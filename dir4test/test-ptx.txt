# -*- coding: utf-8 -*-
import os
import sys
import gym
import numpy as np
import random
import keras
from keras.models import Sequential
from keras.layers import Dense, Embedding, LSTM, Bidirectional
from keras.optimizers import Adam

from collections import deque

from src.coreutils_gym_env import CoreutilsEnv, CoreutilsInfo
from src.utils.config import uroboros_env, instrs_size, max_ops_len
from coreutils_callable_env import *
import src.utils.log as log

from multiprocessing import Process, Pipe
from time import sleep


def sub_process_env_step(env, conn):
    done = False
    while not done:
        action = conn.recv()
        res = env.step(action)
        done = res[2]
        conn.send(res)
    conn.close()


class DQN:
    def __init__(self, env, model_path=None):
        self.env     = env
        self.memory  = deque(maxlen=1000)

        self.gamma = 1.0
        self.epsilon = 0.5
        self.epsilon_min = 0.01
        self.epsilon_decay = 0.99
        self.learning_rate = 0.0001
        self.learning_decay = 0.5
        self.tau = .125

        self._action_space = self.env.action_space

        if model_path:
            self.load_model(model_path)
        else:
            self.init_model()


    def init_model(self):
        self.model = self.create_model()
        self.target_model = self.create_model()

    def load_model(self, model_path):
        try:
            self.model = keras.models.load_model(model_path)
            self.target_model = self.create_model()
            #self.target_model = keras.models.load_model(model_path)
            self.set_lr(self.learning_rate)
        except Exception as e:
            log.log('cannot load model from %s' % model_path, log.LogType.ERROR)
            log.log(str(e), log.LogType.ERROR)
            self.init_model()

    def create_model(self):
        model   = Sequential()
        state_shape  = self.env.observation_space.shape
        #model.add(Embedding(input_dim=instrs_size, output_dim=2, input_length=state_shape[0]))
        model.add(Bidirectional(LSTM(units=512, return_sequences=True)))
        model.add(LSTM(units=512))
        model.add(Dense(units=512, activation='relu'))
        model.add(Dense(units=self._action_space.n))
        model.compile(loss="mean_squared_error",
            optimizer=Adam(lr=self.learning_rate))
        return model

    def set_lr(self, lr):
        current_lr = keras.backend.eval(self.model.optimizer.lr)
        log.log('set learning rate from %f to %f' % (current_lr, lr), log.LogType.WARNING)
        self.learning_rate = lr
        keras.backend.set_value(self.model.optimizer.lr, self.learning_rate)
        keras.backend.set_value(self.target_model.optimizer.lr, self.learning_rate)

    def reduce_lr(self):
        new_learning_rate = self.learning_rate * self.learning_decay
        log.log('reduce learning rate from %f to %f' % (self.learning_rate, new_learning_rate))
        self.learning_rate = new_learning_rate
        keras.backend.set_value(self.model.optimizer.lr, self.learning_rate)
        keras.backend.set_value(self.target_model.optimizer.lr, self.learning_rate)

    def act(self, state):
        self.epsilon *= self.epsilon_decay
        self.epsilon = max(self.epsilon_min, self.epsilon)
        if np.random.random() < self.epsilon:
            return self._action_space.sample()
        return np.argmax(self.model.predict(state)[0])

    def remember(self, state, action, reward, new_state, done):
        self.memory.append([state, action, reward, new_state, done])

    def replay(self):
        batch_size = 128
        if len(self.memory) < batch_size:
            batch_size = len(self.memory)

        samples = random.sample(self.memory, batch_size)
        X = []
        y = []
        for sample in samples:
            state, action, reward, new_state, done = sample
            target = self.target_model.predict(state)
            if done:
                target[0][action] = reward
            else:
                Q_future = max(self.target_model.predict(new_state)[0])
                target[0][action] = reward + Q_future * self.gamma
            X.append(state)
            y.append(target)
        X = np.array(X).reshape(batch_size, 1, max_ops_len)
        y = np.array(y).reshape(batch_size, self._action_space.n)
        log.log('training ...', log.LogType.INFO)
        self.model.fit(X, y, epochs=1, verbose=0)

    def target_train(self):
        weights = self.model.get_weights()
        target_weights = self.target_model.get_weights()
        for i in range(len(target_weights)):
            target_weights[i] = weights[i] * self.tau + target_weights[i] * (1 - self.tau)
        self.target_model.set_weights(target_weights)

    def save_model(self, fn, iteration):
        if not os.path.isdir(fn):
            os.mkdir(fn)
        file_path = os.path.join(fn, 'dqn_model-%d.h5' % iteration)
        self.model.save(file_path)


def finish_an_episode(envs, dqn_agent):
    num = len(envs)
    finished = [False for _ in range(num)]
    cur_states = [env.reset().reshape(1, 1, max_ops_len) for env in envs]
    conns = [Pipe() for _ in range(num)]
    processes = [Process(target=sub_process_env_step, args=(envs[idx], conns[idx][1])) for idx in range(num)]
    for p in processes:
        p.start()
    while True:
        has_active = False
        actions = [-1 for _ in range(num)]
        for idx in range(num):
            if not finished[idx]:
                has_active = True
                action = dqn_agent.act(cur_states[idx])
                conns[idx][0].send(action)
                sleep(0.5)
                actions[idx] = action
        if not has_active:
            break
        for idx in range(num):
            if not finished[idx]:
                new_state, reward, done, log_dict = conns[idx][0].recv()
                new_state = new_state.reshape(1, 1, max_ops_len)
                if log_dict['reset']:  # error process
                    finished[idx] = True
                    continue
                else:
                    finished[idx] = done
                    if done:
                        conns[idx][0].close()
                dqn_agent.remember(cur_states[idx], actions[idx], reward, new_state, done)
                cur_states[idx] = new_state
    for _ in range(3):
        dqn_agent.replay()       # internally iterates default (prediction) model
    dqn_agent.target_train() # iterates target mode
    for p in processes:
        p.join()



def main():
    num_iterations  = 100

    # updateTargetNetwork = 1000
    dqn_agent = DQN(env=train_envs[0], model_path=None)
    for iteration in range(1, num_iterations+1):
        for env in train_envs:
            env.set_episode_count(iteration)
        finish_an_episode(train_envs, dqn_agent)
        if iteration % 5 == 0:
            dqn_agent.save_model('/home/hwangdz/export-d1/rl-select-div-out/checkpoints', iteration)
        if iteration % 20 == 0:
            dqn_agent.reduce_lr()

    #for iteration in range(num_iterations):
    #    finish_episode = False
    #    cur_state = env.reset().reshape(1, 1, max_ops_len)
    #    while not finish_episode:
    #        action = dqn_agent.act(cur_state)
    #        new_state, reward, done, log_dict = env.step(action)
    #        new_state = new_state.reshape(1, 1, max_ops_len)
    #        if log_dict['reset']:
    #            finish_episode = True
    #            break
    #        else:
    #            finish_episode = done
    #        # reward = reward if not done else -20
    #        dqn_agent.remember(cur_state, action, reward, new_state, done)

    #        dqn_agent.replay()       # internally iterates default (prediction) model
    #        dqn_agent.target_train() # iterates target model
    #        cur_state = new_state


if __name__ == "__main__":
    main()
from src.coreutils_gym_env import *

iteration_num = 20
test_times=5
#trainning environments
b2sum_train_env_1_info = CoreutilsInfo(test_id='b2sum_train_env_1', exe_bin_path='/home/hwangdz/rl-select-div-out/train/test/train_1', save_bins_dir='/home/hwangdz/rl-select-div-out/train/save/train_1', test_params=['/home/hwangdz/opengl32sw.dll-truncate'], uroboros_dir='/home/hwangdz/rl-select-div-out/train/uroboros/train_1', uroboros_env=uroboros_env, src_bin_path='/home/hwangdz/git/rl-select-div/samples/b2sum')
b2sum_train_env_1 = CoreutilsEnv(b2sum_train_env_1_info, '/home/hwangdz/rl-select-div-out/train/env/train_1', max_itr=iteration_num, test_times=test_times, _original_cost=None)


b2sum_train_env_2_info = CoreutilsInfo(test_id='b2sum_train_env_2', exe_bin_path='/home/hwangdz/rl-select-div-out/train/test/train_2', save_bins_dir='/home/hwangdz/rl-select-div-out/train/save/train_2', test_params=['/home/hwangdz/opengl32sw.dll-truncate'], uroboros_dir='/home/hwangdz/rl-select-div-out/train/uroboros/train_2', uroboros_env=uroboros_env, src_bin_path='/home/hwangdz/git/rl-select-div/samples/b2sum')
b2sum_train_env_2 = CoreutilsEnv(b2sum_train_env_2_info, '/home/hwangdz/rl-select-div-out/train/env/train_2', max_itr=iteration_num, test_times=test_times, _original_cost=None)


b2sum_train_env_3_info = CoreutilsInfo(test_id='b2sum_train_env_3', exe_bin_path='/home/hwangdz/rl-select-div-out/train/test/train_3', save_bins_dir='/home/hwangdz/rl-select-div-out/train/save/train_3', test_params=['/home/hwangdz/opengl32sw.dll-truncate'], uroboros_dir='/home/hwangdz/rl-select-div-out/train/uroboros/train_3', uroboros_env=uroboros_env, src_bin_path='/home/hwangdz/git/rl-select-div/samples/b2sum')
b2sum_train_env_3 = CoreutilsEnv(b2sum_train_env_3_info, '/home/hwangdz/rl-select-div-out/train/env/train_3', max_itr=iteration_num, test_times=test_times, _original_cost=None)


b2sum_train_env_4_info = CoreutilsInfo(test_id='b2sum_train_env_4', exe_bin_path='/home/hwangdz/rl-select-div-out/train/test/train_4', save_bins_dir='/home/hwangdz/rl-select-div-out/train/save/train_4', test_params=['/home/hwangdz/opengl32sw.dll-truncate'], uroboros_dir='/home/hwangdz/rl-select-div-out/train/uroboros/train_4', uroboros_env=uroboros_env, src_bin_path='/home/hwangdz/git/rl-select-div/samples/b2sum')
b2sum_train_env_4 = CoreutilsEnv(b2sum_train_env_4_info, '/home/hwangdz/rl-select-div-out/train/env/train_4', max_itr=iteration_num, test_times=test_times, _original_cost=None)


b2sum_train_env_5_info = CoreutilsInfo(test_id='b2sum_train_env_5', exe_bin_path='/home/hwangdz/rl-select-div-out/train/test/train_5', save_bins_dir='/home/hwangdz/rl-select-div-out/train/save/train_5', test_params=['/home/hwangdz/opengl32sw.dll-truncate'], uroboros_dir='/home/hwangdz/rl-select-div-out/train/uroboros/train_5', uroboros_env=uroboros_env, src_bin_path='/home/hwangdz/git/rl-select-div/samples/b2sum')
b2sum_train_env_5 = CoreutilsEnv(b2sum_train_env_5_info, '/home/hwangdz/rl-select-div-out/train/env/train_5', max_itr=iteration_num, test_times=test_times, _original_cost=None)


b2sum_train_env_6_info = CoreutilsInfo(test_id='b2sum_train_env_6', exe_bin_path='/home/hwangdz/rl-select-div-out/train/test/train_6', save_bins_dir='/home/hwangdz/rl-select-div-out/train/save/train_6', test_params=['/home/hwangdz/opengl32sw.dll-truncate'], uroboros_dir='/home/hwangdz/rl-select-div-out/train/uroboros/train_6', uroboros_env=uroboros_env, src_bin_path='/home/hwangdz/git/rl-select-div/samples/b2sum')
b2sum_train_env_6 = CoreutilsEnv(b2sum_train_env_6_info, '/home/hwangdz/rl-select-div-out/train/env/train_6', max_itr=iteration_num, test_times=test_times, _original_cost=None)



#evaluating environments
train_envs = [b2sum_train_env_1, b2sum_train_env_2, b2sum_train_env_3, b2sum_train_env_4, b2sum_train_env_5, b2sum_train_env_6]

# -*- coding: utf-8 -*-
import os
import sys
# use this file to create all environments for trainning and evaluating by coreutils
# currently we merely test sha1sum, sha224sum, sha256sum, sha512sum, ls

binaries = ['sha1sum', 'sha224sum', 'sha256sum', 'sha384sum', 'sha512sum', 'ls'
                                                                           'dir', 'b2sum', 'md5sum', 'base64']

# the parameters for testing the output binaries, and the original running cost
# to run all these binaries at the same time makes the time result inaccurate
train_bin_dict = {
    'sha1sum': (['/home/hwangdz/opengl32sw.dll'], 124.995809),
    'sha224sum': (['/home/hwangdz/opengl32sw.dll'], 215.163173),
    'sha256sum': (['/home/hwangdz/opengl32sw.dll-truncate'], None),
    'b2sum': (['/home/hwangdz/opengl32sw.dll-truncate'], None),
    'md5sum': (['/home/hwangdz/opengl32sw.dll'], 183.949734),
    'sha384sum': (['/home/hwangdz/opengl32sw.dll-truncate'], 45.117974),
    'sha512sum': (['/home/hwangdz/opengl32sw.dll-truncate'], None),
    'ls': (['-lRa', '/home/hwangdz/coreutils/coreutils-8.28'], None),
    'sort': (['/home/hwangdz/git/rl-select-div/test-sort.txt'], 52.998467),
    'tsort': (['/home/hwangdz/git/rl-select-div/test-sort.txt'], None),
    #'factor': (['151111111111111111111111111111111123459', '151111111111111111111111111111111123410'], None),
    'shuf': (['/home/hwangdz/git/rl-select-div/test-shuf.txt'], 30.911404),
    'sum': (['/home/hwangdz/opengl32sw.dll-truncate-10M'], None),
    'uniq': (['/home/hwangdz/git/rl-select-div/test-shuf.txt'], None),
    'join': (['/home/hwangdz/git/rl-select-div/test-sort.txt', '/home/hwangdz/git/rl-select-div/test-shuf.txt'], None),
    'nl': (['/home/hwangdz/git/rl-select-div/test-shuf.txt'], None),
    'comm': (['/home/hwangdz/git/rl-select-div/test-comm1.txt', '/home/hwangdz/git/rl-select-div/test-comm2.txt'], None),
    'cat': (['/home/hwangdz/opengl32sw.dll', '/home/hwangdz/opengl32sw.dll-truncate-10M'], None),
    'tail': (['/home/hwangdz/opengl32sw.dll', '-n', '100000'], None),
    'wc': (['/home/hwangdz/git/rl-select-div/test-shuf.txt'], None),

}

eval_bin_dict = {
    'dir': (['-lRa', '/home/hwangdz/coreutils/coreutils-8.28'], None),
    'sha384sum': (['/home/hwangdz/opengl32sw.dll'], None),
    'sha512sum': (['/home/hwangdz/opengl32sw.dll'], None),
    'md5sum': (['/home/hwangdz/opengl32sw.dll'], None),
    'base64': (['/home/hwangdz/opengl32sw.dll-truncate'], None)
}

# you should have all bins here
src_coreutils_path = '/home/hwangdz/git/rl-select-div/samples'

# directory for all trainning, evaluating
# save it to a ssd
output_dir = '/home/hwangdz/rl-select-div-out/'

uroboros_url = 'https://github.com/whj0401/uroboros.git'
#src_uroboros = None
src_uroboros = '/home/hwangdz/git/uroboros'

head_lines = """from src.coreutils_env import *
from src.callable_env import CallableEnv
from tf_agents.environments.parallel_py_environment import ParallelPyEnvironment

iteration_num = 30
test_times=5"""

gym_head_lines = """from src.coreutils_gym_env import *

iteration_num = 20
test_times=5"""

def create_an_env(test_id,
                  exe_bin_path,
                  save_bins_dir,
                  test_params,
                  original_cost,
                  uroboros_dir,
                  # uroboros_env,
                  src_bin_path,
                  env_path):
    # use test_id as the class name
    res =  "class %s(CallableEnv):\n" % test_id
    res += "    def __init__(self):\n"
    res += "        super(%s, self).__init__()\n" % test_id
    res += "        info = CoreutilsInfo(test_id=\'%s\', exe_bin_path=\'%s\', save_bins_dir=\'%s\', test_params=%s, uroboros_dir=\'%s\', uroboros_env=uroboros_env, src_bin_path=\'%s\')\n" % (
    test_id, exe_bin_path, save_bins_dir, str(test_params), uroboros_dir, src_bin_path)
    res += "        self._env = CoreutilsEnv(info, \'%s\', max_itr=iteration_num, test_times=test_times, _original_cost=%s)\n\n" % (env_path, str(original_cost))
    return res


def create_an_gym_env(test_id,
                      exe_bin_path,
                      save_bins_dir,
                      test_params,
                      original_cost,
                      uroboros_dir,
                      src_bin_path,
                      env_path):
    res = "%s_info = CoreutilsInfo(test_id=\'%s\', exe_bin_path=\'%s\', save_bins_dir=\'%s\', test_params=%s, uroboros_dir=\'%s\', uroboros_env=uroboros_env, src_bin_path=\'%s\')\n" % (
    test_id, test_id, exe_bin_path, save_bins_dir, str(test_params), uroboros_dir, src_bin_path)
    res += "%s = CoreutilsEnv(%s_info, \'%s\', max_itr=iteration_num, test_times=test_times, _original_cost=%s)\n\n" % (test_id, test_id, env_path, str(original_cost))
    return res


def build_env(bin_dict: dict, mode='train'):
    count = 0
    result = ''
    global src_uroboros
    pe_str = 'parallel_%s_env = ParallelPyEnvironment([' % mode
    base_dir = os.path.join(output_dir, mode)
    os.mkdir(base_dir)
    base_exe_bin_path = os.path.join(base_dir, 'test')
    os.mkdir(base_exe_bin_path)
    base_save_bins_dir = os.path.join(base_dir, 'save')
    os.mkdir(base_save_bins_dir)
    base_env_path = os.path.join(base_dir, 'env')
    os.mkdir(base_env_path)
    base_uroboros_dir = os.path.join(base_dir, 'uroboros')
    os.mkdir(base_uroboros_dir)

    for b, params in bin_dict.items():
        count += 1
        test_id = b + '_' + mode + '_env' + '_' + str(count)
        exe_bin_path = os.path.join(base_exe_bin_path, '%s_%d' % (mode, count))
        save_bins_dir = os.path.join(base_save_bins_dir, '%s_%d' % (mode, count))
        os.mkdir(save_bins_dir)
        env_path = os.path.join(base_env_path, '%s_%d' % (mode, count))
        os.mkdir(env_path)
        uroboros_dir = os.path.join(base_uroboros_dir, '%s_%d' % (mode, count))
        src_bin_path = os.path.join(src_coreutils_path, b)
        # clone uroboros
        if src_uroboros is None:
            ret = os.system('git clone %s %s && cd %s && git reset --hard 5edd5b4aa701e67550477020776c9e7f496422f1' % (uroboros_url, uroboros_dir, uroboros_dir))
            assert ret == 0, 'failed to clone uroboros'
            src_uroboros = uroboros_dir
        else:
            os.system('cp -r %s %s' % (src_uroboros, uroboros_dir))
        # string for this environment
        env_str = create_an_env(test_id, exe_bin_path, save_bins_dir, params[0], params[1], uroboros_dir, src_bin_path, env_path)
        result += env_str + '\n'
        pe_str += test_id + ', '
    pe_str = pe_str[:-2]
    pe_str += '], start_serially=False, flatten=True)'

    return result, pe_str


def build_gym_env(bin_dict: dict, mode='train'):
    count = 0
    result = ''
    global src_uroboros
    pe_str = '%s_envs = [' % mode
    base_dir = os.path.join(output_dir, mode)
    os.mkdir(base_dir)
    base_exe_bin_path = os.path.join(base_dir, 'test')
    os.mkdir(base_exe_bin_path)
    base_save_bins_dir = os.path.join(base_dir, 'save')
    os.mkdir(base_save_bins_dir)
    base_env_path = os.path.join(base_dir, 'env')
    os.mkdir(base_env_path)
    base_uroboros_dir = os.path.join(base_dir, 'uroboros')
    os.mkdir(base_uroboros_dir)

    for b, params in bin_dict.items():
        count += 1
        test_id = b + '_' + mode + '_env' + '_' + str(count)
        exe_bin_path = os.path.join(base_exe_bin_path, '%s_%d' % (mode, count))
        save_bins_dir = os.path.join(base_save_bins_dir, '%s_%d' % (mode, count))
        os.mkdir(save_bins_dir)
        env_path = os.path.join(base_env_path, '%s_%d' % (mode, count))
        os.mkdir(env_path)
        uroboros_dir = os.path.join(base_uroboros_dir, '%s_%d' % (mode, count))
        src_bin_path = os.path.join(src_coreutils_path, b)
        if src_uroboros is None:
            ret = os.system('git clone %s %s && cd %s && git reset --hard 5edd5b4aa701e67550477020776c9e7f496422f1' % (uroboros_url, uroboros_dir, uroboros_dir))
            assert ret == 0, 'failed to clone uroboros'
            src_uroboros = uroboros_dir
        else:
            os.system('cp -r %s %s' % (src_uroboros, uroboros_dir))
        env_str = create_an_gym_env(test_id, exe_bin_path, save_bins_dir, params[0], params[1], uroboros_dir, src_bin_path, env_path)
        result += env_str + '\n'
        pe_str += test_id + ', '
    pe_str = pe_str[:-2] + ']'
    return result, pe_str

def build_gym_env2(bin_name, params, cost_time, mode='train'):
    result = ''
    global src_uroboros
    pe_str = '%s_envs = [' % mode
    base_dir = os.path.join(output_dir, mode)
    os.mkdir(base_dir)
    base_exe_bin_path = os.path.join(base_dir, 'test')
    os.mkdir(base_exe_bin_path)
    base_save_bins_dir = os.path.join(base_dir, 'save')
    os.mkdir(base_save_bins_dir)
    base_env_path = os.path.join(base_dir, 'env')
    os.mkdir(base_env_path)
    base_uroboros_dir = os.path.join(base_dir, 'uroboros')
    os.mkdir(base_uroboros_dir)
    for i in range(1, 7):
        count = i
        test_id = bin_name + '_' + mode + '_env' + '_' + str(count)
        exe_bin_path = os.path.join(base_exe_bin_path, '%s_%d' % (mode, count))
        save_bins_dir = os.path.join(base_save_bins_dir, '%s_%d' % (mode, count))
        os.mkdir(save_bins_dir)
        env_path = os.path.join(base_env_path, '%s_%d' % (mode, count))
        os.mkdir(env_path)
        uroboros_dir = os.path.join(base_uroboros_dir, '%s_%d' % (mode, count))
        src_bin_path = os.path.join(src_coreutils_path, bin_name)
        if src_uroboros is None:
            ret = os.system('git clone %s %s' % (uroboros_url, uroboros_dir))
            assert ret == 0, 'failed to clone uroboros'
            src_uroboros = uroboros_dir
        else:
            os.system('cp -r %s %s' % (src_uroboros, uroboros_dir))
        env_str = create_an_gym_env(test_id, exe_bin_path, save_bins_dir, params, cost_time, uroboros_dir, src_bin_path, env_path)
        result += env_str + '\n'
        pe_str += test_id + ', '
    pe_str = pe_str[:-2] + ']'
    return result, pe_str

if __name__ == "__main__":
    callable_file = sys.argv[2] + '.py'
    if not os.path.isdir(output_dir):
        os.mkdir(output_dir)
    if sys.argv[1] == 'tf_agents':
        local_head_lines = head_lines
        train_define_str, train_pe_str = build_env(train_bin_dict, 'train')
        eval_define_str, eval_pe_str = build_env(eval_bin_dict, 'eval')
    elif sys.argv[1] == 'gym':
        local_head_lines = gym_head_lines
        train_define_str, train_pe_str = build_gym_env(train_bin_dict, 'train')
        eval_define_str, eval_pe_str = '', ''  #build_gym_env(eval_bin_dict, 'eval')
    elif sys.argv[1] == 'gym2':
        local_head_lines = gym_head_lines
        bin_name = sys.argv[3]
        params, time_cost = train_bin_dict[bin_name]
        train_define_str, train_pe_str = build_gym_env2(bin_name, params, time_cost)
        eval_define_str, eval_pe_str = '', ''  #build_gym_env(eval_bin_dict, 'eval')
    else:
        assert False

    with open(callable_file, 'w') as f:
        f.write(local_head_lines)
        f.write('\n#trainning environments\n')
        f.write(train_define_str)
        f.write('\n#evaluating environments\n')
        f.write(eval_define_str)
        f.write(train_pe_str)
        f.write('\n')
        f.write(eval_pe_str)
        f.write('\n')



"""
Main module
"""

import glob
import os
import shutil
import sys
from argparse import ArgumentParser, RawTextHelpFormatter

from termcolor import colored

import config


def process(filepath, instrument=False, fexclude=''):
    """
    Start file processing
    :param filepath: path to executable
    :param instrument: True to apply instrumentation
    :param fexclude: path to file of symbol exclusions
    :return: True if everything ok
    """
    import init
    import traceback
    from postprocess import compile_process
    from disasm import main_discover, func_addr

    print "Starting to process binary '" + filepath + "'"
    try:

        func_addr.func_addr(filepath, 0, fexclude)

        os.system(config.strip + ' ' + filepath)
        main_discover.main_discover(filepath)

        init.main(filepath, instrument)
        if not os.path.isfile("final.s"): return False

        with open('final_data.s', 'a') as f:
            f.write('\n.section .eh_frame\n')
            with open('eh_frame_split.info') as eh: f.write(eh.read())
            f.write('\n.section .eh_frame_hdr\n')
            with open('eh_frame_hdr_split.info') as eh: f.write(eh.read())
        with open('final.s', 'a') as f:
            with open('final_data.s', 'r') as fd: f.write(fd.read())
            if instrument: f.write('\n\n'.join(map(lambda e: e['plain'].instrdata, config.instrumentors)))

        compile_process.main(filepath)
        if instrument:
            for worker in config.instrumentors:
                worker['main'].aftercompile()
        if compile_process.reassemble() != 0: return False

    except Exception as e:
        print e
        traceback.print_exc()
        return False

    return True


def check(filepath, assumptions, gccopt='', excludedata='', instrument=False):
    """
    Perform basic check on analyzed executable and set configuration values
    :param filepath: path to executable
    :param assumptions: list of assumption codes
    :param gccopt: additional options for the compiler
    :param excludedata: path to file of address exclusions
    :param instrument: True if instrumentation enabled
    :return: True if everything ok
    """
    if not assumptions: assumptions = []

    if not os.path.isfile(filepath):
        sys.stderr.write("Cannot find input binary\n")
        return False

    if len(excludedata) != 0 and not os.path.isfile(excludedata):
        sys.stderr.write("File with exclusions not found\n")
        return False

    for f in glob.glob('*'): os.remove(f)

    if os.path.dirname(filepath) != os.getcwd():
        shutil.copy(filepath, '.')

    os.system('file ' + filepath + ' > elf.info')
    config.setup(filepath, gccopt, excludedata, instrument)

    if config.is_lib:
        sys.stderr.write("Uroboros doesn't support shared libraries\n")
        return False

    # if assumption three is utilized, then input binary should be unstripped.
    if ('3' in assumptions or instrument) and not config.is_unstrip:
        print colored('Warning:', 'yellow'), 'binary is stripped, function boundaries evaluation may not be precise'

    return True


def set_assumption (assumptions):
    """
    Save assumptions to file
    2 -> assumption two: fix data section starting address
    3 -> assumption three: function starting address + jump table
    :param assumptions: list of assumptions codes
    :return: True if everything ok
    """
    if not assumptions:
        with open('assumption_set.info', 'w') as f:
            f.write('1\n')
    else:
        chk = (i in ['2', '3'] for i in assumptions)
        if any(chk) == False:
            print "assumption undefined!"
            print "accepted assumptions: 2 for assumption two and 3 for assumption three"
            return False
        with open('assumption_set.info', 'w') as f:
            f.write(' '.join(assumptions) + '\n')
    return True


def set_diversification(d, iter):
    if d not in config.all_diver_modes:
        assert False, 'unrecognizible diversification mode %d for iteration %d' % (d, iter)
    config.diversification_mode = d
    print 'set diversification mode %d for iteration %d' % (d, iter)
    os.system('echo %d > mode' % d)


def reset_diversification():
    config.diversification_mode = 0


def main():
    """
    Main function
    """
    p = ArgumentParser(formatter_class=RawTextHelpFormatter)
    p.add_argument("binary", help="path to the input binary")
    p.add_argument("-o", "--output", help="destination output file")
    p.add_argument("-g", "--instrument", action='store_true', help="apply instrumentations to output")
    p.add_argument("-a", "--assumption", action="append",
                   help='''this option configures three addtional assumption,
note that two basic assumptions and addtional assumption one
(n-byte alignment) are set by default,
while assumption two and three need to be configured. For example, setting
assumption two and three: -a 2 -a 3''')
    p.add_argument("-gcc", "--gccopt", action="store", default="", help="A string of additional arguments for GCC")
    p.add_argument("-ex", "--exclude", default="", help="""File where each line is either a single value which must not be
a label or an address range of data section to exclude from symbol search""")
    p.add_argument("-fex", "--functionexclude", default="", help="File with a list of symbols not representing functions")
    p.add_argument("--version", action="version", version="Uroboros 0.2b")

    p.add_argument('-i', '--iteration', type=int, help='the number of disassemble-diversify-reassemble iterations')
    p.add_argument('-d', '--diversification', type=int, action='append',
                   help='the sequence of diversification for every iteration \n' + config.diversification_description)

    args = p.parse_args()
    filepath = os.path.realpath(args.binary)
    outpath = os.path.realpath(args.output) if args.output is not None else None
    exclude = os.path.realpath(args.exclude) if len(args.exclude) > 0 else ''
    fexclude = os.path.realpath(args.functionexclude) if len(args.functionexclude) > 0 else ''

    num_iteration = args.iteration
    if num_iteration is None or num_iteration <= 0:
        num_iteration = 1

    diversifications = args.diversification
    if diversifications is None:
        diversifications = [0]
    while len(diversifications) < num_iteration:
        diversifications.append(diversifications[-1])

    abs_path = os.path.dirname(os.path.abspath(__file__))

    for i in range(1, num_iteration + 1):
        workdir = abs_path + '/workdir_' + str(i)
        if not os.path.isdir(workdir):
            os.mkdir(workdir)

        print colored(('iteration %d dir:' + workdir) % i, 'green')
        os.chdir(workdir)
        # run after setting the work directory
        set_diversification(diversifications[i - 1], i)

        if check(filepath, args.assumption, args.gccopt, exclude, args.instrument) and set_assumption(args.assumption):
            if process(os.path.basename(filepath), args.instrument, fexclude):
                os.system('strip a.out')
                print colored("Processing %d succeeded" % i, "blue")
                if outpath is not None:
                    shutil.copy('a.out', outpath + '_' + str(i) + '_mode_' + str(config.diversification_mode))
                    shutil.copy('a.out', outpath)
                # change source file path
                filepath = workdir + '/a.out'
            else:
                print colored("Processing %d failed" % i, "red")
                exit(1)
        reset_diversification()


if __name__ == "__main__":
    main()
"""
Main module
"""

import glob
import os
import shutil
import sys
from argparse import ArgumentParser, RawTextHelpFormatter

from termcolor import colored

import config


def process(filepath, instrument=False, fexclude=''):
    """
    Start file processing
    :param filepath: path to executable
    :param instrument: True to apply instrumentation
    :param fexclude: path to file of symbol exclusions
    :return: True if everything ok
    """
    import init
    import traceback
    from postprocess import compile_process
    from disasm import main_discover, func_addr

    print "Starting to process binary '" + filepath + "'"
    try:

        func_addr.func_addr(filepath, 0, fexclude)

        os.system(config.strip + ' ' + filepath)
        main_discover.main_discover(filepath)

        init.main(filepath, instrument)
        if not os.path.isfile("final.s"): return False

        with open('final_data.s', 'a') as f:
            f.write('\n.section .eh_frame\n')
            with open('eh_frame_split.info') as eh: f.write(eh.read())
            f.write('\n.section .eh_frame_hdr\n')
            with open('eh_frame_hdr_split.info') as eh: f.write(eh.read())
        with open('final.s', 'a') as f:
            with open('final_data.s', 'r') as fd: f.write(fd.read())
            if instrument: f.write('\n\n'.join(map(lambda e: e['plain'].instrdata, config.instrumentors)))

        compile_process.main(filepath)
        if instrument:
            for worker in config.instrumentors:
                worker['main'].aftercompile()
        if compile_process.reassemble() != 0: return False

    except Exception as e:
        print e
        traceback.print_exc()
        return False

    return True


def check(filepath, assumptions, gccopt='', excludedata='', instrument=False):
    """
    Perform basic check on analyzed executable and set configuration values
    :param filepath: path to executable
    :param assumptions: list of assumption codes
    :param gccopt: additional options for the compiler
    :param excludedata: path to file of address exclusions
    :param instrument: True if instrumentation enabled
    :return: True if everything ok
    """
    if not assumptions: assumptions = []

    if not os.path.isfile(filepath):
        sys.stderr.write("Cannot find input binary\n")
        return False

    if len(excludedata) != 0 and not os.path.isfile(excludedata):
        sys.stderr.write("File with exclusions not found\n")
        return False

    for f in glob.glob('*'): os.remove(f)

    if os.path.dirname(filepath) != os.getcwd():
        shutil.copy(filepath, '.')

    os.system('file ' + filepath + ' > elf.info')
    config.setup(filepath, gccopt, excludedata, instrument)

    if config.is_lib:
        sys.stderr.write("Uroboros doesn't support shared libraries\n")
        return False

    # if assumption three is utilized, then input binary should be unstripped.
    if ('3' in assumptions or instrument) and not config.is_unstrip:
        print colored('Warning:', 'yellow'), 'binary is stripped, function boundaries evaluation may not be precise'

    return True


def set_assumption (assumptions):
    """
    Save assumptions to file
    2 -> assumption two: fix data section starting address
    3 -> assumption three: function starting address + jump table
    :param assumptions: list of assumptions codes
    :return: True if everything ok
    """
    if not assumptions:
        with open('assumption_set.info', 'w') as f:
            f.write('1\n')
    else:
        chk = (i in ['2', '3'] for i in assumptions)
        if any(chk) == False:
            print "assumption undefined!"
            print "accepted assumptions: 2 for assumption two and 3 for assumption three"
            return False
        with open('assumption_set.info', 'w') as f:
            f.write(' '.join(assumptions) + '\n')
    return True


def set_diversification(d, iter):
    if d not in config.all_diver_modes:
        assert False, 'unrecognizible diversification mode %d for iteration %d' % (d, iter)
    config.diversification_mode = d
    print 'set diversification mode %d for iteration %d' % (d, iter)
    os.system('echo %d > mode' % d)


def reset_diversification():
    config.diversification_mode = 0


def main():
    """
    Main function
    """
    p = ArgumentParser(formatter_class=RawTextHelpFormatter)
    p.add_argument("binary", help="path to the input binary")
    p.add_argument("-o", "--output", help="destination output file")
    p.add_argument("-g", "--instrument", action='store_true', help="apply instrumentations to output")
    p.add_argument("-a", "--assumption", action="append",
                   help='''this option configures three addtional assumption,
note that two basic assumptions and addtional assumption one
(n-byte alignment) are set by default,
while assumption two and three need to be configured. For example, setting
assumption two and three: -a 2 -a 3''')
    p.add_argument("-gcc", "--gccopt", action="store", default="", help="A string of additional arguments for GCC")
    p.add_argument("-ex", "--exclude", default="", help="""File where each line is either a single value which must not be
a label or an address range of data section to exclude from symbol search""")
    p.add_argument("-fex", "--functionexclude", default="", help="File with a list of symbols not representing functions")
    p.add_argument("--version", action="version", version="Uroboros 0.2b")

    p.add_argument('-i', '--iteration', type=int, help='the number of disassemble-diversify-reassemble iterations')
    p.add_argument('-d', '--diversification', type=int, action='append',
                   help='the sequence of diversification for every iteration \n' + config.diversification_description)

    args = p.parse_args()
    filepath = os.path.realpath(args.binary)
    outpath = os.path.realpath(args.output) if args.output is not None else None
    exclude = os.path.realpath(args.exclude) if len(args.exclude) > 0 else ''
    fexclude = os.path.realpath(args.functionexclude) if len(args.functionexclude) > 0 else ''

    num_iteration = args.iteration
    if num_iteration is None or num_iteration <= 0:
        num_iteration = 1

    diversifications = args.diversification
    if diversifications is None:
        diversifications = [0]
    while len(diversifications) < num_iteration:
        diversifications.append(diversifications[-1])

    abs_path = os.path.dirname(os.path.abspath(__file__))

    for i in range(1, num_iteration + 1):
        workdir = abs_path + '/workdir_' + str(i)
        if not os.path.isdir(workdir):
            os.mkdir(workdir)

        print colored(('iteration %d dir:' + workdir) % i, 'green')
        os.chdir(workdir)
        # run after setting the work directory
        set_diversification(diversifications[i - 1], i)

        if check(filepath, args.assumption, args.gccopt, exclude, args.instrument) and set_assumption(args.assumption):
            if process(os.path.basename(filepath), args.instrument, fexclude):
                os.system('strip a.out')
                print colored("Processing %d succeeded" % i, "blue")
                if outpath is not None:
                    shutil.copy('a.out', outpath + '_' + str(i) + '_mode_' + str(config.diversification_mode))
                    shutil.copy('a.out', outpath)
                # change source file path
                filepath = workdir + '/a.out'
            else:
                print colored("Processing %d failed" % i, "red")
                exit(1)
        reset_diversification()


if __name__ == "__main__":
    main()
# -*- coding: utf-8 -*-

import os
import sys
import json


def count_opcodes_from_file(file_path):
    with open(file_path, 'r') as f:
        opcodes = f.read().split()
        counter = dict()
        for op in opcodes:
            if op in counter:
                counter[op] += 1
            else:
                counter[op] = 1
        return counter


def count_from_files(files):
    counter = dict()
    for file in files:
        tmp_counter = count_opcodes_from_file(file)
        for op, count in tmp_counter.items():
            if op in counter:
                counter[op] += count
            else:
                counter[op] = count
    return counter


def op_classifier(op_str):
    if op_str.startswith('j') or op_str.startswith('ret') or op_str.startswith('call') or op_str.startswith('lcall'):
        return 'control'
    elif op_str.startswith('push') or op_str.startswith('pop'):
        return 'stack_op'
    elif op_str.startswith('mov'):
        return 'mov'
    else:
        return 'others'


def print_statistics(d):
    s = {
        'control':0, 'stack_op':0, 'mov':0, 'others':0
    }
    total = 0
    for op_str, num in d.items():
        s[op_classifier(op_str)] += num
        total += num
    tmp = {}
    for k in s.keys():
        tmp[k+'_proportion'] = s[k]/total
        print(k + ': %d (%f)' % (s[k], s[k]/total))
    s.update(tmp)
    return s


if __name__ == '__main__':
    directory = sys.argv[1]
    output = sys.argv[2]
    if os.path.isdir(directory):
        file_names = os.listdir(directory)
        for i in range(len(file_names)):
            file_names[i] = os.path.join(directory, file_names[i])
        counter = count_from_files(file_names)
    elif os.path.isfile(directory):
        file_name = directory
        counter = count_opcodes_from_file(file_name)
    else:
        counter = dict()
    data = print_statistics(counter)
    with open(output, 'w') as of:
        json.dump([data, counter], of, indent=2)


# -*- coding: utf-8 -*-

import sys
import os
import json

head_count = 8


def read_headline(f):
    count = 0
    headline_info = []
    while count < head_count:
        line = f.readline().strip()
        if line.startswith('(probability'):
            count += 1
            tmp_info = line.split('<b>')
            headline_info.append((count-1, float(tmp_info[1].split('<')[0]), float(tmp_info[2].split('<')[0])))
    return headline_info


def read_a_table(f):
    while True:
        line = f.readline().strip()
        if line == '<tbody>':
            break

    table_info = []

    while True:
        line = f.readline().strip()
        if line.startswith('<td'):
            line = f.readline().strip()
            contribution = float(line)
            line = f.readline()
            line = f.readline()
            line = f.readline().strip()
            token = line
            table_info.append((contribution, token))
        elif line == '</tbody>':
            break
    return table_info

def read_num_of_opcodes(f):
    while f:
        line = f.readline()
        if len(line) == 0:
            return 1
        line = line.strip()
        if line.startswith('num of opcodes:'):
            num = int(line.split(':')[-1])
            return num
    return 1



def read_a_html_explanation(file_path):
    print('read %s' % file_path)
    with open(file_path, 'r') as f:
        headline_info = read_headline(f)
        table_info = []
        for _ in range(head_count):
            table_info.append(read_a_table(f))
        num_ops = read_num_of_opcodes(f)
    return headline_info, table_info, num_ops


def read_files(files):
    heads = []
    tables = []
    num_ops = []
    for fp in files:
        head, table, num = read_a_html_explanation(fp)
        heads.append(head)
        tables.append(table)
        num_ops.append(num)
    return heads, tables, num_ops


def is_control_token(token):
    if 'j' in token or 'call' in token or 'ret' in token:
        return True
    return False

def is_stack_token(token):
    if 'push' in token or 'pop' in token:
        return True
    return False

def is_mov_token(token):
    if token.startswith('mov'):
        return True
    return False

def is_others(token):
    return not is_control_token(token) and not is_stack_token(token) and not is_mov_token(token)

def count_control_opcodes(files, top_valid=5):
    heads, tables, num_ops = read_files(files)
    data = []
    for i in range(head_count):
        i_data = {'ctl_occ':0, 'ctl_occ_weighted': 0,
                  'stack_occ': 0, 'stack_occ_weighted': 0,
                  'mov_occ': 0, 'mov_occ_weighted': 0,
                  'other_occ': 0, 'other_occ_weighted': 0,
                  'total_ops':0}
        for f_idx in range(len(files)):
            valid = tables[f_idx][i][:top_valid]
            for item in valid:
                contribution, token = item
                # to compute the proportion of control opcodes in top 5
                if is_control_token(token):
                    i_data['ctl_occ'] += 1
                    i_data['ctl_occ_weighted'] += num_ops[f_idx]
                if is_stack_token(token):
                    i_data['stack_occ'] += 1
                    i_data['stack_occ_weighted'] += num_ops[f_idx]
                if is_mov_token(token):
                    i_data['mov_occ'] += 1
                    i_data['mov_occ_weighted'] += num_ops[f_idx]
                if is_others(token):
                    i_data['other_occ'] += 1
                    i_data['other_occ_weighted'] += num_ops[f_idx]
            i_data['total_ops'] += num_ops[f_idx]
        i_data['ctl_proportion_weighted'] = i_data['ctl_occ_weighted'] / i_data['total_ops'] / top_valid
        i_data['ctl_proportion'] = i_data['ctl_occ'] / len(files) / top_valid
        i_data['stack_proportion_weighted'] = i_data['stack_occ_weighted'] / i_data['total_ops'] / top_valid
        i_data['stack_proportion'] = i_data['stack_occ'] / len(files) / top_valid
        i_data['mov_proportion_weighted'] = i_data['mov_occ_weighted'] / i_data['total_ops'] / top_valid
        i_data['mov_proportion'] = i_data['mov_occ'] / len(files) / top_valid
        i_data['other_proportion_weighted'] = i_data['other_occ_weighted'] / i_data['total_ops'] / top_valid
        i_data['other_proportion'] = i_data['other_occ'] / len(files) / top_valid
        data.append(i_data)
    return data


if __name__ == '__main__':
    files = sys.argv[1:]
    data = count_control_opcodes(files)
    with open('ctl_proportion_data', 'w') as f:
        json.dump(data, f, indent=2)



# -*- coding: utf-8 -*-

import os
import sys
import json


def count_opcodes_from_file(file_path):
    with open(file_path, 'r') as f:
        opcodes = f.read().split()
        counter = dict()
        for op in opcodes:
            if op in counter:
                counter[op] += 1
            else:
                counter[op] = 1
        return counter


def count_from_files(files):
    counter = dict()
    for file in files:
        tmp_counter = count_opcodes_from_file(file)
        for op, count in tmp_counter.items():
            if op in counter:
                counter[op] += count
            else:
                counter[op] = count
    return counter


def op_classifier(op_str):
    if op_str.startswith('j') or op_str.startswith('ret') or op_str.startswith('call') or op_str.startswith('lcall'):
        return 'control'
    elif op_str.startswith('push') or op_str.startswith('pop'):
        return 'stack_op'
    elif op_str.startswith('mov'):
        return 'mov'
    else:
        return 'others'


def print_statistics(d):
    s = {
        'control':0, 'stack_op':0, 'mov':0, 'others':0
    }
    total = 0
    for op_str, num in d.items():
        s[op_classifier(op_str)] += num
        total += num
    tmp = {}
    for k in s.keys():
        tmp[k+'_proportion'] = s[k]/total
        print(k + ': %d (%f)' % (s[k], s[k]/total))
    s.update(tmp)
    return s


if __name__ == '__main__':
    directory = sys.argv[1]
    output = sys.argv[2]
    if os.path.isdir(directory):
        file_names = os.listdir(directory)
        for i in range(len(file_names)):
            file_names[i] = os.path.join(directory, file_names[i])
        counter = count_from_files(file_names)
    elif os.path.isfile(directory):
        file_name = directory
        counter = count_opcodes_from_file(file_name)
    else:
        counter = dict()
    data = print_statistics(counter)
    with open(output, 'w') as of:
        json.dump([data, counter], of, indent=2)


# -*- coding: utf-8 -*-

import sys
import os
import json

head_count = 8


def read_headline(f):
    count = 0
    headline_info = []
    while count < head_count:
        line = f.readline().strip()
        if line.startswith('(probability'):
            count += 1
            tmp_info = line.split('<b>')
            headline_info.append((count-1, float(tmp_info[1].split('<')[0]), float(tmp_info[2].split('<')[0])))
    return headline_info


def read_a_table(f):
    while True:
        line = f.readline().strip()
        if line == '<tbody>':
            break

    table_info = []

    while True:
        line = f.readline().strip()
        if line.startswith('<td'):
            line = f.readline().strip()
            contribution = float(line)
            line = f.readline()
            line = f.readline()
            line = f.readline().strip()
            token = line
            table_info.append((contribution, token))
        elif line == '</tbody>':
            break
    return table_info

def read_num_of_opcodes(f):
    while f:
        line = f.readline()
        if len(line) == 0:
            return 1
        line = line.strip()
        if line.startswith('num of opcodes:'):
            num = int(line.split(':')[-1])
            return num
    return 1



def read_a_html_explanation(file_path):
    print('read %s' % file_path)
    with open(file_path, 'r') as f:
        headline_info = read_headline(f)
        table_info = []
        for _ in range(head_count):
            table_info.append(read_a_table(f))
        num_ops = read_num_of_opcodes(f)
    return headline_info, table_info, num_ops


def read_files(files):
    heads = []
    tables = []
    num_ops = []
    for fp in files:
        head, table, num = read_a_html_explanation(fp)
        heads.append(head)
        tables.append(table)
        num_ops.append(num)
    return heads, tables, num_ops


def is_control_token(token):
    if 'j' in token or 'call' in token or 'ret' in token:
        return True
    return False

def is_stack_token(token):
    if 'push' in token or 'pop' in token:
        return True
    return False

def is_mov_token(token):
    if token.startswith('mov'):
        return True
    return False

def is_others(token):
    return not is_control_token(token) and not is_stack_token(token) and not is_mov_token(token)

def count_control_opcodes(files, top_valid=5):
    heads, tables, num_ops = read_files(files)
    data = []
    for i in range(head_count):
        i_data = {'ctl_occ':0, 'ctl_occ_weighted': 0,
                  'stack_occ': 0, 'stack_occ_weighted': 0,
                  'mov_occ': 0, 'mov_occ_weighted': 0,
                  'other_occ': 0, 'other_occ_weighted': 0,
                  'total_ops':0}
        for f_idx in range(len(files)):
            valid = tables[f_idx][i][:top_valid]
            for item in valid:
                contribution, token = item
                # to compute the proportion of control opcodes in top 5
                if is_control_token(token):
                    i_data['ctl_occ'] += 1
                    i_data['ctl_occ_weighted'] += num_ops[f_idx]
                if is_stack_token(token):
                    i_data['stack_occ'] += 1
                    i_data['stack_occ_weighted'] += num_ops[f_idx]
                if is_mov_token(token):
                    i_data['mov_occ'] += 1
                    i_data['mov_occ_weighted'] += num_ops[f_idx]
                if is_others(token):
                    i_data['other_occ'] += 1
                    i_data['other_occ_weighted'] += num_ops[f_idx]
            i_data['total_ops'] += num_ops[f_idx]
        i_data['ctl_proportion_weighted'] = i_data['ctl_occ_weighted'] / i_data['total_ops'] / top_valid
        i_data['ctl_proportion'] = i_data['ctl_occ'] / len(files) / top_valid
        i_data['stack_proportion_weighted'] = i_data['stack_occ_weighted'] / i_data['total_ops'] / top_valid
        i_data['stack_proportion'] = i_data['stack_occ'] / len(files) / top_valid
        i_data['mov_proportion_weighted'] = i_data['mov_occ_weighted'] / i_data['total_ops'] / top_valid
        i_data['mov_proportion'] = i_data['mov_occ'] / len(files) / top_valid
        i_data['other_proportion_weighted'] = i_data['other_occ_weighted'] / i_data['total_ops'] / top_valid
        i_data['other_proportion'] = i_data['other_occ'] / len(files) / top_valid
        data.append(i_data)
    return data


if __name__ == '__main__':
    files = sys.argv[1:]
    data = count_control_opcodes(files)
    with open('ctl_proportion_data', 'w') as f:
        json.dump(data, f, indent=2)



"""
Main module
"""

import glob
import os
import shutil
import sys
from argparse import ArgumentParser, RawTextHelpFormatter

from termcolor import colored

import config


def process(filepath, instrument=False, fexclude=''):
    """
    Start file processing
    :param filepath: path to executable
    :param instrument: True to apply instrumentation
    :param fexclude: path to file of symbol exclusions
    :return: True if everything ok
    """
    import init
    import traceback
    from postprocess import compile_process
    from disasm import main_discover, func_addr

    print "Starting to process binary '" + filepath + "'"
    try:

        func_addr.func_addr(filepath, 0, fexclude)

        os.system(config.strip + ' ' + filepath)
        main_discover.main_discover(filepath)

        init.main(filepath, instrument)
        if not os.path.isfile("final.s"): return False

        with open('final_data.s', 'a') as f:
            f.write('\n.section .eh_frame\n')
            with open('eh_frame_split.info') as eh: f.write(eh.read())
            f.write('\n.section .eh_frame_hdr\n')
            with open('eh_frame_hdr_split.info') as eh: f.write(eh.read())
        with open('final.s', 'a') as f:
            with open('final_data.s', 'r') as fd: f.write(fd.read())
            if instrument: f.write('\n\n'.join(map(lambda e: e['plain'].instrdata, config.instrumentors)))

        compile_process.main(filepath)
        if instrument:
            for worker in config.instrumentors:
                worker['main'].aftercompile()
        if compile_process.reassemble() != 0: return False

    except Exception as e:
        print e
        traceback.print_exc()
        return False

    return True


def check(filepath, assumptions, gccopt='', excludedata='', instrument=False):
    """
    Perform basic check on analyzed executable and set configuration values
    :param filepath: path to executable
    :param assumptions: list of assumption codes
    :param gccopt: additional options for the compiler
    :param excludedata: path to file of address exclusions
    :param instrument: True if instrumentation enabled
    :return: True if everything ok
    """
    if not assumptions: assumptions = []

    if not os.path.isfile(filepath):
        sys.stderr.write("Cannot find input binary\n")
        return False

    if len(excludedata) != 0 and not os.path.isfile(excludedata):
        sys.stderr.write("File with exclusions not found\n")
        return False

    for f in glob.glob('*'): os.remove(f)

    if os.path.dirname(filepath) != os.getcwd():
        shutil.copy(filepath, '.')

    os.system('file ' + filepath + ' > elf.info')
    config.setup(filepath, gccopt, excludedata, instrument)

    if config.is_lib:
        sys.stderr.write("Uroboros doesn't support shared libraries\n")
        return False

    # if assumption three is utilized, then input binary should be unstripped.
    if ('3' in assumptions or instrument) and not config.is_unstrip:
        print colored('Warning:', 'yellow'), 'binary is stripped, function boundaries evaluation may not be precise'

    return True


def set_assumption (assumptions):
    """
    Save assumptions to file
    2 -> assumption two: fix data section starting address
    3 -> assumption three: function starting address + jump table
    :param assumptions: list of assumptions codes
    :return: True if everything ok
    """
    if not assumptions:
        with open('assumption_set.info', 'w') as f:
            f.write('1\n')
    else:
        chk = (i in ['2', '3'] for i in assumptions)
        if any(chk) == False:
            print "assumption undefined!"
            print "accepted assumptions: 2 for assumption two and 3 for assumption three"
            return False
        with open('assumption_set.info', 'w') as f:
            f.write(' '.join(assumptions) + '\n')
    return True


def set_diversification(d, iter):
    if d not in config.all_diver_modes:
        assert False, 'unrecognizible diversification mode %d for iteration %d' % (d, iter)
    config.diversification_mode = d
    print 'set diversification mode %d for iteration %d' % (d, iter)
    os.system('echo %d > mode' % d)


def reset_diversification():
    config.diversification_mode = 0


def main():
    """
    Main function
    """
    p = ArgumentParser(formatter_class=RawTextHelpFormatter)
    p.add_argument("binary", help="path to the input binary")
    p.add_argument("-o", "--output", help="destination output file")
    p.add_argument("-g", "--instrument", action='store_true', help="apply instrumentations to output")
    p.add_argument("-a", "--assumption", action="append",
                   help='''this option configures three addtional assumption,
note that two basic assumptions and addtional assumption one
(n-byte alignment) are set by default,
while assumption two and three need to be configured. For example, setting
assumption two and three: -a 2 -a 3''')
    p.add_argument("-gcc", "--gccopt", action="store", default="", help="A string of additional arguments for GCC")
    p.add_argument("-ex", "--exclude", default="", help="""File where each line is either a single value which must not be
a label or an address range of data section to exclude from symbol search""")
    p.add_argument("-fex", "--functionexclude", default="", help="File with a list of symbols not representing functions")
    p.add_argument("--version", action="version", version="Uroboros 0.2b")

    p.add_argument('-i', '--iteration', type=int, help='the number of disassemble-diversify-reassemble iterations')
    p.add_argument('-d', '--diversification', type=int, action='append',
                   help='the sequence of diversification for every iteration \n' + config.diversification_description)

    args = p.parse_args()
    filepath = os.path.realpath(args.binary)
    outpath = os.path.realpath(args.output) if args.output is not None else None
    exclude = os.path.realpath(args.exclude) if len(args.exclude) > 0 else ''
    fexclude = os.path.realpath(args.functionexclude) if len(args.functionexclude) > 0 else ''

    num_iteration = args.iteration
    if num_iteration is None or num_iteration <= 0:
        num_iteration = 1

    diversifications = args.diversification
    if diversifications is None:
        diversifications = [0]
    while len(diversifications) < num_iteration:
        diversifications.append(diversifications[-1])

    abs_path = os.path.dirname(os.path.abspath(__file__))

    for i in range(1, num_iteration + 1):
        workdir = abs_path + '/workdir_' + str(i)
        if not os.path.isdir(workdir):
            os.mkdir(workdir)

        print colored(('iteration %d dir:' + workdir) % i, 'green')
        os.chdir(workdir)
        # run after setting the work directory
        set_diversification(diversifications[i - 1], i)

        if check(filepath, args.assumption, args.gccopt, exclude, args.instrument) and set_assumption(args.assumption):
            if process(os.path.basename(filepath), args.instrument, fexclude):
                os.system('strip a.out')
                print colored("Processing %d succeeded" % i, "blue")
                if outpath is not None:
                    shutil.copy('a.out', outpath + '_' + str(i) + '_mode_' + str(config.diversification_mode))
                    shutil.copy('a.out', outpath)
                # change source file path
                filepath = workdir + '/a.out'
            else:
                print colored("Processing %d failed" % i, "red")
                exit(1)
        reset_diversification()


if __name__ == "__main__":
    main()
"""
Main module
"""

import glob
import os
import shutil
import sys
from argparse import ArgumentParser, RawTextHelpFormatter

from termcolor import colored

import config


def process(filepath, instrument=False, fexclude=''):
    """
    Start file processing
    :param filepath: path to executable
    :param instrument: True to apply instrumentation
    :param fexclude: path to file of symbol exclusions
    :return: True if everything ok
    """
    import init
    import traceback
    from postprocess import compile_process
    from disasm import main_discover, func_addr

    print "Starting to process binary '" + filepath + "'"
    try:

        func_addr.func_addr(filepath, 0, fexclude)

        os.system(config.strip + ' ' + filepath)
        main_discover.main_discover(filepath)

        init.main(filepath, instrument)
        if not os.path.isfile("final.s"): return False

        with open('final_data.s', 'a') as f:
            f.write('\n.section .eh_frame\n')
            with open('eh_frame_split.info') as eh: f.write(eh.read())
            f.write('\n.section .eh_frame_hdr\n')
            with open('eh_frame_hdr_split.info') as eh: f.write(eh.read())
        with open('final.s', 'a') as f:
            with open('final_data.s', 'r') as fd: f.write(fd.read())
            if instrument: f.write('\n\n'.join(map(lambda e: e['plain'].instrdata, config.instrumentors)))

        compile_process.main(filepath)
        if instrument:
            for worker in config.instrumentors:
                worker['main'].aftercompile()
        if compile_process.reassemble() != 0: return False

    except Exception as e:
        print e
        traceback.print_exc()
        return False

    return True


def check(filepath, assumptions, gccopt='', excludedata='', instrument=False):
    """
    Perform basic check on analyzed executable and set configuration values
    :param filepath: path to executable
    :param assumptions: list of assumption codes
    :param gccopt: additional options for the compiler
    :param excludedata: path to file of address exclusions
    :param instrument: True if instrumentation enabled
    :return: True if everything ok
    """
    if not assumptions: assumptions = []

    if not os.path.isfile(filepath):
        sys.stderr.write("Cannot find input binary\n")
        return False

    if len(excludedata) != 0 and not os.path.isfile(excludedata):
        sys.stderr.write("File with exclusions not found\n")
        return False

    for f in glob.glob('*'): os.remove(f)

    if os.path.dirname(filepath) != os.getcwd():
        shutil.copy(filepath, '.')

    os.system('file ' + filepath + ' > elf.info')
    config.setup(filepath, gccopt, excludedata, instrument)

    if config.is_lib:
        sys.stderr.write("Uroboros doesn't support shared libraries\n")
        return False

    # if assumption three is utilized, then input binary should be unstripped.
    if ('3' in assumptions or instrument) and not config.is_unstrip:
        print colored('Warning:', 'yellow'), 'binary is stripped, function boundaries evaluation may not be precise'

    return True


def set_assumption (assumptions):
    """
    Save assumptions to file
    2 -> assumption two: fix data section starting address
    3 -> assumption three: function starting address + jump table
    :param assumptions: list of assumptions codes
    :return: True if everything ok
    """
    if not assumptions:
        with open('assumption_set.info', 'w') as f:
            f.write('1\n')
    else:
        chk = (i in ['2', '3'] for i in assumptions)
        if any(chk) == False:
            print "assumption undefined!"
            print "accepted assumptions: 2 for assumption two and 3 for assumption three"
            return False
        with open('assumption_set.info', 'w') as f:
            f.write(' '.join(assumptions) + '\n')
    return True


def set_diversification(d, iter):
    if d not in config.all_diver_modes:
        assert False, 'unrecognizible diversification mode %d for iteration %d' % (d, iter)
    config.diversification_mode = d
    print 'set diversification mode %d for iteration %d' % (d, iter)
    os.system('echo %d > mode' % d)


def reset_diversification():
    config.diversification_mode = 0


def main():
    """
    Main function
    """
    p = ArgumentParser(formatter_class=RawTextHelpFormatter)
    p.add_argument("binary", help="path to the input binary")
    p.add_argument("-o", "--output", help="destination output file")
    p.add_argument("-g", "--instrument", action='store_true', help="apply instrumentations to output")
    p.add_argument("-a", "--assumption", action="append",
                   help='''this option configures three addtional assumption,
note that two basic assumptions and addtional assumption one
(n-byte alignment) are set by default,
while assumption two and three need to be configured. For example, setting
assumption two and three: -a 2 -a 3''')
    p.add_argument("-gcc", "--gccopt", action="store", default="", help="A string of additional arguments for GCC")
    p.add_argument("-ex", "--exclude", default="", help="""File where each line is either a single value which must not be
a label or an address range of data section to exclude from symbol search""")
    p.add_argument("-fex", "--functionexclude", default="", help="File with a list of symbols not representing functions")
    p.add_argument("--version", action="version", version="Uroboros 0.2b")

    p.add_argument('-i', '--iteration', type=int, help='the number of disassemble-diversify-reassemble iterations')
    p.add_argument('-d', '--diversification', type=int, action='append',
                   help='the sequence of diversification for every iteration \n' + config.diversification_description)

    args = p.parse_args()
    filepath = os.path.realpath(args.binary)
    outpath = os.path.realpath(args.output) if args.output is not None else None
    exclude = os.path.realpath(args.exclude) if len(args.exclude) > 0 else ''
    fexclude = os.path.realpath(args.functionexclude) if len(args.functionexclude) > 0 else ''

    num_iteration = args.iteration
    if num_iteration is None or num_iteration <= 0:
        num_iteration = 1

    diversifications = args.diversification
    if diversifications is None:
        diversifications = [0]
    while len(diversifications) < num_iteration:
        diversifications.append(diversifications[-1])

    abs_path = os.path.dirname(os.path.abspath(__file__))

    for i in range(1, num_iteration + 1):
        workdir = abs_path + '/workdir_' + str(i)
        if not os.path.isdir(workdir):
            os.mkdir(workdir)

        print colored(('iteration %d dir:' + workdir) % i, 'green')
        os.chdir(workdir)
        # run after setting the work directory
        set_diversification(diversifications[i - 1], i)

        if check(filepath, args.assumption, args.gccopt, exclude, args.instrument) and set_assumption(args.assumption):
            if process(os.path.basename(filepath), args.instrument, fexclude):
                os.system('strip a.out')
                print colored("Processing %d succeeded" % i, "blue")
                if outpath is not None:
                    shutil.copy('a.out', outpath + '_' + str(i) + '_mode_' + str(config.diversification_mode))
                    shutil.copy('a.out', outpath)
                # change source file path
                filepath = workdir + '/a.out'
            else:
                print colored("Processing %d failed" % i, "red")
                exit(1)
        reset_diversification()


if __name__ == "__main__":
    main()
"""
Main module
"""

import glob
import os
import shutil
import sys
from argparse import ArgumentParser, RawTextHelpFormatter

from termcolor import colored

import config


def process(filepath, instrument=False, fexclude=''):
    """
    Start file processing
    :param filepath: path to executable
    :param instrument: True to apply instrumentation
    :param fexclude: path to file of symbol exclusions
    :return: True if everything ok
    """
    import init
    import traceback
    from postprocess import compile_process
    from disasm import main_discover, func_addr

    print "Starting to process binary '" + filepath + "'"
    try:

        func_addr.func_addr(filepath, 0, fexclude)

        os.system(config.strip + ' ' + filepath)
        main_discover.main_discover(filepath)

        init.main(filepath, instrument)
        if not os.path.isfile("final.s"): return False

        with open('final_data.s', 'a') as f:
            f.write('\n.section .eh_frame\n')
            with open('eh_frame_split.info') as eh: f.write(eh.read())
            f.write('\n.section .eh_frame_hdr\n')
            with open('eh_frame_hdr_split.info') as eh: f.write(eh.read())
        with open('final.s', 'a') as f:
            with open('final_data.s', 'r') as fd: f.write(fd.read())
            if instrument: f.write('\n\n'.join(map(lambda e: e['plain'].instrdata, config.instrumentors)))

        compile_process.main(filepath)
        if instrument:
            for worker in config.instrumentors:
                worker['main'].aftercompile()
        if compile_process.reassemble() != 0: return False

    except Exception as e:
        print e
        traceback.print_exc()
        return False

    return True


def check(filepath, assumptions, gccopt='', excludedata='', instrument=False):
    """
    Perform basic check on analyzed executable and set configuration values
    :param filepath: path to executable
    :param assumptions: list of assumption codes
    :param gccopt: additional options for the compiler
    :param excludedata: path to file of address exclusions
    :param instrument: True if instrumentation enabled
    :return: True if everything ok
    """
    if not assumptions: assumptions = []

    if not os.path.isfile(filepath):
        sys.stderr.write("Cannot find input binary\n")
        return False

    if len(excludedata) != 0 and not os.path.isfile(excludedata):
        sys.stderr.write("File with exclusions not found\n")
        return False

    for f in glob.glob('*'): os.remove(f)

    if os.path.dirname(filepath) != os.getcwd():
        shutil.copy(filepath, '.')

    os.system('file ' + filepath + ' > elf.info')
    config.setup(filepath, gccopt, excludedata, instrument)

    if config.is_lib:
        sys.stderr.write("Uroboros doesn't support shared libraries\n")
        return False

    # if assumption three is utilized, then input binary should be unstripped.
    if ('3' in assumptions or instrument) and not config.is_unstrip:
        print colored('Warning:', 'yellow'), 'binary is stripped, function boundaries evaluation may not be precise'

    return True


def set_assumption (assumptions):
    """
    Save assumptions to file
    2 -> assumption two: fix data section starting address
    3 -> assumption three: function starting address + jump table
    :param assumptions: list of assumptions codes
    :return: True if everything ok
    """
    if not assumptions:
        with open('assumption_set.info', 'w') as f:
            f.write('1\n')
    else:
        chk = (i in ['2', '3'] for i in assumptions)
        if any(chk) == False:
            print "assumption undefined!"
            print "accepted assumptions: 2 for assumption two and 3 for assumption three"
            return False
        with open('assumption_set.info', 'w') as f:
            f.write(' '.join(assumptions) + '\n')
    return True


def set_diversification(d, iter):
    if d not in config.all_diver_modes:
        assert False, 'unrecognizible diversification mode %d for iteration %d' % (d, iter)
    config.diversification_mode = d
    print 'set diversification mode %d for iteration %d' % (d, iter)
    os.system('echo %d > mode' % d)


def reset_diversification():
    config.diversification_mode = 0


def main():
    """
    Main function
    """
    p = ArgumentParser(formatter_class=RawTextHelpFormatter)
    p.add_argument("binary", help="path to the input binary")
    p.add_argument("-o", "--output", help="destination output file")
    p.add_argument("-g", "--instrument", action='store_true', help="apply instrumentations to output")
    p.add_argument("-a", "--assumption", action="append",
                   help='''this option configures three addtional assumption,
note that two basic assumptions and addtional assumption one
(n-byte alignment) are set by default,
while assumption two and three need to be configured. For example, setting
assumption two and three: -a 2 -a 3''')
    p.add_argument("-gcc", "--gccopt", action="store", default="", help="A string of additional arguments for GCC")
    p.add_argument("-ex", "--exclude", default="", help="""File where each line is either a single value which must not be
a label or an address range of data section to exclude from symbol search""")
    p.add_argument("-fex", "--functionexclude", default="", help="File with a list of symbols not representing functions")
    p.add_argument("--version", action="version", version="Uroboros 0.2b")

    p.add_argument('-i', '--iteration', type=int, help='the number of disassemble-diversify-reassemble iterations')
    p.add_argument('-d', '--diversification', type=int, action='append',
                   help='the sequence of diversification for every iteration \n' + config.diversification_description)

    args = p.parse_args()
    filepath = os.path.realpath(args.binary)
    outpath = os.path.realpath(args.output) if args.output is not None else None
    exclude = os.path.realpath(args.exclude) if len(args.exclude) > 0 else ''
    fexclude = os.path.realpath(args.functionexclude) if len(args.functionexclude) > 0 else ''

    num_iteration = args.iteration
    if num_iteration is None or num_iteration <= 0:
        num_iteration = 1

    diversifications = args.diversification
    if diversifications is None:
        diversifications = [0]
    while len(diversifications) < num_iteration:
        diversifications.append(diversifications[-1])

    abs_path = os.path.dirname(os.path.abspath(__file__))

    for i in range(1, num_iteration + 1):
        workdir = abs_path + '/workdir_' + str(i)
        if not os.path.isdir(workdir):
            os.mkdir(workdir)

        print colored(('iteration %d dir:' + workdir) % i, 'green')
        os.chdir(workdir)
        # run after setting the work directory
        set_diversification(diversifications[i - 1], i)

        if check(filepath, args.assumption, args.gccopt, exclude, args.instrument) and set_assumption(args.assumption):
            if process(os.path.basename(filepath), args.instrument, fexclude):
                os.system('strip a.out')
                print colored("Processing %d succeeded" % i, "blue")
                if outpath is not None:
                    shutil.copy('a.out', outpath + '_' + str(i) + '_mode_' + str(config.diversification_mode))
                    shutil.copy('a.out', outpath)
                # change source file path
                filepath = workdir + '/a.out'
            else:
                print colored("Processing %d failed" % i, "red")
                exit(1)
        reset_diversification()


if __name__ == "__main__":
    main()
"""
Main module
"""

import glob
import os
import shutil
import sys
from argparse import ArgumentParser, RawTextHelpFormatter

from termcolor import colored

import config


def process(filepath, instrument=False, fexclude=''):
    """
    Start file processing
    :param filepath: path to executable
    :param instrument: True to apply instrumentation
    :param fexclude: path to file of symbol exclusions
    :return: True if everything ok
    """
    import init
    import traceback
    from postprocess import compile_process
    from disasm import main_discover, func_addr

    print "Starting to process binary '" + filepath + "'"
    try:

        func_addr.func_addr(filepath, 0, fexclude)

        os.system(config.strip + ' ' + filepath)
        main_discover.main_discover(filepath)

        init.main(filepath, instrument)
        if not os.path.isfile("final.s"): return False

        with open('final_data.s', 'a') as f:
            f.write('\n.section .eh_frame\n')
            with open('eh_frame_split.info') as eh: f.write(eh.read())
            f.write('\n.section .eh_frame_hdr\n')
            with open('eh_frame_hdr_split.info') as eh: f.write(eh.read())
        with open('final.s', 'a') as f:
            with open('final_data.s', 'r') as fd: f.write(fd.read())
            if instrument: f.write('\n\n'.join(map(lambda e: e['plain'].instrdata, config.instrumentors)))

        compile_process.main(filepath)
        if instrument:
            for worker in config.instrumentors:
                worker['main'].aftercompile()
        if compile_process.reassemble() != 0: return False

    except Exception as e:
        print e
        traceback.print_exc()
        return False

    return True


def check(filepath, assumptions, gccopt='', excludedata='', instrument=False):
    """
    Perform basic check on analyzed executable and set configuration values
    :param filepath: path to executable
    :param assumptions: list of assumption codes
    :param gccopt: additional options for the compiler
    :param excludedata: path to file of address exclusions
    :param instrument: True if instrumentation enabled
    :return: True if everything ok
    """
    if not assumptions: assumptions = []

    if not os.path.isfile(filepath):
        sys.stderr.write("Cannot find input binary\n")
        return False

    if len(excludedata) != 0 and not os.path.isfile(excludedata):
        sys.stderr.write("File with exclusions not found\n")
        return False

    for f in glob.glob('*'): os.remove(f)

    if os.path.dirname(filepath) != os.getcwd():
        shutil.copy(filepath, '.')

    os.system('file ' + filepath + ' > elf.info')
    config.setup(filepath, gccopt, excludedata, instrument)

    if config.is_lib:
        sys.stderr.write("Uroboros doesn't support shared libraries\n")
        return False

    # if assumption three is utilized, then input binary should be unstripped.
    if ('3' in assumptions or instrument) and not config.is_unstrip:
        print colored('Warning:', 'yellow'), 'binary is stripped, function boundaries evaluation may not be precise'

    return True


def set_assumption (assumptions):
    """
    Save assumptions to file
    2 -> assumption two: fix data section starting address
    3 -> assumption three: function starting address + jump table
    :param assumptions: list of assumptions codes
    :return: True if everything ok
    """
    if not assumptions:
        with open('assumption_set.info', 'w') as f:
            f.write('1\n')
    else:
        chk = (i in ['2', '3'] for i in assumptions)
        if any(chk) == False:
            print "assumption undefined!"
            print "accepted assumptions: 2 for assumption two and 3 for assumption three"
            return False
        with open('assumption_set.info', 'w') as f:
            f.write(' '.join(assumptions) + '\n')
    return True


def set_diversification(d, iter):
    if d not in config.all_diver_modes:
        assert False, 'unrecognizible diversification mode %d for iteration %d' % (d, iter)
    config.diversification_mode = d
    print 'set diversification mode %d for iteration %d' % (d, iter)
    os.system('echo %d > mode' % d)


def reset_diversification():
    config.diversification_mode = 0


def main():
    """
    Main function
    """
    p = ArgumentParser(formatter_class=RawTextHelpFormatter)
    p.add_argument("binary", help="path to the input binary")
    p.add_argument("-o", "--output", help="destination output file")
    p.add_argument("-g", "--instrument", action='store_true', help="apply instrumentations to output")
    p.add_argument("-a", "--assumption", action="append",
                   help='''this option configures three addtional assumption,
note that two basic assumptions and addtional assumption one
(n-byte alignment) are set by default,
while assumption two and three need to be configured. For example, setting
assumption two and three: -a 2 -a 3''')
    p.add_argument("-gcc", "--gccopt", action="store", default="", help="A string of additional arguments for GCC")
    p.add_argument("-ex", "--exclude", default="", help="""File where each line is either a single value which must not be
a label or an address range of data section to exclude from symbol search""")
    p.add_argument("-fex", "--functionexclude", default="", help="File with a list of symbols not representing functions")
    p.add_argument("--version", action="version", version="Uroboros 0.2b")

    p.add_argument('-i', '--iteration', type=int, help='the number of disassemble-diversify-reassemble iterations')
    p.add_argument('-d', '--diversification', type=int, action='append',
                   help='the sequence of diversification for every iteration \n' + config.diversification_description)

    args = p.parse_args()
    filepath = os.path.realpath(args.binary)
    outpath = os.path.realpath(args.output) if args.output is not None else None
    exclude = os.path.realpath(args.exclude) if len(args.exclude) > 0 else ''
    fexclude = os.path.realpath(args.functionexclude) if len(args.functionexclude) > 0 else ''

    num_iteration = args.iteration
    if num_iteration is None or num_iteration <= 0:
        num_iteration = 1

    diversifications = args.diversification
    if diversifications is None:
        diversifications = [0]
    while len(diversifications) < num_iteration:
        diversifications.append(diversifications[-1])

    abs_path = os.path.dirname(os.path.abspath(__file__))

    for i in range(1, num_iteration + 1):
        workdir = abs_path + '/workdir_' + str(i)
        if not os.path.isdir(workdir):
            os.mkdir(workdir)

        print colored(('iteration %d dir:' + workdir) % i, 'green')
        os.chdir(workdir)
        # run after setting the work directory
        set_diversification(diversifications[i - 1], i)

        if check(filepath, args.assumption, args.gccopt, exclude, args.instrument) and set_assumption(args.assumption):
            if process(os.path.basename(filepath), args.instrument, fexclude):
                os.system('strip a.out')
                print colored("Processing %d succeeded" % i, "blue")
                if outpath is not None:
                    shutil.copy('a.out', outpath + '_' + str(i) + '_mode_' + str(config.diversification_mode))
                    shutil.copy('a.out', outpath)
                # change source file path
                filepath = workdir + '/a.out'
            else:
                print colored("Processing %d failed" % i, "red")
                exit(1)
        reset_diversification()


if __name__ == "__main__":
    main()
"""
Main module
"""

import glob
import os
import shutil
import sys
from argparse import ArgumentParser, RawTextHelpFormatter

from termcolor import colored

import config


def process(filepath, instrument=False, fexclude=''):
    """
    Start file processing
    :param filepath: path to executable
    :param instrument: True to apply instrumentation
    :param fexclude: path to file of symbol exclusions
    :return: True if everything ok
    """
    import init
    import traceback
    from postprocess import compile_process
    from disasm import main_discover, func_addr

    print "Starting to process binary '" + filepath + "'"
    try:

        func_addr.func_addr(filepath, 0, fexclude)

        os.system(config.strip + ' ' + filepath)
        main_discover.main_discover(filepath)

        init.main(filepath, instrument)
        if not os.path.isfile("final.s"): return False

        with open('final_data.s', 'a') as f:
            f.write('\n.section .eh_frame\n')
            with open('eh_frame_split.info') as eh: f.write(eh.read())
            f.write('\n.section .eh_frame_hdr\n')
            with open('eh_frame_hdr_split.info') as eh: f.write(eh.read())
        with open('final.s', 'a') as f:
            with open('final_data.s', 'r') as fd: f.write(fd.read())
            if instrument: f.write('\n\n'.join(map(lambda e: e['plain'].instrdata, config.instrumentors)))

        compile_process.main(filepath)
        if instrument:
            for worker in config.instrumentors:
                worker['main'].aftercompile()
        if compile_process.reassemble() != 0: return False

    except Exception as e:
        print e
        traceback.print_exc()
        return False

    return True


def check(filepath, assumptions, gccopt='', excludedata='', instrument=False):
    """
    Perform basic check on analyzed executable and set configuration values
    :param filepath: path to executable
    :param assumptions: list of assumption codes
    :param gccopt: additional options for the compiler
    :param excludedata: path to file of address exclusions
    :param instrument: True if instrumentation enabled
    :return: True if everything ok
    """
    if not assumptions: assumptions = []

    if not os.path.isfile(filepath):
        sys.stderr.write("Cannot find input binary\n")
        return False

    if len(excludedata) != 0 and not os.path.isfile(excludedata):
        sys.stderr.write("File with exclusions not found\n")
        return False

    for f in glob.glob('*'): os.remove(f)

    if os.path.dirname(filepath) != os.getcwd():
        shutil.copy(filepath, '.')

    os.system('file ' + filepath + ' > elf.info')
    config.setup(filepath, gccopt, excludedata, instrument)

    if config.is_lib:
        sys.stderr.write("Uroboros doesn't support shared libraries\n")
        return False

    # if assumption three is utilized, then input binary should be unstripped.
    if ('3' in assumptions or instrument) and not config.is_unstrip:
        print colored('Warning:', 'yellow'), 'binary is stripped, function boundaries evaluation may not be precise'

    return True


def set_assumption (assumptions):
    """
    Save assumptions to file
    2 -> assumption two: fix data section starting address
    3 -> assumption three: function starting address + jump table
    :param assumptions: list of assumptions codes
    :return: True if everything ok
    """
    if not assumptions:
        with open('assumption_set.info', 'w') as f:
            f.write('1\n')
    else:
        chk = (i in ['2', '3'] for i in assumptions)
        if any(chk) == False:
            print "assumption undefined!"
            print "accepted assumptions: 2 for assumption two and 3 for assumption three"
            return False
        with open('assumption_set.info', 'w') as f:
            f.write(' '.join(assumptions) + '\n')
    return True


def set_diversification(d, iter):
    if d not in config.all_diver_modes:
        assert False, 'unrecognizible diversification mode %d for iteration %d' % (d, iter)
    config.diversification_mode = d
    print 'set diversification mode %d for iteration %d' % (d, iter)
    os.system('echo %d > mode' % d)


def reset_diversification():
    config.diversification_mode = 0


def main():
    """
    Main function
    """
    p = ArgumentParser(formatter_class=RawTextHelpFormatter)
    p.add_argument("binary", help="path to the input binary")
    p.add_argument("-o", "--output", help="destination output file")
    p.add_argument("-g", "--instrument", action='store_true', help="apply instrumentations to output")
    p.add_argument("-a", "--assumption", action="append",
                   help='''this option configures three addtional assumption,
note that two basic assumptions and addtional assumption one
(n-byte alignment) are set by default,
while assumption two and three need to be configured. For example, setting
assumption two and three: -a 2 -a 3''')
    p.add_argument("-gcc", "--gccopt", action="store", default="", help="A string of additional arguments for GCC")
    p.add_argument("-ex", "--exclude", default="", help="""File where each line is either a single value which must not be
a label or an address range of data section to exclude from symbol search""")
    p.add_argument("-fex", "--functionexclude", default="", help="File with a list of symbols not representing functions")
    p.add_argument("--version", action="version", version="Uroboros 0.2b")

    p.add_argument('-i', '--iteration', type=int, help='the number of disassemble-diversify-reassemble iterations')
    p.add_argument('-d', '--diversification', type=int, action='append',
                   help='the sequence of diversification for every iteration \n' + config.diversification_description)

    args = p.parse_args()
    filepath = os.path.realpath(args.binary)
    outpath = os.path.realpath(args.output) if args.output is not None else None
    exclude = os.path.realpath(args.exclude) if len(args.exclude) > 0 else ''
    fexclude = os.path.realpath(args.functionexclude) if len(args.functionexclude) > 0 else ''

    num_iteration = args.iteration
    if num_iteration is None or num_iteration <= 0:
        num_iteration = 1

    diversifications = args.diversification
    if diversifications is None:
        diversifications = [0]
    while len(diversifications) < num_iteration:
        diversifications.append(diversifications[-1])

    abs_path = os.path.dirname(os.path.abspath(__file__))

    for i in range(1, num_iteration + 1):
        workdir = abs_path + '/workdir_' + str(i)
        if not os.path.isdir(workdir):
            os.mkdir(workdir)

        print colored(('iteration %d dir:' + workdir) % i, 'green')
        os.chdir(workdir)
        # run after setting the work directory
        set_diversification(diversifications[i - 1], i)

        if check(filepath, args.assumption, args.gccopt, exclude, args.instrument) and set_assumption(args.assumption):
            if process(os.path.basename(filepath), args.instrument, fexclude):
                os.system('strip a.out')
                print colored("Processing %d succeeded" % i, "blue")
                if outpath is not None:
                    shutil.copy('a.out', outpath + '_' + str(i) + '_mode_' + str(config.diversification_mode))
                    shutil.copy('a.out', outpath)
                # change source file path
                filepath = workdir + '/a.out'
            else:
                print colored("Processing %d failed" % i, "red")
                exit(1)
        reset_diversification()


if __name__ == "__main__":
    main()
"""
Main module
"""

import glob
import os
import shutil
import sys
from argparse import ArgumentParser, RawTextHelpFormatter

from termcolor import colored

import config


def process(filepath, instrument=False, fexclude=''):
    """
    Start file processing
    :param filepath: path to executable
    :param instrument: True to apply instrumentation
    :param fexclude: path to file of symbol exclusions
    :return: True if everything ok
    """
    import init
    import traceback
    from postprocess import compile_process
    from disasm import main_discover, func_addr

    print "Starting to process binary '" + filepath + "'"
    try:

        func_addr.func_addr(filepath, 0, fexclude)

        os.system(config.strip + ' ' + filepath)
        main_discover.main_discover(filepath)

        init.main(filepath, instrument)
        if not os.path.isfile("final.s"): return False

        with open('final_data.s', 'a') as f:
            f.write('\n.section .eh_frame\n')
            with open('eh_frame_split.info') as eh: f.write(eh.read())
            f.write('\n.section .eh_frame_hdr\n')
            with open('eh_frame_hdr_split.info') as eh: f.write(eh.read())
        with open('final.s', 'a') as f:
            with open('final_data.s', 'r') as fd: f.write(fd.read())
            if instrument: f.write('\n\n'.join(map(lambda e: e['plain'].instrdata, config.instrumentors)))

        compile_process.main(filepath)
        if instrument:
            for worker in config.instrumentors:
                worker['main'].aftercompile()
        if compile_process.reassemble() != 0: return False

    except Exception as e:
        print e
        traceback.print_exc()
        return False

    return True


def check(filepath, assumptions, gccopt='', excludedata='', instrument=False):
    """
    Perform basic check on analyzed executable and set configuration values
    :param filepath: path to executable
    :param assumptions: list of assumption codes
    :param gccopt: additional options for the compiler
    :param excludedata: path to file of address exclusions
    :param instrument: True if instrumentation enabled
    :return: True if everything ok
    """
    if not assumptions: assumptions = []

    if not os.path.isfile(filepath):
        sys.stderr.write("Cannot find input binary\n")
        return False

    if len(excludedata) != 0 and not os.path.isfile(excludedata):
        sys.stderr.write("File with exclusions not found\n")
        return False

    for f in glob.glob('*'): os.remove(f)

    if os.path.dirname(filepath) != os.getcwd():
        shutil.copy(filepath, '.')

    os.system('file ' + filepath + ' > elf.info')
    config.setup(filepath, gccopt, excludedata, instrument)

    if config.is_lib:
        sys.stderr.write("Uroboros doesn't support shared libraries\n")
        return False

    # if assumption three is utilized, then input binary should be unstripped.
    if ('3' in assumptions or instrument) and not config.is_unstrip:
        print colored('Warning:', 'yellow'), 'binary is stripped, function boundaries evaluation may not be precise'

    return True


def set_assumption (assumptions):
    """
    Save assumptions to file
    2 -> assumption two: fix data section starting address
    3 -> assumption three: function starting address + jump table
    :param assumptions: list of assumptions codes
    :return: True if everything ok
    """
    if not assumptions:
        with open('assumption_set.info', 'w') as f:
            f.write('1\n')
    else:
        chk = (i in ['2', '3'] for i in assumptions)
        if any(chk) == False:
            print "assumption undefined!"
            print "accepted assumptions: 2 for assumption two and 3 for assumption three"
            return False
        with open('assumption_set.info', 'w') as f:
            f.write(' '.join(assumptions) + '\n')
    return True


def set_diversification(d, iter):
    if d not in config.all_diver_modes:
        assert False, 'unrecognizible diversification mode %d for iteration %d' % (d, iter)
    config.diversification_mode = d
    print 'set diversification mode %d for iteration %d' % (d, iter)
    os.system('echo %d > mode' % d)


def reset_diversification():
    config.diversification_mode = 0


def main():
    """
    Main function
    """
    p = ArgumentParser(formatter_class=RawTextHelpFormatter)
    p.add_argument("binary", help="path to the input binary")
    p.add_argument("-o", "--output", help="destination output file")
    p.add_argument("-g", "--instrument", action='store_true', help="apply instrumentations to output")
    p.add_argument("-a", "--assumption", action="append",
                   help='''this option configures three addtional assumption,
note that two basic assumptions and addtional assumption one
(n-byte alignment) are set by default,
while assumption two and three need to be configured. For example, setting
assumption two and three: -a 2 -a 3''')
    p.add_argument("-gcc", "--gccopt", action="store", default="", help="A string of additional arguments for GCC")
    p.add_argument("-ex", "--exclude", default="", help="""File where each line is either a single value which must not be
a label or an address range of data section to exclude from symbol search""")
    p.add_argument("-fex", "--functionexclude", default="", help="File with a list of symbols not representing functions")
    p.add_argument("--version", action="version", version="Uroboros 0.2b")

    p.add_argument('-i', '--iteration', type=int, help='the number of disassemble-diversify-reassemble iterations')
    p.add_argument('-d', '--diversification', type=int, action='append',
                   help='the sequence of diversification for every iteration \n' + config.diversification_description)

    args = p.parse_args()
    filepath = os.path.realpath(args.binary)
    outpath = os.path.realpath(args.output) if args.output is not None else None
    exclude = os.path.realpath(args.exclude) if len(args.exclude) > 0 else ''
    fexclude = os.path.realpath(args.functionexclude) if len(args.functionexclude) > 0 else ''

    num_iteration = args.iteration
    if num_iteration is None or num_iteration <= 0:
        num_iteration = 1

    diversifications = args.diversification
    if diversifications is None:
        diversifications = [0]
    while len(diversifications) < num_iteration:
        diversifications.append(diversifications[-1])

    abs_path = os.path.dirname(os.path.abspath(__file__))

    for i in range(1, num_iteration + 1):
        workdir = abs_path + '/workdir_' + str(i)
        if not os.path.isdir(workdir):
            os.mkdir(workdir)

        print colored(('iteration %d dir:' + workdir) % i, 'green')
        os.chdir(workdir)
        # run after setting the work directory
        set_diversification(diversifications[i - 1], i)

        if check(filepath, args.assumption, args.gccopt, exclude, args.instrument) and set_assumption(args.assumption):
            if process(os.path.basename(filepath), args.instrument, fexclude):
                os.system('strip a.out')
                print colored("Processing %d succeeded" % i, "blue")
                if outpath is not None:
                    shutil.copy('a.out', outpath + '_' + str(i) + '_mode_' + str(config.diversification_mode))
                    shutil.copy('a.out', outpath)
                # change source file path
                filepath = workdir + '/a.out'
            else:
                print colored("Processing %d failed" % i, "red")
                exit(1)
        reset_diversification()


if __name__ == "__main__":
    main()
"""
Main module
"""

import glob
import os
import shutil
import sys
from argparse import ArgumentParser, RawTextHelpFormatter

from termcolor import colored

import config


def process(filepath, instrument=False, fexclude=''):
    """
    Start file processing
    :param filepath: path to executable
    :param instrument: True to apply instrumentation
    :param fexclude: path to file of symbol exclusions
    :return: True if everything ok
    """
    import init
    import traceback
    from postprocess import compile_process
    from disasm import main_discover, func_addr

    print "Starting to process binary '" + filepath + "'"
    try:

        func_addr.func_addr(filepath, 0, fexclude)

        os.system(config.strip + ' ' + filepath)
        main_discover.main_discover(filepath)

        init.main(filepath, instrument)
        if not os.path.isfile("final.s"): return False

        with open('final_data.s', 'a') as f:
            f.write('\n.section .eh_frame\n')
            with open('eh_frame_split.info') as eh: f.write(eh.read())
            f.write('\n.section .eh_frame_hdr\n')
            with open('eh_frame_hdr_split.info') as eh: f.write(eh.read())
        with open('final.s', 'a') as f:
            with open('final_data.s', 'r') as fd: f.write(fd.read())
            if instrument: f.write('\n\n'.join(map(lambda e: e['plain'].instrdata, config.instrumentors)))

        compile_process.main(filepath)
        if instrument:
            for worker in config.instrumentors:
                worker['main'].aftercompile()
        if compile_process.reassemble() != 0: return False

    except Exception as e:
        print e
        traceback.print_exc()
        return False

    return True


def check(filepath, assumptions, gccopt='', excludedata='', instrument=False):
    """
    Perform basic check on analyzed executable and set configuration values
    :param filepath: path to executable
    :param assumptions: list of assumption codes
    :param gccopt: additional options for the compiler
    :param excludedata: path to file of address exclusions
    :param instrument: True if instrumentation enabled
    :return: True if everything ok
    """
    if not assumptions: assumptions = []

    if not os.path.isfile(filepath):
        sys.stderr.write("Cannot find input binary\n")
        return False

    if len(excludedata) != 0 and not os.path.isfile(excludedata):
        sys.stderr.write("File with exclusions not found\n")
        return False

    for f in glob.glob('*'): os.remove(f)

    if os.path.dirname(filepath) != os.getcwd():
        shutil.copy(filepath, '.')

    os.system('file ' + filepath + ' > elf.info')
    config.setup(filepath, gccopt, excludedata, instrument)

    if config.is_lib:
        sys.stderr.write("Uroboros doesn't support shared libraries\n")
        return False

    # if assumption three is utilized, then input binary should be unstripped.
    if ('3' in assumptions or instrument) and not config.is_unstrip:
        print colored('Warning:', 'yellow'), 'binary is stripped, function boundaries evaluation may not be precise'

    return True


def set_assumption (assumptions):
    """
    Save assumptions to file
    2 -> assumption two: fix data section starting address
    3 -> assumption three: function starting address + jump table
    :param assumptions: list of assumptions codes
    :return: True if everything ok
    """
    if not assumptions:
        with open('assumption_set.info', 'w') as f:
            f.write('1\n')
    else:
        chk = (i in ['2', '3'] for i in assumptions)
        if any(chk) == False:
            print "assumption undefined!"
            print "accepted assumptions: 2 for assumption two and 3 for assumption three"
            return False
        with open('assumption_set.info', 'w') as f:
            f.write(' '.join(assumptions) + '\n')
    return True


def set_diversification(d, iter):
    if d not in config.all_diver_modes:
        assert False, 'unrecognizible diversification mode %d for iteration %d' % (d, iter)
    config.diversification_mode = d
    print 'set diversification mode %d for iteration %d' % (d, iter)
    os.system('echo %d > mode' % d)


def reset_diversification():
    config.diversification_mode = 0


def main():
    """
    Main function
    """
    p = ArgumentParser(formatter_class=RawTextHelpFormatter)
    p.add_argument("binary", help="path to the input binary")
    p.add_argument("-o", "--output", help="destination output file")
    p.add_argument("-g", "--instrument", action='store_true', help="apply instrumentations to output")
    p.add_argument("-a", "--assumption", action="append",
                   help='''this option configures three addtional assumption,
note that two basic assumptions and addtional assumption one
(n-byte alignment) are set by default,
while assumption two and three need to be configured. For example, setting
assumption two and three: -a 2 -a 3''')
    p.add_argument("-gcc", "--gccopt", action="store", default="", help="A string of additional arguments for GCC")
    p.add_argument("-ex", "--exclude", default="", help="""File where each line is either a single value which must not be
a label or an address range of data section to exclude from symbol search""")
    p.add_argument("-fex", "--functionexclude", default="", help="File with a list of symbols not representing functions")
    p.add_argument("--version", action="version", version="Uroboros 0.2b")

    p.add_argument('-i', '--iteration', type=int, help='the number of disassemble-diversify-reassemble iterations')
    p.add_argument('-d', '--diversification', type=int, action='append',
                   help='the sequence of diversification for every iteration \n' + config.diversification_description)

    args = p.parse_args()
    filepath = os.path.realpath(args.binary)
    outpath = os.path.realpath(args.output) if args.output is not None else None
    exclude = os.path.realpath(args.exclude) if len(args.exclude) > 0 else ''
    fexclude = os.path.realpath(args.functionexclude) if len(args.functionexclude) > 0 else ''

    num_iteration = args.iteration
    if num_iteration is None or num_iteration <= 0:
        num_iteration = 1

    diversifications = args.diversification
    if diversifications is None:
        diversifications = [0]
    while len(diversifications) < num_iteration:
        diversifications.append(diversifications[-1])

    abs_path = os.path.dirname(os.path.abspath(__file__))

    for i in range(1, num_iteration + 1):
        workdir = abs_path + '/workdir_' + str(i)
        if not os.path.isdir(workdir):
            os.mkdir(workdir)

        print colored(('iteration %d dir:' + workdir) % i, 'green')
        os.chdir(workdir)
        # run after setting the work directory
        set_diversification(diversifications[i - 1], i)

        if check(filepath, args.assumption, args.gccopt, exclude, args.instrument) and set_assumption(args.assumption):
            if process(os.path.basename(filepath), args.instrument, fexclude):
                os.system('strip a.out')
                print colored("Processing %d succeeded" % i, "blue")
                if outpath is not None:
                    shutil.copy('a.out', outpath + '_' + str(i) + '_mode_' + str(config.diversification_mode))
                    shutil.copy('a.out', outpath)
                # change source file path
                filepath = workdir + '/a.out'
            else:
                print colored("Processing %d failed" % i, "red")
                exit(1)
        reset_diversification()


if __name__ == "__main__":
    main()
"""
Main module
"""

import glob
import os
import shutil
import sys
from argparse import ArgumentParser, RawTextHelpFormatter

from termcolor import colored

import config


def process(filepath, instrument=False, fexclude=''):
    """
    Start file processing
    :param filepath: path to executable
    :param instrument: True to apply instrumentation
    :param fexclude: path to file of symbol exclusions
    :return: True if everything ok
    """
    import init
    import traceback
    from postprocess import compile_process
    from disasm import main_discover, func_addr

    print "Starting to process binary '" + filepath + "'"
    try:

        func_addr.func_addr(filepath, 0, fexclude)

        os.system(config.strip + ' ' + filepath)
        main_discover.main_discover(filepath)

        init.main(filepath, instrument)
        if not os.path.isfile("final.s"): return False

        with open('final_data.s', 'a') as f:
            f.write('\n.section .eh_frame\n')
            with open('eh_frame_split.info') as eh: f.write(eh.read())
            f.write('\n.section .eh_frame_hdr\n')
            with open('eh_frame_hdr_split.info') as eh: f.write(eh.read())
        with open('final.s', 'a') as f:
            with open('final_data.s', 'r') as fd: f.write(fd.read())
            if instrument: f.write('\n\n'.join(map(lambda e: e['plain'].instrdata, config.instrumentors)))

        compile_process.main(filepath)
        if instrument:
            for worker in config.instrumentors:
                worker['main'].aftercompile()
        if compile_process.reassemble() != 0: return False

    except Exception as e:
        print e
        traceback.print_exc()
        return False

    return True


def check(filepath, assumptions, gccopt='', excludedata='', instrument=False):
    """
    Perform basic check on analyzed executable and set configuration values
    :param filepath: path to executable
    :param assumptions: list of assumption codes
    :param gccopt: additional options for the compiler
    :param excludedata: path to file of address exclusions
    :param instrument: True if instrumentation enabled
    :return: True if everything ok
    """
    if not assumptions: assumptions = []

    if not os.path.isfile(filepath):
        sys.stderr.write("Cannot find input binary\n")
        return False

    if len(excludedata) != 0 and not os.path.isfile(excludedata):
        sys.stderr.write("File with exclusions not found\n")
        return False

    for f in glob.glob('*'): os.remove(f)

    if os.path.dirname(filepath) != os.getcwd():
        shutil.copy(filepath, '.')

    os.system('file ' + filepath + ' > elf.info')
    config.setup(filepath, gccopt, excludedata, instrument)

    if config.is_lib:
        sys.stderr.write("Uroboros doesn't support shared libraries\n")
        return False

    # if assumption three is utilized, then input binary should be unstripped.
    if ('3' in assumptions or instrument) and not config.is_unstrip:
        print colored('Warning:', 'yellow'), 'binary is stripped, function boundaries evaluation may not be precise'

    return True


def set_assumption (assumptions):
    """
    Save assumptions to file
    2 -> assumption two: fix data section starting address
    3 -> assumption three: function starting address + jump table
    :param assumptions: list of assumptions codes
    :return: True if everything ok
    """
    if not assumptions:
        with open('assumption_set.info', 'w') as f:
            f.write('1\n')
    else:
        chk = (i in ['2', '3'] for i in assumptions)
        if any(chk) == False:
            print "assumption undefined!"
            print "accepted assumptions: 2 for assumption two and 3 for assumption three"
            return False
        with open('assumption_set.info', 'w') as f:
            f.write(' '.join(assumptions) + '\n')
    return True


def set_diversification(d, iter):
    if d not in config.all_diver_modes:
        assert False, 'unrecognizible diversification mode %d for iteration %d' % (d, iter)
    config.diversification_mode = d
    print 'set diversification mode %d for iteration %d' % (d, iter)
    os.system('echo %d > mode' % d)


def reset_diversification():
    config.diversification_mode = 0


def main():
    """
    Main function
    """
    p = ArgumentParser(formatter_class=RawTextHelpFormatter)
    p.add_argument("binary", help="path to the input binary")
    p.add_argument("-o", "--output", help="destination output file")
    p.add_argument("-g", "--instrument", action='store_true', help="apply instrumentations to output")
    p.add_argument("-a", "--assumption", action="append",
                   help='''this option configures three addtional assumption,
note that two basic assumptions and addtional assumption one
(n-byte alignment) are set by default,
while assumption two and three need to be configured. For example, setting
assumption two and three: -a 2 -a 3''')
    p.add_argument("-gcc", "--gccopt", action="store", default="", help="A string of additional arguments for GCC")
    p.add_argument("-ex", "--exclude", default="", help="""File where each line is either a single value which must not be
a label or an address range of data section to exclude from symbol search""")
    p.add_argument("-fex", "--functionexclude", default="", help="File with a list of symbols not representing functions")
    p.add_argument("--version", action="version", version="Uroboros 0.2b")

    p.add_argument('-i', '--iteration', type=int, help='the number of disassemble-diversify-reassemble iterations')
    p.add_argument('-d', '--diversification', type=int, action='append',
                   help='the sequence of diversification for every iteration \n' + config.diversification_description)

    args = p.parse_args()
    filepath = os.path.realpath(args.binary)
    outpath = os.path.realpath(args.output) if args.output is not None else None
    exclude = os.path.realpath(args.exclude) if len(args.exclude) > 0 else ''
    fexclude = os.path.realpath(args.functionexclude) if len(args.functionexclude) > 0 else ''

    num_iteration = args.iteration
    if num_iteration is None or num_iteration <= 0:
        num_iteration = 1

    diversifications = args.diversification
    if diversifications is None:
        diversifications = [0]
    while len(diversifications) < num_iteration:
        diversifications.append(diversifications[-1])

    abs_path = os.path.dirname(os.path.abspath(__file__))

    for i in range(1, num_iteration + 1):
        workdir = abs_path + '/workdir_' + str(i)
        if not os.path.isdir(workdir):
            os.mkdir(workdir)

        print colored(('iteration %d dir:' + workdir) % i, 'green')
        os.chdir(workdir)
        # run after setting the work directory
        set_diversification(diversifications[i - 1], i)

        if check(filepath, args.assumption, args.gccopt, exclude, args.instrument) and set_assumption(args.assumption):
            if process(os.path.basename(filepath), args.instrument, fexclude):
                os.system('strip a.out')
                print colored("Processing %d succeeded" % i, "blue")
                if outpath is not None:
                    shutil.copy('a.out', outpath + '_' + str(i) + '_mode_' + str(config.diversification_mode))
                    shutil.copy('a.out', outpath)
                # change source file path
                filepath = workdir + '/a.out'
            else:
                print colored("Processing %d failed" % i, "red")
                exit(1)
        reset_diversification()


if __name__ == "__main__":
    main()
"""
Main module
"""

import glob
import os
import shutil
import sys
from argparse import ArgumentParser, RawTextHelpFormatter

from termcolor import colored

import config


def process(filepath, instrument=False, fexclude=''):
    """
    Start file processing
    :param filepath: path to executable
    :param instrument: True to apply instrumentation
    :param fexclude: path to file of symbol exclusions
    :return: True if everything ok
    """
    import init
    import traceback
    from postprocess import compile_process
    from disasm import main_discover, func_addr

    print "Starting to process binary '" + filepath + "'"
    try:

        func_addr.func_addr(filepath, 0, fexclude)

        os.system(config.strip + ' ' + filepath)
        main_discover.main_discover(filepath)

        init.main(filepath, instrument)
        if not os.path.isfile("final.s"): return False

        with open('final_data.s', 'a') as f:
            f.write('\n.section .eh_frame\n')
            with open('eh_frame_split.info') as eh: f.write(eh.read())
            f.write('\n.section .eh_frame_hdr\n')
            with open('eh_frame_hdr_split.info') as eh: f.write(eh.read())
        with open('final.s', 'a') as f:
            with open('final_data.s', 'r') as fd: f.write(fd.read())
            if instrument: f.write('\n\n'.join(map(lambda e: e['plain'].instrdata, config.instrumentors)))

        compile_process.main(filepath)
        if instrument:
            for worker in config.instrumentors:
                worker['main'].aftercompile()
        if compile_process.reassemble() != 0: return False

    except Exception as e:
        print e
        traceback.print_exc()
        return False

    return True


def check(filepath, assumptions, gccopt='', excludedata='', instrument=False):
    """
    Perform basic check on analyzed executable and set configuration values
    :param filepath: path to executable
    :param assumptions: list of assumption codes
    :param gccopt: additional options for the compiler
    :param excludedata: path to file of address exclusions
    :param instrument: True if instrumentation enabled
    :return: True if everything ok
    """
    if not assumptions: assumptions = []

    if not os.path.isfile(filepath):
        sys.stderr.write("Cannot find input binary\n")
        return False

    if len(excludedata) != 0 and not os.path.isfile(excludedata):
        sys.stderr.write("File with exclusions not found\n")
        return False

    for f in glob.glob('*'): os.remove(f)

    if os.path.dirname(filepath) != os.getcwd():
        shutil.copy(filepath, '.')

    os.system('file ' + filepath + ' > elf.info')
    config.setup(filepath, gccopt, excludedata, instrument)

    if config.is_lib:
        sys.stderr.write("Uroboros doesn't support shared libraries\n")
        return False

    # if assumption three is utilized, then input binary should be unstripped.
    if ('3' in assumptions or instrument) and not config.is_unstrip:
        print colored('Warning:', 'yellow'), 'binary is stripped, function boundaries evaluation may not be precise'

    return True


def set_assumption (assumptions):
    """
    Save assumptions to file
    2 -> assumption two: fix data section starting address
    3 -> assumption three: function starting address + jump table
    :param assumptions: list of assumptions codes
    :return: True if everything ok
    """
    if not assumptions:
        with open('assumption_set.info', 'w') as f:
            f.write('1\n')
    else:
        chk = (i in ['2', '3'] for i in assumptions)
        if any(chk) == False:
            print "assumption undefined!"
            print "accepted assumptions: 2 for assumption two and 3 for assumption three"
            return False
        with open('assumption_set.info', 'w') as f:
            f.write(' '.join(assumptions) + '\n')
    return True


def set_diversification(d, iter):
    if d not in config.all_diver_modes:
        assert False, 'unrecognizible diversification mode %d for iteration %d' % (d, iter)
    config.diversification_mode = d
    print 'set diversification mode %d for iteration %d' % (d, iter)
    os.system('echo %d > mode' % d)


def reset_diversification():
    config.diversification_mode = 0


def main():
    """
    Main function
    """
    p = ArgumentParser(formatter_class=RawTextHelpFormatter)
    p.add_argument("binary", help="path to the input binary")
    p.add_argument("-o", "--output", help="destination output file")
    p.add_argument("-g", "--instrument", action='store_true', help="apply instrumentations to output")
    p.add_argument("-a", "--assumption", action="append",
                   help='''this option configures three addtional assumption,
note that two basic assumptions and addtional assumption one
(n-byte alignment) are set by default,
while assumption two and three need to be configured. For example, setting
assumption two and three: -a 2 -a 3''')
    p.add_argument("-gcc", "--gccopt", action="store", default="", help="A string of additional arguments for GCC")
    p.add_argument("-ex", "--exclude", default="", help="""File where each line is either a single value which must not be
a label or an address range of data section to exclude from symbol search""")
    p.add_argument("-fex", "--functionexclude", default="", help="File with a list of symbols not representing functions")
    p.add_argument("--version", action="version", version="Uroboros 0.2b")

    p.add_argument('-i', '--iteration', type=int, help='the number of disassemble-diversify-reassemble iterations')
    p.add_argument('-d', '--diversification', type=int, action='append',
                   help='the sequence of diversification for every iteration \n' + config.diversification_description)

    args = p.parse_args()
    filepath = os.path.realpath(args.binary)
    outpath = os.path.realpath(args.output) if args.output is not None else None
    exclude = os.path.realpath(args.exclude) if len(args.exclude) > 0 else ''
    fexclude = os.path.realpath(args.functionexclude) if len(args.functionexclude) > 0 else ''

    num_iteration = args.iteration
    if num_iteration is None or num_iteration <= 0:
        num_iteration = 1

    diversifications = args.diversification
    if diversifications is None:
        diversifications = [0]
    while len(diversifications) < num_iteration:
        diversifications.append(diversifications[-1])

    abs_path = os.path.dirname(os.path.abspath(__file__))

    for i in range(1, num_iteration + 1):
        workdir = abs_path + '/workdir_' + str(i)
        if not os.path.isdir(workdir):
            os.mkdir(workdir)

        print colored(('iteration %d dir:' + workdir) % i, 'green')
        os.chdir(workdir)
        # run after setting the work directory
        set_diversification(diversifications[i - 1], i)

        if check(filepath, args.assumption, args.gccopt, exclude, args.instrument) and set_assumption(args.assumption):
            if process(os.path.basename(filepath), args.instrument, fexclude):
                os.system('strip a.out')
                print colored("Processing %d succeeded" % i, "blue")
                if outpath is not None:
                    shutil.copy('a.out', outpath + '_' + str(i) + '_mode_' + str(config.diversification_mode))
                    shutil.copy('a.out', outpath)
                # change source file path
                filepath = workdir + '/a.out'
            else:
                print colored("Processing %d failed" % i, "red")
                exit(1)
        reset_diversification()


if __name__ == "__main__":
    main()
"""
Main module
"""

import glob
import os
import shutil
import sys
from argparse import ArgumentParser, RawTextHelpFormatter

from termcolor import colored

import config


def process(filepath, instrument=False, fexclude=''):
    """
    Start file processing
    :param filepath: path to executable
    :param instrument: True to apply instrumentation
    :param fexclude: path to file of symbol exclusions
    :return: True if everything ok
    """
    import init
    import traceback
    from postprocess import compile_process
    from disasm import main_discover, func_addr

    print "Starting to process binary '" + filepath + "'"
    try:

        func_addr.func_addr(filepath, 0, fexclude)

        os.system(config.strip + ' ' + filepath)
        main_discover.main_discover(filepath)

        init.main(filepath, instrument)
        if not os.path.isfile("final.s"): return False

        with open('final_data.s', 'a') as f:
            f.write('\n.section .eh_frame\n')
            with open('eh_frame_split.info') as eh: f.write(eh.read())
            f.write('\n.section .eh_frame_hdr\n')
            with open('eh_frame_hdr_split.info') as eh: f.write(eh.read())
        with open('final.s', 'a') as f:
            with open('final_data.s', 'r') as fd: f.write(fd.read())
            if instrument: f.write('\n\n'.join(map(lambda e: e['plain'].instrdata, config.instrumentors)))

        compile_process.main(filepath)
        if instrument:
            for worker in config.instrumentors:
                worker['main'].aftercompile()
        if compile_process.reassemble() != 0: return False

    except Exception as e:
        print e
        traceback.print_exc()
        return False

    return True


def check(filepath, assumptions, gccopt='', excludedata='', instrument=False):
    """
    Perform basic check on analyzed executable and set configuration values
    :param filepath: path to executable
    :param assumptions: list of assumption codes
    :param gccopt: additional options for the compiler
    :param excludedata: path to file of address exclusions
    :param instrument: True if instrumentation enabled
    :return: True if everything ok
    """
    if not assumptions: assumptions = []

    if not os.path.isfile(filepath):
        sys.stderr.write("Cannot find input binary\n")
        return False

    if len(excludedata) != 0 and not os.path.isfile(excludedata):
        sys.stderr.write("File with exclusions not found\n")
        return False

    for f in glob.glob('*'): os.remove(f)

    if os.path.dirname(filepath) != os.getcwd():
        shutil.copy(filepath, '.')

    os.system('file ' + filepath + ' > elf.info')
    config.setup(filepath, gccopt, excludedata, instrument)

    if config.is_lib:
        sys.stderr.write("Uroboros doesn't support shared libraries\n")
        return False

    # if assumption three is utilized, then input binary should be unstripped.
    if ('3' in assumptions or instrument) and not config.is_unstrip:
        print colored('Warning:', 'yellow'), 'binary is stripped, function boundaries evaluation may not be precise'

    return True


def set_assumption (assumptions):
    """
    Save assumptions to file
    2 -> assumption two: fix data section starting address
    3 -> assumption three: function starting address + jump table
    :param assumptions: list of assumptions codes
    :return: True if everything ok
    """
    if not assumptions:
        with open('assumption_set.info', 'w') as f:
            f.write('1\n')
    else:
        chk = (i in ['2', '3'] for i in assumptions)
        if any(chk) == False:
            print "assumption undefined!"
            print "accepted assumptions: 2 for assumption two and 3 for assumption three"
            return False
        with open('assumption_set.info', 'w') as f:
            f.write(' '.join(assumptions) + '\n')
    return True


def set_diversification(d, iter):
    if d not in config.all_diver_modes:
        assert False, 'unrecognizible diversification mode %d for iteration %d' % (d, iter)
    config.diversification_mode = d
    print 'set diversification mode %d for iteration %d' % (d, iter)
    os.system('echo %d > mode' % d)


def reset_diversification():
    config.diversification_mode = 0


def main():
    """
    Main function
    """
    p = ArgumentParser(formatter_class=RawTextHelpFormatter)
    p.add_argument("binary", help="path to the input binary")
    p.add_argument("-o", "--output", help="destination output file")
    p.add_argument("-g", "--instrument", action='store_true', help="apply instrumentations to output")
    p.add_argument("-a", "--assumption", action="append",
                   help='''this option configures three addtional assumption,
note that two basic assumptions and addtional assumption one
(n-byte alignment) are set by default,
while assumption two and three need to be configured. For example, setting
assumption two and three: -a 2 -a 3''')
    p.add_argument("-gcc", "--gccopt", action="store", default="", help="A string of additional arguments for GCC")
    p.add_argument("-ex", "--exclude", default="", help="""File where each line is either a single value which must not be
a label or an address range of data section to exclude from symbol search""")
    p.add_argument("-fex", "--functionexclude", default="", help="File with a list of symbols not representing functions")
    p.add_argument("--version", action="version", version="Uroboros 0.2b")

    p.add_argument('-i', '--iteration', type=int, help='the number of disassemble-diversify-reassemble iterations')
    p.add_argument('-d', '--diversification', type=int, action='append',
                   help='the sequence of diversification for every iteration \n' + config.diversification_description)

    args = p.parse_args()
    filepath = os.path.realpath(args.binary)
    outpath = os.path.realpath(args.output) if args.output is not None else None
    exclude = os.path.realpath(args.exclude) if len(args.exclude) > 0 else ''
    fexclude = os.path.realpath(args.functionexclude) if len(args.functionexclude) > 0 else ''

    num_iteration = args.iteration
    if num_iteration is None or num_iteration <= 0:
        num_iteration = 1

    diversifications = args.diversification
    if diversifications is None:
        diversifications = [0]
    while len(diversifications) < num_iteration:
        diversifications.append(diversifications[-1])

    abs_path = os.path.dirname(os.path.abspath(__file__))

    for i in range(1, num_iteration + 1):
        workdir = abs_path + '/workdir_' + str(i)
        if not os.path.isdir(workdir):
            os.mkdir(workdir)

        print colored(('iteration %d dir:' + workdir) % i, 'green')
        os.chdir(workdir)
        # run after setting the work directory
        set_diversification(diversifications[i - 1], i)

        if check(filepath, args.assumption, args.gccopt, exclude, args.instrument) and set_assumption(args.assumption):
            if process(os.path.basename(filepath), args.instrument, fexclude):
                os.system('strip a.out')
                print colored("Processing %d succeeded" % i, "blue")
                if outpath is not None:
                    shutil.copy('a.out', outpath + '_' + str(i) + '_mode_' + str(config.diversification_mode))
                    shutil.copy('a.out', outpath)
                # change source file path
                filepath = workdir + '/a.out'
            else:
                print colored("Processing %d failed" % i, "red")
                exit(1)
        reset_diversification()


if __name__ == "__main__":
    main()
"""
Main module
"""

import glob
import os
import shutil
import sys
from argparse import ArgumentParser, RawTextHelpFormatter

from termcolor import colored

import config


def process(filepath, instrument=False, fexclude=''):
    """
    Start file processing
    :param filepath: path to executable
    :param instrument: True to apply instrumentation
    :param fexclude: path to file of symbol exclusions
    :return: True if everything ok
    """
    import init
    import traceback
    from postprocess import compile_process
    from disasm import main_discover, func_addr

    print "Starting to process binary '" + filepath + "'"
    try:

        func_addr.func_addr(filepath, 0, fexclude)

        os.system(config.strip + ' ' + filepath)
        main_discover.main_discover(filepath)

        init.main(filepath, instrument)
        if not os.path.isfile("final.s"): return False

        with open('final_data.s', 'a') as f:
            f.write('\n.section .eh_frame\n')
            with open('eh_frame_split.info') as eh: f.write(eh.read())
            f.write('\n.section .eh_frame_hdr\n')
            with open('eh_frame_hdr_split.info') as eh: f.write(eh.read())
        with open('final.s', 'a') as f:
            with open('final_data.s', 'r') as fd: f.write(fd.read())
            if instrument: f.write('\n\n'.join(map(lambda e: e['plain'].instrdata, config.instrumentors)))

        compile_process.main(filepath)
        if instrument:
            for worker in config.instrumentors:
                worker['main'].aftercompile()
        if compile_process.reassemble() != 0: return False

    except Exception as e:
        print e
        traceback.print_exc()
        return False

    return True


def check(filepath, assumptions, gccopt='', excludedata='', instrument=False):
    """
    Perform basic check on analyzed executable and set configuration values
    :param filepath: path to executable
    :param assumptions: list of assumption codes
    :param gccopt: additional options for the compiler
    :param excludedata: path to file of address exclusions
    :param instrument: True if instrumentation enabled
    :return: True if everything ok
    """
    if not assumptions: assumptions = []

    if not os.path.isfile(filepath):
        sys.stderr.write("Cannot find input binary\n")
        return False

    if len(excludedata) != 0 and not os.path.isfile(excludedata):
        sys.stderr.write("File with exclusions not found\n")
        return False

    for f in glob.glob('*'): os.remove(f)

    if os.path.dirname(filepath) != os.getcwd():
        shutil.copy(filepath, '.')

    os.system('file ' + filepath + ' > elf.info')
    config.setup(filepath, gccopt, excludedata, instrument)

    if config.is_lib:
        sys.stderr.write("Uroboros doesn't support shared libraries\n")
        return False

    # if assumption three is utilized, then input binary should be unstripped.
    if ('3' in assumptions or instrument) and not config.is_unstrip:
        print colored('Warning:', 'yellow'), 'binary is stripped, function boundaries evaluation may not be precise'

    return True


def set_assumption (assumptions):
    """
    Save assumptions to file
    2 -> assumption two: fix data section starting address
    3 -> assumption three: function starting address + jump table
    :param assumptions: list of assumptions codes
    :return: True if everything ok
    """
    if not assumptions:
        with open('assumption_set.info', 'w') as f:
            f.write('1\n')
    else:
        chk = (i in ['2', '3'] for i in assumptions)
        if any(chk) == False:
            print "assumption undefined!"
            print "accepted assumptions: 2 for assumption two and 3 for assumption three"
            return False
        with open('assumption_set.info', 'w') as f:
            f.write(' '.join(assumptions) + '\n')
    return True


def set_diversification(d, iter):
    if d not in config.all_diver_modes:
        assert False, 'unrecognizible diversification mode %d for iteration %d' % (d, iter)
    config.diversification_mode = d
    print 'set diversification mode %d for iteration %d' % (d, iter)
    os.system('echo %d > mode' % d)


def reset_diversification():
    config.diversification_mode = 0


def main():
    """
    Main function
    """
    p = ArgumentParser(formatter_class=RawTextHelpFormatter)
    p.add_argument("binary", help="path to the input binary")
    p.add_argument("-o", "--output", help="destination output file")
    p.add_argument("-g", "--instrument", action='store_true', help="apply instrumentations to output")
    p.add_argument("-a", "--assumption", action="append",
                   help='''this option configures three addtional assumption,
note that two basic assumptions and addtional assumption one
(n-byte alignment) are set by default,
while assumption two and three need to be configured. For example, setting
assumption two and three: -a 2 -a 3''')
    p.add_argument("-gcc", "--gccopt", action="store", default="", help="A string of additional arguments for GCC")
    p.add_argument("-ex", "--exclude", default="", help="""File where each line is either a single value which must not be
a label or an address range of data section to exclude from symbol search""")
    p.add_argument("-fex", "--functionexclude", default="", help="File with a list of symbols not representing functions")
    p.add_argument("--version", action="version", version="Uroboros 0.2b")

    p.add_argument('-i', '--iteration', type=int, help='the number of disassemble-diversify-reassemble iterations')
    p.add_argument('-d', '--diversification', type=int, action='append',
                   help='the sequence of diversification for every iteration \n' + config.diversification_description)

    args = p.parse_args()
    filepath = os.path.realpath(args.binary)
    outpath = os.path.realpath(args.output) if args.output is not None else None
    exclude = os.path.realpath(args.exclude) if len(args.exclude) > 0 else ''
    fexclude = os.path.realpath(args.functionexclude) if len(args.functionexclude) > 0 else ''

    num_iteration = args.iteration
    if num_iteration is None or num_iteration <= 0:
        num_iteration = 1

    diversifications = args.diversification
    if diversifications is None:
        diversifications = [0]
    while len(diversifications) < num_iteration:
        diversifications.append(diversifications[-1])

    abs_path = os.path.dirname(os.path.abspath(__file__))

    for i in range(1, num_iteration + 1):
        workdir = abs_path + '/workdir_' + str(i)
        if not os.path.isdir(workdir):
            os.mkdir(workdir)

        print colored(('iteration %d dir:' + workdir) % i, 'green')
        os.chdir(workdir)
        # run after setting the work directory
        set_diversification(diversifications[i - 1], i)

        if check(filepath, args.assumption, args.gccopt, exclude, args.instrument) and set_assumption(args.assumption):
            if process(os.path.basename(filepath), args.instrument, fexclude):
                os.system('strip a.out')
                print colored("Processing %d succeeded" % i, "blue")
                if outpath is not None:
                    shutil.copy('a.out', outpath + '_' + str(i) + '_mode_' + str(config.diversification_mode))
                    shutil.copy('a.out', outpath)
                # change source file path
                filepath = workdir + '/a.out'
            else:
                print colored("Processing %d failed" % i, "red")
                exit(1)
        reset_diversification()


if __name__ == "__main__":
    main()
"""
Main module
"""

import glob
import os
import shutil
import sys
from argparse import ArgumentParser, RawTextHelpFormatter

from termcolor import colored

import config


def process(filepath, instrument=False, fexclude=''):
    """
    Start file processing
    :param filepath: path to executable
    :param instrument: True to apply instrumentation
    :param fexclude: path to file of symbol exclusions
    :return: True if everything ok
    """
    import init
    import traceback
    from postprocess import compile_process
    from disasm import main_discover, func_addr

    print "Starting to process binary '" + filepath + "'"
    try:

        func_addr.func_addr(filepath, 0, fexclude)

        os.system(config.strip + ' ' + filepath)
        main_discover.main_discover(filepath)

        init.main(filepath, instrument)
        if not os.path.isfile("final.s"): return False

        with open('final_data.s', 'a') as f:
            f.write('\n.section .eh_frame\n')
            with open('eh_frame_split.info') as eh: f.write(eh.read())
            f.write('\n.section .eh_frame_hdr\n')
            with open('eh_frame_hdr_split.info') as eh: f.write(eh.read())
        with open('final.s', 'a') as f:
            with open('final_data.s', 'r') as fd: f.write(fd.read())
            if instrument: f.write('\n\n'.join(map(lambda e: e['plain'].instrdata, config.instrumentors)))

        compile_process.main(filepath)
        if instrument:
            for worker in config.instrumentors:
                worker['main'].aftercompile()
        if compile_process.reassemble() != 0: return False

    except Exception as e:
        print e
        traceback.print_exc()
        return False

    return True


def check(filepath, assumptions, gccopt='', excludedata='', instrument=False):
    """
    Perform basic check on analyzed executable and set configuration values
    :param filepath: path to executable
    :param assumptions: list of assumption codes
    :param gccopt: additional options for the compiler
    :param excludedata: path to file of address exclusions
    :param instrument: True if instrumentation enabled
    :return: True if everything ok
    """
    if not assumptions: assumptions = []

    if not os.path.isfile(filepath):
        sys.stderr.write("Cannot find input binary\n")
        return False

    if len(excludedata) != 0 and not os.path.isfile(excludedata):
        sys.stderr.write("File with exclusions not found\n")
        return False

    for f in glob.glob('*'): os.remove(f)

    if os.path.dirname(filepath) != os.getcwd():
        shutil.copy(filepath, '.')

    os.system('file ' + filepath + ' > elf.info')
    config.setup(filepath, gccopt, excludedata, instrument)

    if config.is_lib:
        sys.stderr.write("Uroboros doesn't support shared libraries\n")
        return False

    # if assumption three is utilized, then input binary should be unstripped.
    if ('3' in assumptions or instrument) and not config.is_unstrip:
        print colored('Warning:', 'yellow'), 'binary is stripped, function boundaries evaluation may not be precise'

    return True


def set_assumption (assumptions):
    """
    Save assumptions to file
    2 -> assumption two: fix data section starting address
    3 -> assumption three: function starting address + jump table
    :param assumptions: list of assumptions codes
    :return: True if everything ok
    """
    if not assumptions:
        with open('assumption_set.info', 'w') as f:
            f.write('1\n')
    else:
        chk = (i in ['2', '3'] for i in assumptions)
        if any(chk) == False:
            print "assumption undefined!"
            print "accepted assumptions: 2 for assumption two and 3 for assumption three"
            return False
        with open('assumption_set.info', 'w') as f:
            f.write(' '.join(assumptions) + '\n')
    return True


def set_diversification(d, iter):
    if d not in config.all_diver_modes:
        assert False, 'unrecognizible diversification mode %d for iteration %d' % (d, iter)
    config.diversification_mode = d
    print 'set diversification mode %d for iteration %d' % (d, iter)
    os.system('echo %d > mode' % d)


def reset_diversification():
    config.diversification_mode = 0


def main():
    """
    Main function
    """
    p = ArgumentParser(formatter_class=RawTextHelpFormatter)
    p.add_argument("binary", help="path to the input binary")
    p.add_argument("-o", "--output", help="destination output file")
    p.add_argument("-g", "--instrument", action='store_true', help="apply instrumentations to output")
    p.add_argument("-a", "--assumption", action="append",
                   help='''this option configures three addtional assumption,
note that two basic assumptions and addtional assumption one
(n-byte alignment) are set by default,
while assumption two and three need to be configured. For example, setting
assumption two and three: -a 2 -a 3''')
    p.add_argument("-gcc", "--gccopt", action="store", default="", help="A string of additional arguments for GCC")
    p.add_argument("-ex", "--exclude", default="", help="""File where each line is either a single value which must not be
a label or an address range of data section to exclude from symbol search""")
    p.add_argument("-fex", "--functionexclude", default="", help="File with a list of symbols not representing functions")
    p.add_argument("--version", action="version", version="Uroboros 0.2b")

    p.add_argument('-i', '--iteration', type=int, help='the number of disassemble-diversify-reassemble iterations')
    p.add_argument('-d', '--diversification', type=int, action='append',
                   help='the sequence of diversification for every iteration \n' + config.diversification_description)

    args = p.parse_args()
    filepath = os.path.realpath(args.binary)
    outpath = os.path.realpath(args.output) if args.output is not None else None
    exclude = os.path.realpath(args.exclude) if len(args.exclude) > 0 else ''
    fexclude = os.path.realpath(args.functionexclude) if len(args.functionexclude) > 0 else ''

    num_iteration = args.iteration
    if num_iteration is None or num_iteration <= 0:
        num_iteration = 1

    diversifications = args.diversification
    if diversifications is None:
        diversifications = [0]
    while len(diversifications) < num_iteration:
        diversifications.append(diversifications[-1])

    abs_path = os.path.dirname(os.path.abspath(__file__))

    for i in range(1, num_iteration + 1):
        workdir = abs_path + '/workdir_' + str(i)
        if not os.path.isdir(workdir):
            os.mkdir(workdir)

        print colored(('iteration %d dir:' + workdir) % i, 'green')
        os.chdir(workdir)
        # run after setting the work directory
        set_diversification(diversifications[i - 1], i)

        if check(filepath, args.assumption, args.gccopt, exclude, args.instrument) and set_assumption(args.assumption):
            if process(os.path.basename(filepath), args.instrument, fexclude):
                os.system('strip a.out')
                print colored("Processing %d succeeded" % i, "blue")
                if outpath is not None:
                    shutil.copy('a.out', outpath + '_' + str(i) + '_mode_' + str(config.diversification_mode))
                    shutil.copy('a.out', outpath)
                # change source file path
                filepath = workdir + '/a.out'
            else:
                print colored("Processing %d failed" % i, "red")
                exit(1)
        reset_diversification()


if __name__ == "__main__":
    main()
"""
Main module
"""

import glob
import os
import shutil
import sys
from argparse import ArgumentParser, RawTextHelpFormatter

from termcolor import colored

import config


def process(filepath, instrument=False, fexclude=''):
    """
    Start file processing
    :param filepath: path to executable
    :param instrument: True to apply instrumentation
    :param fexclude: path to file of symbol exclusions
    :return: True if everything ok
    """
    import init
    import traceback
    from postprocess import compile_process
    from disasm import main_discover, func_addr

    print "Starting to process binary '" + filepath + "'"
    try:

        func_addr.func_addr(filepath, 0, fexclude)

        os.system(config.strip + ' ' + filepath)
        main_discover.main_discover(filepath)

        init.main(filepath, instrument)
        if not os.path.isfile("final.s"): return False

        with open('final_data.s', 'a') as f:
            f.write('\n.section .eh_frame\n')
            with open('eh_frame_split.info') as eh: f.write(eh.read())
            f.write('\n.section .eh_frame_hdr\n')
            with open('eh_frame_hdr_split.info') as eh: f.write(eh.read())
        with open('final.s', 'a') as f:
            with open('final_data.s', 'r') as fd: f.write(fd.read())
            if instrument: f.write('\n\n'.join(map(lambda e: e['plain'].instrdata, config.instrumentors)))

        compile_process.main(filepath)
        if instrument:
            for worker in config.instrumentors:
                worker['main'].aftercompile()
        if compile_process.reassemble() != 0: return False

    except Exception as e:
        print e
        traceback.print_exc()
        return False

    return True


def check(filepath, assumptions, gccopt='', excludedata='', instrument=False):
    """
    Perform basic check on analyzed executable and set configuration values
    :param filepath: path to executable
    :param assumptions: list of assumption codes
    :param gccopt: additional options for the compiler
    :param excludedata: path to file of address exclusions
    :param instrument: True if instrumentation enabled
    :return: True if everything ok
    """
    if not assumptions: assumptions = []

    if not os.path.isfile(filepath):
        sys.stderr.write("Cannot find input binary\n")
        return False

    if len(excludedata) != 0 and not os.path.isfile(excludedata):
        sys.stderr.write("File with exclusions not found\n")
        return False

    for f in glob.glob('*'): os.remove(f)

    if os.path.dirname(filepath) != os.getcwd():
        shutil.copy(filepath, '.')

    os.system('file ' + filepath + ' > elf.info')
    config.setup(filepath, gccopt, excludedata, instrument)

    if config.is_lib:
        sys.stderr.write("Uroboros doesn't support shared libraries\n")
        return False

    # if assumption three is utilized, then input binary should be unstripped.
    if ('3' in assumptions or instrument) and not config.is_unstrip:
        print colored('Warning:', 'yellow'), 'binary is stripped, function boundaries evaluation may not be precise'

    return True


def set_assumption (assumptions):
    """
    Save assumptions to file
    2 -> assumption two: fix data section starting address
    3 -> assumption three: function starting address + jump table
    :param assumptions: list of assumptions codes
    :return: True if everything ok
    """
    if not assumptions:
        with open('assumption_set.info', 'w') as f:
            f.write('1\n')
    else:
        chk = (i in ['2', '3'] for i in assumptions)
        if any(chk) == False:
            print "assumption undefined!"
            print "accepted assumptions: 2 for assumption two and 3 for assumption three"
            return False
        with open('assumption_set.info', 'w') as f:
            f.write(' '.join(assumptions) + '\n')
    return True


def set_diversification(d, iter):
    if d not in config.all_diver_modes:
        assert False, 'unrecognizible diversification mode %d for iteration %d' % (d, iter)
    config.diversification_mode = d
    print 'set diversification mode %d for iteration %d' % (d, iter)
    os.system('echo %d > mode' % d)


def reset_diversification():
    config.diversification_mode = 0


def main():
    """
    Main function
    """
    p = ArgumentParser(formatter_class=RawTextHelpFormatter)
    p.add_argument("binary", help="path to the input binary")
    p.add_argument("-o", "--output", help="destination output file")
    p.add_argument("-g", "--instrument", action='store_true', help="apply instrumentations to output")
    p.add_argument("-a", "--assumption", action="append",
                   help='''this option configures three addtional assumption,
note that two basic assumptions and addtional assumption one
(n-byte alignment) are set by default,
while assumption two and three need to be configured. For example, setting
assumption two and three: -a 2 -a 3''')
    p.add_argument("-gcc", "--gccopt", action="store", default="", help="A string of additional arguments for GCC")
    p.add_argument("-ex", "--exclude", default="", help="""File where each line is either a single value which must not be
a label or an address range of data section to exclude from symbol search""")
    p.add_argument("-fex", "--functionexclude", default="", help="File with a list of symbols not representing functions")
    p.add_argument("--version", action="version", version="Uroboros 0.2b")

    p.add_argument('-i', '--iteration', type=int, help='the number of disassemble-diversify-reassemble iterations')
    p.add_argument('-d', '--diversification', type=int, action='append',
                   help='the sequence of diversification for every iteration \n' + config.diversification_description)

    args = p.parse_args()
    filepath = os.path.realpath(args.binary)
    outpath = os.path.realpath(args.output) if args.output is not None else None
    exclude = os.path.realpath(args.exclude) if len(args.exclude) > 0 else ''
    fexclude = os.path.realpath(args.functionexclude) if len(args.functionexclude) > 0 else ''

    num_iteration = args.iteration
    if num_iteration is None or num_iteration <= 0:
        num_iteration = 1

    diversifications = args.diversification
    if diversifications is None:
        diversifications = [0]
    while len(diversifications) < num_iteration:
        diversifications.append(diversifications[-1])

    abs_path = os.path.dirname(os.path.abspath(__file__))

    for i in range(1, num_iteration + 1):
        workdir = abs_path + '/workdir_' + str(i)
        if not os.path.isdir(workdir):
            os.mkdir(workdir)

        print colored(('iteration %d dir:' + workdir) % i, 'green')
        os.chdir(workdir)
        # run after setting the work directory
        set_diversification(diversifications[i - 1], i)

        if check(filepath, args.assumption, args.gccopt, exclude, args.instrument) and set_assumption(args.assumption):
            if process(os.path.basename(filepath), args.instrument, fexclude):
                os.system('strip a.out')
                print colored("Processing %d succeeded" % i, "blue")
                if outpath is not None:
                    shutil.copy('a.out', outpath + '_' + str(i) + '_mode_' + str(config.diversification_mode))
                    shutil.copy('a.out', outpath)
                # change source file path
                filepath = workdir + '/a.out'
            else:
                print colored("Processing %d failed" % i, "red")
                exit(1)
        reset_diversification()


if __name__ == "__main__":
    main()
"""
Main module
"""

import glob
import os
import shutil
import sys
from argparse import ArgumentParser, RawTextHelpFormatter

from termcolor import colored

import config


def process(filepath, instrument=False, fexclude=''):
    """
    Start file processing
    :param filepath: path to executable
    :param instrument: True to apply instrumentation
    :param fexclude: path to file of symbol exclusions
    :return: True if everything ok
    """
    import init
    import traceback
    from postprocess import compile_process
    from disasm import main_discover, func_addr

    print "Starting to process binary '" + filepath + "'"
    try:

        func_addr.func_addr(filepath, 0, fexclude)

        os.system(config.strip + ' ' + filepath)
        main_discover.main_discover(filepath)

        init.main(filepath, instrument)
        if not os.path.isfile("final.s"): return False

        with open('final_data.s', 'a') as f:
            f.write('\n.section .eh_frame\n')
            with open('eh_frame_split.info') as eh: f.write(eh.read())
            f.write('\n.section .eh_frame_hdr\n')
            with open('eh_frame_hdr_split.info') as eh: f.write(eh.read())
        with open('final.s', 'a') as f:
            with open('final_data.s', 'r') as fd: f.write(fd.read())
            if instrument: f.write('\n\n'.join(map(lambda e: e['plain'].instrdata, config.instrumentors)))

        compile_process.main(filepath)
        if instrument:
            for worker in config.instrumentors:
                worker['main'].aftercompile()
        if compile_process.reassemble() != 0: return False

    except Exception as e:
        print e
        traceback.print_exc()
        return False

    return True


def check(filepath, assumptions, gccopt='', excludedata='', instrument=False):
    """
    Perform basic check on analyzed executable and set configuration values
    :param filepath: path to executable
    :param assumptions: list of assumption codes
    :param gccopt: additional options for the compiler
    :param excludedata: path to file of address exclusions
    :param instrument: True if instrumentation enabled
    :return: True if everything ok
    """
    if not assumptions: assumptions = []

    if not os.path.isfile(filepath):
        sys.stderr.write("Cannot find input binary\n")
        return False

    if len(excludedata) != 0 and not os.path.isfile(excludedata):
        sys.stderr.write("File with exclusions not found\n")
        return False

    for f in glob.glob('*'): os.remove(f)

    if os.path.dirname(filepath) != os.getcwd():
        shutil.copy(filepath, '.')

    os.system('file ' + filepath + ' > elf.info')
    config.setup(filepath, gccopt, excludedata, instrument)

    if config.is_lib:
        sys.stderr.write("Uroboros doesn't support shared libraries\n")
        return False

    # if assumption three is utilized, then input binary should be unstripped.
    if ('3' in assumptions or instrument) and not config.is_unstrip:
        print colored('Warning:', 'yellow'), 'binary is stripped, function boundaries evaluation may not be precise'

    return True


def set_assumption (assumptions):
    """
    Save assumptions to file
    2 -> assumption two: fix data section starting address
    3 -> assumption three: function starting address + jump table
    :param assumptions: list of assumptions codes
    :return: True if everything ok
    """
    if not assumptions:
        with open('assumption_set.info', 'w') as f:
            f.write('1\n')
    else:
        chk = (i in ['2', '3'] for i in assumptions)
        if any(chk) == False:
            print "assumption undefined!"
            print "accepted assumptions: 2 for assumption two and 3 for assumption three"
            return False
        with open('assumption_set.info', 'w') as f:
            f.write(' '.join(assumptions) + '\n')
    return True


def set_diversification(d, iter):
    if d not in config.all_diver_modes:
        assert False, 'unrecognizible diversification mode %d for iteration %d' % (d, iter)
    config.diversification_mode = d
    print 'set diversification mode %d for iteration %d' % (d, iter)
    os.system('echo %d > mode' % d)


def reset_diversification():
    config.diversification_mode = 0


def main():
    """
    Main function
    """
    p = ArgumentParser(formatter_class=RawTextHelpFormatter)
    p.add_argument("binary", help="path to the input binary")
    p.add_argument("-o", "--output", help="destination output file")
    p.add_argument("-g", "--instrument", action='store_true', help="apply instrumentations to output")
    p.add_argument("-a", "--assumption", action="append",
                   help='''this option configures three addtional assumption,
note that two basic assumptions and addtional assumption one
(n-byte alignment) are set by default,
while assumption two and three need to be configured. For example, setting
assumption two and three: -a 2 -a 3''')
    p.add_argument("-gcc", "--gccopt", action="store", default="", help="A string of additional arguments for GCC")
    p.add_argument("-ex", "--exclude", default="", help="""File where each line is either a single value which must not be
a label or an address range of data section to exclude from symbol search""")
    p.add_argument("-fex", "--functionexclude", default="", help="File with a list of symbols not representing functions")
    p.add_argument("--version", action="version", version="Uroboros 0.2b")

    p.add_argument('-i', '--iteration', type=int, help='the number of disassemble-diversify-reassemble iterations')
    p.add_argument('-d', '--diversification', type=int, action='append',
                   help='the sequence of diversification for every iteration \n' + config.diversification_description)

    args = p.parse_args()
    filepath = os.path.realpath(args.binary)
    outpath = os.path.realpath(args.output) if args.output is not None else None
    exclude = os.path.realpath(args.exclude) if len(args.exclude) > 0 else ''
    fexclude = os.path.realpath(args.functionexclude) if len(args.functionexclude) > 0 else ''

    num_iteration = args.iteration
    if num_iteration is None or num_iteration <= 0:
        num_iteration = 1

    diversifications = args.diversification
    if diversifications is None:
        diversifications = [0]
    while len(diversifications) < num_iteration:
        diversifications.append(diversifications[-1])

    abs_path = os.path.dirname(os.path.abspath(__file__))

    for i in range(1, num_iteration + 1):
        workdir = abs_path + '/workdir_' + str(i)
        if not os.path.isdir(workdir):
            os.mkdir(workdir)

        print colored(('iteration %d dir:' + workdir) % i, 'green')
        os.chdir(workdir)
        # run after setting the work directory
        set_diversification(diversifications[i - 1], i)

        if check(filepath, args.assumption, args.gccopt, exclude, args.instrument) and set_assumption(args.assumption):
            if process(os.path.basename(filepath), args.instrument, fexclude):
                os.system('strip a.out')
                print colored("Processing %d succeeded" % i, "blue")
                if outpath is not None:
                    shutil.copy('a.out', outpath + '_' + str(i) + '_mode_' + str(config.diversification_mode))
                    shutil.copy('a.out', outpath)
                # change source file path
                filepath = workdir + '/a.out'
            else:
                print colored("Processing %d failed" % i, "red")
                exit(1)
        reset_diversification()


if __name__ == "__main__":
    main()
"""
Main module
"""

import glob
import os
import shutil
import sys
from argparse import ArgumentParser, RawTextHelpFormatter

from termcolor import colored

import config


def process(filepath, instrument=False, fexclude=''):
    """
    Start file processing
    :param filepath: path to executable
    :param instrument: True to apply instrumentation
    :param fexclude: path to file of symbol exclusions
    :return: True if everything ok
    """
    import init
    import traceback
    from postprocess import compile_process
    from disasm import main_discover, func_addr

    print "Starting to process binary '" + filepath + "'"
    try:

        func_addr.func_addr(filepath, 0, fexclude)

        os.system(config.strip + ' ' + filepath)
        main_discover.main_discover(filepath)

        init.main(filepath, instrument)
        if not os.path.isfile("final.s"): return False

        with open('final_data.s', 'a') as f:
            f.write('\n.section .eh_frame\n')
            with open('eh_frame_split.info') as eh: f.write(eh.read())
            f.write('\n.section .eh_frame_hdr\n')
            with open('eh_frame_hdr_split.info') as eh: f.write(eh.read())
        with open('final.s', 'a') as f:
            with open('final_data.s', 'r') as fd: f.write(fd.read())
            if instrument: f.write('\n\n'.join(map(lambda e: e['plain'].instrdata, config.instrumentors)))

        compile_process.main(filepath)
        if instrument:
            for worker in config.instrumentors:
                worker['main'].aftercompile()
        if compile_process.reassemble() != 0: return False

    except Exception as e:
        print e
        traceback.print_exc()
        return False

    return True


def check(filepath, assumptions, gccopt='', excludedata='', instrument=False):
    """
    Perform basic check on analyzed executable and set configuration values
    :param filepath: path to executable
    :param assumptions: list of assumption codes
    :param gccopt: additional options for the compiler
    :param excludedata: path to file of address exclusions
    :param instrument: True if instrumentation enabled
    :return: True if everything ok
    """
    if not assumptions: assumptions = []

    if not os.path.isfile(filepath):
        sys.stderr.write("Cannot find input binary\n")
        return False

    if len(excludedata) != 0 and not os.path.isfile(excludedata):
        sys.stderr.write("File with exclusions not found\n")
        return False

    for f in glob.glob('*'): os.remove(f)

    if os.path.dirname(filepath) != os.getcwd():
        shutil.copy(filepath, '.')

    os.system('file ' + filepath + ' > elf.info')
    config.setup(filepath, gccopt, excludedata, instrument)

    if config.is_lib:
        sys.stderr.write("Uroboros doesn't support shared libraries\n")
        return False

    # if assumption three is utilized, then input binary should be unstripped.
    if ('3' in assumptions or instrument) and not config.is_unstrip:
        print colored('Warning:', 'yellow'), 'binary is stripped, function boundaries evaluation may not be precise'

    return True


def set_assumption (assumptions):
    """
    Save assumptions to file
    2 -> assumption two: fix data section starting address
    3 -> assumption three: function starting address + jump table
    :param assumptions: list of assumptions codes
    :return: True if everything ok
    """
    if not assumptions:
        with open('assumption_set.info', 'w') as f:
            f.write('1\n')
    else:
        chk = (i in ['2', '3'] for i in assumptions)
        if any(chk) == False:
            print "assumption undefined!"
            print "accepted assumptions: 2 for assumption two and 3 for assumption three"
            return False
        with open('assumption_set.info', 'w') as f:
            f.write(' '.join(assumptions) + '\n')
    return True


def set_diversification(d, iter):
    if d not in config.all_diver_modes:
        assert False, 'unrecognizible diversification mode %d for iteration %d' % (d, iter)
    config.diversification_mode = d
    print 'set diversification mode %d for iteration %d' % (d, iter)
    os.system('echo %d > mode' % d)


def reset_diversification():
    config.diversification_mode = 0


def main():
    """
    Main function
    """
    p = ArgumentParser(formatter_class=RawTextHelpFormatter)
    p.add_argument("binary", help="path to the input binary")
    p.add_argument("-o", "--output", help="destination output file")
    p.add_argument("-g", "--instrument", action='store_true', help="apply instrumentations to output")
    p.add_argument("-a", "--assumption", action="append",
                   help='''this option configures three addtional assumption,
note that two basic assumptions and addtional assumption one
(n-byte alignment) are set by default,
while assumption two and three need to be configured. For example, setting
assumption two and three: -a 2 -a 3''')
    p.add_argument("-gcc", "--gccopt", action="store", default="", help="A string of additional arguments for GCC")
    p.add_argument("-ex", "--exclude", default="", help="""File where each line is either a single value which must not be
a label or an address range of data section to exclude from symbol search""")
    p.add_argument("-fex", "--functionexclude", default="", help="File with a list of symbols not representing functions")
    p.add_argument("--version", action="version", version="Uroboros 0.2b")

    p.add_argument('-i', '--iteration', type=int, help='the number of disassemble-diversify-reassemble iterations')
    p.add_argument('-d', '--diversification', type=int, action='append',
                   help='the sequence of diversification for every iteration \n' + config.diversification_description)

    args = p.parse_args()
    filepath = os.path.realpath(args.binary)
    outpath = os.path.realpath(args.output) if args.output is not None else None
    exclude = os.path.realpath(args.exclude) if len(args.exclude) > 0 else ''
    fexclude = os.path.realpath(args.functionexclude) if len(args.functionexclude) > 0 else ''

    num_iteration = args.iteration
    if num_iteration is None or num_iteration <= 0:
        num_iteration = 1

    diversifications = args.diversification
    if diversifications is None:
        diversifications = [0]
    while len(diversifications) < num_iteration:
        diversifications.append(diversifications[-1])

    abs_path = os.path.dirname(os.path.abspath(__file__))

    for i in range(1, num_iteration + 1):
        workdir = abs_path + '/workdir_' + str(i)
        if not os.path.isdir(workdir):
            os.mkdir(workdir)

        print colored(('iteration %d dir:' + workdir) % i, 'green')
        os.chdir(workdir)
        # run after setting the work directory
        set_diversification(diversifications[i - 1], i)

        if check(filepath, args.assumption, args.gccopt, exclude, args.instrument) and set_assumption(args.assumption):
            if process(os.path.basename(filepath), args.instrument, fexclude):
                os.system('strip a.out')
                print colored("Processing %d succeeded" % i, "blue")
                if outpath is not None:
                    shutil.copy('a.out', outpath + '_' + str(i) + '_mode_' + str(config.diversification_mode))
                    shutil.copy('a.out', outpath)
                # change source file path
                filepath = workdir + '/a.out'
            else:
                print colored("Processing %d failed" % i, "red")
                exit(1)
        reset_diversification()


if __name__ == "__main__":
    main()
"""
Main module
"""

import glob
import os
import shutil
import sys
from argparse import ArgumentParser, RawTextHelpFormatter

from termcolor import colored

import config


def process(filepath, instrument=False, fexclude=''):
    """
    Start file processing
    :param filepath: path to executable
    :param instrument: True to apply instrumentation
    :param fexclude: path to file of symbol exclusions
    :return: True if everything ok
    """
    import init
    import traceback
    from postprocess import compile_process
    from disasm import main_discover, func_addr

    print "Starting to process binary '" + filepath + "'"
    try:

        func_addr.func_addr(filepath, 0, fexclude)

        os.system(config.strip + ' ' + filepath)
        main_discover.main_discover(filepath)

        init.main(filepath, instrument)
        if not os.path.isfile("final.s"): return False

        with open('final_data.s', 'a') as f:
            f.write('\n.section .eh_frame\n')
            with open('eh_frame_split.info') as eh: f.write(eh.read())
            f.write('\n.section .eh_frame_hdr\n')
            with open('eh_frame_hdr_split.info') as eh: f.write(eh.read())
        with open('final.s', 'a') as f:
            with open('final_data.s', 'r') as fd: f.write(fd.read())
            if instrument: f.write('\n\n'.join(map(lambda e: e['plain'].instrdata, config.instrumentors)))

        compile_process.main(filepath)
        if instrument:
            for worker in config.instrumentors:
                worker['main'].aftercompile()
        if compile_process.reassemble() != 0: return False

    except Exception as e:
        print e
        traceback.print_exc()
        return False

    return True


def check(filepath, assumptions, gccopt='', excludedata='', instrument=False):
    """
    Perform basic check on analyzed executable and set configuration values
    :param filepath: path to executable
    :param assumptions: list of assumption codes
    :param gccopt: additional options for the compiler
    :param excludedata: path to file of address exclusions
    :param instrument: True if instrumentation enabled
    :return: True if everything ok
    """
    if not assumptions: assumptions = []

    if not os.path.isfile(filepath):
        sys.stderr.write("Cannot find input binary\n")
        return False

    if len(excludedata) != 0 and not os.path.isfile(excludedata):
        sys.stderr.write("File with exclusions not found\n")
        return False

    for f in glob.glob('*'): os.remove(f)

    if os.path.dirname(filepath) != os.getcwd():
        shutil.copy(filepath, '.')

    os.system('file ' + filepath + ' > elf.info')
    config.setup(filepath, gccopt, excludedata, instrument)

    if config.is_lib:
        sys.stderr.write("Uroboros doesn't support shared libraries\n")
        return False

    # if assumption three is utilized, then input binary should be unstripped.
    if ('3' in assumptions or instrument) and not config.is_unstrip:
        print colored('Warning:', 'yellow'), 'binary is stripped, function boundaries evaluation may not be precise'

    return True


def set_assumption (assumptions):
    """
    Save assumptions to file
    2 -> assumption two: fix data section starting address
    3 -> assumption three: function starting address + jump table
    :param assumptions: list of assumptions codes
    :return: True if everything ok
    """
    if not assumptions:
        with open('assumption_set.info', 'w') as f:
            f.write('1\n')
    else:
        chk = (i in ['2', '3'] for i in assumptions)
        if any(chk) == False:
            print "assumption undefined!"
            print "accepted assumptions: 2 for assumption two and 3 for assumption three"
            return False
        with open('assumption_set.info', 'w') as f:
            f.write(' '.join(assumptions) + '\n')
    return True


def set_diversification(d, iter):
    if d not in config.all_diver_modes:
        assert False, 'unrecognizible diversification mode %d for iteration %d' % (d, iter)
    config.diversification_mode = d
    print 'set diversification mode %d for iteration %d' % (d, iter)
    os.system('echo %d > mode' % d)


def reset_diversification():
    config.diversification_mode = 0


def main():
    """
    Main function
    """
    p = ArgumentParser(formatter_class=RawTextHelpFormatter)
    p.add_argument("binary", help="path to the input binary")
    p.add_argument("-o", "--output", help="destination output file")
    p.add_argument("-g", "--instrument", action='store_true', help="apply instrumentations to output")
    p.add_argument("-a", "--assumption", action="append",
                   help='''this option configures three addtional assumption,
note that two basic assumptions and addtional assumption one
(n-byte alignment) are set by default,
while assumption two and three need to be configured. For example, setting
assumption two and three: -a 2 -a 3''')
    p.add_argument("-gcc", "--gccopt", action="store", default="", help="A string of additional arguments for GCC")
    p.add_argument("-ex", "--exclude", default="", help="""File where each line is either a single value which must not be
a label or an address range of data section to exclude from symbol search""")
    p.add_argument("-fex", "--functionexclude", default="", help="File with a list of symbols not representing functions")
    p.add_argument("--version", action="version", version="Uroboros 0.2b")

    p.add_argument('-i', '--iteration', type=int, help='the number of disassemble-diversify-reassemble iterations')
    p.add_argument('-d', '--diversification', type=int, action='append',
                   help='the sequence of diversification for every iteration \n' + config.diversification_description)

    args = p.parse_args()
    filepath = os.path.realpath(args.binary)
    outpath = os.path.realpath(args.output) if args.output is not None else None
    exclude = os.path.realpath(args.exclude) if len(args.exclude) > 0 else ''
    fexclude = os.path.realpath(args.functionexclude) if len(args.functionexclude) > 0 else ''

    num_iteration = args.iteration
    if num_iteration is None or num_iteration <= 0:
        num_iteration = 1

    diversifications = args.diversification
    if diversifications is None:
        diversifications = [0]
    while len(diversifications) < num_iteration:
        diversifications.append(diversifications[-1])

    abs_path = os.path.dirname(os.path.abspath(__file__))

    for i in range(1, num_iteration + 1):
        workdir = abs_path + '/workdir_' + str(i)
        if not os.path.isdir(workdir):
            os.mkdir(workdir)

        print colored(('iteration %d dir:' + workdir) % i, 'green')
        os.chdir(workdir)
        # run after setting the work directory
        set_diversification(diversifications[i - 1], i)

        if check(filepath, args.assumption, args.gccopt, exclude, args.instrument) and set_assumption(args.assumption):
            if process(os.path.basename(filepath), args.instrument, fexclude):
                os.system('strip a.out')
                print colored("Processing %d succeeded" % i, "blue")
                if outpath is not None:
                    shutil.copy('a.out', outpath + '_' + str(i) + '_mode_' + str(config.diversification_mode))
                    shutil.copy('a.out', outpath)
                # change source file path
                filepath = workdir + '/a.out'
            else:
                print colored("Processing %d failed" % i, "red")
                exit(1)
        reset_diversification()


if __name__ == "__main__":
    main()
"""
Main module
"""

import glob
import os
import shutil
import sys
from argparse import ArgumentParser, RawTextHelpFormatter

from termcolor import colored

import config


def process(filepath, instrument=False, fexclude=''):
    """
    Start file processing
    :param filepath: path to executable
    :param instrument: True to apply instrumentation
    :param fexclude: path to file of symbol exclusions
    :return: True if everything ok
    """
    import init
    import traceback
    from postprocess import compile_process
    from disasm import main_discover, func_addr

    print "Starting to process binary '" + filepath + "'"
    try:

        func_addr.func_addr(filepath, 0, fexclude)

        os.system(config.strip + ' ' + filepath)
        main_discover.main_discover(filepath)

        init.main(filepath, instrument)
        if not os.path.isfile("final.s"): return False

        with open('final_data.s', 'a') as f:
            f.write('\n.section .eh_frame\n')
            with open('eh_frame_split.info') as eh: f.write(eh.read())
            f.write('\n.section .eh_frame_hdr\n')
            with open('eh_frame_hdr_split.info') as eh: f.write(eh.read())
        with open('final.s', 'a') as f:
            with open('final_data.s', 'r') as fd: f.write(fd.read())
            if instrument: f.write('\n\n'.join(map(lambda e: e['plain'].instrdata, config.instrumentors)))

        compile_process.main(filepath)
        if instrument:
            for worker in config.instrumentors:
                worker['main'].aftercompile()
        if compile_process.reassemble() != 0: return False

    except Exception as e:
        print e
        traceback.print_exc()
        return False

    return True


def check(filepath, assumptions, gccopt='', excludedata='', instrument=False):
    """
    Perform basic check on analyzed executable and set configuration values
    :param filepath: path to executable
    :param assumptions: list of assumption codes
    :param gccopt: additional options for the compiler
    :param excludedata: path to file of address exclusions
    :param instrument: True if instrumentation enabled
    :return: True if everything ok
    """
    if not assumptions: assumptions = []

    if not os.path.isfile(filepath):
        sys.stderr.write("Cannot find input binary\n")
        return False

    if len(excludedata) != 0 and not os.path.isfile(excludedata):
        sys.stderr.write("File with exclusions not found\n")
        return False

    for f in glob.glob('*'): os.remove(f)

    if os.path.dirname(filepath) != os.getcwd():
        shutil.copy(filepath, '.')

    os.system('file ' + filepath + ' > elf.info')
    config.setup(filepath, gccopt, excludedata, instrument)

    if config.is_lib:
        sys.stderr.write("Uroboros doesn't support shared libraries\n")
        return False

    # if assumption three is utilized, then input binary should be unstripped.
    if ('3' in assumptions or instrument) and not config.is_unstrip:
        print colored('Warning:', 'yellow'), 'binary is stripped, function boundaries evaluation may not be precise'

    return True


def set_assumption (assumptions):
    """
    Save assumptions to file
    2 -> assumption two: fix data section starting address
    3 -> assumption three: function starting address + jump table
    :param assumptions: list of assumptions codes
    :return: True if everything ok
    """
    if not assumptions:
        with open('assumption_set.info', 'w') as f:
            f.write('1\n')
    else:
        chk = (i in ['2', '3'] for i in assumptions)
        if any(chk) == False:
            print "assumption undefined!"
            print "accepted assumptions: 2 for assumption two and 3 for assumption three"
            return False
        with open('assumption_set.info', 'w') as f:
            f.write(' '.join(assumptions) + '\n')
    return True


def set_diversification(d, iter):
    if d not in config.all_diver_modes:
        assert False, 'unrecognizible diversification mode %d for iteration %d' % (d, iter)
    config.diversification_mode = d
    print 'set diversification mode %d for iteration %d' % (d, iter)
    os.system('echo %d > mode' % d)


def reset_diversification():
    config.diversification_mode = 0


def main():
    """
    Main function
    """
    p = ArgumentParser(formatter_class=RawTextHelpFormatter)
    p.add_argument("binary", help="path to the input binary")
    p.add_argument("-o", "--output", help="destination output file")
    p.add_argument("-g", "--instrument", action='store_true', help="apply instrumentations to output")
    p.add_argument("-a", "--assumption", action="append",
                   help='''this option configures three addtional assumption,
note that two basic assumptions and addtional assumption one
(n-byte alignment) are set by default,
while assumption two and three need to be configured. For example, setting
assumption two and three: -a 2 -a 3''')
    p.add_argument("-gcc", "--gccopt", action="store", default="", help="A string of additional arguments for GCC")
    p.add_argument("-ex", "--exclude", default="", help="""File where each line is either a single value which must not be
a label or an address range of data section to exclude from symbol search""")
    p.add_argument("-fex", "--functionexclude", default="", help="File with a list of symbols not representing functions")
    p.add_argument("--version", action="version", version="Uroboros 0.2b")

    p.add_argument('-i', '--iteration', type=int, help='the number of disassemble-diversify-reassemble iterations')
    p.add_argument('-d', '--diversification', type=int, action='append',
                   help='the sequence of diversification for every iteration \n' + config.diversification_description)

    args = p.parse_args()
    filepath = os.path.realpath(args.binary)
    outpath = os.path.realpath(args.output) if args.output is not None else None
    exclude = os.path.realpath(args.exclude) if len(args.exclude) > 0 else ''
    fexclude = os.path.realpath(args.functionexclude) if len(args.functionexclude) > 0 else ''

    num_iteration = args.iteration
    if num_iteration is None or num_iteration <= 0:
        num_iteration = 1

    diversifications = args.diversification
    if diversifications is None:
        diversifications = [0]
    while len(diversifications) < num_iteration:
        diversifications.append(diversifications[-1])

    abs_path = os.path.dirname(os.path.abspath(__file__))

    for i in range(1, num_iteration + 1):
        workdir = abs_path + '/workdir_' + str(i)
        if not os.path.isdir(workdir):
            os.mkdir(workdir)

        print colored(('iteration %d dir:' + workdir) % i, 'green')
        os.chdir(workdir)
        # run after setting the work directory
        set_diversification(diversifications[i - 1], i)

        if check(filepath, args.assumption, args.gccopt, exclude, args.instrument) and set_assumption(args.assumption):
            if process(os.path.basename(filepath), args.instrument, fexclude):
                os.system('strip a.out')
                print colored("Processing %d succeeded" % i, "blue")
                if outpath is not None:
                    shutil.copy('a.out', outpath + '_' + str(i) + '_mode_' + str(config.diversification_mode))
                    shutil.copy('a.out', outpath)
                # change source file path
                filepath = workdir + '/a.out'
            else:
                print colored("Processing %d failed" % i, "red")
                exit(1)
        reset_diversification()


if __name__ == "__main__":
    main()
"""
Main module
"""

import glob
import os
import shutil
import sys
from argparse import ArgumentParser, RawTextHelpFormatter

from termcolor import colored

import config


def process(filepath, instrument=False, fexclude=''):
    """
    Start file processing
    :param filepath: path to executable
    :param instrument: True to apply instrumentation
    :param fexclude: path to file of symbol exclusions
    :return: True if everything ok
    """
    import init
    import traceback
    from postprocess import compile_process
    from disasm import main_discover, func_addr

    print "Starting to process binary '" + filepath + "'"
    try:

        func_addr.func_addr(filepath, 0, fexclude)

        os.system(config.strip + ' ' + filepath)
        main_discover.main_discover(filepath)

        init.main(filepath, instrument)
        if not os.path.isfile("final.s"): return False

        with open('final_data.s', 'a') as f:
            f.write('\n.section .eh_frame\n')
            with open('eh_frame_split.info') as eh: f.write(eh.read())
            f.write('\n.section .eh_frame_hdr\n')
            with open('eh_frame_hdr_split.info') as eh: f.write(eh.read())
        with open('final.s', 'a') as f:
            with open('final_data.s', 'r') as fd: f.write(fd.read())
            if instrument: f.write('\n\n'.join(map(lambda e: e['plain'].instrdata, config.instrumentors)))

        compile_process.main(filepath)
        if instrument:
            for worker in config.instrumentors:
                worker['main'].aftercompile()
        if compile_process.reassemble() != 0: return False

    except Exception as e:
        print e
        traceback.print_exc()
        return False

    return True


def check(filepath, assumptions, gccopt='', excludedata='', instrument=False):
    """
    Perform basic check on analyzed executable and set configuration values
    :param filepath: path to executable
    :param assumptions: list of assumption codes
    :param gccopt: additional options for the compiler
    :param excludedata: path to file of address exclusions
    :param instrument: True if instrumentation enabled
    :return: True if everything ok
    """
    if not assumptions: assumptions = []

    if not os.path.isfile(filepath):
        sys.stderr.write("Cannot find input binary\n")
        return False

    if len(excludedata) != 0 and not os.path.isfile(excludedata):
        sys.stderr.write("File with exclusions not found\n")
        return False

    for f in glob.glob('*'): os.remove(f)

    if os.path.dirname(filepath) != os.getcwd():
        shutil.copy(filepath, '.')

    os.system('file ' + filepath + ' > elf.info')
    config.setup(filepath, gccopt, excludedata, instrument)

    if config.is_lib:
        sys.stderr.write("Uroboros doesn't support shared libraries\n")
        return False

    # if assumption three is utilized, then input binary should be unstripped.
    if ('3' in assumptions or instrument) and not config.is_unstrip:
        print colored('Warning:', 'yellow'), 'binary is stripped, function boundaries evaluation may not be precise'

    return True


def set_assumption (assumptions):
    """
    Save assumptions to file
    2 -> assumption two: fix data section starting address
    3 -> assumption three: function starting address + jump table
    :param assumptions: list of assumptions codes
    :return: True if everything ok
    """
    if not assumptions:
        with open('assumption_set.info', 'w') as f:
            f.write('1\n')
    else:
        chk = (i in ['2', '3'] for i in assumptions)
        if any(chk) == False:
            print "assumption undefined!"
            print "accepted assumptions: 2 for assumption two and 3 for assumption three"
            return False
        with open('assumption_set.info', 'w') as f:
            f.write(' '.join(assumptions) + '\n')
    return True


def set_diversification(d, iter):
    if d not in config.all_diver_modes:
        assert False, 'unrecognizible diversification mode %d for iteration %d' % (d, iter)
    config.diversification_mode = d
    print 'set diversification mode %d for iteration %d' % (d, iter)
    os.system('echo %d > mode' % d)


def reset_diversification():
    config.diversification_mode = 0


def main():
    """
    Main function
    """
    p = ArgumentParser(formatter_class=RawTextHelpFormatter)
    p.add_argument("binary", help="path to the input binary")
    p.add_argument("-o", "--output", help="destination output file")
    p.add_argument("-g", "--instrument", action='store_true', help="apply instrumentations to output")
    p.add_argument("-a", "--assumption", action="append",
                   help='''this option configures three addtional assumption,
note that two basic assumptions and addtional assumption one
(n-byte alignment) are set by default,
while assumption two and three need to be configured. For example, setting
assumption two and three: -a 2 -a 3''')
    p.add_argument("-gcc", "--gccopt", action="store", default="", help="A string of additional arguments for GCC")
    p.add_argument("-ex", "--exclude", default="", help="""File where each line is either a single value which must not be
a label or an address range of data section to exclude from symbol search""")
    p.add_argument("-fex", "--functionexclude", default="", help="File with a list of symbols not representing functions")
    p.add_argument("--version", action="version", version="Uroboros 0.2b")

    p.add_argument('-i', '--iteration', type=int, help='the number of disassemble-diversify-reassemble iterations')
    p.add_argument('-d', '--diversification', type=int, action='append',
                   help='the sequence of diversification for every iteration \n' + config.diversification_description)

    args = p.parse_args()
    filepath = os.path.realpath(args.binary)
    outpath = os.path.realpath(args.output) if args.output is not None else None
    exclude = os.path.realpath(args.exclude) if len(args.exclude) > 0 else ''
    fexclude = os.path.realpath(args.functionexclude) if len(args.functionexclude) > 0 else ''

    num_iteration = args.iteration
    if num_iteration is None or num_iteration <= 0:
        num_iteration = 1

    diversifications = args.diversification
    if diversifications is None:
        diversifications = [0]
    while len(diversifications) < num_iteration:
        diversifications.append(diversifications[-1])

    abs_path = os.path.dirname(os.path.abspath(__file__))

    for i in range(1, num_iteration + 1):
        workdir = abs_path + '/workdir_' + str(i)
        if not os.path.isdir(workdir):
            os.mkdir(workdir)

        print colored(('iteration %d dir:' + workdir) % i, 'green')
        os.chdir(workdir)
        # run after setting the work directory
        set_diversification(diversifications[i - 1], i)

        if check(filepath, args.assumption, args.gccopt, exclude, args.instrument) and set_assumption(args.assumption):
            if process(os.path.basename(filepath), args.instrument, fexclude):
                os.system('strip a.out')
                print colored("Processing %d succeeded" % i, "blue")
                if outpath is not None:
                    shutil.copy('a.out', outpath + '_' + str(i) + '_mode_' + str(config.diversification_mode))
                    shutil.copy('a.out', outpath)
                # change source file path
                filepath = workdir + '/a.out'
            else:
                print colored("Processing %d failed" % i, "red")
                exit(1)
        reset_diversification()


if __name__ == "__main__":
    main()
"""
Main module
"""

import glob
import os
import shutil
import sys
from argparse import ArgumentParser, RawTextHelpFormatter

from termcolor import colored

import config


def process(filepath, instrument=False, fexclude=''):
    """
    Start file processing
    :param filepath: path to executable
    :param instrument: True to apply instrumentation
    :param fexclude: path to file of symbol exclusions
    :return: True if everything ok
    """
    import init
    import traceback
    from postprocess import compile_process
    from disasm import main_discover, func_addr

    print "Starting to process binary '" + filepath + "'"
    try:

        func_addr.func_addr(filepath, 0, fexclude)

        os.system(config.strip + ' ' + filepath)
        main_discover.main_discover(filepath)

        init.main(filepath, instrument)
        if not os.path.isfile("final.s"): return False

        with open('final_data.s', 'a') as f:
            f.write('\n.section .eh_frame\n')
            with open('eh_frame_split.info') as eh: f.write(eh.read())
            f.write('\n.section .eh_frame_hdr\n')
            with open('eh_frame_hdr_split.info') as eh: f.write(eh.read())
        with open('final.s', 'a') as f:
            with open('final_data.s', 'r') as fd: f.write(fd.read())
            if instrument: f.write('\n\n'.join(map(lambda e: e['plain'].instrdata, config.instrumentors)))

        compile_process.main(filepath)
        if instrument:
            for worker in config.instrumentors:
                worker['main'].aftercompile()
        if compile_process.reassemble() != 0: return False

    except Exception as e:
        print e
        traceback.print_exc()
        return False

    return True


def check(filepath, assumptions, gccopt='', excludedata='', instrument=False):
    """
    Perform basic check on analyzed executable and set configuration values
    :param filepath: path to executable
    :param assumptions: list of assumption codes
    :param gccopt: additional options for the compiler
    :param excludedata: path to file of address exclusions
    :param instrument: True if instrumentation enabled
    :return: True if everything ok
    """
    if not assumptions: assumptions = []

    if not os.path.isfile(filepath):
        sys.stderr.write("Cannot find input binary\n")
        return False

    if len(excludedata) != 0 and not os.path.isfile(excludedata):
        sys.stderr.write("File with exclusions not found\n")
        return False

    for f in glob.glob('*'): os.remove(f)

    if os.path.dirname(filepath) != os.getcwd():
        shutil.copy(filepath, '.')

    os.system('file ' + filepath + ' > elf.info')
    config.setup(filepath, gccopt, excludedata, instrument)

    if config.is_lib:
        sys.stderr.write("Uroboros doesn't support shared libraries\n")
        return False

    # if assumption three is utilized, then input binary should be unstripped.
    if ('3' in assumptions or instrument) and not config.is_unstrip:
        print colored('Warning:', 'yellow'), 'binary is stripped, function boundaries evaluation may not be precise'

    return True


def set_assumption (assumptions):
    """
    Save assumptions to file
    2 -> assumption two: fix data section starting address
    3 -> assumption three: function starting address + jump table
    :param assumptions: list of assumptions codes
    :return: True if everything ok
    """
    if not assumptions:
        with open('assumption_set.info', 'w') as f:
            f.write('1\n')
    else:
        chk = (i in ['2', '3'] for i in assumptions)
        if any(chk) == False:
            print "assumption undefined!"
            print "accepted assumptions: 2 for assumption two and 3 for assumption three"
            return False
        with open('assumption_set.info', 'w') as f:
            f.write(' '.join(assumptions) + '\n')
    return True


def set_diversification(d, iter):
    if d not in config.all_diver_modes:
        assert False, 'unrecognizible diversification mode %d for iteration %d' % (d, iter)
    config.diversification_mode = d
    print 'set diversification mode %d for iteration %d' % (d, iter)
    os.system('echo %d > mode' % d)


def reset_diversification():
    config.diversification_mode = 0


def main():
    """
    Main function
    """
    p = ArgumentParser(formatter_class=RawTextHelpFormatter)
    p.add_argument("binary", help="path to the input binary")
    p.add_argument("-o", "--output", help="destination output file")
    p.add_argument("-g", "--instrument", action='store_true', help="apply instrumentations to output")
    p.add_argument("-a", "--assumption", action="append",
                   help='''this option configures three addtional assumption,
note that two basic assumptions and addtional assumption one
(n-byte alignment) are set by default,
while assumption two and three need to be configured. For example, setting
assumption two and three: -a 2 -a 3''')
    p.add_argument("-gcc", "--gccopt", action="store", default="", help="A string of additional arguments for GCC")
    p.add_argument("-ex", "--exclude", default="", help="""File where each line is either a single value which must not be
a label or an address range of data section to exclude from symbol search""")
    p.add_argument("-fex", "--functionexclude", default="", help="File with a list of symbols not representing functions")
    p.add_argument("--version", action="version", version="Uroboros 0.2b")

    p.add_argument('-i', '--iteration', type=int, help='the number of disassemble-diversify-reassemble iterations')
    p.add_argument('-d', '--diversification', type=int, action='append',
                   help='the sequence of diversification for every iteration \n' + config.diversification_description)

    args = p.parse_args()
    filepath = os.path.realpath(args.binary)
    outpath = os.path.realpath(args.output) if args.output is not None else None
    exclude = os.path.realpath(args.exclude) if len(args.exclude) > 0 else ''
    fexclude = os.path.realpath(args.functionexclude) if len(args.functionexclude) > 0 else ''

    num_iteration = args.iteration
    if num_iteration is None or num_iteration <= 0:
        num_iteration = 1

    diversifications = args.diversification
    if diversifications is None:
        diversifications = [0]
    while len(diversifications) < num_iteration:
        diversifications.append(diversifications[-1])

    abs_path = os.path.dirname(os.path.abspath(__file__))

    for i in range(1, num_iteration + 1):
        workdir = abs_path + '/workdir_' + str(i)
        if not os.path.isdir(workdir):
            os.mkdir(workdir)

        print colored(('iteration %d dir:' + workdir) % i, 'green')
        os.chdir(workdir)
        # run after setting the work directory
        set_diversification(diversifications[i - 1], i)

        if check(filepath, args.assumption, args.gccopt, exclude, args.instrument) and set_assumption(args.assumption):
            if process(os.path.basename(filepath), args.instrument, fexclude):
                os.system('strip a.out')
                print colored("Processing %d succeeded" % i, "blue")
                if outpath is not None:
                    shutil.copy('a.out', outpath + '_' + str(i) + '_mode_' + str(config.diversification_mode))
                    shutil.copy('a.out', outpath)
                # change source file path
                filepath = workdir + '/a.out'
            else:
                print colored("Processing %d failed" % i, "red")
                exit(1)
        reset_diversification()


if __name__ == "__main__":
    main()
"""
Main module
"""

import glob
import os
import shutil
import sys
from argparse import ArgumentParser, RawTextHelpFormatter

from termcolor import colored

import config


def process(filepath, instrument=False, fexclude=''):
    """
    Start file processing
    :param filepath: path to executable
    :param instrument: True to apply instrumentation
    :param fexclude: path to file of symbol exclusions
    :return: True if everything ok
    """
    import init
    import traceback
    from postprocess import compile_process
    from disasm import main_discover, func_addr

    print "Starting to process binary '" + filepath + "'"
    try:

        func_addr.func_addr(filepath, 0, fexclude)

        os.system(config.strip + ' ' + filepath)
        main_discover.main_discover(filepath)

        init.main(filepath, instrument)
        if not os.path.isfile("final.s"): return False

        with open('final_data.s', 'a') as f:
            f.write('\n.section .eh_frame\n')
            with open('eh_frame_split.info') as eh: f.write(eh.read())
            f.write('\n.section .eh_frame_hdr\n')
            with open('eh_frame_hdr_split.info') as eh: f.write(eh.read())
        with open('final.s', 'a') as f:
            with open('final_data.s', 'r') as fd: f.write(fd.read())
            if instrument: f.write('\n\n'.join(map(lambda e: e['plain'].instrdata, config.instrumentors)))

        compile_process.main(filepath)
        if instrument:
            for worker in config.instrumentors:
                worker['main'].aftercompile()
        if compile_process.reassemble() != 0: return False

    except Exception as e:
        print e
        traceback.print_exc()
        return False

    return True


def check(filepath, assumptions, gccopt='', excludedata='', instrument=False):
    """
    Perform basic check on analyzed executable and set configuration values
    :param filepath: path to executable
    :param assumptions: list of assumption codes
    :param gccopt: additional options for the compiler
    :param excludedata: path to file of address exclusions
    :param instrument: True if instrumentation enabled
    :return: True if everything ok
    """
    if not assumptions: assumptions = []

    if not os.path.isfile(filepath):
        sys.stderr.write("Cannot find input binary\n")
        return False

    if len(excludedata) != 0 and not os.path.isfile(excludedata):
        sys.stderr.write("File with exclusions not found\n")
        return False

    for f in glob.glob('*'): os.remove(f)

    if os.path.dirname(filepath) != os.getcwd():
        shutil.copy(filepath, '.')

    os.system('file ' + filepath + ' > elf.info')
    config.setup(filepath, gccopt, excludedata, instrument)

    if config.is_lib:
        sys.stderr.write("Uroboros doesn't support shared libraries\n")
        return False

    # if assumption three is utilized, then input binary should be unstripped.
    if ('3' in assumptions or instrument) and not config.is_unstrip:
        print colored('Warning:', 'yellow'), 'binary is stripped, function boundaries evaluation may not be precise'

    return True


def set_assumption (assumptions):
    """
    Save assumptions to file
    2 -> assumption two: fix data section starting address
    3 -> assumption three: function starting address + jump table
    :param assumptions: list of assumptions codes
    :return: True if everything ok
    """
    if not assumptions:
        with open('assumption_set.info', 'w') as f:
            f.write('1\n')
    else:
        chk = (i in ['2', '3'] for i in assumptions)
        if any(chk) == False:
            print "assumption undefined!"
            print "accepted assumptions: 2 for assumption two and 3 for assumption three"
            return False
        with open('assumption_set.info', 'w') as f:
            f.write(' '.join(assumptions) + '\n')
    return True


def set_diversification(d, iter):
    if d not in config.all_diver_modes:
        assert False, 'unrecognizible diversification mode %d for iteration %d' % (d, iter)
    config.diversification_mode = d
    print 'set diversification mode %d for iteration %d' % (d, iter)
    os.system('echo %d > mode' % d)


def reset_diversification():
    config.diversification_mode = 0


def main():
    """
    Main function
    """
    p = ArgumentParser(formatter_class=RawTextHelpFormatter)
    p.add_argument("binary", help="path to the input binary")
    p.add_argument("-o", "--output", help="destination output file")
    p.add_argument("-g", "--instrument", action='store_true', help="apply instrumentations to output")
    p.add_argument("-a", "--assumption", action="append",
                   help='''this option configures three addtional assumption,
note that two basic assumptions and addtional assumption one
(n-byte alignment) are set by default,
while assumption two and three need to be configured. For example, setting
assumption two and three: -a 2 -a 3''')
    p.add_argument("-gcc", "--gccopt", action="store", default="", help="A string of additional arguments for GCC")
    p.add_argument("-ex", "--exclude", default="", help="""File where each line is either a single value which must not be
a label or an address range of data section to exclude from symbol search""")
    p.add_argument("-fex", "--functionexclude", default="", help="File with a list of symbols not representing functions")
    p.add_argument("--version", action="version", version="Uroboros 0.2b")

    p.add_argument('-i', '--iteration', type=int, help='the number of disassemble-diversify-reassemble iterations')
    p.add_argument('-d', '--diversification', type=int, action='append',
                   help='the sequence of diversification for every iteration \n' + config.diversification_description)

    args = p.parse_args()
    filepath = os.path.realpath(args.binary)
    outpath = os.path.realpath(args.output) if args.output is not None else None
    exclude = os.path.realpath(args.exclude) if len(args.exclude) > 0 else ''
    fexclude = os.path.realpath(args.functionexclude) if len(args.functionexclude) > 0 else ''

    num_iteration = args.iteration
    if num_iteration is None or num_iteration <= 0:
        num_iteration = 1

    diversifications = args.diversification
    if diversifications is None:
        diversifications = [0]
    while len(diversifications) < num_iteration:
        diversifications.append(diversifications[-1])

    abs_path = os.path.dirname(os.path.abspath(__file__))

    for i in range(1, num_iteration + 1):
        workdir = abs_path + '/workdir_' + str(i)
        if not os.path.isdir(workdir):
            os.mkdir(workdir)

        print colored(('iteration %d dir:' + workdir) % i, 'green')
        os.chdir(workdir)
        # run after setting the work directory
        set_diversification(diversifications[i - 1], i)

        if check(filepath, args.assumption, args.gccopt, exclude, args.instrument) and set_assumption(args.assumption):
            if process(os.path.basename(filepath), args.instrument, fexclude):
                os.system('strip a.out')
                print colored("Processing %d succeeded" % i, "blue")
                if outpath is not None:
                    shutil.copy('a.out', outpath + '_' + str(i) + '_mode_' + str(config.diversification_mode))
                    shutil.copy('a.out', outpath)
                # change source file path
                filepath = workdir + '/a.out'
            else:
                print colored("Processing %d failed" % i, "red")
                exit(1)
        reset_diversification()


if __name__ == "__main__":
    main()
"""
Main module
"""

import glob
import os
import shutil
import sys
from argparse import ArgumentParser, RawTextHelpFormatter

from termcolor import colored

import config


def process(filepath, instrument=False, fexclude=''):
    """
    Start file processing
    :param filepath: path to executable
    :param instrument: True to apply instrumentation
    :param fexclude: path to file of symbol exclusions
    :return: True if everything ok
    """
    import init
    import traceback
    from postprocess import compile_process
    from disasm import main_discover, func_addr

    print "Starting to process binary '" + filepath + "'"
    try:

        func_addr.func_addr(filepath, 0, fexclude)

        os.system(config.strip + ' ' + filepath)
        main_discover.main_discover(filepath)

        init.main(filepath, instrument)
        if not os.path.isfile("final.s"): return False

        with open('final_data.s', 'a') as f:
            f.write('\n.section .eh_frame\n')
            with open('eh_frame_split.info') as eh: f.write(eh.read())
            f.write('\n.section .eh_frame_hdr\n')
            with open('eh_frame_hdr_split.info') as eh: f.write(eh.read())
        with open('final.s', 'a') as f:
            with open('final_data.s', 'r') as fd: f.write(fd.read())
            if instrument: f.write('\n\n'.join(map(lambda e: e['plain'].instrdata, config.instrumentors)))

        compile_process.main(filepath)
        if instrument:
            for worker in config.instrumentors:
                worker['main'].aftercompile()
        if compile_process.reassemble() != 0: return False

    except Exception as e:
        print e
        traceback.print_exc()
        return False

    return True


def check(filepath, assumptions, gccopt='', excludedata='', instrument=False):
    """
    Perform basic check on analyzed executable and set configuration values
    :param filepath: path to executable
    :param assumptions: list of assumption codes
    :param gccopt: additional options for the compiler
    :param excludedata: path to file of address exclusions
    :param instrument: True if instrumentation enabled
    :return: True if everything ok
    """
    if not assumptions: assumptions = []

    if not os.path.isfile(filepath):
        sys.stderr.write("Cannot find input binary\n")
        return False

    if len(excludedata) != 0 and not os.path.isfile(excludedata):
        sys.stderr.write("File with exclusions not found\n")
        return False

    for f in glob.glob('*'): os.remove(f)

    if os.path.dirname(filepath) != os.getcwd():
        shutil.copy(filepath, '.')

    os.system('file ' + filepath + ' > elf.info')
    config.setup(filepath, gccopt, excludedata, instrument)

    if config.is_lib:
        sys.stderr.write("Uroboros doesn't support shared libraries\n")
        return False

    # if assumption three is utilized, then input binary should be unstripped.
    if ('3' in assumptions or instrument) and not config.is_unstrip:
        print colored('Warning:', 'yellow'), 'binary is stripped, function boundaries evaluation may not be precise'

    return True


def set_assumption (assumptions):
    """
    Save assumptions to file
    2 -> assumption two: fix data section starting address
    3 -> assumption three: function starting address + jump table
    :param assumptions: list of assumptions codes
    :return: True if everything ok
    """
    if not assumptions:
        with open('assumption_set.info', 'w') as f:
            f.write('1\n')
    else:
        chk = (i in ['2', '3'] for i in assumptions)
        if any(chk) == False:
            print "assumption undefined!"
            print "accepted assumptions: 2 for assumption two and 3 for assumption three"
            return False
        with open('assumption_set.info', 'w') as f:
            f.write(' '.join(assumptions) + '\n')
    return True


def set_diversification(d, iter):
    if d not in config.all_diver_modes:
        assert False, 'unrecognizible diversification mode %d for iteration %d' % (d, iter)
    config.diversification_mode = d
    print 'set diversification mode %d for iteration %d' % (d, iter)
    os.system('echo %d > mode' % d)


def reset_diversification():
    config.diversification_mode = 0


def main():
    """
    Main function
    """
    p = ArgumentParser(formatter_class=RawTextHelpFormatter)
    p.add_argument("binary", help="path to the input binary")
    p.add_argument("-o", "--output", help="destination output file")
    p.add_argument("-g", "--instrument", action='store_true', help="apply instrumentations to output")
    p.add_argument("-a", "--assumption", action="append",
                   help='''this option configures three addtional assumption,
note that two basic assumptions and addtional assumption one
(n-byte alignment) are set by default,
while assumption two and three need to be configured. For example, setting
assumption two and three: -a 2 -a 3''')
    p.add_argument("-gcc", "--gccopt", action="store", default="", help="A string of additional arguments for GCC")
    p.add_argument("-ex", "--exclude", default="", help="""File where each line is either a single value which must not be
a label or an address range of data section to exclude from symbol search""")
    p.add_argument("-fex", "--functionexclude", default="", help="File with a list of symbols not representing functions")
    p.add_argument("--version", action="version", version="Uroboros 0.2b")

    p.add_argument('-i', '--iteration', type=int, help='the number of disassemble-diversify-reassemble iterations')
    p.add_argument('-d', '--diversification', type=int, action='append',
                   help='the sequence of diversification for every iteration \n' + config.diversification_description)

    args = p.parse_args()
    filepath = os.path.realpath(args.binary)
    outpath = os.path.realpath(args.output) if args.output is not None else None
    exclude = os.path.realpath(args.exclude) if len(args.exclude) > 0 else ''
    fexclude = os.path.realpath(args.functionexclude) if len(args.functionexclude) > 0 else ''

    num_iteration = args.iteration
    if num_iteration is None or num_iteration <= 0:
        num_iteration = 1

    diversifications = args.diversification
    if diversifications is None:
        diversifications = [0]
    while len(diversifications) < num_iteration:
        diversifications.append(diversifications[-1])

    abs_path = os.path.dirname(os.path.abspath(__file__))

    for i in range(1, num_iteration + 1):
        workdir = abs_path + '/workdir_' + str(i)
        if not os.path.isdir(workdir):
            os.mkdir(workdir)

        print colored(('iteration %d dir:' + workdir) % i, 'green')
        os.chdir(workdir)
        # run after setting the work directory
        set_diversification(diversifications[i - 1], i)

        if check(filepath, args.assumption, args.gccopt, exclude, args.instrument) and set_assumption(args.assumption):
            if process(os.path.basename(filepath), args.instrument, fexclude):
                os.system('strip a.out')
                print colored("Processing %d succeeded" % i, "blue")
                if outpath is not None:
                    shutil.copy('a.out', outpath + '_' + str(i) + '_mode_' + str(config.diversification_mode))
                    shutil.copy('a.out', outpath)
                # change source file path
                filepath = workdir + '/a.out'
            else:
                print colored("Processing %d failed" % i, "red")
                exit(1)
        reset_diversification()


if __name__ == "__main__":
    main()
"""
Main module
"""

import glob
import os
import shutil
import sys
from argparse import ArgumentParser, RawTextHelpFormatter

from termcolor import colored

import config


def process(filepath, instrument=False, fexclude=''):
    """
    Start file processing
    :param filepath: path to executable
    :param instrument: True to apply instrumentation
    :param fexclude: path to file of symbol exclusions
    :return: True if everything ok
    """
    import init
    import traceback
    from postprocess import compile_process
    from disasm import main_discover, func_addr

    print "Starting to process binary '" + filepath + "'"
    try:

        func_addr.func_addr(filepath, 0, fexclude)

        os.system(config.strip + ' ' + filepath)
        main_discover.main_discover(filepath)

        init.main(filepath, instrument)
        if not os.path.isfile("final.s"): return False

        with open('final_data.s', 'a') as f:
            f.write('\n.section .eh_frame\n')
            with open('eh_frame_split.info') as eh: f.write(eh.read())
            f.write('\n.section .eh_frame_hdr\n')
            with open('eh_frame_hdr_split.info') as eh: f.write(eh.read())
        with open('final.s', 'a') as f:
            with open('final_data.s', 'r') as fd: f.write(fd.read())
            if instrument: f.write('\n\n'.join(map(lambda e: e['plain'].instrdata, config.instrumentors)))

        compile_process.main(filepath)
        if instrument:
            for worker in config.instrumentors:
                worker['main'].aftercompile()
        if compile_process.reassemble() != 0: return False

    except Exception as e:
        print e
        traceback.print_exc()
        return False

    return True


def check(filepath, assumptions, gccopt='', excludedata='', instrument=False):
    """
    Perform basic check on analyzed executable and set configuration values
    :param filepath: path to executable
    :param assumptions: list of assumption codes
    :param gccopt: additional options for the compiler
    :param excludedata: path to file of address exclusions
    :param instrument: True if instrumentation enabled
    :return: True if everything ok
    """
    if not assumptions: assumptions = []

    if not os.path.isfile(filepath):
        sys.stderr.write("Cannot find input binary\n")
        return False

    if len(excludedata) != 0 and not os.path.isfile(excludedata):
        sys.stderr.write("File with exclusions not found\n")
        return False

    for f in glob.glob('*'): os.remove(f)

    if os.path.dirname(filepath) != os.getcwd():
        shutil.copy(filepath, '.')

    os.system('file ' + filepath + ' > elf.info')
    config.setup(filepath, gccopt, excludedata, instrument)

    if config.is_lib:
        sys.stderr.write("Uroboros doesn't support shared libraries\n")
        return False

    # if assumption three is utilized, then input binary should be unstripped.
    if ('3' in assumptions or instrument) and not config.is_unstrip:
        print colored('Warning:', 'yellow'), 'binary is stripped, function boundaries evaluation may not be precise'

    return True


def set_assumption (assumptions):
    """
    Save assumptions to file
    2 -> assumption two: fix data section starting address
    3 -> assumption three: function starting address + jump table
    :param assumptions: list of assumptions codes
    :return: True if everything ok
    """
    if not assumptions:
        with open('assumption_set.info', 'w') as f:
            f.write('1\n')
    else:
        chk = (i in ['2', '3'] for i in assumptions)
        if any(chk) == False:
            print "assumption undefined!"
            print "accepted assumptions: 2 for assumption two and 3 for assumption three"
            return False
        with open('assumption_set.info', 'w') as f:
            f.write(' '.join(assumptions) + '\n')
    return True


def set_diversification(d, iter):
    if d not in config.all_diver_modes:
        assert False, 'unrecognizible diversification mode %d for iteration %d' % (d, iter)
    config.diversification_mode = d
    print 'set diversification mode %d for iteration %d' % (d, iter)
    os.system('echo %d > mode' % d)


def reset_diversification():
    config.diversification_mode = 0


def main():
    """
    Main function
    """
    p = ArgumentParser(formatter_class=RawTextHelpFormatter)
    p.add_argument("binary", help="path to the input binary")
    p.add_argument("-o", "--output", help="destination output file")
    p.add_argument("-g", "--instrument", action='store_true', help="apply instrumentations to output")
    p.add_argument("-a", "--assumption", action="append",
                   help='''this option configures three addtional assumption,
note that two basic assumptions and addtional assumption one
(n-byte alignment) are set by default,
while assumption two and three need to be configured. For example, setting
assumption two and three: -a 2 -a 3''')
    p.add_argument("-gcc", "--gccopt", action="store", default="", help="A string of additional arguments for GCC")
    p.add_argument("-ex", "--exclude", default="", help="""File where each line is either a single value which must not be
a label or an address range of data section to exclude from symbol search""")
    p.add_argument("-fex", "--functionexclude", default="", help="File with a list of symbols not representing functions")
    p.add_argument("--version", action="version", version="Uroboros 0.2b")

    p.add_argument('-i', '--iteration', type=int, help='the number of disassemble-diversify-reassemble iterations')
    p.add_argument('-d', '--diversification', type=int, action='append',
                   help='the sequence of diversification for every iteration \n' + config.diversification_description)

    args = p.parse_args()
    filepath = os.path.realpath(args.binary)
    outpath = os.path.realpath(args.output) if args.output is not None else None
    exclude = os.path.realpath(args.exclude) if len(args.exclude) > 0 else ''
    fexclude = os.path.realpath(args.functionexclude) if len(args.functionexclude) > 0 else ''

    num_iteration = args.iteration
    if num_iteration is None or num_iteration <= 0:
        num_iteration = 1

    diversifications = args.diversification
    if diversifications is None:
        diversifications = [0]
    while len(diversifications) < num_iteration:
        diversifications.append(diversifications[-1])

    abs_path = os.path.dirname(os.path.abspath(__file__))

    for i in range(1, num_iteration + 1):
        workdir = abs_path + '/workdir_' + str(i)
        if not os.path.isdir(workdir):
            os.mkdir(workdir)

        print colored(('iteration %d dir:' + workdir) % i, 'green')
        os.chdir(workdir)
        # run after setting the work directory
        set_diversification(diversifications[i - 1], i)

        if check(filepath, args.assumption, args.gccopt, exclude, args.instrument) and set_assumption(args.assumption):
            if process(os.path.basename(filepath), args.instrument, fexclude):
                os.system('strip a.out')
                print colored("Processing %d succeeded" % i, "blue")
                if outpath is not None:
                    shutil.copy('a.out', outpath + '_' + str(i) + '_mode_' + str(config.diversification_mode))
                    shutil.copy('a.out', outpath)
                # change source file path
                filepath = workdir + '/a.out'
            else:
                print colored("Processing %d failed" % i, "red")
                exit(1)
        reset_diversification()


if __name__ == "__main__":
    main()
"""
Main module
"""

import glob
import os
import shutil
import sys
from argparse import ArgumentParser, RawTextHelpFormatter

from termcolor import colored

import config


def process(filepath, instrument=False, fexclude=''):
    """
    Start file processing
    :param filepath: path to executable
    :param instrument: True to apply instrumentation
    :param fexclude: path to file of symbol exclusions
    :return: True if everything ok
    """
    import init
    import traceback
    from postprocess import compile_process
    from disasm import main_discover, func_addr

    print "Starting to process binary '" + filepath + "'"
    try:

        func_addr.func_addr(filepath, 0, fexclude)

        os.system(config.strip + ' ' + filepath)
        main_discover.main_discover(filepath)

        init.main(filepath, instrument)
        if not os.path.isfile("final.s"): return False

        with open('final_data.s', 'a') as f:
            f.write('\n.section .eh_frame\n')
            with open('eh_frame_split.info') as eh: f.write(eh.read())
            f.write('\n.section .eh_frame_hdr\n')
            with open('eh_frame_hdr_split.info') as eh: f.write(eh.read())
        with open('final.s', 'a') as f:
            with open('final_data.s', 'r') as fd: f.write(fd.read())
            if instrument: f.write('\n\n'.join(map(lambda e: e['plain'].instrdata, config.instrumentors)))

        compile_process.main(filepath)
        if instrument:
            for worker in config.instrumentors:
                worker['main'].aftercompile()
        if compile_process.reassemble() != 0: return False

    except Exception as e:
        print e
        traceback.print_exc()
        return False

    return True


def check(filepath, assumptions, gccopt='', excludedata='', instrument=False):
    """
    Perform basic check on analyzed executable and set configuration values
    :param filepath: path to executable
    :param assumptions: list of assumption codes
    :param gccopt: additional options for the compiler
    :param excludedata: path to file of address exclusions
    :param instrument: True if instrumentation enabled
    :return: True if everything ok
    """
    if not assumptions: assumptions = []

    if not os.path.isfile(filepath):
        sys.stderr.write("Cannot find input binary\n")
        return False

    if len(excludedata) != 0 and not os.path.isfile(excludedata):
        sys.stderr.write("File with exclusions not found\n")
        return False

    for f in glob.glob('*'): os.remove(f)

    if os.path.dirname(filepath) != os.getcwd():
        shutil.copy(filepath, '.')

    os.system('file ' + filepath + ' > elf.info')
    config.setup(filepath, gccopt, excludedata, instrument)

    if config.is_lib:
        sys.stderr.write("Uroboros doesn't support shared libraries\n")
        return False

    # if assumption three is utilized, then input binary should be unstripped.
    if ('3' in assumptions or instrument) and not config.is_unstrip:
        print colored('Warning:', 'yellow'), 'binary is stripped, function boundaries evaluation may not be precise'

    return True


def set_assumption (assumptions):
    """
    Save assumptions to file
    2 -> assumption two: fix data section starting address
    3 -> assumption three: function starting address + jump table
    :param assumptions: list of assumptions codes
    :return: True if everything ok
    """
    if not assumptions:
        with open('assumption_set.info', 'w') as f:
            f.write('1\n')
    else:
        chk = (i in ['2', '3'] for i in assumptions)
        if any(chk) == False:
            print "assumption undefined!"
            print "accepted assumptions: 2 for assumption two and 3 for assumption three"
            return False
        with open('assumption_set.info', 'w') as f:
            f.write(' '.join(assumptions) + '\n')
    return True


def set_diversification(d, iter):
    if d not in config.all_diver_modes:
        assert False, 'unrecognizible diversification mode %d for iteration %d' % (d, iter)
    config.diversification_mode = d
    print 'set diversification mode %d for iteration %d' % (d, iter)
    os.system('echo %d > mode' % d)


def reset_diversification():
    config.diversification_mode = 0


def main():
    """
    Main function
    """
    p = ArgumentParser(formatter_class=RawTextHelpFormatter)
    p.add_argument("binary", help="path to the input binary")
    p.add_argument("-o", "--output", help="destination output file")
    p.add_argument("-g", "--instrument", action='store_true', help="apply instrumentations to output")
    p.add_argument("-a", "--assumption", action="append",
                   help='''this option configures three addtional assumption,
note that two basic assumptions and addtional assumption one
(n-byte alignment) are set by default,
while assumption two and three need to be configured. For example, setting
assumption two and three: -a 2 -a 3''')
    p.add_argument("-gcc", "--gccopt", action="store", default="", help="A string of additional arguments for GCC")
    p.add_argument("-ex", "--exclude", default="", help="""File where each line is either a single value which must not be
a label or an address range of data section to exclude from symbol search""")
    p.add_argument("-fex", "--functionexclude", default="", help="File with a list of symbols not representing functions")
    p.add_argument("--version", action="version", version="Uroboros 0.2b")

    p.add_argument('-i', '--iteration', type=int, help='the number of disassemble-diversify-reassemble iterations')
    p.add_argument('-d', '--diversification', type=int, action='append',
                   help='the sequence of diversification for every iteration \n' + config.diversification_description)

    args = p.parse_args()
    filepath = os.path.realpath(args.binary)
    outpath = os.path.realpath(args.output) if args.output is not None else None
    exclude = os.path.realpath(args.exclude) if len(args.exclude) > 0 else ''
    fexclude = os.path.realpath(args.functionexclude) if len(args.functionexclude) > 0 else ''

    num_iteration = args.iteration
    if num_iteration is None or num_iteration <= 0:
        num_iteration = 1

    diversifications = args.diversification
    if diversifications is None:
        diversifications = [0]
    while len(diversifications) < num_iteration:
        diversifications.append(diversifications[-1])

    abs_path = os.path.dirname(os.path.abspath(__file__))

    for i in range(1, num_iteration + 1):
        workdir = abs_path + '/workdir_' + str(i)
        if not os.path.isdir(workdir):
            os.mkdir(workdir)

        print colored(('iteration %d dir:' + workdir) % i, 'green')
        os.chdir(workdir)
        # run after setting the work directory
        set_diversification(diversifications[i - 1], i)

        if check(filepath, args.assumption, args.gccopt, exclude, args.instrument) and set_assumption(args.assumption):
            if process(os.path.basename(filepath), args.instrument, fexclude):
                os.system('strip a.out')
                print colored("Processing %d succeeded" % i, "blue")
                if outpath is not None:
                    shutil.copy('a.out', outpath + '_' + str(i) + '_mode_' + str(config.diversification_mode))
                    shutil.copy('a.out', outpath)
                # change source file path
                filepath = workdir + '/a.out'
            else:
                print colored("Processing %d failed" % i, "red")
                exit(1)
        reset_diversification()


if __name__ == "__main__":
    main()
"""
Main module
"""

import glob
import os
import shutil
import sys
from argparse import ArgumentParser, RawTextHelpFormatter

from termcolor import colored

import config


def process(filepath, instrument=False, fexclude=''):
    """
    Start file processing
    :param filepath: path to executable
    :param instrument: True to apply instrumentation
    :param fexclude: path to file of symbol exclusions
    :return: True if everything ok
    """
    import init
    import traceback
    from postprocess import compile_process
    from disasm import main_discover, func_addr

    print "Starting to process binary '" + filepath + "'"
    try:

        func_addr.func_addr(filepath, 0, fexclude)

        os.system(config.strip + ' ' + filepath)
        main_discover.main_discover(filepath)

        init.main(filepath, instrument)
        if not os.path.isfile("final.s"): return False

        with open('final_data.s', 'a') as f:
            f.write('\n.section .eh_frame\n')
            with open('eh_frame_split.info') as eh: f.write(eh.read())
            f.write('\n.section .eh_frame_hdr\n')
            with open('eh_frame_hdr_split.info') as eh: f.write(eh.read())
        with open('final.s', 'a') as f:
            with open('final_data.s', 'r') as fd: f.write(fd.read())
            if instrument: f.write('\n\n'.join(map(lambda e: e['plain'].instrdata, config.instrumentors)))

        compile_process.main(filepath)
        if instrument:
            for worker in config.instrumentors:
                worker['main'].aftercompile()
        if compile_process.reassemble() != 0: return False

    except Exception as e:
        print e
        traceback.print_exc()
        return False

    return True


def check(filepath, assumptions, gccopt='', excludedata='', instrument=False):
    """
    Perform basic check on analyzed executable and set configuration values
    :param filepath: path to executable
    :param assumptions: list of assumption codes
    :param gccopt: additional options for the compiler
    :param excludedata: path to file of address exclusions
    :param instrument: True if instrumentation enabled
    :return: True if everything ok
    """
    if not assumptions: assumptions = []

    if not os.path.isfile(filepath):
        sys.stderr.write("Cannot find input binary\n")
        return False

    if len(excludedata) != 0 and not os.path.isfile(excludedata):
        sys.stderr.write("File with exclusions not found\n")
        return False

    for f in glob.glob('*'): os.remove(f)

    if os.path.dirname(filepath) != os.getcwd():
        shutil.copy(filepath, '.')

    os.system('file ' + filepath + ' > elf.info')
    config.setup(filepath, gccopt, excludedata, instrument)

    if config.is_lib:
        sys.stderr.write("Uroboros doesn't support shared libraries\n")
        return False

    # if assumption three is utilized, then input binary should be unstripped.
    if ('3' in assumptions or instrument) and not config.is_unstrip:
        print colored('Warning:', 'yellow'), 'binary is stripped, function boundaries evaluation may not be precise'

    return True


def set_assumption (assumptions):
    """
    Save assumptions to file
    2 -> assumption two: fix data section starting address
    3 -> assumption three: function starting address + jump table
    :param assumptions: list of assumptions codes
    :return: True if everything ok
    """
    if not assumptions:
        with open('assumption_set.info', 'w') as f:
            f.write('1\n')
    else:
        chk = (i in ['2', '3'] for i in assumptions)
        if any(chk) == False:
            print "assumption undefined!"
            print "accepted assumptions: 2 for assumption two and 3 for assumption three"
            return False
        with open('assumption_set.info', 'w') as f:
            f.write(' '.join(assumptions) + '\n')
    return True


def set_diversification(d, iter):
    if d not in config.all_diver_modes:
        assert False, 'unrecognizible diversification mode %d for iteration %d' % (d, iter)
    config.diversification_mode = d
    print 'set diversification mode %d for iteration %d' % (d, iter)
    os.system('echo %d > mode' % d)


def reset_diversification():
    config.diversification_mode = 0


def main():
    """
    Main function
    """
    p = ArgumentParser(formatter_class=RawTextHelpFormatter)
    p.add_argument("binary", help="path to the input binary")
    p.add_argument("-o", "--output", help="destination output file")
    p.add_argument("-g", "--instrument", action='store_true', help="apply instrumentations to output")
    p.add_argument("-a", "--assumption", action="append",
                   help='''this option configures three addtional assumption,
note that two basic assumptions and addtional assumption one
(n-byte alignment) are set by default,
while assumption two and three need to be configured. For example, setting
assumption two and three: -a 2 -a 3''')
    p.add_argument("-gcc", "--gccopt", action="store", default="", help="A string of additional arguments for GCC")
    p.add_argument("-ex", "--exclude", default="", help="""File where each line is either a single value which must not be
a label or an address range of data section to exclude from symbol search""")
    p.add_argument("-fex", "--functionexclude", default="", help="File with a list of symbols not representing functions")
    p.add_argument("--version", action="version", version="Uroboros 0.2b")

    p.add_argument('-i', '--iteration', type=int, help='the number of disassemble-diversify-reassemble iterations')
    p.add_argument('-d', '--diversification', type=int, action='append',
                   help='the sequence of diversification for every iteration \n' + config.diversification_description)

    args = p.parse_args()
    filepath = os.path.realpath(args.binary)
    outpath = os.path.realpath(args.output) if args.output is not None else None
    exclude = os.path.realpath(args.exclude) if len(args.exclude) > 0 else ''
    fexclude = os.path.realpath(args.functionexclude) if len(args.functionexclude) > 0 else ''

    num_iteration = args.iteration
    if num_iteration is None or num_iteration <= 0:
        num_iteration = 1

    diversifications = args.diversification
    if diversifications is None:
        diversifications = [0]
    while len(diversifications) < num_iteration:
        diversifications.append(diversifications[-1])

    abs_path = os.path.dirname(os.path.abspath(__file__))

    for i in range(1, num_iteration + 1):
        workdir = abs_path + '/workdir_' + str(i)
        if not os.path.isdir(workdir):
            os.mkdir(workdir)

        print colored(('iteration %d dir:' + workdir) % i, 'green')
        os.chdir(workdir)
        # run after setting the work directory
        set_diversification(diversifications[i - 1], i)

        if check(filepath, args.assumption, args.gccopt, exclude, args.instrument) and set_assumption(args.assumption):
            if process(os.path.basename(filepath), args.instrument, fexclude):
                os.system('strip a.out')
                print colored("Processing %d succeeded" % i, "blue")
                if outpath is not None:
                    shutil.copy('a.out', outpath + '_' + str(i) + '_mode_' + str(config.diversification_mode))
                    shutil.copy('a.out', outpath)
                # change source file path
                filepath = workdir + '/a.out'
            else:
                print colored("Processing %d failed" % i, "red")
                exit(1)
        reset_diversification()


if __name__ == "__main__":
    main()
"""
Main module
"""

import glob
import os
import shutil
import sys
from argparse import ArgumentParser, RawTextHelpFormatter

from termcolor import colored

import config


def process(filepath, instrument=False, fexclude=''):
    """
    Start file processing
    :param filepath: path to executable
    :param instrument: True to apply instrumentation
    :param fexclude: path to file of symbol exclusions
    :return: True if everything ok
    """
    import init
    import traceback
    from postprocess import compile_process
    from disasm import main_discover, func_addr

    print "Starting to process binary '" + filepath + "'"
    try:

        func_addr.func_addr(filepath, 0, fexclude)

        os.system(config.strip + ' ' + filepath)
        main_discover.main_discover(filepath)

        init.main(filepath, instrument)
        if not os.path.isfile("final.s"): return False

        with open('final_data.s', 'a') as f:
            f.write('\n.section .eh_frame\n')
            with open('eh_frame_split.info') as eh: f.write(eh.read())
            f.write('\n.section .eh_frame_hdr\n')
            with open('eh_frame_hdr_split.info') as eh: f.write(eh.read())
        with open('final.s', 'a') as f:
            with open('final_data.s', 'r') as fd: f.write(fd.read())
            if instrument: f.write('\n\n'.join(map(lambda e: e['plain'].instrdata, config.instrumentors)))

        compile_process.main(filepath)
        if instrument:
            for worker in config.instrumentors:
                worker['main'].aftercompile()
        if compile_process.reassemble() != 0: return False

    except Exception as e:
        print e
        traceback.print_exc()
        return False

    return True


def check(filepath, assumptions, gccopt='', excludedata='', instrument=False):
    """
    Perform basic check on analyzed executable and set configuration values
    :param filepath: path to executable
    :param assumptions: list of assumption codes
    :param gccopt: additional options for the compiler
    :param excludedata: path to file of address exclusions
    :param instrument: True if instrumentation enabled
    :return: True if everything ok
    """
    if not assumptions: assumptions = []

    if not os.path.isfile(filepath):
        sys.stderr.write("Cannot find input binary\n")
        return False

    if len(excludedata) != 0 and not os.path.isfile(excludedata):
        sys.stderr.write("File with exclusions not found\n")
        return False

    for f in glob.glob('*'): os.remove(f)

    if os.path.dirname(filepath) != os.getcwd():
        shutil.copy(filepath, '.')

    os.system('file ' + filepath + ' > elf.info')
    config.setup(filepath, gccopt, excludedata, instrument)

    if config.is_lib:
        sys.stderr.write("Uroboros doesn't support shared libraries\n")
        return False

    # if assumption three is utilized, then input binary should be unstripped.
    if ('3' in assumptions or instrument) and not config.is_unstrip:
        print colored('Warning:', 'yellow'), 'binary is stripped, function boundaries evaluation may not be precise'

    return True


def set_assumption (assumptions):
    """
    Save assumptions to file
    2 -> assumption two: fix data section starting address
    3 -> assumption three: function starting address + jump table
    :param assumptions: list of assumptions codes
    :return: True if everything ok
    """
    if not assumptions:
        with open('assumption_set.info', 'w') as f:
            f.write('1\n')
    else:
        chk = (i in ['2', '3'] for i in assumptions)
        if any(chk) == False:
            print "assumption undefined!"
            print "accepted assumptions: 2 for assumption two and 3 for assumption three"
            return False
        with open('assumption_set.info', 'w') as f:
            f.write(' '.join(assumptions) + '\n')
    return True


def set_diversification(d, iter):
    if d not in config.all_diver_modes:
        assert False, 'unrecognizible diversification mode %d for iteration %d' % (d, iter)
    config.diversification_mode = d
    print 'set diversification mode %d for iteration %d' % (d, iter)
    os.system('echo %d > mode' % d)


def reset_diversification():
    config.diversification_mode = 0


def main():
    """
    Main function
    """
    p = ArgumentParser(formatter_class=RawTextHelpFormatter)
    p.add_argument("binary", help="path to the input binary")
    p.add_argument("-o", "--output", help="destination output file")
    p.add_argument("-g", "--instrument", action='store_true', help="apply instrumentations to output")
    p.add_argument("-a", "--assumption", action="append",
                   help='''this option configures three addtional assumption,
note that two basic assumptions and addtional assumption one
(n-byte alignment) are set by default,
while assumption two and three need to be configured. For example, setting
assumption two and three: -a 2 -a 3''')
    p.add_argument("-gcc", "--gccopt", action="store", default="", help="A string of additional arguments for GCC")
    p.add_argument("-ex", "--exclude", default="", help="""File where each line is either a single value which must not be
a label or an address range of data section to exclude from symbol search""")
    p.add_argument("-fex", "--functionexclude", default="", help="File with a list of symbols not representing functions")
    p.add_argument("--version", action="version", version="Uroboros 0.2b")

    p.add_argument('-i', '--iteration', type=int, help='the number of disassemble-diversify-reassemble iterations')
    p.add_argument('-d', '--diversification', type=int, action='append',
                   help='the sequence of diversification for every iteration \n' + config.diversification_description)

    args = p.parse_args()
    filepath = os.path.realpath(args.binary)
    outpath = os.path.realpath(args.output) if args.output is not None else None
    exclude = os.path.realpath(args.exclude) if len(args.exclude) > 0 else ''
    fexclude = os.path.realpath(args.functionexclude) if len(args.functionexclude) > 0 else ''

    num_iteration = args.iteration
    if num_iteration is None or num_iteration <= 0:
        num_iteration = 1

    diversifications = args.diversification
    if diversifications is None:
        diversifications = [0]
    while len(diversifications) < num_iteration:
        diversifications.append(diversifications[-1])

    abs_path = os.path.dirname(os.path.abspath(__file__))

    for i in range(1, num_iteration + 1):
        workdir = abs_path + '/workdir_' + str(i)
        if not os.path.isdir(workdir):
            os.mkdir(workdir)

        print colored(('iteration %d dir:' + workdir) % i, 'green')
        os.chdir(workdir)
        # run after setting the work directory
        set_diversification(diversifications[i - 1], i)

        if check(filepath, args.assumption, args.gccopt, exclude, args.instrument) and set_assumption(args.assumption):
            if process(os.path.basename(filepath), args.instrument, fexclude):
                os.system('strip a.out')
                print colored("Processing %d succeeded" % i, "blue")
                if outpath is not None:
                    shutil.copy('a.out', outpath + '_' + str(i) + '_mode_' + str(config.diversification_mode))
                    shutil.copy('a.out', outpath)
                # change source file path
                filepath = workdir + '/a.out'
            else:
                print colored("Processing %d failed" % i, "red")
                exit(1)
        reset_diversification()


if __name__ == "__main__":
    main()
"""
Main module
"""

import glob
import os
import shutil
import sys
from argparse import ArgumentParser, RawTextHelpFormatter

from termcolor import colored

import config


def process(filepath, instrument=False, fexclude=''):
    """
    Start file processing
    :param filepath: path to executable
    :param instrument: True to apply instrumentation
    :param fexclude: path to file of symbol exclusions
    :return: True if everything ok
    """
    import init
    import traceback
    from postprocess import compile_process
    from disasm import main_discover, func_addr

    print "Starting to process binary '" + filepath + "'"
    try:

        func_addr.func_addr(filepath, 0, fexclude)

        os.system(config.strip + ' ' + filepath)
        main_discover.main_discover(filepath)

        init.main(filepath, instrument)
        if not os.path.isfile("final.s"): return False

        with open('final_data.s', 'a') as f:
            f.write('\n.section .eh_frame\n')
            with open('eh_frame_split.info') as eh: f.write(eh.read())
            f.write('\n.section .eh_frame_hdr\n')
            with open('eh_frame_hdr_split.info') as eh: f.write(eh.read())
        with open('final.s', 'a') as f:
            with open('final_data.s', 'r') as fd: f.write(fd.read())
            if instrument: f.write('\n\n'.join(map(lambda e: e['plain'].instrdata, config.instrumentors)))

        compile_process.main(filepath)
        if instrument:
            for worker in config.instrumentors:
                worker['main'].aftercompile()
        if compile_process.reassemble() != 0: return False

    except Exception as e:
        print e
        traceback.print_exc()
        return False

    return True


def check(filepath, assumptions, gccopt='', excludedata='', instrument=False):
    """
    Perform basic check on analyzed executable and set configuration values
    :param filepath: path to executable
    :param assumptions: list of assumption codes
    :param gccopt: additional options for the compiler
    :param excludedata: path to file of address exclusions
    :param instrument: True if instrumentation enabled
    :return: True if everything ok
    """
    if not assumptions: assumptions = []

    if not os.path.isfile(filepath):
        sys.stderr.write("Cannot find input binary\n")
        return False

    if len(excludedata) != 0 and not os.path.isfile(excludedata):
        sys.stderr.write("File with exclusions not found\n")
        return False

    for f in glob.glob('*'): os.remove(f)

    if os.path.dirname(filepath) != os.getcwd():
        shutil.copy(filepath, '.')

    os.system('file ' + filepath + ' > elf.info')
    config.setup(filepath, gccopt, excludedata, instrument)

    if config.is_lib:
        sys.stderr.write("Uroboros doesn't support shared libraries\n")
        return False

    # if assumption three is utilized, then input binary should be unstripped.
    if ('3' in assumptions or instrument) and not config.is_unstrip:
        print colored('Warning:', 'yellow'), 'binary is stripped, function boundaries evaluation may not be precise'

    return True


def set_assumption (assumptions):
    """
    Save assumptions to file
    2 -> assumption two: fix data section starting address
    3 -> assumption three: function starting address + jump table
    :param assumptions: list of assumptions codes
    :return: True if everything ok
    """
    if not assumptions:
        with open('assumption_set.info', 'w') as f:
            f.write('1\n')
    else:
        chk = (i in ['2', '3'] for i in assumptions)
        if any(chk) == False:
            print "assumption undefined!"
            print "accepted assumptions: 2 for assumption two and 3 for assumption three"
            return False
        with open('assumption_set.info', 'w') as f:
            f.write(' '.join(assumptions) + '\n')
    return True


def set_diversification(d, iter):
    if d not in config.all_diver_modes:
        assert False, 'unrecognizible diversification mode %d for iteration %d' % (d, iter)
    config.diversification_mode = d
    print 'set diversification mode %d for iteration %d' % (d, iter)
    os.system('echo %d > mode' % d)


def reset_diversification():
    config.diversification_mode = 0


def main():
    """
    Main function
    """
    p = ArgumentParser(formatter_class=RawTextHelpFormatter)
    p.add_argument("binary", help="path to the input binary")
    p.add_argument("-o", "--output", help="destination output file")
    p.add_argument("-g", "--instrument", action='store_true', help="apply instrumentations to output")
    p.add_argument("-a", "--assumption", action="append",
                   help='''this option configures three addtional assumption,
note that two basic assumptions and addtional assumption one
(n-byte alignment) are set by default,
while assumption two and three need to be configured. For example, setting
assumption two and three: -a 2 -a 3''')
    p.add_argument("-gcc", "--gccopt", action="store", default="", help="A string of additional arguments for GCC")
    p.add_argument("-ex", "--exclude", default="", help="""File where each line is either a single value which must not be
a label or an address range of data section to exclude from symbol search""")
    p.add_argument("-fex", "--functionexclude", default="", help="File with a list of symbols not representing functions")
    p.add_argument("--version", action="version", version="Uroboros 0.2b")

    p.add_argument('-i', '--iteration', type=int, help='the number of disassemble-diversify-reassemble iterations')
    p.add_argument('-d', '--diversification', type=int, action='append',
                   help='the sequence of diversification for every iteration \n' + config.diversification_description)

    args = p.parse_args()
    filepath = os.path.realpath(args.binary)
    outpath = os.path.realpath(args.output) if args.output is not None else None
    exclude = os.path.realpath(args.exclude) if len(args.exclude) > 0 else ''
    fexclude = os.path.realpath(args.functionexclude) if len(args.functionexclude) > 0 else ''

    num_iteration = args.iteration
    if num_iteration is None or num_iteration <= 0:
        num_iteration = 1

    diversifications = args.diversification
    if diversifications is None:
        diversifications = [0]
    while len(diversifications) < num_iteration:
        diversifications.append(diversifications[-1])

    abs_path = os.path.dirname(os.path.abspath(__file__))

    for i in range(1, num_iteration + 1):
        workdir = abs_path + '/workdir_' + str(i)
        if not os.path.isdir(workdir):
            os.mkdir(workdir)

        print colored(('iteration %d dir:' + workdir) % i, 'green')
        os.chdir(workdir)
        # run after setting the work directory
        set_diversification(diversifications[i - 1], i)

        if check(filepath, args.assumption, args.gccopt, exclude, args.instrument) and set_assumption(args.assumption):
            if process(os.path.basename(filepath), args.instrument, fexclude):
                os.system('strip a.out')
                print colored("Processing %d succeeded" % i, "blue")
                if outpath is not None:
                    shutil.copy('a.out', outpath + '_' + str(i) + '_mode_' + str(config.diversification_mode))
                    shutil.copy('a.out', outpath)
                # change source file path
                filepath = workdir + '/a.out'
            else:
                print colored("Processing %d failed" % i, "red")
                exit(1)
        reset_diversification()


if __name__ == "__main__":
    main()
