/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8048D40();
// int strcmp(const char *s1, const char *s2);
// int __cdecl open64(_DWORD, _DWORD); weak
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void _exit(int status);
// void free(void *ptr);
// void *memcpy(void *dest, const void *src, size_t n);
// int fclose(FILE *stream);
// int getc_unlocked(FILE *stream);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// int __cdecl fopen64(_DWORD, _DWORD); weak
// int ferror_unlocked(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// size_t __ctype_get_mb_cur_max(void);
// char *strcpy(char *dest, const char *src);
// size_t __fpending(FILE *fp);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// void error(int status, int errnum, const char *format, ...);
// int strcoll(const char *s1, const char *s2);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// char *strchr(const char *s, int c);
// int fscanf(FILE *stream, const char *format, ...);
// size_t strlen(const char *s);
// int fprintf(FILE *stream, const char *format, ...);
// int fcntl(int fd, int cmd, ...);
// void *memset(void *s, int c, size_t n);
// int ungetc(int c, FILE *stream);
// int *__errno_location(void);
// void *memchr(const void *s, int c, size_t n);
// int fileno(FILE *stream);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// char *strpbrk(const char *s, const char *accept);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// int toupper(int c);
// char *strrchr(const char *s, int c);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// int feof_unlocked(FILE *stream);
// void abort(void);
// int close(int fd);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// void *calloc(size_t nmemb, size_t size);
// int putchar_unlocked(int c);
// int _gmon_start__(void); weak
void sub_8049183();
void sub_80491A0();
int sub_80491B0();
int sub_8049220();
int sub_8049240();
void sub_804929F();
void sub_80492BA();
int sub_80492CA();
void sub_80493AC();
void sub_80493C7();
int sub_80493D7();
void sub_80494B9();
void sub_80494D4();
int sub_80494E4();
void sub_80495C6();
void sub_80495E1();
signed int sub_80495F1();
void sub_80496D3();
void sub_80496EE();
int sub_80496FE();
void sub_80497E0();
void sub_80497FB();
int sub_804980B();
void sub_80498F7();
void sub_8049912();
int sub_8049922();
// int __usercall sub_8049989@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
void sub_8049A20();
void sub_8049A3B();
int sub_8049A4B();
int sub_8049AD5();
void sub_8049B53();
void sub_8049B6E();
int sub_8049B90();
int sub_8049C1A();
void sub_8049CA7();
void sub_8049CD0();
int sub_8049CE0();
void sub_8049DD0();
void sub_8049DEB();
signed int sub_8049DFB();
signed int __cdecl sub_8049EB5(unsigned __int8 a1);
int __cdecl sub_8049F0D(char *s1); // idb
void __cdecl __noreturn sub_804A093(int status); // idb
int __cdecl sub_804A210(int a1, int a2, int a3);
int __cdecl sub_804A28A(int a1);
int __cdecl sub_804A439(int a1);
signed int __cdecl sub_804A479(int a1, int a2, unsigned int a3, unsigned int a4);
int __cdecl sub_804A60B(int a1, int a2, int a3);
int __cdecl sub_804A780(int a1);
void *__cdecl sub_804A78F(_DWORD *a1);
int __cdecl sub_804A7B9(FILE *stream, int, int); // idb
void sub_804A94E();
_DWORD *__cdecl sub_804A9A8(_DWORD *a1);
int __cdecl sub_804A9CA(FILE *stream, int, int); // idb
int __cdecl sub_804AA77(FILE *stream, int, int, int); // idb
void __cdecl sub_804AABD(int a1);
char *__cdecl sub_804ABEA(int a1, unsigned int a2, size_t a3);
int __cdecl sub_804B150(FILE *stream, FILE *); // idb
_DWORD __cdecl sub_804D148(_DWORD, _DWORD); // weak
int __cdecl sub_804D20C(char *nptr); // idb
_DWORD __cdecl sub_804D2AF(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl sub_804D3F3(_DWORD); // weak
_DWORD *__cdecl sub_804D479(_DWORD *a1, int a2);
_DWORD *__cdecl sub_804D4E3(_BYTE *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, signed int *a5, _DWORD *a6, _DWORD *a7);
void __cdecl __noreturn main(int argc, char **argv);
int __cdecl sub_804E15A(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_804E1AB(FILE *stream, int); // idb
int __cdecl sub_804E21E(int, char *modes); // idb
int __cdecl sub_804E316(int category); // idb
int __cdecl sub_804E3B9(int a1, FILE *stream, char a3);
int __cdecl sub_804E4FD(unsigned __int8 *a1, unsigned __int8 *a2, unsigned int a3);
void __cdecl __noreturn sub_804E596(_DWORD); // weak
int __cdecl sub_804E5E5(int c, size_t n); // idb
int __cdecl sub_804E720(int *a1, unsigned __int8 a2, char a3);
void __cdecl __noreturn sub_804E7DA(int *a1, int a2, int a3);
int sub_804E820(); // weak
// _DWORD *__userpurge sub_804E834@<eax>(_DWORD *a1, int a2);
char *__cdecl sub_804E8C2(char *msgid, int a2);
int __cdecl sub_804E9B0(_BYTE *a1, unsigned int a2, _BYTE *a3, int a4, signed int a5, int a6, int a7, const char *a8, const char *a9);
_BYTE *__cdecl sub_804F777(_BYTE *a1, int a2, _DWORD *a3, int a4);
_BYTE *__cdecl sub_804F93B(signed int a1, _BYTE *a2, int a3, int a4);
_BYTE *__cdecl sub_804FB64(signed int a1, _BYTE *a2);
_BYTE *__cdecl sub_804FB9E(signed int a1, _BYTE *a2, int a3);
_BYTE *__cdecl sub_804FC16(signed int a1, int a2, _BYTE *a3);
_BYTE *__cdecl sub_804FC54(signed int a1, int a2, _BYTE *a3, int a4);
_BYTE *__cdecl sub_804FC9F(int a1, _BYTE *a2);
_BYTE *__cdecl sub_804FCF8(_BYTE *a1, int a2, unsigned __int8 a3);
_BYTE *__cdecl sub_804FDB2(_BYTE *a1, unsigned __int8 a2);
_BYTE *__cdecl sub_804FDDB(_BYTE *a1);
_BYTE *__cdecl sub_804FE28(signed int a1, int a2, _BYTE *a3);
void __cdecl __noreturn sub_804FEDB(int a1, int a2, int a3);
void __cdecl __noreturn sub_804FF0B(int a1, int a2, int a3);
_BYTE *__cdecl sub_8050023(signed int a1, _BYTE *a2, int a3);
_BYTE *__cdecl sub_805006E(signed int a1, _BYTE *a2);
_BYTE *__cdecl sub_8050090(_BYTE *a1);
int __cdecl sub_80500BD(int fd); // idb
int __cdecl sub_80500F2(FILE *stream, int, int, int, int, int); // idb
int __cdecl sub_8050677(FILE *stream, int, int, int, int); // idb
int sub_80506DD(FILE *stream, int a2, int a3, int a4, ...);
void *__cdecl sub_80507F2(void *ptr, int a2, int a3);
void *__cdecl sub_8050889(size_t size);
void *__cdecl sub_805089C(size_t size);
void *__cdecl sub_80508C6(void *ptr, size_t size);
void *__cdecl sub_805092E(void *ptr, int a2);
void *__cdecl sub_805097A(size_t nmemb, size_t size);
void *__cdecl sub_80509B7(void *src, size_t n);
void __noreturn sub_8050A05();
void __cdecl sub_8050A3E(int errnum, int a2, int a3, int a4, int a5);
int __cdecl sub_8050B0A(void *s1, size_t n, void *s2, int); // idb
signed int __cdecl sub_8050BEA(unsigned int *a1, unsigned int a2);
int __cdecl sub_8050C3C(unsigned int *a1, unsigned int a2, int a3);
int __cdecl sub_8050C72(char *nptr, int, int base, int, char *s); // idb
int __cdecl sub_80510BF(FILE *stream); // idb
int __cdecl sub_8051182(int fd, int cmd, char); // idb
int __cdecl sub_80512EC(FILE *stream); // idb
int __cdecl sub_8051325(FILE *fp); // idb
int __cdecl sub_8051377(FILE *stream, int, int, int); // idb
size_t __cdecl sub_8051449(wchar_t *pwc, char *s, size_t n, mbstate_t *p);
int __cdecl sub_80514BB(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_8051520(FILE *fp); // idb
void *sub_80515AE();
const char *sub_8051A65();
int __cdecl sub_8051B18(char *s, int, char *s2, int); // idb
int __cdecl sub_8051BC5(void *s1, size_t n, void *s2, int); // idb
int __cdecl sub_8051C99(void *s1, size_t n, void *s2, int); // idb
int __cdecl sub_8051EC7(int a1);
int __cdecl sub_8051F83(int a1);
int __stdcall sub_805212E(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_80521A2(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_8052214(_DWORD); // weak
int __stdcall sub_805229F(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_8052309(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __fastcall sub_8052373(_DWORD); // weak
int sub_80523DD(void); // weak
int (**sub_80523F0())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_8049EFC; // weak
_UNKNOWN loc_8049F03; // weak
_UNKNOWN locret_804A437; // weak
_UNKNOWN loc_804A510; // weak
_UNKNOWN loc_804A535; // weak
_UNKNOWN loc_804A6D9; // weak
_UNKNOWN loc_804A6DD; // weak
_UNKNOWN loc_804A866; // weak
_UNKNOWN loc_804A8B3; // weak
_UNKNOWN loc_804A9A0; // weak
_UNKNOWN loc_804AD01; // weak
_UNKNOWN loc_804ADA1; // weak
_UNKNOWN loc_804ADD4; // weak
_UNKNOWN loc_804AE2A; // weak
_UNKNOWN loc_804D575; // weak
_UNKNOWN loc_804D603; // weak
_UNKNOWN loc_804D638; // weak
_UNKNOWN loc_804E1D0; // weak
_UNKNOWN locret_804E20A; // weak
_UNKNOWN loc_804E40C; // weak
_UNKNOWN loc_804E416; // weak
_UNKNOWN loc_804E57E; // weak
_UNKNOWN loc_804E583; // weak
_UNKNOWN loc_804E81B; // weak
_UNKNOWN loc_804E968; // weak
_UNKNOWN loc_804E96F; // weak
_UNKNOWN loc_804E995; // weak
_UNKNOWN loc_804E9A9; // weak
_UNKNOWN locret_804E9AE; // weak
_UNKNOWN loc_804EB83; // weak
_UNKNOWN loc_804F50C; // weak
_UNKNOWN loc_804F5D2; // weak
_UNKNOWN loc_804F5FC; // weak
_UNKNOWN loc_804F628; // weak
_UNKNOWN loc_804F6A9; // weak
_UNKNOWN loc_804F79B; // weak
_UNKNOWN loc_8050617; // weak
_UNKNOWN loc_8050924; // weak
_UNKNOWN loc_8050929; // weak
_UNKNOWN loc_80519FC; // weak
_UNKNOWN loc_8051A03; // weak
_UNKNOWN loc_8051A2C; // weak
_UNKNOWN loc_8051BEC; // weak
_UNKNOWN loc_8051C1D; // weak
_UNKNOWN unk_80524E0; // weak
char s = '\0'; // idb
_UNKNOWN unk_805334E; // weak
_UNKNOWN unk_8053352; // weak
_UNKNOWN unk_805335E; // weak
_UNKNOWN unk_8053365; // weak
_UNKNOWN unk_8053CC7; // weak
_UNKNOWN unk_80541B0; // weak
_UNKNOWN unk_80541B3; // weak
_UNKNOWN unk_80551BC; // weak
_UNKNOWN unk_80551BF; // weak
int (*off_8056EDC[2])() = { &sub_8049240, &sub_8049220 }; // weak
int (*off_8056EE0)() = &sub_8049220; // weak
int (*dword_8057008)(void) = NULL; // weak
int dword_8057114 = 0; // weak
int dword_8057128 = 0; // weak
int dword_805713C = 0; // weak
int dword_8057150 = 0; // weak
int dword_8057164 = 0; // weak
int dword_8057178 = 0; // weak
int dword_805718C = 0; // weak
int dword_80571C8 = 0; // weak
int dword_80571CC = 4294967295; // weak
int dword_80571D0 = 4294967295; // weak
int c = 4294967295; // idb
int status = 1; // idb
int dword_8057204 = 1; // weak
int dword_8057208 = 256; // weak
void *off_805720C = &unk_80576CF; // weak
int *off_8057210 = &dword_8057208; // weak
_UNKNOWN unk_8057224; // weak
_UNKNOWN unk_8057240; // weak
_UNKNOWN unk_8057243; // weak
_UNKNOWN unk_8057248; // weak
_UNKNOWN unk_805724B; // weak
_UNKNOWN unk_8057254; // weak
_UNKNOWN unk_8057257; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
FILE *stdout; // idb
char byte_80572AC; // weak
_UNKNOWN unk_80572B0; // weak
char byte_8057514; // weak
char byte_8057561; // weak
int dword_80575FF[]; // weak
int dword_8057607[]; // weak
int dword_805760B[2]; // idb
char *dword_8057617; // idb
void *ptr[2]; // idb
char byte_805762B; // weak
char byte_805762C[]; // weak
char *s1; // idb
char byte_8057633; // weak
int dword_805764B; // weak
int dword_8057673; // weak
int dword_805768F; // weak
int dword_8057693; // weak
int dword_8057697; // weak
int dword_805769B; // weak
int dword_805769F; // weak
int dword_80576A3; // weak
int dword_80576A7; // weak
int dword_80576AB; // weak
int dword_80576AF; // weak
int dword_80576B3; // weak
int dword_80576B7; // weak
int dword_80576BB; // weak
_UNKNOWN unk_80576CF; // weak
int dword_80577CF; // weak
int dword_80577D3; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (08048D18) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 8049140: using guessed type int _gmon_start__(void);

//----- (08048D40) --------------------------------------------------------
int sub_8048D40()
{
  return dword_8057008();
}
// 8057008: using guessed type int (*dword_8057008)(void);

//----- (08049150) --------------------------------------------------------
#error "8049153: positive sp value has been found (funcsize=2)"

//----- (08049183) --------------------------------------------------------
void sub_8049183()
{
  ;
}

//----- (080491A0) --------------------------------------------------------
void sub_80491A0()
{
  ;
}

//----- (080491B0) --------------------------------------------------------
int sub_80491B0()
{
  int result; // eax

  result = &unk_8057257 - &unk_8057254;
  if ( (unsigned int)(&unk_8057257 - &unk_8057254) > 6 )
    result = 0;
  return result;
}
// 80491B0: could not find valid save-restore pair for ebp

//----- (08049220) --------------------------------------------------------
int sub_8049220()
{
  int result; // eax

  if ( !byte_80572AC )
  {
    result = sub_80491B0();
    byte_80572AC = 1;
  }
  return result;
}
// 8049220: could not find valid save-restore pair for ebp
// 80572AC: using guessed type char byte_80572AC;

//----- (08049240) --------------------------------------------------------
int sub_8049240()
{
  return 0;
}
// 8049240: could not find valid save-restore pair for ebp

//----- (0804929F) --------------------------------------------------------
void sub_804929F()
{
  ;
}

//----- (080492BA) --------------------------------------------------------
void sub_80492BA()
{
  ;
}

//----- (080492CA) --------------------------------------------------------
int sub_80492CA()
{
  int result; // eax

  result = &unk_80572B0 - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_80572B0 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 80492CA: could not find valid save-restore pair for ebp
// 8057260: using guessed type int program_invocation_short_name;

//----- (080493AC) --------------------------------------------------------
void sub_80493AC()
{
  ;
}

//----- (080493C7) --------------------------------------------------------
void sub_80493C7()
{
  ;
}

//----- (080493D7) --------------------------------------------------------
int sub_80493D7()
{
  int result; // eax

  result = &unk_8057243 - &unk_8057240;
  if ( (unsigned int)(&unk_8057243 - &unk_8057240) > 6 )
    result = 0;
  return result;
}
// 80493D7: could not find valid save-restore pair for ebp

//----- (080494B9) --------------------------------------------------------
void sub_80494B9()
{
  ;
}

//----- (080494D4) --------------------------------------------------------
void sub_80494D4()
{
  ;
}

//----- (080494E4) --------------------------------------------------------
int sub_80494E4()
{
  int result; // eax

  result = &unk_8057243 - &unk_8057240;
  if ( (unsigned int)(&unk_8057243 - &unk_8057240) > 6 )
    result = 0;
  return result;
}
// 80494E4: could not find valid save-restore pair for ebp

//----- (080495C6) --------------------------------------------------------
void sub_80495C6()
{
  ;
}

//----- (080495E1) --------------------------------------------------------
void sub_80495E1()
{
  ;
}

//----- (080495F1) --------------------------------------------------------
signed int sub_80495F1()
{
  return 3;
}
// 80495F1: could not find valid save-restore pair for ebp

//----- (080496D3) --------------------------------------------------------
void sub_80496D3()
{
  ;
}

//----- (080496EE) --------------------------------------------------------
void sub_80496EE()
{
  ;
}

//----- (080496FE) --------------------------------------------------------
int sub_80496FE()
{
  int result; // eax

  result = &unk_8057243 - &unk_8057240;
  if ( (unsigned int)(&unk_8057243 - &unk_8057240) > 6 )
    result = 0;
  return result;
}
// 80496FE: could not find valid save-restore pair for ebp

//----- (080497E0) --------------------------------------------------------
void sub_80497E0()
{
  ;
}

//----- (080497FB) --------------------------------------------------------
void sub_80497FB()
{
  ;
}

//----- (0804980B) --------------------------------------------------------
int sub_804980B()
{
  int result; // eax

  result = &unk_8057243 - &unk_8057240;
  if ( (unsigned int)(&unk_8057243 - &unk_8057240) > 6 )
    result = 0;
  return result;
}
// 804980B: could not find valid save-restore pair for ebp

//----- (080498F7) --------------------------------------------------------
void sub_80498F7()
{
  ;
}

//----- (08049912) --------------------------------------------------------
void sub_8049912()
{
  ;
}

//----- (08049922) --------------------------------------------------------
int sub_8049922()
{
  int result; // eax

  result = &unk_8057243 - &unk_8057240;
  if ( (unsigned int)(&unk_8057243 - &unk_8057240) > 6 )
    result = 0;
  return result;
}
// 8049922: could not find valid save-restore pair for ebp

//----- (08049989) --------------------------------------------------------
int __usercall sub_8049989@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_8057240, a1);
}

//----- (08049A20) --------------------------------------------------------
void sub_8049A20()
{
  ;
}

//----- (08049A3B) --------------------------------------------------------
void sub_8049A3B()
{
  ;
}

//----- (08049A4B) --------------------------------------------------------
int sub_8049A4B()
{
  int result; // eax

  result = &unk_80551BF - &unk_80551BC;
  if ( (unsigned int)(&unk_80551BF - &unk_80551BC) > 6 )
    result = 0;
  return result;
}
// 8049A4B: could not find valid save-restore pair for ebp

//----- (08049AD5) --------------------------------------------------------
int sub_8049AD5()
{
  int result; // eax

  result = sub_8049A4B();
  byte_8057514 = 1;
  return result;
}
// 8057514: using guessed type char byte_8057514;

//----- (08049B53) --------------------------------------------------------
void sub_8049B53()
{
  ;
}

//----- (08049B6E) --------------------------------------------------------
void sub_8049B6E()
{
  ;
}

//----- (08049B90) --------------------------------------------------------
int sub_8049B90()
{
  int result; // eax

  result = &unk_80541B3 - &unk_80541B0;
  if ( (unsigned int)(&unk_80541B3 - &unk_80541B0) > 6 )
    result = 0;
  return result;
}
// 8049B90: could not find valid save-restore pair for ebp

//----- (08049C1A) --------------------------------------------------------
int sub_8049C1A()
{
  int result; // eax

  result = sub_8049B90();
  byte_8057561 = 1;
  return result;
}
// 8057561: using guessed type char byte_8057561;

//----- (08049CA7) --------------------------------------------------------
void sub_8049CA7()
{
  ;
}

//----- (08049CD0) --------------------------------------------------------
void sub_8049CD0()
{
  ;
}

//----- (08049CE0) --------------------------------------------------------
int sub_8049CE0()
{
  int result; // eax

  result = &unk_805724B - &unk_8057248;
  if ( (unsigned int)(&unk_805724B - &unk_8057248) > 6 )
    result = 0;
  return result;
}
// 8049CE0: could not find valid save-restore pair for ebp

//----- (08049DD0) --------------------------------------------------------
void sub_8049DD0()
{
  ;
}

//----- (08049DEB) --------------------------------------------------------
void sub_8049DEB()
{
  ;
}

//----- (08049DFB) --------------------------------------------------------
signed int sub_8049DFB()
{
  return 4;
}
// 8049DFB: could not find valid save-restore pair for ebp

//----- (08049EB5) --------------------------------------------------------
#error "8049EF7: call analysis failed (funcsize=30)"

//----- (08049F0D) --------------------------------------------------------
int __cdecl sub_8049F0D(char *s1)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // ebx
  char *v5; // eax
  char *v7; // [esp+1Ch] [ebp-4Ch]
  void **i; // [esp+20h] [ebp-48h]
  const char *v9; // [esp+24h] [ebp-44h]
  void *v10; // [esp+28h] [ebp-40h]
  const char *v11; // [esp+2Ch] [ebp-3Ch]
  const char *v12; // [esp+30h] [ebp-38h]
  const char *v13; // [esp+34h] [ebp-34h]
  const char *v14; // [esp+38h] [ebp-30h]
  const char *v15; // [esp+3Ch] [ebp-2Ch]
  const char *v16; // [esp+40h] [ebp-28h]
  const char *v17; // [esp+44h] [ebp-24h]
  const char *v18; // [esp+48h] [ebp-20h]
  const char *v19; // [esp+4Ch] [ebp-1Ch]
  const char *v20; // [esp+50h] [ebp-18h]
  const char *v21; // [esp+54h] [ebp-14h]
  int v22; // [esp+58h] [ebp-10h]
  int v23; // [esp+5Ch] [ebp-Ch]

  v10 = &unk_80524E0;
  v11 = "test invocation";
  v12 = "coreutils";
  v13 = "Multi-call invocation";
  v14 = "sha224sum";
  v15 = "sha2 utilities";
  v16 = "sha256sum";
  v17 = "sha2 utilities";
  v18 = "sha384sum";
  v19 = "sha2 utilities";
  v20 = "sha512sum";
  v21 = "sha2 utilities";
  v22 = 0;
  v23 = 0;
  v7 = s1;
  for ( i = &v10; *i && strcmp(s1, (const char *)*i); i += 2 )
    ;
  if ( i[1] )
    v7 = (char *)i[1];
  v1 = gettext("\n%s online help: <%s>\n");
  printf(v1, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  v9 = setlocale(5, 0);
  if ( v9 && strncmp(v9, "en_", 3u) )
  {
    v2 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
    printf(v2, s1);
  }
  v3 = gettext("Full documentation at: <%s%s>\n");
  printf(v3, "http://www.gnu.org/software/coreutils/", s1);
  if ( v7 == s1 )
    v4 = " invocation";
  else
    v4 = &s;
  v5 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  return printf(v5, v7, v4);
}

//----- (0804A093) --------------------------------------------------------
void __cdecl __noreturn sub_804A093(int status)
{
  int v1; // ebx
  char *v2; // eax
  int v3; // ebx
  char *v4; // eax
  FILE *v5; // ebx
  char *v6; // eax
  FILE *v7; // ebx
  char *v8; // eax
  FILE *v9; // ebx
  char *v10; // eax
  FILE *v11; // ebx
  char *v12; // eax
  FILE *v13; // ebx
  char *v14; // eax
  FILE *v15; // ebx
  char *v16; // eax
  FILE *v17; // ebx
  char *v18; // eax
  FILE *v19; // ebx
  char *v20; // eax
  FILE *v21; // ebx
  char *v22; // eax

  if ( status )
  {
    v1 = dword_8057673;
    v2 = gettext("Try '%s --help' for more information.\n");
    fprintf(stderr, v2, v1);
  }
  else
  {
    v3 = dword_8057673;
    v4 = gettext("Usage: %s [OPTION]... FILE1 FILE2\n");
    printf(v4, v3);
    v5 = stdout;
    v6 = gettext(
           "For each pair of input lines with identical join fields, write a line to\n"
           "standard output.  The default join field is the first, delimited by blanks.\n");
    fputs_unlocked(v6, v5);
    v7 = stdout;
    v8 = gettext("\nWhen FILE1 or FILE2 (not both) is -, read standard input.\n");
    fputs_unlocked(v8, v7);
    v9 = stdout;
    v10 = gettext(
            "\n"
            "  -a FILENUM        also print unpairable lines from file FILENUM, where\n"
            "                      FILENUM is 1 or 2, corresponding to FILE1 or FILE2\n"
            "  -e EMPTY          replace missing input fields with EMPTY\n");
    fputs_unlocked(v10, v9);
    v11 = stdout;
    v12 = gettext(
            "  -i, --ignore-case  ignore differences in case when comparing fields\n"
            "  -j FIELD          equivalent to '-1 FIELD -2 FIELD'\n"
            "  -o FORMAT         obey FORMAT while constructing output line\n"
            "  -t CHAR           use CHAR as input and output field separator\n");
    fputs_unlocked(v12, v11);
    v13 = stdout;
    v14 = gettext(
            "  -v FILENUM        like -a FILENUM, but suppress joined output lines\n"
            "  -1 FIELD          join on this FIELD of file 1\n"
            "  -2 FIELD          join on this FIELD of file 2\n"
            "  --check-order     check that the input is correctly sorted, even\n"
            "                      if all input lines are pairable\n"
            "  --nocheck-order   do not check that the input is correctly sorted\n"
            "  --header          treat the first line in each file as field headers,\n"
            "                      print them without trying to pair them\n");
    fputs_unlocked(v14, v13);
    v15 = stdout;
    v16 = gettext("  -z, --zero-terminated     line delimiter is NUL, not newline\n");
    fputs_unlocked(v16, v15);
    v17 = stdout;
    v18 = gettext("      --help     display this help and exit\n");
    fputs_unlocked(v18, v17);
    v19 = stdout;
    v20 = gettext("      --version  output version information and exit\n");
    fputs_unlocked(v20, v19);
    v21 = stdout;
    v22 = gettext(
            "\n"
            "Unless -t CHAR is given, leading blanks separate fields and are ignored,\n"
            "else fields are separated by CHAR.  Any FIELD is a field number counted\n"
            "from 1.  FORMAT is one or more comma or blank separated specifications,\n"
            "each being 'FILENUM.FIELD' or '0'.  Default FORMAT outputs the join field,\n"
            "the remaining fields from FILE1, the remaining fields from FILE2, all\n"
            "separated by CHAR.  If FORMAT is the keyword 'auto', then the first\n"
            "line of each file determines the number of fields output for each line.\n"
            "\n"
            "Important: FILE1 and FILE2 must be sorted on the join fields.\n"
            "E.g., use \"sort -k 1b,1\" if 'join' has no options,\n"
            "or use \"join -t ''\" if 'sort' has no options.\n"
            "Note, comparisons honor the rules specified by 'LC_COLLATE'.\n"
            "If the input is not sorted and some lines cannot be joined, a\n"
            "warning message will be given.\n");
    fputs_unlocked(v22, v21);
    sub_8049F0D("join");
  }
  exit(status);
}
// 8048F50: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8057673: using guessed type int dword_8057673;

//----- (0804A210) --------------------------------------------------------
int __cdecl sub_804A210(int a1, int a2, int a3)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 12) >= *(_DWORD *)(a1 + 16) )
    *(_DWORD *)(a1 + 20) = sub_80507F2(*(void **)(a1 + 20), a1 + 16, 8);
  *(_DWORD *)(8 * *(_DWORD *)(a1 + 12) + *(_DWORD *)(a1 + 20)) = a2;
  *(_DWORD *)(8 * *(_DWORD *)(a1 + 12) + *(_DWORD *)(a1 + 20) + 4) = a3;
  result = a1;
  ++*(_DWORD *)(a1 + 12);
  return result;
}

//----- (0804A28A) --------------------------------------------------------
int __cdecl sub_804A28A(int a1)
{
  int v1; // ecx
  int v2; // edx
  int result; // eax
  unsigned __int8 *s; // [esp+10h] [ebp-18h]
  unsigned __int8 *i; // [esp+14h] [ebp-14h]
  int v6; // [esp+18h] [ebp-10h]
  char *v7; // [esp+1Ch] [ebp-Ch]

  s = *(unsigned __int8 **)(a1 + 8);
  v2 = *(_DWORD *)(a1 + 4) - 1;
  v6 = (int)&s[v2];
  if ( s == &s[v2] )
  {
    dword_8057128 = (int)&locret_804A437;
    sub_8052373(v1);
  }
  if ( c >= 0 && c != 10 )
  {
    while ( 1 )
    {
      v7 = (char *)memchr(s, c, v6 - (_DWORD)s);
      if ( !v7 )
        break;
      sub_804A210(a1, (int)s, v7 - (char *)s);
      s = (unsigned __int8 *)(v7 + 1);
    }
    return sub_804A210(a1, (int)s, v6 - (_DWORD)s);
  }
  if ( c >= 0 )
    return sub_804A210(a1, (int)s, v6 - (_DWORD)s);
  while ( (unsigned __int8)sub_8049EB5(*s) )
  {
    result = (int)++s;
    if ( s == (unsigned __int8 *)v6 )
      return result;
  }
  while ( 1 )
  {
    for ( i = s + 1; i != (unsigned __int8 *)v6 && (unsigned __int8)sub_8049EB5(*i) ^ 1; ++i )
      ;
    sub_804A210(a1, (int)s, i - s);
    result = (int)i;
    if ( i == (unsigned __int8 *)v6 )
      break;
    for ( s = i + 1; s != (unsigned __int8 *)v6 && (unsigned __int8)sub_8049EB5(*s); ++s )
      ;
    if ( s == (unsigned __int8 *)v6 )
      return sub_804A210(a1, (int)s, v6 - (_DWORD)s);
  }
  return result;
}
// 8052373: using guessed type int __fastcall sub_8052373(_DWORD);
// 8057128: using guessed type int dword_8057128;

//----- (0804A439) --------------------------------------------------------
int __cdecl sub_804A439(int a1)
{
  int result; // eax

  if ( a1 )
  {
    free(*(void **)(a1 + 20));
    *(_DWORD *)(a1 + 20) = 0;
    free(*(void **)(a1 + 8));
    result = a1;
    *(_DWORD *)(a1 + 8) = 0;
  }
  return result;
}

//----- (0804A479) --------------------------------------------------------
#error "804A4FD: call analysis failed (funcsize=109)"

//----- (0804A60B) --------------------------------------------------------
int __cdecl sub_804A60B(int a1, int a2, int a3)
{
  int result; // eax
  unsigned int v4; // eax
  void *v5; // eax
  signed int v6; // eax
  int v7; // ST34_4
  signed int v8; // ST30_4
  int v9; // ebx
  int v10; // esi
  char *v11; // edi
  char *v12; // eax
  int v13; // [esp+0h] [ebp-58h]
  int v14; // [esp+4h] [ebp-54h]
  int v15; // [esp+8h] [ebp-50h]
  int v16; // [esp+Ch] [ebp-4Ch]
  int v17; // [esp+10h] [ebp-48h]
  int v18; // [esp+14h] [ebp-44h]
  int v19; // [esp+18h] [ebp-40h]
  int v20; // [esp+1Ch] [ebp-3Ch]
  int v21; // [esp+20h] [ebp-38h]
  int v22; // [esp+24h] [ebp-34h]
  int v23; // [esp+28h] [ebp-30h]
  int v24; // [esp+2Ch] [ebp-2Ch]
  signed int v25; // [esp+38h] [ebp-20h]

  result = dword_805764B;
  if ( dword_805764B != 2 )
  {
    if ( dword_805764B == 1 || (result = (unsigned __int8)byte_805762B, byte_805762B) )
    {
      result = (unsigned __int8)byte_805762C[a3 - 1] ^ 1;
      if ( byte_805762C[a3 - 1] != 1 )
      {
        v4 = a3 == 1 ? dword_80571CC : dword_80571D0;
        result = sub_804A479(a1, a2, v4, v4);
        if ( result > 0 )
        {
          v25 = *(_DWORD *)(a2 + 4);
          if ( v25 )
          {
            v5 = &loc_804A6D9;
            if ( *(_BYTE *)(v25 - 1 + *(_DWORD *)(a2 + 8)) != 10 )
              v5 = &loc_804A6DD;
            dword_8057150 = (int)v5;
            sub_805229F(v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24);
            --v25;
          }
          if ( v25 < 0 )
            v6 = 0x7FFFFFFF;
          else
            v6 = v25;
          v7 = *(_DWORD *)(a2 + 8);
          v8 = v6;
          v9 = dword_8057607[2 * (a3 - 1)];
          v10 = dword_805760B[2 * (a3 - 1)];
          v11 = (&dword_8057617)[a3 - 1];
          v12 = gettext("%s:%llu: is not sorted: %.*s");
          error(dword_805764B == 1, 0, v12, v11, v9, v10, v8, v7);
          result = a3 - 1;
          byte_805762C[a3 - 1] = 1;
        }
      }
    }
  }
  return result;
}
// 805229F: using guessed type int __stdcall sub_805229F(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8057150: using guessed type int dword_8057150;
// 80571CC: using guessed type int dword_80571CC;
// 80571D0: using guessed type int dword_80571D0;
// 8057607: using guessed type int dword_8057607[];
// 805762B: using guessed type char byte_805762B;
// 805764B: using guessed type int dword_805764B;

//----- (0804A780) --------------------------------------------------------
int __cdecl sub_804A780(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (0804A78F) --------------------------------------------------------
void *__cdecl sub_804A78F(_DWORD *a1)
{
  void *result; // eax

  result = sub_805097A(1u, 0x18u);
  *a1 = result;
  return result;
}

//----- (0804A7B9) --------------------------------------------------------
#error "804A861: call analysis failed (funcsize=76)"

//----- (0804A94E) --------------------------------------------------------
void sub_804A94E()
{
  unsigned int v0; // [esp+1Ch] [ebp-Ch]

  v0 = 0;
  dword_8057114 = (int)&loc_804A9A0;
  sub_80523DD();
  do
  {
    if ( ptr[v0] )
    {
      sub_804A439((int)ptr[v0]);
      free(ptr[v0]);
    }
    ++v0;
  }
  while ( v0 <= 1 );
}
// 80523DD: using guessed type int sub_80523DD(void);
// 8057114: using guessed type int dword_8057114;

//----- (0804A9A8) --------------------------------------------------------
_DWORD *__cdecl sub_804A9A8(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = a1;
  a1[2] = 0;
  return result;
}

//----- (0804A9CA) --------------------------------------------------------
int __cdecl sub_804A9CA(FILE *stream, int a2, int a3)
{
  unsigned int i; // [esp+1Ch] [ebp-Ch]

  if ( *(_DWORD *)a2 == *(_DWORD *)(a2 + 4) )
  {
    *(_DWORD *)(a2 + 8) = sub_80507F2(*(void **)(a2 + 8), a2 + 4, 4);
    for ( i = *(_DWORD *)a2; *(_DWORD *)(a2 + 4) > i; ++i )
      *(_DWORD *)(4 * i + *(_DWORD *)(a2 + 8)) = 0;
  }
  if ( !(unsigned __int8)sub_804A7B9(stream, 4 * *(_DWORD *)a2 + *(_DWORD *)(a2 + 8), a3) )
    return 0;
  ++*(_DWORD *)a2;
  return 1;
}

//----- (0804AA77) --------------------------------------------------------
int __cdecl sub_804AA77(FILE *stream, int a2, int a3, int a4)
{
  if ( (_BYTE)a3 )
    *(_DWORD *)a2 = 0;
  return sub_804A9CA(stream, a2, a4);
}

//----- (0804AABD) --------------------------------------------------------
void __cdecl sub_804AABD(int a1)
{
  unsigned int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; *(_DWORD *)(a1 + 4) > i; ++i )
  {
    sub_804A439(*(_DWORD *)(4 * i + *(_DWORD *)(a1 + 8)));
    free(*(void **)(4 * i + *(_DWORD *)(a1 + 8)));
  }
  free(*(void **)(a1 + 8));
}

//----- (0804ABEA) --------------------------------------------------------
char *__cdecl sub_804ABEA(int a1, unsigned int a2, size_t a3)
{
  size_t v3; // eax
  char v4; // al
  char *result; // eax
  int v6; // eax
  bool v7; // zf
  void *v8; // eax
  int v9; // ST3C_4
  int v10; // ST38_4
  size_t v11; // ST24_4
  int v12; // [esp-30h] [ebp-58h]
  int v13; // [esp-2Ch] [ebp-54h]
  int v14; // [esp-28h] [ebp-50h]
  int v15; // [esp-24h] [ebp-4Ch]
  int v16; // [esp-20h] [ebp-48h]
  int v17; // [esp-1Ch] [ebp-44h]
  int v18; // [esp-18h] [ebp-40h]
  size_t v19; // [esp-14h] [ebp-3Ch]
  int v20; // [esp-14h] [ebp-3Ch]
  int v21; // [esp-10h] [ebp-38h]
  int v22; // [esp-Ch] [ebp-34h]
  int v23; // [esp+8h] [ebp-20h]
  int v24; // [esp+Ch] [ebp-1Ch]
  char v25; // [esp+17h] [ebp-11h]
  unsigned int v26; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]
  int savedregs; // [esp+28h] [ebp+0h]

  if ( byte_8057633 )
    v3 = a3;
  else
    v3 = *(_DWORD *)(a1 + 12);
  n = v3;
  if ( c < 0 )
    v4 = 32;
  else
    v4 = c;
  v25 = v4;
  if ( a2 > 0 && n > 0 )
  {
    putchar_unlocked(v4);
    if ( *(_DWORD *)(a1 + 12) <= 0u )
    {
      result = s1;
      if ( s1 )
        result = (char *)fputs_unlocked(s1, stdout);
    }
    else
    {
      v19 = *(_DWORD *)(*(_DWORD *)(a1 + 20) + 4);
      if ( v19 )
      {
        result = (char *)fwrite_unlocked(**(const void ***)(a1 + 20), 1u, v19, stdout);
      }
      else
      {
        result = s1;
        if ( s1 )
          result = (char *)fputs_unlocked(s1, stdout);
      }
    }
  }
  else
  {
    v26 = a2 + 1;
    result = (char *)(a2 + 1);
    if ( v26 < n )
    {
      putchar_unlocked(v25);
      if ( *(_DWORD *)(a1 + 12) <= v26 )
      {
        result = s1;
        if ( s1 )
          result = (char *)fputs_unlocked(s1, stdout);
      }
      else
      {
        v6 = *(_DWORD *)(8 * v26 + *(_DWORD *)(a1 + 20) + 4);
        v20 = v6;
        v7 = v6 == 0;
        v8 = &loc_804ADA1;
        if ( v7 )
          v8 = &loc_804ADD4;
        dword_805718C = (int)v8;
        sub_805212E(v12, v13, v14, v15, v16, v17, v18, v20, v21, v22, &savedregs, &loc_804AE2A, v26, a1, v23, v24);
        result = (char *)fwrite_unlocked(*(const void **)(8 * v10 + *(_DWORD *)(v9 + 20)), 1u, v11, stdout);
      }
    }
  }
  return result;
}
// 8048F50: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 805212E: using guessed type int __stdcall sub_805212E(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 805718C: using guessed type int dword_805718C;
// 8057633: using guessed type char byte_8057633;

//----- (0804AEE3) --------------------------------------------------------
#error "804AF80: call analysis failed (funcsize=66)"

//----- (0804B150) --------------------------------------------------------
#error "804B25B: call analysis failed (funcsize=1701)"

//----- (0804D148) --------------------------------------------------------
#error "804D1A4: call analysis failed (funcsize=49)"

//----- (0804D20C) --------------------------------------------------------
int __cdecl sub_804D20C(char *nptr)
{
  _BYTE *v1; // ebx
  char *v2; // eax
  int v4; // [esp+24h] [ebp-14h]
  int v5; // [esp+28h] [ebp-10h]

  v5 = sub_8050C72(nptr, 0, 10, (int)&v4, &s);
  if ( v5 == 1 )
  {
    v4 = -1;
  }
  else if ( v5 || !v4 )
  {
    v1 = sub_8050090(nptr);
    v2 = gettext("invalid field number: %s");
    error(1, 0, v2, v1);
  }
  return v4 - 1;
}

//----- (0804D2AF) --------------------------------------------------------
#error "804D34B: call analysis failed (funcsize=88)"

//----- (0804D3F3) --------------------------------------------------------
#error "804D435: call analysis failed (funcsize=42)"

//----- (0804D479) --------------------------------------------------------
_DWORD *__cdecl sub_804D479(_DWORD *a1, int a2)
{
  int v2; // ST28_4
  char *v3; // eax
  _DWORD *result; // eax

  if ( *a1 != -1 && *a1 != a2 )
  {
    v2 = *a1 + 1;
    v3 = gettext("incompatible join fields %lu, %lu");
    error(1, 0, v3, v2, a2 + 1);
  }
  result = a1;
  *a1 = a2;
  return result;
}

//----- (0804D4E3) --------------------------------------------------------
_DWORD *__cdecl sub_804D4E3(_BYTE *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, signed int *a5, _DWORD *a6, _DWORD *a7)
{
  signed int v7; // eax
  bool v8; // zf
  void *v9; // eax
  _BYTE *v10; // ebx
  char *v11; // eax
  int v12; // eax
  int v13; // eax
  _DWORD *result; // eax
  int v15; // [esp+0h] [ebp-28h]
  bool v16; // [esp+17h] [ebp-11h]
  signed int v17; // [esp+18h] [ebp-10h]
  char *nptr; // [esp+1Ch] [ebp-Ch]

  v17 = *a5;
  if ( *a5 == 2 )
  {
    v16 = *a3 == 0;
    nptr = (char *)a2[v16];
    v7 = a3[v16];
    if ( v7 == 1 )
    {
      --*a4;
      v12 = sub_804D20C(nptr);
      sub_804D479(&dword_80571CC, v12);
      dword_8057114 = (int)&loc_804D638;
      sub_80523DD();
      --a4[1];
      v13 = sub_804D20C(nptr);
      sub_804D479(&dword_80571D0, v13);
    }
    else if ( v7 > 1 )
    {
      v8 = v7 == 2;
      v9 = &loc_804D575;
      if ( v8 )
        v9 = &loc_804D603;
      dword_8057164 = (int)v9;
      if ( sub_8052214(v15) == 3 )
        sub_804D3F3(nptr);
    }
    else if ( !v7 )
    {
      v10 = sub_804FC9F(4, a1);
      v11 = gettext("extra operand %s");
      error(0, 0, v11, v10);
      sub_804A093(1);
    }
    if ( v16 != 1 )
    {
      *a3 = a3[1];
      *a2 = a2[1];
    }
    v17 = 1;
  }
  a3[v17] = *a6;
  a2[v17] = a1;
  *a5 = v17 + 1;
  result = (_DWORD *)*a6;
  if ( *a6 == 3 )
  {
    result = a7;
    *a7 = 3;
  }
  return result;
}
// 804D3F3: using guessed type _DWORD __cdecl sub_804D3F3(_DWORD);
// 8052214: using guessed type int __stdcall sub_8052214(_DWORD);
// 80523DD: using guessed type int sub_80523DD(void);
// 8057114: using guessed type int dword_8057114;
// 8057164: using guessed type int dword_8057164;
// 80571CC: using guessed type int dword_80571CC;
// 80571D0: using guessed type int dword_80571D0;

//----- (0804D6AE) --------------------------------------------------------
void __cdecl __noreturn main(int argc, char **argv)
{
  sub_804E596(*argv);
}
// 804E596: using guessed type void __cdecl __noreturn sub_804E596(_DWORD);

//----- (0804E069) --------------------------------------------------------
#error "804E0FE: call analysis failed (funcsize=61)"

//----- (0804E15A) --------------------------------------------------------
int __cdecl sub_804E15A(int a1, int a2, int a3, int a4, int a5, int a6)
{
  return posix_fadvise64(a1, a2, a3, a4, a5, a6);
}
// 80490B0: using guessed type int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804E1AB) --------------------------------------------------------
int __cdecl sub_804E1AB(FILE *stream, int a2)
{
  int v2; // ecx
  void *v3; // eax
  int v4; // eax

  v3 = &loc_804E1D0;
  if ( !stream )
    v3 = &locret_804E20A;
  dword_8057128 = (int)v3;
  sub_8052373(v2);
  v4 = fileno(stream);
  return sub_804E15A(v4, 0, 0, 0, 0, a2);
}
// 8052373: using guessed type int __fastcall sub_8052373(_DWORD);
// 8057128: using guessed type int dword_8057128;

//----- (0804E21E) --------------------------------------------------------
#error "804E253: call analysis failed (funcsize=72)"

//----- (0804E316) --------------------------------------------------------
int __cdecl sub_804E316(int category)
{
  unsigned __int8 v2; // [esp+1Bh] [ebp-Dh]
  const char *s1; // [esp+1Ch] [ebp-Ch]

  v2 = 1;
  s1 = setlocale(category, 0);
  if ( s1 && (!strcmp(s1, "C") || !strcmp(s1, "POSIX")) )
    v2 = 0;
  return v2;
}

//----- (0804E3B9) --------------------------------------------------------
int __cdecl sub_804E3B9(int a1, FILE *stream, char a3)
{
  bool v3; // zf
  void *v4; // eax
  int v6; // [esp+0h] [ebp-38h]
  int v7; // [esp+4h] [ebp-34h]
  int v8; // [esp+8h] [ebp-30h]
  _DWORD v9[4]; // [esp+Ch] [ebp-2Ch]
  int v10; // [esp+10h] [ebp-28h]
  int v11; // [esp+14h] [ebp-24h]
  int v12; // [esp+18h] [ebp-20h]
  int v13; // [esp+1Ch] [ebp-1Ch]
  char *ptr; // [esp+20h] [ebp-18h]
  int v15; // [esp+24h] [ebp-14h]
  int v16; // [esp+28h] [ebp-10h]
  int v17; // [esp+2Ch] [ebp-Ch]

  LOBYTE(v9[0]) = a3;
  ptr = *(char **)(a1 + 8);
  v15 = *(_DWORD *)(a1 + 8);
  v16 = (int)&ptr[*(_DWORD *)a1];
  v3 = feof_unlocked(stream) == 0;
  v4 = &loc_804E40C;
  if ( v3 )
    v4 = &loc_804E416;
  dword_8057150 = (int)v4;
  sub_805229F(v6, v7, v8, v9[0], v10, v11, v12, v13, ptr, v15, v16, v17);
  return 0;
}
// 805229F: using guessed type int __stdcall sub_805229F(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8057150: using guessed type int dword_8057150;

//----- (0804E4FD) --------------------------------------------------------
int __cdecl sub_804E4FD(unsigned __int8 *a1, unsigned __int8 *a2, unsigned int a3)
{
  int v3; // eax
  int v4; // eax
  bool v5; // zf
  void *v6; // eax
  int v7; // ST34_4
  int v9; // [esp+0h] [ebp-38h]
  int v10; // [esp+4h] [ebp-34h]
  int v11; // [esp+8h] [ebp-30h]
  int v12; // [esp+Ch] [ebp-2Ch]
  int v13; // [esp+10h] [ebp-28h]
  int v14; // [esp+14h] [ebp-24h]
  int v15; // [esp+24h] [ebp-14h]
  int v16; // [esp+28h] [ebp-10h]
  int v17; // [esp+2Ch] [ebp-Ch]

  if ( a3 <= 0 )
    return 0;
  BYTE2(v14) = *a1;
  HIBYTE(v14) = *a2;
  v15 = toupper(*a1);
  v3 = toupper(HIBYTE(v14));
  v16 = v3;
  v4 = v15 - v3;
  v17 = v4;
  v5 = v4 == 0;
  v6 = &loc_804E57E;
  if ( v5 )
    v6 = &loc_804E583;
  dword_8057150 = (int)v6;
  sub_805229F(v9, v10, v11, v12, v13, v14, 0, a1, a2, v15, v16, v17);
  return v7;
}
// 805229F: using guessed type int __stdcall sub_805229F(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8057150: using guessed type int dword_8057150;

//----- (0804E596) --------------------------------------------------------
#error "804E5B6: call analysis failed (funcsize=20)"

//----- (0804E5E5) --------------------------------------------------------
#error "804E6AC: positive sp value has been found (funcsize=58)"

//----- (0804E720) --------------------------------------------------------
int __cdecl sub_804E720(int *a1, unsigned __int8 a2, char a3)
{
  int *v3; // eax
  int v4; // ST10_4

  if ( a1 )
    v3 = a1;
  else
    v3 = &dword_805768F;
  v4 = ((unsigned int)v3[(a2 >> 5) + 2] >> (a2 & 0x1F)) & 1;
  v3[(a2 >> 5) + 2] ^= (v4 ^ a3 & 1) << (a2 & 0x1F);
  return v4;
}
// 805768F: using guessed type int dword_805768F;

//----- (0804E7DA) --------------------------------------------------------
void __cdecl __noreturn sub_804E7DA(int *a1, int a2, int a3)
{
  int (*v3)(); // eax

  if ( !a1 )
    a1 = &dword_805768F;
  *a1 = 10;
  if ( a2 )
  {
    v3 = (int (*)())&loc_804E81B;
    if ( a3 )
      v3 = sub_804E820;
    dword_8057114 = (int)v3;
    sub_80523DD();
  }
  abort();
}
// 804E820: using guessed type int sub_804E820();
// 80523DD: using guessed type int sub_80523DD(void);
// 8057114: using guessed type int dword_8057114;
// 805768F: using guessed type int dword_805768F;

//----- (0804E820) --------------------------------------------------------
#error "804E833: positive sp value has been found (funcsize=0)"

//----- (0804E834) --------------------------------------------------------
_DWORD *__userpurge sub_804E834@<eax>(_DWORD *a1, int a2)
{
  int v3; // [esp+0h] [ebp-38h]
  int v4; // [esp+4h] [ebp-34h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]

  memset(&v3, 0, 0x30u);
  if ( a2 == 10 )
    abort();
  *a1 = a2;
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = v6;
  a1[4] = v7;
  a1[5] = v8;
  a1[6] = v9;
  a1[7] = v10;
  a1[8] = v11;
  a1[9] = v12;
  a1[10] = v13;
  a1[11] = v14;
  return a1;
}

//----- (0804E8C2) --------------------------------------------------------
#error "804E9A4: call analysis failed (funcsize=65)"

//----- (0804E9B0) --------------------------------------------------------
int __cdecl sub_804E9B0(_BYTE *a1, unsigned int a2, _BYTE *a3, int a4, signed int a5, int a6, int a7, const char *a8, const char *a9)
{
  bool v9; // ST53_1
  _BOOL4 v10; // eax
  bool v11; // zf
  void *v12; // eax
  const char *v13; // ST34_4
  const char *v14; // ST38_4
  int v15; // ST3C_4
  char *v16; // ST40_4
  _BYTE *v17; // ST44_4
  int result; // eax
  void *v19; // eax
  int v20; // [esp+0h] [ebp-88h]
  int v21; // [esp+0h] [ebp-88h]
  int v22; // [esp+4h] [ebp-84h]
  int v23; // [esp+8h] [ebp-80h]
  int v24; // [esp+Ch] [ebp-7Ch]
  int v25; // [esp+10h] [ebp-78h]
  int v26; // [esp+14h] [ebp-74h]
  int v27; // [esp+18h] [ebp-70h]
  int v28; // [esp+1Ch] [ebp-6Ch]
  int v29; // [esp+20h] [ebp-68h]
  int v30; // [esp+24h] [ebp-64h]
  int v31; // [esp+28h] [ebp-60h]
  const char *v32; // [esp+2Ch] [ebp-5Ch]
  const char *v33; // [esp+30h] [ebp-58h]
  char v34; // [esp+40h] [ebp-48h]
  bool v35; // [esp+41h] [ebp-47h]
  unsigned int v36; // [esp+54h] [ebp-34h]
  char *s; // [esp+5Ch] [ebp-2Ch]
  char *sa; // [esp+5Ch] [ebp-2Ch]

  v33 = a8;
  v32 = a9;
  v36 = 0;
  s = 0;
  v34 = 0;
  v9 = __ctype_get_mb_cur_max() == 1;
  v35 = (a6 & 2) != 0;
  switch ( a5 )
  {
    case 0:
      v35 = 0;
      break;
    case 1:
      goto LABEL_19;
    case 2:
      goto LABEL_22;
    case 3:
      v34 = 1;
LABEL_19:
      v35 = 1;
      goto LABEL_20;
    case 4:
LABEL_20:
      if ( v35 != 1 )
        v34 = 1;
LABEL_22:
      a5 = 2;
      if ( v35 != 1 )
      {
        if ( a2 > 0 )
          *a1 = 39;
        v36 = 1;
      }
      s = "'";
      break;
    case 5:
      goto LABEL_3;
    case 6:
      a5 = 5;
      v35 = 1;
LABEL_3:
      if ( v35 != 1 )
      {
        if ( a2 > 0 )
          *a1 = 34;
        v36 = 1;
      }
      v34 = 1;
      s = (char *)&unk_8053365;
      break;
    case 7:
      v34 = 1;
      v35 = 0;
      break;
    case 8:
    case 9:
    case 10:
      if ( a5 != 10 )
      {
        v33 = sub_804E8C2("`", a5);
        v32 = sub_804E8C2("'", a5);
      }
      if ( v35 != 1 )
      {
        for ( sa = (char *)v33; *sa; ++sa )
        {
          if ( v36 < a2 )
            a1[v36] = *sa;
          ++v36;
        }
      }
      v34 = 1;
      s = (char *)v32;
      strlen(v32);
      break;
    default:
      abort();
      return result;
  }
  if ( a4 == -1 )
    LOBYTE(v10) = *a3 != 0;
  else
    v10 = a4 != 0;
  v11 = (_BYTE)v10 == 0;
  v12 = &loc_804F50C;
  if ( !v11 )
    v12 = &loc_804EB83;
  dword_8057164 = (int)v12;
  sub_8052214(v20);
  if ( v36 || a5 != 2 || !v35 )
  {
    if ( a5 == 2 && v35 != 1 )
    {
      dword_8057178 = (int)&loc_804F5D2;
      sub_80521A2(v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, a7, a3, a1);
      return sub_804E9B0(v17, 0, v16, a4, 5, a6, v15, v14, v13);
    }
    if ( s )
    {
      v19 = &loc_804F5FC;
      if ( v35 == 1 )
        v19 = &loc_804F628;
      dword_8057164 = (int)v19;
      sub_8052214(v21);
      while ( *s )
      {
        if ( v36 < a2 )
          a1[v36] = *s;
        ++v36;
        ++s;
      }
    }
    if ( v36 < a2 )
      a1[v36] = 0;
    dword_8057150 = (int)&loc_804F6A9;
    sub_805229F(v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32);
  }
  if ( a5 == 2 )
  {
    if ( v34 )
      a5 = 4;
  }
  return sub_804E9B0(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0, v33, v32);
}
// 80521A2: using guessed type int __stdcall sub_80521A2(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8052214: using guessed type int __stdcall sub_8052214(_DWORD);
// 805229F: using guessed type int __stdcall sub_805229F(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8057150: using guessed type int dword_8057150;
// 8057164: using guessed type int dword_8057164;
// 8057178: using guessed type int dword_8057178;

//----- (0804F777) --------------------------------------------------------
_BYTE *__cdecl sub_804F777(_BYTE *a1, int a2, _DWORD *a3, int a4)
{
  int v4; // ST40_4
  int v5; // ST44_4
  int v7; // [esp+0h] [ebp-58h]
  int size; // [esp+48h] [ebp-10h]
  _BYTE *v9; // [esp+4Ch] [ebp-Ch]

  if ( a4 )
  {
    dword_8057164 = (int)&loc_804F79B;
    sub_8052214(v7);
  }
  v4 = *__errno_location();
  v5 = *(&dword_805768F + 1) | (a3 == 0);
  size = sub_804E9B0(
           0,
           0,
           a1,
           a2,
           dword_805768F,
           v5,
           (int)(&dword_805768F + 2),
           (const char *)*(&dword_805768F + 10),
           (const char *)*(&dword_805768F + 11))
       + 1;
  v9 = sub_8050889(size);
  sub_804E9B0(
    v9,
    size,
    a1,
    a2,
    dword_805768F,
    v5,
    (int)(&dword_805768F + 2),
    (const char *)*(&dword_805768F + 10),
    (const char *)*(&dword_805768F + 11));
  *__errno_location() = v4;
  if ( a3 )
    *a3 = size - 1;
  return v9;
}
// 8052214: using guessed type int __stdcall sub_8052214(_DWORD);
// 8057164: using guessed type int dword_8057164;
// 805768F: using guessed type int dword_805768F;

//----- (0804F93B) --------------------------------------------------------
_BYTE *__cdecl sub_804F93B(signed int a1, _BYTE *a2, int a3, int a4)
{
  int *v4; // eax
  void *v5; // edx
  size_t v6; // ST44_4
  bool v8; // [esp+37h] [ebp-21h]
  int *v9; // [esp+38h] [ebp-20h]
  _BYTE *ptr; // [esp+3Ch] [ebp-1Ch]
  int v11; // [esp+40h] [ebp-18h]
  int size; // [esp+44h] [ebp-14h]
  int v13; // [esp+48h] [ebp-10h]
  unsigned int v14; // [esp+4Ch] [ebp-Ch]

  v11 = *__errno_location();
  v9 = off_8057210;
  if ( a1 < 0 )
    abort();
  if ( dword_8057204 <= a1 )
  {
    v8 = off_8057210 == &dword_8057208;
    if ( (unsigned int)a1 > 0xFFFFFFE )
      sub_8050A05();
    if ( v8 )
      v4 = 0;
    else
      v4 = off_8057210;
    v9 = (int *)sub_80508C6(v4, 8 * (a1 + 1));
    off_8057210 = v9;
    if ( v8 )
    {
      v5 = off_805720C;
      *v9 = dword_8057208;
      v9[1] = (int)v5;
    }
    memset(&v9[2 * dword_8057204], 0, 8 * (a1 + 1 - dword_8057204));
    dword_8057204 = a1 + 1;
  }
  v6 = v9[2 * a1];
  ptr = (_BYTE *)v9[2 * a1 + 1];
  v13 = *(_DWORD *)(a4 + 4) | 1;
  v14 = sub_804E9B0(
          (_BYTE *)v9[2 * a1 + 1],
          v9[2 * a1],
          a2,
          a3,
          *(_DWORD *)a4,
          v13,
          a4 + 8,
          *(const char **)(a4 + 40),
          *(const char **)(a4 + 44));
  if ( v6 <= v14 )
  {
    size = v14 + 1;
    v9[2 * a1] = v14 + 1;
    if ( ptr != (_BYTE *)&unk_80576CF )
      free(ptr);
    ptr = sub_8050889(size);
    v9[2 * a1 + 1] = (int)ptr;
    sub_804E9B0(ptr, size, a2, a3, *(_DWORD *)a4, v13, a4 + 8, *(const char **)(a4 + 40), *(const char **)(a4 + 44));
  }
  *__errno_location() = v11;
  return ptr;
}
// 8057204: using guessed type int dword_8057204;
// 8057208: using guessed type int dword_8057208;
// 805720C: using guessed type void *off_805720C;
// 8057210: using guessed type int *off_8057210;

//----- (0804FB64) --------------------------------------------------------
_BYTE *__cdecl sub_804FB64(signed int a1, _BYTE *a2)
{
  return sub_804F93B(a1, a2, -1, (int)&dword_805768F);
}
// 805768F: using guessed type int dword_805768F;

//----- (0804FB9E) --------------------------------------------------------
_BYTE *__cdecl sub_804FB9E(signed int a1, _BYTE *a2, int a3)
{
  return sub_804F93B(a1, a2, a3, (int)&dword_805768F);
}
// 805768F: using guessed type int dword_805768F;

//----- (0804FC16) --------------------------------------------------------
_BYTE *__cdecl sub_804FC16(signed int a1, int a2, _BYTE *a3)
{
  char v4; // [esp+10h] [ebp-38h]

  sub_804E834(&v4, a2);
  return sub_804F93B(a1, a3, -1, (int)&v4);
}

//----- (0804FC54) --------------------------------------------------------
_BYTE *__cdecl sub_804FC54(signed int a1, int a2, _BYTE *a3, int a4)
{
  char v5; // [esp+10h] [ebp-38h]

  sub_804E834(&v5, a2);
  return sub_804F93B(a1, a3, a4, (int)&v5);
}

//----- (0804FC9F) --------------------------------------------------------
_BYTE *__cdecl sub_804FC9F(int a1, _BYTE *a2)
{
  return sub_804FC16(0, a1, a2);
}

//----- (0804FCF8) --------------------------------------------------------
_BYTE *__cdecl sub_804FCF8(_BYTE *a1, int a2, unsigned __int8 a3)
{
  int v4; // [esp+20h] [ebp-38h]
  int v5; // [esp+24h] [ebp-34h]
  int v6; // [esp+28h] [ebp-30h]
  int v7; // [esp+2Ch] [ebp-2Ch]
  int v8; // [esp+30h] [ebp-28h]
  int v9; // [esp+34h] [ebp-24h]
  int v10; // [esp+38h] [ebp-20h]
  int v11; // [esp+3Ch] [ebp-1Ch]
  int v12; // [esp+40h] [ebp-18h]
  int v13; // [esp+44h] [ebp-14h]
  int v14; // [esp+48h] [ebp-10h]
  int v15; // [esp+4Ch] [ebp-Ch]

  v4 = dword_805768F;
  v5 = dword_8057693;
  v6 = dword_8057697;
  v7 = dword_805769B;
  v8 = dword_805769F;
  v9 = dword_80576A3;
  v10 = dword_80576A7;
  v11 = dword_80576AB;
  v12 = dword_80576AF;
  v13 = dword_80576B3;
  v14 = dword_80576B7;
  v15 = dword_80576BB;
  sub_804E720(&v4, a3, 1);
  return sub_804F93B(0, a1, a2, (int)&v4);
}
// 805768F: using guessed type int dword_805768F;
// 8057693: using guessed type int dword_8057693;
// 8057697: using guessed type int dword_8057697;
// 805769B: using guessed type int dword_805769B;
// 805769F: using guessed type int dword_805769F;
// 80576A3: using guessed type int dword_80576A3;
// 80576A7: using guessed type int dword_80576A7;
// 80576AB: using guessed type int dword_80576AB;
// 80576AF: using guessed type int dword_80576AF;
// 80576B3: using guessed type int dword_80576B3;
// 80576B7: using guessed type int dword_80576B7;
// 80576BB: using guessed type int dword_80576BB;

//----- (0804FDB2) --------------------------------------------------------
_BYTE *__cdecl sub_804FDB2(_BYTE *a1, unsigned __int8 a2)
{
  return sub_804FCF8(a1, -1, a2);
}

//----- (0804FDDB) --------------------------------------------------------
_BYTE *__cdecl sub_804FDDB(_BYTE *a1)
{
  return sub_804FDB2(a1, 0x3Au);
}

//----- (0804FE28) --------------------------------------------------------
_BYTE *__cdecl sub_804FE28(signed int a1, int a2, _BYTE *a3)
{
  int v4; // [esp+10h] [ebp-68h]
  int v5; // [esp+14h] [ebp-64h]
  int v6; // [esp+18h] [ebp-60h]
  int v7; // [esp+1Ch] [ebp-5Ch]
  int v8; // [esp+20h] [ebp-58h]
  int v9; // [esp+24h] [ebp-54h]
  int v10; // [esp+28h] [ebp-50h]
  int v11; // [esp+2Ch] [ebp-4Ch]
  int v12; // [esp+30h] [ebp-48h]
  int v13; // [esp+34h] [ebp-44h]
  int v14; // [esp+38h] [ebp-40h]
  int v15; // [esp+3Ch] [ebp-3Ch]
  int v16; // [esp+40h] [ebp-38h]
  int v17; // [esp+44h] [ebp-34h]
  int v18; // [esp+48h] [ebp-30h]
  int v19; // [esp+4Ch] [ebp-2Ch]
  int v20; // [esp+50h] [ebp-28h]
  int v21; // [esp+54h] [ebp-24h]
  int v22; // [esp+58h] [ebp-20h]
  int v23; // [esp+5Ch] [ebp-1Ch]
  int v24; // [esp+60h] [ebp-18h]
  int v25; // [esp+64h] [ebp-14h]
  int v26; // [esp+68h] [ebp-10h]
  int v27; // [esp+6Ch] [ebp-Ch]

  sub_804E834(&v4, a2);
  v16 = v4;
  v17 = v5;
  v18 = v6;
  v19 = v7;
  v20 = v8;
  v21 = v9;
  v22 = v10;
  v23 = v11;
  v24 = v12;
  v25 = v13;
  v26 = v14;
  v27 = v15;
  sub_804E720(&v16, 0x3Au, 1);
  return sub_804F93B(a1, a3, -1, (int)&v16);
}

//----- (0804FEDB) --------------------------------------------------------
void __cdecl __noreturn sub_804FEDB(int a1, int a2, int a3)
{
  sub_804FF0B(a1, a2, a3);
}

//----- (0804FF0B) --------------------------------------------------------
void __cdecl __noreturn sub_804FF0B(int a1, int a2, int a3)
{
  int v3; // [esp+10h] [ebp-38h]
  int v4; // [esp+14h] [ebp-34h]
  int v5; // [esp+18h] [ebp-30h]
  int v6; // [esp+1Ch] [ebp-2Ch]
  int v7; // [esp+20h] [ebp-28h]
  int v8; // [esp+24h] [ebp-24h]
  int v9; // [esp+28h] [ebp-20h]
  int v10; // [esp+2Ch] [ebp-1Ch]
  int v11; // [esp+30h] [ebp-18h]
  int v12; // [esp+34h] [ebp-14h]
  int v13; // [esp+38h] [ebp-10h]
  int v14; // [esp+3Ch] [ebp-Ch]

  v3 = dword_805768F;
  v4 = dword_8057693;
  v5 = dword_8057697;
  v6 = dword_805769B;
  v7 = dword_805769F;
  v8 = dword_80576A3;
  v9 = dword_80576A7;
  v10 = dword_80576AB;
  v11 = dword_80576AF;
  v12 = dword_80576B3;
  v13 = dword_80576B7;
  v14 = dword_80576BB;
  sub_804E7DA(&v3, a2, a3);
}
// 805768F: using guessed type int dword_805768F;
// 8057693: using guessed type int dword_8057693;
// 8057697: using guessed type int dword_8057697;
// 805769B: using guessed type int dword_805769B;
// 805769F: using guessed type int dword_805769F;
// 80576A3: using guessed type int dword_80576A3;
// 80576A7: using guessed type int dword_80576A7;
// 80576AB: using guessed type int dword_80576AB;
// 80576AF: using guessed type int dword_80576AF;
// 80576B3: using guessed type int dword_80576B3;
// 80576B7: using guessed type int dword_80576B7;
// 80576BB: using guessed type int dword_80576BB;

//----- (08050023) --------------------------------------------------------
_BYTE *__cdecl sub_8050023(signed int a1, _BYTE *a2, int a3)
{
  return sub_804F93B(a1, a2, a3, (int)&unk_8057224);
}

//----- (0805006E) --------------------------------------------------------
_BYTE *__cdecl sub_805006E(signed int a1, _BYTE *a2)
{
  return sub_8050023(a1, a2, -1);
}

//----- (08050090) --------------------------------------------------------
_BYTE *__cdecl sub_8050090(_BYTE *a1)
{
  return sub_805006E(0, a1);
}

//----- (080500BD) --------------------------------------------------------
int __cdecl sub_80500BD(int fd)
{
  return sub_8051182(fd, 0, 3);
}

//----- (080500F2) --------------------------------------------------------
int __cdecl sub_80500F2(FILE *stream, int a2, int a3, int a4, int a5, int a6)
{
  char *v6; // eax
  char *v7; // eax
  int v8; // ebx
  char *v9; // eax
  int result; // eax
  int v11; // esi
  int v12; // ebx
  char *v13; // eax
  int v14; // edi
  int v15; // esi
  int v16; // ebx
  char *v17; // eax
  int v18; // ST4C_4
  int v19; // edi
  int v20; // esi
  int v21; // ebx
  char *v22; // eax
  int v23; // ST4C_4
  int v24; // ST48_4
  int v25; // edi
  int v26; // esi
  int v27; // ebx
  char *v28; // eax
  int v29; // ST4C_4
  int v30; // ST48_4
  int v31; // ST44_4
  int v32; // edi
  int v33; // esi
  int v34; // ebx
  char *v35; // eax
  int v36; // esi
  int v37; // ST4C_4
  int v38; // ST48_4
  int v39; // ST44_4
  int v40; // ST40_4
  int v41; // edi
  int v42; // ebx
  char *v43; // eax
  int v44; // ecx
  int v45; // edi
  int v46; // ST4C_4
  int v47; // ST48_4
  int v48; // ST44_4
  int v49; // ST40_4
  int v50; // ST3C_4
  int v51; // esi
  int v52; // ebx
  char *v53; // eax
  int v54; // ST00_4
  int v55; // edi
  int v56; // ST4C_4
  int v57; // ST48_4
  int v58; // ST44_4
  int v59; // ST40_4
  int v60; // ST3C_4
  int v61; // ST38_4
  int v62; // esi
  int v63; // ebx
  char *v64; // eax
  int v65; // edi
  int v66; // ST4C_4
  int v67; // ST48_4
  int v68; // ST44_4
  int v69; // ST40_4
  int v70; // ST3C_4
  int v71; // ST38_4
  int v72; // esi
  int v73; // ebx
  char *v74; // eax

  if ( a2 )
    fprintf(stream, "%s (%s) %s\n", a2, a3, a4);
  else
    fprintf(stream, "%s %s\n", a3, a4);
  v6 = gettext("(C)");
  fprintf(stream, "Copyright %s %d Free Software Foundation, Inc.", v6, 2017);
  v7 = gettext(
         "\n"
         "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\n"
         "This is free software: you are free to change and redistribute it.\n"
         "There is NO WARRANTY, to the extent permitted by law.\n"
         "\n");
  fputs_unlocked(v7, stream);
  switch ( a6 )
  {
    case 0:
      abort();
      return result;
    case 1:
      v8 = *(_DWORD *)a5;
      v9 = gettext("Written by %s.\n");
      return fprintf(stream, v9, v8);
    case 2:
      v11 = *(_DWORD *)(a5 + 4);
      v12 = *(_DWORD *)a5;
      v13 = gettext("Written by %s and %s.\n");
      return fprintf(stream, v13, v12, v11);
    case 3:
      v14 = *(_DWORD *)(a5 + 8);
      v15 = *(_DWORD *)(a5 + 4);
      v16 = *(_DWORD *)a5;
      v17 = gettext("Written by %s, %s, and %s.\n");
      return fprintf(stream, v17, v16, v15, v14);
    case 4:
      v18 = *(_DWORD *)(a5 + 12);
      v19 = *(_DWORD *)(a5 + 8);
      v20 = *(_DWORD *)(a5 + 4);
      v21 = *(_DWORD *)a5;
      v22 = gettext("Written by %s, %s, %s,\nand %s.\n");
      return fprintf(stream, v22, v21, v20, v19, v18);
    case 5:
      v23 = *(_DWORD *)(a5 + 16);
      v24 = *(_DWORD *)(a5 + 12);
      v25 = *(_DWORD *)(a5 + 8);
      v26 = *(_DWORD *)(a5 + 4);
      v27 = *(_DWORD *)a5;
      v28 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
      return fprintf(stream, v28, v27, v26, v25, v24, v23);
    case 6:
      v29 = *(_DWORD *)(a5 + 20);
      v30 = *(_DWORD *)(a5 + 16);
      v31 = *(_DWORD *)(a5 + 12);
      v32 = *(_DWORD *)(a5 + 8);
      v33 = *(_DWORD *)(a5 + 4);
      v34 = *(_DWORD *)a5;
      v35 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
      return fprintf(stream, v35, v34, v33, v32, v31, v30, v29);
    case 7:
      v36 = *(_DWORD *)(a5 + 24);
      v37 = *(_DWORD *)(a5 + 20);
      v38 = *(_DWORD *)(a5 + 16);
      v39 = *(_DWORD *)(a5 + 12);
      v40 = *(_DWORD *)(a5 + 8);
      v41 = *(_DWORD *)(a5 + 4);
      v42 = *(_DWORD *)a5;
      v43 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
      fprintf(stream, v43, v42, v41, v40, v39, v38, v37, v36);
      dword_8057128 = (int)&loc_8050617;
      sub_8052373(v44);
      goto LABEL_13;
    case 8:
LABEL_13:
      v45 = *(_DWORD *)(a5 + 28);
      v46 = *(_DWORD *)(a5 + 24);
      v47 = *(_DWORD *)(a5 + 20);
      v48 = *(_DWORD *)(a5 + 16);
      v49 = *(_DWORD *)(a5 + 12);
      v50 = *(_DWORD *)(a5 + 8);
      v51 = *(_DWORD *)(a5 + 4);
      v52 = *(_DWORD *)a5;
      v53 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
      fprintf(stream, v53, v52, v51, v50, v49, v48, v47, v46, v45);
      dword_8057164 = (int)&loc_8050617;
      sub_8052214(v54);
      goto LABEL_14;
    case 9:
LABEL_14:
      v55 = *(_DWORD *)(a5 + 32);
      v56 = *(_DWORD *)(a5 + 28);
      v57 = *(_DWORD *)(a5 + 24);
      v58 = *(_DWORD *)(a5 + 20);
      v59 = *(_DWORD *)(a5 + 16);
      v60 = *(_DWORD *)(a5 + 12);
      v61 = *(_DWORD *)(a5 + 8);
      v62 = *(_DWORD *)(a5 + 4);
      v63 = *(_DWORD *)a5;
      v64 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
      result = fprintf(stream, v64, v63, v62, v61, v60, v59, v58, v57, v56, v55);
      break;
    default:
      v65 = *(_DWORD *)(a5 + 32);
      v66 = *(_DWORD *)(a5 + 28);
      v67 = *(_DWORD *)(a5 + 24);
      v68 = *(_DWORD *)(a5 + 20);
      v69 = *(_DWORD *)(a5 + 16);
      v70 = *(_DWORD *)(a5 + 12);
      v71 = *(_DWORD *)(a5 + 8);
      v72 = *(_DWORD *)(a5 + 4);
      v73 = *(_DWORD *)a5;
      v74 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
      result = fprintf(stream, v74, v73, v72, v71, v70, v69, v68, v67, v66, v65);
      break;
  }
  return result;
}
// 8048F50: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8052214: using guessed type int __stdcall sub_8052214(_DWORD);
// 8052373: using guessed type int __fastcall sub_8052373(_DWORD);
// 8057128: using guessed type int dword_8057128;
// 8057164: using guessed type int dword_8057164;

//----- (08050677) --------------------------------------------------------
int __cdecl sub_8050677(FILE *stream, int a2, int a3, int a4, int a5)
{
  int *v5; // eax
  unsigned int i; // [esp+24h] [ebp-34h]
  int v8[12]; // [esp+28h] [ebp-30h]

  for ( i = 0; i <= 9; ++i )
  {
    v5 = (int *)a5;
    a5 += 4;
    v8[i] = *v5;
    if ( !v8[i] )
      break;
  }
  return sub_80500F2(stream, a2, a3, a4, (int)v8, i);
}
// 8050677: using guessed type int var_30[12];

//----- (080506DD) --------------------------------------------------------
int sub_80506DD(FILE *stream, int a2, int a3, int a4, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a4);
  return sub_8050677(stream, a2, a3, a4, (int)va);
}

//----- (080507F2) --------------------------------------------------------
void *__cdecl sub_80507F2(void *ptr, int a2, int a3)
{
  unsigned int v4; // [esp+1Ch] [ebp-Ch]

  v4 = *(_DWORD *)a2;
  if ( ptr )
  {
    if ( 0x55555554u / a3 <= v4 )
      sub_8050A05();
    v4 += (v4 >> 1) + 1;
  }
  else
  {
    if ( !v4 )
      v4 = (0x40u / a3 == 0) + 0x40u / a3;
    if ( 0x7FFFFFFFu / a3 < v4 )
      sub_8050A05();
  }
  *(_DWORD *)a2 = v4;
  return sub_80508C6(ptr, a3 * v4);
}

//----- (08050889) --------------------------------------------------------
void *__cdecl sub_8050889(size_t size)
{
  return sub_805089C(size);
}

//----- (0805089C) --------------------------------------------------------
void *__cdecl sub_805089C(size_t size)
{
  void *v2; // [esp+1Ch] [ebp-Ch]

  v2 = malloc(size);
  if ( !v2 && size )
    sub_8050A05();
  return v2;
}

//----- (080508C6) --------------------------------------------------------
#error "805091F: call analysis failed (funcsize=34)"

//----- (0805092E) --------------------------------------------------------
void *__cdecl sub_805092E(void *ptr, int a2)
{
  return sub_80507F2(ptr, a2, 1);
}

//----- (0805097A) --------------------------------------------------------
void *__cdecl sub_805097A(size_t nmemb, size_t size)
{
  void *v3; // [esp+1Ch] [ebp-Ch]

  if ( 0x7FFFFFFF / size < nmemb || (v3 = calloc(nmemb, size)) == 0 )
    sub_8050A05();
  return v3;
}

//----- (080509B7) --------------------------------------------------------
void *__cdecl sub_80509B7(void *src, size_t n)
{
  void *v2; // eax

  v2 = sub_805089C(n);
  return memcpy(v2, src, n);
}

//----- (08050A05) --------------------------------------------------------
void __noreturn sub_8050A05()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (08050A3E) --------------------------------------------------------
void __cdecl sub_8050A3E(int errnum, int a2, int a3, int a4, int a5)
{
  char *v5; // eax
  char *v6; // eax
  _BYTE *v7; // esi
  _BYTE *v8; // ebx
  char *v9; // eax

  v5 = gettext("string comparison failed");
  error(0, errnum, v5);
  v6 = gettext("Set LC_ALL='C' to work around the problem.");
  error(0, 0, v6);
  v7 = sub_804FC54(1, 8, (_BYTE *)a4, a5);
  v8 = sub_804FC54(0, 8, (_BYTE *)a2, a3);
  v9 = gettext("The strings compared were %s and %s.");
  error(status, 0, v9, v8, v7);
}

//----- (08050B0A) --------------------------------------------------------
int __cdecl sub_8050B0A(void *s1, size_t n, void *s2, int a4)
{
  int v5; // [esp+28h] [ebp-10h]
  int errnum; // [esp+2Ch] [ebp-Ch]

  v5 = sub_8051BC5(s1, n, s2, a4);
  errnum = *__errno_location();
  if ( errnum )
    sub_8050A3E(errnum, (int)s1, n, (int)s2, a4);
  return v5;
}

//----- (08050BEA) --------------------------------------------------------
signed int __cdecl sub_8050BEA(unsigned int *a1, unsigned int a2)
{
  signed int result; // eax

  if ( 0xFFFFFFFF / a2 >= *a1 )
  {
    *a1 *= a2;
    result = 0;
  }
  else
  {
    *a1 = -1;
    result = 1;
  }
  return result;
}

//----- (08050C3C) --------------------------------------------------------
int __cdecl sub_8050C3C(unsigned int *a1, unsigned int a2, int a3)
{
  int v3; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; i |= sub_8050BEA(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}

//----- (08050C72) --------------------------------------------------------
#error "8050D98: call analysis failed (funcsize=153)"

//----- (080510BF) --------------------------------------------------------
int __cdecl sub_80510BF(FILE *stream)
{
  int v2; // eax
  __int64 v3; // rax
  int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]

  v4 = 0;
  if ( fileno(stream) < 0 )
    return fclose(stream);
  if ( !__freading(stream) || (v2 = fileno(stream), LODWORD(v3) = lseek64(v2, 0, 0, 1), v3 != -1) )
  {
    if ( sub_8051325(stream) )
      v4 = *__errno_location();
  }
  v5 = fclose(stream);
  if ( v4 )
  {
    *__errno_location() = v4;
    v5 = -1;
  }
  return v5;
}
// 8049090: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08051182) --------------------------------------------------------
int __cdecl sub_8051182(int fd, int cmd, char a3)
{
  int v3; // ST28_4
  int v5; // [esp+1Ch] [ebp-1Ch]
  char v6; // [esp+20h] [ebp-18h]
  int v7; // [esp+24h] [ebp-14h]

  if ( cmd != 1030 )
    return fcntl(fd, cmd, a3);
  v6 = a3;
  if ( dword_80577CF < 0 )
  {
    v5 = sub_8051182(fd, 0, a3);
  }
  else
  {
    v5 = fcntl(fd, 1030, a3);
    if ( v5 < 0 && *__errno_location() == 22 )
    {
      v5 = sub_8051182(fd, 0, v6);
      if ( v5 < 0 )
        return v5;
      dword_80577CF = -1;
    }
    else
    {
      dword_80577CF = 1;
    }
  }
  if ( v5 >= 0 && dword_80577CF == -1 )
  {
    v7 = fcntl(v5, 1);
    if ( v7 < 0 || fcntl(v5, 2, v7 | 1) == -1 )
    {
      v3 = *__errno_location();
      close(v5);
      *__errno_location() = v3;
      v5 = -1;
    }
  }
  return v5;
}
// 80577CF: using guessed type int dword_80577CF;

//----- (080512EC) --------------------------------------------------------
int __cdecl sub_80512EC(FILE *stream)
{
  int result; // eax

  result = stream->_flags & 0x100;
  if ( result )
    result = sub_8051377(stream, 0, 0, 1);
  return result;
}

//----- (08051325) --------------------------------------------------------
int __cdecl sub_8051325(FILE *fp)
{
  if ( !fp || !__freading(fp) )
    return fflush(fp);
  sub_80512EC(fp);
  return fflush(fp);
}

//----- (08051377) --------------------------------------------------------
int __cdecl sub_8051377(FILE *stream, int a2, int a3, int a4)
{
  int v4; // eax
  __off64_t v5; // rax

  if ( stream->_IO_read_end != stream->_IO_read_ptr
    || stream->_IO_write_ptr != stream->_IO_write_base
    || stream->_IO_save_base )
  {
    return fseeko64(stream, a2, a3, a4);
  }
  v4 = fileno(stream);
  LODWORD(v5) = lseek64(v4, a2, a3, a4);
  if ( v5 == -1 )
    return -1;
  stream->_flags &= 0xFFFFFFEF;
  stream->_offset = v5;
  return 0;
}
// 8048DF0: using guessed type int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8049090: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08051449) --------------------------------------------------------
size_t __cdecl sub_8051449(wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  char v5; // [esp+18h] [ebp-10h]
  size_t v6; // [esp+1Ch] [ebp-Ch]

  if ( !pwc )
    pwc = (wchar_t *)&v5;
  v6 = mbrtowc(pwc, s, n, p);
  if ( v6 <= 0xFFFFFFFD || !n || !((unsigned __int8)sub_804E316(0) ^ 1) )
    return v6;
  *pwc = (unsigned __int8)*s;
  return 1;
}

//----- (080514BB) --------------------------------------------------------
int __cdecl sub_80514BB(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // esi
  unsigned __int8 *v3; // ebx
  unsigned __int8 v5; // [esp+1Eh] [ebp-Ah]
  unsigned __int8 v6; // [esp+1Fh] [ebp-9h]

  v2 = a1;
  v3 = a2;
  if ( a1 == a2 )
    return 0;
  do
  {
    v5 = sub_8051EC7(*v2);
    v6 = sub_8051EC7(*v3);
    if ( !v5 )
      break;
    ++v2;
    ++v3;
  }
  while ( v5 == v6 );
  return v5 - v6;
}

//----- (08051520) --------------------------------------------------------
#error "80515A2: call analysis failed (funcsize=43)"

//----- (080515AE) --------------------------------------------------------
void *sub_80515AE()
{
  _BOOL4 v0; // eax
  int v1; // ecx
  void *v2; // eax
  int v4; // [esp+0h] [ebp-C8h]
  int v5; // [esp+4h] [ebp-C4h]
  int v6; // [esp+8h] [ebp-C0h]
  int v7; // [esp+Ch] [ebp-BCh]
  int v8; // [esp+10h] [ebp-B8h]
  void *v9; // [esp+18h] [ebp-B0h]
  const char *s; // [esp+1Ch] [ebp-ACh]
  void *v11; // [esp+20h] [ebp-A8h]
  void *v12; // [esp+20h] [ebp-A8h]
  int v13; // [esp+24h] [ebp-A4h]
  int v14; // [esp+24h] [ebp-A4h]
  size_t n; // [esp+2Ch] [ebp-9Ch]
  size_t v16; // [esp+30h] [ebp-98h]
  _BOOL4 v17; // [esp+34h] [ebp-94h]
  char *dest; // [esp+38h] [ebp-90h]
  int fd; // [esp+3Ch] [ebp-8Ch]
  FILE *stream; // [esp+40h] [ebp-88h]
  int c; // [esp+44h] [ebp-84h]
  int ca; // [esp+44h] [ebp-84h]
  size_t v23; // [esp+48h] [ebp-80h]
  size_t v24; // [esp+4Ch] [ebp-7Ch]
  void *v25; // [esp+50h] [ebp-78h]
  char src; // [esp+56h] [ebp-72h]
  char v27; // [esp+89h] [ebp-3Fh]
  unsigned int v28; // [esp+BCh] [ebp-Ch]

  v28 = __readgsdword(0x14u);
  v9 = (void *)dword_80577D3;
  if ( !dword_80577D3 )
  {
    s = getenv("CHARSETALIASDIR");
    if ( !s || !*s )
      s = "/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib";
    n = strlen(s);
    v16 = strlen("charset.alias");
    v0 = n && s[n - 1] != 47;
    v17 = v0;
    dest = (char *)malloc(n + v0 + v16 + 1);
    if ( dest )
    {
      memcpy(dest, s, n);
      if ( v17 )
        dest[n] = 47;
      memcpy(&dest[n + v17], "charset.alias", v16 + 1);
    }
    free(0);
    if ( dest )
    {
      fd = open64(dest, 0x20000);
      if ( fd < 0 )
      {
        dword_8057178 = (int)&loc_8051A2C;
        sub_80521A2(v4, v5, v6, v7, v8, 0, &unk_8053CC7, s, v11, v13, "charset.alias", n, v16, v17, dest, fd);
      }
      stream = fdopen(fd, "r");
      if ( !stream )
      {
        close(fd);
        dword_8057128 = (int)&loc_8051A2C;
        sub_8052373(v1);
      }
      v12 = 0;
      v14 = 0;
      while ( 1 )
      {
        c = getc_unlocked(stream);
        if ( c == -1 )
          break;
        if ( c != 10 && c != 32 && c != 9 )
        {
          if ( c == 35 )
          {
            do
              ca = getc_unlocked(stream);
            while ( ca != -1 && ca != 10 );
            if ( ca == -1 )
              break;
          }
          else
          {
            ungetc(c, stream);
            if ( fscanf(stream, "%50s %50s", &src, &v27) <= 1 )
              break;
            v23 = strlen(&src);
            v24 = strlen(&v27);
            v25 = v12;
            if ( v14 )
            {
              v14 += v24 + v23 + 2;
              v12 = realloc(v12, v14 + 1);
            }
            else
            {
              v14 = v23 + v24 + 2;
              v12 = malloc(v23 + v24 + 3);
            }
            if ( !v12 )
            {
              v14 = 0;
              free(v25);
              break;
            }
            strcpy((char *)v12 + v14 - v24 - v23 - 2, &src);
            strcpy((char *)v12 + v14 - v24 - 1, &v27);
          }
        }
      }
      sub_80510BF(stream);
      v2 = &loc_80519FC;
      if ( !v14 )
        v2 = &loc_8051A03;
      dword_8057114 = (int)v2;
      sub_80523DD();
      *((_BYTE *)v12 + v14) = 0;
      v9 = v12;
      free(dest);
    }
    else
    {
      v9 = &unk_8053CC7;
    }
    dword_80577D3 = (int)v9;
  }
  return v9;
}
// 8048D60: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 80521A2: using guessed type int __stdcall sub_80521A2(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8052373: using guessed type int __fastcall sub_8052373(_DWORD);
// 80523DD: using guessed type int sub_80523DD(void);
// 8057114: using guessed type int dword_8057114;
// 8057128: using guessed type int dword_8057128;
// 8057178: using guessed type int dword_8057178;
// 80577D3: using guessed type int dword_80577D3;

//----- (08051A65) --------------------------------------------------------
const char *sub_8051A65()
{
  char *v0; // ST1C_4
  const char *s1; // [esp+18h] [ebp-10h]
  char *s2; // [esp+1Ch] [ebp-Ch]

  s1 = nl_langinfo(14);
  if ( !s1 )
    s1 = (const char *)&unk_8053CC7;
  for ( s2 = (char *)sub_80515AE(); *s2; s2 = &v0[strlen(v0) + 1] )
  {
    if ( !strcmp(s1, s2) || *s2 == 42 && !s2[1] )
    {
      s1 = &s2[strlen(s2) + 1];
      break;
    }
    v0 = &s2[strlen(s2) + 1];
  }
  if ( !*s1 )
    s1 = "ASCII";
  return s1;
}

//----- (08051B18) --------------------------------------------------------
int __cdecl sub_8051B18(char *s, int a2, char *s2, int a4)
{
  size_t v4; // ST18_4
  size_t v5; // ST1C_4
  _BOOL4 v7; // eax
  int v8; // [esp+14h] [ebp-14h]

  while ( 1 )
  {
    *__errno_location() = 0;
    v8 = strcoll(s, s2);
    v7 = v8 || *__errno_location();
    if ( v7 )
      break;
    v4 = strlen(s) + 1;
    v5 = strlen(s2) + 1;
    s += v4;
    s2 += v5;
    a2 -= v4;
    a4 -= v5;
    if ( !a2 )
      return -(a4 != 0);
    if ( !a4 )
      return 1;
  }
  return v8;
}

//----- (08051BC5) --------------------------------------------------------
int __cdecl sub_8051BC5(void *s1, size_t n, void *s2, int a4)
{
  void *v4; // eax
  char v5; // ST22_1
  char v6; // ST23_1
  int v8; // [esp+1Ch] [ebp-Ch]

  v4 = &loc_8051BEC;
  if ( n != a4 )
    v4 = &loc_8051C1D;
  dword_8057114 = (int)v4;
  sub_80523DD();
  if ( !memcmp(s1, s2, n) )
  {
    *__errno_location() = 0;
    v8 = 0;
  }
  else
  {
    v5 = *((_BYTE *)s1 + n);
    v6 = *((_BYTE *)s2 + a4);
    *((_BYTE *)s1 + n) = 0;
    *((_BYTE *)s2 + a4) = 0;
    v8 = sub_8051B18((char *)s1, n + 1, (char *)s2, a4 + 1);
    *((_BYTE *)s1 + n) = v5;
    *((_BYTE *)s2 + a4) = v6;
  }
  return v8;
}
// 80523DD: using guessed type int sub_80523DD(void);
// 8057114: using guessed type int dword_8057114;

//----- (08051C99) --------------------------------------------------------
int __cdecl sub_8051C99(void *s1, size_t n, void *s2, int a4)
{
  if ( n != a4 || memcmp(s1, s2, n) )
    return sub_8051B18((char *)s1, n, (char *)s2, a4);
  *__errno_location() = 0;
  return 0;
}

//----- (08051EC7) --------------------------------------------------------
int __cdecl sub_8051EC7(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 65) > 0x19 )
    result = a1;
  else
    result = a1 + 32;
  return result;
}

//----- (08051F83) --------------------------------------------------------
int __cdecl sub_8051F83(int a1)
{
  return __cxa_atexit(a1, 0, dword_80571C8);
}
// 8048EB0: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 80571C8: using guessed type int dword_80571C8;

//----- (0805212E) --------------------------------------------------------
#error "8052134: positive sp value has been found (funcsize=0)"

//----- (080521A2) --------------------------------------------------------
#error "80521A8: positive sp value has been found (funcsize=0)"

//----- (08052214) --------------------------------------------------------
#error "805221A: positive sp value has been found (funcsize=0)"

//----- (0805225E) --------------------------------------------------------
#error "8052297: positive sp value has been found (funcsize=18)"

//----- (0805229F) --------------------------------------------------------
#error "80522A5: positive sp value has been found (funcsize=0)"

//----- (08052309) --------------------------------------------------------
#error "805230F: positive sp value has been found (funcsize=0)"

//----- (08052373) --------------------------------------------------------
#error "8052379: positive sp value has been found (funcsize=0)"

//----- (080523DD) --------------------------------------------------------
#error "80523E3: positive sp value has been found (funcsize=0)"

//----- (080523F0) --------------------------------------------------------
int (**sub_80523F0())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_8056EDC;
  v1 = &off_8056EE0 - off_8056EDC;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_8056EDC[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 8056EDC: using guessed type int (*off_8056EDC[2])();
// 8056EE0: using guessed type int (*off_8056EE0)();

//----- (08052454) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 26 decompilation failure(s) on 143 function(s)"
