/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8048D40();
// int strcmp(const char *s1, const char *s2);
// int __cdecl open64(_DWORD, _DWORD); weak
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void _exit(int status);
// void free(void *ptr);
// void *memcpy(void *dest, const void *src, size_t n);
// int mbsinit(const mbstate_t *ps);
// int fclose(FILE *stream);
// int getc_unlocked(FILE *stream);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// char *textdomain(const char *domainname);
// int iswprint(wint_t wc);
// int __cdecl fopen64(_DWORD, _DWORD); weak
// int ferror_unlocked(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// size_t __ctype_get_mb_cur_max(void);
// char *strcpy(char *dest, const char *src);
// size_t __fpending(FILE *fp);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// void error(int status, int errnum, const char *format, ...);
// int strcoll(const char *s1, const char *s2);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// char *strchr(const char *s, int c);
// int fscanf(FILE *stream, const char *format, ...);
// size_t strlen(const char *s);
// int fprintf(FILE *stream, const char *format, ...);
// int fcntl(int fd, int cmd, ...);
// void *memset(void *s, int c, size_t n);
// int ungetc(int c, FILE *stream);
// int *__errno_location(void);
// void *memchr(const void *s, int c, size_t n);
// int fileno(FILE *stream);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// char *strpbrk(const char *s, const char *accept);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// int toupper(int c);
// char *strrchr(const char *s, int c);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// char *bindtextdomain(const char *domainname, const char *dirname);
// int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// int feof_unlocked(FILE *stream);
// void abort(void);
// int close(int fd);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// void *calloc(size_t nmemb, size_t size);
// int putchar_unlocked(int c);
// int _gmon_start__(void); weak
void sub_8049183();
void sub_80491A0();
int sub_80491B0();
int sub_8049220();
int sub_8049240();
void sub_804929F();
void sub_80492BA();
signed int sub_80492CA();
int __cdecl sub_804937A(unsigned __int8 a1);
int __cdecl sub_80493B9(char *s1); // idb
void __cdecl __noreturn sub_804953F(int status); // idb
int __cdecl sub_80496BC(int a1, int a2, int a3);
int __cdecl sub_8049736(int a1);
int __cdecl sub_80498BB(int a1);
int __cdecl sub_80498FB(int a1, int a2, unsigned int a3, unsigned int a4);
int __cdecl sub_8049A5A(int a1, int a2, int a3);
int __cdecl sub_8049BAA(int a1);
void *__cdecl sub_8049BB9(_DWORD *a1);
int __cdecl sub_8049BE3(FILE *stream, int, int); // idb
void sub_8049D43();
_DWORD *__cdecl sub_8049D90(_DWORD *a1);
int __cdecl sub_8049DB2(FILE *stream, int, int); // idb
int __cdecl sub_8049E5F(FILE *stream, int, int, int); // idb
void __cdecl sub_8049E95(int a1);
char *__cdecl sub_8049EF3(unsigned int a1, int a2);
unsigned int __cdecl sub_8049F95(int a1, unsigned int a2, unsigned int a3);
int __cdecl sub_804A03E(void *a1, int a2);
void __cdecl sub_804A196(FILE *stream, FILE *a2);
_DWORD *__cdecl sub_804A7B2(int a1, int a2);
int __cdecl sub_804A85D(char *nptr); // idb
void __cdecl sub_804A8F4(char *a1, _DWORD *a2, _DWORD *a3);
_DWORD *__cdecl sub_804AA19(char *a1);
_DWORD *__cdecl sub_804AA86(_DWORD *a1, int a2);
_DWORD *__cdecl sub_804AAF0(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, signed int *a5, _DWORD *a6, _DWORD *a7);
_BOOL4 __cdecl main(int argc, char **argv);
int sub_804B5D1();
int __cdecl sub_804B6B5(int a1, int a2, int a3, int a4, int a5, int a6);
void __cdecl sub_804B706(FILE *stream, int a2);
FILE *__cdecl sub_804B74E(int a1, char *modes);
int __cdecl sub_804B824(int category); // idb
int __cdecl sub_804B8C7(int, FILE *stream, int); // idb
int __cdecl sub_804B9E5(int a1, int a2, unsigned int a3);
char *__cdecl sub_804BA65(char *s);
int __cdecl sub_804BBB1(int *a1, unsigned __int8 a2, char a3);
int *__cdecl sub_804BC5B(int *a1, int a2, int a3);
// _DWORD *__userpurge sub_804BC9C@<eax>(_DWORD *a1, int a2);
const char *__cdecl sub_804BD1E(char *msgid, int a2);
unsigned int __cdecl sub_804BDB9(int a1, unsigned int a2, int a3, size_t a4, signed int a5, int a6, int a7, char *a8, char *a9);
void *__cdecl sub_804CA50(int a1, size_t a2, _DWORD *a3, int *a4);
void *__cdecl sub_804CBF7(signed int a1, int a2, size_t a3, int a4);
void *__cdecl sub_804CE20(signed int a1, int a2);
void *__cdecl sub_804CE4A(signed int a1, int a2, size_t a3);
void *__cdecl sub_804CEB0(signed int a1, int a2, int a3);
void *__cdecl sub_804CEEE(signed int a1, int a2, int a3, size_t a4);
void *__cdecl sub_804CF2B(int a1, int a2);
void *__cdecl sub_804CF76(int a1, size_t a2, unsigned __int8 a3);
void *__cdecl sub_804D020(int a1, unsigned __int8 a2);
void *__cdecl sub_804D049(int a1);
void *__cdecl sub_804D086(signed int a1, int a2, int a3);
void *__cdecl sub_804D127(signed int a1, int a2, int a3, int a4);
void *__cdecl sub_804D157(signed int a1, int a2, int a3, int a4, size_t a5);
void *__cdecl sub_804D251(signed int a1, int a2, size_t a3);
void *__cdecl sub_804D29C(signed int a1, int a2);
void *__cdecl sub_804D2BE(int a1);
int __cdecl sub_804D2D9(int fd); // idb
int __cdecl sub_804D2FC(FILE *stream, int, int, int, int, int); // idb
int __cdecl sub_804D861(FILE *stream, int, int, int, int); // idb
int sub_804D8C7(FILE *stream, int a2, int a3, int a4, ...);
void *__cdecl sub_804D9CA(void *ptr, int a2, int a3);
void *__cdecl sub_804DA61(size_t size);
void *__cdecl sub_804DA74(size_t size);
void *__cdecl sub_804DA9E(void *ptr, size_t size);
void *__cdecl sub_804DAED(void *ptr, int a2);
void *__cdecl sub_804DB39(size_t nmemb, size_t size);
void *__cdecl sub_804DB76(void *src, size_t n);
void __noreturn sub_804DBC4();
void __cdecl sub_804DBFD(int errnum, int a2, int a3, int a4, int a5);
int __cdecl sub_804DCC9(void *s1, size_t n, void *s2, int); // idb
signed int __cdecl sub_804DD99(unsigned int *a1, unsigned int a2);
int __cdecl sub_804DDDD(unsigned int *a1, unsigned int a2, int a3);
int __cdecl sub_804DE13(char *nptr, int, int base, int, char *s); // idb
int __cdecl sub_804E1E7(FILE *stream); // idb
int __cdecl sub_804E2AA(int fd, int cmd, char); // idb
int __cdecl sub_804E414(FILE *stream); // idb
int __cdecl sub_804E44D(FILE *fp); // idb
int __cdecl sub_804E48D(FILE *stream, int, int, int); // idb
size_t __cdecl sub_804E55F(wchar_t *pwc, char *s, size_t n, mbstate_t *p);
int __cdecl sub_804E5D1(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_804E636(FILE *fp); // idb
void *sub_804E6B7();
const char *sub_804EB2F();
int __cdecl sub_804EBE2(char *s, int, char *s2, int); // idb
int __cdecl sub_804EC8F(void *s1, size_t n, void *s2, int); // idb
int __cdecl sub_804ED4A(void *s1, size_t n, void *s2, int); // idb
int __cdecl sub_804EF6B(int a1);
int __cdecl sub_804F019(int a1);
int (**sub_804F040())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_804F0E0; // weak
char s = '\0'; // idb
struct option longopts = { "ignore-case", 0, NULL, 105 }; // idb
_UNKNOWN unk_804FF4E; // weak
_UNKNOWN unk_804FF52; // weak
_UNKNOWN unk_804FF5E; // weak
_UNKNOWN unk_804FF62; // weak
_UNKNOWN unk_804FF65; // weak
_UNKNOWN unk_80508C7; // weak
int (*off_8053F04[2])() = { &sub_8049240, &sub_8049220 }; // weak
int (*off_8053F08)() = &sub_8049220; // weak
int (*dword_8054008)(void) = NULL; // weak
int dword_8054118 = 0; // weak
int dword_805411C = 4294967295; // weak
int dword_8054120 = 4294967295; // weak
void *off_8054124 = &unk_805429D; // weak
int c = 4294967295; // idb
char byte_805412C = '\n'; // weak
int off_8054130 = 134544898; // idb
int status = 1; // idb
int dword_8054154 = 1; // weak
int dword_8054158 = 256; // weak
void *off_805415C = &unk_805432D; // weak
int *off_8054160 = &dword_8054158; // weak
_UNKNOWN unk_8054174; // weak
_UNKNOWN unk_80541A4; // weak
_UNKNOWN unk_80541A7; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int program_invocation_name; // weak
int optind; // weak
int stdin; // weak
FILE *stdout; // idb
char *optarg; // idb
char byte_805420C; // weak
int dword_805425D[]; // weak
int dword_8054261; // weak
int dword_8054265[]; // weak
int dword_8054269[2]; // idb
char *dword_8054275; // idb
char *dword_8054279; // idb
void *ptr[2]; // idb
char byte_8054285; // weak
char byte_8054286; // weak
char byte_8054287; // weak
char byte_8054288; // weak
char byte_8054289; // weak
char byte_805428A[]; // weak
char byte_805428B; // weak
char *s1; // idb
char byte_8054291; // weak
int dword_8054295; // weak
int dword_8054299; // weak
int dword_80542A5; // weak
int dword_80542A9; // weak
_UNKNOWN unk_80542AD; // weak
char byte_80542C5; // weak
char byte_80542C6; // weak
int dword_80542C9; // weak
char byte_80542CD; // weak
int dword_80542D1; // weak
int dword_80542ED; // weak
int dword_80542F1; // weak
int dword_80542F5; // weak
int dword_80542F9; // weak
int dword_80542FD; // weak
int dword_8054301; // weak
int dword_8054305; // weak
int dword_8054309; // weak
int dword_805430D; // weak
int dword_8054311; // weak
int dword_8054315; // weak
int dword_8054319; // weak
_UNKNOWN unk_805432D; // weak
int dword_805442D; // weak
int dword_8054431; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (08048D18) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 8049140: using guessed type int _gmon_start__(void);

//----- (08048D40) --------------------------------------------------------
int sub_8048D40()
{
  return dword_8054008();
}
// 8054008: using guessed type int (*dword_8054008)(void);

//----- (08049150) --------------------------------------------------------
#error "8049153: positive sp value has been found (funcsize=2)"

//----- (08049183) --------------------------------------------------------
void sub_8049183()
{
  ;
}

//----- (080491A0) --------------------------------------------------------
void sub_80491A0()
{
  ;
}

//----- (080491B0) --------------------------------------------------------
int sub_80491B0()
{
  int result; // eax

  result = &unk_80541A7 - &unk_80541A4;
  if ( (unsigned int)(&unk_80541A7 - &unk_80541A4) > 6 )
    result = 0;
  return result;
}
// 80491B0: could not find valid save-restore pair for ebp

//----- (08049220) --------------------------------------------------------
int sub_8049220()
{
  int result; // eax

  if ( !byte_805420C )
  {
    result = sub_80491B0();
    byte_805420C = 1;
  }
  return result;
}
// 8049220: could not find valid save-restore pair for ebp
// 805420C: using guessed type char byte_805420C;

//----- (08049240) --------------------------------------------------------
int sub_8049240()
{
  return 0;
}
// 8049240: could not find valid save-restore pair for ebp

//----- (0804929F) --------------------------------------------------------
void sub_804929F()
{
  ;
}

//----- (080492BA) --------------------------------------------------------
void sub_80492BA()
{
  ;
}

//----- (080492CA) --------------------------------------------------------
signed int sub_80492CA()
{
  return 3;
}
// 80492CA: could not find valid save-restore pair for ebp

//----- (0804937A) --------------------------------------------------------
int __cdecl sub_804937A(unsigned __int8 a1)
{
  return (*__ctype_b_loc())[a1] & 1 || a1 == 10;
}

//----- (080493B9) --------------------------------------------------------
int __cdecl sub_80493B9(char *s1)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // ebx
  char *v5; // eax
  char *v7; // [esp+1Ch] [ebp-4Ch]
  void **i; // [esp+20h] [ebp-48h]
  const char *v9; // [esp+24h] [ebp-44h]
  void *v10; // [esp+28h] [ebp-40h]
  const char *v11; // [esp+2Ch] [ebp-3Ch]
  const char *v12; // [esp+30h] [ebp-38h]
  const char *v13; // [esp+34h] [ebp-34h]
  const char *v14; // [esp+38h] [ebp-30h]
  const char *v15; // [esp+3Ch] [ebp-2Ch]
  const char *v16; // [esp+40h] [ebp-28h]
  const char *v17; // [esp+44h] [ebp-24h]
  const char *v18; // [esp+48h] [ebp-20h]
  const char *v19; // [esp+4Ch] [ebp-1Ch]
  const char *v20; // [esp+50h] [ebp-18h]
  const char *v21; // [esp+54h] [ebp-14h]
  int v22; // [esp+58h] [ebp-10h]
  int v23; // [esp+5Ch] [ebp-Ch]

  v10 = &unk_804F0E0;
  v11 = "test invocation";
  v12 = "coreutils";
  v13 = "Multi-call invocation";
  v14 = "sha224sum";
  v15 = "sha2 utilities";
  v16 = "sha256sum";
  v17 = "sha2 utilities";
  v18 = "sha384sum";
  v19 = "sha2 utilities";
  v20 = "sha512sum";
  v21 = "sha2 utilities";
  v22 = 0;
  v23 = 0;
  v7 = s1;
  for ( i = &v10; *i && strcmp(s1, (const char *)*i); i += 2 )
    ;
  if ( i[1] )
    v7 = (char *)i[1];
  v1 = gettext("\n%s online help: <%s>\n");
  printf(v1, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  v9 = setlocale(5, 0);
  if ( v9 && strncmp(v9, "en_", 3u) )
  {
    v2 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
    printf(v2, s1);
  }
  v3 = gettext("Full documentation at: <%s%s>\n");
  printf(v3, "http://www.gnu.org/software/coreutils/", s1);
  if ( v7 == s1 )
    v4 = " invocation";
  else
    v4 = &s;
  v5 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  return printf(v5, v7, v4);
}

//----- (0804953F) --------------------------------------------------------
void __cdecl __noreturn sub_804953F(int status)
{
  int v1; // ebx
  char *v2; // eax
  int v3; // ebx
  char *v4; // eax
  FILE *v5; // ebx
  char *v6; // eax
  FILE *v7; // ebx
  char *v8; // eax
  FILE *v9; // ebx
  char *v10; // eax
  FILE *v11; // ebx
  char *v12; // eax
  FILE *v13; // ebx
  char *v14; // eax
  FILE *v15; // ebx
  char *v16; // eax
  FILE *v17; // ebx
  char *v18; // eax
  FILE *v19; // ebx
  char *v20; // eax
  FILE *v21; // ebx
  char *v22; // eax

  if ( status )
  {
    v1 = dword_80542D1;
    v2 = gettext("Try '%s --help' for more information.\n");
    fprintf(stderr, v2, v1);
  }
  else
  {
    v3 = dword_80542D1;
    v4 = gettext("Usage: %s [OPTION]... FILE1 FILE2\n");
    printf(v4, v3);
    v5 = stdout;
    v6 = gettext(
           "For each pair of input lines with identical join fields, write a line to\n"
           "standard output.  The default join field is the first, delimited by blanks.\n");
    fputs_unlocked(v6, v5);
    v7 = stdout;
    v8 = gettext("\nWhen FILE1 or FILE2 (not both) is -, read standard input.\n");
    fputs_unlocked(v8, v7);
    v9 = stdout;
    v10 = gettext(
            "\n"
            "  -a FILENUM        also print unpairable lines from file FILENUM, where\n"
            "                      FILENUM is 1 or 2, corresponding to FILE1 or FILE2\n"
            "  -e EMPTY          replace missing input fields with EMPTY\n");
    fputs_unlocked(v10, v9);
    v11 = stdout;
    v12 = gettext(
            "  -i, --ignore-case  ignore differences in case when comparing fields\n"
            "  -j FIELD          equivalent to '-1 FIELD -2 FIELD'\n"
            "  -o FORMAT         obey FORMAT while constructing output line\n"
            "  -t CHAR           use CHAR as input and output field separator\n");
    fputs_unlocked(v12, v11);
    v13 = stdout;
    v14 = gettext(
            "  -v FILENUM        like -a FILENUM, but suppress joined output lines\n"
            "  -1 FIELD          join on this FIELD of file 1\n"
            "  -2 FIELD          join on this FIELD of file 2\n"
            "  --check-order     check that the input is correctly sorted, even\n"
            "                      if all input lines are pairable\n"
            "  --nocheck-order   do not check that the input is correctly sorted\n"
            "  --header          treat the first line in each file as field headers,\n"
            "                      print them without trying to pair them\n");
    fputs_unlocked(v14, v13);
    v15 = stdout;
    v16 = gettext("  -z, --zero-terminated     line delimiter is NUL, not newline\n");
    fputs_unlocked(v16, v15);
    v17 = stdout;
    v18 = gettext("      --help     display this help and exit\n");
    fputs_unlocked(v18, v17);
    v19 = stdout;
    v20 = gettext("      --version  output version information and exit\n");
    fputs_unlocked(v20, v19);
    v21 = stdout;
    v22 = gettext(
            "\n"
            "Unless -t CHAR is given, leading blanks separate fields and are ignored,\n"
            "else fields are separated by CHAR.  Any FIELD is a field number counted\n"
            "from 1.  FORMAT is one or more comma or blank separated specifications,\n"
            "each being 'FILENUM.FIELD' or '0'.  Default FORMAT outputs the join field,\n"
            "the remaining fields from FILE1, the remaining fields from FILE2, all\n"
            "separated by CHAR.  If FORMAT is the keyword 'auto', then the first\n"
            "line of each file determines the number of fields output for each line.\n"
            "\n"
            "Important: FILE1 and FILE2 must be sorted on the join fields.\n"
            "E.g., use \"sort -k 1b,1\" if 'join' has no options,\n"
            "or use \"join -t ''\" if 'sort' has no options.\n"
            "Note, comparisons honor the rules specified by 'LC_COLLATE'.\n"
            "If the input is not sorted and some lines cannot be joined, a\n"
            "warning message will be given.\n");
    fputs_unlocked(v22, v21);
    sub_80493B9("join");
  }
  exit(status);
}
// 8048F50: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 80542D1: using guessed type int dword_80542D1;

//----- (080496BC) --------------------------------------------------------
int __cdecl sub_80496BC(int a1, int a2, int a3)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 12) >= *(_DWORD *)(a1 + 16) )
    *(_DWORD *)(a1 + 20) = sub_804D9CA(*(void **)(a1 + 20), a1 + 16, 8);
  *(_DWORD *)(8 * *(_DWORD *)(a1 + 12) + *(_DWORD *)(a1 + 20)) = a2;
  *(_DWORD *)(8 * *(_DWORD *)(a1 + 12) + *(_DWORD *)(a1 + 20) + 4) = a3;
  result = a1;
  ++*(_DWORD *)(a1 + 12);
  return result;
}

//----- (08049736) --------------------------------------------------------
int __cdecl sub_8049736(int a1)
{
  int v1; // edx
  int result; // eax
  unsigned __int8 *s; // [esp+10h] [ebp-18h]
  unsigned __int8 *i; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]
  char *v6; // [esp+1Ch] [ebp-Ch]

  s = *(unsigned __int8 **)(a1 + 8);
  v1 = *(_DWORD *)(a1 + 4) - 1;
  v5 = (int)&s[v1];
  result = *(_DWORD *)(a1 + 8);
  if ( s != &s[v1] )
  {
    if ( c >= 0 && c != 10 )
    {
      while ( 1 )
      {
        v6 = (char *)memchr(s, c, v5 - (_DWORD)s);
        if ( !v6 )
          break;
        sub_80496BC(a1, (int)s, v6 - (char *)s);
        s = (unsigned __int8 *)(v6 + 1);
      }
      return sub_80496BC(a1, (int)s, v5 - (_DWORD)s);
    }
    if ( c >= 0 )
      return sub_80496BC(a1, (int)s, v5 - (_DWORD)s);
    while ( (unsigned __int8)sub_804937A(*s) )
    {
      result = (int)++s;
      if ( s == (unsigned __int8 *)v5 )
        return result;
    }
    while ( 1 )
    {
      for ( i = s + 1; i != (unsigned __int8 *)v5 && (unsigned __int8)sub_804937A(*i) ^ 1; ++i )
        ;
      sub_80496BC(a1, (int)s, i - s);
      result = (int)i;
      if ( i == (unsigned __int8 *)v5 )
        break;
      for ( s = i + 1; s != (unsigned __int8 *)v5 && (unsigned __int8)sub_804937A(*s); ++s )
        ;
      if ( s == (unsigned __int8 *)v5 )
        return sub_80496BC(a1, (int)s, v5 - (_DWORD)s);
    }
  }
  return result;
}

//----- (080498BB) --------------------------------------------------------
int __cdecl sub_80498BB(int a1)
{
  int result; // eax

  if ( a1 )
  {
    free(*(void **)(a1 + 20));
    *(_DWORD *)(a1 + 20) = 0;
    free(*(void **)(a1 + 8));
    result = a1;
    *(_DWORD *)(a1 + 8) = 0;
  }
  return result;
}

//----- (080498FB) --------------------------------------------------------
int __cdecl sub_80498FB(int a1, int a2, unsigned int a3, unsigned int a4)
{
  int result; // eax
  unsigned int v5; // eax
  size_t v6; // eax
  void *s1; // [esp+1Ch] [ebp-1Ch]
  void *s2; // [esp+20h] [ebp-18h]
  size_t v9; // [esp+24h] [ebp-14h]
  unsigned int n; // [esp+28h] [ebp-10h]
  int v11; // [esp+2Ch] [ebp-Ch]

  if ( *(_DWORD *)(a1 + 12) <= a3 )
  {
    s1 = 0;
    v9 = 0;
  }
  else
  {
    s1 = *(void **)(8 * a3 + *(_DWORD *)(a1 + 20));
    v9 = *(_DWORD *)(8 * a3 + *(_DWORD *)(a1 + 20) + 4);
  }
  if ( *(_DWORD *)(a2 + 12) <= a4 )
  {
    s2 = 0;
    n = 0;
  }
  else
  {
    s2 = *(void **)(8 * a4 + *(_DWORD *)(a2 + 20));
    n = *(_DWORD *)(8 * a4 + *(_DWORD *)(a2 + 20) + 4);
  }
  if ( v9 )
  {
    if ( !n )
      return 1;
    if ( byte_80542C5 )
    {
      v5 = v9;
      if ( n <= v9 )
        v5 = n;
      v11 = sub_804B9E5((int)s1, (int)s2, v5);
    }
    else
    {
      if ( byte_8054285 )
        return sub_804DCC9(s1, v9, s2, n);
      v6 = v9;
      if ( n <= v9 )
        v6 = n;
      v11 = memcmp(s1, s2, v6);
    }
    if ( v11 )
    {
      result = v11;
    }
    else if ( v9 < n )
    {
      result = -1;
    }
    else
    {
      result = v9 != n;
    }
  }
  else if ( n )
  {
    result = -1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 8054285: using guessed type char byte_8054285;
// 80542C5: using guessed type char byte_80542C5;

//----- (08049A5A) --------------------------------------------------------
int __cdecl sub_8049A5A(int a1, int a2, int a3)
{
  int result; // eax
  unsigned int v4; // eax
  signed int v5; // eax
  int v6; // ST2C_4
  signed int v7; // ST28_4
  int v8; // ebx
  int v9; // esi
  char *v10; // edi
  char *v11; // eax
  signed int v12; // [esp+38h] [ebp-20h]

  result = dword_80542A9;
  if ( dword_80542A9 != 2 )
  {
    if ( dword_80542A9 == 1 || (result = (unsigned __int8)byte_8054289, byte_8054289) )
    {
      result = (unsigned __int8)byte_805428A[a3 - 1] ^ 1;
      if ( byte_805428A[a3 - 1] != 1 )
      {
        v4 = a3 == 1 ? dword_805411C : dword_8054120;
        result = sub_80498FB(a1, a2, v4, v4);
        if ( result > 0 )
        {
          v12 = *(_DWORD *)(a2 + 4);
          if ( v12 && *(_BYTE *)(v12 - 1 + *(_DWORD *)(a2 + 8)) == 10 )
            --v12;
          if ( v12 < 0 )
            v5 = 0x7FFFFFFF;
          else
            v5 = v12;
          v6 = *(_DWORD *)(a2 + 8);
          v7 = v5;
          v8 = dword_8054265[2 * (a3 - 1)];
          v9 = dword_8054269[2 * (a3 - 1)];
          v10 = (&dword_8054275)[a3 - 1];
          v11 = gettext("%s:%llu: is not sorted: %.*s");
          error(dword_80542A9 == 1, 0, v11, v10, v8, v9, v7, v6);
          result = a3 - 1;
          byte_805428A[a3 - 1] = 1;
        }
      }
    }
  }
  return result;
}
// 805411C: using guessed type int dword_805411C;
// 8054120: using guessed type int dword_8054120;
// 8054265: using guessed type int dword_8054265[];
// 8054289: using guessed type char byte_8054289;
// 80542A9: using guessed type int dword_80542A9;

//----- (08049BAA) --------------------------------------------------------
int __cdecl sub_8049BAA(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (08049BB9) --------------------------------------------------------
void *__cdecl sub_8049BB9(_DWORD *a1)
{
  void *result; // eax

  result = sub_804DB39(1u, 0x18u);
  *a1 = result;
  return result;
}

//----- (08049BE3) --------------------------------------------------------
int __cdecl sub_8049BE3(FILE *stream, int a2, int a3)
{
  char *v3; // ebx
  int *v4; // eax
  int result; // eax
  int v6; // ecx
  __int64 v7; // rax
  void *v8; // [esp+18h] [ebp-10h]

  v8 = *(void **)a2;
  if ( dword_805425D[a3 - 1] == *(_DWORD *)a2 )
  {
    v8 = ptr[a3 - 1];
    ptr[a3 - 1] = *(void **)a2;
    *(_DWORD *)a2 = v8;
  }
  if ( v8 )
    sub_8049BAA((int)v8);
  else
    v8 = sub_8049BB9((_DWORD *)a2);
  if ( sub_804B8C7((int)v8, stream, byte_805412C) )
  {
    v6 = a3 - 1;
    LODWORD(v7) = dword_8054265[2 * (a3 - 1)];
    HIDWORD(v7) = dword_8054269[2 * (a3 - 1)];
    dword_8054265[2 * v6] = ++v7;
    dword_8054269[2 * v6] = HIDWORD(v7);
    sub_8049736((int)v8);
    if ( dword_805425D[a3 - 1] )
      sub_8049A5A(dword_805425D[a3 - 1], (int)v8, a3);
    dword_805425D[a3 - 1] = (int)v8;
    result = 1;
  }
  else
  {
    if ( ferror_unlocked(stream) )
    {
      v3 = gettext("read error");
      v4 = __errno_location();
      error(1, *v4, v3);
    }
    sub_80498BB((int)v8);
    result = 0;
  }
  return result;
}
// 805412C: using guessed type char byte_805412C;
// 805425D: using guessed type int dword_805425D[];
// 8054265: using guessed type int dword_8054265[];

//----- (08049D43) --------------------------------------------------------
void sub_8049D43()
{
  unsigned int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; i <= 1; ++i )
  {
    if ( ptr[i] )
    {
      sub_80498BB((int)ptr[i]);
      free(ptr[i]);
    }
  }
}

//----- (08049D90) --------------------------------------------------------
_DWORD *__cdecl sub_8049D90(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = a1;
  a1[2] = 0;
  return result;
}

//----- (08049DB2) --------------------------------------------------------
int __cdecl sub_8049DB2(FILE *stream, int a2, int a3)
{
  unsigned int i; // [esp+1Ch] [ebp-Ch]

  if ( *(_DWORD *)a2 == *(_DWORD *)(a2 + 4) )
  {
    *(_DWORD *)(a2 + 8) = sub_804D9CA(*(void **)(a2 + 8), a2 + 4, 4);
    for ( i = *(_DWORD *)a2; *(_DWORD *)(a2 + 4) > i; ++i )
      *(_DWORD *)(4 * i + *(_DWORD *)(a2 + 8)) = 0;
  }
  if ( !(unsigned __int8)sub_8049BE3(stream, 4 * *(_DWORD *)a2 + *(_DWORD *)(a2 + 8), a3) )
    return 0;
  ++*(_DWORD *)a2;
  return 1;
}

//----- (08049E5F) --------------------------------------------------------
int __cdecl sub_8049E5F(FILE *stream, int a2, int a3, int a4)
{
  if ( (_BYTE)a3 )
    *(_DWORD *)a2 = 0;
  return sub_8049DB2(stream, a2, a4);
}

//----- (08049E95) --------------------------------------------------------
void __cdecl sub_8049E95(int a1)
{
  unsigned int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; *(_DWORD *)(a1 + 4) > i; ++i )
  {
    sub_80498BB(*(_DWORD *)(4 * i + *(_DWORD *)(a1 + 8)));
    free(*(void **)(4 * i + *(_DWORD *)(a1 + 8)));
  }
  free(*(void **)(a1 + 8));
}

//----- (08049EF3) --------------------------------------------------------
char *__cdecl sub_8049EF3(unsigned int a1, int a2)
{
  char *result; // eax
  size_t n; // [esp+1Ch] [ebp-Ch]

  if ( *(_DWORD *)(a2 + 12) <= a1 )
  {
    result = s1;
    if ( s1 )
      result = (char *)fputs_unlocked(s1, stdout);
  }
  else
  {
    n = *(_DWORD *)(8 * a1 + *(_DWORD *)(a2 + 20) + 4);
    if ( n )
    {
      result = (char *)fwrite_unlocked(*(const void **)(8 * a1 + *(_DWORD *)(a2 + 20)), 1u, n, stdout);
    }
    else
    {
      result = s1;
      if ( s1 )
        result = (char *)fputs_unlocked(s1, stdout);
    }
  }
  return result;
}
// 8048F50: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (08049F95) --------------------------------------------------------
unsigned int __cdecl sub_8049F95(int a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // eax
  char v4; // al
  unsigned int result; // eax
  char v6; // [esp+17h] [ebp-11h]
  unsigned int i; // [esp+18h] [ebp-10h]
  unsigned int j; // [esp+18h] [ebp-10h]
  unsigned int v9; // [esp+1Ch] [ebp-Ch]

  if ( byte_8054291 )
    v3 = a3;
  else
    v3 = *(_DWORD *)(a1 + 12);
  v9 = v3;
  if ( c < 0 )
    v4 = 32;
  else
    v4 = c;
  v6 = v4;
  for ( i = 0; i < a2 && i < v9; ++i )
  {
    putchar_unlocked(v6);
    sub_8049EF3(i, a1);
  }
  for ( j = a2 + 1; ; ++j )
  {
    result = j;
    if ( j >= v9 )
      break;
    putchar_unlocked(v6);
    sub_8049EF3(j, a1);
  }
  return result;
}
// 8054291: using guessed type char byte_8054291;

//----- (0804A03E) --------------------------------------------------------
int __cdecl sub_804A03E(void *a1, int a2)
{
  char v2; // al
  int v3; // eax
  int result; // eax
  char v5; // [esp+1Fh] [ebp-19h]
  _DWORD *v6; // [esp+28h] [ebp-10h]

  if ( c < 0 )
    v2 = 32;
  else
    v2 = c;
  v5 = v2;
  if ( dword_80542A5 )
  {
    v6 = (_DWORD *)dword_80542A5;
    while ( 1 )
    {
      if ( *v6 )
      {
        v3 = (int)(*v6 == 1 ? a1 : a2);
        sub_8049EF3(v6[1], v3);
      }
      else if ( a1 == &unk_80542AD )
      {
        sub_8049EF3(dword_8054120, a2);
      }
      else
      {
        sub_8049EF3(dword_805411C, (int)a1);
      }
      v6 = (_DWORD *)v6[2];
      if ( !v6 )
        break;
      putchar_unlocked(v5);
    }
    result = putchar_unlocked(byte_805412C);
  }
  else
  {
    if ( a1 == &unk_80542AD )
      sub_8049EF3(dword_8054120, a2);
    else
      sub_8049EF3(dword_805411C, (int)a1);
    sub_8049F95((int)a1, dword_805411C, dword_8054295);
    sub_8049F95(a2, dword_8054120, dword_8054299);
    result = putchar_unlocked(byte_805412C);
  }
  return result;
}
// 805411C: using guessed type int dword_805411C;
// 8054120: using guessed type int dword_8054120;
// 805412C: using guessed type char byte_805412C;
// 8054295: using guessed type int dword_8054295;
// 8054299: using guessed type int dword_8054299;
// 80542A5: using guessed type int dword_80542A5;

//----- (0804A196) --------------------------------------------------------
void __cdecl sub_804A196(FILE *stream, FILE *a2)
{
  int v2; // eax
  int v3; // eax
  void *v4; // eax
  void *v5; // eax
  char v6; // [esp+15h] [ebp-43h]
  char v7; // [esp+16h] [ebp-42h]
  char v8; // [esp+17h] [ebp-41h]
  void *ptr; // [esp+18h] [ebp-40h]
  unsigned int i; // [esp+1Ch] [ebp-3Ch]
  unsigned int j; // [esp+20h] [ebp-38h]
  void *v12; // [esp+24h] [ebp-34h]
  void *v13; // [esp+28h] [ebp-30h]
  int v14; // [esp+2Ch] [ebp-2Ch]
  int v15; // [esp+30h] [ebp-28h]
  int v16; // [esp+34h] [ebp-24h]
  int v17; // [esp+38h] [ebp-20h]
  int *v18; // [esp+40h] [ebp-18h]
  int v19; // [esp+44h] [ebp-14h]
  int *v20; // [esp+4Ch] [ebp-Ch]

  sub_804B706(stream, 2);
  sub_804B706(a2, 2);
  sub_8049D90(&v17);
  sub_8049DB2(stream, (int)&v17, 1);
  sub_8049D90(&v19);
  sub_8049DB2(a2, (int)&v19, 2);
  if ( byte_8054291 )
  {
    if ( v17 )
      v2 = *(_DWORD *)(*v18 + 12);
    else
      v2 = 0;
    dword_8054295 = v2;
    if ( v19 )
      v3 = *(_DWORD *)(*v20 + 12);
    else
      v3 = 0;
    dword_8054299 = v3;
  }
  if ( byte_80542C6 && (v17 || v19) )
  {
    if ( v17 )
      v4 = (void *)*v18;
    else
      v4 = &unk_80542AD;
    v12 = v4;
    if ( v19 )
      v5 = (void *)*v20;
    else
      v5 = &unk_80542AD;
    v13 = v5;
    sub_804A03E(v12, (int)v5);
    dword_805425D[0] = 0;
    dword_8054261 = 0;
    if ( v17 )
      sub_8049E5F(stream, (int)&v17, 1, 1);
    if ( v19 )
      sub_8049E5F(a2, (int)&v19, 1, 2);
  }
  while ( v17 && v19 )
  {
    v14 = sub_80498FB(*v18, *v20, dword_805411C, dword_8054120);
    if ( v14 >= 0 )
    {
      if ( v14 <= 0 )
      {
        v6 = 0;
        while ( !((unsigned __int8)sub_8049E5F(stream, (int)&v17, 0, 1) ^ 1) )
        {
          if ( sub_80498FB(v18[v17 + 0x3FFFFFFF], *v20, dword_805411C, dword_8054120) )
            goto LABEL_35;
        }
        v6 = 1;
        ++v17;
LABEL_35:
        v7 = 0;
        while ( !((unsigned __int8)sub_8049E5F(a2, (int)&v19, 0, 2) ^ 1) )
        {
          if ( sub_80498FB(*v18, v20[v19 + 0x3FFFFFFF], dword_805411C, dword_8054120) )
            goto LABEL_39;
        }
        v7 = 1;
        ++v19;
LABEL_39:
        if ( byte_8054288 )
        {
          for ( i = 0; v17 - 1 > i; ++i )
          {
            for ( j = 0; v19 - 1 > j; ++j )
              sub_804A03E((void *)v18[i], v20[j]);
          }
        }
        if ( v6 == 1 )
        {
          v17 = 0;
        }
        else
        {
          v15 = *v18;
          *v18 = v18[v17 + 0x3FFFFFFF];
          v18[v17 + 0x3FFFFFFF] = v15;
          v17 = 1;
        }
        if ( v7 == 1 )
        {
          v19 = 0;
        }
        else
        {
          v16 = *v20;
          *v20 = v20[v19 + 0x3FFFFFFF];
          v20[v19 + 0x3FFFFFFF] = v16;
          v19 = 1;
        }
      }
      else
      {
        if ( byte_8054287 )
          sub_804A03E(&unk_80542AD, *v20);
        sub_8049E5F(a2, (int)&v19, 1, 2);
        byte_8054289 = 1;
      }
    }
    else
    {
      if ( byte_8054286 )
        sub_804A03E((void *)*v18, (int)&unk_80542AD);
      sub_8049E5F(stream, (int)&v17, 1, 1);
      byte_8054289 = 1;
    }
  }
  ptr = 0;
  v8 = 0;
  if ( dword_80542A9 != 2 && (byte_805428A[0] != 1 || byte_805428B != 1) )
    v8 = 1;
  if ( (byte_8054286 || v8) && v17 )
  {
    if ( byte_8054286 )
      sub_804A03E((void *)*v18, (int)&unk_80542AD);
    if ( v19 )
      byte_8054289 = 1;
    do
    {
      if ( !(unsigned __int8)sub_8049BE3(stream, (int)&ptr, 1) )
        break;
      if ( byte_8054286 )
        sub_804A03E(ptr, (int)&unk_80542AD);
    }
    while ( !byte_805428A[0] || byte_8054286 == 1 );
  }
  if ( (byte_8054287 || v8) && v19 )
  {
    if ( byte_8054287 )
      sub_804A03E(&unk_80542AD, *v20);
    if ( v17 )
      byte_8054289 = 1;
    do
    {
      if ( !(unsigned __int8)sub_8049BE3(a2, (int)&ptr, 2) )
        break;
      if ( byte_8054287 )
        sub_804A03E(&unk_80542AD, (int)ptr);
    }
    while ( !byte_805428B || byte_8054287 == 1 );
  }
  sub_80498BB((int)ptr);
  free(ptr);
  sub_8049E95((int)&v17);
  sub_8049E95((int)&v19);
}
// 805411C: using guessed type int dword_805411C;
// 8054120: using guessed type int dword_8054120;
// 805425D: using guessed type int dword_805425D[];
// 8054261: using guessed type int dword_8054261;
// 8054286: using guessed type char byte_8054286;
// 8054287: using guessed type char byte_8054287;
// 8054288: using guessed type char byte_8054288;
// 8054289: using guessed type char byte_8054289;
// 805428B: using guessed type char byte_805428B;
// 8054291: using guessed type char byte_8054291;
// 8054295: using guessed type int dword_8054295;
// 8054299: using guessed type int dword_8054299;
// 80542A9: using guessed type int dword_80542A9;
// 80542C6: using guessed type char byte_80542C6;

//----- (0804A7B2) --------------------------------------------------------
_DWORD *__cdecl sub_804A7B2(int a1, int a2)
{
  _DWORD *result; // eax

  if ( a1 && a1 != 1 && a1 != 2 )
    __assert_fail("file == 0 || file == 1 || file == 2", "src/join.c", 0x333u, "add_field");
  if ( !a1 && a2 )
    __assert_fail("file != 0 || field == 0", "src/join.c", 0x334u, "add_field");
  result = sub_804DA74(0xCu);
  *result = a1;
  result[1] = a2;
  result[2] = 0;
  *((_DWORD *)off_8054124 + 2) = result;
  off_8054124 = result;
  return result;
}
// 8054124: using guessed type void *off_8054124;

//----- (0804A85D) --------------------------------------------------------
int __cdecl sub_804A85D(char *nptr)
{
  void *v1; // ebx
  char *v2; // eax
  int v4; // [esp+24h] [ebp-14h]
  int v5; // [esp+28h] [ebp-10h]

  v5 = sub_804DE13(nptr, 0, 10, (int)&v4, &s);
  if ( v5 == 1 )
  {
    v4 = -1;
  }
  else if ( v5 || !v4 )
  {
    v1 = sub_804D2BE((int)nptr);
    v2 = gettext("invalid field number: %s");
    error(1, 0, v2, v1);
  }
  return v4 - 1;
}

//----- (0804A8F4) --------------------------------------------------------
void __cdecl sub_804A8F4(char *a1, _DWORD *a2, _DWORD *a3)
{
  signed int v3; // eax
  void *v4; // ebx
  char *v5; // eax
  void *v6; // ebx
  char *v7; // eax
  void *v8; // ebx
  char *v9; // eax

  v3 = *a1;
  if ( v3 == 48 )
  {
    if ( a1[1] )
    {
      v4 = sub_804D2BE((int)a1);
      v5 = gettext("invalid field specifier: %s");
      error(1, 0, v5, v4);
    }
    *a2 = 0;
    *a3 = 0;
  }
  else if ( v3 < 48 || v3 > 50 )
  {
    v8 = sub_804D2BE((int)a1);
    v9 = gettext("invalid file number in field spec: %s");
    error(1, 0, v9, v8);
  }
  else
  {
    if ( a1[1] != 46 )
    {
      v6 = sub_804D2BE((int)a1);
      v7 = gettext("invalid field specifier: %s");
      error(1, 0, v7, v6);
    }
    *a2 = *a1 - 48;
    *a3 = sub_804A85D(a1 + 2);
  }
}

//----- (0804AA19) --------------------------------------------------------
_DWORD *__cdecl sub_804AA19(char *a1)
{
  char *v1; // eax
  _DWORD *result; // eax
  int v3; // [esp+10h] [ebp-18h]
  int v4; // [esp+14h] [ebp-14h]
  char *s; // [esp+18h] [ebp-10h]
  char *v6; // [esp+1Ch] [ebp-Ch]

  s = a1;
  do
  {
    v6 = s;
    s = strpbrk(s, ", \t");
    if ( s )
    {
      v1 = s++;
      *v1 = 0;
    }
    sub_804A8F4(v6, &v3, &v4);
    result = sub_804A7B2(v3, v4);
  }
  while ( s );
  return result;
}

//----- (0804AA86) --------------------------------------------------------
_DWORD *__cdecl sub_804AA86(_DWORD *a1, int a2)
{
  int v2; // ST28_4
  char *v3; // eax
  _DWORD *result; // eax

  if ( *a1 != -1 && *a1 != a2 )
  {
    v2 = *a1 + 1;
    v3 = gettext("incompatible join fields %lu, %lu");
    error(1, 0, v3, v2, a2 + 1);
  }
  result = a1;
  *a1 = a2;
  return result;
}

//----- (0804AAF0) --------------------------------------------------------
_DWORD *__cdecl sub_804AAF0(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, signed int *a5, _DWORD *a6, _DWORD *a7)
{
  signed int v7; // eax
  void *v8; // ebx
  char *v9; // eax
  int v10; // eax
  int v11; // eax
  _DWORD *result; // eax
  bool v13; // [esp+17h] [ebp-11h]
  signed int v14; // [esp+18h] [ebp-10h]
  char *nptr; // [esp+1Ch] [ebp-Ch]

  v14 = *a5;
  if ( *a5 == 2 )
  {
    v13 = *a3 == 0;
    nptr = (char *)a2[v13];
    v7 = a3[v13];
    if ( v7 == 1 )
    {
      --*a4;
      v10 = sub_804A85D(nptr);
      sub_804AA86(&dword_805411C, v10);
    }
    else if ( v7 > 1 )
    {
      if ( v7 == 2 )
      {
        --a4[1];
        v11 = sub_804A85D(nptr);
        sub_804AA86(&dword_8054120, v11);
      }
      else if ( v7 == 3 )
      {
        sub_804AA19(nptr);
      }
    }
    else if ( !v7 )
    {
      v8 = sub_804CF2B(4, a1);
      v9 = gettext("extra operand %s");
      error(0, 0, v9, v8);
      sub_804953F(1);
    }
    if ( v13 != 1 )
    {
      *a3 = a3[1];
      *a2 = a2[1];
    }
    v14 = 1;
  }
  a3[v14] = *a6;
  a2[v14] = a1;
  *a5 = v14 + 1;
  result = (_DWORD *)*a6;
  if ( *a6 == 3 )
  {
    result = a7;
    *a7 = 3;
  }
  return result;
}
// 805411C: using guessed type int dword_805411C;
// 8054120: using guessed type int dword_8054120;

//----- (0804AC85) --------------------------------------------------------
_BOOL4 __cdecl main(int argc, char **argv)
{
  void *v2; // ebx
  char *v3; // eax
  char *v4; // eax
  int v5; // eax
  int v6; // eax
  bool v7; // ST2F_1
  int v8; // eax
  void *v9; // ebx
  char *v10; // eax
  char *v11; // eax
  int v12; // eax
  char *v13; // eax
  void *v14; // ebx
  char *v15; // eax
  FILE *v16; // eax
  void *v17; // ebx
  int *v18; // eax
  FILE *v19; // eax
  void *v20; // ebx
  int *v21; // eax
  char *v22; // ebx
  int *v23; // eax
  void *v24; // ebx
  int *v25; // eax
  void *v26; // ebx
  int *v27; // eax
  unsigned __int8 v29; // [esp+2Eh] [ebp-36h]
  int v30; // [esp+30h] [ebp-34h]
  int v31; // [esp+34h] [ebp-30h]
  int v32; // [esp+38h] [ebp-2Ch]
  int v33; // [esp+3Ch] [ebp-28h]
  int i; // [esp+40h] [ebp-24h]
  int v35; // [esp+44h] [ebp-20h]
  FILE *v36; // [esp+48h] [ebp-1Ch]
  FILE *v37; // [esp+4Ch] [ebp-18h]
  int v38; // [esp+50h] [ebp-14h]
  int v39; // [esp+58h] [ebp-Ch]
  int v40; // [esp+5Ch] [ebp-8h]

  v31 = 0;
  v39 = 0;
  v40 = 0;
  v32 = 0;
  sub_804BA65(*argv);
  setlocale(6, &s);
  bindtextdomain("coreutils", "/home/hwangdz/coreutils/coreutils-8.28/install_m32/share/locale");
  textdomain("coreutils");
  byte_8054285 = sub_804B824(3);
  sub_804F019((int)sub_804B5D1);
  sub_804F019((int)sub_8049D43);
  byte_8054288 = 1;
  byte_8054289 = 0;
  byte_805428B = 0;
  byte_805428A[0] = 0;
  dword_80542A9 = 0;
  while ( 1 )
  {
    v35 = getopt_long(argc, argv, "-a:e:i1:2:j:o:t:v:z", &longopts, 0);
    if ( v35 == -1 )
      break;
    v30 = 0;
    if ( v35 == 105 )
    {
      byte_80542C5 = 1;
      goto LABEL_70;
    }
    if ( v35 > 105 )
    {
      if ( v35 == 118 )
      {
        byte_8054288 = 0;
LABEL_28:
        if ( sub_804DE13(optarg, 0, 10, (int)&v33, &s) || v33 != 1 && v33 != 2 )
        {
          v2 = sub_804D2BE((int)optarg);
          v3 = gettext("invalid field number: %s");
          error(1, 0, v3, v2);
        }
        if ( v33 == 1 )
          byte_8054286 = 1;
        else
          byte_8054287 = 1;
        goto LABEL_70;
      }
      if ( v35 > 118 )
      {
        if ( v35 == 128 )
        {
          dword_80542A9 = 1;
        }
        else if ( v35 > 128 )
        {
          if ( v35 == 129 )
          {
            dword_80542A9 = 2;
          }
          else
          {
            if ( v35 != 130 )
              goto LABEL_69;
            byte_80542C6 = 1;
          }
        }
        else
        {
          if ( v35 != 122 )
            goto LABEL_69;
          byte_805412C = 0;
        }
      }
      else
      {
        switch ( v35 )
        {
          case 111:
            if ( !strcmp(optarg, "auto") )
            {
              byte_8054291 = 1;
            }
            else
            {
              sub_804AA19(optarg);
              v30 = 3;
            }
            break;
          case 116:
            v29 = *optarg;
            if ( *optarg )
            {
              if ( optarg[1] )
              {
                if ( !strcmp(optarg, "\\0") )
                {
                  v29 = 0;
                }
                else
                {
                  v9 = sub_804D2BE((int)optarg);
                  v10 = gettext("multi-character tab %s");
                  error(1, 0, v10, v9);
                }
              }
            }
            else
            {
              v29 = 10;
            }
            if ( c >= 0 && v29 != c )
            {
              v11 = gettext("incompatible tabs");
              error(1, 0, v11);
            }
            c = v29;
            break;
          case 106:
            if ( *optarg != 49 && *optarg != 50 || optarg[1] || argv[optind + 0x3FFFFFFF] + 2 != optarg )
            {
              v8 = sub_804A85D(optarg);
              sub_804AA86(&dword_805411C, v8);
              sub_804AA86(&dword_8054120, dword_805411C);
            }
            else
            {
              v7 = *optarg == 50;
              ++*(&v39 + v7);
              v30 = v7 + 1;
            }
            break;
          default:
            goto LABEL_69;
        }
      }
    }
    else
    {
      if ( v35 == 49 )
      {
        v5 = sub_804A85D(optarg);
        sub_804AA86(&dword_805411C, v5);
        goto LABEL_70;
      }
      if ( v35 > 49 )
      {
        switch ( v35 )
        {
          case 97:
            goto LABEL_28;
          case 101:
            if ( s1 && strcmp(s1, optarg) )
            {
              v4 = gettext("conflicting empty-field replacement strings");
              error(1, 0, v4);
            }
            s1 = optarg;
            break;
          case 50:
            v6 = sub_804A85D(optarg);
            sub_804AA86(&dword_8054120, v6);
            break;
          default:
            goto LABEL_69;
        }
      }
      else
      {
        if ( v35 == -130 )
          sub_804953F(0);
        if ( v35 != 1 )
        {
          if ( v35 == -131 )
          {
            sub_804D8C7(stdout, (int)"join", (int)"GNU coreutils", off_8054130, "Mike Haertel", 0);
            exit(0);
          }
LABEL_69:
          sub_804953F(1);
        }
        sub_804AAF0((int)optarg, &dword_8054275, &v38, &v39, &v32, &v31, &v30);
      }
    }
LABEL_70:
    v31 = v30;
  }
  v31 = 0;
  while ( optind < argc )
  {
    v12 = optind++;
    sub_804AAF0((int)argv[v12], &dword_8054275, &v38, &v39, &v32, &v31, &v30);
  }
  if ( v32 != 2 )
  {
    if ( v32 )
    {
      v14 = sub_804D2BE((int)argv[argc + 0x3FFFFFFF]);
      v15 = gettext("missing operand after %s");
      error(0, 0, v15, v14);
    }
    else
    {
      v13 = gettext("missing operand");
      error(0, 0, v13);
    }
    sub_804953F(1);
  }
  for ( i = 0; i <= 1; ++i )
  {
    if ( *(&v39 + i) )
    {
      sub_804AA86(&dword_805411C, i);
      sub_804AA86(&dword_8054120, i);
    }
  }
  if ( dword_805411C == -1 )
    dword_805411C = 0;
  if ( dword_8054120 == -1 )
    dword_8054120 = 0;
  if ( !strcmp(dword_8054275, "-") )
    v16 = (FILE *)stdin;
  else
    v16 = sub_804B74E((int)dword_8054275, "r");
  v36 = v16;
  if ( !v16 )
  {
    v17 = sub_804D086(0, 3, (int)dword_8054275);
    v18 = __errno_location();
    error(1, *v18, "%s", v17);
  }
  if ( !strcmp(dword_8054279, "-") )
    v19 = (FILE *)stdin;
  else
    v19 = sub_804B74E((int)dword_8054279, "r");
  v37 = v19;
  if ( !v19 )
  {
    v20 = sub_804D086(0, 3, (int)dword_8054279);
    v21 = __errno_location();
    error(1, *v21, "%s", v20);
  }
  if ( v36 == v37 )
  {
    v22 = gettext("both files cannot be standard input");
    v23 = __errno_location();
    error(1, *v23, v22);
  }
  sub_804A196(v36, v37);
  if ( sub_804E1E7(v36) )
  {
    v24 = sub_804D086(0, 3, (int)dword_8054275);
    v25 = __errno_location();
    error(1, *v25, "%s", v24);
  }
  if ( sub_804E1E7(v37) )
  {
    v26 = sub_804D086(0, 3, (int)dword_8054279);
    v27 = __errno_location();
    error(1, *v27, "%s", v26);
  }
  return byte_805428A[0] || byte_805428B;
}
// 805411C: using guessed type int dword_805411C;
// 8054120: using guessed type int dword_8054120;
// 805412C: using guessed type char byte_805412C;
// 80541E0: using guessed type int optind;
// 8054200: using guessed type int stdin;
// 8054285: using guessed type char byte_8054285;
// 8054286: using guessed type char byte_8054286;
// 8054287: using guessed type char byte_8054287;
// 8054288: using guessed type char byte_8054288;
// 8054289: using guessed type char byte_8054289;
// 805428B: using guessed type char byte_805428B;
// 8054291: using guessed type char byte_8054291;
// 80542A9: using guessed type int dword_80542A9;
// 80542C5: using guessed type char byte_80542C5;
// 80542C6: using guessed type char byte_80542C6;

//----- (0804B5D1) --------------------------------------------------------
int sub_804B5D1()
{
  void *v0; // ebx
  int *v1; // eax
  int *v2; // eax
  int result; // eax
  char *v4; // [esp+2Ch] [ebp-Ch]

  if ( sub_804E636(stdout) && (byte_80542CD != 1 || *__errno_location() != 32) )
  {
    v4 = gettext("write error");
    if ( dword_80542C9 )
    {
      v0 = sub_804D049(dword_80542C9);
      v1 = __errno_location();
      error(0, *v1, "%s: %s", v0, v4);
    }
    else
    {
      v2 = __errno_location();
      error(0, *v2, "%s", v4);
    }
    _exit(status);
  }
  result = sub_804E636(stderr);
  if ( result )
    _exit(status);
  return result;
}
// 80542C9: using guessed type int dword_80542C9;
// 80542CD: using guessed type char byte_80542CD;

//----- (0804B6B5) --------------------------------------------------------
int __cdecl sub_804B6B5(int a1, int a2, int a3, int a4, int a5, int a6)
{
  return posix_fadvise64(a1, a2, a3, a4, a5, a6);
}
// 80490B0: using guessed type int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804B706) --------------------------------------------------------
void __cdecl sub_804B706(FILE *stream, int a2)
{
  int v2; // eax

  if ( stream )
  {
    v2 = fileno(stream);
    sub_804B6B5(v2, 0, 0, 0, 0, a2);
  }
}

//----- (0804B74E) --------------------------------------------------------
FILE *__cdecl sub_804B74E(int a1, char *modes)
{
  int v2; // ST28_4
  int v4; // ST2C_4
  FILE *stream; // [esp+1Ch] [ebp-1Ch]
  signed int v6; // [esp+20h] [ebp-18h]
  int fd; // [esp+24h] [ebp-14h]

  stream = (FILE *)fopen64(a1, modes);
  if ( !stream )
    return stream;
  v6 = fileno(stream);
  if ( v6 < 0 || v6 > 2 )
    return stream;
  fd = sub_804D2D9(v6);
  if ( fd < 0 )
  {
    v2 = *__errno_location();
    sub_804E1E7(stream);
    *__errno_location() = v2;
    return 0;
  }
  if ( !sub_804E1E7(stream) )
  {
    stream = fdopen(fd, modes);
    if ( stream )
      return stream;
  }
  v4 = *__errno_location();
  close(fd);
  *__errno_location() = v4;
  return 0;
}
// 8048E40: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (0804B824) --------------------------------------------------------
int __cdecl sub_804B824(int category)
{
  unsigned __int8 v2; // [esp+1Bh] [ebp-Dh]
  const char *s1; // [esp+1Ch] [ebp-Ch]

  v2 = 1;
  s1 = setlocale(category, 0);
  if ( s1 && (!strcmp(s1, "C") || !strcmp(s1, "POSIX")) )
    v2 = 0;
  return v2;
}

//----- (0804B8C7) --------------------------------------------------------
int __cdecl sub_804B8C7(int a1, FILE *stream, int a3)
{
  int v4; // ST2C_4
  _BYTE *v5; // eax
  int v6; // [esp+1Ch] [ebp-1Ch]
  char *ptr; // [esp+20h] [ebp-18h]
  int v8; // [esp+24h] [ebp-14h]
  int v9; // [esp+28h] [ebp-10h]

  ptr = *(char **)(a1 + 8);
  v8 = *(_DWORD *)(a1 + 8);
  v9 = (int)&ptr[*(_DWORD *)a1];
  if ( feof_unlocked(stream) )
    return 0;
  while ( 1 )
  {
    v6 = getc_unlocked(stream);
    if ( v6 == -1 )
      break;
LABEL_9:
    if ( v8 == v9 )
    {
      v4 = *(_DWORD *)a1;
      ptr = (char *)sub_804DAED(ptr, a1);
      v8 = (int)&ptr[v4];
      *(_DWORD *)(a1 + 8) = ptr;
      v9 = (int)&ptr[*(_DWORD *)a1];
    }
    v5 = (_BYTE *)v8++;
    *v5 = v6;
    if ( (char)a3 == v6 )
      goto LABEL_12;
  }
  if ( (char *)v8 == ptr || ferror_unlocked(stream) )
    return 0;
  if ( *(_BYTE *)(v8 - 1) != (_BYTE)a3 )
  {
    v6 = (char)a3;
    goto LABEL_9;
  }
LABEL_12:
  *(_DWORD *)(a1 + 4) = v8 - (_DWORD)ptr;
  return a1;
}

//----- (0804B9E5) --------------------------------------------------------
int __cdecl sub_804B9E5(int a1, int a2, unsigned int a3)
{
  unsigned __int8 v3; // ST17_1
  unsigned int i; // [esp+18h] [ebp-20h]
  int v6; // [esp+24h] [ebp-14h]
  int v7; // [esp+28h] [ebp-10h]

  for ( i = 0; i < a3; ++i )
  {
    v3 = *(_BYTE *)(a2 + i);
    v6 = toupper(*(unsigned __int8 *)(a1 + i));
    v7 = toupper(v3);
    if ( v6 != v7 )
      return v6 - v7;
  }
  return 0;
}

//----- (0804BA65) --------------------------------------------------------
char *__cdecl sub_804BA65(char *s)
{
  char *v1; // eax
  char *result; // eax
  char *v3; // [esp+18h] [ebp-10h]
  char *s1; // [esp+1Ch] [ebp-Ch]

  if ( !s )
  {
    fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
    abort();
  }
  v3 = strrchr(s, 47);
  if ( v3 )
    v1 = v3 + 1;
  else
    v1 = s;
  s1 = v1;
  if ( v1 - s > 6 && !strncmp(v1 - 7, "/.libs/", 7u) )
  {
    s = s1;
    if ( !strncmp(s1, "lt-", 3u) )
    {
      s = s1 + 3;
      program_invocation_short_name = (int)(s1 + 3);
    }
  }
  dword_80542D1 = (int)s;
  result = s;
  program_invocation_name = (int)s;
  return result;
}
// 80541C0: using guessed type int program_invocation_short_name;
// 80541D0: using guessed type int program_invocation_name;
// 80542D1: using guessed type int dword_80542D1;

//----- (0804BBB1) --------------------------------------------------------
int __cdecl sub_804BBB1(int *a1, unsigned __int8 a2, char a3)
{
  int *v3; // eax
  int v4; // ST10_4

  if ( a1 )
    v3 = a1;
  else
    v3 = &dword_80542ED;
  v4 = ((unsigned int)v3[(a2 >> 5) + 2] >> (a2 & 0x1F)) & 1;
  v3[(a2 >> 5) + 2] ^= (v4 ^ a3 & 1) << (a2 & 0x1F);
  return v4;
}
// 80542ED: using guessed type int dword_80542ED;

//----- (0804BC5B) --------------------------------------------------------
int *__cdecl sub_804BC5B(int *a1, int a2, int a3)
{
  int *result; // eax

  if ( !a1 )
    a1 = &dword_80542ED;
  *a1 = 10;
  if ( !a2 || !a3 )
    abort();
  a1[10] = a2;
  result = a1;
  a1[11] = a3;
  return result;
}
// 80542ED: using guessed type int dword_80542ED;

//----- (0804BC9C) --------------------------------------------------------
_DWORD *__userpurge sub_804BC9C@<eax>(_DWORD *a1, int a2)
{
  int v3; // [esp+0h] [ebp-38h]
  int v4; // [esp+4h] [ebp-34h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]

  memset(&v3, 0, 0x30u);
  if ( a2 == 10 )
    abort();
  *a1 = a2;
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = v6;
  a1[4] = v7;
  a1[5] = v8;
  a1[6] = v9;
  a1[7] = v10;
  a1[8] = v11;
  a1[9] = v12;
  a1[10] = v13;
  a1[11] = v14;
  return a1;
}

//----- (0804BD1E) --------------------------------------------------------
const char *__cdecl sub_804BD1E(char *msgid, int a2)
{
  const char *result; // eax
  char *v3; // [esp+18h] [ebp-10h]
  unsigned __int8 *v4; // [esp+1Ch] [ebp-Ch]

  v3 = gettext(msgid);
  if ( v3 != msgid )
    return v3;
  v4 = (unsigned __int8 *)sub_804EB2F();
  if ( sub_804E5D1(v4, "UTF-8") )
  {
    if ( sub_804E5D1(v4, "GB18030") )
    {
      if ( a2 == 9 )
        result = (const char *)&unk_804FF65;
      else
        result = "'";
    }
    else if ( *msgid == 96 )
    {
      result = (const char *)&unk_804FF5E;
    }
    else
    {
      result = (const char *)&unk_804FF62;
    }
  }
  else if ( *msgid == 96 )
  {
    result = (const char *)&unk_804FF4E;
  }
  else
  {
    result = (const char *)&unk_804FF52;
  }
  return result;
}

//----- (0804BDB9) --------------------------------------------------------
unsigned int __cdecl sub_804BDB9(int a1, unsigned int a2, int a3, size_t a4, signed int a5, int a6, int a7, char *a8, char *a9)
{
  size_t v9; // ebx
  size_t v10; // eax
  bool v11; // al
  bool v12; // al
  unsigned int result; // eax
  char *v14; // [esp+2Ch] [ebp-5Ch]
  char *v15; // [esp+30h] [ebp-58h]
  char v16; // [esp+40h] [ebp-48h]
  bool v17; // [esp+41h] [ebp-47h]
  char v18; // [esp+42h] [ebp-46h]
  char v19; // [esp+43h] [ebp-45h]
  char v20; // [esp+44h] [ebp-44h]
  unsigned __int8 v21; // [esp+45h] [ebp-43h]
  char v22; // [esp+46h] [ebp-42h]
  char v23; // [esp+47h] [ebp-41h]
  char v24; // [esp+48h] [ebp-40h]
  char v25; // [esp+49h] [ebp-3Fh]
  bool v26; // [esp+4Ah] [ebp-3Eh]
  bool v27; // [esp+4Bh] [ebp-3Dh]
  wint_t wc; // [esp+4Ch] [ebp-3Ch]
  int v29; // [esp+50h] [ebp-38h]
  unsigned int v30; // [esp+54h] [ebp-34h]
  unsigned int v31; // [esp+58h] [ebp-30h]
  char *s; // [esp+5Ch] [ebp-2Ch]
  size_t n; // [esp+60h] [ebp-28h]
  unsigned int v34; // [esp+64h] [ebp-24h]
  unsigned int v35; // [esp+68h] [ebp-20h]
  size_t v36; // [esp+6Ch] [ebp-1Ch]
  unsigned int v37; // [esp+70h] [ebp-18h]
  mbstate_t ps; // [esp+74h] [ebp-14h]
  unsigned int v39; // [esp+7Ch] [ebp-Ch]

  v15 = a8;
  v14 = a9;
  v39 = __readgsdword(0x14u);
  v30 = 0;
  v31 = 0;
  s = 0;
  n = 0;
  v16 = 0;
  v27 = __ctype_get_mb_cur_max() == 1;
  v17 = (a6 & 2) != 0;
  v18 = 0;
  v19 = 0;
  v20 = 1;
  while ( 1 )
  {
    switch ( a5 )
    {
      case 0:
        v17 = 0;
        break;
      case 1:
        goto LABEL_20;
      case 2:
        goto LABEL_23;
      case 3:
        v16 = 1;
LABEL_20:
        v17 = 1;
        goto LABEL_21;
      case 4:
LABEL_21:
        if ( v17 != 1 )
          v16 = 1;
LABEL_23:
        a5 = 2;
        if ( v17 != 1 )
        {
          if ( v30 < a2 )
            *(_BYTE *)(a1 + v30) = 39;
          ++v30;
        }
        s = "'";
        n = 1;
        break;
      case 5:
        goto LABEL_4;
      case 6:
        a5 = 5;
        v17 = 1;
LABEL_4:
        if ( v17 != 1 )
        {
          if ( v30 < a2 )
            *(_BYTE *)(a1 + v30) = 34;
          ++v30;
        }
        v16 = 1;
        s = (char *)&unk_804FF65;
        n = 1;
        break;
      case 7:
        v16 = 1;
        v17 = 0;
        break;
      case 8:
      case 9:
      case 10:
        if ( a5 != 10 )
        {
          v15 = (char *)sub_804BD1E("`", a5);
          v14 = (char *)sub_804BD1E("'", a5);
        }
        if ( v17 != 1 )
        {
          for ( s = v15; *s; ++s )
          {
            if ( v30 < a2 )
              *(_BYTE *)(v30 + a1) = *s;
            ++v30;
          }
        }
        v16 = 1;
        s = v14;
        n = strlen(v14);
        break;
      default:
        abort();
        return result;
    }
    v29 = 0;
    while ( 1 )
    {
      v12 = a4 == -1 ? *(_BYTE *)(a3 + v29) != 0 : v29 != a4;
      if ( !v12 )
        break;
      v23 = 0;
      v24 = 0;
      v25 = 0;
      if ( v16 && a5 != 2 && n )
      {
        v9 = v29 + n;
        if ( a4 != -1 || n <= 1 )
        {
          v10 = a4;
        }
        else
        {
          v10 = strlen((const char *)a3);
          a4 = v10;
        }
        if ( v9 <= v10 && !memcmp((const void *)(v29 + a3), s, n) )
        {
          if ( v17 )
            goto LABEL_245;
          v23 = 1;
        }
      }
      v21 = *(_BYTE *)(a3 + v29);
      switch ( v21 )
      {
        case 0u:
          if ( v16 )
          {
            if ( v17 )
              goto LABEL_245;
            v24 = 1;
            if ( a5 == 2 && v18 != 1 )
            {
              if ( v30 < a2 )
                *(_BYTE *)(a1 + v30) = 39;
              if ( ++v30 < a2 )
                *(_BYTE *)(a1 + v30) = 36;
              if ( ++v30 < a2 )
                *(_BYTE *)(a1 + v30) = 39;
              ++v30;
              v18 = 1;
            }
            if ( v30 < a2 )
              *(_BYTE *)(a1 + v30) = 92;
            ++v30;
            if ( a5 != 2 && v29 + 1 < a4 && *(_BYTE *)(v29 + 1 + a3) > 47 && *(_BYTE *)(v29 + 1 + a3) <= 57 )
            {
              if ( v30 < a2 )
                *(_BYTE *)(a1 + v30) = 48;
              if ( ++v30 < a2 )
                *(_BYTE *)(a1 + v30) = 48;
              ++v30;
            }
            v21 = 48;
          }
          else if ( a6 & 1 )
          {
            goto LABEL_219;
          }
          goto LABEL_189;
        case 7u:
          v22 = 97;
          goto LABEL_103;
        case 8u:
          v22 = 98;
          goto LABEL_103;
        case 9u:
          v22 = 116;
          goto LABEL_101;
        case 0xAu:
          v22 = 110;
          goto LABEL_101;
        case 0xBu:
          v22 = 118;
          goto LABEL_103;
        case 0xCu:
          v22 = 102;
          goto LABEL_103;
        case 0xDu:
          v22 = 114;
          goto LABEL_101;
        case 0x20u:
          goto LABEL_111;
        case 0x21u:
        case 0x22u:
        case 0x24u:
        case 0x26u:
        case 0x28u:
        case 0x29u:
        case 0x2Au:
        case 0x3Bu:
        case 0x3Cu:
        case 0x3Du:
        case 0x3Eu:
        case 0x5Bu:
        case 0x5Eu:
        case 0x60u:
        case 0x7Cu:
          goto LABEL_112;
        case 0x23u:
        case 0x7Eu:
          goto LABEL_110;
        case 0x25u:
        case 0x2Bu:
        case 0x2Cu:
        case 0x2Du:
        case 0x2Eu:
        case 0x2Fu:
        case 0x30u:
        case 0x31u:
        case 0x32u:
        case 0x33u:
        case 0x34u:
        case 0x35u:
        case 0x36u:
        case 0x37u:
        case 0x38u:
        case 0x39u:
        case 0x3Au:
        case 0x41u:
        case 0x42u:
        case 0x43u:
        case 0x44u:
        case 0x45u:
        case 0x46u:
        case 0x47u:
        case 0x48u:
        case 0x49u:
        case 0x4Au:
        case 0x4Bu:
        case 0x4Cu:
        case 0x4Du:
        case 0x4Eu:
        case 0x4Fu:
        case 0x50u:
        case 0x51u:
        case 0x52u:
        case 0x53u:
        case 0x54u:
        case 0x55u:
        case 0x56u:
        case 0x57u:
        case 0x58u:
        case 0x59u:
        case 0x5Au:
        case 0x5Du:
        case 0x5Fu:
        case 0x61u:
        case 0x62u:
        case 0x63u:
        case 0x64u:
        case 0x65u:
        case 0x66u:
        case 0x67u:
        case 0x68u:
        case 0x69u:
        case 0x6Au:
        case 0x6Bu:
        case 0x6Cu:
        case 0x6Du:
        case 0x6Eu:
        case 0x6Fu:
        case 0x70u:
        case 0x71u:
        case 0x72u:
        case 0x73u:
        case 0x74u:
        case 0x75u:
        case 0x76u:
        case 0x77u:
        case 0x78u:
        case 0x79u:
        case 0x7Au:
          v25 = 1;
          goto LABEL_189;
        case 0x27u:
          v19 = 1;
          v25 = 1;
          if ( a5 != 2 )
            goto LABEL_189;
          if ( v17 )
            goto LABEL_245;
          if ( a2 && !v31 )
          {
            v31 = a2;
            a2 = 0;
          }
          if ( v30 < a2 )
            *(_BYTE *)(a1 + v30) = 39;
          if ( ++v30 < a2 )
            *(_BYTE *)(a1 + v30) = 92;
          if ( ++v30 < a2 )
            *(_BYTE *)(a1 + v30) = 39;
          ++v30;
          v18 = 0;
          goto LABEL_189;
        case 0x3Fu:
          if ( a5 == 2 )
          {
            if ( v17 )
              goto LABEL_245;
          }
          else if ( a5 == 5 && a6 & 4 && v29 + 2 < a4 && *(_BYTE *)(v29 + 1 + a3) == 63 )
          {
            switch ( *(char *)(v29 + 2 + a3) )
            {
              case 33:
              case 39:
              case 40:
              case 41:
              case 45:
              case 47:
              case 60:
              case 61:
              case 62:
                if ( v17 )
                  goto LABEL_245;
                v21 = *(_BYTE *)(v29 + 2 + a3);
                v29 += 2;
                if ( v30 < a2 )
                  *(_BYTE *)(a1 + v30) = 63;
                if ( ++v30 < a2 )
                  *(_BYTE *)(a1 + v30) = 34;
                if ( ++v30 < a2 )
                  *(_BYTE *)(a1 + v30) = 34;
                if ( ++v30 < a2 )
                  *(_BYTE *)(a1 + v30) = 63;
                ++v30;
                break;
              default:
                goto LABEL_189;
            }
          }
          goto LABEL_189;
        case 0x5Cu:
          v22 = *(_BYTE *)(a3 + v29);
          if ( a5 == 2 )
          {
            if ( v17 )
              goto LABEL_245;
          }
          else
          {
            if ( v16 && v17 && n )
              goto LABEL_208;
LABEL_101:
            if ( a5 == 2 && v17 )
              goto LABEL_245;
LABEL_103:
            if ( v16 )
            {
              v21 = v22;
            }
            else
            {
LABEL_189:
              if ( ((v16 != 1 || a5 == 2) && v17 != 1 || !a7
                                                      || !((*(_DWORD *)(4 * (v21 >> 5) + a7) >> (v21 & 0x1F)) & 1))
                && v23 != 1 )
              {
                goto LABEL_208;
              }
            }
            if ( v17 )
              goto LABEL_245;
            v24 = 1;
            if ( a5 == 2 && v18 != 1 )
            {
              if ( v30 < a2 )
                *(_BYTE *)(a1 + v30) = 39;
              if ( ++v30 < a2 )
                *(_BYTE *)(a1 + v30) = 36;
              if ( ++v30 < a2 )
                *(_BYTE *)(a1 + v30) = 39;
              ++v30;
              v18 = 1;
            }
            if ( v30 < a2 )
              *(_BYTE *)(a1 + v30) = 92;
            ++v30;
          }
LABEL_208:
          if ( v18 && v24 != 1 )
          {
            if ( v30 < a2 )
              *(_BYTE *)(a1 + v30) = 39;
            if ( ++v30 < a2 )
              *(_BYTE *)(a1 + v30) = 39;
            ++v30;
            v18 = 0;
          }
          if ( v30 < a2 )
            *(_BYTE *)(v30 + a1) = v21;
          ++v30;
          if ( v25 != 1 )
            v20 = 0;
LABEL_219:
          ++v29;
          break;
        case 0x7Bu:
        case 0x7Du:
          if ( a4 == -1 )
            v11 = *(_BYTE *)(a3 + 1) != 0;
          else
            v11 = a4 != 1;
          if ( v11 )
            goto LABEL_189;
LABEL_110:
          if ( v29 )
            goto LABEL_189;
LABEL_111:
          v25 = 1;
LABEL_112:
          if ( a5 != 2 || !v17 )
            goto LABEL_189;
          goto LABEL_245;
        default:
          if ( v27 )
          {
            v34 = 1;
            v26 = ((*__ctype_b_loc())[v21] & 0x4000) != 0;
            goto LABEL_151;
          }
          memset(&ps, 0, 8u);
          v34 = 0;
          v26 = 1;
          if ( a4 == -1 )
            a4 = strlen((const char *)a3);
          while ( 2 )
          {
            v36 = sub_804E55F((wchar_t *)&wc, (char *)(a3 + v34 + v29), a4 - (v34 + v29), &ps);
            if ( v36 )
            {
              if ( v36 == -1 )
              {
                v26 = 0;
              }
              else
              {
                if ( v36 != -2 )
                {
                  if ( v17 && a5 == 2 )
                  {
                    v35 = 1;
                    while ( v35 < v36 )
                    {
                      switch ( *(char *)(v35 + v34 + v29 + a3) )
                      {
                        case 91:
                        case 92:
                        case 94:
                        case 96:
                        case 124:
                          goto LABEL_245;
                        default:
                          ++v35;
                          break;
                      }
                    }
                  }
                  if ( !iswprint(wc) )
                    v26 = 0;
                  v34 += v36;
                  if ( mbsinit(&ps) )
                    break;
                  continue;
                }
                v26 = 0;
                while ( v29 + v34 < a4 && *(_BYTE *)(v34 + v29 + a3) )
                  ++v34;
              }
            }
            break;
          }
LABEL_151:
          v25 = v26;
          if ( v34 <= 1 && (!v16 || v26 == 1) )
            goto LABEL_189;
          v37 = v29 + v34;
          while ( 1 )
          {
            if ( v16 && v26 != 1 )
            {
              if ( v17 )
                goto LABEL_245;
              v24 = 1;
              if ( a5 == 2 && v18 != 1 )
              {
                if ( v30 < a2 )
                  *(_BYTE *)(a1 + v30) = 39;
                if ( ++v30 < a2 )
                  *(_BYTE *)(a1 + v30) = 36;
                if ( ++v30 < a2 )
                  *(_BYTE *)(a1 + v30) = 39;
                ++v30;
                v18 = 1;
              }
              if ( v30 < a2 )
                *(_BYTE *)(a1 + v30) = 92;
              if ( ++v30 < a2 )
                *(_BYTE *)(v30 + a1) = (v21 >> 6) + 48;
              if ( ++v30 < a2 )
                *(_BYTE *)(v30 + a1) = ((v21 >> 3) & 7) + 48;
              ++v30;
              v21 = (v21 & 7) + 48;
            }
            else if ( v23 )
            {
              if ( v30 < a2 )
                *(_BYTE *)(a1 + v30) = 92;
              ++v30;
              v23 = 0;
            }
            if ( v29 + 1 >= v37 )
              goto LABEL_208;
            if ( v18 && v24 != 1 )
            {
              if ( v30 < a2 )
                *(_BYTE *)(a1 + v30) = 39;
              if ( ++v30 < a2 )
                *(_BYTE *)(a1 + v30) = 39;
              ++v30;
              v18 = 0;
            }
            if ( v30 < a2 )
              *(_BYTE *)(v30 + a1) = v21;
            ++v30;
            v21 = *(_BYTE *)(a3 + ++v29);
          }
      }
    }
    if ( !v30 && a5 == 2 && v17 )
      break;
    if ( a5 != 2 || v17 == 1 || !v19 )
      goto LABEL_251;
    if ( v20 )
      return sub_804BDB9(a1, v31, a3, a4, 5, a6, a7, v15, v14);
    if ( a2 || !v31 )
    {
LABEL_251:
      if ( s && v17 != 1 )
      {
        while ( *s )
        {
          if ( v30 < a2 )
            *(_BYTE *)(v30 + a1) = *s;
          ++v30;
          ++s;
        }
      }
      if ( v30 < a2 )
        *(_BYTE *)(a1 + v30) = 0;
      return v30;
    }
    a2 = v31;
    v30 = 0;
  }
LABEL_245:
  if ( a5 == 2 && v16 )
    a5 = 4;
  return sub_804BDB9(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0, v15, v14);
}

//----- (0804CA50) --------------------------------------------------------
void *__cdecl sub_804CA50(int a1, size_t a2, _DWORD *a3, int *a4)
{
  int *v4; // eax
  int *v5; // ST3C_4
  int v6; // ST40_4
  int v7; // ST44_4
  unsigned int size; // [esp+48h] [ebp-10h]
  void *v10; // [esp+4Ch] [ebp-Ch]

  if ( a4 )
    v4 = a4;
  else
    v4 = &dword_80542ED;
  v5 = v4;
  v6 = *__errno_location();
  v7 = v5[1] | (a3 == 0);
  size = sub_804BDB9(0, 0, a1, a2, *v5, v7, (int)(v5 + 2), (char *)v5[10], (char *)v5[11]) + 1;
  v10 = sub_804DA61(size);
  sub_804BDB9((int)v10, size, a1, a2, *v5, v7, (int)(v5 + 2), (char *)v5[10], (char *)v5[11]);
  *__errno_location() = v6;
  if ( a3 )
    *a3 = size - 1;
  return v10;
}
// 80542ED: using guessed type int dword_80542ED;

//----- (0804CBF7) --------------------------------------------------------
void *__cdecl sub_804CBF7(signed int a1, int a2, size_t a3, int a4)
{
  int *v4; // eax
  void *v5; // edx
  size_t v6; // ST44_4
  bool v8; // [esp+37h] [ebp-21h]
  int *v9; // [esp+38h] [ebp-20h]
  void *ptr; // [esp+3Ch] [ebp-1Ch]
  int v11; // [esp+40h] [ebp-18h]
  int size; // [esp+44h] [ebp-14h]
  int v13; // [esp+48h] [ebp-10h]
  unsigned int v14; // [esp+4Ch] [ebp-Ch]

  v11 = *__errno_location();
  v9 = off_8054160;
  if ( a1 < 0 )
    abort();
  if ( dword_8054154 <= a1 )
  {
    v8 = off_8054160 == &dword_8054158;
    if ( (unsigned int)a1 > 0xFFFFFFE )
      sub_804DBC4();
    if ( v8 )
      v4 = 0;
    else
      v4 = off_8054160;
    v9 = (int *)sub_804DA9E(v4, 8 * (a1 + 1));
    off_8054160 = v9;
    if ( v8 )
    {
      v5 = off_805415C;
      *v9 = dword_8054158;
      v9[1] = (int)v5;
    }
    memset(&v9[2 * dword_8054154], 0, 8 * (a1 + 1 - dword_8054154));
    dword_8054154 = a1 + 1;
  }
  v6 = v9[2 * a1];
  ptr = (void *)v9[2 * a1 + 1];
  v13 = *(_DWORD *)(a4 + 4) | 1;
  v14 = sub_804BDB9(
          v9[2 * a1 + 1],
          v9[2 * a1],
          a2,
          a3,
          *(_DWORD *)a4,
          v13,
          a4 + 8,
          *(char **)(a4 + 40),
          *(char **)(a4 + 44));
  if ( v6 <= v14 )
  {
    size = v14 + 1;
    v9[2 * a1] = v14 + 1;
    if ( ptr != &unk_805432D )
      free(ptr);
    ptr = sub_804DA61(size);
    v9[2 * a1 + 1] = (int)ptr;
    sub_804BDB9((int)ptr, size, a2, a3, *(_DWORD *)a4, v13, a4 + 8, *(char **)(a4 + 40), *(char **)(a4 + 44));
  }
  *__errno_location() = v11;
  return ptr;
}
// 8054154: using guessed type int dword_8054154;
// 8054158: using guessed type int dword_8054158;
// 805415C: using guessed type void *off_805415C;
// 8054160: using guessed type int *off_8054160;

//----- (0804CE20) --------------------------------------------------------
void *__cdecl sub_804CE20(signed int a1, int a2)
{
  return sub_804CBF7(a1, a2, 0xFFFFFFFF, (int)&dword_80542ED);
}
// 80542ED: using guessed type int dword_80542ED;

//----- (0804CE4A) --------------------------------------------------------
void *__cdecl sub_804CE4A(signed int a1, int a2, size_t a3)
{
  return sub_804CBF7(a1, a2, a3, (int)&dword_80542ED);
}
// 80542ED: using guessed type int dword_80542ED;

//----- (0804CEB0) --------------------------------------------------------
void *__cdecl sub_804CEB0(signed int a1, int a2, int a3)
{
  char v4; // [esp+10h] [ebp-38h]

  sub_804BC9C(&v4, a2);
  return sub_804CBF7(a1, a3, 0xFFFFFFFF, (int)&v4);
}

//----- (0804CEEE) --------------------------------------------------------
void *__cdecl sub_804CEEE(signed int a1, int a2, int a3, size_t a4)
{
  char v5; // [esp+10h] [ebp-38h]

  sub_804BC9C(&v5, a2);
  return sub_804CBF7(a1, a3, a4, (int)&v5);
}

//----- (0804CF2B) --------------------------------------------------------
void *__cdecl sub_804CF2B(int a1, int a2)
{
  return sub_804CEB0(0, a1, a2);
}

//----- (0804CF76) --------------------------------------------------------
void *__cdecl sub_804CF76(int a1, size_t a2, unsigned __int8 a3)
{
  int v4; // [esp+20h] [ebp-38h]
  int v5; // [esp+24h] [ebp-34h]
  int v6; // [esp+28h] [ebp-30h]
  int v7; // [esp+2Ch] [ebp-2Ch]
  int v8; // [esp+30h] [ebp-28h]
  int v9; // [esp+34h] [ebp-24h]
  int v10; // [esp+38h] [ebp-20h]
  int v11; // [esp+3Ch] [ebp-1Ch]
  int v12; // [esp+40h] [ebp-18h]
  int v13; // [esp+44h] [ebp-14h]
  int v14; // [esp+48h] [ebp-10h]
  int v15; // [esp+4Ch] [ebp-Ch]

  v4 = dword_80542ED;
  v5 = dword_80542F1;
  v6 = dword_80542F5;
  v7 = dword_80542F9;
  v8 = dword_80542FD;
  v9 = dword_8054301;
  v10 = dword_8054305;
  v11 = dword_8054309;
  v12 = dword_805430D;
  v13 = dword_8054311;
  v14 = dword_8054315;
  v15 = dword_8054319;
  sub_804BBB1(&v4, a3, 1);
  return sub_804CBF7(0, a1, a2, (int)&v4);
}
// 80542ED: using guessed type int dword_80542ED;
// 80542F1: using guessed type int dword_80542F1;
// 80542F5: using guessed type int dword_80542F5;
// 80542F9: using guessed type int dword_80542F9;
// 80542FD: using guessed type int dword_80542FD;
// 8054301: using guessed type int dword_8054301;
// 8054305: using guessed type int dword_8054305;
// 8054309: using guessed type int dword_8054309;
// 805430D: using guessed type int dword_805430D;
// 8054311: using guessed type int dword_8054311;
// 8054315: using guessed type int dword_8054315;
// 8054319: using guessed type int dword_8054319;

//----- (0804D020) --------------------------------------------------------
void *__cdecl sub_804D020(int a1, unsigned __int8 a2)
{
  return sub_804CF76(a1, 0xFFFFFFFF, a2);
}

//----- (0804D049) --------------------------------------------------------
void *__cdecl sub_804D049(int a1)
{
  return sub_804D020(a1, 0x3Au);
}

//----- (0804D086) --------------------------------------------------------
void *__cdecl sub_804D086(signed int a1, int a2, int a3)
{
  int v4; // [esp+10h] [ebp-68h]
  int v5; // [esp+14h] [ebp-64h]
  int v6; // [esp+18h] [ebp-60h]
  int v7; // [esp+1Ch] [ebp-5Ch]
  int v8; // [esp+20h] [ebp-58h]
  int v9; // [esp+24h] [ebp-54h]
  int v10; // [esp+28h] [ebp-50h]
  int v11; // [esp+2Ch] [ebp-4Ch]
  int v12; // [esp+30h] [ebp-48h]
  int v13; // [esp+34h] [ebp-44h]
  int v14; // [esp+38h] [ebp-40h]
  int v15; // [esp+3Ch] [ebp-3Ch]
  int v16; // [esp+40h] [ebp-38h]
  int v17; // [esp+44h] [ebp-34h]
  int v18; // [esp+48h] [ebp-30h]
  int v19; // [esp+4Ch] [ebp-2Ch]
  int v20; // [esp+50h] [ebp-28h]
  int v21; // [esp+54h] [ebp-24h]
  int v22; // [esp+58h] [ebp-20h]
  int v23; // [esp+5Ch] [ebp-1Ch]
  int v24; // [esp+60h] [ebp-18h]
  int v25; // [esp+64h] [ebp-14h]
  int v26; // [esp+68h] [ebp-10h]
  int v27; // [esp+6Ch] [ebp-Ch]

  sub_804BC9C(&v4, a2);
  v16 = v4;
  v17 = v5;
  v18 = v6;
  v19 = v7;
  v20 = v8;
  v21 = v9;
  v22 = v10;
  v23 = v11;
  v24 = v12;
  v25 = v13;
  v26 = v14;
  v27 = v15;
  sub_804BBB1(&v16, 0x3Au, 1);
  return sub_804CBF7(a1, a3, 0xFFFFFFFF, (int)&v16);
}

//----- (0804D127) --------------------------------------------------------
void *__cdecl sub_804D127(signed int a1, int a2, int a3, int a4)
{
  return sub_804D157(a1, a2, a3, a4, 0xFFFFFFFF);
}

//----- (0804D157) --------------------------------------------------------
void *__cdecl sub_804D157(signed int a1, int a2, int a3, int a4, size_t a5)
{
  int v6; // [esp+10h] [ebp-38h]
  int v7; // [esp+14h] [ebp-34h]
  int v8; // [esp+18h] [ebp-30h]
  int v9; // [esp+1Ch] [ebp-2Ch]
  int v10; // [esp+20h] [ebp-28h]
  int v11; // [esp+24h] [ebp-24h]
  int v12; // [esp+28h] [ebp-20h]
  int v13; // [esp+2Ch] [ebp-1Ch]
  int v14; // [esp+30h] [ebp-18h]
  int v15; // [esp+34h] [ebp-14h]
  int v16; // [esp+38h] [ebp-10h]
  int v17; // [esp+3Ch] [ebp-Ch]

  v6 = dword_80542ED;
  v7 = dword_80542F1;
  v8 = dword_80542F5;
  v9 = dword_80542F9;
  v10 = dword_80542FD;
  v11 = dword_8054301;
  v12 = dword_8054305;
  v13 = dword_8054309;
  v14 = dword_805430D;
  v15 = dword_8054311;
  v16 = dword_8054315;
  v17 = dword_8054319;
  sub_804BC5B(&v6, a2, a3);
  return sub_804CBF7(a1, a4, a5, (int)&v6);
}
// 80542ED: using guessed type int dword_80542ED;
// 80542F1: using guessed type int dword_80542F1;
// 80542F5: using guessed type int dword_80542F5;
// 80542F9: using guessed type int dword_80542F9;
// 80542FD: using guessed type int dword_80542FD;
// 8054301: using guessed type int dword_8054301;
// 8054305: using guessed type int dword_8054305;
// 8054309: using guessed type int dword_8054309;
// 805430D: using guessed type int dword_805430D;
// 8054311: using guessed type int dword_8054311;
// 8054315: using guessed type int dword_8054315;
// 8054319: using guessed type int dword_8054319;

//----- (0804D251) --------------------------------------------------------
void *__cdecl sub_804D251(signed int a1, int a2, size_t a3)
{
  return sub_804CBF7(a1, a2, a3, (int)&unk_8054174);
}

//----- (0804D29C) --------------------------------------------------------
void *__cdecl sub_804D29C(signed int a1, int a2)
{
  return sub_804D251(a1, a2, 0xFFFFFFFF);
}

//----- (0804D2BE) --------------------------------------------------------
void *__cdecl sub_804D2BE(int a1)
{
  return sub_804D29C(0, a1);
}

//----- (0804D2D9) --------------------------------------------------------
int __cdecl sub_804D2D9(int fd)
{
  return sub_804E2AA(fd, 0, 3);
}

//----- (0804D2FC) --------------------------------------------------------
int __cdecl sub_804D2FC(FILE *stream, int a2, int a3, int a4, int a5, int a6)
{
  char *v6; // eax
  char *v7; // eax
  int v8; // ebx
  char *v9; // eax
  int result; // eax
  int v11; // esi
  int v12; // ebx
  char *v13; // eax
  int v14; // edi
  int v15; // esi
  int v16; // ebx
  char *v17; // eax
  int v18; // ST4C_4
  int v19; // edi
  int v20; // esi
  int v21; // ebx
  char *v22; // eax
  int v23; // ST4C_4
  int v24; // ST48_4
  int v25; // edi
  int v26; // esi
  int v27; // ebx
  char *v28; // eax
  int v29; // ST4C_4
  int v30; // ST48_4
  int v31; // ST44_4
  int v32; // edi
  int v33; // esi
  int v34; // ebx
  char *v35; // eax
  int v36; // esi
  int v37; // ST4C_4
  int v38; // ST48_4
  int v39; // ST44_4
  int v40; // ST40_4
  int v41; // edi
  int v42; // ebx
  char *v43; // eax
  int v44; // edi
  int v45; // ST4C_4
  int v46; // ST48_4
  int v47; // ST44_4
  int v48; // ST40_4
  int v49; // ST3C_4
  int v50; // esi
  int v51; // ebx
  char *v52; // eax
  int v53; // edi
  int v54; // ST4C_4
  int v55; // ST48_4
  int v56; // ST44_4
  int v57; // ST40_4
  int v58; // ST3C_4
  int v59; // ST38_4
  int v60; // esi
  int v61; // ebx
  char *v62; // eax
  int v63; // edi
  int v64; // ST4C_4
  int v65; // ST48_4
  int v66; // ST44_4
  int v67; // ST40_4
  int v68; // ST3C_4
  int v69; // ST38_4
  int v70; // esi
  int v71; // ebx
  char *v72; // eax

  if ( a2 )
    fprintf(stream, "%s (%s) %s\n", a2, a3, a4);
  else
    fprintf(stream, "%s %s\n", a3, a4);
  v6 = gettext("(C)");
  fprintf(stream, "Copyright %s %d Free Software Foundation, Inc.", v6, 2017);
  v7 = gettext(
         "\n"
         "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\n"
         "This is free software: you are free to change and redistribute it.\n"
         "There is NO WARRANTY, to the extent permitted by law.\n"
         "\n");
  fputs_unlocked(v7, stream);
  switch ( a6 )
  {
    case 0:
      abort();
      return result;
    case 1:
      v8 = *(_DWORD *)a5;
      v9 = gettext("Written by %s.\n");
      result = fprintf(stream, v9, v8);
      break;
    case 2:
      v11 = *(_DWORD *)(a5 + 4);
      v12 = *(_DWORD *)a5;
      v13 = gettext("Written by %s and %s.\n");
      result = fprintf(stream, v13, v12, v11);
      break;
    case 3:
      v14 = *(_DWORD *)(a5 + 8);
      v15 = *(_DWORD *)(a5 + 4);
      v16 = *(_DWORD *)a5;
      v17 = gettext("Written by %s, %s, and %s.\n");
      result = fprintf(stream, v17, v16, v15, v14);
      break;
    case 4:
      v18 = *(_DWORD *)(a5 + 12);
      v19 = *(_DWORD *)(a5 + 8);
      v20 = *(_DWORD *)(a5 + 4);
      v21 = *(_DWORD *)a5;
      v22 = gettext("Written by %s, %s, %s,\nand %s.\n");
      result = fprintf(stream, v22, v21, v20, v19, v18);
      break;
    case 5:
      v23 = *(_DWORD *)(a5 + 16);
      v24 = *(_DWORD *)(a5 + 12);
      v25 = *(_DWORD *)(a5 + 8);
      v26 = *(_DWORD *)(a5 + 4);
      v27 = *(_DWORD *)a5;
      v28 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
      result = fprintf(stream, v28, v27, v26, v25, v24, v23);
      break;
    case 6:
      v29 = *(_DWORD *)(a5 + 20);
      v30 = *(_DWORD *)(a5 + 16);
      v31 = *(_DWORD *)(a5 + 12);
      v32 = *(_DWORD *)(a5 + 8);
      v33 = *(_DWORD *)(a5 + 4);
      v34 = *(_DWORD *)a5;
      v35 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
      result = fprintf(stream, v35, v34, v33, v32, v31, v30, v29);
      break;
    case 7:
      v36 = *(_DWORD *)(a5 + 24);
      v37 = *(_DWORD *)(a5 + 20);
      v38 = *(_DWORD *)(a5 + 16);
      v39 = *(_DWORD *)(a5 + 12);
      v40 = *(_DWORD *)(a5 + 8);
      v41 = *(_DWORD *)(a5 + 4);
      v42 = *(_DWORD *)a5;
      v43 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
      result = fprintf(stream, v43, v42, v41, v40, v39, v38, v37, v36);
      break;
    case 8:
      v44 = *(_DWORD *)(a5 + 28);
      v45 = *(_DWORD *)(a5 + 24);
      v46 = *(_DWORD *)(a5 + 20);
      v47 = *(_DWORD *)(a5 + 16);
      v48 = *(_DWORD *)(a5 + 12);
      v49 = *(_DWORD *)(a5 + 8);
      v50 = *(_DWORD *)(a5 + 4);
      v51 = *(_DWORD *)a5;
      v52 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
      result = fprintf(stream, v52, v51, v50, v49, v48, v47, v46, v45, v44);
      break;
    case 9:
      v53 = *(_DWORD *)(a5 + 32);
      v54 = *(_DWORD *)(a5 + 28);
      v55 = *(_DWORD *)(a5 + 24);
      v56 = *(_DWORD *)(a5 + 20);
      v57 = *(_DWORD *)(a5 + 16);
      v58 = *(_DWORD *)(a5 + 12);
      v59 = *(_DWORD *)(a5 + 8);
      v60 = *(_DWORD *)(a5 + 4);
      v61 = *(_DWORD *)a5;
      v62 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
      result = fprintf(stream, v62, v61, v60, v59, v58, v57, v56, v55, v54, v53);
      break;
    default:
      v63 = *(_DWORD *)(a5 + 32);
      v64 = *(_DWORD *)(a5 + 28);
      v65 = *(_DWORD *)(a5 + 24);
      v66 = *(_DWORD *)(a5 + 20);
      v67 = *(_DWORD *)(a5 + 16);
      v68 = *(_DWORD *)(a5 + 12);
      v69 = *(_DWORD *)(a5 + 8);
      v70 = *(_DWORD *)(a5 + 4);
      v71 = *(_DWORD *)a5;
      v72 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
      result = fprintf(stream, v72, v71, v70, v69, v68, v67, v66, v65, v64, v63);
      break;
  }
  return result;
}
// 8048F50: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804D861) --------------------------------------------------------
int __cdecl sub_804D861(FILE *stream, int a2, int a3, int a4, int a5)
{
  int *v5; // eax
  unsigned int i; // [esp+24h] [ebp-34h]
  int v8[12]; // [esp+28h] [ebp-30h]

  for ( i = 0; i <= 9; ++i )
  {
    v5 = (int *)a5;
    a5 += 4;
    v8[i] = *v5;
    if ( !v8[i] )
      break;
  }
  return sub_804D2FC(stream, a2, a3, a4, (int)v8, i);
}
// 804D861: using guessed type int var_30[12];

//----- (0804D8C7) --------------------------------------------------------
int sub_804D8C7(FILE *stream, int a2, int a3, int a4, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a4);
  return sub_804D861(stream, a2, a3, a4, (int)va);
}

//----- (0804D9CA) --------------------------------------------------------
void *__cdecl sub_804D9CA(void *ptr, int a2, int a3)
{
  unsigned int v4; // [esp+1Ch] [ebp-Ch]

  v4 = *(_DWORD *)a2;
  if ( ptr )
  {
    if ( 0x55555554u / a3 <= v4 )
      sub_804DBC4();
    v4 += (v4 >> 1) + 1;
  }
  else
  {
    if ( !v4 )
      v4 = (0x40u / a3 == 0) + 0x40u / a3;
    if ( 0x7FFFFFFFu / a3 < v4 )
      sub_804DBC4();
  }
  *(_DWORD *)a2 = v4;
  return sub_804DA9E(ptr, a3 * v4);
}

//----- (0804DA61) --------------------------------------------------------
void *__cdecl sub_804DA61(size_t size)
{
  return sub_804DA74(size);
}

//----- (0804DA74) --------------------------------------------------------
void *__cdecl sub_804DA74(size_t size)
{
  void *v2; // [esp+1Ch] [ebp-Ch]

  v2 = malloc(size);
  if ( !v2 && size )
    sub_804DBC4();
  return v2;
}

//----- (0804DA9E) --------------------------------------------------------
void *__cdecl sub_804DA9E(void *ptr, size_t size)
{
  void *result; // eax
  void *ptra; // [esp+20h] [ebp+8h]

  if ( size || !ptr )
  {
    ptra = realloc(ptr, size);
    if ( !ptra )
    {
      if ( size )
        sub_804DBC4();
    }
    result = ptra;
  }
  else
  {
    free(ptr);
    result = 0;
  }
  return result;
}

//----- (0804DAED) --------------------------------------------------------
void *__cdecl sub_804DAED(void *ptr, int a2)
{
  return sub_804D9CA(ptr, a2, 1);
}

//----- (0804DB39) --------------------------------------------------------
void *__cdecl sub_804DB39(size_t nmemb, size_t size)
{
  void *v3; // [esp+1Ch] [ebp-Ch]

  if ( 0x7FFFFFFF / size < nmemb || (v3 = calloc(nmemb, size)) == 0 )
    sub_804DBC4();
  return v3;
}

//----- (0804DB76) --------------------------------------------------------
void *__cdecl sub_804DB76(void *src, size_t n)
{
  void *v2; // eax

  v2 = sub_804DA74(n);
  return memcpy(v2, src, n);
}

//----- (0804DBC4) --------------------------------------------------------
void __noreturn sub_804DBC4()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (0804DBFD) --------------------------------------------------------
void __cdecl sub_804DBFD(int errnum, int a2, int a3, int a4, int a5)
{
  char *v5; // eax
  char *v6; // eax
  void *v7; // esi
  void *v8; // ebx
  char *v9; // eax

  v5 = gettext("string comparison failed");
  error(0, errnum, v5);
  v6 = gettext("Set LC_ALL='C' to work around the problem.");
  error(0, 0, v6);
  v7 = sub_804CEEE(1, 8, a4, a5);
  v8 = sub_804CEEE(0, 8, a2, a3);
  v9 = gettext("The strings compared were %s and %s.");
  error(status, 0, v9, v8, v7);
}

//----- (0804DCC9) --------------------------------------------------------
int __cdecl sub_804DCC9(void *s1, size_t n, void *s2, int a4)
{
  int v5; // [esp+28h] [ebp-10h]
  int errnum; // [esp+2Ch] [ebp-Ch]

  v5 = sub_804EC8F(s1, n, s2, a4);
  errnum = *__errno_location();
  if ( errnum )
    sub_804DBFD(errnum, (int)s1, n, (int)s2, a4);
  return v5;
}

//----- (0804DD99) --------------------------------------------------------
signed int __cdecl sub_804DD99(unsigned int *a1, unsigned int a2)
{
  signed int result; // eax

  if ( 0xFFFFFFFF / a2 >= *a1 )
  {
    *a1 *= a2;
    result = 0;
  }
  else
  {
    *a1 = -1;
    result = 1;
  }
  return result;
}

//----- (0804DDDD) --------------------------------------------------------
int __cdecl sub_804DDDD(unsigned int *a1, unsigned int a2, int a3)
{
  int v3; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; i |= sub_804DD99(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}

//----- (0804DE13) --------------------------------------------------------
int __cdecl sub_804DE13(char *nptr, int a2, int base, int a4, char *s)
{
  char **v5; // eax
  int result; // eax
  int v7; // eax
  unsigned __int8 i; // [esp+1Fh] [ebp-29h]
  char v9; // [esp+20h] [ebp-28h]
  unsigned int v10; // [esp+24h] [ebp-24h]
  int v11; // [esp+28h] [ebp-20h]
  char *v12; // [esp+2Ch] [ebp-1Ch]
  unsigned int v13; // [esp+30h] [ebp-18h]
  int v14; // [esp+34h] [ebp-14h]
  int v15; // [esp+38h] [ebp-10h]
  char **endptr; // [esp+3Ch] [ebp-Ch]

  v11 = 0;
  if ( base < 0 || base > 36 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoul");
  if ( a2 )
    v5 = (char **)a2;
  else
    v5 = (char **)&v9;
  endptr = v5;
  *__errno_location() = 0;
  v12 = nptr;
  for ( i = *nptr; (*__ctype_b_loc())[i] & 0x2000; i = *v12 )
    ++v12;
  if ( i == 45 )
    return 4;
  v10 = strtoul(nptr, endptr, base);
  if ( *endptr == nptr )
  {
    if ( !s || !**endptr || !strchr(s, **endptr) )
      return 4;
    v10 = 1;
  }
  else if ( *__errno_location() )
  {
    if ( *__errno_location() != 34 )
      return 4;
    v11 = 1;
  }
  if ( !s )
  {
    *(_DWORD *)a4 = v10;
    return v11;
  }
  if ( !**endptr )
  {
LABEL_53:
    *(_DWORD *)a4 = v10;
    return v11;
  }
  v13 = 1024;
  v14 = 1;
  if ( !strchr(s, **endptr) )
  {
    *(_DWORD *)a4 = v10;
    return v11 | 2;
  }
  switch ( **endptr )
  {
    case 69:
    case 71:
    case 75:
    case 77:
    case 80:
    case 84:
    case 89:
    case 90:
    case 103:
    case 107:
    case 109:
    case 116:
      if ( strchr(s, 48) )
      {
        v7 = (*endptr)[1];
        switch ( v7 )
        {
          case 68:
            goto LABEL_56;
          case 105:
            if ( (*endptr)[2] == 66 )
              v14 += 2;
            goto LABEL_37;
          case 66:
LABEL_56:
            v13 = 1000;
            ++v14;
            break;
        }
      }
      break;
    default:
      break;
  }
LABEL_37:
  switch ( **endptr )
  {
    case 66:
      v15 = sub_804DD99(&v10, 0x400u);
      goto LABEL_51;
    case 69:
      v15 = sub_804DDDD(&v10, v13, 6);
      goto LABEL_51;
    case 71:
    case 103:
      v15 = sub_804DDDD(&v10, v13, 3);
      goto LABEL_51;
    case 75:
    case 107:
      v15 = sub_804DDDD(&v10, v13, 1);
      goto LABEL_51;
    case 77:
    case 109:
      v15 = sub_804DDDD(&v10, v13, 2);
      goto LABEL_51;
    case 80:
      v15 = sub_804DDDD(&v10, v13, 5);
      goto LABEL_51;
    case 84:
    case 116:
      v15 = sub_804DDDD(&v10, v13, 4);
      goto LABEL_51;
    case 89:
      v15 = sub_804DDDD(&v10, v13, 8);
      goto LABEL_51;
    case 90:
      v15 = sub_804DDDD(&v10, v13, 7);
      goto LABEL_51;
    case 98:
      v15 = sub_804DD99(&v10, 0x200u);
      goto LABEL_51;
    case 99:
      v15 = 0;
      goto LABEL_51;
    case 119:
      v15 = sub_804DD99(&v10, 2u);
LABEL_51:
      v11 |= v15;
      *endptr += v14;
      if ( **endptr )
        v11 |= 2u;
      goto LABEL_53;
    default:
      *(_DWORD *)a4 = v10;
      result = v11 | 2;
      break;
  }
  return result;
}

//----- (0804E1E7) --------------------------------------------------------
int __cdecl sub_804E1E7(FILE *stream)
{
  int v2; // eax
  __int64 v3; // rax
  int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]

  v4 = 0;
  if ( fileno(stream) < 0 )
    return fclose(stream);
  if ( !__freading(stream) || (v2 = fileno(stream), LODWORD(v3) = lseek64(v2, 0, 0, 1), v3 != -1) )
  {
    if ( sub_804E44D(stream) )
      v4 = *__errno_location();
  }
  v5 = fclose(stream);
  if ( v4 )
  {
    *__errno_location() = v4;
    v5 = -1;
  }
  return v5;
}
// 8049090: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804E2AA) --------------------------------------------------------
int __cdecl sub_804E2AA(int fd, int cmd, char a3)
{
  int v3; // ST28_4
  int v5; // [esp+1Ch] [ebp-1Ch]
  char v6; // [esp+20h] [ebp-18h]
  int v7; // [esp+24h] [ebp-14h]

  if ( cmd != 1030 )
    return fcntl(fd, cmd, a3);
  v6 = a3;
  if ( dword_805442D < 0 )
  {
    v5 = sub_804E2AA(fd, 0, a3);
  }
  else
  {
    v5 = fcntl(fd, 1030, a3);
    if ( v5 < 0 && *__errno_location() == 22 )
    {
      v5 = sub_804E2AA(fd, 0, v6);
      if ( v5 < 0 )
        return v5;
      dword_805442D = -1;
    }
    else
    {
      dword_805442D = 1;
    }
  }
  if ( v5 >= 0 && dword_805442D == -1 )
  {
    v7 = fcntl(v5, 1);
    if ( v7 < 0 || fcntl(v5, 2, v7 | 1) == -1 )
    {
      v3 = *__errno_location();
      close(v5);
      *__errno_location() = v3;
      v5 = -1;
    }
  }
  return v5;
}
// 805442D: using guessed type int dword_805442D;

//----- (0804E414) --------------------------------------------------------
int __cdecl sub_804E414(FILE *stream)
{
  int result; // eax

  result = stream->_flags & 0x100;
  if ( result )
    result = sub_804E48D(stream, 0, 0, 1);
  return result;
}

//----- (0804E44D) --------------------------------------------------------
int __cdecl sub_804E44D(FILE *fp)
{
  if ( !fp || !__freading(fp) )
    return fflush(fp);
  sub_804E414(fp);
  return fflush(fp);
}

//----- (0804E48D) --------------------------------------------------------
int __cdecl sub_804E48D(FILE *stream, int a2, int a3, int a4)
{
  int v4; // eax
  __off64_t v5; // rax

  if ( stream->_IO_read_end != stream->_IO_read_ptr
    || stream->_IO_write_ptr != stream->_IO_write_base
    || stream->_IO_save_base )
  {
    return fseeko64(stream, a2, a3, a4);
  }
  v4 = fileno(stream);
  LODWORD(v5) = lseek64(v4, a2, a3, a4);
  if ( v5 == -1 )
    return -1;
  stream->_flags &= 0xFFFFFFEF;
  stream->_offset = v5;
  return 0;
}
// 8048DF0: using guessed type int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8049090: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804E55F) --------------------------------------------------------
size_t __cdecl sub_804E55F(wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  char v5; // [esp+18h] [ebp-10h]
  size_t v6; // [esp+1Ch] [ebp-Ch]

  if ( !pwc )
    pwc = (wchar_t *)&v5;
  v6 = mbrtowc(pwc, s, n, p);
  if ( v6 <= 0xFFFFFFFD || !n || !((unsigned __int8)sub_804B824(0) ^ 1) )
    return v6;
  *pwc = (unsigned __int8)*s;
  return 1;
}

//----- (0804E5D1) --------------------------------------------------------
int __cdecl sub_804E5D1(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // esi
  unsigned __int8 *v3; // ebx
  unsigned __int8 v5; // [esp+1Eh] [ebp-Ah]
  unsigned __int8 v6; // [esp+1Fh] [ebp-9h]

  v2 = a1;
  v3 = a2;
  if ( a1 == a2 )
    return 0;
  do
  {
    v5 = sub_804EF6B(*v2);
    v6 = sub_804EF6B(*v3);
    if ( !v5 )
      break;
    ++v2;
    ++v3;
  }
  while ( v5 == v6 );
  return v5 - v6;
}

//----- (0804E636) --------------------------------------------------------
int __cdecl sub_804E636(FILE *fp)
{
  bool v1; // ST1E_1
  bool v3; // [esp+1Dh] [ebp-Bh]
  bool v4; // [esp+1Fh] [ebp-9h]

  v3 = __fpending(fp) != 0;
  v1 = ferror_unlocked(fp) != 0;
  v4 = sub_804E1E7(fp) != 0;
  if ( !v1 && (!v4 || !v3 && *__errno_location() == 9) )
    return 0;
  if ( v4 != 1 )
    *__errno_location() = 0;
  return -1;
}

//----- (0804E6B7) --------------------------------------------------------
void *sub_804E6B7()
{
  _BOOL4 v0; // eax
  void *v2; // [esp+18h] [ebp-B0h]
  const char *s; // [esp+1Ch] [ebp-ACh]
  void *v4; // [esp+20h] [ebp-A8h]
  int v5; // [esp+24h] [ebp-A4h]
  size_t n; // [esp+2Ch] [ebp-9Ch]
  size_t v7; // [esp+30h] [ebp-98h]
  _BOOL4 v8; // [esp+34h] [ebp-94h]
  char *dest; // [esp+38h] [ebp-90h]
  int fd; // [esp+3Ch] [ebp-8Ch]
  FILE *stream; // [esp+40h] [ebp-88h]
  int c; // [esp+44h] [ebp-84h]
  int ca; // [esp+44h] [ebp-84h]
  size_t v14; // [esp+48h] [ebp-80h]
  size_t v15; // [esp+4Ch] [ebp-7Ch]
  void *v16; // [esp+50h] [ebp-78h]
  char src; // [esp+56h] [ebp-72h]
  char v18; // [esp+89h] [ebp-3Fh]
  unsigned int v19; // [esp+BCh] [ebp-Ch]

  v19 = __readgsdword(0x14u);
  v2 = (void *)dword_8054431;
  if ( !dword_8054431 )
  {
    s = getenv("CHARSETALIASDIR");
    if ( !s || !*s )
      s = "/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib";
    n = strlen(s);
    v7 = strlen("charset.alias");
    v0 = n && s[n - 1] != 47;
    v8 = v0;
    dest = (char *)malloc(n + v0 + v7 + 1);
    if ( dest )
    {
      memcpy(dest, s, n);
      if ( v8 )
        dest[n] = 47;
      memcpy(&dest[n + v8], "charset.alias", v7 + 1);
    }
    free(0);
    if ( dest )
    {
      fd = open64(dest, 0x20000);
      if ( fd >= 0 )
      {
        stream = fdopen(fd, "r");
        if ( stream )
        {
          v4 = 0;
          v5 = 0;
          while ( 1 )
          {
            c = getc_unlocked(stream);
            if ( c == -1 )
              break;
            if ( c != 10 && c != 32 && c != 9 )
            {
              if ( c == 35 )
              {
                do
                  ca = getc_unlocked(stream);
                while ( ca != -1 && ca != 10 );
                if ( ca == -1 )
                  break;
              }
              else
              {
                ungetc(c, stream);
                if ( fscanf(stream, "%50s %50s", &src, &v18) <= 1 )
                  break;
                v14 = strlen(&src);
                v15 = strlen(&v18);
                v16 = v4;
                if ( v5 )
                {
                  v5 += v15 + v14 + 2;
                  v4 = realloc(v4, v5 + 1);
                }
                else
                {
                  v5 = v14 + v15 + 2;
                  v4 = malloc(v14 + v15 + 3);
                }
                if ( !v4 )
                {
                  v5 = 0;
                  free(v16);
                  break;
                }
                strcpy((char *)v4 + v5 - v15 - v14 - 2, &src);
                strcpy((char *)v4 + v5 - v15 - 1, &v18);
              }
            }
          }
          sub_804E1E7(stream);
          if ( v5 )
          {
            *((_BYTE *)v4 + v5) = 0;
            v2 = v4;
          }
          else
          {
            v2 = &unk_80508C7;
          }
        }
        else
        {
          close(fd);
          v2 = &unk_80508C7;
        }
      }
      else
      {
        v2 = &unk_80508C7;
      }
      free(dest);
    }
    else
    {
      v2 = &unk_80508C7;
    }
    dword_8054431 = (int)v2;
  }
  return v2;
}
// 8048D60: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 8054431: using guessed type int dword_8054431;

//----- (0804EB2F) --------------------------------------------------------
const char *sub_804EB2F()
{
  char *v0; // ST1C_4
  const char *s1; // [esp+18h] [ebp-10h]
  char *s2; // [esp+1Ch] [ebp-Ch]

  s1 = nl_langinfo(14);
  if ( !s1 )
    s1 = (const char *)&unk_80508C7;
  for ( s2 = (char *)sub_804E6B7(); *s2; s2 = &v0[strlen(v0) + 1] )
  {
    if ( !strcmp(s1, s2) || *s2 == 42 && !s2[1] )
    {
      s1 = &s2[strlen(s2) + 1];
      break;
    }
    v0 = &s2[strlen(s2) + 1];
  }
  if ( !*s1 )
    s1 = "ASCII";
  return s1;
}

//----- (0804EBE2) --------------------------------------------------------
int __cdecl sub_804EBE2(char *s, int a2, char *s2, int a4)
{
  size_t v4; // ST18_4
  size_t v5; // ST1C_4
  _BOOL4 v7; // eax
  int v8; // [esp+14h] [ebp-14h]

  while ( 1 )
  {
    *__errno_location() = 0;
    v8 = strcoll(s, s2);
    v7 = v8 || *__errno_location();
    if ( v7 )
      break;
    v4 = strlen(s) + 1;
    v5 = strlen(s2) + 1;
    s += v4;
    s2 += v5;
    a2 -= v4;
    a4 -= v5;
    if ( !a2 )
      return -(a4 != 0);
    if ( !a4 )
      return 1;
  }
  return v8;
}

//----- (0804EC8F) --------------------------------------------------------
int __cdecl sub_804EC8F(void *s1, size_t n, void *s2, int a4)
{
  char v4; // ST1A_1
  char v5; // ST1B_1
  int v7; // [esp+1Ch] [ebp-Ch]

  if ( n == a4 && !memcmp(s1, s2, n) )
  {
    *__errno_location() = 0;
    v7 = 0;
  }
  else
  {
    v4 = *((_BYTE *)s1 + n);
    v5 = *((_BYTE *)s2 + a4);
    *((_BYTE *)s1 + n) = 0;
    *((_BYTE *)s2 + a4) = 0;
    v7 = sub_804EBE2((char *)s1, n + 1, (char *)s2, a4 + 1);
    *((_BYTE *)s1 + n) = v4;
    *((_BYTE *)s2 + a4) = v5;
  }
  return v7;
}

//----- (0804ED4A) --------------------------------------------------------
int __cdecl sub_804ED4A(void *s1, size_t n, void *s2, int a4)
{
  if ( n != a4 || memcmp(s1, s2, n) )
    return sub_804EBE2((char *)s1, n, (char *)s2, a4);
  *__errno_location() = 0;
  return 0;
}

//----- (0804EF6B) --------------------------------------------------------
int __cdecl sub_804EF6B(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 65) > 0x19 )
    result = a1;
  else
    result = a1 + 32;
  return result;
}

//----- (0804F019) --------------------------------------------------------
int __cdecl sub_804F019(int a1)
{
  return __cxa_atexit(a1, 0, dword_8054118);
}
// 8048EB0: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 8054118: using guessed type int dword_8054118;

//----- (0804F040) --------------------------------------------------------
int (**sub_804F040())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_8053F04;
  v1 = &off_8053F08 - off_8053F04;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_8053F04[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 8053F04: using guessed type int (*off_8053F04[2])();
// 8053F08: using guessed type int (*off_8053F08)();

//----- (0804F0A4) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 1 decompilation failure(s) on 101 function(s)"
