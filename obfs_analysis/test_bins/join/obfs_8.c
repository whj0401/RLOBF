/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8048D40();
// int strcmp(const char *s1, const char *s2);
// int __cdecl open64(_DWORD, _DWORD); weak
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void _exit(int status);
// void free(void *ptr);
// void *memcpy(void *dest, const void *src, size_t n);
// int fclose(FILE *stream);
// int getc_unlocked(FILE *stream);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// char *textdomain(const char *domainname);
// int __cdecl fopen64(_DWORD, _DWORD); weak
// int ferror_unlocked(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// size_t __ctype_get_mb_cur_max(void);
// size_t __fpending(FILE *fp);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// void error(int status, int errnum, const char *format, ...);
// int strcoll(const char *s1, const char *s2);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// char *strchr(const char *s, int c);
// size_t strlen(const char *s);
// int fprintf(FILE *stream, const char *format, ...);
// int fcntl(int fd, int cmd, ...);
// void *memset(void *s, int c, size_t n);
// int *__errno_location(void);
// void *memchr(const void *s, int c, size_t n);
// int fileno(FILE *stream);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// char *strpbrk(const char *s, const char *accept);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// int toupper(int c);
// char *strrchr(const char *s, int c);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// char *bindtextdomain(const char *domainname, const char *dirname);
// int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// int feof_unlocked(FILE *stream);
// void abort(void);
// int close(int fd);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// void *calloc(size_t nmemb, size_t size);
// int putchar_unlocked(int c);
// int _gmon_start__(void); weak
void sub_8049183();
void sub_80491A0();
int sub_80491B0();
int sub_8049220();
int sub_8049240();
void sub_804929F();
void sub_80492BA();
int sub_80492CA();
void sub_80493AC();
void sub_80493C7();
signed int sub_80493D7();
void sub_80494B9();
void sub_80494D4();
int sub_80494E4();
void sub_80495C6();
void sub_80495E1();
int sub_80495F1();
void sub_80496D3();
void sub_80496EE();
int sub_80496FE(void); // weak
int nullsub_3(void); // weak
int sub_8049775();
int sub_80497BA();
void sub_804982E();
void sub_8049849();
int nullsub_4(void); // weak
int sub_80498D0();
void sub_8049970();
void sub_804998B();
int sub_804999B();
void sub_8049A7D();
void sub_8049A98();
int sub_8049AA8();
// int __usercall sub_8049B0F@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
void sub_8049BA6();
void sub_8049BC1();
int sub_8049BD1(void); // weak
int sub_8049C74();
void sub_8049CE8();
void sub_8049D03();
int sub_8049D13();
// int __usercall sub_8049D7A@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
void sub_8049E1B();
void sub_8049E36();
int sub_8049E46();
int sub_8049ED0();
// int __usercall sub_8049F11@<eax>(void (__cdecl *a1)(int *)@<eax>);
void sub_8049F67();
void sub_8049F82();
int sub_8049F92();
int nullsub_7(void); // weak
int sub_8049FF0();
void sub_804A090();
void sub_804A0AB();
int sub_804A0BB();
void sub_804A1B9();
void sub_804A1D4();
int sub_804A1E4();
void sub_804A2D8();
void sub_804A305();
// int __usercall sub_804A395@<eax>(int a1@<eax>, int (__cdecl *a2)(signed int, int)@<edx>);
void sub_804A461();
void sub_804A47C();
int sub_804A48C();
int nullsub_9(void); // weak
int sub_804A4EA();
void sub_804A5A3();
void sub_804A5CC();
signed int sub_804A5EA();
int nullsub_10(); // weak
// int __usercall sub_804A648@<eax>(int a1@<ebp>);
signed int sub_804A6A6();
int __cdecl sub_804A708(unsigned __int8 a1);
int __cdecl sub_804A76D(char *s1); // idb
void __cdecl __noreturn sub_804A90C(int status); // idb
int __cdecl sub_804AA93(int a1, int a2, int a3);
unsigned __int8 *__cdecl sub_804AB0D(int a1);
int __cdecl sub_804ACFC(int a1);
int __cdecl sub_804AD3C(int a1, int a2, unsigned int a3, unsigned int a4);
int __cdecl sub_804AEF5(int a1, int a2, int a3);
int __cdecl sub_804B062(int a1);
void *__cdecl sub_804B071(_DWORD *a1);
int __cdecl sub_804B0BD(FILE *stream, int, int); // idb
void sub_804B22B();
_DWORD *__cdecl sub_804B29E(_DWORD *a1);
int __cdecl sub_804B2C0(FILE *stream, int, int); // idb
int __cdecl sub_804B3A5(FILE *stream, int, int, int); // idb
void __cdecl sub_804B406(int a1);
char *__cdecl sub_804B530(unsigned int a1, unsigned int a2, size_t a3);
char *__cdecl sub_804B927(unsigned int a1, int a2);
// void __usercall sub_804BA28(int a1@<ebx>, FILE *stream, FILE *a3);
void __cdecl __noreturn sub_804D9F0(_DWORD, _DWORD); // weak
int __cdecl sub_804DADD(char *nptr); // idb
_DWORD __cdecl sub_804DB8D(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl sub_804DDB0(_DWORD, _DWORD); // weak
_DWORD *__cdecl sub_804DE43(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, signed int *a5, _DWORD *a6, _DWORD *a7);
_BOOL4 __cdecl main(int argc, char **argv);
void __noreturn sub_804EAFA(); // weak
int __cdecl sub_804EC2E(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_804EC7F(FILE *stream, int); // idb
FILE *__cdecl sub_804ECF2(int a1, char *modes);
int __cdecl sub_804EDDA(int category); // idb
int __cdecl sub_804EE7D(int, FILE *stream, int); // idb
int __cdecl sub_804EFD1(int a1, int a2, unsigned int a3);
char *__cdecl sub_804F063(char *s);
int __cdecl sub_804F1EF(int *a1, unsigned __int8 a2, char a3);
int *__cdecl sub_804F2C2(int *a1, int a2, int a3);
// _DWORD *__userpurge sub_804F303@<eax>(_DWORD *a1, int a2);
char *__cdecl sub_804F385(char *msgid);
unsigned int __cdecl sub_804F465(int a1, unsigned int a2, int a3, size_t a4, int a5, int a6, int a7, char *a8, char *a9);
void *__cdecl sub_80503B7(int a1, size_t a2, _DWORD *a3, int a4);
void *__cdecl sub_805057D(signed int a1, int a2, size_t a3, int a4);
void *__cdecl sub_80507A6(signed int a1, int a2);
void *__cdecl sub_80507D0(signed int a1, int a2, size_t a3);
void *__cdecl sub_8050846(signed int a1, int a2, int a3);
void *__cdecl sub_8050884(signed int a1, int a2, int a3, size_t a4);
void *__cdecl sub_80508C1(int a1, int a2);
void *__cdecl sub_805090C(int a1, size_t a2, unsigned __int8 a3);
void *__cdecl sub_80509C6(int a1, unsigned __int8 a2);
void *__cdecl sub_80509EF(int a1);
void *__cdecl sub_8050A2C(signed int a1, int a2, int a3);
void *__cdecl sub_8050ADD(signed int a1, int a2, int a3, int a4);
void *__cdecl sub_8050B0D(signed int a1, int a2, int a3, int a4, size_t a5);
void *__cdecl sub_8050C19(signed int a1, int a2, size_t a3);
void *__cdecl sub_8050C64(signed int a1, int a2);
void *__cdecl sub_8050C86(int a1);
int __cdecl sub_8050CA1(int fd); // idb
int __cdecl sub_8050CC4(FILE *stream, int, int, int, int, int); // idb
int __cdecl sub_8051233(FILE *stream, int, int, int, int); // idb
int sub_80512A6(FILE *stream, int a2, int a3, int a4, ...);
void *__cdecl sub_80513A9(void *ptr, int a2, int a3);
void *__cdecl sub_8051452(size_t size);
void *__cdecl sub_8051465(size_t size);
void *__cdecl sub_80514A8(void *ptr, size_t size);
void *__cdecl sub_8051548(void *ptr, int a2);
void *__cdecl sub_80515A2(size_t nmemb, size_t size);
void *__cdecl sub_80515DF(void *src, size_t n);
void __noreturn sub_805162D();
void __cdecl sub_8051666(int errnum, int a2, int a3, int a4, int a5);
int __cdecl sub_8051732(void *a1, int a2, void *a3, int a4);
signed int __cdecl sub_8051802(unsigned int *a1, unsigned int a2);
int __cdecl sub_8051846(unsigned int *a1, unsigned int a2, int a3);
int __cdecl sub_805188A(char *nptr, int, int base, int, char *s); // idb
int __cdecl sub_8051D01(FILE *stream); // idb
int __cdecl sub_8051DD2(int fd, int cmd, char a3, int a4);
int __cdecl sub_8051F89(FILE *stream); // idb
int __cdecl sub_8051FE9(FILE *fp); // idb
int __cdecl sub_8052042(FILE *stream, int, int, int); // idb
size_t __cdecl sub_805214A(wchar_t *pwc, char *s, size_t n, mbstate_t *p);
int __cdecl sub_80521D5(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_8052272(FILE *fp); // idb
int __fastcall __noreturn sub_805231E(int a1);
int sub_80528A1(); // weak
void __noreturn sub_80528AA();
int __cdecl sub_80529C8(char *s1, int a2, char *s2);
int __cdecl sub_8052AA3(void *s1, size_t n, void *s2, int a4);
int __cdecl sub_8052B79(void *s1, size_t n, void *s2, int); // idb
int __cdecl sub_8052E19(int a1);
int __cdecl sub_8052ED9(int a1);
int __stdcall sub_80530F0(_DWORD); // weak
int __stdcall sub_8053179(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int sub_80531E5(void); // weak
int sub_805324D(void); // weak
int sub_80532E9(void); // weak
int __stdcall sub_8053376(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int sub_80533FB(void); // weak
int __stdcall sub_805346B(_DWORD); // weak
int __cdecl sub_80534D5();
int __stdcall sub_805354B(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_80535C1(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __fastcall sub_8053629(_DWORD); // weak
int __stdcall sub_8053699(_DWORD); // weak
int (**sub_80536B0())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_8049E72; // weak
_UNKNOWN loc_804A749; // weak
_UNKNOWN loc_804A74F; // weak
_UNKNOWN loc_804A768; // weak
_UNKNOWN loc_804A8DB; // weak
_UNKNOWN loc_804A8E2; // weak
_UNKNOWN loc_804AA88; // weak
_UNKNOWN loc_804AB57; // weak
_UNKNOWN loc_804ABC6; // weak
_UNKNOWN loc_804AC7A; // weak
_UNKNOWN loc_804AC89; // weak
_UNKNOWN loc_804ACB9; // weak
_UNKNOWN loc_804ACCE; // weak
_UNKNOWN loc_804ACDA; // weak
_UNKNOWN locret_804ACFA; // weak
_UNKNOWN loc_804ADA1; // weak
_UNKNOWN loc_804ADF0; // weak
_UNKNOWN loc_804AE0F; // weak
_UNKNOWN loc_804AF6C; // weak
_UNKNOWN loc_804B26E; // weak
_UNKNOWN loc_804B292; // weak
_UNKNOWN loc_804B296; // weak
_UNKNOWN loc_804B36B; // weak
_UNKNOWN loc_804B39E; // weak
_UNKNOWN locret_804B3A3; // weak
_UNKNOWN loc_804B3D0; // weak
_UNKNOWN loc_804B3EB; // weak
_UNKNOWN locret_804B640; // weak
_UNKNOWN loc_804B644; // weak
_UNKNOWN loc_804B72E; // weak
_UNKNOWN locret_804B9D4; // weak
_UNKNOWN loc_804BBC9; // weak
_UNKNOWN locret_804BC96; // weak
_UNKNOWN loc_804BC9A; // weak
_UNKNOWN loc_804BDAE; // weak
_UNKNOWN locret_804BDC5; // weak
_UNKNOWN loc_804BDC9; // weak
_UNKNOWN loc_804BE1B; // weak
_UNKNOWN loc_804BF2D; // weak
_UNKNOWN loc_804C03B; // weak
_UNKNOWN loc_804C07C; // weak
_UNKNOWN loc_804C1BA; // weak
_UNKNOWN loc_804C225; // weak
_UNKNOWN loc_804C27D; // weak
_UNKNOWN loc_804C2A6; // weak
_UNKNOWN loc_804C375; // weak
_UNKNOWN locret_804C3AE; // weak
_UNKNOWN loc_804C3B2; // weak
_UNKNOWN loc_804C40B; // weak
_UNKNOWN loc_804C41B; // weak
_UNKNOWN loc_804C44A; // weak
_UNKNOWN locret_804C4F7; // weak
_UNKNOWN loc_804C4FB; // weak
_UNKNOWN loc_804C54D; // weak
_UNKNOWN loc_804C57F; // weak
_UNKNOWN loc_804C60C; // weak
_UNKNOWN loc_804C735; // weak
_UNKNOWN loc_804C75E; // weak
_UNKNOWN loc_804C7D8; // weak
_UNKNOWN loc_804C80B; // weak
_UNKNOWN loc_804C85E; // weak
_UNKNOWN loc_804C997; // weak
_UNKNOWN loc_804C9E9; // weak
_UNKNOWN loc_804C9ED; // weak
_UNKNOWN loc_804CA84; // weak
_UNKNOWN loc_804CAC3; // weak
_UNKNOWN loc_804CB0A; // weak
_UNKNOWN loc_804CB2A; // weak
_UNKNOWN loc_804CB5F; // weak
_UNKNOWN loc_804CB83; // weak
_UNKNOWN loc_804CBDF; // weak
_UNKNOWN loc_804CC42; // weak
_UNKNOWN loc_804CCDA; // weak
_UNKNOWN locret_804CD20; // weak
_UNKNOWN loc_804CD24; // weak
_UNKNOWN loc_804CD5B; // weak
_UNKNOWN loc_804CEA9; // weak
_UNKNOWN loc_804D221; // weak
_UNKNOWN loc_804D245; // weak
_UNKNOWN loc_804D264; // weak
_UNKNOWN loc_804D2A2; // weak
_UNKNOWN loc_804D349; // weak
_UNKNOWN loc_804D3CD; // weak
_UNKNOWN locret_804D406; // weak
_UNKNOWN loc_804D40A; // weak
_UNKNOWN loc_804D463; // weak
_UNKNOWN loc_804D480; // weak
_UNKNOWN loc_804D48E; // weak
_UNKNOWN loc_804D4EA; // weak
_UNKNOWN loc_804D51D; // weak
_UNKNOWN loc_804D57C; // weak
_UNKNOWN loc_804D5CE; // weak
_UNKNOWN loc_804D5EE; // weak
_UNKNOWN loc_804D5FA; // weak
_UNKNOWN loc_804D609; // weak
_UNKNOWN loc_804D9BD; // weak
_UNKNOWN loc_804DB30; // weak
_UNKNOWN loc_804DB39; // weak
_UNKNOWN loc_804DEB7; // weak
_UNKNOWN loc_804DED4; // weak
_UNKNOWN loc_804DED9; // weak
_UNKNOWN loc_804DF05; // weak
_UNKNOWN loc_804E11A; // weak
_UNKNOWN loc_804E148; // weak
_UNKNOWN loc_804E166; // weak
_UNKNOWN loc_804E194; // weak
_UNKNOWN loc_804E1BB; // weak
_UNKNOWN loc_804E1C0; // weak
_UNKNOWN loc_804E277; // weak
_UNKNOWN loc_804E3B0; // weak
_UNKNOWN loc_804E5F5; // weak
_UNKNOWN loc_804E63D; // weak
_UNKNOWN loc_804E76F; // weak
_UNKNOWN loc_804E795; // weak
_UNKNOWN loc_804E839; // weak
_UNKNOWN loc_804E877; // weak
_UNKNOWN loc_804E881; // weak
_UNKNOWN loc_804E8C3; // weak
_UNKNOWN loc_804E969; // weak
_UNKNOWN loc_804E9AB; // weak
_UNKNOWN loc_804EA6D; // weak
_UNKNOWN loc_804EAAF; // weak
_UNKNOWN loc_804ECA4; // weak
_UNKNOWN locret_804ECDE; // weak
_UNKNOWN loc_804EF05; // weak
_UNKNOWN loc_804EF0F; // weak
_UNKNOWN loc_804F10D; // weak
_UNKNOWN loc_804F143; // weak
_UNKNOWN loc_804F526; // weak
_UNKNOWN loc_804F53D; // weak
_UNKNOWN loc_804F580; // weak
_UNKNOWN loc_804F5AC; // weak
_UNKNOWN loc_804F6BC; // weak
_UNKNOWN loc_804F6D5; // weak
_UNKNOWN loc_804F764; // weak
_UNKNOWN loc_804F769; // weak
_UNKNOWN loc_804F89C; // weak
_UNKNOWN loc_804F8A1; // weak
_UNKNOWN loc_804F91A; // weak
_UNKNOWN loc_804F95F; // weak
_UNKNOWN loc_804F964; // weak
_UNKNOWN loc_804F9D7; // weak
_UNKNOWN loc_804FA6E; // weak
_UNKNOWN loc_804FA7F; // weak
_UNKNOWN loc_804FA9E; // weak
_UNKNOWN loc_804FAAA; // weak
_UNKNOWN loc_804FAF3; // weak
_UNKNOWN loc_804FB02; // weak
_UNKNOWN loc_804FB58; // weak
_UNKNOWN loc_804FB67; // weak
_UNKNOWN loc_804FC5F; // weak
_UNKNOWN loc_804FC6D; // weak
_UNKNOWN loc_804FCDA; // weak
_UNKNOWN loc_804FCE3; // weak
_UNKNOWN loc_804FDC3; // weak
_UNKNOWN loc_804FF3A; // weak
_UNKNOWN loc_804FF6C; // weak
_UNKNOWN loc_804FF9D; // weak
_UNKNOWN loc_804FFC7; // weak
_UNKNOWN loc_804FFD2; // weak
_UNKNOWN loc_8050028; // weak
_UNKNOWN loc_805002D; // weak
_UNKNOWN loc_805004C; // weak
_UNKNOWN loc_8050051; // weak
_UNKNOWN loc_80500C6; // weak
_UNKNOWN loc_80501B8; // weak
_UNKNOWN loc_8050201; // weak
_UNKNOWN loc_805028D; // weak
_UNKNOWN loc_80503DB; // weak
_UNKNOWN loc_80511D3; // weak
_UNKNOWN loc_8051253; // weak
_UNKNOWN loc_8051498; // weak
_UNKNOWN loc_80514A3; // weak
_UNKNOWN loc_80514CD; // weak
_UNKNOWN loc_80514F2; // weak
_UNKNOWN loc_805153E; // weak
_UNKNOWN loc_8051543; // weak
_UNKNOWN locret_8051546; // weak
_UNKNOWN loc_8051988; // weak
_UNKNOWN loc_80519AD; // weak
_UNKNOWN loc_80519D4; // weak
_UNKNOWN loc_8051A55; // weak
_UNKNOWN loc_8051B01; // weak
_UNKNOWN loc_8051B2B; // weak
_UNKNOWN loc_8051B31; // weak
_UNKNOWN loc_8051B33; // weak
_UNKNOWN loc_8051CF4; // weak
_UNKNOWN locret_8051CFF; // weak
_UNKNOWN loc_8051E55; // weak
_UNKNOWN loc_8051E6E; // weak
_UNKNOWN loc_8051EBF; // weak
_UNKNOWN loc_8051F84; // weak
_UNKNOWN loc_8051FB6; // weak
_UNKNOWN locret_8051FE7; // weak
_UNKNOWN loc_805201D; // weak
_UNKNOWN loc_805202A; // weak
_UNKNOWN loc_805207D; // weak
_UNKNOWN loc_80520FC; // weak
_UNKNOWN loc_8052103; // weak
_UNKNOWN loc_8052128; // weak
_UNKNOWN loc_805216F; // weak
_UNKNOWN loc_8052175; // weak
_UNKNOWN loc_805222F; // weak
_UNKNOWN loc_805223E; // weak
_UNKNOWN loc_805225F; // weak
_UNKNOWN loc_8052360; // weak
_UNKNOWN loc_80523FA; // weak
_UNKNOWN loc_8052419; // weak
_UNKNOWN loc_80524F5; // weak
_UNKNOWN loc_805250E; // weak
_UNKNOWN loc_805258A; // weak
_UNKNOWN loc_80525A7; // weak
_UNKNOWN loc_8052858; // weak
_UNKNOWN loc_8052866; // weak
_UNKNOWN loc_8052871; // weak
_UNKNOWN loc_805289C; // weak
_UNKNOWN loc_80528DE; // weak
_UNKNOWN loc_80528E5; // weak
_UNKNOWN loc_80529D0; // weak
_UNKNOWN loc_8052A9E; // weak
_UNKNOWN loc_8052B74; // weak
_UNKNOWN unk_80537D0; // weak
char s = '\0'; // idb
struct option longopts = { "ignore-case", 0, NULL, 105 }; // idb
_UNKNOWN unk_8054655; // weak
_UNKNOWN unk_8054FB7; // weak
_UNKNOWN unk_80551BC; // weak
_UNKNOWN unk_80551BF; // weak
int dword_8055EF8 = 67108864; // weak
_UNKNOWN unk_8056204; // weak
_UNKNOWN unk_8056207; // weak
int (*off_8058EC4[2])() = { &sub_8049240, &sub_8049220 }; // weak
int (*off_8058EC8)() = &sub_8049220; // weak
int (*dword_8059008)(void) = NULL; // weak
int dword_8059114 = 0; // weak
int dword_8059128 = 0; // weak
int dword_805913C = 0; // weak
int dword_8059150 = 0; // weak
int dword_8059164 = 0; // weak
int dword_8059178 = 0; // weak
int dword_805918C = 0; // weak
int dword_80591A0 = 0; // weak
int dword_80591B4 = 0; // weak
int dword_80591C8 = 0; // weak
int dword_80591DC = 0; // weak
int dword_80591F0 = 0; // weak
int dword_8059204 = 0; // weak
int dword_8059240 = 0; // weak
int dword_8059244 = 4294967295; // weak
int dword_8059248 = 4294967295; // weak
int c = 4294967295; // idb
char byte_8059254 = '\n'; // weak
int off_8059258 = 134563058; // idb
int status = 1; // idb
int dword_805927C = 1; // weak
int dword_8059280 = 256; // weak
void *off_8059284 = &unk_805991D; // weak
int *off_8059288 = &dword_8059280; // weak
_UNKNOWN unk_805929C; // weak
_UNKNOWN unk_80592B8; // weak
_UNKNOWN unk_80592BB; // weak
_UNKNOWN unk_80592C0; // weak
_UNKNOWN unk_80592C3; // weak
_UNKNOWN unk_80592CC; // weak
_UNKNOWN unk_80592CF; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int program_invocation_name; // weak
int optind; // weak
int stdin; // weak
FILE *stdout; // idb
char *optarg; // idb
char byte_805932C; // weak
char byte_80594AD; // weak
_UNKNOWN unk_80594FE; // weak
char byte_80595E1; // weak
char byte_805967B; // weak
char byte_8059849; // weak
int dword_805984D[]; // weak
int dword_8059855[]; // weak
int dword_8059859[2]; // idb
char *dword_8059865; // idb
char *dword_8059869; // idb
void *ptr[2]; // idb
char byte_8059875; // weak
char byte_8059876; // weak
char byte_8059877; // weak
char byte_8059878; // weak
char byte_8059879; // weak
char byte_805987A[]; // weak
char byte_805987B; // weak
char *s1; // idb
char byte_8059881; // weak
int dword_8059885; // weak
int dword_8059889; // weak
int dword_8059895; // weak
int dword_8059899; // weak
_UNKNOWN unk_805989D; // weak
char byte_80598B5; // weak
char byte_80598B6; // weak
int dword_80598C1; // weak
int dword_80598DD; // weak
int dword_80598E1; // weak
int dword_80598E5; // weak
int dword_80598E9; // weak
int dword_80598ED; // weak
int dword_80598F1; // weak
int dword_80598F5; // weak
int dword_80598F9; // weak
int dword_80598FD; // weak
int dword_8059901; // weak
int dword_8059905; // weak
int dword_8059909; // weak
_UNKNOWN unk_805991D; // weak
int dword_8059A1D; // weak
int dword_8059A21; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (08048D18) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 8049140: using guessed type int _gmon_start__(void);

//----- (08048D40) --------------------------------------------------------
int sub_8048D40()
{
  return dword_8059008();
}
// 8059008: using guessed type int (*dword_8059008)(void);

//----- (08049150) --------------------------------------------------------
#error "8049153: positive sp value has been found (funcsize=2)"

//----- (08049183) --------------------------------------------------------
void sub_8049183()
{
  ;
}

//----- (080491A0) --------------------------------------------------------
void sub_80491A0()
{
  ;
}

//----- (080491B0) --------------------------------------------------------
int sub_80491B0()
{
  int result; // eax

  result = &unk_80592CF - &unk_80592CC;
  if ( (unsigned int)(&unk_80592CF - &unk_80592CC) > 6 )
    result = 0;
  return result;
}
// 80491B0: could not find valid save-restore pair for ebp

//----- (08049220) --------------------------------------------------------
int sub_8049220()
{
  int result; // eax

  if ( !byte_805932C )
  {
    result = sub_80491B0();
    byte_805932C = 1;
  }
  return result;
}
// 8049220: could not find valid save-restore pair for ebp
// 805932C: using guessed type char byte_805932C;

//----- (08049240) --------------------------------------------------------
int sub_8049240()
{
  return 0;
}
// 8049240: could not find valid save-restore pair for ebp

//----- (0804929F) --------------------------------------------------------
void sub_804929F()
{
  ;
}

//----- (080492BA) --------------------------------------------------------
void sub_80492BA()
{
  ;
}

//----- (080492CA) --------------------------------------------------------
int sub_80492CA()
{
  int result; // eax

  result = &unk_80592BB - &unk_80592B8;
  if ( (unsigned int)(&unk_80592BB - &unk_80592B8) > 6 )
    result = 0;
  return result;
}
// 80492CA: could not find valid save-restore pair for ebp

//----- (080493AC) --------------------------------------------------------
void sub_80493AC()
{
  ;
}

//----- (080493C7) --------------------------------------------------------
void sub_80493C7()
{
  ;
}

//----- (080493D7) --------------------------------------------------------
signed int sub_80493D7()
{
  return 3;
}
// 80493D7: could not find valid save-restore pair for ebp

//----- (080494B9) --------------------------------------------------------
void sub_80494B9()
{
  ;
}

//----- (080494D4) --------------------------------------------------------
void sub_80494D4()
{
  ;
}

//----- (080494E4) --------------------------------------------------------
int sub_80494E4()
{
  int result; // eax

  result = &unk_80592BB - &unk_80592B8;
  if ( (unsigned int)(&unk_80592BB - &unk_80592B8) > 6 )
    result = 0;
  return result;
}
// 80494E4: could not find valid save-restore pair for ebp

//----- (080495C6) --------------------------------------------------------
void sub_80495C6()
{
  ;
}

//----- (080495E1) --------------------------------------------------------
void sub_80495E1()
{
  ;
}

//----- (080495F1) --------------------------------------------------------
int sub_80495F1()
{
  int result; // eax

  result = &unk_80592BB - &unk_80592B8;
  if ( (unsigned int)(&unk_80592BB - &unk_80592B8) > 6 )
    result = 0;
  return result;
}
// 80495F1: could not find valid save-restore pair for ebp

//----- (080496D3) --------------------------------------------------------
void sub_80496D3()
{
  ;
}

//----- (080496EE) --------------------------------------------------------
void sub_80496EE()
{
  ;
}

//----- (080496FE) --------------------------------------------------------
#error "804972B: call analysis failed (funcsize=23)"

//----- (08049775) --------------------------------------------------------
int sub_8049775()
{
  return nullsub_3();
}
// 8049775: could not find valid save-restore pair for ebp
// 8049774: using guessed type int nullsub_3(void);

//----- (080497BA) --------------------------------------------------------
int sub_80497BA()
{
  int result; // eax

  result = sub_80496FE();
  byte_80594AD = 1;
  return result;
}
// 80496FE: using guessed type int sub_80496FE(void);
// 80594AD: using guessed type char byte_80594AD;

//----- (0804982E) --------------------------------------------------------
void sub_804982E()
{
  ;
}

//----- (08049849) --------------------------------------------------------
void sub_8049849()
{
  ;
}

//----- (08049859) --------------------------------------------------------
#error "8049886: call analysis failed (funcsize=23)"

//----- (080498D0) --------------------------------------------------------
int sub_80498D0()
{
  return nullsub_4();
}
// 80498D0: could not find valid save-restore pair for ebp
// 80498CF: using guessed type int nullsub_4(void);

//----- (08049970) --------------------------------------------------------
void sub_8049970()
{
  ;
}

//----- (0804998B) --------------------------------------------------------
void sub_804998B()
{
  ;
}

//----- (0804999B) --------------------------------------------------------
int sub_804999B()
{
  int result; // eax

  result = &unk_80594FE - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_80594FE - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 804999B: could not find valid save-restore pair for ebp
// 80592E0: using guessed type int program_invocation_short_name;

//----- (08049A7D) --------------------------------------------------------
void sub_8049A7D()
{
  ;
}

//----- (08049A98) --------------------------------------------------------
void sub_8049A98()
{
  ;
}

//----- (08049AA8) --------------------------------------------------------
int sub_8049AA8()
{
  int result; // eax

  result = &unk_80592BB - &unk_80592B8;
  if ( (unsigned int)(&unk_80592BB - &unk_80592B8) > 6 )
    result = 0;
  return result;
}
// 8049AA8: could not find valid save-restore pair for ebp

//----- (08049B0F) --------------------------------------------------------
int __usercall sub_8049B0F@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_80592B8, a1);
}

//----- (08049BA6) --------------------------------------------------------
void sub_8049BA6()
{
  ;
}

//----- (08049BC1) --------------------------------------------------------
void sub_8049BC1()
{
  ;
}

//----- (08049BD1) --------------------------------------------------------
#error "8049BFE: call analysis failed (funcsize=23)"

//----- (08049C74) --------------------------------------------------------
int sub_8049C74()
{
  int result; // eax

  result = sub_8049BD1();
  byte_80595E1 = 1;
  return result;
}
// 8049BD1: using guessed type int sub_8049BD1(void);
// 80595E1: using guessed type char byte_80595E1;

//----- (08049CE8) --------------------------------------------------------
void sub_8049CE8()
{
  ;
}

//----- (08049D03) --------------------------------------------------------
void sub_8049D03()
{
  ;
}

//----- (08049D13) --------------------------------------------------------
int sub_8049D13()
{
  int result; // eax

  result = &unk_8056207 - &unk_8056204;
  if ( (unsigned int)(&unk_8056207 - &unk_8056204) > 6 )
    result = 0;
  return result;
}
// 8049D13: could not find valid save-restore pair for ebp

//----- (08049D7A) --------------------------------------------------------
int __usercall sub_8049D7A@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_8056204, a1);
}

//----- (08049E1B) --------------------------------------------------------
void sub_8049E1B()
{
  ;
}

//----- (08049E36) --------------------------------------------------------
void sub_8049E36()
{
  ;
}

//----- (08049E46) --------------------------------------------------------
int sub_8049E46()
{
  int result; // eax

  result = &unk_80592BB - &unk_80592B8;
  if ( (unsigned int)(&unk_80592BB - &unk_80592B8) > 6 )
    result = 0;
  return result;
}
// 8049E46: could not find valid save-restore pair for ebp

//----- (08049ED0) --------------------------------------------------------
int sub_8049ED0()
{
  int result; // eax

  result = sub_8049E46();
  byte_805967B = 1;
  return result;
}
// 805967B: using guessed type char byte_805967B;

//----- (08049F11) --------------------------------------------------------
int __usercall sub_8049F11@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  int v2; // ecx

  a1(&dword_8055EF8);
  dword_8059128 = (int)&loc_8049E72;
  sub_8053629(v2);
  return 0;
}
// 8053629: using guessed type int __fastcall sub_8053629(_DWORD);
// 8055EF8: using guessed type int dword_8055EF8;
// 8059128: using guessed type int dword_8059128;

//----- (08049F67) --------------------------------------------------------
void sub_8049F67()
{
  ;
}

//----- (08049F82) --------------------------------------------------------
void sub_8049F82()
{
  ;
}

//----- (08049F92) --------------------------------------------------------
int sub_8049F92()
{
  int result; // eax

  result = &unk_80592BB - &unk_80592B8;
  if ( (unsigned int)(&unk_80592BB - &unk_80592B8) > 6 )
    result = 0;
  return result;
}
// 8049F92: could not find valid save-restore pair for ebp

//----- (08049FF0) --------------------------------------------------------
int sub_8049FF0()
{
  return nullsub_7();
}
// 8049FF0: could not find valid save-restore pair for ebp
// 8049FEF: using guessed type int nullsub_7(void);

//----- (0804A090) --------------------------------------------------------
void sub_804A090()
{
  ;
}

//----- (0804A0AB) --------------------------------------------------------
void sub_804A0AB()
{
  ;
}

//----- (0804A0BB) --------------------------------------------------------
int sub_804A0BB()
{
  int result; // eax

  result = &unk_80592BB - &unk_80592B8;
  if ( (unsigned int)(&unk_80592BB - &unk_80592B8) > 6 )
    result = 0;
  return result;
}
// 804A0BB: could not find valid save-restore pair for ebp

//----- (0804A1B9) --------------------------------------------------------
void sub_804A1B9()
{
  ;
}

//----- (0804A1D4) --------------------------------------------------------
void sub_804A1D4()
{
  ;
}

//----- (0804A1E4) --------------------------------------------------------
int sub_804A1E4()
{
  int result; // eax

  result = &unk_80551BF - &unk_80551BC;
  if ( (unsigned int)(&unk_80551BF - &unk_80551BC) > 6 )
    result = 0;
  return result;
}
// 804A1E4: could not find valid save-restore pair for ebp

//----- (0804A2D8) --------------------------------------------------------
void sub_804A2D8()
{
  ;
}

//----- (0804A305) --------------------------------------------------------
void sub_804A305()
{
  ;
}

//----- (0804A315) --------------------------------------------------------
#error "804A342: call analysis failed (funcsize=23)"

//----- (0804A395) --------------------------------------------------------
int __usercall sub_804A395@<eax>(int a1@<eax>, int (__cdecl *a2)(signed int, int)@<edx>)
{
  return a2(134565376, a1);
}

//----- (0804A461) --------------------------------------------------------
void sub_804A461()
{
  ;
}

//----- (0804A47C) --------------------------------------------------------
void sub_804A47C()
{
  ;
}

//----- (0804A48C) --------------------------------------------------------
int sub_804A48C()
{
  int result; // eax

  result = &unk_80592C3 - &unk_80592C0;
  if ( (unsigned int)(&unk_80592C3 - &unk_80592C0) > 6 )
    result = 0;
  return result;
}
// 804A48C: could not find valid save-restore pair for ebp

//----- (0804A4EA) --------------------------------------------------------
int sub_804A4EA()
{
  return nullsub_9();
}
// 804A4EA: could not find valid save-restore pair for ebp
// 804A4E9: using guessed type int nullsub_9(void);

//----- (0804A5A3) --------------------------------------------------------
void sub_804A5A3()
{
  ;
}

//----- (0804A5CC) --------------------------------------------------------
void sub_804A5CC()
{
  ;
}

//----- (0804A5EA) --------------------------------------------------------
signed int sub_804A5EA()
{
  return 4;
}
// 804A5EA: could not find valid save-restore pair for ebp

//----- (0804A648) --------------------------------------------------------
int __usercall sub_804A648@<eax>(int a1@<ebp>)
{
  int v1; // eax
  int (__cdecl *v2)(signed int, int); // edx
  int v4; // [esp+18h] [ebp-4h]

  dword_80591DC = (int)nullsub_10;
  v1 = sub_80531E5();
  v4 = a1;
  return v2(134565936, v1);
}
// 804A648: could not find valid save-restore pair for ebp
// 804A647: using guessed type int nullsub_10();
// 80531E5: using guessed type int sub_80531E5(void);
// 80591DC: using guessed type int dword_80591DC;

//----- (0804A6A6) --------------------------------------------------------
signed int sub_804A6A6()
{
  signed int result; // eax

  result = sub_804A5EA();
  byte_8059849 = 1;
  return result;
}
// 8059849: using guessed type char byte_8059849;

//----- (0804A708) --------------------------------------------------------
#error "804A744: call analysis failed (funcsize=32)"

//----- (0804A76D) --------------------------------------------------------
int __cdecl sub_804A76D(char *s1)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  void *v4; // eax
  char *v5; // eax
  char *v7; // [esp+1Ch] [ebp-4Ch]
  void **i; // [esp+20h] [ebp-48h]
  const char *v9; // [esp+24h] [ebp-44h]
  void *v10; // [esp+28h] [ebp-40h]
  const char *v11; // [esp+2Ch] [ebp-3Ch]
  const char *v12; // [esp+30h] [ebp-38h]
  const char *v13; // [esp+34h] [ebp-34h]
  const char *v14; // [esp+38h] [ebp-30h]
  const char *v15; // [esp+3Ch] [ebp-2Ch]
  const char *v16; // [esp+40h] [ebp-28h]
  const char *v17; // [esp+44h] [ebp-24h]
  const char *v18; // [esp+48h] [ebp-20h]
  const char *v19; // [esp+4Ch] [ebp-1Ch]
  const char *v20; // [esp+50h] [ebp-18h]
  const char *v21; // [esp+54h] [ebp-14h]
  int v22; // [esp+58h] [ebp-10h]
  int v23; // [esp+5Ch] [ebp-Ch]

  v10 = &unk_80537D0;
  v11 = "test invocation";
  v12 = "coreutils";
  v13 = "Multi-call invocation";
  v14 = "sha224sum";
  v15 = "sha2 utilities";
  v16 = "sha256sum";
  v17 = "sha2 utilities";
  v18 = "sha384sum";
  v19 = "sha2 utilities";
  v20 = "sha512sum";
  v21 = "sha2 utilities";
  v22 = 0;
  v23 = 0;
  v7 = s1;
  for ( i = &v10; *i && strcmp(s1, (const char *)*i); i += 2 )
    ;
  if ( i[1] )
    v7 = (char *)i[1];
  v1 = gettext("\n%s online help: <%s>\n");
  printf(v1, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  v9 = setlocale(5, 0);
  if ( v9 && strncmp(v9, "en_", 3u) )
  {
    v2 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
    printf(v2, s1);
  }
  v3 = gettext("Full documentation at: <%s%s>\n");
  printf(v3, "http://www.gnu.org/software/coreutils/", s1);
  v4 = &loc_804A8DB;
  if ( v7 != s1 )
    v4 = &loc_804A8E2;
  dword_80591DC = (int)v4;
  sub_80531E5();
  v5 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  return printf(v5, v7, " invocation");
}
// 80531E5: using guessed type int sub_80531E5(void);
// 80591DC: using guessed type int dword_80591DC;

//----- (0804A90C) --------------------------------------------------------
void __cdecl __noreturn sub_804A90C(int status)
{
  int v1; // ebx
  char *v2; // eax
  int v3; // ST00_4
  int v4; // ebx
  char *v5; // eax
  FILE *v6; // ebx
  char *v7; // eax
  FILE *v8; // ebx
  char *v9; // eax
  FILE *v10; // ebx
  char *v11; // eax
  FILE *v12; // ebx
  char *v13; // eax
  FILE *v14; // ebx
  char *v15; // eax
  FILE *v16; // ebx
  char *v17; // eax
  FILE *v18; // ebx
  char *v19; // eax
  FILE *v20; // ebx
  char *v21; // eax
  FILE *v22; // ebx
  char *v23; // eax

  if ( status )
  {
    v1 = dword_80598C1;
    v2 = gettext("Try '%s --help' for more information.\n");
    fprintf(stderr, v2, v1);
    dword_8059114 = (int)&loc_804AA88;
    sub_8053699(v3);
  }
  v4 = dword_80598C1;
  v5 = gettext("Usage: %s [OPTION]... FILE1 FILE2\n");
  printf(v5, v4);
  v6 = stdout;
  v7 = gettext(
         "For each pair of input lines with identical join fields, write a line to\n"
         "standard output.  The default join field is the first, delimited by blanks.\n");
  fputs_unlocked(v7, v6);
  v8 = stdout;
  v9 = gettext("\nWhen FILE1 or FILE2 (not both) is -, read standard input.\n");
  fputs_unlocked(v9, v8);
  v10 = stdout;
  v11 = gettext(
          "\n"
          "  -a FILENUM        also print unpairable lines from file FILENUM, where\n"
          "                      FILENUM is 1 or 2, corresponding to FILE1 or FILE2\n"
          "  -e EMPTY          replace missing input fields with EMPTY\n");
  fputs_unlocked(v11, v10);
  v12 = stdout;
  v13 = gettext(
          "  -i, --ignore-case  ignore differences in case when comparing fields\n"
          "  -j FIELD          equivalent to '-1 FIELD -2 FIELD'\n"
          "  -o FORMAT         obey FORMAT while constructing output line\n"
          "  -t CHAR           use CHAR as input and output field separator\n");
  fputs_unlocked(v13, v12);
  v14 = stdout;
  v15 = gettext(
          "  -v FILENUM        like -a FILENUM, but suppress joined output lines\n"
          "  -1 FIELD          join on this FIELD of file 1\n"
          "  -2 FIELD          join on this FIELD of file 2\n"
          "  --check-order     check that the input is correctly sorted, even\n"
          "                      if all input lines are pairable\n"
          "  --nocheck-order   do not check that the input is correctly sorted\n"
          "  --header          treat the first line in each file as field headers,\n"
          "                      print them without trying to pair them\n");
  fputs_unlocked(v15, v14);
  v16 = stdout;
  v17 = gettext("  -z, --zero-terminated     line delimiter is NUL, not newline\n");
  fputs_unlocked(v17, v16);
  v18 = stdout;
  v19 = gettext("      --help     display this help and exit\n");
  fputs_unlocked(v19, v18);
  v20 = stdout;
  v21 = gettext("      --version  output version information and exit\n");
  fputs_unlocked(v21, v20);
  v22 = stdout;
  v23 = gettext(
          "\n"
          "Unless -t CHAR is given, leading blanks separate fields and are ignored,\n"
          "else fields are separated by CHAR.  Any FIELD is a field number counted\n"
          "from 1.  FORMAT is one or more comma or blank separated specifications,\n"
          "each being 'FILENUM.FIELD' or '0'.  Default FORMAT outputs the join field,\n"
          "the remaining fields from FILE1, the remaining fields from FILE2, all\n"
          "separated by CHAR.  If FORMAT is the keyword 'auto', then the first\n"
          "line of each file determines the number of fields output for each line.\n"
          "\n"
          "Important: FILE1 and FILE2 must be sorted on the join fields.\n"
          "E.g., use \"sort -k 1b,1\" if 'join' has no options,\n"
          "or use \"join -t ''\" if 'sort' has no options.\n"
          "Note, comparisons honor the rules specified by 'LC_COLLATE'.\n"
          "If the input is not sorted and some lines cannot be joined, a\n"
          "warning message will be given.\n");
  fputs_unlocked(v23, v22);
  sub_804A76D("join");
  exit(status);
}
// 8048F50: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8053699: using guessed type int __stdcall sub_8053699(_DWORD);
// 8059114: using guessed type int dword_8059114;
// 80598C1: using guessed type int dword_80598C1;

//----- (0804AA93) --------------------------------------------------------
int __cdecl sub_804AA93(int a1, int a2, int a3)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 12) >= *(_DWORD *)(a1 + 16) )
    *(_DWORD *)(a1 + 20) = sub_80513A9(*(void **)(a1 + 20), a1 + 16, 8);
  *(_DWORD *)(8 * *(_DWORD *)(a1 + 12) + *(_DWORD *)(a1 + 20)) = a2;
  *(_DWORD *)(8 * *(_DWORD *)(a1 + 12) + *(_DWORD *)(a1 + 20) + 4) = a3;
  result = a1;
  ++*(_DWORD *)(a1 + 12);
  return result;
}

//----- (0804AB0D) --------------------------------------------------------
unsigned __int8 *__cdecl sub_804AB0D(int a1)
{
  size_t v1; // edx
  unsigned __int8 *result; // eax
  bool v3; // zf
  void *v4; // eax
  void *v5; // eax
  void *v6; // eax
  int v7; // [esp+0h] [ebp-28h]
  unsigned __int8 *s; // [esp+10h] [ebp-18h]
  unsigned __int8 *i; // [esp+14h] [ebp-14h]
  int v10; // [esp+18h] [ebp-10h]

  s = *(unsigned __int8 **)(a1 + 8);
  v1 = *(_DWORD *)(a1 + 4) - 1;
  v10 = (int)&s[v1];
  result = *(unsigned __int8 **)(a1 + 8);
  if ( s != &s[v1] )
  {
    if ( c >= 0 && c != 10 )
    {
      v3 = memchr(s, c, v1) == 0;
      v4 = &loc_804ABC6;
      if ( !v3 )
        v4 = &loc_804AB57;
      dword_80591C8 = (int)v4;
      sub_805324D();
      dword_80591DC = (int)&loc_804ACDA;
      sub_80531E5();
    }
    if ( c < 0 )
    {
      while ( (unsigned __int8)sub_804A708(*s) )
      {
        result = ++s;
        if ( s == (unsigned __int8 *)v10 )
          return result;
      }
      do
      {
        for ( i = s + 1; i != (unsigned __int8 *)v10 && (unsigned __int8)sub_804A708(*i) ^ 1; ++i )
          ;
        sub_804AA93(a1, (int)s, i - s);
        v5 = &loc_804AC7A;
        if ( i != (unsigned __int8 *)v10 )
          v5 = &loc_804AC89;
        dword_80591B4 = (int)v5;
        sub_80532E9();
        dword_80591B4 = (int)&locret_804ACFA;
        sub_80532E9();
        for ( s = i + 1; ; ++s )
        {
          v6 = &loc_804ACB9;
          if ( s == (unsigned __int8 *)v10 )
            v6 = &loc_804ACCE;
          dword_8059204 = (int)v6;
          sub_80530F0(v7);
          if ( !(unsigned __int8)sub_804A708(*s) )
            break;
        }
      }
      while ( s != (unsigned __int8 *)v10 );
    }
    result = (unsigned __int8 *)sub_804AA93(a1, (int)s, v10 - (_DWORD)s);
  }
  return result;
}
// 804AB0D: could not find valid save-restore pair for ebx
// 80530F0: using guessed type int __stdcall sub_80530F0(_DWORD);
// 80531E5: using guessed type int sub_80531E5(void);
// 805324D: using guessed type int sub_805324D(void);
// 80532E9: using guessed type int sub_80532E9(void);
// 80591B4: using guessed type int dword_80591B4;
// 80591C8: using guessed type int dword_80591C8;
// 80591DC: using guessed type int dword_80591DC;
// 8059204: using guessed type int dword_8059204;

//----- (0804ACFC) --------------------------------------------------------
int __cdecl sub_804ACFC(int a1)
{
  int result; // eax

  if ( a1 )
  {
    free(*(void **)(a1 + 20));
    *(_DWORD *)(a1 + 20) = 0;
    free(*(void **)(a1 + 8));
    result = a1;
    *(_DWORD *)(a1 + 8) = 0;
  }
  return result;
}

//----- (0804AD3C) --------------------------------------------------------
int __cdecl sub_804AD3C(int a1, int a2, unsigned int a3, unsigned int a4)
{
  void *s1; // ST24_4
  int v5; // ST2C_4
  void *s2; // ST28_4
  size_t n; // ST30_4
  void *v8; // eax
  int v10; // [esp+0h] [ebp-38h]

  if ( *(_DWORD *)(a1 + 12) > a3 )
  {
    s1 = *(void **)(8 * a3 + *(_DWORD *)(a1 + 20));
    v5 = *(_DWORD *)(8 * a3 + *(_DWORD *)(a1 + 20) + 4);
    dword_805918C = (int)&loc_804ADA1;
    sub_80533FB();
  }
  if ( *(_DWORD *)(a2 + 12) > a4 )
  {
    s2 = *(void **)(8 * a4 + *(_DWORD *)(a2 + 20));
    n = *(_DWORD *)(8 * a4 + *(_DWORD *)(a2 + 20) + 4);
    dword_8059114 = (int)&loc_804ADF0;
    sub_8053699(v10);
  }
  v8 = &loc_804AE0F;
  dword_8059204 = (int)v8;
  sub_80530F0(v10);
  return 0;
}
// 80530F0: using guessed type int __stdcall sub_80530F0(_DWORD);
// 80533FB: using guessed type int sub_80533FB(void);
// 8053699: using guessed type int __stdcall sub_8053699(_DWORD);
// 8059114: using guessed type int dword_8059114;
// 805918C: using guessed type int dword_805918C;
// 8059204: using guessed type int dword_8059204;

//----- (0804AEF5) --------------------------------------------------------
int __cdecl sub_804AEF5(int a1, int a2, int a3)
{
  int v3; // ecx
  int result; // eax
  signed int v5; // eax
  int v6; // ST2C_4
  signed int v7; // ST28_4
  int v8; // ebx
  int v9; // esi
  char *v10; // edi
  char *v11; // eax
  signed int v12; // [esp+38h] [ebp-20h]

  result = dword_8059899;
  if ( dword_8059899 != 2 )
  {
    if ( dword_8059899 == 1 || (result = (unsigned __int8)byte_8059879, byte_8059879) )
    {
      result = (unsigned __int8)byte_805987A[a3 - 1] ^ 1;
      if ( byte_805987A[a3 - 1] != 1 )
      {
        if ( a3 == 1 )
        {
          dword_8059128 = (int)&loc_804AF6C;
          sub_8053629(v3);
        }
        result = sub_804AD3C(a1, a2, dword_8059248, dword_8059248);
        if ( result > 0 )
        {
          v12 = *(_DWORD *)(a2 + 4);
          if ( v12 && *(_BYTE *)(v12 - 1 + *(_DWORD *)(a2 + 8)) == 10 )
            --v12;
          if ( v12 < 0 )
            v5 = 0x7FFFFFFF;
          else
            v5 = v12;
          v6 = *(_DWORD *)(a2 + 8);
          v7 = v5;
          v8 = dword_8059855[2 * (a3 - 1)];
          v9 = dword_8059859[2 * (a3 - 1)];
          v10 = (&dword_8059865)[a3 - 1];
          v11 = gettext("%s:%llu: is not sorted: %.*s");
          error(dword_8059899 == 1, 0, v11, v10, v8, v9, v7, v6);
          result = a3 - 1;
          byte_805987A[a3 - 1] = 1;
        }
      }
    }
  }
  return result;
}
// 8053629: using guessed type int __fastcall sub_8053629(_DWORD);
// 8059128: using guessed type int dword_8059128;
// 8059248: using guessed type int dword_8059248;
// 8059855: using guessed type int dword_8059855[];
// 8059879: using guessed type char byte_8059879;
// 8059899: using guessed type int dword_8059899;

//----- (0804B062) --------------------------------------------------------
int __cdecl sub_804B062(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (0804B071) --------------------------------------------------------
void *__cdecl sub_804B071(_DWORD *a1)
{
  void *result; // eax

  result = sub_80515A2(1u, 0x18u);
  *a1 = result;
  return result;
}

//----- (0804B0BD) --------------------------------------------------------
int __cdecl sub_804B0BD(FILE *stream, int a2, int a3)
{
  char *v3; // ebx
  int *v4; // eax
  int result; // eax
  int v6; // ecx
  __int64 v7; // rax
  void *v8; // [esp+18h] [ebp-10h]

  v8 = *(void **)a2;
  if ( dword_805984D[a3 - 1] == *(_DWORD *)a2 )
  {
    v8 = ptr[a3 - 1];
    ptr[a3 - 1] = *(void **)a2;
    *(_DWORD *)a2 = v8;
  }
  if ( v8 )
    sub_804B062((int)v8);
  else
    v8 = sub_804B071((_DWORD *)a2);
  if ( sub_804EE7D((int)v8, stream, byte_8059254) )
  {
    v6 = a3 - 1;
    LODWORD(v7) = dword_8059855[2 * (a3 - 1)];
    HIDWORD(v7) = dword_8059859[2 * (a3 - 1)];
    dword_8059855[2 * v6] = ++v7;
    dword_8059859[2 * v6] = HIDWORD(v7);
    sub_804AB0D((int)v8);
    if ( dword_805984D[a3 - 1] )
      sub_804AEF5(dword_805984D[a3 - 1], (int)v8, a3);
    dword_805984D[a3 - 1] = (int)v8;
    result = 1;
  }
  else
  {
    if ( ferror_unlocked(stream) )
    {
      v3 = gettext("read error");
      v4 = __errno_location();
      error(1, *v4, v3);
    }
    sub_804ACFC((int)v8);
    result = 0;
  }
  return result;
}
// 8059254: using guessed type char byte_8059254;
// 805984D: using guessed type int dword_805984D[];
// 8059855: using guessed type int dword_8059855[];

//----- (0804B22B) --------------------------------------------------------
#error "804B269: call analysis failed (funcsize=31)"

//----- (0804B29E) --------------------------------------------------------
_DWORD *__cdecl sub_804B29E(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = a1;
  a1[2] = 0;
  return result;
}

//----- (0804B2C0) --------------------------------------------------------
#error "804B366: call analysis failed (funcsize=76)"

//----- (0804B3A5) --------------------------------------------------------
#error "804B3CB: call analysis failed (funcsize=35)"

//----- (0804B406) --------------------------------------------------------
void __cdecl sub_804B406(int a1)
{
  unsigned int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; *(_DWORD *)(a1 + 4) > i; ++i )
  {
    sub_804ACFC(*(_DWORD *)(4 * i + *(_DWORD *)(a1 + 8)));
    free(*(void **)(4 * i + *(_DWORD *)(a1 + 8)));
  }
  free(*(void **)(a1 + 8));
}

//----- (0804B530) --------------------------------------------------------
char *__cdecl sub_804B530(unsigned int a1, unsigned int a2, size_t a3)
{
  size_t v3; // eax
  char v4; // al
  char *result; // eax
  int *v6; // [esp-8h] [ebp-30h]
  void *v7; // [esp-4h] [ebp-2Ch]
  size_t v8; // [esp+0h] [ebp-28h]
  unsigned int v9; // [esp+4h] [ebp-24h]
  char v10; // [esp+17h] [ebp-11h]
  size_t v11; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]
  int savedregs; // [esp+28h] [ebp+0h]

  if ( byte_8059881 )
    v3 = a3;
  else
    v3 = *(_DWORD *)(a1 + 12);
  n = v3;
  if ( c < 0 )
    v4 = 32;
  else
    v4 = c;
  v10 = v4;
  v11 = 0;
  if ( v11 < a2 && v11 < n )
  {
    putchar_unlocked(v10);
    v9 = a1;
    v8 = v11;
    v7 = &loc_804B644;
    v6 = &savedregs;
    if ( *(_DWORD *)(a2 + 12) <= a1 )
    {
      result = s1;
      if ( s1 )
        result = (char *)fputs_unlocked(s1, stdout);
    }
    else
    {
      n = *(_DWORD *)(8 * a1 + *(_DWORD *)(a2 + 20) + 4);
      if ( n )
      {
        fwrite_unlocked(*(const void **)(8 * a1 + *(_DWORD *)(a2 + 20)), 1u, n, stdout);
        dword_805918C = (int)&locret_804B640;
        sub_80533FB();
      }
      result = s1;
      if ( s1 )
        result = (char *)fputs_unlocked(s1, stdout);
    }
  }
  else
  {
    v11 = a2 + 1;
    result = (char *)v11;
    if ( v11 < n )
    {
      putchar_unlocked(v10);
      v9 = a1;
      v8 = v11;
      v7 = &loc_804B72E;
      v6 = &savedregs;
      if ( *(_DWORD *)(a2 + 12) <= a1 )
      {
        result = s1;
        if ( s1 )
          result = (char *)fputs_unlocked(s1, stdout);
      }
      else
      {
        n = *(_DWORD *)(8 * a1 + *(_DWORD *)(a2 + 20) + 4);
        if ( n )
        {
          result = (char *)fwrite_unlocked(*(const void **)(8 * a1 + *(_DWORD *)(a2 + 20)), 1u, n, stdout);
        }
        else
        {
          result = s1;
          if ( s1 )
            result = (char *)fputs_unlocked(s1, stdout);
        }
      }
    }
  }
  return result;
}
// 8048F50: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 80533FB: using guessed type int sub_80533FB(void);
// 805918C: using guessed type int dword_805918C;
// 8059881: using guessed type char byte_8059881;

//----- (0804B927) --------------------------------------------------------
char *__cdecl sub_804B927(unsigned int a1, int a2)
{
  char *result; // eax
  int v3; // ST00_4
  size_t n; // [esp+1Ch] [ebp-Ch]

  if ( *(_DWORD *)(a2 + 12) <= a1 )
    goto LABEL_6;
  n = *(_DWORD *)(8 * a1 + *(_DWORD *)(a2 + 20) + 4);
  if ( n )
    return (char *)fwrite_unlocked(*(const void **)(8 * a1 + *(_DWORD *)(a2 + 20)), 1u, n, stdout);
  result = s1;
  if ( s1 )
  {
    fputs_unlocked(s1, stdout);
    dword_8059114 = (int)&locret_804B9D4;
    sub_8053699(v3);
LABEL_6:
    result = s1;
    if ( s1 )
      result = (char *)fputs_unlocked(s1, stdout);
  }
  return result;
}
// 8048F50: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8053699: using guessed type int __stdcall sub_8053699(_DWORD);
// 8059114: using guessed type int dword_8059114;

//----- (0804BA28) --------------------------------------------------------
void __usercall sub_804BA28(int a1@<ebx>, FILE *stream, FILE *a3)
{
  int v3; // eax
  int v4; // eax
  int *v5; // eax
  FILE *v6; // eax
  char v7; // al
  void *v8; // eax
  int *v9; // eax
  char v10; // al
  void *v11; // eax
  FILE *v12; // eax
  char v13; // al
  bool v14; // zf
  void *v15; // eax
  void *v16; // eax
  void *v17; // eax
  int v18; // ebx
  int v19; // eax
  int v20; // ecx
  void *v21; // eax
  int *v22; // eax
  char v23; // al
  void *v24; // eax
  size_t v25; // eax
  void *v26; // eax
  void *v27; // eax
  void *v28; // eax
  void *v29; // eax
  int v30; // ecx
  void *v31; // eax
  char *v32; // ebx
  int *v33; // eax
  char v34; // al
  void *v35; // eax
  FILE *v36; // eax
  void *v37; // eax
  void *v38; // eax
  void *v39; // eax
  char *v40; // ebx
  char v41; // al
  FILE *v42; // eax
  void *v43; // eax
  void *v44; // eax
  int v45; // ecx
  size_t v46; // eax
  void *v47; // eax
  void *v48; // eax
  int v49; // eax
  void *v50; // eax
  FILE *v51; // [esp-48h] [ebp-A0h]
  FILE *v52; // [esp-44h] [ebp-9Ch]
  int *v53; // [esp-40h] [ebp-98h]
  int v54; // [esp-3Ch] [ebp-94h]
  FILE *v55; // [esp-38h] [ebp-90h]
  char *v56; // [esp-34h] [ebp-8Ch]
  char *v57; // [esp-30h] [ebp-88h]
  int v58; // [esp-2Ch] [ebp-84h]
  int v59; // [esp-28h] [ebp-80h]
  int v60; // [esp-24h] [ebp-7Ch]
  int v61; // [esp-20h] [ebp-78h]
  int v62; // [esp-1Ch] [ebp-74h]
  int v63; // [esp-18h] [ebp-70h]
  int v64; // [esp-14h] [ebp-6Ch]
  int v65; // [esp-10h] [ebp-68h]
  int v66; // [esp-Ch] [ebp-64h]
  char *v67; // [esp-8h] [ebp-60h]
  int v68; // [esp-4h] [ebp-5Ch]
  int *v69; // [esp+0h] [ebp-58h]
  FILE *v70; // [esp+4h] [ebp-54h]
  int v71; // [esp+8h] [ebp-50h]
  int v72; // [esp+Ch] [ebp-4Ch]
  int v73; // [esp+10h] [ebp-48h]
  int v74; // [esp+14h] [ebp-44h]
  void *ptr; // [esp+18h] [ebp-40h]
  unsigned int v76; // [esp+1Ch] [ebp-3Ch]
  int v77; // [esp+20h] [ebp-38h]
  int *v78; // [esp+24h] [ebp-34h]
  FILE *v79; // [esp+28h] [ebp-30h]
  int v80; // [esp+2Ch] [ebp-2Ch]
  int v81; // [esp+30h] [ebp-28h]
  FILE *v82; // [esp+34h] [ebp-24h]
  int v83; // [esp+38h] [ebp-20h]
  int v84; // [esp+3Ch] [ebp-1Ch]
  int *v85; // [esp+40h] [ebp-18h]
  int v86; // [esp+44h] [ebp-14h]
  _DWORD *v87; // [esp+48h] [ebp-10h]
  size_t n; // [esp+4Ch] [ebp-Ch]
  int savedregs; // [esp+58h] [ebp+0h]

  sub_804EC7F(stream, 2);
  sub_804EC7F(a3, 2);
  sub_804B29E(&v83);
  sub_804B2C0(stream, (int)&v83, 1);
  sub_804B29E(&v86);
  sub_804B2C0(a3, (int)&v86, 2);
  if ( byte_8059881 )
  {
    if ( v83 )
      v3 = *(_DWORD *)(*v85 + 12);
    else
      v3 = 0;
    dword_8059885 = v3;
    if ( v86 )
      v4 = *(_DWORD *)(*(_DWORD *)n + 12);
    else
      v4 = 0;
    dword_8059889 = v4;
  }
  if ( byte_80598B6 && (v83 || v86) )
  {
    if ( v83 )
      v5 = (int *)*v85;
    else
      v5 = (int *)&unk_805989D;
    v78 = v5;
    if ( v86 )
      v6 = *(FILE **)n;
    else
      v6 = (FILE *)&unk_805989D;
    v79 = v6;
    v70 = v6;
    v69 = v78;
    v68 = (int)&loc_804BE1B;
    v67 = (char *)&savedregs;
    if ( c < 0 )
      v7 = 32;
    else
      v7 = c;
    HIBYTE(v84) = v7;
    n = dword_8059895;
    if ( !dword_8059895 )
    {
      if ( stream == (FILE *)&unk_805989D )
      {
        v86 = (int)a3;
        v85 = (int *)dword_8059248;
      }
      else
      {
        v86 = (int)stream;
        v85 = (int *)dword_8059244;
      }
      v54 = v86;
      v53 = v85;
      v52 = (FILE *)&loc_804BDC9;
      v51 = (FILE *)&savedregs;
      if ( a3->_IO_read_base <= (char *)stream )
      {
        v8 = &loc_804BDAE;
        if ( !s1 )
          v8 = &locret_804BDC5;
        dword_805918C = (int)v8;
        sub_80533FB();
        fputs_unlocked(s1, stdout);
      }
      else
      {
        n = *(_DWORD *)&a3->_IO_write_ptr[8 * (_DWORD)stream + 4];
        if ( n )
        {
          fwrite_unlocked(*(const void **)&a3->_IO_write_ptr[8 * (_DWORD)stream], 1u, n, stdout);
        }
        else if ( s1 )
        {
          fputs_unlocked(s1, stdout);
        }
      }
      return;
    }
    v87 = (_DWORD *)n;
    if ( *(_DWORD *)n )
    {
      if ( *v87 == 1 )
      {
        dword_8059178 = (int)&loc_804BBC9;
        sub_805346B(v53);
      }
      v86 = (int)a3;
      v85 = (int *)v87[1];
    }
    else if ( stream == (FILE *)&unk_805989D )
    {
      v86 = (int)a3;
      v85 = (int *)dword_8059248;
    }
    else
    {
      v86 = (int)stream;
      v85 = (int *)dword_8059244;
    }
    v54 = v86;
    v53 = v85;
    v52 = (FILE *)&loc_804BC9A;
    v51 = (FILE *)&savedregs;
    if ( a3->_IO_read_base <= (char *)stream )
    {
LABEL_34:
      if ( s1 )
        fputs_unlocked(s1, stdout);
      return;
    }
    n = *(_DWORD *)&a3->_IO_write_ptr[8 * (_DWORD)stream + 4];
    if ( n )
    {
      fwrite_unlocked(*(const void **)&a3->_IO_write_ptr[8 * (_DWORD)stream], 1u, n, stdout);
      return;
    }
    if ( s1 )
    {
      fputs_unlocked(s1, stdout);
      dword_80591DC = (int)&locret_804BC96;
      sub_80531E5();
      goto LABEL_34;
    }
  }
  else
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          if ( !v83 || !v86 )
          {
            ptr = 0;
            HIBYTE(v74) = 0;
            v68 = dword_8059899;
            v67 = (char *)a1;
            v28 = &loc_804CB0A;
            if ( dword_8059899 == 2 )
              v28 = &loc_804CB2A;
            dword_805918C = (int)v28;
            sub_80533FB();
            if ( byte_805987A[0] != 1 || byte_805987B != 1 )
              HIBYTE(v74) = 1;
            if ( !byte_8059876 && !HIBYTE(v74) )
            {
              v68 = (unsigned __int8)byte_8059877;
              v38 = &loc_804D245;
              if ( byte_8059877 )
                v38 = &loc_804D264;
              dword_80591C8 = (int)v38;
              v68 = sub_805324D();
              v39 = &loc_804D264;
              if ( !HIBYTE(v74) )
                v39 = &loc_804D9BD;
              dword_80591F0 = (int)v39;
              v40 = v67;
              sub_8053179(v69, v70, v71, v72, v73, v74, ptr, v76, v77, v78, v79, v80, v81, v82, v83, v84);
              if ( v86 )
              {
                if ( byte_8059877 )
                {
                  v70 = *(FILE **)n;
                  v69 = (int *)&unk_805989D;
                  dword_8059178 = (int)&loc_804D2A2;
                  sub_805346B(&loc_804D5CE);
                  v68 = (int)&savedregs;
                  if ( c < 0 )
                    v41 = 32;
                  else
                    v41 = c;
                  HIBYTE(v84) = v41;
                  n = dword_8059895;
                  if ( dword_8059895 )
                  {
                    v87 = (_DWORD *)n;
                    if ( *(_DWORD *)n )
                    {
                      if ( *v87 == 1 )
                        v42 = stream;
                      else
                        v42 = a3;
                      v86 = (int)v42;
                      v85 = (int *)v87[1];
                    }
                    else if ( stream == (FILE *)&unk_805989D )
                    {
                      v86 = (int)a3;
                      v85 = (int *)dword_8059248;
                    }
                    else
                    {
                      v86 = (int)stream;
                      v85 = (int *)dword_8059244;
                    }
                    dword_80591A0 = (int)&loc_804D349;
                    sub_8053376(&loc_804D40A, v85, v86, v56, v57, v58, v59, v60, v61, v62, v63, v64, v65, v66, v67, v68);
                    v68 = (int)&savedregs;
                    if ( a3->_IO_read_base <= (char *)stream )
                    {
                      if ( s1 )
                        fputs_unlocked(s1, stdout);
                    }
                    else
                    {
                      n = *(_DWORD *)&a3->_IO_write_ptr[8 * (_DWORD)stream + 4];
                      if ( n )
                      {
                        fwrite_unlocked(*(const void **)&a3->_IO_write_ptr[8 * (_DWORD)stream], 1u, n, stdout);
                      }
                      else
                      {
                        v57 = s1;
                        v56 = v40;
                        v43 = &loc_804D3CD;
                        if ( !s1 )
                          v43 = &locret_804D406;
                        dword_80591DC = (int)v43;
                        sub_80531E5();
                        fputs_unlocked(s1, stdout);
                      }
                    }
                  }
                  else
                  {
                    v53 = (int *)dword_8059895;
                    v52 = (FILE *)v67;
                    v44 = &loc_804D463;
                    if ( stream != (FILE *)&unk_805989D )
                      v44 = &loc_804D480;
                    dword_80591F0 = (int)v44;
                    sub_8053179(v54, v55, v56, v57, v58, v59, v60, v61, v62, v63, v64, v65, v66, v67, v68, v69);
                    v86 = (int)a3;
                    v85 = (int *)dword_8059248;
                    dword_8059128 = (int)&loc_804D48E;
                    sub_8053629(v45);
                    v86 = (int)stream;
                    v85 = (int *)dword_8059244;
                    v70 = stream;
                    v69 = (int *)dword_8059244;
                    v68 = (int)&loc_804D57C;
                    v67 = (char *)&savedregs;
                    if ( a3->_IO_read_base <= (char *)stream )
                    {
                      if ( s1 )
                        fputs_unlocked(s1, stdout);
                    }
                    else
                    {
                      v46 = *(_DWORD *)&a3->_IO_write_ptr[8 * (_DWORD)stream + 4];
                      n = v46;
                      v14 = v46 == 0;
                      v56 = (char *)v46;
                      v55 = v52;
                      v47 = &loc_804D4EA;
                      if ( v14 )
                        v47 = &loc_804D51D;
                      dword_805913C = (int)v47;
                      sub_80535C1(v57, v58, v59, v60, v61, v62, v63, v64, v65, v66, v67, v68, v69, v70, v71);
                      fwrite_unlocked(*(const void **)&a3->_IO_write_ptr[8 * (_DWORD)stream], 1u, n, stdout);
                    }
                  }
                  return;
                }
                v68 = v83;
                v48 = &loc_804D5EE;
                if ( !v83 )
                  v48 = &loc_804D5FA;
                dword_80591F0 = (int)v48;
                sub_8053179(v69, v70, v71, v72, v73, v74, ptr, v76, v77, v78, v79, v80, v81, v82, v83, v84);
                byte_8059879 = 1;
                v49 = sub_804B0BD(a3, (int)&ptr, 2);
                v14 = (_BYTE)v49 == 0;
                v68 = v49;
                v50 = &loc_804D9BD;
                if ( !v14 )
                  v50 = &loc_804D609;
                dword_80591F0 = (int)v50;
                sub_8053179(v69, v70, v71, v72, v73, v74, ptr, v76, v77, v78, v79, v80, v81, v82, v83, v84);
              }
              sub_804ACFC((int)ptr);
              free(ptr);
              sub_804B406((int)&v83);
              sub_804B406((int)&v86);
              return;
            }
            v68 = v83;
            v29 = &loc_804CB5F;
            if ( !v83 )
              v29 = &loc_804D221;
            dword_80591F0 = (int)v29;
            sub_8053179(v69, v70, v71, v72, v73, v74, ptr, v76, v77, v78, v79, v80, v81, v82, v83, v84);
            v68 = (unsigned __int8)byte_8059876;
            v31 = &loc_804CB83;
            if ( !byte_8059876 )
              v31 = &loc_804CEA9;
            dword_8059128 = (int)v31;
            v32 = v67;
            sub_8053629(v30);
            v33 = (int *)*v85;
            v70 = (FILE *)&unk_805989D;
            v69 = v33;
            v68 = (int)&loc_804CEA9;
            v67 = (char *)&savedregs;
            if ( c < 0 )
              v34 = 32;
            else
              v34 = c;
            HIBYTE(v84) = v34;
            n = dword_8059895;
            v52 = (FILE *)dword_8059895;
            v51 = (FILE *)v32;
            v35 = &loc_804CBDF;
            if ( !dword_8059895 )
              v35 = &loc_804CD5B;
            dword_8059178 = (int)v35;
            sub_805346B(v53);
            v87 = (_DWORD *)n;
            if ( *(_DWORD *)n )
            {
              if ( *v87 == 1 )
                v36 = stream;
              else
                v36 = a3;
              v86 = (int)v36;
              v85 = (int *)v87[1];
            }
            else
            {
              if ( stream == (FILE *)&unk_805989D )
              {
                v86 = (int)a3;
                v85 = (int *)dword_8059248;
                dword_8059164 = (int)&loc_804CC42;
                sub_80534D5();
              }
              v86 = (int)stream;
              v85 = (int *)dword_8059244;
            }
            v70 = (FILE *)v86;
            v69 = v85;
            v68 = (int)&loc_804CD24;
            v67 = (char *)&savedregs;
            if ( a3->_IO_read_base > (char *)stream )
            {
              n = *(_DWORD *)&a3->_IO_write_ptr[8 * (_DWORD)stream + 4];
              if ( n )
              {
                fwrite_unlocked(*(const void **)&a3->_IO_write_ptr[8 * (_DWORD)stream], 1u, n, stdout);
                return;
              }
              v56 = s1;
              v55 = v51;
              v37 = &loc_804CCDA;
              if ( !s1 )
                v37 = &locret_804CD20;
              dword_8059114 = (int)v37;
              sub_8053699(v57);
              fputs_unlocked(s1, stdout);
              dword_8059204 = (int)&locret_804CD20;
              sub_80530F0(v57);
            }
            if ( s1 )
              fputs_unlocked(s1, stdout);
            return;
          }
          a1 = dword_8059248;
          v80 = sub_804AD3C(*v85, *(_DWORD *)n, dword_8059244, dword_8059248);
          if ( v80 >= 0 )
            break;
          if ( byte_8059876 )
          {
            v9 = (int *)*v85;
            v70 = (FILE *)&unk_805989D;
            v69 = v9;
            v68 = (int)&loc_804C1BA;
            v67 = (char *)&savedregs;
            if ( c < 0 )
              v10 = 32;
            else
              v10 = c;
            HIBYTE(v84) = v10;
            n = dword_8059895;
            v52 = (FILE *)dword_8059895;
            v51 = (FILE *)a1;
            v11 = &loc_804BF2D;
            if ( !dword_8059895 )
              v11 = &loc_804C07C;
            dword_8059114 = (int)v11;
            sub_8053699(v53);
            v87 = (_DWORD *)n;
            if ( *(_DWORD *)n )
            {
              if ( *v87 == 1 )
                v12 = stream;
              else
                v12 = a3;
              v86 = (int)v12;
              v85 = (int *)v87[1];
            }
            else if ( stream == (FILE *)&unk_805989D )
            {
              v86 = (int)a3;
              v85 = (int *)dword_8059248;
            }
            else
            {
              v86 = (int)stream;
              v85 = (int *)dword_8059244;
            }
            v70 = (FILE *)v86;
            v69 = v85;
            v68 = (int)&loc_804C03B;
            v67 = (char *)&savedregs;
            if ( a3->_IO_read_base <= (char *)stream )
            {
              if ( s1 )
                fputs_unlocked(s1, stdout);
            }
            else
            {
              n = *(_DWORD *)&a3->_IO_write_ptr[8 * (_DWORD)stream + 4];
              if ( n )
              {
                fwrite_unlocked(*(const void **)&a3->_IO_write_ptr[8 * (_DWORD)stream], 1u, n, stdout);
              }
              else if ( s1 )
              {
                fputs_unlocked(s1, stdout);
              }
            }
            return;
          }
          sub_804B3A5(stream, (int)&v83, 1, 1);
          byte_8059879 = 1;
        }
        if ( v80 > 0 )
          break;
        BYTE1(v74) = 0;
        if ( (unsigned __int8)sub_804B3A5(stream, (int)&v83, 0, 1) ^ 1 )
        {
          BYTE1(v74) = 1;
          ++v83;
        }
        else
        {
          v18 = dword_8059248;
          v19 = sub_804AD3C(v85[v83 + 0x3FFFFFFF], *(_DWORD *)n, dword_8059244, dword_8059248);
          v14 = v19 == 0;
          v68 = v19;
          v67 = (char *)v18;
          v21 = &loc_804C60C;
          if ( v14 )
            v21 = &loc_804C57F;
          dword_8059128 = (int)v21;
          a1 = (int)v67;
          sub_8053629(v20);
        }
        BYTE2(v74) = 0;
        while ( !((unsigned __int8)sub_804B3A5(a3, (int)&v86, 0, 2) ^ 1) )
        {
          a1 = dword_8059248;
          if ( sub_804AD3C(*v85, *(_DWORD *)(4 * (v86 + 0x3FFFFFFF) + n), dword_8059244, dword_8059248) )
            goto LABEL_114;
        }
        BYTE2(v74) = 1;
        ++v86;
LABEL_114:
        if ( byte_8059878 )
        {
          v76 = 0;
          if ( v83 - 1 > v76 )
          {
            v77 = 0;
            dword_805918C = (int)&loc_804C9ED;
            sub_80533FB();
            v22 = (int *)v85[v76];
            v70 = *(FILE **)n;
            v69 = v22;
            v68 = (int)&loc_804C9E9;
            v67 = (char *)&savedregs;
            if ( c < 0 )
              v23 = 32;
            else
              v23 = c;
            HIBYTE(v84) = v23;
            n = dword_8059895;
            if ( dword_8059895 )
            {
              v87 = (_DWORD *)n;
              v14 = *(_DWORD *)n == 0;
              v52 = *(FILE **)n;
              v51 = (FILE *)a1;
              v24 = &loc_804C735;
              if ( !v14 )
                v24 = &loc_804C75E;
              dword_80591F0 = (int)v24;
              sub_8053179(v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63, v64, v65, v66, v67, v68);
              if ( stream == (FILE *)&unk_805989D )
              {
                v86 = (int)a3;
                v85 = (int *)dword_8059248;
              }
              else
              {
                v86 = (int)stream;
                v85 = (int *)dword_8059244;
              }
              v70 = (FILE *)v86;
              v69 = v85;
              v68 = (int)&loc_804C85E;
              v67 = (char *)&savedregs;
              if ( a3->_IO_read_base <= (char *)stream )
              {
                if ( s1 )
                  fputs_unlocked(s1, stdout);
              }
              else
              {
                v25 = *(_DWORD *)&a3->_IO_write_ptr[8 * (_DWORD)stream + 4];
                n = v25;
                v14 = v25 == 0;
                v56 = (char *)v25;
                v55 = v51;
                v26 = &loc_804C7D8;
                if ( v14 )
                  v26 = &loc_804C80B;
                dword_80591B4 = (int)v26;
                sub_80532E9();
                fwrite_unlocked(*(const void **)&a3->_IO_write_ptr[8 * (_DWORD)stream], 1u, n, stdout);
              }
            }
            else
            {
              if ( stream == (FILE *)&unk_805989D )
              {
                v86 = (int)a3;
                v85 = (int *)dword_8059248;
              }
              else
              {
                v86 = (int)stream;
                v85 = (int *)dword_8059244;
              }
              v54 = v86;
              v53 = v85;
              v52 = (FILE *)&loc_804C997;
              v51 = (FILE *)&savedregs;
              if ( a3->_IO_read_base <= (char *)stream )
              {
                if ( s1 )
                  fputs_unlocked(s1, stdout);
              }
              else
              {
                n = *(_DWORD *)&a3->_IO_write_ptr[8 * (_DWORD)stream + 4];
                if ( n )
                {
                  fwrite_unlocked(*(const void **)&a3->_IO_write_ptr[8 * (_DWORD)stream], 1u, n, stdout);
                }
                else if ( s1 )
                {
                  fputs_unlocked(s1, stdout);
                }
              }
            }
            return;
          }
        }
        if ( BYTE1(v74) == 1 )
        {
          v83 = 0;
        }
        else
        {
          v81 = *v85;
          *v85 = v85[v83 + 0x3FFFFFFF];
          v85[v83 + 0x3FFFFFFF] = v81;
          v83 = 1;
        }
        v68 = BYTE2(v74) ^ 1;
        v67 = (char *)a1;
        v27 = &loc_804CA84;
        if ( BYTE2(v74) == 1 )
          v27 = &loc_804CAC3;
        dword_805918C = (int)v27;
        a1 = (int)v67;
        sub_80533FB();
        v82 = *(FILE **)n;
        *(_DWORD *)n = *(_DWORD *)(4 * (v86 + 0x3FFFFFFF) + n);
        *(_DWORD *)(n + 4 * (v86 + 0x3FFFFFFF)) = v82;
        v86 = 1;
      }
      if ( byte_8059877 )
        break;
      sub_804B3A5(a3, (int)&v86, 1, 2);
      byte_8059879 = 1;
    }
    v70 = *(FILE **)n;
    v69 = (int *)&unk_805989D;
    dword_8059114 = (int)&loc_804C225;
    sub_8053699(&loc_804C54D);
    v68 = (int)&savedregs;
    if ( c < 0 )
      v13 = 32;
    else
      v13 = c;
    HIBYTE(v84) = v13;
    n = dword_8059895;
    if ( dword_8059895 )
    {
      v87 = (_DWORD *)n;
      v14 = *(_DWORD *)n == 0;
      v53 = *(int **)n;
      v52 = (FILE *)a1;
      v15 = &loc_804C27D;
      if ( !v14 )
        v15 = &loc_804C2A6;
      dword_805913C = (int)v15;
      sub_80535C1(v54, v55, v56, v57, v58, v59, v60, v61, v62, v63, v64, v65, v66, v67, v68);
      if ( stream == (FILE *)&unk_805989D )
      {
        v86 = (int)a3;
        v85 = (int *)dword_8059248;
      }
      else
      {
        v86 = (int)stream;
        v85 = (int *)dword_8059244;
      }
      v70 = (FILE *)v86;
      v69 = v85;
      v68 = (int)&loc_804C3B2;
      v67 = (char *)&savedregs;
      if ( a3->_IO_read_base <= (char *)stream )
      {
        if ( s1 )
          fputs_unlocked(s1, stdout);
      }
      else
      {
        n = *(_DWORD *)&a3->_IO_write_ptr[8 * (_DWORD)stream + 4];
        if ( n )
        {
          fwrite_unlocked(*(const void **)&a3->_IO_write_ptr[8 * (_DWORD)stream], 1u, n, stdout);
        }
        else
        {
          v56 = s1;
          v55 = v52;
          v16 = &loc_804C375;
          if ( !s1 )
            v16 = &locret_804C3AE;
          dword_80591B4 = (int)v16;
          sub_80532E9();
          fputs_unlocked(s1, stdout);
        }
      }
      return;
    }
    v53 = (int *)dword_8059895;
    v52 = (FILE *)a1;
    v17 = &loc_804C40B;
    if ( stream != (FILE *)&unk_805989D )
      v17 = &loc_804C41B;
    dword_8059150 = (int)v17;
    sub_805354B(v54, v55, v56, v57, v58, v59, v60, v61, v62, v63, v64, v65, v66, v67, v68);
    v86 = (int)a3;
    v85 = (int *)dword_8059248;
    v70 = a3;
    v69 = (int *)dword_8059248;
    dword_8059204 = (int)&loc_804C44A;
    sub_80530F0(&loc_804C4FB);
    v68 = (int)&savedregs;
    if ( a3->_IO_read_base <= (char *)stream )
      goto LABEL_101;
    n = *(_DWORD *)&a3->_IO_write_ptr[8 * (_DWORD)stream + 4];
    if ( n )
    {
      fwrite_unlocked(*(const void **)&a3->_IO_write_ptr[8 * (_DWORD)stream], 1u, n, stdout);
      return;
    }
    if ( s1 )
    {
      fputs_unlocked(s1, stdout);
      dword_8059150 = (int)&locret_804C4F7;
      sub_805354B(v58, v59, v60, v61, v62, v63, v64, v65, v66, v67, v68, v69, v70, v71, v72);
LABEL_101:
      if ( s1 )
        fputs_unlocked(s1, stdout);
      return;
    }
  }
}
// 8048F50: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 80530F0: using guessed type int __stdcall sub_80530F0(_DWORD);
// 8053179: using guessed type int __stdcall sub_8053179(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80531E5: using guessed type int sub_80531E5(void);
// 805324D: using guessed type int sub_805324D(void);
// 80532E9: using guessed type int sub_80532E9(void);
// 8053376: using guessed type int __stdcall sub_8053376(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80533FB: using guessed type int sub_80533FB(void);
// 805346B: using guessed type int __stdcall sub_805346B(_DWORD);
// 805354B: using guessed type int __stdcall sub_805354B(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80535C1: using guessed type int __stdcall sub_80535C1(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8053629: using guessed type int __fastcall sub_8053629(_DWORD);
// 8053699: using guessed type int __stdcall sub_8053699(_DWORD);
// 8059114: using guessed type int dword_8059114;
// 8059128: using guessed type int dword_8059128;
// 805913C: using guessed type int dword_805913C;
// 8059150: using guessed type int dword_8059150;
// 8059164: using guessed type int dword_8059164;
// 8059178: using guessed type int dword_8059178;
// 805918C: using guessed type int dword_805918C;
// 80591A0: using guessed type int dword_80591A0;
// 80591B4: using guessed type int dword_80591B4;
// 80591C8: using guessed type int dword_80591C8;
// 80591DC: using guessed type int dword_80591DC;
// 80591F0: using guessed type int dword_80591F0;
// 8059204: using guessed type int dword_8059204;
// 8059244: using guessed type int dword_8059244;
// 8059248: using guessed type int dword_8059248;
// 8059876: using guessed type char byte_8059876;
// 8059877: using guessed type char byte_8059877;
// 8059878: using guessed type char byte_8059878;
// 8059879: using guessed type char byte_8059879;
// 805987B: using guessed type char byte_805987B;
// 8059881: using guessed type char byte_8059881;
// 8059885: using guessed type int dword_8059885;
// 8059889: using guessed type int dword_8059889;
// 8059895: using guessed type int dword_8059895;
// 8059899: using guessed type int dword_8059899;
// 80598B6: using guessed type char byte_80598B6;

//----- (0804D9F0) --------------------------------------------------------
#error "804DA99: call analysis failed (funcsize=47)"

//----- (0804DA9E) --------------------------------------------------------
#error "804DADC: positive sp value has been found (funcsize=0)"

//----- (0804DADD) --------------------------------------------------------
int __cdecl sub_804DADD(char *nptr)
{
  int v1; // eax
  bool v2; // zf
  void *v3; // eax
  int v5; // [esp+0h] [ebp-38h]
  int v6; // [esp+4h] [ebp-34h]
  int v7; // [esp+8h] [ebp-30h]
  int v8; // [esp+Ch] [ebp-2Ch]
  int v9; // [esp+10h] [ebp-28h]
  int v10; // [esp+14h] [ebp-24h]
  int v11; // [esp+18h] [ebp-20h]
  int v12; // [esp+1Ch] [ebp-1Ch]
  int v13; // [esp+20h] [ebp-18h]
  int v14; // [esp+24h] [ebp-14h]
  int v15; // [esp+28h] [ebp-10h]
  int v16; // [esp+2Ch] [ebp-Ch]
  int v17; // [esp+30h] [ebp-8h]
  int v18; // [esp+34h] [ebp-4h]
  int savedregs; // [esp+38h] [ebp+0h]

  v1 = sub_805188A(nptr, 0, 10, (int)&v14, &s);
  v15 = v1;
  v2 = v1 == 1;
  v3 = &loc_804DB30;
  if ( !v2 )
    v3 = &loc_804DB39;
  dword_805913C = (int)v3;
  sub_80535C1(v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, savedregs);
  return -2;
}
// 80535C1: using guessed type int __stdcall sub_80535C1(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 805913C: using guessed type int dword_805913C;

//----- (0804DB8D) --------------------------------------------------------
#error "804DCD8: call analysis failed (funcsize=92)"

//----- (0804DD18) --------------------------------------------------------
#error "804DD8D: call analysis failed (funcsize=45)"

//----- (0804DDB0) --------------------------------------------------------
#error "804DDEE: call analysis failed (funcsize=49)"

//----- (0804DE43) --------------------------------------------------------
_DWORD *__cdecl sub_804DE43(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, signed int *a5, _DWORD *a6, _DWORD *a7)
{
  int v7; // eax
  bool v8; // zf
  bool v9; // sf
  unsigned __int8 v10; // of
  void *v11; // eax
  void *v12; // eax
  int v13; // eax
  _DWORD *result; // eax
  bool v15; // [esp+17h] [ebp-11h]
  signed int v16; // [esp+18h] [ebp-10h]
  char *nptr; // [esp+1Ch] [ebp-Ch]

  v16 = *a5;
  if ( *a5 == 2 )
  {
    v15 = *a3 == 0;
    nptr = (char *)a2[v15];
    v7 = a3[v15];
    if ( v7 == 1 )
    {
      --*a4;
      v13 = sub_804DADD(nptr);
      sub_804DDB0(&dword_8059244, v13);
    }
    else
    {
      v10 = __OFSUB__(v7, 1);
      v8 = v7 == 1;
      v9 = v7 - 1 < 0;
      v11 = &loc_804DEB7;
      if ( !((unsigned __int8)(v9 ^ v10) | v8) )
        v11 = &loc_804DED9;
      dword_8059164 = (int)v11;
      v8 = sub_80534D5() == 0;
      v12 = &loc_804DED4;
      if ( v8 )
        v12 = &loc_804DF05;
      dword_8059164 = (int)v12;
      sub_80534D5();
    }
    if ( v15 != 1 )
    {
      *a3 = a3[1];
      *a2 = a2[1];
    }
    v16 = 1;
  }
  a3[v16] = *a6;
  a2[v16] = a1;
  *a5 = v16 + 1;
  result = (_DWORD *)*a6;
  if ( *a6 == 3 )
  {
    result = a7;
    *a7 = 3;
  }
  return result;
}
// 804DDB0: using guessed type _DWORD __cdecl sub_804DDB0(_DWORD, _DWORD);
// 8059164: using guessed type int dword_8059164;
// 8059244: using guessed type int dword_8059244;

//----- (0804E023) --------------------------------------------------------
_BOOL4 __cdecl main(int argc, char **argv)
{
  void *v2; // eax
  int v3; // eax
  bool v4; // zf
  void *v5; // eax
  void *v6; // eax
  void *v7; // eax
  int v8; // eax
  void *v9; // eax
  char *v10; // eax
  int v11; // eax
  int v12; // eax
  void *v13; // eax
  char *v14; // eax
  void *v15; // eax
  void *v16; // ebx
  int *v17; // eax
  FILE *v18; // eax
  void *v19; // eax
  const char *v20; // ebx
  int *v21; // eax
  int *v22; // eax
  const char *v23; // ebx
  int *v24; // eax
  void *v25; // eax
  void *v26; // ebx
  int *v27; // eax
  int v29; // [esp+0h] [ebp-64h]
  int v30; // [esp+0h] [ebp-64h]
  int v31; // [esp+0h] [ebp-64h]
  int v32; // [esp+4h] [ebp-60h]
  int v33; // [esp+4h] [ebp-60h]
  int v34; // [esp+8h] [ebp-5Ch]
  int v35; // [esp+8h] [ebp-5Ch]
  void *v36; // [esp+Ch] [ebp-58h]
  const char *v37; // [esp+Ch] [ebp-58h]
  int v38; // [esp+10h] [ebp-54h]
  int v39; // [esp+10h] [ebp-54h]
  int v40; // [esp+14h] [ebp-50h]
  int v41; // [esp+14h] [ebp-50h]
  int v42; // [esp+18h] [ebp-4Ch]
  int v43; // [esp+18h] [ebp-4Ch]
  int v44; // [esp+1Ch] [ebp-48h]
  int v45; // [esp+1Ch] [ebp-48h]
  int v46; // [esp+20h] [ebp-44h]
  int v47; // [esp+20h] [ebp-44h]
  int v48; // [esp+24h] [ebp-40h]
  int v49; // [esp+24h] [ebp-40h]
  int v50; // [esp+28h] [ebp-3Ch]
  int v51; // [esp+28h] [ebp-3Ch]
  int v52; // [esp+2Ch] [ebp-38h]
  int v53; // [esp+2Ch] [ebp-38h]
  int v54; // [esp+30h] [ebp-34h]
  int v55; // [esp+34h] [ebp-30h]
  int v56; // [esp+38h] [ebp-2Ch]
  int v57; // [esp+3Ch] [ebp-28h]
  int v58; // [esp+40h] [ebp-24h]
  int v59; // [esp+44h] [ebp-20h]
  FILE *v60; // [esp+48h] [ebp-1Ch]
  FILE *v61; // [esp+4Ch] [ebp-18h]
  int v62; // [esp+50h] [ebp-14h]
  int v63; // [esp+58h] [ebp-Ch]
  int v64; // [esp+5Ch] [ebp-8h]

  v55 = 0;
  v63 = 0;
  v64 = 0;
  v56 = 0;
  sub_804F063(*argv);
  setlocale(6, &s);
  bindtextdomain("coreutils", "/home/hwangdz/coreutils/coreutils-8.28/install_m32/share/locale");
  textdomain("coreutils");
  byte_8059875 = sub_804EDDA(3);
  sub_8052ED9((int)sub_804EAFA);
  sub_8052ED9((int)sub_804B22B);
  byte_8059878 = 1;
  byte_8059879 = 0;
  byte_805987B = 0;
  byte_805987A[0] = 0;
  dword_8059899 = 0;
  while ( 1 )
  {
    v59 = getopt_long(argc, argv, "-a:e:i1:2:j:o:t:v:z", &longopts, 0);
    if ( v59 == -1 )
      break;
    v54 = 0;
    if ( v59 == 105 )
    {
      byte_80598B5 = 1;
    }
    else
    {
      v2 = &loc_804E11A;
      if ( v59 > 105 )
        v2 = &loc_804E1C0;
      dword_80591C8 = (int)v2;
      v3 = sub_805324D();
      if ( v3 == 49 )
      {
        v11 = sub_804DADD(optarg);
        sub_804DDB0(&dword_8059244, v11);
      }
      else
      {
        if ( v3 <= 49 )
        {
          v4 = v3 == -130;
          v5 = &loc_804E148;
          if ( v4 )
            v5 = &loc_804E63D;
          dword_80591B4 = (int)v5;
          v4 = sub_80532E9() == 1;
          v6 = &loc_804E166;
          if ( v4 )
            v6 = &loc_804E5F5;
          dword_80591B4 = (int)v6;
          if ( sub_80532E9() == -131 )
          {
            sub_80512A6(stdout, (int)"join", (int)"GNU coreutils", off_8059258, "Mike Haertel", 0);
            exit(0);
          }
          goto LABEL_27;
        }
        v4 = v3 == 97;
        v7 = &loc_804E194;
        if ( v4 )
          v7 = &loc_804E277;
        dword_8059164 = (int)v7;
        v8 = sub_80534D5();
        if ( v8 != 101 )
        {
          v4 = v8 == 50;
          v9 = &loc_804E1BB;
          if ( v4 )
            v9 = &loc_804E3B0;
          dword_8059178 = (int)v9;
          sub_805346B(v29);
LABEL_27:
          sub_804A90C(1);
        }
        if ( s1 && strcmp(s1, optarg) )
        {
          v10 = gettext("conflicting empty-field replacement strings");
          error(1, 0, v10);
        }
        s1 = optarg;
      }
    }
    v55 = v54;
  }
  v55 = 0;
  while ( optind < argc )
  {
    v12 = optind++;
    sub_804DE43((int)argv[v12], &dword_8059865, &v62, &v63, &v56, &v55, &v54);
  }
  if ( v56 != 2 )
  {
    v13 = &loc_804E76F;
    if ( v56 )
      v13 = &loc_804E795;
    dword_8059178 = (int)v13;
    sub_805346B(v29);
    v14 = gettext("missing operand");
    error(0, 0, v14);
    sub_804A90C(1);
  }
  v58 = 0;
  dword_80591DC = (int)&loc_804E839;
  sub_80531E5();
  do
  {
    if ( *(&v63 + v58) )
    {
      sub_804DDB0(&dword_8059244, v58);
      sub_804DDB0(&dword_8059248, v58);
    }
    ++v58;
  }
  while ( v58 <= 1 );
  if ( dword_8059244 == -1 )
    dword_8059244 = 0;
  v15 = &loc_804E877;
  if ( dword_8059248 != -1 )
    v15 = &loc_804E881;
  dword_80591B4 = (int)v15;
  sub_80532E9();
  dword_8059248 = 0;
  if ( strcmp(dword_8059865, "-") )
  {
    sub_804ECF2((int)dword_8059865, "r");
    dword_8059164 = (int)&loc_804E8C3;
    sub_80534D5();
  }
  v60 = (FILE *)stdin;
  if ( !stdin )
  {
    v16 = sub_8050A2C(0, 3, (int)dword_8059865);
    v17 = __errno_location();
    v36 = v16;
    error(1, *v17, "%s");
  }
  if ( !strcmp(dword_8059869, "-") )
    v18 = (FILE *)stdin;
  else
    v18 = sub_804ECF2((int)dword_8059869, "r");
  v61 = v18;
  v4 = v18 == 0;
  v19 = &loc_804E969;
  if ( !v4 )
    v19 = &loc_804E9AB;
  dword_8059150 = (int)v19;
  sub_805354B(v30, v32, v34, v36, v38, v40, v42, v44, v46, v48, v50, v52, v54, v55, v56);
  v20 = (const char *)sub_8050A2C(0, 3, (int)dword_8059869);
  v21 = __errno_location();
  v37 = v20;
  error(1, *v21, "%s");
  if ( v60 == v61 )
  {
    v20 = gettext("both files cannot be standard input");
    v22 = __errno_location();
    error(1, *v22, v20);
  }
  sub_804BA28((int)v20, v60, v61);
  if ( sub_8051D01(v60) )
  {
    v23 = (const char *)sub_8050A2C(0, 3, (int)dword_8059865);
    v24 = __errno_location();
    v37 = v23;
    error(1, *v24, "%s");
  }
  v4 = sub_8051D01(v61) == 0;
  v25 = &loc_804EA6D;
  if ( v4 )
    v25 = &loc_804EAAF;
  dword_80591A0 = (int)v25;
  sub_8053376(v31, v33, v35, v37, v39, v41, v43, v45, v47, v49, v51, v53, v54, v55, v56, v57);
  v26 = sub_8050A2C(0, 3, (int)dword_8059869);
  v27 = __errno_location();
  error(1, *v27, "%s", v26);
  return byte_805987A[0] || byte_805987B;
}
// 804DDB0: using guessed type _DWORD __cdecl sub_804DDB0(_DWORD, _DWORD);
// 804EAFA: using guessed type void __noreturn sub_804EAFA();
// 80531E5: using guessed type int sub_80531E5(void);
// 805324D: using guessed type int sub_805324D(void);
// 80532E9: using guessed type int sub_80532E9(void);
// 8053376: using guessed type int __stdcall sub_8053376(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 805346B: using guessed type int __stdcall sub_805346B(_DWORD);
// 805354B: using guessed type int __stdcall sub_805354B(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8059150: using guessed type int dword_8059150;
// 8059164: using guessed type int dword_8059164;
// 8059178: using guessed type int dword_8059178;
// 80591A0: using guessed type int dword_80591A0;
// 80591B4: using guessed type int dword_80591B4;
// 80591C8: using guessed type int dword_80591C8;
// 80591DC: using guessed type int dword_80591DC;
// 8059244: using guessed type int dword_8059244;
// 8059248: using guessed type int dword_8059248;
// 8059300: using guessed type int optind;
// 8059320: using guessed type int stdin;
// 8059875: using guessed type char byte_8059875;
// 8059878: using guessed type char byte_8059878;
// 8059879: using guessed type char byte_8059879;
// 805987B: using guessed type char byte_805987B;
// 8059899: using guessed type int dword_8059899;
// 80598B5: using guessed type char byte_80598B5;

//----- (0804EAFA) --------------------------------------------------------
#error "804EB59: call analysis failed (funcsize=65)"

//----- (0804EBF1) --------------------------------------------------------
#error "804EBF9: call analysis failed (funcsize=16)"

//----- (0804EC28) --------------------------------------------------------
#error "804EC2B: positive sp value has been found (funcsize=0)"

//----- (0804EC2E) --------------------------------------------------------
int __cdecl sub_804EC2E(int a1, int a2, int a3, int a4, int a5, int a6)
{
  return posix_fadvise64(a1, a2, a3, a4, a5, a6);
}
// 80490B0: using guessed type int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804EC7F) --------------------------------------------------------
int __cdecl sub_804EC7F(FILE *stream, int a2)
{
  void *v2; // eax
  int v3; // eax
  int v5; // [esp+0h] [ebp-28h]

  v2 = &loc_804ECA4;
  if ( !stream )
    v2 = &locret_804ECDE;
  dword_8059178 = (int)v2;
  sub_805346B(v5);
  v3 = fileno(stream);
  return sub_804EC2E(v3, 0, 0, 0, 0, a2);
}
// 805346B: using guessed type int __stdcall sub_805346B(_DWORD);
// 8059178: using guessed type int dword_8059178;

//----- (0804ECF2) --------------------------------------------------------
FILE *__cdecl sub_804ECF2(int a1, char *modes)
{
  int v2; // ST28_4
  int v4; // ST2C_4
  FILE *stream; // [esp+1Ch] [ebp-1Ch]
  signed int v6; // [esp+20h] [ebp-18h]
  int fd; // [esp+24h] [ebp-14h]

  stream = (FILE *)fopen64(a1, modes);
  if ( !stream )
    return stream;
  v6 = fileno(stream);
  if ( v6 < 0 || v6 > 2 )
    return stream;
  fd = sub_8050CA1(v6);
  if ( fd < 0 )
  {
    v2 = *__errno_location();
    sub_8051D01(stream);
    *__errno_location() = v2;
    return 0;
  }
  if ( !sub_8051D01(stream) )
  {
    stream = fdopen(fd, modes);
    if ( stream )
      return stream;
  }
  v4 = *__errno_location();
  close(fd);
  *__errno_location() = v4;
  return 0;
}
// 8048E40: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (0804EDDA) --------------------------------------------------------
int __cdecl sub_804EDDA(int category)
{
  unsigned __int8 v2; // [esp+1Bh] [ebp-Dh]
  const char *s1; // [esp+1Ch] [ebp-Ch]

  v2 = 1;
  s1 = setlocale(category, 0);
  if ( s1 && (!strcmp(s1, "C") || !strcmp(s1, "POSIX")) )
    v2 = 0;
  return v2;
}

//----- (0804EE7D) --------------------------------------------------------
int __cdecl sub_804EE7D(int a1, FILE *stream, int a3)
{
  bool v4; // zf
  void *v5; // eax
  _BYTE *v6; // eax
  int v7; // [esp+0h] [ebp-38h]
  int v8; // [esp+4h] [ebp-34h]
  int v9; // [esp+8h] [ebp-30h]
  int v10[4]; // [esp+Ch] [ebp-2Ch]
  int v11; // [esp+10h] [ebp-28h]
  int v12; // [esp+14h] [ebp-24h]
  int v13; // [esp+18h] [ebp-20h]
  int v14; // [esp+1Ch] [ebp-1Ch]
  char *ptr; // [esp+20h] [ebp-18h]
  int v16; // [esp+24h] [ebp-14h]
  int v17; // [esp+28h] [ebp-10h]
  int v18; // [esp+2Ch] [ebp-Ch]
  int v19; // [esp+30h] [ebp-8h]
  int v20; // [esp+34h] [ebp-4h]
  int savedregs; // [esp+38h] [ebp+0h]

  LOBYTE(v10[0]) = a3;
  ptr = *(char **)(a1 + 8);
  v16 = *(_DWORD *)(a1 + 8);
  v17 = (int)&ptr[*(_DWORD *)a1];
  if ( feof_unlocked(stream) )
    return 0;
  while ( 1 )
  {
    v14 = getc_unlocked(stream);
    if ( v14 == -1 )
      break;
    if ( v16 == v17 )
    {
      v18 = *(_DWORD *)a1;
      ptr = (char *)sub_8051548(ptr, a1);
      v16 = (int)&ptr[v18];
      *(_DWORD *)(a1 + 8) = ptr;
      v17 = (int)&ptr[*(_DWORD *)a1];
    }
    v6 = (_BYTE *)v16++;
    *v6 = v14;
    if ( (char)a3 == v14 )
    {
      *(_DWORD *)(a1 + 4) = v16 - (_DWORD)ptr;
      return a1;
    }
  }
  if ( (char *)v16 != ptr )
  {
    v4 = ferror_unlocked(stream) == 0;
    v5 = &loc_804EF05;
    if ( v4 )
      v5 = &loc_804EF0F;
    dword_8059150 = (int)v5;
    sub_805354B(v7, v8, v9, v10[0], v11, v12, v13, -1, ptr, v16, v17, v18, v19, v20, savedregs);
  }
  return 0;
}
// 805354B: using guessed type int __stdcall sub_805354B(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8059150: using guessed type int dword_8059150;

//----- (0804EFD1) --------------------------------------------------------
int __cdecl sub_804EFD1(int a1, int a2, unsigned int a3)
{
  unsigned __int8 v3; // ST17_1
  int v4; // eax
  unsigned int i; // [esp+18h] [ebp-20h]
  int v7; // [esp+24h] [ebp-14h]

  for ( i = 0; i < a3; ++i )
  {
    v3 = *(_BYTE *)(a2 + i);
    v7 = toupper(*(unsigned __int8 *)(a1 + i));
    v4 = toupper(v3);
    if ( v7 != v4 )
      return v7 - v4;
  }
  return 0;
}

//----- (0804F063) --------------------------------------------------------
char *__cdecl sub_804F063(char *s)
{
  char *v1; // eax
  bool v2; // zf
  void *v3; // eax
  char *result; // eax
  char *v5; // [esp+18h] [ebp-10h]
  char *s1; // [esp+1Ch] [ebp-Ch]

  if ( !s )
  {
    fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
    abort();
  }
  v5 = strrchr(s, 47);
  if ( v5 )
    v1 = v5 + 1;
  else
    v1 = s;
  s1 = v1;
  if ( v1 - s > 6 )
  {
    v2 = strncmp(v1 - 7, "/.libs/", 7u) == 0;
    v3 = &loc_804F10D;
    if ( !v2 )
      v3 = &loc_804F143;
    dword_8059164 = (int)v3;
    sub_80534D5();
    s = s1;
    if ( !strncmp(s1, "lt-", 3u) )
    {
      s = s1 + 3;
      program_invocation_short_name = (int)(s1 + 3);
    }
  }
  dword_80598C1 = (int)s;
  result = s;
  program_invocation_name = (int)s;
  return result;
}
// 8059164: using guessed type int dword_8059164;
// 80592E0: using guessed type int program_invocation_short_name;
// 80592F0: using guessed type int program_invocation_name;
// 80598C1: using guessed type int dword_80598C1;

//----- (0804F1EF) --------------------------------------------------------
int __cdecl sub_804F1EF(int *a1, unsigned __int8 a2, char a3)
{
  int *v3; // eax
  int v4; // ST10_4

  if ( a1 )
    v3 = a1;
  else
    v3 = &dword_80598DD;
  v4 = ((unsigned int)v3[(a2 >> 5) + 2] >> (a2 & 0x1F)) & 1;
  v3[(a2 >> 5) + 2] ^= (v4 ^ a3 & 1) << (a2 & 0x1F);
  return v4;
}
// 80598DD: using guessed type int dword_80598DD;

//----- (0804F2C2) --------------------------------------------------------
int *__cdecl sub_804F2C2(int *a1, int a2, int a3)
{
  int *result; // eax

  if ( !a1 )
    a1 = &dword_80598DD;
  *a1 = 10;
  if ( !a2 || !a3 )
    abort();
  a1[10] = a2;
  result = a1;
  a1[11] = a3;
  return result;
}
// 80598DD: using guessed type int dword_80598DD;

//----- (0804F303) --------------------------------------------------------
_DWORD *__userpurge sub_804F303@<eax>(_DWORD *a1, int a2)
{
  int v3; // [esp+0h] [ebp-38h]
  int v4; // [esp+4h] [ebp-34h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]

  memset(&v3, 0, 0x30u);
  if ( a2 == 10 )
    abort();
  *a1 = a2;
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = v6;
  a1[4] = v7;
  a1[5] = v8;
  a1[6] = v9;
  a1[7] = v10;
  a1[8] = v11;
  a1[9] = v12;
  a1[10] = v13;
  a1[11] = v14;
  return a1;
}

//----- (0804F385) --------------------------------------------------------
char *__cdecl sub_804F385(char *msgid)
{
  char *v2; // [esp+18h] [ebp-10h]

  v2 = gettext(msgid);
  if ( v2 == msgid )
    sub_80528AA();
  return v2;
}

//----- (0804F465) --------------------------------------------------------
unsigned int __cdecl sub_804F465(int a1, unsigned int a2, int a3, size_t a4, int a5, int a6, int a7, char *a8, char *a9)
{
  int v9; // ecx
  void *v10; // eax
  void *v11; // eax
  void *v12; // eax
  size_t v13; // eax
  void *v14; // eax
  void *v15; // eax
  void *v16; // eax
  void *v17; // eax
  void *v18; // eax
  bool v19; // al
  bool v20; // zf
  void *v21; // eax
  int v22; // ST08_4
  void *v23; // eax
  void *v24; // eax
  void *v25; // eax
  void *v26; // eax
  void *v27; // eax
  void *v28; // eax
  void *v29; // eax
  bool v30; // al
  void *v31; // eax
  unsigned int result; // eax
  size_t v33; // [esp-8h] [ebp-90h]
  int v34; // [esp+0h] [ebp-88h]
  int v35; // [esp+0h] [ebp-88h]
  int v36; // [esp+0h] [ebp-88h]
  int v37; // [esp+4h] [ebp-84h]
  int v38; // [esp+4h] [ebp-84h]
  int v39; // [esp+4h] [ebp-84h]
  int v40; // [esp+8h] [ebp-80h]
  int v41; // [esp+8h] [ebp-80h]
  int v42; // [esp+8h] [ebp-80h]
  int v43; // [esp+Ch] [ebp-7Ch]
  int v44; // [esp+Ch] [ebp-7Ch]
  int v45; // [esp+10h] [ebp-78h]
  int v46; // [esp+10h] [ebp-78h]
  int v47; // [esp+14h] [ebp-74h]
  int v48; // [esp+14h] [ebp-74h]
  int v49; // [esp+18h] [ebp-70h]
  int v50; // [esp+18h] [ebp-70h]
  int v51; // [esp+1Ch] [ebp-6Ch]
  int v52; // [esp+1Ch] [ebp-6Ch]
  int v53; // [esp+20h] [ebp-68h]
  int v54; // [esp+20h] [ebp-68h]
  int v55; // [esp+24h] [ebp-64h]
  int v56; // [esp+24h] [ebp-64h]
  int v57; // [esp+28h] [ebp-60h]
  int v58; // [esp+28h] [ebp-60h]
  char *v59; // [esp+2Ch] [ebp-5Ch]
  int v60; // [esp+2Ch] [ebp-5Ch]
  char *v61; // [esp+30h] [ebp-58h]
  int v62; // [esp+30h] [ebp-58h]
  int v63; // [esp+34h] [ebp-54h]
  int v64; // [esp+34h] [ebp-54h]
  char *v65; // [esp+38h] [ebp-50h]
  char *v66; // [esp+38h] [ebp-50h]
  int v67; // [esp+3Ch] [ebp-4Ch]
  int v68; // [esp+3Ch] [ebp-4Ch]
  char v69; // [esp+40h] [ebp-48h]
  bool v70; // [esp+41h] [ebp-47h]
  char v71; // [esp+42h] [ebp-46h]
  char v72; // [esp+43h] [ebp-45h]
  char v73; // [esp+44h] [ebp-44h]
  unsigned __int8 v74; // [esp+45h] [ebp-43h]
  char v75; // [esp+47h] [ebp-41h]
  char v76; // [esp+48h] [ebp-40h]
  char v77; // [esp+49h] [ebp-3Fh]
  bool v78; // [esp+4Ah] [ebp-3Eh]
  bool v79; // [esp+4Bh] [ebp-3Dh]
  wint_t wc; // [esp+4Ch] [ebp-3Ch]
  int v81; // [esp+50h] [ebp-38h]
  unsigned int v82; // [esp+54h] [ebp-34h]
  unsigned int v83; // [esp+58h] [ebp-30h]
  char *s; // [esp+5Ch] [ebp-2Ch]
  size_t n; // [esp+60h] [ebp-28h]
  unsigned int v86; // [esp+64h] [ebp-24h]
  size_t v87; // [esp+6Ch] [ebp-1Ch]
  unsigned int v88; // [esp+70h] [ebp-18h]
  mbstate_t ps; // [esp+74h] [ebp-14h]
  unsigned int v90; // [esp+7Ch] [ebp-Ch]

  v67 = a1;
  v65 = (char *)a3;
  v63 = a7;
  v61 = a8;
  v59 = a9;
  v90 = __readgsdword(0x14u);
  v82 = 0;
  v83 = 0;
  s = 0;
  n = 0;
  v69 = 0;
  v79 = __ctype_get_mb_cur_max() == 1;
  v70 = (a6 & 2) != 0;
  v71 = 0;
  v72 = 0;
  v73 = 1;
  switch ( a5 )
  {
    case 0:
      v70 = 0;
      break;
    case 1:
      goto LABEL_19;
    case 2:
      goto LABEL_22;
    case 3:
      v69 = 1;
LABEL_19:
      v70 = 1;
      goto LABEL_20;
    case 4:
LABEL_20:
      if ( v70 != 1 )
        v69 = 1;
LABEL_22:
      a5 = 2;
      if ( v70 != 1 )
      {
        if ( v82 < a2 )
          *(_BYTE *)(a1 + v82) = 39;
        ++v82;
      }
      s = "'";
      n = 1;
      break;
    case 5:
      goto LABEL_3;
    case 6:
      a5 = 5;
      v70 = 1;
LABEL_3:
      v10 = &loc_804F526;
      if ( v70 == 1 )
        v10 = &loc_804F53D;
      dword_8059114 = (int)v10;
      sub_8053699(v34);
      if ( v82 < a2 )
        *(_BYTE *)(a1 + v82) = 34;
      ++v82;
      v69 = 1;
      s = (char *)&unk_8054655;
      n = 1;
      break;
    case 7:
      v69 = 1;
      v70 = 0;
      break;
    case 8:
    case 9:
    case 10:
      v11 = &loc_804F580;
      if ( a5 == 10 )
        v11 = &loc_804F5AC;
      dword_8059150 = (int)v11;
      sub_805354B(v34, v37, v40, v43, v45, v47, v49, v51, v53, v55, v57, a9, a8, a7, a3);
      v61 = sub_804F385("`");
      v37 = a5;
      v59 = sub_804F385("'");
      if ( v70 != 1 )
      {
        for ( s = v61; *s; ++s )
        {
          if ( v82 < a2 )
            *(_BYTE *)(v82 + a1) = *s;
          ++v82;
        }
      }
      v69 = 1;
      s = v59;
      n = strlen(v59);
      break;
    default:
      abort();
      return result;
  }
  v81 = 0;
  while ( 2 )
  {
    if ( a4 == -1 )
      v30 = v65[v81] != 0;
    else
      v30 = v81 != a4;
    if ( !v30 )
    {
      if ( !v82 && a5 == 2 && v70 )
        goto LABEL_201;
      if ( a5 == 2 && v70 != 1 && v72 )
      {
        v31 = &loc_80501B8;
        if ( !v73 )
          v31 = &loc_8050201;
        dword_80591C8 = (int)v31;
        sub_805324D();
        result = sub_804F465(v67, v83, (int)v65, a4, 5, a6, v63, v61, v59);
      }
      else
      {
        if ( s && v70 != 1 )
        {
          while ( *s )
          {
            if ( v82 < a2 )
              *(_BYTE *)(v82 + v67) = *s;
            ++v82;
            ++s;
          }
        }
        if ( v82 < a2 )
          *(_BYTE *)(v67 + v82) = 0;
        result = v82;
      }
      return result;
    }
    v75 = 0;
    v76 = 0;
    v77 = 0;
    if ( v69 && a5 != 2 && n )
    {
      v33 = v81 + n;
      v12 = &loc_804F6BC;
      if ( a4 != -1 )
        v12 = &loc_804F6D5;
      dword_80591A0 = (int)v12;
      sub_8053376(v34, v37, v40, v43, v45, v47, v49, v51, v53, v55, v57, v59, v61, v63, v65, v67);
      if ( n <= 1 )
      {
        v13 = a4;
      }
      else
      {
        v13 = strlen(v65);
        a4 = v13;
      }
      if ( v33 <= v13 && !memcmp(&v65[v81], s, n) )
      {
        if ( v70 )
        {
          dword_8059128 = (int)&loc_805028D;
          sub_8053629(v9);
        }
        v75 = 1;
      }
    }
    v74 = v65[v81];
    switch ( v74 )
    {
      case 0u:
        if ( v69 )
        {
          v14 = &loc_804F764;
          if ( !v70 )
            v14 = &loc_804F769;
          dword_8059164 = (int)v14;
          sub_80534D5();
          goto LABEL_201;
        }
        v15 = &loc_804F89C;
        if ( !(a6 & 1) )
          v15 = &loc_804F8A1;
        dword_8059128 = (int)v15;
        sub_8053629(v9);
        goto LABEL_177;
      case 7u:
      case 8u:
      case 0xBu:
        goto LABEL_76;
      case 9u:
      case 0xAu:
        goto LABEL_74;
      case 0xCu:
        dword_8059178 = (int)&loc_804FA7F;
        sub_805346B(v34);
        goto LABEL_74;
      case 0xDu:
        dword_8059128 = (int)&loc_804FA6E;
        sub_8053629(v9);
        goto LABEL_74;
      case 0x20u:
        goto LABEL_86;
      case 0x21u:
      case 0x22u:
      case 0x24u:
      case 0x26u:
      case 0x28u:
      case 0x29u:
      case 0x2Au:
      case 0x3Bu:
      case 0x3Cu:
      case 0x3Du:
      case 0x3Eu:
      case 0x5Bu:
      case 0x5Eu:
      case 0x60u:
      case 0x7Cu:
        goto LABEL_87;
      case 0x23u:
      case 0x7Eu:
        goto LABEL_85;
      case 0x25u:
      case 0x2Bu:
      case 0x2Cu:
      case 0x2Du:
      case 0x2Eu:
      case 0x2Fu:
      case 0x30u:
      case 0x31u:
      case 0x32u:
      case 0x33u:
      case 0x34u:
      case 0x35u:
      case 0x36u:
      case 0x37u:
      case 0x38u:
      case 0x39u:
      case 0x3Au:
      case 0x41u:
      case 0x42u:
      case 0x43u:
      case 0x44u:
      case 0x45u:
      case 0x46u:
      case 0x47u:
      case 0x48u:
      case 0x49u:
      case 0x4Au:
      case 0x4Bu:
      case 0x4Cu:
      case 0x4Du:
      case 0x4Eu:
      case 0x4Fu:
      case 0x50u:
      case 0x51u:
      case 0x52u:
      case 0x53u:
      case 0x54u:
      case 0x55u:
      case 0x56u:
      case 0x57u:
      case 0x58u:
      case 0x59u:
      case 0x5Au:
      case 0x5Du:
      case 0x5Fu:
      case 0x61u:
      case 0x62u:
      case 0x63u:
      case 0x64u:
      case 0x65u:
      case 0x66u:
      case 0x67u:
      case 0x68u:
      case 0x69u:
      case 0x6Au:
      case 0x6Bu:
      case 0x6Cu:
      case 0x6Du:
      case 0x6Eu:
      case 0x6Fu:
      case 0x70u:
      case 0x71u:
      case 0x72u:
      case 0x73u:
      case 0x74u:
      case 0x75u:
      case 0x76u:
      case 0x77u:
      case 0x78u:
      case 0x79u:
      case 0x7Au:
        dword_80591B4 = (int)&loc_804FF9D;
        sub_80532E9();
        goto LABEL_105;
      case 0x27u:
        v72 = 1;
        v77 = 1;
        if ( a5 == 2 )
        {
          v23 = &loc_804FB58;
          if ( !v70 )
            v23 = &loc_804FB67;
          dword_80591B4 = (int)v23;
          sub_80532E9();
          dword_805913C = (int)&loc_805028D;
          sub_80535C1(v34, v37, v40, v43, v45, v47, v49, v51, v53, v55, v57, v59, v61, v63, v65);
          if ( a2 && !v83 )
          {
            v83 = a2;
            a2 = 0;
          }
          if ( v82 < a2 )
            *(_BYTE *)(v67 + v82) = 39;
          if ( ++v82 < a2 )
            *(_BYTE *)(v67 + v82) = 92;
          if ( ++v82 < a2 )
            *(_BYTE *)(v67 + v82) = 39;
          ++v82;
          v71 = 0;
        }
        goto LABEL_153;
      case 0x3Fu:
        if ( a5 == 2 )
          goto LABEL_54;
        if ( a5 == 5 )
        {
          if ( a6 & 4 && v81 + 2 < a4 )
          {
            v16 = &loc_804F91A;
            if ( v65[v81 + 1] != 63 )
              v16 = &loc_804F9D7;
            dword_80591DC = (int)v16;
            sub_80531E5();
            switch ( v65[v81 + 2] )
            {
              case 33:
              case 39:
              case 40:
              case 41:
              case 45:
              case 47:
              case 60:
              case 61:
              case 62:
                v17 = &loc_804F95F;
                if ( !v70 )
                  v17 = &loc_804F964;
                dword_8059114 = (int)v17;
                sub_8053699(v34);
                goto LABEL_201;
              default:
                break;
            }
          }
        }
        else
        {
          dword_8059150 = (int)&loc_804F9D7;
          sub_805354B(v34, v37, v40, v43, v45, v47, v49, v51, v53, v55, v57, v59, v61, v63, v65);
LABEL_54:
          if ( v70 )
            goto LABEL_201;
        }
LABEL_153:
        if ( v69 == 1 )
        {
          v27 = &loc_804FFC7;
          if ( a5 != 2 )
            v27 = &loc_804FFD2;
          dword_8059128 = (int)v27;
          sub_8053629(v9);
        }
        if ( v70 != 1 || !v63 || !((*(_DWORD *)(4 * (v74 >> 5) + v63) >> (v74 & 0x1F)) & 1) )
        {
          v28 = &loc_8050028;
          if ( v75 == 1 )
            v28 = &loc_805002D;
          dword_80591C8 = (int)v28;
          sub_805324D();
LABEL_166:
          if ( v71 && v76 != 1 )
          {
            if ( v82 < a2 )
              *(_BYTE *)(v67 + v82) = 39;
            if ( ++v82 < a2 )
              *(_BYTE *)(v67 + v82) = 39;
            ++v82;
            v71 = 0;
          }
          if ( v82 < a2 )
            *(_BYTE *)(v82 + v67) = v74;
          ++v82;
          if ( v77 != 1 )
            v73 = 0;
LABEL_177:
          ++v81;
          continue;
        }
LABEL_163:
        v29 = &loc_805004C;
        if ( !v70 )
          v29 = &loc_8050051;
        dword_80591F0 = (int)v29;
        sub_8053179(v34, v37, v40, v43, v45, v47, v49, v51, v53, v55, v57, v59, v61, v63, v65, v67);
LABEL_201:
        if ( a5 == 2 && v69 )
          a5 = 4;
        return sub_804F465(v67, a2, (int)v65, a4, a5, a6 & 0xFFFFFFFD, 0, v61, v59);
      case 0x5Cu:
        if ( a5 != 2 )
          goto LABEL_70;
        if ( v70 )
          goto LABEL_201;
        dword_8059178 = (int)&loc_80500C6;
        sub_805346B(v34);
LABEL_70:
        if ( v69 && v70 && n )
        {
          dword_80591A0 = (int)&loc_80500C6;
          sub_8053376(v34, v37, v40, v43, v45, v47, v49, v51, v53, v55, v57, v59, v61, v63, v65, v67);
        }
LABEL_74:
        if ( a5 == 2 && v70 )
          goto LABEL_201;
LABEL_76:
        v18 = &loc_804FA9E;
        if ( !v69 )
          v18 = &loc_804FAAA;
        dword_8059128 = (int)v18;
        sub_8053629(v9);
        goto LABEL_163;
      case 0x7Bu:
      case 0x7Du:
        if ( a4 == -1 )
          v19 = v65[1] != 0;
        else
          v19 = a4 != 1;
        v20 = v19 == 0;
        v21 = &loc_804FAF3;
        if ( v20 )
          v21 = &loc_804FB02;
        dword_8059204 = (int)v21;
        sub_80530F0(v34);
        dword_80591A0 = (int)&loc_804FF9D;
        sub_8053376(v22, v37, v40, v43, v45, v47, v49, v51, v53, v55, v57, v59, v61, v63, v65, v67);
LABEL_85:
        if ( v81 )
          goto LABEL_153;
LABEL_86:
        v77 = 1;
LABEL_87:
        if ( a5 != 2 || !v70 )
          goto LABEL_153;
        goto LABEL_201;
      default:
LABEL_105:
        if ( v79 )
        {
          v86 = 1;
          v78 = ((*__ctype_b_loc())[v74] & 0x4000) != 0;
        }
        else
        {
          memset(&ps, 0, 8u);
          v86 = 0;
          v24 = &loc_804FC5F;
          if ( a4 != -1 )
            v24 = &loc_804FC6D;
          dword_80591F0 = (int)v24;
          sub_8053179(v35, v38, v41, v43, v45, v47, v49, v51, v53, v55, v57, v59, v61, v63, v65, v67);
          a4 = strlen(v66);
          v87 = sub_805214A((wchar_t *)&wc, &v66[v86 + v81], a4 - (v86 + v81), &ps);
          if ( !v87 )
          {
            dword_8059164 = (int)&loc_804FDC3;
            sub_80534D5();
          }
          v25 = &loc_804FCDA;
          if ( v87 != -1 )
            v25 = &loc_804FCE3;
          dword_80591A0 = (int)v25;
          sub_8053376(v36, v39, v42, v44, v46, v48, v50, v52, v54, v56, v58, v60, v62, v64, v66, v68);
          v78 = 0;
        }
        v77 = v78;
        if ( v86 <= 1 && (!v69 || v78 == 1) )
          goto LABEL_153;
        v88 = v81 + v86;
        while ( 2 )
        {
          if ( v69 && v78 != 1 )
          {
            if ( v70 )
              goto LABEL_201;
            v76 = 1;
            if ( a5 == 2 && v71 != 1 )
            {
              if ( v82 < a2 )
                *(_BYTE *)(v67 + v82) = 39;
              if ( ++v82 < a2 )
                *(_BYTE *)(v67 + v82) = 36;
              if ( ++v82 < a2 )
                *(_BYTE *)(v67 + v82) = 39;
              ++v82;
              v71 = 1;
            }
            if ( v82 < a2 )
              *(_BYTE *)(v67 + v82) = 92;
            if ( ++v82 < a2 )
              *(_BYTE *)(v82 + v67) = (v74 >> 6) + 48;
            if ( ++v82 < a2 )
              *(_BYTE *)(v82 + v67) = ((v74 >> 3) & 7) + 48;
            ++v82;
            v74 = (v74 & 7) + 48;
          }
          else if ( v75 )
          {
            if ( v82 < a2 )
              *(_BYTE *)(v67 + v82) = 92;
            ++v82;
            v75 = 0;
          }
          if ( v81 + 1 < v88 )
          {
            if ( v71 )
            {
              v26 = &loc_804FF3A;
              if ( v76 == 1 )
                v26 = &loc_804FF6C;
              dword_8059114 = (int)v26;
              sub_8053699(v34);
              if ( v82 < a2 )
                *(_BYTE *)(v67 + v82) = 39;
              if ( ++v82 < a2 )
                *(_BYTE *)(v67 + v82) = 39;
              ++v82;
              v71 = 0;
            }
            if ( v82 < a2 )
              *(_BYTE *)(v82 + v67) = v74;
            ++v82;
            v74 = v65[++v81];
            continue;
          }
          goto LABEL_166;
        }
    }
  }
}
// 80530F0: using guessed type int __stdcall sub_80530F0(_DWORD);
// 8053179: using guessed type int __stdcall sub_8053179(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80531E5: using guessed type int sub_80531E5(void);
// 805324D: using guessed type int sub_805324D(void);
// 80532E9: using guessed type int sub_80532E9(void);
// 8053376: using guessed type int __stdcall sub_8053376(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 805346B: using guessed type int __stdcall sub_805346B(_DWORD);
// 805354B: using guessed type int __stdcall sub_805354B(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80535C1: using guessed type int __stdcall sub_80535C1(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8053629: using guessed type int __fastcall sub_8053629(_DWORD);
// 8053699: using guessed type int __stdcall sub_8053699(_DWORD);
// 8059114: using guessed type int dword_8059114;
// 8059128: using guessed type int dword_8059128;
// 805913C: using guessed type int dword_805913C;
// 8059150: using guessed type int dword_8059150;
// 8059164: using guessed type int dword_8059164;
// 8059178: using guessed type int dword_8059178;
// 80591A0: using guessed type int dword_80591A0;
// 80591B4: using guessed type int dword_80591B4;
// 80591C8: using guessed type int dword_80591C8;
// 80591DC: using guessed type int dword_80591DC;
// 80591F0: using guessed type int dword_80591F0;
// 8059204: using guessed type int dword_8059204;

//----- (080503B7) --------------------------------------------------------
void *__cdecl sub_80503B7(int a1, size_t a2, _DWORD *a3, int a4)
{
  int v4; // ST40_4
  int v5; // ST44_4
  int v7; // [esp+0h] [ebp-58h]
  unsigned int size; // [esp+48h] [ebp-10h]
  void *v9; // [esp+4Ch] [ebp-Ch]

  if ( a4 )
  {
    dword_8059114 = (int)&loc_80503DB;
    sub_8053699(v7);
  }
  v4 = *__errno_location();
  v5 = *(&dword_80598DD + 1) | (a3 == 0);
  size = sub_804F465(
           0,
           0,
           a1,
           a2,
           dword_80598DD,
           v5,
           (int)(&dword_80598DD + 2),
           (char *)*(&dword_80598DD + 10),
           (char *)*(&dword_80598DD + 11))
       + 1;
  v9 = sub_8051452(size);
  sub_804F465(
    (int)v9,
    size,
    a1,
    a2,
    dword_80598DD,
    v5,
    (int)(&dword_80598DD + 2),
    (char *)*(&dword_80598DD + 10),
    (char *)*(&dword_80598DD + 11));
  *__errno_location() = v4;
  if ( a3 )
    *a3 = size - 1;
  return v9;
}
// 8053699: using guessed type int __stdcall sub_8053699(_DWORD);
// 8059114: using guessed type int dword_8059114;
// 80598DD: using guessed type int dword_80598DD;

//----- (0805057D) --------------------------------------------------------
void *__cdecl sub_805057D(signed int a1, int a2, size_t a3, int a4)
{
  int *v4; // eax
  void *v5; // edx
  size_t v6; // ST44_4
  bool v8; // [esp+37h] [ebp-21h]
  int *v9; // [esp+38h] [ebp-20h]
  void *ptr; // [esp+3Ch] [ebp-1Ch]
  int v11; // [esp+40h] [ebp-18h]
  int size; // [esp+44h] [ebp-14h]
  int v13; // [esp+48h] [ebp-10h]
  unsigned int v14; // [esp+4Ch] [ebp-Ch]

  v11 = *__errno_location();
  v9 = off_8059288;
  if ( a1 < 0 )
    abort();
  if ( dword_805927C <= a1 )
  {
    v8 = off_8059288 == &dword_8059280;
    if ( (unsigned int)a1 > 0xFFFFFFE )
      sub_805162D();
    if ( v8 )
      v4 = 0;
    else
      v4 = off_8059288;
    v9 = (int *)sub_80514A8(v4, 8 * (a1 + 1));
    off_8059288 = v9;
    if ( v8 )
    {
      v5 = off_8059284;
      *v9 = dword_8059280;
      v9[1] = (int)v5;
    }
    memset(&v9[2 * dword_805927C], 0, 8 * (a1 + 1 - dword_805927C));
    dword_805927C = a1 + 1;
  }
  v6 = v9[2 * a1];
  ptr = (void *)v9[2 * a1 + 1];
  v13 = *(_DWORD *)(a4 + 4) | 1;
  v14 = sub_804F465(
          v9[2 * a1 + 1],
          v9[2 * a1],
          a2,
          a3,
          *(_DWORD *)a4,
          v13,
          a4 + 8,
          *(char **)(a4 + 40),
          *(char **)(a4 + 44));
  if ( v6 <= v14 )
  {
    size = v14 + 1;
    v9[2 * a1] = v14 + 1;
    if ( ptr != &unk_805991D )
      free(ptr);
    ptr = sub_8051452(size);
    v9[2 * a1 + 1] = (int)ptr;
    sub_804F465((int)ptr, size, a2, a3, *(_DWORD *)a4, v13, a4 + 8, *(char **)(a4 + 40), *(char **)(a4 + 44));
  }
  *__errno_location() = v11;
  return ptr;
}
// 805927C: using guessed type int dword_805927C;
// 8059280: using guessed type int dword_8059280;
// 8059284: using guessed type void *off_8059284;
// 8059288: using guessed type int *off_8059288;

//----- (080507A6) --------------------------------------------------------
void *__cdecl sub_80507A6(signed int a1, int a2)
{
  return sub_805057D(a1, a2, 0xFFFFFFFF, (int)&dword_80598DD);
}
// 80598DD: using guessed type int dword_80598DD;

//----- (080507D0) --------------------------------------------------------
void *__cdecl sub_80507D0(signed int a1, int a2, size_t a3)
{
  return sub_805057D(a1, a2, a3, (int)&dword_80598DD);
}
// 80598DD: using guessed type int dword_80598DD;

//----- (08050846) --------------------------------------------------------
void *__cdecl sub_8050846(signed int a1, int a2, int a3)
{
  char v4; // [esp+10h] [ebp-38h]

  sub_804F303(&v4, a2);
  return sub_805057D(a1, a3, 0xFFFFFFFF, (int)&v4);
}

//----- (08050884) --------------------------------------------------------
void *__cdecl sub_8050884(signed int a1, int a2, int a3, size_t a4)
{
  char v5; // [esp+10h] [ebp-38h]

  sub_804F303(&v5, a2);
  return sub_805057D(a1, a3, a4, (int)&v5);
}

//----- (080508C1) --------------------------------------------------------
void *__cdecl sub_80508C1(int a1, int a2)
{
  return sub_8050846(0, a1, a2);
}

//----- (0805090C) --------------------------------------------------------
void *__cdecl sub_805090C(int a1, size_t a2, unsigned __int8 a3)
{
  int v4; // [esp+20h] [ebp-38h]
  int v5; // [esp+24h] [ebp-34h]
  int v6; // [esp+28h] [ebp-30h]
  int v7; // [esp+2Ch] [ebp-2Ch]
  int v8; // [esp+30h] [ebp-28h]
  int v9; // [esp+34h] [ebp-24h]
  int v10; // [esp+38h] [ebp-20h]
  int v11; // [esp+3Ch] [ebp-1Ch]
  int v12; // [esp+40h] [ebp-18h]
  int v13; // [esp+44h] [ebp-14h]
  int v14; // [esp+48h] [ebp-10h]
  int v15; // [esp+4Ch] [ebp-Ch]

  v4 = dword_80598DD;
  v5 = dword_80598E1;
  v6 = dword_80598E5;
  v7 = dword_80598E9;
  v8 = dword_80598ED;
  v9 = dword_80598F1;
  v10 = dword_80598F5;
  v11 = dword_80598F9;
  v12 = dword_80598FD;
  v13 = dword_8059901;
  v14 = dword_8059905;
  v15 = dword_8059909;
  sub_804F1EF(&v4, a3, 1);
  return sub_805057D(0, a1, a2, (int)&v4);
}
// 80598DD: using guessed type int dword_80598DD;
// 80598E1: using guessed type int dword_80598E1;
// 80598E5: using guessed type int dword_80598E5;
// 80598E9: using guessed type int dword_80598E9;
// 80598ED: using guessed type int dword_80598ED;
// 80598F1: using guessed type int dword_80598F1;
// 80598F5: using guessed type int dword_80598F5;
// 80598F9: using guessed type int dword_80598F9;
// 80598FD: using guessed type int dword_80598FD;
// 8059901: using guessed type int dword_8059901;
// 8059905: using guessed type int dword_8059905;
// 8059909: using guessed type int dword_8059909;

//----- (080509C6) --------------------------------------------------------
void *__cdecl sub_80509C6(int a1, unsigned __int8 a2)
{
  return sub_805090C(a1, 0xFFFFFFFF, a2);
}

//----- (080509EF) --------------------------------------------------------
void *__cdecl sub_80509EF(int a1)
{
  return sub_80509C6(a1, 0x3Au);
}

//----- (08050A2C) --------------------------------------------------------
void *__cdecl sub_8050A2C(signed int a1, int a2, int a3)
{
  int v4; // [esp+10h] [ebp-68h]
  int v5; // [esp+14h] [ebp-64h]
  int v6; // [esp+18h] [ebp-60h]
  int v7; // [esp+1Ch] [ebp-5Ch]
  int v8; // [esp+20h] [ebp-58h]
  int v9; // [esp+24h] [ebp-54h]
  int v10; // [esp+28h] [ebp-50h]
  int v11; // [esp+2Ch] [ebp-4Ch]
  int v12; // [esp+30h] [ebp-48h]
  int v13; // [esp+34h] [ebp-44h]
  int v14; // [esp+38h] [ebp-40h]
  int v15; // [esp+3Ch] [ebp-3Ch]
  int v16; // [esp+40h] [ebp-38h]
  int v17; // [esp+44h] [ebp-34h]
  int v18; // [esp+48h] [ebp-30h]
  int v19; // [esp+4Ch] [ebp-2Ch]
  int v20; // [esp+50h] [ebp-28h]
  int v21; // [esp+54h] [ebp-24h]
  int v22; // [esp+58h] [ebp-20h]
  int v23; // [esp+5Ch] [ebp-1Ch]
  int v24; // [esp+60h] [ebp-18h]
  int v25; // [esp+64h] [ebp-14h]
  int v26; // [esp+68h] [ebp-10h]
  int v27; // [esp+6Ch] [ebp-Ch]

  sub_804F303(&v4, a2);
  v16 = v4;
  v17 = v5;
  v18 = v6;
  v19 = v7;
  v20 = v8;
  v21 = v9;
  v22 = v10;
  v23 = v11;
  v24 = v12;
  v25 = v13;
  v26 = v14;
  v27 = v15;
  sub_804F1EF(&v16, 0x3Au, 1);
  return sub_805057D(a1, a3, 0xFFFFFFFF, (int)&v16);
}

//----- (08050ADD) --------------------------------------------------------
void *__cdecl sub_8050ADD(signed int a1, int a2, int a3, int a4)
{
  return sub_8050B0D(a1, a2, a3, a4, 0xFFFFFFFF);
}

//----- (08050B0D) --------------------------------------------------------
void *__cdecl sub_8050B0D(signed int a1, int a2, int a3, int a4, size_t a5)
{
  int v6; // [esp+10h] [ebp-38h]
  int v7; // [esp+14h] [ebp-34h]
  int v8; // [esp+18h] [ebp-30h]
  int v9; // [esp+1Ch] [ebp-2Ch]
  int v10; // [esp+20h] [ebp-28h]
  int v11; // [esp+24h] [ebp-24h]
  int v12; // [esp+28h] [ebp-20h]
  int v13; // [esp+2Ch] [ebp-1Ch]
  int v14; // [esp+30h] [ebp-18h]
  int v15; // [esp+34h] [ebp-14h]
  int v16; // [esp+38h] [ebp-10h]
  int v17; // [esp+3Ch] [ebp-Ch]

  v6 = dword_80598DD;
  v7 = dword_80598E1;
  v8 = dword_80598E5;
  v9 = dword_80598E9;
  v10 = dword_80598ED;
  v11 = dword_80598F1;
  v12 = dword_80598F5;
  v13 = dword_80598F9;
  v14 = dword_80598FD;
  v15 = dword_8059901;
  v16 = dword_8059905;
  v17 = dword_8059909;
  sub_804F2C2(&v6, a2, a3);
  return sub_805057D(a1, a4, a5, (int)&v6);
}
// 80598DD: using guessed type int dword_80598DD;
// 80598E1: using guessed type int dword_80598E1;
// 80598E5: using guessed type int dword_80598E5;
// 80598E9: using guessed type int dword_80598E9;
// 80598ED: using guessed type int dword_80598ED;
// 80598F1: using guessed type int dword_80598F1;
// 80598F5: using guessed type int dword_80598F5;
// 80598F9: using guessed type int dword_80598F9;
// 80598FD: using guessed type int dword_80598FD;
// 8059901: using guessed type int dword_8059901;
// 8059905: using guessed type int dword_8059905;
// 8059909: using guessed type int dword_8059909;

//----- (08050C19) --------------------------------------------------------
void *__cdecl sub_8050C19(signed int a1, int a2, size_t a3)
{
  return sub_805057D(a1, a2, a3, (int)&unk_805929C);
}

//----- (08050C64) --------------------------------------------------------
void *__cdecl sub_8050C64(signed int a1, int a2)
{
  return sub_8050C19(a1, a2, 0xFFFFFFFF);
}

//----- (08050C86) --------------------------------------------------------
void *__cdecl sub_8050C86(int a1)
{
  return sub_8050C64(0, a1);
}

//----- (08050CA1) --------------------------------------------------------
int __cdecl sub_8050CA1(int fd)
{
  int v2; // [esp+Ch] [ebp-Ch]

  return sub_8051DD2(fd, 0, 3, v2);
}

//----- (08050CC4) --------------------------------------------------------
int __cdecl sub_8050CC4(FILE *stream, int a2, int a3, int a4, int a5, int a6)
{
  char *v6; // eax
  char *v7; // eax
  int v8; // ebx
  char *v9; // eax
  int result; // eax
  int v11; // esi
  int v12; // ebx
  char *v13; // eax
  int v14; // edi
  int v15; // esi
  int v16; // ebx
  char *v17; // eax
  int v18; // ST4C_4
  int v19; // edi
  int v20; // esi
  int v21; // ebx
  char *v22; // eax
  int v23; // ST4C_4
  int v24; // ST48_4
  int v25; // edi
  int v26; // esi
  int v27; // ebx
  char *v28; // eax
  int v29; // ST4C_4
  int v30; // ST48_4
  int v31; // ST44_4
  int v32; // edi
  int v33; // esi
  int v34; // ebx
  char *v35; // eax
  int v36; // esi
  int v37; // ST4C_4
  int v38; // ST48_4
  int v39; // ST44_4
  int v40; // ST40_4
  int v41; // edi
  int v42; // ebx
  char *v43; // eax
  int v44; // edi
  int v45; // ST4C_4
  int v46; // ST48_4
  int v47; // ST44_4
  int v48; // ST40_4
  int v49; // ST3C_4
  int v50; // esi
  int v51; // ebx
  char *v52; // eax
  int v53; // edi
  int v54; // ST4C_4
  int v55; // ST48_4
  int v56; // ST44_4
  int v57; // ST40_4
  int v58; // ST3C_4
  int v59; // ST38_4
  int v60; // esi
  int v61; // ebx
  char *v62; // eax
  int v63; // ecx
  int v64; // edi
  int v65; // ST4C_4
  int v66; // ST48_4
  int v67; // ST44_4
  int v68; // ST40_4
  int v69; // ST3C_4
  int v70; // ST38_4
  int v71; // esi
  int v72; // ebx
  char *v73; // eax

  if ( a2 )
    fprintf(stream, "%s (%s) %s\n", a2, a3, a4);
  else
    fprintf(stream, "%s %s\n", a3, a4);
  v6 = gettext("(C)");
  fprintf(stream, "Copyright %s %d Free Software Foundation, Inc.", v6, 2017);
  v7 = gettext(
         "\n"
         "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\n"
         "This is free software: you are free to change and redistribute it.\n"
         "There is NO WARRANTY, to the extent permitted by law.\n"
         "\n");
  fputs_unlocked(v7, stream);
  switch ( a6 )
  {
    case 0:
      abort();
      return result;
    case 1:
      v8 = *(_DWORD *)a5;
      v9 = gettext("Written by %s.\n");
      return fprintf(stream, v9, v8);
    case 2:
      v11 = *(_DWORD *)(a5 + 4);
      v12 = *(_DWORD *)a5;
      v13 = gettext("Written by %s and %s.\n");
      return fprintf(stream, v13, v12, v11);
    case 3:
      v14 = *(_DWORD *)(a5 + 8);
      v15 = *(_DWORD *)(a5 + 4);
      v16 = *(_DWORD *)a5;
      v17 = gettext("Written by %s, %s, and %s.\n");
      return fprintf(stream, v17, v16, v15, v14);
    case 4:
      v18 = *(_DWORD *)(a5 + 12);
      v19 = *(_DWORD *)(a5 + 8);
      v20 = *(_DWORD *)(a5 + 4);
      v21 = *(_DWORD *)a5;
      v22 = gettext("Written by %s, %s, %s,\nand %s.\n");
      return fprintf(stream, v22, v21, v20, v19, v18);
    case 5:
      v23 = *(_DWORD *)(a5 + 16);
      v24 = *(_DWORD *)(a5 + 12);
      v25 = *(_DWORD *)(a5 + 8);
      v26 = *(_DWORD *)(a5 + 4);
      v27 = *(_DWORD *)a5;
      v28 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
      return fprintf(stream, v28, v27, v26, v25, v24, v23);
    case 6:
      v29 = *(_DWORD *)(a5 + 20);
      v30 = *(_DWORD *)(a5 + 16);
      v31 = *(_DWORD *)(a5 + 12);
      v32 = *(_DWORD *)(a5 + 8);
      v33 = *(_DWORD *)(a5 + 4);
      v34 = *(_DWORD *)a5;
      v35 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
      return fprintf(stream, v35, v34, v33, v32, v31, v30, v29);
    case 7:
      v36 = *(_DWORD *)(a5 + 24);
      v37 = *(_DWORD *)(a5 + 20);
      v38 = *(_DWORD *)(a5 + 16);
      v39 = *(_DWORD *)(a5 + 12);
      v40 = *(_DWORD *)(a5 + 8);
      v41 = *(_DWORD *)(a5 + 4);
      v42 = *(_DWORD *)a5;
      v43 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
      return fprintf(stream, v43, v42, v41, v40, v39, v38, v37, v36);
    case 8:
      v44 = *(_DWORD *)(a5 + 28);
      v45 = *(_DWORD *)(a5 + 24);
      v46 = *(_DWORD *)(a5 + 20);
      v47 = *(_DWORD *)(a5 + 16);
      v48 = *(_DWORD *)(a5 + 12);
      v49 = *(_DWORD *)(a5 + 8);
      v50 = *(_DWORD *)(a5 + 4);
      v51 = *(_DWORD *)a5;
      v52 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
      return fprintf(stream, v52, v51, v50, v49, v48, v47, v46, v45, v44);
    case 9:
      v53 = *(_DWORD *)(a5 + 32);
      v54 = *(_DWORD *)(a5 + 28);
      v55 = *(_DWORD *)(a5 + 24);
      v56 = *(_DWORD *)(a5 + 20);
      v57 = *(_DWORD *)(a5 + 16);
      v58 = *(_DWORD *)(a5 + 12);
      v59 = *(_DWORD *)(a5 + 8);
      v60 = *(_DWORD *)(a5 + 4);
      v61 = *(_DWORD *)a5;
      v62 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
      fprintf(stream, v62, v61, v60, v59, v58, v57, v56, v55, v54, v53);
      dword_8059128 = (int)&loc_80511D3;
      sub_8053629(v63);
      break;
    default:
      break;
  }
  v64 = *(_DWORD *)(a5 + 32);
  v65 = *(_DWORD *)(a5 + 28);
  v66 = *(_DWORD *)(a5 + 24);
  v67 = *(_DWORD *)(a5 + 20);
  v68 = *(_DWORD *)(a5 + 16);
  v69 = *(_DWORD *)(a5 + 12);
  v70 = *(_DWORD *)(a5 + 8);
  v71 = *(_DWORD *)(a5 + 4);
  v72 = *(_DWORD *)a5;
  v73 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
  return fprintf(stream, v73, v72, v71, v70, v69, v68, v67, v66, v65, v64);
}
// 8048F50: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8053629: using guessed type int __fastcall sub_8053629(_DWORD);
// 8059128: using guessed type int dword_8059128;

//----- (08051233) --------------------------------------------------------
int __cdecl sub_8051233(FILE *stream, int a2, int a3, int a4, int a5)
{
  int *v5; // eax
  int v7; // [esp+0h] [ebp-58h]
  int v8; // [esp+24h] [ebp-34h]
  int v9[12]; // [esp+28h] [ebp-30h]

  v8 = 0;
  dword_8059178 = (int)&loc_8051253;
  sub_805346B(v7);
  do
  {
    if ( (unsigned int)++v8 > 9 )
      break;
    v5 = (int *)a5;
    a5 += 4;
    v9[v8] = *v5;
  }
  while ( v9[v8] );
  return sub_8050CC4(stream, a2, a3, a4, (int)v9, v8);
}
// 805346B: using guessed type int __stdcall sub_805346B(_DWORD);
// 8059178: using guessed type int dword_8059178;
// 8051233: using guessed type int var_30[12];

//----- (080512A6) --------------------------------------------------------
int sub_80512A6(FILE *stream, int a2, int a3, int a4, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a4);
  return sub_8051233(stream, a2, a3, a4, (int)va);
}

//----- (080513A9) --------------------------------------------------------
void *__cdecl sub_80513A9(void *ptr, int a2, int a3)
{
  unsigned int v4; // [esp+1Ch] [ebp-Ch]

  v4 = *(_DWORD *)a2;
  if ( ptr )
  {
    if ( 0x55555554u / a3 <= v4 )
      sub_805162D();
    v4 += (v4 >> 1) + 1;
  }
  else
  {
    if ( !v4 )
      v4 = (0x40u / a3 == 0) + 0x40u / a3;
    if ( 0x7FFFFFFFu / a3 < v4 )
      sub_805162D();
  }
  *(_DWORD *)a2 = v4;
  return sub_80514A8(ptr, a3 * v4);
}

//----- (08051452) --------------------------------------------------------
void *__cdecl sub_8051452(size_t size)
{
  return sub_8051465(size);
}

//----- (08051465) --------------------------------------------------------
void *__cdecl sub_8051465(size_t size)
{
  void *v1; // eax
  bool v2; // zf
  void *v3; // eax
  void *v5; // [esp+1Ch] [ebp-Ch]

  v1 = malloc(size);
  v5 = v1;
  v2 = v1 == 0;
  v3 = &loc_8051498;
  if ( !v2 )
    v3 = &loc_80514A3;
  dword_80591C8 = (int)v3;
  sub_805324D();
  if ( size )
    sub_805162D();
  return v5;
}
// 805324D: using guessed type int sub_805324D(void);
// 80591C8: using guessed type int dword_80591C8;

//----- (080514A8) --------------------------------------------------------
#error "80514C8: call analysis failed (funcsize=52)"

//----- (08051548) --------------------------------------------------------
void *__cdecl sub_8051548(void *ptr, int a2)
{
  return sub_80513A9(ptr, a2, 1);
}

//----- (080515A2) --------------------------------------------------------
void *__cdecl sub_80515A2(size_t nmemb, size_t size)
{
  void *v3; // [esp+1Ch] [ebp-Ch]

  if ( 0x7FFFFFFF / size < nmemb || (v3 = calloc(nmemb, size)) == 0 )
    sub_805162D();
  return v3;
}

//----- (080515DF) --------------------------------------------------------
void *__cdecl sub_80515DF(void *src, size_t n)
{
  void *v2; // eax

  v2 = sub_8051465(n);
  return memcpy(v2, src, n);
}

//----- (0805162D) --------------------------------------------------------
void __noreturn sub_805162D()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (08051666) --------------------------------------------------------
void __cdecl sub_8051666(int errnum, int a2, int a3, int a4, int a5)
{
  char *v5; // eax
  char *v6; // eax
  void *v7; // esi
  void *v8; // ebx
  char *v9; // eax

  v5 = gettext("string comparison failed");
  error(0, errnum, v5);
  v6 = gettext("Set LC_ALL='C' to work around the problem.");
  error(0, 0, v6);
  v7 = sub_8050884(1, 8, a4, a5);
  v8 = sub_8050884(0, 8, a2, a3);
  v9 = gettext("The strings compared were %s and %s.");
  error(status, 0, v9, v8, v7);
}

//----- (08051732) --------------------------------------------------------
int __cdecl sub_8051732(void *a1, int a2, void *a3, int a4)
{
  int v5; // [esp+28h] [ebp-10h]
  int errnum; // [esp+2Ch] [ebp-Ch]

  v5 = sub_8052AA3(a1, a2, a3, a4);
  errnum = *__errno_location();
  if ( errnum )
    sub_8051666(errnum, (int)a1, a2, (int)a3, a4);
  return v5;
}

//----- (08051802) --------------------------------------------------------
signed int __cdecl sub_8051802(unsigned int *a1, unsigned int a2)
{
  signed int result; // eax

  if ( 0xFFFFFFFF / a2 >= *a1 )
  {
    *a1 *= a2;
    result = 0;
  }
  else
  {
    *a1 = -1;
    result = 1;
  }
  return result;
}

//----- (08051846) --------------------------------------------------------
int __cdecl sub_8051846(unsigned int *a1, unsigned int a2, int a3)
{
  int v3; // eax
  int i; // [esp+14h] [ebp-8h]

  for ( i = 0; ; i |= sub_8051802(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}

//----- (0805188A) --------------------------------------------------------
int __cdecl sub_805188A(char *nptr, int a2, int base, int a4, char *s)
{
  char **v5; // eax
  int result; // eax
  void *v7; // eax
  void *v8; // eax
  void *v9; // eax
  int v10; // ecx
  int v11; // eax
  bool v12; // zf
  void *v13; // eax
  void *v14; // eax
  int v15; // [esp+0h] [ebp-48h]
  int v16; // [esp+0h] [ebp-48h]
  int v17; // [esp+0h] [ebp-48h]
  int v18; // [esp+4h] [ebp-44h]
  int v19; // [esp+4h] [ebp-44h]
  int v20; // [esp+8h] [ebp-40h]
  int v21; // [esp+Ch] [ebp-3Ch]
  int v22; // [esp+10h] [ebp-38h]
  int v23; // [esp+14h] [ebp-34h]
  int v24; // [esp+18h] [ebp-30h]
  int v25; // [esp+1Ch] [ebp-2Ch]
  char v26; // [esp+20h] [ebp-28h]
  unsigned int v27; // [esp+24h] [ebp-24h]
  int v28; // [esp+28h] [ebp-20h]
  char *v29; // [esp+2Ch] [ebp-1Ch]
  unsigned int v30; // [esp+30h] [ebp-18h]
  int v31; // [esp+34h] [ebp-14h]
  int v32; // [esp+38h] [ebp-10h]
  char **endptr; // [esp+3Ch] [ebp-Ch]

  v28 = 0;
  if ( base < 0 || base > 36 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoul");
  if ( a2 )
    v5 = (char **)a2;
  else
    v5 = (char **)&v26;
  endptr = v5;
  *__errno_location() = 0;
  v29 = nptr;
  HIBYTE(v25) = *nptr;
  while ( (*__ctype_b_loc())[HIBYTE(v25)] & 0x2000 )
    HIBYTE(v25) = *++v29;
  if ( HIBYTE(v25) == 45 )
    return 4;
  v27 = strtoul(nptr, endptr, base);
  if ( *endptr == nptr )
  {
    v7 = &loc_8051988;
    if ( !s )
      v7 = &loc_80519D4;
    dword_8059178 = (int)v7;
    sub_805346B(v15);
    v8 = &loc_80519AD;
    if ( !**endptr )
      v8 = &loc_80519D4;
    dword_8059150 = (int)v8;
    sub_805354B(v16, v18, v20, v21, v22, v23, v24, v25, *(_DWORD *)&v26, v27, v28, v29, v30, v31, v32);
    if ( !strchr(s, **endptr) )
      return 4;
    v27 = 1;
  }
  else if ( *__errno_location() )
  {
    if ( *__errno_location() != 34 )
    {
      dword_8059178 = (int)&locret_8051CFF;
      sub_805346B(v15);
    }
    v28 = 1;
  }
  if ( !s )
  {
    *(_DWORD *)a4 = v27;
    dword_805918C = (int)&locret_8051CFF;
    sub_80533FB();
  }
  v9 = &loc_8051A55;
  if ( !**endptr )
    v9 = &loc_8051CF4;
  dword_8059178 = (int)v9;
  sub_805346B(v15);
  v30 = 1024;
  v31 = 1;
  if ( strchr(s, **endptr) )
  {
    switch ( **endptr )
    {
      case 69:
      case 71:
      case 75:
      case 77:
      case 80:
      case 84:
      case 89:
      case 90:
      case 103:
      case 107:
      case 109:
      case 116:
        if ( strchr(s, 48) )
        {
          v11 = (*endptr)[1];
          if ( v11 == 68 )
          {
            v30 = 1000;
            ++v31;
          }
          else if ( v11 == 105 )
          {
            v14 = &loc_8051B2B;
            if ( (*endptr)[2] != 66 )
              v14 = &loc_8051B31;
            dword_8059128 = (int)v14;
            sub_8053629(v10);
            v31 += 2;
          }
          else
          {
            v12 = v11 == 66;
            v13 = &loc_8051B01;
            if ( v12 )
              v13 = &loc_8051B33;
            dword_805913C = (int)v13;
            sub_80535C1(v17, v19, v20, v21, v22, v23, v24, v25, *(_DWORD *)&v26, v27, v28, v29, v30, v31, v32);
          }
        }
        break;
      default:
        break;
    }
    switch ( **endptr )
    {
      case 66:
        v32 = sub_8051802(&v27, 0x400u);
        goto LABEL_55;
      case 69:
        v32 = sub_8051846(&v27, v30, 6);
        goto LABEL_55;
      case 71:
      case 103:
        v32 = sub_8051846(&v27, v30, 3);
        goto LABEL_55;
      case 75:
      case 107:
        v32 = sub_8051846(&v27, v30, 1);
        goto LABEL_55;
      case 77:
      case 109:
        v32 = sub_8051846(&v27, v30, 2);
        goto LABEL_55;
      case 80:
        v32 = sub_8051846(&v27, v30, 5);
        goto LABEL_55;
      case 84:
      case 116:
        v32 = sub_8051846(&v27, v30, 4);
        goto LABEL_55;
      case 89:
        v32 = sub_8051846(&v27, v30, 8);
        goto LABEL_55;
      case 90:
        v32 = sub_8051846(&v27, v30, 7);
        goto LABEL_55;
      case 98:
        v32 = sub_8051802(&v27, 0x200u);
        goto LABEL_55;
      case 99:
        v32 = 0;
        goto LABEL_55;
      case 119:
        v32 = sub_8051802(&v27, 2u);
LABEL_55:
        v28 |= v32;
        *endptr += v31;
        if ( **endptr )
          v28 |= 2u;
        *(_DWORD *)a4 = v27;
        result = v28;
        break;
      default:
        *(_DWORD *)a4 = v27;
        result = v28 | 2;
        break;
    }
  }
  else
  {
    *(_DWORD *)a4 = v27;
    result = v28 | 2;
  }
  return result;
}
// 805188A: could not find valid save-restore pair for ebx
// 80533FB: using guessed type int sub_80533FB(void);
// 805346B: using guessed type int __stdcall sub_805346B(_DWORD);
// 805354B: using guessed type int __stdcall sub_805354B(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80535C1: using guessed type int __stdcall sub_80535C1(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8053629: using guessed type int __fastcall sub_8053629(_DWORD);
// 8059128: using guessed type int dword_8059128;
// 805913C: using guessed type int dword_805913C;
// 8059150: using guessed type int dword_8059150;
// 8059178: using guessed type int dword_8059178;
// 805918C: using guessed type int dword_805918C;

//----- (08051D01) --------------------------------------------------------
int __cdecl sub_8051D01(FILE *stream)
{
  int v2; // eax
  __int64 v3; // rax
  int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]

  v4 = 0;
  if ( fileno(stream) < 0 )
    return fclose(stream);
  if ( !__freading(stream) || (v2 = fileno(stream), LODWORD(v3) = lseek64(v2, 0, 0, 1), v3 != -1) )
  {
    if ( sub_8051FE9(stream) )
      v4 = *__errno_location();
  }
  v5 = fclose(stream);
  if ( v4 )
  {
    *__errno_location() = v4;
    v5 = -1;
  }
  return v5;
}
// 8049090: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08051DD2) --------------------------------------------------------
int __cdecl sub_8051DD2(int fd, int cmd, char a3, int a4)
{
  bool v4; // zf
  void *v5; // eax
  int v6; // ST30_4
  int v8; // [esp+0h] [ebp-38h]
  int v9; // [esp+0h] [ebp-38h]
  char *v10; // [esp+18h] [ebp-20h]
  int v11; // [esp+1Ch] [ebp-1Ch]
  char v12; // [esp+20h] [ebp-18h]
  int v13; // [esp+24h] [ebp-14h]

  v10 = &a3;
  if ( cmd != 1030 )
    return fcntl(fd, cmd, *(_DWORD *)v10);
  v10 = (char *)&a4;
  v12 = a3;
  if ( dword_8059A1D < 0 )
  {
    v11 = sub_8051DD2(fd, 0, a3);
LABEL_10:
    if ( v11 >= 0 && dword_8059A1D == -1 )
    {
      v13 = fcntl(v11, 1);
      if ( v13 < 0 || fcntl(v11, 2, v13 | 1) == -1 )
      {
        v6 = *__errno_location();
        close(v11);
        *__errno_location() = v6;
        return -1;
      }
    }
    dword_8059204 = (int)&loc_8051F84;
    sub_80530F0(v9);
    return fcntl(fd, cmd, *(_DWORD *)v10);
  }
  if ( fcntl(fd, 1030, a3) < 0 )
  {
    v4 = *__errno_location() == 22;
    v5 = &loc_8051E55;
    if ( v4 )
      v5 = &loc_8051E6E;
    dword_8059114 = (int)v5;
    sub_8053699(v8);
  }
  dword_8059A1D = 1;
  dword_80591DC = (int)&loc_8051EBF;
  sub_80531E5();
  v11 = sub_8051DD2(fd, 0, v12);
  if ( v11 >= 0 )
  {
    dword_8059A1D = -1;
    goto LABEL_10;
  }
  return v11;
}
// 80530F0: using guessed type int __stdcall sub_80530F0(_DWORD);
// 80531E5: using guessed type int sub_80531E5(void);
// 8053699: using guessed type int __stdcall sub_8053699(_DWORD);
// 8059114: using guessed type int dword_8059114;
// 80591DC: using guessed type int dword_80591DC;
// 8059204: using guessed type int dword_8059204;
// 8059A1D: using guessed type int dword_8059A1D;

//----- (08051F89) --------------------------------------------------------
int __cdecl sub_8051F89(FILE *stream)
{
  void *v1; // eax

  v1 = &loc_8051FB6;
  if ( !(stream->_flags & 0x100) )
    v1 = &locret_8051FE7;
  dword_80591DC = (int)v1;
  sub_80531E5();
  return sub_8052042(stream, 0, 0, 1);
}
// 80531E5: using guessed type int sub_80531E5(void);
// 80591DC: using guessed type int dword_80591DC;

//----- (08051FE9) --------------------------------------------------------
int __cdecl sub_8051FE9(FILE *fp)
{
  bool v1; // zf
  int v2; // ecx
  void *v3; // eax

  if ( fp )
  {
    v1 = __freading(fp) == 0;
    v3 = &loc_805201D;
    if ( !v1 )
      v3 = &loc_805202A;
    dword_8059128 = (int)v3;
    sub_8053629(v2);
  }
  return fflush(fp);
}
// 8053629: using guessed type int __fastcall sub_8053629(_DWORD);
// 8059128: using guessed type int dword_8059128;

//----- (08052042) --------------------------------------------------------
int __cdecl sub_8052042(FILE *stream, int a2, int a3, int a4)
{
  void *v4; // eax
  int v5; // eax
  __int64 v6; // rax
  bool v7; // zf
  void *v8; // eax
  int v10; // [esp+0h] [ebp-38h]

  v4 = &loc_805207D;
  if ( stream->_IO_read_end != stream->_IO_read_ptr )
    v4 = &loc_8052128;
  dword_8059204 = (int)v4;
  sub_80530F0(v10);
  if ( stream->_IO_write_ptr != stream->_IO_write_base || stream->_IO_save_base )
    return fseeko64(stream, a2, a3, a4);
  v5 = fileno(stream);
  LODWORD(v6) = lseek64(v5, a2, a3, a4);
  v7 = v6 == -1;
  v8 = &loc_80520FC;
  if ( !v7 )
    v8 = &loc_8052103;
  dword_805918C = (int)v8;
  sub_80533FB();
  return -1;
}
// 8052042: could not find valid save-restore pair for ebx
// 8048DF0: using guessed type int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8049090: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 80530F0: using guessed type int __stdcall sub_80530F0(_DWORD);
// 80533FB: using guessed type int sub_80533FB(void);
// 805918C: using guessed type int dword_805918C;
// 8059204: using guessed type int dword_8059204;

//----- (0805214A) --------------------------------------------------------
size_t __cdecl sub_805214A(wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  void *v4; // eax
  int v6; // [esp+0h] [ebp-28h]
  wchar_t v7; // [esp+18h] [ebp-10h]
  size_t v8; // [esp+1Ch] [ebp-Ch]

  v4 = &loc_805216F;
  if ( pwc )
    v4 = &loc_8052175;
  dword_8059178 = (int)v4;
  sub_805346B(v6);
  v8 = mbrtowc(&v7, s, n, p);
  if ( v8 <= 0xFFFFFFFD || !n || !((unsigned __int8)sub_804EDDA(0) ^ 1) )
    return v8;
  v7 = (unsigned __int8)*s;
  return 1;
}
// 805346B: using guessed type int __stdcall sub_805346B(_DWORD);
// 8059178: using guessed type int dword_8059178;

//----- (080521D5) --------------------------------------------------------
int __cdecl sub_80521D5(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // esi
  unsigned __int8 *v3; // ebx
  void *v5; // eax
  unsigned __int8 v6; // [esp+1Eh] [ebp-Ah]
  unsigned __int8 v7; // [esp+1Fh] [ebp-9h]

  v2 = a1;
  v3 = a2;
  if ( a1 == a2 )
    return 0;
  do
  {
    v6 = sub_8052E19(*v2);
    v7 = sub_8052E19(*v3);
    v5 = &loc_805222F;
    if ( v6 )
      v5 = &loc_805223E;
    dword_80591DC = (int)v5;
    sub_80531E5();
    dword_80591DC = (int)&loc_805225F;
    sub_80531E5();
    ++v2;
    ++v3;
  }
  while ( v6 == v7 );
  return v6 - v7;
}
// 80531E5: using guessed type int sub_80531E5(void);
// 80591DC: using guessed type int dword_80591DC;

//----- (08052272) --------------------------------------------------------
#error "80522EE: call analysis failed (funcsize=59)"

//----- (0805231E) --------------------------------------------------------
int __fastcall __noreturn sub_805231E(int a1)
{
  void *v1; // eax
  void *v2; // eax
  void *v3; // eax
  bool v4; // zf
  void *v5; // eax
  int (*v6)(); // eax
  int v8; // [esp+0h] [ebp-C8h]
  int v9; // [esp+0h] [ebp-C8h]
  int v10; // [esp+0h] [ebp-C8h]
  int v11; // [esp+4h] [ebp-C4h]
  int v12; // [esp+8h] [ebp-C0h]
  int v13; // [esp+Ch] [ebp-BCh]
  int v14; // [esp+10h] [ebp-B8h]
  const char *s; // [esp+1Ch] [ebp-ACh]
  void *v16; // [esp+20h] [ebp-A8h]
  int v17; // [esp+24h] [ebp-A4h]
  size_t n; // [esp+2Ch] [ebp-9Ch]
  size_t v19; // [esp+30h] [ebp-98h]
  _BOOL4 v20; // [esp+34h] [ebp-94h]
  char *dest; // [esp+38h] [ebp-90h]
  int fd; // [esp+3Ch] [ebp-8Ch]
  unsigned int v23; // [esp+BCh] [ebp-Ch]

  v23 = __readgsdword(0x14u);
  v1 = &loc_8052360;
  if ( dword_8059A21 )
    v1 = &loc_8052871;
  dword_8059128 = (int)v1;
  sub_8053629(a1);
  s = getenv("CHARSETALIASDIR");
  if ( !s || !*s )
    s = "/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib";
  n = strlen(s);
  v19 = strlen("charset.alias");
  v2 = &loc_80523FA;
  if ( !n )
    v2 = &loc_8052419;
  dword_8059178 = (int)v2;
  sub_805346B(v8);
  v20 = s[n - 1] != 47;
  dest = (char *)malloc(n + v20 + v19 + 1);
  if ( dest )
  {
    memcpy(dest, s, n);
    if ( v20 )
      dest[n] = 47;
    memcpy(&dest[n + v20], "charset.alias", v19 + 1);
  }
  free(0);
  v3 = &loc_80524F5;
  if ( dest )
    v3 = &loc_805250E;
  dword_80591DC = (int)v3;
  sub_80531E5();
  dword_8059114 = (int)&loc_8052866;
  sub_8053699(v9);
  fd = open64(dest, 0x20000);
  if ( fd < 0 )
  {
    dword_80591DC = (int)&loc_8052858;
    sub_80531E5();
  }
  v4 = fdopen(fd, "r") == 0;
  v5 = &loc_805258A;
  if ( !v4 )
    v5 = &loc_80525A7;
  dword_8059164 = (int)v5;
  sub_80534D5();
  close(fd);
  free(dest);
  dword_8059A21 = (int)&unk_8054FB7;
  v6 = (int (*)())&loc_805289C;
  if ( __readgsdword(0x14u) == v23 )
    v6 = sub_80528A1;
  dword_8059150 = (int)v6;
  return sub_805354B(v10, v11, v12, v13, v14, 0, &unk_8054FB7, s, v16, v17, "charset.alias", n, v19, v20, dest);
}
// 8048D60: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 80528A1: using guessed type int sub_80528A1();
// 80531E5: using guessed type int sub_80531E5(void);
// 805346B: using guessed type int __stdcall sub_805346B(_DWORD);
// 805354B: using guessed type int __stdcall sub_805354B(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8053629: using guessed type int __fastcall sub_8053629(_DWORD);
// 8053699: using guessed type int __stdcall sub_8053699(_DWORD);
// 8059114: using guessed type int dword_8059114;
// 8059128: using guessed type int dword_8059128;
// 8059150: using guessed type int dword_8059150;
// 8059164: using guessed type int dword_8059164;
// 8059178: using guessed type int dword_8059178;
// 80591DC: using guessed type int dword_80591DC;
// 8059A21: using guessed type int dword_8059A21;

//----- (080528A1) --------------------------------------------------------
#error "80528A7: positive sp value has been found (funcsize=0)"

//----- (080528AA) --------------------------------------------------------
#error "80528D9: call analysis failed (funcsize=18)"

//----- (080529C8) --------------------------------------------------------
#error "8052A99: call analysis failed (funcsize=34)"

//----- (08052AA3) --------------------------------------------------------
#error "8052AF8: call analysis failed (funcsize=70)"

//----- (08052B79) --------------------------------------------------------
int __cdecl sub_8052B79(void *s1, size_t n, void *s2, int a4)
{
  if ( n != a4 || memcmp(s1, s2, n) )
    return sub_80529C8((char *)s1, n, (char *)s2);
  *__errno_location() = 0;
  return 0;
}

//----- (08052E19) --------------------------------------------------------
int __cdecl sub_8052E19(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 65) > 0x19 )
    result = a1;
  else
    result = a1 + 32;
  return result;
}

//----- (08052ED9) --------------------------------------------------------
int __cdecl sub_8052ED9(int a1)
{
  return __cxa_atexit(a1, 0, dword_8059240);
}
// 8048EB0: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 8059240: using guessed type int dword_8059240;

//----- (08052FD4) --------------------------------------------------------
#error "805300D: positive sp value has been found (funcsize=18)"

//----- (080530F0) --------------------------------------------------------
#error "80530F6: positive sp value has been found (funcsize=0)"

//----- (08053138) --------------------------------------------------------
#error "8053171: positive sp value has been found (funcsize=18)"

//----- (08053179) --------------------------------------------------------
#error "805317F: positive sp value has been found (funcsize=0)"

//----- (080531E5) --------------------------------------------------------
#error "80531EB: positive sp value has been found (funcsize=0)"

//----- (0805324D) --------------------------------------------------------
#error "8053253: positive sp value has been found (funcsize=0)"

//----- (080532A8) --------------------------------------------------------
#error "80532E1: positive sp value has been found (funcsize=18)"

//----- (080532E9) --------------------------------------------------------
#error "80532EF: positive sp value has been found (funcsize=0)"

//----- (08053376) --------------------------------------------------------
#error "805337C: positive sp value has been found (funcsize=0)"

//----- (080533BA) --------------------------------------------------------
#error "80533F3: positive sp value has been found (funcsize=18)"

//----- (080533FB) --------------------------------------------------------
#error "8053401: positive sp value has been found (funcsize=0)"

//----- (0805346B) --------------------------------------------------------
#error "8053471: positive sp value has been found (funcsize=0)"

//----- (080534D5) --------------------------------------------------------
#error "80534DB: positive sp value has been found (funcsize=0)"

//----- (0805354B) --------------------------------------------------------
#error "8053551: positive sp value has been found (funcsize=0)"

//----- (080535C1) --------------------------------------------------------
#error "80535C7: positive sp value has been found (funcsize=0)"

//----- (08053629) --------------------------------------------------------
#error "805362F: positive sp value has been found (funcsize=0)"

//----- (08053699) --------------------------------------------------------
#error "805369F: positive sp value has been found (funcsize=0)"

//----- (080536B0) --------------------------------------------------------
int (**sub_80536B0())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_8058EC4;
  v1 = &off_8058EC8 - off_8058EC4;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_8058EC4[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 8058EC4: using guessed type int (*off_8058EC4[2])();
// 8058EC8: using guessed type int (*off_8058EC8)();

//----- (08053714) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 40 decompilation failure(s) on 182 function(s)"
