/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8048D40();
// int strcmp(const char *s1, const char *s2);
// int __cdecl open64(_DWORD, _DWORD); weak
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void _exit(int status);
// void free(void *ptr);
// void *memcpy(void *dest, const void *src, size_t n);
// int fclose(FILE *stream);
// int getc_unlocked(FILE *stream);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// char *textdomain(const char *domainname);
// int __cdecl fopen64(_DWORD, _DWORD); weak
// int ferror_unlocked(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// size_t __ctype_get_mb_cur_max(void);
// char *strcpy(char *dest, const char *src);
// size_t __fpending(FILE *fp);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// void error(int status, int errnum, const char *format, ...);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// char *strchr(const char *s, int c);
// int fscanf(FILE *stream, const char *format, ...);
// size_t strlen(const char *s);
// int fprintf(FILE *stream, const char *format, ...);
// int fcntl(int fd, int cmd, ...);
// void *memset(void *s, int c, size_t n);
// int ungetc(int c, FILE *stream);
// int *__errno_location(void);
// void *memchr(const void *s, int c, size_t n);
// int fileno(FILE *stream);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// char *strpbrk(const char *s, const char *accept);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// int toupper(int c);
// char *strrchr(const char *s, int c);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// char *bindtextdomain(const char *domainname, const char *dirname);
// int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// int feof_unlocked(FILE *stream);
// void abort(void);
// int close(int fd);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// void *calloc(size_t nmemb, size_t size);
// int putchar_unlocked(int c);
// int _gmon_start__(void); weak
void sub_8049183();
void sub_80491A0();
int sub_80491B0();
int sub_8049220();
int sub_8049240();
void sub_804929F();
void sub_80492BA();
int sub_80492CA();
void sub_80493AC();
void sub_80493C7();
signed int sub_80493D7();
// int __usercall sub_8049489@<eax>(void (__cdecl *a1)(signed int)@<eax>);
void sub_80494D5();
void sub_80494F0();
int sub_8049500();
void sub_80495E2();
void sub_80495FD();
int sub_804960D();
void sub_80496F9();
void sub_8049714();
int sub_8049724();
void sub_8049822();
void sub_804983D();
int sub_804984D();
void sub_8049939();
void sub_8049954();
int sub_8049964();
void sub_8049A50();
void sub_8049A6B();
int sub_8049A7B();
int nullsub_3(void); // weak
int sub_8049AD9();
void sub_8049B79();
void sub_8049B94();
void sub_8049CBB();
void sub_8049CD6();
int sub_8049CE6();
void sub_8049DC8();
void sub_8049DE3();
int sub_8049DF3();
int sub_8049E1F();
// int __usercall sub_8049EBE@<eax>(void (__cdecl *a1)(int *)@<eax>);
void sub_8049F0A();
void sub_8049F25();
int sub_8049F35();
int sub_8049FD8();
void sub_804A056();
void sub_804A071();
int sub_804A081();
int sub_804A124();
void sub_804A198();
void sub_804A1B3();
int sub_804A1C3();
int nullsub_4(void); // weak
int sub_804A221();
void sub_804A2CB();
void sub_804A308();
signed int sub_804A318();
void sub_804A413();
void sub_804A43C();
int sub_804A44C();
void sub_804A54A();
void sub_804A575();
signed int sub_804A585();
int sub_804A5BD(void); // weak
int nullsub_5(); // weak
// int __usercall sub_804A5EF@<eax>(int a1@<ebp>);
signed int sub_804A64D();
// int __usercall sub_804A6A7@<eax>(void (__cdecl *a1)(signed int)@<eax>);
int __cdecl sub_804A6C1(unsigned __int8 a1);
int __cdecl sub_804A70E(char *s1); // idb
void __cdecl __noreturn sub_804A894(int status); // idb
int __cdecl sub_804AA21(int a1, int a2, int a3);
int __cdecl sub_804AA9B(int a1);
int __cdecl sub_804ACD2(int a1);
int __cdecl sub_804AD32(int a1, int a2, unsigned int a3, unsigned int a4);
int __cdecl sub_804AEC3(int a1, int a2, int a3);
int __cdecl sub_804B07D(int a1);
void __noreturn sub_804B08C();
int __cdecl sub_804B0C8(FILE *stream, int, int); // idb
void sub_804B253();
_DWORD *__cdecl sub_804B2B9(_DWORD *a1);
int __cdecl sub_804B2DB(FILE *stream, int, int); // idb
int __cdecl sub_804B3B5(FILE *stream, int, int, int); // idb
void __cdecl sub_804B3EB(int a1);
char *__cdecl sub_804B4EB(unsigned int a1, unsigned int a2, size_t a3);
int __cdecl sub_804BA18(FILE *stream, FILE *); // idb
_DWORD *__cdecl sub_804DAA7(int a1, int a2);
int __cdecl sub_804DB62(char *nptr); // idb
_DWORD __cdecl sub_804DC09(_DWORD, _DWORD, _DWORD); // weak
_DWORD *__cdecl sub_804DD5C(char *a1);
__int64 __cdecl sub_804DDD9(__int64 a1);
_DWORD *__cdecl sub_804DE55(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7);
void __cdecl __noreturn main(int argc, char **argv);
void __noreturn sub_804EA99();
int sub_804EB90(); // weak
int __cdecl sub_804EB96(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_804EBE7(FILE *stream, int); // idb
int __cdecl sub_804EC48(int, char *modes); // idb
int __cdecl sub_804ED4D(int category); // idb
int __cdecl sub_804EE00(int a1, FILE *stream);
int __cdecl sub_804EF73(int a1, int a2, unsigned int a3);
char *__cdecl sub_804EFF3(char *s);
int __cdecl sub_804F14F(int *a1, unsigned __int8 a2, char a3);
int *__cdecl sub_804F1F9(int *a1, int a2, int a3);
// _DWORD *__userpurge sub_804F24C@<eax>(_DWORD *a1, int a2);
const char *__cdecl sub_804F2CE(char *msgid, int a2);
unsigned int __cdecl sub_804F37E(int a1, unsigned int a2, int a3, size_t a4, signed int a5, int a6, int a7, char *a8, char *a9);
void *__cdecl sub_80503BF(int a1, size_t a2, _DWORD *a3, int a4);
void *__cdecl sub_80505A4(signed int a1, int a2, size_t a3, int a4);
void *__cdecl sub_80507E6(signed int a1, int a2);
void *__cdecl sub_8050810(signed int a1, int a2, size_t a3);
void *__cdecl sub_8050884(signed int a1, int a2, int a3);
void *__cdecl sub_80508C2(signed int a1, int a2, int a3, size_t a4);
void *__cdecl sub_8050923(int a1, int a2);
void *__cdecl sub_805096E(int a1, size_t a2, unsigned __int8 a3);
void *__cdecl sub_8050A18(int a1, unsigned __int8 a2);
void *__cdecl sub_8050A41(int a1);
void *__cdecl sub_8050A8E(signed int a1, int a2, int a3);
void *__cdecl sub_8050B41(signed int a1, int a2, int a3, int a4);
void *__cdecl sub_8050B71(signed int a1, int a2, int a3, int a4, size_t a5);
void *__cdecl sub_8050C7B(signed int a1, int a2, size_t a3);
void *__cdecl sub_8050CC6(signed int a1, int a2);
void *__cdecl sub_8050CF6(int a1);
int __cdecl sub_8050D21(int fd); // idb
int __cdecl sub_8050D44(FILE *stream, int, int, int, int, int); // idb
int __cdecl sub_80512C0(FILE *stream, int, int, int, int); // idb
int sub_8051333(FILE *stream, int a2, int a3, int a4, ...);
void *__cdecl sub_8051446(void *ptr, int a2, int a3);
void *__cdecl sub_80514ED(size_t size);
void *__cdecl sub_8051510(size_t size);
void *__cdecl sub_8051561(void *ptr, size_t size);
void *__cdecl sub_8051601(void *ptr, int a2);
void __cdecl __noreturn sub_805164D(size_t nmemb, size_t size); // idb
int sub_805169E(); // weak
void *__cdecl sub_80516A3(void *src, size_t n);
void __noreturn sub_80516F1();
void __cdecl sub_805172A(int errnum, int a2, int a3, int a4, int a5);
int __cdecl sub_80517F6(void *s1, size_t n, void *s2, int); // idb
signed int __cdecl sub_80518DF(unsigned int *a1, unsigned int a2);
int __cdecl sub_8051931(unsigned int *a1, unsigned int a2, int a3);
int __cdecl sub_8051975(char *nptr, int, int base, int, char *s); // idb
int __cdecl sub_8051E00(FILE *stream); // idb
int __cdecl sub_8051EEE(int fd, int cmd, char); // idb
int __cdecl sub_8052075(FILE *stream); // idb
int __cdecl sub_80520C0(FILE *fp); // idb
int __cdecl sub_805210D(FILE *stream, int, int, int); // idb
size_t __cdecl sub_80521F0(wchar_t *pwc, char *s, size_t n, mbstate_t *p);
int __cdecl sub_8052288(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_80522FF(FILE *fp); // idb
void *sub_80523CD();
char *sub_80528B4();
int __cdecl sub_80529CE(char *s, int, char *s2, int); // idb
int __cdecl sub_8052ACC(void *s1, size_t n, void *s2, int); // idb
int __cdecl sub_8052B94(void *s1, size_t n, void *s2, int); // idb
int __cdecl sub_8052E5F(int a1);
int __cdecl sub_8052F0D(int a1);
int __stdcall sub_80530AA(_DWORD); // weak
int __stdcall sub_805311E(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_8053190(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_8053217(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int sub_8053287(void); // weak
int sub_8053314(void); // weak
int sub_8053386(void); // weak
int sub_80533F8(void); // weak
int sub_8053468(void); // weak
int __stdcall sub_80534D6(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int sub_805355B(void); // weak
int __stdcall sub_80535C9(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int sub_8053637(void); // weak
int (**sub_8053650())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN locret_8049F44; // weak
_UNKNOWN locret_804A090; // weak
_UNKNOWN loc_804AB1F; // weak
_UNKNOWN loc_804AB60; // weak
_UNKNOWN loc_804AB9F; // weak
_UNKNOWN loc_804ABAA; // weak
_UNKNOWN loc_804ABCF; // weak
_UNKNOWN loc_804AC00; // weak
_UNKNOWN loc_804AC41; // weak
_UNKNOWN loc_804AC46; // weak
_UNKNOWN loc_804ADE1; // weak
_UNKNOWN loc_804ADE8; // weak
_UNKNOWN loc_804AEA1; // weak
_UNKNOWN loc_804AEA6; // weak
_UNKNOWN loc_804AF1A; // weak
_UNKNOWN loc_804AF47; // weak
_UNKNOWN loc_804AF99; // weak
_UNKNOWN loc_804AFC1; // weak
_UNKNOWN loc_804AFDA; // weak
_UNKNOWN loc_804B075; // weak
_UNKNOWN loc_804B102; // weak
_UNKNOWN loc_804B142; // weak
_UNKNOWN loc_804B289; // weak
_UNKNOWN loc_804B2AD; // weak
_UNKNOWN loc_804B353; // weak
_UNKNOWN loc_804B596; // weak
_UNKNOWN loc_804B5C9; // weak
_UNKNOWN loc_804B60F; // weak
_UNKNOWN loc_804B6E6; // weak
_UNKNOWN locret_804B71F; // weak
_UNKNOWN loc_804B723; // weak
_UNKNOWN loc_804DE83; // weak
_UNKNOWN loc_804DEDE; // weak
_UNKNOWN loc_804DEFB; // weak
_UNKNOWN loc_804DF00; // weak
_UNKNOWN loc_804DF17; // weak
_UNKNOWN loc_804DFE7; // weak
_UNKNOWN loc_804E0F9; // weak
_UNKNOWN loc_804E664; // weak
_UNKNOWN loc_804E66E; // weak
_UNKNOWN loc_804E6E5; // weak
_UNKNOWN loc_804E707; // weak
_UNKNOWN unk_804E789; // weak
_UNKNOWN loc_804EB83; // weak
_UNKNOWN loc_804EC0C; // weak
_UNKNOWN locret_804EC46; // weak
_UNKNOWN loc_804EE53; // weak
_UNKNOWN loc_804EE5D; // weak
_UNKNOWN loc_804F494; // weak
_UNKNOWN loc_804F4C0; // weak
_UNKNOWN loc_804F4D3; // weak
_UNKNOWN loc_804F516; // weak
_UNKNOWN loc_804F598; // weak
_UNKNOWN loc_804F610; // weak
_UNKNOWN loc_804F655; // weak
_UNKNOWN loc_804F65A; // weak
_UNKNOWN loc_804F6A1; // weak
_UNKNOWN loc_804F765; // weak
_UNKNOWN loc_804F790; // weak
_UNKNOWN loc_804F7BE; // weak
_UNKNOWN loc_804F7C4; // weak
_UNKNOWN loc_804F7FE; // weak
_UNKNOWN loc_804F822; // weak
_UNKNOWN loc_804F827; // weak
_UNKNOWN loc_804F82C; // weak
_UNKNOWN loc_804F987; // weak
_UNKNOWN loc_804F98C; // weak
_UNKNOWN loc_804F9C6; // weak
_UNKNOWN loc_804F9CB; // weak
_UNKNOWN loc_804F9DC; // weak
_UNKNOWN loc_804FA38; // weak
_UNKNOWN loc_804FA3D; // weak
_UNKNOWN loc_804FA66; // weak
_UNKNOWN loc_804FA6B; // weak
_UNKNOWN loc_804FAA1; // weak
_UNKNOWN loc_804FAA6; // weak
_UNKNOWN loc_804FC04; // weak
_UNKNOWN loc_804FC09; // weak
_UNKNOWN loc_804FD2A; // weak
_UNKNOWN loc_804FD5B; // weak
_UNKNOWN loc_804FD7A; // weak
_UNKNOWN loc_804FE70; // weak
_UNKNOWN loc_804FF6D; // weak
_UNKNOWN loc_804FF8C; // weak
_UNKNOWN loc_804FFD1; // weak
_UNKNOWN loc_804FFF5; // weak
_UNKNOWN loc_804FFFA; // weak
_UNKNOWN loc_80500F4; // weak
_UNKNOWN loc_8050113; // weak
_UNKNOWN loc_8050125; // weak
_UNKNOWN loc_8050155; // weak
_UNKNOWN loc_8050166; // weak
_UNKNOWN loc_8050185; // weak
_UNKNOWN loc_8050216; // weak
_UNKNOWN loc_805022E; // weak
_UNKNOWN loc_8050283; // weak
_UNKNOWN loc_80502DF; // weak
_UNKNOWN loc_80503E5; // weak
_UNKNOWN loc_80503EA; // weak
_UNKNOWN loc_8050645; // weak
_UNKNOWN loc_8050658; // weak
_UNKNOWN loc_8051253; // weak
_UNKNOWN loc_80512E0; // weak
_UNKNOWN loc_8051557; // weak
_UNKNOWN loc_805155C; // weak
_UNKNOWN loc_8051586; // weak
_UNKNOWN loc_80515AB; // weak
_UNKNOWN loc_80515DF; // weak
_UNKNOWN loc_80515FC; // weak
_UNKNOWN locret_80515FF; // weak
_UNKNOWN loc_8051699; // weak
_UNKNOWN loc_8051ACE; // weak
_UNKNOWN loc_8051AF5; // weak
_UNKNOWN loc_8051BC2; // weak
_UNKNOWN loc_8051BD6; // weak
_UNKNOWN loc_8051BF8; // weak
_UNKNOWN loc_8051DCE; // weak
_UNKNOWN locret_8051DFE; // weak
_UNKNOWN loc_8051EBA; // weak
_UNKNOWN loc_8051EC4; // weak
_UNKNOWN loc_805201C; // weak
_UNKNOWN loc_8052044; // weak
_UNKNOWN locret_805210B; // weak
_UNKNOWN locret_80521EE; // weak
_UNKNOWN loc_805224A; // weak
_UNKNOWN loc_8052283; // weak
_UNKNOWN locret_8052286; // weak
_UNKNOWN loc_80524AC; // weak
_UNKNOWN loc_80525EB; // weak
_UNKNOWN loc_8052612; // weak
_UNKNOWN loc_8052673; // weak
_UNKNOWN loc_805267C; // weak
_UNKNOWN loc_80526C0; // weak
_UNKNOWN loc_80526C9; // weak
_UNKNOWN loc_805285E; // weak
_UNKNOWN loc_805287B; // weak
_UNKNOWN loc_80528E8; // weak
_UNKNOWN loc_80528EF; // weak
_UNKNOWN loc_80528FC; // weak
_UNKNOWN loc_80529B8; // weak
_UNKNOWN loc_8052A4E; // weak
_UNKNOWN loc_8052A5C; // weak
_UNKNOWN loc_8052A69; // weak
_UNKNOWN loc_8052B8F; // weak
_UNKNOWN unk_8053770; // weak
char s = '\0'; // idb
struct option longopts = { "ignore-case", 0, NULL, 105 }; // idb
_UNKNOWN unk_80545DE; // weak
_UNKNOWN unk_80545E2; // weak
_UNKNOWN unk_80545EE; // weak
_UNKNOWN unk_80545F2; // weak
_UNKNOWN unk_80545F5; // weak
_UNKNOWN unk_8054F00; // weak
_UNKNOWN unk_8054F57; // weak
_UNKNOWN unk_80551BC; // weak
_UNKNOWN unk_80551BF; // weak
int dword_8055EF8 = 1694498816; // weak
_UNKNOWN unk_8056204; // weak
_UNKNOWN unk_8056207; // weak
_UNKNOWN unk_8057254; // weak
_UNKNOWN unk_8057257; // weak
int (*off_8058EC4[2])() = { &sub_8049240, &sub_8049220 }; // weak
int (*off_8058EC8)() = &sub_8049220; // weak
int (*dword_8059008)(void) = NULL; // weak
int dword_8059114 = 0; // weak
int dword_8059128 = 0; // weak
int dword_805913C = 0; // weak
int dword_8059150 = 0; // weak
int dword_8059164 = 0; // weak
int dword_8059178 = 0; // weak
int dword_805918C = 0; // weak
int dword_80591A0 = 0; // weak
int dword_80591B4 = 0; // weak
int dword_80591C8 = 0; // weak
int dword_80591DC = 0; // weak
int dword_80591F0 = 0; // weak
int dword_8059204 = 0; // weak
int dword_8059240 = 0; // weak
int dword_8059244 = 4294967295; // weak
int dword_8059248 = 4294967295; // weak
void *off_805924C = &unk_805988D; // weak
int c = 4294967295; // idb
int status = 1; // idb
int dword_805927C = 1; // weak
int dword_8059280 = 256; // weak
void *off_8059284 = &unk_805991D; // weak
int *off_8059288 = &dword_8059280; // weak
_UNKNOWN unk_805929C; // weak
_UNKNOWN unk_80592B8; // weak
_UNKNOWN unk_80592BB; // weak
_UNKNOWN unk_80592C0; // weak
_UNKNOWN unk_80592C3; // weak
_UNKNOWN unk_80592CC; // weak
_UNKNOWN unk_80592CF; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int program_invocation_name; // weak
int optind; // weak
FILE *stdout; // idb
char byte_805932C; // weak
_UNKNOWN unk_80594FE; // weak
char byte_80596C8; // weak
char byte_8059715; // weak
char byte_8059849; // weak
int dword_805984D[]; // weak
int dword_8059855[]; // weak
int dword_8059859[2]; // idb
char *s1; // idb
void *ptr[2]; // idb
char byte_8059875; // weak
char byte_8059878; // weak
char byte_8059879; // weak
char byte_805987A[]; // weak
char byte_805987B; // weak
char *dword_805987D; // idb
char byte_8059881; // weak
int dword_8059899; // weak
char byte_80598B5; // weak
int dword_80598B9; // weak
char byte_80598BD; // weak
int dword_80598C1; // weak
int dword_80598DD; // weak
int dword_80598E1; // weak
int dword_80598E5; // weak
int dword_80598E9; // weak
int dword_80598ED; // weak
int dword_80598F1; // weak
int dword_80598F5; // weak
int dword_80598F9; // weak
int dword_80598FD; // weak
int dword_8059901; // weak
int dword_8059905; // weak
int dword_8059909; // weak
_UNKNOWN unk_805991D; // weak
int dword_8059A1D; // weak
int dword_8059A21; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (08048D18) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 8049140: using guessed type int _gmon_start__(void);

//----- (08048D40) --------------------------------------------------------
int sub_8048D40()
{
  return dword_8059008();
}
// 8059008: using guessed type int (*dword_8059008)(void);

//----- (08049150) --------------------------------------------------------
#error "8049153: positive sp value has been found (funcsize=2)"

//----- (08049183) --------------------------------------------------------
void sub_8049183()
{
  ;
}

//----- (080491A0) --------------------------------------------------------
void sub_80491A0()
{
  ;
}

//----- (080491B0) --------------------------------------------------------
int sub_80491B0()
{
  int result; // eax

  result = &unk_80592CF - &unk_80592CC;
  if ( (unsigned int)(&unk_80592CF - &unk_80592CC) > 6 )
    result = 0;
  return result;
}
// 80491B0: could not find valid save-restore pair for ebp

//----- (08049220) --------------------------------------------------------
int sub_8049220()
{
  int result; // eax

  if ( !byte_805932C )
  {
    result = sub_80491B0();
    byte_805932C = 1;
  }
  return result;
}
// 8049220: could not find valid save-restore pair for ebp
// 805932C: using guessed type char byte_805932C;

//----- (08049240) --------------------------------------------------------
int sub_8049240()
{
  return 0;
}
// 8049240: could not find valid save-restore pair for ebp

//----- (0804929F) --------------------------------------------------------
void sub_804929F()
{
  ;
}

//----- (080492BA) --------------------------------------------------------
void sub_80492BA()
{
  ;
}

//----- (080492CA) --------------------------------------------------------
int sub_80492CA()
{
  int result; // eax

  result = &unk_80592BB - &unk_80592B8;
  if ( (unsigned int)(&unk_80592BB - &unk_80592B8) > 6 )
    result = 0;
  return result;
}
// 80492CA: could not find valid save-restore pair for ebp

//----- (080493AC) --------------------------------------------------------
void sub_80493AC()
{
  ;
}

//----- (080493C7) --------------------------------------------------------
void sub_80493C7()
{
  ;
}

//----- (080493D7) --------------------------------------------------------
signed int sub_80493D7()
{
  return 3;
}
// 80493D7: could not find valid save-restore pair for ebp

//----- (08049489) --------------------------------------------------------
int __usercall sub_8049489@<eax>(void (__cdecl *a1)(signed int)@<eax>)
{
  a1(134577876);
  return 0;
}

//----- (080494D5) --------------------------------------------------------
void sub_80494D5()
{
  ;
}

//----- (080494F0) --------------------------------------------------------
void sub_80494F0()
{
  ;
}

//----- (08049500) --------------------------------------------------------
int sub_8049500()
{
  int result; // eax

  result = &unk_80592BB - &unk_80592B8;
  if ( (unsigned int)(&unk_80592BB - &unk_80592B8) > 6 )
    result = 0;
  return result;
}
// 8049500: could not find valid save-restore pair for ebp

//----- (080495E2) --------------------------------------------------------
void sub_80495E2()
{
  ;
}

//----- (080495FD) --------------------------------------------------------
void sub_80495FD()
{
  ;
}

//----- (0804960D) --------------------------------------------------------
int sub_804960D()
{
  int result; // eax

  result = &unk_80592BB - &unk_80592B8;
  if ( (unsigned int)(&unk_80592BB - &unk_80592B8) > 6 )
    result = 0;
  return result;
}
// 804960D: could not find valid save-restore pair for ebp

//----- (080496F9) --------------------------------------------------------
void sub_80496F9()
{
  ;
}

//----- (08049714) --------------------------------------------------------
void sub_8049714()
{
  ;
}

//----- (08049724) --------------------------------------------------------
int sub_8049724()
{
  int result; // eax

  result = &unk_80592BB - &unk_80592B8;
  if ( (unsigned int)(&unk_80592BB - &unk_80592B8) > 6 )
    result = 0;
  return result;
}
// 8049724: could not find valid save-restore pair for ebp

//----- (08049822) --------------------------------------------------------
void sub_8049822()
{
  ;
}

//----- (0804983D) --------------------------------------------------------
void sub_804983D()
{
  ;
}

//----- (0804984D) --------------------------------------------------------
int sub_804984D()
{
  int result; // eax

  result = &unk_8057257 - &unk_8057254;
  if ( (unsigned int)(&unk_8057257 - &unk_8057254) > 6 )
    result = 0;
  return result;
}
// 804984D: could not find valid save-restore pair for ebp

//----- (08049939) --------------------------------------------------------
void sub_8049939()
{
  ;
}

//----- (08049954) --------------------------------------------------------
void sub_8049954()
{
  ;
}

//----- (08049964) --------------------------------------------------------
int sub_8049964()
{
  int result; // eax

  result = &unk_80594FE - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_80594FE - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 8049964: could not find valid save-restore pair for ebp
// 80592E0: using guessed type int program_invocation_short_name;

//----- (08049A50) --------------------------------------------------------
void sub_8049A50()
{
  ;
}

//----- (08049A6B) --------------------------------------------------------
void sub_8049A6B()
{
  ;
}

//----- (08049A7B) --------------------------------------------------------
int sub_8049A7B()
{
  int result; // eax

  result = &unk_80592BB - &unk_80592B8;
  if ( (unsigned int)(&unk_80592BB - &unk_80592B8) > 6 )
    result = 0;
  return result;
}
// 8049A7B: could not find valid save-restore pair for ebp

//----- (08049AD9) --------------------------------------------------------
int sub_8049AD9()
{
  return nullsub_3();
}
// 8049AD9: could not find valid save-restore pair for ebp
// 8049AD8: using guessed type int nullsub_3(void);

//----- (08049B79) --------------------------------------------------------
void sub_8049B79()
{
  ;
}

//----- (08049B94) --------------------------------------------------------
void sub_8049B94()
{
  ;
}

//----- (08049BA4) --------------------------------------------------------
#error "8049BD1: call analysis failed (funcsize=23)"

//----- (08049CBB) --------------------------------------------------------
void sub_8049CBB()
{
  ;
}

//----- (08049CD6) --------------------------------------------------------
void sub_8049CD6()
{
  ;
}

//----- (08049CE6) --------------------------------------------------------
int sub_8049CE6()
{
  int result; // eax

  result = &unk_8056207 - &unk_8056204;
  if ( (unsigned int)(&unk_8056207 - &unk_8056204) > 6 )
    result = 0;
  return result;
}
// 8049CE6: could not find valid save-restore pair for ebp

//----- (08049DC8) --------------------------------------------------------
void sub_8049DC8()
{
  ;
}

//----- (08049DE3) --------------------------------------------------------
void sub_8049DE3()
{
  ;
}

//----- (08049DF3) --------------------------------------------------------
int sub_8049DF3()
{
  int result; // eax

  result = &unk_80592BB - &unk_80592B8;
  if ( (unsigned int)(&unk_80592BB - &unk_80592B8) > 6 )
    result = 0;
  return result;
}
// 8049DF3: could not find valid save-restore pair for ebp

//----- (08049E1F) --------------------------------------------------------
int sub_8049E1F()
{
  return 0;
}
// 8049E1F: could not find valid save-restore pair for ebp

//----- (08049EBE) --------------------------------------------------------
int __usercall sub_8049EBE@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  a1(&dword_8055EF8);
  return sub_8049E1F();
}
// 8055EF8: using guessed type int dword_8055EF8;

//----- (08049F0A) --------------------------------------------------------
void sub_8049F0A()
{
  ;
}

//----- (08049F25) --------------------------------------------------------
void sub_8049F25()
{
  ;
}

//----- (08049F35) --------------------------------------------------------
int sub_8049F35()
{
  int result; // eax
  int (__stdcall *v1)(void *, int, int, int, int, int); // eax
  int v2; // [esp+4h] [ebp-18h]
  int v3; // [esp+8h] [ebp-14h]
  int v4; // [esp+Ch] [ebp-10h]
  int v5; // [esp+10h] [ebp-Ch]
  int v6; // [esp+14h] [ebp-8h]
  int v7; // [esp+18h] [ebp-4h]

  result = &unk_80592BB - &unk_80592B8;
  if ( (unsigned int)(&unk_80592BB - &unk_80592B8) > 6 )
  {
    v7 = 0;
    dword_8059178 = (int)&locret_8049F44;
    v1 = (int (__stdcall *)(void *, int, int, int, int, int))sub_80533F8();
    result = v1(&unk_80592B8, v2, v3, v4, v5, v6);
  }
  return result;
}
// 80533F8: using guessed type int sub_80533F8(void);
// 8059178: using guessed type int dword_8059178;

//----- (08049FD8) --------------------------------------------------------
int sub_8049FD8()
{
  int result; // eax

  result = sub_8049F35();
  byte_80596C8 = 1;
  return result;
}
// 80596C8: using guessed type char byte_80596C8;

//----- (0804A056) --------------------------------------------------------
void sub_804A056()
{
  ;
}

//----- (0804A071) --------------------------------------------------------
void sub_804A071()
{
  ;
}

//----- (0804A081) --------------------------------------------------------
int sub_804A081()
{
  int result; // eax
  int (__stdcall *v1)(void *, int, int, int, int, int); // eax
  int v2; // [esp+4h] [ebp-18h]
  int v3; // [esp+8h] [ebp-14h]
  int v4; // [esp+Ch] [ebp-10h]
  int v5; // [esp+10h] [ebp-Ch]
  int v6; // [esp+14h] [ebp-8h]
  int v7; // [esp+18h] [ebp-4h]

  result = &unk_80592BB - &unk_80592B8;
  if ( (unsigned int)(&unk_80592BB - &unk_80592B8) > 6 )
  {
    v7 = 0;
    dword_805913C = (int)&locret_804A090;
    v1 = (int (__stdcall *)(void *, int, int, int, int, int))sub_805355B();
    result = v1(&unk_80592B8, v2, v3, v4, v5, v6);
  }
  return result;
}
// 805355B: using guessed type int sub_805355B(void);
// 805913C: using guessed type int dword_805913C;

//----- (0804A124) --------------------------------------------------------
int sub_804A124()
{
  int result; // eax

  result = sub_804A081();
  byte_8059715 = 1;
  return result;
}
// 8059715: using guessed type char byte_8059715;

//----- (0804A198) --------------------------------------------------------
void sub_804A198()
{
  ;
}

//----- (0804A1B3) --------------------------------------------------------
void sub_804A1B3()
{
  ;
}

//----- (0804A1C3) --------------------------------------------------------
int sub_804A1C3()
{
  int result; // eax

  result = &unk_80551BF - &unk_80551BC;
  if ( (unsigned int)(&unk_80551BF - &unk_80551BC) > 6 )
    result = 0;
  return result;
}
// 804A1C3: could not find valid save-restore pair for ebp

//----- (0804A221) --------------------------------------------------------
int sub_804A221()
{
  return nullsub_4();
}
// 804A221: could not find valid save-restore pair for ebp
// 804A220: using guessed type int nullsub_4(void);

//----- (0804A2CB) --------------------------------------------------------
void sub_804A2CB()
{
  ;
}

//----- (0804A308) --------------------------------------------------------
void sub_804A308()
{
  ;
}

//----- (0804A318) --------------------------------------------------------
signed int sub_804A318()
{
  return 4;
}
// 804A318: could not find valid save-restore pair for ebx
// 804A318: could not find valid save-restore pair for ebp
// 8053287: using guessed type int sub_8053287(void);
// 80591B4: using guessed type int dword_80591B4;

//----- (0804A413) --------------------------------------------------------
void sub_804A413()
{
  ;
}

//----- (0804A43C) --------------------------------------------------------
void sub_804A43C()
{
  ;
}

//----- (0804A44C) --------------------------------------------------------
int sub_804A44C()
{
  int result; // eax

  result = &unk_80592C3 - &unk_80592C0;
  if ( (unsigned int)(&unk_80592C3 - &unk_80592C0) > 6 )
    result = 0;
  return result;
}
// 804A44C: could not find valid save-restore pair for ebp

//----- (0804A54A) --------------------------------------------------------
void sub_804A54A()
{
  ;
}

//----- (0804A575) --------------------------------------------------------
void sub_804A575()
{
  ;
}

//----- (0804A585) --------------------------------------------------------
signed int sub_804A585()
{
  return 4;
}
// 804A585: could not find valid save-restore pair for ebp

//----- (0804A5BD) --------------------------------------------------------
#error "804A5E9: call analysis failed (funcsize=16)"

//----- (0804A5EF) --------------------------------------------------------
int __usercall sub_804A5EF@<eax>(int a1@<ebp>)
{
  int v1; // eax
  int (__cdecl *v2)(signed int, int); // edx
  int v4; // [esp+18h] [ebp-4h]

  dword_80591A0 = (int)nullsub_5;
  v1 = sub_8053314();
  v4 = a1;
  return v2(134565520, v1);
}
// 804A5EF: could not find valid save-restore pair for ebp
// 804A5EE: using guessed type int nullsub_5();
// 8053314: using guessed type int sub_8053314(void);
// 80591A0: using guessed type int dword_80591A0;

//----- (0804A64D) --------------------------------------------------------
signed int sub_804A64D()
{
  signed int result; // eax

  result = sub_804A585();
  byte_8059849 = 1;
  return result;
}
// 8059849: using guessed type char byte_8059849;

//----- (0804A6A7) --------------------------------------------------------
int __usercall sub_804A6A7@<eax>(void (__cdecl *a1)(signed int)@<eax>)
{
  a1(134565576);
  return sub_804A5BD();
}
// 804A5BD: using guessed type int sub_804A5BD(void);

//----- (0804A6C1) --------------------------------------------------------
int __cdecl sub_804A6C1(unsigned __int8 a1)
{
  return (*__ctype_b_loc())[a1] & 1 || a1 == 10;
}

//----- (0804A70E) --------------------------------------------------------
int __cdecl sub_804A70E(char *s1)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // ebx
  char *v5; // eax
  char *v7; // [esp+1Ch] [ebp-4Ch]
  void **i; // [esp+20h] [ebp-48h]
  const char *v9; // [esp+24h] [ebp-44h]
  void *v10; // [esp+28h] [ebp-40h]
  const char *v11; // [esp+2Ch] [ebp-3Ch]
  const char *v12; // [esp+30h] [ebp-38h]
  const char *v13; // [esp+34h] [ebp-34h]
  const char *v14; // [esp+38h] [ebp-30h]
  const char *v15; // [esp+3Ch] [ebp-2Ch]
  const char *v16; // [esp+40h] [ebp-28h]
  const char *v17; // [esp+44h] [ebp-24h]
  const char *v18; // [esp+48h] [ebp-20h]
  const char *v19; // [esp+4Ch] [ebp-1Ch]
  const char *v20; // [esp+50h] [ebp-18h]
  const char *v21; // [esp+54h] [ebp-14h]
  int v22; // [esp+58h] [ebp-10h]
  int v23; // [esp+5Ch] [ebp-Ch]

  v10 = &unk_8053770;
  v11 = "test invocation";
  v12 = "coreutils";
  v13 = "Multi-call invocation";
  v14 = "sha224sum";
  v15 = "sha2 utilities";
  v16 = "sha256sum";
  v17 = "sha2 utilities";
  v18 = "sha384sum";
  v19 = "sha2 utilities";
  v20 = "sha512sum";
  v21 = "sha2 utilities";
  v22 = 0;
  v23 = 0;
  v7 = s1;
  for ( i = &v10; *i && strcmp(s1, (const char *)*i); i += 2 )
    ;
  if ( i[1] )
    v7 = (char *)i[1];
  v1 = gettext("\n%s online help: <%s>\n");
  printf(v1, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  v9 = setlocale(5, 0);
  if ( v9 && strncmp(v9, "en_", 3u) )
  {
    v2 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
    printf(v2, s1);
  }
  v3 = gettext("Full documentation at: <%s%s>\n");
  printf(v3, "http://www.gnu.org/software/coreutils/", s1);
  if ( v7 == s1 )
    v4 = " invocation";
  else
    v4 = &s;
  v5 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  return printf(v5, v7, v4);
}

//----- (0804A894) --------------------------------------------------------
void __cdecl __noreturn sub_804A894(int status)
{
  int v1; // ebx
  char *v2; // eax
  int v3; // ebx
  char *v4; // eax
  FILE *v5; // ebx
  char *v6; // eax
  FILE *v7; // ebx
  char *v8; // eax
  FILE *v9; // ebx
  char *v10; // eax
  FILE *v11; // ebx
  char *v12; // eax
  FILE *v13; // ebx
  char *v14; // eax
  FILE *v15; // ebx
  char *v16; // eax
  FILE *v17; // ebx
  char *v18; // eax
  FILE *v19; // ebx
  char *v20; // eax
  FILE *v21; // ebx
  char *v22; // eax

  if ( status )
  {
    v1 = dword_80598C1;
    v2 = gettext("Try '%s --help' for more information.\n");
    fprintf(stderr, v2, v1);
  }
  else
  {
    v3 = dword_80598C1;
    v4 = gettext("Usage: %s [OPTION]... FILE1 FILE2\n");
    printf(v4, v3);
    v5 = stdout;
    v6 = gettext(
           "For each pair of input lines with identical join fields, write a line to\n"
           "standard output.  The default join field is the first, delimited by blanks.\n");
    fputs_unlocked(v6, v5);
    v7 = stdout;
    v8 = gettext("\nWhen FILE1 or FILE2 (not both) is -, read standard input.\n");
    fputs_unlocked(v8, v7);
    v9 = stdout;
    v10 = gettext(
            "\n"
            "  -a FILENUM        also print unpairable lines from file FILENUM, where\n"
            "                      FILENUM is 1 or 2, corresponding to FILE1 or FILE2\n"
            "  -e EMPTY          replace missing input fields with EMPTY\n");
    fputs_unlocked(v10, v9);
    v11 = stdout;
    v12 = gettext(
            "  -i, --ignore-case  ignore differences in case when comparing fields\n"
            "  -j FIELD          equivalent to '-1 FIELD -2 FIELD'\n"
            "  -o FORMAT         obey FORMAT while constructing output line\n"
            "  -t CHAR           use CHAR as input and output field separator\n");
    fputs_unlocked(v12, v11);
    v13 = stdout;
    v14 = gettext(
            "  -v FILENUM        like -a FILENUM, but suppress joined output lines\n"
            "  -1 FIELD          join on this FIELD of file 1\n"
            "  -2 FIELD          join on this FIELD of file 2\n"
            "  --check-order     check that the input is correctly sorted, even\n"
            "                      if all input lines are pairable\n"
            "  --nocheck-order   do not check that the input is correctly sorted\n"
            "  --header          treat the first line in each file as field headers,\n"
            "                      print them without trying to pair them\n");
    fputs_unlocked(v14, v13);
    v15 = stdout;
    v16 = gettext("  -z, --zero-terminated     line delimiter is NUL, not newline\n");
    fputs_unlocked(v16, v15);
    v17 = stdout;
    v18 = gettext("      --help     display this help and exit\n");
    fputs_unlocked(v18, v17);
    v19 = stdout;
    v20 = gettext("      --version  output version information and exit\n");
    fputs_unlocked(v20, v19);
    v21 = stdout;
    v22 = gettext(
            "\n"
            "Unless -t CHAR is given, leading blanks separate fields and are ignored,\n"
            "else fields are separated by CHAR.  Any FIELD is a field number counted\n"
            "from 1.  FORMAT is one or more comma or blank separated specifications,\n"
            "each being 'FILENUM.FIELD' or '0'.  Default FORMAT outputs the join field,\n"
            "the remaining fields from FILE1, the remaining fields from FILE2, all\n"
            "separated by CHAR.  If FORMAT is the keyword 'auto', then the first\n"
            "line of each file determines the number of fields output for each line.\n"
            "\n"
            "Important: FILE1 and FILE2 must be sorted on the join fields.\n"
            "E.g., use \"sort -k 1b,1\" if 'join' has no options,\n"
            "or use \"join -t ''\" if 'sort' has no options.\n"
            "Note, comparisons honor the rules specified by 'LC_COLLATE'.\n"
            "If the input is not sorted and some lines cannot be joined, a\n"
            "warning message will be given.\n");
    fputs_unlocked(v22, v21);
    sub_804A70E("join");
  }
  exit(status);
}
// 8048F50: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 80598C1: using guessed type int dword_80598C1;

//----- (0804AA21) --------------------------------------------------------
int __cdecl sub_804AA21(int a1, int a2, int a3)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 12) >= *(_DWORD *)(a1 + 16) )
    *(_DWORD *)(a1 + 20) = sub_8051446(*(void **)(a1 + 20), a1 + 16, 8);
  *(_DWORD *)(8 * *(_DWORD *)(a1 + 12) + *(_DWORD *)(a1 + 20)) = a2;
  *(_DWORD *)(8 * *(_DWORD *)(a1 + 12) + *(_DWORD *)(a1 + 20) + 4) = a3;
  result = a1;
  ++*(_DWORD *)(a1 + 12);
  return result;
}

//----- (0804AA9B) --------------------------------------------------------
#error "804ABCA: call analysis failed (funcsize=142)"

//----- (0804ACD2) --------------------------------------------------------
int __cdecl sub_804ACD2(int a1)
{
  int result; // eax

  if ( a1 )
  {
    free(*(void **)(a1 + 20));
    *(_DWORD *)(a1 + 20) = 0;
    free(*(void **)(a1 + 8));
    result = a1;
    *(_DWORD *)(a1 + 8) = 0;
  }
  return result;
}

//----- (0804AD32) --------------------------------------------------------
int __cdecl sub_804AD32(int a1, int a2, unsigned int a3, unsigned int a4)
{
  void *v4; // eax
  int result; // eax
  unsigned int v6; // eax
  size_t v7; // eax
  void *v8; // eax
  void *s1; // [esp+1Ch] [ebp-1Ch]
  void *s2; // [esp+20h] [ebp-18h]
  size_t v11; // [esp+24h] [ebp-14h]
  unsigned int n; // [esp+28h] [ebp-10h]
  int v13; // [esp+2Ch] [ebp-Ch]

  if ( *(_DWORD *)(a1 + 12) <= a3 )
  {
    s1 = 0;
    v11 = 0;
  }
  else
  {
    s1 = *(void **)(8 * a3 + *(_DWORD *)(a1 + 20));
    v11 = *(_DWORD *)(8 * a3 + *(_DWORD *)(a1 + 20) + 4);
  }
  if ( *(_DWORD *)(a2 + 12) <= a4 )
  {
    s2 = 0;
    n = 0;
  }
  else
  {
    s2 = *(void **)(8 * a4 + *(_DWORD *)(a2 + 20));
    n = *(_DWORD *)(8 * a4 + *(_DWORD *)(a2 + 20) + 4);
  }
  if ( v11 )
  {
    if ( !n )
      return 1;
    if ( byte_80598B5 )
    {
      v6 = v11;
      if ( n <= v11 )
        v6 = n;
      v13 = sub_804EF73((int)s1, (int)s2, v6);
    }
    else
    {
      if ( byte_8059875 )
        return sub_80517F6(s1, v11, s2, n);
      v7 = v11;
      if ( n <= v11 )
        v7 = n;
      v13 = memcmp(s1, s2, v7);
    }
    v8 = &loc_804AEA1;
    if ( !v13 )
      v8 = &loc_804AEA6;
    dword_80591B4 = (int)v8;
    sub_8053287();
    result = v13;
  }
  else
  {
    v4 = &loc_804ADE1;
    if ( n )
      v4 = &loc_804ADE8;
    dword_805913C = (int)v4;
    sub_805355B();
    result = 0;
  }
  return result;
}
// 8053287: using guessed type int sub_8053287(void);
// 805355B: using guessed type int sub_805355B(void);
// 805913C: using guessed type int dword_805913C;
// 80591B4: using guessed type int dword_80591B4;
// 8059875: using guessed type char byte_8059875;
// 80598B5: using guessed type char byte_80598B5;

//----- (0804AEC3) --------------------------------------------------------
int __cdecl sub_804AEC3(int a1, int a2, int a3)
{
  int result; // eax
  void *v4; // eax
  void *v5; // eax
  unsigned int v6; // eax
  int v7; // eax
  bool v8; // zf
  bool v9; // sf
  void *v10; // eax
  signed int v11; // eax
  void *v12; // eax
  signed int v13; // eax
  int v14; // ST34_4
  signed int v15; // ST30_4
  int v16; // ebx
  int v17; // esi
  char *v18; // edi
  char *v19; // eax
  int v20; // [esp+0h] [ebp-58h]
  int v21; // [esp+0h] [ebp-58h]
  int v22; // [esp+4h] [ebp-54h]
  int v23; // [esp+8h] [ebp-50h]
  int v24; // [esp+Ch] [ebp-4Ch]
  int v25; // [esp+10h] [ebp-48h]
  int v26; // [esp+14h] [ebp-44h]
  int v27; // [esp+18h] [ebp-40h]
  int v28; // [esp+1Ch] [ebp-3Ch]
  int v29; // [esp+20h] [ebp-38h]
  int v30; // [esp+24h] [ebp-34h]
  int v31; // [esp+28h] [ebp-30h]
  int v32; // [esp+2Ch] [ebp-2Ch]
  int v33; // [esp+30h] [ebp-28h]
  int v34; // [esp+34h] [ebp-24h]
  int v35; // [esp+38h] [ebp-20h]
  signed int v36; // [esp+38h] [ebp-20h]
  unsigned int v37; // [esp+3Ch] [ebp-1Ch]
  int v38; // [esp+40h] [ebp-18h]

  result = dword_8059899;
  if ( dword_8059899 != 2 )
  {
    if ( dword_8059899 != 1 )
    {
      v4 = &loc_804AF1A;
      if ( !byte_8059879 )
        v4 = &loc_804B075;
      dword_8059204 = (int)v4;
      sub_80530AA(v20);
    }
    v5 = &loc_804AF47;
    if ( byte_805987A[a3 - 1] == 1 )
      v5 = &loc_804B075;
    dword_805913C = (int)v5;
    sub_805355B();
    if ( a3 == 1 )
      v6 = dword_8059244;
    else
      v6 = dword_8059248;
    v37 = v6;
    v7 = sub_804AD32(a1, a2, v6, v6);
    v8 = v7 == 0;
    v9 = v7 < 0;
    v10 = &loc_804AF99;
    if ( v9 || v8 )
      v10 = &loc_804B075;
    dword_80591DC = (int)v10;
    sub_8053190(v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v37, v38);
    v11 = *(_DWORD *)(a2 + 4);
    v36 = v11;
    v8 = v11 == 0;
    v12 = &loc_804AFC1;
    if ( v8 )
      v12 = &loc_804AFDA;
    dword_8059164 = (int)v12;
    sub_8053468();
    if ( *(_BYTE *)(v36 - 1 + *(_DWORD *)(a2 + 8)) == 10 )
      --v36;
    if ( v36 < 0 )
      v13 = 0x7FFFFFFF;
    else
      v13 = v36;
    v14 = *(_DWORD *)(a2 + 8);
    v15 = v13;
    v16 = dword_8059855[2 * (a3 - 1)];
    v17 = dword_8059859[2 * (a3 - 1)];
    v18 = (&s1)[a3 - 1];
    v19 = gettext("%s:%llu: is not sorted: %.*s");
    error(dword_8059899 == 1, 0, v19, v18, v16, v17, v15, v14);
    result = a3 - 1;
    byte_805987A[a3 - 1] = 1;
  }
  return result;
}
// 80530AA: using guessed type int __stdcall sub_80530AA(_DWORD);
// 8053190: using guessed type int __stdcall sub_8053190(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8053468: using guessed type int sub_8053468(void);
// 805355B: using guessed type int sub_805355B(void);
// 805913C: using guessed type int dword_805913C;
// 8059164: using guessed type int dword_8059164;
// 80591DC: using guessed type int dword_80591DC;
// 8059204: using guessed type int dword_8059204;
// 8059244: using guessed type int dword_8059244;
// 8059248: using guessed type int dword_8059248;
// 8059855: using guessed type int dword_8059855[];
// 8059879: using guessed type char byte_8059879;
// 8059899: using guessed type int dword_8059899;

//----- (0804B07D) --------------------------------------------------------
int __cdecl sub_804B07D(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (0804B08C) --------------------------------------------------------
void __noreturn sub_804B08C()
{
  sub_805164D(1u, 0x18u);
}

//----- (0804B0C8) --------------------------------------------------------
#error "804B0FD: call analysis failed (funcsize=114)"

//----- (0804B253) --------------------------------------------------------
#error "804B284: call analysis failed (funcsize=30)"

//----- (0804B2B9) --------------------------------------------------------
_DWORD *__cdecl sub_804B2B9(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = a1;
  a1[2] = 0;
  return result;
}

//----- (0804B2DB) --------------------------------------------------------
int __cdecl sub_804B2DB(FILE *stream, int a2, int a3)
{
  int v3; // ST00_4
  unsigned int v5; // [esp+1Ch] [ebp-Ch]

  if ( *(_DWORD *)a2 == *(_DWORD *)(a2 + 4) )
  {
    *(_DWORD *)(a2 + 8) = sub_8051446(*(void **)(a2 + 8), a2 + 4, 4);
    v5 = *(_DWORD *)a2;
    dword_8059204 = (int)&loc_804B353;
    sub_80530AA(v3);
    do
      *(_DWORD *)(4 * v5++ + *(_DWORD *)(a2 + 8)) = 0;
    while ( *(_DWORD *)(a2 + 4) > v5 );
  }
  if ( !(unsigned __int8)sub_804B0C8(stream, 4 * *(_DWORD *)a2 + *(_DWORD *)(a2 + 8), a3) )
    return 0;
  ++*(_DWORD *)a2;
  return 1;
}
// 80530AA: using guessed type int __stdcall sub_80530AA(_DWORD);
// 8059204: using guessed type int dword_8059204;

//----- (0804B3B5) --------------------------------------------------------
int __cdecl sub_804B3B5(FILE *stream, int a2, int a3, int a4)
{
  if ( (_BYTE)a3 )
    *(_DWORD *)a2 = 0;
  return sub_804B2DB(stream, a2, a4);
}

//----- (0804B3EB) --------------------------------------------------------
void __cdecl sub_804B3EB(int a1)
{
  unsigned int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; *(_DWORD *)(a1 + 4) > i; ++i )
  {
    sub_804ACD2(*(_DWORD *)(4 * i + *(_DWORD *)(a1 + 8)));
    free(*(void **)(4 * i + *(_DWORD *)(a1 + 8)));
  }
  free(*(void **)(a1 + 8));
}

//----- (0804B4EB) --------------------------------------------------------
char *__cdecl sub_804B4EB(unsigned int a1, unsigned int a2, size_t a3)
{
  size_t v3; // eax
  char v4; // al
  size_t v5; // eax
  bool v6; // zf
  void *v7; // eax
  char *result; // eax
  int v9; // ST08_4
  void *v10; // eax
  int v11; // [esp-30h] [ebp-58h]
  int v12; // [esp-2Ch] [ebp-54h]
  int v13; // [esp-28h] [ebp-50h]
  int v14; // [esp-24h] [ebp-4Ch]
  int v15; // [esp-20h] [ebp-48h]
  int v16; // [esp-1Ch] [ebp-44h]
  int v17; // [esp-18h] [ebp-40h]
  int v18; // [esp-14h] [ebp-3Ch]
  int v19; // [esp-10h] [ebp-38h]
  int v20; // [esp-Ch] [ebp-34h]
  int v21; // [esp+8h] [ebp-20h]
  int v22; // [esp+Ch] [ebp-1Ch]
  int v23; // [esp+10h] [ebp-18h]
  char v24; // [esp+17h] [ebp-11h]
  unsigned int v25; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]
  size_t na; // [esp+1Ch] [ebp-Ch]
  size_t nb; // [esp+1Ch] [ebp-Ch]
  int savedregs; // [esp+28h] [ebp+0h]

  if ( byte_8059881 )
    v3 = a3;
  else
    v3 = *(_DWORD *)(a1 + 12);
  n = v3;
  if ( c < 0 )
    v4 = 32;
  else
    v4 = c;
  v24 = v4;
  if ( a2 > 0 && n > 0 )
  {
    putchar_unlocked(v4);
    if ( *(_DWORD *)(a2 + 12) <= a1 )
    {
      result = dword_805987D;
      if ( dword_805987D )
        result = (char *)fputs_unlocked(dword_805987D, stdout);
    }
    else
    {
      v5 = *(_DWORD *)(8 * a1 + *(_DWORD *)(a2 + 20) + 4);
      na = v5;
      v6 = v5 == 0;
      v7 = &loc_804B596;
      if ( v6 )
        v7 = &loc_804B5C9;
      dword_80591DC = (int)v7;
      sub_8053190(v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, &savedregs, &loc_804B60F, 0, a1, v21, v22, v23);
      result = (char *)fwrite_unlocked(*(const void **)(8 * a1 + *(_DWORD *)(a2 + 20)), 1u, na, stdout);
    }
  }
  else
  {
    v25 = a2 + 1;
    result = (char *)(a2 + 1);
    if ( v25 < n )
    {
      putchar_unlocked(v24);
      if ( *(_DWORD *)(a2 + 12) <= a1 )
      {
        result = dword_805987D;
        if ( dword_805987D )
          result = (char *)fputs_unlocked(dword_805987D, stdout);
      }
      else
      {
        nb = *(_DWORD *)(8 * a1 + *(_DWORD *)(a2 + 20) + 4);
        if ( nb )
        {
          fwrite_unlocked(*(const void **)(8 * a1 + *(_DWORD *)(a2 + 20)), 1u, nb, stdout);
          dword_8059204 = (int)&locret_804B71F;
          sub_80530AA(v9);
        }
        v10 = &loc_804B6E6;
        if ( !dword_805987D )
          v10 = &locret_804B71F;
        dword_8059128 = (int)v10;
        sub_80535C9(v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, &savedregs, &loc_804B723, v25, a1, v21, v22);
        result = (char *)fputs_unlocked(dword_805987D, stdout);
      }
    }
  }
  return result;
}
// 8048F50: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 80530AA: using guessed type int __stdcall sub_80530AA(_DWORD);
// 8053190: using guessed type int __stdcall sub_8053190(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80535C9: using guessed type int __stdcall sub_80535C9(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8059128: using guessed type int dword_8059128;
// 80591DC: using guessed type int dword_80591DC;
// 8059204: using guessed type int dword_8059204;
// 8059881: using guessed type char byte_8059881;

//----- (0804BA18) --------------------------------------------------------
#error "804D19F: call analysis failed (funcsize=1796)"

//----- (0804DAA7) --------------------------------------------------------
_DWORD *__cdecl sub_804DAA7(int a1, int a2)
{
  _DWORD *result; // eax

  if ( a1 && a1 != 1 && a1 != 2 )
    __assert_fail("file == 0 || file == 1 || file == 2", "src/join.c", 0x333u, "add_field");
  if ( !a1 && a2 )
    __assert_fail("file != 0 || field == 0", "src/join.c", 0x334u, "add_field");
  result = sub_8051510(0xCu);
  *result = a1;
  result[1] = a2;
  result[2] = 0;
  *((_DWORD *)off_805924C + 2) = result;
  off_805924C = result;
  return result;
}
// 805924C: using guessed type void *off_805924C;

//----- (0804DB62) --------------------------------------------------------
int __cdecl sub_804DB62(char *nptr)
{
  void *v1; // ebx
  char *v2; // eax
  int v4; // [esp+24h] [ebp-14h]
  int v5; // [esp+28h] [ebp-10h]

  v5 = sub_8051975(nptr, 0, 10, (int)&v4, &s);
  if ( v5 == 1 )
  {
    v4 = -1;
  }
  else if ( v5 || !v4 )
  {
    v1 = sub_8050CF6((int)nptr);
    v2 = gettext("invalid field number: %s");
    error(1, 0, v2, v1);
  }
  return v4 - 1;
}

//----- (0804DC09) --------------------------------------------------------
#error "804DCC1: call analysis failed (funcsize=95)"

//----- (0804DD5C) --------------------------------------------------------
_DWORD *__cdecl sub_804DD5C(char *a1)
{
  char *v1; // eax
  _DWORD *result; // eax
  int v3; // [esp+10h] [ebp-18h]
  int v4; // [esp+14h] [ebp-14h]
  char *s; // [esp+18h] [ebp-10h]
  char *v6; // [esp+1Ch] [ebp-Ch]

  s = a1;
  do
  {
    v6 = s;
    s = strpbrk(s, ", \t");
    if ( s )
    {
      v1 = s++;
      *v1 = 0;
    }
    sub_804DC09(v6, &v3, &v4);
    result = sub_804DAA7(v3, v4);
  }
  while ( s );
  return result;
}
// 804DC09: using guessed type _DWORD __cdecl sub_804DC09(_DWORD, _DWORD, _DWORD);

//----- (0804DDD9) --------------------------------------------------------
__int64 __cdecl sub_804DDD9(__int64 a1)
{
  int v1; // ST28_4
  char *v2; // eax
  __int64 result; // rax

  if ( *(_DWORD *)a1 != -1 && *(_DWORD *)a1 != HIDWORD(a1) )
  {
    v1 = *(_DWORD *)a1 + 1;
    v2 = gettext("incompatible join fields %lu, %lu");
    error(1, 0, v2, v1, HIDWORD(a1) + 1);
  }
  result = a1;
  *(_DWORD *)a1 = HIDWORD(a1);
  return result;
}

//----- (0804DE55) --------------------------------------------------------
_DWORD *__cdecl sub_804DE55(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7)
{
  void *v7; // eax
  int v8; // eax
  bool v9; // zf
  bool v10; // sf
  unsigned __int8 v11; // of
  void *v12; // eax
  void *v13; // eax
  __int64 v14; // ST08_8
  _DWORD *result; // eax
  int v16; // [esp+0h] [ebp-28h]
  bool v17; // [esp+17h] [ebp-11h]
  char *nptr; // [esp+1Ch] [ebp-Ch]

  v7 = &loc_804DE83;
  if ( *a5 != 2 )
    v7 = &loc_804DFE7;
  dword_8059204 = (int)v7;
  sub_80530AA(v16);
  v17 = *a3 == 0;
  nptr = (char *)a2[v17];
  v8 = a3[v17];
  if ( v8 == 1 )
  {
    --*a4;
    HIDWORD(v14) = sub_804DB62(nptr);
    LODWORD(v14) = &dword_8059244;
    sub_804DDD9(v14);
  }
  else
  {
    v11 = __OFSUB__(v8, 1);
    v9 = v8 == 1;
    v10 = v8 - 1 < 0;
    v12 = &loc_804DEDE;
    if ( !((unsigned __int8)(v10 ^ v11) | v9) )
      v12 = &loc_804DF00;
    dword_805913C = (int)v12;
    v9 = sub_805355B() == 0;
    v13 = &loc_804DEFB;
    if ( v9 )
      v13 = &loc_804DF17;
    dword_8059114 = (int)v13;
    sub_8053637();
  }
  if ( v17 != 1 )
  {
    *a3 = a3[1];
    *a2 = a2[1];
  }
  a3[1] = *a6;
  a2[1] = a1;
  *a5 = 2;
  result = (_DWORD *)*a6;
  if ( *a6 == 3 )
  {
    result = a7;
    *a7 = 3;
  }
  return result;
}
// 80530AA: using guessed type int __stdcall sub_80530AA(_DWORD);
// 805355B: using guessed type int sub_805355B(void);
// 8053637: using guessed type int sub_8053637(void);
// 8059114: using guessed type int dword_8059114;
// 805913C: using guessed type int dword_805913C;
// 8059204: using guessed type int dword_8059204;
// 8059244: using guessed type int dword_8059244;

//----- (0804E035) --------------------------------------------------------
void __cdecl __noreturn main(int argc, char **argv)
{
  bool v2; // zf
  void *v3; // eax
  void *v4; // eax
  void *v5; // eax
  char *v6; // eax
  void *v7; // ebx
  char *v8; // eax
  int v9; // [esp+0h] [ebp-64h]
  int v10; // [esp+4h] [ebp-60h]
  int v11; // [esp+8h] [ebp-5Ch]
  int v12; // [esp+Ch] [ebp-58h]
  int v13; // [esp+10h] [ebp-54h]
  int v14; // [esp+14h] [ebp-50h]
  int v15; // [esp+18h] [ebp-4Ch]
  int v16; // [esp+1Ch] [ebp-48h]
  int v17; // [esp+20h] [ebp-44h]
  int v18; // [esp+24h] [ebp-40h]
  int v19; // [esp+28h] [ebp-3Ch]
  int v20; // [esp+2Ch] [ebp-38h]
  int v21; // [esp+30h] [ebp-34h]
  int v22; // [esp+38h] [ebp-2Ch]

  sub_804EFF3(*argv);
  setlocale(6, &s);
  bindtextdomain("coreutils", "/home/hwangdz/coreutils/coreutils-8.28/install_m32/share/locale");
  textdomain("coreutils");
  byte_8059875 = sub_804ED4D(3);
  sub_8052F0D((int)sub_804EA99);
  sub_8052F0D((int)sub_804B253);
  byte_8059878 = 1;
  byte_8059879 = 0;
  byte_805987B = 0;
  byte_805987A[0] = 0;
  dword_8059899 = 0;
  v2 = getopt_long(argc, argv, "-a:e:i1:2:j:o:t:v:z", &longopts, 0) == -1;
  v3 = &loc_804E664;
  if ( !v2 )
    v3 = &loc_804E0F9;
  dword_805913C = (int)v3;
  sub_805355B();
  v4 = &loc_804E6E5;
  if ( optind < argc )
    v4 = &loc_804E66E;
  dword_8059150 = (int)v4;
  sub_80534D6(v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, 0, 0);
  v5 = &loc_804E707;
  if ( v22 == 2 )
    v5 = &unk_804E789;
  dword_8059114 = (int)v5;
  sub_8053637();
  if ( v22 )
  {
    v7 = sub_8050CF6((int)argv[argc + 0x3FFFFFFF]);
    v8 = gettext("missing operand after %s");
    error(0, 0, v8, v7);
  }
  else
  {
    v6 = gettext("missing operand");
    error(0, 0, v6);
  }
  sub_804A894(1);
}
// 80534D6: using guessed type int __stdcall sub_80534D6(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 805355B: using guessed type int sub_805355B(void);
// 8053637: using guessed type int sub_8053637(void);
// 8059114: using guessed type int dword_8059114;
// 805913C: using guessed type int dword_805913C;
// 8059150: using guessed type int dword_8059150;
// 8059300: using guessed type int optind;
// 8059875: using guessed type char byte_8059875;
// 8059878: using guessed type char byte_8059878;
// 8059879: using guessed type char byte_8059879;
// 805987B: using guessed type char byte_805987B;
// 8059899: using guessed type int dword_8059899;

//----- (0804EA99) --------------------------------------------------------
void __noreturn sub_804EA99()
{
  void *v0; // ebx
  int *v1; // eax
  int *v2; // eax
  bool v3; // zf
  int (*v4)(); // eax
  int v5; // [esp+0h] [ebp-38h]
  char *v6; // [esp+2Ch] [ebp-Ch]

  if ( sub_80522FF(stdout) && (byte_80598BD != 1 || *__errno_location() != 32) )
  {
    v6 = gettext("write error");
    if ( dword_80598B9 )
    {
      v0 = sub_8050A41(dword_80598B9);
      v1 = __errno_location();
      error(0, *v1, "%s: %s", v0, v6);
    }
    else
    {
      v2 = __errno_location();
      error(0, *v2, "%s", v6);
    }
    _exit(status);
  }
  v3 = sub_80522FF(stderr) == 0;
  v4 = (int (*)())&loc_804EB83;
  if ( v3 )
    v4 = sub_804EB90;
  dword_8059204 = (int)v4;
  sub_80530AA(v5);
  _exit(status);
}
// 804EB90: using guessed type int sub_804EB90();
// 80530AA: using guessed type int __stdcall sub_80530AA(_DWORD);
// 8059204: using guessed type int dword_8059204;
// 80598B9: using guessed type int dword_80598B9;
// 80598BD: using guessed type char byte_80598BD;

//----- (0804EB90) --------------------------------------------------------
#error "804EB93: positive sp value has been found (funcsize=0)"

//----- (0804EB96) --------------------------------------------------------
int __cdecl sub_804EB96(int a1, int a2, int a3, int a4, int a5, int a6)
{
  return posix_fadvise64(a1, a2, a3, a4, a5, a6);
}
// 80490B0: using guessed type int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804EBE7) --------------------------------------------------------
int __cdecl sub_804EBE7(FILE *stream, int a2)
{
  void *v2; // eax
  int v3; // eax

  v2 = &loc_804EC0C;
  if ( !stream )
    v2 = &locret_804EC46;
  dword_805918C = (int)v2;
  sub_8053386();
  v3 = fileno(stream);
  return sub_804EB96(v3, 0, 0, 0, 0, a2);
}
// 8053386: using guessed type int sub_8053386(void);
// 805918C: using guessed type int dword_805918C;

//----- (0804EC48) --------------------------------------------------------
#error "804ECE6: call analysis failed (funcsize=73)"

//----- (0804ED4D) --------------------------------------------------------
int __cdecl sub_804ED4D(int category)
{
  unsigned __int8 v2; // [esp+1Bh] [ebp-Dh]
  const char *s1; // [esp+1Ch] [ebp-Ch]

  v2 = 1;
  s1 = setlocale(category, 0);
  if ( s1 && (!strcmp(s1, "C") || !strcmp(s1, "POSIX")) )
    v2 = 0;
  return v2;
}

//----- (0804EE00) --------------------------------------------------------
int __cdecl sub_804EE00(int a1, FILE *stream)
{
  int v2; // ST2C_4
  int v3; // ST30_4
  bool v4; // zf
  void *v5; // eax

  v2 = *(_DWORD *)(a1 + 8);
  v3 = *(_DWORD *)a1 + *(_DWORD *)(a1 + 8);
  v4 = feof_unlocked(stream) == 0;
  v5 = &loc_804EE53;
  if ( v4 )
    v5 = &loc_804EE5D;
  dword_805918C = (int)v5;
  sub_8053386();
  return 0;
}
// 8053386: using guessed type int sub_8053386(void);
// 805918C: using guessed type int dword_805918C;

//----- (0804EF73) --------------------------------------------------------
int __cdecl sub_804EF73(int a1, int a2, unsigned int a3)
{
  unsigned __int8 v3; // ST17_1
  unsigned int i; // [esp+18h] [ebp-20h]
  int v6; // [esp+24h] [ebp-14h]
  int v7; // [esp+28h] [ebp-10h]

  for ( i = 0; i < a3; ++i )
  {
    v3 = *(_BYTE *)(a2 + i);
    v6 = toupper(*(unsigned __int8 *)(a1 + i));
    v7 = toupper(v3);
    if ( v6 != v7 )
      return v6 - v7;
  }
  return 0;
}

//----- (0804EFF3) --------------------------------------------------------
char *__cdecl sub_804EFF3(char *s)
{
  char *v1; // eax
  char *result; // eax
  char *v3; // [esp+18h] [ebp-10h]
  char *s1; // [esp+1Ch] [ebp-Ch]

  if ( !s )
  {
    fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
    abort();
  }
  v3 = strrchr(s, 47);
  if ( v3 )
    v1 = v3 + 1;
  else
    v1 = s;
  s1 = v1;
  if ( v1 - s > 6 && !strncmp(v1 - 7, "/.libs/", 7u) )
  {
    s = s1;
    if ( !strncmp(s1, "lt-", 3u) )
    {
      s = s1 + 3;
      program_invocation_short_name = (int)(s1 + 3);
    }
  }
  dword_80598C1 = (int)s;
  result = s;
  program_invocation_name = (int)s;
  return result;
}
// 80592E0: using guessed type int program_invocation_short_name;
// 80592F0: using guessed type int program_invocation_name;
// 80598C1: using guessed type int dword_80598C1;

//----- (0804F14F) --------------------------------------------------------
int __cdecl sub_804F14F(int *a1, unsigned __int8 a2, char a3)
{
  int *v3; // eax
  int v4; // ST10_4

  if ( a1 )
    v3 = a1;
  else
    v3 = &dword_80598DD;
  v4 = ((unsigned int)v3[(a2 >> 5) + 2] >> (a2 & 0x1F)) & 1;
  v3[(a2 >> 5) + 2] ^= (v4 ^ a3 & 1) << (a2 & 0x1F);
  return v4;
}
// 80598DD: using guessed type int dword_80598DD;

//----- (0804F1F9) --------------------------------------------------------
int *__cdecl sub_804F1F9(int *a1, int a2, int a3)
{
  int *result; // eax

  if ( !a1 )
    a1 = &dword_80598DD;
  *a1 = 10;
  if ( !a2 || !a3 )
    abort();
  a1[10] = a2;
  result = a1;
  a1[11] = a3;
  return result;
}
// 80598DD: using guessed type int dword_80598DD;

//----- (0804F24C) --------------------------------------------------------
_DWORD *__userpurge sub_804F24C@<eax>(_DWORD *a1, int a2)
{
  int v3; // [esp+0h] [ebp-38h]
  int v4; // [esp+4h] [ebp-34h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]

  memset(&v3, 0, 0x30u);
  if ( a2 == 10 )
    abort();
  *a1 = a2;
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = v6;
  a1[4] = v7;
  a1[5] = v8;
  a1[6] = v9;
  a1[7] = v10;
  a1[8] = v11;
  a1[9] = v12;
  a1[10] = v13;
  a1[11] = v14;
  return a1;
}

//----- (0804F2CE) --------------------------------------------------------
const char *__cdecl sub_804F2CE(char *msgid, int a2)
{
  const char *result; // eax
  char *v3; // [esp+18h] [ebp-10h]
  unsigned __int8 *v4; // [esp+1Ch] [ebp-Ch]

  v3 = gettext(msgid);
  if ( v3 != msgid )
    return v3;
  v4 = (unsigned __int8 *)sub_80528B4();
  if ( sub_8052288(v4, "UTF-8") )
  {
    if ( sub_8052288(v4, "GB18030") )
    {
      if ( a2 == 9 )
        result = (const char *)&unk_80545F5;
      else
        result = "'";
    }
    else if ( *msgid == 96 )
    {
      result = (const char *)&unk_80545EE;
    }
    else
    {
      result = (const char *)&unk_80545F2;
    }
  }
  else if ( *msgid == 96 )
  {
    result = (const char *)&unk_80545DE;
  }
  else
  {
    result = (const char *)&unk_80545E2;
  }
  return result;
}

//----- (0804F37E) --------------------------------------------------------
unsigned int __cdecl sub_804F37E(int a1, unsigned int a2, int a3, size_t a4, signed int a5, int a6, int a7, char *a8, char *a9)
{
  void *v9; // eax
  void *v10; // eax
  size_t v11; // ebx
  int v12; // ST08_4
  void *v13; // eax
  void *v14; // eax
  char v15; // al
  bool v16; // zf
  bool v17; // sf
  unsigned __int8 v18; // of
  void *v19; // eax
  char v20; // al
  void *v21; // eax
  void *v22; // eax
  void *v23; // eax
  void *v24; // eax
  void *v25; // eax
  bool v26; // al
  void *v27; // eax
  void *v28; // eax
  void *v29; // eax
  bool v30; // ST52_1
  size_t v31; // eax
  void *v32; // eax
  void *v33; // eax
  int v34; // ST08_4
  void *v35; // eax
  void *v36; // eax
  void *v37; // eax
  void *v38; // eax
  void *v39; // eax
  void *v40; // eax
  int v41; // ST08_4
  int v42; // ST0C_4
  int v43; // ST10_4
  int v44; // ST14_4
  int v45; // ST18_4
  int v46; // ST1C_4
  int v47; // ST20_4
  int v48; // ST24_4
  int v49; // ST28_4
  void *v50; // eax
  unsigned int result; // eax
  int v52; // [esp+0h] [ebp-88h]
  int v53; // [esp+0h] [ebp-88h]
  int v54; // [esp+0h] [ebp-88h]
  int v55; // [esp+0h] [ebp-88h]
  int v56; // [esp+4h] [ebp-84h]
  int v57; // [esp+4h] [ebp-84h]
  int v58; // [esp+8h] [ebp-80h]
  int v59; // [esp+8h] [ebp-80h]
  int v60; // [esp+Ch] [ebp-7Ch]
  int v61; // [esp+Ch] [ebp-7Ch]
  int v62; // [esp+10h] [ebp-78h]
  int v63; // [esp+10h] [ebp-78h]
  int v64; // [esp+14h] [ebp-74h]
  int v65; // [esp+14h] [ebp-74h]
  int v66; // [esp+18h] [ebp-70h]
  int v67; // [esp+18h] [ebp-70h]
  int v68; // [esp+1Ch] [ebp-6Ch]
  int v69; // [esp+1Ch] [ebp-6Ch]
  int v70; // [esp+20h] [ebp-68h]
  int v71; // [esp+20h] [ebp-68h]
  int v72; // [esp+24h] [ebp-64h]
  int v73; // [esp+24h] [ebp-64h]
  int v74; // [esp+28h] [ebp-60h]
  int v75; // [esp+28h] [ebp-60h]
  char *v76; // [esp+2Ch] [ebp-5Ch]
  char *v77; // [esp+2Ch] [ebp-5Ch]
  char *v78; // [esp+30h] [ebp-58h]
  char *v79; // [esp+30h] [ebp-58h]
  int v80; // [esp+34h] [ebp-54h]
  int v81; // [esp+34h] [ebp-54h]
  char *v82; // [esp+38h] [ebp-50h]
  char *v83; // [esp+38h] [ebp-50h]
  int v84; // [esp+3Ch] [ebp-4Ch]
  int v85; // [esp+40h] [ebp-48h]
  char v86; // [esp+44h] [ebp-44h]
  unsigned __int8 v87; // [esp+45h] [ebp-43h]
  char v88; // [esp+46h] [ebp-42h]
  char v89; // [esp+48h] [ebp-40h]
  char v90; // [esp+49h] [ebp-3Fh]
  bool v91; // [esp+4Bh] [ebp-3Dh]
  wint_t wc; // [esp+4Ch] [ebp-3Ch]
  int v93; // [esp+50h] [ebp-38h]
  unsigned int v94; // [esp+54h] [ebp-34h]
  unsigned int v95; // [esp+58h] [ebp-30h]
  char *s; // [esp+5Ch] [ebp-2Ch]
  size_t n; // [esp+60h] [ebp-28h]
  unsigned int v98; // [esp+64h] [ebp-24h]
  size_t v99; // [esp+6Ch] [ebp-1Ch]
  unsigned int v100; // [esp+70h] [ebp-18h]
  mbstate_t ps; // [esp+74h] [ebp-14h]
  unsigned int v102; // [esp+7Ch] [ebp-Ch]

  v84 = a1;
  v82 = (char *)a3;
  v80 = a7;
  v78 = a8;
  v76 = a9;
  v102 = __readgsdword(0x14u);
  v94 = 0;
  v95 = 0;
  s = 0;
  n = 0;
  LOBYTE(v85) = 0;
  v91 = __ctype_get_mb_cur_max() == 1;
  BYTE1(v85) = (a6 & 2) != 0;
  HIWORD(v85) = 0;
  v86 = 1;
LABEL_2:
  switch ( a5 )
  {
    case 0:
      BYTE1(v85) = 0;
      goto LABEL_28;
    case 1:
      goto LABEL_18;
    case 2:
      goto LABEL_21;
    case 3:
      goto LABEL_17;
    case 4:
      goto LABEL_19;
    case 5:
      goto LABEL_4;
    case 6:
      a5 = 5;
      BYTE1(v85) = 1;
LABEL_4:
      if ( BYTE1(v85) != 1 )
      {
        if ( v94 < a2 )
          *(_BYTE *)(v84 + v94) = 34;
        ++v94;
      }
      s = (char *)&unk_80545F5;
      n = 1;
      dword_80591B4 = (int)&loc_804F598;
      sub_8053287();
      goto LABEL_9;
    case 7:
LABEL_9:
      BYTE1(v85) = 0;
      dword_80591F0 = (int)&loc_804F598;
      sub_805311E(v52, v56, v58, v60, v62, v64, v66, v68, v70, v72, v74, v76, v78, v80, v82);
      break;
    case 8:
    case 9:
    case 10:
      break;
    default:
      abort();
      return result;
  }
  v9 = &loc_804F494;
  if ( a5 == 10 )
    v9 = &loc_804F4C0;
  dword_8059164 = (int)v9;
  sub_8053468();
  v78 = (char *)sub_804F2CE("`", a5);
  v76 = (char *)sub_804F2CE("'", a5);
  if ( BYTE1(v85) != 1 )
  {
    s = v78;
    v10 = &loc_804F516;
    if ( *v78 )
      v10 = &loc_804F4D3;
    dword_8059204 = (int)v10;
    sub_80530AA(v53);
  }
  s = v76;
  n = strlen(v76);
  dword_8059178 = (int)&loc_804F598;
  sub_80533F8();
LABEL_17:
  LOBYTE(v85) = 1;
LABEL_18:
  BYTE1(v85) = 1;
LABEL_19:
  if ( BYTE1(v85) != 1 )
    LOBYTE(v85) = 1;
LABEL_21:
  a5 = 2;
  if ( BYTE1(v85) != 1 )
  {
    if ( v94 < a2 )
      *(_BYTE *)(v84 + v94) = 39;
    ++v94;
  }
  s = "'";
  n = 1;
LABEL_28:
  v93 = 0;
  dword_80591DC = (int)&loc_80500F4;
  sub_8053190(v52, v56, v58, v60, v62, v64, v66, v68, v70, v72, v74, v76, v78, v80, v82, v84, v85);
  while ( 2 )
  {
    v89 = 0;
    v90 = 0;
    if ( (_BYTE)v85 && a5 != 2 && n )
    {
      v11 = v93 + n;
      if ( a4 == -1 && n > 1 )
      {
        a4 = strlen(v83);
        dword_80591F0 = (int)&loc_804F610;
        sub_805311E(v12, v57, v59, v61, v63, v65, v67, v69, v71, v73, v75, v77, v79, v81, v83);
      }
      if ( v11 <= a4 && !memcmp(&v83[v93], s, n) )
      {
        v13 = &loc_804F655;
        if ( !BYTE1(v85) )
          v13 = &loc_804F65A;
        dword_8059164 = (int)v13;
        sub_8053468();
LABEL_205:
        if ( a5 == 2 )
        {
          if ( (_BYTE)v85 )
            a5 = 4;
        }
        return sub_804F37E(v84, a2, (int)v83, a4, a5, a6 & 0xFFFFFFFD, 0, v79, v77);
      }
    }
    v87 = v83[v93];
    switch ( v87 )
    {
      case 0u:
        v14 = &loc_804F6A1;
        if ( !(_BYTE)v85 )
          v14 = &loc_804F7C4;
        dword_8059114 = (int)v14;
        sub_8053637();
        if ( BYTE1(v85) )
          goto LABEL_205;
        v89 = 1;
        if ( a5 == 2 && BYTE2(v85) != 1 )
        {
          if ( v94 < a2 )
            *(_BYTE *)(v84 + v94) = 39;
          if ( ++v94 < a2 )
            *(_BYTE *)(v84 + v94) = 36;
          if ( ++v94 < a2 )
            *(_BYTE *)(v84 + v94) = 39;
          ++v94;
          BYTE2(v85) = 1;
        }
        if ( v94 < a2 )
          *(_BYTE *)(v84 + v94) = 92;
        ++v94;
        if ( a5 != 2 && v93 + 1 < a4 )
        {
          v15 = v83[v93 + 1];
          v18 = __OFSUB__(v15, 47);
          v16 = v15 == 47;
          v17 = (char)(v15 - 47) < 0;
          v19 = &loc_804F765;
          if ( (unsigned __int8)(v17 ^ v18) | v16 )
            v19 = &loc_804F7BE;
          dword_80591A0 = (int)v19;
          sub_8053314();
          v20 = v83[v93 + 1];
          v18 = __OFSUB__(v20, 57);
          v16 = v20 == 57;
          v17 = (char)(v20 - 57) < 0;
          v21 = &loc_804F790;
          if ( !((unsigned __int8)(v17 ^ v18) | v16) )
            v21 = &loc_804F7BE;
          dword_805918C = (int)v21;
          sub_8053386();
          if ( v94 < a2 )
            *(_BYTE *)(v84 + v94) = 48;
          if ( ++v94 < a2 )
            *(_BYTE *)(v84 + v94) = 48;
          ++v94;
        }
        v87 = 48;
        goto LABEL_143;
      case 7u:
        dword_8059164 = (int)&loc_804F9DC;
        sub_8053468();
        goto LABEL_75;
      case 8u:
LABEL_75:
        v88 = 98;
        goto LABEL_92;
      case 9u:
        dword_80591A0 = (int)&loc_804F9CB;
        sub_8053314();
        goto LABEL_80;
      case 0xAu:
        v88 = 110;
        goto LABEL_90;
      case 0xBu:
LABEL_80:
        v88 = 118;
        goto LABEL_92;
      case 0xCu:
        v88 = 102;
        goto LABEL_92;
      case 0xDu:
        v88 = 114;
        goto LABEL_90;
      case 0x20u:
        v90 = 1;
        goto LABEL_103;
      case 0x21u:
      case 0x22u:
      case 0x24u:
      case 0x26u:
      case 0x28u:
      case 0x29u:
      case 0x2Au:
      case 0x3Bu:
      case 0x3Cu:
      case 0x3Du:
      case 0x3Eu:
      case 0x5Bu:
      case 0x5Eu:
      case 0x60u:
      case 0x7Cu:
LABEL_103:
        if ( a5 != 2 )
          goto LABEL_143;
        v28 = &loc_804FA66;
        if ( !BYTE1(v85) )
          v28 = &loc_804FA6B;
        dword_8059114 = (int)v28;
        sub_8053637();
        goto LABEL_205;
      case 0x23u:
      case 0x7Eu:
        goto LABEL_99;
      case 0x25u:
      case 0x2Bu:
      case 0x2Cu:
      case 0x2Du:
      case 0x2Eu:
      case 0x2Fu:
      case 0x30u:
      case 0x31u:
      case 0x32u:
      case 0x33u:
      case 0x34u:
      case 0x35u:
      case 0x36u:
      case 0x37u:
      case 0x38u:
      case 0x39u:
      case 0x3Au:
      case 0x41u:
      case 0x42u:
      case 0x43u:
      case 0x44u:
      case 0x45u:
      case 0x46u:
      case 0x47u:
      case 0x48u:
      case 0x49u:
      case 0x4Au:
      case 0x4Bu:
      case 0x4Cu:
      case 0x4Du:
      case 0x4Eu:
      case 0x4Fu:
      case 0x50u:
      case 0x51u:
      case 0x52u:
      case 0x53u:
      case 0x54u:
      case 0x55u:
      case 0x56u:
      case 0x57u:
      case 0x58u:
      case 0x59u:
      case 0x5Au:
      case 0x5Du:
      case 0x5Fu:
      case 0x61u:
      case 0x62u:
      case 0x63u:
      case 0x64u:
      case 0x65u:
      case 0x66u:
      case 0x67u:
      case 0x68u:
      case 0x69u:
      case 0x6Au:
      case 0x6Bu:
      case 0x6Cu:
      case 0x6Du:
      case 0x6Eu:
      case 0x6Fu:
      case 0x70u:
      case 0x71u:
      case 0x72u:
      case 0x73u:
      case 0x74u:
      case 0x75u:
      case 0x76u:
      case 0x77u:
      case 0x78u:
      case 0x79u:
      case 0x7Au:
        v90 = 1;
        goto LABEL_143;
      case 0x27u:
        HIBYTE(v85) = 1;
        v90 = 1;
        if ( a5 != 2 )
          goto LABEL_143;
        v29 = &loc_804FAA1;
        if ( !BYTE1(v85) )
          v29 = &loc_804FAA6;
        dword_8059114 = (int)v29;
        sub_8053637();
        goto LABEL_205;
      case 0x3Fu:
        if ( a5 == 2 )
        {
          v23 = &loc_804F822;
          if ( !BYTE1(v85) )
            v23 = &loc_804F827;
          dword_80591C8 = (int)v23;
          sub_8053217(v54, v57, v59, v61, v63, v65, v67, v69, v71, v73, v75, v77, v79, v81, v83, v84, v85);
          goto LABEL_205;
        }
        v22 = &loc_804F7FE;
        if ( a5 == 5 )
          v22 = &loc_804F82C;
        dword_805918C = (int)v22;
        sub_8053386();
LABEL_143:
        if ( (_BYTE)v85 != 1 || a5 == 2 )
        {
          v35 = &loc_804FF6D;
          if ( BYTE1(v85) != 1 )
            v35 = &loc_804FFD1;
          dword_8059114 = (int)v35;
          sub_8053637();
        }
        v36 = &loc_804FF8C;
        if ( !v81 )
          v36 = &loc_804FFD1;
        dword_8059114 = (int)v36;
        sub_8053637();
        v37 = &loc_804FFD1;
        if ( (*(_DWORD *)(4 * (v87 >> 5) + v81) >> (v87 & 0x1F)) & 1 )
          v37 = &loc_804FFFA;
        dword_8059164 = (int)v37;
        sub_8053468();
        dword_80591A0 = (int)&loc_804FFF5;
        sub_8053314();
LABEL_167:
        if ( BYTE2(v85) && v89 != 1 )
        {
          if ( v94 < a2 )
            *(_BYTE *)(v84 + v94) = 39;
          if ( ++v94 < a2 )
            *(_BYTE *)(v84 + v94) = 39;
          ++v94;
          BYTE2(v85) = 0;
        }
        if ( v94 < a2 )
          *(_BYTE *)(v94 + v84) = v87;
        ++v94;
        if ( v90 != 1 )
          v86 = 0;
        ++v93;
        v38 = &loc_8050113;
        if ( a4 != -1 )
          v38 = &loc_8050125;
        dword_8059204 = (int)v38;
        sub_80530AA(v54);
        if ( v83[v93] )
          continue;
        v39 = &loc_8050155;
        if ( v94 )
          v39 = &loc_8050166;
        dword_8059204 = (int)v39;
        sub_80530AA(v54);
        if ( a5 == 2 && BYTE1(v85) )
          goto LABEL_205;
        v40 = &loc_8050185;
        if ( a5 != 2 )
          v40 = &loc_805022E;
        dword_8059178 = (int)v40;
        sub_80533F8();
        if ( BYTE1(v85) != 1 && HIBYTE(v85) )
        {
          if ( v86 )
          {
            sub_804F37E(v84, v95, (int)v83, a4, 5, a6, v81, v79, v77);
            dword_80591F0 = (int)&loc_80502DF;
            sub_805311E(v41, v42, v43, v44, v45, v46, v47, v48, v49, v73, v75, v77, v79, v81, v83);
          }
          v50 = &loc_8050216;
          if ( a2 )
            v50 = &loc_805022E;
          dword_80591DC = (int)v50;
          sub_8053190(v55, v57, v59, v61, v63, v65, v67, v69, v71, v73, v75, v77, v79, v81, v83, v84, v85);
          if ( v95 )
          {
            a2 = v95;
            v94 = 0;
            goto LABEL_2;
          }
        }
        if ( s && BYTE1(v85) != 1 )
        {
          while ( *s )
          {
            if ( v94 < a2 )
              *(_BYTE *)(v94 + v84) = *s;
            ++v94;
            ++s;
          }
        }
        if ( v94 < a2 )
          *(_BYTE *)(v84 + v94) = 0;
        return v94;
      case 0x5Cu:
        v88 = v83[v93];
        if ( a5 == 2 )
        {
          v24 = &loc_804F987;
          if ( !BYTE1(v85) )
            v24 = &loc_804F98C;
          dword_80591A0 = (int)v24;
          sub_8053314();
          goto LABEL_205;
        }
        if ( (_BYTE)v85 && BYTE1(v85) )
        {
          v25 = &loc_804F9C6;
          if ( !n )
            v25 = &loc_804F9CB;
          dword_805918C = (int)v25;
          sub_8053386();
          goto LABEL_167;
        }
LABEL_90:
        if ( a5 == 2 && BYTE1(v85) )
          goto LABEL_205;
LABEL_92:
        if ( (_BYTE)v85 )
        {
          v87 = v88;
          if ( BYTE1(v85) )
          {
            dword_8059150 = (int)&loc_8050283;
            sub_80534D6(v54, v57, v59, v61, v63, v65, v67, v69, v71, v73, v75, v77, v79, v81, v83);
          }
          v89 = 1;
          if ( a5 == 2 && BYTE2(v85) != 1 )
          {
            if ( v94 < a2 )
              *(_BYTE *)(v84 + v94) = 39;
            if ( ++v94 < a2 )
              *(_BYTE *)(v84 + v94) = 36;
            if ( ++v94 < a2 )
              *(_BYTE *)(v84 + v94) = 39;
            ++v94;
            BYTE2(v85) = 1;
          }
          if ( v94 < a2 )
            *(_BYTE *)(v84 + v94) = 92;
          ++v94;
          goto LABEL_167;
        }
        goto LABEL_143;
      case 0x7Bu:
      case 0x7Du:
        if ( a4 == -1 )
          v26 = v83[1] != 0;
        else
          v26 = a4 != 1;
        if ( !v26 )
        {
LABEL_99:
          v27 = &loc_804FA38;
          if ( !v93 )
            v27 = &loc_804FA3D;
          dword_8059128 = (int)v27;
          sub_80535C9(v54, v57, v59, v61, v63, v65, v67, v69, v71, v73, v75, v77, v79, v81, v83, v84);
        }
        goto LABEL_143;
      default:
        if ( v91 )
        {
          v98 = 1;
          v30 = ((*__ctype_b_loc())[v87] & 0x4000) != 0;
          dword_805918C = (int)&loc_804FD2A;
          sub_8053386();
        }
        memset(&ps, 0, 8u);
        v98 = 0;
        if ( a4 == -1 )
          a4 = strlen(v83);
        v31 = sub_80521F0((wchar_t *)&wc, &v83[v98 + v93], a4 - (v98 + v93), &ps);
        v99 = v31;
        v16 = v31 == 0;
        v32 = &loc_804FC04;
        if ( !v16 )
          v32 = &loc_804FC09;
        dword_805918C = (int)v32;
        sub_8053386();
        v90 = 1;
        if ( v98 <= 1 )
          goto LABEL_143;
        v100 = v93 + v98;
        v33 = &loc_804FD7A;
        if ( !(_BYTE)v85 )
          v33 = &loc_804FE70;
        dword_8059204 = (int)v33;
        sub_80530AA(v54);
        dword_8059128 = (int)&loc_804FE70;
        sub_80535C9(v34, v57, v59, v61, v63, v65, v67, v69, v71, v73, v75, v77, v79, v81, v83, v84);
        if ( BYTE1(v85) )
          goto LABEL_205;
        v89 = 1;
        if ( a5 == 2 && BYTE2(v85) != 1 )
        {
          if ( v94 < a2 )
            *(_BYTE *)(v84 + v94) = 39;
          if ( ++v94 < a2 )
            *(_BYTE *)(v84 + v94) = 36;
          if ( ++v94 < a2 )
            *(_BYTE *)(v84 + v94) = 39;
          ++v94;
          BYTE2(v85) = 1;
        }
        if ( v94 < a2 )
          *(_BYTE *)(v84 + v94) = 92;
        if ( ++v94 < a2 )
          *(_BYTE *)(v94 + v84) = (v87 >> 6) + 48;
        if ( ++v94 < a2 )
          *(_BYTE *)(v94 + v84) = ((v87 >> 3) & 7) + 48;
        ++v94;
        v87 = (v87 & 7) + 48;
        if ( v93 + 1 >= v100 )
          goto LABEL_167;
        if ( v94 < a2 )
          *(_BYTE *)(v94 + v84) = v87;
        ++v94;
        v87 = v83[++v93];
        dword_805913C = (int)&loc_804FD5B;
        sub_805355B();
        goto LABEL_143;
    }
  }
}
// 80530AA: using guessed type int __stdcall sub_80530AA(_DWORD);
// 805311E: using guessed type int __stdcall sub_805311E(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8053190: using guessed type int __stdcall sub_8053190(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8053217: using guessed type int __stdcall sub_8053217(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8053287: using guessed type int sub_8053287(void);
// 8053314: using guessed type int sub_8053314(void);
// 8053386: using guessed type int sub_8053386(void);
// 80533F8: using guessed type int sub_80533F8(void);
// 8053468: using guessed type int sub_8053468(void);
// 80534D6: using guessed type int __stdcall sub_80534D6(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 805355B: using guessed type int sub_805355B(void);
// 80535C9: using guessed type int __stdcall sub_80535C9(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8053637: using guessed type int sub_8053637(void);
// 8059114: using guessed type int dword_8059114;
// 8059128: using guessed type int dword_8059128;
// 805913C: using guessed type int dword_805913C;
// 8059150: using guessed type int dword_8059150;
// 8059164: using guessed type int dword_8059164;
// 8059178: using guessed type int dword_8059178;
// 805918C: using guessed type int dword_805918C;
// 80591A0: using guessed type int dword_80591A0;
// 80591B4: using guessed type int dword_80591B4;
// 80591C8: using guessed type int dword_80591C8;
// 80591DC: using guessed type int dword_80591DC;
// 80591F0: using guessed type int dword_80591F0;
// 8059204: using guessed type int dword_8059204;

//----- (080503BF) --------------------------------------------------------
void *__cdecl sub_80503BF(int a1, size_t a2, _DWORD *a3, int a4)
{
  void *v4; // eax
  int v5; // ST44_4
  int v6; // ST48_4
  int v7; // ST4C_4
  int v9; // [esp+0h] [ebp-58h]
  int v10; // [esp+4h] [ebp-54h]
  int v11; // [esp+8h] [ebp-50h]
  int v12; // [esp+Ch] [ebp-4Ch]
  int v13; // [esp+10h] [ebp-48h]
  int v14; // [esp+14h] [ebp-44h]
  int v15; // [esp+18h] [ebp-40h]
  int v16; // [esp+1Ch] [ebp-3Ch]
  int v17; // [esp+20h] [ebp-38h]
  int v18; // [esp+24h] [ebp-34h]
  int v19; // [esp+28h] [ebp-30h]
  int v20; // [esp+2Ch] [ebp-2Ch]
  int v21; // [esp+30h] [ebp-28h]
  int v22; // [esp+34h] [ebp-24h]
  int v23; // [esp+38h] [ebp-20h]
  int v24; // [esp+3Ch] [ebp-1Ch]
  int v25; // [esp+40h] [ebp-18h]
  unsigned int size; // [esp+48h] [ebp-10h]
  void *v27; // [esp+4Ch] [ebp-Ch]

  v4 = &loc_80503E5;
  if ( !a4 )
    v4 = &loc_80503EA;
  dword_80591C8 = (int)v4;
  sub_8053217(v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25);
  v5 = a4;
  v6 = *__errno_location();
  v7 = *(_DWORD *)(a4 + 4) | (a3 == 0);
  size = sub_804F37E(
           0,
           0,
           a1,
           a2,
           *(_DWORD *)v5,
           *(_DWORD *)(v5 + 4) | (a3 == 0),
           v5 + 8,
           *(char **)(v5 + 40),
           *(char **)(v5 + 44))
       + 1;
  v27 = sub_80514ED(size);
  sub_804F37E((int)v27, size, a1, a2, *(_DWORD *)v5, v7, v5 + 8, *(char **)(v5 + 40), *(char **)(v5 + 44));
  *__errno_location() = v6;
  if ( a3 )
    *a3 = size - 1;
  return v27;
}
// 8053217: using guessed type int __stdcall sub_8053217(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80591C8: using guessed type int dword_80591C8;

//----- (080505A4) --------------------------------------------------------
void *__cdecl sub_80505A4(signed int a1, int a2, size_t a3, int a4)
{
  int *v4; // eax
  int *v5; // eax
  void *v6; // eax
  void *v7; // edx
  size_t v8; // ST4C_4
  bool v10; // [esp+37h] [ebp-21h]
  int *v11; // [esp+38h] [ebp-20h]
  void *ptr; // [esp+3Ch] [ebp-1Ch]
  int v13; // [esp+40h] [ebp-18h]
  int size; // [esp+44h] [ebp-14h]
  int v15; // [esp+48h] [ebp-10h]
  unsigned int v16; // [esp+4Ch] [ebp-Ch]

  v13 = *__errno_location();
  v11 = off_8059288;
  if ( a1 < 0 )
    abort();
  if ( dword_805927C <= a1 )
  {
    v10 = off_8059288 == &dword_8059280;
    if ( (unsigned int)a1 > 0xFFFFFFE )
      sub_80516F1();
    if ( v10 )
      v4 = 0;
    else
      v4 = off_8059288;
    v5 = (int *)sub_8051561(v4, 8 * (a1 + 1));
    v11 = v5;
    off_8059288 = v5;
    v6 = &loc_8050645;
    if ( !v10 )
      v6 = &loc_8050658;
    dword_8059178 = (int)v6;
    sub_80533F8();
    v7 = off_8059284;
    *v11 = dword_8059280;
    v11[1] = (int)v7;
    memset(&v11[2 * dword_805927C], 0, 8 * (a1 + 1 - dword_805927C));
    dword_805927C = a1 + 1;
  }
  v8 = v11[2 * a1];
  ptr = (void *)v11[2 * a1 + 1];
  v15 = *(_DWORD *)(a4 + 4) | 1;
  v16 = sub_804F37E(
          v11[2 * a1 + 1],
          v11[2 * a1],
          a2,
          a3,
          *(_DWORD *)a4,
          v15,
          a4 + 8,
          *(char **)(a4 + 40),
          *(char **)(a4 + 44));
  if ( v8 <= v16 )
  {
    size = v16 + 1;
    v11[2 * a1] = v16 + 1;
    if ( ptr != &unk_805991D )
      free(ptr);
    ptr = sub_80514ED(size);
    v11[2 * a1 + 1] = (int)ptr;
    sub_804F37E((int)ptr, size, a2, a3, *(_DWORD *)a4, v15, a4 + 8, *(char **)(a4 + 40), *(char **)(a4 + 44));
  }
  *__errno_location() = v13;
  return ptr;
}
// 80533F8: using guessed type int sub_80533F8(void);
// 8059178: using guessed type int dword_8059178;
// 805927C: using guessed type int dword_805927C;
// 8059280: using guessed type int dword_8059280;
// 8059284: using guessed type void *off_8059284;
// 8059288: using guessed type int *off_8059288;

//----- (080507E6) --------------------------------------------------------
void *__cdecl sub_80507E6(signed int a1, int a2)
{
  return sub_80505A4(a1, a2, 0xFFFFFFFF, (int)&dword_80598DD);
}
// 80598DD: using guessed type int dword_80598DD;

//----- (08050810) --------------------------------------------------------
void *__cdecl sub_8050810(signed int a1, int a2, size_t a3)
{
  return sub_80505A4(a1, a2, a3, (int)&dword_80598DD);
}
// 80598DD: using guessed type int dword_80598DD;

//----- (08050884) --------------------------------------------------------
void *__cdecl sub_8050884(signed int a1, int a2, int a3)
{
  char v4; // [esp+10h] [ebp-38h]

  sub_804F24C(&v4, a2);
  return sub_80505A4(a1, a3, 0xFFFFFFFF, (int)&v4);
}

//----- (080508C2) --------------------------------------------------------
void *__cdecl sub_80508C2(signed int a1, int a2, int a3, size_t a4)
{
  int v5; // [esp+10h] [ebp-3Ch]

  sub_804F24C(&v5, a2);
  return sub_80505A4(a1, a3, a4, (int)&v5);
}

//----- (08050923) --------------------------------------------------------
void *__cdecl sub_8050923(int a1, int a2)
{
  return sub_8050884(0, a1, a2);
}

//----- (0805096E) --------------------------------------------------------
void *__cdecl sub_805096E(int a1, size_t a2, unsigned __int8 a3)
{
  int v4; // [esp+20h] [ebp-38h]
  int v5; // [esp+24h] [ebp-34h]
  int v6; // [esp+28h] [ebp-30h]
  int v7; // [esp+2Ch] [ebp-2Ch]
  int v8; // [esp+30h] [ebp-28h]
  int v9; // [esp+34h] [ebp-24h]
  int v10; // [esp+38h] [ebp-20h]
  int v11; // [esp+3Ch] [ebp-1Ch]
  int v12; // [esp+40h] [ebp-18h]
  int v13; // [esp+44h] [ebp-14h]
  int v14; // [esp+48h] [ebp-10h]
  int v15; // [esp+4Ch] [ebp-Ch]

  v4 = dword_80598DD;
  v5 = dword_80598E1;
  v6 = dword_80598E5;
  v7 = dword_80598E9;
  v8 = dword_80598ED;
  v9 = dword_80598F1;
  v10 = dword_80598F5;
  v11 = dword_80598F9;
  v12 = dword_80598FD;
  v13 = dword_8059901;
  v14 = dword_8059905;
  v15 = dword_8059909;
  sub_804F14F(&v4, a3, 1);
  return sub_80505A4(0, a1, a2, (int)&v4);
}
// 80598DD: using guessed type int dword_80598DD;
// 80598E1: using guessed type int dword_80598E1;
// 80598E5: using guessed type int dword_80598E5;
// 80598E9: using guessed type int dword_80598E9;
// 80598ED: using guessed type int dword_80598ED;
// 80598F1: using guessed type int dword_80598F1;
// 80598F5: using guessed type int dword_80598F5;
// 80598F9: using guessed type int dword_80598F9;
// 80598FD: using guessed type int dword_80598FD;
// 8059901: using guessed type int dword_8059901;
// 8059905: using guessed type int dword_8059905;
// 8059909: using guessed type int dword_8059909;

//----- (08050A18) --------------------------------------------------------
void *__cdecl sub_8050A18(int a1, unsigned __int8 a2)
{
  return sub_805096E(a1, 0xFFFFFFFF, a2);
}

//----- (08050A41) --------------------------------------------------------
void *__cdecl sub_8050A41(int a1)
{
  return sub_8050A18(a1, 0x3Au);
}

//----- (08050A8E) --------------------------------------------------------
void *__cdecl sub_8050A8E(signed int a1, int a2, int a3)
{
  int v4; // [esp+10h] [ebp-68h]
  int v5; // [esp+14h] [ebp-64h]
  int v6; // [esp+18h] [ebp-60h]
  int v7; // [esp+1Ch] [ebp-5Ch]
  int v8; // [esp+20h] [ebp-58h]
  int v9; // [esp+24h] [ebp-54h]
  int v10; // [esp+28h] [ebp-50h]
  int v11; // [esp+2Ch] [ebp-4Ch]
  int v12; // [esp+30h] [ebp-48h]
  int v13; // [esp+34h] [ebp-44h]
  int v14; // [esp+38h] [ebp-40h]
  int v15; // [esp+3Ch] [ebp-3Ch]
  int v16; // [esp+40h] [ebp-38h]
  int v17; // [esp+44h] [ebp-34h]
  int v18; // [esp+48h] [ebp-30h]
  int v19; // [esp+4Ch] [ebp-2Ch]
  int v20; // [esp+50h] [ebp-28h]
  int v21; // [esp+54h] [ebp-24h]
  int v22; // [esp+58h] [ebp-20h]
  int v23; // [esp+5Ch] [ebp-1Ch]
  int v24; // [esp+60h] [ebp-18h]
  int v25; // [esp+64h] [ebp-14h]
  int v26; // [esp+68h] [ebp-10h]
  int v27; // [esp+6Ch] [ebp-Ch]

  sub_804F24C(&v4, a2);
  v16 = v4;
  v17 = v5;
  v18 = v6;
  v19 = v7;
  v20 = v8;
  v21 = v9;
  v22 = v10;
  v23 = v11;
  v24 = v12;
  v25 = v13;
  v26 = v14;
  v27 = v15;
  sub_804F14F(&v16, 0x3Au, 1);
  return sub_80505A4(a1, a3, 0xFFFFFFFF, (int)&v16);
}

//----- (08050B41) --------------------------------------------------------
void *__cdecl sub_8050B41(signed int a1, int a2, int a3, int a4)
{
  return sub_8050B71(a1, a2, a3, a4, 0xFFFFFFFF);
}

//----- (08050B71) --------------------------------------------------------
void *__cdecl sub_8050B71(signed int a1, int a2, int a3, int a4, size_t a5)
{
  int v6; // [esp+10h] [ebp-38h]
  int v7; // [esp+14h] [ebp-34h]
  int v8; // [esp+18h] [ebp-30h]
  int v9; // [esp+1Ch] [ebp-2Ch]
  int v10; // [esp+20h] [ebp-28h]
  int v11; // [esp+24h] [ebp-24h]
  int v12; // [esp+28h] [ebp-20h]
  int v13; // [esp+2Ch] [ebp-1Ch]
  int v14; // [esp+30h] [ebp-18h]
  int v15; // [esp+34h] [ebp-14h]
  int v16; // [esp+38h] [ebp-10h]
  int v17; // [esp+3Ch] [ebp-Ch]

  v6 = dword_80598DD;
  v7 = dword_80598E1;
  v8 = dword_80598E5;
  v9 = dword_80598E9;
  v10 = dword_80598ED;
  v11 = dword_80598F1;
  v12 = dword_80598F5;
  v13 = dword_80598F9;
  v14 = dword_80598FD;
  v15 = dword_8059901;
  v16 = dword_8059905;
  v17 = dword_8059909;
  sub_804F1F9(&v6, a2, a3);
  return sub_80505A4(a1, a4, a5, (int)&v6);
}
// 80598DD: using guessed type int dword_80598DD;
// 80598E1: using guessed type int dword_80598E1;
// 80598E5: using guessed type int dword_80598E5;
// 80598E9: using guessed type int dword_80598E9;
// 80598ED: using guessed type int dword_80598ED;
// 80598F1: using guessed type int dword_80598F1;
// 80598F5: using guessed type int dword_80598F5;
// 80598F9: using guessed type int dword_80598F9;
// 80598FD: using guessed type int dword_80598FD;
// 8059901: using guessed type int dword_8059901;
// 8059905: using guessed type int dword_8059905;
// 8059909: using guessed type int dword_8059909;

//----- (08050C7B) --------------------------------------------------------
void *__cdecl sub_8050C7B(signed int a1, int a2, size_t a3)
{
  return sub_80505A4(a1, a2, a3, (int)&unk_805929C);
}

//----- (08050CC6) --------------------------------------------------------
void *__cdecl sub_8050CC6(signed int a1, int a2)
{
  return sub_8050C7B(a1, a2, 0xFFFFFFFF);
}

//----- (08050CF6) --------------------------------------------------------
void *__cdecl sub_8050CF6(int a1)
{
  return sub_8050CC6(0, a1);
}

//----- (08050D21) --------------------------------------------------------
int __cdecl sub_8050D21(int fd)
{
  return sub_8051EEE(fd, 0, 3);
}

//----- (08050D44) --------------------------------------------------------
int __cdecl sub_8050D44(FILE *stream, int a2, int a3, int a4, int a5, int a6)
{
  char *v6; // eax
  char *v7; // eax
  int v8; // ebx
  char *v9; // eax
  int result; // eax
  int v11; // esi
  int v12; // ebx
  char *v13; // eax
  int v14; // edi
  int v15; // esi
  int v16; // ebx
  char *v17; // eax
  int v18; // ST4C_4
  int v19; // edi
  int v20; // esi
  int v21; // ebx
  char *v22; // eax
  int v23; // ST00_4
  int v24; // ST04_4
  int v25; // ST4C_4
  int v26; // ST48_4
  int v27; // edi
  int v28; // esi
  int v29; // ebx
  char *v30; // eax
  int v31; // ST4C_4
  int v32; // ST48_4
  int v33; // ST44_4
  int v34; // edi
  int v35; // esi
  int v36; // ebx
  char *v37; // eax
  int v38; // esi
  int v39; // ST4C_4
  int v40; // ST48_4
  int v41; // ST44_4
  int v42; // ST40_4
  int v43; // edi
  int v44; // ebx
  char *v45; // eax
  int v46; // edi
  int v47; // ST4C_4
  int v48; // ST48_4
  int v49; // ST44_4
  int v50; // ST40_4
  int v51; // ST3C_4
  int v52; // esi
  int v53; // ebx
  char *v54; // eax
  int v55; // edi
  int v56; // ST4C_4
  int v57; // ST48_4
  int v58; // ST44_4
  int v59; // ST40_4
  int v60; // ST3C_4
  int v61; // ST38_4
  int v62; // esi
  int v63; // ebx
  char *v64; // eax
  int v65; // edi
  int v66; // ST4C_4
  int v67; // ST48_4
  int v68; // ST44_4
  int v69; // ST40_4
  int v70; // ST3C_4
  int v71; // ST38_4
  int v72; // esi
  int v73; // ebx
  char *v74; // eax
  int v75; // [esp+18h] [ebp-50h]
  int v76; // [esp+1Ch] [ebp-4Ch]
  int v77; // [esp+20h] [ebp-48h]
  int v78; // [esp+24h] [ebp-44h]
  int v79; // [esp+28h] [ebp-40h]
  int v80; // [esp+2Ch] [ebp-3Ch]
  int v81; // [esp+30h] [ebp-38h]
  int v82; // [esp+34h] [ebp-34h]
  int v83; // [esp+38h] [ebp-30h]
  int v84; // [esp+3Ch] [ebp-2Ch]
  int v85; // [esp+40h] [ebp-28h]

  if ( a2 )
    fprintf(stream, "%s (%s) %s\n", a2, a3, a4);
  else
    fprintf(stream, "%s %s\n", a3, a4);
  v6 = gettext("(C)");
  fprintf(stream, "Copyright %s %d Free Software Foundation, Inc.", v6, 2017);
  v7 = gettext(
         "\n"
         "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\n"
         "This is free software: you are free to change and redistribute it.\n"
         "There is NO WARRANTY, to the extent permitted by law.\n"
         "\n");
  fputs_unlocked(v7, stream);
  switch ( a6 )
  {
    case 0:
      abort();
      return result;
    case 1:
      v8 = *(_DWORD *)a5;
      v9 = gettext("Written by %s.\n");
      return fprintf(stream, v9, v8);
    case 2:
      v11 = *(_DWORD *)(a5 + 4);
      v12 = *(_DWORD *)a5;
      v13 = gettext("Written by %s and %s.\n");
      return fprintf(stream, v13, v12, v11);
    case 3:
      v14 = *(_DWORD *)(a5 + 8);
      v15 = *(_DWORD *)(a5 + 4);
      v16 = *(_DWORD *)a5;
      v17 = gettext("Written by %s, %s, and %s.\n");
      return fprintf(stream, v17, v16, v15, v14);
    case 4:
      v18 = *(_DWORD *)(a5 + 12);
      v19 = *(_DWORD *)(a5 + 8);
      v20 = *(_DWORD *)(a5 + 4);
      v21 = *(_DWORD *)a5;
      v22 = gettext("Written by %s, %s, %s,\nand %s.\n");
      fprintf(stream, v22);
      dword_80591DC = (int)&loc_8051253;
      sub_8053190(v23, v24, v21, v20, v19, v18, v75, v76, v77, v78, v79, v80, v81, v82, v83, v84, v85);
      goto LABEL_10;
    case 5:
LABEL_10:
      v25 = *(_DWORD *)(a5 + 16);
      v26 = *(_DWORD *)(a5 + 12);
      v27 = *(_DWORD *)(a5 + 8);
      v28 = *(_DWORD *)(a5 + 4);
      v29 = *(_DWORD *)a5;
      v30 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
      result = fprintf(stream, v30, v29, v28, v27, v26, v25);
      break;
    case 6:
      v31 = *(_DWORD *)(a5 + 20);
      v32 = *(_DWORD *)(a5 + 16);
      v33 = *(_DWORD *)(a5 + 12);
      v34 = *(_DWORD *)(a5 + 8);
      v35 = *(_DWORD *)(a5 + 4);
      v36 = *(_DWORD *)a5;
      v37 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
      result = fprintf(stream, v37, v36, v35, v34, v33, v32, v31);
      break;
    case 7:
      v38 = *(_DWORD *)(a5 + 24);
      v39 = *(_DWORD *)(a5 + 20);
      v40 = *(_DWORD *)(a5 + 16);
      v41 = *(_DWORD *)(a5 + 12);
      v42 = *(_DWORD *)(a5 + 8);
      v43 = *(_DWORD *)(a5 + 4);
      v44 = *(_DWORD *)a5;
      v45 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
      result = fprintf(stream, v45, v44, v43, v42, v41, v40, v39, v38);
      break;
    case 8:
      v46 = *(_DWORD *)(a5 + 28);
      v47 = *(_DWORD *)(a5 + 24);
      v48 = *(_DWORD *)(a5 + 20);
      v49 = *(_DWORD *)(a5 + 16);
      v50 = *(_DWORD *)(a5 + 12);
      v51 = *(_DWORD *)(a5 + 8);
      v52 = *(_DWORD *)(a5 + 4);
      v53 = *(_DWORD *)a5;
      v54 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
      result = fprintf(stream, v54, v53, v52, v51, v50, v49, v48, v47, v46);
      break;
    case 9:
      v55 = *(_DWORD *)(a5 + 32);
      v56 = *(_DWORD *)(a5 + 28);
      v57 = *(_DWORD *)(a5 + 24);
      v58 = *(_DWORD *)(a5 + 20);
      v59 = *(_DWORD *)(a5 + 16);
      v60 = *(_DWORD *)(a5 + 12);
      v61 = *(_DWORD *)(a5 + 8);
      v62 = *(_DWORD *)(a5 + 4);
      v63 = *(_DWORD *)a5;
      v64 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
      result = fprintf(stream, v64, v63, v62, v61, v60, v59, v58, v57, v56, v55);
      break;
    default:
      v65 = *(_DWORD *)(a5 + 32);
      v66 = *(_DWORD *)(a5 + 28);
      v67 = *(_DWORD *)(a5 + 24);
      v68 = *(_DWORD *)(a5 + 20);
      v69 = *(_DWORD *)(a5 + 16);
      v70 = *(_DWORD *)(a5 + 12);
      v71 = *(_DWORD *)(a5 + 8);
      v72 = *(_DWORD *)(a5 + 4);
      v73 = *(_DWORD *)a5;
      v74 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
      result = fprintf(stream, v74, v73, v72, v71, v70, v69, v68, v67, v66, v65);
      break;
  }
  return result;
}
// 8048F50: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8053190: using guessed type int __stdcall sub_8053190(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80591DC: using guessed type int dword_80591DC;

//----- (080512C0) --------------------------------------------------------
int __cdecl sub_80512C0(FILE *stream, int a2, int a3, int a4, int a5)
{
  int *v5; // eax
  int v7; // [esp+0h] [ebp-58h]
  int v8; // [esp+4h] [ebp-54h]
  int v9; // [esp+8h] [ebp-50h]
  int v10; // [esp+Ch] [ebp-4Ch]
  int v11; // [esp+10h] [ebp-48h]
  int v12; // [esp+14h] [ebp-44h]
  int v13; // [esp+18h] [ebp-40h]
  int v14; // [esp+1Ch] [ebp-3Ch]
  int v15; // [esp+20h] [ebp-38h]
  int v16; // [esp+24h] [ebp-34h]
  int v17; // [esp+28h] [ebp-30h]
  int v18; // [esp+2Ch] [ebp-2Ch]
  int v19; // [esp+30h] [ebp-28h]
  int v20; // [esp+34h] [ebp-24h]
  int v21; // [esp+38h] [ebp-20h]
  int v22; // [esp+3Ch] [ebp-1Ch]

  dword_8059128 = (int)&loc_80512E0;
  sub_80535C9(v7, v8, v9, v10, v11, v12, v13, v14, v15, 0, v17, v18, v19, v20, v21, v22);
  do
  {
    if ( (unsigned int)++v16 > 9 )
      break;
    v5 = (int *)a5;
    a5 += 4;
    *(&v17 + v16) = *v5;
  }
  while ( *(&v17 + v16) );
  return sub_8050D44(stream, a2, a3, a4, (int)&v17, v16);
}
// 80535C9: using guessed type int __stdcall sub_80535C9(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8059128: using guessed type int dword_8059128;

//----- (08051333) --------------------------------------------------------
int sub_8051333(FILE *stream, int a2, int a3, int a4, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a4);
  return sub_80512C0(stream, a2, a3, a4, (int)va);
}

//----- (08051446) --------------------------------------------------------
void *__cdecl sub_8051446(void *ptr, int a2, int a3)
{
  unsigned int v4; // [esp+1Ch] [ebp-Ch]

  v4 = *(_DWORD *)a2;
  if ( ptr )
  {
    if ( 0x55555554u / a3 <= v4 )
      sub_80516F1();
    v4 += (v4 >> 1) + 1;
  }
  else
  {
    if ( !v4 )
      v4 = (0x40u / a3 == 0) + 0x40u / a3;
    if ( 0x7FFFFFFFu / a3 < v4 )
      sub_80516F1();
  }
  *(_DWORD *)a2 = v4;
  return sub_8051561(ptr, a3 * v4);
}

//----- (080514ED) --------------------------------------------------------
void *__cdecl sub_80514ED(size_t size)
{
  return sub_8051510(size);
}

//----- (08051510) --------------------------------------------------------
void *__cdecl sub_8051510(size_t size)
{
  void *v1; // eax
  void *v3; // [esp+1Ch] [ebp-Ch]

  v3 = malloc(size);
  if ( !v3 )
  {
    v1 = &loc_8051557;
    if ( !size )
      v1 = &loc_805155C;
    dword_8059114 = (int)v1;
    sub_8053637();
    sub_80516F1();
  }
  return v3;
}
// 8053637: using guessed type int sub_8053637(void);
// 8059114: using guessed type int dword_8059114;

//----- (08051561) --------------------------------------------------------
void *__cdecl sub_8051561(void *ptr, size_t size)
{
  void *v2; // eax
  void *v3; // eax
  bool v4; // zf
  void *v5; // eax
  int v7; // [esp+0h] [ebp-18h]
  void *ptra; // [esp+20h] [ebp+8h]

  v2 = &loc_8051586;
  if ( size )
    v2 = &loc_80515AB;
  dword_805918C = (int)v2;
  sub_8053386();
  if ( ptr )
  {
    free(ptr);
    dword_80591A0 = (int)&locret_80515FF;
    sub_8053314();
  }
  v3 = realloc(ptr, size);
  ptra = v3;
  v4 = v3 == 0;
  v5 = &loc_80515DF;
  if ( !v4 )
    v5 = &loc_80515FC;
  dword_8059204 = (int)v5;
  sub_80530AA(v7);
  if ( size )
    sub_80516F1();
  return ptra;
}
// 8051561: could not find valid save-restore pair for ebx
// 80530AA: using guessed type int __stdcall sub_80530AA(_DWORD);
// 8053314: using guessed type int sub_8053314(void);
// 8053386: using guessed type int sub_8053386(void);
// 805918C: using guessed type int dword_805918C;
// 80591A0: using guessed type int dword_80591A0;
// 8059204: using guessed type int dword_8059204;

//----- (08051601) --------------------------------------------------------
void *__cdecl sub_8051601(void *ptr, int a2)
{
  return sub_8051446(ptr, a2, 1);
}

//----- (0805164D) --------------------------------------------------------
void __cdecl __noreturn sub_805164D(size_t nmemb, size_t size)
{
  bool v2; // zf
  int (*v3)(); // eax

  if ( 0x7FFFFFFF / size >= nmemb )
  {
    v2 = calloc(nmemb, size) == 0;
    v3 = (int (*)())&loc_8051699;
    if ( !v2 )
      v3 = sub_805169E;
    dword_8059114 = (int)v3;
    sub_8053637();
  }
  sub_80516F1();
}
// 805169E: using guessed type int sub_805169E();
// 8053637: using guessed type int sub_8053637(void);
// 8059114: using guessed type int dword_8059114;

//----- (0805169E) --------------------------------------------------------
#error "80516A2: positive sp value has been found (funcsize=0)"

//----- (080516A3) --------------------------------------------------------
void *__cdecl sub_80516A3(void *src, size_t n)
{
  void *v2; // eax

  v2 = sub_8051510(n);
  return memcpy(v2, src, n);
}

//----- (080516F1) --------------------------------------------------------
void __noreturn sub_80516F1()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (0805172A) --------------------------------------------------------
void __cdecl sub_805172A(int errnum, int a2, int a3, int a4, int a5)
{
  char *v5; // eax
  char *v6; // eax
  void *v7; // esi
  void *v8; // ebx
  char *v9; // eax

  v5 = gettext("string comparison failed");
  error(0, errnum, v5);
  v6 = gettext("Set LC_ALL='C' to work around the problem.");
  error(0, 0, v6);
  v7 = sub_80508C2(1, 8, a4, a5);
  v8 = sub_80508C2(0, 8, a2, a3);
  v9 = gettext("The strings compared were %s and %s.");
  error(status, 0, v9, v8, v7);
}

//----- (080517F6) --------------------------------------------------------
int __cdecl sub_80517F6(void *s1, size_t n, void *s2, int a4)
{
  int v5; // [esp+28h] [ebp-10h]
  int errnum; // [esp+2Ch] [ebp-Ch]

  v5 = sub_8052ACC(s1, n, s2, a4);
  errnum = *__errno_location();
  if ( errnum )
    sub_805172A(errnum, (int)s1, n, (int)s2, a4);
  return v5;
}

//----- (080518DF) --------------------------------------------------------
signed int __cdecl sub_80518DF(unsigned int *a1, unsigned int a2)
{
  signed int result; // eax

  if ( 0xFFFFFFFF / a2 >= *a1 )
  {
    *a1 *= a2;
    result = 0;
  }
  else
  {
    *a1 = -1;
    result = 1;
  }
  return result;
}

//----- (08051931) --------------------------------------------------------
int __cdecl sub_8051931(unsigned int *a1, unsigned int a2, int a3)
{
  int v3; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; i |= sub_80518DF(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}

//----- (08051975) --------------------------------------------------------
int __cdecl sub_8051975(char *nptr, int a2, int base, int a4, char *s)
{
  char **v5; // eax
  bool v7; // zf
  void *v8; // eax
  int v9; // eax
  void *v10; // eax
  signed int v11; // eax
  int v12; // ST08_4
  int v13; // ST0C_4
  int v14; // eax
  int v15; // ST08_4
  int v16; // ST0C_4
  int v17; // ST10_4
  signed int v18; // eax
  int v19; // ST08_4
  int v20; // ST0C_4
  int v21; // [esp+0h] [ebp-48h]
  int v22; // [esp+4h] [ebp-44h]
  int v23; // [esp+8h] [ebp-40h]
  int v24; // [esp+8h] [ebp-40h]
  int v25; // [esp+Ch] [ebp-3Ch]
  int v26; // [esp+Ch] [ebp-3Ch]
  int v27; // [esp+10h] [ebp-38h]
  int v28; // [esp+10h] [ebp-38h]
  int v29; // [esp+14h] [ebp-34h]
  int v30; // [esp+14h] [ebp-34h]
  int v31; // [esp+18h] [ebp-30h]
  int v32; // [esp+18h] [ebp-30h]
  int v33; // [esp+1Ch] [ebp-2Ch]
  int v34; // [esp+1Ch] [ebp-2Ch]
  char v35; // [esp+20h] [ebp-28h]
  unsigned int v36; // [esp+24h] [ebp-24h]
  int v37; // [esp+28h] [ebp-20h]
  char *v38; // [esp+2Ch] [ebp-1Ch]
  unsigned int v39; // [esp+30h] [ebp-18h]
  int v40; // [esp+34h] [ebp-14h]
  int v41; // [esp+38h] [ebp-10h]
  char **endptr; // [esp+3Ch] [ebp-Ch]

  v37 = 0;
  if ( base < 0 || base > 36 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoul");
  if ( a2 )
    v5 = (char **)a2;
  else
    v5 = (char **)&v35;
  endptr = v5;
  *__errno_location() = 0;
  v38 = nptr;
  HIBYTE(v33) = *nptr;
  while ( (*__ctype_b_loc())[HIBYTE(v33)] & 0x2000 )
    HIBYTE(v33) = *++v38;
  if ( HIBYTE(v33) == 45 )
    return 4;
  v36 = strtoul(nptr, endptr, base);
  if ( *endptr == nptr )
  {
    if ( s && **endptr && strchr(s, **endptr) )
    {
      v36 = 1;
      dword_8059178 = (int)&loc_8051AF5;
      sub_80533F8();
    }
    dword_8059204 = (int)&locret_8051DFE;
    sub_80530AA(v21);
  }
  v7 = *__errno_location() == 0;
  v8 = &loc_8051ACE;
  if ( v7 )
    v8 = &loc_8051AF5;
  dword_8059128 = (int)v8;
  sub_80535C9(v21, v22, v23, v25, v27, v29, v31, v33, *(_DWORD *)&v35, v36, v37, v38, v39, v40, v41, endptr);
  if ( *__errno_location() != 34 )
  {
    dword_8059178 = (int)&locret_8051DFE;
    sub_80533F8();
  }
  v37 = 1;
  if ( !s )
  {
    *(_DWORD *)a4 = v36;
    return v37;
  }
  if ( **endptr )
  {
    v39 = 1024;
    v40 = 1;
    if ( !strchr(s, **endptr) )
    {
      *(_DWORD *)a4 = v36;
      return v37 | 2;
    }
    switch ( **endptr )
    {
      case 69:
      case 71:
      case 75:
      case 77:
      case 80:
      case 84:
      case 89:
      case 90:
      case 103:
      case 107:
      case 109:
      case 116:
        if ( strchr(s, 48) )
        {
          v9 = (*endptr)[1];
          if ( v9 == 68 )
            goto LABEL_56;
          v7 = v9 == 105;
          v10 = &loc_8051BC2;
          if ( v7 )
            v10 = &loc_8051BD6;
          dword_80591A0 = (int)v10;
          if ( sub_8053314() == 66 )
          {
LABEL_56:
            v39 = 1000;
            ++v40;
          }
          else
          {
            dword_805918C = (int)&loc_8051BF8;
            sub_8053386();
            if ( (*endptr)[2] == 66 )
              v40 += 2;
          }
        }
        break;
      default:
        break;
    }
    switch ( **endptr )
    {
      case 66:
        goto LABEL_39;
      case 69:
        v41 = sub_8051931(&v36, v39, 6);
        break;
      case 71:
      case 103:
        v41 = sub_8051931(&v36, v39, 3);
        break;
      case 75:
      case 107:
        v14 = sub_8051931(&v36, v39, 1);
        dword_8059150 = (int)&loc_8051DCE;
        sub_80534D6(v15, v16, v17, v26, v28, v30, v32, v34, *(_DWORD *)&v35, v36, v37, v38, v39, v40, v14);
        goto LABEL_44;
      case 77:
      case 109:
LABEL_44:
        v41 = sub_8051931(&v36, v39, 2);
        break;
      case 80:
        v41 = sub_8051931(&v36, v39, 5);
        dword_8059114 = (int)&loc_8051DCE;
        sub_8053637();
        goto LABEL_46;
      case 84:
      case 116:
LABEL_46:
        v41 = sub_8051931(&v36, v39, 4);
        dword_80591A0 = (int)&loc_8051DCE;
        sub_8053314();
        goto LABEL_47;
      case 89:
        goto LABEL_48;
      case 90:
        v41 = sub_8051931(&v36, v39, 7);
        break;
      case 98:
        v11 = sub_80518DF(&v36, 0x200u);
        dword_8059150 = (int)&loc_8051DCE;
        sub_80534D6(v12, v13, v24, v26, v28, v30, v32, v34, *(_DWORD *)&v35, v36, v37, v38, v39, v40, v11);
LABEL_39:
        v41 = sub_80518DF(&v36, 0x400u);
        break;
      case 99:
        v41 = 0;
        break;
      case 119:
LABEL_47:
        v18 = sub_80518DF(&v36, 2u);
        dword_8059128 = (int)&loc_8051DCE;
        sub_80535C9(v19, v20, v24, v26, v28, v30, v32, v34, *(_DWORD *)&v35, v36, v37, v38, v39, v40, v18, endptr);
LABEL_48:
        v41 = sub_8051931(&v36, v39, 8);
        break;
      default:
        *(_DWORD *)a4 = v36;
        dword_8059164 = (int)&locret_8051DFE;
        sub_8053468();
        break;
    }
    v37 |= v41;
    *endptr += v40;
    if ( **endptr )
      v37 |= 2u;
  }
  *(_DWORD *)a4 = v36;
  return v37;
}
// 8051975: could not find valid save-restore pair for ebx
// 80530AA: using guessed type int __stdcall sub_80530AA(_DWORD);
// 8053314: using guessed type int sub_8053314(void);
// 8053386: using guessed type int sub_8053386(void);
// 80533F8: using guessed type int sub_80533F8(void);
// 8053468: using guessed type int sub_8053468(void);
// 80534D6: using guessed type int __stdcall sub_80534D6(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80535C9: using guessed type int __stdcall sub_80535C9(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8053637: using guessed type int sub_8053637(void);
// 8059114: using guessed type int dword_8059114;
// 8059128: using guessed type int dword_8059128;
// 8059150: using guessed type int dword_8059150;
// 8059164: using guessed type int dword_8059164;
// 8059178: using guessed type int dword_8059178;
// 805918C: using guessed type int dword_805918C;
// 80591A0: using guessed type int dword_80591A0;
// 8059204: using guessed type int dword_8059204;

//----- (08051E00) --------------------------------------------------------
int __cdecl sub_8051E00(FILE *stream)
{
  int v2; // eax
  __int64 v3; // rax
  bool v4; // zf
  void *v5; // eax
  int v6; // [esp+0h] [ebp-28h]
  int v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+18h] [ebp-10h]

  v7 = 0;
  if ( fileno(stream) < 0 )
    return fclose(stream);
  if ( !__freading(stream) || (v2 = fileno(stream), LODWORD(v3) = lseek64(v2, 0, 0, 1), v3 != -1) )
  {
    v4 = sub_80520C0(stream) == 0;
    v5 = &loc_8051EBA;
    if ( v4 )
      v5 = &loc_8051EC4;
    dword_8059204 = (int)v5;
    sub_80530AA(v6);
    v7 = *__errno_location();
  }
  v8 = fclose(stream);
  if ( v7 )
  {
    *__errno_location() = v7;
    v8 = -1;
  }
  return v8;
}
// 8049090: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 80530AA: using guessed type int __stdcall sub_80530AA(_DWORD);
// 8059204: using guessed type int dword_8059204;

//----- (08051EEE) --------------------------------------------------------
int __cdecl sub_8051EEE(int fd, int cmd, char a3)
{
  bool v3; // zf
  void *v4; // eax
  int v5; // ST30_4
  int v7; // [esp+1Ch] [ebp-1Ch]
  char v8; // [esp+20h] [ebp-18h]
  int v9; // [esp+24h] [ebp-14h]

  if ( cmd != 1030 )
    return fcntl(fd, cmd, a3);
  v8 = a3;
  if ( dword_8059A1D < 0 )
  {
    v7 = sub_8051EEE(fd, 0, a3);
  }
  else
  {
    v7 = fcntl(fd, 1030, a3);
    if ( v7 < 0 && *__errno_location() == 22 )
    {
      v7 = sub_8051EEE(fd, 0, v8);
      if ( v7 < 0 )
        return v7;
      dword_8059A1D = -1;
    }
    else
    {
      dword_8059A1D = 1;
    }
  }
  if ( v7 >= 0 && dword_8059A1D == -1 )
  {
    v9 = fcntl(v7, 1);
    if ( v9 >= 0 )
    {
      v3 = fcntl(v7, 2, v9 | 1) == -1;
      v4 = &loc_805201C;
      if ( !v3 )
        v4 = &loc_8052044;
      dword_80591A0 = (int)v4;
      sub_8053314();
    }
    v5 = *__errno_location();
    close(v7);
    *__errno_location() = v5;
    v7 = -1;
  }
  return v7;
}
// 8053314: using guessed type int sub_8053314(void);
// 80591A0: using guessed type int dword_80591A0;
// 8059A1D: using guessed type int dword_8059A1D;

//----- (08052075) --------------------------------------------------------
int __cdecl sub_8052075(FILE *stream)
{
  int result; // eax

  result = stream->_flags & 0x100;
  if ( result )
    result = sub_805210D(stream, 0, 0, 1);
  return result;
}

//----- (080520C0) --------------------------------------------------------
#error "80520F0: call analysis failed (funcsize=23)"

//----- (0805210D) --------------------------------------------------------
int __cdecl sub_805210D(FILE *stream, int a2, int a3, int a4)
{
  int v4; // eax
  __off64_t v5; // rax
  __off64_t v7; // [esp+28h] [ebp-10h]

  if ( stream->_IO_read_end != stream->_IO_read_ptr
    || stream->_IO_write_ptr != stream->_IO_write_base
    || stream->_IO_save_base )
  {
    return fseeko64(stream, a2, a3, a4);
  }
  v4 = fileno(stream);
  LODWORD(v5) = lseek64(v4, a2, a3, a4);
  v7 = v5;
  if ( v5 == -1 )
  {
    dword_8059114 = (int)&locret_80521EE;
    sub_8053637();
  }
  stream->_flags &= 0xFFFFFFEF;
  stream->_offset = v7;
  return 0;
}
// 8048DF0: using guessed type int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8049090: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8053637: using guessed type int sub_8053637(void);
// 8059114: using guessed type int dword_8059114;

//----- (080521F0) --------------------------------------------------------
size_t __cdecl sub_80521F0(wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  void *v4; // eax
  char v6; // [esp+18h] [ebp-10h]
  size_t v7; // [esp+1Ch] [ebp-Ch]

  if ( !pwc )
    pwc = (wchar_t *)&v6;
  v7 = mbrtowc(pwc, s, n, p);
  if ( v7 > 0xFFFFFFFD )
  {
    v4 = &loc_805224A;
    if ( !n )
      v4 = &loc_8052283;
    dword_80591B4 = (int)v4;
    sub_8053287();
    if ( (unsigned __int8)sub_804ED4D(0) ^ 1 )
    {
      *pwc = (unsigned __int8)*s;
      dword_8059178 = (int)&locret_8052286;
      sub_80533F8();
    }
  }
  return v7;
}
// 8053287: using guessed type int sub_8053287(void);
// 80533F8: using guessed type int sub_80533F8(void);
// 8059178: using guessed type int dword_8059178;
// 80591B4: using guessed type int dword_80591B4;

//----- (08052288) --------------------------------------------------------
int __cdecl sub_8052288(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // esi
  unsigned __int8 *v3; // ebx
  unsigned __int8 v5; // [esp+1Eh] [ebp-Ah]
  unsigned __int8 v6; // [esp+1Fh] [ebp-9h]

  v2 = a1;
  v3 = a2;
  if ( a1 == a2 )
    return 0;
  do
  {
    v5 = sub_8052E5F(*v2);
    v6 = sub_8052E5F(*v3);
    if ( !v5 )
      break;
    ++v2;
    ++v3;
  }
  while ( v5 == v6 );
  return v5 - v6;
}

//----- (080522FF) --------------------------------------------------------
#error "8052358: call analysis failed (funcsize=66)"

//----- (080523CD) --------------------------------------------------------
void *sub_80523CD()
{
  FILE *v2; // eax
  bool v3; // zf
  void *v4; // eax
  int v5; // ST08_4
  int v6; // eax
  void *v7; // eax
  int v8; // eax
  void *v9; // eax
  int v11; // [esp+0h] [ebp-C8h]
  int v12; // [esp+0h] [ebp-C8h]
  int v13; // [esp+0h] [ebp-C8h]
  int v14; // [esp+0h] [ebp-C8h]
  int v15; // [esp+4h] [ebp-C4h]
  int v16; // [esp+4h] [ebp-C4h]
  int v17; // [esp+4h] [ebp-C4h]
  int v18; // [esp+8h] [ebp-C0h]
  char *v19; // [esp+8h] [ebp-C0h]
  int v20; // [esp+Ch] [ebp-BCh]
  char *v21; // [esp+Ch] [ebp-BCh]
  int v22; // [esp+10h] [ebp-B8h]
  int v23; // [esp+10h] [ebp-B8h]
  void *ptr; // [esp+14h] [ebp-B4h]
  void *ptra; // [esp+14h] [ebp-B4h]
  void *v26; // [esp+18h] [ebp-B0h]
  int v27; // [esp+18h] [ebp-B0h]
  const char *s; // [esp+1Ch] [ebp-ACh]
  char *sa; // [esp+1Ch] [ebp-ACh]
  void *v30; // [esp+20h] [ebp-A8h]
  void *v31; // [esp+20h] [ebp-A8h]
  int v32; // [esp+24h] [ebp-A4h]
  int v33; // [esp+24h] [ebp-A4h]
  char *v34; // [esp+28h] [ebp-A0h]
  char *v35; // [esp+28h] [ebp-A0h]
  size_t n; // [esp+2Ch] [ebp-9Ch]
  size_t na; // [esp+2Ch] [ebp-9Ch]
  size_t v38; // [esp+30h] [ebp-98h]
  int v39; // [esp+30h] [ebp-98h]
  int v40; // [esp+34h] [ebp-94h]
  int v41; // [esp+34h] [ebp-94h]
  void *dest; // [esp+38h] [ebp-90h]
  char *desta; // [esp+38h] [ebp-90h]
  int fd; // [esp+3Ch] [ebp-8Ch]
  int fda; // [esp+3Ch] [ebp-8Ch]
  FILE *stream; // [esp+40h] [ebp-88h]
  FILE *streama; // [esp+40h] [ebp-88h]
  int c; // [esp+44h] [ebp-84h]
  int ca; // [esp+44h] [ebp-84h]
  size_t v50; // [esp+48h] [ebp-80h]
  size_t v51; // [esp+4Ch] [ebp-7Ch]
  void *v52; // [esp+50h] [ebp-78h]
  char src; // [esp+56h] [ebp-72h]
  char v54; // [esp+89h] [ebp-3Fh]
  unsigned int v55; // [esp+BCh] [ebp-Ch]

  v55 = __readgsdword(0x14u);
  v26 = (void *)dword_8059A21;
  if ( dword_8059A21 )
    return v26;
  ptr = 0;
  v34 = (char *)&unk_8054F00;
  s = getenv("CHARSETALIASDIR");
  if ( !s || !*s )
  {
    ptr = 0;
    s = "/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib";
  }
  n = strlen(s);
  v38 = strlen((const char *)&unk_8054F00);
  if ( n && s[n - 1] != 47 )
  {
    dword_80591C8 = (int)&loc_80524AC;
    sub_8053217(v11, v15, v18, v20, v22, 0, v26, s, v30, v32, &unk_8054F00, n, v38, v40, dest, fd, stream);
  }
  desta = (char *)malloc(n + v38 + 1);
  if ( desta )
  {
    memcpy(desta, s, n);
    memcpy(&desta[n], v34, v38 + 1);
  }
  free(ptr);
  if ( !desta )
  {
    v26 = &unk_8054F57;
    goto LABEL_42;
  }
  fda = open64(desta, 0x20000);
  if ( fda < 0 )
  {
    v26 = &unk_8054F57;
    goto LABEL_41;
  }
  v2 = fdopen(fda, "r");
  streama = v2;
  v3 = v2 == 0;
  v4 = &loc_80525EB;
  if ( !v3 )
    v4 = &loc_8052612;
  dword_8059204 = (int)v4;
  sub_80530AA(v12);
  close(fda);
  dword_80591F0 = (int)&loc_805287B;
  sub_805311E(v5, v16, v18, v20, v22, ptr, &unk_8054F57, s, v30, v32, v34, n, v38, 0, desta);
  v31 = 0;
  v33 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          v6 = getc_unlocked(streama);
          c = v6;
          if ( v6 == -1 )
            goto LABEL_37;
          if ( v6 != 10 )
          {
            v7 = &loc_8052673;
            if ( c == 32 )
              v7 = &loc_805267C;
            dword_80591F0 = (int)v7;
            sub_805311E(v13, v17, v19, v21, v23, ptra, v27, sa, v31, v33, v35, na, v39, v41, desta);
            if ( c != 9 )
              break;
          }
        }
        if ( c != 35 )
          break;
        do
        {
          v8 = getc_unlocked(streama);
          ca = v8;
          v3 = v8 == -1;
          v9 = &loc_80526C0;
          if ( v3 )
            v9 = &loc_80526C9;
          dword_80591A0 = (int)v9;
          sub_8053314();
        }
        while ( ca != 10 );
      }
      ungetc(c, streama);
      v21 = &v54;
      v19 = &src;
      if ( fscanf(streama, "%50s %50s") <= 1 )
        break;
      v50 = strlen(&src);
      v51 = strlen(&v54);
      v52 = v31;
      if ( v33 )
      {
        v33 += v51 + v50 + 2;
        v31 = realloc(v31, v33 + 1);
      }
      else
      {
        v33 = v50 + v51 + 2;
        v31 = malloc(v50 + v51 + 3);
      }
      if ( !v31 )
      {
        v33 = 0;
        free(v52);
        break;
      }
      strcpy((char *)v31 + v33 - v51 - v50 - 2, &src);
      strcpy((char *)v31 + v33 - v51 - 1, &v54);
    }
LABEL_37:
    sub_8051E00(streama);
    if ( !v33 )
      break;
    dword_8059204 = (int)&loc_805285E;
    sub_80530AA(v14);
  }
  v26 = &unk_8054F57;
LABEL_41:
  free(desta);
LABEL_42:
  dword_8059A21 = (int)&unk_8054F57;
  return v26;
}
// 8048D60: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 80530AA: using guessed type int __stdcall sub_80530AA(_DWORD);
// 805311E: using guessed type int __stdcall sub_805311E(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8053217: using guessed type int __stdcall sub_8053217(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8053314: using guessed type int sub_8053314(void);
// 80591A0: using guessed type int dword_80591A0;
// 80591C8: using guessed type int dword_80591C8;
// 80591F0: using guessed type int dword_80591F0;
// 8059204: using guessed type int dword_8059204;
// 8059A21: using guessed type int dword_8059A21;

//----- (080528B4) --------------------------------------------------------
#error "80528E3: call analysis failed (funcsize=40)"

//----- (080529CE) --------------------------------------------------------
#error "8052A49: call analysis failed (funcsize=49)"

//----- (08052ACC) --------------------------------------------------------
int __cdecl sub_8052ACC(void *s1, size_t n, void *s2, int a4)
{
  char v4; // ST1A_1
  char v5; // ST1B_1
  int v6; // ST1C_4

  if ( n == a4 && !memcmp(s1, s2, n) )
  {
    *__errno_location() = 0;
    dword_8059178 = (int)&loc_8052B8F;
    sub_80533F8();
  }
  v4 = *((_BYTE *)s1 + n);
  v5 = *((_BYTE *)s2 + a4);
  *((_BYTE *)s1 + n) = 0;
  *((_BYTE *)s2 + a4) = 0;
  v6 = sub_80529CE((char *)s1, n + 1, (char *)s2, a4 + 1);
  *((_BYTE *)s1 + n) = v4;
  *((_BYTE *)s2 + a4) = v5;
  return v6;
}
// 80533F8: using guessed type int sub_80533F8(void);
// 8059178: using guessed type int dword_8059178;

//----- (08052B94) --------------------------------------------------------
int __cdecl sub_8052B94(void *s1, size_t n, void *s2, int a4)
{
  if ( n != a4 || memcmp(s1, s2, n) )
    return sub_80529CE((char *)s1, n, (char *)s2, a4);
  *__errno_location() = 0;
  return 0;
}

//----- (08052E5F) --------------------------------------------------------
int __cdecl sub_8052E5F(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 65) > 0x19 )
    result = a1;
  else
    result = a1 + 32;
  return result;
}

//----- (08052F0D) --------------------------------------------------------
int __cdecl sub_8052F0D(int a1)
{
  return __cxa_atexit(a1, 0, dword_8059240);
}
// 8048EB0: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 8059240: using guessed type int dword_8059240;

//----- (080530AA) --------------------------------------------------------
#error "80530B0: positive sp value has been found (funcsize=0)"

//----- (0805311E) --------------------------------------------------------
#error "8053124: positive sp value has been found (funcsize=0)"

//----- (08053190) --------------------------------------------------------
#error "8053196: positive sp value has been found (funcsize=0)"

//----- (080531D6) --------------------------------------------------------
#error "805320F: positive sp value has been found (funcsize=18)"

//----- (08053217) --------------------------------------------------------
#error "805321D: positive sp value has been found (funcsize=0)"

//----- (08053287) --------------------------------------------------------
#error "805328D: positive sp value has been found (funcsize=0)"

//----- (080532D3) --------------------------------------------------------
#error "805330C: positive sp value has been found (funcsize=18)"

//----- (08053314) --------------------------------------------------------
#error "805331A: positive sp value has been found (funcsize=0)"

//----- (08053386) --------------------------------------------------------
#error "805338C: positive sp value has been found (funcsize=0)"

//----- (080533F8) --------------------------------------------------------
#error "80533FE: positive sp value has been found (funcsize=0)"

//----- (08053468) --------------------------------------------------------
#error "805346E: positive sp value has been found (funcsize=0)"

//----- (080534D6) --------------------------------------------------------
#error "80534DC: positive sp value has been found (funcsize=0)"

//----- (0805351A) --------------------------------------------------------
#error "8053553: positive sp value has been found (funcsize=18)"

//----- (0805355B) --------------------------------------------------------
#error "8053561: positive sp value has been found (funcsize=0)"

//----- (080535C9) --------------------------------------------------------
#error "80535CF: positive sp value has been found (funcsize=0)"

//----- (08053637) --------------------------------------------------------
#error "805363D: positive sp value has been found (funcsize=0)"

//----- (08053650) --------------------------------------------------------
int (**sub_8053650())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_8058EC4;
  v1 = &off_8058EC8 - off_8058EC4;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_8058EC4[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 8058EC4: using guessed type int (*off_8058EC4[2])();
// 8058EC8: using guessed type int (*off_8058EC8)();

//----- (080536B4) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 31 decompilation failure(s) on 176 function(s)"
