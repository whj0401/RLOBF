/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8048D40();
// int strcmp(const char *s1, const char *s2);
// int __cdecl open64(_DWORD, _DWORD); weak
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void _exit(int status);
// void free(void *ptr);
// void *memcpy(void *dest, const void *src, size_t n);
// int mbsinit(const mbstate_t *ps);
// int fclose(FILE *stream);
// int getc_unlocked(FILE *stream);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// int iswprint(wint_t wc);
// int __cdecl fopen64(_DWORD, _DWORD); weak
// int ferror_unlocked(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// size_t __ctype_get_mb_cur_max(void);
// size_t __fpending(FILE *fp);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// void error(int status, int errnum, const char *format, ...);
// int strcoll(const char *s1, const char *s2);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// char *strchr(const char *s, int c);
// size_t strlen(const char *s);
// int fprintf(FILE *stream, const char *format, ...);
// int fcntl(int fd, int cmd, ...);
// void *memset(void *s, int c, size_t n);
// int *__errno_location(void);
// void *memchr(const void *s, int c, size_t n);
// int fileno(FILE *stream);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// char *strpbrk(const char *s, const char *accept);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// int toupper(int c);
// char *strrchr(const char *s, int c);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// int feof_unlocked(FILE *stream);
// void abort(void);
// int close(int fd);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// void *calloc(size_t nmemb, size_t size);
// int putchar_unlocked(int c);
// int _gmon_start__(void); weak
void sub_8049183();
void sub_80491A0();
int sub_80491B0();
int sub_8049220();
int sub_8049240();
void sub_804929F();
void sub_80492BA();
int sub_80492CA();
void sub_80493AC();
void sub_80493C7();
int sub_80493D7();
void sub_80494B9();
void sub_80494D4();
int sub_80494E4();
void sub_80495C6();
void sub_80495E1();
signed int sub_80495F1();
void sub_80496D3();
void sub_80496EE();
int sub_80496FE();
void sub_80497F9();
void sub_8049814();
int sub_8049824();
// int __usercall sub_804988B@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
void sub_8049922();
void sub_804993D();
int sub_804994D();
int nullsub_4(void); // weak
int sub_80499AB();
int sub_80499F0();
void sub_8049A64();
void sub_8049A7F();
int sub_8049A8F();
// int __usercall sub_8049B41@<eax>(void (__cdecl *a1)(int *)@<eax>);
void sub_8049B8D();
void sub_8049BA8();
int sub_8049BB8();
void sub_8049CB3();
void sub_8049CCE();
int sub_8049CDE();
int nullsub_7(void); // weak
int sub_8049D3C();
void sub_8049DF0();
void sub_8049E0B();
int sub_8049E1B();
void sub_8049F16();
void sub_8049F31();
int __fastcall sub_8049F41(int a1, int a2);
// int __usercall sub_8049FC1@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
void sub_804A058();
void sub_804A073();
signed int sub_804A083();
void sub_804A1AD();
void sub_804A1D8();
int sub_804A1F8();
void sub_804A312();
void sub_804A32D();
signed int sub_804A33D();
int nullsub_6(void); // weak
// int __usercall sub_804A39B@<eax>(int a1@<ebp>);
// int __usercall sub_804A421@<eax>(void (__cdecl *a1)(signed int)@<eax>);
int __cdecl sub_804A43B(unsigned __int8 a1);
int __cdecl sub_804A47A(char *s1); // idb
void __cdecl __noreturn sub_804A636(int status); // idb
int __cdecl sub_804A7C3(int a1, int a2, int a3);
int __cdecl sub_804A84F(int a1);
int __cdecl sub_804AA21(int a1);
signed int __cdecl sub_804AA61(int a1, int a2, unsigned int a3, unsigned int a4);
int __cdecl sub_804AC09(int a1, int a2, int a3);
int __cdecl sub_804ADB7(int a1);
void *__cdecl sub_804ADC6(_DWORD *a1);
int __cdecl sub_804ADF0(FILE *stream, int, int); // idb
void sub_804AF89();
_DWORD *__cdecl sub_804AFD6(_DWORD *a1);
int __cdecl sub_804AFF8(FILE *stream, int, int); // idb
int __cdecl sub_804B0C7(FILE *stream, int, int, int); // idb
void __cdecl sub_804B10B(int a1);
char *__cdecl sub_804B260(int a1, unsigned int a2, size_t a3);
// void __usercall sub_804B7B2(signed int *a1@<ebx>, FILE *stream, FILE *a3);
_DWORD *__cdecl sub_804D851(int a1, int a2);
int __cdecl sub_804D915(char *nptr); // idb
void __cdecl sub_804D9AC(char *a1, _DWORD *a2, _DWORD *a3);
_DWORD *__cdecl sub_804DAFC(char *a1);
_DWORD *__cdecl sub_804DB98(_DWORD *a1, int a2);
_DWORD *__cdecl sub_804DC14(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, signed int *a5, _DWORD *a6, _DWORD *a7);
void __cdecl __noreturn main(int argc, char **argv);
int sub_804E7D1();
int __cdecl sub_804E8B5(int a1, int a2, int a3, int a4, int a5, int a6);
void __cdecl sub_804E916(FILE *stream, int a2);
FILE *__cdecl sub_804E970(int a1, char *modes);
int __cdecl sub_804EA58(int category); // idb
int __cdecl sub_804EB2D(int, FILE *stream, int); // idb
int __cdecl sub_804EC79(unsigned __int8 *a1, unsigned __int8 *a2, unsigned int a3);
void __cdecl __noreturn sub_804ED12(int a1);
int __cdecl sub_804ED61(int c, size_t n); // idb
int __cdecl sub_804EF21(int *a1, unsigned __int8 a2, char a3);
int *__cdecl sub_804EFCB(int *a1, int a2, int a3);
void __cdecl __noreturn sub_804F018(int a1, int a2);
int __stdcall sub_804F057(int); // weak
const char *__cdecl sub_804F0B3(char *msgid, int a2);
unsigned int __cdecl sub_804F186(int a1, unsigned int a2, int a3, size_t a4, signed int a5, int a6, int a7, char *a8, char *a9);
void *__cdecl sub_8050027(int a1, size_t a2, _DWORD *a3, int a4);
void *__cdecl sub_8050202(signed int a1, int a2, size_t a3, int a4);
void *__cdecl sub_8050444(signed int a1, int a2);
void *__cdecl sub_8050480(signed int a1, int a2, size_t a3);
void __cdecl __noreturn sub_80504E6(int a1, int a2);
void __cdecl __noreturn sub_8050524(int a1, int a2);
void __cdecl __noreturn sub_8050561(int a1);
void *__cdecl sub_80505BE(int a1, size_t a2, unsigned __int8 a3);
void *__cdecl sub_8050668(int a1, unsigned __int8 a2);
void *__cdecl sub_8050691(int a1);
void __cdecl __noreturn sub_80506CE(int a1, int a2);
void *__cdecl sub_805076F(signed int a1, int a2, int a3, int a4);
void *__cdecl sub_805079F(signed int a1, int a2, int a3, int a4, size_t a5);
void *__cdecl sub_80508A9(signed int a1, int a2, size_t a3);
void *__cdecl sub_80508F4(signed int a1, int a2);
void *__cdecl sub_8050916(int a1);
int __cdecl sub_8050931(int fd); // idb
int __cdecl sub_8050964(FILE *stream, int, int, int, int, int); // idb
int __cdecl sub_8050EF7(FILE *stream, int, int, int, int); // idb
int sub_8050F83(FILE *stream, int a2, int a3, int a4, ...);
void *__cdecl sub_8051096(void *ptr, int a2, int a3);
void *__cdecl sub_8051146(size_t size);
void *__cdecl sub_805116B(size_t size);
void *__cdecl sub_8051195(void *ptr, size_t size);
void *__cdecl sub_805120D(void *ptr, int a2);
void *__cdecl sub_8051259(size_t nmemb, size_t size);
void *__cdecl sub_8051296(void *src, size_t n);
void __noreturn sub_80512F4();
void __cdecl __noreturn sub_805133F(int errnum);
void __cdecl __noreturn sub_8051419(void *s1, size_t n, void *s2, int); // idb
int sub_8051492(); // weak
signed int __cdecl sub_8051502(unsigned int *a1, unsigned int a2);
int __cdecl sub_8051546(unsigned int *a1, unsigned int a2, int a3);
int __cdecl sub_805157C(char *nptr, int, int base, int, char *s); // idb
int __cdecl sub_80519B0(FILE *stream); // idb
int __cdecl sub_8051AB5(int fd, int cmd, char); // idb
int __cdecl sub_8051C2C(FILE *stream); // idb
int __cdecl sub_8051C65(FILE *fp); // idb
int __cdecl sub_8051CA5(FILE *stream, int, int, int); // idb
size_t __cdecl sub_8051D8C(wchar_t *pwc, char *s, size_t n, mbstate_t *p);
int __cdecl sub_8051DFE(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_8051E7C(FILE *fp); // idb
void *sub_8051EFD();
char *sub_8052461();
int __cdecl sub_805253A(char *s, int, char *s2, int); // idb
int __cdecl sub_8052600(void *s1, size_t n, void *s2, int); // idb
int __cdecl sub_80526D2(void *s1, size_t n, void *s2, int); // idb
int __cdecl sub_8052929(int a1);
int __cdecl sub_80529E7(int a1);
int __stdcall sub_8052BC2(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_8052C34(_DWORD); // weak
int __stdcall sub_8052CB5(_DWORD); // weak
int __stdcall sub_8052D42(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __fastcall sub_8052DB0(_DWORD, _DWORD); // weak
int sub_8052E1A(void); // weak
int sub_8052EA3(void); // weak
int __stdcall sub_8052F2E(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_8052F9A(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int sub_805300C(void); // weak
int __stdcall sub_8053080(_DWORD); // weak
int (**sub_8053090())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN locret_804970D; // weak
_UNKNOWN locret_8049BC7; // weak
_UNKNOWN locret_8049E2A; // weak
_UNKNOWN locret_8049F50; // weak
_UNKNOWN locret_804A207; // weak
_UNKNOWN loc_804A4F1; // weak
_UNKNOWN loc_804A52F; // weak
_UNKNOWN loc_804A611; // weak
_UNKNOWN loc_804A8B6; // weak
_UNKNOWN loc_804A913; // weak
_UNKNOWN loc_804A947; // weak
_UNKNOWN loc_804A94C; // weak
_UNKNOWN loc_804A97D; // weak
_UNKNOWN locret_804AA1F; // weak
_UNKNOWN loc_804AAF8; // weak
_UNKNOWN locret_804AC07; // weak
_UNKNOWN loc_804AC82; // weak
_UNKNOWN loc_804ACD5; // weak
_UNKNOWN loc_804AD03; // weak
_UNKNOWN loc_804AD07; // weak
_UNKNOWN loc_804AD25; // weak
_UNKNOWN loc_804AE7D; // weak
_UNKNOWN loc_804AF4B; // weak
_UNKNOWN loc_804AF6E; // weak
_UNKNOWN loc_804B30B; // weak
_UNKNOWN loc_804B33E; // weak
_UNKNOWN loc_804B392; // weak
_UNKNOWN loc_804B469; // weak
_UNKNOWN locret_804B4B0; // weak
_UNKNOWN loc_804B4B4; // weak
_UNKNOWN loc_804B858; // weak
_UNKNOWN loc_804B8E6; // weak
_UNKNOWN loc_804BA04; // weak
_UNKNOWN locret_804BA58; // weak
_UNKNOWN loc_804BA5C; // weak
_UNKNOWN loc_804BABF; // weak
_UNKNOWN loc_804BACF; // weak
_UNKNOWN loc_804BBA3; // weak
_UNKNOWN loc_804BE27; // weak
_UNKNOWN loc_804BE99; // weak
_UNKNOWN loc_804BEB6; // weak
_UNKNOWN loc_804BEC4; // weak
_UNKNOWN loc_804BEE5; // weak
_UNKNOWN loc_804BF97; // weak
_UNKNOWN loc_804BFE9; // weak
_UNKNOWN loc_804C0B2; // weak
_UNKNOWN loc_804C0CF; // weak
_UNKNOWN loc_804C0FD; // weak
_UNKNOWN loc_804C159; // weak
_UNKNOWN loc_804C18C; // weak
_UNKNOWN loc_804C1E0; // weak
_UNKNOWN locret_804C341; // weak
_UNKNOWN loc_804C345; // weak
_UNKNOWN loc_804C397; // weak
_UNKNOWN loc_804C44B; // weak
_UNKNOWN loc_804C4E5; // weak
_UNKNOWN loc_804C54B; // weak
_UNKNOWN loc_804C573; // weak
_UNKNOWN loc_804C5B9; // weak
_UNKNOWN loc_804C5C9; // weak
_UNKNOWN loc_804C69C; // weak
_UNKNOWN locret_804C6E3; // weak
_UNKNOWN loc_804C6E7; // weak
_UNKNOWN loc_804C81F; // weak
_UNKNOWN loc_804C871; // weak
_UNKNOWN loc_804C875; // weak
_UNKNOWN loc_804C939; // weak
_UNKNOWN loc_804C9A4; // weak
_UNKNOWN loc_804C9AE; // weak
_UNKNOWN loc_804C9DD; // weak
_UNKNOWN loc_804CA01; // weak
_UNKNOWN loc_804CA46; // weak
_UNKNOWN loc_804CAA1; // weak
_UNKNOWN loc_804CAA6; // weak
_UNKNOWN locret_804CB84; // weak
_UNKNOWN loc_804CB88; // weak
_UNKNOWN loc_804CBD8; // weak
_UNKNOWN loc_804CD34; // weak
_UNKNOWN loc_804D1FD; // weak
_UNKNOWN loc_804D259; // weak
_UNKNOWN loc_804D28C; // weak
_UNKNOWN loc_804D2DE; // weak
_UNKNOWN locret_804D2F5; // weak
_UNKNOWN loc_804D2F9; // weak
_UNKNOWN loc_804D3D6; // weak
_UNKNOWN loc_804D409; // weak
_UNKNOWN loc_804D45D; // weak
_UNKNOWN loc_804D4AF; // weak
_UNKNOWN loc_804D5CD; // weak
_UNKNOWN loc_804D600; // weak
_UNKNOWN loc_804D654; // weak
_UNKNOWN locret_804D78B; // weak
_UNKNOWN loc_804D78F; // weak
_UNKNOWN loc_804D7E1; // weak
_UNKNOWN loc_804D876; // weak
_UNKNOWN loc_804D8A6; // weak
_UNKNOWN loc_804D9DA; // weak
_UNKNOWN loc_804D9EE; // weak
_UNKNOWN loc_804DB55; // weak
_UNKNOWN loc_804DB61; // weak
_UNKNOWN loc_804DD3D; // weak
_UNKNOWN loc_804DD61; // weak
_UNKNOWN loc_804DD77; // weak
_UNKNOWN loc_804EA97; // weak
_UNKNOWN loc_804EAC7; // weak
_UNKNOWN loc_804EADE; // weak
_UNKNOWN loc_804EAE2; // weak
_UNKNOWN loc_804EB71; // weak
_UNKNOWN loc_804EBB5; // weak
_UNKNOWN loc_804EBBF; // weak
_UNKNOWN loc_804EC4C; // weak
_UNKNOWN loc_804ECFA; // weak
_UNKNOWN loc_804ECFF; // weak
_UNKNOWN loc_804ED37; // weak
_UNKNOWN loc_804F052; // weak
_UNKNOWN loc_804F163; // weak
_UNKNOWN locret_804F184; // weak
_UNKNOWN loc_804F292; // weak
_UNKNOWN loc_804F2BE; // weak
_UNKNOWN loc_804F37D; // weak
_UNKNOWN loc_804F4F1; // weak
_UNKNOWN loc_804F531; // weak
_UNKNOWN loc_804F553; // weak
_UNKNOWN loc_804F65E; // weak
_UNKNOWN loc_804F6FC; // weak
_UNKNOWN loc_804F721; // weak
_UNKNOWN loc_804F730; // weak
_UNKNOWN loc_804F741; // weak
_UNKNOWN loc_804F930; // weak
_UNKNOWN loc_804F96E; // weak
_UNKNOWN loc_804FA6B; // weak
_UNKNOWN loc_804FAB4; // weak
_UNKNOWN loc_804FBD2; // weak
_UNKNOWN loc_804FC07; // weak
_UNKNOWN loc_804FC39; // weak
_UNKNOWN loc_804FC5D; // weak
_UNKNOWN loc_804FC62; // weak
_UNKNOWN loc_804FCE2; // weak
_UNKNOWN loc_804FD9A; // weak
_UNKNOWN loc_804FDBF; // weak
_UNKNOWN loc_804FDC4; // weak
_UNKNOWN loc_804FDFC; // weak
_UNKNOWN loc_804FE1B; // weak
_UNKNOWN loc_804FE64; // weak
_UNKNOWN loc_804FE82; // weak
_UNKNOWN loc_804FE95; // weak
_UNKNOWN loc_804FED8; // weak
_UNKNOWN loc_805004B; // weak
_UNKNOWN loc_80503B4; // weak
_UNKNOWN loc_80503BF; // weak
_UNKNOWN loc_80509CB; // weak
_UNKNOWN loc_8050E8A; // weak
_UNKNOWN loc_8050F13; // weak
_UNKNOWN loc_8050F17; // weak
_UNKNOWN loc_8050F53; // weak
_UNKNOWN loc_80510C9; // weak
_UNKNOWN loc_80510E6; // weak
_UNKNOWN loc_80511FD; // weak
_UNKNOWN loc_8051208; // weak
_UNKNOWN loc_805146B; // weak
_UNKNOWN loc_80515E8; // weak
_UNKNOWN loc_805162C; // weak
_UNKNOWN loc_80516C9; // weak
_UNKNOWN loc_80516E6; // weak
_UNKNOWN loc_80517CC; // weak
_UNKNOWN loc_805197E; // weak
_UNKNOWN loc_8051A10; // weak
_UNKNOWN loc_8051A62; // weak
_UNKNOWN loc_8051A7B; // weak
_UNKNOWN loc_8051B85; // weak
_UNKNOWN loc_8051CE0; // weak
_UNKNOWN loc_8051D6A; // weak
_UNKNOWN loc_8051E75; // weak
_UNKNOWN loc_8052132; // weak
_UNKNOWN loc_805214F; // weak
_UNKNOWN loc_8052428; // weak
_UNKNOWN loc_8052436; // weak
_UNKNOWN loc_8052495; // weak
_UNKNOWN loc_805249C; // weak
_UNKNOWN loc_805251A; // weak
_UNKNOWN loc_80525DC; // weak
_UNKNOWN loc_80525E7; // weak
_UNKNOWN loc_80526CD; // weak
_UNKNOWN unk_80531A0; // weak
char s = '\0'; // idb
char aIIgnoreCaseIgn[152] = "  -i, --ignore-case  ignore differences in case when comparing fields\n  -j FIELD          equivalent to '-1 FIELD -2 FIELD'\n  -o FORMAT         obey FOR"; // idb
_UNKNOWN unk_8054022; // weak
_UNKNOWN unk_8054025; // weak
_UNKNOWN unk_8054987; // weak
_UNKNOWN unk_80551BC; // weak
_UNKNOWN unk_80551BF; // weak
int dword_8055EF4 = 4021747711; // weak
_UNKNOWN unk_8056204; // weak
_UNKNOWN unk_8056207; // weak
int (*off_8057ECC[2])() = { &sub_8049240, &sub_8049220 }; // weak
int (*off_8057ED0)() = &sub_8049220; // weak
int (*dword_8058008)(void) = NULL; // weak
int dword_8058114 = 0; // weak
int dword_8058128 = 0; // weak
int dword_805813C = 0; // weak
int dword_8058150 = 0; // weak
int dword_8058164 = 0; // weak
int dword_8058178 = 0; // weak
int dword_805818C = 0; // weak
int dword_80581A0 = 0; // weak
int dword_80581B4 = 0; // weak
int dword_80581C8 = 0; // weak
int dword_80581DC = 0; // weak
int dword_8058218 = 0; // weak
int dword_805821C = 4294967295; // weak
int dword_8058220 = 4294967295; // weak
void *off_8058224 = &unk_80587D3; // weak
int c = 4294967295; // idb
char byte_805822C = '\n'; // weak
int status = 1; // idb
int dword_8058254 = 1; // weak
int dword_8058258 = 256; // weak
void *off_805825C = &unk_8058863; // weak
int *off_8058260 = &dword_8058258; // weak
_UNKNOWN unk_8058274; // weak
_UNKNOWN unk_8058290; // weak
_UNKNOWN unk_8058293; // weak
_UNKNOWN unk_8058298; // weak
_UNKNOWN unk_805829B; // weak
_UNKNOWN unk_80582A4; // weak
_UNKNOWN unk_80582A7; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
FILE *stdout; // idb
char byte_805830C; // weak
_UNKNOWN unk_8058444; // weak
char byte_8058527; // weak
int dword_8058793[]; // weak
int dword_805879B[]; // weak
int dword_805879F[2]; // idb
char *dword_80587AB; // idb
void *ptr[2]; // idb
char byte_80587BC; // weak
char byte_80587BD; // weak
char byte_80587BE; // weak
char byte_80587BF; // weak
char byte_80587C0[]; // weak
char byte_80587C1; // weak
char *s1; // idb
char byte_80587C7; // weak
int dword_80587CB; // weak
int dword_80587CF; // weak
int dword_80587DB; // weak
int dword_80587DF; // weak
_UNKNOWN unk_80587E3; // weak
char byte_80587FC; // weak
int dword_80587FF; // weak
char byte_8058803; // weak
int dword_8058807; // weak
int dword_8058823; // weak
int dword_8058827; // weak
int dword_805882B; // weak
int dword_805882F; // weak
int dword_8058833; // weak
int dword_8058837; // weak
int dword_805883B; // weak
int dword_805883F; // weak
int dword_8058843; // weak
int dword_8058847; // weak
int dword_805884B; // weak
int dword_805884F; // weak
_UNKNOWN unk_8058863; // weak
int dword_8058963; // weak
int dword_8058967; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (08048D18) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 8049140: using guessed type int _gmon_start__(void);

//----- (08048D40) --------------------------------------------------------
int sub_8048D40()
{
  return dword_8058008();
}
// 8058008: using guessed type int (*dword_8058008)(void);

//----- (08049150) --------------------------------------------------------
#error "8049153: positive sp value has been found (funcsize=2)"

//----- (08049183) --------------------------------------------------------
void sub_8049183()
{
  ;
}

//----- (080491A0) --------------------------------------------------------
void sub_80491A0()
{
  ;
}

//----- (080491B0) --------------------------------------------------------
int sub_80491B0()
{
  int result; // eax

  result = &unk_80582A7 - &unk_80582A4;
  if ( (unsigned int)(&unk_80582A7 - &unk_80582A4) > 6 )
    result = 0;
  return result;
}
// 80491B0: could not find valid save-restore pair for ebp

//----- (08049220) --------------------------------------------------------
int sub_8049220()
{
  int result; // eax

  if ( !byte_805830C )
  {
    result = sub_80491B0();
    byte_805830C = 1;
  }
  return result;
}
// 8049220: could not find valid save-restore pair for ebp
// 805830C: using guessed type char byte_805830C;

//----- (08049240) --------------------------------------------------------
int sub_8049240()
{
  return 0;
}
// 8049240: could not find valid save-restore pair for ebp

//----- (0804929F) --------------------------------------------------------
void sub_804929F()
{
  ;
}

//----- (080492BA) --------------------------------------------------------
void sub_80492BA()
{
  ;
}

//----- (080492CA) --------------------------------------------------------
int sub_80492CA()
{
  int result; // eax

  result = &unk_8058293 - &unk_8058290;
  if ( (unsigned int)(&unk_8058293 - &unk_8058290) > 6 )
    result = 0;
  return result;
}
// 80492CA: could not find valid save-restore pair for ebp

//----- (080493AC) --------------------------------------------------------
void sub_80493AC()
{
  ;
}

//----- (080493C7) --------------------------------------------------------
void sub_80493C7()
{
  ;
}

//----- (080493D7) --------------------------------------------------------
int sub_80493D7()
{
  int result; // eax

  result = &unk_8058293 - &unk_8058290;
  if ( (unsigned int)(&unk_8058293 - &unk_8058290) > 6 )
    result = 0;
  return result;
}
// 80493D7: could not find valid save-restore pair for ebp

//----- (080494B9) --------------------------------------------------------
void sub_80494B9()
{
  ;
}

//----- (080494D4) --------------------------------------------------------
void sub_80494D4()
{
  ;
}

//----- (080494E4) --------------------------------------------------------
int sub_80494E4()
{
  int result; // eax

  result = &unk_8058293 - &unk_8058290;
  if ( (unsigned int)(&unk_8058293 - &unk_8058290) > 6 )
    result = 0;
  return result;
}
// 80494E4: could not find valid save-restore pair for ebp

//----- (080495C6) --------------------------------------------------------
void sub_80495C6()
{
  ;
}

//----- (080495E1) --------------------------------------------------------
void sub_80495E1()
{
  ;
}

//----- (080495F1) --------------------------------------------------------
signed int sub_80495F1()
{
  return 3;
}
// 80495F1: could not find valid save-restore pair for ebp

//----- (080496D3) --------------------------------------------------------
void sub_80496D3()
{
  ;
}

//----- (080496EE) --------------------------------------------------------
void sub_80496EE()
{
  ;
}

//----- (080496FE) --------------------------------------------------------
int sub_80496FE()
{
  int result; // eax
  int (__stdcall *v1)(int *, int, int, int, int, int); // eax
  int v2; // [esp+4h] [ebp-18h]
  int v3; // [esp+8h] [ebp-14h]
  int v4; // [esp+Ch] [ebp-10h]
  int v5; // [esp+10h] [ebp-Ch]
  int v6; // [esp+14h] [ebp-8h]
  int v7; // [esp+18h] [ebp-4h]

  result = &unk_8058444 - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_8058444 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
  {
    v7 = 0;
    dword_8058164 = (int)&locret_804970D;
    v1 = (int (__stdcall *)(int *, int, int, int, int, int))sub_8052EA3();
    result = v1(&program_invocation_short_name, v2, v3, v4, v5, v6);
  }
  return result;
}
// 8052EA3: using guessed type int sub_8052EA3(void);
// 8058164: using guessed type int dword_8058164;
// 80582C0: using guessed type int program_invocation_short_name;

//----- (080497F9) --------------------------------------------------------
void sub_80497F9()
{
  ;
}

//----- (08049814) --------------------------------------------------------
void sub_8049814()
{
  ;
}

//----- (08049824) --------------------------------------------------------
int sub_8049824()
{
  int result; // eax

  result = &unk_8058293 - &unk_8058290;
  if ( (unsigned int)(&unk_8058293 - &unk_8058290) > 6 )
    result = 0;
  return result;
}
// 8049824: could not find valid save-restore pair for ebp

//----- (0804988B) --------------------------------------------------------
int __usercall sub_804988B@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_8058290, a1);
}

//----- (08049922) --------------------------------------------------------
void sub_8049922()
{
  ;
}

//----- (0804993D) --------------------------------------------------------
void sub_804993D()
{
  ;
}

//----- (0804994D) --------------------------------------------------------
int sub_804994D()
{
  int result; // eax

  result = &unk_8058293 - &unk_8058290;
  if ( (unsigned int)(&unk_8058293 - &unk_8058290) > 6 )
    result = 0;
  return result;
}
// 804994D: could not find valid save-restore pair for ebp

//----- (080499AB) --------------------------------------------------------
int sub_80499AB()
{
  return nullsub_4();
}
// 80499AB: could not find valid save-restore pair for ebp
// 80499AA: using guessed type int nullsub_4(void);

//----- (080499F0) --------------------------------------------------------
int sub_80499F0()
{
  int result; // eax

  result = sub_804994D();
  byte_8058527 = 1;
  return result;
}
// 8058527: using guessed type char byte_8058527;

//----- (08049A64) --------------------------------------------------------
void sub_8049A64()
{
  ;
}

//----- (08049A7F) --------------------------------------------------------
void sub_8049A7F()
{
  ;
}

//----- (08049A8F) --------------------------------------------------------
int sub_8049A8F()
{
  int result; // eax

  result = &unk_8056207 - &unk_8056204;
  if ( (unsigned int)(&unk_8056207 - &unk_8056204) > 6 )
    result = 0;
  return result;
}
// 8049A8F: could not find valid save-restore pair for ebp

//----- (08049B41) --------------------------------------------------------
int __usercall sub_8049B41@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  a1(&dword_8055EF4);
  return 0;
}
// 8055EF4: using guessed type int dword_8055EF4;

//----- (08049B8D) --------------------------------------------------------
void sub_8049B8D()
{
  ;
}

//----- (08049BA8) --------------------------------------------------------
void sub_8049BA8()
{
  ;
}

//----- (08049BB8) --------------------------------------------------------
int sub_8049BB8()
{
  int result; // eax
  int (__stdcall *v1)(void *, int, int, int, int, int); // eax
  int v2; // [esp+4h] [ebp-18h]
  int v3; // [esp+8h] [ebp-14h]
  int v4; // [esp+Ch] [ebp-10h]
  int v5; // [esp+10h] [ebp-Ch]
  int v6; // [esp+14h] [ebp-8h]
  int v7; // [esp+18h] [ebp-4h]

  result = &unk_8058293 - &unk_8058290;
  if ( (unsigned int)(&unk_8058293 - &unk_8058290) > 6 )
  {
    v7 = 0;
    dword_8058128 = (int)&locret_8049BC7;
    v1 = (int (__stdcall *)(void *, int, int, int, int, int))sub_805300C();
    result = v1(&unk_8058290, v2, v3, v4, v5, v6);
  }
  return result;
}
// 805300C: using guessed type int sub_805300C(void);
// 8058128: using guessed type int dword_8058128;

//----- (08049CB3) --------------------------------------------------------
void sub_8049CB3()
{
  ;
}

//----- (08049CCE) --------------------------------------------------------
void sub_8049CCE()
{
  ;
}

//----- (08049CDE) --------------------------------------------------------
int sub_8049CDE()
{
  int result; // eax

  result = &unk_8058293 - &unk_8058290;
  if ( (unsigned int)(&unk_8058293 - &unk_8058290) > 6 )
    result = 0;
  return result;
}
// 8049CDE: could not find valid save-restore pair for ebp

//----- (08049D3C) --------------------------------------------------------
int sub_8049D3C()
{
  return nullsub_7();
}
// 8049D3C: could not find valid save-restore pair for ebp
// 8049D3B: using guessed type int nullsub_7(void);

//----- (08049DF0) --------------------------------------------------------
void sub_8049DF0()
{
  ;
}

//----- (08049E0B) --------------------------------------------------------
void sub_8049E0B()
{
  ;
}

//----- (08049E1B) --------------------------------------------------------
#error "8049E48: call analysis failed (funcsize=23)"

//----- (08049F16) --------------------------------------------------------
void sub_8049F16()
{
  ;
}

//----- (08049F31) --------------------------------------------------------
void sub_8049F31()
{
  ;
}

//----- (08049F41) --------------------------------------------------------
int __fastcall sub_8049F41(int a1, int a2)
{
  int result; // eax
  int (__stdcall *v3)(void *, int, int, int, int, int); // eax
  int v4; // [esp+4h] [ebp-18h]
  int v5; // [esp+8h] [ebp-14h]
  int v6; // [esp+Ch] [ebp-10h]
  int v7; // [esp+10h] [ebp-Ch]
  int v8; // [esp+14h] [ebp-8h]
  int v9; // [esp+18h] [ebp-4h]

  result = &unk_80551BF - &unk_80551BC;
  if ( (unsigned int)(&unk_80551BF - &unk_80551BC) > 6 )
  {
    v9 = 0;
    dword_805818C = (int)&locret_8049F50;
    v3 = (int (__stdcall *)(void *, int, int, int, int, int))sub_8052DB0(a1, a2);
    result = v3(&unk_80551BC, v4, v5, v6, v7, v8);
  }
  return result;
}
// 8052DB0: using guessed type int __fastcall sub_8052DB0(_DWORD, _DWORD);
// 805818C: using guessed type int dword_805818C;

//----- (08049FC1) --------------------------------------------------------
int __usercall sub_8049FC1@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_80551BC, a1);
}

//----- (0804A058) --------------------------------------------------------
void sub_804A058()
{
  ;
}

//----- (0804A073) --------------------------------------------------------
void sub_804A073()
{
  ;
}

//----- (0804A083) --------------------------------------------------------
signed int sub_804A083()
{
  return 4;
}
// 804A083: could not find valid save-restore pair for ebp

//----- (0804A11D) --------------------------------------------------------
#error "804A120: positive sp value has been found (funcsize=2)"

//----- (0804A1AD) --------------------------------------------------------
void sub_804A1AD()
{
  ;
}

//----- (0804A1D8) --------------------------------------------------------
void sub_804A1D8()
{
  ;
}

//----- (0804A1F8) --------------------------------------------------------
#error "804A225: call analysis failed (funcsize=23)"

//----- (0804A312) --------------------------------------------------------
void sub_804A312()
{
  ;
}

//----- (0804A32D) --------------------------------------------------------
void sub_804A32D()
{
  ;
}

//----- (0804A33D) --------------------------------------------------------
signed int sub_804A33D()
{
  return 4;
}
// 804A33D: could not find valid save-restore pair for ebp

//----- (0804A39B) --------------------------------------------------------
#error "804A3B8: call analysis failed (funcsize=19)"

//----- (0804A421) --------------------------------------------------------
#error "804A395: call analysis failed (funcsize=23)"

//----- (0804A43B) --------------------------------------------------------
int __cdecl sub_804A43B(unsigned __int8 a1)
{
  return (*__ctype_b_loc())[a1] & 1 || a1 == 10;
}

//----- (0804A47A) --------------------------------------------------------
int __cdecl sub_804A47A(char *s1)
{
  bool v1; // zf
  void *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  int v8; // [esp+0h] [ebp-68h]
  const char *v9; // [esp+1Ch] [ebp-4Ch]
  const char *v10; // [esp+24h] [ebp-44h]
  const char *v11; // [esp+28h] [ebp-40h]
  const char *v12; // [esp+2Ch] [ebp-3Ch]
  const char *v13; // [esp+30h] [ebp-38h]
  const char *v14; // [esp+34h] [ebp-34h]
  const char *v15; // [esp+38h] [ebp-30h]
  const char *v16; // [esp+3Ch] [ebp-2Ch]
  const char *v17; // [esp+40h] [ebp-28h]
  const char *v18; // [esp+44h] [ebp-24h]
  const char *v19; // [esp+48h] [ebp-20h]
  const char *v20; // [esp+4Ch] [ebp-1Ch]
  const char *v21; // [esp+50h] [ebp-18h]
  const char *v22; // [esp+54h] [ebp-14h]
  int v23; // [esp+58h] [ebp-10h]
  int v24; // [esp+5Ch] [ebp-Ch]

  v11 = (const char *)&unk_80531A0;
  v12 = "test invocation";
  v13 = "coreutils";
  v14 = "Multi-call invocation";
  v15 = "sha224sum";
  v16 = "sha2 utilities";
  v17 = "sha256sum";
  v18 = "sha2 utilities";
  v19 = "sha384sum";
  v20 = "sha2 utilities";
  v21 = "sha512sum";
  v22 = "sha2 utilities";
  v23 = 0;
  v24 = 0;
  v9 = s1;
  if ( &unk_80531A0 )
  {
    v1 = strcmp(s1, v11) == 0;
    v2 = &loc_804A52F;
    if ( !v1 )
      v2 = &loc_804A4F1;
    dword_8058178 = (int)v2;
    sub_8052E1A();
  }
  if ( v12 )
    v9 = v12;
  v3 = gettext("\n%s online help: <%s>\n");
  printf(v3, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  v10 = setlocale(5, 0);
  if ( v10 && strncmp(v10, "en_", 3u) )
  {
    v4 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
    printf(v4, s1);
  }
  v5 = gettext("Full documentation at: <%s%s>\n");
  printf(v5, "http://www.gnu.org/software/coreutils/", s1);
  if ( v9 == s1 )
  {
    dword_80581C8 = (int)&loc_804A611;
    sub_8052C34(v8);
  }
  v6 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  return printf(v6, v9, &s);
}
// 8052C34: using guessed type int __stdcall sub_8052C34(_DWORD);
// 8052E1A: using guessed type int sub_8052E1A(void);
// 8058178: using guessed type int dword_8058178;
// 80581C8: using guessed type int dword_80581C8;

//----- (0804A636) --------------------------------------------------------
void __cdecl __noreturn sub_804A636(int status)
{
  int v1; // ebx
  char *v2; // eax
  int v3; // ebx
  char *v4; // eax
  FILE *v5; // ebx
  char *v6; // eax
  FILE *v7; // ebx
  char *v8; // eax
  FILE *v9; // ebx
  char *v10; // eax
  FILE *v11; // ebx
  char *v12; // eax
  FILE *v13; // ebx
  char *v14; // eax
  FILE *v15; // ebx
  char *v16; // eax
  FILE *v17; // ebx
  char *v18; // eax
  FILE *v19; // ebx
  char *v20; // eax
  FILE *v21; // ebx
  char *v22; // eax

  if ( status )
  {
    v1 = dword_8058807;
    v2 = gettext("Try '%s --help' for more information.\n");
    fprintf(stderr, v2, v1);
  }
  else
  {
    v3 = dword_8058807;
    v4 = gettext("Usage: %s [OPTION]... FILE1 FILE2\n");
    printf(v4, v3);
    v5 = stdout;
    v6 = gettext(
           "For each pair of input lines with identical join fields, write a line to\n"
           "standard output.  The default join field is the first, delimited by blanks.\n");
    fputs_unlocked(v6, v5);
    v7 = stdout;
    v8 = gettext("\nWhen FILE1 or FILE2 (not both) is -, read standard input.\n");
    fputs_unlocked(v8, v7);
    v9 = stdout;
    v10 = gettext(
            "\n"
            "  -a FILENUM        also print unpairable lines from file FILENUM, where\n"
            "                      FILENUM is 1 or 2, corresponding to FILE1 or FILE2\n"
            "  -e EMPTY          replace missing input fields with EMPTY\n");
    fputs_unlocked(v10, v9);
    v11 = stdout;
    v12 = gettext(aIIgnoreCaseIgn);
    fputs_unlocked(v12, v11);
    v13 = stdout;
    v14 = gettext(
            "  -v FILENUM        like -a FILENUM, but suppress joined output lines\n"
            "  -1 FIELD          join on this FIELD of file 1\n"
            "  -2 FIELD          join on this FIELD of file 2\n"
            "  --check-order     check that the input is correctly sorted, even\n"
            "                      if all input lines are pairable\n"
            "  --nocheck-order   do not check that the input is correctly sorted\n"
            "  --header          treat the first line in each file as field headers,\n"
            "                      print them without trying to pair them\n");
    fputs_unlocked(v14, v13);
    v15 = stdout;
    v16 = gettext("  -z, --zero-terminated     line delimiter is NUL, not newline\n");
    fputs_unlocked(v16, v15);
    v17 = stdout;
    v18 = gettext("      --help     display this help and exit\n");
    fputs_unlocked(v18, v17);
    v19 = stdout;
    v20 = gettext("      --version  output version information and exit\n");
    fputs_unlocked(v20, v19);
    v21 = stdout;
    v22 = gettext(
            "\n"
            "Unless -t CHAR is given, leading blanks separate fields and are ignored,\n"
            "else fields are separated by CHAR.  Any FIELD is a field number counted\n"
            "from 1.  FORMAT is one or more comma or blank separated specifications,\n"
            "each being 'FILENUM.FIELD' or '0'.  Default FORMAT outputs the join field,\n"
            "the remaining fields from FILE1, the remaining fields from FILE2, all\n"
            "separated by CHAR.  If FORMAT is the keyword 'auto', then the first\n"
            "line of each file determines the number of fields output for each line.\n"
            "\n"
            "Important: FILE1 and FILE2 must be sorted on the join fields.\n"
            "E.g., use \"sort -k 1b,1\" if 'join' has no options,\n"
            "or use \"join -t ''\" if 'sort' has no options.\n"
            "Note, comparisons honor the rules specified by 'LC_COLLATE'.\n"
            "If the input is not sorted and some lines cannot be joined, a\n"
            "warning message will be given.\n");
    fputs_unlocked(v22, v21);
    sub_804A47A("join");
  }
  exit(status);
}
// 8048F50: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8058807: using guessed type int dword_8058807;

//----- (0804A7C3) --------------------------------------------------------
int __cdecl sub_804A7C3(int a1, int a2, int a3)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 12) >= *(_DWORD *)(a1 + 16) )
    *(_DWORD *)(a1 + 20) = sub_8051096(*(void **)(a1 + 20), a1 + 16, 8);
  *(_DWORD *)(8 * *(_DWORD *)(a1 + 12) + *(_DWORD *)(a1 + 20)) = a2;
  *(_DWORD *)(8 * *(_DWORD *)(a1 + 12) + *(_DWORD *)(a1 + 20) + 4) = a3;
  result = a1;
  ++*(_DWORD *)(a1 + 12);
  return result;
}

//----- (0804A84F) --------------------------------------------------------
#error "804A942: call analysis failed (funcsize=145)"

//----- (0804AA21) --------------------------------------------------------
int __cdecl sub_804AA21(int a1)
{
  int result; // eax

  if ( a1 )
  {
    free(*(void **)(a1 + 20));
    *(_DWORD *)(a1 + 20) = 0;
    free(*(void **)(a1 + 8));
    result = a1;
    *(_DWORD *)(a1 + 8) = 0;
  }
  return result;
}

//----- (0804AA61) --------------------------------------------------------
#error "804AAE5: call analysis failed (funcsize=95)"

//----- (0804AC09) --------------------------------------------------------
int __cdecl sub_804AC09(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // edx
  int v5; // ecx
  int v6; // eax
  bool v7; // zf
  void *v8; // eax
  void *v9; // eax
  int v10; // ST34_4
  int v11; // ebx
  int v12; // esi
  char *v13; // edi
  char *v14; // eax
  int v15; // [esp+0h] [ebp-58h]
  int v16; // [esp+38h] [ebp-20h]

  result = dword_80587DF;
  if ( dword_80587DF != 2 )
  {
    if ( dword_80587DF == 1 || (result = (unsigned __int8)byte_80587BF, byte_80587BF) )
    {
      result = (unsigned __int8)byte_80587C0[a3 - 1] ^ 1;
      if ( byte_80587C0[a3 - 1] != 1 )
      {
        if ( a3 == 1 )
        {
          dword_8058164 = (int)&loc_804AC82;
          sub_8052EA3();
        }
        result = sub_804AA61(a1, a2, dword_8058220, dword_8058220);
        if ( result > 0 )
        {
          v6 = *(_DWORD *)(a2 + 4);
          v16 = v6;
          v7 = v6 == 0;
          v8 = &loc_804ACD5;
          if ( v7 )
            v8 = &loc_804AD07;
          dword_805818C = (int)v8;
          sub_8052DB0(v5, v4);
          v9 = &loc_804AD03;
          if ( *(_BYTE *)(v16 - 1 + *(_DWORD *)(a2 + 8)) != 10 )
            v9 = &loc_804AD07;
          dword_8058178 = (int)v9;
          sub_8052E1A();
          if ( v16 - 1 >= 0 )
          {
            dword_8058114 = (int)&loc_804AD25;
            sub_8053080(v15);
          }
          v10 = *(_DWORD *)(a2 + 8);
          v11 = dword_805879B[2 * (a3 - 1)];
          v12 = dword_805879F[2 * (a3 - 1)];
          v13 = (&dword_80587AB)[a3 - 1];
          v14 = gettext("%s:%llu: is not sorted: %.*s");
          error(dword_80587DF == 1, 0, v14, v13, v11, v12, 0x7FFFFFFF, v10);
          result = a3 - 1;
          byte_80587C0[a3 - 1] = 1;
        }
      }
    }
  }
  return result;
}
// 8052DB0: using guessed type int __fastcall sub_8052DB0(_DWORD, _DWORD);
// 8052E1A: using guessed type int sub_8052E1A(void);
// 8052EA3: using guessed type int sub_8052EA3(void);
// 8053080: using guessed type int __stdcall sub_8053080(_DWORD);
// 8058114: using guessed type int dword_8058114;
// 8058164: using guessed type int dword_8058164;
// 8058178: using guessed type int dword_8058178;
// 805818C: using guessed type int dword_805818C;
// 805821C: using guessed type int dword_805821C;
// 8058220: using guessed type int dword_8058220;
// 805879B: using guessed type int dword_805879B[];
// 80587BF: using guessed type char byte_80587BF;
// 80587DF: using guessed type int dword_80587DF;

//----- (0804ADB7) --------------------------------------------------------
int __cdecl sub_804ADB7(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (0804ADC6) --------------------------------------------------------
void *__cdecl sub_804ADC6(_DWORD *a1)
{
  void *result; // eax

  result = sub_8051259(1u, 0x18u);
  *a1 = result;
  return result;
}

//----- (0804ADF0) --------------------------------------------------------
#error "804AE6A: call analysis failed (funcsize=115)"

//----- (0804AF89) --------------------------------------------------------
void sub_804AF89()
{
  unsigned int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; i <= 1; ++i )
  {
    if ( ptr[i] )
    {
      sub_804AA21((int)ptr[i]);
      free(ptr[i]);
    }
  }
}

//----- (0804AFD6) --------------------------------------------------------
_DWORD *__cdecl sub_804AFD6(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = a1;
  a1[2] = 0;
  return result;
}

//----- (0804AFF8) --------------------------------------------------------
int __cdecl sub_804AFF8(FILE *stream, int a2, int a3)
{
  unsigned int i; // [esp+0h] [ebp-Ch]

  if ( *(_DWORD *)a2 == *(_DWORD *)(a2 + 4) )
  {
    *(_DWORD *)(a2 + 8) = sub_8051096(*(void **)(a2 + 8), a2 + 4, 4);
    for ( i = *(_DWORD *)a2; *(_DWORD *)(a2 + 4) > i; ++i )
      *(_DWORD *)(4 * i + *(_DWORD *)(a2 + 8)) = 0;
  }
  if ( !(unsigned __int8)sub_804ADF0(stream, 4 * *(_DWORD *)a2 + *(_DWORD *)(a2 + 8), a3) )
    return 0;
  ++*(_DWORD *)a2;
  return 1;
}

//----- (0804B0C7) --------------------------------------------------------
int __cdecl sub_804B0C7(FILE *stream, int a2, int a3, int a4)
{
  if ( (_BYTE)a3 )
    *(_DWORD *)a2 = 0;
  return sub_804AFF8(stream, a2, a4);
}

//----- (0804B10B) --------------------------------------------------------
void __cdecl sub_804B10B(int a1)
{
  unsigned int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; *(_DWORD *)(a1 + 4) > i; ++i )
  {
    sub_804AA21(*(_DWORD *)(4 * i + *(_DWORD *)(a1 + 8)));
    free(*(void **)(4 * i + *(_DWORD *)(a1 + 8)));
  }
  free(*(void **)(a1 + 8));
}

//----- (0804B260) --------------------------------------------------------
#error "804B442: call analysis failed (funcsize=175)"

//----- (0804B7B2) --------------------------------------------------------
void __usercall sub_804B7B2(signed int *a1@<ebx>, FILE *stream, FILE *a3)
{
  int *v3; // edx
  int v4; // ecx
  int v5; // eax
  int v6; // eax
  void *v7; // eax
  void *v8; // eax
  char v9; // al
  unsigned int v10; // eax
  void *v11; // eax
  void *v12; // eax
  int v13; // ebx
  int v14; // edx
  int v15; // ecx
  int v16; // eax
  char v17; // al
  unsigned int v18; // eax
  void *v19; // eax
  char v20; // al
  void *v21; // eax
  unsigned int v22; // eax
  size_t v23; // eax
  bool v24; // zf
  void *v25; // eax
  int v26; // ST08_4
  int v27; // ebx
  signed int v28; // eax
  void *v29; // eax
  int v30; // eax
  int v31; // ecx
  void *v32; // eax
  unsigned int v33; // eax
  void *v34; // eax
  void *v35; // eax
  void *v36; // eax
  int v37; // eax
  char v38; // al
  void *v39; // eax
  void *v40; // eax
  char v41; // al
  unsigned int v42; // eax
  int v43; // eax
  void *v44; // eax
  size_t v45; // ST24_4
  void *v46; // eax
  size_t v47; // eax
  void *v48; // eax
  char v49; // al
  unsigned int v50; // eax
  size_t v51; // eax
  void *v52; // eax
  int v53; // ST08_4
  int v54; // ST0C_4
  int v55; // [esp-70h] [ebp-C8h]
  int v56; // [esp-6Ch] [ebp-C4h]
  int v57; // [esp-68h] [ebp-C0h]
  int v58; // [esp-64h] [ebp-BCh]
  int v59; // [esp-60h] [ebp-B8h]
  int v60; // [esp-5Ch] [ebp-B4h]
  int v61; // [esp-58h] [ebp-B0h]
  size_t v62; // [esp-54h] [ebp-ACh]
  size_t v63; // [esp-54h] [ebp-ACh]
  size_t v64; // [esp-54h] [ebp-ACh]
  int v65; // [esp-54h] [ebp-ACh]
  size_t v66; // [esp-54h] [ebp-ACh]
  size_t v67; // [esp-54h] [ebp-ACh]
  size_t v68; // [esp-54h] [ebp-ACh]
  int v69; // [esp-50h] [ebp-A8h]
  size_t v70; // [esp-50h] [ebp-A8h]
  size_t v71; // [esp-50h] [ebp-A8h]
  size_t v72; // [esp-50h] [ebp-A8h]
  int v73; // [esp-4Ch] [ebp-A4h]
  signed int **v74; // [esp-48h] [ebp-A0h]
  signed int *v75; // [esp-44h] [ebp-9Ch]
  int v76; // [esp-40h] [ebp-98h]
  unsigned int v77; // [esp-3Ch] [ebp-94h]
  _DWORD *v78; // [esp-38h] [ebp-90h]
  int v79; // [esp-34h] [ebp-8Ch]
  int v80; // [esp-30h] [ebp-88h]
  int v81; // [esp-2Ch] [ebp-84h]
  int v82; // [esp-28h] [ebp-80h]
  int v83; // [esp-24h] [ebp-7Ch]
  unsigned int v84; // [esp-20h] [ebp-78h]
  char v85; // [esp-1Dh] [ebp-75h]
  unsigned int v86; // [esp-1Ch] [ebp-74h]
  _DWORD *v87; // [esp-18h] [ebp-70h]
  _DWORD *v88; // [esp-14h] [ebp-6Ch]
  _DWORD *v89; // [esp-10h] [ebp-68h]
  int v90; // [esp-Ch] [ebp-64h]
  signed int *v91; // [esp-8h] [ebp-60h]
  signed int v92; // [esp-4h] [ebp-5Ch]
  int v93; // [esp+0h] [ebp-58h]
  unsigned int v94; // [esp+4h] [ebp-54h]
  unsigned int v95; // [esp+8h] [ebp-50h]
  char v96; // [esp+15h] [ebp-43h]
  char v97; // [esp+16h] [ebp-42h]
  char v98; // [esp+17h] [ebp-41h]
  void *ptr; // [esp+18h] [ebp-40h]
  unsigned int v100; // [esp+1Ch] [ebp-3Ch]
  int v101; // [esp+20h] [ebp-38h]
  int v102; // [esp+24h] [ebp-34h]
  void *v103; // [esp+28h] [ebp-30h]
  int v104; // [esp+2Ch] [ebp-2Ch]
  int v105; // [esp+30h] [ebp-28h]
  int v106; // [esp+34h] [ebp-24h]
  int v107; // [esp+38h] [ebp-20h]
  int *v108; // [esp+40h] [ebp-18h]
  int v109; // [esp+44h] [ebp-14h]
  size_t n; // [esp+4Ch] [ebp-Ch]
  int savedregs; // [esp+58h] [ebp+0h]

  sub_804E916(stream, 2);
  sub_804E916(a3, 2);
  sub_804AFD6(&v107);
  sub_804AFF8(stream, (int)&v107, 1);
  sub_804AFD6(&v109);
  sub_804AFF8(a3, (int)&v109, 2);
  if ( byte_80587C7 )
  {
    if ( v107 )
    {
      v5 = *(_DWORD *)(*v108 + 12);
      dword_80581B4 = (int)&loc_804B858;
      ((void (*)(void))sub_8052CB5)();
    }
    dword_80587CB = 0;
    if ( v109 )
      v6 = *(_DWORD *)(*(_DWORD *)n + 12);
    else
      v6 = 0;
    dword_80587CF = v6;
  }
  if ( !byte_80587FC || !v107 && !v109 )
  {
    while ( v107 && v109 )
    {
      v13 = dword_8058220;
      v104 = sub_804AA61(*v108, *(_DWORD *)n, dword_805821C, dword_8058220);
      if ( v104 < 0 )
      {
        if ( byte_80587BC )
        {
          v16 = *v108;
          v94 = (unsigned int)&unk_80587E3;
          v93 = v16;
          v92 = (signed int)&loc_804BFE9;
          v91 = &savedregs;
          if ( c < 0 )
            v17 = 32;
          else
            v17 = c;
          HIBYTE(v83) = v17;
          v88 = (_DWORD *)dword_80587DB;
          if ( dword_80587DB )
          {
            v87 = v88;
            if ( *v88 )
            {
              if ( *v87 == 1 )
                v18 = v93;
              else
                v18 = v94;
              v86 = v18;
              v84 = v87[1];
            }
            else if ( (_UNKNOWN *)v93 == &unk_80587E3 )
            {
              v86 = v94;
              v84 = dword_8058220;
            }
            else
            {
              v86 = v93;
              v84 = dword_805821C;
            }
            v77 = v86;
            v76 = v84;
            v75 = (signed int *)&loc_804BE27;
            v74 = &v91;
            if ( *(_DWORD *)(v86 + 12) <= v84 )
            {
              if ( s1 )
                fputs_unlocked(s1, stdout);
            }
            else
            {
              v62 = *(_DWORD *)(8 * v76 + *(_DWORD *)(v77 + 20) + 4);
              if ( v62 )
              {
                fwrite_unlocked(*(const void **)(8 * v76 + *(_DWORD *)(v77 + 20)), 1u, v62, stdout);
              }
              else if ( s1 )
              {
                fputs_unlocked(s1, stdout);
              }
            }
          }
          else
          {
            v75 = (signed int *)dword_80587DB;
            v74 = (signed int **)v13;
            v19 = &loc_804BE99;
            if ( (_UNKNOWN *)v93 != &unk_80587E3 )
              v19 = &loc_804BEB6;
            dword_80581DC = (int)v19;
            sub_8052BC2(v76, v77, v78, v79, v80, v81, v82, v83, v84, v86, v87, v88, v89, v90, v91, v92);
            dword_80581C8 = (int)&loc_804BEC4;
            sub_8052C34(v93);
            v86 = v93;
            v84 = dword_805821C;
            v94 = v93;
            v93 = dword_805821C;
            dword_80581B4 = (int)&loc_804BEE5;
            sub_8052CB5(&loc_804BF97);
            v92 = (signed int)&v91;
            if ( *(_DWORD *)(v95 + 12) <= v94 )
            {
              if ( s1 )
                fputs_unlocked(s1, stdout);
            }
            else
            {
              v89 = *(_DWORD **)(8 * v94 + *(_DWORD *)(v95 + 20) + 4);
              if ( v89 )
              {
                fwrite_unlocked(*(const void **)(8 * v94 + *(_DWORD *)(v95 + 20)), 1u, (size_t)v89, stdout);
              }
              else if ( s1 )
              {
                fputs_unlocked(s1, stdout);
              }
            }
          }
          return;
        }
        sub_804B0C7(stream, (int)&v107, 1, 1);
        byte_80587BF = 1;
        dword_80581A0 = (int)&loc_804C939;
        ((void (*)(void))sub_8052D42)();
      }
      if ( v104 > 0 )
      {
        if ( byte_80587BD )
        {
          v94 = *(_DWORD *)n;
          v93 = (int)&unk_80587E3;
          v92 = (signed int)&loc_804C397;
          v91 = &savedregs;
          if ( c < 0 )
            v20 = 32;
          else
            v20 = c;
          HIBYTE(v83) = v20;
          v88 = (_DWORD *)dword_80587DB;
          if ( dword_80587DB )
          {
            v87 = v88;
            if ( *v88 )
            {
              if ( *v87 == 1 )
                v22 = v93;
              else
                v22 = v94;
              v86 = v22;
              v84 = v87[1];
            }
            else
            {
              v75 = 0;
              v74 = (signed int **)v13;
              v21 = &loc_804C0B2;
              if ( (_UNKNOWN *)v93 != &unk_80587E3 )
                v21 = &loc_804C0CF;
              dword_805818C = (int)v21;
              sub_8052DB0(v15, v14);
              dword_8058178 = (int)&loc_804C0FD;
              sub_8052E1A();
              v86 = v93;
              v84 = dword_805821C;
            }
            v77 = v86;
            v76 = v84;
            v75 = (signed int *)&loc_804C1E0;
            v74 = &v91;
            if ( *(_DWORD *)(v86 + 12) <= v84 )
            {
              if ( s1 )
                fputs_unlocked(s1, stdout);
            }
            else
            {
              v23 = *(_DWORD *)(8 * v76 + *(_DWORD *)(v77 + 20) + 4);
              v63 = v23;
              v24 = v23 == 0;
              v25 = &loc_804C159;
              if ( v24 )
                v25 = &loc_804C18C;
              dword_8058178 = (int)v25;
              sub_8052E1A();
              fwrite_unlocked(*(const void **)(8 * v76 + *(_DWORD *)(v77 + 20)), 1u, v63, stdout);
            }
            return;
          }
          if ( (_UNKNOWN *)v93 == &unk_80587E3 )
          {
            v86 = v94;
            v84 = dword_8058220;
          }
          else
          {
            v86 = v93;
            v84 = dword_805821C;
          }
          v77 = v86;
          v76 = v84;
          v75 = (signed int *)&loc_804C345;
          v74 = &v91;
          if ( *(_DWORD *)(v86 + 12) > v84 )
          {
            v64 = *(_DWORD *)(8 * v76 + *(_DWORD *)(v77 + 20) + 4);
            if ( v64 )
            {
              fwrite_unlocked(*(const void **)(8 * v76 + *(_DWORD *)(v77 + 20)), 1u, v64, stdout);
              dword_80581C8 = (int)&locret_804C341;
              sub_8052C34(v26);
            }
            if ( !s1 )
              return;
            fputs_unlocked(s1, stdout);
            dword_80581DC = (int)&locret_804C341;
            ((void (*)(void))sub_8052BC2)();
          }
          if ( s1 )
            fputs_unlocked(s1, stdout);
          return;
        }
        sub_804B0C7(a3, (int)&v109, 1, 2);
        byte_80587BF = 1;
        dword_8058114 = (int)&loc_804C939;
        ((void (*)(void))sub_8053080)();
      }
      v96 = 0;
      while ( !((unsigned __int8)sub_804B0C7(stream, (int)&v107, 0, 1) ^ 1) )
      {
        if ( sub_804AA61(v108[v107 + 0x3FFFFFFF], *(_DWORD *)n, dword_805821C, dword_8058220) )
          goto LABEL_119;
      }
      v96 = 1;
      ++v107;
LABEL_119:
      v97 = 0;
      if ( (unsigned __int8)sub_804B0C7(a3, (int)&v109, 0, 2) ^ 1 )
      {
        v97 = 1;
        ++v109;
        dword_8058164 = (int)&loc_804C4E5;
        sub_8052EA3();
      }
      v27 = dword_8058220;
      v28 = sub_804AA61(*v108, *(_DWORD *)(4 * (v109 + 0x3FFFFFFF) + n), dword_805821C, dword_8058220);
      v24 = v28 == 0;
      v92 = v28;
      v91 = (signed int *)v27;
      v29 = &loc_804C4E5;
      if ( v24 )
        v29 = &loc_804C44B;
      dword_80581DC = (int)v29;
      a1 = v91;
      ((void (*)(void))sub_8052BC2)();
      if ( byte_80587BE )
      {
        v100 = 0;
        if ( v107 - 1 > v100 )
        {
          v101 = 0;
          dword_80581A0 = (int)&loc_804C875;
          ((void (*)(void))sub_8052D42)();
          v30 = v108[v100];
          v94 = *(_DWORD *)n;
          v93 = v30;
          dword_80581C8 = (int)&loc_804C54B;
          sub_8052C34(&loc_804C871);
          v92 = (signed int)&savedregs;
          if ( c >= 0 )
          {
            dword_8058164 = (int)&loc_804C573;
            sub_8052EA3();
          }
          v85 = 32;
          v89 = (_DWORD *)dword_80587DB;
          if ( dword_80587DB )
          {
            v88 = v89;
            if ( *v89 )
            {
              if ( *v88 == 1 )
                v33 = v94;
              else
                v33 = v95;
              v87 = (_DWORD *)v33;
              v86 = v88[1];
            }
            else
            {
              v76 = 0;
              v75 = v91;
              v32 = &loc_804C5B9;
              if ( (_UNKNOWN *)v94 != &unk_80587E3 )
                v32 = &loc_804C5C9;
              dword_8058128 = (int)v32;
              sub_805300C();
              v87 = (_DWORD *)v95;
              v86 = dword_8058220;
            }
            v78 = v87;
            v77 = v86;
            v76 = (int)&loc_804C6E7;
            v75 = &v92;
            if ( v87[3] <= v86 )
            {
              if ( s1 )
                fputs_unlocked(s1, stdout);
            }
            else
            {
              v71 = *(_DWORD *)(8 * v77 + v78[5] + 4);
              if ( v71 )
              {
                fwrite_unlocked(*(const void **)(8 * v77 + v78[5]), 1u, v71, stdout);
              }
              else
              {
                v34 = &loc_804C69C;
                if ( !s1 )
                  v34 = &locret_804C6E3;
                dword_805818C = (int)v34;
                sub_8052DB0(v31, 8 * v77);
                fputs_unlocked(s1, stdout);
              }
            }
          }
          else
          {
            if ( (_UNKNOWN *)v94 == &unk_80587E3 )
            {
              v87 = (_DWORD *)v95;
              v86 = dword_8058220;
            }
            else
            {
              v87 = (_DWORD *)v94;
              v86 = dword_805821C;
            }
            v78 = v87;
            v77 = v86;
            v76 = (int)&loc_804C81F;
            v75 = &v92;
            if ( v87[3] <= v86 )
            {
              if ( s1 )
                fputs_unlocked(s1, stdout);
            }
            else
            {
              v72 = *(_DWORD *)(8 * v77 + v78[5] + 4);
              if ( v72 )
              {
                fwrite_unlocked(*(const void **)(8 * v77 + v78[5]), 1u, v72, stdout);
              }
              else if ( s1 )
              {
                fputs_unlocked(s1, stdout);
              }
            }
          }
          return;
        }
      }
      if ( v96 == 1 )
      {
        v107 = 0;
      }
      else
      {
        v105 = *v108;
        v4 = 4 * (v107 + 0x3FFFFFFF);
        *v108 = v108[v4 / 4u];
        v3 = &v108[v107 + 0x3FFFFFFF];
        *v3 = v105;
        v107 = 1;
      }
      if ( v97 == 1 )
      {
        v109 = 0;
      }
      else
      {
        v106 = *(_DWORD *)n;
        v4 = 4 * (v109 + 0x3FFFFFFF);
        *(_DWORD *)n = *(_DWORD *)(v4 + n);
        v3 = (int *)(n + 4 * (v109 + 0x3FFFFFFF));
        *v3 = v106;
        v109 = 1;
      }
    }
    ptr = 0;
    v98 = 0;
    if ( dword_80587DF != 2 && (byte_80587C0[0] != 1 || byte_80587C1 != 1) )
      v98 = 1;
    v92 = (unsigned __int8)byte_80587BC;
    v91 = a1;
    v35 = &loc_804C9A4;
    if ( byte_80587BC )
      v35 = &loc_804C9AE;
    dword_805818C = (int)v35;
    sub_8052DB0(v4, v3);
    if ( v98 && v107 )
    {
      v92 = (unsigned __int8)byte_80587BC;
      v36 = &loc_804C9DD;
      if ( !byte_80587BC )
        v36 = &loc_804CD34;
      dword_8058128 = (int)v36;
      sub_805300C();
      v37 = *v108;
      v94 = (unsigned int)&unk_80587E3;
      v93 = v37;
      dword_8058114 = (int)&loc_804CA01;
      sub_8053080(&loc_804CD34);
      v92 = (signed int)&savedregs;
      if ( c < 0 )
        v38 = 32;
      else
        v38 = c;
      v85 = v38;
      v89 = (_DWORD *)dword_80587DB;
      v76 = dword_80587DB;
      v75 = v91;
      v39 = &loc_804CA46;
      if ( !dword_80587DB )
        v39 = &loc_804CBD8;
      dword_8058150 = (int)v39;
      sub_8052F2E(v77, v78, v79, v80, v81, v82, v83, v84, v86, v87, v88, v89, v90, v91, v92);
      v88 = v89;
      if ( *v89 )
      {
        v24 = *v88 == 1;
        v92 = *v88;
        v91 = v75;
        v40 = &loc_804CAA1;
        if ( !v24 )
          v40 = &loc_804CAA6;
        dword_80581C8 = (int)v40;
        sub_8052C34(v93);
        v87 = (_DWORD *)v94;
        v86 = v88[1];
      }
      else if ( (_UNKNOWN *)v94 == &unk_80587E3 )
      {
        v87 = (_DWORD *)v95;
        v86 = dword_8058220;
      }
      else
      {
        v87 = (_DWORD *)v94;
        v86 = dword_805821C;
      }
      v94 = (unsigned int)v87;
      v93 = v86;
      v92 = (signed int)&loc_804CB88;
      v91 = &v92;
      if ( v87[3] <= v86 )
      {
        if ( s1 )
          fputs_unlocked(s1, stdout);
      }
      else
      {
        v88 = *(_DWORD **)(8 * v93 + *(_DWORD *)(v94 + 20) + 4);
        if ( v88 )
        {
          fwrite_unlocked(*(const void **)(8 * v93 + *(_DWORD *)(v94 + 20)), 1u, (size_t)v88, stdout);
          dword_8058150 = (int)&locret_804CB84;
          sub_8052F2E(v80, v81, v82, v83, v84, v86, v87, v88, v89, v90, v91, v92, v93, v94, v95);
        }
        if ( s1 )
          fputs_unlocked(s1, stdout);
      }
      return;
    }
    if ( !byte_80587BD && !v98 || !v109 )
    {
LABEL_266:
      sub_804AA21((int)ptr);
      free(ptr);
      sub_804B10B((int)&v107);
      sub_804B10B((int)&v109);
      return;
    }
    if ( !byte_80587BD )
    {
      if ( v107 )
        byte_80587BF = 1;
      while ( 1 )
      {
        if ( !(unsigned __int8)sub_804ADF0(a3, (int)&ptr, 2) )
          goto LABEL_266;
        if ( byte_80587BD )
          break;
        if ( byte_80587C1 && byte_80587BD != 1 )
          goto LABEL_266;
      }
      v94 = (unsigned int)ptr;
      v93 = (int)&unk_80587E3;
      v92 = (signed int)&loc_804D7E1;
      v91 = &savedregs;
      if ( c < 0 )
        v49 = 32;
      else
        v49 = c;
      HIBYTE(v83) = v49;
      v88 = (_DWORD *)dword_80587DB;
      if ( dword_80587DB )
      {
        v87 = v88;
        if ( *v88 )
        {
          if ( *v87 == 1 )
            v50 = v93;
          else
            v50 = v94;
          v86 = v50;
          v84 = v87[1];
        }
        else if ( (_UNKNOWN *)v93 == &unk_80587E3 )
        {
          v86 = v94;
          v84 = dword_8058220;
        }
        else
        {
          v86 = v93;
          v84 = dword_805821C;
        }
        v77 = v86;
        v76 = v84;
        v75 = (signed int *)&loc_804D654;
        v74 = &v91;
        if ( *(_DWORD *)(v86 + 12) <= v84 )
        {
          if ( s1 )
            fputs_unlocked(s1, stdout);
        }
        else
        {
          v51 = *(_DWORD *)(8 * v76 + *(_DWORD *)(v77 + 20) + 4);
          v67 = v51;
          v24 = v51 == 0;
          v52 = &loc_804D5CD;
          if ( v24 )
            v52 = &loc_804D600;
          dword_8058128 = (int)v52;
          sub_805300C();
          fwrite_unlocked(*(const void **)(8 * v76 + *(_DWORD *)(v77 + 20)), 1u, v67, stdout);
        }
        return;
      }
      if ( (_UNKNOWN *)v93 == &unk_80587E3 )
      {
        v86 = v94;
        v84 = dword_8058220;
      }
      else
      {
        v86 = v93;
        v84 = dword_805821C;
      }
      v77 = v86;
      v76 = v84;
      v75 = (signed int *)&loc_804D78F;
      v74 = &v91;
      if ( *(_DWORD *)(v86 + 12) > v84 )
      {
        v68 = *(_DWORD *)(8 * v76 + *(_DWORD *)(v77 + 20) + 4);
        if ( v68 )
        {
          fwrite_unlocked(*(const void **)(8 * v76 + *(_DWORD *)(v77 + 20)), 1u, v68, stdout);
          return;
        }
        if ( !s1 )
          return;
        fputs_unlocked(s1, stdout);
        dword_80581DC = (int)&locret_804D78B;
        sub_8052BC2(v53, v54, v57, v58, v59, v60, v61, 0, v69, v73, v74, v75, v76, v77, v78, v79);
      }
      if ( s1 )
        fputs_unlocked(s1, stdout);
      return;
    }
    v94 = *(_DWORD *)n;
    v93 = (int)&unk_80587E3;
    v92 = (signed int)&loc_804D4AF;
    v91 = &savedregs;
    if ( c < 0 )
      v41 = 32;
    else
      v41 = c;
    HIBYTE(v83) = v41;
    v88 = (_DWORD *)dword_80587DB;
    if ( !dword_80587DB )
    {
      if ( (_UNKNOWN *)v93 == &unk_80587E3 )
      {
        v86 = v94;
        v84 = dword_8058220;
      }
      else
      {
        v86 = v93;
        v84 = dword_805821C;
      }
      v77 = v86;
      v76 = v84;
      v75 = (signed int *)&loc_804D45D;
      v74 = &v91;
      if ( *(_DWORD *)(v86 + 12) <= v84 )
      {
        if ( s1 )
          fputs_unlocked(s1, stdout);
      }
      else
      {
        v47 = *(_DWORD *)(8 * v76 + *(_DWORD *)(v77 + 20) + 4);
        v66 = v47;
        v24 = v47 == 0;
        v48 = &loc_804D3D6;
        if ( v24 )
          v48 = &loc_804D409;
        dword_805813C = (int)v48;
        ((void (*)(void))sub_8052F9A)();
        fwrite_unlocked(*(const void **)(8 * v76 + *(_DWORD *)(v77 + 20)), 1u, v66, stdout);
      }
      return;
    }
    v87 = v88;
    if ( !*v88 )
    {
      if ( (_UNKNOWN *)v93 == &unk_80587E3 )
      {
        v86 = v94;
        v84 = dword_8058220;
        goto LABEL_211;
      }
      v86 = v93;
      v84 = dword_805821C;
      dword_805813C = (int)&loc_804D1FD;
      ((void (*)(void))sub_8052F9A)();
    }
    if ( *v87 == 1 )
      v42 = v93;
    else
      v42 = v94;
    v86 = v42;
    v84 = v87[1];
LABEL_211:
    v77 = v86;
    v76 = v84;
    v75 = (signed int *)&loc_804D2F9;
    v74 = &v91;
    if ( *(_DWORD *)(v86 + 12) <= v84 )
    {
      v46 = &loc_804D2DE;
      if ( !s1 )
        v46 = &locret_804D2F5;
      dword_80581B4 = (int)v46;
      sub_8052CB5(v55);
      fputs_unlocked(s1, stdout);
    }
    else
    {
      v43 = *(_DWORD *)(8 * v76 + *(_DWORD *)(v77 + 20) + 4);
      v65 = v43;
      v24 = v43 == 0;
      v44 = &loc_804D259;
      if ( v24 )
        v44 = &loc_804D28C;
      dword_80581A0 = (int)v44;
      sub_8052D42(
        v55,
        v56,
        v57,
        v58,
        v59,
        v60,
        v61,
        v65,
        v69,
        v73,
        v74,
        v75,
        v76,
        v77,
        v78,
        v79,
        v80,
        v81,
        v82,
        v83,
        v84,
        v86,
        v87,
        v88,
        v89,
        v90,
        v91,
        v92);
      fwrite_unlocked(*(const void **)(8 * v76 + *(_DWORD *)(v77 + 20)), 1u, v45, stdout);
    }
    return;
  }
  if ( v107 )
    v7 = (void *)*v108;
  else
    v7 = &unk_80587E3;
  v102 = (int)v7;
  if ( v109 )
    v8 = *(void **)n;
  else
    v8 = &unk_80587E3;
  v103 = v8;
  v94 = (unsigned int)v8;
  v93 = v102;
  dword_805818C = (int)&loc_804B8E6;
  sub_8052DB0(v4, v3);
  v92 = (signed int)&savedregs;
  if ( c < 0 )
    v9 = 32;
  else
    v9 = c;
  v85 = v9;
  v89 = (_DWORD *)dword_80587DB;
  if ( dword_80587DB )
  {
    v88 = v89;
    if ( *v89 )
    {
      if ( *v88 == 1 )
        v10 = v94;
      else
        v10 = v95;
      v87 = (_DWORD *)v10;
      v86 = v88[1];
    }
    else if ( (_UNKNOWN *)v94 == &unk_80587E3 )
    {
      v87 = (_DWORD *)v95;
      v86 = dword_8058220;
    }
    else
    {
      v87 = (_DWORD *)v94;
      v86 = dword_805821C;
    }
    v78 = v87;
    v77 = v86;
    v76 = (int)&loc_804BA5C;
    v75 = &v92;
    if ( v87[3] > v86 )
    {
      v70 = *(_DWORD *)(8 * v77 + v78[5] + 4);
      if ( v70 )
      {
        fwrite_unlocked(*(const void **)(8 * v77 + v78[5]), 1u, v70, stdout);
        return;
      }
      v11 = &loc_804BA04;
      if ( !s1 )
        v11 = &locret_804BA58;
      dword_8058178 = (int)v11;
      sub_8052E1A();
      fputs_unlocked(s1, stdout);
      dword_8058178 = (int)&locret_804BA58;
      sub_8052E1A();
    }
    if ( s1 )
      fputs_unlocked(s1, stdout);
  }
  else
  {
    v76 = dword_80587DB;
    v75 = a1;
    v12 = &loc_804BABF;
    if ( (_UNKNOWN *)v94 != &unk_80587E3 )
      v12 = &loc_804BACF;
    dword_805813C = (int)v12;
    sub_8052F9A(v77, v78, v79, v80, v81, v82, v83, v84, v86, v87, v88, v89, v90, v91, v92);
    v87 = (_DWORD *)v95;
    v86 = dword_8058220;
    v94 = v95;
    v93 = dword_8058220;
    v92 = (signed int)&loc_804BBA3;
    v91 = &v92;
    if ( *(_DWORD *)(v95 + 12) <= (unsigned int)dword_8058220 )
    {
      if ( s1 )
        fputs_unlocked(s1, stdout);
    }
    else
    {
      v88 = *(_DWORD **)(8 * v93 + *(_DWORD *)(v94 + 20) + 4);
      if ( v88 )
      {
        fwrite_unlocked(*(const void **)(8 * v93 + *(_DWORD *)(v94 + 20)), 1u, (size_t)v88, stdout);
      }
      else if ( s1 )
      {
        fputs_unlocked(s1, stdout);
      }
    }
  }
}
// 8048F50: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8052BC2: using guessed type int __stdcall sub_8052BC2(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8052C34: using guessed type int __stdcall sub_8052C34(_DWORD);
// 8052CB5: using guessed type int __stdcall sub_8052CB5(_DWORD);
// 8052D42: using guessed type int __stdcall sub_8052D42(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8052DB0: using guessed type int __fastcall sub_8052DB0(_DWORD, _DWORD);
// 8052E1A: using guessed type int sub_8052E1A(void);
// 8052EA3: using guessed type int sub_8052EA3(void);
// 8052F2E: using guessed type int __stdcall sub_8052F2E(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8052F9A: using guessed type int __stdcall sub_8052F9A(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 805300C: using guessed type int sub_805300C(void);
// 8053080: using guessed type int __stdcall sub_8053080(_DWORD);
// 8058114: using guessed type int dword_8058114;
// 8058128: using guessed type int dword_8058128;
// 805813C: using guessed type int dword_805813C;
// 8058150: using guessed type int dword_8058150;
// 8058164: using guessed type int dword_8058164;
// 8058178: using guessed type int dword_8058178;
// 805818C: using guessed type int dword_805818C;
// 80581A0: using guessed type int dword_80581A0;
// 80581B4: using guessed type int dword_80581B4;
// 80581C8: using guessed type int dword_80581C8;
// 80581DC: using guessed type int dword_80581DC;
// 805821C: using guessed type int dword_805821C;
// 8058220: using guessed type int dword_8058220;
// 80587BC: using guessed type char byte_80587BC;
// 80587BD: using guessed type char byte_80587BD;
// 80587BE: using guessed type char byte_80587BE;
// 80587BF: using guessed type char byte_80587BF;
// 80587C1: using guessed type char byte_80587C1;
// 80587C7: using guessed type char byte_80587C7;
// 80587CB: using guessed type int dword_80587CB;
// 80587CF: using guessed type int dword_80587CF;
// 80587DB: using guessed type int dword_80587DB;
// 80587DF: using guessed type int dword_80587DF;
// 80587FC: using guessed type char byte_80587FC;

//----- (0804D851) --------------------------------------------------------
#error "804D871: call analysis failed (funcsize=49)"

//----- (0804D915) --------------------------------------------------------
int __cdecl sub_804D915(char *nptr)
{
  void *v1; // ebx
  char *v2; // eax
  int v4; // [esp+24h] [ebp-14h]
  int v5; // [esp+28h] [ebp-10h]

  v5 = sub_805157C(nptr, 0, 10, (int)&v4, &s);
  if ( v5 == 1 )
  {
    v4 = -1;
  }
  else if ( v5 || !v4 )
  {
    v1 = sub_8050916((int)nptr);
    v2 = gettext("invalid field number: %s");
    error(1, 0, v2, v1);
  }
  return v4 - 1;
}

//----- (0804D9AC) --------------------------------------------------------
void __cdecl sub_804D9AC(char *a1, _DWORD *a2, _DWORD *a3)
{
  void *v3; // eax
  int v4; // eax
  void *v5; // ebx
  char *v6; // eax
  void *v7; // ebx
  char *v8; // eax

  v3 = &loc_804D9DA;
  if ( *a1 == 48 )
    v3 = &loc_804D9EE;
  dword_8058128 = (int)v3;
  v4 = sub_805300C();
  if ( v4 < 48 || v4 > 50 )
  {
    v7 = sub_8050916((int)a1);
    v8 = gettext("invalid file number in field spec: %s");
    error(1, 0, v8, v7);
  }
  else
  {
    if ( a1[1] != 46 )
    {
      v5 = sub_8050916((int)a1);
      v6 = gettext("invalid field specifier: %s");
      error(1, 0, v6, v5);
    }
    *a2 = *a1 - 48;
    *a3 = sub_804D915(a1 + 2);
  }
}
// 805300C: using guessed type int sub_805300C(void);
// 8058128: using guessed type int dword_8058128;

//----- (0804DAFC) --------------------------------------------------------
_DWORD *__cdecl sub_804DAFC(char *a1)
{
  char *v1; // eax
  bool v2; // zf
  void *v3; // eax
  char *v4; // eax
  _DWORD *result; // eax
  int v6; // [esp+0h] [ebp-28h]
  int v7; // [esp+10h] [ebp-18h]
  int v8; // [esp+14h] [ebp-14h]
  char *s; // [esp+18h] [ebp-10h]
  char *v10; // [esp+1Ch] [ebp-Ch]

  s = a1;
  do
  {
    v10 = s;
    v1 = strpbrk(s, ", \t");
    s = v1;
    v2 = v1 == 0;
    v3 = &loc_804DB55;
    if ( v2 )
      v3 = &loc_804DB61;
    dword_80581B4 = (int)v3;
    sub_8052CB5(v6);
    v4 = s++;
    *v4 = 0;
    sub_804D9AC(v10, &v7, &v8);
    result = sub_804D851(v7, v8);
  }
  while ( s );
  return result;
}
// 8052CB5: using guessed type int __stdcall sub_8052CB5(_DWORD);
// 80581B4: using guessed type int dword_80581B4;

//----- (0804DB98) --------------------------------------------------------
_DWORD *__cdecl sub_804DB98(_DWORD *a1, int a2)
{
  int v2; // ST28_4
  char *v3; // eax
  _DWORD *result; // eax

  if ( *a1 != -1 && *a1 != a2 )
  {
    v2 = *a1 + 1;
    v3 = gettext("incompatible join fields %lu, %lu");
    error(1, 0, v3, v2, a2 + 1);
  }
  result = a1;
  *a1 = a2;
  return result;
}

//----- (0804DC14) --------------------------------------------------------
#error "804DC79: call analysis failed (funcsize=117)"

//----- (0804DDCC) --------------------------------------------------------
void __cdecl __noreturn main(int argc, char **argv)
{
  sub_804ED12((int)*argv);
}

//----- (0804E7D1) --------------------------------------------------------
int sub_804E7D1()
{
  void *v0; // ebx
  int *v1; // eax
  int *v2; // eax
  int result; // eax
  char *v4; // [esp+2Ch] [ebp-Ch]

  if ( sub_8051E7C(stdout) && (byte_8058803 != 1 || *__errno_location() != 32) )
  {
    v4 = gettext("write error");
    if ( dword_80587FF )
    {
      v0 = sub_8050691(dword_80587FF);
      v1 = __errno_location();
      error(0, *v1, "%s: %s", v0, v4);
    }
    else
    {
      v2 = __errno_location();
      error(0, *v2, "%s", v4);
    }
    _exit(status);
  }
  result = sub_8051E7C(stderr);
  if ( result )
    _exit(status);
  return result;
}
// 80587FF: using guessed type int dword_80587FF;
// 8058803: using guessed type char byte_8058803;

//----- (0804E8B5) --------------------------------------------------------
int __cdecl sub_804E8B5(int a1, int a2, int a3, int a4, int a5, int a6)
{
  return posix_fadvise64(a1, a2, a3, a4, a5, a6);
}
// 80490B0: using guessed type int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804E916) --------------------------------------------------------
void __cdecl sub_804E916(FILE *stream, int a2)
{
  int v2; // eax

  if ( stream )
  {
    v2 = fileno(stream);
    sub_804E8B5(v2, 0, 0, 0, 0, a2);
  }
}

//----- (0804E970) --------------------------------------------------------
FILE *__cdecl sub_804E970(int a1, char *modes)
{
  int v2; // ST28_4
  int v4; // ST2C_4
  FILE *stream; // [esp+1Ch] [ebp-1Ch]
  signed int v6; // [esp+20h] [ebp-18h]
  int fd; // [esp+24h] [ebp-14h]

  stream = (FILE *)fopen64(a1, modes);
  if ( !stream )
    return stream;
  v6 = fileno(stream);
  if ( v6 < 0 || v6 > 2 )
    return stream;
  fd = sub_8050931(v6);
  if ( fd < 0 )
  {
    v2 = *__errno_location();
    sub_80519B0(stream);
    *__errno_location() = v2;
    return 0;
  }
  if ( !sub_80519B0(stream) )
  {
    stream = fdopen(fd, modes);
    if ( stream )
      return stream;
  }
  v4 = *__errno_location();
  close(fd);
  *__errno_location() = v4;
  return 0;
}
// 8048E40: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (0804EA58) --------------------------------------------------------
int __cdecl sub_804EA58(int category)
{
  char *v1; // eax
  int v2; // edx
  int v3; // ecx
  bool v4; // zf
  void *v5; // eax
  void *v6; // eax
  int v8; // [esp+0h] [ebp-28h]
  unsigned __int8 v9; // [esp+1Bh] [ebp-Dh]
  char *s1; // [esp+1Ch] [ebp-Ch]

  v9 = 1;
  v1 = setlocale(category, 0);
  s1 = v1;
  v4 = v1 == 0;
  v5 = &loc_804EA97;
  if ( v4 )
    v5 = &loc_804EAE2;
  dword_805818C = (int)v5;
  sub_8052DB0(v3, v2);
  v4 = strcmp(s1, "C") == 0;
  v6 = &loc_804EAC7;
  if ( v4 )
    v6 = &loc_804EADE;
  dword_80581B4 = (int)v6;
  sub_8052CB5(v8);
  if ( !strcmp(s1, "POSIX") )
    v9 = 0;
  return v9;
}
// 804EA58: could not find valid save-restore pair for ebx
// 8052CB5: using guessed type int __stdcall sub_8052CB5(_DWORD);
// 8052DB0: using guessed type int __fastcall sub_8052DB0(_DWORD, _DWORD);
// 805818C: using guessed type int dword_805818C;
// 80581B4: using guessed type int dword_80581B4;

//----- (0804EB2D) --------------------------------------------------------
#error "804EC47: call analysis failed (funcsize=97)"

//----- (0804EC79) --------------------------------------------------------
int __cdecl sub_804EC79(unsigned __int8 *a1, unsigned __int8 *a2, unsigned int a3)
{
  unsigned __int8 v3; // ST1F_1
  int v4; // ST2C_4
  int v5; // eax
  bool v6; // zf
  void *v7; // eax
  int v9; // [esp+0h] [ebp-38h]
  int v10; // [esp+2Ch] [ebp-Ch]

  if ( a3 <= 0 )
    return 0;
  v3 = *a2;
  v4 = toupper(*a1);
  v5 = v4 - toupper(v3);
  v10 = v5;
  v6 = v5 == 0;
  v7 = &loc_804ECFA;
  if ( v6 )
    v7 = &loc_804ECFF;
  dword_8058114 = (int)v7;
  sub_8053080(v9);
  return v10;
}
// 8053080: using guessed type int __stdcall sub_8053080(_DWORD);
// 8058114: using guessed type int dword_8058114;

//----- (0804ED12) --------------------------------------------------------
void __cdecl __noreturn sub_804ED12(int a1)
{
  int (__cdecl *v1)(int, size_t); // eax

  v1 = (int (__cdecl *)(int, size_t))&loc_804ED37;
  if ( a1 )
    v1 = sub_804ED61;
  dword_8058164 = (int)v1;
  sub_8052EA3();
  fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
  abort();
}
// 8052EA3: using guessed type int sub_8052EA3(void);
// 8058164: using guessed type int dword_8058164;

//----- (0804ED61) --------------------------------------------------------
#error "804EE42: positive sp value has been found (funcsize=62)"

//----- (0804EF21) --------------------------------------------------------
int __cdecl sub_804EF21(int *a1, unsigned __int8 a2, char a3)
{
  int *v3; // eax
  int v4; // ST10_4

  if ( a1 )
    v3 = a1;
  else
    v3 = &dword_8058823;
  v4 = ((unsigned int)v3[(a2 >> 5) + 2] >> (a2 & 0x1F)) & 1;
  v3[(a2 >> 5) + 2] ^= (v4 ^ a3 & 1) << (a2 & 0x1F);
  return v4;
}
// 8058823: using guessed type int dword_8058823;

//----- (0804EFCB) --------------------------------------------------------
int *__cdecl sub_804EFCB(int *a1, int a2, int a3)
{
  int *result; // eax

  if ( !a1 )
    a1 = &dword_8058823;
  *a1 = 10;
  if ( !a2 || !a3 )
    abort();
  a1[10] = a2;
  result = a1;
  a1[11] = a3;
  return result;
}
// 8058823: using guessed type int dword_8058823;

//----- (0804F018) --------------------------------------------------------
void __cdecl __noreturn sub_804F018(int a1, int a2)
{
  int (__stdcall *v2)(int); // eax
  char v3; // [esp+0h] [ebp-38h]

  memset(&v3, 0, 0x30u);
  v2 = (int (__stdcall *)(int))&loc_804F052;
  if ( a2 != 10 )
    v2 = sub_804F057;
  dword_805818C = (int)v2;
  sub_8052DB0(0, 12);
  abort();
}
// 804F057: using guessed type int __stdcall sub_804F057(int);
// 8052DB0: using guessed type int __fastcall sub_8052DB0(_DWORD, _DWORD);
// 805818C: using guessed type int dword_805818C;

//----- (0804F057) --------------------------------------------------------
#error "804F0AD: positive sp value has been found (funcsize=0)"

//----- (0804F0B3) --------------------------------------------------------
#error "804F17A: call analysis failed (funcsize=59)"

//----- (0804F186) --------------------------------------------------------
unsigned int __cdecl sub_804F186(int a1, unsigned int a2, int a3, size_t a4, signed int a5, int a6, int a7, char *a8, char *a9)
{
  int v9; // edx
  int v10; // ecx
  void *v11; // eax
  size_t v12; // ebx
  size_t v13; // eax
  char *v14; // edx
  char v15; // al
  bool v16; // zf
  bool v17; // sf
  unsigned __int8 v18; // of
  void *v19; // eax
  void *v20; // eax
  void *v21; // eax
  bool v22; // al
  void *v23; // eax
  int v24; // edx
  void *v25; // eax
  void *v26; // eax
  void *v27; // eax
  bool v28; // al
  void *v29; // eax
  void *v30; // eax
  void *v31; // eax
  void *v32; // eax
  unsigned int result; // eax
  void *v34; // eax
  int v35; // [esp+0h] [ebp-88h]
  int v36; // [esp+0h] [ebp-88h]
  int v37; // [esp+4h] [ebp-84h]
  int v38; // [esp+8h] [ebp-80h]
  int v39; // [esp+Ch] [ebp-7Ch]
  int v40; // [esp+10h] [ebp-78h]
  int v41; // [esp+14h] [ebp-74h]
  int v42; // [esp+18h] [ebp-70h]
  int v43; // [esp+1Ch] [ebp-6Ch]
  int v44; // [esp+20h] [ebp-68h]
  int v45; // [esp+24h] [ebp-64h]
  int v46; // [esp+28h] [ebp-60h]
  char *v47; // [esp+2Ch] [ebp-5Ch]
  char *v48; // [esp+2Ch] [ebp-5Ch]
  char *v49; // [esp+30h] [ebp-58h]
  char *v50; // [esp+30h] [ebp-58h]
  int v51; // [esp+34h] [ebp-54h]
  int v52; // [esp+34h] [ebp-54h]
  char *v53; // [esp+38h] [ebp-50h]
  char *v54; // [esp+38h] [ebp-50h]
  int v55; // [esp+3Ch] [ebp-4Ch]
  char v56; // [esp+40h] [ebp-48h]
  bool v57; // [esp+41h] [ebp-47h]
  char v58; // [esp+42h] [ebp-46h]
  char v59; // [esp+43h] [ebp-45h]
  char v60; // [esp+44h] [ebp-44h]
  unsigned __int8 v61; // [esp+45h] [ebp-43h]
  char v62; // [esp+46h] [ebp-42h]
  char v63; // [esp+47h] [ebp-41h]
  char v64; // [esp+48h] [ebp-40h]
  bool v65; // [esp+49h] [ebp-3Fh]
  bool v66; // [esp+4Ah] [ebp-3Eh]
  bool v67; // [esp+4Bh] [ebp-3Dh]
  wint_t wc; // [esp+4Ch] [ebp-3Ch]
  int v69; // [esp+50h] [ebp-38h]
  unsigned int v70; // [esp+54h] [ebp-34h]
  unsigned int v71; // [esp+58h] [ebp-30h]
  char *s; // [esp+5Ch] [ebp-2Ch]
  size_t n; // [esp+60h] [ebp-28h]
  unsigned int v74; // [esp+64h] [ebp-24h]
  unsigned int v75; // [esp+68h] [ebp-20h]
  size_t v76; // [esp+6Ch] [ebp-1Ch]
  unsigned int v77; // [esp+70h] [ebp-18h]
  mbstate_t ps; // [esp+74h] [ebp-14h]
  unsigned int v79; // [esp+7Ch] [ebp-Ch]

  v55 = a1;
  v53 = (char *)a3;
  v51 = a7;
  v49 = a8;
  v47 = a9;
  v79 = __readgsdword(0x14u);
  v70 = 0;
  v71 = 0;
  s = 0;
  n = 0;
  v56 = 0;
  v67 = __ctype_get_mb_cur_max() == 1;
  v57 = (a6 & 2) != 0;
  v58 = 0;
  v59 = 0;
  v60 = 1;
  switch ( a5 )
  {
    case 0:
      v57 = 0;
      dword_8058164 = (int)&loc_804F37D;
      sub_8052EA3();
      goto LABEL_28;
    case 1:
      goto LABEL_19;
    case 2:
      goto LABEL_22;
    case 3:
      v56 = 1;
LABEL_19:
      v57 = 1;
      goto LABEL_20;
    case 4:
LABEL_20:
      if ( v57 != 1 )
        v56 = 1;
LABEL_22:
      a5 = 2;
      if ( v57 != 1 )
      {
        if ( v70 < a2 )
          *(_BYTE *)(a1 + v70) = 39;
        ++v70;
      }
      s = "'";
      n = 1;
      break;
    case 5:
      goto LABEL_3;
    case 6:
      a5 = 5;
      v57 = 1;
LABEL_3:
      if ( v57 != 1 )
      {
        if ( v70 < a2 )
          *(_BYTE *)(a1 + v70) = 34;
        ++v70;
      }
      s = (char *)&unk_8054025;
      n = 1;
      dword_80581C8 = (int)&loc_804F37D;
      sub_8052C34(v35);
      goto LABEL_8;
    case 7:
LABEL_8:
      v56 = 1;
      v57 = 0;
      break;
    case 8:
    case 9:
    case 10:
      v11 = &loc_804F292;
      if ( a5 == 10 )
        v11 = &loc_804F2BE;
      dword_805818C = (int)v11;
      sub_8052DB0(v10, v9);
      v49 = (char *)sub_804F0B3("`", a5);
      v47 = (char *)sub_804F0B3("'", a5);
      if ( v57 != 1 )
      {
        for ( s = v49; *s; ++s )
        {
          if ( v70 < a2 )
            *(_BYTE *)(v70 + a1) = *s;
          ++v70;
        }
      }
      v56 = 1;
      s = v47;
      n = strlen(v47);
      break;
    default:
LABEL_28:
      abort();
      return result;
  }
  v69 = 0;
  while ( 1 )
  {
    v28 = a4 == -1 ? v53[v69] != 0 : v69 != a4;
    if ( !v28 )
      break;
    v63 = 0;
    v64 = 0;
    v65 = 0;
    if ( v56 && a5 != 2 && n )
    {
      v12 = v69 + n;
      if ( a4 != -1 || n <= 1 )
      {
        v13 = a4;
      }
      else
      {
        v13 = strlen(v53);
        a4 = v13;
      }
      if ( v12 <= v13 && !memcmp(&v53[v69], s, n) )
      {
        if ( v57 )
          goto LABEL_253;
        v63 = 1;
      }
    }
    v14 = v53;
    v61 = v53[v69];
    switch ( v61 )
    {
      case 0u:
        if ( v56 )
        {
          if ( v57 )
            goto LABEL_253;
          v64 = 1;
          if ( a5 == 2 && v58 != 1 )
          {
            if ( v70 < a2 )
              *(_BYTE *)(v55 + v70) = 39;
            if ( ++v70 < a2 )
              *(_BYTE *)(v55 + v70) = 36;
            if ( ++v70 < a2 )
              *(_BYTE *)(v55 + v70) = 39;
            ++v70;
            v58 = 1;
          }
          if ( v70 < a2 )
            *(_BYTE *)(v55 + v70) = 92;
          ++v70;
          if ( a5 != 2 && v69 + 1 < a4 )
          {
            v15 = v53[v69 + 1];
            v18 = __OFSUB__(v15, 47);
            v16 = v15 == 47;
            v17 = (char)(v15 - 47) < 0;
            v19 = &loc_804F4F1;
            if ( (unsigned __int8)(v17 ^ v18) | v16 )
              v19 = &loc_804F531;
            dword_8058178 = (int)v19;
            sub_8052E1A();
            if ( v53[v69 + 1] <= 57 )
            {
              if ( v70 < a2 )
                *(_BYTE *)(v55 + v70) = 48;
              if ( ++v70 < a2 )
                *(_BYTE *)(v55 + v70) = 48;
              ++v70;
            }
          }
          v61 = 48;
          dword_8058150 = (int)&loc_804F553;
          sub_8052F2E(v35, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v49, v51, v53);
        }
        if ( a6 & 1 )
          goto LABEL_227;
        goto LABEL_193;
      case 7u:
        v62 = 97;
        goto LABEL_106;
      case 8u:
        v62 = 98;
        dword_8058128 = (int)&loc_804F741;
        sub_805300C();
        goto LABEL_90;
      case 9u:
        v62 = 116;
        goto LABEL_104;
      case 0xAu:
        goto LABEL_91;
      case 0xBu:
        v62 = 118;
        dword_80581B4 = (int)&loc_804F741;
        sub_8052CB5(v35);
        goto LABEL_95;
      case 0xCu:
LABEL_90:
        v62 = 102;
        dword_805818C = (int)&loc_804F741;
        sub_8052DB0(v10, v14);
LABEL_91:
        v62 = 110;
        goto LABEL_104;
      case 0xDu:
        v62 = 114;
        goto LABEL_104;
      case 0x20u:
        goto LABEL_114;
      case 0x21u:
      case 0x22u:
      case 0x24u:
      case 0x26u:
      case 0x28u:
      case 0x29u:
      case 0x2Au:
      case 0x3Bu:
      case 0x3Cu:
      case 0x3Du:
      case 0x3Eu:
      case 0x5Bu:
      case 0x5Eu:
      case 0x60u:
      case 0x7Cu:
        goto LABEL_115;
      case 0x23u:
      case 0x7Eu:
        goto LABEL_113;
      case 0x25u:
      case 0x2Bu:
      case 0x2Cu:
      case 0x2Du:
      case 0x2Eu:
      case 0x2Fu:
      case 0x30u:
      case 0x31u:
      case 0x32u:
      case 0x33u:
      case 0x34u:
      case 0x35u:
      case 0x36u:
      case 0x37u:
      case 0x38u:
      case 0x39u:
      case 0x3Au:
      case 0x41u:
      case 0x42u:
      case 0x43u:
      case 0x44u:
      case 0x45u:
      case 0x46u:
      case 0x47u:
      case 0x48u:
      case 0x49u:
      case 0x4Au:
      case 0x4Bu:
      case 0x4Cu:
      case 0x4Du:
      case 0x4Eu:
      case 0x4Fu:
      case 0x50u:
      case 0x51u:
      case 0x52u:
      case 0x53u:
      case 0x54u:
      case 0x55u:
      case 0x56u:
      case 0x57u:
      case 0x58u:
      case 0x59u:
      case 0x5Au:
      case 0x5Du:
      case 0x5Fu:
      case 0x61u:
      case 0x62u:
      case 0x63u:
      case 0x64u:
      case 0x65u:
      case 0x66u:
      case 0x67u:
      case 0x68u:
      case 0x69u:
      case 0x6Au:
      case 0x6Bu:
      case 0x6Cu:
      case 0x6Du:
      case 0x6Eu:
      case 0x6Fu:
      case 0x70u:
      case 0x71u:
      case 0x72u:
      case 0x73u:
      case 0x74u:
      case 0x75u:
      case 0x76u:
      case 0x77u:
      case 0x78u:
      case 0x79u:
      case 0x7Au:
        goto LABEL_131;
      case 0x27u:
        goto LABEL_118;
      case 0x3Fu:
        if ( a5 == 2 )
        {
          if ( v57 )
            goto LABEL_253;
        }
        else if ( a5 == 5 && a6 & 4 && v69 + 2 < a4 && v53[v69 + 1] == 63 )
        {
          switch ( v53[v69 + 2] )
          {
            case 33:
            case 39:
            case 40:
            case 41:
            case 45:
            case 47:
            case 60:
            case 61:
            case 62:
              if ( v57 )
                goto LABEL_253;
              v61 = v53[v69 + 2];
              v69 += 2;
              if ( v70 < a2 )
                *(_BYTE *)(v55 + v70) = 63;
              if ( ++v70 < a2 )
                *(_BYTE *)(v55 + v70) = 34;
              if ( ++v70 < a2 )
                *(_BYTE *)(v55 + v70) = 34;
              if ( ++v70 < a2 )
                *(_BYTE *)(v55 + v70) = 63;
              ++v70;
              dword_80581DC = (int)&loc_804F65E;
              sub_8052BC2(v35, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v49, v51, v53, v55);
              break;
            default:
              goto LABEL_193;
          }
        }
        goto LABEL_193;
      case 0x5Cu:
LABEL_95:
        v62 = v61;
        if ( a5 == 2 )
        {
          if ( v57 )
            goto LABEL_253;
        }
        else
        {
          v20 = &loc_804F6FC;
          if ( !v56 )
            v20 = &loc_804F730;
          dword_8058178 = (int)v20;
          sub_8052E1A();
          if ( v57 )
          {
            v21 = &loc_804F721;
            if ( !n )
              v21 = &loc_804F730;
            dword_80581DC = (int)v21;
            sub_8052BC2(v35, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v49, v51, v53, v55);
            dword_8058128 = (int)&loc_804FCE2;
            sub_805300C();
          }
LABEL_104:
          if ( a5 == 2 && v57 )
            goto LABEL_253;
LABEL_106:
          if ( v56 )
          {
            v61 = v62;
            dword_8058164 = (int)&loc_804FC62;
            sub_8052EA3();
          }
          dword_805818C = (int)&loc_804FBD2;
          sub_8052DB0(v10, v14);
LABEL_109:
          if ( a4 == -1 )
            v22 = v53[1] != 0;
          else
            v22 = a4 != 1;
          if ( !v22 )
          {
LABEL_113:
            if ( !v69 )
            {
LABEL_114:
              v65 = 1;
LABEL_115:
              if ( a5 == 2 && v57 )
                goto LABEL_253;
              dword_8058150 = (int)&loc_804FBD2;
              sub_8052F2E(v35, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v49, v51, v53);
LABEL_118:
              v59 = 1;
              v65 = 1;
              if ( a5 == 2 )
              {
                if ( v57 )
                  goto LABEL_253;
                if ( a2 && !v71 )
                {
                  v71 = a2;
                  a2 = 0;
                }
                if ( v70 < a2 )
                  *(_BYTE *)(v55 + v70) = 39;
                if ( ++v70 < a2 )
                  *(_BYTE *)(v55 + v70) = 92;
                if ( ++v70 < a2 )
                  *(_BYTE *)(v55 + v70) = 39;
                ++v70;
                v58 = 0;
              }
              else
              {
                dword_805818C = (int)&loc_804FBD2;
                sub_8052DB0(v10, v14);
LABEL_131:
                v65 = 1;
                dword_80581C8 = (int)&loc_804FBD2;
                sub_8052C34(v35);
LABEL_132:
                if ( v67 )
                {
                  v74 = 1;
                  v66 = ((*__ctype_b_loc())[v61] & 0x4000) != 0;
                }
                else
                {
                  memset(&ps, 0, 8u);
                  v74 = 0;
                  v66 = 1;
                  if ( a4 == -1 )
                    a4 = strlen(v53);
                  do
                  {
                    v76 = sub_8051D8C((wchar_t *)&wc, &v53[v74 + v69], a4 - (v74 + v69), &ps);
                    if ( !v76 )
                      break;
                    if ( v76 == -1 )
                    {
                      v66 = 0;
                      break;
                    }
                    if ( v76 == -2 )
                    {
                      v66 = 0;
                      if ( v69 + v74 < a4 )
                      {
                        v23 = &loc_804F96E;
                        if ( v53[v74 + v69] )
                          v23 = &loc_804F930;
                        dword_8058164 = (int)v23;
                        sub_8052EA3();
                      }
                      break;
                    }
                    if ( v57 && a5 == 2 )
                    {
                      v75 = 1;
                      while ( v75 < v76 )
                      {
                        switch ( v53[v75 + v74 + v69] )
                        {
                          case 91:
                          case 92:
                          case 94:
                          case 96:
                          case 124:
                            goto LABEL_253;
                          default:
                            ++v75;
                            break;
                        }
                      }
                    }
                    if ( !iswprint(wc) )
                      v66 = 0;
                    v74 += v76;
                  }
                  while ( !mbsinit(&ps) );
                }
                v65 = v66;
                if ( v74 > 1 || v56 && v66 != 1 )
                {
                  v24 = v69;
                  v77 = v69 + v74;
                  while ( 1 )
                  {
                    if ( v56 && v66 != 1 )
                    {
                      if ( v57 )
                        goto LABEL_253;
                      v64 = 1;
                      if ( a5 == 2 )
                      {
                        v25 = &loc_804FA6B;
                        if ( v58 == 1 )
                          v25 = &loc_804FAB4;
                        dword_805818C = (int)v25;
                        sub_8052DB0(v10, v24);
                        if ( v70 < a2 )
                          *(_BYTE *)(v55 + v70) = 39;
                        if ( ++v70 < a2 )
                          *(_BYTE *)(v55 + v70) = 36;
                        if ( ++v70 < a2 )
                          *(_BYTE *)(v55 + v70) = 39;
                        ++v70;
                        v58 = 1;
                      }
                      if ( v70 < a2 )
                        *(_BYTE *)(v55 + v70) = 92;
                      if ( ++v70 < a2 )
                        *(_BYTE *)(v70 + v55) = (v61 >> 6) + 48;
                      if ( ++v70 < a2 )
                        *(_BYTE *)(v70 + v55) = ((v61 >> 3) & 7) + 48;
                      ++v70;
                      v61 = (v61 & 7) + 48;
                    }
                    else if ( v63 )
                    {
                      if ( v70 < a2 )
                        *(_BYTE *)(v55 + v70) = 92;
                      ++v70;
                      v63 = 0;
                    }
                    if ( v69 + 1 >= v77 )
                      goto LABEL_216;
                    if ( v58 && v64 != 1 )
                    {
                      if ( v70 < a2 )
                        *(_BYTE *)(v55 + v70) = 39;
                      if ( ++v70 < a2 )
                        *(_BYTE *)(v55 + v70) = 39;
                      ++v70;
                      v58 = 0;
                    }
                    if ( v70 < a2 )
                      *(_BYTE *)(v70 + v55) = v61;
                    ++v70;
                    ++v69;
                    v24 = (int)v53;
                    v61 = v53[v69];
                  }
                }
              }
            }
          }
LABEL_193:
          if ( v56 != 1 || a5 == 2 )
          {
            v26 = &loc_804FC07;
            if ( v57 != 1 )
              v26 = &loc_804FC39;
            dword_8058178 = (int)v26;
            sub_8052E1A();
          }
          if ( v51 && (v10 = v61 & 0x1F, (*(_DWORD *)(4 * (v61 >> 5) + v51) >> v10) & 1) )
          {
            if ( v57 )
              goto LABEL_253;
            v64 = 1;
            if ( a5 == 2 && v58 != 1 )
            {
              if ( v70 < a2 )
                *(_BYTE *)(v55 + v70) = 39;
              if ( ++v70 < a2 )
                *(_BYTE *)(v55 + v70) = 36;
              if ( ++v70 < a2 )
                *(_BYTE *)(v55 + v70) = 39;
              ++v70;
              v58 = 1;
            }
            if ( v70 < a2 )
              *(_BYTE *)(v55 + v70) = 92;
            ++v70;
          }
          else
          {
            v27 = &loc_804FC5D;
            if ( v63 == 1 )
              v27 = &loc_804FC62;
            dword_8058114 = (int)v27;
            sub_8053080(v35);
          }
        }
LABEL_216:
        if ( v58 && v64 != 1 )
        {
          if ( v70 < a2 )
            *(_BYTE *)(v55 + v70) = 39;
          if ( ++v70 < a2 )
            *(_BYTE *)(v55 + v70) = 39;
          ++v70;
          v58 = 0;
        }
        if ( v70 < a2 )
          *(_BYTE *)(v70 + v55) = v61;
        ++v70;
        if ( v65 != 1 )
          v60 = 0;
LABEL_227:
        ++v69;
        break;
      case 0x7Bu:
      case 0x7Du:
        goto LABEL_109;
      default:
        goto LABEL_132;
    }
  }
  v29 = &loc_804FD9A;
  if ( v70 )
    v29 = &loc_804FDC4;
  dword_8058114 = (int)v29;
  sub_8053080(v35);
  if ( a5 == 2 )
  {
    v30 = &loc_804FDBF;
    if ( !v57 )
      v30 = &loc_804FDC4;
    dword_8058164 = (int)v30;
    sub_8052EA3();
LABEL_253:
    if ( a5 == 2 )
    {
      if ( v56 )
        a5 = 4;
    }
    result = sub_804F186(v55, a2, (int)v53, a4, a5, a6 & 0xFFFFFFFD, 0, v49, v47);
  }
  else if ( a5 != 2 || v57 == 1 )
  {
    if ( s && v57 != 1 )
    {
      v34 = &loc_804FED8;
      if ( *s )
        v34 = &loc_804FE95;
      dword_80581B4 = (int)v34;
      sub_8052CB5(v36);
    }
    if ( v70 < a2 )
      *(_BYTE *)(v55 + v70) = 0;
    result = v70;
  }
  else
  {
    v31 = &loc_804FDFC;
    if ( !v59 )
      v31 = &loc_804FE82;
    dword_805813C = (int)v31;
    sub_8052F9A(v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v49, v51, v53);
    v32 = &loc_804FE1B;
    if ( !v60 )
      v32 = &loc_804FE64;
    dword_8058128 = (int)v32;
    sub_805300C();
    result = sub_804F186(v55, v71, (int)v54, a4, 5, a6, v52, v50, v48);
  }
  return result;
}
// 8052BC2: using guessed type int __stdcall sub_8052BC2(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8052C34: using guessed type int __stdcall sub_8052C34(_DWORD);
// 8052CB5: using guessed type int __stdcall sub_8052CB5(_DWORD);
// 8052DB0: using guessed type int __fastcall sub_8052DB0(_DWORD, _DWORD);
// 8052E1A: using guessed type int sub_8052E1A(void);
// 8052EA3: using guessed type int sub_8052EA3(void);
// 8052F2E: using guessed type int __stdcall sub_8052F2E(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8052F9A: using guessed type int __stdcall sub_8052F9A(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 805300C: using guessed type int sub_805300C(void);
// 8053080: using guessed type int __stdcall sub_8053080(_DWORD);
// 8058114: using guessed type int dword_8058114;
// 8058128: using guessed type int dword_8058128;
// 805813C: using guessed type int dword_805813C;
// 8058150: using guessed type int dword_8058150;
// 8058164: using guessed type int dword_8058164;
// 8058178: using guessed type int dword_8058178;
// 805818C: using guessed type int dword_805818C;
// 80581B4: using guessed type int dword_80581B4;
// 80581C8: using guessed type int dword_80581C8;
// 80581DC: using guessed type int dword_80581DC;

//----- (08050027) --------------------------------------------------------
void *__cdecl sub_8050027(int a1, size_t a2, _DWORD *a3, int a4)
{
  int v4; // ST40_4
  int v5; // ST44_4
  int v7; // [esp+0h] [ebp-58h]
  unsigned int size; // [esp+48h] [ebp-10h]
  void *v9; // [esp+4Ch] [ebp-Ch]

  if ( a4 )
  {
    dword_8058114 = (int)&loc_805004B;
    sub_8053080(v7);
  }
  v4 = *__errno_location();
  v5 = *(&dword_8058823 + 1) | (a3 == 0);
  size = sub_804F186(
           0,
           0,
           a1,
           a2,
           dword_8058823,
           v5,
           (int)(&dword_8058823 + 2),
           (char *)*(&dword_8058823 + 10),
           (char *)*(&dword_8058823 + 11))
       + 1;
  v9 = sub_8051146(size);
  sub_804F186(
    (int)v9,
    size,
    a1,
    a2,
    dword_8058823,
    v5,
    (int)(&dword_8058823 + 2),
    (char *)*(&dword_8058823 + 10),
    (char *)*(&dword_8058823 + 11));
  *__errno_location() = v4;
  if ( a3 )
    *a3 = size - 1;
  return v9;
}
// 8053080: using guessed type int __stdcall sub_8053080(_DWORD);
// 8058114: using guessed type int dword_8058114;
// 8058823: using guessed type int dword_8058823;

//----- (08050202) --------------------------------------------------------
void *__cdecl sub_8050202(signed int a1, int a2, size_t a3, int a4)
{
  int *v4; // eax
  void *v5; // edx
  size_t v6; // ST4C_4
  int v7; // ecx
  int *v8; // edx
  void *v9; // eax
  bool v11; // [esp+37h] [ebp-21h]
  int *v12; // [esp+38h] [ebp-20h]
  void *ptr; // [esp+3Ch] [ebp-1Ch]
  int v14; // [esp+40h] [ebp-18h]
  int size; // [esp+44h] [ebp-14h]
  int v16; // [esp+48h] [ebp-10h]
  unsigned int v17; // [esp+4Ch] [ebp-Ch]

  v14 = *__errno_location();
  v12 = off_8058260;
  if ( a1 < 0 )
    abort();
  if ( dword_8058254 <= a1 )
  {
    v11 = off_8058260 == &dword_8058258;
    if ( (unsigned int)a1 > 0xFFFFFFE )
      sub_80512F4();
    if ( v11 )
      v4 = 0;
    else
      v4 = off_8058260;
    v12 = (int *)sub_8051195(v4, 8 * (a1 + 1));
    off_8058260 = v12;
    if ( v11 )
    {
      v5 = off_805825C;
      *v12 = dword_8058258;
      v12[1] = (int)v5;
    }
    memset(&v12[2 * dword_8058254], 0, 8 * (a1 + 1 - dword_8058254));
    dword_8058254 = a1 + 1;
  }
  v6 = v12[2 * a1];
  ptr = (void *)v12[2 * a1 + 1];
  v16 = *(_DWORD *)(a4 + 4) | 1;
  v17 = sub_804F186(
          v12[2 * a1 + 1],
          v12[2 * a1],
          a2,
          a3,
          *(_DWORD *)a4,
          v16,
          a4 + 8,
          *(char **)(a4 + 40),
          *(char **)(a4 + 44));
  if ( v6 <= v17 )
  {
    v8 = &v12[2 * a1];
    size = v17 + 1;
    *v8 = v17 + 1;
    v9 = &loc_80503B4;
    if ( ptr == &unk_8058863 )
      v9 = &loc_80503BF;
    dword_805818C = (int)v9;
    sub_8052DB0(v7, v8);
    free(ptr);
    ptr = sub_8051146(size);
    v12[2 * a1 + 1] = (int)ptr;
    sub_804F186((int)ptr, size, a2, a3, *(_DWORD *)a4, v16, a4 + 8, *(char **)(a4 + 40), *(char **)(a4 + 44));
  }
  *__errno_location() = v14;
  return ptr;
}
// 8052DB0: using guessed type int __fastcall sub_8052DB0(_DWORD, _DWORD);
// 805818C: using guessed type int dword_805818C;
// 8058254: using guessed type int dword_8058254;
// 8058258: using guessed type int dword_8058258;
// 805825C: using guessed type void *off_805825C;
// 8058260: using guessed type int *off_8058260;

//----- (08050444) --------------------------------------------------------
void *__cdecl sub_8050444(signed int a1, int a2)
{
  return sub_8050202(a1, a2, 0xFFFFFFFF, (int)&dword_8058823);
}
// 8058823: using guessed type int dword_8058823;

//----- (08050480) --------------------------------------------------------
void *__cdecl sub_8050480(signed int a1, int a2, size_t a3)
{
  return sub_8050202(a1, a2, a3, (int)&dword_8058823);
}
// 8058823: using guessed type int dword_8058823;

//----- (080504E6) --------------------------------------------------------
void __cdecl __noreturn sub_80504E6(int a1, int a2)
{
  char v2; // [esp+10h] [ebp-38h]

  sub_804F018((int)&v2, a2);
}

//----- (08050524) --------------------------------------------------------
void __cdecl __noreturn sub_8050524(int a1, int a2)
{
  char v2; // [esp+10h] [ebp-38h]

  sub_804F018((int)&v2, a2);
}

//----- (08050561) --------------------------------------------------------
void __cdecl __noreturn sub_8050561(int a1)
{
  sub_80504E6(0, a1);
}

//----- (080505BE) --------------------------------------------------------
void *__cdecl sub_80505BE(int a1, size_t a2, unsigned __int8 a3)
{
  int v4; // [esp+20h] [ebp-38h]
  int v5; // [esp+24h] [ebp-34h]
  int v6; // [esp+28h] [ebp-30h]
  int v7; // [esp+2Ch] [ebp-2Ch]
  int v8; // [esp+30h] [ebp-28h]
  int v9; // [esp+34h] [ebp-24h]
  int v10; // [esp+38h] [ebp-20h]
  int v11; // [esp+3Ch] [ebp-1Ch]
  int v12; // [esp+40h] [ebp-18h]
  int v13; // [esp+44h] [ebp-14h]
  int v14; // [esp+48h] [ebp-10h]
  int v15; // [esp+4Ch] [ebp-Ch]

  v4 = dword_8058823;
  v5 = dword_8058827;
  v6 = dword_805882B;
  v7 = dword_805882F;
  v8 = dword_8058833;
  v9 = dword_8058837;
  v10 = dword_805883B;
  v11 = dword_805883F;
  v12 = dword_8058843;
  v13 = dword_8058847;
  v14 = dword_805884B;
  v15 = dword_805884F;
  sub_804EF21(&v4, a3, 1);
  return sub_8050202(0, a1, a2, (int)&v4);
}
// 8058823: using guessed type int dword_8058823;
// 8058827: using guessed type int dword_8058827;
// 805882B: using guessed type int dword_805882B;
// 805882F: using guessed type int dword_805882F;
// 8058833: using guessed type int dword_8058833;
// 8058837: using guessed type int dword_8058837;
// 805883B: using guessed type int dword_805883B;
// 805883F: using guessed type int dword_805883F;
// 8058843: using guessed type int dword_8058843;
// 8058847: using guessed type int dword_8058847;
// 805884B: using guessed type int dword_805884B;
// 805884F: using guessed type int dword_805884F;

//----- (08050668) --------------------------------------------------------
void *__cdecl sub_8050668(int a1, unsigned __int8 a2)
{
  return sub_80505BE(a1, 0xFFFFFFFF, a2);
}

//----- (08050691) --------------------------------------------------------
void *__cdecl sub_8050691(int a1)
{
  return sub_8050668(a1, 0x3Au);
}

//----- (080506CE) --------------------------------------------------------
void __cdecl __noreturn sub_80506CE(int a1, int a2)
{
  char v2; // [esp+10h] [ebp-68h]

  sub_804F018((int)&v2, a2);
}

//----- (0805076F) --------------------------------------------------------
void *__cdecl sub_805076F(signed int a1, int a2, int a3, int a4)
{
  return sub_805079F(a1, a2, a3, a4, 0xFFFFFFFF);
}

//----- (0805079F) --------------------------------------------------------
void *__cdecl sub_805079F(signed int a1, int a2, int a3, int a4, size_t a5)
{
  int v6; // [esp+10h] [ebp-38h]
  int v7; // [esp+14h] [ebp-34h]
  int v8; // [esp+18h] [ebp-30h]
  int v9; // [esp+1Ch] [ebp-2Ch]
  int v10; // [esp+20h] [ebp-28h]
  int v11; // [esp+24h] [ebp-24h]
  int v12; // [esp+28h] [ebp-20h]
  int v13; // [esp+2Ch] [ebp-1Ch]
  int v14; // [esp+30h] [ebp-18h]
  int v15; // [esp+34h] [ebp-14h]
  int v16; // [esp+38h] [ebp-10h]
  int v17; // [esp+3Ch] [ebp-Ch]

  v6 = dword_8058823;
  v7 = dword_8058827;
  v8 = dword_805882B;
  v9 = dword_805882F;
  v10 = dword_8058833;
  v11 = dword_8058837;
  v12 = dword_805883B;
  v13 = dword_805883F;
  v14 = dword_8058843;
  v15 = dword_8058847;
  v16 = dword_805884B;
  v17 = dword_805884F;
  sub_804EFCB(&v6, a2, a3);
  return sub_8050202(a1, a4, a5, (int)&v6);
}
// 8058823: using guessed type int dword_8058823;
// 8058827: using guessed type int dword_8058827;
// 805882B: using guessed type int dword_805882B;
// 805882F: using guessed type int dword_805882F;
// 8058833: using guessed type int dword_8058833;
// 8058837: using guessed type int dword_8058837;
// 805883B: using guessed type int dword_805883B;
// 805883F: using guessed type int dword_805883F;
// 8058843: using guessed type int dword_8058843;
// 8058847: using guessed type int dword_8058847;
// 805884B: using guessed type int dword_805884B;
// 805884F: using guessed type int dword_805884F;

//----- (080508A9) --------------------------------------------------------
void *__cdecl sub_80508A9(signed int a1, int a2, size_t a3)
{
  return sub_8050202(a1, a2, a3, (int)&unk_8058274);
}

//----- (080508F4) --------------------------------------------------------
void *__cdecl sub_80508F4(signed int a1, int a2)
{
  return sub_80508A9(a1, a2, 0xFFFFFFFF);
}

//----- (08050916) --------------------------------------------------------
void *__cdecl sub_8050916(int a1)
{
  return sub_80508F4(0, a1);
}

//----- (08050931) --------------------------------------------------------
int __cdecl sub_8050931(int fd)
{
  return sub_8051AB5(fd, 0, 3);
}

//----- (08050964) --------------------------------------------------------
int __cdecl sub_8050964(FILE *stream, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // ST00_4
  int v7; // ST04_4
  char *v8; // eax
  char *v9; // eax
  int v10; // ebx
  char *v11; // eax
  int result; // eax
  int v13; // esi
  int v14; // ebx
  char *v15; // eax
  int v16; // ST00_4
  int v17; // ST04_4
  int v18; // edi
  int v19; // esi
  int v20; // ebx
  char *v21; // eax
  int v22; // ST4C_4
  int v23; // edi
  int v24; // esi
  int v25; // ebx
  char *v26; // eax
  int v27; // ST4C_4
  int v28; // ST48_4
  int v29; // edi
  int v30; // esi
  int v31; // ebx
  char *v32; // eax
  int v33; // ST4C_4
  int v34; // ST48_4
  int v35; // ST44_4
  int v36; // edi
  int v37; // esi
  int v38; // ebx
  char *v39; // eax
  int v40; // esi
  int v41; // ST4C_4
  int v42; // ST48_4
  int v43; // ST44_4
  int v44; // ST40_4
  int v45; // edi
  int v46; // ebx
  char *v47; // eax
  int v48; // edi
  int v49; // ST4C_4
  int v50; // ST48_4
  int v51; // ST44_4
  int v52; // ST40_4
  int v53; // ST3C_4
  int v54; // esi
  int v55; // ebx
  char *v56; // eax
  int v57; // edi
  int v58; // ST4C_4
  int v59; // ST48_4
  int v60; // ST44_4
  int v61; // ST40_4
  int v62; // ST3C_4
  int v63; // ST38_4
  int v64; // esi
  int v65; // ebx
  char *v66; // eax
  int v67; // edi
  int v68; // ST4C_4
  int v69; // ST48_4
  int v70; // ST44_4
  int v71; // ST40_4
  int v72; // ST3C_4
  int v73; // ST38_4
  int v74; // esi
  int v75; // ebx
  char *v76; // eax
  int v77; // [esp+10h] [ebp-58h]
  int v78; // [esp+14h] [ebp-54h]
  int v79; // [esp+18h] [ebp-50h]
  int v80; // [esp+1Ch] [ebp-4Ch]
  int v81; // [esp+20h] [ebp-48h]
  int v82; // [esp+24h] [ebp-44h]
  int v83; // [esp+28h] [ebp-40h]
  int v84; // [esp+2Ch] [ebp-3Ch]
  int v85; // [esp+30h] [ebp-38h]
  int v86; // [esp+34h] [ebp-34h]
  int v87; // [esp+38h] [ebp-30h]
  int v88; // [esp+3Ch] [ebp-2Ch]

  if ( a2 )
  {
    fprintf(stream, "%s (%s) %s\n");
    dword_80581DC = (int)&loc_80509CB;
    sub_8052BC2(v6, v7, a2, a3, a4, v78, v79, v80, v81, v82, v83, v84, v85, v86, v87, v88);
  }
  fprintf(stream, "%s %s\n", a3, a4);
  v8 = gettext("(C)");
  fprintf(stream, "Copyright %s %d Free Software Foundation, Inc.", v8, 2017);
  v9 = gettext(
         "\n"
         "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\n"
         "This is free software: you are free to change and redistribute it.\n"
         "There is NO WARRANTY, to the extent permitted by law.\n"
         "\n");
  fputs_unlocked(v9, stream);
  switch ( a6 )
  {
    case 0:
      abort();
      return result;
    case 1:
      v10 = *(_DWORD *)a5;
      v11 = gettext("Written by %s.\n");
      return fprintf(stream, v11, v10);
    case 2:
      v13 = *(_DWORD *)(a5 + 4);
      v14 = *(_DWORD *)a5;
      v15 = gettext("Written by %s and %s.\n");
      fprintf(stream, v15);
      dword_805813C = (int)&loc_8050E8A;
      sub_8052F9A(v16, v17, v14, v13, v77, v78, v79, v80, v81, v82, v83, v84, v85, v86, v87);
      goto LABEL_7;
    case 3:
LABEL_7:
      v18 = *(_DWORD *)(a5 + 8);
      v19 = *(_DWORD *)(a5 + 4);
      v20 = *(_DWORD *)a5;
      v21 = gettext("Written by %s, %s, and %s.\n");
      return fprintf(stream, v21, v20, v19, v18);
    case 4:
      v22 = *(_DWORD *)(a5 + 12);
      v23 = *(_DWORD *)(a5 + 8);
      v24 = *(_DWORD *)(a5 + 4);
      v25 = *(_DWORD *)a5;
      v26 = gettext("Written by %s, %s, %s,\nand %s.\n");
      return fprintf(stream, v26, v25, v24, v23, v22);
    case 5:
      v27 = *(_DWORD *)(a5 + 16);
      v28 = *(_DWORD *)(a5 + 12);
      v29 = *(_DWORD *)(a5 + 8);
      v30 = *(_DWORD *)(a5 + 4);
      v31 = *(_DWORD *)a5;
      v32 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
      return fprintf(stream, v32, v31, v30, v29, v28, v27);
    case 6:
      v33 = *(_DWORD *)(a5 + 20);
      v34 = *(_DWORD *)(a5 + 16);
      v35 = *(_DWORD *)(a5 + 12);
      v36 = *(_DWORD *)(a5 + 8);
      v37 = *(_DWORD *)(a5 + 4);
      v38 = *(_DWORD *)a5;
      v39 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
      fprintf(stream, v39, v38, v37, v36, v35, v34, v33);
      dword_8058178 = (int)&loc_8050E8A;
      sub_8052E1A();
      goto LABEL_11;
    case 7:
LABEL_11:
      v40 = *(_DWORD *)(a5 + 24);
      v41 = *(_DWORD *)(a5 + 20);
      v42 = *(_DWORD *)(a5 + 16);
      v43 = *(_DWORD *)(a5 + 12);
      v44 = *(_DWORD *)(a5 + 8);
      v45 = *(_DWORD *)(a5 + 4);
      v46 = *(_DWORD *)a5;
      v47 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
      result = fprintf(stream, v47, v46, v45, v44, v43, v42, v41, v40);
      break;
    case 8:
      v48 = *(_DWORD *)(a5 + 28);
      v49 = *(_DWORD *)(a5 + 24);
      v50 = *(_DWORD *)(a5 + 20);
      v51 = *(_DWORD *)(a5 + 16);
      v52 = *(_DWORD *)(a5 + 12);
      v53 = *(_DWORD *)(a5 + 8);
      v54 = *(_DWORD *)(a5 + 4);
      v55 = *(_DWORD *)a5;
      v56 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
      result = fprintf(stream, v56, v55, v54, v53, v52, v51, v50, v49, v48);
      break;
    case 9:
      v57 = *(_DWORD *)(a5 + 32);
      v58 = *(_DWORD *)(a5 + 28);
      v59 = *(_DWORD *)(a5 + 24);
      v60 = *(_DWORD *)(a5 + 20);
      v61 = *(_DWORD *)(a5 + 16);
      v62 = *(_DWORD *)(a5 + 12);
      v63 = *(_DWORD *)(a5 + 8);
      v64 = *(_DWORD *)(a5 + 4);
      v65 = *(_DWORD *)a5;
      v66 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
      result = fprintf(stream, v66, v65, v64, v63, v62, v61, v60, v59, v58, v57);
      break;
    default:
      v67 = *(_DWORD *)(a5 + 32);
      v68 = *(_DWORD *)(a5 + 28);
      v69 = *(_DWORD *)(a5 + 24);
      v70 = *(_DWORD *)(a5 + 20);
      v71 = *(_DWORD *)(a5 + 16);
      v72 = *(_DWORD *)(a5 + 12);
      v73 = *(_DWORD *)(a5 + 8);
      v74 = *(_DWORD *)(a5 + 4);
      v75 = *(_DWORD *)a5;
      v76 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
      result = fprintf(stream, v76, v75, v74, v73, v72, v71, v70, v69, v68, v67);
      break;
  }
  return result;
}
// 8048F50: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8052BC2: using guessed type int __stdcall sub_8052BC2(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8052E1A: using guessed type int sub_8052E1A(void);
// 8052F9A: using guessed type int __stdcall sub_8052F9A(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 805813C: using guessed type int dword_805813C;
// 8058178: using guessed type int dword_8058178;
// 80581DC: using guessed type int dword_80581DC;

//----- (08050EF7) --------------------------------------------------------
int __cdecl sub_8050EF7(FILE *stream, int a2, int a3, int a4, int a5)
{
  void *v5; // eax
  int v7; // [esp+0h] [ebp-58h]
  int v8; // [esp+0h] [ebp-58h]
  int v9; // [esp+28h] [ebp-30h]
  int v10; // [esp+2Ch] [ebp-2Ch]

  dword_80581C8 = (int)&loc_8050F17;
  sub_8052C34(v7);
  v10 = *(_DWORD *)a5;
  v5 = &loc_8050F53;
  if ( v10 )
    v5 = &loc_8050F13;
  dword_8058114 = (int)v5;
  sub_8053080(v8);
  return sub_8050964(stream, a2, a3, a4, (int)&v9, 1);
}
// 8052C34: using guessed type int __stdcall sub_8052C34(_DWORD);
// 8053080: using guessed type int __stdcall sub_8053080(_DWORD);
// 8058114: using guessed type int dword_8058114;
// 80581C8: using guessed type int dword_80581C8;

//----- (08050F83) --------------------------------------------------------
int sub_8050F83(FILE *stream, int a2, int a3, int a4, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a4);
  return sub_8050EF7(stream, a2, a3, a4, (int)va);
}

//----- (08051096) --------------------------------------------------------
#error "80510C4: call analysis failed (funcsize=56)"

//----- (08051146) --------------------------------------------------------
void *__cdecl sub_8051146(size_t size)
{
  return sub_805116B(size);
}

//----- (0805116B) --------------------------------------------------------
void *__cdecl sub_805116B(size_t size)
{
  void *v2; // [esp+1Ch] [ebp-Ch]

  v2 = malloc(size);
  if ( !v2 && size )
    sub_80512F4();
  return v2;
}

//----- (08051195) --------------------------------------------------------
#error "80511F8: call analysis failed (funcsize=42)"

//----- (0805120D) --------------------------------------------------------
void *__cdecl sub_805120D(void *ptr, int a2)
{
  return sub_8051096(ptr, a2, 1);
}

//----- (08051259) --------------------------------------------------------
void *__cdecl sub_8051259(size_t nmemb, size_t size)
{
  void *v3; // [esp+1Ch] [ebp-Ch]

  if ( 0x7FFFFFFF / size < nmemb || (v3 = calloc(nmemb, size)) == 0 )
    sub_80512F4();
  return v3;
}

//----- (08051296) --------------------------------------------------------
void *__cdecl sub_8051296(void *src, size_t n)
{
  void *v2; // eax

  v2 = sub_805116B(n);
  return memcpy(v2, src, n);
}

//----- (080512F4) --------------------------------------------------------
void __noreturn sub_80512F4()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (0805133F) --------------------------------------------------------
void __cdecl __noreturn sub_805133F(int errnum)
{
  char *v1; // eax
  char *v2; // eax

  v1 = gettext("string comparison failed");
  error(0, errnum, v1);
  v2 = gettext("Set LC_ALL='C' to work around the problem.");
  error(0, 0, v2);
  sub_8050524(1, 8);
}

//----- (08051419) --------------------------------------------------------
#error "8051466: call analysis failed (funcsize=37)"

//----- (08051492) --------------------------------------------------------
#error "8051496: positive sp value has been found (funcsize=0)"

//----- (08051502) --------------------------------------------------------
signed int __cdecl sub_8051502(unsigned int *a1, unsigned int a2)
{
  signed int result; // eax

  if ( 0xFFFFFFFF / a2 >= *a1 )
  {
    *a1 *= a2;
    result = 0;
  }
  else
  {
    *a1 = -1;
    result = 1;
  }
  return result;
}

//----- (08051546) --------------------------------------------------------
int __cdecl sub_8051546(unsigned int *a1, unsigned int a2, int a3)
{
  int v3; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; i |= sub_8051502(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}

//----- (0805157C) --------------------------------------------------------
int __cdecl sub_805157C(char *nptr, int a2, int base, int a4, char *s)
{
  char **v5; // eax
  const unsigned __int16 **v6; // eax
  int v7; // ecx
  int v8; // edx
  bool v9; // zf
  void *v10; // eax
  int result; // eax
  void *v12; // eax
  int v13; // eax
  int v14; // ST08_4
  int v15; // [esp+0h] [ebp-48h]
  unsigned __int8 v16; // [esp+1Fh] [ebp-29h]
  char v17; // [esp+20h] [ebp-28h]
  unsigned int v18; // [esp+24h] [ebp-24h]
  int v19; // [esp+28h] [ebp-20h]
  char *v20; // [esp+2Ch] [ebp-1Ch]
  unsigned int v21; // [esp+30h] [ebp-18h]
  int v22; // [esp+34h] [ebp-14h]
  int v23; // [esp+38h] [ebp-10h]
  char **endptr; // [esp+3Ch] [ebp-Ch]

  v19 = 0;
  if ( base < 0 || base > 36 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoul");
  if ( a2 )
    v5 = (char **)a2;
  else
    v5 = (char **)&v17;
  endptr = v5;
  *__errno_location() = 0;
  v20 = nptr;
  v16 = *nptr;
  v6 = __ctype_b_loc();
  v8 = v16;
  v9 = ((*v6)[v8] & 0x2000) == 0;
  v10 = &loc_805162C;
  if ( !v9 )
    v10 = &loc_80515E8;
  dword_805818C = (int)v10;
  sub_8052DB0(v7, v8 * 2);
  if ( v16 == 45 )
    return 4;
  v18 = strtoul(nptr, endptr, base);
  if ( *endptr == nptr )
  {
    if ( !s || !**endptr || !strchr(s, **endptr) )
      return 4;
    v18 = 1;
  }
  else
  {
    v9 = *__errno_location() == 0;
    v12 = &loc_80516C9;
    if ( v9 )
      v12 = &loc_80516E6;
    dword_80581C8 = (int)v12;
    sub_8052C34(v15);
    if ( *__errno_location() != 34 )
      return 4;
    v19 = 1;
  }
  if ( !s )
  {
    *(_DWORD *)a4 = v18;
    return v19;
  }
  if ( !**endptr )
  {
LABEL_53:
    *(_DWORD *)a4 = v18;
    return v19;
  }
  v21 = 1024;
  v22 = 1;
  if ( !strchr(s, **endptr) )
  {
    *(_DWORD *)a4 = v18;
    return v19 | 2;
  }
  switch ( **endptr )
  {
    case 69:
    case 71:
    case 75:
    case 77:
    case 80:
    case 84:
    case 89:
    case 90:
    case 103:
    case 107:
    case 109:
    case 116:
      if ( !strchr(s, 48) )
        goto LABEL_37;
      v13 = (*endptr)[1];
      switch ( v13 )
      {
        case 68:
          goto LABEL_36;
        case 105:
          if ( (*endptr)[2] == 66 )
          {
            v22 += 2;
            break;
          }
          dword_8058178 = (int)&loc_80517CC;
          sub_8052E1A();
          goto LABEL_36;
        case 66:
LABEL_36:
          v21 = 1000;
          ++v22;
          break;
      }
LABEL_37:
      switch ( **endptr )
      {
        case 66:
          v23 = sub_8051502(&v18, 0x400u);
          goto LABEL_51;
        case 69:
          v23 = sub_8051546(&v18, v21, 6);
          goto LABEL_51;
        case 71:
        case 103:
          v23 = sub_8051546(&v18, v21, 3);
          dword_80581B4 = (int)&loc_805197E;
          sub_8052CB5(v14);
          goto LABEL_43;
        case 75:
        case 107:
LABEL_43:
          v23 = sub_8051546(&v18, v21, 1);
          goto LABEL_51;
        case 77:
        case 109:
          v23 = sub_8051546(&v18, v21, 2);
          dword_8058128 = (int)&loc_805197E;
          sub_805300C();
          goto LABEL_45;
        case 80:
LABEL_45:
          v23 = sub_8051546(&v18, v21, 5);
          goto LABEL_51;
        case 84:
        case 116:
          v23 = sub_8051546(&v18, v21, 4);
          goto LABEL_51;
        case 89:
          goto LABEL_48;
        case 90:
          v23 = sub_8051546(&v18, v21, 7);
          goto LABEL_51;
        case 98:
          v23 = sub_8051502(&v18, 0x200u);
          goto LABEL_51;
        case 99:
          v23 = 0;
          goto LABEL_51;
        case 119:
          v23 = sub_8051502(&v18, 2u);
          dword_8058178 = (int)&loc_805197E;
          sub_8052E1A();
LABEL_48:
          v23 = sub_8051546(&v18, v21, 8);
LABEL_51:
          v19 |= v23;
          *endptr += v22;
          if ( **endptr )
            v19 |= 2u;
          goto LABEL_53;
        default:
          *(_DWORD *)a4 = v18;
          result = v19 | 2;
          break;
      }
      return result;
    default:
      goto LABEL_37;
  }
}
// 805157C: could not find valid save-restore pair for ebx
// 8052C34: using guessed type int __stdcall sub_8052C34(_DWORD);
// 8052CB5: using guessed type int __stdcall sub_8052CB5(_DWORD);
// 8052DB0: using guessed type int __fastcall sub_8052DB0(_DWORD, _DWORD);
// 8052E1A: using guessed type int sub_8052E1A(void);
// 805300C: using guessed type int sub_805300C(void);
// 8058128: using guessed type int dword_8058128;
// 8058178: using guessed type int dword_8058178;
// 805818C: using guessed type int dword_805818C;
// 80581B4: using guessed type int dword_80581B4;
// 80581C8: using guessed type int dword_80581C8;

//----- (080519B0) --------------------------------------------------------
int __cdecl sub_80519B0(FILE *stream)
{
  bool v2; // zf
  void *v3; // eax
  int v4; // eax
  __int64 v5; // rax
  int v6; // [esp+0h] [ebp-28h]
  int v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+18h] [ebp-10h]

  v7 = 0;
  if ( fileno(stream) < 0 )
    return fclose(stream);
  v2 = __freading(stream) == 0;
  v3 = &loc_8051A10;
  if ( v2 )
    v3 = &loc_8051A62;
  dword_80581B4 = (int)v3;
  sub_8052CB5(v6);
  v4 = fileno(stream);
  LODWORD(v5) = lseek64(v4, 0, 0, 1);
  v2 = v5 == -1;
  LODWORD(v5) = &loc_8051A62;
  if ( v2 )
    LODWORD(v5) = &loc_8051A7B;
  dword_805818C = v5;
  sub_8052DB0(~HIDWORD(v5), HIDWORD(v5));
  if ( sub_8051C65(stream) )
    v7 = *__errno_location();
  v8 = fclose(stream);
  if ( v7 )
  {
    *__errno_location() = v7;
    v8 = -1;
  }
  return v8;
}
// 80519B0: could not find valid save-restore pair for ebx
// 8049090: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8052CB5: using guessed type int __stdcall sub_8052CB5(_DWORD);
// 8052DB0: using guessed type int __fastcall sub_8052DB0(_DWORD, _DWORD);
// 805818C: using guessed type int dword_805818C;
// 80581B4: using guessed type int dword_80581B4;

//----- (08051AB5) --------------------------------------------------------
#error "8051B63: call analysis failed (funcsize=102)"

//----- (08051C2C) --------------------------------------------------------
int __cdecl sub_8051C2C(FILE *stream)
{
  int result; // eax

  result = stream->_flags & 0x100;
  if ( result )
    result = sub_8051CA5(stream, 0, 0, 1);
  return result;
}

//----- (08051C65) --------------------------------------------------------
int __cdecl sub_8051C65(FILE *fp)
{
  if ( !fp || !__freading(fp) )
    return fflush(fp);
  sub_8051C2C(fp);
  return fflush(fp);
}

//----- (08051CA5) --------------------------------------------------------
#error "8051CDB: call analysis failed (funcsize=79)"

//----- (08051D8C) --------------------------------------------------------
size_t __cdecl sub_8051D8C(wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  char v5; // [esp+18h] [ebp-10h]
  size_t v6; // [esp+1Ch] [ebp-Ch]

  if ( !pwc )
    pwc = (wchar_t *)&v5;
  v6 = mbrtowc(pwc, s, n, p);
  if ( v6 <= 0xFFFFFFFD || !n || !((unsigned __int8)sub_804EA58(0) ^ 1) )
    return v6;
  *pwc = (unsigned __int8)*s;
  return 1;
}

//----- (08051DFE) --------------------------------------------------------
int __cdecl sub_8051DFE(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // esi
  unsigned __int8 *v3; // ebx
  int v5; // [esp+0h] [ebp-28h]
  unsigned __int8 v6; // [esp+1Eh] [ebp-Ah]
  unsigned __int8 v7; // [esp+1Fh] [ebp-9h]

  v2 = a1;
  v3 = a2;
  if ( a1 == a2 )
  {
    dword_8058114 = (int)&loc_8051E75;
    sub_8053080(v5);
  }
  do
  {
    v6 = sub_8052929(*v2);
    v7 = sub_8052929(*v3);
    if ( !v6 )
      break;
    ++v2;
    ++v3;
  }
  while ( v6 == v7 );
  return v6 - v7;
}
// 8053080: using guessed type int __stdcall sub_8053080(_DWORD);
// 8058114: using guessed type int dword_8058114;

//----- (08051E7C) --------------------------------------------------------
int __cdecl sub_8051E7C(FILE *fp)
{
  bool v1; // ST1E_1
  bool v3; // [esp+1Dh] [ebp-Bh]
  bool v4; // [esp+1Fh] [ebp-9h]

  v3 = __fpending(fp) != 0;
  v1 = ferror_unlocked(fp) != 0;
  v4 = sub_80519B0(fp) != 0;
  if ( !v1 && (!v4 || !v3 && *__errno_location() == 9) )
    return 0;
  if ( v4 != 1 )
    *__errno_location() = 0;
  return -1;
}

//----- (08051EFD) --------------------------------------------------------
void *sub_8051EFD()
{
  _BOOL4 v0; // eax
  bool v1; // zf
  void *v2; // eax
  int v4; // [esp-14h] [ebp-C8h]
  int v5; // [esp-14h] [ebp-C8h]
  int v6; // [esp-10h] [ebp-C4h]
  int v7; // [esp-Ch] [ebp-C0h]
  int v8; // [esp-8h] [ebp-BCh]
  int v9; // [esp-4h] [ebp-B8h]
  void *v10; // [esp+4h] [ebp-B0h]
  const char *s; // [esp+8h] [ebp-ACh]
  void *v12; // [esp+Ch] [ebp-A8h]
  int v13; // [esp+10h] [ebp-A4h]
  size_t n; // [esp+18h] [ebp-9Ch]
  size_t v15; // [esp+1Ch] [ebp-98h]
  _BOOL4 v16; // [esp+20h] [ebp-94h]
  char *dest; // [esp+24h] [ebp-90h]
  int fd; // [esp+28h] [ebp-8Ch]

  v10 = (void *)dword_8058967;
  if ( !dword_8058967 )
  {
    s = getenv("CHARSETALIASDIR");
    if ( !s || !*s )
      s = "/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib";
    n = strlen(s);
    v15 = strlen("charset.alias");
    v0 = n && s[n - 1] != 47;
    v16 = v0;
    dest = (char *)malloc(n + v0 + v15 + 1);
    if ( dest )
    {
      memcpy(dest, s, n);
      if ( v16 )
        dest[n] = 47;
      memcpy(&dest[n + v16], "charset.alias", v15 + 1);
    }
    free(0);
    if ( !dest )
    {
      dword_8058114 = (int)&loc_8052436;
      sub_8053080(v4);
    }
    fd = open64(dest, 0x20000);
    if ( fd < 0 )
    {
      dword_805813C = (int)&loc_8052428;
      sub_8052F9A(v5, v6, v7, v8, v9, 0, &unk_8054987, s, v12, v13, "charset.alias", n, v15, v16, dest);
    }
    v1 = fdopen(fd, "r") == 0;
    v2 = &loc_8052132;
    if ( !v1 )
      v2 = &loc_805214F;
    dword_8058178 = (int)v2;
    sub_8052E1A();
    close(fd);
    v10 = &unk_8054987;
    free(dest);
    dword_8058967 = (int)&unk_8054987;
  }
  return v10;
}
// 8048D60: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 8052E1A: using guessed type int sub_8052E1A(void);
// 8052F9A: using guessed type int __stdcall sub_8052F9A(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8053080: using guessed type int __stdcall sub_8053080(_DWORD);
// 8058114: using guessed type int dword_8058114;
// 805813C: using guessed type int dword_805813C;
// 8058178: using guessed type int dword_8058178;
// 8058967: using guessed type int dword_8058967;

//----- (08052461) --------------------------------------------------------
char *sub_8052461()
{
  bool v0; // zf
  void *v1; // eax
  char *v2; // ST24_4
  char *s1; // [esp+18h] [ebp-10h]
  char *s2; // [esp+1Ch] [ebp-Ch]

  v0 = nl_langinfo(14) == 0;
  v1 = &loc_8052495;
  if ( !v0 )
    v1 = &loc_805249C;
  dword_8058128 = (int)v1;
  sub_805300C();
  s1 = (char *)&unk_8054987;
  s2 = (char *)sub_8051EFD();
  dword_8058164 = (int)&loc_805251A;
  sub_8052EA3();
  while ( strcmp((const char *)&unk_8054987, s2) && (*s2 != 42 || s2[1]) )
  {
    v2 = &s2[strlen(s2) + 1];
    s2 = &v2[strlen(v2) + 1];
    if ( !*s2 )
      goto LABEL_9;
  }
  s1 = &s2[strlen(s2) + 1];
LABEL_9:
  if ( !*s1 )
    s1 = "ASCII";
  return s1;
}
// 8052EA3: using guessed type int sub_8052EA3(void);
// 805300C: using guessed type int sub_805300C(void);
// 8058128: using guessed type int dword_8058128;
// 8058164: using guessed type int dword_8058164;

//----- (0805253A) --------------------------------------------------------
#error "80525D7: call analysis failed (funcsize=63)"

//----- (08052600) --------------------------------------------------------
int __cdecl sub_8052600(void *s1, size_t n, void *s2, int a4)
{
  char v4; // ST1A_1
  char v5; // ST1B_1
  int v6; // ST1C_4

  if ( n == a4 && !memcmp(s1, s2, n) )
  {
    *__errno_location() = 0;
    dword_8058178 = (int)&loc_80526CD;
    sub_8052E1A();
  }
  v4 = *((_BYTE *)s1 + n);
  v5 = *((_BYTE *)s2 + a4);
  *((_BYTE *)s1 + n) = 0;
  *((_BYTE *)s2 + a4) = 0;
  v6 = sub_805253A((char *)s1, n + 1, (char *)s2, a4 + 1);
  *((_BYTE *)s1 + n) = v4;
  *((_BYTE *)s2 + a4) = v5;
  return v6;
}
// 8052E1A: using guessed type int sub_8052E1A(void);
// 8058178: using guessed type int dword_8058178;

//----- (080526D2) --------------------------------------------------------
int __cdecl sub_80526D2(void *s1, size_t n, void *s2, int a4)
{
  if ( n != a4 || memcmp(s1, s2, n) )
    return sub_805253A((char *)s1, n, (char *)s2, a4);
  *__errno_location() = 0;
  return 0;
}

//----- (08052929) --------------------------------------------------------
int __cdecl sub_8052929(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 65) > 0x19 )
    result = a1;
  else
    result = a1 + 32;
  return result;
}

//----- (080529E7) --------------------------------------------------------
int __cdecl sub_80529E7(int a1)
{
  return __cxa_atexit(a1, 0, dword_8058218);
}
// 8048EB0: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 8058218: using guessed type int dword_8058218;

//----- (08052A42) --------------------------------------------------------
#error "8052A7B: positive sp value has been found (funcsize=18)"

//----- (08052BC2) --------------------------------------------------------
#error "8052BC8: positive sp value has been found (funcsize=0)"

//----- (08052C34) --------------------------------------------------------
#error "8052C3A: positive sp value has been found (funcsize=0)"

//----- (08052CB5) --------------------------------------------------------
#error "8052CBB: positive sp value has been found (funcsize=0)"

//----- (08052D42) --------------------------------------------------------
#error "8052D48: positive sp value has been found (funcsize=0)"

//----- (08052DB0) --------------------------------------------------------
#error "8052DB6: positive sp value has been found (funcsize=0)"

//----- (08052E1A) --------------------------------------------------------
#error "8052E20: positive sp value has been found (funcsize=0)"

//----- (08052E62) --------------------------------------------------------
#error "8052E9B: positive sp value has been found (funcsize=18)"

//----- (08052EA3) --------------------------------------------------------
#error "8052EA9: positive sp value has been found (funcsize=0)"

//----- (08052EED) --------------------------------------------------------
#error "8052F26: positive sp value has been found (funcsize=18)"

//----- (08052F2E) --------------------------------------------------------
#error "8052F34: positive sp value has been found (funcsize=0)"

//----- (08052F9A) --------------------------------------------------------
#error "8052FA0: positive sp value has been found (funcsize=0)"

//----- (0805300C) --------------------------------------------------------
#error "8053012: positive sp value has been found (funcsize=0)"

//----- (08053080) --------------------------------------------------------
#error "8053086: positive sp value has been found (funcsize=0)"

//----- (08053090) --------------------------------------------------------
int (**sub_8053090())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_8057ECC;
  v1 = &off_8057ED0 - off_8057ECC;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_8057ECC[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 8057ECC: using guessed type int (*off_8057ECC[2])();
// 8057ED0: using guessed type int (*off_8057ED0)();

//----- (080530F4) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 37 decompilation failure(s) on 167 function(s)"
