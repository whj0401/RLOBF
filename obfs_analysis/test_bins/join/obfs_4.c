/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8048D40();
// int strcmp(const char *s1, const char *s2);
// int __cdecl open64(_DWORD, _DWORD); weak
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void _exit(int status);
// void free(void *ptr);
// void *memcpy(void *dest, const void *src, size_t n);
// int fclose(FILE *stream);
// int getc_unlocked(FILE *stream);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// char *textdomain(const char *domainname);
// int __cdecl fopen64(_DWORD, _DWORD); weak
// int ferror_unlocked(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// size_t __ctype_get_mb_cur_max(void);
// char *strcpy(char *dest, const char *src);
// size_t __fpending(FILE *fp);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// void error(int status, int errnum, const char *format, ...);
// int strcoll(const char *s1, const char *s2);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// char *strchr(const char *s, int c);
// int fscanf(FILE *stream, const char *format, ...);
// size_t strlen(const char *s);
// int fprintf(FILE *stream, const char *format, ...);
// int fcntl(int fd, int cmd, ...);
// void *memset(void *s, int c, size_t n);
// int ungetc(int c, FILE *stream);
// int *__errno_location(void);
// void *memchr(const void *s, int c, size_t n);
// int fileno(FILE *stream);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// char *strpbrk(const char *s, const char *accept);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// int toupper(int c);
// char *strrchr(const char *s, int c);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// char *bindtextdomain(const char *domainname, const char *dirname);
// int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// int feof_unlocked(FILE *stream);
// void abort(void);
// int close(int fd);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// void *calloc(size_t nmemb, size_t size);
// int putchar_unlocked(int c);
// int _gmon_start__(void); weak
void sub_8049183();
void sub_80491A0();
int sub_80491B0();
int sub_8049220();
int sub_8049240();
void sub_804929F();
void sub_80492BA();
int sub_80492CA();
void sub_80493AC();
void sub_80493C7();
signed int sub_80493D7();
void sub_80494B9();
void sub_80494D4();
int sub_80494E4();
void sub_80495C6();
void sub_80495E1();
int sub_80495F1();
void sub_80496D3();
void sub_80496EE();
int sub_80496FE();
void sub_80497E0();
void sub_80497FB();
int sub_804980B();
void sub_80498ED();
void sub_8049908();
int sub_8049918();
int nullsub_3(void); // weak
int sub_804998F();
void sub_8049A2F();
void sub_8049A4A();
int sub_8049A5A();
int nullsub_4(void); // weak
int sub_8049AB8();
void sub_8049B62();
void sub_8049B7D();
int sub_8049B8D();
void sub_8049C6F();
void sub_8049C8A();
int sub_8049C9A();
// int __usercall sub_8049D01@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
void sub_8049D98();
void sub_8049DB3();
int sub_8049DC3();
void sub_8049EB2();
void sub_8049ECD();
// int __usercall sub_8049F6F@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
void sub_804A006();
void sub_804A031();
int sub_804A041();
// int __usercall sub_804A0A8@<eax>(int a1@<eax>, int (__cdecl *a2)(const char *, int)@<edx>);
_BOOL4 __cdecl sub_804A129(unsigned __int8 a1);
int __cdecl sub_804A191(char *s1); // idb
void __cdecl __noreturn sub_804A317(int status); // idb
int __cdecl sub_804A4A6(int a1, int a2, int a3);
int __cdecl sub_804A520(int a1);
int __cdecl sub_804A6CF(_DWORD); // weak
signed int __cdecl sub_804A719(int a1, int a2, unsigned int a3, unsigned int a4);
int __cdecl sub_804A8AD(int a1, int a2, int a3);
int __cdecl sub_804AA16(int a1);
void *__cdecl sub_804AA25(_DWORD *a1);
int __cdecl sub_804AA5F(FILE *stream, int, int); // idb
void sub_804ABCC();
_DWORD *__cdecl sub_804AC19(_DWORD *a1);
int __cdecl sub_804AC3B(FILE *stream, int, int); // idb
int __cdecl sub_804ACE8(FILE *stream, int, int, int); // idb
void __cdecl sub_804AD37(int a1);
char *__cdecl sub_804AE49(unsigned int a1, unsigned int a2, int a3);
char *__cdecl sub_804AEC6(unsigned int a1, int a2);
int sub_804AF83(); // weak
int sub_804B094(); // weak
char *__cdecl sub_804B195(unsigned int a1, int a2);
int __cdecl sub_804B3D5(FILE *stream, FILE *); // idb
_DWORD *__cdecl sub_804D2E7(int a1, int a2);
int __cdecl sub_804D3A0(char *nptr); // idb
int __cdecl sub_804D450(char *a1, _DWORD *a2, int *a3);
_DWORD *__cdecl sub_804D5CA(char *a1);
_DWORD *__cdecl sub_804D641(_DWORD *a1, int a2);
_DWORD __cdecl sub_804D6AB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_BOOL4 __cdecl main(int argc, char **argv);
int sub_804E2DB();
int __cdecl sub_804E3D8(int a1, int a2, int a3, int a4, int a5, int a6);
void __cdecl sub_804E429(FILE *stream, int a2);
int __cdecl sub_804E483(int, char *modes); // idb
int __cdecl sub_804E572(int category); // idb
int __cdecl sub_804E625(int a1, FILE *stream);
int __cdecl sub_804E76E(int a1, int a2, unsigned int a3);
int __cdecl sub_804E7FE(char *s); // idb
unsigned int __cdecl sub_804E9A2(int a1, unsigned __int8 a2, char a3);
int *__cdecl sub_804EA59(int *a1, int a2, int a3);
// _DWORD *__userpurge sub_804EAB3@<eax>(_DWORD *a1, int a2);
const char *__cdecl sub_804EB43(char *msgid, int a2);
unsigned int __cdecl sub_804EC1E(_BYTE *a1, unsigned int a2, _BYTE *a3, int a4, signed int a5, int a6, int a7, const char *a8, const char *a9);
_BYTE *__cdecl sub_804FAD8(_BYTE *a1, int a2, _DWORD *a3, int *a4);
_BYTE *__cdecl sub_804FC98(signed int a1, _BYTE *a2, int a3, int a4);
_BYTE *__cdecl sub_804FED3(signed int a1, _BYTE *a2);
_BYTE *__cdecl sub_804FEFD(signed int a1, _BYTE *a2, int a3);
_BYTE *__cdecl sub_804FF73(signed int a1, int a2, _BYTE *a3);
_BYTE *__cdecl sub_804FFBF(signed int a1, int a2, _BYTE *a3, int a4);
_BYTE *__cdecl sub_804FFFC(int a1, _BYTE *a2);
_BYTE *__cdecl sub_8050059(_BYTE *a1, int a2, unsigned __int8 a3);
_BYTE *__cdecl sub_8050103(_BYTE *a1, unsigned __int8 a2);
_BYTE *__cdecl sub_805014E(_BYTE *a1);
_BYTE *__cdecl sub_805018B(signed int a1, int a2, _BYTE *a3);
_BYTE *__cdecl sub_805023C(signed int a1, int a2, int a3, _BYTE *a4);
_BYTE *__cdecl sub_805027C(signed int a1, int a2, int a3, _BYTE *a4, int a5);
_BYTE *__cdecl sub_8050376(signed int a1, _BYTE *a2, int a3);
_BYTE *__cdecl sub_80503D3(signed int a1, _BYTE *a2);
_BYTE *__cdecl sub_8050407(_BYTE *a1);
int __cdecl sub_8050432(int fd); // idb
int __cdecl sub_8050455(FILE *stream, int, int, int, int, int); // idb
int __cdecl sub_80509C8(FILE *stream, int, int, int, int); // idb
int sub_8050A2E(FILE *stream, int a2, int a3, int a4, ...);
void *__cdecl sub_8050B41(void *ptr, int a2, int a3);
void *__cdecl sub_8050C03(size_t size);
void *__cdecl sub_8050C16(size_t size);
void *__cdecl sub_8050C5E(void *ptr, size_t size);
void *__cdecl sub_8050CC6(void *ptr, int a2);
void *__cdecl sub_8050D12(size_t nmemb, size_t size);
void *__cdecl sub_8050D6D(void *src, size_t n);
void __noreturn sub_8050DCB();
void __cdecl sub_8050E04(int errnum, int a2, int a3, int a4, int a5);
int __cdecl sub_8050EE2(void *s1, size_t n, void *s2, int); // idb
int __cdecl sub_8050FDD(unsigned int *a1, unsigned int a2);
int __cdecl sub_805103E(unsigned int *a1, unsigned int a2, int a3);
int __cdecl sub_8051084(char *nptr, int, int base, int, char *s); // idb
int __cdecl sub_80514EF(FILE *stream); // idb
int __cdecl sub_80515CB(int fd, int cmd, char); // idb
int __cdecl sub_8051760(FILE *stream); // idb
int __cdecl sub_80517B2(FILE *fp); // idb
int __cdecl sub_80517F2(FILE *stream, int, int, int); // idb
size_t __cdecl sub_80518C4(wchar_t *pwc, char *s, size_t n, mbstate_t *p);
int __cdecl sub_8051936(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_80519AB(FILE *fp); // idb
void *sub_8051A3E();
const char *sub_8051ED8();
int __cdecl sub_8051F9B(char *s, int, char *s2, int); // idb
int __cdecl sub_805207A(void *s1, size_t n, void *s2, int); // idb
int __cdecl sub_8052135(void *s1, size_t n, void *s2, int); // idb
int __cdecl sub_80523E2(int a1);
int __cdecl sub_80524C4(int a1);
int __stdcall sub_8052665(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_80526E6(_DWORD); // weak
int __cdecl sub_8052758();
int sub_80527CA(void); // weak
int sub_8052853(void); // weak
int __stdcall sub_80528C3(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_8052935();
int sub_80529A7(void); // weak
int __stdcall sub_8052A15(_DWORD); // weak
int (**sub_8052A30())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN locret_8049927; // weak
_UNKNOWN loc_804A16A; // weak
_UNKNOWN loc_804A170; // weak
_UNKNOWN loc_804A57D; // weak
_UNKNOWN loc_804A5DA; // weak
_UNKNOWN loc_804A684; // weak
_UNKNOWN loc_804A810; // weak
_UNKNOWN loc_804A835; // weak
_UNKNOWN locret_804A8AB; // weak
_UNKNOWN loc_804A914; // weak
_UNKNOWN loc_804A91B; // weak
_UNKNOWN loc_804ABC6; // weak
_UNKNOWN loc_804AD13; // weak
_UNKNOWN loc_804AD1C; // weak
_UNKNOWN loc_804AE72; // weak
_UNKNOWN loc_804AF68; // weak
_UNKNOWN locret_804AF7F; // weak
_UNKNOWN loc_804B057; // weak
_UNKNOWN locret_804B090; // weak
_UNKNOWN loc_804B098; // weak
_UNKNOWN loc_804B1DD; // weak
_UNKNOWN loc_804B210; // weak
_UNKNOWN loc_804D483; // weak
_UNKNOWN loc_804D4A1; // weak
_UNKNOWN loc_804D522; // weak
_UNKNOWN loc_804D557; // weak
_UNKNOWN loc_804D57D; // weak
_UNKNOWN loc_804D969; // weak
_UNKNOWN loc_804D9C5; // weak
_UNKNOWN loc_804DB37; // weak
_UNKNOWN loc_804DB43; // weak
_UNKNOWN loc_804DEB9; // weak
_UNKNOWN loc_804DEC5; // weak
_UNKNOWN loc_804E0A1; // weak
_UNKNOWN loc_804E0B8; // weak
_UNKNOWN loc_804E1AF; // weak
_UNKNOWN loc_804E1D8; // weak
_UNKNOWN loc_804E346; // weak
_UNKNOWN loc_804E381; // weak
_UNKNOWN loc_804E678; // weak
_UNKNOWN loc_804E682; // weak
_UNKNOWN loc_804E9D3; // weak
_UNKNOWN loc_804EA94; // weak
_UNKNOWN loc_804EA9A; // weak
_UNKNOWN loc_804EBB3; // weak
_UNKNOWN loc_804EBE5; // weak
_UNKNOWN loc_804EC0A; // weak
_UNKNOWN locret_804EC1C; // weak
_UNKNOWN loc_804EDEF; // weak
_UNKNOWN loc_804EDFB; // weak
_UNKNOWN loc_804F85D; // weak
_UNKNOWN loc_804F87C; // weak
_UNKNOWN loc_804F88D; // weak
_UNKNOWN loc_804F96A; // weak
_UNKNOWN loc_804F996; // weak
_UNKNOWN loc_804FBEC; // weak
_UNKNOWN loc_804FBF7; // weak
_UNKNOWN loc_8050B6E; // weak
_UNKNOWN loc_8050BBA; // weak
_UNKNOWN loc_8050C83; // weak
_UNKNOWN loc_8050C9B; // weak
_UNKNOWN loc_805103C; // weak
_UNKNOWN loc_80511C4; // weak
_UNKNOWN loc_80511CE; // weak
_UNKNOWN loc_80511F4; // weak
_UNKNOWN loc_8051220; // weak
_UNKNOWN loc_8051275; // weak
_UNKNOWN loc_8051288; // weak
_UNKNOWN locret_80514ED; // weak
_UNKNOWN loc_805154F; // weak
_UNKNOWN loc_8051588; // weak
_UNKNOWN loc_805165C; // weak
_UNKNOWN loc_8051668; // weak
_UNKNOWN loc_805178D; // weak
_UNKNOWN locret_80517B0; // weak
_UNKNOWN loc_8051A80; // weak
_UNKNOWN loc_8051B32; // weak
_UNKNOWN loc_8051EB8; // weak
_UNKNOWN loc_805200B; // weak
_UNKNOWN loc_8052055; // weak
_UNKNOWN loc_805205C; // weak
_UNKNOWN loc_8052408; // weak
_UNKNOWN unk_8052B30; // weak
char s = '\0'; // idb
struct option longopts = { "ignore-case", 0, NULL, 105 }; // idb
_UNKNOWN unk_80539A2; // weak
_UNKNOWN unk_80539B5; // weak
void *off_805411C[48] =
{
  &loc_80512A4,
  &loc_8051315,
  &loc_80512A4,
  &loc_8051315,
  &loc_8051315,
  &loc_8051315,
  &loc_80512A4,
  &loc_8051315,
  &loc_80512A4,
  &loc_8051315,
  &loc_8051315,
  &loc_80512A4,
  &loc_8051315,
  &loc_8051315,
  &loc_8051315,
  &loc_80512A4,
  &loc_8051315,
  &loc_8051315,
  &loc_8051315,
  &loc_8051315,
  &loc_80512A4,
  &loc_80512A4,
  &loc_8051315,
  &loc_8051315,
  &loc_8051315,
  &loc_8051315,
  &loc_8051315,
  &loc_8051315,
  &loc_8051315,
  &loc_8051315,
  &loc_8051315,
  &loc_8051315,
  &loc_8051315,
  &loc_8051315,
  &loc_80512A4,
  &loc_8051315,
  &loc_8051315,
  &loc_8051315,
  &loc_80512A4,
  &loc_8051315,
  &loc_80512A4,
  &loc_8051315,
  &loc_8051315,
  &loc_8051315,
  &loc_8051315,
  &loc_8051315,
  &loc_8051315,
  &loc_80512A4
}; // weak
_UNKNOWN unk_80542E0; // weak
_UNKNOWN unk_8054317; // weak
_UNKNOWN unk_80551BC; // weak
_UNKNOWN unk_80551BF; // weak
_UNKNOWN unk_8056204; // weak
_UNKNOWN unk_8056207; // weak
int (*off_8057ED4[2])() = { &sub_8049240, &sub_8049220 }; // weak
int (*off_8057ED8)() = &sub_8049220; // weak
int (*dword_8058008)(void) = NULL; // weak
int dword_8058114 = 0; // weak
int dword_8058128 = 0; // weak
int dword_805813C = 0; // weak
int dword_8058150 = 0; // weak
int dword_8058164 = 0; // weak
int dword_8058178 = 0; // weak
int dword_805818C = 0; // weak
int dword_80581A0 = 0; // weak
int dword_80581B4 = 0; // weak
int dword_80581F0 = 0; // weak
int dword_80581F4 = 4294967295; // weak
int dword_80581F8 = 4294967295; // weak
void *off_80581FC = &unk_80586F9; // weak
int c = 4294967295; // idb
int off_8058208 = 134559826; // idb
int status = 1; // idb
int dword_805822C = 1; // weak
int dword_8058230 = 256; // weak
void *off_8058234 = &unk_8058789; // weak
int *off_8058238 = &dword_8058230; // weak
_UNKNOWN unk_805824C; // weak
_UNKNOWN unk_8058268; // weak
_UNKNOWN unk_805826B; // weak
_UNKNOWN unk_8058270; // weak
_UNKNOWN unk_805827C; // weak
_UNKNOWN unk_805827F; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int optind; // weak
int stdin; // weak
FILE *stdout; // idb
char *optarg; // idb
char byte_80582CC; // weak
_UNKNOWN unk_805836A; // weak
int dword_80586B9[]; // weak
int dword_80586C1[]; // weak
int dword_80586C5[2]; // idb
char *dword_80586D1; // idb
char *dword_80586D5; // idb
void *ptr[2]; // idb
char byte_80586E1; // weak
char byte_80586E2; // weak
char byte_80586E4; // weak
char byte_80586E5; // weak
char byte_80586E6[]; // weak
char byte_80586E7; // weak
char *s1; // idb
char byte_80586ED; // weak
int dword_8058705; // weak
char byte_8058721; // weak
int dword_8058725; // weak
char byte_8058729; // weak
int dword_805872D; // weak
int dword_8058749[]; // weak
int dword_805874D; // weak
int dword_8058751; // weak
int dword_8058755; // weak
int dword_8058759; // weak
int dword_805875D; // weak
int dword_8058761; // weak
int dword_8058765; // weak
int dword_8058769; // weak
int dword_805876D; // weak
int dword_8058771; // weak
int dword_8058775; // weak
_UNKNOWN unk_8058789; // weak
int dword_8058889; // weak
int dword_805888D; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (08048D18) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 8049140: using guessed type int _gmon_start__(void);

//----- (08048D40) --------------------------------------------------------
int sub_8048D40()
{
  return dword_8058008();
}
// 8058008: using guessed type int (*dword_8058008)(void);

//----- (08049150) --------------------------------------------------------
#error "8049153: positive sp value has been found (funcsize=2)"

//----- (08049183) --------------------------------------------------------
void sub_8049183()
{
  ;
}

//----- (080491A0) --------------------------------------------------------
void sub_80491A0()
{
  ;
}

//----- (080491B0) --------------------------------------------------------
int sub_80491B0()
{
  int result; // eax

  result = &unk_805827F - &unk_805827C;
  if ( (unsigned int)(&unk_805827F - &unk_805827C) > 6 )
    result = 0;
  return result;
}
// 80491B0: could not find valid save-restore pair for ebp

//----- (08049220) --------------------------------------------------------
int sub_8049220()
{
  int result; // eax

  if ( !byte_80582CC )
  {
    result = sub_80491B0();
    byte_80582CC = 1;
  }
  return result;
}
// 8049220: could not find valid save-restore pair for ebp
// 80582CC: using guessed type char byte_80582CC;

//----- (08049240) --------------------------------------------------------
int sub_8049240()
{
  return 0;
}
// 8049240: could not find valid save-restore pair for ebp

//----- (0804929F) --------------------------------------------------------
void sub_804929F()
{
  ;
}

//----- (080492BA) --------------------------------------------------------
void sub_80492BA()
{
  ;
}

//----- (080492CA) --------------------------------------------------------
int sub_80492CA()
{
  int result; // eax

  result = &unk_805826B - &unk_8058268;
  if ( (unsigned int)(&unk_805826B - &unk_8058268) > 6 )
    result = 0;
  return result;
}
// 80492CA: could not find valid save-restore pair for ebp

//----- (080493AC) --------------------------------------------------------
void sub_80493AC()
{
  ;
}

//----- (080493C7) --------------------------------------------------------
void sub_80493C7()
{
  ;
}

//----- (080493D7) --------------------------------------------------------
signed int sub_80493D7()
{
  return 3;
}
// 80493D7: could not find valid save-restore pair for ebp

//----- (080494B9) --------------------------------------------------------
void sub_80494B9()
{
  ;
}

//----- (080494D4) --------------------------------------------------------
void sub_80494D4()
{
  ;
}

//----- (080494E4) --------------------------------------------------------
int sub_80494E4()
{
  int result; // eax

  result = &unk_805836A - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_805836A - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 80494E4: could not find valid save-restore pair for ebp
// 8058280: using guessed type int program_invocation_short_name;

//----- (080495C6) --------------------------------------------------------
void sub_80495C6()
{
  ;
}

//----- (080495E1) --------------------------------------------------------
void sub_80495E1()
{
  ;
}

//----- (080495F1) --------------------------------------------------------
int sub_80495F1()
{
  int result; // eax

  result = &unk_805826B - &unk_8058268;
  if ( (unsigned int)(&unk_805826B - &unk_8058268) > 6 )
    result = 0;
  return result;
}
// 80495F1: could not find valid save-restore pair for ebp

//----- (080496D3) --------------------------------------------------------
void sub_80496D3()
{
  ;
}

//----- (080496EE) --------------------------------------------------------
void sub_80496EE()
{
  ;
}

//----- (080496FE) --------------------------------------------------------
int sub_80496FE()
{
  int result; // eax

  result = &unk_805826B - &unk_8058268;
  if ( (unsigned int)(&unk_805826B - &unk_8058268) > 6 )
    result = 0;
  return result;
}
// 80496FE: could not find valid save-restore pair for ebp

//----- (080497E0) --------------------------------------------------------
void sub_80497E0()
{
  ;
}

//----- (080497FB) --------------------------------------------------------
void sub_80497FB()
{
  ;
}

//----- (0804980B) --------------------------------------------------------
int sub_804980B()
{
  int result; // eax

  result = &unk_8056207 - &unk_8056204;
  if ( (unsigned int)(&unk_8056207 - &unk_8056204) > 6 )
    result = 0;
  return result;
}
// 804980B: could not find valid save-restore pair for ebp

//----- (080498ED) --------------------------------------------------------
void sub_80498ED()
{
  ;
}

//----- (08049908) --------------------------------------------------------
void sub_8049908()
{
  ;
}

//----- (08049918) --------------------------------------------------------
int sub_8049918()
{
  int result; // eax
  int (__stdcall *v1)(void *, int, int, int, int, int); // eax
  int v2; // [esp+4h] [ebp-18h]
  int v3; // [esp+8h] [ebp-14h]
  int v4; // [esp+Ch] [ebp-10h]
  int v5; // [esp+10h] [ebp-Ch]
  int v6; // [esp+14h] [ebp-8h]
  int v7; // [esp+18h] [ebp-4h]

  result = &unk_805826B - &unk_8058268;
  if ( (unsigned int)(&unk_805826B - &unk_8058268) > 6 )
  {
    v7 = 0;
    dword_805818C = (int)&locret_8049927;
    v1 = (int (__stdcall *)(void *, int, int, int, int, int))sub_8052758();
    result = v1(&unk_8058268, v2, v3, v4, v5, v6);
  }
  return result;
}
// 805818C: using guessed type int dword_805818C;

//----- (0804998F) --------------------------------------------------------
int sub_804998F()
{
  return nullsub_3();
}
// 804998F: could not find valid save-restore pair for ebp
// 804998E: using guessed type int nullsub_3(void);

//----- (08049A2F) --------------------------------------------------------
void sub_8049A2F()
{
  ;
}

//----- (08049A4A) --------------------------------------------------------
void sub_8049A4A()
{
  ;
}

//----- (08049A5A) --------------------------------------------------------
int sub_8049A5A()
{
  int result; // eax

  result = &unk_805826B - &unk_8058268;
  if ( (unsigned int)(&unk_805826B - &unk_8058268) > 6 )
    result = 0;
  return result;
}
// 8049A5A: could not find valid save-restore pair for ebp

//----- (08049AB8) --------------------------------------------------------
int sub_8049AB8()
{
  return nullsub_4();
}
// 8049AB8: could not find valid save-restore pair for ebp
// 8049AB7: using guessed type int nullsub_4(void);

//----- (08049B62) --------------------------------------------------------
void sub_8049B62()
{
  ;
}

//----- (08049B7D) --------------------------------------------------------
void sub_8049B7D()
{
  ;
}

//----- (08049B8D) --------------------------------------------------------
int sub_8049B8D()
{
  int result; // eax

  result = &unk_805826B - &unk_8058268;
  if ( (unsigned int)(&unk_805826B - &unk_8058268) > 6 )
    result = 0;
  return result;
}
// 8049B8D: could not find valid save-restore pair for ebp

//----- (08049C6F) --------------------------------------------------------
void sub_8049C6F()
{
  ;
}

//----- (08049C8A) --------------------------------------------------------
void sub_8049C8A()
{
  ;
}

//----- (08049C9A) --------------------------------------------------------
int sub_8049C9A()
{
  int result; // eax

  result = &unk_80551BF - &unk_80551BC;
  if ( (unsigned int)(&unk_80551BF - &unk_80551BC) > 6 )
    result = 0;
  return result;
}
// 8049C9A: could not find valid save-restore pair for ebp

//----- (08049D01) --------------------------------------------------------
int __usercall sub_8049D01@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_80551BC, a1);
}

//----- (08049D98) --------------------------------------------------------
void sub_8049D98()
{
  ;
}

//----- (08049DB3) --------------------------------------------------------
void sub_8049DB3()
{
  ;
}

//----- (08049DC3) --------------------------------------------------------
int sub_8049DC3()
{
  int result; // eax

  result = (char *)&off_805411C[37] + 3 - (char *)&off_805411C[37];
  if ( (unsigned int)((char *)&off_805411C[37] + 3 - (char *)&off_805411C[37]) > 6 )
    result = 0;
  return result;
}
// 8049DC3: could not find valid save-restore pair for ebp
// 805411C: using guessed type void *off_805411C[48];

//----- (08049EB2) --------------------------------------------------------
void sub_8049EB2()
{
  ;
}

//----- (08049ECD) --------------------------------------------------------
void sub_8049ECD()
{
  ;
}

//----- (08049EDD) --------------------------------------------------------
#error "8049F0A: call analysis failed (funcsize=23)"

//----- (08049F6F) --------------------------------------------------------
int __usercall sub_8049F6F@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_8058270, a1);
}

//----- (0804A006) --------------------------------------------------------
void sub_804A006()
{
  ;
}

//----- (0804A031) --------------------------------------------------------
void sub_804A031()
{
  ;
}

//----- (0804A041) --------------------------------------------------------
int sub_804A041()
{
  int result; // eax

  result = 134562547 - (_DWORD)"reutils/coreutils-8.28/install_m32/lib";
  if ( (unsigned int)(134562547 - (_DWORD)"reutils/coreutils-8.28/install_m32/lib") > 6 )
    result = 0;
  return result;
}
// 804A041: could not find valid save-restore pair for ebp

//----- (0804A0A8) --------------------------------------------------------
int __usercall sub_804A0A8@<eax>(int a1@<eax>, int (__cdecl *a2)(const char *, int)@<edx>)
{
  return a2("reutils/coreutils-8.28/install_m32/lib", a1);
}

//----- (0804A129) --------------------------------------------------------
_BOOL4 __cdecl sub_804A129(unsigned __int8 a1)
{
  bool v1; // zf
  void *v2; // eax

  v1 = ((*__ctype_b_loc())[a1] & 1) == 0;
  v2 = &loc_804A16A;
  if ( !v1 )
    v2 = &loc_804A170;
  dword_8058128 = (int)v2;
  sub_80529A7();
  return a1 == 10;
}
// 80529A7: using guessed type int sub_80529A7(void);
// 8058128: using guessed type int dword_8058128;

//----- (0804A191) --------------------------------------------------------
int __cdecl sub_804A191(char *s1)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // ebx
  char *v5; // eax
  char *v7; // [esp+1Ch] [ebp-4Ch]
  void **i; // [esp+20h] [ebp-48h]
  const char *v9; // [esp+24h] [ebp-44h]
  void *v10; // [esp+28h] [ebp-40h]
  const char *v11; // [esp+2Ch] [ebp-3Ch]
  const char *v12; // [esp+30h] [ebp-38h]
  const char *v13; // [esp+34h] [ebp-34h]
  const char *v14; // [esp+38h] [ebp-30h]
  const char *v15; // [esp+3Ch] [ebp-2Ch]
  const char *v16; // [esp+40h] [ebp-28h]
  const char *v17; // [esp+44h] [ebp-24h]
  const char *v18; // [esp+48h] [ebp-20h]
  const char *v19; // [esp+4Ch] [ebp-1Ch]
  const char *v20; // [esp+50h] [ebp-18h]
  const char *v21; // [esp+54h] [ebp-14h]
  int v22; // [esp+58h] [ebp-10h]
  int v23; // [esp+5Ch] [ebp-Ch]

  v10 = &unk_8052B30;
  v11 = "test invocation";
  v12 = "coreutils";
  v13 = "Multi-call invocation";
  v14 = "sha224sum";
  v15 = "sha2 utilities";
  v16 = "sha256sum";
  v17 = "sha2 utilities";
  v18 = "sha384sum";
  v19 = "sha2 utilities";
  v20 = "sha512sum";
  v21 = "sha2 utilities";
  v22 = 0;
  v23 = 0;
  v7 = s1;
  for ( i = &v10; *i && strcmp(s1, (const char *)*i); i += 2 )
    ;
  if ( i[1] )
    v7 = (char *)i[1];
  v1 = gettext("\n%s online help: <%s>\n");
  printf(v1, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  v9 = setlocale(5, 0);
  if ( v9 && strncmp(v9, "en_", 3u) )
  {
    v2 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
    printf(v2, s1);
  }
  v3 = gettext("Full documentation at: <%s%s>\n");
  printf(v3, "http://www.gnu.org/software/coreutils/", s1);
  if ( v7 == s1 )
    v4 = " invocation";
  else
    v4 = &s;
  v5 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  return printf(v5, v7, v4);
}

//----- (0804A317) --------------------------------------------------------
void __cdecl __noreturn sub_804A317(int status)
{
  int v1; // ebx
  char *v2; // eax
  int v3; // ebx
  char *v4; // eax
  FILE *v5; // ebx
  char *v6; // eax
  FILE *v7; // ebx
  char *v8; // eax
  FILE *v9; // ebx
  char *v10; // eax
  FILE *v11; // ebx
  char *v12; // eax
  FILE *v13; // ebx
  char *v14; // eax
  FILE *v15; // ebx
  char *v16; // eax
  FILE *v17; // ebx
  char *v18; // eax
  FILE *v19; // ebx
  char *v20; // eax
  FILE *v21; // ebx
  char *v22; // eax

  if ( status )
  {
    v1 = dword_805872D;
    v2 = gettext("Try '%s --help' for more information.\n");
    fprintf(stderr, v2, v1);
  }
  else
  {
    v3 = dword_805872D;
    v4 = gettext("Usage: %s [OPTION]... FILE1 FILE2\n");
    printf(v4, v3);
    v5 = stdout;
    v6 = gettext(
           "For each pair of input lines with identical join fields, write a line to\n"
           "standard output.  The default join field is the first, delimited by blanks.\n");
    fputs_unlocked(v6, v5);
    v7 = stdout;
    v8 = gettext("\nWhen FILE1 or FILE2 (not both) is -, read standard input.\n");
    fputs_unlocked(v8, v7);
    v9 = stdout;
    v10 = gettext(
            "\n"
            "  -a FILENUM        also print unpairable lines from file FILENUM, where\n"
            "                      FILENUM is 1 or 2, corresponding to FILE1 or FILE2\n"
            "  -e EMPTY          replace missing input fields with EMPTY\n");
    fputs_unlocked(v10, v9);
    v11 = stdout;
    v12 = gettext(
            "  -i, --ignore-case  ignore differences in case when comparing fields\n"
            "  -j FIELD          equivalent to '-1 FIELD -2 FIELD'\n"
            "  -o FORMAT         obey FORMAT while constructing output line\n"
            "  -t CHAR           use CHAR as input and output field separator\n");
    fputs_unlocked(v12, v11);
    v13 = stdout;
    v14 = gettext(
            "  -v FILENUM        like -a FILENUM, but suppress joined output lines\n"
            "  -1 FIELD          join on this FIELD of file 1\n"
            "  -2 FIELD          join on this FIELD of file 2\n"
            "  --check-order     check that the input is correctly sorted, even\n"
            "                      if all input lines are pairable\n"
            "  --nocheck-order   do not check that the input is correctly sorted\n"
            "  --header          treat the first line in each file as field headers,\n"
            "                      print them without trying to pair them\n");
    fputs_unlocked(v14, v13);
    v15 = stdout;
    v16 = gettext("  -z, --zero-terminated     line delimiter is NUL, not newline\n");
    fputs_unlocked(v16, v15);
    v17 = stdout;
    v18 = gettext("      --help     display this help and exit\n");
    fputs_unlocked(v18, v17);
    v19 = stdout;
    v20 = gettext("      --version  output version information and exit\n");
    fputs_unlocked(v20, v19);
    v21 = stdout;
    v22 = gettext(
            "\n"
            "Unless -t CHAR is given, leading blanks separate fields and are ignored,\n"
            "else fields are separated by CHAR.  Any FIELD is a field number counted\n"
            "from 1.  FORMAT is one or more comma or blank separated specifications,\n"
            "each being 'FILENUM.FIELD' or '0'.  Default FORMAT outputs the join field,\n"
            "the remaining fields from FILE1, the remaining fields from FILE2, all\n"
            "separated by CHAR.  If FORMAT is the keyword 'auto', then the first\n"
            "line of each file determines the number of fields output for each line.\n"
            "\n"
            "Important: FILE1 and FILE2 must be sorted on the join fields.\n"
            "E.g., use \"sort -k 1b,1\" if 'join' has no options,\n"
            "or use \"join -t ''\" if 'sort' has no options.\n"
            "Note, comparisons honor the rules specified by 'LC_COLLATE'.\n"
            "If the input is not sorted and some lines cannot be joined, a\n"
            "warning message will be given.\n");
    fputs_unlocked(v22, v21);
    sub_804A191("join");
  }
  exit(status);
}
// 8048F50: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 805872D: using guessed type int dword_805872D;

//----- (0804A4A6) --------------------------------------------------------
int __cdecl sub_804A4A6(int a1, int a2, int a3)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 12) >= *(_DWORD *)(a1 + 16) )
    *(_DWORD *)(a1 + 20) = sub_8050B41(*(void **)(a1 + 20), a1 + 16, 8);
  *(_DWORD *)(8 * *(_DWORD *)(a1 + 12) + *(_DWORD *)(a1 + 20)) = a2;
  *(_DWORD *)(8 * *(_DWORD *)(a1 + 12) + *(_DWORD *)(a1 + 20) + 4) = a3;
  result = a1;
  ++*(_DWORD *)(a1 + 12);
  return result;
}

//----- (0804A520) --------------------------------------------------------
#error "804A578: call analysis failed (funcsize=136)"

//----- (0804A6CF) --------------------------------------------------------
#error "804A6D8: positive sp value has been found (funcsize=5)"

//----- (0804A719) --------------------------------------------------------
signed int __cdecl sub_804A719(int a1, int a2, unsigned int a3, unsigned int a4)
{
  signed int result; // eax
  void *v5; // eax
  unsigned int v6; // eax
  int v7; // [esp+0h] [ebp-38h]
  void *s1; // [esp+1Ch] [ebp-1Ch]
  void *s2; // [esp+20h] [ebp-18h]
  size_t v10; // [esp+24h] [ebp-14h]
  size_t n; // [esp+28h] [ebp-10h]
  int v12; // [esp+2Ch] [ebp-Ch]

  if ( *(_DWORD *)(a1 + 12) <= a3 )
  {
    s1 = 0;
    v10 = 0;
  }
  else
  {
    s1 = *(void **)(8 * a3 + *(_DWORD *)(a1 + 20));
    v10 = *(_DWORD *)(8 * a3 + *(_DWORD *)(a1 + 20) + 4);
  }
  if ( *(_DWORD *)(a2 + 12) <= a4 )
  {
    s2 = 0;
    n = 0;
  }
  else
  {
    s2 = *(void **)(8 * a4 + *(_DWORD *)(a2 + 20));
    n = *(_DWORD *)(8 * a4 + *(_DWORD *)(a2 + 20) + 4);
  }
  if ( v10 )
  {
    if ( !n )
    {
      dword_805818C = (int)&locret_804A8AB;
      sub_8052758();
    }
    v5 = &loc_804A810;
    if ( !byte_8058721 )
      v5 = &loc_804A835;
    dword_8058114 = (int)v5;
    sub_8052A15(v7);
    v6 = v10;
    if ( n <= v10 )
      v6 = n;
    v12 = sub_804E76E((int)s1, (int)s2, v6);
    if ( v12 )
    {
      result = v12;
    }
    else if ( v10 < n )
    {
      result = -1;
    }
    else
    {
      result = v10 != n;
    }
  }
  else if ( n )
  {
    result = -1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 8052A15: using guessed type int __stdcall sub_8052A15(_DWORD);
// 8058114: using guessed type int dword_8058114;
// 805818C: using guessed type int dword_805818C;
// 8058721: using guessed type char byte_8058721;

//----- (0804A8AD) --------------------------------------------------------
int __cdecl sub_804A8AD(int a1, int a2, int a3)
{
  int result; // eax
  void *v4; // eax
  signed int v5; // eax
  int v6; // ST34_4
  signed int v7; // ST30_4
  int v8; // ebx
  int v9; // esi
  char *v10; // edi
  char *v11; // eax
  int v12; // [esp+0h] [ebp-58h]
  int v13; // [esp+4h] [ebp-54h]
  int v14; // [esp+8h] [ebp-50h]
  int v15; // [esp+Ch] [ebp-4Ch]
  int v16; // [esp+10h] [ebp-48h]
  int v17; // [esp+14h] [ebp-44h]
  int v18; // [esp+18h] [ebp-40h]
  int v19; // [esp+1Ch] [ebp-3Ch]
  int v20; // [esp+20h] [ebp-38h]
  int v21; // [esp+24h] [ebp-34h]
  int v22; // [esp+28h] [ebp-30h]
  int v23; // [esp+2Ch] [ebp-2Ch]
  int v24; // [esp+30h] [ebp-28h]
  int v25; // [esp+34h] [ebp-24h]
  int v26; // [esp+38h] [ebp-20h]
  signed int v27; // [esp+38h] [ebp-20h]

  result = dword_8058705;
  if ( dword_8058705 != 2 )
  {
    if ( dword_8058705 == 1 || (result = (unsigned __int8)byte_80586E5, byte_80586E5) )
    {
      result = (unsigned __int8)byte_80586E6[a3 - 1] ^ 1;
      if ( byte_80586E6[a3 - 1] != 1 )
      {
        v4 = &loc_804A914;
        if ( a3 != 1 )
          v4 = &loc_804A91B;
        dword_8058150 = (int)v4;
        sub_80528C3(v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26);
        result = sub_804A719(a1, a2, dword_80581F4, dword_80581F4);
        if ( result > 0 )
        {
          v27 = *(_DWORD *)(a2 + 4);
          if ( v27 && *(_BYTE *)(v27 - 1 + *(_DWORD *)(a2 + 8)) == 10 )
            --v27;
          if ( v27 < 0 )
            v5 = 0x7FFFFFFF;
          else
            v5 = v27;
          v6 = *(_DWORD *)(a2 + 8);
          v7 = v5;
          v8 = dword_80586C1[2 * (a3 - 1)];
          v9 = dword_80586C5[2 * (a3 - 1)];
          v10 = (&dword_80586D1)[a3 - 1];
          v11 = gettext("%s:%llu: is not sorted: %.*s");
          error(dword_8058705 == 1, 0, v11, v10, v8, v9, v7, v6);
          result = a3 - 1;
          byte_80586E6[a3 - 1] = 1;
        }
      }
    }
  }
  return result;
}
// 80528C3: using guessed type int __stdcall sub_80528C3(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8058150: using guessed type int dword_8058150;
// 80581F4: using guessed type int dword_80581F4;
// 80586C1: using guessed type int dword_80586C1[];
// 80586E5: using guessed type char byte_80586E5;
// 8058705: using guessed type int dword_8058705;

//----- (0804AA16) --------------------------------------------------------
int __cdecl sub_804AA16(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (0804AA25) --------------------------------------------------------
void *__cdecl sub_804AA25(_DWORD *a1)
{
  void *result; // eax

  result = sub_8050D12(1u, 0x18u);
  *a1 = result;
  return result;
}

//----- (0804AA5F) --------------------------------------------------------
int __cdecl sub_804AA5F(FILE *stream, int a2, int a3)
{
  char *v3; // ebx
  int *v4; // eax
  int v5; // ecx
  __int64 v6; // rax
  void *v8; // [esp+18h] [ebp-10h]

  v8 = *(void **)a2;
  if ( dword_80586B9[a3 - 1] == *(_DWORD *)a2 )
  {
    v8 = ptr[a3 - 1];
    ptr[a3 - 1] = *(void **)a2;
    *(_DWORD *)a2 = v8;
  }
  if ( v8 )
    sub_804AA16((int)v8);
  else
    v8 = sub_804AA25((_DWORD *)a2);
  if ( !sub_804E625((int)v8, stream) )
  {
    if ( ferror_unlocked(stream) )
    {
      v3 = gettext("read error");
      v4 = __errno_location();
      error(1, *v4, v3);
    }
    sub_804A6CF(v8);
    dword_8058178 = (int)&loc_804ABC6;
    sub_80527CA();
  }
  v5 = a3 - 1;
  LODWORD(v6) = dword_80586C1[2 * (a3 - 1)];
  HIDWORD(v6) = dword_80586C5[2 * (a3 - 1)];
  dword_80586C1[2 * v5] = ++v6;
  dword_80586C5[2 * v5] = HIDWORD(v6);
  sub_804A520((int)v8);
  if ( dword_80586B9[a3 - 1] )
    sub_804A8AD(dword_80586B9[a3 - 1], (int)v8, a3);
  dword_80586B9[a3 - 1] = (int)v8;
  return 1;
}
// 804A6CF: using guessed type int __cdecl sub_804A6CF(_DWORD);
// 80527CA: using guessed type int sub_80527CA(void);
// 8058178: using guessed type int dword_8058178;
// 80586B9: using guessed type int dword_80586B9[];
// 80586C1: using guessed type int dword_80586C1[];

//----- (0804ABCC) --------------------------------------------------------
void sub_804ABCC()
{
  unsigned int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; i <= 1; ++i )
  {
    if ( ptr[i] )
    {
      sub_804A6CF(ptr[i]);
      free(ptr[i]);
    }
  }
}
// 804A6CF: using guessed type int __cdecl sub_804A6CF(_DWORD);

//----- (0804AC19) --------------------------------------------------------
_DWORD *__cdecl sub_804AC19(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = a1;
  a1[2] = 0;
  return result;
}

//----- (0804AC3B) --------------------------------------------------------
int __cdecl sub_804AC3B(FILE *stream, int a2, int a3)
{
  unsigned int i; // [esp+1Ch] [ebp-Ch]

  if ( *(_DWORD *)a2 == *(_DWORD *)(a2 + 4) )
  {
    *(_DWORD *)(a2 + 8) = sub_8050B41(*(void **)(a2 + 8), a2 + 4, 4);
    for ( i = *(_DWORD *)a2; *(_DWORD *)(a2 + 4) > i; ++i )
      *(_DWORD *)(4 * i + *(_DWORD *)(a2 + 8)) = 0;
  }
  if ( !(unsigned __int8)sub_804AA5F(stream, 4 * *(_DWORD *)a2 + *(_DWORD *)(a2 + 8), a3) )
    return 0;
  ++*(_DWORD *)a2;
  return 1;
}

//----- (0804ACE8) --------------------------------------------------------
int __cdecl sub_804ACE8(FILE *stream, int a2, int a3, int a4)
{
  void *v4; // eax
  int v6; // [esp+0h] [ebp-18h]

  v4 = &loc_804AD13;
  if ( !(_BYTE)a3 )
    v4 = &loc_804AD1C;
  dword_80581A0 = (int)v4;
  sub_80526E6(v6);
  *(_DWORD *)a2 = 0;
  return sub_804AC3B(stream, a2, a4);
}
// 80526E6: using guessed type int __stdcall sub_80526E6(_DWORD);
// 80581A0: using guessed type int dword_80581A0;

//----- (0804AD37) --------------------------------------------------------
void __cdecl sub_804AD37(int a1)
{
  unsigned int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; *(_DWORD *)(a1 + 4) > i; ++i )
  {
    sub_804A6CF(*(_DWORD *)(4 * i + *(_DWORD *)(a1 + 8)));
    free(*(void **)(4 * i + *(_DWORD *)(a1 + 8)));
  }
  free(*(void **)(a1 + 8));
}
// 804A6CF: using guessed type int __cdecl sub_804A6CF(_DWORD);

//----- (0804AE49) --------------------------------------------------------
char *__cdecl sub_804AE49(unsigned int a1, unsigned int a2, int a3)
{
  char v3; // al
  char *result; // eax
  void *v5; // eax
  int v6; // [esp-34h] [ebp-5Ch]
  int v7; // [esp+0h] [ebp-28h]
  char v8; // [esp+17h] [ebp-11h]
  size_t n; // [esp+1Ch] [ebp-Ch]

  if ( byte_80586ED )
  {
    dword_80581A0 = (int)&loc_804AE72;
    sub_80526E6(v7);
  }
  if ( c < 0 )
    v3 = 32;
  else
    v3 = c;
  v8 = v3;
  if ( a2 > 0 && *(_DWORD *)(a1 + 12) > 0u )
  {
    putchar_unlocked(v3);
    dword_805813C = (int)sub_804AEC6;
    sub_8052935();
    result = sub_804AEC6(a1, a2);
  }
  else
  {
    dword_805818C = (int)&loc_804B098;
    sub_8052758();
    putchar_unlocked(v8);
    if ( *(_DWORD *)(a2 + 12) <= a1 )
    {
      result = s1;
      if ( s1 )
        result = (char *)fputs_unlocked(s1, stdout);
    }
    else
    {
      n = *(_DWORD *)(8 * a1 + *(_DWORD *)(a2 + 20) + 4);
      if ( n )
      {
        result = (char *)fwrite_unlocked(*(const void **)(8 * a1 + *(_DWORD *)(a2 + 20)), 1u, n, stdout);
      }
      else
      {
        v5 = &loc_804B057;
        if ( !s1 )
          v5 = &locret_804B090;
        dword_80581A0 = (int)v5;
        sub_80526E6(v6);
        result = (char *)fputs_unlocked(s1, stdout);
      }
    }
  }
  return result;
}
// 8048F50: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 80526E6: using guessed type int __stdcall sub_80526E6(_DWORD);
// 805813C: using guessed type int dword_805813C;
// 805818C: using guessed type int dword_805818C;
// 80581A0: using guessed type int dword_80581A0;
// 80586ED: using guessed type char byte_80586ED;

//----- (0804AEC6) --------------------------------------------------------
#error "804AF63: call analysis failed (funcsize=58)"

//----- (0804B094) --------------------------------------------------------
#error "804B0A5: positive sp value has been found (funcsize=0)"

//----- (0804B195) --------------------------------------------------------
char *__cdecl sub_804B195(unsigned int a1, int a2)
{
  size_t v2; // eax
  bool v3; // zf
  void *v4; // eax
  char *result; // eax
  size_t n; // [esp+1Ch] [ebp-Ch]

  if ( *(_DWORD *)(a2 + 12) <= a1 )
  {
    result = s1;
    if ( s1 )
      result = (char *)fputs_unlocked(s1, stdout);
  }
  else
  {
    v2 = *(_DWORD *)(8 * a1 + *(_DWORD *)(a2 + 20) + 4);
    n = v2;
    v3 = v2 == 0;
    v4 = &loc_804B1DD;
    if ( v3 )
      v4 = &loc_804B210;
    dword_8058178 = (int)v4;
    sub_80527CA();
    result = (char *)fwrite_unlocked(*(const void **)(8 * a1 + *(_DWORD *)(a2 + 20)), 1u, n, stdout);
  }
  return result;
}
// 8048F50: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 80527CA: using guessed type int sub_80527CA(void);
// 8058178: using guessed type int dword_8058178;

//----- (0804B3D5) --------------------------------------------------------
#error "804C689: call analysis failed (funcsize=1668)"

//----- (0804D2E7) --------------------------------------------------------
_DWORD *__cdecl sub_804D2E7(int a1, int a2)
{
  _DWORD *result; // eax

  if ( a1 && a1 != 1 && a1 != 2 )
    __assert_fail("file == 0 || file == 1 || file == 2", "src/join.c", 0x333u, "add_field");
  if ( !a1 && a2 )
    __assert_fail("file != 0 || field == 0", "src/join.c", 0x334u, "add_field");
  result = sub_8050C16(0xCu);
  *result = a1;
  result[1] = a2;
  result[2] = 0;
  *((_DWORD *)off_80581FC + 2) = result;
  off_80581FC = result;
  return result;
}
// 80581FC: using guessed type void *off_80581FC;

//----- (0804D3A0) --------------------------------------------------------
#error "804D3FD: call analysis failed (funcsize=49)"

//----- (0804D450) --------------------------------------------------------
int __cdecl sub_804D450(char *a1, _DWORD *a2, int *a3)
{
  int v3; // eax
  bool v4; // sf
  unsigned __int8 v5; // of
  void *v6; // eax
  int v7; // eax
  bool v8; // zf
  void *v9; // eax
  _BYTE *v10; // ebx
  char *v11; // eax
  int result; // eax
  void *v13; // eax
  _BYTE *v14; // ebx
  char *v15; // eax
  int v16; // [esp+0h] [ebp-18h]

  v3 = *a1;
  if ( v3 == 48 )
  {
    if ( a1[1] )
    {
      v10 = sub_8050407(a1);
      v11 = gettext("invalid field specifier: %s");
      error(1, 0, v11, v10);
    }
    *a2 = 0;
    result = (int)a3;
    *a3 = 0;
  }
  else
  {
    v5 = __OFSUB__(v3, 48);
    v4 = v3 - 48 < 0;
    v6 = &loc_804D483;
    if ( v4 ^ v5 )
      v6 = &loc_804D57D;
    dword_805813C = (int)v6;
    v7 = sub_8052935();
    v5 = __OFSUB__(v7, 50);
    v8 = v7 == 50;
    v4 = v7 - 50 < 0;
    v9 = &loc_804D4A1;
    if ( !((unsigned __int8)(v4 ^ v5) | v8) )
      v9 = &loc_804D57D;
    dword_8058164 = (int)v9;
    sub_8052853();
    v13 = &loc_804D522;
    if ( a1[1] == 46 )
      v13 = &loc_804D557;
    dword_8058114 = (int)v13;
    sub_8052A15(v16);
    v14 = sub_8050407(a1);
    v15 = gettext("invalid field specifier: %s");
    error(1, 0, v15, v14);
    *a2 = *a1 - 48;
    result = sub_804D3A0(a1 + 2);
    *a3 = result;
  }
  return result;
}
// 8052853: using guessed type int sub_8052853(void);
// 8052A15: using guessed type int __stdcall sub_8052A15(_DWORD);
// 8058114: using guessed type int dword_8058114;
// 805813C: using guessed type int dword_805813C;
// 8058164: using guessed type int dword_8058164;

//----- (0804D5CA) --------------------------------------------------------
_DWORD *__cdecl sub_804D5CA(char *a1)
{
  char *v1; // eax
  _DWORD *result; // eax
  int v3; // [esp+10h] [ebp-18h]
  int v4; // [esp+14h] [ebp-14h]
  char *s; // [esp+18h] [ebp-10h]
  char *v6; // [esp+1Ch] [ebp-Ch]

  s = a1;
  do
  {
    v6 = s;
    s = strpbrk(s, ", \t");
    if ( s )
    {
      v1 = s++;
      *v1 = 0;
    }
    sub_804D450(v6, &v3, &v4);
    result = sub_804D2E7(v3, v4);
  }
  while ( s );
  return result;
}

//----- (0804D641) --------------------------------------------------------
_DWORD *__cdecl sub_804D641(_DWORD *a1, int a2)
{
  int v2; // ST28_4
  char *v3; // eax
  _DWORD *result; // eax

  if ( *a1 != -1 && *a1 != a2 )
  {
    v2 = *a1 + 1;
    v3 = gettext("incompatible join fields %lu, %lu");
    error(1, 0, v3, v2, a2 + 1);
  }
  result = a1;
  *a1 = a2;
  return result;
}

//----- (0804D6AB) --------------------------------------------------------
#error "804D731: call analysis failed (funcsize=131)"

//----- (0804D872) --------------------------------------------------------
_BOOL4 __cdecl main(int argc, char **argv)
{
  void *v2; // eax
  int v3; // eax
  _BYTE *v4; // ebx
  char *v5; // eax
  void *v6; // eax
  char *v7; // eax
  int v8; // eax
  int v9; // eax
  bool v10; // ST37_1
  int v11; // eax
  int v12; // eax
  char *v13; // eax
  _BYTE *v14; // ebx
  char *v15; // eax
  bool v16; // zf
  void *v17; // eax
  _BYTE *v18; // ebx
  int *v19; // eax
  FILE *v20; // eax
  _BYTE *v21; // ebx
  int *v22; // eax
  void *v23; // eax
  char *v24; // ebx
  int *v25; // eax
  _BYTE *v26; // ebx
  int *v27; // eax
  _BYTE *v28; // ebx
  int *v29; // eax
  int v31; // [esp+0h] [ebp-64h]
  int v32; // [esp+0h] [ebp-64h]
  int v33; // [esp+30h] [ebp-34h]
  int v34; // [esp+34h] [ebp-30h]
  int v35; // [esp+38h] [ebp-2Ch]
  int v36; // [esp+3Ch] [ebp-28h]
  int i; // [esp+40h] [ebp-24h]
  int v38; // [esp+44h] [ebp-20h]
  FILE *v39; // [esp+48h] [ebp-1Ch]
  FILE *v40; // [esp+4Ch] [ebp-18h]
  int v41; // [esp+50h] [ebp-14h]
  int v42; // [esp+58h] [ebp-Ch]
  int v43; // [esp+5Ch] [ebp-8h]

  v34 = 0;
  v42 = 0;
  v43 = 0;
  v35 = 0;
  sub_804E7FE(*argv);
  setlocale(6, &s);
  bindtextdomain("coreutils", "/home/hwangdz/coreutils/coreutils-8.28/install_m32/share/locale");
  textdomain("coreutils");
  byte_80586E1 = sub_804E572(3);
  sub_80524C4((int)sub_804E2DB);
  sub_80524C4((int)sub_804ABCC);
  byte_80586E4 = 1;
  byte_80586E5 = 0;
  byte_80586E7 = 0;
  byte_80586E6[0] = 0;
  dword_8058705 = 0;
  while ( 1 )
  {
    v38 = getopt_long(argc, argv, "-a:e:i1:2:j:o:t:v:z", &longopts, 0);
    if ( v38 == -1 )
      break;
    v33 = 0;
    if ( v38 == 105 )
      goto LABEL_26;
    v2 = &loc_804D969;
    if ( v38 > 105 )
      v2 = &loc_804D9C5;
    dword_8058164 = (int)v2;
    v3 = sub_8052853();
    if ( v3 == 49 )
      goto LABEL_27;
    if ( v3 <= 49 )
    {
      if ( v3 == -130 )
        sub_804A317(0);
      if ( v3 == 1 )
      {
        sub_804D6AB(optarg, &dword_80586D1, &v41, &v42, &v35, &v34, &v33);
        goto LABEL_39;
      }
      if ( v3 == -131 )
      {
        sub_8050A2E(stdout, (int)"join", (int)"GNU coreutils", off_8058208, "Mike Haertel", 0);
        exit(0);
      }
      dword_8058164 = (int)&loc_804DEB9;
      v3 = sub_8052853();
    }
    if ( v3 == 97 )
    {
      if ( sub_8051084(optarg, 0, 10, (int)&v36, &s) || v36 != 1 && v36 != 2 )
      {
        v4 = sub_8050407(optarg);
        v5 = gettext("invalid field number: %s");
        error(1, 0, v5, v4);
      }
      v6 = &loc_804DB37;
      if ( v36 != 1 )
        v6 = &loc_804DB43;
      dword_80581A0 = (int)v6;
      sub_80526E6(v31);
      byte_80586E2 = 1;
    }
    else
    {
      if ( v3 == 101 )
      {
        if ( s1 && strcmp(s1, optarg) )
        {
          v7 = gettext("conflicting empty-field replacement strings");
          error(1, 0, v7);
        }
        s1 = optarg;
        dword_805818C = (int)&loc_804DEC5;
        sub_8052758();
LABEL_26:
        byte_8058721 = 1;
        dword_8058164 = (int)&loc_804DEC5;
        sub_8052853();
LABEL_27:
        v8 = sub_804D3A0(optarg);
        sub_804D641(&dword_80581F4, v8);
        goto LABEL_39;
      }
      if ( v3 != 50 )
        sub_804A317(1);
      v9 = sub_804D3A0(optarg);
      sub_804D641(&dword_80581F8, v9);
      dword_8058178 = (int)&loc_804DEC5;
      sub_80527CA();
      if ( *optarg != 49 && *optarg != 50 || optarg[1] || argv[optind + 0x3FFFFFFF] + 2 != optarg )
      {
        v11 = sub_804D3A0(optarg);
        sub_804D641(&dword_80581F4, v11);
        sub_804D641(&dword_80581F8, dword_80581F4);
      }
      else
      {
        v10 = *optarg == 50;
        ++*(&v42 + v10);
        v33 = v10 + 1;
      }
    }
LABEL_39:
    v34 = v33;
  }
  v34 = 0;
  while ( optind < argc )
  {
    v12 = optind++;
    sub_804D6AB(argv[v12], &dword_80586D1, &v41, &v42, &v35, &v34, &v33);
  }
  if ( v35 != 2 )
  {
    if ( v35 )
    {
      v14 = sub_8050407(argv[argc + 0x3FFFFFFF]);
      v15 = gettext("missing operand after %s");
      error(0, 0, v15, v14);
    }
    else
    {
      v13 = gettext("missing operand");
      error(0, 0, v13);
    }
    sub_804A317(1);
  }
  for ( i = 0; i <= 1; ++i )
  {
    if ( *(&v42 + i) )
    {
      sub_804D641(&dword_80581F4, i);
      sub_804D641(&dword_80581F8, i);
    }
  }
  if ( dword_80581F4 == -1 )
    dword_80581F4 = 0;
  if ( dword_80581F8 == -1 )
    dword_80581F8 = 0;
  v16 = strcmp(dword_80586D1, "-") == 0;
  v17 = &loc_804E0A1;
  if ( v16 )
    v17 = &loc_804E0B8;
  dword_8058114 = (int)v17;
  sub_8052A15(v32);
  v39 = (FILE *)sub_804E483((int)dword_80586D1, "r");
  if ( !v39 )
  {
    v18 = sub_805018B(0, 3, dword_80586D1);
    v19 = __errno_location();
    error(1, *v19, "%s", v18);
  }
  if ( !strcmp(dword_80586D5, "-") )
    v20 = (FILE *)stdin;
  else
    v20 = (FILE *)sub_804E483((int)dword_80586D5, "r");
  v40 = v20;
  if ( !v20 )
  {
    v21 = sub_805018B(0, 3, dword_80586D5);
    v22 = __errno_location();
    error(1, *v22, "%s", v21);
  }
  v23 = &loc_804E1AF;
  if ( v39 != v40 )
    v23 = &loc_804E1D8;
  dword_8058164 = (int)v23;
  sub_8052853();
  v24 = gettext("both files cannot be standard input");
  v25 = __errno_location();
  error(1, *v25, v24);
  sub_804B3D5(v39, v40);
  if ( sub_80514EF(v39) )
  {
    v26 = sub_805018B(0, 3, dword_80586D1);
    v27 = __errno_location();
    error(1, *v27, "%s", v26);
  }
  if ( sub_80514EF(v40) )
  {
    v28 = sub_805018B(0, 3, dword_80586D5);
    v29 = __errno_location();
    error(1, *v29, "%s", v28);
  }
  return byte_80586E6[0] || byte_80586E7;
}
// 804D6AB: using guessed type _DWORD __cdecl sub_804D6AB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80526E6: using guessed type int __stdcall sub_80526E6(_DWORD);
// 80527CA: using guessed type int sub_80527CA(void);
// 8052853: using guessed type int sub_8052853(void);
// 8052A15: using guessed type int __stdcall sub_8052A15(_DWORD);
// 8058114: using guessed type int dword_8058114;
// 8058164: using guessed type int dword_8058164;
// 8058178: using guessed type int dword_8058178;
// 805818C: using guessed type int dword_805818C;
// 80581A0: using guessed type int dword_80581A0;
// 80581F4: using guessed type int dword_80581F4;
// 80581F8: using guessed type int dword_80581F8;
// 80582A0: using guessed type int optind;
// 80582C0: using guessed type int stdin;
// 80586E1: using guessed type char byte_80586E1;
// 80586E2: using guessed type char byte_80586E2;
// 80586E4: using guessed type char byte_80586E4;
// 80586E5: using guessed type char byte_80586E5;
// 80586E7: using guessed type char byte_80586E7;
// 8058705: using guessed type int dword_8058705;
// 8058721: using guessed type char byte_8058721;

//----- (0804E2DB) --------------------------------------------------------
int sub_804E2DB()
{
  void *v0; // eax
  _BYTE *v1; // ebx
  int *v2; // eax
  int result; // eax
  char *v4; // [esp+2Ch] [ebp-Ch]

  if ( sub_80519AB(stdout) && (byte_8058729 != 1 || *__errno_location() != 32) )
  {
    v4 = gettext("write error");
    v0 = &loc_804E346;
    if ( !dword_8058725 )
      v0 = &loc_804E381;
    dword_805813C = (int)v0;
    sub_8052935();
    v1 = sub_805014E((_BYTE *)dword_8058725);
    v2 = __errno_location();
    error(0, *v2, "%s: %s", v1, v4);
    _exit(status);
  }
  result = sub_80519AB(stderr);
  if ( result )
    _exit(status);
  return result;
}
// 805813C: using guessed type int dword_805813C;
// 8058725: using guessed type int dword_8058725;
// 8058729: using guessed type char byte_8058729;

//----- (0804E3D8) --------------------------------------------------------
int __cdecl sub_804E3D8(int a1, int a2, int a3, int a4, int a5, int a6)
{
  return posix_fadvise64(a1, a2, a3, a4, a5, a6);
}
// 80490B0: using guessed type int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804E429) --------------------------------------------------------
void __cdecl sub_804E429(FILE *stream, int a2)
{
  int v2; // eax

  if ( stream )
  {
    v2 = fileno(stream);
    sub_804E3D8(v2, 0, 0, 0, 0, a2);
  }
}

//----- (0804E483) --------------------------------------------------------
#error "804E542: call analysis failed (funcsize=71)"

//----- (0804E572) --------------------------------------------------------
int __cdecl sub_804E572(int category)
{
  unsigned __int8 v2; // [esp+1Bh] [ebp-Dh]
  const char *s1; // [esp+1Ch] [ebp-Ch]

  v2 = 1;
  s1 = setlocale(category, 0);
  if ( s1 && (!strcmp(s1, "C") || !strcmp(s1, "POSIX")) )
    v2 = 0;
  return v2;
}

//----- (0804E625) --------------------------------------------------------
int __cdecl sub_804E625(int a1, FILE *stream)
{
  int v2; // ST2C_4
  int v3; // ST30_4
  bool v4; // zf
  void *v5; // eax

  v2 = *(_DWORD *)(a1 + 8);
  v3 = *(_DWORD *)a1 + *(_DWORD *)(a1 + 8);
  v4 = feof_unlocked(stream) == 0;
  v5 = &loc_804E678;
  if ( v4 )
    v5 = &loc_804E682;
  dword_805818C = (int)v5;
  sub_8052758();
  return 0;
}
// 805818C: using guessed type int dword_805818C;

//----- (0804E76E) --------------------------------------------------------
int __cdecl sub_804E76E(int a1, int a2, unsigned int a3)
{
  unsigned __int8 v3; // ST17_1
  int v4; // eax
  unsigned int i; // [esp+18h] [ebp-20h]
  int v7; // [esp+24h] [ebp-14h]

  for ( i = 0; i < a3; ++i )
  {
    v3 = *(_BYTE *)(a2 + i);
    v7 = toupper(*(unsigned __int8 *)(a1 + i));
    v4 = toupper(v3);
    if ( v7 != v4 )
      return v7 - v4;
  }
  return 0;
}

//----- (0804E7FE) --------------------------------------------------------
#error "804E89A: call analysis failed (funcsize=73)"

//----- (0804E9A2) --------------------------------------------------------
unsigned int __cdecl sub_804E9A2(int a1, unsigned __int8 a2, char a3)
{
  unsigned int v3; // ST10_4

  if ( a1 )
  {
    dword_805818C = (int)&loc_804E9D3;
    sub_8052758();
  }
  v3 = ((unsigned int)dword_8058749[(a2 >> 5) + 2] >> (a2 & 0x1F)) & 1;
  dword_8058749[(a2 >> 5) + 2] ^= (v3 ^ a3 & 1) << (a2 & 0x1F);
  return v3;
}
// 805818C: using guessed type int dword_805818C;
// 8058749: using guessed type int dword_8058749[];

//----- (0804EA59) --------------------------------------------------------
int *__cdecl sub_804EA59(int *a1, int a2, int a3)
{
  void *v3; // eax
  int *result; // eax
  int v5; // [esp+0h] [ebp-8h]

  if ( !a1 )
    a1 = dword_8058749;
  *a1 = 10;
  v3 = &loc_804EA94;
  if ( !a2 )
    v3 = &loc_804EA9A;
  dword_80581A0 = (int)v3;
  sub_80526E6(v5);
  if ( !a3 )
    abort();
  a1[10] = a2;
  result = a1;
  a1[11] = a3;
  return result;
}
// 80526E6: using guessed type int __stdcall sub_80526E6(_DWORD);
// 80581A0: using guessed type int dword_80581A0;
// 8058749: using guessed type int dword_8058749[];

//----- (0804EAB3) --------------------------------------------------------
_DWORD *__userpurge sub_804EAB3@<eax>(_DWORD *a1, int a2)
{
  int v3; // [esp+0h] [ebp-38h]
  int v4; // [esp+4h] [ebp-34h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]

  memset(&v3, 0, 0x30u);
  if ( a2 == 10 )
    abort();
  *a1 = a2;
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = v6;
  a1[4] = v7;
  a1[5] = v8;
  a1[6] = v9;
  a1[7] = v10;
  a1[8] = v11;
  a1[9] = v12;
  a1[10] = v13;
  a1[11] = v14;
  return a1;
}

//----- (0804EB43) --------------------------------------------------------
const char *__cdecl sub_804EB43(char *msgid, int a2)
{
  const char *result; // eax
  bool v3; // zf
  void *v4; // eax
  int v5; // [esp+0h] [ebp-28h]
  unsigned __int8 *v6; // [esp+1Ch] [ebp-Ch]

  if ( gettext(msgid) != msgid )
  {
    dword_8058114 = (int)&locret_804EC1C;
    sub_8052A15(v5);
  }
  v6 = (unsigned __int8 *)sub_8051ED8();
  if ( sub_8051936(v6, "UTF-8") )
  {
    v3 = sub_8051936(v6, "GB18030") == 0;
    v4 = &loc_804EBE5;
    if ( !v3 )
      v4 = &loc_804EC0A;
    dword_8058164 = (int)v4;
    sub_8052853();
    *msgid;
    dword_8058164 = (int)&locret_804EC1C;
    sub_8052853();
    if ( a2 == 9 )
      result = (const char *)&unk_80539B5;
    else
      result = "'";
  }
  else
  {
    if ( *msgid == 96 )
    {
      dword_8058164 = (int)&loc_804EBB3;
      sub_8052853();
    }
    result = (const char *)&unk_80539A2;
  }
  return result;
}
// 8052853: using guessed type int sub_8052853(void);
// 8052A15: using guessed type int __stdcall sub_8052A15(_DWORD);
// 8058114: using guessed type int dword_8058114;
// 8058164: using guessed type int dword_8058164;

//----- (0804EC1E) --------------------------------------------------------
unsigned int __cdecl sub_804EC1E(_BYTE *a1, unsigned int a2, _BYTE *a3, int a4, signed int a5, int a6, int a7, const char *a8, const char *a9)
{
  bool v9; // ST53_1
  _BOOL4 v10; // eax
  bool v11; // zf
  void *v12; // eax
  void *v13; // eax
  void *v14; // eax
  unsigned int result; // eax
  int v16; // [esp+0h] [ebp-88h]
  int v17; // [esp+0h] [ebp-88h]
  int v18; // [esp+4h] [ebp-84h]
  int v19; // [esp+8h] [ebp-80h]
  int v20; // [esp+Ch] [ebp-7Ch]
  int v21; // [esp+10h] [ebp-78h]
  int v22; // [esp+14h] [ebp-74h]
  int v23; // [esp+18h] [ebp-70h]
  int v24; // [esp+1Ch] [ebp-6Ch]
  int v25; // [esp+20h] [ebp-68h]
  int v26; // [esp+24h] [ebp-64h]
  int v27; // [esp+28h] [ebp-60h]
  const char *v28; // [esp+2Ch] [ebp-5Ch]
  const char *v29; // [esp+2Ch] [ebp-5Ch]
  const char *v30; // [esp+30h] [ebp-58h]
  const char *v31; // [esp+30h] [ebp-58h]
  char *v32; // [esp+38h] [ebp-50h]
  char v33; // [esp+40h] [ebp-48h]
  bool v34; // [esp+41h] [ebp-47h]
  unsigned int v35; // [esp+54h] [ebp-34h]
  char *s; // [esp+5Ch] [ebp-2Ch]
  char *sa; // [esp+5Ch] [ebp-2Ch]

  v30 = a8;
  v28 = a9;
  v35 = 0;
  s = 0;
  v33 = 0;
  v9 = __ctype_get_mb_cur_max() == 1;
  v34 = (a6 & 2) != 0;
  switch ( a5 )
  {
    case 0:
      v34 = 0;
      goto LABEL_29;
    case 1:
      goto LABEL_19;
    case 2:
      goto LABEL_22;
    case 3:
      v33 = 1;
LABEL_19:
      v34 = 1;
      goto LABEL_20;
    case 4:
LABEL_20:
      if ( v34 != 1 )
        v33 = 1;
LABEL_22:
      a5 = 2;
      if ( v34 != 1 )
      {
        if ( a2 > 0 )
          *a1 = 39;
        v35 = 1;
      }
      s = "'";
      goto LABEL_29;
    case 5:
      goto LABEL_3;
    case 6:
      a5 = 5;
      v34 = 1;
LABEL_3:
      if ( v34 != 1 )
      {
        if ( a2 > 0 )
          *a1 = 34;
        v35 = 1;
      }
      v33 = 1;
      s = (char *)&unk_80539B5;
      goto LABEL_29;
    case 7:
      v34 = 0;
      dword_8058114 = (int)&loc_804EDEF;
      sub_8052A15(v16);
      break;
    case 8:
    case 9:
    case 10:
      break;
    default:
      abort();
      return result;
  }
  if ( a5 != 10 )
  {
    v30 = sub_804EB43("`", a5);
    v28 = sub_804EB43("'", a5);
  }
  if ( v34 != 1 )
  {
    for ( sa = (char *)v30; *sa; ++sa )
    {
      if ( v35 < a2 )
        a1[v35] = *sa;
      ++v35;
    }
  }
  v33 = 1;
  s = (char *)v28;
  strlen(v28);
LABEL_29:
  if ( a4 == -1 )
    LOBYTE(v10) = *a3 != 0;
  else
    v10 = a4 != 0;
  v11 = (_BYTE)v10 == 0;
  v12 = &loc_804F85D;
  if ( !v11 )
    v12 = &loc_804EDFB;
  dword_80581A0 = (int)v12;
  sub_80526E6(v16);
  v13 = &loc_804F87C;
  if ( v35 )
    v13 = &loc_804F88D;
  dword_8058150 = (int)v13;
  sub_80528C3(v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v30, a7, a3);
  if ( a5 == 2 && v34 )
  {
    if ( v33 )
      a5 = 4;
    result = sub_804EC1E(a1, a2, v32, a4, a5, a6 & 0xFFFFFFFD, 0, v31, v29);
  }
  else
  {
    if ( s )
    {
      v14 = &loc_804F96A;
      if ( v34 == 1 )
        v14 = &loc_804F996;
      dword_8058128 = (int)v14;
      sub_80529A7();
      while ( *s )
      {
        if ( v35 < a2 )
          a1[v35] = *s;
        ++v35;
        ++s;
      }
    }
    if ( v35 < a2 )
      a1[v35] = 0;
    result = v35;
  }
  return result;
}
// 80526E6: using guessed type int __stdcall sub_80526E6(_DWORD);
// 80528C3: using guessed type int __stdcall sub_80528C3(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80529A7: using guessed type int sub_80529A7(void);
// 8052A15: using guessed type int __stdcall sub_8052A15(_DWORD);
// 8058114: using guessed type int dword_8058114;
// 8058128: using guessed type int dword_8058128;
// 8058150: using guessed type int dword_8058150;
// 80581A0: using guessed type int dword_80581A0;

//----- (0804FAD8) --------------------------------------------------------
_BYTE *__cdecl sub_804FAD8(_BYTE *a1, int a2, _DWORD *a3, int *a4)
{
  int *v4; // eax
  int *v5; // ST44_4
  int v6; // ST48_4
  int v7; // ST4C_4
  void *v8; // eax
  unsigned int size; // [esp+48h] [ebp-10h]
  _BYTE *v11; // [esp+4Ch] [ebp-Ch]

  if ( a4 )
    v4 = a4;
  else
    v4 = dword_8058749;
  v5 = v4;
  v6 = *__errno_location();
  v7 = v5[1] | (a3 == 0);
  size = sub_804EC1E(0, 0, a1, a2, *v5, v7, (int)(v5 + 2), (const char *)v5[10], (const char *)v5[11]) + 1;
  v11 = sub_8050C03(size);
  sub_804EC1E(v11, size, a1, a2, *v5, v7, (int)(v5 + 2), (const char *)v5[10], (const char *)v5[11]);
  *__errno_location() = v6;
  v8 = &loc_804FBEC;
  if ( !a3 )
    v8 = &loc_804FBF7;
  dword_805818C = (int)v8;
  sub_8052758();
  *a3 = size - 1;
  return v11;
}
// 805818C: using guessed type int dword_805818C;
// 8058749: using guessed type int dword_8058749[];

//----- (0804FC98) --------------------------------------------------------
_BYTE *__cdecl sub_804FC98(signed int a1, _BYTE *a2, int a3, int a4)
{
  int *v4; // eax
  void *v5; // edx
  size_t v6; // ST44_4
  bool v8; // [esp+37h] [ebp-21h]
  int *v9; // [esp+38h] [ebp-20h]
  _BYTE *ptr; // [esp+3Ch] [ebp-1Ch]
  int v11; // [esp+40h] [ebp-18h]
  int size; // [esp+44h] [ebp-14h]
  int v13; // [esp+48h] [ebp-10h]
  unsigned int v14; // [esp+4Ch] [ebp-Ch]

  v11 = *__errno_location();
  v9 = off_8058238;
  if ( a1 < 0 )
    abort();
  if ( dword_805822C <= a1 )
  {
    v8 = off_8058238 == &dword_8058230;
    if ( (unsigned int)a1 > 0xFFFFFFE )
      sub_8050DCB();
    if ( v8 )
      v4 = 0;
    else
      v4 = off_8058238;
    v9 = (int *)sub_8050C5E(v4, 8 * (a1 + 1));
    off_8058238 = v9;
    if ( v8 )
    {
      v5 = off_8058234;
      *v9 = dword_8058230;
      v9[1] = (int)v5;
    }
    memset(&v9[2 * dword_805822C], 0, 8 * (a1 + 1 - dword_805822C));
    dword_805822C = a1 + 1;
  }
  v6 = v9[2 * a1];
  ptr = (_BYTE *)v9[2 * a1 + 1];
  v13 = *(_DWORD *)(a4 + 4) | 1;
  v14 = sub_804EC1E(
          (_BYTE *)v9[2 * a1 + 1],
          v9[2 * a1],
          a2,
          a3,
          *(_DWORD *)a4,
          v13,
          a4 + 8,
          *(const char **)(a4 + 40),
          *(const char **)(a4 + 44));
  if ( v6 <= v14 )
  {
    size = v14 + 1;
    v9[2 * a1] = v14 + 1;
    if ( ptr != (_BYTE *)&unk_8058789 )
      free(ptr);
    ptr = sub_8050C03(size);
    v9[2 * a1 + 1] = (int)ptr;
    sub_804EC1E(ptr, size, a2, a3, *(_DWORD *)a4, v13, a4 + 8, *(const char **)(a4 + 40), *(const char **)(a4 + 44));
  }
  *__errno_location() = v11;
  return ptr;
}
// 805822C: using guessed type int dword_805822C;
// 8058230: using guessed type int dword_8058230;
// 8058234: using guessed type void *off_8058234;
// 8058238: using guessed type int *off_8058238;

//----- (0804FED3) --------------------------------------------------------
_BYTE *__cdecl sub_804FED3(signed int a1, _BYTE *a2)
{
  return sub_804FC98(a1, a2, -1, (int)dword_8058749);
}
// 8058749: using guessed type int dword_8058749[];

//----- (0804FEFD) --------------------------------------------------------
_BYTE *__cdecl sub_804FEFD(signed int a1, _BYTE *a2, int a3)
{
  return sub_804FC98(a1, a2, a3, (int)dword_8058749);
}
// 8058749: using guessed type int dword_8058749[];

//----- (0804FF73) --------------------------------------------------------
_BYTE *__cdecl sub_804FF73(signed int a1, int a2, _BYTE *a3)
{
  char v4; // [esp+10h] [ebp-38h]

  sub_804EAB3(&v4, a2);
  return sub_804FC98(a1, a3, -1, (int)&v4);
}

//----- (0804FFBF) --------------------------------------------------------
_BYTE *__cdecl sub_804FFBF(signed int a1, int a2, _BYTE *a3, int a4)
{
  char v5; // [esp+10h] [ebp-38h]

  sub_804EAB3(&v5, a2);
  return sub_804FC98(a1, a3, a4, (int)&v5);
}

//----- (0804FFFC) --------------------------------------------------------
_BYTE *__cdecl sub_804FFFC(int a1, _BYTE *a2)
{
  return sub_804FF73(0, a1, a2);
}

//----- (08050059) --------------------------------------------------------
_BYTE *__cdecl sub_8050059(_BYTE *a1, int a2, unsigned __int8 a3)
{
  int v4; // [esp+20h] [ebp-38h]
  int v5; // [esp+24h] [ebp-34h]
  int v6; // [esp+28h] [ebp-30h]
  int v7; // [esp+2Ch] [ebp-2Ch]
  int v8; // [esp+30h] [ebp-28h]
  int v9; // [esp+34h] [ebp-24h]
  int v10; // [esp+38h] [ebp-20h]
  int v11; // [esp+3Ch] [ebp-1Ch]
  int v12; // [esp+40h] [ebp-18h]
  int v13; // [esp+44h] [ebp-14h]
  int v14; // [esp+48h] [ebp-10h]
  int v15; // [esp+4Ch] [ebp-Ch]

  v4 = dword_8058749[0];
  v5 = dword_805874D;
  v6 = dword_8058751;
  v7 = dword_8058755;
  v8 = dword_8058759;
  v9 = dword_805875D;
  v10 = dword_8058761;
  v11 = dword_8058765;
  v12 = dword_8058769;
  v13 = dword_805876D;
  v14 = dword_8058771;
  v15 = dword_8058775;
  sub_804E9A2((int)&v4, a3, 1);
  return sub_804FC98(0, a1, a2, (int)&v4);
}
// 8058749: using guessed type int dword_8058749[];
// 805874D: using guessed type int dword_805874D;
// 8058751: using guessed type int dword_8058751;
// 8058755: using guessed type int dword_8058755;
// 8058759: using guessed type int dword_8058759;
// 805875D: using guessed type int dword_805875D;
// 8058761: using guessed type int dword_8058761;
// 8058765: using guessed type int dword_8058765;
// 8058769: using guessed type int dword_8058769;
// 805876D: using guessed type int dword_805876D;
// 8058771: using guessed type int dword_8058771;
// 8058775: using guessed type int dword_8058775;

//----- (08050103) --------------------------------------------------------
_BYTE *__cdecl sub_8050103(_BYTE *a1, unsigned __int8 a2)
{
  return sub_8050059(a1, -1, a2);
}

//----- (0805014E) --------------------------------------------------------
_BYTE *__cdecl sub_805014E(_BYTE *a1)
{
  return sub_8050103(a1, 0x3Au);
}

//----- (0805018B) --------------------------------------------------------
_BYTE *__cdecl sub_805018B(signed int a1, int a2, _BYTE *a3)
{
  int v4; // [esp+10h] [ebp-6Ch]
  int v5; // [esp+14h] [ebp-68h]
  int v6; // [esp+18h] [ebp-64h]
  int v7; // [esp+1Ch] [ebp-60h]
  int v8; // [esp+20h] [ebp-5Ch]
  int v9; // [esp+24h] [ebp-58h]
  int v10; // [esp+28h] [ebp-54h]
  int v11; // [esp+2Ch] [ebp-50h]
  int v12; // [esp+30h] [ebp-4Ch]
  int v13; // [esp+34h] [ebp-48h]
  int v14; // [esp+38h] [ebp-44h]
  int v15; // [esp+3Ch] [ebp-40h]
  int v16; // [esp+40h] [ebp-3Ch]
  int v17; // [esp+44h] [ebp-38h]
  int v18; // [esp+48h] [ebp-34h]
  int v19; // [esp+4Ch] [ebp-30h]
  int v20; // [esp+50h] [ebp-2Ch]
  int v21; // [esp+54h] [ebp-28h]
  int v22; // [esp+58h] [ebp-24h]
  int v23; // [esp+5Ch] [ebp-20h]
  int v24; // [esp+60h] [ebp-1Ch]
  int v25; // [esp+64h] [ebp-18h]
  int v26; // [esp+68h] [ebp-14h]
  int v27; // [esp+6Ch] [ebp-10h]

  sub_804EAB3(&v4, a2);
  v16 = v4;
  v17 = v5;
  v18 = v6;
  v19 = v7;
  v20 = v8;
  v21 = v9;
  v22 = v10;
  v23 = v11;
  v24 = v12;
  v25 = v13;
  v26 = v14;
  v27 = v15;
  sub_804E9A2((int)&v16, 0x3Au, 1);
  return sub_804FC98(a1, a3, -1, (int)&v16);
}

//----- (0805023C) --------------------------------------------------------
_BYTE *__cdecl sub_805023C(signed int a1, int a2, int a3, _BYTE *a4)
{
  return sub_805027C(a1, a2, a3, a4, -1);
}

//----- (0805027C) --------------------------------------------------------
_BYTE *__cdecl sub_805027C(signed int a1, int a2, int a3, _BYTE *a4, int a5)
{
  int v6; // [esp+10h] [ebp-38h]
  int v7; // [esp+14h] [ebp-34h]
  int v8; // [esp+18h] [ebp-30h]
  int v9; // [esp+1Ch] [ebp-2Ch]
  int v10; // [esp+20h] [ebp-28h]
  int v11; // [esp+24h] [ebp-24h]
  int v12; // [esp+28h] [ebp-20h]
  int v13; // [esp+2Ch] [ebp-1Ch]
  int v14; // [esp+30h] [ebp-18h]
  int v15; // [esp+34h] [ebp-14h]
  int v16; // [esp+38h] [ebp-10h]
  int v17; // [esp+3Ch] [ebp-Ch]

  v6 = dword_8058749[0];
  v7 = dword_805874D;
  v8 = dword_8058751;
  v9 = dword_8058755;
  v10 = dword_8058759;
  v11 = dword_805875D;
  v12 = dword_8058761;
  v13 = dword_8058765;
  v14 = dword_8058769;
  v15 = dword_805876D;
  v16 = dword_8058771;
  v17 = dword_8058775;
  sub_804EA59(&v6, a2, a3);
  return sub_804FC98(a1, a4, a5, (int)&v6);
}
// 8058749: using guessed type int dword_8058749[];
// 805874D: using guessed type int dword_805874D;
// 8058751: using guessed type int dword_8058751;
// 8058755: using guessed type int dword_8058755;
// 8058759: using guessed type int dword_8058759;
// 805875D: using guessed type int dword_805875D;
// 8058761: using guessed type int dword_8058761;
// 8058765: using guessed type int dword_8058765;
// 8058769: using guessed type int dword_8058769;
// 805876D: using guessed type int dword_805876D;
// 8058771: using guessed type int dword_8058771;
// 8058775: using guessed type int dword_8058775;

//----- (08050376) --------------------------------------------------------
_BYTE *__cdecl sub_8050376(signed int a1, _BYTE *a2, int a3)
{
  return sub_804FC98(a1, a2, a3, (int)&unk_805824C);
}

//----- (080503D3) --------------------------------------------------------
_BYTE *__cdecl sub_80503D3(signed int a1, _BYTE *a2)
{
  return sub_8050376(a1, a2, -1);
}

//----- (08050407) --------------------------------------------------------
_BYTE *__cdecl sub_8050407(_BYTE *a1)
{
  return sub_80503D3(0, a1);
}

//----- (08050432) --------------------------------------------------------
int __cdecl sub_8050432(int fd)
{
  return sub_80515CB(fd, 0, 3);
}

//----- (08050455) --------------------------------------------------------
int __cdecl sub_8050455(FILE *stream, int a2, int a3, int a4, int a5, int a6)
{
  char *v6; // eax
  char *v7; // eax
  int v8; // ebx
  char *v9; // eax
  int result; // eax
  int v11; // esi
  int v12; // ebx
  char *v13; // eax
  int v14; // edi
  int v15; // esi
  int v16; // ebx
  char *v17; // eax
  int v18; // ST4C_4
  int v19; // edi
  int v20; // esi
  int v21; // ebx
  char *v22; // eax
  int v23; // ST4C_4
  int v24; // ST48_4
  int v25; // edi
  int v26; // esi
  int v27; // ebx
  char *v28; // eax
  int v29; // ST4C_4
  int v30; // ST48_4
  int v31; // ST44_4
  int v32; // edi
  int v33; // esi
  int v34; // ebx
  char *v35; // eax
  int v36; // esi
  int v37; // ST4C_4
  int v38; // ST48_4
  int v39; // ST44_4
  int v40; // ST40_4
  int v41; // edi
  int v42; // ebx
  char *v43; // eax
  int v44; // edi
  int v45; // ST4C_4
  int v46; // ST48_4
  int v47; // ST44_4
  int v48; // ST40_4
  int v49; // ST3C_4
  int v50; // esi
  int v51; // ebx
  char *v52; // eax
  int v53; // edi
  int v54; // ST4C_4
  int v55; // ST48_4
  int v56; // ST44_4
  int v57; // ST40_4
  int v58; // ST3C_4
  int v59; // ST38_4
  int v60; // esi
  int v61; // ebx
  char *v62; // eax
  int v63; // edi
  int v64; // ST4C_4
  int v65; // ST48_4
  int v66; // ST44_4
  int v67; // ST40_4
  int v68; // ST3C_4
  int v69; // ST38_4
  int v70; // esi
  int v71; // ebx
  char *v72; // eax

  if ( a2 )
    fprintf(stream, "%s (%s) %s\n", a2, a3, a4);
  else
    fprintf(stream, "%s %s\n", a3, a4);
  v6 = gettext("(C)");
  fprintf(stream, "Copyright %s %d Free Software Foundation, Inc.", v6, 2017);
  v7 = gettext(
         "\n"
         "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\n"
         "This is free software: you are free to change and redistribute it.\n"
         "There is NO WARRANTY, to the extent permitted by law.\n"
         "\n");
  fputs_unlocked(v7, stream);
  switch ( a6 )
  {
    case 0:
      abort();
      return result;
    case 1:
      v8 = *(_DWORD *)a5;
      v9 = gettext("Written by %s.\n");
      result = fprintf(stream, v9, v8);
      break;
    case 2:
      v11 = *(_DWORD *)(a5 + 4);
      v12 = *(_DWORD *)a5;
      v13 = gettext("Written by %s and %s.\n");
      result = fprintf(stream, v13, v12, v11);
      break;
    case 3:
      v14 = *(_DWORD *)(a5 + 8);
      v15 = *(_DWORD *)(a5 + 4);
      v16 = *(_DWORD *)a5;
      v17 = gettext("Written by %s, %s, and %s.\n");
      result = fprintf(stream, v17, v16, v15, v14);
      break;
    case 4:
      v18 = *(_DWORD *)(a5 + 12);
      v19 = *(_DWORD *)(a5 + 8);
      v20 = *(_DWORD *)(a5 + 4);
      v21 = *(_DWORD *)a5;
      v22 = gettext("Written by %s, %s, %s,\nand %s.\n");
      result = fprintf(stream, v22, v21, v20, v19, v18);
      break;
    case 5:
      v23 = *(_DWORD *)(a5 + 16);
      v24 = *(_DWORD *)(a5 + 12);
      v25 = *(_DWORD *)(a5 + 8);
      v26 = *(_DWORD *)(a5 + 4);
      v27 = *(_DWORD *)a5;
      v28 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
      result = fprintf(stream, v28, v27, v26, v25, v24, v23);
      break;
    case 6:
      v29 = *(_DWORD *)(a5 + 20);
      v30 = *(_DWORD *)(a5 + 16);
      v31 = *(_DWORD *)(a5 + 12);
      v32 = *(_DWORD *)(a5 + 8);
      v33 = *(_DWORD *)(a5 + 4);
      v34 = *(_DWORD *)a5;
      v35 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
      result = fprintf(stream, v35, v34, v33, v32, v31, v30, v29);
      break;
    case 7:
      v36 = *(_DWORD *)(a5 + 24);
      v37 = *(_DWORD *)(a5 + 20);
      v38 = *(_DWORD *)(a5 + 16);
      v39 = *(_DWORD *)(a5 + 12);
      v40 = *(_DWORD *)(a5 + 8);
      v41 = *(_DWORD *)(a5 + 4);
      v42 = *(_DWORD *)a5;
      v43 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
      result = fprintf(stream, v43, v42, v41, v40, v39, v38, v37, v36);
      break;
    case 8:
      v44 = *(_DWORD *)(a5 + 28);
      v45 = *(_DWORD *)(a5 + 24);
      v46 = *(_DWORD *)(a5 + 20);
      v47 = *(_DWORD *)(a5 + 16);
      v48 = *(_DWORD *)(a5 + 12);
      v49 = *(_DWORD *)(a5 + 8);
      v50 = *(_DWORD *)(a5 + 4);
      v51 = *(_DWORD *)a5;
      v52 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
      result = fprintf(stream, v52, v51, v50, v49, v48, v47, v46, v45, v44);
      break;
    case 9:
      v53 = *(_DWORD *)(a5 + 32);
      v54 = *(_DWORD *)(a5 + 28);
      v55 = *(_DWORD *)(a5 + 24);
      v56 = *(_DWORD *)(a5 + 20);
      v57 = *(_DWORD *)(a5 + 16);
      v58 = *(_DWORD *)(a5 + 12);
      v59 = *(_DWORD *)(a5 + 8);
      v60 = *(_DWORD *)(a5 + 4);
      v61 = *(_DWORD *)a5;
      v62 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
      result = fprintf(stream, v62, v61, v60, v59, v58, v57, v56, v55, v54, v53);
      break;
    default:
      v63 = *(_DWORD *)(a5 + 32);
      v64 = *(_DWORD *)(a5 + 28);
      v65 = *(_DWORD *)(a5 + 24);
      v66 = *(_DWORD *)(a5 + 20);
      v67 = *(_DWORD *)(a5 + 16);
      v68 = *(_DWORD *)(a5 + 12);
      v69 = *(_DWORD *)(a5 + 8);
      v70 = *(_DWORD *)(a5 + 4);
      v71 = *(_DWORD *)a5;
      v72 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
      result = fprintf(stream, v72, v71, v70, v69, v68, v67, v66, v65, v64, v63);
      break;
  }
  return result;
}
// 8048F50: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (080509C8) --------------------------------------------------------
int __cdecl sub_80509C8(FILE *stream, int a2, int a3, int a4, int a5)
{
  int *v5; // eax
  unsigned int i; // [esp+24h] [ebp-34h]
  int v8[12]; // [esp+28h] [ebp-30h]

  for ( i = 0; i <= 9; ++i )
  {
    v5 = (int *)a5;
    a5 += 4;
    v8[i] = *v5;
    if ( !v8[i] )
      break;
  }
  return sub_8050455(stream, a2, a3, a4, (int)v8, i);
}
// 80509C8: using guessed type int var_30[12];

//----- (08050A2E) --------------------------------------------------------
int sub_8050A2E(FILE *stream, int a2, int a3, int a4, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a4);
  return sub_80509C8(stream, a2, a3, a4, (int)va);
}

//----- (08050B41) --------------------------------------------------------
void *__cdecl sub_8050B41(void *ptr, int a2, int a3)
{
  void *v3; // eax
  unsigned int v5; // [esp+1Ch] [ebp-Ch]

  v5 = *(_DWORD *)a2;
  v3 = &loc_8050B6E;
  if ( ptr )
    v3 = &loc_8050BBA;
  dword_805818C = (int)v3;
  sub_8052758();
  if ( !v5 )
    v5 = (0x40u / a3 == 0) + 0x40u / a3;
  if ( 0x7FFFFFFFu / a3 < v5 )
    sub_8050DCB();
  *(_DWORD *)a2 = v5;
  return sub_8050C5E(ptr, a3 * v5);
}
// 805818C: using guessed type int dword_805818C;

//----- (08050C03) --------------------------------------------------------
void *__cdecl sub_8050C03(size_t size)
{
  return sub_8050C16(size);
}

//----- (08050C16) --------------------------------------------------------
void *__cdecl sub_8050C16(size_t size)
{
  void *v2; // [esp+1Ch] [ebp-Ch]

  v2 = malloc(size);
  if ( !v2 && size )
    sub_8050DCB();
  return v2;
}

//----- (08050C5E) --------------------------------------------------------
void *__cdecl sub_8050C5E(void *ptr, size_t size)
{
  void *v2; // eax
  void *result; // eax
  int v4; // [esp+0h] [ebp-18h]
  void *ptra; // [esp+20h] [ebp+8h]

  v2 = &loc_8050C83;
  if ( size )
    v2 = &loc_8050C9B;
  dword_8058114 = (int)v2;
  sub_8052A15(v4);
  if ( ptr )
  {
    free(ptr);
    result = 0;
  }
  else
  {
    ptra = realloc(0, size);
    if ( !ptra )
    {
      if ( size )
        sub_8050DCB();
    }
    result = ptra;
  }
  return result;
}
// 8052A15: using guessed type int __stdcall sub_8052A15(_DWORD);
// 8058114: using guessed type int dword_8058114;

//----- (08050CC6) --------------------------------------------------------
void *__cdecl sub_8050CC6(void *ptr, int a2)
{
  return sub_8050B41(ptr, a2, 1);
}

//----- (08050D12) --------------------------------------------------------
void *__cdecl sub_8050D12(size_t nmemb, size_t size)
{
  void *v3; // [esp+0h] [ebp-Ch]

  if ( 0x7FFFFFFF / size < nmemb || (v3 = calloc(nmemb, size)) == 0 )
    sub_8050DCB();
  return v3;
}

//----- (08050D6D) --------------------------------------------------------
void *__cdecl sub_8050D6D(void *src, size_t n)
{
  void *v2; // eax

  v2 = sub_8050C16(n);
  return memcpy(v2, src, n);
}

//----- (08050DCB) --------------------------------------------------------
void __noreturn sub_8050DCB()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (08050E04) --------------------------------------------------------
void __cdecl sub_8050E04(int errnum, int a2, int a3, int a4, int a5)
{
  char *v5; // eax
  char *v6; // eax
  _BYTE *v7; // esi
  _BYTE *v8; // ebx
  char *v9; // eax

  v5 = gettext("string comparison failed");
  error(0, errnum, v5);
  v6 = gettext("Set LC_ALL='C' to work around the problem.");
  error(0, 0, v6);
  v7 = sub_804FFBF(1, 8, (_BYTE *)a4, a5);
  v8 = sub_804FFBF(0, 8, (_BYTE *)a2, a3);
  v9 = gettext("The strings compared were %s and %s.");
  error(status, 0, v9, v8, v7);
}

//----- (08050EE2) --------------------------------------------------------
int __cdecl sub_8050EE2(void *s1, size_t n, void *s2, int a4)
{
  int v5; // [esp+28h] [ebp-10h]
  int errnum; // [esp+2Ch] [ebp-Ch]

  v5 = sub_805207A(s1, n, s2, a4);
  errnum = *__errno_location();
  if ( errnum )
    sub_8050E04(errnum, (int)s1, n, (int)s2, a4);
  return v5;
}

//----- (08050FDD) --------------------------------------------------------
int __cdecl sub_8050FDD(unsigned int *a1, unsigned int a2)
{
  if ( 0xFFFFFFFF / a2 < *a1 )
  {
    *a1 = -1;
    dword_8058128 = (int)&loc_805103C;
    sub_80529A7();
  }
  *a1 *= a2;
  return 0;
}
// 80529A7: using guessed type int sub_80529A7(void);
// 8058128: using guessed type int dword_8058128;

//----- (0805103E) --------------------------------------------------------
int __cdecl sub_805103E(unsigned int *a1, unsigned int a2, int a3)
{
  int v3; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; i |= sub_8050FDD(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}

//----- (08051084) --------------------------------------------------------
int __cdecl sub_8051084(char *nptr, int a2, int base, int a4, char *s)
{
  char **v5; // eax
  int result; // eax
  bool v7; // zf
  void *v8; // eax
  void *v9; // eax
  int v10; // ST08_4
  void *v11; // eax
  int v12; // [esp+0h] [ebp-48h]
  int v13; // [esp+4h] [ebp-44h]
  int v14; // [esp+8h] [ebp-40h]
  int v15; // [esp+Ch] [ebp-3Ch]
  int v16; // [esp+10h] [ebp-38h]
  int v17; // [esp+14h] [ebp-34h]
  int v18; // [esp+18h] [ebp-30h]
  int v19; // [esp+1Ch] [ebp-2Ch]
  char v20; // [esp+20h] [ebp-28h]
  unsigned int v21; // [esp+24h] [ebp-24h]
  int v22; // [esp+28h] [ebp-20h]
  char *v23; // [esp+2Ch] [ebp-1Ch]
  int v24; // [esp+30h] [ebp-18h]
  int v25; // [esp+34h] [ebp-14h]
  int v26; // [esp+38h] [ebp-10h]
  char **endptr; // [esp+3Ch] [ebp-Ch]

  v22 = 0;
  if ( base < 0 || base > 36 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoul");
  if ( a2 )
    v5 = (char **)a2;
  else
    v5 = (char **)&v20;
  endptr = v5;
  *__errno_location() = 0;
  v23 = nptr;
  HIBYTE(v19) = *nptr;
  while ( (*__ctype_b_loc())[HIBYTE(v19)] & 0x2000 )
    HIBYTE(v19) = *++v23;
  if ( HIBYTE(v19) == 45 )
    return 4;
  v21 = strtoul(nptr, endptr, base);
  if ( *endptr == nptr )
  {
    if ( !s || !**endptr || !strchr(s, **endptr) )
      return 4;
    v21 = 1;
    goto LABEL_22;
  }
  if ( !*__errno_location() )
  {
LABEL_22:
    v9 = &loc_80511F4;
    if ( s )
      v9 = &loc_8051220;
    dword_80581A0 = (int)v9;
    sub_80526E6(v12);
    *(_DWORD *)a4 = v21;
    dword_8058150 = (int)&locret_80514ED;
    sub_80528C3(v10, v13, v14, v15, v16, v17, v18, v19, *(_DWORD *)&v20, v21, v22, v23, v24, v25, v26);
    if ( **endptr )
    {
      v24 = 1024;
      v25 = 1;
      v7 = strchr(s, **endptr) == 0;
      v11 = &loc_8051275;
      if ( !v7 )
        v11 = &loc_8051288;
      dword_805818C = (int)v11;
      sub_8052758();
      *(_DWORD *)a4 = v21;
      result = v22 | 2;
    }
    else
    {
      *(_DWORD *)a4 = v21;
      result = v22;
    }
    return result;
  }
  v7 = *__errno_location() == 34;
  v8 = &loc_80511C4;
  if ( v7 )
    v8 = &loc_80511CE;
  dword_8058114 = (int)v8;
  sub_8052A15(v12);
  return 4;
}
// 8051084: could not find valid save-restore pair for ebx
// 80526E6: using guessed type int __stdcall sub_80526E6(_DWORD);
// 80528C3: using guessed type int __stdcall sub_80528C3(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8052A15: using guessed type int __stdcall sub_8052A15(_DWORD);
// 8058114: using guessed type int dword_8058114;
// 8058150: using guessed type int dword_8058150;
// 805818C: using guessed type int dword_805818C;
// 80581A0: using guessed type int dword_80581A0;

//----- (080514EF) --------------------------------------------------------
int __cdecl sub_80514EF(FILE *stream)
{
  bool v2; // zf
  void *v3; // eax
  int v4; // eax
  __int64 v5; // rax
  int v6; // [esp+14h] [ebp-14h]
  int v7; // [esp+18h] [ebp-10h]

  v6 = 0;
  if ( fileno(stream) < 0 )
    return fclose(stream);
  v2 = __freading(stream) == 0;
  v3 = &loc_805154F;
  if ( v2 )
    v3 = &loc_8051588;
  dword_8058128 = (int)v3;
  sub_80529A7();
  v4 = fileno(stream);
  LODWORD(v5) = lseek64(v4, 0, 0, 1);
  if ( v5 != -1 && sub_80517B2(stream) )
    v6 = *__errno_location();
  v7 = fclose(stream);
  if ( v6 )
  {
    *__errno_location() = v6;
    v7 = -1;
  }
  return v7;
}
// 8049090: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 80529A7: using guessed type int sub_80529A7(void);
// 8058128: using guessed type int dword_8058128;

//----- (080515CB) --------------------------------------------------------
int __cdecl sub_80515CB(int fd, int cmd, char a3)
{
  bool v3; // zf
  void *v4; // eax
  int v5; // ST30_4
  int v7; // [esp+1Ch] [ebp-1Ch]
  int v8; // [esp+24h] [ebp-14h]

  if ( cmd != 1030 )
    return fcntl(fd, cmd, a3);
  if ( dword_8058889 < 0 )
  {
    v7 = sub_80515CB(fd, 0, a3);
  }
  else
  {
    v7 = fcntl(fd, 1030, a3);
    if ( v7 < 0 )
    {
      v3 = *__errno_location() == 22;
      v4 = &loc_805165C;
      if ( v3 )
        v4 = &loc_8051668;
      dword_805813C = (int)v4;
      sub_8052935();
    }
    dword_8058889 = 1;
  }
  if ( v7 >= 0 && dword_8058889 == -1 )
  {
    v8 = fcntl(v7, 1);
    if ( v8 < 0 || fcntl(v7, 2, v8 | 1) == -1 )
    {
      v5 = *__errno_location();
      close(v7);
      *__errno_location() = v5;
      v7 = -1;
    }
  }
  return v7;
}
// 805813C: using guessed type int dword_805813C;
// 8058889: using guessed type int dword_8058889;

//----- (08051760) --------------------------------------------------------
int __cdecl sub_8051760(FILE *stream)
{
  void *v1; // eax

  v1 = &loc_805178D;
  if ( !(stream->_flags & 0x100) )
    v1 = &locret_80517B0;
  dword_8058164 = (int)v1;
  sub_8052853();
  return sub_80517F2(stream, 0, 0, 1);
}
// 8052853: using guessed type int sub_8052853(void);
// 8058164: using guessed type int dword_8058164;

//----- (080517B2) --------------------------------------------------------
int __cdecl sub_80517B2(FILE *fp)
{
  if ( !fp || !__freading(fp) )
    return fflush(fp);
  sub_8051760(fp);
  return fflush(fp);
}

//----- (080517F2) --------------------------------------------------------
int __cdecl sub_80517F2(FILE *stream, int a2, int a3, int a4)
{
  int v4; // eax
  __off64_t v5; // rax

  if ( stream->_IO_read_end != stream->_IO_read_ptr
    || stream->_IO_write_ptr != stream->_IO_write_base
    || stream->_IO_save_base )
  {
    return fseeko64(stream, a2, a3, a4);
  }
  v4 = fileno(stream);
  LODWORD(v5) = lseek64(v4, a2, a3, a4);
  if ( v5 == -1 )
    return -1;
  stream->_flags &= 0xFFFFFFEF;
  stream->_offset = v5;
  return 0;
}
// 8048DF0: using guessed type int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8049090: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (080518C4) --------------------------------------------------------
size_t __cdecl sub_80518C4(wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  char v5; // [esp+18h] [ebp-10h]
  size_t v6; // [esp+1Ch] [ebp-Ch]

  if ( !pwc )
    pwc = (wchar_t *)&v5;
  v6 = mbrtowc(pwc, s, n, p);
  if ( v6 <= 0xFFFFFFFD || !n || !((unsigned __int8)sub_804E572(0) ^ 1) )
    return v6;
  *pwc = (unsigned __int8)*s;
  return 1;
}

//----- (08051936) --------------------------------------------------------
int __cdecl sub_8051936(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // esi
  unsigned __int8 *v3; // ebx
  unsigned __int8 v5; // [esp+0h] [ebp-Ah]
  unsigned __int8 v6; // [esp+1h] [ebp-9h]

  v2 = a1;
  v3 = a2;
  if ( a1 == a2 )
    return 0;
  do
  {
    v5 = sub_80523E2(*v2);
    v6 = sub_80523E2(*v3);
    if ( !v5 )
      break;
    ++v2;
    ++v3;
  }
  while ( v5 == v6 );
  return v5 - v6;
}

//----- (080519AB) --------------------------------------------------------
int __cdecl sub_80519AB(FILE *fp)
{
  bool v1; // ST1E_1
  bool v3; // [esp+1Dh] [ebp-Bh]
  bool v4; // [esp+1Fh] [ebp-9h]

  v3 = __fpending(fp) != 0;
  v1 = ferror_unlocked(fp) != 0;
  v4 = sub_80514EF(fp) != 0;
  if ( !v1 && (!v4 || !v3 && *__errno_location() == 9) )
    return 0;
  if ( v4 != 1 )
    *__errno_location() = 0;
  return -1;
}

//----- (08051A3E) --------------------------------------------------------
void *sub_8051A3E()
{
  void *v0; // eax
  int v4; // [esp+0h] [ebp-C8h]
  int v5; // [esp+4h] [ebp-C4h]
  int v6; // [esp+8h] [ebp-C0h]
  int v7; // [esp+Ch] [ebp-BCh]
  int v8; // [esp+10h] [ebp-B8h]
  void *ptr; // [esp+14h] [ebp-B4h]
  int v10; // [esp+18h] [ebp-B0h]
  void *v11; // [esp+18h] [ebp-B0h]
  char *s; // [esp+1Ch] [ebp-ACh]
  void *v13; // [esp+20h] [ebp-A8h]
  void *v14; // [esp+20h] [ebp-A8h]
  int v15; // [esp+24h] [ebp-A4h]
  int v16; // [esp+24h] [ebp-A4h]
  char *v17; // [esp+28h] [ebp-A0h]
  size_t n; // [esp+2Ch] [ebp-9Ch]
  size_t v19; // [esp+30h] [ebp-98h]
  int v20; // [esp+34h] [ebp-94h]
  void *dest; // [esp+38h] [ebp-90h]
  char *desta; // [esp+38h] [ebp-90h]
  int fd; // [esp+3Ch] [ebp-8Ch]
  int fda; // [esp+3Ch] [ebp-8Ch]
  FILE *stream; // [esp+40h] [ebp-88h]
  int c; // [esp+44h] [ebp-84h]
  int ca; // [esp+44h] [ebp-84h]
  size_t v28; // [esp+48h] [ebp-80h]
  size_t v29; // [esp+4Ch] [ebp-7Ch]
  void *v30; // [esp+50h] [ebp-78h]
  char src; // [esp+56h] [ebp-72h]
  char v32; // [esp+89h] [ebp-3Fh]
  unsigned int v33; // [esp+BCh] [ebp-Ch]

  v33 = __readgsdword(0x14u);
  v10 = dword_805888D;
  v0 = &loc_8051A80;
  if ( dword_805888D )
    v0 = &loc_8051EB8;
  dword_8058164 = (int)v0;
  sub_8052853();
  ptr = 0;
  v17 = "charset.alias";
  s = getenv("CHARSETALIASDIR");
  if ( !s || !*s )
  {
    ptr = 0;
    s = (char *)&unk_80542E0;
  }
  n = strlen(s);
  v19 = strlen("charset.alias");
  if ( n && s[n - 1] != 47 )
  {
    dword_80581B4 = (int)&loc_8051B32;
    sub_8052665(v4, v5, v6, v7, v8, 0, v10, s, v13, v15, "charset.alias", n, v19, v20, dest, fd);
  }
  desta = (char *)malloc(n + v19 + 1);
  if ( desta )
  {
    memcpy(desta, s, n);
    memcpy(&desta[n], v17, v19 + 1);
  }
  free(ptr);
  if ( desta )
  {
    fda = open64(desta, 0x20000);
    if ( fda >= 0 )
    {
      stream = fdopen(fda, "r");
      if ( stream )
      {
        v14 = 0;
        v16 = 0;
        while ( 1 )
        {
          c = getc_unlocked(stream);
          if ( c == -1 )
            break;
          if ( c != 10 && c != 32 && c != 9 )
          {
            if ( c == 35 )
            {
              do
                ca = getc_unlocked(stream);
              while ( ca != -1 && ca != 10 );
              if ( ca == -1 )
                break;
            }
            else
            {
              ungetc(c, stream);
              if ( fscanf(stream, "%50s %50s", &src, &v32) <= 1 )
                break;
              v28 = strlen(&src);
              v29 = strlen(&v32);
              v30 = v14;
              if ( v16 )
              {
                v16 += v29 + v28 + 2;
                v14 = realloc(v14, v16 + 1);
              }
              else
              {
                v16 = v28 + v29 + 2;
                v14 = malloc(v28 + v29 + 3);
              }
              if ( !v14 )
              {
                v16 = 0;
                free(v30);
                break;
              }
              strcpy((char *)v14 + v16 - v29 - v28 - 2, &src);
              strcpy((char *)v14 + v16 - v29 - 1, &v32);
            }
          }
        }
        sub_80514EF(stream);
        if ( v16 )
        {
          *((_BYTE *)v14 + v16) = 0;
          v11 = v14;
        }
        else
        {
          v11 = &unk_8054317;
        }
      }
      else
      {
        close(fda);
        v11 = &unk_8054317;
      }
    }
    else
    {
      v11 = &unk_8054317;
    }
    free(desta);
  }
  else
  {
    v11 = &unk_8054317;
  }
  dword_805888D = (int)v11;
  return v11;
}
// 8048D60: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 8052665: using guessed type int __stdcall sub_8052665(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8052853: using guessed type int sub_8052853(void);
// 8058164: using guessed type int dword_8058164;
// 80581B4: using guessed type int dword_80581B4;
// 805888D: using guessed type int dword_805888D;

//----- (08051ED8) --------------------------------------------------------
const char *sub_8051ED8()
{
  char *v0; // ST1C_4
  const char *s1; // [esp+18h] [ebp-10h]
  char *s2; // [esp+1Ch] [ebp-Ch]

  s1 = nl_langinfo(14);
  if ( !s1 )
    s1 = (const char *)&unk_8054317;
  for ( s2 = (char *)sub_8051A3E(); *s2; s2 = &v0[strlen(v0) + 1] )
  {
    if ( !strcmp(s1, s2) || *s2 == 42 && !s2[1] )
    {
      s1 = &s2[strlen(s2) + 1];
      break;
    }
    v0 = &s2[strlen(s2) + 1];
  }
  if ( !*s1 )
    s1 = "ASCII";
  return s1;
}

//----- (08051F9B) --------------------------------------------------------
int __cdecl sub_8051F9B(char *s, int a2, char *s2, int a4)
{
  size_t v4; // ST20_4
  size_t v5; // ST24_4
  bool v7; // zf
  void *v8; // eax
  int v9; // [esp+14h] [ebp-14h]
  char *sa; // [esp+30h] [ebp+8h]
  char *s2a; // [esp+38h] [ebp+10h]
  int v12; // [esp+3Ch] [ebp+14h]

  dword_805818C = (int)&loc_805200B;
  sub_8052758();
  v4 = strlen(s) + 1;
  v5 = strlen(s2) + 1;
  sa = &s[v4];
  s2a = &s2[v5];
  v12 = a4 - v5;
  if ( a2 == v4 )
    return -(v12 != 0);
  if ( !v12 )
    return 1;
  *__errno_location() = 0;
  v9 = strcoll(sa, s2a);
  if ( !v9 )
  {
    v7 = *__errno_location() == 0;
    v8 = &loc_8052055;
    if ( v7 )
      v8 = &loc_805205C;
    dword_8058164 = (int)v8;
    sub_8052853();
  }
  return v9;
}
// 8052853: using guessed type int sub_8052853(void);
// 8058164: using guessed type int dword_8058164;
// 805818C: using guessed type int dword_805818C;

//----- (0805207A) --------------------------------------------------------
int __cdecl sub_805207A(void *s1, size_t n, void *s2, int a4)
{
  char v4; // ST1A_1
  char v5; // ST1B_1
  int v7; // [esp+1Ch] [ebp-Ch]

  if ( n == a4 && !memcmp(s1, s2, n) )
  {
    *__errno_location() = 0;
    v7 = 0;
  }
  else
  {
    v4 = *((_BYTE *)s1 + n);
    v5 = *((_BYTE *)s2 + a4);
    *((_BYTE *)s1 + n) = 0;
    *((_BYTE *)s2 + a4) = 0;
    v7 = sub_8051F9B((char *)s1, n + 1, (char *)s2, a4 + 1);
    *((_BYTE *)s1 + n) = v4;
    *((_BYTE *)s2 + a4) = v5;
  }
  return v7;
}

//----- (08052135) --------------------------------------------------------
#error "8052174: call analysis failed (funcsize=38)"

//----- (080523E2) --------------------------------------------------------
int __cdecl sub_80523E2(int a1)
{
  if ( (unsigned int)(a1 - 65) <= 0x19 )
  {
    dword_8058164 = (int)&loc_8052408;
    sub_8052853();
  }
  return a1;
}
// 8052853: using guessed type int sub_8052853(void);
// 8058164: using guessed type int dword_8058164;

//----- (08052467) --------------------------------------------------------
#error "80524A0: positive sp value has been found (funcsize=18)"

//----- (080524C4) --------------------------------------------------------
int __cdecl sub_80524C4(int a1)
{
  return __cxa_atexit(a1, 0, dword_80581F0);
}
// 8048EB0: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 80581F0: using guessed type int dword_80581F0;

//----- (08052665) --------------------------------------------------------
#error "805266B: positive sp value has been found (funcsize=0)"

//----- (080526E6) --------------------------------------------------------
#error "80526EC: positive sp value has been found (funcsize=0)"

//----- (08052758) --------------------------------------------------------
#error "805275E: positive sp value has been found (funcsize=0)"

//----- (080527CA) --------------------------------------------------------
#error "80527D0: positive sp value has been found (funcsize=0)"

//----- (08052853) --------------------------------------------------------
#error "8052859: positive sp value has been found (funcsize=0)"

//----- (080528C3) --------------------------------------------------------
#error "80528C9: positive sp value has been found (funcsize=0)"

//----- (08052935) --------------------------------------------------------
#error "805293B: positive sp value has been found (funcsize=0)"

//----- (080529A7) --------------------------------------------------------
#error "80529AD: positive sp value has been found (funcsize=0)"

//----- (08052A15) --------------------------------------------------------
#error "8052A1B: positive sp value has been found (funcsize=0)"

//----- (08052A30) --------------------------------------------------------
int (**sub_8052A30())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_8057ED4;
  v1 = &off_8057ED8 - off_8057ED4;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_8057ED4[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 8057ED4: using guessed type int (*off_8057ED4[2])();
// 8057ED8: using guessed type int (*off_8057ED8)();

//----- (08052A94) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 22 decompilation failure(s) on 153 function(s)"
