/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8048D00();
// int strcmp(const char *s1, const char *s2);
// int __cdecl open64(_DWORD, _DWORD); weak
// int putc_unlocked(int c, FILE *stream);
// ssize_t read(int fd, void *buf, size_t nbytes);
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void *memmove(void *dest, const void *src, size_t n);
// void free(void *ptr);
// uintmax_t strtoumax(const char *nptr, char **endptr, int base);
// void *memcpy(void *dest, const void *src, size_t n);
// int fclose(FILE *stream);
// int getc_unlocked(FILE *stream);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// char *textdomain(const char *domainname);
// int ferror_unlocked(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// size_t __ctype_get_mb_cur_max(void);
// char *strcpy(char *dest, const char *src);
// size_t __fpending(FILE *fp);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// void error(int status, int errnum, const char *format, ...);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// char *strchr(const char *s, int c);
// int fscanf(FILE *stream, const char *format, ...);
// size_t strlen(const char *s);
// int fprintf(FILE *stream, const char *format, ...);
// int setvbuf(FILE *stream, char *buf, int modes, size_t n);
// void *memset(void *s, int c, size_t n);
// int ungetc(int c, FILE *stream);
// int *__errno_location(void);
// int fileno(FILE *stream);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// char *strrchr(const char *s, int c);
// int sprintf(char *s, const char *format, ...);
// struct lconv *localeconv(void);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// char *bindtextdomain(const char *domainname, const char *dirname);
// int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// void abort(void);
// int close(int fd);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// void *calloc(size_t nmemb, size_t size);
// int _gmon_start__(void); weak
void sub_8049133();
void sub_8049150();
int sub_8049160();
int sub_80491D0();
int sub_80491F0();
void sub_804924F();
void sub_804926A();
int sub_804927A();
void sub_8049392();
void sub_80493AD();
signed int sub_80493BD();
void sub_80494D5();
void sub_80494F0();
int sub_8049500();
// void __usercall sub_80495AC(void (__cdecl *a1)(signed int)@<eax>);
void sub_80495F8();
void sub_8049613();
int sub_8049623();
void sub_8049780();
void sub_804979B();
int sub_80497AB();
void sub_80498A7();
void sub_80498C2();
int sub_80498D2();
void sub_80499DE();
void sub_80499F9();
int sub_8049A09();
void sub_8049B59();
void sub_8049B74();
int sub_8049B84();
void sub_8049D4C();
void sub_8049D67();
int sub_8049D77();
void sub_8049E93();
void sub_8049EAE();
// int __usercall sub_8049EBE@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>);
void sub_804A03B();
signed int sub_804A0C9();
int sub_804A0D3(void); // weak
void sub_804A0E2();
signed int sub_804A0F2();
void sub_804A2A6();
void sub_804A2C1();
int sub_804A30E();
void sub_804A4D3();
void sub_804A4EE();
// int __usercall sub_804A4FE@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>);
// void __usercall sub_804A692(int a1@<eax>, signed int a2@<ebx>);
void sub_804A702();
void sub_804A7B6();
signed int sub_804A80D();
void sub_804A9E7();
void sub_804AB43();
int sub_804AB53();
void sub_804ACE5();
void sub_804ADB8();
// int __usercall sub_804AE78@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>);
void sub_804AFDB();
void sub_804B049();
// signed int __usercall sub_804B04D@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>);
// void __usercall __noreturn sub_804B0C4(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>);
int sub_804B180();
void sub_804B313();
void sub_804B3A2();
int sub_804B4BD();
int sub_804B5E6();
int __cdecl sub_804B611(char *s1); // idb
void __cdecl __noreturn sub_804B80D(int status); // idb
// int __usercall main@<eax>(signed int a1@<ebx>, int argc, char **argv);
// void __usercall sub_804C2BE(signed int a1@<ebx>);
int __cdecl sub_804C3F1(int a1, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_804C442@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>, FILE *stream);
int __cdecl sub_804C542(int, _TBYTE); // idb
char *__cdecl sub_804C7DE(int a1, size_t n, int a3, int a4);
void *__cdecl sub_804C9C5(int a1, int a2, char *s, int a4, int a5, int a6, int a7, int a8);
// signed __int64 __usercall sub_804D712@<edx:eax>(signed int a1@<ebx>);
// int __usercall sub_804D7A1@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>, __int16 *a7@<ebp>, char *a8, _DWORD *a9, _DWORD *a10);
char *__cdecl sub_804DA33(char *s);
// int __usercall sub_804DBCC@<eax>(signed int a1@<ebx>, int *a2, unsigned __int8 a3, char a4);
// int *__usercall sub_804DD08@<eax>(signed int a1@<ebx>, int *a2, int a3, int a4);
// _DWORD *__userpurge sub_804DDAE@<eax>(_DWORD *a1, int a2);
// char *__usercall sub_804DE31@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>, int *a7@<ebp>, const char *msgid, int a9);
// void __usercall sub_804DFC9(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>, int a7, int a8, int a9, int a10, unsigned int a11);
void *__cdecl sub_804ED51(int a1, int a2, _DWORD *a3, int *a4);
void sub_804F154();
// _BYTE *__usercall sub_804F24B@<eax>(signed int a1@<ebx>, signed int a2, int a3, int a4, unsigned int *a5);
// _BYTE *__usercall sub_804F51A@<eax>(signed int a1@<ebx>, signed int a2, int a3);
// _BYTE *__usercall sub_804F544@<eax>(signed int a1@<ebx>, signed int a2, int a3, int a4);
// _BYTE *__usercall sub_804F5F0@<eax>(signed int a1@<ebx>, int a2);
// _BYTE *__usercall sub_804F64E@<eax>(signed int a1@<ebx>, signed int a2, int a3, int a4);
// _BYTE *__usercall sub_804F6F7@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>, int *a7@<ebp>, signed int a8, int a9, int a10, int a11);
// _BYTE *__usercall sub_804F905@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>, signed int *a7@<ebp>, int a8, int a9, unsigned __int8 a10);
// _BYTE *__usercall sub_804FB10@<eax>(signed int a1@<ebx>, int a2, unsigned __int8 a3);
// _BYTE *__usercall sub_804FBB7@<eax>(signed int a1@<ebx>, int a2);
// _BYTE *__usercall sub_804FC67@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>, int a7, int a8);
// _BYTE *__usercall sub_804FDDE@<eax>(signed int a1@<ebx>, signed int a2, int a3, int a4, int a5);
// _BYTE *__usercall sub_804FE0E@<eax>(signed int a1@<ebx>, signed int a2, int a3, int a4, int a5, int a6);
// _BYTE *__usercall sub_804FFE4@<eax>(signed int a1@<ebx>, signed int a2, int a3, int a4);
// _BYTE *__usercall sub_80500F6@<eax>(signed int a1@<ebx>, signed int a2, int a3);
// _BYTE *__usercall sub_8050118@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>, int a7);
int __cdecl sub_8050185(int fd, void *buf, size_t nbytes); // idb
int __cdecl sub_805032F(FILE *stream, int, int, int, int, int); // idb
// int __usercall sub_8050AB4@<eax>(signed int a1@<ebx>, FILE *stream, int a3, int a4, int a5, int a6);
// int __usercall sub_8050C58@<eax>(signed int a1@<ebx>, FILE *stream, int a3, int a4, int a5, ...);
// void *__usercall sub_8050D85@<eax>(signed int a1@<ebx>, void *ptr, unsigned int *a3, unsigned int a4);
// void *__usercall sub_8050EE0@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>, size_t size);
// void *__usercall sub_8050F4D@<eax>(signed int a1@<ebx>, size_t size);
// void *__usercall sub_8051006@<eax>(signed int a1@<ebx>, void *ptr, size_t size);
// void *__usercall sub_8051102@<eax>(signed int a1@<ebx>, size_t nmemb, size_t size);
// void *__usercall sub_8051140@<eax>(signed int a1@<ebx>, void *src, size_t n);
// void __usercall __noreturn sub_805124E(signed int a1@<ebx>);
void sub_80512D2();
// void __usercall sub_80512D7(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>, signed int *a7@<ebp>, int *a8, int a9);
// signed int __usercall sub_8051382@<eax>(signed int a1@<ebx>, unsigned int *a2, signed int a3);
// int __usercall sub_80515C1@<eax>(signed int a1@<ebx>, unsigned int *a2, signed int a3, int a4);
// int __usercall sub_80516FB@<eax>(signed int a1@<ebx>, char *nptr, int a3, int base, int a5, char *s);
// int __usercall sub_8051BDC@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>, __int16 *a7@<ebp>, FILE *stream);
int __cdecl sub_8051CEC(FILE *stream); // idb
// int __usercall sub_8051D98@<eax>(signed int a1@<ebx>, FILE *fp);
int __cdecl sub_8051E7C(FILE *stream, int, int, int); // idb
// unsigned int __usercall sub_8051FE8@<eax>(signed int a1@<ebx>, wchar_t *pwc, char *s, size_t n, mbstate_t *p);
int __cdecl sub_80520CC(char *s, int, int, size_t n); // idb
// void __usercall sub_8052236(signed int a1@<ebx>, int a2, int a3, int a4);
int __cdecl sub_8052343(void *s1, char *s, size_t a3);
int sub_8052611();
int sub_805261C();
// int __usercall sub_8052627@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int *a5@<eax>, signed int a6@<ebx>);
int __cdecl sub_80526D7(unsigned __int8 *a1, unsigned __int8 *a2);
// int __usercall sub_8052761@<eax>(signed int a1@<ebx>, FILE *fp);
signed int sub_805288C();
// signed int __usercall sub_8052896@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>);
int sub_8052951(void); // weak
int sub_8052952(void); // weak
// int __usercall sub_8052953@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>, int category);
// void *__usercall sub_80529F0@<eax>(signed int a1@<ebx>);
// const char *__usercall sub_8052F4C@<eax>(signed int a1@<ebx>);
signed int sub_805322D();
// void __usercall sub_8053237(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed int a5@<ebx>);
// int __usercall sub_8053344@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>, int a7);
// signed __int64 __usercall sub_80533D9@<edx:eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>, unsigned __int64 a7, unsigned int a8, unsigned int a9);
int __cdecl sub_80535D3(unsigned __int64 a1, __int64 a2);
int __cdecl sub_80538AC(int a1);
int (**sub_8054070())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_804953D; // weak
_UNKNOWN loc_804A630; // weak
_UNKNOWN loc_804B0E4; // weak
_UNKNOWN loc_804B8FE; // weak
_UNKNOWN loc_804BC4B; // weak
_UNKNOWN loc_804BF93; // weak
_UNKNOWN loc_804BFFB; // weak
_UNKNOWN loc_804C307; // weak
_UNKNOWN loc_804C5AC; // weak
_UNKNOWN loc_804C5E1; // weak
_UNKNOWN loc_804C7C3; // weak
_UNKNOWN loc_804EF22; // weak
_UNKNOWN loc_8050215; // weak
_UNKNOWN locret_8050238; // weak
_UNKNOWN loc_8051DC3; // weak
_UNKNOWN loc_8051DDB; // weak
_UNKNOWN locret_8051E61; // weak
_UNKNOWN loc_8053315; // weak
char locale = '\0'; // idb
struct option longopts = { "sysv", 0, NULL, 115 }; // idb
_UNKNOWN unk_80545A1; // weak
_UNKNOWN unk_80545A3; // weak
char *off_80545C4[2] = { "human-readable", "si" }; // weak
int dword_80545D0[2] = { 176, 144 }; // idb
_UNKNOWN unk_8054766; // weak
_UNKNOWN unk_805476A; // weak
_UNKNOWN unk_8054776; // weak
_UNKNOWN unk_805477A; // weak
_UNKNOWN unk_805477D; // weak
_UNKNOWN unk_805477F; // weak
_DWORD off_8054784[11] =
{
  134537642,
  134537566,
  134537585,
  134537562,
  134537570,
  134537355,
  134537344,
  134537412,
  134537425,
  134537425,
  134537425
}; // idb
char aWrittenBySSSS[28] = "Written by %s, %s, %s,\n%s, %"; // idb
void *off_8054D0C = &loc_8050481; // weak
char assertion[4] = "0 <="; // idb
void *off_8054E74 = &loc_8051952; // weak
void *off_8054E84 = &loc_80519B5; // weak
void *off_8054E88 = &loc_80519B5; // weak
void *off_8054E94 = &loc_8051952; // weak
void *off_8054E98 = &loc_80519B5; // weak
_UNKNOWN unk_80550D3; // weak
_UNKNOWN unk_80551E8; // weak
_UNKNOWN unk_80551EB; // weak
_UNKNOWN unk_8057224; // weak
_UNKNOWN unk_8057227; // weak
int (*off_8058EC0[2])() = { &sub_80491F0, &sub_80491D0 }; // weak
int (*off_8058EC4)() = &sub_80491D0; // weak
int (*dword_8059008)(void) = NULL; // weak
int (*dword_80591CC)(void) = NULL; // weak
int dword_80591E4 = 0; // weak
int off_80591E8 = 134563193; // idb
int status = 1; // idb
int dword_8059200 = 1; // weak
int dword_8059204 = 256; // weak
void *off_8059208 = &unk_8059822; // weak
int *off_805920C = &dword_8059204; // weak
_UNKNOWN unk_8059220; // weak
_UNKNOWN unk_8059248; // weak
_UNKNOWN unk_805924B; // weak
_UNKNOWN unk_8059254; // weak
_UNKNOWN unk_8059257; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int program_invocation_name; // weak
int optind; // weak
int stdin; // weak
FILE *stdout; // idb
char byte_80592A8; // weak
_UNKNOWN unk_8059462; // weak
_UNKNOWN unk_80596AA; // weak
char byte_80597CB; // weak
char byte_80597D2; // weak
int dword_80597D6; // weak
int dword_80597E2; // weak
int dword_80597E6; // weak
int dword_80597EA; // weak
int dword_80597EE; // weak
int dword_80597F2; // weak
int dword_80597F6; // weak
int dword_80597FA; // weak
int dword_80597FE; // weak
int dword_8059802; // weak
int dword_8059806; // weak
int dword_805980A; // weak
int dword_805980E; // weak
_UNKNOWN unk_8059822; // weak
int dword_8059922; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (08048CD0) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 80490F0: using guessed type int _gmon_start__(void);

//----- (08048D00) --------------------------------------------------------
int sub_8048D00()
{
  return dword_8059008();
}
// 8059008: using guessed type int (*dword_8059008)(void);

//----- (08049100) --------------------------------------------------------
#error "8049103: positive sp value has been found (funcsize=2)"

//----- (08049133) --------------------------------------------------------
void sub_8049133()
{
  ;
}

//----- (08049150) --------------------------------------------------------
void sub_8049150()
{
  ;
}

//----- (08049160) --------------------------------------------------------
int sub_8049160()
{
  int result; // eax

  result = &unk_8059257 - &unk_8059254;
  if ( (unsigned int)(&unk_8059257 - &unk_8059254) > 6 )
    result = 0;
  return result;
}
// 8049160: could not find valid save-restore pair for ebp

//----- (080491D0) --------------------------------------------------------
int sub_80491D0()
{
  int result; // eax

  if ( !byte_80592A8 )
  {
    result = sub_8049160();
    byte_80592A8 = 1;
  }
  return result;
}
// 80491D0: could not find valid save-restore pair for ebp
// 80592A8: using guessed type char byte_80592A8;

//----- (080491F0) --------------------------------------------------------
int sub_80491F0()
{
  return 0;
}
// 80491F0: could not find valid save-restore pair for ebp

//----- (0804924F) --------------------------------------------------------
void sub_804924F()
{
  ;
}

//----- (0804926A) --------------------------------------------------------
void sub_804926A()
{
  ;
}

//----- (0804927A) --------------------------------------------------------
int sub_804927A()
{
  int result; // eax

  result = &unk_805924B - &unk_8059248;
  _CF = (unsigned int)(&unk_805924B - &unk_8059248) < 6;
  _OF = __OFSUB__(&unk_805924B - &unk_8059248, 6);
  _ZF = &unk_805924B - &unk_8059248 == 6;
  _SF = &unk_805924B - &unk_8059248 - 6 < 0;
  if ( (unsigned int)(&unk_805924B - &unk_8059248) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 804927A: could not find valid save-restore pair for ebp

//----- (08049392) --------------------------------------------------------
void sub_8049392()
{
  ;
}

//----- (080493AD) --------------------------------------------------------
void sub_80493AD()
{
  ;
}

//----- (080493BD) --------------------------------------------------------
signed int sub_80493BD()
{
  return 3;
}
// 80493BD: could not find valid save-restore pair for ebp

//----- (080494D5) --------------------------------------------------------
void sub_80494D5()
{
  ;
}

//----- (080494F0) --------------------------------------------------------
void sub_80494F0()
{
  ;
}

//----- (08049500) --------------------------------------------------------
int sub_8049500()
{
  int result; // eax

  result = &unk_805924B - &unk_8059248;
  _CF = (unsigned int)(&unk_805924B - &unk_8059248) < 6;
  _OF = __OFSUB__(&unk_805924B - &unk_8059248, 6);
  _ZF = &unk_805924B - &unk_8059248 == 6;
  _SF = &unk_805924B - &unk_8059248 - 6 < 0;
  if ( (unsigned int)(&unk_805924B - &unk_8059248) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 8049500: could not find valid save-restore pair for ebp

//----- (080495AC) --------------------------------------------------------
void __usercall sub_80495AC(void (__cdecl *a1)(signed int)@<eax>)
{
  a1(134577876);
  JUMPOUT(&loc_804953D);
}

//----- (080495F8) --------------------------------------------------------
void sub_80495F8()
{
  ;
}

//----- (08049613) --------------------------------------------------------
void sub_8049613()
{
  ;
}

//----- (08049623) --------------------------------------------------------
int sub_8049623()
{
  int result; // eax

  result = &unk_8057227 - &unk_8057224;
  _CF = (unsigned int)(&unk_8057227 - &unk_8057224) < 6;
  _OF = __OFSUB__(&unk_8057227 - &unk_8057224, 6);
  _ZF = &unk_8057227 - &unk_8057224 == 6;
  _SF = &unk_8057227 - &unk_8057224 - 6 < 0;
  if ( (unsigned int)(&unk_8057227 - &unk_8057224) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 8049623: could not find valid save-restore pair for ebp

//----- (08049780) --------------------------------------------------------
void sub_8049780()
{
  ;
}

//----- (0804979B) --------------------------------------------------------
void sub_804979B()
{
  ;
}

//----- (080497AB) --------------------------------------------------------
int sub_80497AB()
{
  int result; // eax

  result = &unk_805924B - &unk_8059248;
  _CF = (unsigned int)(&unk_805924B - &unk_8059248) < 6;
  _OF = __OFSUB__(&unk_805924B - &unk_8059248, 6);
  _ZF = &unk_805924B - &unk_8059248 == 6;
  _SF = &unk_805924B - &unk_8059248 - 6 < 0;
  if ( (unsigned int)(&unk_805924B - &unk_8059248) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 80497AB: could not find valid save-restore pair for ebp

//----- (080498A7) --------------------------------------------------------
void sub_80498A7()
{
  ;
}

//----- (080498C2) --------------------------------------------------------
void sub_80498C2()
{
  ;
}

//----- (080498D2) --------------------------------------------------------
int sub_80498D2()
{
  int result; // eax

  result = &unk_805924B - &unk_8059248;
  _CF = (unsigned int)(&unk_805924B - &unk_8059248) < 6;
  _OF = __OFSUB__(&unk_805924B - &unk_8059248, 6);
  _ZF = &unk_805924B - &unk_8059248 == 6;
  _SF = &unk_805924B - &unk_8059248 - 6 < 0;
  if ( (unsigned int)(&unk_805924B - &unk_8059248) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 80498D2: could not find valid save-restore pair for ebp

//----- (080499DE) --------------------------------------------------------
void sub_80499DE()
{
  ;
}

//----- (080499F9) --------------------------------------------------------
void sub_80499F9()
{
  ;
}

//----- (08049A09) --------------------------------------------------------
int sub_8049A09()
{
  int result; // eax

  result = &unk_8059462 - (_UNKNOWN *)&program_invocation_short_name;
  _CF = (unsigned int)(&unk_8059462 - (_UNKNOWN *)&program_invocation_short_name) < 6;
  _OF = __OFSUB__(&unk_8059462 - (_UNKNOWN *)&program_invocation_short_name, 6);
  _ZF = &unk_8059462 - (_UNKNOWN *)&program_invocation_short_name == 6;
  _SF = &unk_8059462 - (_UNKNOWN *)&program_invocation_short_name - 6 < 0;
  if ( (unsigned int)(&unk_8059462 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 8049A09: could not find valid save-restore pair for ebp
// 8059260: using guessed type int program_invocation_short_name;

//----- (08049B59) --------------------------------------------------------
void sub_8049B59()
{
  ;
}

//----- (08049B74) --------------------------------------------------------
void sub_8049B74()
{
  ;
}

//----- (08049B84) --------------------------------------------------------
int sub_8049B84()
{
  int result; // eax

  result = &unk_805924B - &unk_8059248;
  _CF = (unsigned int)(&unk_805924B - &unk_8059248) < 6;
  _OF = __OFSUB__(&unk_805924B - &unk_8059248, 6);
  _ZF = &unk_805924B - &unk_8059248 == 6;
  _SF = &unk_805924B - &unk_8059248 - 6 < 0;
  if ( (unsigned int)(&unk_805924B - &unk_8059248) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 8049B84: could not find valid save-restore pair for ebp

//----- (08049D4C) --------------------------------------------------------
void sub_8049D4C()
{
  ;
}

//----- (08049D67) --------------------------------------------------------
void sub_8049D67()
{
  ;
}

//----- (08049D77) --------------------------------------------------------
int sub_8049D77()
{
  int result; // eax

  result = &unk_80551EB - &unk_80551E8;
  _CF = (unsigned int)(&unk_80551EB - &unk_80551E8) < 6;
  _OF = __OFSUB__(&unk_80551EB - &unk_80551E8, 6);
  _ZF = &unk_80551EB - &unk_80551E8 == 6;
  _SF = &unk_80551EB - &unk_80551E8 - 6 < 0;
  if ( (unsigned int)(&unk_80551EB - &unk_80551E8) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 8049D77: could not find valid save-restore pair for ebp

//----- (08049E93) --------------------------------------------------------
void sub_8049E93()
{
  ;
}

//----- (08049EAE) --------------------------------------------------------
void sub_8049EAE()
{
  ;
}

//----- (08049EBE) --------------------------------------------------------
int __usercall sub_8049EBE@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>)
{
  int result; // eax
  int v11; // [esp+18h] [ebp-4h]

  v11 = a5;
  __asm { pushfw }
  if ( a6 >= 10 && ((_BYTE)a6 - 1) * (_BYTE)a6 & 1 )
    abort();
  __asm { popfw }
  result = &unk_805924B - &unk_8059248;
  _CF = (unsigned int)(&unk_805924B - &unk_8059248) < 6;
  _OF = __OFSUB__(&unk_805924B - &unk_8059248, 6);
  _ZF = &unk_805924B - &unk_8059248 == 6;
  _SF = &unk_805924B - &unk_8059248 - 6 < 0;
  if ( (unsigned int)(&unk_805924B - &unk_8059248) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}

//----- (0804A03B) --------------------------------------------------------
void sub_804A03B()
{
  ;
}

//----- (0804A0C9) --------------------------------------------------------
signed int sub_804A0C9()
{
  return 987;
}

//----- (0804A0E2) --------------------------------------------------------
void sub_804A0E2()
{
  ;
}

//----- (0804A0F2) --------------------------------------------------------
signed int sub_804A0F2()
{
  return 4;
}
// 804A0F2: could not find valid save-restore pair for ebp

//----- (0804A2A6) --------------------------------------------------------
void sub_804A2A6()
{
  ;
}

//----- (0804A2C1) --------------------------------------------------------
void sub_804A2C1()
{
  ;
}

//----- (0804A30E) --------------------------------------------------------
int sub_804A30E()
{
  int result; // eax

  result = &unk_805924B - &unk_8059248;
  _CF = (unsigned int)(&unk_805924B - &unk_8059248) < 6;
  _OF = __OFSUB__(&unk_805924B - &unk_8059248, 6);
  _ZF = &unk_805924B - &unk_8059248 == 6;
  _SF = &unk_805924B - &unk_8059248 - 6 < 0;
  if ( (unsigned int)(&unk_805924B - &unk_8059248) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 804A30E: could not find valid save-restore pair for ebp

//----- (0804A4D3) --------------------------------------------------------
void sub_804A4D3()
{
  ;
}

//----- (0804A4EE) --------------------------------------------------------
void sub_804A4EE()
{
  ;
}

//----- (0804A4FE) --------------------------------------------------------
int __usercall sub_804A4FE@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>)
{
  int result; // eax
  int v11; // [esp+3Ah] [ebp-4h]

  v11 = a5;
  __asm { pushfw }
  if ( a6 >= 10 && ((_BYTE)a6 - 1) * (_BYTE)a6 & 1 )
    abort();
  __asm { popfw }
  result = &unk_805924B - &unk_8059248;
  _CF = (unsigned int)(&unk_805924B - &unk_8059248) < 6;
  _OF = __OFSUB__(&unk_805924B - &unk_8059248, 6);
  _ZF = &unk_805924B - &unk_8059248 == 6;
  _SF = &unk_805924B - &unk_8059248 - 6 < 0;
  if ( (unsigned int)(&unk_805924B - &unk_8059248) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}

//----- (0804A692) --------------------------------------------------------
void __usercall sub_804A692(int a1@<eax>, signed int a2@<ebx>)
{
  char v2; // sf

  sub_804A4FE(0, 0, v2, 0, a1, a2);
  JUMPOUT(&loc_804A630);
}

//----- (0804A702) --------------------------------------------------------
void sub_804A702()
{
  ;
}

//----- (0804A7B6) --------------------------------------------------------
void sub_804A7B6()
{
  ;
}

//----- (0804A80D) --------------------------------------------------------
signed int sub_804A80D()
{
  return 4;
}
// 804A80D: could not find valid save-restore pair for ebp
// 8052952: using guessed type int sub_8052952(void);

//----- (0804A9E7) --------------------------------------------------------
void sub_804A9E7()
{
  ;
}

//----- (0804AB43) --------------------------------------------------------
void sub_804AB43()
{
  ;
}

//----- (0804AB53) --------------------------------------------------------
int sub_804AB53()
{
  int result; // eax

  result = &unk_80596AA - (_UNKNOWN *)&program_invocation_short_name;
  _CF = (unsigned int)(&unk_80596AA - (_UNKNOWN *)&program_invocation_short_name) < 6;
  _OF = __OFSUB__(&unk_80596AA - (_UNKNOWN *)&program_invocation_short_name, 6);
  _ZF = &unk_80596AA - (_UNKNOWN *)&program_invocation_short_name == 6;
  _SF = &unk_80596AA - (_UNKNOWN *)&program_invocation_short_name - 6 < 0;
  if ( (unsigned int)(&unk_80596AA - (_UNKNOWN *)&program_invocation_short_name) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 804AB53: could not find valid save-restore pair for ebp
// 8059260: using guessed type int program_invocation_short_name;

//----- (0804ACE5) --------------------------------------------------------
void sub_804ACE5()
{
  ;
}

//----- (0804ADB8) --------------------------------------------------------
void sub_804ADB8()
{
  ;
}

//----- (0804AE78) --------------------------------------------------------
int __usercall sub_804AE78@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>)
{
  int result; // eax
  int v11; // [esp+18h] [ebp-4h]

  v11 = a5;
  __asm { pushfw }
  if ( a6 >= 10 && ((_BYTE)a6 - 1) * (_BYTE)a6 & 1 )
    abort();
  __asm { popfw }
  result = &unk_805924B - &unk_8059248;
  _CF = (unsigned int)(&unk_805924B - &unk_8059248) < 6;
  _OF = __OFSUB__(&unk_805924B - &unk_8059248, 6);
  _ZF = &unk_805924B - &unk_8059248 == 6;
  _SF = &unk_805924B - &unk_8059248 - 6 < 0;
  if ( (unsigned int)(&unk_805924B - &unk_8059248) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 8052951: using guessed type int sub_8052951(void);

//----- (0804AFDB) --------------------------------------------------------
void sub_804AFDB()
{
  ;
}

//----- (0804B049) --------------------------------------------------------
void sub_804B049()
{
  ;
}

//----- (0804B04D) --------------------------------------------------------
signed int __usercall sub_804B04D@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>)
{
  int v7; // [esp-4h] [ebp-4h]

  v7 = a5;
  __asm { pushfw }
  if ( a6 >= 10 && ((_BYTE)a6 - 1) * (_BYTE)a6 & 1 )
    abort();
  __asm { popfw }
  return 549;
}

//----- (0804B0C4) --------------------------------------------------------
void __usercall __noreturn sub_804B0C4(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>)
{
  int v6; // [esp-4h] [ebp-4h]

  v6 = a5;
  __asm { pushfw }
  if ( sub_8052896(_CF, _ZF, _SF, _OF, a5, a6) != 449 )
    sub_8052951();
  __asm { popfw }
  __halt();
  JUMPOUT(loc_804B0E4);
}
// 8052951: using guessed type int sub_8052951(void);

//----- (0804B180) --------------------------------------------------------
int sub_804B180()
{
  int result; // eax

  result = (char *)&off_8054E88 - (char *)&off_8054E84;
  _CF = (unsigned int)((char *)&off_8054E88 - (char *)&off_8054E84) < 6;
  _OF = __OFSUB__((char *)&off_8054E88 - (char *)&off_8054E84, 6);
  _ZF = (char *)&off_8054E88 - (char *)&off_8054E84 == 6;
  _SF = (char *)&off_8054E88 - (char *)&off_8054E84 - 6 < 0;
  if ( (unsigned int)((char *)&off_8054E88 - (char *)&off_8054E84) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 804B180: could not find valid save-restore pair for ebp
// 8054E84: using guessed type void *off_8054E84;
// 8054E88: using guessed type void *off_8054E88;

//----- (0804B313) --------------------------------------------------------
void sub_804B313()
{
  ;
}

//----- (0804B3A2) --------------------------------------------------------
void sub_804B3A2()
{
  ;
}

//----- (0804B4BD) --------------------------------------------------------
int sub_804B4BD()
{
  int result; // eax

  result = (char *)&off_8054E98 - (char *)&off_8054E94;
  _CF = (unsigned int)((char *)&off_8054E98 - (char *)&off_8054E94) < 6;
  _OF = __OFSUB__((char *)&off_8054E98 - (char *)&off_8054E94, 6);
  _ZF = (char *)&off_8054E98 - (char *)&off_8054E94 == 6;
  _SF = (char *)&off_8054E98 - (char *)&off_8054E94 - 6 < 0;
  if ( (unsigned int)((char *)&off_8054E98 - (char *)&off_8054E94) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 804B4BD: could not find valid save-restore pair for ebp
// 8054E94: using guessed type void *off_8054E94;
// 8054E98: using guessed type void *off_8054E98;

//----- (0804B5E6) --------------------------------------------------------
int sub_804B5E6()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nWith no FILE, or when FILE is -, read standard input.\n");
  return fputs_unlocked(v1, v0);
}
// 8048F40: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804B611) --------------------------------------------------------
int __cdecl sub_804B611(char *s1)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // ebx
  char *v7; // eax
  char *v8; // [esp+1Ch] [ebp-4Ch]
  const char **i; // [esp+20h] [ebp-48h]
  const char *v10; // [esp+28h] [ebp-40h]
  const char *v11; // [esp+2Ch] [ebp-3Ch]
  const char *v12; // [esp+30h] [ebp-38h]
  const char *v13; // [esp+34h] [ebp-34h]
  const char *v14; // [esp+38h] [ebp-30h]
  const char *v15; // [esp+3Ch] [ebp-2Ch]
  const char *v16; // [esp+40h] [ebp-28h]
  const char *v17; // [esp+44h] [ebp-24h]
  const char *v18; // [esp+48h] [ebp-20h]
  const char *v19; // [esp+4Ch] [ebp-1Ch]
  const char *v20; // [esp+50h] [ebp-18h]
  const char *v21; // [esp+54h] [ebp-14h]
  int v22; // [esp+58h] [ebp-10h]
  int v23; // [esp+5Ch] [ebp-Ch]

  v10 = "[";
  v11 = "test invocation";
  v12 = "coreutils";
  v13 = "Multi-call invocation";
  v14 = "sha224sum";
  v15 = "sha2 utilities";
  v16 = "sha256sum";
  v17 = "sha2 utilities";
  v18 = "sha384sum";
  v19 = "sha2 utilities";
  v20 = "sha512sum";
  v21 = "sha2 utilities";
  v22 = 0;
  v23 = 0;
  v8 = s1;
  for ( i = &v10; *i && strcmp(s1, *i); i += 2 )
    ;
  if ( i[1] )
    v8 = (char *)i[1];
  v2 = gettext("\n%s online help: <%s>\n");
  printf(v2, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  v4 = setlocale(5, 0);
  if ( v4 && strncmp(v4, "en_", 3u) )
  {
    v3 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
    printf(v3, s1);
  }
  v1 = gettext("Full documentation at: <%s%s>\n");
  printf(v1, "http://www.gnu.org/software/coreutils/", s1);
  if ( v8 == s1 )
    v5 = " invocation";
  else
    v5 = &locale;
  v7 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  return printf(v7, v8, v5);
}

//----- (0804B80D) --------------------------------------------------------
void __cdecl __noreturn sub_804B80D(int status)
{
  int v1; // ebx
  char *v2; // eax
  int v3; // ebx
  char *v4; // eax
  FILE *v5; // ebx
  char *v6; // eax
  FILE *v7; // ebx
  char *v8; // eax
  FILE *v9; // ebx
  char *v10; // eax
  FILE *v11; // ebx
  char *v12; // eax

  if ( status )
  {
    v1 = dword_80597D6;
    v2 = gettext("Try '%s --help' for more information.\n");
    fprintf(stderr, v2, v1);
  }
  else
  {
    v3 = dword_80597D6;
    v4 = gettext("Usage: %s [OPTION]... [FILE]...\n");
    printf(v4, v3);
    v5 = stdout;
    v6 = gettext("Print checksum and block counts for each FILE.\n");
    fputs_unlocked(v6, v5);
    sub_804B5E6();
    v7 = stdout;
    v8 = gettext(
           "\n"
           "  -r              use BSD sum algorithm, use 1K blocks\n"
           "  -s, --sysv      use System V sum algorithm, use 512 bytes blocks\n");
    fputs_unlocked(v8, v7);
    v11 = stdout;
    v12 = gettext("      --help     display this help and exit\n");
    fputs_unlocked(v12, v11);
    v9 = stdout;
    v10 = gettext("      --version  output version information and exit\n");
    fputs_unlocked(v10, v9);
    sub_804B611("sum");
  }
  exit(status);
}
// 8048F40: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 80597D6: using guessed type int dword_80597D6;

//----- (0804BBE6) --------------------------------------------------------
int __usercall main@<eax>(signed int a1@<ebx>, int argc, char **argv)
{
  _BYTE *v3; // ebx
  int *v4; // eax
  int result; // eax
  unsigned __int8 v10; // [esp+22BBh] [ebp-11h]
  int (__cdecl *v11)(char *, int); // [esp+22BCh] [ebp-10h]
  int v12; // [esp+22C0h] [ebp-Ch]
  int v13; // [esp+22C4h] [ebp-8h]
  int savedregs; // [esp+22CCh] [ebp+0h]

  v11 = (int (__cdecl *)(char *, int))&loc_804B8FE;
  sub_804DA33(*argv);
  setlocale(6, &locale);
  bindtextdomain("coreutils", "/home/hwangdz/coreutils/coreutils-8.28/install_m32/share/locale");
  textdomain("coreutils");
  sub_80538AC((int)sub_804C2BE);
  setvbuf(stdout, 0, 1, 0);
  byte_80597CB = 0;
  while ( 1 )
  {
    v12 = getopt_long(argc, argv, "rs", &longopts, 0);
    if ( v12 == -1 )
      break;
    if ( v12 == -130 )
      sub_804B80D(0);
    if ( v12 <= -130 )
    {
      if ( v12 == -131 )
      {
        sub_8050C58(
          a1,
          stdout,
          (int)"sum",
          (int)"GNU coreutils",
          off_80591E8,
          "Kayvan Aghaiepour",
          "David MacKenzie",
          0);
        exit(0);
      }
LABEL_14:
      sub_804B80D(1);
    }
    if ( v12 == 114 )
    {
      v11 = (int (__cdecl *)(char *, int))&loc_804B8FE;
    }
    else
    {
      if ( v12 != 115 )
        goto LABEL_14;
      v11 = (int (__cdecl *)(char *, int))&loc_804BC4B;
    }
  }
  v13 = argc - optind;
  if ( argc - optind > 0 )
  {
    v10 = 1;
    while ( optind < argc )
    {
      a1 = v10;
      v10 = (unsigned __int8)(v10 & v11(argv[optind], v13)) != 0;
      ++optind;
    }
  }
  else
  {
    v10 = v11("-", v13);
  }
  if ( byte_80597CB
    && sub_8051BDC(0, byte_80597CB == 0, byte_80597CB < 0, 0, stdin, a1, (__int16 *)&savedregs, (FILE *)stdin) == -1 )
  {
    v3 = sub_804FC67(0, 1, 0, 0, -1, a1, 0, 3);
    v4 = __errno_location();
    error(1, *v4, "%s", v3);
  }
  _CF = 0;
  _OF = 0;
  _ZF = v10 == 0;
  _SF = (v10 & 0x80u) != 0;
  if ( !v10 )
    return 1;
  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}
// 8059280: using guessed type int optind;
// 80592A0: using guessed type int stdin;
// 80597CB: using guessed type char byte_80597CB;

//----- (0804C2BE) --------------------------------------------------------
void __usercall sub_804C2BE(signed int a1@<ebx>)
{
  JUMPOUT(sub_8052761(a1, stdout), 0, &loc_804BFFB);
  JUMPOUT(byte_80597D2, 1, &loc_804C307);
  JUMPOUT(&loc_804BF93);
}
// 80597D2: using guessed type char byte_80597D2;

//----- (0804C3F1) --------------------------------------------------------
int __cdecl sub_804C3F1(int a1, int a2, int a3, int a4, int a5, int a6)
{
  return posix_fadvise64(a1, a2, a3, a4, a5, a6);
}
// 8049070: using guessed type int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804C442) --------------------------------------------------------
int __usercall sub_804C442@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>, FILE *stream)
{
  unsigned int v7; // eax
  int result; // eax
  int v9; // [esp-4h] [ebp-30h]
  int v10; // [esp+6h] [ebp-26h]
  __int16 v11; // [esp+26h] [ebp-6h]
  __int16 *v12; // [esp+28h] [ebp-4h]

  v12 = (__int16 *)a5;
  __asm { pushfw }
  if ( sub_805288C() != 695 )
    sub_8052952();
  __asm { popfw }
  result = (int)v12;
  v12 = &v11;
  if ( stream )
  {
    v9 = fileno(stream);
    __asm { pushfw }
    v7 = sub_805322D();
    if ( v7 != -952 )
      sub_8053237(v7 < 0xFFFFFC48, v7 == -952, (signed int)(v7 + 952) < 0, __OFSUB__(v7, -952), a6);
    __asm { popfw }
    result = sub_804C3F1(v9, 0, 0, 0, 0, v10);
  }
  return result;
}
// 804C442: could not find valid save-restore pair for ebp
// 8052952: using guessed type int sub_8052952(void);

//----- (0804C542) --------------------------------------------------------
int __cdecl sub_804C542(int a1, long double a2)
{
  __int16 v3; // ax
  __int16 v4; // [esp+14h] [ebp-24h]
  __int16 v5; // [esp+16h] [ebp-22h]
  __int64 v6; // [esp+28h] [ebp-10h]

  dword_80591CC = (int (*)(void))&loc_804C7C3;
  if ( a1 != 1 )
  {
    dword_80591CC = (int (*)(void))&loc_804C7C3;
    if ( a2 < 1.8446744073709551615e19 )
    {
      dword_80591CC = (int (*)(void))&loc_804C5E1;
      if ( a2 < 9.223372036854775808e18 )
      {
        LOBYTE(v3) = v5;
        HIBYTE(v3) = 12;
        v4 = v3;
        v6 = (signed __int64)a2;
        dword_80591CC = (int (*)(void))&loc_804C5AC;
      }
    }
  }
  return dword_80591CC();
}
// 80591CC: using guessed type int (*dword_80591CC)(void);

//----- (0804C712) --------------------------------------------------------
#error "804C71B: positive sp value has been found (funcsize=5)"

//----- (0804C7DE) --------------------------------------------------------
char *__cdecl sub_804C7DE(int a1, size_t n, int a3, int a4)
{
  size_t v4; // eax
  char *v9; // ebx
  char *v10; // ebx
  unsigned int v12; // eax
  size_t v13; // [esp-4h] [ebp-6Ch]
  char *s; // [esp+14h] [ebp-54h]
  char *v15; // [esp+18h] [ebp-50h]
  void *src; // [esp+1Ch] [ebp-4Ch]
  unsigned __int8 v17; // [esp+23h] [ebp-45h]
  size_t v18; // [esp+24h] [ebp-44h]
  size_t v19; // [esp+28h] [ebp-40h]
  size_t v20; // [esp+2Ch] [ebp-3Ch]
  char dest[41]; // [esp+33h] [ebp-35h]
  unsigned int v22; // [esp+5Ch] [ebp-Ch]

  src = (void *)a1;
  v15 = (char *)a3;
  s = (char *)a4;
  v22 = __readgsdword(0x14u);
  v18 = -1;
  v20 = strlen((const char *)a4);
  v19 = n;
  memcpy(dest, (const void *)a1, n);
  v9 = (char *)(a1 + n);
  while ( 1 )
  {
    v4 = (unsigned __int8)*v15;
    v17 = *v15;
    _CF = 0;
    _OF = 0;
    _ZF = v17 == 0;
    _SF = (v17 & 0x80u) != 0;
    if ( v17 )
    {
      if ( v17 > 0x7Eu )
        v4 = v19;
      else
        v4 = v17;
      v18 = v4;
      _CF = __CFADD__(v15, 1);
      _OF = __OFADD__(1, v15);
      _ZF = v15 + 1 == 0;
      _SF = (signed int)(v15++ + 1) < 0;
    }
    v13 = v4;
    __asm { pushfw }
    if ( sub_805288C() != 695 )
      sub_8052952();
    __asm { popfw }
    if ( v19 < v18 )
      v18 = v19;
    v10 = &v9[-v18];
    v19 -= v18;
    memcpy(v10, &dest[v19], v18);
    if ( !v19 )
      break;
    v9 = &v10[-v20];
    v13 = (size_t)memcpy(v9, s, v20);
    __asm { pushfw }
    v12 = sub_805322D();
    if ( v12 != -952 )
      sub_8053237(v12 < 0xFFFFFC48, v12 == -952, (signed int)(v12 + 952) < 0, __OFSUB__(v12, -952), (signed int)v9);
    __asm { popfw }
  }
  return v10;
}
// 8052952: using guessed type int sub_8052952(void);
// 804C7DE: using guessed type char dest[41];

//----- (0804C9C5) --------------------------------------------------------
void *__cdecl sub_804C9C5(int a1, int a2, char *s, int a4, int a5, int a6, int a7, int a8)
{
  signed int v8; // eax
  int v9; // edx
  signed __int64 v10; // rax
  long double v11; // fst7
  signed int v12; // ebx
  int v13; // ecx
  unsigned __int64 v14; // rax
  signed __int64 v15; // rax
  __int64 v16; // rax
  int v17; // eax
  int v18; // edx
  int v19; // ebx
  unsigned __int64 v20; // rax
  __int64 v21; // rax
  signed int v22; // eax
  long double v23; // fst7
  size_t v24; // eax
  long double v25; // fst7
  int v30; // eax
  unsigned int v31; // edx
  signed int v32; // eax
  char v33; // al
  char v36; // al
  char v37; // al
  char v40; // al
  int v41; // eax
  char *v42; // eax
  char *v43; // eax
  char v44; // dl
  char *v45; // eax
  char *v46; // eax
  signed int v48; // [esp-Ah] [ebp-112h]
  unsigned int v49; // [esp-4h] [ebp-10Ch]
  __int64 v50; // [esp+0h] [ebp-108h]
  __int64 v51; // [esp+8h] [ebp-100h]
  int v52; // [esp+10h] [ebp-F8h]
  __int64 v53; // [esp+20h] [ebp-E8h]
  unsigned __int64 v54; // [esp+28h] [ebp-E0h]
  unsigned __int64 v55; // [esp+30h] [ebp-D8h]
  unsigned __int64 v56; // [esp+38h] [ebp-D0h]
  int v57; // [esp+40h] [ebp-C8h]
  int v58; // [esp+44h] [ebp-C4h]
  void *dest; // [esp+48h] [ebp-C0h]
  char *v60; // [esp+4Ch] [ebp-BCh]
  char *v61; // [esp+50h] [ebp-B8h]
  int v62; // [esp+54h] [ebp-B4h]
  void *src; // [esp+58h] [ebp-B0h]
  size_t v64; // [esp+5Ch] [ebp-ACh]
  int v65; // [esp+60h] [ebp-A8h]
  size_t n; // [esp+64h] [ebp-A4h]
  size_t v67; // [esp+68h] [ebp-A0h]
  int v68; // [esp+6Ch] [ebp-9Ch]
  unsigned int v69; // [esp+70h] [ebp-98h]
  int v70; // [esp+74h] [ebp-94h]
  int v71; // [esp+78h] [ebp-90h]
  struct lconv *v72; // [esp+7Ch] [ebp-8Ch]
  unsigned int v73; // [esp+80h] [ebp-88h]
  unsigned int v74; // [esp+84h] [ebp-84h]
  unsigned int v75; // [esp+88h] [ebp-80h]
  int v76; // [esp+8Ch] [ebp-7Ch]
  unsigned __int64 v77; // [esp+90h] [ebp-78h]
  __int64 i; // [esp+98h] [ebp-70h]
  unsigned int v79; // [esp+A0h] [ebp-68h]
  unsigned int v80; // [esp+A4h] [ebp-64h]
  unsigned __int64 v81; // [esp+A8h] [ebp-60h]
  unsigned __int64 v82; // [esp+B0h] [ebp-58h]
  unsigned __int64 v83; // [esp+B8h] [ebp-50h]
  long double v84; // [esp+C0h] [ebp-48h]
  long double v85; // [esp+D0h] [ebp-38h]
  long double v86[3]; // [esp+E0h] [ebp-28h]

  v56 = __PAIR__(a2, a1);
  v55 = __PAIR__(a6, a5);
  v54 = __PAIR__(a8, a7);
  v68 = a4 & 3;
  if ( a4 & 0x20 )
    v8 = 1024;
  else
    v8 = 1000;
  v69 = v8;
  v58 = -1;
  v70 = 8;
  src = &unk_80545A1;
  v64 = 1;
  v71 = (int)&unk_80545A3;
  v65 = (int)&unk_80545A3;
  v72 = localeconv();
  v73 = strlen(v72->decimal_point);
  if ( v73 && v73 <= 0x10 )
  {
    src = v72->decimal_point;
    v64 = v73;
  }
  v71 = (int)v72->grouping;
  if ( strlen(v72->thousands_sep) <= 0x10 )
    v65 = (int)v72->thousands_sep;
  v60 = s + 647;
  dest = s + 647;
  if ( v54 > v55 )
  {
    if ( v55 && !(v9 | sub_80535D3(v54, v55)) )
    {
      v16 = sub_80533D9(0, 1, 0, 0, v54, SHIDWORD(v55), v54, v55, HIDWORD(v55));
      v81 = v16;
      v17 = sub_80535D3(v56, v16);
      v19 = 10 * v18;
      v20 = 10LL * (unsigned int)v17;
      LODWORD(v82) = v20;
      HIDWORD(v20) += v19;
      HIDWORD(v82) = HIDWORD(v20);
      v12 = HIDWORD(v81);
      LODWORD(v21) = sub_80535D3(v20, v81);
      v83 = 2 * v21;
      v77 = sub_80533D9(
              __CFADD__((_DWORD)v21, (_DWORD)v21),
              2 * (_DWORD)v21 == 0,
              2 * (signed int)v21 < 0,
              __OFADD__((_DWORD)v21, (_DWORD)v21),
              v56,
              SHIDWORD(v81),
              v56,
              v81,
              HIDWORD(v81));
      v57 = sub_80533D9(_CF, _ZF, _SF, _OF, v82, SHIDWORD(v81), v82, v81, HIDWORD(v81));
      if ( HIDWORD(v83) > HIDWORD(v81) || HIDWORD(v83) >= HIDWORD(v81) && (unsigned int)v83 >= (unsigned int)v81 )
      {
        if ( v81 >= v83 )
          v22 = 2;
        else
          v22 = 3;
      }
      else
      {
        v22 = v83 != 0;
      }
      v62 = v22;
LABEL_45:
      if ( a4 & 0x10 )
      {
        v58 = 0;
        _CF = HIDWORD(v77) > 0;
        _OF = __OFSUB__(0, HIDWORD(v77));
        _ZF = HIDWORD(v77) == 0;
        _SF = -HIDWORD(v77) < 0;
        if ( HIDWORD(v77) > 0
          || (_CF = v69 < (unsigned int)v77,
              _OF = __OFSUB__(v69, (_DWORD)v77),
              _ZF = v69 == (_DWORD)v77,
              _SF = (signed int)(v69 - v77) < 0,
              v69 <= (unsigned int)v77) )
        {
          do
          {
            __asm { pushfw }
            v12 = 0;
            __asm { popfw }
            v30 = sub_80535D3(v77, v69);
            v74 = 10 * v30 + v57;
            v31 = 2 * (v74 % v69);
            v75 = v31 + (v62 >> 1);
            v77 = sub_80533D9(
                    __CFADD__(v31, v62 >> 1),
                    v31 + (v62 >> 1) == 0,
                    (signed int)(v31 + (v62 >> 1)) < 0,
                    __OFADD__(v31, v62 >> 1),
                    v77,
                    0,
                    v77,
                    v69,
                    0);
            v57 = v74 / v69;
            if ( v75 >= v69 )
            {
              if ( v62 + v75 <= v69 )
                v32 = 2;
              else
                v32 = 3;
            }
            else
            {
              v32 = v62 + v75 != 0;
            }
            v62 = v32;
            ++v58;
            if ( v69 > v77 )
              break;
            _CF = v58 < (unsigned int)v70;
            _OF = __OFSUB__(v58, v70);
            _ZF = v58 == v70;
            _SF = v58 - v70 < 0;
          }
          while ( v58 < v70 );
          if ( v77 <= 9 )
          {
            if ( v68 == 1 )
            {
              v33 = (v57 & 1) + v62 > 2;
            }
            else
            {
              _ZF = v68 == 0;
              _SF = v68 < 0;
              if ( v68 || (_ZF = v62 == 0, _SF = v62 < 0, v62 <= 0) )
              {
                __asm { pushfw }
                v36 = 0;
                __asm { popfw }
              }
              else
              {
                v36 = 1;
              }
              v33 = v36 & 1;
            }
            if ( v33 )
            {
              ++v57;
              v62 = 0;
              if ( v57 == 10 )
              {
                ++v77;
                v57 = 0;
              }
            }
            if ( v77 <= 9 && (v57 || !(a4 & 8)) )
            {
              dest = (char *)dest - 1;
              *(_BYTE *)dest = v57 + 48;
              dest = (char *)dest - v64;
              memcpy(dest, src, v64);
              v62 = 0;
              v57 = 0;
            }
          }
        }
      }
      if ( v68 == 1 )
      {
        v37 = ((v77 & 1) + v62 != 0) + v57 > 5;
      }
      else
      {
        _ZF = v68 == 0;
        _SF = v68 < 0;
        if ( v68 || (_ZF = v57 + v62 == 0, _SF = v57 + v62 < 0, v57 + v62 <= 0) )
        {
          __asm { pushfw }
          v40 = 0;
          __asm { popfw }
        }
        else
        {
          v40 = 1;
        }
        v37 = v40 & 1;
      }
      if ( v37 )
      {
        ++v77;
        if ( a4 & 0x10 )
        {
          if ( v77 == v69 && v58 < v70 )
          {
            ++v58;
            if ( !(a4 & 8) )
            {
              dest = (char *)dest - 1;
              *(_BYTE *)dest = 48;
              dest = (char *)dest - v64;
              memcpy(dest, src, v64);
            }
            v77 = 1LL;
          }
        }
      }
      v61 = (char *)dest;
      do
      {
        v41 = sub_80535D3(v77, 10LL);
        v76 = v41;
        dest = (char *)dest - 1;
        *(_BYTE *)dest = v41 + 48;
        v77 = sub_80533D9(__CFADD__(v41, 48), v41 == -48, v41 + 48 < 0, __OFADD__(48, v41), v77, v12, v77, 0xAu, 0);
      }
      while ( v77 );
      goto LABEL_87;
    }
  }
  else if ( !(v9 | sub_80535D3(v55, v54)) )
  {
    v10 = sub_80533D9(0, 1, 0, 0, v55, SHIDWORD(v54), v55, v54, HIDWORD(v54));
    v49 = v10;
    __asm { pushfw }
    v48 = HIDWORD(v54);
    if ( SHIDWORD(v54) >= 10 && (BYTE4(v54) - 1) * BYTE4(v54) & 1 )
      abort();
    v12 = v48;
    __asm { popfw }
    v79 = v49;
    v80 = HIDWORD(v10);
    v13 = v49 * HIDWORD(v56) + v56 * HIDWORD(v10);
    v14 = (unsigned int)v56 * (unsigned __int64)v49;
    _CF = __CFADD__(HIDWORD(v14), v13);
    _OF = __OFADD__(HIDWORD(v14), v13);
    _ZF = HIDWORD(v14) + v13 == 0;
    _SF = HIDWORD(v14) + v13 < 0;
    HIDWORD(v14) += v13;
    v77 = v14;
    v15 = sub_80533D9(_CF, _ZF, _SF, _OF, v14, v48, v14, v49, v80);
    if ( v56 == v15 )
    {
      v57 = 0;
      v62 = 0;
      goto LABEL_45;
    }
  }
  v85 = (long double)v54;
  v23 = (long double)v56 * ((long double)v55 / v85);
  v86[0] = v23;
  if ( a4 & 0x10 )
  {
    v84 = 1.0;
    v58 = 0;
    do
    {
      v84 = (long double)v69 * v84;
      ++v58;
      v53 = v69;
    }
    while ( v86[0] >= v84 && v58 < v70 );
    v86[0] = v86[0] / v84;
    v11 = v86[0];
    HIDWORD(v50) = LODWORD(v86[0]);
    v51 = *(_QWORD *)((char *)v86 + 4);
    sub_804C542(v68, *(_TBYTE *)((char *)&v50 + 4));
    *(long double *)&v51 = v11;
    sprintf(s, "%.1Lf", v51, v52);
    v24 = strlen(s);
    n = v24;
    v67 = v64 + 1;
    if ( ((a4 & 0x20) == 0) + v64 + 1 + 1 < v24 || a4 & 8 && s[n - 1] == 48 )
    {
      v25 = v86[0] * 10.0;
      *(long double *)((char *)&v50 + 4) = v86[0] * 10.0;
      sub_804C542(v68, *(_TBYTE *)((char *)&v50 + 4));
      *(long double *)&v51 = v25 / 10.0;
      sprintf(s, "%.0Lf", v51, v52);
      n = strlen(s);
      v67 = 0;
    }
  }
  else
  {
    HIDWORD(v50) = LODWORD(v86[0]);
    v51 = *(_QWORD *)((char *)v86 + 4);
    sub_804C542(v68, *(_TBYTE *)((char *)&v50 + 4));
    *(long double *)&v51 = v23;
    sprintf(s, "%.0Lf", v51, v52);
    n = strlen(s);
    v67 = 0;
  }
  dest = &v60[-n];
  memmove(&v60[-n], s, n);
  v61 = (char *)dest + n - v67;
LABEL_87:
  if ( a4 & 4 )
    dest = sub_804C7DE((int)dest, v61 - (_BYTE *)dest, v71, v65);
  if ( a4 & 0x80 )
  {
    if ( v58 < 0 )
    {
      v58 = 0;
      for ( i = 1LL;
            HIDWORD(i) < HIDWORD(v54) || HIDWORD(i) <= HIDWORD(v54) && (unsigned int)i < (unsigned int)v54;
            i *= v69 )
      {
        if ( ++v58 == v70 )
          break;
      }
    }
    if ( v58 | a4 & 0x100 && a4 & 0x40 )
    {
      v42 = v60++;
      *v42 = 32;
    }
    if ( v58 )
    {
      v43 = v60++;
      if ( a4 & 0x20 || v58 != 1 )
        v44 = *(_BYTE *)(v58 + 134563224);
      else
        v44 = 107;
      *v43 = v44;
    }
    if ( a4 & 0x100 )
    {
      if ( a4 & 0x20 && v58 )
      {
        v45 = v60++;
        *v45 = 105;
      }
      v46 = v60++;
      *v46 = 66;
    }
  }
  *v60 = 0;
  return dest;
}

//----- (0804D712) --------------------------------------------------------
signed __int64 __usercall sub_804D712@<edx:eax>(signed int a1@<ebx>)
{
  char *v1; // eax
  unsigned int v7; // eax

  v1 = getenv("POSIXLY_CORRECT");
  _CF = 0;
  _OF = 0;
  _ZF = v1 == 0;
  _SF = (signed int)v1 < 0;
  if ( v1 )
    return 512LL;
  __asm { pushfw }
  v7 = sub_804B04D(0, 1, 0, 0, 0, a1);
  if ( v7 != 549 )
    sub_804B0C4(v7 < 0x225, v7 == 549, (signed int)(v7 - 549) < 0, __OFSUB__(v7, 549), v7, a1);
  __asm { popfw }
  return 1024LL;
}

//----- (0804D7A1) --------------------------------------------------------
int __usercall sub_804D7A1@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>, __int16 *a7@<ebp>, char *a8, _DWORD *a9, _DWORD *a10)
{
  int *v10; // ebp
  int v15; // eax
  int result; // eax
  unsigned int v21; // eax
  unsigned int v22; // eax
  unsigned __int8 v27; // al
  __int16 v32; // [esp-6h] [ebp-42h]
  int v33; // [esp-4h] [ebp-40h]
  char name[6]; // [esp+0h] [ebp-3Ch]
  int v35; // [esp+20h] [ebp-1Ch]
  int v36; // [esp+24h] [ebp-18h]
  int v37; // [esp+28h] [ebp-14h]
  int v38; // [esp+2Ch] [ebp-10h]
  __int16 v39; // [esp+32h] [ebp-Ah]
  __int16 *v40; // [esp+38h] [ebp-4h]

  v40 = (__int16 *)a5;
  __asm { pushfw }
  if ( a6 >= 10 )
  {
    a7 = &v39;
    if ( ((_BYTE)a6 - 1) * (_BYTE)a6 & 1 )
      abort();
  }
  __asm { popfw }
  v40 = a7;
  v10 = (int *)&v40;
  v36 = 0;
  if ( a8 || (a8 = getenv("BLOCK_SIZE")) != 0 || (a8 = getenv("BLOCKSIZE")) != 0 )
  {
    if ( *a8 == 39 )
    {
      v36 |= 4u;
      ++a8;
    }
    v37 = sub_80520CC(a8, (int)off_80545C4, (int)dword_80545D0, 4u);
    if ( v37 < 0 )
    {
      v38 = sub_80516FB(a6, a8, (int)&v35, 0, (int)a9, "eEgGkKmMpPtTyYzZ0");
      _CF = 0;
      _OF = 0;
      _ZF = v38 == 0;
      _SF = v38 < 0;
      if ( v38 )
      {
        *a10 = 0;
        return v38;
      }
      v33 = 0;
      __asm { pushfw }
      v10 = (int *)&v32;
      v21 = sub_804B04D(0, v38 == 0, v38 < 0, 0, 0, a6);
      if ( v21 != 549 )
        sub_804B0C4(v21 < 0x225, v21 == 549, (signed int)(v21 - 549) < 0, __OFSUB__(v21, 549), v21, a6);
      __asm { popfw }
      while ( 1 )
      {
        _CF = **(_BYTE **)&name[2] < 0x2Fu;
        _OF = __OFSUB__(**(_BYTE **)&name[2], 47);
        _ZF = **(_BYTE **)&name[2] == 47;
        _SF = (char)(**(_BYTE **)&name[2] - 47) < 0;
        if ( **(_BYTE **)&name[2] > 47 )
        {
          v33 = (unsigned __int8)**(_BYTE **)&name[2];
          __asm { pushfw }
          v10 = (int *)&v32;
          if ( sub_805288C() != 695 )
            sub_8052952();
          __asm { popfw }
          _CF = **(_BYTE **)&name[2] < 0x39u;
          _OF = __OFSUB__(**(_BYTE **)&name[2], 57);
          _ZF = **(_BYTE **)&name[2] == 57;
          _SF = (char)(**(_BYTE **)&name[2] - 57) < 0;
          if ( **(_BYTE **)&name[2] <= 57 )
            break;
        }
        v22 = *((_DWORD *)&v32 - 6);
        _CF = *(_DWORD *)&name[2] < v22;
        _OF = __OFSUB__(*(_DWORD *)&name[2], v22);
        _ZF = *(_DWORD *)&name[2] == v22;
        _SF = (signed int)(*(_DWORD *)&name[2] - v22) < 0;
        if ( *(_DWORD *)&name[2] == v22 )
        {
          *((_DWORD *)&v32 - 5) |= 0x80u;
          if ( *(_BYTE *)(*((_DWORD *)&v32 - 6) - 1) == 66 )
            *((_DWORD *)&v32 - 5) |= 0x100u;
          if ( *(_BYTE *)(*((_DWORD *)&v32 - 6) - 1) != 66
            || (v27 = *(_BYTE *)(*((_DWORD *)&v32 - 6) - 2),
                _CF = v27 < 0x69u,
                _OF = __OFSUB__(v27, 105),
                _ZF = v27 == 105,
                _SF = (char)(v27 - 105) < 0,
                v27 == 105) )
          {
            _CF = 0;
            _OF = 0;
            _ZF = (*((_DWORD *)&v32 - 5) | 0x20) == 0;
            _SF = (*((_DWORD *)&v32 - 5) | 0x20) < 0;
            *((_DWORD *)&v32 - 5) |= 0x20u;
          }
          break;
        }
        v33 = *((_DWORD *)&v32 - 6);
        __asm { pushfw }
        v10 = (int *)&v32;
        if ( sub_8052896(
               *(_DWORD *)&name[2] < v22,
               *(_DWORD *)&name[2] == v22,
               (signed int)(*(_DWORD *)&name[2] - v22) < 0,
               __OFSUB__(*(_DWORD *)&name[2], v22),
               v22,
               a6) != 449 )
          sub_8052951();
        __asm { popfw }
        ++*(_DWORD *)&name[2];
      }
    }
    else
    {
      v15 = dword_80545D0[v37];
      _CF = 0;
      _OF = 0;
      _ZF = (v15 | v36) == 0;
      _SF = (v15 | v36) < 0;
      v36 |= v15;
      *a9 = 1;
      a9[1] = 0;
    }
  }
  else
  {
    *(_QWORD *)a9 = sub_804D712(a6);
  }
  *(_DWORD *)v10[4] = *(v10 - 5);
  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}
// 804D7A1: could not find valid save-restore pair for ebp
// 8052951: using guessed type int sub_8052951(void);
// 8052952: using guessed type int sub_8052952(void);
// 80545C4: using guessed type char *off_80545C4[2];

//----- (0804DA33) --------------------------------------------------------
char *__cdecl sub_804DA33(char *s)
{
  char *v1; // eax
  char *result; // eax
  char *v3; // [esp+18h] [ebp-10h]
  char *s1; // [esp+1Ch] [ebp-Ch]

  if ( !s )
  {
    fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
    abort();
  }
  v3 = strrchr(s, 47);
  if ( v3 )
    v1 = v3 + 1;
  else
    v1 = s;
  s1 = v1;
  if ( v1 - s > 6 && !strncmp(v1 - 7, "/.libs/", 7u) )
  {
    s = s1;
    if ( !strncmp(s1, "lt-", 3u) )
    {
      s = s1 + 3;
      program_invocation_short_name = (int)(s1 + 3);
    }
  }
  dword_80597D6 = (int)s;
  result = s;
  program_invocation_name = (int)s;
  return result;
}
// 8059260: using guessed type int program_invocation_short_name;
// 8059270: using guessed type int program_invocation_name;
// 80597D6: using guessed type int dword_80597D6;

//----- (0804DBCC) --------------------------------------------------------
int __usercall sub_804DBCC@<eax>(signed int a1@<ebx>, int *a2, unsigned __int8 a3, char a4)
{
  int *v8; // eax
  int v9; // ST1C_4

  _CF = 0;
  _OF = 0;
  _ZF = a2 == 0;
  _SF = (signed int)a2 < 0;
  if ( a2 )
  {
    v8 = a2;
  }
  else
  {
    __asm { pushfw }
    if ( a1 >= 10 && ((_BYTE)a1 - 1) * (_BYTE)a1 & 1 )
      abort();
    __asm { popfw }
    v8 = &dword_80597E2;
  }
  v9 = ((unsigned int)v8[(a3 >> 5) + 2] >> (a3 & 0x1F)) & 1;
  v8[(a3 >> 5) + 2] ^= (v9 ^ a4 & 1) << (a3 & 0x1F);
  return v9;
}
// 80597E2: using guessed type int dword_80597E2;

//----- (0804DD08) --------------------------------------------------------
int *__usercall sub_804DD08@<eax>(signed int a1@<ebx>, int *a2, int a3, int a4)
{
  int *result; // eax

  _CF = 0;
  _OF = 0;
  _ZF = a2 == 0;
  _SF = (signed int)a2 < 0;
  if ( !a2 )
  {
    __asm { pushfw }
    if ( a1 >= 10 && ((_BYTE)a1 - 1) * (_BYTE)a1 & 1 )
      abort();
    __asm { popfw }
    a2 = &dword_80597E2;
  }
  *a2 = 10;
  if ( !a3 || !a4 )
    abort();
  a2[10] = a3;
  result = a2;
  a2[11] = a4;
  return result;
}
// 80597E2: using guessed type int dword_80597E2;

//----- (0804DDAE) --------------------------------------------------------
_DWORD *__userpurge sub_804DDAE@<eax>(_DWORD *a1, int a2)
{
  int v3; // [esp+0h] [ebp-38h]
  int v4; // [esp+4h] [ebp-34h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]

  memset(&v3, 0, 0x30u);
  if ( a2 == 10 )
    abort();
  *a1 = a2;
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = v6;
  a1[4] = v7;
  a1[5] = v8;
  a1[6] = v9;
  a1[7] = v10;
  a1[8] = v11;
  a1[9] = v12;
  a1[10] = v13;
  a1[11] = v14;
  return a1;
}

//----- (0804DE31) --------------------------------------------------------
char *__usercall sub_804DE31@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>, int *a7@<ebp>, const char *msgid, int a9)
{
  char *result; // eax
  signed int v10; // ebx
  unsigned __int8 *v11; // [esp+1Ch] [ebp-10h]
  int v12; // [esp+22h] [ebp-Ah]
  int *v13; // [esp+28h] [ebp-4h]

  v13 = (int *)a5;
  __asm { pushfw }
  v12 = a6;
  if ( a6 >= 10 )
  {
    a7 = &v12;
    if ( ((_BYTE)a6 - 1) * (_BYTE)a6 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( v12 >= 10 )
  {
    a7 = &v12;
    if ( ((_BYTE)v12 - 1) * (_BYTE)v12 & 1 )
      abort();
  }
  v10 = v12;
  __asm { popfw }
  v13 = a7;
  result = gettext(msgid);
  if ( result == msgid )
  {
    v11 = (unsigned __int8 *)sub_8052F4C(v10);
    if ( sub_80526D7(v11, "UTF-8") )
    {
      if ( sub_80526D7(v11, "GB18030") )
      {
        if ( a9 == 9 )
          result = (char *)&unk_805477D;
        else
          result = (char *)&unk_805477F;
      }
      else if ( *msgid == 96 )
      {
        result = (char *)&unk_8054776;
      }
      else
      {
        result = (char *)&unk_805477A;
      }
    }
    else if ( *msgid == 96 )
    {
      result = (char *)&unk_8054766;
    }
    else
    {
      result = (char *)&unk_805476A;
    }
  }
  return result;
}
// 804DE31: could not find valid save-restore pair for ebx
// 804DE31: could not find valid save-restore pair for ebp

//----- (0804DFC9) --------------------------------------------------------
void __usercall sub_804DFC9(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>, int a7, int a8, int a9, int a10, unsigned int a11)
{
  bool v11; // ST53_1
  int v12; // [esp+80h] [ebp-Ch]
  int v13; // [esp+88h] [ebp-4h]

  v13 = a5;
  __asm { pushfw }
  *(int *)((char *)&v12 + 2) = a6;
  if ( a6 >= 10 && ((_BYTE)a6 - 1) * (_BYTE)a6 & 1 )
    abort();
  __asm { popfw }
  v12 = *(int *)((char *)&v12 + 2);
  v11 = __ctype_get_mb_cur_max() == 1;
  if ( a11 <= 0xA )
    JUMPOUT(__CS__, off_8054784[a11]);
  abort();
}

//----- (0804ED51) --------------------------------------------------------
void *__cdecl sub_804ED51(int a1, int a2, _DWORD *a3, int *a4)
{
  int *v4; // eax
  int v5; // eax
  unsigned int v7; // ST20_4
  unsigned int v8; // ST1C_4
  char v9; // cf
  char v10; // zf
  char v11; // sf
  char v12; // of
  unsigned int *v13; // ST3C_4
  unsigned int v14; // ST20_4
  unsigned int v15; // ST1C_4
  int v16; // [esp+40h] [ebp-18h]
  int v17; // [esp+48h] [ebp-10h]
  void *ptr; // [esp+4Ch] [ebp-Ch]

  if ( a4 )
    v4 = a4;
  else
    v4 = &dword_80597E2;
  v13 = (unsigned int *)v4;
  v16 = *__errno_location();
  v14 = v13[11];
  v15 = v13[10];
  sub_804DFC9(
    0,
    (v13[1] | (a3 == 0)) == 0,
    ((v13[1] | (a3 == 0)) & 0x80000000) != 0,
    0,
    a1,
    (signed int)(v13 + 2),
    0,
    0,
    a1,
    a2,
    *v13);
  v17 = v5 + 1;
  ptr = sub_8050EE0(__CFADD__(v5, 1), v5 == -1, v5 + 1 < 0, __OFADD__(1, v5), v5 + 1, (signed int)(v13 + 2), v5 + 1);
  v7 = v13[11];
  v8 = v13[10];
  sub_804DFC9(v9, v10, v11, v12, (int)ptr, (signed int)(v13 + 2), (int)ptr, v17, a1, a2, *v13);
  *__errno_location() = v16;
  if ( a3 )
    *a3 = v17 - 1;
  return ptr;
}
// 80597E2: using guessed type int dword_80597E2;

//----- (0804F154) --------------------------------------------------------
void sub_804F154()
{
  JUMPOUT(&loc_804EF22);
}

//----- (0804F24B) --------------------------------------------------------
_BYTE *__usercall sub_804F24B@<eax>(signed int a1@<ebx>, signed int a2, int a3, int a4, unsigned int *a5)
{
  int *v9; // eax
  int *v10; // eax
  unsigned int v11; // eax
  void *v16; // edx
  unsigned int v17; // ST50_4
  unsigned int v18; // ST2C_4
  unsigned int v19; // ST28_4
  unsigned int v20; // eax
  bool v21; // cf
  bool v22; // zf
  bool v23; // sf
  char v24; // of
  signed int v25; // ebx
  unsigned int v26; // ST2C_4
  unsigned int v27; // ST28_4
  bool v29; // [esp+37h] [ebp-21h]
  int *v30; // [esp+38h] [ebp-20h]
  _BYTE *ptr; // [esp+3Ch] [ebp-1Ch]
  int v32; // [esp+40h] [ebp-18h]
  int v33; // [esp+44h] [ebp-14h]

  v32 = *__errno_location();
  v30 = off_805920C;
  if ( a2 < 0 )
    abort();
  if ( dword_8059200 <= a2 )
  {
    v29 = off_805920C == &dword_8059204;
    if ( (unsigned int)a2 > 0xFFFFFFE )
      sub_805124E(a1);
    _CF = 0;
    _OF = 0;
    _ZF = off_805920C != &dword_8059204;
    _SF = v29 < 0;
    if ( v29 )
    {
      __asm { pushfw }
      v9 = 0;
      __asm { popfw }
    }
    else
    {
      v9 = off_805920C;
    }
    v10 = (int *)sub_8051006(a1, v9, 8 * (a2 + 1));
    v30 = v10;
    off_805920C = v10;
    _CF = 0;
    _OF = 0;
    _ZF = v29 == 0;
    _SF = v29 < 0;
    if ( v29 )
    {
      __asm { pushfw }
      if ( a1 >= 10 && ((_BYTE)a1 - 1) * (_BYTE)a1 & 1 )
        abort();
      __asm { popfw }
      v16 = off_8059208;
      *v10 = dword_8059204;
      v10[1] = (int)v16;
    }
    __asm { pushfw }
    v11 = sub_805322D();
    if ( v11 != -952 )
      sub_8053237(v11 < 0xFFFFFC48, v11 == -952, (signed int)(v11 + 952) < 0, __OFSUB__(v11, -952), a1);
    __asm { popfw }
    memset(&v30[2 * dword_8059200], 0, 8 * (a2 + 1 - dword_8059200));
    dword_8059200 = a2 + 1;
  }
  v17 = v30[2 * a2];
  ptr = (_BYTE *)v30[2 * a2 + 1];
  v18 = a5[11];
  v19 = a5[10];
  sub_804DFC9(
    0,
    (a5[1] | 1) == 0,
    ((a5[1] | 1) & 0x80000000) != 0,
    0,
    (int)ptr,
    (signed int)(a5 + 2),
    (int)ptr,
    v17,
    a3,
    a4,
    *a5);
  if ( v17 <= v20 )
  {
    v33 = v20 + 1;
    v30[2 * a2] = v20 + 1;
    v21 = ptr < (_BYTE *)&unk_8059822;
    v24 = __OFSUB__(ptr, &unk_8059822);
    v22 = ptr == (_BYTE *)&unk_8059822;
    v23 = ptr - (_BYTE *)&unk_8059822 < 0;
    if ( ptr != (_BYTE *)&unk_8059822 )
      free(ptr);
    v25 = (signed int)&v30[2 * a2];
    ptr = sub_8050EE0(v21, v22, v23, v24, v33, v25, v33);
    *(_DWORD *)(v25 + 4) = ptr;
    v26 = a5[11];
    v27 = a5[10];
    sub_804DFC9(_CF, _ZF, _SF, _OF, (int)ptr, (signed int)(a5 + 2), (int)ptr, v33, a3, a4, *a5);
  }
  *__errno_location() = v32;
  return ptr;
}
// 8059200: using guessed type int dword_8059200;
// 8059204: using guessed type int dword_8059204;
// 8059208: using guessed type void *off_8059208;
// 805920C: using guessed type int *off_805920C;

//----- (0804F51A) --------------------------------------------------------
_BYTE *__usercall sub_804F51A@<eax>(signed int a1@<ebx>, signed int a2, int a3)
{
  return sub_804F24B(a1, a2, a3, -1, (unsigned int *)&dword_80597E2);
}
// 80597E2: using guessed type int dword_80597E2;

//----- (0804F544) --------------------------------------------------------
_BYTE *__usercall sub_804F544@<eax>(signed int a1@<ebx>, signed int a2, int a3, int a4)
{
  _BYTE *v9; // [esp-4h] [ebp-1Ch]

  v9 = sub_804F24B(a1, a2, a3, a4, (unsigned int *)&dword_80597E2);
  __asm { pushfw }
  if ( a1 >= 10 && ((_BYTE)a1 - 1) * (_BYTE)a1 & 1 )
    abort();
  __asm { popfw }
  return v9;
}
// 80597E2: using guessed type int dword_80597E2;

//----- (0804F5F0) --------------------------------------------------------
_BYTE *__usercall sub_804F5F0@<eax>(signed int a1@<ebx>, int a2)
{
  return sub_804F51A(a1, 0, a2);
}

//----- (0804F64E) --------------------------------------------------------
_BYTE *__usercall sub_804F64E@<eax>(signed int a1@<ebx>, signed int a2, int a3, int a4)
{
  _DWORD *v9; // [esp+0h] [ebp-48h]
  unsigned int v10[14]; // [esp+10h] [ebp-38h]

  v9 = sub_804DDAE(v10, a3);
  __asm { pushfw }
  if ( sub_804A0C9() != 987 )
    sub_804A0D3();
  __asm { popfw }
  return sub_804F24B(a1, a2, a4, -1, v10);
}
// 804A0D3: using guessed type int sub_804A0D3(void);

//----- (0804F6F7) --------------------------------------------------------
_BYTE *__usercall sub_804F6F7@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>, int *a7@<ebp>, signed int a8, int a9, int a10, int a11)
{
  int v11; // eax
  signed int v16; // ebx
  int v18; // [esp+10h] [ebp-3Ch]
  int v19; // [esp+3Eh] [ebp-Eh]
  int v20; // [esp+42h] [ebp-Ah]
  int *v21; // [esp+48h] [ebp-4h]

  v21 = (int *)a5;
  __asm { pushfw }
  v20 = a6;
  if ( a6 >= 10 )
  {
    a7 = &v20;
    if ( ((_BYTE)a6 - 1) * (_BYTE)a6 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( v20 >= 10 )
  {
    a7 = &v20;
    v11 = ((_BYTE)v20 - 1) * (_BYTE)v20 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = v11 == 0;
    _SF = v11 < 0;
    if ( ((_BYTE)v20 - 1) * (_BYTE)v20 & 1 )
    {
      v19 = ((_BYTE)v20 - 1) * (_BYTE)v20 & 1;
      __asm { pushfw }
      if ( sub_804A0C9() == 987 )
      {
        __asm { popfw }
        abort();
      }
      sub_804A0D3();
    }
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( v20 >= 10 )
  {
    a7 = &v20;
    if ( ((_BYTE)v20 - 1) * (_BYTE)v20 & 1 )
      abort();
  }
  v16 = v20;
  __asm { popfw }
  v21 = a7;
  sub_804DDAE(&v18, a9);
  return sub_804F24B(v16, a8, a10, a11, (unsigned int *)&v18);
}
// 804F6F7: could not find valid save-restore pair for ebx
// 804F6F7: could not find valid save-restore pair for ebp
// 804A0D3: using guessed type int sub_804A0D3(void);

//----- (0804F905) --------------------------------------------------------
_BYTE *__usercall sub_804F905@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>, signed int *a7@<ebp>, int a8, int a9, unsigned __int8 a10)
{
  unsigned int v10; // eax
  __int16 v12; // [esp-6h] [ebp-62h]
  int v13; // [esp-4h] [ebp-60h]
  char v14[6]; // [esp+0h] [ebp-5Ch]
  int v15; // [esp+6h] [ebp-56h]
  unsigned __int8 v16; // [esp+1Ch] [ebp-40h]
  int v17; // [esp+20h] [ebp-3Ch]
  int v18; // [esp+24h] [ebp-38h]
  int v19; // [esp+28h] [ebp-34h]
  int v20; // [esp+2Ch] [ebp-30h]
  int v21; // [esp+30h] [ebp-2Ch]
  int v22; // [esp+34h] [ebp-28h]
  int v23; // [esp+38h] [ebp-24h]
  int v24; // [esp+3Ch] [ebp-20h]
  int v25; // [esp+40h] [ebp-1Ch]
  int v26; // [esp+44h] [ebp-18h]
  int v27; // [esp+48h] [ebp-14h]
  int v28; // [esp+4Ch] [ebp-10h]
  signed int v29; // [esp+52h] [ebp-Ah]
  signed int *v30; // [esp+58h] [ebp-4h]

  v30 = (signed int *)a5;
  __asm { pushfw }
  if ( a6 >= 10 )
  {
    a7 = &v29;
    if ( ((_BYTE)a6 - 1) * (_BYTE)a6 & 1 )
      abort();
  }
  __asm { popfw }
  v30 = a7;
  v16 = a10;
  v17 = dword_80597E2;
  v18 = dword_80597E6;
  v19 = dword_80597EA;
  v20 = dword_80597EE;
  v21 = dword_80597F2;
  v22 = dword_80597F6;
  v23 = dword_80597FA;
  v24 = dword_80597FE;
  v25 = dword_8059802;
  v26 = dword_8059806;
  v27 = dword_805980A;
  v28 = dword_805980E;
  v13 = sub_804DBCC(v29, &v17, a10, 1);
  __asm { pushfw }
  v10 = sub_805322D();
  if ( v10 != -952 )
    sub_8053237(v10 < 0xFFFFFC48, v10 == -952, (signed int)(v10 + 952) < 0, __OFSUB__(v10, -952), a6);
  __asm { popfw }
  return sub_804F24B(a6, 0, *(int *)&v14[2], v15, (unsigned int *)&v12 - 14);
}
// 804F905: could not find valid save-restore pair for ebp
// 80597E2: using guessed type int dword_80597E2;
// 80597E6: using guessed type int dword_80597E6;
// 80597EA: using guessed type int dword_80597EA;
// 80597EE: using guessed type int dword_80597EE;
// 80597F2: using guessed type int dword_80597F2;
// 80597F6: using guessed type int dword_80597F6;
// 80597FA: using guessed type int dword_80597FA;
// 80597FE: using guessed type int dword_80597FE;
// 8059802: using guessed type int dword_8059802;
// 8059806: using guessed type int dword_8059806;
// 805980A: using guessed type int dword_805980A;
// 805980E: using guessed type int dword_805980E;

//----- (0804FB10) --------------------------------------------------------
_BYTE *__usercall sub_804FB10@<eax>(signed int a1@<ebx>, int a2, unsigned __int8 a3)
{
  unsigned int v8; // [esp-Ah] [ebp-22h]
  _BYTE *v9; // [esp-4h] [ebp-1Ch]
  unsigned __int8 v10; // [esp+Ch] [ebp-Ch]
  int savedregs; // [esp+18h] [ebp+0h]

  v10 = a3;
  v9 = sub_804F905(0, 0, _SF, 0, a2, a1, &savedregs, a2, -1, a3);
  __asm { pushfw }
  v8 = sub_805322D();
  __asm { pushfw }
  if ( sub_805288C() != 695 )
    sub_8052952();
  __asm { popfw }
  if ( v8 != -952 )
    sub_8053237(v8 < 0xFFFFFC48, v8 == -952, (signed int)(v8 + 952) < 0, __OFSUB__(v8, -952), a1);
  __asm { popfw }
  return v9;
}
// 8052952: using guessed type int sub_8052952(void);

//----- (0804FBB7) --------------------------------------------------------
_BYTE *__usercall sub_804FBB7@<eax>(signed int a1@<ebx>, int a2)
{
  return sub_804FB10(a1, a2, 0x3Au);
}

//----- (0804FC67) --------------------------------------------------------
_BYTE *__usercall sub_804FC67@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>, int a7, int a8)
{
  unsigned int v8; // eax
  signed int *v9; // ebp
  signed int v11; // [esp-Ah] [ebp-86h]
  int v12; // [esp-4h] [ebp-80h]
  int v13; // [esp+8h] [ebp-74h]
  signed int *v14; // [esp+Ch] [ebp-70h]
  int v15; // [esp+10h] [ebp-6Ch]
  int v16; // [esp+14h] [ebp-68h]
  int v17; // [esp+18h] [ebp-64h]
  int v18; // [esp+1Ch] [ebp-60h]
  int v19; // [esp+20h] [ebp-5Ch]
  int v20; // [esp+24h] [ebp-58h]
  int v21; // [esp+28h] [ebp-54h]
  int v22; // [esp+2Ch] [ebp-50h]
  int v23; // [esp+30h] [ebp-4Ch]
  int v24; // [esp+34h] [ebp-48h]
  int v25; // [esp+38h] [ebp-44h]
  int v26; // [esp+3Ch] [ebp-40h]
  int v27; // [esp+40h] [ebp-3Ch]
  int v28; // [esp+44h] [ebp-38h]
  int v29; // [esp+48h] [ebp-34h]
  int v30; // [esp+4Ch] [ebp-30h]
  int v31; // [esp+50h] [ebp-2Ch]
  int v32; // [esp+54h] [ebp-28h]
  int v33; // [esp+58h] [ebp-24h]
  int v34; // [esp+5Ch] [ebp-20h]
  int v35; // [esp+60h] [ebp-1Ch]
  int v36; // [esp+64h] [ebp-18h]
  int v37; // [esp+68h] [ebp-14h]
  int v38; // [esp+6Ch] [ebp-10h]
  __int16 v39; // [esp+76h] [ebp-6h]
  __int16 *v40; // [esp+78h] [ebp-4h]

  v40 = (__int16 *)a5;
  __asm { pushfw }
  v8 = sub_804B04D(_CF, _ZF, _SF, _OF, a5, a6);
  if ( v8 != 549 )
    sub_804B0C4(v8 < 0x225, v8 == 549, (signed int)(v8 - 549) < 0, __OFSUB__(v8, 549), v8, a6);
  __asm { popfw }
  v40 = &v39;
  v9 = (signed int *)&v40;
  sub_804DDAE(&v15, a8);
  v27 = v15;
  v28 = v16;
  v29 = v17;
  v30 = v18;
  v31 = v19;
  v32 = v20;
  v33 = v21;
  v34 = v22;
  v35 = v23;
  v36 = v24;
  v37 = v25;
  v38 = v26;
  v12 = sub_804DBCC(a6, &v27, 0x3Au, 1);
  __asm { pushfw }
  v11 = a6;
  if ( a6 >= 10 )
  {
    v9 = &v11;
    if ( ((_BYTE)a6 - 1) * (_BYTE)a6 & 1 )
      abort();
  }
  __asm { popfw }
  v14 = v9 - 14;
  v13 = -1;
  return sub_804F24B(v11, v9[2], v9[4], -1, (unsigned int *)v9 - 14);
}
// 804FC67: could not find valid save-restore pair for ebp

//----- (0804FDDE) --------------------------------------------------------
_BYTE *__usercall sub_804FDDE@<eax>(signed int a1@<ebx>, signed int a2, int a3, int a4, int a5)
{
  return sub_804FE0E(a1, a2, a3, a4, a5, -1);
}

//----- (0804FE0E) --------------------------------------------------------
_BYTE *__usercall sub_804FE0E@<eax>(signed int a1@<ebx>, signed int a2, int a3, int a4, int a5, int a6)
{
  int v7; // [esp+10h] [ebp-38h]
  int v8; // [esp+14h] [ebp-34h]
  int v9; // [esp+18h] [ebp-30h]
  int v10; // [esp+1Ch] [ebp-2Ch]
  int v11; // [esp+20h] [ebp-28h]
  int v12; // [esp+24h] [ebp-24h]
  int v13; // [esp+28h] [ebp-20h]
  int v14; // [esp+2Ch] [ebp-1Ch]
  int v15; // [esp+30h] [ebp-18h]
  int v16; // [esp+34h] [ebp-14h]
  int v17; // [esp+38h] [ebp-10h]
  int v18; // [esp+3Ch] [ebp-Ch]

  v7 = dword_80597E2;
  v8 = dword_80597E6;
  v9 = dword_80597EA;
  v10 = dword_80597EE;
  v11 = dword_80597F2;
  v12 = dword_80597F6;
  v13 = dword_80597FA;
  v14 = dword_80597FE;
  v15 = dword_8059802;
  v16 = dword_8059806;
  v17 = dword_805980A;
  v18 = dword_805980E;
  sub_804DD08(a1, &v7, a3, a4);
  return sub_804F24B(a1, a2, a5, a6, (unsigned int *)&v7);
}
// 80597E2: using guessed type int dword_80597E2;
// 80597E6: using guessed type int dword_80597E6;
// 80597EA: using guessed type int dword_80597EA;
// 80597EE: using guessed type int dword_80597EE;
// 80597F2: using guessed type int dword_80597F2;
// 80597F6: using guessed type int dword_80597F6;
// 80597FA: using guessed type int dword_80597FA;
// 80597FE: using guessed type int dword_80597FE;
// 8059802: using guessed type int dword_8059802;
// 8059806: using guessed type int dword_8059806;
// 805980A: using guessed type int dword_805980A;
// 805980E: using guessed type int dword_805980E;

//----- (0804FFE4) --------------------------------------------------------
_BYTE *__usercall sub_804FFE4@<eax>(signed int a1@<ebx>, signed int a2, int a3, int a4)
{
  return sub_804F24B(a1, a2, a3, a4, (unsigned int *)&unk_8059220);
}

//----- (080500F6) --------------------------------------------------------
_BYTE *__usercall sub_80500F6@<eax>(signed int a1@<ebx>, signed int a2, int a3)
{
  return sub_804FFE4(a1, a2, a3, -1);
}

//----- (08050118) --------------------------------------------------------
_BYTE *__usercall sub_8050118@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>, int a7)
{
  _BYTE *v12; // [esp-4h] [ebp-20h]
  __int16 v13; // [esp+16h] [ebp-6h]
  __int16 *v14; // [esp+18h] [ebp-4h]

  v14 = (__int16 *)a5;
  __asm { pushfw }
  if ( sub_805288C() != 695 )
    sub_8052952();
  __asm { popfw }
  v14 = &v13;
  v12 = sub_80500F6(a6, 0, a7);
  __asm { pushfw }
  if ( sub_8052896(_CF, _ZF, _SF, _OF, (int)v12, a6) != 449 )
    sub_8052951();
  __asm { popfw }
  return v12;
}
// 8050118: could not find valid save-restore pair for ebp
// 8052951: using guessed type int sub_8052951(void);
// 8052952: using guessed type int sub_8052952(void);

//----- (08050185) --------------------------------------------------------
int __cdecl sub_8050185(int fd, void *buf, size_t nbytes)
{
  ssize_t v4; // [esp+1Ch] [ebp-Ch]

  v4 = read(fd, buf, nbytes);
  dword_80591CC = (int (*)(void))&loc_8050215;
  if ( v4 >= 0 )
    dword_80591CC = (int (*)(void))&locret_8050238;
  return dword_80591CC();
}
// 80591CC: using guessed type int (*dword_80591CC)(void);

//----- (0805032F) --------------------------------------------------------
int __cdecl sub_805032F(FILE *stream, int a2, int a3, int a4, int a5, int a6)
{
  char *v6; // eax
  char *v7; // eax
  int v9; // edi
  int v10; // ST54_4
  int v11; // ST50_4
  int v12; // ST4C_4
  int v13; // ST48_4
  int v14; // ST44_4
  int v15; // ST40_4
  int v16; // esi
  int v17; // ebx
  char *v18; // eax

  if ( a2 )
    fprintf(stream, "%s (%s) %s\n", a2, a3, a4);
  else
    fprintf(stream, "%s %s\n", a3, a4);
  v6 = gettext("(C)");
  fprintf(stream, "Copyright %s %d Free Software Foundation, Inc.", v6, 2017);
  v7 = gettext(
         "\n"
         "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\n"
         "This is free software: you are free to change and redistribute it.\n"
         "There is NO WARRANTY, to the extent permitted by law.\n"
         "\n");
  fputs_unlocked(v7, stream);
  if ( (unsigned int)a6 <= 9 )
    JUMPOUT(__CS__, *(&off_8054D0C + a6));
  v9 = *(_DWORD *)(a5 + 32);
  v10 = *(_DWORD *)(a5 + 28);
  v11 = *(_DWORD *)(a5 + 24);
  v12 = *(_DWORD *)(a5 + 20);
  v13 = *(_DWORD *)(a5 + 16);
  v14 = *(_DWORD *)(a5 + 12);
  v15 = *(_DWORD *)(a5 + 8);
  v16 = *(_DWORD *)(a5 + 4);
  v17 = *(_DWORD *)a5;
  v18 = gettext(aWrittenBySSSS);
  return fprintf(stream, v18, v17, v16, v15, v14, v13, v12, v11, v10, v9);
}
// 8048F40: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8054D0C: using guessed type void *;

//----- (08050A76) --------------------------------------------------------
#error "8050AA8: call analysis failed (funcsize=19)"

//----- (08050AB4) --------------------------------------------------------
int __usercall sub_8050AB4@<eax>(signed int a1@<ebx>, FILE *stream, int a3, int a4, int a5, int a6)
{
  int *v6; // eax
  int v12; // [esp-4h] [ebp-5Ch]
  int i; // [esp+24h] [ebp-34h]
  int v14[12]; // [esp+28h] [ebp-30h]

  for ( i = 0; (unsigned int)i <= 9; ++i )
  {
    v6 = (int *)a6;
    a6 += 4;
    v14[i] = *v6;
    if ( !v14[i] )
      break;
  }
  v12 = sub_805032F(stream, a3, a4, a5, (int)v14, i);
  __asm { pushfw }
  if ( a1 >= 10 && ((_BYTE)a1 - 1) * (_BYTE)a1 & 1 )
    abort();
  __asm
  {
    popfw
    pushfw
  }
  if ( sub_8052896(_CF, _ZF, _SF, _OF, v12, a1) != 449 )
    sub_8052951();
  __asm { popfw }
  return v12;
}
// 8052951: using guessed type int sub_8052951(void);
// 8050AB4: using guessed type int var_30[12];

//----- (08050C58) --------------------------------------------------------
int __usercall sub_8050C58@<eax>(signed int a1@<ebx>, FILE *stream, int a3, int a4, int a5, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a5);
  return sub_8050AB4(a1, stream, a3, a4, a5, (int)va);
}

//----- (08050D85) --------------------------------------------------------
void *__usercall sub_8050D85@<eax>(signed int a1@<ebx>, void *ptr, unsigned int *a3, unsigned int a4)
{
  unsigned int v4; // eax
  unsigned int v10; // [esp-4h] [ebp-2Ch]
  unsigned int v11; // [esp+1Ch] [ebp-Ch]

  v4 = *a3;
  v11 = *a3;
  if ( ptr )
  {
    if ( 0x55555554 / a4 <= v11 )
      sub_805124E(a1);
    v11 += (v11 >> 1) + 1;
  }
  else
  {
    _CF = 0;
    _OF = 0;
    _ZF = v11 == 0;
    _SF = (v11 & 0x80000000) != 0;
    if ( !v11 )
    {
      v10 = v4;
      __asm { pushfw }
      if ( sub_805288C() != 695 )
        sub_8052952();
      __asm { popfw }
      v11 = (0x40 / a4 == 0) + 0x40 / a4;
    }
    if ( 0x7FFFFFFF / a4 < v11 )
      sub_805124E(a1);
  }
  *a3 = v11;
  return sub_8051006(a1, ptr, a4 * v11);
}
// 8052952: using guessed type int sub_8052952(void);

//----- (08050EE0) --------------------------------------------------------
void *__usercall sub_8050EE0@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>, size_t size)
{
  unsigned int v7; // eax
  unsigned int v8; // eax
  void *v10; // [esp-4h] [ebp-20h]
  __int16 v11; // [esp+16h] [ebp-6h]
  __int16 *v12; // [esp+18h] [ebp-4h]

  v12 = (__int16 *)a5;
  __asm { pushfw }
  v7 = sub_804B04D(_CF, _ZF, _SF, _OF, a5, a6);
  if ( v7 != 549 )
    sub_804B0C4(v7 < 0x225, v7 == 549, (signed int)(v7 - 549) < 0, __OFSUB__(v7, 549), v7, a6);
  __asm { popfw }
  v12 = &v11;
  v10 = sub_8050F4D(a6, size);
  __asm { pushfw }
  v8 = sub_804B04D(_CF, _ZF, _SF, _OF, (int)v10, a6);
  if ( v8 != 549 )
    sub_804B0C4(v8 < 0x225, v8 == 549, (signed int)(v8 - 549) < 0, __OFSUB__(v8, 549), v8, a6);
  __asm { popfw }
  return v10;
}
// 8050EE0: could not find valid save-restore pair for ebp

//----- (08050F4D) --------------------------------------------------------
void *__usercall sub_8050F4D@<eax>(signed int a1@<ebx>, size_t size)
{
  int v7; // [esp-4h] [ebp-2Ch]
  void *v8; // [esp+1Ch] [ebp-Ch]

  v8 = malloc(size);
  _CF = 0;
  _OF = 0;
  _ZF = v8 == 0;
  _SF = (signed int)v8 < 0;
  if ( !v8 )
  {
    v7 = 0;
    __asm { pushfw }
    if ( sub_805288C() != 695 )
      sub_8052952();
    __asm { popfw }
    if ( size )
      sub_805124E(a1);
  }
  return v8;
}
// 8052952: using guessed type int sub_8052952(void);

//----- (08051006) --------------------------------------------------------
void *__usercall sub_8051006@<eax>(signed int a1@<ebx>, void *ptr, size_t size)
{
  void *result; // eax
  void *v4; // eax
  void *v9; // [esp-4h] [ebp-1Ch]
  void *ptra; // [esp+20h] [ebp+8h]

  if ( size || !ptr )
  {
    v4 = realloc(ptr, size);
    ptra = v4;
    _CF = 0;
    _OF = 0;
    _ZF = v4 == 0;
    _SF = (signed int)v4 < 0;
    if ( !v4 )
    {
      _CF = 0;
      _OF = 0;
      _ZF = size == 0;
      _SF = (size & 0x80000000) != 0;
      if ( size )
        sub_805124E(a1);
    }
    v9 = v4;
    __asm { pushfw }
    if ( sub_805288C() != 695 )
      sub_8052952();
    __asm { popfw }
    result = ptra;
  }
  else
  {
    free(ptr);
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 8052952: using guessed type int sub_8052952(void);

//----- (08051102) --------------------------------------------------------
void *__usercall sub_8051102@<eax>(signed int a1@<ebx>, size_t nmemb, size_t size)
{
  void *v4; // [esp+1Ch] [ebp-Ch]

  if ( 0x7FFFFFFF / size < nmemb || (v4 = calloc(nmemb, size)) == 0 )
    sub_805124E(a1);
  return v4;
}

//----- (08051140) --------------------------------------------------------
void *__usercall sub_8051140@<eax>(signed int a1@<ebx>, void *src, size_t n)
{
  void *v3; // eax

  v3 = sub_8050F4D(a1, n);
  return memcpy(v3, src, n);
}

//----- (0805124E) --------------------------------------------------------
void __usercall __noreturn sub_805124E(signed int a1@<ebx>)
{
  char *v1; // eax
  unsigned int v6; // eax

  v1 = gettext("memory exhausted");
  error(status, 0, "%s", v1);
  __asm { pushfw }
  v6 = sub_805322D();
  if ( v6 != -952 )
    sub_8053237(v6 < 0xFFFFFC48, v6 == -952, (signed int)(v6 + 952) < 0, __OFSUB__(v6, -952), a1);
  __asm { popfw }
  abort();
}

//----- (080512D2) --------------------------------------------------------
void sub_80512D2()
{
  ;
}

//----- (080512D7) --------------------------------------------------------
void __usercall sub_80512D7(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>, signed int *a7@<ebp>, int *a8, int a9)
{
  int v9; // eax
  int v14; // [esp-4h] [ebp-20h]
  int *v15; // [esp+0h] [ebp-1Ch]
  int v16; // [esp+4h] [ebp-18h]
  signed int v17; // [esp+12h] [ebp-Ah]
  signed int *v18; // [esp+18h] [ebp-4h]

  v18 = (signed int *)a5;
  __asm { pushfw }
  if ( a6 >= 10 )
  {
    a7 = &v17;
    if ( ((_BYTE)a6 - 1) * (_BYTE)a6 & 1 )
      abort();
  }
  __asm { popfw }
  v18 = a7;
  v16 = a9;
  v15 = a8;
  v9 = sub_8052627((unsigned int)&v18 < 0x18, &v18 == 0, (signed int)&v18 < 0, __OFSUB__(&v18, 24), a8, v17);
  _CF = 0;
  _OF = 0;
  _ZF = v9 == 0;
  _SF = v9 < 0;
  if ( v9 < 0 )
  {
    v14 = v9;
    __asm { pushfw }
    if ( sub_8052896(0, v9 == 0, v9 < 0, 0, v9, a6) != 449 )
      sub_8052951();
    __asm { popfw }
    sub_80512D2();
  }
}
// 80512D7: could not find valid save-restore pair for ebp
// 8052951: using guessed type int sub_8052951(void);

//----- (08051382) --------------------------------------------------------
signed int __usercall sub_8051382@<eax>(signed int a1@<ebx>, unsigned int *a2, signed int a3)
{
  unsigned int v3; // ebx
  signed __int64 v4; // rax
  unsigned int v5; // ebx
  signed int result; // eax

  v4 = sub_80533D9(0, 0, _SF, 0, a3, a1, 0xFFFFFFFFFFFFFFFFLL, a3, a3 >> 31);
  v3 = HIDWORD(v4);
  HIDWORD(v4) = a2[1];
  if ( v3 > HIDWORD(v4) )
    goto LABEL_13;
  _CF = v3 < HIDWORD(v4);
  _OF = __OFSUB__(v3, HIDWORD(v4));
  _ZF = v3 == HIDWORD(v4);
  _SF = (signed int)(v3 - HIDWORD(v4)) < 0;
  if ( v3 < HIDWORD(v4) )
    goto LABEL_14;
  __asm { pushfw }
  if ( (signed int)v3 >= 10 )
  {
    if ( ((_BYTE)v3 - 1) * (_BYTE)v3 & 1 )
      abort();
  }
  __asm { popfw }
  if ( (unsigned int)v4 >= *a2 )
  {
LABEL_13:
    v5 = a2[1];
    _CF = *a2 * (unsigned __int64)(unsigned int)a3 >> 32 != 0;
    _OF = *a2 * (unsigned __int64)(unsigned int)a3 >> 32 != 0;
    *(_QWORD *)a2 *= a3;
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  else
  {
LABEL_14:
    *a2 = -1;
    a2[1] = -1;
    result = 1;
  }
  return result;
}

//----- (080515C1) --------------------------------------------------------
int __usercall sub_80515C1@<eax>(signed int a1@<ebx>, unsigned int *a2, signed int a3, int a4)
{
  int v9; // eax
  int v14; // [esp-4h] [ebp-2Ch]
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; ; i |= v14 )
  {
    v9 = a4--;
    _CF = 0;
    _OF = 0;
    _ZF = v9 == 0;
    _SF = v9 < 0;
    if ( !v9 )
      break;
    v14 = v9;
    __asm { pushfw }
    if ( a1 >= 10 && ((_BYTE)a1 - 1) * (_BYTE)a1 & 1 )
      abort();
    __asm { popfw }
    v14 = sub_8051382(a1, a2, a3);
    __asm { pushfw }
    if ( sub_8052896(_CF, _ZF, _SF, _OF, v14, a1) != 449 )
      sub_8052951();
    __asm { popfw }
  }
  return i;
}
// 8052951: using guessed type int sub_8052951(void);

//----- (080516FB) --------------------------------------------------------
int __usercall sub_80516FB@<eax>(signed int a1@<ebx>, char *nptr, int a3, int base, int a5, char *s)
{
  char **v6; // eax
  int result; // eax
  int v8; // edx
  char v9; // al
  int v14; // edx
  int v19; // edx
  char v20; // al
  unsigned int v21; // eax
  int v22; // edx
  unsigned __int8 i; // [esp+1Bh] [ebp-2Dh]
  char v24; // [esp+1Ch] [ebp-2Ch]
  int v25; // [esp+20h] [ebp-28h]
  char *v26; // [esp+24h] [ebp-24h]
  int v27; // [esp+28h] [ebp-20h]
  int v28; // [esp+2Ch] [ebp-1Ch]
  int v29; // [esp+30h] [ebp-18h]
  char **endptr; // [esp+34h] [ebp-14h]
  uintmax_t v31; // [esp+38h] [ebp-10h]

  v25 = 0;
  if ( base < 0 || base > 36 )
    __assert_fail(assertion, "lib/xstrtol.c", 0x60u, "xstrtoumax");
  if ( a3 )
    v6 = (char **)a3;
  else
    v6 = (char **)&v24;
  endptr = v6;
  *__errno_location() = 0;
  v26 = nptr;
  for ( i = *nptr; (*__ctype_b_loc())[i] & 0x2000; i = *v26 )
    ++v26;
  if ( i == 45 )
    return 4;
  v31 = strtoumax(nptr, endptr, base);
  if ( *endptr == nptr )
  {
    if ( !s || !**endptr || !strchr(s, **endptr) )
      return 4;
    v31 = 1LL;
  }
  else if ( *__errno_location() )
  {
    if ( *__errno_location() != 34 )
      return 4;
    v25 = 1;
  }
  _CF = 0;
  _OF = 0;
  _ZF = s == 0;
  _SF = (signed int)s < 0;
  if ( s )
  {
    v9 = **endptr;
    _CF = 0;
    _OF = 0;
    _ZF = v9 == 0;
    _SF = v9 < 0;
    if ( v9 )
    {
      v27 = 1024;
      v28 = 1;
      if ( strchr(s, **endptr) )
      {
        v21 = **endptr - 69;
        if ( v21 <= 0x2F )
          JUMPOUT(__CS__, *(&off_8054E74 + v21));
        switch ( **endptr )
        {
          case 66:
            v29 = sub_8051382(a1, (unsigned int *)&v31, 1024);
            goto LABEL_48;
          case 69:
            v29 = sub_80515C1(a1, (unsigned int *)&v31, v27, 6);
            goto LABEL_48;
          case 71:
          case 103:
            v29 = sub_80515C1(a1, (unsigned int *)&v31, v27, 3);
            goto LABEL_48;
          case 75:
          case 107:
            v29 = sub_80515C1(a1, (unsigned int *)&v31, v27, 1);
            goto LABEL_48;
          case 77:
          case 109:
            v29 = sub_80515C1(a1, (unsigned int *)&v31, v27, 2);
            goto LABEL_48;
          case 80:
            v29 = sub_80515C1(a1, (unsigned int *)&v31, v27, 5);
            goto LABEL_48;
          case 84:
          case 116:
            v29 = sub_80515C1(a1, (unsigned int *)&v31, v27, 4);
            goto LABEL_48;
          case 89:
            v29 = sub_80515C1(a1, (unsigned int *)&v31, v27, 8);
            goto LABEL_48;
          case 90:
            v29 = sub_80515C1(a1, (unsigned int *)&v31, v27, 7);
            goto LABEL_48;
          case 98:
            v29 = sub_8051382(a1, (unsigned int *)&v31, 512);
            goto LABEL_48;
          case 99:
            v29 = 0;
            goto LABEL_48;
          case 119:
            v29 = sub_8051382(a1, (unsigned int *)&v31, 2);
LABEL_48:
            v25 |= v29;
            *endptr += v28;
            v20 = **endptr;
            _CF = 0;
            _OF = 0;
            _ZF = v20 == 0;
            _SF = v20 < 0;
            if ( v20 )
            {
              _CF = 0;
              _OF = 0;
              _ZF = (v25 | 2) == 0;
              _SF = (v25 | 2) < 0;
              v25 |= 2u;
            }
            goto LABEL_50;
          default:
            v19 = HIDWORD(v31);
            *(_DWORD *)a5 = v31;
            *(_DWORD *)(a5 + 4) = v19;
            result = v25 | 2;
            break;
        }
      }
      else
      {
        v14 = HIDWORD(v31);
        *(_DWORD *)a5 = v31;
        *(_DWORD *)(a5 + 4) = v14;
        result = v25 | 2;
      }
    }
    else
    {
LABEL_50:
      __asm { pushfw }
      if ( a1 >= 10 && ((_BYTE)a1 - 1) * (_BYTE)a1 & 1 )
        abort();
      __asm { popfw }
      v22 = HIDWORD(v31);
      *(_DWORD *)a5 = v31;
      *(_DWORD *)(a5 + 4) = v22;
      result = v25;
    }
  }
  else
  {
    __asm { pushfw }
    if ( a1 >= 10 )
    {
      if ( ((_BYTE)a1 - 1) * (_BYTE)a1 & 1 )
        abort();
    }
    __asm { popfw }
    v8 = HIDWORD(v31);
    *(_DWORD *)a5 = v31;
    *(_DWORD *)(a5 + 4) = v8;
    result = v25;
  }
  return result;
}
// 8054E74: using guessed type void *off_8054E74;

//----- (08051BDC) --------------------------------------------------------
int __usercall sub_8051BDC@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>, __int16 *a7@<ebp>, FILE *stream)
{
  int v9; // eax
  __int64 v10; // rax
  int v11; // [esp+14h] [ebp-18h]
  int v12; // [esp+18h] [ebp-14h]
  __int16 v13; // [esp+22h] [ebp-Ah]
  __int16 *v14; // [esp+28h] [ebp-4h]

  v14 = (__int16 *)a5;
  __asm { pushfw }
  if ( a6 >= 10 )
  {
    a7 = &v13;
    if ( ((_BYTE)a6 - 1) * (_BYTE)a6 & 1 )
      abort();
  }
  __asm { popfw }
  v14 = a7;
  v11 = 0;
  if ( fileno(stream) < 0 )
    return fclose(stream);
  if ( !__freading(stream) || (v9 = fileno(stream), LODWORD(v10) = lseek64(v9, 0, 0, 1), v10 != -1) )
  {
    if ( sub_8051D98(a6, stream) )
      v11 = *__errno_location();
  }
  v12 = fclose(stream);
  if ( v11 )
  {
    *__errno_location() = v11;
    v12 = -1;
  }
  return v12;
}
// 8051BDC: could not find valid save-restore pair for ebp
// 8049050: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08051CEC) --------------------------------------------------------
int __cdecl sub_8051CEC(FILE *stream)
{
  int result; // eax
  int v6; // [esp-4h] [ebp-1Ch]

  result = stream->_flags & 0x100;
  _CF = 0;
  _OF = 0;
  _ZF = result == 0;
  _SF = result < 0;
  if ( result )
  {
    v6 = stream->_flags & 0x100;
    __asm { pushfw }
    if ( sub_805288C() != 695 )
      sub_8052952();
    __asm { popfw }
    result = sub_8051E7C(stream, 0, 0, 1);
  }
  return result;
}
// 8052952: using guessed type int sub_8052952(void);

//----- (08051D98) --------------------------------------------------------
int __usercall sub_8051D98@<eax>(signed int a1@<ebx>, FILE *fp)
{
  int v3; // eax
  unsigned int v4; // eax
  unsigned int v13; // [esp-Ah] [ebp-22h]
  int v14; // [esp-4h] [ebp-1Ch]

  dword_80591CC = (int (*)(void))&loc_8051DDB;
  if ( fp )
  {
    v3 = __freading(fp);
    _CF = 0;
    _OF = 0;
    _ZF = v3 == 0;
    _SF = v3 < 0;
    dword_80591CC = (int (*)(void))&loc_8051DC3;
    if ( !v3 )
    {
      v14 = 0;
      __asm { pushfw }
      v4 = sub_805322D();
      _CF = v4 < 0xFFFFFC48;
      _OF = __OFSUB__(v4, -952);
      _ZF = v4 == -952;
      _SF = (signed int)(v4 + 952) < 0;
      if ( v4 != -952 )
        sub_8053237(v4 < 0xFFFFFC48, v4 == -952, (signed int)(v4 + 952) < 0, __OFSUB__(v4, -952), a1);
      v13 = v4;
      __asm { pushfw }
      if ( sub_805288C() != 695 )
        sub_8052952();
      __asm
      {
        popfw
        popfw
      }
      fflush(fp);
      dword_80591CC = (int (*)(void))&locret_8051E61;
    }
  }
  return dword_80591CC();
}
// 8052952: using guessed type int sub_8052952(void);
// 80591CC: using guessed type int (*dword_80591CC)(void);

//----- (08051E7C) --------------------------------------------------------
int __cdecl sub_8051E7C(FILE *stream, int a2, int a3, int a4)
{
  int v4; // eax
  int v5; // eax
  int v6; // edx
  int v7; // eax
  int v12; // eax
  int v13; // edx
  int v15; // [esp-4h] [ebp-3Ch]
  int v16; // [esp+18h] [ebp-20h]
  int v17; // [esp+1Ch] [ebp-1Ch]
  int v18; // [esp+28h] [ebp-10h]
  int v19; // [esp+2Ch] [ebp-Ch]

  v16 = a2;
  v17 = a3;
  if ( stream->_IO_read_end != stream->_IO_read_ptr
    || stream->_IO_write_ptr != stream->_IO_write_base
    || stream->_IO_save_base )
  {
    v4 = fseeko64(stream, v16, v17, a4);
  }
  else
  {
    v12 = fileno(stream);
    v5 = lseek64(v12, v16, v17, a4);
    v18 = v5;
    v19 = v6;
    v7 = ~v6 | ~v5;
    _CF = 0;
    _OF = 0;
    _ZF = v7 == 0;
    _SF = v7 < 0;
    if ( v7 )
    {
      _CF = 0;
      _OF = 0;
      _ZF = (stream->_flags & 0xFFFFFFEF) == 0;
      _SF = (stream->_flags & 0xFFFFFFEF & 0x80000000) != 0;
      stream->_flags &= 0xFFFFFFEF;
      v13 = v19;
      LODWORD(stream->_offset) = v18;
      HIDWORD(stream->_offset) = v13;
      __asm { pushfw }
      v4 = 0;
      __asm { popfw }
    }
    else
    {
      v4 = -1;
    }
  }
  v15 = v4;
  __asm { pushfw }
  if ( sub_805288C() != 695 )
    sub_8052952();
  __asm { popfw }
  return v15;
}
// 8048DF0: using guessed type int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8049050: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8052952: using guessed type int sub_8052952(void);

//----- (08051FE8) --------------------------------------------------------
unsigned int __usercall sub_8051FE8@<eax>(signed int a1@<ebx>, wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  unsigned int v9; // eax
  char v11; // [esp+18h] [ebp-10h]
  unsigned int v12; // [esp+1Ch] [ebp-Ch]

  _CF = 0;
  _OF = 0;
  _ZF = pwc == 0;
  _SF = (signed int)pwc < 0;
  if ( !pwc )
    pwc = (wchar_t *)&v11;
  __asm { pushfw }
  if ( a1 >= 10 && ((_BYTE)a1 - 1) * (_BYTE)a1 & 1 )
    abort();
  __asm { popfw }
  v9 = mbrtowc(pwc, s, n, p);
  v12 = v9;
  if ( v9 <= 0xFFFFFFFD || !n || !((unsigned __int8)sub_8052953(0, n == 0, (n & 0x80000000) != 0, 0, v9, a1, 0) ^ 1) )
    return v12;
  *pwc = (unsigned __int8)*s;
  return 1;
}

//----- (080520CC) --------------------------------------------------------
int __cdecl sub_80520CC(char *s, int a2, int a3, size_t n)
{
  int result; // eax
  char v5; // [esp+13h] [ebp-15h]
  signed int i; // [esp+14h] [ebp-14h]
  signed int v7; // [esp+18h] [ebp-10h]
  size_t v8; // [esp+1Ch] [ebp-Ch]

  v7 = -1;
  v5 = 0;
  v8 = strlen(s);
  for ( i = 0; *(_DWORD *)(4 * i + a2); ++i )
  {
    if ( !strncmp(*(const char **)(4 * i + a2), s, v8) )
    {
      if ( strlen(*(const char **)(4 * i + a2)) == v8 )
        return i;
      if ( v7 == -1 )
      {
        v7 = i;
      }
      else if ( !a3 || memcmp((const void *)(a3 + n * v7), (const void *)(i * n + a3), n) )
      {
        v5 = 1;
      }
    }
  }
  if ( v5 )
    result = -2;
  else
    result = v7;
  return result;
}

//----- (08052236) --------------------------------------------------------
void __usercall sub_8052236(signed int a1@<ebx>, int a2, int a3, int a4)
{
  char *v4; // eax
  char *format; // ST38_4
  _BYTE *v6; // eax
  _BYTE *v7; // ebx
  _BYTE *v8; // eax

  if ( a4 == -1 )
    v4 = gettext("invalid argument %s for %s");
  else
    v4 = gettext("ambiguous argument %s for %s");
  format = v4;
  v6 = sub_80500F6(a1, 1, a2);
  v7 = v6;
  v8 = sub_804F64E((signed int)v6, 0, 8, a3);
  error(0, 0, format, v8, v7);
}

//----- (08052343) --------------------------------------------------------
int __cdecl sub_8052343(void *s1, char *s, size_t a3)
{
  FILE *v3; // ebx
  char *v9; // [esp-4h] [ebp-2Ch]
  char *v10; // [esp+4h] [ebp-24h]
  _BYTE *v11; // [esp+8h] [ebp-20h]
  int i; // [esp+18h] [ebp-10h]
  void *v13; // [esp+1Ch] [ebp-Ch]

  v13 = 0;
  v3 = stderr;
  v9 = gettext("Valid arguments are:");
  __asm { pushfw }
  if ( sub_8052896(_CF, _ZF, _SF, _OF, (int)v9, (signed int)v3) != 449 )
    sub_8052951();
  __asm { popfw }
  fputs_unlocked(v9, v3);
  for ( i = 0; *((_DWORD *)s1 + i); ++i )
  {
    if ( i && (v10 = &s[i * a3], !memcmp(v13, v10, a3)) )
    {
      v11 = sub_8050118(
              __CFADD__(4 * i, s1),
              (char *)s1 + 4 * i == 0,
              (signed int)s1 + 4 * i < 0,
              __OFADD__(4 * i, s1),
              *((_DWORD *)s1 + i),
              (signed int)v3,
              *((_DWORD *)s1 + i));
      fprintf(stderr, ", %s", v11);
    }
    else
    {
      v11 = sub_8050118(
              __CFADD__(4 * i, s1),
              (char *)s1 + 4 * i == 0,
              (signed int)s1 + 4 * i < 0,
              __OFADD__(4 * i, s1),
              *((_DWORD *)s1 + i),
              (signed int)v3,
              *((_DWORD *)s1 + i));
      fprintf(stderr, "\n  - %s", v11);
      v13 = &s[i * a3];
    }
  }
  return putc_unlocked(10, stderr);
}
// 8048F40: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8052951: using guessed type int sub_8052951(void);

//----- (08052611) --------------------------------------------------------
int sub_8052611()
{
  int result; // eax

  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}

//----- (0805261C) --------------------------------------------------------
int sub_805261C()
{
  int result; // eax

  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}

//----- (08052627) --------------------------------------------------------
int __usercall sub_8052627@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int *a5@<eax>, signed int a6@<ebx>)
{
  unsigned int v6; // eax
  unsigned int v7; // eax
  int v9; // [esp-4h] [ebp-20h]
  int v10; // [esp+14h] [ebp-8h]
  int *v11; // [esp+18h] [ebp-4h]

  v11 = a5;
  __asm { pushfw }
  v6 = sub_805322D();
  if ( v6 != -952 )
    sub_8053237(v6 < 0xFFFFFC48, v6 == -952, (signed int)(v6 + 952) < 0, __OFSUB__(v6, -952), a6);
  __asm { popfw }
  v11 = (int *)((char *)&v10 + 2);
  v10 = sub_805261C();
  if ( v10 )
    return v10;
  v9 = sub_8052611();
  __asm { pushfw }
  v7 = sub_805322D();
  if ( v7 != -952 )
    sub_8053237(v7 < 0xFFFFFC48, v7 == -952, (signed int)(v7 + 952) < 0, __OFSUB__(v7, -952), a6);
  __asm { popfw }
  return v9;
}
// 8052627: could not find valid save-restore pair for ebp

//----- (080526D7) --------------------------------------------------------
int __cdecl sub_80526D7(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // esi
  unsigned __int8 *v3; // ebx
  int result; // eax
  unsigned __int8 v9; // al
  unsigned __int8 v10; // [esp+1Eh] [ebp-Ah]

  v2 = a1;
  v3 = a2;
  _CF = a1 < a2;
  _OF = __OFSUB__(a1, a2);
  _ZF = a1 == a2;
  _SF = a1 - a2 < 0;
  if ( a1 == a2 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  else
  {
    do
    {
      v10 = sub_8053344(_CF, _ZF, _SF, _OF, *v2, (signed int)v3, *v2);
      v9 = sub_8053344(_CF, _ZF, _SF, _OF, *v3, (signed int)v3, *v3);
      if ( !v10 )
        break;
      ++v2;
      ++v3;
      _CF = v10 < v9;
      _OF = __OFSUB__(v10, v9);
      _ZF = v10 == v9;
      _SF = (char)(v10 - v9) < 0;
    }
    while ( v10 == v9 );
    result = v10 - v9;
  }
  return result;
}

//----- (08052761) --------------------------------------------------------
int __usercall sub_8052761@<eax>(signed int a1@<ebx>, FILE *fp)
{
  __int16 *v2; // ebp
  unsigned int v3; // eax
  int result; // eax
  signed int v9; // [esp-Ah] [ebp-32h]
  int v10; // [esp-4h] [ebp-2Ch]
  bool v11; // [esp+1Dh] [ebp-Bh]
  bool v12; // [esp+1Eh] [ebp-Ah]
  char v13; // [esp+1Fh] [ebp-9h]
  int savedregs; // [esp+28h] [ebp+0h]

  v2 = (__int16 *)&savedregs;
  v11 = __fpending(fp) != 0;
  v10 = ferror_unlocked(fp);
  __asm { pushfw }
  v9 = a1;
  if ( a1 >= 10 )
  {
    v2 = (__int16 *)&v9;
    if ( ((_BYTE)a1 - 1) * (_BYTE)a1 & 1 )
      abort();
  }
  __asm { popfw }
  v12 = v10 != 0;
  v3 = sub_8051BDC(0, v10 == 0, v10 < 0, 0, (int)fp, v9, v2, fp);
  LOBYTE(v3) = v3 != 0;
  v13 = v3;
  if ( v12 )
    goto LABEL_21;
  _CF = 0;
  _OF = 0;
  _ZF = v13 == 0;
  _SF = v13 < 0;
  if ( !v13 )
    goto LABEL_22;
  if ( v11
    || (v3 = *__errno_location(),
        _CF = v3 < 9,
        _OF = __OFSUB__(v3, 9),
        _ZF = v3 == 9,
        _SF = (signed int)(v3 - 9) < 0,
        v3 != 9) )
  {
LABEL_21:
    if ( v13 != 1 )
      *__errno_location() = 0;
    result = -1;
  }
  else
  {
LABEL_22:
    v10 = v3;
    __asm { pushfw }
    if ( sub_804A0C9() != 987 )
      sub_804A0D3();
    __asm
    {
      popfw
      pushfw
    }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 804A0D3: using guessed type int sub_804A0D3(void);

//----- (0805288C) --------------------------------------------------------
signed int sub_805288C()
{
  return 695;
}

//----- (08052896) --------------------------------------------------------
signed int __usercall sub_8052896@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>)
{
  int v7; // [esp-4h] [ebp-4h]

  v7 = a5;
  __asm { pushfw }
  if ( a6 >= 10 && ((_BYTE)a6 - 1) * (_BYTE)a6 & 1 )
    abort();
  __asm { popfw }
  return 449;
}

//----- (08052953) --------------------------------------------------------
int __usercall sub_8052953@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>, int category)
{
  unsigned __int8 v8; // [esp+1Bh] [ebp-11h]
  char *v9; // [esp+1Ch] [ebp-10h]
  __int16 v10; // [esp+26h] [ebp-6h]
  __int16 *v11; // [esp+28h] [ebp-4h]

  v11 = (__int16 *)a5;
  __asm { pushfw }
  if ( sub_8052896(_CF, _ZF, _SF, _OF, a5, a6) != 449 )
    sub_8052951();
  __asm { popfw }
  v11 = &v10;
  v8 = 1;
  v9 = setlocale(category, 0);
  if ( v9 && (!strcmp(v9, "C") || !strcmp(v9, "POSIX")) )
    v8 = 0;
  return v8;
}
// 8052953: could not find valid save-restore pair for ebp
// 8052951: using guessed type int sub_8052951(void);

//----- (080529F0) --------------------------------------------------------
void *__usercall sub_80529F0@<eax>(signed int a1@<ebx>)
{
  char *v1; // eax
  char v6; // al
  signed int v7; // eax
  bool v8; // cf
  bool v9; // zf
  bool v10; // sf
  char v11; // of
  int v12; // eax
  __int16 v14; // [esp-6h] [ebp-CEh]
  int v15; // [esp-4h] [ebp-CCh]
  size_t v16; // [esp+0h] [ebp-C8h]
  char *v17; // [esp+8h] [ebp-C0h]
  char *v18; // [esp+Ch] [ebp-BCh]
  void *ptr; // [esp+14h] [ebp-B4h]
  void *v20; // [esp+18h] [ebp-B0h]
  char *s; // [esp+1Ch] [ebp-ACh]
  void *v22; // [esp+20h] [ebp-A8h]
  size_t v23; // [esp+24h] [ebp-A4h]
  char *v24; // [esp+28h] [ebp-A0h]
  size_t n; // [esp+2Ch] [ebp-9Ch]
  size_t v26; // [esp+30h] [ebp-98h]
  int v27; // [esp+34h] [ebp-94h]
  void *dest; // [esp+38h] [ebp-90h]
  int fd; // [esp+3Ch] [ebp-8Ch]
  FILE *stream; // [esp+40h] [ebp-88h]
  int c; // [esp+44h] [ebp-84h]
  size_t v32; // [esp+48h] [ebp-80h]
  size_t v33; // [esp+4Ch] [ebp-7Ch]
  void *v34; // [esp+50h] [ebp-78h]
  char src; // [esp+56h] [ebp-72h]
  char v36; // [esp+89h] [ebp-3Fh]
  unsigned int v37; // [esp+BCh] [ebp-Ch]

  v37 = __readgsdword(0x14u);
  v20 = (void *)dword_8059922;
  if ( !dword_8059922 )
  {
    ptr = 0;
    v24 = "charset.alias";
    v1 = getenv("CHARSETALIASDIR");
    s = v1;
    if ( !v1 || !*s )
    {
      ptr = 0;
      s = "/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib";
    }
    n = strlen(s);
    v26 = strlen(v24);
    _CF = 0;
    _OF = 0;
    _ZF = n == 0;
    _SF = (n & 0x80000000) != 0;
    if ( n
      && (v6 = s[n - 1],
          _CF = (unsigned __int8)v6 < 0x2Fu,
          _OF = __OFSUB__(v6, 47),
          _ZF = v6 == 47,
          _SF = (char)(v6 - 47) < 0,
          v6 != 47) )
    {
      v7 = 1;
    }
    else
    {
      __asm { pushfw }
      v7 = 0;
      __asm { popfw }
    }
    v27 = v7;
    dest = malloc(n + v7 + v26 + 1);
    if ( dest )
    {
      memcpy(dest, s, n);
      if ( v27 )
        *((_BYTE *)dest + n) = 47;
      memcpy((char *)dest + n + v27, v24, v26 + 1);
    }
    free(ptr);
    if ( dest )
    {
      v15 = open64(dest, 0x20000);
      __asm { pushfw }
      if ( sub_805288C() != 695 )
        sub_8052952();
      __asm { popfw }
      fd = v15;
      if ( v15 >= 0 )
      {
        stream = fdopen(fd, "r");
        if ( stream )
        {
          v22 = 0;
          v23 = 0;
          while ( 1 )
          {
            c = getc_unlocked(stream);
            v8 = (unsigned int)c < 0xFFFFFFFF;
            v11 = __OFSUB__(c, -1);
            v9 = c == -1;
            v10 = c + 1 < 0;
            if ( c == -1 )
              break;
            if ( c != 10 && c != 32 && c != 9 )
            {
              if ( c == 35 )
              {
                do
                  c = getc_unlocked(stream);
                while ( c != -1 && c != 10 );
                v8 = (unsigned int)c < 0xFFFFFFFF;
                v11 = __OFSUB__(c, -1);
                v9 = c == -1;
                v10 = c + 1 < 0;
                if ( c == -1 )
                  break;
              }
              else
              {
                ungetc(c, stream);
                v18 = &v36;
                v17 = &src;
                v12 = fscanf(stream, "%50s %50s", &src, &v36);
                v8 = (unsigned int)v12 < 1;
                v11 = __OFSUB__(v12, 1);
                v9 = v12 == 1;
                v10 = v12 - 1 < 0;
                if ( v12 <= 1 )
                  break;
                v32 = strlen(&src);
                v33 = strlen(&v36);
                v34 = v22;
                if ( v23 )
                {
                  v23 += v33 + v32 + 2;
                  v22 = realloc(v22, v23 + 1);
                }
                else
                {
                  v23 = v32 + v33 + 2;
                  v16 = v32 + v33 + 3;
                  v22 = malloc(v16);
                }
                if ( !v22 )
                {
                  v23 = 0;
                  free(v34);
                  break;
                }
                strcpy((char *)v22 + v23 - v33 - v32 - 2, &src);
                strcpy((char *)v22 + v23 - v33 - 1, &v36);
              }
            }
          }
          sub_8051BDC(v8, v9, v10, v11, (int)stream, a1, &v14, stream);
          if ( v23 )
          {
            *((_BYTE *)v22 + v23) = 0;
            v20 = v22;
          }
          else
          {
            v20 = &unk_80550D3;
          }
        }
        else
        {
          v15 = close(fd);
          __asm { pushfw }
          if ( sub_804A0C9() != 987 )
            sub_804A0D3();
          __asm { popfw }
          v20 = &unk_80550D3;
        }
      }
      else
      {
        v20 = &unk_80550D3;
      }
      free(dest);
    }
    else
    {
      v20 = &unk_80550D3;
    }
    dword_8059922 = (int)v20;
  }
  return v20;
}
// 8048D20: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 804A0D3: using guessed type int sub_804A0D3(void);
// 8052952: using guessed type int sub_8052952(void);
// 8059922: using guessed type int dword_8059922;

//----- (08052F4C) --------------------------------------------------------
const char *__usercall sub_8052F4C@<eax>(signed int a1@<ebx>)
{
  char *v1; // ST1C_4
  const char *s1; // [esp+18h] [ebp-10h]
  char *s2; // [esp+1Ch] [ebp-Ch]

  s1 = nl_langinfo(14);
  if ( !s1 )
    s1 = (const char *)&unk_80550D3;
  for ( s2 = (char *)sub_80529F0(a1); *s2; s2 = &v1[strlen(v1) + 1] )
  {
    if ( !strcmp(s1, s2) || *s2 == 42 && !s2[1] )
    {
      s1 = &s2[strlen(s2) + 1];
      break;
    }
    v1 = &s2[strlen(s2) + 1];
  }
  if ( !*s1 )
    s1 = "ASCII";
  return s1;
}

//----- (0805322D) --------------------------------------------------------
signed int sub_805322D()
{
  return -952;
}

//----- (08053237) --------------------------------------------------------
void __usercall sub_8053237(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed int a5@<ebx>)
{
  __asm { pushfw }
  if ( a5 >= 10 && ((_BYTE)a5 - 1) * (_BYTE)a5 & 1 )
    abort();
  __asm { popfw }
  __halt();
  JUMPOUT(loc_8053315);
}

//----- (08053344) --------------------------------------------------------
int __usercall sub_8053344@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>, int a7)
{
  int result; // eax
  int v8; // [esp-4h] [ebp-4h]

  v8 = a5;
  __asm { pushfw }
  if ( a6 >= 10 && ((_BYTE)a6 - 1) * (_BYTE)a6 & 1 )
    abort();
  __asm { popfw }
  if ( (unsigned int)(a7 - 65) > 0x19 )
    result = a7;
  else
    result = a7 + 32;
  return result;
}

//----- (080533D9) --------------------------------------------------------
signed __int64 __usercall sub_80533D9@<edx:eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>, unsigned __int64 a7, unsigned int a8, unsigned int a9)
{
  unsigned int v9; // ebp
  signed __int64 result; // rax
  unsigned int v11; // esi
  int v20; // ebp
  int v21; // ebp
  unsigned __int64 v22; // rtt
  unsigned int v23; // esi
  unsigned int v24; // edi
  unsigned __int64 v25; // rax
  signed int v26; // [esp-Ah] [ebp-22h]
  unsigned int v27; // [esp-4h] [ebp-1Ch]
  unsigned int v28; // [esp+0h] [ebp-18h]
  unsigned int v29; // [esp+4h] [ebp-14h]
  unsigned int v30; // [esp+8h] [ebp-10h]
  int v31; // [esp+14h] [ebp-4h]

  v31 = a5;
  __asm { pushfw }
  if ( a6 >= 10 && ((_BYTE)a6 - 1) * (_BYTE)a6 & 1 )
    abort();
  __asm { popfw }
  v9 = HIDWORD(a7);
  v29 = a7;
  v28 = a8;
  if ( a9 )
  {
    if ( a9 > HIDWORD(a7) )
      return 0LL;
    _BitScanReverse((unsigned int *)&v20, a9);
    v21 = v20 ^ 0x1F;
    if ( v21 )
    {
      v30 = (a9 << v21) | (v28 >> (32 - v21));
      LODWORD(v22) = (HIDWORD(a7) << v21) | (v29 >> (32 - v21));
      HIDWORD(v22) = HIDWORD(a7) >> (32 - v21);
      v23 = v22 % v30;
      v24 = v22 / v30;
      v25 = (v28 << v21) * (unsigned __int64)v24;
      v28 = HIDWORD(v25);
      if ( v23 < HIDWORD(v25) || v29 << v21 < (unsigned int)v25 && v23 == v28 )
        result = v24 - 1;
      else
        result = v24;
      return result;
    }
    _CF = v28 < v29;
    _OF = __OFSUB__(v28, v29);
    _ZF = v28 == v29;
    _SF = (signed int)(v28 - v29) < 0;
    if ( v28 > v29 )
    {
      _CF = a9 < HIDWORD(a7);
      _OF = __OFSUB__(a9, HIDWORD(a7));
      _ZF = a9 == HIDWORD(a7);
      _SF = (signed int)(a9 - HIDWORD(a7)) < 0;
      if ( a9 >= HIDWORD(a7) )
        return 0LL;
    }
    v27 = a9;
    __asm { pushfw }
    v26 = a6;
    if ( a6 >= 10 && ((_BYTE)a6 - 1) * (_BYTE)a6 & 1 )
      abort();
    __asm { popfw }
    result = 1LL;
  }
  else
  {
    _CF = a8 < HIDWORD(a7);
    _OF = __OFSUB__(a8, HIDWORD(a7));
    _ZF = a8 == HIDWORD(a7);
    _SF = (signed int)(a8 - HIDWORD(a7)) < 0;
    if ( a8 > HIDWORD(a7) )
    {
      result = (unsigned int)(a7 / a8);
    }
    else
    {
      v27 = 0;
      __asm { pushfw }
      v26 = a6;
      if ( a6 >= 10 )
      {
        v9 = (unsigned int)&v26;
        if ( ((_BYTE)a6 - 1) * (_BYTE)a6 & 1 )
          abort();
      }
      __asm { popfw }
      v11 = a8;
      if ( !a8 )
        v11 = 1 / 0u;
      LODWORD(result) = __PAIR__(v9 % v11, (unsigned int)a7) / v11;
      HIDWORD(result) = v9 / v11;
    }
  }
  return result;
}

//----- (080535D3) --------------------------------------------------------
int __cdecl sub_80535D3(unsigned __int64 a1, __int64 a2)
{
  int v2; // edx
  int result; // eax
  unsigned int v4; // ebp
  unsigned __int64 v5; // rtt
  unsigned __int64 v6; // rax
  unsigned int v7; // edi
  unsigned __int64 v8; // rax
  unsigned int v9; // ecx
  int v10; // ebp
  int v11; // ebp
  unsigned int v12; // [esp+4h] [ebp-1Ch]
  __int64 v13; // [esp+8h] [ebp-18h]
  unsigned int v14; // [esp+Ch] [ebp-14h]

  LODWORD(v13) = a1;
  if ( HIDWORD(a2) )
  {
    if ( HIDWORD(a2) > HIDWORD(a1) )
    {
      result = a1;
    }
    else
    {
      _BitScanReverse((unsigned int *)&v10, HIDWORD(a2));
      v11 = v10 ^ 0x1F;
      if ( v11 )
      {
        v12 = (HIDWORD(a2) << v11) | ((unsigned int)a2 >> (32 - v11));
        HIDWORD(v6) = HIDWORD(a1) >> (32 - v11);
        LODWORD(v6) = (HIDWORD(a1) << v11) | ((unsigned int)a1 >> (32 - v11));
        v14 = (_DWORD)a1 << v11;
        v7 = v6 % v12;
        v8 = (unsigned int)((_DWORD)a2 << v11) * (unsigned __int64)(unsigned int)(v6 / v12);
        v9 = v8;
        if ( v7 < HIDWORD(v8) || v14 < (unsigned int)v8 && v7 == HIDWORD(v8) )
        {
          HIDWORD(v8) = (v8 - __PAIR__(v12, (_DWORD)a2 << v11)) >> 32;
          v9 = v8 - ((_DWORD)a2 << v11);
        }
        result = ((__PAIR__(v7, v14) - __PAIR__(HIDWORD(v8), v9)) >> 32 << (32 - (unsigned __int8)v11)) | ((v14 - v9) >> v11);
      }
      else
      {
        if ( (unsigned int)a2 <= (unsigned int)a1 || HIDWORD(a2) < HIDWORD(a1) )
          LODWORD(v13) = a1 - a2;
        result = v13;
      }
    }
  }
  else
  {
    if ( (unsigned int)a2 <= HIDWORD(a1) )
    {
      v4 = a2;
      if ( !(_DWORD)a2 )
        v4 = 1 / 0u;
      LODWORD(v5) = a1;
      HIDWORD(v5) = HIDWORD(a1) % v4;
      v2 = v5 % v4;
    }
    else
    {
      v2 = a1 % (unsigned int)a2;
    }
    result = v2;
  }
  return result;
}

//----- (080538AC) --------------------------------------------------------
int __cdecl sub_80538AC(int a1)
{
  return __cxa_atexit(a1, 0, dword_80591E4);
}
// 8048EB0: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 80591E4: using guessed type int dword_80591E4;

//----- (08054070) --------------------------------------------------------
int (**sub_8054070())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_8058EC0;
  v1 = &off_8058EC4 - off_8058EC0;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_8058EC0[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 8058EC0: using guessed type int (*off_8058EC0[2])();
// 8058EC4: using guessed type int (*off_8058EC4)();

//----- (080540D4) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 3 decompilation failure(s) on 146 function(s)"
