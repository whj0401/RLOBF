/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8048CF0();
// int strcmp(const char *s1, const char *s2);
// int __cdecl open64(_DWORD, _DWORD); weak
// int __cdecl getline(_DWORD, _DWORD, _DWORD); weak
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void _exit(int status);
// void free(void *ptr);
// void *memcpy(void *dest, const void *src, size_t n);
// int fclose(FILE *stream);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// char *textdomain(const char *domainname);
// int __cdecl fopen64(_DWORD, _DWORD); weak
// int ferror_unlocked(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// size_t __ctype_get_mb_cur_max(void);
// size_t __fpending(FILE *fp);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// void error(int status, int errnum, const char *format, ...);
// size_t fread_unlocked(void *ptr, size_t size, size_t n, FILE *stream);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// char *strchr(const char *s, int c);
// size_t strlen(const char *s);
// int fprintf(FILE *stream, const char *format, ...);
// int fcntl(int fd, int cmd, ...);
// int setvbuf(FILE *stream, char *buf, int modes, size_t n);
// void *memset(void *s, int c, size_t n);
// int *__errno_location(void);
// int fileno(FILE *stream);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// char *strrchr(const char *s, int c);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// char *bindtextdomain(const char *domainname, const char *dirname);
// int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// int feof_unlocked(FILE *stream);
// void abort(void);
// char *ngettext(const char *msgid1, const char *msgid2, unsigned int n);
// int close(int fd);
// const unsigned __int16 **__ctype_b_loc(void);
// int putchar_unlocked(int c);
// int _gmon_start__(void); weak
void sub_8049123();
void sub_8049140();
int sub_8049150();
int sub_80491C0();
int sub_80491E0();
void sub_804923F();
void sub_804925A();
int sub_804926A();
void sub_804934C();
void sub_8049367();
signed int sub_8049377();
int nullsub_3(void); // weak
int sub_80493D5();
void sub_8049475();
void sub_8049490();
int sub_80494A0();
int sub_804952A();
void sub_804959E();
void sub_80495B9();
int __fastcall sub_80495C9(int a1);
void sub_80496E0();
void sub_80496FB();
int sub_804970B();
void sub_80497ED();
void sub_8049808();
int sub_8049818();
void sub_8049916();
void sub_8049931();
int sub_8049941();
void sub_8049A23();
void sub_8049A3E();
int __fastcall sub_8049A4E(int a1);
void sub_8049B49();
void sub_8049B64();
int sub_8049B74();
int sub_8049BFE();
void sub_8049C72();
void sub_8049C8D();
int sub_8049C9D();
void sub_8049D7F();
void sub_8049D9A();
int sub_8049DAA();
void sub_8049ED9();
void sub_8049EF4();
int sub_8049F04();
// int __usercall sub_8049F74@<eax>(int a1@<eax>, int (__cdecl *a2)(int *, int)@<edx>);
void sub_804A048();
void sub_804A063();
int sub_804A073();
int __cdecl sub_804A123(int a1, unsigned int a2);
unsigned int __cdecl sub_804A169(int a1, unsigned int a2);
int sub_804A19B();
// int __usercall sub_804A1C6@<eax>(signed __int32 a1@<edx>, int a2@<ecx>, char *s1);
int __cdecl sub_804A37F(int a1);
void __cdecl __noreturn sub_804A387(int status); // idb
// signed __int32 __usercall sub_804A4F7@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, signed __int32 a3, unsigned int a4);
// signed __int32 __usercall sub_804A5FD@<eax>(signed __int32 a1@<edx>, int a2@<ecx>, signed __int32 a3@<ebx>, unsigned __int8 *a4);
// int __usercall sub_804A725@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, signed __int32 a3, int a4, int a5, signed __int32 *a6, char a7);
int __cdecl sub_804A854(signed __int32 a1, int a2, int a3, _DWORD *a4, signed __int32 *a5);
// int __usercall sub_804ACF4@<eax>(int a1@<edx>, int a2@<ecx>, signed __int32 a3@<ebx>, char *a4, char a5);
// int __usercall sub_804AEFC@<eax>(signed __int32 a1@<ebx>, char *s1, int a3, size_t a4, int a5);
// int __usercall sub_804B168@<eax>(_BYTE *a1@<ebx>, const char *a2);
// int __usercall main@<eax>(signed __int32 a1@<ebx>, int argc, char **a3);
int sub_804C28D(); // weak
int __cdecl sub_804C7FA(unsigned __int8 a1);
int sub_804C811();
_DWORD *__cdecl sub_804C8F5(_DWORD *a1);
_DWORD *__cdecl sub_804C9AE(_DWORD *a1);
int __cdecl sub_804CA67(_DWORD *a1, int a2, int a3);
int __cdecl sub_804CA89(int a1, int a2);
int __cdecl sub_804CCBC(int a1, int a2);
int __cdecl sub_804CF6E(int a1);
int __cdecl sub_804D6B1(int a1, int a2);
int __cdecl sub_804D6D6(int a1, int a2);
// int __usercall sub_804D6FB@<eax>(signed __int32 a1@<ebx>, FILE *stream, size_t a3, int a4);
int __cdecl sub_804DAC5(void *src, size_t, int); // idb
_DWORD __cdecl sub_804DD9A(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_80625F6(int a1, int a2, int a3, int a4, int a5, int a6);
void __cdecl sub_8062647(FILE *stream, int a2);
FILE *__cdecl sub_806275C(int a1, char *modes);
char *__cdecl sub_806284A(char *s);
int __cdecl sub_80629CA(int *a1, unsigned __int8 a2, char a3);
int *__cdecl sub_8062A74(int *a1, int a2, int a3);
// _DWORD *__userpurge sub_8062AB5@<eax>(_DWORD *a1, int a2);
// void *__usercall sub_8062B37@<eax>(signed __int32 a1@<ebx>, char *msgid, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10);
// int __usercall sub_8062C88@<eax>(unsigned __int32 a1@<ebx>, _BYTE *a2, unsigned int a3, const char *a4, unsigned int a5, int a6, int a7, int a8, char *a9, const char *a10);
_BYTE *__cdecl sub_8063E1D(const char *a1, unsigned int a2, _DWORD *a3, int *a4);
_BYTE *__cdecl sub_8063FC4(signed int a1, const char *a2, unsigned int a3, int a4);
_BYTE *__cdecl sub_8064206(signed int a1, const char *a2);
_BYTE *__cdecl sub_8064230(signed int a1, const char *a2, unsigned int a3);
_BYTE *__cdecl sub_80642C6(signed int a1, int a2, const char *a3);
_BYTE *__cdecl sub_8064304(signed int a1, int a2, const char *a3, unsigned int a4);
_BYTE *__cdecl sub_8064434(const char *a1, unsigned int a2, unsigned __int8 a3);
_BYTE *__cdecl sub_80644DE(const char *a1, unsigned __int8 a2);
_BYTE *__cdecl sub_8064507(const char *a1);
_BYTE *__cdecl sub_8064544(signed int a1, int a2, const char *a3);
_BYTE *__cdecl sub_80645E5(signed int a1, int a2, int a3, const char *a4);
_BYTE *__cdecl sub_8064615(signed int a1, int a2, int a3, const char *a4, unsigned int a5);
_BYTE *__cdecl sub_806470F(signed int a1, const char *a2, unsigned int a3);
_BYTE *__cdecl sub_806475A(signed int a1, const char *a2);
int __cdecl sub_8064797(int fd); // idb
// int __usercall sub_80647BA@<eax>(signed __int32 a1@<ebx>, FILE *stream, int a3, int a4, int a5, int a6, int a7);
// int __usercall sub_8064D54@<eax>(signed __int32 a1@<edx>, int a2@<ecx>, signed __int32 a3@<ebx>);
// int __usercall sub_8064ECF@<eax>(signed __int32 a1@<edx>, int a2@<ecx>, signed __int32 a3@<ebx>);
void *__cdecl sub_8065038(void *ptr, int a2, int a3);
void *__cdecl sub_8065171(size_t size);
void *__cdecl sub_8065184(size_t size);
void *__cdecl sub_80651AE(void *ptr, size_t size);
void *__cdecl sub_806531B(void *src, size_t n);
void __noreturn sub_8065369();
int __cdecl sub_80653A2(FILE *stream); // idb
int __cdecl sub_806547E(int fd, int cmd, char); // idb
int __cdecl sub_80655E8(FILE *stream); // idb
int __cdecl sub_8065621(FILE *fp); // idb
int __cdecl sub_8065661(FILE *stream, int, int, int); // idb
size_t __cdecl sub_8065748(wchar_t *pwc, char *s, size_t n, mbstate_t *p);
int __cdecl sub_80657C2(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_8065855(FILE *fp); // idb
int __cdecl sub_80658D6(int category); // idb
void *sub_8065934();
const char *sub_8065F31();
int __cdecl sub_80661A6(int a1);
__int64 __cdecl sub_8066255(int a1, unsigned int a2, unsigned int a3, int a4);
int __cdecl sub_806644A(int a1);
int __fastcall sub_8066552(_DWORD); // weak
int __fastcall sub_80665CD(_DWORD, _DWORD); // weak
int sub_8066751(void); // weak
int __fastcall sub_80667D6(_DWORD, _DWORD); // weak
int __fastcall sub_8066852(_DWORD, _DWORD); // weak
int __fastcall sub_80668ED(_DWORD); // weak
int __fastcall sub_806696A(_DWORD); // weak
int __fastcall sub_80669F3(_DWORD); // weak
int __fastcall sub_8066A70(_DWORD, _DWORD, _DWORD); // weak
int (**sub_8066A90())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN locret_80495D8; // weak
_UNKNOWN locret_8049A5D; // weak
_UNKNOWN loc_804A274; // weak
_UNKNOWN locret_804A5FB; // weak
_UNKNOWN loc_804A66F; // weak
_UNKNOWN loc_804A67F; // weak
_UNKNOWN locret_804A723; // weak
_UNKNOWN loc_804A809; // weak
_UNKNOWN loc_804A810; // weak
_UNKNOWN loc_804A8E4; // weak
_UNKNOWN loc_804A99B; // weak
_UNKNOWN loc_804AD24; // weak
_UNKNOWN loc_804AD6E; // weak
_UNKNOWN loc_804AE38; // weak
_UNKNOWN loc_804AED3; // weak
_UNKNOWN loc_804AED7; // weak
_UNKNOWN locret_804AEFA; // weak
_UNKNOWN loc_804B116; // weak
_UNKNOWN loc_804B15D; // weak
_UNKNOWN loc_804B370; // weak
_UNKNOWN loc_804B42E; // weak
_UNKNOWN loc_804B4E0; // weak
_UNKNOWN loc_804B581; // weak
_UNKNOWN loc_804B5EA; // weak
_UNKNOWN loc_804B7AF; // weak
_UNKNOWN loc_804B7D7; // weak
_UNKNOWN loc_804B90D; // weak
_UNKNOWN loc_804B98C; // weak
_UNKNOWN loc_804B9B3; // weak
_UNKNOWN loc_804BA38; // weak
_UNKNOWN loc_804BBC5; // weak
_UNKNOWN loc_804BD39; // weak
_UNKNOWN loc_804BD57; // weak
_UNKNOWN loc_804BDA2; // weak
_UNKNOWN loc_804BDE4; // weak
_UNKNOWN loc_804BE04; // weak
_UNKNOWN loc_804BE41; // weak
_UNKNOWN loc_804BE5C; // weak
_UNKNOWN loc_804BEB4; // weak
_UNKNOWN loc_804BFF5; // weak
_UNKNOWN loc_804C001; // weak
_UNKNOWN loc_804C10B; // weak
_UNKNOWN loc_804C13B; // weak
_UNKNOWN loc_804C2C9; // weak
_UNKNOWN sub_804C79C; // weak
_UNKNOWN loc_804D741; // weak
_UNKNOWN loc_804D7C7; // weak
_UNKNOWN locret_8062663; // weak
_UNKNOWN locret_8062BC9; // weak
_UNKNOWN loc_8062BF6; // weak
_UNKNOWN loc_8062E80; // weak
_UNKNOWN loc_8063006; // weak
_UNKNOWN loc_8063034; // weak
_UNKNOWN loc_806306F; // weak
_UNKNOWN loc_8063079; // weak
_UNKNOWN loc_8063102; // weak
_UNKNOWN loc_80631A6; // weak
_UNKNOWN loc_8063248; // weak
_UNKNOWN loc_806324D; // weak
_UNKNOWN loc_806327A; // weak
_UNKNOWN loc_8063350; // weak
_UNKNOWN loc_8063360; // weak
_UNKNOWN loc_80633A4; // weak
_UNKNOWN loc_80633A9; // weak
_UNKNOWN loc_806341A; // weak
_UNKNOWN loc_806342D; // weak
_UNKNOWN loc_806352F; // weak
_UNKNOWN loc_806355D; // weak
_UNKNOWN loc_8063976; // weak
_UNKNOWN loc_80639AB; // weak
_UNKNOWN loc_80639DD; // weak
_UNKNOWN loc_8063AD1; // weak
_UNKNOWN loc_8063B56; // weak
_UNKNOWN loc_8063B88; // weak
_UNKNOWN loc_8063C37; // weak
_UNKNOWN loc_8063C80; // weak
_UNKNOWN loc_806403E; // weak
_UNKNOWN loc_8064045; // weak
_UNKNOWN loc_8064849; // weak
_UNKNOWN loc_8064D9C; // weak
_UNKNOWN loc_806543B; // weak
_UNKNOWN loc_8065454; // weak
_UNKNOWN loc_806569C; // weak
_UNKNOWN loc_8065726; // weak
_UNKNOWN loc_8065A13; // weak
_UNKNOWN loc_8065A4D; // weak
_UNKNOWN loc_8065A52; // weak
_UNKNOWN loc_8065B91; // weak
_UNKNOWN loc_8065BAE; // weak
_UNKNOWN loc_806629F; // weak
_UNKNOWN loc_80662B6; // weak
_UNKNOWN loc_806630D; // weak
_UNKNOWN loc_8066318; // weak
char locale = '\0'; // idb
struct option longopts = { "binary", 0, NULL, 98 }; // idb
_UNKNOWN unk_8067790; // weak
_UNKNOWN unk_8067BBE; // weak
_UNKNOWN unk_8067BC2; // weak
_UNKNOWN unk_8067BD5; // weak
char aWrittenBySSSS[28] = "Written by %s, %s, %s,\n%s, %"; // idb
_UNKNOWN unk_80682F3; // weak
_UNKNOWN unk_80691C8; // weak
_UNKNOWN unk_80691CB; // weak
_UNKNOWN unk_806A1FC; // weak
_UNKNOWN unk_806A1FF; // weak
int (*off_806BED4[2])() = { &sub_80491E0, &sub_80491C0 }; // weak
int (*off_806BED8)() = &sub_80491C0; // weak
int (*dword_806C008)(void) = NULL; // weak
int dword_806C110 = 0; // weak
int dword_806C124 = 0; // weak
int dword_806C128 = 0; // weak
int dword_806C138 = 0; // weak
int dword_806C13C = 0; // weak
int dword_806C14C = 0; // weak
int dword_806C150 = 0; // weak
int dword_806C160 = 0; // weak
int dword_806C164 = 0; // weak
int dword_806C174 = 0; // weak
int dword_806C178 = 0; // weak
int dword_806C188 = 0; // weak
int dword_806C1A4 = 0; // weak
int (__fastcall *dword_806C1A8)(_DWORD) = NULL; // weak
int dword_806C1AC = 0; // weak
int dword_806C1BC = 0; // weak
int dword_806C1C0 = 0; // weak
int dword_806C1D0 = 0; // weak
int dword_806C1D4 = 0; // weak
int dword_806C1E0 = 0; // weak
int dword_806C1F4 = 0; // weak
int off_806C1FC = 134641525; // idb
int status = 1; // idb
int dword_806C210 = 1; // weak
int dword_806C214 = 256; // weak
void *off_806C218 = &unk_806C6D5; // weak
int *off_806C21C = &dword_806C214; // weak
_UNKNOWN unk_806C230; // weak
_UNKNOWN unk_806C24C; // weak
_UNKNOWN unk_806C24F; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int program_invocation_name; // weak
int stdin; // weak
FILE *stdout; // idb
char byte_806C2A8; // weak
char byte_806C383; // weak
char byte_806C539; // weak
_UNKNOWN unk_806C53D; // weak
_UNKNOWN unk_806C5CF; // weak
_UNKNOWN unk_806C5DF; // weak
char byte_806C661; // weak
int dword_806C665; // weak
int dword_806C669; // weak
char byte_806C66D; // weak
char byte_806C66E; // weak
char byte_806C66F; // weak
char byte_806C670; // weak
char byte_806C671; // weak
int dword_806C675; // weak
char byte_806C679; // weak
int dword_806C67D; // weak
int dword_806C695; // weak
int dword_806C699; // weak
int dword_806C69D; // weak
int dword_806C6A1; // weak
int dword_806C6A5; // weak
int dword_806C6A9; // weak
int dword_806C6AD; // weak
int dword_806C6B1; // weak
int dword_806C6B5; // weak
int dword_806C6B9; // weak
int dword_806C6BD; // weak
int dword_806C6C1; // weak
_UNKNOWN unk_806C6D5; // weak
int dword_806C7D5; // weak
int dword_806C7D9; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (08048CCC) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 80490E0: using guessed type int _gmon_start__(void);

//----- (08048CF0) --------------------------------------------------------
int sub_8048CF0()
{
  return dword_806C008();
}
// 806C008: using guessed type int (*dword_806C008)(void);

//----- (080490F0) --------------------------------------------------------
#error "80490F3: positive sp value has been found (funcsize=2)"

//----- (08049123) --------------------------------------------------------
void sub_8049123()
{
  ;
}

//----- (08049140) --------------------------------------------------------
void sub_8049140()
{
  ;
}

//----- (08049150) --------------------------------------------------------
int sub_8049150()
{
  int result; // eax

  result = 134660707 - (_DWORD)&program_invocation_short_name;
  if ( (unsigned int)(134660707 - (_DWORD)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 8049150: could not find valid save-restore pair for ebp
// 806C260: using guessed type int program_invocation_short_name;

//----- (080491C0) --------------------------------------------------------
int sub_80491C0()
{
  int result; // eax

  if ( !byte_806C2A8 )
  {
    result = sub_8049150();
    byte_806C2A8 = 1;
  }
  return result;
}
// 80491C0: could not find valid save-restore pair for ebp
// 806C2A8: using guessed type char byte_806C2A8;

//----- (080491E0) --------------------------------------------------------
int sub_80491E0()
{
  return 0;
}
// 80491E0: could not find valid save-restore pair for ebp

//----- (0804923F) --------------------------------------------------------
void sub_804923F()
{
  ;
}

//----- (0804925A) --------------------------------------------------------
void sub_804925A()
{
  ;
}

//----- (0804926A) --------------------------------------------------------
int sub_804926A()
{
  int result; // eax

  result = &unk_806C24F - &unk_806C24C;
  if ( (unsigned int)(&unk_806C24F - &unk_806C24C) > 6 )
    result = 0;
  return result;
}
// 804926A: could not find valid save-restore pair for ebp

//----- (0804934C) --------------------------------------------------------
void sub_804934C()
{
  ;
}

//----- (08049367) --------------------------------------------------------
void sub_8049367()
{
  ;
}

//----- (08049377) --------------------------------------------------------
signed int sub_8049377()
{
  return 3;
}
// 8049377: could not find valid save-restore pair for ebp

//----- (080493D5) --------------------------------------------------------
int sub_80493D5()
{
  return nullsub_3();
}
// 80493D5: could not find valid save-restore pair for ebp
// 80493D4: using guessed type int nullsub_3(void);

//----- (08049475) --------------------------------------------------------
void sub_8049475()
{
  ;
}

//----- (08049490) --------------------------------------------------------
void sub_8049490()
{
  ;
}

//----- (080494A0) --------------------------------------------------------
int sub_80494A0()
{
  int result; // eax

  result = &unk_806C24F - &unk_806C24C;
  if ( (unsigned int)(&unk_806C24F - &unk_806C24C) > 6 )
    result = 0;
  return result;
}
// 80494A0: could not find valid save-restore pair for ebp

//----- (0804952A) --------------------------------------------------------
int sub_804952A()
{
  int result; // eax

  result = sub_80494A0();
  byte_806C383 = 1;
  return result;
}
// 806C383: using guessed type char byte_806C383;

//----- (0804959E) --------------------------------------------------------
void sub_804959E()
{
  ;
}

//----- (080495B9) --------------------------------------------------------
void sub_80495B9()
{
  ;
}

//----- (080495C9) --------------------------------------------------------
int __fastcall sub_80495C9(int a1)
{
  int result; // eax
  int (__stdcall *v2)(void *, int, int, int, int, int); // eax
  int v3; // [esp+4h] [ebp-18h]
  int v4; // [esp+8h] [ebp-14h]
  int v5; // [esp+Ch] [ebp-10h]
  int v6; // [esp+10h] [ebp-Ch]
  int v7; // [esp+14h] [ebp-8h]
  int v8; // [esp+18h] [ebp-4h]

  result = &unk_806C24F - &unk_806C24C;
  if ( (unsigned int)(&unk_806C24F - &unk_806C24C) > 6 )
  {
    v8 = 0;
    dword_806C14C = (int)&locret_80495D8;
    v2 = (int (__stdcall *)(void *, int, int, int, int, int))sub_80668ED(a1);
    result = v2(&unk_806C24C, v3, v4, v5, v6, v7);
  }
  return result;
}
// 80668ED: using guessed type int __fastcall sub_80668ED(_DWORD);
// 806C14C: using guessed type int dword_806C14C;

//----- (080496E0) --------------------------------------------------------
void sub_80496E0()
{
  ;
}

//----- (080496FB) --------------------------------------------------------
void sub_80496FB()
{
  ;
}

//----- (0804970B) --------------------------------------------------------
int sub_804970B()
{
  int result; // eax

  result = &unk_806A1FF - &unk_806A1FC;
  if ( (unsigned int)(&unk_806A1FF - &unk_806A1FC) > 6 )
    result = 0;
  return result;
}
// 804970B: could not find valid save-restore pair for ebp

//----- (080497ED) --------------------------------------------------------
void sub_80497ED()
{
  ;
}

//----- (08049808) --------------------------------------------------------
void sub_8049808()
{
  ;
}

//----- (08049818) --------------------------------------------------------
int sub_8049818()
{
  int result; // eax

  result = &unk_806C24F - &unk_806C24C;
  if ( (unsigned int)(&unk_806C24F - &unk_806C24C) > 6 )
    result = 0;
  return result;
}
// 8049818: could not find valid save-restore pair for ebp

//----- (08049916) --------------------------------------------------------
void sub_8049916()
{
  ;
}

//----- (08049931) --------------------------------------------------------
void sub_8049931()
{
  ;
}

//----- (08049941) --------------------------------------------------------
int sub_8049941()
{
  int result; // eax

  result = &unk_806C24F - &unk_806C24C;
  if ( (unsigned int)(&unk_806C24F - &unk_806C24C) > 6 )
    result = 0;
  return result;
}
// 8049941: could not find valid save-restore pair for ebp

//----- (08049A23) --------------------------------------------------------
void sub_8049A23()
{
  ;
}

//----- (08049A3E) --------------------------------------------------------
void sub_8049A3E()
{
  ;
}

//----- (08049A4E) --------------------------------------------------------
int __fastcall sub_8049A4E(int a1)
{
  int result; // eax
  int (__stdcall *v2)(void *, int, int, int, int, int); // eax
  int v3; // [esp+4h] [ebp-18h]
  int v4; // [esp+8h] [ebp-14h]
  int v5; // [esp+Ch] [ebp-10h]
  int v6; // [esp+10h] [ebp-Ch]
  int v7; // [esp+14h] [ebp-8h]
  int v8; // [esp+18h] [ebp-4h]

  result = &unk_80691CB - &unk_80691C8;
  if ( (unsigned int)(&unk_80691CB - &unk_80691C8) > 6 )
  {
    v8 = 0;
    dword_806C138 = (int)&locret_8049A5D;
    v2 = (int (__stdcall *)(void *, int, int, int, int, int))sub_806696A(a1);
    result = v2(&unk_80691C8, v3, v4, v5, v6, v7);
  }
  return result;
}
// 806696A: using guessed type int __fastcall sub_806696A(_DWORD);
// 806C138: using guessed type int dword_806C138;

//----- (08049B49) --------------------------------------------------------
void sub_8049B49()
{
  ;
}

//----- (08049B64) --------------------------------------------------------
void sub_8049B64()
{
  ;
}

//----- (08049B74) --------------------------------------------------------
int sub_8049B74()
{
  int result; // eax

  result = &unk_806C24F - &unk_806C24C;
  if ( (unsigned int)(&unk_806C24F - &unk_806C24C) > 6 )
    result = 0;
  return result;
}
// 8049B74: could not find valid save-restore pair for ebp

//----- (08049BFE) --------------------------------------------------------
int sub_8049BFE()
{
  int result; // eax

  result = sub_8049B74();
  byte_806C539 = 1;
  return result;
}
// 806C539: using guessed type char byte_806C539;

//----- (08049C72) --------------------------------------------------------
void sub_8049C72()
{
  ;
}

//----- (08049C8D) --------------------------------------------------------
void sub_8049C8D()
{
  ;
}

//----- (08049C9D) --------------------------------------------------------
int sub_8049C9D()
{
  int result; // eax

  result = &unk_806C53D - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_806C53D - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 8049C9D: could not find valid save-restore pair for ebp
// 806C260: using guessed type int program_invocation_short_name;

//----- (08049D7F) --------------------------------------------------------
void sub_8049D7F()
{
  ;
}

//----- (08049D9A) --------------------------------------------------------
void sub_8049D9A()
{
  ;
}

//----- (08049DAA) --------------------------------------------------------
int sub_8049DAA()
{
  int result; // eax

  result = &unk_806C24F - &unk_806C24C;
  if ( (unsigned int)(&unk_806C24F - &unk_806C24C) > 6 )
    result = 0;
  return result;
}
// 8049DAA: could not find valid save-restore pair for ebp

//----- (08049ED9) --------------------------------------------------------
void sub_8049ED9()
{
  ;
}

//----- (08049EF4) --------------------------------------------------------
void sub_8049EF4()
{
  ;
}

//----- (08049F04) --------------------------------------------------------
int sub_8049F04()
{
  int result; // eax

  result = &unk_806C5CF - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_806C5CF - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 8049F04: could not find valid save-restore pair for ebp
// 806C260: using guessed type int program_invocation_short_name;

//----- (08049F74) --------------------------------------------------------
int __usercall sub_8049F74@<eax>(int a1@<eax>, int (__cdecl *a2)(int *, int)@<edx>)
{
  return a2(&program_invocation_short_name, a1);
}
// 806C260: using guessed type int program_invocation_short_name;

//----- (0804A048) --------------------------------------------------------
void sub_804A048()
{
  ;
}

//----- (0804A063) --------------------------------------------------------
void sub_804A063()
{
  ;
}

//----- (0804A073) --------------------------------------------------------
int sub_804A073()
{
  int result; // eax

  result = &unk_806C5DF - (_UNKNOWN *)&program_invocation_name;
  if ( (unsigned int)(&unk_806C5DF - (_UNKNOWN *)&program_invocation_name) > 6 )
    result = 0;
  return result;
}
// 804A073: could not find valid save-restore pair for ebp
// 806C270: using guessed type int program_invocation_name;

//----- (0804A123) --------------------------------------------------------
int __cdecl sub_804A123(int a1, unsigned int a2)
{
  int result; // eax

  if ( a2 )
    result = (unsigned __int64)sub_8066255(a1, a2, 0xF4240u, 0) + 1000000;
  else
    result = a1;
  return result;
}

//----- (0804A169) --------------------------------------------------------
unsigned int __cdecl sub_804A169(int a1, unsigned int a2)
{
  return a2 - 1 + a1 - (a2 - 1 + a1) % a2;
}

//----- (0804A19B) --------------------------------------------------------
int sub_804A19B()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nWith no FILE, or when FILE is -, read standard input.\n");
  return fputs_unlocked(v1, v0);
}
// 8048F20: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804A1C6) --------------------------------------------------------
int __usercall sub_804A1C6@<eax>(signed __int32 a1@<edx>, int a2@<ecx>, char *s1)
{
  signed __int32 v3; // eax
  signed __int32 v4; // ecx
  signed __int32 v5; // et1
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // ebx
  char *v10; // eax
  char *v12; // [esp+1Ch] [ebp-4Ch]
  const char **v13; // [esp+20h] [ebp-48h]
  const char *v14; // [esp+24h] [ebp-44h]
  const char *v15; // [esp+28h] [ebp-40h]
  const char *v16; // [esp+2Ch] [ebp-3Ch]
  const char *v17; // [esp+30h] [ebp-38h]
  const char *v18; // [esp+34h] [ebp-34h]
  const char *v19; // [esp+38h] [ebp-30h]
  const char *v20; // [esp+3Ch] [ebp-2Ch]
  const char *v21; // [esp+40h] [ebp-28h]
  const char *v22; // [esp+44h] [ebp-24h]
  const char *v23; // [esp+48h] [ebp-20h]
  const char *v24; // [esp+4Ch] [ebp-1Ch]
  const char *v25; // [esp+50h] [ebp-18h]
  const char *v26; // [esp+54h] [ebp-14h]
  int v27; // [esp+58h] [ebp-10h]
  int v28; // [esp+5Ch] [ebp-Ch]

  v15 = "[";
  v16 = "test invocation";
  v17 = "coreutils";
  v18 = "Multi-call invocation";
  v19 = "sha224sum";
  v20 = "sha2 utilities";
  v21 = "sha256sum";
  v22 = "sha2 utilities";
  v23 = "sha384sum";
  v24 = "sha2 utilities";
  v25 = "sha512sum";
  v26 = "sha2 utilities";
  v27 = 0;
  v28 = 0;
  v12 = s1;
  v13 = &v15;
  dword_806C160 = (int)&loc_804A274;
  v3 = _InterlockedExchange(&dword_806C164, (signed __int32)&v15);
  _InterlockedExchange(&dword_806C164, a1);
  v5 = _InterlockedExchange(&dword_806C164, sub_8066852(a2, _InterlockedExchange(&dword_806C164, v3)));
  _InterlockedExchange(&dword_806C164, v4);
  _InterlockedExchange(&dword_806C164, v5);
  do
    v13 += 2;
  while ( *v13 && strcmp(s1, *v13) );
  if ( v13[1] )
    v12 = (char *)v13[1];
  v6 = gettext("\n%s online help: <%s>\n");
  printf(v6, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  v14 = setlocale(5, 0);
  if ( v14 && strncmp(v14, "en_", 3u) )
  {
    v7 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
    printf(v7, s1);
  }
  v8 = gettext("Full documentation at: <%s%s>\n");
  printf(v8, "http://www.gnu.org/software/coreutils/", s1);
  if ( v12 == s1 )
    v9 = " invocation";
  else
    v9 = &locale;
  v10 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  return printf(v10, v12, v9);
}
// 8066852: using guessed type int __fastcall sub_8066852(_DWORD, _DWORD);
// 806C160: using guessed type int dword_806C160;
// 806C164: using guessed type int dword_806C164;

//----- (0804A37F) --------------------------------------------------------
int __cdecl sub_804A37F(int a1)
{
  return a1;
}

//----- (0804A387) --------------------------------------------------------
void __cdecl __noreturn sub_804A387(int status)
{
  int v1; // ebx
  char *v2; // eax
  int v3; // ebx
  char *v4; // eax
  FILE *v5; // ebx
  char *v6; // eax
  char *v7; // eax
  FILE *v8; // ebx
  char *v9; // eax
  FILE *v10; // ebx
  char *v11; // eax
  FILE *v12; // ebx
  char *v13; // eax
  FILE *v14; // ebx
  char *v15; // eax
  FILE *v16; // ebx
  char *v17; // eax
  char *v18; // eax
  signed __int32 v19; // edx
  int v20; // ecx

  if ( status )
  {
    v1 = dword_806C67D;
    v2 = gettext("Try '%s --help' for more information.\n");
    fprintf(stderr, v2, v1);
  }
  else
  {
    v3 = dword_806C67D;
    v4 = gettext("Usage: %s [OPTION]... [FILE]...\nPrint or check %s (%d-bit) checksums.\n");
    printf(v4, v3, "SHA512", 512);
    sub_804A19B();
    v5 = stdout;
    v6 = gettext("\n  -b, --binary         read in binary mode\n");
    fputs_unlocked(v6, v5);
    v7 = gettext("  -c, --check          read %s sums from the FILEs and check them\n");
    printf(v7, "SHA512");
    v8 = stdout;
    v9 = gettext("      --tag            create a BSD-style checksum\n");
    fputs_unlocked(v9, v8);
    v10 = stdout;
    v11 = gettext("  -t, --text           read in text mode (default)\n");
    fputs_unlocked(v11, v10);
    v12 = stdout;
    v13 = gettext(
            "\n"
            "The following five options are useful only when verifying checksums:\n"
            "      --ignore-missing  don't fail or report status for missing files\n"
            "      --quiet          don't print OK for each successfully verified file\n"
            "      --status         don't output anything, status code shows success\n"
            "      --strict         exit non-zero for improperly formatted checksum lines\n"
            "  -w, --warn           warn about improperly formatted checksum lines\n"
            "\n");
    fputs_unlocked(v13, v12);
    v14 = stdout;
    v15 = gettext("      --help     display this help and exit\n");
    fputs_unlocked(v15, v14);
    v16 = stdout;
    v17 = gettext("      --version  output version information and exit\n");
    fputs_unlocked(v17, v16);
    v18 = gettext(
            "\n"
            "The sums are computed as described in %s.  When checking, the input\n"
            "should be a former output of this program.  The default mode is to print a\n"
            "line with checksum, a space, a character indicating input mode ('*' for binary,\n"
            "' ' for text or where binary is insignificant), and name for each FILE.\n");
    printf(v18, "FIPS-180-2");
    sub_804A1C6(v19, v20, "sha512sum");
  }
  exit(status);
}
// 8048F20: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 806C67D: using guessed type int dword_806C67D;

//----- (0804A4F7) --------------------------------------------------------
signed __int32 __usercall sub_804A4F7@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, signed __int32 a3, unsigned int a4)
{
  int v5; // eax
  _BYTE *v6; // eax
  _BYTE *v7; // eax
  signed __int32 v8; // edx
  signed __int32 v9; // edx
  signed __int32 v10; // et1
  _BYTE *v11; // eax
  _BYTE *v12; // [esp+8h] [ebp-8h]
  unsigned int i; // [esp+Ch] [ebp-4h]

  v12 = (_BYTE *)a3;
  for ( i = 0; i < a4; ++i )
  {
    if ( !*(_BYTE *)(a3 + i) )
      return 0;
    if ( *(_BYTE *)(a3 + i) == 92 )
    {
      if ( a4 - 1 == i )
        return 0;
      v5 = *(char *)(a3 + ++i);
      if ( v5 == 92 )
      {
        v7 = v12++;
        *v7 = 92;
      }
      else if ( v5 == 110 )
      {
        v6 = v12++;
        *v6 = 10;
      }
      else
      {
        dword_806C138 = (int)&locret_804A5FB;
        v8 = _InterlockedExchange(&dword_806C13C, a2);
        a2 = _InterlockedExchange(&dword_806C13C, a3);
        _InterlockedExchange(&dword_806C13C, v8);
        v10 = _InterlockedExchange(&dword_806C13C, sub_806696A(a1));
        _InterlockedExchange(&dword_806C13C, v9);
        _InterlockedExchange(&dword_806C13C, v10);
      }
    }
    else
    {
      v11 = v12++;
      a1 = a3;
      *v11 = *(_BYTE *)(a3 + i);
    }
  }
  if ( a3 + a4 > (unsigned int)v12 )
    *v12 = 0;
  return a3;
}
// 806696A: using guessed type int __fastcall sub_806696A(_DWORD);
// 806C138: using guessed type int dword_806C138;
// 806C13C: using guessed type int dword_806C13C;

//----- (0804A5FD) --------------------------------------------------------
signed __int32 __usercall sub_804A5FD@<eax>(signed __int32 a1@<edx>, int a2@<ecx>, signed __int32 a3@<ebx>, unsigned __int8 *a4)
{
  const unsigned __int16 **v4; // eax
  signed __int32 v5; // ecx
  signed __int32 v6; // edx
  int v7; // eax
  signed __int32 v8; // eax
  signed __int32 v9; // ecx
  signed __int32 v10; // et1
  signed __int32 v11; // eax
  signed __int32 v12; // ebx
  signed __int32 v13; // ecx
  signed __int32 v14; // ecx
  signed __int32 v15; // ett
  signed __int32 v16; // eax
  signed __int32 v17; // edx
  signed __int32 v18; // et1
  signed __int32 v19; // eax
  signed __int32 v20; // ebx
  signed __int32 result; // eax
  signed __int32 v22; // et2
  signed __int32 v23; // ecx

  if ( (unsigned int)dword_806C669 > 0 )
  {
    v4 = __ctype_b_loc();
    v6 = (signed __int32)*v4;
    v7 = (*v4)[*a4] & 0x1000;
    if ( !v7 )
    {
      dword_806C160 = (int)&locret_804A723;
      v8 = _InterlockedExchange(&dword_806C164, 0);
      _InterlockedExchange(&dword_806C164, v5);
      v10 = _InterlockedExchange(&dword_806C164, sub_8066852(_InterlockedExchange(&dword_806C164, v8), v6));
      v7 = _InterlockedExchange(&dword_806C164, v9);
      v5 = _InterlockedExchange(&dword_806C164, v10);
    }
  }
  else
  {
    dword_806C14C = (int)&loc_804A66F;
    v11 = _InterlockedExchange(&dword_806C150, dword_806C669);
    _InterlockedExchange(&dword_806C150, a1);
    _InterlockedExchange(&dword_806C150, v11);
    v7 = sub_80668ED(a2);
    v12 = _InterlockedExchange(&dword_806C150, a3);
    v15 = _InterlockedExchange(&dword_806C150, v13);
    v14 = v12;
    a3 = v15;
    v5 = _InterlockedExchange(&dword_806C150, v14);
  }
  dword_806C1BC = (int)&loc_804A67F;
  v16 = _InterlockedExchange(&dword_806C1C0, v7);
  _InterlockedExchange(&dword_806C1C0, v6);
  v18 = _InterlockedExchange(&dword_806C1C0, sub_80665CD(v5, _InterlockedExchange(&dword_806C1C0, v16)));
  v19 = _InterlockedExchange(&dword_806C1E0, _InterlockedExchange(&dword_806C1C0, v17));
  v20 = _InterlockedExchange(&dword_806C1E0, a3);
  v22 = v19;
  result = _InterlockedExchange(&dword_806C1E0, _InterlockedExchange(&dword_806C1C0, v18));
  _InterlockedExchange(&dword_806C1E0, v22);
  _InterlockedExchange(&dword_806C1E0, v23);
  _InterlockedExchange(&dword_806C1E0, v20);
  return result;
}
// 80665CD: using guessed type int __fastcall sub_80665CD(_DWORD, _DWORD);
// 8066852: using guessed type int __fastcall sub_8066852(_DWORD, _DWORD);
// 80668ED: using guessed type int __fastcall sub_80668ED(_DWORD);
// 806C14C: using guessed type int dword_806C14C;
// 806C150: using guessed type int dword_806C150;
// 806C160: using guessed type int dword_806C160;
// 806C164: using guessed type int dword_806C164;
// 806C1BC: using guessed type int dword_806C1BC;
// 806C1C0: using guessed type int dword_806C1C0;
// 806C1E0: using guessed type int dword_806C1E0;
// 806C669: using guessed type int dword_806C669;

//----- (0804A725) --------------------------------------------------------
int __usercall sub_804A725@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, signed __int32 a3, int a4, int a5, signed __int32 *a6, char a7)
{
  unsigned int v8; // eax
  void *v9; // eax
  unsigned int i; // [esp+1Ch] [ebp-Ch]
  int v11; // [esp+1Ch] [ebp-Ch]

  if ( !a4 )
    return 0;
  for ( i = a4 - 1; i && *(_BYTE *)(a3 + i) != 41; --i )
    ;
  if ( *(_BYTE *)(a3 + i) != 41 )
    return 0;
  *a6 = a3;
  if ( a7 && !sub_804A4F7(a1, a2, a3, i) )
    return 0;
  v8 = i;
  v11 = i + 1;
  *(_BYTE *)(a3 + v8) = 0;
  while ( *(_BYTE *)(a3 + v11) == 32 || *(_BYTE *)(a3 + v11) == 9 )
    ++v11;
  v9 = &loc_804A809;
  if ( *(_BYTE *)(a3 + v11) == 61 )
    v9 = &loc_804A810;
  dword_806C160 = (int)v9;
  sub_8066852(a1, a3);
  return 0;
}
// 8066852: using guessed type int __fastcall sub_8066852(_DWORD, _DWORD);
// 806C160: using guessed type int dword_806C160;

//----- (0804A854) --------------------------------------------------------
int __cdecl sub_804A854(signed __int32 a1, int a2, int a3, _DWORD *a4, signed __int32 *a5)
{
  bool v5; // zf
  int v6; // edx
  int v7; // ecx
  void *v8; // eax
  int v10; // [esp+0h] [ebp-38h]
  char v11; // [esp+27h] [ebp-11h]
  int i; // [esp+28h] [ebp-10h]
  int v13; // [esp+28h] [ebp-10h]

  v11 = 0;
  for ( i = 0; *(_BYTE *)(a1 + i) == 32 || *(_BYTE *)(a1 + i) == 9; ++i )
    ;
  if ( *(_BYTE *)(a1 + i) == 92 )
  {
    ++i;
    v11 = 1;
  }
  v5 = strncmp((const char *)(i + a1), "SHA512", 6u) == 0;
  v8 = &loc_804A8E4;
  if ( !v5 )
    v8 = &loc_804A99B;
  dword_806C110 = (int)v8;
  sub_8066A70(v7, v6, v10);
  v13 = i + 6;
  if ( *(_BYTE *)(a1 + v13) == 32 )
    ++v13;
  if ( *(_BYTE *)(a1 + v13) != 40 )
    return 0;
  *a4 = 0;
  return sub_804A725(a2 - (v13 + 1), a1, a1 + v13 + 1, a2 - (v13 + 1), a3, a5, v11);
}
// 8066A70: using guessed type int __fastcall sub_8066A70(_DWORD, _DWORD, _DWORD);
// 806C110: using guessed type int dword_806C110;

//----- (0804ACF4) --------------------------------------------------------
int __usercall sub_804ACF4@<eax>(int a1@<edx>, int a2@<ecx>, signed __int32 a3@<ebx>, char *a4, char a5)
{
  void *v5; // eax
  signed __int32 v6; // ebx
  signed __int32 v7; // edx
  signed __int32 v8; // edx
  signed __int32 v9; // ebx
  signed __int32 v10; // et0
  int v11; // ecx
  signed __int32 v12; // edx
  signed __int32 v13; // ecx
  signed __int32 v14; // et1
  int v15; // eax
  signed __int32 v16; // ebx
  signed __int32 v17; // et2
  signed __int32 v18; // ecx
  signed __int32 v19; // ebx
  int result; // eax
  signed __int32 v21; // ebx
  signed __int32 v22; // edx
  signed __int32 v23; // et0
  int v24; // ecx
  signed __int32 v25; // ebx
  signed __int32 v26; // edx
  signed __int32 v27; // edx
  signed __int32 v28; // et1

  v5 = &loc_804AD24;
  if ( a5 == 1 )
    v5 = &loc_804AD6E;
  dword_806C174 = (int)v5;
  sub_80667D6(a2, a1);
  fputs_unlocked(a4, stdout);
  dword_806C1D0 = (int)&locret_804AEFA;
  v6 = _InterlockedExchange(&dword_806C1D4, a3);
  v10 = _InterlockedExchange(&dword_806C1D4, v7);
  v8 = v6;
  v9 = v10;
  _InterlockedExchange(&dword_806C1D4, v8);
  v14 = _InterlockedExchange(&dword_806C1D4, sub_8066552(v11));
  _InterlockedExchange(&dword_806C1D4, v12);
  _InterlockedExchange(&dword_806C1D4, v14);
  while ( 1 )
  {
    result = (unsigned __int8)*a4;
    if ( !(_BYTE)result )
      break;
    v15 = *a4;
    if ( v15 == 10 )
    {
      fwrite_unlocked("\\n", 1u, 2u, stdout);
      dword_806C14C = (int)&loc_804AED3;
      v21 = _InterlockedExchange(&dword_806C150, v9);
      v23 = _InterlockedExchange(&dword_806C150, v22);
      _InterlockedExchange(&dword_806C150, v21);
      sub_80668ED(v24);
      v25 = _InterlockedExchange(&dword_806C150, v23);
      v28 = _InterlockedExchange(&dword_806C150, v26);
      v27 = v25;
      v9 = v28;
      _InterlockedExchange(&dword_806C150, v27);
    }
    else
    {
      if ( v15 != 92 )
      {
        dword_806C1A8 = (int (__fastcall *)(_DWORD))&loc_804AED7;
        v16 = _InterlockedExchange(&dword_806C1AC, v9);
        v17 = _InterlockedExchange(&dword_806C1AC, v13);
        v18 = _InterlockedExchange(&dword_806C1AC, v16);
        dword_806C1A4 = (int)&loc_804AE38;
        v19 = _InterlockedExchange(&dword_806C1AC, v17);
        _InterlockedExchange(&dword_806C1AC, v18);
        return ((int (__fastcall *)(signed __int32))loc_804AED7)(_InterlockedExchange(&dword_806C1AC, v19));
      }
      fwrite_unlocked("\\\\", 1u, 2u, stdout);
    }
    ++a4;
  }
  return result;
}
// 8048F20: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8066552: using guessed type int __fastcall sub_8066552(_DWORD);
// 80667D6: using guessed type int __fastcall sub_80667D6(_DWORD, _DWORD);
// 80668ED: using guessed type int __fastcall sub_80668ED(_DWORD);
// 806C14C: using guessed type int dword_806C14C;
// 806C150: using guessed type int dword_806C150;
// 806C174: using guessed type int dword_806C174;
// 806C1A4: using guessed type int dword_806C1A4;
// 806C1A8: using guessed type int (__fastcall *dword_806C1A8)(_DWORD);
// 806C1AC: using guessed type int dword_806C1AC;
// 806C1D0: using guessed type int dword_806C1D0;
// 806C1D4: using guessed type int dword_806C1D4;

//----- (0804AEFC) --------------------------------------------------------
int __usercall sub_804AEFC@<eax>(signed __int32 a1@<ebx>, char *s1, int a3, size_t a4, int a5)
{
  int result; // eax
  _BYTE *v6; // ebx
  int *v7; // eax
  _BYTE *v8; // ebx
  int *v9; // eax
  bool v10; // zf
  signed __int32 v11; // ecx
  int (__fastcall *v12)(_DWORD); // eax
  signed __int32 v13; // ebx
  int v14; // [esp+8h] [ebp-20h]
  bool v15; // [esp+17h] [ebp-11h]
  FILE *stream; // [esp+18h] [ebp-10h]

  v15 = strcmp(s1, "-") == 0;
  *(_BYTE *)a5 = 0;
  if ( v15 )
  {
    byte_806C661 = 1;
    stream = (FILE *)stdin;
    sub_8062647((FILE *)stdin, 2);
  }
  else
  {
    stream = sub_806275C((int)s1, "r");
    if ( !stream )
    {
      if ( byte_806C66F && *__errno_location() == 2 )
      {
        *(_BYTE *)a5 = 1;
        result = 1;
      }
      else
      {
        v6 = sub_8064544(0, 3, s1);
        v7 = __errno_location();
        error(0, *v7, "%s", v6);
        result = 0;
      }
      return result;
    }
    sub_8062647(stream, 2);
  }
  if ( sub_804D6FB(a1, stream, a4, v14) )
  {
    v8 = sub_8064544(0, 3, s1);
    v9 = __errno_location();
    error(0, *v9, "%s", v8);
    if ( stream != (FILE *)stdin )
      sub_80653A2(stream);
    result = 0;
  }
  else if ( v15 == 1 )
  {
    result = 1;
  }
  else
  {
    v10 = sub_80653A2(stream) == 0;
    v12 = (int (__fastcall *)(_DWORD))&loc_804B116;
    if ( v10 )
      v12 = (int (__fastcall *)(_DWORD))&loc_804B15D;
    dword_806C1A8 = v12;
    dword_806C1A4 = (int)&loc_804B116;
    v13 = _InterlockedExchange(&dword_806C1AC, a1);
    _InterlockedExchange(&dword_806C1AC, v11);
    result = v12(_InterlockedExchange(&dword_806C1AC, v13));
  }
  return result;
}
// 806C1A4: using guessed type int dword_806C1A4;
// 806C1A8: using guessed type int (__fastcall *dword_806C1A8)(_DWORD);
// 806C1AC: using guessed type int dword_806C1AC;
// 806C2A0: using guessed type int stdin;
// 806C661: using guessed type char byte_806C661;
// 806C66F: using guessed type char byte_806C66F;

//----- (0804B168) --------------------------------------------------------
int __usercall sub_804B168@<eax>(_BYTE *a1@<ebx>, const char *a2)
{
  _BYTE *v2; // ebx
  int *v3; // eax
  int result; // eax
  char *v5; // eax
  int v6; // eax
  int v7; // ecx
  bool v8; // zf
  bool v9; // sf
  void *v10; // eax
  int v11; // edx
  signed __int32 v12; // ecx
  int v13; // ecx
  void *v14; // eax
  char *v15; // eax
  signed __int32 v16; // ebx
  signed __int32 v17; // et0
  signed __int32 v18; // ebx
  signed __int32 v19; // edx
  signed __int32 v20; // edx
  signed __int32 v21; // et1
  bool v22; // al
  char v23; // al
  int v24; // edx
  int v25; // ecx
  void *v26; // eax
  int v27; // ecx
  char *v28; // eax
  int v29; // edx
  int v30; // ecx
  _BYTE *v31; // ebx
  char *v32; // eax
  signed __int32 v33; // ecx
  int (__fastcall *v34)(_DWORD); // eax
  signed __int32 v35; // ebx
  void *v36; // eax
  _BYTE *v37; // ebx
  char *v38; // eax
  signed __int32 v39; // eax
  signed __int32 v40; // eax
  signed __int32 v41; // edx
  int v42; // ecx
  signed __int32 v43; // ecx
  signed __int32 v44; // et0
  int v45; // eax
  char *v46; // eax
  int v47; // eax
  char *v48; // eax
  int v49; // eax
  char *v50; // eax
  _BYTE *v51; // ebx
  char *v52; // eax
  bool v53; // al
  const char *s1; // [esp+1Ch] [ebp-BCh]
  int v55; // [esp+2Ah] [ebp-AEh]
  unsigned __int8 v56; // [esp+2Eh] [ebp-AAh]
  char v57; // [esp+2Fh] [ebp-A9h]
  void *ptr; // [esp+30h] [ebp-A8h]
  int v59; // [esp+34h] [ebp-A4h]
  char *s; // [esp+38h] [ebp-A0h]
  int v61; // [esp+3Ch] [ebp-9Ch]
  int v62; // [esp+40h] [ebp-98h]
  FILE *stream; // [esp+44h] [ebp-94h]
  int v64; // [esp+48h] [ebp-90h]
  size_t v65; // [esp+50h] [ebp-88h]
  __int64 v66; // [esp+58h] [ebp-80h]
  __int64 v67; // [esp+60h] [ebp-78h]
  __int64 v68; // [esp+68h] [ebp-70h]
  __int64 v69; // [esp+70h] [ebp-68h]
  __int64 v70; // [esp+78h] [ebp-60h]
  char v71; // [esp+84h] [ebp-54h]
  unsigned int v72; // [esp+CCh] [ebp-Ch]

  s1 = a2;
  v72 = __readgsdword(0x14u);
  v66 = 0LL;
  v67 = 0LL;
  v68 = 0LL;
  v69 = 0LL;
  *(_WORD *)((char *)&v55 + 1) = 0;
  v65 = sub_804A169((int)&v71, 8u);
  HIBYTE(v55) = strcmp(a2, "-") == 0;
  if ( HIBYTE(v55) )
  {
    byte_806C661 = 1;
    s1 = gettext("standard input");
    stream = (FILE *)stdin;
  }
  else
  {
    stream = sub_806275C((int)a2, "r");
    if ( !stream )
    {
      v2 = sub_8064544(0, 3, a2);
      v3 = __errno_location();
      error(0, *v3, "%s", v2);
      return 0;
    }
  }
  v70 = 0LL;
  ptr = 0;
  v59 = 0;
  do
  {
    if ( !++v70 )
    {
      a1 = sub_8064544(0, 3, s1);
      v5 = gettext("%s: too many checksum lines");
      error(1, 0, v5, a1);
    }
    v6 = getline(&ptr, &v59, stream);
    v64 = v6;
    v8 = v6 == 0;
    v9 = v6 < 0;
    v10 = &loc_804B370;
    if ( v9 || v8 )
      v10 = &loc_804B7D7;
    dword_806C124 = (int)v10;
    sub_80669F3(v7);
    if ( *(_BYTE *)ptr != 35 )
    {
      if ( *((_BYTE *)ptr + v64 - 1) == 10 )
        *((_BYTE *)ptr + --v64) = 0;
      if ( !((unsigned __int8)sub_804A854((signed __int32)ptr, v64, (int)&v62, &v61, (signed __int32 *)&s) ^ 1) )
      {
        if ( !HIBYTE(v55) )
        {
LABEL_21:
          v22 = byte_806C66D != 1 && strchr(s, 10);
          v56 = v22;
          BYTE1(v55) = 1;
          v23 = sub_804AEFC((signed __int32)a1, s, (int)&v61, v65, (int)&v55);
          v57 = v23;
          v8 = v23 == 1;
          v26 = &loc_804B581;
          if ( v8 )
            v26 = &loc_804B5EA;
          dword_806C160 = (int)v26;
          sub_8066852(v25, v24);
          ++v69;
          if ( byte_806C66D != 1 )
          {
            if ( v56 )
              putchar_unlocked(92);
            sub_804ACF4(v56, v27, (signed __int32)a1, s, v56);
            v28 = gettext("FAILED open or read");
            printf(": %s\n", v28);
          }
          continue;
        }
        v8 = strcmp(s, "-") == 0;
        v14 = &loc_804B42E;
        if ( !v8 )
          v14 = &loc_804B4E0;
        dword_806C138 = (int)v14;
        sub_806696A(v13);
      }
      ++v66;
      if ( byte_806C66E )
      {
        a1 = sub_8064544(0, 3, s1);
        v15 = gettext("%s: %llu: improperly formatted %s checksum line");
        error(0, 0, v15, a1, v70, "SHA512");
      }
      ++v67;
      dword_806C160 = (int)&loc_804B7AF;
      v16 = _InterlockedExchange(&dword_806C164, (signed __int32)a1);
      v17 = _InterlockedExchange(&dword_806C164, v12);
      sub_8066852(_InterlockedExchange(&dword_806C164, v16), v11);
      v18 = _InterlockedExchange(&dword_806C164, v17);
      v21 = _InterlockedExchange(&dword_806C164, v19);
      v20 = v18;
      a1 = (_BYTE *)v21;
      _InterlockedExchange(&dword_806C164, v20);
      goto LABEL_21;
    }
  }
  while ( !feof_unlocked(stream) && !ferror_unlocked(stream) );
  free(ptr);
  if ( ferror_unlocked(stream) )
  {
    v31 = sub_8064544(0, 3, s1);
    v32 = gettext("%s: read error");
    error(0, 0, v32, v31);
    result = 0;
  }
  else if ( HIBYTE(v55) == 1 )
  {
    v36 = &loc_804B9B3;
    if ( BYTE1(v55) == 1 )
      v36 = &loc_804BA38;
    dword_806C160 = (int)v36;
    sub_8066852(v30, v29);
    v37 = sub_8064544(0, 3, s1);
    v38 = gettext("%s: no properly formatted %s checksum lines found");
    error(0, 0, v38, v37, "SHA512");
    dword_806C138 = (int)&loc_804BBC5;
    v40 = _InterlockedExchange(&dword_806C13C, v39);
    _InterlockedExchange(&dword_806C13C, v41);
    _InterlockedExchange(&dword_806C13C, v40);
    v44 = _InterlockedExchange(&dword_806C13C, sub_806696A(v42));
    _InterlockedExchange(&dword_806C13C, v43);
    _InterlockedExchange(&dword_806C13C, v44);
    if ( byte_806C66D != 1 )
    {
      if ( v66 )
      {
        v45 = sub_804A123(v66, HIDWORD(v66));
        v46 = ngettext(
                "WARNING: %llu line is improperly formatted",
                "WARNING: %llu lines are improperly formatted",
                v45);
        error(0, 0, v46, v66);
      }
      if ( v69 )
      {
        v47 = sub_804A123(v69, HIDWORD(v69));
        v48 = ngettext(
                "WARNING: %llu listed file could not be read",
                "WARNING: %llu listed files could not be read",
                v47);
        error(0, 0, v48, v69);
      }
      if ( v68 )
      {
        v49 = sub_804A123(v68, HIDWORD(v68));
        v50 = ngettext(
                "WARNING: %llu computed checksum did NOT match",
                "WARNING: %llu computed checksums did NOT match",
                v49);
        error(0, 0, v50, v68);
      }
      if ( byte_806C66F && BYTE2(v55) != 1 )
      {
        v51 = sub_8064544(0, 3, s1);
        v52 = gettext("%s: no file was verified");
        error(0, 0, v52, v51);
      }
    }
    v53 = BYTE1(v55) && BYTE2(v55) && !v68 && !v69 && (byte_806C671 != 1 || !v67);
    result = v53;
  }
  else
  {
    v8 = sub_80653A2(stream) == 0;
    v34 = (int (__fastcall *)(_DWORD))&loc_804B90D;
    if ( v8 )
      v34 = (int (__fastcall *)(_DWORD))&loc_804B98C;
    dword_806C1A8 = v34;
    dword_806C1A4 = (int)&loc_804B90D;
    v35 = _InterlockedExchange(&dword_806C1AC, (signed __int32)a1);
    _InterlockedExchange(&dword_806C1AC, v33);
    result = v34(_InterlockedExchange(&dword_806C1AC, v35));
  }
  return result;
}
// 8048D20: using guessed type int __cdecl getline(_DWORD, _DWORD, _DWORD);
// 8066852: using guessed type int __fastcall sub_8066852(_DWORD, _DWORD);
// 806696A: using guessed type int __fastcall sub_806696A(_DWORD);
// 80669F3: using guessed type int __fastcall sub_80669F3(_DWORD);
// 806C124: using guessed type int dword_806C124;
// 806C138: using guessed type int dword_806C138;
// 806C13C: using guessed type int dword_806C13C;
// 806C160: using guessed type int dword_806C160;
// 806C164: using guessed type int dword_806C164;
// 806C1A4: using guessed type int dword_806C1A4;
// 806C1A8: using guessed type int (__fastcall *dword_806C1A8)(_DWORD);
// 806C1AC: using guessed type int dword_806C1AC;
// 806C2A0: using guessed type int stdin;
// 806C661: using guessed type char byte_806C661;
// 806C66D: using guessed type char byte_806C66D;
// 806C66E: using guessed type char byte_806C66E;
// 806C66F: using guessed type char byte_806C66F;
// 806C671: using guessed type char byte_806C671;

//----- (0804BC33) --------------------------------------------------------
int __usercall main@<eax>(signed __int32 a1@<ebx>, int argc, char **a3)
{
  int i; // eax
  int v4; // edx
  signed __int32 v5; // ecx
  void *v6; // eax
  int v7; // eax
  int v8; // ecx
  bool v9; // zf
  bool v10; // sf
  unsigned __int8 v11; // of
  void *v12; // eax
  signed __int32 v13; // eax
  signed __int32 v14; // edx
  int v15; // ecx
  signed __int32 v16; // eax
  signed __int32 v17; // ecx
  signed __int32 v18; // eax
  signed __int32 v19; // et1
  void *v20; // eax
  int v21; // edx
  int v22; // ecx
  void *v23; // eax
  signed __int32 v24; // eax
  int v25; // edx
  signed __int32 v26; // ecx
  signed __int32 v27; // eax
  int v28; // eax
  int v29; // edx
  signed __int32 v30; // ebx
  signed __int32 v31; // ecx
  signed __int32 v32; // ecx
  signed __int32 v33; // ett
  signed __int32 v34; // ecx
  signed __int32 v35; // eax
  signed __int32 v36; // ebx
  signed __int32 v37; // ecx
  signed __int32 v38; // ebx
  signed __int32 v39; // ecx
  int v40; // edx
  signed __int32 v41; // edx
  signed __int32 v42; // ett
  int result; // eax
  void *v49; // eax
  char *v50; // eax
  char *v51; // eax
  char *v52; // eax
  int (*v53)(); // eax
  signed __int32 v54; // ebx
  char v55; // [esp+3Ch] [ebp-78h]
  signed int v56; // [esp+44h] [ebp-70h]
  signed int v57; // [esp+5Ch] [ebp-58h]
  int v58; // [esp+64h] [ebp-50h]
  unsigned int v59; // [esp+ACh] [ebp-8h]
  _DWORD *savedregs; // [esp+B4h] [ebp+0h]

  v59 = __readgsdword(0x14u);
  sub_804A169((int)&v58, 8u);
  v55 = 0;
  v56 = -1;
  sub_806284A(*a3);
  setlocale(6, &locale);
  bindtextdomain("coreutils", "/home/hwangdz/coreutils/coreutils-8.28/install_m32/share/locale");
  textdomain("coreutils");
  sub_806644A((int)sub_804C811);
  setvbuf(stdout, 0, 1, 0);
  for ( i = getopt_long(argc, a3, "bctw", &longopts, 0); ; i = getopt_long(argc, a3, "bctw", &longopts, 0) )
  {
    v57 = i;
    if ( i == -1 )
      break;
    if ( i == 119 )
    {
      byte_806C66D = 0;
      byte_806C66E = 1;
      byte_806C670 = 0;
    }
    else if ( i > 119 )
    {
      if ( i == 130 )
      {
        byte_806C66D = 0;
        byte_806C66E = 0;
        byte_806C670 = 1;
      }
      else
      {
        v20 = &loc_804BDE4;
        if ( v57 > 130 )
          v20 = &loc_804BE41;
        dword_806C160 = (int)v20;
        v9 = sub_8066852(v5, v4) == 128;
        v23 = &loc_804BE04;
        if ( v9 )
          v23 = &loc_804BEB4;
        dword_806C1BC = (int)v23;
        v24 = sub_80665CD(v22, v21);
        if ( v24 == 129 )
        {
          byte_806C66D = 1;
          byte_806C66E = 0;
          byte_806C670 = 0;
        }
        else
        {
          dword_806C160 = (int)&loc_804BFF5;
          v27 = _InterlockedExchange(&dword_806C164, v24);
          _InterlockedExchange(&dword_806C164, v26);
          v28 = sub_8066852(_InterlockedExchange(&dword_806C164, v27), v25);
          v30 = _InterlockedExchange(&dword_806C164, a1);
          v33 = _InterlockedExchange(&dword_806C164, v31);
          v32 = v30;
          a1 = v33;
          v34 = _InterlockedExchange(&dword_806C164, v32);
          if ( v28 != 131 )
          {
            if ( v28 == 132 )
            {
              dword_806C160 = (int)&loc_804C001;
              v35 = _InterlockedExchange(&dword_806C164, 132);
              _InterlockedExchange(&dword_806C164, v34);
              sub_8066852(_InterlockedExchange(&dword_806C164, v35), v29);
              v36 = _InterlockedExchange(&dword_806C164, a1);
              _InterlockedExchange(&dword_806C164, v37);
              _InterlockedExchange(&dword_806C164, v36);
LABEL_29:
              sub_804A387(0);
            }
LABEL_31:
            sub_804A387(1);
          }
          byte_806C671 = 1;
        }
      }
    }
    else
    {
      v6 = &loc_804BD39;
      if ( v57 == 98 )
        v6 = &loc_804BE5C;
      dword_806C1BC = (int)v6;
      v7 = sub_80665CD(v5, v4);
      v11 = __OFSUB__(v7, 98);
      v9 = v7 == 98;
      v10 = v7 - 98 < 0;
      v12 = &loc_804BD57;
      if ( !((unsigned __int8)(v10 ^ v11) | v9) )
        v12 = &loc_804BDA2;
      dword_806C1D0 = (int)v12;
      v13 = sub_8066552(v8);
      if ( v13 == -131 )
      {
        sub_8064ECF(off_806C1FC, v15, a1);
        dword_806C1BC = (int)sub_804C79C;
        v38 = _InterlockedExchange(&dword_806C1C0, a1);
        _InterlockedExchange(&dword_806C1C0, v39);
        v42 = _InterlockedExchange(&dword_806C1C0, sub_80665CD(_InterlockedExchange(&dword_806C1C0, v38), v40));
        _InterlockedExchange(&dword_806C1C0, v41);
        _InterlockedExchange(&dword_806C1C0, v42);
        savedregs = &savedregs;
        result = argc;
        dword_806C675 = argc;
        return result;
      }
      if ( v13 == -130 )
        goto LABEL_29;
      dword_806C160 = (int)&loc_804BFF5;
      v16 = _InterlockedExchange(&dword_806C164, v13);
      _InterlockedExchange(&dword_806C164, v14);
      v19 = _InterlockedExchange(&dword_806C164, sub_8066852(v15, _InterlockedExchange(&dword_806C164, v16)));
      v18 = _InterlockedExchange(&dword_806C164, v17);
      _InterlockedExchange(&dword_806C164, v19);
      if ( v18 == 99 )
      {
        v55 = 1;
      }
      else
      {
        if ( v18 != 116 )
          goto LABEL_31;
        v56 = 0;
      }
    }
  }
  dword_806C665 = 130;
  dword_806C669 = 128;
  if ( v56 >= 0 )
  {
    v49 = &loc_804C10B;
    if ( !v55 )
      v49 = &loc_804C13B;
    dword_806C1D0 = (int)v49;
    sub_8066552(v5);
    v50 = gettext("the --binary and --text options are meaningless when verifying checksums");
    error(0, 0, v50);
    sub_804A387(1);
  }
  if ( byte_806C66F && v55 != 1 )
  {
    v51 = gettext("the --ignore-missing option is meaningful only when verifying checksums");
    error(0, 0, v51);
    sub_804A387(1);
  }
  if ( byte_806C66D && v55 != 1 )
  {
    v52 = gettext("the --status option is meaningful only when verifying checksums");
    error(0, 0, v52);
    sub_804A387(1);
  }
  v53 = sub_804C28D;
  if ( !byte_806C66E )
    v53 = (int (*)())&loc_804C2C9;
  dword_806C1A8 = (int (__fastcall *)(_DWORD))v53;
  dword_806C1A4 = (int)sub_804C28D;
  v54 = _InterlockedExchange(&dword_806C1AC, a1);
  _InterlockedExchange(&dword_806C1AC, v5);
  return ((int (__fastcall *)(signed __int32))v53)(_InterlockedExchange(&dword_806C1AC, v54));
}
// 804C28D: using guessed type int sub_804C28D();
// 804C79C: using guessed type int sub_804C79C();
// 8066552: using guessed type int __fastcall sub_8066552(_DWORD);
// 80665CD: using guessed type int __fastcall sub_80665CD(_DWORD, _DWORD);
// 8066852: using guessed type int __fastcall sub_8066852(_DWORD, _DWORD);
// 806C160: using guessed type int dword_806C160;
// 806C164: using guessed type int dword_806C164;
// 806C1A4: using guessed type int dword_806C1A4;
// 806C1A8: using guessed type int (__fastcall *dword_806C1A8)(_DWORD);
// 806C1AC: using guessed type int dword_806C1AC;
// 806C1BC: using guessed type int dword_806C1BC;
// 806C1C0: using guessed type int dword_806C1C0;
// 806C1D0: using guessed type int dword_806C1D0;
// 806C665: using guessed type int dword_806C665;
// 806C669: using guessed type int dword_806C669;
// 806C66D: using guessed type char byte_806C66D;
// 806C66E: using guessed type char byte_806C66E;
// 806C66F: using guessed type char byte_806C66F;
// 806C670: using guessed type char byte_806C670;
// 806C671: using guessed type char byte_806C671;
// 806C675: using guessed type int dword_806C675;

//----- (0804C7FA) --------------------------------------------------------
int __cdecl sub_804C7FA(unsigned __int8 a1)
{
  int result; // eax

  result = a1;
  byte_806C679 = a1;
  return result;
}
// 806C679: using guessed type char byte_806C679;

//----- (0804C811) --------------------------------------------------------
int sub_804C811()
{
  _BYTE *v0; // ebx
  int *v1; // eax
  int *v2; // eax
  int result; // eax
  char *v4; // [esp+2Ch] [ebp-Ch]

  if ( sub_8065855(stdout) && (byte_806C679 != 1 || *__errno_location() != 32) )
  {
    v4 = gettext("write error");
    if ( dword_806C675 )
    {
      v0 = sub_8064507((const char *)dword_806C675);
      v1 = __errno_location();
      error(0, *v1, "%s: %s", v0, v4);
    }
    else
    {
      v2 = __errno_location();
      error(0, *v2, "%s", v4);
    }
    _exit(status);
  }
  result = sub_8065855(stderr);
  if ( result )
    _exit(status);
  return result;
}
// 806C675: using guessed type int dword_806C675;
// 806C679: using guessed type char byte_806C679;

//----- (0804C8F5) --------------------------------------------------------
_DWORD *__cdecl sub_804C8F5(_DWORD *a1)
{
  int v1; // edx
  _DWORD *result; // eax

  *a1 = -205731576;
  a1[1] = 1779033703;
  a1[2] = -2067093701;
  a1[3] = -1150833019;
  a1[4] = -23791573;
  a1[5] = 1013904242;
  a1[6] = 1595750129;
  a1[7] = -1521486534;
  a1[8] = -1377402159;
  a1[9] = 1359893119;
  a1[10] = 725511199;
  a1[11] = -1694144372;
  a1[12] = -79577749;
  a1[13] = 528734635;
  a1[14] = 327033209;
  a1[15] = 1541459225;
  a1[18] = 0;
  a1[19] = 0;
  v1 = a1[19];
  a1[16] = a1[18];
  a1[17] = v1;
  result = a1;
  a1[20] = 0;
  return result;
}

//----- (0804C9AE) --------------------------------------------------------
_DWORD *__cdecl sub_804C9AE(_DWORD *a1)
{
  int v1; // edx
  _DWORD *result; // eax

  *a1 = -1056596264;
  a1[1] = -876896931;
  a1[2] = 914150663;
  a1[3] = 1654270250;
  a1[4] = 812702999;
  a1[5] = -1856437926;
  a1[6] = -150054599;
  a1[7] = 355462360;
  a1[8] = -4191439;
  a1[9] = 1731405415;
  a1[10] = 1750603025;
  a1[11] = -1900787065;
  a1[12] = 1694076839;
  a1[13] = -619958771;
  a1[14] = -1090891868;
  a1[15] = 1203062813;
  a1[18] = 0;
  a1[19] = 0;
  v1 = a1[19];
  a1[16] = a1[18];
  a1[17] = v1;
  result = a1;
  a1[20] = 0;
  return result;
}

//----- (0804CA67) --------------------------------------------------------
int __cdecl sub_804CA67(_DWORD *a1, int a2, int a3)
{
  int result; // eax

  result = a2;
  *a1 = a2;
  a1[1] = a3;
  return result;
}

//----- (0804CA89) --------------------------------------------------------
int __cdecl sub_804CA89(int a1, int a2)
{
  _DWORD *v2; // edx
  int v3; // et1
  int v4; // ebx
  _DWORD *v5; // edx
  int v6; // et1
  int v7; // ST64_4
  _DWORD *v8; // edx
  int v9; // et1
  int v10; // ST58_4
  _DWORD *v11; // edx
  int v12; // et1
  unsigned int v13; // ST50_4
  int *v14; // edx
  int v15; // et1
  int v16; // ST20_4
  int *v17; // edx
  int v18; // et1
  signed int i; // [esp+80h] [ebp-18h]

  for ( i = 0; i <= 7; ++i )
  {
    v2 = (_DWORD *)(a1 + 8 * i);
    v3 = v2[1];
    v4 = *v2 << 24;
    v5 = (_DWORD *)(a1 + 8 * i);
    v6 = v5[1];
    v7 = ((*v5 & 0xFF00) << 8) | v4;
    v8 = (_DWORD *)(a1 + 8 * i);
    v9 = v8[1];
    v10 = *v8 & 0xFF0000;
    v11 = (_DWORD *)(a1 + 8 * i);
    v12 = v11[1];
    v13 = *v11 & 0xFF000000;
    v14 = (int *)(a1 + 8 * i);
    v15 = *v14;
    v16 = ((unsigned int)v14[1] >> 8) & 0xFF00;
    v17 = (int *)(a1 + 8 * i);
    v18 = *v17;
    sub_804CA67(
      (_DWORD *)(8 * i + a2),
      ((unsigned int)v17[1] >> 24) | v16 | (*(_QWORD *)(a1 + 8 * i) >> 24) & 0xFF0000 | (*(_QWORD *)(a1 + 8 * i) >> 8) & 0xFF000000 | (v13 << 8) | (v10 << 24),
      ((unsigned __int64)v13 >> 24) | ((unsigned __int64)(unsigned int)v10 >> 8) | v7);
  }
  return a2;
}

//----- (0804CCBC) --------------------------------------------------------
int __cdecl sub_804CCBC(int a1, int a2)
{
  _DWORD *v2; // edx
  int v3; // et1
  int v4; // ebx
  _DWORD *v5; // edx
  int v6; // et1
  int v7; // ST64_4
  _DWORD *v8; // edx
  int v9; // et1
  int v10; // ST58_4
  _DWORD *v11; // edx
  int v12; // et1
  unsigned int v13; // ST50_4
  int *v14; // edx
  int v15; // et1
  int v16; // ST20_4
  int *v17; // edx
  int v18; // et1
  signed int i; // [esp+80h] [ebp-18h]

  for ( i = 0; i <= 5; ++i )
  {
    v2 = (_DWORD *)(a1 + 8 * i);
    v3 = v2[1];
    v4 = *v2 << 24;
    v5 = (_DWORD *)(a1 + 8 * i);
    v6 = v5[1];
    v7 = ((*v5 & 0xFF00) << 8) | v4;
    v8 = (_DWORD *)(a1 + 8 * i);
    v9 = v8[1];
    v10 = *v8 & 0xFF0000;
    v11 = (_DWORD *)(a1 + 8 * i);
    v12 = v11[1];
    v13 = *v11 & 0xFF000000;
    v14 = (int *)(a1 + 8 * i);
    v15 = *v14;
    v16 = ((unsigned int)v14[1] >> 8) & 0xFF00;
    v17 = (int *)(a1 + 8 * i);
    v18 = *v17;
    sub_804CA67(
      (_DWORD *)(8 * i + a2),
      ((unsigned int)v17[1] >> 24) | v16 | (*(_QWORD *)(a1 + 8 * i) >> 24) & 0xFF0000 | (*(_QWORD *)(a1 + 8 * i) >> 8) & 0xFF000000 | (v13 << 8) | (v10 << 24),
      ((unsigned __int64)v13 >> 24) | ((unsigned __int64)(unsigned int)v10 >> 8) | v7);
  }
  return a2;
}

//----- (0804CF6E) --------------------------------------------------------
int __cdecl sub_804CF6E(int a1)
{
  signed int v1; // eax
  int v2; // et1
  int v3; // et1
  int v4; // et1
  int v5; // et1
  unsigned int v6; // STF8_4
  int v7; // et1
  int v8; // STE8_4
  int v9; // et1
  int v10; // et1
  int v11; // et1
  int v12; // et1
  int v13; // et1
  int v14; // et1
  int v15; // et1
  int v16; // et1
  unsigned int v18; // [esp+128h] [ebp-20h]
  signed int v19; // [esp+12Ch] [ebp-1Ch]

  v18 = *(_DWORD *)(a1 + 80);
  if ( v18 > 0x6F )
    v1 = 32;
  else
    v1 = 16;
  v19 = v1;
  *(_QWORD *)(a1 + 64) += v18;
  if ( *(_QWORD *)(a1 + 64) < (unsigned __int64)v18 )
    ++*(_QWORD *)(a1 + 72);
  v2 = *(_DWORD *)(a1 + 76);
  v3 = *(_DWORD *)(a1 + 64);
  v4 = *(_DWORD *)(a1 + 64);
  v5 = *(_DWORD *)(a1 + 64);
  v6 = *(_QWORD *)(a1 + 68) >> 29;
  v7 = *(_DWORD *)(a1 + 64);
  v8 = *(_QWORD *)(a1 + 68) >> 29;
  v9 = *(_DWORD *)(a1 + 64);
  v10 = *(_DWORD *)(a1 + 64);
  v11 = *(_DWORD *)(a1 + 64);
  v12 = *(_DWORD *)(a1 + 64);
  sub_804CA67(
    (_DWORD *)(8 * (v1 - 2 + 10) + a1 + 4),
    ((unsigned int)(*(_QWORD *)(a1 + 72) >> 29) >> 24) | ((unsigned int)(*(_QWORD *)(a1 + 72) >> 29) >> 8) & 0xFF00 | (__PAIR__(*(_QWORD *)(a1 + 72) >> 29, v6) >> 24) & 0xFF0000 | (__PAIR__(*(_QWORD *)(a1 + 72) >> 29, v6) >> 8) & 0xFF000000 | ((v8 & 0xFF000000) << 8) | ((v6 & 0xFF0000) << 24),
    ((v8 & 0xFF000000) >> 24) | ((v6 & 0xFF0000uLL) >> 8) | ((unsigned __int16)((*(_QWORD *)(a1 + 68) >> 29) & 0xFF00) << 8) | (v6 << 24));
  v13 = *(_DWORD *)(a1 + 68);
  v14 = *(_DWORD *)(a1 + 68);
  v15 = *(_DWORD *)(a1 + 68);
  v16 = *(_DWORD *)(a1 + 68);
  sub_804CA67(
    (_DWORD *)(8 * (v19 - 1 + 10) + a1 + 4),
    ((unsigned int)(*(_QWORD *)(a1 + 64) >> 29) >> 24) | ((unsigned int)(*(_QWORD *)(a1 + 64) >> 29) >> 8) & 0xFF00 | ((unsigned __int64)(8LL * *(_QWORD *)(a1 + 64)) >> 24) & 0xFF0000 | ((unsigned __int64)(8LL * *(_QWORD *)(a1 + 64)) >> 8) & 0xFF000000 | ((8 * *(_DWORD *)(a1 + 64) & 0xFF000000) << 8) | ((8 * *(_DWORD *)(a1 + 64) & 0xFF0000) << 24),
    ((8 * *(_DWORD *)(a1 + 64) & 0xFF000000) >> 24) | ((8 * *(_DWORD *)(a1 + 64) & 0xFF0000u) >> 8) | ((unsigned __int16)(8 * *(unsigned int *)(a1 + 64) & 0xFF00) << 8) | (*(_DWORD *)(a1 + 64) << 27));
  memcpy((void *)(a1 + 84 + v18), &unk_8067790, 8 * (v19 + 536870910) - v18);
  return sub_804DD9A(a1 + 84, 8 * v19, a1);
}
// 804DD9A: using guessed type _DWORD __cdecl sub_804DD9A(_DWORD, _DWORD, _DWORD);

//----- (0804D6B1) --------------------------------------------------------
int __cdecl sub_804D6B1(int a1, int a2)
{
  sub_804CF6E(a1);
  return sub_804CA89(a1, a2);
}

//----- (0804D6D6) --------------------------------------------------------
int __cdecl sub_804D6D6(int a1, int a2)
{
  sub_804CF6E(a1);
  return sub_804CCBC(a1, a2);
}

//----- (0804D6FB) --------------------------------------------------------
int __usercall sub_804D6FB@<eax>(signed __int32 a1@<ebx>, FILE *stream, size_t a3, int a4)
{
  signed __int32 v5; // edx
  int v6; // ecx
  signed __int32 v7; // eax
  signed __int32 v8; // edx
  signed __int32 v9; // et1
  signed __int32 v10; // eax
  signed __int32 v11; // eax
  signed __int32 v12; // ecx
  signed __int32 v13; // ebx
  signed __int32 v14; // edx
  void *ptr; // [esp+14h] [ebp-164h]
  size_t v16; // [esp+18h] [ebp-160h]
  int v17; // [esp+1Ch] [ebp-15Ch]

  ptr = malloc(0x8048u);
  if ( !ptr )
    return 1;
  sub_804C8F5(&v17);
  v16 = fread_unlocked(ptr, 1u, 0x8000u, stream);
  if ( v16 == 0x8000 )
  {
    v10 = sub_804DD9A(ptr, 0x8000, &v17);
    dword_806C138 = (int)&loc_804D7C7;
    v11 = _InterlockedExchange(&dword_806C13C, v10);
    _InterlockedExchange(&dword_806C13C, v12);
    sub_806696A(_InterlockedExchange(&dword_806C13C, v11));
    v13 = _InterlockedExchange(&dword_806C13C, a1);
    _InterlockedExchange(&dword_806C13C, v14);
    _InterlockedExchange(&dword_806C13C, v13);
    sub_804DAC5(stream, a3, (int)&v17);
    return sub_804D6D6((int)&v17, a4);
  }
  if ( v16 )
  {
    if ( !feof_unlocked(stream) )
    {
      dword_806C174 = (int)&loc_804D741;
      v7 = _InterlockedExchange(&dword_806C178, 0);
      _InterlockedExchange(&dword_806C178, v5);
      v9 = _InterlockedExchange(&dword_806C178, sub_80667D6(v6, _InterlockedExchange(&dword_806C178, v7)));
      _InterlockedExchange(&dword_806C178, v8);
      _InterlockedExchange(&dword_806C178, v9);
    }
  }
  else if ( ferror_unlocked(stream) )
  {
    free(ptr);
    return 1;
  }
  if ( v16 )
    sub_804DAC5(ptr, v16, (int)&v17);
  sub_804D6B1((int)&v17, a3);
  free(ptr);
  return 0;
}
// 804DD9A: using guessed type _DWORD __cdecl sub_804DD9A(_DWORD, _DWORD, _DWORD);
// 80667D6: using guessed type int __fastcall sub_80667D6(_DWORD, _DWORD);
// 806696A: using guessed type int __fastcall sub_806696A(_DWORD);
// 806C138: using guessed type int dword_806C138;
// 806C13C: using guessed type int dword_806C13C;
// 806C174: using guessed type int dword_806C174;
// 806C178: using guessed type int dword_806C178;

//----- (0804DAC5) --------------------------------------------------------
int __cdecl sub_804DAC5(void *src, size_t a2, int a3)
{
  int result; // eax
  int v4; // eax
  void *v5; // eax
  size_t v6; // [esp+14h] [ebp-14h]
  size_t v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]

  result = *(_DWORD *)(a3 + 80);
  if ( result )
  {
    v8 = *(_DWORD *)(a3 + 80);
    v4 = a2;
    if ( 256 - v8 <= a2 )
      v4 = 256 - v8;
    n = v4;
    memcpy((void *)(v8 + a3 + 84), src, v4);
    *(_DWORD *)(a3 + 80) += n;
    if ( *(_DWORD *)(a3 + 80) > 0x80u )
    {
      sub_804DD9A(a3 + 84, *(_DWORD *)(a3 + 80) & 0xFFFFFF80, a3);
      *(_DWORD *)(a3 + 80) &= 0x7Fu;
      memcpy((void *)(a3 + 84), (const void *)(a3 + 84 + ((v8 + n) & 0xFFFFFF80)), *(_DWORD *)(a3 + 80));
    }
    src = (char *)src + n;
    result = n;
    a2 -= n;
  }
  if ( a2 > 0x7F )
  {
    result = (unsigned __int8)src & 3;
    if ( (unsigned __int8)src & 3 )
    {
      while ( a2 > 0x80 )
      {
        v5 = memcpy((void *)(a3 + 84), src, 0x80u);
        result = sub_804DD9A(v5, 128, a3);
        src = (char *)src + 128;
        a2 -= 128;
      }
    }
    else
    {
      sub_804DD9A(src, a2 & 0xFFFFFF80, a3);
      result = a2 & 0xFFFFFF80;
      src = (char *)src + (a2 & 0xFFFFFF80);
      a2 &= 0x7Fu;
    }
  }
  if ( a2 )
  {
    v7 = *(_DWORD *)(a3 + 80);
    memcpy((void *)(v7 + a3 + 84), src, a2);
    v6 = a2 + v7;
    if ( v6 > 0x7F )
    {
      sub_804DD9A(a3 + 84, 128, a3);
      v6 -= 128;
      memcpy((void *)(a3 + 84), (const void *)(a3 + 212), v6);
    }
    result = a3;
    *(_DWORD *)(a3 + 80) = v6;
  }
  return result;
}
// 804DD9A: using guessed type _DWORD __cdecl sub_804DD9A(_DWORD, _DWORD, _DWORD);

//----- (0804DD9A) --------------------------------------------------------
#error "804DD9A: too big function (funcsize=0)"

//----- (080625F6) --------------------------------------------------------
int __cdecl sub_80625F6(int a1, int a2, int a3, int a4, int a5, int a6)
{
  return posix_fadvise64(a1, a2, a3, a4, a5, a6);
}
// 8049050: using guessed type int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (08062647) --------------------------------------------------------
void __cdecl sub_8062647(FILE *stream, int a2)
{
  int v2; // eax
  int v3; // eax
  signed __int32 v4; // eax
  signed __int32 v5; // edx
  int v6; // ecx
  signed __int32 v7; // ecx
  signed __int32 v8; // et1

  if ( stream )
  {
    v2 = fileno(stream);
    v3 = sub_80625F6(v2, 0, 0, 0, 0, a2);
    dword_806C14C = (int)&locret_8062663;
    v4 = _InterlockedExchange(&dword_806C150, v3);
    _InterlockedExchange(&dword_806C150, v5);
    _InterlockedExchange(&dword_806C150, v4);
    v8 = _InterlockedExchange(&dword_806C150, sub_80668ED(v6));
    _InterlockedExchange(&dword_806C150, v7);
    _InterlockedExchange(&dword_806C150, v8);
  }
}
// 80668ED: using guessed type int __fastcall sub_80668ED(_DWORD);
// 806C14C: using guessed type int dword_806C14C;
// 806C150: using guessed type int dword_806C150;

//----- (0806275C) --------------------------------------------------------
FILE *__cdecl sub_806275C(int a1, char *modes)
{
  int v2; // ST28_4
  FILE *v4; // eax
  signed int v5; // eax
  int v6; // ST2C_4
  FILE *stream; // [esp+1Ch] [ebp-1Ch]
  int fd; // [esp+24h] [ebp-14h]

  stream = (FILE *)fopen64(a1, modes);
  if ( !stream )
    return stream;
  v5 = fileno(stream);
  if ( v5 < 0 || v5 > 2 )
    return stream;
  fd = sub_8064797(v5);
  if ( fd < 0 )
  {
    v2 = *__errno_location();
    sub_80653A2(stream);
    *__errno_location() = v2;
    return 0;
  }
  if ( !sub_80653A2(stream) )
  {
    v4 = fdopen(fd, modes);
    stream = v4;
    if ( v4 )
      return stream;
  }
  v6 = *__errno_location();
  close(fd);
  *__errno_location() = v6;
  return 0;
}
// 8048E10: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (0806284A) --------------------------------------------------------
char *__cdecl sub_806284A(char *s)
{
  char *v1; // eax
  char *result; // eax
  char *v3; // [esp+18h] [ebp-10h]
  char *s1; // [esp+1Ch] [ebp-Ch]

  if ( !s )
  {
    fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
    abort();
  }
  v3 = strrchr(s, 47);
  if ( v3 )
    v1 = v3 + 1;
  else
    v1 = s;
  s1 = v1;
  if ( v1 - s > 6 && !strncmp(v1 - 7, "/.libs/", 7u) )
  {
    s = s1;
    if ( !strncmp(s1, "lt-", 3u) )
    {
      s = s1 + 3;
      program_invocation_short_name = (int)(s1 + 3);
    }
  }
  dword_806C67D = (int)s;
  result = s;
  program_invocation_name = (int)s;
  return result;
}
// 806C260: using guessed type int program_invocation_short_name;
// 806C270: using guessed type int program_invocation_name;
// 806C67D: using guessed type int dword_806C67D;

//----- (080629CA) --------------------------------------------------------
int __cdecl sub_80629CA(int *a1, unsigned __int8 a2, char a3)
{
  int *v3; // eax
  int v4; // ST10_4

  if ( a1 )
    v3 = a1;
  else
    v3 = &dword_806C695;
  v4 = ((unsigned int)v3[(a2 >> 5) + 2] >> (a2 & 0x1F)) & 1;
  v3[(a2 >> 5) + 2] ^= (v4 ^ a3 & 1) << (a2 & 0x1F);
  return v4;
}
// 806C695: using guessed type int dword_806C695;

//----- (08062A74) --------------------------------------------------------
int *__cdecl sub_8062A74(int *a1, int a2, int a3)
{
  int *result; // eax

  if ( !a1 )
    a1 = &dword_806C695;
  *a1 = 10;
  if ( !a2 || !a3 )
    abort();
  a1[10] = a2;
  result = a1;
  a1[11] = a3;
  return result;
}
// 806C695: using guessed type int dword_806C695;

//----- (08062AB5) --------------------------------------------------------
_DWORD *__userpurge sub_8062AB5@<eax>(_DWORD *a1, int a2)
{
  int v3; // [esp+0h] [ebp-38h]
  int v4; // [esp+4h] [ebp-34h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]

  memset(&v3, 0, 0x30u);
  if ( a2 == 10 )
    abort();
  *a1 = a2;
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = v6;
  a1[4] = v7;
  a1[5] = v8;
  a1[6] = v9;
  a1[7] = v10;
  a1[8] = v11;
  a1[9] = v12;
  a1[10] = v13;
  a1[11] = v14;
  return a1;
}

//----- (08062B37) --------------------------------------------------------
void *__usercall sub_8062B37@<eax>(signed __int32 a1@<ebx>, char *msgid, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  signed __int32 v10; // edx
  int v11; // ecx
  signed __int32 v12; // ebx
  signed __int32 v13; // edx
  signed __int32 v14; // et0
  signed __int32 v15; // edx
  signed __int32 v16; // et1
  void *result; // eax
  int v18; // eax
  signed __int32 v19; // eax
  signed __int32 v20; // ecx
  signed __int32 v21; // ebx
  signed __int32 v22; // ecx
  unsigned __int32 v23; // ett
  unsigned __int8 *v24; // [esp+1Ch] [ebp-Ch]

  if ( gettext(msgid) != msgid )
  {
    dword_806C1BC = (int)&locret_8062BC9;
    v12 = _InterlockedExchange(&dword_806C1C0, a1);
    v14 = _InterlockedExchange(&dword_806C1C0, v10);
    v13 = v12;
    a1 = v14;
    v16 = _InterlockedExchange(&dword_806C1C0, sub_80665CD(v11, _InterlockedExchange(&dword_806C1C0, v13)));
    _InterlockedExchange(&dword_806C1C0, v15);
    _InterlockedExchange(&dword_806C1C0, v16);
  }
  v24 = (unsigned __int8 *)sub_8065F31();
  if ( sub_80657C2(v24, "UTF-8") )
  {
    v18 = sub_80657C2(v24, "GB18030");
    dword_806C14C = (int)&loc_8062BF6;
    v19 = _InterlockedExchange(&dword_806C150, v18);
    _InterlockedExchange(&dword_806C150, v20);
    sub_80668ED(_InterlockedExchange(&dword_806C150, v19));
    v21 = _InterlockedExchange(&dword_806C150, a1);
    v23 = _InterlockedExchange(&dword_806C150, v22);
    _InterlockedExchange(&dword_806C150, v21);
    result = (void *)sub_8062C88(v23, msgid, a3, (const char *)a4, a5, a6, a7, a8, (char *)a9, (const char *)a10);
  }
  else if ( *msgid == 96 )
  {
    result = &unk_8067BBE;
  }
  else
  {
    result = &unk_8067BC2;
  }
  return result;
}
// 80665CD: using guessed type int __fastcall sub_80665CD(_DWORD, _DWORD);
// 80668ED: using guessed type int __fastcall sub_80668ED(_DWORD);
// 806C14C: using guessed type int dword_806C14C;
// 806C150: using guessed type int dword_806C150;
// 806C1BC: using guessed type int dword_806C1BC;
// 806C1C0: using guessed type int dword_806C1C0;

//----- (08062C88) --------------------------------------------------------
int __usercall sub_8062C88@<eax>(unsigned __int32 a1@<ebx>, _BYTE *a2, unsigned int a3, const char *a4, unsigned int a5, int a6, int a7, int a8, char *a9, const char *a10)
{
  signed __int32 v10; // edx
  int v11; // ecx
  signed __int32 v12; // eax
  signed __int32 v13; // ebx
  signed __int32 v14; // ecx
  signed __int32 v15; // ecx
  unsigned __int32 v16; // et1
  int v17; // ST18_4
  int v18; // ST1C_4
  int v19; // ST20_4
  int v20; // ST24_4
  int v21; // ST28_4
  int v22; // ST2C_4
  int v23; // ST30_4
  unsigned __int32 v24; // eax
  char v25; // al
  bool v26; // zf
  bool v27; // sf
  unsigned __int8 v28; // of
  void *v29; // eax
  void *v30; // eax
  void *v31; // eax
  signed __int32 v32; // edx
  signed __int32 v33; // ebx
  signed __int32 v34; // ebx
  signed __int32 v35; // ecx
  signed __int32 v36; // ecx
  unsigned __int32 v37; // ett
  void *v38; // eax
  int (__fastcall *v39)(_DWORD); // eax
  signed __int32 v40; // ebx
  int result; // eax
  void *v42; // eax
  signed __int32 v43; // eax
  signed __int32 v44; // ecx
  signed __int32 v45; // et2
  void *v46; // eax
  int (__fastcall *v47)(_DWORD); // eax
  signed __int32 v48; // ebx
  void *v49; // eax
  int (__fastcall *v50)(_DWORD); // eax
  signed __int32 v51; // ebx
  signed __int32 v52; // et0
  signed __int32 v53; // edx
  signed __int32 v54; // et1
  signed __int32 v55; // ebx
  signed __int32 v56; // ecx
  bool v57; // al
  void *v58; // eax
  int v59; // [esp+0h] [ebp-88h]
  int v60; // [esp+8h] [ebp-80h]
  int v61; // [esp+Ch] [ebp-7Ch]
  int v62; // [esp+10h] [ebp-78h]
  int v63; // [esp+14h] [ebp-74h]
  int v64; // [esp+18h] [ebp-70h]
  int v65; // [esp+1Ch] [ebp-6Ch]
  int v66; // [esp+20h] [ebp-68h]
  const char *v67; // [esp+2Ch] [ebp-5Ch]
  char *v68; // [esp+30h] [ebp-58h]
  char v69; // [esp+40h] [ebp-48h]
  bool v70; // [esp+41h] [ebp-47h]
  char v71; // [esp+42h] [ebp-46h]
  char v72; // [esp+43h] [ebp-45h]
  char v73; // [esp+44h] [ebp-44h]
  unsigned __int8 v74; // [esp+45h] [ebp-43h]
  char v75; // [esp+46h] [ebp-42h]
  char v76; // [esp+47h] [ebp-41h]
  char v77; // [esp+48h] [ebp-40h]
  char v78; // [esp+49h] [ebp-3Fh]
  bool v79; // [esp+4Bh] [ebp-3Dh]
  int v80; // [esp+50h] [ebp-38h]
  unsigned int v81; // [esp+54h] [ebp-34h]
  unsigned int v82; // [esp+54h] [ebp-34h]
  unsigned int v83; // [esp+54h] [ebp-34h]
  unsigned int v84; // [esp+54h] [ebp-34h]
  unsigned int v85; // [esp+54h] [ebp-34h]
  unsigned int v86; // [esp+54h] [ebp-34h]
  unsigned int v87; // [esp+54h] [ebp-34h]
  unsigned int v88; // [esp+54h] [ebp-34h]
  unsigned int v89; // [esp+54h] [ebp-34h]
  unsigned int v90; // [esp+54h] [ebp-34h]
  unsigned int v91; // [esp+54h] [ebp-34h]
  unsigned int v92; // [esp+58h] [ebp-30h]
  char *s; // [esp+5Ch] [ebp-2Ch]
  char *sa; // [esp+5Ch] [ebp-2Ch]
  size_t n; // [esp+60h] [ebp-28h]

  v68 = a9;
  v67 = a10;
  v81 = 0;
  v92 = 0;
  s = 0;
  n = 0;
  v69 = 0;
  v79 = __ctype_get_mb_cur_max() == 1;
  v70 = (a7 & 2) != 0;
  v71 = 0;
  v72 = 0;
  v73 = 1;
  switch ( a6 )
  {
    case 0:
      v70 = 0;
      goto LABEL_29;
    case 1:
      goto LABEL_19;
    case 2:
      goto LABEL_22;
    case 3:
      v69 = 1;
LABEL_19:
      v70 = 1;
      goto LABEL_20;
    case 4:
LABEL_20:
      if ( v70 != 1 )
        v69 = 1;
LABEL_22:
      a6 = 2;
      if ( v70 != 1 )
      {
        if ( a3 > 0 )
          *a2 = 39;
        v81 = 1;
      }
      s = "'";
      n = 1;
      goto LABEL_29;
    case 5:
      goto LABEL_3;
    case 6:
      a6 = 5;
      v70 = 1;
LABEL_3:
      if ( v70 != 1 )
      {
        if ( a3 > 0 )
          *a2 = 34;
        v81 = 1;
      }
      v69 = 1;
      s = (char *)&unk_8067BD5;
      n = 1;
      goto LABEL_29;
    case 7:
      v70 = 0;
      dword_806C160 = (int)&loc_8062E80;
      v12 = _InterlockedExchange(&dword_806C164, a6);
      _InterlockedExchange(&dword_806C164, v10);
      sub_8066852(v11, _InterlockedExchange(&dword_806C164, v12));
      v13 = _InterlockedExchange(&dword_806C164, a1);
      v16 = _InterlockedExchange(&dword_806C164, v14);
      v15 = v13;
      a1 = v16;
      _InterlockedExchange(&dword_806C164, v15);
      break;
    case 8:
    case 9:
    case 10:
      break;
    default:
      abort();
      return result;
  }
  if ( a6 != 10 )
  {
    v68 = (char *)sub_8062B37(a1, "`", a6, v60, v61, v62, v63, v64, v65, v66);
    v67 = (const char *)sub_8062B37(a1, "'", a6, v17, v18, v19, v20, v21, v22, v23);
  }
  if ( v70 != 1 )
  {
    for ( sa = v68; *sa; ++sa )
    {
      if ( v81 < a3 )
        a2[v81] = *sa;
      ++v81;
    }
  }
  v69 = 1;
  s = (char *)v67;
  n = strlen(v67);
LABEL_29:
  v80 = 0;
  while ( 2 )
  {
    if ( a5 == -1 )
      v57 = a4[v80] != 0;
    else
      v57 = v80 != a5;
    if ( !v57 )
    {
      if ( !v81 && a6 == 2 && v70 )
        goto LABEL_185;
      if ( a6 == 2 && v70 != 1 && v72 )
      {
        v58 = &loc_8063C37;
        if ( !v73 )
          v58 = &loc_8063C80;
        dword_806C14C = (int)v58;
        sub_80668ED(v11);
        result = sub_8062C88(a1, a2, v92, a4, a5, 5, a7, a8, v68, v67);
      }
      else
      {
        if ( s && v70 != 1 )
        {
          while ( *s )
          {
            if ( v81 < a3 )
              a2[v81] = *s;
            ++v81;
            ++s;
          }
        }
        if ( v81 < a3 )
          a2[v81] = 0;
        result = v81;
      }
      return result;
    }
    v76 = 0;
    v77 = 0;
    v78 = 0;
    if ( v69 && a6 != 2 && n )
    {
      a1 = v80 + n;
      if ( a5 != -1 || n <= 1 )
      {
        v24 = a5;
      }
      else
      {
        v24 = strlen(a4);
        a5 = v24;
      }
      if ( a1 <= v24 && !memcmp(&a4[v80], s, n) )
      {
        if ( v70 )
          goto LABEL_185;
        v76 = 1;
      }
    }
    v74 = a4[v80];
    switch ( v74 )
    {
      case 0u:
        if ( v69 )
        {
          if ( v70 )
            goto LABEL_185;
          v77 = 1;
          if ( a6 == 2 )
          {
            if ( v81 < a3 )
              a2[v81] = 39;
            v82 = v81 + 1;
            if ( v82 < a3 )
              a2[v82] = 36;
            v83 = v82 + 1;
            if ( v83 < a3 )
              a2[v83] = 39;
            v81 = v83 + 1;
            v71 = 1;
          }
          if ( v81 < a3 )
            a2[v81] = 92;
          ++v81;
          if ( a6 != 2 && v80 + 1 < a5 && a4[v80 + 1] > 47 )
          {
            v25 = a4[v80 + 1];
            v28 = __OFSUB__(v25, 57);
            v26 = v25 == 57;
            v27 = (char)(v25 - 57) < 0;
            v29 = &loc_8063006;
            if ( !((unsigned __int8)(v27 ^ v28) | v26) )
              v29 = &loc_8063034;
            dword_806C110 = (int)v29;
            sub_8066A70(v11, v80 + 1, v59);
            if ( v81 < a3 )
              a2[v81] = 48;
            v84 = v81 + 1;
            if ( v84 < a3 )
              a2[v84] = 48;
            v81 = v84 + 1;
          }
          v74 = 48;
        }
        else if ( a7 & 1 )
        {
          goto LABEL_161;
        }
        goto LABEL_132;
      case 7u:
        v75 = 97;
        goto LABEL_102;
      case 8u:
        v75 = 98;
        goto LABEL_102;
      case 9u:
        v75 = 116;
        goto LABEL_100;
      case 0xAu:
        v75 = 110;
        goto LABEL_100;
      case 0xBu:
        dword_806C174 = (int)&loc_806327A;
        v32 = _InterlockedExchange(&dword_806C178, a1);
        v33 = _InterlockedExchange(&dword_806C178, (signed __int32)a4);
        sub_80667D6(v11, _InterlockedExchange(&dword_806C178, v32));
        v34 = _InterlockedExchange(&dword_806C178, v33);
        v37 = _InterlockedExchange(&dword_806C178, v35);
        v36 = v34;
        a1 = v37;
        v11 = _InterlockedExchange(&dword_806C178, v36);
        goto LABEL_93;
      case 0xCu:
        v75 = 102;
        goto LABEL_102;
      case 0xDu:
        v75 = 114;
        goto LABEL_100;
      case 0x20u:
      case 0x21u:
      case 0x22u:
      case 0x24u:
      case 0x26u:
      case 0x28u:
      case 0x29u:
      case 0x2Au:
      case 0x3Bu:
      case 0x3Cu:
      case 0x3Du:
      case 0x3Eu:
      case 0x5Bu:
      case 0x5Eu:
      case 0x60u:
      case 0x7Cu:
        goto LABEL_109;
      case 0x23u:
      case 0x7Eu:
        if ( v80 )
          goto LABEL_132;
LABEL_109:
        if ( a6 != 2 )
        {
          dword_806C124 = (int)&loc_8063976;
          v43 = _InterlockedExchange(&dword_806C128, v74);
          _InterlockedExchange(&dword_806C128, v11);
          v45 = _InterlockedExchange(&dword_806C128, sub_80669F3(_InterlockedExchange(&dword_806C128, v43)));
          _InterlockedExchange(&dword_806C128, v44);
          v11 = _InterlockedExchange(&dword_806C128, v45);
LABEL_114:
          v72 = 1;
          v78 = 1;
          if ( a6 == 2 )
          {
            if ( v70 )
              goto LABEL_185;
            v46 = &loc_806341A;
            if ( !a3 )
              v46 = &loc_806342D;
            dword_806C124 = (int)v46;
            sub_80669F3(v11);
            if ( !v92 )
            {
              v92 = a3;
              a3 = 0;
            }
            if ( v81 < a3 )
              a2[v81] = 39;
            v88 = v81 + 1;
            if ( v88 < a3 )
              a2[v88] = 92;
            v89 = v88 + 1;
            if ( v89 < a3 )
              a2[v89] = 39;
            v81 = v89 + 1;
            v71 = 0;
          }
LABEL_132:
          if ( v69 != 1 || a6 == 2 )
          {
            v49 = &loc_80639AB;
            if ( v70 != 1 )
              v49 = &loc_80639DD;
            dword_806C14C = (int)v49;
            sub_80668ED(v11);
          }
          if ( a8 && (v11 = v74 & 0x1F, (*(_DWORD *)(4 * (v74 >> 5) + a8) >> v11) & 1) || v76 == 1 )
          {
LABEL_140:
            if ( v70 )
              goto LABEL_185;
            v77 = 1;
            if ( a6 == 2 && v71 != 1 )
            {
              if ( v81 < a3 )
                a2[v81] = 39;
              v90 = v81 + 1;
              if ( v90 < a3 )
                a2[v90] = 36;
              v91 = v90 + 1;
              if ( v91 < a3 )
                a2[v91] = 39;
              v81 = v91 + 1;
              v71 = 1;
            }
            if ( v81 < a3 )
              a2[v81] = 92;
            ++v81;
          }
LABEL_153:
          if ( v71 )
          {
            v50 = (int (__fastcall *)(_DWORD))&loc_8063B56;
            if ( v77 == 1 )
              v50 = (int (__fastcall *)(_DWORD))&loc_8063B88;
            dword_806C1A8 = v50;
            dword_806C124 = (int)&loc_8063AD1;
            v51 = _InterlockedExchange(&dword_806C128, a1);
            v52 = _InterlockedExchange(&dword_806C128, v11);
            v54 = _InterlockedExchange(&dword_806C128, sub_80669F3(_InterlockedExchange(&dword_806C128, v51)));
            _InterlockedExchange(&dword_806C128, v53);
            _InterlockedExchange(&dword_806C128, v54);
            dword_806C1A4 = v59;
            v55 = _InterlockedExchange(&dword_806C1AC, v52);
            _InterlockedExchange(&dword_806C1AC, v56);
            return dword_806C1A8(_InterlockedExchange(&dword_806C1AC, v55));
          }
          if ( v81 < a3 )
            a2[v81] = v74;
          ++v81;
          if ( v78 != 1 )
            v73 = 0;
LABEL_161:
          ++v80;
          continue;
        }
        v42 = &loc_80633A4;
        if ( !v70 )
          v42 = &loc_80633A9;
        dword_806C160 = (int)v42;
        sub_8066852(v11, a4);
LABEL_185:
        if ( a6 == 2 && v69 )
          a6 = 4;
        return sub_8062C88(a1, a2, a3, a4, a5, a6, a7 & 0xFFFFFFFD, 0, v68, v67);
      case 0x25u:
      case 0x2Bu:
      case 0x2Cu:
      case 0x2Du:
      case 0x2Eu:
      case 0x2Fu:
      case 0x30u:
      case 0x31u:
      case 0x32u:
      case 0x33u:
      case 0x34u:
      case 0x35u:
      case 0x36u:
      case 0x37u:
      case 0x38u:
      case 0x39u:
      case 0x3Au:
      case 0x41u:
      case 0x42u:
      case 0x43u:
      case 0x44u:
      case 0x45u:
      case 0x46u:
      case 0x47u:
      case 0x48u:
      case 0x49u:
      case 0x4Au:
      case 0x4Bu:
      case 0x4Cu:
      case 0x4Du:
      case 0x4Eu:
      case 0x4Fu:
      case 0x50u:
      case 0x51u:
      case 0x52u:
      case 0x53u:
      case 0x54u:
      case 0x55u:
      case 0x56u:
      case 0x57u:
      case 0x58u:
      case 0x59u:
      case 0x5Au:
      case 0x5Du:
      case 0x5Fu:
      case 0x61u:
      case 0x62u:
      case 0x63u:
      case 0x64u:
      case 0x65u:
      case 0x66u:
      case 0x67u:
      case 0x68u:
      case 0x69u:
      case 0x6Au:
      case 0x6Bu:
      case 0x6Cu:
      case 0x6Du:
      case 0x6Eu:
      case 0x6Fu:
      case 0x70u:
      case 0x71u:
      case 0x72u:
      case 0x73u:
      case 0x74u:
      case 0x75u:
      case 0x76u:
      case 0x77u:
      case 0x78u:
      case 0x79u:
      case 0x7Au:
        v78 = 1;
        goto LABEL_132;
      case 0x27u:
        goto LABEL_114;
      case 0x3Fu:
        v30 = &loc_806306F;
        if ( a6 == 2 )
          v30 = &loc_8063079;
        dword_806C1BC = (int)v30;
        if ( sub_80665CD(v11, a4) == 5 && a7 & 4 && v80 + 2 < a5 )
        {
          v31 = &loc_8063102;
          if ( a4[v80 + 1] != 63 )
            v31 = &loc_80631A6;
          dword_806C188 = (int)v31;
          sub_8066751();
          switch ( a4[v80 + 2] )
          {
            case 33:
            case 39:
            case 40:
            case 41:
            case 45:
            case 47:
            case 60:
            case 61:
            case 62:
              if ( v70 )
                goto LABEL_185;
              v74 = a4[v80 + 2];
              v80 += 2;
              if ( v81 < a3 )
                a2[v81] = 63;
              v85 = v81 + 1;
              if ( v85 < a3 )
                a2[v85] = 34;
              v86 = v85 + 1;
              if ( v86 < a3 )
                a2[v86] = 34;
              v87 = v86 + 1;
              if ( v87 < a3 )
                a2[v87] = 63;
              v81 = v87 + 1;
              break;
            default:
              goto LABEL_132;
          }
        }
        goto LABEL_132;
      case 0x5Cu:
LABEL_93:
        v75 = v74;
        if ( a6 == 2 )
        {
          v38 = &loc_8063248;
          if ( !v70 )
            v38 = &loc_806324D;
          dword_806C138 = (int)v38;
          sub_806696A(v11);
          goto LABEL_185;
        }
        if ( v69 && v70 && n )
          goto LABEL_153;
LABEL_100:
        if ( a6 == 2 && v70 )
          goto LABEL_185;
LABEL_102:
        if ( !v69 )
          goto LABEL_132;
        v74 = v75;
        goto LABEL_140;
      case 0x7Bu:
      case 0x7Du:
        v39 = (int (__fastcall *)(_DWORD))&loc_8063350;
        if ( a5 != -1 )
          v39 = (int (__fastcall *)(_DWORD))&loc_8063360;
        dword_806C1A8 = v39;
        dword_806C1A4 = (int)&loc_8063350;
        v40 = _InterlockedExchange(&dword_806C1AC, a1);
        _InterlockedExchange(&dword_806C1AC, v11);
        return v39(_InterlockedExchange(&dword_806C1AC, v40));
      default:
        v47 = (int (__fastcall *)(_DWORD))&loc_806352F;
        if ( !v79 )
          v47 = (int (__fastcall *)(_DWORD))&loc_806355D;
        dword_806C1A8 = v47;
        dword_806C1A4 = (int)&loc_806352F;
        v48 = _InterlockedExchange(&dword_806C1AC, a1);
        _InterlockedExchange(&dword_806C1AC, v11);
        return v47(_InterlockedExchange(&dword_806C1AC, v48));
    }
  }
}
// 80665CD: using guessed type int __fastcall sub_80665CD(_DWORD, _DWORD);
// 8066751: using guessed type int sub_8066751(void);
// 80667D6: using guessed type int __fastcall sub_80667D6(_DWORD, _DWORD);
// 8066852: using guessed type int __fastcall sub_8066852(_DWORD, _DWORD);
// 80668ED: using guessed type int __fastcall sub_80668ED(_DWORD);
// 806696A: using guessed type int __fastcall sub_806696A(_DWORD);
// 80669F3: using guessed type int __fastcall sub_80669F3(_DWORD);
// 8066A70: using guessed type int __fastcall sub_8066A70(_DWORD, _DWORD, _DWORD);
// 806C110: using guessed type int dword_806C110;
// 806C124: using guessed type int dword_806C124;
// 806C128: using guessed type int dword_806C128;
// 806C138: using guessed type int dword_806C138;
// 806C14C: using guessed type int dword_806C14C;
// 806C160: using guessed type int dword_806C160;
// 806C164: using guessed type int dword_806C164;
// 806C174: using guessed type int dword_806C174;
// 806C178: using guessed type int dword_806C178;
// 806C188: using guessed type int dword_806C188;
// 806C1A4: using guessed type int dword_806C1A4;
// 806C1A8: using guessed type int (__fastcall *dword_806C1A8)(_DWORD);
// 806C1AC: using guessed type int dword_806C1AC;
// 806C1BC: using guessed type int dword_806C1BC;

//----- (08063E1D) --------------------------------------------------------
_BYTE *__cdecl sub_8063E1D(const char *a1, unsigned int a2, _DWORD *a3, int *a4)
{
  int *v4; // eax
  int *v5; // ST3C_4
  int v6; // ST40_4
  int v7; // ST44_4
  int size; // [esp+48h] [ebp-10h]
  _BYTE *v10; // [esp+4Ch] [ebp-Ch]

  if ( a4 )
    v4 = a4;
  else
    v4 = &dword_806C695;
  v5 = v4;
  v6 = *__errno_location();
  v7 = v5[1] | (a3 == 0);
  size = sub_8062C88(
           (unsigned __int32)(v5 + 2),
           0,
           0,
           a1,
           a2,
           *v5,
           v7,
           (int)(v5 + 2),
           (char *)v5[10],
           (const char *)v5[11])
       + 1;
  v10 = sub_8065171(size);
  sub_8062C88(
    (unsigned __int32)(v5 + 2),
    v10,
    size,
    a1,
    a2,
    *v5,
    v7,
    (int)(v5 + 2),
    (char *)v5[10],
    (const char *)v5[11]);
  *__errno_location() = v6;
  if ( a3 )
    *a3 = size - 1;
  return v10;
}
// 806C695: using guessed type int dword_806C695;

//----- (08063FC4) --------------------------------------------------------
_BYTE *__cdecl sub_8063FC4(signed int a1, const char *a2, unsigned int a3, int a4)
{
  int v4; // ecx
  void *v5; // eax
  size_t v6; // edx
  void *v7; // edx
  size_t v8; // ST4C_4
  bool v10; // [esp+37h] [ebp-21h]
  int *v11; // [esp+38h] [ebp-20h]
  _BYTE *ptr; // [esp+3Ch] [ebp-1Ch]
  int v13; // [esp+40h] [ebp-18h]
  int size; // [esp+44h] [ebp-14h]
  int v15; // [esp+48h] [ebp-10h]
  unsigned int v16; // [esp+4Ch] [ebp-Ch]

  v13 = *__errno_location();
  v11 = off_806C21C;
  if ( a1 < 0 )
    abort();
  if ( dword_806C210 <= a1 )
  {
    v10 = off_806C21C == &dword_806C214;
    if ( (unsigned int)a1 > 0xFFFFFFE )
      sub_8065369();
    v5 = &loc_806403E;
    if ( !v10 )
      v5 = &loc_8064045;
    dword_806C124 = (int)v5;
    sub_80669F3(v4);
    v11 = (int *)sub_80651AE(0, v6);
    off_806C21C = v11;
    if ( v10 )
    {
      v7 = off_806C218;
      *v11 = dword_806C214;
      v11[1] = (int)v7;
    }
    memset(&v11[2 * dword_806C210], 0, 8 * (a1 + 1 - dword_806C210));
    dword_806C210 = a1 + 1;
  }
  v8 = v11[2 * a1];
  ptr = (_BYTE *)v11[2 * a1 + 1];
  v15 = *(_DWORD *)(a4 + 4) | 1;
  v16 = sub_8062C88(
          a4 + 8,
          (_BYTE *)v11[2 * a1 + 1],
          v11[2 * a1],
          a2,
          a3,
          *(_DWORD *)a4,
          v15,
          a4 + 8,
          *(char **)(a4 + 40),
          *(const char **)(a4 + 44));
  if ( v8 <= v16 )
  {
    size = v16 + 1;
    v11[2 * a1] = v16 + 1;
    if ( ptr != (_BYTE *)&unk_806C6D5 )
      free(ptr);
    ptr = sub_8065171(size);
    v11[2 * a1 + 1] = (int)ptr;
    sub_8062C88(a4 + 8, ptr, size, a2, a3, *(_DWORD *)a4, v15, a4 + 8, *(char **)(a4 + 40), *(const char **)(a4 + 44));
  }
  *__errno_location() = v13;
  return ptr;
}
// 80669F3: using guessed type int __fastcall sub_80669F3(_DWORD);
// 806C124: using guessed type int dword_806C124;
// 806C210: using guessed type int dword_806C210;
// 806C214: using guessed type int dword_806C214;
// 806C218: using guessed type void *off_806C218;
// 806C21C: using guessed type int *off_806C21C;

//----- (08064206) --------------------------------------------------------
_BYTE *__cdecl sub_8064206(signed int a1, const char *a2)
{
  return sub_8063FC4(a1, a2, 0xFFFFFFFF, (int)&dword_806C695);
}
// 806C695: using guessed type int dword_806C695;

//----- (08064230) --------------------------------------------------------
_BYTE *__cdecl sub_8064230(signed int a1, const char *a2, unsigned int a3)
{
  return sub_8063FC4(a1, a2, a3, (int)&dword_806C695);
}
// 806C695: using guessed type int dword_806C695;

//----- (080642C6) --------------------------------------------------------
_BYTE *__cdecl sub_80642C6(signed int a1, int a2, const char *a3)
{
  char v4; // [esp+10h] [ebp-38h]

  sub_8062AB5(&v4, a2);
  return sub_8063FC4(a1, a3, 0xFFFFFFFF, (int)&v4);
}

//----- (08064304) --------------------------------------------------------
_BYTE *__cdecl sub_8064304(signed int a1, int a2, const char *a3, unsigned int a4)
{
  char v5; // [esp+10h] [ebp-38h]

  sub_8062AB5(&v5, a2);
  return sub_8063FC4(a1, a3, a4, (int)&v5);
}

//----- (08064434) --------------------------------------------------------
_BYTE *__cdecl sub_8064434(const char *a1, unsigned int a2, unsigned __int8 a3)
{
  int v4; // [esp+20h] [ebp-38h]
  int v5; // [esp+24h] [ebp-34h]
  int v6; // [esp+28h] [ebp-30h]
  int v7; // [esp+2Ch] [ebp-2Ch]
  int v8; // [esp+30h] [ebp-28h]
  int v9; // [esp+34h] [ebp-24h]
  int v10; // [esp+38h] [ebp-20h]
  int v11; // [esp+3Ch] [ebp-1Ch]
  int v12; // [esp+40h] [ebp-18h]
  int v13; // [esp+44h] [ebp-14h]
  int v14; // [esp+48h] [ebp-10h]
  int v15; // [esp+4Ch] [ebp-Ch]

  v4 = dword_806C695;
  v5 = dword_806C699;
  v6 = dword_806C69D;
  v7 = dword_806C6A1;
  v8 = dword_806C6A5;
  v9 = dword_806C6A9;
  v10 = dword_806C6AD;
  v11 = dword_806C6B1;
  v12 = dword_806C6B5;
  v13 = dword_806C6B9;
  v14 = dword_806C6BD;
  v15 = dword_806C6C1;
  sub_80629CA(&v4, a3, 1);
  return sub_8063FC4(0, a1, a2, (int)&v4);
}
// 806C695: using guessed type int dword_806C695;
// 806C699: using guessed type int dword_806C699;
// 806C69D: using guessed type int dword_806C69D;
// 806C6A1: using guessed type int dword_806C6A1;
// 806C6A5: using guessed type int dword_806C6A5;
// 806C6A9: using guessed type int dword_806C6A9;
// 806C6AD: using guessed type int dword_806C6AD;
// 806C6B1: using guessed type int dword_806C6B1;
// 806C6B5: using guessed type int dword_806C6B5;
// 806C6B9: using guessed type int dword_806C6B9;
// 806C6BD: using guessed type int dword_806C6BD;
// 806C6C1: using guessed type int dword_806C6C1;

//----- (080644DE) --------------------------------------------------------
_BYTE *__cdecl sub_80644DE(const char *a1, unsigned __int8 a2)
{
  return sub_8064434(a1, 0xFFFFFFFF, a2);
}

//----- (08064507) --------------------------------------------------------
_BYTE *__cdecl sub_8064507(const char *a1)
{
  return sub_80644DE(a1, 0x3Au);
}

//----- (08064544) --------------------------------------------------------
_BYTE *__cdecl sub_8064544(signed int a1, int a2, const char *a3)
{
  int v4; // [esp+10h] [ebp-68h]
  int v5; // [esp+14h] [ebp-64h]
  int v6; // [esp+18h] [ebp-60h]
  int v7; // [esp+1Ch] [ebp-5Ch]
  int v8; // [esp+20h] [ebp-58h]
  int v9; // [esp+24h] [ebp-54h]
  int v10; // [esp+28h] [ebp-50h]
  int v11; // [esp+2Ch] [ebp-4Ch]
  int v12; // [esp+30h] [ebp-48h]
  int v13; // [esp+34h] [ebp-44h]
  int v14; // [esp+38h] [ebp-40h]
  int v15; // [esp+3Ch] [ebp-3Ch]
  int v16; // [esp+40h] [ebp-38h]
  int v17; // [esp+44h] [ebp-34h]
  int v18; // [esp+48h] [ebp-30h]
  int v19; // [esp+4Ch] [ebp-2Ch]
  int v20; // [esp+50h] [ebp-28h]
  int v21; // [esp+54h] [ebp-24h]
  int v22; // [esp+58h] [ebp-20h]
  int v23; // [esp+5Ch] [ebp-1Ch]
  int v24; // [esp+60h] [ebp-18h]
  int v25; // [esp+64h] [ebp-14h]
  int v26; // [esp+68h] [ebp-10h]
  int v27; // [esp+6Ch] [ebp-Ch]

  sub_8062AB5(&v4, a2);
  v16 = v4;
  v17 = v5;
  v18 = v6;
  v19 = v7;
  v20 = v8;
  v21 = v9;
  v22 = v10;
  v23 = v11;
  v24 = v12;
  v25 = v13;
  v26 = v14;
  v27 = v15;
  sub_80629CA(&v16, 0x3Au, 1);
  return sub_8063FC4(a1, a3, 0xFFFFFFFF, (int)&v16);
}

//----- (080645E5) --------------------------------------------------------
_BYTE *__cdecl sub_80645E5(signed int a1, int a2, int a3, const char *a4)
{
  return sub_8064615(a1, a2, a3, a4, 0xFFFFFFFF);
}

//----- (08064615) --------------------------------------------------------
_BYTE *__cdecl sub_8064615(signed int a1, int a2, int a3, const char *a4, unsigned int a5)
{
  int v6; // [esp+10h] [ebp-38h]
  int v7; // [esp+14h] [ebp-34h]
  int v8; // [esp+18h] [ebp-30h]
  int v9; // [esp+1Ch] [ebp-2Ch]
  int v10; // [esp+20h] [ebp-28h]
  int v11; // [esp+24h] [ebp-24h]
  int v12; // [esp+28h] [ebp-20h]
  int v13; // [esp+2Ch] [ebp-1Ch]
  int v14; // [esp+30h] [ebp-18h]
  int v15; // [esp+34h] [ebp-14h]
  int v16; // [esp+38h] [ebp-10h]
  int v17; // [esp+3Ch] [ebp-Ch]

  v6 = dword_806C695;
  v7 = dword_806C699;
  v8 = dword_806C69D;
  v9 = dword_806C6A1;
  v10 = dword_806C6A5;
  v11 = dword_806C6A9;
  v12 = dword_806C6AD;
  v13 = dword_806C6B1;
  v14 = dword_806C6B5;
  v15 = dword_806C6B9;
  v16 = dword_806C6BD;
  v17 = dword_806C6C1;
  sub_8062A74(&v6, a2, a3);
  return sub_8063FC4(a1, a4, a5, (int)&v6);
}
// 806C695: using guessed type int dword_806C695;
// 806C699: using guessed type int dword_806C699;
// 806C69D: using guessed type int dword_806C69D;
// 806C6A1: using guessed type int dword_806C6A1;
// 806C6A5: using guessed type int dword_806C6A5;
// 806C6A9: using guessed type int dword_806C6A9;
// 806C6AD: using guessed type int dword_806C6AD;
// 806C6B1: using guessed type int dword_806C6B1;
// 806C6B5: using guessed type int dword_806C6B5;
// 806C6B9: using guessed type int dword_806C6B9;
// 806C6BD: using guessed type int dword_806C6BD;
// 806C6C1: using guessed type int dword_806C6C1;

//----- (0806470F) --------------------------------------------------------
_BYTE *__cdecl sub_806470F(signed int a1, const char *a2, unsigned int a3)
{
  return sub_8063FC4(a1, a2, a3, (int)&unk_806C230);
}

//----- (0806475A) --------------------------------------------------------
_BYTE *__cdecl sub_806475A(signed int a1, const char *a2)
{
  return sub_806470F(a1, a2, 0xFFFFFFFF);
}

//----- (08064797) --------------------------------------------------------
int __cdecl sub_8064797(int fd)
{
  return sub_806547E(fd, 0, 3);
}

//----- (080647BA) --------------------------------------------------------
int __usercall sub_80647BA@<eax>(signed __int32 a1@<ebx>, FILE *stream, int a3, int a4, int a5, int a6, int a7)
{
  signed __int32 v7; // ebx
  signed __int32 v8; // ecx
  signed __int32 v9; // et0
  int v10; // edx
  signed __int32 v11; // ebx
  signed __int32 v12; // edx
  char *v13; // eax
  char *v14; // eax
  int v15; // ebx
  char *v16; // eax
  int result; // eax
  int v18; // esi
  int v19; // ebx
  char *v20; // eax
  int v21; // edi
  int v22; // esi
  int v23; // ebx
  char *v24; // eax
  int v25; // ST4C_4
  int v26; // edi
  int v27; // esi
  int v28; // ebx
  char *v29; // eax
  int v30; // ST4C_4
  int v31; // ST48_4
  int v32; // edi
  int v33; // esi
  int v34; // ebx
  char *v35; // eax
  int v36; // ST4C_4
  int v37; // ST48_4
  int v38; // ST44_4
  int v39; // edi
  int v40; // esi
  int v41; // ebx
  char *v42; // eax
  int v43; // esi
  int v44; // ST4C_4
  int v45; // ST48_4
  int v46; // ST44_4
  int v47; // ST40_4
  int v48; // edi
  int v49; // ebx
  char *v50; // eax
  int v51; // edi
  int v52; // ST4C_4
  int v53; // ST48_4
  int v54; // ST44_4
  int v55; // ST40_4
  int v56; // ST3C_4
  int v57; // esi
  int v58; // ebx
  char *v59; // eax
  int v60; // edi
  int v61; // ST4C_4
  int v62; // ST48_4
  int v63; // ST44_4
  int v64; // ST40_4
  int v65; // ST3C_4
  int v66; // ST38_4
  int v67; // esi
  int v68; // ebx
  char *v69; // eax
  int v70; // edi
  int v71; // ST4C_4
  int v72; // ST48_4
  int v73; // ST44_4
  int v74; // ST40_4
  int v75; // ST3C_4
  int v76; // ST38_4
  int v77; // esi
  int v78; // ebx
  char *v79; // eax

  if ( a3 )
  {
    fprintf(stream, "%s (%s) %s\n", a3, a4, a5);
    dword_806C160 = (int)&loc_8064849;
    v7 = _InterlockedExchange(&dword_806C164, a1);
    v9 = _InterlockedExchange(&dword_806C164, v8);
    sub_8066852(_InterlockedExchange(&dword_806C164, v7), v10);
    v11 = _InterlockedExchange(&dword_806C164, v9);
    _InterlockedExchange(&dword_806C164, v12);
    _InterlockedExchange(&dword_806C164, v11);
  }
  fprintf(stream, "%s %s\n", a4, a5);
  v13 = gettext("(C)");
  fprintf(stream, "Copyright %s %d Free Software Foundation, Inc.", v13, 2017);
  v14 = gettext(
          "\n"
          "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\n"
          "This is free software: you are free to change and redistribute it.\n"
          "There is NO WARRANTY, to the extent permitted by law.\n"
          "\n");
  fputs_unlocked(v14, stream);
  switch ( a7 )
  {
    case 0:
      abort();
      return result;
    case 1:
      v15 = *(_DWORD *)a6;
      v16 = gettext("Written by %s.\n");
      result = fprintf(stream, v16, v15);
      break;
    case 2:
      v18 = *(_DWORD *)(a6 + 4);
      v19 = *(_DWORD *)a6;
      v20 = gettext("Written by %s and %s.\n");
      result = fprintf(stream, v20, v19, v18);
      break;
    case 3:
      v21 = *(_DWORD *)(a6 + 8);
      v22 = *(_DWORD *)(a6 + 4);
      v23 = *(_DWORD *)a6;
      v24 = gettext("Written by %s, %s, and %s.\n");
      result = fprintf(stream, v24, v23, v22, v21);
      break;
    case 4:
      v25 = *(_DWORD *)(a6 + 12);
      v26 = *(_DWORD *)(a6 + 8);
      v27 = *(_DWORD *)(a6 + 4);
      v28 = *(_DWORD *)a6;
      v29 = gettext("Written by %s, %s, %s,\nand %s.\n");
      result = fprintf(stream, v29, v28, v27, v26, v25);
      break;
    case 5:
      v30 = *(_DWORD *)(a6 + 16);
      v31 = *(_DWORD *)(a6 + 12);
      v32 = *(_DWORD *)(a6 + 8);
      v33 = *(_DWORD *)(a6 + 4);
      v34 = *(_DWORD *)a6;
      v35 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
      result = fprintf(stream, v35, v34, v33, v32, v31, v30);
      break;
    case 6:
      v36 = *(_DWORD *)(a6 + 20);
      v37 = *(_DWORD *)(a6 + 16);
      v38 = *(_DWORD *)(a6 + 12);
      v39 = *(_DWORD *)(a6 + 8);
      v40 = *(_DWORD *)(a6 + 4);
      v41 = *(_DWORD *)a6;
      v42 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
      result = fprintf(stream, v42, v41, v40, v39, v38, v37, v36);
      break;
    case 7:
      v43 = *(_DWORD *)(a6 + 24);
      v44 = *(_DWORD *)(a6 + 20);
      v45 = *(_DWORD *)(a6 + 16);
      v46 = *(_DWORD *)(a6 + 12);
      v47 = *(_DWORD *)(a6 + 8);
      v48 = *(_DWORD *)(a6 + 4);
      v49 = *(_DWORD *)a6;
      v50 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
      result = fprintf(stream, v50, v49, v48, v47, v46, v45, v44, v43);
      break;
    case 8:
      v51 = *(_DWORD *)(a6 + 28);
      v52 = *(_DWORD *)(a6 + 24);
      v53 = *(_DWORD *)(a6 + 20);
      v54 = *(_DWORD *)(a6 + 16);
      v55 = *(_DWORD *)(a6 + 12);
      v56 = *(_DWORD *)(a6 + 8);
      v57 = *(_DWORD *)(a6 + 4);
      v58 = *(_DWORD *)a6;
      v59 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
      result = fprintf(stream, v59, v58, v57, v56, v55, v54, v53, v52, v51);
      break;
    case 9:
      v60 = *(_DWORD *)(a6 + 32);
      v61 = *(_DWORD *)(a6 + 28);
      v62 = *(_DWORD *)(a6 + 24);
      v63 = *(_DWORD *)(a6 + 20);
      v64 = *(_DWORD *)(a6 + 16);
      v65 = *(_DWORD *)(a6 + 12);
      v66 = *(_DWORD *)(a6 + 8);
      v67 = *(_DWORD *)(a6 + 4);
      v68 = *(_DWORD *)a6;
      v69 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
      result = fprintf(stream, v69, v68, v67, v66, v65, v64, v63, v62, v61, v60);
      break;
    default:
      v70 = *(_DWORD *)(a6 + 32);
      v71 = *(_DWORD *)(a6 + 28);
      v72 = *(_DWORD *)(a6 + 24);
      v73 = *(_DWORD *)(a6 + 20);
      v74 = *(_DWORD *)(a6 + 16);
      v75 = *(_DWORD *)(a6 + 12);
      v76 = *(_DWORD *)(a6 + 8);
      v77 = *(_DWORD *)(a6 + 4);
      v78 = *(_DWORD *)a6;
      v79 = gettext(aWrittenBySSSS);
      result = fprintf(stream, v79, v78, v77, v76, v75, v74, v73, v72, v71, v70);
      break;
  }
  return result;
}
// 8048F20: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8066852: using guessed type int __fastcall sub_8066852(_DWORD, _DWORD);
// 806C160: using guessed type int dword_806C160;
// 806C164: using guessed type int dword_806C164;

//----- (08064D54) --------------------------------------------------------
int __usercall sub_8064D54@<eax>(signed __int32 a1@<edx>, int a2@<ecx>, signed __int32 a3@<ebx>)
{
  signed __int32 v3; // ebx
  signed __int32 v4; // et0
  signed __int32 v5; // ecx
  signed __int32 v6; // et1
  signed __int32 v7; // edx
  signed __int32 v8; // eax
  signed __int32 v9; // et2
  signed __int32 v10; // edx
  signed __int32 v11; // eax
  signed __int32 v12; // ett
  signed __int32 v13; // ecx
  signed __int32 v14; // ebx
  signed __int32 v15; // et0
  signed __int32 v16; // edx
  signed __int32 v17; // eax
  signed __int32 v18; // et1
  signed __int32 v19; // edx
  signed __int32 v20; // eax
  signed __int32 v21; // et2
  signed __int32 v22; // ecx
  signed __int32 v23; // ebx
  signed __int32 v24; // ett
  signed __int32 v25; // ecx
  signed __int32 v26; // ebx
  signed __int32 v27; // et0
  signed __int32 v28; // edx
  signed __int32 v29; // ebx
  signed __int32 v30; // et1
  signed __int32 v31; // eax
  signed __int32 v32; // et2
  signed __int32 v33; // edx
  signed __int32 v34; // eax
  signed __int32 v35; // ebx
  int result; // eax
  signed __int32 v37; // ett

  dword_806C160 = (int)&loc_8064D9C;
  v3 = _InterlockedExchange(&dword_806C164, a3);
  v4 = _InterlockedExchange(&dword_806C164, a1);
  v6 = _InterlockedExchange(&dword_806C164, sub_8066852(a2, _InterlockedExchange(&dword_806C164, v3)));
  v9 = _InterlockedExchange(&dword_806C1E0, _InterlockedExchange(&dword_806C164, v5));
  v8 = _InterlockedExchange(&dword_806C1E0, v7);
  v10 = _InterlockedExchange(&dword_806C1E0, v9);
  v12 = _InterlockedExchange(&dword_806C1E0, v8);
  v11 = _InterlockedExchange(&dword_806C1E0, _InterlockedExchange(&dword_806C164, v6));
  v13 = _InterlockedExchange(&dword_806C1E0, v12);
  v14 = _InterlockedExchange(&dword_806C1E0, v4);
  v15 = _InterlockedExchange(&dword_806C1E0, v10);
  v16 = _InterlockedExchange(&dword_806C1E0, v14);
  v18 = _InterlockedExchange(&dword_806C1E0, v11);
  v17 = _InterlockedExchange(&dword_806C1E0, v16);
  v19 = _InterlockedExchange(&dword_806C1E0, v18);
  v21 = _InterlockedExchange(&dword_806C1E0, v17);
  v20 = _InterlockedExchange(&dword_806C1E0, v13);
  v22 = _InterlockedExchange(&dword_806C1E0, v21);
  v23 = _InterlockedExchange(&dword_806C1E0, v15);
  v24 = _InterlockedExchange(&dword_806C1E0, v22);
  v25 = _InterlockedExchange(&dword_806C1E0, v23);
  v26 = _InterlockedExchange(&dword_806C1E0, v24);
  v27 = _InterlockedExchange(&dword_806C1E0, v19);
  v28 = _InterlockedExchange(&dword_806C1E0, v26);
  v29 = _InterlockedExchange(&dword_806C1E0, v27);
  v30 = _InterlockedExchange(&dword_806C1E0, v25);
  _InterlockedExchange(&dword_806C1E0, v29);
  v32 = _InterlockedExchange(&dword_806C1E0, v20);
  v31 = _InterlockedExchange(&dword_806C1E0, v28);
  v33 = _InterlockedExchange(&dword_806C1E0, v32);
  v34 = _InterlockedExchange(&dword_806C1E0, v31);
  v35 = _InterlockedExchange(&dword_806C1E0, v30);
  v37 = v34;
  result = _InterlockedExchange(&dword_806C1E0, v33);
  _InterlockedExchange(&dword_806C1E0, _InterlockedExchange(&dword_806C1E0, v37));
  _InterlockedExchange(&dword_806C1E0, v35);
  return result;
}
// 8066852: using guessed type int __fastcall sub_8066852(_DWORD, _DWORD);
// 806C160: using guessed type int dword_806C160;
// 806C164: using guessed type int dword_806C164;
// 806C1E0: using guessed type int dword_806C1E0;

//----- (08064ECF) --------------------------------------------------------
int __usercall sub_8064ECF@<eax>(signed __int32 a1@<edx>, int a2@<ecx>, signed __int32 a3@<ebx>)
{
  return sub_8064D54(a1, a2, a3);
}

//----- (08065038) --------------------------------------------------------
void *__cdecl sub_8065038(void *ptr, int a2, int a3)
{
  unsigned int v4; // [esp+1Ch] [ebp-Ch]

  v4 = *(_DWORD *)a2;
  if ( ptr )
  {
    if ( 0x55555554u / a3 <= v4 )
      sub_8065369();
    v4 += (v4 >> 1) + 1;
  }
  else
  {
    if ( !v4 )
      v4 = (0x40u / a3 == 0) + 0x40u / a3;
    if ( 0x7FFFFFFFu / a3 < v4 )
      sub_8065369();
  }
  *(_DWORD *)a2 = v4;
  return sub_80651AE(ptr, a3 * v4);
}

//----- (08065171) --------------------------------------------------------
void *__cdecl sub_8065171(size_t size)
{
  return sub_8065184(size);
}

//----- (08065184) --------------------------------------------------------
void *__cdecl sub_8065184(size_t size)
{
  void *v2; // [esp+1Ch] [ebp-Ch]

  v2 = malloc(size);
  if ( !v2 && size )
    sub_8065369();
  return v2;
}

//----- (080651AE) --------------------------------------------------------
void *__cdecl sub_80651AE(void *ptr, size_t size)
{
  void *result; // eax
  void *ptra; // [esp+20h] [ebp+8h]

  if ( size || !ptr )
  {
    ptra = realloc(ptr, size);
    if ( !ptra )
    {
      if ( size )
        sub_8065369();
    }
    result = ptra;
  }
  else
  {
    free(ptr);
    result = 0;
  }
  return result;
}

//----- (0806531B) --------------------------------------------------------
void *__cdecl sub_806531B(void *src, size_t n)
{
  void *v2; // eax

  v2 = sub_8065184(n);
  return memcpy(v2, src, n);
}

//----- (08065369) --------------------------------------------------------
void __noreturn sub_8065369()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (080653A2) --------------------------------------------------------
int __cdecl sub_80653A2(FILE *stream)
{
  int v2; // eax
  bool v3; // zf
  __int64 v4; // rax
  int v5; // [esp+14h] [ebp-14h]
  int v6; // [esp+18h] [ebp-10h]

  v5 = 0;
  if ( fileno(stream) < 0 )
    return fclose(stream);
  if ( __freading(stream) )
  {
    v2 = fileno(stream);
    LODWORD(v4) = lseek64(v2, 0, 0, 1);
    v3 = v4 == -1;
    LODWORD(v4) = &loc_806543B;
    if ( v3 )
      LODWORD(v4) = &loc_8065454;
    dword_806C160 = v4;
    sub_8066852(~HIDWORD(v4), HIDWORD(v4));
  }
  if ( sub_8065621(stream) )
    v5 = *__errno_location();
  v6 = fclose(stream);
  if ( v5 )
  {
    *__errno_location() = v5;
    v6 = -1;
  }
  return v6;
}
// 8049030: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8066852: using guessed type int __fastcall sub_8066852(_DWORD, _DWORD);
// 806C160: using guessed type int dword_806C160;

//----- (0806547E) --------------------------------------------------------
int __cdecl sub_806547E(int fd, int cmd, char a3)
{
  int v3; // ST28_4
  int v5; // [esp+1Ch] [ebp-1Ch]
  char v6; // [esp+20h] [ebp-18h]
  int v7; // [esp+24h] [ebp-14h]

  if ( cmd != 1030 )
    return fcntl(fd, cmd, a3);
  v6 = a3;
  if ( dword_806C7D5 < 0 )
  {
    v5 = sub_806547E(fd, 0, a3);
  }
  else
  {
    v5 = fcntl(fd, 1030, a3);
    if ( v5 < 0 && *__errno_location() == 22 )
    {
      v5 = sub_806547E(fd, 0, v6);
      if ( v5 < 0 )
        return v5;
      dword_806C7D5 = -1;
    }
    else
    {
      dword_806C7D5 = 1;
    }
  }
  if ( v5 >= 0 && dword_806C7D5 == -1 )
  {
    v7 = fcntl(v5, 1);
    if ( v7 < 0 || fcntl(v5, 2, v7 | 1) == -1 )
    {
      v3 = *__errno_location();
      close(v5);
      *__errno_location() = v3;
      v5 = -1;
    }
  }
  return v5;
}
// 806C7D5: using guessed type int dword_806C7D5;

//----- (080655E8) --------------------------------------------------------
int __cdecl sub_80655E8(FILE *stream)
{
  int result; // eax

  result = stream->_flags & 0x100;
  if ( result )
    result = sub_8065661(stream, 0, 0, 1);
  return result;
}

//----- (08065621) --------------------------------------------------------
int __cdecl sub_8065621(FILE *fp)
{
  if ( !fp || !__freading(fp) )
    return fflush(fp);
  sub_80655E8(fp);
  return fflush(fp);
}

//----- (08065661) --------------------------------------------------------
int __cdecl sub_8065661(FILE *stream, int a2, int a3, int a4)
{
  void *v4; // eax
  int v5; // eax
  __off64_t v6; // rax

  v4 = &loc_806569C;
  if ( stream->_IO_read_end != stream->_IO_read_ptr )
    v4 = &loc_8065726;
  dword_806C188 = (int)v4;
  sub_8066751();
  if ( stream->_IO_write_ptr != stream->_IO_write_base || stream->_IO_save_base )
    return fseeko64(stream, a2, a3, a4);
  v5 = fileno(stream);
  LODWORD(v6) = lseek64(v5, a2, a3, a4);
  if ( v6 == -1 )
    return -1;
  stream->_flags &= 0xFFFFFFEF;
  stream->_offset = v6;
  return 0;
}
// 8048DC0: using guessed type int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8049030: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8066751: using guessed type int sub_8066751(void);
// 806C188: using guessed type int dword_806C188;

//----- (08065748) --------------------------------------------------------
size_t __cdecl sub_8065748(wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  char v5; // [esp+18h] [ebp-10h]
  size_t v6; // [esp+1Ch] [ebp-Ch]

  if ( !pwc )
    pwc = (wchar_t *)&v5;
  v6 = mbrtowc(pwc, s, n, p);
  if ( v6 <= 0xFFFFFFFD || !n || !((unsigned __int8)sub_80658D6(0) ^ 1) )
    return v6;
  *pwc = (unsigned __int8)*s;
  return 1;
}

//----- (080657C2) --------------------------------------------------------
int __cdecl sub_80657C2(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // esi
  unsigned __int8 *v3; // ebx
  unsigned __int8 v5; // al
  unsigned __int8 v6; // [esp+1Eh] [ebp-Ah]

  v2 = a1;
  v3 = a2;
  if ( a1 == a2 )
    return 0;
  do
  {
    v6 = sub_80661A6(*v2);
    v5 = sub_80661A6(*v3);
    if ( !v6 )
      break;
    ++v2;
    ++v3;
  }
  while ( v6 == v5 );
  return v6 - v5;
}

//----- (08065855) --------------------------------------------------------
int __cdecl sub_8065855(FILE *fp)
{
  bool v1; // ST1E_1
  bool v3; // [esp+1Dh] [ebp-Bh]
  bool v4; // [esp+1Fh] [ebp-9h]

  v3 = __fpending(fp) != 0;
  v1 = ferror_unlocked(fp) != 0;
  v4 = sub_80653A2(fp) != 0;
  if ( !v1 && (!v4 || !v3 && *__errno_location() == 9) )
    return 0;
  if ( v4 != 1 )
    *__errno_location() = 0;
  return -1;
}

//----- (080658D6) --------------------------------------------------------
int __cdecl sub_80658D6(int category)
{
  unsigned __int8 v2; // [esp+1Bh] [ebp-Dh]
  const char *s1; // [esp+1Ch] [ebp-Ch]

  v2 = 1;
  s1 = setlocale(category, 0);
  if ( s1 && (!strcmp(s1, "C") || !strcmp(s1, "POSIX")) )
    v2 = 0;
  return v2;
}

//----- (08065934) --------------------------------------------------------
void *sub_8065934()
{
  int v0; // ecx
  void *v1; // eax
  signed __int32 v2; // eax
  signed __int32 v3; // ecx
  signed __int32 v4; // ecx
  signed __int32 v5; // et1
  bool v8; // zf
  int v9; // edx
  int v10; // ecx
  void *v11; // eax
  void *v13; // [esp+18h] [ebp-B0h]
  const char *s; // [esp+1Ch] [ebp-ACh]
  size_t n; // [esp+2Ch] [ebp-9Ch]
  size_t v16; // [esp+30h] [ebp-98h]
  char *dest; // [esp+38h] [ebp-90h]
  int fd; // [esp+3Ch] [ebp-8Ch]

  v13 = (void *)dword_806C7D9;
  if ( !dword_806C7D9 )
  {
    s = getenv("CHARSETALIASDIR");
    if ( !s || !*s )
      s = "/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib";
    n = strlen(s);
    v16 = strlen("charset.alias");
    if ( n )
    {
      v1 = &loc_8065A13;
      if ( s[n - 1] == 47 )
        v1 = &loc_8065A4D;
      dword_806C174 = (int)v1;
      sub_80667D6(v0, n - 1);
      dword_806C1D0 = (int)&loc_8065A52;
      v2 = _InterlockedExchange(&dword_806C1D4, 1);
      _InterlockedExchange(&dword_806C1D4, v3);
      v5 = _InterlockedExchange(&dword_806C1D4, sub_8066552(_InterlockedExchange(&dword_806C1D4, v2)));
      _InterlockedExchange(&dword_806C1D4, v4);
      _InterlockedExchange(&dword_806C1D4, v5);
    }
    dest = (char *)malloc(n + v16 + 1);
    if ( dest )
    {
      memcpy(dest, s, n);
      memcpy(&dest[n], "charset.alias", v16 + 1);
    }
    free(0);
    if ( dest )
    {
      fd = open64(dest, 0x20000);
      if ( fd >= 0 )
      {
        v8 = fdopen(fd, "r") == 0;
        v11 = &loc_8065B91;
        if ( !v8 )
          v11 = &loc_8065BAE;
        dword_806C160 = (int)v11;
        sub_8066852(v10, v9);
        close(fd);
        v13 = &unk_80682F3;
      }
      else
      {
        v13 = &unk_80682F3;
      }
      free(dest);
    }
    else
    {
      v13 = &unk_80682F3;
    }
    dword_806C7D9 = (int)&unk_80682F3;
  }
  return v13;
}
// 8048D10: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 8066552: using guessed type int __fastcall sub_8066552(_DWORD);
// 80667D6: using guessed type int __fastcall sub_80667D6(_DWORD, _DWORD);
// 8066852: using guessed type int __fastcall sub_8066852(_DWORD, _DWORD);
// 806C160: using guessed type int dword_806C160;
// 806C174: using guessed type int dword_806C174;
// 806C1D0: using guessed type int dword_806C1D0;
// 806C1D4: using guessed type int dword_806C1D4;
// 806C7D9: using guessed type int dword_806C7D9;

//----- (08065F31) --------------------------------------------------------
const char *sub_8065F31()
{
  char *v0; // ST1C_4
  const char *s1; // [esp+18h] [ebp-10h]
  char *s2; // [esp+1Ch] [ebp-Ch]

  s1 = nl_langinfo(14);
  if ( !s1 )
    s1 = (const char *)&unk_80682F3;
  for ( s2 = (char *)sub_8065934(); *s2; s2 = &v0[strlen(v0) + 1] )
  {
    if ( !strcmp(s1, s2) || *s2 == 42 && !s2[1] )
    {
      s1 = &s2[strlen(s2) + 1];
      break;
    }
    v0 = &s2[strlen(s2) + 1];
  }
  if ( !*s1 )
    s1 = "ASCII";
  return s1;
}

//----- (080661A6) --------------------------------------------------------
int __cdecl sub_80661A6(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 65) > 0x19 )
    result = a1;
  else
    result = a1 + 32;
  return result;
}

//----- (08066255) --------------------------------------------------------
__int64 __cdecl sub_8066255(int a1, unsigned int a2, unsigned int a3, int a4)
{
  void *v4; // eax
  unsigned int v5; // ecx
  unsigned int v6; // edx
  void *v8; // eax
  int v9; // ecx
  unsigned __int64 v10; // rtt

  v4 = &loc_806629F;
  if ( a4 )
    v4 = &loc_80662B6;
  dword_806C110 = (int)v4;
  sub_8066A70(a1, a4, a3);
  if ( a3 <= a2 )
  {
    v8 = &loc_806630D;
    if ( a3 )
      v8 = &loc_8066318;
    dword_806C124 = (int)v8;
    sub_80669F3(v5);
    LODWORD(v10) = v9;
    HIDWORD(v10) = a2 % (1 / a3);
    v6 = v10 % (1 / a3);
  }
  else
  {
    v6 = __PAIR__(a2, v5) % a3;
  }
  return v6;
}
// 8066255: could not find valid save-restore pair for ebx
// 80669F3: using guessed type int __fastcall sub_80669F3(_DWORD);
// 8066A70: using guessed type int __fastcall sub_8066A70(_DWORD, _DWORD, _DWORD);
// 806C110: using guessed type int dword_806C110;
// 806C124: using guessed type int dword_806C124;

//----- (0806644A) --------------------------------------------------------
int __cdecl sub_806644A(int a1)
{
  return __cxa_atexit(a1, 0, dword_806C1F4);
}
// 8048E80: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 806C1F4: using guessed type int dword_806C1F4;

//----- (08066511) --------------------------------------------------------
#error "806654A: positive sp value has been found (funcsize=18)"

//----- (08066552) --------------------------------------------------------
#error "8066558: positive sp value has been found (funcsize=0)"

//----- (080665CD) --------------------------------------------------------
#error "80665D3: positive sp value has been found (funcsize=0)"

//----- (08066628) --------------------------------------------------------
#error "8066661: positive sp value has been found (funcsize=18)"

//----- (08066751) --------------------------------------------------------
#error "8066757: positive sp value has been found (funcsize=0)"

//----- (080667D6) --------------------------------------------------------
#error "80667DC: positive sp value has been found (funcsize=0)"

//----- (08066852) --------------------------------------------------------
#error "8066858: positive sp value has been found (funcsize=0)"

//----- (080668AC) --------------------------------------------------------
#error "80668E5: positive sp value has been found (funcsize=18)"

//----- (080668ED) --------------------------------------------------------
#error "80668F3: positive sp value has been found (funcsize=0)"

//----- (0806696A) --------------------------------------------------------
#error "8066970: positive sp value has been found (funcsize=0)"

//----- (080669F3) --------------------------------------------------------
#error "80669F9: positive sp value has been found (funcsize=0)"

//----- (08066A70) --------------------------------------------------------
#error "8066A76: positive sp value has been found (funcsize=0)"

//----- (08066A90) --------------------------------------------------------
int (**sub_8066A90())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_806BED4;
  v1 = &off_806BED8 - off_806BED4;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_806BED4[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 806BED4: using guessed type int (*off_806BED4[2])();
// 806BED8: using guessed type int (*off_806BED8)();

//----- (08066AF4) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 14 decompilation failure(s) on 139 function(s)"
