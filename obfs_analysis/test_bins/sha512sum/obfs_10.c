/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8048CF0();
// int strcmp(const char *s1, const char *s2);
// int __fastcall open64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl getline(_DWORD, _DWORD, _DWORD); weak
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void _exit(int status);
// void free(void *ptr);
// void *memcpy(void *dest, const void *src, size_t n);
// int tolower(int c);
// int fclose(FILE *stream);
// int getc_unlocked(FILE *stream);
// int __fastcall fseeko64(_DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// char *textdomain(const char *domainname);
// int __cdecl fopen64(_DWORD, _DWORD); weak
// int ferror_unlocked(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// size_t __ctype_get_mb_cur_max(void);
// char *strcpy(char *dest, const char *src);
// size_t __fpending(FILE *fp);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// void error(int status, int errnum, const char *format, ...);
// size_t fread_unlocked(void *ptr, size_t size, size_t n, FILE *stream);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// char *strchr(const char *s, int c);
// int fscanf(FILE *stream, const char *format, ...);
// size_t strlen(const char *s);
// int fprintf(FILE *stream, const char *format, ...);
// int fcntl(int fd, int cmd, ...);
// int setvbuf(FILE *stream, char *buf, int modes, size_t n);
// void *memset(void *s, int c, size_t n);
// int ungetc(int c, FILE *stream);
// int *__errno_location(void);
// int fileno(FILE *stream);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// char *strrchr(const char *s, int c);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// char *bindtextdomain(const char *domainname, const char *dirname);
// int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// int feof_unlocked(FILE *stream);
// void abort(void);
// char *ngettext(const char *msgid1, const char *msgid2, unsigned int n);
// int close(int fd);
// const unsigned __int16 **__ctype_b_loc(void);
// int putchar_unlocked(int c);
// int _gmon_start__(void); weak
void sub_8049123();
void sub_8049140();
int sub_8049150();
int sub_80491C0();
int sub_80491E0();
void sub_804923F();
void sub_804925A();
int sub_804926A();
void sub_804934C();
void sub_8049367();
int sub_8049377();
void sub_8049459();
void sub_8049474();
int sub_8049484();
void sub_8049566();
void sub_8049581();
int sub_8049591();
void sub_8049673();
void sub_804968E();
int sub_804969E();
void sub_804979C();
void sub_80497B7();
int sub_80497C7();
void sub_80498DD();
void sub_80498F8();
int sub_8049908();
void sub_8049A06();
void sub_8049A21();
int __fastcall sub_8049A31(int a1, int a2);
// int __usercall sub_8049AB1@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
void sub_8049B48();
void sub_8049B63();
int sub_8049B73();
void sub_8049C55();
void sub_8049C70();
int sub_8049C80();
// int __usercall sub_8049CE7@<eax>(int a1@<eax>, int (__cdecl *a2)(int *, int)@<edx>);
void sub_8049D7E();
void sub_8049D99();
int sub_8049DA9();
int sub_8049DD5();
int sub_8049E33();
// int __usercall sub_8049E8D@<eax>(void (__cdecl *a1)(int *)@<eax>);
void sub_8049ED9();
void sub_8049EF4();
int sub_8049F04();
void sub_804A01B();
void sub_804A036();
int __fastcall sub_804A046(int a1, int a2);
void sub_804A15D();
void sub_804A178();
int sub_804A188();
// int __usercall sub_804A23A@<eax>(void (__cdecl *a1)(signed int)@<eax>);
void sub_804A286();
void sub_804A2A1();
int sub_804A2B1();
int nullsub_5(void); // weak
int sub_804A30F();
int sub_804A354();
void sub_804A3C8();
void sub_804A3E3();
int __fastcall sub_804A3F3(int a1, int a2);
void sub_804A53B();
void sub_804A556();
int __fastcall sub_804A566(int a1);
// int __usercall sub_804A5E6@<eax>(int a1@<eax>, int (__cdecl *a2)(const char *, int)@<edx>);
void sub_804A67D();
void sub_804A698();
int sub_804A6A8();
void sub_804A7D8();
void sub_804A7F3();
int __fastcall sub_804A803(int a1);
int __fastcall sub_804A8A6(int a1);
void sub_804A9F1();
void sub_804AA0C();
int sub_804AA1C();
int nullsub_7(void); // weak
int sub_804AA7A();
// int __usercall sub_804AAE7@<eax>(void (__cdecl *a1)(void **)@<eax>);
void sub_804AB33();
void sub_804AB4E();
int sub_804AB5E();
// int __usercall sub_804ACB6@<eax>(signed __int32 a1@<ebx>, unsigned __int64 a2);
unsigned int __cdecl sub_804AD04(int a1, unsigned int a2);
int sub_804AD36();
int __cdecl sub_804AD61(char *s1); // idb
int __cdecl sub_804AF4D(int a1);
void __cdecl __noreturn sub_804AF55(int status); // idb
// _BYTE *__usercall sub_804B0F5@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, _BYTE *a3, unsigned int a4);
// bool __usercall sub_804B248@<al>(signed __int32 a1@<eax>, signed __int32 a2@<edx>, int a3@<ecx>, _BYTE *a4);
// bool __usercall sub_804B39E@<al>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, _BYTE *a3, int a4, signed __int32 *a5, _DWORD *a6, char a7);
// bool __usercall sub_804B5CE@<al>(signed __int32 a1@<eax>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, signed __int32 a4, int a5, signed __int32 *a6, _DWORD *a7, _DWORD *a8);
// int __usercall sub_804BA2A@<eax>(signed __int32 a1@<ebx>, int ecx0@<ecx>, char *a2, char a3);
// int __usercall sub_804BB81@<eax>(signed __int32 a1@<ebx>, char *s1, int a3, int a4, int a5);
// int __usercall __noreturn sub_804BDB7@<eax>(int a1@<ebx>, const char *a2);
int sub_804C871(); // weak
// int __usercall main@<eax>(signed __int32 a1@<ebx>, int argc, char **a3);
// int __usercall sub_804D234@<eax>(signed __int32 a1@<ebx>);
_DWORD *__cdecl sub_804D365(_DWORD *a1);
_DWORD *__cdecl sub_804D41E(_DWORD *a1);
int __cdecl sub_804D4D7(_DWORD *a1, int a2, int a3);
// int __usercall sub_804D4F9@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, int a3, int a4);
// signed __int32 __usercall sub_804D7DB@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, int a3, signed __int32 a4);
int __cdecl sub_804DA3F(int a1);
// int __usercall sub_804E1AD@<eax>(signed __int32 a1@<ebx>, int a2, int a3);
// signed __int32 __usercall sub_804E1D2@<eax>(signed __int32 a1@<ebx>, int a2, signed __int32 a3);
// int __usercall sub_804E1F7@<eax>(signed __int32 a1@<ebx>, FILE *stream, int a3);
// int __usercall sub_804E398@<eax>(signed __int32 a1@<ebx>, FILE *stream, int a3);
int __cdecl sub_804E599(void *src, size_t, int); // idb
_DWORD __cdecl sub_804E816(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_8063060(int a1, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_80630B1@<eax>(signed __int32 a1@<ebx>, int a2@<edx>, int a3@<ecx>, FILE *stream);
int sub_80631A6(); // weak
// FILE *__usercall sub_8063241@<eax>(signed __int32 a1@<ebx>, int a2, char *modes);
// char *__usercall sub_806339C@<eax>(signed __int32 a1@<ebx>, char *s);
int __cdecl sub_8063595(int *a1, unsigned __int8 a2, char a3);
// void __usercall __noreturn sub_806363F(signed __int32 a1@<eax>, signed __int32 a2@<edx>, signed __int32 a3@<ecx>, _DWORD *a4, int a5, int a6);
int sub_80636FE(); // weak
// _DWORD *__userpurge sub_8063712@<eax>(_DWORD *a1, int a2);
// char *__usercall sub_8063794@<eax>(signed __int32 a1@<ebx>, char *msgid, int a3);
// unsigned int __usercall sub_8063882@<eax>(signed __int32 a1@<ebx>, signed __int32 a2, unsigned int a3, signed __int32 a4, size_t a5, signed int a6, int a7, int a8, char *a9, char *a10);
void *__cdecl sub_80649FD(signed __int32 a1, size_t a2, _DWORD *a3, int a4);
void *__cdecl sub_8064C8E(signed int a1, signed __int32 a2, size_t a3, int a4);
void *__cdecl sub_8064EB7(signed int a1, signed __int32 a2);
void *__cdecl sub_8064EE1(signed int a1, signed __int32 a2, size_t a3);
void *__cdecl sub_8064FF7(signed int a1, int a2, signed __int32 a3);
void *__cdecl sub_8065035(signed int a1, int a2, signed __int32 a3, size_t a4);
void *__cdecl sub_8065196(signed __int32 a1, size_t a2, unsigned __int8 a3);
void *__cdecl sub_8065240(signed __int32 a1, unsigned __int8 a2);
void *__cdecl sub_8065269(signed __int32 a1);
// int __usercall sub_8065388@<eax>(signed __int32 a1@<ebx>, signed int a2, int a3, signed __int32 a4);
// void __usercall __noreturn sub_80654F9(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, int a3, int a4, int a5);
// void __usercall __noreturn sub_8065529(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, int a3, int a4, int a5);
void *__cdecl sub_8065623(signed int a1, signed __int32 a2, size_t a3);
void *__cdecl sub_806566E(signed int a1, signed __int32 a2);
// int __usercall sub_8065761@<eax>(signed __int32 a1@<ebx>, int fd);
// int __usercall sub_8065784@<eax>(int a1@<edx>, int a2@<ecx>, FILE *stream, int a4, int a5, int a6, int a7, int a8);
// int __usercall sub_8065DAD@<eax>(int a1@<edx>, int a2@<ecx>, FILE *stream, int a4, int a5, int a6, int a7);
// int __usercall sub_8065E13@<eax>(int a1@<edx>, int a2@<ecx>, FILE *stream, int a4, int a5, int a6, ...);
void *__cdecl sub_8065F9B(void *ptr, int a2, int a3);
// void *__usercall sub_80660CD@<eax>(signed __int32 a1@<ebx>, size_t size);
// void *__usercall sub_80660E0@<eax>(signed __int32 a1@<ebx>, size_t size);
void __noreturn sub_806613E(); // weak
// void *__usercall sub_806618F@<eax>(int a1@<edx>, int a2@<ecx>, void *ptr, size_t size);
// void *__usercall sub_8066299@<eax>(signed __int32 a1@<ebx>, void *src, size_t n);
void __noreturn sub_80663AB();
int __cdecl sub_80663E4(FILE *stream); // idb
// int __usercall sub_80664C0@<eax>(signed __int32 a1@<ebx>, int fd, int cmd, char a4);
int __cdecl sub_80666B0(FILE *stream); // idb
int __cdecl sub_80666E9(FILE *fp); // idb
int __cdecl sub_806675D(FILE *stream, int, int, int); // idb
// unsigned int __usercall sub_8066894@<eax>(signed __int32 a1@<ebx>, wchar_t *pwc, char *s, size_t n, mbstate_t *p);
// int __usercall sub_8066A45@<eax>(signed __int32 a1@<edx>, int a2@<ecx>, unsigned __int8 *a3, signed __int32 a4);
// int __usercall sub_8066B41@<eax>(signed __int32 a1@<ebx>, FILE *fp);
// int __usercall sub_8066C96@<eax>(signed __int32 a1@<ebx>, int category);
int sub_8066D45(); // weak
// void *__usercall sub_8066DC7@<eax>(int a1@<ecx>, signed __int32 a2@<ebx>);
// const char *__usercall sub_806741E@<eax>(signed __int32 a1@<ebx>);
// int __usercall sub_806789C@<eax>(signed __int32 a1@<edx>, int a2@<ecx>, signed __int32 a3@<ebx>, int a4);
// int __usercall sub_8067909@<eax>(signed __int32 a1@<ebx>, unsigned __int64 a2, __int64 a3);
int __cdecl sub_8067B3B(int a1);
int __fastcall sub_8067C35(_DWORD); // weak
int __fastcall sub_8067CB2(_DWORD, _DWORD); // weak
int __fastcall sub_8067D53(_DWORD); // weak
int __fastcall sub_8067DD8(_DWORD, _DWORD); // weak
int __fastcall sub_8067E53(_DWORD); // weak
int __fastcall sub_8067ECF(_DWORD); // weak
int __fastcall sub_8067F6F(_DWORD, _DWORD); // weak
int __fastcall sub_806800D(_DWORD); // weak
int __fastcall sub_806808A(_DWORD); // weak
int __fastcall sub_806812D(_DWORD); // weak
int __fastcall sub_80681B2(_DWORD, _DWORD); // weak
int __fastcall sub_8068230(_DWORD); // weak
int __fastcall sub_80682B5(_DWORD); // weak
int __fastcall sub_806833F(_DWORD); // weak
int __fastcall sub_80683C2(_DWORD, _DWORD); // weak
int __fastcall sub_806844C(_DWORD, _DWORD); // weak
int __fastcall sub_80684CC(_DWORD); // weak
int __fastcall sub_8068556(_DWORD); // weak
int __fastcall sub_80685D2(_DWORD); // weak
int (**sub_8068600())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN locret_8049A40; // weak
_UNKNOWN locret_804A055; // weak
_UNKNOWN locret_804A402; // weak
_UNKNOWN locret_804A575; // weak
_UNKNOWN locret_804A812; // weak
_UNKNOWN loc_804ADFE; // weak
_UNKNOWN loc_804AE16; // weak
_UNKNOWN loc_804AEA2; // weak
_UNKNOWN loc_804AEBD; // weak
_UNKNOWN loc_804AF28; // weak
_UNKNOWN loc_804B0EA; // weak
_UNKNOWN loc_804B141; // weak
_UNKNOWN loc_804B20A; // weak
_UNKNOWN loc_804B220; // weak
_UNKNOWN locret_804B246; // weak
_UNKNOWN loc_804B383; // weak
_UNKNOWN loc_804B3E5; // weak
_UNKNOWN loc_804B3F4; // weak
_UNKNOWN locret_804B413; // weak
_UNKNOWN loc_804B503; // weak
_UNKNOWN loc_804B53E; // weak
_UNKNOWN loc_804B544; // weak
_UNKNOWN loc_804B570; // weak
_UNKNOWN loc_804B598; // weak
_UNKNOWN loc_804B61A; // weak
_UNKNOWN loc_804B660; // weak
_UNKNOWN loc_804B668; // weak
_UNKNOWN loc_804B76F; // weak
_UNKNOWN loc_804B8B6; // weak
_UNKNOWN loc_804B8C0; // weak
_UNKNOWN loc_804BA5A; // weak
_UNKNOWN loc_804BAA4; // weak
_UNKNOWN loc_804BAD5; // weak
_UNKNOWN loc_804BB01; // weak
_UNKNOWN locret_804BB7F; // weak
_UNKNOWN loc_804BC07; // weak
_UNKNOWN loc_804BC23; // weak
_UNKNOWN loc_804BCB4; // weak
_UNKNOWN loc_804BD13; // weak
_UNKNOWN loc_804BEC6; // weak
_UNKNOWN loc_804BF44; // weak
_UNKNOWN loc_804C01D; // weak
_UNKNOWN loc_804C04E; // weak
_UNKNOWN loc_804C066; // weak
_UNKNOWN loc_804C1B7; // weak
_UNKNOWN loc_804C23A; // weak
_UNKNOWN loc_804C3C8; // weak
_UNKNOWN loc_804C3F6; // weak
_UNKNOWN loc_804C44E; // weak
_UNKNOWN loc_804C5EF; // weak
_UNKNOWN loc_804C641; // weak
_UNKNOWN loc_804C666; // weak
_UNKNOWN loc_804C6B8; // weak
_UNKNOWN loc_804C6DD; // weak
_UNKNOWN loc_804C72F; // weak
_UNKNOWN loc_804C7B2; // weak
_UNKNOWN loc_804C7D4; // weak
_UNKNOWN loc_804C805; // weak
_UNKNOWN loc_804C82C; // weak
_UNKNOWN loc_804C838; // weak
_UNKNOWN loc_804C83F; // weak
_UNKNOWN loc_804C847; // weak
_UNKNOWN loc_804C86C; // weak
_UNKNOWN loc_804CA02; // weak
_UNKNOWN loc_804CA2E; // weak
_UNKNOWN loc_804CAF8; // weak
_UNKNOWN loc_804CB1E; // weak
_UNKNOWN loc_804CBA1; // weak
_UNKNOWN loc_804CC0F; // weak
_UNKNOWN loc_804CC46; // weak
_UNKNOWN loc_804CDBB; // weak
_UNKNOWN loc_804CDF7; // weak
_UNKNOWN loc_804CECD; // weak
_UNKNOWN loc_804D1F6; // weak
_UNKNOWN loc_804D277; // weak
_UNKNOWN loc_804D287; // weak
_UNKNOWN loc_804D334; // weak
_UNKNOWN loc_804D756; // weak
_UNKNOWN loc_804DA27; // weak
_UNKNOWN loc_804E2EA; // weak
_UNKNOWN loc_804E393; // weak
_UNKNOWN loc_804E483; // weak
_UNKNOWN loc_804E498; // weak
_UNKNOWN loc_804E681; // weak
_UNKNOWN loc_804E759; // weak
_UNKNOWN loc_80630D6; // weak
_UNKNOWN locret_8063118; // weak
_UNKNOWN loc_8063308; // weak
_UNKNOWN loc_806333C; // weak
_UNKNOWN loc_8063397; // weak
_UNKNOWN locret_806339A; // weak
_UNKNOWN loc_8063411; // weak
_UNKNOWN loc_806344E; // weak
_UNKNOWN loc_8063451; // weak
_UNKNOWN loc_80636AA; // weak
_UNKNOWN loc_80636E6; // weak
_UNKNOWN loc_8063853; // weak
_UNKNOWN loc_8063874; // weak
_UNKNOWN loc_806387B; // weak
_UNKNOWN loc_80639DB; // weak
_UNKNOWN loc_8063A1E; // weak
_UNKNOWN loc_8063A93; // weak
_UNKNOWN loc_8063AD4; // weak
_UNKNOWN loc_8063B02; // weak
_UNKNOWN loc_8063B1B; // weak
_UNKNOWN loc_8063B53; // weak
_UNKNOWN loc_8063C8D; // weak
_UNKNOWN loc_8063C92; // weak
_UNKNOWN loc_8063D3D; // weak
_UNKNOWN loc_8063E06; // weak
_UNKNOWN loc_8063F03; // weak
_UNKNOWN loc_8063F44; // weak
_UNKNOWN loc_8063F63; // weak
_UNKNOWN loc_8063FA5; // weak
_UNKNOWN loc_8063FCA; // weak
_UNKNOWN loc_8063FCF; // weak
_UNKNOWN loc_80640BB; // weak
_UNKNOWN loc_80640EB; // weak
_UNKNOWN loc_80640F8; // weak
_UNKNOWN loc_8064146; // weak
_UNKNOWN loc_8064295; // weak
_UNKNOWN loc_806429B; // weak
_UNKNOWN loc_80642D9; // weak
_UNKNOWN loc_80642DE; // weak
_UNKNOWN loc_80643B9; // weak
_UNKNOWN loc_80643F4; // weak
_UNKNOWN loc_806442D; // weak
_UNKNOWN loc_806444C; // weak
_UNKNOWN loc_8064451; // weak
_UNKNOWN loc_8064531; // weak
_UNKNOWN loc_80645D6; // weak
_UNKNOWN loc_8064600; // weak
_UNKNOWN loc_806460B; // weak
_UNKNOWN loc_8064656; // weak
_UNKNOWN loc_806467A; // weak
_UNKNOWN loc_806467F; // weak
_UNKNOWN loc_80646AD; // weak
_UNKNOWN loc_8064701; // weak
_UNKNOWN loc_8064718; // weak
_UNKNOWN loc_8064799; // weak
_UNKNOWN loc_806479D; // weak
_UNKNOWN loc_806488F; // weak
_UNKNOWN loc_80648BB; // weak
_UNKNOWN loc_80648D3; // weak
_UNKNOWN loc_8064A23; // weak
_UNKNOWN loc_8064A28; // weak
_UNKNOWN locret_806540B; // weak
_UNKNOWN loc_80657AC; // weak
_UNKNOWN loc_80657D6; // weak
_UNKNOWN loc_8065D34; // weak
_UNKNOWN loc_8066022; // weak
_UNKNOWN loc_8066040; // weak
_UNKNOWN loc_80661BA; // weak
_UNKNOWN loc_80661CC; // weak
_UNKNOWN loc_8066206; // weak
_UNKNOWN loc_806620B; // weak
_UNKNOWN loc_8066444; // weak
_UNKNOWN loc_806647D; // weak
_UNKNOWN loc_8066543; // weak
_UNKNOWN loc_8066584; // weak
_UNKNOWN loc_8066609; // weak
_UNKNOWN loc_806671D; // weak
_UNKNOWN loc_806672E; // weak
_UNKNOWN loc_8066798; // weak
_UNKNOWN loc_80667CF; // weak
_UNKNOWN loc_8066872; // weak
_UNKNOWN locret_8066892; // weak
_UNKNOWN loc_80668FB; // weak
_UNKNOWN loc_80669D5; // weak
_UNKNOWN loc_8066A40; // weak
_UNKNOWN locret_8066A43; // weak
_UNKNOWN loc_8066A9C; // weak
_UNKNOWN loc_8066AF1; // weak
_UNKNOWN loc_8066B27; // weak
_UNKNOWN loc_8066B3A; // weak
_UNKNOWN loc_8066C62; // weak
_UNKNOWN loc_8066C86; // weak
_UNKNOWN loc_8066C88; // weak
_UNKNOWN loc_8066CEC; // weak
_UNKNOWN loc_8066D7F; // weak
_UNKNOWN loc_8066E09; // weak
_UNKNOWN loc_8066E51; // weak
_UNKNOWN loc_8066E77; // weak
_UNKNOWN loc_8066E8B; // weak
_UNKNOWN loc_8066EED; // weak
_UNKNOWN loc_8066F29; // weak
_UNKNOWN loc_8066F2E; // weak
_UNKNOWN loc_8066FBD; // weak
_UNKNOWN loc_8067184; // weak
_UNKNOWN loc_80671C3; // weak
_UNKNOWN loc_80671E5; // weak
_UNKNOWN loc_806721A; // weak
_UNKNOWN loc_806736A; // weak
_UNKNOWN loc_80673B7; // weak
_UNKNOWN loc_80673C8; // weak
_UNKNOWN loc_80673F3; // weak
_UNKNOWN loc_80673FE; // weak
_UNKNOWN loc_8067519; // weak
_UNKNOWN loc_8067527; // weak
_UNKNOWN loc_806754A; // weak
_UNKNOWN loc_8067551; // weak
_UNKNOWN loc_80678EA; // weak
_UNKNOWN loc_8067944; // weak
char locale = '\0'; // idb
struct option longopts = { "binary", 0, NULL, 98 }; // idb
char byte_8069315[16] =
{
  '0',
  '1',
  '2',
  '3',
  '4',
  '5',
  '6',
  '7',
  '8',
  '9',
  'a',
  'b',
  'c',
  'd',
  'e',
  'f'
}; // idb
_UNKNOWN unk_8069340; // weak
_UNKNOWN unk_806976E; // weak
_UNKNOWN unk_8069772; // weak
_UNKNOWN unk_806977E; // weak
_UNKNOWN unk_8069782; // weak
_UNKNOWN unk_8069785; // weak
char aWrittenB[9] = "Written b"; // idb
void *off_8069D14[10] =
{
  &loc_8065856,
  &loc_806585B,
  &loc_8065884,
  &loc_80658B9,
  &loc_806592A,
  &loc_806597D,
  &loc_8065A13,
  &loc_8065A8A,
  &loc_8065B13,
  &loc_8065BDF
}; // weak
char name[10] = "CHARSETALI"; // idb
char aHomeHwangdzCor_0[55] = "/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib"; // weak
_UNKNOWN unk_8069EA3; // weak
_UNKNOWN unk_806A204; // weak
_UNKNOWN unk_806A207; // weak
int dword_806AEE8 = 2231517709; // weak
_UNKNOWN unk_806C290; // weak
_UNKNOWN unk_806C293; // weak
int (*off_806DEB4[2])() = { &sub_80491E0, &sub_80491C0 }; // weak
int (*off_806DEB8)() = &sub_80491C0; // weak
int (*dword_806E008)(void) = NULL; // weak
int dword_806E110 = 0; // weak
int dword_806E114 = 0; // weak
int dword_806E124 = 0; // weak
int dword_806E128 = 0; // weak
int dword_806E138 = 0; // weak
int dword_806E13C = 0; // weak
int dword_806E14C = 0; // weak
int dword_806E150 = 0; // weak
int dword_806E160 = 0; // weak
int dword_806E164 = 0; // weak
int dword_806E174 = 0; // weak
int dword_806E178 = 0; // weak
int dword_806E188 = 0; // weak
int dword_806E18C = 0; // weak
int dword_806E19C = 0; // weak
int dword_806E1A0 = 0; // weak
int dword_806E1B0 = 0; // weak
int dword_806E1B4 = 0; // weak
int dword_806E1C4 = 0; // weak
int dword_806E1C8 = 0; // weak
int dword_806E1D8 = 0; // weak
int dword_806E1DC = 0; // weak
int dword_806E1EC = 0; // weak
int dword_806E1F0 = 0; // weak
int dword_806E200 = 0; // weak
int dword_806E204 = 0; // weak
int dword_806E214 = 0; // weak
int dword_806E218 = 0; // weak
int dword_806E228 = 0; // weak
int dword_806E22C = 0; // weak
int dword_806E23C = 0; // weak
int dword_806E240 = 0; // weak
int dword_806E250 = 0; // weak
int dword_806E254 = 0; // weak
int dword_806E264 = 0; // weak
int dword_806E268 = 0; // weak
int dword_806E278 = 0; // weak
int dword_806E27C = 0; // weak
int dword_806E288 = 0; // weak
int dword_806E29C = 0; // weak
int off_806E2A4 = 134648613; // idb
int status = 1; // idb
int dword_806E2B8 = 1; // weak
int dword_806E2BC = 256; // weak
void *off_806E2C0 = &unk_806E9DD; // weak
int *off_806E2C4 = &dword_806E2BC; // weak
_UNKNOWN unk_806E2D8; // weak
_UNKNOWN unk_806E2F4; // weak
_UNKNOWN unk_806E2F7; // weak
_UNKNOWN unk_806E308; // weak
_UNKNOWN unk_806E30B; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int program_invocation_name; // weak
int optind; // weak
FILE *stdin; // idb
FILE *stdout; // idb
char byte_806E368; // weak
_UNKNOWN unk_806E3B5; // weak
_UNKNOWN unk_806E5FD; // weak
char byte_806E68B; // weak
char byte_806E7AF; // weak
_UNKNOWN unk_806E845; // weak
char byte_806E8D3; // weak
_UNKNOWN unk_806E8D7; // weak
_UNKNOWN unk_806E8E7; // weak
char byte_806E969; // weak
int dword_806E96D; // weak
int dword_806E971; // weak
char byte_806E975; // weak
char byte_806E976; // weak
char byte_806E977; // weak
char byte_806E978; // weak
char byte_806E979; // weak
int dword_806E97D; // weak
char byte_806E981; // weak
int dword_806E985; // weak
int dword_806E99D; // weak
int dword_806E9A1; // weak
int dword_806E9A5; // weak
int dword_806E9A9; // weak
int dword_806E9AD; // weak
int dword_806E9B1; // weak
int dword_806E9B5; // weak
int dword_806E9B9; // weak
int dword_806E9BD; // weak
int dword_806E9C1; // weak
int dword_806E9C5; // weak
int dword_806E9C9; // weak
_UNKNOWN unk_806E9DD; // weak
int dword_806EADD; // weak
int dword_806EAE1; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (08048CCC) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 80490E0: using guessed type int _gmon_start__(void);

//----- (08048CF0) --------------------------------------------------------
int sub_8048CF0()
{
  return dword_806E008();
}
// 806E008: using guessed type int (*dword_806E008)(void);

//----- (080490F0) --------------------------------------------------------
#error "80490F3: positive sp value has been found (funcsize=2)"

//----- (08049123) --------------------------------------------------------
void sub_8049123()
{
  ;
}

//----- (08049140) --------------------------------------------------------
void sub_8049140()
{
  ;
}

//----- (08049150) --------------------------------------------------------
int sub_8049150()
{
  int result; // eax

  result = &unk_806E30B - &unk_806E308;
  if ( (unsigned int)(&unk_806E30B - &unk_806E308) > 6 )
    result = 0;
  return result;
}
// 8049150: could not find valid save-restore pair for ebp

//----- (080491C0) --------------------------------------------------------
int sub_80491C0()
{
  int result; // eax

  if ( !byte_806E368 )
  {
    result = sub_8049150();
    byte_806E368 = 1;
  }
  return result;
}
// 80491C0: could not find valid save-restore pair for ebp
// 806E368: using guessed type char byte_806E368;

//----- (080491E0) --------------------------------------------------------
int sub_80491E0()
{
  return 0;
}
// 80491E0: could not find valid save-restore pair for ebp

//----- (0804923F) --------------------------------------------------------
void sub_804923F()
{
  ;
}

//----- (0804925A) --------------------------------------------------------
void sub_804925A()
{
  ;
}

//----- (0804926A) --------------------------------------------------------
int sub_804926A()
{
  int result; // eax

  result = &unk_806E2F7 - &unk_806E2F4;
  if ( (unsigned int)(&unk_806E2F7 - &unk_806E2F4) > 6 )
    result = 0;
  return result;
}
// 804926A: could not find valid save-restore pair for ebp

//----- (0804934C) --------------------------------------------------------
void sub_804934C()
{
  ;
}

//----- (08049367) --------------------------------------------------------
void sub_8049367()
{
  ;
}

//----- (08049377) --------------------------------------------------------
int sub_8049377()
{
  int result; // eax

  result = &unk_806E3B5 - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_806E3B5 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 8049377: could not find valid save-restore pair for ebp
// 806E320: using guessed type int program_invocation_short_name;

//----- (08049459) --------------------------------------------------------
void sub_8049459()
{
  ;
}

//----- (08049474) --------------------------------------------------------
void sub_8049474()
{
  ;
}

//----- (08049484) --------------------------------------------------------
int sub_8049484()
{
  int result; // eax

  result = &unk_806E2F7 - &unk_806E2F4;
  if ( (unsigned int)(&unk_806E2F7 - &unk_806E2F4) > 6 )
    result = 0;
  return result;
}
// 8049484: could not find valid save-restore pair for ebp

//----- (08049566) --------------------------------------------------------
void sub_8049566()
{
  ;
}

//----- (08049581) --------------------------------------------------------
void sub_8049581()
{
  ;
}

//----- (08049591) --------------------------------------------------------
int sub_8049591()
{
  int result; // eax

  result = &unk_806E2F7 - &unk_806E2F4;
  if ( (unsigned int)(&unk_806E2F7 - &unk_806E2F4) > 6 )
    result = 0;
  return result;
}
// 8049591: could not find valid save-restore pair for ebp

//----- (08049673) --------------------------------------------------------
void sub_8049673()
{
  ;
}

//----- (0804968E) --------------------------------------------------------
void sub_804968E()
{
  ;
}

//----- (0804969E) --------------------------------------------------------
int sub_804969E()
{
  int result; // eax

  result = &unk_806E2F7 - &unk_806E2F4;
  if ( (unsigned int)(&unk_806E2F7 - &unk_806E2F4) > 6 )
    result = 0;
  return result;
}
// 804969E: could not find valid save-restore pair for ebp

//----- (0804979C) --------------------------------------------------------
void sub_804979C()
{
  ;
}

//----- (080497B7) --------------------------------------------------------
void sub_80497B7()
{
  ;
}

//----- (080497C7) --------------------------------------------------------
int sub_80497C7()
{
  int result; // eax

  result = &unk_806C293 - &unk_806C290;
  if ( (unsigned int)(&unk_806C293 - &unk_806C290) > 6 )
    result = 0;
  return result;
}
// 80497C7: could not find valid save-restore pair for ebp

//----- (080498DD) --------------------------------------------------------
void sub_80498DD()
{
  ;
}

//----- (080498F8) --------------------------------------------------------
void sub_80498F8()
{
  ;
}

//----- (08049908) --------------------------------------------------------
int sub_8049908()
{
  int result; // eax

  result = &unk_806E2F7 - &unk_806E2F4;
  if ( (unsigned int)(&unk_806E2F7 - &unk_806E2F4) > 6 )
    result = 0;
  return result;
}
// 8049908: could not find valid save-restore pair for ebp

//----- (08049A06) --------------------------------------------------------
void sub_8049A06()
{
  ;
}

//----- (08049A21) --------------------------------------------------------
void sub_8049A21()
{
  ;
}

//----- (08049A31) --------------------------------------------------------
int __fastcall sub_8049A31(int a1, int a2)
{
  int result; // eax
  int (__stdcall *v3)(void *, int, int, int, int, int); // eax
  int v4; // [esp+4h] [ebp-18h]
  int v5; // [esp+8h] [ebp-14h]
  int v6; // [esp+Ch] [ebp-10h]
  int v7; // [esp+10h] [ebp-Ch]
  int v8; // [esp+14h] [ebp-8h]
  int v9; // [esp+18h] [ebp-4h]

  result = &unk_806E2F7 - &unk_806E2F4;
  if ( (unsigned int)(&unk_806E2F7 - &unk_806E2F4) > 6 )
  {
    v9 = 0;
    dword_806E14C = (int)&locret_8049A40;
    v3 = (int (__stdcall *)(void *, int, int, int, int, int))sub_806844C(a1, a2);
    result = v3(&unk_806E2F4, v4, v5, v6, v7, v8);
  }
  return result;
}
// 806844C: using guessed type int __fastcall sub_806844C(_DWORD, _DWORD);
// 806E14C: using guessed type int dword_806E14C;

//----- (08049AB1) --------------------------------------------------------
int __usercall sub_8049AB1@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_806E2F4, a1);
}

//----- (08049B48) --------------------------------------------------------
void sub_8049B48()
{
  ;
}

//----- (08049B63) --------------------------------------------------------
void sub_8049B63()
{
  ;
}

//----- (08049B73) --------------------------------------------------------
int sub_8049B73()
{
  int result; // eax

  result = &unk_806E2F7 - &unk_806E2F4;
  if ( (unsigned int)(&unk_806E2F7 - &unk_806E2F4) > 6 )
    result = 0;
  return result;
}
// 8049B73: could not find valid save-restore pair for ebp

//----- (08049C55) --------------------------------------------------------
void sub_8049C55()
{
  ;
}

//----- (08049C70) --------------------------------------------------------
void sub_8049C70()
{
  ;
}

//----- (08049C80) --------------------------------------------------------
int sub_8049C80()
{
  int result; // eax

  result = &unk_806E5FD - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_806E5FD - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 8049C80: could not find valid save-restore pair for ebp
// 806E320: using guessed type int program_invocation_short_name;

//----- (08049CE7) --------------------------------------------------------
int __usercall sub_8049CE7@<eax>(int a1@<eax>, int (__cdecl *a2)(int *, int)@<edx>)
{
  return a2(&program_invocation_short_name, a1);
}
// 806E320: using guessed type int program_invocation_short_name;

//----- (08049D7E) --------------------------------------------------------
void sub_8049D7E()
{
  ;
}

//----- (08049D99) --------------------------------------------------------
void sub_8049D99()
{
  ;
}

//----- (08049DA9) --------------------------------------------------------
int sub_8049DA9()
{
  int result; // eax

  result = &unk_806E2F7 - &unk_806E2F4;
  if ( (unsigned int)(&unk_806E2F7 - &unk_806E2F4) > 6 )
    result = 0;
  return result;
}
// 8049DA9: could not find valid save-restore pair for ebp

//----- (08049DD5) --------------------------------------------------------
int sub_8049DD5()
{
  return 0;
}
// 8049DD5: could not find valid save-restore pair for ebp

//----- (08049E33) --------------------------------------------------------
int sub_8049E33()
{
  int result; // eax

  result = sub_8049DA9();
  byte_806E68B = 1;
  return result;
}
// 806E68B: using guessed type char byte_806E68B;

//----- (08049E8D) --------------------------------------------------------
int __usercall sub_8049E8D@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  a1(&dword_806AEE8);
  return sub_8049DD5();
}
// 806AEE8: using guessed type int dword_806AEE8;

//----- (08049ED9) --------------------------------------------------------
void sub_8049ED9()
{
  ;
}

//----- (08049EF4) --------------------------------------------------------
void sub_8049EF4()
{
  ;
}

//----- (08049F04) --------------------------------------------------------
int sub_8049F04()
{
  int result; // eax

  result = &unk_806E2F7 - &unk_806E2F4;
  if ( (unsigned int)(&unk_806E2F7 - &unk_806E2F4) > 6 )
    result = 0;
  return result;
}
// 8049F04: could not find valid save-restore pair for ebp

//----- (0804A01B) --------------------------------------------------------
void sub_804A01B()
{
  ;
}

//----- (0804A036) --------------------------------------------------------
void sub_804A036()
{
  ;
}

//----- (0804A046) --------------------------------------------------------
int __fastcall sub_804A046(int a1, int a2)
{
  int result; // eax
  int (__stdcall *v3)(void *, int, int, int, int, int); // eax
  int v4; // [esp+4h] [ebp-18h]
  int v5; // [esp+8h] [ebp-14h]
  int v6; // [esp+Ch] [ebp-10h]
  int v7; // [esp+10h] [ebp-Ch]
  int v8; // [esp+14h] [ebp-8h]
  int v9; // [esp+18h] [ebp-4h]

  result = &unk_806A207 - &unk_806A204;
  if ( (unsigned int)(&unk_806A207 - &unk_806A204) > 6 )
  {
    v9 = 0;
    dword_806E14C = (int)&locret_804A055;
    v3 = (int (__stdcall *)(void *, int, int, int, int, int))sub_806844C(a1, a2);
    result = v3(&unk_806A204, v4, v5, v6, v7, v8);
  }
  return result;
}
// 806844C: using guessed type int __fastcall sub_806844C(_DWORD, _DWORD);
// 806E14C: using guessed type int dword_806E14C;

//----- (0804A15D) --------------------------------------------------------
void sub_804A15D()
{
  ;
}

//----- (0804A178) --------------------------------------------------------
void sub_804A178()
{
  ;
}

//----- (0804A188) --------------------------------------------------------
int sub_804A188()
{
  int result; // eax

  result = &unk_806E2F7 - &unk_806E2F4;
  if ( (unsigned int)(&unk_806E2F7 - &unk_806E2F4) > 6 )
    result = 0;
  return result;
}
// 804A188: could not find valid save-restore pair for ebp

//----- (0804A23A) --------------------------------------------------------
int __usercall sub_804A23A@<eax>(void (__cdecl *a1)(signed int)@<eax>)
{
  a1(134651636);
  return 0;
}

//----- (0804A286) --------------------------------------------------------
void sub_804A286()
{
  ;
}

//----- (0804A2A1) --------------------------------------------------------
void sub_804A2A1()
{
  ;
}

//----- (0804A2B1) --------------------------------------------------------
int sub_804A2B1()
{
  int result; // eax

  result = &unk_806E2F7 - &unk_806E2F4;
  if ( (unsigned int)(&unk_806E2F7 - &unk_806E2F4) > 6 )
    result = 0;
  return result;
}
// 804A2B1: could not find valid save-restore pair for ebp

//----- (0804A30F) --------------------------------------------------------
int sub_804A30F()
{
  return nullsub_5();
}
// 804A30F: could not find valid save-restore pair for ebp
// 804A30E: using guessed type int nullsub_5(void);

//----- (0804A354) --------------------------------------------------------
int sub_804A354()
{
  int result; // eax

  result = sub_804A2B1();
  byte_806E7AF = 1;
  return result;
}
// 806E7AF: using guessed type char byte_806E7AF;

//----- (0804A3C8) --------------------------------------------------------
void sub_804A3C8()
{
  ;
}

//----- (0804A3E3) --------------------------------------------------------
void sub_804A3E3()
{
  ;
}

//----- (0804A3F3) --------------------------------------------------------
int __fastcall sub_804A3F3(int a1, int a2)
{
  int result; // eax
  int (__stdcall *v3)(void *, int, int, int, int, int); // eax
  int v4; // [esp+4h] [ebp-18h]
  int v5; // [esp+8h] [ebp-14h]
  int v6; // [esp+Ch] [ebp-10h]
  int v7; // [esp+10h] [ebp-Ch]
  int v8; // [esp+14h] [ebp-8h]
  int v9; // [esp+18h] [ebp-4h]

  result = &unk_806E2F7 - &unk_806E2F4;
  if ( (unsigned int)(&unk_806E2F7 - &unk_806E2F4) > 6 )
  {
    v9 = 0;
    dword_806E160 = (int)&locret_804A402;
    v3 = (int (__stdcall *)(void *, int, int, int, int, int))sub_80683C2(a1, a2);
    result = v3(&unk_806E2F4, v4, v5, v6, v7, v8);
  }
  return result;
}
// 80683C2: using guessed type int __fastcall sub_80683C2(_DWORD, _DWORD);
// 806E160: using guessed type int dword_806E160;

//----- (0804A53B) --------------------------------------------------------
void sub_804A53B()
{
  ;
}

//----- (0804A556) --------------------------------------------------------
void sub_804A556()
{
  ;
}

//----- (0804A566) --------------------------------------------------------
int __fastcall sub_804A566(int a1)
{
  int result; // eax
  int (__stdcall *v2)(const char *, int, int, int, int, int); // eax
  int v3; // [esp+4h] [ebp-18h]
  int v4; // [esp+8h] [ebp-14h]
  int v5; // [esp+Ch] [ebp-10h]
  int v6; // [esp+10h] [ebp-Ch]
  int v7; // [esp+14h] [ebp-8h]
  int v8; // [esp+18h] [ebp-4h]

  result = "IR" - "ASDIR";
  if ( (unsigned int)("IR" - "ASDIR") > 6 )
  {
    v8 = 0;
    dword_806E250 = (int)&locret_804A575;
    v2 = (int (__stdcall *)(const char *, int, int, int, int, int))sub_8067D53(a1);
    result = v2("ASDIR", v3, v4, v5, v6, v7);
  }
  return result;
}
// 8067D53: using guessed type int __fastcall sub_8067D53(_DWORD);
// 806E250: using guessed type int dword_806E250;

//----- (0804A5E6) --------------------------------------------------------
int __usercall sub_804A5E6@<eax>(int a1@<eax>, int (__cdecl *a2)(const char *, int)@<edx>)
{
  return a2("ASDIR", a1);
}

//----- (0804A67D) --------------------------------------------------------
void sub_804A67D()
{
  ;
}

//----- (0804A698) --------------------------------------------------------
void sub_804A698()
{
  ;
}

//----- (0804A6A8) --------------------------------------------------------
int sub_804A6A8()
{
  int result; // eax

  result = &unk_806E845 - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_806E845 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 804A6A8: could not find valid save-restore pair for ebp
// 806E320: using guessed type int program_invocation_short_name;

//----- (0804A7D8) --------------------------------------------------------
void sub_804A7D8()
{
  ;
}

//----- (0804A7F3) --------------------------------------------------------
void sub_804A7F3()
{
  ;
}

//----- (0804A803) --------------------------------------------------------
int __fastcall sub_804A803(int a1)
{
  int result; // eax
  int (__stdcall *v2)(void *, int, int, int, int, int); // eax
  int v3; // [esp+4h] [ebp-18h]
  int v4; // [esp+8h] [ebp-14h]
  int v5; // [esp+Ch] [ebp-10h]
  int v6; // [esp+10h] [ebp-Ch]
  int v7; // [esp+14h] [ebp-8h]
  int v8; // [esp+18h] [ebp-4h]

  result = &unk_806E2F7 - &unk_806E2F4;
  if ( (unsigned int)(&unk_806E2F7 - &unk_806E2F4) > 6 )
  {
    v8 = 0;
    dword_806E1D8 = (int)&locret_804A812;
    v2 = (int (__stdcall *)(void *, int, int, int, int, int))sub_806808A(a1);
    result = v2(&unk_806E2F4, v3, v4, v5, v6, v7);
  }
  return result;
}
// 806808A: using guessed type int __fastcall sub_806808A(_DWORD);
// 806E1D8: using guessed type int dword_806E1D8;

//----- (0804A8A6) --------------------------------------------------------
int __fastcall sub_804A8A6(int a1)
{
  int result; // eax

  result = sub_804A803(a1);
  byte_806E8D3 = 1;
  return result;
}
// 806E8D3: using guessed type char byte_806E8D3;

//----- (0804A9F1) --------------------------------------------------------
void sub_804A9F1()
{
  ;
}

//----- (0804AA0C) --------------------------------------------------------
void sub_804AA0C()
{
  ;
}

//----- (0804AA1C) --------------------------------------------------------
int sub_804AA1C()
{
  int result; // eax

  result = &unk_806E8D7 - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_806E8D7 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 804AA1C: could not find valid save-restore pair for ebp
// 806E320: using guessed type int program_invocation_short_name;

//----- (0804AA7A) --------------------------------------------------------
int sub_804AA7A()
{
  return nullsub_7();
}
// 804AA7A: could not find valid save-restore pair for ebp
// 804AA79: using guessed type int nullsub_7(void);

//----- (0804AAE7) --------------------------------------------------------
int __usercall sub_804AAE7@<eax>(void (__cdecl *a1)(void **)@<eax>)
{
  int v1; // ecx
  int savedregs; // [esp+18h] [ebp+0h]

  a1(off_8069D14);
  savedregs = 0;
  dword_806E250 = (int)nullsub_7;
  sub_8067D53(v1);
  return nullsub_7();
}
// 804AA79: using guessed type int nullsub_7(void);
// 8067D53: using guessed type int __fastcall sub_8067D53(_DWORD);
// 8069D14: using guessed type void *off_8069D14[10];
// 806E250: using guessed type int dword_806E250;

//----- (0804AB33) --------------------------------------------------------
void sub_804AB33()
{
  ;
}

//----- (0804AB4E) --------------------------------------------------------
void sub_804AB4E()
{
  ;
}

//----- (0804AB5E) --------------------------------------------------------
int sub_804AB5E()
{
  int result; // eax

  result = &unk_806E8E7 - (_UNKNOWN *)&program_invocation_name;
  if ( (unsigned int)(&unk_806E8E7 - (_UNKNOWN *)&program_invocation_name) > 6 )
    result = 0;
  return result;
}
// 804AB5E: could not find valid save-restore pair for ebp
// 806E330: using guessed type int program_invocation_name;

//----- (0804ACB6) --------------------------------------------------------
int __usercall sub_804ACB6@<eax>(signed __int32 a1@<ebx>, unsigned __int64 a2)
{
  int result; // eax

  if ( HIDWORD(a2) )
    result = sub_8067909(a1, a2, 1000000LL) + 1000000;
  else
    result = a2;
  return result;
}

//----- (0804AD04) --------------------------------------------------------
unsigned int __cdecl sub_804AD04(int a1, unsigned int a2)
{
  return a2 - 1 + a1 - (a2 - 1 + a1) % a2;
}

//----- (0804AD36) --------------------------------------------------------
int sub_804AD36()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nWith no FILE, or when FILE is -, read standard input.\n");
  return fputs_unlocked(v1, v0);
}
// 8048F20: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804AD61) --------------------------------------------------------
int __cdecl sub_804AD61(char *s1)
{
  int v1; // ecx
  void *v2; // eax
  char *v3; // eax
  bool v4; // zf
  int v5; // ecx
  void *v6; // eax
  char *v7; // eax
  char *v8; // eax
  signed __int32 v9; // ecx
  signed __int32 v10; // eax
  signed __int32 v11; // ebx
  signed __int32 v12; // ecx
  char *v13; // eax
  char *v15; // [esp+1Ch] [ebp-4Ch]
  const char **i; // [esp+20h] [ebp-48h]
  const char *v17; // [esp+24h] [ebp-44h]
  const char *v18; // [esp+28h] [ebp-40h]
  const char *v19; // [esp+2Ch] [ebp-3Ch]
  const char *v20; // [esp+30h] [ebp-38h]
  const char *v21; // [esp+34h] [ebp-34h]
  const char *v22; // [esp+38h] [ebp-30h]
  const char *v23; // [esp+3Ch] [ebp-2Ch]
  const char *v24; // [esp+40h] [ebp-28h]
  const char *v25; // [esp+44h] [ebp-24h]
  const char *v26; // [esp+48h] [ebp-20h]
  const char *v27; // [esp+4Ch] [ebp-1Ch]
  const char *v28; // [esp+50h] [ebp-18h]
  const char *v29; // [esp+54h] [ebp-14h]
  int v30; // [esp+58h] [ebp-10h]
  int v31; // [esp+5Ch] [ebp-Ch]

  v18 = "[";
  v19 = "test invocation";
  v20 = "coreutils";
  v21 = "Multi-call invocation";
  v22 = "sha224sum";
  v23 = "sha2 utilities";
  v24 = "sha256sum";
  v25 = "sha2 utilities";
  v26 = "sha384sum";
  v27 = "sha2 utilities";
  v28 = "sha512sum";
  v29 = "sha2 utilities";
  v30 = 0;
  v31 = 0;
  v15 = s1;
  for ( i = &v18; ; i += 2 )
  {
    v2 = &loc_804ADFE;
    if ( !*i )
      v2 = &loc_804AE16;
    dword_806E188 = (int)v2;
    sub_80682B5(v1);
    if ( !strcmp(s1, *i) )
      break;
  }
  if ( i[1] )
    v15 = (char *)i[1];
  v3 = gettext("\n%s online help: <%s>\n");
  printf(v3, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  v17 = setlocale(5, 0);
  if ( v17 )
  {
    v4 = strncmp(v17, "en_", 3u) == 0;
    v6 = &loc_804AEA2;
    if ( v4 )
      v6 = &loc_804AEBD;
    dword_806E19C = (int)v6;
    sub_8068230(v5);
    v7 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
    printf(v7, s1);
  }
  v8 = gettext("Full documentation at: <%s%s>\n");
  printf(v8, "http://www.gnu.org/software/coreutils/", s1);
  if ( v15 == s1 )
  {
    dword_806E19C = (int)&loc_804AF28;
    v10 = _InterlockedExchange(&dword_806E1A0, (signed __int32)v15);
    _InterlockedExchange(&dword_806E1A0, v9);
    sub_8068230(_InterlockedExchange(&dword_806E1A0, v10));
    v11 = _InterlockedExchange(&dword_806E1A0, (signed __int32)" invocation");
    _InterlockedExchange(&dword_806E1A0, v12);
    _InterlockedExchange(&dword_806E1A0, v11);
  }
  v13 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  return printf(v13, v15, &locale);
}
// 8068230: using guessed type int __fastcall sub_8068230(_DWORD);
// 80682B5: using guessed type int __fastcall sub_80682B5(_DWORD);
// 806E188: using guessed type int dword_806E188;
// 806E19C: using guessed type int dword_806E19C;
// 806E1A0: using guessed type int dword_806E1A0;

//----- (0804AF4D) --------------------------------------------------------
int __cdecl sub_804AF4D(int a1)
{
  return a1;
}

//----- (0804AF55) --------------------------------------------------------
void __cdecl __noreturn sub_804AF55(int status)
{
  int v1; // ebx
  char *v2; // eax
  int v3; // eax
  signed __int32 v4; // eax
  signed __int32 v5; // edx
  int v6; // ecx
  signed __int32 v7; // ecx
  signed __int32 v8; // et1
  int v9; // ebx
  char *v10; // eax
  FILE *v11; // ebx
  char *v12; // eax
  char *v13; // eax
  FILE *v14; // ebx
  char *v15; // eax
  FILE *v16; // ebx
  char *v17; // eax
  FILE *v18; // ebx
  char *v19; // eax
  FILE *v20; // ebx
  char *v21; // eax
  FILE *v22; // ebx
  char *v23; // eax
  char *v24; // eax

  if ( status )
  {
    v1 = dword_806E985;
    v2 = gettext("Try '%s --help' for more information.\n");
    v3 = fprintf(stderr, v2, v1);
    dword_806E14C = (int)&loc_804B0EA;
    v4 = _InterlockedExchange(&dword_806E150, v3);
    _InterlockedExchange(&dword_806E150, v5);
    v8 = _InterlockedExchange(&dword_806E150, sub_806844C(v6, _InterlockedExchange(&dword_806E150, v4)));
    _InterlockedExchange(&dword_806E150, v7);
    _InterlockedExchange(&dword_806E150, v8);
  }
  v9 = dword_806E985;
  v10 = gettext("Usage: %s [OPTION]... [FILE]...\nPrint or check %s (%d-bit) checksums.\n");
  printf(v10, v9, "SHA512", 512);
  sub_804AD36();
  v11 = stdout;
  v12 = gettext("\n  -b, --binary         read in binary mode\n");
  fputs_unlocked(v12, v11);
  v13 = gettext("  -c, --check          read %s sums from the FILEs and check them\n");
  printf(v13, "SHA512");
  v14 = stdout;
  v15 = gettext("      --tag            create a BSD-style checksum\n");
  fputs_unlocked(v15, v14);
  v16 = stdout;
  v17 = gettext("  -t, --text           read in text mode (default)\n");
  fputs_unlocked(v17, v16);
  v18 = stdout;
  v19 = gettext(
          "\n"
          "The following five options are useful only when verifying checksums:\n"
          "      --ignore-missing  don't fail or report status for missing files\n"
          "      --quiet          don't print OK for each successfully verified file\n"
          "      --status         don't output anything, status code shows success\n"
          "      --strict         exit non-zero for improperly formatted checksum lines\n"
          "  -w, --warn           warn about improperly formatted checksum lines\n"
          "\n");
  fputs_unlocked(v19, v18);
  v20 = stdout;
  v21 = gettext("      --help     display this help and exit\n");
  fputs_unlocked(v21, v20);
  v22 = stdout;
  v23 = gettext("      --version  output version information and exit\n");
  fputs_unlocked(v23, v22);
  v24 = gettext(
          "\n"
          "The sums are computed as described in %s.  When checking, the input\n"
          "should be a former output of this program.  The default mode is to print a\n"
          "line with checksum, a space, a character indicating input mode ('*' for binary,\n"
          "' ' for text or where binary is insignificant), and name for each FILE.\n");
  printf(v24, "FIPS-180-2");
  sub_804AD61("sha512sum");
  exit(status);
}
// 8048F20: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 806844C: using guessed type int __fastcall sub_806844C(_DWORD, _DWORD);
// 806E14C: using guessed type int dword_806E14C;
// 806E150: using guessed type int dword_806E150;
// 806E985: using guessed type int dword_806E985;

//----- (0804B0F5) --------------------------------------------------------
_BYTE *__usercall sub_804B0F5@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, _BYTE *a3, unsigned int a4)
{
  void *v4; // eax
  signed __int32 v5; // ecx
  int v7; // eax
  _BYTE *v8; // eax
  _BYTE *v9; // eax
  signed __int32 v10; // ebx
  signed __int32 v11; // et0
  signed __int32 v12; // ebx
  signed __int32 v13; // edx
  signed __int32 v14; // edx
  signed __int32 v15; // et1
  signed __int32 v16; // eax
  signed __int32 v17; // ebx
  signed __int32 v18; // edx
  signed __int32 v19; // edx
  signed __int32 v20; // ett
  _BYTE *v21; // eax
  _BYTE *v22; // [esp+8h] [ebp-8h]
  unsigned int i; // [esp+Ch] [ebp-4h]

  v22 = a3;
  for ( i = 0; i < a4; ++i )
  {
    if ( a3[i] )
    {
      v4 = &loc_804B141;
      if ( a3[i] != 92 )
        v4 = &loc_804B20A;
      dword_806E174 = (int)v4;
      sub_806833F(a1);
      if ( a4 - 1 == i )
        return 0;
      v7 = (char)a3[++i];
      if ( v7 == 92 )
      {
        v9 = v22++;
        *v9 = 92;
      }
      else
      {
        if ( v7 != 110 )
          return 0;
        v8 = v22++;
        *v8 = 10;
      }
      dword_806E110 = (int)&loc_804B220;
      v10 = _InterlockedExchange(&dword_806E114, a2);
      v11 = _InterlockedExchange(&dword_806E114, v5);
      sub_80685D2(_InterlockedExchange(&dword_806E114, v10));
      v12 = _InterlockedExchange(&dword_806E114, v11);
      v15 = _InterlockedExchange(&dword_806E114, v13);
      v14 = v12;
      a2 = v15;
      _InterlockedExchange(&dword_806E114, v14);
    }
    dword_806E1C4 = (int)&locret_804B246;
    v16 = _InterlockedExchange(&dword_806E1C8, 0);
    _InterlockedExchange(&dword_806E1C8, a1);
    sub_806812D(_InterlockedExchange(&dword_806E1C8, v16));
    v17 = _InterlockedExchange(&dword_806E1C8, a2);
    v20 = _InterlockedExchange(&dword_806E1C8, v18);
    v19 = v17;
    a2 = v20;
    _InterlockedExchange(&dword_806E1C8, v19);
    v21 = v22++;
    a1 = (signed __int32)a3;
    *v21 = a3[i];
  }
  if ( &a3[a4] > v22 )
    *v22 = 0;
  return a3;
}
// 806812D: using guessed type int __fastcall sub_806812D(_DWORD);
// 806833F: using guessed type int __fastcall sub_806833F(_DWORD);
// 80685D2: using guessed type int __fastcall sub_80685D2(_DWORD);
// 806E110: using guessed type int dword_806E110;
// 806E114: using guessed type int dword_806E114;
// 806E174: using guessed type int dword_806E174;
// 806E1C4: using guessed type int dword_806E1C4;
// 806E1C8: using guessed type int dword_806E1C8;

//----- (0804B248) --------------------------------------------------------
bool __usercall sub_804B248@<al>(signed __int32 a1@<eax>, signed __int32 a2@<edx>, int a3@<ecx>, _BYTE *a4)
{
  signed __int32 v4; // eax
  signed __int32 v5; // edx
  signed __int32 v6; // et1
  unsigned int v8; // [esp+Ch] [ebp-Ch]

  v8 = 0;
  dword_806E1EC = (int)&loc_804B383;
  v4 = _InterlockedExchange(&dword_806E1F0, a1);
  _InterlockedExchange(&dword_806E1F0, a2);
  _InterlockedExchange(&dword_806E1F0, v4);
  v6 = _InterlockedExchange(&dword_806E1F0, sub_806800D(a3));
  _InterlockedExchange(&dword_806E1F0, v5);
  _InterlockedExchange(&dword_806E1F0, v6);
  do
  {
    if ( !((*__ctype_b_loc())[(unsigned __int8)*a4] & 0x1000) )
      return 0;
    ++a4;
    ++v8;
  }
  while ( v8 < dword_806E971 );
  return *a4 == 0;
}
// 806800D: using guessed type int __fastcall sub_806800D(_DWORD);
// 806E1EC: using guessed type int dword_806E1EC;
// 806E1F0: using guessed type int dword_806E1F0;
// 806E971: using guessed type int dword_806E971;

//----- (0804B39E) --------------------------------------------------------
bool __usercall sub_804B39E@<al>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, _BYTE *a3, int a4, signed __int32 *a5, _DWORD *a6, char a7)
{
  void *v8; // eax
  signed __int32 v9; // edx
  signed __int32 v10; // ebx
  signed __int32 v11; // et0
  signed __int32 v12; // ebx
  signed __int32 v13; // edx
  signed __int32 v14; // edx
  signed __int32 v15; // et1
  unsigned int v16; // eax
  void *v17; // eax
  signed __int32 v18; // eax
  signed __int32 v19; // ecx
  int v20; // ecx
  signed __int32 v21; // ebx
  signed __int32 v22; // edx
  void *v23; // eax
  int v24; // ecx
  void *v25; // eax
  int v26; // ecx
  unsigned int i; // [esp+1Ch] [ebp-Ch]
  int v28; // [esp+1Ch] [ebp-Ch]
  int v29; // [esp+1Ch] [ebp-Ch]

  if ( !a4 )
    return 0;
  for ( i = a4 - 1; ; --i )
  {
    v8 = &loc_804B3E5;
    if ( !i )
      v8 = &loc_804B3F4;
    dword_806E138 = (int)v8;
    sub_80684CC(a1);
    if ( a3[i] == 41 )
      break;
  }
  if ( a3[i] != 41 )
    return 0;
  *a6 = a3;
  if ( a7 && !sub_804B0F5(a1, a2, a3, i) )
  {
    dword_806E278 = (int)&locret_804B413;
    v10 = _InterlockedExchange(&dword_806E27C, a2);
    v11 = _InterlockedExchange(&dword_806E27C, v9);
    _InterlockedExchange(&dword_806E27C, v10);
    sub_8067C35(a1);
    v12 = _InterlockedExchange(&dword_806E27C, v11);
    v15 = _InterlockedExchange(&dword_806E27C, v13);
    v14 = v12;
    a2 = v15;
    _InterlockedExchange(&dword_806E27C, v14);
  }
  v16 = i;
  v28 = i + 1;
  a3[v16] = 0;
  while ( a3[v28] == 32 || a3[v28] == 9 )
    ++v28;
  v17 = &loc_804B503;
  if ( a3[v28] == 61 )
    v17 = &loc_804B53E;
  dword_806E214 = (int)v17;
  sub_8067ECF(a1);
  dword_806E278 = (int)&locret_804B413;
  v18 = _InterlockedExchange(&dword_806E27C, 0);
  _InterlockedExchange(&dword_806E27C, v19);
  sub_8067C35(_InterlockedExchange(&dword_806E27C, v18));
  v21 = _InterlockedExchange(&dword_806E27C, a2);
  _InterlockedExchange(&dword_806E27C, v22);
  _InterlockedExchange(&dword_806E27C, v21);
  v29 = v28 + 1;
  v23 = &loc_804B570;
  if ( a3[v29] == 32 )
    v23 = &loc_804B544;
  dword_806E138 = (int)v23;
  sub_80684CC(v20);
  v25 = &loc_804B598;
  if ( a3[v29] == 9 )
    v25 = &loc_804B544;
  dword_806E250 = (int)v25;
  sub_8067D53(v24);
  *a5 = (signed __int32)&a3[v29];
  return sub_804B248(*a5, (signed __int32)&a3[v29], v26, (_BYTE *)*a5);
}
// 804B39E: could not find valid save-restore pair for ebx
// 8067C35: using guessed type int __fastcall sub_8067C35(_DWORD);
// 8067D53: using guessed type int __fastcall sub_8067D53(_DWORD);
// 8067ECF: using guessed type int __fastcall sub_8067ECF(_DWORD);
// 80684CC: using guessed type int __fastcall sub_80684CC(_DWORD);
// 806E138: using guessed type int dword_806E138;
// 806E214: using guessed type int dword_806E214;
// 806E250: using guessed type int dword_806E250;
// 806E278: using guessed type int dword_806E278;
// 806E27C: using guessed type int dword_806E27C;

//----- (0804B5CE) --------------------------------------------------------
bool __usercall sub_804B5CE@<al>(signed __int32 a1@<eax>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, signed __int32 a4, int a5, signed __int32 *a6, _DWORD *a7, _DWORD *a8)
{
  signed __int32 v8; // eax
  signed __int32 v9; // ebx
  signed __int32 v10; // ecx
  signed __int32 v11; // ecx
  signed __int32 v12; // ebx
  signed __int32 v13; // et1
  signed __int32 v14; // ecx
  void *v15; // eax
  bool result; // al
  int v17; // ecx
  _BOOL4 v18; // edx
  signed __int32 v19; // ebx
  signed __int32 v20; // et2
  signed __int32 v21; // ebx
  signed __int32 v22; // ecx
  signed __int32 v23; // ecx
  signed __int32 v24; // ett
  signed __int32 v25; // edx
  signed __int32 v26; // ebx
  signed __int32 v27; // ebx
  signed __int32 v28; // edx
  bool v29; // zf
  int v30; // ecx
  void *v31; // eax
  int v32; // [esp+28h] [ebp-10h]
  int v33; // [esp+28h] [ebp-10h]
  int v34; // [esp+28h] [ebp-10h]
  int v35; // [esp+28h] [ebp-10h]

  v32 = 0;
  dword_806E1C4 = (int)&loc_804B61A;
  v8 = _InterlockedExchange(&dword_806E1C8, a1);
  _InterlockedExchange(&dword_806E1C8, a2);
  sub_806812D(_InterlockedExchange(&dword_806E1C8, v8));
  v9 = _InterlockedExchange(&dword_806E1C8, a3);
  v13 = _InterlockedExchange(&dword_806E1C8, v10);
  v11 = v9;
  v12 = v13;
  v14 = _InterlockedExchange(&dword_806E1C8, v11);
  do
  {
    do
      ++v32;
    while ( *(_BYTE *)(a4 + v32) == 32 );
  }
  while ( *(_BYTE *)(a4 + v32) == 9 );
  v15 = &loc_804B660;
  if ( *(_BYTE *)(a4 + v32) != 92 )
    v15 = &loc_804B668;
  dword_806E1D8 = (int)v15;
  sub_806808A(v14);
  v33 = v32 + 1;
  if ( !strncmp((const char *)(v33 + a4), "SHA512", 6u) )
  {
    v34 = v33 + 6;
    if ( *(_BYTE *)(a4 + v34) == 32 )
      ++v34;
    if ( *(_BYTE *)(a4 + v34) == 40 )
    {
      *a7 = 0;
      result = sub_804B39E(a5 - (v34 + 1), a4, (_BYTE *)(a4 + v34 + 1), a5 - (v34 + 1), a6, a8, 1);
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    v17 = a5 - v33;
    v18 = *(_BYTE *)(a4 + v33) == 92;
    if ( a5 - v33 < (unsigned int)(v18 + dword_806E96D) )
    {
      dword_806E110 = (int)&loc_804B76F;
      v19 = _InterlockedExchange(&dword_806E114, v12);
      v20 = _InterlockedExchange(&dword_806E114, v18);
      _InterlockedExchange(&dword_806E114, v19);
      sub_80685D2(v17);
      v21 = _InterlockedExchange(&dword_806E114, v20);
      v24 = _InterlockedExchange(&dword_806E114, v22);
      v23 = v21;
      v12 = v24;
      v17 = _InterlockedExchange(&dword_806E114, v23);
    }
    *a6 = v33 + a4;
    v35 = dword_806E971 + v33;
    if ( *(_BYTE *)(a4 + v35) != 32 && *(_BYTE *)(a4 + v35) != 9 )
    {
      dword_806E1EC = (int)&loc_804B76F;
      v25 = _InterlockedExchange(&dword_806E1F0, v12);
      v26 = _InterlockedExchange(&dword_806E1F0, a4);
      _InterlockedExchange(&dword_806E1F0, v25);
      sub_806800D(v17);
      v27 = _InterlockedExchange(&dword_806E1F0, v26);
      _InterlockedExchange(&dword_806E1F0, v28);
      _InterlockedExchange(&dword_806E1F0, v27);
    }
    *(_BYTE *)(a4 + v35) = 0;
    v29 = sub_804B248(*a6, a4, v17, (_BYTE *)*a6) == 1;
    v31 = &loc_804B8B6;
    if ( v29 )
      v31 = &loc_804B8C0;
    dword_806E110 = (int)v31;
    sub_80685D2(v30);
    result = 0;
  }
  return result;
}
// 806800D: using guessed type int __fastcall sub_806800D(_DWORD);
// 806808A: using guessed type int __fastcall sub_806808A(_DWORD);
// 806812D: using guessed type int __fastcall sub_806812D(_DWORD);
// 80685D2: using guessed type int __fastcall sub_80685D2(_DWORD);
// 806E110: using guessed type int dword_806E110;
// 806E114: using guessed type int dword_806E114;
// 806E1C4: using guessed type int dword_806E1C4;
// 806E1C8: using guessed type int dword_806E1C8;
// 806E1D8: using guessed type int dword_806E1D8;
// 806E1EC: using guessed type int dword_806E1EC;
// 806E1F0: using guessed type int dword_806E1F0;
// 806E96D: using guessed type int dword_806E96D;
// 806E971: using guessed type int dword_806E971;

//----- (0804BA2A) --------------------------------------------------------
int __usercall sub_804BA2A@<eax>(signed __int32 a1@<ebx>, int ecx0@<ecx>, char *a2, char a3)
{
  void *v4; // eax
  signed __int32 v5; // eax
  signed __int32 v6; // eax
  signed __int32 v7; // edx
  int v8; // ecx
  int v9; // ecx
  signed __int32 v10; // ebx
  signed __int32 v11; // edx
  int v12; // eax
  bool v13; // zf
  void *v14; // eax
  int result; // eax

  v4 = &loc_804BA5A;
  if ( a3 == 1 )
    v4 = &loc_804BAA4;
  dword_806E124 = (int)v4;
  sub_8068556(ecx0);
  v5 = fputs_unlocked(a2, stdout);
  dword_806E19C = (int)&locret_804BB7F;
  v6 = _InterlockedExchange(&dword_806E1A0, v5);
  _InterlockedExchange(&dword_806E1A0, v7);
  _InterlockedExchange(&dword_806E1A0, v6);
  sub_8068230(v8);
  v10 = _InterlockedExchange(&dword_806E1A0, a1);
  _InterlockedExchange(&dword_806E1A0, v11);
  _InterlockedExchange(&dword_806E1A0, v10);
  while ( 1 )
  {
    result = (unsigned __int8)*a2;
    if ( !(_BYTE)result )
      break;
    v12 = *a2;
    if ( v12 == 10 )
    {
      fwrite_unlocked("\\n", 1u, 2u, stdout);
    }
    else
    {
      v13 = v12 == 92;
      v14 = &loc_804BAD5;
      if ( v13 )
        v14 = &loc_804BB01;
      dword_806E278 = (int)v14;
      sub_8067C35(v9);
      putchar_unlocked(*a2);
    }
    ++a2;
  }
  return result;
}
// 8048F20: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8067C35: using guessed type int __fastcall sub_8067C35(_DWORD);
// 8068230: using guessed type int __fastcall sub_8068230(_DWORD);
// 8068556: using guessed type int __fastcall sub_8068556(_DWORD);
// 806E124: using guessed type int dword_806E124;
// 806E19C: using guessed type int dword_806E19C;
// 806E1A0: using guessed type int dword_806E1A0;
// 806E278: using guessed type int dword_806E278;

//----- (0804BB81) --------------------------------------------------------
int __usercall sub_804BB81@<eax>(signed __int32 a1@<ebx>, char *s1, int a3, int a4, int a5)
{
  int v5; // edx
  int v6; // ecx
  bool v7; // ST1F_1
  void *v8; // eax
  int result; // eax
  int v10; // ebx
  int *v11; // eax
  bool v12; // zf
  int v13; // ecx
  void *v14; // eax
  int v15; // ebx
  int *v16; // eax
  FILE *stream; // [esp+18h] [ebp-10h]

  v7 = strcmp(s1, "-") == 0;
  *(_BYTE *)a5 = 0;
  if ( v7 )
  {
    byte_806E969 = 1;
    stream = stdin;
LABEL_9:
    sub_80630B1(a1, v5, v6, stream);
    v12 = sub_804E1F7(a1, stream, a4) == 0;
    v14 = &loc_804BCB4;
    if ( v12 )
      v14 = &loc_804BD13;
    dword_806E1EC = (int)v14;
    sub_806800D(v13);
    v15 = sub_8065388(a1, 0, 3, (signed __int32)s1);
    v16 = __errno_location();
    error(0, *v16, "%s", v15);
    if ( stream != stdin )
      sub_80663E4(stream);
    return 0;
  }
  stream = sub_8063241(a1, (int)s1, "r");
  if ( stream )
    goto LABEL_9;
  v8 = &loc_804BC07;
  if ( !byte_806E977 )
    v8 = &loc_804BC23;
  dword_806E110 = (int)v8;
  sub_80685D2(v6);
  if ( *__errno_location() == 2 )
  {
    *(_BYTE *)a5 = 1;
    result = 1;
  }
  else
  {
    v10 = sub_8065388(a1, 0, 3, (signed __int32)s1);
    v11 = __errno_location();
    error(0, *v11, "%s", v10);
    result = 0;
  }
  return result;
}
// 806800D: using guessed type int __fastcall sub_806800D(_DWORD);
// 80685D2: using guessed type int __fastcall sub_80685D2(_DWORD);
// 806E110: using guessed type int dword_806E110;
// 806E1EC: using guessed type int dword_806E1EC;
// 806E969: using guessed type char byte_806E969;
// 806E977: using guessed type char byte_806E977;

//----- (0804BDB7) --------------------------------------------------------
int __usercall __noreturn sub_804BDB7@<eax>(int a1@<ebx>, const char *a2)
{
  FILE *v2; // eax
  int v3; // edx
  int v4; // ecx
  bool v5; // zf
  void *v6; // eax
  int v7; // ebx
  int *v8; // eax
  signed __int32 v9; // eax
  signed __int32 v10; // edx
  int v11; // ecx
  signed __int32 v12; // ebx
  signed __int32 v13; // edx
  signed __int32 v14; // edx
  signed __int32 v15; // et1
  char *v16; // eax
  int v17; // edx
  int v18; // ecx
  void *v19; // eax
  int v20; // ecx
  void *v21; // eax
  char *v22; // eax
  int v23; // edx
  signed __int32 v24; // ecx
  signed __int32 v25; // ebx
  signed __int32 v26; // et2
  signed __int32 v27; // ebx
  signed __int32 v28; // ecx
  signed __int32 v29; // ecx
  signed __int32 v30; // ett
  int v31; // edx
  int v32; // ecx
  void *v33; // eax
  int v34; // ecx
  char *v35; // eax
  int v36; // eax
  int v37; // eax
  void *v38; // eax
  char *v39; // eax
  char *v40; // eax
  int v41; // edx
  int v42; // ecx
  int v43; // ebx
  char *v44; // eax
  int v45; // ecx
  int v46; // ebx
  int *v47; // eax
  int v48; // ebx
  char *v49; // eax
  void *v50; // eax
  int v51; // eax
  char *v52; // eax
  int v53; // ecx
  void *v54; // eax
  int v55; // eax
  char *v56; // eax
  int v57; // ecx
  void *v58; // eax
  int v59; // eax
  char *v60; // eax
  int v61; // ebx
  char *v62; // eax
  void *v63; // eax
  int v64; // ecx
  void *v65; // eax
  void *v66; // eax
  int v67; // ecx
  void *v68; // eax
  int (*v69)(); // eax
  char *s1; // [esp+1Ch] [ebp-BCh]
  int v72; // [esp+2Ah] [ebp-AEh]
  char v73; // [esp+2Eh] [ebp-AAh]
  unsigned __int8 v74; // [esp+2Fh] [ebp-A9h]
  void *ptr; // [esp+30h] [ebp-A8h]
  int v76; // [esp+34h] [ebp-A4h]
  char *s; // [esp+38h] [ebp-A0h]
  int v78; // [esp+3Ch] [ebp-9Ch]
  int v79; // [esp+40h] [ebp-98h]
  FILE *stream; // [esp+44h] [ebp-94h]
  int v81; // [esp+48h] [ebp-90h]
  unsigned int i; // [esp+4Ch] [ebp-8Ch]
  int v83; // [esp+50h] [ebp-88h]
  unsigned int v84; // [esp+54h] [ebp-84h]
  unsigned __int64 v85; // [esp+58h] [ebp-80h]
  __int64 v86; // [esp+60h] [ebp-78h]
  unsigned __int64 v87; // [esp+68h] [ebp-70h]
  unsigned __int64 v88; // [esp+70h] [ebp-68h]
  __int64 v89; // [esp+78h] [ebp-60h]
  char v90; // [esp+84h] [ebp-54h]
  unsigned int v91; // [esp+CCh] [ebp-Ch]

  s1 = (char *)a2;
  v91 = __readgsdword(0x14u);
  v85 = 0LL;
  v86 = 0LL;
  v87 = 0LL;
  v88 = 0LL;
  *(_WORD *)((char *)&v72 + 1) = 0;
  v83 = sub_804AD04((int)&v90, 8u);
  HIBYTE(v72) = strcmp(a2, "-") == 0;
  if ( HIBYTE(v72) )
  {
    byte_806E969 = 1;
    s1 = gettext("standard input");
    stream = stdin;
  }
  else
  {
    v2 = sub_8063241(a1, (int)a2, "r");
    stream = v2;
    v5 = v2 == 0;
    v6 = &loc_804BEC6;
    if ( !v5 )
      v6 = &loc_804BF44;
    dword_806E1B0 = (int)v6;
    sub_80681B2(v4, v3);
    v7 = sub_8065388(a1, 0, 3, (signed __int32)a2);
    v8 = __errno_location();
    error(0, *v8, "%s", v7);
    dword_806E188 = (int)&loc_804C847;
    v9 = _InterlockedExchange(&dword_806E18C, 0);
    _InterlockedExchange(&dword_806E18C, v10);
    _InterlockedExchange(&dword_806E18C, v9);
    sub_80682B5(v11);
    v12 = _InterlockedExchange(&dword_806E18C, v7);
    v15 = _InterlockedExchange(&dword_806E18C, v13);
    v14 = v12;
    a1 = v15;
    _InterlockedExchange(&dword_806E18C, v14);
  }
  v89 = 0LL;
  ptr = 0;
  v76 = 0;
  do
  {
    if ( !++v89 )
    {
      a1 = sub_8065388(a1, 0, 3, (signed __int32)s1);
      v16 = gettext("%s: too many checksum lines");
      error(1, 0, v16, a1);
    }
    v81 = getline(&ptr, &v76, stream);
    if ( v81 <= 0 )
      break;
    v19 = &loc_804C01D;
    if ( *(_BYTE *)ptr == 35 )
      v19 = &loc_804C44E;
    dword_806E264 = (int)v19;
    sub_8067CB2(v18, v17);
    v21 = &loc_804C04E;
    if ( *((_BYTE *)ptr + v81 - 1) != 10 )
      v21 = &loc_804C066;
    dword_806E214 = (int)v21;
    sub_8067ECF(v20);
    *((_BYTE *)ptr + --v81) = 0;
    if ( !sub_804B5CE((signed __int32)ptr, (signed __int32)&v79, a1, (signed __int32)ptr, v81, &v79, &v78, &s)
      || HIBYTE(v72) && !strcmp(s, "-") )
    {
      ++v85;
      if ( byte_806E976 )
      {
        a1 = sub_8065388(a1, 0, 3, (signed __int32)s1);
        v22 = gettext("%s: %llu: improperly formatted %s checksum line");
        error(0, 0, v22, a1, v89, "SHA512");
      }
      ++v86;
    }
    else
    {
      if ( byte_806E975 != 1 && strchr(s, 10) )
      {
        dword_806E264 = (int)&loc_804C1B7;
        v25 = _InterlockedExchange(&dword_806E268, a1);
        v26 = _InterlockedExchange(&dword_806E268, v24);
        sub_8067CB2(_InterlockedExchange(&dword_806E268, v25), v23);
        v27 = _InterlockedExchange(&dword_806E268, v26);
        v30 = _InterlockedExchange(&dword_806E268, v28);
        v29 = v27;
        a1 = v30;
        _InterlockedExchange(&dword_806E268, v29);
      }
      v73 = 0;
      BYTE1(v72) = 1;
      v74 = sub_804BB81(a1, s, (int)&v78, v83, (int)&v72);
      if ( v74 ^ 1 )
      {
        ++v88;
        v33 = &loc_804C23A;
        if ( byte_806E975 == 1 )
          v33 = &loc_804C44E;
        dword_806E250 = (int)v33;
        sub_8067D53(v32);
        if ( v73 )
          putchar_unlocked(92);
        sub_804BA2A(a1, v34, s, v73);
        v35 = gettext("FAILED open or read");
        printf(": %s\n", v35);
      }
      else if ( !byte_806E977 || !(_BYTE)v72 )
      {
        v84 = (unsigned int)dword_806E971 >> 1;
        for ( i = 0; i < v84; ++i )
        {
          v36 = tolower(*(unsigned __int8 *)(2 * i + v79));
          v32 = v83;
          v31 = byte_8069315[(unsigned __int8)(*(_BYTE *)(v83 + i) >> 4)];
          if ( v36 != v31 )
            break;
          v37 = tolower(*(unsigned __int8 *)(2 * i + 1 + v79));
          v32 = v83;
          v31 = byte_8069315[*(_BYTE *)(v83 + i) & 0xF];
          if ( v37 != v31 )
            break;
        }
        if ( i == v84 )
          BYTE2(v72) = 1;
        else
          ++v87;
        if ( byte_806E975 != 1 )
        {
          if ( i == v84 )
          {
            v38 = &loc_804C3C8;
            if ( byte_806E978 == 1 )
              v38 = &loc_804C3F6;
            dword_806E23C = (int)v38;
            sub_8067DD8(v32, v31);
          }
          if ( v73 )
            putchar_unlocked(92);
          sub_804BA2A(a1, v32, s, v73);
          if ( i == v84 )
          {
            if ( byte_806E978 != 1 )
            {
              v40 = gettext("OK");
              printf(": %s\n", v40);
            }
          }
          else
          {
            v39 = gettext("FAILED");
            printf(": %s\n", v39);
          }
        }
      }
    }
  }
  while ( !feof_unlocked(stream) && !ferror_unlocked(stream) );
  free(ptr);
  if ( ferror_unlocked(stream) )
  {
    v43 = sub_8065388(a1, 0, 3, (signed __int32)s1);
    v44 = gettext("%s: read error");
    error(0, 0, v44, v43);
  }
  else if ( HIBYTE(v72) != 1 && sub_80663E4(stream) )
  {
    v46 = sub_8065388(a1, 0, 3, (signed __int32)s1);
    v47 = __errno_location();
    error(0, *v47, "%s", v46);
  }
  else
  {
    if ( BYTE1(v72) == 1 )
    {
      if ( byte_806E975 != 1 )
      {
        v50 = &loc_804C5EF;
        if ( !v85 )
          v50 = &loc_804C641;
        dword_806E278 = (int)v50;
        sub_8067C35(v42);
        v51 = sub_804ACB6(a1, v85);
        v52 = ngettext(
                "WARNING: %llu line is improperly formatted",
                "WARNING: %llu lines are improperly formatted",
                v51);
        error(0, 0, v52, v85);
        v54 = &loc_804C666;
        if ( !v88 )
          v54 = &loc_804C6B8;
        dword_806E1D8 = (int)v54;
        sub_806808A(v53);
        v55 = sub_804ACB6(a1, v88);
        v56 = ngettext(
                "WARNING: %llu listed file could not be read",
                "WARNING: %llu listed files could not be read",
                v55);
        error(0, 0, v56, v88);
        v58 = &loc_804C6DD;
        if ( !v87 )
          v58 = &loc_804C72F;
        dword_806E1B0 = (int)v58;
        sub_80681B2(v57, HIDWORD(v87));
        v59 = sub_804ACB6(a1, v87);
        v60 = ngettext(
                "WARNING: %llu computed checksum did NOT match",
                "WARNING: %llu computed checksums did NOT match",
                v59);
        error(0, 0, v60, v87);
        if ( byte_806E977 && BYTE2(v72) != 1 )
        {
          v61 = sub_8065388(a1, 0, 3, (signed __int32)s1);
          v62 = gettext("%s: no file was verified");
          error(0, 0, v62, v61);
        }
      }
    }
    else
    {
      v48 = sub_8065388(a1, 0, 3, (signed __int32)s1);
      v49 = gettext("%s: no properly formatted %s checksum lines found");
      error(0, 0, v49, v48, "SHA512");
    }
    v63 = &loc_804C7B2;
    if ( !BYTE1(v72) )
      v63 = &loc_804C83F;
    dword_806E14C = (int)v63;
    sub_806844C(v42, v41);
    v65 = &loc_804C7D4;
    if ( !BYTE2(v72) )
      v65 = &loc_804C83F;
    dword_806E174 = (int)v65;
    sub_806833F(v64);
    if ( !v87 )
    {
      v66 = &loc_804C805;
      if ( v88 )
        v66 = &loc_804C83F;
      dword_806E138 = (int)v66;
      sub_80684CC(v45);
      v68 = &loc_804C82C;
      if ( byte_806E979 != 1 )
        v68 = &loc_804C838;
      dword_806E250 = (int)v68;
      sub_8067D53(v67);
    }
  }
  v69 = (int (*)())&loc_804C86C;
  if ( __readgsdword(0x14u) == v91 )
    v69 = sub_804C871;
  dword_806E1EC = (int)v69;
  return sub_806800D(v45);
}
// 8048D20: using guessed type int __cdecl getline(_DWORD, _DWORD, _DWORD);
// 804C871: using guessed type int sub_804C871();
// 8067C35: using guessed type int __fastcall sub_8067C35(_DWORD);
// 8067CB2: using guessed type int __fastcall sub_8067CB2(_DWORD, _DWORD);
// 8067D53: using guessed type int __fastcall sub_8067D53(_DWORD);
// 8067DD8: using guessed type int __fastcall sub_8067DD8(_DWORD, _DWORD);
// 8067ECF: using guessed type int __fastcall sub_8067ECF(_DWORD);
// 806800D: using guessed type int __fastcall sub_806800D(_DWORD);
// 806808A: using guessed type int __fastcall sub_806808A(_DWORD);
// 80681B2: using guessed type int __fastcall sub_80681B2(_DWORD, _DWORD);
// 80682B5: using guessed type int __fastcall sub_80682B5(_DWORD);
// 806833F: using guessed type int __fastcall sub_806833F(_DWORD);
// 806844C: using guessed type int __fastcall sub_806844C(_DWORD, _DWORD);
// 80684CC: using guessed type int __fastcall sub_80684CC(_DWORD);
// 806E138: using guessed type int dword_806E138;
// 806E14C: using guessed type int dword_806E14C;
// 806E174: using guessed type int dword_806E174;
// 806E188: using guessed type int dword_806E188;
// 806E18C: using guessed type int dword_806E18C;
// 806E1B0: using guessed type int dword_806E1B0;
// 806E1D8: using guessed type int dword_806E1D8;
// 806E1EC: using guessed type int dword_806E1EC;
// 806E214: using guessed type int dword_806E214;
// 806E23C: using guessed type int dword_806E23C;
// 806E250: using guessed type int dword_806E250;
// 806E264: using guessed type int dword_806E264;
// 806E268: using guessed type int dword_806E268;
// 806E278: using guessed type int dword_806E278;
// 806E969: using guessed type char byte_806E969;
// 806E971: using guessed type int dword_806E971;
// 806E975: using guessed type char byte_806E975;
// 806E976: using guessed type char byte_806E976;
// 806E977: using guessed type char byte_806E977;
// 806E978: using guessed type char byte_806E978;
// 806E979: using guessed type char byte_806E979;

//----- (0804C871) --------------------------------------------------------
#error "804C877: positive sp value has been found (funcsize=0)"

//----- (0804C87B) --------------------------------------------------------
int __usercall main@<eax>(signed __int32 a1@<ebx>, int argc, char **a3)
{
  int v3; // eax
  signed __int32 v4; // eax
  signed __int32 v5; // ecx
  int v6; // edx
  signed __int32 v7; // ebx
  signed __int32 v8; // ecx
  signed __int32 v9; // ecx
  char *v10; // ebx
  signed __int32 v11; // et1
  signed __int32 v12; // ecx
  void *v13; // eax
  void *v14; // eax
  signed __int32 v15; // ebx
  signed __int32 v16; // ecx
  signed __int32 v17; // et2
  signed __int32 v18; // edx
  signed __int32 v19; // ett
  signed __int32 v20; // ebx
  signed __int32 v21; // ecx
  signed __int32 v22; // et0
  signed __int32 v23; // ecx
  signed __int32 v24; // et1
  void *v25; // eax
  int v26; // edx
  int v27; // ecx
  char *v28; // eax
  char *v29; // eax
  char *v30; // eax
  char *v31; // eax
  char *v32; // eax
  char *v33; // eax
  void *v34; // eax
  int v35; // ecx
  char *v36; // eax
  signed __int32 v37; // edx
  int *v38; // eax
  signed __int32 v39; // ebx
  signed __int32 v40; // edx
  signed __int32 v41; // ett
  char v43; // [esp+3Ch] [ebp-78h]
  char v44; // [esp+3Eh] [ebp-76h]
  signed int v45; // [esp+44h] [ebp-70h]
  char **v46; // [esp+48h] [ebp-6Ch]
  const char **v47; // [esp+4Ch] [ebp-68h]
  int v48; // [esp+5Ch] [ebp-58h]
  const char *v49; // [esp+60h] [ebp-54h]
  int v50; // [esp+64h] [ebp-50h]
  unsigned int v51; // [esp+ACh] [ebp-8h]

  v51 = __readgsdword(0x14u);
  sub_804AD04((int)&v50, 8u);
  v43 = 0;
  v45 = -1;
  v44 = 0;
  sub_806339C(a1, *a3);
  setlocale(6, &locale);
  bindtextdomain("coreutils", "/home/hwangdz/coreutils/coreutils-8.28/install_m32/share/locale");
  textdomain("coreutils");
  sub_8067B3B((int)sub_804D234);
  v3 = setvbuf(stdout, 0, 1, 0);
  dword_806E214 = (int)&loc_804CBA1;
  v4 = _InterlockedExchange(&dword_806E218, v3);
  _InterlockedExchange(&dword_806E218, v5);
  sub_8067ECF(_InterlockedExchange(&dword_806E218, v4));
  v7 = _InterlockedExchange(&dword_806E218, a1);
  v11 = _InterlockedExchange(&dword_806E218, v8);
  v9 = v7;
  v10 = (char *)v11;
  v12 = _InterlockedExchange(&dword_806E218, v9);
  do
  {
    if ( v48 == 119 )
      goto LABEL_26;
    if ( v48 <= 119 )
    {
      if ( v48 == 98 )
      {
        v45 = 1;
        dword_806E124 = (int)&loc_804CBA1;
        v15 = _InterlockedExchange(&dword_806E128, (signed __int32)v10);
        v17 = _InterlockedExchange(&dword_806E128, v12);
        v16 = v15;
        v10 = (char *)v17;
        v19 = _InterlockedExchange(&dword_806E128, sub_8068556(_InterlockedExchange(&dword_806E128, v16)));
        _InterlockedExchange(&dword_806E128, v18);
        _InterlockedExchange(&dword_806E128, v19);
LABEL_23:
        v43 = 1;
        goto LABEL_33;
      }
      if ( v48 <= 98 )
      {
        if ( v48 == -131 )
        {
          sub_8065E13(
            off_806E2A4,
            v12,
            stdout,
            (int)"sha512sum",
            (int)"GNU coreutils",
            off_806E2A4,
            "Ulrich Drepper",
            "Scott Miller",
            "David Madore",
            0);
          exit(0);
        }
        if ( v48 == -130 )
          sub_804AF55(0);
LABEL_32:
        sub_804AF55(1);
      }
      if ( v48 == 99 )
        goto LABEL_23;
      if ( v48 != 116 )
        goto LABEL_32;
      v45 = 0;
      dword_806E1D8 = (int)&loc_804CBA1;
      v20 = _InterlockedExchange(&dword_806E1DC, (signed __int32)v10);
      v22 = _InterlockedExchange(&dword_806E1DC, v12);
      v21 = v20;
      v10 = (char *)v22;
      v24 = _InterlockedExchange(&dword_806E1DC, sub_806808A(_InterlockedExchange(&dword_806E1DC, v21)));
      _InterlockedExchange(&dword_806E1DC, v23);
      _InterlockedExchange(&dword_806E1DC, v24);
LABEL_26:
      byte_806E975 = 0;
      byte_806E976 = 1;
      byte_806E978 = 0;
      goto LABEL_33;
    }
    if ( v48 == 130 )
    {
      byte_806E975 = 0;
      byte_806E976 = 0;
      byte_806E978 = 1;
    }
    else if ( v48 > 130 )
    {
      v14 = &loc_804CA2E;
      if ( v48 == 131 )
        v14 = &loc_804CB1E;
      dword_806E1C4 = (int)v14;
      if ( sub_806812D(v12) != 132 )
        goto LABEL_32;
      v44 = 1;
      v45 = 1;
    }
    else
    {
      v13 = &loc_804CA02;
      if ( v48 == 128 )
        v13 = &loc_804CAF8;
      dword_806E14C = (int)v13;
      if ( sub_806844C(v12, v6) != 129 )
        goto LABEL_32;
      byte_806E975 = 1;
      byte_806E976 = 0;
      byte_806E978 = 0;
    }
LABEL_33:
    v48 = getopt_long(argc, a3, "bctw", &longopts, 0);
  }
  while ( v48 != -1 );
  dword_806E96D = 130;
  dword_806E971 = 128;
  v25 = &loc_804CC0F;
  if ( !v44 )
    v25 = &loc_804CC46;
  dword_806E14C = (int)v25;
  sub_806844C(v12, v6);
  if ( !v45 )
  {
    v28 = gettext("--tag does not support --text mode");
    error(0, 0, v28);
    sub_804AF55(1);
  }
  if ( v44 && v43 )
  {
    v29 = gettext("the --tag option is meaningless when verifying checksums");
    error(0, 0, v29);
    sub_804AF55(1);
  }
  if ( v45 >= 0 && v43 )
  {
    v30 = gettext("the --binary and --text options are meaningless when verifying checksums");
    error(0, 0, v30);
    sub_804AF55(1);
  }
  if ( byte_806E977 && v43 != 1 )
  {
    v31 = gettext("the --ignore-missing option is meaningful only when verifying checksums");
    error(0, 0, v31);
    sub_804AF55(1);
  }
  if ( byte_806E975 && v43 != 1 )
  {
    v32 = gettext("the --status option is meaningful only when verifying checksums");
    error(0, 0, v32);
    sub_804AF55(1);
  }
  if ( byte_806E976 && v43 != 1 )
  {
    v33 = gettext("the --warn option is meaningful only when verifying checksums");
    error(0, 0, v33);
    sub_804AF55(1);
  }
  v34 = &loc_804CDBB;
  if ( !byte_806E978 )
    v34 = &loc_804CDF7;
  dword_806E200 = (int)v34;
  sub_8067F6F(v27, v26);
  if ( v43 != 1 )
  {
    v36 = gettext("the --quiet option is meaningful only when verifying checksums");
    error(0, 0, v36);
    sub_804AF55(1);
  }
  v46 = &a3[argc];
  if ( optind == argc )
  {
    v10 = (char *)&a3[argc];
    ++v46;
    *(_DWORD *)v10 = sub_804AF4D((int)"-");
  }
  v37 = 4 * optind;
  v47 = (const char **)&a3[optind];
  if ( v47 < (const char **)v46 )
  {
    v49 = *v47;
    dword_806E1D8 = (int)&loc_804CECD;
    sub_806808A(v35);
    sub_804BDB7(1, v49);
  }
  if ( byte_806E969 && sub_80663E4(stdin) == -1 )
  {
    v10 = gettext("standard input");
    v38 = __errno_location();
    error(1, *v38, v10);
  }
  dword_806E19C = (int)&loc_804D1F6;
  v39 = _InterlockedExchange(&dword_806E1A0, (signed __int32)v10);
  _InterlockedExchange(&dword_806E1A0, v37);
  _InterlockedExchange(&dword_806E1A0, v39);
  v41 = _InterlockedExchange(&dword_806E1A0, sub_8068230(v35));
  _InterlockedExchange(&dword_806E1A0, v40);
  _InterlockedExchange(&dword_806E1A0, v41);
  return 1;
}
// 8067ECF: using guessed type int __fastcall sub_8067ECF(_DWORD);
// 8067F6F: using guessed type int __fastcall sub_8067F6F(_DWORD, _DWORD);
// 806808A: using guessed type int __fastcall sub_806808A(_DWORD);
// 806812D: using guessed type int __fastcall sub_806812D(_DWORD);
// 8068230: using guessed type int __fastcall sub_8068230(_DWORD);
// 806844C: using guessed type int __fastcall sub_806844C(_DWORD, _DWORD);
// 8068556: using guessed type int __fastcall sub_8068556(_DWORD);
// 806E124: using guessed type int dword_806E124;
// 806E128: using guessed type int dword_806E128;
// 806E14C: using guessed type int dword_806E14C;
// 806E19C: using guessed type int dword_806E19C;
// 806E1A0: using guessed type int dword_806E1A0;
// 806E1C4: using guessed type int dword_806E1C4;
// 806E1D8: using guessed type int dword_806E1D8;
// 806E1DC: using guessed type int dword_806E1DC;
// 806E200: using guessed type int dword_806E200;
// 806E214: using guessed type int dword_806E214;
// 806E218: using guessed type int dword_806E218;
// 806E340: using guessed type int optind;
// 806E969: using guessed type char byte_806E969;
// 806E96D: using guessed type int dword_806E96D;
// 806E971: using guessed type int dword_806E971;
// 806E975: using guessed type char byte_806E975;
// 806E976: using guessed type char byte_806E976;
// 806E977: using guessed type char byte_806E977;
// 806E978: using guessed type char byte_806E978;
// 806E979: using guessed type char byte_806E979;

//----- (0804D234) --------------------------------------------------------
int __usercall sub_804D234@<eax>(signed __int32 a1@<ebx>)
{
  int v1; // ecx
  void *v2; // eax
  void *v3; // ebx
  int *v4; // eax
  signed __int32 v5; // eax
  signed __int32 v6; // eax
  signed __int32 v7; // edx
  int v8; // ecx
  signed __int32 v9; // ebx
  signed __int32 v10; // edx
  int *v11; // eax
  int result; // eax
  char *v13; // [esp+2Ch] [ebp-Ch]

  if ( sub_8066B41(a1, stdout) )
  {
    v2 = &loc_804D277;
    if ( byte_806E981 != 1 )
      v2 = &loc_804D287;
    dword_806E1EC = (int)v2;
    sub_806800D(v1);
    if ( *__errno_location() != 32 )
    {
      v13 = gettext("write error");
      if ( dword_806E97D )
      {
        v3 = sub_8065269(dword_806E97D);
        v4 = __errno_location();
        error(0, *v4, "%s: %s", v3, v13);
        dword_806E1D8 = (int)&loc_804D334;
        v6 = _InterlockedExchange(&dword_806E1DC, v5);
        _InterlockedExchange(&dword_806E1DC, v7);
        _InterlockedExchange(&dword_806E1DC, v6);
        sub_806808A(v8);
        v9 = _InterlockedExchange(&dword_806E1DC, (signed __int32)v3);
        _InterlockedExchange(&dword_806E1DC, v10);
        _InterlockedExchange(&dword_806E1DC, v9);
      }
      v11 = __errno_location();
      error(0, *v11, "%s", v13);
      _exit(status);
    }
  }
  result = sub_8066B41(a1, stderr);
  if ( result )
    _exit(status);
  return result;
}
// 806800D: using guessed type int __fastcall sub_806800D(_DWORD);
// 806808A: using guessed type int __fastcall sub_806808A(_DWORD);
// 806E1D8: using guessed type int dword_806E1D8;
// 806E1DC: using guessed type int dword_806E1DC;
// 806E1EC: using guessed type int dword_806E1EC;
// 806E97D: using guessed type int dword_806E97D;
// 806E981: using guessed type char byte_806E981;

//----- (0804D365) --------------------------------------------------------
_DWORD *__cdecl sub_804D365(_DWORD *a1)
{
  int v1; // edx
  _DWORD *result; // eax

  *a1 = -205731576;
  a1[1] = 1779033703;
  a1[2] = -2067093701;
  a1[3] = -1150833019;
  a1[4] = -23791573;
  a1[5] = 1013904242;
  a1[6] = 1595750129;
  a1[7] = -1521486534;
  a1[8] = -1377402159;
  a1[9] = 1359893119;
  a1[10] = 725511199;
  a1[11] = -1694144372;
  a1[12] = -79577749;
  a1[13] = 528734635;
  a1[14] = 327033209;
  a1[15] = 1541459225;
  a1[18] = 0;
  a1[19] = 0;
  v1 = a1[19];
  a1[16] = a1[18];
  a1[17] = v1;
  result = a1;
  a1[20] = 0;
  return result;
}

//----- (0804D41E) --------------------------------------------------------
_DWORD *__cdecl sub_804D41E(_DWORD *a1)
{
  int v1; // edx
  _DWORD *result; // eax

  *a1 = -1056596264;
  a1[1] = -876896931;
  a1[2] = 914150663;
  a1[3] = 1654270250;
  a1[4] = 812702999;
  a1[5] = -1856437926;
  a1[6] = -150054599;
  a1[7] = 355462360;
  a1[8] = -4191439;
  a1[9] = 1731405415;
  a1[10] = 1750603025;
  a1[11] = -1900787065;
  a1[12] = 1694076839;
  a1[13] = -619958771;
  a1[14] = -1090891868;
  a1[15] = 1203062813;
  a1[18] = 0;
  a1[19] = 0;
  v1 = a1[19];
  a1[16] = a1[18];
  a1[17] = v1;
  result = a1;
  a1[20] = 0;
  return result;
}

//----- (0804D4D7) --------------------------------------------------------
int __cdecl sub_804D4D7(_DWORD *a1, int a2, int a3)
{
  int result; // eax

  result = a2;
  *a1 = a2;
  a1[1] = a3;
  return result;
}

//----- (0804D4F9) --------------------------------------------------------
int __usercall sub_804D4F9@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, int a3, int a4)
{
  signed __int32 v4; // ebx
  signed __int32 v5; // edx
  signed __int32 v6; // et1
  _DWORD *v7; // edx
  int v8; // et1
  int v9; // ebx
  _DWORD *v10; // edx
  int v11; // et1
  int v12; // ST64_4
  _DWORD *v13; // edx
  int v14; // et1
  int v15; // ST58_4
  _DWORD *v16; // edx
  int v17; // et1
  unsigned int v18; // ST50_4
  int *v19; // edx
  int v20; // et1
  int v21; // ST20_4
  int *v22; // edx
  int v23; // et1
  signed int v25; // [esp+80h] [ebp-18h]

  v25 = 0;
  dword_806E138 = (int)&loc_804D756;
  v4 = _InterlockedExchange(&dword_806E13C, a2);
  _InterlockedExchange(&dword_806E13C, a1);
  v6 = _InterlockedExchange(&dword_806E13C, sub_80684CC(_InterlockedExchange(&dword_806E13C, v4)));
  _InterlockedExchange(&dword_806E13C, v5);
  _InterlockedExchange(&dword_806E13C, v6);
  do
  {
    v7 = (_DWORD *)(a3 + 8 * v25);
    v8 = v7[1];
    v9 = *v7 << 24;
    v10 = (_DWORD *)(a3 + 8 * v25);
    v11 = v10[1];
    v12 = ((*v10 & 0xFF00) << 8) | v9;
    v13 = (_DWORD *)(a3 + 8 * v25);
    v14 = v13[1];
    v15 = *v13 & 0xFF0000;
    v16 = (_DWORD *)(a3 + 8 * v25);
    v17 = v16[1];
    v18 = *v16 & 0xFF000000;
    v19 = (int *)(a3 + 8 * v25);
    v20 = *v19;
    v21 = ((unsigned int)v19[1] >> 8) & 0xFF00;
    v22 = (int *)(a3 + 8 * v25);
    v23 = *v22;
    sub_804D4D7(
      (_DWORD *)(8 * v25 + a4),
      ((unsigned int)v22[1] >> 24) | v21 | (*(_QWORD *)(a3 + 8 * v25) >> 24) & 0xFF0000 | (*(_QWORD *)(a3 + 8 * v25) >> 8) & 0xFF000000 | (v18 << 8) | (v15 << 24),
      ((unsigned __int64)v18 >> 24) | ((unsigned __int64)(unsigned int)v15 >> 8) | v12);
    ++v25;
  }
  while ( v25 <= 7 );
  return a4;
}
// 80684CC: using guessed type int __fastcall sub_80684CC(_DWORD);
// 806E138: using guessed type int dword_806E138;
// 806E13C: using guessed type int dword_806E13C;

//----- (0804D7DB) --------------------------------------------------------
signed __int32 __usercall sub_804D7DB@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, int a3, signed __int32 a4)
{
  signed __int32 v4; // eax
  signed __int32 v5; // ebx
  signed __int32 v6; // ecx
  _DWORD *v7; // edx
  int v8; // et1
  int v9; // ebx
  _DWORD *v10; // edx
  int v11; // et1
  int v12; // ST64_4
  _DWORD *v13; // edx
  int v14; // et1
  int v15; // ST58_4
  _DWORD *v16; // edx
  int v17; // et1
  unsigned int v18; // ST50_4
  int *v19; // edx
  int v20; // et1
  int v21; // ST20_4
  int *v22; // edx
  int v23; // et1
  signed int v25; // [esp+80h] [ebp-18h]

  v25 = 0;
  dword_806E174 = (int)&loc_804DA27;
  v4 = _InterlockedExchange(&dword_806E178, a4);
  _InterlockedExchange(&dword_806E178, a1);
  sub_806833F(_InterlockedExchange(&dword_806E178, v4));
  v5 = _InterlockedExchange(&dword_806E178, a2);
  _InterlockedExchange(&dword_806E178, v6);
  _InterlockedExchange(&dword_806E178, v5);
  do
  {
    v7 = (_DWORD *)(a3 + 8 * v25);
    v8 = v7[1];
    v9 = *v7 << 24;
    v10 = (_DWORD *)(a3 + 8 * v25);
    v11 = v10[1];
    v12 = ((*v10 & 0xFF00) << 8) | v9;
    v13 = (_DWORD *)(a3 + 8 * v25);
    v14 = v13[1];
    v15 = *v13 & 0xFF0000;
    v16 = (_DWORD *)(a3 + 8 * v25);
    v17 = v16[1];
    v18 = *v16 & 0xFF000000;
    v19 = (int *)(a3 + 8 * v25);
    v20 = *v19;
    v21 = ((unsigned int)v19[1] >> 8) & 0xFF00;
    v22 = (int *)(a3 + 8 * v25);
    v23 = *v22;
    sub_804D4D7(
      (_DWORD *)(8 * v25 + a4),
      ((unsigned int)v22[1] >> 24) | v21 | (*(_QWORD *)(a3 + 8 * v25) >> 24) & 0xFF0000 | (*(_QWORD *)(a3 + 8 * v25) >> 8) & 0xFF000000 | (v18 << 8) | (v15 << 24),
      ((unsigned __int64)v18 >> 24) | ((unsigned __int64)(unsigned int)v15 >> 8) | v12);
    ++v25;
  }
  while ( v25 <= 5 );
  return a4;
}
// 806833F: using guessed type int __fastcall sub_806833F(_DWORD);
// 806E174: using guessed type int dword_806E174;
// 806E178: using guessed type int dword_806E178;

//----- (0804DA3F) --------------------------------------------------------
int __cdecl sub_804DA3F(int a1)
{
  signed int v1; // eax
  int v3; // et1
  int v4; // et1
  int v5; // et1
  int v6; // et1
  unsigned int v7; // STF8_4
  int v8; // et1
  int v9; // STE8_4
  int v10; // et1
  int v11; // et1
  int v12; // et1
  int v13; // et1
  int v14; // et1
  int v15; // et1
  int v16; // et1
  int v17; // et1
  unsigned int v18; // [esp+128h] [ebp-20h]
  signed int v19; // [esp+12Ch] [ebp-1Ch]

  v18 = *(_DWORD *)(a1 + 80);
  if ( v18 > 0x6F )
    v1 = 32;
  else
    v1 = 16;
  v19 = v1;
  *(_QWORD *)(a1 + 64) += v18;
  if ( *(_QWORD *)(a1 + 64) < (unsigned __int64)v18 )
    ++*(_QWORD *)(a1 + 72);
  v3 = *(_DWORD *)(a1 + 76);
  v4 = *(_DWORD *)(a1 + 64);
  v5 = *(_DWORD *)(a1 + 64);
  v6 = *(_DWORD *)(a1 + 64);
  v7 = *(_QWORD *)(a1 + 68) >> 29;
  v8 = *(_DWORD *)(a1 + 64);
  v9 = *(_QWORD *)(a1 + 68) >> 29;
  v10 = *(_DWORD *)(a1 + 64);
  v11 = *(_DWORD *)(a1 + 64);
  v12 = *(_DWORD *)(a1 + 64);
  v13 = *(_DWORD *)(a1 + 64);
  sub_804D4D7(
    (_DWORD *)(8 * (v1 - 2 + 10) + a1 + 4),
    ((unsigned int)(*(_QWORD *)(a1 + 72) >> 29) >> 24) | ((unsigned int)(*(_QWORD *)(a1 + 72) >> 29) >> 8) & 0xFF00 | (__PAIR__(*(_QWORD *)(a1 + 72) >> 29, v7) >> 24) & 0xFF0000 | (__PAIR__(*(_QWORD *)(a1 + 72) >> 29, v7) >> 8) & 0xFF000000 | ((v9 & 0xFF000000) << 8) | ((v7 & 0xFF0000) << 24),
    ((v9 & 0xFF000000) >> 24) | ((v7 & 0xFF0000uLL) >> 8) | ((unsigned __int16)((*(_QWORD *)(a1 + 68) >> 29) & 0xFF00) << 8) | (v7 << 24));
  v14 = *(_DWORD *)(a1 + 68);
  v15 = *(_DWORD *)(a1 + 68);
  v16 = *(_DWORD *)(a1 + 68);
  v17 = *(_DWORD *)(a1 + 68);
  sub_804D4D7(
    (_DWORD *)(8 * (v19 - 1 + 10) + a1 + 4),
    ((unsigned int)(*(_QWORD *)(a1 + 64) >> 29) >> 24) | ((unsigned int)(*(_QWORD *)(a1 + 64) >> 29) >> 8) & 0xFF00 | ((unsigned __int64)(8LL * *(_QWORD *)(a1 + 64)) >> 24) & 0xFF0000 | ((unsigned __int64)(8LL * *(_QWORD *)(a1 + 64)) >> 8) & 0xFF000000 | ((8 * *(_DWORD *)(a1 + 64) & 0xFF000000) << 8) | ((8 * *(_DWORD *)(a1 + 64) & 0xFF0000) << 24),
    ((8 * *(_DWORD *)(a1 + 64) & 0xFF000000) >> 24) | ((8 * *(_DWORD *)(a1 + 64) & 0xFF0000u) >> 8) | ((unsigned __int16)(8 * *(unsigned int *)(a1 + 64) & 0xFF00) << 8) | (*(_DWORD *)(a1 + 64) << 27));
  memcpy((void *)(a1 + 84 + v18), &unk_8069340, 8 * (v19 + 536870910) - v18);
  return sub_804E816(a1 + 84, 8 * v19, a1);
}
// 804E816: using guessed type _DWORD __cdecl sub_804E816(_DWORD, _DWORD, _DWORD);

//----- (0804E1AD) --------------------------------------------------------
int __usercall sub_804E1AD@<eax>(signed __int32 a1@<ebx>, int a2, int a3)
{
  signed __int32 v3; // ecx

  sub_804DA3F(a2);
  return sub_804D4F9(v3, a1, a2, a3);
}

//----- (0804E1D2) --------------------------------------------------------
signed __int32 __usercall sub_804E1D2@<eax>(signed __int32 a1@<ebx>, int a2, signed __int32 a3)
{
  signed __int32 v3; // ecx

  sub_804DA3F(a2);
  return sub_804D7DB(v3, a1, a2, a3);
}

//----- (0804E1F7) --------------------------------------------------------
int __usercall sub_804E1F7@<eax>(signed __int32 a1@<ebx>, FILE *stream, int a3)
{
  int result; // eax
  int v4; // edx
  int v5; // ecx
  void *v6; // eax
  void *ptr; // [esp+14h] [ebp-164h]
  size_t v8; // [esp+18h] [ebp-160h]
  int v9; // [esp+1Ch] [ebp-15Ch]

  ptr = malloc(0x8048u);
  if ( !ptr )
    return 1;
  sub_804D365(&v9);
  while ( 1 )
  {
    v8 = fread_unlocked(ptr, 1u, 0x8000u, stream);
    if ( v8 != 0x8000 )
      break;
    sub_804E816(ptr, 0x8000, &v9);
  }
  v6 = &loc_804E393;
  if ( v8 )
    v6 = &loc_804E2EA;
  dword_806E264 = (int)v6;
  sub_8067CB2(v5, v4);
  if ( ferror_unlocked(stream) )
  {
    free(ptr);
    result = 1;
  }
  else
  {
    if ( v8 )
      sub_804E599(ptr, v8, (int)&v9);
    sub_804E1AD(a1, (int)&v9, a3);
    free(ptr);
    result = 0;
  }
  return result;
}
// 804E816: using guessed type _DWORD __cdecl sub_804E816(_DWORD, _DWORD, _DWORD);
// 8067CB2: using guessed type int __fastcall sub_8067CB2(_DWORD, _DWORD);
// 806E264: using guessed type int dword_806E264;

//----- (0804E398) --------------------------------------------------------
int __usercall sub_804E398@<eax>(signed __int32 a1@<ebx>, FILE *stream, int a3)
{
  bool v4; // zf
  int v5; // ecx
  void *v6; // eax
  size_t v7; // [esp+10h] [ebp-168h]
  char *ptr; // [esp+14h] [ebp-164h]
  size_t v9; // [esp+18h] [ebp-160h]
  int v10; // [esp+1Ch] [ebp-15Ch]

  ptr = (char *)malloc(0x8048u);
  if ( !ptr )
    return 1;
  sub_804D41E(&v10);
LABEL_4:
  v7 = 0;
  do
  {
    v9 = fread_unlocked(&ptr[v7], 1u, 0x8000 - v7, stream);
    v7 += v9;
    if ( v7 == 0x8000 )
    {
      sub_804E816(ptr, 0x8000, &v10);
      goto LABEL_4;
    }
    if ( !v9 )
    {
      v4 = ferror_unlocked(stream) == 0;
      v6 = &loc_804E483;
      if ( v4 )
        v6 = &loc_804E498;
      dword_806E19C = (int)v6;
      sub_8068230(v5);
      free(ptr);
      return 1;
    }
  }
  while ( !feof_unlocked(stream) );
  if ( v7 )
    sub_804E599(ptr, v7, (int)&v10);
  sub_804E1D2(a1, (int)&v10, a3);
  free(ptr);
  return 0;
}
// 804E816: using guessed type _DWORD __cdecl sub_804E816(_DWORD, _DWORD, _DWORD);
// 8068230: using guessed type int __fastcall sub_8068230(_DWORD);
// 806E19C: using guessed type int dword_806E19C;

//----- (0804E599) --------------------------------------------------------
int __cdecl sub_804E599(void *src, size_t a2, int a3)
{
  int v3; // ecx
  int v4; // eax
  void *v5; // eax
  void *v6; // eax
  size_t v7; // ST1C_4
  int result; // eax
  size_t v9; // [esp+14h] [ebp-14h]
  int v10; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]

  if ( *(_DWORD *)(a3 + 80) )
  {
    v10 = *(_DWORD *)(a3 + 80);
    v4 = a2;
    if ( 256 - v10 <= a2 )
      v4 = 256 - v10;
    n = v4;
    memcpy((void *)(v10 + a3 + 84), src, v4);
    *(_DWORD *)(a3 + 80) += n;
    if ( *(_DWORD *)(a3 + 80) > 0x80u )
    {
      sub_804E816(a3 + 84, *(_DWORD *)(a3 + 80) & 0xFFFFFF80, a3);
      *(_DWORD *)(a3 + 80) &= 0x7Fu;
      memcpy((void *)(a3 + 84), (const void *)(a3 + 84 + ((v10 + n) & 0xFFFFFF80)), *(_DWORD *)(a3 + 80));
    }
    src = (char *)src + n;
    a2 -= n;
  }
  if ( a2 > 0x7F )
  {
    if ( (unsigned __int8)src & 3 )
    {
      while ( a2 > 0x80 )
      {
        v5 = memcpy((void *)(a3 + 84), src, 0x80u);
        sub_804E816(v5, 128, a3);
        src = (char *)src + 128;
        a2 -= 128;
      }
    }
    else
    {
      sub_804E816(src, a2 & 0xFFFFFF80, a3);
      src = (char *)src + (a2 & 0xFFFFFF80);
      a2 &= 0x7Fu;
    }
  }
  v6 = &loc_804E759;
  if ( !a2 )
    v6 = &loc_804E681;
  dword_806E214 = (int)v6;
  sub_8067ECF(v3);
  v7 = *(_DWORD *)(a3 + 80);
  memcpy((void *)(v7 + a3 + 84), src, a2);
  v9 = a2 + v7;
  if ( v9 > 0x7F )
  {
    sub_804E816(a3 + 84, 128, a3);
    v9 -= 128;
    memcpy((void *)(a3 + 84), (const void *)(a3 + 212), v9);
  }
  result = a3;
  *(_DWORD *)(a3 + 80) = v9;
  return result;
}
// 804E816: using guessed type _DWORD __cdecl sub_804E816(_DWORD, _DWORD, _DWORD);
// 8067ECF: using guessed type int __fastcall sub_8067ECF(_DWORD);
// 806E214: using guessed type int dword_806E214;

//----- (0804E816) --------------------------------------------------------
#error "804E816: too big function (funcsize=0)"

//----- (08063060) --------------------------------------------------------
int __cdecl sub_8063060(int a1, int a2, int a3, int a4, int a5, int a6)
{
  return posix_fadvise64(a1, a2, a3, a4, a5, a6);
}
// 8049050: using guessed type int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (080630B1) --------------------------------------------------------
int __usercall sub_80630B1@<eax>(signed __int32 a1@<ebx>, int a2@<edx>, int a3@<ecx>, FILE *stream)
{
  void *v4; // eax
  signed __int32 v5; // ebx
  signed __int32 v6; // ecx
  signed __int32 v7; // et0
  int result; // eax
  signed __int32 v9; // ebx
  signed __int32 v10; // ecx

  v4 = &loc_80630D6;
  if ( !stream )
    v4 = &locret_8063118;
  dword_806E200 = (int)v4;
  sub_8067F6F(a3, a2);
  fileno(stream);
  dword_806E1D8 = (int)sub_80631A6;
  v5 = _InterlockedExchange(&dword_806E1DC, a1);
  v7 = _InterlockedExchange(&dword_806E1DC, v6);
  result = sub_806808A(_InterlockedExchange(&dword_806E1DC, v5));
  v9 = _InterlockedExchange(&dword_806E1DC, v7);
  _InterlockedExchange(&dword_806E1DC, v10);
  _InterlockedExchange(&dword_806E1DC, v9);
  return result;
}
// 80631A6: using guessed type int sub_80631A6();
// 8067F6F: using guessed type int __fastcall sub_8067F6F(_DWORD, _DWORD);
// 806808A: using guessed type int __fastcall sub_806808A(_DWORD);
// 806E1D8: using guessed type int dword_806E1D8;
// 806E1DC: using guessed type int dword_806E1DC;
// 806E200: using guessed type int dword_806E200;

//----- (08063241) --------------------------------------------------------
FILE *__usercall sub_8063241@<eax>(signed __int32 a1@<ebx>, int a2, char *modes)
{
  signed int v3; // eax
  int v5; // ST30_4
  bool v6; // zf
  int v7; // edx
  int v8; // ecx
  void *v9; // eax
  FILE *v10; // eax
  int v11; // ecx
  void *v12; // eax
  int v13; // ST34_4
  signed __int32 v14; // edx
  signed __int32 v15; // ebx
  int v16; // ecx
  signed __int32 v17; // ebx
  signed __int32 v18; // ecx
  FILE *stream; // [esp+1Ch] [ebp-1Ch]
  int fd; // [esp+24h] [ebp-14h]

  stream = (FILE *)fopen64(a2, modes);
  if ( stream )
  {
    v3 = fileno(stream);
    if ( v3 >= 0 && v3 <= 2 )
    {
      fd = sub_8065761(a1, v3);
      if ( fd < 0 )
      {
        v5 = *__errno_location();
        sub_80663E4(stream);
        *__errno_location() = v5;
        return 0;
      }
      v6 = sub_80663E4(stream) == 0;
      v9 = &loc_8063308;
      if ( !v6 )
        v9 = &loc_806333C;
      dword_806E14C = (int)v9;
      sub_806844C(v8, v7);
      v10 = fdopen(fd, modes);
      stream = v10;
      v6 = v10 == 0;
      v12 = &loc_806333C;
      if ( !v6 )
        v12 = &loc_8063397;
      dword_806E278 = (int)v12;
      sub_8067C35(v11);
      v13 = *__errno_location();
      close(fd);
      *__errno_location() = v13;
      dword_806E200 = (int)&locret_806339A;
      v14 = _InterlockedExchange(&dword_806E204, a1);
      v15 = _InterlockedExchange(&dword_806E204, v13);
      sub_8067F6F(v16, _InterlockedExchange(&dword_806E204, v14));
      v17 = _InterlockedExchange(&dword_806E204, v15);
      _InterlockedExchange(&dword_806E204, v18);
      _InterlockedExchange(&dword_806E204, v17);
    }
  }
  return stream;
}
// 8048E10: using guessed type int __cdecl fopen64(_DWORD, _DWORD);
// 8067C35: using guessed type int __fastcall sub_8067C35(_DWORD);
// 8067F6F: using guessed type int __fastcall sub_8067F6F(_DWORD, _DWORD);
// 806844C: using guessed type int __fastcall sub_806844C(_DWORD, _DWORD);
// 806E14C: using guessed type int dword_806E14C;
// 806E200: using guessed type int dword_806E200;
// 806E204: using guessed type int dword_806E204;
// 806E278: using guessed type int dword_806E278;

//----- (0806339C) --------------------------------------------------------
char *__usercall sub_806339C@<eax>(signed __int32 a1@<ebx>, char *s)
{
  bool v2; // zf
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  signed __int32 v6; // ebx
  signed __int32 v7; // edx
  signed __int32 v8; // et0
  int v9; // ecx
  signed __int32 v10; // ebx
  signed __int32 v11; // edx
  char *result; // eax

  if ( !s )
  {
    fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
    abort();
  }
  v2 = strrchr(s, 47) == 0;
  v5 = &loc_8063411;
  if ( v2 )
    v5 = &loc_806344E;
  dword_806E14C = (int)v5;
  sub_806844C(v4, v3);
  dword_806E23C = (int)&loc_8063451;
  v6 = _InterlockedExchange(&dword_806E240, a1);
  v8 = _InterlockedExchange(&dword_806E240, v7);
  sub_8067DD8(v9, _InterlockedExchange(&dword_806E240, v6));
  v10 = _InterlockedExchange(&dword_806E240, v8);
  _InterlockedExchange(&dword_806E240, v11);
  _InterlockedExchange(&dword_806E240, v10);
  dword_806E985 = (int)s;
  result = s;
  program_invocation_name = (int)s;
  return result;
}
// 8067DD8: using guessed type int __fastcall sub_8067DD8(_DWORD, _DWORD);
// 806844C: using guessed type int __fastcall sub_806844C(_DWORD, _DWORD);
// 80685D2: using guessed type int __fastcall sub_80685D2(_DWORD);
// 806E110: using guessed type int dword_806E110;
// 806E14C: using guessed type int dword_806E14C;
// 806E23C: using guessed type int dword_806E23C;
// 806E240: using guessed type int dword_806E240;
// 806E320: using guessed type int program_invocation_short_name;
// 806E330: using guessed type int program_invocation_name;
// 806E985: using guessed type int dword_806E985;

//----- (08063595) --------------------------------------------------------
int __cdecl sub_8063595(int *a1, unsigned __int8 a2, char a3)
{
  int *v3; // eax
  int v4; // ST10_4

  if ( a1 )
    v3 = a1;
  else
    v3 = &dword_806E99D;
  v4 = ((unsigned int)v3[(a2 >> 5) + 2] >> (a2 & 0x1F)) & 1;
  v3[(a2 >> 5) + 2] ^= (v4 ^ a3 & 1) << (a2 & 0x1F);
  return v4;
}
// 806E99D: using guessed type int dword_806E99D;

//----- (0806363F) --------------------------------------------------------
void __usercall __noreturn sub_806363F(signed __int32 a1@<eax>, signed __int32 a2@<edx>, signed __int32 a3@<ecx>, _DWORD *a4, int a5, int a6)
{
  signed __int32 v6; // eax
  signed __int32 v7; // ecx
  signed __int32 v8; // et1
  int (*v9)(); // eax

  if ( a4 )
  {
    *a4 = 10;
    if ( !a5 )
      goto LABEL_7;
  }
  else
  {
    dword_806E250 = (int)&loc_80636E6;
    v6 = _InterlockedExchange(&dword_806E254, a1);
    _InterlockedExchange(&dword_806E254, a2);
    _InterlockedExchange(&dword_806E254, v6);
    v8 = _InterlockedExchange(&dword_806E254, sub_8067D53(a3));
    _InterlockedExchange(&dword_806E254, v7);
    a3 = _InterlockedExchange(&dword_806E254, v8);
  }
  v9 = (int (*)())&loc_80636AA;
  if ( a6 )
    v9 = sub_80636FE;
  dword_806E1EC = (int)v9;
  sub_806800D(a3);
LABEL_7:
  abort();
}
// 80636FE: using guessed type int sub_80636FE();
// 8067D53: using guessed type int __fastcall sub_8067D53(_DWORD);
// 806800D: using guessed type int __fastcall sub_806800D(_DWORD);
// 806E1EC: using guessed type int dword_806E1EC;
// 806E250: using guessed type int dword_806E250;
// 806E254: using guessed type int dword_806E254;

//----- (080636FE) --------------------------------------------------------
#error "8063711: positive sp value has been found (funcsize=0)"

//----- (08063712) --------------------------------------------------------
_DWORD *__userpurge sub_8063712@<eax>(_DWORD *a1, int a2)
{
  int v3; // [esp+0h] [ebp-38h]
  int v4; // [esp+4h] [ebp-34h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]

  memset(&v3, 0, 0x30u);
  if ( a2 == 10 )
    abort();
  *a1 = a2;
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = v6;
  a1[4] = v7;
  a1[5] = v8;
  a1[6] = v9;
  a1[7] = v10;
  a1[8] = v11;
  a1[9] = v12;
  a1[10] = v13;
  a1[11] = v14;
  return a1;
}

//----- (08063794) --------------------------------------------------------
char *__usercall sub_8063794@<eax>(signed __int32 a1@<ebx>, char *msgid, int a3)
{
  char *result; // eax
  signed __int32 v4; // edx
  int v5; // ecx
  signed __int32 v6; // edx
  int v7; // ecx
  signed __int32 v8; // ecx
  signed __int32 v9; // eax
  signed __int32 v10; // ebx
  signed __int32 v11; // edx
  void *v12; // eax
  char *v13; // [esp+18h] [ebp-10h]
  unsigned __int8 *v14; // [esp+1Ch] [ebp-Ch]

  v13 = gettext(msgid);
  if ( v13 != msgid )
    return v13;
  v14 = (unsigned __int8 *)sub_806741E(a1);
  if ( sub_8066A45(v4, v5, v14, (signed __int32)"UTF-8") )
  {
    if ( sub_8066A45(v6, v7, v14, (signed __int32)"GB18030") )
    {
      v12 = &loc_8063874;
      if ( a3 != 9 )
        v12 = &loc_806387B;
      dword_806E278 = (int)v12;
      sub_8067C35(v8);
      result = (char *)&unk_8069785;
    }
    else
    {
      if ( *msgid == 96 )
      {
        dword_806E278 = (int)&loc_8063853;
        v9 = _InterlockedExchange(&dword_806E27C, (signed __int32)&unk_806977E);
        _InterlockedExchange(&dword_806E27C, v8);
        sub_8067C35(_InterlockedExchange(&dword_806E27C, v9));
        v10 = _InterlockedExchange(&dword_806E27C, a1);
        _InterlockedExchange(&dword_806E27C, v11);
        _InterlockedExchange(&dword_806E27C, v10);
      }
      result = (char *)&unk_8069782;
    }
  }
  else if ( *msgid == 96 )
  {
    result = (char *)&unk_806976E;
  }
  else
  {
    result = (char *)&unk_8069772;
  }
  return result;
}
// 8067C35: using guessed type int __fastcall sub_8067C35(_DWORD);
// 806E278: using guessed type int dword_806E278;
// 806E27C: using guessed type int dword_806E27C;

//----- (08063882) --------------------------------------------------------
unsigned int __usercall sub_8063882@<eax>(signed __int32 a1@<ebx>, signed __int32 a2, unsigned int a3, signed __int32 a4, size_t a5, signed int a6, int a7, int a8, char *a9, char *a10)
{
  signed __int32 v10; // edx
  signed __int32 v11; // ecx
  int v12; // eax
  signed __int32 v13; // eax
  signed __int32 v14; // ebx
  signed __int32 v15; // edx
  signed __int32 v16; // edx
  signed __int32 v17; // et1
  void *v18; // eax
  void *v19; // eax
  void *v20; // eax
  size_t v21; // eax
  signed __int32 v22; // edx
  signed __int32 v23; // eax
  void *v24; // eax
  signed __int32 v25; // eax
  signed __int32 v26; // edx
  signed __int32 v27; // ecx
  signed __int32 v28; // ett
  signed __int32 v29; // eax
  signed __int32 v30; // ecx
  signed __int32 v31; // et1
  void *v32; // eax
  signed __int32 v33; // eax
  signed __int32 v34; // ecx
  signed __int32 v35; // ett
  signed __int32 v36; // eax
  signed __int32 v37; // ebx
  signed __int32 v38; // edx
  signed __int32 v39; // edx
  signed __int32 v40; // et1
  signed __int32 v41; // ebx
  signed __int32 v42; // et2
  signed __int32 v43; // ebx
  signed __int32 v44; // ecx
  signed __int32 v45; // ecx
  signed __int32 v46; // ett
  void *v47; // eax
  signed __int32 v48; // edx
  int v49; // ecx
  signed __int32 v50; // ebx
  signed __int32 v51; // et0
  signed __int32 v52; // ecx
  int v53; // edx
  signed __int32 v54; // et1
  signed __int32 v55; // ecx
  void *v56; // eax
  void *v57; // eax
  signed __int32 v58; // ebx
  signed __int32 v59; // ecx
  signed __int32 v60; // et0
  signed __int32 v61; // ecx
  signed __int32 v62; // et1
  bool v63; // al
  signed __int32 v64; // ebx
  signed __int32 v65; // et2
  signed __int32 v66; // ebx
  signed __int32 v67; // edx
  signed __int32 v68; // edx
  signed __int32 v69; // ett
  void *v70; // eax
  void *v71; // eax
  signed __int32 v72; // ebx
  signed __int32 v73; // ecx
  signed __int32 v74; // et0
  signed __int32 v75; // edx
  signed __int32 v76; // et1
  const unsigned __int16 **v77; // eax
  signed __int32 v78; // edx
  int v79; // eax
  signed __int32 v80; // eax
  int v81; // ecx
  signed __int32 v82; // ecx
  signed __int32 v83; // ett
  int v84; // edx
  void *v85; // eax
  void *v86; // eax
  void *v87; // eax
  void *v88; // eax
  int v89; // ecx
  void *v90; // eax
  void *v91; // eax
  int v92; // ecx
  void *v93; // eax
  void *v94; // eax
  void *v95; // eax
  void *v96; // eax
  bool v97; // al
  unsigned int result; // eax
  void *v99; // eax
  size_t v100; // [esp-8h] [ebp-90h]
  signed __int32 v101; // [esp-8h] [ebp-90h]
  char *v102; // [esp+2Ch] [ebp-5Ch]
  char *v103; // [esp+30h] [ebp-58h]
  char v104; // [esp+40h] [ebp-48h]
  bool v105; // [esp+41h] [ebp-47h]
  char v106; // [esp+42h] [ebp-46h]
  char v107; // [esp+43h] [ebp-45h]
  char v108; // [esp+44h] [ebp-44h]
  unsigned __int8 v109; // [esp+45h] [ebp-43h]
  char v110; // [esp+46h] [ebp-42h]
  char v111; // [esp+47h] [ebp-41h]
  char v112; // [esp+48h] [ebp-40h]
  char v113; // [esp+49h] [ebp-3Fh]
  char v114; // [esp+4Ah] [ebp-3Eh]
  bool v115; // [esp+4Bh] [ebp-3Dh]
  wint_t wc; // [esp+4Ch] [ebp-3Ch]
  int v117; // [esp+50h] [ebp-38h]
  unsigned int v118; // [esp+54h] [ebp-34h]
  unsigned int v119; // [esp+58h] [ebp-30h]
  char *s; // [esp+5Ch] [ebp-2Ch]
  size_t n; // [esp+60h] [ebp-28h]
  unsigned int v122; // [esp+64h] [ebp-24h]
  unsigned int v123; // [esp+6Ch] [ebp-1Ch]
  unsigned int v124; // [esp+70h] [ebp-18h]
  mbstate_t ps; // [esp+74h] [ebp-14h]
  unsigned int v126; // [esp+7Ch] [ebp-Ch]

  v103 = a9;
  v102 = a10;
  v126 = __readgsdword(0x14u);
  v118 = 0;
  v119 = 0;
  s = 0;
  n = 0;
  v104 = 0;
  v115 = __ctype_get_mb_cur_max() == 1;
  v105 = (a7 & 2) != 0;
  v106 = 0;
  v107 = 0;
  v108 = 1;
  while ( 1 )
  {
    switch ( a6 )
    {
      case 0:
        v105 = 0;
        break;
      case 1:
        goto LABEL_18;
      case 2:
        goto LABEL_21;
      case 3:
        v104 = 1;
LABEL_18:
        v105 = 1;
        goto LABEL_19;
      case 4:
LABEL_19:
        if ( v105 != 1 )
          v104 = 1;
LABEL_21:
        a6 = 2;
        if ( v105 != 1 )
        {
          if ( v118 < a3 )
          {
            v10 = a2;
            *(_BYTE *)(a2 + v118) = 39;
          }
          ++v118;
        }
        s = "'";
        n = 1;
        break;
      case 5:
        goto LABEL_4;
      case 6:
        a6 = 5;
        v105 = 1;
LABEL_4:
        v12 = !v105;
        if ( v105 != 1 )
        {
          v12 = v118;
          if ( v118 < a3 )
          {
            v10 = a2;
            v12 = a2 + v118;
            *(_BYTE *)(a2 + v118) = 34;
          }
          ++v118;
        }
        s = (char *)&unk_8069785;
        n = 1;
        dword_806E160 = (int)&loc_8063A93;
        v13 = _InterlockedExchange(&dword_806E164, v12);
        _InterlockedExchange(&dword_806E164, v10);
        sub_80683C2(v11, _InterlockedExchange(&dword_806E164, v13));
        v14 = _InterlockedExchange(&dword_806E164, a1);
        v17 = _InterlockedExchange(&dword_806E164, v15);
        v16 = v14;
        a1 = v17;
        v10 = _InterlockedExchange(&dword_806E164, v16);
        goto LABEL_9;
      case 7:
LABEL_9:
        v104 = 1;
        v105 = 0;
        break;
      case 8:
      case 9:
      case 10:
        if ( a6 != 10 )
        {
          v103 = sub_8063794(a1, "`", a6);
          v102 = sub_8063794(a1, "'", a6);
        }
        if ( v105 != 1 )
        {
          s = v103;
          v18 = &loc_8063A1E;
          if ( *v103 )
            v18 = &loc_80639DB;
          dword_806E200 = (int)v18;
          sub_8067F6F(v11, v10);
        }
        v104 = 1;
        s = v102;
        n = strlen(v102);
        break;
      default:
        abort();
        return result;
    }
    v117 = 0;
LABEL_214:
    if ( a5 == -1 )
    {
      v10 = a4;
      v97 = *(_BYTE *)(a4 + v117) != 0;
    }
    else
    {
      v97 = v117 != a5;
    }
    if ( v97 )
      break;
    if ( !v118 && a6 == 2 && v105 )
      goto LABEL_240;
    if ( a6 != 2 || v105 == 1 || !v107 )
      goto LABEL_246;
    if ( v108 )
      return sub_8063882(a1, a2, v119, a4, a5, 5, a7, a8, v103, v102);
    if ( a3 || !v119 )
    {
LABEL_246:
      if ( s )
      {
        v99 = &loc_806488F;
        if ( v105 == 1 )
          v99 = &loc_80648BB;
        dword_806E1D8 = (int)v99;
        sub_806808A(v11);
        while ( *s )
        {
          if ( v118 < a3 )
            *(_BYTE *)(v118 + a2) = *s;
          ++v118;
          ++s;
        }
      }
      if ( v118 < a3 )
        *(_BYTE *)(a2 + v118) = 0;
      return v118;
    }
    a3 = v119;
    v118 = 0;
  }
  v111 = 0;
  v112 = 0;
  v113 = 0;
  if ( v104 )
  {
    v19 = &loc_8063AD4;
    if ( a6 == 2 )
      v19 = &loc_8063B53;
    dword_806E174 = (int)v19;
    sub_806833F(v11);
    if ( n )
    {
      v100 = v117 + n;
      v20 = &loc_8063B02;
      if ( a5 != -1 )
        v20 = &loc_8063B1B;
      dword_806E160 = (int)v20;
      a1 = v117 + n;
      sub_80683C2(v11, v117);
      if ( n <= 1 )
      {
        v21 = a5;
      }
      else
      {
        v21 = strlen((const char *)a4);
        a5 = v21;
      }
      if ( v100 <= v21 && !memcmp((const void *)(v117 + a4), s, n) )
      {
        if ( v105 )
          goto LABEL_240;
        v111 = 1;
      }
    }
  }
  v22 = a4;
  v109 = *(_BYTE *)(a4 + v117);
  v23 = v109;
  switch ( v109 )
  {
    case 0u:
      if ( !v104 )
      {
        v24 = &loc_8063C8D;
        if ( !(a7 & 1) )
          v24 = &loc_8063C92;
        dword_806E1C4 = (int)v24;
        sub_806812D(v11);
        goto LABEL_213;
      }
      if ( v105 )
        goto LABEL_240;
      v112 = 1;
      if ( a6 == 2 && v106 != 1 )
      {
        if ( v118 < a3 )
          *(_BYTE *)(a2 + v118) = 39;
        if ( ++v118 < a3 )
          *(_BYTE *)(a2 + v118) = 36;
        if ( ++v118 < a3 )
          *(_BYTE *)(a2 + v118) = 39;
        ++v118;
        v106 = 1;
      }
      if ( v118 < a3 )
        *(_BYTE *)(a2 + v118) = 92;
      ++v118;
      if ( a6 != 2 && v117 + 1 < a5 && *(_BYTE *)(v117 + 1 + a4) > 47 && *(_BYTE *)(v117 + 1 + a4) <= 57 )
      {
        if ( v118 < a3 )
          *(_BYTE *)(a2 + v118) = 48;
        if ( ++v118 < a3 )
          *(_BYTE *)(a2 + v118) = 48;
        ++v118;
      }
      v109 = 48;
      goto LABEL_175;
    case 7u:
      v110 = 97;
      goto LABEL_108;
    case 8u:
      dword_806E200 = (int)&loc_8063FCF;
      v33 = _InterlockedExchange(&dword_806E204, v109);
      _InterlockedExchange(&dword_806E204, a4);
      v35 = _InterlockedExchange(&dword_806E204, sub_8067F6F(v11, _InterlockedExchange(&dword_806E204, v33)));
      v23 = _InterlockedExchange(&dword_806E204, v34);
      v11 = _InterlockedExchange(&dword_806E204, v35);
      goto LABEL_93;
    case 9u:
      v110 = 116;
      goto LABEL_104;
    case 0xAu:
      goto LABEL_94;
    case 0xBu:
      dword_806E250 = (int)&loc_8063FCF;
      v41 = _InterlockedExchange(&dword_806E254, a1);
      v42 = _InterlockedExchange(&dword_806E254, v11);
      sub_8067D53(_InterlockedExchange(&dword_806E254, v41));
      v43 = _InterlockedExchange(&dword_806E254, v42);
      v46 = _InterlockedExchange(&dword_806E254, v44);
      v45 = v43;
      a1 = v46;
      v11 = _InterlockedExchange(&dword_806E254, v45);
      goto LABEL_98;
    case 0xCu:
LABEL_93:
      dword_806E19C = (int)&loc_8063FCF;
      v36 = _InterlockedExchange(&dword_806E1A0, v23);
      _InterlockedExchange(&dword_806E1A0, v11);
      sub_8068230(_InterlockedExchange(&dword_806E1A0, v36));
      v37 = _InterlockedExchange(&dword_806E1A0, a1);
      v40 = _InterlockedExchange(&dword_806E1A0, v38);
      v39 = v37;
      a1 = v40;
      v22 = _InterlockedExchange(&dword_806E1A0, v39);
LABEL_94:
      v110 = 110;
      goto LABEL_104;
    case 0xDu:
      v110 = 114;
      goto LABEL_104;
    case 0x20u:
      goto LABEL_117;
    case 0x21u:
    case 0x22u:
    case 0x24u:
    case 0x26u:
    case 0x28u:
    case 0x29u:
    case 0x2Au:
    case 0x3Bu:
    case 0x3Cu:
    case 0x3Du:
    case 0x3Eu:
    case 0x5Bu:
    case 0x5Eu:
    case 0x60u:
    case 0x7Cu:
      goto LABEL_118;
    case 0x23u:
    case 0x7Eu:
      goto LABEL_116;
    case 0x25u:
    case 0x2Bu:
    case 0x2Cu:
    case 0x2Du:
    case 0x2Eu:
    case 0x2Fu:
    case 0x30u:
    case 0x31u:
    case 0x32u:
    case 0x33u:
    case 0x34u:
    case 0x35u:
    case 0x36u:
    case 0x37u:
    case 0x38u:
    case 0x39u:
    case 0x3Au:
    case 0x41u:
    case 0x42u:
    case 0x43u:
    case 0x44u:
    case 0x45u:
    case 0x46u:
    case 0x47u:
    case 0x48u:
    case 0x49u:
    case 0x4Au:
    case 0x4Bu:
    case 0x4Cu:
    case 0x4Du:
    case 0x4Eu:
    case 0x4Fu:
    case 0x50u:
    case 0x51u:
    case 0x52u:
    case 0x53u:
    case 0x54u:
    case 0x55u:
    case 0x56u:
    case 0x57u:
    case 0x58u:
    case 0x59u:
    case 0x5Au:
    case 0x5Du:
    case 0x5Fu:
    case 0x61u:
    case 0x62u:
    case 0x63u:
    case 0x64u:
    case 0x65u:
    case 0x66u:
    case 0x67u:
    case 0x68u:
    case 0x69u:
    case 0x6Au:
    case 0x6Bu:
    case 0x6Cu:
    case 0x6Du:
    case 0x6Eu:
    case 0x6Fu:
    case 0x70u:
    case 0x71u:
    case 0x72u:
    case 0x73u:
    case 0x74u:
    case 0x75u:
    case 0x76u:
    case 0x77u:
    case 0x78u:
    case 0x79u:
    case 0x7Au:
      dword_806E200 = (int)&loc_80645D6;
      v72 = _InterlockedExchange(&dword_806E204, a1);
      v74 = _InterlockedExchange(&dword_806E204, v11);
      v73 = v72;
      a1 = v74;
      v76 = _InterlockedExchange(&dword_806E204, sub_8067F6F(_InterlockedExchange(&dword_806E204, v73), a4));
      _InterlockedExchange(&dword_806E204, v75);
      _InterlockedExchange(&dword_806E204, v76);
      goto LABEL_136;
    case 0x27u:
      v107 = 1;
      v113 = 1;
      v70 = &loc_80640BB;
      if ( a6 != 2 )
        v70 = &loc_8064146;
      dword_806E278 = (int)v70;
      sub_8067C35(v11);
      if ( v105 )
        goto LABEL_240;
      if ( a3 )
      {
        v71 = &loc_80640EB;
        if ( v119 )
          v71 = &loc_80640F8;
        dword_806E138 = (int)v71;
        sub_80684CC(v11);
        v119 = a3;
        a3 = 0;
      }
      if ( v118 < a3 )
        *(_BYTE *)(a2 + v118) = 39;
      if ( ++v118 < a3 )
        *(_BYTE *)(a2 + v118) = 92;
      if ( ++v118 < a3 )
        *(_BYTE *)(a2 + v118) = 39;
      ++v118;
      v106 = 0;
      goto LABEL_175;
    case 0x3Fu:
      v25 = a6;
      if ( a6 == 2 )
      {
        if ( v105 )
        {
          dword_806E160 = (int)&loc_80648D3;
          v26 = _InterlockedExchange(&dword_806E164, a1);
          a1 = _InterlockedExchange(&dword_806E164, a4);
          v28 = _InterlockedExchange(&dword_806E164, sub_80683C2(v11, _InterlockedExchange(&dword_806E164, v26)));
          v25 = _InterlockedExchange(&dword_806E164, v27);
          v11 = _InterlockedExchange(&dword_806E164, v28);
        }
        dword_806E124 = (int)&loc_8063E06;
        v29 = _InterlockedExchange(&dword_806E128, v25);
        _InterlockedExchange(&dword_806E128, v22);
        _InterlockedExchange(&dword_806E128, v29);
        v31 = _InterlockedExchange(&dword_806E128, sub_8068556(v11));
        _InterlockedExchange(&dword_806E128, v30);
        v11 = _InterlockedExchange(&dword_806E128, v31);
      }
      else if ( a6 != 5 )
      {
        goto LABEL_175;
      }
      v32 = &loc_8063D3D;
      if ( !(a7 & 4) )
        v32 = &loc_8063E06;
      dword_806E174 = (int)v32;
      sub_806833F(v11);
      if ( v117 + 2 < a5 && *(_BYTE *)(v117 + 1 + a4) == 63 )
      {
        switch ( *(char *)(v117 + 2 + a4) )
        {
          case 33:
          case 39:
          case 40:
          case 41:
          case 45:
          case 47:
          case 60:
          case 61:
          case 62:
            if ( v105 )
              goto LABEL_240;
            v109 = *(_BYTE *)(v117 + 2 + a4);
            v117 += 2;
            if ( v118 < a3 )
              *(_BYTE *)(a2 + v118) = 63;
            if ( ++v118 < a3 )
              *(_BYTE *)(a2 + v118) = 34;
            if ( ++v118 < a3 )
              *(_BYTE *)(a2 + v118) = 34;
            if ( ++v118 < a3 )
              *(_BYTE *)(a2 + v118) = 63;
            ++v118;
            break;
          default:
            goto LABEL_175;
        }
      }
      goto LABEL_175;
    case 0x5Cu:
LABEL_98:
      v110 = v109;
      v47 = &loc_8063F03;
      if ( a6 != 2 )
        v47 = &loc_8063F44;
      dword_806E14C = (int)v47;
      sub_806844C(v11, v22);
      if ( v105 )
        goto LABEL_240;
      dword_806E160 = (int)&loc_8064718;
      v50 = _InterlockedExchange(&dword_806E164, a1);
      v51 = _InterlockedExchange(&dword_806E164, v48);
      v54 = _InterlockedExchange(&dword_806E164, sub_80683C2(v49, _InterlockedExchange(&dword_806E164, v50)));
      _InterlockedExchange(&dword_806E164, v52);
      v55 = _InterlockedExchange(&dword_806E164, v54);
      v101 = v51;
      v56 = &loc_8063F63;
      if ( !v104 )
        v56 = &loc_8063FA5;
      dword_806E264 = (int)v56;
      a1 = v101;
      sub_8067CB2(v55, v53);
LABEL_104:
      if ( a6 == 2 )
      {
        v57 = &loc_8063FCA;
        if ( !v105 )
          v57 = &loc_8063FCF;
        dword_806E110 = (int)v57;
        sub_80685D2(v11);
        goto LABEL_240;
      }
LABEL_108:
      if ( v104 )
      {
        v109 = v110;
        if ( v105 )
          goto LABEL_240;
        v112 = 1;
        v95 = &loc_80646AD;
        if ( a6 != 2 )
          v95 = &loc_8064701;
        dword_806E160 = (int)v95;
        sub_80683C2(v11, v22);
        if ( v106 != 1 )
        {
          if ( v118 < a3 )
            *(_BYTE *)(a2 + v118) = 39;
          if ( ++v118 < a3 )
            *(_BYTE *)(a2 + v118) = 36;
          if ( ++v118 < a3 )
            *(_BYTE *)(a2 + v118) = 39;
          ++v118;
          v106 = 1;
        }
        if ( v118 < a3 )
          *(_BYTE *)(a2 + v118) = 92;
        ++v118;
      }
      else
      {
        dword_806E174 = (int)&loc_80645D6;
        v58 = _InterlockedExchange(&dword_806E178, a1);
        v60 = _InterlockedExchange(&dword_806E178, v11);
        v59 = v58;
        a1 = v60;
        v62 = _InterlockedExchange(&dword_806E178, sub_806833F(_InterlockedExchange(&dword_806E178, v59)));
        _InterlockedExchange(&dword_806E178, v61);
        v11 = _InterlockedExchange(&dword_806E178, v62);
LABEL_111:
        if ( a5 == -1 )
          v63 = *(_BYTE *)(a4 + 1) != 0;
        else
          v63 = a5 != 1;
        if ( v63 )
        {
          dword_806E124 = (int)&loc_80645D6;
          v64 = _InterlockedExchange(&dword_806E128, a1);
          v65 = _InterlockedExchange(&dword_806E128, v11);
          sub_8068556(_InterlockedExchange(&dword_806E128, v64));
          v66 = _InterlockedExchange(&dword_806E128, v65);
          v69 = _InterlockedExchange(&dword_806E128, v67);
          v68 = v66;
          a1 = v69;
          _InterlockedExchange(&dword_806E128, v68);
        }
LABEL_116:
        if ( !v117 )
        {
LABEL_117:
          v113 = 1;
LABEL_118:
          if ( a6 == 2 && v105 )
            goto LABEL_240;
        }
LABEL_175:
        if ( v104 == 1 )
        {
          v91 = &loc_8064600;
          if ( a6 != 2 )
            v91 = &loc_806460B;
          dword_806E124 = (int)v91;
          sub_8068556(v11);
        }
        if ( v105 == 1 && a8 )
        {
          v92 = v109 & 0x1F;
          v93 = &loc_8064656;
          if ( (*(_DWORD *)(4 * (v109 >> 5) + a8) >> v92) & 1 )
            v93 = &loc_806467F;
          dword_806E110 = (int)v93;
          sub_80685D2(v92);
        }
        v94 = &loc_806467A;
        if ( v111 == 1 )
          v94 = &loc_806467F;
        dword_806E214 = (int)v94;
        sub_8067ECF(v11);
      }
      goto LABEL_201;
    case 0x7Bu:
    case 0x7Du:
      goto LABEL_111;
    default:
LABEL_136:
      if ( v115 )
      {
        v122 = 1;
        v77 = __ctype_b_loc();
        v78 = v109;
        v79 = (*v77)[v78] & 0x4000;
        LOBYTE(v79) = v79 != 0;
        dword_806E160 = (int)&loc_80643B9;
        v80 = _InterlockedExchange(&dword_806E164, v79);
        _InterlockedExchange(&dword_806E164, v78 * 2);
        v83 = _InterlockedExchange(&dword_806E164, sub_80683C2(v81, _InterlockedExchange(&dword_806E164, v80)));
        _InterlockedExchange(&dword_806E164, v82);
        _InterlockedExchange(&dword_806E164, v83);
      }
      memset(&ps, 0, 8u);
      v122 = 0;
      v114 = 1;
      if ( a5 == -1 )
        a5 = strlen((const char *)a4);
      v123 = sub_8066894(a1, (wchar_t *)&wc, (char *)(a4 + v122 + v117), a5 - (v122 + v117), &ps);
      if ( v123 )
      {
        if ( v123 == -1 )
        {
          v114 = 0;
        }
        else
        {
          v85 = &loc_8064295;
          if ( v123 != -2 )
            v85 = &loc_80642DE;
          dword_806E1C4 = (int)v85;
          sub_806812D(v11);
          v114 = 0;
          v84 = v117;
          if ( v117 + v122 < a5 )
          {
            v86 = &loc_80642D9;
            if ( *(_BYTE *)(v122 + v117 + a4) )
              v86 = &loc_806429B;
            dword_806E278 = (int)v86;
            sub_8067C35(v11);
          }
        }
      }
      v113 = v114;
      if ( v122 > 1 )
        goto LABEL_154;
      if ( !v104 )
        goto LABEL_175;
      v87 = &loc_80643F4;
      if ( v114 == 1 )
        v87 = &loc_80645D6;
      dword_806E23C = (int)v87;
      sub_8067DD8(v11, v84);
LABEL_154:
      v124 = v117 + v122;
      while ( 2 )
      {
        if ( !v104 )
        {
          if ( v111 )
          {
            if ( v118 < a3 )
              *(_BYTE *)(a2 + v118) = 92;
            ++v118;
            v111 = 0;
          }
          if ( v117 + 1 < v124 )
          {
            if ( v106 )
            {
              if ( v118 < a3 )
                *(_BYTE *)(a2 + v118) = 39;
              if ( ++v118 < a3 )
                *(_BYTE *)(a2 + v118) = 39;
              ++v118;
              v106 = 0;
            }
            if ( v118 < a3 )
              *(_BYTE *)(v118 + a2) = v109;
            ++v118;
            v109 = *(_BYTE *)(a4 + ++v117);
            continue;
          }
LABEL_201:
          if ( v106 && v112 != 1 )
          {
            if ( v118 < a3 )
              *(_BYTE *)(a2 + v118) = 39;
            if ( ++v118 < a3 )
              *(_BYTE *)(a2 + v118) = 39;
            ++v118;
            v106 = 0;
          }
          if ( v118 < a3 )
            *(_BYTE *)(v118 + a2) = v109;
          ++v118;
          v96 = &loc_8064799;
          if ( v113 == 1 )
            v96 = &loc_806479D;
          dword_806E174 = (int)v96;
          sub_806833F(v11);
          v108 = 0;
LABEL_213:
          ++v117;
          goto LABEL_214;
        }
        break;
      }
      v88 = &loc_806442D;
      if ( v114 == 1 )
        v88 = &loc_8064531;
      dword_806E19C = (int)v88;
      sub_8068230(v11);
      v90 = &loc_806444C;
      if ( !v105 )
        v90 = &loc_8064451;
      dword_806E214 = (int)v90;
      sub_8067ECF(v89);
LABEL_240:
      if ( a6 == 2 && v104 )
        a6 = 4;
      return sub_8063882(a1, a2, a3, a4, a5, a6, a7 & 0xFFFFFFFD, 0, v103, v102);
  }
}
// 8067C35: using guessed type int __fastcall sub_8067C35(_DWORD);
// 8067CB2: using guessed type int __fastcall sub_8067CB2(_DWORD, _DWORD);
// 8067D53: using guessed type int __fastcall sub_8067D53(_DWORD);
// 8067DD8: using guessed type int __fastcall sub_8067DD8(_DWORD, _DWORD);
// 8067E53: using guessed type int __fastcall sub_8067E53(_DWORD);
// 8067ECF: using guessed type int __fastcall sub_8067ECF(_DWORD);
// 8067F6F: using guessed type int __fastcall sub_8067F6F(_DWORD, _DWORD);
// 806808A: using guessed type int __fastcall sub_806808A(_DWORD);
// 806812D: using guessed type int __fastcall sub_806812D(_DWORD);
// 8068230: using guessed type int __fastcall sub_8068230(_DWORD);
// 806833F: using guessed type int __fastcall sub_806833F(_DWORD);
// 80683C2: using guessed type int __fastcall sub_80683C2(_DWORD, _DWORD);
// 806844C: using guessed type int __fastcall sub_806844C(_DWORD, _DWORD);
// 80684CC: using guessed type int __fastcall sub_80684CC(_DWORD);
// 8068556: using guessed type int __fastcall sub_8068556(_DWORD);
// 80685D2: using guessed type int __fastcall sub_80685D2(_DWORD);
// 806E110: using guessed type int dword_806E110;
// 806E124: using guessed type int dword_806E124;
// 806E128: using guessed type int dword_806E128;
// 806E138: using guessed type int dword_806E138;
// 806E14C: using guessed type int dword_806E14C;
// 806E160: using guessed type int dword_806E160;
// 806E164: using guessed type int dword_806E164;
// 806E174: using guessed type int dword_806E174;
// 806E178: using guessed type int dword_806E178;
// 806E19C: using guessed type int dword_806E19C;
// 806E1A0: using guessed type int dword_806E1A0;
// 806E1C4: using guessed type int dword_806E1C4;
// 806E1D8: using guessed type int dword_806E1D8;
// 806E200: using guessed type int dword_806E200;
// 806E204: using guessed type int dword_806E204;
// 806E214: using guessed type int dword_806E214;
// 806E228: using guessed type int dword_806E228;
// 806E22C: using guessed type int dword_806E22C;
// 806E23C: using guessed type int dword_806E23C;
// 806E250: using guessed type int dword_806E250;
// 806E254: using guessed type int dword_806E254;
// 806E264: using guessed type int dword_806E264;
// 806E278: using guessed type int dword_806E278;

//----- (080649FD) --------------------------------------------------------
void *__cdecl sub_80649FD(signed __int32 a1, size_t a2, _DWORD *a3, int a4)
{
  int v4; // ecx
  void *v5; // eax
  int v6; // ST44_4
  int v7; // ST48_4
  int v8; // ST4C_4
  unsigned int size; // [esp+48h] [ebp-10h]
  void *v11; // [esp+4Ch] [ebp-Ch]

  v5 = &loc_8064A23;
  if ( !a4 )
    v5 = &loc_8064A28;
  dword_806E1C4 = (int)v5;
  sub_806812D(v4);
  v6 = a4;
  v7 = *__errno_location();
  v8 = *(_DWORD *)(a4 + 4) | (a3 == 0);
  size = sub_8063882(
           v6 + 8,
           0,
           0,
           a1,
           a2,
           *(_DWORD *)v6,
           *(_DWORD *)(v6 + 4) | (a3 == 0),
           v6 + 8,
           *(char **)(v6 + 40),
           *(char **)(v6 + 44))
       + 1;
  v11 = sub_80660CD(a4 + 8, size);
  sub_8063882(
    v6 + 8,
    (signed __int32)v11,
    size,
    a1,
    a2,
    *(_DWORD *)v6,
    v8,
    v6 + 8,
    *(char **)(v6 + 40),
    *(char **)(v6 + 44));
  *__errno_location() = v7;
  if ( a3 )
    *a3 = size - 1;
  return v11;
}
// 806812D: using guessed type int __fastcall sub_806812D(_DWORD);
// 806E1C4: using guessed type int dword_806E1C4;

//----- (08064C8E) --------------------------------------------------------
void *__cdecl sub_8064C8E(signed int a1, signed __int32 a2, size_t a3, int a4)
{
  int v4; // ecx
  int *v5; // eax
  void *v6; // edx
  size_t v7; // ST44_4
  signed __int32 v8; // ebx
  bool v10; // [esp+37h] [ebp-21h]
  int *v11; // [esp+38h] [ebp-20h]
  void *ptr; // [esp+3Ch] [ebp-1Ch]
  int v13; // [esp+40h] [ebp-18h]
  int size; // [esp+44h] [ebp-14h]
  int v15; // [esp+48h] [ebp-10h]
  unsigned int v16; // [esp+4Ch] [ebp-Ch]

  v13 = *__errno_location();
  v11 = off_806E2C4;
  if ( a1 < 0 )
    abort();
  if ( dword_806E2B8 <= a1 )
  {
    v10 = off_806E2C4 == &dword_806E2BC;
    if ( (unsigned int)a1 > 0xFFFFFFE )
      sub_80663AB();
    if ( v10 )
      v5 = 0;
    else
      v5 = off_806E2C4;
    v11 = (int *)sub_806618F(8 * (a1 + 1), v4, v5, 8 * (a1 + 1));
    off_806E2C4 = v11;
    if ( v10 )
    {
      v6 = off_806E2C0;
      *v11 = dword_806E2BC;
      v11[1] = (int)v6;
    }
    memset(&v11[2 * dword_806E2B8], 0, 8 * (a1 + 1 - dword_806E2B8));
    dword_806E2B8 = a1 + 1;
  }
  v7 = v11[2 * a1];
  ptr = (void *)v11[2 * a1 + 1];
  v15 = *(_DWORD *)(a4 + 4) | 1;
  v16 = sub_8063882(
          a4 + 8,
          v11[2 * a1 + 1],
          v11[2 * a1],
          a2,
          a3,
          *(_DWORD *)a4,
          v15,
          a4 + 8,
          *(char **)(a4 + 40),
          *(char **)(a4 + 44));
  if ( v7 <= v16 )
  {
    size = v16 + 1;
    v11[2 * a1] = v16 + 1;
    if ( ptr != &unk_806E9DD )
      free(ptr);
    v8 = (signed __int32)&v11[2 * a1];
    ptr = sub_80660CD(v8, size);
    *(_DWORD *)(v8 + 4) = ptr;
    sub_8063882(
      a4 + 8,
      (signed __int32)ptr,
      size,
      a2,
      a3,
      *(_DWORD *)a4,
      v15,
      a4 + 8,
      *(char **)(a4 + 40),
      *(char **)(a4 + 44));
  }
  *__errno_location() = v13;
  return ptr;
}
// 806E2B8: using guessed type int dword_806E2B8;
// 806E2BC: using guessed type int dword_806E2BC;
// 806E2C0: using guessed type void *off_806E2C0;
// 806E2C4: using guessed type int *off_806E2C4;

//----- (08064EB7) --------------------------------------------------------
void *__cdecl sub_8064EB7(signed int a1, signed __int32 a2)
{
  return sub_8064C8E(a1, a2, 0xFFFFFFFF, (int)&dword_806E99D);
}
// 806E99D: using guessed type int dword_806E99D;

//----- (08064EE1) --------------------------------------------------------
void *__cdecl sub_8064EE1(signed int a1, signed __int32 a2, size_t a3)
{
  return sub_8064C8E(a1, a2, a3, (int)&dword_806E99D);
}
// 806E99D: using guessed type int dword_806E99D;

//----- (08064FF7) --------------------------------------------------------
void *__cdecl sub_8064FF7(signed int a1, int a2, signed __int32 a3)
{
  char v4; // [esp+10h] [ebp-38h]

  sub_8063712(&v4, a2);
  return sub_8064C8E(a1, a3, 0xFFFFFFFF, (int)&v4);
}

//----- (08065035) --------------------------------------------------------
void *__cdecl sub_8065035(signed int a1, int a2, signed __int32 a3, size_t a4)
{
  char v5; // [esp+10h] [ebp-38h]

  sub_8063712(&v5, a2);
  return sub_8064C8E(a1, a3, a4, (int)&v5);
}

//----- (08065196) --------------------------------------------------------
void *__cdecl sub_8065196(signed __int32 a1, size_t a2, unsigned __int8 a3)
{
  int v4; // [esp+20h] [ebp-38h]
  int v5; // [esp+24h] [ebp-34h]
  int v6; // [esp+28h] [ebp-30h]
  int v7; // [esp+2Ch] [ebp-2Ch]
  int v8; // [esp+30h] [ebp-28h]
  int v9; // [esp+34h] [ebp-24h]
  int v10; // [esp+38h] [ebp-20h]
  int v11; // [esp+3Ch] [ebp-1Ch]
  int v12; // [esp+40h] [ebp-18h]
  int v13; // [esp+44h] [ebp-14h]
  int v14; // [esp+48h] [ebp-10h]
  int v15; // [esp+4Ch] [ebp-Ch]

  v4 = dword_806E99D;
  v5 = dword_806E9A1;
  v6 = dword_806E9A5;
  v7 = dword_806E9A9;
  v8 = dword_806E9AD;
  v9 = dword_806E9B1;
  v10 = dword_806E9B5;
  v11 = dword_806E9B9;
  v12 = dword_806E9BD;
  v13 = dword_806E9C1;
  v14 = dword_806E9C5;
  v15 = dword_806E9C9;
  sub_8063595(&v4, a3, 1);
  return sub_8064C8E(0, a1, a2, (int)&v4);
}
// 806E99D: using guessed type int dword_806E99D;
// 806E9A1: using guessed type int dword_806E9A1;
// 806E9A5: using guessed type int dword_806E9A5;
// 806E9A9: using guessed type int dword_806E9A9;
// 806E9AD: using guessed type int dword_806E9AD;
// 806E9B1: using guessed type int dword_806E9B1;
// 806E9B5: using guessed type int dword_806E9B5;
// 806E9B9: using guessed type int dword_806E9B9;
// 806E9BD: using guessed type int dword_806E9BD;
// 806E9C1: using guessed type int dword_806E9C1;
// 806E9C5: using guessed type int dword_806E9C5;
// 806E9C9: using guessed type int dword_806E9C9;

//----- (08065240) --------------------------------------------------------
void *__cdecl sub_8065240(signed __int32 a1, unsigned __int8 a2)
{
  return sub_8065196(a1, 0xFFFFFFFF, a2);
}

//----- (08065269) --------------------------------------------------------
void *__cdecl sub_8065269(signed __int32 a1)
{
  return sub_8065240(a1, 0x3Au);
}

//----- (08065388) --------------------------------------------------------
int __usercall sub_8065388@<eax>(signed __int32 a1@<ebx>, signed int a2, int a3, signed __int32 a4)
{
  signed __int32 v4; // ebx
  signed __int32 v5; // edx
  signed __int32 v6; // et0
  int v7; // ecx
  int result; // eax
  signed __int32 v9; // ebx
  signed __int32 v10; // ecx
  int v11; // [esp+10h] [ebp-68h]
  int v12; // [esp+14h] [ebp-64h]
  int v13; // [esp+18h] [ebp-60h]
  int v14; // [esp+1Ch] [ebp-5Ch]
  int v15; // [esp+20h] [ebp-58h]
  int v16; // [esp+24h] [ebp-54h]
  int v17; // [esp+28h] [ebp-50h]
  int v18; // [esp+2Ch] [ebp-4Ch]
  int v19; // [esp+30h] [ebp-48h]
  int v20; // [esp+34h] [ebp-44h]
  int v21; // [esp+38h] [ebp-40h]
  int v22; // [esp+3Ch] [ebp-3Ch]
  int v23; // [esp+40h] [ebp-38h]
  int v24; // [esp+44h] [ebp-34h]
  int v25; // [esp+48h] [ebp-30h]
  int v26; // [esp+4Ch] [ebp-2Ch]
  int v27; // [esp+50h] [ebp-28h]
  int v28; // [esp+54h] [ebp-24h]
  int v29; // [esp+58h] [ebp-20h]
  int v30; // [esp+5Ch] [ebp-1Ch]
  int v31; // [esp+60h] [ebp-18h]
  int v32; // [esp+64h] [ebp-14h]
  int v33; // [esp+68h] [ebp-10h]
  int v34; // [esp+6Ch] [ebp-Ch]

  sub_8063712(&v11, a3);
  v23 = v11;
  v24 = v12;
  v25 = v13;
  v26 = v14;
  v27 = v15;
  v28 = v16;
  v29 = v17;
  v30 = v18;
  v31 = v19;
  v32 = v20;
  v33 = v21;
  v34 = v22;
  sub_8063595(&v23, 0x3Au, 1);
  sub_8064C8E(a2, a4, 0xFFFFFFFF, (int)&v23);
  dword_806E1D8 = (int)&locret_806540B;
  v4 = _InterlockedExchange(&dword_806E1DC, a1);
  v6 = _InterlockedExchange(&dword_806E1DC, v5);
  _InterlockedExchange(&dword_806E1DC, v4);
  result = sub_806808A(v7);
  v9 = _InterlockedExchange(&dword_806E1DC, v6);
  _InterlockedExchange(&dword_806E1DC, v10);
  _InterlockedExchange(&dword_806E1DC, v9);
  return result;
}
// 806808A: using guessed type int __fastcall sub_806808A(_DWORD);
// 806E1D8: using guessed type int dword_806E1D8;
// 806E1DC: using guessed type int dword_806E1DC;

//----- (080654F9) --------------------------------------------------------
void __usercall __noreturn sub_80654F9(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, int a3, int a4, int a5)
{
  sub_8065529(a1, a2, a3, a4, a5);
}

//----- (08065529) --------------------------------------------------------
void __usercall __noreturn sub_8065529(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, int a3, int a4, int a5)
{
  int v5; // [esp+10h] [ebp-38h]
  int v6; // [esp+14h] [ebp-34h]
  int v7; // [esp+18h] [ebp-30h]
  int v8; // [esp+1Ch] [ebp-2Ch]
  int v9; // [esp+20h] [ebp-28h]
  int v10; // [esp+24h] [ebp-24h]
  int v11; // [esp+28h] [ebp-20h]
  int v12; // [esp+2Ch] [ebp-1Ch]
  int v13; // [esp+30h] [ebp-18h]
  int v14; // [esp+34h] [ebp-14h]
  int v15; // [esp+38h] [ebp-10h]
  int v16; // [esp+3Ch] [ebp-Ch]

  v5 = dword_806E99D;
  v6 = dword_806E9A1;
  v7 = dword_806E9A5;
  v8 = dword_806E9A9;
  v9 = dword_806E9AD;
  v10 = dword_806E9B1;
  v11 = dword_806E9B5;
  v12 = dword_806E9B9;
  v13 = dword_806E9BD;
  v14 = dword_806E9C1;
  v15 = dword_806E9C5;
  v16 = dword_806E9C9;
  sub_806363F((signed __int32)&v5, a1, a2, &v5, a4, a5);
}
// 806E99D: using guessed type int dword_806E99D;
// 806E9A1: using guessed type int dword_806E9A1;
// 806E9A5: using guessed type int dword_806E9A5;
// 806E9A9: using guessed type int dword_806E9A9;
// 806E9AD: using guessed type int dword_806E9AD;
// 806E9B1: using guessed type int dword_806E9B1;
// 806E9B5: using guessed type int dword_806E9B5;
// 806E9B9: using guessed type int dword_806E9B9;
// 806E9BD: using guessed type int dword_806E9BD;
// 806E9C1: using guessed type int dword_806E9C1;
// 806E9C5: using guessed type int dword_806E9C5;
// 806E9C9: using guessed type int dword_806E9C9;

//----- (08065623) --------------------------------------------------------
void *__cdecl sub_8065623(signed int a1, signed __int32 a2, size_t a3)
{
  return sub_8064C8E(a1, a2, a3, (int)&unk_806E2D8);
}

//----- (0806566E) --------------------------------------------------------
void *__cdecl sub_806566E(signed int a1, signed __int32 a2)
{
  return sub_8065623(a1, a2, 0xFFFFFFFF);
}

//----- (08065761) --------------------------------------------------------
int __usercall sub_8065761@<eax>(signed __int32 a1@<ebx>, int fd)
{
  return sub_80664C0(a1, fd, 0, 3);
}

//----- (08065784) --------------------------------------------------------
int __usercall sub_8065784@<eax>(int a1@<edx>, int a2@<ecx>, FILE *stream, int a4, int a5, int a6, int a7, int a8)
{
  void *v8; // eax
  char *v9; // eax
  char *v10; // eax
  signed __int32 v11; // ebx
  char *v12; // eax
  int result; // eax
  int v14; // esi
  signed __int32 v15; // ebx
  char *v16; // eax
  int v17; // edi
  int v18; // esi
  signed __int32 v19; // ebx
  char *v20; // eax
  int v21; // eax
  signed __int32 v22; // eax
  signed __int32 v23; // ecx
  signed __int32 v24; // edx
  signed __int32 v25; // et1
  int v26; // ST54_4
  int v27; // edi
  int v28; // esi
  signed __int32 v29; // ebx
  char *v30; // eax
  int v31; // ST54_4
  int v32; // ST50_4
  int v33; // edi
  int v34; // esi
  signed __int32 v35; // ebx
  char *v36; // eax
  signed __int32 v37; // ebx
  signed __int32 v38; // edx
  int v39; // ecx
  signed __int32 v40; // ecx
  signed __int32 v41; // ett
  int v42; // ST54_4
  int v43; // ST50_4
  int v44; // ST4C_4
  int v45; // edi
  int v46; // esi
  signed __int32 v47; // ebx
  char *v48; // eax
  int v49; // esi
  int v50; // ST54_4
  int v51; // ST50_4
  int v52; // ST4C_4
  int v53; // ST48_4
  int v54; // edi
  signed __int32 v55; // ebx
  char *v56; // eax
  int v57; // edi
  int v58; // ST54_4
  int v59; // ST50_4
  int v60; // ST4C_4
  int v61; // ST48_4
  int v62; // ST44_4
  int v63; // esi
  signed __int32 v64; // ebx
  char *v65; // eax
  int v66; // eax
  signed __int32 v67; // eax
  signed __int32 v68; // edx
  int v69; // ecx
  signed __int32 v70; // ebx
  signed __int32 v71; // ecx
  int v72; // edi
  int v73; // ST54_4
  int v74; // ST50_4
  int v75; // ST4C_4
  int v76; // ST48_4
  int v77; // ST44_4
  int v78; // ST40_4
  int v79; // esi
  signed __int32 v80; // ebx
  char *v81; // eax
  int v82; // edi
  int v83; // ST54_4
  int v84; // ST50_4
  int v85; // ST4C_4
  int v86; // ST48_4
  int v87; // ST44_4
  int v88; // ST40_4
  int v89; // esi
  signed __int32 v90; // ebx
  char *v91; // eax

  v8 = &loc_80657AC;
  if ( !a4 )
    v8 = &loc_80657D6;
  dword_806E23C = (int)v8;
  sub_8067DD8(a2, a1);
  fprintf(stream, "%s (%s) %s\n", a4, a5, a6);
  v9 = gettext("(C)");
  fprintf(stream, "Copyright %s %d Free Software Foundation, Inc.", v9, 2017);
  v10 = gettext(
          "\n"
          "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\n"
          "This is free software: you are free to change and redistribute it.\n"
          "There is NO WARRANTY, to the extent permitted by law.\n"
          "\n");
  fputs_unlocked(v10, stream);
  switch ( a8 )
  {
    case 0:
      abort();
      return result;
    case 1:
      v11 = *(_DWORD *)a7;
      v12 = gettext("Written by %s.\n");
      return fprintf(stream, v12, v11);
    case 2:
      v14 = *(_DWORD *)(a7 + 4);
      v15 = *(_DWORD *)a7;
      v16 = gettext(aWrittenB);
      return fprintf(stream, v16, v15, v14);
    case 3:
      v17 = *(_DWORD *)(a7 + 8);
      v18 = *(_DWORD *)(a7 + 4);
      v19 = *(_DWORD *)a7;
      v20 = gettext("Written by %s, %s, and %s.\n");
      v21 = fprintf(stream, v20, v19, v18, v17);
      dword_806E19C = (int)&loc_8065D34;
      v22 = _InterlockedExchange(&dword_806E1A0, v21);
      _InterlockedExchange(&dword_806E1A0, v23);
      v25 = _InterlockedExchange(&dword_806E1A0, sub_8068230(_InterlockedExchange(&dword_806E1A0, v22)));
      _InterlockedExchange(&dword_806E1A0, v24);
      _InterlockedExchange(&dword_806E1A0, v25);
      goto LABEL_8;
    case 4:
LABEL_8:
      v26 = *(_DWORD *)(a7 + 12);
      v27 = *(_DWORD *)(a7 + 8);
      v28 = *(_DWORD *)(a7 + 4);
      v29 = *(_DWORD *)a7;
      v30 = gettext("Written by %s, %s, %s,\nand %s.\n");
      return fprintf(stream, v30, v29, v28, v27, v26);
    case 5:
      v31 = *(_DWORD *)(a7 + 16);
      v32 = *(_DWORD *)(a7 + 12);
      v33 = *(_DWORD *)(a7 + 8);
      v34 = *(_DWORD *)(a7 + 4);
      v35 = *(_DWORD *)a7;
      v36 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
      fprintf(stream, v36, v35, v34, v33, v32, v31);
      dword_806E19C = (int)&loc_8065D34;
      v37 = _InterlockedExchange(&dword_806E1A0, v35);
      _InterlockedExchange(&dword_806E1A0, v38);
      _InterlockedExchange(&dword_806E1A0, v37);
      v41 = _InterlockedExchange(&dword_806E1A0, sub_8068230(v39));
      _InterlockedExchange(&dword_806E1A0, v40);
      _InterlockedExchange(&dword_806E1A0, v41);
      goto LABEL_10;
    case 6:
LABEL_10:
      v42 = *(_DWORD *)(a7 + 20);
      v43 = *(_DWORD *)(a7 + 16);
      v44 = *(_DWORD *)(a7 + 12);
      v45 = *(_DWORD *)(a7 + 8);
      v46 = *(_DWORD *)(a7 + 4);
      v47 = *(_DWORD *)a7;
      v48 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
      return fprintf(stream, v48, v47, v46, v45, v44, v43, v42);
    case 7:
      v49 = *(_DWORD *)(a7 + 24);
      v50 = *(_DWORD *)(a7 + 20);
      v51 = *(_DWORD *)(a7 + 16);
      v52 = *(_DWORD *)(a7 + 12);
      v53 = *(_DWORD *)(a7 + 8);
      v54 = *(_DWORD *)(a7 + 4);
      v55 = *(_DWORD *)a7;
      v56 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
      return fprintf(stream, v56, v55, v54, v53, v52, v51, v50, v49);
    case 8:
      v57 = *(_DWORD *)(a7 + 28);
      v58 = *(_DWORD *)(a7 + 24);
      v59 = *(_DWORD *)(a7 + 20);
      v60 = *(_DWORD *)(a7 + 16);
      v61 = *(_DWORD *)(a7 + 12);
      v62 = *(_DWORD *)(a7 + 8);
      v63 = *(_DWORD *)(a7 + 4);
      v64 = *(_DWORD *)a7;
      v65 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
      v66 = fprintf(stream, v65, v64, v63, v62, v61, v60, v59, v58, v57);
      dword_806E1C4 = (int)&loc_8065D34;
      v67 = _InterlockedExchange(&dword_806E1C8, v66);
      _InterlockedExchange(&dword_806E1C8, v68);
      _InterlockedExchange(&dword_806E1C8, v67);
      sub_806812D(v69);
      v70 = _InterlockedExchange(&dword_806E1C8, v64);
      _InterlockedExchange(&dword_806E1C8, v71);
      _InterlockedExchange(&dword_806E1C8, v70);
      goto LABEL_13;
    case 9:
LABEL_13:
      v72 = *(_DWORD *)(a7 + 32);
      v73 = *(_DWORD *)(a7 + 28);
      v74 = *(_DWORD *)(a7 + 24);
      v75 = *(_DWORD *)(a7 + 20);
      v76 = *(_DWORD *)(a7 + 16);
      v77 = *(_DWORD *)(a7 + 12);
      v78 = *(_DWORD *)(a7 + 8);
      v79 = *(_DWORD *)(a7 + 4);
      v80 = *(_DWORD *)a7;
      v81 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
      result = fprintf(stream, v81, v80, v79, v78, v77, v76, v75, v74, v73, v72);
      break;
    default:
      v82 = *(_DWORD *)(a7 + 32);
      v83 = *(_DWORD *)(a7 + 28);
      v84 = *(_DWORD *)(a7 + 24);
      v85 = *(_DWORD *)(a7 + 20);
      v86 = *(_DWORD *)(a7 + 16);
      v87 = *(_DWORD *)(a7 + 12);
      v88 = *(_DWORD *)(a7 + 8);
      v89 = *(_DWORD *)(a7 + 4);
      v90 = *(_DWORD *)a7;
      v91 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
      result = fprintf(stream, v91, v90, v89, v88, v87, v86, v85, v84, v83, v82);
      break;
  }
  return result;
}
// 8048F20: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8067DD8: using guessed type int __fastcall sub_8067DD8(_DWORD, _DWORD);
// 806812D: using guessed type int __fastcall sub_806812D(_DWORD);
// 8068230: using guessed type int __fastcall sub_8068230(_DWORD);
// 806E19C: using guessed type int dword_806E19C;
// 806E1A0: using guessed type int dword_806E1A0;
// 806E1C4: using guessed type int dword_806E1C4;
// 806E1C8: using guessed type int dword_806E1C8;
// 806E23C: using guessed type int dword_806E23C;

//----- (08065DAD) --------------------------------------------------------
int __usercall sub_8065DAD@<eax>(int a1@<edx>, int a2@<ecx>, FILE *stream, int a4, int a5, int a6, int a7)
{
  int *v7; // eax
  unsigned int i; // [esp+24h] [ebp-34h]
  int v10[12]; // [esp+28h] [ebp-30h]

  for ( i = 0; i <= 9; ++i )
  {
    v7 = (int *)a7;
    a7 += 4;
    a1 = *v7;
    v10[i] = *v7;
    if ( !v10[i] )
      break;
  }
  return sub_8065784(a1, a2, stream, a4, a5, a6, (int)v10, i);
}
// 8065DAD: using guessed type int var_30[12];

//----- (08065E13) --------------------------------------------------------
int __usercall sub_8065E13@<eax>(int a1@<edx>, int a2@<ecx>, FILE *stream, int a4, int a5, int a6, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a6);
  return sub_8065DAD(a1, a2, stream, a4, a5, a6, (int)va);
}

//----- (08065F9B) --------------------------------------------------------
void *__cdecl sub_8065F9B(void *ptr, int a2, int a3)
{
  signed __int32 v3; // ecx
  _BOOL4 v4; // eax
  signed __int32 v5; // eax
  signed __int32 v6; // ecx
  signed __int32 v7; // et1
  signed __int32 v8; // eax
  signed __int32 v9; // ecx
  signed __int32 v10; // ett
  signed __int32 v11; // edx
  signed __int32 v12; // eax
  signed __int32 v13; // et0
  unsigned int v15; // [esp+1Ch] [ebp-Ch]

  v15 = *(_DWORD *)a2;
  if ( ptr )
  {
    if ( 0x55555554u / a3 <= v15 )
      sub_80663AB();
    goto LABEL_4;
  }
  if ( !v15 )
  {
    v4 = 0x40u / a3 == 0;
    v15 = v4 + 0x40u / a3;
    dword_806E110 = (int)&loc_8066040;
    v5 = _InterlockedExchange(&dword_806E114, v4);
    _InterlockedExchange(&dword_806E114, v3);
    v7 = _InterlockedExchange(&dword_806E114, sub_80685D2(_InterlockedExchange(&dword_806E114, v5)));
    _InterlockedExchange(&dword_806E114, v6);
    v3 = _InterlockedExchange(&dword_806E114, v7);
LABEL_4:
    v15 += (v15 >> 1) + 1;
    goto LABEL_9;
  }
  if ( 0x7FFFFFFFu / a3 < v15 )
  {
    dword_806E1B0 = (int)&loc_8066022;
    v8 = _InterlockedExchange(&dword_806E1B4, 0x7FFFFFFFu / a3);
    _InterlockedExchange(&dword_806E1B4, 0x7FFFFFFFu % a3);
    v10 = _InterlockedExchange(&dword_806E1B4, sub_80681B2(v3, _InterlockedExchange(&dword_806E1B4, v8)));
    v13 = _InterlockedExchange(
            &dword_806E288,
            _InterlockedExchange(&dword_806E288, _InterlockedExchange(&dword_806E1B4, v9)));
    v12 = _InterlockedExchange(&dword_806E288, v11);
    _InterlockedExchange(&dword_806E288, v13);
    _InterlockedExchange(&dword_806E288, _InterlockedExchange(&dword_806E1B4, v10));
    v3 = _InterlockedExchange(&dword_806E288, v12);
  }
LABEL_9:
  *(_DWORD *)a2 = v15;
  return sub_806618F(v15, v3, ptr, a3 * v15);
}
// 80681B2: using guessed type int __fastcall sub_80681B2(_DWORD, _DWORD);
// 80685D2: using guessed type int __fastcall sub_80685D2(_DWORD);
// 806E110: using guessed type int dword_806E110;
// 806E114: using guessed type int dword_806E114;
// 806E1B0: using guessed type int dword_806E1B0;
// 806E1B4: using guessed type int dword_806E1B4;
// 806E288: using guessed type int dword_806E288;

//----- (080660CD) --------------------------------------------------------
void *__usercall sub_80660CD@<eax>(signed __int32 a1@<ebx>, size_t size)
{
  return sub_80660E0(a1, size);
}

//----- (080660E0) --------------------------------------------------------
void *__usercall sub_80660E0@<eax>(signed __int32 a1@<ebx>, size_t size)
{
  signed __int32 v2; // edx
  int v3; // ecx
  signed __int32 v4; // ebx
  signed __int32 v5; // et0
  signed __int32 v6; // ebx
  signed __int32 v7; // ecx
  void *v9; // [esp+1Ch] [ebp-Ch]

  v9 = malloc(size);
  if ( !v9 && size )
  {
    dword_806E23C = (int)sub_806613E;
    v4 = _InterlockedExchange(&dword_806E240, a1);
    v5 = _InterlockedExchange(&dword_806E240, v2);
    sub_8067DD8(v3, _InterlockedExchange(&dword_806E240, v4));
    v6 = _InterlockedExchange(&dword_806E240, v5);
    _InterlockedExchange(&dword_806E240, v7);
    _InterlockedExchange(&dword_806E240, v6);
  }
  return v9;
}
// 806613E: using guessed type void __noreturn sub_806613E();
// 8067DD8: using guessed type int __fastcall sub_8067DD8(_DWORD, _DWORD);
// 806E23C: using guessed type int dword_806E23C;
// 806E240: using guessed type int dword_806E240;

//----- (0806618F) --------------------------------------------------------
void *__usercall sub_806618F@<eax>(int a1@<edx>, int a2@<ecx>, void *ptr, size_t size)
{
  void *v4; // eax
  void *result; // eax
  int v6; // ecx
  void *v7; // eax
  void *ptra; // [esp+20h] [ebp+8h]

  if ( size )
  {
    ptra = realloc(ptr, size);
    if ( !ptra )
    {
      v7 = &loc_8066206;
      if ( !size )
        v7 = &loc_806620B;
      dword_806E228 = (int)v7;
      sub_8067E53(v6);
      sub_80663AB();
    }
    result = ptra;
  }
  else
  {
    v4 = &loc_80661BA;
    if ( !ptr )
      v4 = &loc_80661CC;
    dword_806E200 = (int)v4;
    sub_8067F6F(a2, a1);
    free(ptr);
    result = 0;
  }
  return result;
}
// 8067E53: using guessed type int __fastcall sub_8067E53(_DWORD);
// 8067F6F: using guessed type int __fastcall sub_8067F6F(_DWORD, _DWORD);
// 806E200: using guessed type int dword_806E200;
// 806E228: using guessed type int dword_806E228;

//----- (08066299) --------------------------------------------------------
void *__usercall sub_8066299@<eax>(signed __int32 a1@<ebx>, void *src, size_t n)
{
  void *v3; // eax

  v3 = sub_80660E0(a1, n);
  return memcpy(v3, src, n);
}

//----- (080663AB) --------------------------------------------------------
void __noreturn sub_80663AB()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (080663E4) --------------------------------------------------------
int __cdecl sub_80663E4(FILE *stream)
{
  bool v2; // zf
  int v3; // ecx
  void *v4; // eax
  int v5; // eax
  __int64 v6; // rax
  int v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+18h] [ebp-10h]

  v7 = 0;
  if ( fileno(stream) < 0 )
    return fclose(stream);
  v2 = __freading(stream) == 0;
  v4 = &loc_8066444;
  if ( v2 )
    v4 = &loc_806647D;
  dword_806E110 = (int)v4;
  sub_80685D2(v3);
  v5 = fileno(stream);
  LODWORD(v6) = lseek64(v5, 0, 0, 1);
  if ( v6 != -1 && sub_80666E9(stream) )
    v7 = *__errno_location();
  v8 = fclose(stream);
  if ( v7 )
  {
    *__errno_location() = v7;
    v8 = -1;
  }
  return v8;
}
// 8049030: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 80685D2: using guessed type int __fastcall sub_80685D2(_DWORD);
// 806E110: using guessed type int dword_806E110;

//----- (080664C0) --------------------------------------------------------
int __usercall sub_80664C0@<eax>(signed __int32 a1@<ebx>, int fd, int cmd, char a4)
{
  signed __int32 v4; // ecx
  bool v5; // zf
  int v6; // ecx
  void *v7; // eax
  signed __int32 v8; // ebx
  signed __int32 v9; // et0
  signed __int32 v10; // ebx
  signed __int32 v11; // ecx
  signed __int32 v12; // ecx
  signed __int32 v13; // ebx
  signed __int32 v14; // et1
  signed __int32 v15; // edx
  int v16; // ecx
  signed __int32 v17; // ebx
  signed __int32 v18; // edx
  signed __int32 v19; // et2
  signed __int32 v20; // ecx
  signed __int32 v21; // ett
  int v22; // ST30_4
  signed int v24; // [esp+1Ch] [ebp-1Ch]
  char v25; // [esp+20h] [ebp-18h]
  int v26; // [esp+24h] [ebp-14h]

  if ( cmd != 1030 )
    return fcntl(fd, cmd, a4);
  v25 = a4;
  if ( dword_806EADD < 0 )
    goto LABEL_9;
  if ( fcntl(fd, 1030, a4) < 0 )
  {
    v5 = *__errno_location() == 22;
    v7 = &loc_8066543;
    if ( v5 )
      v7 = &loc_8066584;
    dword_806E1C4 = (int)v7;
    sub_806812D(v6);
  }
  dword_806EADD = 1;
  dword_806E124 = (int)&loc_8066609;
  v8 = _InterlockedExchange(&dword_806E128, a1);
  v9 = _InterlockedExchange(&dword_806E128, v4);
  sub_8068556(_InterlockedExchange(&dword_806E128, v8));
  v10 = _InterlockedExchange(&dword_806E128, v9);
  v14 = _InterlockedExchange(&dword_806E128, v11);
  v12 = v10;
  v13 = v14;
  _InterlockedExchange(&dword_806E128, v12);
  v24 = sub_80664C0(v14, fd, 0, v25);
  if ( v24 >= 0 )
  {
    dword_806EADD = -1;
    dword_806E264 = (int)&loc_8066609;
    v17 = _InterlockedExchange(&dword_806E268, v13);
    v19 = _InterlockedExchange(&dword_806E268, v15);
    v18 = v17;
    a1 = v19;
    v21 = _InterlockedExchange(&dword_806E268, sub_8067CB2(v16, _InterlockedExchange(&dword_806E268, v18)));
    _InterlockedExchange(&dword_806E268, v20);
    _InterlockedExchange(&dword_806E268, v21);
LABEL_9:
    v24 = sub_80664C0(a1, fd, 0, v25);
    if ( v24 >= 0 && dword_806EADD == -1 )
    {
      v26 = fcntl(v24, 1);
      if ( v26 < 0 || fcntl(v24, 2, v26 | 1) == -1 )
      {
        v22 = *__errno_location();
        close(v24);
        *__errno_location() = v22;
        v24 = -1;
      }
    }
  }
  return v24;
}
// 8067CB2: using guessed type int __fastcall sub_8067CB2(_DWORD, _DWORD);
// 806812D: using guessed type int __fastcall sub_806812D(_DWORD);
// 8068556: using guessed type int __fastcall sub_8068556(_DWORD);
// 806E124: using guessed type int dword_806E124;
// 806E128: using guessed type int dword_806E128;
// 806E1C4: using guessed type int dword_806E1C4;
// 806E264: using guessed type int dword_806E264;
// 806E268: using guessed type int dword_806E268;
// 806EADD: using guessed type int dword_806EADD;

//----- (080666B0) --------------------------------------------------------
int __cdecl sub_80666B0(FILE *stream)
{
  int result; // eax

  result = stream->_flags & 0x100;
  if ( result )
    result = sub_806675D(stream, 0, 0, 1);
  return result;
}

//----- (080666E9) --------------------------------------------------------
int __cdecl sub_80666E9(FILE *fp)
{
  bool v1; // zf
  int v2; // ecx
  void *v3; // eax

  if ( fp )
  {
    v1 = __freading(fp) == 0;
    v3 = &loc_806671D;
    if ( !v1 )
      v3 = &loc_806672E;
    dword_806E1C4 = (int)v3;
    sub_806812D(v2);
  }
  return fflush(fp);
}
// 806812D: using guessed type int __fastcall sub_806812D(_DWORD);
// 806E1C4: using guessed type int dword_806E1C4;

//----- (0806675D) --------------------------------------------------------
int __cdecl sub_806675D(FILE *stream, int a2, int a3, int a4)
{
  int v4; // ecx
  void *v5; // eax
  signed __int32 v6; // ecx
  void *v7; // eax
  int v8; // eax
  __off64_t v9; // rax
  signed __int32 v11; // ecx
  signed __int32 v12; // et1

  v5 = &loc_8066798;
  if ( stream->_IO_read_end != stream->_IO_read_ptr )
    v5 = &loc_8066872;
  dword_806E1D8 = (int)v5;
  sub_806808A(v4);
  if ( stream->_IO_write_ptr == stream->_IO_write_base )
  {
    v7 = &loc_80667CF;
    if ( stream->_IO_save_base )
      v7 = &loc_8066872;
    dword_806E174 = (int)v7;
    sub_806833F(v6);
    v8 = fileno(stream);
    LODWORD(v9) = lseek64(v8, a2, a3, a4);
    if ( v9 == -1 )
      return -1;
    stream->_flags &= 0xFFFFFFEF;
    stream->_offset = v9;
    dword_806E264 = (int)&locret_8066892;
    LODWORD(v9) = _InterlockedExchange(&dword_806E268, 0);
    _InterlockedExchange(&dword_806E268, SHIDWORD(v9));
    v12 = _InterlockedExchange(&dword_806E268, sub_8067CB2(stream, _InterlockedExchange(&dword_806E268, v9)));
    _InterlockedExchange(&dword_806E268, v11);
    v6 = _InterlockedExchange(&dword_806E268, v12);
  }
  return fseeko64(v6);
}
// 806675D: could not find valid save-restore pair for ebx
// 8048DC0: using guessed type int __fastcall fseeko64(_DWORD);
// 8049030: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8067CB2: using guessed type int __fastcall sub_8067CB2(_DWORD, _DWORD);
// 806808A: using guessed type int __fastcall sub_806808A(_DWORD);
// 806833F: using guessed type int __fastcall sub_806833F(_DWORD);
// 806E174: using guessed type int dword_806E174;
// 806E1D8: using guessed type int dword_806E1D8;
// 806E264: using guessed type int dword_806E264;
// 806E268: using guessed type int dword_806E268;

//----- (08066894) --------------------------------------------------------
unsigned int __usercall sub_8066894@<eax>(signed __int32 a1@<ebx>, wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  signed __int32 v5; // eax
  signed __int32 v6; // eax
  signed __int32 v7; // ecx
  signed __int32 v8; // ecx
  signed __int32 v9; // et1
  signed __int32 v10; // ecx
  wchar_t v11; // edx
  signed __int32 v12; // eax
  signed __int32 v13; // eax
  signed __int32 v14; // edx
  signed __int32 v15; // edx
  signed __int32 v16; // ebx
  int v17; // ecx
  signed __int32 v18; // ecx
  signed __int32 v19; // et1
  signed __int32 v20; // edx
  int v21; // ecx
  signed __int32 v22; // ebx
  signed __int32 v23; // et2
  unsigned int v24; // eax
  signed __int32 v25; // ebx
  signed __int32 v26; // edx
  signed __int32 v27; // edx
  signed __int32 v28; // ett
  char v30; // [esp+18h] [ebp-10h]
  unsigned int v31; // [esp+1Ch] [ebp-Ch]

  if ( !pwc )
    pwc = (wchar_t *)&v30;
  v5 = mbrtowc(pwc, s, n, p);
  dword_806E188 = (int)&loc_80669D5;
  v6 = _InterlockedExchange(&dword_806E18C, v5);
  _InterlockedExchange(&dword_806E18C, v7);
  v9 = _InterlockedExchange(&dword_806E18C, sub_80682B5(_InterlockedExchange(&dword_806E18C, v6)));
  _InterlockedExchange(&dword_806E18C, v8);
  v10 = _InterlockedExchange(&dword_806E18C, v9);
  v11 = (unsigned __int8)*s;
  *pwc = v11;
  dword_806E1C4 = (int)&locret_8066A43;
  v12 = _InterlockedExchange(&dword_806E1C8, 1);
  _InterlockedExchange(&dword_806E1C8, v11);
  _InterlockedExchange(&dword_806E1C8, v12);
  v13 = _InterlockedExchange(&dword_806E1C8, sub_806812D(v10));
  _InterlockedExchange(&dword_806E1C8, v14);
  dword_806E228 = (int)&loc_8066A40;
  v15 = _InterlockedExchange(&dword_806E22C, a1);
  v16 = _InterlockedExchange(&dword_806E22C, _InterlockedExchange(&dword_806E1C8, v13));
  _InterlockedExchange(&dword_806E22C, v15);
  v19 = _InterlockedExchange(&dword_806E22C, sub_8067E53(v17));
  _InterlockedExchange(&dword_806E22C, v18);
  _InterlockedExchange(&dword_806E22C, v19);
  do
  {
    if ( !n )
      break;
    if ( !((unsigned __int8)sub_8066C96(v16, 0) ^ 1) )
      break;
    dword_806E1C4 = (int)&loc_80668FB;
    v22 = _InterlockedExchange(&dword_806E1C8, v16);
    v23 = _InterlockedExchange(&dword_806E1C8, v20);
    _InterlockedExchange(&dword_806E1C8, v22);
    v24 = sub_806812D(v21);
    v25 = _InterlockedExchange(&dword_806E1C8, v23);
    v28 = _InterlockedExchange(&dword_806E1C8, v26);
    v27 = v25;
    v16 = v28;
    _InterlockedExchange(&dword_806E1C8, v27);
    v31 = v24;
  }
  while ( v24 > 0xFFFFFFFD );
  return v31;
}
// 8067E53: using guessed type int __fastcall sub_8067E53(_DWORD);
// 806812D: using guessed type int __fastcall sub_806812D(_DWORD);
// 80682B5: using guessed type int __fastcall sub_80682B5(_DWORD);
// 806E188: using guessed type int dword_806E188;
// 806E18C: using guessed type int dword_806E18C;
// 806E1C4: using guessed type int dword_806E1C4;
// 806E1C8: using guessed type int dword_806E1C8;
// 806E228: using guessed type int dword_806E228;
// 806E22C: using guessed type int dword_806E22C;

//----- (08066A45) --------------------------------------------------------
int __usercall sub_8066A45@<eax>(signed __int32 a1@<edx>, int a2@<ecx>, unsigned __int8 *a3, signed __int32 a4)
{
  unsigned __int8 *v4; // esi
  unsigned __int8 *v5; // ebx
  signed __int32 v6; // ebx
  signed __int32 v7; // et0
  signed __int32 v8; // ebx
  signed __int32 v9; // edx
  signed __int32 v10; // edx
  signed __int32 v11; // et1
  int v13; // edx
  int v14; // ecx
  void *v15; // eax
  signed __int32 v16; // ebx
  signed __int32 v17; // ecx
  signed __int32 v18; // ecx
  signed __int32 v19; // et2
  signed __int32 v20; // edx
  signed __int32 v21; // ett
  char v22; // al
  signed __int32 v23; // edx
  int v24; // ecx
  char v25; // [esp+1Eh] [ebp-Ah]
  unsigned __int8 v26; // [esp+1Fh] [ebp-9h]

  v4 = a3;
  v5 = (unsigned __int8 *)a4;
  if ( a3 == (unsigned __int8 *)a4 )
  {
    dword_806E160 = (int)&loc_8066B3A;
    v6 = _InterlockedExchange(&dword_806E164, a4);
    v7 = _InterlockedExchange(&dword_806E164, a1);
    sub_80683C2(a2, _InterlockedExchange(&dword_806E164, v6));
    v8 = _InterlockedExchange(&dword_806E164, v7);
    v11 = _InterlockedExchange(&dword_806E164, v9);
    v10 = v8;
    v5 = (unsigned __int8 *)v11;
    a1 = _InterlockedExchange(&dword_806E164, v10);
  }
  while ( 1 )
  {
    v22 = sub_806789C(a1, a2, (signed __int32)v5, *v4);
    v25 = v22;
    v26 = sub_806789C(v23, v24, (signed __int32)v5, *v5);
    if ( !v25 )
      break;
    ++v4;
    v15 = &loc_8066AF1;
    if ( v25 == v26 )
      v15 = &loc_8066B27;
    dword_806E160 = (int)v15;
    sub_80683C2(v14, v13);
    dword_806E1C4 = (int)&loc_8066A9C;
    v16 = _InterlockedExchange(&dword_806E1C8, (signed __int32)(v5 + 1));
    v19 = _InterlockedExchange(&dword_806E1C8, v17);
    v18 = v16;
    v5 = (unsigned __int8 *)v19;
    v21 = _InterlockedExchange(&dword_806E1C8, sub_806812D(_InterlockedExchange(&dword_806E1C8, v18)));
    _InterlockedExchange(&dword_806E1C8, v20);
    a1 = _InterlockedExchange(&dword_806E1C8, v21);
  }
  return -v26;
}
// 806812D: using guessed type int __fastcall sub_806812D(_DWORD);
// 80683C2: using guessed type int __fastcall sub_80683C2(_DWORD, _DWORD);
// 806E160: using guessed type int dword_806E160;
// 806E164: using guessed type int dword_806E164;
// 806E1C4: using guessed type int dword_806E1C4;
// 806E1C8: using guessed type int dword_806E1C8;

//----- (08066B41) --------------------------------------------------------
int __usercall sub_8066B41@<eax>(signed __int32 a1@<ebx>, FILE *fp)
{
  bool v2; // ST26_1
  int v3; // edx
  int v4; // ecx
  int v5; // eax
  signed __int32 v6; // ecx
  signed __int32 v7; // eax
  int *v8; // eax
  int v9; // ecx
  signed __int32 v10; // ebx
  signed __int32 v11; // edx
  signed __int32 v12; // edx
  signed __int32 v13; // et1
  signed __int32 v14; // edx
  signed __int32 v15; // eax
  signed __int32 v16; // eax
  signed __int32 v17; // ebx
  signed __int32 v18; // edx
  signed __int32 v19; // ett
  signed __int32 v20; // edx
  signed __int32 v21; // ebx
  signed __int32 v22; // et0
  signed __int32 v23; // edx
  signed __int32 v24; // eax
  signed __int32 v25; // ebx
  signed __int32 v26; // ecx
  signed __int32 v27; // edx
  signed __int32 v28; // et2
  void *v29; // eax
  bool v31; // [esp+1Dh] [ebp-Bh]
  bool v32; // [esp+1Fh] [ebp-9h]

  v31 = __fpending(fp) != 0;
  v2 = ferror_unlocked(fp) != 0;
  v32 = sub_80663E4(fp) != 0;
  if ( v2 )
    goto LABEL_14;
  if ( !v32 )
    return 0;
  if ( v31 )
  {
LABEL_14:
    v29 = &loc_8066C86;
    if ( v32 == 1 )
      v29 = &loc_8066C88;
    dword_806E200 = (int)v29;
    sub_8067F6F(v4, v3);
    goto LABEL_7;
  }
  v5 = *__errno_location();
  if ( v5 != 9 )
  {
    dword_806E1EC = (int)&loc_8066C62;
    v7 = _InterlockedExchange(&dword_806E1F0, v5);
    _InterlockedExchange(&dword_806E1F0, v6);
    v8 = (int *)sub_806800D(_InterlockedExchange(&dword_806E1F0, v7));
    v10 = _InterlockedExchange(&dword_806E1F0, a1);
    v13 = _InterlockedExchange(&dword_806E1F0, v11);
    v12 = v10;
    a1 = v13;
    v14 = _InterlockedExchange(&dword_806E1F0, v12);
    while ( 1 )
    {
      *v8 = 0;
      dword_806E1B0 = (int)&loc_8066C88;
      v15 = _InterlockedExchange(&dword_806E1B4, (signed __int32)v8);
      _InterlockedExchange(&dword_806E1B4, v14);
      v16 = sub_80681B2(v9, _InterlockedExchange(&dword_806E1B4, v15));
      v17 = _InterlockedExchange(&dword_806E1B4, a1);
      v19 = _InterlockedExchange(&dword_806E1B4, v18);
      v20 = _InterlockedExchange(&dword_806E1B4, v17);
      v21 = _InterlockedExchange(&dword_806E288, v19);
      v22 = _InterlockedExchange(&dword_806E288, v20);
      v23 = _InterlockedExchange(&dword_806E288, v21);
      v24 = _InterlockedExchange(&dword_806E288, v16);
      v25 = _InterlockedExchange(&dword_806E288, v22);
      _InterlockedExchange(&dword_806E288, v26);
      _InterlockedExchange(&dword_806E288, v24);
      v28 = _InterlockedExchange(&dword_806E288, v23);
      v27 = v25;
      a1 = v28;
      _InterlockedExchange(&dword_806E288, v27);
LABEL_7:
      v8 = __errno_location();
    }
  }
  return 0;
}
// 8067F6F: using guessed type int __fastcall sub_8067F6F(_DWORD, _DWORD);
// 806800D: using guessed type int __fastcall sub_806800D(_DWORD);
// 80681B2: using guessed type int __fastcall sub_80681B2(_DWORD, _DWORD);
// 806E1B0: using guessed type int dword_806E1B0;
// 806E1B4: using guessed type int dword_806E1B4;
// 806E1EC: using guessed type int dword_806E1EC;
// 806E1F0: using guessed type int dword_806E1F0;
// 806E200: using guessed type int dword_806E200;
// 806E288: using guessed type int dword_806E288;

//----- (08066C96) --------------------------------------------------------
int __usercall sub_8066C96@<eax>(signed __int32 a1@<ebx>, int category)
{
  bool v2; // zf
  int v3; // edx
  int v4; // ecx
  int (*v5)(); // eax
  signed __int32 v6; // eax
  signed __int32 v7; // eax
  signed __int32 v8; // ecx
  signed __int32 v9; // ebx
  signed __int32 v10; // edx
  const char *s1; // [esp+1Ch] [ebp-Ch]

  s1 = setlocale(category, 0);
  if ( s1 )
  {
    v2 = strcmp(s1, "C") == 0;
    v5 = (int (*)())&loc_8066CEC;
    if ( v2 )
      v5 = sub_8066D45;
    dword_806E23C = (int)v5;
    v6 = sub_8067DD8(v4, v3);
    dword_806E138 = (int)&loc_8066D7F;
    v7 = _InterlockedExchange(&dword_806E13C, v6);
    _InterlockedExchange(&dword_806E13C, v8);
    sub_80684CC(_InterlockedExchange(&dword_806E13C, v7));
    v9 = _InterlockedExchange(&dword_806E13C, a1);
    _InterlockedExchange(&dword_806E13C, v10);
    _InterlockedExchange(&dword_806E13C, v9);
  }
  return 1;
}
// 8066D45: using guessed type int sub_8066D45();
// 8067DD8: using guessed type int __fastcall sub_8067DD8(_DWORD, _DWORD);
// 80684CC: using guessed type int __fastcall sub_80684CC(_DWORD);
// 806E138: using guessed type int dword_806E138;
// 806E13C: using guessed type int dword_806E13C;
// 806E23C: using guessed type int dword_806E23C;

//----- (08066DC7) --------------------------------------------------------
void *__usercall sub_8066DC7@<eax>(int a1@<ecx>, signed __int32 a2@<ebx>)
{
  void *v2; // eax
  char *v3; // eax
  int v4; // ecx
  bool v5; // zf
  void *v6; // eax
  int v7; // edx
  int v8; // ecx
  void *v9; // eax
  int v10; // ecx
  void *v11; // eax
  signed __int32 v12; // ebx
  signed __int32 v13; // ecx
  signed __int32 v14; // et0
  signed __int32 v15; // ebx
  signed __int32 v16; // ecx
  signed __int32 v17; // ecx
  signed __int32 v18; // et1
  int v19; // ecx
  signed __int32 v20; // eax
  signed __int32 v21; // edx
  signed __int32 v22; // ecx
  signed __int32 v23; // eax
  signed __int32 v24; // ebx
  signed __int32 v25; // edx
  signed __int32 v26; // edx
  signed __int32 v27; // ett
  int v28; // eax
  signed __int32 v29; // edx
  signed __int32 v30; // ecx
  signed __int32 v31; // ebx
  signed __int32 v32; // ecx
  signed __int32 v33; // et0
  signed __int32 v34; // ecx
  signed __int32 v35; // et1
  signed __int32 v36; // eax
  signed __int32 v37; // ebx
  signed __int32 v38; // ecx
  signed __int32 v39; // ecx
  signed __int32 v40; // ett
  int v41; // ecx
  void *v42; // eax
  void *v43; // eax
  signed __int32 v44; // eax
  signed __int32 v45; // eax
  signed __int32 v46; // edx
  int v47; // ecx
  signed __int32 v48; // ecx
  signed __int32 v49; // et1
  signed __int32 v50; // edx
  int v51; // ecx
  signed __int32 v52; // ebx
  signed __int32 v53; // edx
  signed __int32 v54; // et2
  signed __int32 v55; // ecx
  signed __int32 v56; // ett
  char *s; // [esp+1Ch] [ebp-ACh]
  char *v59; // [esp+20h] [ebp-A8h]
  int i; // [esp+24h] [ebp-A4h]
  size_t n; // [esp+2Ch] [ebp-9Ch]
  size_t v62; // [esp+30h] [ebp-98h]
  char *dest; // [esp+38h] [ebp-90h]
  int fd; // [esp+3Ch] [ebp-8Ch]
  FILE *stream; // [esp+40h] [ebp-88h]
  int c; // [esp+44h] [ebp-84h]
  int ca; // [esp+44h] [ebp-84h]
  size_t v68; // [esp+48h] [ebp-80h]
  size_t v69; // [esp+4Ch] [ebp-7Ch]
  char *v70; // [esp+50h] [ebp-78h]
  char src; // [esp+56h] [ebp-72h]
  char v72; // [esp+89h] [ebp-3Fh]
  unsigned int v73; // [esp+BCh] [ebp-Ch]

  v73 = __readgsdword(0x14u);
  v2 = &loc_8066E09;
  if ( dword_806EAE1 )
    v2 = &loc_80673FE;
  dword_806E1D8 = (int)v2;
  sub_806808A(a1);
  v3 = getenv(name);
  s = v3;
  v5 = v3 == 0;
  v6 = &loc_8066E51;
  if ( v5 )
    v6 = &loc_8066E77;
  dword_806E188 = (int)v6;
  sub_80682B5(v4);
  v9 = &loc_8066E77;
  if ( *s )
    v9 = &loc_8066E8B;
  dword_806E23C = (int)v9;
  sub_8067DD8(v8, v7);
  n = strlen("/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib");
  v62 = strlen("charset.alias");
  if ( n )
  {
    v11 = &loc_8066EED;
    if ( aHomeHwangdzCor_0[n - 1] == 47 )
      v11 = &loc_8066F29;
    dword_806E138 = (int)v11;
    sub_80684CC(v10);
    dword_806E228 = (int)&loc_8066F2E;
    v12 = _InterlockedExchange(&dword_806E22C, a2);
    v14 = _InterlockedExchange(&dword_806E22C, v13);
    sub_8067E53(_InterlockedExchange(&dword_806E22C, v12));
    v15 = _InterlockedExchange(&dword_806E22C, v14);
    v18 = _InterlockedExchange(&dword_806E22C, v16);
    v17 = v15;
    a2 = v18;
    _InterlockedExchange(&dword_806E22C, v17);
  }
  dest = (char *)malloc(n + v62 + 1);
  if ( dest )
  {
    memcpy(dest, "/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib", n);
    dword_806E1D8 = (int)&loc_8066FBD;
    sub_806808A(v19);
    dest[n] = 47;
    memcpy(&dest[n], "charset.alias", v62 + 1);
  }
  free(0);
  if ( !dest )
  {
    dword_806E214 = (int)&loc_80673F3;
    v23 = _InterlockedExchange(&dword_806E218, v20);
    _InterlockedExchange(&dword_806E218, v22);
    sub_8067ECF(_InterlockedExchange(&dword_806E218, v23));
    v24 = _InterlockedExchange(&dword_806E218, a2);
    v27 = _InterlockedExchange(&dword_806E218, v25);
    v26 = v24;
    a2 = v27;
    v21 = _InterlockedExchange(&dword_806E218, v26);
  }
  fd = open64(v22, v21, dest, 0x20000);
  if ( fd >= 0 )
  {
    stream = fdopen(fd, "r");
    if ( !stream )
    {
      close(fd);
      goto LABEL_43;
    }
    v59 = 0;
    for ( i = 0; ; strcpy(&v59[i - v69 - 1], &v72) )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          v28 = getc_unlocked(stream);
          c = v28;
          if ( v28 == -1 )
          {
            dword_806E278 = (int)&loc_806736A;
            v31 = _InterlockedExchange(&dword_806E27C, a2);
            v33 = _InterlockedExchange(&dword_806E27C, v30);
            v32 = v31;
            a2 = v33;
            v35 = _InterlockedExchange(&dword_806E27C, sub_8067C35(_InterlockedExchange(&dword_806E27C, v32)));
            v28 = _InterlockedExchange(&dword_806E27C, v34);
            v30 = _InterlockedExchange(&dword_806E27C, v35);
          }
          if ( c == 10 || c == 32 || c == 9 )
          {
            dword_806E174 = (int)&loc_80673B7;
            v36 = _InterlockedExchange(&dword_806E178, v28);
            _InterlockedExchange(&dword_806E178, v29);
            _InterlockedExchange(&dword_806E178, v36);
            sub_806833F(v30);
            v37 = _InterlockedExchange(&dword_806E178, a2);
            v40 = _InterlockedExchange(&dword_806E178, v38);
            v39 = v37;
            a2 = v40;
            _InterlockedExchange(&dword_806E178, v39);
          }
          if ( c != 35 )
            break;
          ca = getc_unlocked(stream);
          if ( ca != -1 )
          {
            v42 = &loc_80671C3;
            if ( ca != 10 )
              v42 = &loc_8067184;
            dword_806E228 = (int)v42;
            sub_8067E53(v41);
          }
          v43 = &loc_80671E5;
          if ( ca != -1 )
            v43 = &loc_806721A;
          dword_806E250 = (int)v43;
          v44 = sub_8067D53(v41);
          dword_806E138 = (int)&loc_806736A;
          v45 = _InterlockedExchange(&dword_806E13C, v44);
          _InterlockedExchange(&dword_806E13C, v46);
          _InterlockedExchange(&dword_806E13C, v45);
          v49 = _InterlockedExchange(&dword_806E13C, sub_80684CC(v47));
          _InterlockedExchange(&dword_806E13C, v48);
          _InterlockedExchange(&dword_806E13C, v49);
        }
        ungetc(c, stream);
        if ( fscanf(stream, "%50s %50s", &src, &v72) > 1 )
          break;
LABEL_40:
        sub_80663E4(stream);
        if ( !i )
          goto LABEL_43;
        dword_806E1B0 = (int)&loc_80673C8;
        v52 = _InterlockedExchange(&dword_806E1B4, a2);
        v54 = _InterlockedExchange(&dword_806E1B4, v50);
        v53 = v52;
        a2 = v54;
        v56 = _InterlockedExchange(&dword_806E1B4, sub_80681B2(v51, _InterlockedExchange(&dword_806E1B4, v53)));
        _InterlockedExchange(&dword_806E1B4, v55);
        _InterlockedExchange(&dword_806E1B4, v56);
      }
      v68 = strlen(&src);
      v69 = strlen(&v72);
      v70 = v59;
      if ( i )
      {
        i += v69 + v68 + 2;
        v59 = (char *)realloc(v59, i + 1);
      }
      else
      {
        i = v68 + v69 + 2;
        v59 = (char *)malloc(v68 + v69 + 3);
      }
      if ( !v59 )
      {
        i = 0;
        free(v70);
        goto LABEL_40;
      }
      strcpy(&v59[i - v69 - v68 - 2], &src);
    }
  }
LABEL_43:
  free(dest);
  dword_806EAE1 = (int)&unk_8069EA3;
  return &unk_8069EA3;
}
// 8048D10: using guessed type int __fastcall open64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8067C35: using guessed type int __fastcall sub_8067C35(_DWORD);
// 8067D53: using guessed type int __fastcall sub_8067D53(_DWORD);
// 8067DD8: using guessed type int __fastcall sub_8067DD8(_DWORD, _DWORD);
// 8067E53: using guessed type int __fastcall sub_8067E53(_DWORD);
// 8067ECF: using guessed type int __fastcall sub_8067ECF(_DWORD);
// 806808A: using guessed type int __fastcall sub_806808A(_DWORD);
// 80681B2: using guessed type int __fastcall sub_80681B2(_DWORD, _DWORD);
// 80682B5: using guessed type int __fastcall sub_80682B5(_DWORD);
// 806833F: using guessed type int __fastcall sub_806833F(_DWORD);
// 80684CC: using guessed type int __fastcall sub_80684CC(_DWORD);
// 806E138: using guessed type int dword_806E138;
// 806E13C: using guessed type int dword_806E13C;
// 806E174: using guessed type int dword_806E174;
// 806E178: using guessed type int dword_806E178;
// 806E188: using guessed type int dword_806E188;
// 806E1B0: using guessed type int dword_806E1B0;
// 806E1B4: using guessed type int dword_806E1B4;
// 806E1D8: using guessed type int dword_806E1D8;
// 806E214: using guessed type int dword_806E214;
// 806E218: using guessed type int dword_806E218;
// 806E228: using guessed type int dword_806E228;
// 806E22C: using guessed type int dword_806E22C;
// 806E23C: using guessed type int dword_806E23C;
// 806E250: using guessed type int dword_806E250;
// 806E278: using guessed type int dword_806E278;
// 806E27C: using guessed type int dword_806E27C;
// 806EAE1: using guessed type int dword_806EAE1;

//----- (0806741E) --------------------------------------------------------
const char *__usercall sub_806741E@<eax>(signed __int32 a1@<ebx>)
{
  int v1; // ecx
  signed __int32 v2; // ebx
  signed __int32 v3; // edx
  signed __int32 v4; // edx
  signed __int32 v5; // ebx
  signed __int32 v6; // et0
  int v7; // ecx
  signed __int32 v8; // ecx
  signed __int32 v9; // et1
  size_t v10; // eax
  signed __int32 v11; // edx
  signed __int32 v12; // eax
  signed __int32 v13; // eax
  int v14; // ecx
  signed __int32 v15; // ebx
  signed __int32 v16; // edx
  signed __int32 v17; // edx
  signed __int32 v18; // ett
  char *v19; // ST24_4
  int v20; // ecx
  void *v21; // eax
  const char *s1; // [esp+18h] [ebp-10h]
  char *s2; // [esp+1Ch] [ebp-Ch]

  s1 = nl_langinfo(14);
  if ( !s1 )
    s1 = (const char *)&unk_8069EA3;
  s2 = (char *)sub_8066DC7(v1, a1);
  dword_806E228 = (int)&loc_8067519;
  v2 = _InterlockedExchange(&dword_806E22C, a1);
  v6 = _InterlockedExchange(&dword_806E22C, v3);
  v4 = v2;
  v5 = v6;
  _InterlockedExchange(&dword_806E22C, v4);
  v9 = _InterlockedExchange(&dword_806E22C, sub_8067E53(v7));
  _InterlockedExchange(&dword_806E22C, v8);
  _InterlockedExchange(&dword_806E22C, v9);
  do
  {
    if ( !strcmp(s1, s2) || *s2 == 42 && !s2[1] )
    {
      v10 = strlen(s2);
      v11 = v10 + 1;
      v12 = (signed __int32)&s2[v10 + 1];
      s1 = (const char *)v12;
      dword_806E1C4 = (int)&loc_8067527;
      v13 = _InterlockedExchange(&dword_806E1C8, v12);
      _InterlockedExchange(&dword_806E1C8, v11);
      _InterlockedExchange(&dword_806E1C8, v13);
      sub_806812D(v14);
      v15 = _InterlockedExchange(&dword_806E1C8, v5);
      v18 = _InterlockedExchange(&dword_806E1C8, v16);
      v17 = v15;
      v5 = v18;
      _InterlockedExchange(&dword_806E1C8, v17);
    }
    v19 = &s2[strlen(s2) + 1];
    s2 = &v19[strlen(v19) + 1];
  }
  while ( *s2 );
  v21 = &loc_806754A;
  if ( *s1 )
    v21 = &loc_8067551;
  dword_806E124 = (int)v21;
  sub_8068556(v20);
  return "ASCII";
}
// 8067E53: using guessed type int __fastcall sub_8067E53(_DWORD);
// 806812D: using guessed type int __fastcall sub_806812D(_DWORD);
// 8068556: using guessed type int __fastcall sub_8068556(_DWORD);
// 806E124: using guessed type int dword_806E124;
// 806E1C4: using guessed type int dword_806E1C4;
// 806E1C8: using guessed type int dword_806E1C8;
// 806E228: using guessed type int dword_806E228;
// 806E22C: using guessed type int dword_806E22C;

//----- (0806789C) --------------------------------------------------------
int __usercall sub_806789C@<eax>(signed __int32 a1@<edx>, int a2@<ecx>, signed __int32 a3@<ebx>, int a4)
{
  signed __int32 v4; // ebx
  signed __int32 v5; // et0
  signed __int32 v6; // ebx
  signed __int32 v7; // ecx

  if ( (unsigned int)(a4 - 65) <= 0x19 )
  {
    dword_806E14C = (int)&loc_80678EA;
    v4 = _InterlockedExchange(&dword_806E150, a3);
    v5 = _InterlockedExchange(&dword_806E150, a1);
    sub_806844C(a2, _InterlockedExchange(&dword_806E150, v4));
    v6 = _InterlockedExchange(&dword_806E150, v5);
    _InterlockedExchange(&dword_806E150, v7);
    _InterlockedExchange(&dword_806E150, v6);
  }
  return a4;
}
// 806844C: using guessed type int __fastcall sub_806844C(_DWORD, _DWORD);
// 806E14C: using guessed type int dword_806E14C;
// 806E150: using guessed type int dword_806E150;

//----- (08067909) --------------------------------------------------------
int __usercall sub_8067909@<eax>(signed __int32 a1@<ebx>, unsigned __int64 a2, __int64 a3)
{
  int v3; // ecx
  int result; // eax
  int v5; // ebp
  int v6; // ebp
  signed __int32 v7; // ecx
  signed __int32 v8; // ebx
  signed __int32 v9; // ebx
  signed __int32 v10; // edx
  unsigned __int64 v11; // rax
  unsigned int v12; // edi
  unsigned __int64 v13; // rax
  unsigned int v14; // ecx
  unsigned int v15; // [esp+4h] [ebp-1Ch]
  __int64 v16; // [esp+8h] [ebp-18h]
  unsigned int v17; // [esp+Ch] [ebp-14h]

  v3 = a2;
  LODWORD(v16) = a2;
  if ( !HIDWORD(a3) )
  {
    if ( (unsigned int)a3 > HIDWORD(a2) )
      return a2 % (unsigned int)a3;
    dword_806E1EC = (int)&loc_8067944;
    v7 = _InterlockedExchange(&dword_806E1F0, a1);
    v8 = _InterlockedExchange(&dword_806E1F0, a2);
    sub_806800D(_InterlockedExchange(&dword_806E1F0, v7));
    v9 = _InterlockedExchange(&dword_806E1F0, v8);
    _InterlockedExchange(&dword_806E1F0, v10);
    _InterlockedExchange(&dword_806E1F0, v9);
    return v3;
  }
  if ( HIDWORD(a3) > HIDWORD(a2) )
    return v3;
  _BitScanReverse((unsigned int *)&v5, HIDWORD(a3));
  v6 = v5 ^ 0x1F;
  if ( v6 )
  {
    v15 = (HIDWORD(a3) << v6) | ((unsigned int)a3 >> (32 - v6));
    HIDWORD(v11) = HIDWORD(a2) >> (32 - v6);
    LODWORD(v11) = (HIDWORD(a2) << v6) | ((unsigned int)a2 >> (32 - v6));
    v17 = (_DWORD)a2 << v6;
    v12 = v11 % v15;
    v13 = (unsigned int)((_DWORD)a3 << v6) * (unsigned __int64)(unsigned int)(v11 / v15);
    v14 = v13;
    if ( v12 < HIDWORD(v13) || v17 < (unsigned int)v13 && v12 == HIDWORD(v13) )
    {
      HIDWORD(v13) = (v13 - __PAIR__(v15, (_DWORD)a3 << v6)) >> 32;
      v14 = v13 - ((_DWORD)a3 << v6);
    }
    result = ((__PAIR__(v12, v17) - __PAIR__(HIDWORD(v13), v14)) >> 32 << (32 - (unsigned __int8)v6)) | ((v17 - v14) >> v6);
  }
  else
  {
    if ( (unsigned int)a3 <= (unsigned int)a2 || HIDWORD(a3) < HIDWORD(a2) )
      LODWORD(v16) = a2 - a3;
    result = v16;
  }
  return result;
}
// 806800D: using guessed type int __fastcall sub_806800D(_DWORD);
// 806E1EC: using guessed type int dword_806E1EC;
// 806E1F0: using guessed type int dword_806E1F0;

//----- (08067AEC) --------------------------------------------------------
#error "8067B25: positive sp value has been found (funcsize=18)"

//----- (08067B3B) --------------------------------------------------------
int __cdecl sub_8067B3B(int a1)
{
  return __cxa_atexit(a1, 0, dword_806E29C);
}
// 8048E80: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 806E29C: using guessed type int dword_806E29C;

//----- (08067BF4) --------------------------------------------------------
#error "8067C2D: positive sp value has been found (funcsize=18)"

//----- (08067C35) --------------------------------------------------------
#error "8067C3B: positive sp value has been found (funcsize=0)"

//----- (08067CB2) --------------------------------------------------------
#error "8067CB8: positive sp value has been found (funcsize=0)"

//----- (08067D53) --------------------------------------------------------
#error "8067D59: positive sp value has been found (funcsize=0)"

//----- (08067DD8) --------------------------------------------------------
#error "8067DDE: positive sp value has been found (funcsize=0)"

//----- (08067E53) --------------------------------------------------------
#error "8067E59: positive sp value has been found (funcsize=0)"

//----- (08067ECF) --------------------------------------------------------
#error "8067ED5: positive sp value has been found (funcsize=0)"

//----- (08067F6F) --------------------------------------------------------
#error "8067F75: positive sp value has been found (funcsize=0)"

//----- (08067FCC) --------------------------------------------------------
#error "8068005: positive sp value has been found (funcsize=18)"

//----- (0806800D) --------------------------------------------------------
#error "8068013: positive sp value has been found (funcsize=0)"

//----- (0806808A) --------------------------------------------------------
#error "8068090: positive sp value has been found (funcsize=0)"

//----- (0806812D) --------------------------------------------------------
#error "8068133: positive sp value has been found (funcsize=0)"

//----- (080681B2) --------------------------------------------------------
#error "80681B8: positive sp value has been found (funcsize=0)"

//----- (08068230) --------------------------------------------------------
#error "8068236: positive sp value has been found (funcsize=0)"

//----- (080682B5) --------------------------------------------------------
#error "80682BB: positive sp value has been found (funcsize=0)"

//----- (0806833F) --------------------------------------------------------
#error "8068345: positive sp value has been found (funcsize=0)"

//----- (080683C2) --------------------------------------------------------
#error "80683C8: positive sp value has been found (funcsize=0)"

//----- (0806844C) --------------------------------------------------------
#error "8068452: positive sp value has been found (funcsize=0)"

//----- (080684CC) --------------------------------------------------------
#error "80684D2: positive sp value has been found (funcsize=0)"

//----- (08068556) --------------------------------------------------------
#error "806855C: positive sp value has been found (funcsize=0)"

//----- (080685D2) --------------------------------------------------------
#error "80685D8: positive sp value has been found (funcsize=0)"

//----- (08068600) --------------------------------------------------------
int (**sub_8068600())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_806DEB4;
  v1 = &off_806DEB8 - off_806DEB4;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_806DEB4[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 806DEB4: using guessed type int (*off_806DEB4[2])();
// 806DEB8: using guessed type int (*off_806DEB8)();

//----- (08068664) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 26 decompilation failure(s) on 183 function(s)"
