/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8048CF0();
// int strcmp(const char *s1, const char *s2);
// int __cdecl open64(_DWORD, _DWORD); weak
// int __cdecl getline(_DWORD, _DWORD, _DWORD); weak
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void _exit(int status);
// void free(void *ptr);
// void *memcpy(void *dest, const void *src, size_t n);
// int tolower(int c);
// int fclose(FILE *stream);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// char *textdomain(const char *domainname);
// int __cdecl fopen64(_DWORD, _DWORD); weak
// int ferror_unlocked(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// size_t __ctype_get_mb_cur_max(void);
// size_t __fpending(FILE *fp);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// void error(int status, int errnum, const char *format, ...);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// char *strchr(const char *s, int c);
// size_t strlen(const char *s);
// int fprintf(FILE *stream, const char *format, ...);
// int fcntl(int fd, int cmd, ...);
// int setvbuf(FILE *stream, char *buf, int modes, size_t n);
// void *memset(void *s, int c, size_t n);
// int *__errno_location(void);
// int fileno(FILE *stream);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// char *strrchr(const char *s, int c);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// char *bindtextdomain(const char *domainname, const char *dirname);
// int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// int feof_unlocked(FILE *stream);
// void abort(void);
// int close(int fd);
// const unsigned __int16 **__ctype_b_loc(void);
// int putchar_unlocked(int c);
// int _gmon_start__(void); weak
void sub_8049123();
void sub_8049140();
int sub_8049150();
int sub_80491C0();
int sub_80491E0();
void sub_804923F();
void sub_804925A();
int sub_804926A();
void sub_804934C();
void sub_8049367();
int sub_8049377();
void sub_8049459();
void sub_8049474();
int sub_8049484();
void sub_8049597();
void sub_80495B2();
int sub_80495C2();
void sub_80496A4();
void sub_80496BF();
int sub_80496CF();
// int __usercall sub_8049781@<eax>(void (__cdecl *a1)(signed int)@<eax>);
void sub_80497CD();
void sub_80497E8();
int sub_80497F8();
void sub_80498DA();
void sub_80498F5();
int __fastcall sub_8049905(int a1);
void sub_8049A00();
void sub_8049A1B();
int sub_8049A2B();
void sub_8049B3E();
void sub_8049B59();
int sub_8049B69();
int nullsub_3(void); // weak
int sub_8049BC7();
void sub_8049C99();
void sub_8049CB4();
int sub_8049CC4();
void sub_8049DA6();
void sub_8049DC1();
int sub_8049DD1();
void sub_8049EB3();
void sub_8049ECE();
int sub_8049EDE();
int nullsub_4(); // weak
// int __usercall sub_8049F3C@<eax>(int a1@<ecx>, int a2@<ebp>);
void sub_804A025();
void sub_804A040();
int sub_804A050();
int nullsub_5(void); // weak
// int __usercall sub_804A10A@<eax>(void (__cdecl *a1)(void **)@<eax>);
void sub_804A156();
void sub_804A171();
int sub_804A181();
// int __usercall sub_804A233@<eax>(void (__cdecl *a1)(signed int)@<eax>);
int __cdecl sub_804A24D(int a1, unsigned int a2);
unsigned int __cdecl sub_804A293(int a1, unsigned int a2);
int sub_804A2C5();
int __cdecl sub_804A2F0(char *s1); // idb
int __cdecl sub_804A4DC(int a1);
void __cdecl __noreturn sub_804A4E4(int status); // idb
// signed __int32 __usercall sub_804A69D@<eax>(signed __int32 a1@<edx>, int a2@<ecx>, signed __int32 a3, unsigned int a4);
bool __cdecl sub_804A797(_BYTE *a1);
// int __usercall sub_804A7F7@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, int a3, int a4);
// int __usercall sub_804A9E6@<eax>(signed __int32 a1@<ebx>, signed __int32 a2, int a3, _BYTE **a4, _DWORD *a5);
// int __usercall sub_804AC95@<eax>(int a1@<edx>, int a2@<ecx>, _BYTE *a3, char a4);
// int __usercall sub_804ADC2@<eax>(_BYTE *a1@<ebx>, char *s1, int a3, int a4, int a5);
// int __usercall __noreturn sub_804B073@<eax>(signed __int32 a1@<ebx>, const char *a2);
int sub_804BB5F(); // weak
// int __usercall main@<eax>(signed __int32 a1@<ebx>, int argc, char **a3);
int sub_804C4F1();
_DWORD *__cdecl sub_804C5D5(_DWORD *a1);
_DWORD *__cdecl sub_804C68E(_DWORD *a1);
int __cdecl sub_804C747(_DWORD *a1, int a2, int a3);
int __cdecl sub_804C769(int a1, int a2);
int __cdecl sub_804C99C(int a1, int a2);
int __cdecl sub_804CBCF(int a1);
int __cdecl sub_804D350(int a1, int a2);
int __cdecl sub_804D375(int a1, int a2);
// int __usercall sub_804D39A@<eax>(signed __int32 a1@<ebx>, FILE *stream, int a3);
int __cdecl sub_804D8CC(void *src, size_t, int); // idb
_DWORD __cdecl sub_804DB23(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_8062358(int a1, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_80623A9@<eax>(int a1@<edx>, int a2@<ecx>, FILE *stream, int a4);
// FILE *__usercall sub_806240A@<eax>(signed __int32 a1@<ebx>, int a2, char *modes);
char *__cdecl sub_80624F5(char *s);
int __cdecl sub_80626B1(int *a1, unsigned __int8 a2, char a3);
int *__cdecl sub_80627B2(int *a1, int a2, int a3);
// _DWORD *__userpurge sub_8062866@<eax>(_DWORD *a1, int a2);
// const char *__usercall sub_80628E8@<eax>(signed __int32 a1@<ebx>, char *msgid, int a3);
// int __usercall sub_8062A96@<eax>(unsigned __int32 a1@<ebx>, _BYTE *a2, unsigned __int32 a3, const char *a4, size_t a5, signed int a6, int a7, int a8, const char *a9, const char *a10);
int sub_8063B71(); // weak
_BYTE *__cdecl sub_8063C2E(const char *a1, size_t a2, _DWORD *a3, int a4);
_BYTE *__cdecl sub_8063DEE(signed int a1, const char *a2, size_t a3, int a4);
_BYTE *__cdecl sub_8064103(signed int a1, const char *a2);
_BYTE *__cdecl sub_806412D(signed int a1, const char *a2, size_t a3);
_BYTE *__cdecl sub_8064193(signed int a1, int a2, const char *a3);
// int __usercall sub_80641D1@<eax>(signed __int32 a1@<ebx>, signed int a2, int a3, const char *a4, size_t a5);
_BYTE *__cdecl sub_806437E(const char *a1, size_t a2, unsigned __int8 a3);
_BYTE *__cdecl sub_8064428(const char *a1, unsigned __int8 a2);
_BYTE *__cdecl sub_8064451(const char *a1);
_BYTE *__cdecl sub_8064540(signed int a1, int a2, const char *a3);
signed __int32 __cdecl sub_8064681(signed int a1, int a2, int a3, const char *a4);
signed __int32 __cdecl sub_80646B1(signed int a1, int a2, int a3, const char *a4, size_t a5);
int sub_80647B2(); // weak
_BYTE *__cdecl sub_80647E6(signed int a1, const char *a2, size_t a3);
_BYTE *__cdecl sub_8064831(signed int a1, const char *a2);
// int __usercall sub_806486E@<eax>(signed __int32 a1@<ebx>, int fd);
int __cdecl sub_8064891(FILE *stream, int, int, int, int, int); // idb
// int __usercall sub_8064E40@<eax>(signed __int32 a1@<edx>, int a2@<ecx>, signed __int32 a3@<ebx>, FILE *stream, int a5, int a6, int a7, int a8);
// int __usercall sub_8064EDA@<eax>(signed __int32 a1@<edx>, int a2@<ecx>, signed __int32 a3@<ebx>, FILE *stream, int a5, int a6, int a7, ...);
void *__cdecl sub_8064FDD(void *ptr, int a2, int a3);
void *__cdecl sub_806515A(size_t size);
void *__cdecl sub_806516D(size_t size);
void *__cdecl sub_80651B2(void *ptr, size_t size);
void *__cdecl sub_80652BD(void *src, size_t n);
void __noreturn sub_806530B();
int __cdecl sub_8065344(FILE *stream); // idb
// int __usercall sub_8065442@<eax>(signed __int32 a1@<ebx>, int fd, int cmd, char a4);
int __cdecl sub_8065645(FILE *stream); // idb
int __cdecl sub_806567E(FILE *fp); // idb
int __cdecl sub_80656DA(FILE *stream, int, int, int); // idb
// size_t __usercall sub_80658CB@<eax>(signed __int32 a1@<ebx>, wchar_t *pwc, char *s, size_t n, mbstate_t *p);
int __cdecl sub_8065A2F(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_8065A94(FILE *fp); // idb
int __cdecl sub_8065B2E(int category); // idb
signed __int32 sub_8065B8C();
const char *sub_806618C();
int __cdecl sub_80664CE(int a1);
__int64 __cdecl sub_806650E(int a1, unsigned int a2, unsigned int a3, int a4);
int __cdecl sub_8066703(int a1);
int __fastcall sub_8066803(_DWORD); // weak
int __fastcall sub_806689B(_DWORD, _DWORD); // weak
int __fastcall sub_806691B(_DWORD); // weak
int __fastcall sub_80669A2(_DWORD, _DWORD); // weak
int __fastcall sub_8066A1E(_DWORD, _DWORD); // weak
int __fastcall sub_8066AB8(_DWORD); // weak
int __fastcall sub_8066B3F(_DWORD, _DWORD); // weak
int __fastcall sub_8066BC0(_DWORD); // weak
int __fastcall sub_8066C43(_DWORD); // weak
int __fastcall sub_8066CC6(_DWORD, _DWORD); // weak
int __fastcall sub_8066D47(_DWORD); // weak
int __fastcall sub_8066DC7(_DWORD); // weak
int (**sub_8066DF0())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN locret_8049914; // weak
_UNKNOWN loc_804A3AF; // weak
_UNKNOWN loc_804A3B8; // weak
_UNKNOWN loc_804A412; // weak
_UNKNOWN loc_804A44C; // weak
_UNKNOWN loc_804A4B7; // weak
_UNKNOWN loc_804A604; // weak
_UNKNOWN loc_804A773; // weak
_UNKNOWN loc_804A856; // weak
_UNKNOWN loc_804A893; // weak
_UNKNOWN loc_804A89D; // weak
_UNKNOWN loc_804AB78; // weak
_UNKNOWN loc_804AB91; // weak
_UNKNOWN loc_804ABCF; // weak
_UNKNOWN loc_804ABD9; // weak
_UNKNOWN loc_804AC8F; // weak
_UNKNOWN loc_804ACF9; // weak
_UNKNOWN loc_804AD1A; // weak
_UNKNOWN loc_804AEF7; // weak
_UNKNOWN loc_804AFA7; // weak
_UNKNOWN loc_804AFB2; // weak
_UNKNOWN loc_804B012; // weak
_UNKNOWN loc_804B068; // weak
_UNKNOWN loc_804B06D; // weak
_UNKNOWN loc_804B236; // weak
_UNKNOWN loc_804B27E; // weak
_UNKNOWN loc_804B2C8; // weak
_UNKNOWN loc_804B386; // weak
_UNKNOWN loc_804B437; // weak
_UNKNOWN loc_804B4FF; // weak
_UNKNOWN loc_804B50B; // weak
_UNKNOWN loc_804B569; // weak
_UNKNOWN loc_804B579; // weak
_UNKNOWN loc_804B637; // weak
_UNKNOWN loc_804B650; // weak
_UNKNOWN loc_804B6BF; // weak
_UNKNOWN loc_804B6CB; // weak
_UNKNOWN loc_804B737; // weak
_UNKNOWN loc_804B755; // weak
_UNKNOWN loc_804B77D; // weak
_UNKNOWN loc_804B7B6; // weak
_UNKNOWN loc_804B808; // weak
_UNKNOWN loc_804BB35; // weak
_UNKNOWN loc_804BB5A; // weak
_UNKNOWN loc_804BC6D; // weak
_UNKNOWN loc_804BE90; // weak
_UNKNOWN loc_804BEDF; // weak
_UNKNOWN loc_804BF13; // weak
_UNKNOWN loc_804BF4A; // weak
_UNKNOWN loc_804C397; // weak
_UNKNOWN loc_804C3EB; // weak
_UNKNOWN loc_804C408; // weak
_UNKNOWN loc_804C4B3; // weak
_UNKNOWN locret_804D5CC; // weak
_UNKNOWN loc_804D7C7; // weak
_UNKNOWN loc_80623CE; // weak
_UNKNOWN locret_8062408; // weak
_UNKNOWN loc_8062466; // weak
_UNKNOWN loc_80624F0; // weak
_UNKNOWN loc_8062560; // weak
_UNKNOWN loc_8062568; // weak
_UNKNOWN loc_80627E6; // weak
_UNKNOWN loc_8062815; // weak
_UNKNOWN loc_806299C; // weak
_UNKNOWN loc_80629B9; // weak
_UNKNOWN loc_80629BE; // weak
_UNKNOWN loc_80629E2; // weak
_UNKNOWN locret_8062A94; // weak
_UNKNOWN loc_8062D31; // weak
_UNKNOWN loc_8063325; // weak
_UNKNOWN loc_8063353; // weak
_UNKNOWN loc_806351C; // weak
_UNKNOWN loc_80635BA; // weak
_UNKNOWN loc_8063603; // weak
_UNKNOWN loc_80636BF; // weak
_UNKNOWN loc_80636DA; // weak
_UNKNOWN loc_8063790; // weak
_UNKNOWN loc_806386E; // weak
_UNKNOWN loc_80638FD; // weak
_UNKNOWN loc_806390F; // weak
_UNKNOWN loc_8063945; // weak
_UNKNOWN loc_8063950; // weak
_UNKNOWN loc_806396F; // weak
_UNKNOWN loc_8063A40; // weak
_UNKNOWN loc_8063AEB; // weak
_UNKNOWN loc_8063B47; // weak
_UNKNOWN loc_8063B6C; // weak
_UNKNOWN loc_8063C54; // weak
_UNKNOWN loc_8063C59; // weak
_UNKNOWN loc_8063E1B; // weak
_UNKNOWN loc_8063EC3; // weak
_UNKNOWN loc_8063F49; // weak
_UNKNOWN loc_8063F5C; // weak
_UNKNOWN loc_8064073; // weak
_UNKNOWN loc_806407E; // weak
_UNKNOWN locret_8064292; // weak
_UNKNOWN loc_80648B9; // weak
_UNKNOWN loc_80648E3; // weak
_UNKNOWN loc_8064DE0; // weak
_UNKNOWN loc_8064E87; // weak
_UNKNOWN locret_8065232; // weak
_UNKNOWN loc_80653AE; // weak
_UNKNOWN loc_806543D; // weak
_UNKNOWN loc_80654C5; // weak
_UNKNOWN loc_80654D1; // weak
_UNKNOWN loc_80655CB; // weak
_UNKNOWN loc_8065640; // weak
_UNKNOWN loc_8065737; // weak
_UNKNOWN loc_80658A9; // weak
_UNKNOWN loc_8065A2A; // weak
_UNKNOWN locret_8065A2D; // weak
_UNKNOWN loc_8065AF2; // weak
_UNKNOWN loc_8065B0A; // weak
_UNKNOWN loc_8065C2C; // weak
_UNKNOWN loc_8065C47; // weak
_UNKNOWN loc_8065CFA; // weak
_UNKNOWN loc_8065DF7; // weak
_UNKNOWN loc_8065E14; // weak
_UNKNOWN loc_80660D5; // weak
_UNKNOWN loc_8066558; // weak
_UNKNOWN loc_806656F; // weak
char locale = '\0'; // idb
struct option longopts = { "binary", 0, NULL, 98 }; // idb
char byte_8067ACD[16] =
{
  '0',
  '1',
  '2',
  '3',
  '4',
  '5',
  '6',
  '7',
  '8',
  '9',
  'a',
  'b',
  'c',
  'd',
  'e',
  'f'
}; // idb
_UNKNOWN unk_8067AF8; // weak
_UNKNOWN unk_8067F26; // weak
_UNKNOWN unk_8067F2A; // weak
_UNKNOWN unk_8067F36; // weak
_UNKNOWN unk_8067F3A; // weak
_UNKNOWN unk_8067F3D; // weak
void *off_8067F70 = &loc_8062DEC; // weak
void *off_80684CC[10] =
{
  &loc_8064963,
  &loc_8064968,
  &loc_8064991,
  &loc_80649C6,
  &loc_8064A07,
  &loc_8064A8B,
  &loc_8064AF0,
  &loc_8064B67,
  &loc_8064BF0,
  &loc_8064C8B
}; // weak
_UNKNOWN unk_806865B; // weak
_UNKNOWN unk_80691B4; // weak
_UNKNOWN unk_80691B7; // weak
_UNKNOWN unk_806A204; // weak
_UNKNOWN unk_806A207; // weak
int (*off_806BED0[2])() = { &sub_80491E0, &sub_80491C0 }; // weak
int (*off_806BED4)() = &sub_80491C0; // weak
int (*dword_806C008)(void) = NULL; // weak
int dword_806C110 = 0; // weak
int dword_806C114 = 0; // weak
int dword_806C124 = 0; // weak
int dword_806C128 = 0; // weak
int dword_806C138 = 0; // weak
int dword_806C13C = 0; // weak
int dword_806C14C = 0; // weak
int dword_806C150 = 0; // weak
int dword_806C160 = 0; // weak
int dword_806C164 = 0; // weak
int dword_806C174 = 0; // weak
int dword_806C178 = 0; // weak
int dword_806C188 = 0; // weak
int dword_806C18C = 0; // weak
int dword_806C19C = 0; // weak
int dword_806C1A0 = 0; // weak
int dword_806C1B0 = 0; // weak
int dword_806C1B4 = 0; // weak
int dword_806C1C4 = 0; // weak
int dword_806C1C8 = 0; // weak
int dword_806C1D8 = 0; // weak
int dword_806C1DC = 0; // weak
int dword_806C1EC = 0; // weak
int dword_806C1F0 = 0; // weak
int dword_806C1FC = 0; // weak
int dword_806C210 = 0; // weak
int off_806C218 = 134642397; // idb
int status = 1; // idb
int dword_806C22C = 1; // weak
int dword_806C230 = 256; // weak
void *off_806C234 = &unk_806C73E; // weak
int *off_806C238 = &dword_806C230; // weak
_UNKNOWN unk_806C24C; // weak
_UNKNOWN unk_806C268; // weak
_UNKNOWN unk_806C26B; // weak
_UNKNOWN unk_806C27C; // weak
_UNKNOWN unk_806C27F; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int program_invocation_name; // weak
int optind; // weak
FILE *stdin; // idb
FILE *stdout; // idb
char byte_806C2C8; // weak
_UNKNOWN unk_806C35E; // weak
_UNKNOWN unk_806C5A6; // weak
_UNKNOWN unk_806C638; // weak
_UNKNOWN unk_806C648; // weak
char byte_806C6CA; // weak
int dword_806C6CE; // weak
int dword_806C6D2; // weak
char byte_806C6D6; // weak
char byte_806C6D7; // weak
char byte_806C6D8; // weak
char byte_806C6D9; // weak
char byte_806C6DA; // weak
int dword_806C6DE; // weak
char byte_806C6E2; // weak
int dword_806C6E6; // weak
int dword_806C6FE; // weak
int dword_806C702; // weak
int dword_806C706; // weak
int dword_806C70A; // weak
int dword_806C70E; // weak
int dword_806C712; // weak
int dword_806C716; // weak
int dword_806C71A; // weak
int dword_806C71E; // weak
int dword_806C722; // weak
int dword_806C726; // weak
int dword_806C72A; // weak
_UNKNOWN unk_806C73E; // weak
int dword_806C83E; // weak
int dword_806C842; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (08048CCC) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 80490E0: using guessed type int _gmon_start__(void);

//----- (08048CF0) --------------------------------------------------------
int sub_8048CF0()
{
  return dword_806C008();
}
// 806C008: using guessed type int (*dword_806C008)(void);

//----- (080490F0) --------------------------------------------------------
#error "80490F3: positive sp value has been found (funcsize=2)"

//----- (08049123) --------------------------------------------------------
void sub_8049123()
{
  ;
}

//----- (08049140) --------------------------------------------------------
void sub_8049140()
{
  ;
}

//----- (08049150) --------------------------------------------------------
int sub_8049150()
{
  int result; // eax

  result = &unk_806C27F - &unk_806C27C;
  if ( (unsigned int)(&unk_806C27F - &unk_806C27C) > 6 )
    result = 0;
  return result;
}
// 8049150: could not find valid save-restore pair for ebp

//----- (080491C0) --------------------------------------------------------
int sub_80491C0()
{
  int result; // eax

  if ( !byte_806C2C8 )
  {
    result = sub_8049150();
    byte_806C2C8 = 1;
  }
  return result;
}
// 80491C0: could not find valid save-restore pair for ebp
// 806C2C8: using guessed type char byte_806C2C8;

//----- (080491E0) --------------------------------------------------------
int sub_80491E0()
{
  return 0;
}
// 80491E0: could not find valid save-restore pair for ebp

//----- (0804923F) --------------------------------------------------------
void sub_804923F()
{
  ;
}

//----- (0804925A) --------------------------------------------------------
void sub_804925A()
{
  ;
}

//----- (0804926A) --------------------------------------------------------
int sub_804926A()
{
  int result; // eax

  result = &unk_806C26B - &unk_806C268;
  if ( (unsigned int)(&unk_806C26B - &unk_806C268) > 6 )
    result = 0;
  return result;
}
// 804926A: could not find valid save-restore pair for ebp

//----- (0804934C) --------------------------------------------------------
void sub_804934C()
{
  ;
}

//----- (08049367) --------------------------------------------------------
void sub_8049367()
{
  ;
}

//----- (08049377) --------------------------------------------------------
int sub_8049377()
{
  int result; // eax

  result = &unk_806C26B - &unk_806C268;
  if ( (unsigned int)(&unk_806C26B - &unk_806C268) > 6 )
    result = 0;
  return result;
}
// 8049377: could not find valid save-restore pair for ebp

//----- (08049459) --------------------------------------------------------
void sub_8049459()
{
  ;
}

//----- (08049474) --------------------------------------------------------
void sub_8049474()
{
  ;
}

//----- (08049484) --------------------------------------------------------
int sub_8049484()
{
  int result; // eax

  result = &unk_806C35E - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_806C35E - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 8049484: could not find valid save-restore pair for ebp
// 806C280: using guessed type int program_invocation_short_name;

//----- (08049597) --------------------------------------------------------
void sub_8049597()
{
  ;
}

//----- (080495B2) --------------------------------------------------------
void sub_80495B2()
{
  ;
}

//----- (080495C2) --------------------------------------------------------
int sub_80495C2()
{
  int result; // eax

  result = &unk_806C26B - &unk_806C268;
  if ( (unsigned int)(&unk_806C26B - &unk_806C268) > 6 )
    result = 0;
  return result;
}
// 80495C2: could not find valid save-restore pair for ebp

//----- (080496A4) --------------------------------------------------------
void sub_80496A4()
{
  ;
}

//----- (080496BF) --------------------------------------------------------
void sub_80496BF()
{
  ;
}

//----- (080496CF) --------------------------------------------------------
int sub_80496CF()
{
  int result; // eax

  result = &unk_806C26B - &unk_806C268;
  if ( (unsigned int)(&unk_806C26B - &unk_806C268) > 6 )
    result = 0;
  return result;
}
// 80496CF: could not find valid save-restore pair for ebp

//----- (08049781) --------------------------------------------------------
int __usercall sub_8049781@<eax>(void (__cdecl *a1)(signed int)@<eax>)
{
  a1(134655724);
  return 0;
}

//----- (080497CD) --------------------------------------------------------
void sub_80497CD()
{
  ;
}

//----- (080497E8) --------------------------------------------------------
void sub_80497E8()
{
  ;
}

//----- (080497F8) --------------------------------------------------------
int sub_80497F8()
{
  int result; // eax

  result = &unk_806A207 - &unk_806A204;
  if ( (unsigned int)(&unk_806A207 - &unk_806A204) > 6 )
    result = 0;
  return result;
}
// 80497F8: could not find valid save-restore pair for ebp

//----- (080498DA) --------------------------------------------------------
void sub_80498DA()
{
  ;
}

//----- (080498F5) --------------------------------------------------------
void sub_80498F5()
{
  ;
}

//----- (08049905) --------------------------------------------------------
int __fastcall sub_8049905(int a1)
{
  int result; // eax
  int (__stdcall *v2)(void *, int, int, int, int, int); // eax
  int v3; // [esp+4h] [ebp-18h]
  int v4; // [esp+8h] [ebp-14h]
  int v5; // [esp+Ch] [ebp-10h]
  int v6; // [esp+10h] [ebp-Ch]
  int v7; // [esp+14h] [ebp-8h]
  int v8; // [esp+18h] [ebp-4h]

  result = &unk_806C26B - &unk_806C268;
  if ( (unsigned int)(&unk_806C26B - &unk_806C268) > 6 )
  {
    v8 = 0;
    dword_806C110 = (int)&locret_8049914;
    v2 = (int (__stdcall *)(void *, int, int, int, int, int))sub_8066DC7(a1);
    result = v2(&unk_806C268, v3, v4, v5, v6, v7);
  }
  return result;
}
// 8066DC7: using guessed type int __fastcall sub_8066DC7(_DWORD);
// 806C110: using guessed type int dword_806C110;

//----- (08049A00) --------------------------------------------------------
void sub_8049A00()
{
  ;
}

//----- (08049A1B) --------------------------------------------------------
void sub_8049A1B()
{
  ;
}

//----- (08049A2B) --------------------------------------------------------
int sub_8049A2B()
{
  int result; // eax

  result = &unk_806C26B - &unk_806C268;
  if ( (unsigned int)(&unk_806C26B - &unk_806C268) > 6 )
    result = 0;
  return result;
}
// 8049A2B: could not find valid save-restore pair for ebp

//----- (08049B3E) --------------------------------------------------------
void sub_8049B3E()
{
  ;
}

//----- (08049B59) --------------------------------------------------------
void sub_8049B59()
{
  ;
}

//----- (08049B69) --------------------------------------------------------
int sub_8049B69()
{
  int result; // eax

  result = &unk_806C26B - &unk_806C268;
  if ( (unsigned int)(&unk_806C26B - &unk_806C268) > 6 )
    result = 0;
  return result;
}
// 8049B69: could not find valid save-restore pair for ebp

//----- (08049BC7) --------------------------------------------------------
int sub_8049BC7()
{
  return nullsub_3();
}
// 8049BC7: could not find valid save-restore pair for ebp
// 8049BC6: using guessed type int nullsub_3(void);

//----- (08049C99) --------------------------------------------------------
void sub_8049C99()
{
  ;
}

//----- (08049CB4) --------------------------------------------------------
void sub_8049CB4()
{
  ;
}

//----- (08049CC4) --------------------------------------------------------
int sub_8049CC4()
{
  int result; // eax

  result = &unk_80691B7 - &unk_80691B4;
  if ( (unsigned int)(&unk_80691B7 - &unk_80691B4) > 6 )
    result = 0;
  return result;
}
// 8049CC4: could not find valid save-restore pair for ebp

//----- (08049DA6) --------------------------------------------------------
void sub_8049DA6()
{
  ;
}

//----- (08049DC1) --------------------------------------------------------
void sub_8049DC1()
{
  ;
}

//----- (08049DD1) --------------------------------------------------------
int sub_8049DD1()
{
  int result; // eax

  result = &unk_806C5A6 - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_806C5A6 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 8049DD1: could not find valid save-restore pair for ebp
// 806C280: using guessed type int program_invocation_short_name;

//----- (08049EB3) --------------------------------------------------------
void sub_8049EB3()
{
  ;
}

//----- (08049ECE) --------------------------------------------------------
void sub_8049ECE()
{
  ;
}

//----- (08049EDE) --------------------------------------------------------
int sub_8049EDE()
{
  int result; // eax

  result = &unk_806C26B - &unk_806C268;
  if ( (unsigned int)(&unk_806C26B - &unk_806C268) > 6 )
    result = 0;
  return result;
}
// 8049EDE: could not find valid save-restore pair for ebp

//----- (08049F3C) --------------------------------------------------------
int __usercall sub_8049F3C@<eax>(int a1@<ecx>, int a2@<ebp>)
{
  int v2; // eax
  int (__cdecl *v3)(void *, int); // edx
  int v5; // [esp+18h] [ebp-4h]

  dword_806C138 = (int)nullsub_4;
  v2 = sub_8066CC6(a1, 0);
  v5 = a2;
  return v3(&unk_806C268, v2);
}
// 8049F3C: could not find valid save-restore pair for ebp
// 8049F3B: using guessed type int nullsub_4();
// 8066CC6: using guessed type int __fastcall sub_8066CC6(_DWORD, _DWORD);
// 806C138: using guessed type int dword_806C138;

//----- (0804A025) --------------------------------------------------------
void sub_804A025()
{
  ;
}

//----- (0804A040) --------------------------------------------------------
void sub_804A040()
{
  ;
}

//----- (0804A050) --------------------------------------------------------
int sub_804A050()
{
  int result; // eax

  result = &unk_806C638 - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_806C638 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 804A050: could not find valid save-restore pair for ebp
// 806C280: using guessed type int program_invocation_short_name;

//----- (0804A10A) --------------------------------------------------------
int __usercall sub_804A10A@<eax>(void (__cdecl *a1)(void **)@<eax>)
{
  a1(off_80684CC);
  return nullsub_5();
}
// 804A07C: using guessed type int nullsub_5(void);
// 80684CC: using guessed type void *off_80684CC[10];

//----- (0804A156) --------------------------------------------------------
void sub_804A156()
{
  ;
}

//----- (0804A171) --------------------------------------------------------
void sub_804A171()
{
  ;
}

//----- (0804A181) --------------------------------------------------------
int sub_804A181()
{
  int result; // eax

  result = &unk_806C648 - (_UNKNOWN *)&program_invocation_name;
  if ( (unsigned int)(&unk_806C648 - (_UNKNOWN *)&program_invocation_name) > 6 )
    result = 0;
  return result;
}
// 804A181: could not find valid save-restore pair for ebp
// 806C290: using guessed type int program_invocation_name;

//----- (0804A233) --------------------------------------------------------
int __usercall sub_804A233@<eax>(void (__cdecl *a1)(signed int)@<eax>)
{
  a1(134644944);
  return 0;
}

//----- (0804A24D) --------------------------------------------------------
int __cdecl sub_804A24D(int a1, unsigned int a2)
{
  int result; // eax

  if ( a2 )
    result = (unsigned __int64)sub_806650E(a1, a2, 0xF4240u, 0) + 1000000;
  else
    result = a1;
  return result;
}

//----- (0804A293) --------------------------------------------------------
unsigned int __cdecl sub_804A293(int a1, unsigned int a2)
{
  return a2 - 1 + a1 - (a2 - 1 + a1) % a2;
}

//----- (0804A2C5) --------------------------------------------------------
int sub_804A2C5()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nWith no FILE, or when FILE is -, read standard input.\n");
  return fputs_unlocked(v1, v0);
}
// 8048F20: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804A2F0) --------------------------------------------------------
int __cdecl sub_804A2F0(char *s1)
{
  int v1; // ecx
  void *v2; // eax
  char *v3; // eax
  char *v4; // eax
  int v5; // ecx
  bool v6; // zf
  void *v7; // eax
  char *v8; // eax
  char *v9; // eax
  signed __int32 v10; // ecx
  signed __int32 v11; // eax
  signed __int32 v12; // ebx
  signed __int32 v13; // edx
  char *v14; // eax
  char *v16; // [esp+1Ch] [ebp-4Ch]
  const char **i; // [esp+20h] [ebp-48h]
  char *v18; // [esp+24h] [ebp-44h]
  const char *v19; // [esp+28h] [ebp-40h]
  const char *v20; // [esp+2Ch] [ebp-3Ch]
  const char *v21; // [esp+30h] [ebp-38h]
  const char *v22; // [esp+34h] [ebp-34h]
  const char *v23; // [esp+38h] [ebp-30h]
  const char *v24; // [esp+3Ch] [ebp-2Ch]
  const char *v25; // [esp+40h] [ebp-28h]
  const char *v26; // [esp+44h] [ebp-24h]
  const char *v27; // [esp+48h] [ebp-20h]
  const char *v28; // [esp+4Ch] [ebp-1Ch]
  const char *v29; // [esp+50h] [ebp-18h]
  const char *v30; // [esp+54h] [ebp-14h]
  int v31; // [esp+58h] [ebp-10h]
  int v32; // [esp+5Ch] [ebp-Ch]

  v19 = "[";
  v20 = "test invocation";
  v21 = "coreutils";
  v22 = "Multi-call invocation";
  v23 = "sha224sum";
  v24 = "sha2 utilities";
  v25 = "sha256sum";
  v26 = "sha2 utilities";
  v27 = "sha384sum";
  v28 = "sha2 utilities";
  v29 = "sha512sum";
  v30 = "sha2 utilities";
  v31 = 0;
  v32 = 0;
  for ( i = &v19; *i && strcmp(s1, *i); i += 2 )
    ;
  v2 = &loc_804A3AF;
  if ( !i[1] )
    v2 = &loc_804A3B8;
  dword_806C124 = (int)v2;
  sub_8066D47(v1);
  v16 = (char *)i[1];
  v3 = gettext("\n%s online help: <%s>\n");
  printf(v3, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  v4 = setlocale(5, 0);
  v18 = v4;
  v6 = v4 == 0;
  v7 = &loc_804A412;
  if ( v6 )
    v7 = &loc_804A44C;
  dword_806C110 = (int)v7;
  sub_8066DC7(v5);
  if ( strncmp(v18, "en_", 3u) )
  {
    v8 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
    printf(v8, s1);
  }
  v9 = gettext("Full documentation at: <%s%s>\n");
  printf(v9, "http://www.gnu.org/software/coreutils/", s1);
  if ( v16 == s1 )
  {
    dword_806C1C4 = (int)&loc_804A4B7;
    v11 = _InterlockedExchange(&dword_806C1C8, (signed __int32)v16);
    _InterlockedExchange(&dword_806C1C8, v10);
    sub_806691B(_InterlockedExchange(&dword_806C1C8, v11));
    v12 = _InterlockedExchange(&dword_806C1C8, (signed __int32)" invocation");
    _InterlockedExchange(&dword_806C1C8, v13);
    _InterlockedExchange(&dword_806C1C8, v12);
  }
  v14 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  return printf(v14, v16, &locale);
}
// 806691B: using guessed type int __fastcall sub_806691B(_DWORD);
// 8066D47: using guessed type int __fastcall sub_8066D47(_DWORD);
// 8066DC7: using guessed type int __fastcall sub_8066DC7(_DWORD);
// 806C110: using guessed type int dword_806C110;
// 806C124: using guessed type int dword_806C124;
// 806C1C4: using guessed type int dword_806C1C4;
// 806C1C8: using guessed type int dword_806C1C8;

//----- (0804A4DC) --------------------------------------------------------
int __cdecl sub_804A4DC(int a1)
{
  return a1;
}

//----- (0804A4E4) --------------------------------------------------------
void __cdecl __noreturn sub_804A4E4(int status)
{
  int v1; // ebx
  char *v2; // eax
  FILE *v3; // ebx
  char *v4; // eax
  signed __int32 v5; // eax
  signed __int32 v6; // edx
  int v7; // ecx
  char *v8; // eax
  signed __int32 v9; // ebx
  signed __int32 v10; // edx
  signed __int32 v11; // edx
  int v12; // ebx
  signed __int32 v13; // et1
  FILE *v14; // ebx
  char *v15; // eax
  char *v16; // eax
  FILE *v17; // ebx
  char *v18; // eax

  if ( status )
  {
    v1 = dword_806C6E6;
    v2 = gettext("Try '%s --help' for more information.\n");
    fprintf(stderr, v2, v1);
    exit(status);
  }
  v12 = dword_806C6E6;
  v8 = gettext("Usage: %s [OPTION]... [FILE]...\nPrint or check %s (%d-bit) checksums.\n");
  while ( 1 )
  {
    printf(v8, v12, "SHA512", 512);
    sub_804A2C5();
    v14 = stdout;
    v15 = gettext("\n  -b, --binary         read in binary mode\n");
    fputs_unlocked(v15, v14);
    v16 = gettext("  -c, --check          read %s sums from the FILEs and check them\n");
    printf(v16, "SHA512");
    v17 = stdout;
    v18 = gettext("      --tag            create a BSD-style checksum\n");
    fputs_unlocked(v18, v17);
    v3 = stdout;
    v4 = gettext("  -t, --text           read in text mode (default)\n");
    dword_806C1B0 = (int)&loc_804A604;
    v5 = _InterlockedExchange(&dword_806C1B4, (signed __int32)v4);
    _InterlockedExchange(&dword_806C1B4, v6);
    v8 = (char *)sub_80669A2(v7, _InterlockedExchange(&dword_806C1B4, v5));
    v9 = _InterlockedExchange(&dword_806C1B4, (signed __int32)v3);
    v13 = _InterlockedExchange(&dword_806C1B4, v10);
    v11 = v9;
    v12 = v13;
    _InterlockedExchange(&dword_806C1B4, v11);
  }
}
// 8048F20: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 80669A2: using guessed type int __fastcall sub_80669A2(_DWORD, _DWORD);
// 806C1B0: using guessed type int dword_806C1B0;
// 806C1B4: using guessed type int dword_806C1B4;
// 806C6E6: using guessed type int dword_806C6E6;

//----- (0804A69D) --------------------------------------------------------
signed __int32 __usercall sub_804A69D@<eax>(signed __int32 a1@<edx>, int a2@<ecx>, signed __int32 a3, unsigned int a4)
{
  signed __int32 v4; // eax
  signed __int32 v5; // ecx
  signed __int32 v6; // et1
  int v8; // eax
  _BYTE *v9; // eax
  _BYTE *v10; // eax
  _BYTE *v11; // eax
  _BYTE *v12; // [esp+8h] [ebp-8h]
  unsigned int v13; // [esp+Ch] [ebp-4h]

  v12 = (_BYTE *)a3;
  v13 = 0;
  dword_806C1B0 = (int)&loc_804A773;
  v4 = _InterlockedExchange(&dword_806C1B4, a3);
  _InterlockedExchange(&dword_806C1B4, a1);
  v6 = _InterlockedExchange(&dword_806C1B4, sub_80669A2(a2, _InterlockedExchange(&dword_806C1B4, v4)));
  _InterlockedExchange(&dword_806C1B4, v5);
  _InterlockedExchange(&dword_806C1B4, v6);
  do
  {
    if ( !*(_BYTE *)(a3 + v13) )
      return 0;
    if ( *(_BYTE *)(a3 + v13) == 92 )
    {
      if ( a4 - 1 == v13 )
        return 0;
      v8 = *(char *)(a3 + ++v13);
      if ( v8 == 92 )
      {
        v10 = v12++;
        *v10 = 92;
      }
      else
      {
        if ( v8 != 110 )
          return 0;
        v9 = v12++;
        *v9 = 10;
      }
    }
    else
    {
      v11 = v12++;
      *v11 = *(_BYTE *)(a3 + v13);
    }
    ++v13;
  }
  while ( v13 < a4 );
  if ( a3 + a4 > (unsigned int)v12 )
    *v12 = 0;
  return a3;
}
// 80669A2: using guessed type int __fastcall sub_80669A2(_DWORD, _DWORD);
// 806C1B0: using guessed type int dword_806C1B0;
// 806C1B4: using guessed type int dword_806C1B4;

//----- (0804A797) --------------------------------------------------------
bool __cdecl sub_804A797(_BYTE *a1)
{
  unsigned int i; // [esp+Ch] [ebp-Ch]

  for ( i = 0; i < dword_806C6D2; ++i )
  {
    if ( !((*__ctype_b_loc())[(unsigned __int8)*a1] & 0x1000) )
      return 0;
    ++a1;
  }
  return *a1 == 0;
}
// 806C6D2: using guessed type int dword_806C6D2;

//----- (0804A7F7) --------------------------------------------------------
int __usercall sub_804A7F7@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, int a3, int a4)
{
  signed __int32 v5; // ebx
  signed __int32 v6; // ecx
  signed __int32 v7; // et1
  signed __int32 v8; // ecx
  void *v9; // eax
  int v10; // [esp+1Ch] [ebp-Ch]

  if ( !a4 )
    return 0;
  v10 = a4 - 1;
  dword_806C160 = (int)&loc_804A856;
  v5 = _InterlockedExchange(&dword_806C164, a2);
  _InterlockedExchange(&dword_806C164, a1);
  v7 = _InterlockedExchange(&dword_806C164, sub_8066BC0(_InterlockedExchange(&dword_806C164, v5)));
  _InterlockedExchange(&dword_806C164, v6);
  v8 = _InterlockedExchange(&dword_806C164, v7);
  do
    --v10;
  while ( v10 && *(_BYTE *)(a3 + v10) != 41 );
  v9 = &loc_804A893;
  if ( *(_BYTE *)(a3 + v10) == 41 )
    v9 = &loc_804A89D;
  dword_806C110 = (int)v9;
  sub_8066DC7(v8);
  return 0;
}
// 8066BC0: using guessed type int __fastcall sub_8066BC0(_DWORD);
// 8066DC7: using guessed type int __fastcall sub_8066DC7(_DWORD);
// 806C110: using guessed type int dword_806C110;
// 806C160: using guessed type int dword_806C160;
// 806C164: using guessed type int dword_806C164;

//----- (0804A9E6) --------------------------------------------------------
int __usercall sub_804A9E6@<eax>(signed __int32 a1@<ebx>, signed __int32 a2, int a3, _BYTE **a4, _DWORD *a5)
{
  signed __int32 v5; // ecx
  signed __int32 v7; // ebx
  signed __int32 v8; // et0
  signed __int32 v9; // ebx
  signed __int32 v10; // ecx
  int v11; // ecx
  void *v12; // eax
  bool v13; // zf
  int v14; // ecx
  void *v15; // eax
  int i; // [esp+28h] [ebp-10h]
  int v17; // [esp+28h] [ebp-10h]

  for ( i = 0; *(_BYTE *)(a2 + i) == 32 || *(_BYTE *)(a2 + i) == 9; ++i )
    ;
  if ( *(_BYTE *)(a2 + i) == 92 )
    ++i;
  if ( !strncmp((const char *)(i + a2), "SHA512", 6u) )
  {
    i += 6;
    if ( *(_BYTE *)(a2 + i) == 32 )
      ++i;
    if ( *(_BYTE *)(a2 + i) == 40 )
    {
      *a5 = 0;
      return sub_804A7F7(a3 - (i + 1), a2, a2 + i + 1, a3 - (i + 1));
    }
    dword_806C1EC = (int)&loc_804AC8F;
    v7 = _InterlockedExchange(&dword_806C1F0, a1);
    v8 = _InterlockedExchange(&dword_806C1F0, v5);
    sub_8066803(_InterlockedExchange(&dword_806C1F0, v7));
    v9 = _InterlockedExchange(&dword_806C1F0, v8);
    _InterlockedExchange(&dword_806C1F0, v10);
    _InterlockedExchange(&dword_806C1F0, v9);
  }
  v11 = a3 - i;
  if ( a3 - i < (unsigned int)(*(_BYTE *)(a2 + i) == 92) + dword_806C6CE )
    return 0;
  *a4 = (_BYTE *)(i + a2);
  v17 = dword_806C6D2 + i;
  v12 = &loc_804AB78;
  if ( *(_BYTE *)(a2 + v17) == 32 )
    v12 = &loc_804AB91;
  dword_806C124 = (int)v12;
  sub_8066D47(v11);
  if ( *(_BYTE *)(a2 + v17) != 9 )
    return 0;
  *(_BYTE *)(a2 + v17) = 0;
  v13 = sub_804A797(*a4) == 1;
  v15 = &loc_804ABCF;
  if ( v13 )
    v15 = &loc_804ABD9;
  dword_806C124 = (int)v15;
  sub_8066D47(v14);
  return 0;
}
// 8066803: using guessed type int __fastcall sub_8066803(_DWORD);
// 8066D47: using guessed type int __fastcall sub_8066D47(_DWORD);
// 806C124: using guessed type int dword_806C124;
// 806C1EC: using guessed type int dword_806C1EC;
// 806C1F0: using guessed type int dword_806C1F0;
// 806C6CE: using guessed type int dword_806C6CE;
// 806C6D2: using guessed type int dword_806C6D2;

//----- (0804AC95) --------------------------------------------------------
int __usercall sub_804AC95@<eax>(int a1@<edx>, int a2@<ecx>, _BYTE *a3, char a4)
{
  int result; // eax
  void *v5; // eax

  if ( a4 != 1 )
    return fputs_unlocked(a3, stdout);
  while ( 1 )
  {
    result = (unsigned __int8)*a3;
    if ( !(_BYTE)result )
      break;
    v5 = &loc_804ACF9;
    if ( *a3 == 10 )
      v5 = &loc_804AD1A;
    dword_806C1B0 = (int)v5;
    if ( sub_80669A2(a2, a1) == 92 )
      fwrite_unlocked("\\\\", 1u, 2u, stdout);
    else
      putchar_unlocked((char)*a3);
    ++a3;
  }
  return result;
}
// 8048F20: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 80669A2: using guessed type int __fastcall sub_80669A2(_DWORD, _DWORD);
// 806C1B0: using guessed type int dword_806C1B0;

//----- (0804ADC2) --------------------------------------------------------
int __usercall sub_804ADC2@<eax>(_BYTE *a1@<ebx>, char *s1, int a3, int a4, int a5)
{
  signed __int32 v5; // ecx
  signed __int32 v6; // ebx
  signed __int32 v7; // et0
  signed __int32 v8; // ebx
  signed __int32 v9; // ecx
  signed __int32 v10; // ecx
  signed __int32 v11; // et1
  int v12; // edx
  int v13; // ecx
  int *v15; // eax
  signed __int32 v16; // eax
  signed __int32 v17; // ecx
  int v18; // edx
  signed __int32 v19; // ecx
  signed __int32 v20; // ett
  int v21; // edx
  signed __int32 v22; // ecx
  _BYTE *v23; // ebx
  int *v24; // eax
  int v25; // ecx
  void *v26; // eax
  signed __int32 v27; // ebx
  signed __int32 v28; // ecx
  signed __int32 v29; // et0
  signed __int32 v30; // ebx
  signed __int32 v31; // ecx
  void *v32; // eax
  _BYTE *v33; // ebx
  int *v34; // eax
  bool v35; // [esp+17h] [ebp-11h]
  FILE *stream; // [esp+18h] [ebp-10h]

  v35 = strcmp(s1, "-") == 0;
  *(_BYTE *)a5 = 0;
  if ( v35 )
  {
    byte_806C6CA = 1;
    dword_806C1EC = (int)&loc_804AEF7;
    v6 = _InterlockedExchange(&dword_806C1F0, (signed __int32)a1);
    v7 = _InterlockedExchange(&dword_806C1F0, v5);
    sub_8066803(_InterlockedExchange(&dword_806C1F0, v6));
    v8 = _InterlockedExchange(&dword_806C1F0, v7);
    v11 = _InterlockedExchange(&dword_806C1F0, v9);
    v10 = v8;
    a1 = (_BYTE *)v11;
    _InterlockedExchange(&dword_806C1F0, v10);
  }
  stream = sub_806240A((signed __int32)a1, (int)s1, "r");
  if ( !stream )
  {
    if ( byte_806C6D8 && *__errno_location() == 2 )
    {
      *(_BYTE *)a5 = 1;
      return 1;
    }
    a1 = sub_8064540(0, 3, s1);
    v15 = __errno_location();
    error(0, *v15, "%s", a1);
    dword_806C174 = (int)&loc_804B06D;
    v16 = _InterlockedExchange(&dword_806C178, 0);
    _InterlockedExchange(&dword_806C178, v17);
    v20 = _InterlockedExchange(&dword_806C178, sub_8066B3F(_InterlockedExchange(&dword_806C178, v16), v18));
    _InterlockedExchange(&dword_806C178, v19);
    v13 = _InterlockedExchange(&dword_806C178, v20);
  }
  sub_80623A9(v12, v13, stream, 2);
  if ( sub_804D39A((signed __int32)a1, stream, a4) )
  {
    v23 = sub_8064540(0, 3, s1);
    v24 = __errno_location();
    error(0, *v24, "%s", v23);
    v26 = &loc_804AFA7;
    if ( stream == stdin )
      v26 = &loc_804AFB2;
    dword_806C188 = (int)v26;
    sub_8066AB8(v25);
    sub_8065344(stream);
    dword_806C14C = (int)&loc_804B06D;
    v27 = _InterlockedExchange(&dword_806C150, (signed __int32)v23);
    v29 = _InterlockedExchange(&dword_806C150, v28);
    sub_8066C43(_InterlockedExchange(&dword_806C150, v27));
    v30 = _InterlockedExchange(&dword_806C150, v29);
    _InterlockedExchange(&dword_806C150, v31);
    v22 = _InterlockedExchange(&dword_806C150, v30);
  }
  v32 = &loc_804B012;
  if ( v35 == 1 )
    v32 = &loc_804B068;
  dword_806C19C = (int)v32;
  sub_8066A1E(v22, v21);
  if ( !sub_8065344(stream) )
    return 1;
  v33 = sub_8064540(0, 3, s1);
  v34 = __errno_location();
  error(0, *v34, "%s", v33);
  return 0;
}
// 8066803: using guessed type int __fastcall sub_8066803(_DWORD);
// 8066A1E: using guessed type int __fastcall sub_8066A1E(_DWORD, _DWORD);
// 8066AB8: using guessed type int __fastcall sub_8066AB8(_DWORD);
// 8066B3F: using guessed type int __fastcall sub_8066B3F(_DWORD, _DWORD);
// 8066C43: using guessed type int __fastcall sub_8066C43(_DWORD);
// 806C14C: using guessed type int dword_806C14C;
// 806C150: using guessed type int dword_806C150;
// 806C174: using guessed type int dword_806C174;
// 806C178: using guessed type int dword_806C178;
// 806C188: using guessed type int dword_806C188;
// 806C19C: using guessed type int dword_806C19C;
// 806C1EC: using guessed type int dword_806C1EC;
// 806C1F0: using guessed type int dword_806C1F0;
// 806C6CA: using guessed type char byte_806C6CA;
// 806C6D8: using guessed type char byte_806C6D8;

//----- (0804B073) --------------------------------------------------------
int __usercall __noreturn sub_804B073@<eax>(signed __int32 a1@<ebx>, const char *a2)
{
  int v2; // ecx
  _BYTE *v3; // ebx
  int *v4; // eax
  signed __int32 v5; // ebx
  signed __int32 v6; // ecx
  int v7; // edx
  signed __int32 v8; // edx
  signed __int32 v9; // et1
  void *v10; // eax
  _BYTE *v11; // ebx
  char *v12; // eax
  int v13; // eax
  int v14; // edx
  int v15; // ecx
  bool v16; // zf
  bool v17; // sf
  void *v18; // eax
  signed __int32 v19; // edx
  int v20; // ecx
  int v21; // edx
  int v22; // ecx
  void *v23; // eax
  signed __int32 v24; // eax
  char *v25; // eax
  signed __int32 v26; // eax
  signed __int32 v27; // ebx
  signed __int32 v28; // ecx
  signed __int32 v29; // ecx
  signed __int32 v30; // ett
  bool v31; // al
  int v32; // edx
  int v33; // ecx
  void *v34; // eax
  int v35; // ecx
  char *v36; // eax
  void *v37; // eax
  int v38; // edx
  int v39; // ecx
  int v40; // eax
  void *v41; // eax
  void *v42; // eax
  int v43; // ecx
  char *v44; // eax
  void *v45; // eax
  char *v46; // eax
  int v47; // ecx
  void *v48; // eax
  _BYTE *v49; // ebx
  char *v50; // eax
  int v51; // ecx
  int (*v52)(); // eax
  __int64 v54; // [esp+10h] [ebp-C8h]
  const char *s1; // [esp+1Ch] [ebp-BCh]
  int v56; // [esp+2Ah] [ebp-AEh]
  unsigned __int8 v57; // [esp+2Eh] [ebp-AAh]
  unsigned __int8 v58; // [esp+2Fh] [ebp-A9h]
  void *ptr; // [esp+30h] [ebp-A8h]
  int v60; // [esp+34h] [ebp-A4h]
  char *s; // [esp+38h] [ebp-A0h]
  int v62; // [esp+3Ch] [ebp-9Ch]
  int v63; // [esp+40h] [ebp-98h]
  FILE *stream; // [esp+44h] [ebp-94h]
  int v65; // [esp+48h] [ebp-90h]
  unsigned int i; // [esp+4Ch] [ebp-8Ch]
  int v67; // [esp+50h] [ebp-88h]
  unsigned int v68; // [esp+54h] [ebp-84h]
  __int64 v69; // [esp+58h] [ebp-80h]
  __int64 v70; // [esp+60h] [ebp-78h]
  __int64 v71; // [esp+68h] [ebp-70h]
  __int64 v72; // [esp+70h] [ebp-68h]
  __int64 v73; // [esp+78h] [ebp-60h]
  char v74; // [esp+84h] [ebp-54h]
  unsigned int v75; // [esp+CCh] [ebp-Ch]

  s1 = a2;
  v75 = __readgsdword(0x14u);
  v69 = 0LL;
  v70 = 0LL;
  v71 = 0LL;
  v72 = 0LL;
  *(_WORD *)((char *)&v56 + 1) = 0;
  v67 = sub_804A293((int)&v74, 8u);
  HIBYTE(v56) = strcmp(a2, "-") == 0;
  if ( HIBYTE(v56) )
  {
    byte_806C6CA = 1;
    s1 = gettext("standard input");
    stream = stdin;
  }
  else
  {
    stream = sub_806240A(a1, (int)a2, "r");
    if ( !stream )
    {
      v3 = sub_8064540(0, 3, a2);
      v4 = __errno_location();
      error(0, *v4, "%s", v3);
      dword_806C174 = (int)&loc_804BB35;
      v5 = _InterlockedExchange(&dword_806C178, (signed __int32)v3);
      _InterlockedExchange(&dword_806C178, v6);
      v9 = _InterlockedExchange(&dword_806C178, sub_8066B3F(_InterlockedExchange(&dword_806C178, v5), v7));
      _InterlockedExchange(&dword_806C178, v8);
      _InterlockedExchange(&dword_806C178, v9);
    }
  }
  v73 = 0LL;
  ptr = 0;
  v60 = 0;
  do
  {
    ++v73;
    v10 = &loc_804B236;
    if ( v73 )
      v10 = &loc_804B27E;
    dword_806C1D8 = (int)v10;
    sub_806689B(v2, HIDWORD(v73));
    v11 = sub_8064540(0, 3, s1);
    v12 = gettext("%s: too many checksum lines");
    error(1, 0, v12, v11, (_DWORD)v54);
    v13 = getline(&ptr, &v60, stream);
    v65 = v13;
    v16 = v13 == 0;
    v17 = v13 < 0;
    v18 = &loc_804B2C8;
    if ( v17 || v16 )
      v18 = &loc_804B77D;
    dword_806C1B0 = (int)v18;
    sub_80669A2(v15, v14);
    if ( *(_BYTE *)ptr != 35 )
    {
      if ( *((_BYTE *)ptr + v65 - 1) == 10 )
        *((_BYTE *)ptr + --v65) = 0;
      LODWORD(v54) = &s;
      if ( !((unsigned __int8)sub_804A9E6((signed __int32)v11, (signed __int32)ptr, v65, (_BYTE **)&v63, &v62) ^ 1) )
      {
        if ( !HIBYTE(v56) )
        {
LABEL_21:
          v31 = byte_806C6D6 != 1 && strchr(s, 10);
          v57 = v31;
          BYTE1(v56) = 1;
          v58 = sub_804ADC2(v11, s, (int)&v62, v67, (int)&v56);
          if ( v58 ^ 1 )
          {
            ++v72;
            if ( byte_806C6D6 != 1 )
            {
              v34 = &loc_804B4FF;
              if ( !v57 )
                v34 = &loc_804B50B;
              dword_806C1B0 = (int)v34;
              sub_80669A2(v33, v32);
              putchar_unlocked(92);
              sub_804AC95(v57, v35, s, v57);
              v36 = gettext("FAILED open or read");
              printf(": %s\n", v36);
            }
          }
          else
          {
            v37 = &loc_804B569;
            if ( !byte_806C6D8 )
              v37 = &loc_804B579;
            dword_806C1B0 = (int)v37;
            sub_80669A2(v33, v32);
            if ( !(_BYTE)v56 )
            {
              v68 = (unsigned int)dword_806C6D2 >> 1;
              for ( i = 0; i < v68; ++i )
              {
                v40 = tolower(*(unsigned __int8 *)(2 * i + v63));
                v39 = v67;
                v38 = byte_8067ACD[(unsigned __int8)(*(_BYTE *)(v67 + i) >> 4)];
                if ( v40 != v38 )
                  break;
                v16 = tolower(*(unsigned __int8 *)(2 * i + 1 + v63)) == byte_8067ACD[*(_BYTE *)(v67 + i) & 0xF];
                v41 = &loc_804B637;
                if ( !v16 )
                  v41 = &loc_804B650;
                dword_806C160 = (int)v41;
                sub_8066BC0(v67);
              }
              if ( i == v68 )
                BYTE2(v56) = 1;
              else
                ++v71;
              if ( byte_806C6D6 != 1 )
              {
                if ( i != v68 || byte_806C6D9 != 1 )
                {
                  v42 = &loc_804B6BF;
                  if ( !v57 )
                    v42 = &loc_804B6CB;
                  dword_806C1EC = (int)v42;
                  sub_8066803(v39);
                  putchar_unlocked(92);
                  sub_804AC95(v57, v43, s, v57);
                }
                if ( i == v68 )
                {
                  v45 = &loc_804B737;
                  if ( byte_806C6D9 == 1 )
                    v45 = &loc_804B755;
                  dword_806C1D8 = (int)v45;
                  sub_806689B(v39, v38);
                  v46 = gettext("OK");
                  printf(": %s\n", v46);
                }
                else
                {
                  v44 = gettext("FAILED");
                  printf(": %s\n", v44);
                }
              }
            }
          }
          continue;
        }
        v16 = strcmp(s, "-") == 0;
        v23 = &loc_804B386;
        if ( !v16 )
          v23 = &loc_804B437;
        dword_806C19C = (int)v23;
        sub_8066A1E(v22, v21);
      }
      ++v69;
      v24 = (unsigned __int8)byte_806C6D7;
      if ( byte_806C6D7 )
      {
        v11 = sub_8064540(0, 3, s1);
        v25 = gettext("%s: %llu: improperly formatted %s checksum line");
        error(0, 0, v25, v11, v73, "SHA512");
      }
      ++v70;
      dword_806C138 = (int)&loc_804B755;
      v26 = _InterlockedExchange(&dword_806C13C, v24);
      _InterlockedExchange(&dword_806C13C, v19);
      sub_8066CC6(v20, _InterlockedExchange(&dword_806C13C, v26));
      v27 = _InterlockedExchange(&dword_806C13C, (signed __int32)v11);
      v30 = _InterlockedExchange(&dword_806C13C, v28);
      v29 = v27;
      v11 = (_BYTE *)v30;
      _InterlockedExchange(&dword_806C13C, v29);
      goto LABEL_21;
    }
  }
  while ( !feof_unlocked(stream) && !ferror_unlocked(stream) );
  free(ptr);
  v16 = ferror_unlocked(stream) == 0;
  v48 = &loc_804B7B6;
  if ( v16 )
    v48 = &loc_804B808;
  dword_806C160 = (int)v48;
  sub_8066BC0(v47);
  v49 = sub_8064540(0, 3, s1);
  v50 = gettext("%s: read error");
  error(0, 0, v50, v49, (_DWORD)v54);
  v52 = (int (*)())&loc_804BB5A;
  if ( __readgsdword(0x14u) == v75 )
    v52 = sub_804BB5F;
  dword_806C110 = (int)v52;
  return sub_8066DC7(v51);
}
// 8048D20: using guessed type int __cdecl getline(_DWORD, _DWORD, _DWORD);
// 804BB5F: using guessed type int sub_804BB5F();
// 8066803: using guessed type int __fastcall sub_8066803(_DWORD);
// 806689B: using guessed type int __fastcall sub_806689B(_DWORD, _DWORD);
// 80669A2: using guessed type int __fastcall sub_80669A2(_DWORD, _DWORD);
// 8066A1E: using guessed type int __fastcall sub_8066A1E(_DWORD, _DWORD);
// 8066B3F: using guessed type int __fastcall sub_8066B3F(_DWORD, _DWORD);
// 8066BC0: using guessed type int __fastcall sub_8066BC0(_DWORD);
// 8066CC6: using guessed type int __fastcall sub_8066CC6(_DWORD, _DWORD);
// 8066DC7: using guessed type int __fastcall sub_8066DC7(_DWORD);
// 806C110: using guessed type int dword_806C110;
// 806C138: using guessed type int dword_806C138;
// 806C13C: using guessed type int dword_806C13C;
// 806C160: using guessed type int dword_806C160;
// 806C174: using guessed type int dword_806C174;
// 806C178: using guessed type int dword_806C178;
// 806C19C: using guessed type int dword_806C19C;
// 806C1B0: using guessed type int dword_806C1B0;
// 806C1D8: using guessed type int dword_806C1D8;
// 806C1EC: using guessed type int dword_806C1EC;
// 806C6CA: using guessed type char byte_806C6CA;
// 806C6D2: using guessed type int dword_806C6D2;
// 806C6D6: using guessed type char byte_806C6D6;
// 806C6D7: using guessed type char byte_806C6D7;
// 806C6D8: using guessed type char byte_806C6D8;
// 806C6D9: using guessed type char byte_806C6D9;

//----- (0804BB5F) --------------------------------------------------------
#error "804BB65: positive sp value has been found (funcsize=0)"

//----- (0804BB69) --------------------------------------------------------
int __usercall main@<eax>(signed __int32 a1@<ebx>, int argc, char **a3)
{
  signed __int32 v3; // ebx
  signed __int32 v4; // ecx
  signed __int32 v5; // et0
  signed __int32 v6; // edx
  signed __int32 v7; // ebx
  signed __int32 v8; // ecx
  signed __int32 v9; // ecx
  _BYTE *v10; // ebx
  signed __int32 v11; // et1
  int v12; // ecx
  signed __int32 v13; // eax
  signed __int32 v14; // ebx
  signed __int32 v15; // et2
  signed __int32 v16; // ebx
  signed __int32 v17; // edx
  signed __int32 v18; // edx
  signed __int32 v19; // ett
  signed __int32 v20; // eax
  signed __int32 v21; // ebx
  signed __int32 v22; // edx
  signed __int32 v23; // edx
  signed __int32 v24; // et1
  signed __int32 v25; // ebx
  signed __int32 v26; // et2
  signed __int32 v27; // ebx
  signed __int32 v28; // edx
  signed __int32 v29; // edx
  signed __int32 v30; // ett
  int v31; // eax
  int v32; // ecx
  bool v33; // zf
  void *v34; // eax
  int v35; // edx
  int v36; // ecx
  void *v37; // eax
  signed __int32 v38; // ecx
  char *v39; // eax
  char *v40; // eax
  char *v41; // eax
  char *v42; // eax
  char *v43; // eax
  char *v44; // eax
  char *v45; // eax
  char *v46; // eax
  int v47; // edx
  int v48; // edx
  int v49; // ecx
  bool v50; // al
  int v51; // edx
  int v52; // ecx
  void *v53; // eax
  signed __int32 v54; // edx
  int v55; // ecx
  signed __int32 v56; // ebx
  signed __int32 v57; // edx
  signed __int32 v58; // et0
  signed __int32 v59; // ecx
  signed __int32 v60; // et1
  int v61; // edx
  int v62; // ecx
  char *v63; // ebx
  int *v64; // eax
  signed __int32 v65; // eax
  signed __int32 v66; // ecx
  signed __int32 v67; // ett
  int v69; // [esp+3Bh] [ebp-79h]
  bool v70; // [esp+3Fh] [ebp-75h]
  int v71; // [esp+40h] [ebp-74h]
  int v72; // [esp+44h] [ebp-70h]
  char **v73; // [esp+48h] [ebp-6Ch]
  char **i; // [esp+4Ch] [ebp-68h]
  unsigned int j; // [esp+50h] [ebp-64h]
  int v76; // [esp+54h] [ebp-60h]
  const char *v77; // [esp+58h] [ebp-5Ch]
  int v78; // [esp+5Ch] [ebp-58h]
  char *v79; // [esp+60h] [ebp-54h]
  int v80; // [esp+64h] [ebp-50h]
  unsigned int v81; // [esp+ACh] [ebp-8h]

  v81 = __readgsdword(0x14u);
  v76 = sub_804A293((int)&v80, 8u);
  *(_WORD *)((char *)&v69 + 1) = 256;
  v72 = -1;
  HIBYTE(v69) = 0;
  sub_80624F5(*a3);
  setlocale(6, &locale);
  bindtextdomain("coreutils", "/home/hwangdz/coreutils/coreutils-8.28/install_m32/share/locale");
  textdomain("coreutils");
  sub_8066703((int)sub_804C4F1);
  setvbuf(stdout, 0, 1, 0);
  v77 = "bctw";
  dword_806C14C = (int)&loc_804BE90;
  v3 = _InterlockedExchange(&dword_806C150, a1);
  v5 = _InterlockedExchange(&dword_806C150, v4);
  sub_8066C43(_InterlockedExchange(&dword_806C150, v3));
  v7 = _InterlockedExchange(&dword_806C150, v5);
  v11 = _InterlockedExchange(&dword_806C150, v8);
  v9 = v7;
  v10 = (_BYTE *)v11;
  v12 = _InterlockedExchange(&dword_806C150, v9);
  v13 = v78;
  if ( v78 == 119 )
  {
    byte_806C6D6 = 0;
    byte_806C6D7 = 1;
    byte_806C6D9 = 0;
    dword_806C124 = (int)&loc_804BE90;
    v14 = _InterlockedExchange(&dword_806C128, (signed __int32)v10);
    v15 = _InterlockedExchange(&dword_806C128, v6);
    _InterlockedExchange(&dword_806C128, v14);
    v13 = sub_8066D47(v12);
    v16 = _InterlockedExchange(&dword_806C128, v15);
    v19 = _InterlockedExchange(&dword_806C128, v17);
    v18 = v16;
    v10 = (_BYTE *)v19;
    v6 = _InterlockedExchange(&dword_806C128, v18);
    goto LABEL_24;
  }
  if ( v78 > 119 )
  {
    if ( v78 == 130 )
    {
LABEL_25:
      byte_806C6D6 = 0;
      byte_806C6D7 = 0;
      byte_806C6D9 = 1;
      goto LABEL_32;
    }
    if ( v78 > 130 )
    {
      if ( v78 == 131 )
      {
        byte_806C6DA = 1;
        dword_806C1B0 = (int)&loc_804BE90;
        v25 = _InterlockedExchange(&dword_806C1B4, (signed __int32)v10);
        v26 = _InterlockedExchange(&dword_806C1B4, v6);
        sub_80669A2(v12, _InterlockedExchange(&dword_806C1B4, v25));
        v27 = _InterlockedExchange(&dword_806C1B4, v26);
        v30 = _InterlockedExchange(&dword_806C1B4, v28);
        v29 = v27;
        v10 = (_BYTE *)v30;
        _InterlockedExchange(&dword_806C1B4, v29);
      }
      else if ( v78 != 132 )
      {
        goto LABEL_31;
      }
      HIBYTE(v69) = 1;
      v72 = 1;
      goto LABEL_32;
    }
    if ( v78 != 128 )
    {
      if ( v78 != 129 )
        goto LABEL_31;
      byte_806C6D6 = 1;
      byte_806C6D7 = 0;
      byte_806C6D9 = 0;
      goto LABEL_32;
    }
LABEL_24:
    byte_806C6D8 = 1;
    dword_806C174 = (int)&loc_804BE90;
    v20 = _InterlockedExchange(&dword_806C178, v13);
    _InterlockedExchange(&dword_806C178, v6);
    sub_8066B3F(v12, _InterlockedExchange(&dword_806C178, v20));
    v21 = _InterlockedExchange(&dword_806C178, (signed __int32)v10);
    v24 = _InterlockedExchange(&dword_806C178, v22);
    v23 = v21;
    v10 = (_BYTE *)v24;
    _InterlockedExchange(&dword_806C178, v23);
    goto LABEL_25;
  }
  if ( v78 == 98 )
  {
    v72 = 1;
  }
  else
  {
    if ( v78 <= 98 )
    {
      if ( v78 == -131 )
      {
        sub_8064EDA(
          off_806C218,
          v12,
          (signed __int32)v10,
          stdout,
          (int)"sha512sum",
          (int)"GNU coreutils",
          off_806C218,
          "Ulrich Drepper",
          "Scott Miller",
          "David Madore",
          0);
        exit(0);
      }
      if ( v78 == -130 )
        sub_804A4E4(0);
LABEL_31:
      sub_804A4E4(1);
    }
    if ( v78 == 99 )
    {
      BYTE1(v69) = 1;
    }
    else
    {
      if ( v78 != 116 )
        goto LABEL_31;
      v72 = 0;
    }
  }
LABEL_32:
  v31 = getopt_long(argc, a3, v77, &longopts, 0);
  v78 = v31;
  v33 = v31 == -1;
  v34 = &loc_804BEDF;
  if ( !v33 )
    v34 = &loc_804BC6D;
  dword_806C110 = (int)v34;
  sub_8066DC7(v32);
  dword_806C6CE = 130;
  dword_806C6D2 = 128;
  v37 = &loc_804BF13;
  if ( !HIBYTE(v69) )
    v37 = &loc_804BF4A;
  dword_806C19C = (int)v37;
  sub_8066A1E(v36, v35);
  if ( !v72 )
  {
    v39 = gettext("--tag does not support --text mode");
    error(0, 0, v39);
    sub_804A4E4(1);
  }
  if ( HIBYTE(v69) && BYTE1(v69) )
  {
    v40 = gettext("the --tag option is meaningless when verifying checksums");
    error(0, 0, v40);
    sub_804A4E4(1);
  }
  if ( v72 >= 0 && BYTE1(v69) )
  {
    v41 = gettext("the --binary and --text options are meaningless when verifying checksums");
    error(0, 0, v41);
    sub_804A4E4(1);
  }
  if ( byte_806C6D8 && BYTE1(v69) != 1 )
  {
    v42 = gettext("the --ignore-missing option is meaningful only when verifying checksums");
    error(0, 0, v42);
    sub_804A4E4(1);
  }
  if ( byte_806C6D6 && BYTE1(v69) != 1 )
  {
    v43 = gettext("the --status option is meaningful only when verifying checksums");
    error(0, 0, v43);
    sub_804A4E4(1);
  }
  if ( byte_806C6D7 && BYTE1(v69) != 1 )
  {
    v44 = gettext("the --warn option is meaningful only when verifying checksums");
    error(0, 0, v44);
    sub_804A4E4(1);
  }
  if ( byte_806C6D9 && BYTE1(v69) != 1 )
  {
    v45 = gettext("the --quiet option is meaningful only when verifying checksums");
    error(0, 0, v45);
    sub_804A4E4(1);
  }
  if ( (unsigned __int8)byte_806C6DA & (unsigned __int8)(BYTE1(v69) ^ 1) )
  {
    v46 = gettext("the --strict option is meaningful only when verifying checksums");
    error(0, 0, v46);
    sub_804A4E4(1);
  }
  if ( v72 < 0 )
    v72 = 0;
  v73 = &a3[argc];
  if ( optind == argc )
  {
    v10 = v73;
    ++v73;
    *(_DWORD *)v10 = sub_804A4DC((int)"-");
  }
  v47 = 4 * optind;
  for ( i = &a3[optind]; i < v73; ++i )
  {
    v79 = *i;
    if ( BYTE1(v69) )
      sub_804B073(BYTE2(v69), v79);
    v71 = v72;
    if ( (unsigned __int8)sub_804ADC2(v10, v79, (int)&v71, v76, (int)&v69) ^ 1 )
    {
      BYTE2(v69) = 0;
    }
    else
    {
      v50 = strchr(v79, 92) || strchr(v79, 10);
      v70 = v50;
      if ( HIBYTE(v69) )
      {
        if ( v70 )
          putchar_unlocked(92);
        fwrite_unlocked("SHA512", 1u, 6u, stdout);
        fwrite_unlocked(" (", 1u, 2u, stdout);
        sub_804AC95(v51, v52, v79, v70);
        fwrite_unlocked(") = ", 1u, 4u, stdout);
      }
      if ( HIBYTE(v69) != 1 && v70 )
        putchar_unlocked(92);
      for ( j = 0; (unsigned int)dword_806C6D2 >> 1 > j; ++j )
        printf("%02x", *(unsigned __int8 *)(v76 + j));
      v53 = &loc_804C397;
      if ( HIBYTE(v69) == 1 )
        v53 = &loc_804C408;
      dword_806C1D8 = (int)v53;
      sub_806689B(v49, v48);
      putchar_unlocked(32);
      if ( v71 )
      {
        dword_806C14C = (int)&loc_804C3EB;
        v56 = _InterlockedExchange(&dword_806C150, (signed __int32)v10);
        v58 = _InterlockedExchange(&dword_806C150, v54);
        v57 = v56;
        v10 = (_BYTE *)v58;
        _InterlockedExchange(&dword_806C150, v57);
        v60 = _InterlockedExchange(&dword_806C150, sub_8066C43(v55));
        _InterlockedExchange(&dword_806C150, v59);
        _InterlockedExchange(&dword_806C150, v60);
      }
      putchar_unlocked(32);
      sub_804AC95(v61, v62, v79, v70);
      putchar_unlocked(10);
    }
  }
  if ( byte_806C6CA && sub_8065344(stdin) == -1 )
  {
    v63 = gettext("standard input");
    v64 = __errno_location();
    error(1, *v64, v63);
  }
  if ( BYTE2(v69) )
  {
    dword_806C1B0 = (int)&loc_804C4B3;
    v65 = _InterlockedExchange(&dword_806C1B4, 0);
    _InterlockedExchange(&dword_806C1B4, v38);
    v67 = _InterlockedExchange(&dword_806C1B4, sub_80669A2(_InterlockedExchange(&dword_806C1B4, v65), v47));
    _InterlockedExchange(&dword_806C1B4, v66);
    _InterlockedExchange(&dword_806C1B4, v67);
  }
  return 1;
}
// 806689B: using guessed type int __fastcall sub_806689B(_DWORD, _DWORD);
// 80669A2: using guessed type int __fastcall sub_80669A2(_DWORD, _DWORD);
// 8066A1E: using guessed type int __fastcall sub_8066A1E(_DWORD, _DWORD);
// 8066B3F: using guessed type int __fastcall sub_8066B3F(_DWORD, _DWORD);
// 8066C43: using guessed type int __fastcall sub_8066C43(_DWORD);
// 8066D47: using guessed type int __fastcall sub_8066D47(_DWORD);
// 8066DC7: using guessed type int __fastcall sub_8066DC7(_DWORD);
// 806C110: using guessed type int dword_806C110;
// 806C124: using guessed type int dword_806C124;
// 806C128: using guessed type int dword_806C128;
// 806C14C: using guessed type int dword_806C14C;
// 806C150: using guessed type int dword_806C150;
// 806C174: using guessed type int dword_806C174;
// 806C178: using guessed type int dword_806C178;
// 806C19C: using guessed type int dword_806C19C;
// 806C1B0: using guessed type int dword_806C1B0;
// 806C1B4: using guessed type int dword_806C1B4;
// 806C1D8: using guessed type int dword_806C1D8;
// 806C2A0: using guessed type int optind;
// 806C6CA: using guessed type char byte_806C6CA;
// 806C6CE: using guessed type int dword_806C6CE;
// 806C6D2: using guessed type int dword_806C6D2;
// 806C6D6: using guessed type char byte_806C6D6;
// 806C6D7: using guessed type char byte_806C6D7;
// 806C6D8: using guessed type char byte_806C6D8;
// 806C6D9: using guessed type char byte_806C6D9;
// 806C6DA: using guessed type char byte_806C6DA;

//----- (0804C4F1) --------------------------------------------------------
int sub_804C4F1()
{
  _BYTE *v0; // ebx
  int *v1; // eax
  int *v2; // eax
  int result; // eax
  char *v4; // [esp+2Ch] [ebp-Ch]

  if ( sub_8065A94(stdout) && (byte_806C6E2 != 1 || *__errno_location() != 32) )
  {
    v4 = gettext("write error");
    if ( dword_806C6DE )
    {
      v0 = sub_8064451((const char *)dword_806C6DE);
      v1 = __errno_location();
      error(0, *v1, "%s: %s", v0, v4);
    }
    else
    {
      v2 = __errno_location();
      error(0, *v2, "%s", v4);
    }
    _exit(status);
  }
  result = sub_8065A94(stderr);
  if ( result )
    _exit(status);
  return result;
}
// 806C6DE: using guessed type int dword_806C6DE;
// 806C6E2: using guessed type char byte_806C6E2;

//----- (0804C5D5) --------------------------------------------------------
_DWORD *__cdecl sub_804C5D5(_DWORD *a1)
{
  int v1; // edx
  _DWORD *result; // eax

  *a1 = -205731576;
  a1[1] = 1779033703;
  a1[2] = -2067093701;
  a1[3] = -1150833019;
  a1[4] = -23791573;
  a1[5] = 1013904242;
  a1[6] = 1595750129;
  a1[7] = -1521486534;
  a1[8] = -1377402159;
  a1[9] = 1359893119;
  a1[10] = 725511199;
  a1[11] = -1694144372;
  a1[12] = -79577749;
  a1[13] = 528734635;
  a1[14] = 327033209;
  a1[15] = 1541459225;
  a1[18] = 0;
  a1[19] = 0;
  v1 = a1[19];
  a1[16] = a1[18];
  a1[17] = v1;
  result = a1;
  a1[20] = 0;
  return result;
}

//----- (0804C68E) --------------------------------------------------------
_DWORD *__cdecl sub_804C68E(_DWORD *a1)
{
  int v1; // edx
  _DWORD *result; // eax

  *a1 = -1056596264;
  a1[1] = -876896931;
  a1[2] = 914150663;
  a1[3] = 1654270250;
  a1[4] = 812702999;
  a1[5] = -1856437926;
  a1[6] = -150054599;
  a1[7] = 355462360;
  a1[8] = -4191439;
  a1[9] = 1731405415;
  a1[10] = 1750603025;
  a1[11] = -1900787065;
  a1[12] = 1694076839;
  a1[13] = -619958771;
  a1[14] = -1090891868;
  a1[15] = 1203062813;
  a1[18] = 0;
  a1[19] = 0;
  v1 = a1[19];
  a1[16] = a1[18];
  a1[17] = v1;
  result = a1;
  a1[20] = 0;
  return result;
}

//----- (0804C747) --------------------------------------------------------
int __cdecl sub_804C747(_DWORD *a1, int a2, int a3)
{
  int result; // eax

  result = a2;
  *a1 = a2;
  a1[1] = a3;
  return result;
}

//----- (0804C769) --------------------------------------------------------
int __cdecl sub_804C769(int a1, int a2)
{
  _DWORD *v2; // edx
  int v3; // et1
  int v4; // ebx
  _DWORD *v5; // edx
  int v6; // et1
  int v7; // ST64_4
  _DWORD *v8; // edx
  int v9; // et1
  int v10; // ST58_4
  _DWORD *v11; // edx
  int v12; // et1
  unsigned int v13; // ST50_4
  int *v14; // edx
  int v15; // et1
  int v16; // ST20_4
  int *v17; // edx
  int v18; // et1
  signed int i; // [esp+80h] [ebp-18h]

  for ( i = 0; i <= 7; ++i )
  {
    v2 = (_DWORD *)(a1 + 8 * i);
    v3 = v2[1];
    v4 = *v2 << 24;
    v5 = (_DWORD *)(a1 + 8 * i);
    v6 = v5[1];
    v7 = ((*v5 & 0xFF00) << 8) | v4;
    v8 = (_DWORD *)(a1 + 8 * i);
    v9 = v8[1];
    v10 = *v8 & 0xFF0000;
    v11 = (_DWORD *)(a1 + 8 * i);
    v12 = v11[1];
    v13 = *v11 & 0xFF000000;
    v14 = (int *)(a1 + 8 * i);
    v15 = *v14;
    v16 = ((unsigned int)v14[1] >> 8) & 0xFF00;
    v17 = (int *)(a1 + 8 * i);
    v18 = *v17;
    sub_804C747(
      (_DWORD *)(8 * i + a2),
      ((unsigned int)v17[1] >> 24) | v16 | (*(_QWORD *)(a1 + 8 * i) >> 24) & 0xFF0000 | (*(_QWORD *)(a1 + 8 * i) >> 8) & 0xFF000000 | (v13 << 8) | (v10 << 24),
      ((unsigned __int64)v13 >> 24) | ((unsigned __int64)(unsigned int)v10 >> 8) | v7);
  }
  return a2;
}

//----- (0804C99C) --------------------------------------------------------
int __cdecl sub_804C99C(int a1, int a2)
{
  _DWORD *v2; // edx
  int v3; // et1
  int v4; // ebx
  _DWORD *v5; // edx
  int v6; // et1
  int v7; // ST64_4
  _DWORD *v8; // edx
  int v9; // et1
  int v10; // ST58_4
  _DWORD *v11; // edx
  int v12; // et1
  unsigned int v13; // ST50_4
  int *v14; // edx
  int v15; // et1
  int v16; // ST20_4
  int *v17; // edx
  int v18; // et1
  signed int i; // [esp+80h] [ebp-18h]

  for ( i = 0; i <= 5; ++i )
  {
    v2 = (_DWORD *)(a1 + 8 * i);
    v3 = v2[1];
    v4 = *v2 << 24;
    v5 = (_DWORD *)(a1 + 8 * i);
    v6 = v5[1];
    v7 = ((*v5 & 0xFF00) << 8) | v4;
    v8 = (_DWORD *)(a1 + 8 * i);
    v9 = v8[1];
    v10 = *v8 & 0xFF0000;
    v11 = (_DWORD *)(a1 + 8 * i);
    v12 = v11[1];
    v13 = *v11 & 0xFF000000;
    v14 = (int *)(a1 + 8 * i);
    v15 = *v14;
    v16 = ((unsigned int)v14[1] >> 8) & 0xFF00;
    v17 = (int *)(a1 + 8 * i);
    v18 = *v17;
    sub_804C747(
      (_DWORD *)(8 * i + a2),
      ((unsigned int)v17[1] >> 24) | v16 | (*(_QWORD *)(a1 + 8 * i) >> 24) & 0xFF0000 | (*(_QWORD *)(a1 + 8 * i) >> 8) & 0xFF000000 | (v13 << 8) | (v10 << 24),
      ((unsigned __int64)v13 >> 24) | ((unsigned __int64)(unsigned int)v10 >> 8) | v7);
  }
  return a2;
}

//----- (0804CBCF) --------------------------------------------------------
int __cdecl sub_804CBCF(int a1)
{
  signed int v1; // eax
  int v2; // et1
  int v3; // et1
  int v4; // et1
  int v5; // et1
  unsigned int v6; // STF8_4
  int v7; // et1
  int v8; // STE8_4
  int v9; // et1
  int v10; // et1
  int v11; // et1
  int v12; // et1
  int v13; // et1
  int v14; // et1
  int v15; // et1
  int v16; // et1
  unsigned int v18; // [esp+128h] [ebp-20h]
  signed int v19; // [esp+12Ch] [ebp-1Ch]

  v18 = *(_DWORD *)(a1 + 80);
  if ( v18 > 0x6F )
    v1 = 32;
  else
    v1 = 16;
  v19 = v1;
  *(_QWORD *)(a1 + 64) += v18;
  if ( *(_QWORD *)(a1 + 64) < (unsigned __int64)v18 )
    ++*(_QWORD *)(a1 + 72);
  v2 = *(_DWORD *)(a1 + 76);
  v3 = *(_DWORD *)(a1 + 64);
  v4 = *(_DWORD *)(a1 + 64);
  v5 = *(_DWORD *)(a1 + 64);
  v6 = *(_QWORD *)(a1 + 68) >> 29;
  v7 = *(_DWORD *)(a1 + 64);
  v8 = *(_QWORD *)(a1 + 68) >> 29;
  v9 = *(_DWORD *)(a1 + 64);
  v10 = *(_DWORD *)(a1 + 64);
  v11 = *(_DWORD *)(a1 + 64);
  v12 = *(_DWORD *)(a1 + 64);
  sub_804C747(
    (_DWORD *)(8 * (v1 - 2 + 10) + a1 + 4),
    ((unsigned int)(*(_QWORD *)(a1 + 72) >> 29) >> 24) | ((unsigned int)(*(_QWORD *)(a1 + 72) >> 29) >> 8) & 0xFF00 | (__PAIR__(*(_QWORD *)(a1 + 72) >> 29, v6) >> 24) & 0xFF0000 | (__PAIR__(*(_QWORD *)(a1 + 72) >> 29, v6) >> 8) & 0xFF000000 | ((v8 & 0xFF000000) << 8) | ((v6 & 0xFF0000) << 24),
    ((v8 & 0xFF000000) >> 24) | ((v6 & 0xFF0000uLL) >> 8) | ((unsigned __int16)((*(_QWORD *)(a1 + 68) >> 29) & 0xFF00) << 8) | (v6 << 24));
  v13 = *(_DWORD *)(a1 + 68);
  v14 = *(_DWORD *)(a1 + 68);
  v15 = *(_DWORD *)(a1 + 68);
  v16 = *(_DWORD *)(a1 + 68);
  sub_804C747(
    (_DWORD *)(8 * (v19 - 1 + 10) + a1 + 4),
    ((unsigned int)(*(_QWORD *)(a1 + 64) >> 29) >> 24) | ((unsigned int)(*(_QWORD *)(a1 + 64) >> 29) >> 8) & 0xFF00 | ((unsigned __int64)(8LL * *(_QWORD *)(a1 + 64)) >> 24) & 0xFF0000 | ((unsigned __int64)(8LL * *(_QWORD *)(a1 + 64)) >> 8) & 0xFF000000 | ((8 * *(_DWORD *)(a1 + 64) & 0xFF000000) << 8) | ((8 * *(_DWORD *)(a1 + 64) & 0xFF0000) << 24),
    ((8 * *(_DWORD *)(a1 + 64) & 0xFF000000) >> 24) | ((8 * *(_DWORD *)(a1 + 64) & 0xFF0000u) >> 8) | ((unsigned __int16)(8 * *(unsigned int *)(a1 + 64) & 0xFF00) << 8) | (*(_DWORD *)(a1 + 64) << 27));
  memcpy((void *)(a1 + 84 + v18), &unk_8067AF8, 8 * (v19 + 536870910) - v18);
  return sub_804DB23(a1 + 84, 8 * v19, a1);
}
// 804DB23: using guessed type _DWORD __cdecl sub_804DB23(_DWORD, _DWORD, _DWORD);

//----- (0804D350) --------------------------------------------------------
int __cdecl sub_804D350(int a1, int a2)
{
  sub_804CBCF(a1);
  return sub_804C769(a1, a2);
}

//----- (0804D375) --------------------------------------------------------
int __cdecl sub_804D375(int a1, int a2)
{
  sub_804CBCF(a1);
  return sub_804C99C(a1, a2);
}

//----- (0804D39A) --------------------------------------------------------
int __usercall sub_804D39A@<eax>(signed __int32 a1@<ebx>, FILE *stream, int a3)
{
  signed __int32 v3; // ecx
  signed __int32 v4; // ebx
  signed __int32 v5; // edx
  signed __int32 v6; // et1
  _DWORD *v7; // eax
  signed __int32 v8; // eax
  signed __int32 v9; // edx
  int v10; // ecx
  signed __int32 v11; // ecx
  signed __int32 v12; // ett
  void *ptr; // [esp+14h] [ebp-164h]
  int v15; // [esp+1Ch] [ebp-15Ch]

  ptr = malloc(0x8048u);
  if ( !ptr )
  {
    dword_806C188 = (int)&locret_804D5CC;
    v4 = _InterlockedExchange(&dword_806C18C, a1);
    _InterlockedExchange(&dword_806C18C, v3);
    v6 = _InterlockedExchange(&dword_806C18C, sub_8066AB8(_InterlockedExchange(&dword_806C18C, v4)));
    _InterlockedExchange(&dword_806C18C, v5);
    _InterlockedExchange(&dword_806C18C, v6);
  }
  v7 = sub_804C5D5(&v15);
  dword_806C1D8 = (int)&loc_804D7C7;
  v8 = _InterlockedExchange(&dword_806C1DC, (signed __int32)v7);
  _InterlockedExchange(&dword_806C1DC, v9);
  v12 = _InterlockedExchange(&dword_806C1DC, sub_806689B(v10, _InterlockedExchange(&dword_806C1DC, v8)));
  _InterlockedExchange(&dword_806C1DC, v11);
  _InterlockedExchange(&dword_806C1DC, v12);
  sub_804D375((int)&v15, a3);
  free(ptr);
  return 0;
}
// 806689B: using guessed type int __fastcall sub_806689B(_DWORD, _DWORD);
// 8066AB8: using guessed type int __fastcall sub_8066AB8(_DWORD);
// 806C188: using guessed type int dword_806C188;
// 806C18C: using guessed type int dword_806C18C;
// 806C1D8: using guessed type int dword_806C1D8;
// 806C1DC: using guessed type int dword_806C1DC;

//----- (0804D8CC) --------------------------------------------------------
int __cdecl sub_804D8CC(void *src, size_t a2, int a3)
{
  int result; // eax
  int v4; // eax
  void *v5; // eax
  size_t v6; // ST14_4
  size_t v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]

  result = *(_DWORD *)(a3 + 80);
  if ( result )
  {
    v8 = *(_DWORD *)(a3 + 80);
    v4 = a2;
    if ( 256 - v8 <= a2 )
      v4 = 256 - v8;
    n = v4;
    memcpy((void *)(v8 + a3 + 84), src, v4);
    *(_DWORD *)(a3 + 80) += n;
    if ( *(_DWORD *)(a3 + 80) > 0x80u )
    {
      sub_804DB23(a3 + 84, *(_DWORD *)(a3 + 80) & 0xFFFFFF80, a3);
      *(_DWORD *)(a3 + 80) &= 0x7Fu;
      memcpy((void *)(a3 + 84), (const void *)(a3 + 84 + ((v8 + n) & 0xFFFFFF80)), *(_DWORD *)(a3 + 80));
    }
    src = (char *)src + n;
    result = n;
    a2 -= n;
  }
  if ( a2 > 0x7F )
  {
    result = (unsigned __int8)src & 3;
    if ( (unsigned __int8)src & 3 )
    {
      while ( a2 > 0x80 )
      {
        v5 = memcpy((void *)(a3 + 84), src, 0x80u);
        result = sub_804DB23(v5, 128, a3);
        src = (char *)src + 128;
        a2 -= 128;
      }
    }
    else
    {
      sub_804DB23(src, a2 & 0xFFFFFF80, a3);
      result = a2 & 0xFFFFFF80;
      src = (char *)src + (a2 & 0xFFFFFF80);
      a2 &= 0x7Fu;
    }
  }
  if ( a2 )
  {
    v6 = *(_DWORD *)(a3 + 80);
    memcpy((void *)(v6 + a3 + 84), src, a2);
    v7 = a2 + v6;
    if ( v7 > 0x7F )
    {
      sub_804DB23(a3 + 84, 128, a3);
      v7 -= 128;
      memcpy((void *)(a3 + 84), (const void *)(a3 + 212), v7);
    }
    result = a3;
    *(_DWORD *)(a3 + 80) = v7;
  }
  return result;
}
// 804DB23: using guessed type _DWORD __cdecl sub_804DB23(_DWORD, _DWORD, _DWORD);

//----- (0804DB23) --------------------------------------------------------
#error "804DB23: too big function (funcsize=0)"

//----- (08062358) --------------------------------------------------------
int __cdecl sub_8062358(int a1, int a2, int a3, int a4, int a5, int a6)
{
  return posix_fadvise64(a1, a2, a3, a4, a5, a6);
}
// 8049050: using guessed type int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (080623A9) --------------------------------------------------------
int __usercall sub_80623A9@<eax>(int a1@<edx>, int a2@<ecx>, FILE *stream, int a4)
{
  void *v4; // eax
  int v5; // eax

  v4 = &loc_80623CE;
  if ( !stream )
    v4 = &locret_8062408;
  dword_806C1B0 = (int)v4;
  sub_80669A2(a2, a1);
  v5 = fileno(stream);
  return sub_8062358(v5, 0, 0, 0, 0, a4);
}
// 80669A2: using guessed type int __fastcall sub_80669A2(_DWORD, _DWORD);
// 806C1B0: using guessed type int dword_806C1B0;

//----- (0806240A) --------------------------------------------------------
FILE *__usercall sub_806240A@<eax>(signed __int32 a1@<ebx>, int a2, char *modes)
{
  int v3; // ecx
  void *v4; // eax
  int v5; // ST30_4
  int v7; // ST34_4
  FILE *stream; // [esp+1Ch] [ebp-1Ch]
  signed int v9; // [esp+20h] [ebp-18h]
  int fd; // [esp+24h] [ebp-14h]

  stream = (FILE *)fopen64(a2, modes);
  if ( !stream )
    return stream;
  v9 = fileno(stream);
  if ( v9 < 0 )
    return stream;
  v4 = &loc_8062466;
  if ( v9 > 2 )
    v4 = &loc_80624F0;
  dword_806C14C = (int)v4;
  sub_8066C43(v3);
  fd = sub_806486E(a1, v9);
  if ( fd < 0 )
  {
    v5 = *__errno_location();
    sub_8065344(stream);
    *__errno_location() = v5;
    return 0;
  }
  if ( !sub_8065344(stream) )
  {
    stream = fdopen(fd, modes);
    if ( stream )
      return stream;
  }
  v7 = *__errno_location();
  close(fd);
  *__errno_location() = v7;
  return 0;
}
// 8048E10: using guessed type int __cdecl fopen64(_DWORD, _DWORD);
// 8066C43: using guessed type int __fastcall sub_8066C43(_DWORD);
// 806C14C: using guessed type int dword_806C14C;

//----- (080624F5) --------------------------------------------------------
char *__cdecl sub_80624F5(char *s)
{
  char *v1; // eax
  int v2; // edx
  int v3; // ecx
  bool v4; // zf
  void *v5; // eax
  char *result; // eax
  char *v7; // [esp+18h] [ebp-10h]

  if ( !s )
  {
    fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
    abort();
  }
  v1 = strrchr(s, 47);
  v7 = v1;
  v4 = v1 == 0;
  v5 = &loc_8062560;
  if ( v4 )
    v5 = &loc_8062568;
  dword_806C1B0 = (int)v5;
  sub_80669A2(v3, v2);
  if ( v7 + 1 - s > 6 && !strncmp(v7 - 6, "/.libs/", 7u) )
  {
    s = v7 + 1;
    if ( !strncmp(v7 + 1, "lt-", 3u) )
    {
      s = v7 + 4;
      program_invocation_short_name = (int)(v7 + 4);
    }
  }
  dword_806C6E6 = (int)s;
  result = s;
  program_invocation_name = (int)s;
  return result;
}
// 80669A2: using guessed type int __fastcall sub_80669A2(_DWORD, _DWORD);
// 806C1B0: using guessed type int dword_806C1B0;
// 806C280: using guessed type int program_invocation_short_name;
// 806C290: using guessed type int program_invocation_name;
// 806C6E6: using guessed type int dword_806C6E6;

//----- (080626B1) --------------------------------------------------------
int __cdecl sub_80626B1(int *a1, unsigned __int8 a2, char a3)
{
  int *v3; // eax
  int v4; // ST10_4

  if ( a1 )
    v3 = a1;
  else
    v3 = &dword_806C6FE;
  v4 = ((unsigned int)v3[(a2 >> 5) + 2] >> (a2 & 0x1F)) & 1;
  v3[(a2 >> 5) + 2] ^= (v4 ^ a3 & 1) << (a2 & 0x1F);
  return v4;
}
// 806C6FE: using guessed type int dword_806C6FE;

//----- (080627B2) --------------------------------------------------------
int *__cdecl sub_80627B2(int *a1, int a2, int a3)
{
  int v3; // ecx
  int *result; // eax
  void *v5; // eax

  if ( !a1 )
    a1 = &dword_806C6FE;
  *a1 = 10;
  v5 = &loc_8062815;
  if ( !a2 )
    v5 = &loc_80627E6;
  dword_806C14C = (int)v5;
  sub_8066C43(v3);
  if ( !a3 )
    abort();
  a1[10] = a2;
  result = a1;
  a1[11] = a3;
  return result;
}
// 8066C43: using guessed type int __fastcall sub_8066C43(_DWORD);
// 806C14C: using guessed type int dword_806C14C;
// 806C6FE: using guessed type int dword_806C6FE;

//----- (08062866) --------------------------------------------------------
_DWORD *__userpurge sub_8062866@<eax>(_DWORD *a1, int a2)
{
  int v3; // [esp+0h] [ebp-38h]
  int v4; // [esp+4h] [ebp-34h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]

  memset(&v3, 0, 0x30u);
  if ( a2 == 10 )
    abort();
  *a1 = a2;
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = v6;
  a1[4] = v7;
  a1[5] = v8;
  a1[6] = v9;
  a1[7] = v10;
  a1[8] = v11;
  a1[9] = v12;
  a1[10] = v13;
  a1[11] = v14;
  return a1;
}

//----- (080628E8) --------------------------------------------------------
const char *__usercall sub_80628E8@<eax>(signed __int32 a1@<ebx>, char *msgid, int a3)
{
  const char *result; // eax
  signed __int32 v4; // ecx
  void *v5; // eax
  signed __int32 v6; // eax
  signed __int32 v7; // ecx
  signed __int32 v8; // et1
  signed __int32 v9; // ecx
  void *v10; // eax
  signed __int32 v11; // ebx
  signed __int32 v12; // edx
  signed __int32 v13; // et2
  int v14; // ecx
  signed __int32 v15; // ebx
  signed __int32 v16; // ecx
  signed __int32 v17; // eax
  signed __int32 v18; // eax
  signed __int32 v19; // ecx
  signed __int32 v20; // ebx
  signed __int32 v21; // edx
  signed __int32 v22; // et2
  signed __int32 v23; // ebx
  signed __int32 v24; // ecx
  char *v25; // [esp+18h] [ebp-10h]
  unsigned __int8 *v26; // [esp+1Ch] [ebp-Ch]

  v25 = gettext(msgid);
  if ( v25 != msgid )
    return v25;
  v26 = (unsigned __int8 *)sub_806618C();
  if ( !sub_8065A2F(v26, "UTF-8") )
  {
    if ( *msgid == 96 )
      v5 = &unk_8067F26;
    else
      v5 = &unk_8067F2A;
    dword_806C14C = (int)&locret_8062A94;
    v6 = _InterlockedExchange(&dword_806C150, (signed __int32)v5);
    _InterlockedExchange(&dword_806C150, v4);
    v8 = _InterlockedExchange(&dword_806C150, sub_8066C43(_InterlockedExchange(&dword_806C150, v6)));
    _InterlockedExchange(&dword_806C150, v7);
    _InterlockedExchange(&dword_806C150, v8);
  }
  if ( sub_8065A2F(v26, "GB18030") )
  {
    v10 = &loc_80629E2;
    if ( a3 != 9 )
      v10 = &loc_806299C;
    dword_806C138 = (int)v10;
    ((void (*)(void))sub_8066CC6)();
    dword_806C14C = (int)&locret_8062A94;
    v11 = _InterlockedExchange(&dword_806C150, a1);
    v13 = _InterlockedExchange(&dword_806C150, v12);
    _InterlockedExchange(&dword_806C150, v11);
    sub_8066C43(v14);
    v15 = _InterlockedExchange(&dword_806C150, v13);
    _InterlockedExchange(&dword_806C150, v16);
    _InterlockedExchange(&dword_806C150, v15);
    result = "'";
  }
  else if ( *msgid == 96 )
  {
    dword_806C188 = (int)&loc_80629BE;
    v17 = _InterlockedExchange(&dword_806C18C, (signed __int32)&unk_8067F36);
    _InterlockedExchange(&dword_806C18C, v9);
    v18 = _InterlockedExchange(&dword_806C18C, sub_8066AB8(_InterlockedExchange(&dword_806C18C, v17)));
    _InterlockedExchange(&dword_806C18C, v19);
    dword_806C138 = (int)&loc_80629B9;
    v20 = _InterlockedExchange(&dword_806C13C, a1);
    v22 = _InterlockedExchange(&dword_806C13C, v21);
    result = (const char *)sub_8066CC6(
                             _InterlockedExchange(&dword_806C18C, v18),
                             _InterlockedExchange(&dword_806C13C, v20));
    v23 = _InterlockedExchange(&dword_806C13C, v22);
    _InterlockedExchange(&dword_806C13C, v24);
    _InterlockedExchange(&dword_806C13C, v23);
  }
  else
  {
    result = (const char *)&unk_8067F3A;
  }
  return result;
}
// 8066AB8: using guessed type int __fastcall sub_8066AB8(_DWORD);
// 8066C43: using guessed type int __fastcall sub_8066C43(_DWORD);
// 8066CC6: using guessed type int __fastcall sub_8066CC6(_DWORD, _DWORD);
// 806C138: using guessed type int dword_806C138;
// 806C13C: using guessed type int dword_806C13C;
// 806C14C: using guessed type int dword_806C14C;
// 806C150: using guessed type int dword_806C150;
// 806C188: using guessed type int dword_806C188;
// 806C18C: using guessed type int dword_806C18C;

//----- (08062A96) --------------------------------------------------------
int __usercall sub_8062A96@<eax>(unsigned __int32 a1@<ebx>, _BYTE *a2, unsigned __int32 a3, const char *a4, size_t a5, signed int a6, int a7, int a8, const char *a9, const char *a10)
{
  int v10; // edx
  int v11; // ecx
  size_t v12; // eax
  signed __int32 v13; // ecx
  signed __int32 v14; // eax
  signed __int32 v15; // ebx
  signed __int32 v16; // edx
  signed __int32 v17; // edx
  signed __int32 v18; // et1
  signed __int32 v19; // eax
  signed __int32 v20; // ecx
  signed __int32 v21; // ett
  void *v22; // eax
  int v23; // ecx
  void *v24; // eax
  const char *v25; // edx
  signed __int32 v26; // ebx
  signed __int32 v27; // et0
  signed __int32 v28; // ebx
  signed __int32 v29; // ecx
  signed __int32 v30; // ecx
  signed __int32 v31; // et1
  void *v32; // eax
  signed __int32 v33; // ebx
  signed __int32 v34; // ecx
  signed __int32 v35; // et2
  signed __int32 v36; // edx
  signed __int32 v37; // ett
  void *v38; // eax
  _BYTE *v39; // edx
  signed __int32 v40; // ebx
  signed __int32 v41; // et0
  signed __int32 v42; // ebx
  signed __int32 v43; // ecx
  signed __int32 v44; // ecx
  signed __int32 v45; // et1
  void *v46; // eax
  const char *v47; // edx
  void *v48; // eax
  void *v49; // eax
  signed __int32 v50; // ecx
  signed __int32 v51; // ebx
  signed __int32 v52; // et0
  signed __int32 v53; // ebx
  signed __int32 v54; // ecx
  signed __int32 v55; // ecx
  signed __int32 v56; // et1
  int v57; // edx
  int v58; // ecx
  int (*v59)(); // eax
  int result; // eax
  const char *v61; // [esp+2Ch] [ebp-5Ch]
  const char *v62; // [esp+30h] [ebp-58h]
  char v63; // [esp+40h] [ebp-48h]
  bool v64; // [esp+41h] [ebp-47h]
  char v65; // [esp+42h] [ebp-46h]
  unsigned __int8 v66; // [esp+45h] [ebp-43h]
  char v67; // [esp+47h] [ebp-41h]
  char v68; // [esp+48h] [ebp-40h]
  bool v69; // [esp+4Ah] [ebp-3Eh]
  bool v70; // [esp+4Bh] [ebp-3Dh]
  const char *i; // [esp+50h] [ebp-38h]
  unsigned __int32 v72; // [esp+54h] [ebp-34h]
  unsigned int v73; // [esp+54h] [ebp-34h]
  unsigned int v74; // [esp+54h] [ebp-34h]
  unsigned int v75; // [esp+54h] [ebp-34h]
  unsigned int v76; // [esp+54h] [ebp-34h]
  unsigned int v77; // [esp+54h] [ebp-34h]
  unsigned int v78; // [esp+54h] [ebp-34h]
  unsigned int v79; // [esp+54h] [ebp-34h]
  unsigned int v80; // [esp+54h] [ebp-34h]
  unsigned int v81; // [esp+54h] [ebp-34h]
  char *s; // [esp+5Ch] [ebp-2Ch]
  char *sa; // [esp+5Ch] [ebp-2Ch]
  size_t n; // [esp+60h] [ebp-28h]
  unsigned int v85; // [esp+70h] [ebp-18h]
  unsigned int v86; // [esp+7Ch] [ebp-Ch]

  v62 = a9;
  v61 = a10;
  v86 = __readgsdword(0x14u);
  v72 = 0;
  s = 0;
  n = 0;
  v63 = 0;
  v70 = __ctype_get_mb_cur_max() == 1;
  v64 = (a7 & 2) != 0;
  v65 = 0;
  switch ( a6 )
  {
    case 0:
      v64 = 0;
      break;
    case 1:
      goto LABEL_19;
    case 2:
      goto LABEL_22;
    case 3:
      v63 = 1;
LABEL_19:
      v64 = 1;
      goto LABEL_20;
    case 4:
LABEL_20:
      if ( v64 != 1 )
        v63 = 1;
LABEL_22:
      a6 = 2;
      if ( v64 != 1 )
      {
        if ( a3 > 0 )
        {
          v10 = (int)a2;
          *a2 = 39;
        }
        v72 = 1;
      }
      s = "'";
      n = 1;
      break;
    case 5:
      goto LABEL_3;
    case 6:
      a6 = 5;
      v64 = 1;
LABEL_3:
      if ( v64 != 1 )
      {
        if ( a3 > 0 )
        {
          v10 = (int)a2;
          *a2 = 34;
        }
        v72 = 1;
      }
      v63 = 1;
      s = (char *)&unk_8067F3D;
      n = 1;
      break;
    case 7:
      v63 = 1;
      v64 = 0;
      break;
    case 8:
    case 9:
    case 10:
      if ( a6 != 10 )
      {
        v62 = sub_80628E8(a1, "`", a6);
        v61 = sub_80628E8(a1, "'", a6);
      }
      if ( v64 != 1 )
      {
        for ( sa = (char *)v62; *sa; ++sa )
        {
          if ( v72 < a3 )
            a2[v72] = *sa;
          ++v72;
        }
      }
      v63 = 1;
      s = (char *)v61;
      n = strlen(v61);
      break;
    default:
      abort();
      return result;
  }
  for ( i = 0; ; ++i )
  {
    v46 = &loc_80638FD;
    if ( a5 != -1 )
      v46 = &loc_806390F;
    dword_806C174 = (int)v46;
    sub_8066B3F(v11, v10);
    v47 = a4;
    if ( !i[(_DWORD)a4] )
      break;
    v67 = 0;
    v68 = 0;
    if ( v63 && a6 != 2 && n )
    {
      a1 = (unsigned __int32)&i[n];
      if ( a5 != -1 || n <= 1 )
      {
        v12 = a5;
      }
      else
      {
        v12 = strlen(a4);
        a5 = v12;
      }
      if ( a1 <= v12 && !memcmp(&a4[(_DWORD)i], s, n) )
      {
        if ( v64 )
        {
          dword_806C124 = (int)&loc_8063AEB;
          v14 = _InterlockedExchange(&dword_806C128, 0);
          _InterlockedExchange(&dword_806C128, v13);
          sub_8066D47(_InterlockedExchange(&dword_806C128, v14));
          v15 = _InterlockedExchange(&dword_806C128, a1);
          v18 = _InterlockedExchange(&dword_806C128, v16);
          v17 = v15;
          a1 = v18;
          _InterlockedExchange(&dword_806C128, v17);
        }
        v67 = 1;
      }
    }
LABEL_134:
    v66 = i[(_DWORD)a4];
    if ( v66 <= 0x7Eu )
      JUMPOUT(__CS__, *(&off_8067F70 + v66));
    v22 = &loc_8063325;
    if ( !v70 )
      v22 = &loc_8063353;
    dword_806C188 = (int)v22;
    sub_8066AB8(v13);
    v69 = ((*__ctype_b_loc())[v66] & 0x4000) != 0;
    v24 = &loc_806351C;
    if ( !v63 )
      v24 = &loc_8063790;
    dword_806C14C = (int)v24;
    sub_8066C43(v23);
    if ( v69 != 1 )
    {
      v25 = i;
      v85 = (unsigned int)(i + 1);
      while ( 1 )
      {
        if ( v63 && v69 != 1 )
        {
          if ( v64 )
          {
            dword_806C138 = (int)&loc_8063AEB;
            v26 = _InterlockedExchange(&dword_806C13C, a1);
            v27 = _InterlockedExchange(&dword_806C13C, v11);
            sub_8066CC6(_InterlockedExchange(&dword_806C13C, v26), v25);
            v28 = _InterlockedExchange(&dword_806C13C, v27);
            v31 = _InterlockedExchange(&dword_806C13C, v29);
            v30 = v28;
            a1 = v31;
            v11 = _InterlockedExchange(&dword_806C13C, v30);
          }
          v68 = 1;
          if ( a6 == 2 )
          {
            v32 = &loc_80635BA;
            if ( v65 == 1 )
              v32 = &loc_8063603;
            dword_806C174 = (int)v32;
            sub_8066B3F(v11, v25);
            if ( v72 < a3 )
              a2[v72] = 39;
            v73 = v72 + 1;
            if ( v73 < a3 )
              a2[v73] = 36;
            v74 = v73 + 1;
            if ( v74 < a3 )
              a2[v74] = 39;
            v72 = v74 + 1;
            v65 = 1;
          }
          if ( v72 < a3 )
            a2[v72] = 92;
          v75 = v72 + 1;
          if ( v75 < a3 )
            a2[v75] = (v66 >> 6) + 48;
          v76 = v75 + 1;
          if ( v76 < a3 )
            a2[v76] = ((v66 >> 3) & 7) + 48;
          v72 = v76 + 1;
          v66 = (v66 & 7) + 48;
          dword_806C160 = (int)&loc_80636DA;
          v33 = _InterlockedExchange(&dword_806C164, a1);
          v35 = _InterlockedExchange(&dword_806C164, v11);
          v34 = v33;
          a1 = v35;
          v37 = _InterlockedExchange(&dword_806C164, sub_8066BC0(_InterlockedExchange(&dword_806C164, v34)));
          _InterlockedExchange(&dword_806C164, v36);
          _InterlockedExchange(&dword_806C164, v37);
        }
        v38 = &loc_80636BF;
        if ( !v67 )
          v38 = &loc_80636DA;
        dword_806C160 = (int)v38;
        sub_8066BC0(v11);
        if ( v72 < a3 )
        {
          v39 = a2;
          a2[v72] = 92;
        }
        v77 = v72 + 1;
        v67 = 0;
        if ( (unsigned int)(i + 1) >= v85 )
        {
          dword_806C174 = (int)&loc_806386E;
          v40 = _InterlockedExchange(&dword_806C178, a1);
          v41 = _InterlockedExchange(&dword_806C178, v11);
          sub_8066B3F(_InterlockedExchange(&dword_806C178, v40), v39);
          v42 = _InterlockedExchange(&dword_806C178, v41);
          v45 = _InterlockedExchange(&dword_806C178, v43);
          v44 = v42;
          a1 = v45;
          v11 = _InterlockedExchange(&dword_806C178, v44);
        }
        if ( v65 && v68 != 1 )
        {
          if ( v77 < a3 )
            a2[v77] = 39;
          v78 = v77 + 1;
          if ( v78 < a3 )
            a2[v78] = 39;
          v77 = v78 + 1;
          v65 = 0;
        }
        if ( v77 < a3 )
          a2[v77] = v66;
        v72 = v77 + 1;
        ++i;
        v25 = a4;
        v66 = i[(_DWORD)a4];
      }
    }
    if ( (v63 == 1 && a6 != 2 || v64 == 1)
      && a8
      && (v11 = v66 & 0x1F, v10 = *(_DWORD *)(4 * (v66 >> 5) + a8) >> v11, v10 & 1)
      || v67 == 1 )
    {
      if ( v64 )
        goto LABEL_136;
      v68 = 1;
      if ( a6 == 2 && v65 != 1 )
      {
        if ( v72 < a3 )
        {
          v10 = (int)a2;
          a2[v72] = 39;
        }
        v79 = v72 + 1;
        if ( v79 < a3 )
        {
          v10 = (int)a2;
          a2[v79] = 36;
        }
        v80 = v79 + 1;
        if ( v80 < a3 )
        {
          v10 = (int)a2;
          a2[v80] = 39;
        }
        v72 = v80 + 1;
        v65 = 1;
      }
      if ( v72 < a3 )
      {
        v10 = (int)a2;
        a2[v72] = 92;
      }
      ++v72;
    }
    if ( v65 && v68 != 1 )
    {
      if ( v72 < a3 )
      {
        v10 = (int)a2;
        a2[v72] = 39;
      }
      v81 = v72 + 1;
      if ( v81 < a3 )
      {
        v10 = (int)a2;
        a2[v81] = 39;
      }
      v72 = v81 + 1;
      v65 = 0;
    }
    if ( v72 < a3 )
    {
      v10 = (int)&a2[v72];
      a2[v72] = v66;
    }
    ++v72;
  }
  if ( !v72 )
  {
    v48 = &loc_8063945;
    if ( a6 != 2 )
      v48 = &loc_8063950;
    dword_806C110 = (int)v48;
    sub_8066DC7(v13);
    if ( v64 )
      goto LABEL_136;
  }
  v49 = &loc_806396F;
  if ( a6 != 2 )
    v49 = &loc_8063A40;
  dword_806C19C = (int)v49;
  sub_8066A1E(v13, v47);
  if ( s && v64 != 1 )
  {
    while ( *s )
    {
      if ( v72 < a3 )
        a2[v72] = *s;
      ++v72;
      ++s;
    }
  }
  if ( v72 < a3 )
  {
    a2[v72] = 0;
    dword_806C110 = (int)&loc_8062D31;
    v51 = _InterlockedExchange(&dword_806C114, a1);
    v52 = _InterlockedExchange(&dword_806C114, v50);
    sub_8066DC7(_InterlockedExchange(&dword_806C114, v51));
    v53 = _InterlockedExchange(&dword_806C114, v52);
    v56 = _InterlockedExchange(&dword_806C114, v54);
    v55 = v53;
    a1 = v56;
    v13 = _InterlockedExchange(&dword_806C114, v55);
    goto LABEL_134;
  }
  dword_806C1C4 = (int)&loc_8063B47;
  v19 = _InterlockedExchange(&dword_806C1C8, v72);
  _InterlockedExchange(&dword_806C1C8, v50);
  v21 = _InterlockedExchange(&dword_806C1C8, sub_806691B(_InterlockedExchange(&dword_806C1C8, v19)));
  _InterlockedExchange(&dword_806C1C8, v20);
  _InterlockedExchange(&dword_806C1C8, v21);
LABEL_136:
  if ( a6 == 2 && v63 )
    a6 = 4;
  sub_8062A96(a2, a3, a4, a5, a6, a7 & 0xFFFFFFFD, 0, v62, v61);
  v59 = (int (*)())&loc_8063B6C;
  if ( __readgsdword(0x14u) == v86 )
    v59 = sub_8063B71;
  dword_806C1D8 = (int)v59;
  return sub_806689B(v58, v57);
}
// 8063B71: using guessed type int sub_8063B71();
// 8066803: using guessed type int __fastcall sub_8066803(_DWORD);
// 806689B: using guessed type int __fastcall sub_806689B(_DWORD, _DWORD);
// 806691B: using guessed type int __fastcall sub_806691B(_DWORD);
// 80669A2: using guessed type int __fastcall sub_80669A2(_DWORD, _DWORD);
// 8066A1E: using guessed type int __fastcall sub_8066A1E(_DWORD, _DWORD);
// 8066AB8: using guessed type int __fastcall sub_8066AB8(_DWORD);
// 8066B3F: using guessed type int __fastcall sub_8066B3F(_DWORD, _DWORD);
// 8066BC0: using guessed type int __fastcall sub_8066BC0(_DWORD);
// 8066C43: using guessed type int __fastcall sub_8066C43(_DWORD);
// 8066CC6: using guessed type int __fastcall sub_8066CC6(_DWORD, _DWORD);
// 8066D47: using guessed type int __fastcall sub_8066D47(_DWORD);
// 8066DC7: using guessed type int __fastcall sub_8066DC7(_DWORD);
// 8067F70: using guessed type void *off_8067F70;
// 806C110: using guessed type int dword_806C110;
// 806C114: using guessed type int dword_806C114;
// 806C124: using guessed type int dword_806C124;
// 806C128: using guessed type int dword_806C128;
// 806C138: using guessed type int dword_806C138;
// 806C13C: using guessed type int dword_806C13C;
// 806C14C: using guessed type int dword_806C14C;
// 806C160: using guessed type int dword_806C160;
// 806C164: using guessed type int dword_806C164;
// 806C174: using guessed type int dword_806C174;
// 806C178: using guessed type int dword_806C178;
// 806C188: using guessed type int dword_806C188;
// 806C19C: using guessed type int dword_806C19C;
// 806C1B0: using guessed type int dword_806C1B0;
// 806C1C4: using guessed type int dword_806C1C4;
// 806C1C8: using guessed type int dword_806C1C8;
// 806C1D8: using guessed type int dword_806C1D8;
// 806C1EC: using guessed type int dword_806C1EC;

//----- (08063B71) --------------------------------------------------------
#error "8063B74: positive sp value has been found (funcsize=0)"

//----- (08063C2E) --------------------------------------------------------
_BYTE *__cdecl sub_8063C2E(const char *a1, size_t a2, _DWORD *a3, int a4)
{
  int v4; // ecx
  void *v5; // eax
  int v6; // ST44_4
  int v7; // ST48_4
  int v8; // ST4C_4
  int size; // [esp+48h] [ebp-10h]
  _BYTE *v11; // [esp+4Ch] [ebp-Ch]

  v5 = &loc_8063C54;
  if ( !a4 )
    v5 = &loc_8063C59;
  dword_806C14C = (int)v5;
  sub_8066C43(v4);
  v6 = a4;
  v7 = *__errno_location();
  v8 = *(_DWORD *)(a4 + 4) | (a3 == 0);
  size = sub_8062A96(
           v6 + 8,
           0,
           0,
           a1,
           a2,
           *(_DWORD *)v6,
           *(_DWORD *)(v6 + 4) | (a3 == 0),
           v6 + 8,
           *(const char **)(v6 + 40),
           *(const char **)(v6 + 44))
       + 1;
  v11 = sub_806515A(size);
  sub_8062A96(
    v6 + 8,
    v11,
    size,
    a1,
    a2,
    *(_DWORD *)v6,
    v8,
    v6 + 8,
    *(const char **)(v6 + 40),
    *(const char **)(v6 + 44));
  *__errno_location() = v7;
  if ( a3 )
    *a3 = size - 1;
  return v11;
}
// 8066C43: using guessed type int __fastcall sub_8066C43(_DWORD);
// 806C14C: using guessed type int dword_806C14C;

//----- (08063DEE) --------------------------------------------------------
_BYTE *__cdecl sub_8063DEE(signed int a1, const char *a2, size_t a3, int a4)
{
  int v4; // ecx
  void *v5; // eax
  size_t v6; // edx
  int *v7; // eax
  int v8; // ecx
  void *v9; // eax
  void *v10; // edx
  size_t v11; // ST4C_4
  int v12; // ecx
  int *v13; // edx
  void *v14; // eax
  bool v16; // [esp+37h] [ebp-21h]
  int *v17; // [esp+38h] [ebp-20h]
  _BYTE *ptr; // [esp+3Ch] [ebp-1Ch]
  int v19; // [esp+40h] [ebp-18h]
  int size; // [esp+44h] [ebp-14h]
  int v21; // [esp+48h] [ebp-10h]
  unsigned int v22; // [esp+4Ch] [ebp-Ch]

  v19 = *__errno_location();
  v17 = off_806C238;
  if ( a1 < 0 )
    abort();
  if ( dword_806C22C <= a1 )
  {
    v16 = off_806C238 == &dword_806C230;
    if ( (unsigned int)a1 > 0xFFFFFFE )
      sub_806530B();
    v5 = &loc_8063EC3;
    if ( !v16 )
      v5 = &loc_8063E1B;
    dword_806C160 = (int)v5;
    sub_8066BC0(v4);
    v7 = (int *)sub_80651B2(0, v6);
    v17 = v7;
    off_806C238 = v7;
    v9 = &loc_8063F49;
    if ( !v16 )
      v9 = &loc_8063F5C;
    dword_806C1EC = (int)v9;
    sub_8066803(v8);
    v10 = off_806C234;
    *v17 = dword_806C230;
    v17[1] = (int)v10;
    memset(&v17[2 * dword_806C22C], 0, 8 * (a1 + 1 - dword_806C22C));
    dword_806C22C = a1 + 1;
  }
  v11 = v17[2 * a1];
  ptr = (_BYTE *)v17[2 * a1 + 1];
  v21 = *(_DWORD *)(a4 + 4) | 1;
  v22 = sub_8062A96(
          a4 + 8,
          (_BYTE *)v17[2 * a1 + 1],
          v17[2 * a1],
          a2,
          a3,
          *(_DWORD *)a4,
          v21,
          a4 + 8,
          *(const char **)(a4 + 40),
          *(const char **)(a4 + 44));
  if ( v11 <= v22 )
  {
    v13 = &v17[2 * a1];
    size = v22 + 1;
    *v13 = v22 + 1;
    v14 = &loc_8064073;
    if ( ptr == (_BYTE *)&unk_806C73E )
      v14 = &loc_806407E;
    dword_806C138 = (int)v14;
    sub_8066CC6(v12, v13);
    free(ptr);
    ptr = sub_806515A(size);
    v17[2 * a1 + 1] = (int)ptr;
    sub_8062A96(
      a4 + 8,
      ptr,
      size,
      a2,
      a3,
      *(_DWORD *)a4,
      v21,
      a4 + 8,
      *(const char **)(a4 + 40),
      *(const char **)(a4 + 44));
  }
  *__errno_location() = v19;
  return ptr;
}
// 8066803: using guessed type int __fastcall sub_8066803(_DWORD);
// 8066BC0: using guessed type int __fastcall sub_8066BC0(_DWORD);
// 8066CC6: using guessed type int __fastcall sub_8066CC6(_DWORD, _DWORD);
// 806C138: using guessed type int dword_806C138;
// 806C160: using guessed type int dword_806C160;
// 806C1EC: using guessed type int dword_806C1EC;
// 806C22C: using guessed type int dword_806C22C;
// 806C230: using guessed type int dword_806C230;
// 806C234: using guessed type void *off_806C234;
// 806C238: using guessed type int *off_806C238;

//----- (08064103) --------------------------------------------------------
_BYTE *__cdecl sub_8064103(signed int a1, const char *a2)
{
  return sub_8063DEE(a1, a2, 0xFFFFFFFF, (int)&dword_806C6FE);
}
// 806C6FE: using guessed type int dword_806C6FE;

//----- (0806412D) --------------------------------------------------------
_BYTE *__cdecl sub_806412D(signed int a1, const char *a2, size_t a3)
{
  return sub_8063DEE(a1, a2, a3, (int)&dword_806C6FE);
}
// 806C6FE: using guessed type int dword_806C6FE;

//----- (08064193) --------------------------------------------------------
_BYTE *__cdecl sub_8064193(signed int a1, int a2, const char *a3)
{
  char v4; // [esp+10h] [ebp-38h]

  sub_8062866(&v4, a2);
  return sub_8063DEE(a1, a3, 0xFFFFFFFF, (int)&v4);
}

//----- (080641D1) --------------------------------------------------------
int __usercall sub_80641D1@<eax>(signed __int32 a1@<ebx>, signed int a2, int a3, const char *a4, size_t a5)
{
  _BYTE *v5; // eax
  signed __int32 v6; // eax
  signed __int32 v7; // ecx
  signed __int32 v8; // ebx
  signed __int32 v9; // ecx
  char v11; // [esp+10h] [ebp-38h]

  sub_8062866(&v11, a3);
  v5 = sub_8063DEE(a2, a4, a5, (int)&v11);
  dword_806C1EC = (int)&locret_8064292;
  v6 = _InterlockedExchange(&dword_806C1F0, (signed __int32)v5);
  _InterlockedExchange(&dword_806C1F0, v7);
  sub_8066803(_InterlockedExchange(&dword_806C1F0, v6));
  v8 = _InterlockedExchange(&dword_806C1F0, a1);
  _InterlockedExchange(&dword_806C1F0, v9);
  _InterlockedExchange(&dword_806C1F0, v8);
  return sub_80641D1(0, a2, a3, a4);
}
// 8066803: using guessed type int __fastcall sub_8066803(_DWORD);
// 806C1EC: using guessed type int dword_806C1EC;
// 806C1F0: using guessed type int dword_806C1F0;

//----- (0806437E) --------------------------------------------------------
_BYTE *__cdecl sub_806437E(const char *a1, size_t a2, unsigned __int8 a3)
{
  int v4; // [esp+20h] [ebp-38h]
  int v5; // [esp+24h] [ebp-34h]
  int v6; // [esp+28h] [ebp-30h]
  int v7; // [esp+2Ch] [ebp-2Ch]
  int v8; // [esp+30h] [ebp-28h]
  int v9; // [esp+34h] [ebp-24h]
  int v10; // [esp+38h] [ebp-20h]
  int v11; // [esp+3Ch] [ebp-1Ch]
  int v12; // [esp+40h] [ebp-18h]
  int v13; // [esp+44h] [ebp-14h]
  int v14; // [esp+48h] [ebp-10h]
  int v15; // [esp+4Ch] [ebp-Ch]

  v4 = dword_806C6FE;
  v5 = dword_806C702;
  v6 = dword_806C706;
  v7 = dword_806C70A;
  v8 = dword_806C70E;
  v9 = dword_806C712;
  v10 = dword_806C716;
  v11 = dword_806C71A;
  v12 = dword_806C71E;
  v13 = dword_806C722;
  v14 = dword_806C726;
  v15 = dword_806C72A;
  sub_80626B1(&v4, a3, 1);
  return sub_8063DEE(0, a1, a2, (int)&v4);
}
// 806C6FE: using guessed type int dword_806C6FE;
// 806C702: using guessed type int dword_806C702;
// 806C706: using guessed type int dword_806C706;
// 806C70A: using guessed type int dword_806C70A;
// 806C70E: using guessed type int dword_806C70E;
// 806C712: using guessed type int dword_806C712;
// 806C716: using guessed type int dword_806C716;
// 806C71A: using guessed type int dword_806C71A;
// 806C71E: using guessed type int dword_806C71E;
// 806C722: using guessed type int dword_806C722;
// 806C726: using guessed type int dword_806C726;
// 806C72A: using guessed type int dword_806C72A;

//----- (08064428) --------------------------------------------------------
_BYTE *__cdecl sub_8064428(const char *a1, unsigned __int8 a2)
{
  return sub_806437E(a1, 0xFFFFFFFF, a2);
}

//----- (08064451) --------------------------------------------------------
_BYTE *__cdecl sub_8064451(const char *a1)
{
  return sub_8064428(a1, 0x3Au);
}

//----- (08064540) --------------------------------------------------------
_BYTE *__cdecl sub_8064540(signed int a1, int a2, const char *a3)
{
  int v4; // [esp+10h] [ebp-68h]
  int v5; // [esp+14h] [ebp-64h]
  int v6; // [esp+18h] [ebp-60h]
  int v7; // [esp+1Ch] [ebp-5Ch]
  int v8; // [esp+20h] [ebp-58h]
  int v9; // [esp+24h] [ebp-54h]
  int v10; // [esp+28h] [ebp-50h]
  int v11; // [esp+2Ch] [ebp-4Ch]
  int v12; // [esp+30h] [ebp-48h]
  int v13; // [esp+34h] [ebp-44h]
  int v14; // [esp+38h] [ebp-40h]
  int v15; // [esp+3Ch] [ebp-3Ch]
  int v16; // [esp+40h] [ebp-38h]
  int v17; // [esp+44h] [ebp-34h]
  int v18; // [esp+48h] [ebp-30h]
  int v19; // [esp+4Ch] [ebp-2Ch]
  int v20; // [esp+50h] [ebp-28h]
  int v21; // [esp+54h] [ebp-24h]
  int v22; // [esp+58h] [ebp-20h]
  int v23; // [esp+5Ch] [ebp-1Ch]
  int v24; // [esp+60h] [ebp-18h]
  int v25; // [esp+64h] [ebp-14h]
  int v26; // [esp+68h] [ebp-10h]
  int v27; // [esp+6Ch] [ebp-Ch]

  sub_8062866(&v4, a2);
  v16 = v4;
  v17 = v5;
  v18 = v6;
  v19 = v7;
  v20 = v8;
  v21 = v9;
  v22 = v10;
  v23 = v11;
  v24 = v12;
  v25 = v13;
  v26 = v14;
  v27 = v15;
  sub_80626B1(&v16, 0x3Au, 1);
  return sub_8063DEE(a1, a3, 0xFFFFFFFF, (int)&v16);
}

//----- (08064681) --------------------------------------------------------
signed __int32 __cdecl sub_8064681(signed int a1, int a2, int a3, const char *a4)
{
  return sub_80646B1(a1, a2, a3, a4, 0xFFFFFFFF);
}

//----- (080646B1) --------------------------------------------------------
signed __int32 __cdecl sub_80646B1(signed int a1, int a2, int a3, const char *a4, size_t a5)
{
  _BYTE *v5; // eax
  signed __int32 v6; // eax
  signed __int32 v7; // edx
  int v8; // ecx
  signed __int32 v9; // ecx
  signed __int32 result; // eax
  signed __int32 v11; // et1
  int v12; // [esp+10h] [ebp-38h]
  int v13; // [esp+14h] [ebp-34h]
  int v14; // [esp+18h] [ebp-30h]
  int v15; // [esp+1Ch] [ebp-2Ch]
  int v16; // [esp+20h] [ebp-28h]
  int v17; // [esp+24h] [ebp-24h]
  int v18; // [esp+28h] [ebp-20h]
  int v19; // [esp+2Ch] [ebp-1Ch]
  int v20; // [esp+30h] [ebp-18h]
  int v21; // [esp+34h] [ebp-14h]
  int v22; // [esp+38h] [ebp-10h]
  int v23; // [esp+3Ch] [ebp-Ch]

  v12 = dword_806C6FE;
  v13 = dword_806C702;
  v14 = dword_806C706;
  v15 = dword_806C70A;
  v16 = dword_806C70E;
  v17 = dword_806C712;
  v18 = dword_806C716;
  v19 = dword_806C71A;
  v20 = dword_806C71E;
  v21 = dword_806C722;
  v22 = dword_806C726;
  v23 = dword_806C72A;
  sub_80627B2(&v12, a2, a3);
  v5 = sub_8063DEE(a1, a4, a5, (int)&v12);
  dword_806C160 = (int)sub_80647B2;
  v6 = _InterlockedExchange(&dword_806C164, (signed __int32)v5);
  _InterlockedExchange(&dword_806C164, v7);
  _InterlockedExchange(&dword_806C164, v6);
  v11 = _InterlockedExchange(&dword_806C164, sub_8066BC0(v8));
  result = _InterlockedExchange(&dword_806C164, v9);
  _InterlockedExchange(&dword_806C164, v11);
  return result;
}
// 80647B2: using guessed type int sub_80647B2();
// 8066BC0: using guessed type int __fastcall sub_8066BC0(_DWORD);
// 806C160: using guessed type int dword_806C160;
// 806C164: using guessed type int dword_806C164;
// 806C6FE: using guessed type int dword_806C6FE;
// 806C702: using guessed type int dword_806C702;
// 806C706: using guessed type int dword_806C706;
// 806C70A: using guessed type int dword_806C70A;
// 806C70E: using guessed type int dword_806C70E;
// 806C712: using guessed type int dword_806C712;
// 806C716: using guessed type int dword_806C716;
// 806C71A: using guessed type int dword_806C71A;
// 806C71E: using guessed type int dword_806C71E;
// 806C722: using guessed type int dword_806C722;
// 806C726: using guessed type int dword_806C726;
// 806C72A: using guessed type int dword_806C72A;

//----- (080647E6) --------------------------------------------------------
_BYTE *__cdecl sub_80647E6(signed int a1, const char *a2, size_t a3)
{
  return sub_8063DEE(a1, a2, a3, (int)&unk_806C24C);
}

//----- (08064831) --------------------------------------------------------
_BYTE *__cdecl sub_8064831(signed int a1, const char *a2)
{
  return sub_80647E6(a1, a2, 0xFFFFFFFF);
}

//----- (0806486E) --------------------------------------------------------
int __usercall sub_806486E@<eax>(signed __int32 a1@<ebx>, int fd)
{
  return sub_8065442(a1, fd, 0, 3);
}

//----- (08064891) --------------------------------------------------------
int __cdecl sub_8064891(FILE *stream, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // ecx
  void *v7; // eax
  char *v8; // eax
  char *v9; // eax
  signed __int32 v10; // ebx
  char *v11; // eax
  int result; // eax
  int v13; // esi
  signed __int32 v14; // ebx
  char *v15; // eax
  int v16; // edi
  int v17; // esi
  signed __int32 v18; // ebx
  char *v19; // eax
  int v20; // ST54_4
  int v21; // edi
  int v22; // esi
  signed __int32 v23; // ebx
  char *v24; // eax
  signed __int32 v25; // ebx
  signed __int32 v26; // ecx
  signed __int32 v27; // edx
  signed __int32 v28; // et1
  int v29; // ST54_4
  int v30; // ST50_4
  int v31; // edi
  int v32; // esi
  signed __int32 v33; // ebx
  char *v34; // eax
  int v35; // ST54_4
  int v36; // ST50_4
  int v37; // ST4C_4
  int v38; // edi
  int v39; // esi
  signed __int32 v40; // ebx
  char *v41; // eax
  int v42; // esi
  int v43; // ST54_4
  int v44; // ST50_4
  int v45; // ST4C_4
  int v46; // ST48_4
  int v47; // edi
  signed __int32 v48; // ebx
  char *v49; // eax
  int v50; // edi
  int v51; // ST54_4
  int v52; // ST50_4
  int v53; // ST4C_4
  int v54; // ST48_4
  int v55; // ST44_4
  int v56; // esi
  signed __int32 v57; // ebx
  char *v58; // eax
  int v59; // edi
  int v60; // ST54_4
  int v61; // ST50_4
  int v62; // ST4C_4
  int v63; // ST48_4
  int v64; // ST44_4
  int v65; // ST40_4
  int v66; // esi
  signed __int32 v67; // ebx
  char *v68; // eax
  int v69; // edi
  int v70; // ST54_4
  int v71; // ST50_4
  int v72; // ST4C_4
  int v73; // ST48_4
  int v74; // ST44_4
  int v75; // ST40_4
  int v76; // esi
  signed __int32 v77; // ebx
  char *v78; // eax

  v7 = &loc_80648B9;
  if ( !a2 )
    v7 = &loc_80648E3;
  dword_806C160 = (int)v7;
  sub_8066BC0(v6);
  fprintf(stream, "%s (%s) %s\n", a2, a3, a4);
  v8 = gettext("(C)");
  fprintf(stream, "Copyright %s %d Free Software Foundation, Inc.", v8, 2017);
  v9 = gettext(
         "\n"
         "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\n"
         "This is free software: you are free to change and redistribute it.\n"
         "There is NO WARRANTY, to the extent permitted by law.\n"
         "\n");
  fputs_unlocked(v9, stream);
  switch ( a6 )
  {
    case 0:
      abort();
      return result;
    case 1:
      v10 = *(_DWORD *)a5;
      v11 = gettext("Written by %s.\n");
      return fprintf(stream, v11, v10);
    case 2:
      v13 = *(_DWORD *)(a5 + 4);
      v14 = *(_DWORD *)a5;
      v15 = gettext("Written by %s and %s.\n");
      return fprintf(stream, v15, v14, v13);
    case 3:
      v16 = *(_DWORD *)(a5 + 8);
      v17 = *(_DWORD *)(a5 + 4);
      v18 = *(_DWORD *)a5;
      v19 = gettext("Written by %s, %s, and %s.\n");
      return fprintf(stream, v19, v18, v17, v16);
    case 4:
      v20 = *(_DWORD *)(a5 + 12);
      v21 = *(_DWORD *)(a5 + 8);
      v22 = *(_DWORD *)(a5 + 4);
      v23 = *(_DWORD *)a5;
      v24 = gettext("Written by %s, %s, %s,\nand %s.\n");
      fprintf(stream, v24, v23, v22, v21, v20);
      dword_806C14C = (int)&loc_8064DE0;
      v25 = _InterlockedExchange(&dword_806C150, v23);
      _InterlockedExchange(&dword_806C150, v26);
      v28 = _InterlockedExchange(&dword_806C150, sub_8066C43(_InterlockedExchange(&dword_806C150, v25)));
      _InterlockedExchange(&dword_806C150, v27);
      _InterlockedExchange(&dword_806C150, v28);
      goto LABEL_9;
    case 5:
LABEL_9:
      v29 = *(_DWORD *)(a5 + 16);
      v30 = *(_DWORD *)(a5 + 12);
      v31 = *(_DWORD *)(a5 + 8);
      v32 = *(_DWORD *)(a5 + 4);
      v33 = *(_DWORD *)a5;
      v34 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
      result = fprintf(stream, v34, v33, v32, v31, v30, v29);
      break;
    case 6:
      v35 = *(_DWORD *)(a5 + 20);
      v36 = *(_DWORD *)(a5 + 16);
      v37 = *(_DWORD *)(a5 + 12);
      v38 = *(_DWORD *)(a5 + 8);
      v39 = *(_DWORD *)(a5 + 4);
      v40 = *(_DWORD *)a5;
      v41 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
      result = fprintf(stream, v41, v40, v39, v38, v37, v36, v35);
      break;
    case 7:
      v42 = *(_DWORD *)(a5 + 24);
      v43 = *(_DWORD *)(a5 + 20);
      v44 = *(_DWORD *)(a5 + 16);
      v45 = *(_DWORD *)(a5 + 12);
      v46 = *(_DWORD *)(a5 + 8);
      v47 = *(_DWORD *)(a5 + 4);
      v48 = *(_DWORD *)a5;
      v49 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
      result = fprintf(stream, v49, v48, v47, v46, v45, v44, v43, v42);
      break;
    case 8:
      v50 = *(_DWORD *)(a5 + 28);
      v51 = *(_DWORD *)(a5 + 24);
      v52 = *(_DWORD *)(a5 + 20);
      v53 = *(_DWORD *)(a5 + 16);
      v54 = *(_DWORD *)(a5 + 12);
      v55 = *(_DWORD *)(a5 + 8);
      v56 = *(_DWORD *)(a5 + 4);
      v57 = *(_DWORD *)a5;
      v58 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
      result = fprintf(stream, v58, v57, v56, v55, v54, v53, v52, v51, v50);
      break;
    case 9:
      v59 = *(_DWORD *)(a5 + 32);
      v60 = *(_DWORD *)(a5 + 28);
      v61 = *(_DWORD *)(a5 + 24);
      v62 = *(_DWORD *)(a5 + 20);
      v63 = *(_DWORD *)(a5 + 16);
      v64 = *(_DWORD *)(a5 + 12);
      v65 = *(_DWORD *)(a5 + 8);
      v66 = *(_DWORD *)(a5 + 4);
      v67 = *(_DWORD *)a5;
      v68 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
      result = fprintf(stream, v68, v67, v66, v65, v64, v63, v62, v61, v60, v59);
      break;
    default:
      v69 = *(_DWORD *)(a5 + 32);
      v70 = *(_DWORD *)(a5 + 28);
      v71 = *(_DWORD *)(a5 + 24);
      v72 = *(_DWORD *)(a5 + 20);
      v73 = *(_DWORD *)(a5 + 16);
      v74 = *(_DWORD *)(a5 + 12);
      v75 = *(_DWORD *)(a5 + 8);
      v76 = *(_DWORD *)(a5 + 4);
      v77 = *(_DWORD *)a5;
      v78 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
      result = fprintf(stream, v78, v77, v76, v75, v74, v73, v72, v71, v70, v69);
      break;
  }
  return result;
}
// 8048F20: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8066BC0: using guessed type int __fastcall sub_8066BC0(_DWORD);
// 8066C43: using guessed type int __fastcall sub_8066C43(_DWORD);
// 806C14C: using guessed type int dword_806C14C;
// 806C150: using guessed type int dword_806C150;
// 806C160: using guessed type int dword_806C160;

//----- (08064E40) --------------------------------------------------------
int __usercall sub_8064E40@<eax>(signed __int32 a1@<edx>, int a2@<ecx>, signed __int32 a3@<ebx>, FILE *stream, int a5, int a6, int a7, int a8)
{
  signed __int32 v8; // ebx
  signed __int32 v9; // edx
  signed __int32 v10; // et1
  int *v11; // eax
  int v13; // [esp+24h] [ebp-34h]
  int v14[12]; // [esp+28h] [ebp-30h]

  v13 = 0;
  dword_806C1D8 = (int)&loc_8064E87;
  v8 = _InterlockedExchange(&dword_806C1DC, a3);
  _InterlockedExchange(&dword_806C1DC, a1);
  v10 = _InterlockedExchange(&dword_806C1DC, sub_806689B(a2, _InterlockedExchange(&dword_806C1DC, v8)));
  _InterlockedExchange(&dword_806C1DC, v9);
  _InterlockedExchange(&dword_806C1DC, v10);
  do
  {
    if ( (unsigned int)++v13 > 9 )
      break;
    v11 = (int *)a8;
    a8 += 4;
    v14[v13] = *v11;
  }
  while ( v14[v13] );
  return sub_8064891(stream, a5, a6, a7, (int)v14, v13);
}
// 806689B: using guessed type int __fastcall sub_806689B(_DWORD, _DWORD);
// 806C1D8: using guessed type int dword_806C1D8;
// 806C1DC: using guessed type int dword_806C1DC;
// 8064E40: using guessed type int var_30[12];

//----- (08064EDA) --------------------------------------------------------
int __usercall sub_8064EDA@<eax>(signed __int32 a1@<edx>, int a2@<ecx>, signed __int32 a3@<ebx>, FILE *stream, int a5, int a6, int a7, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a7);
  return sub_8064E40(a1, a2, a3, stream, a5, a6, a7, (int)va);
}

//----- (08064FDD) --------------------------------------------------------
void *__cdecl sub_8064FDD(void *ptr, int a2, int a3)
{
  unsigned int v4; // [esp+1Ch] [ebp-Ch]

  v4 = *(_DWORD *)a2;
  if ( ptr )
  {
    if ( 0x55555554u / a3 <= v4 )
      sub_806530B();
    v4 += (v4 >> 1) + 1;
  }
  else
  {
    if ( !v4 )
      v4 = (0x40u / a3 == 0) + 0x40u / a3;
    if ( 0x7FFFFFFFu / a3 < v4 )
      sub_806530B();
  }
  *(_DWORD *)a2 = v4;
  return sub_80651B2(ptr, a3 * v4);
}

//----- (0806515A) --------------------------------------------------------
void *__cdecl sub_806515A(size_t size)
{
  return sub_806516D(size);
}

//----- (0806516D) --------------------------------------------------------
void *__cdecl sub_806516D(size_t size)
{
  void *v2; // [esp+1Ch] [ebp-Ch]

  v2 = malloc(size);
  if ( !v2 && size )
    sub_806530B();
  return v2;
}

//----- (080651B2) --------------------------------------------------------
void *__cdecl sub_80651B2(void *ptr, size_t size)
{
  signed __int32 v2; // eax
  signed __int32 v3; // edx
  int v4; // ecx
  signed __int32 v5; // edx
  signed __int32 v6; // et1
  void *ptra; // [esp+20h] [ebp+8h]

  if ( !size && ptr )
  {
    free(ptr);
    dword_806C1D8 = (int)&locret_8065232;
    v2 = _InterlockedExchange(&dword_806C1DC, 0);
    _InterlockedExchange(&dword_806C1DC, v3);
    v6 = _InterlockedExchange(&dword_806C1DC, sub_806689B(v4, _InterlockedExchange(&dword_806C1DC, v2)));
    _InterlockedExchange(&dword_806C1DC, v5);
    _InterlockedExchange(&dword_806C1DC, v6);
  }
  ptra = realloc(ptr, size);
  if ( !ptra && size )
    sub_806530B();
  return ptra;
}
// 806689B: using guessed type int __fastcall sub_806689B(_DWORD, _DWORD);
// 806C1D8: using guessed type int dword_806C1D8;
// 806C1DC: using guessed type int dword_806C1DC;

//----- (080652BD) --------------------------------------------------------
void *__cdecl sub_80652BD(void *src, size_t n)
{
  void *v2; // eax

  v2 = sub_806516D(n);
  return memcpy(v2, src, n);
}

//----- (0806530B) --------------------------------------------------------
void __noreturn sub_806530B()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (08065344) --------------------------------------------------------
int __cdecl sub_8065344(FILE *stream)
{
  void *v2; // eax
  int v3; // eax
  __int64 v4; // rax
  int v5; // ecx
  int v6; // [esp+14h] [ebp-14h]

  v6 = 0;
  if ( fileno(stream) < 0 )
    return fclose(stream);
  if ( !__freading(stream) || (v3 = fileno(stream), LODWORD(v4) = lseek64(v3, 0, 0, 1), v4 != -1) )
  {
    if ( sub_806567E(stream) )
      v6 = *__errno_location();
  }
  fclose(stream);
  v2 = &loc_80653AE;
  if ( !v6 )
    v2 = &loc_806543D;
  dword_806C14C = (int)v2;
  sub_8066C43(v5);
  *__errno_location() = v6;
  return -1;
}
// 8049030: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8066C43: using guessed type int __fastcall sub_8066C43(_DWORD);
// 806C14C: using guessed type int dword_806C14C;

//----- (08065442) --------------------------------------------------------
int __usercall sub_8065442@<eax>(signed __int32 a1@<ebx>, int fd, int cmd, char a4)
{
  bool v4; // zf
  int v5; // edx
  int v6; // ecx
  void *v7; // eax
  signed __int32 v8; // ecx
  signed __int32 v9; // ebx
  signed __int32 v10; // ecx
  signed __int32 v11; // et0
  signed __int32 v12; // ecx
  signed __int32 v13; // et1
  signed __int32 v14; // edx
  int v15; // ecx
  signed __int32 v16; // ecx
  signed __int32 v17; // ett
  int v19; // [esp+1Ch] [ebp-1Ch]
  int v20; // [esp+24h] [ebp-14h]
  int v21; // [esp+28h] [ebp-10h]

  if ( cmd != 1030 )
    return fcntl(fd, cmd, a4);
  if ( dword_806C83E < 0 )
  {
    v19 = sub_8065442(fd, 0, a4);
  }
  else
  {
    v19 = fcntl(fd, 1030, a4);
    if ( v19 < 0 )
    {
      v4 = *__errno_location() == 22;
      v7 = &loc_80654C5;
      if ( v4 )
        v7 = &loc_80654D1;
      dword_806C1D8 = (int)v7;
      sub_806689B(v6, v5);
    }
    dword_806C83E = 1;
  }
  if ( v19 >= 0 && dword_806C83E == -1 )
  {
    v20 = fcntl(v19, 1);
    if ( v20 < 0 )
    {
      v21 = *__errno_location();
      close(v19);
      goto LABEL_14;
    }
    if ( fcntl(v19, 2, v20 | 1) == -1 )
    {
      dword_806C124 = (int)&loc_80655CB;
      v9 = _InterlockedExchange(&dword_806C128, a1);
      v11 = _InterlockedExchange(&dword_806C128, v8);
      v10 = v9;
      a1 = v11;
      v13 = _InterlockedExchange(&dword_806C128, sub_8066D47(_InterlockedExchange(&dword_806C128, v10)));
      _InterlockedExchange(&dword_806C128, v12);
      _InterlockedExchange(&dword_806C128, v13);
LABEL_14:
      *__errno_location() = v21;
      v19 = -1;
      dword_806C174 = (int)&loc_8065640;
      v14 = _InterlockedExchange(&dword_806C178, a1);
      _InterlockedExchange(&dword_806C178, v21);
      v17 = _InterlockedExchange(&dword_806C178, sub_8066B3F(v15, _InterlockedExchange(&dword_806C178, v14)));
      _InterlockedExchange(&dword_806C178, v16);
      _InterlockedExchange(&dword_806C178, v17);
      return v19;
    }
  }
  return v19;
}
// 806689B: using guessed type int __fastcall sub_806689B(_DWORD, _DWORD);
// 8066B3F: using guessed type int __fastcall sub_8066B3F(_DWORD, _DWORD);
// 8066D47: using guessed type int __fastcall sub_8066D47(_DWORD);
// 806C124: using guessed type int dword_806C124;
// 806C128: using guessed type int dword_806C128;
// 806C174: using guessed type int dword_806C174;
// 806C178: using guessed type int dword_806C178;
// 806C1D8: using guessed type int dword_806C1D8;
// 806C83E: using guessed type int dword_806C83E;

//----- (08065645) --------------------------------------------------------
int __cdecl sub_8065645(FILE *stream)
{
  int result; // eax

  result = stream->_flags & 0x100;
  if ( result )
    result = sub_80656DA(stream, 0, 0, 1);
  return result;
}

//----- (0806567E) --------------------------------------------------------
int __cdecl sub_806567E(FILE *fp)
{
  if ( !fp || !__freading(fp) )
    return fflush(fp);
  sub_8065645(fp);
  return fflush(fp);
}

//----- (080656DA) --------------------------------------------------------
int __cdecl sub_80656DA(FILE *stream, int a2, int a3, int a4)
{
  int v4; // ecx
  void *v5; // eax
  int v6; // eax
  __off64_t v7; // rax

  if ( stream->_IO_read_end != stream->_IO_read_ptr || stream->_IO_write_ptr != stream->_IO_write_base )
    return fseeko64(stream, a2, a3, a4);
  v5 = &loc_8065737;
  if ( stream->_IO_save_base )
    v5 = &loc_80658A9;
  dword_806C188 = (int)v5;
  sub_8066AB8(v4);
  v6 = fileno(stream);
  LODWORD(v7) = lseek64(v6, a2, a3, a4);
  if ( v7 == -1 )
    return -1;
  stream->_flags &= 0xFFFFFFEF;
  stream->_offset = v7;
  return 0;
}
// 8048DC0: using guessed type int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8049030: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8066AB8: using guessed type int __fastcall sub_8066AB8(_DWORD);
// 806C188: using guessed type int dword_806C188;

//----- (080658CB) --------------------------------------------------------
size_t __usercall sub_80658CB@<eax>(signed __int32 a1@<ebx>, wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  wchar_t v5; // edx
  signed __int32 v6; // eax
  signed __int32 v7; // edx
  signed __int32 v8; // et1
  signed __int32 v9; // eax
  int v10; // ecx
  signed __int32 v11; // ebx
  signed __int32 v12; // edx
  signed __int32 v13; // edx
  signed __int32 v14; // ett
  signed __int32 v15; // ecx
  char v17; // [esp+18h] [ebp-10h]
  size_t v18; // [esp+1Ch] [ebp-Ch]

  if ( !pwc )
    pwc = (wchar_t *)&v17;
  v18 = mbrtowc(pwc, s, n, p);
  if ( v18 > 0xFFFFFFFD && n )
  {
    while ( (unsigned __int8)sub_8065B2E(0) ^ 1 )
    {
      v5 = (unsigned __int8)*s;
      *pwc = v5;
      dword_806C19C = (int)&locret_8065A2D;
      v6 = _InterlockedExchange(&dword_806C1A0, 1);
      _InterlockedExchange(&dword_806C1A0, v15);
      v8 = _InterlockedExchange(&dword_806C1A0, sub_8066A1E(_InterlockedExchange(&dword_806C1A0, v6), v5));
      dword_806C188 = (int)&loc_8065A2A;
      v9 = _InterlockedExchange(&dword_806C18C, _InterlockedExchange(&dword_806C1A0, v7));
      _InterlockedExchange(&dword_806C18C, _InterlockedExchange(&dword_806C1A0, v8));
      _InterlockedExchange(&dword_806C18C, v9);
      sub_8066AB8(v10);
      v11 = _InterlockedExchange(&dword_806C18C, a1);
      v14 = _InterlockedExchange(&dword_806C18C, v12);
      v13 = v11;
      a1 = v14;
      _InterlockedExchange(&dword_806C18C, v13);
    }
  }
  return v18;
}
// 8066A1E: using guessed type int __fastcall sub_8066A1E(_DWORD, _DWORD);
// 8066AB8: using guessed type int __fastcall sub_8066AB8(_DWORD);
// 806C188: using guessed type int dword_806C188;
// 806C18C: using guessed type int dword_806C18C;
// 806C19C: using guessed type int dword_806C19C;
// 806C1A0: using guessed type int dword_806C1A0;

//----- (08065A2F) --------------------------------------------------------
int __cdecl sub_8065A2F(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // esi
  unsigned __int8 *v3; // ebx
  unsigned __int8 v5; // [esp+1Eh] [ebp-Ah]
  unsigned __int8 v6; // [esp+1Fh] [ebp-9h]

  v2 = a1;
  v3 = a2;
  if ( a1 == a2 )
    return 0;
  do
  {
    v5 = sub_80664CE(*v2);
    v6 = sub_80664CE(*v3);
    if ( !v5 )
      break;
    ++v2;
    ++v3;
  }
  while ( v5 == v6 );
  return v5 - v6;
}

//----- (08065A94) --------------------------------------------------------
int __cdecl sub_8065A94(FILE *fp)
{
  bool v1; // ST26_1
  int v2; // edx
  int v3; // ecx
  void *v4; // eax
  bool v6; // [esp+1Dh] [ebp-Bh]
  bool v7; // [esp+1Fh] [ebp-9h]

  v6 = __fpending(fp) != 0;
  v1 = ferror_unlocked(fp) != 0;
  v7 = sub_8065344(fp) != 0;
  v4 = &loc_8065AF2;
  if ( v1 )
    v4 = &loc_8065B0A;
  dword_806C174 = (int)v4;
  sub_8066B3F(v3, v2);
  if ( !v7 || !v6 && *__errno_location() == 9 )
    return 0;
  if ( v7 != 1 )
    *__errno_location() = 0;
  return -1;
}
// 8066B3F: using guessed type int __fastcall sub_8066B3F(_DWORD, _DWORD);
// 806C174: using guessed type int dword_806C174;

//----- (08065B2E) --------------------------------------------------------
int __cdecl sub_8065B2E(int category)
{
  unsigned __int8 v2; // [esp+1Bh] [ebp-Dh]
  const char *s1; // [esp+1Ch] [ebp-Ch]

  v2 = 1;
  s1 = setlocale(category, 0);
  if ( s1 && (!strcmp(s1, "C") || !strcmp(s1, "POSIX")) )
    v2 = 0;
  return v2;
}

//----- (08065B8C) --------------------------------------------------------
signed __int32 sub_8065B8C()
{
  signed __int32 v0; // eax
  signed __int32 v1; // edx
  signed __int32 v2; // ecx
  signed __int32 result; // eax
  int v4; // ecx
  int v5; // edx
  signed __int32 v6; // ecx
  signed __int32 v7; // eax
  signed __int32 v8; // ecx
  signed __int32 v9; // eax
  signed __int32 v10; // ecx
  signed __int32 v11; // et1
  bool v12; // zf
  int v13; // ecx
  void *v14; // eax
  signed __int32 v15; // eax
  signed __int32 v16; // ecx
  signed __int32 v17; // ett
  signed __int32 v18; // eax
  signed __int32 v19; // edx
  signed __int32 v20; // eax
  signed __int32 v21; // et1
  signed __int32 v22; // ecx
  signed __int32 v23; // et2
  const char *s; // [esp+1Ch] [ebp-ACh]
  size_t n; // [esp+2Ch] [ebp-9Ch]
  signed __int32 v26; // [esp+30h] [ebp-98h]
  _BYTE *dest; // [esp+38h] [ebp-90h]
  int fd; // [esp+3Ch] [ebp-8Ch]

  if ( dword_806C842 )
    return dword_806C842;
  s = getenv("CHARSETALIASDIR");
  if ( !s || !*s )
    s = "/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib";
  n = strlen(s);
  v0 = strlen("charset.alias");
  while ( 1 )
  {
    v26 = v0;
    if ( n )
      break;
    dest = malloc(v0 + 1);
    if ( dest )
    {
      memcpy(dest, s, 0);
      dword_806C1C4 = (int)&loc_8065CFA;
      sub_806691B(v4);
      *dest = 47;
      memcpy(dest, "charset.alias", v26 + 1);
    }
    free(0);
    if ( dest )
    {
      v7 = open64(dest, 0x20000);
      fd = v7;
      if ( v7 < 0 )
      {
        dword_806C110 = (int)&loc_80660D5;
        v9 = _InterlockedExchange(&dword_806C114, v7);
        _InterlockedExchange(&dword_806C114, v8);
        v11 = _InterlockedExchange(&dword_806C114, sub_8066DC7(_InterlockedExchange(&dword_806C114, v9)));
        _InterlockedExchange(&dword_806C114, v10);
        _InterlockedExchange(&dword_806C114, v11);
      }
      v12 = fdopen(fd, "r") == 0;
      v14 = &loc_8065DF7;
      if ( !v12 )
        v14 = &loc_8065E14;
      dword_806C1C4 = (int)v14;
      sub_806691B(v13);
      close(fd);
      free(dest);
    }
    dword_806C842 = (int)&unk_806865B;
    dword_806C174 = (int)&loc_8065C2C;
    v15 = _InterlockedExchange(&dword_806C178, (signed __int32)&unk_806865B);
    _InterlockedExchange(&dword_806C178, v6);
    v17 = _InterlockedExchange(&dword_806C178, sub_8066B3F(_InterlockedExchange(&dword_806C178, v15), v5));
    v0 = _InterlockedExchange(&dword_806C178, v16);
    v2 = _InterlockedExchange(&dword_806C178, v17);
  }
  dword_806C19C = (int)&loc_8065C47;
  v18 = _InterlockedExchange(&dword_806C1A0, v0);
  _InterlockedExchange(&dword_806C1A0, v1);
  v21 = _InterlockedExchange(&dword_806C1A0, sub_8066A1E(v2, _InterlockedExchange(&dword_806C1A0, v18)));
  v20 = _InterlockedExchange(&dword_806C1A0, v19);
  _InterlockedExchange(&dword_806C1A0, v21);
  v23 = _InterlockedExchange(&dword_806C1FC, v20);
  result = _InterlockedExchange(&dword_806C1FC, v22);
  _InterlockedExchange(&dword_806C1FC, v23);
  return result;
}
// 8048D10: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 806691B: using guessed type int __fastcall sub_806691B(_DWORD);
// 8066A1E: using guessed type int __fastcall sub_8066A1E(_DWORD, _DWORD);
// 8066B3F: using guessed type int __fastcall sub_8066B3F(_DWORD, _DWORD);
// 8066DC7: using guessed type int __fastcall sub_8066DC7(_DWORD);
// 806C110: using guessed type int dword_806C110;
// 806C114: using guessed type int dword_806C114;
// 806C174: using guessed type int dword_806C174;
// 806C178: using guessed type int dword_806C178;
// 806C19C: using guessed type int dword_806C19C;
// 806C1A0: using guessed type int dword_806C1A0;
// 806C1C4: using guessed type int dword_806C1C4;
// 806C1FC: using guessed type int dword_806C1FC;
// 806C842: using guessed type int dword_806C842;

//----- (0806618C) --------------------------------------------------------
const char *sub_806618C()
{
  char *v0; // ST1C_4
  const char *s1; // [esp+18h] [ebp-10h]
  char *s2; // [esp+1Ch] [ebp-Ch]

  s1 = nl_langinfo(14);
  if ( !s1 )
    s1 = (const char *)&unk_806865B;
  for ( s2 = (char *)sub_8065B8C(); *s2; s2 = &v0[strlen(v0) + 1] )
  {
    if ( !strcmp(s1, s2) || *s2 == 42 && !s2[1] )
    {
      s1 = &s2[strlen(s2) + 1];
      break;
    }
    v0 = &s2[strlen(s2) + 1];
  }
  if ( !*s1 )
    s1 = "ASCII";
  return s1;
}

//----- (080664CE) --------------------------------------------------------
int __cdecl sub_80664CE(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 65) > 0x19 )
    result = a1;
  else
    result = a1 + 32;
  return result;
}

//----- (0806650E) --------------------------------------------------------
__int64 __cdecl sub_806650E(int a1, unsigned int a2, unsigned int a3, int a4)
{
  void *v4; // eax
  unsigned int v5; // ecx
  unsigned int v6; // edx
  unsigned int v8; // ebp
  unsigned __int64 v9; // rtt

  v4 = &loc_8066558;
  if ( a4 )
    v4 = &loc_806656F;
  dword_806C188 = (int)v4;
  sub_8066AB8(a1);
  if ( a3 <= a2 )
  {
    v8 = a3;
    if ( !a3 )
      v8 = 1 / 0u;
    LODWORD(v9) = v5;
    HIDWORD(v9) = a2 % v8;
    v6 = v9 % v8;
  }
  else
  {
    v6 = __PAIR__(a2, v5) % a3;
  }
  return v6;
}
// 8066AB8: using guessed type int __fastcall sub_8066AB8(_DWORD);
// 806C188: using guessed type int dword_806C188;

//----- (080666B4) --------------------------------------------------------
#error "80666ED: positive sp value has been found (funcsize=18)"

//----- (08066703) --------------------------------------------------------
int __cdecl sub_8066703(int a1)
{
  return __cxa_atexit(a1, 0, dword_806C210);
}
// 8048E80: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 806C210: using guessed type int dword_806C210;

//----- (08066760) --------------------------------------------------------
#error "8066799: positive sp value has been found (funcsize=18)"

//----- (08066803) --------------------------------------------------------
#error "8066809: positive sp value has been found (funcsize=0)"

//----- (0806689B) --------------------------------------------------------
#error "80668A1: positive sp value has been found (funcsize=0)"

//----- (0806691B) --------------------------------------------------------
#error "8066921: positive sp value has been found (funcsize=0)"

//----- (080669A2) --------------------------------------------------------
#error "80669A8: positive sp value has been found (funcsize=0)"

//----- (08066A1E) --------------------------------------------------------
#error "8066A24: positive sp value has been found (funcsize=0)"

//----- (08066AB8) --------------------------------------------------------
#error "8066ABE: positive sp value has been found (funcsize=0)"

//----- (08066B3F) --------------------------------------------------------
#error "8066B45: positive sp value has been found (funcsize=0)"

//----- (08066BC0) --------------------------------------------------------
#error "8066BC6: positive sp value has been found (funcsize=0)"

//----- (08066C43) --------------------------------------------------------
#error "8066C49: positive sp value has been found (funcsize=0)"

//----- (08066CC6) --------------------------------------------------------
#error "8066CCC: positive sp value has been found (funcsize=0)"

//----- (08066D47) --------------------------------------------------------
#error "8066D4D: positive sp value has been found (funcsize=0)"

//----- (08066DC7) --------------------------------------------------------
#error "8066DCD: positive sp value has been found (funcsize=0)"

//----- (08066DF0) --------------------------------------------------------
int (**sub_8066DF0())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_806BED0;
  v1 = &off_806BED4 - off_806BED0;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_806BED0[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 806BED0: using guessed type int (*off_806BED0[2])();
// 806BED4: using guessed type int (*off_806BED4)();

//----- (08066E54) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 18 decompilation failure(s) on 146 function(s)"
