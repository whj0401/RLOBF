/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8048CF0();
// int strcmp(const char *s1, const char *s2);
// int __cdecl open64(_DWORD, _DWORD); weak
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void _exit(int status);
// void free(void *ptr);
// void *memcpy(void *dest, const void *src, size_t n);
// int fclose(FILE *stream);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// char *textdomain(const char *domainname);
// int __cdecl fopen64(_DWORD, _DWORD); weak
// int ferror_unlocked(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// size_t __ctype_get_mb_cur_max(void);
// size_t __fpending(FILE *fp);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// void error(int status, int errnum, const char *format, ...);
// size_t fread_unlocked(void *ptr, size_t size, size_t n, FILE *stream);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// char *strchr(const char *s, int c);
// size_t strlen(const char *s);
// int fprintf(FILE *stream, const char *format, ...);
// int fcntl(int fd, int cmd, ...);
// int setvbuf(FILE *stream, char *buf, int modes, size_t n);
// void *memset(void *s, int c, size_t n);
// int *__errno_location(void);
// int fileno(FILE *stream);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// char *strrchr(const char *s, int c);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// char *bindtextdomain(const char *domainname, const char *dirname);
// int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// int feof_unlocked(FILE *stream);
// void abort(void);
// int close(int fd);
// const unsigned __int16 **__ctype_b_loc(void);
// int putchar_unlocked(int c);
// int _gmon_start__(void); weak
void sub_8049123();
void sub_8049140();
int sub_8049150();
int sub_80491C0();
int sub_80491E0();
void sub_804923F();
void sub_804925A();
signed int sub_804926A();
void sub_804934C();
void sub_8049367();
int sub_8049377();
void sub_8049459();
void sub_8049474();
int sub_8049484();
void sub_8049566();
void sub_8049581();
int sub_8049591();
void sub_8049673();
void sub_804968E();
signed int sub_804969E();
int nullsub_3(void); // weak
// int __usercall sub_8049705@<eax>(int a1@<eax>, int (__cdecl *a2)(signed int, int)@<edx>);
// int __usercall sub_8049769@<eax>(int (__cdecl *a1)(int *)@<eax>);
void sub_80497E5();
void sub_8049800();
int __fastcall sub_8049810(int a1);
// int __usercall sub_80498DB@<eax>(void (__cdecl *a1)(int *)@<eax>);
void sub_8049927();
void sub_8049942();
int sub_8049952();
void sub_8049A34();
void sub_8049A4F();
int sub_8049A5F();
void sub_8049B41();
void sub_8049B5C();
int sub_8049B6C();
void sub_8049C4E();
void sub_8049C69();
int __fastcall sub_8049C79(int a1);
// int __usercall sub_8049CF9@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
void sub_8049D90();
void sub_8049DAB();
int sub_8049DBB();
void sub_8049E9D();
void sub_8049EB8();
int sub_8049EC8();
void sub_8049FAA();
void sub_8049FC5();
int sub_8049FD5();
void sub_804A0E8();
void sub_804A103();
int sub_804A113();
int nullsub_5(void); // weak
int sub_804A171();
void sub_804A211();
void sub_804A22C();
int sub_804A23C();
// int __usercall sub_804A2EE@<eax>(void (__cdecl *a1)(int *)@<eax>, signed __int32 a2@<ebx>);
void sub_804A36B();
void sub_804A386();
int sub_804A396();
void sub_804A4AA();
void sub_804A4C5();
int sub_804A4D5();
int sub_804A55F();
void sub_804A6DF();
void sub_804A6FA();
int __fastcall sub_804A70A(int a1);
int nullsub_6(void); // weak
int sub_804A781();
void sub_804A892();
void sub_804A8AD();
int sub_804A8BD();
int __cdecl sub_804A96D(unsigned __int64 a1);
unsigned int __cdecl sub_804A9BB(int a1, unsigned int a2);
int sub_804A9ED();
int __cdecl sub_804AA18(char *s1); // idb
int __cdecl sub_804ABD3(int a1);
void __cdecl __noreturn sub_804ABDB(int status); // idb
_BYTE *__cdecl sub_804AD4B(_BYTE *a1, unsigned int a2);
bool __cdecl sub_804AF88(_BYTE *a1);
bool __cdecl sub_804B013(_BYTE *a1, int a2, _BYTE **a3, _DWORD *a4, char a5);
bool __cdecl sub_804B15B(int a1, int a2, _BYTE **a3, _DWORD *a4, _DWORD *a5);
// int __usercall sub_804B526@<eax>(signed __int32 a1@<ebx>, int ecx0@<ecx>, _BYTE *a2, char a3);
// int __usercall sub_804B707@<eax>(signed __int32 a1@<ebx>, char *s1, int a3, int a4, int a5);
// void __usercall __noreturn sub_804B961(signed __int32 a1@<ebx>, const char *a2);
// _BOOL4 __usercall main@<eax>(signed __int32 a1@<ebx>, int argc, char **a3);
// int __usercall sub_804CED6@<eax>(signed __int32 a1@<ebx>);
_DWORD *__cdecl sub_804CFD3(_DWORD *a1);
_DWORD *__cdecl sub_804D08C(_DWORD *a1);
int __cdecl sub_804D145(_DWORD *a1, int a2, int a3);
int __cdecl sub_804D167(int a1, int a2);
int __cdecl sub_804D3EF(int a1, int a2);
void __cdecl __noreturn sub_804D6A0(int a1);
void __cdecl __noreturn sub_804DDE3(int a1);
void __cdecl __noreturn sub_804DE08(int a1);
// int __usercall sub_804DE2D@<eax>(signed __int32 a1@<ebx>, FILE *stream);
int __cdecl sub_804E204(void *src, size_t, int); // idb
void __cdecl __noreturn sub_804E3FD(_DWORD, _DWORD, _DWORD); // weak
// void __usercall __noreturn sub_806355E(int a1@<ebp>);
int __cdecl sub_80637E8(int a1, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_8063839@<eax>(int a1@<edx>, int a2@<ecx>, FILE *stream, int a4);
// FILE *__usercall sub_8063938@<eax>(signed __int32 a1@<ebx>, int a2, char *modes);
char *__cdecl sub_8063A48(char *s);
int __cdecl sub_8063C3C(int *a1, unsigned __int8 a2, char a3);
// int *__usercall sub_8063CFF@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5);
void __cdecl __noreturn sub_8063DBC(int a1, int a2);
int __stdcall sub_8063DFB(int); // weak
// void *__usercall sub_8063E57@<eax>(signed __int32 a1@<ebx>, char *msgid, int a3);
// unsigned int __usercall sub_8063FFD@<eax>(unsigned __int32 a1@<ebx>, _BYTE *a2, unsigned int a3, signed __int32 a4, unsigned int a5, signed int a6, int a7, int a8, char *a9, const char *a10);
_BYTE *__cdecl sub_806516B(signed __int32 a1, unsigned int a2, _DWORD *a3, int *a4);
// _BYTE *__usercall sub_8065312@<eax>(signed __int32 a1@<ebx>, signed int a2, signed __int32 a3, unsigned int a4, int a5);
// _BYTE *__usercall sub_806556F@<eax>(signed __int32 a1@<ebx>, signed int a2, signed __int32 a3);
// _BYTE *__usercall sub_8065599@<eax>(signed __int32 a1@<ebx>, signed int a2, signed __int32 a3, unsigned int a4);
void __cdecl __noreturn sub_80655FF(int a1, int a2);
void __cdecl __noreturn sub_806563D(int a1, int a2);
// _BYTE *__usercall sub_80656C5@<eax>(signed __int32 a1@<ebx>, signed __int32 a2, unsigned int a3, unsigned __int8 a4);
// _BYTE *__usercall sub_806576F@<eax>(signed __int32 a1@<ebx>, signed __int32 a2, unsigned __int8 a3);
// _BYTE *__usercall sub_8065798@<eax>(signed __int32 a1@<ebx>, signed __int32 a2);
void __cdecl __noreturn sub_80657D5(int a1, int a2);
// _BYTE *__usercall sub_8065944@<eax>(int a1@<edx>, int a2@<ecx>, signed __int32 a3@<ebx>, signed int a4, int a5, int a6, signed __int32 a7);
// _BYTE *__usercall sub_8065974@<eax>(int a1@<edx>, int a2@<ecx>, signed __int32 a3@<ebx>, signed int a4, int a5, int a6, signed __int32 a7, unsigned int a8);
// _BYTE *__usercall sub_8065A9D@<eax>(signed __int32 a1@<ebx>, signed int a2, signed __int32 a3, unsigned int a4);
// _BYTE *__usercall sub_8065B96@<eax>(signed __int32 a1@<ebx>, signed int a2, signed __int32 a3);
// int __usercall sub_8065BD3@<eax>(signed __int32 a1@<ebx>, int a2@<edx>, int a3@<ecx>, int fd);
int __cdecl sub_8065BF6(FILE *stream, int, int, int, int, int); // idb
// int __usercall sub_806623B@<eax>(signed __int32 a1@<eax>, signed __int32 a2@<ecx>, FILE *stream, int a4, int a5, int a6, int a7);
// int __usercall sub_80662D4@<eax>(signed __int32 a1@<ecx>, FILE *stream, int a3, int a4, int a5, ...);
void *__cdecl sub_80663D7(void *ptr, int a2, int a3);
// void *__usercall sub_80664BE@<eax>(signed __int32 a1@<ebx>, size_t size);
// void *__usercall sub_80664D1@<eax>(signed __int32 a1@<ebx>, size_t size);
void __noreturn sub_806652E(); // weak
void *__cdecl sub_806654A(void *ptr, size_t size);
// void *__usercall sub_806663B@<eax>(signed __int32 a1@<ebx>, void *src, size_t n);
void __noreturn sub_8066689();
// int __usercall sub_80666C7@<eax>(signed __int32 a1@<ebx>, int a2@<ecx>, FILE *fp);
// int __usercall sub_8066758@<eax>(signed __int32 a1@<ebx>, int a2@<edx>, int a3@<ecx>, int fd, int cmd, char a4, int a5);
// int __usercall sub_8066929@<eax>(signed __int32 a1@<ebx>, FILE *stream);
// int __usercall sub_8066967@<eax>(signed __int32 a1@<ebx>, FILE *stream);
// int __usercall sub_8066A2F@<eax>(signed __int32 a1@<ebx>, FILE *stream, int a3, int a4, int a5);
// size_t __usercall sub_8066BA9@<eax>(int a1@<ecx>, signed __int32 a2@<ebx>, wchar_t *pwc, char *s, size_t n, mbstate_t *p);
int __cdecl sub_8066C8D(unsigned __int8 *a1, unsigned __int8 *a2);
// int __usercall sub_8066D27@<eax>(signed __int32 a1@<ebx>, FILE *fp);
int __cdecl sub_8066DF5(int category); // idb
void __fastcall __noreturn sub_8066E53(int a1, int a2);
void __noreturn sub_80673D4();
int __cdecl sub_8067893(int a1);
int __cdecl sub_80679A6(int a1);
int __cdecl sub_80679C5(unsigned __int64 a1, __int64 a2);
int __cdecl sub_8067BA9(int a1);
int __fastcall sub_8067C8C(_DWORD); // weak
int __fastcall sub_8067D07(_DWORD, _DWORD); // weak
int __fastcall sub_8067D8E(_DWORD); // weak
int __fastcall sub_8067E16(_DWORD, _DWORD); // weak
int __fastcall sub_8067E97(_DWORD, _DWORD); // weak
int __fastcall sub_8067F20(_DWORD, _DWORD); // weak
int __fastcall sub_8068003(_DWORD); // weak
int __fastcall sub_8068088(_DWORD); // weak
int __fastcall sub_806811D(_DWORD, _DWORD); // weak
int __fastcall sub_80681B5(_DWORD, _DWORD); // weak
int __fastcall sub_806823B(_DWORD); // weak
int sub_80682DA(void); // weak
int __fastcall sub_8068355(_DWORD); // weak
int __fastcall sub_80683DD(_DWORD); // weak
int __fastcall sub_8068460(_DWORD); // weak
int __fastcall sub_80684E1(_DWORD, _DWORD); // weak
int (**sub_8068500())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_80496CA; // weak
_UNKNOWN locret_804981F; // weak
_UNKNOWN locret_8049C88; // weak
_UNKNOWN loc_804A268; // weak
_UNKNOWN locret_804A719; // weak
_UNKNOWN loc_804ABA2; // weak
_UNKNOWN loc_804ABA9; // weak
_UNKNOWN loc_804AD8E; // weak
_UNKNOWN loc_804AE03; // weak
_UNKNOWN loc_804AE3F; // weak
_UNKNOWN loc_804AF0C; // weak
_UNKNOWN loc_804AF43; // weak
_UNKNOWN locret_804B011; // weak
_UNKNOWN loc_804B03A; // weak
_UNKNOWN loc_804B06C; // weak
_UNKNOWN loc_804B104; // weak
_UNKNOWN loc_804B13F; // weak
_UNKNOWN loc_804B16F; // weak
_UNKNOWN loc_804B19B; // weak
_UNKNOWN loc_804B304; // weak
_UNKNOWN loc_804B31D; // weak
_UNKNOWN loc_804B35B; // weak
_UNKNOWN loc_804B365; // weak
_UNKNOWN loc_804B520; // weak
_UNKNOWN loc_804B58D; // weak
_UNKNOWN locret_804B705; // weak
_UNKNOWN loc_804B78D; // weak
_UNKNOWN loc_804B7A9; // weak
_UNKNOWN loc_804B863; // weak
_UNKNOWN loc_804B8C2; // weak
_UNKNOWN loc_804BAA2; // weak
_UNKNOWN sub_804BAEF; // weak
_UNKNOWN loc_804C5B2; // weak
_UNKNOWN loc_804C5E0; // weak
_UNKNOWN loc_804C619; // weak
_UNKNOWN loc_804C644; // weak
_UNKNOWN loc_804C67B; // weak
_UNKNOWN loc_804C6D4; // weak
_UNKNOWN loc_804C6DE; // weak
_UNKNOWN unk_804C7CC; // weak
_UNKNOWN loc_804C81F; // weak
_UNKNOWN loc_804C82B; // weak
_UNKNOWN loc_804C91C; // weak
_UNKNOWN loc_804C94C; // weak
_UNKNOWN loc_804C97C; // weak
_UNKNOWN loc_804C9AC; // weak
_UNKNOWN loc_804C9DC; // weak
_UNKNOWN loc_804CA0C; // weak
_UNKNOWN loc_804CA77; // weak
_UNKNOWN loc_804CAB3; // weak
_UNKNOWN loc_804CB44; // weak
_UNKNOWN loc_804CB5D; // weak
_UNKNOWN loc_804CD88; // weak
_UNKNOWN loc_804CD9B; // weak
_UNKNOWN loc_804CE2C; // weak
_UNKNOWN loc_804CE31; // weak
_UNKNOWN loc_804CF41; // weak
_UNKNOWN loc_804CF7C; // weak
_UNKNOWN loc_804DE6A; // weak
_UNKNOWN loc_804DEA5; // weak
_UNKNOWN locret_804DFC9; // weak
_UNKNOWN loc_804F142; // weak
_UNKNOWN loc_806385E; // weak
_UNKNOWN locret_806386E; // weak
_UNKNOWN loc_8063994; // weak
_UNKNOWN loc_8063A43; // weak
_UNKNOWN loc_8063D24; // weak
_UNKNOWN loc_8063D2B; // weak
_UNKNOWN loc_8063DF6; // weak
_UNKNOWN loc_8063E8C; // weak
_UNKNOWN loc_8063EA9; // weak
_UNKNOWN loc_8063FEF; // weak
_UNKNOWN loc_8063FF6; // weak
_UNKNOWN locret_8063FFB; // weak
_UNKNOWN loc_8064094; // weak
_UNKNOWN loc_8064108; // weak
_UNKNOWN loc_8064134; // weak
_UNKNOWN loc_806419A; // weak
_UNKNOWN loc_8064250; // weak
_UNKNOWN loc_8064287; // weak
_UNKNOWN loc_80642A6; // weak
_UNKNOWN loc_806430C; // weak
_UNKNOWN loc_80644CA; // weak
_UNKNOWN loc_80644CF; // weak
_UNKNOWN loc_80645E0; // weak
_UNKNOWN loc_8064685; // weak
_UNKNOWN loc_80646BC; // weak
_UNKNOWN loc_8064739; // weak
_UNKNOWN loc_8064745; // weak
_UNKNOWN loc_806479C; // weak
_UNKNOWN loc_806483C; // weak
_UNKNOWN loc_8064849; // weak
_UNKNOWN loc_80648C4; // weak
_UNKNOWN loc_80648F2; // weak
_UNKNOWN loc_8064AB1; // weak
_UNKNOWN loc_8064C02; // weak
_UNKNOWN loc_8064C34; // weak
_UNKNOWN loc_8064C65; // weak
_UNKNOWN loc_8064CCC; // weak
_UNKNOWN loc_8064D0E; // weak
_UNKNOWN loc_8064D3C; // weak
_UNKNOWN loc_8064D60; // weak
_UNKNOWN loc_8064DA9; // weak
_UNKNOWN loc_8064DC0; // weak
_UNKNOWN loc_8064E41; // weak
_UNKNOWN loc_8064E45; // weak
_UNKNOWN loc_8064E68; // weak
_UNKNOWN loc_8064E7A; // weak
_UNKNOWN loc_8064EB6; // weak
_UNKNOWN loc_8064EBB; // weak
_UNKNOWN loc_8064EDA; // weak
_UNKNOWN loc_8064F12; // weak
_UNKNOWN loc_8064F5B; // weak
_UNKNOWN loc_8064FAB; // weak
_UNKNOWN loc_8064FBE; // weak
_UNKNOWN loc_8065001; // weak
_UNKNOWN loc_80653B1; // weak
_UNKNOWN loc_8065C1E; // weak
_UNKNOWN loc_8065C48; // weak
_UNKNOWN loc_80661A6; // weak
_UNKNOWN loc_8066281; // weak
_UNKNOWN loc_80666EC; // weak
_UNKNOWN loc_80666FB; // weak
_UNKNOWN locret_8066751; // weak
_UNKNOWN loc_806678E; // weak
_UNKNOWN loc_806689B; // weak
_UNKNOWN loc_80668C3; // weak
_UNKNOWN loc_80668FA; // weak
_UNKNOWN loc_8066924; // weak
_UNKNOWN locret_8066A6E; // weak
_UNKNOWN loc_8066BCE; // weak
_UNKNOWN loc_8066BD4; // weak
_UNKNOWN locret_8066BF9; // weak
_UNKNOWN loc_8066D14; // weak
_UNKNOWN loc_8066D85; // weak
_UNKNOWN loc_8066D9D; // weak
_UNKNOWN locret_8066DF3; // weak
_UNKNOWN loc_8066EC5; // weak
_UNKNOWN loc_8067067; // weak
_UNKNOWN loc_8067084; // weak
_UNKNOWN loc_806738A; // weak
_UNKNOWN loc_8067408; // weak
_UNKNOWN loc_806740F; // weak
_UNKNOWN loc_80678DF; // weak
_UNKNOWN loc_8067AD8; // weak
_UNKNOWN loc_8067B16; // weak
char locale = '\0'; // idb
struct option longopts = { "binary", 0, NULL, 98 }; // idb
_UNKNOWN unk_8069230; // weak
_UNKNOWN unk_806966E; // weak
_UNKNOWN unk_8069672; // weak
_UNKNOWN unk_8069675; // weak
_UNKNOWN unk_8069D93; // weak
int dword_8069F00 = 1155923967; // weak
_UNKNOWN unk_806A1DC; // weak
_UNKNOWN unk_806A1DF; // weak
_UNKNOWN unk_806B224; // weak
_UNKNOWN unk_806B227; // weak
int dword_806BED8 = 806241324; // weak
int dword_806BEDC = 1193283149; // weak
int (*off_806DEBC[2])() = { &sub_80491E0, &sub_80491C0 }; // weak
int (*off_806DEC0)() = &sub_80491C0; // weak
int (*dword_806E008)(void) = NULL; // weak
int dword_806E110 = 0; // weak
int dword_806E114 = 0; // weak
int dword_806E124 = 0; // weak
int dword_806E128 = 0; // weak
int dword_806E138 = 0; // weak
int dword_806E13C = 0; // weak
int dword_806E14C = 0; // weak
int dword_806E150 = 0; // weak
int dword_806E160 = 0; // weak
int dword_806E174 = 0; // weak
int dword_806E178 = 0; // weak
int dword_806E188 = 0; // weak
int dword_806E18C = 0; // weak
int dword_806E19C = 0; // weak
int dword_806E1A0 = 0; // weak
int dword_806E1B0 = 0; // weak
int dword_806E1B4 = 0; // weak
int dword_806E1C4 = 0; // weak
int dword_806E1C8 = 0; // weak
int dword_806E1E4 = 0; // weak
int dword_806E1F8 = 0; // weak
int dword_806E1FC = 0; // weak
int dword_806E20C = 0; // weak
int dword_806E210 = 0; // weak
int dword_806E220 = 0; // weak
int dword_806E224 = 0; // weak
int dword_806E234 = 0; // weak
int dword_806E238 = 0; // weak
int dword_806E248 = 0; // weak
int dword_806E24C = 0; // weak
int dword_806E258 = 0; // weak
int dword_806E26C = 0; // weak
int status = 1; // idb
int dword_806E288 = 1; // weak
int dword_806E28C = 256; // weak
void *off_806E290 = &unk_806E90B; // weak
int *off_806E294 = &dword_806E28C; // weak
_UNKNOWN unk_806E2A8; // weak
_UNKNOWN unk_806E2C4; // weak
_UNKNOWN unk_806E2C7; // weak
_UNKNOWN unk_806E2CC; // weak
_UNKNOWN unk_806E2CF; // weak
_UNKNOWN unk_806E2D8; // weak
_UNKNOWN unk_806E2DB; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int program_invocation_name; // weak
int optind; // weak
FILE *stdin; // idb
FILE *stdout; // idb
char byte_806E328; // weak
_UNKNOWN unk_806E499; // weak
_UNKNOWN unk_806E773; // weak
char byte_806E801; // weak
_UNKNOWN unk_806E805; // weak
_UNKNOWN unk_806E815; // weak
char byte_806E897; // weak
int dword_806E89B; // weak
int dword_806E89F; // weak
char byte_806E8A3; // weak
char byte_806E8A4; // weak
char byte_806E8A5; // weak
char byte_806E8A6; // weak
char byte_806E8A7; // weak
int dword_806E8AB; // weak
char byte_806E8AF; // weak
int dword_806E8B3; // weak
int dword_806E8CB; // weak
int dword_806E8CF; // weak
int dword_806E8D3; // weak
int dword_806E8D7; // weak
int dword_806E8DB; // weak
int dword_806E8DF; // weak
int dword_806E8E3; // weak
int dword_806E8E7; // weak
int dword_806E8EB; // weak
int dword_806E8EF; // weak
int dword_806E8F3; // weak
int dword_806E8F7; // weak
_UNKNOWN unk_806E90B; // weak
int dword_806EA0B; // weak
int dword_806EA0F; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (08048CCC) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 80490E0: using guessed type int _gmon_start__(void);

//----- (08048CF0) --------------------------------------------------------
int sub_8048CF0()
{
  return dword_806E008();
}
// 806E008: using guessed type int (*dword_806E008)(void);

//----- (080490F0) --------------------------------------------------------
#error "80490F3: positive sp value has been found (funcsize=2)"

//----- (08049123) --------------------------------------------------------
void sub_8049123()
{
  ;
}

//----- (08049140) --------------------------------------------------------
void sub_8049140()
{
  ;
}

//----- (08049150) --------------------------------------------------------
int sub_8049150()
{
  int result; // eax

  result = &unk_806E2DB - &unk_806E2D8;
  if ( (unsigned int)(&unk_806E2DB - &unk_806E2D8) > 6 )
    result = 0;
  return result;
}
// 8049150: could not find valid save-restore pair for ebp

//----- (080491C0) --------------------------------------------------------
int sub_80491C0()
{
  int result; // eax

  if ( !byte_806E328 )
  {
    result = sub_8049150();
    byte_806E328 = 1;
  }
  return result;
}
// 80491C0: could not find valid save-restore pair for ebp
// 806E328: using guessed type char byte_806E328;

//----- (080491E0) --------------------------------------------------------
int sub_80491E0()
{
  return 0;
}
// 80491E0: could not find valid save-restore pair for ebp

//----- (0804923F) --------------------------------------------------------
void sub_804923F()
{
  ;
}

//----- (0804925A) --------------------------------------------------------
void sub_804925A()
{
  ;
}

//----- (0804926A) --------------------------------------------------------
signed int sub_804926A()
{
  return 3;
}
// 804926A: could not find valid save-restore pair for ebp

//----- (0804934C) --------------------------------------------------------
void sub_804934C()
{
  ;
}

//----- (08049367) --------------------------------------------------------
void sub_8049367()
{
  ;
}

//----- (08049377) --------------------------------------------------------
int sub_8049377()
{
  int result; // eax

  result = &unk_806E2C7 - &unk_806E2C4;
  if ( (unsigned int)(&unk_806E2C7 - &unk_806E2C4) > 6 )
    result = 0;
  return result;
}
// 8049377: could not find valid save-restore pair for ebp

//----- (08049459) --------------------------------------------------------
void sub_8049459()
{
  ;
}

//----- (08049474) --------------------------------------------------------
void sub_8049474()
{
  ;
}

//----- (08049484) --------------------------------------------------------
int sub_8049484()
{
  int result; // eax

  result = &unk_806E2C7 - &unk_806E2C4;
  if ( (unsigned int)(&unk_806E2C7 - &unk_806E2C4) > 6 )
    result = 0;
  return result;
}
// 8049484: could not find valid save-restore pair for ebp

//----- (08049566) --------------------------------------------------------
void sub_8049566()
{
  ;
}

//----- (08049581) --------------------------------------------------------
void sub_8049581()
{
  ;
}

//----- (08049591) --------------------------------------------------------
int sub_8049591()
{
  int result; // eax

  result = &unk_806E2C7 - &unk_806E2C4;
  if ( (unsigned int)(&unk_806E2C7 - &unk_806E2C4) > 6 )
    result = 0;
  return result;
}
// 8049591: could not find valid save-restore pair for ebp

//----- (08049673) --------------------------------------------------------
void sub_8049673()
{
  ;
}

//----- (0804968E) --------------------------------------------------------
void sub_804968E()
{
  ;
}

//----- (0804969E) --------------------------------------------------------
signed int sub_804969E()
{
  return 3;
}
// 804969E: could not find valid save-restore pair for ebp

//----- (08049705) --------------------------------------------------------
int __usercall sub_8049705@<eax>(int a1@<eax>, int (__cdecl *a2)(signed int, int)@<edx>)
{
  return a2(134660724, a1);
}

//----- (08049769) --------------------------------------------------------
int __usercall sub_8049769@<eax>(int (__cdecl *a1)(int *)@<eax>)
{
  signed __int32 v2; // eax
  signed __int32 v3; // eax
  signed __int32 v4; // ecx
  signed __int32 v5; // edx
  signed __int32 v6; // et1

  v2 = a1(&dword_806BED8);
  dword_806E14C = (int)&loc_80496CA;
  v3 = _InterlockedExchange(&dword_806E150, v2);
  _InterlockedExchange(&dword_806E150, v4);
  v6 = _InterlockedExchange(&dword_806E150, sub_8068355(_InterlockedExchange(&dword_806E150, v3)));
  _InterlockedExchange(&dword_806E150, v5);
  _InterlockedExchange(&dword_806E150, v6);
  return nullsub_3();
}
// 8049769: could not find valid save-restore pair for ebx
// 80496E2: using guessed type int nullsub_3(void);
// 8068355: using guessed type int __fastcall sub_8068355(_DWORD);
// 80683DD: using guessed type int __fastcall sub_80683DD(_DWORD);
// 806BED8: using guessed type int dword_806BED8;
// 806E138: using guessed type int dword_806E138;
// 806E14C: using guessed type int dword_806E14C;
// 806E150: using guessed type int dword_806E150;

//----- (080497E5) --------------------------------------------------------
void sub_80497E5()
{
  ;
}

//----- (08049800) --------------------------------------------------------
void sub_8049800()
{
  ;
}

//----- (08049810) --------------------------------------------------------
int __fastcall sub_8049810(int a1)
{
  int result; // eax
  int (__stdcall *v2)(int *, int, int, int, int, int); // eax
  int v3; // [esp+4h] [ebp-18h]
  int v4; // [esp+8h] [ebp-14h]
  int v5; // [esp+Ch] [ebp-10h]
  int v6; // [esp+10h] [ebp-Ch]
  int v7; // [esp+14h] [ebp-8h]
  int v8; // [esp+18h] [ebp-4h]

  result = &unk_806E499 - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_806E499 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
  {
    v8 = 0;
    dword_806E124 = (int)&locret_804981F;
    v2 = (int (__stdcall *)(int *, int, int, int, int, int))sub_8068460(a1);
    result = v2(&program_invocation_short_name, v3, v4, v5, v6, v7);
  }
  return result;
}
// 8068460: using guessed type int __fastcall sub_8068460(_DWORD);
// 806E124: using guessed type int dword_806E124;
// 806E2E0: using guessed type int program_invocation_short_name;

//----- (080498DB) --------------------------------------------------------
int __usercall sub_80498DB@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  a1(&dword_806BEDC);
  return 0;
}
// 806BEDC: using guessed type int dword_806BEDC;

//----- (08049927) --------------------------------------------------------
void sub_8049927()
{
  ;
}

//----- (08049942) --------------------------------------------------------
void sub_8049942()
{
  ;
}

//----- (08049952) --------------------------------------------------------
int sub_8049952()
{
  int result; // eax

  result = &unk_806E2C7 - &unk_806E2C4;
  if ( (unsigned int)(&unk_806E2C7 - &unk_806E2C4) > 6 )
    result = 0;
  return result;
}
// 8049952: could not find valid save-restore pair for ebp

//----- (08049A34) --------------------------------------------------------
void sub_8049A34()
{
  ;
}

//----- (08049A4F) --------------------------------------------------------
void sub_8049A4F()
{
  ;
}

//----- (08049A5F) --------------------------------------------------------
int sub_8049A5F()
{
  int result; // eax

  result = &unk_806E2C7 - &unk_806E2C4;
  if ( (unsigned int)(&unk_806E2C7 - &unk_806E2C4) > 6 )
    result = 0;
  return result;
}
// 8049A5F: could not find valid save-restore pair for ebp

//----- (08049B41) --------------------------------------------------------
void sub_8049B41()
{
  ;
}

//----- (08049B5C) --------------------------------------------------------
void sub_8049B5C()
{
  ;
}

//----- (08049B6C) --------------------------------------------------------
int sub_8049B6C()
{
  int result; // eax

  result = &unk_806B227 - &unk_806B224;
  if ( (unsigned int)(&unk_806B227 - &unk_806B224) > 6 )
    result = 0;
  return result;
}
// 8049B6C: could not find valid save-restore pair for ebp

//----- (08049C4E) --------------------------------------------------------
void sub_8049C4E()
{
  ;
}

//----- (08049C69) --------------------------------------------------------
void sub_8049C69()
{
  ;
}

//----- (08049C79) --------------------------------------------------------
int __fastcall sub_8049C79(int a1)
{
  int result; // eax
  int (__stdcall *v2)(void *, int, int, int, int, int); // eax
  int v3; // [esp+4h] [ebp-18h]
  int v4; // [esp+8h] [ebp-14h]
  int v5; // [esp+Ch] [ebp-10h]
  int v6; // [esp+10h] [ebp-Ch]
  int v7; // [esp+14h] [ebp-8h]
  int v8; // [esp+18h] [ebp-4h]

  result = &unk_806E2C7 - &unk_806E2C4;
  if ( (unsigned int)(&unk_806E2C7 - &unk_806E2C4) > 6 )
  {
    v8 = 0;
    dword_806E138 = (int)&locret_8049C88;
    v2 = (int (__stdcall *)(void *, int, int, int, int, int))sub_80683DD(a1);
    result = v2(&unk_806E2C4, v3, v4, v5, v6, v7);
  }
  return result;
}
// 80683DD: using guessed type int __fastcall sub_80683DD(_DWORD);
// 806E138: using guessed type int dword_806E138;

//----- (08049CF9) --------------------------------------------------------
int __usercall sub_8049CF9@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_806E2C4, a1);
}

//----- (08049D90) --------------------------------------------------------
void sub_8049D90()
{
  ;
}

//----- (08049DAB) --------------------------------------------------------
void sub_8049DAB()
{
  ;
}

//----- (08049DBB) --------------------------------------------------------
int sub_8049DBB()
{
  int result; // eax

  result = &unk_806E2CF - &unk_806E2CC;
  if ( (unsigned int)(&unk_806E2CF - &unk_806E2CC) > 6 )
    result = 0;
  return result;
}
// 8049DBB: could not find valid save-restore pair for ebp

//----- (08049E9D) --------------------------------------------------------
void sub_8049E9D()
{
  ;
}

//----- (08049EB8) --------------------------------------------------------
void sub_8049EB8()
{
  ;
}

//----- (08049EC8) --------------------------------------------------------
int sub_8049EC8()
{
  int result; // eax

  result = &unk_806E2C7 - &unk_806E2C4;
  if ( (unsigned int)(&unk_806E2C7 - &unk_806E2C4) > 6 )
    result = 0;
  return result;
}
// 8049EC8: could not find valid save-restore pair for ebp

//----- (08049FAA) --------------------------------------------------------
void sub_8049FAA()
{
  ;
}

//----- (08049FC5) --------------------------------------------------------
void sub_8049FC5()
{
  ;
}

//----- (08049FD5) --------------------------------------------------------
int sub_8049FD5()
{
  int result; // eax

  result = &unk_806A1DF - &unk_806A1DC;
  if ( (unsigned int)(&unk_806A1DF - &unk_806A1DC) > 6 )
    result = 0;
  return result;
}
// 8049FD5: could not find valid save-restore pair for ebp

//----- (0804A0E8) --------------------------------------------------------
void sub_804A0E8()
{
  ;
}

//----- (0804A103) --------------------------------------------------------
void sub_804A103()
{
  ;
}

//----- (0804A113) --------------------------------------------------------
int sub_804A113()
{
  int result; // eax

  result = &unk_806E2C7 - &unk_806E2C4;
  if ( (unsigned int)(&unk_806E2C7 - &unk_806E2C4) > 6 )
    result = 0;
  return result;
}
// 804A113: could not find valid save-restore pair for ebp

//----- (0804A171) --------------------------------------------------------
int sub_804A171()
{
  return nullsub_5();
}
// 804A171: could not find valid save-restore pair for ebp
// 804A170: using guessed type int nullsub_5(void);

//----- (0804A211) --------------------------------------------------------
void sub_804A211()
{
  ;
}

//----- (0804A22C) --------------------------------------------------------
void sub_804A22C()
{
  ;
}

//----- (0804A23C) --------------------------------------------------------
int sub_804A23C()
{
  int result; // eax

  result = &unk_806E2C7 - &unk_806E2C4;
  if ( (unsigned int)(&unk_806E2C7 - &unk_806E2C4) > 6 )
    result = 0;
  return result;
}
// 804A23C: could not find valid save-restore pair for ebp

//----- (0804A2EE) --------------------------------------------------------
int __usercall sub_804A2EE@<eax>(void (__cdecl *a1)(int *)@<eax>, signed __int32 a2@<ebx>)
{
  signed __int32 v3; // ebx
  signed __int32 v4; // ecx
  signed __int32 v5; // edx
  signed __int32 v6; // et1

  a1(&dword_8069F00);
  dword_806E124 = (int)&loc_804A268;
  v3 = _InterlockedExchange(&dword_806E128, a2);
  _InterlockedExchange(&dword_806E128, v4);
  v6 = _InterlockedExchange(&dword_806E128, sub_8068460(_InterlockedExchange(&dword_806E128, v3)));
  _InterlockedExchange(&dword_806E128, v5);
  _InterlockedExchange(&dword_806E128, v6);
  return 0;
}
// 8068460: using guessed type int __fastcall sub_8068460(_DWORD);
// 8069F00: using guessed type int dword_8069F00;
// 806E124: using guessed type int dword_806E124;
// 806E128: using guessed type int dword_806E128;

//----- (0804A36B) --------------------------------------------------------
void sub_804A36B()
{
  ;
}

//----- (0804A386) --------------------------------------------------------
void sub_804A386()
{
  ;
}

//----- (0804A396) --------------------------------------------------------
int sub_804A396()
{
  int result; // eax

  result = &unk_806E773 - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_806E773 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 804A396: could not find valid save-restore pair for ebp
// 806E2E0: using guessed type int program_invocation_short_name;

//----- (0804A4AA) --------------------------------------------------------
void sub_804A4AA()
{
  ;
}

//----- (0804A4C5) --------------------------------------------------------
void sub_804A4C5()
{
  ;
}

//----- (0804A4D5) --------------------------------------------------------
int sub_804A4D5()
{
  int result; // eax

  result = &unk_806E2C7 - &unk_806E2C4;
  if ( (unsigned int)(&unk_806E2C7 - &unk_806E2C4) > 6 )
    result = 0;
  return result;
}
// 804A4D5: could not find valid save-restore pair for ebp

//----- (0804A55F) --------------------------------------------------------
int sub_804A55F()
{
  int result; // eax

  result = sub_804A4D5();
  byte_806E801 = 1;
  return result;
}
// 806E801: using guessed type char byte_806E801;

//----- (0804A6DF) --------------------------------------------------------
void sub_804A6DF()
{
  ;
}

//----- (0804A6FA) --------------------------------------------------------
void sub_804A6FA()
{
  ;
}

//----- (0804A70A) --------------------------------------------------------
int __fastcall sub_804A70A(int a1)
{
  int result; // eax
  int (__stdcall *v2)(int *, int, int, int, int, int); // eax
  int v3; // [esp+4h] [ebp-18h]
  int v4; // [esp+8h] [ebp-14h]
  int v5; // [esp+Ch] [ebp-10h]
  int v6; // [esp+10h] [ebp-Ch]
  int v7; // [esp+14h] [ebp-8h]
  int v8; // [esp+18h] [ebp-4h]

  result = &unk_806E805 - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_806E805 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
  {
    v8 = 0;
    dword_806E174 = (int)&locret_804A719;
    v2 = (int (__stdcall *)(int *, int, int, int, int, int))sub_806823B(a1);
    result = v2(&program_invocation_short_name, v3, v4, v5, v6, v7);
  }
  return result;
}
// 806823B: using guessed type int __fastcall sub_806823B(_DWORD);
// 806E174: using guessed type int dword_806E174;
// 806E2E0: using guessed type int program_invocation_short_name;

//----- (0804A781) --------------------------------------------------------
int sub_804A781()
{
  return nullsub_6();
}
// 804A781: could not find valid save-restore pair for ebp
// 804A780: using guessed type int nullsub_6(void);

//----- (0804A892) --------------------------------------------------------
void sub_804A892()
{
  ;
}

//----- (0804A8AD) --------------------------------------------------------
void sub_804A8AD()
{
  ;
}

//----- (0804A8BD) --------------------------------------------------------
int sub_804A8BD()
{
  int result; // eax

  result = &unk_806E815 - (_UNKNOWN *)&program_invocation_name;
  if ( (unsigned int)(&unk_806E815 - (_UNKNOWN *)&program_invocation_name) > 6 )
    result = 0;
  return result;
}
// 804A8BD: could not find valid save-restore pair for ebp
// 806E2F0: using guessed type int program_invocation_name;

//----- (0804A96D) --------------------------------------------------------
int __cdecl sub_804A96D(unsigned __int64 a1)
{
  int result; // eax

  if ( HIDWORD(a1) )
    result = sub_80679C5(a1, 1000000LL) + 1000000;
  else
    result = a1;
  return result;
}

//----- (0804A9BB) --------------------------------------------------------
unsigned int __cdecl sub_804A9BB(int a1, unsigned int a2)
{
  return a2 - 1 + a1 - (a2 - 1 + a1) % a2;
}

//----- (0804A9ED) --------------------------------------------------------
int sub_804A9ED()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nWith no FILE, or when FILE is -, read standard input.\n");
  return fputs_unlocked(v1, v0);
}
// 8048F20: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804AA18) --------------------------------------------------------
int __cdecl sub_804AA18(char *s1)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  int v5; // ecx
  void *v6; // eax
  char *v7; // eax
  char *v9; // [esp+1Ch] [ebp-4Ch]
  const char **i; // [esp+20h] [ebp-48h]
  const char *v11; // [esp+28h] [ebp-40h]
  const char *v12; // [esp+2Ch] [ebp-3Ch]
  const char *v13; // [esp+30h] [ebp-38h]
  const char *v14; // [esp+34h] [ebp-34h]
  const char *v15; // [esp+38h] [ebp-30h]
  const char *v16; // [esp+3Ch] [ebp-2Ch]
  const char *v17; // [esp+40h] [ebp-28h]
  const char *v18; // [esp+44h] [ebp-24h]
  const char *v19; // [esp+48h] [ebp-20h]
  const char *v20; // [esp+4Ch] [ebp-1Ch]
  const char *v21; // [esp+50h] [ebp-18h]
  const char *v22; // [esp+54h] [ebp-14h]
  int v23; // [esp+58h] [ebp-10h]
  int v24; // [esp+5Ch] [ebp-Ch]

  v11 = "[";
  v12 = "test invocation";
  v13 = "coreutils";
  v14 = "Multi-call invocation";
  v15 = "sha224sum";
  v16 = "sha2 utilities";
  v17 = "sha256sum";
  v18 = "sha2 utilities";
  v19 = "sha384sum";
  v20 = "sha2 utilities";
  v21 = "sha512sum";
  v22 = "sha2 utilities";
  v23 = 0;
  v24 = 0;
  v9 = s1;
  for ( i = &v11; *i && strcmp(s1, *i); i += 2 )
    ;
  if ( i[1] )
    v9 = (char *)i[1];
  v2 = gettext("\n%s online help: <%s>\n");
  printf(v2, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  v1 = setlocale(5, 0);
  if ( v1 && strncmp(v1, "en_", 3u) )
  {
    v3 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
    printf(v3, s1);
  }
  v4 = gettext("Full documentation at: <%s%s>\n");
  printf(v4, "http://www.gnu.org/software/coreutils/", s1);
  v6 = &loc_804ABA2;
  if ( v9 != s1 )
    v6 = &loc_804ABA9;
  dword_806E248 = (int)v6;
  sub_8067C8C(v5);
  v7 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  return printf(v7, v9, " invocation");
}
// 8067C8C: using guessed type int __fastcall sub_8067C8C(_DWORD);
// 806E248: using guessed type int dword_806E248;

//----- (0804ABD3) --------------------------------------------------------
int __cdecl sub_804ABD3(int a1)
{
  return a1;
}

//----- (0804ABDB) --------------------------------------------------------
void __cdecl __noreturn sub_804ABDB(int status)
{
  int v1; // ebx
  char *v2; // eax
  int v3; // ebx
  char *v4; // eax
  FILE *v5; // ebx
  char *v6; // eax
  char *v7; // eax
  FILE *v8; // ebx
  char *v9; // eax
  FILE *v10; // ebx
  char *v11; // eax
  FILE *v12; // ebx
  char *v13; // eax
  FILE *v14; // ebx
  char *v15; // eax
  FILE *v16; // ebx
  char *v17; // eax
  char *v18; // eax

  if ( status )
  {
    v1 = dword_806E8B3;
    v2 = gettext("Try '%s --help' for more information.\n");
    fprintf(stderr, v2, v1);
  }
  else
  {
    v3 = dword_806E8B3;
    v4 = gettext("Usage: %s [OPTION]... [FILE]...\nPrint or check %s (%d-bit) checksums.\n");
    printf(v4, v3, "SHA512", 512);
    sub_804A9ED();
    v5 = stdout;
    v6 = gettext("\n  -b, --binary         read in binary mode\n");
    fputs_unlocked(v6, v5);
    v7 = gettext("  -c, --check          read %s sums from the FILEs and check them\n");
    printf(v7, "SHA512");
    v8 = stdout;
    v9 = gettext("      --tag            create a BSD-style checksum\n");
    fputs_unlocked(v9, v8);
    v10 = stdout;
    v11 = gettext("  -t, --text           read in text mode (default)\n");
    fputs_unlocked(v11, v10);
    v12 = stdout;
    v13 = gettext(
            "\n"
            "The following five options are useful only when verifying checksums:\n"
            "      --ignore-missing  don't fail or report status for missing files\n"
            "      --quiet          don't print OK for each successfully verified file\n"
            "      --status         don't output anything, status code shows success\n"
            "      --strict         exit non-zero for improperly formatted checksum lines\n"
            "  -w, --warn           warn about improperly formatted checksum lines\n"
            "\n");
    fputs_unlocked(v13, v12);
    v14 = stdout;
    v15 = gettext("      --help     display this help and exit\n");
    fputs_unlocked(v15, v14);
    v16 = stdout;
    v17 = gettext("      --version  output version information and exit\n");
    fputs_unlocked(v17, v16);
    v18 = gettext(
            "\n"
            "The sums are computed as described in %s.  When checking, the input\n"
            "should be a former output of this program.  The default mode is to print a\n"
            "line with checksum, a space, a character indicating input mode ('*' for binary,\n"
            "' ' for text or where binary is insignificant), and name for each FILE.\n");
    printf(v18, "FIPS-180-2");
    sub_804AA18("sha512sum");
  }
  exit(status);
}
// 8048F20: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 806E8B3: using guessed type int dword_806E8B3;

//----- (0804AD4B) --------------------------------------------------------
_BYTE *__cdecl sub_804AD4B(_BYTE *a1, unsigned int a2)
{
  signed __int32 v2; // ecx
  void *v3; // eax
  int v4; // ecx
  void *v5; // eax
  signed __int32 v6; // eax
  signed __int32 v7; // eax
  signed __int32 v8; // edx
  int v9; // ecx
  signed __int32 v10; // ecx
  signed __int32 v11; // et1
  _BYTE *v12; // eax
  _BYTE *v14; // [esp+8h] [ebp-8h]
  unsigned int i; // [esp+Ch] [ebp-4h]

  v14 = a1;
  for ( i = 0; i < a2; ++i )
  {
    v3 = &loc_804AD8E;
    if ( !a1[i] )
      v3 = &loc_804AF43;
    dword_806E20C = (int)v3;
    if ( sub_8067E16(v2, a1) == 92 )
    {
      v5 = &loc_804AF0C;
      if ( a2 - 1 != i )
        v5 = &loc_804AE3F;
      dword_806E1C4 = (int)v5;
      v6 = sub_8068003(v4);
      dword_806E174 = (int)&loc_804AE03;
      v7 = _InterlockedExchange(&dword_806E178, v6);
      _InterlockedExchange(&dword_806E178, v8);
      _InterlockedExchange(&dword_806E178, v7);
      v11 = _InterlockedExchange(&dword_806E178, sub_806823B(v9));
      _InterlockedExchange(&dword_806E178, v10);
      v2 = _InterlockedExchange(&dword_806E178, v11);
    }
    else
    {
      v12 = v14++;
      v2 = (signed __int32)a1;
      *v12 = a1[i];
    }
  }
  if ( &a1[a2] > v14 )
    *v14 = 0;
  return a1;
}
// 804AD4B: could not find valid save-restore pair for ebx
// 8067E16: using guessed type int __fastcall sub_8067E16(_DWORD, _DWORD);
// 8068003: using guessed type int __fastcall sub_8068003(_DWORD);
// 806823B: using guessed type int __fastcall sub_806823B(_DWORD);
// 806E174: using guessed type int dword_806E174;
// 806E178: using guessed type int dword_806E178;
// 806E1C4: using guessed type int dword_806E1C4;
// 806E20C: using guessed type int dword_806E20C;

//----- (0804AF88) --------------------------------------------------------
bool __cdecl sub_804AF88(_BYTE *a1)
{
  const unsigned __int16 **v1; // eax
  int v2; // ecx
  signed __int32 v3; // edx
  signed __int32 v4; // eax
  signed __int32 v5; // edx
  signed __int32 v6; // et1
  unsigned int i; // [esp+Ch] [ebp-Ch]

  for ( i = 0; i < dword_806E89F; ++i )
  {
    v1 = __ctype_b_loc();
    v3 = (signed __int32)*v1;
    if ( !((*v1)[(unsigned __int8)*a1] & 0x1000) )
    {
      dword_806E174 = (int)&locret_804B011;
      v4 = _InterlockedExchange(&dword_806E178, 0);
      _InterlockedExchange(&dword_806E178, v3);
      _InterlockedExchange(&dword_806E178, v4);
      v6 = _InterlockedExchange(&dword_806E178, sub_806823B(v2));
      _InterlockedExchange(&dword_806E178, v5);
      _InterlockedExchange(&dword_806E178, v6);
    }
    ++a1;
  }
  return *a1 == 0;
}
// 806823B: using guessed type int __fastcall sub_806823B(_DWORD);
// 806E174: using guessed type int dword_806E174;
// 806E178: using guessed type int dword_806E178;
// 806E89F: using guessed type int dword_806E89F;

//----- (0804B013) --------------------------------------------------------
bool __cdecl sub_804B013(_BYTE *a1, int a2, _BYTE **a3, _DWORD *a4, char a5)
{
  int v5; // ecx
  void *v7; // eax
  void *v8; // eax
  unsigned int v9; // [esp+1Ch] [ebp-Ch]
  int v10; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+1Ch] [ebp-Ch]

  if ( !a2 )
    return 0;
  v9 = a2 - 1;
  if ( a2 != 1 )
  {
    v7 = &loc_804B06C;
    if ( a1[v9] != 41 )
      v7 = &loc_804B03A;
    dword_806E1F8 = (int)v7;
    sub_8067E97(v5, a1);
  }
  if ( a1[v9] != 41 )
    return 0;
  *a4 = a1;
  if ( a5 && !sub_804AD4B(a1, v9) )
    return 0;
  v10 = a2;
  a1[a2 - 1] = 0;
  while ( a1[v10] == 32 || a1[v10] == 9 )
    ++v10;
  if ( a1[v10] != 61 )
    return 0;
  for ( i = v10 + 1; a1[i] == 32; ++i )
    ;
  v8 = &loc_804B13F;
  if ( a1[i] == 9 )
    v8 = &loc_804B104;
  dword_806E160 = (int)v8;
  sub_80682DA();
  *a3 = &a1[i];
  return sub_804AF88(*a3);
}
// 804B013: could not find valid save-restore pair for ebx
// 8067E97: using guessed type int __fastcall sub_8067E97(_DWORD, _DWORD);
// 80682DA: using guessed type int sub_80682DA(void);
// 806E160: using guessed type int dword_806E160;
// 806E1F8: using guessed type int dword_806E1F8;

//----- (0804B15B) --------------------------------------------------------
bool __cdecl sub_804B15B(int a1, int a2, _BYTE **a3, _DWORD *a4, _DWORD *a5)
{
  int v5; // ecx
  void *v6; // eax
  signed __int32 v7; // ecx
  signed __int32 v9; // eax
  signed __int32 v10; // ecx
  signed __int32 v11; // et1
  int v12; // ecx
  void *v13; // eax
  bool v14; // zf
  int v15; // edx
  int v16; // ecx
  void *v17; // eax
  char v18; // [esp+27h] [ebp-11h]
  int i; // [esp+28h] [ebp-10h]
  int v20; // [esp+28h] [ebp-10h]

  v18 = 0;
  for ( i = 0; ; ++i )
  {
    v6 = &loc_804B19B;
    if ( *(_BYTE *)(a1 + i) == 32 )
      v6 = &loc_804B16F;
    dword_806E1F8 = (int)v6;
    sub_8067E97(v5, a1);
    if ( *(_BYTE *)(a1 + i) != 9 )
      break;
  }
  if ( *(_BYTE *)(a1 + i) == 92 )
  {
    ++i;
    v18 = 1;
  }
  if ( !strncmp((const char *)(i + a1), "SHA512", 6u) )
  {
    i += 6;
    if ( *(_BYTE *)(a1 + i) == 32 )
      ++i;
    if ( *(_BYTE *)(a1 + i) == 40 )
    {
      *a4 = 0;
      return sub_804B013((_BYTE *)(a1 + i + 1), a2 - (i + 1), a3, a5, v18);
    }
    dword_806E110 = (int)&loc_804B520;
    v9 = _InterlockedExchange(&dword_806E114, 0);
    _InterlockedExchange(&dword_806E114, v7);
    v11 = _InterlockedExchange(&dword_806E114, sub_80684E1(_InterlockedExchange(&dword_806E114, v9), a1));
    _InterlockedExchange(&dword_806E114, v10);
    _InterlockedExchange(&dword_806E114, v11);
  }
  v12 = a2 - i;
  if ( a2 - i < (unsigned int)(*(_BYTE *)(a1 + i) == 92) + dword_806E89B )
    return 0;
  *a3 = (_BYTE *)(i + a1);
  v20 = dword_806E89F + i;
  v13 = &loc_804B304;
  if ( *(_BYTE *)(a1 + v20) == 32 )
    v13 = &loc_804B31D;
  dword_806E1B0 = (int)v13;
  sub_8068088(v12);
  if ( *(_BYTE *)(a1 + v20) != 9 )
    return 0;
  *(_BYTE *)(a1 + v20) = 0;
  v14 = sub_804AF88(*a3) == 1;
  v17 = &loc_804B35B;
  if ( v14 )
    v17 = &loc_804B365;
  dword_806E110 = (int)v17;
  sub_80684E1(v16, v15);
  return 0;
}
// 8067E97: using guessed type int __fastcall sub_8067E97(_DWORD, _DWORD);
// 8068088: using guessed type int __fastcall sub_8068088(_DWORD);
// 80684E1: using guessed type int __fastcall sub_80684E1(_DWORD, _DWORD);
// 806E110: using guessed type int dword_806E110;
// 806E114: using guessed type int dword_806E114;
// 806E1B0: using guessed type int dword_806E1B0;
// 806E1F8: using guessed type int dword_806E1F8;
// 806E89B: using guessed type int dword_806E89B;
// 806E89F: using guessed type int dword_806E89F;

//----- (0804B526) --------------------------------------------------------
int __usercall sub_804B526@<eax>(signed __int32 a1@<ebx>, int ecx0@<ecx>, _BYTE *a2, char a3)
{
  signed __int32 v4; // ebx
  signed __int32 v5; // ecx
  signed __int32 v6; // et0
  signed __int32 v7; // ebx
  signed __int32 v8; // edx
  void *v9; // eax

  if ( a3 != 1 )
  {
    fputs_unlocked(a2, stdout);
    dword_806E1B0 = (int)&locret_804B705;
    v4 = _InterlockedExchange(&dword_806E1B4, a1);
    v6 = _InterlockedExchange(&dword_806E1B4, v5);
    sub_8068088(_InterlockedExchange(&dword_806E1B4, v4));
    v7 = _InterlockedExchange(&dword_806E1B4, v6);
    _InterlockedExchange(&dword_806E1B4, v8);
    _InterlockedExchange(&dword_806E1B4, v7);
  }
  v9 = &locret_804B705;
  if ( *a2 )
    v9 = &loc_804B58D;
  dword_806E124 = (int)v9;
  return sub_8068460(ecx0);
}
// 8048F20: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8068088: using guessed type int __fastcall sub_8068088(_DWORD);
// 8068460: using guessed type int __fastcall sub_8068460(_DWORD);
// 806E124: using guessed type int dword_806E124;
// 806E1B0: using guessed type int dword_806E1B0;
// 806E1B4: using guessed type int dword_806E1B4;

//----- (0804B707) --------------------------------------------------------
int __usercall sub_804B707@<eax>(signed __int32 a1@<ebx>, char *s1, int a3, int a4, int a5)
{
  int v5; // edx
  int v6; // ecx
  bool v7; // ST1F_1
  int v8; // edx
  int v9; // ecx
  void *v10; // eax
  bool v12; // zf
  int v13; // edx
  int v14; // ecx
  void *v15; // eax
  FILE *stream; // [esp+18h] [ebp-10h]

  v7 = strcmp(s1, "-") == 0;
  *(_BYTE *)a5 = 0;
  if ( v7 )
  {
    byte_806E897 = 1;
    stream = stdin;
    sub_8063839(v5, v6, stdin, 2);
    goto LABEL_9;
  }
  stream = sub_8063938(a1, (int)s1, "r");
  if ( stream )
  {
    sub_8063839(v8, v9, stream, 2);
LABEL_9:
    v12 = sub_804DE2D(a1, stream) == 0;
    v15 = &loc_804B863;
    if ( v12 )
      v15 = &loc_804B8C2;
    dword_806E234 = (int)v15;
    sub_8067D07(v14, v13);
    sub_80657D5(0, 3);
  }
  v10 = &loc_804B78D;
  if ( !byte_806E8A5 )
    v10 = &loc_804B7A9;
  dword_806E14C = (int)v10;
  sub_8068355(v9);
  if ( *__errno_location() != 2 )
    sub_80657D5(0, 3);
  *(_BYTE *)a5 = 1;
  return 1;
}
// 8067D07: using guessed type int __fastcall sub_8067D07(_DWORD, _DWORD);
// 8068355: using guessed type int __fastcall sub_8068355(_DWORD);
// 806E14C: using guessed type int dword_806E14C;
// 806E234: using guessed type int dword_806E234;
// 806E897: using guessed type char byte_806E897;
// 806E8A5: using guessed type char byte_806E8A5;

//----- (0804B961) --------------------------------------------------------
void __usercall __noreturn sub_804B961(signed __int32 a1@<ebx>, const char *a2)
{
  signed __int32 v2; // ebx
  signed __int32 v3; // ecx
  signed __int32 v4; // et0
  signed __int32 v5; // ebx
  signed __int32 v6; // ecx
  signed __int32 v7; // ecx
  signed __int32 v8; // et1
  bool v9; // zf
  int v10; // edx
  int v11; // ecx
  int (*v12)(); // eax
  char *s1; // [esp+1Ch] [ebp-BCh]
  char v14; // [esp+84h] [ebp-54h]
  unsigned int v15; // [esp+CCh] [ebp-Ch]

  s1 = (char *)a2;
  v15 = __readgsdword(0x14u);
  sub_804A9BB((int)&v14, 8u);
  if ( strcmp(a2, "-") == 0 )
  {
    byte_806E897 = 1;
    s1 = gettext("standard input");
    dword_806E248 = (int)sub_804BAEF;
    v2 = _InterlockedExchange(&dword_806E24C, a1);
    v4 = _InterlockedExchange(&dword_806E24C, v3);
    sub_8067C8C(_InterlockedExchange(&dword_806E24C, v2));
    v5 = _InterlockedExchange(&dword_806E24C, v4);
    v8 = _InterlockedExchange(&dword_806E24C, v6);
    v7 = v5;
    a1 = v8;
    _InterlockedExchange(&dword_806E24C, v7);
  }
  v9 = sub_8063938(a1, (int)s1, "r") == 0;
  v12 = (int (*)())&loc_804BAA2;
  if ( !v9 )
    v12 = sub_804BAEF;
  dword_806E1F8 = (int)v12;
  sub_8067E97(v11, v10);
  sub_80657D5(0, 3);
}
// 804BAEF: using guessed type int sub_804BAEF();
// 8067C8C: using guessed type int __fastcall sub_8067C8C(_DWORD);
// 8067E97: using guessed type int __fastcall sub_8067E97(_DWORD, _DWORD);
// 806E1F8: using guessed type int dword_806E1F8;
// 806E248: using guessed type int dword_806E248;
// 806E24C: using guessed type int dword_806E24C;
// 806E897: using guessed type char byte_806E897;

//----- (0804C4A0) --------------------------------------------------------
_BOOL4 __usercall main@<eax>(signed __int32 a1@<ebx>, int argc, char **a3)
{
  void *v3; // eax
  void *v4; // eax
  void *v5; // eax
  int v6; // eax
  int v7; // ecx
  bool v8; // zf
  void *v9; // eax
  signed __int32 v10; // ebx
  signed __int32 v11; // ecx
  signed __int32 v12; // et0
  int v13; // edx
  int v14; // eax
  signed __int32 v15; // ebx
  signed __int32 v16; // ecx
  signed __int32 v17; // ecx
  signed __int32 v18; // et1
  signed __int32 v19; // ecx
  signed __int32 v20; // ebx
  signed __int32 v21; // ecx
  signed __int32 v22; // et2
  signed __int32 v23; // ecx
  signed __int32 v24; // ett
  signed __int32 v25; // ebx
  signed __int32 v26; // et0
  signed __int32 v27; // ebx
  signed __int32 v28; // edx
  signed __int32 v29; // edx
  signed __int32 v30; // et1
  signed __int32 v31; // ebx
  signed __int32 v32; // ecx
  signed __int32 v33; // et2
  signed __int32 v34; // ecx
  signed __int32 v35; // ett
  signed __int32 v36; // edx
  signed __int32 v37; // ecx
  char *v38; // eax
  char *v39; // eax
  void *v40; // eax
  char *v41; // eax
  void *v42; // eax
  char *v43; // eax
  void *v44; // eax
  char *v45; // eax
  char *v46; // eax
  void *v47; // eax
  int v48; // ecx
  char *v49; // eax
  void *v50; // eax
  _DWORD *v51; // ebx
  char **v52; // eax
  signed __int32 v53; // eax
  int v54; // ecx
  signed __int32 v55; // edx
  signed __int32 v56; // et1
  int v57; // eax
  signed __int32 v58; // edx
  int v59; // ecx
  signed __int32 v60; // eax
  signed __int32 v61; // ecx
  signed __int32 v62; // ett
  int v63; // edx
  int v64; // ecx
  bool v65; // al
  int v66; // ecx
  void *v67; // eax
  int v68; // eax
  int v69; // ecx
  char *v70; // ebx
  int *v71; // eax
  int v73; // [esp+3Bh] [ebp-79h]
  bool v74; // [esp+3Fh] [ebp-75h]
  int v75; // [esp+40h] [ebp-74h]
  int v76; // [esp+44h] [ebp-70h]
  char **v77; // [esp+48h] [ebp-6Ch]
  char **v78; // [esp+4Ch] [ebp-68h]
  unsigned int i; // [esp+50h] [ebp-64h]
  int v80; // [esp+54h] [ebp-60h]
  const char *v81; // [esp+58h] [ebp-5Ch]
  int v82; // [esp+5Ch] [ebp-58h]
  char *v83; // [esp+60h] [ebp-54h]
  int v84; // [esp+64h] [ebp-50h]
  unsigned int v85; // [esp+ACh] [ebp-8h]

  v85 = __readgsdword(0x14u);
  v80 = sub_804A9BB((int)&v84, 8u);
  *(_WORD *)((char *)&v73 + 1) = 256;
  v76 = -1;
  HIBYTE(v73) = 0;
  sub_8063A48(*a3);
  setlocale(6, &locale);
  bindtextdomain("coreutils", "/home/hwangdz/coreutils/coreutils-8.28/install_m32/share/locale");
  textdomain("coreutils");
  sub_8067BA9((int)sub_804CED6);
  setvbuf(stdout, 0, 1, 0);
  v81 = "bctw";
  while ( 1 )
  {
    v82 = getopt_long(argc, a3, v81, &longopts, 0);
    if ( v82 == -1 )
      break;
    if ( v82 == 119 )
    {
      byte_806E8A3 = 0;
      byte_806E8A4 = 1;
      byte_806E8A6 = 0;
      dword_806E188 = (int)&loc_804C82B;
      v25 = _InterlockedExchange(&dword_806E18C, a1);
      v26 = _InterlockedExchange(&dword_806E18C, v36);
      sub_80681B5(v37, _InterlockedExchange(&dword_806E18C, v25));
      v27 = _InterlockedExchange(&dword_806E18C, v26);
      v30 = _InterlockedExchange(&dword_806E18C, v28);
      v29 = v27;
      a1 = v30;
      _InterlockedExchange(&dword_806E18C, v29);
      goto LABEL_26;
    }
    if ( v82 > 119 )
    {
      if ( v82 == 130 )
      {
        byte_806E8A3 = 0;
        byte_806E8A4 = 0;
        byte_806E8A6 = 1;
        dword_806E1F8 = (int)&loc_804C82B;
        v31 = _InterlockedExchange(&dword_806E1FC, a1);
        v33 = _InterlockedExchange(&dword_806E1FC, v37);
        v32 = v31;
        a1 = v33;
        v35 = _InterlockedExchange(&dword_806E1FC, sub_8067E97(_InterlockedExchange(&dword_806E1FC, v32), v36));
        _InterlockedExchange(&dword_806E1FC, v34);
        _InterlockedExchange(&dword_806E1FC, v35);
        goto LABEL_28;
      }
      v5 = &loc_804C619;
      if ( v82 > 130 )
        v5 = &loc_804C67B;
      dword_806E1B0 = (int)v5;
      v6 = sub_8068088(v37);
      if ( v6 == 128 )
      {
LABEL_26:
        byte_806E8A5 = 1;
      }
      else
      {
        v8 = v6 == 129;
        v9 = &loc_804C644;
        if ( v8 )
          v9 = &loc_804C6DE;
        dword_806E220 = (int)v9;
        sub_8067D8E(v7);
        dword_806E110 = (int)&loc_804C81F;
        v10 = _InterlockedExchange(&dword_806E114, a1);
        v12 = _InterlockedExchange(&dword_806E114, v11);
        v14 = sub_80684E1(_InterlockedExchange(&dword_806E114, v10), v13);
        v15 = _InterlockedExchange(&dword_806E114, v12);
        v18 = _InterlockedExchange(&dword_806E114, v16);
        v17 = v15;
        a1 = v18;
        v19 = _InterlockedExchange(&dword_806E114, v17);
        if ( v14 == 131 )
        {
LABEL_28:
          byte_806E8A7 = 1;
        }
        else if ( v14 == 132 )
        {
          HIBYTE(v73) = 1;
          v76 = 1;
        }
        else
        {
          dword_806E14C = (int)&loc_804C81F;
          v20 = _InterlockedExchange(&dword_806E150, a1);
          v22 = _InterlockedExchange(&dword_806E150, v19);
          v21 = v20;
          a1 = v22;
          v24 = _InterlockedExchange(&dword_806E150, sub_8068355(_InterlockedExchange(&dword_806E150, v21)));
          _InterlockedExchange(&dword_806E150, v23);
          _InterlockedExchange(&dword_806E150, v24);
LABEL_23:
          v76 = 1;
        }
      }
    }
    else
    {
      if ( v82 == 98 )
        goto LABEL_23;
      if ( v82 <= 98 )
      {
        v3 = &loc_804C5B2;
        if ( v82 == -131 )
          v3 = &unk_804C7CC;
        dword_806E1B0 = (int)v3;
        if ( sub_8068088(v37) == -130 )
          sub_804ABDB(0);
LABEL_31:
        sub_804ABDB(1);
      }
      v4 = &loc_804C5E0;
      if ( v82 == 99 )
        v4 = &loc_804C6D4;
      dword_806E1C4 = (int)v4;
      if ( sub_8068003(v37) != 116 )
        goto LABEL_31;
      v76 = 0;
    }
  }
  dword_806E89B = 130;
  dword_806E89F = 128;
  if ( HIBYTE(v73) && !v76 )
  {
    v38 = gettext("--tag does not support --text mode");
    error(0, 0, v38);
    sub_804ABDB(1);
  }
  if ( HIBYTE(v73) && BYTE1(v73) )
  {
    v39 = gettext("the --tag option is meaningless when verifying checksums");
    error(0, 0, v39);
    sub_804ABDB(1);
  }
  if ( v76 >= 0 )
  {
    v40 = &loc_804C91C;
    if ( !BYTE1(v73) )
      v40 = &loc_804C94C;
    dword_806E1E4 = (int)v40;
    sub_8067F20(v37, v36);
    v41 = gettext("the --binary and --text options are meaningless when verifying checksums");
    error(0, 0, v41);
    sub_804ABDB(1);
  }
  if ( byte_806E8A5 )
  {
    v42 = &loc_804C97C;
    if ( BYTE1(v73) == 1 )
      v42 = &loc_804C9AC;
    dword_806E110 = (int)v42;
    sub_80684E1(v37, v36);
    v43 = gettext("the --ignore-missing option is meaningful only when verifying checksums");
    error(0, 0, v43);
    sub_804ABDB(1);
  }
  if ( byte_806E8A3 )
  {
    v44 = &loc_804C9DC;
    if ( BYTE1(v73) == 1 )
      v44 = &loc_804CA0C;
    dword_806E188 = (int)v44;
    sub_80681B5(v37, v36);
    v45 = gettext("the --status option is meaningful only when verifying checksums");
    error(0, 0, v45);
    sub_804ABDB(1);
  }
  if ( byte_806E8A4 && BYTE1(v73) != 1 )
  {
    v46 = gettext("the --warn option is meaningful only when verifying checksums");
    error(0, 0, v46);
    sub_804ABDB(1);
  }
  v47 = &loc_804CA77;
  if ( !byte_806E8A6 )
    v47 = &loc_804CAB3;
  dword_806E1C4 = (int)v47;
  sub_8068003(v37);
  if ( BYTE1(v73) != 1 )
  {
    v49 = gettext("the --quiet option is meaningful only when verifying checksums");
    error(0, 0, v49);
    sub_804ABDB(1);
  }
  if ( v76 < 0 )
    v76 = 0;
  v77 = &a3[argc];
  v50 = &loc_804CB44;
  if ( optind != argc )
    v50 = &loc_804CB5D;
  dword_806E14C = (int)v50;
  sub_8068355(v48);
  v51 = v77;
  ++v77;
  *v51 = sub_804ABD3((int)"-");
  v52 = &a3[optind];
  v78 = v52;
  dword_806E234 = (int)&loc_804CE31;
  v53 = _InterlockedExchange(&dword_806E238, (signed __int32)v52);
  _InterlockedExchange(&dword_806E238, 4 * optind);
  v56 = _InterlockedExchange(&dword_806E238, sub_8067D07(v54, _InterlockedExchange(&dword_806E238, v53)));
  _InterlockedExchange(&dword_806E238, v55);
  _InterlockedExchange(&dword_806E238, v56);
  do
  {
    v83 = *v78;
    if ( BYTE1(v73) )
      sub_804B961(BYTE2(v73), v83);
    v75 = v76;
    v57 = sub_804B707((signed __int32)v51, v83, (int)&v75, v80, (int)&v73) ^ 1;
    if ( (_BYTE)v57 )
    {
      BYTE2(v73) = 0;
      dword_806E174 = (int)&loc_804CE2C;
      v60 = _InterlockedExchange(&dword_806E178, v57);
      _InterlockedExchange(&dword_806E178, v58);
      _InterlockedExchange(&dword_806E178, v60);
      v62 = _InterlockedExchange(&dword_806E178, sub_806823B(v59));
      _InterlockedExchange(&dword_806E178, v61);
      _InterlockedExchange(&dword_806E178, v62);
    }
    v65 = strchr(v83, 92) || strchr(v83, 10);
    v74 = v65;
    if ( HIBYTE(v73) )
    {
      if ( v74 )
        putchar_unlocked(92);
      fwrite_unlocked("SHA512", 1u, 6u, stdout);
      fwrite_unlocked(" (", 1u, 2u, stdout);
      sub_804B526((signed __int32)v51, v66, v83, v74);
      fwrite_unlocked(") = ", 1u, 4u, stdout);
    }
    v67 = &loc_804CD88;
    if ( HIBYTE(v73) == 1 )
      v67 = &loc_804CD9B;
    dword_806E20C = (int)v67;
    sub_8067E16(v64, v63);
    if ( v74 )
      putchar_unlocked(92);
    for ( i = 0; (unsigned int)dword_806E89F >> 1 > i; ++i )
      printf("%02x", *(unsigned __int8 *)(v80 + i));
    if ( HIBYTE(v73) != 1 )
    {
      putchar_unlocked(32);
      if ( v75 )
        v68 = 42;
      else
        v68 = 32;
      putchar_unlocked(v68);
      sub_804B526((signed __int32)v51, v69, v83, v74);
    }
    putchar_unlocked(10);
    ++v78;
  }
  while ( v78 < v77 );
  if ( byte_806E897 && sub_8066967((signed __int32)v51, stdin) == -1 )
  {
    v70 = gettext("standard input");
    v71 = __errno_location();
    error(1, *v71, v70);
  }
  return BYTE2(v73) == 0;
}
// 8067D07: using guessed type int __fastcall sub_8067D07(_DWORD, _DWORD);
// 8067D8E: using guessed type int __fastcall sub_8067D8E(_DWORD);
// 8067E16: using guessed type int __fastcall sub_8067E16(_DWORD, _DWORD);
// 8067E97: using guessed type int __fastcall sub_8067E97(_DWORD, _DWORD);
// 8067F20: using guessed type int __fastcall sub_8067F20(_DWORD, _DWORD);
// 8068003: using guessed type int __fastcall sub_8068003(_DWORD);
// 8068088: using guessed type int __fastcall sub_8068088(_DWORD);
// 80681B5: using guessed type int __fastcall sub_80681B5(_DWORD, _DWORD);
// 806823B: using guessed type int __fastcall sub_806823B(_DWORD);
// 8068355: using guessed type int __fastcall sub_8068355(_DWORD);
// 80684E1: using guessed type int __fastcall sub_80684E1(_DWORD, _DWORD);
// 806E110: using guessed type int dword_806E110;
// 806E114: using guessed type int dword_806E114;
// 806E14C: using guessed type int dword_806E14C;
// 806E150: using guessed type int dword_806E150;
// 806E174: using guessed type int dword_806E174;
// 806E178: using guessed type int dword_806E178;
// 806E188: using guessed type int dword_806E188;
// 806E18C: using guessed type int dword_806E18C;
// 806E1B0: using guessed type int dword_806E1B0;
// 806E1C4: using guessed type int dword_806E1C4;
// 806E1E4: using guessed type int dword_806E1E4;
// 806E1F8: using guessed type int dword_806E1F8;
// 806E1FC: using guessed type int dword_806E1FC;
// 806E20C: using guessed type int dword_806E20C;
// 806E220: using guessed type int dword_806E220;
// 806E234: using guessed type int dword_806E234;
// 806E238: using guessed type int dword_806E238;
// 806E300: using guessed type int optind;
// 806E897: using guessed type char byte_806E897;
// 806E89B: using guessed type int dword_806E89B;
// 806E89F: using guessed type int dword_806E89F;
// 806E8A3: using guessed type char byte_806E8A3;
// 806E8A4: using guessed type char byte_806E8A4;
// 806E8A5: using guessed type char byte_806E8A5;
// 806E8A6: using guessed type char byte_806E8A6;
// 806E8A7: using guessed type char byte_806E8A7;

//----- (0804CED6) --------------------------------------------------------
int __usercall sub_804CED6@<eax>(signed __int32 a1@<ebx>)
{
  int v1; // edx
  int v2; // ecx
  void *v3; // eax
  _BYTE *v4; // ebx
  int *v5; // eax
  int result; // eax
  char *v7; // [esp+2Ch] [ebp-Ch]

  if ( sub_8066D27(a1, stdout) && (byte_806E8AF != 1 || *__errno_location() != 32) )
  {
    v7 = gettext("write error");
    v3 = &loc_804CF41;
    if ( !dword_806E8AB )
      v3 = &loc_804CF7C;
    dword_806E1E4 = (int)v3;
    sub_8067F20(v2, v1);
    v4 = sub_8065798(a1, dword_806E8AB);
    v5 = __errno_location();
    error(0, *v5, "%s: %s", v4, v7);
    _exit(status);
  }
  result = sub_8066D27(a1, stderr);
  if ( result )
    _exit(status);
  return result;
}
// 8067F20: using guessed type int __fastcall sub_8067F20(_DWORD, _DWORD);
// 806E1E4: using guessed type int dword_806E1E4;
// 806E8AB: using guessed type int dword_806E8AB;
// 806E8AF: using guessed type char byte_806E8AF;

//----- (0804CFD3) --------------------------------------------------------
_DWORD *__cdecl sub_804CFD3(_DWORD *a1)
{
  int v1; // edx
  _DWORD *result; // eax

  *a1 = -205731576;
  a1[1] = 1779033703;
  a1[2] = -2067093701;
  a1[3] = -1150833019;
  a1[4] = -23791573;
  a1[5] = 1013904242;
  a1[6] = 1595750129;
  a1[7] = -1521486534;
  a1[8] = -1377402159;
  a1[9] = 1359893119;
  a1[10] = 725511199;
  a1[11] = -1694144372;
  a1[12] = -79577749;
  a1[13] = 528734635;
  a1[14] = 327033209;
  a1[15] = 1541459225;
  a1[18] = 0;
  a1[19] = 0;
  v1 = a1[19];
  a1[16] = a1[18];
  a1[17] = v1;
  result = a1;
  a1[20] = 0;
  return result;
}

//----- (0804D08C) --------------------------------------------------------
_DWORD *__cdecl sub_804D08C(_DWORD *a1)
{
  int v1; // edx
  _DWORD *result; // eax

  *a1 = -1056596264;
  a1[1] = -876896931;
  a1[2] = 914150663;
  a1[3] = 1654270250;
  a1[4] = 812702999;
  a1[5] = -1856437926;
  a1[6] = -150054599;
  a1[7] = 355462360;
  a1[8] = -4191439;
  a1[9] = 1731405415;
  a1[10] = 1750603025;
  a1[11] = -1900787065;
  a1[12] = 1694076839;
  a1[13] = -619958771;
  a1[14] = -1090891868;
  a1[15] = 1203062813;
  a1[18] = 0;
  a1[19] = 0;
  v1 = a1[19];
  a1[16] = a1[18];
  a1[17] = v1;
  result = a1;
  a1[20] = 0;
  return result;
}

//----- (0804D145) --------------------------------------------------------
int __cdecl sub_804D145(_DWORD *a1, int a2, int a3)
{
  int result; // eax

  result = a2;
  *a1 = a2;
  a1[1] = a3;
  return result;
}

//----- (0804D167) --------------------------------------------------------
int __cdecl sub_804D167(int a1, int a2)
{
  _DWORD *v2; // edx
  int v3; // et1
  int v4; // ebx
  _DWORD *v5; // edx
  int v6; // et1
  int v7; // ST64_4
  _DWORD *v8; // edx
  int v9; // et1
  int v10; // ST58_4
  _DWORD *v11; // edx
  int v12; // et1
  unsigned int v13; // ST50_4
  int *v14; // edx
  int v15; // et1
  int v16; // ST20_4
  int *v17; // edx
  int v18; // et1
  signed int i; // [esp+80h] [ebp-18h]

  for ( i = 0; i <= 7; ++i )
  {
    v2 = (_DWORD *)(a1 + 8 * i);
    v3 = v2[1];
    v4 = *v2 << 24;
    v5 = (_DWORD *)(a1 + 8 * i);
    v6 = v5[1];
    v7 = ((*v5 & 0xFF00) << 8) | v4;
    v8 = (_DWORD *)(a1 + 8 * i);
    v9 = v8[1];
    v10 = *v8 & 0xFF0000;
    v11 = (_DWORD *)(a1 + 8 * i);
    v12 = v11[1];
    v13 = *v11 & 0xFF000000;
    v14 = (int *)(a1 + 8 * i);
    v15 = *v14;
    v16 = ((unsigned int)v14[1] >> 8) & 0xFF00;
    v17 = (int *)(a1 + 8 * i);
    v18 = *v17;
    sub_804D145(
      (_DWORD *)(8 * i + a2),
      ((unsigned int)v17[1] >> 24) | v16 | (*(_QWORD *)(a1 + 8 * i) >> 24) & 0xFF0000 | (*(_QWORD *)(a1 + 8 * i) >> 8) & 0xFF000000 | (v13 << 8) | (v10 << 24),
      ((unsigned __int64)v13 >> 24) | ((unsigned __int64)(unsigned int)v10 >> 8) | v7);
  }
  return a2;
}

//----- (0804D3EF) --------------------------------------------------------
int __cdecl sub_804D3EF(int a1, int a2)
{
  _DWORD *v2; // edx
  int v3; // et1
  int v4; // ebx
  _DWORD *v5; // edx
  int v6; // et1
  int v7; // ST64_4
  _DWORD *v8; // edx
  int v9; // et1
  int v10; // ST58_4
  _DWORD *v11; // edx
  int v12; // et1
  unsigned int v13; // ST50_4
  int *v14; // edx
  int v15; // et1
  int v16; // ST20_4
  int *v17; // edx
  int v18; // et1
  signed int i; // [esp+80h] [ebp-18h]

  for ( i = 0; i <= 5; ++i )
  {
    v2 = (_DWORD *)(a1 + 8 * i);
    v3 = v2[1];
    v4 = *v2 << 24;
    v5 = (_DWORD *)(a1 + 8 * i);
    v6 = v5[1];
    v7 = ((*v5 & 0xFF00) << 8) | v4;
    v8 = (_DWORD *)(a1 + 8 * i);
    v9 = v8[1];
    v10 = *v8 & 0xFF0000;
    v11 = (_DWORD *)(a1 + 8 * i);
    v12 = v11[1];
    v13 = *v11 & 0xFF000000;
    v14 = (int *)(a1 + 8 * i);
    v15 = *v14;
    v16 = ((unsigned int)v14[1] >> 8) & 0xFF00;
    v17 = (int *)(a1 + 8 * i);
    v18 = *v17;
    sub_804D145(
      (_DWORD *)(8 * i + a2),
      ((unsigned int)v17[1] >> 24) | v16 | (*(_QWORD *)(a1 + 8 * i) >> 24) & 0xFF0000 | (*(_QWORD *)(a1 + 8 * i) >> 8) & 0xFF000000 | (v13 << 8) | (v10 << 24),
      ((unsigned __int64)v13 >> 24) | ((unsigned __int64)(unsigned int)v10 >> 8) | v7);
  }
  return a2;
}

//----- (0804D6A0) --------------------------------------------------------
void __cdecl __noreturn sub_804D6A0(int a1)
{
  signed int v1; // eax
  int v2; // et1
  int v3; // et1
  int v4; // et1
  int v5; // et1
  unsigned int v6; // STF8_4
  int v7; // et1
  int v8; // STE8_4
  int v9; // et1
  int v10; // et1
  int v11; // et1
  int v12; // et1
  int v13; // et1
  int v14; // et1
  int v15; // et1
  int v16; // et1
  unsigned int v17; // [esp+128h] [ebp-20h]
  signed int v18; // [esp+12Ch] [ebp-1Ch]

  v17 = *(_DWORD *)(a1 + 80);
  if ( v17 > 0x6F )
    v1 = 32;
  else
    v1 = 16;
  v18 = v1;
  *(_QWORD *)(a1 + 64) += v17;
  if ( *(_QWORD *)(a1 + 64) < (unsigned __int64)v17 )
    ++*(_QWORD *)(a1 + 72);
  v2 = *(_DWORD *)(a1 + 76);
  v3 = *(_DWORD *)(a1 + 64);
  v4 = *(_DWORD *)(a1 + 64);
  v5 = *(_DWORD *)(a1 + 64);
  v6 = *(_QWORD *)(a1 + 68) >> 29;
  v7 = *(_DWORD *)(a1 + 64);
  v8 = *(_QWORD *)(a1 + 68) >> 29;
  v9 = *(_DWORD *)(a1 + 64);
  v10 = *(_DWORD *)(a1 + 64);
  v11 = *(_DWORD *)(a1 + 64);
  v12 = *(_DWORD *)(a1 + 64);
  sub_804D145(
    (_DWORD *)(8 * (v1 - 2 + 10) + a1 + 4),
    ((unsigned int)(*(_QWORD *)(a1 + 72) >> 29) >> 24) | ((unsigned int)(*(_QWORD *)(a1 + 72) >> 29) >> 8) & 0xFF00 | (__PAIR__(*(_QWORD *)(a1 + 72) >> 29, v6) >> 24) & 0xFF0000 | (__PAIR__(*(_QWORD *)(a1 + 72) >> 29, v6) >> 8) & 0xFF000000 | ((v8 & 0xFF000000) << 8) | ((v6 & 0xFF0000) << 24),
    ((v8 & 0xFF000000) >> 24) | ((v6 & 0xFF0000uLL) >> 8) | ((unsigned __int16)((*(_QWORD *)(a1 + 68) >> 29) & 0xFF00) << 8) | (v6 << 24));
  v13 = *(_DWORD *)(a1 + 68);
  v14 = *(_DWORD *)(a1 + 68);
  v15 = *(_DWORD *)(a1 + 68);
  v16 = *(_DWORD *)(a1 + 68);
  sub_804D145(
    (_DWORD *)(8 * (v18 - 1 + 10) + a1 + 4),
    ((unsigned int)(*(_QWORD *)(a1 + 64) >> 29) >> 24) | ((unsigned int)(*(_QWORD *)(a1 + 64) >> 29) >> 8) & 0xFF00 | ((unsigned __int64)(8LL * *(_QWORD *)(a1 + 64)) >> 24) & 0xFF0000 | ((unsigned __int64)(8LL * *(_QWORD *)(a1 + 64)) >> 8) & 0xFF000000 | ((8 * *(_DWORD *)(a1 + 64) & 0xFF000000) << 8) | ((8 * *(_DWORD *)(a1 + 64) & 0xFF0000) << 24),
    ((8 * *(_DWORD *)(a1 + 64) & 0xFF000000) >> 24) | ((8 * *(_DWORD *)(a1 + 64) & 0xFF0000u) >> 8) | ((unsigned __int16)(8 * *(unsigned int *)(a1 + 64) & 0xFF00) << 8) | (*(_DWORD *)(a1 + 64) << 27));
  memcpy((void *)(a1 + 84 + v17), &unk_8069230, 8 * (v18 + 536870910) - v17);
  sub_804E3FD(a1 + 84, 8 * v18, a1);
}
// 804E3FD: using guessed type void __cdecl __noreturn sub_804E3FD(_DWORD, _DWORD, _DWORD);

//----- (0804DDE3) --------------------------------------------------------
void __cdecl __noreturn sub_804DDE3(int a1)
{
  sub_804D6A0(a1);
}

//----- (0804DE08) --------------------------------------------------------
void __cdecl __noreturn sub_804DE08(int a1)
{
  sub_804D6A0(a1);
}

//----- (0804DE2D) --------------------------------------------------------
int __usercall sub_804DE2D@<eax>(signed __int32 a1@<ebx>, FILE *stream)
{
  char *v2; // eax
  int v3; // ecx
  bool v4; // zf
  void *v5; // eax
  signed __int32 v6; // ebx
  signed __int32 v7; // edx
  int v8; // ecx
  signed __int32 v9; // ecx
  signed __int32 v10; // et1
  size_t v12; // [esp+10h] [ebp-168h]
  char *ptr; // [esp+14h] [ebp-164h]
  size_t v14; // [esp+18h] [ebp-160h]
  int v15; // [esp+1Ch] [ebp-15Ch]

  v2 = (char *)malloc(0x8048u);
  ptr = v2;
  v4 = v2 == 0;
  v5 = &loc_804DE6A;
  if ( !v4 )
    v5 = &loc_804DEA5;
  dword_806E174 = (int)v5;
  sub_806823B(v3);
  dword_806E1B0 = (int)&locret_804DFC9;
  v6 = _InterlockedExchange(&dword_806E1B4, a1);
  _InterlockedExchange(&dword_806E1B4, v7);
  _InterlockedExchange(&dword_806E1B4, v6);
  v10 = _InterlockedExchange(&dword_806E1B4, sub_8068088(v8));
  _InterlockedExchange(&dword_806E1B4, v9);
  _InterlockedExchange(&dword_806E1B4, v10);
  sub_804CFD3(&v15);
  v12 = 0;
  while ( 1 )
  {
    v14 = fread_unlocked(&ptr[v12], 1u, 0x8000 - v12, stream);
    v12 += v14;
    if ( v12 == 0x8000 )
      sub_804E3FD(ptr, 0x8000, &v15);
    if ( !v14 )
      break;
    if ( feof_unlocked(stream) )
      goto LABEL_11;
  }
  if ( !ferror_unlocked(stream) )
  {
LABEL_11:
    if ( v12 )
      sub_804E204(ptr, v12, (int)&v15);
    sub_804DDE3((int)&v15);
  }
  free(ptr);
  return 1;
}
// 804E3FD: using guessed type void __cdecl __noreturn sub_804E3FD(_DWORD, _DWORD, _DWORD);
// 8068088: using guessed type int __fastcall sub_8068088(_DWORD);
// 806823B: using guessed type int __fastcall sub_806823B(_DWORD);
// 806E174: using guessed type int dword_806E174;
// 806E1B0: using guessed type int dword_806E1B0;
// 806E1B4: using guessed type int dword_806E1B4;

//----- (0804E204) --------------------------------------------------------
int __cdecl sub_804E204(void *src, size_t a2, int a3)
{
  int result; // eax
  int v4; // eax
  void *v5; // eax
  size_t v6; // ST14_4
  size_t v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]

  result = *(_DWORD *)(a3 + 80);
  if ( result )
  {
    v8 = *(_DWORD *)(a3 + 80);
    v4 = a2;
    if ( 256 - v8 <= a2 )
      v4 = 256 - v8;
    n = v4;
    memcpy((void *)(v8 + a3 + 84), src, v4);
    *(_DWORD *)(a3 + 80) += n;
    if ( *(_DWORD *)(a3 + 80) > 0x80u )
      sub_804E3FD(a3 + 84, *(_DWORD *)(a3 + 80) & 0xFFFFFF80, a3);
    src = (char *)src + n;
    result = n;
    a2 -= n;
  }
  if ( a2 > 0x7F )
  {
    result = (unsigned __int8)src & 3;
    if ( !((unsigned __int8)src & 3) )
      sub_804E3FD(src, a2 & 0xFFFFFF80, a3);
    if ( a2 > 0x80 )
    {
      v5 = memcpy((void *)(a3 + 84), src, 0x80u);
      sub_804E3FD(v5, 128, a3);
    }
  }
  if ( a2 )
  {
    v6 = *(_DWORD *)(a3 + 80);
    memcpy((void *)(v6 + a3 + 84), src, a2);
    v7 = a2 + v6;
    if ( v7 > 0x7F )
      sub_804E3FD(a3 + 84, 128, a3);
    result = a3;
    *(_DWORD *)(a3 + 80) = v7;
  }
  return result;
}
// 804E3FD: using guessed type void __cdecl __noreturn sub_804E3FD(_DWORD, _DWORD, _DWORD);

//----- (0804E3FD) --------------------------------------------------------
#error "804E3FD: too big function (funcsize=0)"

//----- (0806355E) --------------------------------------------------------
void __usercall __noreturn sub_806355E(int a1@<ebp>)
{
  _DWORD *v1; // eax
  int v2; // et1
  int v3; // ebx
  _DWORD *v4; // eax
  int v5; // et1
  int v6; // et1
  int v7; // edx
  _DWORD *v8; // eax
  int v9; // et1
  __int64 v10; // rcx
  _DWORD *v11; // eax
  int v12; // et1
  int v13; // edx
  int v14; // esi
  int v15; // edx
  int v16; // esi
  int v17; // edx
  int *v18; // eax
  int v19; // et1
  int *v20; // eax
  int v21; // et1
  int v22; // esi
  int v23; // esi
  int v24; // edx
  int v25; // esi
  int v26; // edx
  int v27; // eax
  int v28; // esi

  v1 = *(_DWORD **)(a1 - 1508);
  v2 = v1[1];
  v3 = *v1 << 24;
  v4 = *(_DWORD **)(a1 - 1508);
  v5 = v4[1];
  *(_DWORD *)(a1 - 1528) = *v4 & 0xFF00;
  *(_DWORD *)(a1 - 1524) = 0;
  v6 = *(_DWORD *)(a1 - 1524);
  v7 = *(_DWORD *)(a1 - 1528) << 8;
  *(_DWORD *)(a1 - 1536) = 0;
  *(_DWORD *)(a1 - 1532) = v7 | v3;
  v8 = *(_DWORD **)(a1 - 1508);
  v9 = v8[1];
  *(_DWORD *)(a1 - 1544) = *v8 & 0xFF0000;
  *(_DWORD *)(a1 - 1540) = 0;
  v10 = *(_QWORD *)(a1 - 1544) << 24;
  v11 = *(_DWORD **)(a1 - 1508);
  v12 = v11[1];
  *(_DWORD *)(a1 - 1552) = *v11 & 0xFF000000;
  *(_DWORD *)(a1 - 1548) = 0;
  v13 = *(_QWORD *)(a1 - 1552) >> 24;
  *(_DWORD *)(a1 - 1560) = (*(_DWORD *)(a1 - 1552) << 8) | v10;
  *(_DWORD *)(a1 - 1556) = v13 | HIDWORD(v10);
  v14 = *(_DWORD *)(a1 - 1532);
  v15 = *(_DWORD *)(a1 - 1556);
  *(_DWORD *)(a1 - 1568) = *(_DWORD *)(a1 - 1560) | *(_DWORD *)(a1 - 1536);
  *(_DWORD *)(a1 - 1564) = v15 | v14;
  *(_DWORD *)(a1 - 1576) = (*(_QWORD *)*(_DWORD *)(a1 - 1508) >> 8) & 0xFF000000;
  *(_DWORD *)(a1 - 1572) = 0;
  *(_DWORD *)(a1 - 1584) = (*(_QWORD *)*(_DWORD *)(a1 - 1508) >> 24) & 0xFF0000;
  *(_DWORD *)(a1 - 1580) = 0;
  v16 = *(_DWORD *)(a1 - 1572);
  v17 = *(_DWORD *)(a1 - 1580);
  *(_DWORD *)(a1 - 1592) = *(_DWORD *)(a1 - 1584) | *(_DWORD *)(a1 - 1576);
  *(_DWORD *)(a1 - 1588) = v17 | v16;
  v18 = *(int **)(a1 - 1508);
  v19 = *v18;
  *(_DWORD *)(a1 - 1600) = ((unsigned int)v18[1] >> 8) & 0xFF00;
  *(_DWORD *)(a1 - 1596) = 0;
  v20 = *(int **)(a1 - 1508);
  v21 = *v20;
  v22 = *(_DWORD *)(a1 - 1596);
  *(_DWORD *)(a1 - 1608) = ((unsigned int)v20[1] >> 24) | *(_DWORD *)(a1 - 1600);
  *(_DWORD *)(a1 - 1604) = v22;
  v23 = *(_DWORD *)(a1 - 1588);
  v24 = *(_DWORD *)(a1 - 1604);
  *(_DWORD *)(a1 - 1616) = *(_DWORD *)(a1 - 1608) | *(_DWORD *)(a1 - 1592);
  *(_DWORD *)(a1 - 1612) = v24 | v23;
  v25 = *(_DWORD *)(a1 - 1564);
  v26 = *(_DWORD *)(a1 - 1612);
  *(_DWORD *)(a1 - 1624) = *(_DWORD *)(a1 - 1616) | *(_DWORD *)(a1 - 1568);
  *(_DWORD *)(a1 - 1620) = v26 | v25;
  v27 = *(_DWORD *)(a1 - 1504);
  v28 = *(_DWORD *)(a1 - 1620);
  *(_DWORD *)(a1 + 8 * v27 - 144) = *(_DWORD *)(a1 - 1624);
  *(_DWORD *)(a1 + 8 * v27 - 140) = v28;
  *(_DWORD *)(a1 - 1508) += 8;
  ++*(_DWORD *)(a1 - 1504);
  JUMPOUT(&loc_804F142);
}

//----- (080637DD) --------------------------------------------------------
#error "80637E3: positive sp value has been found (funcsize=0)"

//----- (080637E8) --------------------------------------------------------
int __cdecl sub_80637E8(int a1, int a2, int a3, int a4, int a5, int a6)
{
  return posix_fadvise64(a1, a2, a3, a4, a5, a6);
}
// 8049050: using guessed type int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (08063839) --------------------------------------------------------
int __usercall sub_8063839@<eax>(int a1@<edx>, int a2@<ecx>, FILE *stream, int a4)
{
  void *v4; // eax
  int v5; // eax

  v4 = &loc_806385E;
  if ( !stream )
    v4 = &locret_806386E;
  dword_806E1F8 = (int)v4;
  sub_8067E97(a2, a1);
  v5 = fileno(stream);
  return sub_80637E8(v5, 0, 0, 0, 0, a4);
}
// 8067E97: using guessed type int __fastcall sub_8067E97(_DWORD, _DWORD);
// 806E1F8: using guessed type int dword_806E1F8;

//----- (08063938) --------------------------------------------------------
FILE *__usercall sub_8063938@<eax>(signed __int32 a1@<ebx>, int a2, char *modes)
{
  void *v3; // eax
  int v4; // edx
  int v5; // ecx
  int v6; // eax
  int v8; // ST30_4
  int v9; // ST34_4
  FILE *stream; // [esp+1Ch] [ebp-1Ch]
  signed int v11; // [esp+20h] [ebp-18h]
  int fd; // [esp+24h] [ebp-14h]

  stream = (FILE *)fopen64(a2, modes);
  if ( stream )
  {
    v11 = fileno(stream);
    if ( v11 >= 0 )
    {
      v3 = &loc_8063994;
      if ( v11 > 2 )
        v3 = &loc_8063A43;
      dword_806E160 = (int)v3;
      sub_80682DA();
      v6 = sub_8065BD3(a1, v4, v5, v11);
      fd = v6;
      if ( v6 < 0 )
      {
        v8 = *__errno_location();
        sub_8066967(a1, stream);
        *__errno_location() = v8;
        return 0;
      }
      if ( sub_8066967(a1, stream) || (stream = fdopen(fd, modes)) == 0 )
      {
        v9 = *__errno_location();
        close(fd);
        *__errno_location() = v9;
        return 0;
      }
    }
  }
  return stream;
}
// 8048E10: using guessed type int __cdecl fopen64(_DWORD, _DWORD);
// 80682DA: using guessed type int sub_80682DA(void);
// 806E160: using guessed type int dword_806E160;

//----- (08063A48) --------------------------------------------------------
char *__cdecl sub_8063A48(char *s)
{
  char *v1; // eax
  char *result; // eax
  char *v3; // eax
  char *s1; // [esp+1Ch] [ebp-Ch]

  if ( !s )
  {
    fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
    abort();
  }
  v3 = strrchr(s, 47);
  if ( v3 )
    v1 = v3 + 1;
  else
    v1 = s;
  s1 = v1;
  if ( v1 - s > 6 && !strncmp(v1 - 7, "/.libs/", 7u) )
  {
    s = s1;
    if ( !strncmp(s1, "lt-", 3u) )
    {
      s = s1 + 3;
      program_invocation_short_name = (int)(s1 + 3);
    }
  }
  dword_806E8B3 = (int)s;
  result = s;
  program_invocation_name = (int)s;
  return result;
}
// 806E2E0: using guessed type int program_invocation_short_name;
// 806E2F0: using guessed type int program_invocation_name;
// 806E8B3: using guessed type int dword_806E8B3;

//----- (08063C3C) --------------------------------------------------------
int __cdecl sub_8063C3C(int *a1, unsigned __int8 a2, char a3)
{
  int *v3; // eax
  int v4; // ST10_4

  if ( a1 )
    v3 = a1;
  else
    v3 = &dword_806E8CB;
  v4 = ((unsigned int)v3[(a2 >> 5) + 2] >> (a2 & 0x1F)) & 1;
  v3[(a2 >> 5) + 2] ^= (v4 ^ a3 & 1) << (a2 & 0x1F);
  return v4;
}
// 806E8CB: using guessed type int dword_806E8CB;

//----- (08063CFF) --------------------------------------------------------
int *__usercall sub_8063CFF@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5)
{
  void *v5; // eax
  int *result; // eax

  v5 = &loc_8063D24;
  if ( a3 )
    v5 = &loc_8063D2B;
  dword_806E20C = (int)v5;
  sub_8067E16(a2, a1);
  dword_806E8CB = 10;
  if ( !a4 || !a5 )
    abort();
  *(&dword_806E8CB + 10) = a4;
  result = &dword_806E8CB;
  *(&dword_806E8CB + 11) = a5;
  return result;
}
// 8067E16: using guessed type int __fastcall sub_8067E16(_DWORD, _DWORD);
// 806E20C: using guessed type int dword_806E20C;
// 806E8CB: using guessed type int dword_806E8CB;

//----- (08063DBC) --------------------------------------------------------
void __cdecl __noreturn sub_8063DBC(int a1, int a2)
{
  int (__stdcall *v2)(int); // eax
  char v3; // [esp+0h] [ebp-38h]

  memset(&v3, 0, 0x30u);
  v2 = (int (__stdcall *)(int))&loc_8063DF6;
  if ( a2 != 10 )
    v2 = sub_8063DFB;
  dword_806E234 = (int)v2;
  sub_8067D07(0, 12);
  abort();
}
// 8063DFB: using guessed type int __stdcall sub_8063DFB(int);
// 8067D07: using guessed type int __fastcall sub_8067D07(_DWORD, _DWORD);
// 806E234: using guessed type int dword_806E234;

//----- (08063DFB) --------------------------------------------------------
#error "8063E51: positive sp value has been found (funcsize=0)"

//----- (08063E57) --------------------------------------------------------
void *__usercall sub_8063E57@<eax>(signed __int32 a1@<ebx>, char *msgid, int a3)
{
  char *v3; // eax
  int v4; // ecx
  bool v5; // zf
  void *v6; // eax
  signed __int32 v7; // eax
  signed __int32 v8; // edx
  int v9; // ecx
  signed __int32 v10; // eax
  signed __int32 v11; // ebx
  signed __int32 v12; // edx
  signed __int32 v13; // et1
  signed __int32 v14; // eax
  int v15; // ecx
  int v16; // eax
  signed __int32 v17; // ebx
  signed __int32 v18; // ecx
  signed __int32 v19; // ett
  signed __int32 v20; // ecx
  signed __int32 v21; // ebx
  signed __int32 v22; // et0
  signed __int32 v23; // ecx
  signed __int32 v24; // edx
  signed __int32 v25; // edx
  void *result; // eax
  void *v27; // eax
  signed __int32 v28; // [esp+18h] [ebp-10h]

  v3 = gettext(msgid);
  v28 = (signed __int32)v3;
  v5 = v3 == msgid;
  v6 = &loc_8063E8C;
  if ( v5 )
    v6 = &loc_8063EA9;
  dword_806E1B0 = (int)v6;
  sub_8068088(v4);
  dword_806E19C = (int)&locret_8063FFB;
  v7 = _InterlockedExchange(&dword_806E1A0, v28);
  _InterlockedExchange(&dword_806E1A0, v8);
  v10 = sub_806811D(v9, _InterlockedExchange(&dword_806E1A0, v7));
  v11 = _InterlockedExchange(&dword_806E1A0, a1);
  v13 = _InterlockedExchange(&dword_806E1A0, v12);
  dword_806E1C4 = (int)&loc_8063EA9;
  v14 = _InterlockedExchange(&dword_806E1C8, v10);
  _InterlockedExchange(&dword_806E1C8, _InterlockedExchange(&dword_806E1A0, v11));
  _InterlockedExchange(&dword_806E1C8, v14);
  v16 = sub_8068003(v15);
  v17 = _InterlockedExchange(&dword_806E1C8, v13);
  v19 = _InterlockedExchange(&dword_806E1C8, v18);
  v20 = _InterlockedExchange(&dword_806E1C8, v17);
  v21 = _InterlockedExchange(&dword_806E258, _InterlockedExchange(&dword_806E258, v19));
  v22 = _InterlockedExchange(&dword_806E258, v20);
  v23 = _InterlockedExchange(&dword_806E258, v21);
  _InterlockedExchange(&dword_806E258, v24);
  v25 = _InterlockedExchange(&dword_806E258, v22);
  if ( v16 )
  {
    v27 = &loc_8063FEF;
    if ( a3 != 9 )
      v27 = &loc_8063FF6;
    dword_806E20C = (int)v27;
    sub_8067E16(v23, v25);
    result = &unk_8069675;
  }
  else if ( *msgid == 96 )
  {
    result = &unk_806966E;
  }
  else
  {
    result = &unk_8069672;
  }
  return result;
}
// 8067E16: using guessed type int __fastcall sub_8067E16(_DWORD, _DWORD);
// 8068003: using guessed type int __fastcall sub_8068003(_DWORD);
// 8068088: using guessed type int __fastcall sub_8068088(_DWORD);
// 806811D: using guessed type int __fastcall sub_806811D(_DWORD, _DWORD);
// 806E19C: using guessed type int dword_806E19C;
// 806E1A0: using guessed type int dword_806E1A0;
// 806E1B0: using guessed type int dword_806E1B0;
// 806E1C4: using guessed type int dword_806E1C4;
// 806E1C8: using guessed type int dword_806E1C8;
// 806E20C: using guessed type int dword_806E20C;
// 806E258: using guessed type int dword_806E258;

//----- (08063FFD) --------------------------------------------------------
unsigned int __usercall sub_8063FFD@<eax>(unsigned __int32 a1@<ebx>, _BYTE *a2, unsigned int a3, signed __int32 a4, unsigned int a5, signed int a6, int a7, int a8, char *a9, const char *a10)
{
  int v10; // edx
  signed __int32 v11; // ecx
  void *v12; // eax
  signed __int32 v13; // ecx
  signed __int32 v14; // eax
  signed __int32 v15; // ecx
  signed __int32 v16; // et1
  signed __int32 v17; // ebx
  signed __int32 v18; // ecx
  signed __int32 v19; // ett
  void *v20; // eax
  int v21; // ecx
  void *v22; // eax
  unsigned __int32 v23; // eax
  signed __int32 v24; // eax
  signed __int32 v25; // edx
  signed __int32 v26; // ebx
  signed __int32 v27; // ebx
  signed __int32 v28; // ecx
  signed __int32 v29; // ecx
  unsigned __int32 v30; // et1
  int v31; // eax
  signed __int32 v32; // eax
  signed __int32 v33; // edx
  signed __int32 v34; // ett
  void *v35; // eax
  _BYTE *v36; // edx
  char v37; // ST4D_1
  signed __int32 v38; // ebx
  signed __int32 v39; // et0
  signed __int32 v40; // ebx
  signed __int32 v41; // edx
  signed __int32 v42; // edx
  unsigned __int32 v43; // et1
  signed __int32 v44; // ebx
  signed __int32 v45; // edx
  unsigned __int32 v46; // et2
  signed __int32 v47; // ecx
  signed __int32 v48; // ett
  void *v49; // eax
  signed __int32 v50; // ebx
  signed __int32 v51; // edx
  signed __int32 v52; // et0
  int v53; // ecx
  signed __int32 v54; // ebx
  signed __int32 v55; // edx
  signed __int32 v56; // edx
  signed __int32 v57; // et1
  signed __int32 v58; // ebx
  signed __int32 v59; // ecx
  signed __int32 v60; // ecx
  unsigned __int32 v61; // et2
  signed __int32 v62; // edx
  signed __int32 v63; // ett
  void *v64; // eax
  char v65; // al
  signed __int32 v66; // ebx
  signed __int32 v67; // et0
  signed __int32 v68; // ebx
  signed __int32 v69; // ecx
  signed __int32 v70; // ecx
  unsigned __int32 v71; // et1
  signed __int32 v72; // eax
  signed __int32 v73; // ecx
  signed __int32 v74; // ett
  void *v75; // eax
  void *v76; // eax
  const unsigned __int16 **v77; // eax
  void *v78; // eax
  _BYTE *v79; // edx
  void *v80; // eax
  int v81; // ecx
  int v82; // edx
  void *v83; // eax
  signed __int32 v84; // ebx
  signed __int32 v85; // et0
  signed __int32 v86; // ebx
  signed __int32 v87; // edx
  signed __int32 v88; // edx
  unsigned __int32 v89; // et1
  void *v90; // eax
  int v91; // ecx
  void *v92; // eax
  void *v93; // eax
  void *v94; // eax
  int v95; // ecx
  void *v96; // eax
  void *v97; // eax
  int v98; // edx
  int v99; // ecx
  void *v100; // eax
  unsigned int result; // eax
  void *v102; // eax
  const char *v103; // [esp+2Ch] [ebp-5Ch]
  char *v104; // [esp+30h] [ebp-58h]
  char v105; // [esp+40h] [ebp-48h]
  bool v106; // [esp+41h] [ebp-47h]
  char v107; // [esp+42h] [ebp-46h]
  char v108; // [esp+43h] [ebp-45h]
  char v109; // [esp+44h] [ebp-44h]
  unsigned __int8 v110; // [esp+45h] [ebp-43h]
  char v111; // [esp+46h] [ebp-42h]
  char v112; // [esp+47h] [ebp-41h]
  char v113; // [esp+48h] [ebp-40h]
  bool v114; // [esp+49h] [ebp-3Fh]
  bool v115; // [esp+4Ah] [ebp-3Eh]
  bool v116; // [esp+4Bh] [ebp-3Dh]
  _BYTE *v117; // [esp+50h] [ebp-38h]
  unsigned int v118; // [esp+54h] [ebp-34h]
  unsigned int v119; // [esp+54h] [ebp-34h]
  unsigned int v120; // [esp+54h] [ebp-34h]
  unsigned int v121; // [esp+54h] [ebp-34h]
  unsigned int v122; // [esp+54h] [ebp-34h]
  unsigned int v123; // [esp+54h] [ebp-34h]
  unsigned int v124; // [esp+54h] [ebp-34h]
  unsigned int v125; // [esp+54h] [ebp-34h]
  unsigned int v126; // [esp+54h] [ebp-34h]
  unsigned int v127; // [esp+54h] [ebp-34h]
  unsigned int v128; // [esp+54h] [ebp-34h]
  unsigned int v129; // [esp+54h] [ebp-34h]
  unsigned int v130; // [esp+54h] [ebp-34h]
  unsigned int v131; // [esp+54h] [ebp-34h]
  unsigned int v132; // [esp+54h] [ebp-34h]
  unsigned int v133; // [esp+54h] [ebp-34h]
  unsigned int v134; // [esp+54h] [ebp-34h]
  unsigned int v135; // [esp+54h] [ebp-34h]
  unsigned int v136; // [esp+58h] [ebp-30h]
  char *s; // [esp+5Ch] [ebp-2Ch]
  char *sa; // [esp+5Ch] [ebp-2Ch]
  size_t n; // [esp+60h] [ebp-28h]
  unsigned int v140; // [esp+70h] [ebp-18h]

  v104 = a9;
  v103 = a10;
  v118 = 0;
  v136 = 0;
  s = 0;
  n = 0;
  v105 = 0;
  v116 = __ctype_get_mb_cur_max() == 1;
  v106 = (a7 & 2) != 0;
  v107 = 0;
  v108 = 0;
  v109 = 1;
  switch ( a6 )
  {
    case 0:
      dword_806E1B0 = (int)&loc_8064250;
      v17 = _InterlockedExchange(&dword_806E1B4, a1);
      _InterlockedExchange(&dword_806E1B4, v11);
      v19 = _InterlockedExchange(&dword_806E1B4, sub_8068088(_InterlockedExchange(&dword_806E1B4, v17)));
      _InterlockedExchange(&dword_806E1B4, v18);
      _InterlockedExchange(&dword_806E1B4, v19);
      goto LABEL_28;
    case 1:
      goto LABEL_19;
    case 2:
      goto LABEL_22;
    case 3:
      v105 = 1;
LABEL_19:
      v106 = 1;
      goto LABEL_20;
    case 4:
LABEL_20:
      if ( v106 != 1 )
        v105 = 1;
LABEL_22:
      a6 = 2;
      if ( v106 != 1 )
      {
        if ( a3 > 0 )
        {
          v10 = (int)a2;
          *a2 = 39;
        }
        v118 = 1;
      }
      s = "'";
      n = 1;
      break;
    case 5:
      goto LABEL_4;
    case 6:
      a6 = 5;
      v106 = 1;
LABEL_4:
      if ( v106 != 1 )
      {
        if ( a3 > 0 )
        {
          v10 = (int)a2;
          *a2 = 34;
        }
        v118 = 1;
      }
      v105 = 1;
      s = (char *)&unk_8069675;
      n = 1;
      break;
    case 7:
      v105 = 1;
      v106 = 0;
      break;
    case 8:
    case 9:
    case 10:
      v12 = &loc_8064108;
      if ( a6 == 10 )
        v12 = &loc_8064134;
      dword_806E220 = (int)v12;
      sub_8067D8E(v11);
      v104 = (char *)sub_8063E57(a1, "`", a6);
      v103 = (const char *)sub_8063E57(a1, "'", a6);
      if ( v106 != 1 )
      {
        sa = v104;
        dword_806E1C4 = (int)&loc_806419A;
        v14 = _InterlockedExchange(&dword_806E1C8, (signed __int32)v104);
        _InterlockedExchange(&dword_806E1C8, v13);
        v16 = _InterlockedExchange(&dword_806E1C8, sub_8068003(_InterlockedExchange(&dword_806E1C8, v14)));
        _InterlockedExchange(&dword_806E1C8, v15);
        _InterlockedExchange(&dword_806E1C8, v16);
        do
        {
          if ( v118 < a3 )
            a2[v118] = *sa;
          ++v118;
          ++sa;
        }
        while ( *sa );
      }
      v105 = 1;
      s = (char *)v103;
      n = strlen(v103);
      break;
    default:
LABEL_28:
      abort();
      return result;
  }
  v117 = 0;
  while ( 1 )
  {
    v94 = &loc_8064E68;
    if ( a5 != -1 )
      v94 = &loc_8064E7A;
    dword_806E20C = (int)v94;
    sub_8067E16(v11, v10);
    if ( !v117[a4] )
      break;
    v112 = 0;
    v113 = 0;
    v114 = 0;
    v20 = &loc_8064287;
    if ( !v105 )
      v20 = &loc_806430C;
    dword_806E188 = (int)v20;
    sub_80681B5(v95, a4);
    v22 = &loc_80642A6;
    if ( a6 == 2 )
      v22 = &loc_806430C;
    dword_806E1B0 = (int)v22;
    sub_8068088(v21);
    if ( n )
    {
      a1 = (unsigned __int32)&v117[n];
      if ( a5 != -1 || n <= 1 )
      {
        v23 = a5;
      }
      else
      {
        v23 = strlen((const char *)a4);
        a5 = v23;
      }
      if ( a1 <= v23 && !memcmp(&v117[a4], s, n) )
      {
        if ( v106 )
          goto LABEL_2;
        v112 = 1;
      }
    }
    v10 = a4;
    v110 = v117[a4];
    v24 = v110;
    switch ( v110 )
    {
      case 0u:
        if ( v105 )
        {
          if ( v106 )
          {
            dword_806E20C = (int)&loc_8064094;
            v25 = _InterlockedExchange(&dword_806E210, a1);
            v26 = _InterlockedExchange(&dword_806E210, a4);
            sub_8067E16(v11, _InterlockedExchange(&dword_806E210, v25));
            v27 = _InterlockedExchange(&dword_806E210, v26);
            v30 = _InterlockedExchange(&dword_806E210, v28);
            v29 = v27;
            a1 = v30;
            v11 = _InterlockedExchange(&dword_806E210, v29);
          }
          if ( a6 == 2 && v107 != 1 )
          {
            if ( v118 < a3 )
              a2[v118] = 39;
            v119 = v118 + 1;
            if ( v119 < a3 )
              a2[v119] = 36;
            v120 = v119 + 1;
            if ( v120 < a3 )
              a2[v120] = 39;
            v118 = v120 + 1;
            v107 = 1;
          }
          v31 = v118;
          if ( v118 < a3 )
          {
            v31 = (int)&a2[v118];
            a2[v118] = 92;
          }
          ++v118;
          if ( a6 != 2 )
          {
            v31 = (int)(v117 + 1);
            if ( (unsigned int)(v117 + 1) < a5 )
            {
              v31 = (unsigned __int8)v117[a4 + 1];
              if ( (char)v31 > 47 )
              {
                v31 = (unsigned __int8)v117[a4 + 1];
                if ( (char)v31 <= 57 )
                {
                  if ( v118 < a3 )
                    a2[v118] = 48;
                  v121 = v118 + 1;
                  v31 = v121;
                  if ( v121 < a3 )
                  {
                    v31 = (int)&a2[v121];
                    a2[v121] = 48;
                  }
                  v118 = v121 + 1;
                }
              }
            }
          }
        }
        else
        {
          v31 = a7 & 1;
          if ( a7 & 1 )
            goto LABEL_210;
        }
        dword_806E174 = (int)&loc_8064C65;
        v32 = _InterlockedExchange(&dword_806E178, v31);
        _InterlockedExchange(&dword_806E178, v11);
        v34 = _InterlockedExchange(&dword_806E178, sub_806823B(_InterlockedExchange(&dword_806E178, v32)));
        _InterlockedExchange(&dword_806E178, v33);
        v10 = _InterlockedExchange(&dword_806E178, v34);
        goto LABEL_70;
      case 7u:
        goto LABEL_91;
      case 8u:
        v111 = 98;
        goto LABEL_107;
      case 9u:
        v111 = 116;
        goto LABEL_105;
      case 0xAu:
        v111 = 110;
        goto LABEL_105;
      case 0xBu:
        v111 = 118;
        goto LABEL_107;
      case 0xCu:
        v111 = 102;
        goto LABEL_107;
      case 0xDu:
        v111 = 114;
        goto LABEL_105;
      case 0x20u:
        goto LABEL_114;
      case 0x21u:
      case 0x22u:
      case 0x24u:
      case 0x26u:
      case 0x28u:
      case 0x29u:
      case 0x2Au:
      case 0x3Bu:
      case 0x3Cu:
      case 0x3Du:
      case 0x3Eu:
      case 0x5Bu:
      case 0x5Eu:
      case 0x60u:
      case 0x7Cu:
        goto LABEL_115;
      case 0x23u:
      case 0x7Eu:
        goto LABEL_113;
      case 0x25u:
      case 0x2Bu:
      case 0x2Cu:
      case 0x2Du:
      case 0x2Eu:
      case 0x2Fu:
      case 0x30u:
      case 0x31u:
      case 0x32u:
      case 0x33u:
      case 0x34u:
      case 0x35u:
      case 0x36u:
      case 0x37u:
      case 0x38u:
      case 0x39u:
      case 0x3Au:
      case 0x41u:
      case 0x42u:
      case 0x43u:
      case 0x44u:
      case 0x45u:
      case 0x46u:
      case 0x47u:
      case 0x48u:
      case 0x49u:
      case 0x4Au:
      case 0x4Bu:
      case 0x4Cu:
      case 0x4Du:
      case 0x4Eu:
      case 0x4Fu:
      case 0x50u:
      case 0x51u:
      case 0x52u:
      case 0x53u:
      case 0x54u:
      case 0x55u:
      case 0x56u:
      case 0x57u:
      case 0x58u:
      case 0x59u:
      case 0x5Au:
      case 0x5Du:
      case 0x5Fu:
      case 0x61u:
      case 0x62u:
      case 0x63u:
      case 0x64u:
      case 0x65u:
      case 0x66u:
      case 0x67u:
      case 0x68u:
      case 0x69u:
      case 0x6Au:
      case 0x6Bu:
      case 0x6Cu:
      case 0x6Du:
      case 0x6Eu:
      case 0x6Fu:
      case 0x70u:
      case 0x71u:
      case 0x72u:
      case 0x73u:
      case 0x74u:
      case 0x75u:
      case 0x76u:
      case 0x77u:
      case 0x78u:
      case 0x79u:
      case 0x7Au:
        v114 = 1;
        goto LABEL_175;
      case 0x27u:
        v108 = 1;
        v114 = 1;
        if ( a6 != 2 )
          goto LABEL_175;
        if ( v106 )
          goto LABEL_2;
        if ( a3 )
        {
          v75 = &loc_806483C;
          if ( v136 )
            v75 = &loc_8064849;
          dword_806E1B0 = (int)v75;
          sub_8068088(v11);
          v136 = a3;
          a3 = 0;
        }
        if ( v118 < a3 )
        {
          v10 = (int)a2;
          a2[v118] = 39;
        }
        v125 = v118 + 1;
        if ( v125 < a3 )
        {
          v10 = (int)a2;
          a2[v125] = 92;
        }
        v126 = v125 + 1;
        if ( v126 < a3 )
        {
          v10 = (int)a2;
          a2[v126] = 39;
        }
        v118 = v126 + 1;
        v107 = 0;
        goto LABEL_175;
      case 0x3Fu:
LABEL_70:
        if ( a6 == 2 )
        {
          v35 = &loc_80644CA;
          if ( !v106 )
            v35 = &loc_80644CF;
          dword_806E220 = (int)v35;
          sub_8067D8E(v11);
LABEL_2:
          if ( a6 == 2 )
          {
            if ( v105 )
              a6 = 4;
          }
          return sub_8063FFD(a1, a2, a3, a4, a5, a6, a7 & 0xFFFFFFFD, 0, v104, v103);
        }
        if ( a6 == 5 )
        {
          if ( a7 & 4 )
          {
            if ( (unsigned int)(v117 + 2) < a5 )
            {
              v10 = (int)(v117 + 1);
              if ( v117[a4 + 1] == 63 )
              {
                v10 = (int)(v117 + 2);
                switch ( v117[a4 + 2] )
                {
                  case 33:
                  case 39:
                  case 40:
                  case 41:
                  case 45:
                  case 47:
                  case 60:
                  case 61:
                  case 62:
                    if ( v106 )
                      goto LABEL_2;
                    v36 = v117 + 2;
                    v37 = v117[a4 + 2];
                    v117 += 2;
                    if ( v118 < a3 )
                    {
                      v36 = a2;
                      a2[v118] = 63;
                    }
                    v122 = v118 + 1;
                    if ( v122 < a3 )
                    {
                      v36 = a2;
                      a2[v122] = 34;
                    }
                    v123 = v122 + 1;
                    if ( v123 < a3 )
                    {
                      v36 = a2;
                      a2[v123] = 34;
                    }
                    v124 = v123 + 1;
                    if ( v124 < a3 )
                    {
                      v36 = a2;
                      a2[v124] = 63;
                    }
                    v118 = v124 + 1;
                    dword_806E1F8 = (int)&loc_80645E0;
                    v38 = _InterlockedExchange(&dword_806E1FC, a1);
                    v39 = _InterlockedExchange(&dword_806E1FC, v11);
                    sub_8067E97(_InterlockedExchange(&dword_806E1FC, v38), v36);
                    v40 = _InterlockedExchange(&dword_806E1FC, v39);
                    v43 = _InterlockedExchange(&dword_806E1FC, v41);
                    v42 = v40;
                    a1 = v43;
                    v10 = _InterlockedExchange(&dword_806E1FC, v42);
                    break;
                  default:
                    break;
                }
              }
            }
          }
        }
        dword_806E248 = (int)&loc_8064C65;
        v44 = _InterlockedExchange(&dword_806E24C, a1);
        v46 = _InterlockedExchange(&dword_806E24C, v10);
        v45 = v44;
        a1 = v46;
        _InterlockedExchange(&dword_806E24C, v45);
        v48 = _InterlockedExchange(&dword_806E24C, sub_8067C8C(v11));
        _InterlockedExchange(&dword_806E24C, v47);
        v11 = _InterlockedExchange(&dword_806E24C, v48);
LABEL_91:
        v111 = 97;
LABEL_107:
        v64 = &loc_8064739;
        if ( !v105 )
          v64 = &loc_8064745;
        dword_806E1F8 = (int)v64;
        sub_8067E97(v11, v10);
        v110 = v111;
LABEL_184:
        if ( v106 )
          goto LABEL_2;
        v113 = 1;
        v90 = &loc_8064D3C;
        if ( a6 != 2 )
          v90 = &loc_8064DA9;
        dword_806E1E4 = (int)v90;
        sub_8067F20(v11, v10);
        v92 = &loc_8064D60;
        if ( v107 == 1 )
          v92 = &loc_8064DA9;
        dword_806E1C4 = (int)v92;
        sub_8068003(v91);
        if ( v118 < a3 )
          a2[v118] = 39;
        v132 = v118 + 1;
        if ( v132 < a3 )
          a2[v132] = 36;
        v133 = v132 + 1;
        if ( v133 < a3 )
          a2[v133] = 39;
        v134 = v133 + 1;
        v107 = 1;
        if ( v134 < a3 )
          a2[v134] = 92;
        v118 = v134 + 1;
LABEL_198:
        if ( v107 && v113 != 1 )
        {
          if ( v118 < a3 )
            a2[v118] = 39;
          v135 = v118 + 1;
          if ( v135 < a3 )
            a2[v135] = 39;
          v118 = v135 + 1;
          v107 = 0;
        }
        if ( v118 < a3 )
          a2[v118] = v110;
        ++v118;
        v93 = &loc_8064E41;
        if ( v114 == 1 )
          v93 = &loc_8064E45;
        dword_806E138 = (int)v93;
        sub_80683DD(v11);
        v109 = 0;
LABEL_210:
        ++v117;
        break;
      case 0x5Cu:
        v111 = v117[a4];
        if ( a6 == 2 )
        {
          v49 = &loc_8064685;
          if ( !v106 )
            v49 = &loc_80646BC;
          dword_806E1F8 = (int)v49;
          sub_8067E97(v11, a4);
          dword_806E19C = (int)&loc_8064094;
          v50 = _InterlockedExchange(&dword_806E1A0, a1);
          v52 = _InterlockedExchange(&dword_806E1A0, v51);
          sub_806811D(v53, _InterlockedExchange(&dword_806E1A0, v50));
          v54 = _InterlockedExchange(&dword_806E1A0, v52);
          v57 = _InterlockedExchange(&dword_806E1A0, v55);
          v56 = v54;
          dword_806E110 = (int)&loc_8064DC0;
          v58 = _InterlockedExchange(&dword_806E114, v57);
          v61 = _InterlockedExchange(&dword_806E114, v59);
          v60 = v58;
          a1 = v61;
          v63 = _InterlockedExchange(
                  &dword_806E114,
                  sub_80684E1(_InterlockedExchange(&dword_806E114, v60), _InterlockedExchange(&dword_806E1A0, v56)));
          _InterlockedExchange(&dword_806E114, v62);
          v10 = _InterlockedExchange(&dword_806E114, v63);
        }
        if ( v105 && v106 && n )
          goto LABEL_198;
LABEL_105:
        if ( a6 != 2 || !v106 )
          goto LABEL_107;
        goto LABEL_2;
      case 0x7Bu:
      case 0x7Du:
        if ( a5 == -1 )
        {
          v65 = *(_BYTE *)(a4 + 1);
          dword_806E138 = (int)&loc_806479C;
          v66 = _InterlockedExchange(&dword_806E13C, a1);
          v67 = _InterlockedExchange(&dword_806E13C, v11);
          v24 = sub_80683DD(_InterlockedExchange(&dword_806E13C, v66));
          v68 = _InterlockedExchange(&dword_806E13C, v67);
          v71 = _InterlockedExchange(&dword_806E13C, v69);
          v70 = v68;
          a1 = v71;
          v11 = _InterlockedExchange(&dword_806E13C, v70);
        }
        LOBYTE(v24) = a5 != 1;
        if ( a5 == 1 )
        {
LABEL_113:
          if ( !v117 )
          {
LABEL_114:
            v114 = 1;
LABEL_115:
            if ( a6 == 2 && v106 )
            {
              dword_806E20C = (int)&loc_8064094;
              v72 = _InterlockedExchange(&dword_806E210, v24);
              _InterlockedExchange(&dword_806E210, v10);
              v74 = _InterlockedExchange(&dword_806E210, sub_8067E16(v11, _InterlockedExchange(&dword_806E210, v72)));
              _InterlockedExchange(&dword_806E210, v73);
              v11 = _InterlockedExchange(&dword_806E210, v74);
            }
          }
        }
        goto LABEL_175;
      default:
        v76 = &loc_80648C4;
        if ( !v116 )
          v76 = &loc_80648F2;
        dword_806E220 = (int)v76;
        sub_8067D8E(v11);
        v77 = __ctype_b_loc();
        v10 = 2 * v110;
        v115 = (*(const unsigned __int16 *)((char *)*v77 + v10) & 0x4000) != 0;
        v114 = (*(const unsigned __int16 *)((char *)*v77 + v10) & 0x4000) != 0;
        if ( !v105 )
        {
LABEL_175:
          if ( (v105 == 1 && a6 != 2 || v106 == 1) && a8 )
          {
            v81 = v110 & 0x1F;
            v82 = *(_DWORD *)(4 * (v110 >> 5) + a8) >> v81;
            v83 = &loc_8064CCC;
            if ( v82 & 1 )
              v83 = &loc_8064D0E;
            dword_806E110 = (int)v83;
            sub_80684E1(v81, v82);
          }
          if ( v112 != 1 )
          {
            dword_806E1F8 = (int)&loc_8064DC0;
            v84 = _InterlockedExchange(&dword_806E1FC, a1);
            v85 = _InterlockedExchange(&dword_806E1FC, v10);
            sub_8067E97(v11, _InterlockedExchange(&dword_806E1FC, v84));
            v86 = _InterlockedExchange(&dword_806E1FC, v85);
            v89 = _InterlockedExchange(&dword_806E1FC, v87);
            v88 = v86;
            a1 = v89;
            v10 = _InterlockedExchange(&dword_806E1FC, v88);
          }
          goto LABEL_184;
        }
        v78 = &loc_8064AB1;
        if ( v115 == 1 )
          v78 = &loc_8064C65;
        dword_806E160 = (int)v78;
        sub_80682DA();
        v79 = v117;
        v140 = (unsigned int)(v117 + 1);
        while ( 1 )
        {
          if ( v105 && v115 != 1 )
          {
            if ( v106 )
              goto LABEL_2;
            v113 = 1;
            if ( a6 == 2 && v107 != 1 )
            {
              if ( v118 < a3 )
              {
                v79 = a2;
                a2[v118] = 39;
              }
              v127 = v118 + 1;
              if ( v127 < a3 )
              {
                v79 = a2;
                a2[v127] = 36;
              }
              v128 = v127 + 1;
              if ( v128 < a3 )
              {
                v79 = a2;
                a2[v128] = 39;
              }
              v118 = v128 + 1;
              v107 = 1;
            }
            if ( v118 < a3 )
            {
              v79 = a2;
              a2[v118] = 92;
            }
            v129 = v118 + 1;
            if ( v129 < a3 )
            {
              v79 = &a2[v129];
              a2[v129] = (v110 >> 6) + 48;
            }
            v130 = v129 + 1;
            if ( v130 < a3 )
            {
              v79 = &a2[v130];
              a2[v130] = ((v110 >> 3) & 7) + 48;
            }
            v118 = v130 + 1;
            v110 = (v110 & 7) + 48;
          }
          else if ( v112 )
          {
            if ( v118 < a3 )
            {
              v79 = a2;
              a2[v118] = 92;
            }
            ++v118;
            v112 = 0;
          }
          if ( (unsigned int)(v117 + 1) >= v140 )
            goto LABEL_198;
          if ( v107 )
          {
            v80 = &loc_8064C02;
            if ( v113 == 1 )
              v80 = &loc_8064C34;
            dword_806E1E4 = (int)v80;
            sub_8067F20(v11, v79);
            if ( v118 < a3 )
              a2[v118] = 39;
            v131 = v118 + 1;
            if ( v131 < a3 )
              a2[v131] = 39;
            v118 = v131 + 1;
            v107 = 0;
          }
          if ( v118 < a3 )
            a2[v118] = v110;
          ++v118;
          ++v117;
          v79 = (_BYTE *)a4;
          v110 = v117[a4];
        }
    }
  }
  if ( !v118 && a6 == 2 )
  {
    v96 = &loc_8064EB6;
    if ( !v106 )
      v96 = &loc_8064EBB;
    dword_806E1F8 = (int)v96;
    sub_8067E97(v95, a4);
    goto LABEL_2;
  }
  v97 = &loc_8064EDA;
  if ( a6 != 2 )
    v97 = &loc_8064FAB;
  dword_806E138 = (int)v97;
  sub_80683DD(v95);
  if ( v106 != 1 && v108 )
  {
    v100 = &loc_8064F12;
    if ( !v109 )
      v100 = &loc_8064F5B;
    dword_806E248 = (int)v100;
    sub_8067C8C(v99);
    result = sub_8063FFD(a1, a2, v136, a4, a5, 5, a7, a8, v104, v103);
  }
  else
  {
    if ( s && v106 != 1 )
    {
      v102 = &loc_8065001;
      if ( *s )
        v102 = &loc_8064FBE;
      dword_806E1F8 = (int)v102;
      sub_8067E97(v99, v98);
    }
    if ( v118 < a3 )
      a2[v118] = 0;
    result = v118;
  }
  return result;
}
// 8067C8C: using guessed type int __fastcall sub_8067C8C(_DWORD);
// 8067D8E: using guessed type int __fastcall sub_8067D8E(_DWORD);
// 8067E16: using guessed type int __fastcall sub_8067E16(_DWORD, _DWORD);
// 8067E97: using guessed type int __fastcall sub_8067E97(_DWORD, _DWORD);
// 8067F20: using guessed type int __fastcall sub_8067F20(_DWORD, _DWORD);
// 8068003: using guessed type int __fastcall sub_8068003(_DWORD);
// 8068088: using guessed type int __fastcall sub_8068088(_DWORD);
// 806811D: using guessed type int __fastcall sub_806811D(_DWORD, _DWORD);
// 80681B5: using guessed type int __fastcall sub_80681B5(_DWORD, _DWORD);
// 806823B: using guessed type int __fastcall sub_806823B(_DWORD);
// 80682DA: using guessed type int sub_80682DA(void);
// 80683DD: using guessed type int __fastcall sub_80683DD(_DWORD);
// 80684E1: using guessed type int __fastcall sub_80684E1(_DWORD, _DWORD);
// 806E110: using guessed type int dword_806E110;
// 806E114: using guessed type int dword_806E114;
// 806E138: using guessed type int dword_806E138;
// 806E13C: using guessed type int dword_806E13C;
// 806E160: using guessed type int dword_806E160;
// 806E174: using guessed type int dword_806E174;
// 806E178: using guessed type int dword_806E178;
// 806E188: using guessed type int dword_806E188;
// 806E19C: using guessed type int dword_806E19C;
// 806E1A0: using guessed type int dword_806E1A0;
// 806E1B0: using guessed type int dword_806E1B0;
// 806E1B4: using guessed type int dword_806E1B4;
// 806E1C4: using guessed type int dword_806E1C4;
// 806E1C8: using guessed type int dword_806E1C8;
// 806E1E4: using guessed type int dword_806E1E4;
// 806E1F8: using guessed type int dword_806E1F8;
// 806E1FC: using guessed type int dword_806E1FC;
// 806E20C: using guessed type int dword_806E20C;
// 806E210: using guessed type int dword_806E210;
// 806E220: using guessed type int dword_806E220;
// 806E248: using guessed type int dword_806E248;
// 806E24C: using guessed type int dword_806E24C;

//----- (0806516B) --------------------------------------------------------
_BYTE *__cdecl sub_806516B(signed __int32 a1, unsigned int a2, _DWORD *a3, int *a4)
{
  int *v4; // eax
  int *v5; // ST3C_4
  int v6; // ST40_4
  int v7; // ST44_4
  unsigned int size; // [esp+48h] [ebp-10h]
  _BYTE *v10; // [esp+4Ch] [ebp-Ch]

  if ( a4 )
    v4 = a4;
  else
    v4 = &dword_806E8CB;
  v5 = v4;
  v6 = *__errno_location();
  v7 = v5[1] | (a3 == 0);
  size = sub_8063FFD(
           (unsigned __int32)(v5 + 2),
           0,
           0,
           a1,
           a2,
           *v5,
           v7,
           (int)(v5 + 2),
           (char *)v5[10],
           (const char *)v5[11])
       + 1;
  v10 = sub_80664BE((signed __int32)(v5 + 2), size);
  sub_8063FFD(
    (unsigned __int32)(v5 + 2),
    v10,
    size,
    a1,
    a2,
    *v5,
    v7,
    (int)(v5 + 2),
    (char *)v5[10],
    (const char *)v5[11]);
  *__errno_location() = v6;
  if ( a3 )
    *a3 = size - 1;
  return v10;
}
// 806E8CB: using guessed type int dword_806E8CB;

//----- (08065312) --------------------------------------------------------
_BYTE *__usercall sub_8065312@<eax>(signed __int32 a1@<ebx>, signed int a2, signed __int32 a3, unsigned int a4, int a5)
{
  signed __int32 v5; // ecx
  size_t v6; // edx
  signed __int32 v7; // ebx
  signed __int32 v8; // edx
  signed __int32 v9; // et1
  void *v10; // edx
  size_t v11; // ST44_4
  signed __int32 v12; // ebx
  bool v14; // [esp+37h] [ebp-21h]
  int *v15; // [esp+38h] [ebp-20h]
  _BYTE *ptr; // [esp+3Ch] [ebp-1Ch]
  int v17; // [esp+40h] [ebp-18h]
  int size; // [esp+44h] [ebp-14h]
  int v19; // [esp+48h] [ebp-10h]
  unsigned int v20; // [esp+4Ch] [ebp-Ch]

  v17 = *__errno_location();
  v15 = off_806E294;
  if ( a2 < 0 )
    abort();
  if ( dword_806E288 <= a2 )
  {
    v14 = off_806E294 == &dword_806E28C;
    if ( (unsigned int)a2 > 0xFFFFFFE )
      sub_8066689();
    v6 = 8 * (a2 + 1);
    if ( v14 )
    {
      dword_806E138 = (int)&loc_80653B1;
      v7 = _InterlockedExchange(&dword_806E13C, a1);
      _InterlockedExchange(&dword_806E13C, v5);
      v9 = _InterlockedExchange(&dword_806E13C, sub_80683DD(_InterlockedExchange(&dword_806E13C, v7)));
      _InterlockedExchange(&dword_806E13C, v8);
      v6 = _InterlockedExchange(&dword_806E13C, v9);
    }
    v15 = (int *)sub_806654A(v15, v6);
    off_806E294 = v15;
    if ( v14 )
    {
      v10 = off_806E290;
      *v15 = dword_806E28C;
      v15[1] = (int)v10;
    }
    memset(&v15[2 * dword_806E288], 0, 8 * (a2 + 1 - dword_806E288));
    dword_806E288 = a2 + 1;
  }
  v11 = v15[2 * a2];
  ptr = (_BYTE *)v15[2 * a2 + 1];
  v19 = *(_DWORD *)(a5 + 4) | 1;
  v20 = sub_8063FFD(
          a5 + 8,
          (_BYTE *)v15[2 * a2 + 1],
          v15[2 * a2],
          a3,
          a4,
          *(_DWORD *)a5,
          v19,
          a5 + 8,
          *(char **)(a5 + 40),
          *(const char **)(a5 + 44));
  if ( v11 <= v20 )
  {
    size = v20 + 1;
    v15[2 * a2] = v20 + 1;
    if ( ptr != (_BYTE *)&unk_806E90B )
      free(ptr);
    v12 = (signed __int32)&v15[2 * a2];
    ptr = sub_80664BE(v12, size);
    *(_DWORD *)(v12 + 4) = ptr;
    sub_8063FFD(a5 + 8, ptr, size, a3, a4, *(_DWORD *)a5, v19, a5 + 8, *(char **)(a5 + 40), *(const char **)(a5 + 44));
  }
  *__errno_location() = v17;
  return ptr;
}
// 80683DD: using guessed type int __fastcall sub_80683DD(_DWORD);
// 806E138: using guessed type int dword_806E138;
// 806E13C: using guessed type int dword_806E13C;
// 806E288: using guessed type int dword_806E288;
// 806E28C: using guessed type int dword_806E28C;
// 806E290: using guessed type void *off_806E290;
// 806E294: using guessed type int *off_806E294;

//----- (0806556F) --------------------------------------------------------
_BYTE *__usercall sub_806556F@<eax>(signed __int32 a1@<ebx>, signed int a2, signed __int32 a3)
{
  return sub_8065312(a1, a2, a3, 0xFFFFFFFF, (int)&dword_806E8CB);
}
// 806E8CB: using guessed type int dword_806E8CB;

//----- (08065599) --------------------------------------------------------
_BYTE *__usercall sub_8065599@<eax>(signed __int32 a1@<ebx>, signed int a2, signed __int32 a3, unsigned int a4)
{
  return sub_8065312(a1, a2, a3, a4, (int)&dword_806E8CB);
}
// 806E8CB: using guessed type int dword_806E8CB;

//----- (080655FF) --------------------------------------------------------
void __cdecl __noreturn sub_80655FF(int a1, int a2)
{
  char v2; // [esp+10h] [ebp-38h]

  sub_8063DBC((int)&v2, a2);
}

//----- (0806563D) --------------------------------------------------------
void __cdecl __noreturn sub_806563D(int a1, int a2)
{
  char v2; // [esp+10h] [ebp-38h]

  sub_8063DBC((int)&v2, a2);
}

//----- (080656C5) --------------------------------------------------------
_BYTE *__usercall sub_80656C5@<eax>(signed __int32 a1@<ebx>, signed __int32 a2, unsigned int a3, unsigned __int8 a4)
{
  int v5; // [esp+20h] [ebp-38h]
  int v6; // [esp+24h] [ebp-34h]
  int v7; // [esp+28h] [ebp-30h]
  int v8; // [esp+2Ch] [ebp-2Ch]
  int v9; // [esp+30h] [ebp-28h]
  int v10; // [esp+34h] [ebp-24h]
  int v11; // [esp+38h] [ebp-20h]
  int v12; // [esp+3Ch] [ebp-1Ch]
  int v13; // [esp+40h] [ebp-18h]
  int v14; // [esp+44h] [ebp-14h]
  int v15; // [esp+48h] [ebp-10h]
  int v16; // [esp+4Ch] [ebp-Ch]

  v5 = dword_806E8CB;
  v6 = dword_806E8CF;
  v7 = dword_806E8D3;
  v8 = dword_806E8D7;
  v9 = dword_806E8DB;
  v10 = dword_806E8DF;
  v11 = dword_806E8E3;
  v12 = dword_806E8E7;
  v13 = dword_806E8EB;
  v14 = dword_806E8EF;
  v15 = dword_806E8F3;
  v16 = dword_806E8F7;
  sub_8063C3C(&v5, a4, 1);
  return sub_8065312(a1, 0, a2, a3, (int)&v5);
}
// 806E8CB: using guessed type int dword_806E8CB;
// 806E8CF: using guessed type int dword_806E8CF;
// 806E8D3: using guessed type int dword_806E8D3;
// 806E8D7: using guessed type int dword_806E8D7;
// 806E8DB: using guessed type int dword_806E8DB;
// 806E8DF: using guessed type int dword_806E8DF;
// 806E8E3: using guessed type int dword_806E8E3;
// 806E8E7: using guessed type int dword_806E8E7;
// 806E8EB: using guessed type int dword_806E8EB;
// 806E8EF: using guessed type int dword_806E8EF;
// 806E8F3: using guessed type int dword_806E8F3;
// 806E8F7: using guessed type int dword_806E8F7;

//----- (0806576F) --------------------------------------------------------
_BYTE *__usercall sub_806576F@<eax>(signed __int32 a1@<ebx>, signed __int32 a2, unsigned __int8 a3)
{
  return sub_80656C5(a1, a2, 0xFFFFFFFF, a3);
}

//----- (08065798) --------------------------------------------------------
_BYTE *__usercall sub_8065798@<eax>(signed __int32 a1@<ebx>, signed __int32 a2)
{
  return sub_806576F(a1, a2, 0x3Au);
}

//----- (080657D5) --------------------------------------------------------
void __cdecl __noreturn sub_80657D5(int a1, int a2)
{
  char v2; // [esp+10h] [ebp-68h]

  sub_8063DBC((int)&v2, a2);
}

//----- (08065944) --------------------------------------------------------
_BYTE *__usercall sub_8065944@<eax>(int a1@<edx>, int a2@<ecx>, signed __int32 a3@<ebx>, signed int a4, int a5, int a6, signed __int32 a7)
{
  return sub_8065974(a1, a2, a3, a4, a5, a6, a7, 0xFFFFFFFF);
}

//----- (08065974) --------------------------------------------------------
_BYTE *__usercall sub_8065974@<eax>(int a1@<edx>, int a2@<ecx>, signed __int32 a3@<ebx>, signed int a4, int a5, int a6, signed __int32 a7, unsigned int a8)
{
  int v9; // [esp+10h] [ebp-38h]
  int v10; // [esp+14h] [ebp-34h]
  int v11; // [esp+18h] [ebp-30h]
  int v12; // [esp+1Ch] [ebp-2Ch]
  int v13; // [esp+20h] [ebp-28h]
  int v14; // [esp+24h] [ebp-24h]
  int v15; // [esp+28h] [ebp-20h]
  int v16; // [esp+2Ch] [ebp-1Ch]
  int v17; // [esp+30h] [ebp-18h]
  int v18; // [esp+34h] [ebp-14h]
  int v19; // [esp+38h] [ebp-10h]
  int v20; // [esp+3Ch] [ebp-Ch]

  v9 = dword_806E8CB;
  v10 = dword_806E8CF;
  v11 = dword_806E8D3;
  v12 = dword_806E8D7;
  v13 = dword_806E8DB;
  v14 = dword_806E8DF;
  v15 = dword_806E8E3;
  v16 = dword_806E8E7;
  v17 = dword_806E8EB;
  v18 = dword_806E8EF;
  v19 = dword_806E8F3;
  v20 = dword_806E8F7;
  sub_8063CFF(a1, a2, (int)&v9, a5, a6);
  return sub_8065312(a3, a4, a7, a8, (int)&v9);
}
// 806E8CB: using guessed type int dword_806E8CB;
// 806E8CF: using guessed type int dword_806E8CF;
// 806E8D3: using guessed type int dword_806E8D3;
// 806E8D7: using guessed type int dword_806E8D7;
// 806E8DB: using guessed type int dword_806E8DB;
// 806E8DF: using guessed type int dword_806E8DF;
// 806E8E3: using guessed type int dword_806E8E3;
// 806E8E7: using guessed type int dword_806E8E7;
// 806E8EB: using guessed type int dword_806E8EB;
// 806E8EF: using guessed type int dword_806E8EF;
// 806E8F3: using guessed type int dword_806E8F3;
// 806E8F7: using guessed type int dword_806E8F7;

//----- (08065A9D) --------------------------------------------------------
_BYTE *__usercall sub_8065A9D@<eax>(signed __int32 a1@<ebx>, signed int a2, signed __int32 a3, unsigned int a4)
{
  return sub_8065312(a1, a2, a3, a4, (int)&unk_806E2A8);
}

//----- (08065B96) --------------------------------------------------------
_BYTE *__usercall sub_8065B96@<eax>(signed __int32 a1@<ebx>, signed int a2, signed __int32 a3)
{
  return sub_8065A9D(a1, a2, a3, 0xFFFFFFFF);
}

//----- (08065BD3) --------------------------------------------------------
int __usercall sub_8065BD3@<eax>(signed __int32 a1@<ebx>, int a2@<edx>, int a3@<ecx>, int fd)
{
  int v5; // [esp+Ch] [ebp-Ch]

  return sub_8066758(a1, a2, a3, fd, 0, 3, v5);
}

//----- (08065BF6) --------------------------------------------------------
int __cdecl sub_8065BF6(FILE *stream, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // ecx
  void *v7; // eax
  char *v8; // eax
  char *v9; // eax
  signed __int32 v10; // ebx
  char *v11; // eax
  int result; // eax
  int v13; // esi
  signed __int32 v14; // ebx
  char *v15; // eax
  int v16; // eax
  signed __int32 v17; // eax
  signed __int32 v18; // edx
  int v19; // ecx
  signed __int32 v20; // ecx
  signed __int32 v21; // et1
  int v22; // edi
  int v23; // esi
  signed __int32 v24; // ebx
  char *v25; // eax
  int v26; // ST54_4
  int v27; // edi
  int v28; // esi
  signed __int32 v29; // ebx
  char *v30; // eax
  int v31; // ST54_4
  int v32; // ST50_4
  int v33; // edi
  int v34; // esi
  signed __int32 v35; // ebx
  char *v36; // eax
  int v37; // ST54_4
  int v38; // ST50_4
  int v39; // ST4C_4
  int v40; // edi
  int v41; // esi
  signed __int32 v42; // ebx
  char *v43; // eax
  int v44; // esi
  int v45; // ST54_4
  int v46; // ST50_4
  int v47; // ST4C_4
  int v48; // ST48_4
  int v49; // edi
  signed __int32 v50; // ebx
  char *v51; // eax
  int v52; // eax
  signed __int32 v53; // eax
  signed __int32 v54; // edx
  int v55; // ecx
  signed __int32 v56; // ecx
  signed __int32 v57; // ett
  int v58; // edi
  int v59; // ST54_4
  int v60; // ST50_4
  int v61; // ST4C_4
  int v62; // ST48_4
  int v63; // ST44_4
  int v64; // esi
  signed __int32 v65; // ebx
  char *v66; // eax
  int v67; // edi
  int v68; // ST54_4
  int v69; // ST50_4
  int v70; // ST4C_4
  int v71; // ST48_4
  int v72; // ST44_4
  int v73; // ST40_4
  int v74; // esi
  signed __int32 v75; // ebx
  char *v76; // eax
  signed __int32 v77; // ebx
  signed __int32 v78; // ecx
  signed __int32 v79; // et0
  int v80; // edx
  signed __int32 v81; // ebx
  signed __int32 v82; // edx
  int v83; // edi
  int v84; // ST54_4
  int v85; // ST50_4
  int v86; // ST4C_4
  int v87; // ST48_4
  int v88; // ST44_4
  int v89; // ST40_4
  int v90; // esi
  signed __int32 v91; // ebx
  char *v92; // eax

  v7 = &loc_8065C1E;
  if ( !a2 )
    v7 = &loc_8065C48;
  dword_806E124 = (int)v7;
  sub_8068460(v6);
  fprintf(stream, "%s (%s) %s\n", a2, a3, a4);
  v8 = gettext("(C)");
  fprintf(stream, "Copyright %s %d Free Software Foundation, Inc.", v8, 2017);
  v9 = gettext(
         "\n"
         "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\n"
         "This is free software: you are free to change and redistribute it.\n"
         "There is NO WARRANTY, to the extent permitted by law.\n"
         "\n");
  fputs_unlocked(v9, stream);
  switch ( a6 )
  {
    case 0:
      abort();
      return result;
    case 1:
      v10 = *(_DWORD *)a5;
      v11 = gettext("Written by %s.\n");
      return fprintf(stream, v11, v10);
    case 2:
      v13 = *(_DWORD *)(a5 + 4);
      v14 = *(_DWORD *)a5;
      v15 = gettext("Written by %s and %s.\n");
      v16 = fprintf(stream, v15, v14, v13);
      dword_806E19C = (int)&loc_80661A6;
      v17 = _InterlockedExchange(&dword_806E1A0, v16);
      _InterlockedExchange(&dword_806E1A0, v18);
      v21 = _InterlockedExchange(&dword_806E1A0, sub_806811D(v19, _InterlockedExchange(&dword_806E1A0, v17)));
      _InterlockedExchange(&dword_806E1A0, v20);
      _InterlockedExchange(&dword_806E1A0, v21);
      goto LABEL_7;
    case 3:
LABEL_7:
      v22 = *(_DWORD *)(a5 + 8);
      v23 = *(_DWORD *)(a5 + 4);
      v24 = *(_DWORD *)a5;
      v25 = gettext("Written by %s, %s, and %s.\n");
      return fprintf(stream, v25, v24, v23, v22);
    case 4:
      v26 = *(_DWORD *)(a5 + 12);
      v27 = *(_DWORD *)(a5 + 8);
      v28 = *(_DWORD *)(a5 + 4);
      v29 = *(_DWORD *)a5;
      v30 = gettext("Written by %s, %s, %s,\nand %s.\n");
      return fprintf(stream, v30, v29, v28, v27, v26);
    case 5:
      v31 = *(_DWORD *)(a5 + 16);
      v32 = *(_DWORD *)(a5 + 12);
      v33 = *(_DWORD *)(a5 + 8);
      v34 = *(_DWORD *)(a5 + 4);
      v35 = *(_DWORD *)a5;
      v36 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
      return fprintf(stream, v36, v35, v34, v33, v32, v31);
    case 6:
      v37 = *(_DWORD *)(a5 + 20);
      v38 = *(_DWORD *)(a5 + 16);
      v39 = *(_DWORD *)(a5 + 12);
      v40 = *(_DWORD *)(a5 + 8);
      v41 = *(_DWORD *)(a5 + 4);
      v42 = *(_DWORD *)a5;
      v43 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
      return fprintf(stream, v43, v42, v41, v40, v39, v38, v37);
    case 7:
      v44 = *(_DWORD *)(a5 + 24);
      v45 = *(_DWORD *)(a5 + 20);
      v46 = *(_DWORD *)(a5 + 16);
      v47 = *(_DWORD *)(a5 + 12);
      v48 = *(_DWORD *)(a5 + 8);
      v49 = *(_DWORD *)(a5 + 4);
      v50 = *(_DWORD *)a5;
      v51 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
      v52 = fprintf(stream, v51, v50, v49, v48, v47, v46, v45, v44);
      dword_806E248 = (int)&loc_80661A6;
      v53 = _InterlockedExchange(&dword_806E24C, v52);
      _InterlockedExchange(&dword_806E24C, v54);
      _InterlockedExchange(&dword_806E24C, v53);
      v57 = _InterlockedExchange(&dword_806E24C, sub_8067C8C(v55));
      _InterlockedExchange(&dword_806E24C, v56);
      _InterlockedExchange(&dword_806E24C, v57);
      goto LABEL_12;
    case 8:
LABEL_12:
      v58 = *(_DWORD *)(a5 + 28);
      v59 = *(_DWORD *)(a5 + 24);
      v60 = *(_DWORD *)(a5 + 20);
      v61 = *(_DWORD *)(a5 + 16);
      v62 = *(_DWORD *)(a5 + 12);
      v63 = *(_DWORD *)(a5 + 8);
      v64 = *(_DWORD *)(a5 + 4);
      v65 = *(_DWORD *)a5;
      v66 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
      return fprintf(stream, v66, v65, v64, v63, v62, v61, v60, v59, v58);
    case 9:
      v67 = *(_DWORD *)(a5 + 32);
      v68 = *(_DWORD *)(a5 + 28);
      v69 = *(_DWORD *)(a5 + 24);
      v70 = *(_DWORD *)(a5 + 20);
      v71 = *(_DWORD *)(a5 + 16);
      v72 = *(_DWORD *)(a5 + 12);
      v73 = *(_DWORD *)(a5 + 8);
      v74 = *(_DWORD *)(a5 + 4);
      v75 = *(_DWORD *)a5;
      v76 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
      fprintf(stream, v76, v75, v74, v73, v72, v71, v70, v69, v68, v67);
      dword_806E234 = (int)&loc_80661A6;
      v77 = _InterlockedExchange(&dword_806E238, v75);
      v79 = _InterlockedExchange(&dword_806E238, v78);
      sub_8067D07(_InterlockedExchange(&dword_806E238, v77), v80);
      v81 = _InterlockedExchange(&dword_806E238, v79);
      _InterlockedExchange(&dword_806E238, v82);
      _InterlockedExchange(&dword_806E238, v81);
      break;
    default:
      break;
  }
  v83 = *(_DWORD *)(a5 + 32);
  v84 = *(_DWORD *)(a5 + 28);
  v85 = *(_DWORD *)(a5 + 24);
  v86 = *(_DWORD *)(a5 + 20);
  v87 = *(_DWORD *)(a5 + 16);
  v88 = *(_DWORD *)(a5 + 12);
  v89 = *(_DWORD *)(a5 + 8);
  v90 = *(_DWORD *)(a5 + 4);
  v91 = *(_DWORD *)a5;
  v92 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
  return fprintf(stream, v92, v91, v90, v89, v88, v87, v86, v85, v84, v83);
}
// 8048F20: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8067C8C: using guessed type int __fastcall sub_8067C8C(_DWORD);
// 8067D07: using guessed type int __fastcall sub_8067D07(_DWORD, _DWORD);
// 806811D: using guessed type int __fastcall sub_806811D(_DWORD, _DWORD);
// 8068460: using guessed type int __fastcall sub_8068460(_DWORD);
// 806E124: using guessed type int dword_806E124;
// 806E19C: using guessed type int dword_806E19C;
// 806E1A0: using guessed type int dword_806E1A0;
// 806E234: using guessed type int dword_806E234;
// 806E238: using guessed type int dword_806E238;
// 806E248: using guessed type int dword_806E248;
// 806E24C: using guessed type int dword_806E24C;

//----- (0806623B) --------------------------------------------------------
int __usercall sub_806623B@<eax>(signed __int32 a1@<eax>, signed __int32 a2@<ecx>, FILE *stream, int a4, int a5, int a6, int a7)
{
  signed __int32 v7; // eax
  signed __int32 v8; // edx
  signed __int32 v9; // et1
  int *v10; // eax
  int v12; // [esp+24h] [ebp-34h]
  int v13[12]; // [esp+28h] [ebp-30h]

  v12 = 0;
  dword_806E1C4 = (int)&loc_8066281;
  v7 = _InterlockedExchange(&dword_806E1C8, a1);
  _InterlockedExchange(&dword_806E1C8, a2);
  v9 = _InterlockedExchange(&dword_806E1C8, sub_8068003(_InterlockedExchange(&dword_806E1C8, v7)));
  _InterlockedExchange(&dword_806E1C8, v8);
  _InterlockedExchange(&dword_806E1C8, v9);
  do
  {
    if ( (unsigned int)++v12 > 9 )
      break;
    v10 = (int *)a7;
    a7 += 4;
    v13[v12] = *v10;
  }
  while ( v13[v12] );
  return sub_8065BF6(stream, a4, a5, a6, (int)v13, v12);
}
// 8068003: using guessed type int __fastcall sub_8068003(_DWORD);
// 806E1C4: using guessed type int dword_806E1C4;
// 806E1C8: using guessed type int dword_806E1C8;
// 806623B: using guessed type int var_30[12];

//----- (080662D4) --------------------------------------------------------
int __usercall sub_80662D4@<eax>(signed __int32 a1@<ecx>, FILE *stream, int a3, int a4, int a5, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a5);
  return sub_806623B((signed __int32)stream, a1, stream, a3, a4, a5, (int)va);
}

//----- (080663D7) --------------------------------------------------------
void *__cdecl sub_80663D7(void *ptr, int a2, int a3)
{
  unsigned int v4; // [esp+1Ch] [ebp-Ch]

  v4 = *(_DWORD *)a2;
  if ( ptr )
  {
    if ( 0x55555554u / a3 <= v4 )
      sub_8066689();
    v4 += (v4 >> 1) + 1;
  }
  else
  {
    if ( !v4 )
      v4 = (0x40u / a3 == 0) + 0x40u / a3;
    if ( 0x7FFFFFFFu / a3 < v4 )
      sub_8066689();
  }
  *(_DWORD *)a2 = v4;
  return sub_806654A(ptr, a3 * v4);
}

//----- (080664BE) --------------------------------------------------------
void *__usercall sub_80664BE@<eax>(signed __int32 a1@<ebx>, size_t size)
{
  return sub_80664D1(a1, size);
}

//----- (080664D1) --------------------------------------------------------
void *__usercall sub_80664D1@<eax>(signed __int32 a1@<ebx>, size_t size)
{
  signed __int32 v2; // ecx
  signed __int32 v3; // ebx
  signed __int32 v4; // ecx
  signed __int32 v5; // et1
  void *v7; // [esp+1Ch] [ebp-Ch]

  v7 = malloc(size);
  if ( !v7 && size )
  {
    dword_806E14C = (int)sub_806652E;
    v3 = _InterlockedExchange(&dword_806E150, a1);
    _InterlockedExchange(&dword_806E150, v2);
    v5 = _InterlockedExchange(&dword_806E150, sub_8068355(_InterlockedExchange(&dword_806E150, v3)));
    _InterlockedExchange(&dword_806E150, v4);
    _InterlockedExchange(&dword_806E150, v5);
  }
  return v7;
}
// 806652E: using guessed type void __noreturn sub_806652E();
// 8068355: using guessed type int __fastcall sub_8068355(_DWORD);
// 806E14C: using guessed type int dword_806E14C;
// 806E150: using guessed type int dword_806E150;

//----- (0806654A) --------------------------------------------------------
void *__cdecl sub_806654A(void *ptr, size_t size)
{
  void *result; // eax
  void *ptra; // [esp+20h] [ebp+8h]

  if ( size || !ptr )
  {
    ptra = realloc(ptr, size);
    if ( !ptra )
    {
      if ( size )
        sub_8066689();
    }
    result = ptra;
  }
  else
  {
    free(ptr);
    result = 0;
  }
  return result;
}

//----- (0806663B) --------------------------------------------------------
void *__usercall sub_806663B@<eax>(signed __int32 a1@<ebx>, void *src, size_t n)
{
  void *v3; // eax

  v3 = sub_80664D1(a1, n);
  return memcpy(v3, src, n);
}

//----- (08066689) --------------------------------------------------------
void __noreturn sub_8066689()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (080666C7) --------------------------------------------------------
int __usercall sub_80666C7@<eax>(signed __int32 a1@<ebx>, int a2@<ecx>, FILE *fp)
{
  void *v3; // eax
  int v4; // eax
  signed __int32 v5; // eax
  signed __int32 v6; // edx
  int v7; // ecx
  signed __int32 v8; // ecx
  signed __int32 v9; // et1

  v3 = &loc_80666EC;
  if ( !fp )
    v3 = &loc_80666FB;
  dword_806E220 = (int)v3;
  sub_8067D8E(a2);
  if ( !__freading(fp) )
  {
    v4 = fflush(fp);
    dword_806E20C = (int)&locret_8066751;
    v5 = _InterlockedExchange(&dword_806E210, v4);
    _InterlockedExchange(&dword_806E210, v6);
    v9 = _InterlockedExchange(&dword_806E210, sub_8067E16(v7, _InterlockedExchange(&dword_806E210, v5)));
    _InterlockedExchange(&dword_806E210, v8);
    _InterlockedExchange(&dword_806E210, v9);
  }
  sub_8066929(a1, fp);
  return fflush(fp);
}
// 8067D8E: using guessed type int __fastcall sub_8067D8E(_DWORD);
// 8067E16: using guessed type int __fastcall sub_8067E16(_DWORD, _DWORD);
// 806E20C: using guessed type int dword_806E20C;
// 806E210: using guessed type int dword_806E210;
// 806E220: using guessed type int dword_806E220;

//----- (08066758) --------------------------------------------------------
int __usercall sub_8066758@<eax>(signed __int32 a1@<ebx>, int a2@<edx>, int a3@<ecx>, int fd, int cmd, char a4, int a5)
{
  void *v7; // eax
  signed __int32 v8; // ecx
  bool v9; // zf
  int v10; // ecx
  void *v11; // eax
  int v12; // ST30_4
  signed __int32 v13; // ebx
  signed __int32 v14; // et0
  signed __int32 v15; // ebx
  signed __int32 v16; // ecx
  int v18; // [esp+Ch] [ebp-2Ch]
  signed int v19; // [esp+1Ch] [ebp-1Ch]
  char v20; // [esp+20h] [ebp-18h]
  int v21; // [esp+24h] [ebp-14h]

  v7 = &loc_806678E;
  if ( cmd != 1030 )
    v7 = &loc_80668FA;
  dword_806E110 = (int)v7;
  sub_80684E1(a3, a2);
  v20 = a4;
  if ( dword_806EA0B < 0 )
  {
    v19 = sub_8066758(a1, fd, 0, a4, v18);
  }
  else
  {
    v19 = fcntl(fd, cmd, a4);
    if ( v19 < 0 && *__errno_location() == 22 )
    {
      v19 = sub_8066758(a1, fd, 0, v20, v18);
      if ( v19 < 0 )
        return v19;
      dword_806EA0B = -1;
    }
    else
    {
      dword_806EA0B = 1;
    }
  }
  if ( v19 < 0 || dword_806EA0B != -1 )
  {
    dword_806E14C = (int)&loc_8066924;
    v13 = _InterlockedExchange(&dword_806E150, a1);
    v14 = _InterlockedExchange(&dword_806E150, v8);
    sub_8068355(_InterlockedExchange(&dword_806E150, v13));
    v15 = _InterlockedExchange(&dword_806E150, v14);
    _InterlockedExchange(&dword_806E150, v16);
    _InterlockedExchange(&dword_806E150, v15);
    v19 = fcntl(fd, cmd, a5);
  }
  else
  {
    v21 = fcntl(v19, 1);
    if ( v21 >= 0 )
    {
      v9 = fcntl(v19, 2, v21 | 1) == -1;
      v11 = &loc_806689B;
      if ( !v9 )
        v11 = &loc_80668C3;
      dword_806E174 = (int)v11;
      sub_806823B(v10);
    }
    v12 = *__errno_location();
    close(v19);
    *__errno_location() = v12;
    v19 = -1;
  }
  return v19;
}
// 806823B: using guessed type int __fastcall sub_806823B(_DWORD);
// 8068355: using guessed type int __fastcall sub_8068355(_DWORD);
// 80684E1: using guessed type int __fastcall sub_80684E1(_DWORD, _DWORD);
// 806E110: using guessed type int dword_806E110;
// 806E14C: using guessed type int dword_806E14C;
// 806E150: using guessed type int dword_806E150;
// 806E174: using guessed type int dword_806E174;
// 806EA0B: using guessed type int dword_806EA0B;

//----- (08066929) --------------------------------------------------------
int __usercall sub_8066929@<eax>(signed __int32 a1@<ebx>, FILE *stream)
{
  int result; // eax

  result = stream->_flags & 0x100;
  if ( result )
    result = sub_8066A2F(a1, stream, 0, 0, 1);
  return result;
}

//----- (08066967) --------------------------------------------------------
int __usercall sub_8066967@<eax>(signed __int32 a1@<ebx>, FILE *stream)
{
  int v3; // ecx
  int v4; // eax
  __int64 v5; // rax
  int v6; // [esp+14h] [ebp-14h]
  int v7; // [esp+18h] [ebp-10h]

  v6 = 0;
  if ( fileno(stream) < 0 )
    return fclose(stream);
  if ( !__freading(stream) || (v4 = fileno(stream), LODWORD(v5) = lseek64(v4, 0, 0, 1), v3 = ~HIDWORD(v5), v5 != -1) )
  {
    if ( sub_80666C7(a1, v3, stream) )
      v6 = *__errno_location();
  }
  v7 = fclose(stream);
  if ( v6 )
  {
    *__errno_location() = v6;
    v7 = -1;
  }
  return v7;
}
// 8049030: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08066A2F) --------------------------------------------------------
int __usercall sub_8066A2F@<eax>(signed __int32 a1@<ebx>, FILE *stream, int a3, int a4, int a5)
{
  int v5; // eax
  __off64_t v6; // rax
  signed __int32 v7; // ecx
  signed __int32 v8; // eax
  signed __int32 v9; // ebx
  signed __int32 v10; // ecx
  signed __int32 v12; // ebx
  signed __int32 v13; // ecx
  signed __int32 v14; // et2
  signed __int32 v15; // ebx
  signed __int32 v16; // edx
  signed __int32 v17; // edx
  signed __int32 v18; // ett
  __off64_t v19; // [esp+28h] [ebp-10h]

  if ( stream->_IO_read_end != stream->_IO_read_ptr || stream->_IO_write_ptr != stream->_IO_write_base )
    goto LABEL_7;
  while ( stream->_IO_save_base )
  {
LABEL_7:
    fseeko64(stream, a3, a4, a5);
    dword_806E248 = (int)&locret_8066A6E;
    v12 = _InterlockedExchange(&dword_806E24C, a1);
    v14 = _InterlockedExchange(&dword_806E24C, v13);
    sub_8067C8C(_InterlockedExchange(&dword_806E24C, v12));
    v15 = _InterlockedExchange(&dword_806E24C, v14);
    v18 = _InterlockedExchange(&dword_806E24C, v16);
    v17 = v15;
    a1 = v18;
    _InterlockedExchange(&dword_806E24C, v17);
  }
  v5 = fileno(stream);
  LODWORD(v6) = lseek64(v5, a3, a4, a5);
  v19 = v6;
  if ( v6 == -1 )
  {
    dword_806E124 = (int)&locret_8066A6E;
    v8 = _InterlockedExchange(&dword_806E128, -1);
    _InterlockedExchange(&dword_806E128, v7);
    sub_8068460(_InterlockedExchange(&dword_806E128, v8));
    v9 = _InterlockedExchange(&dword_806E128, a1);
    _InterlockedExchange(&dword_806E128, v10);
    _InterlockedExchange(&dword_806E128, v9);
  }
  stream->_flags &= 0xFFFFFFEF;
  stream->_offset = v19;
  return 0;
}
// 8048DC0: using guessed type int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8049030: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8067C8C: using guessed type int __fastcall sub_8067C8C(_DWORD);
// 8068460: using guessed type int __fastcall sub_8068460(_DWORD);
// 806E124: using guessed type int dword_806E124;
// 806E128: using guessed type int dword_806E128;
// 806E248: using guessed type int dword_806E248;
// 806E24C: using guessed type int dword_806E24C;

//----- (08066BA9) --------------------------------------------------------
size_t __usercall sub_8066BA9@<eax>(int a1@<ecx>, signed __int32 a2@<ebx>, wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  void *v6; // eax
  size_t v7; // eax
  signed __int32 v8; // ecx
  signed __int32 v9; // eax
  signed __int32 v10; // ebx
  signed __int32 v11; // ecx
  wchar_t v13; // [esp+18h] [ebp-10h]
  size_t v14; // [esp+1Ch] [ebp-Ch]

  v6 = &loc_8066BCE;
  if ( pwc )
    v6 = &loc_8066BD4;
  dword_806E14C = (int)v6;
  sub_8068355(a1);
  v7 = mbrtowc(&v13, s, n, p);
  v14 = v7;
  if ( v7 > 0xFFFFFFFD && n && (unsigned __int8)sub_8066DF5(0) ^ 1 )
  {
    v13 = (unsigned __int8)*s;
    dword_806E124 = (int)&locret_8066BF9;
    v9 = _InterlockedExchange(&dword_806E128, 1);
    _InterlockedExchange(&dword_806E128, v8);
    sub_8068460(_InterlockedExchange(&dword_806E128, v9));
    v10 = _InterlockedExchange(&dword_806E128, a2);
    _InterlockedExchange(&dword_806E128, v11);
    _InterlockedExchange(&dword_806E128, v10);
  }
  return v14;
}
// 8068355: using guessed type int __fastcall sub_8068355(_DWORD);
// 8068460: using guessed type int __fastcall sub_8068460(_DWORD);
// 806E124: using guessed type int dword_806E124;
// 806E128: using guessed type int dword_806E128;
// 806E14C: using guessed type int dword_806E14C;

//----- (08066C8D) --------------------------------------------------------
int __cdecl sub_8066C8D(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // esi
  unsigned __int8 *v3; // ebx
  signed __int32 v5; // edx
  int v6; // ecx
  signed __int32 v7; // ebx
  signed __int32 v8; // et0
  signed __int32 v9; // ebx
  signed __int32 v10; // ecx
  signed __int32 v11; // ecx
  signed __int32 v12; // et1
  unsigned __int8 v13; // [esp+1Eh] [ebp-Ah]
  unsigned __int8 v14; // [esp+1Fh] [ebp-9h]

  v2 = a1;
  v3 = a2;
  if ( a1 == a2 )
    return 0;
  do
  {
    v13 = sub_8067893(*v2);
    v14 = sub_8067893(*v3);
    if ( !v13 )
    {
      dword_806E1F8 = (int)&loc_8066D14;
      v7 = _InterlockedExchange(&dword_806E1FC, (signed __int32)v3);
      v8 = _InterlockedExchange(&dword_806E1FC, v5);
      sub_8067E97(v6, _InterlockedExchange(&dword_806E1FC, v7));
      v9 = _InterlockedExchange(&dword_806E1FC, v8);
      v12 = _InterlockedExchange(&dword_806E1FC, v10);
      v11 = v9;
      v3 = (unsigned __int8 *)v12;
      _InterlockedExchange(&dword_806E1FC, v11);
    }
    ++v2;
    ++v3;
  }
  while ( v13 == v14 );
  return v13 - v14;
}
// 8067E97: using guessed type int __fastcall sub_8067E97(_DWORD, _DWORD);
// 806E1F8: using guessed type int dword_806E1F8;
// 806E1FC: using guessed type int dword_806E1FC;

//----- (08066D27) --------------------------------------------------------
int __usercall sub_8066D27@<eax>(signed __int32 a1@<ebx>, FILE *fp)
{
  bool v2; // ST26_1
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  signed __int32 v6; // ecx
  signed __int32 v7; // ebx
  signed __int32 v8; // edx
  signed __int32 v9; // et1
  bool v11; // [esp+1Dh] [ebp-Bh]
  bool v12; // [esp+1Fh] [ebp-9h]

  v11 = __fpending(fp) != 0;
  v2 = ferror_unlocked(fp) != 0;
  v12 = sub_8066967(a1, fp) != 0;
  v5 = &loc_8066D85;
  if ( v2 )
    v5 = &loc_8066D9D;
  dword_806E19C = (int)v5;
  sub_806811D(v4, v3);
  if ( v12 && (v11 || *__errno_location() != 9) )
  {
    if ( v12 != 1 )
      *__errno_location() = 0;
    dword_806E220 = (int)&locret_8066DF3;
    v7 = _InterlockedExchange(&dword_806E224, a1);
    _InterlockedExchange(&dword_806E224, v6);
    v9 = _InterlockedExchange(&dword_806E224, sub_8067D8E(_InterlockedExchange(&dword_806E224, v7)));
    _InterlockedExchange(&dword_806E224, v8);
    _InterlockedExchange(&dword_806E224, v9);
  }
  return 0;
}
// 8067D8E: using guessed type int __fastcall sub_8067D8E(_DWORD);
// 806811D: using guessed type int __fastcall sub_806811D(_DWORD, _DWORD);
// 806E19C: using guessed type int dword_806E19C;
// 806E220: using guessed type int dword_806E220;
// 806E224: using guessed type int dword_806E224;

//----- (08066DF5) --------------------------------------------------------
int __cdecl sub_8066DF5(int category)
{
  unsigned __int8 v2; // [esp+1Bh] [ebp-Dh]
  const char *s1; // [esp+1Ch] [ebp-Ch]

  v2 = 1;
  s1 = setlocale(category, 0);
  if ( s1 && (!strcmp(s1, "C") || !strcmp(s1, "POSIX")) )
    v2 = 0;
  return v2;
}

//----- (08066E53) --------------------------------------------------------
void __fastcall __noreturn sub_8066E53(int a1, int a2)
{
  size_t i; // eax
  _BOOL4 v3; // eax
  bool v4; // zf
  int v5; // ecx
  void *v6; // eax
  void *v7; // eax
  const char *s; // [esp+1Ch] [ebp-ACh]
  char *v9; // [esp+28h] [ebp-A0h]
  size_t n; // [esp+2Ch] [ebp-9Ch]
  size_t v11; // [esp+30h] [ebp-98h]
  _BOOL4 v12; // [esp+34h] [ebp-94h]
  char *dest; // [esp+38h] [ebp-90h]
  int fd; // [esp+3Ch] [ebp-8Ch]
  unsigned int v15; // [esp+BCh] [ebp-Ch]

  v15 = __readgsdword(0x14u);
  if ( dword_806EA0F )
    goto LABEL_20;
  v9 = "charset.alias";
  s = getenv("CHARSETALIASDIR");
  if ( !s || !*s )
    goto LABEL_23;
  for ( i = strlen(s); ; i = strlen("/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib") )
  {
    n = i;
    v11 = strlen(v9);
    v3 = n && s[n - 1] != 47;
    v12 = v3;
    dest = (char *)malloc(n + v3 + v11 + 1);
    if ( dest )
    {
      memcpy(dest, s, n);
      if ( v12 )
        dest[n] = 47;
      memcpy(&dest[n + v12], v9, v11 + 1);
    }
    free(0);
    if ( dest )
    {
      fd = open64(dest, 0x20000);
      if ( fd >= 0 )
      {
        v4 = fdopen(fd, "r") == 0;
        v6 = &loc_8067067;
        if ( !v4 )
          v6 = &loc_8067084;
        dword_806E14C = (int)v6;
        sub_8068355(v5);
        close(fd);
      }
      free(dest);
    }
    dword_806EA0F = (int)&unk_8069D93;
LABEL_20:
    v7 = &loc_806738A;
    if ( __readgsdword(0x14u) == v15 )
      v7 = &loc_8066EC5;
    dword_806E1E4 = (int)v7;
    sub_8067F20(a1, a2);
LABEL_23:
    s = "/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib";
  }
}
// 8048D10: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 8067F20: using guessed type int __fastcall sub_8067F20(_DWORD, _DWORD);
// 8068355: using guessed type int __fastcall sub_8068355(_DWORD);
// 806E14C: using guessed type int dword_806E14C;
// 806E1E4: using guessed type int dword_806E1E4;
// 806EA0F: using guessed type int dword_806EA0F;

//----- (080673D4) --------------------------------------------------------
void __noreturn sub_80673D4()
{
  bool v0; // zf
  int v1; // ecx
  void *v2; // eax
  int v3; // edx
  int v4; // ecx

  v0 = nl_langinfo(14) == 0;
  v2 = &loc_8067408;
  if ( !v0 )
    v2 = &loc_806740F;
  dword_806E1B0 = (int)v2;
  sub_8068088(v1);
  sub_8066E53(v4, v3);
}
// 8068088: using guessed type int __fastcall sub_8068088(_DWORD);
// 806E1B0: using guessed type int dword_806E1B0;

//----- (08067893) --------------------------------------------------------
int __cdecl sub_8067893(int a1)
{
  signed __int32 v1; // ecx
  signed __int32 v2; // eax
  signed __int32 v3; // edx
  signed __int32 v4; // et1

  if ( (unsigned int)(a1 - 65) <= 0x19 )
  {
    dword_806E1C4 = (int)&loc_80678DF;
    v2 = _InterlockedExchange(&dword_806E1C8, a1 + 32);
    _InterlockedExchange(&dword_806E1C8, v1);
    v4 = _InterlockedExchange(&dword_806E1C8, sub_8068003(_InterlockedExchange(&dword_806E1C8, v2)));
    _InterlockedExchange(&dword_806E1C8, v3);
    _InterlockedExchange(&dword_806E1C8, v4);
  }
  return a1;
}
// 8068003: using guessed type int __fastcall sub_8068003(_DWORD);
// 806E1C4: using guessed type int dword_806E1C4;
// 806E1C8: using guessed type int dword_806E1C8;

//----- (080679A6) --------------------------------------------------------
int __cdecl sub_80679A6(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 97) <= 0x19 )
    result = a1 - 32;
  else
    result = a1;
  return result;
}

//----- (080679C5) --------------------------------------------------------
int __cdecl sub_80679C5(unsigned __int64 a1, __int64 a2)
{
  int v4; // ebp
  int v5; // ebp
  unsigned int v6; // ebp
  unsigned __int64 v7; // rtt
  unsigned __int64 v8; // rax
  unsigned int v9; // edi
  unsigned __int64 v10; // rax
  unsigned int v11; // ecx
  int v12; // [esp+0h] [ebp-20h]
  unsigned int v13; // [esp+4h] [ebp-1Ch]
  __int64 v14; // [esp+8h] [ebp-18h]
  unsigned int v15; // [esp+Ch] [ebp-14h]

  LODWORD(v14) = a1;
  if ( !HIDWORD(a2) )
  {
    if ( (unsigned int)a2 > HIDWORD(a1) )
      return a1 % (unsigned int)a2;
    v6 = a2;
    if ( !(_DWORD)a2 )
      v6 = 1 / 0u;
    LODWORD(v7) = a1;
    HIDWORD(v7) = HIDWORD(a1) % v6;
    return v7 % v6;
  }
  if ( HIDWORD(a2) > HIDWORD(a1) )
    return a1;
  _BitScanReverse((unsigned int *)&v4, HIDWORD(a2));
  v5 = v4 ^ 0x1F;
  if ( v5 )
  {
    v13 = (HIDWORD(a2) << v5) | ((unsigned int)a2 >> (32 - v5));
    HIDWORD(v8) = HIDWORD(a1) >> (32 - v5);
    LODWORD(v8) = (HIDWORD(a1) << v5) | ((unsigned int)a1 >> (32 - v5));
    v15 = (_DWORD)a1 << v5;
    v9 = v8 % v13;
    v10 = (unsigned int)((_DWORD)a2 << v5) * (unsigned __int64)(unsigned int)(v8 / v13);
    v12 = HIDWORD(v10);
    v11 = v10;
    if ( v9 >= HIDWORD(v10) )
    {
      if ( v15 >= (unsigned int)v10 )
        return ((__PAIR__(v9, v15) - __PAIR__(HIDWORD(v10), v11)) >> 32 << (32 - (unsigned __int8)v5)) | ((v15 - v11) >> v5);
      LODWORD(v10) = &loc_8067B16;
      if ( v9 != HIDWORD(v10) )
        LODWORD(v10) = &loc_8067AD8;
      dword_806E19C = v10;
      LODWORD(v10) = sub_806811D(v11, HIDWORD(v10));
    }
    HIDWORD(v10) = v12;
    HIDWORD(v10) = (v10 - __PAIR__(v13, (_DWORD)a2 << v5)) >> 32;
    v11 = v10 - ((_DWORD)a2 << v5);
    return ((__PAIR__(v9, v15) - __PAIR__(HIDWORD(v10), v11)) >> 32 << (32 - (unsigned __int8)v5)) | ((v15 - v11) >> v5);
  }
  if ( (unsigned int)a2 <= (unsigned int)a1 || HIDWORD(a2) < HIDWORD(a1) )
    LODWORD(v14) = a1 - a2;
  return v14;
}
// 806811D: using guessed type int __fastcall sub_806811D(_DWORD, _DWORD);
// 806E19C: using guessed type int dword_806E19C;

//----- (08067BA9) --------------------------------------------------------
int __cdecl sub_8067BA9(int a1)
{
  return __cxa_atexit(a1, 0, dword_806E26C);
}
// 8048E80: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 806E26C: using guessed type int dword_806E26C;

//----- (08067C8C) --------------------------------------------------------
#error "8067C92: positive sp value has been found (funcsize=0)"

//----- (08067D07) --------------------------------------------------------
#error "8067D0D: positive sp value has been found (funcsize=0)"

//----- (08067D8E) --------------------------------------------------------
#error "8067D94: positive sp value has been found (funcsize=0)"

//----- (08067E16) --------------------------------------------------------
#error "8067E1C: positive sp value has been found (funcsize=0)"

//----- (08067E97) --------------------------------------------------------
#error "8067E9D: positive sp value has been found (funcsize=0)"

//----- (08067F20) --------------------------------------------------------
#error "8067F26: positive sp value has been found (funcsize=0)"

//----- (08068003) --------------------------------------------------------
#error "8068009: positive sp value has been found (funcsize=0)"

//----- (08068088) --------------------------------------------------------
#error "806808E: positive sp value has been found (funcsize=0)"

//----- (0806811D) --------------------------------------------------------
#error "8068123: positive sp value has been found (funcsize=0)"

//----- (080681B5) --------------------------------------------------------
#error "80681BB: positive sp value has been found (funcsize=0)"

//----- (0806823B) --------------------------------------------------------
#error "8068241: positive sp value has been found (funcsize=0)"

//----- (080682DA) --------------------------------------------------------
#error "80682E0: positive sp value has been found (funcsize=0)"

//----- (08068355) --------------------------------------------------------
#error "806835B: positive sp value has been found (funcsize=0)"

//----- (080683DD) --------------------------------------------------------
#error "80683E3: positive sp value has been found (funcsize=0)"

//----- (08068460) --------------------------------------------------------
#error "8068466: positive sp value has been found (funcsize=0)"

//----- (080684E1) --------------------------------------------------------
#error "80684E7: positive sp value has been found (funcsize=0)"

//----- (08068500) --------------------------------------------------------
int (**sub_8068500())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_806DEBC;
  v1 = &off_806DEC0 - off_806DEBC;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_806DEBC[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 806DEBC: using guessed type int (*off_806DEBC[2])();
// 806DEC0: using guessed type int (*off_806DEC0)();

//----- (08068564) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 20 decompilation failure(s) on 168 function(s)"
