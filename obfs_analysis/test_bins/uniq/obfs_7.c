/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8048D50();
// int __cdecl freopen64(_DWORD, _DWORD, _DWORD); weak
// int dup2(int fd, int fd2);
// int strcmp(const char *s1, const char *s2);
// int __cdecl open64(_DWORD, _DWORD); weak
// int putc_unlocked(int c, FILE *stream);
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void _exit(int status);
// void free(void *ptr);
// void *memcpy(void *dest, const void *src, size_t n);
// int mbsinit(const mbstate_t *ps);
// int fclose(FILE *stream);
// int getc_unlocked(FILE *stream);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// char *textdomain(const char *domainname);
// int iswprint(wint_t wc);
// int ferror_unlocked(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// size_t __ctype_get_mb_cur_max(void);
// size_t __fpending(FILE *fp);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// void error(int status, int errnum, const char *format, ...);
// int strcoll(const char *s1, const char *s2);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// char *strchr(const char *s, int c);
// size_t strlen(const char *s);
// int fprintf(FILE *stream, const char *format, ...);
// void *memset(void *s, int c, size_t n);
// int *__errno_location(void);
// int fileno(FILE *stream);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// int toupper(int c);
// char *strrchr(const char *s, int c);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// char *bindtextdomain(const char *domainname, const char *dirname);
// int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// int feof_unlocked(FILE *stream);
// void abort(void);
// int strtol(const char *nptr, char **endptr, int base);
// int close(int fd);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// int putchar_unlocked(int c);
// int _gmon_start__(void); weak
void sub_8049193();
void sub_80491B0();
int sub_80491C0();
int sub_8049230();
int sub_8049250();
void sub_80492AF();
void sub_80492CA();
int sub_80492DA();
void sub_80493C2();
void sub_80493DD();
int sub_80493ED();
void sub_80494D5();
void sub_80494F0();
int sub_8049500();
void sub_80495E8();
void sub_8049603();
int sub_8049613();
void sub_80496FB();
void sub_8049716();
int sub_8049726();
// int __usercall sub_804978F@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
void sub_8049827();
void sub_8049842();
int sub_8049852();
void sub_804993A();
void sub_8049955();
int sub_8049965();
void sub_8049A4D();
void sub_8049A68();
int sub_8049A78();
void sub_8049B79();
void sub_8049B94();
int sub_8049BA4();
void sub_8049CA5();
void sub_8049CC0();
int sub_8049CD0();
void sub_8049DCA();
void sub_8049DE5();
int sub_8049DF5();
int sub_8049E81();
void sub_8049EF6();
void sub_8049F11();
int sub_8049F21();
void sub_804A022();
void sub_804A03D();
int sub_804A04D();
void sub_804A135();
void sub_804A150();
int sub_804A160();
void sub_804A24C();
void sub_804A26B();
int sub_804A27F();
void sub_804A377();
void sub_804A396();
signed int sub_804A3A6();
// int __usercall sub_804A413@<eax>(int a1@<eax>, int (__cdecl *a2)(signed int, int)@<edx>);
int __cdecl sub_804A485(unsigned __int8 a1);
int sub_804A4C9();
int __cdecl sub_804A4F8(char *s1); // idb
void __cdecl __noreturn sub_804A697(int status); // idb
int sub_804A873();
int __cdecl sub_804A8C5(char *nptr, char *msgid); // idb
int __cdecl sub_804A931(int a1);
int __cdecl sub_804AA20(void *s1, void *s2, size_t n, int); // idb
size_t __cdecl sub_804AB12(int a1, char a2, __int64 a3);
void __cdecl sub_804ABF4(char *s1, char *a2, int a3);
int __cdecl main(int argc, char **argv);
void __noreturn sub_804B9FA();
int __cdecl sub_804BA0E(char *s, int a2);
void __cdecl sub_804BB5D(int a1, int a2, int a3);
int __cdecl sub_804BC03(int, int, size_t n); // idb
int __cdecl sub_804BD1A(int, char *s, int, int, size_t n, int); // idb
int sub_804BE2D();
int __cdecl sub_804BF1F(int a1, int a2, int a3, int a4, int a5, int a6);
void __cdecl sub_804BF70(FILE *stream, int a2);
int __cdecl sub_804BFD6(int a1);
FILE *__cdecl sub_804C043(int a1, int a2, FILE *stream);
int __cdecl sub_804C219(int category); // idb
void *__cdecl sub_804C287(void *s);
int __cdecl sub_804C2D0(int, FILE *stream, int); // idb
int __cdecl sub_804C41B(int a1, int a2, unsigned int a3);
int sub_804C4A0();
char *__cdecl sub_804C534(char *s);
int __cdecl sub_804C699(int *a1, unsigned __int8 a2, char a3);
void __cdecl __noreturn sub_804C760(int a1, int a2, int a3);
int sub_804C7BF(); // weak
// _DWORD *__userpurge sub_804C7D3@<eax>(_DWORD *a1, int a2);
void *__cdecl sub_804C866(int a1, const char *a2);
void __cdecl sub_804C93F(int a1, int a2, int a3, int a4, unsigned int a5);
// void __usercall sub_804CE38(int a1@<ebp>);
// int __usercall sub_804D08B@<eax>(int a1@<ebx>, int a2@<ebp>, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, void *a17, char a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42);
// void __usercall sub_804D1F6(int a1@<ebp>);
int sub_804D21E(); // weak
// int __usercall sub_804D4CD@<eax>(int a1@<ebx>, void **a2@<ebp>, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, void *a17, char a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42);
// void __usercall sub_804D593(int a1@<ebp>);
// void __usercall sub_804D78A(int a1@<ebp>, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24);
// void __usercall sub_804D7BB(int a1@<ebp>);
int sub_804D8CA(); // weak
void *__cdecl sub_804D987(int a1, int a2, _DWORD *a3, int *a4);
void *__cdecl sub_804DB4B(signed int a1, int a2, int a3, unsigned int *a4);
void *__cdecl sub_804DD85(signed int a1, int a2);
void *__cdecl sub_804DDAF(signed int a1, int a2, int a3);
void *__cdecl sub_804DE27(signed int a1, int a2, int a3);
void *__cdecl sub_804DE77(signed int a1, int a2, int a3, int a4);
void *__cdecl sub_804DEB4(int a1, int a2);
void *__cdecl sub_804DF07(int a1, int a2, unsigned __int8 a3);
void *__cdecl sub_804DFC3(int a1, unsigned __int8 a2);
void *__cdecl sub_804DFFE(int a1);
void *__cdecl sub_804E03B(signed int a1, int a2, int a3);
void __cdecl __noreturn sub_804E0EE(int a1, int a2, int a3);
void __cdecl __noreturn sub_804E130(int a1, int a2, int a3);
void *__cdecl sub_804E238(signed int a1, int a2, int a3);
void *__cdecl sub_804E287(signed int a1, int a2);
void *__cdecl sub_804E2AD(int a1);
int __cdecl sub_804E2C8(FILE *stream, int a2, int a3, int a4, int *a5, unsigned int a6);
int __cdecl sub_804E866(FILE *a1, int a2, int a3, int a4, int *a5);
int sub_804E8CC(FILE *a1, int a2, int a3, int a4, ...);
void *__cdecl sub_804E9F3(void *ptr, int a2, int a3);
void *__cdecl sub_804EAA6(size_t size);
void *__cdecl sub_804EACB(size_t size);
void *__cdecl sub_804EB05(void *ptr, size_t size);
void *__cdecl sub_804EB61(void *ptr, int a2);
void *__cdecl sub_804EC08(void *src, size_t n);
void __noreturn sub_804EC5A();
void __cdecl sub_804EC93(int errnum, int a2, int a3, int a4, int a5);
int __cdecl sub_804ED67(void *s1, size_t n, void *s2, int); // idb
signed int __cdecl sub_804EE47(unsigned int *a1, signed int a2);
int __cdecl sub_804EE9D(unsigned int *a1, signed int a2, int a3);
int __cdecl sub_804EEE5(char *nptr, int, int base, int, char *s); // idb
int __cdecl sub_804F3D2(FILE *stream); // idb
int __cdecl sub_804F4BC(FILE *stream); // idb
int __cdecl sub_804F4F9(FILE *fp); // idb
int __cdecl sub_804F53D(FILE *stream, int, int, int); // idb
size_t __cdecl sub_804F628(wchar_t *pwc, char *s, size_t n, mbstate_t *p);
int __cdecl sub_804F6E9(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_804F753(FILE *fp); // idb
void *sub_804F807();
char *sub_804FD41();
int __cdecl sub_804FE36(char *s, int, char *s2, int); // idb
int __cdecl sub_804FEF4(void *s1, size_t n, void *s2, int); // idb
int __cdecl sub_804FFB3(void *s1, size_t n, void *s2, int); // idb
int __cdecl sub_80502A3(int a1);
int __cdecl sub_805036C(int a1);
int sub_805044F(void); // weak
int sub_80504C1(void); // weak
int sub_8050548(void); // weak
int sub_80505B6(void); // weak
int sub_8050624(void); // weak
int sub_8050696(void); // weak
int sub_805070A(void); // weak
int sub_805077E(void); // weak
int sub_80507F4(void); // weak
int sub_8050866(void); // weak
int sub_80508DA(void); // weak
int sub_805094E(void); // weak
int sub_80509C0(void); // weak
int (**sub_8050A40())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN locret_8049F30; // weak
_UNKNOWN loc_804A672; // weak
_UNKNOWN loc_804A997; // weak
_UNKNOWN loc_804AA6E; // weak
_UNKNOWN loc_804AAA5; // weak
_UNKNOWN loc_804AB4F; // weak
_UNKNOWN loc_804AB5B; // weak
_UNKNOWN loc_804AC34; // weak
_UNKNOWN loc_804AC94; // weak
_UNKNOWN loc_804AE3B; // weak
_UNKNOWN loc_804AE5E; // weak
_UNKNOWN loc_804AE78; // weak
_UNKNOWN loc_804AF6F; // weak
_UNKNOWN loc_804AF74; // weak
_UNKNOWN loc_804B3A6; // weak
_UNKNOWN loc_804B3C9; // weak
_UNKNOWN loc_804B3DB; // weak
_UNKNOWN loc_804B47D; // weak
_UNKNOWN loc_804B997; // weak
_UNKNOWN loc_804B9D2; // weak
_UNKNOWN loc_804BACF; // weak
_UNKNOWN loc_804BAD7; // weak
_UNKNOWN loc_804BB19; // weak
_UNKNOWN loc_804BB51; // weak
_UNKNOWN loc_804BB58; // weak
_UNKNOWN loc_804BB99; // weak
_UNKNOWN loc_804C018; // weak
_UNKNOWN loc_804C03C; // weak
_UNKNOWN loc_804C0DD; // weak
_UNKNOWN loc_804C0E3; // weak
_UNKNOWN loc_804C115; // weak
_UNKNOWN loc_804C121; // weak
_UNKNOWN loc_804C1AB; // weak
_UNKNOWN loc_804C1D4; // weak
_UNKNOWN loc_804C1E0; // weak
_UNKNOWN loc_804C327; // weak
_UNKNOWN loc_804C3EA; // weak
_UNKNOWN locret_804C403; // weak
_UNKNOWN loc_804C4E5; // weak
_UNKNOWN loc_804C529; // weak
_UNKNOWN loc_804C52F; // weak
_UNKNOWN loc_804C785; // weak
_UNKNOWN loc_804C78C; // weak
_UNKNOWN loc_804C7BA; // weak
_UNKNOWN loc_804C8EE; // weak
_UNKNOWN loc_804C8F5; // weak
_UNKNOWN locret_804C93D; // weak
_UNKNOWN loc_804C9B8; // weak
_UNKNOWN loc_804CEAB; // weak
_UNKNOWN loc_804D0AA; // weak
_UNKNOWN loc_804D0BD; // weak
_UNKNOWN loc_804D215; // weak
_UNKNOWN loc_804D2FA; // weak
_UNKNOWN loc_804D4F7; // weak
_UNKNOWN loc_804D502; // weak
_UNKNOWN loc_804D521; // weak
_UNKNOWN loc_804D54D; // weak
_UNKNOWN loc_804D58E; // weak
_UNKNOWN loc_804D608; // weak
_UNKNOWN loc_804D7DB; // weak
_UNKNOWN loc_804D7FE; // weak
_UNKNOWN loc_804D850; // weak
_UNKNOWN loc_804D857; // weak
_UNKNOWN loc_804D8C5; // weak
_UNKNOWN loc_804EA26; // weak
_UNKNOWN loc_804EA44; // weak
_UNKNOWN loc_804EF51; // weak
_UNKNOWN loc_804EF95; // weak
_UNKNOWN loc_804EFE4; // weak
_UNKNOWN loc_804F02D; // weak
_UNKNOWN loc_804F036; // weak
_UNKNOWN loc_804F052; // weak
_UNKNOWN loc_804F082; // weak
_UNKNOWN loc_804F08C; // weak
_UNKNOWN loc_804F0CE; // weak
_UNKNOWN loc_804F159; // weak
_UNKNOWN loc_804F19A; // weak
_UNKNOWN loc_804F387; // weak
_UNKNOWN loc_804F3C1; // weak
_UNKNOWN loc_804F3C5; // weak
_UNKNOWN locret_804F3D0; // weak
_UNKNOWN loc_804F440; // weak
_UNKNOWN loc_804F479; // weak
_UNKNOWN loc_804F64D; // weak
_UNKNOWN loc_804F653; // weak
_UNKNOWN loc_804F69F; // weak
_UNKNOWN loc_804F6CB; // weak
_UNKNOWN loc_804F6E4; // weak
_UNKNOWN loc_804F7B7; // weak
_UNKNOWN loc_804F7FB; // weak
_UNKNOWN locret_804F801; // weak
_UNKNOWN loc_804F87C; // weak
_UNKNOWN loc_804F889; // weak
_UNKNOWN loc_804F9CE; // weak
_UNKNOWN loc_804F9DD; // weak
_UNKNOWN loc_804FD75; // weak
_UNKNOWN loc_804FD7C; // weak
_UNKNOWN loc_804FD86; // weak
_UNKNOWN loc_804FE20; // weak
_UNKNOWN loc_804FFDA; // weak
_UNKNOWN loc_805000A; // weak
char s = '\0'; // idb
struct option longopts = { "count", 0, NULL, 99 }; // idb
_UNKNOWN unk_80518A6; // weak
_UNKNOWN unk_80518B6; // weak
_UNKNOWN unk_80518BA; // weak
_UNKNOWN unk_80518BD; // weak
_UNKNOWN unk_80518BF; // weak
_DWORD off_80518C4[11] =
{
  134531903,
  134531798,
  134531817,
  134531794,
  134531802,
  134531548,
  134531537,
  134531605,
  134531636,
  134531636,
  134531636
}; // idb
void *off_8051E4C = &loc_804E38F; // weak
_UNKNOWN unk_805221F; // weak
_UNKNOWN unk_80531B8; // weak
_UNKNOWN unk_80531BB; // weak
_UNKNOWN unk_805421C; // weak
_UNKNOWN unk_805421F; // weak
int (*off_8055EC8[2])() = { &sub_8049250, &sub_8049230 }; // weak
int (*off_8055ECC)() = &sub_8049230; // weak
int (*dword_8056008)(void) = NULL; // weak
int dword_8056120 = 0; // weak
int dword_8056134 = 0; // weak
int dword_8056148 = 0; // weak
int dword_805615C = 0; // weak
int dword_8056170 = 0; // weak
int dword_8056184 = 0; // weak
int dword_8056198 = 0; // weak
int dword_80561AC = 0; // weak
int dword_80561C0 = 0; // weak
int dword_80561D4 = 0; // weak
int dword_80561E8 = 0; // weak
int dword_80561FC = 0; // weak
int dword_8056210 = 0; // weak
int dword_8056234 = 0; // weak
int status = 1; // idb
int dword_8056250 = 1; // weak
int dword_8056254 = 256; // weak
void *off_8056258 = &unk_8056830; // weak
int *off_805625C = &dword_8056254; // weak
_UNKNOWN unk_8056270; // weak
_UNKNOWN unk_805628C; // weak
_UNKNOWN unk_805628F; // weak
_UNKNOWN unk_8056294; // weak
_UNKNOWN unk_8056297; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int program_invocation_name; // weak
int optind; // weak
FILE *stdin; // idb
FILE *stdout; // idb
char byte_80562EC; // weak
_UNKNOWN unk_805633D; // weak
_UNKNOWN unk_80565A5; // weak
char byte_805663B; // weak
char byte_80567C0; // weak
int dword_80567C4; // weak
int dword_80567C8; // weak
int dword_80567CC; // weak
int dword_80567D0; // weak
char byte_80567D4; // weak
char byte_80567D5; // weak
char byte_80567D6; // weak
char byte_80567D7; // weak
int dword_80567D8; // weak
int dword_80567DC; // weak
int dword_80567E0; // weak
char byte_80567E4; // weak
int dword_80567E8; // weak
int dword_80567F0; // weak
int dword_80567F4; // weak
int dword_80567F8; // weak
int dword_80567FC; // weak
int dword_8056800; // weak
int dword_8056804; // weak
int dword_8056808; // weak
int dword_805680C; // weak
int dword_8056810; // weak
int dword_8056814; // weak
int dword_8056818; // weak
int dword_805681C; // weak
_UNKNOWN unk_8056830; // weak
int dword_8056930; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (08048D20) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 8049150: using guessed type int _gmon_start__(void);

//----- (08048D50) --------------------------------------------------------
int sub_8048D50()
{
  return dword_8056008();
}
// 8056008: using guessed type int (*dword_8056008)(void);

//----- (08049160) --------------------------------------------------------
#error "8049163: positive sp value has been found (funcsize=2)"

//----- (08049193) --------------------------------------------------------
void sub_8049193()
{
  ;
}

//----- (080491B0) --------------------------------------------------------
void sub_80491B0()
{
  ;
}

//----- (080491C0) --------------------------------------------------------
int sub_80491C0()
{
  int result; // eax

  result = 134570659 - (_DWORD)&program_invocation_short_name;
  if ( (unsigned int)(134570659 - (_DWORD)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 80491C0: could not find valid save-restore pair for ebp
// 80562A0: using guessed type int program_invocation_short_name;

//----- (08049230) --------------------------------------------------------
int sub_8049230()
{
  int result; // eax

  if ( !byte_80562EC )
  {
    result = sub_80491C0();
    byte_80562EC = 1;
  }
  return result;
}
// 8049230: could not find valid save-restore pair for ebp
// 80562EC: using guessed type char byte_80562EC;

//----- (08049250) --------------------------------------------------------
int sub_8049250()
{
  return 0;
}
// 8049250: could not find valid save-restore pair for ebp

//----- (080492AF) --------------------------------------------------------
void sub_80492AF()
{
  ;
}

//----- (080492CA) --------------------------------------------------------
void sub_80492CA()
{
  ;
}

//----- (080492DA) --------------------------------------------------------
int sub_80492DA()
{
  int result; // eax

  result = &unk_8056297 - &unk_8056294;
  _CF = (unsigned int)(&unk_8056297 - &unk_8056294) < 6;
  _OF = __OFSUB__(&unk_8056297 - &unk_8056294, 6);
  _ZF = &unk_8056297 - &unk_8056294 == 6;
  _SF = &unk_8056297 - &unk_8056294 - 6 < 0;
  if ( (unsigned int)(&unk_8056297 - &unk_8056294) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 80492DA: could not find valid save-restore pair for ebp

//----- (080493C2) --------------------------------------------------------
void sub_80493C2()
{
  ;
}

//----- (080493DD) --------------------------------------------------------
void sub_80493DD()
{
  ;
}

//----- (080493ED) --------------------------------------------------------
int sub_80493ED()
{
  int result; // eax

  result = &unk_805633D - (_UNKNOWN *)&program_invocation_short_name;
  _CF = (unsigned int)(&unk_805633D - (_UNKNOWN *)&program_invocation_short_name) < 6;
  _OF = __OFSUB__(&unk_805633D - (_UNKNOWN *)&program_invocation_short_name, 6);
  _ZF = &unk_805633D - (_UNKNOWN *)&program_invocation_short_name == 6;
  _SF = &unk_805633D - (_UNKNOWN *)&program_invocation_short_name - 6 < 0;
  if ( (unsigned int)(&unk_805633D - (_UNKNOWN *)&program_invocation_short_name) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 80493ED: could not find valid save-restore pair for ebp
// 80562A0: using guessed type int program_invocation_short_name;

//----- (080494D5) --------------------------------------------------------
void sub_80494D5()
{
  ;
}

//----- (080494F0) --------------------------------------------------------
void sub_80494F0()
{
  ;
}

//----- (08049500) --------------------------------------------------------
int sub_8049500()
{
  int result; // eax

  result = &unk_805628F - &unk_805628C;
  _CF = (unsigned int)(&unk_805628F - &unk_805628C) < 6;
  _OF = __OFSUB__(&unk_805628F - &unk_805628C, 6);
  _ZF = &unk_805628F - &unk_805628C == 6;
  _SF = &unk_805628F - &unk_805628C - 6 < 0;
  if ( (unsigned int)(&unk_805628F - &unk_805628C) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 8049500: could not find valid save-restore pair for ebp

//----- (080495E8) --------------------------------------------------------
void sub_80495E8()
{
  ;
}

//----- (08049603) --------------------------------------------------------
void sub_8049603()
{
  ;
}

//----- (08049613) --------------------------------------------------------
int sub_8049613()
{
  int result; // eax

  result = &unk_805628F - &unk_805628C;
  _CF = (unsigned int)(&unk_805628F - &unk_805628C) < 6;
  _OF = __OFSUB__(&unk_805628F - &unk_805628C, 6);
  _ZF = &unk_805628F - &unk_805628C == 6;
  _SF = &unk_805628F - &unk_805628C - 6 < 0;
  if ( (unsigned int)(&unk_805628F - &unk_805628C) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 8049613: could not find valid save-restore pair for ebp

//----- (080496FB) --------------------------------------------------------
void sub_80496FB()
{
  ;
}

//----- (08049716) --------------------------------------------------------
void sub_8049716()
{
  ;
}

//----- (08049726) --------------------------------------------------------
int sub_8049726()
{
  int result; // eax

  result = &unk_805628F - &unk_805628C;
  _CF = (unsigned int)(&unk_805628F - &unk_805628C) < 6;
  _OF = __OFSUB__(&unk_805628F - &unk_805628C, 6);
  _ZF = &unk_805628F - &unk_805628C == 6;
  _SF = &unk_805628F - &unk_805628C - 6 < 0;
  if ( (unsigned int)(&unk_805628F - &unk_805628C) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 8049726: could not find valid save-restore pair for ebp

//----- (0804978F) --------------------------------------------------------
int __usercall sub_804978F@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_805628C, a1);
}

//----- (08049827) --------------------------------------------------------
void sub_8049827()
{
  ;
}

//----- (08049842) --------------------------------------------------------
void sub_8049842()
{
  ;
}

//----- (08049852) --------------------------------------------------------
int sub_8049852()
{
  int result; // eax

  result = &unk_805628F - &unk_805628C;
  _CF = (unsigned int)(&unk_805628F - &unk_805628C) < 6;
  _OF = __OFSUB__(&unk_805628F - &unk_805628C, 6);
  _ZF = &unk_805628F - &unk_805628C == 6;
  _SF = &unk_805628F - &unk_805628C - 6 < 0;
  if ( (unsigned int)(&unk_805628F - &unk_805628C) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 8049852: could not find valid save-restore pair for ebp

//----- (0804993A) --------------------------------------------------------
void sub_804993A()
{
  ;
}

//----- (08049955) --------------------------------------------------------
void sub_8049955()
{
  ;
}

//----- (08049965) --------------------------------------------------------
int sub_8049965()
{
  int result; // eax

  result = &unk_805421F - &unk_805421C;
  _CF = (unsigned int)(&unk_805421F - &unk_805421C) < 6;
  _OF = __OFSUB__(&unk_805421F - &unk_805421C, 6);
  _ZF = &unk_805421F - &unk_805421C == 6;
  _SF = &unk_805421F - &unk_805421C - 6 < 0;
  if ( (unsigned int)(&unk_805421F - &unk_805421C) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 8049965: could not find valid save-restore pair for ebp

//----- (08049A4D) --------------------------------------------------------
void sub_8049A4D()
{
  ;
}

//----- (08049A68) --------------------------------------------------------
void sub_8049A68()
{
  ;
}

//----- (08049A78) --------------------------------------------------------
int sub_8049A78()
{
  int result; // eax

  result = &unk_805628F - &unk_805628C;
  _CF = (unsigned int)(&unk_805628F - &unk_805628C) < 6;
  _OF = __OFSUB__(&unk_805628F - &unk_805628C, 6);
  _ZF = &unk_805628F - &unk_805628C == 6;
  _SF = &unk_805628F - &unk_805628C - 6 < 0;
  if ( (unsigned int)(&unk_805628F - &unk_805628C) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 8049A78: could not find valid save-restore pair for ebp

//----- (08049B79) --------------------------------------------------------
void sub_8049B79()
{
  ;
}

//----- (08049B94) --------------------------------------------------------
void sub_8049B94()
{
  ;
}

//----- (08049BA4) --------------------------------------------------------
int sub_8049BA4()
{
  int result; // eax

  result = &unk_805628F - &unk_805628C;
  _CF = (unsigned int)(&unk_805628F - &unk_805628C) < 6;
  _OF = __OFSUB__(&unk_805628F - &unk_805628C, 6);
  _ZF = &unk_805628F - &unk_805628C == 6;
  _SF = &unk_805628F - &unk_805628C - 6 < 0;
  if ( (unsigned int)(&unk_805628F - &unk_805628C) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 8049BA4: could not find valid save-restore pair for ebp

//----- (08049CA5) --------------------------------------------------------
void sub_8049CA5()
{
  ;
}

//----- (08049CC0) --------------------------------------------------------
void sub_8049CC0()
{
  ;
}

//----- (08049CD0) --------------------------------------------------------
int sub_8049CD0()
{
  int result; // eax

  result = &unk_80565A5 - (_UNKNOWN *)&program_invocation_short_name;
  _CF = (unsigned int)(&unk_80565A5 - (_UNKNOWN *)&program_invocation_short_name) < 6;
  _OF = __OFSUB__(&unk_80565A5 - (_UNKNOWN *)&program_invocation_short_name, 6);
  _ZF = &unk_80565A5 - (_UNKNOWN *)&program_invocation_short_name == 6;
  _SF = &unk_80565A5 - (_UNKNOWN *)&program_invocation_short_name - 6 < 0;
  if ( (unsigned int)(&unk_80565A5 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 8049CD0: could not find valid save-restore pair for ebp
// 80562A0: using guessed type int program_invocation_short_name;

//----- (08049DCA) --------------------------------------------------------
void sub_8049DCA()
{
  ;
}

//----- (08049DE5) --------------------------------------------------------
void sub_8049DE5()
{
  ;
}

//----- (08049DF5) --------------------------------------------------------
int sub_8049DF5()
{
  int result; // eax

  result = &unk_805628F - &unk_805628C;
  _CF = (unsigned int)(&unk_805628F - &unk_805628C) < 6;
  _OF = __OFSUB__(&unk_805628F - &unk_805628C, 6);
  _ZF = &unk_805628F - &unk_805628C == 6;
  _SF = &unk_805628F - &unk_805628C - 6 < 0;
  if ( (unsigned int)(&unk_805628F - &unk_805628C) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 8049DF5: could not find valid save-restore pair for ebp

//----- (08049E81) --------------------------------------------------------
int sub_8049E81()
{
  int result; // eax

  result = sub_8049DF5();
  byte_805663B = 1;
  return result;
}
// 805663B: using guessed type char byte_805663B;

//----- (08049EF6) --------------------------------------------------------
void sub_8049EF6()
{
  ;
}

//----- (08049F11) --------------------------------------------------------
void sub_8049F11()
{
  ;
}

//----- (08049F21) --------------------------------------------------------
int sub_8049F21()
{
  int result; // eax
  int (__stdcall *v1)(void *, int, int, int, int, int); // eax
  int v2; // [esp+4h] [ebp-18h]
  int v3; // [esp+8h] [ebp-14h]
  int v4; // [esp+Ch] [ebp-10h]
  int v5; // [esp+10h] [ebp-Ch]
  int v6; // [esp+14h] [ebp-8h]
  int v7; // [esp+18h] [ebp-4h]

  result = &unk_80531BB - &unk_80531B8;
  if ( (unsigned int)(&unk_80531BB - &unk_80531B8) > 6 )
  {
    v7 = 0;
    dword_80561E8 = (int)&locret_8049F30;
    v1 = (int (__stdcall *)(void *, int, int, int, int, int))sub_8050548();
    result = v1(&unk_80531B8, v2, v3, v4, v5, v6);
  }
  return result;
}
// 8050548: using guessed type int sub_8050548(void);
// 80561E8: using guessed type int dword_80561E8;

//----- (0804A022) --------------------------------------------------------
void sub_804A022()
{
  ;
}

//----- (0804A03D) --------------------------------------------------------
void sub_804A03D()
{
  ;
}

//----- (0804A04D) --------------------------------------------------------
int sub_804A04D()
{
  int result; // eax

  result = &unk_805628F - &unk_805628C;
  _CF = (unsigned int)(&unk_805628F - &unk_805628C) < 6;
  _OF = __OFSUB__(&unk_805628F - &unk_805628C, 6);
  _ZF = &unk_805628F - &unk_805628C == 6;
  _SF = &unk_805628F - &unk_805628C - 6 < 0;
  if ( (unsigned int)(&unk_805628F - &unk_805628C) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 804A04D: could not find valid save-restore pair for ebp

//----- (0804A135) --------------------------------------------------------
void sub_804A135()
{
  ;
}

//----- (0804A150) --------------------------------------------------------
void sub_804A150()
{
  ;
}

//----- (0804A160) --------------------------------------------------------
int sub_804A160()
{
  int result; // eax

  result = &unk_805628F - &unk_805628C;
  _CF = (unsigned int)(&unk_805628F - &unk_805628C) < 6;
  _OF = __OFSUB__(&unk_805628F - &unk_805628C, 6);
  _ZF = &unk_805628F - &unk_805628C == 6;
  _SF = &unk_805628F - &unk_805628C - 6 < 0;
  if ( (unsigned int)(&unk_805628F - &unk_805628C) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 804A160: could not find valid save-restore pair for ebp

//----- (0804A24C) --------------------------------------------------------
void sub_804A24C()
{
  ;
}

//----- (0804A26B) --------------------------------------------------------
void sub_804A26B()
{
  ;
}

//----- (0804A27F) --------------------------------------------------------
int sub_804A27F()
{
  int result; // eax

  result = &unk_8056297 - &unk_8056294;
  _CF = (unsigned int)(&unk_8056297 - &unk_8056294) < 6;
  _OF = __OFSUB__(&unk_8056297 - &unk_8056294, 6);
  _ZF = &unk_8056297 - &unk_8056294 == 6;
  _SF = &unk_8056297 - &unk_8056294 - 6 < 0;
  if ( (unsigned int)(&unk_8056297 - &unk_8056294) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 804A27F: could not find valid save-restore pair for ebp

//----- (0804A377) --------------------------------------------------------
void sub_804A377()
{
  ;
}

//----- (0804A396) --------------------------------------------------------
void sub_804A396()
{
  ;
}

//----- (0804A3A6) --------------------------------------------------------
signed int sub_804A3A6()
{
  return 3;
}

//----- (0804A413) --------------------------------------------------------
int __usercall sub_804A413@<eax>(int a1@<eax>, int (__cdecl *a2)(signed int, int)@<edx>)
{
  return a2(134554000, a1);
}

//----- (0804A485) --------------------------------------------------------
int __cdecl sub_804A485(unsigned __int8 a1)
{
  char v5; // al

  if ( (*__ctype_b_loc())[a1] & 1
    || (_CF = a1 < 0xAu, _OF = __OFSUB__(a1, 10), _ZF = a1 == 10, _SF = (char)(a1 - 10) < 0, a1 == 10) )
  {
    v5 = 1;
  }
  else
  {
    __asm { pushfw }
    v5 = 0;
    __asm { popfw }
  }
  return v5 & 1;
}

//----- (0804A4C9) --------------------------------------------------------
int sub_804A4C9()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nMandatory arguments to long options are mandatory for short options too.\n");
  return fputs_unlocked(v1, v0);
}
// 8048F80: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804A4F8) --------------------------------------------------------
int __cdecl sub_804A4F8(char *s1)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v6; // [esp+4h] [ebp-64h]
  char *v7; // [esp+8h] [ebp-60h]
  char *v8; // [esp+1Ch] [ebp-4Ch]
  const char **i; // [esp+20h] [ebp-48h]
  char *v10; // [esp+24h] [ebp-44h]
  const char *v11; // [esp+28h] [ebp-40h]
  const char *v12; // [esp+2Ch] [ebp-3Ch]
  const char *v13; // [esp+30h] [ebp-38h]
  const char *v14; // [esp+34h] [ebp-34h]
  const char *v15; // [esp+38h] [ebp-30h]
  const char *v16; // [esp+3Ch] [ebp-2Ch]
  const char *v17; // [esp+40h] [ebp-28h]
  const char *v18; // [esp+44h] [ebp-24h]
  const char *v19; // [esp+48h] [ebp-20h]
  const char *v20; // [esp+4Ch] [ebp-1Ch]
  const char *v21; // [esp+50h] [ebp-18h]
  const char *v22; // [esp+54h] [ebp-14h]
  int v23; // [esp+58h] [ebp-10h]
  int v24; // [esp+5Ch] [ebp-Ch]

  v11 = "[";
  v12 = "test invocation";
  v13 = "coreutils";
  v14 = "Multi-call invocation";
  v15 = "sha224sum";
  v16 = "sha2 utilities";
  v17 = "sha256sum";
  v18 = "sha2 utilities";
  v19 = "sha384sum";
  v20 = "sha2 utilities";
  v21 = "sha512sum";
  v22 = "sha2 utilities";
  v23 = 0;
  v24 = 0;
  v8 = s1;
  for ( i = &v11; *i; i += 2 )
  {
    v6 = (char *)*i;
    if ( !strcmp(s1, v6) )
      break;
  }
  if ( i[1] )
    v8 = (char *)i[1];
  v1 = gettext("\n%s online help: <%s>\n");
  v7 = "http://www.gnu.org/software/coreutils/";
  v6 = "GNU coreutils";
  printf(v1, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  v10 = setlocale(5, 0);
  if ( v10 && strncmp(v10, "en_", 3u) )
  {
    v2 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
    v6 = s1;
    printf(v2, s1);
  }
  v3 = gettext("Full documentation at: <%s%s>\n");
  v7 = s1;
  v6 = "http://www.gnu.org/software/coreutils/";
  printf(v3, "http://www.gnu.org/software/coreutils/", s1);
  if ( v8 == s1 )
  {
    dword_80561E8 = (int)&loc_804A672;
    sub_8050548();
  }
  v4 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  v7 = &s;
  v6 = v8;
  return printf(v4, v8, &s);
}
// 8050548: using guessed type int sub_8050548(void);
// 80561E8: using guessed type int dword_80561E8;

//----- (0804A697) --------------------------------------------------------
void __cdecl __noreturn sub_804A697(int status)
{
  int v1; // ebx
  char *v2; // eax
  int v3; // ebx
  char *v4; // eax
  FILE *v5; // ebx
  char *v6; // eax
  FILE *v7; // ebx
  char *v8; // eax
  FILE *v9; // ebx
  char *v10; // eax
  FILE *v11; // ebx
  char *v12; // eax
  FILE *v13; // ebx
  char *v14; // eax
  FILE *v15; // ebx
  char *v16; // eax
  FILE *v17; // ebx
  char *v18; // eax
  FILE *v19; // ebx
  char *v20; // eax
  FILE *v21; // ebx
  char *v22; // eax
  FILE *v23; // ebx
  char *v24; // eax
  FILE *v25; // ebx
  char *v26; // eax
  FILE *v27; // ebx
  char *v28; // eax

  if ( status )
  {
    v1 = dword_80567E8;
    v2 = gettext("Try '%s --help' for more information.\n");
    fprintf(stderr, v2, v1);
  }
  else
  {
    v3 = dword_80567E8;
    v4 = gettext("Usage: %s [OPTION]... [INPUT [OUTPUT]]\n");
    printf(v4, v3);
    v5 = stdout;
    v6 = gettext(
           "Filter adjacent matching lines from INPUT (or standard input),\n"
           "writing to OUTPUT (or standard output).\n"
           "\n"
           "With no options, matching lines are merged to the first occurrence.\n");
    fputs_unlocked(v6, v5);
    sub_804A4C9();
    v7 = stdout;
    v8 = gettext(
           "  -c, --count           prefix lines by the number of occurrences\n"
           "  -d, --repeated        only print duplicate lines, one for each group\n");
    fputs_unlocked(v8, v7);
    v9 = stdout;
    v10 = gettext(
            "  -D                    print all duplicate lines\n"
            "      --all-repeated[=METHOD]  like -D, but allow separating groups\n"
            "                                 with an empty line;\n"
            "                                 METHOD={none(default),prepend,separate}\n");
    fputs_unlocked(v10, v9);
    v11 = stdout;
    v12 = gettext("  -f, --skip-fields=N   avoid comparing the first N fields\n");
    fputs_unlocked(v12, v11);
    v13 = stdout;
    v14 = gettext(
            "      --group[=METHOD]  show all items, separating groups with an empty line;\n"
            "                          METHOD={separate(default),prepend,append,both}\n");
    fputs_unlocked(v14, v13);
    v15 = stdout;
    v16 = gettext(
            "  -i, --ignore-case     ignore differences in case when comparing\n"
            "  -s, --skip-chars=N    avoid comparing the first N characters\n"
            "  -u, --unique          only print unique lines\n");
    fputs_unlocked(v16, v15);
    v17 = stdout;
    v18 = gettext("  -z, --zero-terminated     line delimiter is NUL, not newline\n");
    fputs_unlocked(v18, v17);
    v19 = stdout;
    v20 = gettext("  -w, --check-chars=N   compare no more than N characters in lines\n");
    fputs_unlocked(v20, v19);
    v21 = stdout;
    v22 = gettext("      --help     display this help and exit\n");
    fputs_unlocked(v22, v21);
    v23 = stdout;
    v24 = gettext("      --version  output version information and exit\n");
    fputs_unlocked(v24, v23);
    v25 = stdout;
    v26 = gettext(
            "\n"
            "A field is a run of blanks (usually spaces and/or TABs), then non-blank\n"
            "characters.  Fields are skipped before chars.\n");
    fputs_unlocked(v26, v25);
    v27 = stdout;
    v28 = gettext(
            "\n"
            "Note: 'uniq' does not detect repeated lines unless they are adjacent.\n"
            "You may want to sort the input first, or use 'sort -u' without 'uniq'.\n"
            "Also, comparisons honor the rules specified by 'LC_COLLATE'.\n");
    fputs_unlocked(v28, v27);
    sub_804A4F8("uniq");
  }
  exit(status);
}
// 8048F80: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 80567E8: using guessed type int dword_80567E8;

//----- (0804A873) --------------------------------------------------------
int sub_804A873()
{
  char v4; // al
  int v6; // [esp+Ch] [ebp-Ch]

  v6 = sub_804C4A0();
  _CF = (unsigned int)v6 < 0x30DAF;
  _OF = __OFSUB__(v6, 200111);
  _ZF = v6 == 200111;
  _SF = v6 - 200111 < 0;
  if ( v6 <= 200111
    || (_CF = (unsigned int)v6 < 0x31068,
        _OF = __OFSUB__(v6, 200808),
        _ZF = v6 == 200808,
        _SF = v6 - 200808 < 0,
        v6 > 200808) )
  {
    __asm { pushfw }
    v4 = 0;
    __asm { popfw }
  }
  else
  {
    v4 = 1;
  }
  return v4 & 1;
}

//----- (0804A8C5) --------------------------------------------------------
int __cdecl sub_804A8C5(char *nptr, char *msgid)
{
  char *v2; // eax
  int v4; // [esp+2Ch] [ebp-Ch]

  if ( (unsigned int)sub_804EEE5(nptr, 0, 10, (int)&v4, &s) > 1 )
  {
    v2 = gettext(msgid);
    error(1, 0, "%s: %s", nptr, v2);
  }
  return v4;
}

//----- (0804A931) --------------------------------------------------------
int __cdecl sub_804A931(int a1)
{
  unsigned __int8 *v1; // ebp
  int v2; // eax
  unsigned __int8 v4; // [esp+0h] [ebp-28h]
  int v5; // [esp+10h] [ebp-18h]
  int v6; // [esp+14h] [ebp-14h]
  int v7; // [esp+18h] [ebp-10h]
  int v8; // [esp+1Ch] [ebp-Ch]
  int savedregs; // [esp+28h] [ebp+0h]

  v1 = (unsigned __int8 *)&savedregs;
  v7 = *(_DWORD *)(a1 + 8);
  v8 = *(_DWORD *)(a1 + 4) - 1;
  v6 = 0;
  v5 = 0;
  while ( *((_DWORD *)v1 - 6) < (unsigned int)dword_80567C4 && *((_DWORD *)v1 - 5) < *((_DWORD *)v1 - 3) )
  {
    dword_8056134 = (int)&loc_804A997;
    sub_805094E();
    v1 = &v4;
    do
    {
      if ( ++*((_DWORD *)&v4 - 5) >= *((_DWORD *)&v4 - 3) )
        break;
      *(_DWORD *)&v4 = *(unsigned __int8 *)(*((_DWORD *)&v4 - 4) + *((_DWORD *)&v4 - 5));
    }
    while ( (unsigned __int8)sub_804A485(v4) );
    while ( *((_DWORD *)&v4 - 5) < *((_DWORD *)&v4 - 3) )
    {
      *(_DWORD *)&v4 = *(unsigned __int8 *)(*((_DWORD *)&v4 - 4) + *((_DWORD *)&v4 - 5));
      if ( !((unsigned __int8)sub_804A485(v4) ^ 1) )
        break;
      ++*((_DWORD *)&v4 - 5);
    }
    ++*((_DWORD *)&v4 - 6);
  }
  v2 = dword_80567C8;
  if ( *((_DWORD *)v1 - 3) - *((_DWORD *)v1 - 5) <= (unsigned int)dword_80567C8 )
    v2 = *((_DWORD *)v1 - 3) - *((_DWORD *)v1 - 5);
  *((_DWORD *)v1 - 5) += v2;
  return *(_DWORD *)(*((_DWORD *)v1 + 2) + 8) + *((_DWORD *)v1 - 5);
}
// 805094E: using guessed type int sub_805094E(void);
// 8056134: using guessed type int dword_8056134;
// 80567C4: using guessed type int dword_80567C4;
// 80567C8: using guessed type int dword_80567C8;

//----- (0804AA20) --------------------------------------------------------
int __cdecl sub_804AA20(void *s1, void *s2, size_t n, int a4)
{
  void *v4; // eax
  int v5; // eax
  char v10; // al

  if ( dword_80567CC < n )
    n = dword_80567CC;
  if ( dword_80567CC < (unsigned int)a4 )
    a4 = dword_80567CC;
  v4 = &loc_804AA6E;
  if ( !byte_80567D7 )
    v4 = &loc_804AAA5;
  dword_805615C = (int)v4;
  sub_8050866();
  if ( n != a4 || (v5 = sub_804C41B((int)s1, (int)s2, n), _CF = 0, _OF = 0, _ZF = v5 == 0, _SF = v5 < 0, v5) )
  {
    v10 = 1;
  }
  else
  {
    __asm { pushfw }
    v10 = 0;
    __asm { popfw }
  }
  return v10 & 1;
}
// 8050866: using guessed type int sub_8050866(void);
// 805615C: using guessed type int dword_805615C;
// 80567CC: using guessed type int dword_80567CC;
// 80567D7: using guessed type char byte_80567D7;

//----- (0804AB12) --------------------------------------------------------
size_t __cdecl sub_804AB12(int a1, char a2, __int64 a3)
{
  void *v3; // eax
  size_t result; // eax
  __int64 v5; // [esp+4h] [ebp-24h]
  __int64 v6; // [esp+10h] [ebp-18h]
  char v7; // [esp+1Ch] [ebp-Ch]

  v7 = a2;
  v6 = a3;
  v3 = &loc_804AB4F;
  if ( a3 )
    v3 = &loc_804AB5B;
  dword_805615C = (int)v3;
  sub_8050866();
  result = (unsigned __int8)byte_80567D4 ^ 1;
  if ( !(_BYTE)result )
  {
    if ( !dword_80567D0 )
    {
      v5 = v6 + 1;
      printf("%7llu ", v6 + 1);
    }
    result = fwrite_unlocked(*(const void **)(a1 + 8), 1u, *(_DWORD *)(a1 + 4), stdout);
  }
  return result;
}
// 8050866: using guessed type int sub_8050866(void);
// 805615C: using guessed type int dword_805615C;
// 80567D0: using guessed type int dword_80567D0;
// 80567D4: using guessed type char byte_80567D4;

//----- (0804ABF4) --------------------------------------------------------
void __cdecl sub_804ABF4(char *s1, char *a2, int a3)
{
  void *v3; // eax
  void *v4; // ebx
  int *v5; // eax
  void *v6; // ebx
  int *v7; // eax
  char v8; // al
  char v13; // al
  void *v14; // eax
  void *v15; // eax
  char *v16; // ST58_4
  void *v17; // eax
  void *v18; // ebx
  char *v19; // eax
  char v20; // [esp+2Ch] [ebp-5Ch]
  char v21; // [esp+2Eh] [ebp-5Ah]
  char *s; // [esp+30h] [ebp-58h]
  char *v23; // [esp+34h] [ebp-54h]
  void *s2; // [esp+38h] [ebp-50h]
  int v25; // [esp+3Ch] [ebp-4Ch]
  void *v26; // [esp+48h] [ebp-40h]
  int n; // [esp+4Ch] [ebp-3Ch]
  char v28; // [esp+68h] [ebp-20h]
  void *ptr; // [esp+70h] [ebp-18h]
  char v30; // [esp+74h] [ebp-14h]
  void *v31; // [esp+7Ch] [ebp-Ch]

  _ZF = strcmp(s1, "-") == 0;
  v3 = &loc_804AC34;
  if ( _ZF )
    v3 = &loc_804AC94;
  dword_80561E8 = (int)v3;
  sub_8050548();
  if ( !sub_804C043((int)s1, (int)"r", stdin) )
  {
    v4 = sub_804E03B(0, 3, (int)s1);
    v5 = __errno_location();
    error(1, *v5, "%s", v4);
  }
  if ( strcmp(a2, "-") && !sub_804C043((int)a2, (int)"w", stdout) )
  {
    v6 = sub_804E03B(0, 3, (int)a2);
    v7 = __errno_location();
    error(1, *v7, "%s", v6);
  }
  sub_804BF70(stdin, 2);
  s = &v28;
  v23 = &v30;
  sub_804C287(&v28);
  sub_804C287(&v30);
  if ( byte_80567D4 && byte_80567D5 && dword_80567D0 == 1 )
  {
    v20 = 0;
    while ( !feof_unlocked(stdin) && sub_804C2D0((int)s, stdin, (char)a3) )
    {
      v26 = (void *)sub_804A931((int)s);
      n = *((_DWORD *)s + 1) + *((_DWORD *)s + 2) - (_DWORD)v26 - 1;
      if ( *((_DWORD *)v23 + 1)
        && (v8 = sub_804AA20(v26, s2, n, v25), _CF = 0, _OF = 0, _ZF = v8 == 0, _SF = v8 < 0, !v8) )
      {
        __asm { pushfw }
        v13 = 0;
        __asm { popfw }
      }
      else
      {
        v13 = 1;
      }
      v21 = v13 & 1;
      if ( v13 & 1 && dword_80567DC )
      {
        v14 = &loc_804AE3B;
        if ( dword_80567DC == 1 )
          v14 = &loc_804AE78;
        dword_80561AC = (int)v14;
        sub_8050696();
        v15 = &loc_804AE5E;
        if ( dword_80567DC == 4 )
          v15 = &loc_804AE78;
        dword_8056148 = (int)v15;
        sub_80508DA();
        if ( v20 && (dword_80567DC == 2 || dword_80567DC == 3) )
          putchar_unlocked((char)a3);
      }
      if ( v21 || dword_80567DC )
      {
        fwrite_unlocked(*((const void **)s + 2), 1u, *((_DWORD *)s + 1), stdout);
        v16 = v23;
        v23 = s;
        s = v16;
        s2 = v26;
        v25 = n;
        v20 = 1;
      }
    }
    if ( (dword_80567DC == 4 || dword_80567DC == 2) && v20 )
      putchar_unlocked((char)a3);
  }
  else
  {
    _ZF = sub_804C2D0((int)&v30, stdin, (char)a3) == 0;
    v17 = &loc_804AF6F;
    if ( !_ZF )
      v17 = &loc_804AF74;
    dword_8056170 = (int)v17;
    sub_80507F4();
  }
  if ( ferror_unlocked(stdin) || sub_804F3D2(stdin) )
  {
    v18 = sub_804DEB4(4, (int)s1);
    v19 = gettext("error reading %s");
    error(1, 0, v19, v18);
  }
  free(ptr);
  free(v31);
}
// 8050548: using guessed type int sub_8050548(void);
// 8050696: using guessed type int sub_8050696(void);
// 80507F4: using guessed type int sub_80507F4(void);
// 80508DA: using guessed type int sub_80508DA(void);
// 8056148: using guessed type int dword_8056148;
// 8056170: using guessed type int dword_8056170;
// 80561AC: using guessed type int dword_80561AC;
// 80561E8: using guessed type int dword_80561E8;
// 80567D0: using guessed type int dword_80567D0;
// 80567D4: using guessed type char byte_80567D4;
// 80567D5: using guessed type char byte_80567D5;
// 80567DC: using guessed type int dword_80567DC;

//----- (0804B236) --------------------------------------------------------
int __cdecl main(int argc, char **argv)
{
  bool v2; // ST2F_1
  void *v4; // eax
  void *v5; // eax
  char *v6; // eax
  void *v7; // eax
  char *v8; // eax
  int result; // eax

  v2 = getenv("POSIXLY_CORRECT") != 0;
  sub_804C534(*argv);
  setlocale(6, &s);
  bindtextdomain("coreutils", "/home/hwangdz/coreutils/coreutils-8.28/install_m32/share/locale");
  textdomain("coreutils");
  byte_80567C0 = sub_804C219(3);
  sub_805036C((int)sub_804BE2D);
  dword_80567C8 = 0;
  dword_80567C4 = 0;
  dword_80567CC = -1;
  byte_80567D5 = 1;
  byte_80567D4 = 1;
  byte_80567D6 = 0;
  dword_80567D0 = 1;
  dword_80567D8 = 0;
  _ZF = getopt_long(argc, argv, "-0123456789Dcdf:is:uw:z", &longopts, 0) == -1;
  v4 = &loc_804B3A6;
  if ( !_ZF )
    v4 = &loc_804B47D;
  dword_8056210 = (int)v4;
  sub_805044F();
  v5 = &loc_804B3C9;
  if ( argc > optind )
    v5 = &loc_804B3DB;
  dword_8056170 = (int)v5;
  sub_80507F4();
  if ( dword_80567DC && dword_80567D0 != 1 )
  {
    v6 = gettext("grouping and printing repeat counts is meaningless");
    error(0, 0, v6);
    sub_804A697(1);
  }
  v7 = &loc_804B997;
  if ( dword_80567D0 )
    v7 = &loc_804B9D2;
  dword_80561D4 = (int)v7;
  sub_80505B6();
  if ( byte_80567D6 )
  {
    v8 = gettext("printing all duplicated lines and repeat counts is meaningless");
    error(0, 0, v8);
    sub_804A697(1);
  }
  sub_804ABF4("-", "-", 10);
  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}
// 805044F: using guessed type int sub_805044F(void);
// 80505B6: using guessed type int sub_80505B6(void);
// 80507F4: using guessed type int sub_80507F4(void);
// 8056170: using guessed type int dword_8056170;
// 80561D4: using guessed type int dword_80561D4;
// 8056210: using guessed type int dword_8056210;
// 80562C0: using guessed type int optind;
// 80567C0: using guessed type char byte_80567C0;
// 80567C4: using guessed type int dword_80567C4;
// 80567C8: using guessed type int dword_80567C8;
// 80567CC: using guessed type int dword_80567CC;
// 80567D0: using guessed type int dword_80567D0;
// 80567D4: using guessed type char byte_80567D4;
// 80567D5: using guessed type char byte_80567D5;
// 80567D6: using guessed type char byte_80567D6;
// 80567D8: using guessed type int dword_80567D8;
// 80567DC: using guessed type int dword_80567DC;

//----- (0804B9FA) --------------------------------------------------------
void __noreturn sub_804B9FA()
{
  sub_804A697(1);
}

//----- (0804BA0E) --------------------------------------------------------
int __cdecl sub_804BA0E(char *s, int a2)
{
  size_t v2; // eax
  void *v4; // eax
  void *v5; // eax
  const char *v6; // [esp+0h] [ebp-28h]
  char v7; // [esp+13h] [ebp-15h]
  int v8; // [esp+14h] [ebp-14h]
  int v9; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]

  v9 = -1;
  v7 = 0;
  n = strlen(s);
  v8 = 0;
  dword_80561FC = (int)&loc_804BB19;
  sub_80504C1();
  do
  {
    if ( !strncmp(*(const char **)(4 * v8 + a2), s, n) )
    {
      v6 = *(const char **)(4 * v8 + a2);
      v2 = strlen(v6);
      if ( v2 == n )
        return v8;
      v4 = &loc_804BACF;
      if ( v9 != -1 )
        v4 = &loc_804BAD7;
      dword_80561D4 = (int)v4;
      sub_80505B6();
      v9 = v8;
    }
    ++v8;
  }
  while ( *(_DWORD *)(4 * v8 + a2) );
  v5 = &loc_804BB51;
  if ( !v7 )
    v5 = &loc_804BB58;
  dword_80561FC = (int)v5;
  sub_80504C1();
  return -2;
}
// 804BA0E: could not find valid save-restore pair for ebx
// 80504C1: using guessed type int sub_80504C1(void);
// 80505B6: using guessed type int sub_80505B6(void);
// 80561D4: using guessed type int dword_80561D4;
// 80561FC: using guessed type int dword_80561FC;

//----- (0804BB5D) --------------------------------------------------------
void __cdecl sub_804BB5D(int a1, int a2, int a3)
{
  int *v3; // ebp
  void *v4; // ebx
  void *v5; // eax
  int v6; // [esp+0h] [ebp-38h]
  int v7; // [esp+4h] [ebp-34h]
  void *v8; // [esp+Ch] [ebp-2Ch]
  void *v9; // [esp+10h] [ebp-28h]
  int savedregs; // [esp+38h] [ebp+0h]

  v3 = &savedregs;
  if ( a3 == -1 )
  {
    gettext("invalid argument %s for %s");
    dword_80561C0 = (int)&loc_804BB99;
    sub_8050624();
    v3 = &v6;
  }
  *(v3 - 3) = (int)gettext("ambiguous argument %s for %s");
  v7 = v3[2];
  v4 = sub_804E287(1, v7);
  v5 = sub_804DE27(0, 8, v3[3]);
  v9 = v4;
  v8 = v5;
  error(0, 0, (const char *)*(v3 - 3), v5, v4);
}
// 8050624: using guessed type int sub_8050624(void);
// 80561C0: using guessed type int dword_80561C0;

//----- (0804BC03) --------------------------------------------------------
int __cdecl sub_804BC03(int a1, int a2, size_t n)
{
  FILE *v3; // ebx
  char *v4; // eax
  void *v5; // eax
  void *v6; // eax
  int i; // [esp+18h] [ebp-10h]
  void *s1; // [esp+1Ch] [ebp-Ch]

  s1 = 0;
  v3 = stderr;
  v4 = gettext("Valid arguments are:");
  fputs_unlocked(v4, v3);
  for ( i = 0; *(_DWORD *)(4 * i + a1); ++i )
  {
    if ( i && !memcmp(s1, (const void *)(a2 + i * n), n) )
    {
      v6 = sub_804E2AD(*(_DWORD *)(4 * i + a1));
      fprintf(stderr, ", %s", v6);
    }
    else
    {
      v5 = sub_804E2AD(*(_DWORD *)(4 * i + a1));
      fprintf(stderr, "\n  - %s", v5);
      s1 = (void *)(i * n + a2);
    }
  }
  return putc_unlocked(10, stderr);
}
// 8048F80: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804BD1A) --------------------------------------------------------
int __cdecl sub_804BD1A(int a1, char *s, int a3, int a4, size_t n, int a6)
{
  int v7; // [esp+1Ch] [ebp-Ch]

  v7 = sub_804BA0E(s, a3);
  if ( v7 >= 0 )
    return v7;
  sub_804BB5D(a1, (int)s, v7);
  sub_804BC03(a3, a4, n);
  ((void (*)(void))a6)();
  return -1;
}

//----- (0804BE2D) --------------------------------------------------------
int sub_804BE2D()
{
  void *v0; // ebx
  int *v1; // eax
  int *v2; // eax
  int result; // eax
  char *v4; // [esp+2Ch] [ebp-Ch]

  if ( sub_804F753(stdout) && (byte_80567E4 != 1 || *__errno_location() != 32) )
  {
    v4 = gettext("write error");
    if ( dword_80567E0 )
    {
      v0 = sub_804DFFE(dword_80567E0);
      v1 = __errno_location();
      error(0, *v1, "%s: %s", v0, v4);
    }
    else
    {
      v2 = __errno_location();
      error(0, *v2, "%s", v4);
    }
    _exit(status);
  }
  result = sub_804F753(stderr);
  if ( result )
    _exit(status);
  return result;
}
// 80567E0: using guessed type int dword_80567E0;
// 80567E4: using guessed type char byte_80567E4;

//----- (0804BF1F) --------------------------------------------------------
int __cdecl sub_804BF1F(int a1, int a2, int a3, int a4, int a5, int a6)
{
  return posix_fadvise64(a1, a2, a3, a4, a5, a6);
}
// 80490B0: using guessed type int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804BF70) --------------------------------------------------------
void __cdecl sub_804BF70(FILE *stream, int a2)
{
  int v2; // eax

  if ( stream )
  {
    v2 = fileno(stream);
    sub_804BF1F(v2, 0, 0, 0, 0, a2);
  }
}

//----- (0804BFD6) --------------------------------------------------------
int __cdecl sub_804BFD6(int a1)
{
  int v1; // eax
  void *v2; // eax
  int result; // eax
  int fd; // [esp+1Ch] [ebp-Ch]

  v1 = open64("/dev/null", 0);
  fd = v1;
  _ZF = v1 == a1;
  v2 = &loc_804C018;
  if ( _ZF )
    v2 = &loc_804C03C;
  dword_80561E8 = (int)v2;
  sub_8050548();
  _CF = 0;
  _OF = 0;
  _ZF = fd == 0;
  _SF = fd < 0;
  if ( fd >= 0 )
  {
    close(fd);
    *__errno_location() = 9;
  }
  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}
// 8048D90: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 8050548: using guessed type int sub_8050548(void);
// 80561E8: using guessed type int dword_80561E8;

//----- (0804C043) --------------------------------------------------------
FILE *__cdecl sub_804C043(int a1, int a2, FILE *stream)
{
  int v3; // eax
  bool v4; // zf
  void *v5; // eax
  void *v6; // eax
  void *v7; // eax
  char v9; // [esp+19h] [ebp-Fh]
  char v10; // [esp+1Ah] [ebp-Eh]
  char v11; // [esp+1Bh] [ebp-Dh]
  int v12; // [esp+1Ch] [ebp-Ch]
  FILE *streama; // [esp+38h] [ebp+10h]

  v9 = 0;
  v10 = 0;
  v11 = 0;
  v3 = fileno(stream);
  if ( v3 != 1 )
  {
    if ( v3 != 2 )
    {
      if ( !v3 )
        goto LABEL_11;
      if ( dup2(2, 2) != 2 )
        v11 = 1;
    }
    if ( dup2(1, 1) != 1 )
      v10 = 1;
  }
  v4 = dup2(0, 0) == 0;
  v5 = &loc_804C0DD;
  if ( v4 )
    v5 = &loc_804C0E3;
  dword_8056170 = (int)v5;
  sub_80507F4();
  v9 = 1;
LABEL_11:
  if ( v9 )
  {
    v4 = (unsigned __int8)sub_804BFD6(0) == 1;
    v6 = &loc_804C115;
    if ( v4 )
      v6 = &loc_804C121;
    dword_805615C = (int)v6;
    sub_8050866();
    streama = 0;
  }
  else
  {
    if ( v10 && (unsigned __int8)sub_804BFD6(1) ^ 1 )
    {
      stream = 0;
      dword_8056170 = (int)&loc_804C1AB;
      sub_80507F4();
    }
    if ( v11 && (unsigned __int8)sub_804BFD6(2) ^ 1 )
    {
      stream = 0;
      dword_8056120 = (int)&loc_804C1AB;
      sub_80509C0();
    }
    streama = (FILE *)freopen64(a1, a2, stream);
  }
  v12 = *__errno_location();
  v7 = &loc_804C1D4;
  if ( !v11 )
    v7 = &loc_804C1E0;
  dword_80561C0 = (int)v7;
  sub_8050624();
  close(2);
  if ( v10 )
    close(1);
  if ( v9 )
    close(0);
  if ( !streama )
    *__errno_location() = v12;
  return streama;
}
// 804C043: could not find valid save-restore pair for ebx
// 8048D60: using guessed type int __cdecl freopen64(_DWORD, _DWORD, _DWORD);
// 8050624: using guessed type int sub_8050624(void);
// 80507F4: using guessed type int sub_80507F4(void);
// 8050866: using guessed type int sub_8050866(void);
// 80509C0: using guessed type int sub_80509C0(void);
// 8056120: using guessed type int dword_8056120;
// 805615C: using guessed type int dword_805615C;
// 8056170: using guessed type int dword_8056170;
// 80561C0: using guessed type int dword_80561C0;

//----- (0804C219) --------------------------------------------------------
int __cdecl sub_804C219(int category)
{
  unsigned __int8 v2; // [esp+1Bh] [ebp-Dh]
  const char *s1; // [esp+1Ch] [ebp-Ch]

  v2 = 1;
  s1 = setlocale(category, 0);
  if ( s1 && (!strcmp(s1, "C") || !strcmp(s1, "POSIX")) )
    v2 = 0;
  return v2;
}

//----- (0804C287) --------------------------------------------------------
void *__cdecl sub_804C287(void *s)
{
  return memset(s, 0, 0xCu);
}

//----- (0804C2D0) --------------------------------------------------------
int __cdecl sub_804C2D0(int a1, FILE *stream, int a3)
{
  int v7; // eax
  int result; // eax
  char *v9; // eax
  void *v10; // eax
  char v11; // [esp+Ch] [ebp-2Ch]
  int v12; // [esp+1Ch] [ebp-1Ch]
  void *ptr; // [esp+20h] [ebp-18h]
  char *v14; // [esp+24h] [ebp-14h]
  char *v15; // [esp+28h] [ebp-10h]
  int v16; // [esp+2Ch] [ebp-Ch]

  v11 = a3;
  ptr = *(void **)(a1 + 8);
  v14 = *(char **)(a1 + 8);
  v15 = (char *)ptr + *(_DWORD *)a1;
  if ( feof_unlocked(stream) )
  {
    dword_80561AC = (int)&locret_804C403;
    sub_8050696();
  }
  v12 = getc_unlocked(stream);
  if ( v12 != -1 )
    goto LABEL_9;
  _CF = v14 < ptr;
  _OF = __OFSUB__(v14, ptr);
  _ZF = v14 == ptr;
  _SF = v14 - (_BYTE *)ptr < 0;
  if ( v14 == ptr || (v7 = ferror_unlocked(stream), _CF = 0, _OF = 0, _ZF = v7 == 0, _SF = v7 < 0, v7) )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
    return result;
  }
  if ( *(v14 - 1) != v11 )
  {
    v12 = v11;
LABEL_9:
    if ( v14 == v15 )
    {
      v16 = *(_DWORD *)a1;
      ptr = sub_804EB61(ptr, a1);
      v14 = (char *)ptr + v16;
      *(_DWORD *)(a1 + 8) = ptr;
      v15 = (char *)ptr + *(_DWORD *)a1;
    }
    v9 = v14++;
    *v9 = v12;
    v10 = &loc_804C3EA;
    if ( v11 != v12 )
      v10 = &loc_804C327;
    dword_805615C = (int)v10;
    sub_8050866();
  }
  *(_DWORD *)(a1 + 4) = v14 - (_BYTE *)ptr;
  return a1;
}
// 8050696: using guessed type int sub_8050696(void);
// 8050866: using guessed type int sub_8050866(void);
// 805615C: using guessed type int dword_805615C;
// 80561AC: using guessed type int dword_80561AC;

//----- (0804C41B) --------------------------------------------------------
int __cdecl sub_804C41B(int a1, int a2, unsigned int a3)
{
  unsigned __int8 v3; // ST1B_1
  int result; // eax
  unsigned int i; // [esp+18h] [ebp-20h]
  int v10; // [esp+24h] [ebp-14h]
  int v11; // [esp+28h] [ebp-10h]

  for ( i = 0; ; ++i )
  {
    _CF = i < a3;
    _OF = __OFSUB__(i, a3);
    _ZF = i == a3;
    _SF = (signed int)(i - a3) < 0;
    if ( i >= a3 )
      break;
    v3 = *(_BYTE *)(a2 + i);
    v10 = toupper(*(unsigned __int8 *)(a1 + i));
    v11 = toupper(v3);
    if ( v10 != v11 )
      return v10 - v11;
  }
  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}

//----- (0804C4A0) --------------------------------------------------------
int sub_804C4A0()
{
  void *v0; // eax
  void *v1; // eax
  char *endptr; // [esp+10h] [ebp-18h]
  int v4; // [esp+14h] [ebp-14h]
  char *nptr; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]

  v4 = 200809;
  nptr = getenv("_POSIX2_VERSION");
  if ( nptr )
  {
    v0 = &loc_804C4E5;
    if ( !*nptr )
      v0 = &loc_804C52F;
    dword_8056184 = (int)v0;
    sub_805077E();
    v6 = strtol(nptr, &endptr, 10);
    v1 = &loc_804C529;
    if ( *endptr )
      v1 = &loc_804C52F;
    dword_80561C0 = (int)v1;
    sub_8050624();
    v4 = v6;
  }
  return v4;
}
// 804C4A0: could not find valid save-restore pair for ebx
// 8050624: using guessed type int sub_8050624(void);
// 805077E: using guessed type int sub_805077E(void);
// 8056184: using guessed type int dword_8056184;
// 80561C0: using guessed type int dword_80561C0;

//----- (0804C534) --------------------------------------------------------
char *__cdecl sub_804C534(char *s)
{
  char *v1; // eax
  char *result; // eax
  char *v3; // [esp+18h] [ebp-10h]
  char *s1; // [esp+1Ch] [ebp-Ch]

  if ( !s )
  {
    fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
    abort();
  }
  v3 = strrchr(s, 47);
  if ( v3 )
    v1 = v3 + 1;
  else
    v1 = s;
  s1 = v1;
  if ( v1 - s > 6 && !strncmp(v1 - 7, "/.libs/", 7u) )
  {
    s = s1;
    if ( !strncmp(s1, "lt-", 3u) )
    {
      s = s1 + 3;
      program_invocation_short_name = (int)(s1 + 3);
    }
  }
  dword_80567E8 = (int)s;
  result = s;
  program_invocation_name = (int)s;
  return result;
}
// 80562A0: using guessed type int program_invocation_short_name;
// 80562B0: using guessed type int program_invocation_name;
// 80567E8: using guessed type int dword_80567E8;

//----- (0804C699) --------------------------------------------------------
int __cdecl sub_804C699(int *a1, unsigned __int8 a2, char a3)
{
  int *v3; // eax
  int v4; // ST10_4

  if ( a1 )
    v3 = a1;
  else
    v3 = &dword_80567F0;
  v4 = ((unsigned int)v3[(a2 >> 5) + 2] >> (a2 & 0x1F)) & 1;
  v3[(a2 >> 5) + 2] ^= (v4 ^ a3 & 1) << (a2 & 0x1F);
  return v4;
}
// 80567F0: using guessed type int dword_80567F0;

//----- (0804C760) --------------------------------------------------------
void __cdecl __noreturn sub_804C760(int a1, int a2, int a3)
{
  void *v3; // eax
  int (*v4)(); // eax

  v3 = &loc_804C785;
  if ( a1 )
    v3 = &loc_804C78C;
  dword_80561FC = (int)v3;
  sub_80504C1();
  dword_80567F0 = 10;
  if ( a2 )
  {
    v4 = (int (*)())&loc_804C7BA;
    if ( a3 )
      v4 = sub_804C7BF;
    dword_8056120 = (int)v4;
    sub_80509C0();
  }
  abort();
}
// 804C7BF: using guessed type int sub_804C7BF();
// 80504C1: using guessed type int sub_80504C1(void);
// 80509C0: using guessed type int sub_80509C0(void);
// 8056120: using guessed type int dword_8056120;
// 80561FC: using guessed type int dword_80561FC;
// 80567F0: using guessed type int dword_80567F0;

//----- (0804C7BF) --------------------------------------------------------
#error "804C7D2: positive sp value has been found (funcsize=0)"

//----- (0804C7D3) --------------------------------------------------------
_DWORD *__userpurge sub_804C7D3@<eax>(_DWORD *a1, int a2)
{
  int v3; // [esp+0h] [ebp-38h]
  int v4; // [esp+4h] [ebp-34h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]

  memset(&v3, 0, 0x30u);
  if ( a2 == 10 )
    abort();
  *a1 = a2;
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = v6;
  a1[4] = v7;
  a1[5] = v8;
  a1[6] = v9;
  a1[7] = v10;
  a1[8] = v11;
  a1[9] = v12;
  a1[10] = v13;
  a1[11] = v14;
  return a1;
}

//----- (0804C866) --------------------------------------------------------
void *__cdecl sub_804C866(int a1, const char *a2)
{
  char **v2; // ebp
  bool v3; // zf
  void *v4; // eax
  void *result; // eax
  int v6; // [esp+0h] [ebp-2Ch]
  char *msgid; // [esp+4h] [ebp-28h]
  const char *v8; // [esp+8h] [ebp-24h]
  char *v9; // [esp+1Ch] [ebp-10h]
  void *retaddr; // [esp+2Ch] [ebp+0h]

  v2 = (char **)&retaddr;
  v9 = gettext(a2);
  if ( v9 != a2 )
  {
    dword_8056198 = (int)&locret_804C93D;
    sub_805070A();
    v2 = &msgid;
  }
  *(v2 - 3) = sub_804FD41();
  v8 = "UTF-8";
  msgid = *(v2 - 3);
  if ( sub_804F6E9((unsigned __int8 *)msgid, "UTF-8") )
  {
    v8 = "GB18030";
    msgid = *(v2 - 3);
    if ( sub_804F6E9((unsigned __int8 *)msgid, "GB18030") )
    {
      if ( v2[3] == (char *)9 )
        result = &unk_80518BD;
      else
        result = &unk_80518BF;
    }
    else if ( *v2[2] == 96 )
    {
      result = &unk_80518B6;
    }
    else
    {
      result = &unk_80518BA;
    }
  }
  else
  {
    v3 = *v2[2] == 96;
    v6 = (unsigned __int8)*v2[2];
    v4 = &loc_804C8EE;
    if ( !v3 )
      v4 = &loc_804C8F5;
    dword_805615C = (int)v4;
    sub_8050866();
    result = &unk_80518A6;
  }
  return result;
}
// 805070A: using guessed type int sub_805070A(void);
// 8050866: using guessed type int sub_8050866(void);
// 805615C: using guessed type int dword_805615C;
// 8056198: using guessed type int dword_8056198;

//----- (0804C93F) --------------------------------------------------------
void __cdecl sub_804C93F(int a1, int a2, int a3, int a4, unsigned int a5)
{
  bool v5; // ST53_1

  v5 = __ctype_get_mb_cur_max() == 1;
  if ( a5 <= 0xA )
    JUMPOUT(__CS__, off_80518C4[a5]);
  abort();
}

//----- (0804CE38) --------------------------------------------------------
void __usercall sub_804CE38(int a1@<ebp>)
{
  *(_BYTE *)(a1 - 67) = *(_BYTE *)(*(_DWORD *)(a1 - 56) + 2 + *(_DWORD *)(a1 - 80));
  *(_DWORD *)(a1 - 56) += 2;
  if ( *(_DWORD *)(a1 - 52) < *(_DWORD *)(a1 + 12) )
    *(_BYTE *)(*(_DWORD *)(a1 - 76) + *(_DWORD *)(a1 - 52)) = 63;
  if ( ++*(_DWORD *)(a1 - 52) < *(_DWORD *)(a1 + 12) )
    *(_BYTE *)(*(_DWORD *)(a1 - 76) + *(_DWORD *)(a1 - 52)) = 34;
  if ( ++*(_DWORD *)(a1 - 52) < *(_DWORD *)(a1 + 12) )
    *(_BYTE *)(*(_DWORD *)(a1 - 76) + *(_DWORD *)(a1 - 52)) = 34;
  if ( ++*(_DWORD *)(a1 - 52) < *(_DWORD *)(a1 + 12) )
    *(_BYTE *)(*(_DWORD *)(a1 - 76) + *(_DWORD *)(a1 - 52)) = 63;
  ++*(_DWORD *)(a1 - 52);
  JUMPOUT(&loc_804CEAB);
}

//----- (0804D08B) --------------------------------------------------------
int __usercall sub_804D08B@<eax>(int a1@<ebx>, int a2@<ebp>, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, void *a17, char a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42)
{
  void *v42; // eax

  v42 = &loc_804D0AA;
  if ( !*(_DWORD *)(a2 + 12) )
    v42 = &loc_804D0BD;
  dword_80561FC = (int)v42;
  sub_80504C1();
  if ( !*(_DWORD *)(a2 - 48) )
  {
    *(_DWORD *)(a2 - 48) = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a2 + 12) = 0;
  }
  if ( *(_DWORD *)(a2 - 52) < *(_DWORD *)(a2 + 12) )
    *(_BYTE *)(*(_DWORD *)(a2 - 76) + *(_DWORD *)(a2 - 52)) = 39;
  if ( ++*(_DWORD *)(a2 - 52) < *(_DWORD *)(a2 + 12) )
    *(_BYTE *)(*(_DWORD *)(a2 - 76) + *(_DWORD *)(a2 - 52)) = 92;
  if ( ++*(_DWORD *)(a2 - 52) < *(_DWORD *)(a2 + 12) )
    *(_BYTE *)(*(_DWORD *)(a2 - 76) + *(_DWORD *)(a2 - 52)) = 39;
  ++*(_DWORD *)(a2 - 52);
  *(_BYTE *)(a2 - 70) = 0;
  return sub_804D4CD(
           a1,
           (void **)a2,
           a3,
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30,
           a31,
           a32,
           a33,
           a34,
           a35,
           a36,
           a37,
           a38,
           a39,
           a40,
           a41,
           a42);
}
// 80504C1: using guessed type int sub_80504C1(void);
// 80561FC: using guessed type int dword_80561FC;

//----- (0804D1F6) --------------------------------------------------------
void __usercall sub_804D1F6(int a1@<ebp>)
{
  int (*v1)(); // eax

  v1 = (int (*)())&loc_804D215;
  if ( *(_DWORD *)(a1 - 28) != -1 )
    v1 = sub_804D21E;
  dword_805615C = (int)v1;
  sub_8050866();
  *(_BYTE *)(a1 - 62) = 0;
  JUMPOUT(&loc_804D2FA);
}
// 804D21E: using guessed type int sub_804D21E();
// 8050866: using guessed type int sub_8050866(void);
// 805615C: using guessed type int dword_805615C;

//----- (0804D21E) --------------------------------------------------------
#error "804D2BD: call analysis failed (funcsize=117)"

//----- (0804D4CD) --------------------------------------------------------
int __usercall sub_804D4CD@<eax>(int a1@<ebx>, void **a2@<ebp>, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, void *a17, char a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42)
{
  bool v42; // zf
  void *v43; // eax
  void *v44; // eax
  int v45; // eax
  void (__usercall *v46)(int@<ebp>); // eax
  void *v47; // eax
  int (*v48)(); // eax
  int v50; // [esp-8Ch] [ebp-8Ch]
  int v51; // [esp-88h] [ebp-88h]
  int v52; // [esp-84h] [ebp-84h]
  int v53; // [esp-80h] [ebp-80h]
  unsigned int v54; // [esp-7Ch] [ebp-7Ch]
  int v55; // [esp-8h] [ebp-8h]
  int v56; // [esp-4h] [ebp-4h]
  void *retaddr; // [esp+0h] [ebp+0h]

  if ( *((_BYTE *)a2 - 72) == 1 )
  {
    v42 = a2[6] == (void *)2;
    v56 = *((unsigned __int8 *)a2 - 72) ^ 1;
    v55 = a1;
    v43 = &loc_804D4F7;
    if ( !v42 )
      v43 = &loc_804D502;
    dword_8056170 = (int)v43;
    a1 = v55;
    sub_80507F4();
  }
  if ( *((_BYTE *)a2 - 71) != 1 )
    goto LABEL_22;
  v42 = *(a2 - 21) == 0;
  v56 = *((unsigned __int8 *)a2 - 71) ^ 1;
  v55 = a1;
  v44 = &loc_804D521;
  if ( v42 )
    v44 = &loc_804D54D;
  dword_80561E8 = (int)v44;
  a1 = v55;
  sub_8050548();
  v45 = (*((_DWORD *)*(a2 - 21) + (unsigned __int8)(*((_BYTE *)a2 - 67) >> 5)) >> (*((_BYTE *)a2 - 67) & 0x1F)) & 1;
  if ( !v45 )
  {
LABEL_22:
    v45 = *((unsigned __int8 *)a2 - 65) ^ 1;
    if ( *((_BYTE *)a2 - 65) != 1 )
    {
      dword_8056198 = (int)&loc_804D608;
      v45 = sub_805070A();
      a2 = &retaddr;
    }
  }
  v42 = *((_BYTE *)a2 - 71) == 0;
  v56 = v45;
  v55 = a1;
  v46 = (void (__usercall *)(int@<ebp>))&loc_804D58E;
  if ( v42 )
    v46 = sub_804D593;
  dword_8056120 = (int)v46;
  sub_80509C0();
  if ( a42 == 2 )
  {
    v47 = &loc_804D850;
    if ( !a18 )
      v47 = &loc_804D857;
    dword_8056210 = (int)v47;
    sub_805044F();
  }
  retaddr = a17;
  sub_804C93F(v50, v51, v52, v53, v54);
  v48 = (int (*)())&loc_804D8C5;
  if ( __readgsdword(0x14u) == a33 )
    v48 = sub_804D8CA;
  dword_8056148 = (int)v48;
  return sub_80508DA();
}
// 804D4CD: could not find valid save-restore pair for ebx
// 804D8CA: using guessed type int sub_804D8CA();
// 805044F: using guessed type int sub_805044F(void);
// 8050548: using guessed type int sub_8050548(void);
// 805070A: using guessed type int sub_805070A(void);
// 80507F4: using guessed type int sub_80507F4(void);
// 80508DA: using guessed type int sub_80508DA(void);
// 80509C0: using guessed type int sub_80509C0(void);
// 8056120: using guessed type int dword_8056120;
// 8056148: using guessed type int dword_8056148;
// 8056170: using guessed type int dword_8056170;
// 8056198: using guessed type int dword_8056198;
// 80561E8: using guessed type int dword_80561E8;
// 8056210: using guessed type int dword_8056210;

//----- (0804D593) --------------------------------------------------------
void __usercall sub_804D593(int a1@<ebp>)
{
  *(_BYTE *)(a1 - 64) = 1;
  if ( *(_DWORD *)(a1 + 24) == 2 && *(_BYTE *)(a1 - 70) != 1 )
  {
    if ( *(_DWORD *)(a1 - 52) < *(_DWORD *)(a1 + 12) )
      *(_BYTE *)(*(_DWORD *)(a1 - 76) + *(_DWORD *)(a1 - 52)) = 39;
    if ( ++*(_DWORD *)(a1 - 52) < *(_DWORD *)(a1 + 12) )
      *(_BYTE *)(*(_DWORD *)(a1 - 76) + *(_DWORD *)(a1 - 52)) = 36;
    if ( ++*(_DWORD *)(a1 - 52) < *(_DWORD *)(a1 + 12) )
      *(_BYTE *)(*(_DWORD *)(a1 - 76) + *(_DWORD *)(a1 - 52)) = 39;
    ++*(_DWORD *)(a1 - 52);
    *(_BYTE *)(a1 - 70) = 1;
  }
  if ( *(_DWORD *)(a1 - 52) < *(_DWORD *)(a1 + 12) )
    *(_BYTE *)(*(_DWORD *)(a1 - 76) + *(_DWORD *)(a1 - 52)) = 92;
  ++*(_DWORD *)(a1 - 52);
  JUMPOUT(loc_804D608);
}

//----- (0804D78A) --------------------------------------------------------
void __usercall sub_804D78A(int a1@<ebp>, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24)
{
  if ( !*(_DWORD *)(a1 + 12) && *(_DWORD *)(a1 - 48) )
  {
    *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 - 48);
    *(_DWORD *)(a1 - 52) = 0;
    JUMPOUT(&loc_804C9B8);
  }
  JUMPOUT(a24, 0, &loc_804D7FE);
  JUMPOUT(HIBYTE(a17), 1, &loc_804D7FE);
  JUMPOUT(&loc_804D7DB);
}

//----- (0804D7BB) --------------------------------------------------------
void __usercall sub_804D7BB(int a1@<ebp>)
{
  if ( *(_DWORD *)(a1 - 52) < *(_DWORD *)(a1 + 12) )
    *(_BYTE *)(*(_DWORD *)(a1 - 52) + *(_DWORD *)(a1 - 76)) = **(_BYTE **)(a1 - 44);
  ++*(_DWORD *)(a1 - 52);
  ++*(_DWORD *)(a1 - 44);
  JUMPOUT(loc_804D7DB);
}

//----- (0804D8CA) --------------------------------------------------------
#error "804D8CD: positive sp value has been found (funcsize=0)"

//----- (0804D987) --------------------------------------------------------
void *__cdecl sub_804D987(int a1, int a2, _DWORD *a3, int *a4)
{
  int *v4; // eax
  unsigned int *v5; // ST3C_4
  int v6; // ST40_4
  int v7; // ST44_4
  unsigned int v8; // ST20_4
  unsigned int v9; // ST1C_4
  int v10; // eax
  unsigned int v11; // ST20_4
  unsigned int v12; // ST1C_4
  int v14; // [esp+48h] [ebp-10h]
  void *v15; // [esp+4Ch] [ebp-Ch]

  if ( a4 )
    v4 = a4;
  else
    v4 = &dword_80567F0;
  v5 = (unsigned int *)v4;
  v6 = *__errno_location();
  v7 = v5[1] | (a3 == 0);
  v8 = v5[11];
  v9 = v5[10];
  sub_804C93F(0, 0, a1, a2, *v5);
  v14 = v10 + 1;
  v15 = sub_804EAA6(v10 + 1);
  v11 = v5[11];
  v12 = v5[10];
  sub_804C93F((int)v15, v14, a1, a2, *v5);
  *__errno_location() = v6;
  if ( a3 )
    *a3 = v14 - 1;
  return v15;
}
// 80567F0: using guessed type int dword_80567F0;

//----- (0804DB4B) --------------------------------------------------------
void *__cdecl sub_804DB4B(signed int a1, int a2, int a3, unsigned int *a4)
{
  int *v8; // eax
  void *v9; // edx
  unsigned int v10; // ST48_4
  int v11; // ST4C_4
  unsigned int v12; // ST24_4
  unsigned int v13; // ST20_4
  unsigned int v14; // eax
  unsigned int v15; // ST24_4
  unsigned int v16; // ST20_4
  bool v18; // [esp+37h] [ebp-21h]
  int *v19; // [esp+38h] [ebp-20h]
  void *ptr; // [esp+3Ch] [ebp-1Ch]
  int v21; // [esp+40h] [ebp-18h]
  int v22; // [esp+44h] [ebp-14h]

  v21 = *__errno_location();
  v19 = off_805625C;
  if ( a1 < 0 )
    abort();
  if ( dword_8056250 <= a1 )
  {
    v18 = off_805625C == &dword_8056254;
    if ( (unsigned int)a1 > 0xFFFFFFE )
      sub_804EC5A();
    _CF = 0;
    _OF = 0;
    _ZF = off_805625C != &dword_8056254;
    _SF = v18 < 0;
    if ( v18 )
    {
      __asm { pushfw }
      v8 = 0;
      __asm { popfw }
    }
    else
    {
      v8 = off_805625C;
    }
    v19 = (int *)sub_804EB05(v8, 8 * (a1 + 1));
    off_805625C = v19;
    if ( v18 )
    {
      v9 = off_8056258;
      *v19 = dword_8056254;
      v19[1] = (int)v9;
    }
    memset(&v19[2 * dword_8056250], 0, 8 * (a1 + 1 - dword_8056250));
    dword_8056250 = a1 + 1;
  }
  v10 = v19[2 * a1];
  ptr = (void *)v19[2 * a1 + 1];
  v11 = a4[1] | 1;
  v12 = a4[11];
  v13 = a4[10];
  sub_804C93F(v19[2 * a1 + 1], v19[2 * a1], a2, a3, *a4);
  if ( v10 <= v14 )
  {
    v22 = v14 + 1;
    v19[2 * a1] = v14 + 1;
    if ( ptr != &unk_8056830 )
      free(ptr);
    ptr = sub_804EAA6(v22);
    v19[2 * a1 + 1] = (int)ptr;
    v15 = a4[11];
    v16 = a4[10];
    sub_804C93F((int)ptr, v22, a2, a3, *a4);
  }
  *__errno_location() = v21;
  return ptr;
}
// 8056250: using guessed type int dword_8056250;
// 8056254: using guessed type int dword_8056254;
// 8056258: using guessed type void *off_8056258;
// 805625C: using guessed type int *off_805625C;

//----- (0804DD85) --------------------------------------------------------
void *__cdecl sub_804DD85(signed int a1, int a2)
{
  return sub_804DB4B(a1, a2, -1, (unsigned int *)&dword_80567F0);
}
// 80567F0: using guessed type int dword_80567F0;

//----- (0804DDAF) --------------------------------------------------------
void *__cdecl sub_804DDAF(signed int a1, int a2, int a3)
{
  return sub_804DB4B(a1, a2, a3, (unsigned int *)&dword_80567F0);
}
// 80567F0: using guessed type int dword_80567F0;

//----- (0804DE27) --------------------------------------------------------
void *__cdecl sub_804DE27(signed int a1, int a2, int a3)
{
  unsigned int v4[14]; // [esp+10h] [ebp-38h]

  sub_804C7D3(v4, a2);
  return sub_804DB4B(a1, a3, -1, v4);
}

//----- (0804DE77) --------------------------------------------------------
void *__cdecl sub_804DE77(signed int a1, int a2, int a3, int a4)
{
  unsigned int v5[14]; // [esp+10h] [ebp-38h]

  sub_804C7D3(v5, a2);
  return sub_804DB4B(a1, a3, a4, v5);
}

//----- (0804DEB4) --------------------------------------------------------
void *__cdecl sub_804DEB4(int a1, int a2)
{
  return sub_804DE27(0, a1, a2);
}

//----- (0804DF07) --------------------------------------------------------
void *__cdecl sub_804DF07(int a1, int a2, unsigned __int8 a3)
{
  int v4; // [esp+20h] [ebp-38h]
  int v5; // [esp+24h] [ebp-34h]
  int v6; // [esp+28h] [ebp-30h]
  int v7; // [esp+2Ch] [ebp-2Ch]
  int v8; // [esp+30h] [ebp-28h]
  int v9; // [esp+34h] [ebp-24h]
  int v10; // [esp+38h] [ebp-20h]
  int v11; // [esp+3Ch] [ebp-1Ch]
  int v12; // [esp+40h] [ebp-18h]
  int v13; // [esp+44h] [ebp-14h]
  int v14; // [esp+48h] [ebp-10h]
  int v15; // [esp+4Ch] [ebp-Ch]

  v4 = dword_80567F0;
  v5 = dword_80567F4;
  v6 = dword_80567F8;
  v7 = dword_80567FC;
  v8 = dword_8056800;
  v9 = dword_8056804;
  v10 = dword_8056808;
  v11 = dword_805680C;
  v12 = dword_8056810;
  v13 = dword_8056814;
  v14 = dword_8056818;
  v15 = dword_805681C;
  sub_804C699(&v4, a3, 1);
  return sub_804DB4B(0, a1, a2, (unsigned int *)&v4);
}
// 80567F0: using guessed type int dword_80567F0;
// 80567F4: using guessed type int dword_80567F4;
// 80567F8: using guessed type int dword_80567F8;
// 80567FC: using guessed type int dword_80567FC;
// 8056800: using guessed type int dword_8056800;
// 8056804: using guessed type int dword_8056804;
// 8056808: using guessed type int dword_8056808;
// 805680C: using guessed type int dword_805680C;
// 8056810: using guessed type int dword_8056810;
// 8056814: using guessed type int dword_8056814;
// 8056818: using guessed type int dword_8056818;
// 805681C: using guessed type int dword_805681C;

//----- (0804DFC3) --------------------------------------------------------
void *__cdecl sub_804DFC3(int a1, unsigned __int8 a2)
{
  return sub_804DF07(a1, -1, a2);
}

//----- (0804DFFE) --------------------------------------------------------
void *__cdecl sub_804DFFE(int a1)
{
  return sub_804DFC3(a1, 0x3Au);
}

//----- (0804E03B) --------------------------------------------------------
void *__cdecl sub_804E03B(signed int a1, int a2, int a3)
{
  int v4; // [esp+0h] [ebp-78h]
  int v5; // [esp+10h] [ebp-68h]
  int v6; // [esp+14h] [ebp-64h]
  int v7; // [esp+18h] [ebp-60h]
  int v8; // [esp+1Ch] [ebp-5Ch]
  int v9; // [esp+20h] [ebp-58h]
  int v10; // [esp+24h] [ebp-54h]
  int v11; // [esp+28h] [ebp-50h]
  int v12; // [esp+2Ch] [ebp-4Ch]
  int v13; // [esp+30h] [ebp-48h]
  int v14; // [esp+34h] [ebp-44h]
  int v15; // [esp+38h] [ebp-40h]
  int v16; // [esp+3Ch] [ebp-3Ch]
  int v17; // [esp+40h] [ebp-38h]
  int v18; // [esp+44h] [ebp-34h]
  int v19; // [esp+48h] [ebp-30h]
  int v20; // [esp+4Ch] [ebp-2Ch]
  int v21; // [esp+50h] [ebp-28h]
  int v22; // [esp+54h] [ebp-24h]
  int v23; // [esp+58h] [ebp-20h]
  int v24; // [esp+5Ch] [ebp-1Ch]
  int v25; // [esp+60h] [ebp-18h]
  int v26; // [esp+64h] [ebp-14h]
  int v27; // [esp+68h] [ebp-10h]
  int v28; // [esp+6Ch] [ebp-Ch]

  sub_804C7D3(&v4 - 26, a2);
  v17 = v5;
  v18 = v6;
  v19 = v7;
  v20 = v8;
  v21 = v9;
  v22 = v10;
  v23 = v11;
  v24 = v12;
  v25 = v13;
  v26 = v14;
  v27 = v15;
  v28 = v16;
  sub_804C699(&v17, 0x3Au, 1);
  return sub_804DB4B(a1, a3, -1, (unsigned int *)&v17);
}

//----- (0804E0EE) --------------------------------------------------------
void __cdecl __noreturn sub_804E0EE(int a1, int a2, int a3)
{
  sub_804E130(a1, a2, a3);
}

//----- (0804E130) --------------------------------------------------------
void __cdecl __noreturn sub_804E130(int a1, int a2, int a3)
{
  int v3; // [esp+10h] [ebp-38h]
  int v4; // [esp+14h] [ebp-34h]
  int v5; // [esp+18h] [ebp-30h]
  int v6; // [esp+1Ch] [ebp-2Ch]
  int v7; // [esp+20h] [ebp-28h]
  int v8; // [esp+24h] [ebp-24h]
  int v9; // [esp+28h] [ebp-20h]
  int v10; // [esp+2Ch] [ebp-1Ch]
  int v11; // [esp+30h] [ebp-18h]
  int v12; // [esp+34h] [ebp-14h]
  int v13; // [esp+38h] [ebp-10h]
  int v14; // [esp+3Ch] [ebp-Ch]

  v3 = dword_80567F0;
  v4 = dword_80567F4;
  v5 = dword_80567F8;
  v6 = dword_80567FC;
  v7 = dword_8056800;
  v8 = dword_8056804;
  v9 = dword_8056808;
  v10 = dword_805680C;
  v11 = dword_8056810;
  v12 = dword_8056814;
  v13 = dword_8056818;
  v14 = dword_805681C;
  sub_804C760((int)&v3, a2, a3);
}
// 80567F0: using guessed type int dword_80567F0;
// 80567F4: using guessed type int dword_80567F4;
// 80567F8: using guessed type int dword_80567F8;
// 80567FC: using guessed type int dword_80567FC;
// 8056800: using guessed type int dword_8056800;
// 8056804: using guessed type int dword_8056804;
// 8056808: using guessed type int dword_8056808;
// 805680C: using guessed type int dword_805680C;
// 8056810: using guessed type int dword_8056810;
// 8056814: using guessed type int dword_8056814;
// 8056818: using guessed type int dword_8056818;
// 805681C: using guessed type int dword_805681C;

//----- (0804E238) --------------------------------------------------------
void *__cdecl sub_804E238(signed int a1, int a2, int a3)
{
  return sub_804DB4B(a1, a2, a3, (unsigned int *)&unk_8056270);
}

//----- (0804E287) --------------------------------------------------------
void *__cdecl sub_804E287(signed int a1, int a2)
{
  return sub_804E238(a1, a2, -1);
}

//----- (0804E2AD) --------------------------------------------------------
void *__cdecl sub_804E2AD(int a1)
{
  return sub_804E287(0, a1);
}

//----- (0804E2C8) --------------------------------------------------------
int __cdecl sub_804E2C8(FILE *stream, int a2, int a3, int a4, int *a5, unsigned int a6)
{
  char *v6; // eax
  char *v7; // eax
  int v8; // edi
  int v9; // ST4C_4
  int v10; // ST48_4
  int v11; // ST44_4
  int v12; // ST40_4
  int v13; // ST3C_4
  int v14; // ST38_4
  int v15; // esi
  int v16; // ebx
  char *format; // eax

  if ( a2 )
    fprintf(stream, "%s (%s) %s\n", a2, a3, a4);
  else
    fprintf(stream, "%s %s\n", a3, a4);
  v6 = gettext("(C)");
  fprintf(stream, "Copyright %s %d Free Software Foundation, Inc.", v6, 2017);
  v7 = gettext(
         "\n"
         "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\n"
         "This is free software: you are free to change and redistribute it.\n"
         "There is NO WARRANTY, to the extent permitted by law.\n"
         "\n");
  fputs_unlocked(v7, stream);
  if ( a6 <= 9 )
    JUMPOUT(__CS__, *(&off_8051E4C + a6));
  v8 = a5[8];
  v9 = a5[7];
  v10 = a5[6];
  v11 = a5[5];
  v12 = a5[4];
  v13 = a5[3];
  v14 = a5[2];
  v15 = a5[1];
  v16 = *a5;
  format = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
  return fprintf(stream, format, v16, v15, v14, v13, v12, v11, v10, v9, v8);
}
// 8048F80: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8051E4C: using guessed type void *;

//----- (0804E866) --------------------------------------------------------
int __cdecl sub_804E866(FILE *a1, int a2, int a3, int a4, int *a5)
{
  int *v5; // eax
  unsigned int i; // [esp+24h] [ebp-34h]
  int v8[12]; // [esp+28h] [ebp-30h]

  for ( i = 0; i <= 9; ++i )
  {
    v5 = a5;
    ++a5;
    v8[i] = *v5;
    if ( !v8[i] )
      break;
  }
  return sub_804E2C8(a1, a2, a3, a4, v8, i);
}
// 804E866: using guessed type int var_30[12];

//----- (0804E8CC) --------------------------------------------------------
int sub_804E8CC(FILE *a1, int a2, int a3, int a4, ...)
{
  va_list va; // [esp+24h] [ebp+18h]

  va_start(va, a4);
  return sub_804E866(a1, a2, a3, a4, (int *)va);
}

//----- (0804E9F3) --------------------------------------------------------
void *__cdecl sub_804E9F3(void *ptr, int a2, int a3)
{
  void *v3; // eax
  unsigned int v5; // [esp+1Ch] [ebp-Ch]
  unsigned int v6; // [esp+1Ch] [ebp-Ch]

  v5 = *(_DWORD *)a2;
  if ( ptr )
  {
    if ( 0x55555554u / a3 <= v5 )
      sub_804EC5A();
    v6 = (v5 >> 1) + v5 + 1;
  }
  else
  {
    v3 = &loc_804EA26;
    if ( v5 )
      v3 = &loc_804EA44;
    dword_8056210 = (int)v3;
    sub_805044F();
    v6 = (0x40u / a3 == 0) + 0x40u / a3;
    if ( 0x7FFFFFFFu / a3 < v6 )
      sub_804EC5A();
  }
  *(_DWORD *)a2 = v6;
  return sub_804EB05(ptr, a3 * v6);
}
// 805044F: using guessed type int sub_805044F(void);
// 8056210: using guessed type int dword_8056210;

//----- (0804EAA6) --------------------------------------------------------
void *__cdecl sub_804EAA6(size_t size)
{
  return sub_804EACB(size);
}

//----- (0804EACB) --------------------------------------------------------
void *__cdecl sub_804EACB(size_t size)
{
  void *v2; // [esp+1Ch] [ebp-Ch]

  v2 = malloc(size);
  if ( !v2 && size )
    sub_804EC5A();
  return v2;
}

//----- (0804EB05) --------------------------------------------------------
void *__cdecl sub_804EB05(void *ptr, size_t size)
{
  void *result; // eax
  void *ptra; // [esp+20h] [ebp+8h]

  if ( size || !ptr )
  {
    ptra = realloc(ptr, size);
    if ( !ptra )
    {
      if ( size )
        sub_804EC5A();
    }
    result = ptra;
  }
  else
  {
    free(ptr);
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}

//----- (0804EB61) --------------------------------------------------------
void *__cdecl sub_804EB61(void *ptr, int a2)
{
  return sub_804E9F3(ptr, a2, 1);
}

//----- (0804EC08) --------------------------------------------------------
void *__cdecl sub_804EC08(void *src, size_t n)
{
  void *v2; // eax

  v2 = sub_804EACB(n);
  return memcpy(v2, src, n);
}

//----- (0804EC5A) --------------------------------------------------------
void __noreturn sub_804EC5A()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (0804EC93) --------------------------------------------------------
void __cdecl sub_804EC93(int errnum, int a2, int a3, int a4, int a5)
{
  char *v5; // eax
  char *v6; // eax
  void *v7; // esi
  void *v8; // ebx
  char *v9; // eax
  void *v10; // [esp-1Ch] [ebp-1Ch]
  void *v11; // [esp-18h] [ebp-18h]

  v5 = gettext("string comparison failed");
  error(0, errnum, v5);
  v6 = gettext("Set LC_ALL='C' to work around the problem.");
  error(0, 0, v6);
  v7 = sub_804DE77(1, 8, a4, a5);
  v8 = sub_804DE77(0, 8, a2, a3);
  v9 = gettext("The strings compared were %s and %s.");
  v11 = v7;
  v10 = v8;
  error(status, 0, v9, v8, v7);
}

//----- (0804ED67) --------------------------------------------------------
int __cdecl sub_804ED67(void *s1, size_t n, void *s2, int a4)
{
  int v5; // [esp+28h] [ebp-10h]
  int errnum; // [esp+2Ch] [ebp-Ch]

  v5 = sub_804FEF4(s1, n, s2, a4);
  errnum = *__errno_location();
  if ( errnum )
    sub_804EC93(errnum, (int)s1, n, (int)s2, a4);
  return v5;
}

//----- (0804EE47) --------------------------------------------------------
signed int __cdecl sub_804EE47(unsigned int *a1, signed int a2)
{
  signed int result; // eax

  if ( 0xFFFFFFFF / a2 >= *a1 )
  {
    _CF = (unsigned __int64)(a2 * (signed __int64)(signed int)*a1) >> 32 != 0;
    _OF = (unsigned __int64)(a2 * (signed __int64)(signed int)*a1) >> 32 != 0;
    *a1 *= a2;
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  else
  {
    *a1 = -1;
    result = 1;
  }
  return result;
}

//----- (0804EE9D) --------------------------------------------------------
int __cdecl sub_804EE9D(unsigned int *a1, signed int a2, int a3)
{
  int v3; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; i |= sub_804EE47(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}

//----- (0804EEE5) --------------------------------------------------------
int __cdecl sub_804EEE5(char *nptr, int a2, int base, int a4, char *s)
{
  char **v5; // eax
  bool v6; // zf
  void *v7; // eax
  int result; // eax
  void *v9; // eax
  void *v10; // eax
  void *v11; // eax
  void *v12; // eax
  void *v13; // eax
  int v14; // eax
  void *v15; // eax
  int v16; // [esp+4h] [ebp-44h]
  unsigned __int8 v17; // [esp+1Fh] [ebp-29h]
  char v18; // [esp+20h] [ebp-28h]
  unsigned int v19; // [esp+24h] [ebp-24h]
  int v20; // [esp+28h] [ebp-20h]
  char *v21; // [esp+2Ch] [ebp-1Ch]
  int v22; // [esp+30h] [ebp-18h]
  int v23; // [esp+34h] [ebp-14h]
  int v24; // [esp+38h] [ebp-10h]
  char **endptr; // [esp+3Ch] [ebp-Ch]

  v20 = 0;
  if ( base < 0 || base > 36 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoul");
  if ( a2 )
    v5 = (char **)a2;
  else
    v5 = (char **)&v18;
  endptr = v5;
  *__errno_location() = 0;
  v21 = nptr;
  v17 = *nptr;
  v6 = ((*__ctype_b_loc())[v17] & 0x2000) == 0;
  v7 = &loc_804EF95;
  if ( !v6 )
    v7 = &loc_804EF51;
  dword_8056184 = (int)v7;
  sub_805077E();
  if ( v17 == 45 )
    return 4;
  v19 = strtoul(nptr, endptr, base);
  v9 = &loc_804EFE4;
  if ( *endptr != nptr )
    v9 = &loc_804F052;
  dword_8056198 = (int)v9;
  sub_805070A();
  if ( s && **endptr )
  {
    v6 = strchr(s, **endptr) == 0;
    v10 = &loc_804F02D;
    if ( v6 )
      v10 = &loc_804F036;
    dword_8056170 = (int)v10;
    sub_80507F4();
    v19 = 1;
LABEL_22:
    if ( !s )
    {
      *(_DWORD *)a4 = v19;
      return v20;
    }
    v12 = &loc_804F0CE;
    if ( !**endptr )
      v12 = &loc_804F3C5;
    dword_8056198 = (int)v12;
    sub_805070A();
    v22 = 1024;
    v23 = 1;
    v16 = **endptr;
    if ( !strchr(s, v16) )
    {
      *(_DWORD *)a4 = v19;
      return v20 | 2;
    }
    switch ( **endptr )
    {
      case 69:
      case 71:
      case 75:
      case 77:
      case 80:
      case 84:
      case 89:
      case 90:
      case 103:
      case 107:
      case 109:
      case 116:
        v6 = strchr(s, 48) == 0;
        v13 = &loc_804F159;
        if ( v6 )
          v13 = &loc_804F19A;
        dword_8056170 = (int)v13;
        sub_80507F4();
        v14 = (*endptr)[1];
        switch ( v14 )
        {
          case 68:
            goto LABEL_38;
          case 105:
            if ( (*endptr)[2] == 66 )
              v23 += 2;
            break;
          case 66:
LABEL_38:
            v22 = 1000;
            ++v23;
            break;
        }
        break;
      default:
        break;
    }
    switch ( **endptr )
    {
      case 66:
        v24 = sub_804EE47(&v19, 1024);
        goto LABEL_53;
      case 69:
        v24 = sub_804EE9D(&v19, v22, 6);
        dword_805615C = (int)&loc_804F387;
        sub_8050866();
        goto LABEL_44;
      case 71:
      case 103:
LABEL_44:
        v24 = sub_804EE9D(&v19, v22, 3);
        dword_80561AC = (int)&loc_804F387;
        sub_8050696();
        goto LABEL_45;
      case 75:
      case 107:
LABEL_45:
        v24 = sub_804EE9D(&v19, v22, 1);
        goto LABEL_53;
      case 77:
      case 109:
        v24 = sub_804EE9D(&v19, v22, 2);
        goto LABEL_53;
      case 80:
        v24 = sub_804EE9D(&v19, v22, 5);
        goto LABEL_53;
      case 84:
      case 116:
        v24 = sub_804EE9D(&v19, v22, 4);
        dword_80561FC = (int)&loc_804F387;
        sub_80504C1();
        goto LABEL_49;
      case 89:
        v24 = sub_804EE9D(&v19, v22, 8);
        goto LABEL_53;
      case 90:
        v24 = sub_804EE9D(&v19, v22, 7);
        dword_8056120 = (int)&loc_804F387;
        sub_80509C0();
        goto LABEL_52;
      case 98:
        v24 = sub_804EE47(&v19, 512);
        goto LABEL_53;
      case 99:
        v24 = 0;
        goto LABEL_53;
      case 119:
LABEL_49:
        v24 = sub_804EE47(&v19, 2);
LABEL_53:
        v20 |= v24;
        *endptr += v23;
        v15 = &loc_804F3C1;
        if ( !**endptr )
          v15 = &loc_804F3C5;
        dword_8056134 = (int)v15;
        sub_805094E();
        v20 |= 2u;
        *(_DWORD *)a4 = v19;
        result = v20;
        break;
      default:
LABEL_52:
        *(_DWORD *)a4 = v19;
        result = v20 | 2;
        break;
    }
    return result;
  }
  dword_80561E8 = (int)&locret_804F3D0;
  sub_8050548();
  if ( !*__errno_location() )
    goto LABEL_22;
  v6 = *__errno_location() == 34;
  v11 = &loc_804F082;
  if ( v6 )
    v11 = &loc_804F08C;
  dword_80561E8 = (int)v11;
  sub_8050548();
  return 4;
}
// 804EEE5: could not find valid save-restore pair for ebx
// 80504C1: using guessed type int sub_80504C1(void);
// 8050548: using guessed type int sub_8050548(void);
// 8050696: using guessed type int sub_8050696(void);
// 805070A: using guessed type int sub_805070A(void);
// 805077E: using guessed type int sub_805077E(void);
// 80507F4: using guessed type int sub_80507F4(void);
// 8050866: using guessed type int sub_8050866(void);
// 805094E: using guessed type int sub_805094E(void);
// 80509C0: using guessed type int sub_80509C0(void);
// 8056120: using guessed type int dword_8056120;
// 8056134: using guessed type int dword_8056134;
// 805615C: using guessed type int dword_805615C;
// 8056170: using guessed type int dword_8056170;
// 8056184: using guessed type int dword_8056184;
// 8056198: using guessed type int dword_8056198;
// 80561AC: using guessed type int dword_80561AC;
// 80561E8: using guessed type int dword_80561E8;
// 80561FC: using guessed type int dword_80561FC;

//----- (0804F3D2) --------------------------------------------------------
int __cdecl sub_804F3D2(FILE *stream)
{
  bool v2; // zf
  void *v3; // eax
  int v4; // eax
  __int64 v5; // rax
  int v6; // [esp+14h] [ebp-14h]
  int v7; // [esp+18h] [ebp-10h]

  v6 = 0;
  if ( fileno(stream) < 0 )
    return fclose(stream);
  v2 = __freading(stream) == 0;
  v3 = &loc_804F440;
  if ( v2 )
    v3 = &loc_804F479;
  dword_80561FC = (int)v3;
  sub_80504C1();
  v4 = fileno(stream);
  LODWORD(v5) = lseek64(v4, 0, 0, 1);
  if ( v5 != -1 && sub_804F4F9(stream) )
    v6 = *__errno_location();
  v7 = fclose(stream);
  if ( v6 )
  {
    *__errno_location() = v6;
    v7 = -1;
  }
  return v7;
}
// 8049090: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 80504C1: using guessed type int sub_80504C1(void);
// 80561FC: using guessed type int dword_80561FC;

//----- (0804F4BC) --------------------------------------------------------
int __cdecl sub_804F4BC(FILE *stream)
{
  int result; // eax

  result = stream->_flags & 0x100;
  if ( result )
    result = sub_804F53D(stream, 0, 0, 1);
  return result;
}

//----- (0804F4F9) --------------------------------------------------------
int __cdecl sub_804F4F9(FILE *fp)
{
  if ( !fp || !__freading(fp) )
    return fflush(fp);
  sub_804F4BC(fp);
  return fflush(fp);
}

//----- (0804F53D) --------------------------------------------------------
int __cdecl sub_804F53D(FILE *stream, int a2, int a3, int a4)
{
  int v4; // eax
  __off64_t v5; // rax
  int result; // eax

  if ( stream->_IO_read_end != stream->_IO_read_ptr
    || stream->_IO_write_ptr != stream->_IO_write_base
    || stream->_IO_save_base )
  {
    return fseeko64(stream, a2, a3, a4);
  }
  v4 = fileno(stream);
  LODWORD(v5) = lseek64(v4, a2, a3, a4);
  if ( v5 == -1 )
    return -1;
  _CF = 0;
  _OF = 0;
  _ZF = (stream->_flags & 0xFFFFFFEF) == 0;
  _SF = (stream->_flags & 0xFFFFFFEF & 0x80000000) != 0;
  stream->_flags &= 0xFFFFFFEF;
  stream->_offset = v5;
  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}
// 8048E30: using guessed type int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8049090: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804F628) --------------------------------------------------------
size_t __cdecl sub_804F628(wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  void *v4; // eax
  void *v5; // eax
  bool v6; // zf
  void *v7; // eax
  wchar_t v9; // [esp+18h] [ebp-10h]
  size_t v10; // [esp+1Ch] [ebp-Ch]

  v4 = &loc_804F64D;
  if ( pwc )
    v4 = &loc_804F653;
  dword_805615C = (int)v4;
  sub_8050866();
  v10 = mbrtowc(&v9, s, n, p);
  if ( v10 <= 0xFFFFFFFD )
    return v10;
  v5 = &loc_804F69F;
  if ( !n )
    v5 = &loc_804F6E4;
  dword_8056134 = (int)v5;
  sub_805094E();
  v6 = (unsigned __int8)sub_804C219(0) == 1;
  v7 = &loc_804F6CB;
  if ( v6 )
    v7 = &loc_804F6E4;
  dword_80561D4 = (int)v7;
  sub_80505B6();
  v9 = (unsigned __int8)*s;
  return 1;
}
// 804F628: could not find valid save-restore pair for ebx
// 80505B6: using guessed type int sub_80505B6(void);
// 8050866: using guessed type int sub_8050866(void);
// 805094E: using guessed type int sub_805094E(void);
// 8056134: using guessed type int dword_8056134;
// 805615C: using guessed type int dword_805615C;
// 80561D4: using guessed type int dword_80561D4;

//----- (0804F6E9) --------------------------------------------------------
int __cdecl sub_804F6E9(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // esi
  unsigned __int8 *v3; // ebx
  int result; // eax
  unsigned __int8 v9; // [esp+1Eh] [ebp-Ah]
  unsigned __int8 v10; // [esp+1Fh] [ebp-9h]

  v2 = a1;
  v3 = a2;
  _CF = a1 < a2;
  _OF = __OFSUB__(a1, a2);
  _ZF = a1 == a2;
  _SF = a1 - a2 < 0;
  if ( a1 == a2 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  else
  {
    do
    {
      v9 = sub_80502A3(*v2);
      v10 = sub_80502A3(*v3);
      if ( !v9 )
        break;
      ++v2;
      ++v3;
    }
    while ( v9 == v10 );
    result = v9 - v10;
  }
  return result;
}

//----- (0804F753) --------------------------------------------------------
int __cdecl sub_804F753(FILE *fp)
{
  void *v1; // eax
  unsigned int v2; // eax
  int result; // eax
  bool v8; // [esp+1Dh] [ebp-Bh]
  bool v9; // [esp+1Eh] [ebp-Ah]
  bool v10; // [esp+1Fh] [ebp-9h]

  v8 = __fpending(fp) != 0;
  v9 = ferror_unlocked(fp) != 0;
  v10 = sub_804F3D2(fp) != 0;
  if ( v9 )
    goto LABEL_12;
  v1 = &loc_804F7B7;
  if ( !v10 )
    v1 = &loc_804F7FB;
  dword_80561AC = (int)v1;
  sub_8050696();
  if ( v8
    || (v2 = *__errno_location(),
        _CF = v2 < 9,
        _OF = __OFSUB__(v2, 9),
        _ZF = v2 == 9,
        _SF = (signed int)(v2 - 9) < 0,
        v2 != 9) )
  {
LABEL_12:
    if ( v10 != 1 )
      *__errno_location() = 0;
    dword_8056210 = (int)&locret_804F801;
    sub_805044F();
  }
  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}
// 805044F: using guessed type int sub_805044F(void);
// 8050696: using guessed type int sub_8050696(void);
// 80561AC: using guessed type int dword_80561AC;
// 8056210: using guessed type int dword_8056210;

//----- (0804F807) --------------------------------------------------------
void *sub_804F807()
{
  char *v0; // eax
  void *v1; // eax
  char v6; // al
  signed int v7; // eax
  void *v8; // eax
  void *ptr; // [esp+14h] [ebp-B4h]
  void *v11; // [esp+18h] [ebp-B0h]
  char *s; // [esp+1Ch] [ebp-ACh]
  char *v13; // [esp+28h] [ebp-A0h]
  size_t n; // [esp+2Ch] [ebp-9Ch]
  size_t v15; // [esp+30h] [ebp-98h]
  int v16; // [esp+34h] [ebp-94h]
  void *dest; // [esp+38h] [ebp-90h]
  unsigned int v18; // [esp+BCh] [ebp-Ch]

  v18 = __readgsdword(0x14u);
  v11 = (void *)dword_8056930;
  if ( !dword_8056930 )
  {
    ptr = 0;
    v13 = "charset.alias";
    v0 = getenv("CHARSETALIASDIR");
    s = v0;
    _ZF = v0 == 0;
    v1 = &loc_804F87C;
    if ( _ZF )
      v1 = &loc_804F889;
    dword_80561FC = (int)v1;
    sub_80504C1();
    if ( !*s )
    {
      ptr = 0;
      s = "/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib";
    }
    n = strlen(s);
    v15 = strlen(v13);
    _CF = 0;
    _OF = 0;
    _ZF = n == 0;
    _SF = (n & 0x80000000) != 0;
    if ( n
      && (v6 = s[n - 1],
          _CF = (unsigned __int8)v6 < 0x2Fu,
          _OF = __OFSUB__(v6, 47),
          _ZF = v6 == 47,
          _SF = (char)(v6 - 47) < 0,
          v6 != 47) )
    {
      v7 = 1;
    }
    else
    {
      __asm { pushfw }
      v7 = 0;
      __asm { popfw }
    }
    v16 = v7;
    dest = malloc(n + v7 + v15 + 1);
    if ( dest )
    {
      memcpy(dest, s, n);
      if ( v16 )
        *((_BYTE *)dest + n) = 47;
      memcpy((char *)dest + n + v16, v13, v15 + 1);
    }
    free(ptr);
    v8 = &loc_804F9CE;
    if ( dest )
      v8 = &loc_804F9DD;
    dword_80561D4 = (int)v8;
    sub_80505B6();
    v11 = &unk_805221F;
    dword_8056930 = (int)&unk_805221F;
  }
  return v11;
}
// 80504C1: using guessed type int sub_80504C1(void);
// 80505B6: using guessed type int sub_80505B6(void);
// 80561D4: using guessed type int dword_80561D4;
// 80561FC: using guessed type int dword_80561FC;
// 8056930: using guessed type int dword_8056930;

//----- (0804FD41) --------------------------------------------------------
char *sub_804FD41()
{
  bool v0; // zf
  void *v1; // eax
  char *s2; // ST24_4
  void *v3; // eax
  char *s1; // [esp+18h] [ebp-10h]

  v0 = nl_langinfo(14) == 0;
  v1 = &loc_804FD75;
  if ( !v0 )
    v1 = &loc_804FD7C;
  dword_8056210 = (int)v1;
  sub_805044F();
  s1 = (char *)&unk_805221F;
  s2 = (char *)sub_804F807();
  v3 = &loc_804FE20;
  if ( *s2 )
    v3 = &loc_804FD86;
  dword_8056198 = (int)v3;
  sub_805070A();
  if ( !unk_805221F )
    s1 = "ASCII";
  return s1;
}
// 804FD41: could not find valid save-restore pair for ebx
// 805044F: using guessed type int sub_805044F(void);
// 805070A: using guessed type int sub_805070A(void);
// 8056198: using guessed type int dword_8056198;
// 8056210: using guessed type int dword_8056210;

//----- (0804FE36) --------------------------------------------------------
int __cdecl sub_804FE36(char *s, int a2, char *s2, int a4)
{
  size_t v4; // ST1C_4
  size_t v5; // eax
  int v7; // eax
  signed int v12; // eax
  int v13; // [esp+14h] [ebp-14h]

  while ( 1 )
  {
    *__errno_location() = 0;
    v13 = strcoll(s, s2);
    if ( v13 || (v7 = *__errno_location(), _CF = 0, _OF = 0, _ZF = v7 == 0, _SF = v7 < 0, v7) )
    {
      v12 = 1;
    }
    else
    {
      __asm { pushfw }
      v12 = 0;
      __asm { popfw }
    }
    if ( v12 )
      break;
    v4 = strlen(s) + 1;
    v5 = strlen(s2);
    s += v4;
    s2 += v5 + 1;
    a2 -= v4;
    a4 -= v5 + 1;
    if ( !a2 )
      return -(a4 != 0);
    if ( !a4 )
      return 1;
  }
  return v13;
}

//----- (0804FEF4) --------------------------------------------------------
int __cdecl sub_804FEF4(void *s1, size_t n, void *s2, int a4)
{
  char v4; // ST1A_1
  char v5; // ST1B_1
  int v7; // [esp+1Ch] [ebp-Ch]

  if ( n == a4 && !memcmp(s1, s2, n) )
  {
    *__errno_location() = 0;
    v7 = 0;
  }
  else
  {
    v4 = *((_BYTE *)s1 + n);
    v5 = *((_BYTE *)s2 + a4);
    *((_BYTE *)s1 + n) = 0;
    *((_BYTE *)s2 + a4) = 0;
    v7 = sub_804FE36((char *)s1, n + 1, (char *)s2, a4 + 1);
    *((_BYTE *)s1 + n) = v4;
    *((_BYTE *)s2 + a4) = v5;
  }
  return v7;
}

//----- (0804FFB3) --------------------------------------------------------
int __cdecl sub_804FFB3(void *s1, size_t n, void *s2, int a4)
{
  void *v4; // eax
  int result; // eax

  v4 = &loc_804FFDA;
  if ( n != a4 )
    v4 = &loc_805000A;
  dword_80561D4 = (int)v4;
  sub_80505B6();
  if ( memcmp(s1, s2, n) )
    return sub_804FE36((char *)s1, n, (char *)s2, a4);
  *__errno_location() = 0;
  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}
// 80505B6: using guessed type int sub_80505B6(void);
// 80561D4: using guessed type int dword_80561D4;

//----- (080502A3) --------------------------------------------------------
int __cdecl sub_80502A3(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 65) > 0x19 )
    result = a1;
  else
    result = a1 + 32;
  return result;
}

//----- (0805036C) --------------------------------------------------------
int __cdecl sub_805036C(int a1)
{
  return __cxa_atexit(a1, 0, dword_8056234);
}
// 8048EE0: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 8056234: using guessed type int dword_8056234;

//----- (0805044F) --------------------------------------------------------
#error "8050455: positive sp value has been found (funcsize=0)"

//----- (080504C1) --------------------------------------------------------
#error "80504C7: positive sp value has been found (funcsize=0)"

//----- (08050548) --------------------------------------------------------
#error "805054E: positive sp value has been found (funcsize=0)"

//----- (080505B6) --------------------------------------------------------
#error "80505BC: positive sp value has been found (funcsize=0)"

//----- (08050624) --------------------------------------------------------
#error "805062A: positive sp value has been found (funcsize=0)"

//----- (08050696) --------------------------------------------------------
#error "805069C: positive sp value has been found (funcsize=0)"

//----- (0805070A) --------------------------------------------------------
#error "8050710: positive sp value has been found (funcsize=0)"

//----- (0805077E) --------------------------------------------------------
#error "8050784: positive sp value has been found (funcsize=0)"

//----- (080507F4) --------------------------------------------------------
#error "80507FA: positive sp value has been found (funcsize=0)"

//----- (08050866) --------------------------------------------------------
#error "805086C: positive sp value has been found (funcsize=0)"

//----- (080508DA) --------------------------------------------------------
#error "80508E0: positive sp value has been found (funcsize=0)"

//----- (0805094E) --------------------------------------------------------
#error "8050954: positive sp value has been found (funcsize=0)"

//----- (080509C0) --------------------------------------------------------
#error "80509C6: positive sp value has been found (funcsize=0)"

//----- (08050A40) --------------------------------------------------------
int (**sub_8050A40())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_8055EC8;
  v1 = &off_8055ECC - off_8055EC8;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_8055EC8[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 8055EC8: using guessed type int (*off_8055EC8[2])();
// 8055ECC: using guessed type int (*off_8055ECC)();

//----- (08050AA4) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 17 decompilation failure(s) on 161 function(s)"
