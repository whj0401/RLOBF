/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8048CF0();
// int strcmp(const char *s1, const char *s2);
// int __cdecl open64(_DWORD, _DWORD); weak
// int __cdecl getline(_DWORD, _DWORD, _DWORD); weak
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void _exit(int status);
// void free(void *ptr);
// void *memcpy(void *dest, const void *src, size_t n);
// int mbsinit(const mbstate_t *ps);
// int tolower(int c);
// int fclose(FILE *stream);
// int getc_unlocked(FILE *stream);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// int iswprint(wint_t wc);
// int __stdcall fopen64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int ferror_unlocked(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// size_t __ctype_get_mb_cur_max(void);
// char *strcpy(char *dest, const char *src);
// size_t __fpending(FILE *fp);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// void error(int status, int errnum, const char *format, ...);
// size_t fread_unlocked(void *ptr, size_t size, size_t n, FILE *stream);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// char *strchr(const char *s, int c);
// int fscanf(FILE *stream, const char *format, ...);
// size_t strlen(const char *s);
// int fprintf(FILE *stream, const char *format, ...);
// int fcntl(int fd, int cmd, ...);
// void *memset(void *s, int c, size_t n);
// int ungetc(int c, FILE *stream);
// int *__errno_location(void);
// int fileno(FILE *stream);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// char *strrchr(const char *s, int c);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// int feof_unlocked(FILE *stream);
// void abort(void);
// char *ngettext(const char *msgid1, const char *msgid2, unsigned int n);
// int close(int fd);
// const unsigned __int16 **__ctype_b_loc(void);
// int putchar_unlocked(int c);
// int _gmon_start__(void); weak
void sub_8049123();
void sub_8049140();
int sub_8049150();
int sub_80491C0();
int sub_80491E0();
void sub_804927D();
void sub_8049298();
signed int sub_80492E5();
void sub_8049407();
// int __usercall sub_8049422@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>);
// int __usercall sub_80494B0@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>);
void sub_8049610();
void sub_8049660();
int sub_80496AD();
void sub_804978F();
// void __usercall __spoils<edx,ecx> sub_80497E9(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>);
int sub_804986C();
void sub_8049986();
// void __usercall __spoils<edx,ecx> sub_80499A1(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>);
int sub_80499E6();
void sub_8049B6C();
void sub_8049BFA();
int sub_8049C0A();
void sub_8049DA0();
void sub_8049E2D();
int sub_8049EB1();
void sub_804A047();
signed int sub_804A04B();
// void __usercall __noreturn sub_804A055(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>);
void sub_804A15B();
int sub_804A1A9();
void sub_804A335();
void sub_804A38E();
signed int sub_804A392();
int __fastcall sub_804A39C(_DWORD, _DWORD); // weak
int sub_804A413();
void sub_804A52C();
void sub_804A57B();
int sub_804A629();
void sub_804A70B();
void sub_804A75A();
int sub_804A7A7();
signed int sub_804A7B7();
int __fastcall sub_804A7C1(_DWORD, _DWORD); // weak
void sub_804A908();
void sub_804A923();
// signed __int32 __usercall sub_804A927@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>);
int __fastcall sub_804AA62(_DWORD, _DWORD); // weak
// int __usercall sub_804AA6F@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>);
void sub_804AC63();
// void __usercall __spoils<edx,ecx> sub_804AC7E(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>);
// int __usercall sub_804AD6A@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>);
signed int sub_804AE45();
// void __usercall __noreturn sub_804AE4F(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>);
void sub_804AFD7();
signed int sub_804AFDB();
int __fastcall sub_804AFE5(_DWORD, _DWORD); // weak
void sub_804B0AD();
int sub_804B164();
void sub_804B370();
// void __usercall __spoils<edx,ecx> sub_804B445(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>);
int sub_804B4BF();
// signed int __usercall sub_804B557@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>);
// void __usercall __noreturn sub_804B60C(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>);
void sub_804B802();
// void __usercall __spoils<edx,ecx> sub_804B85B(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>);
int sub_804B9B1();
signed int sub_804BB55();
int __fastcall sub_804BB5F(_DWORD); // weak
// int __usercall sub_804BB65@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>, int a8@<ebp>, unsigned __int32 a9, signed int a10);
// int __usercall sub_804BD12@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, int a3, unsigned int a4);
// signed __int32 __usercall sub_804BDA2@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>);
// int __usercall sub_804BEF9@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, const char *a9);
int __cdecl sub_804C1BA(int a1);
// void __usercall __noreturn sub_804C1C2(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, int a8);
// _BYTE *__usercall sub_804C516@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, int a9@<ebp>, _BYTE *a10, unsigned int a11);
// bool __usercall sub_804C699@<al>(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, _BYTE *a4);
signed int sub_804C840();
int __fastcall sub_804C84A(_DWORD); // weak
// bool __usercall sub_804C84B@<al>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, int a9@<ebp>, _BYTE *a10, int a11, _BYTE **a12, _DWORD *a13, char a14);
// bool __usercall sub_804CAE3@<al>(signed __int32 a1@<ebx>, signed __int32 a2, int a3, _BYTE **a4, _DWORD *a5, _DWORD *a6);
// int __usercall sub_804CE26@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>, char *a3, char a4);
// int __usercall sub_804CF90@<eax>(signed __int32 a1@<ebx>, char *s1, int a3, int a4, int a5);
// int __usercall sub_804D19E@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, signed __int32 a9);
// int __usercall sub_804E2FF@<eax>(signed __int32 a1@<ebx>);
// _DWORD *__usercall sub_804E3E3@<eax>(signed __int32 a1@<ebx>, _DWORD *a2);
_DWORD *__cdecl sub_804E44F(_DWORD *a1, int a2);
// _DWORD *__usercall sub_804E45C@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, signed __int32 *a8, _DWORD *a9);
// _DWORD *__usercall sub_804E723@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, int *a3, _DWORD *a4);
// int __usercall sub_804E9A3@<eax>(signed __int32 a1@<ebx>, FILE *stream, int a3);
// int *__usercall sub_804EB97@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, void *src, int a4, int a5);
// int *__usercall sub_804EEB9@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, int *a3, unsigned int a4, int *a5);
signed int sub_804FCF9();
int __fastcall sub_804FD03(_DWORD); // weak
// int __usercall sub_804FD04@<eax>(char _CF@<cf>, bool _ZF@<zf>, bool _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, int a8@<ebp>, int a9, int a10, int a11, signed __int32 a12, int a13, int a14);
// int __usercall sub_804FF77@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, int a9@<ebp>, FILE *stream, int a11);
int __cdecl sub_8050033(_DWORD, _DWORD); // weak
// const char *__usercall sub_8050182@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>, const char *a7);
signed int sub_8050431();
// void __usercall __noreturn sub_805043B(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>);
// unsigned int __usercall sub_80504E1@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, int *a9, unsigned __int8 a10, char a11);
int *__cdecl sub_80506E0(int *a1, int a2, int a3);
// unsigned int *__userpurge sub_8050750@<eax>(signed __int32 a1@<eax>, signed __int32 a2@<ecx>, unsigned int *a3, unsigned int a4);
// char *__usercall sub_8050844@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, const char *msgid, int a9);
// unsigned int __usercall sub_8050A80@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, signed __int32 a3, unsigned int a4, signed __int32 a5, unsigned __int32 a6, unsigned __int32 a7, int a8, int a9, char *a10, char *a11);
signed int sub_80519A9();
// void __usercall __noreturn sub_80519B3(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>);
// signed __int32 __usercall sub_8051A65@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, signed __int32 a8, unsigned __int32 a9, _DWORD *a10, int *a11);
// void *__usercall sub_8051D36@<eax>(signed __int32 a1@<ebx>, signed __int32 a2, signed __int32 a3, unsigned __int32 a4, int a5);
// void *__usercall sub_8052326@<eax>(signed __int32 a1@<ebx>, signed __int32 a2, signed __int32 a3);
// void *__usercall sub_80523F3@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>, signed __int32 a3, signed __int32 a4, unsigned __int32 a5);
// void *__usercall sub_80525CD@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, signed __int32 a3, unsigned int a4, signed __int32 a5);
// void *__usercall sub_8052693@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, signed __int32 a3, unsigned int a4, signed __int32 a5, unsigned __int32 a6);
// void *__usercall sub_80527D7@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, signed __int32 a4, unsigned __int32 a5, unsigned __int8 a6);
// void *__usercall sub_80528DE@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, signed __int32 a4, unsigned __int8 a5);
// void *__usercall sub_8052964@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>, signed __int32 a7);
// void *__usercall sub_8052BC0@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, signed __int32 a3, unsigned int a4, signed __int32 a5);
// void *__usercall sub_8052D4F@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, int a4, int a5, int a6, signed __int32 a7);
// void *__usercall sub_8052E12@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, int a9@<ebp>, signed __int32 a10, int a11, int a12, signed __int32 a13, unsigned __int32 a14);
// void *__usercall sub_8053163@<eax>(signed __int32 a1@<eax>, signed __int32 a2@<edx>, signed __int32 a3@<ebx>, signed __int32 a4, signed __int32 a5, unsigned __int32 a6);
// void *__usercall sub_8053326@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, signed __int32 a9, signed __int32 a10);
// int __usercall sub_8053428@<eax>(signed __int32 a1@<ebx>, int fd);
signed int sub_805344B();
// void __usercall __noreturn sub_8053455(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>);
// int __usercall sub_805353C@<eax>(char _CF@<cf>, bool _ZF@<zf>, bool _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, FILE *stream, int a10, int a11, int a12, signed __int32 *a13, int a14);
// int __usercall sub_8053DEF@<eax>(char _CF@<cf>, bool _ZF@<zf>, bool _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, int a8@<ebp>, FILE *a9, int a10, int a11, int a12, signed __int32 *a13);
// int __usercall sub_8054127@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, FILE *a3, int a4, int a5, int a6, ...);
// void *__usercall sub_80542C5@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>, void *ptr, signed __int32 *a8, unsigned int a9);
// void *__usercall sub_80544B6@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>, signed __int32 a3);
// void *__usercall sub_8054507@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>, signed int size);
// void *__usercall sub_805465D@<eax>(signed __int32 a1@<ebx>, void *ptr, size_t size);
// void *__usercall sub_80547DB@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, int a9@<ebp>, const void *src, unsigned __int32 n);
// void __usercall __noreturn sub_805492A(signed __int32 a1@<ebx>);
// int __usercall sub_80549A1@<eax>(signed __int32 a1@<ebx>, FILE *stream);
// int __usercall sub_8054BCE@<eax>(signed __int32 a1@<ebx>, int fd, int cmd, char a4, int a5);
// int __usercall sub_8054EBA@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, FILE *stream);
// int __usercall sub_8054FE9@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, FILE *fp);
// int __usercall sub_80551A3@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>, FILE *stream, int a4, int a5, int a6);
// int __usercall sub_80554BD@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, wchar_t *pwc, char *s, size_t n, mbstate_t *p);
// int __usercall sub_80555E1@<eax>(signed __int32 a1@<edx>, unsigned __int8 *a2, unsigned __int8 *a3);
// int __usercall sub_8055736@<eax>(signed __int32 a1@<ebx>, FILE *fp);
// int __usercall sub_8055864@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>, int category);
// void *__usercall sub_805599B@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>);
// const char *__usercall sub_8055F5C@<eax>(signed __int32 a1@<ebx>);
// int __usercall sub_80562BD@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>, int a3);
// signed __int32 __usercall sub_80563B2@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>, unsigned __int32 a7, unsigned int a8, __int64 a9);
// int __usercall sub_8056735@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>, int a7);
int (**sub_8056E30())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

char byte_804A0D1[2] = { 'f', '\x90' }; // weak
_UNKNOWN loc_804AEC0; // weak
char byte_804B681[2] = { '\x89', '' }; // weak
char locale = '\0'; // idb
char byte_8057B21[16] =
{
  '0',
  '1',
  '2',
  '3',
  '4',
  '5',
  '6',
  '7',
  '8',
  '9',
  'a',
  'b',
  'c',
  'd',
  'e',
  'f'
}; // idb
_UNKNOWN unk_8057B68; // weak
_UNKNOWN unk_8057B74; // weak
_UNKNOWN unk_8057B77; // weak
_UNKNOWN unk_8057CD6; // weak
_UNKNOWN unk_8057CDA; // weak
_UNKNOWN unk_8057CE6; // weak
_UNKNOWN unk_8057CEA; // weak
_UNKNOWN unk_8057CED; // weak
_UNKNOWN unk_8057CEF; // weak
_UNKNOWN unk_8057CF1; // weak
char aLicenseGplv3Gn[64] = "\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/lice"; // idb
char aWrittenBySS[19] = "Written by %s, %s, "; // idb
char aWrittenBySSSSS_2[55] = "Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and othe"; // idb
_UNKNOWN unk_8058348; // weak
char aCopyrightSDFre[31] = "Copyright %s %d Free Software F"; // idb
_UNKNOWN unk_805840B; // weak
_UNKNOWN unk_80591F8; // weak
_UNKNOWN unk_80591FB; // weak
_UNKNOWN unk_805A210; // weak
_UNKNOWN unk_805A213; // weak
int (*off_805BEC8[2])() = { &sub_80491E0, &sub_80491C0 }; // weak
int (*off_805BECC)() = &sub_80491C0; // weak
int (*dword_805C008)(void) = NULL; // weak
int dword_805C10C = 0; // weak
int dword_805C118 = 0; // weak
int dword_805C124 = 0; // weak
int dword_805C130 = 0; // weak
int dword_805C13C = 0; // weak
int dword_805C148 = 0; // weak
int dword_805C154 = 0; // weak
int dword_805C160 = 0; // weak
int dword_805C16C = 0; // weak
int dword_805C178 = 0; // weak
int dword_805C184 = 0; // weak
int dword_805C190 = 0; // weak
int dword_805C19C = 0; // weak
int dword_805C1A8 = 0; // weak
int dword_805C1C8 = 0; // weak
int dword_805C1CC = 4294967295; // weak
int status = 1; // idb
int dword_805C1E4 = 1; // weak
int dword_805C1E8 = 256; // weak
void *off_805C1EC = &unk_805C790; // weak
int *off_805C1F0 = &dword_805C1E8; // weak
_UNKNOWN unk_805C204; // weak
_UNKNOWN unk_805C228; // weak
_UNKNOWN unk_805C22B; // weak
_UNKNOWN unk_805C234; // weak
_UNKNOWN unk_805C237; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int program_invocation_name; // weak
FILE *stdin; // idb
FILE *stdout; // idb
char byte_805C288; // weak
_UNKNOWN unk_805C442; // weak
_UNKNOWN unk_805C68A; // weak
_UNKNOWN unk_805C69A; // weak
char byte_805C71C; // weak
int dword_805C720; // weak
int dword_805C724; // weak
char byte_805C728; // weak
char byte_805C729; // weak
char byte_805C72A; // weak
char byte_805C72B; // weak
char byte_805C72C; // weak
int dword_805C730; // weak
char byte_805C734; // weak
int dword_805C738; // weak
int dword_805C750; // weak
int dword_805C754; // weak
int dword_805C758; // weak
int dword_805C75C; // weak
int dword_805C760; // weak
int dword_805C764; // weak
int dword_805C768; // weak
int dword_805C76C; // weak
int dword_805C770; // weak
int dword_805C774; // weak
int dword_805C778; // weak
int dword_805C77C; // weak
_UNKNOWN unk_805C790; // weak
int dword_805C890; // weak
int dword_805C894; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (08048CCC) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 80490E0: using guessed type int _gmon_start__(void);

//----- (08048CF0) --------------------------------------------------------
int sub_8048CF0()
{
  return dword_805C008();
}
// 805C008: using guessed type int (*dword_805C008)(void);

//----- (080490F0) --------------------------------------------------------
#error "80490F3: positive sp value has been found (funcsize=2)"

//----- (08049123) --------------------------------------------------------
void sub_8049123()
{
  ;
}

//----- (08049140) --------------------------------------------------------
void sub_8049140()
{
  ;
}

//----- (08049150) --------------------------------------------------------
int sub_8049150()
{
  int result; // eax

  result = &unk_805C237 - &unk_805C234;
  if ( (unsigned int)(&unk_805C237 - &unk_805C234) > 6 )
    result = 0;
  return result;
}
// 8049150: could not find valid save-restore pair for ebp

//----- (080491C0) --------------------------------------------------------
int sub_80491C0()
{
  int result; // eax

  if ( !byte_805C288 )
  {
    result = sub_8049150();
    byte_805C288 = 1;
  }
  return result;
}
// 80491C0: could not find valid save-restore pair for ebp
// 805C288: using guessed type char byte_805C288;

//----- (080491E0) --------------------------------------------------------
int sub_80491E0()
{
  return 0;
}
// 80491E0: could not find valid save-restore pair for ebp

//----- (0804927D) --------------------------------------------------------
void sub_804927D()
{
  ;
}

//----- (08049298) --------------------------------------------------------
void sub_8049298()
{
  ;
}

//----- (080492E5) --------------------------------------------------------
signed int sub_80492E5()
{
  return 3;
}
// 80492E5: could not find valid save-restore pair for ebp

//----- (08049407) --------------------------------------------------------
void sub_8049407()
{
  ;
}

//----- (08049422) --------------------------------------------------------
int __usercall sub_8049422@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>)
{
  signed __int32 v7; // ebx
  signed __int32 v8; // edx
  signed __int32 v9; // ebx
  signed __int32 v10; // et0
  signed __int32 v11; // edx
  int v12; // ecx
  signed __int32 v13; // ebx
  signed __int32 v14; // ebx
  signed __int32 v15; // edx
  signed __int32 v16; // ebx
  signed __int32 v17; // et2
  signed __int32 v18; // edx
  int v19; // ecx
  signed __int32 v20; // ebx
  int v22; // [esp-4h] [ebp-4h]

  v22 = a5;
  __asm { pushfw }
  v7 = _InterlockedExchange(&dword_805C10C, a7);
  v10 = _InterlockedExchange(&dword_805C10C, a6);
  v8 = v7;
  v9 = v10;
  _InterlockedExchange(&dword_805C10C, v8);
  if ( sub_804AFDB() != 929 )
  {
    v13 = _InterlockedExchange(&dword_805C10C, v9);
    _InterlockedExchange(&dword_805C10C, v11);
    sub_804AFE5(v12, _InterlockedExchange(&dword_805C10C, v13));
  }
  __asm
  {
    popfw
    pushfw
  }
  v14 = _InterlockedExchange(&dword_805C118, v9);
  v17 = _InterlockedExchange(&dword_805C118, v11);
  v15 = v14;
  v16 = v17;
  _InterlockedExchange(&dword_805C118, v15);
  if ( sub_804A7B7() != 317 )
  {
    v20 = _InterlockedExchange(&dword_805C118, v16);
    _InterlockedExchange(&dword_805C118, v18);
    sub_804A7C1(v19, _InterlockedExchange(&dword_805C118, v20));
  }
  __asm { popfw }
  return v22;
}
// 804A7C1: using guessed type int __fastcall sub_804A7C1(_DWORD, _DWORD);
// 804AFE5: using guessed type int __fastcall sub_804AFE5(_DWORD, _DWORD);
// 805C10C: using guessed type int dword_805C10C;
// 805C118: using guessed type int dword_805C118;

//----- (080494B0) --------------------------------------------------------
int __usercall sub_80494B0@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>)
{
  signed __int32 v6; // eax
  signed __int32 v7; // eax
  int v8; // edx
  signed __int32 v9; // ecx
  signed __int32 v10; // eax
  int result; // eax
  int v12; // [esp+18h] [ebp-4h]

  v12 = a5;
  __asm { pushfw }
  v6 = _InterlockedExchange(&dword_805C10C, a5);
  _InterlockedExchange(&dword_805C10C, a6);
  _InterlockedExchange(&dword_805C10C, v6);
  v7 = sub_804AFDB();
  if ( v7 != 929 )
  {
    v10 = _InterlockedExchange(&dword_805C10C, v7);
    _InterlockedExchange(&dword_805C10C, v9);
    sub_804AFE5(_InterlockedExchange(&dword_805C10C, v10), v8);
  }
  __asm { popfw }
  result = &unk_805C22B - &unk_805C228;
  if ( (unsigned int)(&unk_805C22B - &unk_805C228) > 6 )
    result = 0;
  return result;
}
// 80494B0: could not find valid save-restore pair for ebp
// 804AFE5: using guessed type int __fastcall sub_804AFE5(_DWORD, _DWORD);
// 805C10C: using guessed type int dword_805C10C;

//----- (08049610) --------------------------------------------------------
void sub_8049610()
{
  ;
}

//----- (08049660) --------------------------------------------------------
void sub_8049660()
{
  ;
}

//----- (080496AD) --------------------------------------------------------
int sub_80496AD()
{
  int result; // eax

  result = &unk_805A213 - &unk_805A210;
  if ( (unsigned int)(&unk_805A213 - &unk_805A210) > 6 )
    result = 0;
  return result;
}
// 80496AD: could not find valid save-restore pair for ebp

//----- (0804978F) --------------------------------------------------------
void sub_804978F()
{
  ;
}

//----- (080497E9) --------------------------------------------------------
void __usercall __spoils<edx,ecx> sub_80497E9(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>)
{
  signed __int32 v6; // ebx
  signed __int32 v7; // eax
  signed __int32 v8; // ecx
  signed __int32 v9; // eax

  __asm { pushfw }
  v6 = _InterlockedExchange(&dword_805C130, a6);
  _InterlockedExchange(&dword_805C130, a5);
  _InterlockedExchange(&dword_805C130, v6);
  v7 = sub_804BB55();
  if ( v7 != 654 )
  {
    v9 = _InterlockedExchange(&dword_805C130, v7);
    _InterlockedExchange(&dword_805C130, v8);
    sub_804BB5F(_InterlockedExchange(&dword_805C130, v9));
  }
  __asm { popfw }
}
// 804BB5F: using guessed type int __fastcall sub_804BB5F(_DWORD);
// 805C130: using guessed type int dword_805C130;

//----- (0804986C) --------------------------------------------------------
int sub_804986C()
{
  int result; // eax

  result = &unk_805C22B - &unk_805C228;
  if ( (unsigned int)(&unk_805C22B - &unk_805C228) > 6 )
    result = 0;
  return result;
}
// 804986C: could not find valid save-restore pair for ebp

//----- (08049986) --------------------------------------------------------
void sub_8049986()
{
  ;
}

//----- (080499A1) --------------------------------------------------------
void __usercall __spoils<edx,ecx> sub_80499A1(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>)
{
  char v6; // al
  signed __int32 v7; // ebx
  char v8; // t0

  __asm { pushfw }
  if ( a6 >= 10 )
  {
    v6 = a6;
    v7 = _InterlockedExchange(&dword_805C118, a6);
    v8 = _InterlockedExchange(&dword_805C118, a5);
    _InterlockedExchange(&dword_805C118, v7);
    if ( (v8 - 1) * v6 & 1 )
      abort();
  }
  __asm { popfw }
}
// 80499A1: could not find valid save-restore pair for ebx
// 805C118: using guessed type int dword_805C118;

//----- (080499E6) --------------------------------------------------------
int sub_80499E6()
{
  int result; // eax

  result = &unk_80591FB - &unk_80591F8;
  if ( (unsigned int)(&unk_80591FB - &unk_80591F8) > 6 )
    result = 0;
  return result;
}
// 80499E6: could not find valid save-restore pair for ebp

//----- (08049B6C) --------------------------------------------------------
void sub_8049B6C()
{
  ;
}

//----- (08049BFA) --------------------------------------------------------
void sub_8049BFA()
{
  ;
}

//----- (08049C0A) --------------------------------------------------------
int sub_8049C0A()
{
  int result; // eax

  result = "%s,\n%s, %s, %s, %s,\nand %s.\n" - &aWrittenBySS[16];
  if ( (unsigned int)("%s,\n%s, %s, %s, %s,\nand %s.\n" - &aWrittenBySS[16]) > 6 )
    result = 0;
  return result;
}
// 8049C0A: could not find valid save-restore pair for ebp

//----- (08049DA0) --------------------------------------------------------
void sub_8049DA0()
{
  ;
}

//----- (08049E2D) --------------------------------------------------------
void sub_8049E2D()
{
  ;
}

//----- (08049EB1) --------------------------------------------------------
int sub_8049EB1()
{
  int result; // eax

  result = &unk_805C442 - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_805C442 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 8049EB1: could not find valid save-restore pair for ebp
// 805C240: using guessed type int program_invocation_short_name;

//----- (0804A047) --------------------------------------------------------
void sub_804A047()
{
  ;
}

//----- (0804A04B) --------------------------------------------------------
signed int sub_804A04B()
{
  return -752;
}

//----- (0804A055) --------------------------------------------------------
void __usercall __noreturn sub_804A055(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>)
{
  signed __int32 v7; // eax
  unsigned __int32 v8; // eax
  signed __int32 v9; // ecx
  signed __int32 v14; // eax
  signed __int32 v15; // eax
  signed __int32 v16; // edx
  signed __int32 v17; // ecx
  signed __int32 v18; // eax
  signed __int32 v19; // ebx

  __asm { pushfw }
  v7 = _InterlockedExchange(&dword_805C124, a5);
  _InterlockedExchange(&dword_805C124, a6);
  _InterlockedExchange(&dword_805C124, v7);
  v8 = sub_804C840();
  _CF = v8 < 0x204;
  _OF = __OFSUB__(v8, 516);
  _ZF = v8 == 516;
  _SF = (signed int)(v8 - 516) < 0;
  if ( v8 != 516 )
  {
    __asm { pushfw }
    v14 = _InterlockedExchange(&dword_805C10C, v8);
    _InterlockedExchange(&dword_805C10C, v9);
    _InterlockedExchange(&dword_805C10C, v14);
    v15 = sub_804AFDB();
    if ( v15 != 929 )
    {
      v18 = _InterlockedExchange(&dword_805C10C, v15);
      _InterlockedExchange(&dword_805C10C, v16);
      sub_804AFE5(v17, _InterlockedExchange(&dword_805C10C, v18));
    }
    __asm { popfw }
    v19 = _InterlockedExchange(&dword_805C124, a7);
    _InterlockedExchange(&dword_805C124, v17);
    sub_804C84A(_InterlockedExchange(&dword_805C124, v19));
  }
  __asm { popfw }
  __halt();
  JUMPOUT(*(_DWORD *)byte_804A0D1);
}
// 804AFE5: using guessed type int __fastcall sub_804AFE5(_DWORD, _DWORD);
// 804C84A: using guessed type int __fastcall sub_804C84A(_DWORD);
// 805C10C: using guessed type int dword_805C10C;
// 805C124: using guessed type int dword_805C124;

//----- (0804A15B) --------------------------------------------------------
void sub_804A15B()
{
  ;
}

//----- (0804A1A9) --------------------------------------------------------
int sub_804A1A9()
{
  int result; // eax

  result = "rs.\n" - &aWrittenBySSSSS_2[52];
  if ( (unsigned int)("rs.\n" - &aWrittenBySSSSS_2[52]) > 6 )
    result = 0;
  return result;
}
// 804A1A9: could not find valid save-restore pair for ebp

//----- (0804A335) --------------------------------------------------------
void sub_804A335()
{
  ;
}

//----- (0804A38E) --------------------------------------------------------
void sub_804A38E()
{
  ;
}

//----- (0804A392) --------------------------------------------------------
signed int sub_804A392()
{
  return -637;
}

//----- (0804A413) --------------------------------------------------------
int sub_804A413()
{
  int result; // eax

  result = "u.org/gethelp/>\n" - (char *)&unk_8058348;
  if ( (unsigned int)("u.org/gethelp/>\n" - (char *)&unk_8058348) > 6 )
    result = 0;
  return result;
}
// 804A413: could not find valid save-restore pair for ebp

//----- (0804A52C) --------------------------------------------------------
void sub_804A52C()
{
  ;
}

//----- (0804A57B) --------------------------------------------------------
void sub_804A57B()
{
  ;
}

//----- (0804A629) --------------------------------------------------------
int sub_804A629()
{
  int result; // eax

  result = &unk_805C22B - &unk_805C228;
  if ( (unsigned int)(&unk_805C22B - &unk_805C228) > 6 )
    result = 0;
  return result;
}
// 804A629: could not find valid save-restore pair for ebp

//----- (0804A70B) --------------------------------------------------------
void sub_804A70B()
{
  ;
}

//----- (0804A75A) --------------------------------------------------------
void sub_804A75A()
{
  ;
}

//----- (0804A7A7) --------------------------------------------------------
int sub_804A7A7()
{
  int result; // eax

  result = &unk_805C22B - &unk_805C228;
  if ( (unsigned int)(&unk_805C22B - &unk_805C228) > 6 )
    result = 0;
  return result;
}
// 804A7A7: could not find valid save-restore pair for ebp

//----- (0804A7B7) --------------------------------------------------------
signed int sub_804A7B7()
{
  return 317;
}

//----- (0804A908) --------------------------------------------------------
void sub_804A908()
{
  ;
}

//----- (0804A923) --------------------------------------------------------
void sub_804A923()
{
  ;
}

//----- (0804A927) --------------------------------------------------------
signed __int32 __usercall sub_804A927@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>)
{
  signed __int32 v7; // eax
  unsigned __int32 v8; // eax
  signed __int32 v9; // edx
  signed __int32 v10; // ecx
  char v15; // al
  signed __int32 v16; // ebx
  signed __int32 v17; // et2
  int v18; // eax
  char v23; // al
  signed __int32 v24; // ebx
  signed __int32 v25; // ett
  int v26; // eax
  char v27; // al
  signed __int32 v28; // et0
  char v29; // al
  signed __int32 v30; // ebx
  char v31; // t1
  signed __int32 result; // eax
  signed __int32 v33; // et2

  __asm { pushfw }
  v7 = _InterlockedExchange(&dword_805C178, a5);
  _InterlockedExchange(&dword_805C178, a6);
  _InterlockedExchange(&dword_805C178, v7);
  v8 = sub_8050431();
  if ( v8 != 110 )
    sub_805043B(
      v8 < 0x6E,
      v8 == 110,
      (signed int)(v8 - 110) < 0,
      __OFSUB__(v8, 110),
      _InterlockedExchange(&dword_805C178, v10),
      _InterlockedExchange(&dword_805C178, _InterlockedExchange(&dword_805C178, v8)),
      a7);
  __asm
  {
    popfw
    pushfw
  }
  _CF = (unsigned int)a7 < 0xA;
  _OF = __OFSUB__(a7, 10);
  _ZF = a7 == 10;
  _SF = a7 - 10 < 0;
  if ( a7 >= 10 )
  {
    v15 = a7;
    v16 = _InterlockedExchange(&dword_805C184, a7);
    v17 = _InterlockedExchange(&dword_805C184, v9);
    v9 = _InterlockedExchange(&dword_805C184, v16);
    a7 = v17 - 1;
    v18 = ((_BYTE)v17 - 1) * v15 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = v18 == 0;
    _SF = v18 < 0;
    if ( v18 )
    {
      __asm { pushfw }
      _CF = (unsigned int)a7 < 0xA;
      _OF = __OFSUB__(a7, 10);
      _ZF = a7 == 10;
      _SF = a7 - 10 < 0;
      if ( a7 >= 10 )
      {
        v23 = a7;
        v24 = _InterlockedExchange(&dword_805C130, a7);
        v25 = _InterlockedExchange(&dword_805C130, v10);
        _InterlockedExchange(&dword_805C130, v24);
        a7 = v25 - 1;
        v26 = ((_BYTE)v25 - 1) * v23 & 1;
        _CF = 0;
        _OF = 0;
        _ZF = v26 == 0;
        _SF = v26 < 0;
        if ( v26 )
          abort();
      }
      __asm { pushfw }
      if ( a7 >= 10 )
      {
        v28 = _InterlockedExchange(&dword_805C124, a7);
        v27 = _InterlockedExchange(&dword_805C124, v9);
        _InterlockedExchange(&dword_805C124, v28);
        if ( ((_BYTE)a7 - 1) * v27 & 1 )
          abort();
      }
      __asm
      {
        popfw
        popfw
      }
      abort();
    }
  }
  __asm { pushfw }
  if ( a7 >= 10 )
  {
    v29 = a7;
    v30 = _InterlockedExchange(&dword_805C178, a7);
    v31 = _InterlockedExchange(&dword_805C178, v9);
    _InterlockedExchange(&dword_805C178, v30);
    if ( (v31 - 1) * v29 & 1 )
      abort();
  }
  __asm
  {
    popfw
    popfw
  }
  v33 = _InterlockedExchange(&dword_805C160, 625);
  result = _InterlockedExchange(&dword_805C160, v10);
  _InterlockedExchange(&dword_805C160, v33);
  return result;
}
// 805C124: using guessed type int dword_805C124;
// 805C130: using guessed type int dword_805C130;
// 805C160: using guessed type int dword_805C160;
// 805C178: using guessed type int dword_805C178;
// 805C184: using guessed type int dword_805C184;

//----- (0804AA6F) --------------------------------------------------------
int __usercall sub_804AA6F@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>)
{
  char v8; // al
  signed __int32 v9; // et0
  char v10; // al
  signed __int32 v11; // et1
  signed __int32 v12; // eax
  unsigned __int32 v13; // eax
  signed __int32 v14; // ecx
  char v15; // al
  signed __int32 v16; // et0
  int result; // eax
  int v18; // [esp+18h] [ebp-4h]

  v18 = a5;
  __asm { pushfw }
  if ( a8 >= 10 )
  {
    v9 = _InterlockedExchange(&dword_805C10C, a8);
    v8 = _InterlockedExchange(&dword_805C10C, a7);
    a7 = _InterlockedExchange(&dword_805C10C, v9);
    if ( ((_BYTE)a8 - 1) * v8 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( a8 >= 10 )
  {
    v11 = _InterlockedExchange(&dword_805C118, a8);
    v10 = _InterlockedExchange(&dword_805C118, a6);
    _InterlockedExchange(&dword_805C118, v11);
    if ( ((_BYTE)a8 - 1) * v10 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  v12 = _InterlockedExchange(&dword_805C154, v18);
  _InterlockedExchange(&dword_805C154, a7);
  _InterlockedExchange(&dword_805C154, v12);
  v13 = sub_804A04B();
  if ( v13 != -752 )
    sub_804A055(
      v13 < 0xFFFFFD10,
      v13 == -752,
      (signed int)(v13 + 752) < 0,
      __OFSUB__(v13, -752),
      v13,
      _InterlockedExchange(&dword_805C154, _InterlockedExchange(&dword_805C154, a8)),
      _InterlockedExchange(&dword_805C154, v14));
  __asm
  {
    popfw
    pushfw
  }
  if ( a8 >= 10 )
  {
    v16 = _InterlockedExchange(&dword_805C178, a8);
    v15 = _InterlockedExchange(&dword_805C178, v14);
    _InterlockedExchange(&dword_805C178, v16);
    if ( ((_BYTE)a8 - 1) * v15 & 1 )
      abort();
  }
  __asm { popfw }
  result = "oundation, Inc." - &aCopyrightSDFre[28];
  if ( (unsigned int)("oundation, Inc." - &aCopyrightSDFre[28]) > 6 )
    result = 0;
  return result;
}
// 804AA6F: could not find valid save-restore pair for ebx
// 804AA6F: could not find valid save-restore pair for ebp
// 805C10C: using guessed type int dword_805C10C;
// 805C118: using guessed type int dword_805C118;
// 805C154: using guessed type int dword_805C154;
// 805C178: using guessed type int dword_805C178;

//----- (0804AC63) --------------------------------------------------------
void sub_804AC63()
{
  ;
}

//----- (0804AC7E) --------------------------------------------------------
void __usercall __spoils<edx,ecx> sub_804AC7E(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>)
{
  char v11; // al
  signed __int32 v12; // ebx
  signed __int32 v13; // et0
  int v14; // eax
  char v15; // al
  signed __int32 v16; // et1
  signed __int32 v17; // ebx
  signed __int32 v18; // ecx
  signed __int32 v19; // ebx
  signed __int32 v20; // et2
  signed __int32 v21; // ecx
  signed __int32 v22; // ebx

  __asm { pushfw }
  _CF = (unsigned int)a7 < 0xA;
  _OF = __OFSUB__(a7, 10);
  _ZF = a7 == 10;
  _SF = a7 - 10 < 0;
  if ( a7 >= 10 )
  {
    v11 = a7;
    v12 = _InterlockedExchange(&dword_805C190, a7);
    v13 = _InterlockedExchange(&dword_805C190, a5);
    _InterlockedExchange(&dword_805C190, v12);
    a7 = v13 - 1;
    v14 = ((_BYTE)v13 - 1) * v11 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = v14 == 0;
    _SF = v14 < 0;
    if ( v14 )
      abort();
  }
  __asm { pushfw }
  if ( a7 >= 10 )
  {
    v16 = _InterlockedExchange(&dword_805C124, a7);
    v15 = _InterlockedExchange(&dword_805C124, a6);
    a6 = _InterlockedExchange(&dword_805C124, v16);
    if ( ((_BYTE)a7 - 1) * v15 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  v17 = _InterlockedExchange(&dword_805C130, a7);
  v20 = _InterlockedExchange(&dword_805C130, a6);
  v18 = v17;
  v19 = v20;
  _InterlockedExchange(&dword_805C130, v18);
  if ( sub_804BB55() != 654 )
  {
    v22 = _InterlockedExchange(&dword_805C130, v19);
    _InterlockedExchange(&dword_805C130, v21);
    sub_804BB5F(_InterlockedExchange(&dword_805C130, v22));
  }
  __asm
  {
    popfw
    popfw
  }
}
// 804AC7E: could not find valid save-restore pair for ebx
// 804BB5F: using guessed type int __fastcall sub_804BB5F(_DWORD);
// 805C124: using guessed type int dword_805C124;
// 805C130: using guessed type int dword_805C130;
// 805C190: using guessed type int dword_805C190;

//----- (0804AD6A) --------------------------------------------------------
int __usercall sub_804AD6A@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>)
{
  signed __int32 v11; // eax
  unsigned int v12; // eax
  signed __int32 v13; // edx
  signed __int32 v14; // ecx
  signed __int32 v15; // eax
  signed __int32 v16; // ebx
  char v17; // t2
  signed __int32 v18; // ett
  int result; // eax
  int v20; // [esp+18h] [ebp-4h]

  v20 = a5;
  __asm { pushfw }
  _CF = (unsigned int)a7 < 0xA;
  _OF = __OFSUB__(a7, 10);
  _ZF = a7 == 10;
  _SF = a7 - 10 < 0;
  if ( a7 >= 10 )
  {
    __asm { pushfw }
    v11 = _InterlockedExchange(&dword_805C16C, a5);
    _InterlockedExchange(&dword_805C16C, a6);
    _InterlockedExchange(&dword_805C16C, v11);
    v12 = sub_805344B();
    if ( v12 != 260 )
      sub_8053455(
        v12 < 0x104,
        v12 == 260,
        (signed int)(v12 - 260) < 0,
        __OFSUB__(v12, 260),
        _InterlockedExchange(&dword_805C16C, _InterlockedExchange(&dword_805C16C, a7)),
        v14,
        _InterlockedExchange(&dword_805C16C, v13));
    __asm { popfw }
    v15 = a7;
    v16 = _InterlockedExchange(&dword_805C178, a7);
    v17 = _InterlockedExchange(&dword_805C178, v13);
    v18 = _InterlockedExchange(&dword_805C160, v15);
    LOBYTE(v15) = _InterlockedExchange(&dword_805C160, _InterlockedExchange(&dword_805C178, v16));
    _InterlockedExchange(&dword_805C160, v18);
    if ( (v17 - 1) * (_BYTE)v15 & 1 )
      abort();
  }
  __asm { popfw }
  result = &unk_805C22B - &unk_805C228;
  if ( (unsigned int)(&unk_805C22B - &unk_805C228) > 6 )
    result = 0;
  return result;
}
// 804AD6A: could not find valid save-restore pair for ebp
// 805C160: using guessed type int dword_805C160;
// 805C16C: using guessed type int dword_805C16C;
// 805C178: using guessed type int dword_805C178;

//----- (0804AE45) --------------------------------------------------------
signed int sub_804AE45()
{
  return -91;
}

//----- (0804AE4F) --------------------------------------------------------
void __usercall __noreturn sub_804AE4F(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>)
{
  char v7; // al
  signed __int32 v8; // et0
  signed __int32 v9; // eax
  unsigned __int32 v10; // eax
  signed __int32 v11; // ecx
  signed __int32 v12; // [esp-4h] [ebp-4h]

  v12 = a5;
  __asm { pushfw }
  if ( a7 >= 10 )
  {
    v8 = _InterlockedExchange(&dword_805C13C, a7);
    v7 = _InterlockedExchange(&dword_805C13C, a6);
    a6 = _InterlockedExchange(&dword_805C13C, v8);
    if ( ((_BYTE)a7 - 1) * v7 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  v9 = _InterlockedExchange(&dword_805C178, v12);
  _InterlockedExchange(&dword_805C178, a6);
  _InterlockedExchange(&dword_805C178, v9);
  v10 = sub_8050431();
  if ( v10 != 110 )
    sub_805043B(
      v10 < 0x6E,
      v10 == 110,
      (signed int)(v10 - 110) < 0,
      __OFSUB__(v10, 110),
      v10,
      _InterlockedExchange(&dword_805C178, _InterlockedExchange(&dword_805C178, a7)),
      _InterlockedExchange(&dword_805C178, v11));
  __asm { popfw }
  __halt();
  JUMPOUT(loc_804AEC0);
}
// 805C13C: using guessed type int dword_805C13C;
// 805C178: using guessed type int dword_805C178;

//----- (0804AFD7) --------------------------------------------------------
void sub_804AFD7()
{
  ;
}

//----- (0804AFDB) --------------------------------------------------------
signed int sub_804AFDB()
{
  return 929;
}

//----- (0804B0AD) --------------------------------------------------------
void sub_804B0AD()
{
  ;
}

//----- (0804B164) --------------------------------------------------------
int sub_804B164()
{
  int result; // eax

  result = &unk_8057B77 - &unk_8057B74;
  if ( (unsigned int)(&unk_8057B77 - &unk_8057B74) > 6 )
    result = 0;
  return result;
}
// 804B164: could not find valid save-restore pair for ebp

//----- (0804B370) --------------------------------------------------------
void sub_804B370()
{
  ;
}

//----- (0804B445) --------------------------------------------------------
void __usercall __spoils<edx,ecx> sub_804B445(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>)
{
  char v10; // al
  signed __int32 v11; // ebx
  char v12; // t0
  signed __int32 v13; // ebx
  char v14; // t1
  signed __int32 v15; // [esp-14h] [ebp-14h]

  __asm { pushfw }
  _CF = (unsigned int)a6 < 0xA;
  _OF = __OFSUB__(a6, 10);
  _ZF = a6 == 10;
  _SF = a6 - 10 < 0;
  if ( a6 >= 10 )
  {
    __asm { pushfw }
    v15 = a6;
    if ( a6 >= 10 )
    {
      v10 = a6;
      v11 = _InterlockedExchange(&dword_805C118, a6);
      v12 = _InterlockedExchange(&dword_805C118, a5);
      a5 = _InterlockedExchange(&dword_805C118, v11);
      if ( (v12 - 1) * v10 & 1 )
        abort();
    }
    __asm { popfw }
    v13 = _InterlockedExchange(&dword_805C13C, v15);
    v14 = _InterlockedExchange(&dword_805C13C, a5);
    _InterlockedExchange(&dword_805C13C, v13);
    if ( (v14 - 1) * (_BYTE)v15 & 1 )
      abort();
  }
  __asm { popfw }
}
// 804B445: could not find valid save-restore pair for ebx
// 805C118: using guessed type int dword_805C118;
// 805C13C: using guessed type int dword_805C13C;

//----- (0804B4BF) --------------------------------------------------------
int sub_804B4BF()
{
  int result; // eax

  result = &unk_805C68A - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_805C68A - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 804B4BF: could not find valid save-restore pair for ebp
// 805C240: using guessed type int program_invocation_short_name;

//----- (0804B557) --------------------------------------------------------
signed int __usercall sub_804B557@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>)
{
  char v7; // al
  signed __int32 v8; // et0
  signed __int32 v9; // ebx
  int v10; // eax
  char v19; // al
  signed __int32 v20; // et1
  int v21; // eax
  signed __int32 v22; // ebx
  signed __int32 v23; // edx
  signed __int32 v24; // ebx
  signed __int32 v25; // et2
  int v26; // edx
  signed __int32 v27; // ecx
  signed __int32 v28; // ebx

  __asm { pushfw }
  if ( a7 >= 10 )
  {
    v8 = _InterlockedExchange(&dword_805C148, a7);
    v7 = _InterlockedExchange(&dword_805C148, a6);
    _InterlockedExchange(&dword_805C148, v8);
    v9 = a7 - 1;
    v10 = (_BYTE)v9 * v7 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = v10 == 0;
    _SF = v10 < 0;
    if ( v10 )
    {
      __asm { pushfw }
      _CF = (unsigned int)v9 < 0xA;
      _OF = __OFSUB__(v9, 10);
      _ZF = v9 == 10;
      _SF = v9 - 10 < 0;
      if ( v9 >= 10 )
      {
        v20 = _InterlockedExchange(&dword_805C124, v9);
        v19 = _InterlockedExchange(&dword_805C124, a5);
        a5 = _InterlockedExchange(&dword_805C124, v20);
        v21 = (_BYTE)--v9 * v19 & 1;
        _CF = 0;
        _OF = 0;
        _ZF = v21 == 0;
        _SF = v21 < 0;
        if ( v21 )
          abort();
      }
      __asm { pushfw }
      v22 = _InterlockedExchange(&dword_805C10C, v9);
      v25 = _InterlockedExchange(&dword_805C10C, a5);
      v23 = v22;
      v24 = v25;
      _InterlockedExchange(&dword_805C10C, v23);
      if ( sub_804AFDB() != 929 )
      {
        v28 = _InterlockedExchange(&dword_805C10C, v24);
        _InterlockedExchange(&dword_805C10C, v27);
        sub_804AFE5(_InterlockedExchange(&dword_805C10C, v28), v26);
      }
      __asm
      {
        popfw
        popfw
      }
      abort();
    }
  }
  __asm { popfw }
  return -153;
}
// 804AFE5: using guessed type int __fastcall sub_804AFE5(_DWORD, _DWORD);
// 805C10C: using guessed type int dword_805C10C;
// 805C124: using guessed type int dword_805C124;
// 805C148: using guessed type int dword_805C148;

//----- (0804B60C) --------------------------------------------------------
void __usercall __noreturn sub_804B60C(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>)
{
  signed __int32 v10; // ebx
  signed __int32 v11; // ecx
  signed __int32 v12; // ebx
  signed __int32 v13; // et0
  int v14; // edx
  signed __int32 v15; // ecx
  signed __int32 v16; // ebx
  char v17; // al
  signed __int32 v18; // ebx
  char v19; // t2

  __asm { pushfw }
  _CF = (unsigned int)a6 < 0xA;
  _OF = __OFSUB__(a6, 10);
  _ZF = a6 == 10;
  _SF = a6 - 10 < 0;
  if ( a6 >= 10 )
  {
    __asm { pushfw }
    v10 = _InterlockedExchange(&dword_805C13C, a6);
    v13 = _InterlockedExchange(&dword_805C13C, a5);
    v11 = v10;
    v12 = v13;
    _InterlockedExchange(&dword_805C13C, v11);
    if ( sub_804A392() != -637 )
    {
      v16 = _InterlockedExchange(&dword_805C13C, v12);
      _InterlockedExchange(&dword_805C13C, v15);
      sub_804A39C(_InterlockedExchange(&dword_805C13C, v16), v14);
    }
    __asm { popfw }
    v17 = v12;
    v18 = _InterlockedExchange(&dword_805C19C, v12);
    v19 = _InterlockedExchange(&dword_805C19C, v15);
    _InterlockedExchange(&dword_805C19C, v18);
    if ( (v19 - 1) * v17 & 1 )
      abort();
  }
  __asm { popfw }
  __halt();
  JUMPOUT(*(_DWORD *)byte_804B681);
}
// 804A39C: using guessed type int __fastcall sub_804A39C(_DWORD, _DWORD);
// 805C13C: using guessed type int dword_805C13C;
// 805C19C: using guessed type int dword_805C19C;

//----- (0804B802) --------------------------------------------------------
void sub_804B802()
{
  ;
}

//----- (0804B85B) --------------------------------------------------------
void __usercall __spoils<edx,ecx> sub_804B85B(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>)
{
  char v6; // al
  signed __int32 v7; // et0

  __asm { pushfw }
  if ( a6 >= 10 )
  {
    v7 = _InterlockedExchange(&dword_805C148, a6);
    v6 = _InterlockedExchange(&dword_805C148, a5);
    _InterlockedExchange(&dword_805C148, v7);
    if ( ((_BYTE)a6 - 1) * v6 & 1 )
      abort();
  }
  __asm { popfw }
}
// 804B85B: could not find valid save-restore pair for ebx
// 805C148: using guessed type int dword_805C148;

//----- (0804B9B1) --------------------------------------------------------
int sub_804B9B1()
{
  int result; // eax

  result = &unk_805C69A - (_UNKNOWN *)&program_invocation_name;
  if ( (unsigned int)(&unk_805C69A - (_UNKNOWN *)&program_invocation_name) > 6 )
    result = 0;
  return result;
}
// 804B9B1: could not find valid save-restore pair for ebp
// 805C250: using guessed type int program_invocation_name;

//----- (0804BB55) --------------------------------------------------------
signed int sub_804BB55()
{
  return 654;
}

//----- (0804BB65) --------------------------------------------------------
int __usercall sub_804BB65@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>, int a8@<ebp>, unsigned __int32 a9, signed int a10)
{
  signed __int32 v10; // ebx
  signed __int32 v11; // edx
  signed __int32 v12; // ebx
  signed __int32 v13; // et0
  signed __int32 v14; // eax
  signed __int32 v15; // edx
  signed __int32 v16; // ecx
  signed __int32 v17; // eax
  signed __int32 v18; // ebx
  signed __int32 v19; // edx
  signed __int32 v20; // edx
  signed __int32 v21; // ebx
  signed __int32 v22; // et2
  unsigned int v23; // eax
  signed __int32 v24; // edx
  signed __int32 v29; // ebx
  signed __int32 v30; // edx
  signed __int32 v31; // ebx
  signed __int32 v32; // ett
  unsigned int v33; // eax
  signed __int32 v34; // edx
  signed __int32 v35; // ecx
  char v40; // al
  signed __int32 v41; // et0
  signed __int32 v42; // ebx
  signed __int32 v43; // eax
  signed __int32 v44; // et2
  signed __int32 v45; // edx
  signed __int32 v46; // ecx
  char v47; // al
  signed __int32 v48; // ebx
  char v49; // t0
  signed __int32 v50; // eax
  signed __int32 v52; // [esp-Ah] [ebp-36h]
  signed __int32 v53; // [esp-Ah] [ebp-36h]
  signed __int32 v54; // [esp-4h] [ebp-30h]
  int v55; // [esp+28h] [ebp-4h]

  v55 = a5;
  __asm { pushfw }
  v10 = _InterlockedExchange(&dword_805C124, a7);
  v13 = _InterlockedExchange(&dword_805C124, a6);
  v11 = v10;
  v12 = v13;
  _InterlockedExchange(&dword_805C124, v11);
  v14 = sub_804C840();
  if ( v14 != 516 )
  {
    v17 = _InterlockedExchange(&dword_805C124, v14);
    _InterlockedExchange(&dword_805C124, v15);
    _InterlockedExchange(&dword_805C124, v17);
    sub_804C84A(v16);
  }
  __asm { popfw }
  v55 = a8;
  if ( !a10 )
    return a9;
  v54 = sub_80563B2(0, a10 == 0, a10 < 0, 0, v16, v12, a9, a10, 1000000LL);
  __asm { pushfw }
  v18 = _InterlockedExchange(&dword_805C178, v12);
  v22 = _InterlockedExchange(&dword_805C178, v19);
  v20 = v18;
  v21 = v22;
  _InterlockedExchange(&dword_805C178, v20);
  v23 = sub_8050431();
  _CF = v23 < 0x6E;
  _OF = __OFSUB__(v23, 110);
  _ZF = v23 == 110;
  _SF = (signed int)(v23 - 110) < 0;
  if ( v23 != 110 )
  {
    v52 = v23;
    __asm { pushfw }
    v29 = _InterlockedExchange(&dword_805C130, v21);
    v32 = _InterlockedExchange(&dword_805C130, v24);
    v30 = v29;
    v31 = v32;
    _InterlockedExchange(&dword_805C130, v30);
    v33 = sub_804BB55();
    _CF = v33 < 0x28E;
    _OF = __OFSUB__(v33, 654);
    _ZF = v33 == 654;
    _SF = (signed int)(v33 - 654) < 0;
    if ( v33 != 654 )
    {
      __asm { pushfw }
      if ( v31 >= 10 )
      {
        v41 = _InterlockedExchange(&dword_805C10C, v31);
        v40 = _InterlockedExchange(&dword_805C10C, v35);
        v35 = _InterlockedExchange(&dword_805C10C, v41);
        if ( ((_BYTE)v31 - 1) * v40 & 1 )
          abort();
      }
      __asm { popfw }
      v42 = _InterlockedExchange(&dword_805C130, v31);
      _InterlockedExchange(&dword_805C130, v34);
      _InterlockedExchange(&dword_805C130, v42);
      sub_804BB5F(v35);
    }
    __asm { popfw }
    v44 = _InterlockedExchange(&dword_805C178, v52);
    v43 = _InterlockedExchange(&dword_805C178, v34);
    _InterlockedExchange(&dword_805C178, v44);
    sub_805043B(_CF, _ZF, _SF, _OF, v43, v35, v31);
  }
  __asm
  {
    popfw
    pushfw
  }
  v53 = sub_804A927(
          _CF,
          _ZF,
          _SF,
          _OF,
          _InterlockedExchange(&dword_805C190, v24),
          _InterlockedExchange(&dword_805C190, _InterlockedExchange(&dword_805C190, v54)),
          v21);
  __asm { pushfw }
  if ( v21 >= 10 )
  {
    v47 = v21;
    v48 = _InterlockedExchange(&dword_805C184, v21);
    v49 = _InterlockedExchange(&dword_805C184, v46);
    v46 = _InterlockedExchange(&dword_805C184, v48);
    if ( (v49 - 1) * v47 & 1 )
      abort();
  }
  __asm { popfw }
  if ( v53 != 625 )
  {
    v50 = _InterlockedExchange(&dword_805C190, v53);
    _InterlockedExchange(&dword_805C190, v45);
    sub_804AA62(v46, _InterlockedExchange(&dword_805C190, v50));
  }
  __asm { popfw }
  return v54 + 1000000;
}
// 804BB65: could not find valid save-restore pair for ebp
// 804AA62: using guessed type int __fastcall sub_804AA62(_DWORD, _DWORD);
// 804BB5F: using guessed type int __fastcall sub_804BB5F(_DWORD);
// 804C84A: using guessed type int __fastcall sub_804C84A(_DWORD);
// 805C10C: using guessed type int dword_805C10C;
// 805C124: using guessed type int dword_805C124;
// 805C130: using guessed type int dword_805C130;
// 805C178: using guessed type int dword_805C178;
// 805C184: using guessed type int dword_805C184;
// 805C190: using guessed type int dword_805C190;

//----- (0804BD12) --------------------------------------------------------
int __usercall sub_804BD12@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, int a3, unsigned int a4)
{
  unsigned int v4; // edx
  unsigned int v5; // eax
  signed __int32 v10; // ebx
  signed __int32 v11; // ecx
  signed __int32 v12; // ebx
  signed __int32 v13; // et0
  signed __int32 v14; // eax
  signed __int32 v15; // edx
  signed __int32 v16; // ecx
  signed __int32 v17; // eax
  int result; // eax
  signed __int32 v19; // ebx
  int v20; // [esp-4h] [ebp-14h]

  v4 = -((a4 - 1 + a3) % a4);
  v5 = a4 - 1 + a3;
  _CF = __CFADD__(v4, v5);
  _OF = __OFADD__(v4, v5);
  _ZF = v5 == v5 % a4;
  _SF = (signed int)(v5 - v5 % a4) < 0;
  v20 = v5 - v5 % a4;
  __asm { pushfw }
  v10 = _InterlockedExchange(&dword_805C13C, a2);
  v13 = _InterlockedExchange(&dword_805C13C, a1);
  v11 = v10;
  v12 = v13;
  _InterlockedExchange(&dword_805C13C, v11);
  v14 = sub_804A392();
  if ( v14 != -637 )
  {
    v17 = _InterlockedExchange(&dword_805C13C, v14);
    _InterlockedExchange(&dword_805C13C, v15);
    sub_804A39C(v16, _InterlockedExchange(&dword_805C13C, v17));
  }
  __asm { popfw }
  result = v20;
  v19 = _InterlockedExchange(&dword_805C160, v12);
  _InterlockedExchange(&dword_805C160, v16);
  _InterlockedExchange(&dword_805C160, v19);
  return result;
}
// 804A39C: using guessed type int __fastcall sub_804A39C(_DWORD, _DWORD);
// 805C13C: using guessed type int dword_805C13C;
// 805C160: using guessed type int dword_805C160;

//----- (0804BDA2) --------------------------------------------------------
signed __int32 __usercall sub_804BDA2@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>)
{
  char v7; // al
  signed __int32 v8; // ebx
  char v9; // t0
  FILE *v10; // ebx
  char *v11; // eax
  signed __int32 v12; // ebx
  signed __int32 v13; // ecx
  signed __int32 v14; // et1
  signed __int32 v15; // ebx
  signed __int32 v16; // ecx
  signed __int32 v17; // ecx
  signed __int32 v18; // ebx
  signed __int32 v19; // et2
  signed __int32 v20; // edx
  signed __int32 v21; // ecx
  signed __int32 v22; // ebx
  signed __int32 v23; // eax
  signed __int32 v24; // eax
  unsigned __int32 v25; // eax
  signed __int32 v26; // ecx
  signed __int32 v31; // ebx
  signed __int32 v32; // ecx
  signed __int32 v33; // ebx
  signed __int32 v34; // ett
  signed __int32 v35; // ecx
  signed __int32 v36; // ebx
  signed __int32 v38; // [esp-Ah] [ebp-26h]
  signed __int32 v39; // [esp-4h] [ebp-20h]
  int v40; // [esp+18h] [ebp-4h]

  v40 = a5;
  __asm { pushfw }
  if ( a7 >= 10 )
  {
    v7 = a7;
    v8 = _InterlockedExchange(&dword_805C118, a7);
    v9 = _InterlockedExchange(&dword_805C118, a6);
    _InterlockedExchange(&dword_805C118, v8);
    if ( (v9 - 1) * v7 & 1 )
      abort();
  }
  __asm { popfw }
  v10 = stdout;
  v11 = gettext("\nWith no FILE, or when FILE is -, read standard input.\n");
  v39 = fputs_unlocked(v11, v10);
  __asm { pushfw }
  v12 = _InterlockedExchange(&dword_805C130, (signed __int32)v10);
  v14 = _InterlockedExchange(&dword_805C130, v13);
  _InterlockedExchange(&dword_805C130, v12);
  v38 = sub_804BB55();
  __asm { pushfw }
  v15 = _InterlockedExchange(&dword_805C124, v14);
  v19 = _InterlockedExchange(&dword_805C124, v16);
  v17 = v15;
  v18 = v19;
  _InterlockedExchange(&dword_805C124, v17);
  if ( sub_804C840() != 516 )
  {
    v22 = _InterlockedExchange(&dword_805C124, v18);
    _InterlockedExchange(&dword_805C124, v21);
    sub_804C84A(_InterlockedExchange(&dword_805C124, v22));
  }
  __asm { popfw }
  if ( v38 != 654 )
  {
    v23 = _InterlockedExchange(&dword_805C130, v38);
    _InterlockedExchange(&dword_805C130, v20);
    _InterlockedExchange(&dword_805C130, v23);
    sub_804BB5F(v21);
  }
  __asm
  {
    popfw
    pushfw
  }
  v24 = _InterlockedExchange(&dword_805C184, v39);
  _InterlockedExchange(&dword_805C184, v21);
  _InterlockedExchange(&dword_805C184, v24);
  v25 = sub_804AE45();
  _CF = v25 < 0xFFFFFFA5;
  _OF = __OFSUB__(v25, -91);
  _ZF = v25 == -91;
  _SF = (signed int)(v25 + 91) < 0;
  if ( v25 != -91 )
    sub_804AE4F(
      v25 < 0xFFFFFFA5,
      v25 == -91,
      (signed int)(v25 + 91) < 0,
      __OFSUB__(v25, -91),
      _InterlockedExchange(&dword_805C184, v26),
      _InterlockedExchange(&dword_805C184, _InterlockedExchange(&dword_805C184, v25)),
      v18);
  __asm { pushfw }
  v31 = _InterlockedExchange(&dword_805C148, v18);
  v34 = _InterlockedExchange(&dword_805C148, v26);
  v32 = v31;
  v33 = v34;
  _InterlockedExchange(&dword_805C148, v32);
  if ( sub_804FCF9() != 863 )
  {
    v36 = _InterlockedExchange(&dword_805C148, v33);
    _InterlockedExchange(&dword_805C148, v35);
    sub_804FD03(_InterlockedExchange(&dword_805C148, v36));
  }
  __asm
  {
    popfw
    popfw
  }
  return v39;
}
// 804BDA2: could not find valid save-restore pair for ebx
// 8048F20: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 804BB5F: using guessed type int __fastcall sub_804BB5F(_DWORD);
// 804C84A: using guessed type int __fastcall sub_804C84A(_DWORD);
// 804FD03: using guessed type int __fastcall sub_804FD03(_DWORD);
// 805C118: using guessed type int dword_805C118;
// 805C124: using guessed type int dword_805C124;
// 805C130: using guessed type int dword_805C130;
// 805C148: using guessed type int dword_805C148;
// 805C184: using guessed type int dword_805C184;

//----- (0804BEF9) --------------------------------------------------------
int __usercall sub_804BEF9@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, const char *a9)
{
  signed __int32 v9; // eax
  signed __int32 v10; // et0
  signed __int32 v11; // edx
  signed __int32 v12; // ecx
  signed __int32 v13; // ebx
  signed __int32 v14; // ebx
  signed __int32 v15; // edx
  signed __int32 v16; // ebx
  signed __int32 v17; // et2
  char *v18; // eax
  char *v19; // eax
  char *v20; // eax
  char *v21; // eax
  signed __int32 v22; // edx
  char v23; // al
  signed __int32 v24; // ebx
  char v25; // tt
  char *v30; // ebx
  signed __int32 v31; // ebx
  char v32; // t0
  char *v33; // eax
  signed __int32 v35; // [esp-Ah] [ebp-76h]
  unsigned int v36; // [esp+1Ch] [ebp-50h]
  const char **i; // [esp+20h] [ebp-4Ch]
  const char *v38; // [esp+24h] [ebp-48h]
  const char *v39; // [esp+28h] [ebp-44h]
  const char *v40; // [esp+2Ch] [ebp-40h]
  const char *v41; // [esp+30h] [ebp-3Ch]
  const char *v42; // [esp+34h] [ebp-38h]
  const char *v43; // [esp+38h] [ebp-34h]
  const char *v44; // [esp+3Ch] [ebp-30h]
  const char *v45; // [esp+40h] [ebp-2Ch]
  const char *v46; // [esp+44h] [ebp-28h]
  const char *v47; // [esp+48h] [ebp-24h]
  const char *v48; // [esp+4Ch] [ebp-20h]
  const char *v49; // [esp+50h] [ebp-1Ch]
  const char *v50; // [esp+54h] [ebp-18h]
  int v51; // [esp+58h] [ebp-14h]
  int v52; // [esp+5Ch] [ebp-10h]
  int v53; // [esp+64h] [ebp-8h]
  int v54; // [esp+68h] [ebp-4h]

  v54 = a5;
  __asm { pushfw }
  v10 = _InterlockedExchange(&dword_805C190, a5);
  v9 = _InterlockedExchange(&dword_805C190, a7);
  _InterlockedExchange(&dword_805C190, v10);
  if ( sub_804A927(_CF, _ZF, _SF, _OF, v9, a6, a8) != 625 )
  {
    v13 = _InterlockedExchange(&dword_805C190, a8);
    _InterlockedExchange(&dword_805C190, v12);
    sub_804AA62(_InterlockedExchange(&dword_805C190, v13), v11);
  }
  __asm { popfw }
  v53 = a8;
  v39 = "[";
  v40 = "test invocation";
  v41 = "coreutils";
  v42 = "Multi-call invocation";
  v14 = _InterlockedExchange(&dword_805C160, a8);
  v17 = _InterlockedExchange(&dword_805C160, v11);
  v15 = v14;
  v16 = v17;
  _InterlockedExchange(&dword_805C160, v15);
  v43 = "sha224sum";
  v44 = "sha2 utilities";
  v45 = "sha256sum";
  v46 = "sha2 utilities";
  v47 = "sha384sum";
  v48 = "sha2 utilities";
  v49 = "sha512sum";
  v50 = "sha2 utilities";
  v51 = 0;
  v52 = 0;
  v36 = (unsigned int)a9;
  for ( i = &v39; *i && strcmp(a9, *i); i += 2 )
    ;
  if ( i[1] )
    v36 = (unsigned int)i[1];
  v18 = gettext("\n%s online help: <%s>\n");
  printf(v18, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  v19 = setlocale(5, 0);
  v38 = v19;
  if ( v19 && strncmp(v38, "en_", 3u) )
  {
    v20 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
    printf(v20, a9);
  }
  v21 = gettext("Full documentation at: <%s%s>\n");
  printf(v21, "http://www.gnu.org/software/coreutils/", a9);
  __asm { pushfw }
  v35 = v16;
  if ( v16 >= 10 )
  {
    v23 = v16;
    v24 = _InterlockedExchange(&dword_805C148, v16);
    v25 = _InterlockedExchange(&dword_805C148, v22);
    v22 = _InterlockedExchange(&dword_805C148, v24);
    if ( (v25 - 1) * v23 & 1 )
      abort();
  }
  __asm { popfw }
  _CF = v36 < (unsigned int)a9;
  _OF = __OFSUB__(v36, a9);
  _ZF = v36 == (_DWORD)a9;
  _SF = (signed int)(v36 - (_DWORD)a9) < 0;
  if ( (const char *)v36 == a9 )
  {
    v30 = " invocation";
  }
  else
  {
    __asm { pushfw }
    if ( v35 >= 10 )
    {
      v31 = _InterlockedExchange(&dword_805C13C, v35);
      v32 = _InterlockedExchange(&dword_805C13C, v22);
      _InterlockedExchange(&dword_805C13C, v31);
      if ( (v32 - 1) * (_BYTE)v35 & 1 )
        abort();
    }
    __asm { popfw }
    v30 = &locale;
  }
  v33 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  return printf(v33, v36, v30);
}
// 804AA62: using guessed type int __fastcall sub_804AA62(_DWORD, _DWORD);
// 805C13C: using guessed type int dword_805C13C;
// 805C148: using guessed type int dword_805C148;
// 805C160: using guessed type int dword_805C160;
// 805C190: using guessed type int dword_805C190;

//----- (0804C1BA) --------------------------------------------------------
int __cdecl sub_804C1BA(int a1)
{
  return a1;
}

//----- (0804C1C2) --------------------------------------------------------
void __usercall __noreturn sub_804C1C2(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, int a8)
{
  signed __int32 v8; // eax
  signed __int32 v9; // eax
  signed __int32 v10; // edx
  int v11; // ecx
  signed __int32 v12; // eax
  signed __int32 v13; // ebx
  signed __int32 v14; // edx
  signed __int32 v15; // ebx
  signed __int32 v16; // et2
  signed __int32 v17; // eax
  signed __int32 v18; // edx
  signed __int32 v19; // ecx
  signed __int32 v20; // eax
  char v21; // al
  signed __int32 v22; // et0
  int v27; // ebx
  char *format; // eax
  signed __int32 v29; // eax
  signed __int32 v30; // edx
  int v31; // ecx
  signed __int32 v32; // ebx
  signed __int32 v33; // ebx
  char *v34; // eax
  int v35; // eax
  signed __int32 v36; // edx
  signed __int32 v37; // edx
  signed __int32 v38; // ecx
  char v39; // al
  signed __int32 v40; // ebx
  char v41; // tt
  signed __int32 v42; // eax
  unsigned __int32 v43; // eax
  signed __int32 v44; // ecx
  bool v45; // cf
  bool v46; // zf
  bool v47; // sf
  char v48; // of
  signed __int32 v49; // eax
  FILE *v50; // ebx
  char *v51; // eax
  char *v52; // eax
  FILE *v53; // ebx
  char *v54; // eax
  FILE *v55; // ebx
  signed __int32 v56; // ecx
  char v57; // al
  signed __int32 v58; // ebx
  char v59; // t2
  FILE *v60; // ebx
  char *v61; // eax
  FILE *v62; // ebx
  char *v63; // eax
  char *v64; // eax
  int v65; // eax
  signed __int32 v66; // edx
  signed __int32 v67; // ecx
  FILE *v68; // ebx
  char *v69; // eax
  signed __int32 v70; // [esp-Ah] [ebp-26h]
  FILE *v71; // [esp-Ah] [ebp-26h]
  signed __int32 v72; // [esp-4h] [ebp-20h]
  char *v73; // [esp-4h] [ebp-20h]
  int v74; // [esp+18h] [ebp-4h]

  v74 = a5;
  __asm { pushfw }
  v8 = _InterlockedExchange(&dword_805C10C, a5);
  _InterlockedExchange(&dword_805C10C, a6);
  _InterlockedExchange(&dword_805C10C, v8);
  v9 = sub_804AFDB();
  if ( v9 != 929 )
  {
    v12 = _InterlockedExchange(&dword_805C10C, v9);
    _InterlockedExchange(&dword_805C10C, v10);
    sub_804AFE5(v11, _InterlockedExchange(&dword_805C10C, v12));
  }
  __asm
  {
    popfw
    pushfw
  }
  v13 = _InterlockedExchange(&dword_805C13C, a7);
  v16 = _InterlockedExchange(&dword_805C13C, v10);
  v14 = v13;
  v15 = v16;
  _InterlockedExchange(&dword_805C13C, v14);
  v17 = sub_804A392();
  if ( v17 != -637 )
  {
    v20 = _InterlockedExchange(&dword_805C13C, v17);
    _InterlockedExchange(&dword_805C13C, v19);
    sub_804A39C(_InterlockedExchange(&dword_805C13C, v20), v18);
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( v15 >= 10 )
  {
    v22 = _InterlockedExchange(&dword_805C148, v15);
    v21 = _InterlockedExchange(&dword_805C148, v18);
    _InterlockedExchange(&dword_805C148, v22);
    if ( ((_BYTE)v15 - 1) * v21 & 1 )
      abort();
  }
  __asm { popfw }
  _CF = 0;
  _OF = 0;
  _ZF = a8 == 0;
  _SF = a8 < 0;
  if ( a8 )
  {
    v27 = dword_805C738;
    format = gettext("Try '%s --help' for more information.\n");
    fprintf(stderr, format, v27);
  }
  else
  {
    __asm { pushfw }
    v29 = _InterlockedExchange(&dword_805C130, v74);
    _InterlockedExchange(&dword_805C130, v19);
    _InterlockedExchange(&dword_805C130, v29);
    if ( sub_804BB55() != 654 )
    {
      v32 = _InterlockedExchange(&dword_805C130, v15);
      _InterlockedExchange(&dword_805C130, v30);
      _InterlockedExchange(&dword_805C130, v32);
      sub_804BB5F(v31);
    }
    __asm { popfw }
    v33 = dword_805C738;
    v34 = gettext("Usage: %s [OPTION]... [FILE]...\nPrint or check %s (%d-bit) checksums.\n");
    v35 = printf(v34, v33, "MD5", 128);
    v72 = sub_804BDA2(_CF, _ZF, _SF, _OF, v35, v36, v33);
    __asm { pushfw }
    v70 = v33;
    if ( v33 >= 10 )
    {
      v39 = v33;
      v40 = _InterlockedExchange(&dword_805C13C, v33);
      v41 = _InterlockedExchange(&dword_805C13C, v37);
      v37 = _InterlockedExchange(&dword_805C13C, v40);
      if ( (v41 - 1) * v39 & 1 )
        abort();
    }
    __asm
    {
      popfw
      pushfw
    }
    v42 = _InterlockedExchange(&dword_805C1A8, v72);
    _InterlockedExchange(&dword_805C1A8, v38);
    v43 = sub_804B557(_CF, _ZF, _SF, _OF, v37, _InterlockedExchange(&dword_805C1A8, v42), v70);
    v45 = v43 < 0xFFFFFF67;
    v48 = __OFSUB__(v43, -153);
    v46 = v43 == -153;
    v47 = (signed int)(v43 + 153) < 0;
    if ( v43 != -153 )
    {
      v49 = _InterlockedExchange(&dword_805C1A8, v43);
      _InterlockedExchange(&dword_805C1A8, v44);
      sub_804B60C(v45, v46, v47, v48, _InterlockedExchange(&dword_805C1A8, v49), v70);
    }
    __asm { popfw }
    v50 = stdout;
    v51 = gettext("\n  -b, --binary         read in binary mode\n");
    fputs_unlocked(v51, v50);
    v52 = gettext("  -c, --check          read %s sums from the FILEs and check them\n");
    printf(v52, "MD5");
    v53 = stdout;
    v54 = gettext("      --tag            create a BSD-style checksum\n");
    fputs_unlocked(v54, v53);
    v55 = stdout;
    v73 = gettext("  -t, --text           read in text mode (default)\n");
    __asm { pushfw }
    v71 = v55;
    if ( (signed int)v55 >= 10 )
    {
      v57 = (char)v55;
      v58 = _InterlockedExchange(&dword_805C190, (signed __int32)v55);
      v59 = _InterlockedExchange(&dword_805C190, v56);
      _InterlockedExchange(&dword_805C190, v58);
      if ( (v59 - 1) * v57 & 1 )
        abort();
    }
    __asm { popfw }
    fputs_unlocked(v73, v71);
    v68 = stdout;
    v69 = gettext(
            "\n"
            "The following five options are useful only when verifying checksums:\n"
            "      --ignore-missing  don't fail or report status for missing files\n"
            "      --quiet          don't print OK for each successfully verified file\n"
            "      --status         don't output anything, status code shows success\n"
            "      --strict         exit non-zero for improperly formatted checksum lines\n"
            "  -w, --warn           warn about improperly formatted checksum lines\n"
            "\n");
    fputs_unlocked(v69, v68);
    v60 = stdout;
    v61 = gettext("      --help     display this help and exit\n");
    fputs_unlocked(v61, v60);
    v62 = stdout;
    v63 = gettext("      --version  output version information and exit\n");
    fputs_unlocked(v63, v62);
    v64 = gettext(
            "\n"
            "The sums are computed as described in %s.  When checking, the input\n"
            "should be a former output of this program.  The default mode is to print a\n"
            "line with checksum, a space, a character indicating input mode ('*' for binary,\n"
            "' ' for text or where binary is insignificant), and name for each FILE.\n");
    v65 = printf(v64, "RFC 1321");
    sub_804BEF9(_CF, _ZF, _SF, _OF, v65, v66, v67, (signed __int32)v62, "md5sum");
  }
  exit(a8);
}
// 8048F20: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 804A39C: using guessed type int __fastcall sub_804A39C(_DWORD, _DWORD);
// 804AFE5: using guessed type int __fastcall sub_804AFE5(_DWORD, _DWORD);
// 804BB5F: using guessed type int __fastcall sub_804BB5F(_DWORD);
// 805C10C: using guessed type int dword_805C10C;
// 805C130: using guessed type int dword_805C130;
// 805C13C: using guessed type int dword_805C13C;
// 805C148: using guessed type int dword_805C148;
// 805C190: using guessed type int dword_805C190;
// 805C1A8: using guessed type int dword_805C1A8;
// 805C738: using guessed type int dword_805C738;

//----- (0804C516) --------------------------------------------------------
_BYTE *__usercall sub_804C516@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, int a9@<ebp>, _BYTE *a10, unsigned int a11)
{
  char v11; // al
  signed __int32 v12; // ebx
  char v13; // t0
  signed __int32 v14; // ebx
  int v20; // eax
  _BYTE *v21; // eax
  _BYTE *v22; // eax
  _BYTE *v23; // eax
  signed __int32 v24; // ebx
  signed __int32 v25; // et1
  signed __int32 v26; // ebx
  signed __int32 v27; // edx
  signed __int32 v28; // edx
  signed __int32 v29; // et2
  signed __int32 v30; // edx
  signed __int32 v31; // ebx
  signed __int32 v32; // ebx
  signed __int32 v33; // et0
  unsigned int v34; // [esp-1Eh] [ebp-1Eh]
  _BYTE *v35; // [esp-Ch] [ebp-Ch]
  signed __int32 v36; // [esp-Ah] [ebp-Ah]
  unsigned int i; // [esp-8h] [ebp-8h]
  int v38; // [esp-4h] [ebp-4h]

  v38 = a5;
  __asm { pushfw }
  v36 = a8;
  if ( a8 >= 10 )
  {
    v11 = a8;
    v12 = _InterlockedExchange(&dword_805C154, a8);
    v13 = _InterlockedExchange(&dword_805C154, a6);
    a6 = _InterlockedExchange(&dword_805C154, v12);
    if ( (v13 - 1) * v11 & 1 )
      abort();
  }
  v14 = v36;
  __asm { popfw }
  v38 = a9;
  _CF = (unsigned int)&v38 < 0x10;
  _OF = __OFSUB__(&v38, 16);
  _ZF = &v38 == 0;
  _SF = (signed int)&v38 < 0;
  v35 = a10;
  for ( i = 0; ; ++i )
  {
    __asm { pushfw }
    v24 = _InterlockedExchange(&dword_805C1A8, v14);
    v25 = _InterlockedExchange(&dword_805C1A8, a6);
    v34 = sub_804B557(_CF, _ZF, _SF, _OF, _InterlockedExchange(&dword_805C1A8, v24), a7, v25);
    __asm { pushfw }
    v26 = _InterlockedExchange(&dword_805C13C, v25);
    v29 = _InterlockedExchange(&dword_805C13C, v27);
    v28 = v26;
    v14 = v29;
    _InterlockedExchange(&dword_805C13C, v28);
    if ( sub_804A392() != -637 )
    {
      v31 = _InterlockedExchange(&dword_805C13C, v14);
      _InterlockedExchange(&dword_805C13C, a7);
      sub_804A39C(_InterlockedExchange(&dword_805C13C, v31), v30);
    }
    __asm { popfw }
    if ( v34 != -153 )
    {
      v32 = _InterlockedExchange(&dword_805C1A8, v14);
      v33 = _InterlockedExchange(&dword_805C1A8, v30);
      _InterlockedExchange(&dword_805C1A8, v32);
      sub_804B60C(v34 < 0xFFFFFF67, v34 == -153, (signed int)(v34 + 153) < 0, __OFSUB__(v34, -153), a7, v33);
    }
    __asm { popfw }
    if ( i >= a11 )
      break;
    if ( !a10[i] )
      return 0;
    if ( a10[i] == 92 )
    {
      if ( a11 - 1 == i )
        return 0;
      v20 = (char)a10[++i];
      if ( v20 == 92 )
      {
        v22 = v35;
        a6 = (signed __int32)(v35++ + 1);
        *v22 = 92;
      }
      else
      {
        if ( v20 != 110 )
          return 0;
        v21 = v35;
        a6 = (signed __int32)(v35++ + 1);
        *v21 = 10;
      }
    }
    else
    {
      v23 = v35++;
      a7 = (signed __int32)a10;
      a6 = (unsigned __int8)a10[i];
      *v23 = a6;
    }
    _CF = __CFADD__(i, 1);
    _OF = __OFADD__(1, i);
    _ZF = i == -1;
    _SF = (signed int)(i + 1) < 0;
  }
  if ( &a10[a11] > v35 )
    *v35 = 0;
  return a10;
}
// 804C516: could not find valid save-restore pair for ebp
// 804A39C: using guessed type int __fastcall sub_804A39C(_DWORD, _DWORD);
// 805C13C: using guessed type int dword_805C13C;
// 805C154: using guessed type int dword_805C154;
// 805C1A8: using guessed type int dword_805C1A8;

//----- (0804C699) --------------------------------------------------------
bool __usercall sub_804C699@<al>(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, _BYTE *a4)
{
  const unsigned __int16 **v8; // eax
  signed __int32 v9; // ecx
  signed __int32 v10; // et0
  int v11; // eax
  signed __int32 v16; // eax
  signed __int32 v17; // ebx
  signed __int32 v18; // edx
  signed __int32 v19; // edx
  signed __int32 v20; // ebx
  signed __int32 v21; // et2
  signed __int32 v22; // eax
  signed __int32 v23; // edx
  int v24; // ecx
  signed __int32 v25; // eax
  signed __int32 v30; // eax
  signed __int32 v31; // eax
  signed __int32 v32; // edx
  signed __int32 v33; // ecx
  signed __int32 v34; // eax
  signed __int32 v35; // eax
  char v37; // al
  signed __int32 v38; // ebx
  char v39; // tt
  signed __int32 v40; // ebx
  char v41; // t0
  unsigned __int32 v42; // [esp-Ah] [ebp-22h]
  signed __int32 v43; // [esp-Ah] [ebp-22h]
  unsigned int i; // [esp+Ch] [ebp-Ch]

  _CF = 0;
  _ZF = 0;
  _OF = 0;
  for ( i = 0; ; ++i )
  {
    __asm { pushfw }
    v43 = a3;
    if ( a3 >= 10 )
    {
      v37 = a3;
      v38 = _InterlockedExchange(&dword_805C178, a3);
      v39 = _InterlockedExchange(&dword_805C178, a2);
      _InterlockedExchange(&dword_805C178, v38);
      if ( (v39 - 1) * v37 & 1 )
        abort();
    }
    __asm
    {
      popfw
      pushfw
    }
    if ( v43 >= 10 )
    {
      v40 = _InterlockedExchange(&dword_805C1A8, v43);
      v41 = _InterlockedExchange(&dword_805C1A8, a1);
      _InterlockedExchange(&dword_805C1A8, v40);
      if ( (v41 - 1) * (_BYTE)v43 & 1 )
        abort();
    }
    a3 = v43;
    __asm { popfw }
    if ( i >= dword_805C724 )
      return *a4 == 0;
    v8 = __ctype_b_loc();
    a1 = (signed __int32)*v8;
    v10 = _InterlockedExchange(&dword_805C160, (*v8)[(unsigned __int8)*a4]);
    LOWORD(v8) = _InterlockedExchange(&dword_805C160, v9);
    a2 = _InterlockedExchange(&dword_805C160, v10);
    v11 = (unsigned __int16)v8 & 0x1000;
    _CF = 0;
    _OF = 0;
    _ZF = v11 == 0;
    _SF = v11 < 0;
    if ( !v11 )
      break;
    ++a4;
    _CF = __CFADD__(i, 1);
    _OF = __OFADD__(1, i);
    _ZF = i == -1;
    _SF = (signed int)(i + 1) < 0;
  }
  __asm { pushfw }
  v16 = _InterlockedExchange(&dword_805C16C, 0);
  _InterlockedExchange(&dword_805C16C, a2);
  _InterlockedExchange(&dword_805C16C, v16);
  v42 = sub_805344B();
  __asm { pushfw }
  v17 = _InterlockedExchange(&dword_805C130, a3);
  v21 = _InterlockedExchange(&dword_805C130, v18);
  v19 = v17;
  v20 = v21;
  _InterlockedExchange(&dword_805C130, v19);
  v22 = sub_804BB55();
  if ( v22 != 654 )
  {
    v25 = _InterlockedExchange(&dword_805C130, v22);
    _InterlockedExchange(&dword_805C130, v23);
    _InterlockedExchange(&dword_805C130, v25);
    sub_804BB5F(v24);
  }
  __asm { popfw }
  _CF = v42 < 0x104;
  _OF = __OFSUB__(v42, 260);
  _ZF = v42 == 260;
  _SF = (signed int)(v42 - 260) < 0;
  if ( v42 != 260 )
  {
    __asm { pushfw }
    v30 = _InterlockedExchange(&dword_805C124, v42);
    _InterlockedExchange(&dword_805C124, v23);
    _InterlockedExchange(&dword_805C124, v30);
    v31 = sub_804C840();
    if ( v31 != 516 )
    {
      v34 = _InterlockedExchange(&dword_805C124, v31);
      _InterlockedExchange(&dword_805C124, v32);
      _InterlockedExchange(&dword_805C124, v34);
      sub_804C84A(v33);
    }
    __asm { popfw }
    v35 = _InterlockedExchange(&dword_805C16C, v42);
    _InterlockedExchange(&dword_805C16C, v33);
    sub_8053455(_CF, _ZF, _SF, _OF, v32, _InterlockedExchange(&dword_805C16C, v35), v20);
  }
  __asm { popfw }
  return 0;
}
// 804BB5F: using guessed type int __fastcall sub_804BB5F(_DWORD);
// 804C84A: using guessed type int __fastcall sub_804C84A(_DWORD);
// 805C124: using guessed type int dword_805C124;
// 805C130: using guessed type int dword_805C130;
// 805C160: using guessed type int dword_805C160;
// 805C16C: using guessed type int dword_805C16C;
// 805C178: using guessed type int dword_805C178;
// 805C1A8: using guessed type int dword_805C1A8;
// 805C724: using guessed type int dword_805C724;

//----- (0804C840) --------------------------------------------------------
signed int sub_804C840()
{
  return 516;
}

//----- (0804C84B) --------------------------------------------------------
bool __usercall sub_804C84B@<al>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, int a9@<ebp>, _BYTE *a10, int a11, _BYTE **a12, _DWORD *a13, char a14)
{
  char v14; // al
  signed __int32 v15; // ebx
  char v16; // t0
  signed __int32 v17; // ebx
  char v18; // t1
  signed __int32 v19; // ebx
  char v25; // al
  signed __int32 v26; // et2
  signed int v27; // eax
  signed __int32 v28; // edx
  int v33; // eax
  char v34; // al
  signed __int32 v35; // ebx
  char v36; // tt
  signed __int32 v37; // ebx
  signed __int32 v38; // eax
  signed __int32 v39; // edx
  char v40; // al
  signed __int32 v41; // ebx
  char v42; // t1
  signed __int32 v43; // eax
  char v44; // al
  signed __int32 v45; // ebx
  char v46; // tt
  signed __int32 v47; // edx
  unsigned __int8 v48; // al
  unsigned __int8 v53; // al
  signed __int32 v54; // [esp-10h] [ebp-3Ch]
  signed __int32 v55; // [esp-Ah] [ebp-36h]
  unsigned __int32 v56; // [esp-Ah] [ebp-36h]
  signed __int32 v57; // [esp-Ah] [ebp-36h]
  signed __int32 v58; // [esp-4h] [ebp-30h]
  signed int i; // [esp+1Ch] [ebp-10h]
  int v60; // [esp+1Ch] [ebp-10h]
  int j; // [esp+1Ch] [ebp-10h]
  signed __int32 v62; // [esp+22h] [ebp-Ah]
  int v63; // [esp+28h] [ebp-4h]

  v63 = a5;
  __asm { pushfw }
  v62 = a8;
  if ( a8 >= 10 )
  {
    v14 = a8;
    v15 = _InterlockedExchange(&dword_805C10C, a8);
    v16 = _InterlockedExchange(&dword_805C10C, a7);
    a7 = _InterlockedExchange(&dword_805C10C, v15);
    if ( (v16 - 1) * v14 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( v62 >= 10 )
  {
    v17 = _InterlockedExchange(&dword_805C118, v62);
    v18 = _InterlockedExchange(&dword_805C118, a6);
    a6 = _InterlockedExchange(&dword_805C118, v17);
    if ( (v18 - 1) * (_BYTE)v62 & 1 )
      abort();
  }
  v19 = v62;
  __asm { popfw }
  v63 = a9;
  if ( !a11 )
    return 0;
  for ( i = a11 - 1; ; --i )
  {
    _CF = 0;
    _OF = 0;
    _ZF = i == 0;
    _SF = i < 0;
    if ( !i )
      break;
    __asm { pushfw }
    if ( v62 >= 10 )
    {
      v26 = _InterlockedExchange(&dword_805C19C, v62);
      v25 = _InterlockedExchange(&dword_805C19C, a6);
      _InterlockedExchange(&dword_805C19C, v26);
      if ( ((_BYTE)v62 - 1) * v25 & 1 )
        abort();
    }
    __asm { popfw }
    a6 = (signed __int32)a10;
    if ( a10[i] == 41 )
      break;
  }
  if ( a10[i] != 41 )
    return 0;
  *a13 = a10;
  if ( a14 && !sub_804C516(0, a14 == 0, a14 < 0, 0, (int)a10, (signed __int32)a10, a7, v62, (int)&v63, a10, i) )
    return 0;
  v27 = i;
  v60 = i + 1;
  v28 = (signed __int32)a10;
  _CF = __CFADD__(a10, v27);
  _OF = __OFADD__(a10, v27);
  _ZF = &a10[v27] == 0;
  _SF = (signed int)&a10[v27] < 0;
  v33 = (int)&a10[v27];
  *(_BYTE *)v33 = 0;
  while ( 1 )
  {
    v58 = v33;
    __asm { pushfw }
    v55 = v19;
    if ( v19 >= 10 )
    {
      v34 = v19;
      v35 = _InterlockedExchange(&dword_805C130, v19);
      v36 = _InterlockedExchange(&dword_805C130, a7);
      _InterlockedExchange(&dword_805C130, v35);
      if ( (v36 - 1) * v34 & 1 )
        abort();
    }
    v37 = v55;
    __asm
    {
      popfw
      pushfw
    }
    v38 = _InterlockedExchange(&dword_805C16C, v58);
    _InterlockedExchange(&dword_805C16C, v28);
    _InterlockedExchange(&dword_805C16C, v38);
    v56 = sub_805344B();
    __asm { pushfw }
    v54 = v37;
    if ( v37 >= 10 )
    {
      v40 = v37;
      v41 = _InterlockedExchange(&dword_805C10C, v37);
      v42 = _InterlockedExchange(&dword_805C10C, v39);
      v39 = _InterlockedExchange(&dword_805C10C, v41);
      if ( (v42 - 1) * v40 & 1 )
        abort();
    }
    v19 = v54;
    __asm { popfw }
    if ( v56 != 260 )
    {
      v43 = _InterlockedExchange(&dword_805C16C, v56);
      _InterlockedExchange(&dword_805C16C, v39);
      sub_8053455(
        v56 < 0x104,
        v56 == 260,
        (signed int)(v56 - 260) < 0,
        __OFSUB__(v56, 260),
        _InterlockedExchange(&dword_805C16C, v43),
        a7,
        v54);
    }
    __asm { popfw }
    v28 = (signed __int32)a10;
    v33 = (unsigned __int8)a10[v60];
    if ( (_BYTE)v33 != 32 )
    {
      v28 = (signed __int32)a10;
      v33 = (unsigned __int8)a10[v60];
      if ( (_BYTE)v33 != 9 )
        break;
    }
    _CF = __CFADD__(v60, 1);
    _OF = __OFADD__(1, v60);
    _ZF = v60 == -1;
    _SF = v60++ + 1 < 0;
  }
  if ( a10[v60] != 61 )
    return 0;
  for ( j = v60 + 1; ; ++j )
  {
    v47 = (signed __int32)a10;
    v48 = a10[j];
    _CF = v48 < 0x20u;
    _OF = __OFSUB__(v48, 32);
    _ZF = v48 == 32;
    _SF = (char)(v48 - 32) < 0;
    if ( v48 != 32 )
    {
      v47 = (signed __int32)a10;
      v53 = a10[j];
      _CF = v53 < 9u;
      _OF = __OFSUB__(v53, 9);
      _ZF = v53 == 9;
      _SF = (char)(v53 - 9) < 0;
      if ( v53 != 9 )
        break;
    }
    __asm { pushfw }
    v57 = v19;
    if ( v19 >= 10 )
    {
      v44 = v19;
      v45 = _InterlockedExchange(&dword_805C13C, v19);
      v46 = _InterlockedExchange(&dword_805C13C, v47);
      _InterlockedExchange(&dword_805C13C, v45);
      if ( (v46 - 1) * v44 & 1 )
        abort();
    }
    v19 = v57;
    __asm { popfw }
  }
  *a12 = &a10[j];
  return sub_804C699((signed __int32)&a10[j], a7, v19, *a12);
}
// 804C84B: could not find valid save-restore pair for ebx
// 804C84B: could not find valid save-restore pair for ebp
// 805C10C: using guessed type int dword_805C10C;
// 805C118: using guessed type int dword_805C118;
// 805C130: using guessed type int dword_805C130;
// 805C13C: using guessed type int dword_805C13C;
// 805C16C: using guessed type int dword_805C16C;
// 805C19C: using guessed type int dword_805C19C;

//----- (0804CAE3) --------------------------------------------------------
bool __usercall sub_804CAE3@<al>(signed __int32 a1@<ebx>, signed __int32 a2, int a3, _BYTE **a4, _DWORD *a5, _DWORD *a6)
{
  signed __int32 v6; // ecx
  int v7; // ST34_4
  char v8; // al
  signed __int32 v9; // et0
  bool result; // al
  bool v11; // al
  signed __int32 v12; // ecx
  signed __int32 v13; // ebx
  unsigned __int32 v14; // ecx
  signed __int32 v15; // ebx
  signed __int32 v16; // ecx
  signed __int32 v17; // ebx
  signed __int32 v18; // et2
  signed __int32 v19; // ecx
  int v20; // eax
  signed __int32 v21; // ecx
  int v22; // eax
  signed __int32 v23; // ebx
  signed __int32 v24; // ecx
  signed __int32 v25; // ett
  signed __int32 v30; // ecx
  char v31; // al
  signed __int32 v32; // ebx
  char v33; // t0
  signed __int32 v34; // ebx
  signed __int32 v35; // ecx
  signed __int32 v36; // ebx
  signed __int32 v37; // et1
  unsigned __int32 v38; // eax
  signed __int32 v39; // edx
  signed __int32 v40; // ecx
  signed __int32 v41; // ebx
  signed __int32 v42; // et2
  signed __int32 v43; // [esp-Ah] [ebp-42h]
  _BYTE *v44; // [esp-4h] [ebp-3Ch]
  unsigned __int8 v45; // [esp+27h] [ebp-11h]
  int i; // [esp+28h] [ebp-10h]
  int v47; // [esp+28h] [ebp-10h]
  int v48; // [esp+28h] [ebp-10h]
  int v49; // [esp+28h] [ebp-10h]
  int savedregs; // [esp+38h] [ebp+0h]

  v45 = 0;
  for ( i = 0; *(_BYTE *)(a2 + i) == 32 || *(_BYTE *)(a2 + i) == 9; ++i )
    ;
  if ( *(_BYTE *)(a2 + i) == 92 )
  {
    ++i;
    v45 = 1;
  }
  if ( !strncmp((const char *)(i + a2), "MD5", 3u) )
  {
    v47 = i + 3;
    if ( *(_BYTE *)(a2 + v47) == 32 )
      ++v47;
    if ( *(_BYTE *)(a2 + v47) == 40 )
    {
      v7 = v47 + 1;
      *a5 = 0;
      v9 = _InterlockedExchange(&dword_805C160, v45);
      v8 = _InterlockedExchange(&dword_805C160, v6);
      _InterlockedExchange(&dword_805C160, v9);
      result = sub_804C84B(
                 __CFADD__(a2, v7),
                 a2 + v7 == 0,
                 a2 + v7 < 0,
                 __OFADD__(a2, v7),
                 (int)a4,
                 a2 + v7,
                 a3 - v7,
                 a2,
                 (int)&savedregs,
                 (_BYTE *)(a2 + v7),
                 a3 - v7,
                 a4,
                 a6,
                 v8);
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    v11 = *(_BYTE *)(a2 + i) == 92;
    v12 = _InterlockedExchange(&dword_805C160, a1);
    v13 = _InterlockedExchange(&dword_805C160, a3 - i);
    v14 = _InterlockedExchange(&dword_805C160, v12);
    if ( v14 < (unsigned int)v11 + dword_805C720 )
      return 0;
    *a4 = (_BYTE *)(i + a2);
    v48 = dword_805C724 + i;
    v15 = _InterlockedExchange(&dword_805C160, v13);
    v18 = _InterlockedExchange(&dword_805C160, v14);
    v16 = v15;
    v17 = v18;
    v19 = _InterlockedExchange(&dword_805C160, v16);
    if ( *(_BYTE *)(a2 + v48) != 32 && *(_BYTE *)(a2 + v48) != 9 )
      return 0;
    v20 = v48;
    v49 = v48 + 1;
    *(_BYTE *)(a2 + v20) = 0;
    if ( !sub_804C699(a2, v19, v17, *a4) )
      return 0;
    if ( a3 - v49 != 1 && (*(_BYTE *)(a2 + v49) == 32 || *(_BYTE *)(a2 + v49) == 42) )
    {
      if ( dword_805C1CC != 1 )
      {
        dword_805C1CC = 0;
        v22 = v49++;
        v23 = _InterlockedExchange(&dword_805C160, v17);
        v25 = _InterlockedExchange(&dword_805C160, v21);
        v24 = v23;
        v17 = v25;
        _InterlockedExchange(&dword_805C160, v24);
        *a5 = *(_BYTE *)(a2 + v22) == 42;
      }
    }
    else
    {
      if ( !dword_805C1CC )
        return 0;
      dword_805C1CC = 1;
    }
    *a6 = v49 + a2;
    if ( v45 )
    {
      v44 = sub_804C516(
              __CFADD__(a2, v49),
              a2 + v49 == 0,
              a2 + v49 < 0,
              __OFADD__(a2, v49),
              a2 + v49,
              a3 - v49,
              a2,
              v17,
              (int)&savedregs,
              (_BYTE *)(a2 + v49),
              a3 - v49);
      __asm { pushfw }
      v43 = v17;
      if ( v17 >= 10 )
      {
        v31 = v17;
        v32 = _InterlockedExchange(&dword_805C13C, v17);
        v33 = _InterlockedExchange(&dword_805C13C, v30);
        v30 = _InterlockedExchange(&dword_805C13C, v32);
        if ( (v33 - 1) * v31 & 1 )
          abort();
      }
      __asm
      {
        popfw
        pushfw
      }
      v34 = _InterlockedExchange(&dword_805C178, v43);
      v37 = _InterlockedExchange(&dword_805C178, v30);
      v35 = v34;
      v36 = v37;
      _InterlockedExchange(&dword_805C178, v35);
      v38 = sub_8050431();
      if ( v38 != 110 )
      {
        v41 = _InterlockedExchange(&dword_805C178, v36);
        v42 = _InterlockedExchange(&dword_805C178, v39);
        _InterlockedExchange(&dword_805C178, v41);
        sub_805043B(v38 < 0x6E, v38 == 110, (signed int)(v38 - 110) < 0, __OFSUB__(v38, 110), v38, v40, v42);
      }
      __asm { popfw }
      result = v44 != 0;
    }
    else
    {
      result = 1;
    }
  }
  return result;
}
// 805C13C: using guessed type int dword_805C13C;
// 805C160: using guessed type int dword_805C160;
// 805C178: using guessed type int dword_805C178;
// 805C1CC: using guessed type int dword_805C1CC;
// 805C720: using guessed type int dword_805C720;
// 805C724: using guessed type int dword_805C724;

//----- (0804CE26) --------------------------------------------------------
int __usercall sub_804CE26@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>, char *a3, char a4)
{
  int v12; // eax
  signed __int32 v13; // edx
  char v14; // al
  signed __int32 v15; // et0
  signed __int32 v16; // ebx
  signed __int32 v17; // edx
  signed __int32 v18; // et1
  unsigned __int32 v19; // eax
  signed __int32 v20; // ecx
  int v21; // eax
  signed __int32 v22; // ebx
  signed __int32 v23; // edx
  signed __int32 v24; // ebx
  signed __int32 v25; // ett
  int v26; // edx
  signed __int32 v27; // ecx
  signed __int32 v28; // ebx
  int v30; // [esp-4h] [ebp-2Ch]

  _CF = 0;
  _OF = 0;
  _ZF = a4 == 1;
  _SF = ((a4 ^ 1) & 0x80u) != 0;
  if ( a4 == 1 )
  {
    __asm { pushfw }
    if ( a2 >= 10 )
    {
      v15 = _InterlockedExchange(&dword_805C154, a2);
      v14 = _InterlockedExchange(&dword_805C154, a1);
      a1 = _InterlockedExchange(&dword_805C154, v15);
      if ( ((_BYTE)a2 - 1) * v14 & 1 )
        abort();
    }
    __asm
    {
      popfw
      pushfw
    }
    v16 = _InterlockedExchange(&dword_805C184, a2);
    v18 = _InterlockedExchange(&dword_805C184, a1);
    v17 = v16;
    a2 = v18;
    _InterlockedExchange(&dword_805C184, v17);
    v19 = sub_804AE45();
    if ( v19 != -91 )
      sub_804AE4F(
        v19 < 0xFFFFFFA5,
        v19 == -91,
        (signed int)(v19 + 91) < 0,
        __OFSUB__(v19, -91),
        v19,
        _InterlockedExchange(&dword_805C184, _InterlockedExchange(&dword_805C184, a2)),
        _InterlockedExchange(&dword_805C184, v20));
    __asm { popfw }
    while ( 1 )
    {
      v12 = (unsigned __int8)*a3;
      _CF = 0;
      _OF = 0;
      _ZF = (_BYTE)v12 == 0;
      _SF = (v12 & 0x80u) != 0;
      if ( !(_BYTE)v12 )
        break;
      v21 = *a3;
      if ( v21 == 10 )
      {
        fwrite_unlocked("\\n", 1u, 2u, stdout);
      }
      else if ( v21 == 92 )
      {
        fwrite_unlocked("\\\\", 1u, 2u, stdout);
      }
      else
      {
        putchar_unlocked(*a3);
      }
      ++a3;
    }
  }
  else
  {
    v12 = fputs_unlocked(a3, stdout);
  }
  v30 = v12;
  __asm { pushfw }
  v22 = _InterlockedExchange(&dword_805C13C, a2);
  v25 = _InterlockedExchange(&dword_805C13C, v13);
  v23 = v22;
  v24 = v25;
  _InterlockedExchange(&dword_805C13C, v23);
  if ( sub_804A392() != -637 )
  {
    v28 = _InterlockedExchange(&dword_805C13C, v24);
    _InterlockedExchange(&dword_805C13C, v27);
    sub_804A39C(_InterlockedExchange(&dword_805C13C, v28), v26);
  }
  __asm { popfw }
  return v30;
}
// 8048F20: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 804A39C: using guessed type int __fastcall sub_804A39C(_DWORD, _DWORD);
// 805C13C: using guessed type int dword_805C13C;
// 805C154: using guessed type int dword_805C154;
// 805C184: using guessed type int dword_805C184;

//----- (0804CF90) --------------------------------------------------------
int __usercall sub_804CF90@<eax>(signed __int32 a1@<ebx>, char *s1, int a3, int a4, int a5)
{
  signed __int32 v5; // edx
  signed __int32 v6; // ecx
  signed __int32 v7; // edx
  signed __int32 v8; // ecx
  int result; // eax
  void *v10; // ebx
  int *v11; // eax
  signed __int32 v12; // ecx
  void *v13; // ebx
  int *v14; // eax
  signed __int32 v15; // ecx
  void *v16; // ebx
  int *v17; // eax
  signed __int32 v22; // eax
  signed __int32 v23; // eax
  signed __int32 v24; // edx
  signed __int32 v25; // ecx
  unsigned int v26; // eax
  signed __int32 v27; // edx
  signed __int32 v28; // ecx
  signed __int32 v29; // ebx
  signed __int32 v30; // et1
  bool v31; // [esp+17h] [ebp-11h]
  FILE *stream; // [esp+18h] [ebp-10h]
  int savedregs; // [esp+28h] [ebp+0h]

  v31 = strcmp(s1, "-") == 0;
  *(_BYTE *)a5 = 0;
  if ( v31 )
  {
    byte_805C71C = 1;
    stream = stdin;
    sub_804FF77(0, v31 == 0, v31 < 0, 0, (signed __int32)stream, v5, v6, a1, (int)&savedregs, stream, 2);
  }
  else
  {
    stream = (FILE *)sub_8050033(s1, "r");
    if ( !stream )
    {
      if ( byte_805C72A && *__errno_location() == 2 )
      {
        *(_BYTE *)a5 = 1;
        result = 1;
      }
      else
      {
        v10 = sub_8052BC0(v8, a1, 0, 3u, (signed __int32)s1);
        v11 = __errno_location();
        error(0, *v11, "%s", v10);
        result = 0;
      }
      return result;
    }
    sub_804FF77(
      0,
      stream == 0,
      (signed int)stream < 0,
      0,
      (signed __int32)stream,
      v7,
      v8,
      a1,
      (int)&savedregs,
      stream,
      2);
  }
  if ( sub_804E9A3(a1, stream, a4) )
  {
    v13 = sub_8052BC0(v12, a1, 0, 3u, (signed __int32)s1);
    v14 = __errno_location();
    error(0, *v14, "%s", v13);
    if ( stream != stdin )
      sub_80549A1((signed __int32)v13, stream);
    result = 0;
  }
  else if ( v31 != 1 && sub_80549A1(a1, stream) )
  {
    v16 = sub_8052BC0(v15, a1, 0, 3u, (signed __int32)s1);
    v17 = __errno_location();
    error(0, *v17, "%s", v16);
    __asm { pushfw }
    v23 = _InterlockedExchange(&dword_805C1A8, v22);
    _InterlockedExchange(&dword_805C1A8, v24);
    v26 = sub_804B557(_CF, _ZF, _SF, _OF, _InterlockedExchange(&dword_805C1A8, v23), v25, (signed __int32)v16);
    if ( v26 != -153 )
    {
      v29 = _InterlockedExchange(&dword_805C1A8, (signed __int32)v16);
      v30 = _InterlockedExchange(&dword_805C1A8, v27);
      _InterlockedExchange(&dword_805C1A8, v29);
      sub_804B60C(v26 < 0xFFFFFF67, v26 == -153, (signed int)(v26 + 153) < 0, __OFSUB__(v26, -153), v28, v30);
    }
    __asm { popfw }
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 8050033: using guessed type int __cdecl sub_8050033(_DWORD, _DWORD);
// 805C1A8: using guessed type int dword_805C1A8;
// 805C71C: using guessed type char byte_805C71C;
// 805C72A: using guessed type char byte_805C72A;

//----- (0804D19E) --------------------------------------------------------
int __usercall sub_804D19E@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, signed __int32 a9)
{
  char v9; // al
  signed __int32 v10; // ebx
  char v11; // t0
  void *v12; // ebx
  signed __int32 v13; // eax
  signed __int32 v14; // et1
  signed __int32 v15; // ecx
  void *v16; // ebx
  int *v17; // eax
  int result; // eax
  char *v19; // eax
  signed __int32 v20; // ecx
  signed __int32 v21; // ebx
  signed __int32 v22; // ecx
  signed __int32 v23; // et2
  signed __int32 v24; // ecx
  const char *format; // ST14_4
  signed __int32 v26; // eax
  bool v27; // al
  char *v28; // eax
  char *v29; // eax
  char *v30; // eax
  signed __int32 v31; // ecx
  void *v32; // ebx
  char *v33; // eax
  void *v34; // ebx
  int *v35; // eax
  void *v36; // ebx
  char *v37; // eax
  char v42; // al
  signed __int32 v43; // ebx
  char v44; // t1
  int v45; // eax
  char *v46; // eax
  int v47; // eax
  char *v48; // eax
  int v49; // eax
  char *v50; // eax
  void *v51; // ebx
  char *v52; // eax
  bool v53; // al
  signed __int32 v54; // [esp-Ah] [ebp-A6h]
  char *modes; // [esp+1Ch] [ebp-80h]
  size_t n; // [esp+20h] [ebp-7Ch]
  int *longind; // [esp+24h] [ebp-78h]
  _BYTE *v58; // [esp+28h] [ebp-74h]
  int v59; // [esp+2Ch] [ebp-70h]
  char *s1; // [esp+30h] [ebp-6Ch]
  int v61; // [esp+34h] [ebp-68h]
  int v62; // [esp+38h] [ebp-64h]
  FILE *v63; // [esp+3Ch] [ebp-60h]
  char **argv; // [esp+40h] [ebp-5Ch]
  unsigned int i; // [esp+44h] [ebp-58h]
  int v66; // [esp+48h] [ebp-54h]
  unsigned int v67; // [esp+4Ch] [ebp-50h]
  __int64 v68; // [esp+50h] [ebp-4Ch]
  __int64 v69; // [esp+58h] [ebp-44h]
  __int64 v70; // [esp+60h] [ebp-3Ch]
  __int64 v71; // [esp+68h] [ebp-34h]
  __int64 shortopts; // [esp+70h] [ebp-2Ch]
  char *s; // [esp+78h] [ebp-24h]
  unsigned int v74; // [esp+8Ch] [ebp-10h]
  signed __int32 v75[2]; // [esp+90h] [ebp-Ch]
  int v76; // [esp+98h] [ebp-4h]

  v76 = a5;
  __asm { pushfw }
  *(signed __int32 *)((char *)v75 + 2) = a8;
  if ( a8 >= 10 )
  {
    v9 = a8;
    v10 = _InterlockedExchange(&dword_805C10C, a8);
    v11 = _InterlockedExchange(&dword_805C10C, a7);
    a7 = _InterlockedExchange(&dword_805C10C, v10);
    if ( (v11 - 1) * v9 & 1 )
      abort();
  }
  __asm { popfw }
  v75[0] = *(signed __int32 *)((char *)v75 + 2);
  v12 = (void *)v75[0];
  v14 = _InterlockedExchange(&dword_805C160, a9);
  v13 = _InterlockedExchange(&dword_805C160, a6);
  _InterlockedExchange(&dword_805C160, v14);
  modes = (char *)v13;
  v74 = __readgsdword(0x14u);
  v68 = 0LL;
  v69 = 0LL;
  v70 = 0LL;
  v71 = 0LL;
  HIBYTE(n) = 0;
  LOBYTE(longind) = 0;
  v66 = sub_804BD12(a7, v75[0], (int)&s, 4u);
  BYTE1(longind) = strcmp(modes, "-") == 0;
  if ( BYTE1(longind) )
  {
    byte_805C71C = 1;
    modes = gettext("standard input");
    v63 = stdin;
  }
  else
  {
    v63 = (FILE *)sub_8050033(modes, "r");
    if ( !v63 )
    {
      v16 = sub_8052BC0(v15, (signed __int32)v12, 0, 3u, (signed __int32)modes);
      v17 = __errno_location();
      error(0, *v17, "%s", v16);
      return 0;
    }
  }
  shortopts = 0LL;
  v58 = 0;
  v59 = 0;
  do
  {
    if ( !++shortopts )
    {
      v12 = sub_8052BC0(v15, (signed __int32)v12, 0, 3u, (signed __int32)modes);
      v19 = gettext("%s: too many checksum lines");
      error(1, 0, v19, v12);
    }
    argv = (char **)getline(&v58, &v59, v63);
    if ( (signed int)argv <= 0 )
      break;
    if ( *v58 != 35 )
    {
      if ( v58[(_DWORD)argv - 1] == 10 )
      {
        argv = (char **)((char *)argv - 1);
        *((_BYTE *)argv + (_DWORD)v58) = 0;
      }
      v21 = _InterlockedExchange(&dword_805C160, (signed __int32)v12);
      v23 = _InterlockedExchange(&dword_805C160, v20);
      v22 = v21;
      v12 = (void *)v23;
      _InterlockedExchange(&dword_805C160, v22);
      if ( !sub_804CAE3(v23, (signed __int32)v58, (int)argv, (_BYTE **)&v62, &v61, &s1)
        || BYTE1(longind) && !strcmp(s1, "-") )
      {
        ++v68;
        if ( byte_805C729 )
        {
          v12 = sub_8052BC0(v24, (signed __int32)v12, 0, 3u, (signed __int32)modes);
          format = gettext("%s: %llu: improperly formatted %s checksum line");
          v26 = _InterlockedExchange(&dword_805C160, shortopts);
          _InterlockedExchange(&dword_805C160, SHIDWORD(shortopts));
          _InterlockedExchange(&dword_805C160, v26);
          error(0, 0, format, v12, shortopts, "MD5");
        }
        ++v69;
      }
      else
      {
        v27 = byte_805C728 != 1 && strchr(s1, 10);
        BYTE2(longind) = v27;
        HIBYTE(n) = 1;
        HIBYTE(longind) = sub_804CF90(
                            (signed __int32)v12,
                            (char *)_InterlockedExchange(&dword_805C160, (signed __int32)&v61),
                            _InterlockedExchange(
                              &dword_805C160,
                              _InterlockedExchange(&dword_805C160, (signed __int32)s1)),
                            v66,
                            (int)&n + 2);
        if ( HIBYTE(longind) == 1 )
        {
          if ( !byte_805C72A || !BYTE2(n) )
          {
            v67 = (unsigned int)dword_805C724 >> 1;
            for ( i = 0;
                  i < v67
               && tolower(*(unsigned __int8 *)(2 * i + v62)) == byte_8057B21[(unsigned __int8)(*(_BYTE *)(v66 + i) >> 4)]
               && tolower(*(unsigned __int8 *)(2 * i + 1 + v62)) == byte_8057B21[*(_BYTE *)(v66 + i) & 0xF];
                  ++i )
            {
              ;
            }
            if ( i == v67 )
              LOBYTE(longind) = 1;
            else
              ++v70;
            if ( byte_805C728 != 1 )
            {
              if ( i != v67 || byte_805C72B != 1 )
              {
                if ( BYTE2(longind) )
                  putchar_unlocked(92);
                sub_804CE26(BYTE2(longind), (signed __int32)v12, s1, SBYTE2(longind));
              }
              if ( i == v67 )
              {
                if ( byte_805C72B != 1 )
                {
                  v30 = gettext("OK");
                  printf(": %s\n", v30);
                }
              }
              else
              {
                v29 = gettext("FAILED");
                printf(": %s\n", v29);
              }
            }
          }
        }
        else
        {
          ++v71;
          if ( byte_805C728 != 1 )
          {
            if ( BYTE2(longind) )
              putchar_unlocked(92);
            sub_804CE26(BYTE2(longind), (signed __int32)v12, s1, SBYTE2(longind));
            v28 = gettext("FAILED open or read");
            printf(": %s\n", v28);
          }
        }
      }
    }
  }
  while ( !feof_unlocked(v63) && !ferror_unlocked(v63) );
  free(v58);
  if ( ferror_unlocked(v63) )
  {
    v32 = sub_8052BC0(v31, (signed __int32)v12, 0, 3u, (signed __int32)modes);
    v33 = gettext("%s: read error");
    error(0, 0, v33, v32);
    result = 0;
  }
  else if ( BYTE1(longind) != 1 && sub_80549A1((signed __int32)v12, v63) )
  {
    v34 = sub_8052BC0(v31, (signed __int32)v12, 0, 3u, (signed __int32)modes);
    v35 = __errno_location();
    error(0, *v35, "%s", v34);
    result = 0;
  }
  else
  {
    if ( HIBYTE(n) == 1 )
    {
      _CF = 0;
      _OF = 0;
      _ZF = byte_805C728 == 1;
      _SF = ((byte_805C728 ^ 1) & 0x80u) != 0;
      if ( byte_805C728 != 1 )
      {
        __asm { pushfw }
        v54 = (signed __int32)v12;
        if ( (signed int)v12 >= 10 )
        {
          v42 = (char)v12;
          v43 = _InterlockedExchange(&dword_805C190, (signed __int32)v12);
          v44 = _InterlockedExchange(&dword_805C190, v31);
          v31 = _InterlockedExchange(&dword_805C190, v43);
          if ( (v44 - 1) * v42 & 1 )
            abort();
        }
        __asm { popfw }
        if ( v68 )
        {
          v45 = sub_804BB65(
                  0,
                  v68 == 0,
                  (signed int)(HIDWORD(v68) | v68) < 0,
                  0,
                  v68,
                  SHIDWORD(v68),
                  v54,
                  (int)&v76,
                  v68,
                  SHIDWORD(v68));
          v46 = ngettext(
                  "WARNING: %llu line is improperly formatted",
                  "WARNING: %llu lines are improperly formatted",
                  v45);
          error(0, 0, v46, v68);
        }
        if ( v71 )
        {
          v47 = sub_804BB65(
                  0,
                  v71 == 0,
                  (signed int)(HIDWORD(v71) | v71) < 0,
                  0,
                  v71,
                  SHIDWORD(v71),
                  v54,
                  (int)&v76,
                  v71,
                  SHIDWORD(v71));
          v48 = ngettext(
                  "WARNING: %llu listed file could not be read",
                  "WARNING: %llu listed files could not be read",
                  v47);
          error(0, 0, v48, v71);
        }
        if ( v70 )
        {
          v49 = sub_804BB65(
                  0,
                  v70 == 0,
                  (signed int)(HIDWORD(v70) | v70) < 0,
                  0,
                  v70,
                  SHIDWORD(v70),
                  v54,
                  (int)&v76,
                  v70,
                  SHIDWORD(v70));
          v50 = ngettext(
                  "WARNING: %llu computed checksum did NOT match",
                  "WARNING: %llu computed checksums did NOT match",
                  v49);
          error(0, 0, v50, v70);
        }
        if ( byte_805C72A && (_BYTE)longind != 1 )
        {
          v51 = sub_8052BC0(v31, v54, 0, 3u, (signed __int32)modes);
          v52 = gettext("%s: no file was verified");
          error(0, 0, v52, v51);
        }
      }
    }
    else
    {
      v36 = sub_8052BC0(v31, (signed __int32)v12, 0, 3u, (signed __int32)modes);
      v37 = gettext("%s: no properly formatted %s checksum lines found");
      error(0, 0, v37, v36, "MD5");
    }
    v53 = HIBYTE(n) && (_BYTE)longind && !v70 && !v71 && (byte_805C72C != 1 || !v69);
    result = v53;
  }
  return result;
}
// 804D19E: could not find valid save-restore pair for ebx
// 8048D20: using guessed type int __cdecl getline(_DWORD, _DWORD, _DWORD);
// 8050033: using guessed type int __cdecl sub_8050033(_DWORD, _DWORD);
// 805C10C: using guessed type int dword_805C10C;
// 805C160: using guessed type int dword_805C160;
// 805C190: using guessed type int dword_805C190;
// 805C71C: using guessed type char byte_805C71C;
// 805C724: using guessed type int dword_805C724;
// 805C728: using guessed type char byte_805C728;
// 805C729: using guessed type char byte_805C729;
// 805C72A: using guessed type char byte_805C72A;
// 805C72B: using guessed type char byte_805C72B;
// 805C72C: using guessed type char byte_805C72C;

//----- (0804E2FF) --------------------------------------------------------
int __usercall sub_804E2FF@<eax>(signed __int32 a1@<ebx>)
{
  signed __int32 v1; // edx
  void *v2; // ebx
  int *v3; // eax
  int *v4; // eax
  int result; // eax
  char *v6; // [esp+2Ch] [ebp-Ch]

  if ( sub_8055736(a1, stdout) && (byte_805C734 != 1 || *__errno_location() != 32) )
  {
    v6 = gettext("write error");
    if ( dword_805C730 )
    {
      v2 = sub_8052964(0, dword_805C730 == 0, dword_805C730 < 0, 0, v1, a1, dword_805C730);
      v3 = __errno_location();
      error(0, *v3, "%s: %s", v2, v6);
    }
    else
    {
      v4 = __errno_location();
      error(0, *v4, "%s", v6);
    }
    _exit(status);
  }
  result = sub_8055736(a1, stderr);
  if ( result )
    _exit(status);
  return result;
}
// 805C730: using guessed type int dword_805C730;
// 805C734: using guessed type char byte_805C734;

//----- (0804E3E3) --------------------------------------------------------
_DWORD *__usercall sub_804E3E3@<eax>(signed __int32 a1@<ebx>, _DWORD *a2)
{
  signed __int32 v2; // edx
  _DWORD *result; // eax
  signed __int32 v4; // ebx

  *a2 = 1732584193;
  a2[1] = -271733879;
  a2[2] = -1732584194;
  a2[3] = 271733878;
  a2[5] = 0;
  v2 = a2[5];
  a2[4] = v2;
  result = a2;
  a2[6] = 0;
  v4 = _InterlockedExchange(&dword_805C160, a1);
  _InterlockedExchange(&dword_805C160, v2);
  _InterlockedExchange(&dword_805C160, v4);
  return result;
}
// 805C160: using guessed type int dword_805C160;

//----- (0804E44F) --------------------------------------------------------
_DWORD *__cdecl sub_804E44F(_DWORD *a1, int a2)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = a2;
  return result;
}

//----- (0804E45C) --------------------------------------------------------
_DWORD *__usercall sub_804E45C@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, signed __int32 *a8, _DWORD *a9)
{
  signed __int32 v9; // ebx
  signed __int32 v10; // ecx
  signed __int32 v11; // ebx
  signed __int32 v12; // et0
  signed __int32 v13; // edx
  signed __int32 v14; // ecx
  signed __int32 v15; // ebx
  char v16; // al
  signed __int32 v17; // ebx
  char v18; // t2
  char v19; // al
  signed __int32 v20; // ett
  signed __int32 v21; // ebx
  char v22; // t0
  signed __int32 v27; // eax
  signed __int32 v28; // edx
  signed __int32 v29; // ecx
  signed __int32 v30; // eax
  signed __int32 v31; // ebx
  signed __int32 v32; // ett
  char v33; // al
  signed __int32 v34; // et0
  signed __int32 v35; // ebx
  int v36; // eax
  char v41; // al
  signed __int32 v42; // et1
  int v43; // eax
  signed __int32 v44; // et2
  signed __int32 v45; // ebx
  signed __int32 v46; // ecx
  signed __int32 v47; // ecx
  signed __int32 v48; // ebx
  signed __int32 v49; // ett
  unsigned __int32 v50; // eax
  signed __int32 v51; // edx
  signed __int32 v52; // ecx
  bool v53; // cf
  bool v54; // zf
  bool v55; // sf
  char v56; // of
  signed __int32 v57; // eax
  signed __int32 v58; // et0
  signed __int32 v60; // [esp+12h] [ebp-Ah]
  signed __int32 v61; // [esp+18h] [ebp-4h]

  v61 = a5;
  __asm { pushfw }
  v9 = _InterlockedExchange(&dword_805C130, a7);
  v12 = _InterlockedExchange(&dword_805C130, a6);
  v10 = v9;
  v11 = v12;
  _InterlockedExchange(&dword_805C130, v10);
  if ( sub_804BB55() != 654 )
  {
    v15 = _InterlockedExchange(&dword_805C130, v11);
    _InterlockedExchange(&dword_805C130, v13);
    _InterlockedExchange(&dword_805C130, v15);
    sub_804BB5F(v14);
  }
  __asm
  {
    popfw
    pushfw
  }
  v60 = v11;
  if ( v11 >= 10 )
  {
    v16 = v11;
    v17 = _InterlockedExchange(&dword_805C13C, v11);
    v18 = _InterlockedExchange(&dword_805C13C, v14);
    v14 = _InterlockedExchange(&dword_805C13C, v17);
    if ( (v18 - 1) * v16 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( v60 >= 10 )
  {
    v20 = _InterlockedExchange(&dword_805C178, v60);
    v19 = _InterlockedExchange(&dword_805C178, v14);
    v14 = _InterlockedExchange(&dword_805C178, v20);
    if ( ((_BYTE)v60 - 1) * v19 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( v60 >= 10 )
  {
    v21 = _InterlockedExchange(&dword_805C190, v60);
    v22 = _InterlockedExchange(&dword_805C190, v14);
    v14 = _InterlockedExchange(&dword_805C190, v21);
    if ( (v22 - 1) * (_BYTE)v60 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  _CF = (unsigned int)v60 < 0xA;
  _OF = __OFSUB__(v60, 10);
  _ZF = v60 == 10;
  _SF = v60 - 10 < 0;
  if ( v60 >= 10 )
  {
    __asm { pushfw }
    v27 = sub_804A927(
            (unsigned int)v60 < 0xA,
            v60 == 10,
            v60 - 10 < 0,
            __OFSUB__(v60, 10),
            _InterlockedExchange(&dword_805C190, v13),
            _InterlockedExchange(&dword_805C190, _InterlockedExchange(&dword_805C190, v61)),
            v60);
    if ( v27 != 625 )
    {
      v30 = _InterlockedExchange(&dword_805C190, v27);
      _InterlockedExchange(&dword_805C190, v28);
      sub_804AA62(v29, _InterlockedExchange(&dword_805C190, v30));
    }
    __asm { popfw }
    v31 = _InterlockedExchange(&dword_805C1A8, v60);
    v32 = _InterlockedExchange(&dword_805C1A8, v29);
    v34 = _InterlockedExchange(&dword_805C160, v60);
    v33 = _InterlockedExchange(&dword_805C160, v31);
    v14 = _InterlockedExchange(&dword_805C1A8, _InterlockedExchange(&dword_805C160, v34));
    v35 = v32 - 1;
    v36 = ((_BYTE)v32 - 1) * v33 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = v36 == 0;
    _SF = v36 < 0;
    if ( v36 )
    {
      __asm { pushfw }
      if ( v35 >= 10 )
      {
        v42 = _InterlockedExchange(&dword_805C124, v35);
        v41 = _InterlockedExchange(&dword_805C124, v14);
        _InterlockedExchange(&dword_805C124, v42);
        if ( ((_BYTE)v35 - 1) * v41 & 1 )
          abort();
      }
      __asm { popfw }
      abort();
    }
  }
  __asm { popfw }
  v44 = _InterlockedExchange(&dword_805C160, *a8);
  v43 = _InterlockedExchange(&dword_805C160, v14);
  _InterlockedExchange(&dword_805C160, v44);
  sub_804E44F(a9, v43);
  sub_804E44F(a9 + 1, a8[1]);
  sub_804E44F(a9 + 2, a8[2]);
  __asm { pushfw }
  v45 = _InterlockedExchange(&dword_805C184, v60);
  v49 = _InterlockedExchange(&dword_805C184, v46);
  v47 = v45;
  v48 = v49;
  _InterlockedExchange(&dword_805C184, v47);
  v50 = sub_804AE45();
  v53 = v50 < 0xFFFFFFA5;
  v56 = __OFSUB__(v50, -91);
  v54 = v50 == -91;
  v55 = (signed int)(v50 + 91) < 0;
  if ( v50 != -91 )
  {
    v58 = _InterlockedExchange(&dword_805C184, v50);
    v57 = _InterlockedExchange(&dword_805C184, v51);
    _InterlockedExchange(&dword_805C184, v58);
    sub_804AE4F(v53, v54, v55, v56, v57, v52, v48);
  }
  __asm { popfw }
  sub_804E44F(a9 + 3, a8[3]);
  return a9;
}
// 804E45C: could not find valid save-restore pair for ebp
// 804AA62: using guessed type int __fastcall sub_804AA62(_DWORD, _DWORD);
// 804BB5F: using guessed type int __fastcall sub_804BB5F(_DWORD);
// 805C124: using guessed type int dword_805C124;
// 805C130: using guessed type int dword_805C130;
// 805C13C: using guessed type int dword_805C13C;
// 805C160: using guessed type int dword_805C160;
// 805C178: using guessed type int dword_805C178;
// 805C184: using guessed type int dword_805C184;
// 805C190: using guessed type int dword_805C190;
// 805C1A8: using guessed type int dword_805C1A8;

//----- (0804E723) --------------------------------------------------------
_DWORD *__usercall sub_804E723@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, int *a3, _DWORD *a4)
{
  signed int v4; // eax
  signed __int32 v5; // edx
  signed __int32 v6; // ebx
  signed __int32 v7; // edx
  signed __int32 v8; // ebx
  signed __int32 v9; // et0
  unsigned int v10; // eax
  char v15; // al
  signed __int32 v16; // et1
  signed __int32 v17; // ecx
  signed __int32 v18; // ebx
  signed __int32 v19; // et2
  signed __int32 v20; // ecx
  unsigned int v22; // [esp+18h] [ebp-10h]
  signed int v23; // [esp+1Ch] [ebp-Ch]

  v22 = a3[6];
  if ( v22 > 0x37 )
    v4 = 32;
  else
    v4 = 16;
  v23 = v4;
  v5 = v22 + a3[4];
  v6 = _InterlockedExchange(&dword_805C160, a2);
  v9 = _InterlockedExchange(&dword_805C160, v5);
  v7 = v6;
  v8 = v9;
  a3[4] = _InterlockedExchange(&dword_805C160, v7);
  v10 = a3[4];
  _CF = v10 < v22;
  _OF = __OFSUB__(v10, v22);
  _ZF = v10 == v22;
  _SF = (signed int)(v10 - v22) < 0;
  if ( v10 < v22 )
    ++a3[5];
  __asm { pushfw }
  if ( v8 >= 10 )
  {
    v16 = _InterlockedExchange(&dword_805C148, v8);
    v15 = _InterlockedExchange(&dword_805C148, a1);
    _InterlockedExchange(&dword_805C148, v16);
    if ( ((_BYTE)v8 - 1) * v15 & 1 )
      abort();
  }
  __asm { popfw }
  a3[v23 + 5] = 8 * a3[4];
  v17 = *((_QWORD *)a3 + 2) >> 29;
  a3[v23 + 6] = v17;
  v18 = _InterlockedExchange(&dword_805C160, v8);
  v19 = _InterlockedExchange(&dword_805C160, v17);
  _InterlockedExchange(&dword_805C160, v18);
  memcpy((char *)a3 + v22 + 28, &unk_8057B68, 4 * (v23 + 1073741822) - v22);
  sub_804EEB9(4 * v23, v19, a3 + 7, 4 * v23, a3);
  return sub_804E45C(_CF, _ZF, _SF, _OF, (signed __int32)a3, v20, v19, a3, a4);
}
// 805C148: using guessed type int dword_805C148;
// 805C160: using guessed type int dword_805C160;

//----- (0804E9A3) --------------------------------------------------------
int __usercall sub_804E9A3@<eax>(signed __int32 a1@<ebx>, FILE *stream, int a3)
{
  signed __int32 v3; // edx
  char v9; // al
  signed __int32 v10; // et0
  signed __int32 v11; // ecx
  signed __int32 v12; // ecx
  int v13; // [esp+18h] [ebp-B0h]
  int *ptr; // [esp+1Ch] [ebp-ACh]
  size_t v15; // [esp+20h] [ebp-A8h]
  int v16; // [esp+24h] [ebp-A4h]

  ptr = (int *)malloc(0x8048u);
  _CF = 0;
  _OF = 0;
  _ZF = ptr == 0;
  _SF = (signed int)ptr < 0;
  if ( !ptr )
    return 1;
  __asm { pushfw }
  if ( a1 >= 10 )
  {
    v10 = _InterlockedExchange(&dword_805C178, a1);
    v9 = _InterlockedExchange(&dword_805C178, v3);
    _InterlockedExchange(&dword_805C178, v10);
    if ( ((_BYTE)a1 - 1) * v9 & 1 )
      abort();
  }
  __asm { popfw }
  sub_804E3E3(a1, &v16);
LABEL_7:
  v13 = 0;
  while ( 1 )
  {
    v15 = fread_unlocked(
            (void *)_InterlockedExchange(&dword_805C160, _InterlockedExchange(&dword_805C160, 0x8000 - v13)),
            1u,
            _InterlockedExchange(&dword_805C160, (signed __int32)ptr + v13),
            stream);
    v13 += v15;
    if ( v13 == 0x8000 )
    {
      sub_804EEB9(v11, a1, ptr, 0x8000u, &v16);
      goto LABEL_7;
    }
    if ( !v15 )
      break;
    if ( feof_unlocked(stream) )
      goto LABEL_15;
  }
  if ( ferror_unlocked(stream) )
  {
    free(ptr);
    return 1;
  }
LABEL_15:
  if ( v13 )
    sub_804EB97(v12, a1, ptr, v13, (int)&v16);
  sub_804E723(v12, a1, &v16, (_DWORD *)a3);
  free(ptr);
  return 0;
}
// 805C160: using guessed type int dword_805C160;
// 805C178: using guessed type int dword_805C178;

//----- (0804EB97) --------------------------------------------------------
int *__usercall sub_804EB97@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, void *src, int a4, int a5)
{
  int *result; // eax
  int v6; // eax
  signed __int32 v7; // edx
  signed __int32 v8; // eax
  signed __int32 v9; // ecx
  signed __int32 v10; // ecx
  size_t v11; // eax
  signed __int32 v12; // et2
  int *v13; // eax
  signed __int32 v14; // ecx
  signed __int32 v15; // eax
  signed __int32 v16; // eax
  void *v17; // edx
  signed __int32 v18; // ecx
  signed __int32 v19; // eax
  size_t v20; // eax
  signed __int32 v21; // et1
  signed __int32 v22; // ecx
  signed __int32 v27; // edx
  char v28; // al
  signed __int32 v29; // et2
  signed __int32 v30; // ebx
  signed __int32 v31; // ecx
  signed __int32 v32; // ebx
  signed __int32 v33; // ett
  signed __int32 v34; // ecx
  signed __int32 v35; // ebx
  size_t v36; // [esp+14h] [ebp-14h]
  unsigned int v37; // [esp+14h] [ebp-14h]
  int v38; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]

  result = *(int **)(a5 + 24);
  if ( result )
  {
    v38 = *(_DWORD *)(a5 + 24);
    v6 = a4;
    if ( 128 - v38 <= (unsigned int)a4 )
      v6 = 128 - v38;
    v7 = _InterlockedExchange(&dword_805C160, a2);
    a2 = _InterlockedExchange(&dword_805C160, 128 - v38);
    _InterlockedExchange(&dword_805C160, v7);
    n = v6;
    memcpy((void *)(v38 + a5 + 28), src, v6);
    *(_DWORD *)(a5 + 24) += n;
    if ( *(_DWORD *)(a5 + 24) > 0x40u )
    {
      v8 = _InterlockedExchange(&dword_805C160, *(_DWORD *)(a5 + 24));
      v9 = _InterlockedExchange(&dword_805C160, a1);
      _InterlockedExchange(&dword_805C160, v8);
      sub_804EEB9(v9 & 0xFFFFFFC0, a2, (int *)(a5 + 28), v9 & 0xFFFFFFC0, (int *)a5);
      *(_DWORD *)(a5 + 24) &= 0x3Fu;
      v12 = _InterlockedExchange(&dword_805C160, *(_DWORD *)(a5 + 24));
      v11 = _InterlockedExchange(&dword_805C160, v10);
      _InterlockedExchange(&dword_805C160, v12);
      a2 = a5 + 28;
      memcpy((void *)(a5 + 28), (const void *)(a5 + 28 + ((v38 + n) & 0xFFFFFFC0)), v11);
    }
    src = (char *)src + n;
    result = (int *)n;
    a4 -= n;
  }
  if ( (unsigned int)a4 > 0x3F )
  {
    result = (int *)((unsigned __int8)src & 3);
    if ( (unsigned __int8)src & 3 )
    {
      while ( (unsigned int)a4 > 0x40 )
      {
        v13 = (int *)memcpy((void *)(a5 + 28), src, 0x40u);
        result = sub_804EEB9(v14, a2, v13, 0x40u, (int *)a5);
        src = (char *)src + 64;
        a4 -= 64;
      }
    }
    else
    {
      sub_804EEB9(a1, a2, (int *)src, a4 & 0xFFFFFFC0, (int *)a5);
      result = (int *)(a4 & 0xFFFFFFC0);
      src = (char *)src + (a4 & 0xFFFFFFC0);
      a4 &= 0x3Fu;
    }
  }
  if ( a4 )
  {
    v36 = *(_DWORD *)(a5 + 24);
    _CF = __CFADD__(v36, a5 + 28);
    _OF = __OFADD__(v36, a5 + 28);
    _ZF = v36 + a5 + 28 == 0;
    _SF = (signed int)(v36 + a5 + 28) < 0;
    __asm { pushfw }
    v15 = _InterlockedExchange(&dword_805C118, a4);
    _InterlockedExchange(&dword_805C118, a1);
    _InterlockedExchange(&dword_805C118, v15);
    v16 = sub_804A7B7();
    if ( v16 != 317 )
    {
      v19 = _InterlockedExchange(&dword_805C118, v16);
      _InterlockedExchange(&dword_805C118, v18);
      sub_804A7C1(_InterlockedExchange(&dword_805C118, v19), v17);
    }
    __asm { popfw }
    v21 = _InterlockedExchange(&dword_805C160, a4);
    v20 = _InterlockedExchange(&dword_805C160, v18);
    _InterlockedExchange(&dword_805C160, v21);
    memcpy(v17, src, v20);
    v37 = a4 + v36;
    _CF = v37 < 0x3F;
    _OF = __OFSUB__(v37, 63);
    _ZF = v37 == 63;
    _SF = (signed int)(v37 - 63) < 0;
    if ( v37 > 0x3F )
    {
      sub_804EEB9(v22, a2, (int *)(a5 + 28), 0x40u, (int *)a5);
      __asm { pushfw }
      if ( a2 >= 10 )
      {
        v29 = _InterlockedExchange(&dword_805C148, a2);
        v28 = _InterlockedExchange(&dword_805C148, v27);
        _InterlockedExchange(&dword_805C148, v29);
        if ( ((_BYTE)a2 - 1) * v28 & 1 )
          abort();
      }
      __asm { popfw }
      v37 -= 64;
      memcpy((void *)(a5 + 28), (const void *)(a5 + 92), v37);
    }
    __asm { pushfw }
    v30 = _InterlockedExchange(&dword_805C130, a2);
    v33 = _InterlockedExchange(&dword_805C130, v22);
    v31 = v30;
    v32 = v33;
    _InterlockedExchange(&dword_805C130, v31);
    if ( sub_804BB55() != 654 )
    {
      v35 = _InterlockedExchange(&dword_805C130, v32);
      _InterlockedExchange(&dword_805C130, v34);
      sub_804BB5F(_InterlockedExchange(&dword_805C130, v35));
    }
    __asm { popfw }
    result = (int *)a5;
    *(_DWORD *)(a5 + 24) = v37;
  }
  return result;
}
// 804A7C1: using guessed type int __fastcall sub_804A7C1(_DWORD, _DWORD);
// 804BB5F: using guessed type int __fastcall sub_804BB5F(_DWORD);
// 805C118: using guessed type int dword_805C118;
// 805C130: using guessed type int dword_805C130;
// 805C148: using guessed type int dword_805C148;
// 805C160: using guessed type int dword_805C160;

//----- (0804EEB9) --------------------------------------------------------
int *__usercall sub_804EEB9@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, int *a3, unsigned int a4, int *a5)
{
  int v5; // edx
  signed __int32 v6; // eax
  signed __int32 v7; // et0
  int v8; // edx
  _BOOL4 v9; // eax
  signed __int32 v14; // edx
  signed __int32 v15; // eax
  int v16; // ST4C_4
  int v17; // ST50_4
  int v18; // ST54_4
  int v19; // ST58_4
  int v20; // ST5C_4
  int v21; // ST2C_4
  signed __int32 *v22; // ST28_4
  int v23; // ST2C_4
  signed __int32 v24; // ST60_4
  int v25; // ST38_4
  signed __int32 v26; // ST64_4
  int v27; // ST34_4
  signed __int32 v28; // ST68_4
  int v29; // ST30_4
  signed __int32 v30; // ST6C_4
  int v31; // ST2C_4
  signed __int32 v32; // ST70_4
  int v33; // ST38_4
  signed __int32 v34; // ST74_4
  int v35; // ST34_4
  signed __int32 v36; // ST78_4
  int v37; // ST30_4
  signed __int32 v38; // ST7C_4
  int v39; // ST2C_4
  signed __int32 v40; // ST80_4
  int v41; // ST38_4
  signed __int32 v42; // ST84_4
  int v43; // ST34_4
  signed __int32 v44; // ST88_4
  int v45; // ST30_4
  signed __int32 v46; // ST8C_4
  int v47; // ST2C_4
  signed __int32 v48; // ST90_4
  int v49; // ST38_4
  signed __int32 v50; // ST94_4
  int v51; // ST34_4
  int v52; // ecx
  signed __int32 v53; // ST98_4
  int v54; // ST30_4
  int v55; // ST2C_4
  int v56; // ST38_4
  int v57; // ST34_4
  int v58; // ST30_4
  int v59; // ST2C_4
  int v60; // ST38_4
  int v61; // ST34_4
  int v62; // ST30_4
  int v63; // ST2C_4
  int v64; // ST38_4
  int v65; // ST34_4
  int v66; // ST30_4
  int v67; // ST2C_4
  int v68; // ST38_4
  signed __int32 v69; // eax
  signed __int32 v70; // et1
  int v71; // ST34_4
  int v72; // ST30_4
  int v73; // ST2C_4
  int v74; // ST38_4
  int v75; // ST34_4
  int v76; // ST30_4
  int v77; // ST2C_4
  int v78; // ST38_4
  int v79; // ST34_4
  int v80; // ST30_4
  int v81; // ST2C_4
  int v82; // ST38_4
  int v83; // ST34_4
  int v84; // ST30_4
  int v85; // ST2C_4
  int v86; // ST38_4
  int v87; // ST34_4
  int v88; // ST30_4
  int v89; // ST2C_4
  int v90; // ST38_4
  int v91; // ST34_4
  int v92; // ST30_4
  int v93; // ST2C_4
  int v94; // ST38_4
  int v95; // ST34_4
  int v96; // ST30_4
  int v97; // ST2C_4
  int v98; // ST38_4
  int v99; // ST34_4
  int v100; // ST30_4
  int v101; // ST2C_4
  int v102; // ST38_4
  int v103; // ST34_4
  signed __int32 v104; // eax
  signed __int32 v105; // eax
  signed __int32 v106; // edx
  signed __int32 v107; // ecx
  signed __int32 v108; // eax
  signed __int32 v113; // ebx
  signed __int32 v114; // edx
  signed __int32 v115; // ebx
  signed __int32 v116; // et0
  signed __int32 v117; // edx
  signed __int32 v118; // ecx
  char v119; // al
  signed __int32 v120; // et1
  signed __int32 v125; // ebx
  char v126; // t2
  char v127; // al
  signed __int32 v128; // ett
  signed __int32 v129; // eax
  int *result; // eax
  signed __int32 v131; // [esp-10h] [ebp-90h]
  unsigned __int32 v132; // [esp-Ah] [ebp-8Ah]
  int *v133; // [esp+Ch] [ebp-74h]
  int v134; // [esp+10h] [ebp-70h]
  int v135; // [esp+14h] [ebp-6Ch]
  int v136; // [esp+18h] [ebp-68h]
  int v137; // [esp+1Ch] [ebp-64h]
  unsigned int v138; // [esp+24h] [ebp-5Ch]

  v133 = a3;
  v138 = (unsigned int)&a3[a4 >> 2];
  v134 = *a5;
  v135 = a5[1];
  v136 = a5[2];
  v137 = a5[3];
  v5 = a4 + a5[4];
  v7 = _InterlockedExchange(&dword_805C160, (signed __int32)a5);
  v6 = _InterlockedExchange(&dword_805C160, a1);
  _InterlockedExchange(&dword_805C160, v7);
  *(_DWORD *)(v6 + 16) = v5;
  v8 = a5[5];
  v9 = a5[4] < a4;
  _CF = __CFADD__(v9, v8);
  _OF = __OFADD__(v9, v8);
  _ZF = v9 + v8 == 0;
  _SF = v9 + v8 < 0;
  v14 = v9 + v8;
  v15 = (signed __int32)a5;
  a5[5] = v14;
  while ( 1 )
  {
    __asm { pushfw }
    v104 = _InterlockedExchange(&dword_805C124, v15);
    _InterlockedExchange(&dword_805C124, v14);
    _InterlockedExchange(&dword_805C124, v104);
    v105 = sub_804C840();
    if ( v105 != 516 )
    {
      v108 = _InterlockedExchange(&dword_805C124, v105);
      _InterlockedExchange(&dword_805C124, v107);
      sub_804C84A(_InterlockedExchange(&dword_805C124, v108));
    }
    __asm { popfw }
    _CF = (unsigned int)v133 < v138;
    _OF = __OFSUB__(v133, v138);
    _ZF = v133 == (int *)v138;
    _SF = (signed int)((signed int)v133 - v138) < 0;
    if ( (unsigned int)v133 >= v138 )
      break;
    v16 = v134;
    v17 = v135;
    v18 = v136;
    v19 = v137;
    v20 = *v133;
    v21 = (v137 ^ v135 & (v136 ^ v137)) + *v133 + v134 - 680876936;
    v22 = v133 + 1;
    v23 = v135 + __ROR4__(v21, 25);
    v24 = *v22;
    ++v22;
    v25 = v23 + __ROR4__((v136 ^ v23 & (v135 ^ v136)) + v24 + v137 - 389564586, 20);
    v26 = *v22;
    ++v22;
    v27 = v25 + __ROR4__((v135 ^ v25 & (v23 ^ v135)) + v26 + v136 + 606105819, 15);
    v28 = *v22;
    ++v22;
    v29 = v27 + __ROR4__((v23 ^ v27 & (v25 ^ v23)) + v28 + v135 - 1044525330, 10);
    v30 = *v22;
    ++v22;
    v31 = v29 + __ROR4__((v25 ^ v29 & (v27 ^ v25)) + v30 + v23 - 176418897, 25);
    v32 = *v22;
    ++v22;
    v33 = v31 + __ROR4__((v27 ^ v31 & (v29 ^ v27)) + v32 + v25 + 1200080426, 20);
    v34 = *v22;
    ++v22;
    v35 = v33 + __ROR4__((v29 ^ v33 & (v31 ^ v29)) + v34 + v27 - 1473231341, 15);
    v36 = *v22;
    ++v22;
    v37 = v35 + __ROR4__((v31 ^ v35 & (v33 ^ v31)) + v36 + v29 - 45705983, 10);
    v38 = *v22;
    ++v22;
    v39 = v37 + __ROR4__((v33 ^ v37 & (v35 ^ v33)) + v38 + v31 + 1770035416, 25);
    v40 = *v22;
    ++v22;
    v41 = v39 + __ROR4__((v35 ^ v39 & (v37 ^ v35)) + v40 + v33 - 1958414417, 20);
    v42 = *v22;
    ++v22;
    v43 = v41 + __ROR4__((v37 ^ v41 & (v39 ^ v37)) + v42 + v35 - 42063, 15);
    v44 = *v22;
    ++v22;
    v45 = v43 + __ROR4__((v39 ^ v43 & (v41 ^ v39)) + v44 + v37 - 1990404162, 10);
    v46 = *v22;
    ++v22;
    v47 = v45 + __ROR4__((v41 ^ v45 & (v43 ^ v41)) + v46 + v39 + 1804603682, 25);
    v48 = *v22;
    ++v22;
    v49 = v47 + __ROR4__((v43 ^ v47 & (v45 ^ v43)) + v48 + v41 - 40341101, 20);
    v50 = *v22;
    ++v22;
    v51 = v49 + __ROR4__((v45 ^ v49 & (v47 ^ v45)) + v50 + v43 - 1502002290, 15);
    v52 = v47 ^ v51 & (v49 ^ v47);
    v53 = *v22;
    v133 = v22 + 1;
    v54 = v51 + __ROR4__(v52 + v53 + v45 + 1236535329, 10);
    v55 = v54 + __ROR4__(v24 + (v51 ^ v49 & (v54 ^ v51)) + v47 - 165796510, 27);
    v56 = v55 + __ROR4__(v34 + (v54 ^ v51 & (v55 ^ v54)) + v49 - 1069501632, 23);
    v57 = v56 + __ROR4__(v44 + (v55 ^ v54 & (v56 ^ v55)) + v51 + 643717713, 18);
    v58 = v57 + __ROR4__(v20 + (v56 ^ v55 & (v57 ^ v56)) + v54 - 373897302, 12);
    v59 = v58 + __ROR4__(v32 + (v57 ^ v56 & (v58 ^ v57)) + v55 - 701558691, 27);
    v60 = v59 + __ROR4__(v42 + (v58 ^ v57 & (v59 ^ v58)) + v56 + 38016083, 23);
    v61 = v60 + __ROR4__(v53 + (v59 ^ v58 & (v60 ^ v59)) + v57 - 660478335, 18);
    v62 = v61 + __ROR4__(v30 + (v60 ^ v59 & (v61 ^ v60)) + v58 - 405537848, 12);
    v63 = v62 + __ROR4__(v40 + (v61 ^ v60 & (v62 ^ v61)) + v59 + 568446438, 27);
    v64 = v63 + __ROR4__(v50 + (v62 ^ v61 & (v63 ^ v62)) + v60 - 1019803690, 23);
    v65 = v64 + __ROR4__(v28 + (v63 ^ v62 & (v64 ^ v63)) + v61 - 187363961, 18);
    v66 = v65 + __ROR4__(v38 + (v64 ^ v63 & (v65 ^ v64)) + v62 + 1163531501, 12);
    v67 = v66 + __ROR4__(v48 + (v65 ^ v64 & (v66 ^ v65)) + v63 - 1444681467, 27);
    v68 = v67 + __ROR4__(v26 + (v66 ^ v65 & (v67 ^ v66)) + v64 - 51403784, 23);
    v70 = _InterlockedExchange(&dword_805C160, v36);
    v69 = _InterlockedExchange(&dword_805C160, v52);
    _InterlockedExchange(&dword_805C160, v70);
    v71 = v68 + __ROR4__(v69 + (v67 ^ v66 & (v68 ^ v67)) + v65 + 1735328473, 18);
    v72 = v71 + __ROR4__(v46 + (v68 ^ v67 & (v71 ^ v68)) + v66 - 1926607734, 12);
    v73 = v72 + __ROR4__(v32 + (v68 ^ v72 ^ v71) + v67 - 378558, 28);
    v74 = v73 + __ROR4__(v38 + (v71 ^ v73 ^ v72) + v68 - 2022574463, 21);
    v75 = v74 + __ROR4__(v44 + (v72 ^ v74 ^ v73) + v71 + 1839030562, 16);
    v76 = v75 + __ROR4__(v50 + (v73 ^ v75 ^ v74) + v72 - 35309556, 9);
    v77 = v76 + __ROR4__(v24 + (v74 ^ v76 ^ v75) + v73 - 1530992060, 28);
    v78 = v77 + __ROR4__(v30 + (v75 ^ v77 ^ v76) + v74 + 1272893353, 21);
    v79 = v78 + __ROR4__(v36 + (v76 ^ v78 ^ v77) + v75 - 155497632, 16);
    v80 = v79 + __ROR4__(v42 + (v77 ^ v79 ^ v78) + v76 - 1094730640, 9);
    v81 = v80 + __ROR4__(v48 + (v78 ^ v80 ^ v79) + v77 + 681279174, 28);
    v82 = v81 + __ROR4__(v20 + (v79 ^ v81 ^ v80) + v78 - 358537222, 21);
    v83 = v82 + __ROR4__(v28 + (v80 ^ v82 ^ v81) + v79 - 722521979, 16);
    v84 = v83 + __ROR4__(v34 + (v81 ^ v83 ^ v82) + v80 + 76029189, 9);
    v85 = v84 + __ROR4__(v40 + (v82 ^ v84 ^ v83) + v81 - 640364487, 28);
    v86 = v85 + __ROR4__(v46 + (v83 ^ v85 ^ v84) + v82 - 421815835, 21);
    v87 = v86 + __ROR4__(v53 + (v84 ^ v86 ^ v85) + v83 + 530742520, 16);
    v88 = v87 + __ROR4__(v26 + (v85 ^ v87 ^ v86) + v84 - 995338651, 9);
    v89 = v88 + __ROR4__(v20 + (v87 ^ (v88 | ~v86)) + v85 - 198630844, 26);
    v90 = v89 + __ROR4__(v36 + (v88 ^ (v89 | ~v87)) + v86 + 1126891415, 22);
    v91 = v90 + __ROR4__(v50 + (v89 ^ (v90 | ~v88)) + v87 - 1416354905, 17);
    v92 = v91 + __ROR4__(v32 + (v90 ^ (v91 | ~v89)) + v88 - 57434055, 11);
    v93 = v92 + __ROR4__(v46 + (v91 ^ (v92 | ~v90)) + v89 + 1700485571, 26);
    v94 = v93 + __ROR4__(v28 + (v92 ^ (v93 | ~v91)) + v90 - 1894986606, 22);
    v95 = v94 + __ROR4__(v42 + (v93 ^ (v94 | ~v92)) + v91 - 1051523, 17);
    v96 = v95 + __ROR4__(v24 + (v94 ^ (v95 | ~v93)) + v92 - 2054922799, 11);
    v97 = v96 + __ROR4__(v38 + (v95 ^ (v96 | ~v94)) + v93 + 1873313359, 26);
    v98 = v97 + __ROR4__(v53 + (v96 ^ (v97 | ~v95)) + v94 - 30611744, 22);
    v99 = v98 + __ROR4__(v34 + (v97 ^ (v98 | ~v96)) + v95 - 1560198380, 17);
    v100 = v99 + __ROR4__(v48 + (v98 ^ (v99 | ~v97)) + v96 + 1309151649, 11);
    v101 = v100 + __ROR4__(v30 + (v99 ^ (v100 | ~v98)) + v97 - 145523070, 26);
    v102 = v101 + __ROR4__(v44 + (v100 ^ (v101 | ~v99)) + v98 - 1120210379, 22);
    v103 = v102 + __ROR4__(v26 + (v101 ^ (v102 | ~v100)) + v99 + 718787259, 17);
    v14 = v40 + (v102 ^ (v103 | ~v101));
    v134 = v16 + v101;
    v135 = v17 + v103 + __ROR4__(v14 + v100 - 343485551, 11);
    v136 = v18 + v103;
    v15 = v19;
    _CF = __CFADD__(v19, v102);
    _OF = __OFADD__(v19, v102);
    _ZF = v19 + v102 == 0;
    _SF = v19 + v102 < 0;
    v137 = v19 + v102;
  }
  __asm { pushfw }
  v113 = _InterlockedExchange(&dword_805C1A8, a2);
  v116 = _InterlockedExchange(&dword_805C1A8, v106);
  v114 = v113;
  v115 = v116;
  v132 = sub_804B557(
           (unsigned int)v133 < v138,
           v133 == (int *)v138,
           (signed int)((signed int)v133 - v138) < 0,
           __OFSUB__(v133, v138),
           _InterlockedExchange(&dword_805C1A8, v114),
           v107,
           v116);
  __asm { pushfw }
  v131 = v116;
  if ( v116 >= 10 )
  {
    v120 = _InterlockedExchange(&dword_805C13C, v115);
    v119 = _InterlockedExchange(&dword_805C13C, v117);
    _InterlockedExchange(&dword_805C13C, v120);
    if ( ((_BYTE)v115 - 1) * v119 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  _CF = (unsigned int)v131 < 0xA;
  _OF = __OFSUB__(v131, 10);
  _ZF = v131 == 10;
  _SF = v131 - 10 < 0;
  if ( v131 >= 10 )
  {
    __asm { pushfw }
    if ( v131 >= 10 )
    {
      v125 = _InterlockedExchange(&dword_805C154, v131);
      v126 = _InterlockedExchange(&dword_805C154, v118);
      v118 = _InterlockedExchange(&dword_805C154, v125);
      if ( (v126 - 1) * (_BYTE)v131 & 1 )
        abort();
    }
    __asm { popfw }
    v128 = _InterlockedExchange(&dword_805C184, v131);
    v127 = _InterlockedExchange(&dword_805C184, v118);
    v118 = _InterlockedExchange(&dword_805C184, v128);
    if ( ((_BYTE)v131 - 1) * v127 & 1 )
      abort();
  }
  __asm { popfw }
  if ( v132 != -153 )
    sub_804B60C(
      v132 < 0xFFFFFF67,
      v132 == -153,
      (signed int)(v132 + 153) < 0,
      __OFSUB__(v132, -153),
      _InterlockedExchange(&dword_805C1A8, _InterlockedExchange(&dword_805C1A8, v131)),
      _InterlockedExchange(&dword_805C1A8, v118));
  __asm { popfw }
  v129 = _InterlockedExchange(&dword_805C160, v132);
  _InterlockedExchange(&dword_805C160, v118);
  _InterlockedExchange(&dword_805C160, v129);
  *a5 = v134;
  a5[1] = v135;
  a5[2] = v136;
  result = a5;
  a5[3] = v137;
  return result;
}
// 804C84A: using guessed type int __fastcall sub_804C84A(_DWORD);
// 805C124: using guessed type int dword_805C124;
// 805C13C: using guessed type int dword_805C13C;
// 805C154: using guessed type int dword_805C154;
// 805C160: using guessed type int dword_805C160;
// 805C184: using guessed type int dword_805C184;
// 805C1A8: using guessed type int dword_805C1A8;

//----- (0804FCF9) --------------------------------------------------------
signed int sub_804FCF9()
{
  return 863;
}

//----- (0804FD04) --------------------------------------------------------
int __usercall sub_804FD04@<eax>(char _CF@<cf>, bool _ZF@<zf>, bool _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, int a8@<ebp>, int a9, int a10, int a11, signed __int32 a12, int a13, int a14)
{
  signed __int32 v14; // ebx
  signed __int32 v15; // ecx
  signed __int32 v16; // ebx
  signed __int32 v17; // et0
  signed __int32 v18; // edx
  signed __int32 v19; // ecx
  signed __int32 v20; // ebx
  signed __int32 v21; // eax
  signed __int32 v22; // edx
  int v23; // ecx
  signed __int32 v24; // ebx
  signed __int32 v25; // eax
  signed __int32 v26; // edx
  signed __int32 v27; // ecx
  signed __int32 v28; // ebx
  signed __int32 v29; // eax
  int v30; // eax
  signed __int32 v31; // edx
  signed __int32 v32; // ecx
  signed __int32 v41; // ebx
  signed __int32 v42; // ecx
  signed __int32 v43; // ebx
  signed __int32 v44; // ett
  signed __int32 v45; // ecx
  signed __int32 v46; // ebx
  char v47; // al
  signed __int32 v48; // ebx
  signed __int32 v49; // et1
  signed __int32 v50; // eax
  unsigned __int32 v51; // eax
  signed __int32 v52; // edx
  signed __int32 v53; // ecx
  signed __int32 v54; // ebx
  signed __int32 v55; // ett
  signed __int32 v56; // ebx
  signed __int32 v57; // et0
  signed __int32 v58; // edx
  signed __int32 v59; // ebx
  int v60; // eax
  signed __int32 v61; // eax
  signed __int32 v62; // edx
  signed __int32 v63; // ecx
  signed __int32 v64; // ebx
  signed __int32 v65; // eax
  signed __int32 v66; // ett
  signed __int32 v68; // [esp+38h] [ebp-14h]
  signed __int32 v69; // [esp+3Eh] [ebp-Eh]
  int v70; // [esp+48h] [ebp-4h]

  v70 = a5;
  __asm { pushfw }
  v14 = _InterlockedExchange(&dword_805C10C, a7);
  v17 = _InterlockedExchange(&dword_805C10C, a6);
  v15 = v14;
  v16 = v17;
  _InterlockedExchange(&dword_805C10C, v15);
  if ( sub_804AFDB() != 929 )
  {
    v20 = _InterlockedExchange(&dword_805C10C, v16);
    _InterlockedExchange(&dword_805C10C, v19);
    sub_804AFE5(_InterlockedExchange(&dword_805C10C, v20), v18);
  }
  __asm
  {
    popfw
    pushfw
  }
  v21 = _InterlockedExchange(&dword_805C130, v70);
  _InterlockedExchange(&dword_805C130, v18);
  _InterlockedExchange(&dword_805C130, v21);
  if ( sub_804BB55() != 654 )
  {
    v24 = _InterlockedExchange(&dword_805C130, v16);
    _InterlockedExchange(&dword_805C130, v22);
    _InterlockedExchange(&dword_805C130, v24);
    sub_804BB5F(v23);
  }
  __asm
  {
    popfw
    pushfw
  }
  v25 = _InterlockedExchange(&dword_805C13C, v70);
  _InterlockedExchange(&dword_805C13C, v22);
  _InterlockedExchange(&dword_805C13C, v25);
  if ( sub_804A392() != -637 )
  {
    v28 = _InterlockedExchange(&dword_805C13C, v16);
    _InterlockedExchange(&dword_805C13C, v26);
    sub_804A39C(v27, _InterlockedExchange(&dword_805C13C, v28));
  }
  __asm { popfw }
  v70 = a8;
  v29 = _InterlockedExchange(&dword_805C160, a12);
  _InterlockedExchange(&dword_805C160, v27);
  v30 = ((int (__fastcall *)(signed __int32, int, int, int, int, signed __int32, int, int))posix_fadvise64)(
          _InterlockedExchange(&dword_805C160, v29),
          a11,
          a9,
          a10,
          a11,
          a12,
          a13,
          a14);
  v70 = v30;
  __asm { pushfw }
  _CF = (unsigned int)v16 < 0xA;
  _OF = __OFSUB__(v16, 10);
  _ZF = v16 == 10;
  _SF = v16 - 10 < 0;
  if ( v16 >= 10 )
  {
    __asm { pushfw }
    v68 = v16;
    _CF = (unsigned int)v16 < 0xA;
    _OF = __OFSUB__(v16, 10);
    _ZF = v16 == 10;
    _SF = v16 - 10 < 0;
    if ( v16 >= 10 )
    {
      __asm { pushfw }
      v41 = _InterlockedExchange(&dword_805C148, v16);
      v44 = _InterlockedExchange(&dword_805C148, v32);
      v42 = v41;
      v43 = v44;
      _InterlockedExchange(&dword_805C148, v42);
      if ( sub_804FCF9() != 863 )
      {
        v46 = _InterlockedExchange(&dword_805C148, v43);
        _InterlockedExchange(&dword_805C148, v31);
        _InterlockedExchange(&dword_805C148, v46);
        sub_804FD03(v45);
      }
      __asm { popfw }
      v47 = v43;
      v48 = _InterlockedExchange(&dword_805C16C, v43);
      v49 = _InterlockedExchange(&dword_805C16C, v45);
      _InterlockedExchange(&dword_805C16C, v48);
      v16 = v49 - 1;
      v30 = ((_BYTE)v49 - 1) * v47 & 1;
      _CF = 0;
      _OF = 0;
      _ZF = v30 == 0;
      _SF = v30 < 0;
      if ( v30 )
        abort();
    }
    __asm { pushfw }
    v50 = _InterlockedExchange(&dword_805C154, v30);
    _InterlockedExchange(&dword_805C154, v31);
    _InterlockedExchange(&dword_805C154, v50);
    v51 = sub_804A04B();
    if ( v51 != -752 )
    {
      v54 = _InterlockedExchange(&dword_805C154, v16);
      v55 = _InterlockedExchange(&dword_805C154, v52);
      _InterlockedExchange(&dword_805C154, v54);
      sub_804A055(v51 < 0xFFFFFD10, v51 == -752, (signed int)(v51 + 752) < 0, __OFSUB__(v51, -752), v51, v53, v55);
    }
    __asm
    {
      popfw
      popfw
    }
    v56 = _InterlockedExchange(&dword_805C1A8, v68);
    v57 = _InterlockedExchange(&dword_805C1A8, v52);
    v58 = _InterlockedExchange(&dword_805C1A8, v56);
    v59 = v57 - 1;
    v60 = ((_BYTE)v57 - 1) * (_BYTE)v68 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = v60 == 0;
    _SF = v60 < 0;
    v69 = v60;
    __asm { pushfw }
    v61 = _InterlockedExchange(&dword_805C10C, v60);
    _InterlockedExchange(&dword_805C10C, v58);
    _InterlockedExchange(&dword_805C10C, v61);
    if ( sub_804AFDB() != 929 )
    {
      v64 = _InterlockedExchange(&dword_805C10C, v59);
      _InterlockedExchange(&dword_805C10C, v63);
      sub_804AFE5(_InterlockedExchange(&dword_805C10C, v64), v62);
    }
    __asm { popfw }
    v66 = _InterlockedExchange(&dword_805C160, v69);
    v65 = _InterlockedExchange(&dword_805C160, v62);
    _InterlockedExchange(&dword_805C160, v66);
    if ( v65 )
      abort();
  }
  __asm { popfw }
  return v70;
}
// 804FD04: could not find valid save-restore pair for ebp
// 8049050: using guessed type int __fastcall posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 804A39C: using guessed type int __fastcall sub_804A39C(_DWORD, _DWORD);
// 804AFE5: using guessed type int __fastcall sub_804AFE5(_DWORD, _DWORD);
// 804BB5F: using guessed type int __fastcall sub_804BB5F(_DWORD);
// 804FD03: using guessed type int __fastcall sub_804FD03(_DWORD);
// 805C10C: using guessed type int dword_805C10C;
// 805C130: using guessed type int dword_805C130;
// 805C13C: using guessed type int dword_805C13C;
// 805C148: using guessed type int dword_805C148;
// 805C154: using guessed type int dword_805C154;
// 805C160: using guessed type int dword_805C160;
// 805C16C: using guessed type int dword_805C16C;
// 805C1A8: using guessed type int dword_805C1A8;

//----- (0804FF77) --------------------------------------------------------
int __usercall sub_804FF77@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, int a9@<ebp>, FILE *stream, int a11)
{
  signed __int32 v11; // ebx
  signed __int32 v12; // ecx
  signed __int32 v13; // ebx
  signed __int32 v14; // et0
  signed __int32 v15; // edx
  int v16; // ecx
  signed __int32 v17; // ebx
  int result; // eax
  char v23; // al
  signed __int32 v24; // ebx
  char v25; // t2
  int v26; // eax
  signed __int32 v27; // ecx
  signed __int32 v28; // [esp-Ah] [ebp-36h]
  int v29; // [esp+28h] [ebp-4h]

  v29 = a5;
  __asm { pushfw }
  v11 = _InterlockedExchange(&dword_805C190, a8);
  v14 = _InterlockedExchange(&dword_805C190, a7);
  v12 = v11;
  v13 = v14;
  _InterlockedExchange(&dword_805C190, v12);
  if ( sub_804A927(_CF, _ZF, _SF, _OF, a5, a6, v14) != 625 )
  {
    v17 = _InterlockedExchange(&dword_805C190, v13);
    _InterlockedExchange(&dword_805C190, v15);
    sub_804AA62(v16, _InterlockedExchange(&dword_805C190, v17));
  }
  __asm { popfw }
  result = v29;
  v29 = a9;
  _CF = 0;
  _OF = 0;
  _ZF = stream == 0;
  _SF = (signed int)stream < 0;
  if ( stream )
  {
    __asm { pushfw }
    v28 = v13;
    if ( v13 >= 10 )
    {
      v23 = v13;
      v24 = _InterlockedExchange(&dword_805C1A8, v13);
      v25 = _InterlockedExchange(&dword_805C1A8, v15);
      _InterlockedExchange(&dword_805C1A8, v24);
      if ( (v25 - 1) * v23 & 1 )
        abort();
    }
    __asm { popfw }
    v26 = fileno(stream);
    result = sub_804FD04(_CF, _ZF, _SF, _OF, v26, v27, v28, (int)&v29, v26, 0, 0, 0, 0, a11);
  }
  return result;
}
// 804FF77: could not find valid save-restore pair for ebp
// 804AA62: using guessed type int __fastcall sub_804AA62(_DWORD, _DWORD);
// 805C190: using guessed type int dword_805C190;
// 805C1A8: using guessed type int dword_805C1A8;

//----- (08050033) --------------------------------------------------------
#error "8050149: call analysis failed (funcsize=95)"

//----- (08050182) --------------------------------------------------------
const char *__usercall sub_8050182@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>, const char *a7)
{
  signed __int32 v7; // ebx
  signed __int32 v8; // et0
  signed __int32 v9; // ebx
  signed __int32 v10; // edx
  signed __int32 v11; // edx
  signed __int32 v12; // ebx
  signed __int32 v13; // et1
  signed __int32 v14; // eax
  int v15; // edx
  signed __int32 v16; // ecx
  signed __int32 v17; // eax
  signed __int32 v22; // eax
  unsigned int v23; // eax
  signed __int32 v24; // edx
  signed __int32 v25; // ecx
  char v30; // al
  signed __int32 v31; // et0
  signed __int32 v32; // ebx
  signed __int32 v33; // et1
  signed __int32 v34; // eax
  signed __int32 v35; // ecx
  int v36; // eax
  int v37; // eax
  int v42; // eax
  int v43; // eax
  signed __int32 v44; // ebx
  signed __int32 v45; // ecx
  signed __int32 v46; // ebx
  signed __int32 v47; // ett
  unsigned __int32 v48; // eax
  signed __int32 v49; // edx
  signed __int32 v50; // ecx
  signed __int32 v51; // ebx
  signed __int32 v52; // et0
  const char *result; // eax
  char *v54; // [esp+18h] [ebp-14h]
  signed __int32 v55; // [esp+1Ch] [ebp-10h]
  const char *v56; // [esp+1Ch] [ebp-10h]
  unsigned __int32 v57; // [esp+22h] [ebp-Ah]

  __asm { pushfw }
  v7 = _InterlockedExchange(&dword_805C19C, a6);
  v8 = _InterlockedExchange(&dword_805C19C, a5);
  _InterlockedExchange(&dword_805C19C, v7);
  v57 = sub_80519A9();
  __asm { pushfw }
  v9 = _InterlockedExchange(&dword_805C118, v8);
  v13 = _InterlockedExchange(&dword_805C118, v10);
  v11 = v9;
  v12 = v13;
  _InterlockedExchange(&dword_805C118, v11);
  v14 = sub_804A7B7();
  if ( v14 != 317 )
  {
    v17 = _InterlockedExchange(&dword_805C118, v14);
    _InterlockedExchange(&dword_805C118, v16);
    sub_804A7C1(_InterlockedExchange(&dword_805C118, v17), v15);
  }
  __asm { popfw }
  _CF = v57 < 0xFFFFFDA6;
  _OF = __OFSUB__(v57, -602);
  _ZF = v57 == -602;
  _SF = (signed int)(v57 + 602) < 0;
  if ( v57 != -602 )
  {
    __asm { pushfw }
    v22 = _InterlockedExchange(&dword_805C154, v57);
    _InterlockedExchange(&dword_805C154, v16);
    _InterlockedExchange(&dword_805C154, v22);
    v23 = sub_804A04B();
    _CF = v23 < 0xFFFFFD10;
    _OF = __OFSUB__(v23, -752);
    _ZF = v23 == -752;
    _SF = (signed int)(v23 + 752) < 0;
    if ( v23 != -752 )
    {
      v55 = v23;
      __asm { pushfw }
      if ( v12 >= 10 )
      {
        v31 = _InterlockedExchange(&dword_805C148, v12);
        v30 = _InterlockedExchange(&dword_805C148, v24);
        v24 = _InterlockedExchange(&dword_805C148, v31);
        if ( ((_BYTE)v12 - 1) * v30 & 1 )
          abort();
      }
      __asm { popfw }
      v32 = _InterlockedExchange(&dword_805C154, v12);
      v33 = _InterlockedExchange(&dword_805C154, v24);
      _InterlockedExchange(&dword_805C154, v32);
      sub_804A055(_CF, _ZF, _SF, _OF, v55, v25, v33);
    }
    __asm { popfw }
    v34 = _InterlockedExchange(&dword_805C19C, v57);
    _InterlockedExchange(&dword_805C19C, v24);
    sub_80519B3(_CF, _ZF, _SF, _OF, _InterlockedExchange(&dword_805C19C, v34), v12);
  }
  __asm { popfw }
  if ( !a7 )
  {
    fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
    abort();
  }
  v54 = strrchr(a7, 47);
  if ( v54 )
    v36 = (int)(v54 + 1);
  else
    v36 = (int)a7;
  v56 = (const char *)v36;
  v37 = v36 - (_DWORD)a7;
  _CF = (unsigned int)v37 < 6;
  _OF = __OFSUB__(v37, 6);
  _ZF = v37 == 6;
  _SF = v37 - 6 < 0;
  if ( v37 > 6 )
  {
    v42 = strncmp(v56 - 7, "/.libs/", 7u);
    _CF = 0;
    _OF = 0;
    _ZF = v42 == 0;
    _SF = v42 < 0;
    if ( !v42 )
    {
      a7 = v56;
      v43 = strncmp(v56, "lt-", 3u);
      _CF = 0;
      _OF = 0;
      _ZF = v43 == 0;
      _SF = v43 < 0;
      if ( !v43 )
      {
        _CF = __CFADD__(v56, 3);
        _OF = __OFADD__(3, v56);
        _ZF = v56 + 3 == 0;
        _SF = (signed int)(v56 + 3) < 0;
        a7 = v56 + 3;
        program_invocation_short_name = (int)(v56 + 3);
      }
    }
  }
  __asm { pushfw }
  v44 = _InterlockedExchange(&dword_805C184, v12);
  v47 = _InterlockedExchange(&dword_805C184, v35);
  v45 = v44;
  v46 = v47;
  _InterlockedExchange(&dword_805C184, v45);
  v48 = sub_804AE45();
  if ( v48 != -91 )
  {
    v51 = _InterlockedExchange(&dword_805C184, v46);
    v52 = _InterlockedExchange(&dword_805C184, v49);
    _InterlockedExchange(&dword_805C184, v51);
    sub_804AE4F(v48 < 0xFFFFFFA5, v48 == -91, (signed int)(v48 + 91) < 0, __OFSUB__(v48, -91), v48, v50, v52);
  }
  __asm { popfw }
  dword_805C738 = (int)a7;
  result = a7;
  program_invocation_name = (int)a7;
  return result;
}
// 8050182: could not find valid save-restore pair for ebp
// 804A7C1: using guessed type int __fastcall sub_804A7C1(_DWORD, _DWORD);
// 805C118: using guessed type int dword_805C118;
// 805C148: using guessed type int dword_805C148;
// 805C154: using guessed type int dword_805C154;
// 805C184: using guessed type int dword_805C184;
// 805C19C: using guessed type int dword_805C19C;
// 805C240: using guessed type int program_invocation_short_name;
// 805C250: using guessed type int program_invocation_name;
// 805C738: using guessed type int dword_805C738;

//----- (08050431) --------------------------------------------------------
signed int sub_8050431()
{
  return 110;
}

//----- (0805043B) --------------------------------------------------------
void __usercall __noreturn sub_805043B(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>)
{
  char v7; // al
  signed __int32 v8; // et0
  signed __int32 v9; // eax
  signed __int32 v10; // eax
  signed __int32 v11; // edx
  signed __int32 v12; // ecx
  signed __int32 v13; // eax
  char v14; // al
  signed __int32 v15; // ett
  signed __int32 v16; // [esp-4h] [ebp-4h]

  v16 = a5;
  __asm { pushfw }
  if ( a7 >= 10 )
  {
    v8 = _InterlockedExchange(&dword_805C118, a7);
    v7 = _InterlockedExchange(&dword_805C118, a6);
    a6 = _InterlockedExchange(&dword_805C118, v8);
    if ( ((_BYTE)a7 - 1) * v7 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  v9 = _InterlockedExchange(&dword_805C130, v16);
  _InterlockedExchange(&dword_805C130, a6);
  _InterlockedExchange(&dword_805C130, v9);
  v10 = sub_804BB55();
  if ( v10 != 654 )
  {
    v13 = _InterlockedExchange(&dword_805C130, v10);
    _InterlockedExchange(&dword_805C130, v12);
    sub_804BB5F(_InterlockedExchange(&dword_805C130, v13));
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( a7 >= 10 )
  {
    v15 = _InterlockedExchange(&dword_805C13C, a7);
    v14 = _InterlockedExchange(&dword_805C13C, v11);
    _InterlockedExchange(&dword_805C13C, v15);
    if ( ((_BYTE)a7 - 1) * v14 & 1 )
      abort();
  }
  __asm { popfw }
  __halt();
  JUMPOUT(*(_DWORD *)sub_80504E1);
}
// 804BB5F: using guessed type int __fastcall sub_804BB5F(_DWORD);
// 805C118: using guessed type int dword_805C118;
// 805C130: using guessed type int dword_805C130;
// 805C13C: using guessed type int dword_805C13C;

//----- (080504E1) --------------------------------------------------------
unsigned int __usercall sub_80504E1@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, int *a9, unsigned __int8 a10, char a11)
{
  char v15; // al
  signed __int32 v16; // ebx
  signed __int32 v17; // et0
  int v18; // eax
  char v19; // al
  signed __int32 v20; // et1
  signed __int32 v21; // eax
  unsigned __int32 v22; // eax
  signed __int32 v23; // edx
  signed __int32 v24; // ecx
  bool v25; // cf
  bool v26; // zf
  bool v27; // sf
  char v28; // of
  signed __int32 v29; // eax
  signed __int32 v30; // eax
  signed __int32 v31; // edx
  signed __int32 v36; // eax
  unsigned __int32 v37; // eax
  signed __int32 v38; // edx
  signed __int32 v39; // ecx
  bool v40; // cf
  bool v41; // zf
  bool v42; // sf
  char v43; // of
  signed __int32 v44; // eax
  int *v45; // eax
  char v46; // al
  signed __int32 v47; // ett
  signed __int32 *v48; // ST14_4
  int v49; // ST18_4
  signed __int32 v50; // edx
  char v51; // al
  signed __int32 v52; // et0
  unsigned int v53; // ST1C_4
  signed __int32 v55; // [esp-Ah] [ebp-Ah]
  signed __int32 v56; // [esp-4h] [ebp-4h]

  v56 = a5;
  __asm { pushfw }
  v55 = a8;
  _CF = (unsigned int)a8 < 0xA;
  _OF = __OFSUB__(a8, 10);
  _ZF = a8 == 10;
  _SF = a8 - 10 < 0;
  if ( a8 >= 10 )
  {
    v15 = a8;
    v16 = _InterlockedExchange(&dword_805C13C, a8);
    v17 = _InterlockedExchange(&dword_805C13C, a6);
    _InterlockedExchange(&dword_805C13C, v16);
    a8 = v17 - 1;
    v18 = ((_BYTE)v17 - 1) * v15 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = v18 == 0;
    _SF = v18 < 0;
    if ( v18 )
      abort();
  }
  __asm { pushfw }
  if ( a8 >= 10 )
  {
    v20 = _InterlockedExchange(&dword_805C130, a8);
    v19 = _InterlockedExchange(&dword_805C130, a7);
    a7 = _InterlockedExchange(&dword_805C130, v20);
    if ( ((_BYTE)a8 - 1) * v19 & 1 )
      abort();
  }
  __asm
  {
    popfw
    popfw
    pushfw
  }
  v21 = _InterlockedExchange(&dword_805C16C, v56);
  _InterlockedExchange(&dword_805C16C, a7);
  _InterlockedExchange(&dword_805C16C, v21);
  v22 = sub_805344B();
  v25 = v22 < 0x104;
  v28 = __OFSUB__(v22, 260);
  v26 = v22 == 260;
  v27 = (signed int)(v22 - 260) < 0;
  if ( v22 != 260 )
  {
    v29 = _InterlockedExchange(&dword_805C16C, v22);
    _InterlockedExchange(&dword_805C16C, v23);
    sub_8053455(v25, v26, v27, v28, _InterlockedExchange(&dword_805C16C, v29), v24, v55);
  }
  __asm { popfw }
  v30 = _InterlockedExchange(&dword_805C160, v56);
  _InterlockedExchange(&dword_805C160, v23);
  v31 = _InterlockedExchange(&dword_805C160, v30);
  _CF = 0;
  _OF = 0;
  _ZF = a9 == 0;
  _SF = (signed int)a9 < 0;
  if ( a9 )
  {
    __asm { pushfw }
    v36 = _InterlockedExchange(&dword_805C16C, a10);
    _InterlockedExchange(&dword_805C16C, v31);
    _InterlockedExchange(&dword_805C16C, v36);
    v37 = sub_805344B();
    v40 = v37 < 0x104;
    v43 = __OFSUB__(v37, 260);
    v41 = v37 == 260;
    v42 = (signed int)(v37 - 260) < 0;
    if ( v37 != 260 )
    {
      v44 = _InterlockedExchange(&dword_805C16C, v37);
      _InterlockedExchange(&dword_805C16C, v38);
      sub_8053455(v40, v41, v42, v43, _InterlockedExchange(&dword_805C16C, v44), v39, v55);
    }
    __asm { popfw }
    v45 = a9;
  }
  else
  {
    __asm { pushfw }
    if ( v55 >= 10 )
    {
      v47 = _InterlockedExchange(&dword_805C1A8, v55);
      v46 = _InterlockedExchange(&dword_805C1A8, v31);
      _InterlockedExchange(&dword_805C1A8, v47);
      if ( ((_BYTE)v55 - 1) * v46 & 1 )
        abort();
    }
    __asm { popfw }
    v45 = &dword_805C750;
  }
  v48 = &v45[(a10 >> 5) + 2];
  v49 = a10 & 0x1F;
  v50 = *v48;
  v52 = _InterlockedExchange(&dword_805C160, v49);
  v51 = _InterlockedExchange(&dword_805C160, v50);
  v53 = ((unsigned int)_InterlockedExchange(&dword_805C160, v52) >> v51) & 1;
  *v48 ^= (v53 ^ a11 & 1) << v49;
  return v53;
}
// 80504E1: could not find valid save-restore pair for ebx
// 805C130: using guessed type int dword_805C130;
// 805C13C: using guessed type int dword_805C13C;
// 805C160: using guessed type int dword_805C160;
// 805C16C: using guessed type int dword_805C16C;
// 805C1A8: using guessed type int dword_805C1A8;
// 805C750: using guessed type int dword_805C750;

//----- (080506E0) --------------------------------------------------------
int *__cdecl sub_80506E0(int *a1, int a2, int a3)
{
  int *result; // eax

  if ( !a1 )
    a1 = &dword_805C750;
  *a1 = 10;
  if ( !a2 || !a3 )
    abort();
  a1[10] = a2;
  result = a1;
  a1[11] = a3;
  return result;
}
// 805C750: using guessed type int dword_805C750;

//----- (08050750) --------------------------------------------------------
unsigned int *__userpurge sub_8050750@<eax>(signed __int32 a1@<eax>, signed __int32 a2@<ecx>, unsigned int *a3, unsigned int a4)
{
  signed __int32 v4; // eax
  signed __int32 v9; // edx
  char v10; // al
  signed __int32 v11; // et1
  signed __int32 v12; // eax
  signed __int32 v13; // et2
  signed __int32 v15; // [esp-4h] [ebp-3Ch]
  unsigned int v16; // [esp+0h] [ebp-38h]
  unsigned int v17; // [esp+4h] [ebp-34h]
  unsigned int v18; // [esp+8h] [ebp-30h]
  unsigned int v19; // [esp+Ch] [ebp-2Ch]
  unsigned int v20; // [esp+10h] [ebp-28h]
  unsigned int v21; // [esp+14h] [ebp-24h]
  unsigned int v22; // [esp+18h] [ebp-20h]
  unsigned int v23; // [esp+1Ch] [ebp-1Ch]
  unsigned int v24; // [esp+20h] [ebp-18h]
  unsigned int v25; // [esp+24h] [ebp-14h]
  unsigned int v26; // [esp+28h] [ebp-10h]
  int v27; // [esp+2Ch] [ebp-Ch]

  v4 = _InterlockedExchange(&dword_805C160, a1);
  _InterlockedExchange(&dword_805C160, a2);
  _InterlockedExchange(&dword_805C160, v4);
  memset(&v16, 0, 0x30u);
  _CF = a4 < 0xA;
  _OF = __OFSUB__(a4, 10);
  _ZF = a4 == 10;
  _SF = (signed int)(a4 - 10) < 0;
  if ( a4 == 10 )
    abort();
  v16 = a4;
  *a3 = a4;
  a3[1] = v17;
  a3[2] = v18;
  a3[3] = v19;
  a3[4] = v20;
  a3[5] = v21;
  a3[6] = v22;
  a3[7] = v23;
  a3[8] = v24;
  a3[9] = v25;
  a3[10] = v26;
  v9 = v27;
  v15 = (signed __int32)a3;
  __asm { pushfw }
  if ( (signed int)&v16 >= 10 )
  {
    v11 = _InterlockedExchange(&dword_805C130, (signed __int32)&v16);
    v10 = _InterlockedExchange(&dword_805C130, v27);
    v9 = _InterlockedExchange(&dword_805C130, v11);
    if ( (unsigned __int8)((char *)&v15 + 3) * v10 & 1 )
      abort();
  }
  __asm { popfw }
  v13 = _InterlockedExchange(&dword_805C160, v15);
  v12 = _InterlockedExchange(&dword_805C160, v9);
  *(_DWORD *)(v12 + 44) = _InterlockedExchange(&dword_805C160, v13);
  return a3;
}
// 805C130: using guessed type int dword_805C130;
// 805C160: using guessed type int dword_805C160;

//----- (08050844) --------------------------------------------------------
char *__usercall sub_8050844@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, const char *msgid, int a9)
{
  signed __int32 v9; // ebx
  signed __int32 v10; // ecx
  signed __int32 v11; // ebx
  signed __int32 v12; // et0
  signed __int32 v13; // edx
  int v14; // ecx
  signed __int32 v15; // ebx
  signed __int32 v16; // eax
  unsigned __int32 v17; // eax
  signed __int32 v18; // edx
  signed __int32 v19; // ecx
  signed __int32 v20; // ebx
  signed __int32 v21; // ett
  int v22; // eax
  signed __int32 v23; // edx
  signed __int32 v24; // edx
  signed __int32 v25; // edx
  signed __int32 v26; // ecx
  char *v31; // eax
  signed __int32 v32; // ebx
  signed __int32 v33; // ecx
  signed __int32 v34; // ebx
  signed __int32 v35; // et0
  signed __int32 v36; // eax
  signed __int32 v37; // ecx
  signed __int32 v38; // eax
  char v39; // al
  signed __int32 v40; // ebx
  char v41; // t2
  char *result; // eax
  signed __int32 v47; // ebx
  signed __int32 v48; // edx
  signed __int32 v49; // ebx
  signed __int32 v50; // ett
  unsigned __int32 v51; // eax
  signed __int32 v52; // edx
  signed __int32 v53; // ecx
  bool v54; // cf
  bool v55; // zf
  bool v56; // sf
  char v57; // of
  signed __int32 v58; // eax
  signed __int32 v59; // et0
  char *v60; // [esp-4h] [ebp-30h]
  char *v61; // [esp+18h] [ebp-14h]
  unsigned __int8 *v62; // [esp+1Ch] [ebp-10h]
  signed __int32 v63; // [esp+28h] [ebp-4h]

  v63 = a5;
  __asm { pushfw }
  v9 = _InterlockedExchange(&dword_805C10C, a7);
  v12 = _InterlockedExchange(&dword_805C10C, a6);
  v10 = v9;
  v11 = v12;
  _InterlockedExchange(&dword_805C10C, v10);
  if ( sub_804AFDB() != 929 )
  {
    v15 = _InterlockedExchange(&dword_805C10C, v11);
    _InterlockedExchange(&dword_805C10C, v13);
    sub_804AFE5(v14, _InterlockedExchange(&dword_805C10C, v15));
  }
  __asm
  {
    popfw
    pushfw
  }
  v16 = _InterlockedExchange(&dword_805C178, v63);
  _InterlockedExchange(&dword_805C178, v13);
  _InterlockedExchange(&dword_805C178, v16);
  v17 = sub_8050431();
  if ( v17 != 110 )
  {
    v20 = _InterlockedExchange(&dword_805C178, v11);
    v21 = _InterlockedExchange(&dword_805C178, v18);
    _InterlockedExchange(&dword_805C178, v20);
    sub_805043B(v17 < 0x6E, v17 == 110, (signed int)(v17 - 110) < 0, __OFSUB__(v17, 110), v17, v19, v21);
  }
  __asm { popfw }
  v61 = gettext(msgid);
  if ( v61 != msgid )
    return v61;
  v62 = (unsigned __int8 *)sub_8055F5C(v11);
  if ( sub_80555E1(v24, v62, "UTF-8") )
  {
    v22 = sub_80555E1(v25, v62, "GB18030");
    if ( v22 )
    {
      if ( a9 == 9 )
        result = (char *)&unk_8057CED;
      else
        result = (char *)&unk_8057CEF;
    }
    else
    {
      _CF = *msgid < 0x60u;
      _OF = __OFSUB__(*msgid, 96);
      _ZF = *msgid == 96;
      _SF = (char)(*msgid - 96) < 0;
      if ( *msgid == 96 )
      {
        __asm { pushfw }
        v47 = _InterlockedExchange(&dword_805C154, v11);
        v50 = _InterlockedExchange(&dword_805C154, v23);
        v48 = v47;
        v49 = v50;
        _InterlockedExchange(&dword_805C154, v48);
        v51 = sub_804A04B();
        v54 = v51 < 0xFFFFFD10;
        v57 = __OFSUB__(v51, -752);
        v55 = v51 == -752;
        v56 = (signed int)(v51 + 752) < 0;
        if ( v51 != -752 )
        {
          v59 = _InterlockedExchange(&dword_805C154, v51);
          v58 = _InterlockedExchange(&dword_805C154, v52);
          _InterlockedExchange(&dword_805C154, v59);
          sub_804A055(v54, v55, v56, v57, v58, v53, v49);
        }
        __asm { popfw }
        result = (char *)&unk_8057CE6;
      }
      else
      {
        result = (char *)&unk_8057CEA;
      }
    }
  }
  else
  {
    _CF = *msgid < 0x60u;
    _OF = __OFSUB__(*msgid, 96);
    _ZF = *msgid == 96;
    _SF = (char)(*msgid - 96) < 0;
    if ( *msgid == 96 )
      v31 = (char *)&unk_8057CD6;
    else
      v31 = (char *)&unk_8057CDA;
    v60 = v31;
    __asm { pushfw }
    v32 = _InterlockedExchange(&dword_805C124, v11);
    v35 = _InterlockedExchange(&dword_805C124, v26);
    v33 = v32;
    v34 = v35;
    _InterlockedExchange(&dword_805C124, v33);
    v36 = sub_804C840();
    if ( v36 != 516 )
    {
      v38 = _InterlockedExchange(&dword_805C124, v36);
      _InterlockedExchange(&dword_805C124, v37);
      sub_804C84A(_InterlockedExchange(&dword_805C124, v38));
    }
    __asm
    {
      popfw
      pushfw
    }
    if ( v34 >= 10 )
    {
      v39 = v34;
      v40 = _InterlockedExchange(&dword_805C13C, v34);
      v41 = _InterlockedExchange(&dword_805C13C, v37);
      _InterlockedExchange(&dword_805C13C, v40);
      if ( (v41 - 1) * v39 & 1 )
        abort();
    }
    __asm { popfw }
    result = v60;
  }
  return result;
}
// 8050844: could not find valid save-restore pair for ebp
// 804AFE5: using guessed type int __fastcall sub_804AFE5(_DWORD, _DWORD);
// 804C84A: using guessed type int __fastcall sub_804C84A(_DWORD);
// 805C10C: using guessed type int dword_805C10C;
// 805C124: using guessed type int dword_805C124;
// 805C13C: using guessed type int dword_805C13C;
// 805C154: using guessed type int dword_805C154;
// 805C178: using guessed type int dword_805C178;

//----- (08050A80) --------------------------------------------------------
unsigned int __usercall sub_8050A80@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, signed __int32 a3, unsigned int a4, signed __int32 a5, unsigned __int32 a6, unsigned __int32 a7, int a8, int a9, char *a10, char *a11)
{
  signed __int32 v11; // ebx
  signed __int32 v12; // ecx
  signed __int32 v13; // ebx
  signed __int32 v14; // et0
  signed __int32 v15; // eax
  signed __int32 v16; // ecx
  signed __int32 v17; // eax
  signed __int32 v18; // edx
  signed __int32 v19; // edx
  signed __int32 v20; // ecx
  size_t v21; // eax
  signed __int32 v26; // ebx
  signed __int32 v27; // ecx
  signed __int32 v28; // et2
  signed __int32 v29; // ebx
  char v34; // al
  signed __int32 v35; // et0
  bool v36; // al
  const unsigned __int16 **v37; // eax
  signed __int32 v38; // edx
  signed __int32 v39; // ebx
  signed __int32 v40; // edx
  signed __int32 v41; // et1
  signed __int32 v42; // eax
  signed __int32 v43; // eax
  int v44; // ecx
  signed __int32 v45; // eax
  signed __int32 v46; // et0
  int v47; // eax
  signed __int32 v52; // eax
  signed __int32 v53; // ebx
  bool v54; // al
  signed __int32 v59; // ebx
  signed __int32 v60; // edx
  signed __int32 v61; // ebx
  signed __int32 v62; // ett
  unsigned __int32 v63; // eax
  signed __int32 v64; // edx
  signed __int32 v65; // ecx
  signed __int32 v66; // ebx
  signed __int32 v67; // et0
  signed __int32 v68; // eax
  unsigned int result; // eax
  signed __int32 v70; // ebx
  char *v71; // [esp+2Ch] [ebp-5Ch]
  char *v72; // [esp+30h] [ebp-58h]
  char v73; // [esp+40h] [ebp-48h]
  bool v74; // [esp+41h] [ebp-47h]
  char v75; // [esp+42h] [ebp-46h]
  char v76; // [esp+43h] [ebp-45h]
  char v77; // [esp+44h] [ebp-44h]
  unsigned __int8 v78; // [esp+45h] [ebp-43h]
  char v79; // [esp+46h] [ebp-42h]
  unsigned __int8 v80; // [esp+47h] [ebp-41h]
  char v81; // [esp+48h] [ebp-40h]
  char v82; // [esp+49h] [ebp-3Fh]
  bool v83; // [esp+4Ah] [ebp-3Eh]
  bool v84; // [esp+4Bh] [ebp-3Dh]
  wint_t wc; // [esp+4Ch] [ebp-3Ch]
  int v86; // [esp+50h] [ebp-38h]
  unsigned int v87; // [esp+54h] [ebp-34h]
  unsigned int v88; // [esp+58h] [ebp-30h]
  char *s; // [esp+5Ch] [ebp-2Ch]
  size_t n; // [esp+60h] [ebp-28h]
  unsigned __int32 v91; // [esp+64h] [ebp-24h]
  unsigned int v92; // [esp+68h] [ebp-20h]
  unsigned int v93; // [esp+6Ch] [ebp-1Ch]
  unsigned int v94; // [esp+70h] [ebp-18h]
  mbstate_t ps; // [esp+74h] [ebp-14h]
  unsigned int v96; // [esp+7Ch] [ebp-Ch]

  v72 = a10;
  v71 = a11;
  v96 = __readgsdword(0x14u);
  v87 = 0;
  v88 = 0;
  v11 = _InterlockedExchange(&dword_805C160, a2);
  v14 = _InterlockedExchange(&dword_805C160, a1);
  v12 = v11;
  v13 = v14;
  _InterlockedExchange(&dword_805C160, v12);
  s = 0;
  n = 0;
  v73 = 0;
  v15 = __ctype_get_mb_cur_max();
  _ZF = v15 == 1;
  v17 = _InterlockedExchange(&dword_805C160, v15);
  _InterlockedExchange(&dword_805C160, v18);
  v19 = _InterlockedExchange(&dword_805C160, v17);
  v84 = _ZF;
  v74 = (a8 & 2) != 0;
  v75 = 0;
  v76 = 0;
  v77 = 1;
  while ( 1 )
  {
    switch ( a7 )
    {
      case 0u:
        v74 = 0;
        break;
      case 1u:
        goto LABEL_20;
      case 2u:
        goto LABEL_23;
      case 3u:
        v73 = 1;
LABEL_20:
        v74 = 1;
        goto LABEL_21;
      case 4u:
LABEL_21:
        if ( v74 != 1 )
          v73 = 1;
LABEL_23:
        a7 = 2;
        if ( v74 != 1 )
        {
          if ( v87 < a4 )
          {
            v19 = a3;
            *(_BYTE *)(a3 + v87) = 39;
          }
          ++v87;
        }
        s = (char *)&unk_8057CEF;
        n = 1;
        break;
      case 5u:
        goto LABEL_4;
      case 6u:
        a7 = 5;
        v74 = 1;
LABEL_4:
        if ( v74 != 1 )
        {
          if ( v87 < a4 )
          {
            v19 = a3;
            *(_BYTE *)(a3 + v87) = 34;
          }
          ++v87;
        }
        v73 = 1;
        s = (char *)&unk_8057CED;
        n = 1;
        break;
      case 7u:
        v73 = 1;
        v74 = 0;
        break;
      case 8u:
      case 9u:
      case 0xAu:
        if ( a7 != 10 )
        {
          v72 = sub_8050844(
                  a7 < 0xA,
                  a7 == 10,
                  (signed int)(a7 - 10) < 0,
                  __OFSUB__(a7, 10),
                  a7,
                  v16,
                  v13,
                  (const char *)&unk_8057CF1,
                  a7);
          v71 = sub_8050844(_CF, _ZF, _SF, _OF, a7, v20, v13, (const char *)&unk_8057CEF, a7);
        }
        if ( v74 != 1 )
        {
          for ( s = v72; *s; ++s )
          {
            if ( v87 < a4 )
              *(_BYTE *)(v87 + a3) = *s;
            ++v87;
          }
        }
        v73 = 1;
        s = v71;
        n = strlen(v71);
        break;
      default:
        abort();
        return result;
    }
    v86 = 0;
LABEL_229:
    if ( a6 == -1 )
    {
      v19 = a5;
      v54 = *(_BYTE *)(a5 + v86) != 0;
    }
    else
    {
      v54 = v86 != a6;
    }
    if ( v54 )
      break;
    if ( !v87 && a7 == 2 && v74 )
      goto LABEL_256;
    if ( a7 != 2 || v74 == 1 || !v76 )
      goto LABEL_262;
    _CF = 0;
    _OF = 0;
    _ZF = v77 == 0;
    _SF = v77 < 0;
    if ( v77 )
    {
      __asm { pushfw }
      v59 = _InterlockedExchange(&dword_805C178, v13);
      v62 = _InterlockedExchange(&dword_805C178, v19);
      v60 = v59;
      v61 = v62;
      _InterlockedExchange(&dword_805C178, v60);
      v63 = sub_8050431();
      if ( v63 != 110 )
      {
        v66 = _InterlockedExchange(&dword_805C178, v61);
        v67 = _InterlockedExchange(&dword_805C178, v64);
        _InterlockedExchange(&dword_805C178, v66);
        sub_805043B(v63 < 0x6E, v63 == 110, (signed int)(v63 - 110) < 0, __OFSUB__(v63, 110), v63, v65, v67);
      }
      __asm { popfw }
      v68 = _InterlockedExchange(&dword_805C160, a6);
      _InterlockedExchange(&dword_805C160, v64);
      _InterlockedExchange(&dword_805C160, v68);
      return sub_8050A80(a3, v88, a5, a6, 5, a8, a9, v72, v71);
    }
    if ( a4 || !v88 )
    {
LABEL_262:
      if ( s && v74 != 1 )
      {
        while ( *s )
        {
          if ( v87 < a4 )
            *(_BYTE *)(v87 + a3) = *s;
          ++v87;
          ++s;
        }
      }
      if ( v87 < a4 )
        *(_BYTE *)(a3 + v87) = 0;
      return v87;
    }
    a4 = v88;
    v87 = 0;
  }
  v80 = 0;
  v81 = 0;
  v82 = 0;
  if ( v73 && a7 != 2 && n )
  {
    v13 = v86 + n;
    if ( a6 != -1 || n <= 1 )
    {
      v21 = a6;
    }
    else
    {
      v21 = strlen((const char *)a5);
      a6 = v21;
    }
    if ( v13 <= v21 && !memcmp((const void *)(v86 + a5), s, n) )
    {
      if ( v74 )
        goto LABEL_256;
      v80 = 1;
    }
  }
  v19 = a5;
  v78 = *(_BYTE *)(a5 + v86);
  switch ( v78 )
  {
    case 0u:
      if ( v73 )
      {
        if ( v74 )
          goto LABEL_256;
        v81 = 1;
        if ( a7 == 2 && v75 != 1 )
        {
          _CF = v87 < a4;
          _OF = __OFSUB__(v87, a4);
          _ZF = v87 == a4;
          _SF = (signed int)(v87 - a4) < 0;
          if ( v87 < a4 )
          {
            _CF = __CFADD__(a3, v87);
            _OF = __OFADD__(a3, v87);
            _ZF = a3 + v87 == 0;
            _SF = (signed int)(a3 + v87) < 0;
            *(_BYTE *)(a3 + v87) = 39;
          }
          __asm { pushfw }
          v26 = _InterlockedExchange(&dword_805C148, v13);
          v28 = _InterlockedExchange(&dword_805C148, v16);
          v27 = v26;
          v13 = v28;
          _InterlockedExchange(&dword_805C148, v27);
          if ( sub_804FCF9() != 863 )
          {
            v29 = _InterlockedExchange(&dword_805C148, v13);
            _InterlockedExchange(&dword_805C148, v19);
            _InterlockedExchange(&dword_805C148, v29);
            sub_804FD03(v16);
          }
          __asm { popfw }
          if ( ++v87 < a4 )
          {
            v19 = a3;
            *(_BYTE *)(a3 + v87) = 36;
          }
          if ( ++v87 < a4 )
          {
            v19 = a3;
            *(_BYTE *)(a3 + v87) = 39;
          }
          ++v87;
          v75 = 1;
        }
        if ( v87 < a4 )
        {
          v19 = a3;
          *(_BYTE *)(a3 + v87) = 92;
        }
        ++v87;
        if ( a7 != 2 && v86 + 1 < a6 )
        {
          v19 = v86 + 1;
          if ( *(_BYTE *)(v86 + 1 + a5) > 47 )
          {
            v19 = v86 + 1;
            if ( *(_BYTE *)(v86 + 1 + a5) <= 57 )
            {
              if ( v87 < a4 )
              {
                v19 = a3;
                *(_BYTE *)(a3 + v87) = 48;
              }
              if ( ++v87 < a4 )
              {
                v19 = a3;
                *(_BYTE *)(a3 + v87) = 48;
              }
              ++v87;
            }
          }
        }
        v78 = 48;
      }
      else if ( a8 & 1 )
      {
        goto LABEL_228;
      }
      goto LABEL_195;
    case 7u:
      v79 = 97;
      goto LABEL_109;
    case 8u:
      v79 = 98;
      goto LABEL_109;
    case 9u:
      v79 = 116;
      goto LABEL_103;
    case 0xAu:
      v79 = 110;
      goto LABEL_103;
    case 0xBu:
      v79 = 118;
      goto LABEL_109;
    case 0xCu:
      v79 = 102;
      goto LABEL_109;
    case 0xDu:
      v79 = 114;
      goto LABEL_103;
    case 0x20u:
      goto LABEL_117;
    case 0x21u:
    case 0x22u:
    case 0x24u:
    case 0x26u:
    case 0x28u:
    case 0x29u:
    case 0x2Au:
    case 0x3Bu:
    case 0x3Cu:
    case 0x3Du:
    case 0x3Eu:
    case 0x5Bu:
    case 0x5Eu:
    case 0x60u:
    case 0x7Cu:
      goto LABEL_118;
    case 0x23u:
    case 0x7Eu:
      goto LABEL_116;
    case 0x25u:
    case 0x2Bu:
    case 0x2Cu:
    case 0x2Du:
    case 0x2Eu:
    case 0x2Fu:
    case 0x30u:
    case 0x31u:
    case 0x32u:
    case 0x33u:
    case 0x34u:
    case 0x35u:
    case 0x36u:
    case 0x37u:
    case 0x38u:
    case 0x39u:
    case 0x3Au:
    case 0x41u:
    case 0x42u:
    case 0x43u:
    case 0x44u:
    case 0x45u:
    case 0x46u:
    case 0x47u:
    case 0x48u:
    case 0x49u:
    case 0x4Au:
    case 0x4Bu:
    case 0x4Cu:
    case 0x4Du:
    case 0x4Eu:
    case 0x4Fu:
    case 0x50u:
    case 0x51u:
    case 0x52u:
    case 0x53u:
    case 0x54u:
    case 0x55u:
    case 0x56u:
    case 0x57u:
    case 0x58u:
    case 0x59u:
    case 0x5Au:
    case 0x5Du:
    case 0x5Fu:
    case 0x61u:
    case 0x62u:
    case 0x63u:
    case 0x64u:
    case 0x65u:
    case 0x66u:
    case 0x67u:
    case 0x68u:
    case 0x69u:
    case 0x6Au:
    case 0x6Bu:
    case 0x6Cu:
    case 0x6Du:
    case 0x6Eu:
    case 0x6Fu:
    case 0x70u:
    case 0x71u:
    case 0x72u:
    case 0x73u:
    case 0x74u:
    case 0x75u:
    case 0x76u:
    case 0x77u:
    case 0x78u:
    case 0x79u:
    case 0x7Au:
      v82 = 1;
      goto LABEL_195;
    case 0x27u:
      v76 = 1;
      v82 = 1;
      if ( a7 != 2 )
        goto LABEL_195;
      if ( v74 )
        goto LABEL_256;
      if ( a4 && !v88 )
      {
        v88 = a4;
        a4 = 0;
      }
      if ( v87 < a4 )
      {
        v19 = a3;
        *(_BYTE *)(a3 + v87) = 39;
      }
      if ( ++v87 < a4 )
      {
        v19 = a3;
        *(_BYTE *)(a3 + v87) = 92;
      }
      if ( ++v87 < a4 )
      {
        v19 = a3;
        *(_BYTE *)(a3 + v87) = 39;
      }
      ++v87;
      v75 = 0;
      goto LABEL_195;
    case 0x3Fu:
      if ( a7 == 2 )
      {
        if ( v74 )
          goto LABEL_256;
      }
      else if ( a7 == 5 )
      {
        if ( a8 & 4 )
        {
          if ( v86 + 2 < a6 )
          {
            v19 = v86 + 1;
            if ( *(_BYTE *)(v86 + 1 + a5) == 63 )
            {
              v19 = v86 + 2;
              switch ( *(char *)(v86 + 2 + a5) )
              {
                case 33:
                case 39:
                case 40:
                case 41:
                case 45:
                case 47:
                case 60:
                case 61:
                case 62:
                  if ( v74 )
                    goto LABEL_256;
                  v19 = v86 + 2;
                  v78 = *(_BYTE *)(v86 + 2 + a5);
                  v86 += 2;
                  if ( v87 < a4 )
                  {
                    v19 = a3;
                    *(_BYTE *)(a3 + v87) = 63;
                  }
                  if ( ++v87 < a4 )
                  {
                    v19 = a3;
                    *(_BYTE *)(a3 + v87) = 34;
                  }
                  if ( ++v87 < a4 )
                  {
                    v19 = a3;
                    *(_BYTE *)(a3 + v87) = 34;
                  }
                  if ( ++v87 < a4 )
                  {
                    v19 = a3;
                    *(_BYTE *)(a3 + v87) = 63;
                  }
                  ++v87;
                  break;
                default:
                  goto LABEL_195;
              }
            }
          }
        }
      }
      goto LABEL_195;
    case 0x5Cu:
      v79 = *(_BYTE *)(a5 + v86);
      if ( a7 == 2 )
      {
        if ( v74 )
          goto LABEL_256;
        goto LABEL_217;
      }
      if ( v73 && v74 && n )
        goto LABEL_217;
LABEL_103:
      if ( a7 != 2 || (_CF = 0, _OF = 0, _ZF = v74 == 0, _SF = v74 < 0, !v74) )
      {
LABEL_109:
        if ( v73 )
        {
          v78 = v79;
LABEL_204:
          if ( v74 )
            goto LABEL_256;
          v81 = 1;
          if ( a7 == 2 && v75 != 1 )
          {
            if ( v87 < a4 )
            {
              v19 = a3;
              *(_BYTE *)(a3 + v87) = 39;
            }
            if ( ++v87 < a4 )
            {
              v19 = a3;
              *(_BYTE *)(a3 + v87) = 36;
            }
            if ( ++v87 < a4 )
            {
              v19 = a3;
              *(_BYTE *)(a3 + v87) = 39;
            }
            ++v87;
            v75 = 1;
          }
          if ( v87 < a4 )
          {
            v19 = a3;
            *(_BYTE *)(a3 + v87) = 92;
          }
          ++v87;
          goto LABEL_217;
        }
LABEL_195:
        if ( v73 == 1 && a7 != 2 || v74 == 1 )
        {
          if ( a9 )
          {
            v44 = v78 & 0x1F;
            v19 = *(_DWORD *)(4 * (v78 >> 5) + a9) >> v44;
            v46 = _InterlockedExchange(&dword_805C160, v19 & 1);
            v45 = _InterlockedExchange(&dword_805C160, v44);
            v16 = _InterlockedExchange(&dword_805C160, v46);
            if ( v45 )
              goto LABEL_204;
          }
        }
        v47 = v80 ^ 1;
        _CF = 0;
        _OF = 0;
        _ZF = v80 == 1;
        _SF = (v47 & 0x80u) != 0;
        if ( v80 == 1 )
          goto LABEL_204;
        __asm { pushfw }
        v52 = _InterlockedExchange(&dword_805C118, v47);
        _InterlockedExchange(&dword_805C118, v16);
        _InterlockedExchange(&dword_805C118, v52);
        if ( sub_804A7B7() != 317 )
        {
          v53 = _InterlockedExchange(&dword_805C118, v13);
          _InterlockedExchange(&dword_805C118, v19);
          sub_804A7C1(v16, _InterlockedExchange(&dword_805C118, v53));
        }
        __asm { popfw }
LABEL_217:
        if ( v75 && v81 != 1 )
        {
          if ( v87 < a4 )
          {
            v19 = a3;
            *(_BYTE *)(a3 + v87) = 39;
          }
          if ( ++v87 < a4 )
          {
            v19 = a3;
            *(_BYTE *)(a3 + v87) = 39;
          }
          ++v87;
          v75 = 0;
        }
        if ( v87 < a4 )
        {
          v19 = v87 + a3;
          *(_BYTE *)(v87 + a3) = v78;
        }
        ++v87;
        if ( v82 != 1 )
          v77 = 0;
LABEL_228:
        ++v86;
        goto LABEL_229;
      }
      __asm { pushfw }
      if ( v13 >= 10 )
      {
        v35 = _InterlockedExchange(&dword_805C19C, v13);
        v34 = _InterlockedExchange(&dword_805C19C, a5);
        v19 = _InterlockedExchange(&dword_805C19C, v35);
        if ( ((_BYTE)v13 - 1) * v34 & 1 )
          abort();
      }
      __asm { popfw }
LABEL_256:
      if ( a7 == 2 && v73 )
        a7 = 4;
      v70 = _InterlockedExchange(&dword_805C160, v13);
      _InterlockedExchange(&dword_805C160, v19);
      _InterlockedExchange(&dword_805C160, v70);
      return sub_8050A80(a3, a4, a5, a6, a7, a8 & 0xFFFFFFFD, 0, v72, v71);
    case 0x7Bu:
    case 0x7Du:
      if ( a6 == -1 )
        v36 = *(_BYTE *)(a5 + 1) != 0;
      else
        v36 = a6 != 1;
      if ( v36 )
        goto LABEL_195;
LABEL_116:
      if ( v86 )
        goto LABEL_195;
LABEL_117:
      v82 = 1;
LABEL_118:
      if ( a7 != 2 || !v74 )
        goto LABEL_195;
      goto LABEL_256;
    default:
      if ( v84 )
      {
        v91 = 1;
        v37 = __ctype_b_loc();
        v38 = v78;
        LOWORD(v37) = (*v37)[v38];
        v39 = _InterlockedExchange(&dword_805C160, v13);
        v41 = _InterlockedExchange(&dword_805C160, v38 * 2);
        v40 = v39;
        v13 = v41;
        v19 = _InterlockedExchange(&dword_805C160, v40);
        v83 = ((unsigned __int16)v37 & 0x4000) != 0;
        goto LABEL_157;
      }
      memset(&ps, 0, 8u);
      v91 = 0;
      v83 = 1;
      if ( a6 == -1 )
        a6 = strlen((const char *)a5);
      while ( 2 )
      {
        v42 = _InterlockedExchange(&dword_805C160, (signed __int32)&ps);
        _InterlockedExchange(&dword_805C160, a5 + v91 + v86);
        v93 = sub_80554BD(
                a6 - (v91 + v86),
                v13,
                (wchar_t *)&wc,
                (char *)_InterlockedExchange(&dword_805C160, v42),
                a6 - (v91 + v86),
                &ps);
        if ( v93 )
        {
          if ( v93 == -1 )
          {
            v83 = 0;
          }
          else
          {
            if ( v93 != -2 )
            {
              if ( v74 && a7 == 2 )
              {
                v92 = 1;
                while ( v92 < v93 )
                {
                  v43 = _InterlockedExchange(&dword_805C160, v91);
                  _InterlockedExchange(&dword_805C160, v91 + v86);
                  v19 = v92 + _InterlockedExchange(&dword_805C160, v43);
                  switch ( *(char *)(v19 + a5) )
                  {
                    case 91:
                    case 92:
                    case 94:
                    case 96:
                    case 124:
                      goto LABEL_256;
                    default:
                      ++v92;
                      break;
                  }
                }
              }
              if ( !iswprint(wc) )
                v83 = 0;
              v91 += v93;
              if ( mbsinit(&ps) )
                break;
              continue;
            }
            v83 = 0;
            while ( 1 )
            {
              v19 = v86;
              if ( v86 + v91 >= a6 )
                break;
              v19 = v91 + v86;
              if ( !*(_BYTE *)(v91 + v86 + a5) )
                break;
              ++v91;
            }
          }
        }
        break;
      }
LABEL_157:
      v82 = v83;
      if ( v91 <= 1 && (!v73 || v83 == 1) )
        goto LABEL_195;
      v19 = v86;
      v94 = v86 + v91;
      while ( 1 )
      {
        if ( v73 && v83 != 1 )
        {
          if ( v74 )
            goto LABEL_256;
          v81 = 1;
          if ( a7 == 2 && v75 != 1 )
          {
            if ( v87 < a4 )
            {
              v19 = a3;
              *(_BYTE *)(a3 + v87) = 39;
            }
            if ( ++v87 < a4 )
            {
              v19 = a3;
              *(_BYTE *)(a3 + v87) = 36;
            }
            if ( ++v87 < a4 )
            {
              v19 = a3;
              *(_BYTE *)(a3 + v87) = 39;
            }
            ++v87;
            v75 = 1;
          }
          if ( v87 < a4 )
          {
            v19 = a3;
            *(_BYTE *)(a3 + v87) = 92;
          }
          if ( ++v87 < a4 )
          {
            v19 = v87 + a3;
            *(_BYTE *)(v87 + a3) = (v78 >> 6) + 48;
          }
          if ( ++v87 < a4 )
          {
            v19 = v87 + a3;
            *(_BYTE *)(v87 + a3) = ((v78 >> 3) & 7) + 48;
          }
          ++v87;
          v78 = (v78 & 7) + 48;
        }
        else if ( v80 )
        {
          if ( v87 < a4 )
          {
            v19 = a3;
            *(_BYTE *)(a3 + v87) = 92;
          }
          ++v87;
          v80 = 0;
        }
        if ( v86 + 1 >= v94 )
          goto LABEL_217;
        if ( v75 && v81 != 1 )
        {
          if ( v87 < a4 )
            *(_BYTE *)(a3 + v87) = 39;
          if ( ++v87 < a4 )
            *(_BYTE *)(a3 + v87) = 39;
          ++v87;
          v75 = 0;
        }
        if ( v87 < a4 )
          *(_BYTE *)(v87 + a3) = v78;
        ++v87;
        ++v86;
        v19 = a5;
        v78 = *(_BYTE *)(a5 + v86);
      }
  }
}
// 804A7C1: using guessed type int __fastcall sub_804A7C1(_DWORD, _DWORD);
// 804FD03: using guessed type int __fastcall sub_804FD03(_DWORD);
// 805C118: using guessed type int dword_805C118;
// 805C148: using guessed type int dword_805C148;
// 805C160: using guessed type int dword_805C160;
// 805C178: using guessed type int dword_805C178;
// 805C19C: using guessed type int dword_805C19C;

//----- (080519A9) --------------------------------------------------------
signed int sub_80519A9()
{
  return -602;
}

//----- (080519B3) --------------------------------------------------------
void __usercall __noreturn sub_80519B3(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>)
{
  signed __int32 v6; // ebx
  signed __int32 v7; // edx
  signed __int32 v8; // ebx
  signed __int32 v9; // et0
  unsigned __int32 v10; // eax
  signed __int32 v11; // ecx
  signed __int32 v16; // eax
  char v17; // al
  signed __int32 v18; // et2
  signed __int32 v19; // ebx
  signed __int32 v20; // ecx
  signed __int32 v21; // ebx
  signed __int32 v22; // ett
  signed __int32 v23; // ecx
  signed __int32 v24; // ebx

  __asm { pushfw }
  v6 = _InterlockedExchange(&dword_805C124, a6);
  v9 = _InterlockedExchange(&dword_805C124, a5);
  v7 = v6;
  v8 = v9;
  _InterlockedExchange(&dword_805C124, v7);
  v10 = sub_804C840();
  _CF = v10 < 0x204;
  _OF = __OFSUB__(v10, 516);
  _ZF = v10 == 516;
  _SF = (signed int)(v10 - 516) < 0;
  if ( v10 != 516 )
  {
    v16 = _InterlockedExchange(&dword_805C124, v10);
    _InterlockedExchange(&dword_805C124, v11);
    sub_804C84A(_InterlockedExchange(&dword_805C124, v16));
  }
  __asm { pushfw }
  if ( v8 >= 10 )
  {
    v18 = _InterlockedExchange(&dword_805C118, v8);
    v17 = _InterlockedExchange(&dword_805C118, v11);
    v11 = _InterlockedExchange(&dword_805C118, v18);
    if ( ((_BYTE)v8 - 1) * v17 & 1 )
      abort();
  }
  __asm
  {
    popfw
    popfw
    pushfw
  }
  v19 = _InterlockedExchange(&dword_805C148, v8);
  v22 = _InterlockedExchange(&dword_805C148, v11);
  v20 = v19;
  v21 = v22;
  _InterlockedExchange(&dword_805C148, v20);
  if ( sub_804FCF9() != 863 )
  {
    v24 = _InterlockedExchange(&dword_805C148, v21);
    _InterlockedExchange(&dword_805C148, v23);
    sub_804FD03(_InterlockedExchange(&dword_805C148, v24));
  }
  __asm { popfw }
  __halt();
  JUMPOUT(*(_DWORD *)sub_8051A65);
}
// 804C84A: using guessed type int __fastcall sub_804C84A(_DWORD);
// 804FD03: using guessed type int __fastcall sub_804FD03(_DWORD);
// 805C118: using guessed type int dword_805C118;
// 805C124: using guessed type int dword_805C124;
// 805C148: using guessed type int dword_805C148;

//----- (08051A65) --------------------------------------------------------
signed __int32 __usercall sub_8051A65@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, signed __int32 a8, unsigned __int32 a9, _DWORD *a10, int *a11)
{
  signed __int32 v11; // eax
  unsigned __int32 v12; // eax
  signed __int32 v13; // edx
  signed __int32 v14; // ecx
  signed __int32 v15; // ebx
  signed __int32 v16; // ecx
  signed __int32 v17; // ebx
  signed __int32 v18; // et2
  signed __int32 v19; // eax
  signed __int32 v20; // edx
  int v21; // ecx
  signed __int32 v22; // eax
  int *v23; // eax
  signed __int32 v24; // edx
  signed __int32 v25; // ecx
  char v26; // al
  signed __int32 v27; // et0
  int v28; // eax
  signed __int32 v29; // ebx
  int v30; // ST4C_4
  int v31; // ST50_4
  unsigned int v32; // eax
  signed __int32 v33; // edx
  void *v34; // eax
  signed __int32 v35; // eax
  signed __int32 v36; // ecx
  signed __int32 v37; // ebx
  int *v38; // eax
  signed __int32 v39; // ecx
  signed __int32 v44; // eax
  unsigned __int32 v45; // eax
  signed __int32 v46; // ecx
  int *v48; // [esp-4h] [ebp-60h]
  int *v49; // [esp+3Ch] [ebp-20h]
  unsigned int v50; // [esp+48h] [ebp-14h]
  signed __int32 v51; // [esp+4Ch] [ebp-10h]
  signed __int32 v52; // [esp+58h] [ebp-4h]

  v52 = a5;
  __asm { pushfw }
  v11 = _InterlockedExchange(&dword_805C154, a5);
  _InterlockedExchange(&dword_805C154, a6);
  _InterlockedExchange(&dword_805C154, v11);
  v12 = sub_804A04B();
  if ( v12 != -752 )
    sub_804A055(
      v12 < 0xFFFFFD10,
      v12 == -752,
      (signed int)(v12 + 752) < 0,
      __OFSUB__(v12, -752),
      _InterlockedExchange(&dword_805C154, v14),
      _InterlockedExchange(&dword_805C154, _InterlockedExchange(&dword_805C154, v12)),
      a7);
  __asm
  {
    popfw
    pushfw
  }
  v15 = _InterlockedExchange(&dword_805C190, a7);
  v18 = _InterlockedExchange(&dword_805C190, v14);
  v16 = v15;
  v17 = v18;
  _InterlockedExchange(&dword_805C190, v16);
  v19 = sub_804A927(_CF, _ZF, _SF, _OF, v52, v13, v18);
  if ( v19 != 625 )
  {
    v22 = _InterlockedExchange(&dword_805C190, v19);
    _InterlockedExchange(&dword_805C190, v20);
    sub_804AA62(v21, _InterlockedExchange(&dword_805C190, v22));
  }
  __asm { popfw }
  if ( a11 )
    v23 = a11;
  else
    v23 = &dword_805C750;
  v49 = v23;
  v48 = __errno_location();
  __asm { pushfw }
  if ( v17 >= 10 )
  {
    v27 = _InterlockedExchange(&dword_805C118, v17);
    v26 = _InterlockedExchange(&dword_805C118, v25);
    _InterlockedExchange(&dword_805C118, v27);
    if ( ((_BYTE)v17 - 1) * v26 & 1 )
      abort();
  }
  __asm { popfw }
  v28 = *v48;
  v29 = _InterlockedExchange(&dword_805C160, v17);
  _InterlockedExchange(&dword_805C160, v24);
  _InterlockedExchange(&dword_805C160, v29);
  v30 = v28;
  v31 = v49[1] | (a10 == 0);
  v32 = sub_8050A80(
          v49[11],
          (signed __int32)(v49 + 2),
          0,
          0,
          a8,
          a9,
          *v49,
          v31,
          (int)(v49 + 2),
          (char *)v49[10],
          (char *)v49[11]);
  v50 = v32 + 1;
  v34 = sub_80544B6(v33, (signed __int32)(v49 + 2), v32 + 1);
  v51 = (signed __int32)v34;
  v35 = _InterlockedExchange(&dword_805C160, (signed __int32)v34);
  _InterlockedExchange(&dword_805C160, v36);
  _InterlockedExchange(&dword_805C160, v35);
  v37 = (signed __int32)(v49 + 2);
  sub_8050A80(v49[11], v37, v51, v50, a8, a9, *v49, v31, v37, (char *)v49[10], (char *)v49[11]);
  v38 = __errno_location();
  *v38 = v30;
  _CF = 0;
  _OF = 0;
  _ZF = a10 == 0;
  _SF = (signed int)a10 < 0;
  if ( a10 )
  {
    __asm { pushfw }
    v44 = _InterlockedExchange(&dword_805C178, (signed __int32)v38);
    _InterlockedExchange(&dword_805C178, v39);
    _InterlockedExchange(&dword_805C178, v44);
    v45 = sub_8050431();
    if ( v45 != 110 )
      sub_805043B(
        v45 < 0x6E,
        v45 == 110,
        (signed int)(v45 - 110) < 0,
        __OFSUB__(v45, 110),
        v45,
        _InterlockedExchange(&dword_805C178, _InterlockedExchange(&dword_805C178, v37)),
        _InterlockedExchange(&dword_805C178, v46));
    __asm { popfw }
    *a10 = v50 - 1;
  }
  return v51;
}
// 804AA62: using guessed type int __fastcall sub_804AA62(_DWORD, _DWORD);
// 805C118: using guessed type int dword_805C118;
// 805C154: using guessed type int dword_805C154;
// 805C160: using guessed type int dword_805C160;
// 805C178: using guessed type int dword_805C178;
// 805C190: using guessed type int dword_805C190;
// 805C750: using guessed type int dword_805C750;

//----- (08051D36) --------------------------------------------------------
void *__usercall sub_8051D36@<eax>(signed __int32 a1@<ebx>, signed __int32 a2, signed __int32 a3, unsigned __int32 a4, int a5)
{
  signed __int32 v5; // edx
  signed __int32 v6; // ecx
  char v11; // al
  signed __int32 v12; // et0
  int *v17; // eax
  signed __int32 v18; // ecx
  void *v19; // edx
  signed __int32 v20; // eax
  signed __int32 v21; // ecx
  char v22; // al
  signed __int32 v23; // et2
  unsigned int v24; // ST50_4
  signed __int32 v25; // eax
  signed __int32 v26; // ebx
  signed __int32 v27; // ecx
  signed __int32 v28; // ebx
  signed __int32 v29; // ebx
  bool v31; // [esp+37h] [ebp-21h]
  int *v32; // [esp+38h] [ebp-20h]
  void *ptr; // [esp+3Ch] [ebp-1Ch]
  int v34; // [esp+40h] [ebp-18h]
  int v35; // [esp+44h] [ebp-14h]
  int v36; // [esp+48h] [ebp-10h]
  unsigned int v37; // [esp+4Ch] [ebp-Ch]

  v34 = *__errno_location();
  v32 = off_805C1F0;
  _CF = 0;
  _OF = 0;
  _ZF = a2 == 0;
  _SF = a2 < 0;
  if ( a2 < 0 )
  {
    __asm { pushfw }
    if ( a1 >= 10 )
    {
      v12 = _InterlockedExchange(&dword_805C154, a1);
      v11 = _InterlockedExchange(&dword_805C154, v6);
      _InterlockedExchange(&dword_805C154, v12);
      if ( ((_BYTE)a1 - 1) * v11 & 1 )
        abort();
    }
    __asm { popfw }
    abort();
  }
  _CF = dword_805C1E4 < (unsigned int)a2;
  _OF = __OFSUB__(dword_805C1E4, a2);
  _ZF = dword_805C1E4 == a2;
  _SF = dword_805C1E4 - a2 < 0;
  if ( dword_805C1E4 <= a2 )
  {
    v31 = off_805C1F0 == &dword_805C1E8;
    if ( (unsigned int)a2 > 0xFFFFFFE )
      sub_805492A(a1);
    if ( v31 )
      v17 = 0;
    else
      v17 = off_805C1F0;
    v32 = (int *)sub_805465D(a1, v17, 8 * (a2 + 1));
    off_805C1F0 = v32;
    if ( v31 )
    {
      v18 = (signed __int32)v32;
      v19 = off_805C1EC;
      *v32 = dword_805C1E8;
      v32[1] = (int)v19;
    }
    v20 = _InterlockedExchange(&dword_805C160, a2);
    v21 = _InterlockedExchange(&dword_805C160, v18);
    _InterlockedExchange(&dword_805C160, v20);
    memset(&v32[2 * dword_805C1E4], 0, 8 * (v21 + 1 - dword_805C1E4));
    _CF = __CFADD__(a2, 1);
    _OF = __OFADD__(1, a2);
    _ZF = a2 == -1;
    _SF = a2 + 1 < 0;
    dword_805C1E4 = a2 + 1;
  }
  __asm { pushfw }
  if ( a1 >= 10 )
  {
    v23 = _InterlockedExchange(&dword_805C16C, a1);
    v22 = _InterlockedExchange(&dword_805C16C, v5);
    _InterlockedExchange(&dword_805C16C, v23);
    if ( ((_BYTE)a1 - 1) * v22 & 1 )
      abort();
  }
  __asm { popfw }
  v24 = v32[2 * a2];
  v25 = v32[2 * a2 + 1];
  v26 = _InterlockedExchange(&dword_805C160, a1);
  _InterlockedExchange(&dword_805C160, v6);
  _InterlockedExchange(&dword_805C160, v26);
  ptr = (void *)v25;
  v36 = *(_DWORD *)(a5 + 4) | 1;
  v37 = sub_8050A80(
          *(_DWORD *)(a5 + 44),
          a5 + 8,
          v25,
          v24,
          a3,
          a4,
          *(_DWORD *)a5,
          v36,
          a5 + 8,
          *(char **)(a5 + 40),
          *(char **)(a5 + 44));
  if ( v24 <= v37 )
  {
    v35 = v37 + 1;
    v28 = _InterlockedExchange(&dword_805C160, a5 + 8);
    _InterlockedExchange(&dword_805C160, v27);
    _InterlockedExchange(&dword_805C160, v28);
    v32[2 * a2] = v37 + 1;
    if ( ptr != &unk_805C790 )
      free(ptr);
    v29 = (signed __int32)&v32[2 * a2];
    ptr = sub_80544B6(8 * a2, v29, v35);
    *(_DWORD *)(v29 + 4) = ptr;
    sub_8050A80(
      _InterlockedExchange(&dword_805C160, _InterlockedExchange(&dword_805C160, a4)),
      a5 + 8,
      (signed __int32)ptr,
      v35,
      a3,
      _InterlockedExchange(&dword_805C160, *(_DWORD *)(a5 + 44)),
      *(_DWORD *)a5,
      v36,
      a5 + 8,
      *(char **)(a5 + 40),
      *(char **)(a5 + 44));
  }
  *__errno_location() = v34;
  return ptr;
}
// 805C154: using guessed type int dword_805C154;
// 805C160: using guessed type int dword_805C160;
// 805C16C: using guessed type int dword_805C16C;
// 805C1E4: using guessed type int dword_805C1E4;
// 805C1E8: using guessed type int dword_805C1E8;
// 805C1EC: using guessed type void *off_805C1EC;
// 805C1F0: using guessed type int *off_805C1F0;

//----- (08052326) --------------------------------------------------------
void *__usercall sub_8052326@<eax>(signed __int32 a1@<ebx>, signed __int32 a2, signed __int32 a3)
{
  signed __int32 v3; // edx
  signed __int32 v4; // ecx
  char v5; // al
  signed __int32 v6; // ebx
  signed __int32 v7; // et0
  signed __int32 v8; // ebx
  int v9; // eax
  char v14; // al
  signed __int32 v15; // ebx
  signed __int32 v16; // et1
  signed __int32 v17; // edx
  signed __int32 v18; // ebx
  int v19; // eax
  char v24; // al
  signed __int32 v25; // ebx
  char v26; // t2
  void *v28; // [esp-4h] [ebp-1Ch]

  v28 = sub_8051D36(a1, a2, a3, 0xFFFFFFFF, (int)&dword_805C750);
  __asm { pushfw }
  if ( a1 >= 10 )
  {
    v5 = a1;
    v6 = _InterlockedExchange(&dword_805C190, a1);
    v7 = _InterlockedExchange(&dword_805C190, v4);
    _InterlockedExchange(&dword_805C190, v6);
    v8 = v7 - 1;
    v9 = ((_BYTE)v7 - 1) * v5 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = v9 == 0;
    _SF = v9 < 0;
    if ( v9 )
    {
      __asm { pushfw }
      if ( v8 >= 10 )
      {
        v14 = v8;
        v15 = _InterlockedExchange(&dword_805C178, v8);
        v16 = _InterlockedExchange(&dword_805C178, v3);
        v17 = _InterlockedExchange(&dword_805C178, v15);
        v18 = v16 - 1;
        v19 = ((_BYTE)v16 - 1) * v14 & 1;
        _CF = 0;
        _OF = 0;
        _ZF = v19 == 0;
        _SF = v19 < 0;
        if ( v19 )
        {
          __asm { pushfw }
          if ( v18 >= 10 )
          {
            v24 = v18;
            v25 = _InterlockedExchange(&dword_805C154, v18);
            v26 = _InterlockedExchange(&dword_805C154, v17);
            _InterlockedExchange(&dword_805C154, v25);
            if ( (v26 - 1) * v24 & 1 )
              abort();
          }
          __asm { popfw }
          abort();
        }
      }
      __asm { popfw }
      abort();
    }
  }
  __asm { popfw }
  return v28;
}
// 805C154: using guessed type int dword_805C154;
// 805C178: using guessed type int dword_805C178;
// 805C190: using guessed type int dword_805C190;
// 805C750: using guessed type int dword_805C750;

//----- (080523F3) --------------------------------------------------------
void *__usercall sub_80523F3@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>, signed __int32 a3, signed __int32 a4, unsigned __int32 a5)
{
  signed __int32 v5; // ebx
  signed __int32 v6; // et0

  v5 = _InterlockedExchange(&dword_805C160, a2);
  v6 = _InterlockedExchange(&dword_805C160, a1);
  _InterlockedExchange(&dword_805C160, v5);
  return sub_8051D36(v6, a3, a4, a5, (int)&dword_805C750);
}
// 805C160: using guessed type int dword_805C160;
// 805C750: using guessed type int dword_805C750;

//----- (080525CD) --------------------------------------------------------
void *__usercall sub_80525CD@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, signed __int32 a3, unsigned int a4, signed __int32 a5)
{
  signed __int32 v5; // edx
  signed __int32 v6; // ecx
  char v11; // al
  signed __int32 v12; // et0
  char v13; // al
  signed __int32 v14; // ebx
  char v15; // t1
  signed __int32 v16; // eax
  signed __int32 v17; // et2
  signed __int32 v19; // [esp-Ah] [ebp-52h]
  signed __int32 v20; // [esp+4h] [ebp-44h]
  unsigned __int32 v21; // [esp+8h] [ebp-40h]
  char *v22; // [esp+Ch] [ebp-3Ch]
  char v23; // [esp+10h] [ebp-38h]

  sub_8050750((signed __int32)&v23, a1, (unsigned int *)&v23, a4);
  __asm { pushfw }
  if ( a2 >= 10 )
  {
    v12 = _InterlockedExchange(&dword_805C190, a2);
    v11 = _InterlockedExchange(&dword_805C190, v6);
    v6 = _InterlockedExchange(&dword_805C190, v12);
    if ( ((_BYTE)a2 - 1) * v11 & 1 )
      abort();
  }
  __asm { popfw }
  _CF = (unsigned int)&v20 < 4;
  _OF = __OFSUB__(&v20, 4);
  _ZF = &v20 == 0;
  _SF = (signed int)&v20 < 0;
  v22 = &v23;
  v21 = -1;
  v20 = a5;
  __asm { pushfw }
  v19 = a2;
  if ( a2 >= 10 )
  {
    v13 = a2;
    v14 = _InterlockedExchange(&dword_805C10C, a2);
    v15 = _InterlockedExchange(&dword_805C10C, v6);
    _InterlockedExchange(&dword_805C10C, v14);
    if ( (v15 - 1) * v13 & 1 )
      abort();
  }
  __asm { popfw }
  v17 = _InterlockedExchange(&dword_805C160, a3);
  v16 = _InterlockedExchange(&dword_805C160, v5);
  _InterlockedExchange(&dword_805C160, v17);
  return sub_8051D36(v19, v16, v20, v21, (int)v22);
}
// 805C10C: using guessed type int dword_805C10C;
// 805C160: using guessed type int dword_805C160;
// 805C190: using guessed type int dword_805C190;

//----- (08052693) --------------------------------------------------------
void *__usercall sub_8052693@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, signed __int32 a3, unsigned int a4, signed __int32 a5, unsigned __int32 a6)
{
  char v7; // [esp+10h] [ebp-38h]

  sub_8050750((signed __int32)&v7, a1, (unsigned int *)&v7, a4);
  return sub_8051D36(a2, a3, a5, a6, (int)&v7);
}

//----- (080527D7) --------------------------------------------------------
void *__usercall sub_80527D7@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, signed __int32 a4, unsigned __int32 a5, unsigned __int8 a6)
{
  signed __int32 v6; // et0
  signed __int32 v7; // ebx
  signed __int32 v8; // ecx
  signed __int32 v9; // ecx
  signed __int32 v10; // ebx
  signed __int32 v11; // et1
  unsigned __int32 v12; // eax
  signed __int32 v13; // edx
  signed __int32 v18; // eax
  int v20; // [esp+20h] [ebp-38h]
  int v21; // [esp+24h] [ebp-34h]
  int v22; // [esp+28h] [ebp-30h]
  int v23; // [esp+2Ch] [ebp-2Ch]
  int v24; // [esp+30h] [ebp-28h]
  int v25; // [esp+34h] [ebp-24h]
  int v26; // [esp+38h] [ebp-20h]
  int v27; // [esp+3Ch] [ebp-1Ch]
  int v28; // [esp+40h] [ebp-18h]
  int v29; // [esp+44h] [ebp-14h]
  int v30; // [esp+48h] [ebp-10h]
  int v31; // [esp+4Ch] [ebp-Ch]

  v20 = dword_805C750;
  v21 = dword_805C754;
  v22 = dword_805C758;
  v23 = dword_805C75C;
  v24 = dword_805C760;
  v25 = dword_805C764;
  v26 = dword_805C768;
  v6 = _InterlockedExchange(&dword_805C160, dword_805C76C);
  v27 = _InterlockedExchange(&dword_805C160, a2);
  v28 = dword_805C770;
  v29 = dword_805C774;
  v30 = dword_805C778;
  v31 = dword_805C77C;
  sub_80504E1(0, 0, _SF, 0, (signed __int32)&v20, a1, _InterlockedExchange(&dword_805C160, v6), a3, &v20, a6, 1);
  __asm { pushfw }
  v7 = _InterlockedExchange(&dword_805C19C, a3);
  v11 = _InterlockedExchange(&dword_805C19C, v8);
  v9 = v7;
  v10 = v11;
  _InterlockedExchange(&dword_805C19C, v9);
  v12 = sub_80519A9();
  _CF = v12 < 0xFFFFFDA6;
  _OF = __OFSUB__(v12, -602);
  _ZF = v12 == -602;
  _SF = (signed int)(v12 + 602) < 0;
  if ( v12 != -602 )
  {
    v18 = _InterlockedExchange(&dword_805C19C, v12);
    _InterlockedExchange(&dword_805C19C, v13);
    sub_80519B3(_CF, _ZF, _SF, _OF, _InterlockedExchange(&dword_805C19C, v18), v10);
  }
  __asm { popfw }
  return sub_8051D36(v10, 0, a4, a5, (int)&v20);
}
// 805C160: using guessed type int dword_805C160;
// 805C19C: using guessed type int dword_805C19C;
// 805C750: using guessed type int dword_805C750;
// 805C754: using guessed type int dword_805C754;
// 805C758: using guessed type int dword_805C758;
// 805C75C: using guessed type int dword_805C75C;
// 805C760: using guessed type int dword_805C760;
// 805C764: using guessed type int dword_805C764;
// 805C768: using guessed type int dword_805C768;
// 805C76C: using guessed type int dword_805C76C;
// 805C770: using guessed type int dword_805C770;
// 805C774: using guessed type int dword_805C774;
// 805C778: using guessed type int dword_805C778;
// 805C77C: using guessed type int dword_805C77C;

//----- (080528DE) --------------------------------------------------------
void *__usercall sub_80528DE@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, signed __int32 a4, unsigned __int8 a5)
{
  signed __int32 v5; // ebx
  signed __int32 v6; // et0
  void *v7; // eax
  signed __int32 v12; // edx
  signed __int32 v13; // eax
  int v14; // edx
  signed __int32 v15; // ecx
  signed __int32 v16; // eax
  void *v18; // [esp-4h] [ebp-1Ch]

  v5 = _InterlockedExchange(&dword_805C160, a3);
  v6 = _InterlockedExchange(&dword_805C160, a1);
  v7 = sub_80527D7(_InterlockedExchange(&dword_805C160, v5), a2, v6, a4, 0xFFFFFFFF, a5);
  v18 = v7;
  __asm { pushfw }
  v13 = sub_804A927(
          _CF,
          _ZF,
          _SF,
          _OF,
          _InterlockedExchange(&dword_805C190, v12),
          _InterlockedExchange(&dword_805C190, _InterlockedExchange(&dword_805C190, (signed __int32)v7)),
          v6);
  if ( v13 != 625 )
  {
    v16 = _InterlockedExchange(&dword_805C190, v13);
    _InterlockedExchange(&dword_805C190, v15);
    sub_804AA62(_InterlockedExchange(&dword_805C190, v16), v14);
  }
  __asm { popfw }
  return v18;
}
// 804AA62: using guessed type int __fastcall sub_804AA62(_DWORD, _DWORD);
// 805C160: using guessed type int dword_805C160;
// 805C190: using guessed type int dword_805C190;

//----- (08052964) --------------------------------------------------------
void *__usercall sub_8052964@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>, signed __int32 a7)
{
  signed __int32 v7; // ebx
  signed __int32 v8; // edx
  signed __int32 v9; // ebx
  signed __int32 v10; // et0
  signed __int32 v11; // eax
  signed __int32 v12; // edx
  signed __int32 v13; // ecx
  signed __int32 v14; // eax
  char v15; // al
  signed __int32 v16; // ebx
  char v17; // t2
  signed __int32 v18; // ebx
  char v19; // tt
  signed __int32 v20; // edx
  char v21; // al
  signed __int32 v22; // et0
  void *v24; // [esp-4h] [ebp-20h]
  signed __int32 v25; // [esp+12h] [ebp-Ah]

  __asm { pushfw }
  v7 = _InterlockedExchange(&dword_805C124, a6);
  v10 = _InterlockedExchange(&dword_805C124, a5);
  v8 = v7;
  v9 = v10;
  _InterlockedExchange(&dword_805C124, v8);
  v11 = sub_804C840();
  if ( v11 != 516 )
  {
    v14 = _InterlockedExchange(&dword_805C124, v11);
    _InterlockedExchange(&dword_805C124, v13);
    sub_804C84A(_InterlockedExchange(&dword_805C124, v14));
  }
  __asm
  {
    popfw
    pushfw
  }
  v25 = v9;
  if ( v9 >= 10 )
  {
    v15 = v9;
    v16 = _InterlockedExchange(&dword_805C154, v9);
    v17 = _InterlockedExchange(&dword_805C154, v13);
    v13 = _InterlockedExchange(&dword_805C154, v16);
    if ( (v17 - 1) * v15 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( v25 >= 10 )
  {
    v18 = _InterlockedExchange(&dword_805C19C, v25);
    v19 = _InterlockedExchange(&dword_805C19C, v12);
    v12 = _InterlockedExchange(&dword_805C19C, v18);
    if ( (v19 - 1) * (_BYTE)v25 & 1 )
      abort();
  }
  __asm { popfw }
  v24 = sub_80528DE(v12, v13, v25, a7, 0x3Au);
  __asm { pushfw }
  if ( v25 >= 10 )
  {
    v22 = _InterlockedExchange(&dword_805C1A8, v25);
    v21 = _InterlockedExchange(&dword_805C1A8, v20);
    _InterlockedExchange(&dword_805C1A8, v22);
    if ( ((_BYTE)v25 - 1) * v21 & 1 )
      abort();
  }
  __asm { popfw }
  return v24;
}
// 8052964: could not find valid save-restore pair for ebp
// 804C84A: using guessed type int __fastcall sub_804C84A(_DWORD);
// 805C124: using guessed type int dword_805C124;
// 805C154: using guessed type int dword_805C154;
// 805C19C: using guessed type int dword_805C19C;
// 805C1A8: using guessed type int dword_805C1A8;

//----- (08052BC0) --------------------------------------------------------
void *__usercall sub_8052BC0@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, signed __int32 a3, unsigned int a4, signed __int32 a5)
{
  signed __int32 v5; // eax
  signed __int32 v6; // ecx
  signed __int32 v7; // edx
  signed __int32 v8; // ebx
  signed __int32 v9; // edx
  signed __int32 v10; // edx
  signed __int32 v11; // ebx
  signed __int32 v12; // et1
  signed __int32 v13; // edx
  signed __int32 v14; // ecx
  signed __int32 v15; // ebx
  char v16; // al
  signed __int32 v17; // ett
  signed __int32 v18; // ebx
  signed __int32 v19; // et0
  signed __int32 v20; // ebx
  signed __int32 v21; // ecx
  signed __int32 v22; // ecx
  signed __int32 v23; // ebx
  signed __int32 v24; // et1
  unsigned __int32 v25; // eax
  signed __int32 v26; // edx
  signed __int32 v27; // ecx
  signed __int32 v32; // eax
  signed __int32 v33; // et2
  void *v35; // [esp-4h] [ebp-7Ch]
  int v36; // [esp+4h] [ebp-74h]
  int v37; // [esp+10h] [ebp-68h]
  int v38; // [esp+14h] [ebp-64h]
  int v39; // [esp+18h] [ebp-60h]
  int v40; // [esp+1Ch] [ebp-5Ch]
  int v41; // [esp+20h] [ebp-58h]
  int v42; // [esp+24h] [ebp-54h]
  int v43; // [esp+28h] [ebp-50h]
  int v44; // [esp+2Ch] [ebp-4Ch]
  int v45; // [esp+30h] [ebp-48h]
  int v46; // [esp+34h] [ebp-44h]
  int v47; // [esp+38h] [ebp-40h]
  int v48; // [esp+3Ch] [ebp-3Ch]
  int v49; // [esp+40h] [ebp-38h]
  int v50; // [esp+44h] [ebp-34h]
  int v51; // [esp+48h] [ebp-30h]
  int v52; // [esp+4Ch] [ebp-2Ch]
  int v53; // [esp+50h] [ebp-28h]
  int v54; // [esp+54h] [ebp-24h]
  int v55; // [esp+58h] [ebp-20h]
  int v56; // [esp+5Ch] [ebp-1Ch]
  int v57; // [esp+60h] [ebp-18h]
  int v58; // [esp+64h] [ebp-14h]
  int v59; // [esp+68h] [ebp-10h]
  int v60; // [esp+6Ch] [ebp-Ch]

  sub_8050750((signed __int32)&v37, a1, (unsigned int *)&v37, a4);
  v49 = v37;
  v50 = v38;
  v51 = v39;
  v52 = v40;
  v53 = v41;
  v54 = v42;
  v55 = v43;
  v5 = _InterlockedExchange(&dword_805C160, v43);
  _InterlockedExchange(&dword_805C160, v6);
  v56 = v44;
  v57 = v45;
  v58 = v46;
  v59 = v47;
  v60 = v48;
  sub_80504E1(
    (unsigned int)&v36 < 4,
    &v36 == 0,
    (signed int)&v36 < 0,
    __OFSUB__(&v36, 4),
    (signed __int32)&v49,
    v7,
    _InterlockedExchange(&dword_805C160, v5),
    a2,
    &v49,
    0x3Au,
    1);
  __asm { pushfw }
  v8 = _InterlockedExchange(&dword_805C118, a2);
  v12 = _InterlockedExchange(&dword_805C118, v9);
  v10 = v8;
  v11 = v12;
  _InterlockedExchange(&dword_805C118, v10);
  if ( sub_804A7B7() != 317 )
  {
    v15 = _InterlockedExchange(&dword_805C118, v11);
    _InterlockedExchange(&dword_805C118, v14);
    sub_804A7C1(_InterlockedExchange(&dword_805C118, v15), v13);
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( v11 >= 10 )
  {
    v17 = _InterlockedExchange(&dword_805C190, v11);
    v16 = _InterlockedExchange(&dword_805C190, v13);
    v13 = _InterlockedExchange(&dword_805C190, v17);
    if ( ((_BYTE)v11 - 1) * v16 & 1 )
      abort();
  }
  __asm { popfw }
  v18 = _InterlockedExchange(&dword_805C160, v11);
  v19 = _InterlockedExchange(&dword_805C160, v13);
  _InterlockedExchange(&dword_805C160, v18);
  v35 = sub_8051D36(v19, a3, a5, 0xFFFFFFFF, (int)&v49);
  __asm { pushfw }
  v20 = _InterlockedExchange(&dword_805C184, v19);
  v24 = _InterlockedExchange(&dword_805C184, v21);
  v22 = v20;
  v23 = v24;
  _InterlockedExchange(&dword_805C184, v22);
  v25 = sub_804AE45();
  _CF = v25 < 0xFFFFFFA5;
  _OF = __OFSUB__(v25, -91);
  _ZF = v25 == -91;
  _SF = (signed int)(v25 + 91) < 0;
  if ( v25 != -91 )
  {
    v33 = _InterlockedExchange(&dword_805C184, v25);
    v32 = _InterlockedExchange(&dword_805C184, v26);
    _InterlockedExchange(&dword_805C184, v33);
    sub_804AE4F(_CF, _ZF, _SF, _OF, v32, v27, v23);
  }
  __asm { popfw }
  return v35;
}
// 804A7C1: using guessed type int __fastcall sub_804A7C1(_DWORD, _DWORD);
// 805C118: using guessed type int dword_805C118;
// 805C160: using guessed type int dword_805C160;
// 805C184: using guessed type int dword_805C184;
// 805C190: using guessed type int dword_805C190;

//----- (08052D4F) --------------------------------------------------------
void *__usercall sub_8052D4F@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, int a4, int a5, int a6, signed __int32 a7)
{
  signed __int32 v8; // ebx
  signed __int32 v9; // et0
  signed __int32 v13; // ebx
  signed __int32 v14; // edx
  signed __int32 v15; // edx
  signed __int32 v16; // ebx
  signed __int32 v17; // et1
  int v18; // edx
  signed __int32 v19; // ecx
  signed __int32 v20; // ebx
  void *v22; // [esp-4h] [ebp-2Ch]
  int savedregs; // [esp+28h] [ebp+0h]

  v8 = _InterlockedExchange(&dword_805C160, a3);
  v9 = _InterlockedExchange(&dword_805C160, a1);
  v22 = sub_8052E12(
          0,
          0,
          _SF,
          0,
          a4,
          _InterlockedExchange(&dword_805C160, v8),
          a2,
          v9,
          (int)&savedregs,
          a4,
          a5,
          a6,
          a7,
          0xFFFFFFFF);
  __asm { pushfw }
  v13 = _InterlockedExchange(&dword_805C13C, v9);
  v17 = _InterlockedExchange(&dword_805C13C, v14);
  v15 = v13;
  v16 = v17;
  _InterlockedExchange(&dword_805C13C, v15);
  if ( sub_804A392() != -637 )
  {
    v20 = _InterlockedExchange(&dword_805C13C, v16);
    _InterlockedExchange(&dword_805C13C, v19);
    sub_804A39C(_InterlockedExchange(&dword_805C13C, v20), v18);
  }
  __asm { popfw }
  return v22;
}
// 804A39C: using guessed type int __fastcall sub_804A39C(_DWORD, _DWORD);
// 805C13C: using guessed type int dword_805C13C;
// 805C160: using guessed type int dword_805C160;

//----- (08052E12) --------------------------------------------------------
void *__usercall sub_8052E12@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, int a9@<ebp>, signed __int32 a10, int a11, int a12, signed __int32 a13, unsigned __int32 a14)
{
  char v14; // al
  signed __int32 v15; // et0
  signed __int32 v16; // ebx
  signed __int32 v17; // edx
  signed __int32 v18; // ebx
  signed __int32 v19; // et1
  signed __int32 v20; // edx
  signed __int32 v21; // ecx
  char v22; // al
  signed __int32 v23; // et2
  signed __int32 v24; // ebx
  signed __int32 v25; // ett
  signed __int32 v27; // [esp-Ah] [ebp-56h]
  int v28; // [esp+10h] [ebp-3Ch]
  int v29; // [esp+14h] [ebp-38h]
  int v30; // [esp+18h] [ebp-34h]
  int v31; // [esp+1Ch] [ebp-30h]
  int v32; // [esp+20h] [ebp-2Ch]
  int v33; // [esp+24h] [ebp-28h]
  int v34; // [esp+28h] [ebp-24h]
  int v35; // [esp+2Ch] [ebp-20h]
  int v36; // [esp+30h] [ebp-1Ch]
  int v37; // [esp+34h] [ebp-18h]
  int v38; // [esp+38h] [ebp-14h]
  int v39; // [esp+3Ch] [ebp-10h]
  int v40; // [esp+42h] [ebp-Ah]
  int v41; // [esp+48h] [ebp-4h]

  v41 = a5;
  __asm { pushfw }
  v40 = a8;
  if ( a8 >= 10 )
  {
    v15 = _InterlockedExchange(&dword_805C16C, a8);
    v14 = _InterlockedExchange(&dword_805C16C, a7);
    _InterlockedExchange(&dword_805C16C, v15);
    if ( ((_BYTE)a8 - 1) * v14 & 1 )
      abort();
  }
  __asm { popfw }
  v41 = a9;
  v28 = dword_805C750;
  v29 = dword_805C754;
  v30 = dword_805C758;
  v31 = dword_805C75C;
  v32 = dword_805C760;
  v33 = dword_805C764;
  v34 = dword_805C768;
  v35 = dword_805C76C;
  v36 = dword_805C770;
  v37 = dword_805C774;
  v38 = dword_805C778;
  v16 = _InterlockedExchange(&dword_805C160, v40);
  v19 = _InterlockedExchange(&dword_805C160, a6);
  v17 = v16;
  v18 = v19;
  _InterlockedExchange(&dword_805C160, v17);
  v39 = dword_805C77C;
  sub_80506E0(&v28, a11, a12);
  __asm { pushfw }
  v27 = v19;
  if ( v19 >= 10 )
  {
    v23 = _InterlockedExchange(&dword_805C1A8, v18);
    v22 = _InterlockedExchange(&dword_805C1A8, v21);
    _InterlockedExchange(&dword_805C1A8, v23);
    if ( ((_BYTE)v18 - 1) * v22 & 1 )
      abort();
  }
  __asm { popfw }
  v24 = _InterlockedExchange(&dword_805C160, v27);
  v25 = _InterlockedExchange(&dword_805C160, v20);
  _InterlockedExchange(&dword_805C160, v24);
  return sub_8051D36(v25, a10, a13, a14, (int)&v28);
}
// 8052E12: could not find valid save-restore pair for ebp
// 805C160: using guessed type int dword_805C160;
// 805C16C: using guessed type int dword_805C16C;
// 805C1A8: using guessed type int dword_805C1A8;
// 805C750: using guessed type int dword_805C750;
// 805C754: using guessed type int dword_805C754;
// 805C758: using guessed type int dword_805C758;
// 805C75C: using guessed type int dword_805C75C;
// 805C760: using guessed type int dword_805C760;
// 805C764: using guessed type int dword_805C764;
// 805C768: using guessed type int dword_805C768;
// 805C76C: using guessed type int dword_805C76C;
// 805C770: using guessed type int dword_805C770;
// 805C774: using guessed type int dword_805C774;
// 805C778: using guessed type int dword_805C778;
// 805C77C: using guessed type int dword_805C77C;

//----- (08053163) --------------------------------------------------------
void *__usercall sub_8053163@<eax>(signed __int32 a1@<eax>, signed __int32 a2@<edx>, signed __int32 a3@<ebx>, signed __int32 a4, signed __int32 a5, unsigned __int32 a6)
{
  signed __int32 v6; // eax
  signed __int32 v11; // edx
  char v12; // al
  signed __int32 v13; // ebx
  char v14; // t1
  void *v16; // [esp-4h] [ebp-1Ch]

  v6 = _InterlockedExchange(&dword_805C160, a1);
  _InterlockedExchange(&dword_805C160, a2);
  _InterlockedExchange(&dword_805C160, v6);
  v16 = sub_8051D36(a3, a4, a5, a6, (int)&unk_805C204);
  __asm { pushfw }
  if ( a3 >= 10 )
  {
    v12 = a3;
    v13 = _InterlockedExchange(&dword_805C19C, a3);
    v14 = _InterlockedExchange(&dword_805C19C, v11);
    _InterlockedExchange(&dword_805C19C, v13);
    if ( (v14 - 1) * v12 & 1 )
      abort();
  }
  __asm { popfw }
  return v16;
}
// 805C160: using guessed type int dword_805C160;
// 805C19C: using guessed type int dword_805C19C;

//----- (08053326) --------------------------------------------------------
void *__usercall sub_8053326@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, signed __int32 a9, signed __int32 a10)
{
  signed __int32 v10; // eax
  signed __int32 v11; // et0
  signed __int32 v12; // eax
  signed __int32 v13; // edx
  signed __int32 v14; // ecx
  signed __int32 v15; // eax
  signed __int32 v16; // edx
  signed __int32 v17; // ecx
  char v22; // al
  signed __int32 v23; // ebx
  signed __int32 v24; // ett
  int v25; // eax
  char v26; // al
  signed __int32 v27; // et0
  void *v29; // [esp-4h] [ebp-20h]

  __asm { pushfw }
  v11 = _InterlockedExchange(&dword_805C190, a5);
  v10 = _InterlockedExchange(&dword_805C190, a7);
  _InterlockedExchange(&dword_805C190, v11);
  v12 = sub_804A927(_CF, _ZF, _SF, _OF, v10, a6, a8);
  if ( v12 != 625 )
  {
    v15 = _InterlockedExchange(&dword_805C190, v12);
    _InterlockedExchange(&dword_805C190, v14);
    sub_804AA62(_InterlockedExchange(&dword_805C190, v15), v13);
  }
  __asm { popfw }
  v29 = sub_8053163(
          a9,
          _InterlockedExchange(&dword_805C160, _InterlockedExchange(&dword_805C160, a10)),
          a8,
          a9,
          _InterlockedExchange(&dword_805C160, v13),
          0xFFFFFFFF);
  __asm { pushfw }
  _CF = (unsigned int)a8 < 0xA;
  _OF = __OFSUB__(a8, 10);
  _ZF = a8 == 10;
  _SF = a8 - 10 < 0;
  if ( a8 >= 10 )
  {
    v22 = a8;
    v23 = _InterlockedExchange(&dword_805C184, a8);
    v24 = _InterlockedExchange(&dword_805C184, v16);
    _InterlockedExchange(&dword_805C184, v23);
    a8 = v24 - 1;
    v25 = ((_BYTE)v24 - 1) * v22 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = v25 == 0;
    _SF = v25 < 0;
    if ( v25 )
      abort();
  }
  __asm { pushfw }
  if ( a8 >= 10 )
  {
    v27 = _InterlockedExchange(&dword_805C13C, a8);
    v26 = _InterlockedExchange(&dword_805C13C, v17);
    _InterlockedExchange(&dword_805C13C, v27);
    if ( ((_BYTE)a8 - 1) * v26 & 1 )
      abort();
  }
  __asm
  {
    popfw
    popfw
  }
  return v29;
}
// 8053326: could not find valid save-restore pair for ebp
// 804AA62: using guessed type int __fastcall sub_804AA62(_DWORD, _DWORD);
// 805C13C: using guessed type int dword_805C13C;
// 805C160: using guessed type int dword_805C160;
// 805C184: using guessed type int dword_805C184;
// 805C190: using guessed type int dword_805C190;

//----- (08053428) --------------------------------------------------------
int __usercall sub_8053428@<eax>(signed __int32 a1@<ebx>, int fd)
{
  int v3; // [esp+Ch] [ebp-Ch]

  return sub_8054BCE(a1, fd, 0, 3, v3);
}

//----- (0805344B) --------------------------------------------------------
signed int sub_805344B()
{
  return 260;
}

//----- (08053455) --------------------------------------------------------
void __usercall __noreturn sub_8053455(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>)
{
  char v7; // al
  signed __int32 v8; // et0
  signed __int32 v9; // ebx
  signed __int32 v10; // edx
  signed __int32 v11; // ebx
  signed __int32 v12; // et1
  signed __int32 v13; // eax
  signed __int32 v14; // edx
  int v15; // ecx
  signed __int32 v16; // eax
  signed __int32 v17; // ebx
  signed __int32 v18; // edx
  signed __int32 v19; // ebx
  signed __int32 v20; // ett
  signed __int32 v21; // ecx
  signed __int32 v22; // ebx
  char v23; // al
  signed __int32 v24; // ebx
  char v25; // t1

  __asm { pushfw }
  if ( a7 >= 10 )
  {
    v8 = _InterlockedExchange(&dword_805C10C, a7);
    v7 = _InterlockedExchange(&dword_805C10C, a6);
    _InterlockedExchange(&dword_805C10C, v8);
    if ( ((_BYTE)a7 - 1) * v7 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  v9 = _InterlockedExchange(&dword_805C118, a7);
  v12 = _InterlockedExchange(&dword_805C118, a5);
  v10 = v9;
  v11 = v12;
  _InterlockedExchange(&dword_805C118, v10);
  v13 = sub_804A7B7();
  if ( v13 != 317 )
  {
    v16 = _InterlockedExchange(&dword_805C118, v13);
    _InterlockedExchange(&dword_805C118, v14);
    sub_804A7C1(v15, _InterlockedExchange(&dword_805C118, v16));
  }
  __asm
  {
    popfw
    pushfw
  }
  v17 = _InterlockedExchange(&dword_805C124, v11);
  v20 = _InterlockedExchange(&dword_805C124, v14);
  v18 = v17;
  v19 = v20;
  _InterlockedExchange(&dword_805C124, v18);
  if ( sub_804C840() != 516 )
  {
    v22 = _InterlockedExchange(&dword_805C124, v19);
    _InterlockedExchange(&dword_805C124, v21);
    sub_804C84A(_InterlockedExchange(&dword_805C124, v22));
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( v19 >= 10 )
  {
    v23 = v19;
    v24 = _InterlockedExchange(&dword_805C13C, v19);
    v25 = _InterlockedExchange(&dword_805C13C, v21);
    _InterlockedExchange(&dword_805C13C, v24);
    if ( (v25 - 1) * v23 & 1 )
      abort();
  }
  __asm { popfw }
  __halt();
  JUMPOUT(*(_DWORD *)sub_805353C);
}
// 804A7C1: using guessed type int __fastcall sub_804A7C1(_DWORD, _DWORD);
// 804C84A: using guessed type int __fastcall sub_804C84A(_DWORD);
// 805C10C: using guessed type int dword_805C10C;
// 805C118: using guessed type int dword_805C118;
// 805C124: using guessed type int dword_805C124;
// 805C13C: using guessed type int dword_805C13C;

//----- (0805353C) --------------------------------------------------------
int __usercall sub_805353C@<eax>(char _CF@<cf>, bool _ZF@<zf>, bool _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, FILE *stream, int a10, int a11, int a12, signed __int32 *a13, int a14)
{
  char v14; // al
  signed __int32 v15; // ebx
  char v16; // t0
  signed __int32 v17; // eax
  unsigned __int32 v18; // eax
  signed __int32 v19; // edx
  signed __int32 v20; // ecx
  bool v21; // cf
  bool v22; // zf
  bool v23; // sf
  char v24; // of
  signed __int32 v25; // eax
  signed __int32 v30; // eax
  unsigned __int32 v31; // eax
  signed __int32 v32; // ecx
  signed __int32 v33; // edx
  signed __int32 v34; // ebx
  char v35; // t1
  char *v36; // eax
  signed __int32 v41; // edx
  signed __int32 v42; // ecx
  signed __int32 v43; // ebx
  signed __int32 v44; // edx
  signed __int32 v45; // ebx
  signed __int32 v46; // et2
  unsigned __int32 v47; // eax
  signed __int32 v48; // edx
  signed __int32 v49; // ecx
  bool v50; // cf
  bool v51; // zf
  bool v52; // sf
  char v53; // of
  signed __int32 v54; // eax
  signed __int32 v55; // ett
  signed __int32 v56; // ebx
  char *v57; // eax
  int result; // eax
  signed __int32 v59; // esi
  signed __int32 v60; // ebx
  signed __int32 v61; // ecx
  char v62; // al
  signed __int32 v63; // et0
  signed __int32 v64; // edi
  signed __int32 v65; // esi
  signed __int32 v66; // ebx
  char *v67; // eax
  signed __int32 v68; // ST58_4
  signed __int32 v69; // edi
  int *v70; // eax
  signed __int32 v71; // et1
  int v72; // esi
  signed __int32 v73; // ebx
  char *v74; // eax
  signed __int32 v75; // ST58_4
  signed __int32 v76; // ecx
  signed __int32 v77; // ST54_4
  signed __int32 v78; // edi
  signed __int32 v79; // esi
  signed __int32 v80; // ebx
  signed __int32 v81; // eax
  const char *format; // ST10_4
  signed __int32 v83; // edx
  signed __int32 v84; // ST58_4
  signed __int32 v85; // ST54_4
  signed __int32 v86; // eax
  signed __int32 v87; // et0
  int v88; // ST50_4
  signed __int32 v89; // edi
  signed __int32 v90; // esi
  signed __int32 v91; // ebx
  signed __int32 v92; // ecx
  const char *v93; // eax
  signed __int32 v94; // et1
  signed __int32 v95; // esi
  signed __int32 v96; // ST58_4
  signed __int32 v97; // ecx
  signed __int32 v98; // ST54_4
  signed __int32 v99; // ST50_4
  signed __int32 v100; // ST4C_4
  signed __int32 v101; // edi
  signed __int32 v102; // ebx
  signed __int32 v103; // ebx
  char *v104; // eax
  signed __int32 v105; // ecx
  signed __int32 v106; // ebx
  signed __int32 v107; // edi
  signed __int32 v108; // ST58_4
  signed __int32 v109; // ecx
  signed __int32 v110; // ST54_4
  signed __int32 v111; // ST50_4
  signed __int32 v112; // ST4C_4
  signed __int32 v113; // ebx
  signed __int32 v114; // ST48_4
  signed __int32 v115; // esi
  signed __int32 v116; // ebx
  char *v117; // eax
  signed __int32 v118; // ebx
  signed __int32 v119; // ecx
  signed __int32 v120; // et1
  signed __int32 v121; // edi
  signed __int32 v122; // esi
  signed __int32 v123; // eax
  signed __int32 v124; // edx
  signed __int32 v125; // ecx
  signed __int32 v126; // ebx
  signed __int32 v127; // ebx
  signed __int32 v128; // ST50_4
  signed __int32 v129; // ST4C_4
  signed __int32 v130; // ST48_4
  signed __int32 v131; // ST44_4
  signed __int32 v132; // esi
  signed __int32 v133; // ebx
  char *v134; // eax
  signed __int32 v135; // ebx
  signed __int32 v136; // ecx
  signed __int32 v137; // et1
  signed __int32 v138; // edi
  signed __int32 v139; // eax
  signed __int32 v140; // ebx
  signed __int32 v141; // ST58_4
  signed __int32 v142; // ST54_4
  signed __int32 v143; // ST50_4
  signed __int32 v144; // ST4C_4
  signed __int32 v145; // ST48_4
  signed __int32 v146; // ST44_4
  signed __int32 v147; // esi
  signed __int32 v148; // ebx
  char *v149; // eax
  char *v150; // [esp-4h] [ebp-70h]
  char *v151; // [esp-4h] [ebp-70h]
  signed __int32 v152; // [esp+48h] [ebp-24h]
  signed __int32 v153; // [esp+4Ch] [ebp-20h]
  signed __int32 v154; // [esp+62h] [ebp-Ah]
  int v155; // [esp+68h] [ebp-4h]

  v155 = a5;
  __asm { pushfw }
  v154 = a8;
  if ( a8 >= 10 )
  {
    v14 = a8;
    v15 = _InterlockedExchange(&dword_805C16C, a8);
    v16 = _InterlockedExchange(&dword_805C16C, a7);
    a7 = _InterlockedExchange(&dword_805C16C, v15);
    if ( (v16 - 1) * v14 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  v17 = _InterlockedExchange(&dword_805C1A8, v155);
  _InterlockedExchange(&dword_805C1A8, a7);
  v18 = sub_804B557(_CF, _ZF, _SF, _OF, a6, _InterlockedExchange(&dword_805C1A8, v17), v154);
  v21 = v18 < 0xFFFFFF67;
  v24 = __OFSUB__(v18, -153);
  v22 = v18 == -153;
  v23 = (signed int)(v18 + 153) < 0;
  if ( v18 != -153 )
  {
    v25 = _InterlockedExchange(&dword_805C1A8, v18);
    _InterlockedExchange(&dword_805C1A8, v19);
    _InterlockedExchange(&dword_805C1A8, v25);
    sub_804B60C(v21, v22, v23, v24, v20, v154);
  }
  __asm { popfw }
  _CF = 0;
  _OF = 0;
  _ZF = a10 == 0;
  _SF = a10 < 0;
  if ( a10 )
  {
    fprintf(stream, "%s (%s) %s\n", a10, a11, a12);
  }
  else
  {
    __asm { pushfw }
    v30 = _InterlockedExchange(&dword_805C184, v155);
    _InterlockedExchange(&dword_805C184, v20);
    _InterlockedExchange(&dword_805C184, v30);
    v31 = sub_804AE45();
    if ( v31 != -91 )
      sub_804AE4F(
        v31 < 0xFFFFFFA5,
        v31 == -91,
        (signed int)(v31 + 91) < 0,
        __OFSUB__(v31, -91),
        v31,
        _InterlockedExchange(&dword_805C184, _InterlockedExchange(&dword_805C184, v154)),
        _InterlockedExchange(&dword_805C184, v32));
    __asm { popfw }
    fprintf(stream, "%s %s\n", a11, a12);
  }
  v150 = gettext("(C)");
  __asm { pushfw }
  if ( v154 >= 10 )
  {
    v34 = _InterlockedExchange(&dword_805C13C, v154);
    v35 = _InterlockedExchange(&dword_805C13C, v33);
    _InterlockedExchange(&dword_805C13C, v34);
    if ( (v35 - 1) * (_BYTE)v154 & 1 )
      abort();
  }
  __asm { popfw }
  fprintf(stream, aCopyrightSDFre, v150, 2017);
  v36 = gettext(aLicenseGplv3Gn);
  fputs_unlocked(v36, stream);
  switch ( a14 )
  {
    case 0:
      __asm { pushfw }
      v43 = _InterlockedExchange(&dword_805C154, v154);
      v46 = _InterlockedExchange(&dword_805C154, v41);
      v44 = v43;
      v45 = v46;
      _InterlockedExchange(&dword_805C154, v44);
      v47 = sub_804A04B();
      v50 = v47 < 0xFFFFFD10;
      v53 = __OFSUB__(v47, -752);
      v51 = v47 == -752;
      v52 = (signed int)(v47 + 752) < 0;
      if ( v47 != -752 )
      {
        v55 = _InterlockedExchange(&dword_805C154, v47);
        v54 = _InterlockedExchange(&dword_805C154, v48);
        _InterlockedExchange(&dword_805C154, v55);
        sub_804A055(v50, v51, v52, v53, v54, v49, v45);
      }
      __asm { popfw }
      abort();
      return result;
    case 1:
      v56 = *a13;
      v57 = gettext("Written by %s.\n");
      result = fprintf(stream, v57, v56);
      break;
    case 2:
      v59 = a13[1];
      v60 = *a13;
      v151 = gettext("Written by %s and %s.\n");
      __asm { pushfw }
      if ( v60 >= 10 )
      {
        v63 = _InterlockedExchange(&dword_805C190, v60);
        v62 = _InterlockedExchange(&dword_805C190, v61);
        _InterlockedExchange(&dword_805C190, v63);
        if ( ((_BYTE)v60 - 1) * v62 & 1 )
          abort();
      }
      __asm { popfw }
      result = fprintf(stream, v151, v60, v59);
      break;
    case 3:
      v64 = a13[2];
      v65 = a13[1];
      v66 = *a13;
      v67 = gettext("Written by %s, %s, and %s.\n");
      result = fprintf(stream, v67, v66, v65, v64);
      break;
    case 4:
      v68 = a13[3];
      v69 = a13[2];
      v71 = _InterlockedExchange(&dword_805C160, (signed __int32)(a13 + 1));
      v70 = (int *)_InterlockedExchange(&dword_805C160, v41);
      _InterlockedExchange(&dword_805C160, v71);
      v72 = *v70;
      v73 = *a13;
      v74 = gettext("Written by %s, %s, %s,\nand %s.\n");
      result = fprintf(stream, v74, v73, v72, v69, v68);
      break;
    case 5:
      v75 = a13[4];
      v76 = a13[3];
      v77 = a13[3];
      v78 = a13[2];
      v79 = a13[1];
      v80 = *a13;
      v81 = _InterlockedExchange(&dword_805C160, (signed __int32)a13);
      _InterlockedExchange(&dword_805C160, v76);
      _InterlockedExchange(&dword_805C160, v81);
      format = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
      v83 = _InterlockedExchange(&dword_805C160, v80);
      _InterlockedExchange(&dword_805C160, v75);
      _InterlockedExchange(&dword_805C160, v83);
      result = fprintf(stream, format, v80, v79, v78, v77, v75);
      break;
    case 6:
      v84 = a13[5];
      v85 = a13[4];
      v87 = _InterlockedExchange(&dword_805C160, (signed __int32)a13);
      v86 = _InterlockedExchange(&dword_805C160, v41);
      _InterlockedExchange(&dword_805C160, v87);
      v88 = *(_DWORD *)(v86 + 12);
      v89 = a13[2];
      v90 = a13[1];
      v91 = *a13;
      v94 = _InterlockedExchange(&dword_805C160, (signed __int32)gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n"));
      v93 = (const char *)_InterlockedExchange(&dword_805C160, v92);
      _InterlockedExchange(&dword_805C160, v94);
      result = fprintf(stream, v93, v91, v90, v89, v88, v85, v84);
      break;
    case 7:
      v95 = a13[6];
      v96 = a13[5];
      v97 = a13[4];
      v98 = a13[4];
      v99 = a13[3];
      v100 = a13[2];
      v101 = a13[1];
      v102 = _InterlockedExchange(&dword_805C160, a13[2]);
      _InterlockedExchange(&dword_805C160, v97);
      _InterlockedExchange(&dword_805C160, v102);
      v103 = *a13;
      v104 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
      v105 = _InterlockedExchange(&dword_805C160, v103);
      v106 = _InterlockedExchange(&dword_805C160, v98);
      _InterlockedExchange(&dword_805C160, v105);
      result = fprintf(stream, v104, v106, v101, v100, v99, v98, v96, v95);
      break;
    case 8:
      v107 = a13[7];
      v108 = a13[6];
      v109 = a13[5];
      v110 = a13[5];
      v111 = a13[4];
      v112 = a13[3];
      v113 = _InterlockedExchange(&dword_805C160, a13[3]);
      _InterlockedExchange(&dword_805C160, v109);
      _InterlockedExchange(&dword_805C160, v113);
      v114 = a13[2];
      v115 = a13[1];
      v116 = *a13;
      v117 = gettext(aWrittenBySS);
      v118 = _InterlockedExchange(&dword_805C160, v116);
      v120 = _InterlockedExchange(&dword_805C160, v119);
      _InterlockedExchange(&dword_805C160, v118);
      result = fprintf(stream, v117, v120, v115, v114, v112, v111, v110, v108, v107);
      break;
    case 9:
      v121 = a13[8];
      v153 = a13[7];
      v152 = a13[6];
      _CF = __CFADD__(a13, 20);
      _OF = __OFADD__(20, a13);
      _ZF = a13 + 5 == 0;
      _SF = (signed int)(a13 + 5) < 0;
      v122 = a13[5];
      __asm { pushfw }
      v123 = _InterlockedExchange(&dword_805C118, (signed __int32)(a13 + 5));
      _InterlockedExchange(&dword_805C118, v41);
      _InterlockedExchange(&dword_805C118, v123);
      if ( sub_804A7B7() != 317 )
      {
        v126 = _InterlockedExchange(&dword_805C118, v154);
        _InterlockedExchange(&dword_805C118, v125);
        sub_804A7C1(_InterlockedExchange(&dword_805C118, v126), v124);
      }
      __asm { popfw }
      v127 = _InterlockedExchange(&dword_805C160, v154);
      _InterlockedExchange(&dword_805C160, v124);
      _InterlockedExchange(&dword_805C160, v127);
      v128 = v122;
      v129 = a13[4];
      v130 = a13[3];
      v131 = a13[2];
      v132 = a13[1];
      v133 = *a13;
      v134 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
      v135 = _InterlockedExchange(&dword_805C160, v133);
      v137 = _InterlockedExchange(&dword_805C160, v136);
      _InterlockedExchange(&dword_805C160, v135);
      result = fprintf(stream, v134, v137, v132, v131, v130, v129, v128, v152, v153, v121);
      break;
    default:
      v138 = a13[8];
      v139 = a13[7];
      v140 = _InterlockedExchange(&dword_805C160, v154);
      _InterlockedExchange(&dword_805C160, v42);
      _InterlockedExchange(&dword_805C160, v140);
      v141 = v139;
      v142 = a13[6];
      v143 = a13[5];
      v144 = a13[4];
      v145 = a13[3];
      v146 = a13[2];
      v147 = a13[1];
      v148 = *a13;
      v149 = gettext(aWrittenBySSSSS_2);
      result = fprintf(
                 stream,
                 (const char *)_InterlockedExchange(&dword_805C160, v141),
                 v148,
                 v147,
                 v146,
                 v145,
                 v144,
                 v143,
                 v142,
                 _InterlockedExchange(&dword_805C160, _InterlockedExchange(&dword_805C160, (signed __int32)v149)),
                 v138);
      break;
  }
  return result;
}
// 805353C: could not find valid save-restore pair for ebx
// 8048F20: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 804A7C1: using guessed type int __fastcall sub_804A7C1(_DWORD, _DWORD);
// 805C118: using guessed type int dword_805C118;
// 805C13C: using guessed type int dword_805C13C;
// 805C154: using guessed type int dword_805C154;
// 805C160: using guessed type int dword_805C160;
// 805C16C: using guessed type int dword_805C16C;
// 805C184: using guessed type int dword_805C184;
// 805C190: using guessed type int dword_805C190;
// 805C1A8: using guessed type int dword_805C1A8;

//----- (08053DEF) --------------------------------------------------------
int __usercall sub_8053DEF@<eax>(char _CF@<cf>, bool _ZF@<zf>, bool _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, int a8@<ebp>, FILE *a9, int a10, int a11, int a12, signed __int32 *a13)
{
  signed __int32 v21; // ebx
  signed __int32 v22; // ecx
  signed __int32 v23; // ebx
  signed __int32 v24; // et0
  signed __int32 v25; // edx
  signed __int32 v26; // ecx
  signed __int32 v27; // ebx
  char v28; // al
  signed __int32 v29; // et2
  signed __int32 v30; // ebx
  signed __int32 v31; // ett
  signed __int32 v32; // ecx
  signed __int32 v33; // ebx
  char v34; // t0
  signed __int32 v35; // ebx
  int v36; // eax
  char v41; // al
  signed __int32 v42; // et1
  signed __int32 v43; // eax
  signed __int32 v44; // edx
  signed __int32 v45; // ecx
  signed __int32 v46; // ebx
  signed __int32 *v48; // eax
  signed __int32 v49; // edx
  char v54; // al
  signed __int32 v55; // ebx
  signed __int32 v56; // et1
  signed __int32 v57; // ebx
  int v58; // eax
  char v63; // al
  signed __int32 v64; // ebx
  char v65; // t2
  signed __int32 v66; // [esp-Ah] [ebp-66h]
  signed __int32 v67; // [esp-4h] [ebp-60h]
  unsigned int i; // [esp+24h] [ebp-38h]
  int v69; // [esp+28h] [ebp-34h]
  int v70; // [esp+44h] [ebp-18h]
  int v71; // [esp+48h] [ebp-14h]
  int v72; // [esp+4Eh] [ebp-Eh]
  int v73; // [esp+52h] [ebp-Ah]
  int v74; // [esp+58h] [ebp-4h]

  v74 = a5;
  __asm { pushfw }
  v73 = a7;
  _CF = (unsigned int)a7 < 0xA;
  _OF = __OFSUB__(a7, 10);
  _ZF = a7 == 10;
  _SF = a7 - 10 < 0;
  if ( a7 >= 10 )
  {
    v72 = a5;
    __asm { pushfw }
    v71 = a7;
    _CF = (unsigned int)a7 < 0xA;
    _OF = __OFSUB__(a7, 10);
    _ZF = a7 == 10;
    _SF = a7 - 10 < 0;
    if ( a7 >= 10 )
    {
      v70 = a5;
      __asm { pushfw }
      v21 = _InterlockedExchange(&dword_805C13C, a7);
      v24 = _InterlockedExchange(&dword_805C13C, a6);
      v22 = v21;
      v23 = v24;
      _InterlockedExchange(&dword_805C13C, v22);
      if ( sub_804A392() != -637 )
      {
        v27 = _InterlockedExchange(&dword_805C13C, v23);
        _InterlockedExchange(&dword_805C13C, v25);
        sub_804A39C(v26, _InterlockedExchange(&dword_805C13C, v27));
      }
      __asm { popfw }
      v29 = _InterlockedExchange(&dword_805C16C, v23);
      v28 = _InterlockedExchange(&dword_805C16C, v26);
      a6 = _InterlockedExchange(&dword_805C16C, v29);
      if ( ((_BYTE)v23 - 1) * v28 & 1 )
        abort();
    }
    __asm { popfw }
    v30 = _InterlockedExchange(&dword_805C160, v71);
    v31 = _InterlockedExchange(&dword_805C160, a6);
    v32 = _InterlockedExchange(&dword_805C160, v30);
    v33 = _InterlockedExchange(&dword_805C19C, v31);
    v34 = _InterlockedExchange(&dword_805C19C, v32);
    a6 = _InterlockedExchange(&dword_805C19C, v33);
    if ( (v34 - 1) * (_BYTE)v71 & 1 )
      abort();
  }
  v35 = v73;
  __asm { popfw }
  v36 = v74;
  v74 = a8;
  for ( i = 0; ; ++i )
  {
    _CF = i < 9;
    _OF = __OFSUB__(i, 9);
    _ZF = i == 9;
    _SF = (signed int)(i - 9) < 0;
    if ( i > 9 )
      break;
    v48 = a13;
    ++a13;
    v49 = *v48;
    *(&v74 + i - 12) = *v48;
    v36 = *(&v74 + i - 12);
    _CF = 0;
    _OF = 0;
    _ZF = v36 == 0;
    _SF = v36 < 0;
    if ( !v36 )
    {
      __asm { pushfw }
      v66 = v35;
      if ( v35 >= 10 )
      {
        v54 = v35;
        v55 = _InterlockedExchange(&dword_805C1A8, v35);
        v56 = _InterlockedExchange(&dword_805C1A8, v49);
        _InterlockedExchange(&dword_805C1A8, v55);
        v57 = v56 - 1;
        v58 = ((_BYTE)v56 - 1) * v54 & 1;
        _CF = 0;
        _OF = 0;
        _ZF = v58 == 0;
        _SF = v58 < 0;
        if ( v58 )
        {
          __asm { pushfw }
          if ( v57 >= 10 )
          {
            v63 = v57;
            v64 = _InterlockedExchange(&dword_805C154, v57);
            v65 = _InterlockedExchange(&dword_805C154, a6);
            _InterlockedExchange(&dword_805C154, v64);
            if ( (v65 - 1) * v63 & 1 )
              abort();
          }
          __asm { popfw }
          abort();
        }
      }
      v35 = v66;
      __asm { popfw }
      v36 = 0;
      break;
    }
  }
  v67 = v36;
  __asm { pushfw }
  if ( v35 >= 10 )
  {
    v42 = _InterlockedExchange(&dword_805C178, v35);
    v41 = _InterlockedExchange(&dword_805C178, a6);
    a6 = _InterlockedExchange(&dword_805C178, v42);
    if ( ((_BYTE)v35 - 1) * v41 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  v43 = _InterlockedExchange(&dword_805C130, v67);
  _InterlockedExchange(&dword_805C130, a6);
  _InterlockedExchange(&dword_805C130, v43);
  if ( sub_804BB55() != 654 )
  {
    v46 = _InterlockedExchange(&dword_805C130, v35);
    _InterlockedExchange(&dword_805C130, v44);
    _InterlockedExchange(&dword_805C130, v46);
    sub_804BB5F(v45);
  }
  __asm { popfw }
  return sub_805353C(
           _CF,
           _ZF,
           _SF,
           _OF,
           (int)a9,
           v44,
           _InterlockedExchange(&dword_805C160, _InterlockedExchange(&dword_805C160, v35)),
           _InterlockedExchange(&dword_805C160, v45),
           a9,
           a10,
           a11,
           a12,
           &v69,
           i);
}
// 8053DEF: could not find valid save-restore pair for ebp
// 804A39C: using guessed type int __fastcall sub_804A39C(_DWORD, _DWORD);
// 804BB5F: using guessed type int __fastcall sub_804BB5F(_DWORD);
// 805C130: using guessed type int dword_805C130;
// 805C13C: using guessed type int dword_805C13C;
// 805C154: using guessed type int dword_805C154;
// 805C160: using guessed type int dword_805C160;
// 805C16C: using guessed type int dword_805C16C;
// 805C178: using guessed type int dword_805C178;
// 805C19C: using guessed type int dword_805C19C;
// 805C1A8: using guessed type int dword_805C1A8;

//----- (08054127) --------------------------------------------------------
int __usercall sub_8054127@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, FILE *a3, int a4, int a5, int a6, ...)
{
  bool v6; // sf
  int savedregs; // [esp+38h] [ebp+0h]
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a6);
  return sub_8053DEF(
           0,
           0,
           v6,
           0,
           (int)a3,
           _InterlockedExchange(&dword_805C160, _InterlockedExchange(&dword_805C160, a2)),
           _InterlockedExchange(&dword_805C160, a1),
           (int)&savedregs,
           a3,
           a4,
           a5,
           a6,
           (signed __int32 *)va);
}
// 805C160: using guessed type int dword_805C160;

//----- (080542C5) --------------------------------------------------------
void *__usercall sub_80542C5@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>, void *ptr, signed __int32 *a8, unsigned int a9)
{
  signed __int32 v9; // ebx
  signed __int32 v10; // edx
  signed __int32 v11; // ebx
  signed __int32 v12; // et0
  signed __int32 v13; // eax
  signed __int32 v14; // edx
  signed __int32 v15; // ecx
  signed __int32 v16; // eax
  signed __int32 v21; // eax
  signed __int32 v22; // eax
  int v23; // edx
  signed __int32 v24; // eax
  char v29; // al
  signed __int32 v30; // ebx
  signed __int32 v31; // et0
  int v32; // eax
  char v33; // al
  signed __int32 v34; // et1
  _BOOL4 v39; // eax
  signed __int32 v40; // ebx
  char v41; // t2
  signed __int32 v42; // eax
  int v47; // eax
  signed __int32 v48; // eax
  signed __int32 v49; // eax
  signed __int32 v50; // edx
  int v51; // ecx
  signed __int32 v52; // eax
  signed __int32 v54; // [esp-Ah] [ebp-36h]
  unsigned int v55; // [esp+1Ch] [ebp-10h]

  __asm { pushfw }
  v9 = _InterlockedExchange(&dword_805C130, a6);
  v12 = _InterlockedExchange(&dword_805C130, a5);
  v10 = v9;
  v11 = v12;
  _InterlockedExchange(&dword_805C130, v10);
  v13 = sub_804BB55();
  if ( v13 != 654 )
  {
    v16 = _InterlockedExchange(&dword_805C130, v13);
    _InterlockedExchange(&dword_805C130, v14);
    _InterlockedExchange(&dword_805C130, v16);
    sub_804BB5F(v15);
  }
  __asm { popfw }
  v55 = *a8;
  _CF = 0;
  _OF = 0;
  _ZF = ptr == 0;
  _SF = (signed int)ptr < 0;
  if ( ptr )
  {
    if ( 0x55555554 / a9 <= v55 )
      sub_805492A(v11);
    v47 = (v55 >> 1) + v55;
    _CF = __CFADD__(v47, 1);
    _OF = __OFADD__(1, v47);
    _ZF = v47 == -1;
    _SF = v47 + 1 < 0;
    v42 = v47 + 1;
    v55 = v42;
  }
  else
  {
    __asm { pushfw }
    v21 = _InterlockedExchange(&dword_805C13C, *a8);
    _InterlockedExchange(&dword_805C13C, v15);
    _InterlockedExchange(&dword_805C13C, v21);
    v22 = sub_804A392();
    if ( v22 != -637 )
    {
      v24 = _InterlockedExchange(&dword_805C13C, v22);
      _InterlockedExchange(&dword_805C13C, v15);
      sub_804A39C(_InterlockedExchange(&dword_805C13C, v24), v23);
    }
    __asm
    {
      popfw
      pushfw
    }
    v54 = v11;
    _CF = (unsigned int)v11 < 0xA;
    _OF = __OFSUB__(v11, 10);
    _ZF = v11 == 10;
    _SF = v11 - 10 < 0;
    if ( v11 >= 10 )
    {
      v29 = v11;
      v30 = _InterlockedExchange(&dword_805C190, v11);
      v31 = _InterlockedExchange(&dword_805C190, v15);
      v15 = _InterlockedExchange(&dword_805C190, v30);
      v11 = v31 - 1;
      v32 = ((_BYTE)v31 - 1) * v29 & 1;
      _CF = 0;
      _OF = 0;
      _ZF = v32 == 0;
      _SF = v32 < 0;
      if ( v32 )
        abort();
    }
    __asm { pushfw }
    if ( v11 >= 10 )
    {
      v34 = _InterlockedExchange(&dword_805C148, v11);
      v33 = _InterlockedExchange(&dword_805C148, v15);
      v15 = _InterlockedExchange(&dword_805C148, v34);
      if ( ((_BYTE)v11 - 1) * v33 & 1 )
        abort();
    }
    __asm
    {
      popfw
      popfw
    }
    _CF = 0;
    _OF = 0;
    _ZF = v55 == 0;
    _SF = (v55 & 0x80000000) != 0;
    if ( !v55 )
    {
      v39 = 0x40 / a9 == 0;
      _CF = __CFADD__(v39, 0x40 / a9);
      _OF = __OFADD__(v39, 0x40 / a9);
      _ZF = v39 + 0x40 / a9 == 0;
      _SF = (signed int)(v39 + 0x40 / a9) < 0;
      v55 = v39 + 0x40 / a9;
    }
    __asm { pushfw }
    if ( v54 >= 10 )
    {
      v40 = _InterlockedExchange(&dword_805C1A8, v54);
      v41 = _InterlockedExchange(&dword_805C1A8, v15);
      v15 = _InterlockedExchange(&dword_805C1A8, v40);
      if ( (v41 - 1) * (_BYTE)v54 & 1 )
        abort();
    }
    v11 = v54;
    __asm { popfw }
    v42 = 0x7FFFFFFF / a9;
    _CF = 0x7FFFFFFF / a9 < v55;
    _OF = __OFSUB__(0x7FFFFFFF / a9, v55);
    _ZF = 0x7FFFFFFF / a9 == v55;
    _SF = (signed int)(0x7FFFFFFF / a9 - v55) < 0;
    if ( 0x7FFFFFFF / a9 < v55 )
      sub_805492A(v54);
  }
  __asm { pushfw }
  v48 = _InterlockedExchange(&dword_805C130, v42);
  _InterlockedExchange(&dword_805C130, v15);
  _InterlockedExchange(&dword_805C130, v48);
  v49 = sub_804BB55();
  if ( v49 != 654 )
  {
    v52 = _InterlockedExchange(&dword_805C130, v49);
    _InterlockedExchange(&dword_805C130, v50);
    _InterlockedExchange(&dword_805C130, v52);
    sub_804BB5F(v51);
  }
  __asm { popfw }
  *a8 = v55;
  return sub_805465D(v11, ptr, a9 * v55);
}
// 80542C5: could not find valid save-restore pair for ebp
// 804A39C: using guessed type int __fastcall sub_804A39C(_DWORD, _DWORD);
// 804BB5F: using guessed type int __fastcall sub_804BB5F(_DWORD);
// 805C130: using guessed type int dword_805C130;
// 805C13C: using guessed type int dword_805C13C;
// 805C148: using guessed type int dword_805C148;
// 805C190: using guessed type int dword_805C190;
// 805C1A8: using guessed type int dword_805C1A8;

//----- (080544B6) --------------------------------------------------------
void *__usercall sub_80544B6@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>, signed __int32 a3)
{
  void *v4; // eax
  signed __int32 v8; // eax
  signed __int32 v9; // edx
  int v10; // edx
  signed __int32 v11; // ecx
  signed __int32 v12; // ebx
  void *v14; // [esp-4h] [ebp-1Ch]

  v4 = sub_8054507(0, 0, _SF, 0, a3, a1, a2, a3);
  v14 = v4;
  __asm { pushfw }
  v8 = _InterlockedExchange(&dword_805C118, (signed __int32)v4);
  _InterlockedExchange(&dword_805C118, v9);
  _InterlockedExchange(&dword_805C118, v8);
  if ( sub_804A7B7() != 317 )
  {
    v12 = _InterlockedExchange(&dword_805C118, a2);
    _InterlockedExchange(&dword_805C118, v11);
    sub_804A7C1(_InterlockedExchange(&dword_805C118, v12), v10);
  }
  __asm { popfw }
  return v14;
}
// 804A7C1: using guessed type int __fastcall sub_804A7C1(_DWORD, _DWORD);
// 805C118: using guessed type int dword_805C118;

//----- (08054507) --------------------------------------------------------
void *__usercall sub_8054507@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>, signed int size)
{
  char v8; // al
  signed __int32 v9; // ebx
  char v10; // t0
  signed __int32 v11; // ebx
  signed __int32 v12; // eax
  unsigned __int32 v13; // eax
  signed __int32 v14; // edx
  signed __int32 v15; // ecx
  signed __int32 v16; // ebx
  signed __int32 v17; // et2
  signed __int32 v18; // edx
  signed __int32 v19; // ecx
  signed __int32 v24; // ebx
  signed __int32 v25; // edx
  signed __int32 v26; // ett
  signed __int32 v27; // edx
  signed __int32 v28; // ebx
  signed __int32 v29; // ebx
  signed __int32 v30; // ecx
  signed __int32 v31; // ebx
  signed __int32 v32; // et1
  signed __int32 v33; // eax
  signed __int32 v34; // eax
  signed __int32 v35; // edx
  signed __int32 v36; // eax
  signed __int32 v37; // edx
  signed __int32 v38; // ecx
  signed __int32 v39; // eax
  signed __int32 v40; // ebx
  signed __int32 v41; // et0
  unsigned int v43; // [esp-Ah] [ebp-36h]
  void *v44; // [esp+1Ch] [ebp-10h]
  signed __int32 v45; // [esp+22h] [ebp-Ah]
  signed __int32 v46; // [esp+28h] [ebp-4h]

  v46 = a5;
  __asm { pushfw }
  v45 = a7;
  if ( a7 >= 10 )
  {
    v8 = a7;
    v9 = _InterlockedExchange(&dword_805C13C, a7);
    v10 = _InterlockedExchange(&dword_805C13C, a6);
    a6 = _InterlockedExchange(&dword_805C13C, v9);
    if ( (v10 - 1) * v8 & 1 )
      abort();
  }
  v11 = v45;
  __asm
  {
    popfw
    pushfw
  }
  v12 = _InterlockedExchange(&dword_805C184, v46);
  _InterlockedExchange(&dword_805C184, a6);
  _InterlockedExchange(&dword_805C184, v12);
  v13 = sub_804AE45();
  if ( v13 != -91 )
  {
    v16 = _InterlockedExchange(&dword_805C184, v45);
    v17 = _InterlockedExchange(&dword_805C184, v14);
    _InterlockedExchange(&dword_805C184, v16);
    sub_804AE4F(v13 < 0xFFFFFFA5, v13 == -91, (signed int)(v13 + 91) < 0, __OFSUB__(v13, -91), v13, v15, v17);
  }
  __asm { popfw }
  v44 = malloc(size);
  _CF = 0;
  _OF = 0;
  _ZF = v44 == 0;
  _SF = (signed int)v44 < 0;
  if ( !v44 )
  {
    __asm { pushfw }
    v24 = _InterlockedExchange(&dword_805C190, v45);
    v26 = _InterlockedExchange(&dword_805C190, v18);
    v25 = v24;
    v11 = v26;
    if ( sub_804A927(0, 1, 0, 0, 0, _InterlockedExchange(&dword_805C190, v25), v26) != 625 )
    {
      v28 = _InterlockedExchange(&dword_805C190, v11);
      _InterlockedExchange(&dword_805C190, v27);
      sub_804AA62(v19, _InterlockedExchange(&dword_805C190, v28));
    }
    __asm { popfw }
    _CF = 0;
    _OF = 0;
    _ZF = size == 0;
    _SF = size < 0;
    if ( size )
      sub_805492A(v11);
  }
  __asm { pushfw }
  v29 = _InterlockedExchange(&dword_805C19C, v11);
  v32 = _InterlockedExchange(&dword_805C19C, v19);
  v30 = v29;
  v31 = v32;
  _InterlockedExchange(&dword_805C19C, v30);
  v33 = sub_80519A9();
  v43 = v33;
  __asm { pushfw }
  v34 = _InterlockedExchange(&dword_805C13C, v33);
  _InterlockedExchange(&dword_805C13C, v35);
  _InterlockedExchange(&dword_805C13C, v34);
  v36 = sub_804A392();
  if ( v36 != -637 )
  {
    v39 = _InterlockedExchange(&dword_805C13C, v36);
    _InterlockedExchange(&dword_805C13C, v37);
    sub_804A39C(v38, _InterlockedExchange(&dword_805C13C, v39));
  }
  __asm { popfw }
  if ( v43 != -602 )
  {
    v40 = _InterlockedExchange(&dword_805C19C, v31);
    v41 = _InterlockedExchange(&dword_805C19C, v38);
    _InterlockedExchange(&dword_805C19C, v40);
    sub_80519B3(v43 < 0xFFFFFDA6, v43 == -602, (signed int)(v43 + 602) < 0, __OFSUB__(v43, -602), v37, v41);
  }
  __asm { popfw }
  return v44;
}
// 8054507: could not find valid save-restore pair for ebp
// 804A39C: using guessed type int __fastcall sub_804A39C(_DWORD, _DWORD);
// 804AA62: using guessed type int __fastcall sub_804AA62(_DWORD, _DWORD);
// 805C13C: using guessed type int dword_805C13C;
// 805C184: using guessed type int dword_805C184;
// 805C190: using guessed type int dword_805C190;
// 805C19C: using guessed type int dword_805C19C;

//----- (0805465D) --------------------------------------------------------
void *__usercall sub_805465D@<eax>(signed __int32 a1@<ebx>, void *ptr, size_t size)
{
  void *result; // eax
  signed __int32 v4; // edx
  char v9; // al
  signed __int32 v10; // ebx
  char v11; // t0
  signed __int32 v12; // [esp-Ah] [ebp-22h]
  void *ptra; // [esp+20h] [ebp+8h]

  if ( size || !ptr )
  {
    ptra = realloc(ptr, size);
    _CF = 0;
    _OF = 0;
    _ZF = ptra == 0;
    _SF = (signed int)ptra < 0;
    if ( !ptra )
    {
      __asm { pushfw }
      v12 = a1;
      if ( a1 >= 10 )
      {
        v9 = a1;
        v10 = _InterlockedExchange(&dword_805C190, a1);
        v11 = _InterlockedExchange(&dword_805C190, v4);
        _InterlockedExchange(&dword_805C190, v10);
        if ( (v11 - 1) * v9 & 1 )
          abort();
      }
      __asm { popfw }
      if ( size )
        sub_805492A(v12);
    }
    result = ptra;
  }
  else
  {
    free(ptr);
    result = 0;
  }
  return result;
}
// 805C190: using guessed type int dword_805C190;

//----- (080547DB) --------------------------------------------------------
void *__usercall sub_80547DB@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, int a9@<ebp>, const void *src, unsigned __int32 n)
{
  char v11; // al
  signed __int32 v12; // et0
  signed __int32 v13; // edx
  char v14; // al
  signed __int32 v15; // et1
  signed __int32 v16; // ecx
  char v17; // al
  signed __int32 v18; // et2
  void *dest; // [esp+18h] [ebp-20h]
  void *v21; // [esp+18h] [ebp-20h]
  int v22; // [esp+34h] [ebp-4h]

  v22 = a5;
  __asm { pushfw }
  if ( a8 >= 10 )
  {
    v12 = _InterlockedExchange(&dword_805C124, a8);
    v11 = _InterlockedExchange(&dword_805C124, a7);
    _InterlockedExchange(&dword_805C124, v12);
    if ( ((_BYTE)a8 - 1) * v11 & 1 )
      abort();
  }
  __asm { popfw }
  v22 = a9;
  dest = sub_8054507((unsigned int)&v22 < 0x18, &v22 == 0, (signed int)&v22 < 0, __OFSUB__(&v22, 24), n, a6, a8, n);
  __asm { pushfw }
  if ( a8 >= 10 )
  {
    v15 = _InterlockedExchange(&dword_805C16C, a8);
    v14 = _InterlockedExchange(&dword_805C16C, v13);
    _InterlockedExchange(&dword_805C16C, v15);
    if ( ((_BYTE)a8 - 1) * v14 & 1 )
      abort();
  }
  __asm { popfw }
  v21 = memcpy(dest, src, n);
  __asm { pushfw }
  if ( a8 >= 10 )
  {
    v18 = _InterlockedExchange(&dword_805C154, a8);
    v17 = _InterlockedExchange(&dword_805C154, v16);
    _InterlockedExchange(&dword_805C154, v18);
    if ( ((_BYTE)a8 - 1) * v17 & 1 )
      abort();
  }
  __asm { popfw }
  return v21;
}
// 80547DB: could not find valid save-restore pair for ebx
// 80547DB: could not find valid save-restore pair for ebp
// 805C124: using guessed type int dword_805C124;
// 805C154: using guessed type int dword_805C154;
// 805C16C: using guessed type int dword_805C16C;

//----- (0805492A) --------------------------------------------------------
void __usercall __noreturn sub_805492A(signed __int32 a1@<ebx>)
{
  char *v1; // eax
  signed __int32 v6; // ebx
  signed __int32 v7; // edx
  signed __int32 v8; // eax
  signed __int32 v9; // edx
  int v10; // ecx
  signed __int32 v11; // eax

  v1 = gettext("memory exhausted");
  error(status, 0, "%s", v1);
  __asm { pushfw }
  v6 = _InterlockedExchange(&dword_805C130, a1);
  _InterlockedExchange(&dword_805C130, v7);
  _InterlockedExchange(&dword_805C130, v6);
  v8 = sub_804BB55();
  if ( v8 != 654 )
  {
    v11 = _InterlockedExchange(&dword_805C130, v8);
    _InterlockedExchange(&dword_805C130, v9);
    _InterlockedExchange(&dword_805C130, v11);
    sub_804BB5F(v10);
  }
  __asm { popfw }
  abort();
}
// 804BB5F: using guessed type int __fastcall sub_804BB5F(_DWORD);
// 805C130: using guessed type int dword_805C130;

//----- (080549A1) --------------------------------------------------------
int __usercall sub_80549A1@<eax>(signed __int32 a1@<ebx>, FILE *stream)
{
  signed __int32 v2; // ebx
  signed __int32 v3; // edx
  signed __int32 v4; // edx
  signed __int32 v5; // ebx
  signed __int32 v6; // et0
  unsigned __int32 v7; // eax
  signed __int32 v8; // edx
  signed __int32 v9; // ecx
  signed __int32 v14; // eax
  signed __int32 v15; // et1
  int v20; // eax
  signed __int32 v21; // edx
  signed __int32 v22; // ecx
  char v23; // al
  signed __int32 v24; // ebx
  char v25; // t2
  int v26; // eax
  int v27; // ecx
  int v32; // eax
  int v33; // eax
  int v34; // edx
  int v35; // eax
  signed __int32 v36; // ebx
  signed __int32 v37; // ecx
  signed __int32 v38; // ebx
  signed __int32 v39; // ett
  signed __int32 v40; // edx
  signed __int32 v41; // ecx
  char v42; // al
  signed __int32 v43; // ebx
  char v44; // t0
  signed __int32 v45; // ebx
  signed __int32 v46; // et1
  int v47; // eax
  signed __int32 v48; // eax
  signed __int32 v49; // edx
  int v50; // ecx
  signed __int32 v51; // ebx
  char v52; // al
  signed __int32 v53; // et0
  signed __int32 v55; // [esp-10h] [ebp-38h]
  signed __int32 v56; // [esp-Ah] [ebp-32h]
  unsigned __int32 v57; // [esp-Ah] [ebp-32h]
  int v58; // [esp-4h] [ebp-2Ch]
  int *v59; // [esp-4h] [ebp-2Ch]
  int v60; // [esp-4h] [ebp-2Ch]
  int v61; // [esp-4h] [ebp-2Ch]
  int v62; // [esp+14h] [ebp-14h]
  signed int v63; // [esp+18h] [ebp-10h]

  v62 = 0;
  v58 = fileno(stream);
  __asm { pushfw }
  v2 = _InterlockedExchange(&dword_805C178, a1);
  v6 = _InterlockedExchange(&dword_805C178, v3);
  v4 = v2;
  v5 = v6;
  _InterlockedExchange(&dword_805C178, v4);
  v7 = sub_8050431();
  _CF = v7 < 0x6E;
  _OF = __OFSUB__(v7, 110);
  _ZF = v7 == 110;
  _SF = (signed int)(v7 - 110) < 0;
  if ( v7 != 110 )
  {
    v15 = _InterlockedExchange(&dword_805C178, v7);
    v14 = _InterlockedExchange(&dword_805C178, v8);
    _InterlockedExchange(&dword_805C178, v15);
    sub_805043B(_CF, _ZF, _SF, _OF, v14, v9, v5);
  }
  __asm { popfw }
  if ( v58 >= 0 )
  {
    v26 = __freading(stream);
    _CF = 0;
    _OF = 0;
    _ZF = v26 == 0;
    _SF = v26 < 0;
    if ( !v26 )
      goto LABEL_28;
    v32 = fileno(stream);
    v33 = lseek64(v32, 0, 0, 1);
    v27 = ~v34;
    v35 = ~v34 | ~v33;
    _CF = 0;
    _OF = 0;
    _ZF = v35 == 0;
    _SF = v35 < 0;
    if ( v35 )
    {
LABEL_28:
      __asm { pushfw }
      v36 = _InterlockedExchange(&dword_805C184, v5);
      v39 = _InterlockedExchange(&dword_805C184, v27);
      v37 = v36;
      v38 = v39;
      _InterlockedExchange(&dword_805C184, v37);
      v57 = sub_804AE45();
      __asm { pushfw }
      v55 = v39;
      if ( v39 >= 10 )
      {
        v42 = v38;
        v43 = _InterlockedExchange(&dword_805C16C, v38);
        v44 = _InterlockedExchange(&dword_805C16C, v41);
        v41 = _InterlockedExchange(&dword_805C16C, v43);
        if ( (v44 - 1) * v42 & 1 )
          abort();
      }
      v5 = v55;
      __asm { popfw }
      if ( v57 != -91 )
      {
        v45 = _InterlockedExchange(&dword_805C184, v55);
        v46 = _InterlockedExchange(&dword_805C184, v40);
        _InterlockedExchange(&dword_805C184, v45);
        sub_804AE4F(v57 < 0xFFFFFFA5, v57 == -91, (signed int)(v57 + 91) < 0, __OFSUB__(v57, -91), v57, v41, v46);
      }
      __asm { popfw }
      if ( sub_8054FE9(_CF, _ZF, _SF, _OF, v40, v41, v55, stream) )
        v62 = *__errno_location();
    }
    v47 = fclose(stream);
    v60 = v47;
    __asm { pushfw }
    v48 = _InterlockedExchange(&dword_805C148, v47);
    _InterlockedExchange(&dword_805C148, v49);
    _InterlockedExchange(&dword_805C148, v48);
    if ( sub_804FCF9() != 863 )
    {
      v51 = _InterlockedExchange(&dword_805C148, v5);
      _InterlockedExchange(&dword_805C148, v21);
      _InterlockedExchange(&dword_805C148, v51);
      sub_804FD03(v50);
    }
    __asm { popfw }
    v63 = v60;
    _CF = 0;
    _OF = 0;
    _ZF = v62 == 0;
    _SF = v62 < 0;
    if ( v62 )
    {
      v59 = __errno_location();
      __asm { pushfw }
      v56 = v5;
      if ( v5 >= 10 )
      {
        v23 = v5;
        v24 = _InterlockedExchange(&dword_805C154, v5);
        v25 = _InterlockedExchange(&dword_805C154, v22);
        _InterlockedExchange(&dword_805C154, v24);
        if ( (v25 - 1) * v23 & 1 )
          abort();
      }
      v5 = v56;
      __asm { popfw }
      v21 = v62;
      *v59 = v62;
      v63 = -1;
    }
    v20 = v63;
  }
  else
  {
    v20 = fclose(stream);
  }
  v61 = v20;
  __asm { pushfw }
  if ( v5 >= 10 )
  {
    v53 = _InterlockedExchange(&dword_805C1A8, v5);
    v52 = _InterlockedExchange(&dword_805C1A8, v21);
    _InterlockedExchange(&dword_805C1A8, v53);
    if ( ((_BYTE)v5 - 1) * v52 & 1 )
      abort();
  }
  __asm { popfw }
  return v61;
}
// 8049030: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 804FD03: using guessed type int __fastcall sub_804FD03(_DWORD);
// 805C148: using guessed type int dword_805C148;
// 805C154: using guessed type int dword_805C154;
// 805C16C: using guessed type int dword_805C16C;
// 805C178: using guessed type int dword_805C178;
// 805C184: using guessed type int dword_805C184;
// 805C1A8: using guessed type int dword_805C1A8;

//----- (08054BCE) --------------------------------------------------------
int __usercall sub_8054BCE@<eax>(signed __int32 a1@<ebx>, int fd, int cmd, char a4, int a5)
{
  signed __int32 v9; // ecx
  char v10; // al
  signed __int32 v11; // ebx
  char v12; // t0
  signed __int32 v13; // ebx
  signed __int32 v14; // edx
  signed __int32 v15; // edx
  signed __int32 v16; // ebx
  signed __int32 v17; // et1
  signed __int32 v18; // ecx
  unsigned __int32 v19; // eax
  signed __int32 v20; // ecx
  bool v21; // cf
  bool v22; // zf
  bool v23; // sf
  char v24; // of
  signed __int32 v25; // eax
  int v26; // ST34_4
  int *v27; // edx
  char v28; // al
  signed __int32 v29; // ett
  int v30; // eax
  signed __int32 v31; // et0
  int v33; // [esp-4h] [ebp-3Ch]
  int v34; // [esp-4h] [ebp-3Ch]
  signed int v35; // [esp+1Ch] [ebp-1Ch]
  char v36; // [esp+20h] [ebp-18h]
  int v37; // [esp+24h] [ebp-14h]

  _CF = (unsigned int)cmd < 0x406;
  _OF = __OFSUB__(cmd, 1030);
  _ZF = cmd == 1030;
  _SF = cmd - 1030 < 0;
  if ( cmd == 1030 )
  {
    v36 = a4;
    if ( dword_805C890 < 0 )
    {
      v34 = sub_8054BCE(fd, 0, a4);
      __asm { pushfw }
      v13 = _InterlockedExchange(&dword_805C1A8, a1);
      v17 = _InterlockedExchange(&dword_805C1A8, v14);
      v15 = v13;
      v16 = v17;
      v19 = sub_804B557(_CF, _ZF, _SF, _OF, _InterlockedExchange(&dword_805C1A8, v15), v18, v17);
      v21 = v19 < 0xFFFFFF67;
      v24 = __OFSUB__(v19, -153);
      v22 = v19 == -153;
      v23 = (signed int)(v19 + 153) < 0;
      if ( v19 != -153 )
      {
        v25 = _InterlockedExchange(&dword_805C1A8, v19);
        _InterlockedExchange(&dword_805C1A8, v20);
        sub_804B60C(v21, v22, v23, v24, _InterlockedExchange(&dword_805C1A8, v25), v16);
      }
      __asm { popfw }
      v35 = v34;
      goto LABEL_14;
    }
    v35 = fcntl(fd, 1030, a4);
    if ( v35 >= 0 || *__errno_location() != 22 )
    {
      dword_805C890 = 1;
LABEL_14:
      if ( v35 >= 0 && dword_805C890 == -1 )
      {
        v37 = fcntl(v35, 1);
        if ( v37 < 0 || fcntl(v35, 2, v37 | 1) == -1 )
        {
          v26 = *__errno_location();
          close(v35);
          *__errno_location() = v26;
          v35 = -1;
        }
      }
      return v35;
    }
    v33 = sub_8054BCE(fd, 0, v36);
    __asm { pushfw }
    if ( a1 >= 10 )
    {
      v10 = a1;
      v11 = _InterlockedExchange(&dword_805C154, a1);
      v12 = _InterlockedExchange(&dword_805C154, v9);
      _InterlockedExchange(&dword_805C154, v11);
      if ( (v12 - 1) * v10 & 1 )
        abort();
    }
    __asm { popfw }
    v35 = v33;
    if ( v33 >= 0 )
    {
      dword_805C890 = -1;
      goto LABEL_14;
    }
  }
  else
  {
    v27 = &a5;
    __asm { pushfw }
    if ( a1 >= 10 )
    {
      v29 = _InterlockedExchange(&dword_805C124, a1);
      v28 = _InterlockedExchange(&dword_805C124, (signed __int32)&a5);
      v27 = (int *)_InterlockedExchange(&dword_805C124, v29);
      if ( ((_BYTE)a1 - 1) * v28 & 1 )
        abort();
    }
    __asm { popfw }
    v31 = _InterlockedExchange(&dword_805C160, cmd);
    v30 = _InterlockedExchange(&dword_805C160, (signed __int32)v27);
    _InterlockedExchange(&dword_805C160, v31);
    v35 = fcntl(fd, v30, a4);
  }
  return v35;
}
// 805C124: using guessed type int dword_805C124;
// 805C154: using guessed type int dword_805C154;
// 805C160: using guessed type int dword_805C160;
// 805C1A8: using guessed type int dword_805C1A8;
// 805C890: using guessed type int dword_805C890;

//----- (08054EBA) --------------------------------------------------------
int __usercall sub_8054EBA@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, FILE *stream)
{
  int v4; // eax
  signed __int32 v9; // ebx
  signed __int32 v10; // ecx
  signed __int32 v11; // ebx
  signed __int32 v12; // et0
  unsigned __int32 v13; // eax
  signed __int32 v14; // edx
  signed __int32 v15; // ecx
  char v20; // al
  signed __int32 v21; // ebx
  signed __int32 v22; // et2
  signed __int32 v23; // ebx
  int v24; // eax
  signed __int32 v29; // ebx
  signed __int32 v30; // ecx
  signed __int32 v31; // ebx
  signed __int32 v32; // ett
  unsigned int v33; // eax
  signed __int32 v34; // edx
  signed __int32 v35; // ecx
  signed __int32 v40; // ebx
  signed __int32 v41; // eax
  signed __int32 v42; // eax
  int v43; // edx
  signed __int32 v44; // ecx
  signed __int32 v45; // eax
  int v47; // [esp-4h] [ebp-1Ch]

  v4 = stream->_flags & 0x100;
  _CF = 0;
  _OF = 0;
  _ZF = v4 == 0;
  _SF = v4 < 0;
  if ( v4 )
    v4 = sub_80551A3(a1, a3, stream, 0, 0, 1);
  v47 = v4;
  __asm { pushfw }
  v9 = _InterlockedExchange(&dword_805C184, a3);
  v12 = _InterlockedExchange(&dword_805C184, a2);
  v10 = v9;
  v11 = v12;
  _InterlockedExchange(&dword_805C184, v10);
  v13 = sub_804AE45();
  _CF = v13 < 0xFFFFFFA5;
  _OF = __OFSUB__(v13, -91);
  _ZF = v13 == -91;
  _SF = (signed int)(v13 + 91) < 0;
  if ( v13 != -91 )
    sub_804AE4F(
      v13 < 0xFFFFFFA5,
      v13 == -91,
      (signed int)(v13 + 91) < 0,
      __OFSUB__(v13, -91),
      v13,
      _InterlockedExchange(&dword_805C184, _InterlockedExchange(&dword_805C184, v11)),
      _InterlockedExchange(&dword_805C184, v15));
  __asm { pushfw }
  if ( v11 >= 10 )
  {
    v20 = v11;
    v21 = _InterlockedExchange(&dword_805C154, v11);
    v22 = _InterlockedExchange(&dword_805C154, v14);
    _InterlockedExchange(&dword_805C154, v21);
    v23 = v22 - 1;
    v24 = ((_BYTE)v22 - 1) * v20 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = v24 == 0;
    _SF = v24 < 0;
    if ( v24 )
    {
      __asm { pushfw }
      v29 = _InterlockedExchange(&dword_805C118, v23);
      v32 = _InterlockedExchange(&dword_805C118, v15);
      v30 = v29;
      v31 = v32;
      _InterlockedExchange(&dword_805C118, v30);
      v33 = sub_804A7B7();
      _CF = v33 < 0x13D;
      _OF = __OFSUB__(v33, 317);
      _ZF = v33 == 317;
      _SF = (signed int)(v33 - 317) < 0;
      if ( v33 != 317 )
      {
        v40 = _InterlockedExchange(&dword_805C118, v31);
        _InterlockedExchange(&dword_805C118, v35);
        sub_804A7C1(_InterlockedExchange(&dword_805C118, v40), v34);
      }
      __asm { pushfw }
      v41 = _InterlockedExchange(&dword_805C10C, 317);
      _InterlockedExchange(&dword_805C10C, v34);
      _InterlockedExchange(&dword_805C10C, v41);
      v42 = sub_804AFDB();
      if ( v42 != 929 )
      {
        v45 = _InterlockedExchange(&dword_805C10C, v42);
        _InterlockedExchange(&dword_805C10C, v44);
        sub_804AFE5(_InterlockedExchange(&dword_805C10C, v45), v43);
      }
      __asm
      {
        popfw
        popfw
      }
      abort();
    }
  }
  __asm
  {
    popfw
    popfw
  }
  return v47;
}
// 804A7C1: using guessed type int __fastcall sub_804A7C1(_DWORD, _DWORD);
// 804AFE5: using guessed type int __fastcall sub_804AFE5(_DWORD, _DWORD);
// 805C10C: using guessed type int dword_805C10C;
// 805C118: using guessed type int dword_805C118;
// 805C154: using guessed type int dword_805C154;
// 805C184: using guessed type int dword_805C184;

//----- (08054FE9) --------------------------------------------------------
int __usercall sub_8054FE9@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, FILE *fp)
{
  signed __int32 v8; // ebx
  signed __int32 v9; // ecx
  signed __int32 v10; // ebx
  signed __int32 v11; // et0
  unsigned __int32 v12; // eax
  signed __int32 v13; // edx
  signed __int32 v14; // ecx
  bool v15; // cf
  bool v16; // zf
  bool v17; // sf
  char v18; // of
  signed __int32 v19; // eax
  int v20; // eax
  signed __int32 v21; // edx
  int v26; // eax
  signed __int32 v27; // eax
  signed __int32 v28; // edx
  signed __int32 v29; // eax
  signed __int32 v30; // eax
  signed __int32 v31; // ecx
  signed __int32 v32; // eax
  signed __int32 v33; // eax
  signed __int32 v34; // ecx
  unsigned __int32 v35; // eax
  signed __int32 v36; // edx
  signed __int32 v37; // ecx
  signed __int32 v38; // ebx
  signed __int32 v39; // et1
  signed __int32 v40; // ebx
  signed __int32 v41; // ett
  int result; // eax
  signed __int32 v43; // ebx
  signed __int32 v44; // edx
  signed __int32 v45; // ebx
  signed __int32 v46; // et0
  signed __int32 v47; // eax
  signed __int32 v48; // edx
  signed __int32 v49; // ecx
  signed __int32 v50; // eax
  int v51; // ST10_4
  signed __int32 v52; // ebx
  signed __int32 v53; // edx
  signed __int32 v54; // edx
  signed __int32 v55; // ebx
  signed __int32 v56; // et2
  int v57; // edx
  signed __int32 v58; // ecx
  signed __int32 v59; // ebx
  unsigned int v60; // [esp-10h] [ebp-2Ch]
  unsigned __int32 v61; // [esp-Ah] [ebp-26h]
  int v62; // [esp-4h] [ebp-20h]

  __asm { pushfw }
  v8 = _InterlockedExchange(&dword_805C1A8, a7);
  v11 = _InterlockedExchange(&dword_805C1A8, a6);
  v9 = v8;
  v10 = v11;
  v12 = sub_804B557(_CF, _ZF, _SF, _OF, a5, _InterlockedExchange(&dword_805C1A8, v9), v11);
  v15 = v12 < 0xFFFFFF67;
  v18 = __OFSUB__(v12, -153);
  v16 = v12 == -153;
  v17 = (signed int)(v12 + 153) < 0;
  if ( v12 != -153 )
  {
    v19 = _InterlockedExchange(&dword_805C1A8, v12);
    _InterlockedExchange(&dword_805C1A8, v13);
    _InterlockedExchange(&dword_805C1A8, v19);
    sub_804B60C(v15, v16, v17, v18, v14, v10);
  }
  __asm { popfw }
  if ( fp && (v20 = __freading(fp), _CF = 0, _OF = 0, _ZF = v20 == 0, _SF = v20 < 0, v20) )
  {
    __asm { pushfw }
    v43 = _InterlockedExchange(&dword_805C10C, v10);
    v46 = _InterlockedExchange(&dword_805C10C, v21);
    v44 = v43;
    v45 = v46;
    _InterlockedExchange(&dword_805C10C, v44);
    v47 = sub_804AFDB();
    if ( v47 != 929 )
    {
      v50 = _InterlockedExchange(&dword_805C10C, v47);
      _InterlockedExchange(&dword_805C10C, v49);
      sub_804AFE5(_InterlockedExchange(&dword_805C10C, v50), v48);
    }
    __asm { popfw }
    v51 = sub_8054EBA(v48, v49, v45, fp);
    __asm { pushfw }
    v52 = _InterlockedExchange(&dword_805C190, v45);
    v56 = _InterlockedExchange(&dword_805C190, v53);
    v54 = v52;
    v55 = v56;
    if ( sub_804A927(_CF, _ZF, _SF, _OF, v51, _InterlockedExchange(&dword_805C190, v54), v56) != 625 )
    {
      v59 = _InterlockedExchange(&dword_805C190, v55);
      _InterlockedExchange(&dword_805C190, v58);
      sub_804AA62(_InterlockedExchange(&dword_805C190, v59), v57);
    }
    __asm { popfw }
    result = fflush(fp);
  }
  else
  {
    v26 = fflush(fp);
    v62 = v26;
    __asm { pushfw }
    v27 = _InterlockedExchange(&dword_805C184, v26);
    _InterlockedExchange(&dword_805C184, v28);
    _InterlockedExchange(&dword_805C184, v27);
    v29 = sub_804AE45();
    v61 = v29;
    __asm { pushfw }
    v30 = _InterlockedExchange(&dword_805C16C, v29);
    _InterlockedExchange(&dword_805C16C, v31);
    _InterlockedExchange(&dword_805C16C, v30);
    v32 = sub_805344B();
    v60 = v32;
    __asm { pushfw }
    v33 = _InterlockedExchange(&dword_805C154, v32);
    _InterlockedExchange(&dword_805C154, v34);
    _InterlockedExchange(&dword_805C154, v33);
    v35 = sub_804A04B();
    if ( v35 != -752 )
    {
      v38 = _InterlockedExchange(&dword_805C154, v10);
      v39 = _InterlockedExchange(&dword_805C154, v36);
      _InterlockedExchange(&dword_805C154, v38);
      sub_804A055(v35 < 0xFFFFFD10, v35 == -752, (signed int)(v35 + 752) < 0, __OFSUB__(v35, -752), v35, v37, v39);
    }
    __asm { popfw }
    if ( v60 != 260 )
      sub_8053455(
        v60 < 0x104,
        v60 == 260,
        (signed int)(v60 - 260) < 0,
        __OFSUB__(v60, 260),
        _InterlockedExchange(&dword_805C16C, _InterlockedExchange(&dword_805C16C, v10)),
        v37,
        _InterlockedExchange(&dword_805C16C, v36));
    __asm { popfw }
    if ( v61 != -91 )
    {
      v40 = _InterlockedExchange(&dword_805C184, v10);
      v41 = _InterlockedExchange(&dword_805C184, v36);
      _InterlockedExchange(&dword_805C184, v40);
      sub_804AE4F(v61 < 0xFFFFFFA5, v61 == -91, (signed int)(v61 + 91) < 0, __OFSUB__(v61, -91), v61, v37, v41);
    }
    __asm { popfw }
    result = v62;
  }
  return result;
}
// 8054FE9: could not find valid save-restore pair for ebp
// 804AA62: using guessed type int __fastcall sub_804AA62(_DWORD, _DWORD);
// 804AFE5: using guessed type int __fastcall sub_804AFE5(_DWORD, _DWORD);
// 805C10C: using guessed type int dword_805C10C;
// 805C154: using guessed type int dword_805C154;
// 805C16C: using guessed type int dword_805C16C;
// 805C184: using guessed type int dword_805C184;
// 805C190: using guessed type int dword_805C190;
// 805C1A8: using guessed type int dword_805C1A8;

//----- (080551A3) --------------------------------------------------------
int __usercall sub_80551A3@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>, FILE *stream, int a4, int a5, int a6)
{
  signed __int32 v6; // ebx
  signed __int32 v7; // edx
  signed __int32 v8; // ebx
  signed __int32 v9; // et0
  signed __int32 v10; // ebx
  signed __int32 v11; // edx
  signed __int32 v12; // edx
  signed __int32 v13; // ebx
  signed __int32 v14; // et1
  signed __int32 v15; // ecx
  unsigned int v16; // eax
  signed __int32 v17; // edx
  signed __int32 v18; // ecx
  char v23; // al
  signed __int32 v24; // ett
  signed __int32 v25; // ebx
  __int64 v26; // rax
  signed __int32 v27; // et1
  int v29; // [esp-4h] [ebp-3Ch]

  v6 = _InterlockedExchange(&dword_805C160, a2);
  v9 = _InterlockedExchange(&dword_805C160, a1);
  v7 = v6;
  v8 = v9;
  _InterlockedExchange(&dword_805C160, v7);
  if ( stream->_IO_read_end != stream->_IO_read_ptr
    || stream->_IO_write_ptr != stream->_IO_write_base
    || stream->_IO_save_base )
  {
    return fseeko64(stream, a4, a5, a6);
  }
  v29 = fileno(stream);
  __asm { pushfw }
  v10 = _InterlockedExchange(&dword_805C1A8, v8);
  v14 = _InterlockedExchange(&dword_805C1A8, v11);
  v12 = v10;
  v13 = v14;
  v16 = sub_804B557(_CF, _ZF, _SF, _OF, _InterlockedExchange(&dword_805C1A8, v12), v15, v14);
  _CF = v16 < 0xFFFFFF67;
  _OF = __OFSUB__(v16, -153);
  _ZF = v16 == -153;
  _SF = (signed int)(v16 + 153) < 0;
  if ( v16 != -153 )
    sub_804B60C(
      v16 < 0xFFFFFF67,
      v16 == -153,
      (signed int)(v16 + 153) < 0,
      __OFSUB__(v16, -153),
      _InterlockedExchange(&dword_805C1A8, _InterlockedExchange(&dword_805C1A8, v13)),
      _InterlockedExchange(&dword_805C1A8, v18));
  __asm { pushfw }
  if ( v13 >= 10 )
  {
    v24 = _InterlockedExchange(&dword_805C19C, v13);
    v23 = _InterlockedExchange(&dword_805C19C, v18);
    _InterlockedExchange(&dword_805C19C, v24);
    if ( ((_BYTE)v13 - 1) * v23 & 1 )
      abort();
  }
  v25 = _InterlockedExchange(&dword_805C160, v13);
  _InterlockedExchange(&dword_805C160, v17);
  _InterlockedExchange(&dword_805C160, v25);
  __asm
  {
    popfw
    popfw
  }
  LODWORD(v26) = lseek64(v29, a4, a5, a6);
  if ( v26 == -1 )
    return -1;
  stream->_flags &= 0xFFFFFFEF;
  v27 = _InterlockedExchange(&dword_805C160, v26);
  LODWORD(v26) = _InterlockedExchange(&dword_805C160, (signed __int32)stream);
  *(_QWORD *)(_InterlockedExchange(&dword_805C160, v27) + 76) = v26;
  return 0;
}
// 8048DC0: using guessed type int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8049030: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 805C160: using guessed type int dword_805C160;
// 805C19C: using guessed type int dword_805C19C;
// 805C1A8: using guessed type int dword_805C1A8;

//----- (080554BD) --------------------------------------------------------
int __usercall sub_80554BD@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  char v10; // al
  signed __int32 v11; // et0
  unsigned __int32 v12; // eax
  signed __int32 v13; // edx
  signed __int32 v14; // ecx
  signed __int32 v19; // ebx
  signed __int32 v20; // edx
  signed __int32 v21; // edx
  signed __int32 v22; // et1
  unsigned int v23; // eax
  signed __int32 v24; // ebx
  signed __int32 v25; // et2
  signed __int32 v26; // eax
  signed __int32 v27; // ebx
  signed __int32 v28; // ecx
  signed __int32 v29; // ebx
  signed __int32 v30; // ett
  signed __int32 v31; // edx
  int v32; // ecx
  signed __int32 v33; // ebx
  char v35; // [esp-4h] [ebp-2Ch]
  signed __int32 v36; // [esp-4h] [ebp-2Ch]
  char v37; // [esp+18h] [ebp-10h]
  int v38; // [esp+1Ch] [ebp-Ch]

  _CF = 0;
  _OF = 0;
  _ZF = pwc == 0;
  _SF = (signed int)pwc < 0;
  if ( !pwc )
    pwc = (wchar_t *)&v37;
  __asm { pushfw }
  if ( a2 >= 10 )
  {
    v11 = _InterlockedExchange(&dword_805C130, a2);
    v10 = _InterlockedExchange(&dword_805C130, a1);
    _InterlockedExchange(&dword_805C130, v11);
    if ( ((_BYTE)a2 - 1) * v10 & 1 )
      abort();
  }
  __asm { popfw }
  v12 = mbrtowc(pwc, s, n, p);
  v38 = v12;
  _CF = v12 < 0xFFFFFFFD;
  _OF = __OFSUB__(v12, -3);
  _ZF = v12 == -3;
  _SF = (signed int)(v12 + 3) < 0;
  if ( v12 <= 0xFFFFFFFD )
    goto LABEL_18;
  _CF = 0;
  _OF = 0;
  _ZF = n == 0;
  _SF = (n & 0x80000000) != 0;
  if ( !n )
    goto LABEL_18;
  v35 = sub_8055864(0, n == 0, (n & 0x80000000) != 0, 0, v12, v13, a2, 0);
  __asm { pushfw }
  v19 = _InterlockedExchange(&dword_805C19C, a2);
  v22 = _InterlockedExchange(&dword_805C19C, v20);
  v21 = v19;
  a2 = v22;
  _InterlockedExchange(&dword_805C19C, v21);
  v23 = sub_80519A9();
  if ( v23 != -602 )
  {
    v24 = _InterlockedExchange(&dword_805C19C, a2);
    v25 = _InterlockedExchange(&dword_805C19C, v14);
    _InterlockedExchange(&dword_805C19C, v24);
    sub_80519B3(v23 < 0xFFFFFDA6, v23 == -602, (signed int)(v23 + 602) < 0, __OFSUB__(v23, -602), v13, v25);
  }
  __asm { popfw }
  _CF = 0;
  _OF = 0;
  _ZF = v35 == 1;
  _SF = ((v35 ^ 1) & 0x80u) != 0;
  if ( v35 != 1 )
  {
    v13 = (unsigned __int8)*s;
    *pwc = v13;
    v26 = 1;
  }
  else
  {
LABEL_18:
    v26 = v38;
  }
  v36 = v26;
  __asm { pushfw }
  v27 = _InterlockedExchange(&dword_805C190, a2);
  v30 = _InterlockedExchange(&dword_805C190, v14);
  v28 = v27;
  v29 = v30;
  _InterlockedExchange(&dword_805C190, v28);
  if ( sub_804A927(_CF, _ZF, _SF, _OF, v26, v13, v30) != 625 )
  {
    v33 = _InterlockedExchange(&dword_805C190, v29);
    _InterlockedExchange(&dword_805C190, v31);
    sub_804AA62(v32, _InterlockedExchange(&dword_805C190, v33));
  }
  __asm { popfw }
  return v36;
}
// 804AA62: using guessed type int __fastcall sub_804AA62(_DWORD, _DWORD);
// 805C130: using guessed type int dword_805C130;
// 805C190: using guessed type int dword_805C190;
// 805C19C: using guessed type int dword_805C19C;

//----- (080555E1) --------------------------------------------------------
int __usercall sub_80555E1@<eax>(signed __int32 a1@<edx>, unsigned __int8 *a2, unsigned __int8 *a3)
{
  unsigned __int8 *v3; // esi
  unsigned __int8 *v4; // ebx
  int v9; // eax
  signed __int32 v10; // edx
  int v11; // eax
  signed __int32 v12; // ecx
  signed __int32 v17; // eax
  signed __int32 v18; // eax
  signed __int32 v19; // edx
  signed __int32 v20; // ecx
  signed __int32 v21; // eax
  signed __int32 v22; // ebx
  signed __int32 v23; // edx
  signed __int32 v24; // et2
  unsigned int v25; // eax
  signed __int32 v26; // ecx
  char v31; // al
  signed __int32 v32; // ett
  char v33; // al
  signed __int32 v34; // ebx
  char v35; // t1
  int v37; // [esp-4h] [ebp-2Ch]
  unsigned __int8 v38; // [esp+1Eh] [ebp-Ah]
  unsigned __int8 v39; // [esp+1Fh] [ebp-9h]

  v3 = a2;
  v4 = a3;
  _CF = a2 < a3;
  _OF = __OFSUB__(a2, a3);
  _ZF = a2 == a3;
  _SF = a2 - a3 < 0;
  if ( a2 == a3 )
  {
    v9 = 0;
  }
  else
  {
    while ( 1 )
    {
      v38 = sub_80562BD(a1, (signed __int32)v4, *v3);
      v11 = sub_80562BD(v10, (signed __int32)v4, *v4);
      v39 = v11;
      _CF = 0;
      _OF = 0;
      _ZF = v38 == 0;
      _SF = (v38 & 0x80u) != 0;
      if ( !v38 )
        break;
      ++v3;
      ++v4;
      if ( v38 != (_BYTE)v11 )
        goto LABEL_13;
    }
    __asm { pushfw }
    v17 = _InterlockedExchange(&dword_805C10C, v11);
    _InterlockedExchange(&dword_805C10C, v12);
    _InterlockedExchange(&dword_805C10C, v17);
    v18 = sub_804AFDB();
    if ( v18 != 929 )
    {
      v21 = _InterlockedExchange(&dword_805C10C, v18);
      _InterlockedExchange(&dword_805C10C, v20);
      sub_804AFE5(_InterlockedExchange(&dword_805C10C, v21), v19);
    }
    __asm
    {
      popfw
      pushfw
    }
    v22 = _InterlockedExchange(&dword_805C1A8, (signed __int32)v4);
    v24 = _InterlockedExchange(&dword_805C1A8, v19);
    v23 = v22;
    v4 = (unsigned __int8 *)v24;
    v25 = sub_804B557(_CF, _ZF, _SF, _OF, _InterlockedExchange(&dword_805C1A8, v23), v20, v24);
    _CF = v25 < 0xFFFFFF67;
    _OF = __OFSUB__(v25, -153);
    _ZF = v25 == -153;
    _SF = (signed int)(v25 + 153) < 0;
    if ( v25 != -153 )
    {
      __asm { pushfw }
      if ( (signed int)v4 >= 10 )
      {
        v32 = _InterlockedExchange(&dword_805C118, (signed __int32)v4);
        v31 = _InterlockedExchange(&dword_805C118, v26);
        v26 = _InterlockedExchange(&dword_805C118, v32);
        if ( ((_BYTE)v4 - 1) * v31 & 1 )
          abort();
      }
      __asm { popfw }
      sub_804B60C(
        _CF,
        _ZF,
        _SF,
        _OF,
        _InterlockedExchange(&dword_805C1A8, _InterlockedExchange(&dword_805C1A8, (signed __int32)v4)),
        _InterlockedExchange(&dword_805C1A8, v26));
    }
    __asm { popfw }
LABEL_13:
    _CF = v38 < (unsigned int)v39;
    _OF = __OFSUB__(v38, v39);
    a1 = v38 - v39;
    _ZF = v38 == v39;
    _SF = a1 < 0;
    v9 = v38 - v39;
  }
  v37 = v9;
  __asm { pushfw }
  if ( (signed int)v4 >= 10 )
  {
    v33 = (char)v4;
    v34 = _InterlockedExchange(&dword_805C148, (signed __int32)v4);
    v35 = _InterlockedExchange(&dword_805C148, a1);
    _InterlockedExchange(&dword_805C148, v34);
    if ( (v35 - 1) * v33 & 1 )
      abort();
  }
  __asm { popfw }
  return v37;
}
// 804AFE5: using guessed type int __fastcall sub_804AFE5(_DWORD, _DWORD);
// 805C10C: using guessed type int dword_805C10C;
// 805C118: using guessed type int dword_805C118;
// 805C148: using guessed type int dword_805C148;
// 805C1A8: using guessed type int dword_805C1A8;

//----- (08055736) --------------------------------------------------------
int __usercall sub_8055736@<eax>(signed __int32 a1@<ebx>, FILE *fp)
{
  bool v2; // ST2E_1
  bool v3; // al
  signed __int32 v4; // edx
  signed __int32 v5; // ecx
  char v10; // al
  signed __int32 v11; // et0
  int v12; // eax
  signed __int32 v21; // eax
  signed __int32 v22; // eax
  signed __int32 v23; // edx
  signed __int32 v24; // ecx
  signed __int32 v25; // eax
  char v26; // al
  signed __int32 v27; // ett
  bool v29; // [esp+1Dh] [ebp-Bh]
  bool v30; // [esp+1Fh] [ebp-9h]

  v29 = __fpending(fp) != 0;
  v2 = ferror_unlocked(fp) != 0;
  v3 = sub_80549A1(a1, fp) != 0;
  v30 = v3;
  if ( !v2 )
  {
    _CF = 0;
    _OF = 0;
    _ZF = v3 == 0;
    _SF = v3 < 0;
    if ( !v3 )
      return 0;
    __asm { pushfw }
    if ( a1 >= 10 )
    {
      v11 = _InterlockedExchange(&dword_805C1A8, a1);
      v10 = _InterlockedExchange(&dword_805C1A8, v5);
      _InterlockedExchange(&dword_805C1A8, v11);
      if ( ((_BYTE)a1 - 1) * v10 & 1 )
        abort();
    }
    __asm { popfw }
    if ( !v29 && *__errno_location() == 9 )
      return 0;
  }
  v12 = !v30;
  _CF = 0;
  _OF = 0;
  _ZF = v30 == 1;
  _SF = (v12 & 0x80u) != 0;
  if ( v30 != 1 )
  {
    __asm { pushfw }
    _CF = (unsigned int)a1 < 0xA;
    _OF = __OFSUB__(a1, 10);
    _ZF = a1 == 10;
    _SF = a1 - 10 < 0;
    if ( a1 >= 10 )
    {
      __asm { pushfw }
      v21 = _InterlockedExchange(&dword_805C130, v12);
      _InterlockedExchange(&dword_805C130, v4);
      _InterlockedExchange(&dword_805C130, v21);
      v22 = sub_804BB55();
      if ( v22 != 654 )
      {
        v25 = _InterlockedExchange(&dword_805C130, v22);
        _InterlockedExchange(&dword_805C130, v23);
        _InterlockedExchange(&dword_805C130, v25);
        sub_804BB5F(v24);
      }
      __asm { popfw }
      v27 = _InterlockedExchange(&dword_805C148, a1);
      v26 = _InterlockedExchange(&dword_805C148, v24);
      _InterlockedExchange(&dword_805C148, v27);
      if ( ((_BYTE)a1 - 1) * v26 & 1 )
        abort();
    }
    __asm { popfw }
    *__errno_location() = 0;
  }
  return -1;
}
// 804BB5F: using guessed type int __fastcall sub_804BB5F(_DWORD);
// 805C130: using guessed type int dword_805C130;
// 805C148: using guessed type int dword_805C148;
// 805C1A8: using guessed type int dword_805C1A8;

//----- (08055864) --------------------------------------------------------
int __usercall sub_8055864@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>, int category)
{
  signed __int32 v8; // eax
  unsigned __int32 v9; // eax
  signed __int32 v10; // ecx
  signed __int32 v11; // ecx
  char v16; // al
  signed __int32 v17; // ebx
  signed __int32 v18; // et2
  int v19; // eax
  char v20; // al
  signed __int32 v21; // ett
  int v22; // eax
  signed __int32 v23; // edx
  signed __int32 v28; // ebx
  char v29; // t0
  signed __int32 v31; // [esp-Ah] [ebp-36h]
  char *v32; // [esp-4h] [ebp-30h]
  unsigned __int8 v33; // [esp+1Bh] [ebp-11h]

  __asm { pushfw }
  v8 = _InterlockedExchange(&dword_805C178, a5);
  _InterlockedExchange(&dword_805C178, a6);
  _InterlockedExchange(&dword_805C178, v8);
  v9 = sub_8050431();
  if ( v9 != 110 )
    sub_805043B(
      v9 < 0x6E,
      v9 == 110,
      (signed int)(v9 - 110) < 0,
      __OFSUB__(v9, 110),
      _InterlockedExchange(&dword_805C178, v10),
      _InterlockedExchange(&dword_805C178, _InterlockedExchange(&dword_805C178, v9)),
      a7);
  __asm { popfw }
  v33 = 1;
  v32 = setlocale(category, 0);
  __asm { pushfw }
  v31 = a7;
  _CF = (unsigned int)a7 < 0xA;
  _OF = __OFSUB__(a7, 10);
  _ZF = a7 == 10;
  _SF = a7 - 10 < 0;
  if ( a7 >= 10 )
  {
    v16 = a7;
    v17 = _InterlockedExchange(&dword_805C154, a7);
    v18 = _InterlockedExchange(&dword_805C154, v11);
    v11 = _InterlockedExchange(&dword_805C154, v17);
    a7 = v18 - 1;
    v19 = ((_BYTE)v18 - 1) * v16 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = v19 == 0;
    _SF = v19 < 0;
    if ( v19 )
      abort();
  }
  __asm { pushfw }
  if ( a7 >= 10 )
  {
    v21 = _InterlockedExchange(&dword_805C124, a7);
    v20 = _InterlockedExchange(&dword_805C124, v11);
    _InterlockedExchange(&dword_805C124, v21);
    if ( ((_BYTE)a7 - 1) * v20 & 1 )
      abort();
  }
  __asm
  {
    popfw
    popfw
  }
  if ( v32 )
  {
    v22 = strcmp(v32, "C");
    _CF = 0;
    _OF = 0;
    _ZF = v22 == 0;
    _SF = v22 < 0;
    if ( !v22 )
      goto LABEL_19;
    __asm { pushfw }
    if ( v31 >= 10 )
    {
      v28 = _InterlockedExchange(&dword_805C130, v31);
      v29 = _InterlockedExchange(&dword_805C130, v23);
      _InterlockedExchange(&dword_805C130, v28);
      if ( (v29 - 1) * (_BYTE)v31 & 1 )
        abort();
    }
    __asm { popfw }
    if ( !strcmp(v32, "POSIX") )
LABEL_19:
      v33 = 0;
  }
  return v33;
}
// 8055864: could not find valid save-restore pair for ebp
// 805C124: using guessed type int dword_805C124;
// 805C130: using guessed type int dword_805C130;
// 805C154: using guessed type int dword_805C154;
// 805C178: using guessed type int dword_805C178;

//----- (0805599B) --------------------------------------------------------
void *__usercall sub_805599B@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>)
{
  signed __int32 v2; // ebx
  signed __int32 v3; // ecx
  signed __int32 v4; // ebx
  signed __int32 v5; // et0
  _BOOL4 v6; // eax
  unsigned int v7; // eax
  signed __int32 v8; // edx
  signed __int32 v9; // ecx
  char v14; // al
  signed __int32 v15; // et2
  signed __int32 v20; // eax
  signed __int32 v21; // edx
  int v22; // ecx
  signed __int32 v23; // ebx
  signed __int32 v24; // edx
  char v25; // al
  signed __int32 v26; // et1
  signed __int32 v27; // ecx
  signed __int32 v28; // eax
  signed __int32 v29; // et2
  signed __int32 v30; // eax
  signed __int32 v31; // edx
  signed __int32 v32; // eax
  signed __int32 v33; // ecx
  size_t v35; // [esp-4h] [ebp-CCh]
  void *v36; // [esp+18h] [ebp-B0h]
  const char *s; // [esp+1Ch] [ebp-ACh]
  void *v38; // [esp+20h] [ebp-A8h]
  signed __int32 v39; // [esp+24h] [ebp-A4h]
  size_t n; // [esp+2Ch] [ebp-9Ch]
  size_t v41; // [esp+30h] [ebp-98h]
  _BOOL4 v42; // [esp+34h] [ebp-94h]
  void *dest; // [esp+38h] [ebp-90h]
  int fd; // [esp+3Ch] [ebp-8Ch]
  FILE *stream; // [esp+40h] [ebp-88h]
  int c; // [esp+44h] [ebp-84h]
  int ca; // [esp+44h] [ebp-84h]
  size_t v48; // [esp+4Ch] [ebp-7Ch]
  void *v49; // [esp+50h] [ebp-78h]
  char src; // [esp+56h] [ebp-72h]
  char v51; // [esp+89h] [ebp-3Fh]
  unsigned int v52; // [esp+BCh] [ebp-Ch]

  v52 = __readgsdword(0x14u);
  v2 = _InterlockedExchange(&dword_805C160, a2);
  v5 = _InterlockedExchange(&dword_805C160, a1);
  v3 = v2;
  v4 = v5;
  _InterlockedExchange(&dword_805C160, v3);
  v36 = (void *)dword_805C894;
  if ( !dword_805C894 )
  {
    s = getenv("CHARSETALIASDIR");
    if ( !s || !*s )
      s = "/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib";
    n = strlen(s);
    v41 = strlen("charset.alias");
    v6 = n && s[n - 1] != 47;
    v42 = v6;
    dest = malloc(n + v6 + v41 + 1);
    if ( dest )
    {
      memcpy(dest, s, n);
      if ( v42 )
        *((_BYTE *)dest + n) = 47;
      memcpy(
        (void *)(n + v42 + _InterlockedExchange(&dword_805C160, _InterlockedExchange(&dword_805C160, v41 + 1))),
        "charset.alias",
        _InterlockedExchange(&dword_805C160, (signed __int32)dest));
    }
    free(0);
    if ( dest )
    {
      fd = open64(dest, 0x20000);
      if ( fd >= 0 )
      {
        stream = fdopen(fd, "r");
        if ( stream )
        {
          v38 = 0;
          v39 = 0;
          while ( 1 )
          {
            v7 = getc_unlocked(stream);
            c = v7;
            _CF = v7 < 0xFFFFFFFF;
            _OF = __OFSUB__(v7, -1);
            _ZF = v7 == -1;
            _SF = (signed int)(v7 + 1) < 0;
            if ( v7 == -1 )
              break;
            _CF = v7 < 0xA;
            _OF = __OFSUB__(v7, 10);
            _ZF = v7 == 10;
            _SF = (signed int)(v7 - 10) < 0;
            if ( v7 != 10 )
            {
              __asm { pushfw }
              v20 = _InterlockedExchange(&dword_805C10C, v7);
              _InterlockedExchange(&dword_805C10C, v9);
              _InterlockedExchange(&dword_805C10C, v20);
              if ( sub_804AFDB() != 929 )
              {
                v23 = _InterlockedExchange(&dword_805C10C, v4);
                _InterlockedExchange(&dword_805C10C, v21);
                sub_804AFE5(v22, _InterlockedExchange(&dword_805C10C, v23));
              }
              __asm { popfw }
              if ( c != 32 && c != 9 )
              {
                if ( c == 35 )
                {
                  do
                    ca = getc_unlocked(stream);
                  while ( ca != -1 && ca != 10 );
                  if ( ca == -1 )
                    goto LABEL_46;
                }
                else
                {
                  ungetc(c, stream);
                  if ( fscanf(stream, "%50s %50s", &src, &v51) <= 1 )
                    goto LABEL_46;
                  v35 = strlen(&src);
                  __asm { pushfw }
                  if ( v4 >= 10 )
                  {
                    v26 = _InterlockedExchange(&dword_805C16C, v4);
                    v25 = _InterlockedExchange(&dword_805C16C, v24);
                    _InterlockedExchange(&dword_805C16C, v26);
                    if ( ((_BYTE)v4 - 1) * v25 & 1 )
                      abort();
                  }
                  __asm { popfw }
                  v48 = strlen(&v51);
                  v49 = v38;
                  if ( v39 )
                  {
                    v39 += v48 + v35 + 2;
                    v29 = _InterlockedExchange(&dword_805C160, v39);
                    v28 = _InterlockedExchange(&dword_805C160, v27);
                    _InterlockedExchange(&dword_805C160, v29);
                    v38 = realloc(v38, v28 + 1);
                  }
                  else
                  {
                    v39 = v35 + v48 + 2;
                    v38 = malloc(v35 + v48 + 3);
                  }
                  if ( !v38 )
                  {
                    v39 = 0;
                    free(v49);
                    goto LABEL_46;
                  }
                  v30 = _InterlockedExchange(&dword_805C160, v39 - v48 - v35);
                  v31 = _InterlockedExchange(&dword_805C160, v39 - v48);
                  _InterlockedExchange(&dword_805C160, v30);
                  strcpy((char *)v38 + v31 - 2, &src);
                  v32 = _InterlockedExchange(&dword_805C160, (signed __int32)v38);
                  _InterlockedExchange(&dword_805C160, v33);
                  _InterlockedExchange(&dword_805C160, v32);
                  strcpy((char *)v38 + v39 - v48 - 1, &v51);
                }
              }
            }
          }
          __asm { pushfw }
          if ( v4 >= 10 )
          {
            v15 = _InterlockedExchange(&dword_805C1A8, v4);
            v14 = _InterlockedExchange(&dword_805C1A8, v8);
            _InterlockedExchange(&dword_805C1A8, v15);
            if ( ((_BYTE)v4 - 1) * v14 & 1 )
              abort();
          }
          __asm { popfw }
LABEL_46:
          sub_80549A1(v4, stream);
          if ( v39 )
          {
            *((_BYTE *)v38 + v39) = 0;
            v36 = v38;
          }
          else
          {
            v36 = &unk_805840B;
          }
        }
        else
        {
          close(fd);
          v36 = &unk_805840B;
        }
      }
      else
      {
        v36 = &unk_805840B;
      }
      free(dest);
    }
    else
    {
      v36 = &unk_805840B;
    }
    dword_805C894 = (int)v36;
  }
  return v36;
}
// 8048D10: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 804AFE5: using guessed type int __fastcall sub_804AFE5(_DWORD, _DWORD);
// 805C10C: using guessed type int dword_805C10C;
// 805C160: using guessed type int dword_805C160;
// 805C16C: using guessed type int dword_805C16C;
// 805C1A8: using guessed type int dword_805C1A8;
// 805C894: using guessed type int dword_805C894;

//----- (08055F5C) --------------------------------------------------------
const char *__usercall sub_8055F5C@<eax>(signed __int32 a1@<ebx>)
{
  signed __int32 v1; // ecx
  signed __int32 v6; // edx
  char v7; // al
  signed __int32 v8; // ebx
  char v9; // t0
  signed __int32 v11; // [esp-Ah] [ebp-32h]
  size_t v12; // [esp-4h] [ebp-2Ch]
  const char *s1; // [esp+18h] [ebp-10h]
  char *s2; // [esp+1Ch] [ebp-Ch]

  s1 = nl_langinfo(14);
  if ( !s1 )
    s1 = (const char *)&unk_805840B;
  for ( s2 = (char *)sub_805599B(v1, a1); *s2; s2 += strlen(&s2[v12 + 1]) + v12 + 2 )
  {
    if ( !strcmp(s1, s2) || *s2 == 42 && !s2[1] )
    {
      s1 = &s2[strlen(s2) + 1];
      break;
    }
    v12 = strlen(s2);
    __asm { pushfw }
    v11 = a1;
    if ( a1 >= 10 )
    {
      v7 = a1;
      v8 = _InterlockedExchange(&dword_805C154, a1);
      v9 = _InterlockedExchange(&dword_805C154, v6);
      _InterlockedExchange(&dword_805C154, v8);
      if ( (v9 - 1) * v7 & 1 )
        abort();
    }
    a1 = v11;
    __asm { popfw }
  }
  if ( !*s1 )
    s1 = "ASCII";
  return s1;
}
// 805C154: using guessed type int dword_805C154;

//----- (080562BD) --------------------------------------------------------
int __usercall sub_80562BD@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>, int a3)
{
  signed __int32 v8; // eax
  signed __int32 v9; // eax
  signed __int32 v10; // edx
  signed __int32 v11; // ecx
  signed __int32 v12; // eax
  signed __int32 v13; // ebx
  signed __int32 v14; // edx
  signed __int32 v15; // ebx
  signed __int32 v16; // et2
  signed __int32 v17; // ecx
  signed __int32 v18; // ebx

  _CF = (unsigned int)(a3 - 65) < 0x19;
  _OF = __OFSUB__(a3 - 65, 25);
  _ZF = a3 == 90;
  _SF = a3 - 90 < 0;
  if ( (unsigned int)(a3 - 65) <= 0x19 )
    return a3 + 32;
  __asm { pushfw }
  v8 = _InterlockedExchange(&dword_805C10C, a3 - 65);
  _InterlockedExchange(&dword_805C10C, a1);
  _InterlockedExchange(&dword_805C10C, v8);
  v9 = sub_804AFDB();
  if ( v9 != 929 )
  {
    v12 = _InterlockedExchange(&dword_805C10C, v9);
    _InterlockedExchange(&dword_805C10C, v11);
    sub_804AFE5(_InterlockedExchange(&dword_805C10C, v12), v10);
  }
  __asm
  {
    popfw
    pushfw
  }
  v13 = _InterlockedExchange(&dword_805C124, a2);
  v16 = _InterlockedExchange(&dword_805C124, v10);
  v14 = v13;
  v15 = v16;
  _InterlockedExchange(&dword_805C124, v14);
  if ( sub_804C840() != 516 )
  {
    v18 = _InterlockedExchange(&dword_805C124, v15);
    _InterlockedExchange(&dword_805C124, v17);
    sub_804C84A(_InterlockedExchange(&dword_805C124, v18));
  }
  __asm { popfw }
  return a3;
}
// 804AFE5: using guessed type int __fastcall sub_804AFE5(_DWORD, _DWORD);
// 804C84A: using guessed type int __fastcall sub_804C84A(_DWORD);
// 805C10C: using guessed type int dword_805C10C;
// 805C124: using guessed type int dword_805C124;

//----- (080563B2) --------------------------------------------------------
signed __int32 __usercall sub_80563B2@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>, unsigned __int32 a7, unsigned int a8, __int64 a9)
{
  char v9; // al
  signed __int32 v10; // et0
  signed __int32 v11; // ecx
  signed __int32 v12; // ebx
  unsigned __int32 v13; // ecx
  signed __int32 v14; // edx
  signed __int32 result; // eax
  int v16; // ebp
  int v17; // ebp
  unsigned int v22; // ebp
  signed __int32 v23; // ebx
  signed __int32 v24; // ecx
  signed __int32 v25; // ebx
  signed __int32 v26; // et2
  unsigned __int32 v27; // eax
  signed __int32 v28; // edx
  signed __int32 v29; // ecx
  bool v30; // cf
  bool v31; // zf
  bool v32; // sf
  char v33; // of
  signed __int32 v34; // eax
  unsigned __int64 v35; // rtt
  signed __int32 v36; // ecx
  unsigned __int64 v37; // rax
  unsigned int v38; // edi
  unsigned __int64 v39; // rax
  unsigned int v40; // ecx
  unsigned int v41; // edi
  signed __int32 v42; // et1
  unsigned int v43; // [esp+4h] [ebp-1Ch]
  __int64 v44; // [esp+8h] [ebp-18h]
  __int64 v45; // [esp+8h] [ebp-18h]

  __asm { pushfw }
  if ( a6 >= 10 )
  {
    v10 = _InterlockedExchange(&dword_805C184, a6);
    v9 = _InterlockedExchange(&dword_805C184, a5);
    _InterlockedExchange(&dword_805C184, v10);
    if ( ((_BYTE)a6 - 1) * v9 & 1 )
      abort();
  }
  __asm { popfw }
  v11 = _InterlockedExchange(&dword_805C160, a6);
  v12 = _InterlockedExchange(&dword_805C160, a7);
  v13 = _InterlockedExchange(&dword_805C160, v11);
  LODWORD(v44) = v13;
  if ( HIDWORD(a9) )
  {
    if ( HIDWORD(a9) > a8 )
    {
      result = v13;
    }
    else
    {
      _BitScanReverse((unsigned int *)&v16, HIDWORD(a9));
      v17 = v16 ^ 0x1F;
      if ( v17 )
      {
        v43 = (HIDWORD(a9) << v17) | ((unsigned int)a9 >> (32 - v17));
        v36 = _InterlockedExchange(&dword_805C160, v12);
        _InterlockedExchange(&dword_805C160, v17);
        LODWORD(v45) = (_DWORD)a9 << _InterlockedExchange(&dword_805C160, v36);
        HIDWORD(v37) = a8 >> (32 - v17);
        LODWORD(v37) = (a8 << v17) | (a7 >> (32 - v17));
        HIDWORD(v45) = a7 << v17;
        v38 = v37 % v43;
        v39 = (unsigned int)v45 * (unsigned __int64)(unsigned int)(v37 / v43);
        v40 = v39;
        if ( v38 < HIDWORD(v39) || HIDWORD(v45) < (unsigned int)v39 && v38 == HIDWORD(v39) )
        {
          HIDWORD(v39) = (v39 - __PAIR__(v43, (unsigned int)v45)) >> 32;
          v40 = v39 - v45;
        }
        v41 = (__PAIR__(v38, HIDWORD(v45)) - __PAIR__(HIDWORD(v39), v40)) >> 32;
        v42 = _InterlockedExchange(&dword_805C160, (v41 << (32 - v17)) | ((HIDWORD(v45) - v40) >> v17));
        result = _InterlockedExchange(&dword_805C160, v41 >> v17);
        _InterlockedExchange(&dword_805C160, v42);
      }
      else
      {
        if ( (unsigned int)a9 <= v13 || HIDWORD(a9) < a8 )
          LODWORD(v44) = v13 - a9;
        result = v44;
      }
    }
  }
  else
  {
    if ( (unsigned int)a9 <= a8 )
    {
      _CF = 0;
      _OF = 0;
      _ZF = (_DWORD)a9 == 0;
      _SF = (signed int)a9 < 0;
      v22 = a9;
      if ( !(_DWORD)a9 )
        v22 = 1 / 0u;
      __asm { pushfw }
      v23 = _InterlockedExchange(&dword_805C16C, v12);
      v26 = _InterlockedExchange(&dword_805C16C, v13);
      v24 = v23;
      v25 = v26;
      _InterlockedExchange(&dword_805C16C, v24);
      v27 = sub_805344B();
      v30 = v27 < 0x104;
      v33 = __OFSUB__(v27, 260);
      v31 = v27 == 260;
      v32 = (signed int)(v27 - 260) < 0;
      if ( v27 != 260 )
      {
        v34 = _InterlockedExchange(&dword_805C16C, v27);
        _InterlockedExchange(&dword_805C16C, v28);
        sub_8053455(v30, v31, v32, v33, _InterlockedExchange(&dword_805C16C, v34), v29, v25);
      }
      __asm { popfw }
      LODWORD(v35) = v29;
      HIDWORD(v35) = a8 % v22;
      v14 = v35 % v22;
    }
    else
    {
      v14 = __PAIR__(a8, v13) % (unsigned int)a9;
    }
    result = v14;
  }
  return result;
}
// 805C160: using guessed type int dword_805C160;
// 805C16C: using guessed type int dword_805C16C;
// 805C184: using guessed type int dword_805C184;

//----- (08056735) --------------------------------------------------------
int __usercall sub_8056735@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>, int a7)
{
  signed __int32 v7; // ebx
  signed __int32 v8; // edx
  signed __int32 v9; // edx
  signed __int32 v10; // ebx
  signed __int32 v11; // et0
  unsigned __int32 v12; // eax
  signed __int32 v13; // edx
  signed __int32 v14; // ecx
  signed __int32 v15; // ebx
  signed __int32 v16; // et1
  int v18; // [esp-1Ch] [ebp-20h]

  sub_804B85B(_CF, _ZF, _SF, _OF, a5, a6);
  v18 = __cxa_atexit(a7, 0, dword_805C1C8);
  __asm { pushfw }
  v7 = _InterlockedExchange(&dword_805C184, a6 + 20845);
  v11 = _InterlockedExchange(&dword_805C184, v8);
  v9 = v7;
  v10 = v11;
  _InterlockedExchange(&dword_805C184, v9);
  v12 = sub_804AE45();
  if ( v12 != -91 )
  {
    v15 = _InterlockedExchange(&dword_805C184, v10);
    v16 = _InterlockedExchange(&dword_805C184, v13);
    _InterlockedExchange(&dword_805C184, v15);
    sub_804AE4F(v12 < 0xFFFFFFA5, v12 == -91, (signed int)(v12 + 91) < 0, __OFSUB__(v12, -91), v12, v14, v16);
  }
  __asm { popfw }
  return v18;
}
// 8048E80: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 805C184: using guessed type int dword_805C184;
// 805C1C8: using guessed type int dword_805C1C8;

//----- (08056E30) --------------------------------------------------------
int (**sub_8056E30())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_805BEC8;
  v1 = &off_805BECC - off_805BEC8;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_805BEC8[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 805BEC8: using guessed type int (*off_805BEC8[2])();
// 805BECC: using guessed type int (*off_805BECC)();

//----- (08056E94) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 2 decompilation failure(s) on 145 function(s)"
