/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8048CF0();
// int strcmp(const char *s1, const char *s2);
// int __cdecl open64(_DWORD, _DWORD); weak
// int __cdecl getline(_DWORD, _DWORD, _DWORD); weak
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void _exit(int status);
// void free(void *ptr);
// void *memcpy(void *dest, const void *src, size_t n);
// int mbsinit(const mbstate_t *ps);
// int tolower(int c);
// int fclose(FILE *stream);
// int getc_unlocked(FILE *stream);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// int iswprint(wint_t wc);
// int __cdecl fopen64(_DWORD, _DWORD); weak
// int ferror_unlocked(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// size_t __ctype_get_mb_cur_max(void);
// char *strcpy(char *dest, const char *src);
// size_t __fpending(FILE *fp);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// void error(int status, int errnum, const char *format, ...);
// size_t fread_unlocked(void *ptr, size_t size, size_t n, FILE *stream);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// char *strchr(const char *s, int c);
// int fscanf(FILE *stream, const char *format, ...);
// size_t strlen(const char *s);
// int fprintf(FILE *stream, const char *format, ...);
// int fcntl(int fd, int cmd, ...);
// void *memset(void *s, int c, size_t n);
// int ungetc(int c, FILE *stream);
// int *__errno_location(void);
// int fileno(FILE *stream);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// char *strrchr(const char *s, int c);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// int feof_unlocked(FILE *stream);
// void abort(void);
// char *ngettext(const char *msgid1, const char *msgid2, unsigned int n);
// int close(int fd);
// const unsigned __int16 **__ctype_b_loc(void);
// int putchar_unlocked(int c);
// int _gmon_start__(void); weak
void sub_8049123();
void sub_8049140();
int sub_8049150();
int sub_80491C0();
int sub_80491E0();
void sub_804923F();
void sub_804925A();
signed int sub_804926A();
void sub_804934C();
void sub_80493A5();
// int __usercall sub_80493B5@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>);
void sub_80494CB();
void sub_804951A();
int sub_8049569();
void sub_804964B();
void sub_8049714();
// int __usercall sub_8049724@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>);
void sub_8049871();
// void __usercall __spoils<edx,ecx> sub_80498C1(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>);
int sub_804990F();
void sub_8049A32();
void sub_8049A81();
// int __usercall sub_8049AC6@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>);
void sub_8049BE5();
// void __usercall __spoils<edx,ecx> sub_8049C3E(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>);
// int __usercall sub_8049D28@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>);
void sub_8049E80();
void sub_8049F04();
// int __usercall sub_8049F52@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>);
void sub_804A119();
// signed __int32 __usercall sub_804A171@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>);
int sub_804A22E();
void sub_804A3CE();
// void __usercall __spoils<edx,ecx> sub_804A41E(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>);
// signed int __usercall sub_804A4CC@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>);
void sub_804A662();
// int __usercall sub_804A67D@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>);
// int __usercall sub_804A7A8@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>);
signed int sub_804A881();
int __fastcall sub_804A88B(_DWORD); // weak
void sub_804A984();
// void __usercall __spoils<edx,ecx> sub_804A9D3(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>);
signed int sub_804AA55();
// void __usercall __spoils<edx,ecx> sub_804ABB4(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>);
void sub_804AC77();
// int __usercall sub_804AC87@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>);
signed int sub_804ADD8();
// void __usercall __noreturn sub_804ADE2(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>);
signed int sub_804AFB8();
// void __usercall __noreturn sub_804AFC2(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>);
// signed int __usercall sub_804B058@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>);
// void __usercall __noreturn sub_804B0A0(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>);
void sub_804B193();
// void __usercall __spoils<edx,ecx> sub_804B260(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>);
// int __usercall sub_804B35E@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>);
void sub_804B51E();
// signed int __usercall sub_804B522@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>);
// void __usercall __noreturn sub_804B619(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>);
// int __usercall sub_804B699@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>);
// int __usercall sub_804B78C@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>);
// int __usercall sub_804B8E6@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>, __int64 a7);
unsigned int __cdecl sub_804BA0B(int a1, unsigned int a2);
// int __usercall sub_804BA3D@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>);
// int __usercall sub_804BC1F@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, char *s1);
int __cdecl sub_804BE4A(int a1);
// void __usercall __noreturn sub_804BE52(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, int a9);
// signed __int32 __usercall sub_804C168@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, signed __int32 a3, unsigned int a4);
// bool __usercall sub_804C330@<al>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>, _BYTE *a3);
// bool __usercall sub_804C4AA@<al>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, signed __int32 a3, int a4, _BYTE **a5, signed __int32 *a6, char a7);
// bool __usercall sub_804C674@<al>(signed __int32 a1@<ebx>, signed __int32 a2, int a3, _BYTE **a4, _DWORD *a5, signed __int32 *a6);
// int __usercall sub_804C930@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>, char *a7, unsigned __int8 a8);
// int __usercall sub_804CB2E@<eax>(signed __int32 a1@<ebx>, char *s1, int a3, int a4, int a5);
// _BOOL4 __usercall sub_804CE15@<eax>(void *a1@<ebx>, int argc);
// signed int __usercall sub_804DF47@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>);
_DWORD *__cdecl sub_804E02B(_DWORD *a1);
// _DWORD *__usercall sub_804E077@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, _DWORD *a8, int a9);
// _DWORD *__usercall sub_804E221@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, int a8@<ebp>, int *a9, _DWORD *a10);
// _DWORD *__usercall sub_804E415@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, int *a4, _DWORD *a5);
// int __usercall sub_804E677@<eax>(signed __int32 a1@<ebx>, FILE *stream, int a3);
// int *__usercall sub_804E8F6@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, void *src, size_t a4, int a5);
// int *__usercall sub_804EB80@<eax>(int a1@<ecx>, signed __int32 a2@<ebx>, int *a3, unsigned int a4, int *a5);
// int __usercall sub_804F9C5@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, int a8@<ebp>, int a9, int a10, int a11, int a12, int a13, int a14);
// int __usercall sub_804FAF9@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, int a8@<ebp>, FILE *stream, int a10);
signed int sub_804FBC9();
// void __usercall __noreturn sub_804FBD3(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>);
// FILE *__usercall sub_804FD03@<eax>(signed __int32 a1@<ebx>, int a2, char *modes);
char *__cdecl sub_804FE3A(char *s);
// int __usercall sub_8050064@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, int *a3, unsigned __int8 a4, char a5);
// int *__usercall sub_80501BB@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>, int *a8, int a9, int a10);
// unsigned int *__userpurge sub_80502A8@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>, unsigned int *a8, unsigned int a9);
// const char *__usercall sub_8050482@<eax>(signed __int32 a1@<ebx>, char *msgid, int a3);
// unsigned int __usercall sub_80505A2@<eax>(signed __int32 a1@<ebx>, signed __int32 a2, unsigned int a3, signed __int32 a4, size_t a5, unsigned int a6, int a7, int a8, char *a9, char *a10);
void *__cdecl sub_8051313(signed __int32 a1, size_t a2, _DWORD *a3, int *a4);
// void *__usercall sub_8051523@<eax>(signed __int32 a1@<ebx>, signed int a2, signed __int32 a3, size_t a4, int a5);
// void *__usercall sub_80517DA@<eax>(signed __int32 a1@<ebx>, signed int a2, signed __int32 a3);
// void *__usercall sub_8051840@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>, signed int a7, signed __int32 a8, size_t a9);
signed int sub_805194D();
// void __usercall __noreturn sub_8051957(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>);
// void *__usercall sub_8051997@<eax>(signed __int32 a1@<ebx>, signed int a2, unsigned __int32 a3, signed __int32 a4);
// void *__usercall sub_8051A49@<eax>(signed __int32 a1@<ebx>, signed int a2, unsigned __int32 a3, signed __int32 a4, size_t a5);
// void *__usercall sub_8051B96@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, signed __int32 a3, size_t a4, unsigned __int8 a5);
// void *__usercall sub_8051D37@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, signed __int32 a3, unsigned __int8 a4);
// void *__usercall sub_8051D60@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, signed __int32 a8);
// void *__usercall sub_8051EAD@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, int a8@<ebp>, signed int a9, unsigned __int32 a10, signed __int32 a11);
// void *__usercall sub_8052188@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>, signed int a3, int a4, int a5, signed __int32 a6);
// void *__usercall sub_80522D1@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>, signed int a3, int a4, int a5, signed __int32 a6, size_t a7);
// void *__usercall sub_8052408@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>, signed int a7, signed __int32 a8, size_t a9);
signed int sub_8052466();
int __fastcall sub_8052470(_DWORD); // weak
// void *__usercall sub_8052582@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>, signed int a3, signed __int32 a4);
// signed int __usercall sub_80525AB@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>);
signed int sub_8052670();
int __fastcall sub_805267A(_DWORD, _DWORD); // weak
int __fastcall sub_805267B(_DWORD, _DWORD); // weak
// int __usercall sub_80527FB@<eax>(signed __int32 a1@<ebx>, int fd);
// int __usercall sub_805281E@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, FILE *stream, int a9, int a10, int a11, signed __int32 *a12, int a13);
// int __usercall sub_8053067@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, FILE *a4, int a5, int a6, int a7, signed __int32 *a8);
// int __usercall sub_80531F8@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, FILE *a4, int a5, int a6, int a7, ...);
// void *__usercall sub_80533B3@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, void *a4, unsigned int *a5, unsigned int a6);
// void *__usercall sub_805352E@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>, unsigned __int32 a3);
// void *__usercall sub_8053580@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>, size_t size);
// void *__usercall sub_8053627@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>, void *ptr, size_t size);
signed int sub_80537D9();
int __fastcall sub_80537E3(_DWORD, _DWORD); // weak
// void *__usercall sub_80537E4@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, int a9@<ebp>, const void *src, unsigned __int32 n);
// void __usercall __noreturn sub_8053913(signed __int32 a1@<ebx>);
// int __usercall sub_80539F0@<eax>(signed __int32 a1@<ebx>, FILE *stream);
// int __usercall sub_8053AF0@<eax>(signed __int32 a1@<ebx>, int fd, int cmd, char a4);
// int __usercall sub_8053D06@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, FILE *stream);
// int __usercall sub_8053E5B@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, FILE *fp);
// int __usercall sub_8053FD0@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, FILE *stream, int a4, int a5, int a6);
// size_t __usercall sub_80541F6@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>, wchar_t *pwc, char *s, size_t n, mbstate_t *p);
// int __usercall sub_80543EB@<eax>(signed __int32 a1@<eax>, signed __int32 a2@<edx>, signed __int32 a3@<ecx>, unsigned __int8 *a4, unsigned __int32 a5);
// signed int __usercall sub_8054491@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, int a8@<ebp>, FILE *fp);
// int __usercall sub_80546BD@<eax>(signed __int32 a1@<ebx>, int category);
// void *__usercall sub_80547CB@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>);
// const char *__usercall sub_8054CB5@<eax>(signed __int32 a1@<ebx>);
signed int sub_8054E13();
// void __usercall __noreturn sub_8054E1D(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>);
signed int sub_80550AC();
int __fastcall sub_80550B6(_DWORD); // weak
// signed __int32 __usercall sub_80550DC@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, signed __int32 a3);
// int __usercall sub_8055239@<eax>(signed __int32 a1@<ebx>, __int64 a2, unsigned int a3, unsigned __int32 a4);
// int __usercall sub_805555D@<eax>(char a1@<cf>, char a2@<zf>, char a3@<sf>, char a4@<of>, int a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, int a8);
int (**sub_8055C40())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

char byte_804AEBD[2] = { '\x8D', '6' }; // weak
_UNKNOWN loc_804B036; // weak
char byte_804B111[2] = { '\x89', '' }; // weak
char byte_804B64E[2] = { 'f', '\x90' }; // weak
_UNKNOWN loc_804FC09; // weak
_UNKNOWN loc_8054ECC; // weak
char locale = '\0'; // idb
char byte_8056929[16] =
{
  '0',
  '1',
  '2',
  '3',
  '4',
  '5',
  '6',
  '7',
  '8',
  '9',
  'a',
  'b',
  'c',
  'd',
  'e',
  'f'
}; // idb
_UNKNOWN unk_8056970; // weak
_UNKNOWN unk_80569B0; // weak
_UNKNOWN unk_80569E0; // weak
_UNKNOWN unk_8056ADE; // weak
_UNKNOWN unk_8056AE2; // weak
_UNKNOWN unk_8056AEE; // weak
_UNKNOWN unk_8056AF2; // weak
_UNKNOWN unk_8056AF5; // weak
char aLicenseGplv3Gn[176] = "\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the "; // idb
_UNKNOWN unk_8057213; // weak
_UNKNOWN unk_80581F8; // weak
_UNKNOWN unk_80581FB; // weak
_UNKNOWN unk_8059204; // weak
_UNKNOWN unk_8059207; // weak
int (*off_805AECC[2])() = { &sub_80491E0, &sub_80491C0 }; // weak
int (*off_805AED0)() = &sub_80491C0; // weak
int (*dword_805B008)(void) = NULL; // weak
int dword_805B10C = 0; // weak
int dword_805B118 = 0; // weak
int dword_805B124 = 0; // weak
int dword_805B130 = 0; // weak
int dword_805B13C = 0; // weak
int dword_805B148 = 0; // weak
int dword_805B154 = 0; // weak
int dword_805B160 = 0; // weak
int dword_805B16C = 0; // weak
int dword_805B178 = 0; // weak
int dword_805B184 = 0; // weak
int dword_805B190 = 0; // weak
int dword_805B19C = 0; // weak
int dword_805B1BC = 0; // weak
int dword_805B1C0 = 4294967295; // weak
int status = 1; // idb
int dword_805B1D8 = 1; // weak
int dword_805B1DC = 256; // weak
void *off_805B1E0 = &unk_805B747; // weak
int *off_805B1E4 = &dword_805B1DC; // weak
_UNKNOWN unk_805B1F8; // weak
_UNKNOWN unk_805B21C; // weak
_UNKNOWN unk_805B21F; // weak
_UNKNOWN unk_805B228; // weak
_UNKNOWN unk_805B22B; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int program_invocation_name; // weak
FILE *stdin; // idb
FILE *stdout; // idb
char byte_805B288; // weak
_UNKNOWN unk_805B3F9; // weak
_UNKNOWN unk_805B641; // weak
_UNKNOWN unk_805B651; // weak
char byte_805B6D3; // weak
int dword_805B6D7; // weak
int dword_805B6DB; // weak
char byte_805B6DF; // weak
char byte_805B6E0; // weak
char byte_805B6E1; // weak
char byte_805B6E2; // weak
char byte_805B6E3; // weak
int dword_805B6E7; // weak
char byte_805B6EB; // weak
int dword_805B6EF; // weak
int dword_805B707; // weak
int dword_805B70B; // weak
int dword_805B70F; // weak
int dword_805B713; // weak
int dword_805B717; // weak
int dword_805B71B; // weak
int dword_805B71F; // weak
int dword_805B723; // weak
int dword_805B727; // weak
int dword_805B72B; // weak
int dword_805B72F; // weak
int dword_805B733; // weak
_UNKNOWN unk_805B747; // weak
int dword_805B847; // weak
int dword_805B84B; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (08048CCC) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 80490E0: using guessed type int _gmon_start__(void);

//----- (08048CF0) --------------------------------------------------------
int sub_8048CF0()
{
  return dword_805B008();
}
// 805B008: using guessed type int (*dword_805B008)(void);

//----- (080490F0) --------------------------------------------------------
#error "80490F3: positive sp value has been found (funcsize=2)"

//----- (08049123) --------------------------------------------------------
void sub_8049123()
{
  ;
}

//----- (08049140) --------------------------------------------------------
void sub_8049140()
{
  ;
}

//----- (08049150) --------------------------------------------------------
int sub_8049150()
{
  int result; // eax

  result = &unk_805B22B - &unk_805B228;
  if ( (unsigned int)(&unk_805B22B - &unk_805B228) > 6 )
    result = 0;
  return result;
}
// 8049150: could not find valid save-restore pair for ebp

//----- (080491C0) --------------------------------------------------------
int sub_80491C0()
{
  int result; // eax

  if ( !byte_805B288 )
  {
    result = sub_8049150();
    byte_805B288 = 1;
  }
  return result;
}
// 80491C0: could not find valid save-restore pair for ebp
// 805B288: using guessed type char byte_805B288;

//----- (080491E0) --------------------------------------------------------
int sub_80491E0()
{
  return 0;
}
// 80491E0: could not find valid save-restore pair for ebp

//----- (0804923F) --------------------------------------------------------
void sub_804923F()
{
  ;
}

//----- (0804925A) --------------------------------------------------------
void sub_804925A()
{
  ;
}

//----- (0804926A) --------------------------------------------------------
signed int sub_804926A()
{
  return 3;
}
// 804926A: could not find valid save-restore pair for ebp

//----- (0804934C) --------------------------------------------------------
void sub_804934C()
{
  ;
}

//----- (080493A5) --------------------------------------------------------
void sub_80493A5()
{
  ;
}

//----- (080493B5) --------------------------------------------------------
int __usercall sub_80493B5@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>)
{
  int v2; // eax
  char v7; // al
  signed __int32 v8; // et0
  int v10; // [esp+18h] [ebp-4h]

  v2 = &unk_805B21F - &unk_805B21C;
  _CF = (unsigned int)(&unk_805B21F - &unk_805B21C) < 6;
  _OF = __OFSUB__(&unk_805B21F - &unk_805B21C, 6);
  _ZF = &unk_805B21F - &unk_805B21C == 6;
  _SF = &unk_805B21F - &unk_805B21C - 6 < 0;
  if ( (unsigned int)(&unk_805B21F - &unk_805B21C) > 6 )
  {
    v2 = 0;
    _CF = 0;
    _OF = 0;
    _ZF = 1;
    _SF = 0;
  }
  v10 = v2;
  __asm { pushfw }
  if ( a2 >= 10 )
  {
    v8 = _InterlockedExchange(&dword_805B10C, a2);
    v7 = _InterlockedExchange(&dword_805B10C, a1);
    _InterlockedExchange(&dword_805B10C, v8);
    if ( ((_BYTE)a2 - 1) * v7 & 1 )
      abort();
  }
  __asm { popfw }
  return v10;
}
// 80493B5: could not find valid save-restore pair for ebp
// 805B10C: using guessed type int dword_805B10C;

//----- (080494CB) --------------------------------------------------------
void sub_80494CB()
{
  ;
}

//----- (0804951A) --------------------------------------------------------
void sub_804951A()
{
  ;
}

//----- (08049569) --------------------------------------------------------
int sub_8049569()
{
  int result; // eax

  result = &unk_8059207 - &unk_8059204;
  if ( (unsigned int)(&unk_8059207 - &unk_8059204) > 6 )
    result = 0;
  return result;
}
// 8049569: could not find valid save-restore pair for ebp

//----- (0804964B) --------------------------------------------------------
void sub_804964B()
{
  ;
}

//----- (08049714) --------------------------------------------------------
void sub_8049714()
{
  ;
}

//----- (08049724) --------------------------------------------------------
int __usercall sub_8049724@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>)
{
  char v7; // al
  signed __int32 v8; // et0
  int result; // eax
  int v10; // [esp+18h] [ebp-4h]

  v10 = a5;
  __asm { pushfw }
  if ( a7 >= 10 )
  {
    v8 = _InterlockedExchange(&dword_805B10C, a7);
    v7 = _InterlockedExchange(&dword_805B10C, a6);
    _InterlockedExchange(&dword_805B10C, v8);
    if ( ((_BYTE)a7 - 1) * v7 & 1 )
      abort();
  }
  __asm { popfw }
  result = &unk_80581FB - &unk_80581F8;
  if ( (unsigned int)(&unk_80581FB - &unk_80581F8) > 6 )
    result = 0;
  return result;
}
// 8049724: could not find valid save-restore pair for ebp
// 805B10C: using guessed type int dword_805B10C;

//----- (08049871) --------------------------------------------------------
void sub_8049871()
{
  ;
}

//----- (080498C1) --------------------------------------------------------
void __usercall __spoils<edx,ecx> sub_80498C1(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>)
{
  signed __int32 v7; // eax
  signed __int32 v8; // ecx
  signed __int32 v9; // ebx

  __asm { pushfw }
  v7 = _InterlockedExchange(&dword_805B10C, a5);
  _InterlockedExchange(&dword_805B10C, a6);
  _InterlockedExchange(&dword_805B10C, v7);
  if ( sub_8052466() != -423 )
  {
    v9 = _InterlockedExchange(&dword_805B10C, a7);
    _InterlockedExchange(&dword_805B10C, v8);
    sub_8052470(_InterlockedExchange(&dword_805B10C, v9));
  }
  __asm { popfw }
}
// 8052470: using guessed type int __fastcall sub_8052470(_DWORD);
// 805B10C: using guessed type int dword_805B10C;

//----- (0804990F) --------------------------------------------------------
int sub_804990F()
{
  int result; // eax

  result = &unk_805B21F - &unk_805B21C;
  if ( (unsigned int)(&unk_805B21F - &unk_805B21C) > 6 )
    result = 0;
  return result;
}
// 804990F: could not find valid save-restore pair for ebp

//----- (08049A32) --------------------------------------------------------
void sub_8049A32()
{
  ;
}

//----- (08049A81) --------------------------------------------------------
void sub_8049A81()
{
  ;
}

//----- (08049AC6) --------------------------------------------------------
int __usercall sub_8049AC6@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>)
{
  signed __int32 v6; // eax
  signed __int32 v7; // eax
  signed __int32 v8; // edx
  int v9; // ecx
  signed __int32 v10; // eax
  int result; // eax
  int v12; // [esp+18h] [ebp-4h]

  v12 = a5;
  __asm { pushfw }
  v6 = _InterlockedExchange(&dword_805B148, a5);
  _InterlockedExchange(&dword_805B148, a6);
  _InterlockedExchange(&dword_805B148, v6);
  v7 = sub_80537D9();
  if ( v7 != 862 )
  {
    v10 = _InterlockedExchange(&dword_805B148, v7);
    _InterlockedExchange(&dword_805B148, v8);
    sub_80537E3(v9, _InterlockedExchange(&dword_805B148, v10));
  }
  __asm { popfw }
  result = &unk_805B3F9 - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_805B3F9 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 8049AC6: could not find valid save-restore pair for ebp
// 80537E3: using guessed type int __fastcall sub_80537E3(_DWORD, _DWORD);
// 805B148: using guessed type int dword_805B148;
// 805B240: using guessed type int program_invocation_short_name;

//----- (08049BE5) --------------------------------------------------------
void sub_8049BE5()
{
  ;
}

//----- (08049C3E) --------------------------------------------------------
void __usercall __spoils<edx,ecx> sub_8049C3E(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>)
{
  char v6; // al
  signed __int32 v7; // ebx
  signed __int32 v8; // et0
  signed __int32 v9; // edx
  signed __int32 v10; // ebx
  int v11; // eax
  signed __int32 v16; // ebx
  signed __int32 v17; // edx
  signed __int32 v18; // ebx
  signed __int32 v19; // et1
  unsigned __int32 v20; // eax
  signed __int32 v21; // edx
  signed __int32 v22; // ecx
  bool v23; // cf
  bool v24; // zf
  bool v25; // sf
  char v26; // of
  signed __int32 v27; // eax

  __asm { pushfw }
  if ( a6 >= 10 )
  {
    v6 = a6;
    v7 = _InterlockedExchange(&dword_805B13C, a6);
    v8 = _InterlockedExchange(&dword_805B13C, a5);
    v9 = _InterlockedExchange(&dword_805B13C, v7);
    v10 = v8 - 1;
    v11 = ((_BYTE)v8 - 1) * v6 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = v11 == 0;
    _SF = v11 < 0;
    if ( v11 )
    {
      __asm { pushfw }
      v16 = _InterlockedExchange(&dword_805B124, v10);
      v19 = _InterlockedExchange(&dword_805B124, v9);
      v17 = v16;
      v18 = v19;
      _InterlockedExchange(&dword_805B124, v17);
      v20 = sub_805194D();
      v23 = v20 < 0x2C;
      v26 = __OFSUB__(v20, 44);
      v24 = v20 == 44;
      v25 = (signed int)(v20 - 44) < 0;
      if ( v20 != 44 )
      {
        v27 = _InterlockedExchange(&dword_805B124, v20);
        _InterlockedExchange(&dword_805B124, v22);
        _InterlockedExchange(&dword_805B124, v27);
        sub_8051957(v23, v24, v25, v26, v21, v18);
      }
      __asm { popfw }
      abort();
    }
  }
  __asm { popfw }
}
// 8049C3E: could not find valid save-restore pair for ebx
// 805B124: using guessed type int dword_805B124;
// 805B13C: using guessed type int dword_805B13C;

//----- (08049D28) --------------------------------------------------------
int __usercall sub_8049D28@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>)
{
  char v7; // al
  signed __int32 v8; // ebx
  char v9; // t0
  int result; // eax
  int v11; // [esp+18h] [ebp-4h]

  v11 = a5;
  __asm { pushfw }
  if ( a7 >= 10 )
  {
    v7 = a7;
    v8 = _InterlockedExchange(&dword_805B154, a7);
    v9 = _InterlockedExchange(&dword_805B154, a6);
    _InterlockedExchange(&dword_805B154, v8);
    if ( (v9 - 1) * v7 & 1 )
      abort();
  }
  __asm { popfw }
  result = &unk_805B21F - &unk_805B21C;
  if ( (unsigned int)(&unk_805B21F - &unk_805B21C) > 6 )
    result = 0;
  return result;
}
// 8049D28: could not find valid save-restore pair for ebp
// 805B154: using guessed type int dword_805B154;

//----- (08049E80) --------------------------------------------------------
void sub_8049E80()
{
  ;
}

//----- (08049F04) --------------------------------------------------------
void sub_8049F04()
{
  ;
}

//----- (08049F52) --------------------------------------------------------
int __usercall sub_8049F52@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>)
{
  char v7; // al
  signed __int32 v8; // ebx
  char v9; // t0
  int result; // eax
  int v11; // [esp+18h] [ebp-4h]

  v11 = a5;
  __asm { pushfw }
  if ( a7 >= 10 )
  {
    v7 = a7;
    v8 = _InterlockedExchange(&dword_805B124, a7);
    v9 = _InterlockedExchange(&dword_805B124, a6);
    _InterlockedExchange(&dword_805B124, v8);
    if ( (v9 - 1) * v7 & 1 )
      abort();
  }
  __asm { popfw }
  result = "ll.\n" - (char *)&unk_80569E0;
  if ( (unsigned int)("ll.\n" - (char *)&unk_80569E0) > 6 )
    result = 0;
  return result;
}
// 8049F52: could not find valid save-restore pair for ebp
// 805B124: using guessed type int dword_805B124;

//----- (0804A119) --------------------------------------------------------
void sub_804A119()
{
  ;
}

//----- (0804A171) --------------------------------------------------------
signed __int32 __usercall sub_804A171@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>)
{
  char v8; // al
  signed __int32 v9; // et0
  signed __int32 v10; // eax
  signed __int32 v11; // eax
  signed __int32 v12; // edx
  signed __int32 v13; // ecx
  signed __int32 v14; // eax
  signed __int32 v15; // eax
  signed __int32 v16; // edx
  int v17; // ecx
  signed __int32 v18; // ebx
  signed __int32 v20; // [esp-4h] [ebp-4h]

  v20 = a5;
  __asm { pushfw }
  if ( a8 >= 10 )
  {
    v9 = _InterlockedExchange(&dword_805B118, a8);
    v8 = _InterlockedExchange(&dword_805B118, a7);
    _InterlockedExchange(&dword_805B118, v9);
    if ( ((_BYTE)a8 - 1) * v8 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  v10 = _InterlockedExchange(&dword_805B13C, v20);
  _InterlockedExchange(&dword_805B13C, a6);
  _InterlockedExchange(&dword_805B13C, v10);
  v11 = sub_8052670();
  if ( v11 != -41 )
  {
    v14 = _InterlockedExchange(&dword_805B13C, v11);
    _InterlockedExchange(&dword_805B13C, v12);
    sub_805267A(v13, _InterlockedExchange(&dword_805B13C, v14));
  }
  __asm
  {
    popfw
    pushfw
  }
  v15 = _InterlockedExchange(&dword_805B148, v20);
  _InterlockedExchange(&dword_805B148, v13);
  _InterlockedExchange(&dword_805B148, v15);
  if ( sub_80537D9() != 862 )
  {
    v18 = _InterlockedExchange(&dword_805B148, a8);
    _InterlockedExchange(&dword_805B148, v16);
    sub_80537E3(v17, _InterlockedExchange(&dword_805B148, v18));
  }
  __asm { popfw }
  return v20;
}
// 804A171: could not find valid save-restore pair for ebx
// 805267A: using guessed type int __fastcall sub_805267A(_DWORD, _DWORD);
// 80537E3: using guessed type int __fastcall sub_80537E3(_DWORD, _DWORD);
// 805B118: using guessed type int dword_805B118;
// 805B13C: using guessed type int dword_805B13C;
// 805B148: using guessed type int dword_805B148;

//----- (0804A22E) --------------------------------------------------------
int sub_804A22E()
{
  int result; // eax

  result = &unk_805B21F - &unk_805B21C;
  if ( (unsigned int)(&unk_805B21F - &unk_805B21C) > 6 )
    result = 0;
  return result;
}
// 804A22E: could not find valid save-restore pair for ebp

//----- (0804A3CE) --------------------------------------------------------
void sub_804A3CE()
{
  ;
}

//----- (0804A41E) --------------------------------------------------------
void __usercall __spoils<edx,ecx> sub_804A41E(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>)
{
  char v11; // al
  signed __int32 v12; // ebx
  char v13; // t0
  signed __int32 v14; // ebx
  signed __int32 v15; // et1
  int v16; // eax
  char v17; // al
  signed __int32 v18; // et2
  signed __int32 v19; // [esp-14h] [ebp-14h]

  __asm { pushfw }
  _CF = (unsigned int)a7 < 0xA;
  _OF = __OFSUB__(a7, 10);
  _ZF = a7 == 10;
  _SF = a7 - 10 < 0;
  if ( a7 >= 10 )
  {
    __asm { pushfw }
    v19 = a7;
    if ( a7 >= 10 )
    {
      v11 = a7;
      v12 = _InterlockedExchange(&dword_805B124, a7);
      v13 = _InterlockedExchange(&dword_805B124, a5);
      _InterlockedExchange(&dword_805B124, v12);
      if ( (v13 - 1) * v11 & 1 )
        abort();
    }
    __asm { popfw }
    v14 = _InterlockedExchange(&dword_805B130, v19);
    v15 = _InterlockedExchange(&dword_805B130, a6);
    a6 = _InterlockedExchange(&dword_805B130, v14);
    a7 = v15 - 1;
    v16 = ((_BYTE)v15 - 1) * (_BYTE)v19 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = v16 == 0;
    _SF = v16 < 0;
    if ( ((_BYTE)v15 - 1) * (_BYTE)v19 & 1 )
      abort();
  }
  __asm { pushfw }
  if ( a7 >= 10 )
  {
    v18 = _InterlockedExchange(&dword_805B118, a7);
    v17 = _InterlockedExchange(&dword_805B118, a6);
    _InterlockedExchange(&dword_805B118, v18);
    if ( ((_BYTE)a7 - 1) * v17 & 1 )
      abort();
  }
  __asm
  {
    popfw
    popfw
  }
}
// 804A41E: could not find valid save-restore pair for ebx
// 805B118: using guessed type int dword_805B118;
// 805B124: using guessed type int dword_805B124;
// 805B130: using guessed type int dword_805B130;

//----- (0804A4CC) --------------------------------------------------------
signed int __usercall sub_804A4CC@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>)
{
  signed __int32 v7; // ebx
  signed __int32 v8; // eax
  signed __int32 v9; // ecx
  signed __int32 v10; // eax
  int v12; // [esp+18h] [ebp-4h]

  v12 = a5;
  __asm { pushfw }
  v7 = _InterlockedExchange(&dword_805B178, a7);
  _InterlockedExchange(&dword_805B178, a6);
  _InterlockedExchange(&dword_805B178, v7);
  v8 = sub_804A881();
  if ( v8 != 893 )
  {
    v10 = _InterlockedExchange(&dword_805B178, v8);
    _InterlockedExchange(&dword_805B178, v9);
    sub_804A88B(_InterlockedExchange(&dword_805B178, v10));
  }
  __asm { popfw }
  return 4;
}
// 804A4CC: could not find valid save-restore pair for ebp
// 804A88B: using guessed type int __fastcall sub_804A88B(_DWORD);
// 805B178: using guessed type int dword_805B178;

//----- (0804A662) --------------------------------------------------------
void sub_804A662()
{
  ;
}

//----- (0804A67D) --------------------------------------------------------
int __usercall sub_804A67D@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>)
{
  char v8; // al
  signed __int32 v9; // et0
  signed __int32 v10; // ebx
  signed __int32 v11; // ecx
  signed __int32 v12; // ebx
  signed __int32 v13; // et1
  signed __int32 v14; // edx
  signed __int32 v15; // ecx
  char v20; // al
  signed __int32 v21; // ebx
  char v22; // t2
  signed __int32 v23; // ebx
  char v24; // tt
  signed __int32 v29; // ebx
  signed __int32 v30; // ebx
  signed __int32 v31; // edx
  signed __int32 v32; // ebx
  signed __int32 v33; // et1
  unsigned __int32 v34; // eax
  signed __int32 v35; // edx
  signed __int32 v36; // ecx
  bool v37; // cf
  bool v38; // zf
  bool v39; // sf
  char v40; // of
  signed __int32 v41; // eax
  signed __int32 v43; // [esp-1Ah] [ebp-1Ah]
  signed __int32 v44; // [esp-10h] [ebp-10h]
  unsigned int v45; // [esp-Ah] [ebp-Ah]
  int v46; // [esp-4h] [ebp-4h]

  v46 = a5;
  __asm { pushfw }
  if ( a8 >= 10 )
  {
    v9 = _InterlockedExchange(&dword_805B154, a8);
    v8 = _InterlockedExchange(&dword_805B154, a6);
    _InterlockedExchange(&dword_805B154, v9);
    if ( ((_BYTE)a8 - 1) * v8 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  v10 = _InterlockedExchange(&dword_805B178, a8);
  v13 = _InterlockedExchange(&dword_805B178, a7);
  v11 = v10;
  v12 = v13;
  _InterlockedExchange(&dword_805B178, v11);
  v45 = sub_804A881();
  __asm { pushfw }
  v44 = v13;
  _CF = (unsigned int)v13 < 0xA;
  _OF = __OFSUB__(v13, 10);
  _ZF = v13 == 10;
  _SF = v13 - 10 < 0;
  if ( v13 >= 10 )
  {
    __asm { pushfw }
    v43 = v12;
    if ( v12 >= 10 )
    {
      v20 = v12;
      v21 = _InterlockedExchange(&dword_805B124, v12);
      v22 = _InterlockedExchange(&dword_805B124, v14);
      v14 = _InterlockedExchange(&dword_805B124, v21);
      if ( (v22 - 1) * v20 & 1 )
        abort();
    }
    __asm { popfw }
    v23 = _InterlockedExchange(&dword_805B130, v43);
    v24 = _InterlockedExchange(&dword_805B130, v14);
    v14 = _InterlockedExchange(&dword_805B130, v23);
    if ( (v24 - 1) * (_BYTE)v43 & 1 )
      abort();
  }
  __asm { popfw }
  _CF = v45 < 0x37D;
  _OF = __OFSUB__(v45, 893);
  _ZF = v45 == 893;
  _SF = (signed int)(v45 - 893) < 0;
  if ( v45 != 893 )
  {
    v29 = _InterlockedExchange(&dword_805B178, v44);
    _InterlockedExchange(&dword_805B178, v15);
    sub_804A88B(_InterlockedExchange(&dword_805B178, v29));
  }
  __asm { pushfw }
  v30 = _InterlockedExchange(&dword_805B16C, v44);
  v33 = _InterlockedExchange(&dword_805B16C, v14);
  v31 = v30;
  v32 = v33;
  _InterlockedExchange(&dword_805B16C, v31);
  v34 = sub_804B058(v45 < 0x37D, v45 == 893, (signed int)(v45 - 893) < 0, __OFSUB__(v45, 893), v15, v33);
  v37 = v34 < 0xFFFFFCD4;
  v40 = __OFSUB__(v34, -812);
  v38 = v34 == -812;
  v39 = (signed int)(v34 + 812) < 0;
  if ( v34 != -812 )
  {
    v41 = _InterlockedExchange(&dword_805B16C, v34);
    _InterlockedExchange(&dword_805B16C, v36);
    sub_804B0A0(v37, v38, v39, v40, v35, _InterlockedExchange(&dword_805B16C, v41), v32);
  }
  __asm
  {
    popfw
    popfw
  }
  return v46;
}
// 804A67D: could not find valid save-restore pair for ebx
// 804A88B: using guessed type int __fastcall sub_804A88B(_DWORD);
// 805B124: using guessed type int dword_805B124;
// 805B130: using guessed type int dword_805B130;
// 805B154: using guessed type int dword_805B154;
// 805B16C: using guessed type int dword_805B16C;
// 805B178: using guessed type int dword_805B178;

//----- (0804A7A8) --------------------------------------------------------
int __usercall sub_804A7A8@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>)
{
  signed __int32 v7; // ebx
  signed __int32 v8; // edx
  signed __int32 v9; // ebx
  signed __int32 v10; // et0
  signed __int32 v11; // edx
  signed __int32 v12; // ecx
  signed __int32 v13; // ebx
  int v14; // eax
  signed __int32 v19; // ebx
  signed __int32 v20; // edx
  signed __int32 v21; // ebx
  signed __int32 v22; // et2
  unsigned __int32 v23; // eax
  signed __int32 v24; // edx
  bool v25; // cf
  bool v26; // zf
  bool v27; // sf
  char v28; // of
  signed __int32 v29; // eax
  char v31; // al
  signed __int32 v32; // et0
  int v33; // [esp+18h] [ebp-4h]

  v33 = a5;
  __asm { pushfw }
  v7 = _InterlockedExchange(&dword_805B13C, a7);
  v10 = _InterlockedExchange(&dword_805B13C, a6);
  v8 = v7;
  v9 = v10;
  _InterlockedExchange(&dword_805B13C, v8);
  if ( sub_8052670() != -41 )
  {
    v13 = _InterlockedExchange(&dword_805B13C, v9);
    _InterlockedExchange(&dword_805B13C, v12);
    sub_805267A(_InterlockedExchange(&dword_805B13C, v13), v11);
  }
  __asm { popfw }
  v14 = &unk_805B21F - &unk_805B21C;
  _CF = (unsigned int)(&unk_805B21F - &unk_805B21C) < 6;
  _OF = __OFSUB__(&unk_805B21F - &unk_805B21C, 6);
  _ZF = &unk_805B21F - &unk_805B21C == 6;
  _SF = &unk_805B21F - &unk_805B21C - 6 < 0;
  if ( (unsigned int)(&unk_805B21F - &unk_805B21C) > 6 )
  {
    v33 = &unk_805B21F - &unk_805B21C;
    __asm { pushfw }
    if ( v9 >= 10 )
    {
      v32 = _InterlockedExchange(&dword_805B10C, v9);
      v31 = _InterlockedExchange(&dword_805B10C, v12);
      _InterlockedExchange(&dword_805B10C, v32);
      if ( ((_BYTE)v9 - 1) * v31 & 1 )
        abort();
    }
    __asm { popfw }
    v14 = 0;
    _CF = 0;
    _OF = 0;
    _ZF = 1;
    _SF = 0;
  }
  v33 = v14;
  __asm { pushfw }
  v19 = _InterlockedExchange(&dword_805B130, v9);
  v22 = _InterlockedExchange(&dword_805B130, v11);
  v20 = v19;
  v21 = v22;
  _InterlockedExchange(&dword_805B130, v20);
  v23 = sub_804AFB8();
  v25 = v23 < 0x36C;
  v28 = __OFSUB__(v23, 876);
  v26 = v23 == 876;
  v27 = (signed int)(v23 - 876) < 0;
  if ( v23 != 876 )
  {
    v29 = _InterlockedExchange(&dword_805B130, v23);
    _InterlockedExchange(&dword_805B130, v24);
    sub_804AFC2(v25, v26, v27, v28, _InterlockedExchange(&dword_805B130, v29), v21);
  }
  __asm { popfw }
  return v33;
}
// 804A7A8: could not find valid save-restore pair for ebp
// 805267A: using guessed type int __fastcall sub_805267A(_DWORD, _DWORD);
// 805B10C: using guessed type int dword_805B10C;
// 805B130: using guessed type int dword_805B130;
// 805B13C: using guessed type int dword_805B13C;

//----- (0804A881) --------------------------------------------------------
signed int sub_804A881()
{
  return 893;
}

//----- (0804A984) --------------------------------------------------------
void sub_804A984()
{
  ;
}

//----- (0804A9D3) --------------------------------------------------------
void __usercall __spoils<edx,ecx> sub_804A9D3(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>)
{
  signed __int32 v6; // ebx
  signed __int32 v7; // ecx
  signed __int32 v8; // ebx
  signed __int32 v9; // et0
  unsigned int v10; // eax
  signed __int32 v11; // edx
  signed __int32 v12; // ecx
  char v17; // al
  signed __int32 v18; // et1
  signed __int32 v19; // eax
  signed __int32 v20; // [esp-Ah] [ebp-Ah]

  __asm { pushfw }
  v6 = _InterlockedExchange(&dword_805B184, a6);
  v9 = _InterlockedExchange(&dword_805B184, a5);
  v7 = v6;
  v8 = v9;
  v10 = sub_80525AB(_CF, _ZF, _SF, _OF, _InterlockedExchange(&dword_805B184, v7), v9);
  _CF = v10 < 0xFFFFFE72;
  _OF = __OFSUB__(v10, -398);
  _ZF = v10 == -398;
  _SF = (signed int)(v10 + 398) < 0;
  if ( v10 != -398 )
  {
    v20 = v10;
    __asm { pushfw }
    if ( v8 >= 10 )
    {
      v18 = _InterlockedExchange(&dword_805B154, v8);
      v17 = _InterlockedExchange(&dword_805B154, v12);
      v12 = _InterlockedExchange(&dword_805B154, v18);
      if ( ((_BYTE)v8 - 1) * v17 & 1 )
        abort();
    }
    __asm { popfw }
    v19 = _InterlockedExchange(&dword_805B184, v20);
    _InterlockedExchange(&dword_805B184, v11);
    sub_805267B(v12, _InterlockedExchange(&dword_805B184, v19));
  }
  __asm { popfw }
}
// 805267B: using guessed type int __fastcall sub_805267B(_DWORD, _DWORD);
// 805B154: using guessed type int dword_805B154;
// 805B184: using guessed type int dword_805B184;

//----- (0804AA55) --------------------------------------------------------
signed int sub_804AA55()
{
  return 4;
}
// 804AA55: could not find valid save-restore pair for ebp

//----- (0804ABB4) --------------------------------------------------------
void __usercall __spoils<edx,ecx> sub_804ABB4(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>)
{
  signed __int32 v6; // ebx
  signed __int32 v7; // edx
  signed __int32 v8; // ebx
  signed __int32 v9; // et0
  signed __int32 v10; // edx
  signed __int32 v11; // ecx
  char v12; // al
  signed __int32 v13; // ebx
  char v14; // t1
  signed __int32 v15; // [esp-10h] [ebp-10h]
  unsigned __int32 v16; // [esp-Ah] [ebp-Ah]

  __asm { pushfw }
  v6 = _InterlockedExchange(&dword_805B190, a6);
  v9 = _InterlockedExchange(&dword_805B190, a5);
  v7 = v6;
  v8 = v9;
  _InterlockedExchange(&dword_805B190, v7);
  v16 = sub_804ADD8();
  __asm { pushfw }
  v15 = v9;
  if ( v9 >= 10 )
  {
    v12 = v8;
    v13 = _InterlockedExchange(&dword_805B130, v8);
    v14 = _InterlockedExchange(&dword_805B130, v10);
    _InterlockedExchange(&dword_805B130, v13);
    if ( (v14 - 1) * v12 & 1 )
      abort();
  }
  __asm { popfw }
  if ( v16 != 449 )
    sub_804ADE2(
      v16 < 0x1C1,
      v16 == 449,
      (signed int)(v16 - 449) < 0,
      __OFSUB__(v16, 449),
      _InterlockedExchange(&dword_805B190, v11),
      _InterlockedExchange(&dword_805B190, _InterlockedExchange(&dword_805B190, v16)),
      v15);
  __asm { popfw }
}
// 805B130: using guessed type int dword_805B130;
// 805B190: using guessed type int dword_805B190;

//----- (0804AC77) --------------------------------------------------------
void sub_804AC77()
{
  ;
}

//----- (0804AC87) --------------------------------------------------------
int __usercall sub_804AC87@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>)
{
  int result; // eax
  char v7; // al
  signed __int32 v8; // ebx
  char v9; // t0
  int v10; // [esp+18h] [ebp-4h]

  result = &unk_805B21F - &unk_805B21C;
  _CF = (unsigned int)(&unk_805B21F - &unk_805B21C) < 6;
  _OF = __OFSUB__(&unk_805B21F - &unk_805B21C, 6);
  _ZF = &unk_805B21F - &unk_805B21C == 6;
  _SF = &unk_805B21F - &unk_805B21C - 6 < 0;
  if ( (unsigned int)(&unk_805B21F - &unk_805B21C) > 6 )
  {
    v10 = &unk_805B21F - &unk_805B21C;
    __asm { pushfw }
    if ( a2 >= 10 )
    {
      v7 = a2;
      v8 = _InterlockedExchange(&dword_805B16C, a2);
      v9 = _InterlockedExchange(&dword_805B16C, a1);
      _InterlockedExchange(&dword_805B16C, v8);
      if ( (v9 - 1) * v7 & 1 )
        abort();
    }
    __asm { popfw }
    result = 0;
  }
  return result;
}
// 804AC87: could not find valid save-restore pair for ebp
// 80550B6: using guessed type int __fastcall sub_80550B6(_DWORD);
// 805B118: using guessed type int dword_805B118;
// 805B124: using guessed type int dword_805B124;
// 805B16C: using guessed type int dword_805B16C;
// 805B184: using guessed type int dword_805B184;
// 805B19C: using guessed type int dword_805B19C;

//----- (0804ADD8) --------------------------------------------------------
signed int sub_804ADD8()
{
  return 449;
}

//----- (0804ADE2) --------------------------------------------------------
void __usercall __noreturn sub_804ADE2(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>)
{
  char v11; // al
  signed __int32 v12; // et0
  int v13; // eax
  char v14; // al
  signed __int32 v15; // ebx
  char v16; // t1
  char v17; // al
  signed __int32 v18; // et2
  signed __int32 v19; // eax
  signed __int32 v20; // eax
  signed __int32 v21; // edx
  int v22; // ecx
  signed __int32 v23; // eax
  signed __int32 v24; // [esp-Ah] [ebp-Ah]
  signed __int32 v25; // [esp-4h] [ebp-4h]

  v25 = a5;
  __asm { pushfw }
  v24 = a7;
  _CF = (unsigned int)a7 < 0xA;
  _OF = __OFSUB__(a7, 10);
  _ZF = a7 == 10;
  _SF = a7 - 10 < 0;
  if ( a7 >= 10 )
  {
    v12 = _InterlockedExchange(&dword_805B124, a7);
    v11 = _InterlockedExchange(&dword_805B124, a6);
    a6 = _InterlockedExchange(&dword_805B124, v12);
    v13 = (_BYTE)--a7 * v11 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = v13 == 0;
    _SF = v13 < 0;
    if ( v13 )
      abort();
  }
  __asm { pushfw }
  if ( a7 >= 10 )
  {
    v14 = a7;
    v15 = _InterlockedExchange(&dword_805B10C, a7);
    v16 = _InterlockedExchange(&dword_805B10C, a6);
    a6 = _InterlockedExchange(&dword_805B10C, v15);
    if ( (v16 - 1) * v14 & 1 )
      abort();
  }
  __asm
  {
    popfw
    popfw
    pushfw
  }
  if ( v24 >= 10 )
  {
    v18 = _InterlockedExchange(&dword_805B130, v24);
    v17 = _InterlockedExchange(&dword_805B130, a6);
    a6 = _InterlockedExchange(&dword_805B130, v18);
    if ( ((_BYTE)v24 - 1) * v17 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  v19 = _InterlockedExchange(&dword_805B184, v25);
  _InterlockedExchange(&dword_805B184, a6);
  v20 = sub_80525AB(_CF, _ZF, _SF, _OF, _InterlockedExchange(&dword_805B184, v19), v24);
  if ( v20 != -398 )
  {
    v23 = _InterlockedExchange(&dword_805B184, v20);
    _InterlockedExchange(&dword_805B184, v21);
    sub_805267B(v22, _InterlockedExchange(&dword_805B184, v23));
  }
  __asm { popfw }
  __halt();
  JUMPOUT(*(_DWORD *)byte_804AEBD);
}
// 805267B: using guessed type int __fastcall sub_805267B(_DWORD, _DWORD);
// 805B10C: using guessed type int dword_805B10C;
// 805B124: using guessed type int dword_805B124;
// 805B130: using guessed type int dword_805B130;
// 805B184: using guessed type int dword_805B184;

//----- (0804AFB8) --------------------------------------------------------
signed int sub_804AFB8()
{
  return 876;
}

//----- (0804AFC2) --------------------------------------------------------
void __usercall __noreturn sub_804AFC2(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>)
{
  char v6; // al
  signed __int32 v7; // ebx
  signed __int32 v8; // et0
  signed __int32 v9; // edx
  signed __int32 v10; // ebx
  int v11; // eax
  signed __int32 v16; // eax
  signed __int32 v17; // edx
  int v18; // ecx
  signed __int32 v19; // ebx

  __asm { pushfw }
  if ( a6 >= 10 )
  {
    v6 = a6;
    v7 = _InterlockedExchange(&dword_805B118, a6);
    v8 = _InterlockedExchange(&dword_805B118, a5);
    v9 = _InterlockedExchange(&dword_805B118, v7);
    v10 = v8 - 1;
    v11 = ((_BYTE)v8 - 1) * v6 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = v11 == 0;
    _SF = v11 < 0;
    if ( v11 )
    {
      __asm { pushfw }
      v16 = _InterlockedExchange(&dword_805B10C, v11);
      _InterlockedExchange(&dword_805B10C, v9);
      _InterlockedExchange(&dword_805B10C, v16);
      if ( sub_8052466() != -423 )
      {
        v19 = _InterlockedExchange(&dword_805B10C, v10);
        _InterlockedExchange(&dword_805B10C, v17);
        _InterlockedExchange(&dword_805B10C, v19);
        sub_8052470(v18);
      }
      __asm { popfw }
      abort();
    }
  }
  __asm { popfw }
  __halt();
  JUMPOUT(loc_804B036);
}
// 8052470: using guessed type int __fastcall sub_8052470(_DWORD);
// 805B10C: using guessed type int dword_805B10C;
// 805B118: using guessed type int dword_805B118;

//----- (0804B058) --------------------------------------------------------
signed int __usercall sub_804B058@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>)
{
  signed __int32 v6; // ebx
  signed __int32 v7; // eax
  signed __int32 v8; // ecx
  signed __int32 v9; // eax

  __asm { pushfw }
  v6 = _InterlockedExchange(&dword_805B118, a6);
  _InterlockedExchange(&dword_805B118, a5);
  _InterlockedExchange(&dword_805B118, v6);
  v7 = sub_80550AC();
  if ( v7 != 445 )
  {
    v9 = _InterlockedExchange(&dword_805B118, v7);
    _InterlockedExchange(&dword_805B118, v8);
    sub_80550B6(_InterlockedExchange(&dword_805B118, v9));
  }
  __asm { popfw }
  return -812;
}
// 80550B6: using guessed type int __fastcall sub_80550B6(_DWORD);
// 805B118: using guessed type int dword_805B118;

//----- (0804B0A0) --------------------------------------------------------
void __usercall __noreturn sub_804B0A0(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>)
{
  char v7; // al
  signed __int32 v8; // et0
  signed __int32 v9; // ebx
  signed __int32 v10; // eax
  int v11; // edx
  signed __int32 v12; // ecx
  signed __int32 v13; // eax

  __asm { pushfw }
  if ( a7 >= 10 )
  {
    v8 = _InterlockedExchange(&dword_805B130, a7);
    v7 = _InterlockedExchange(&dword_805B130, a6);
    _InterlockedExchange(&dword_805B130, v8);
    if ( ((_BYTE)a7 - 1) * v7 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  v9 = _InterlockedExchange(&dword_805B13C, a7);
  _InterlockedExchange(&dword_805B13C, a5);
  _InterlockedExchange(&dword_805B13C, v9);
  v10 = sub_8052670();
  if ( v10 != -41 )
  {
    v13 = _InterlockedExchange(&dword_805B13C, v10);
    _InterlockedExchange(&dword_805B13C, v12);
    sub_805267A(_InterlockedExchange(&dword_805B13C, v13), v11);
  }
  __asm { popfw }
  __halt();
  JUMPOUT(*(_DWORD *)byte_804B111);
}
// 805267A: using guessed type int __fastcall sub_805267A(_DWORD, _DWORD);
// 805B130: using guessed type int dword_805B130;
// 805B13C: using guessed type int dword_805B13C;

//----- (0804B193) --------------------------------------------------------
void sub_804B193()
{
  ;
}

//----- (0804B260) --------------------------------------------------------
void __usercall __spoils<edx,ecx> sub_804B260(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>)
{
  signed __int32 v7; // eax
  int v8; // edx
  signed __int32 v9; // ecx
  signed __int32 v10; // ebx

  __asm { pushfw }
  v7 = _InterlockedExchange(&dword_805B13C, a5);
  _InterlockedExchange(&dword_805B13C, a6);
  _InterlockedExchange(&dword_805B13C, v7);
  if ( sub_8052670() != -41 )
  {
    v10 = _InterlockedExchange(&dword_805B13C, a7);
    _InterlockedExchange(&dword_805B13C, v9);
    sub_805267A(_InterlockedExchange(&dword_805B13C, v10), v8);
  }
  __asm { popfw }
}
// 805267A: using guessed type int __fastcall sub_805267A(_DWORD, _DWORD);
// 805B13C: using guessed type int dword_805B13C;

//----- (0804B35E) --------------------------------------------------------
int __usercall sub_804B35E@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>)
{
  signed __int32 v7; // eax
  unsigned __int32 v8; // eax
  signed __int32 v9; // edx
  signed __int32 v10; // ecx
  bool v11; // cf
  bool v12; // zf
  bool v13; // sf
  char v14; // of
  signed __int32 v15; // eax
  int v16; // eax
  char v21; // al
  signed __int32 v22; // ebx
  char v23; // t2
  int v25; // [esp+18h] [ebp-4h]

  v25 = a5;
  __asm { pushfw }
  v7 = _InterlockedExchange(&dword_805B16C, a5);
  _InterlockedExchange(&dword_805B16C, a6);
  v8 = sub_804B058(_CF, _ZF, _SF, _OF, _InterlockedExchange(&dword_805B16C, v7), a7);
  v11 = v8 < 0xFFFFFCD4;
  v14 = __OFSUB__(v8, -812);
  v12 = v8 == -812;
  v13 = (signed int)(v8 + 812) < 0;
  if ( v8 != -812 )
  {
    v15 = _InterlockedExchange(&dword_805B16C, v8);
    _InterlockedExchange(&dword_805B16C, v10);
    sub_804B0A0(v11, v12, v13, v14, v9, _InterlockedExchange(&dword_805B16C, v15), a7);
  }
  __asm { popfw }
  v16 = &unk_805B641 - (_UNKNOWN *)&program_invocation_short_name;
  _CF = (unsigned int)(&unk_805B641 - (_UNKNOWN *)&program_invocation_short_name) < 6;
  _OF = __OFSUB__(&unk_805B641 - (_UNKNOWN *)&program_invocation_short_name, 6);
  _ZF = &unk_805B641 - (_UNKNOWN *)&program_invocation_short_name == 6;
  _SF = &unk_805B641 - (_UNKNOWN *)&program_invocation_short_name - 6 < 0;
  if ( (unsigned int)(&unk_805B641 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
  {
    v16 = 0;
    _CF = 0;
    _OF = 0;
    _ZF = 1;
    _SF = 0;
  }
  v25 = v16;
  __asm { pushfw }
  if ( a7 >= 10 )
  {
    v21 = a7;
    v22 = _InterlockedExchange(&dword_805B148, a7);
    v23 = _InterlockedExchange(&dword_805B148, v10);
    _InterlockedExchange(&dword_805B148, v22);
    if ( (v23 - 1) * v21 & 1 )
      abort();
  }
  __asm { popfw }
  return v25;
}
// 804B35E: could not find valid save-restore pair for ebp
// 805B148: using guessed type int dword_805B148;
// 805B16C: using guessed type int dword_805B16C;
// 805B240: using guessed type int program_invocation_short_name;

//----- (0804B51E) --------------------------------------------------------
void sub_804B51E()
{
  ;
}

//----- (0804B522) --------------------------------------------------------
signed int __usercall sub_804B522@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>)
{
  char v8; // al
  signed __int32 v9; // ebx
  char v10; // t0
  signed __int32 v11; // ebx
  signed __int32 v12; // eax
  signed __int32 v13; // eax
  signed __int32 v14; // eax
  signed __int32 v15; // ecx
  signed __int32 v16; // ecx
  signed __int32 v17; // ebx
  signed __int32 v22; // eax
  unsigned int v23; // eax
  signed __int32 v24; // edx
  signed __int32 v25; // ecx
  signed __int32 v26; // ebx
  signed __int32 v27; // et2
  signed __int32 v29; // [esp-Ah] [ebp-Ah]
  unsigned __int32 v30; // [esp-Ah] [ebp-Ah]
  signed __int32 v31; // [esp-4h] [ebp-4h]

  v31 = a5;
  __asm { pushfw }
  v29 = a8;
  if ( a8 >= 10 )
  {
    v8 = a8;
    v9 = _InterlockedExchange(&dword_805B118, a8);
    v10 = _InterlockedExchange(&dword_805B118, a6);
    _InterlockedExchange(&dword_805B118, v9);
    if ( (v10 - 1) * v8 & 1 )
      abort();
  }
  v11 = v29;
  __asm
  {
    popfw
    pushfw
  }
  v12 = _InterlockedExchange(&dword_805B130, v31);
  _InterlockedExchange(&dword_805B130, a7);
  _InterlockedExchange(&dword_805B130, v12);
  v13 = sub_804AFB8();
  v30 = v13;
  __asm { pushfw }
  v14 = _InterlockedExchange(&dword_805B10C, v13);
  _InterlockedExchange(&dword_805B10C, v15);
  _InterlockedExchange(&dword_805B10C, v14);
  if ( sub_8052466() != -423 )
  {
    v17 = _InterlockedExchange(&dword_805B10C, v11);
    _InterlockedExchange(&dword_805B10C, v16);
    sub_8052470(_InterlockedExchange(&dword_805B10C, v17));
  }
  __asm { popfw }
  _CF = v30 < 0x36C;
  _OF = __OFSUB__(v30, 876);
  _ZF = v30 == 876;
  _SF = (signed int)(v30 - 876) < 0;
  if ( v30 != 876 )
  {
    __asm { pushfw }
    v22 = _InterlockedExchange(&dword_805B124, v30);
    _InterlockedExchange(&dword_805B124, v16);
    _InterlockedExchange(&dword_805B124, v22);
    v23 = sub_805194D();
    if ( v23 != 44 )
      sub_8051957(
        v23 < 0x2C,
        v23 == 44,
        (signed int)(v23 - 44) < 0,
        __OFSUB__(v23, 44),
        _InterlockedExchange(&dword_805B124, _InterlockedExchange(&dword_805B124, v11)),
        _InterlockedExchange(&dword_805B124, v24));
    __asm { popfw }
    v26 = _InterlockedExchange(&dword_805B130, v11);
    v27 = _InterlockedExchange(&dword_805B130, v25);
    _InterlockedExchange(&dword_805B130, v26);
    sub_804AFC2(_CF, _ZF, _SF, _OF, v24, v27);
  }
  __asm { popfw }
  return -958;
}
// 804B522: could not find valid save-restore pair for ebx
// 8052470: using guessed type int __fastcall sub_8052470(_DWORD);
// 805B10C: using guessed type int dword_805B10C;
// 805B118: using guessed type int dword_805B118;
// 805B124: using guessed type int dword_805B124;
// 805B130: using guessed type int dword_805B130;

//----- (0804B619) --------------------------------------------------------
void __usercall __noreturn sub_804B619(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>)
{
  char v6; // al
  signed __int32 v7; // et0

  __asm { pushfw }
  if ( a6 >= 10 )
  {
    v7 = _InterlockedExchange(&dword_805B13C, a6);
    v6 = _InterlockedExchange(&dword_805B13C, a5);
    _InterlockedExchange(&dword_805B13C, v7);
    if ( ((_BYTE)a6 - 1) * v6 & 1 )
      abort();
  }
  __asm { popfw }
  __halt();
  JUMPOUT(*(_DWORD *)byte_804B64E);
}
// 805B13C: using guessed type int dword_805B13C;

//----- (0804B699) --------------------------------------------------------
int __usercall sub_804B699@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>)
{
  signed __int32 v7; // ebx
  signed __int32 v8; // ecx
  signed __int32 v9; // ebx
  signed __int32 v10; // et0
  signed __int32 v11; // eax
  signed __int32 v12; // edx
  signed __int32 v13; // ecx
  signed __int32 v14; // eax
  int v15; // eax
  char v20; // al
  signed __int32 v21; // et2
  signed __int32 v22; // eax
  signed __int32 v23; // ecx
  signed __int32 v24; // ebx
  int v26; // [esp-4h] [ebp-4h]

  v26 = a5;
  __asm { pushfw }
  v7 = _InterlockedExchange(&dword_805B13C, a7);
  v10 = _InterlockedExchange(&dword_805B13C, a6);
  v8 = v7;
  v9 = v10;
  _InterlockedExchange(&dword_805B13C, v8);
  v11 = sub_8052670();
  if ( v11 != -41 )
  {
    v14 = _InterlockedExchange(&dword_805B13C, v11);
    _InterlockedExchange(&dword_805B13C, v13);
    sub_805267A(_InterlockedExchange(&dword_805B13C, v14), v12);
  }
  __asm { popfw }
  v15 = v26;
  __asm { pushfw }
  _CF = (unsigned int)v9 < 0xA;
  _OF = __OFSUB__(v9, 10);
  _ZF = v9 == 10;
  _SF = v9 - 10 < 0;
  if ( v9 >= 10 )
  {
    v21 = _InterlockedExchange(&dword_805B160, v9);
    v20 = _InterlockedExchange(&dword_805B160, v13);
    _InterlockedExchange(&dword_805B160, v21);
    v15 = (_BYTE)--v9 * v20 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = v15 == 0;
    _SF = v15 < 0;
    if ( v15 )
      abort();
  }
  __asm { pushfw }
  v22 = _InterlockedExchange(&dword_805B10C, v15);
  _InterlockedExchange(&dword_805B10C, v12);
  _InterlockedExchange(&dword_805B10C, v22);
  if ( sub_8052466() != -423 )
  {
    v24 = _InterlockedExchange(&dword_805B10C, v9);
    _InterlockedExchange(&dword_805B10C, v23);
    sub_8052470(_InterlockedExchange(&dword_805B10C, v24));
  }
  __asm
  {
    popfw
    popfw
  }
  return v26;
}
// 8052470: using guessed type int __fastcall sub_8052470(_DWORD);
// 805267A: using guessed type int __fastcall sub_805267A(_DWORD, _DWORD);
// 805B10C: using guessed type int dword_805B10C;
// 805B13C: using guessed type int dword_805B13C;
// 805B160: using guessed type int dword_805B160;

//----- (0804B78C) --------------------------------------------------------
int __usercall sub_804B78C@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>)
{
  int v2; // eax
  char v7; // al
  signed __int32 v8; // et0
  int v10; // [esp+18h] [ebp-4h]

  v2 = &unk_805B651 - (_UNKNOWN *)&program_invocation_name;
  _CF = (unsigned int)(&unk_805B651 - (_UNKNOWN *)&program_invocation_name) < 6;
  _OF = __OFSUB__(&unk_805B651 - (_UNKNOWN *)&program_invocation_name, 6);
  _ZF = &unk_805B651 - (_UNKNOWN *)&program_invocation_name == 6;
  _SF = &unk_805B651 - (_UNKNOWN *)&program_invocation_name - 6 < 0;
  if ( (unsigned int)(&unk_805B651 - (_UNKNOWN *)&program_invocation_name) > 6 )
  {
    v2 = 0;
    _CF = 0;
    _OF = 0;
    _ZF = 1;
    _SF = 0;
  }
  v10 = v2;
  __asm { pushfw }
  if ( a2 >= 10 )
  {
    v8 = _InterlockedExchange(&dword_805B160, a2);
    v7 = _InterlockedExchange(&dword_805B160, a1);
    _InterlockedExchange(&dword_805B160, v8);
    if ( ((_BYTE)a2 - 1) * v7 & 1 )
      abort();
  }
  __asm { popfw }
  return v10;
}
// 804B78C: could not find valid save-restore pair for ebp
// 805B160: using guessed type int dword_805B160;
// 805B250: using guessed type int program_invocation_name;

//----- (0804B8E6) --------------------------------------------------------
int __usercall sub_804B8E6@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>, __int64 a7)
{
  signed __int32 v7; // ebx
  signed __int32 v8; // edx
  signed __int32 v9; // ebx
  signed __int32 v10; // et0
  unsigned __int32 v11; // eax
  signed __int32 v12; // edx
  signed __int32 v13; // ecx
  signed __int32 v18; // eax
  signed __int32 v19; // et1
  char v20; // al
  signed __int32 v21; // ebx
  char v22; // t2
  signed __int32 v23; // eax
  signed __int32 v24; // eax
  signed __int32 v25; // edx
  int v26; // ecx
  signed __int32 v27; // eax
  int result; // eax
  signed __int32 v29; // [esp+1Ch] [ebp-10h]

  __asm { pushfw }
  v7 = _InterlockedExchange(&dword_805B19C, a6);
  v10 = _InterlockedExchange(&dword_805B19C, a5);
  v8 = v7;
  v9 = v10;
  _InterlockedExchange(&dword_805B19C, v8);
  v11 = sub_8054E13();
  _CF = v11 < 0x390;
  _OF = __OFSUB__(v11, 912);
  _ZF = v11 == 912;
  _SF = (signed int)(v11 - 912) < 0;
  if ( v11 != 912 )
  {
    v19 = _InterlockedExchange(&dword_805B19C, v11);
    v18 = _InterlockedExchange(&dword_805B19C, v12);
    _InterlockedExchange(&dword_805B19C, v19);
    sub_8054E1D(_CF, _ZF, _SF, _OF, v18, v13, v9);
  }
  __asm { pushfw }
  v29 = v9;
  if ( v9 >= 10 )
  {
    v20 = v9;
    v21 = _InterlockedExchange(&dword_805B10C, v9);
    v22 = _InterlockedExchange(&dword_805B10C, v12);
    v12 = _InterlockedExchange(&dword_805B10C, v21);
    if ( (v22 - 1) * v20 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  v23 = _InterlockedExchange(&dword_805B148, 912);
  _InterlockedExchange(&dword_805B148, v12);
  _InterlockedExchange(&dword_805B148, v23);
  v24 = sub_80537D9();
  if ( v24 != 862 )
  {
    v27 = _InterlockedExchange(&dword_805B148, v24);
    _InterlockedExchange(&dword_805B148, v25);
    sub_80537E3(v26, _InterlockedExchange(&dword_805B148, v27));
  }
  __asm
  {
    popfw
    popfw
  }
  if ( HIDWORD(a7) )
    result = sub_8055239(v29, a7, 0xF4240u, 0) + 1000000;
  else
    result = a7;
  return result;
}
// 804B8E6: could not find valid save-restore pair for ebp
// 80537E3: using guessed type int __fastcall sub_80537E3(_DWORD, _DWORD);
// 805B10C: using guessed type int dword_805B10C;
// 805B148: using guessed type int dword_805B148;
// 805B19C: using guessed type int dword_805B19C;

//----- (0804BA0B) --------------------------------------------------------
unsigned int __cdecl sub_804BA0B(int a1, unsigned int a2)
{
  return a2 - 1 + a1 - (a2 - 1 + a1) % a2;
}

//----- (0804BA3D) --------------------------------------------------------
int __usercall sub_804BA3D@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>)
{
  signed __int32 v7; // eax
  signed __int32 v8; // eax
  signed __int32 v9; // edx
  signed __int32 v10; // ecx
  signed __int32 v11; // eax
  char v12; // al
  signed __int32 v13; // et2
  signed __int32 v14; // ebx
  char v15; // tt
  char v16; // al
  signed __int32 v17; // et0
  signed __int32 v18; // ebx
  signed __int32 v23; // ebx
  signed __int32 v24; // et1
  int v25; // eax
  char v26; // al
  signed __int32 v27; // et2
  signed __int32 v28; // ebx
  char v29; // tt
  FILE *v30; // ebx
  signed __int32 v31; // ebx
  signed __int32 v32; // ecx
  signed __int32 v33; // ecx
  signed __int32 v34; // ebx
  signed __int32 v35; // et0
  unsigned __int32 v36; // eax
  signed __int32 v37; // ecx
  char *v39; // [esp-4h] [ebp-20h]
  signed __int32 v40; // [esp+12h] [ebp-Ah]
  int v41; // [esp+18h] [ebp-4h]

  v41 = a5;
  __asm { pushfw }
  v7 = _InterlockedExchange(&dword_805B118, a5);
  _InterlockedExchange(&dword_805B118, a6);
  _InterlockedExchange(&dword_805B118, v7);
  v8 = sub_80550AC();
  if ( v8 != 445 )
  {
    v11 = _InterlockedExchange(&dword_805B118, v8);
    _InterlockedExchange(&dword_805B118, v9);
    _InterlockedExchange(&dword_805B118, v11);
    sub_80550B6(v10);
  }
  __asm
  {
    popfw
    pushfw
  }
  v40 = a7;
  if ( a7 >= 10 )
  {
    v13 = _InterlockedExchange(&dword_805B13C, a7);
    v12 = _InterlockedExchange(&dword_805B13C, v10);
    v10 = _InterlockedExchange(&dword_805B13C, v13);
    if ( ((_BYTE)a7 - 1) * v12 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( a7 >= 10 )
  {
    v14 = _InterlockedExchange(&dword_805B148, a7);
    v15 = _InterlockedExchange(&dword_805B148, v10);
    v10 = _InterlockedExchange(&dword_805B148, v14);
    if ( (v15 - 1) * (_BYTE)v40 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( v40 >= 10 )
  {
    v17 = _InterlockedExchange(&dword_805B178, v40);
    v16 = _InterlockedExchange(&dword_805B178, v10);
    v10 = _InterlockedExchange(&dword_805B178, v17);
    if ( ((_BYTE)v40 - 1) * v16 & 1 )
      abort();
  }
  v18 = v40;
  __asm
  {
    popfw
    pushfw
  }
  _CF = (unsigned int)v40 < 0xA;
  _OF = __OFSUB__(v40, 10);
  _ZF = v40 == 10;
  _SF = v40 - 10 < 0;
  if ( v40 >= 10 )
  {
    v23 = _InterlockedExchange(&dword_805B184, v40);
    v24 = _InterlockedExchange(&dword_805B184, v9);
    v9 = _InterlockedExchange(&dword_805B184, v23);
    v18 = v24 - 1;
    v25 = ((_BYTE)v24 - 1) * (_BYTE)v40 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = v25 == 0;
    _SF = v25 < 0;
    if ( ((_BYTE)v24 - 1) * (_BYTE)v40 & 1 )
      abort();
  }
  __asm { pushfw }
  if ( v18 >= 10 )
  {
    v27 = _InterlockedExchange(&dword_805B178, v18);
    v26 = _InterlockedExchange(&dword_805B178, v10);
    _InterlockedExchange(&dword_805B178, v27);
    if ( ((_BYTE)v18 - 1) * v26 & 1 )
      abort();
  }
  __asm
  {
    popfw
    popfw
    pushfw
  }
  if ( v40 >= 10 )
  {
    v28 = _InterlockedExchange(&dword_805B19C, v40);
    v29 = _InterlockedExchange(&dword_805B19C, v9);
    _InterlockedExchange(&dword_805B19C, v28);
    if ( (v29 - 1) * (_BYTE)v40 & 1 )
      abort();
  }
  __asm { popfw }
  v30 = stdout;
  v39 = gettext("\nWith no FILE, or when FILE is -, read standard input.\n");
  __asm { pushfw }
  v31 = _InterlockedExchange(&dword_805B19C, (signed __int32)v30);
  v35 = _InterlockedExchange(&dword_805B19C, v32);
  v33 = v31;
  v34 = v35;
  _InterlockedExchange(&dword_805B19C, v33);
  v36 = sub_8054E13();
  if ( v36 != 912 )
    sub_8054E1D(
      v36 < 0x390,
      v36 == 912,
      (signed int)(v36 - 912) < 0,
      __OFSUB__(v36, 912),
      v36,
      _InterlockedExchange(&dword_805B19C, _InterlockedExchange(&dword_805B19C, v34)),
      _InterlockedExchange(&dword_805B19C, v37));
  __asm { popfw }
  return fputs_unlocked(v39, v34);
}
// 8048F20: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 80550B6: using guessed type int __fastcall sub_80550B6(_DWORD);
// 805B118: using guessed type int dword_805B118;
// 805B13C: using guessed type int dword_805B13C;
// 805B148: using guessed type int dword_805B148;
// 805B178: using guessed type int dword_805B178;
// 805B184: using guessed type int dword_805B184;
// 805B19C: using guessed type int dword_805B19C;

//----- (0804BC1F) --------------------------------------------------------
int __usercall sub_804BC1F@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, char *s1)
{
  signed __int32 v8; // ebx
  signed __int32 v9; // edx
  signed __int32 v10; // et0
  int v11; // edx
  signed __int32 v12; // ecx
  signed __int32 v13; // ebx
  const char *v14; // eax
  char v19; // al
  signed __int32 v20; // et2
  char *v21; // eax
  signed __int32 v22; // edx
  char v23; // al
  signed __int32 v24; // ett
  char *v25; // eax
  char *v26; // eax
  char *v27; // ebx
  char *v28; // eax
  char *v30; // [esp+1Ch] [ebp-4Ch]
  const char **i; // [esp+20h] [ebp-48h]
  const char *v32; // [esp+24h] [ebp-44h]
  const char *v33; // [esp+28h] [ebp-40h]
  const char *v34; // [esp+2Ch] [ebp-3Ch]
  const char *v35; // [esp+30h] [ebp-38h]
  const char *v36; // [esp+34h] [ebp-34h]
  const char *v37; // [esp+38h] [ebp-30h]
  const char *v38; // [esp+3Ch] [ebp-2Ch]
  const char *v39; // [esp+40h] [ebp-28h]
  const char *v40; // [esp+44h] [ebp-24h]
  const char *v41; // [esp+48h] [ebp-20h]
  const char *v42; // [esp+4Ch] [ebp-1Ch]
  const char *v43; // [esp+50h] [ebp-18h]
  const char *v44; // [esp+54h] [ebp-14h]
  int v45; // [esp+58h] [ebp-10h]
  int v46; // [esp+5Ch] [ebp-Ch]

  v33 = "[";
  v34 = "test invocation";
  v35 = "coreutils";
  v36 = "Multi-call invocation";
  v37 = "sha224sum";
  v38 = "sha2 utilities";
  v39 = "sha256sum";
  v40 = "sha2 utilities";
  v41 = "sha384sum";
  v42 = "sha2 utilities";
  v43 = "sha512sum";
  v44 = "sha2 utilities";
  v45 = 0;
  v46 = 0;
  v30 = s1;
  for ( i = &v33; ; i += 2 )
  {
    _CF = 0;
    _OF = 0;
    _ZF = *i == 0;
    _SF = (signed int)*i < 0;
    if ( !*i )
      break;
    __asm { pushfw }
    v8 = _InterlockedExchange(&dword_805B13C, a3);
    v10 = _InterlockedExchange(&dword_805B13C, a1);
    v9 = v8;
    a3 = v10;
    _InterlockedExchange(&dword_805B13C, v9);
    if ( sub_8052670() != -41 )
    {
      v13 = _InterlockedExchange(&dword_805B13C, a3);
      _InterlockedExchange(&dword_805B13C, v12);
      sub_805267A(_InterlockedExchange(&dword_805B13C, v13), v11);
    }
    __asm { popfw }
    if ( !strcmp(s1, *i) )
      break;
  }
  v14 = i[1];
  _CF = 0;
  _OF = 0;
  _ZF = v14 == 0;
  _SF = (signed int)v14 < 0;
  if ( v14 )
  {
    __asm { pushfw }
    if ( a3 >= 10 )
    {
      v20 = _InterlockedExchange(&dword_805B19C, a3);
      v19 = _InterlockedExchange(&dword_805B19C, a2);
      _InterlockedExchange(&dword_805B19C, v20);
      if ( ((_BYTE)a3 - 1) * v19 & 1 )
        abort();
    }
    __asm { popfw }
    v30 = (char *)i[1];
  }
  v21 = gettext("\n%s online help: <%s>\n");
  printf(v21, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  __asm { pushfw }
  if ( a3 >= 10 )
  {
    v24 = _InterlockedExchange(&dword_805B154, a3);
    v23 = _InterlockedExchange(&dword_805B154, v22);
    _InterlockedExchange(&dword_805B154, v24);
    if ( ((_BYTE)a3 - 1) * v23 & 1 )
      abort();
  }
  __asm { popfw }
  v32 = setlocale(5, 0);
  if ( v32 && strncmp(v32, "en_", 3u) )
  {
    v25 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
    printf(v25, s1);
  }
  v26 = gettext("Full documentation at: <%s%s>\n");
  printf(v26, "http://www.gnu.org/software/coreutils/", s1);
  if ( v30 == s1 )
    v27 = " invocation";
  else
    v27 = &locale;
  v28 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  return printf(v28, v30, v27);
}
// 805267A: using guessed type int __fastcall sub_805267A(_DWORD, _DWORD);
// 805B13C: using guessed type int dword_805B13C;
// 805B154: using guessed type int dword_805B154;
// 805B19C: using guessed type int dword_805B19C;

//----- (0804BE4A) --------------------------------------------------------
int __cdecl sub_804BE4A(int a1)
{
  return a1;
}

//----- (0804BE52) --------------------------------------------------------
void __usercall __noreturn sub_804BE52(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, int a9)
{
  char v9; // al
  signed __int32 v10; // ebx
  char v11; // t0
  signed __int32 v12; // eax
  unsigned int v13; // eax
  signed __int32 v14; // edx
  signed __int32 v15; // ecx
  signed __int32 v16; // eax
  unsigned int v17; // eax
  signed __int32 v18; // edx
  signed __int32 v19; // ecx
  signed __int32 v24; // ebx
  signed __int32 v25; // ecx
  signed __int32 v26; // ebx
  signed __int32 v27; // et1
  unsigned __int32 v28; // eax
  signed __int32 v29; // edx
  signed __int32 v30; // ecx
  bool v31; // cf
  bool v32; // zf
  bool v33; // sf
  char v34; // of
  signed __int32 v35; // eax
  signed __int32 v36; // ebx
  signed __int32 v37; // ecx
  signed __int32 v38; // ebx
  signed __int32 v39; // ett
  unsigned __int32 v40; // eax
  signed __int32 v41; // edx
  signed __int32 v42; // ecx
  signed __int32 v43; // ebx
  signed __int32 v44; // et0
  char v49; // al
  signed __int32 v50; // ebx
  char v51; // t1
  int v52; // ebx
  char *format; // eax
  signed __int32 v54; // ebx
  char *v55; // eax
  int v56; // eax
  signed __int32 v57; // edx
  FILE *v58; // ebx
  char *v59; // eax
  char *v60; // eax
  FILE *v61; // ebx
  char *v62; // eax
  FILE *v63; // ebx
  char *v64; // eax
  FILE *v65; // ebx
  char *v66; // eax
  signed __int32 v67; // eax
  signed __int32 v68; // ecx
  signed __int32 v69; // eax
  signed __int32 v70; // ecx
  signed __int32 v71; // eax
  FILE *v72; // ebx
  char *v73; // eax
  FILE *v74; // ebx
  char *v75; // eax
  char *v76; // eax
  signed __int32 v77; // edx
  signed __int32 v78; // ecx
  char *v79; // [esp-4h] [ebp-20h]
  signed __int32 v80; // [esp+12h] [ebp-Ah]
  int v81; // [esp+18h] [ebp-4h]

  v81 = a5;
  __asm { pushfw }
  v80 = a8;
  if ( a8 >= 10 )
  {
    v9 = a8;
    v10 = _InterlockedExchange(&dword_805B10C, a8);
    v11 = _InterlockedExchange(&dword_805B10C, a7);
    _InterlockedExchange(&dword_805B10C, v10);
    if ( (v11 - 1) * v9 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  v12 = _InterlockedExchange(&dword_805B124, v81);
  _InterlockedExchange(&dword_805B124, a6);
  _InterlockedExchange(&dword_805B124, v12);
  v13 = sub_805194D();
  if ( v13 != 44 )
    sub_8051957(
      v13 < 0x2C,
      v13 == 44,
      (signed int)(v13 - 44) < 0,
      __OFSUB__(v13, 44),
      _InterlockedExchange(&dword_805B124, _InterlockedExchange(&dword_805B124, v80)),
      _InterlockedExchange(&dword_805B124, v14));
  __asm
  {
    popfw
    pushfw
  }
  v16 = _InterlockedExchange(&dword_805B16C, v81);
  _InterlockedExchange(&dword_805B16C, v15);
  v17 = sub_804B058(_CF, _ZF, _SF, _OF, _InterlockedExchange(&dword_805B16C, v16), v80);
  _CF = v17 < 0xFFFFFCD4;
  _OF = __OFSUB__(v17, -812);
  _ZF = v17 == -812;
  _SF = (signed int)(v17 + 812) < 0;
  if ( v17 != -812 )
    sub_804B0A0(
      v17 < 0xFFFFFCD4,
      v17 == -812,
      (signed int)(v17 + 812) < 0,
      __OFSUB__(v17, -812),
      _InterlockedExchange(&dword_805B16C, _InterlockedExchange(&dword_805B16C, v80)),
      v19,
      _InterlockedExchange(&dword_805B16C, v18));
  __asm { pushfw }
  v24 = _InterlockedExchange(&dword_805B130, v80);
  v27 = _InterlockedExchange(&dword_805B130, v19);
  v25 = v24;
  v26 = v27;
  _InterlockedExchange(&dword_805B130, v25);
  v28 = sub_804AFB8();
  v31 = v28 < 0x36C;
  v34 = __OFSUB__(v28, 876);
  v32 = v28 == 876;
  v33 = (signed int)(v28 - 876) < 0;
  if ( v28 != 876 )
  {
    v35 = _InterlockedExchange(&dword_805B130, v28);
    _InterlockedExchange(&dword_805B130, v30);
    _InterlockedExchange(&dword_805B130, v35);
    sub_804AFC2(v31, v32, v33, v34, v29, v26);
  }
  __asm
  {
    popfw
    popfw
    pushfw
  }
  v36 = _InterlockedExchange(&dword_805B190, v26);
  v39 = _InterlockedExchange(&dword_805B190, v30);
  v37 = v36;
  v38 = v39;
  _InterlockedExchange(&dword_805B190, v37);
  v40 = sub_804ADD8();
  if ( v40 != 449 )
  {
    v43 = _InterlockedExchange(&dword_805B190, v38);
    v44 = _InterlockedExchange(&dword_805B190, v41);
    _InterlockedExchange(&dword_805B190, v43);
    sub_804ADE2(v40 < 0x1C1, v40 == 449, (signed int)(v40 - 449) < 0, __OFSUB__(v40, 449), v40, v42, v44);
  }
  __asm { popfw }
  _CF = 0;
  _OF = 0;
  _ZF = a9 == 0;
  _SF = a9 < 0;
  if ( a9 )
  {
    __asm { pushfw }
    if ( v38 >= 10 )
    {
      v49 = v38;
      v50 = _InterlockedExchange(&dword_805B184, v38);
      v51 = _InterlockedExchange(&dword_805B184, v41);
      _InterlockedExchange(&dword_805B184, v50);
      if ( (v51 - 1) * v49 & 1 )
        abort();
    }
    __asm { popfw }
    v52 = dword_805B6EF;
    format = gettext("Try '%s --help' for more information.\n");
    fprintf(stderr, format, v52);
  }
  else
  {
    v54 = dword_805B6EF;
    v55 = gettext("Usage: %s [OPTION]... [FILE]...\nPrint or check %s (%d-bit) checksums.\n");
    v56 = printf(v55, v54, "MD5", 128);
    sub_804BA3D(_CF, _ZF, _SF, _OF, v56, v57, v54);
    v58 = stdout;
    v59 = gettext("\n  -b, --binary         read in binary mode\n");
    fputs_unlocked(v59, v58);
    v60 = gettext("  -c, --check          read %s sums from the FILEs and check them\n");
    printf(v60, "MD5");
    v61 = stdout;
    v62 = gettext("      --tag            create a BSD-style checksum\n");
    fputs_unlocked(v62, v61);
    v63 = stdout;
    v64 = gettext("  -t, --text           read in text mode (default)\n");
    fputs_unlocked(v64, v63);
    v65 = stdout;
    v66 = gettext(
            "\n"
            "The following five options are useful only when verifying checksums:\n"
            "      --ignore-missing  don't fail or report status for missing files\n"
            "      --quiet          don't print OK for each successfully verified file\n"
            "      --status         don't output anything, status code shows success\n"
            "      --strict         exit non-zero for improperly formatted checksum lines\n"
            "  -w, --warn           warn about improperly formatted checksum lines\n"
            "\n");
    v79 = v66;
    __asm { pushfw }
    v67 = _InterlockedExchange(&dword_805B178, (signed __int32)v66);
    _InterlockedExchange(&dword_805B178, v68);
    _InterlockedExchange(&dword_805B178, v67);
    v69 = sub_804A881();
    if ( v69 != 893 )
    {
      v71 = _InterlockedExchange(&dword_805B178, v69);
      _InterlockedExchange(&dword_805B178, v70);
      sub_804A88B(_InterlockedExchange(&dword_805B178, v71));
    }
    __asm { popfw }
    fputs_unlocked(v79, v65);
    v72 = stdout;
    v73 = gettext("      --help     display this help and exit\n");
    fputs_unlocked(v73, v72);
    v74 = stdout;
    v75 = gettext("      --version  output version information and exit\n");
    fputs_unlocked(v75, v74);
    v76 = gettext(
            "\n"
            "The sums are computed as described in %s.  When checking, the input\n"
            "should be a former output of this program.  The default mode is to print a\n"
            "line with checksum, a space, a character indicating input mode ('*' for binary,\n"
            "' ' for text or where binary is insignificant), and name for each FILE.\n");
    printf(v76, "RFC 1321");
    sub_804BC1F(v77, v78, (signed __int32)v74, "md5sum");
  }
  exit(a9);
}
// 8048F20: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 804A88B: using guessed type int __fastcall sub_804A88B(_DWORD);
// 805B10C: using guessed type int dword_805B10C;
// 805B124: using guessed type int dword_805B124;
// 805B130: using guessed type int dword_805B130;
// 805B16C: using guessed type int dword_805B16C;
// 805B178: using guessed type int dword_805B178;
// 805B184: using guessed type int dword_805B184;
// 805B190: using guessed type int dword_805B190;
// 805B6EF: using guessed type int dword_805B6EF;

//----- (0804C168) --------------------------------------------------------
signed __int32 __usercall sub_804C168@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, signed __int32 a3, unsigned int a4)
{
  signed __int32 v4; // edx
  int v5; // eax
  signed __int32 v10; // eax
  unsigned __int32 v11; // eax
  _BYTE *v16; // eax
  _BYTE *v17; // eax
  signed __int32 v18; // eax
  signed __int32 v19; // ecx
  signed __int32 v20; // ebx
  _BYTE *v21; // eax
  signed __int32 v22; // edx
  unsigned __int32 v23; // eax
  signed __int32 v24; // ecx
  bool v25; // cf
  bool v26; // zf
  bool v27; // sf
  char v28; // of
  signed __int32 v29; // eax
  char v30; // al
  signed __int32 v31; // ebx
  char v32; // t0
  signed __int32 v34; // [esp-4h] [ebp-14h]
  _BYTE *v35; // [esp+8h] [ebp-8h]
  unsigned int i; // [esp+Ch] [ebp-4h]

  v35 = (_BYTE *)a3;
  for ( i = 0; ; ++i )
  {
    if ( i >= a4 )
    {
      v4 = a3;
      _CF = a3 + a4 < (unsigned int)v35;
      _OF = __OFSUB__(a3 + a4, v35);
      _ZF = a3 + a4 == (_DWORD)v35;
      _SF = (signed int)(a3 + a4 - (_DWORD)v35) < 0;
      if ( a3 + a4 > (unsigned int)v35 )
      {
        __asm { pushfw }
        v22 = _InterlockedExchange(&dword_805B130, a2);
        a2 = _InterlockedExchange(&dword_805B130, a3);
        _InterlockedExchange(&dword_805B130, v22);
        v23 = sub_804AFB8();
        v25 = v23 < 0x36C;
        v28 = __OFSUB__(v23, 876);
        v26 = v23 == 876;
        v27 = (signed int)(v23 - 876) < 0;
        if ( v23 != 876 )
        {
          v29 = _InterlockedExchange(&dword_805B130, v23);
          _InterlockedExchange(&dword_805B130, v24);
          _InterlockedExchange(&dword_805B130, v29);
          sub_804AFC2(v25, v26, v27, v28, v4, a2);
        }
        __asm { popfw }
        *v35 = 0;
      }
      v10 = a3;
      goto LABEL_23;
    }
    v4 = a3;
    v5 = *(char *)(a3 + i);
    _CF = 0;
    _OF = 0;
    _ZF = v5 == 0;
    _SF = v5 < 0;
    if ( !*(_BYTE *)(a3 + i) )
    {
      v10 = 0;
      goto LABEL_23;
    }
    if ( v5 != 92 )
    {
      v21 = v35++;
      a1 = a3;
      *v21 = *(_BYTE *)(a3 + i);
      continue;
    }
    _CF = a4 - 1 < i;
    _OF = __OFSUB__(a4 - 1, i);
    _ZF = a4 - 1 == i;
    _SF = (signed int)(a4 - 1 - i) < 0;
    if ( a4 - 1 == i )
    {
      v10 = 0;
      goto LABEL_23;
    }
    v11 = *(char *)(a3 + ++i);
    if ( v11 != 92 )
      break;
    v17 = v35++;
    *v17 = 92;
LABEL_13:
    ;
  }
  _CF = v11 < 0x6E;
  _OF = __OFSUB__(v11, 110);
  _ZF = v11 == 110;
  _SF = (signed int)(v11 - 110) < 0;
  if ( v11 == 110 )
  {
    v16 = v35++;
    *v16 = 10;
    goto LABEL_13;
  }
  __asm { pushfw }
  v18 = _InterlockedExchange(&dword_805B178, v11);
  _InterlockedExchange(&dword_805B178, a1);
  _InterlockedExchange(&dword_805B178, v18);
  if ( sub_804A881() != 893 )
  {
    v20 = _InterlockedExchange(&dword_805B178, a2);
    _InterlockedExchange(&dword_805B178, v19);
    sub_804A88B(_InterlockedExchange(&dword_805B178, v20));
  }
  __asm { popfw }
  v10 = 0;
LABEL_23:
  v34 = v10;
  __asm { pushfw }
  if ( a2 >= 10 )
  {
    v30 = a2;
    v31 = _InterlockedExchange(&dword_805B148, a2);
    v32 = _InterlockedExchange(&dword_805B148, v4);
    _InterlockedExchange(&dword_805B148, v31);
    if ( (v32 - 1) * v30 & 1 )
      abort();
  }
  __asm { popfw }
  return v34;
}
// 804A88B: using guessed type int __fastcall sub_804A88B(_DWORD);
// 805B130: using guessed type int dword_805B130;
// 805B148: using guessed type int dword_805B148;
// 805B178: using guessed type int dword_805B178;

//----- (0804C330) --------------------------------------------------------
bool __usercall sub_804C330@<al>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>, _BYTE *a3)
{
  const unsigned __int16 **v7; // eax
  signed __int32 v8; // ecx
  int v9; // eax
  char v18; // al
  signed __int32 v19; // et0
  int v20; // eax
  char v21; // al
  signed __int32 v22; // et1
  signed __int32 v23; // ebx
  signed __int32 v24; // ecx
  signed __int32 v25; // ebx
  signed __int32 v26; // et2
  signed __int32 v27; // eax
  signed __int32 v28; // eax
  signed __int32 v29; // edx
  signed __int32 v30; // eax
  signed __int32 v31; // edx
  signed __int32 v32; // ecx
  signed __int32 v33; // eax
  signed __int32 v34; // eax
  char v36; // al
  signed __int32 v37; // et2
  unsigned __int32 v38; // [esp-14h] [ebp-2Ch]
  unsigned int i; // [esp+Ch] [ebp-Ch]

  _CF = 0;
  _ZF = 0;
  _OF = 0;
  for ( i = 0; ; ++i )
  {
    __asm { pushfw }
    if ( a2 >= 10 )
    {
      v37 = _InterlockedExchange(&dword_805B148, a2);
      v36 = _InterlockedExchange(&dword_805B148, a1);
      _InterlockedExchange(&dword_805B148, v37);
      if ( ((_BYTE)a2 - 1) * v36 & 1 )
        abort();
    }
    __asm { popfw }
    if ( i >= dword_805B6DB )
      return *a3 == 0;
    v7 = __ctype_b_loc();
    a1 = (signed __int32)*v7;
    v9 = (*v7)[(unsigned __int8)*a3] & 0x1000;
    _CF = 0;
    _OF = 0;
    _ZF = v9 == 0;
    _SF = v9 < 0;
    if ( !v9 )
      break;
    ++a3;
    _CF = __CFADD__(i, 1);
    _OF = __OFADD__(1, i);
    _ZF = i == -1;
    _SF = (signed int)(i + 1) < 0;
  }
  __asm { pushfw }
  _CF = (unsigned int)a2 < 0xA;
  _OF = __OFSUB__(a2, 10);
  _ZF = a2 == 10;
  _SF = a2 - 10 < 0;
  if ( a2 >= 10 )
  {
    v19 = _InterlockedExchange(&dword_805B19C, a2);
    v18 = _InterlockedExchange(&dword_805B19C, a1);
    _InterlockedExchange(&dword_805B19C, v19);
    v20 = (_BYTE)--a2 * v18 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = v20 == 0;
    _SF = v20 < 0;
    if ( v20 )
      abort();
  }
  __asm { pushfw }
  if ( a2 >= 10 )
  {
    v22 = _InterlockedExchange(&dword_805B130, a2);
    v21 = _InterlockedExchange(&dword_805B130, v8);
    v8 = _InterlockedExchange(&dword_805B130, v22);
    if ( ((_BYTE)a2 - 1) * v21 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  v23 = _InterlockedExchange(&dword_805B16C, a2);
  v26 = _InterlockedExchange(&dword_805B16C, v8);
  v24 = v23;
  v25 = v26;
  v27 = sub_804B058(_CF, _ZF, _SF, _OF, _InterlockedExchange(&dword_805B16C, v24), v26);
  v38 = v27;
  __asm { pushfw }
  v28 = _InterlockedExchange(&dword_805B118, v27);
  _InterlockedExchange(&dword_805B118, v29);
  _InterlockedExchange(&dword_805B118, v28);
  v30 = sub_80550AC();
  if ( v30 != 445 )
  {
    v33 = _InterlockedExchange(&dword_805B118, v30);
    _InterlockedExchange(&dword_805B118, v31);
    _InterlockedExchange(&dword_805B118, v33);
    sub_80550B6(v32);
  }
  __asm { popfw }
  if ( v38 != -812 )
  {
    v34 = _InterlockedExchange(&dword_805B16C, v38);
    _InterlockedExchange(&dword_805B16C, v31);
    sub_804B0A0(
      v38 < 0xFFFFFCD4,
      v38 == -812,
      (signed int)(v38 + 812) < 0,
      __OFSUB__(v38, -812),
      _InterlockedExchange(&dword_805B16C, v34),
      v32,
      v25);
  }
  __asm
  {
    popfw
    popfw
  }
  return 0;
}
// 80550B6: using guessed type int __fastcall sub_80550B6(_DWORD);
// 805B118: using guessed type int dword_805B118;
// 805B130: using guessed type int dword_805B130;
// 805B148: using guessed type int dword_805B148;
// 805B16C: using guessed type int dword_805B16C;
// 805B19C: using guessed type int dword_805B19C;
// 805B6DB: using guessed type int dword_805B6DB;

//----- (0804C4AA) --------------------------------------------------------
bool __usercall sub_804C4AA@<al>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, signed __int32 a3, int a4, _BYTE **a5, signed __int32 *a6, char a7)
{
  signed __int32 v11; // ebx
  signed __int32 v12; // ecx
  signed __int32 v13; // ebx
  signed __int32 v14; // et0
  unsigned __int32 v15; // eax
  signed __int32 v16; // edx
  signed __int32 v17; // ecx
  bool v18; // cf
  bool v19; // zf
  bool v20; // sf
  char v21; // of
  signed __int32 v22; // eax
  signed __int32 v23; // eax
  int v24; // edx
  signed __int32 v25; // ecx
  signed __int32 v26; // eax
  bool result; // al
  unsigned __int8 v28; // al
  char v33; // al
  signed __int32 v34; // et0
  unsigned int v35; // eax
  unsigned int i; // [esp+1Ch] [ebp-Ch]
  int v37; // [esp+1Ch] [ebp-Ch]
  int j; // [esp+1Ch] [ebp-Ch]

  _CF = 0;
  _OF = 0;
  _ZF = a4 == 0;
  _SF = a4 < 0;
  if ( a4 )
  {
    for ( i = a4 - 1; i && *(_BYTE *)(a3 + i) != 41; --i )
      ;
    v28 = *(_BYTE *)(a3 + i);
    _CF = v28 < 0x29u;
    _OF = __OFSUB__(v28, 41);
    _ZF = v28 == 41;
    _SF = (char)(v28 - 41) < 0;
    if ( v28 == 41 )
    {
      *a6 = a3;
      if ( !a7 || sub_804C168(a1, a2, a3, i) )
      {
        v35 = i;
        v37 = i + 1;
        *(_BYTE *)(a3 + v35) = 0;
        while ( *(_BYTE *)(a3 + v37) == 32 || *(_BYTE *)(a3 + v37) == 9 )
          ++v37;
        if ( *(_BYTE *)(a3 + v37) == 61 )
        {
          for ( j = v37 + 1; *(_BYTE *)(a3 + j) == 32 || *(_BYTE *)(a3 + j) == 9; ++j )
            ;
          *a5 = (_BYTE *)(j + a3);
          result = sub_804C330(j + a3, a2, *a5);
        }
        else
        {
          result = 0;
        }
      }
      else
      {
        result = 0;
      }
    }
    else
    {
      __asm { pushfw }
      if ( a2 >= 10 )
      {
        v34 = _InterlockedExchange(&dword_805B160, a2);
        v33 = _InterlockedExchange(&dword_805B160, a3);
        _InterlockedExchange(&dword_805B160, v34);
        if ( ((_BYTE)a2 - 1) * v33 & 1 )
          abort();
      }
      __asm { popfw }
      result = 0;
    }
  }
  else
  {
    __asm { pushfw }
    v11 = _InterlockedExchange(&dword_805B130, a2);
    v14 = _InterlockedExchange(&dword_805B130, a1);
    v12 = v11;
    v13 = v14;
    _InterlockedExchange(&dword_805B130, v12);
    v15 = sub_804AFB8();
    v18 = v15 < 0x36C;
    v21 = __OFSUB__(v15, 876);
    v19 = v15 == 876;
    v20 = (signed int)(v15 - 876) < 0;
    if ( v15 != 876 )
    {
      v22 = _InterlockedExchange(&dword_805B130, v15);
      _InterlockedExchange(&dword_805B130, v17);
      _InterlockedExchange(&dword_805B130, v22);
      sub_804AFC2(v18, v19, v20, v21, v16, v13);
    }
    __asm
    {
      popfw
      pushfw
    }
    v23 = sub_80525AB(
            _CF,
            _ZF,
            _SF,
            _OF,
            _InterlockedExchange(&dword_805B184, _InterlockedExchange(&dword_805B184, v13)),
            _InterlockedExchange(&dword_805B184, v17));
    if ( v23 != -398 )
    {
      v26 = _InterlockedExchange(&dword_805B184, v23);
      _InterlockedExchange(&dword_805B184, v25);
      sub_805267B(_InterlockedExchange(&dword_805B184, v26), v24);
    }
    __asm { popfw }
    result = 0;
  }
  return result;
}
// 805267B: using guessed type int __fastcall sub_805267B(_DWORD, _DWORD);
// 805B130: using guessed type int dword_805B130;
// 805B160: using guessed type int dword_805B160;
// 805B184: using guessed type int dword_805B184;

//----- (0804C674) --------------------------------------------------------
bool __usercall sub_804C674@<al>(signed __int32 a1@<ebx>, signed __int32 a2, int a3, _BYTE **a4, _DWORD *a5, signed __int32 *a6)
{
  int v6; // eax
  signed __int32 v7; // eax
  signed __int32 v8; // edx
  signed __int32 v9; // ecx
  signed __int32 v10; // eax
  signed __int32 v11; // edx
  int v12; // ecx
  signed __int32 v13; // eax
  bool result; // al
  int v15; // eax
  signed __int32 v16; // ecx
  char v21; // al
  signed __int32 v22; // ebx
  char v23; // t2
  int v24; // eax
  signed __int32 v25; // [esp-Ah] [ebp-42h]
  int v26; // [esp-4h] [ebp-3Ch]
  char v27; // [esp+27h] [ebp-11h]
  int i; // [esp+28h] [ebp-10h]
  int v29; // [esp+28h] [ebp-10h]
  int v30; // [esp+28h] [ebp-10h]
  int v31; // [esp+28h] [ebp-10h]

  v27 = 0;
  for ( i = 0; *(_BYTE *)(a2 + i) == 32 || *(_BYTE *)(a2 + i) == 9; ++i )
    ;
  if ( *(_BYTE *)(a2 + i) == 92 )
  {
    ++i;
    v27 = 1;
  }
  v6 = strncmp((const char *)(i + a2), "MD5", 3u);
  v26 = v6;
  __asm { pushfw }
  v7 = _InterlockedExchange(&dword_805B184, v6);
  _InterlockedExchange(&dword_805B184, v8);
  _InterlockedExchange(&dword_805B184, v7);
  v10 = sub_80525AB(_CF, _ZF, _SF, _OF, v9, a1);
  if ( v10 != -398 )
  {
    v13 = _InterlockedExchange(&dword_805B184, v10);
    _InterlockedExchange(&dword_805B184, v11);
    sub_805267B(v12, _InterlockedExchange(&dword_805B184, v13));
  }
  __asm { popfw }
  if ( v26 )
  {
    if ( a3 - i < (unsigned int)(*(_BYTE *)(a2 + i) == 92) + dword_805B6D7 )
      return 0;
    *a4 = (_BYTE *)(i + a2);
    v30 = dword_805B6DB + i;
    if ( *(_BYTE *)(a2 + v30) != 32 && *(_BYTE *)(a2 + v30) != 9 )
      return 0;
    v15 = v30;
    v31 = v30 + 1;
    *(_BYTE *)(a2 + v15) = 0;
    if ( !sub_804C330(a2, a1, *a4) )
      return 0;
    if ( a3 - v31 != 1 && (*(_BYTE *)(a2 + v31) == 32 || *(_BYTE *)(a2 + v31) == 42) )
    {
      if ( dword_805B1C0 != 1 )
      {
        dword_805B1C0 = 0;
        v24 = v31++;
        *a5 = *(_BYTE *)(a2 + v24) == 42;
      }
    }
    else
    {
      _CF = 0;
      _OF = 0;
      _ZF = dword_805B1C0 == 0;
      _SF = dword_805B1C0 < 0;
      if ( !dword_805B1C0 )
        return 0;
      __asm { pushfw }
      v25 = a1;
      if ( a1 >= 10 )
      {
        v21 = a1;
        v22 = _InterlockedExchange(&dword_805B190, a1);
        v23 = _InterlockedExchange(&dword_805B190, v16);
        _InterlockedExchange(&dword_805B190, v22);
        if ( (v23 - 1) * v21 & 1 )
          abort();
      }
      a1 = v25;
      __asm { popfw }
      dword_805B1C0 = 1;
    }
    *a6 = v31 + a2;
    if ( v27 )
      result = sub_804C168(a2, a1, a2 + v31, a3 - v31) != 0;
    else
      result = 1;
  }
  else
  {
    v29 = i + 3;
    if ( *(_BYTE *)(a2 + v29) == 32 )
      ++v29;
    if ( *(_BYTE *)(a2 + v29) == 40 )
    {
      *a5 = 0;
      result = sub_804C4AA(a3 - (v29 + 1), a2, a2 + v29 + 1, a3 - (v29 + 1), a4, a6, v27);
    }
    else
    {
      result = 0;
    }
  }
  return result;
}
// 805267B: using guessed type int __fastcall sub_805267B(_DWORD, _DWORD);
// 805B184: using guessed type int dword_805B184;
// 805B190: using guessed type int dword_805B190;
// 805B1C0: using guessed type int dword_805B1C0;
// 805B6D7: using guessed type int dword_805B6D7;
// 805B6DB: using guessed type int dword_805B6DB;

//----- (0804C930) --------------------------------------------------------
int __usercall sub_804C930@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>, char *a7, unsigned __int8 a8)
{
  char v8; // al
  signed __int32 v9; // ebx
  char v10; // t0
  signed __int32 v11; // ebx
  int v12; // eax
  int result; // eax
  int v18; // eax
  size_t v23; // eax
  signed __int32 v24; // ecx
  char v25; // al
  signed __int32 v26; // ebx
  char v27; // t1
  signed __int32 v28; // eax
  int v29; // edx
  signed __int32 v30; // ecx
  signed __int32 v31; // ebx
  signed __int32 v32; // [esp-Ah] [ebp-36h]
  int v33; // [esp-4h] [ebp-30h]
  signed __int32 v34; // [esp+22h] [ebp-Ah]

  __asm { pushfw }
  v34 = a6;
  if ( a6 >= 10 )
  {
    v8 = a6;
    v9 = _InterlockedExchange(&dword_805B124, a6);
    v10 = _InterlockedExchange(&dword_805B124, a5);
    a5 = _InterlockedExchange(&dword_805B124, v9);
    if ( (v10 - 1) * v8 & 1 )
      abort();
  }
  v11 = v34;
  __asm { popfw }
  v12 = a8 ^ 1;
  _CF = 0;
  _OF = 0;
  _ZF = a8 == 1;
  _SF = (v12 & 0x80u) != 0;
  if ( a8 != 1 )
    return fputs_unlocked(a7, stdout);
  while ( 1 )
  {
    __asm { pushfw }
    v28 = _InterlockedExchange(&dword_805B13C, v12);
    _InterlockedExchange(&dword_805B13C, a5);
    _InterlockedExchange(&dword_805B13C, v28);
    if ( sub_8052670() != -41 )
    {
      v31 = _InterlockedExchange(&dword_805B13C, v11);
      _InterlockedExchange(&dword_805B13C, v30);
      sub_805267A(_InterlockedExchange(&dword_805B13C, v31), v29);
    }
    __asm { popfw }
    result = (unsigned __int8)*a7;
    if ( !(_BYTE)result )
      break;
    v18 = *a7;
    if ( v18 == 10 )
    {
      v23 = fwrite_unlocked("\\n", 1u, 2u, stdout);
    }
    else if ( v18 == 92 )
    {
      v23 = fwrite_unlocked("\\\\", 1u, 2u, stdout);
    }
    else
    {
      v23 = putchar_unlocked(*a7);
    }
    v33 = v23;
    __asm { pushfw }
    v32 = v11;
    if ( v11 >= 10 )
    {
      v25 = v11;
      v26 = _InterlockedExchange(&dword_805B19C, v11);
      v27 = _InterlockedExchange(&dword_805B19C, v24);
      _InterlockedExchange(&dword_805B19C, v26);
      if ( (v27 - 1) * v25 & 1 )
        abort();
    }
    v11 = v32;
    __asm { popfw }
    v12 = v33;
    _CF = __CFADD__(a7, 1);
    _OF = __OFADD__(1, a7);
    _ZF = a7 + 1 == 0;
    _SF = (signed int)(a7++ + 1) < 0;
  }
  return result;
}
// 804C930: could not find valid save-restore pair for ebx
// 804C930: could not find valid save-restore pair for ebp
// 8048F20: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 805267A: using guessed type int __fastcall sub_805267A(_DWORD, _DWORD);
// 805B124: using guessed type int dword_805B124;
// 805B13C: using guessed type int dword_805B13C;
// 805B19C: using guessed type int dword_805B19C;

//----- (0804CB2E) --------------------------------------------------------
int __usercall sub_804CB2E@<eax>(signed __int32 a1@<ebx>, char *s1, int a3, int a4, int a5)
{
  signed __int32 v5; // ecx
  signed __int32 v6; // ecx
  unsigned int v11; // eax
  int result; // eax
  void *v13; // eax
  signed __int32 v14; // eax
  signed __int32 v15; // edx
  signed __int32 v16; // ecx
  signed __int32 v17; // ebx
  signed __int32 v18; // ebx
  signed __int32 v19; // edx
  char v20; // al
  signed __int32 v21; // et2
  signed __int32 v22; // ecx
  void *v23; // ebx
  signed __int32 v24; // ebx
  signed __int32 v25; // edx
  signed __int32 v26; // edx
  signed __int32 v27; // ebx
  signed __int32 v28; // ett
  signed __int32 v29; // edx
  signed __int32 v30; // ecx
  char v35; // al
  signed __int32 v36; // ebx
  signed __int32 v37; // et0
  int v38; // eax
  char v39; // al
  signed __int32 v40; // ebx
  char v41; // t1
  signed __int32 v42; // eax
  signed __int32 v43; // et2
  int v44; // eax
  signed __int32 v45; // ecx
  void *v46; // ebx
  int *v47; // eax
  signed __int32 v48; // [esp-10h] [ebp-38h]
  unsigned __int32 v49; // [esp-Ah] [ebp-32h]
  signed __int32 v50; // [esp-4h] [ebp-2Ch]
  int *v51; // [esp-4h] [ebp-2Ch]
  int *v52; // [esp-4h] [ebp-2Ch]
  bool v53; // [esp+17h] [ebp-11h]
  FILE *stream; // [esp+18h] [ebp-10h]
  int v55; // [esp+1Ch] [ebp-Ch]
  int savedregs; // [esp+28h] [ebp+0h]

  v53 = strcmp(s1, "-") == 0;
  *(_BYTE *)a5 = 0;
  if ( v53 )
  {
    byte_805B6D3 = 1;
    stream = stdin;
    sub_804FAF9(0, v53 == 0, v53 < 0, 0, (int)stream, v5, a1, (int)&savedregs, stream, 2);
    goto LABEL_14;
  }
  stream = sub_804FD03(a1, (int)s1, "r");
  if ( stream )
  {
    sub_804FAF9(0, stream == 0, (signed int)stream < 0, 0, (int)stream, v6, a1, (int)&savedregs, stream, 2);
LABEL_14:
    v55 = sub_804E677(a1, stream, a4);
    if ( v55 )
    {
      v23 = sub_8051EAD(0, v55 == 0, v55 < 0, 0, (int)s1, v22, a1, (int)&savedregs, 0, 3u, (signed __int32)s1);
      v52 = __errno_location();
      __asm { pushfw }
      v24 = _InterlockedExchange(&dword_805B190, (signed __int32)v23);
      v28 = _InterlockedExchange(&dword_805B190, v25);
      v26 = v24;
      v27 = v28;
      _InterlockedExchange(&dword_805B190, v26);
      v49 = sub_804ADD8();
      __asm { pushfw }
      v48 = v28;
      _CF = (unsigned int)v28 < 0xA;
      _OF = __OFSUB__(v28, 10);
      _ZF = v28 == 10;
      _SF = v28 - 10 < 0;
      if ( v28 >= 10 )
      {
        v35 = v27;
        v36 = _InterlockedExchange(&dword_805B184, v27);
        v37 = _InterlockedExchange(&dword_805B184, v29);
        v29 = _InterlockedExchange(&dword_805B184, v36);
        v27 = v37 - 1;
        v38 = ((_BYTE)v37 - 1) * v35 & 1;
        _CF = 0;
        _OF = 0;
        _ZF = v38 == 0;
        _SF = v38 < 0;
        if ( v38 )
          abort();
      }
      __asm { pushfw }
      if ( v27 >= 10 )
      {
        v39 = v27;
        v40 = _InterlockedExchange(&dword_805B130, v27);
        v41 = _InterlockedExchange(&dword_805B130, v29);
        v29 = _InterlockedExchange(&dword_805B130, v40);
        if ( (v41 - 1) * v39 & 1 )
          abort();
      }
      __asm
      {
        popfw
        popfw
      }
      if ( v49 != 449 )
      {
        v43 = _InterlockedExchange(&dword_805B190, v49);
        v42 = _InterlockedExchange(&dword_805B190, v29);
        _InterlockedExchange(&dword_805B190, v43);
        sub_804ADE2(v49 < 0x1C1, v49 == 449, (signed int)(v49 - 449) < 0, __OFSUB__(v49, 449), v42, v30, v48);
      }
      __asm { popfw }
      error(0, *v52, "%s", v48);
      if ( stream != stdin )
        sub_80539F0(v48, stream);
      result = 0;
    }
    else if ( v53 != 1 && (v44 = sub_80539F0(a1, stream)) != 0 )
    {
      v46 = sub_8051EAD(0, v44 == 0, v44 < 0, 0, (int)s1, v45, a1, (int)&savedregs, 0, 3u, (signed __int32)s1);
      v47 = __errno_location();
      error(0, *v47, "%s", v46);
      result = 0;
    }
    else
    {
      result = 1;
    }
    return result;
  }
  _CF = 0;
  _OF = 0;
  _ZF = byte_805B6E1 == 0;
  _SF = byte_805B6E1 < 0;
  if ( byte_805B6E1
    && (v11 = *__errno_location(),
        _CF = v11 < 2,
        _OF = __OFSUB__(v11, 2),
        _ZF = v11 == 2,
        _SF = (signed int)(v11 - 2) < 0,
        v11 == 2) )
  {
    *(_BYTE *)a5 = 1;
    result = 1;
  }
  else
  {
    v13 = sub_8051EAD(_CF, _ZF, _SF, _OF, (int)s1, v6, a1, (int)&savedregs, 0, 3u, (signed __int32)s1);
    v50 = (signed __int32)v13;
    __asm { pushfw }
    v14 = _InterlockedExchange(&dword_805B178, (signed __int32)v13);
    _InterlockedExchange(&dword_805B178, v15);
    _InterlockedExchange(&dword_805B178, v14);
    if ( sub_804A881() != 893 )
    {
      v17 = _InterlockedExchange(&dword_805B178, a1);
      _InterlockedExchange(&dword_805B178, v16);
      sub_804A88B(_InterlockedExchange(&dword_805B178, v17));
    }
    __asm { popfw }
    v18 = v50;
    v51 = __errno_location();
    __asm { pushfw }
    if ( v18 >= 10 )
    {
      v21 = _InterlockedExchange(&dword_805B118, v18);
      v20 = _InterlockedExchange(&dword_805B118, v19);
      _InterlockedExchange(&dword_805B118, v21);
      if ( ((_BYTE)v18 - 1) * v20 & 1 )
        abort();
    }
    __asm { popfw }
    error(0, *v51, "%s", v18);
    result = 0;
  }
  return result;
}
// 804A88B: using guessed type int __fastcall sub_804A88B(_DWORD);
// 805B118: using guessed type int dword_805B118;
// 805B130: using guessed type int dword_805B130;
// 805B178: using guessed type int dword_805B178;
// 805B184: using guessed type int dword_805B184;
// 805B190: using guessed type int dword_805B190;
// 805B6D3: using guessed type char byte_805B6D3;
// 805B6E1: using guessed type char byte_805B6E1;

//----- (0804CE15) --------------------------------------------------------
_BOOL4 __usercall sub_804CE15@<eax>(void *a1@<ebx>, int argc)
{
  signed __int32 v2; // ecx
  void *v3; // ebx
  int *v4; // eax
  _BOOL4 result; // eax
  char *v6; // eax
  signed __int32 v7; // ecx
  char *v8; // eax
  bool v9; // al
  char *v14; // eax
  signed __int32 v15; // eax
  signed __int32 v16; // edx
  signed __int32 v17; // eax
  signed __int32 v18; // edx
  int v19; // ecx
  signed __int32 v20; // eax
  char v21; // cf
  bool v22; // zf
  bool v23; // sf
  char v24; // of
  char *v25; // eax
  char *v26; // eax
  int v27; // eax
  signed __int32 v28; // ecx
  void *v29; // ebx
  char *v30; // eax
  int v31; // eax
  void *v32; // ebx
  int *v33; // eax
  signed __int32 v34; // eax
  signed __int32 v35; // edx
  signed __int32 v36; // ecx
  unsigned int v37; // eax
  signed __int32 v38; // ecx
  void *v39; // ebx
  char *v40; // eax
  int v41; // eax
  char *v42; // eax
  int v43; // eax
  char *v44; // eax
  int v45; // eax
  char *v46; // eax
  void *v47; // ebx
  char *v48; // eax
  bool v49; // al
  char *v50; // [esp-4h] [ebp-9Ch]
  char *s1; // [esp+1Ch] [ebp-7Ch]
  int v52; // [esp+22h] [ebp-76h]
  unsigned __int8 v53; // [esp+26h] [ebp-72h]
  unsigned __int8 v54; // [esp+27h] [ebp-71h]
  void *ptr; // [esp+28h] [ebp-70h]
  int v56; // [esp+2Ch] [ebp-6Ch]
  char *s; // [esp+30h] [ebp-68h]
  int v58; // [esp+34h] [ebp-64h]
  int v59; // [esp+38h] [ebp-60h]
  FILE *stream; // [esp+3Ch] [ebp-5Ch]
  int v61; // [esp+40h] [ebp-58h]
  int i; // [esp+44h] [ebp-54h]
  int v63; // [esp+48h] [ebp-50h]
  unsigned int v64; // [esp+4Ch] [ebp-4Ch]
  __int64 v65; // [esp+50h] [ebp-48h]
  __int64 v66; // [esp+58h] [ebp-40h]
  __int64 v67; // [esp+60h] [ebp-38h]
  __int64 v68; // [esp+68h] [ebp-30h]
  __int64 v69; // [esp+70h] [ebp-28h]
  char v70; // [esp+78h] [ebp-20h]
  unsigned int v71; // [esp+8Ch] [ebp-Ch]
  int savedregs; // [esp+98h] [ebp+0h]

  s1 = (char *)argc;
  v71 = __readgsdword(0x14u);
  v65 = 0LL;
  v66 = 0LL;
  v67 = 0LL;
  v68 = 0LL;
  *(_WORD *)((char *)&v52 + 1) = 0;
  v63 = sub_804BA0B((int)&v70, 4u);
  HIBYTE(v52) = strcmp((const char *)argc, "-") == 0;
  if ( HIBYTE(v52) )
  {
    byte_805B6D3 = 1;
    s1 = gettext("standard input");
    stream = stdin;
  }
  else
  {
    stream = sub_804FD03((signed __int32)a1, argc, "r");
    if ( !stream )
    {
      v3 = sub_8051EAD(
             0,
             stream == 0,
             (signed int)stream < 0,
             0,
             argc,
             v2,
             (signed __int32)a1,
             (int)&savedregs,
             0,
             3u,
             argc);
      v4 = __errno_location();
      error(0, *v4, "%s", v3);
      result = 0;
      goto LABEL_79;
    }
  }
  v69 = 0LL;
  ptr = 0;
  v56 = 0;
  do
  {
    if ( !++v69 )
    {
      a1 = sub_8051EAD(0, 1, 0, 0, (int)s1, v2, (signed __int32)a1, (int)&savedregs, 0, 3u, (signed __int32)s1);
      v6 = gettext("%s: too many checksum lines");
      error(1, 0, v6, a1);
    }
    v61 = getline(&ptr, &v56, stream);
    if ( v61 <= 0 )
      break;
    if ( *(_BYTE *)ptr != 35 )
    {
      if ( *((_BYTE *)ptr + v61 - 1) == 10 )
        *((_BYTE *)ptr + --v61) = 0;
      if ( !sub_804C674((signed __int32)a1, (signed __int32)ptr, v61, (_BYTE **)&v59, &v58, (signed __int32 *)&s)
        || HIBYTE(v52) && !strcmp(s, "-") )
      {
        ++v65;
        if ( byte_805B6E0 )
        {
          a1 = sub_8051EAD(
                 0,
                 byte_805B6E0 == 0,
                 byte_805B6E0 < 0,
                 0,
                 (int)s1,
                 v7,
                 (signed __int32)a1,
                 (int)&savedregs,
                 0,
                 3u,
                 (signed __int32)s1);
          v8 = gettext("%s: %llu: improperly formatted %s checksum line");
          error(0, 0, v8, a1, v69, "MD5");
        }
        ++v66;
      }
      else
      {
        v9 = byte_805B6DF != 1 && strchr(s, 10);
        v53 = v9;
        BYTE1(v52) = 1;
        v54 = sub_804CB2E((signed __int32)a1, s, (int)&v58, v63, (int)&v52);
        if ( v54 ^ 1 )
        {
          ++v68;
          if ( byte_805B6DF != 1 )
          {
            _CF = 0;
            _OF = 0;
            _ZF = v53 == 0;
            _SF = (v53 & 0x80u) != 0;
            if ( v53 )
              putchar_unlocked(92);
            sub_804C930(_CF, _ZF, _SF, _OF, v53, (signed __int32)a1, s, v53);
            v14 = gettext("FAILED open or read");
            v50 = v14;
            __asm { pushfw }
            v15 = _InterlockedExchange(&dword_805B118, (signed __int32)v14);
            _InterlockedExchange(&dword_805B118, v16);
            _InterlockedExchange(&dword_805B118, v15);
            v17 = sub_80550AC();
            if ( v17 != 445 )
            {
              v20 = _InterlockedExchange(&dword_805B118, v17);
              _InterlockedExchange(&dword_805B118, v18);
              _InterlockedExchange(&dword_805B118, v20);
              sub_80550B6(v19);
            }
            __asm { popfw }
            printf(": %s\n", v50);
          }
        }
        else if ( !byte_805B6E1 || !(_BYTE)v52 )
        {
          v64 = (unsigned int)dword_805B6DB >> 1;
          for ( i = 0;
                i < v64
             && tolower(*(unsigned __int8 *)(2 * i + v59)) == byte_8056929[(unsigned __int8)(*(_BYTE *)(v63 + i) >> 4)]
             && tolower(*(unsigned __int8 *)(2 * i + 1 + v59)) == byte_8056929[*(_BYTE *)(v63 + i) & 0xF];
                ++i )
          {
            ;
          }
          if ( i == v64 )
            BYTE2(v52) = 1;
          else
            ++v67;
          if ( byte_805B6DF != 1 )
          {
            if ( i != v64 || byte_805B6E2 != 1 )
            {
              v21 = 0;
              v24 = 0;
              v22 = v53 == 0;
              v23 = (v53 & 0x80u) != 0;
              if ( v53 )
                putchar_unlocked(92);
              sub_804C930(v21, v22, v23, v24, v53, (signed __int32)a1, s, v53);
            }
            if ( i == v64 )
            {
              if ( byte_805B6E2 != 1 )
              {
                v26 = gettext("OK");
                printf(": %s\n", v26);
              }
            }
            else
            {
              v25 = gettext("FAILED");
              printf(": %s\n", v25);
            }
          }
        }
      }
    }
  }
  while ( !feof_unlocked(stream) && !ferror_unlocked(stream) );
  free(ptr);
  v27 = ferror_unlocked(stream);
  if ( v27 )
  {
    v29 = sub_8051EAD(
            0,
            v27 == 0,
            v27 < 0,
            0,
            (int)s1,
            v28,
            (signed __int32)a1,
            (int)&savedregs,
            0,
            3u,
            (signed __int32)s1);
    v30 = gettext("%s: read error");
    error(0, 0, v30, v29);
    result = 0;
  }
  else if ( HIBYTE(v52) != 1 && (v31 = sub_80539F0((signed __int32)a1, stream)) != 0 )
  {
    v32 = sub_8051EAD(
            0,
            v31 == 0,
            v31 < 0,
            0,
            (int)s1,
            v28,
            (signed __int32)a1,
            (int)&savedregs,
            0,
            3u,
            (signed __int32)s1);
    v33 = __errno_location();
    error(0, *v33, "%s", v32);
    __asm { pushfw }
    v37 = sub_804B522(
            _CF,
            _ZF,
            _SF,
            _OF,
            _InterlockedExchange(&dword_805B154, v35),
            _InterlockedExchange(&dword_805B154, _InterlockedExchange(&dword_805B154, v34)),
            v36,
            (signed __int32)v32);
    if ( v37 != -958 )
      sub_804B619(
        v37 < 0xFFFFFC42,
        v37 == -958,
        (signed int)(v37 + 958) < 0,
        __OFSUB__(v37, -958),
        _InterlockedExchange(&dword_805B154, _InterlockedExchange(&dword_805B154, (signed __int32)v32)),
        _InterlockedExchange(&dword_805B154, v38));
    __asm { popfw }
    result = 0;
  }
  else
  {
    if ( BYTE1(v52) == 1 )
    {
      if ( byte_805B6DF != 1 )
      {
        if ( v65 )
        {
          v41 = sub_804B8E6(
                  0,
                  v65 == 0,
                  (signed int)(HIDWORD(v65) | v65) < 0,
                  0,
                  SHIDWORD(v65),
                  (signed __int32)a1,
                  v65);
          v42 = ngettext(
                  "WARNING: %llu line is improperly formatted",
                  "WARNING: %llu lines are improperly formatted",
                  v41);
          error(0, 0, v42, v65);
        }
        if ( v68 )
        {
          v43 = sub_804B8E6(
                  0,
                  v68 == 0,
                  (signed int)(HIDWORD(v68) | v68) < 0,
                  0,
                  SHIDWORD(v68),
                  (signed __int32)a1,
                  v68);
          v44 = ngettext(
                  "WARNING: %llu listed file could not be read",
                  "WARNING: %llu listed files could not be read",
                  v43);
          error(0, 0, v44, v68);
        }
        if ( v67 )
        {
          v45 = sub_804B8E6(
                  0,
                  v67 == 0,
                  (signed int)(HIDWORD(v67) | v67) < 0,
                  0,
                  SHIDWORD(v67),
                  (signed __int32)a1,
                  v67);
          v46 = ngettext(
                  "WARNING: %llu computed checksum did NOT match",
                  "WARNING: %llu computed checksums did NOT match",
                  v45);
          error(0, 0, v46, v67);
        }
        if ( byte_805B6E1 && BYTE2(v52) != 1 )
        {
          v47 = sub_8051EAD(
                  0,
                  BYTE2(v52) == 1,
                  ((BYTE2(v52) ^ 1) & 0x80u) != 0,
                  0,
                  (int)s1,
                  v28,
                  (signed __int32)a1,
                  (int)&savedregs,
                  0,
                  3u,
                  (signed __int32)s1);
          v48 = gettext("%s: no file was verified");
          error(0, 0, v48, v47);
        }
      }
    }
    else
    {
      v39 = sub_8051EAD(
              0,
              BYTE1(v52) == 1,
              ((BYTE1(v52) ^ 1) & 0x80u) != 0,
              0,
              (int)s1,
              v28,
              (signed __int32)a1,
              (int)&savedregs,
              0,
              3u,
              (signed __int32)s1);
      v40 = gettext("%s: no properly formatted %s checksum lines found");
      error(0, 0, v40, v39, "MD5");
    }
    v49 = BYTE1(v52) && BYTE2(v52) && !v67 && !v68 && (byte_805B6E3 != 1 || !v66);
    result = v49;
  }
LABEL_79:
  __readgsdword(0x14u);
  return result;
}
// 8048D20: using guessed type int __cdecl getline(_DWORD, _DWORD, _DWORD);
// 80550B6: using guessed type int __fastcall sub_80550B6(_DWORD);
// 805B118: using guessed type int dword_805B118;
// 805B154: using guessed type int dword_805B154;
// 805B6D3: using guessed type char byte_805B6D3;
// 805B6DB: using guessed type int dword_805B6DB;
// 805B6DF: using guessed type char byte_805B6DF;
// 805B6E0: using guessed type char byte_805B6E0;
// 805B6E1: using guessed type char byte_805B6E1;
// 805B6E2: using guessed type char byte_805B6E2;
// 805B6E3: using guessed type char byte_805B6E3;

//----- (0804DF47) --------------------------------------------------------
signed int __usercall sub_804DF47@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>)
{
  signed int v2; // eax
  signed __int32 v3; // ecx
  bool v4; // cf
  bool v5; // zf
  bool v6; // sf
  char v7; // of
  unsigned int v8; // eax
  signed __int32 v9; // edx
  signed __int32 v10; // ecx
  void *v11; // ebx
  int *v12; // eax
  int *v13; // eax
  signed int result; // eax
  char *v15; // [esp+2Ch] [ebp-Ch]
  int savedregs; // [esp+38h] [ebp+0h]

  v2 = sub_8054491(0, 0, v6, 0, (signed __int32)stdout, a1, a2, (int)&savedregs, stdout);
  v4 = 0;
  v7 = 0;
  v5 = v2 == 0;
  v6 = v2 < 0;
  if ( v2 )
  {
    if ( byte_805B6EB != 1
      || (v8 = *__errno_location(),
          v4 = v8 < 0x20,
          v7 = __OFSUB__(v8, 32),
          v5 = v8 == 32,
          v6 = (signed int)(v8 - 32) < 0,
          v8 != 32) )
    {
      v15 = gettext("write error");
      if ( dword_805B6E7 )
      {
        v11 = sub_8051D60(0, dword_805B6E7 == 0, dword_805B6E7 < 0, 0, v9, v10, a2, dword_805B6E7);
        v12 = __errno_location();
        error(0, *v12, "%s: %s", v11, v15);
      }
      else
      {
        v13 = __errno_location();
        error(0, *v13, "%s", v15);
      }
      _exit(status);
    }
  }
  result = sub_8054491(v4, v5, v6, v7, (signed __int32)stderr, v3, a2, (int)&savedregs, stderr);
  if ( result )
    _exit(status);
  return result;
}
// 805B6E7: using guessed type int dword_805B6E7;
// 805B6EB: using guessed type char byte_805B6EB;

//----- (0804E02B) --------------------------------------------------------
_DWORD *__cdecl sub_804E02B(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 1732584193;
  a1[1] = -271733879;
  a1[2] = -1732584194;
  a1[3] = 271733878;
  a1[5] = 0;
  a1[4] = a1[5];
  result = a1;
  a1[6] = 0;
  return result;
}

//----- (0804E077) --------------------------------------------------------
_DWORD *__usercall sub_804E077@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, _DWORD *a8, int a9)
{
  char v9; // al
  signed __int32 v10; // et0
  signed __int32 v11; // ebx
  signed __int32 v12; // edx
  signed __int32 v13; // ebx
  signed __int32 v14; // et1
  signed __int32 v15; // edx
  signed __int32 v16; // ecx
  signed __int32 v17; // ebx
  char v18; // al
  signed __int32 v19; // ebx
  char v20; // tt
  char v21; // al
  signed __int32 v22; // et0
  signed __int32 v23; // edx
  int v24; // eax
  signed __int32 v29; // ebx
  signed __int32 v30; // et1
  signed __int32 v31; // ebx
  signed __int32 v32; // edx
  signed __int32 v33; // edx
  signed __int32 v34; // ebx
  signed __int32 v35; // et2
  unsigned int v36; // eax
  signed __int32 v37; // edx
  signed __int32 v38; // ecx
  signed __int32 v39; // ebx
  signed __int32 v40; // ett
  signed __int32 v45; // eax
  signed __int32 v46; // eax
  signed __int32 v47; // edx
  int v48; // ecx
  signed __int32 v49; // ebx
  _DWORD *result; // eax
  unsigned __int32 v51; // [esp-14h] [ebp-14h]
  signed __int32 v52; // [esp-Ah] [ebp-Ah]

  __asm { pushfw }
  if ( a7 >= 10 )
  {
    v10 = _InterlockedExchange(&dword_805B10C, a7);
    v9 = _InterlockedExchange(&dword_805B10C, a6);
    _InterlockedExchange(&dword_805B10C, v10);
    if ( ((_BYTE)a7 - 1) * v9 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  v11 = _InterlockedExchange(&dword_805B118, a7);
  v14 = _InterlockedExchange(&dword_805B118, a5);
  v12 = v11;
  v13 = v14;
  _InterlockedExchange(&dword_805B118, v12);
  if ( sub_80550AC() != 445 )
  {
    v17 = _InterlockedExchange(&dword_805B118, v13);
    _InterlockedExchange(&dword_805B118, v15);
    _InterlockedExchange(&dword_805B118, v17);
    sub_80550B6(v16);
  }
  __asm
  {
    popfw
    pushfw
  }
  v52 = v13;
  if ( v13 >= 10 )
  {
    v18 = v13;
    v19 = _InterlockedExchange(&dword_805B160, v13);
    v20 = _InterlockedExchange(&dword_805B160, v16);
    v16 = _InterlockedExchange(&dword_805B160, v19);
    if ( (v20 - 1) * v18 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( v52 >= 10 )
  {
    v22 = _InterlockedExchange(&dword_805B16C, v52);
    v21 = _InterlockedExchange(&dword_805B16C, v15);
    v23 = _InterlockedExchange(&dword_805B16C, v22);
    v24 = ((_BYTE)v52 - 1) * v21 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = v24 == 0;
    _SF = v24 < 0;
    if ( v24 )
    {
      __asm { pushfw }
      v29 = _InterlockedExchange(&dword_805B154, v52 - 1);
      v30 = _InterlockedExchange(&dword_805B154, v16);
      v51 = sub_804B522(0, v24 == 0, v24 < 0, 0, v24, v23, _InterlockedExchange(&dword_805B154, v29), v30);
      __asm { pushfw }
      v31 = _InterlockedExchange(&dword_805B124, v30);
      v35 = _InterlockedExchange(&dword_805B124, v32);
      v33 = v31;
      v34 = v35;
      _InterlockedExchange(&dword_805B124, v33);
      v36 = sub_805194D();
      if ( v36 != 44 )
      {
        v39 = _InterlockedExchange(&dword_805B124, v34);
        v40 = _InterlockedExchange(&dword_805B124, v38);
        _InterlockedExchange(&dword_805B124, v39);
        sub_8051957(v36 < 0x2C, v36 == 44, (signed int)(v36 - 44) < 0, __OFSUB__(v36, 44), v37, v40);
      }
      __asm { popfw }
      _CF = v51 < 0xFFFFFC42;
      _OF = __OFSUB__(v51, -958);
      _ZF = v51 == -958;
      _SF = (signed int)(v51 + 958) < 0;
      if ( v51 != -958 )
      {
        v45 = _InterlockedExchange(&dword_805B154, v51);
        _InterlockedExchange(&dword_805B154, v38);
        sub_804B619(
          v51 < 0xFFFFFC42,
          v51 == -958,
          (signed int)(v51 + 958) < 0,
          __OFSUB__(v51, -958),
          _InterlockedExchange(&dword_805B154, v45),
          v34);
      }
      __asm { pushfw }
      v46 = _InterlockedExchange(&dword_805B10C, -958);
      _InterlockedExchange(&dword_805B10C, v37);
      _InterlockedExchange(&dword_805B10C, v46);
      if ( sub_8052466() != -423 )
      {
        v49 = _InterlockedExchange(&dword_805B10C, v34);
        _InterlockedExchange(&dword_805B10C, v47);
        _InterlockedExchange(&dword_805B10C, v49);
        sub_8052470(v48);
      }
      __asm
      {
        popfw
        popfw
      }
      abort();
    }
  }
  __asm { popfw }
  result = a8;
  *a8 = a9;
  return result;
}
// 804E077: could not find valid save-restore pair for ebx
// 8052470: using guessed type int __fastcall sub_8052470(_DWORD);
// 80550B6: using guessed type int __fastcall sub_80550B6(_DWORD);
// 805B10C: using guessed type int dword_805B10C;
// 805B118: using guessed type int dword_805B118;
// 805B124: using guessed type int dword_805B124;
// 805B154: using guessed type int dword_805B154;
// 805B160: using guessed type int dword_805B160;
// 805B16C: using guessed type int dword_805B16C;

//----- (0804E221) --------------------------------------------------------
_DWORD *__usercall sub_804E221@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, int a8@<ebp>, int *a9, _DWORD *a10)
{
  signed __int32 v10; // ebx
  signed __int32 v11; // ecx
  signed __int32 v12; // ebx
  signed __int32 v13; // et0
  unsigned __int32 v14; // eax
  signed __int32 v15; // edx
  signed __int32 v16; // ecx
  signed __int32 v17; // ebx
  signed __int32 v18; // et1
  signed __int32 v19; // ecx
  signed __int32 v20; // ebx
  signed __int32 v21; // edx
  signed __int32 v22; // edx
  signed __int32 v23; // ebx
  signed __int32 v24; // et2
  signed __int32 v25; // eax
  signed __int32 v26; // edx
  signed __int32 v27; // ecx
  signed __int32 v28; // eax
  signed __int32 v30; // edx
  signed __int32 v31; // ecx
  char v32; // al
  signed __int32 v33; // ebx
  char v34; // t0
  signed __int32 v39; // eax
  signed __int32 v40; // eax
  signed __int32 v41; // ecx
  signed __int32 v42; // eax
  char v43; // al
  signed __int32 v44; // ett
  signed __int32 v45; // [esp-Ah] [ebp-26h]
  _DWORD *v46; // [esp-4h] [ebp-20h]
  int v47; // [esp+18h] [ebp-4h]

  v47 = a5;
  __asm { pushfw }
  v10 = _InterlockedExchange(&dword_805B190, a7);
  v13 = _InterlockedExchange(&dword_805B190, a6);
  v11 = v10;
  v12 = v13;
  _InterlockedExchange(&dword_805B190, v11);
  v14 = sub_804ADD8();
  if ( v14 != 449 )
  {
    v17 = _InterlockedExchange(&dword_805B190, v12);
    v18 = _InterlockedExchange(&dword_805B190, v15);
    _InterlockedExchange(&dword_805B190, v17);
    sub_804ADE2(v14 < 0x1C1, v14 == 449, (signed int)(v14 - 449) < 0, __OFSUB__(v14, 449), v14, v16, v18);
  }
  __asm { popfw }
  v47 = a8;
  sub_804E077((unsigned int)&v47 < 0x18, &v47 == 0, (signed int)&v47 < 0, __OFSUB__(&v47, 24), v15, v16, v12, a10, *a9);
  sub_804E077(
    __CFADD__(a10, 4),
    a10 + 1 == 0,
    (signed int)(a10 + 1) < 0,
    __OFADD__(4, a10),
    (signed __int32)(a10 + 1),
    v19,
    v12,
    a10 + 1,
    a9[1]);
  __asm { pushfw }
  v20 = _InterlockedExchange(&dword_805B178, v12);
  v24 = _InterlockedExchange(&dword_805B178, v21);
  v22 = v20;
  v23 = v24;
  _InterlockedExchange(&dword_805B178, v22);
  v25 = sub_804A881();
  if ( v25 != 893 )
  {
    v28 = _InterlockedExchange(&dword_805B178, v25);
    _InterlockedExchange(&dword_805B178, v26);
    _InterlockedExchange(&dword_805B178, v28);
    sub_804A88B(v27);
  }
  __asm { popfw }
  v46 = sub_804E077(
          __CFADD__(a10, 8),
          a10 + 2 == 0,
          (signed int)(a10 + 2) < 0,
          __OFADD__(8, a10),
          (signed __int32)(a10 + 2),
          v27,
          v23,
          a10 + 2,
          a9[2]);
  __asm { pushfw }
  v45 = v23;
  if ( v23 >= 10 )
  {
    v32 = v23;
    v33 = _InterlockedExchange(&dword_805B148, v23);
    v34 = _InterlockedExchange(&dword_805B148, v30);
    v30 = _InterlockedExchange(&dword_805B148, v33);
    if ( (v34 - 1) * v32 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  _CF = (unsigned int)v45 < 0xA;
  _OF = __OFSUB__(v45, 10);
  _ZF = v45 == 10;
  _SF = v45 - 10 < 0;
  if ( v45 >= 10 )
  {
    __asm { pushfw }
    v39 = _InterlockedExchange(&dword_805B118, (signed __int32)v46);
    _InterlockedExchange(&dword_805B118, v30);
    _InterlockedExchange(&dword_805B118, v39);
    v40 = sub_80550AC();
    if ( v40 != 445 )
    {
      v42 = _InterlockedExchange(&dword_805B118, v40);
      _InterlockedExchange(&dword_805B118, v41);
      sub_80550B6(_InterlockedExchange(&dword_805B118, v42));
    }
    __asm { popfw }
    v44 = _InterlockedExchange(&dword_805B190, v45);
    v43 = _InterlockedExchange(&dword_805B190, v41);
    v31 = _InterlockedExchange(&dword_805B190, v44);
    if ( ((_BYTE)v45 - 1) * v43 & 1 )
      abort();
  }
  __asm { popfw }
  sub_804E077(
    __CFADD__(a10, 12),
    a10 + 3 == 0,
    (signed int)(a10 + 3) < 0,
    __OFADD__(12, a10),
    (signed __int32)(a10 + 3),
    v31,
    v45,
    a10 + 3,
    a9[3]);
  return a10;
}
// 804E221: could not find valid save-restore pair for ebp
// 804A88B: using guessed type int __fastcall sub_804A88B(_DWORD);
// 80550B6: using guessed type int __fastcall sub_80550B6(_DWORD);
// 805B118: using guessed type int dword_805B118;
// 805B148: using guessed type int dword_805B148;
// 805B178: using guessed type int dword_805B178;
// 805B190: using guessed type int dword_805B190;

//----- (0804E415) --------------------------------------------------------
_DWORD *__usercall sub_804E415@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, int *a4, _DWORD *a5)
{
  char v13; // al
  signed __int32 v14; // ebx
  char v15; // t0
  signed __int32 v16; // ebx
  char v17; // t1
  signed int v18; // eax
  signed __int32 v19; // ecx
  signed __int32 v21; // ebx
  signed __int32 v22; // ecx
  signed __int32 v23; // ebx
  signed __int32 v24; // et2
  unsigned __int32 v25; // eax
  signed __int32 v26; // edx
  signed __int32 v27; // ecx
  signed __int32 v32; // eax
  char v33; // al
  signed __int32 v34; // ebx
  char v35; // t0
  unsigned int v36; // eax
  signed __int32 v41; // [esp-14h] [ebp-3Ch]
  signed __int32 v42; // [esp-10h] [ebp-38h]
  signed __int32 v43; // [esp-Ah] [ebp-32h]
  unsigned int v44; // [esp+18h] [ebp-10h]
  signed int v45; // [esp+1Ch] [ebp-Ch]
  int savedregs; // [esp+28h] [ebp+0h]

  v44 = a4[6];
  _CF = v44 < 0x37;
  _OF = __OFSUB__(v44, 55);
  _ZF = v44 == 55;
  _SF = (signed int)(v44 - 55) < 0;
  if ( v44 > 0x37 )
  {
    v18 = 32;
  }
  else
  {
    __asm { pushfw }
    v43 = a3;
    _CF = (unsigned int)a3 < 0xA;
    _OF = __OFSUB__(a3, 10);
    _ZF = a3 == 10;
    _SF = a3 - 10 < 0;
    if ( a3 >= 10 )
    {
      __asm { pushfw }
      v41 = a3;
      if ( a3 >= 10 )
      {
        v13 = a3;
        v14 = _InterlockedExchange(&dword_805B124, a3);
        v15 = _InterlockedExchange(&dword_805B124, a1);
        _InterlockedExchange(&dword_805B124, v14);
        if ( (v15 - 1) * v13 & 1 )
          abort();
      }
      __asm { popfw }
      v16 = _InterlockedExchange(&dword_805B190, v41);
      v17 = _InterlockedExchange(&dword_805B190, a2);
      a2 = _InterlockedExchange(&dword_805B190, v16);
      if ( (v17 - 1) * (_BYTE)v41 & 1 )
        abort();
    }
    a3 = v43;
    __asm { popfw }
    v18 = 16;
  }
  v45 = v18;
  a4[4] += v44;
  v36 = a4[4];
  _CF = v36 < v44;
  _OF = __OFSUB__(v36, v44);
  _ZF = v36 == v44;
  _SF = (signed int)(v36 - v44) < 0;
  if ( v36 < v44 )
    ++a4[5];
  __asm { pushfw }
  v21 = _InterlockedExchange(&dword_805B13C, a3);
  v24 = _InterlockedExchange(&dword_805B13C, a2);
  v22 = v21;
  v23 = v24;
  _InterlockedExchange(&dword_805B13C, v22);
  v25 = sub_8052670();
  _CF = v25 < 0xFFFFFFD7;
  _OF = __OFSUB__(v25, -41);
  _ZF = v25 == -41;
  _SF = (signed int)(v25 + 41) < 0;
  if ( v25 != -41 )
  {
    v32 = _InterlockedExchange(&dword_805B13C, v25);
    _InterlockedExchange(&dword_805B13C, v27);
    sub_805267A(_InterlockedExchange(&dword_805B13C, v32), v26);
  }
  __asm { pushfw }
  v42 = v23;
  if ( v23 >= 10 )
  {
    v33 = v23;
    v34 = _InterlockedExchange(&dword_805B10C, v23);
    v35 = _InterlockedExchange(&dword_805B10C, v26);
    _InterlockedExchange(&dword_805B10C, v34);
    if ( (v35 - 1) * v33 & 1 )
      abort();
  }
  __asm
  {
    popfw
    popfw
  }
  a4[v45 + 5] = 8 * a4[4];
  a4[v45 + 6] = *((_QWORD *)a4 + 2) >> 29;
  memcpy((char *)a4 + v44 + 28, &unk_8056970, 4 * (v45 + 1073741822) - v44);
  sub_804EB80(4 * v45, v42, a4 + 7, 4 * v45, a4);
  return sub_804E221(_CF, _ZF, _SF, _OF, (int)a4, v19, v42, (int)&savedregs, a4, a5);
}
// 805267A: using guessed type int __fastcall sub_805267A(_DWORD, _DWORD);
// 805B10C: using guessed type int dword_805B10C;
// 805B124: using guessed type int dword_805B124;
// 805B13C: using guessed type int dword_805B13C;
// 805B190: using guessed type int dword_805B190;

//----- (0804E677) --------------------------------------------------------
int __usercall sub_804E677@<eax>(signed __int32 a1@<ebx>, FILE *stream, int a3)
{
  int v4; // ecx
  char v9; // al
  signed __int32 v10; // ebx
  char v11; // t0
  int v12; // eax
  signed __int32 v13; // edx
  signed __int32 v14; // ecx
  char v19; // al
  signed __int32 v20; // et1
  int v21; // eax
  signed __int32 v26; // ebx
  char v27; // t2
  signed __int32 v28; // eax
  unsigned __int32 v29; // eax
  signed __int32 v30; // edx
  signed __int32 v31; // ecx
  bool v32; // cf
  bool v33; // zf
  bool v34; // sf
  char v35; // of
  signed __int32 v36; // eax
  signed __int32 v37; // et0
  signed __int32 v38; // [esp-Ah] [ebp-D2h]
  size_t v39; // [esp+18h] [ebp-B0h]
  int *ptr; // [esp+1Ch] [ebp-ACh]
  size_t v41; // [esp+20h] [ebp-A8h]
  int v42; // [esp+24h] [ebp-A4h]

  ptr = (int *)malloc(0x8048u);
  if ( !ptr )
    return 1;
  sub_804E02B(&v42);
LABEL_4:
  v39 = 0;
  while ( 1 )
  {
    v41 = fread_unlocked((char *)ptr + v39, 1u, 0x8000 - v39, stream);
    v39 += v41;
    _CF = v39 < 0x8000;
    _OF = __OFSUB__(v39, 0x8000);
    _ZF = v39 == 0x8000;
    _SF = (signed int)(v39 - 0x8000) < 0;
    if ( v39 == 0x8000 )
    {
      sub_804EB80(v4, a1, ptr, 0x8000u, &v42);
      goto LABEL_4;
    }
    __asm { pushfw }
    v38 = a1;
    if ( a1 >= 10 )
    {
      v9 = a1;
      v10 = _InterlockedExchange(&dword_805B154, a1);
      v11 = _InterlockedExchange(&dword_805B154, v4);
      _InterlockedExchange(&dword_805B154, v10);
      if ( (v11 - 1) * v9 & 1 )
        abort();
    }
    a1 = v38;
    __asm { popfw }
    if ( !v41 )
      break;
    v21 = feof_unlocked(stream);
    _CF = 0;
    _OF = 0;
    _ZF = v21 == 0;
    _SF = v21 < 0;
    if ( v21 )
    {
      __asm { pushfw }
      if ( v38 >= 10 )
      {
        v26 = _InterlockedExchange(&dword_805B184, v38);
        v27 = _InterlockedExchange(&dword_805B184, v13);
        v13 = _InterlockedExchange(&dword_805B184, v26);
        if ( (v27 - 1) * (_BYTE)v38 & 1 )
          abort();
      }
      a1 = v38;
      __asm { popfw }
      goto LABEL_25;
    }
    __asm { pushfw }
    v28 = _InterlockedExchange(&dword_805B190, 0);
    _InterlockedExchange(&dword_805B190, v14);
    _InterlockedExchange(&dword_805B190, v28);
    v29 = sub_804ADD8();
    v32 = v29 < 0x1C1;
    v35 = __OFSUB__(v29, 449);
    v33 = v29 == 449;
    v34 = (signed int)(v29 - 449) < 0;
    if ( v29 != 449 )
    {
      v37 = _InterlockedExchange(&dword_805B190, v29);
      v36 = _InterlockedExchange(&dword_805B190, v30);
      _InterlockedExchange(&dword_805B190, v37);
      sub_804ADE2(v32, v33, v34, v35, v36, v31, v38);
    }
    __asm { popfw }
  }
  v12 = ferror_unlocked(stream);
  _CF = 0;
  _OF = 0;
  _ZF = v12 == 0;
  _SF = v12 < 0;
  if ( v12 )
  {
    __asm { pushfw }
    if ( v38 >= 10 )
    {
      v20 = _InterlockedExchange(&dword_805B130, v38);
      v19 = _InterlockedExchange(&dword_805B130, v14);
      _InterlockedExchange(&dword_805B130, v20);
      if ( ((_BYTE)v38 - 1) * v19 & 1 )
        abort();
    }
    __asm { popfw }
    free(ptr);
    return 1;
  }
LABEL_25:
  if ( v39 )
    sub_804E8F6(v14, a1, ptr, v39, (int)&v42);
  sub_804E415(v13, v14, a1, &v42, (_DWORD *)a3);
  free(ptr);
  return 0;
}
// 805B130: using guessed type int dword_805B130;
// 805B154: using guessed type int dword_805B154;
// 805B184: using guessed type int dword_805B184;
// 805B190: using guessed type int dword_805B190;

//----- (0804E8F6) --------------------------------------------------------
int *__usercall sub_804E8F6@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, void *src, size_t a4, int a5)
{
  int *result; // eax
  int v6; // eax
  unsigned int v7; // eax
  signed __int32 v12; // ebx
  signed __int32 v13; // ecx
  signed __int32 v14; // ebx
  signed __int32 v15; // et0
  unsigned int v16; // eax
  signed __int32 v17; // edx
  signed __int32 v18; // ecx
  int *v19; // eax
  int v20; // ecx
  signed __int32 v21; // edx
  int v22; // ecx
  char v27; // al
  signed __int32 v28; // ebx
  char v29; // t2
  signed __int32 v30; // [esp-Ah] [ebp-32h]
  size_t v31; // [esp+14h] [ebp-14h]
  size_t v32; // [esp+14h] [ebp-14h]
  int v33; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]

  result = *(int **)(a5 + 24);
  if ( result )
  {
    v33 = *(_DWORD *)(a5 + 24);
    v6 = a4;
    if ( 128 - v33 <= a4 )
      v6 = 128 - v33;
    n = v6;
    memcpy((void *)(v33 + a5 + 28), src, v6);
    *(_DWORD *)(a5 + 24) += n;
    v7 = *(_DWORD *)(a5 + 24);
    _CF = v7 < 0x40;
    _OF = __OFSUB__(v7, 64);
    _ZF = v7 == 64;
    _SF = (signed int)(v7 - 64) < 0;
    if ( v7 > 0x40 )
    {
      __asm { pushfw }
      v12 = _InterlockedExchange(&dword_805B16C, a2);
      v15 = _InterlockedExchange(&dword_805B16C, a1);
      v13 = v12;
      v14 = v15;
      v16 = sub_804B058(
              v7 < 0x40,
              v7 == 64,
              (signed int)(v7 - 64) < 0,
              __OFSUB__(v7, 64),
              _InterlockedExchange(&dword_805B16C, v13),
              v15);
      if ( v16 != -812 )
        sub_804B0A0(
          v16 < 0xFFFFFCD4,
          v16 == -812,
          (signed int)(v16 + 812) < 0,
          __OFSUB__(v16, -812),
          _InterlockedExchange(&dword_805B16C, _InterlockedExchange(&dword_805B16C, v14)),
          v18,
          _InterlockedExchange(&dword_805B16C, v17));
      __asm { popfw }
      sub_804EB80(
        *(_DWORD *)(a5 + 24) & 0xFFFFFFC0,
        v14,
        (int *)(a5 + 28),
        *(_DWORD *)(a5 + 24) & 0xFFFFFFC0,
        (int *)a5);
      *(_DWORD *)(a5 + 24) &= 0x3Fu;
      a2 = a5 + 28;
      memcpy((void *)(a5 + 28), (const void *)(a5 + 28 + ((v33 + n) & 0xFFFFFFC0)), *(_DWORD *)(a5 + 24));
    }
    src = (char *)src + n;
    result = (int *)n;
    a4 -= n;
  }
  if ( a4 > 0x3F )
  {
    result = (int *)((unsigned __int8)src & 3);
    if ( (unsigned __int8)src & 3 )
    {
      while ( a4 > 0x40 )
      {
        v19 = (int *)memcpy((void *)(a5 + 28), src, 0x40u);
        result = sub_804EB80(v20, a2, v19, 0x40u, (int *)a5);
        src = (char *)src + 64;
        a4 -= 64;
      }
    }
    else
    {
      sub_804EB80(a1, a2, (int *)src, a4 & 0xFFFFFFC0, (int *)a5);
      result = (int *)(a4 & 0xFFFFFFC0);
      src = (char *)src + (a4 & 0xFFFFFFC0);
      a4 &= 0x3Fu;
    }
  }
  if ( a4 )
  {
    v31 = *(_DWORD *)(a5 + 24);
    memcpy((void *)(v31 + a5 + 28), src, a4);
    v32 = a4 + v31;
    _CF = v32 < 0x3F;
    _OF = __OFSUB__(v32, 63);
    _ZF = v32 == 63;
    _SF = (signed int)(v32 - 63) < 0;
    if ( v32 > 0x3F )
    {
      __asm { pushfw }
      v30 = a2;
      if ( a2 >= 10 )
      {
        v27 = a2;
        v28 = _InterlockedExchange(&dword_805B13C, a2);
        v29 = _InterlockedExchange(&dword_805B13C, v21);
        _InterlockedExchange(&dword_805B13C, v28);
        if ( (v29 - 1) * v27 & 1 )
          abort();
      }
      __asm { popfw }
      sub_804EB80(v22, v30, (int *)(a5 + 28), 0x40u, (int *)a5);
      v32 -= 64;
      memcpy((void *)(a5 + 28), (const void *)(a5 + 92), v32);
    }
    result = (int *)a5;
    *(_DWORD *)(a5 + 24) = v32;
  }
  return result;
}
// 805B13C: using guessed type int dword_805B13C;
// 805B16C: using guessed type int dword_805B16C;

//----- (0804EB80) --------------------------------------------------------
int *__usercall sub_804EB80@<eax>(int a1@<ecx>, signed __int32 a2@<ebx>, int *a3, unsigned int a4, int *a5)
{
  int v5; // edx
  _BOOL4 v6; // eax
  int v11; // edx
  signed __int32 v12; // eax
  int v13; // ST3C_4
  int v14; // ST40_4
  int v15; // ST44_4
  int v16; // ST48_4
  int v17; // ST4C_4
  int v18; // ST1C_4
  int *v19; // ST18_4
  int v20; // ST1C_4
  int v21; // ST50_4
  int v22; // ST28_4
  int v23; // ST54_4
  int v24; // ST24_4
  int v25; // ST58_4
  int v26; // ST20_4
  int v27; // ST5C_4
  int v28; // ST1C_4
  int v29; // ST60_4
  int v30; // ST28_4
  int v31; // ST64_4
  int v32; // ST24_4
  int v33; // ST68_4
  int v34; // ST20_4
  int v35; // ST6C_4
  int v36; // ST1C_4
  int v37; // ST70_4
  int v38; // ST28_4
  int v39; // ST74_4
  int v40; // ST24_4
  int v41; // ST78_4
  int v42; // ST20_4
  int v43; // ST7C_4
  int v44; // ST1C_4
  int v45; // ST80_4
  int v46; // ST28_4
  int v47; // ST84_4
  int v48; // ST24_4
  int v49; // ST88_4
  int v50; // ST20_4
  int v51; // ST1C_4
  int v52; // ST28_4
  int v53; // ST24_4
  int v54; // ST20_4
  int v55; // ST1C_4
  int v56; // ST28_4
  int v57; // ST24_4
  int v58; // ST20_4
  int v59; // ST1C_4
  int v60; // ST28_4
  int v61; // ST24_4
  int v62; // ST20_4
  int v63; // ST1C_4
  int v64; // ST28_4
  int v65; // ST24_4
  int v66; // ST20_4
  int v67; // ST1C_4
  int v68; // ST28_4
  int v69; // ST24_4
  int v70; // ST20_4
  int v71; // ST1C_4
  int v72; // ST28_4
  int v73; // ST24_4
  int v74; // ST20_4
  int v75; // ST1C_4
  int v76; // ST28_4
  int v77; // ST24_4
  int v78; // ST20_4
  int v79; // ST1C_4
  int v80; // ST28_4
  int v81; // ST24_4
  int v82; // ST20_4
  int v83; // ST1C_4
  int v84; // ST28_4
  int v85; // ST24_4
  int v86; // ST20_4
  int v87; // ST1C_4
  int v88; // ST28_4
  int v89; // ST24_4
  int v90; // ST20_4
  int v91; // ST1C_4
  int v92; // ST28_4
  int v93; // ST24_4
  int v94; // ST20_4
  int v95; // ST1C_4
  int v96; // ST28_4
  int v97; // ST24_4
  int v98; // ST20_4
  int *result; // eax
  signed __int32 v100; // eax
  unsigned int v101; // eax
  signed __int32 v102; // edx
  int *v103; // [esp+Ch] [ebp-74h]
  int v104; // [esp+10h] [ebp-70h]
  int v105; // [esp+14h] [ebp-6Ch]
  int v106; // [esp+18h] [ebp-68h]
  int v107; // [esp+1Ch] [ebp-64h]

  v103 = a3;
  v104 = *a5;
  v105 = a5[1];
  v106 = a5[2];
  v107 = a5[3];
  a5[4] += a4;
  v5 = a5[5];
  v6 = a5[4] < a4;
  _CF = __CFADD__(v6, v5);
  _OF = __OFADD__(v6, v5);
  _ZF = v6 + v5 == 0;
  _SF = v6 + v5 < 0;
  v11 = v6 + v5;
  v12 = (signed __int32)a5;
  a5[5] = v11;
  while ( 1 )
  {
    __asm { pushfw }
    v100 = _InterlockedExchange(&dword_805B124, v12);
    _InterlockedExchange(&dword_805B124, a1);
    _InterlockedExchange(&dword_805B124, v100);
    v101 = sub_805194D();
    if ( v101 != 44 )
      sub_8051957(
        v101 < 0x2C,
        v101 == 44,
        (signed int)(v101 - 44) < 0,
        __OFSUB__(v101, 44),
        _InterlockedExchange(&dword_805B124, _InterlockedExchange(&dword_805B124, a2)),
        _InterlockedExchange(&dword_805B124, v102));
    __asm { popfw }
    if ( v103 >= &a3[a4 >> 2] )
      break;
    v13 = v104;
    v14 = v105;
    v15 = v106;
    v16 = v107;
    v17 = *v103;
    v18 = (v107 ^ v105 & (v106 ^ v107)) + *v103 + v104 - 680876936;
    v19 = v103 + 1;
    v20 = v105 + __ROR4__(v18, 25);
    v21 = *v19;
    ++v19;
    v22 = v20 + __ROR4__((v106 ^ v20 & (v105 ^ v106)) + v21 + v107 - 389564586, 20);
    v23 = *v19;
    ++v19;
    v24 = v22 + __ROR4__((v105 ^ v22 & (v20 ^ v105)) + v23 + v106 + 606105819, 15);
    v25 = *v19;
    ++v19;
    v26 = v24 + __ROR4__((v20 ^ v24 & (v22 ^ v20)) + v25 + v105 - 1044525330, 10);
    v27 = *v19;
    ++v19;
    v28 = v26 + __ROR4__((v22 ^ v26 & (v24 ^ v22)) + v27 + v20 - 176418897, 25);
    v29 = *v19;
    ++v19;
    v30 = v28 + __ROR4__((v24 ^ v28 & (v26 ^ v24)) + v29 + v22 + 1200080426, 20);
    v31 = *v19;
    ++v19;
    v32 = v30 + __ROR4__((v26 ^ v30 & (v28 ^ v26)) + v31 + v24 - 1473231341, 15);
    v33 = *v19;
    ++v19;
    v34 = v32 + __ROR4__((v28 ^ v32 & (v30 ^ v28)) + v33 + v26 - 45705983, 10);
    v35 = *v19;
    ++v19;
    v36 = v34 + __ROR4__((v30 ^ v34 & (v32 ^ v30)) + v35 + v28 + 1770035416, 25);
    v37 = *v19;
    ++v19;
    v38 = v36 + __ROR4__((v32 ^ v36 & (v34 ^ v32)) + v37 + v30 - 1958414417, 20);
    v39 = *v19;
    ++v19;
    v40 = v38 + __ROR4__((v34 ^ v38 & (v36 ^ v34)) + v39 + v32 - 42063, 15);
    v41 = *v19;
    ++v19;
    v42 = v40 + __ROR4__((v36 ^ v40 & (v38 ^ v36)) + v41 + v34 - 1990404162, 10);
    v43 = *v19;
    ++v19;
    v44 = v42 + __ROR4__((v38 ^ v42 & (v40 ^ v38)) + v43 + v36 + 1804603682, 25);
    v45 = *v19;
    ++v19;
    v46 = v44 + __ROR4__((v40 ^ v44 & (v42 ^ v40)) + v45 + v38 - 40341101, 20);
    v47 = *v19;
    ++v19;
    v48 = v46 + __ROR4__((v42 ^ v46 & (v44 ^ v42)) + v47 + v40 - 1502002290, 15);
    a1 = v44 ^ v48 & (v46 ^ v44);
    v49 = *v19;
    v103 = v19 + 1;
    v50 = v48 + __ROR4__(a1 + v49 + v42 + 1236535329, 10);
    v51 = v50 + __ROR4__(v21 + (v48 ^ v46 & (v50 ^ v48)) + v44 - 165796510, 27);
    v52 = v51 + __ROR4__(v31 + (v50 ^ v48 & (v51 ^ v50)) + v46 - 1069501632, 23);
    v53 = v52 + __ROR4__(v41 + (v51 ^ v50 & (v52 ^ v51)) + v48 + 643717713, 18);
    v54 = v53 + __ROR4__(v17 + (v52 ^ v51 & (v53 ^ v52)) + v50 - 373897302, 12);
    v55 = v54 + __ROR4__(v29 + (v53 ^ v52 & (v54 ^ v53)) + v51 - 701558691, 27);
    v56 = v55 + __ROR4__(v39 + (v54 ^ v53 & (v55 ^ v54)) + v52 + 38016083, 23);
    v57 = v56 + __ROR4__(v49 + (v55 ^ v54 & (v56 ^ v55)) + v53 - 660478335, 18);
    v58 = v57 + __ROR4__(v27 + (v56 ^ v55 & (v57 ^ v56)) + v54 - 405537848, 12);
    v59 = v58 + __ROR4__(v37 + (v57 ^ v56 & (v58 ^ v57)) + v55 + 568446438, 27);
    v60 = v59 + __ROR4__(v47 + (v58 ^ v57 & (v59 ^ v58)) + v56 - 1019803690, 23);
    v61 = v60 + __ROR4__(v25 + (v59 ^ v58 & (v60 ^ v59)) + v57 - 187363961, 18);
    v62 = v61 + __ROR4__(v35 + (v60 ^ v59 & (v61 ^ v60)) + v58 + 1163531501, 12);
    v63 = v62 + __ROR4__(v45 + (v61 ^ v60 & (v62 ^ v61)) + v59 - 1444681467, 27);
    v64 = v63 + __ROR4__(v23 + (v62 ^ v61 & (v63 ^ v62)) + v60 - 51403784, 23);
    v65 = v64 + __ROR4__(v33 + (v63 ^ v62 & (v64 ^ v63)) + v61 + 1735328473, 18);
    v66 = v65 + __ROR4__(v43 + (v64 ^ v63 & (v65 ^ v64)) + v62 - 1926607734, 12);
    v67 = v66 + __ROR4__(v29 + (v64 ^ v66 ^ v65) + v63 - 378558, 28);
    v68 = v67 + __ROR4__(v35 + (v65 ^ v67 ^ v66) + v64 - 2022574463, 21);
    v69 = v68 + __ROR4__(v41 + (v66 ^ v68 ^ v67) + v65 + 1839030562, 16);
    v70 = v69 + __ROR4__(v47 + (v67 ^ v69 ^ v68) + v66 - 35309556, 9);
    v71 = v70 + __ROR4__(v21 + (v68 ^ v70 ^ v69) + v67 - 1530992060, 28);
    v72 = v71 + __ROR4__(v27 + (v69 ^ v71 ^ v70) + v68 + 1272893353, 21);
    v73 = v72 + __ROR4__(v33 + (v70 ^ v72 ^ v71) + v69 - 155497632, 16);
    v74 = v73 + __ROR4__(v39 + (v71 ^ v73 ^ v72) + v70 - 1094730640, 9);
    v75 = v74 + __ROR4__(v45 + (v72 ^ v74 ^ v73) + v71 + 681279174, 28);
    v76 = v75 + __ROR4__(v17 + (v73 ^ v75 ^ v74) + v72 - 358537222, 21);
    v77 = v76 + __ROR4__(v25 + (v74 ^ v76 ^ v75) + v73 - 722521979, 16);
    v78 = v77 + __ROR4__(v31 + (v75 ^ v77 ^ v76) + v74 + 76029189, 9);
    v79 = v78 + __ROR4__(v37 + (v76 ^ v78 ^ v77) + v75 - 640364487, 28);
    v80 = v79 + __ROR4__(v43 + (v77 ^ v79 ^ v78) + v76 - 421815835, 21);
    v81 = v80 + __ROR4__(v49 + (v78 ^ v80 ^ v79) + v77 + 530742520, 16);
    v82 = v81 + __ROR4__(v23 + (v79 ^ v81 ^ v80) + v78 - 995338651, 9);
    v83 = v82 + __ROR4__(v17 + (v81 ^ (v82 | ~v80)) + v79 - 198630844, 26);
    v84 = v83 + __ROR4__(v33 + (v82 ^ (v83 | ~v81)) + v80 + 1126891415, 22);
    v85 = v84 + __ROR4__(v47 + (v83 ^ (v84 | ~v82)) + v81 - 1416354905, 17);
    v86 = v85 + __ROR4__(v29 + (v84 ^ (v85 | ~v83)) + v82 - 57434055, 11);
    v87 = v86 + __ROR4__(v43 + (v85 ^ (v86 | ~v84)) + v83 + 1700485571, 26);
    v88 = v87 + __ROR4__(v25 + (v86 ^ (v87 | ~v85)) + v84 - 1894986606, 22);
    v89 = v88 + __ROR4__(v39 + (v87 ^ (v88 | ~v86)) + v85 - 1051523, 17);
    v90 = v89 + __ROR4__(v21 + (v88 ^ (v89 | ~v87)) + v86 - 2054922799, 11);
    v91 = v90 + __ROR4__(v35 + (v89 ^ (v90 | ~v88)) + v87 + 1873313359, 26);
    v92 = v91 + __ROR4__(v49 + (v90 ^ (v91 | ~v89)) + v88 - 30611744, 22);
    v93 = v92 + __ROR4__(v31 + (v91 ^ (v92 | ~v90)) + v89 - 1560198380, 17);
    v94 = v93 + __ROR4__(v45 + (v92 ^ (v93 | ~v91)) + v90 + 1309151649, 11);
    v95 = v94 + __ROR4__(v27 + (v93 ^ (v94 | ~v92)) + v91 - 145523070, 26);
    v96 = v95 + __ROR4__(v41 + (v94 ^ (v95 | ~v93)) + v92 - 1120210379, 22);
    v97 = v96 + __ROR4__(v23 + (v95 ^ (v96 | ~v94)) + v93 + 718787259, 17);
    v98 = v97 + __ROR4__(v37 + (v96 ^ (v97 | ~v95)) + v94 - 343485551, 11);
    v104 = v13 + v95;
    v105 = v14 + v98;
    v106 = v15 + v97;
    v12 = v16;
    _CF = __CFADD__(v16, v96);
    _OF = __OFADD__(v16, v96);
    _ZF = v16 + v96 == 0;
    _SF = v16 + v96 < 0;
    v107 = v16 + v96;
  }
  *a5 = v104;
  a5[1] = v105;
  a5[2] = v106;
  result = a5;
  a5[3] = v107;
  return result;
}
// 805B124: using guessed type int dword_805B124;

//----- (0804F9C5) --------------------------------------------------------
int __usercall sub_804F9C5@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, int a8@<ebp>, int a9, int a10, int a11, int a12, int a13, int a14)
{
  char v14; // al
  signed __int32 v15; // et0
  signed __int32 v16; // eax
  signed __int32 v17; // eax
  int v18; // edx
  signed __int32 v19; // ecx
  signed __int32 v20; // eax
  signed __int32 v21; // ebx
  signed __int32 v22; // edx
  signed __int32 v23; // edx
  signed __int32 v24; // ebx
  signed __int32 v25; // ett
  signed __int32 v26; // ecx
  unsigned int v27; // eax
  signed __int32 v28; // edx
  int v29; // ecx
  char v34; // al
  signed __int32 v35; // et0
  signed __int32 v36; // eax
  int v38; // [esp+18h] [ebp-34h]
  int v39; // [esp+1Ch] [ebp-30h]
  int v40; // [esp+30h] [ebp-1Ch]
  int v41; // [esp+34h] [ebp-18h]
  int v42; // [esp+38h] [ebp-14h]
  int v43; // [esp+3Ch] [ebp-10h]
  __int64 v44; // [esp+40h] [ebp-Ch]
  signed __int32 v45; // [esp+42h] [ebp-Ah]
  int v46; // [esp+48h] [ebp-4h]

  v46 = a5;
  __asm { pushfw }
  *(_DWORD *)((char *)&v44 + 2) = a7;
  if ( a7 >= 10 )
  {
    v15 = _InterlockedExchange(&dword_805B178, a7);
    v14 = _InterlockedExchange(&dword_805B178, a6);
    a6 = _InterlockedExchange(&dword_805B178, v15);
    if ( ((_BYTE)a7 - 1) * v14 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  v16 = _InterlockedExchange(&dword_805B184, v46);
  _InterlockedExchange(&dword_805B184, a6);
  v17 = sub_80525AB(_CF, _ZF, _SF, _OF, _InterlockedExchange(&dword_805B184, v16), a7);
  if ( v17 != -398 )
  {
    v20 = _InterlockedExchange(&dword_805B184, v17);
    _InterlockedExchange(&dword_805B184, v19);
    sub_805267B(_InterlockedExchange(&dword_805B184, v20), v18);
  }
  __asm { popfw }
  v46 = posix_fadvise64(
          a9,
          a10,
          a11,
          a12,
          a13,
          a14,
          v38,
          v39,
          a12,
          a13,
          a10,
          a11,
          v40,
          v41,
          v42,
          v43,
          v44,
          HIDWORD(v44),
          a8);
  __asm { pushfw }
  v21 = _InterlockedExchange(&dword_805B184, a7);
  v25 = _InterlockedExchange(&dword_805B184, v22);
  v23 = v21;
  v24 = v25;
  _InterlockedExchange(&dword_805B184, v23);
  v27 = sub_80525AB(_CF, _ZF, _SF, _OF, v26, v25);
  _CF = v27 < 0xFFFFFE72;
  _OF = __OFSUB__(v27, -398);
  _ZF = v27 == -398;
  _SF = (signed int)(v27 + 398) < 0;
  if ( v27 != -398 )
  {
    v45 = v27;
    __asm { pushfw }
    if ( v24 >= 10 )
    {
      v35 = _InterlockedExchange(&dword_805B130, v24);
      v34 = _InterlockedExchange(&dword_805B130, v28);
      v28 = _InterlockedExchange(&dword_805B130, v35);
      if ( ((_BYTE)v24 - 1) * v34 & 1 )
        abort();
    }
    __asm { popfw }
    v36 = _InterlockedExchange(&dword_805B184, v45);
    _InterlockedExchange(&dword_805B184, v28);
    sub_805267B(v29, _InterlockedExchange(&dword_805B184, v36));
  }
  __asm { popfw }
  return v46;
}
// 804F9C5: could not find valid save-restore pair for ebp
// 8049050: using guessed type int __stdcall posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 805267B: using guessed type int __fastcall sub_805267B(_DWORD, _DWORD);
// 805B130: using guessed type int dword_805B130;
// 805B178: using guessed type int dword_805B178;
// 805B184: using guessed type int dword_805B184;

//----- (0804FAF9) --------------------------------------------------------
int __usercall sub_804FAF9@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, int a8@<ebp>, FILE *stream, int a10)
{
  signed __int32 v10; // ebx
  signed __int32 v11; // ecx
  signed __int32 v12; // ebx
  signed __int32 v13; // et0
  signed __int32 v14; // edx
  signed __int32 v15; // ecx
  signed __int32 v16; // ebx
  int v17; // eax
  signed __int32 v22; // eax
  signed __int32 v23; // edx
  int v24; // ecx
  signed __int32 v25; // ebx
  int v26; // eax
  char v27; // al
  signed __int32 v28; // ebx
  char v29; // t0
  signed __int32 v31; // ecx
  int v32; // [esp-4h] [ebp-30h]
  int v33; // [esp+28h] [ebp-4h]

  v33 = a5;
  __asm { pushfw }
  v10 = _InterlockedExchange(&dword_805B118, a7);
  v13 = _InterlockedExchange(&dword_805B118, a6);
  v11 = v10;
  v12 = v13;
  _InterlockedExchange(&dword_805B118, v11);
  if ( sub_80550AC() != 445 )
  {
    v16 = _InterlockedExchange(&dword_805B118, v12);
    _InterlockedExchange(&dword_805B118, v15);
    sub_80550B6(_InterlockedExchange(&dword_805B118, v16));
  }
  __asm { popfw }
  v17 = v33;
  v33 = a8;
  _CF = 0;
  _OF = 0;
  _ZF = stream == 0;
  _SF = (signed int)stream < 0;
  if ( stream )
  {
    __asm { pushfw }
    v22 = _InterlockedExchange(&dword_805B118, v17);
    _InterlockedExchange(&dword_805B118, v14);
    _InterlockedExchange(&dword_805B118, v22);
    if ( sub_80550AC() != 445 )
    {
      v25 = _InterlockedExchange(&dword_805B118, v12);
      _InterlockedExchange(&dword_805B118, v23);
      _InterlockedExchange(&dword_805B118, v25);
      sub_80550B6(v24);
    }
    __asm { popfw }
    v26 = fileno(stream);
    v17 = sub_804F9C5(_CF, _ZF, _SF, _OF, v26, v31, v12, (int)&v33, v26, 0, 0, 0, 0, a10);
  }
  v32 = v17;
  __asm { pushfw }
  if ( v12 >= 10 )
  {
    v27 = v12;
    v28 = _InterlockedExchange(&dword_805B13C, v12);
    v29 = _InterlockedExchange(&dword_805B13C, v15);
    _InterlockedExchange(&dword_805B13C, v28);
    if ( (v29 - 1) * v27 & 1 )
      abort();
  }
  __asm { popfw }
  return v32;
}
// 804FAF9: could not find valid save-restore pair for ebp
// 80550B6: using guessed type int __fastcall sub_80550B6(_DWORD);
// 805B118: using guessed type int dword_805B118;
// 805B13C: using guessed type int dword_805B13C;

//----- (0804FBC9) --------------------------------------------------------
signed int sub_804FBC9()
{
  return -580;
}

//----- (0804FBD3) --------------------------------------------------------
void __usercall __noreturn sub_804FBD3(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>)
{
  char v6; // al
  signed __int32 v7; // ebx
  char v8; // t0

  __asm { pushfw }
  if ( a6 >= 10 )
  {
    v6 = a6;
    v7 = _InterlockedExchange(&dword_805B118, a6);
    v8 = _InterlockedExchange(&dword_805B118, a5);
    _InterlockedExchange(&dword_805B118, v7);
    if ( (v8 - 1) * v6 & 1 )
      abort();
  }
  __asm { popfw }
  __halt();
  JUMPOUT(loc_804FC09);
}
// 805B118: using guessed type int dword_805B118;

//----- (0804FD03) --------------------------------------------------------
FILE *__usercall sub_804FD03@<eax>(signed __int32 a1@<ebx>, int a2, char *modes)
{
  signed __int32 v3; // edx
  char v8; // al
  signed __int32 v9; // et0
  int v11; // ST34_4
  int v12; // ST38_4
  FILE *stream; // [esp+1Ch] [ebp-1Ch]
  signed int v14; // [esp+20h] [ebp-18h]
  int fd; // [esp+24h] [ebp-14h]

  stream = (FILE *)fopen64(a2, modes);
  if ( !stream )
    return stream;
  v14 = fileno(stream);
  _CF = 0;
  _OF = 0;
  _ZF = v14 == 0;
  _SF = v14 < 0;
  if ( v14 < 0 )
    return stream;
  __asm { pushfw }
  if ( a1 >= 10 )
  {
    v9 = _InterlockedExchange(&dword_805B19C, a1);
    v8 = _InterlockedExchange(&dword_805B19C, v3);
    _InterlockedExchange(&dword_805B19C, v9);
    if ( ((_BYTE)a1 - 1) * v8 & 1 )
      abort();
  }
  __asm { popfw }
  if ( v14 > 2 )
    return stream;
  fd = sub_80527FB(a1, v14);
  if ( fd < 0 )
  {
    v11 = *__errno_location();
    sub_80539F0(a1, stream);
    *__errno_location() = v11;
    return 0;
  }
  if ( !sub_80539F0(a1, stream) )
  {
    stream = fdopen(fd, modes);
    if ( stream )
      return stream;
  }
  v12 = *__errno_location();
  close(fd);
  *__errno_location() = v12;
  return 0;
}
// 8048E10: using guessed type int __cdecl fopen64(_DWORD, _DWORD);
// 805B19C: using guessed type int dword_805B19C;

//----- (0804FE3A) --------------------------------------------------------
char *__cdecl sub_804FE3A(char *s)
{
  char *v1; // eax
  char *result; // eax
  char *v3; // [esp+18h] [ebp-10h]
  char *s1; // [esp+1Ch] [ebp-Ch]

  if ( !s )
  {
    fwrite(&unk_80569B0, 1u, 0x37u, stderr);
    abort();
  }
  v3 = strrchr(s, 47);
  if ( v3 )
    v1 = v3 + 1;
  else
    v1 = s;
  s1 = v1;
  if ( v1 - s > 6 && !strncmp(v1 - 7, "/.libs/", 7u) )
  {
    s = s1;
    if ( !strncmp(s1, "lt-", 3u) )
    {
      s = s1 + 3;
      program_invocation_short_name = (int)(s1 + 3);
    }
  }
  dword_805B6EF = (int)s;
  result = s;
  program_invocation_name = (int)s;
  return result;
}
// 805B240: using guessed type int program_invocation_short_name;
// 805B250: using guessed type int program_invocation_name;
// 805B6EF: using guessed type int dword_805B6EF;

//----- (08050064) --------------------------------------------------------
int __usercall sub_8050064@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, int *a3, unsigned __int8 a4, char a5)
{
  signed __int32 v9; // ebx
  signed __int32 v10; // ecx
  signed __int32 v11; // ebx
  signed __int32 v12; // et0
  unsigned __int32 v13; // eax
  int v14; // edx
  signed __int32 v15; // ecx
  signed __int32 v20; // eax
  char v21; // al
  signed __int32 v22; // et2
  int *v23; // eax
  int v24; // ST20_4

  _CF = 0;
  _OF = 0;
  _ZF = a3 == 0;
  _SF = (signed int)a3 < 0;
  if ( a3 )
  {
    __asm { pushfw }
    v9 = _InterlockedExchange(&dword_805B13C, a2);
    v12 = _InterlockedExchange(&dword_805B13C, a1);
    v10 = v9;
    v11 = v12;
    _InterlockedExchange(&dword_805B13C, v10);
    v13 = sub_8052670();
    _CF = v13 < 0xFFFFFFD7;
    _OF = __OFSUB__(v13, -41);
    _ZF = v13 == -41;
    _SF = (signed int)(v13 + 41) < 0;
    if ( v13 != -41 )
    {
      v20 = _InterlockedExchange(&dword_805B13C, v13);
      _InterlockedExchange(&dword_805B13C, v15);
      sub_805267A(_InterlockedExchange(&dword_805B13C, v20), v14);
    }
    __asm { pushfw }
    if ( v11 >= 10 )
    {
      v22 = _InterlockedExchange(&dword_805B130, v11);
      v21 = _InterlockedExchange(&dword_805B130, v15);
      _InterlockedExchange(&dword_805B130, v22);
      if ( ((_BYTE)v11 - 1) * v21 & 1 )
        abort();
    }
    __asm
    {
      popfw
      popfw
    }
    v23 = a3;
  }
  else
  {
    v23 = &dword_805B707;
  }
  v24 = ((unsigned int)v23[(a4 >> 5) + 2] >> (a4 & 0x1F)) & 1;
  v23[(a4 >> 5) + 2] ^= (v24 ^ a5 & 1) << (a4 & 0x1F);
  return v24;
}
// 805267A: using guessed type int __fastcall sub_805267A(_DWORD, _DWORD);
// 805B130: using guessed type int dword_805B130;
// 805B13C: using guessed type int dword_805B13C;
// 805B707: using guessed type int dword_805B707;

//----- (080501BB) --------------------------------------------------------
int *__usercall sub_80501BB@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>, int *a8, int a9, int a10)
{
  char v10; // al
  signed __int32 v11; // et0
  signed __int32 v12; // eax
  signed __int32 v17; // eax
  unsigned __int32 v18; // eax
  bool v19; // cf
  bool v20; // zf
  bool v21; // sf
  char v22; // of
  signed __int32 v23; // eax
  signed __int32 v24; // eax
  signed __int32 v25; // eax
  signed __int32 v26; // ecx
  signed __int32 v27; // eax
  int *result; // eax
  signed __int32 v29; // [esp-4h] [ebp-4h]

  v29 = a5;
  __asm { pushfw }
  if ( a7 >= 10 )
  {
    v11 = _InterlockedExchange(&dword_805B160, a7);
    v10 = _InterlockedExchange(&dword_805B160, a6);
    a6 = _InterlockedExchange(&dword_805B160, v11);
    if ( ((_BYTE)a7 - 1) * v10 & 1 )
      abort();
  }
  __asm { popfw }
  v12 = v29;
  _CF = 0;
  _OF = 0;
  _ZF = a8 == 0;
  _SF = (signed int)a8 < 0;
  if ( !a8 )
  {
    __asm { pushfw }
    v17 = _InterlockedExchange(&dword_805B124, v29);
    _InterlockedExchange(&dword_805B124, a6);
    _InterlockedExchange(&dword_805B124, v17);
    v18 = sub_805194D();
    v19 = v18 < 0x2C;
    v22 = __OFSUB__(v18, 44);
    v20 = v18 == 44;
    v21 = (signed int)(v18 - 44) < 0;
    if ( v18 != 44 )
    {
      v23 = _InterlockedExchange(&dword_805B124, v18);
      _InterlockedExchange(&dword_805B124, a6);
      sub_8051957(v19, v20, v21, v22, _InterlockedExchange(&dword_805B124, v23), a7);
    }
    __asm { popfw }
    v12 = v29;
    a8 = &dword_805B707;
  }
  __asm { pushfw }
  v24 = _InterlockedExchange(&dword_805B178, v12);
  _InterlockedExchange(&dword_805B178, a6);
  _InterlockedExchange(&dword_805B178, v24);
  v25 = sub_804A881();
  if ( v25 != 893 )
  {
    v27 = _InterlockedExchange(&dword_805B178, v25);
    _InterlockedExchange(&dword_805B178, v26);
    sub_804A88B(_InterlockedExchange(&dword_805B178, v27));
  }
  __asm { popfw }
  *a8 = 10;
  if ( !a9 || !a10 )
    abort();
  a8[10] = a9;
  result = a8;
  a8[11] = a10;
  return result;
}
// 80501BB: could not find valid save-restore pair for ebp
// 804A88B: using guessed type int __fastcall sub_804A88B(_DWORD);
// 805B124: using guessed type int dword_805B124;
// 805B160: using guessed type int dword_805B160;
// 805B178: using guessed type int dword_805B178;
// 805B707: using guessed type int dword_805B707;

//----- (080502A8) --------------------------------------------------------
unsigned int *__userpurge sub_80502A8@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>, unsigned int *a8, unsigned int a9)
{
  signed __int32 v9; // eax
  unsigned int v10; // eax
  signed __int32 v11; // edx
  signed __int32 v12; // ecx
  char v17; // al
  signed __int32 v18; // et1
  signed __int32 v19; // ebx
  signed __int32 v20; // ebx
  signed __int32 v21; // ecx
  signed __int32 v22; // ebx
  signed __int32 v23; // ett
  signed __int32 v24; // edx
  int v25; // ecx
  signed __int32 v26; // ebx
  char *v27; // ebx
  char v36; // al
  signed __int32 v37; // et1
  int v38; // eax
  char v39; // al
  signed __int32 v40; // ebx
  char v41; // t2
  signed __int32 v42; // eax
  signed __int32 v43; // edx
  int v44; // ecx
  signed __int32 v45; // ebx
  int *v47; // [esp-46h] [ebp-46h]
  int v48; // [esp-40h] [ebp-40h]
  int v49; // [esp-3Ch] [ebp-3Ch]
  unsigned int v50; // [esp-38h] [ebp-38h]
  unsigned int v51; // [esp-34h] [ebp-34h]
  unsigned int v52; // [esp-30h] [ebp-30h]
  unsigned int v53; // [esp-2Ch] [ebp-2Ch]
  unsigned int v54; // [esp-28h] [ebp-28h]
  unsigned int v55; // [esp-24h] [ebp-24h]
  unsigned int v56; // [esp-20h] [ebp-20h]
  unsigned int v57; // [esp-1Ch] [ebp-1Ch]
  unsigned int v58; // [esp-18h] [ebp-18h]
  unsigned int v59; // [esp-14h] [ebp-14h]
  signed __int32 v60; // [esp-10h] [ebp-10h]
  signed __int32 v61; // [esp-Ch] [ebp-Ch]
  signed int v62; // [esp-Ah] [ebp-Ah]
  signed __int32 v63; // [esp-4h] [ebp-4h]

  v63 = a5;
  __asm { pushfw }
  v9 = _InterlockedExchange(&dword_805B148, a5);
  _InterlockedExchange(&dword_805B148, a6);
  _InterlockedExchange(&dword_805B148, v9);
  v10 = sub_80537D9();
  _CF = v10 < 0x35E;
  _OF = __OFSUB__(v10, 862);
  _ZF = v10 == 862;
  _SF = (signed int)(v10 - 862) < 0;
  if ( v10 != 862 )
  {
    v62 = v10;
    __asm { pushfw }
    v60 = a7;
    if ( a7 >= 10 )
    {
      v18 = _InterlockedExchange(&dword_805B118, a7);
      v17 = _InterlockedExchange(&dword_805B118, v12);
      v12 = _InterlockedExchange(&dword_805B118, v18);
      if ( ((_BYTE)a7 - 1) * v17 & 1 )
        abort();
    }
    __asm { popfw }
    v19 = _InterlockedExchange(&dword_805B148, v60);
    _InterlockedExchange(&dword_805B148, v11);
    sub_80537E3(v12, _InterlockedExchange(&dword_805B148, v19));
  }
  v62 = 862;
  __asm { pushfw }
  v20 = _InterlockedExchange(&dword_805B10C, a7);
  v23 = _InterlockedExchange(&dword_805B10C, v12);
  v21 = v20;
  v22 = v23;
  _InterlockedExchange(&dword_805B10C, v21);
  if ( sub_8052466() != -423 )
  {
    v26 = _InterlockedExchange(&dword_805B10C, v22);
    _InterlockedExchange(&dword_805B10C, v24);
    _InterlockedExchange(&dword_805B10C, v26);
    sub_8052470(v25);
  }
  __asm
  {
    popfw
    popfw
  }
  v61 = v22;
  v27 = (char *)&v49;
  memset(&v49, 0, 0x30u);
  _CF = a9 < 0xA;
  _OF = __OFSUB__(a9, 10);
  _ZF = a9 == 10;
  _SF = (signed int)(a9 - 10) < 0;
  if ( a9 == 10 )
  {
    v48 = 0;
    __asm { pushfw }
    v47 = &v49;
    _CF = (unsigned int)&v49 < 0xA;
    _OF = __OFSUB__(&v49, 10);
    _ZF = &v49 == (int *)10;
    _SF = (signed int)&v47 < 0;
    if ( (signed int)&v49 >= 10 )
    {
      v37 = _InterlockedExchange(&dword_805B190, (signed __int32)&v49);
      v36 = _InterlockedExchange(&dword_805B190, 0);
      _InterlockedExchange(&dword_805B190, v37);
      v27 = (char *)&v48 + 3;
      v38 = (unsigned __int8)((char *)&v48 + 3) * v36 & 1;
      _CF = 0;
      _OF = 0;
      _ZF = v38 == 0;
      _SF = v38 < 0;
      if ( v38 )
        abort();
    }
    __asm { pushfw }
    if ( (signed int)v27 >= 10 )
    {
      v39 = (char)v27;
      v40 = _InterlockedExchange(&dword_805B124, (signed __int32)v27);
      v41 = _InterlockedExchange(&dword_805B124, 12);
      _InterlockedExchange(&dword_805B124, v40);
      if ( (v41 - 1) * v39 & 1 )
        abort();
    }
    __asm
    {
      popfw
      popfw
    }
    abort();
  }
  v48 = 0;
  __asm { pushfw }
  v42 = _InterlockedExchange(&dword_805B178, 0);
  _InterlockedExchange(&dword_805B178, 12);
  _InterlockedExchange(&dword_805B178, v42);
  if ( sub_804A881() != 893 )
  {
    v45 = _InterlockedExchange(&dword_805B178, (signed __int32)&v49);
    _InterlockedExchange(&dword_805B178, v43);
    _InterlockedExchange(&dword_805B178, v45);
    sub_804A88B(v44);
  }
  __asm { popfw }
  *a8 = a9;
  a8[1] = v50;
  a8[2] = v51;
  a8[3] = v52;
  a8[4] = v53;
  a8[5] = v54;
  a8[6] = v55;
  a8[7] = v56;
  a8[8] = v57;
  a8[9] = v58;
  a8[10] = v59;
  a8[11] = v60;
  return a8;
}
// 804A88B: using guessed type int __fastcall sub_804A88B(_DWORD);
// 8052470: using guessed type int __fastcall sub_8052470(_DWORD);
// 80537E3: using guessed type int __fastcall sub_80537E3(_DWORD, _DWORD);
// 805B10C: using guessed type int dword_805B10C;
// 805B118: using guessed type int dword_805B118;
// 805B124: using guessed type int dword_805B124;
// 805B148: using guessed type int dword_805B148;
// 805B178: using guessed type int dword_805B178;
// 805B190: using guessed type int dword_805B190;

//----- (08050482) --------------------------------------------------------
const char *__usercall sub_8050482@<eax>(signed __int32 a1@<ebx>, char *msgid, int a3)
{
  const char *result; // eax
  signed __int32 v4; // edx
  signed __int32 v5; // ecx
  signed __int32 v6; // edx
  signed __int32 v7; // ecx
  int v8; // eax
  signed __int32 v9; // ecx
  signed __int32 v14; // eax
  unsigned __int32 v15; // eax
  signed __int32 v16; // edx
  signed __int32 v17; // ecx
  bool v18; // cf
  bool v19; // zf
  bool v20; // sf
  char v21; // of
  signed __int32 v22; // eax
  signed __int32 v23; // eax
  signed __int32 v28; // eax
  signed __int32 v29; // ecx
  signed __int32 v30; // ebx
  char *v31; // [esp+18h] [ebp-10h]
  unsigned __int8 *v32; // [esp+1Ch] [ebp-Ch]

  v31 = gettext(msgid);
  if ( v31 != msgid )
    return v31;
  v32 = (unsigned __int8 *)sub_8054CB5(a1);
  if ( sub_80543EB((signed __int32)v32, v4, v5, v32, (unsigned __int32)"UTF-8") )
  {
    v8 = sub_80543EB((signed __int32)v32, v6, v7, v32, (unsigned __int32)"GB18030");
    _CF = 0;
    _OF = 0;
    _ZF = v8 == 0;
    _SF = v8 < 0;
    if ( v8 )
    {
      if ( a3 == 9 )
        result = (const char *)&unk_8056AF5;
      else
        result = "'";
    }
    else
    {
      __asm { pushfw }
      v14 = _InterlockedExchange(&dword_805B16C, 0);
      _InterlockedExchange(&dword_805B16C, v9);
      v15 = sub_804B058(0, _ZF, _SF, 0, _InterlockedExchange(&dword_805B16C, v14), a1);
      v18 = v15 < 0xFFFFFCD4;
      v21 = __OFSUB__(v15, -812);
      v19 = v15 == -812;
      v20 = (signed int)(v15 + 812) < 0;
      if ( v15 != -812 )
      {
        v22 = _InterlockedExchange(&dword_805B16C, v15);
        _InterlockedExchange(&dword_805B16C, v16);
        sub_804B0A0(v18, v19, v20, v21, _InterlockedExchange(&dword_805B16C, v22), v17, a1);
      }
      __asm { popfw }
      v23 = (unsigned __int8)*msgid;
      _CF = (unsigned __int8)v23 < 0x60u;
      _OF = __OFSUB__((_BYTE)v23, 96);
      _ZF = (_BYTE)v23 == 96;
      _SF = (char)(v23 - 96) < 0;
      if ( (_BYTE)v23 == 96 )
      {
        result = (const char *)&unk_8056AEE;
      }
      else
      {
        __asm { pushfw }
        v28 = _InterlockedExchange(&dword_805B118, v23);
        _InterlockedExchange(&dword_805B118, v16);
        _InterlockedExchange(&dword_805B118, v28);
        if ( sub_80550AC() != 445 )
        {
          v30 = _InterlockedExchange(&dword_805B118, a1);
          _InterlockedExchange(&dword_805B118, v29);
          sub_80550B6(_InterlockedExchange(&dword_805B118, v30));
        }
        __asm { popfw }
        result = (const char *)&unk_8056AF2;
      }
    }
  }
  else if ( *msgid == 96 )
  {
    result = (const char *)&unk_8056ADE;
  }
  else
  {
    result = (const char *)&unk_8056AE2;
  }
  return result;
}
// 80550B6: using guessed type int __fastcall sub_80550B6(_DWORD);
// 805B118: using guessed type int dword_805B118;
// 805B16C: using guessed type int dword_805B16C;

//----- (080505A2) --------------------------------------------------------
unsigned int __usercall sub_80505A2@<eax>(signed __int32 a1@<ebx>, signed __int32 a2, unsigned int a3, signed __int32 a4, size_t a5, unsigned int a6, int a7, int a8, char *a9, char *a10)
{
  signed __int32 v10; // edx
  int v11; // ecx
  int v12; // eax
  char v17; // al
  signed __int32 v18; // ebx
  char v19; // t0
  size_t v20; // eax
  unsigned __int8 v25; // al
  unsigned __int8 v26; // al
  int v27; // eax
  char v28; // al
  signed __int32 v29; // ebx
  char v30; // t1
  bool v31; // al
  const unsigned __int16 **v32; // eax
  signed __int32 v37; // eax
  int v38; // edx
  signed __int32 v39; // ecx
  signed __int32 v40; // ebx
  bool v41; // al
  unsigned int result; // eax
  signed __int32 v43; // [esp-Ah] [ebp-92h]
  signed __int32 v44; // [esp-Ah] [ebp-92h]
  char *v45; // [esp+2Ch] [ebp-5Ch]
  char *v46; // [esp+30h] [ebp-58h]
  char v47; // [esp+40h] [ebp-48h]
  bool v48; // [esp+41h] [ebp-47h]
  char v49; // [esp+42h] [ebp-46h]
  char v50; // [esp+43h] [ebp-45h]
  char v51; // [esp+44h] [ebp-44h]
  unsigned __int8 v52; // [esp+45h] [ebp-43h]
  char v53; // [esp+46h] [ebp-42h]
  char v54; // [esp+47h] [ebp-41h]
  char v55; // [esp+48h] [ebp-40h]
  char v56; // [esp+49h] [ebp-3Fh]
  bool v57; // [esp+4Ah] [ebp-3Eh]
  bool v58; // [esp+4Bh] [ebp-3Dh]
  wint_t wc; // [esp+4Ch] [ebp-3Ch]
  int i; // [esp+50h] [ebp-38h]
  unsigned int v61; // [esp+54h] [ebp-34h]
  int v62; // [esp+58h] [ebp-30h]
  char *s; // [esp+5Ch] [ebp-2Ch]
  size_t n; // [esp+60h] [ebp-28h]
  unsigned int v65; // [esp+64h] [ebp-24h]
  unsigned int v66; // [esp+68h] [ebp-20h]
  size_t v67; // [esp+6Ch] [ebp-1Ch]
  unsigned int v68; // [esp+70h] [ebp-18h]
  mbstate_t ps; // [esp+74h] [ebp-14h]
  unsigned int v70; // [esp+7Ch] [ebp-Ch]

  v46 = a9;
  v45 = a10;
  v70 = __readgsdword(0x14u);
  v61 = 0;
  v62 = 0;
  s = 0;
  n = 0;
  v47 = 0;
  v58 = __ctype_get_mb_cur_max() == 1;
  v12 = a7 & 2;
  _CF = 0;
  _OF = 0;
  _ZF = v12 == 0;
  _SF = v12 < 0;
  v48 = v12 != 0;
  v49 = 0;
  v50 = 0;
  v51 = 1;
LABEL_2:
  switch ( a6 )
  {
    case 0u:
      v48 = 0;
      break;
    case 1u:
      goto LABEL_23;
    case 2u:
      goto LABEL_26;
    case 3u:
      v47 = 1;
LABEL_23:
      v48 = 1;
      goto LABEL_24;
    case 4u:
LABEL_24:
      if ( v48 != 1 )
        v47 = 1;
LABEL_26:
      a6 = 2;
      if ( v48 != 1 )
      {
        if ( v61 < a3 )
        {
          v10 = a2;
          *(_BYTE *)(a2 + v61) = 39;
        }
        ++v61;
      }
      s = "'";
      n = 1;
      break;
    case 5u:
      goto LABEL_7;
    case 6u:
      __asm { pushfw }
      v43 = a1;
      if ( a1 >= 10 )
      {
        v17 = a1;
        v18 = _InterlockedExchange(&dword_805B154, a1);
        v19 = _InterlockedExchange(&dword_805B154, v10);
        v10 = _InterlockedExchange(&dword_805B154, v18);
        if ( (v19 - 1) * v17 & 1 )
          abort();
      }
      a1 = v43;
      __asm { popfw }
      a6 = 5;
      v48 = 1;
LABEL_7:
      if ( v48 != 1 )
      {
        if ( v61 < a3 )
        {
          v10 = a2;
          *(_BYTE *)(a2 + v61) = 34;
        }
        ++v61;
      }
      v47 = 1;
      s = (char *)&unk_8056AF5;
      n = 1;
      break;
    case 7u:
      v47 = 1;
      v48 = 0;
      break;
    case 8u:
    case 9u:
    case 0xAu:
      if ( a6 != 10 )
      {
        v46 = (char *)sub_8050482(a1, "`", a6);
        v45 = (char *)sub_8050482(a1, "'", a6);
      }
      if ( v48 != 1 )
      {
        for ( s = v46; *s; ++s )
        {
          if ( v61 < a3 )
            *(_BYTE *)(v61 + a2) = *s;
          ++v61;
        }
      }
      v47 = 1;
      s = v45;
      n = strlen(v45);
      break;
    default:
      abort();
      return result;
  }
  for ( i = 0; ; ++i )
  {
    if ( a5 == -1 )
    {
      v10 = a4;
      v41 = *(_BYTE *)(a4 + i) != 0;
    }
    else
    {
      v41 = i != a5;
    }
    if ( !v41 )
    {
      if ( !v61 && a6 == 2 && v48 )
        goto LABEL_255;
      if ( a6 != 2 || v48 == 1 || !v50 )
        goto LABEL_262;
      if ( v51 )
        return sub_80505A2(a2, v62, a4, a5, 5, a7, a8, v46, v45);
      if ( a3 || (_CF = 0, _OF = 0, _ZF = v62 == 0, _SF = v62 < 0, !v62) )
      {
LABEL_262:
        if ( s && v48 != 1 )
        {
          while ( *s )
          {
            if ( v61 < a3 )
              *(_BYTE *)(v61 + a2) = *s;
            ++v61;
            ++s;
          }
        }
        if ( v61 < a3 )
          *(_BYTE *)(a2 + v61) = 0;
        return v61;
      }
      a3 = v62;
      v61 = 0;
      goto LABEL_2;
    }
    v54 = 0;
    v55 = 0;
    v56 = 0;
    if ( v47 && a6 != 2 && n )
    {
      a1 = i + n;
      if ( a5 != -1 || n <= 1 )
      {
        v20 = a5;
      }
      else
      {
        v20 = strlen((const char *)a4);
        a5 = v20;
      }
      if ( a1 <= v20 && !memcmp((const void *)(i + a4), s, n) )
      {
        if ( v48 )
          goto LABEL_255;
        v54 = 1;
      }
    }
    v10 = a4;
    v52 = *(_BYTE *)(a4 + i);
    switch ( v52 )
    {
      case 0u:
        if ( v47 )
        {
          if ( v48 )
            goto LABEL_255;
          v55 = 1;
          if ( a6 == 2 && v49 != 1 )
          {
            if ( v61 < a3 )
            {
              v10 = a2;
              *(_BYTE *)(a2 + v61) = 39;
            }
            if ( ++v61 < a3 )
            {
              v10 = a2;
              *(_BYTE *)(a2 + v61) = 36;
            }
            if ( ++v61 < a3 )
            {
              v10 = a2;
              *(_BYTE *)(a2 + v61) = 39;
            }
            ++v61;
            v49 = 1;
          }
          if ( v61 < a3 )
          {
            v10 = a2;
            *(_BYTE *)(a2 + v61) = 92;
          }
          ++v61;
          _CF = a6 < 2;
          _OF = __OFSUB__(a6, 2);
          _ZF = a6 == 2;
          _SF = (signed int)(a6 - 2) < 0;
          if ( a6 != 2 )
          {
            _CF = i + 1 < a5;
            _OF = __OFSUB__(i + 1, a5);
            _ZF = i + 1 == a5;
            _SF = (signed int)(i + 1 - a5) < 0;
            if ( i + 1 < a5 )
            {
              v10 = i + 1;
              v25 = *(_BYTE *)(i + 1 + a4);
              _CF = v25 < 0x2Fu;
              _OF = __OFSUB__(v25, 47);
              _ZF = v25 == 47;
              _SF = (char)(v25 - 47) < 0;
              if ( (char)v25 > 47 )
              {
                v10 = i + 1;
                v26 = *(_BYTE *)(i + 1 + a4);
                _CF = v26 < 0x39u;
                _OF = __OFSUB__(v26, 57);
                _ZF = v26 == 57;
                _SF = (char)(v26 - 57) < 0;
                if ( (char)v26 <= 57 )
                {
                  if ( v61 < a3 )
                  {
                    v10 = a2;
                    *(_BYTE *)(a2 + v61) = 48;
                  }
                  if ( ++v61 < a3 )
                  {
                    v10 = a2;
                    *(_BYTE *)(a2 + v61) = 48;
                  }
                  _CF = __CFADD__(v61, 1);
                  _OF = __OFADD__(1, v61);
                  _ZF = v61 == -1;
                  _SF = (signed int)(v61++ + 1) < 0;
                }
              }
            }
          }
          v52 = 48;
        }
        else
        {
          v27 = a7 & 1;
          _CF = 0;
          _OF = 0;
          _ZF = v27 == 0;
          _SF = v27 < 0;
          if ( a7 & 1 )
            continue;
        }
        __asm { pushfw }
        v44 = a1;
        if ( a1 >= 10 )
        {
          v28 = a1;
          v29 = _InterlockedExchange(&dword_805B16C, a1);
          v30 = _InterlockedExchange(&dword_805B16C, v11);
          v11 = _InterlockedExchange(&dword_805B16C, v29);
          if ( (v30 - 1) * v28 & 1 )
            abort();
        }
        a1 = v44;
        __asm { popfw }
        goto LABEL_199;
      case 7u:
        v53 = 97;
        goto LABEL_109;
      case 8u:
        v53 = 98;
        goto LABEL_109;
      case 9u:
        v53 = 116;
        goto LABEL_107;
      case 0xAu:
        v53 = 110;
        goto LABEL_107;
      case 0xBu:
        v53 = 118;
        goto LABEL_109;
      case 0xCu:
        v53 = 102;
        goto LABEL_109;
      case 0xDu:
        v53 = 114;
        goto LABEL_107;
      case 0x20u:
        goto LABEL_117;
      case 0x21u:
      case 0x22u:
      case 0x24u:
      case 0x26u:
      case 0x28u:
      case 0x29u:
      case 0x2Au:
      case 0x3Bu:
      case 0x3Cu:
      case 0x3Du:
      case 0x3Eu:
      case 0x5Bu:
      case 0x5Eu:
      case 0x60u:
      case 0x7Cu:
        goto LABEL_118;
      case 0x23u:
      case 0x7Eu:
        goto LABEL_116;
      case 0x25u:
      case 0x2Bu:
      case 0x2Cu:
      case 0x2Du:
      case 0x2Eu:
      case 0x2Fu:
      case 0x30u:
      case 0x31u:
      case 0x32u:
      case 0x33u:
      case 0x34u:
      case 0x35u:
      case 0x36u:
      case 0x37u:
      case 0x38u:
      case 0x39u:
      case 0x3Au:
      case 0x41u:
      case 0x42u:
      case 0x43u:
      case 0x44u:
      case 0x45u:
      case 0x46u:
      case 0x47u:
      case 0x48u:
      case 0x49u:
      case 0x4Au:
      case 0x4Bu:
      case 0x4Cu:
      case 0x4Du:
      case 0x4Eu:
      case 0x4Fu:
      case 0x50u:
      case 0x51u:
      case 0x52u:
      case 0x53u:
      case 0x54u:
      case 0x55u:
      case 0x56u:
      case 0x57u:
      case 0x58u:
      case 0x59u:
      case 0x5Au:
      case 0x5Du:
      case 0x5Fu:
      case 0x61u:
      case 0x62u:
      case 0x63u:
      case 0x64u:
      case 0x65u:
      case 0x66u:
      case 0x67u:
      case 0x68u:
      case 0x69u:
      case 0x6Au:
      case 0x6Bu:
      case 0x6Cu:
      case 0x6Du:
      case 0x6Eu:
      case 0x6Fu:
      case 0x70u:
      case 0x71u:
      case 0x72u:
      case 0x73u:
      case 0x74u:
      case 0x75u:
      case 0x76u:
      case 0x77u:
      case 0x78u:
      case 0x79u:
      case 0x7Au:
        v56 = 1;
        goto LABEL_199;
      case 0x27u:
        v50 = 1;
        v56 = 1;
        if ( a6 != 2 )
          goto LABEL_199;
        if ( v48 )
          goto LABEL_255;
        if ( a3 && !v62 )
        {
          v62 = a3;
          a3 = 0;
        }
        if ( v61 < a3 )
        {
          v10 = a2;
          *(_BYTE *)(a2 + v61) = 39;
        }
        if ( ++v61 < a3 )
        {
          v10 = a2;
          *(_BYTE *)(a2 + v61) = 92;
        }
        if ( ++v61 < a3 )
        {
          v10 = a2;
          *(_BYTE *)(a2 + v61) = 39;
        }
        ++v61;
        v49 = 0;
        goto LABEL_199;
      case 0x3Fu:
        if ( a6 == 2 )
        {
          if ( v48 )
            goto LABEL_255;
        }
        else if ( a6 == 5 )
        {
          if ( a7 & 4 )
          {
            if ( i + 2 < a5 )
            {
              v10 = i + 1;
              if ( *(_BYTE *)(i + 1 + a4) == 63 )
              {
                v10 = i + 2;
                switch ( *(char *)(i + 2 + a4) )
                {
                  case 33:
                  case 39:
                  case 40:
                  case 41:
                  case 45:
                  case 47:
                  case 60:
                  case 61:
                  case 62:
                    if ( v48 )
                      goto LABEL_255;
                    v10 = i + 2;
                    v52 = *(_BYTE *)(i + 2 + a4);
                    i += 2;
                    if ( v61 < a3 )
                    {
                      v10 = a2;
                      *(_BYTE *)(a2 + v61) = 63;
                    }
                    if ( ++v61 < a3 )
                    {
                      v10 = a2;
                      *(_BYTE *)(a2 + v61) = 34;
                    }
                    if ( ++v61 < a3 )
                    {
                      v10 = a2;
                      *(_BYTE *)(a2 + v61) = 34;
                    }
                    if ( ++v61 < a3 )
                    {
                      v10 = a2;
                      *(_BYTE *)(a2 + v61) = 63;
                    }
                    ++v61;
                    break;
                  default:
                    goto LABEL_199;
                }
              }
            }
          }
        }
        goto LABEL_199;
      case 0x5Cu:
        v53 = *(_BYTE *)(a4 + i);
        if ( a6 == 2 )
        {
          if ( v48 )
            goto LABEL_255;
          goto LABEL_218;
        }
        if ( v47 && v48 && n )
          goto LABEL_218;
LABEL_107:
        if ( a6 == 2 && v48 )
          goto LABEL_255;
LABEL_109:
        if ( v47 )
        {
          v52 = v53;
          goto LABEL_205;
        }
        goto LABEL_199;
      case 0x7Bu:
      case 0x7Du:
        if ( a5 == -1 )
          v31 = *(_BYTE *)(a4 + 1) != 0;
        else
          v31 = a5 != 1;
        if ( v31 )
          goto LABEL_199;
LABEL_116:
        if ( i )
          goto LABEL_199;
LABEL_117:
        v56 = 1;
LABEL_118:
        if ( a6 != 2 || !v48 )
          goto LABEL_199;
        goto LABEL_255;
      default:
        if ( v58 )
        {
          v65 = 1;
          v32 = __ctype_b_loc();
          v10 = 2 * v52;
          v57 = (*(const unsigned __int16 *)((char *)*v32 + v10) & 0x4000) != 0;
          goto LABEL_158;
        }
        memset(&ps, 0, 8u);
        v65 = 0;
        v57 = 1;
        if ( a5 == -1 )
          a5 = strlen((const char *)a4);
        break;
    }
    do
    {
      v67 = sub_80541F6(a4 + v65 + i, a1, (wchar_t *)&wc, (char *)(a4 + v65 + i), a5 - (v65 + i), &ps);
      if ( !v67 )
        break;
      if ( v67 == -1 )
      {
        v57 = 0;
        break;
      }
      if ( v67 == -2 )
      {
        v57 = 0;
        while ( 1 )
        {
          v10 = i;
          if ( i + v65 >= a5 )
            break;
          v10 = v65 + i;
          if ( !*(_BYTE *)(v65 + i + a4) )
            break;
          ++v65;
        }
        break;
      }
      if ( v48 && a6 == 2 )
      {
        v66 = 1;
        while ( v66 < v67 )
        {
          switch ( *(char *)(v66 + v65 + i + a4) )
          {
            case 91:
            case 92:
            case 94:
            case 96:
            case 124:
              goto LABEL_255;
            default:
              ++v66;
              break;
          }
        }
      }
      if ( !iswprint(wc) )
        v57 = 0;
      v65 += v67;
    }
    while ( !mbsinit(&ps) );
LABEL_158:
    v56 = v57;
    if ( v65 > 1 || v47 && v57 != 1 )
      break;
LABEL_199:
    if ( (v47 == 1 && a6 != 2 || v48 == 1)
      && a8
      && (v11 = v52 & 0x1F, v10 = *(_DWORD *)(4 * (v52 >> 5) + a8) >> v11, v10 & 1)
      || v54 == 1 )
    {
LABEL_205:
      if ( v48 )
        goto LABEL_255;
      v55 = 1;
      if ( a6 == 2 && v49 != 1 )
      {
        if ( v61 < a3 )
        {
          v10 = a2;
          *(_BYTE *)(a2 + v61) = 39;
        }
        if ( ++v61 < a3 )
        {
          v10 = a2;
          *(_BYTE *)(a2 + v61) = 36;
        }
        if ( ++v61 < a3 )
        {
          v10 = a2;
          *(_BYTE *)(a2 + v61) = 39;
        }
        ++v61;
        v49 = 1;
      }
      if ( v61 < a3 )
      {
        v10 = a2;
        *(_BYTE *)(a2 + v61) = 92;
      }
      ++v61;
    }
LABEL_218:
    if ( v49 && v55 != 1 )
    {
      if ( v61 < a3 )
      {
        v10 = a2;
        *(_BYTE *)(a2 + v61) = 39;
      }
      if ( ++v61 < a3 )
      {
        v10 = a2;
        *(_BYTE *)(a2 + v61) = 39;
      }
      ++v61;
      v49 = 0;
    }
    if ( v61 < a3 )
    {
      v10 = v61 + a2;
      *(_BYTE *)(v61 + a2) = v52;
    }
    ++v61;
    if ( v56 != 1 )
      v51 = 0;
  }
  v10 = i;
  v68 = i + v65;
  while ( !v47 || v57 == 1 )
  {
    if ( v54 )
    {
      if ( v61 < a3 )
      {
        v10 = a2;
        *(_BYTE *)(a2 + v61) = 92;
      }
      ++v61;
      v54 = 0;
    }
LABEL_188:
    if ( i + 1 >= v68 )
      goto LABEL_218;
    if ( v49 && v55 != 1 )
    {
      if ( v61 < a3 )
        *(_BYTE *)(a2 + v61) = 39;
      if ( ++v61 < a3 )
        *(_BYTE *)(a2 + v61) = 39;
      ++v61;
      v49 = 0;
    }
    if ( v61 < a3 )
      *(_BYTE *)(v61 + a2) = v52;
    ++v61;
    ++i;
    v10 = a4;
    v52 = *(_BYTE *)(a4 + i);
  }
  _CF = 0;
  _OF = 0;
  _ZF = v48 == 0;
  _SF = v48 < 0;
  if ( !v48 )
  {
    v55 = 1;
    if ( a6 == 2 && v49 != 1 )
    {
      if ( v61 < a3 )
      {
        v10 = a2;
        *(_BYTE *)(a2 + v61) = 39;
      }
      if ( ++v61 < a3 )
      {
        v10 = a2;
        *(_BYTE *)(a2 + v61) = 36;
      }
      if ( ++v61 < a3 )
      {
        v10 = a2;
        *(_BYTE *)(a2 + v61) = 39;
      }
      ++v61;
      v49 = 1;
    }
    if ( v61 < a3 )
    {
      v10 = a2;
      *(_BYTE *)(a2 + v61) = 92;
    }
    if ( ++v61 < a3 )
    {
      v10 = v61 + a2;
      *(_BYTE *)(v61 + a2) = (v52 >> 6) + 48;
    }
    if ( ++v61 < a3 )
    {
      v10 = v61 + a2;
      *(_BYTE *)(v61 + a2) = ((v52 >> 3) & 7) + 48;
    }
    ++v61;
    v52 = (v52 & 7) + 48;
    goto LABEL_188;
  }
  __asm { pushfw }
  v37 = _InterlockedExchange(&dword_805B148, !v57);
  _InterlockedExchange(&dword_805B148, v10);
  _InterlockedExchange(&dword_805B148, v37);
  if ( sub_80537D9() != 862 )
  {
    v40 = _InterlockedExchange(&dword_805B148, a1);
    _InterlockedExchange(&dword_805B148, v39);
    sub_80537E3(_InterlockedExchange(&dword_805B148, v40), v38);
  }
  __asm { popfw }
LABEL_255:
  if ( a6 == 2 && v47 )
    a6 = 4;
  return sub_80505A2(a2, a3, a4, a5, a6, a7 & 0xFFFFFFFD, 0, v46, v45);
}
// 80537E3: using guessed type int __fastcall sub_80537E3(_DWORD, _DWORD);
// 805B148: using guessed type int dword_805B148;
// 805B154: using guessed type int dword_805B154;
// 805B16C: using guessed type int dword_805B16C;

//----- (08051313) --------------------------------------------------------
void *__cdecl sub_8051313(signed __int32 a1, size_t a2, _DWORD *a3, int *a4)
{
  int *v4; // eax
  int v5; // ST4C_4
  int v6; // ST50_4
  signed __int32 v7; // edx
  signed __int32 v8; // ebx
  signed __int32 v9; // ecx
  signed __int32 v14; // ebx
  char v15; // t0
  int *v17; // [esp+3Ch] [ebp-1Ch]
  unsigned __int32 v18; // [esp+48h] [ebp-10h]
  void *v19; // [esp+4Ch] [ebp-Ch]

  if ( a4 )
    v4 = a4;
  else
    v4 = &dword_805B707;
  v17 = v4;
  v5 = *__errno_location();
  v6 = v17[1] | (a3 == 0);
  v18 = sub_80505A2((signed __int32)(v17 + 2), 0, 0, a1, a2, *v17, v6, (int)(v17 + 2), (char *)v17[10], (char *)v17[11])
      + 1;
  v19 = sub_805352E(v7, (signed __int32)(v17 + 2), v18);
  v8 = (signed __int32)(v17 + 2);
  sub_80505A2(
    (signed __int32)(v17 + 2),
    (signed __int32)v19,
    v18,
    a1,
    a2,
    *v17,
    v6,
    (int)(v17 + 2),
    (char *)v17[10],
    (char *)v17[11]);
  *__errno_location() = v5;
  _CF = 0;
  _OF = 0;
  _ZF = a3 == 0;
  _SF = (signed int)a3 < 0;
  if ( a3 )
  {
    __asm { pushfw }
    if ( v8 >= 10 )
    {
      v14 = _InterlockedExchange(&dword_805B13C, v8);
      v15 = _InterlockedExchange(&dword_805B13C, v9);
      _InterlockedExchange(&dword_805B13C, v14);
      if ( (v15 - 1) * ((_BYTE)v17 + 8) & 1 )
        abort();
    }
    __asm { popfw }
    *a3 = v18 - 1;
  }
  return v19;
}
// 805B13C: using guessed type int dword_805B13C;
// 805B707: using guessed type int dword_805B707;

//----- (08051523) --------------------------------------------------------
void *__usercall sub_8051523@<eax>(signed __int32 a1@<ebx>, signed int a2, signed __int32 a3, size_t a4, int a5)
{
  signed __int32 v5; // ecx
  int *v6; // eax
  signed __int32 v7; // edx
  signed __int32 v8; // ecx
  char v9; // al
  signed __int32 v10; // ebx
  char v11; // t0
  signed __int32 v16; // eax
  unsigned __int32 v17; // eax
  signed __int32 v18; // edx
  signed __int32 v19; // ecx
  bool v20; // cf
  bool v21; // zf
  bool v22; // sf
  char v23; // of
  signed __int32 v24; // eax
  void *v25; // edx
  unsigned int v26; // ST50_4
  signed __int32 v27; // ebx
  signed __int32 v29; // [esp-Ah] [ebp-62h]
  int *v30; // [esp-4h] [ebp-5Ch]
  bool v31; // [esp+37h] [ebp-21h]
  int *v32; // [esp+38h] [ebp-20h]
  void *ptr; // [esp+3Ch] [ebp-1Ch]
  int v34; // [esp+40h] [ebp-18h]
  unsigned __int32 v35; // [esp+44h] [ebp-14h]
  int v36; // [esp+48h] [ebp-10h]
  unsigned int v37; // [esp+4Ch] [ebp-Ch]

  v34 = *__errno_location();
  v32 = off_805B1E4;
  if ( a2 < 0 )
    abort();
  if ( dword_805B1D8 <= a2 )
  {
    v31 = off_805B1E4 == &dword_805B1DC;
    if ( (unsigned int)a2 > 0xFFFFFFE )
      sub_8053913(a1);
    if ( v31 )
      v6 = 0;
    else
      v6 = off_805B1E4;
    v30 = (int *)sub_8053627(
                   0,
                   off_805B1E4 != &dword_805B1DC,
                   (off_805B1E4 == &dword_805B1DC) < 0,
                   0,
                   v5,
                   a1,
                   v6,
                   8 * (a2 + 1));
    __asm { pushfw }
    v29 = a1;
    if ( a1 >= 10 )
    {
      v9 = a1;
      v10 = _InterlockedExchange(&dword_805B19C, a1);
      v11 = _InterlockedExchange(&dword_805B19C, v7);
      _InterlockedExchange(&dword_805B19C, v10);
      if ( (v11 - 1) * v9 & 1 )
        abort();
    }
    __asm { popfw }
    v32 = v30;
    off_805B1E4 = v30;
    _CF = 0;
    _OF = 0;
    _ZF = v31 == 0;
    _SF = v31 < 0;
    if ( v31 )
    {
      __asm { pushfw }
      v16 = _InterlockedExchange(&dword_805B160, (signed __int32)v30);
      _InterlockedExchange(&dword_805B160, v8);
      _InterlockedExchange(&dword_805B160, v16);
      v17 = sub_804FBC9();
      v20 = v17 < 0xFFFFFDBC;
      v23 = __OFSUB__(v17, -580);
      v21 = v17 == -580;
      v22 = (signed int)(v17 + 580) < 0;
      if ( v17 != -580 )
      {
        v24 = _InterlockedExchange(&dword_805B160, v17);
        _InterlockedExchange(&dword_805B160, v18);
        _InterlockedExchange(&dword_805B160, v24);
        sub_804FBD3(v20, v21, v22, v23, v19, v29);
      }
      __asm { popfw }
      v25 = off_805B1E0;
      *v30 = dword_805B1DC;
      v30[1] = (int)v25;
    }
    memset(&v30[2 * dword_805B1D8], 0, 8 * (a2 + 1 - dword_805B1D8));
    dword_805B1D8 = a2 + 1;
  }
  v26 = v32[2 * a2];
  ptr = (void *)v32[2 * a2 + 1];
  v36 = *(_DWORD *)(a5 + 4) | 1;
  v37 = sub_80505A2(
          a5 + 8,
          v32[2 * a2 + 1],
          v32[2 * a2],
          a3,
          a4,
          *(_DWORD *)a5,
          v36,
          a5 + 8,
          *(char **)(a5 + 40),
          *(char **)(a5 + 44));
  if ( v26 <= v37 )
  {
    v35 = v37 + 1;
    v32[2 * a2] = v37 + 1;
    if ( ptr != &unk_805B747 )
      free(ptr);
    v27 = (signed __int32)&v32[2 * a2];
    ptr = sub_805352E(8 * a2, v27, v35);
    *(_DWORD *)(v27 + 4) = ptr;
    sub_80505A2(
      a5 + 8,
      (signed __int32)ptr,
      v35,
      a3,
      a4,
      *(_DWORD *)a5,
      v36,
      a5 + 8,
      *(char **)(a5 + 40),
      *(char **)(a5 + 44));
  }
  *__errno_location() = v34;
  return ptr;
}
// 805B160: using guessed type int dword_805B160;
// 805B19C: using guessed type int dword_805B19C;
// 805B1D8: using guessed type int dword_805B1D8;
// 805B1DC: using guessed type int dword_805B1DC;
// 805B1E0: using guessed type void *off_805B1E0;
// 805B1E4: using guessed type int *off_805B1E4;

//----- (080517DA) --------------------------------------------------------
void *__usercall sub_80517DA@<eax>(signed __int32 a1@<ebx>, signed int a2, signed __int32 a3)
{
  void *v3; // eax
  signed __int32 v8; // eax
  signed __int32 v9; // edx
  int v10; // edx
  signed __int32 v11; // ecx
  signed __int32 v12; // ebx
  void *v14; // [esp-4h] [ebp-1Ch]

  v3 = sub_8051523(a1, a2, a3, 0xFFFFFFFF, (int)&dword_805B707);
  v14 = v3;
  __asm { pushfw }
  v8 = _InterlockedExchange(&dword_805B13C, (signed __int32)v3);
  _InterlockedExchange(&dword_805B13C, v9);
  _InterlockedExchange(&dword_805B13C, v8);
  if ( sub_8052670() != -41 )
  {
    v12 = _InterlockedExchange(&dword_805B13C, a1);
    _InterlockedExchange(&dword_805B13C, v11);
    sub_805267A(_InterlockedExchange(&dword_805B13C, v12), v10);
  }
  __asm { popfw }
  return v14;
}
// 805267A: using guessed type int __fastcall sub_805267A(_DWORD, _DWORD);
// 805B13C: using guessed type int dword_805B13C;
// 805B707: using guessed type int dword_805B707;

//----- (08051840) --------------------------------------------------------
void *__usercall sub_8051840@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>, signed int a7, signed __int32 a8, size_t a9)
{
  char v9; // al
  signed __int32 v10; // et0
  signed __int32 v11; // ecx
  char v12; // al
  signed __int32 v13; // et1
  void *v15; // [esp-4h] [ebp-20h]

  __asm { pushfw }
  if ( a6 >= 10 )
  {
    v10 = _InterlockedExchange(&dword_805B160, a6);
    v9 = _InterlockedExchange(&dword_805B160, a5);
    _InterlockedExchange(&dword_805B160, v10);
    if ( ((_BYTE)a6 - 1) * v9 & 1 )
      abort();
  }
  __asm { popfw }
  v15 = sub_8051523(a6, a7, a8, a9, (int)&dword_805B707);
  __asm { pushfw }
  if ( a6 >= 10 )
  {
    v13 = _InterlockedExchange(&dword_805B190, a6);
    v12 = _InterlockedExchange(&dword_805B190, v11);
    _InterlockedExchange(&dword_805B190, v13);
    if ( ((_BYTE)a6 - 1) * v12 & 1 )
      abort();
  }
  __asm { popfw }
  return v15;
}
// 8051840: could not find valid save-restore pair for ebx
// 8051840: could not find valid save-restore pair for ebp
// 805B160: using guessed type int dword_805B160;
// 805B190: using guessed type int dword_805B190;
// 805B707: using guessed type int dword_805B707;

//----- (0805194D) --------------------------------------------------------
signed int sub_805194D()
{
  return 44;
}

//----- (08051957) --------------------------------------------------------
void __usercall __noreturn sub_8051957(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>)
{
  signed __int32 v6; // ebx
  signed __int32 v7; // edx
  signed __int32 v8; // ebx
  signed __int32 v9; // et0
  signed __int32 v10; // edx
  int v11; // ecx
  signed __int32 v12; // ebx

  __asm { pushfw }
  v6 = _InterlockedExchange(&dword_805B10C, a6);
  v9 = _InterlockedExchange(&dword_805B10C, a5);
  v7 = v6;
  v8 = v9;
  _InterlockedExchange(&dword_805B10C, v7);
  if ( sub_8052466() != -423 )
  {
    v12 = _InterlockedExchange(&dword_805B10C, v8);
    _InterlockedExchange(&dword_805B10C, v10);
    _InterlockedExchange(&dword_805B10C, v12);
    sub_8052470(v11);
  }
  __asm { popfw }
  __halt();
  JUMPOUT(*(_DWORD *)sub_8051997);
}
// 8052470: using guessed type int __fastcall sub_8052470(_DWORD);
// 805B10C: using guessed type int dword_805B10C;

//----- (08051997) --------------------------------------------------------
void *__usercall sub_8051997@<eax>(signed __int32 a1@<ebx>, signed int a2, unsigned __int32 a3, signed __int32 a4)
{
  signed __int32 v4; // ebx
  signed __int32 v5; // edx
  signed __int32 v6; // edx
  signed __int32 v7; // ebx
  signed __int32 v8; // et0
  signed __int32 v9; // ecx
  unsigned int v10; // eax
  signed __int32 v11; // edx
  signed __int32 v12; // ecx
  char v17; // al
  signed __int32 v18; // ebx
  char v19; // t1
  signed __int32 v21; // [esp-10h] [ebp-58h]
  void *v22; // [esp-4h] [ebp-4Ch]
  char v23; // [esp+10h] [ebp-38h]

  sub_80502A8(0, 0, _SF, 0, (signed __int32)&v23, a3, a1, (unsigned int *)&v23, a3);
  v22 = sub_8051523(a1, a2, a4, 0xFFFFFFFF, (int)&v23);
  __asm { pushfw }
  v4 = _InterlockedExchange(&dword_805B16C, a1);
  v8 = _InterlockedExchange(&dword_805B16C, v5);
  v6 = v4;
  v7 = v8;
  _InterlockedExchange(&dword_805B16C, v6);
  v10 = sub_804B058(_CF, _ZF, _SF, _OF, v9, v8);
  _CF = v10 < 0xFFFFFCD4;
  _OF = __OFSUB__(v10, -812);
  _ZF = v10 == -812;
  _SF = (signed int)(v10 + 812) < 0;
  if ( v10 != -812 )
  {
    __asm { pushfw }
    v21 = v7;
    if ( v7 >= 10 )
    {
      v17 = v7;
      v18 = _InterlockedExchange(&dword_805B160, v7);
      v19 = _InterlockedExchange(&dword_805B160, v11);
      v11 = _InterlockedExchange(&dword_805B160, v18);
      if ( (v19 - 1) * v17 & 1 )
        abort();
    }
    __asm { popfw }
    sub_804B0A0(
      _CF,
      _ZF,
      _SF,
      _OF,
      _InterlockedExchange(&dword_805B16C, _InterlockedExchange(&dword_805B16C, v21)),
      v12,
      _InterlockedExchange(&dword_805B16C, v11));
  }
  __asm { popfw }
  return v22;
}
// 805B160: using guessed type int dword_805B160;
// 805B16C: using guessed type int dword_805B16C;

//----- (08051A49) --------------------------------------------------------
void *__usercall sub_8051A49@<eax>(signed __int32 a1@<ebx>, signed int a2, unsigned __int32 a3, signed __int32 a4, size_t a5)
{
  void *v6; // eax
  signed __int32 v10; // eax
  signed __int32 v11; // edx
  signed __int32 v12; // ecx
  signed __int32 v13; // eax
  signed __int32 v14; // edx
  int v15; // ecx
  signed __int32 v16; // eax
  void *v18; // [esp-4h] [ebp-4Ch]
  char v19; // [esp+10h] [ebp-38h]

  sub_80502A8(0, 0, _SF, 0, (signed __int32)&v19, a3, a1, (unsigned int *)&v19, a3);
  v6 = sub_8051523(a1, a2, a4, a5, (int)&v19);
  v18 = v6;
  __asm { pushfw }
  v10 = _InterlockedExchange(&dword_805B184, (signed __int32)v6);
  _InterlockedExchange(&dword_805B184, v11);
  _InterlockedExchange(&dword_805B184, v10);
  v13 = sub_80525AB(_CF, _ZF, _SF, _OF, v12, a1);
  if ( v13 != -398 )
  {
    v16 = _InterlockedExchange(&dword_805B184, v13);
    _InterlockedExchange(&dword_805B184, v14);
    sub_805267B(v15, _InterlockedExchange(&dword_805B184, v16));
  }
  __asm { popfw }
  return v18;
}
// 805267B: using guessed type int __fastcall sub_805267B(_DWORD, _DWORD);
// 805B184: using guessed type int dword_805B184;

//----- (08051B96) --------------------------------------------------------
void *__usercall sub_8051B96@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, signed __int32 a3, size_t a4, unsigned __int8 a5)
{
  signed __int32 v5; // ebx
  signed __int32 v6; // edx
  signed __int32 v7; // edx
  signed __int32 v8; // ebx
  signed __int32 v9; // et0
  unsigned __int32 v10; // eax
  signed __int32 v11; // edx
  signed __int32 v12; // ecx
  signed __int32 v17; // eax
  signed __int32 v18; // ebx
  signed __int32 v19; // ecx
  signed __int32 v20; // ebx
  signed __int32 v21; // et2
  signed __int32 v22; // eax
  signed __int32 v23; // eax
  signed __int32 v24; // edx
  unsigned int v25; // eax
  signed __int32 v26; // edx
  signed __int32 v27; // ecx
  signed __int32 v32; // ebx
  signed __int32 v33; // ebx
  signed __int32 v34; // ecx
  signed __int32 v35; // ebx
  signed __int32 v36; // et1
  unsigned __int32 v37; // eax
  signed __int32 v38; // edx
  signed __int32 v39; // ecx
  bool v40; // cf
  bool v41; // zf
  bool v42; // sf
  char v43; // of
  signed __int32 v44; // eax
  unsigned int v46; // [esp-Ah] [ebp-62h]
  void *v47; // [esp-4h] [ebp-5Ch]
  int v48; // [esp+20h] [ebp-38h]
  int v49; // [esp+24h] [ebp-34h]
  int v50; // [esp+28h] [ebp-30h]
  int v51; // [esp+2Ch] [ebp-2Ch]
  int v52; // [esp+30h] [ebp-28h]
  int v53; // [esp+34h] [ebp-24h]
  int v54; // [esp+38h] [ebp-20h]
  int v55; // [esp+3Ch] [ebp-1Ch]
  int v56; // [esp+40h] [ebp-18h]
  int v57; // [esp+44h] [ebp-14h]
  int v58; // [esp+48h] [ebp-10h]
  int v59; // [esp+4Ch] [ebp-Ch]

  v48 = dword_805B707;
  v49 = dword_805B70B;
  v50 = dword_805B70F;
  v51 = dword_805B713;
  v52 = dword_805B717;
  v53 = dword_805B71B;
  v54 = dword_805B71F;
  v55 = dword_805B723;
  v56 = dword_805B727;
  v57 = dword_805B72B;
  v58 = dword_805B72F;
  v59 = dword_805B733;
  sub_8050064(a1, a2, &v48, a5, 1);
  v47 = sub_8051523(a2, 0, a3, a4, (int)&v48);
  __asm { pushfw }
  v5 = _InterlockedExchange(&dword_805B130, a2);
  v9 = _InterlockedExchange(&dword_805B130, v6);
  v7 = v5;
  v8 = v9;
  _InterlockedExchange(&dword_805B130, v7);
  v10 = sub_804AFB8();
  _CF = v10 < 0x36C;
  _OF = __OFSUB__(v10, 876);
  _ZF = v10 == 876;
  _SF = (signed int)(v10 - 876) < 0;
  if ( v10 != 876 )
  {
    v17 = _InterlockedExchange(&dword_805B130, v10);
    _InterlockedExchange(&dword_805B130, v12);
    _InterlockedExchange(&dword_805B130, v17);
    sub_804AFC2(_CF, _ZF, _SF, _OF, v11, v8);
  }
  __asm
  {
    popfw
    pushfw
  }
  v18 = _InterlockedExchange(&dword_805B154, v8);
  v21 = _InterlockedExchange(&dword_805B154, v12);
  v19 = v18;
  v20 = v21;
  v22 = sub_804B522(_CF, _ZF, _SF, _OF, (signed __int32)v47, v11, _InterlockedExchange(&dword_805B154, v19), v21);
  v46 = v22;
  __asm { pushfw }
  v23 = _InterlockedExchange(&dword_805B148, v22);
  _InterlockedExchange(&dword_805B148, v24);
  _InterlockedExchange(&dword_805B148, v23);
  v25 = sub_80537D9();
  _CF = v25 < 0x35E;
  _OF = __OFSUB__(v25, 862);
  _ZF = v25 == 862;
  _SF = (signed int)(v25 - 862) < 0;
  if ( v25 != 862 )
  {
    v32 = _InterlockedExchange(&dword_805B148, v20);
    _InterlockedExchange(&dword_805B148, v26);
    sub_80537E3(v27, _InterlockedExchange(&dword_805B148, v32));
  }
  __asm { pushfw }
  v33 = _InterlockedExchange(&dword_805B124, v20);
  v36 = _InterlockedExchange(&dword_805B124, v27);
  v34 = v33;
  v35 = v36;
  _InterlockedExchange(&dword_805B124, v34);
  v37 = sub_805194D();
  v40 = v37 < 0x2C;
  v43 = __OFSUB__(v37, 44);
  v41 = v37 == 44;
  v42 = (signed int)(v37 - 44) < 0;
  if ( v37 != 44 )
  {
    v44 = _InterlockedExchange(&dword_805B124, v37);
    _InterlockedExchange(&dword_805B124, v39);
    _InterlockedExchange(&dword_805B124, v44);
    sub_8051957(v40, v41, v42, v43, v38, v35);
  }
  __asm
  {
    popfw
    popfw
  }
  if ( v46 != -958 )
    sub_804B619(
      v46 < 0xFFFFFC42,
      v46 == -958,
      (signed int)(v46 + 958) < 0,
      __OFSUB__(v46, -958),
      _InterlockedExchange(&dword_805B154, _InterlockedExchange(&dword_805B154, v35)),
      _InterlockedExchange(&dword_805B154, v39));
  __asm { popfw }
  return v47;
}
// 80537E3: using guessed type int __fastcall sub_80537E3(_DWORD, _DWORD);
// 805B124: using guessed type int dword_805B124;
// 805B130: using guessed type int dword_805B130;
// 805B148: using guessed type int dword_805B148;
// 805B154: using guessed type int dword_805B154;
// 805B707: using guessed type int dword_805B707;
// 805B70B: using guessed type int dword_805B70B;
// 805B70F: using guessed type int dword_805B70F;
// 805B713: using guessed type int dword_805B713;
// 805B717: using guessed type int dword_805B717;
// 805B71B: using guessed type int dword_805B71B;
// 805B71F: using guessed type int dword_805B71F;
// 805B723: using guessed type int dword_805B723;
// 805B727: using guessed type int dword_805B727;
// 805B72B: using guessed type int dword_805B72B;
// 805B72F: using guessed type int dword_805B72F;
// 805B733: using guessed type int dword_805B733;

//----- (08051D37) --------------------------------------------------------
void *__usercall sub_8051D37@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, signed __int32 a3, unsigned __int8 a4)
{
  return sub_8051B96(a1, a2, a3, 0xFFFFFFFF, a4);
}

//----- (08051D60) --------------------------------------------------------
void *__usercall sub_8051D60@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, signed __int32 a8)
{
  char v8; // al
  signed __int32 v9; // ebx
  char v10; // t0
  signed __int32 v11; // ebx
  char v12; // t1
  char v13; // al
  signed __int32 v14; // et2
  signed __int32 v15; // ebx
  int v16; // eax
  unsigned int v21; // eax
  signed __int32 v22; // edx
  signed __int32 v23; // ecx
  signed __int32 v24; // ebx
  signed __int32 v25; // et0
  char v26; // al
  signed __int32 v27; // et1
  signed __int32 v29; // [esp+12h] [ebp-Ah]

  __asm { pushfw }
  v29 = a7;
  if ( a7 >= 10 )
  {
    v8 = a7;
    v9 = _InterlockedExchange(&dword_805B13C, a7);
    v10 = _InterlockedExchange(&dword_805B13C, a5);
    a5 = _InterlockedExchange(&dword_805B13C, v9);
    if ( (v10 - 1) * v8 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( v29 >= 10 )
  {
    v11 = _InterlockedExchange(&dword_805B148, v29);
    v12 = _InterlockedExchange(&dword_805B148, a6);
    a6 = _InterlockedExchange(&dword_805B148, v11);
    if ( (v12 - 1) * (_BYTE)v29 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( v29 >= 10 )
  {
    v14 = _InterlockedExchange(&dword_805B184, v29);
    v13 = _InterlockedExchange(&dword_805B184, a5);
    a5 = _InterlockedExchange(&dword_805B184, v14);
    v15 = v29 - 1;
    v16 = ((_BYTE)v29 - 1) * v13 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = v16 == 0;
    _SF = v16 < 0;
    if ( v16 )
    {
      __asm { pushfw }
      v21 = sub_804B522(
              0,
              v16 == 0,
              v16 < 0,
              0,
              _InterlockedExchange(&dword_805B154, a5),
              _InterlockedExchange(&dword_805B154, _InterlockedExchange(&dword_805B154, v16)),
              a6,
              v15);
      if ( v21 != -958 )
      {
        v24 = _InterlockedExchange(&dword_805B154, v15);
        v25 = _InterlockedExchange(&dword_805B154, v22);
        _InterlockedExchange(&dword_805B154, v24);
        sub_804B619(v21 < 0xFFFFFC42, v21 == -958, (signed int)(v21 + 958) < 0, __OFSUB__(v21, -958), v23, v25);
      }
      __asm { popfw }
      abort();
    }
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( v29 >= 10 )
  {
    v27 = _InterlockedExchange(&dword_805B190, v29);
    v26 = _InterlockedExchange(&dword_805B190, a5);
    _InterlockedExchange(&dword_805B190, v27);
    if ( ((_BYTE)v29 - 1) * v26 & 1 )
      abort();
  }
  __asm { popfw }
  return sub_8051D37(a6, v29, a8, 0x3Au);
}
// 8051D60: could not find valid save-restore pair for ebx
// 8051D60: could not find valid save-restore pair for ebp
// 805B13C: using guessed type int dword_805B13C;
// 805B148: using guessed type int dword_805B148;
// 805B154: using guessed type int dword_805B154;
// 805B184: using guessed type int dword_805B184;
// 805B190: using guessed type int dword_805B190;

//----- (08051EAD) --------------------------------------------------------
void *__usercall sub_8051EAD@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, int a8@<ebp>, signed int a9, unsigned __int32 a10, signed __int32 a11)
{
  signed __int32 v11; // ebx
  signed __int32 v12; // ecx
  signed __int32 v13; // ebx
  signed __int32 v14; // et0
  signed __int32 v15; // ecx
  signed __int32 v16; // ebx
  unsigned int *v17; // eax
  signed __int32 v18; // eax
  signed __int32 v19; // edx
  unsigned int v20; // eax
  signed __int32 v21; // edx
  signed __int32 v22; // ecx
  signed __int32 v23; // edx
  char v24; // al
  signed __int32 v25; // et0
  int v27; // [esp+10h] [ebp-6Ch]
  int v28; // [esp+14h] [ebp-68h]
  int v29; // [esp+18h] [ebp-64h]
  int v30; // [esp+1Ch] [ebp-60h]
  int v31; // [esp+20h] [ebp-5Ch]
  int v32; // [esp+24h] [ebp-58h]
  int v33; // [esp+28h] [ebp-54h]
  int v34; // [esp+2Ch] [ebp-50h]
  int v35; // [esp+30h] [ebp-4Ch]
  int v36; // [esp+34h] [ebp-48h]
  int v37; // [esp+38h] [ebp-44h]
  int v38; // [esp+3Ch] [ebp-40h]
  int v39; // [esp+40h] [ebp-3Ch]
  int v40; // [esp+44h] [ebp-38h]
  int v41; // [esp+48h] [ebp-34h]
  int v42; // [esp+4Ch] [ebp-30h]
  int v43; // [esp+50h] [ebp-2Ch]
  int v44; // [esp+54h] [ebp-28h]
  int v45; // [esp+58h] [ebp-24h]
  int v46; // [esp+5Ch] [ebp-20h]
  int v47; // [esp+60h] [ebp-1Ch]
  int v48; // [esp+64h] [ebp-18h]
  int v49; // [esp+68h] [ebp-14h]
  int v50; // [esp+6Ch] [ebp-10h]
  int v51; // [esp+78h] [ebp-4h]

  v51 = a5;
  __asm { pushfw }
  v11 = _InterlockedExchange(&dword_805B178, a7);
  v14 = _InterlockedExchange(&dword_805B178, a6);
  v12 = v11;
  v13 = v14;
  _InterlockedExchange(&dword_805B178, v12);
  if ( sub_804A881() != 893 )
  {
    v16 = _InterlockedExchange(&dword_805B178, v13);
    _InterlockedExchange(&dword_805B178, v15);
    sub_804A88B(_InterlockedExchange(&dword_805B178, v16));
  }
  __asm { popfw }
  v51 = a8;
  v17 = sub_80502A8(
          (unsigned int)&v51 < 0x78,
          &v51 == 0,
          (signed int)&v51 < 0,
          __OFSUB__(&v51, 120),
          (signed __int32)&v27,
          a10,
          v13,
          (unsigned int *)&v27,
          a10);
  __asm { pushfw }
  v18 = _InterlockedExchange(&dword_805B124, (signed __int32)v17);
  _InterlockedExchange(&dword_805B124, v19);
  _InterlockedExchange(&dword_805B124, v18);
  v20 = sub_805194D();
  if ( v20 != 44 )
    sub_8051957(
      v20 < 0x2C,
      v20 == 44,
      (signed int)(v20 - 44) < 0,
      __OFSUB__(v20, 44),
      _InterlockedExchange(&dword_805B124, _InterlockedExchange(&dword_805B124, v13)),
      _InterlockedExchange(&dword_805B124, v21));
  __asm { popfw }
  v39 = v27;
  v40 = v28;
  v41 = v29;
  v42 = v30;
  v43 = v31;
  v44 = v32;
  v45 = v33;
  v46 = v34;
  v47 = v35;
  v48 = v36;
  v49 = v37;
  v50 = v38;
  sub_8050064(v22, v13, &v39, 0x3Au, 1);
  __asm { pushfw }
  if ( v13 >= 10 )
  {
    v25 = _InterlockedExchange(&dword_805B160, v13);
    v24 = _InterlockedExchange(&dword_805B160, v23);
    _InterlockedExchange(&dword_805B160, v25);
    if ( ((_BYTE)v13 - 1) * v24 & 1 )
      abort();
  }
  __asm { popfw }
  return sub_8051523(v13, a9, a11, 0xFFFFFFFF, (int)&v39);
}
// 8051EAD: could not find valid save-restore pair for ebp
// 804A88B: using guessed type int __fastcall sub_804A88B(_DWORD);
// 805B124: using guessed type int dword_805B124;
// 805B160: using guessed type int dword_805B160;
// 805B178: using guessed type int dword_805B178;

//----- (08052188) --------------------------------------------------------
void *__usercall sub_8052188@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>, signed int a3, int a4, int a5, signed __int32 a6)
{
  signed __int32 v6; // ebx
  signed __int32 v7; // ecx
  signed __int32 v8; // ecx
  signed __int32 v9; // ebx
  signed __int32 v10; // et0
  signed __int32 v11; // edx
  signed __int32 v12; // ecx
  char v13; // al
  signed __int32 v14; // et1
  int v15; // eax
  signed __int32 v20; // eax
  signed __int32 v21; // eax
  signed __int32 v22; // ecx
  signed __int32 v23; // eax
  signed __int32 v28; // ebx
  char v29; // t1
  char v30; // al
  signed __int32 v31; // et2
  signed __int32 v33; // [esp-10h] [ebp-38h]
  unsigned int v34; // [esp-Ah] [ebp-32h]
  void *v35; // [esp-4h] [ebp-2Ch]

  v35 = sub_80522D1(a1, a2, a3, a4, a5, a6, 0xFFFFFFFF);
  __asm { pushfw }
  v6 = _InterlockedExchange(&dword_805B16C, a2);
  v10 = _InterlockedExchange(&dword_805B16C, v7);
  v8 = v6;
  v9 = v10;
  v34 = sub_804B058(_CF, _ZF, _SF, _OF, _InterlockedExchange(&dword_805B16C, v8), v10);
  __asm { pushfw }
  v33 = v10;
  if ( v10 >= 10 )
  {
    v14 = _InterlockedExchange(&dword_805B148, v9);
    v13 = _InterlockedExchange(&dword_805B148, v12);
    v12 = _InterlockedExchange(&dword_805B148, v14);
    v15 = ((_BYTE)v9 - 1) * v13 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = v15 == 0;
    _SF = v15 < 0;
    if ( v15 )
    {
      __asm { pushfw }
      v20 = _InterlockedExchange(&dword_805B10C, v15);
      _InterlockedExchange(&dword_805B10C, v12);
      _InterlockedExchange(&dword_805B10C, v20);
      v21 = sub_8052466();
      if ( v21 != -423 )
      {
        v23 = _InterlockedExchange(&dword_805B10C, v21);
        _InterlockedExchange(&dword_805B10C, v22);
        sub_8052470(_InterlockedExchange(&dword_805B10C, v23));
      }
      __asm { popfw }
      abort();
    }
  }
  __asm { popfw }
  _CF = v34 < 0xFFFFFCD4;
  _OF = __OFSUB__(v34, -812);
  _ZF = v34 == -812;
  _SF = (signed int)(v34 + 812) < 0;
  if ( v34 != -812 )
    sub_804B0A0(
      v34 < 0xFFFFFCD4,
      v34 == -812,
      (signed int)(v34 + 812) < 0,
      __OFSUB__(v34, -812),
      v11,
      _InterlockedExchange(&dword_805B16C, _InterlockedExchange(&dword_805B16C, v33)),
      _InterlockedExchange(&dword_805B16C, v12));
  __asm { pushfw }
  if ( v33 >= 10 )
  {
    v28 = _InterlockedExchange(&dword_805B13C, v33);
    v29 = _InterlockedExchange(&dword_805B13C, v11);
    v11 = _InterlockedExchange(&dword_805B13C, v28);
    if ( (v29 - 1) * (_BYTE)v33 & 1 )
      abort();
  }
  __asm
  {
    popfw
    popfw
    pushfw
  }
  if ( v33 >= 10 )
  {
    v31 = _InterlockedExchange(&dword_805B19C, v33);
    v30 = _InterlockedExchange(&dword_805B19C, v11);
    _InterlockedExchange(&dword_805B19C, v31);
    if ( ((_BYTE)v33 - 1) * v30 & 1 )
      abort();
  }
  __asm { popfw }
  return v35;
}
// 8052470: using guessed type int __fastcall sub_8052470(_DWORD);
// 805B10C: using guessed type int dword_805B10C;
// 805B13C: using guessed type int dword_805B13C;
// 805B148: using guessed type int dword_805B148;
// 805B16C: using guessed type int dword_805B16C;
// 805B19C: using guessed type int dword_805B19C;

//----- (080522D1) --------------------------------------------------------
void *__usercall sub_80522D1@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>, signed int a3, int a4, int a5, signed __int32 a6, size_t a7)
{
  signed __int32 v11; // ebx
  signed __int32 v12; // edx
  signed __int32 v13; // edx
  signed __int32 v14; // ebx
  signed __int32 v15; // et0
  unsigned int v16; // eax
  signed __int32 v17; // edx
  signed __int32 v18; // ecx
  signed __int32 v19; // ebx
  signed __int32 v20; // et1
  int v22; // [esp+10h] [ebp-38h]
  int v23; // [esp+14h] [ebp-34h]
  int v24; // [esp+18h] [ebp-30h]
  int v25; // [esp+1Ch] [ebp-2Ch]
  int v26; // [esp+20h] [ebp-28h]
  int v27; // [esp+24h] [ebp-24h]
  int v28; // [esp+28h] [ebp-20h]
  int v29; // [esp+2Ch] [ebp-1Ch]
  int v30; // [esp+30h] [ebp-18h]
  int v31; // [esp+34h] [ebp-14h]
  int v32; // [esp+38h] [ebp-10h]
  int v33; // [esp+3Ch] [ebp-Ch]

  v22 = dword_805B707;
  v23 = dword_805B70B;
  v24 = dword_805B70F;
  v25 = dword_805B713;
  v26 = dword_805B717;
  v27 = dword_805B71B;
  v28 = dword_805B71F;
  v29 = dword_805B723;
  v30 = dword_805B727;
  v31 = dword_805B72B;
  v32 = dword_805B72F;
  v33 = dword_805B733;
  sub_80501BB(0, 0, _SF, 0, (signed __int32)&v22, a1, a2, &v22, a4, a5);
  __asm { pushfw }
  v11 = _InterlockedExchange(&dword_805B124, a2);
  v15 = _InterlockedExchange(&dword_805B124, v12);
  v13 = v11;
  v14 = v15;
  _InterlockedExchange(&dword_805B124, v13);
  v16 = sub_805194D();
  if ( v16 != 44 )
  {
    v19 = _InterlockedExchange(&dword_805B124, v14);
    v20 = _InterlockedExchange(&dword_805B124, v18);
    _InterlockedExchange(&dword_805B124, v19);
    sub_8051957(v16 < 0x2C, v16 == 44, (signed int)(v16 - 44) < 0, __OFSUB__(v16, 44), v17, v20);
  }
  __asm { popfw }
  return sub_8051523(v14, a3, a6, a7, (int)&v22);
}
// 805B124: using guessed type int dword_805B124;
// 805B707: using guessed type int dword_805B707;
// 805B70B: using guessed type int dword_805B70B;
// 805B70F: using guessed type int dword_805B70F;
// 805B713: using guessed type int dword_805B713;
// 805B717: using guessed type int dword_805B717;
// 805B71B: using guessed type int dword_805B71B;
// 805B71F: using guessed type int dword_805B71F;
// 805B723: using guessed type int dword_805B723;
// 805B727: using guessed type int dword_805B727;
// 805B72B: using guessed type int dword_805B72B;
// 805B72F: using guessed type int dword_805B72F;
// 805B733: using guessed type int dword_805B733;

//----- (08052408) --------------------------------------------------------
void *__usercall sub_8052408@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>, signed int a7, signed __int32 a8, size_t a9)
{
  char v9; // al
  signed __int32 v10; // ebx
  char v11; // t0
  signed __int32 v13; // [esp+12h] [ebp-Ah]

  __asm { pushfw }
  if ( a6 >= 10 )
  {
    v9 = a6;
    v10 = _InterlockedExchange(&dword_805B118, a6);
    v11 = _InterlockedExchange(&dword_805B118, a5);
    _InterlockedExchange(&dword_805B118, v10);
    if ( (v11 - 1) * v9 & 1 )
      abort();
  }
  __asm { popfw }
  return sub_8051523(v13, a7, a8, a9, (int)&unk_805B1F8);
}
// 8052408: could not find valid save-restore pair for ebp
// 805B118: using guessed type int dword_805B118;

//----- (08052466) --------------------------------------------------------
signed int sub_8052466()
{
  return -423;
}

//----- (08052582) --------------------------------------------------------
void *__usercall sub_8052582@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>, signed int a3, signed __int32 a4)
{
  char v4; // sf

  return sub_8052408(0, 0, v4, 0, a1, a2, a3, a4, 0xFFFFFFFF);
}

//----- (080525AB) --------------------------------------------------------
signed int __usercall sub_80525AB@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>)
{
  signed __int32 v6; // ebx
  signed __int32 v7; // ecx
  signed __int32 v8; // ebx
  signed __int32 v9; // et0
  unsigned __int32 v10; // eax
  signed __int32 v11; // edx
  signed __int32 v12; // ecx
  signed __int32 v17; // eax
  signed __int32 v18; // ebx
  signed __int32 v19; // ecx
  signed __int32 v20; // ebx
  signed __int32 v21; // et2
  unsigned int v22; // eax
  signed __int32 v23; // edx
  signed __int32 v28; // ebx
  signed __int32 v29; // edx
  signed __int32 v30; // ebx
  signed __int32 v31; // ett
  unsigned int v32; // eax
  signed __int32 v33; // edx
  signed __int32 v34; // ecx
  signed __int32 v35; // ebx
  signed __int32 v36; // et0
  signed __int32 v37; // eax
  signed __int32 v39; // [esp-10h] [ebp-10h]

  __asm { pushfw }
  v6 = _InterlockedExchange(&dword_805B178, a6);
  v9 = _InterlockedExchange(&dword_805B178, a5);
  v7 = v6;
  v8 = v9;
  _InterlockedExchange(&dword_805B178, v7);
  v10 = sub_804A881();
  _CF = v10 < 0x37D;
  _OF = __OFSUB__(v10, 893);
  _ZF = v10 == 893;
  _SF = (signed int)(v10 - 893) < 0;
  if ( v10 != 893 )
  {
    v17 = _InterlockedExchange(&dword_805B178, v10);
    _InterlockedExchange(&dword_805B178, v11);
    _InterlockedExchange(&dword_805B178, v17);
    sub_804A88B(v12);
  }
  __asm { pushfw }
  v18 = _InterlockedExchange(&dword_805B16C, v8);
  v21 = _InterlockedExchange(&dword_805B16C, v12);
  v19 = v18;
  v20 = v21;
  v22 = sub_804B058(0, 1, 0, 0, _InterlockedExchange(&dword_805B16C, v19), v21);
  _CF = v22 < 0xFFFFFCD4;
  _OF = __OFSUB__(v22, -812);
  _ZF = v22 == -812;
  _SF = (signed int)(v22 + 812) < 0;
  if ( v22 != -812 )
  {
    v39 = v22;
    __asm { pushfw }
    v28 = _InterlockedExchange(&dword_805B130, v20);
    v31 = _InterlockedExchange(&dword_805B130, v23);
    v29 = v28;
    v30 = v31;
    _InterlockedExchange(&dword_805B130, v29);
    v32 = sub_804AFB8();
    if ( v32 != 876 )
    {
      v35 = _InterlockedExchange(&dword_805B130, v30);
      v36 = _InterlockedExchange(&dword_805B130, v34);
      _InterlockedExchange(&dword_805B130, v35);
      sub_804AFC2(v32 < 0x36C, v32 == 876, (signed int)(v32 - 876) < 0, __OFSUB__(v32, 876), v33, v36);
    }
    __asm { popfw }
    v37 = _InterlockedExchange(&dword_805B16C, v39);
    _InterlockedExchange(&dword_805B16C, v33);
    sub_804B0A0(_CF, _ZF, _SF, _OF, _InterlockedExchange(&dword_805B16C, v37), v34, v30);
  }
  __asm
  {
    popfw
    popfw
  }
  return -398;
}
// 804A88B: using guessed type int __fastcall sub_804A88B(_DWORD);
// 805B130: using guessed type int dword_805B130;
// 805B16C: using guessed type int dword_805B16C;
// 805B178: using guessed type int dword_805B178;

//----- (08052670) --------------------------------------------------------
signed int sub_8052670()
{
  return -41;
}

//----- (080527FB) --------------------------------------------------------
int __usercall sub_80527FB@<eax>(signed __int32 a1@<ebx>, int fd)
{
  return sub_8053AF0(a1, fd, 0, 3);
}

//----- (0805281E) --------------------------------------------------------
int __usercall sub_805281E@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, FILE *stream, int a9, int a10, int a11, signed __int32 *a12, int a13)
{
  signed __int32 v13; // ebx
  signed __int32 v14; // ecx
  signed __int32 v15; // ebx
  signed __int32 v16; // et0
  signed __int32 v17; // eax
  signed __int32 v18; // edx
  int v19; // ecx
  signed __int32 v20; // eax
  signed __int32 v21; // ebx
  signed __int32 v22; // edx
  signed __int32 v23; // ebx
  signed __int32 v24; // et2
  unsigned int v25; // eax
  signed __int32 v26; // edx
  signed __int32 v27; // ecx
  signed __int32 v28; // ebx
  signed __int32 v29; // ett
  char v30; // al
  signed __int32 v31; // et0
  signed __int32 v32; // ebx
  signed __int32 v33; // edx
  signed __int32 v34; // ebx
  signed __int32 v35; // et1
  unsigned int v36; // eax
  signed __int32 v37; // edx
  signed __int32 v38; // ecx
  signed __int32 v39; // ebx
  signed __int32 v40; // et2
  char v41; // al
  signed __int32 v42; // ebx
  signed __int32 v43; // ett
  signed __int32 v44; // ebx
  int v45; // eax
  signed __int32 v50; // ebx
  signed __int32 v51; // ecx
  signed __int32 v52; // ebx
  signed __int32 v53; // et0
  signed __int32 v54; // edx
  int v55; // ecx
  signed __int32 v56; // ebx
  char v57; // al
  signed __int32 v58; // et2
  signed __int32 v59; // edx
  int v60; // eax
  signed __int32 v65; // ebx
  signed __int32 v66; // edx
  signed __int32 v67; // ebx
  signed __int32 v68; // ett
  unsigned int v69; // eax
  signed __int32 v70; // edx
  signed __int32 v71; // ecx
  signed __int32 v76; // ebx
  signed __int32 v81; // eax
  unsigned __int32 v82; // eax
  signed __int32 v83; // edx
  signed __int32 v84; // ecx
  bool v85; // cf
  bool v86; // zf
  bool v87; // sf
  char v88; // of
  signed __int32 v89; // eax
  char v90; // al
  signed __int32 v91; // ett
  char *v92; // eax
  char *v93; // eax
  signed __int32 v94; // ebx
  char *format; // eax
  int result; // eax
  signed __int32 v97; // esi
  signed __int32 v98; // ebx
  char *v99; // eax
  signed __int32 v100; // edi
  signed __int32 v101; // esi
  signed __int32 v102; // ebx
  char *v103; // eax
  signed __int32 v104; // ST58_4
  signed __int32 v105; // ST54_4
  signed __int32 v106; // edi
  signed __int32 v107; // esi
  signed __int32 v108; // ebx
  char *v109; // eax
  signed __int32 v110; // edx
  char v111; // al
  signed __int32 v112; // et0
  signed __int32 v113; // ST58_4
  signed __int32 v114; // ST54_4
  signed __int32 v115; // ST50_4
  signed __int32 v116; // edi
  signed __int32 v117; // esi
  signed __int32 v118; // ebx
  char *v119; // eax
  signed __int32 v120; // ebx
  signed __int32 v121; // ecx
  signed __int32 v122; // ecx
  signed __int32 v123; // ebx
  signed __int32 v124; // et1
  signed __int32 v125; // edx
  int v126; // ecx
  signed __int32 v127; // ebx
  signed __int32 v128; // esi
  signed __int32 v129; // ST58_4
  signed __int32 v130; // ST54_4
  signed __int32 v131; // ST50_4
  signed __int32 v132; // ST4C_4
  signed __int32 v133; // edi
  signed __int32 v134; // ebx
  char *v135; // eax
  signed __int32 v136; // edi
  signed __int32 v137; // ST58_4
  signed __int32 v138; // ST54_4
  signed __int32 v139; // ST50_4
  signed __int32 v140; // ST4C_4
  signed __int32 v141; // ST48_4
  signed __int32 v142; // esi
  signed __int32 v143; // ebx
  char *v144; // eax
  signed __int32 v145; // edi
  signed __int32 v146; // ST58_4
  signed __int32 v147; // ST54_4
  signed __int32 v148; // ST50_4
  signed __int32 v149; // ST4C_4
  signed __int32 v150; // ST48_4
  signed __int32 v151; // ST44_4
  signed __int32 v152; // esi
  signed __int32 v153; // ebx
  char *v154; // eax
  signed __int32 v155; // edi
  signed __int32 v156; // ST58_4
  signed __int32 v157; // ST54_4
  signed __int32 v158; // ST50_4
  signed __int32 v159; // ST4C_4
  signed __int32 v160; // ST48_4
  signed __int32 v161; // ST44_4
  signed __int32 v162; // esi
  signed __int32 v163; // ebx
  char *v164; // eax
  signed __int32 v165; // ST58_4
  signed __int32 v166; // edi
  signed __int32 v167; // esi
  signed __int32 v168; // ebx
  char *v169; // eax
  int v170; // [esp-4h] [ebp-70h]
  int v171; // [esp-4h] [ebp-70h]
  signed __int32 v172; // [esp+62h] [ebp-Ah]
  int v173; // [esp+68h] [ebp-4h]

  v173 = a5;
  __asm { pushfw }
  v13 = _InterlockedExchange(&dword_805B118, a7);
  v16 = _InterlockedExchange(&dword_805B118, a6);
  v14 = v13;
  v15 = v16;
  _InterlockedExchange(&dword_805B118, v14);
  v17 = sub_80550AC();
  if ( v17 != 445 )
  {
    v20 = _InterlockedExchange(&dword_805B118, v17);
    _InterlockedExchange(&dword_805B118, v18);
    _InterlockedExchange(&dword_805B118, v20);
    sub_80550B6(v19);
  }
  __asm
  {
    popfw
    pushfw
  }
  v21 = _InterlockedExchange(&dword_805B124, v15);
  v24 = _InterlockedExchange(&dword_805B124, v18);
  v22 = v21;
  v23 = v24;
  _InterlockedExchange(&dword_805B124, v22);
  v25 = sub_805194D();
  if ( v25 != 44 )
  {
    v28 = _InterlockedExchange(&dword_805B124, v23);
    v29 = _InterlockedExchange(&dword_805B124, v27);
    _InterlockedExchange(&dword_805B124, v28);
    sub_8051957(v25 < 0x2C, v25 == 44, (signed int)(v25 - 44) < 0, __OFSUB__(v25, 44), v26, v29);
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( v23 >= 10 )
  {
    v31 = _InterlockedExchange(&dword_805B148, v23);
    v30 = _InterlockedExchange(&dword_805B148, v26);
    v26 = _InterlockedExchange(&dword_805B148, v31);
    if ( ((_BYTE)v23 - 1) * v30 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  v32 = _InterlockedExchange(&dword_805B154, v23);
  v35 = _InterlockedExchange(&dword_805B154, v26);
  v33 = v32;
  v34 = v35;
  v36 = sub_804B522(_CF, _ZF, _SF, _OF, v173, _InterlockedExchange(&dword_805B154, v33), v27, v35);
  if ( v36 != -958 )
  {
    v39 = _InterlockedExchange(&dword_805B154, v34);
    v40 = _InterlockedExchange(&dword_805B154, v37);
    _InterlockedExchange(&dword_805B154, v39);
    sub_804B619(v36 < 0xFFFFFC42, v36 == -958, (signed int)(v36 + 958) < 0, __OFSUB__(v36, -958), v38, v40);
  }
  __asm
  {
    popfw
    pushfw
  }
  v172 = v34;
  if ( v34 >= 10 )
  {
    v41 = v34;
    v42 = _InterlockedExchange(&dword_805B190, v34);
    v43 = _InterlockedExchange(&dword_805B190, v37);
    v37 = _InterlockedExchange(&dword_805B190, v42);
    v44 = v43 - 1;
    v45 = ((_BYTE)v43 - 1) * v41 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = v45 == 0;
    _SF = v45 < 0;
    if ( v45 )
    {
      __asm { pushfw }
      v50 = _InterlockedExchange(&dword_805B13C, v44);
      v53 = _InterlockedExchange(&dword_805B13C, v38);
      v51 = v50;
      v52 = v53;
      _InterlockedExchange(&dword_805B13C, v51);
      if ( sub_8052670() != -41 )
      {
        v56 = _InterlockedExchange(&dword_805B13C, v52);
        _InterlockedExchange(&dword_805B13C, v54);
        sub_805267A(v55, _InterlockedExchange(&dword_805B13C, v56));
      }
      __asm { popfw }
      abort();
    }
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( v172 >= 10 )
  {
    v58 = _InterlockedExchange(&dword_805B19C, v172);
    v57 = _InterlockedExchange(&dword_805B19C, v37);
    v59 = _InterlockedExchange(&dword_805B19C, v58);
    v60 = ((_BYTE)v172 - 1) * v57 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = v60 == 0;
    _SF = v60 < 0;
    if ( v60 )
    {
      __asm { pushfw }
      v65 = _InterlockedExchange(&dword_805B178, v172 - 1);
      v68 = _InterlockedExchange(&dword_805B178, v59);
      v66 = v65;
      v67 = v68;
      _InterlockedExchange(&dword_805B178, v66);
      v69 = sub_804A881();
      _CF = v69 < 0x37D;
      _OF = __OFSUB__(v69, 893);
      _ZF = v69 == 893;
      _SF = (signed int)(v69 - 893) < 0;
      if ( v69 != 893 )
      {
        v76 = _InterlockedExchange(&dword_805B178, v67);
        _InterlockedExchange(&dword_805B178, v71);
        sub_804A88B(_InterlockedExchange(&dword_805B178, v76));
      }
      __asm { pushfw }
      _CF = (unsigned int)v67 < 0xA;
      _OF = __OFSUB__(v67, 10);
      _ZF = v67 == 10;
      _SF = v67 - 10 < 0;
      if ( v67 >= 10 )
      {
        __asm { pushfw }
        v81 = _InterlockedExchange(&dword_805B124, 893);
        _InterlockedExchange(&dword_805B124, v70);
        _InterlockedExchange(&dword_805B124, v81);
        v82 = sub_805194D();
        v85 = v82 < 0x2C;
        v88 = __OFSUB__(v82, 44);
        v86 = v82 == 44;
        v87 = (signed int)(v82 - 44) < 0;
        if ( v82 != 44 )
        {
          v89 = _InterlockedExchange(&dword_805B124, v82);
          _InterlockedExchange(&dword_805B124, v84);
          _InterlockedExchange(&dword_805B124, v89);
          sub_8051957(v85, v86, v87, v88, v83, v67);
        }
        __asm { popfw }
        v91 = _InterlockedExchange(&dword_805B148, v67);
        v90 = _InterlockedExchange(&dword_805B148, v83);
        _InterlockedExchange(&dword_805B148, v91);
        if ( ((_BYTE)v67 - 1) * v90 & 1 )
          abort();
      }
      __asm
      {
        popfw
        popfw
      }
      abort();
    }
  }
  __asm { popfw }
  if ( a9 )
    fprintf(stream, "%s (%s) %s\n", a9, a10, a11);
  else
    fprintf(stream, "%s %s\n", a10, a11);
  v92 = gettext("(C)");
  fprintf(stream, "Copyright %s %d Free Software Foundation, Inc.", v92, 2017);
  v93 = gettext(aLicenseGplv3Gn);
  fputs_unlocked(v93, stream);
  switch ( a13 )
  {
    case 0:
      abort();
      return result;
    case 1:
      v94 = *a12;
      format = gettext("Written by %s.\n");
      result = fprintf(stream, format, v94);
      break;
    case 2:
      v97 = a12[1];
      v98 = *a12;
      v99 = gettext("Written by %s and %s.\n");
      result = fprintf(stream, v99, v98, v97);
      break;
    case 3:
      v100 = a12[2];
      v101 = a12[1];
      v102 = *a12;
      v103 = gettext("Written by %s, %s, and %s.\n");
      result = fprintf(stream, v103, v102, v101, v100);
      break;
    case 4:
      v165 = a12[3];
      v166 = a12[2];
      v167 = a12[1];
      v168 = *a12;
      v169 = gettext("Written by %s, %s, %s,\nand %s.\n");
      result = fprintf(stream, v169, v168, v167, v166, v165);
      break;
    case 5:
      v104 = a12[4];
      v105 = a12[3];
      v106 = a12[2];
      v107 = a12[1];
      v108 = *a12;
      v109 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
      v170 = fprintf(stream, v109, v108, v107, v106, v105, v104);
      __asm { pushfw }
      if ( v108 >= 10 )
      {
        v112 = _InterlockedExchange(&dword_805B19C, v108);
        v111 = _InterlockedExchange(&dword_805B19C, v110);
        _InterlockedExchange(&dword_805B19C, v112);
        if ( ((_BYTE)v108 - 1) * v111 & 1 )
          abort();
      }
      __asm { popfw }
      result = v170;
      break;
    case 6:
      v113 = a12[5];
      v114 = a12[4];
      v115 = a12[3];
      v116 = a12[2];
      v117 = a12[1];
      v118 = *a12;
      v119 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
      v171 = fprintf(stream, v119, v118, v117, v116, v115, v114, v113);
      __asm { pushfw }
      v120 = _InterlockedExchange(&dword_805B118, v118);
      v124 = _InterlockedExchange(&dword_805B118, v121);
      v122 = v120;
      v123 = v124;
      _InterlockedExchange(&dword_805B118, v122);
      if ( sub_80550AC() != 445 )
      {
        v127 = _InterlockedExchange(&dword_805B118, v123);
        _InterlockedExchange(&dword_805B118, v125);
        _InterlockedExchange(&dword_805B118, v127);
        sub_80550B6(v126);
      }
      __asm { popfw }
      result = v171;
      break;
    case 7:
      v128 = a12[6];
      v129 = a12[5];
      v130 = a12[4];
      v131 = a12[3];
      v132 = a12[2];
      v133 = a12[1];
      v134 = *a12;
      v135 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
      result = fprintf(stream, v135, v134, v133, v132, v131, v130, v129, v128);
      break;
    case 8:
      v136 = a12[7];
      v137 = a12[6];
      v138 = a12[5];
      v139 = a12[4];
      v140 = a12[3];
      v141 = a12[2];
      v142 = a12[1];
      v143 = *a12;
      v144 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
      result = fprintf(stream, v144, v143, v142, v141, v140, v139, v138, v137, v136);
      break;
    case 9:
      v145 = a12[8];
      v146 = a12[7];
      v147 = a12[6];
      v148 = a12[5];
      v149 = a12[4];
      v150 = a12[3];
      v151 = a12[2];
      v152 = a12[1];
      v153 = *a12;
      v154 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
      result = fprintf(stream, v154, v153, v152, v151, v150, v149, v148, v147, v146, v145);
      break;
    default:
      v155 = a12[8];
      v156 = a12[7];
      v157 = a12[6];
      v158 = a12[5];
      v159 = a12[4];
      v160 = a12[3];
      v161 = a12[2];
      v162 = a12[1];
      v163 = *a12;
      v164 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
      result = fprintf(stream, v164, v163, v162, v161, v160, v159, v158, v157, v156, v155);
      break;
  }
  return result;
}
// 8048F20: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 804A88B: using guessed type int __fastcall sub_804A88B(_DWORD);
// 805267A: using guessed type int __fastcall sub_805267A(_DWORD, _DWORD);
// 80550B6: using guessed type int __fastcall sub_80550B6(_DWORD);
// 805B118: using guessed type int dword_805B118;
// 805B124: using guessed type int dword_805B124;
// 805B13C: using guessed type int dword_805B13C;
// 805B148: using guessed type int dword_805B148;
// 805B154: using guessed type int dword_805B154;
// 805B178: using guessed type int dword_805B178;
// 805B190: using guessed type int dword_805B190;
// 805B19C: using guessed type int dword_805B19C;

//----- (08053067) --------------------------------------------------------
int __usercall sub_8053067@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, FILE *a4, int a5, int a6, int a7, signed __int32 *a8)
{
  char v13; // al
  signed __int32 v14; // et0
  signed __int32 v15; // ebx
  signed __int32 v16; // edx
  signed __int32 v17; // et1
  unsigned __int32 v18; // eax
  signed __int32 v19; // edx
  bool v20; // cf
  bool v21; // zf
  bool v22; // sf
  char v23; // of
  signed __int32 v24; // eax
  signed __int32 v25; // et2
  signed __int32 *v26; // eax
  int v27; // eax
  unsigned int i; // [esp+24h] [ebp-34h]
  int v29[12]; // [esp+28h] [ebp-30h]

  for ( i = 0; ; ++i )
  {
    _CF = i < 9;
    _OF = __OFSUB__(i, 9);
    _ZF = i == 9;
    _SF = (signed int)(i - 9) < 0;
    if ( i > 9 )
      break;
    __asm { pushfw }
    if ( a3 >= 10 )
    {
      v14 = _InterlockedExchange(&dword_805B10C, a3);
      v13 = _InterlockedExchange(&dword_805B10C, a2);
      _InterlockedExchange(&dword_805B10C, v14);
      if ( ((_BYTE)a3 - 1) * v13 & 1 )
        abort();
    }
    __asm
    {
      popfw
      pushfw
    }
    v15 = _InterlockedExchange(&dword_805B19C, a3);
    v17 = _InterlockedExchange(&dword_805B19C, a1);
    v16 = v15;
    a3 = v17;
    _InterlockedExchange(&dword_805B19C, v16);
    v18 = sub_8054E13();
    v20 = v18 < 0x390;
    v23 = __OFSUB__(v18, 912);
    v21 = v18 == 912;
    v22 = (signed int)(v18 - 912) < 0;
    if ( v18 != 912 )
    {
      v25 = _InterlockedExchange(&dword_805B19C, v18);
      v24 = _InterlockedExchange(&dword_805B19C, v19);
      _InterlockedExchange(&dword_805B19C, v25);
      sub_8054E1D(v20, v21, v22, v23, v24, a2, a3);
    }
    __asm { popfw }
    v26 = a8;
    ++a8;
    a1 = *v26;
    v29[i] = *v26;
    v27 = v29[i];
    _CF = 0;
    _OF = 0;
    _ZF = v27 == 0;
    _SF = v27 < 0;
    if ( !v27 )
      break;
  }
  return sub_805281E(_CF, _ZF, _SF, _OF, (int)a4, a2, a3, a4, a5, a6, a7, v29, i);
}
// 805B10C: using guessed type int dword_805B10C;
// 805B19C: using guessed type int dword_805B19C;
// 8053067: using guessed type int var_30[12];

//----- (080531F8) --------------------------------------------------------
int __usercall sub_80531F8@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, FILE *a4, int a5, int a6, int a7, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a7);
  return sub_8053067(a1, a2, a3, a4, a5, a6, a7, (signed __int32 *)va);
}

//----- (080533B3) --------------------------------------------------------
void *__usercall sub_80533B3@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, void *a4, unsigned int *a5, unsigned int a6)
{
  signed __int32 v10; // ebx
  signed __int32 v11; // edx
  signed __int32 v12; // et0
  signed __int32 v13; // edx
  signed __int32 v14; // ebx
  char v19; // al
  signed __int32 v20; // et2
  char v25; // al
  signed __int32 v26; // ett
  signed __int32 v27; // ecx
  signed __int32 v28; // ebx
  int v29; // eax
  char v34; // al
  signed __int32 v35; // ebx
  char v36; // t0
  signed __int32 v38; // [esp-Ah] [ebp-32h]
  unsigned int v39; // [esp+1Ch] [ebp-Ch]

  v39 = *a5;
  _CF = 0;
  _OF = 0;
  _ZF = a4 == 0;
  _SF = (signed int)a4 < 0;
  if ( a4 )
  {
    _CF = 0x55555554 / a6 < v39;
    _OF = __OFSUB__(0x55555554 / a6, v39);
    _ZF = 0x55555554 / a6 == v39;
    _SF = (signed int)(0x55555554 / a6 - v39) < 0;
    if ( 0x55555554 / a6 <= v39 )
    {
      __asm { pushfw }
      v38 = a3;
      if ( a3 >= 10 )
      {
        v26 = _InterlockedExchange(&dword_805B190, a3);
        v25 = _InterlockedExchange(&dword_805B190, a2);
        v27 = _InterlockedExchange(&dword_805B190, v26);
        v28 = a3 - 1;
        v29 = (_BYTE)v28 * v25 & 1;
        _CF = 0;
        _OF = 0;
        _ZF = v29 == 0;
        _SF = v29 < 0;
        if ( v29 )
        {
          __asm { pushfw }
          if ( v28 >= 10 )
          {
            v34 = v28;
            v35 = _InterlockedExchange(&dword_805B124, v28);
            v36 = _InterlockedExchange(&dword_805B124, v27);
            _InterlockedExchange(&dword_805B124, v35);
            if ( (v36 - 1) * v34 & 1 )
              abort();
          }
          __asm { popfw }
          abort();
        }
      }
      __asm { popfw }
      sub_8053913(v38);
    }
    v39 += (v39 >> 1) + 1;
  }
  else
  {
    __asm { pushfw }
    v10 = _InterlockedExchange(&dword_805B118, a3);
    v12 = _InterlockedExchange(&dword_805B118, a1);
    v11 = v10;
    a3 = v12;
    _InterlockedExchange(&dword_805B118, v11);
    if ( sub_80550AC() != 445 )
    {
      v14 = _InterlockedExchange(&dword_805B118, a3);
      _InterlockedExchange(&dword_805B118, a2);
      sub_80550B6(_InterlockedExchange(&dword_805B118, v14));
    }
    __asm { popfw }
    _CF = 0;
    _OF = 0;
    _ZF = v39 == 0;
    _SF = (v39 & 0x80000000) != 0;
    if ( !v39 )
    {
      __asm { pushfw }
      if ( a3 >= 10 )
      {
        v20 = _InterlockedExchange(&dword_805B184, a3);
        v19 = _InterlockedExchange(&dword_805B184, v13);
        _InterlockedExchange(&dword_805B184, v20);
        if ( ((_BYTE)a3 - 1) * v19 & 1 )
          abort();
      }
      __asm { popfw }
      v39 = (0x40 / a6 == 0) + 0x40 / a6;
    }
    if ( 0x7FFFFFFF / a6 < v39 )
      sub_8053913(a3);
  }
  *a5 = v39;
  return sub_8053627(
           (unsigned __int64)((signed int)a6 * (signed __int64)(signed int)v39) >> 32 != 0,
           _ZF,
           _SF,
           (unsigned __int64)((signed int)a6 * (signed __int64)(signed int)v39) >> 32 != 0,
           a2,
           a3,
           a4,
           a6 * v39);
}
// 80550B6: using guessed type int __fastcall sub_80550B6(_DWORD);
// 805B118: using guessed type int dword_805B118;
// 805B124: using guessed type int dword_805B124;
// 805B184: using guessed type int dword_805B184;
// 805B190: using guessed type int dword_805B190;

//----- (0805352E) --------------------------------------------------------
void *__usercall sub_805352E@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>, unsigned __int32 a3)
{
  signed __int32 v7; // ebx
  signed __int32 v8; // edx
  signed __int32 v9; // edx
  signed __int32 v10; // ebx
  signed __int32 v11; // et0
  unsigned int v12; // eax
  signed __int32 v13; // edx
  void *v15; // [esp-4h] [ebp-1Ch]

  v15 = sub_8053580(0, 0, _SF, 0, a3, a1, a2, a3);
  __asm { pushfw }
  v7 = _InterlockedExchange(&dword_805B130, a2);
  v11 = _InterlockedExchange(&dword_805B130, v8);
  v9 = v7;
  v10 = v11;
  _InterlockedExchange(&dword_805B130, v9);
  v12 = sub_804AFB8();
  if ( v12 != 876 )
    sub_804AFC2(
      v12 < 0x36C,
      v12 == 876,
      (signed int)(v12 - 876) < 0,
      __OFSUB__(v12, 876),
      _InterlockedExchange(&dword_805B130, _InterlockedExchange(&dword_805B130, v10)),
      _InterlockedExchange(&dword_805B130, v13));
  __asm { popfw }
  return v15;
}
// 805B130: using guessed type int dword_805B130;

//----- (08053580) --------------------------------------------------------
void *__usercall sub_8053580@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>, size_t size)
{
  signed __int32 v8; // eax
  int v9; // edx
  signed __int32 v10; // ecx
  signed __int32 v11; // ebx
  void *v12; // eax
  signed __int32 v13; // ebx
  signed __int32 v14; // ecx
  signed __int32 v15; // ecx
  signed __int32 v16; // ebx
  signed __int32 v17; // et2
  signed __int32 v18; // edx
  unsigned int v19; // eax
  signed __int32 v20; // edx
  signed __int32 v21; // ecx
  signed __int32 v22; // ebx
  signed __int32 v23; // ett
  void *v25; // [esp-4h] [ebp-30h]

  __asm { pushfw }
  v8 = _InterlockedExchange(&dword_805B148, a5);
  _InterlockedExchange(&dword_805B148, a6);
  _InterlockedExchange(&dword_805B148, v8);
  if ( sub_80537D9() != 862 )
  {
    v11 = _InterlockedExchange(&dword_805B148, a7);
    _InterlockedExchange(&dword_805B148, v10);
    sub_80537E3(_InterlockedExchange(&dword_805B148, v11), v9);
  }
  __asm { popfw }
  v12 = malloc(size);
  v25 = v12;
  __asm { pushfw }
  v13 = _InterlockedExchange(&dword_805B154, a7);
  v17 = _InterlockedExchange(&dword_805B154, v14);
  v15 = v13;
  v16 = v17;
  v19 = sub_804B522(_CF, _ZF, _SF, _OF, (signed __int32)v12, v18, _InterlockedExchange(&dword_805B154, v15), v17);
  if ( v19 != -958 )
  {
    v22 = _InterlockedExchange(&dword_805B154, v16);
    v23 = _InterlockedExchange(&dword_805B154, v20);
    _InterlockedExchange(&dword_805B154, v22);
    sub_804B619(v19 < 0xFFFFFC42, v19 == -958, (signed int)(v19 + 958) < 0, __OFSUB__(v19, -958), v21, v23);
  }
  __asm { popfw }
  if ( !v25 && size )
    sub_8053913(v16);
  return v25;
}
// 8053580: could not find valid save-restore pair for ebp
// 80537E3: using guessed type int __fastcall sub_80537E3(_DWORD, _DWORD);
// 805B148: using guessed type int dword_805B148;
// 805B154: using guessed type int dword_805B154;

//----- (08053627) --------------------------------------------------------
void *__usercall sub_8053627@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>, void *ptr, size_t size)
{
  char v8; // al
  signed __int32 v9; // et0
  void *result; // eax
  void *v11; // [esp+20h] [ebp+4h]

  __asm { pushfw }
  if ( a6 >= 10 )
  {
    v9 = _InterlockedExchange(&dword_805B190, a6);
    v8 = _InterlockedExchange(&dword_805B190, a5);
    _InterlockedExchange(&dword_805B190, v9);
    if ( ((_BYTE)a6 - 1) * v8 & 1 )
      abort();
  }
  __asm { popfw }
  if ( size || !ptr )
  {
    v11 = realloc(ptr, size);
    if ( !v11 )
    {
      if ( size )
        sub_8053913(a6);
    }
    result = v11;
  }
  else
  {
    free(ptr);
    result = 0;
  }
  return result;
}
// 8053627: could not find valid save-restore pair for ebp
// 805B190: using guessed type int dword_805B190;

//----- (080537D9) --------------------------------------------------------
signed int sub_80537D9()
{
  return 862;
}

//----- (080537E4) --------------------------------------------------------
void *__usercall sub_80537E4@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, int a9@<ebp>, const void *src, unsigned __int32 n)
{
  char v11; // al
  signed __int32 v12; // et0
  void *dest; // eax
  void *v14; // eax
  signed __int32 v15; // eax
  signed __int32 v16; // ecx
  unsigned __int32 v17; // eax
  signed __int32 v18; // edx
  signed __int32 v19; // ecx
  signed __int32 v24; // ebx
  signed __int32 v25; // edx
  signed __int32 v26; // ebx
  signed __int32 v27; // et2
  unsigned int v28; // eax
  signed __int32 v29; // edx
  signed __int32 v30; // ecx
  signed __int32 v31; // ebx
  signed __int32 v32; // ett
  signed __int32 v33; // ebx
  void *v35; // [esp-4h] [ebp-20h]
  signed __int32 v36; // [esp+12h] [ebp-Ah]
  int v37; // [esp+18h] [ebp-4h]

  v37 = a5;
  __asm { pushfw }
  if ( a8 >= 10 )
  {
    v12 = _InterlockedExchange(&dword_805B118, a8);
    v11 = _InterlockedExchange(&dword_805B118, a7);
    _InterlockedExchange(&dword_805B118, v12);
    if ( ((_BYTE)a8 - 1) * v11 & 1 )
      abort();
  }
  __asm { popfw }
  v37 = a9;
  dest = sub_8053580((unsigned int)&v37 < 0x18, &v37 == 0, (signed int)&v37 < 0, __OFSUB__(&v37, 24), n, a6, v36, n);
  v14 = memcpy(dest, src, n);
  v35 = v14;
  __asm { pushfw }
  v15 = _InterlockedExchange(&dword_805B178, (signed __int32)v14);
  _InterlockedExchange(&dword_805B178, v16);
  _InterlockedExchange(&dword_805B178, v15);
  v17 = sub_804A881();
  _CF = v17 < 0x37D;
  _OF = __OFSUB__(v17, 893);
  _ZF = v17 == 893;
  _SF = (signed int)(v17 - 893) < 0;
  if ( v17 != 893 )
  {
    __asm { pushfw }
    v24 = _InterlockedExchange(&dword_805B154, a8);
    v27 = _InterlockedExchange(&dword_805B154, v18);
    v25 = v24;
    v26 = v27;
    v28 = sub_804B522(
            v17 < 0x37D,
            v17 == 893,
            (signed int)(v17 - 893) < 0,
            __OFSUB__(v17, 893),
            v17,
            _InterlockedExchange(&dword_805B154, v25),
            v19,
            v27);
    if ( v28 != -958 )
    {
      v31 = _InterlockedExchange(&dword_805B154, v26);
      v32 = _InterlockedExchange(&dword_805B154, v29);
      _InterlockedExchange(&dword_805B154, v31);
      sub_804B619(v28 < 0xFFFFFC42, v28 == -958, (signed int)(v28 + 958) < 0, __OFSUB__(v28, -958), v30, v32);
    }
    __asm { popfw }
    v33 = _InterlockedExchange(&dword_805B178, v26);
    _InterlockedExchange(&dword_805B178, v29);
    _InterlockedExchange(&dword_805B178, v33);
    sub_804A88B(v30);
  }
  __asm { popfw }
  return v35;
}
// 80537E4: could not find valid save-restore pair for ebp
// 804A88B: using guessed type int __fastcall sub_804A88B(_DWORD);
// 805B118: using guessed type int dword_805B118;
// 805B154: using guessed type int dword_805B154;
// 805B178: using guessed type int dword_805B178;

//----- (08053913) --------------------------------------------------------
void __usercall __noreturn sub_8053913(signed __int32 a1@<ebx>)
{
  signed __int32 v1; // edx
  signed __int32 v2; // ecx
  char v3; // al
  signed __int32 v4; // et0
  char v5; // al
  signed __int32 v6; // et1
  int v7; // eax
  signed __int32 v12; // eax
  unsigned int v13; // eax
  signed __int32 v14; // edx
  signed __int32 v15; // ecx
  signed __int32 v16; // ebx
  signed __int32 v17; // ett
  char *v18; // [esp-4h] [ebp-1Ch]

  v18 = gettext("memory exhausted");
  __asm { pushfw }
  if ( a1 >= 10 )
  {
    v4 = _InterlockedExchange(&dword_805B118, a1);
    v3 = _InterlockedExchange(&dword_805B118, v1);
    v1 = _InterlockedExchange(&dword_805B118, v4);
    if ( ((_BYTE)a1 - 1) * v3 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( a1 >= 10 )
  {
    v6 = _InterlockedExchange(&dword_805B190, a1);
    v5 = _InterlockedExchange(&dword_805B190, v2);
    _InterlockedExchange(&dword_805B190, v6);
    v7 = ((_BYTE)a1 - 1) * v5 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = v7 == 0;
    _SF = v7 < 0;
    if ( v7 )
    {
      __asm { pushfw }
      v12 = _InterlockedExchange(&dword_805B124, v7);
      _InterlockedExchange(&dword_805B124, v1);
      _InterlockedExchange(&dword_805B124, v12);
      v13 = sub_805194D();
      if ( v13 != 44 )
      {
        v16 = _InterlockedExchange(&dword_805B124, a1 - 1);
        v17 = _InterlockedExchange(&dword_805B124, v15);
        _InterlockedExchange(&dword_805B124, v16);
        sub_8051957(v13 < 0x2C, v13 == 44, (signed int)(v13 - 44) < 0, __OFSUB__(v13, 44), v14, v17);
      }
      __asm { popfw }
      abort();
    }
  }
  __asm { popfw }
  error(status, 0, "%s", v18);
  abort();
}
// 805B118: using guessed type int dword_805B118;
// 805B124: using guessed type int dword_805B124;
// 805B190: using guessed type int dword_805B190;

//----- (080539F0) --------------------------------------------------------
int __usercall sub_80539F0@<eax>(signed __int32 a1@<ebx>, FILE *stream)
{
  int v3; // eax
  signed __int32 v4; // edx
  int v5; // ecx
  signed __int32 v10; // eax
  signed __int32 v11; // eax
  signed __int32 v12; // edx
  int v13; // ecx
  signed __int32 v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // edx
  int v18; // eax
  int v19; // [esp+14h] [ebp-14h]
  int v20; // [esp+18h] [ebp-10h]

  v19 = 0;
  if ( fileno(stream) < 0 )
    return fclose(stream);
  v3 = __freading(stream);
  _CF = 0;
  _OF = 0;
  _ZF = v3 == 0;
  _SF = v3 < 0;
  if ( !v3 )
    goto LABEL_14;
  __asm { pushfw }
  v10 = _InterlockedExchange(&dword_805B148, v3);
  _InterlockedExchange(&dword_805B148, v4);
  _InterlockedExchange(&dword_805B148, v10);
  v11 = sub_80537D9();
  if ( v11 != 862 )
  {
    v14 = _InterlockedExchange(&dword_805B148, v11);
    _InterlockedExchange(&dword_805B148, v12);
    sub_80537E3(v13, _InterlockedExchange(&dword_805B148, v14));
  }
  __asm { popfw }
  v15 = fileno(stream);
  v16 = lseek64(v15, 0, 0, 1);
  v5 = ~v17;
  v18 = ~v17 | ~v16;
  _ZF = v18 == 0;
  _SF = v18 < 0;
  if ( v18 )
  {
LABEL_14:
    if ( sub_8053E5B(0, _ZF, _SF, 0, (signed __int32)stream, v5, a1, stream) )
      v19 = *__errno_location();
  }
  v20 = fclose(stream);
  if ( v19 )
  {
    *__errno_location() = v19;
    v20 = -1;
  }
  return v20;
}
// 8049030: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 80537E3: using guessed type int __fastcall sub_80537E3(_DWORD, _DWORD);
// 805B148: using guessed type int dword_805B148;

//----- (08053AF0) --------------------------------------------------------
int __usercall sub_8053AF0@<eax>(signed __int32 a1@<ebx>, int fd, int cmd, char a4)
{
  signed __int32 v4; // edx
  char v9; // al
  signed __int32 v10; // et0
  signed __int32 v11; // edx
  char v16; // al
  signed __int32 v17; // et1
  signed __int32 v18; // edx
  char v19; // al
  signed __int32 v20; // ebx
  char v21; // t2
  int v22; // ST34_4
  int v24; // [esp-4h] [ebp-3Ch]
  int v25; // [esp+1Ch] [ebp-1Ch]
  char v26; // [esp+20h] [ebp-18h]

  if ( cmd != 1030 )
    return fcntl(fd, cmd, a4);
  v26 = a4;
  if ( dword_805B847 < 0 )
  {
    v25 = sub_8053AF0(fd, 0, a4);
  }
  else
  {
    v25 = fcntl(fd, 1030, a4);
    _CF = 0;
    _OF = 0;
    _ZF = v25 == 0;
    _SF = v25 < 0;
    if ( v25 >= 0 )
      goto LABEL_28;
    __asm { pushfw }
    if ( a1 >= 10 )
    {
      v10 = _InterlockedExchange(&dword_805B19C, a1);
      v9 = _InterlockedExchange(&dword_805B19C, v4);
      _InterlockedExchange(&dword_805B19C, v10);
      if ( ((_BYTE)a1 - 1) * v9 & 1 )
        abort();
    }
    __asm { popfw }
    if ( *__errno_location() == 22 )
    {
      v25 = sub_8053AF0(fd, 0, v26);
      _CF = 0;
      _OF = 0;
      _ZF = v25 == 0;
      _SF = v25 < 0;
      if ( v25 < 0 )
        return v25;
      __asm { pushfw }
      if ( a1 >= 10 )
      {
        v17 = _InterlockedExchange(&dword_805B16C, a1);
        v16 = _InterlockedExchange(&dword_805B16C, v11);
        _InterlockedExchange(&dword_805B16C, v17);
        if ( ((_BYTE)a1 - 1) * v16 & 1 )
          abort();
      }
      __asm { popfw }
      dword_805B847 = -1;
    }
    else
    {
LABEL_28:
      dword_805B847 = 1;
    }
  }
  if ( v25 >= 0 && dword_805B847 == -1 )
  {
    v24 = fcntl(v25, 1);
    __asm { pushfw }
    if ( a1 >= 10 )
    {
      v19 = a1;
      v20 = _InterlockedExchange(&dword_805B184, a1);
      v21 = _InterlockedExchange(&dword_805B184, v18);
      _InterlockedExchange(&dword_805B184, v20);
      if ( (v21 - 1) * v19 & 1 )
        abort();
    }
    __asm { popfw }
    if ( v24 < 0 || fcntl(v25, 2, v24 | 1) == -1 )
    {
      v22 = *__errno_location();
      close(v25);
      *__errno_location() = v22;
      v25 = -1;
    }
  }
  return v25;
}
// 805B16C: using guessed type int dword_805B16C;
// 805B184: using guessed type int dword_805B184;
// 805B19C: using guessed type int dword_805B19C;
// 805B847: using guessed type int dword_805B847;

//----- (08053D06) --------------------------------------------------------
int __usercall sub_8053D06@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, FILE *stream)
{
  signed __int32 v12; // eax
  signed __int32 v13; // edx
  char v14; // al
  signed __int32 v15; // ebx
  signed __int32 v16; // et1
  signed __int32 v17; // ebx
  int v18; // eax
  char v23; // al
  signed __int32 v24; // et2
  signed __int32 v29; // ebx
  signed __int32 v30; // edx
  signed __int32 v31; // ebx
  signed __int32 v32; // ett
  unsigned __int32 v33; // eax
  signed __int32 v34; // edx
  signed __int32 v35; // ecx
  bool v36; // cf
  bool v37; // zf
  bool v38; // sf
  char v39; // of
  signed __int32 v40; // eax
  signed __int32 v41; // ebx
  signed __int32 v42; // ebx
  char v43; // t2
  int result; // eax
  FILE *stream_2; // [esp+2h] [ebp-1Ah]
  unsigned int v46; // [esp+8h] [ebp-14h]
  signed __int32 v47; // [esp+12h] [ebp-Ah]

  __asm { pushfw }
  v47 = a7;
  _CF = (unsigned int)a7 < 0xA;
  _OF = __OFSUB__(a7, 10);
  _ZF = a7 == 10;
  _SF = a7 - 10 < 0;
  if ( a7 >= 10 )
  {
    __asm { pushfw }
    v12 = _InterlockedExchange(&dword_805B148, a5);
    _InterlockedExchange(&dword_805B148, a6);
    _InterlockedExchange(&dword_805B148, v12);
    v46 = sub_80537D9();
    __asm { pushfw }
    stream_2 = (FILE *)a7;
    if ( a7 >= 10 )
    {
      v14 = a7;
      v15 = _InterlockedExchange(&dword_805B118, a7);
      v16 = _InterlockedExchange(&dword_805B118, v13);
      v13 = _InterlockedExchange(&dword_805B118, v15);
      v17 = v16 - 1;
      v18 = ((_BYTE)v16 - 1) * v14 & 1;
      _CF = 0;
      _OF = 0;
      _ZF = v18 == 0;
      _SF = v18 < 0;
      if ( v18 )
      {
        __asm { pushfw }
        if ( v17 >= 10 )
        {
          v24 = _InterlockedExchange(&dword_805B10C, v17);
          v23 = _InterlockedExchange(&dword_805B10C, v13);
          _InterlockedExchange(&dword_805B10C, v24);
          if ( ((_BYTE)v17 - 1) * v23 & 1 )
            abort();
        }
        __asm { popfw }
        abort();
      }
    }
    __asm { popfw }
    _CF = v46 < 0x35E;
    _OF = __OFSUB__(v46, 862);
    _ZF = v46 == 862;
    _SF = (signed int)(v46 - 862) < 0;
    if ( v46 != 862 )
    {
      __asm { pushfw }
      v29 = _InterlockedExchange(&dword_805B124, (signed __int32)stream_2);
      v32 = _InterlockedExchange(&dword_805B124, v13);
      v30 = v29;
      v31 = v32;
      _InterlockedExchange(&dword_805B124, v30);
      v33 = sub_805194D();
      v36 = v33 < 0x2C;
      v39 = __OFSUB__(v33, 44);
      v37 = v33 == 44;
      v38 = (signed int)(v33 - 44) < 0;
      if ( v33 != 44 )
      {
        v40 = _InterlockedExchange(&dword_805B124, v33);
        _InterlockedExchange(&dword_805B124, v35);
        _InterlockedExchange(&dword_805B124, v40);
        sub_8051957(v36, v37, v38, v39, v34, v31);
      }
      __asm { popfw }
      v41 = _InterlockedExchange(&dword_805B148, v31);
      _InterlockedExchange(&dword_805B148, v34);
      sub_80537E3(v35, _InterlockedExchange(&dword_805B148, v41));
    }
    __asm { popfw }
    v42 = _InterlockedExchange(&dword_805B160, (signed __int32)stream_2);
    v43 = _InterlockedExchange(&dword_805B160, v13);
    _InterlockedExchange(&dword_805B160, v42);
    if ( (v43 - 1) * (_BYTE)stream_2 & 1 )
      abort();
  }
  __asm { popfw }
  result = stream->_flags & 0x100;
  if ( result )
    result = sub_8053FD0(a6, v47, stream, 0, 0, 1);
  return result;
}
// 8053D06: could not find valid save-restore pair for ebx
// 8053D06: could not find valid save-restore pair for ebp
// 80537E3: using guessed type int __fastcall sub_80537E3(_DWORD, _DWORD);
// 805B10C: using guessed type int dword_805B10C;
// 805B118: using guessed type int dword_805B118;
// 805B124: using guessed type int dword_805B124;
// 805B148: using guessed type int dword_805B148;
// 805B160: using guessed type int dword_805B160;

//----- (08053E5B) --------------------------------------------------------
int __usercall sub_8053E5B@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, FILE *fp)
{
  signed __int32 v8; // eax
  unsigned int v9; // eax
  signed __int32 v10; // edx
  signed __int32 v11; // ecx
  signed __int32 v12; // ebx
  signed __int32 v13; // et1
  char v14; // al
  signed __int32 v15; // et2
  int v16; // eax
  signed __int32 v17; // eax
  signed __int32 v18; // edx
  unsigned __int32 v19; // eax
  signed __int32 v20; // edx
  signed __int32 v21; // ecx
  bool v22; // cf
  bool v23; // zf
  bool v24; // sf
  char v25; // of
  signed __int32 v26; // eax
  signed __int32 v27; // et0
  char v28; // al
  signed __int32 v29; // et1
  int result; // eax
  int v35; // eax
  signed __int32 v36; // ecx
  int v37; // [esp-4h] [ebp-20h]
  int v38; // [esp-4h] [ebp-20h]

  __asm { pushfw }
  v8 = _InterlockedExchange(&dword_805B130, a5);
  _InterlockedExchange(&dword_805B130, a6);
  _InterlockedExchange(&dword_805B130, v8);
  v9 = sub_804AFB8();
  if ( v9 != 876 )
  {
    v12 = _InterlockedExchange(&dword_805B130, a7);
    v13 = _InterlockedExchange(&dword_805B130, v11);
    _InterlockedExchange(&dword_805B130, v12);
    sub_804AFC2(v9 < 0x36C, v9 == 876, (signed int)(v9 - 876) < 0, __OFSUB__(v9, 876), v10, v13);
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( a7 >= 10 )
  {
    v15 = _InterlockedExchange(&dword_805B160, a7);
    v14 = _InterlockedExchange(&dword_805B160, v11);
    _InterlockedExchange(&dword_805B160, v15);
    if ( ((_BYTE)a7 - 1) * v14 & 1 )
      abort();
  }
  __asm { popfw }
  if ( !fp )
    goto LABEL_19;
  v16 = __freading(fp);
  v37 = v16;
  __asm { pushfw }
  v17 = _InterlockedExchange(&dword_805B19C, v16);
  _InterlockedExchange(&dword_805B19C, v18);
  _InterlockedExchange(&dword_805B19C, v17);
  v19 = sub_8054E13();
  v22 = v19 < 0x390;
  v25 = __OFSUB__(v19, 912);
  v23 = v19 == 912;
  v24 = (signed int)(v19 - 912) < 0;
  if ( v19 != 912 )
  {
    v27 = _InterlockedExchange(&dword_805B19C, v19);
    v26 = _InterlockedExchange(&dword_805B19C, v20);
    _InterlockedExchange(&dword_805B19C, v27);
    sub_8054E1D(v22, v23, v24, v25, v26, v21, a7);
  }
  __asm { popfw }
  if ( v37 )
  {
    sub_8053D06(0, v37 == 0, v37 < 0, 0, (signed __int32)fp, v21, a7, fp);
    result = fflush(fp);
  }
  else
  {
LABEL_19:
    v35 = fflush(fp);
    v38 = v35;
    __asm { pushfw }
    if ( a7 >= 10 )
    {
      v29 = _InterlockedExchange(&dword_805B190, a7);
      v28 = _InterlockedExchange(&dword_805B190, v36);
      _InterlockedExchange(&dword_805B190, v29);
      if ( ((_BYTE)a7 - 1) * v28 & 1 )
        abort();
    }
    __asm { popfw }
    result = v38;
  }
  return result;
}
// 8053E5B: could not find valid save-restore pair for ebp
// 805B130: using guessed type int dword_805B130;
// 805B160: using guessed type int dword_805B160;
// 805B190: using guessed type int dword_805B190;
// 805B19C: using guessed type int dword_805B19C;

//----- (08053FD0) --------------------------------------------------------
int __usercall sub_8053FD0@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, FILE *stream, int a4, int a5, int a6)
{
  char *v6; // edx
  char *v7; // eax
  char *v12; // edx
  char *v13; // eax
  char *v14; // eax
  int v15; // edx
  int v16; // eax
  signed __int32 v21; // eax
  signed __int32 v22; // eax
  int v23; // edx
  signed __int32 v24; // ecx
  signed __int32 v25; // eax
  signed __int32 v26; // eax
  signed __int32 v27; // eax
  signed __int32 v28; // ecx
  unsigned int v29; // eax
  signed __int32 v30; // edx
  signed __int32 v31; // ecx
  int v32; // eax
  int result; // eax
  char v34; // al
  signed __int32 v35; // et0
  signed __int32 v36; // [esp-4h] [ebp-3Ch]
  signed __int32 v37; // [esp+2Ch] [ebp-Ch]

  v6 = stream->_IO_read_end;
  v7 = stream->_IO_read_ptr;
  _CF = v6 < v7;
  _OF = __OFSUB__(v6, v7);
  _ZF = v6 == v7;
  _SF = v6 - v7 < 0;
  if ( v6 != v7 )
    goto LABEL_19;
  v12 = stream->_IO_write_ptr;
  v13 = stream->_IO_write_base;
  _CF = v12 < v13;
  _OF = __OFSUB__(v12, v13);
  _ZF = v12 == v13;
  _SF = v12 - v13 < 0;
  if ( v12 != v13 || (v14 = stream->_IO_save_base, _CF = 0, _OF = 0, _ZF = v14 == 0, _SF = (signed int)v14 < 0, v14) )
  {
LABEL_19:
    __asm { pushfw }
    if ( a2 >= 10 )
    {
      v35 = _InterlockedExchange(&dword_805B154, a2);
      v34 = _InterlockedExchange(&dword_805B154, a1);
      _InterlockedExchange(&dword_805B154, v35);
      if ( ((_BYTE)a2 - 1) * v34 & 1 )
        abort();
    }
    __asm { popfw }
    result = fseeko64(stream, a4, a5, a6);
  }
  else
  {
    v32 = fileno(stream);
    v26 = lseek64(v32, a4, a5, a6);
    v36 = v26;
    __asm { pushfw }
    v27 = _InterlockedExchange(&dword_805B16C, v26);
    _InterlockedExchange(&dword_805B16C, v28);
    v29 = sub_804B058(_CF, _ZF, _SF, _OF, _InterlockedExchange(&dword_805B16C, v27), a2);
    if ( v29 != -812 )
      sub_804B0A0(
        v29 < 0xFFFFFCD4,
        v29 == -812,
        (signed int)(v29 + 812) < 0,
        __OFSUB__(v29, -812),
        _InterlockedExchange(&dword_805B16C, _InterlockedExchange(&dword_805B16C, a2)),
        v31,
        _InterlockedExchange(&dword_805B16C, v30));
    __asm { popfw }
    v37 = v30;
    v15 = ~v30;
    v16 = v15 | ~v36;
    _CF = 0;
    _OF = 0;
    _ZF = v16 == 0;
    _SF = v16 < 0;
    if ( v16 )
    {
      stream->_flags &= 0xFFFFFFEF;
      LODWORD(stream->_offset) = v36;
      HIDWORD(stream->_offset) = v37;
      result = 0;
    }
    else
    {
      __asm { pushfw }
      v21 = _InterlockedExchange(&dword_805B13C, 0);
      _InterlockedExchange(&dword_805B13C, v15);
      _InterlockedExchange(&dword_805B13C, v21);
      v22 = sub_8052670();
      if ( v22 != -41 )
      {
        v25 = _InterlockedExchange(&dword_805B13C, v22);
        _InterlockedExchange(&dword_805B13C, v24);
        sub_805267A(_InterlockedExchange(&dword_805B13C, v25), v23);
      }
      __asm { popfw }
      result = -1;
    }
  }
  return result;
}
// 8048DC0: using guessed type int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8049030: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 805267A: using guessed type int __fastcall sub_805267A(_DWORD, _DWORD);
// 805B13C: using guessed type int dword_805B13C;
// 805B154: using guessed type int dword_805B154;
// 805B16C: using guessed type int dword_805B16C;

//----- (080541F6) --------------------------------------------------------
size_t __usercall sub_80541F6@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>, wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  char v10; // al
  signed __int32 v11; // et0
  signed __int32 v12; // edx
  signed __int32 v13; // ecx
  char v18; // al
  signed __int32 v19; // et1
  int v20; // eax
  char v21; // al
  signed __int32 v22; // ebx
  char v23; // t2
  size_t result; // eax
  char v29; // al
  signed __int32 v30; // ett
  signed __int32 v31; // ebx
  int v32; // eax
  char v37; // al
  signed __int32 v38; // et0
  signed __int32 v39; // ebx
  signed __int32 v40; // edx
  signed __int32 v41; // ebx
  signed __int32 v42; // et1
  unsigned int v43; // eax
  signed __int32 v44; // edx
  signed __int32 v45; // ecx
  signed __int32 v46; // ebx
  signed __int32 v47; // et2
  char v48; // al
  signed __int32 v49; // ett
  signed __int32 v50; // [esp-14h] [ebp-3Ch]
  char v51; // [esp+18h] [ebp-10h]
  size_t v52; // [esp+1Ch] [ebp-Ch]

  _CF = 0;
  _OF = 0;
  _ZF = pwc == 0;
  _SF = (signed int)pwc < 0;
  if ( !pwc )
    pwc = (wchar_t *)&v51;
  __asm { pushfw }
  if ( a2 >= 10 )
  {
    v11 = _InterlockedExchange(&dword_805B190, a2);
    v10 = _InterlockedExchange(&dword_805B190, a1);
    _InterlockedExchange(&dword_805B190, v11);
    if ( ((_BYTE)a2 - 1) * v10 & 1 )
      abort();
  }
  __asm { popfw }
  v52 = mbrtowc(pwc, s, n, p);
  _CF = v52 < 0xFFFFFFFD;
  _OF = __OFSUB__(v52, -3);
  _ZF = v52 == -3;
  _SF = (signed int)(v52 + 3) < 0;
  if ( v52 <= 0xFFFFFFFD )
    goto LABEL_30;
  __asm { pushfw }
  if ( a2 >= 10 )
  {
    v19 = _InterlockedExchange(&dword_805B184, a2);
    v18 = _InterlockedExchange(&dword_805B184, v13);
    _InterlockedExchange(&dword_805B184, v19);
    if ( ((_BYTE)a2 - 1) * v18 & 1 )
      abort();
  }
  __asm { popfw }
  _CF = 0;
  _OF = 0;
  _ZF = n == 0;
  _SF = (n & 0x80000000) != 0;
  if ( !n )
    goto LABEL_30;
  v20 = sub_80546BD(a2, 0) ^ 1;
  _CF = 0;
  _OF = 0;
  _ZF = (_BYTE)v20 == 0;
  _SF = (v20 & 0x80u) != 0;
  if ( (_BYTE)v20 )
  {
    __asm { pushfw }
    if ( a2 >= 10 )
    {
      v21 = a2;
      v22 = _InterlockedExchange(&dword_805B148, a2);
      v23 = _InterlockedExchange(&dword_805B148, v12);
      _InterlockedExchange(&dword_805B148, v22);
      if ( (v23 - 1) * v21 & 1 )
        abort();
    }
    __asm { popfw }
    *pwc = (unsigned __int8)*s;
    result = 1;
  }
  else
  {
LABEL_30:
    __asm { pushfw }
    _CF = (unsigned int)a2 < 0xA;
    _OF = __OFSUB__(a2, 10);
    _ZF = a2 == 10;
    _SF = a2 - 10 < 0;
    if ( a2 >= 10 )
    {
      __asm { pushfw }
      v50 = a2;
      if ( a2 >= 10 )
      {
        v30 = _InterlockedExchange(&dword_805B124, a2);
        v29 = _InterlockedExchange(&dword_805B124, v12);
        v12 = _InterlockedExchange(&dword_805B124, v30);
        v31 = a2 - 1;
        v32 = (_BYTE)v31 * v29 & 1;
        _CF = 0;
        _OF = 0;
        _ZF = v32 == 0;
        _SF = v32 < 0;
        if ( v32 )
        {
          __asm { pushfw }
          if ( v31 >= 10 )
          {
            v38 = _InterlockedExchange(&dword_805B118, v31);
            v37 = _InterlockedExchange(&dword_805B118, v12);
            _InterlockedExchange(&dword_805B118, v38);
            if ( ((_BYTE)v31 - 1) * v37 & 1 )
              abort();
          }
          __asm { popfw }
          abort();
        }
      }
      __asm
      {
        popfw
        pushfw
      }
      v39 = _InterlockedExchange(&dword_805B130, v50);
      v42 = _InterlockedExchange(&dword_805B130, v12);
      v40 = v39;
      v41 = v42;
      _InterlockedExchange(&dword_805B130, v40);
      v43 = sub_804AFB8();
      if ( v43 != 876 )
      {
        v46 = _InterlockedExchange(&dword_805B130, v41);
        v47 = _InterlockedExchange(&dword_805B130, v45);
        _InterlockedExchange(&dword_805B130, v46);
        sub_804AFC2(v43 < 0x36C, v43 == 876, (signed int)(v43 - 876) < 0, __OFSUB__(v43, 876), v44, v47);
      }
      __asm { popfw }
      v49 = _InterlockedExchange(&dword_805B160, v41);
      v48 = _InterlockedExchange(&dword_805B160, v45);
      _InterlockedExchange(&dword_805B160, v49);
      if ( ((_BYTE)v41 - 1) * v48 & 1 )
        abort();
    }
    __asm { popfw }
    result = v52;
  }
  return result;
}
// 805B118: using guessed type int dword_805B118;
// 805B124: using guessed type int dword_805B124;
// 805B130: using guessed type int dword_805B130;
// 805B148: using guessed type int dword_805B148;
// 805B160: using guessed type int dword_805B160;
// 805B184: using guessed type int dword_805B184;
// 805B190: using guessed type int dword_805B190;

//----- (080543EB) --------------------------------------------------------
int __usercall sub_80543EB@<eax>(signed __int32 a1@<eax>, signed __int32 a2@<edx>, signed __int32 a3@<ecx>, unsigned __int8 *a4, unsigned __int32 a5)
{
  unsigned __int8 *v5; // esi
  signed __int32 v6; // ebx
  signed __int32 v12; // ebx
  signed __int32 v13; // edx
  unsigned __int8 *v14; // ebx
  signed __int32 v15; // et0
  unsigned __int32 v16; // eax
  signed __int32 v17; // ecx
  bool v18; // cf
  bool v19; // zf
  bool v20; // sf
  char v21; // of
  signed __int32 v22; // eax
  signed __int32 v23; // ecx
  unsigned __int8 v24; // [esp+1Eh] [ebp-Ah]
  unsigned __int8 v25; // [esp+1Fh] [ebp-9h]

  v5 = a4;
  v6 = a5;
  _CF = (unsigned int)a4 < a5;
  _OF = __OFSUB__(a4, a5);
  _ZF = a4 == (unsigned __int8 *)a5;
  _SF = (signed int)&a4[-a5] < 0;
  if ( a4 == (unsigned __int8 *)a5 )
    return 0;
  do
  {
    __asm { pushfw }
    v12 = _InterlockedExchange(&dword_805B154, v6);
    v15 = _InterlockedExchange(&dword_805B154, a2);
    v13 = v12;
    v14 = (unsigned __int8 *)v15;
    v16 = sub_804B522(_CF, _ZF, _SF, _OF, a1, _InterlockedExchange(&dword_805B154, v13), a3, v15);
    v18 = v16 < 0xFFFFFC42;
    v21 = __OFSUB__(v16, -958);
    v19 = v16 == -958;
    v20 = (signed int)(v16 + 958) < 0;
    if ( v16 != -958 )
    {
      v22 = _InterlockedExchange(&dword_805B154, v16);
      _InterlockedExchange(&dword_805B154, v17);
      sub_804B619(v18, v19, v20, v21, _InterlockedExchange(&dword_805B154, v22), (signed __int32)v14);
    }
    __asm { popfw }
    v24 = sub_80550DC(v17, (signed __int32)v14, *v5);
    v25 = sub_80550DC(v23, (signed __int32)v14, *v14);
    if ( !v24 )
      break;
    ++v5;
    v6 = (signed __int32)(v14 + 1);
    a1 = v24;
    _CF = v24 < v25;
    _OF = __OFSUB__(v24, v25);
    _ZF = v24 == v25;
    _SF = (char)(v24 - v25) < 0;
  }
  while ( v24 == v25 );
  return v24 - v25;
}
// 805B154: using guessed type int dword_805B154;

//----- (08054491) --------------------------------------------------------
signed int __usercall sub_8054491@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, int a8@<ebp>, FILE *fp)
{
  signed __int32 v9; // eax
  signed __int32 v10; // eax
  signed __int32 v11; // edx
  int v12; // ecx
  signed __int32 v13; // eax
  signed __int32 v14; // ecx
  char v19; // al
  signed __int32 v20; // ebx
  signed __int32 v21; // et2
  int v22; // eax
  signed __int32 v23; // ebx
  signed __int32 v24; // ecx
  signed __int32 v25; // ebx
  signed __int32 v26; // ett
  unsigned __int32 v27; // eax
  signed __int32 v28; // edx
  bool v29; // cf
  bool v30; // zf
  bool v31; // sf
  char v32; // of
  signed __int32 v33; // eax
  signed __int32 v34; // ebx
  signed __int32 v35; // ebx
  signed __int32 v36; // edx
  signed __int32 v37; // edx
  signed __int32 v38; // et1
  signed __int32 v39; // ecx
  signed __int32 v40; // ebx
  signed __int32 v45; // ebx
  signed __int32 v46; // edx
  signed __int32 v47; // ebx
  signed __int32 v48; // ett
  unsigned __int32 v49; // eax
  signed __int32 v50; // edx
  signed __int32 v51; // ecx
  bool v52; // cf
  bool v53; // zf
  bool v54; // sf
  char v55; // of
  signed __int32 v56; // eax
  signed __int32 v57; // eax
  unsigned int v58; // eax
  signed __int32 v59; // edx
  signed __int32 v60; // ecx
  char v65; // al
  signed __int32 v66; // ebx
  char v67; // t2
  signed __int32 v68; // eax
  signed __int32 v70; // [esp-10h] [ebp-3Ch]
  signed __int32 v71; // [esp-Ah] [ebp-36h]
  signed __int32 v72; // [esp-Ah] [ebp-36h]
  int v73; // [esp-4h] [ebp-30h]
  int *v74; // [esp-4h] [ebp-30h]
  int v75; // [esp-4h] [ebp-30h]
  bool v76; // [esp+1Dh] [ebp-Fh]
  bool v77; // [esp+1Eh] [ebp-Eh]
  bool v78; // [esp+1Fh] [ebp-Dh]
  int v79; // [esp+28h] [ebp-4h]

  v79 = a5;
  __asm { pushfw }
  v9 = _InterlockedExchange(&dword_805B178, a5);
  _InterlockedExchange(&dword_805B178, a6);
  _InterlockedExchange(&dword_805B178, v9);
  v10 = sub_804A881();
  if ( v10 != 893 )
  {
    v13 = _InterlockedExchange(&dword_805B178, v10);
    _InterlockedExchange(&dword_805B178, v11);
    _InterlockedExchange(&dword_805B178, v13);
    sub_804A88B(v12);
  }
  __asm { popfw }
  v79 = a8;
  v76 = __fpending(fp) != 0;
  v77 = ferror_unlocked(fp) != 0;
  v73 = sub_80539F0(a7, fp);
  __asm { pushfw }
  v71 = a7;
  _CF = (unsigned int)a7 < 0xA;
  _OF = __OFSUB__(a7, 10);
  _ZF = a7 == 10;
  _SF = a7 - 10 < 0;
  if ( a7 >= 10 )
  {
    v19 = a7;
    v20 = _InterlockedExchange(&dword_805B19C, a7);
    v21 = _InterlockedExchange(&dword_805B19C, v14);
    v14 = _InterlockedExchange(&dword_805B19C, v20);
    a7 = v21 - 1;
    v22 = ((_BYTE)v21 - 1) * v19 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = v22 == 0;
    _SF = v22 < 0;
    if ( v22 )
      abort();
  }
  __asm { pushfw }
  v23 = _InterlockedExchange(&dword_805B130, a7);
  v26 = _InterlockedExchange(&dword_805B130, v14);
  v24 = v23;
  v25 = v26;
  _InterlockedExchange(&dword_805B130, v24);
  v27 = sub_804AFB8();
  v29 = v27 < 0x36C;
  v32 = __OFSUB__(v27, 876);
  v30 = v27 == 876;
  v31 = (signed int)(v27 - 876) < 0;
  if ( v27 != 876 )
  {
    v33 = _InterlockedExchange(&dword_805B130, v27);
    _InterlockedExchange(&dword_805B130, v28);
    sub_804AFC2(v29, v30, v31, v32, _InterlockedExchange(&dword_805B130, v33), v25);
  }
  __asm { popfw }
  v34 = v71;
  __asm { popfw }
  v78 = v73 != 0;
  if ( !v77 )
  {
    if ( !v78 )
      return 0;
    if ( !v76 )
    {
      v74 = __errno_location();
      __asm { pushfw }
      v35 = _InterlockedExchange(&dword_805B178, v71);
      v38 = _InterlockedExchange(&dword_805B178, v36);
      v37 = v35;
      v34 = v38;
      _InterlockedExchange(&dword_805B178, v37);
      if ( sub_804A881() != 893 )
      {
        v40 = _InterlockedExchange(&dword_805B178, v34);
        _InterlockedExchange(&dword_805B178, v39);
        sub_804A88B(_InterlockedExchange(&dword_805B178, v40));
      }
      __asm { popfw }
      if ( *v74 == 9 )
        return 0;
    }
  }
  _CF = 0;
  _OF = 0;
  _ZF = v78 == 1;
  _SF = !v78 < 0;
  if ( v78 != 1 )
  {
    v75 = !v78;
    __asm { pushfw }
    v45 = _InterlockedExchange(&dword_805B160, v34);
    v48 = _InterlockedExchange(&dword_805B160, v28);
    v46 = v45;
    v47 = v48;
    _InterlockedExchange(&dword_805B160, v46);
    v49 = sub_804FBC9();
    v52 = v49 < 0xFFFFFDBC;
    v55 = __OFSUB__(v49, -580);
    v53 = v49 == -580;
    v54 = (signed int)(v49 + 580) < 0;
    if ( v49 != -580 )
    {
      v56 = _InterlockedExchange(&dword_805B160, v49);
      _InterlockedExchange(&dword_805B160, v50);
      _InterlockedExchange(&dword_805B160, v56);
      sub_804FBD3(v52, v53, v54, v55, v51, v47);
    }
    __asm
    {
      popfw
      pushfw
    }
    v57 = _InterlockedExchange(&dword_805B16C, v75);
    _InterlockedExchange(&dword_805B16C, v50);
    _InterlockedExchange(&dword_805B16C, v57);
    v58 = sub_804B058(_CF, _ZF, _SF, _OF, v51, v47);
    _CF = v58 < 0xFFFFFCD4;
    _OF = __OFSUB__(v58, -812);
    _ZF = v58 == -812;
    _SF = (signed int)(v58 + 812) < 0;
    if ( v58 != -812 )
    {
      v72 = v58;
      __asm { pushfw }
      v70 = v47;
      if ( v47 >= 10 )
      {
        v65 = v47;
        v66 = _InterlockedExchange(&dword_805B124, v47);
        v67 = _InterlockedExchange(&dword_805B124, v60);
        v60 = _InterlockedExchange(&dword_805B124, v66);
        if ( (v67 - 1) * v65 & 1 )
          abort();
      }
      __asm { popfw }
      v68 = _InterlockedExchange(&dword_805B16C, v72);
      _InterlockedExchange(&dword_805B16C, v60);
      sub_804B0A0(_CF, _ZF, _SF, _OF, v59, _InterlockedExchange(&dword_805B16C, v68), v70);
    }
    __asm { popfw }
    *__errno_location() = 0;
  }
  return -1;
}
// 8054491: could not find valid save-restore pair for ebp
// 804A88B: using guessed type int __fastcall sub_804A88B(_DWORD);
// 805B124: using guessed type int dword_805B124;
// 805B130: using guessed type int dword_805B130;
// 805B160: using guessed type int dword_805B160;
// 805B16C: using guessed type int dword_805B16C;
// 805B178: using guessed type int dword_805B178;
// 805B19C: using guessed type int dword_805B19C;

//----- (080546BD) --------------------------------------------------------
int __usercall sub_80546BD@<eax>(signed __int32 a1@<ebx>, int category)
{
  int v2; // eax
  signed __int32 v3; // edx
  signed __int32 v4; // ecx
  char v9; // al
  signed __int32 v10; // et0
  signed __int32 v11; // ebx
  signed __int32 v12; // edx
  signed __int32 v13; // ebx
  signed __int32 v14; // et1
  unsigned int v15; // eax
  signed __int32 v16; // ecx
  signed __int32 v17; // ecx
  char v18; // al
  signed __int32 v19; // ebx
  char v20; // tt
  signed __int32 v22; // [esp-4h] [ebp-2Ch]
  int v23; // [esp-4h] [ebp-2Ch]
  unsigned __int8 v24; // [esp+1Bh] [ebp-Dh]
  const char *s1; // [esp+1Ch] [ebp-Ch]

  v24 = 1;
  s1 = setlocale(category, 0);
  if ( s1 )
  {
    v2 = strcmp(s1, "C");
    _CF = 0;
    _OF = 0;
    _ZF = v2 == 0;
    _SF = v2 < 0;
    if ( !v2 )
      goto LABEL_16;
    v22 = v2;
    __asm { pushfw }
    if ( a1 >= 10 )
    {
      v10 = _InterlockedExchange(&dword_805B10C, a1);
      v9 = _InterlockedExchange(&dword_805B10C, v4);
      v4 = _InterlockedExchange(&dword_805B10C, v10);
      if ( ((_BYTE)a1 - 1) * v9 & 1 )
        abort();
    }
    __asm
    {
      popfw
      pushfw
    }
    v11 = _InterlockedExchange(&dword_805B154, a1);
    v14 = _InterlockedExchange(&dword_805B154, v3);
    v12 = v11;
    v13 = v14;
    v15 = sub_804B522(_CF, _ZF, _SF, _OF, v22, _InterlockedExchange(&dword_805B154, v12), v4, v14);
    if ( v15 != -958 )
      sub_804B619(
        v15 < 0xFFFFFC42,
        v15 == -958,
        (signed int)(v15 + 958) < 0,
        __OFSUB__(v15, -958),
        _InterlockedExchange(&dword_805B154, _InterlockedExchange(&dword_805B154, v13)),
        _InterlockedExchange(&dword_805B154, v16));
    __asm { popfw }
    v23 = strcmp(s1, "POSIX");
    __asm { pushfw }
    if ( v13 >= 10 )
    {
      v18 = v13;
      v19 = _InterlockedExchange(&dword_805B124, v13);
      v20 = _InterlockedExchange(&dword_805B124, v17);
      _InterlockedExchange(&dword_805B124, v19);
      if ( (v20 - 1) * v18 & 1 )
        abort();
    }
    __asm { popfw }
    if ( !v23 )
LABEL_16:
      v24 = 0;
  }
  return v24;
}
// 805B10C: using guessed type int dword_805B10C;
// 805B124: using guessed type int dword_805B124;
// 805B154: using guessed type int dword_805B154;

//----- (080547CB) --------------------------------------------------------
void *__usercall sub_80547CB@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>)
{
  _BOOL4 v2; // eax
  void *v3; // eax
  signed __int32 v4; // edx
  char v9; // al
  signed __int32 v10; // ebx
  char v11; // t0
  void *result; // eax
  unsigned int v17; // et1
  signed __int32 v18; // eax
  signed __int32 v19; // eax
  signed __int32 v20; // ecx
  signed __int32 v21; // eax
  signed __int32 v22; // [esp-Ah] [ebp-D2h]
  void *v23; // [esp+18h] [ebp-B0h]
  const char *s; // [esp+1Ch] [ebp-ACh]
  void *v25; // [esp+20h] [ebp-A8h]
  int v26; // [esp+24h] [ebp-A4h]
  size_t n; // [esp+2Ch] [ebp-9Ch]
  size_t v28; // [esp+30h] [ebp-98h]
  _BOOL4 v29; // [esp+34h] [ebp-94h]
  char *dest; // [esp+38h] [ebp-90h]
  int fd; // [esp+3Ch] [ebp-8Ch]
  FILE *stream; // [esp+40h] [ebp-88h]
  int c; // [esp+44h] [ebp-84h]
  int ca; // [esp+44h] [ebp-84h]
  size_t v35; // [esp+48h] [ebp-80h]
  size_t v36; // [esp+4Ch] [ebp-7Ch]
  void *v37; // [esp+50h] [ebp-78h]
  char src; // [esp+56h] [ebp-72h]
  char v39; // [esp+89h] [ebp-3Fh]
  unsigned int v40; // [esp+BCh] [ebp-Ch]

  v40 = __readgsdword(0x14u);
  v23 = (void *)dword_805B84B;
  if ( !dword_805B84B )
  {
    s = getenv("CHARSETALIASDIR");
    if ( !s || !*s )
      s = "/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib";
    n = strlen(s);
    v28 = strlen("charset.alias");
    v2 = n && s[n - 1] != 47;
    v29 = v2;
    dest = (char *)malloc(n + v2 + v28 + 1);
    if ( dest )
    {
      memcpy(dest, s, n);
      if ( v29 )
        dest[n] = 47;
      memcpy(&dest[n + v29], "charset.alias", v28 + 1);
    }
    free(0);
    if ( dest )
    {
      fd = open64(dest, 0x20000);
      if ( fd >= 0 )
      {
        stream = fdopen(fd, "r");
        if ( stream )
        {
          v25 = 0;
          v26 = 0;
          while ( 1 )
          {
            c = getc_unlocked(stream);
            if ( c == -1 )
              break;
            if ( c != 10 && c != 32 && c != 9 )
            {
              if ( c == 35 )
              {
                do
                  ca = getc_unlocked(stream);
                while ( ca != -1 && ca != 10 );
                if ( ca == -1 )
                  break;
              }
              else
              {
                ungetc(c, stream);
                if ( fscanf(stream, "%50s %50s", &src, &v39) <= 1 )
                  break;
                v35 = strlen(&src);
                v36 = strlen(&v39);
                v37 = v25;
                if ( v26 )
                {
                  v26 += v36 + v35 + 2;
                  v3 = realloc(v25, v26 + 1);
                }
                else
                {
                  v26 = v35 + v36 + 2;
                  v3 = malloc(v35 + v36 + 3);
                }
                v25 = v3;
                _CF = 0;
                _OF = 0;
                _ZF = v3 == 0;
                _SF = (signed int)v3 < 0;
                if ( !v3 )
                {
                  __asm { pushfw }
                  v22 = a2;
                  if ( a2 >= 10 )
                  {
                    v9 = a2;
                    v10 = _InterlockedExchange(&dword_805B154, a2);
                    v11 = _InterlockedExchange(&dword_805B154, v4);
                    _InterlockedExchange(&dword_805B154, v10);
                    if ( (v11 - 1) * v9 & 1 )
                      abort();
                  }
                  a2 = v22;
                  __asm { popfw }
                  v26 = 0;
                  free(v37);
                  break;
                }
                strcpy((char *)v3 + v26 - v36 - v35 - 2, &src);
                strcpy((char *)v25 + v26 - v36 - 1, &v39);
              }
            }
          }
          sub_80539F0(a2, stream);
          if ( v26 )
          {
            *((_BYTE *)v25 + v26) = 0;
            v23 = v25;
          }
          else
          {
            v23 = &unk_8057213;
          }
        }
        else
        {
          close(fd);
          v23 = &unk_8057213;
        }
      }
      else
      {
        v23 = &unk_8057213;
      }
      free(dest);
    }
    else
    {
      v23 = &unk_8057213;
    }
    dword_805B84B = (int)v23;
  }
  result = v23;
  v17 = __readgsdword(0x14u);
  _CF = 0;
  _OF = 0;
  _ZF = v17 == v40;
  _SF = ((v17 ^ v40) & 0x80000000) != 0;
  if ( v17 != v40 )
  {
    __asm { pushfw }
    v18 = _InterlockedExchange(&dword_805B118, (signed __int32)v23);
    _InterlockedExchange(&dword_805B118, a1);
    _InterlockedExchange(&dword_805B118, v18);
    v19 = sub_80550AC();
    if ( v19 != 445 )
    {
      v21 = _InterlockedExchange(&dword_805B118, v19);
      _InterlockedExchange(&dword_805B118, v20);
      sub_80550B6(_InterlockedExchange(&dword_805B118, v21));
    }
    __asm { popfw }
    result = v23;
  }
  return result;
}
// 8048D10: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 80550B6: using guessed type int __fastcall sub_80550B6(_DWORD);
// 805B118: using guessed type int dword_805B118;
// 805B154: using guessed type int dword_805B154;
// 805B84B: using guessed type int dword_805B84B;

//----- (08054CB5) --------------------------------------------------------
const char *__usercall sub_8054CB5@<eax>(signed __int32 a1@<ebx>)
{
  signed __int32 v1; // edx
  signed __int32 v2; // edx
  signed __int32 v3; // ecx
  char v8; // al
  signed __int32 v9; // ebx
  char v10; // t0
  char v11; // al
  signed __int32 v12; // ebx
  signed __int32 v13; // edx
  signed __int32 v14; // et1
  unsigned __int32 v15; // eax
  signed __int32 v16; // ecx
  char *v17; // ST28_4
  signed __int32 v19; // [esp-Ah] [ebp-32h]
  const char *s1; // [esp+18h] [ebp-10h]
  char *s2; // [esp+1Ch] [ebp-Ch]

  s1 = nl_langinfo(14);
  if ( !s1 )
    s1 = (const char *)&unk_8057213;
  for ( s2 = (char *)sub_80547CB(v1, a1); *s2; s2 = &v17[strlen(v17) + 1] )
  {
    if ( !strcmp(s1, s2) )
      goto LABEL_20;
    _CF = (unsigned __int8)*s2 < 0x2Au;
    _OF = __OFSUB__(*s2, 42);
    _ZF = *s2 == 42;
    _SF = (char)(*s2 - 42) < 0;
    if ( *s2 == 42 )
    {
      __asm { pushfw }
      v19 = a1;
      if ( a1 >= 10 )
      {
        v8 = a1;
        v9 = _InterlockedExchange(&dword_805B184, a1);
        v10 = _InterlockedExchange(&dword_805B184, v3);
        _InterlockedExchange(&dword_805B184, v9);
        if ( (v10 - 1) * v8 & 1 )
          abort();
      }
      a1 = v19;
      __asm { popfw }
      v11 = s2[1];
      _CF = 0;
      _OF = 0;
      _ZF = v11 == 0;
      _SF = v11 < 0;
      if ( !v11 )
      {
LABEL_20:
        s1 = &s2[strlen(s2) + 1];
        break;
      }
    }
    __asm { pushfw }
    v12 = _InterlockedExchange(&dword_805B190, a1);
    v14 = _InterlockedExchange(&dword_805B190, v2);
    v13 = v12;
    a1 = v14;
    _InterlockedExchange(&dword_805B190, v13);
    v15 = sub_804ADD8();
    if ( v15 != 449 )
      sub_804ADE2(
        v15 < 0x1C1,
        v15 == 449,
        (signed int)(v15 - 449) < 0,
        __OFSUB__(v15, 449),
        v15,
        _InterlockedExchange(&dword_805B190, _InterlockedExchange(&dword_805B190, a1)),
        _InterlockedExchange(&dword_805B190, v16));
    __asm { popfw }
    v17 = &s2[strlen(s2) + 1];
  }
  if ( !*s1 )
    s1 = "ASCII";
  return s1;
}
// 805B184: using guessed type int dword_805B184;
// 805B190: using guessed type int dword_805B190;

//----- (08054E13) --------------------------------------------------------
signed int sub_8054E13()
{
  return 912;
}

//----- (08054E1D) --------------------------------------------------------
void __usercall __noreturn sub_8054E1D(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>)
{
  signed __int32 v7; // ebx
  signed __int32 v8; // ecx
  signed __int32 v9; // ebx
  signed __int32 v10; // et0
  unsigned __int32 v11; // eax
  signed __int32 v12; // edx
  signed __int32 v13; // ecx
  bool v14; // cf
  bool v15; // zf
  bool v16; // sf
  char v17; // of
  signed __int32 v18; // eax
  unsigned __int32 v19; // eax
  signed __int32 v20; // edx
  signed __int32 v21; // ecx
  signed __int32 v26; // eax
  char v27; // al
  signed __int32 v28; // ebx
  char v29; // t0
  signed __int32 v30; // [esp-4h] [ebp-4h]

  v30 = a5;
  __asm { pushfw }
  v7 = _InterlockedExchange(&dword_805B124, a7);
  v10 = _InterlockedExchange(&dword_805B124, a6);
  v8 = v7;
  v9 = v10;
  _InterlockedExchange(&dword_805B124, v8);
  v11 = sub_805194D();
  v14 = v11 < 0x2C;
  v17 = __OFSUB__(v11, 44);
  v15 = v11 == 44;
  v16 = (signed int)(v11 - 44) < 0;
  if ( v11 != 44 )
  {
    v18 = _InterlockedExchange(&dword_805B124, v11);
    _InterlockedExchange(&dword_805B124, v13);
    _InterlockedExchange(&dword_805B124, v18);
    sub_8051957(v14, v15, v16, v17, v12, v9);
  }
  __asm
  {
    popfw
    pushfw
  }
  v19 = sub_804B522(
          _CF,
          _ZF,
          _SF,
          _OF,
          _InterlockedExchange(&dword_805B154, v13),
          v12,
          _InterlockedExchange(&dword_805B154, _InterlockedExchange(&dword_805B154, v30)),
          v9);
  _CF = v19 < 0xFFFFFC42;
  _OF = __OFSUB__(v19, -958);
  _ZF = v19 == -958;
  _SF = (signed int)(v19 + 958) < 0;
  if ( v19 != -958 )
  {
    v26 = _InterlockedExchange(&dword_805B154, v19);
    _InterlockedExchange(&dword_805B154, v20);
    _InterlockedExchange(&dword_805B154, v26);
    sub_804B619(_CF, _ZF, _SF, _OF, v21, v9);
  }
  __asm { pushfw }
  if ( v9 >= 10 )
  {
    v27 = v9;
    v28 = _InterlockedExchange(&dword_805B124, v9);
    v29 = _InterlockedExchange(&dword_805B124, v21);
    _InterlockedExchange(&dword_805B124, v28);
    if ( (v29 - 1) * v27 & 1 )
      abort();
  }
  __asm
  {
    popfw
    popfw
  }
  __halt();
  JUMPOUT(loc_8054ECC);
}
// 805B124: using guessed type int dword_805B124;
// 805B154: using guessed type int dword_805B154;

//----- (080550AC) --------------------------------------------------------
signed int sub_80550AC()
{
  return 445;
}

//----- (080550DC) --------------------------------------------------------
signed __int32 __usercall sub_80550DC@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, signed __int32 a3)
{
  signed __int32 v7; // eax
  signed __int32 v8; // eax
  int v9; // edx
  signed __int32 v10; // ecx
  signed __int32 v11; // ebx
  signed __int32 v13; // [esp-4h] [ebp-4h]

  _CF = (unsigned int)(a3 - 65) < 0x19;
  _OF = __OFSUB__(a3 - 65, 25);
  _ZF = a3 == 90;
  _SF = a3 - 90 < 0;
  if ( (unsigned int)(a3 - 65) > 0x19 )
  {
    v7 = a3;
  }
  else
  {
    _CF = __CFADD__(a3, 32);
    _OF = __OFADD__(32, a3);
    _ZF = a3 == -32;
    _SF = a3 + 32 < 0;
    v7 = a3 + 32;
  }
  v13 = v7;
  __asm { pushfw }
  v8 = _InterlockedExchange(&dword_805B148, v7);
  _InterlockedExchange(&dword_805B148, a1);
  _InterlockedExchange(&dword_805B148, v8);
  if ( sub_80537D9() != 862 )
  {
    v11 = _InterlockedExchange(&dword_805B148, a2);
    _InterlockedExchange(&dword_805B148, v10);
    sub_80537E3(_InterlockedExchange(&dword_805B148, v11), v9);
  }
  __asm { popfw }
  return v13;
}
// 80537E3: using guessed type int __fastcall sub_80537E3(_DWORD, _DWORD);
// 805B148: using guessed type int dword_805B148;

//----- (08055239) --------------------------------------------------------
int __usercall sub_8055239@<eax>(signed __int32 a1@<ebx>, __int64 a2, unsigned int a3, unsigned __int32 a4)
{
  signed __int32 v4; // ecx
  unsigned __int32 v5; // eax
  signed __int32 v6; // edx
  signed __int32 v7; // ecx
  signed __int32 v8; // ebx
  signed __int32 v9; // edx
  signed __int32 v10; // ecx
  signed __int32 v11; // ebx
  char v12; // al
  signed __int32 v13; // et2
  int result; // eax
  int v15; // ebp
  int v16; // ebp
  int v25; // edi
  char v30; // al
  signed __int32 v31; // ebx
  char v32; // tt
  char v33; // al
  signed __int32 v34; // et0
  unsigned __int64 v35; // rax
  unsigned int v36; // edi
  unsigned __int64 v37; // rax
  unsigned int v38; // ecx
  signed __int32 v39; // edx
  unsigned __int32 v40; // eax
  bool v41; // cf
  bool v42; // zf
  bool v43; // sf
  char v44; // of
  signed __int32 v45; // eax
  signed __int32 v46; // [esp-14h] [ebp-34h]
  int v47; // [esp+4h] [ebp-1Ch]
  __int64 v48; // [esp+8h] [ebp-18h]
  unsigned int v49; // [esp+Ch] [ebp-14h]

  v4 = a2;
  v5 = a4;
  LODWORD(v48) = a2;
  v6 = a4;
  if ( a4 )
  {
    if ( a4 > HIDWORD(a2) )
    {
      result = a2;
    }
    else
    {
      _BitScanReverse((unsigned int *)&v15, a4);
      v16 = v15 ^ 0x1F;
      if ( v16 )
      {
        v47 = (a4 << v16) | (a3 >> (32 - v16));
        HIDWORD(v35) = HIDWORD(a2) >> (32 - v16);
        LODWORD(v35) = (HIDWORD(a2) << v16) | ((unsigned int)a2 >> (32 - v16));
        v49 = (_DWORD)a2 << v16;
        v36 = v35 % (unsigned int)v47;
        v37 = (a3 << v16) * (unsigned __int64)(unsigned int)(v35 / (unsigned int)v47);
        v38 = v37;
        if ( v36 < HIDWORD(v37) || v49 < (unsigned int)v37 && v36 == HIDWORD(v37) )
        {
          HIDWORD(v37) = (v37 - __PAIR__(v47, a3 << v16)) >> 32;
          v38 = v37 - (a3 << v16);
        }
        result = ((__PAIR__(v36, v49) - __PAIR__(HIDWORD(v37), v38)) >> 32 << (32 - (unsigned __int8)v16)) | ((v49 - v38) >> v16);
      }
      else
      {
        _CF = a3 < (unsigned int)a2;
        _OF = __OFSUB__(a3, (_DWORD)a2);
        _ZF = a3 == (_DWORD)a2;
        _SF = (signed int)(a3 - a2) < 0;
        if ( a3 <= (unsigned int)a2 )
          goto LABEL_31;
        __asm { pushfw }
        v39 = _InterlockedExchange(&dword_805B154, a1);
        a1 = _InterlockedExchange(&dword_805B154, a4);
        v40 = sub_804B522(
                a3 < (unsigned int)a2,
                a3 == (_DWORD)a2,
                (signed int)(a3 - a2) < 0,
                __OFSUB__(a3, (_DWORD)a2),
                a4,
                _InterlockedExchange(&dword_805B154, v39),
                a2,
                a1);
        v41 = v40 < 0xFFFFFC42;
        v44 = __OFSUB__(v40, -958);
        v42 = v40 == -958;
        v43 = (signed int)(v40 + 958) < 0;
        if ( v40 != -958 )
        {
          v45 = _InterlockedExchange(&dword_805B154, v40);
          _InterlockedExchange(&dword_805B154, v6);
          _InterlockedExchange(&dword_805B154, v45);
          sub_804B619(v41, v42, v43, v44, v4, a1);
        }
        __asm { popfw }
        v5 = a4;
        _CF = a4 < HIDWORD(a2);
        _OF = __OFSUB__(a4, HIDWORD(a2));
        _ZF = a4 == HIDWORD(a2);
        _SF = (signed int)(a4 - HIDWORD(a2)) < 0;
        if ( a4 < HIDWORD(a2) )
        {
LABEL_31:
          _CF = __PAIR__(HIDWORD(a2), v4) < __PAIR__(v5, a3);
          _OF = __OFSUB__(__PAIR__(HIDWORD(a2), v4), __PAIR__(v5, a3));
          v25 = (__PAIR__(HIDWORD(a2), v4) - __PAIR__(v5, a3)) >> 32;
          v4 -= a3;
          _ZF = v25 == 0;
          _SF = v25 < 0;
          LODWORD(v48) = v4;
        }
        __asm { pushfw }
        _CF = (unsigned int)a1 < 0xA;
        _OF = __OFSUB__(a1, 10);
        _ZF = a1 == 10;
        _SF = a1 - 10 < 0;
        if ( a1 >= 10 )
        {
          __asm { pushfw }
          v46 = a1;
          if ( a1 >= 10 )
          {
            v30 = a1;
            v31 = _InterlockedExchange(&dword_805B10C, a1);
            v32 = _InterlockedExchange(&dword_805B10C, v6);
            _InterlockedExchange(&dword_805B10C, v31);
            if ( (v32 - 1) * v30 & 1 )
              abort();
          }
          __asm { popfw }
          v34 = _InterlockedExchange(&dword_805B178, v46);
          v33 = _InterlockedExchange(&dword_805B178, v4);
          _InterlockedExchange(&dword_805B178, v34);
          if ( ((_BYTE)v46 - 1) * v33 & 1 )
            abort();
        }
        __asm { popfw }
        result = v48;
      }
    }
  }
  else
  {
    __asm { pushfw }
    v7 = _InterlockedExchange(&dword_805B148, a1);
    v8 = _InterlockedExchange(&dword_805B148, a2);
    _InterlockedExchange(&dword_805B148, v7);
    if ( sub_80537D9() != 862 )
    {
      v11 = _InterlockedExchange(&dword_805B148, v8);
      _InterlockedExchange(&dword_805B148, v10);
      sub_80537E3(_InterlockedExchange(&dword_805B148, v11), v9);
    }
    __asm
    {
      popfw
      pushfw
    }
    if ( v8 >= 10 )
    {
      v13 = _InterlockedExchange(&dword_805B16C, v8);
      v12 = _InterlockedExchange(&dword_805B16C, v9);
      v9 = _InterlockedExchange(&dword_805B16C, v13);
      if ( ((_BYTE)v8 - 1) * v12 & 1 )
        abort();
    }
    __asm { popfw }
    result = v9;
  }
  return result;
}
// 80537E3: using guessed type int __fastcall sub_80537E3(_DWORD, _DWORD);
// 805B10C: using guessed type int dword_805B10C;
// 805B148: using guessed type int dword_805B148;
// 805B154: using guessed type int dword_805B154;
// 805B16C: using guessed type int dword_805B16C;
// 805B178: using guessed type int dword_805B178;

//----- (0805555D) --------------------------------------------------------
int __usercall sub_805555D@<eax>(char a1@<cf>, char a2@<zf>, char a3@<sf>, char a4@<of>, int a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, int a8)
{
  sub_804B699(a1, a2, a3, a4, a5, a6, a7);
  return __cxa_atexit(a8, 0, dword_805B1BC);
}
// 8048E80: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 805B1BC: using guessed type int dword_805B1BC;

//----- (08055C40) --------------------------------------------------------
int (**sub_8055C40())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_805AECC;
  v1 = &off_805AED0 - off_805AECC;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_805AECC[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 805AECC: using guessed type int (*off_805AECC[2])();
// 805AED0: using guessed type int (*off_805AED0)();

//----- (08055CA4) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 1 decompilation failure(s) on 143 function(s)"
