/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8048CF0();
// int strcmp(const char *s1, const char *s2);
// int __cdecl open64(_DWORD, _DWORD); weak
// int __cdecl getline(_DWORD, _DWORD, _DWORD); weak
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void _exit(int status);
// void free(void *ptr);
// void *memcpy(void *dest, const void *src, size_t n);
// int mbsinit(const mbstate_t *ps);
// int tolower(int c);
// int fclose(FILE *stream);
// int getc_unlocked(FILE *stream);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// char *textdomain(const char *domainname);
// int iswprint(wint_t wc);
// int __stdcall fopen64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int ferror_unlocked(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// size_t __ctype_get_mb_cur_max(void);
// char *strcpy(char *dest, const char *src);
// size_t __fpending(FILE *fp);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// void error(int status, int errnum, const char *format, ...);
// size_t fread_unlocked(void *ptr, size_t size, size_t n, FILE *stream);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// char *strchr(const char *s, int c);
// int fscanf(FILE *stream, const char *format, ...);
// size_t strlen(const char *s);
// int fprintf(FILE *stream, const char *format, ...);
// int fcntl(int fd, int cmd, ...);
// int setvbuf(FILE *stream, char *buf, int modes, size_t n);
// void *memset(void *s, int c, size_t n);
// int ungetc(int c, FILE *stream);
// int *__errno_location(void);
// int fileno(FILE *stream);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// char *strrchr(const char *s, int c);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// char *bindtextdomain(const char *domainname, const char *dirname);
// int __stdcall posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// int feof_unlocked(FILE *stream);
// void abort(void);
// char *ngettext(const char *msgid1, const char *msgid2, unsigned int n);
// int close(int fd);
// const unsigned __int16 **__ctype_b_loc(void);
// int putchar_unlocked(int c);
// int _gmon_start__(void); weak
void sub_8049123();
void sub_8049140();
int sub_8049150();
int sub_80491C0();
int sub_80491E0();
void sub_804927D();
void sub_8049298();
int sub_80492A8();
void sub_804938A();
void sub_80493E2();
// int __usercall sub_80493F2@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>);
// void __usercall __spoils<edx,ecx> sub_8049513(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>);
void sub_80495DD();
int sub_80495ED();
signed int sub_8049617();
int __fastcall sub_8049621(_DWORD, _DWORD); // weak
void sub_80496DA();
void sub_80496F5();
int sub_8049705();
signed int sub_804972F();
int __fastcall sub_8049739(_DWORD, _DWORD); // weak
void sub_80497F2();
void sub_804980D();
// int __usercall sub_804981D@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>);
void sub_80499DE();
// int __usercall sub_8049A37@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>);
// signed int __usercall sub_8049AB1@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>);
void sub_8049CB7();
void sub_8049D07();
int sub_8049D54();
void sub_8049E6B();
void sub_8049F3C();
signed int sub_8049FBD();
// void __usercall __spoils<edx,ecx> sub_804A147(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>);
// void __usercall __spoils<edx,ecx> sub_804A1DC(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>);
int sub_804A2D0();
void sub_804A46A();
void sub_804A4B9();
// int __usercall sub_804A547@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>);
signed int sub_804A5EF();
// void __usercall __noreturn sub_804A5F9(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>);
void sub_804A767();
void sub_804A85C();
int sub_804A919();
void sub_804AAA5();
void sub_804AB33();
// int __usercall sub_804ABBF@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>);
void sub_804AD16();
void sub_804AE16();
// int __usercall sub_804AF00@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>);
void sub_804B177();
void sub_804B1CF();
// signed int __usercall sub_804B1D3@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>);
// void __usercall __noreturn sub_804B283(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>);
// int __usercall sub_804B3E8@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>);
// void __usercall __spoils<edx,ecx> sub_804B571(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>);
signed int sub_804B6EB();
// void __usercall __noreturn sub_804B6F5(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>);
void sub_804B76D();
// signed int __usercall sub_804B771@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>);
// void __usercall __noreturn sub_804B82B(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>);
int sub_804B962();
void sub_804BB5B();
void sub_804BCAB();
int sub_804BE18();
void sub_804BFD5();
void sub_804C061();
// signed int __usercall sub_804C065@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>);
// void __usercall __noreturn sub_804C18B(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>);
// int __usercall sub_804C27F@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>);
void sub_804C413();
// void __usercall __spoils<edx,ecx> sub_804C4A0(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>);
int sub_804C643();
signed int sub_804C738();
// void __usercall __noreturn sub_804C742(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>);
// int __usercall sub_804C908@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>, signed __int64 a3);
// unsigned int __usercall sub_804CA2C@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, int a9, unsigned int a10);
int sub_804CBBA();
// int __usercall sub_804CCCC@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>, char *s1);
int __cdecl sub_804CF3B(int a1);
// void __usercall __noreturn sub_804CF43(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, int a9);
// _BYTE *__usercall sub_804D2B0@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, _BYTE *a4, unsigned int a5);
// bool __usercall sub_804D497@<al>(signed __int32 a1@<ebx>, _BYTE *a2);
// bool __usercall sub_804D5FA@<al>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, _BYTE *a8, int a9, _BYTE **a10, _DWORD *a11, char a12);
// char __usercall sub_804D7B5@<al>(signed __int32 a1@<ebx>, signed __int32 a2, int a3, _BYTE **a4, _DWORD *a5, _DWORD *a6);
// signed __int32 __usercall sub_804DB65@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, char *a4, char a5);
// int __usercall sub_804DCE9@<eax>(signed __int32 a1@<ebx>, char *s1, int a3, int a4, int a5);
// int __usercall sub_804DFA9@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, void *a3@<ebx>, const char *a4);
// _BOOL4 __usercall main@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, int argc, char **a5);
signed int sub_804F071();
int __fastcall sub_804F07B(_DWORD, _DWORD); // weak
// signed __int32 __usercall sub_804F07C@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>);
_DWORD *__cdecl sub_804F19B(_DWORD *a1);
// _DWORD *__usercall sub_804F1E7@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, _DWORD *a9, int a10);
// _DWORD *__usercall sub_804F4D9@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, int a9@<ebp>, int *a10, _DWORD *a11);
// _DWORD *__usercall sub_804F667@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, int *a3, _DWORD *a4);
// int __usercall sub_804F794@<eax>(signed __int32 a1@<ebx>, FILE *stream, int a3);
// int *__usercall sub_804FA6F@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>, void *src, size_t a4, int a5);
// int *__usercall sub_804FD7C@<eax>(int a1@<ecx>, signed __int32 a2@<ebx>, int *a3, unsigned int a4, int *a5);
// int __usercall sub_8050AEB@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>, int a8@<ebp>, int a9, int a10, int a11, int a12, int a13, int a14);
// int __usercall sub_8050BA4@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, int a8@<ebp>, FILE *stream, signed __int32 a10);
int __cdecl sub_8050E96(_DWORD, _DWORD); // weak
// char *__usercall sub_8051013@<eax>(signed __int32 a1@<ebx>, char *s);
int __cdecl sub_80511DA(int *a1, unsigned __int8 a2, char a3);
// int *__usercall sub_805136F@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, int *a9, int a10, int a11);
// unsigned int *__userpurge sub_805158D@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>, unsigned int *a8, unsigned int a9);
// char *__usercall sub_80516FF@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, const char *msgid, unsigned int a10);
// unsigned int __usercall sub_80518CE@<eax>(signed __int32 a1@<ebx>, signed __int32 a2, unsigned int a3, signed __int32 a4, size_t a5, unsigned int a6, int a7, int a8, char *a9, char *a10);
void *__cdecl sub_80525DF(signed __int32 a1, size_t a2, _DWORD *a3, int *a4);
signed int sub_80527A0();
// void __usercall __noreturn sub_80527AA(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>);
// void *__usercall sub_80528BF@<eax>(signed __int32 a1@<ebx>, signed int a2, signed __int32 a3, size_t a4, int a5);
// signed __int32 __usercall sub_8052BAC@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>, signed int a7, signed __int32 a8);
// void *__usercall sub_8052DB8@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>, signed int a8, signed __int32 a9, size_t a10);
// void *__usercall sub_8052FEE@<eax>(signed __int32 a1@<ebx>, signed int a2, unsigned __int32 a3, signed __int32 a4);
// void *__usercall sub_805302C@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>, int a8@<ebp>, signed int a9, unsigned __int32 a10, signed __int32 a11, size_t a12);
// void *__usercall sub_8053215@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, int a8@<ebp>, signed __int32 a9, size_t a10, unsigned __int8 a11);
// void *__usercall sub_8053327@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, int a3, unsigned __int8 a4);
// void *__usercall sub_805349E@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, int a3);
// void *__usercall sub_80535C8@<eax>(signed __int32 a1@<ebx>, signed int a2, unsigned __int32 a3, signed __int32 a4);
// void *__usercall sub_8053778@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, int a9@<ebp>, int a10, int a11, int a12, signed __int32 a13);
// void *__usercall sub_80538B9@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, int a9@<ebp>, signed int a10, int a11, int a12, signed __int32 a13, size_t a14);
// void *__usercall sub_8053BA4@<eax>(signed __int32 a1@<ebx>, signed int a2, signed __int32 a3, size_t a4);
// void *__usercall sub_8053D14@<eax>(signed __int32 a1@<ebx>, signed int a2, signed __int32 a3);
// int __usercall sub_8053DCE@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, int a9@<ebp>, int a10);
// int __usercall sub_8053E9E@<eax>(signed __int32 a1@<ebx>, FILE *stream, int a3, int a4, int a5, int a6, int a7);
// int __usercall sub_80545A2@<eax>(signed __int32 a1@<eax>, signed __int32 a2@<edx>, signed __int32 a3@<ebx>, FILE *stream, int a5, int a6, int a7, int a8);
// int __usercall sub_8054682@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>, FILE *stream, int a4, int a5, int a6, ...);
// signed int __usercall sub_8054904@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>);
// void __usercall __noreturn sub_8054A34(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>);
// void *__usercall sub_8054A74@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, void *a8, signed __int32 *a9, unsigned int a10);
// void *__usercall sub_8054C95@<eax>(signed __int32 a1@<ebx>, size_t size);
// void *__usercall sub_8054D68@<eax>(signed __int32 a1@<ebx>, size_t size);
// void *__usercall sub_8054E03@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, void *ptr, signed int size);
// void *__usercall sub_8054FF9@<eax>(signed __int32 a1@<ebx>, void *src, size_t n);
signed int sub_80550FF();
// void __usercall __noreturn sub_8055109(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>);
// void __usercall __noreturn sub_805517D(signed __int32 a1@<ebx>);
// int __usercall sub_8055264@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, FILE *stream);
signed int sub_80554DE();
// void __usercall __noreturn sub_80554E8(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>);
// int __usercall sub_80555D5@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, int a9@<ebp>, int fd, int cmd, int a12);
// int __usercall sub_805599E@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, FILE *stream);
// int __usercall sub_8055A4A@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>, FILE *fp);
// int __usercall sub_8055BB2@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, FILE *stream, int a4, int a5, int a6);
signed int sub_8055DB4();
int __fastcall sub_8055DBE(_DWORD, _DWORD); // weak
// size_t __usercall sub_8055DBF@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>, int a8@<ebp>, wchar_t *pwc, const char *s, signed int n, mbstate_t *p);
// int __usercall sub_8055F4B@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, unsigned __int8 *a3, unsigned __int8 *a4);
// signed __int32 __usercall sub_8055FB0@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>, FILE *fp);
// int __usercall sub_80561A0@<eax>(signed __int32 a1@<ebx>, int category);
// void *__usercall sub_805632E@<eax>(signed __int32 a1@<ebx>);
// const char *__usercall sub_805690D@<eax>(signed __int32 a1@<ebx>);
signed int sub_8056BAD();
// void __usercall __noreturn sub_8056BB7(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>);
// signed __int32 __usercall sub_8056DCA@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, signed __int32 a4);
// int __usercall sub_8057062@<eax>(signed __int32 a1@<ebx>, unsigned __int64 a2, unsigned int a3, unsigned __int32 a4);
// signed int __usercall sub_80571DD@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>);
// void __usercall __noreturn sub_8057259(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>);
// int __usercall sub_8057493@<eax>(char a1@<cf>, char a2@<zf>, char a3@<sf>, char a4@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>, int a7);
int (**sub_8057BE0())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

char byte_804A639[2] = { '\x8D', '6' }; // weak
_UNKNOWN loc_804B2F6; // weak
_UNKNOWN loc_804B72B; // weak
_UNKNOWN loc_804B919; // weak
char byte_804C273[2] = { 'f', '\x90' }; // weak
_UNKNOWN loc_804C7F7; // weak
_UNKNOWN loc_80527E8; // weak
_UNKNOWN loc_8056CD2; // weak
_UNKNOWN loc_805728E; // weak
char locale = '\0'; // idb
struct option longopts = { "binary", 0, NULL, 98 }; // idb
char byte_80588E1[16] =
{
  '0',
  '1',
  '2',
  '3',
  '4',
  '5',
  '6',
  '7',
  '8',
  '9',
  'a',
  'b',
  'c',
  'd',
  'e',
  'f'
}; // idb
_UNKNOWN unk_8058928; // weak
_UNKNOWN unk_8058A96; // weak
_UNKNOWN unk_8058A9A; // weak
_UNKNOWN unk_8058AA6; // weak
_UNKNOWN unk_8058AAA; // weak
_UNKNOWN unk_8058AAD; // weak
_UNKNOWN unk_8058AAF; // weak
_UNKNOWN unk_8058AB1; // weak
char aLicenseGplv3Gn[167] = "\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY"; // idb
char aWrit[4] = "Writ"; // idb
char aWrittenBySAnd[17] = "Written by %s and"; // idb
char aWrittenBySSSSS_3[43] = "Written by %s, %s, %s,\n%s, %s, %s, %s,\nand "; // idb
_UNKNOWN unk_80591CB; // weak
_UNKNOWN unk_805A21C; // weak
_UNKNOWN unk_805A21F; // weak
_UNKNOWN unk_805B228; // weak
_UNKNOWN unk_805B22B; // weak
int (*off_805CEC0[2])() = { &sub_80491E0, &sub_80491C0 }; // weak
int (*off_805CEC4)() = &sub_80491C0; // weak
int (*dword_805D008)(void) = NULL; // weak
int dword_805D10C = 0; // weak
int dword_805D118 = 0; // weak
int dword_805D124 = 0; // weak
int dword_805D130 = 0; // weak
int dword_805D13C = 0; // weak
int dword_805D148 = 0; // weak
int dword_805D154 = 0; // weak
int dword_805D160 = 0; // weak
int dword_805D16C = 0; // weak
int dword_805D178 = 0; // weak
int dword_805D184 = 0; // weak
int dword_805D190 = 0; // weak
int dword_805D19C = 0; // weak
int dword_805D1A8 = 0; // weak
int dword_805D1B4 = 0; // weak
int dword_805D1C0 = 0; // weak
int dword_805D1E0 = 0; // weak
int dword_805D1E4 = 4294967295; // weak
int off_805D1E8 = 134580465; // idb
int status = 1; // idb
int dword_805D1FC = 1; // weak
int dword_805D200 = 256; // weak
void *off_805D204 = &unk_805D842; // weak
int *off_805D208 = &dword_805D200; // weak
_UNKNOWN unk_805D21C; // weak
_UNKNOWN unk_805D240; // weak
_UNKNOWN unk_805D243; // weak
_UNKNOWN unk_805D24C; // weak
_UNKNOWN unk_805D24F; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int program_invocation_name; // weak
int optind; // weak
int stdin; // weak
FILE *stdout; // idb
char byte_805D2A8; // weak
_UNKNOWN unk_805D2AC; // weak
_UNKNOWN unk_805D4F4; // weak
_UNKNOWN unk_805D73C; // weak
_UNKNOWN unk_805D74C; // weak
char byte_805D7CE; // weak
int dword_805D7D2; // weak
int dword_805D7D6; // weak
char byte_805D7DA; // weak
char byte_805D7DB; // weak
char byte_805D7DC; // weak
char byte_805D7DD; // weak
char byte_805D7DE; // weak
int dword_805D7E2; // weak
char byte_805D7E6; // weak
int dword_805D7EA; // weak
int dword_805D802; // weak
int dword_805D806; // weak
int dword_805D80A; // weak
int dword_805D80E; // weak
int dword_805D812; // weak
int dword_805D816; // weak
int dword_805D81A; // weak
int dword_805D81E; // weak
int dword_805D822; // weak
int dword_805D826; // weak
int dword_805D82A; // weak
int dword_805D82E; // weak
_UNKNOWN unk_805D842; // weak
int dword_805D942; // weak
int dword_805D946; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (08048CCC) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 80490E0: using guessed type int _gmon_start__(void);

//----- (08048CF0) --------------------------------------------------------
int sub_8048CF0()
{
  return dword_805D008();
}
// 805D008: using guessed type int (*dword_805D008)(void);

//----- (080490F0) --------------------------------------------------------
#error "80490F3: positive sp value has been found (funcsize=2)"

//----- (08049123) --------------------------------------------------------
void sub_8049123()
{
  ;
}

//----- (08049140) --------------------------------------------------------
void sub_8049140()
{
  ;
}

//----- (08049150) --------------------------------------------------------
int sub_8049150()
{
  int result; // eax

  result = &unk_805D24F - &unk_805D24C;
  if ( (unsigned int)(&unk_805D24F - &unk_805D24C) > 6 )
    result = 0;
  return result;
}
// 8049150: could not find valid save-restore pair for ebp

//----- (080491C0) --------------------------------------------------------
int sub_80491C0()
{
  int result; // eax

  if ( !byte_805D2A8 )
  {
    result = sub_8049150();
    byte_805D2A8 = 1;
  }
  return result;
}
// 80491C0: could not find valid save-restore pair for ebp
// 805D2A8: using guessed type char byte_805D2A8;

//----- (080491E0) --------------------------------------------------------
int sub_80491E0()
{
  return 0;
}
// 80491E0: could not find valid save-restore pair for ebp

//----- (0804927D) --------------------------------------------------------
void sub_804927D()
{
  ;
}

//----- (08049298) --------------------------------------------------------
void sub_8049298()
{
  ;
}

//----- (080492A8) --------------------------------------------------------
int sub_80492A8()
{
  int result; // eax

  result = &unk_805D2AC - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_805D2AC - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 80492A8: could not find valid save-restore pair for ebp
// 805D260: using guessed type int program_invocation_short_name;

//----- (0804938A) --------------------------------------------------------
void sub_804938A()
{
  ;
}

//----- (080493E2) --------------------------------------------------------
void sub_80493E2()
{
  ;
}

//----- (080493F2) --------------------------------------------------------
int __usercall sub_80493F2@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>)
{
  signed __int32 v7; // ebx
  signed __int32 v8; // ecx
  signed __int32 v9; // ebx
  signed __int32 v10; // et0
  unsigned int v11; // eax
  signed __int32 v12; // edx
  signed __int32 v13; // ecx
  signed __int32 v14; // ebx
  signed __int32 v15; // et1
  int result; // eax
  int v17; // [esp+18h] [ebp-4h]

  v17 = a5;
  __asm { pushfw }
  v7 = _InterlockedExchange(&dword_805D118, a7);
  v10 = _InterlockedExchange(&dword_805D118, a6);
  v8 = v7;
  v9 = v10;
  _InterlockedExchange(&dword_805D118, v8);
  v11 = sub_804B6EB();
  if ( v11 != -916 )
  {
    v14 = _InterlockedExchange(&dword_805D118, v9);
    v15 = _InterlockedExchange(&dword_805D118, v13);
    _InterlockedExchange(&dword_805D118, v14);
    sub_804B6F5(v11 < 0xFFFFFC6C, v11 == -916, (signed int)(v11 + 916) < 0, __OFSUB__(v11, -916), v12, v15);
  }
  __asm { popfw }
  result = &unk_805D243 - &unk_805D240;
  if ( (unsigned int)(&unk_805D243 - &unk_805D240) > 6 )
    result = 0;
  return result;
}
// 80493F2: could not find valid save-restore pair for ebp
// 805D118: using guessed type int dword_805D118;

//----- (08049513) --------------------------------------------------------
void __usercall __spoils<edx,ecx> sub_8049513(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>)
{
  char v6; // al
  signed __int32 v7; // et0

  __asm { pushfw }
  if ( a6 >= 10 )
  {
    v7 = _InterlockedExchange(&dword_805D118, a6);
    v6 = _InterlockedExchange(&dword_805D118, a5);
    _InterlockedExchange(&dword_805D118, v7);
    if ( ((_BYTE)a6 - 1) * v6 & 1 )
      abort();
  }
  __asm { popfw }
}
// 8049513: could not find valid save-restore pair for ebx
// 805D118: using guessed type int dword_805D118;

//----- (080495DD) --------------------------------------------------------
void sub_80495DD()
{
  ;
}

//----- (080495ED) --------------------------------------------------------
int sub_80495ED()
{
  int result; // eax

  result = &unk_805B22B - &unk_805B228;
  if ( (unsigned int)(&unk_805B22B - &unk_805B228) > 6 )
    result = 0;
  return result;
}
// 80495ED: could not find valid save-restore pair for ebp

//----- (08049617) --------------------------------------------------------
signed int sub_8049617()
{
  return -795;
}

//----- (080496DA) --------------------------------------------------------
void sub_80496DA()
{
  ;
}

//----- (080496F5) --------------------------------------------------------
void sub_80496F5()
{
  ;
}

//----- (08049705) --------------------------------------------------------
int sub_8049705()
{
  int result; // eax

  result = &unk_805A21F - &unk_805A21C;
  if ( (unsigned int)(&unk_805A21F - &unk_805A21C) > 6 )
    result = 0;
  return result;
}
// 8049705: could not find valid save-restore pair for ebp

//----- (0804972F) --------------------------------------------------------
signed int sub_804972F()
{
  return 949;
}

//----- (080497F2) --------------------------------------------------------
void sub_80497F2()
{
  ;
}

//----- (0804980D) --------------------------------------------------------
void sub_804980D()
{
  ;
}

//----- (0804981D) --------------------------------------------------------
int __usercall sub_804981D@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>)
{
  signed __int32 v6; // eax
  unsigned __int32 v7; // eax
  signed __int32 v8; // edx
  int result; // eax
  int v10; // [esp+18h] [ebp-4h]

  v10 = a5;
  __asm { pushfw }
  v6 = _InterlockedExchange(&dword_805D130, a5);
  _InterlockedExchange(&dword_805D130, a6);
  _InterlockedExchange(&dword_805D130, v6);
  v7 = sub_80527A0();
  if ( v7 != 553 )
    sub_80527AA(
      v7 < 0x229,
      v7 == 553,
      (signed int)(v7 - 553) < 0,
      __OFSUB__(v7, 553),
      _InterlockedExchange(&dword_805D130, v8),
      _InterlockedExchange(&dword_805D130, _InterlockedExchange(&dword_805D130, v7)));
  __asm { popfw }
  result = &unk_805D243 - &unk_805D240;
  if ( (unsigned int)(&unk_805D243 - &unk_805D240) > 6 )
    result = 0;
  return result;
}
// 804981D: could not find valid save-restore pair for ebp
// 805D130: using guessed type int dword_805D130;

//----- (080499DE) --------------------------------------------------------
void sub_80499DE()
{
  ;
}

//----- (08049A37) --------------------------------------------------------
int __usercall sub_8049A37@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>)
{
  char v8; // al
  signed __int32 v9; // ebx
  char v10; // t0
  signed __int32 v11; // ebx
  char v12; // t1
  signed __int32 v14; // [esp-Ah] [ebp-Ah]
  int v15; // [esp-4h] [ebp-4h]

  v15 = a5;
  __asm { pushfw }
  v14 = a8;
  if ( a8 >= 10 )
  {
    v8 = a8;
    v9 = _InterlockedExchange(&dword_805D10C, a8);
    v10 = _InterlockedExchange(&dword_805D10C, a7);
    _InterlockedExchange(&dword_805D10C, v9);
    if ( (v10 - 1) * v8 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( v14 >= 10 )
  {
    v11 = _InterlockedExchange(&dword_805D124, v14);
    v12 = _InterlockedExchange(&dword_805D124, a6);
    _InterlockedExchange(&dword_805D124, v11);
    if ( (v12 - 1) * (_BYTE)v14 & 1 )
      abort();
  }
  __asm { popfw }
  return v15;
}
// 8049A37: could not find valid save-restore pair for ebx
// 805D10C: using guessed type int dword_805D10C;
// 805D124: using guessed type int dword_805D124;

//----- (08049AB1) --------------------------------------------------------
signed int __usercall sub_8049AB1@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>)
{
  signed __int32 v6; // eax
  unsigned __int32 v7; // eax
  signed __int32 v8; // edx
  signed __int32 v9; // ecx
  bool v10; // cf
  bool v11; // zf
  bool v12; // sf
  char v13; // of
  signed __int32 v14; // eax
  signed __int32 v15; // et1
  int v17; // [esp+18h] [ebp-4h]

  v17 = a5;
  __asm { pushfw }
  v6 = _InterlockedExchange(&dword_805D130, a5);
  _InterlockedExchange(&dword_805D130, a6);
  _InterlockedExchange(&dword_805D130, v6);
  v7 = sub_80527A0();
  v10 = v7 < 0x229;
  v13 = __OFSUB__(v7, 553);
  v11 = v7 == 553;
  v12 = (signed int)(v7 - 553) < 0;
  if ( v7 != 553 )
  {
    v15 = _InterlockedExchange(&dword_805D130, v7);
    v14 = _InterlockedExchange(&dword_805D130, v9);
    _InterlockedExchange(&dword_805D130, v15);
    sub_80527AA(v10, v11, v12, v13, v14, v8);
  }
  __asm { popfw }
  return 3;
}
// 8049AB1: could not find valid save-restore pair for ebp
// 805D130: using guessed type int dword_805D130;

//----- (08049CB7) --------------------------------------------------------
void sub_8049CB7()
{
  ;
}

//----- (08049D07) --------------------------------------------------------
void sub_8049D07()
{
  ;
}

//----- (08049D54) --------------------------------------------------------
int sub_8049D54()
{
  int result; // eax

  result = &unk_805D243 - &unk_805D240;
  if ( (unsigned int)(&unk_805D243 - &unk_805D240) > 6 )
    result = 0;
  return result;
}
// 8049D54: could not find valid save-restore pair for ebp

//----- (08049E6B) --------------------------------------------------------
void sub_8049E6B()
{
  ;
}

//----- (08049F3C) --------------------------------------------------------
void sub_8049F3C()
{
  ;
}

//----- (08049FBD) --------------------------------------------------------
signed int sub_8049FBD()
{
  return 4;
}
// 8049FBD: could not find valid save-restore pair for ebp

//----- (0804A147) --------------------------------------------------------
void __usercall __spoils<edx,ecx> sub_804A147(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>)
{
  signed __int32 v6; // eax
  signed __int32 v7; // eax
  int v8; // edx
  signed __int32 v9; // ecx
  signed __int32 v10; // eax

  __asm { pushfw }
  v6 = _InterlockedExchange(&dword_805D13C, a5);
  _InterlockedExchange(&dword_805D13C, a6);
  _InterlockedExchange(&dword_805D13C, v6);
  v7 = sub_8055DB4();
  if ( v7 != -64 )
  {
    v10 = _InterlockedExchange(&dword_805D13C, v7);
    _InterlockedExchange(&dword_805D13C, v9);
    sub_8055DBE(_InterlockedExchange(&dword_805D13C, v10), v8);
  }
  __asm { popfw }
}
// 8055DBE: using guessed type int __fastcall sub_8055DBE(_DWORD, _DWORD);
// 805D13C: using guessed type int dword_805D13C;

//----- (0804A1DC) --------------------------------------------------------
void __usercall __spoils<edx,ecx> sub_804A1DC(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>)
{
  char v6; // al
  signed __int32 v7; // et0

  __asm { pushfw }
  if ( a6 >= 10 )
  {
    v7 = _InterlockedExchange(&dword_805D130, a6);
    v6 = _InterlockedExchange(&dword_805D130, a5);
    _InterlockedExchange(&dword_805D130, v7);
    if ( ((_BYTE)a6 - 1) * v6 & 1 )
      abort();
  }
  __asm { popfw }
}
// 804A1DC: could not find valid save-restore pair for ebx
// 805D130: using guessed type int dword_805D130;

//----- (0804A2D0) --------------------------------------------------------
int sub_804A2D0()
{
  int result; // eax

  result = &unk_805D4F4 - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_805D4F4 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 804A2D0: could not find valid save-restore pair for ebp
// 804F07B: using guessed type int __fastcall sub_804F07B(_DWORD, _DWORD);
// 8055DBE: using guessed type int __fastcall sub_8055DBE(_DWORD, _DWORD);
// 805D13C: using guessed type int dword_805D13C;
// 805D160: using guessed type int dword_805D160;
// 805D260: using guessed type int program_invocation_short_name;

//----- (0804A46A) --------------------------------------------------------
void sub_804A46A()
{
  ;
}

//----- (0804A4B9) --------------------------------------------------------
void sub_804A4B9()
{
  ;
}

//----- (0804A547) --------------------------------------------------------
int __usercall sub_804A547@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>)
{
  int v2; // eax
  signed __int32 v7; // ebx
  signed __int32 v8; // ecx
  signed __int32 v9; // ebx
  signed __int32 v10; // et0
  unsigned __int32 v11; // eax
  signed __int32 v12; // edx
  signed __int32 v13; // ecx
  signed __int32 v14; // ebx
  signed __int32 v15; // edx
  signed __int32 v16; // ebx
  signed __int32 v17; // et2
  unsigned __int32 v18; // eax
  signed __int32 v19; // edx
  signed __int32 v20; // ecx
  bool v21; // cf
  bool v22; // zf
  bool v23; // sf
  char v24; // of
  signed __int32 v25; // eax
  int v27; // [esp+18h] [ebp-4h]

  v2 = &unk_805D243 - &unk_805D240;
  _CF = (unsigned int)(&unk_805D243 - &unk_805D240) < 6;
  _OF = __OFSUB__(&unk_805D243 - &unk_805D240, 6);
  _ZF = &unk_805D243 - &unk_805D240 == 6;
  _SF = &unk_805D243 - &unk_805D240 - 6 < 0;
  if ( (unsigned int)(&unk_805D243 - &unk_805D240) > 6 )
  {
    v2 = 0;
    _CF = 0;
    _OF = 0;
    _ZF = 1;
    _SF = 0;
  }
  v27 = v2;
  __asm { pushfw }
  v7 = _InterlockedExchange(&dword_805D130, a2);
  v10 = _InterlockedExchange(&dword_805D130, a1);
  v8 = v7;
  v9 = v10;
  _InterlockedExchange(&dword_805D130, v8);
  v11 = sub_80527A0();
  if ( v11 != 553 )
    sub_80527AA(
      v11 < 0x229,
      v11 == 553,
      (signed int)(v11 - 553) < 0,
      __OFSUB__(v11, 553),
      _InterlockedExchange(&dword_805D130, v12),
      _InterlockedExchange(&dword_805D130, _InterlockedExchange(&dword_805D130, v11)));
  __asm
  {
    popfw
    pushfw
  }
  v14 = _InterlockedExchange(&dword_805D154, v9);
  v17 = _InterlockedExchange(&dword_805D154, v12);
  v15 = v14;
  v16 = v17;
  v18 = sub_804B1D3(_CF, _ZF, _SF, _OF, v27, _InterlockedExchange(&dword_805D154, v15), v13, v17);
  v21 = v18 < 0xF;
  v24 = __OFSUB__(v18, 15);
  v22 = v18 == 15;
  v23 = (signed int)(v18 - 15) < 0;
  if ( v18 != 15 )
  {
    v25 = _InterlockedExchange(&dword_805D154, v18);
    _InterlockedExchange(&dword_805D154, v19);
    _InterlockedExchange(&dword_805D154, v25);
    sub_804B283(v21, v22, v23, v24, v20, v16);
  }
  __asm { popfw }
  return v27;
}
// 804A547: could not find valid save-restore pair for ebp
// 805D130: using guessed type int dword_805D130;
// 805D154: using guessed type int dword_805D154;

//----- (0804A5EF) --------------------------------------------------------
signed int sub_804A5EF()
{
  return 421;
}

//----- (0804A5F9) --------------------------------------------------------
void __usercall __noreturn sub_804A5F9(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>)
{
  signed __int32 v6; // ebx
  signed __int32 v7; // edx
  signed __int32 v8; // ebx
  signed __int32 v9; // et0
  unsigned int v10; // eax
  signed __int32 v11; // edx
  signed __int32 v12; // ecx
  signed __int32 v13; // ebx
  signed __int32 v14; // et1

  __asm { pushfw }
  v6 = _InterlockedExchange(&dword_805D118, a6);
  v9 = _InterlockedExchange(&dword_805D118, a5);
  v7 = v6;
  v8 = v9;
  _InterlockedExchange(&dword_805D118, v7);
  v10 = sub_804B6EB();
  if ( v10 != -916 )
  {
    v13 = _InterlockedExchange(&dword_805D118, v8);
    v14 = _InterlockedExchange(&dword_805D118, v12);
    _InterlockedExchange(&dword_805D118, v13);
    sub_804B6F5(v10 < 0xFFFFFC6C, v10 == -916, (signed int)(v10 + 916) < 0, __OFSUB__(v10, -916), v11, v14);
  }
  __asm { popfw }
  __halt();
  JUMPOUT(*(_DWORD *)byte_804A639);
}
// 805D118: using guessed type int dword_805D118;

//----- (0804A767) --------------------------------------------------------
void sub_804A767()
{
  ;
}

//----- (0804A85C) --------------------------------------------------------
void sub_804A85C()
{
  ;
}

//----- (0804A919) --------------------------------------------------------
int sub_804A919()
{
  int result; // eax

  result = "ten by %s.\n" - &aWrit[1];
  if ( (unsigned int)("ten by %s.\n" - &aWrit[1]) > 6 )
    result = 0;
  return result;
}
// 804A919: could not find valid save-restore pair for ebp

//----- (0804AAA5) --------------------------------------------------------
void sub_804AAA5()
{
  ;
}

//----- (0804AB33) --------------------------------------------------------
void sub_804AB33()
{
  ;
}

//----- (0804ABBF) --------------------------------------------------------
int __usercall sub_804ABBF@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>)
{
  signed __int32 v7; // eax
  unsigned __int32 v8; // eax
  signed __int32 v9; // edx
  signed __int32 v10; // ecx
  bool v11; // cf
  bool v12; // zf
  bool v13; // sf
  char v14; // of
  signed __int32 v15; // eax
  int result; // eax
  int v17; // [esp+18h] [ebp-4h]

  v17 = a5;
  __asm { pushfw }
  v7 = _InterlockedExchange(&dword_805D118, a5);
  _InterlockedExchange(&dword_805D118, a6);
  _InterlockedExchange(&dword_805D118, v7);
  v8 = sub_804B6EB();
  v11 = v8 < 0xFFFFFC6C;
  v14 = __OFSUB__(v8, -916);
  v12 = v8 == -916;
  v13 = (signed int)(v8 + 916) < 0;
  if ( v8 != -916 )
  {
    v15 = _InterlockedExchange(&dword_805D118, v8);
    _InterlockedExchange(&dword_805D118, v10);
    _InterlockedExchange(&dword_805D118, v15);
    sub_804B6F5(v11, v12, v13, v14, v9, a7);
  }
  __asm { popfw }
  result = &unk_805D243 - &unk_805D240;
  if ( (unsigned int)(&unk_805D243 - &unk_805D240) > 6 )
    result = 0;
  return result;
}
// 804ABBF: could not find valid save-restore pair for ebp
// 805D118: using guessed type int dword_805D118;

//----- (0804AD16) --------------------------------------------------------
void sub_804AD16()
{
  ;
}

//----- (0804AE16) --------------------------------------------------------
void sub_804AE16()
{
  ;
}

//----- (0804AF00) --------------------------------------------------------
int __usercall sub_804AF00@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>)
{
  signed __int32 v7; // eax
  unsigned __int32 v8; // eax
  signed __int32 v9; // edx
  signed __int32 v10; // ecx
  signed __int32 v15; // eax
  signed __int32 v16; // et1
  char v17; // al
  signed __int32 v18; // et2
  int result; // eax
  int v20; // [esp+18h] [ebp-4h]

  v20 = a5;
  __asm { pushfw }
  v7 = _InterlockedExchange(&dword_805D190, a5);
  _InterlockedExchange(&dword_805D190, a6);
  _InterlockedExchange(&dword_805D190, v7);
  v8 = sub_80554DE();
  _CF = v8 < 0x229;
  _OF = __OFSUB__(v8, 553);
  _ZF = v8 == 553;
  _SF = (signed int)(v8 - 553) < 0;
  if ( v8 != 553 )
  {
    v16 = _InterlockedExchange(&dword_805D190, v8);
    v15 = _InterlockedExchange(&dword_805D190, v9);
    _InterlockedExchange(&dword_805D190, v16);
    sub_80554E8(_CF, _ZF, _SF, _OF, v15, v10, a7);
  }
  __asm { pushfw }
  if ( a7 >= 10 )
  {
    v18 = _InterlockedExchange(&dword_805D178, a7);
    v17 = _InterlockedExchange(&dword_805D178, v9);
    _InterlockedExchange(&dword_805D178, v18);
    if ( ((_BYTE)a7 - 1) * v17 & 1 )
      abort();
  }
  __asm
  {
    popfw
    popfw
  }
  result = ", to the extent permitted by law.\n\n" - &aLicenseGplv3Gn[164];
  if ( (unsigned int)(", to the extent permitted by law.\n\n" - &aLicenseGplv3Gn[164]) > 6 )
    result = 0;
  return result;
}
// 804AF00: could not find valid save-restore pair for ebp
// 805D178: using guessed type int dword_805D178;
// 805D190: using guessed type int dword_805D190;

//----- (0804B177) --------------------------------------------------------
void sub_804B177()
{
  ;
}

//----- (0804B1CF) --------------------------------------------------------
void sub_804B1CF()
{
  ;
}

//----- (0804B1D3) --------------------------------------------------------
signed int __usercall sub_804B1D3@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>)
{
  char v8; // al
  signed __int32 v9; // et0
  signed __int32 v10; // eax
  unsigned __int32 v11; // eax
  signed __int32 v12; // edx
  signed __int32 v13; // ecx
  bool v14; // cf
  bool v15; // zf
  bool v16; // sf
  char v17; // of
  signed __int32 v18; // eax
  char v19; // al
  signed __int32 v20; // ebx
  char v21; // tt
  signed __int32 v23; // [esp-4h] [ebp-4h]

  v23 = a5;
  __asm { pushfw }
  if ( a8 >= 10 )
  {
    v9 = _InterlockedExchange(&dword_805D10C, a8);
    v8 = _InterlockedExchange(&dword_805D10C, a7);
    _InterlockedExchange(&dword_805D10C, v9);
    if ( ((_BYTE)a8 - 1) * v8 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  v10 = _InterlockedExchange(&dword_805D118, v23);
  _InterlockedExchange(&dword_805D118, a6);
  _InterlockedExchange(&dword_805D118, v10);
  v11 = sub_804B6EB();
  v14 = v11 < 0xFFFFFC6C;
  v17 = __OFSUB__(v11, -916);
  v15 = v11 == -916;
  v16 = (signed int)(v11 + 916) < 0;
  if ( v11 != -916 )
  {
    v18 = _InterlockedExchange(&dword_805D118, v11);
    _InterlockedExchange(&dword_805D118, v13);
    _InterlockedExchange(&dword_805D118, v18);
    sub_804B6F5(v14, v15, v16, v17, v12, a8);
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( a8 >= 10 )
  {
    v19 = a8;
    v20 = _InterlockedExchange(&dword_805D130, a8);
    v21 = _InterlockedExchange(&dword_805D130, v13);
    _InterlockedExchange(&dword_805D130, v20);
    if ( (v21 - 1) * v19 & 1 )
      abort();
  }
  __asm { popfw }
  return 15;
}
// 804B1D3: could not find valid save-restore pair for ebx
// 805D10C: using guessed type int dword_805D10C;
// 805D118: using guessed type int dword_805D118;
// 805D130: using guessed type int dword_805D130;

//----- (0804B283) --------------------------------------------------------
void __usercall __noreturn sub_804B283(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>)
{
  signed __int32 v6; // ebx
  signed __int32 v7; // ecx
  signed __int32 v8; // ebx
  signed __int32 v9; // et0
  unsigned __int32 v10; // eax
  signed __int32 v11; // ecx
  char v16; // al
  signed __int32 v17; // et2

  __asm { pushfw }
  v6 = _InterlockedExchange(&dword_805D148, a6);
  v9 = _InterlockedExchange(&dword_805D148, a5);
  v7 = v6;
  v8 = v9;
  _InterlockedExchange(&dword_805D148, v7);
  v10 = sub_80550FF();
  _CF = v10 < 0xB4;
  _OF = __OFSUB__(v10, 180);
  _ZF = v10 == 180;
  _SF = (signed int)(v10 - 180) < 0;
  if ( v10 != 180 )
    sub_8055109(
      v10 < 0xB4,
      v10 == 180,
      (signed int)(v10 - 180) < 0,
      __OFSUB__(v10, 180),
      _InterlockedExchange(&dword_805D148, v11),
      _InterlockedExchange(&dword_805D148, _InterlockedExchange(&dword_805D148, v10)),
      v8);
  __asm { pushfw }
  if ( v8 >= 10 )
  {
    v17 = _InterlockedExchange(&dword_805D130, v8);
    v16 = _InterlockedExchange(&dword_805D130, v11);
    _InterlockedExchange(&dword_805D130, v17);
    if ( ((_BYTE)v8 - 1) * v16 & 1 )
      abort();
  }
  __asm
  {
    popfw
    popfw
  }
  __halt();
  JUMPOUT(loc_804B2F6);
}
// 805D130: using guessed type int dword_805D130;
// 805D148: using guessed type int dword_805D148;

//----- (0804B3E8) --------------------------------------------------------
int __usercall sub_804B3E8@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>)
{
  int v2; // eax
  char v7; // al
  signed __int32 v8; // ebx
  char v9; // t0
  int v11; // [esp+18h] [ebp-4h]

  v2 = &unk_805D243 - &unk_805D240;
  _CF = (unsigned int)(&unk_805D243 - &unk_805D240) < 6;
  _OF = __OFSUB__(&unk_805D243 - &unk_805D240, 6);
  _ZF = &unk_805D243 - &unk_805D240 == 6;
  _SF = &unk_805D243 - &unk_805D240 - 6 < 0;
  if ( (unsigned int)(&unk_805D243 - &unk_805D240) > 6 )
  {
    v2 = 0;
    _CF = 0;
    _OF = 0;
    _ZF = 1;
    _SF = 0;
  }
  v11 = v2;
  __asm { pushfw }
  if ( a2 >= 10 )
  {
    v7 = a2;
    v8 = _InterlockedExchange(&dword_805D178, a2);
    v9 = _InterlockedExchange(&dword_805D178, a1);
    _InterlockedExchange(&dword_805D178, v8);
    if ( (v9 - 1) * v7 & 1 )
      abort();
  }
  __asm { popfw }
  return v11;
}
// 804B3E8: could not find valid save-restore pair for ebp
// 805D178: using guessed type int dword_805D178;

//----- (0804B571) --------------------------------------------------------
void __usercall __spoils<edx,ecx> sub_804B571(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>)
{
  signed __int32 v12; // ebx
  signed __int32 v13; // ecx
  signed __int32 v14; // ebx
  signed __int32 v15; // et0
  unsigned __int32 v16; // eax
  signed __int32 v17; // edx
  signed __int32 v18; // ecx
  signed __int32 v23; // eax
  signed __int32 v24; // ebx
  signed __int32 v25; // ecx
  signed __int32 v26; // ebx
  signed __int32 v27; // et2
  unsigned __int32 v28; // eax
  signed __int32 v29; // edx
  signed __int32 v30; // ecx
  signed __int32 v35; // eax
  unsigned __int32 v36; // eax
  int v37; // edx
  signed __int32 v38; // ecx
  signed __int32 v39; // ebx
  char v40; // al
  signed __int32 v41; // et2
  signed __int32 v42; // ebx
  signed __int32 v43; // edx
  signed __int32 v44; // ebx
  signed __int32 v45; // ett
  int v46; // edx
  signed __int32 v47; // ecx
  signed __int32 v48; // ebx
  signed __int32 v49; // eax
  unsigned __int32 v50; // eax
  signed __int32 v51; // edx
  bool v52; // cf
  bool v53; // zf
  bool v54; // sf
  char v55; // of
  signed __int32 v56; // eax

  __asm { pushfw }
  _CF = (unsigned int)a8 < 0xA;
  _OF = __OFSUB__(a8, 10);
  _ZF = a8 == 10;
  _SF = a8 - 10 < 0;
  if ( a8 >= 10 )
  {
    __asm { pushfw }
    v12 = _InterlockedExchange(&dword_805D184, a8);
    v15 = _InterlockedExchange(&dword_805D184, a7);
    v13 = v12;
    v14 = v15;
    v16 = sub_804C065(_CF, _ZF, _SF, _OF, a6, _InterlockedExchange(&dword_805D184, v13), v15);
    _CF = v16 < 0x12C;
    _OF = __OFSUB__(v16, 300);
    _ZF = v16 == 300;
    _SF = (signed int)(v16 - 300) < 0;
    if ( v16 != 300 )
    {
      v23 = _InterlockedExchange(&dword_805D184, v16);
      _InterlockedExchange(&dword_805D184, v17);
      sub_804C18B(_CF, _ZF, _SF, _OF, _InterlockedExchange(&dword_805D184, v23), v18, v14);
    }
    __asm { pushfw }
    v24 = _InterlockedExchange(&dword_805D160, v14);
    v27 = _InterlockedExchange(&dword_805D160, v18);
    v25 = v24;
    v26 = v27;
    _InterlockedExchange(&dword_805D160, v25);
    v28 = sub_804F071();
    _CF = v28 < 0xFFFFFFD0;
    _OF = __OFSUB__(v28, -48);
    _ZF = v28 == -48;
    _SF = (signed int)(v28 + 48) < 0;
    if ( v28 != -48 )
    {
      __asm { pushfw }
      v35 = _InterlockedExchange(&dword_805D148, v28);
      _InterlockedExchange(&dword_805D148, v30);
      _InterlockedExchange(&dword_805D148, v35);
      v36 = sub_80550FF();
      if ( v36 != 180 )
        sub_8055109(
          v36 < 0xB4,
          v36 == 180,
          (signed int)(v36 - 180) < 0,
          __OFSUB__(v36, 180),
          v36,
          _InterlockedExchange(&dword_805D148, _InterlockedExchange(&dword_805D148, v26)),
          _InterlockedExchange(&dword_805D148, v38));
      __asm { popfw }
      v39 = _InterlockedExchange(&dword_805D160, v26);
      _InterlockedExchange(&dword_805D160, v38);
      sub_804F07B(_InterlockedExchange(&dword_805D160, v39), v37);
    }
    __asm
    {
      popfw
      popfw
    }
    v41 = _InterlockedExchange(&dword_805D190, v26);
    v40 = _InterlockedExchange(&dword_805D190, v30);
    a7 = _InterlockedExchange(&dword_805D190, v41);
    a8 = v26 - 1;
    a5 = (_BYTE)a8 * v40 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = a5 == 0;
    _SF = a5 < 0;
    if ( a5 )
    {
      __asm { pushfw }
      v42 = _InterlockedExchange(&dword_805D124, a8);
      v45 = _InterlockedExchange(&dword_805D124, v29);
      v43 = v42;
      v44 = v45;
      _InterlockedExchange(&dword_805D124, v43);
      if ( sub_804972F() != 949 )
      {
        v48 = _InterlockedExchange(&dword_805D124, v44);
        _InterlockedExchange(&dword_805D124, v47);
        sub_8049739(_InterlockedExchange(&dword_805D124, v48), v46);
      }
      __asm { popfw }
      abort();
    }
  }
  __asm { pushfw }
  v49 = _InterlockedExchange(&dword_805D118, a5);
  _InterlockedExchange(&dword_805D118, a7);
  _InterlockedExchange(&dword_805D118, v49);
  v50 = sub_804B6EB();
  v52 = v50 < 0xFFFFFC6C;
  v55 = __OFSUB__(v50, -916);
  v53 = v50 == -916;
  v54 = (signed int)(v50 + 916) < 0;
  if ( v50 != -916 )
  {
    v56 = _InterlockedExchange(&dword_805D118, v50);
    _InterlockedExchange(&dword_805D118, v51);
    sub_804B6F5(v52, v53, v54, v55, _InterlockedExchange(&dword_805D118, v56), a8);
  }
  __asm
  {
    popfw
    popfw
  }
}
// 804B571: could not find valid save-restore pair for ebx
// 8049739: using guessed type int __fastcall sub_8049739(_DWORD, _DWORD);
// 804F07B: using guessed type int __fastcall sub_804F07B(_DWORD, _DWORD);
// 805D118: using guessed type int dword_805D118;
// 805D124: using guessed type int dword_805D124;
// 805D148: using guessed type int dword_805D148;
// 805D160: using guessed type int dword_805D160;
// 805D184: using guessed type int dword_805D184;
// 805D190: using guessed type int dword_805D190;

//----- (0804B6EB) --------------------------------------------------------
signed int sub_804B6EB()
{
  return -916;
}

//----- (0804B6F5) --------------------------------------------------------
void __usercall __noreturn sub_804B6F5(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>)
{
  char v6; // al
  signed __int32 v7; // ebx
  char v8; // t0

  __asm { pushfw }
  if ( a6 >= 10 )
  {
    v6 = a6;
    v7 = _InterlockedExchange(&dword_805D10C, a6);
    v8 = _InterlockedExchange(&dword_805D10C, a5);
    _InterlockedExchange(&dword_805D10C, v7);
    if ( (v8 - 1) * v6 & 1 )
      abort();
  }
  __asm { popfw }
  __halt();
  JUMPOUT(loc_804B72B);
}
// 805D10C: using guessed type int dword_805D10C;

//----- (0804B76D) --------------------------------------------------------
void sub_804B76D()
{
  ;
}

//----- (0804B771) --------------------------------------------------------
signed int __usercall sub_804B771@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>)
{
  signed __int32 v7; // eax
  signed __int32 v8; // edx
  signed __int32 v9; // ecx
  signed __int32 v10; // ebx
  char v11; // al
  signed __int32 v12; // ebx
  char v13; // t2
  signed __int32 v14; // eax
  unsigned __int32 v15; // eax
  signed __int32 v16; // edx
  signed __int32 v17; // ecx
  bool v18; // cf
  bool v19; // zf
  bool v20; // sf
  char v21; // of
  signed __int32 v22; // eax
  signed __int32 v23; // et0
  signed __int32 v25; // [esp-Ah] [ebp-Ah]
  signed __int32 v26; // [esp-4h] [ebp-4h]

  v26 = a5;
  __asm { pushfw }
  v7 = _InterlockedExchange(&dword_805D124, a5);
  _InterlockedExchange(&dword_805D124, a6);
  _InterlockedExchange(&dword_805D124, v7);
  if ( sub_804972F() != 949 )
  {
    v10 = _InterlockedExchange(&dword_805D124, a7);
    _InterlockedExchange(&dword_805D124, v8);
    sub_8049739(v9, _InterlockedExchange(&dword_805D124, v10));
  }
  __asm
  {
    popfw
    pushfw
  }
  v25 = a7;
  if ( a7 >= 10 )
  {
    v11 = a7;
    v12 = _InterlockedExchange(&dword_805D154, a7);
    v13 = _InterlockedExchange(&dword_805D154, v8);
    _InterlockedExchange(&dword_805D154, v12);
    if ( (v13 - 1) * v11 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  v14 = _InterlockedExchange(&dword_805D190, v26);
  _InterlockedExchange(&dword_805D190, v9);
  _InterlockedExchange(&dword_805D190, v14);
  v15 = sub_80554DE();
  v18 = v15 < 0x229;
  v21 = __OFSUB__(v15, 553);
  v19 = v15 == 553;
  v20 = (signed int)(v15 - 553) < 0;
  if ( v15 != 553 )
  {
    v23 = _InterlockedExchange(&dword_805D190, v15);
    v22 = _InterlockedExchange(&dword_805D190, v16);
    _InterlockedExchange(&dword_805D190, v23);
    sub_80554E8(v18, v19, v20, v21, v22, v17, v25);
  }
  __asm { popfw }
  return -342;
}
// 8049739: using guessed type int __fastcall sub_8049739(_DWORD, _DWORD);
// 805D124: using guessed type int dword_805D124;
// 805D154: using guessed type int dword_805D154;
// 805D190: using guessed type int dword_805D190;

//----- (0804B82B) --------------------------------------------------------
void __usercall __noreturn sub_804B82B(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>)
{
  signed __int32 v7; // ebx
  signed __int32 v8; // edx
  signed __int32 v9; // ebx
  signed __int32 v10; // et0
  signed __int32 v11; // edx
  int v12; // ecx
  signed __int32 v13; // ebx
  signed __int32 v14; // eax
  unsigned int v15; // eax
  signed __int32 v16; // edx
  char v21; // al
  signed __int32 v22; // ebx
  char v23; // tt
  signed __int32 v24; // ebx
  signed __int32 v25; // edx
  signed __int32 v26; // ebx
  signed __int32 v27; // et1
  unsigned __int32 v28; // eax
  signed __int32 v29; // edx
  signed __int32 v30; // ecx
  bool v31; // cf
  bool v32; // zf
  bool v33; // sf
  char v34; // of
  signed __int32 v35; // eax
  signed __int32 v36; // et2
  signed __int32 v37; // [esp-10h] [ebp-10h]
  signed __int32 v38; // [esp-Ah] [ebp-Ah]
  signed __int32 v39; // [esp-4h] [ebp-4h]

  v39 = a5;
  __asm { pushfw }
  v7 = _InterlockedExchange(&dword_805D160, a7);
  v10 = _InterlockedExchange(&dword_805D160, a6);
  v8 = v7;
  v9 = v10;
  _InterlockedExchange(&dword_805D160, v8);
  if ( sub_804F071() != -48 )
  {
    v13 = _InterlockedExchange(&dword_805D160, v9);
    _InterlockedExchange(&dword_805D160, v11);
    sub_804F07B(v12, _InterlockedExchange(&dword_805D160, v13));
  }
  __asm
  {
    popfw
    pushfw
  }
  v14 = _InterlockedExchange(&dword_805D16C, v39);
  _InterlockedExchange(&dword_805D16C, v11);
  _InterlockedExchange(&dword_805D16C, v14);
  v15 = sub_804C738();
  _CF = v15 < 0x38B;
  _OF = __OFSUB__(v15, 907);
  _ZF = v15 == 907;
  _SF = (signed int)(v15 - 907) < 0;
  if ( v15 != 907 )
  {
    v38 = v15;
    __asm { pushfw }
    v37 = v9;
    if ( v9 >= 10 )
    {
      v21 = v9;
      v22 = _InterlockedExchange(&dword_805D148, v9);
      v23 = _InterlockedExchange(&dword_805D148, v16);
      v16 = _InterlockedExchange(&dword_805D148, v22);
      if ( (v23 - 1) * v21 & 1 )
        abort();
    }
    __asm { popfw }
    sub_804C742(
      _CF,
      _ZF,
      _SF,
      _OF,
      _InterlockedExchange(&dword_805D16C, v16),
      _InterlockedExchange(&dword_805D16C, _InterlockedExchange(&dword_805D16C, v38)),
      v37);
  }
  __asm
  {
    popfw
    pushfw
  }
  v24 = _InterlockedExchange(&dword_805D190, v9);
  v27 = _InterlockedExchange(&dword_805D190, v16);
  v25 = v24;
  v26 = v27;
  _InterlockedExchange(&dword_805D190, v25);
  v28 = sub_80554DE();
  v31 = v28 < 0x229;
  v34 = __OFSUB__(v28, 553);
  v32 = v28 == 553;
  v33 = (signed int)(v28 - 553) < 0;
  if ( v28 != 553 )
  {
    v36 = _InterlockedExchange(&dword_805D190, v28);
    v35 = _InterlockedExchange(&dword_805D190, v29);
    _InterlockedExchange(&dword_805D190, v36);
    sub_80554E8(v31, v32, v33, v34, v35, v30, v26);
  }
  __asm { popfw }
  __halt();
  JUMPOUT(loc_804B919);
}
// 804F07B: using guessed type int __fastcall sub_804F07B(_DWORD, _DWORD);
// 805D148: using guessed type int dword_805D148;
// 805D160: using guessed type int dword_805D160;
// 805D16C: using guessed type int dword_805D16C;
// 805D190: using guessed type int dword_805D190;

//----- (0804B962) --------------------------------------------------------
int sub_804B962()
{
  int result; // eax

  result = &unk_805D243 - &unk_805D240;
  if ( (unsigned int)(&unk_805D243 - &unk_805D240) > 6 )
    result = 0;
  return result;
}
// 804B962: could not find valid save-restore pair for ebx
// 804B962: could not find valid save-restore pair for ebp
// 805D10C: using guessed type int dword_805D10C;
// 805D160: using guessed type int dword_805D160;
// 805D178: using guessed type int dword_805D178;

//----- (0804BB5B) --------------------------------------------------------
void sub_804BB5B()
{
  ;
}

//----- (0804BCAB) --------------------------------------------------------
void sub_804BCAB()
{
  ;
}

//----- (0804BE18) --------------------------------------------------------
int sub_804BE18()
{
  int result; // eax

  result = "%s.\n" - &aWrittenBySSSSS_3[40];
  if ( (unsigned int)("%s.\n" - &aWrittenBySSSSS_3[40]) > 6 )
    result = 0;
  return result;
}
// 804BE18: could not find valid save-restore pair for ebx
// 804BE18: could not find valid save-restore pair for ebp

//----- (0804BFD5) --------------------------------------------------------
void sub_804BFD5()
{
  ;
}

//----- (0804C061) --------------------------------------------------------
void sub_804C061()
{
  ;
}

//----- (0804C065) --------------------------------------------------------
signed int __usercall sub_804C065@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>)
{
  char v11; // al
  signed __int32 v12; // ebx
  signed __int32 v13; // et0
  int v14; // eax
  signed __int32 v15; // ebx
  signed __int32 v16; // ecx
  signed __int32 v17; // ebx
  signed __int32 v18; // et1
  signed __int32 v19; // edx
  signed __int32 v20; // ecx
  signed __int32 v21; // ebx
  signed __int32 v22; // ebx
  char v27; // al
  signed __int32 v28; // ett
  signed __int32 v29; // edx
  int v30; // eax
  signed __int32 v31; // ebx
  char v32; // t0
  signed __int32 v33; // ebx
  signed __int32 v34; // ecx
  signed __int32 v35; // ebx
  signed __int32 v36; // et1
  unsigned int v37; // eax
  signed __int32 v38; // edx
  signed __int32 v40; // [esp-Ah] [ebp-Ah]

  __asm { pushfw }
  v40 = a7;
  _CF = (unsigned int)a7 < 0xA;
  _OF = __OFSUB__(a7, 10);
  _ZF = a7 == 10;
  _SF = a7 - 10 < 0;
  if ( a7 >= 10 )
  {
    v11 = a7;
    v12 = _InterlockedExchange(&dword_805D130, a7);
    v13 = _InterlockedExchange(&dword_805D130, a5);
    _InterlockedExchange(&dword_805D130, v12);
    a7 = v13 - 1;
    v14 = ((_BYTE)v13 - 1) * v11 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = v14 == 0;
    _SF = v14 < 0;
    if ( v14 )
      abort();
  }
  __asm { pushfw }
  v15 = _InterlockedExchange(&dword_805D10C, a7);
  v18 = _InterlockedExchange(&dword_805D10C, a6);
  v16 = v15;
  v17 = v18;
  _InterlockedExchange(&dword_805D10C, v16);
  if ( sub_8049617() != -795 )
  {
    v21 = _InterlockedExchange(&dword_805D10C, v17);
    _InterlockedExchange(&dword_805D10C, v19);
    sub_8049621(v20, _InterlockedExchange(&dword_805D10C, v21));
  }
  __asm { popfw }
  v22 = v40;
  __asm
  {
    popfw
    pushfw
  }
  _CF = (unsigned int)v40 < 0xA;
  _OF = __OFSUB__(v40, 10);
  _ZF = v40 == 10;
  _SF = v40 - 10 < 0;
  if ( v40 >= 10 )
  {
    v28 = _InterlockedExchange(&dword_805D16C, v40);
    v27 = _InterlockedExchange(&dword_805D16C, v19);
    v29 = _InterlockedExchange(&dword_805D16C, v28);
    v22 = v40 - 1;
    v30 = ((_BYTE)v40 - 1) * v27 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = v30 == 0;
    _SF = v30 < 0;
    if ( v30 )
    {
      __asm { pushfw }
      if ( v22 >= 10 )
      {
        v31 = _InterlockedExchange(&dword_805D148, v22);
        v32 = _InterlockedExchange(&dword_805D148, v29);
        _InterlockedExchange(&dword_805D148, v31);
        if ( (v32 - 1) * ((_BYTE)v40 - 1) & 1 )
          abort();
      }
      __asm { popfw }
      abort();
    }
  }
  __asm { pushfw }
  v33 = _InterlockedExchange(&dword_805D118, v22);
  v36 = _InterlockedExchange(&dword_805D118, v20);
  v34 = v33;
  v35 = v36;
  _InterlockedExchange(&dword_805D118, v34);
  v37 = sub_804B6EB();
  if ( v37 != -916 )
    sub_804B6F5(
      v37 < 0xFFFFFC6C,
      v37 == -916,
      (signed int)(v37 + 916) < 0,
      __OFSUB__(v37, -916),
      _InterlockedExchange(&dword_805D118, _InterlockedExchange(&dword_805D118, v35)),
      _InterlockedExchange(&dword_805D118, v38));
  __asm
  {
    popfw
    popfw
  }
  return 300;
}
// 804C065: could not find valid save-restore pair for ebx
// 8049621: using guessed type int __fastcall sub_8049621(_DWORD, _DWORD);
// 805D10C: using guessed type int dword_805D10C;
// 805D118: using guessed type int dword_805D118;
// 805D130: using guessed type int dword_805D130;
// 805D148: using guessed type int dword_805D148;
// 805D16C: using guessed type int dword_805D16C;

//----- (0804C18B) --------------------------------------------------------
void __usercall __noreturn sub_804C18B(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>)
{
  signed __int32 v15; // ebx
  signed __int32 v16; // edx
  signed __int32 v17; // ebx
  signed __int32 v18; // et0
  unsigned __int32 v19; // eax
  signed __int32 v20; // ecx
  bool v21; // cf
  bool v22; // zf
  bool v23; // sf
  char v24; // of
  signed __int32 v25; // eax
  signed __int32 v26; // et1
  char v27; // al
  signed __int32 v28; // et2
  char v29; // al
  signed __int32 v30; // ett
  int v31; // eax
  signed __int32 v36; // eax
  unsigned __int32 v37; // eax
  signed __int32 v38; // edx
  signed __int32 v39; // [esp-14h] [ebp-14h]

  __asm { pushfw }
  _CF = (unsigned int)a7 < 0xA;
  _OF = __OFSUB__(a7, 10);
  _ZF = a7 == 10;
  _SF = a7 - 10 < 0;
  if ( a7 >= 10 )
  {
    __asm { pushfw }
    v39 = a7;
    _CF = (unsigned int)a7 < 0xA;
    _OF = __OFSUB__(a7, 10);
    _ZF = a7 == 10;
    _SF = a7 - 10 < 0;
    if ( a7 >= 10 )
    {
      __asm { pushfw }
      v15 = _InterlockedExchange(&dword_805D130, a7);
      v18 = _InterlockedExchange(&dword_805D130, a5);
      v16 = v15;
      v17 = v18;
      _InterlockedExchange(&dword_805D130, v16);
      v19 = sub_80527A0();
      v21 = v19 < 0x229;
      v24 = __OFSUB__(v19, 553);
      v22 = v19 == 553;
      v23 = (signed int)(v19 - 553) < 0;
      if ( v19 != 553 )
      {
        v26 = _InterlockedExchange(&dword_805D130, v19);
        v25 = _InterlockedExchange(&dword_805D130, v20);
        _InterlockedExchange(&dword_805D130, v26);
        sub_80527AA(v21, v22, v23, v24, v25, a5);
      }
      __asm { popfw }
      v28 = _InterlockedExchange(&dword_805D160, v17);
      v27 = _InterlockedExchange(&dword_805D160, v20);
      a6 = _InterlockedExchange(&dword_805D160, v28);
      if ( ((_BYTE)v17 - 1) * v27 & 1 )
        abort();
    }
    __asm { popfw }
    v30 = _InterlockedExchange(&dword_805D178, v39);
    v29 = _InterlockedExchange(&dword_805D178, a6);
    _InterlockedExchange(&dword_805D178, v30);
    v31 = ((_BYTE)v39 - 1) * v29 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = v31 == 0;
    _SF = v31 < 0;
    if ( v31 )
    {
      __asm { pushfw }
      v36 = _InterlockedExchange(&dword_805D16C, v31);
      _InterlockedExchange(&dword_805D16C, a5);
      _InterlockedExchange(&dword_805D16C, v36);
      v37 = sub_804C738();
      if ( v37 != 907 )
        sub_804C742(
          v37 < 0x38B,
          v37 == 907,
          (signed int)(v37 - 907) < 0,
          __OFSUB__(v37, 907),
          _InterlockedExchange(&dword_805D16C, v38),
          _InterlockedExchange(&dword_805D16C, _InterlockedExchange(&dword_805D16C, v37)),
          v39 - 1);
      __asm { popfw }
      abort();
    }
  }
  __asm { popfw }
  __halt();
  JUMPOUT(*(_DWORD *)byte_804C273);
}
// 805D130: using guessed type int dword_805D130;
// 805D160: using guessed type int dword_805D160;
// 805D16C: using guessed type int dword_805D16C;
// 805D178: using guessed type int dword_805D178;

//----- (0804C27F) --------------------------------------------------------
int __usercall sub_804C27F@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>)
{
  char v7; // al
  signed __int32 v8; // ebx
  char v9; // t0
  int result; // eax
  int v11; // [esp+18h] [ebp-4h]

  v11 = a5;
  __asm { pushfw }
  if ( a7 >= 10 )
  {
    v7 = a7;
    v8 = _InterlockedExchange(&dword_805D178, a7);
    v9 = _InterlockedExchange(&dword_805D178, a6);
    _InterlockedExchange(&dword_805D178, v8);
    if ( (v9 - 1) * v7 & 1 )
      abort();
  }
  __asm { popfw }
  result = &unk_805D73C - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_805D73C - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 804C27F: could not find valid save-restore pair for ebp
// 805D16C: using guessed type int dword_805D16C;
// 805D178: using guessed type int dword_805D178;
// 805D1B4: using guessed type int dword_805D1B4;
// 805D260: using guessed type int program_invocation_short_name;

//----- (0804C413) --------------------------------------------------------
void sub_804C413()
{
  ;
}

//----- (0804C4A0) --------------------------------------------------------
void __usercall __spoils<edx,ecx> sub_804C4A0(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>)
{
  signed __int32 v6; // ebx
  signed __int32 v7; // ecx
  signed __int32 v8; // ebx
  signed __int32 v9; // et0
  unsigned __int32 v10; // eax
  signed __int32 v11; // ecx

  __asm { pushfw }
  v6 = _InterlockedExchange(&dword_805D1B4, a6);
  v9 = _InterlockedExchange(&dword_805D1B4, a5);
  v7 = v6;
  v8 = v9;
  _InterlockedExchange(&dword_805D1B4, v7);
  v10 = sub_8056BAD();
  if ( v10 != 702 )
    sub_8056BB7(
      v10 < 0x2BE,
      v10 == 702,
      (signed int)(v10 - 702) < 0,
      __OFSUB__(v10, 702),
      v10,
      _InterlockedExchange(&dword_805D1B4, _InterlockedExchange(&dword_805D1B4, v8)),
      _InterlockedExchange(&dword_805D1B4, v11));
  __asm { popfw }
}
// 805D1B4: using guessed type int dword_805D1B4;

//----- (0804C643) --------------------------------------------------------
int sub_804C643()
{
  int result; // eax

  result = &unk_805D74C - (_UNKNOWN *)&program_invocation_name;
  if ( (unsigned int)(&unk_805D74C - (_UNKNOWN *)&program_invocation_name) > 6 )
    result = 0;
  return result;
}
// 804C643: could not find valid save-restore pair for ebx
// 804C643: could not find valid save-restore pair for ebp
// 8055DBE: using guessed type int __fastcall sub_8055DBE(_DWORD, _DWORD);
// 805D118: using guessed type int dword_805D118;
// 805D13C: using guessed type int dword_805D13C;
// 805D190: using guessed type int dword_805D190;
// 805D270: using guessed type int program_invocation_name;

//----- (0804C738) --------------------------------------------------------
signed int sub_804C738()
{
  return 907;
}

//----- (0804C742) --------------------------------------------------------
void __usercall __noreturn sub_804C742(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>)
{
  signed __int32 v7; // eax
  unsigned __int32 v8; // eax
  signed __int32 v9; // edx
  signed __int32 v10; // ecx
  bool v11; // cf
  bool v12; // zf
  bool v13; // sf
  char v14; // of
  signed __int32 v15; // eax
  signed __int32 v16; // et1
  unsigned __int32 v17; // eax
  signed __int32 v18; // edx
  signed __int32 v19; // ecx
  bool v20; // cf
  bool v21; // zf
  bool v22; // sf
  char v23; // of
  signed __int32 v24; // eax
  signed __int32 v25; // ebx
  signed __int32 v26; // eax
  signed __int32 v27; // edx
  int v28; // ecx
  signed __int32 v29; // eax
  signed __int32 v30; // [esp-4h] [ebp-4h]

  v30 = a5;
  __asm { pushfw }
  v7 = _InterlockedExchange(&dword_805D130, a5);
  _InterlockedExchange(&dword_805D130, a6);
  _InterlockedExchange(&dword_805D130, v7);
  v8 = sub_80527A0();
  v11 = v8 < 0x229;
  v14 = __OFSUB__(v8, 553);
  v12 = v8 == 553;
  v13 = (signed int)(v8 - 553) < 0;
  if ( v8 != 553 )
  {
    v16 = _InterlockedExchange(&dword_805D130, v8);
    v15 = _InterlockedExchange(&dword_805D130, v10);
    _InterlockedExchange(&dword_805D130, v16);
    sub_80527AA(v11, v12, v13, v14, v15, v9);
  }
  __asm
  {
    popfw
    pushfw
  }
  v17 = sub_804B1D3(
          _CF,
          _ZF,
          _SF,
          _OF,
          _InterlockedExchange(&dword_805D154, v10),
          v9,
          _InterlockedExchange(&dword_805D154, _InterlockedExchange(&dword_805D154, v30)),
          a7);
  v20 = v17 < 0xF;
  v23 = __OFSUB__(v17, 15);
  v21 = v17 == 15;
  v22 = (signed int)(v17 - 15) < 0;
  if ( v17 != 15 )
  {
    v24 = _InterlockedExchange(&dword_805D154, v17);
    _InterlockedExchange(&dword_805D154, v19);
    sub_804B283(v20, v21, v22, v23, _InterlockedExchange(&dword_805D154, v24), a7);
  }
  __asm
  {
    popfw
    pushfw
  }
  v25 = _InterlockedExchange(&dword_805D160, a7);
  _InterlockedExchange(&dword_805D160, v18);
  _InterlockedExchange(&dword_805D160, v25);
  v26 = sub_804F071();
  if ( v26 != -48 )
  {
    v29 = _InterlockedExchange(&dword_805D160, v26);
    _InterlockedExchange(&dword_805D160, v27);
    sub_804F07B(v28, _InterlockedExchange(&dword_805D160, v29));
  }
  __asm { popfw }
  __halt();
  JUMPOUT(loc_804C7F7);
}
// 804F07B: using guessed type int __fastcall sub_804F07B(_DWORD, _DWORD);
// 805D130: using guessed type int dword_805D130;
// 805D154: using guessed type int dword_805D154;
// 805D160: using guessed type int dword_805D160;

//----- (0804C908) --------------------------------------------------------
int __usercall sub_804C908@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>, signed __int64 a3)
{
  signed __int32 v7; // edx
  signed __int32 v8; // ecx
  char v9; // al
  signed __int32 v10; // et0
  signed __int32 v11; // eax
  int v12; // edx
  signed __int32 v13; // ecx
  signed __int32 v14; // ebx
  int result; // eax
  char v16; // al
  signed __int32 v17; // ett
  char v18; // al
  signed __int32 v19; // et0
  int v20; // [esp-4h] [ebp-2Ch]

  _CF = 0;
  _OF = 0;
  _ZF = HIDWORD(a3) == 0;
  _SF = a3 < 0;
  if ( HIDWORD(a3) )
  {
    v20 = sub_8057062(a2, a3, 0xF4240u, 0);
    __asm { pushfw }
    if ( a2 >= 10 )
    {
      v10 = _InterlockedExchange(&dword_805D10C, a2);
      v9 = _InterlockedExchange(&dword_805D10C, v8);
      _InterlockedExchange(&dword_805D10C, v10);
      if ( ((_BYTE)a2 - 1) * v9 & 1 )
        abort();
    }
    __asm
    {
      popfw
      pushfw
    }
    v11 = _InterlockedExchange(&dword_805D124, v20);
    _InterlockedExchange(&dword_805D124, v7);
    _InterlockedExchange(&dword_805D124, v11);
    if ( sub_804972F() != 949 )
    {
      v14 = _InterlockedExchange(&dword_805D124, a2);
      _InterlockedExchange(&dword_805D124, v13);
      sub_8049739(_InterlockedExchange(&dword_805D124, v14), v12);
    }
    __asm { popfw }
    result = v20 + 1000000;
  }
  else
  {
    __asm { pushfw }
    if ( a2 >= 10 )
    {
      v17 = _InterlockedExchange(&dword_805D130, a2);
      v16 = _InterlockedExchange(&dword_805D130, a1);
      a1 = _InterlockedExchange(&dword_805D130, v17);
      if ( ((_BYTE)a2 - 1) * v16 & 1 )
        abort();
    }
    __asm
    {
      popfw
      pushfw
    }
    if ( a2 >= 10 )
    {
      v19 = _InterlockedExchange(&dword_805D1B4, a2);
      v18 = _InterlockedExchange(&dword_805D1B4, a1);
      _InterlockedExchange(&dword_805D1B4, v19);
      if ( ((_BYTE)a2 - 1) * v18 & 1 )
        abort();
    }
    __asm { popfw }
    result = a3;
  }
  return result;
}
// 8049739: using guessed type int __fastcall sub_8049739(_DWORD, _DWORD);
// 805D10C: using guessed type int dword_805D10C;
// 805D124: using guessed type int dword_805D124;
// 805D130: using guessed type int dword_805D130;
// 805D1B4: using guessed type int dword_805D1B4;

//----- (0804CA2C) --------------------------------------------------------
unsigned int __usercall sub_804CA2C@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, int a9, unsigned int a10)
{
  signed __int32 v14; // ebx
  signed __int32 v15; // edx
  signed __int32 v16; // ebx
  signed __int32 v17; // et0
  unsigned int v18; // eax
  signed __int32 v19; // ecx
  signed __int32 v20; // ebx
  signed __int32 v21; // et1
  char v22; // al
  signed __int32 v23; // ebx
  signed __int32 v24; // et2
  signed __int32 v25; // ebx
  signed __int32 v26; // ecx
  signed __int32 v27; // ebx
  signed __int32 v28; // ett
  unsigned int v29; // eax
  signed __int32 v30; // edx
  signed __int32 v31; // ecx
  signed __int32 v32; // ebx
  signed __int32 v33; // et0
  char v34; // al
  signed __int32 v35; // ebx
  char v36; // t1
  signed __int32 v37; // ebx
  signed __int32 v38; // eax
  unsigned int v39; // eax
  signed __int32 v40; // edx
  signed __int32 v41; // ecx
  char v46; // al
  signed __int32 v47; // ett
  signed __int32 v48; // ebx
  signed __int32 v49; // et0
  signed __int32 v51; // [esp-14h] [ebp-14h]
  signed __int32 v52; // [esp-14h] [ebp-14h]
  signed __int32 v53; // [esp-Eh] [ebp-Eh]

  __asm { pushfw }
  _CF = (unsigned int)a8 < 0xA;
  _OF = __OFSUB__(a8, 10);
  _ZF = a8 == 10;
  _SF = a8 - 10 < 0;
  if ( a8 >= 10 )
  {
    __asm { pushfw }
    v14 = _InterlockedExchange(&dword_805D154, a8);
    v17 = _InterlockedExchange(&dword_805D154, a6);
    v15 = v14;
    v16 = v17;
    v18 = sub_804B1D3(_CF, _ZF, _SF, _OF, a5, _InterlockedExchange(&dword_805D154, v15), a7, v17);
    if ( v18 != 15 )
    {
      v20 = _InterlockedExchange(&dword_805D154, v16);
      v21 = _InterlockedExchange(&dword_805D154, a6);
      _InterlockedExchange(&dword_805D154, v20);
      sub_804B283(v18 < 0xF, v18 == 15, (signed int)(v18 - 15) < 0, __OFSUB__(v18, 15), v19, v21);
    }
    __asm { popfw }
    v22 = v16;
    v23 = _InterlockedExchange(&dword_805D1C0, v16);
    v24 = _InterlockedExchange(&dword_805D1C0, v19);
    a7 = _InterlockedExchange(&dword_805D1C0, v23);
    a8 = v24 - 1;
    a5 = ((_BYTE)v24 - 1) * v22 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = a5 == 0;
    _SF = a5 < 0;
    if ( a5 )
    {
      __asm { pushfw }
      v25 = _InterlockedExchange(&dword_805D178, a8);
      v28 = _InterlockedExchange(&dword_805D178, a7);
      v26 = v25;
      v27 = v28;
      _InterlockedExchange(&dword_805D178, v26);
      v29 = sub_804A5EF();
      if ( v29 != 421 )
      {
        v32 = _InterlockedExchange(&dword_805D178, v27);
        v33 = _InterlockedExchange(&dword_805D178, v31);
        _InterlockedExchange(&dword_805D178, v32);
        sub_804A5F9(v29 < 0x1A5, v29 == 421, (signed int)(v29 - 421) < 0, __OFSUB__(v29, 421), v30, v33);
      }
      __asm { popfw }
      abort();
    }
  }
  v53 = a5;
  __asm { pushfw }
  v51 = a8;
  if ( a8 >= 10 )
  {
    v34 = a8;
    v35 = _InterlockedExchange(&dword_805D124, a8);
    v36 = _InterlockedExchange(&dword_805D124, a7);
    _InterlockedExchange(&dword_805D124, v35);
    if ( (v36 - 1) * v34 & 1 )
      abort();
  }
  v37 = v51;
  __asm
  {
    popfw
    pushfw
  }
  v38 = _InterlockedExchange(&dword_805D190, v53);
  _InterlockedExchange(&dword_805D190, a6);
  _InterlockedExchange(&dword_805D190, v38);
  v39 = sub_80554DE();
  _CF = v39 < 0x229;
  _OF = __OFSUB__(v39, 553);
  _ZF = v39 == 553;
  _SF = (signed int)(v39 - 553) < 0;
  if ( v39 != 553 )
  {
    v52 = v39;
    __asm { pushfw }
    if ( v37 >= 10 )
    {
      v47 = _InterlockedExchange(&dword_805D13C, v37);
      v46 = _InterlockedExchange(&dword_805D13C, v40);
      v40 = _InterlockedExchange(&dword_805D13C, v47);
      if ( ((_BYTE)v37 - 1) * v46 & 1 )
        abort();
    }
    __asm { popfw }
    v48 = _InterlockedExchange(&dword_805D190, v37);
    v49 = _InterlockedExchange(&dword_805D190, v40);
    _InterlockedExchange(&dword_805D190, v48);
    sub_80554E8(_CF, _ZF, _SF, _OF, v52, v41, v49);
  }
  __asm
  {
    popfw
    popfw
  }
  return a10 - 1 + a9 - (a10 - 1 + a9) % a10;
}
// 804CA2C: could not find valid save-restore pair for ebp
// 805D124: using guessed type int dword_805D124;
// 805D13C: using guessed type int dword_805D13C;
// 805D154: using guessed type int dword_805D154;
// 805D178: using guessed type int dword_805D178;
// 805D190: using guessed type int dword_805D190;
// 805D1C0: using guessed type int dword_805D1C0;

//----- (0804CBBA) --------------------------------------------------------
int sub_804CBBA()
{
  FILE *v0; // ebx
  char *v1; // eax
  signed __int32 v2; // ebx
  signed __int32 v3; // ecx
  signed __int32 v4; // ecx
  signed __int32 v5; // ebx
  signed __int32 v6; // et0
  unsigned __int32 v7; // eax
  signed __int32 v8; // edx
  signed __int32 v9; // ecx
  signed __int32 v18; // eax
  signed __int32 v19; // eax
  signed __int32 v20; // edx
  signed __int32 v21; // eax
  char v22; // al
  signed __int32 v23; // ett
  signed __int32 v24; // eax
  char v25; // al
  signed __int32 v26; // et1
  signed __int32 v28; // [esp-Ah] [ebp-22h]
  int v29; // [esp-4h] [ebp-1Ch]

  v0 = stdout;
  v1 = gettext("\nWith no FILE, or when FILE is -, read standard input.\n");
  v29 = fputs_unlocked(v1, v0);
  __asm { pushfw }
  v2 = _InterlockedExchange(&dword_805D178, (signed __int32)v0);
  v6 = _InterlockedExchange(&dword_805D178, v3);
  v4 = v2;
  v5 = v6;
  _InterlockedExchange(&dword_805D178, v4);
  v7 = sub_804A5EF();
  _CF = v7 < 0x1A5;
  _OF = __OFSUB__(v7, 421);
  _ZF = v7 == 421;
  _SF = (signed int)(v7 - 421) < 0;
  if ( v7 != 421 )
  {
    v28 = v7;
    __asm { pushfw }
    _CF = (unsigned int)v5 < 0xA;
    _OF = __OFSUB__(v5, 10);
    _ZF = v5 == 10;
    _SF = v5 - 10 < 0;
    if ( v5 >= 10 )
    {
      __asm { pushfw }
      v18 = _InterlockedExchange(&dword_805D124, v7);
      _InterlockedExchange(&dword_805D124, v9);
      _InterlockedExchange(&dword_805D124, v18);
      v19 = sub_804972F();
      if ( v19 != 949 )
      {
        v21 = _InterlockedExchange(&dword_805D124, v19);
        _InterlockedExchange(&dword_805D124, v9);
        sub_8049739(_InterlockedExchange(&dword_805D124, v21), v20);
      }
      __asm { popfw }
      v23 = _InterlockedExchange(&dword_805D16C, v5);
      v22 = _InterlockedExchange(&dword_805D16C, v20);
      v8 = _InterlockedExchange(&dword_805D16C, v23);
      if ( ((_BYTE)v5 - 1) * v22 & 1 )
        abort();
    }
    __asm { popfw }
    v24 = _InterlockedExchange(&dword_805D178, v28);
    _InterlockedExchange(&dword_805D178, v9);
    _InterlockedExchange(&dword_805D178, v24);
    sub_804A5F9(_CF, _ZF, _SF, _OF, v8, v5);
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( v5 >= 10 )
  {
    v26 = _InterlockedExchange(&dword_805D184, v5);
    v25 = _InterlockedExchange(&dword_805D184, v8);
    _InterlockedExchange(&dword_805D184, v26);
    if ( ((_BYTE)v5 - 1) * v25 & 1 )
      abort();
  }
  __asm { popfw }
  return v29;
}
// 8048F20: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8049739: using guessed type int __fastcall sub_8049739(_DWORD, _DWORD);
// 805D124: using guessed type int dword_805D124;
// 805D16C: using guessed type int dword_805D16C;
// 805D178: using guessed type int dword_805D178;
// 805D184: using guessed type int dword_805D184;

//----- (0804CCCC) --------------------------------------------------------
int __usercall sub_804CCCC@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>, char *s1)
{
  const char *v3; // eax
  char v8; // al
  signed __int32 v9; // ebx
  char v10; // t0
  char *v11; // eax
  signed __int32 v12; // edx
  char v13; // al
  signed __int32 v14; // et1
  char *v19; // eax
  signed __int32 v20; // ecx
  char *v21; // eax
  signed __int32 v22; // ebx
  char v23; // t2
  char *v24; // ebx
  char *v25; // eax
  signed __int32 v27; // [esp-Ah] [ebp-72h]
  int v28; // [esp-4h] [ebp-6Ch]
  char *v29; // [esp+1Ch] [ebp-4Ch]
  const char **i; // [esp+20h] [ebp-48h]
  const char *v31; // [esp+24h] [ebp-44h]
  const char *v32; // [esp+28h] [ebp-40h]
  const char *v33; // [esp+2Ch] [ebp-3Ch]
  const char *v34; // [esp+30h] [ebp-38h]
  const char *v35; // [esp+34h] [ebp-34h]
  const char *v36; // [esp+38h] [ebp-30h]
  const char *v37; // [esp+3Ch] [ebp-2Ch]
  const char *v38; // [esp+40h] [ebp-28h]
  const char *v39; // [esp+44h] [ebp-24h]
  const char *v40; // [esp+48h] [ebp-20h]
  const char *v41; // [esp+4Ch] [ebp-1Ch]
  const char *v42; // [esp+50h] [ebp-18h]
  const char *v43; // [esp+54h] [ebp-14h]
  int v44; // [esp+58h] [ebp-10h]
  int v45; // [esp+5Ch] [ebp-Ch]

  v32 = "[";
  v33 = "test invocation";
  v34 = "coreutils";
  v35 = "Multi-call invocation";
  v36 = "sha224sum";
  v37 = "sha2 utilities";
  v38 = "sha256sum";
  v39 = "sha2 utilities";
  v40 = "sha384sum";
  v41 = "sha2 utilities";
  v42 = "sha512sum";
  v43 = "sha2 utilities";
  v44 = 0;
  v45 = 0;
  v29 = s1;
  for ( i = &v32; *i && strcmp(s1, *i); i += 2 )
    ;
  v3 = i[1];
  _CF = 0;
  _OF = 0;
  _ZF = v3 == 0;
  _SF = (signed int)v3 < 0;
  if ( v3 )
    v29 = (char *)i[1];
  __asm { pushfw }
  v27 = a2;
  if ( a2 >= 10 )
  {
    v8 = a2;
    v9 = _InterlockedExchange(&dword_805D130, a2);
    v10 = _InterlockedExchange(&dword_805D130, a1);
    _InterlockedExchange(&dword_805D130, v9);
    if ( (v10 - 1) * v8 & 1 )
      abort();
  }
  __asm { popfw }
  v11 = gettext("\n%s online help: <%s>\n");
  printf(v11, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  v31 = setlocale(5, 0);
  if ( v31 )
  {
    v28 = strncmp(v31, "en_", 3u);
    __asm { pushfw }
    if ( v27 >= 10 )
    {
      v14 = _InterlockedExchange(&dword_805D160, v27);
      v13 = _InterlockedExchange(&dword_805D160, v12);
      _InterlockedExchange(&dword_805D160, v14);
      if ( ((_BYTE)v27 - 1) * v13 & 1 )
        abort();
    }
    __asm { popfw }
    if ( v28 )
    {
      v19 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
      __asm { pushfw }
      if ( v27 >= 10 )
      {
        v22 = _InterlockedExchange(&dword_805D148, v27);
        v23 = _InterlockedExchange(&dword_805D148, v20);
        _InterlockedExchange(&dword_805D148, v22);
        if ( (v23 - 1) * (_BYTE)v27 & 1 )
          abort();
      }
      __asm { popfw }
      printf(v19, s1);
    }
  }
  v21 = gettext("Full documentation at: <%s%s>\n");
  printf(v21, "http://www.gnu.org/software/coreutils/", s1);
  if ( v29 == s1 )
    v24 = " invocation";
  else
    v24 = &locale;
  v25 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  return printf(v25, v29, v24);
}
// 805D130: using guessed type int dword_805D130;
// 805D148: using guessed type int dword_805D148;
// 805D160: using guessed type int dword_805D160;

//----- (0804CF3B) --------------------------------------------------------
int __cdecl sub_804CF3B(int a1)
{
  return a1;
}

//----- (0804CF43) --------------------------------------------------------
void __usercall __noreturn sub_804CF43(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, int a9)
{
  char v9; // al
  signed __int32 v10; // et0
  char v11; // al
  signed __int32 v12; // et1
  char v13; // al
  signed __int32 v14; // et2
  signed __int32 v15; // ebx
  char v16; // tt
  char v17; // al
  signed __int32 v18; // et0
  int v19; // ebx
  char *format; // eax
  signed __int32 v21; // ebx
  signed __int32 v22; // ecx
  char v23; // al
  signed __int32 v24; // et1
  int v25; // eax
  signed __int32 v26; // eax
  signed __int32 v27; // ecx
  signed __int32 v28; // edx
  unsigned int v29; // eax
  signed __int32 v30; // ecx
  FILE *v31; // ebx
  char *v32; // eax
  FILE *v33; // ebx
  char *v34; // eax
  char *v35; // eax
  FILE *v36; // ebx
  signed __int32 v37; // edx
  char v38; // al
  signed __int32 v39; // ebx
  char v40; // t0
  signed __int32 v41; // edx
  signed __int32 v42; // ebx
  char v43; // t1
  FILE *v44; // ebx
  char *v45; // eax
  FILE *v46; // ebx
  char *v47; // eax
  FILE *v48; // ebx
  char *v49; // eax
  char *v50; // eax
  signed __int32 v51; // edx
  signed __int32 v52; // [esp-Ah] [ebp-26h]
  char *v53; // [esp-4h] [ebp-20h]
  char *v54; // [esp-4h] [ebp-20h]
  signed __int32 v55; // [esp+12h] [ebp-Ah]
  int v56; // [esp+18h] [ebp-4h]

  v56 = a5;
  __asm { pushfw }
  v55 = a8;
  if ( a8 >= 10 )
  {
    v10 = _InterlockedExchange(&dword_805D10C, a8);
    v9 = _InterlockedExchange(&dword_805D10C, a6);
    a6 = _InterlockedExchange(&dword_805D10C, v10);
    if ( ((_BYTE)a8 - 1) * v9 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( a8 >= 10 )
  {
    v12 = _InterlockedExchange(&dword_805D154, a8);
    v11 = _InterlockedExchange(&dword_805D154, a6);
    a6 = _InterlockedExchange(&dword_805D154, v12);
    if ( ((_BYTE)a8 - 1) * v11 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( a8 >= 10 )
  {
    v14 = _InterlockedExchange(&dword_805D16C, a8);
    v13 = _InterlockedExchange(&dword_805D16C, a7);
    a7 = _InterlockedExchange(&dword_805D16C, v14);
    if ( ((_BYTE)a8 - 1) * v13 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( a8 >= 10 )
  {
    v15 = _InterlockedExchange(&dword_805D178, a8);
    v16 = _InterlockedExchange(&dword_805D178, a6);
    _InterlockedExchange(&dword_805D178, v15);
    if ( (v16 - 1) * (_BYTE)v55 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( v55 >= 10 )
  {
    v18 = _InterlockedExchange(&dword_805D1B4, v55);
    v17 = _InterlockedExchange(&dword_805D1B4, a7);
    _InterlockedExchange(&dword_805D1B4, v18);
    if ( ((_BYTE)v55 - 1) * v17 & 1 )
      abort();
  }
  __asm { popfw }
  if ( a9 )
  {
    v19 = dword_805D7EA;
    format = gettext("Try '%s --help' for more information.\n");
    fprintf(stderr, format, v19);
  }
  else
  {
    v21 = dword_805D7EA;
    v53 = gettext("Usage: %s [OPTION]... [FILE]...\nPrint or check %s (%d-bit) checksums.\n");
    __asm { pushfw }
    if ( v21 >= 10 )
    {
      v24 = _InterlockedExchange(&dword_805D154, v21);
      v23 = _InterlockedExchange(&dword_805D154, v22);
      _InterlockedExchange(&dword_805D154, v24);
      if ( ((_BYTE)v21 - 1) * v23 & 1 )
        abort();
    }
    __asm { popfw }
    printf(v53, v21, "MD5", 128);
    v25 = sub_804CBBA();
    __asm { pushfw }
    v26 = _InterlockedExchange(&dword_805D1C0, v25);
    _InterlockedExchange(&dword_805D1C0, v27);
    v29 = sub_8054904(_CF, _ZF, _SF, _OF, v28, _InterlockedExchange(&dword_805D1C0, v26), v21);
    if ( v29 != 655 )
      sub_8054A34(
        v29 < 0x28F,
        v29 == 655,
        (signed int)(v29 - 655) < 0,
        __OFSUB__(v29, 655),
        _InterlockedExchange(&dword_805D1C0, _InterlockedExchange(&dword_805D1C0, v21)),
        _InterlockedExchange(&dword_805D1C0, v30));
    __asm { popfw }
    v31 = stdout;
    v32 = gettext("\n  -b, --binary         read in binary mode\n");
    fputs_unlocked(v32, v31);
    v35 = gettext("  -c, --check          read %s sums from the FILEs and check them\n");
    printf(v35, "MD5");
    v33 = stdout;
    v34 = gettext("      --tag            create a BSD-style checksum\n");
    fputs_unlocked(v34, v33);
    v36 = stdout;
    v54 = gettext("  -t, --text           read in text mode (default)\n");
    __asm { pushfw }
    v52 = (signed __int32)v36;
    if ( (signed int)v36 >= 10 )
    {
      v38 = (char)v36;
      v39 = _InterlockedExchange(&dword_805D148, (signed __int32)v36);
      v40 = _InterlockedExchange(&dword_805D148, v37);
      _InterlockedExchange(&dword_805D148, v39);
      if ( (v40 - 1) * v38 & 1 )
        abort();
    }
    __asm { popfw }
    fputs_unlocked(v54, v52);
    __asm { pushfw }
    if ( v52 >= 10 )
    {
      v42 = _InterlockedExchange(&dword_805D1A8, v52);
      v43 = _InterlockedExchange(&dword_805D1A8, v41);
      _InterlockedExchange(&dword_805D1A8, v42);
      if ( (v43 - 1) * (_BYTE)v52 & 1 )
        abort();
    }
    __asm { popfw }
    v44 = stdout;
    v45 = gettext(
            "\n"
            "The following five options are useful only when verifying checksums:\n"
            "      --ignore-missing  don't fail or report status for missing files\n"
            "      --quiet          don't print OK for each successfully verified file\n"
            "      --status         don't output anything, status code shows success\n"
            "      --strict         exit non-zero for improperly formatted checksum lines\n"
            "  -w, --warn           warn about improperly formatted checksum lines\n"
            "\n");
    fputs_unlocked(v45, v44);
    v46 = stdout;
    v47 = gettext("      --help     display this help and exit\n");
    fputs_unlocked(v47, v46);
    v48 = stdout;
    v49 = gettext("      --version  output version information and exit\n");
    fputs_unlocked(v49, v48);
    v50 = gettext(
            "\n"
            "The sums are computed as described in %s.  When checking, the input\n"
            "should be a former output of this program.  The default mode is to print a\n"
            "line with checksum, a space, a character indicating input mode ('*' for binary,\n"
            "' ' for text or where binary is insignificant), and name for each FILE.\n");
    printf(v50, "RFC 1321");
    sub_804CCCC(v51, (signed __int32)v48, "md5sum");
  }
  exit(a9);
}
// 8048F20: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 805D10C: using guessed type int dword_805D10C;
// 805D148: using guessed type int dword_805D148;
// 805D154: using guessed type int dword_805D154;
// 805D16C: using guessed type int dword_805D16C;
// 805D178: using guessed type int dword_805D178;
// 805D1A8: using guessed type int dword_805D1A8;
// 805D1B4: using guessed type int dword_805D1B4;
// 805D1C0: using guessed type int dword_805D1C0;
// 805D7EA: using guessed type int dword_805D7EA;

//----- (0804D2B0) --------------------------------------------------------
_BYTE *__usercall sub_804D2B0@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, _BYTE *a4, unsigned int a5)
{
  signed __int32 v5; // ebx
  signed __int32 v6; // edx
  signed __int32 v7; // ebx
  signed __int32 v8; // et0
  signed __int32 v9; // edx
  char v10; // al
  signed __int32 v11; // et1
  char v12; // al
  signed __int32 v13; // et2
  signed __int32 v22; // ebx
  signed __int32 v23; // edx
  signed __int32 v24; // ebx
  signed __int32 v25; // ett
  unsigned __int32 v26; // eax
  signed __int32 v27; // edx
  signed __int32 v28; // ebx
  signed __int32 v29; // et0
  char v30; // al
  signed __int32 v31; // et1
  signed __int32 v32; // eax
  int v34; // eax
  _BYTE *v35; // eax
  _BYTE *v36; // eax
  _BYTE *v37; // eax
  signed __int32 v42; // [esp-10h] [ebp-20h]
  unsigned __int32 v43; // [esp-Ah] [ebp-1Ah]
  _BYTE *v44; // [esp+8h] [ebp-8h]
  unsigned int i; // [esp+Ch] [ebp-4h]

  v44 = a4;
  for ( i = 0; ; ++i )
  {
    _CF = i < a5;
    _OF = __OFSUB__(i, a5);
    _ZF = i == a5;
    _SF = (signed int)(i - a5) < 0;
    if ( i >= a5 )
      break;
    __asm { pushfw }
    v5 = _InterlockedExchange(&dword_805D1C0, a3);
    v8 = _InterlockedExchange(&dword_805D1C0, a1);
    v6 = v5;
    v7 = v8;
    v43 = sub_8054904(
            i < a5,
            i == a5,
            (signed int)(i - a5) < 0,
            __OFSUB__(i, a5),
            _InterlockedExchange(&dword_805D1C0, v6),
            a2,
            v8);
    __asm { pushfw }
    v42 = v8;
    if ( v8 >= 10 )
    {
      v11 = _InterlockedExchange(&dword_805D124, v7);
      v10 = _InterlockedExchange(&dword_805D124, a2);
      a2 = _InterlockedExchange(&dword_805D124, v11);
      if ( ((_BYTE)v7 - 1) * v10 & 1 )
        abort();
    }
    __asm
    {
      popfw
      pushfw
    }
    if ( v42 >= 10 )
    {
      v13 = _InterlockedExchange(&dword_805D19C, v42);
      v12 = _InterlockedExchange(&dword_805D19C, a2);
      a2 = _InterlockedExchange(&dword_805D19C, v13);
      if ( ((_BYTE)v42 - 1) * v12 & 1 )
        abort();
    }
    a3 = v42;
    __asm { popfw }
    _CF = v43 < 0x28F;
    _OF = __OFSUB__(v43, 655);
    _ZF = v43 == 655;
    _SF = (signed int)(v43 - 655) < 0;
    if ( v43 != 655 )
    {
      __asm { pushfw }
      _CF = (unsigned int)v42 < 0xA;
      _OF = __OFSUB__(v42, 10);
      _ZF = v42 == 10;
      _SF = v42 - 10 < 0;
      if ( v42 >= 10 )
      {
        __asm { pushfw }
        v22 = _InterlockedExchange(&dword_805D16C, v42);
        v25 = _InterlockedExchange(&dword_805D16C, v9);
        v23 = v22;
        v24 = v25;
        _InterlockedExchange(&dword_805D16C, v23);
        v26 = sub_804C738();
        if ( v26 != 907 )
        {
          v28 = _InterlockedExchange(&dword_805D16C, v24);
          v29 = _InterlockedExchange(&dword_805D16C, a2);
          _InterlockedExchange(&dword_805D16C, v28);
          sub_804C742(v26 < 0x38B, v26 == 907, (signed int)(v26 - 907) < 0, __OFSUB__(v26, 907), v26, v27, v29);
        }
        __asm { popfw }
        v31 = _InterlockedExchange(&dword_805D190, v24);
        v30 = _InterlockedExchange(&dword_805D190, v27);
        v9 = _InterlockedExchange(&dword_805D190, v31);
        if ( ((_BYTE)v24 - 1) * v30 & 1 )
          abort();
      }
      __asm { popfw }
      v32 = _InterlockedExchange(&dword_805D1C0, v43);
      _InterlockedExchange(&dword_805D1C0, v9);
      _InterlockedExchange(&dword_805D1C0, v32);
      sub_8054A34(_CF, _ZF, _SF, _OF, a2, v42);
    }
    __asm { popfw }
    if ( !a4[i] )
      return 0;
    if ( a4[i] == 92 )
    {
      if ( a5 - 1 == i )
        return 0;
      v34 = (char)a4[++i];
      if ( v34 == 92 )
      {
        v36 = v44;
        a1 = (signed __int32)(v44++ + 1);
        *v36 = 92;
      }
      else
      {
        if ( v34 != 110 )
          return 0;
        v35 = v44;
        a1 = (signed __int32)(v44++ + 1);
        *v35 = 10;
      }
    }
    else
    {
      v37 = v44++;
      a2 = (signed __int32)a4;
      a1 = (unsigned __int8)a4[i];
      *v37 = a1;
    }
  }
  if ( &a4[a5] > v44 )
    *v44 = 0;
  return a4;
}
// 805D124: using guessed type int dword_805D124;
// 805D16C: using guessed type int dword_805D16C;
// 805D190: using guessed type int dword_805D190;
// 805D19C: using guessed type int dword_805D19C;
// 805D1C0: using guessed type int dword_805D1C0;

//----- (0804D497) --------------------------------------------------------
bool __usercall sub_804D497@<al>(signed __int32 a1@<ebx>, _BYTE *a2)
{
  const unsigned __int16 **v2; // eax
  signed __int32 v3; // ecx
  signed __int32 v4; // eax
  unsigned int v5; // eax
  signed __int32 v6; // edx
  signed __int32 v7; // ecx
  signed __int32 v9; // edx
  int v10; // eax
  unsigned int i; // [esp+Ch] [ebp-Ch]

  for ( i = 0; ; ++i )
  {
    if ( i >= dword_805D7D6 )
      return *a2 == 0;
    v2 = __ctype_b_loc();
    v9 = (signed __int32)*v2;
    v10 = (*v2)[(unsigned __int8)*a2] & 0x1000;
    _CF = 0;
    _OF = 0;
    _ZF = v10 == 0;
    _SF = v10 < 0;
    if ( !v10 )
      break;
    ++a2;
  }
  __asm { pushfw }
  v4 = _InterlockedExchange(&dword_805D184, 0);
  _InterlockedExchange(&dword_805D184, v3);
  v5 = sub_804C065(0, _ZF, _SF, 0, v9, _InterlockedExchange(&dword_805D184, v4), a1);
  if ( v5 != 300 )
    sub_804C18B(
      v5 < 0x12C,
      v5 == 300,
      (signed int)(v5 - 300) < 0,
      __OFSUB__(v5, 300),
      v6,
      _InterlockedExchange(&dword_805D184, _InterlockedExchange(&dword_805D184, a1)),
      _InterlockedExchange(&dword_805D184, v7));
  __asm { popfw }
  return 0;
}
// 805D184: using guessed type int dword_805D184;
// 805D7D6: using guessed type int dword_805D7D6;

//----- (0804D5FA) --------------------------------------------------------
bool __usercall sub_804D5FA@<al>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, _BYTE *a8, int a9, _BYTE **a10, _DWORD *a11, char a12)
{
  signed __int32 v12; // eax
  signed __int32 v13; // edx
  signed __int32 v14; // ecx
  signed __int32 v15; // ebx
  signed __int32 v17; // edx
  char v18; // al
  signed __int32 v19; // et2
  unsigned int v20; // eax
  char v21; // al
  signed __int32 v22; // ebx
  char v23; // tt
  unsigned __int8 v24; // al
  unsigned __int8 v29; // al
  signed __int32 v30; // [esp-Ah] [ebp-36h]
  _BYTE *v31; // [esp-4h] [ebp-30h]
  unsigned int i; // [esp+1Ch] [ebp-10h]
  int v33; // [esp+1Ch] [ebp-10h]
  int j; // [esp+1Ch] [ebp-10h]

  __asm { pushfw }
  v12 = _InterlockedExchange(&dword_805D160, a5);
  _InterlockedExchange(&dword_805D160, a6);
  _InterlockedExchange(&dword_805D160, v12);
  if ( sub_804F071() != -48 )
  {
    v15 = _InterlockedExchange(&dword_805D160, a7);
    _InterlockedExchange(&dword_805D160, v13);
    sub_804F07B(v14, _InterlockedExchange(&dword_805D160, v15));
  }
  __asm { popfw }
  if ( !a9 )
    return 0;
  for ( i = a9 - 1; i && a8[i] != 41; --i )
    ;
  if ( a8[i] != 41 )
    return 0;
  *a11 = a8;
  if ( a12 )
  {
    v31 = sub_804D2B0((signed __int32)a8, v14, a7, a8, i);
    __asm { pushfw }
    if ( a7 >= 10 )
    {
      v19 = _InterlockedExchange(&dword_805D160, a7);
      v18 = _InterlockedExchange(&dword_805D160, v17);
      _InterlockedExchange(&dword_805D160, v19);
      if ( ((_BYTE)a7 - 1) * v18 & 1 )
        abort();
    }
    __asm { popfw }
    if ( !v31 )
      return 0;
  }
  v20 = i;
  v33 = i + 1;
  a8[v20] = 0;
  while ( a8[v33] == 32 || a8[v33] == 9 )
    ++v33;
  if ( a8[v33] != 61 )
    return 0;
  for ( j = v33 + 1; ; ++j )
  {
    v24 = a8[j];
    _CF = v24 < 0x20u;
    _OF = __OFSUB__(v24, 32);
    _ZF = v24 == 32;
    _SF = (char)(v24 - 32) < 0;
    if ( v24 != 32 )
    {
      v29 = a8[j];
      _CF = v29 < 9u;
      _OF = __OFSUB__(v29, 9);
      _ZF = v29 == 9;
      _SF = (char)(v29 - 9) < 0;
      if ( v29 != 9 )
        break;
    }
    __asm { pushfw }
    v30 = a7;
    if ( a7 >= 10 )
    {
      v21 = a7;
      v22 = _InterlockedExchange(&dword_805D10C, a7);
      v23 = _InterlockedExchange(&dword_805D10C, v14);
      v14 = _InterlockedExchange(&dword_805D10C, v22);
      if ( (v23 - 1) * v21 & 1 )
        abort();
    }
    a7 = v30;
    __asm { popfw }
  }
  *a10 = &a8[j];
  return sub_804D497(a7, *a10);
}
// 804D5FA: could not find valid save-restore pair for ebp
// 804F07B: using guessed type int __fastcall sub_804F07B(_DWORD, _DWORD);
// 805D10C: using guessed type int dword_805D10C;
// 805D160: using guessed type int dword_805D160;

//----- (0804D7B5) --------------------------------------------------------
char __usercall sub_804D7B5@<al>(signed __int32 a1@<ebx>, signed __int32 a2, int a3, _BYTE **a4, _DWORD *a5, _DWORD *a6)
{
  int v7; // eax
  signed __int32 v8; // eax
  signed __int32 v9; // eax
  signed __int32 v10; // edx
  unsigned __int32 v11; // eax
  signed __int32 v12; // edx
  signed __int32 v13; // ecx
  signed __int32 v18; // eax
  signed __int32 v19; // edx
  signed __int32 v20; // eax
  signed __int32 v29; // eax
  unsigned __int32 v30; // eax
  signed __int32 v31; // ecx
  signed __int32 v32; // eax
  unsigned __int32 v33; // eax
  signed __int32 v34; // edx
  signed __int32 v35; // ebx
  signed __int32 v36; // et1
  char v41; // al
  signed __int32 v42; // et2
  int v43; // eax
  signed __int32 v48; // ebx
  signed __int32 v49; // ecx
  signed __int32 v50; // ebx
  signed __int32 v51; // ett
  signed __int32 v52; // edx
  signed __int32 v53; // ecx
  char v54; // al
  signed __int32 v55; // ebx
  char v56; // t0
  signed __int32 v57; // eax
  signed __int32 v58; // [esp-10h] [ebp-48h]
  unsigned __int32 v59; // [esp-Ah] [ebp-42h]
  char v60; // [esp-4h] [ebp-3Ch]
  char v61; // [esp+27h] [ebp-11h]
  int i; // [esp+28h] [ebp-10h]
  int v63; // [esp+28h] [ebp-10h]
  int v64; // [esp+28h] [ebp-10h]
  int v65; // [esp+28h] [ebp-10h]

  v61 = 0;
  for ( i = 0; *(_BYTE *)(a2 + i) == 32 || *(_BYTE *)(a2 + i) == 9; ++i )
    ;
  if ( *(_BYTE *)(a2 + i) == 92 )
  {
    ++i;
    v61 = 1;
  }
  if ( !strncmp((const char *)(i + a2), "MD5", 3u) )
  {
    v63 = i + 3;
    if ( *(_BYTE *)(a2 + v63) == 32 )
      ++v63;
    if ( *(_BYTE *)(a2 + v63) != 40 )
      return 0;
    *a5 = 0;
    return sub_804D5FA(
             __CFADD__(a2, v63 + 1),
             a2 + v63 + 1 == 0,
             a2 + v63 + 1 < 0,
             __OFADD__(a2, v63 + 1),
             (signed __int32)a4,
             a3 - (v63 + 1),
             a2,
             (_BYTE *)(a2 + v63 + 1),
             a3 - (v63 + 1),
             a4,
             a6,
             v61);
  }
  if ( a3 - i < (unsigned int)(*(_BYTE *)(a2 + i) == 92) + dword_805D7D2 )
    return 0;
  *a4 = (_BYTE *)(i + a2);
  v64 = dword_805D7D6 + i;
  if ( *(_BYTE *)(a2 + v64) != 32 && *(_BYTE *)(a2 + v64) != 9 )
    return 0;
  v7 = v64;
  v65 = v64 + 1;
  *(_BYTE *)(a2 + v7) = 0;
  LOBYTE(v8) = sub_804D497(a1, *a4);
  v60 = v8;
  __asm { pushfw }
  v9 = _InterlockedExchange(&dword_805D118, v8);
  _InterlockedExchange(&dword_805D118, v10);
  _InterlockedExchange(&dword_805D118, v9);
  v11 = sub_804B6EB();
  _CF = v11 < 0xFFFFFC6C;
  _OF = __OFSUB__(v11, -916);
  _ZF = v11 == -916;
  _SF = (signed int)(v11 + 916) < 0;
  if ( v11 != -916 )
  {
    v18 = _InterlockedExchange(&dword_805D118, v11);
    _InterlockedExchange(&dword_805D118, v12);
    sub_804B6F5(_CF, _ZF, _SF, _OF, _InterlockedExchange(&dword_805D118, v18), a1);
  }
  __asm { popfw }
  if ( v60 != 1 )
    return 0;
  v19 = a3 - v65;
  if ( a3 - v65 == 1 )
    goto LABEL_47;
  v20 = *(unsigned __int8 *)(a2 + v65);
  _CF = (unsigned __int8)v20 < 0x20u;
  _OF = __OFSUB__((_BYTE)v20, 32);
  _ZF = (_BYTE)v20 == 32;
  _SF = (char)(v20 - 32) < 0;
  if ( (_BYTE)v20 == 32
    || (v19 = a2,
        v20 = *(unsigned __int8 *)(a2 + v65),
        _CF = (unsigned __int8)v20 < 0x2Au,
        _OF = __OFSUB__((_BYTE)v20, 42),
        _ZF = (_BYTE)v20 == 42,
        _SF = (char)(v20 - 42) < 0,
        (_BYTE)v20 == 42) )
  {
    __asm { pushfw }
    v32 = _InterlockedExchange(&dword_805D1B4, v20);
    _InterlockedExchange(&dword_805D1B4, v13);
    _InterlockedExchange(&dword_805D1B4, v32);
    v33 = sub_8056BAD();
    if ( v33 != 702 )
    {
      v35 = _InterlockedExchange(&dword_805D1B4, a1);
      v36 = _InterlockedExchange(&dword_805D1B4, v34);
      _InterlockedExchange(&dword_805D1B4, v35);
      sub_8056BB7(v33 < 0x2BE, v33 == 702, (signed int)(v33 - 702) < 0, __OFSUB__(v33, 702), v33, v13, v36);
    }
    __asm { popfw }
    _CF = (unsigned int)dword_805D1E4 < 1;
    _OF = __OFSUB__(dword_805D1E4, 1);
    _ZF = dword_805D1E4 == 1;
    _SF = dword_805D1E4 - 1 < 0;
    if ( dword_805D1E4 != 1 )
    {
      __asm { pushfw }
      if ( a1 >= 10 )
      {
        v42 = _InterlockedExchange(&dword_805D10C, a1);
        v41 = _InterlockedExchange(&dword_805D10C, v34);
        _InterlockedExchange(&dword_805D10C, v42);
        if ( ((_BYTE)a1 - 1) * v41 & 1 )
          abort();
      }
      __asm { popfw }
      dword_805D1E4 = 0;
      v43 = v65++;
      *a5 = *(_BYTE *)(a2 + v43) == 42;
    }
  }
  else
  {
LABEL_47:
    _CF = 0;
    _OF = 0;
    _ZF = dword_805D1E4 == 0;
    _SF = dword_805D1E4 < 0;
    if ( !dword_805D1E4 )
    {
      __asm { pushfw }
      v29 = _InterlockedExchange(&dword_805D148, dword_805D1E4);
      _InterlockedExchange(&dword_805D148, v19);
      _InterlockedExchange(&dword_805D148, v29);
      v30 = sub_80550FF();
      if ( v30 != 180 )
        sub_8055109(
          v30 < 0xB4,
          v30 == 180,
          (signed int)(v30 - 180) < 0,
          __OFSUB__(v30, 180),
          _InterlockedExchange(&dword_805D148, v31),
          _InterlockedExchange(&dword_805D148, _InterlockedExchange(&dword_805D148, v30)),
          a1);
      __asm { popfw }
      return 0;
    }
    dword_805D1E4 = 1;
  }
  *a6 = v65 + a2;
  _CF = 0;
  _OF = 0;
  _ZF = v61 == 0;
  _SF = v61 < 0;
  if ( !v61 )
    return 1;
  __asm { pushfw }
  v48 = _InterlockedExchange(&dword_805D1C0, a1);
  v51 = _InterlockedExchange(&dword_805D1C0, v13);
  v49 = v48;
  v50 = v51;
  v59 = sub_8054904(0, v61 == 0, v61 < 0, 0, v65 + a2, _InterlockedExchange(&dword_805D1C0, v49), v51);
  __asm { pushfw }
  v58 = v51;
  if ( v51 >= 10 )
  {
    v54 = v50;
    v55 = _InterlockedExchange(&dword_805D178, v50);
    v56 = _InterlockedExchange(&dword_805D178, v52);
    _InterlockedExchange(&dword_805D178, v55);
    if ( (v56 - 1) * v54 & 1 )
      abort();
  }
  __asm { popfw }
  if ( v59 != 655 )
  {
    v57 = _InterlockedExchange(&dword_805D1C0, v59);
    _InterlockedExchange(&dword_805D1C0, v53);
    sub_8054A34(
      v59 < 0x28F,
      v59 == 655,
      (signed int)(v59 - 655) < 0,
      __OFSUB__(v59, 655),
      _InterlockedExchange(&dword_805D1C0, v57),
      v58);
  }
  __asm { popfw }
  return sub_804D2B0(a3 - v65, a2, v58, (_BYTE *)(a2 + v65), a3 - v65) != 0;
}
// 805D10C: using guessed type int dword_805D10C;
// 805D118: using guessed type int dword_805D118;
// 805D148: using guessed type int dword_805D148;
// 805D178: using guessed type int dword_805D178;
// 805D1B4: using guessed type int dword_805D1B4;
// 805D1C0: using guessed type int dword_805D1C0;
// 805D1E4: using guessed type int dword_805D1E4;
// 805D7D2: using guessed type int dword_805D7D2;
// 805D7D6: using guessed type int dword_805D7D6;

//----- (0804DB65) --------------------------------------------------------
signed __int32 __usercall sub_804DB65@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, char *a4, char a5)
{
  char v9; // al
  signed __int32 v10; // ebx
  char v11; // t0
  signed __int32 result; // eax
  signed __int32 v13; // eax
  unsigned __int32 v14; // eax
  signed __int32 v15; // edx
  signed __int32 v16; // ecx
  bool v17; // cf
  bool v18; // zf
  bool v19; // sf
  char v20; // of
  signed __int32 v21; // eax
  unsigned __int32 v22; // eax
  signed __int32 v27; // eax
  unsigned int v28; // eax
  signed __int32 v29; // edx
  signed __int32 v30; // ecx
  signed __int32 v31; // ebx
  signed __int32 v32; // et0

  _CF = 0;
  _OF = 0;
  _ZF = a5 == 1;
  _SF = ((a5 ^ 1) & 0x80u) != 0;
  if ( a5 == 1 )
  {
    while ( 1 )
    {
      result = (unsigned __int8)*a4;
      _CF = 0;
      _OF = 0;
      _ZF = (_BYTE)result == 0;
      _SF = (result & 0x80u) != 0;
      if ( !(_BYTE)result )
        break;
      __asm { pushfw }
      v13 = _InterlockedExchange(&dword_805D184, result);
      _InterlockedExchange(&dword_805D184, a2);
      v14 = sub_804C065(0, _ZF, _SF, 0, a1, _InterlockedExchange(&dword_805D184, v13), a3);
      v17 = v14 < 0x12C;
      v20 = __OFSUB__(v14, 300);
      v18 = v14 == 300;
      v19 = (signed int)(v14 - 300) < 0;
      if ( v14 != 300 )
      {
        v21 = _InterlockedExchange(&dword_805D184, v14);
        _InterlockedExchange(&dword_805D184, v15);
        sub_804C18B(v17, v18, v19, v20, _InterlockedExchange(&dword_805D184, v21), v16, a3);
      }
      __asm { popfw }
      v22 = *a4;
      if ( v22 == 10 )
      {
        fwrite_unlocked("\\n", 1u, 2u, stdout);
      }
      else
      {
        _CF = v22 < 0x5C;
        _OF = __OFSUB__(v22, 92);
        _ZF = v22 == 92;
        _SF = (signed int)(v22 - 92) < 0;
        if ( v22 == 92 )
        {
          fwrite_unlocked("\\\\", 1u, 2u, stdout);
        }
        else
        {
          __asm { pushfw }
          v27 = _InterlockedExchange(&dword_805D178, v22);
          _InterlockedExchange(&dword_805D178, v16);
          _InterlockedExchange(&dword_805D178, v27);
          v28 = sub_804A5EF();
          if ( v28 != 421 )
          {
            v31 = _InterlockedExchange(&dword_805D178, a3);
            v32 = _InterlockedExchange(&dword_805D178, v30);
            _InterlockedExchange(&dword_805D178, v31);
            sub_804A5F9(v28 < 0x1A5, v28 == 421, (signed int)(v28 - 421) < 0, __OFSUB__(v28, 421), v29, v32);
          }
          __asm { popfw }
          putchar_unlocked(*a4);
        }
      }
      ++a4;
    }
  }
  else
  {
    __asm { pushfw }
    if ( a3 >= 10 )
    {
      v9 = a3;
      v10 = _InterlockedExchange(&dword_805D1C0, a3);
      v11 = _InterlockedExchange(&dword_805D1C0, a2);
      _InterlockedExchange(&dword_805D1C0, v10);
      if ( (v11 - 1) * v9 & 1 )
        abort();
    }
    __asm { popfw }
    result = fputs_unlocked(a4, stdout);
  }
  return result;
}
// 8048F20: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 805D178: using guessed type int dword_805D178;
// 805D184: using guessed type int dword_805D184;
// 805D1C0: using guessed type int dword_805D1C0;

//----- (0804DCE9) --------------------------------------------------------
int __usercall sub_804DCE9@<eax>(signed __int32 a1@<ebx>, char *s1, int a3, int a4, int a5)
{
  signed __int32 v5; // ecx
  signed __int32 v10; // ebx
  signed __int32 v11; // ecx
  signed __int32 v12; // ebx
  signed __int32 v13; // et0
  unsigned __int32 v14; // eax
  signed __int32 v15; // edx
  bool v16; // cf
  bool v17; // zf
  bool v18; // sf
  char v19; // of
  signed __int32 v20; // eax
  int result; // eax
  void *v22; // ebx
  int *v23; // eax
  char v24; // al
  signed __int32 v25; // ebx
  char v26; // t2
  signed __int32 v27; // ecx
  void *v28; // ebx
  int *v29; // eax
  signed __int32 v30; // ecx
  char v35; // al
  signed __int32 v36; // ett
  void *v37; // ebx
  int *v38; // eax
  signed __int32 v39; // [esp-Ah] [ebp-32h]
  bool v40; // [esp+17h] [ebp-11h]
  FILE *stream; // [esp+18h] [ebp-10h]
  int savedregs; // [esp+28h] [ebp+0h]

  v40 = strcmp(s1, "-") == 0;
  *(_BYTE *)a5 = 0;
  _CF = 0;
  _OF = 0;
  _ZF = v40 == 0;
  _SF = v40 < 0;
  if ( v40 )
  {
    byte_805D7CE = 1;
    stream = (FILE *)stdin;
    goto LABEL_10;
  }
  stream = (FILE *)sub_8050E96(s1, "r");
  _CF = 0;
  _OF = 0;
  _ZF = stream == 0;
  _SF = (signed int)stream < 0;
  if ( stream )
  {
LABEL_10:
    __asm { pushfw }
    v39 = a1;
    if ( a1 >= 10 )
    {
      v24 = a1;
      v25 = _InterlockedExchange(&dword_805D148, a1);
      v26 = _InterlockedExchange(&dword_805D148, v5);
      v5 = _InterlockedExchange(&dword_805D148, v25);
      if ( (v26 - 1) * v24 & 1 )
        abort();
    }
    __asm { popfw }
    sub_8050BA4(_CF, _ZF, _SF, _OF, (int)stream, v5, v39, (int)&savedregs, stream, 2);
    if ( sub_804F794(v39, stream, a4) )
    {
      v28 = sub_80535C8(v39, 0, 3u, (signed __int32)s1);
      v29 = __errno_location();
      error(0, *v29, "%s", v28);
      _CF = (unsigned int)stream < stdin;
      _OF = __OFSUB__(stream, stdin);
      _ZF = stream == (FILE *)stdin;
      _SF = (signed int)stream - stdin < 0;
      if ( stream != (FILE *)stdin )
        sub_8055264(
          (unsigned int)stream < stdin,
          stream == (FILE *)stdin,
          (signed int)stream - stdin < 0,
          __OFSUB__(stream, stdin),
          (signed __int32)stream,
          v30,
          (signed __int32)v28,
          stream);
      __asm { pushfw }
      if ( (signed int)v28 >= 10 )
      {
        v36 = _InterlockedExchange(&dword_805D16C, (signed __int32)v28);
        v35 = _InterlockedExchange(&dword_805D16C, v30);
        _InterlockedExchange(&dword_805D16C, v36);
        if ( ((_BYTE)v28 - 1) * v35 & 1 )
          abort();
      }
      __asm { popfw }
      result = 0;
    }
    else if ( v40 != 1 && sub_8055264(0, v40 == 1, !v40 < 0, 0, (signed __int32)stream, v27, v39, stream) )
    {
      v37 = sub_80535C8(v39, 0, 3u, (signed __int32)s1);
      v38 = __errno_location();
      error(0, *v38, "%s", v37);
      result = 0;
    }
    else
    {
      result = 1;
    }
    return result;
  }
  __asm { pushfw }
  v10 = _InterlockedExchange(&dword_805D178, a1);
  v13 = _InterlockedExchange(&dword_805D178, v5);
  v11 = v10;
  v12 = v13;
  _InterlockedExchange(&dword_805D178, v11);
  v14 = sub_804A5EF();
  v16 = v14 < 0x1A5;
  v19 = __OFSUB__(v14, 421);
  v17 = v14 == 421;
  v18 = (signed int)(v14 - 421) < 0;
  if ( v14 != 421 )
  {
    v20 = _InterlockedExchange(&dword_805D178, v14);
    _InterlockedExchange(&dword_805D178, v15);
    sub_804A5F9(v16, v17, v18, v19, _InterlockedExchange(&dword_805D178, v20), v12);
  }
  __asm { popfw }
  if ( byte_805D7DC && *__errno_location() == 2 )
  {
    *(_BYTE *)a5 = 1;
    result = 1;
  }
  else
  {
    v22 = sub_80535C8(v12, 0, 3u, (signed __int32)s1);
    v23 = __errno_location();
    error(0, *v23, "%s", v22);
    result = 0;
  }
  return result;
}
// 8050E96: using guessed type int __cdecl sub_8050E96(_DWORD, _DWORD);
// 805D148: using guessed type int dword_805D148;
// 805D16C: using guessed type int dword_805D16C;
// 805D178: using guessed type int dword_805D178;
// 805D2A0: using guessed type int stdin;
// 805D7CE: using guessed type char byte_805D7CE;
// 805D7DC: using guessed type char byte_805D7DC;

//----- (0804DFA9) --------------------------------------------------------
int __usercall sub_804DFA9@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, void *a3@<ebx>, const char *a4)
{
  signed __int32 v4; // edx
  char v9; // al
  signed __int32 v10; // ebx
  signed __int32 v11; // et0
  int v12; // eax
  char v13; // al
  signed __int32 v14; // ebx
  char v15; // t1
  int *v16; // eax
  signed __int32 v21; // edx
  signed __int32 v22; // ecx
  int v23; // eax
  char *v24; // eax
  char *v25; // eax
  bool v26; // al
  signed __int32 v27; // edx
  int v28; // ecx
  char *v29; // eax
  int v30; // eax
  int v31; // eax
  char v36; // al
  signed __int32 v37; // ebx
  char v38; // t2
  char *v39; // eax
  char *v40; // eax
  char *v41; // eax
  int *v42; // eax
  char *v43; // eax
  int v44; // eax
  char *v45; // eax
  int v46; // eax
  char *v47; // eax
  int v48; // eax
  char *v49; // eax
  char *v50; // eax
  bool v51; // al
  signed __int32 v52; // ebx
  signed __int32 v53; // edx
  signed __int32 v54; // ebx
  signed __int32 v55; // ett
  unsigned __int32 v56; // eax
  signed __int32 v57; // edx
  signed __int32 v58; // ecx
  bool v59; // cf
  bool v60; // zf
  bool v61; // sf
  char v62; // of
  signed __int32 v63; // eax
  signed __int32 v65; // [esp-Ah] [ebp-A2h]
  void *v66; // [esp-4h] [ebp-9Ch]
  int v67; // [esp-4h] [ebp-9Ch]
  char *s1; // [esp+1Ch] [ebp-7Ch]
  int v69; // [esp+22h] [ebp-76h]
  unsigned __int8 v70; // [esp+26h] [ebp-72h]
  unsigned __int8 v71; // [esp+27h] [ebp-71h]
  void *ptr; // [esp+28h] [ebp-70h]
  int v73; // [esp+2Ch] [ebp-6Ch]
  char *s; // [esp+30h] [ebp-68h]
  int v75; // [esp+34h] [ebp-64h]
  int v76; // [esp+38h] [ebp-60h]
  FILE *stream; // [esp+3Ch] [ebp-5Ch]
  int v78; // [esp+40h] [ebp-58h]
  unsigned int i; // [esp+44h] [ebp-54h]
  int v80; // [esp+48h] [ebp-50h]
  unsigned int v81; // [esp+4Ch] [ebp-4Ch]
  __int64 v82; // [esp+50h] [ebp-48h]
  __int64 v83; // [esp+58h] [ebp-40h]
  __int64 v84; // [esp+60h] [ebp-38h]
  __int64 v85; // [esp+68h] [ebp-30h]
  __int64 v86; // [esp+70h] [ebp-28h]
  char v87; // [esp+78h] [ebp-20h]
  unsigned int v88; // [esp+8Ch] [ebp-Ch]

  s1 = (char *)a4;
  v88 = __readgsdword(0x14u);
  v82 = 0LL;
  v83 = 0LL;
  v84 = 0LL;
  v85 = 0LL;
  *(_WORD *)((char *)&v69 + 1) = 0;
  v80 = sub_804CA2C(0, 1, 0, 0, (int)&v87, a1, a2, (signed __int32)a3, (int)&v87, 4u);
  HIBYTE(v69) = strcmp(a4, "-") == 0;
  if ( HIBYTE(v69) )
  {
    byte_805D7CE = 1;
    s1 = gettext("standard input");
    stream = (FILE *)stdin;
    goto LABEL_11;
  }
  stream = (FILE *)sub_8050E96(a4, "r");
  if ( stream )
  {
LABEL_11:
    v86 = 0LL;
    ptr = 0;
    v73 = 0;
    do
    {
      if ( !++v86 )
      {
        a3 = sub_80535C8((signed __int32)a3, 0, 3u, (signed __int32)s1);
        v24 = gettext("%s: too many checksum lines");
        error(1, 0, v24, a3);
      }
      v78 = getline(&ptr, &v73, stream);
      if ( v78 <= 0 )
        break;
      if ( *(_BYTE *)ptr != 35 )
      {
        if ( *((_BYTE *)ptr + v78 - 1) == 10 )
          *((_BYTE *)ptr + --v78) = 0;
        if ( (unsigned __int8)sub_804D7B5((signed __int32)a3, (signed __int32)ptr, v78, (_BYTE **)&v76, &v75, &s) ^ 1
          || HIBYTE(v69) && !strcmp(s, "-") )
        {
          ++v82;
          if ( byte_805D7DB )
          {
            a3 = sub_80535C8((signed __int32)a3, 0, 3u, (signed __int32)s1);
            v25 = gettext("%s: %llu: improperly formatted %s checksum line");
            error(0, 0, v25, a3, v86, "MD5");
          }
          ++v83;
        }
        else
        {
          v26 = byte_805D7DA != 1 && strchr(s, 10);
          v70 = v26;
          BYTE1(v69) = 1;
          v71 = sub_804DCE9((signed __int32)a3, s, (int)&v75, v80, (int)&v69);
          if ( v71 ^ 1 )
          {
            ++v85;
            if ( byte_805D7DA != 1 )
            {
              if ( v70 )
                putchar_unlocked(92);
              sub_804DB65(v70, v28, (signed __int32)a3, s, v70);
              v29 = gettext("FAILED open or read");
              printf(": %s\n", v29);
            }
          }
          else if ( !byte_805D7DC || !(_BYTE)v69 )
          {
            v81 = (unsigned int)dword_805D7D6 >> 1;
            for ( i = 0; i < v81; ++i )
            {
              v30 = tolower(*(unsigned __int8 *)(2 * i + v76));
              v28 = v80;
              v27 = byte_80588E1[(unsigned __int8)(*(_BYTE *)(v80 + i) >> 4)];
              if ( v30 != v27 )
                break;
              v31 = tolower(*(unsigned __int8 *)(2 * i + 1 + v76));
              v28 = v80;
              v27 = byte_80588E1[*(_BYTE *)(v80 + i) & 0xF];
              if ( v31 != v27 )
                break;
            }
            if ( i == v81 )
              BYTE2(v69) = 1;
            else
              ++v84;
            _CF = 0;
            _OF = 0;
            _ZF = byte_805D7DA == 1;
            _SF = ((byte_805D7DA ^ 1) & 0x80u) != 0;
            if ( byte_805D7DA != 1 )
            {
              __asm { pushfw }
              v65 = (signed __int32)a3;
              if ( (signed int)a3 >= 10 )
              {
                v36 = (char)a3;
                v37 = _InterlockedExchange(&dword_805D160, (signed __int32)a3);
                v38 = _InterlockedExchange(&dword_805D160, v27);
                _InterlockedExchange(&dword_805D160, v37);
                if ( (v38 - 1) * v36 & 1 )
                  abort();
              }
              a3 = (void *)v65;
              __asm { popfw }
              if ( i != v81 || byte_805D7DD != 1 )
              {
                if ( v70 )
                  putchar_unlocked(92);
                sub_804DB65(v70, v28, v65, s, v70);
              }
              if ( i == v81 )
              {
                if ( byte_805D7DD != 1 )
                {
                  v40 = gettext("OK");
                  printf(": %s\n", v40);
                }
              }
              else
              {
                v39 = gettext("FAILED");
                printf(": %s\n", v39);
              }
            }
          }
        }
      }
    }
    while ( !feof_unlocked(stream) && !ferror_unlocked(stream) );
    free(ptr);
    if ( ferror_unlocked(stream) )
    {
      a3 = sub_80535C8((signed __int32)a3, 0, 3u, (signed __int32)s1);
      v41 = gettext("%s: read error");
      error(0, 0, v41, a3);
      v23 = 0;
    }
    else if ( HIBYTE(v69) != 1
           && sub_8055264(
                0,
                HIBYTE(v69) == 1,
                ((HIBYTE(v69) ^ 1) & 0x80u) != 0,
                0,
                (signed __int32)stream,
                v22,
                (signed __int32)a3,
                stream) )
    {
      a3 = sub_80535C8((signed __int32)a3, 0, 3u, (signed __int32)s1);
      v42 = __errno_location();
      error(0, *v42, "%s", a3);
      v23 = 0;
    }
    else
    {
      if ( BYTE1(v69) == 1 )
      {
        if ( byte_805D7DA != 1 )
        {
          if ( v82 )
          {
            v44 = sub_804C908(SHIDWORD(v82), (signed __int32)a3, v82);
            v45 = ngettext(
                    "WARNING: %llu line is improperly formatted",
                    "WARNING: %llu lines are improperly formatted",
                    v44);
            error(0, 0, v45, v82);
          }
          if ( v85 )
          {
            v46 = sub_804C908(SHIDWORD(v85), (signed __int32)a3, v85);
            v47 = ngettext(
                    "WARNING: %llu listed file could not be read",
                    "WARNING: %llu listed files could not be read",
                    v46);
            error(0, 0, v47, v85);
          }
          v21 = HIDWORD(v84);
          if ( v84 )
          {
            v48 = sub_804C908(SHIDWORD(v84), (signed __int32)a3, v84);
            v49 = ngettext(
                    "WARNING: %llu computed checksum did NOT match",
                    "WARNING: %llu computed checksums did NOT match",
                    v48);
            error(0, 0, v49, v84);
          }
          if ( byte_805D7DC && BYTE2(v69) != 1 )
          {
            a3 = sub_80535C8((signed __int32)a3, 0, 3u, (signed __int32)s1);
            v50 = gettext("%s: no file was verified");
            error(0, 0, v50, a3);
          }
        }
      }
      else
      {
        a3 = sub_80535C8((signed __int32)a3, 0, 3u, (signed __int32)s1);
        v43 = gettext("%s: no properly formatted %s checksum lines found");
        error(0, 0, v43, a3, "MD5");
      }
      v51 = 0;
      if ( BYTE1(v69) )
      {
        if ( BYTE2(v69) )
        {
          v21 = HIDWORD(v84);
          if ( !v84 )
          {
            v21 = HIDWORD(v85);
            if ( !v85 )
            {
              if ( byte_805D7DE != 1 || (v21 = HIDWORD(v83), !v83) )
                v51 = 1;
            }
          }
        }
      }
      v23 = v51;
      _CF = 0;
      _OF = 0;
      _ZF = v23 == 0;
      _SF = v23 < 0;
    }
    goto LABEL_84;
  }
  v66 = sub_80535C8((signed __int32)a3, 0, 3u, (signed __int32)a4);
  __asm { pushfw }
  _CF = (unsigned int)a3 < 0xA;
  _OF = __OFSUB__(a3, 10);
  _ZF = a3 == (void *)10;
  _SF = (_DWORD)((_DWORD)a3 - 10) < 0;
  if ( (signed int)a3 >= 10 )
  {
    v9 = (char)a3;
    v10 = _InterlockedExchange(&dword_805D178, (signed __int32)a3);
    v11 = _InterlockedExchange(&dword_805D178, v4);
    v4 = _InterlockedExchange(&dword_805D178, v10);
    a3 = (void *)(v11 - 1);
    v12 = ((_BYTE)v11 - 1) * v9 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = v12 == 0;
    _SF = v12 < 0;
    if ( v12 )
      abort();
  }
  __asm { pushfw }
  if ( (signed int)a3 >= 10 )
  {
    v13 = (char)a3;
    v14 = _InterlockedExchange(&dword_805D130, (signed __int32)a3);
    v15 = _InterlockedExchange(&dword_805D130, v4);
    _InterlockedExchange(&dword_805D130, v14);
    if ( (v15 - 1) * v13 & 1 )
      abort();
  }
  __asm
  {
    popfw
    popfw
  }
  a3 = v66;
  v16 = __errno_location();
  error(0, *v16, "%s", v66);
  v23 = 0;
LABEL_84:
  v67 = v23;
  __asm { pushfw }
  v52 = _InterlockedExchange(&dword_805D184, (signed __int32)a3);
  v55 = _InterlockedExchange(&dword_805D184, v21);
  v53 = v52;
  v54 = v55;
  v56 = sub_804C065(_CF, _ZF, _SF, _OF, _InterlockedExchange(&dword_805D184, v53), v22, v55);
  v59 = v56 < 0x12C;
  v62 = __OFSUB__(v56, 300);
  v60 = v56 == 300;
  v61 = (signed int)(v56 - 300) < 0;
  if ( v56 != 300 )
  {
    v63 = _InterlockedExchange(&dword_805D184, v56);
    _InterlockedExchange(&dword_805D184, v57);
    sub_804C18B(v59, v60, v61, v62, _InterlockedExchange(&dword_805D184, v63), v58, v54);
  }
  __asm { popfw }
  return v67;
}
// 8048D20: using guessed type int __cdecl getline(_DWORD, _DWORD, _DWORD);
// 8050E96: using guessed type int __cdecl sub_8050E96(_DWORD, _DWORD);
// 805D130: using guessed type int dword_805D130;
// 805D160: using guessed type int dword_805D160;
// 805D178: using guessed type int dword_805D178;
// 805D184: using guessed type int dword_805D184;
// 805D2A0: using guessed type int stdin;
// 805D7CE: using guessed type char byte_805D7CE;
// 805D7D6: using guessed type int dword_805D7D6;
// 805D7DA: using guessed type char byte_805D7DA;
// 805D7DB: using guessed type char byte_805D7DB;
// 805D7DC: using guessed type char byte_805D7DC;
// 805D7DD: using guessed type char byte_805D7DD;
// 805D7DE: using guessed type char byte_805D7DE;

//----- (0804E89E) --------------------------------------------------------
_BOOL4 __usercall main@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, int argc, char **a5)
{
  signed __int32 v5; // ecx
  bool v6; // cf
  bool v7; // zf
  bool v8; // sf
  char v9; // of
  signed __int32 v10; // edx
  signed __int32 v11; // ecx
  char *v12; // eax
  char v13; // cf
  char v14; // zf
  char v15; // sf
  char v16; // of
  int v17; // eax
  signed __int32 v18; // edx
  signed __int32 v19; // ecx
  char *v20; // eax
  char v21; // cf
  char v22; // zf
  char v23; // sf
  char v24; // of
  int v25; // eax
  signed __int32 v26; // edx
  signed __int32 v27; // ecx
  char *v28; // eax
  char v29; // cf
  char v30; // zf
  char v31; // sf
  char v32; // of
  int v33; // eax
  signed __int32 v34; // edx
  signed __int32 v35; // ecx
  char *v36; // eax
  char v37; // cf
  char v38; // zf
  char v39; // sf
  char v40; // of
  int v41; // eax
  signed __int32 v42; // edx
  signed __int32 v43; // ecx
  char *v44; // eax
  char v45; // cf
  char v46; // zf
  char v47; // sf
  char v48; // of
  int v49; // eax
  signed __int32 v50; // edx
  signed __int32 v51; // ecx
  char *v52; // eax
  char v53; // cf
  char v54; // zf
  char v55; // sf
  char v56; // of
  int v57; // eax
  signed __int32 v58; // edx
  signed __int32 v59; // ecx
  char *v60; // eax
  char v61; // cf
  char v62; // zf
  char v63; // sf
  char v64; // of
  int v65; // eax
  signed __int32 v66; // edx
  signed __int32 v67; // ecx
  char *v68; // eax
  char v69; // cf
  char v70; // zf
  char v71; // sf
  char v72; // of
  int v73; // eax
  signed __int32 v74; // edx
  signed __int32 v75; // ecx
  signed __int32 v76; // edx
  bool v77; // al
  signed __int32 v78; // edx
  signed __int32 v79; // ecx
  int v80; // eax
  signed __int32 v81; // edx
  signed __int32 v82; // ecx
  char *v83; // ebx
  int *v84; // eax
  int v86; // [esp+3Fh] [ebp-45h]
  bool v87; // [esp+43h] [ebp-41h]
  int v88; // [esp+44h] [ebp-40h]
  int v89; // [esp+48h] [ebp-3Ch]
  char **v90; // [esp+4Ch] [ebp-38h]
  char **i; // [esp+50h] [ebp-34h]
  unsigned int j; // [esp+54h] [ebp-30h]
  int v93; // [esp+58h] [ebp-2Ch]
  const char *v94; // [esp+5Ch] [ebp-28h]
  unsigned int v95; // [esp+60h] [ebp-24h]
  char *v96; // [esp+64h] [ebp-20h]
  int v97; // [esp+68h] [ebp-1Ch]
  unsigned int v98; // [esp+7Ch] [ebp-8h]

  v98 = __readgsdword(0x14u);
  v93 = sub_804CA2C(0, 1, 0, 0, (int)&v97, a1, a2, a3, (int)&v97, 4u);
  *(_WORD *)((char *)&v86 + 1) = 256;
  v89 = -1;
  HIBYTE(v86) = 0;
  sub_8051013(a3, *a5);
  setlocale(6, &locale);
  bindtextdomain("coreutils", "/home/hwangdz/coreutils/coreutils-8.28/install_m32/share/locale");
  textdomain("coreutils");
  sub_8057493(v6, v7, v8, v9, v5, a3, (int)sub_804F07C);
  setvbuf(stdout, 0, 1, 0);
  v94 = "bctw";
  while ( 1 )
  {
    v95 = getopt_long(argc, a5, v94, &longopts, 0);
    if ( v95 == -1 )
      break;
    if ( v95 == 119 )
    {
      byte_805D7DA = 0;
      byte_805D7DB = 1;
      byte_805D7DD = 0;
    }
    else if ( (signed int)v95 > 119 )
    {
      if ( v95 == 130 )
      {
        byte_805D7DA = 0;
        byte_805D7DB = 0;
        byte_805D7DD = 1;
      }
      else if ( (signed int)v95 > 130 )
      {
        if ( v95 == 131 )
        {
          byte_805D7DE = 1;
        }
        else
        {
          v6 = v95 < 0x84;
          v9 = __OFSUB__(v95, 132);
          v7 = v95 == 132;
          v8 = (signed int)(v95 - 132) < 0;
          if ( v95 != 132 )
            goto LABEL_32;
          HIBYTE(v86) = 1;
          v89 = 1;
        }
      }
      else if ( v95 == 128 )
      {
        byte_805D7DC = 1;
      }
      else
      {
        v6 = v95 < 0x81;
        v9 = __OFSUB__(v95, 129);
        v7 = v95 == 129;
        v8 = (signed int)(v95 - 129) < 0;
        if ( v95 != 129 )
          goto LABEL_32;
        byte_805D7DA = 1;
        byte_805D7DB = 0;
        byte_805D7DD = 0;
      }
    }
    else if ( v95 == 98 )
    {
      v89 = 1;
    }
    else
    {
      if ( (signed int)v95 <= 98 )
      {
        if ( v95 == -131 )
        {
          sub_8054682(
            off_805D1E8,
            a3,
            stdout,
            (int)"md5sum",
            (int)"GNU coreutils",
            off_805D1E8,
            "Ulrich Drepper",
            "Scott Miller",
            "David Madore",
            0);
          exit(0);
        }
        v6 = v95 < 0xFFFFFF7E;
        v9 = __OFSUB__(v95, -130);
        v7 = v95 == -130;
        v8 = (signed int)(v95 + 130) < 0;
        if ( v95 == -130 )
          sub_804CF43(
            v95 < 0xFFFFFF7E,
            v95 == -130,
            (signed int)(v95 + 130) < 0,
            __OFSUB__(v95, -130),
            -130,
            v10,
            v11,
            a3,
            0);
LABEL_32:
        sub_804CF43(v6, v7, v8, v9, v95, v10, v11, a3, 1);
      }
      if ( v95 == 99 )
      {
        BYTE1(v86) = 1;
      }
      else
      {
        v6 = v95 < 0x74;
        v9 = __OFSUB__(v95, 116);
        v7 = v95 == 116;
        v8 = (signed int)(v95 - 116) < 0;
        if ( v95 != 116 )
          goto LABEL_32;
        v89 = 0;
      }
    }
  }
  dword_805D7D2 = 34;
  dword_805D7D6 = 32;
  if ( HIBYTE(v86) && !v89 )
  {
    v12 = gettext("--tag does not support --text mode");
    error(0, 0, v12);
    sub_804CF43(v13, v14, v15, v16, v17, v18, v19, a3, 1);
  }
  if ( HIBYTE(v86) && BYTE1(v86) )
  {
    v20 = gettext("the --tag option is meaningless when verifying checksums");
    error(0, 0, v20);
    sub_804CF43(v21, v22, v23, v24, v25, v26, v27, a3, 1);
  }
  if ( v89 >= 0 && BYTE1(v86) )
  {
    v28 = gettext("the --binary and --text options are meaningless when verifying checksums");
    error(0, 0, v28);
    sub_804CF43(v29, v30, v31, v32, v33, v34, v35, a3, 1);
  }
  if ( byte_805D7DC && BYTE1(v86) != 1 )
  {
    v36 = gettext("the --ignore-missing option is meaningful only when verifying checksums");
    error(0, 0, v36);
    sub_804CF43(v37, v38, v39, v40, v41, v42, v43, a3, 1);
  }
  if ( byte_805D7DA && BYTE1(v86) != 1 )
  {
    v44 = gettext("the --status option is meaningful only when verifying checksums");
    error(0, 0, v44);
    sub_804CF43(v45, v46, v47, v48, v49, v50, v51, a3, 1);
  }
  if ( byte_805D7DB && BYTE1(v86) != 1 )
  {
    v52 = gettext("the --warn option is meaningful only when verifying checksums");
    error(0, 0, v52);
    sub_804CF43(v53, v54, v55, v56, v57, v58, v59, a3, 1);
  }
  if ( byte_805D7DD && BYTE1(v86) != 1 )
  {
    v60 = gettext("the --quiet option is meaningful only when verifying checksums");
    error(0, 0, v60);
    sub_804CF43(v61, v62, v63, v64, v65, v66, v67, a3, 1);
  }
  if ( (unsigned __int8)byte_805D7DE & (unsigned __int8)(BYTE1(v86) ^ 1) )
  {
    v68 = gettext("the --strict option is meaningful only when verifying checksums");
    error(0, 0, v68);
    sub_804CF43(v69, v70, v71, v72, v73, v74, v75, a3, 1);
  }
  if ( v89 < 0 )
    v89 = 0;
  v90 = &a5[argc];
  if ( optind == argc )
  {
    a3 = (signed __int32)v90;
    ++v90;
    *(_DWORD *)a3 = sub_804CF3B((int)"-");
  }
  v76 = 4 * optind;
  for ( i = &a5[optind]; i < v90; ++i )
  {
    v96 = *i;
    if ( BYTE1(v86) )
    {
      a3 = BYTE2(v86);
      BYTE2(v86) = (unsigned __int8)(a3 & sub_804DFA9(v76, v11, (void *)BYTE2(v86), v96)) != 0;
    }
    else
    {
      v88 = v89;
      if ( (unsigned __int8)sub_804DCE9(a3, v96, (int)&v88, v93, (int)&v86) ^ 1 )
      {
        BYTE2(v86) = 0;
      }
      else
      {
        v77 = strchr(v96, 92) || strchr(v96, 10);
        v87 = v77;
        if ( HIBYTE(v86) )
        {
          if ( v87 )
            putchar_unlocked(92);
          fwrite_unlocked("MD5", 1u, 3u, stdout);
          fwrite_unlocked(" (", 1u, 2u, stdout);
          sub_804DB65(v78, v79, a3, v96, v87);
          fwrite_unlocked(") = ", 1u, 4u, stdout);
        }
        if ( HIBYTE(v86) != 1 && v87 )
          putchar_unlocked(92);
        for ( j = 0; (unsigned int)dword_805D7D6 >> 1 > j; ++j )
          printf("%02x", *(unsigned __int8 *)(v93 + j));
        if ( HIBYTE(v86) != 1 )
        {
          putchar_unlocked(32);
          if ( v88 )
            v80 = 42;
          else
            v80 = 32;
          putchar_unlocked(v80);
          sub_804DB65(v81, v82, a3, v96, v87);
        }
        putchar_unlocked(10);
      }
    }
  }
  if ( byte_805D7CE && sub_8055264(0, byte_805D7CE == 0, byte_805D7CE < 0, 0, stdin, v11, a3, (FILE *)stdin) == -1 )
  {
    v83 = gettext("standard input");
    v84 = __errno_location();
    error(1, *v84, v83);
  }
  return BYTE2(v86) == 0;
}
// 805D280: using guessed type int optind;
// 805D2A0: using guessed type int stdin;
// 805D7CE: using guessed type char byte_805D7CE;
// 805D7D2: using guessed type int dword_805D7D2;
// 805D7D6: using guessed type int dword_805D7D6;
// 805D7DA: using guessed type char byte_805D7DA;
// 805D7DB: using guessed type char byte_805D7DB;
// 805D7DC: using guessed type char byte_805D7DC;
// 805D7DD: using guessed type char byte_805D7DD;
// 805D7DE: using guessed type char byte_805D7DE;

//----- (0804F071) --------------------------------------------------------
signed int sub_804F071()
{
  return -48;
}

//----- (0804F07C) --------------------------------------------------------
signed __int32 __usercall sub_804F07C@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>)
{
  signed __int32 v2; // eax
  signed __int32 v3; // ecx
  unsigned int v8; // eax
  signed __int32 v9; // ecx
  void *v10; // eax
  signed __int32 v11; // ecx
  signed __int32 v12; // edx
  unsigned __int32 v13; // eax
  signed __int32 v14; // edx
  signed __int32 v15; // ecx
  bool v16; // cf
  bool v17; // zf
  bool v18; // sf
  char v19; // of
  signed __int32 v20; // eax
  int *v21; // eax
  int *v22; // eax
  signed __int32 result; // eax
  void *v24; // [esp-4h] [ebp-3Ch]
  char *v25; // [esp+2Ch] [ebp-Ch]

  v2 = sub_8055FB0(0, 0, _SF, 0, a1, a2, stdout);
  _CF = 0;
  _OF = 0;
  _ZF = v2 == 0;
  _SF = v2 < 0;
  if ( v2 )
  {
    if ( byte_805D7E6 != 1
      || (v8 = *__errno_location(),
          _CF = v8 < 0x20,
          _OF = __OFSUB__(v8, 32),
          _ZF = v8 == 32,
          _SF = (signed int)(v8 - 32) < 0,
          v8 != 32) )
    {
      v25 = gettext("write error");
      if ( dword_805D7E2 )
      {
        v10 = sub_805349E(v9, a2, dword_805D7E2);
        v24 = v10;
        __asm { pushfw }
        v13 = sub_804B1D3(
                _CF,
                _ZF,
                _SF,
                _OF,
                _InterlockedExchange(&dword_805D154, v11),
                v12,
                _InterlockedExchange(&dword_805D154, _InterlockedExchange(&dword_805D154, (signed __int32)v10)),
                a2);
        v16 = v13 < 0xF;
        v19 = __OFSUB__(v13, 15);
        v17 = v13 == 15;
        v18 = (signed int)(v13 - 15) < 0;
        if ( v13 != 15 )
        {
          v20 = _InterlockedExchange(&dword_805D154, v13);
          _InterlockedExchange(&dword_805D154, v14);
          _InterlockedExchange(&dword_805D154, v20);
          sub_804B283(v16, v17, v18, v19, v15, a2);
        }
        __asm { popfw }
        v21 = __errno_location();
        error(0, *v21, "%s: %s", v24, v25);
      }
      else
      {
        v22 = __errno_location();
        error(0, *v22, "%s", v25);
      }
      _exit(status);
    }
  }
  result = sub_8055FB0(_CF, _ZF, _SF, _OF, v3, a2, stderr);
  if ( result )
    _exit(status);
  return result;
}
// 805D154: using guessed type int dword_805D154;
// 805D7E2: using guessed type int dword_805D7E2;
// 805D7E6: using guessed type char byte_805D7E6;

//----- (0804F19B) --------------------------------------------------------
_DWORD *__cdecl sub_804F19B(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 1732584193;
  a1[1] = -271733879;
  a1[2] = -1732584194;
  a1[3] = 271733878;
  a1[5] = 0;
  a1[4] = a1[5];
  result = a1;
  a1[6] = 0;
  return result;
}

//----- (0804F1E7) --------------------------------------------------------
_DWORD *__usercall sub_804F1E7@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, _DWORD *a9, int a10)
{
  char v10; // al
  signed __int32 v11; // ebx
  char v12; // t0
  signed __int32 v13; // eax
  unsigned __int32 v14; // eax
  signed __int32 v15; // edx
  signed __int32 v16; // ecx
  signed __int32 v21; // eax
  signed __int32 v22; // ebx
  char v23; // tt
  signed __int32 v24; // eax
  unsigned __int32 v25; // eax
  signed __int32 v26; // edx
  signed __int32 v27; // ecx
  signed __int32 v28; // ebx
  signed __int32 v29; // et1
  signed __int32 v30; // eax
  signed __int32 v31; // edx
  signed __int32 v32; // ecx
  signed __int32 v33; // ebx
  char v34; // tt
  char v35; // al
  signed __int32 v36; // et1
  char v37; // al
  signed __int32 v38; // et2
  signed __int32 v39; // ebx
  signed __int32 v40; // ecx
  signed __int32 v41; // ebx
  signed __int32 v42; // ett
  signed __int32 v43; // edx
  char v48; // al
  signed __int32 v49; // et0
  int v50; // eax
  signed __int32 v51; // ebx
  signed __int32 v52; // edx
  signed __int32 v53; // ebx
  signed __int32 v54; // et1
  unsigned int v55; // eax
  signed __int32 v56; // edx
  signed __int32 v57; // ecx
  signed __int32 v62; // ebx
  signed __int32 v63; // ecx
  signed __int32 v64; // ebx
  signed __int32 v65; // ett
  unsigned int v66; // eax
  signed __int32 v67; // edx
  signed __int32 v68; // ecx
  char v73; // al
  signed __int32 v74; // et0
  signed __int32 v75; // eax
  signed __int32 v76; // eax
  _DWORD *result; // eax
  signed __int32 v78; // [esp-10h] [ebp-10h]
  signed __int32 v79; // [esp-10h] [ebp-10h]
  signed __int32 v80; // [esp-10h] [ebp-10h]
  signed __int32 v81; // [esp-Ah] [ebp-Ah]
  unsigned __int32 v82; // [esp-Ah] [ebp-Ah]
  unsigned __int32 v83; // [esp-Ah] [ebp-Ah]
  signed __int32 v84; // [esp-4h] [ebp-4h]

  v84 = a5;
  __asm { pushfw }
  v81 = a8;
  if ( a8 >= 10 )
  {
    v10 = a8;
    v11 = _InterlockedExchange(&dword_805D130, a8);
    v12 = _InterlockedExchange(&dword_805D130, a6);
    _InterlockedExchange(&dword_805D130, v11);
    if ( (v12 - 1) * v10 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  v13 = _InterlockedExchange(&dword_805D13C, v84);
  _InterlockedExchange(&dword_805D13C, a7);
  _InterlockedExchange(&dword_805D13C, v13);
  v14 = sub_8055DB4();
  _CF = v14 < 0xFFFFFFC0;
  _OF = __OFSUB__(v14, -64);
  _ZF = v14 == -64;
  _SF = (signed int)(v14 + 64) < 0;
  if ( v14 != -64 )
  {
    v21 = _InterlockedExchange(&dword_805D13C, v14);
    _InterlockedExchange(&dword_805D13C, v15);
    sub_8055DBE(v16, _InterlockedExchange(&dword_805D13C, v21));
  }
  __asm { pushfw }
  v78 = v81;
  if ( v81 >= 10 )
  {
    v22 = _InterlockedExchange(&dword_805D124, v81);
    v23 = _InterlockedExchange(&dword_805D124, v16);
    v16 = _InterlockedExchange(&dword_805D124, v22);
    if ( (v23 - 1) * (_BYTE)v81 & 1 )
      abort();
  }
  __asm
  {
    popfw
    popfw
    pushfw
  }
  v24 = _InterlockedExchange(&dword_805D148, v84);
  _InterlockedExchange(&dword_805D148, v16);
  _InterlockedExchange(&dword_805D148, v24);
  v25 = sub_80550FF();
  if ( v25 != 180 )
  {
    v28 = _InterlockedExchange(&dword_805D148, v81);
    v29 = _InterlockedExchange(&dword_805D148, v26);
    _InterlockedExchange(&dword_805D148, v28);
    sub_8055109(v25 < 0xB4, v25 == 180, (signed int)(v25 - 180) < 0, __OFSUB__(v25, 180), v25, v27, v29);
  }
  __asm
  {
    popfw
    pushfw
  }
  v30 = _InterlockedExchange(&dword_805D16C, v84);
  _InterlockedExchange(&dword_805D16C, v27);
  _InterlockedExchange(&dword_805D16C, v30);
  v82 = sub_804C738();
  __asm { pushfw }
  if ( v78 >= 10 )
  {
    v33 = _InterlockedExchange(&dword_805D148, v78);
    v34 = _InterlockedExchange(&dword_805D148, v32);
    v32 = _InterlockedExchange(&dword_805D148, v33);
    if ( (v34 - 1) * (_BYTE)v78 & 1 )
      abort();
  }
  __asm { popfw }
  if ( v82 != 907 )
    sub_804C742(
      v82 < 0x38B,
      v82 == 907,
      (signed int)(v82 - 907) < 0,
      __OFSUB__(v82, 907),
      v82,
      _InterlockedExchange(&dword_805D16C, _InterlockedExchange(&dword_805D16C, v78)),
      _InterlockedExchange(&dword_805D16C, v31));
  __asm
  {
    popfw
    pushfw
  }
  if ( v78 >= 10 )
  {
    v36 = _InterlockedExchange(&dword_805D184, v78);
    v35 = _InterlockedExchange(&dword_805D184, v31);
    v31 = _InterlockedExchange(&dword_805D184, v36);
    if ( ((_BYTE)v78 - 1) * v35 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( v78 >= 10 )
  {
    v38 = _InterlockedExchange(&dword_805D190, v78);
    v37 = _InterlockedExchange(&dword_805D190, v32);
    v32 = _InterlockedExchange(&dword_805D190, v38);
    if ( ((_BYTE)v78 - 1) * v37 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  v39 = _InterlockedExchange(&dword_805D1C0, v78);
  v42 = _InterlockedExchange(&dword_805D1C0, v32);
  v40 = v39;
  v41 = v42;
  v83 = sub_8054904(_CF, _ZF, _SF, _OF, v31, _InterlockedExchange(&dword_805D1C0, v40), v42);
  __asm { pushfw }
  v79 = v42;
  _CF = (unsigned int)v42 < 0xA;
  _OF = __OFSUB__(v42, 10);
  _ZF = v42 == 10;
  _SF = v42 - 10 < 0;
  if ( v42 >= 10 )
  {
    v49 = _InterlockedExchange(&dword_805D19C, v41);
    v48 = _InterlockedExchange(&dword_805D19C, v43);
    v43 = _InterlockedExchange(&dword_805D19C, v49);
    v50 = (_BYTE)--v41 * v48 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = v50 == 0;
    _SF = v50 < 0;
    if ( v50 )
      abort();
  }
  __asm { pushfw }
  v51 = _InterlockedExchange(&dword_805D118, v41);
  v54 = _InterlockedExchange(&dword_805D118, v43);
  v52 = v51;
  v53 = v54;
  _InterlockedExchange(&dword_805D118, v52);
  v55 = sub_804B6EB();
  if ( v55 != -916 )
    sub_804B6F5(
      v55 < 0xFFFFFC6C,
      v55 == -916,
      (signed int)(v55 + 916) < 0,
      __OFSUB__(v55, -916),
      _InterlockedExchange(&dword_805D118, _InterlockedExchange(&dword_805D118, v53)),
      _InterlockedExchange(&dword_805D118, v56));
  __asm
  {
    popfw
    popfw
  }
  _CF = v83 < 0x28F;
  _OF = __OFSUB__(v83, 655);
  _ZF = v83 == 655;
  _SF = (signed int)(v83 - 655) < 0;
  if ( v83 != 655 )
  {
    __asm { pushfw }
    v62 = _InterlockedExchange(&dword_805D184, v79);
    v65 = _InterlockedExchange(&dword_805D184, v57);
    v63 = v62;
    v64 = v65;
    v66 = sub_804C065(
            v83 < 0x28F,
            v83 == 655,
            (signed int)(v83 - 655) < 0,
            __OFSUB__(v83, 655),
            v56,
            _InterlockedExchange(&dword_805D184, v63),
            v65);
    _CF = v66 < 0x12C;
    _OF = __OFSUB__(v66, 300);
    _ZF = v66 == 300;
    _SF = (signed int)(v66 - 300) < 0;
    if ( v66 != 300 )
    {
      v80 = v66;
      __asm { pushfw }
      if ( v64 >= 10 )
      {
        v74 = _InterlockedExchange(&dword_805D16C, v64);
        v73 = _InterlockedExchange(&dword_805D16C, v68);
        v68 = _InterlockedExchange(&dword_805D16C, v74);
        if ( ((_BYTE)v64 - 1) * v73 & 1 )
          abort();
      }
      __asm { popfw }
      v75 = _InterlockedExchange(&dword_805D184, v80);
      _InterlockedExchange(&dword_805D184, v67);
      sub_804C18B(_CF, _ZF, _SF, _OF, _InterlockedExchange(&dword_805D184, v75), v68, v64);
    }
    __asm { popfw }
    v76 = _InterlockedExchange(&dword_805D1C0, v83);
    _InterlockedExchange(&dword_805D1C0, v67);
    _InterlockedExchange(&dword_805D1C0, v76);
    sub_8054A34(_CF, _ZF, _SF, _OF, v68, v64);
  }
  __asm { popfw }
  result = a9;
  *a9 = a10;
  return result;
}
// 804F1E7: could not find valid save-restore pair for ebx
// 8055DBE: using guessed type int __fastcall sub_8055DBE(_DWORD, _DWORD);
// 805D118: using guessed type int dword_805D118;
// 805D124: using guessed type int dword_805D124;
// 805D130: using guessed type int dword_805D130;
// 805D13C: using guessed type int dword_805D13C;
// 805D148: using guessed type int dword_805D148;
// 805D16C: using guessed type int dword_805D16C;
// 805D184: using guessed type int dword_805D184;
// 805D190: using guessed type int dword_805D190;
// 805D19C: using guessed type int dword_805D19C;
// 805D1C0: using guessed type int dword_805D1C0;

//----- (0804F4D9) --------------------------------------------------------
_DWORD *__usercall sub_804F4D9@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, int a9@<ebp>, int *a10, _DWORD *a11)
{
  signed __int32 v11; // ebx
  signed __int32 v12; // ecx
  signed __int32 v13; // ebx
  signed __int32 v14; // et0
  signed __int32 v15; // edx
  signed __int32 v16; // ecx
  char v17; // al
  signed __int32 v18; // ebx
  char v19; // t1
  signed __int32 v20; // ebx
  signed __int32 v21; // et2
  _DWORD *v22; // eax
  signed __int32 v23; // ecx
  signed __int32 v24; // edx
  unsigned __int32 v25; // eax
  signed __int32 v26; // ecx
  bool v27; // cf
  bool v28; // zf
  bool v29; // sf
  char v30; // of
  signed __int32 v31; // eax
  signed __int32 v32; // ecx
  signed __int32 v34; // ecx
  signed __int32 v35; // [esp+Ch] [ebp-10h]
  unsigned int v36; // [esp+12h] [ebp-Ah]
  int v37; // [esp+18h] [ebp-4h]

  v37 = a5;
  __asm { pushfw }
  v11 = _InterlockedExchange(&dword_805D1C0, a8);
  v14 = _InterlockedExchange(&dword_805D1C0, a7);
  v12 = v11;
  v13 = v14;
  v36 = sub_8054904(_CF, _ZF, _SF, _OF, a6, _InterlockedExchange(&dword_805D1C0, v12), v14);
  __asm { pushfw }
  v35 = v14;
  if ( v14 >= 10 )
  {
    v17 = v13;
    v18 = _InterlockedExchange(&dword_805D118, v13);
    v19 = _InterlockedExchange(&dword_805D118, v16);
    v16 = _InterlockedExchange(&dword_805D118, v18);
    if ( (v19 - 1) * v17 & 1 )
      abort();
  }
  __asm { popfw }
  if ( v36 != 655 )
  {
    v20 = _InterlockedExchange(&dword_805D1C0, v35);
    v21 = _InterlockedExchange(&dword_805D1C0, v15);
    _InterlockedExchange(&dword_805D1C0, v20);
    sub_8054A34(v36 < 0x28F, v36 == 655, (signed int)(v36 - 655) < 0, __OFSUB__(v36, 655), v16, v21);
  }
  __asm { popfw }
  v37 = a9;
  v22 = sub_804F1E7(
          (unsigned int)&v37 < 0x18,
          &v37 == 0,
          (signed int)&v37 < 0,
          __OFSUB__(&v37, 24),
          (signed __int32)a11,
          v15,
          v16,
          v35,
          a11,
          *a10);
  __asm { pushfw }
  v25 = sub_804B1D3(
          _CF,
          _ZF,
          _SF,
          _OF,
          _InterlockedExchange(&dword_805D154, v23),
          v24,
          _InterlockedExchange(&dword_805D154, _InterlockedExchange(&dword_805D154, (signed __int32)v22)),
          v35);
  v27 = v25 < 0xF;
  v30 = __OFSUB__(v25, 15);
  v28 = v25 == 15;
  v29 = (signed int)(v25 - 15) < 0;
  if ( v25 != 15 )
  {
    v31 = _InterlockedExchange(&dword_805D154, v25);
    _InterlockedExchange(&dword_805D154, v26);
    sub_804B283(v27, v28, v29, v30, _InterlockedExchange(&dword_805D154, v31), v35);
  }
  __asm { popfw }
  sub_804F1E7(
    __CFADD__(a11, 4),
    a11 + 1 == 0,
    (signed int)(a11 + 1) < 0,
    __OFADD__(4, a11),
    a10[1],
    (signed __int32)(a11 + 1),
    v26,
    v35,
    a11 + 1,
    a10[1]);
  sub_804F1E7(
    __CFADD__(a11, 8),
    a11 + 2 == 0,
    (signed int)(a11 + 2) < 0,
    __OFADD__(8, a11),
    a10[2],
    (signed __int32)(a11 + 2),
    v32,
    v35,
    a11 + 2,
    a10[2]);
  sub_804F1E7(
    __CFADD__(a11, 12),
    a11 + 3 == 0,
    (signed int)(a11 + 3) < 0,
    __OFADD__(12, a11),
    a10[3],
    (signed __int32)(a11 + 3),
    v34,
    v35,
    a11 + 3,
    a10[3]);
  return a11;
}
// 804F4D9: could not find valid save-restore pair for ebp
// 805D118: using guessed type int dword_805D118;
// 805D154: using guessed type int dword_805D154;
// 805D1C0: using guessed type int dword_805D1C0;

//----- (0804F667) --------------------------------------------------------
_DWORD *__usercall sub_804F667@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, int *a3, _DWORD *a4)
{
  signed int v8; // eax
  char v9; // al
  signed __int32 v10; // ebx
  char v11; // t0
  signed __int32 v12; // edx
  signed __int32 v13; // ecx
  signed __int32 v15; // [esp-Ah] [ebp-32h]
  unsigned int v16; // [esp+18h] [ebp-10h]
  signed int v17; // [esp+1Ch] [ebp-Ch]
  int savedregs; // [esp+28h] [ebp+0h]

  v16 = a3[6];
  _CF = v16 < 0x37;
  _OF = __OFSUB__(v16, 55);
  _ZF = v16 == 55;
  _SF = (signed int)(v16 - 55) < 0;
  if ( v16 > 0x37 )
  {
    __asm { pushfw }
    v15 = a2;
    if ( a2 >= 10 )
    {
      v9 = a2;
      v10 = _InterlockedExchange(&dword_805D160, a2);
      v11 = _InterlockedExchange(&dword_805D160, a1);
      _InterlockedExchange(&dword_805D160, v10);
      if ( (v11 - 1) * v9 & 1 )
        abort();
    }
    a2 = v15;
    __asm { popfw }
    v8 = 32;
  }
  else
  {
    v8 = 16;
  }
  v17 = v8;
  a3[4] += v16;
  if ( a3[4] < v16 )
    ++a3[5];
  a3[v8 + 5] = 8 * a3[4];
  a3[v8 + 6] = *((_QWORD *)a3 + 2) >> 29;
  memcpy((char *)a3 + v16 + 28, &unk_8058928, 4 * (v8 + 1073741822) - v16);
  sub_804FD7C(4 * v17, a2, a3 + 7, 4 * v17, a3);
  return sub_804F4D9(_CF, _ZF, _SF, _OF, (int)a3, v12, v13, a2, (int)&savedregs, a3, a4);
}
// 805D160: using guessed type int dword_805D160;

//----- (0804F794) --------------------------------------------------------
int __usercall sub_804F794@<eax>(signed __int32 a1@<ebx>, FILE *stream, int a3)
{
  int v3; // eax
  signed __int32 v4; // edx
  signed __int32 v5; // ecx
  int v6; // ecx
  char v12; // al
  signed __int32 v13; // et0
  char v14; // al
  signed __int32 v15; // et1
  signed __int32 v16; // ebx
  int v17; // eax
  signed __int32 v22; // ebx
  signed __int32 v23; // edx
  signed __int32 v24; // ebx
  signed __int32 v25; // et2
  signed __int32 v26; // edx
  int v27; // ecx
  signed __int32 v28; // ebx
  signed __int32 v29; // edx
  char v34; // al
  signed __int32 v35; // et0
  int v36; // eax
  char v37; // al
  signed __int32 v38; // et1
  signed __int32 v39; // [esp-Ah] [ebp-D2h]
  size_t v40; // [esp+18h] [ebp-B0h]
  int *ptr; // [esp+1Ch] [ebp-ACh]
  size_t v42; // [esp+20h] [ebp-A8h]
  int v43; // [esp+24h] [ebp-A4h]

  ptr = (int *)malloc(0x8048u);
  if ( !ptr )
    return 1;
  sub_804F19B(&v43);
LABEL_4:
  v40 = 0;
  while ( 1 )
  {
    v42 = fread_unlocked((char *)ptr + v40, 1u, 0x8000 - v40, stream);
    v40 += v42;
    if ( v40 == 0x8000 )
    {
      sub_804FD7C(v6, a1, ptr, 0x8000u, &v43);
      goto LABEL_4;
    }
    if ( !v42 )
      break;
    if ( feof_unlocked(stream) )
      goto LABEL_20;
  }
  v3 = ferror_unlocked(stream);
  _CF = 0;
  _OF = 0;
  _ZF = v3 == 0;
  _SF = v3 < 0;
  if ( v3 )
  {
    __asm { pushfw }
    if ( a1 >= 10 )
    {
      v13 = _InterlockedExchange(&dword_805D10C, a1);
      v12 = _InterlockedExchange(&dword_805D10C, v5);
      _InterlockedExchange(&dword_805D10C, v13);
      if ( ((_BYTE)a1 - 1) * v12 & 1 )
        abort();
    }
    __asm { popfw }
    free(ptr);
    return 1;
  }
  __asm { pushfw }
  v39 = a1;
  if ( a1 >= 10 )
  {
    v15 = _InterlockedExchange(&dword_805D160, a1);
    v14 = _InterlockedExchange(&dword_805D160, v4);
    v4 = _InterlockedExchange(&dword_805D160, v15);
    v16 = a1 - 1;
    v17 = (_BYTE)v16 * v14 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = v17 == 0;
    _SF = v17 < 0;
    if ( v17 )
    {
      __asm { pushfw }
      v22 = _InterlockedExchange(&dword_805D124, v16);
      v25 = _InterlockedExchange(&dword_805D124, v4);
      v23 = v22;
      v24 = v25;
      _InterlockedExchange(&dword_805D124, v23);
      if ( sub_804972F() != 949 )
      {
        v28 = _InterlockedExchange(&dword_805D124, v24);
        _InterlockedExchange(&dword_805D124, v26);
        sub_8049739(v27, _InterlockedExchange(&dword_805D124, v28));
      }
      __asm { popfw }
      abort();
    }
  }
  a1 = v39;
  __asm { popfw }
LABEL_20:
  if ( v40 )
    sub_804FA6F(v4, a1, ptr, v40, (int)&v43);
  sub_804F667(v5, a1, &v43, (_DWORD *)a3);
  free(ptr);
  __asm { pushfw }
  _CF = (unsigned int)a1 < 0xA;
  _OF = __OFSUB__(a1, 10);
  _ZF = a1 == 10;
  _SF = a1 - 10 < 0;
  if ( a1 >= 10 )
  {
    v35 = _InterlockedExchange(&dword_805D13C, a1);
    v34 = _InterlockedExchange(&dword_805D13C, v29);
    v29 = _InterlockedExchange(&dword_805D13C, v35);
    v36 = (_BYTE)--a1 * v34 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = v36 == 0;
    _SF = v36 < 0;
    if ( v36 )
      abort();
  }
  __asm { pushfw }
  if ( a1 >= 10 )
  {
    v38 = _InterlockedExchange(&dword_805D118, a1);
    v37 = _InterlockedExchange(&dword_805D118, v29);
    _InterlockedExchange(&dword_805D118, v38);
    if ( ((_BYTE)a1 - 1) * v37 & 1 )
      abort();
  }
  __asm
  {
    popfw
    popfw
  }
  return 0;
}
// 8049739: using guessed type int __fastcall sub_8049739(_DWORD, _DWORD);
// 805D10C: using guessed type int dword_805D10C;
// 805D118: using guessed type int dword_805D118;
// 805D124: using guessed type int dword_805D124;
// 805D13C: using guessed type int dword_805D13C;
// 805D160: using guessed type int dword_805D160;

//----- (0804FA6F) --------------------------------------------------------
int *__usercall sub_804FA6F@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>, void *src, size_t a4, int a5)
{
  int *result; // eax
  int v6; // eax
  unsigned int v7; // eax
  signed __int32 v12; // edx
  char v13; // al
  signed __int32 v14; // ebx
  char v15; // t0
  char v16; // al
  signed __int32 v17; // et1
  int *v22; // eax
  int v23; // ecx
  signed __int32 v24; // ebx
  signed __int32 v25; // edx
  signed __int32 v26; // ebx
  signed __int32 v27; // et2
  signed __int32 v28; // edx
  signed __int32 v29; // ecx
  char v30; // al
  signed __int32 v31; // ett
  size_t v32; // ST24_4
  int v33; // ecx
  signed __int32 v34; // edx
  char v35; // al
  signed __int32 v36; // ebx
  char v37; // t1
  signed __int32 v38; // [esp-10h] [ebp-38h]
  unsigned __int32 v39; // [esp-Ah] [ebp-32h]
  size_t v40; // [esp+14h] [ebp-14h]
  int v41; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]

  result = *(int **)(a5 + 24);
  if ( result )
  {
    v41 = *(_DWORD *)(a5 + 24);
    v6 = a4;
    if ( 128 - v41 <= a4 )
      v6 = 128 - v41;
    n = v6;
    memcpy((void *)(v41 + a5 + 28), src, v6);
    a1 = n + *(_DWORD *)(a5 + 24);
    *(_DWORD *)(a5 + 24) = a1;
    v7 = *(_DWORD *)(a5 + 24);
    _CF = v7 < 0x40;
    _OF = __OFSUB__(v7, 64);
    _ZF = v7 == 64;
    _SF = (signed int)(v7 - 64) < 0;
    if ( v7 > 0x40 )
    {
      sub_804FD7C(*(_DWORD *)(a5 + 24) & 0xFFFFFFC0, a2, (int *)(a5 + 28), *(_DWORD *)(a5 + 24) & 0xFFFFFFC0, (int *)a5);
      __asm { pushfw }
      if ( a2 >= 10 )
      {
        v13 = a2;
        v14 = _InterlockedExchange(&dword_805D10C, a2);
        v15 = _InterlockedExchange(&dword_805D10C, v12);
        _InterlockedExchange(&dword_805D10C, v14);
        if ( (v15 - 1) * v13 & 1 )
          abort();
      }
      __asm { popfw }
      *(_DWORD *)(a5 + 24) &= 0x3Fu;
      a2 = a5 + 28;
      memcpy((void *)(a5 + 28), (const void *)(a5 + 28 + ((v41 + n) & 0xFFFFFFC0)), *(_DWORD *)(a5 + 24));
    }
    __asm { pushfw }
    if ( a2 >= 10 )
    {
      v17 = _InterlockedExchange(&dword_805D124, a2);
      v16 = _InterlockedExchange(&dword_805D124, a1);
      a1 = _InterlockedExchange(&dword_805D124, v17);
      if ( ((_BYTE)a2 - 1) * v16 & 1 )
        abort();
    }
    __asm { popfw }
    src = (char *)src + n;
    result = (int *)n;
    a4 -= n;
  }
  if ( a4 > 0x3F )
  {
    result = (int *)((unsigned __int8)src & 3);
    _CF = 0;
    _OF = 0;
    _ZF = result == 0;
    _SF = (signed int)result < 0;
    if ( (unsigned __int8)src & 3 )
    {
      while ( a4 > 0x40 )
      {
        v22 = (int *)memcpy((void *)(a5 + 28), src, 0x40u);
        result = sub_804FD7C(v23, a2, v22, 0x40u, (int *)a5);
        src = (char *)src + 64;
        a4 -= 64;
      }
    }
    else
    {
      __asm { pushfw }
      v24 = _InterlockedExchange(&dword_805D190, a2);
      v27 = _InterlockedExchange(&dword_805D190, a1);
      v25 = v24;
      v26 = v27;
      _InterlockedExchange(&dword_805D190, v25);
      v39 = sub_80554DE();
      __asm { pushfw }
      v38 = v27;
      if ( v27 >= 10 )
      {
        v31 = _InterlockedExchange(&dword_805D154, v26);
        v30 = _InterlockedExchange(&dword_805D154, v28);
        _InterlockedExchange(&dword_805D154, v31);
        if ( ((_BYTE)v26 - 1) * v30 & 1 )
          abort();
      }
      a2 = v38;
      __asm { popfw }
      if ( v39 != 553 )
        sub_80554E8(
          v39 < 0x229,
          v39 == 553,
          (signed int)(v39 - 553) < 0,
          __OFSUB__(v39, 553),
          v39,
          _InterlockedExchange(&dword_805D190, _InterlockedExchange(&dword_805D190, v38)),
          _InterlockedExchange(&dword_805D190, v29));
      __asm { popfw }
      sub_804FD7C(v29, v38, (int *)src, a4 & 0xFFFFFFC0, (int *)a5);
      result = (int *)(a4 & 0xFFFFFFC0);
      src = (char *)src + (a4 & 0xFFFFFFC0);
      a4 &= 0x3Fu;
    }
  }
  if ( a4 )
  {
    v32 = *(_DWORD *)(a5 + 24);
    memcpy((void *)(v32 + a5 + 28), src, a4);
    v40 = a4 + v32;
    if ( v40 > 0x3F )
    {
      sub_804FD7C(v33, a2, (int *)(a5 + 28), 0x40u, (int *)a5);
      __asm { pushfw }
      if ( a2 >= 10 )
      {
        v35 = a2;
        v36 = _InterlockedExchange(&dword_805D1B4, a2);
        v37 = _InterlockedExchange(&dword_805D1B4, v34);
        _InterlockedExchange(&dword_805D1B4, v36);
        if ( (v37 - 1) * v35 & 1 )
          abort();
      }
      __asm { popfw }
      v40 -= 64;
      memcpy((void *)(a5 + 28), (const void *)(a5 + 92), v40);
    }
    result = (int *)a5;
    *(_DWORD *)(a5 + 24) = v40;
  }
  return result;
}
// 805D10C: using guessed type int dword_805D10C;
// 805D124: using guessed type int dword_805D124;
// 805D154: using guessed type int dword_805D154;
// 805D190: using guessed type int dword_805D190;
// 805D1B4: using guessed type int dword_805D1B4;

//----- (0804FD7C) --------------------------------------------------------
int *__usercall sub_804FD7C@<eax>(int a1@<ecx>, signed __int32 a2@<ebx>, int *a3, unsigned int a4, int *a5)
{
  int v5; // edx
  _BOOL4 v6; // eax
  signed __int32 v11; // edx
  signed __int32 v12; // eax
  char v13; // al
  signed __int32 v14; // et0
  int v15; // ST3C_4
  int v16; // ST40_4
  int v17; // ST44_4
  int v18; // ST48_4
  int v19; // ST4C_4
  int v20; // ST1C_4
  int *v21; // ST18_4
  int v22; // ST1C_4
  int v23; // ST50_4
  int v24; // ST28_4
  int v25; // ST54_4
  int v26; // ST24_4
  int v27; // ST58_4
  int v28; // ST20_4
  int v29; // ST5C_4
  int v30; // ST1C_4
  int v31; // ST60_4
  int v32; // ST28_4
  int v33; // ST64_4
  int v34; // ST24_4
  int v35; // ST68_4
  int v36; // ST20_4
  int v37; // ST6C_4
  int v38; // ST1C_4
  int v39; // ST70_4
  int v40; // ST28_4
  int v41; // ST74_4
  int v42; // ST24_4
  int v43; // ST78_4
  int v44; // ST20_4
  int v45; // ST7C_4
  int v46; // ST1C_4
  int v47; // ST80_4
  int v48; // ST28_4
  int v49; // ST84_4
  int v50; // ST24_4
  int v51; // ST88_4
  int v52; // ST20_4
  int v53; // ST1C_4
  int v54; // ST28_4
  int v55; // ST24_4
  int v56; // ST20_4
  int v57; // ST1C_4
  int v58; // ST28_4
  int v59; // ST24_4
  int v60; // ST20_4
  int v61; // ST1C_4
  int v62; // ST28_4
  int v63; // ST24_4
  int v64; // ST20_4
  int v65; // ST1C_4
  int v66; // ST28_4
  int v67; // ST24_4
  int v68; // ST20_4
  int v69; // ST1C_4
  int v70; // ST28_4
  int v71; // ST24_4
  int v72; // ST20_4
  int v73; // ST1C_4
  int v74; // ST28_4
  int v75; // ST24_4
  int v76; // ST20_4
  int v77; // ST1C_4
  int v78; // ST28_4
  int v79; // ST24_4
  int v80; // ST20_4
  int v81; // ST1C_4
  int v82; // ST28_4
  int v83; // ST24_4
  int v84; // ST20_4
  int v85; // ST1C_4
  int v86; // ST28_4
  int v87; // ST24_4
  int v88; // ST20_4
  int v89; // ST1C_4
  int v90; // ST28_4
  int v91; // ST24_4
  int v92; // ST20_4
  int v93; // ST1C_4
  int v94; // ST28_4
  int v95; // ST24_4
  int v96; // ST20_4
  int v97; // ST1C_4
  int v98; // ST28_4
  int v99; // ST24_4
  signed __int32 v100; // eax
  unsigned __int32 v101; // eax
  signed __int32 v102; // edx
  signed __int32 v103; // ecx
  bool v104; // cf
  bool v105; // zf
  bool v106; // sf
  char v107; // of
  signed __int32 v108; // eax
  char v113; // al
  signed __int32 v114; // ett
  int *result; // eax
  int *v116; // [esp+Ch] [ebp-74h]
  int v117; // [esp+10h] [ebp-70h]
  int v118; // [esp+14h] [ebp-6Ch]
  int v119; // [esp+18h] [ebp-68h]
  int v120; // [esp+1Ch] [ebp-64h]
  unsigned int v121; // [esp+24h] [ebp-5Ch]

  v116 = a3;
  v121 = (unsigned int)&a3[a4 >> 2];
  v117 = *a5;
  v118 = a5[1];
  v119 = a5[2];
  v120 = a5[3];
  a5[4] += a4;
  v5 = a5[5];
  v6 = a5[4] < a4;
  _CF = __CFADD__(v6, v5);
  _OF = __OFADD__(v6, v5);
  _ZF = v6 + v5 == 0;
  _SF = v6 + v5 < 0;
  v11 = v6 + v5;
  v12 = (signed __int32)a5;
  a5[5] = v11;
  while ( 1 )
  {
    __asm { pushfw }
    v100 = _InterlockedExchange(&dword_805D1C0, v12);
    _InterlockedExchange(&dword_805D1C0, a1);
    v101 = sub_8054904(_CF, _ZF, _SF, _OF, v11, _InterlockedExchange(&dword_805D1C0, v100), a2);
    v104 = v101 < 0x28F;
    v107 = __OFSUB__(v101, 655);
    v105 = v101 == 655;
    v106 = (signed int)(v101 - 655) < 0;
    if ( v101 != 655 )
    {
      v108 = _InterlockedExchange(&dword_805D1C0, v101);
      _InterlockedExchange(&dword_805D1C0, v103);
      sub_8054A34(v104, v105, v106, v107, _InterlockedExchange(&dword_805D1C0, v108), a2);
    }
    __asm { popfw }
    _CF = (unsigned int)v116 < v121;
    _OF = __OFSUB__(v116, v121);
    _ZF = v116 == (int *)v121;
    _SF = (signed int)((signed int)v116 - v121) < 0;
    if ( (unsigned int)v116 >= v121 )
      break;
    __asm { pushfw }
    if ( a2 >= 10 )
    {
      v14 = _InterlockedExchange(&dword_805D19C, a2);
      v13 = _InterlockedExchange(&dword_805D19C, v103);
      _InterlockedExchange(&dword_805D19C, v14);
      if ( ((_BYTE)a2 - 1) * v13 & 1 )
        abort();
    }
    __asm { popfw }
    v15 = v117;
    v16 = v118;
    v17 = v119;
    v18 = v120;
    v19 = *v116;
    v20 = (v120 ^ v118 & (v119 ^ v120)) + *v116 + v117 - 680876936;
    v21 = v116 + 1;
    v22 = v118 + __ROR4__(v20, 25);
    v23 = *v21;
    ++v21;
    v24 = v22 + __ROR4__((v119 ^ v22 & (v118 ^ v119)) + v23 + v120 - 389564586, 20);
    v25 = *v21;
    ++v21;
    v26 = v24 + __ROR4__((v118 ^ v24 & (v22 ^ v118)) + v25 + v119 + 606105819, 15);
    v27 = *v21;
    ++v21;
    v28 = v26 + __ROR4__((v22 ^ v26 & (v24 ^ v22)) + v27 + v118 - 1044525330, 10);
    v29 = *v21;
    ++v21;
    v30 = v28 + __ROR4__((v24 ^ v28 & (v26 ^ v24)) + v29 + v22 - 176418897, 25);
    v31 = *v21;
    ++v21;
    v32 = v30 + __ROR4__((v26 ^ v30 & (v28 ^ v26)) + v31 + v24 + 1200080426, 20);
    v33 = *v21;
    ++v21;
    v34 = v32 + __ROR4__((v28 ^ v32 & (v30 ^ v28)) + v33 + v26 - 1473231341, 15);
    v35 = *v21;
    ++v21;
    v36 = v34 + __ROR4__((v30 ^ v34 & (v32 ^ v30)) + v35 + v28 - 45705983, 10);
    v37 = *v21;
    ++v21;
    v38 = v36 + __ROR4__((v32 ^ v36 & (v34 ^ v32)) + v37 + v30 + 1770035416, 25);
    v39 = *v21;
    ++v21;
    v40 = v38 + __ROR4__((v34 ^ v38 & (v36 ^ v34)) + v39 + v32 - 1958414417, 20);
    v41 = *v21;
    ++v21;
    v42 = v40 + __ROR4__((v36 ^ v40 & (v38 ^ v36)) + v41 + v34 - 42063, 15);
    v43 = *v21;
    ++v21;
    v44 = v42 + __ROR4__((v38 ^ v42 & (v40 ^ v38)) + v43 + v36 - 1990404162, 10);
    v45 = *v21;
    ++v21;
    v46 = v44 + __ROR4__((v40 ^ v44 & (v42 ^ v40)) + v45 + v38 + 1804603682, 25);
    v47 = *v21;
    ++v21;
    v48 = v46 + __ROR4__((v42 ^ v46 & (v44 ^ v42)) + v47 + v40 - 40341101, 20);
    v49 = *v21;
    ++v21;
    v50 = v48 + __ROR4__((v44 ^ v48 & (v46 ^ v44)) + v49 + v42 - 1502002290, 15);
    a1 = v46 ^ v50 & (v48 ^ v46);
    v51 = *v21;
    v116 = v21 + 1;
    v52 = v50 + __ROR4__(a1 + v51 + v44 + 1236535329, 10);
    v53 = v52 + __ROR4__(v23 + (v50 ^ v48 & (v52 ^ v50)) + v46 - 165796510, 27);
    v54 = v53 + __ROR4__(v33 + (v52 ^ v50 & (v53 ^ v52)) + v48 - 1069501632, 23);
    v55 = v54 + __ROR4__(v43 + (v53 ^ v52 & (v54 ^ v53)) + v50 + 643717713, 18);
    v56 = v55 + __ROR4__(v19 + (v54 ^ v53 & (v55 ^ v54)) + v52 - 373897302, 12);
    v57 = v56 + __ROR4__(v31 + (v55 ^ v54 & (v56 ^ v55)) + v53 - 701558691, 27);
    v58 = v57 + __ROR4__(v41 + (v56 ^ v55 & (v57 ^ v56)) + v54 + 38016083, 23);
    v59 = v58 + __ROR4__(v51 + (v57 ^ v56 & (v58 ^ v57)) + v55 - 660478335, 18);
    v60 = v59 + __ROR4__(v29 + (v58 ^ v57 & (v59 ^ v58)) + v56 - 405537848, 12);
    v61 = v60 + __ROR4__(v39 + (v59 ^ v58 & (v60 ^ v59)) + v57 + 568446438, 27);
    v62 = v61 + __ROR4__(v49 + (v60 ^ v59 & (v61 ^ v60)) + v58 - 1019803690, 23);
    v63 = v62 + __ROR4__(v27 + (v61 ^ v60 & (v62 ^ v61)) + v59 - 187363961, 18);
    v64 = v63 + __ROR4__(v37 + (v62 ^ v61 & (v63 ^ v62)) + v60 + 1163531501, 12);
    v65 = v64 + __ROR4__(v47 + (v63 ^ v62 & (v64 ^ v63)) + v61 - 1444681467, 27);
    v66 = v65 + __ROR4__(v25 + (v64 ^ v63 & (v65 ^ v64)) + v62 - 51403784, 23);
    v67 = v66 + __ROR4__(v35 + (v65 ^ v64 & (v66 ^ v65)) + v63 + 1735328473, 18);
    v68 = v67 + __ROR4__(v45 + (v66 ^ v65 & (v67 ^ v66)) + v64 - 1926607734, 12);
    v69 = v68 + __ROR4__(v31 + (v66 ^ v68 ^ v67) + v65 - 378558, 28);
    v70 = v69 + __ROR4__(v37 + (v67 ^ v69 ^ v68) + v66 - 2022574463, 21);
    v71 = v70 + __ROR4__(v43 + (v68 ^ v70 ^ v69) + v67 + 1839030562, 16);
    v72 = v71 + __ROR4__(v49 + (v69 ^ v71 ^ v70) + v68 - 35309556, 9);
    v73 = v72 + __ROR4__(v23 + (v70 ^ v72 ^ v71) + v69 - 1530992060, 28);
    v74 = v73 + __ROR4__(v29 + (v71 ^ v73 ^ v72) + v70 + 1272893353, 21);
    v75 = v74 + __ROR4__(v35 + (v72 ^ v74 ^ v73) + v71 - 155497632, 16);
    v76 = v75 + __ROR4__(v41 + (v73 ^ v75 ^ v74) + v72 - 1094730640, 9);
    v77 = v76 + __ROR4__(v47 + (v74 ^ v76 ^ v75) + v73 + 681279174, 28);
    v78 = v77 + __ROR4__(v19 + (v75 ^ v77 ^ v76) + v74 - 358537222, 21);
    v79 = v78 + __ROR4__(v27 + (v76 ^ v78 ^ v77) + v75 - 722521979, 16);
    v80 = v79 + __ROR4__(v33 + (v77 ^ v79 ^ v78) + v76 + 76029189, 9);
    v81 = v80 + __ROR4__(v39 + (v78 ^ v80 ^ v79) + v77 - 640364487, 28);
    v82 = v81 + __ROR4__(v45 + (v79 ^ v81 ^ v80) + v78 - 421815835, 21);
    v83 = v82 + __ROR4__(v51 + (v80 ^ v82 ^ v81) + v79 + 530742520, 16);
    v84 = v83 + __ROR4__(v25 + (v81 ^ v83 ^ v82) + v80 - 995338651, 9);
    v85 = v84 + __ROR4__(v19 + (v83 ^ (v84 | ~v82)) + v81 - 198630844, 26);
    v86 = v85 + __ROR4__(v35 + (v84 ^ (v85 | ~v83)) + v82 + 1126891415, 22);
    v87 = v86 + __ROR4__(v49 + (v85 ^ (v86 | ~v84)) + v83 - 1416354905, 17);
    v88 = v87 + __ROR4__(v31 + (v86 ^ (v87 | ~v85)) + v84 - 57434055, 11);
    v89 = v88 + __ROR4__(v45 + (v87 ^ (v88 | ~v86)) + v85 + 1700485571, 26);
    v90 = v89 + __ROR4__(v27 + (v88 ^ (v89 | ~v87)) + v86 - 1894986606, 22);
    v91 = v90 + __ROR4__(v41 + (v89 ^ (v90 | ~v88)) + v87 - 1051523, 17);
    v92 = v91 + __ROR4__(v23 + (v90 ^ (v91 | ~v89)) + v88 - 2054922799, 11);
    v93 = v92 + __ROR4__(v37 + (v91 ^ (v92 | ~v90)) + v89 + 1873313359, 26);
    v94 = v93 + __ROR4__(v51 + (v92 ^ (v93 | ~v91)) + v90 - 30611744, 22);
    v95 = v94 + __ROR4__(v33 + (v93 ^ (v94 | ~v92)) + v91 - 1560198380, 17);
    v96 = v95 + __ROR4__(v47 + (v94 ^ (v95 | ~v93)) + v92 + 1309151649, 11);
    v97 = v96 + __ROR4__(v29 + (v95 ^ (v96 | ~v94)) + v93 - 145523070, 26);
    v98 = v97 + __ROR4__(v43 + (v96 ^ (v97 | ~v95)) + v94 - 1120210379, 22);
    v99 = v98 + __ROR4__(v25 + (v97 ^ (v98 | ~v96)) + v95 + 718787259, 17);
    v11 = v39 + (v98 ^ (v99 | ~v97));
    v117 = v15 + v97;
    v118 = v16 + v99 + __ROR4__(v11 + v96 - 343485551, 11);
    v119 = v17 + v99;
    v12 = v18;
    _CF = __CFADD__(v18, v98);
    _OF = __OFADD__(v18, v98);
    _ZF = v18 + v98 == 0;
    _SF = v18 + v98 < 0;
    v120 = v18 + v98;
  }
  __asm { pushfw }
  if ( a2 >= 10 )
  {
    v114 = _InterlockedExchange(&dword_805D148, a2);
    v113 = _InterlockedExchange(&dword_805D148, v102);
    _InterlockedExchange(&dword_805D148, v114);
    if ( ((_BYTE)a2 - 1) * v113 & 1 )
      abort();
  }
  __asm { popfw }
  *a5 = v117;
  a5[1] = v118;
  a5[2] = v119;
  result = a5;
  a5[3] = v120;
  return result;
}
// 805D148: using guessed type int dword_805D148;
// 805D19C: using guessed type int dword_805D19C;
// 805D1C0: using guessed type int dword_805D1C0;

//----- (08050AEB) --------------------------------------------------------
int __usercall sub_8050AEB@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>, int a8@<ebp>, int a9, int a10, int a11, int a12, int a13, int a14)
{
  char v14; // al
  signed __int32 v15; // et0
  signed __int32 v16; // edx
  char v17; // al
  signed __int32 v18; // et1
  int v20; // [esp+18h] [ebp-34h]
  int v21; // [esp+1Ch] [ebp-30h]
  int v22; // [esp+30h] [ebp-1Ch]
  int v23; // [esp+34h] [ebp-18h]
  int v24; // [esp+38h] [ebp-14h]
  int v25; // [esp+3Ch] [ebp-10h]
  __int64 v26; // [esp+40h] [ebp-Ch]
  int v27; // [esp+48h] [ebp-4h]

  v27 = a5;
  __asm { pushfw }
  *(_DWORD *)((char *)&v26 + 2) = a7;
  if ( a7 >= 10 )
  {
    v15 = _InterlockedExchange(&dword_805D130, a7);
    v14 = _InterlockedExchange(&dword_805D130, a6);
    _InterlockedExchange(&dword_805D130, v15);
    if ( ((_BYTE)a7 - 1) * v14 & 1 )
      abort();
  }
  __asm { popfw }
  v27 = posix_fadvise64(
          a9,
          a10,
          a11,
          a12,
          a13,
          a14,
          v20,
          v21,
          a12,
          a13,
          a10,
          a11,
          v22,
          v23,
          v24,
          v25,
          v26,
          HIDWORD(v26),
          a8);
  __asm { pushfw }
  if ( a7 >= 10 )
  {
    v18 = _InterlockedExchange(&dword_805D16C, a7);
    v17 = _InterlockedExchange(&dword_805D16C, v16);
    _InterlockedExchange(&dword_805D16C, v18);
    if ( ((_BYTE)a7 - 1) * v17 & 1 )
      abort();
  }
  __asm { popfw }
  return v27;
}
// 8050AEB: could not find valid save-restore pair for ebx
// 8050AEB: could not find valid save-restore pair for ebp
// 8049050: using guessed type int __stdcall posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 805D130: using guessed type int dword_805D130;
// 805D16C: using guessed type int dword_805D16C;

//----- (08050BA4) --------------------------------------------------------
int __usercall sub_8050BA4@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, int a8@<ebp>, FILE *stream, signed __int32 a10)
{
  signed __int32 v10; // ebx
  signed __int32 v11; // ecx
  signed __int32 v12; // ebx
  signed __int32 v13; // et0
  signed __int32 v14; // edx
  signed __int32 v15; // ecx
  signed __int32 v16; // ebx
  signed __int32 v17; // ebx
  signed __int32 v18; // ecx
  signed __int32 v19; // ebx
  signed __int32 v20; // et2
  unsigned int v21; // eax
  signed __int32 v22; // edx
  signed __int32 v23; // ebx
  signed __int32 v24; // edx
  signed __int32 v25; // ebx
  signed __int32 v26; // et0
  unsigned __int32 v27; // eax
  signed __int32 v28; // edx
  signed __int32 v29; // ecx
  char v34; // al
  signed __int32 v35; // ebx
  char v36; // t2
  int result; // eax
  signed __int32 v42; // ebx
  signed __int32 v43; // edx
  signed __int32 v44; // ebx
  signed __int32 v45; // ett
  unsigned __int32 v46; // eax
  signed __int32 v47; // edx
  signed __int32 v48; // ecx
  bool v49; // cf
  bool v50; // zf
  bool v51; // sf
  char v52; // of
  signed __int32 v53; // eax
  char v54; // al
  signed __int32 v55; // et1
  signed __int32 v56; // ebx
  signed __int32 v57; // ecx
  signed __int32 v58; // ecx
  signed __int32 v59; // ebx
  signed __int32 v60; // et2
  int v61; // edx
  signed __int32 v62; // ecx
  signed __int32 v63; // ebx
  char v64; // al
  signed __int32 v65; // ebx
  char v66; // t0
  signed __int32 v67; // [esp-Ah] [ebp-36h]
  int v68; // [esp-4h] [ebp-30h]
  signed __int32 v69; // [esp+1Ch] [ebp-10h]
  int v70; // [esp+28h] [ebp-4h]

  v70 = a5;
  __asm { pushfw }
  v10 = _InterlockedExchange(&dword_805D10C, a7);
  v13 = _InterlockedExchange(&dword_805D10C, a6);
  v11 = v10;
  v12 = v13;
  _InterlockedExchange(&dword_805D10C, v11);
  if ( sub_8049617() != -795 )
  {
    v16 = _InterlockedExchange(&dword_805D10C, v12);
    _InterlockedExchange(&dword_805D10C, v14);
    sub_8049621(v15, _InterlockedExchange(&dword_805D10C, v16));
  }
  __asm
  {
    popfw
    pushfw
  }
  v17 = _InterlockedExchange(&dword_805D178, v12);
  v20 = _InterlockedExchange(&dword_805D178, v15);
  v18 = v17;
  v19 = v20;
  _InterlockedExchange(&dword_805D178, v18);
  v21 = sub_804A5EF();
  if ( v21 != 421 )
    sub_804A5F9(
      v21 < 0x1A5,
      v21 == 421,
      (signed int)(v21 - 421) < 0,
      __OFSUB__(v21, 421),
      _InterlockedExchange(&dword_805D178, _InterlockedExchange(&dword_805D178, v19)),
      _InterlockedExchange(&dword_805D178, v22));
  __asm
  {
    popfw
    pushfw
  }
  v23 = _InterlockedExchange(&dword_805D190, v19);
  v26 = _InterlockedExchange(&dword_805D190, v22);
  v24 = v23;
  v25 = v26;
  _InterlockedExchange(&dword_805D190, v24);
  v27 = sub_80554DE();
  _CF = v27 < 0x229;
  _OF = __OFSUB__(v27, 553);
  _ZF = v27 == 553;
  _SF = (signed int)(v27 - 553) < 0;
  if ( v27 != 553 )
    sub_80554E8(
      v27 < 0x229,
      v27 == 553,
      (signed int)(v27 - 553) < 0,
      __OFSUB__(v27, 553),
      v27,
      _InterlockedExchange(&dword_805D190, _InterlockedExchange(&dword_805D190, v25)),
      _InterlockedExchange(&dword_805D190, v29));
  __asm { pushfw }
  v69 = v25;
  if ( v25 >= 10 )
  {
    v34 = v25;
    v35 = _InterlockedExchange(&dword_805D154, v25);
    v36 = _InterlockedExchange(&dword_805D154, v28);
    v28 = _InterlockedExchange(&dword_805D154, v35);
    if ( (v36 - 1) * v34 & 1 )
      abort();
  }
  __asm
  {
    popfw
    popfw
  }
  result = v70;
  v70 = a8;
  _CF = 0;
  _OF = 0;
  _ZF = stream == 0;
  _SF = (signed int)stream < 0;
  if ( stream )
  {
    __asm { pushfw }
    v42 = _InterlockedExchange(&dword_805D118, v69);
    v45 = _InterlockedExchange(&dword_805D118, v28);
    v43 = v42;
    v44 = v45;
    _InterlockedExchange(&dword_805D118, v43);
    v46 = sub_804B6EB();
    v49 = v46 < 0xFFFFFC6C;
    v52 = __OFSUB__(v46, -916);
    v50 = v46 == -916;
    v51 = (signed int)(v46 + 916) < 0;
    if ( v46 != -916 )
    {
      v53 = _InterlockedExchange(&dword_805D118, v46);
      _InterlockedExchange(&dword_805D118, v48);
      _InterlockedExchange(&dword_805D118, v53);
      sub_804B6F5(v49, v50, v51, v52, v47, v44);
    }
    __asm
    {
      popfw
      pushfw
    }
    if ( v44 >= 10 )
    {
      v55 = _InterlockedExchange(&dword_805D1A8, v44);
      v54 = _InterlockedExchange(&dword_805D1A8, v48);
      _InterlockedExchange(&dword_805D1A8, v55);
      if ( ((_BYTE)v44 - 1) * v54 & 1 )
        abort();
    }
    __asm { popfw }
    v68 = fileno(stream);
    __asm { pushfw }
    v56 = _InterlockedExchange(&dword_805D160, v44);
    v60 = _InterlockedExchange(&dword_805D160, v57);
    v58 = v56;
    v59 = v60;
    _InterlockedExchange(&dword_805D160, v58);
    if ( sub_804F071() != -48 )
    {
      v63 = _InterlockedExchange(&dword_805D160, v59);
      _InterlockedExchange(&dword_805D160, v62);
      sub_804F07B(_InterlockedExchange(&dword_805D160, v63), v61);
    }
    __asm
    {
      popfw
      pushfw
    }
    v67 = v59;
    if ( v59 >= 10 )
    {
      v64 = v59;
      v65 = _InterlockedExchange(&dword_805D1C0, v59);
      v66 = _InterlockedExchange(&dword_805D1C0, v62);
      _InterlockedExchange(&dword_805D1C0, v65);
      if ( (v66 - 1) * v64 & 1 )
        abort();
    }
    __asm { popfw }
    result = sub_8050AEB(_CF, _ZF, _SF, _OF, v68, a10, v67, (int)&v70, v68, 0, 0, 0, 0, a10);
  }
  return result;
}
// 8050BA4: could not find valid save-restore pair for ebp
// 8049621: using guessed type int __fastcall sub_8049621(_DWORD, _DWORD);
// 804F07B: using guessed type int __fastcall sub_804F07B(_DWORD, _DWORD);
// 805D10C: using guessed type int dword_805D10C;
// 805D118: using guessed type int dword_805D118;
// 805D154: using guessed type int dword_805D154;
// 805D160: using guessed type int dword_805D160;
// 805D178: using guessed type int dword_805D178;
// 805D190: using guessed type int dword_805D190;
// 805D1A8: using guessed type int dword_805D1A8;
// 805D1C0: using guessed type int dword_805D1C0;

//----- (08050E96) --------------------------------------------------------
#error "8050FDA: call analysis failed (funcsize=117)"

//----- (08051013) --------------------------------------------------------
char *__usercall sub_8051013@<eax>(signed __int32 a1@<ebx>, char *s)
{
  signed __int32 v2; // edx
  signed __int32 v3; // ecx
  char *v8; // eax
  signed __int32 v9; // ebx
  signed __int32 v10; // edx
  signed __int32 v11; // ebx
  signed __int32 v12; // et0
  unsigned __int32 v13; // eax
  signed __int32 v14; // ecx
  bool v15; // cf
  bool v16; // zf
  bool v17; // sf
  char v18; // of
  signed __int32 v19; // eax
  char *result; // eax
  char *v21; // [esp+18h] [ebp-10h]
  char *s1; // [esp+1Ch] [ebp-Ch]

  if ( !s )
  {
    fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
    abort();
  }
  v21 = strrchr(s, 47);
  _CF = 0;
  _OF = 0;
  _ZF = v21 == 0;
  _SF = (signed int)v21 < 0;
  if ( v21 )
  {
    v8 = v21 + 1;
  }
  else
  {
    __asm { pushfw }
    v9 = _InterlockedExchange(&dword_805D154, a1);
    v12 = _InterlockedExchange(&dword_805D154, v2);
    v10 = v9;
    v11 = v12;
    v13 = sub_804B1D3(0, v21 == 0, (signed int)v21 < 0, 0, 0, _InterlockedExchange(&dword_805D154, v10), v3, v12);
    v15 = v13 < 0xF;
    v18 = __OFSUB__(v13, 15);
    v16 = v13 == 15;
    v17 = (signed int)(v13 - 15) < 0;
    if ( v13 != 15 )
    {
      v19 = _InterlockedExchange(&dword_805D154, v13);
      _InterlockedExchange(&dword_805D154, v14);
      sub_804B283(v15, v16, v17, v18, _InterlockedExchange(&dword_805D154, v19), v11);
    }
    __asm { popfw }
    v8 = s;
  }
  s1 = v8;
  if ( v8 - s > 6 && !strncmp(v8 - 7, "/.libs/", 7u) )
  {
    s = s1;
    if ( !strncmp(s1, "lt-", 3u) )
    {
      s = s1 + 3;
      program_invocation_short_name = (int)(s1 + 3);
    }
  }
  dword_805D7EA = (int)s;
  result = s;
  program_invocation_name = (int)s;
  return result;
}
// 805D154: using guessed type int dword_805D154;
// 805D260: using guessed type int program_invocation_short_name;
// 805D270: using guessed type int program_invocation_name;
// 805D7EA: using guessed type int dword_805D7EA;

//----- (080511DA) --------------------------------------------------------
int __cdecl sub_80511DA(int *a1, unsigned __int8 a2, char a3)
{
  int *v3; // eax
  int v4; // ST10_4

  if ( a1 )
    v3 = a1;
  else
    v3 = &dword_805D802;
  v4 = ((unsigned int)v3[(a2 >> 5) + 2] >> (a2 & 0x1F)) & 1;
  v3[(a2 >> 5) + 2] ^= (v4 ^ a3 & 1) << (a2 & 0x1F);
  return v4;
}
// 805D802: using guessed type int dword_805D802;

//----- (0805136F) --------------------------------------------------------
int *__usercall sub_805136F@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, int *a9, int a10, int a11)
{
  char v11; // al
  signed __int32 v12; // ebx
  char v13; // t0
  signed __int32 v14; // ebx
  signed __int32 v19; // eax
  char v24; // al
  signed __int32 v25; // et2
  signed __int32 v26; // ebx
  signed __int32 v27; // ett
  signed __int32 v28; // ebx
  int v29; // eax
  signed __int32 v34; // eax
  unsigned int v35; // eax
  signed __int32 v36; // edx
  signed __int32 v37; // eax
  signed __int32 v38; // ebx
  signed __int32 v39; // ecx
  signed __int32 v40; // ebx
  signed __int32 v41; // ett
  unsigned __int32 v42; // eax
  signed __int32 v43; // edx
  signed __int32 v44; // ecx
  signed __int32 v49; // ebx
  signed __int32 v50; // ecx
  signed __int32 v51; // ebx
  signed __int32 v52; // et1
  unsigned int v53; // eax
  signed __int32 v54; // edx
  signed __int32 v55; // ecx
  signed __int32 v56; // eax
  signed __int32 v57; // ett
  unsigned __int32 v58; // eax
  signed __int32 v59; // edx
  signed __int32 v60; // ecx
  signed __int32 v61; // ebx
  signed __int32 v62; // et0
  int *result; // eax
  unsigned __int32 v64; // [esp-16h] [ebp-16h]
  signed __int32 v65; // [esp-Ah] [ebp-Ah]
  signed __int32 v66; // [esp-4h] [ebp-4h]

  v66 = a5;
  __asm { pushfw }
  v65 = a8;
  if ( a8 >= 10 )
  {
    v11 = a8;
    v12 = _InterlockedExchange(&dword_805D10C, a8);
    v13 = _InterlockedExchange(&dword_805D10C, a6);
    a6 = _InterlockedExchange(&dword_805D10C, v12);
    if ( (v13 - 1) * v11 & 1 )
      abort();
  }
  v14 = v65;
  __asm { popfw }
  _CF = 0;
  _OF = 0;
  _ZF = a9 == 0;
  _SF = (signed int)a9 < 0;
  if ( !a9 )
  {
    __asm { pushfw }
    v19 = _InterlockedExchange(&dword_805D1C0, v66);
    _InterlockedExchange(&dword_805D1C0, a7);
    v64 = sub_8054904(0, a9 == 0, (signed int)a9 < 0, 0, a6, _InterlockedExchange(&dword_805D1C0, v19), v65);
    __asm { pushfw }
    _CF = (unsigned int)v65 < 0xA;
    _OF = __OFSUB__(v65, 10);
    _ZF = v65 == 10;
    _SF = v65 - 10 < 0;
    if ( v65 >= 10 )
    {
      __asm { pushfw }
      if ( v65 >= 10 )
      {
        v25 = _InterlockedExchange(&dword_805D10C, v65);
        v24 = _InterlockedExchange(&dword_805D10C, a7);
        a7 = _InterlockedExchange(&dword_805D10C, v25);
        if ( ((_BYTE)v65 - 1) * v24 & 1 )
          abort();
      }
      __asm { popfw }
      v26 = _InterlockedExchange(&dword_805D160, v65);
      v27 = _InterlockedExchange(&dword_805D160, a7);
      a7 = _InterlockedExchange(&dword_805D160, v26);
      v28 = v27 - 1;
      v29 = ((_BYTE)v27 - 1) * (_BYTE)v65 & 1;
      _CF = 0;
      _OF = 0;
      _ZF = v29 == 0;
      _SF = v29 < 0;
      if ( ((_BYTE)v27 - 1) * (_BYTE)v65 & 1 )
      {
        __asm { pushfw }
        v34 = _InterlockedExchange(&dword_805D118, v29);
        _InterlockedExchange(&dword_805D118, a7);
        _InterlockedExchange(&dword_805D118, v34);
        v35 = sub_804B6EB();
        if ( v35 != -916 )
          sub_804B6F5(
            v35 < 0xFFFFFC6C,
            v35 == -916,
            (signed int)(v35 + 916) < 0,
            __OFSUB__(v35, -916),
            _InterlockedExchange(&dword_805D118, _InterlockedExchange(&dword_805D118, v28)),
            _InterlockedExchange(&dword_805D118, v36));
        __asm { popfw }
        abort();
      }
    }
    v14 = v65;
    __asm { popfw }
    if ( v64 != 655 )
    {
      v37 = _InterlockedExchange(&dword_805D1C0, v64);
      _InterlockedExchange(&dword_805D1C0, a7);
      sub_8054A34(
        v64 < 0x28F,
        v64 == 655,
        (signed int)(v64 - 655) < 0,
        __OFSUB__(v64, 655),
        _InterlockedExchange(&dword_805D1C0, v37),
        v65);
    }
    __asm { popfw }
    a9 = &dword_805D802;
  }
  __asm { pushfw }
  v38 = _InterlockedExchange(&dword_805D16C, v14);
  v41 = _InterlockedExchange(&dword_805D16C, a7);
  v39 = v38;
  v40 = v41;
  _InterlockedExchange(&dword_805D16C, v39);
  v42 = sub_804C738();
  if ( v42 != 907 )
    sub_804C742(
      v42 < 0x38B,
      v42 == 907,
      (signed int)(v42 - 907) < 0,
      __OFSUB__(v42, 907),
      v42,
      _InterlockedExchange(&dword_805D16C, _InterlockedExchange(&dword_805D16C, v40)),
      _InterlockedExchange(&dword_805D16C, v43));
  __asm { popfw }
  *a9 = 10;
  _CF = 0;
  _OF = 0;
  _ZF = a10 == 0;
  _SF = a10 < 0;
  if ( !a10 || (_CF = 0, _OF = 0, _ZF = a11 == 0, _SF = a11 < 0, !a11) )
  {
    __asm { pushfw }
    v49 = _InterlockedExchange(&dword_805D184, v40);
    v52 = _InterlockedExchange(&dword_805D184, v44);
    v50 = v49;
    v51 = v52;
    v53 = sub_804C065(0, _ZF, _SF, 0, v43, _InterlockedExchange(&dword_805D184, v50), v52);
    if ( v53 != 300 )
      sub_804C18B(
        v53 < 0x12C,
        v53 == 300,
        (signed int)(v53 - 300) < 0,
        __OFSUB__(v53, 300),
        _InterlockedExchange(&dword_805D184, _InterlockedExchange(&dword_805D184, v51)),
        v55,
        _InterlockedExchange(&dword_805D184, v54));
    __asm { popfw }
    abort();
  }
  __asm { pushfw }
  v57 = _InterlockedExchange(&dword_805D19C, (signed __int32)a9);
  v56 = _InterlockedExchange(&dword_805D19C, v44);
  _InterlockedExchange(&dword_805D19C, v57);
  v58 = sub_804B771(0, a11 == 0, a11 < 0, 0, v56, v43, v40);
  if ( v58 != -342 )
  {
    v61 = _InterlockedExchange(&dword_805D19C, v40);
    v62 = _InterlockedExchange(&dword_805D19C, v60);
    _InterlockedExchange(&dword_805D19C, v61);
    sub_804B82B(v58 < 0xFFFFFEAA, v58 == -342, (signed int)(v58 + 342) < 0, __OFSUB__(v58, -342), v58, v59, v62);
  }
  __asm { popfw }
  a9[10] = a10;
  result = a9;
  a9[11] = a11;
  return result;
}
// 805136F: could not find valid save-restore pair for ebp
// 805D10C: using guessed type int dword_805D10C;
// 805D118: using guessed type int dword_805D118;
// 805D160: using guessed type int dword_805D160;
// 805D16C: using guessed type int dword_805D16C;
// 805D184: using guessed type int dword_805D184;
// 805D19C: using guessed type int dword_805D19C;
// 805D1C0: using guessed type int dword_805D1C0;
// 805D802: using guessed type int dword_805D802;

//----- (0805158D) --------------------------------------------------------
unsigned int *__userpurge sub_805158D@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>, unsigned int *a8, unsigned int a9)
{
  signed __int32 v9; // eax
  unsigned __int32 v10; // eax
  signed __int32 v11; // edx
  signed __int32 v12; // ecx
  signed __int32 v13; // ebx
  signed __int32 v18; // eax
  unsigned int v19; // eax
  signed __int32 v20; // edx
  signed __int32 v21; // ecx
  signed __int32 v22; // ebx
  signed __int32 v23; // edx
  signed __int32 v24; // ecx
  char v25; // al
  signed __int32 v26; // ebx
  char v27; // t1
  signed __int32 v29; // [esp-4Ch] [ebp-4Ch]
  unsigned int v30; // [esp-46h] [ebp-46h]
  int v31; // [esp-3Ch] [ebp-3Ch]
  unsigned int v32; // [esp-38h] [ebp-38h]
  unsigned int v33; // [esp-34h] [ebp-34h]
  unsigned int v34; // [esp-30h] [ebp-30h]
  unsigned int v35; // [esp-2Ch] [ebp-2Ch]
  unsigned int v36; // [esp-28h] [ebp-28h]
  unsigned int v37; // [esp-24h] [ebp-24h]
  unsigned int v38; // [esp-20h] [ebp-20h]
  unsigned int v39; // [esp-1Ch] [ebp-1Ch]
  unsigned int v40; // [esp-18h] [ebp-18h]
  unsigned int v41; // [esp-14h] [ebp-14h]
  unsigned int v42; // [esp-10h] [ebp-10h]
  signed __int32 v43; // [esp-Ch] [ebp-Ch]
  signed __int32 v44; // [esp-4h] [ebp-4h]

  v44 = a5;
  __asm { pushfw }
  v9 = _InterlockedExchange(&dword_805D130, a5);
  _InterlockedExchange(&dword_805D130, a6);
  _InterlockedExchange(&dword_805D130, v9);
  v10 = sub_80527A0();
  if ( v10 != 553 )
  {
    v13 = _InterlockedExchange(&dword_805D130, a7);
    _InterlockedExchange(&dword_805D130, v12);
    _InterlockedExchange(&dword_805D130, v13);
    sub_80527AA(v10 < 0x229, v10 == 553, (signed int)(v10 - 553) < 0, __OFSUB__(v10, 553), v10, v11);
  }
  __asm { popfw }
  v43 = a7;
  memset(&v31, 0, 0x30u);
  _CF = a9 < 0xA;
  _OF = __OFSUB__(a9, 10);
  _ZF = a9 == 10;
  _SF = (signed int)(a9 - 10) < 0;
  if ( a9 == 10 )
  {
    __asm { pushfw }
    v18 = _InterlockedExchange(&dword_805D118, 0);
    _InterlockedExchange(&dword_805D118, 0);
    _InterlockedExchange(&dword_805D118, v18);
    v19 = sub_804B6EB();
    if ( v19 != -916 )
      sub_804B6F5(
        v19 < 0xFFFFFC6C,
        v19 == -916,
        (signed int)(v19 + 916) < 0,
        __OFSUB__(v19, -916),
        _InterlockedExchange(&dword_805D118, _InterlockedExchange(&dword_805D118, (signed __int32)&v31)),
        _InterlockedExchange(&dword_805D118, v20));
    __asm { popfw }
    abort();
  }
  __asm { pushfw }
  v21 = _InterlockedExchange(&dword_805D184, (signed __int32)&v31);
  v22 = _InterlockedExchange(&dword_805D184, 0);
  v30 = sub_804C065(
          a9 < 0xA,
          a9 == 10,
          (signed int)(a9 - 10) < 0,
          __OFSUB__(a9, 10),
          12,
          _InterlockedExchange(&dword_805D184, v21),
          v22);
  __asm { pushfw }
  v29 = v22;
  if ( v22 >= 10 )
  {
    v25 = v22;
    v26 = _InterlockedExchange(&dword_805D16C, v22);
    v27 = _InterlockedExchange(&dword_805D16C, v24);
    v24 = _InterlockedExchange(&dword_805D16C, v26);
    if ( (v27 - 1) * v25 & 1 )
      abort();
  }
  __asm { popfw }
  if ( v30 != 300 )
    sub_804C18B(
      v30 < 0x12C,
      v30 == 300,
      (signed int)(v30 - 300) < 0,
      __OFSUB__(v30, 300),
      v23,
      _InterlockedExchange(&dword_805D184, _InterlockedExchange(&dword_805D184, v29)),
      _InterlockedExchange(&dword_805D184, v24));
  __asm { popfw }
  *a8 = a9;
  a8[1] = v32;
  a8[2] = v33;
  a8[3] = v34;
  a8[4] = v35;
  a8[5] = v36;
  a8[6] = v37;
  a8[7] = v38;
  a8[8] = v39;
  a8[9] = v40;
  a8[10] = v41;
  a8[11] = v42;
  return a8;
}
// 805D118: using guessed type int dword_805D118;
// 805D130: using guessed type int dword_805D130;
// 805D16C: using guessed type int dword_805D16C;
// 805D184: using guessed type int dword_805D184;

//----- (080516FF) --------------------------------------------------------
char *__usercall sub_80516FF@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, const char *msgid, unsigned int a10)
{
  signed __int32 v10; // ebx
  signed __int32 v11; // ecx
  signed __int32 v12; // ebx
  signed __int32 v13; // et0
  unsigned __int32 v14; // eax
  signed __int32 v15; // edx
  signed __int32 v16; // ecx
  bool v17; // cf
  bool v18; // zf
  bool v19; // sf
  char v20; // of
  signed __int32 v21; // eax
  signed __int32 v22; // et1
  char *result; // eax
  unsigned __int8 *v24; // eax
  signed __int32 v25; // edx
  signed __int32 v26; // ecx
  int v27; // eax
  signed __int32 v28; // edx
  signed __int32 v29; // ecx
  char *v38; // eax
  unsigned __int32 v39; // eax
  signed __int32 v40; // ecx
  bool v41; // cf
  bool v42; // zf
  bool v43; // sf
  char v44; // of
  signed __int32 v45; // eax
  char v46; // al
  signed __int32 v47; // ebx
  char v48; // t0
  signed __int32 v49; // ebx
  signed __int32 v50; // ecx
  signed __int32 v51; // ebx
  signed __int32 v52; // et1
  unsigned __int32 v53; // eax
  signed __int32 v54; // edx
  signed __int32 v55; // ecx
  signed __int32 v56; // edx
  signed __int32 v61; // ebx
  signed __int32 v62; // edx
  signed __int32 v63; // ebx
  signed __int32 v64; // ett
  signed __int32 v65; // edx
  int v66; // ecx
  signed __int32 v67; // ebx
  char *v68; // [esp-4h] [ebp-30h]
  char *v69; // [esp+18h] [ebp-14h]
  unsigned __int8 *v70; // [esp+1Ch] [ebp-10h]

  __asm { pushfw }
  v10 = _InterlockedExchange(&dword_805D19C, a8);
  v13 = _InterlockedExchange(&dword_805D19C, a7);
  v11 = v10;
  v12 = v13;
  _InterlockedExchange(&dword_805D19C, v11);
  v14 = sub_804B771(_CF, _ZF, _SF, _OF, a5, a6, v13);
  v17 = v14 < 0xFFFFFEAA;
  v20 = __OFSUB__(v14, -342);
  v18 = v14 == -342;
  v19 = (signed int)(v14 + 342) < 0;
  if ( v14 != -342 )
  {
    v22 = _InterlockedExchange(&dword_805D19C, v14);
    v21 = _InterlockedExchange(&dword_805D19C, v16);
    _InterlockedExchange(&dword_805D19C, v22);
    sub_804B82B(v17, v18, v19, v20, v21, v15, v12);
  }
  __asm { popfw }
  v69 = gettext(msgid);
  if ( v69 != msgid )
    return v69;
  v24 = (unsigned __int8 *)sub_805690D(v12);
  v70 = v24;
  v27 = sub_8055F4B(v25, v26, v24, "UTF-8");
  _CF = 0;
  _OF = 0;
  _ZF = v27 == 0;
  _SF = v27 < 0;
  if ( v27 )
  {
    __asm { pushfw }
    v49 = _InterlockedExchange(&dword_805D190, v12);
    v52 = _InterlockedExchange(&dword_805D190, v29);
    v50 = v49;
    v51 = v52;
    _InterlockedExchange(&dword_805D190, v50);
    v53 = sub_80554DE();
    if ( v53 != 553 )
      sub_80554E8(
        v53 < 0x229,
        v53 == 553,
        (signed int)(v53 - 553) < 0,
        __OFSUB__(v53, 553),
        v53,
        _InterlockedExchange(&dword_805D190, _InterlockedExchange(&dword_805D190, v51)),
        _InterlockedExchange(&dword_805D190, v55));
    __asm { popfw }
    if ( sub_8055F4B(v54, v55, v70, "GB18030") )
    {
      _CF = a10 < 9;
      _OF = __OFSUB__(a10, 9);
      _ZF = a10 == 9;
      _SF = (signed int)(a10 - 9) < 0;
      if ( a10 == 9 )
      {
        __asm { pushfw }
        v61 = _InterlockedExchange(&dword_805D13C, v51);
        v64 = _InterlockedExchange(&dword_805D13C, v56);
        v62 = v61;
        v63 = v64;
        _InterlockedExchange(&dword_805D13C, v62);
        if ( sub_8055DB4() != -64 )
        {
          v67 = _InterlockedExchange(&dword_805D13C, v63);
          _InterlockedExchange(&dword_805D13C, v65);
          sub_8055DBE(v66, _InterlockedExchange(&dword_805D13C, v67));
        }
        __asm { popfw }
        result = (char *)&unk_8058AAD;
      }
      else
      {
        result = (char *)&unk_8058AAF;
      }
    }
    else if ( *msgid == 96 )
    {
      result = (char *)&unk_8058AA6;
    }
    else
    {
      result = (char *)&unk_8058AAA;
    }
  }
  else
  {
    _CF = *msgid < 0x60u;
    _OF = __OFSUB__(*msgid, 96);
    _ZF = *msgid == 96;
    _SF = (char)(*msgid - 96) < 0;
    if ( *msgid == 96 )
      v38 = (char *)&unk_8058A96;
    else
      v38 = (char *)&unk_8058A9A;
    v68 = v38;
    __asm { pushfw }
    v39 = sub_804B1D3(
            *msgid < 0x60u,
            *msgid == 96,
            (char)(*msgid - 96) < 0,
            __OFSUB__(*msgid, 96),
            _InterlockedExchange(&dword_805D154, v29),
            v28,
            _InterlockedExchange(&dword_805D154, _InterlockedExchange(&dword_805D154, (signed __int32)v38)),
            v12);
    v41 = v39 < 0xF;
    v44 = __OFSUB__(v39, 15);
    v42 = v39 == 15;
    v43 = (signed int)(v39 - 15) < 0;
    if ( v39 != 15 )
    {
      v45 = _InterlockedExchange(&dword_805D154, v39);
      _InterlockedExchange(&dword_805D154, v40);
      sub_804B283(v41, v42, v43, v44, _InterlockedExchange(&dword_805D154, v45), v12);
    }
    __asm
    {
      popfw
      pushfw
    }
    if ( v12 >= 10 )
    {
      v46 = v12;
      v47 = _InterlockedExchange(&dword_805D16C, v12);
      v48 = _InterlockedExchange(&dword_805D16C, v40);
      _InterlockedExchange(&dword_805D16C, v47);
      if ( (v48 - 1) * v46 & 1 )
        abort();
    }
    __asm { popfw }
    result = v68;
  }
  return result;
}
// 80516FF: could not find valid save-restore pair for ebp
// 8055DBE: using guessed type int __fastcall sub_8055DBE(_DWORD, _DWORD);
// 805D13C: using guessed type int dword_805D13C;
// 805D154: using guessed type int dword_805D154;
// 805D16C: using guessed type int dword_805D16C;
// 805D190: using guessed type int dword_805D190;
// 805D19C: using guessed type int dword_805D19C;

//----- (080518CE) --------------------------------------------------------
unsigned int __usercall sub_80518CE@<eax>(signed __int32 a1@<ebx>, signed __int32 a2, unsigned int a3, signed __int32 a4, size_t a5, unsigned int a6, int a7, int a8, char *a9, char *a10)
{
  signed __int32 v10; // edx
  int v11; // ecx
  signed __int32 v12; // edx
  signed __int32 v13; // ecx
  size_t v14; // eax
  signed __int32 v19; // ebx
  signed __int32 v20; // edx
  signed __int32 v21; // et0
  unsigned __int32 v22; // eax
  bool v23; // cf
  bool v24; // zf
  bool v25; // sf
  char v26; // of
  signed __int32 v27; // eax
  char v32; // al
  signed __int32 v33; // et2
  bool v34; // al
  const unsigned __int16 **v35; // eax
  bool v36; // al
  unsigned int result; // eax
  char *v38; // [esp+2Ch] [ebp-5Ch]
  char *v39; // [esp+30h] [ebp-58h]
  char v40; // [esp+40h] [ebp-48h]
  bool v41; // [esp+41h] [ebp-47h]
  char v42; // [esp+42h] [ebp-46h]
  char v43; // [esp+43h] [ebp-45h]
  char v44; // [esp+44h] [ebp-44h]
  unsigned __int8 v45; // [esp+45h] [ebp-43h]
  char v46; // [esp+46h] [ebp-42h]
  char v47; // [esp+47h] [ebp-41h]
  char v48; // [esp+48h] [ebp-40h]
  char v49; // [esp+49h] [ebp-3Fh]
  bool v50; // [esp+4Ah] [ebp-3Eh]
  bool v51; // [esp+4Bh] [ebp-3Dh]
  wint_t wc; // [esp+4Ch] [ebp-3Ch]
  int v53; // [esp+50h] [ebp-38h]
  unsigned int v54; // [esp+54h] [ebp-34h]
  unsigned int v55; // [esp+58h] [ebp-30h]
  char *s; // [esp+5Ch] [ebp-2Ch]
  size_t n; // [esp+60h] [ebp-28h]
  unsigned int v58; // [esp+64h] [ebp-24h]
  unsigned int v59; // [esp+68h] [ebp-20h]
  size_t v60; // [esp+6Ch] [ebp-1Ch]
  unsigned int v61; // [esp+70h] [ebp-18h]
  mbstate_t ps; // [esp+74h] [ebp-14h]
  unsigned int v63; // [esp+7Ch] [ebp-Ch]
  int savedregs; // [esp+88h] [ebp+0h]

  v39 = a9;
  v38 = a10;
  v63 = __readgsdword(0x14u);
  v54 = 0;
  v55 = 0;
  s = 0;
  n = 0;
  v40 = 0;
  v51 = __ctype_get_mb_cur_max() == 1;
  v41 = (a7 & 2) != 0;
  v42 = 0;
  v43 = 0;
  v44 = 1;
  while ( 1 )
  {
    switch ( a6 )
    {
      case 0u:
        v41 = 0;
        break;
      case 1u:
        goto LABEL_20;
      case 2u:
        goto LABEL_23;
      case 3u:
        v40 = 1;
LABEL_20:
        v41 = 1;
        goto LABEL_21;
      case 4u:
LABEL_21:
        if ( v41 != 1 )
          v40 = 1;
LABEL_23:
        a6 = 2;
        if ( v41 != 1 )
        {
          if ( v54 < a3 )
          {
            v10 = a2;
            *(_BYTE *)(a2 + v54) = 39;
          }
          ++v54;
        }
        s = (char *)&unk_8058AAF;
        n = 1;
        break;
      case 5u:
        goto LABEL_4;
      case 6u:
        a6 = 5;
        v41 = 1;
LABEL_4:
        if ( v41 != 1 )
        {
          if ( v54 < a3 )
          {
            v10 = a2;
            *(_BYTE *)(a2 + v54) = 34;
          }
          ++v54;
        }
        v40 = 1;
        s = (char *)&unk_8058AAD;
        n = 1;
        break;
      case 7u:
        v40 = 1;
        v41 = 0;
        break;
      case 8u:
      case 9u:
      case 0xAu:
        if ( a6 != 10 )
        {
          v39 = sub_80516FF(
                  a6 < 0xA,
                  a6 == 10,
                  (signed int)(a6 - 10) < 0,
                  __OFSUB__(a6, 10),
                  a6,
                  v10,
                  v11,
                  a1,
                  (const char *)&unk_8058AB1,
                  a6);
          v38 = sub_80516FF(_CF, _ZF, _SF, _OF, a6, v12, v13, a1, (const char *)&unk_8058AAF, a6);
        }
        if ( v41 != 1 )
        {
          for ( s = v39; *s; ++s )
          {
            if ( v54 < a3 )
              *(_BYTE *)(v54 + a2) = *s;
            ++v54;
          }
        }
        v40 = 1;
        s = v38;
        n = strlen(v38);
        break;
      default:
        abort();
        return result;
    }
    v53 = 0;
LABEL_226:
    if ( a5 == -1 )
    {
      v10 = a4;
      v36 = *(_BYTE *)(a4 + v53) != 0;
    }
    else
    {
      v36 = v53 != a5;
    }
    if ( v36 )
      break;
    if ( !v54 && a6 == 2 && v41 )
      goto LABEL_251;
    if ( a6 != 2 || v41 == 1 || !v43 )
      goto LABEL_257;
    if ( v44 )
      return sub_80518CE(a2, v55, a4, a5, 5, a7, a8, v39, v38);
    if ( a3 || !v55 )
    {
LABEL_257:
      if ( s && v41 != 1 )
      {
        while ( *s )
        {
          if ( v54 < a3 )
            *(_BYTE *)(v54 + a2) = *s;
          ++v54;
          ++s;
        }
      }
      if ( v54 < a3 )
        *(_BYTE *)(a2 + v54) = 0;
      return v54;
    }
    a3 = v55;
    v54 = 0;
  }
  v47 = 0;
  v48 = 0;
  v49 = 0;
  if ( v40 && a6 != 2 && n )
  {
    a1 = v53 + n;
    if ( a5 != -1 || n <= 1 )
    {
      v14 = a5;
    }
    else
    {
      v14 = strlen((const char *)a4);
      a5 = v14;
    }
    if ( a1 <= v14 && !memcmp((const void *)(v53 + a4), s, n) )
    {
      if ( v41 )
        goto LABEL_251;
      v47 = 1;
    }
  }
  v10 = a4;
  v45 = *(_BYTE *)(a4 + v53);
  switch ( v45 )
  {
    case 0u:
      if ( v40 )
      {
        if ( v41 )
          goto LABEL_251;
        v48 = 1;
        if ( a6 == 2 && v42 != 1 )
        {
          if ( v54 < a3 )
          {
            v10 = a2;
            *(_BYTE *)(a2 + v54) = 39;
          }
          if ( ++v54 < a3 )
          {
            v10 = a2;
            *(_BYTE *)(a2 + v54) = 36;
          }
          if ( ++v54 < a3 )
          {
            v10 = a2;
            *(_BYTE *)(a2 + v54) = 39;
          }
          ++v54;
          v42 = 1;
        }
        if ( v54 < a3 )
        {
          v10 = a2;
          *(_BYTE *)(a2 + v54) = 92;
        }
        ++v54;
        if ( a6 != 2 && v53 + 1 < a5 )
        {
          v10 = v53 + 1;
          if ( *(_BYTE *)(v53 + 1 + a4) > 47 )
          {
            v10 = v53 + 1;
            if ( *(_BYTE *)(v53 + 1 + a4) <= 57 )
            {
              if ( v54 < a3 )
              {
                v10 = a2;
                *(_BYTE *)(a2 + v54) = 48;
              }
              _CF = ++v54 < a3;
              _OF = __OFSUB__(v54, a3);
              _ZF = v54 == a3;
              _SF = (signed int)(v54 - a3) < 0;
              if ( v54 < a3 )
              {
                v10 = a2;
                _CF = __CFADD__(a2, v54);
                _OF = __OFADD__(a2, v54);
                _ZF = a2 + v54 == 0;
                _SF = (signed int)(a2 + v54) < 0;
                *(_BYTE *)(a2 + v54) = 48;
              }
              __asm { pushfw }
              v19 = _InterlockedExchange(&dword_805D184, a1);
              v21 = _InterlockedExchange(&dword_805D184, v10);
              v20 = v19;
              a1 = v21;
              v22 = sub_804C065(_CF, _ZF, _SF, _OF, _InterlockedExchange(&dword_805D184, v20), v11, v21);
              v23 = v22 < 0x12C;
              v26 = __OFSUB__(v22, 300);
              v24 = v22 == 300;
              v25 = (signed int)(v22 - 300) < 0;
              if ( v22 != 300 )
              {
                v27 = _InterlockedExchange(&dword_805D184, v22);
                _InterlockedExchange(&dword_805D184, v11);
                sub_804C18B(v23, v24, v25, v26, v10, _InterlockedExchange(&dword_805D184, v27), a1);
              }
              __asm { popfw }
              ++v54;
            }
          }
        }
        v45 = 48;
      }
      else if ( a7 & 1 )
      {
        goto LABEL_225;
      }
      goto LABEL_195;
    case 7u:
      v46 = 97;
      goto LABEL_109;
    case 8u:
      v46 = 98;
      goto LABEL_109;
    case 9u:
      v46 = 116;
      goto LABEL_107;
    case 0xAu:
      v46 = 110;
      goto LABEL_107;
    case 0xBu:
      v46 = 118;
      goto LABEL_109;
    case 0xCu:
      v46 = 102;
      goto LABEL_109;
    case 0xDu:
      v46 = 114;
      goto LABEL_107;
    case 0x20u:
      goto LABEL_117;
    case 0x21u:
    case 0x22u:
    case 0x24u:
    case 0x26u:
    case 0x28u:
    case 0x29u:
    case 0x2Au:
    case 0x3Bu:
    case 0x3Cu:
    case 0x3Du:
    case 0x3Eu:
    case 0x5Bu:
    case 0x5Eu:
    case 0x60u:
    case 0x7Cu:
      goto LABEL_118;
    case 0x23u:
    case 0x7Eu:
      goto LABEL_116;
    case 0x25u:
    case 0x2Bu:
    case 0x2Cu:
    case 0x2Du:
    case 0x2Eu:
    case 0x2Fu:
    case 0x30u:
    case 0x31u:
    case 0x32u:
    case 0x33u:
    case 0x34u:
    case 0x35u:
    case 0x36u:
    case 0x37u:
    case 0x38u:
    case 0x39u:
    case 0x3Au:
    case 0x41u:
    case 0x42u:
    case 0x43u:
    case 0x44u:
    case 0x45u:
    case 0x46u:
    case 0x47u:
    case 0x48u:
    case 0x49u:
    case 0x4Au:
    case 0x4Bu:
    case 0x4Cu:
    case 0x4Du:
    case 0x4Eu:
    case 0x4Fu:
    case 0x50u:
    case 0x51u:
    case 0x52u:
    case 0x53u:
    case 0x54u:
    case 0x55u:
    case 0x56u:
    case 0x57u:
    case 0x58u:
    case 0x59u:
    case 0x5Au:
    case 0x5Du:
    case 0x5Fu:
    case 0x61u:
    case 0x62u:
    case 0x63u:
    case 0x64u:
    case 0x65u:
    case 0x66u:
    case 0x67u:
    case 0x68u:
    case 0x69u:
    case 0x6Au:
    case 0x6Bu:
    case 0x6Cu:
    case 0x6Du:
    case 0x6Eu:
    case 0x6Fu:
    case 0x70u:
    case 0x71u:
    case 0x72u:
    case 0x73u:
    case 0x74u:
    case 0x75u:
    case 0x76u:
    case 0x77u:
    case 0x78u:
    case 0x79u:
    case 0x7Au:
      v49 = 1;
      goto LABEL_195;
    case 0x27u:
      v43 = 1;
      v49 = 1;
      if ( a6 != 2 )
        goto LABEL_195;
      if ( v41 )
        goto LABEL_251;
      if ( a3 && !v55 )
      {
        v55 = a3;
        a3 = 0;
      }
      if ( v54 < a3 )
      {
        v10 = a2;
        *(_BYTE *)(a2 + v54) = 39;
      }
      if ( ++v54 < a3 )
      {
        v10 = a2;
        *(_BYTE *)(a2 + v54) = 92;
      }
      if ( ++v54 < a3 )
      {
        v10 = a2;
        *(_BYTE *)(a2 + v54) = 39;
      }
      ++v54;
      v42 = 0;
      goto LABEL_195;
    case 0x3Fu:
      if ( a6 == 2 )
      {
        if ( v41 )
          goto LABEL_251;
LABEL_195:
        if ( (v40 == 1 && a6 != 2 || v41 == 1)
          && a8
          && (v11 = v45 & 0x1F, v10 = *(_DWORD *)(4 * (v45 >> 5) + a8) >> v11, v10 & 1)
          || v47 == 1 )
        {
LABEL_201:
          if ( v41 )
            goto LABEL_251;
          v48 = 1;
          if ( a6 == 2 && v42 != 1 )
          {
            if ( v54 < a3 )
            {
              v10 = a2;
              *(_BYTE *)(a2 + v54) = 39;
            }
            if ( ++v54 < a3 )
            {
              v10 = a2;
              *(_BYTE *)(a2 + v54) = 36;
            }
            if ( ++v54 < a3 )
            {
              v10 = a2;
              *(_BYTE *)(a2 + v54) = 39;
            }
            ++v54;
            v42 = 1;
          }
          if ( v54 < a3 )
          {
            v10 = a2;
            *(_BYTE *)(a2 + v54) = 92;
          }
          ++v54;
        }
LABEL_214:
        if ( v42 && v48 != 1 )
        {
          if ( v54 < a3 )
          {
            v10 = a2;
            *(_BYTE *)(a2 + v54) = 39;
          }
          if ( ++v54 < a3 )
          {
            v10 = a2;
            *(_BYTE *)(a2 + v54) = 39;
          }
          ++v54;
          v42 = 0;
        }
        if ( v54 < a3 )
        {
          v10 = v54 + a2;
          *(_BYTE *)(v54 + a2) = v45;
        }
        ++v54;
        if ( v49 != 1 )
          v44 = 0;
LABEL_225:
        ++v53;
        goto LABEL_226;
      }
      if ( a6 != 5 )
        goto LABEL_195;
      if ( !(a7 & 4) )
        goto LABEL_195;
      if ( v53 + 2 >= a5 )
        goto LABEL_195;
      v10 = v53 + 1;
      if ( *(_BYTE *)(v53 + 1 + a4) != 63 )
        goto LABEL_195;
      v10 = v53 + 2;
      switch ( *(char *)(v53 + 2 + a4) )
      {
        case 33:
        case 39:
        case 40:
        case 41:
        case 45:
        case 47:
        case 60:
        case 61:
        case 62:
          _CF = 0;
          _OF = 0;
          _ZF = v41 == 0;
          _SF = v41 < 0;
          if ( !v41 )
          {
            v10 = v53 + 2;
            v45 = *(_BYTE *)(v53 + 2 + a4);
            v53 += 2;
            if ( v54 < a3 )
            {
              v10 = a2;
              *(_BYTE *)(a2 + v54) = 63;
            }
            if ( ++v54 < a3 )
            {
              v10 = a2;
              *(_BYTE *)(a2 + v54) = 34;
            }
            if ( ++v54 < a3 )
            {
              v10 = a2;
              *(_BYTE *)(a2 + v54) = 34;
            }
            if ( ++v54 < a3 )
            {
              v10 = a2;
              *(_BYTE *)(a2 + v54) = 63;
            }
            ++v54;
            goto LABEL_195;
          }
          __asm { pushfw }
          if ( a1 >= 10 )
          {
            v33 = _InterlockedExchange(&dword_805D1B4, a1);
            v32 = _InterlockedExchange(&dword_805D1B4, v11);
            _InterlockedExchange(&dword_805D1B4, v33);
            if ( ((_BYTE)a1 - 1) * v32 & 1 )
              abort();
          }
          __asm { popfw }
LABEL_251:
          if ( a6 == 2 && v40 )
            a6 = 4;
          return sub_80518CE(a2, a3, a4, a5, a6, a7 & 0xFFFFFFFD, 0, v39, v38);
        default:
          goto LABEL_195;
      }
    case 0x5Cu:
      v46 = *(_BYTE *)(a4 + v53);
      if ( a6 == 2 )
      {
        if ( v41 )
          goto LABEL_251;
        goto LABEL_214;
      }
      if ( v40 && v41 && n )
        goto LABEL_214;
LABEL_107:
      if ( a6 == 2 && v41 )
        goto LABEL_251;
LABEL_109:
      if ( v40 )
      {
        v45 = v46;
        goto LABEL_201;
      }
      goto LABEL_195;
    case 0x7Bu:
    case 0x7Du:
      if ( a5 == -1 )
        v34 = *(_BYTE *)(a4 + 1) != 0;
      else
        v34 = a5 != 1;
      if ( v34 )
        goto LABEL_195;
LABEL_116:
      if ( v53 )
        goto LABEL_195;
LABEL_117:
      v49 = 1;
LABEL_118:
      if ( a6 != 2 || !v41 )
        goto LABEL_195;
      goto LABEL_251;
    default:
      if ( v51 )
      {
        v58 = 1;
        v35 = __ctype_b_loc();
        v10 = 2 * v45;
        v50 = (*(const unsigned __int16 *)((char *)*v35 + v10) & 0x4000) != 0;
        goto LABEL_157;
      }
      memset(&ps, 0, 8u);
      v58 = 0;
      v50 = 1;
      if ( a5 == -1 )
        a5 = strlen((const char *)a4);
      while ( 2 )
      {
        v60 = sub_8055DBF(
                __CFADD__(a4, v58 + v53),
                a4 + v58 + v53 == 0,
                (signed int)(a4 + v58 + v53) < 0,
                __OFADD__(a4, v58 + v53),
                (signed __int32)&wc,
                a4 + v58 + v53,
                a1,
                (int)&savedregs,
                (wchar_t *)&wc,
                (const char *)(a4 + v58 + v53),
                a5 - (v58 + v53),
                &ps);
        if ( v60 )
        {
          if ( v60 == -1 )
          {
            v50 = 0;
          }
          else
          {
            if ( v60 != -2 )
            {
              if ( v41 && a6 == 2 )
              {
                v59 = 1;
                while ( v59 < v60 )
                {
                  switch ( *(char *)(v59 + v58 + v53 + a4) )
                  {
                    case 91:
                    case 92:
                    case 94:
                    case 96:
                    case 124:
                      goto LABEL_251;
                    default:
                      ++v59;
                      break;
                  }
                }
              }
              if ( !iswprint(wc) )
                v50 = 0;
              v58 += v60;
              if ( mbsinit(&ps) )
                break;
              continue;
            }
            v50 = 0;
            while ( 1 )
            {
              v10 = v53;
              if ( v53 + v58 >= a5 )
                break;
              v10 = v58 + v53;
              if ( !*(_BYTE *)(v58 + v53 + a4) )
                break;
              ++v58;
            }
          }
        }
        break;
      }
LABEL_157:
      v49 = v50;
      if ( v58 <= 1 && (!v40 || v50 == 1) )
        goto LABEL_195;
      v10 = v53;
      v61 = v53 + v58;
      while ( 1 )
      {
        if ( v40 && v50 != 1 )
        {
          if ( v41 )
            goto LABEL_251;
          v48 = 1;
          if ( a6 == 2 && v42 != 1 )
          {
            if ( v54 < a3 )
            {
              v10 = a2;
              *(_BYTE *)(a2 + v54) = 39;
            }
            if ( ++v54 < a3 )
            {
              v10 = a2;
              *(_BYTE *)(a2 + v54) = 36;
            }
            if ( ++v54 < a3 )
            {
              v10 = a2;
              *(_BYTE *)(a2 + v54) = 39;
            }
            ++v54;
            v42 = 1;
          }
          if ( v54 < a3 )
          {
            v10 = a2;
            *(_BYTE *)(a2 + v54) = 92;
          }
          if ( ++v54 < a3 )
          {
            v10 = v54 + a2;
            *(_BYTE *)(v54 + a2) = (v45 >> 6) + 48;
          }
          if ( ++v54 < a3 )
          {
            v10 = v54 + a2;
            *(_BYTE *)(v54 + a2) = ((v45 >> 3) & 7) + 48;
          }
          ++v54;
          v45 = (v45 & 7) + 48;
        }
        else if ( v47 )
        {
          if ( v54 < a3 )
          {
            v10 = a2;
            *(_BYTE *)(a2 + v54) = 92;
          }
          ++v54;
          v47 = 0;
        }
        if ( v53 + 1 >= v61 )
          goto LABEL_214;
        if ( v42 && v48 != 1 )
        {
          if ( v54 < a3 )
            *(_BYTE *)(a2 + v54) = 39;
          if ( ++v54 < a3 )
            *(_BYTE *)(a2 + v54) = 39;
          ++v54;
          v42 = 0;
        }
        if ( v54 < a3 )
          *(_BYTE *)(v54 + a2) = v45;
        ++v54;
        ++v53;
        v10 = a4;
        v45 = *(_BYTE *)(a4 + v53);
      }
  }
}
// 805D184: using guessed type int dword_805D184;
// 805D1B4: using guessed type int dword_805D1B4;

//----- (080525DF) --------------------------------------------------------
void *__cdecl sub_80525DF(signed __int32 a1, size_t a2, _DWORD *a3, int *a4)
{
  int *v4; // eax
  int v5; // ST54_4
  signed __int32 v6; // edx
  signed __int32 v11; // ebx
  signed __int32 v12; // edx
  signed __int32 v13; // ebx
  signed __int32 v14; // et0
  signed __int32 v15; // edx
  signed __int32 v16; // ecx
  signed __int32 v17; // ebx
  char v18; // al
  signed __int32 v19; // ebx
  char v20; // t2
  signed __int32 v21; // ecx
  signed __int32 v26; // ebx
  signed __int32 v27; // eax
  signed __int32 v28; // edx
  int v29; // ecx
  signed __int32 v30; // eax
  int *v32; // [esp+3Ch] [ebp-1Ch]
  int v33; // [esp+40h] [ebp-18h]
  unsigned int size; // [esp+48h] [ebp-10h]
  void *v35; // [esp+4Ch] [ebp-Ch]

  if ( a4 )
    v4 = a4;
  else
    v4 = &dword_805D802;
  v32 = v4;
  v33 = *__errno_location();
  v5 = v32[1] | (a3 == 0);
  size = sub_80518CE(
           (signed __int32)(v32 + 2),
           0,
           0,
           a1,
           a2,
           *v32,
           v5,
           (int)(v32 + 2),
           (char *)v32[10],
           (char *)v32[11])
       + 1;
  v35 = sub_8054C95((signed __int32)(v32 + 2), size);
  sub_80518CE(
    (signed __int32)(v32 + 2),
    (signed __int32)v35,
    size,
    a1,
    a2,
    *v32,
    v5,
    (int)(v32 + 2),
    (char *)v32[10],
    (char *)v32[11]);
  __asm { pushfw }
  _CF = (unsigned int)(v32 + 2) < 0xA;
  _OF = __OFSUB__(v32 + 2, 10);
  _ZF = v32 + 2 == (int *)10;
  _SF = (signed int)v32 - 2 < 0;
  if ( (signed int)(v32 + 2) >= 10 )
  {
    __asm { pushfw }
    v11 = _InterlockedExchange(&dword_805D124, (signed __int32)(v32 + 2));
    v14 = _InterlockedExchange(&dword_805D124, v6);
    v12 = v11;
    v13 = v14;
    _InterlockedExchange(&dword_805D124, v12);
    if ( sub_804972F() != 949 )
    {
      v17 = _InterlockedExchange(&dword_805D124, v13);
      _InterlockedExchange(&dword_805D124, v16);
      sub_8049739(_InterlockedExchange(&dword_805D124, v17), v15);
    }
    __asm { popfw }
    v18 = v13;
    v19 = _InterlockedExchange(&dword_805D16C, v13);
    v20 = _InterlockedExchange(&dword_805D16C, v15);
    _InterlockedExchange(&dword_805D16C, v19);
    if ( (v20 - 1) * v18 & 1 )
      abort();
  }
  __asm { popfw }
  *__errno_location() = v33;
  _CF = 0;
  _OF = 0;
  _ZF = a3 == 0;
  _SF = (signed int)a3 < 0;
  if ( a3 )
  {
    __asm { pushfw }
    v26 = _InterlockedExchange(&dword_805D10C, (signed __int32)(v32 + 2));
    _InterlockedExchange(&dword_805D10C, v21);
    _InterlockedExchange(&dword_805D10C, v26);
    v27 = sub_8049617();
    if ( v27 != -795 )
    {
      v30 = _InterlockedExchange(&dword_805D10C, v27);
      _InterlockedExchange(&dword_805D10C, v28);
      sub_8049621(v29, _InterlockedExchange(&dword_805D10C, v30));
    }
    __asm { popfw }
    *a3 = size - 1;
  }
  return v35;
}
// 8049621: using guessed type int __fastcall sub_8049621(_DWORD, _DWORD);
// 8049739: using guessed type int __fastcall sub_8049739(_DWORD, _DWORD);
// 805D10C: using guessed type int dword_805D10C;
// 805D124: using guessed type int dword_805D124;
// 805D16C: using guessed type int dword_805D16C;
// 805D802: using guessed type int dword_805D802;

//----- (080527A0) --------------------------------------------------------
signed int sub_80527A0()
{
  return 553;
}

//----- (080527AA) --------------------------------------------------------
void __usercall __noreturn sub_80527AA(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>)
{
  signed __int32 v6; // eax
  signed __int32 v7; // eax
  int v8; // edx
  signed __int32 v9; // ecx
  signed __int32 v10; // eax

  __asm { pushfw }
  v6 = _InterlockedExchange(&dword_805D124, a5);
  _InterlockedExchange(&dword_805D124, a6);
  _InterlockedExchange(&dword_805D124, v6);
  v7 = sub_804972F();
  if ( v7 != 949 )
  {
    v10 = _InterlockedExchange(&dword_805D124, v7);
    _InterlockedExchange(&dword_805D124, v9);
    sub_8049739(_InterlockedExchange(&dword_805D124, v10), v8);
  }
  __asm { popfw }
  __halt();
  JUMPOUT(loc_80527E8);
}
// 8049739: using guessed type int __fastcall sub_8049739(_DWORD, _DWORD);
// 805D124: using guessed type int dword_805D124;

//----- (080528BF) --------------------------------------------------------
void *__usercall sub_80528BF@<eax>(signed __int32 a1@<ebx>, signed int a2, signed __int32 a3, size_t a4, int a5)
{
  signed __int32 v5; // ecx
  int *v6; // eax
  int *v7; // eax
  void *v8; // edx
  signed __int32 v13; // ecx
  char v14; // al
  signed __int32 v15; // et0
  signed __int32 v16; // ebx
  unsigned int v18; // [esp-4h] [ebp-5Ch]
  bool v19; // [esp+37h] [ebp-21h]
  int *v20; // [esp+38h] [ebp-20h]
  void *ptr; // [esp+3Ch] [ebp-1Ch]
  int v22; // [esp+40h] [ebp-18h]
  int size; // [esp+44h] [ebp-14h]
  size_t sizea; // [esp+44h] [ebp-14h]
  int v25; // [esp+48h] [ebp-10h]

  v22 = *__errno_location();
  v20 = off_805D208;
  if ( a2 < 0 )
    abort();
  if ( dword_805D1FC <= a2 )
  {
    v19 = off_805D208 == &dword_805D200;
    if ( (unsigned int)a2 > 0xFFFFFFE )
      sub_805517D(a1);
    if ( v19 )
      v6 = 0;
    else
      v6 = off_805D208;
    v7 = (int *)sub_8054E03(
                  0,
                  off_805D208 != &dword_805D200,
                  (off_805D208 == &dword_805D200) < 0,
                  0,
                  (signed __int32)v6,
                  8 * (a2 + 1),
                  v5,
                  a1,
                  v6,
                  8 * (a2 + 1));
    v20 = v7;
    off_805D208 = v7;
    if ( v19 )
    {
      v8 = off_805D204;
      *v7 = dword_805D200;
      v7[1] = (int)v8;
    }
    memset(&v7[2 * dword_805D1FC], 0, 8 * (a2 + 1 - dword_805D1FC));
    dword_805D1FC = a2 + 1;
  }
  sizea = v20[2 * a2];
  ptr = (void *)v20[2 * a2 + 1];
  v25 = *(_DWORD *)(a5 + 4) | 1;
  v18 = sub_80518CE(
          a5 + 8,
          v20[2 * a2 + 1],
          v20[2 * a2],
          a3,
          a4,
          *(_DWORD *)a5,
          v25,
          a5 + 8,
          *(char **)(a5 + 40),
          *(char **)(a5 + 44));
  __asm { pushfw }
  if ( a5 + 8 >= 10 )
  {
    v15 = _InterlockedExchange(&dword_805D190, a5 + 8);
    v14 = _InterlockedExchange(&dword_805D190, v13);
    _InterlockedExchange(&dword_805D190, v15);
    if ( ((_BYTE)a5 + 7) * v14 & 1 )
      abort();
  }
  __asm { popfw }
  if ( sizea <= v18 )
  {
    size = v18 + 1;
    v20[2 * a2] = v18 + 1;
    if ( ptr != &unk_805D842 )
      free(ptr);
    v16 = (signed __int32)&v20[2 * a2];
    ptr = sub_8054C95(v16, size);
    *(_DWORD *)(v16 + 4) = ptr;
    sub_80518CE(
      a5 + 8,
      (signed __int32)ptr,
      size,
      a3,
      a4,
      *(_DWORD *)a5,
      v25,
      a5 + 8,
      *(char **)(a5 + 40),
      *(char **)(a5 + 44));
  }
  *__errno_location() = v22;
  return ptr;
}
// 805D190: using guessed type int dword_805D190;
// 805D1FC: using guessed type int dword_805D1FC;
// 805D200: using guessed type int dword_805D200;
// 805D204: using guessed type void *off_805D204;
// 805D208: using guessed type int *off_805D208;

//----- (08052BAC) --------------------------------------------------------
signed __int32 __usercall sub_8052BAC@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>, signed int a7, signed __int32 a8)
{
  char v8; // al
  signed __int32 v9; // ebx
  char v10; // t0
  void *v11; // eax
  signed __int32 v12; // eax
  signed __int32 v13; // edx
  signed __int32 v14; // ecx
  unsigned __int32 v15; // eax
  signed __int32 v16; // edx
  signed __int32 v17; // ecx
  bool v18; // cf
  bool v19; // zf
  bool v20; // sf
  char v21; // of
  signed __int32 v22; // eax
  signed __int32 v23; // ebx
  signed __int32 v24; // ecx
  signed __int32 v25; // ebx
  signed __int32 v26; // ett
  unsigned int v27; // eax
  signed __int32 v28; // edx
  signed __int32 v29; // ecx
  char v34; // al
  signed __int32 v35; // ebx
  char v36; // t0
  signed __int32 v37; // ebx
  signed __int32 v38; // ecx
  signed __int32 v39; // ebx
  signed __int32 v40; // et1
  unsigned __int32 v41; // eax
  signed __int32 v42; // edx
  signed __int32 v43; // ebx
  signed __int32 v44; // ecx
  signed __int32 v45; // ebx
  signed __int32 v46; // et0
  signed __int32 v47; // ecx
  signed __int32 v48; // eax
  signed __int32 v49; // et1
  signed __int32 v50; // edx
  unsigned int v51; // eax
  signed __int32 v52; // edx
  signed __int32 v53; // ecx
  signed __int32 v58; // ebx
  signed __int32 v59; // et2
  signed __int32 v60; // eax
  unsigned int v61; // eax
  signed __int32 v62; // edx
  signed __int32 v63; // ecx
  signed __int32 v64; // eax
  signed __int32 v66; // [esp-10h] [ebp-2Ch]
  signed __int32 v67; // [esp-Ah] [ebp-26h]
  unsigned __int32 v68; // [esp-Ah] [ebp-26h]
  signed __int32 v69; // [esp-4h] [ebp-20h]
  signed __int32 v70; // [esp+12h] [ebp-Ah]

  __asm { pushfw }
  v70 = a6;
  if ( a6 >= 10 )
  {
    v8 = a6;
    v9 = _InterlockedExchange(&dword_805D1A8, a6);
    v10 = _InterlockedExchange(&dword_805D1A8, a5);
    _InterlockedExchange(&dword_805D1A8, v9);
    if ( (v10 - 1) * v8 & 1 )
      abort();
  }
  __asm { popfw }
  v11 = sub_80528BF(v70, a7, a8, 0xFFFFFFFF, (int)&dword_805D802);
  v69 = (signed __int32)v11;
  __asm { pushfw }
  v12 = _InterlockedExchange(&dword_805D184, (signed __int32)v11);
  _InterlockedExchange(&dword_805D184, v13);
  v15 = sub_804C065(_CF, _ZF, _SF, _OF, _InterlockedExchange(&dword_805D184, v12), v14, v70);
  v18 = v15 < 0x12C;
  v21 = __OFSUB__(v15, 300);
  v19 = v15 == 300;
  v20 = (signed int)(v15 - 300) < 0;
  if ( v15 != 300 )
  {
    v22 = _InterlockedExchange(&dword_805D184, v15);
    _InterlockedExchange(&dword_805D184, v16);
    sub_804C18B(v18, v19, v20, v21, _InterlockedExchange(&dword_805D184, v22), v17, v70);
  }
  __asm
  {
    popfw
    pushfw
  }
  v23 = _InterlockedExchange(&dword_805D19C, v70);
  v26 = _InterlockedExchange(&dword_805D19C, v17);
  v24 = v23;
  v25 = v26;
  _InterlockedExchange(&dword_805D19C, v24);
  v27 = sub_804B771(_CF, _ZF, _SF, _OF, v69, v16, v26);
  _CF = v27 < 0xFFFFFEAA;
  _OF = __OFSUB__(v27, -342);
  _ZF = v27 == -342;
  _SF = (signed int)(v27 + 342) < 0;
  if ( v27 != -342 )
  {
    v67 = v27;
    __asm { pushfw }
    v66 = v25;
    if ( v25 >= 10 )
    {
      v34 = v25;
      v35 = _InterlockedExchange(&dword_805D124, v25);
      v36 = _InterlockedExchange(&dword_805D124, v29);
      v29 = _InterlockedExchange(&dword_805D124, v35);
      if ( (v36 - 1) * v34 & 1 )
        abort();
    }
    __asm
    {
      popfw
      pushfw
    }
    v37 = _InterlockedExchange(&dword_805D130, v66);
    v40 = _InterlockedExchange(&dword_805D130, v29);
    v38 = v37;
    v39 = v40;
    _InterlockedExchange(&dword_805D130, v38);
    v41 = sub_80527A0();
    if ( v41 != 553 )
      sub_80527AA(
        v41 < 0x229,
        v41 == 553,
        (signed int)(v41 - 553) < 0,
        __OFSUB__(v41, 553),
        _InterlockedExchange(&dword_805D130, v42),
        _InterlockedExchange(&dword_805D130, _InterlockedExchange(&dword_805D130, v41)));
    __asm { popfw }
    sub_804B82B(
      _CF,
      _ZF,
      _SF,
      _OF,
      v67,
      _InterlockedExchange(&dword_805D19C, _InterlockedExchange(&dword_805D19C, v39)),
      _InterlockedExchange(&dword_805D19C, v42));
  }
  __asm
  {
    popfw
    pushfw
  }
  v43 = _InterlockedExchange(&dword_805D1C0, v25);
  v46 = _InterlockedExchange(&dword_805D1C0, v29);
  v44 = v43;
  v45 = v46;
  v68 = sub_8054904(_CF, _ZF, _SF, _OF, v28, _InterlockedExchange(&dword_805D1C0, v44), v46);
  __asm { pushfw }
  v49 = _InterlockedExchange(&dword_805D1A8, v68);
  v48 = _InterlockedExchange(&dword_805D1A8, v47);
  _InterlockedExchange(&dword_805D1A8, v49);
  v51 = sub_80571DD(_CF, _ZF, _SF, _OF, v48, v50, v46);
  _CF = v51 < 0xFFFFFDFB;
  _OF = __OFSUB__(v51, -517);
  _ZF = v51 == -517;
  _SF = (signed int)(v51 + 517) < 0;
  if ( v51 != -517 )
  {
    v58 = _InterlockedExchange(&dword_805D1A8, v45);
    v59 = _InterlockedExchange(&dword_805D1A8, v52);
    _InterlockedExchange(&dword_805D1A8, v58);
    sub_8057259(v51 < 0xFFFFFDFB, v51 == -517, (signed int)(v51 + 517) < 0, __OFSUB__(v51, -517), v53, v59);
  }
  __asm { pushfw }
  v60 = _InterlockedExchange(&dword_805D178, -517);
  _InterlockedExchange(&dword_805D178, v52);
  _InterlockedExchange(&dword_805D178, v60);
  v61 = sub_804A5EF();
  if ( v61 != 421 )
    sub_804A5F9(
      v61 < 0x1A5,
      v61 == 421,
      (signed int)(v61 - 421) < 0,
      __OFSUB__(v61, 421),
      _InterlockedExchange(&dword_805D178, _InterlockedExchange(&dword_805D178, v45)),
      _InterlockedExchange(&dword_805D178, v62));
  __asm
  {
    popfw
    popfw
  }
  if ( v68 != 655 )
  {
    v64 = _InterlockedExchange(&dword_805D1C0, v68);
    _InterlockedExchange(&dword_805D1C0, v63);
    sub_8054A34(
      v68 < 0x28F,
      v68 == 655,
      (signed int)(v68 - 655) < 0,
      __OFSUB__(v68, 655),
      _InterlockedExchange(&dword_805D1C0, v64),
      v45);
  }
  __asm { popfw }
  return v69;
}
// 8052BAC: could not find valid save-restore pair for ebp
// 805D124: using guessed type int dword_805D124;
// 805D130: using guessed type int dword_805D130;
// 805D178: using guessed type int dword_805D178;
// 805D184: using guessed type int dword_805D184;
// 805D19C: using guessed type int dword_805D19C;
// 805D1A8: using guessed type int dword_805D1A8;
// 805D1C0: using guessed type int dword_805D1C0;
// 805D802: using guessed type int dword_805D802;

//----- (08052DB8) --------------------------------------------------------
void *__usercall sub_8052DB8@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>, signed int a8, signed __int32 a9, size_t a10)
{
  signed __int32 v10; // eax
  signed __int32 v11; // eax
  signed __int32 v12; // edx
  int v13; // ecx
  signed __int32 v14; // eax
  char v15; // al
  signed __int32 v16; // et2

  __asm { pushfw }
  v10 = _InterlockedExchange(&dword_805D13C, a5);
  _InterlockedExchange(&dword_805D13C, a6);
  _InterlockedExchange(&dword_805D13C, v10);
  v11 = sub_8055DB4();
  if ( v11 != -64 )
  {
    v14 = _InterlockedExchange(&dword_805D13C, v11);
    _InterlockedExchange(&dword_805D13C, v12);
    sub_8055DBE(v13, _InterlockedExchange(&dword_805D13C, v14));
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( a7 >= 10 )
  {
    v16 = _InterlockedExchange(&dword_805D16C, a7);
    v15 = _InterlockedExchange(&dword_805D16C, v12);
    _InterlockedExchange(&dword_805D16C, v16);
    if ( ((_BYTE)a7 - 1) * v15 & 1 )
      abort();
  }
  __asm { popfw }
  return sub_80528BF(a7, a8, a9, a10, (int)&dword_805D802);
}
// 8052DB8: could not find valid save-restore pair for ebp
// 8055DBE: using guessed type int __fastcall sub_8055DBE(_DWORD, _DWORD);
// 805D13C: using guessed type int dword_805D13C;
// 805D16C: using guessed type int dword_805D16C;
// 805D802: using guessed type int dword_805D802;

//----- (08052FEE) --------------------------------------------------------
void *__usercall sub_8052FEE@<eax>(signed __int32 a1@<ebx>, signed int a2, unsigned __int32 a3, signed __int32 a4)
{
  char v4; // sf
  char v6; // [esp+10h] [ebp-38h]

  sub_805158D(0, 0, v4, 0, (signed __int32)&v6, a3, a1, (unsigned int *)&v6, a3);
  return sub_80528BF(a1, a2, a4, 0xFFFFFFFF, (int)&v6);
}

//----- (0805302C) --------------------------------------------------------
void *__usercall sub_805302C@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>, int a8@<ebp>, signed int a9, unsigned __int32 a10, signed __int32 a11, size_t a12)
{
  signed __int32 v12; // eax
  unsigned __int32 v13; // eax
  signed __int32 v14; // edx
  signed __int32 v19; // eax
  signed __int32 v20; // edx
  signed __int32 v21; // ecx
  signed __int32 v22; // ebx
  signed __int32 v23; // eax
  int v25; // [esp+10h] [ebp-3Ch]
  int v26; // [esp+42h] [ebp-Ah]
  int v27; // [esp+48h] [ebp-4h]

  v27 = a5;
  __asm { pushfw }
  v12 = _InterlockedExchange(&dword_805D13C, a5);
  _InterlockedExchange(&dword_805D13C, a6);
  _InterlockedExchange(&dword_805D13C, v12);
  v13 = sub_8055DB4();
  _CF = v13 < 0xFFFFFFC0;
  _OF = __OFSUB__(v13, -64);
  _ZF = v13 == -64;
  _SF = (signed int)(v13 + 64) < 0;
  if ( v13 != -64 )
  {
    v26 = v13;
    __asm { pushfw }
    v19 = _InterlockedExchange(&dword_805D124, v13);
    _InterlockedExchange(&dword_805D124, v14);
    _InterlockedExchange(&dword_805D124, v19);
    if ( sub_804972F() != 949 )
    {
      v22 = _InterlockedExchange(&dword_805D124, a7);
      _InterlockedExchange(&dword_805D124, v21);
      sub_8049739(_InterlockedExchange(&dword_805D124, v22), v20);
    }
    __asm { popfw }
    v23 = _InterlockedExchange(&dword_805D13C, v26);
    _InterlockedExchange(&dword_805D13C, v20);
    sub_8055DBE(v21, _InterlockedExchange(&dword_805D13C, v23));
  }
  __asm { popfw }
  v27 = a8;
  sub_805158D(
    (unsigned int)&v27 < 0x48,
    &v27 == 0,
    (signed int)&v27 < 0,
    __OFSUB__(&v27, 72),
    (signed __int32)&v25,
    a10,
    a7,
    (unsigned int *)&v25,
    a10);
  return sub_80528BF(a7, a9, a11, a12, (int)&v25);
}
// 805302C: could not find valid save-restore pair for ebp
// 8049739: using guessed type int __fastcall sub_8049739(_DWORD, _DWORD);
// 8055DBE: using guessed type int __fastcall sub_8055DBE(_DWORD, _DWORD);
// 805D124: using guessed type int dword_805D124;
// 805D13C: using guessed type int dword_805D13C;

//----- (08053215) --------------------------------------------------------
void *__usercall sub_8053215@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, int a8@<ebp>, signed __int32 a9, size_t a10, unsigned __int8 a11)
{
  char v15; // al
  signed __int32 v16; // et0
  char v17; // al
  signed __int32 v18; // et1
  int v20; // [esp+20h] [ebp-3Ch]
  int v21; // [esp+24h] [ebp-38h]
  int v22; // [esp+28h] [ebp-34h]
  int v23; // [esp+2Ch] [ebp-30h]
  int v24; // [esp+30h] [ebp-2Ch]
  int v25; // [esp+34h] [ebp-28h]
  int v26; // [esp+38h] [ebp-24h]
  int v27; // [esp+3Ch] [ebp-20h]
  int v28; // [esp+40h] [ebp-1Ch]
  int v29; // [esp+44h] [ebp-18h]
  int v30; // [esp+48h] [ebp-14h]
  char v31[6]; // [esp+4Ch] [ebp-10h]
  int v32; // [esp+58h] [ebp-4h]

  v32 = a5;
  __asm { pushfw }
  _CF = (unsigned int)a7 < 0xA;
  _OF = __OFSUB__(a7, 10);
  _ZF = a7 == 10;
  _SF = a7 - 10 < 0;
  if ( a7 >= 10 )
  {
    *(_DWORD *)&v31[2] = a5;
    __asm { pushfw }
    v30 = a7;
    if ( a7 >= 10 )
    {
      v16 = _InterlockedExchange(&dword_805D160, a7);
      v15 = _InterlockedExchange(&dword_805D160, a6);
      a6 = _InterlockedExchange(&dword_805D160, v16);
      if ( ((_BYTE)a7 - 1) * v15 & 1 )
        abort();
    }
    __asm { popfw }
    v18 = _InterlockedExchange(&dword_805D1A8, v30);
    v17 = _InterlockedExchange(&dword_805D1A8, a6);
    _InterlockedExchange(&dword_805D1A8, v18);
    if ( ((_BYTE)v30 - 1) * v17 & 1 )
      abort();
  }
  __asm { popfw }
  v32 = a8;
  v20 = dword_805D802;
  v21 = dword_805D806;
  v22 = dword_805D80A;
  v23 = dword_805D80E;
  v24 = dword_805D812;
  v25 = dword_805D816;
  v26 = dword_805D81A;
  v27 = dword_805D81E;
  v28 = dword_805D822;
  v29 = dword_805D826;
  v30 = dword_805D82A;
  *(_DWORD *)v31 = dword_805D82E;
  sub_80511DA(&v20, a11, 1);
  return sub_80528BF(a7, 0, a9, a10, (int)&v20);
}
// 8053215: could not find valid save-restore pair for ebp
// 805D160: using guessed type int dword_805D160;
// 805D1A8: using guessed type int dword_805D1A8;
// 805D802: using guessed type int dword_805D802;
// 805D806: using guessed type int dword_805D806;
// 805D80A: using guessed type int dword_805D80A;
// 805D80E: using guessed type int dword_805D80E;
// 805D812: using guessed type int dword_805D812;
// 805D816: using guessed type int dword_805D816;
// 805D81A: using guessed type int dword_805D81A;
// 805D81E: using guessed type int dword_805D81E;
// 805D822: using guessed type int dword_805D822;
// 805D826: using guessed type int dword_805D826;
// 805D82A: using guessed type int dword_805D82A;
// 805D82E: using guessed type int dword_805D82E;

//----- (08053327) --------------------------------------------------------
void *__usercall sub_8053327@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, int a3, unsigned __int8 a4)
{
  signed __int32 v4; // ebx
  signed __int32 v5; // edx
  signed __int32 v6; // edx
  signed __int32 v7; // ebx
  signed __int32 v8; // et0
  unsigned __int32 v9; // eax
  signed __int32 v10; // edx
  signed __int32 v11; // ecx
  signed __int32 v16; // eax
  char v17; // al
  signed __int32 v18; // ebx
  signed __int32 v19; // et2
  signed __int32 v20; // ebx
  int v21; // eax
  char v26; // al
  signed __int32 v27; // ett
  signed __int32 v28; // ebx
  signed __int32 v29; // ecx
  signed __int32 v30; // ebx
  signed __int32 v31; // et0
  signed __int32 v32; // edx
  signed __int32 v33; // ecx
  char v34; // al
  signed __int32 v35; // ebx
  char v36; // t1
  char v37; // al
  signed __int32 v38; // et2
  signed __int32 v39; // eax
  signed __int32 v41; // [esp-10h] [ebp-28h]
  signed __int32 v42; // [esp-Ah] [ebp-22h]
  unsigned __int32 v43; // [esp-Ah] [ebp-22h]
  void *v44; // [esp-4h] [ebp-1Ch]
  int savedregs; // [esp+18h] [ebp+0h]

  v44 = sub_8053215(0, 0, _SF, 0, a3, a1, a2, (int)&savedregs, a3, 0xFFFFFFFF, a4);
  __asm { pushfw }
  v4 = _InterlockedExchange(&dword_805D178, a2);
  v8 = _InterlockedExchange(&dword_805D178, v5);
  v6 = v4;
  v7 = v8;
  _InterlockedExchange(&dword_805D178, v6);
  v9 = sub_804A5EF();
  _CF = v9 < 0x1A5;
  _OF = __OFSUB__(v9, 421);
  _ZF = v9 == 421;
  _SF = (signed int)(v9 - 421) < 0;
  if ( v9 != 421 )
  {
    v16 = _InterlockedExchange(&dword_805D178, v9);
    _InterlockedExchange(&dword_805D178, v11);
    _InterlockedExchange(&dword_805D178, v16);
    sub_804A5F9(_CF, _ZF, _SF, _OF, v10, v7);
  }
  __asm
  {
    popfw
    pushfw
  }
  v42 = v7;
  if ( v7 >= 10 )
  {
    v17 = v7;
    v18 = _InterlockedExchange(&dword_805D1A8, v7);
    v19 = _InterlockedExchange(&dword_805D1A8, v10);
    v10 = _InterlockedExchange(&dword_805D1A8, v18);
    v20 = v19 - 1;
    v21 = ((_BYTE)v19 - 1) * v17 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = v21 == 0;
    _SF = v21 < 0;
    if ( v21 )
    {
      __asm { pushfw }
      if ( v20 >= 10 )
      {
        v27 = _InterlockedExchange(&dword_805D154, v20);
        v26 = _InterlockedExchange(&dword_805D154, v11);
        _InterlockedExchange(&dword_805D154, v27);
        if ( ((_BYTE)v20 - 1) * v26 & 1 )
          abort();
      }
      __asm { popfw }
      abort();
    }
  }
  __asm
  {
    popfw
    pushfw
  }
  v28 = _InterlockedExchange(&dword_805D1C0, v42);
  v31 = _InterlockedExchange(&dword_805D1C0, v11);
  v29 = v28;
  v30 = v31;
  v43 = sub_8054904(_CF, _ZF, _SF, _OF, v10, _InterlockedExchange(&dword_805D1C0, v29), v31);
  __asm { pushfw }
  v41 = v31;
  if ( v31 >= 10 )
  {
    v34 = v30;
    v35 = _InterlockedExchange(&dword_805D148, v30);
    v36 = _InterlockedExchange(&dword_805D148, v32);
    _InterlockedExchange(&dword_805D148, v35);
    if ( (v36 - 1) * v34 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( v41 >= 10 )
  {
    v38 = _InterlockedExchange(&dword_805D184, v41);
    v37 = _InterlockedExchange(&dword_805D184, v33);
    v33 = _InterlockedExchange(&dword_805D184, v38);
    if ( ((_BYTE)v41 - 1) * v37 & 1 )
      abort();
  }
  __asm { popfw }
  if ( v43 != 655 )
  {
    v39 = _InterlockedExchange(&dword_805D1C0, v43);
    _InterlockedExchange(&dword_805D1C0, v33);
    sub_8054A34(
      v43 < 0x28F,
      v43 == 655,
      (signed int)(v43 - 655) < 0,
      __OFSUB__(v43, 655),
      _InterlockedExchange(&dword_805D1C0, v39),
      v41);
  }
  __asm { popfw }
  return v44;
}
// 805D148: using guessed type int dword_805D148;
// 805D154: using guessed type int dword_805D154;
// 805D178: using guessed type int dword_805D178;
// 805D184: using guessed type int dword_805D184;
// 805D1A8: using guessed type int dword_805D1A8;
// 805D1C0: using guessed type int dword_805D1C0;

//----- (0805349E) --------------------------------------------------------
void *__usercall sub_805349E@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, int a3)
{
  return sub_8053327(a1, a2, a3, 0x3Au);
}

//----- (080535C8) --------------------------------------------------------
void *__usercall sub_80535C8@<eax>(signed __int32 a1@<ebx>, signed int a2, unsigned __int32 a3, signed __int32 a4)
{
  int v5; // eax
  signed __int32 v9; // eax
  signed __int32 v10; // edx
  signed __int32 v11; // edx
  signed __int32 v12; // ecx
  char v13; // al
  signed __int32 v14; // et1
  signed __int32 v15; // ebx
  unsigned __int32 v17; // [esp-Ah] [ebp-82h]
  int v18; // [esp+10h] [ebp-68h]
  int v19; // [esp+14h] [ebp-64h]
  int v20; // [esp+18h] [ebp-60h]
  int v21; // [esp+1Ch] [ebp-5Ch]
  int v22; // [esp+20h] [ebp-58h]
  int v23; // [esp+24h] [ebp-54h]
  int v24; // [esp+28h] [ebp-50h]
  int v25; // [esp+2Ch] [ebp-4Ch]
  int v26; // [esp+30h] [ebp-48h]
  int v27; // [esp+34h] [ebp-44h]
  int v28; // [esp+38h] [ebp-40h]
  int v29; // [esp+3Ch] [ebp-3Ch]
  int v30; // [esp+40h] [ebp-38h]
  int v31; // [esp+44h] [ebp-34h]
  int v32; // [esp+48h] [ebp-30h]
  int v33; // [esp+4Ch] [ebp-2Ch]
  int v34; // [esp+50h] [ebp-28h]
  int v35; // [esp+54h] [ebp-24h]
  int v36; // [esp+58h] [ebp-20h]
  int v37; // [esp+5Ch] [ebp-1Ch]
  int v38; // [esp+60h] [ebp-18h]
  int v39; // [esp+64h] [ebp-14h]
  int v40; // [esp+68h] [ebp-10h]
  int v41; // [esp+6Ch] [ebp-Ch]

  sub_805158D(0, 0, _SF, 0, (signed __int32)&v18, a3, a1, (unsigned int *)&v18, a3);
  v30 = v18;
  v31 = v19;
  v32 = v20;
  v33 = v21;
  v34 = v22;
  v35 = v23;
  v36 = v24;
  v37 = v25;
  v38 = v26;
  v39 = v27;
  v40 = v28;
  v41 = v29;
  v5 = sub_80511DA(&v30, 0x3Au, 1);
  __asm { pushfw }
  v9 = _InterlockedExchange(&dword_805D130, v5);
  _InterlockedExchange(&dword_805D130, v10);
  _InterlockedExchange(&dword_805D130, v9);
  v17 = sub_80527A0();
  __asm { pushfw }
  if ( a1 >= 10 )
  {
    v14 = _InterlockedExchange(&dword_805D118, a1);
    v13 = _InterlockedExchange(&dword_805D118, v12);
    _InterlockedExchange(&dword_805D118, v14);
    if ( ((_BYTE)a1 - 1) * v13 & 1 )
      abort();
  }
  __asm { popfw }
  if ( v17 != 553 )
  {
    v15 = _InterlockedExchange(&dword_805D130, a1);
    _InterlockedExchange(&dword_805D130, v11);
    sub_80527AA(
      v17 < 0x229,
      v17 == 553,
      (signed int)(v17 - 553) < 0,
      __OFSUB__(v17, 553),
      v17,
      _InterlockedExchange(&dword_805D130, v15));
  }
  __asm { popfw }
  return sub_80528BF(a1, a2, a4, 0xFFFFFFFF, (int)&v30);
}
// 805D118: using guessed type int dword_805D118;
// 805D130: using guessed type int dword_805D130;

//----- (08053778) --------------------------------------------------------
void *__usercall sub_8053778@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, int a9@<ebp>, int a10, int a11, int a12, signed __int32 a13)
{
  char v13; // al
  signed __int32 v14; // ebx
  signed __int32 v15; // et0
  signed __int32 v16; // ebx
  int v17; // eax
  char v22; // al
  signed __int32 v23; // et1
  signed __int32 v24; // edx
  signed __int32 v25; // ebx
  char v26; // t2
  signed __int32 v31; // eax
  int v32; // edx
  signed __int32 v33; // ecx
  signed __int32 v34; // ebx
  signed __int32 v35; // ebx
  char v36; // t1
  void *v38; // [esp-4h] [ebp-30h]
  signed __int32 v39; // [esp+22h] [ebp-Ah]
  int v40; // [esp+28h] [ebp-4h]

  v40 = a5;
  __asm { pushfw }
  v39 = a8;
  if ( a8 >= 10 )
  {
    v13 = a8;
    v14 = _InterlockedExchange(&dword_805D1B4, a8);
    v15 = _InterlockedExchange(&dword_805D1B4, a7);
    a7 = _InterlockedExchange(&dword_805D1B4, v14);
    v16 = v15 - 1;
    v17 = ((_BYTE)v15 - 1) * v13 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = v17 == 0;
    _SF = v17 < 0;
    if ( v17 )
    {
      __asm { pushfw }
      if ( v16 >= 10 )
      {
        v23 = _InterlockedExchange(&dword_805D190, v16);
        v22 = _InterlockedExchange(&dword_805D190, a6);
        _InterlockedExchange(&dword_805D190, v23);
        if ( ((_BYTE)v16 - 1) * v22 & 1 )
          abort();
      }
      __asm { popfw }
      abort();
    }
  }
  __asm { popfw }
  v40 = a9;
  v38 = sub_80538B9(
          (unsigned int)&v40 < 0x28,
          &v40 == 0,
          (signed int)&v40 < 0,
          __OFSUB__(&v40, 40),
          a10,
          a6,
          a7,
          v39,
          (int)&v40,
          a10,
          a11,
          a12,
          a13,
          0xFFFFFFFF);
  __asm { pushfw }
  if ( v39 >= 10 )
  {
    v25 = _InterlockedExchange(&dword_805D13C, v39);
    v26 = _InterlockedExchange(&dword_805D13C, v24);
    v24 = _InterlockedExchange(&dword_805D13C, v25);
    if ( (v26 - 1) * (_BYTE)v39 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  _CF = (unsigned int)v39 < 0xA;
  _OF = __OFSUB__(v39, 10);
  _ZF = v39 == 10;
  _SF = v39 - 10 < 0;
  if ( v39 >= 10 )
  {
    __asm { pushfw }
    v31 = _InterlockedExchange(&dword_805D124, (signed __int32)v38);
    _InterlockedExchange(&dword_805D124, v24);
    _InterlockedExchange(&dword_805D124, v31);
    if ( sub_804972F() != 949 )
    {
      v34 = _InterlockedExchange(&dword_805D124, v39);
      _InterlockedExchange(&dword_805D124, v33);
      sub_8049739(_InterlockedExchange(&dword_805D124, v34), v32);
    }
    __asm { popfw }
    v35 = _InterlockedExchange(&dword_805D148, v39);
    v36 = _InterlockedExchange(&dword_805D148, v33);
    _InterlockedExchange(&dword_805D148, v35);
    if ( (v36 - 1) * (_BYTE)v39 & 1 )
      abort();
  }
  __asm { popfw }
  return v38;
}
// 8053778: could not find valid save-restore pair for ebx
// 8053778: could not find valid save-restore pair for ebp
// 8049739: using guessed type int __fastcall sub_8049739(_DWORD, _DWORD);
// 805D124: using guessed type int dword_805D124;
// 805D13C: using guessed type int dword_805D13C;
// 805D148: using guessed type int dword_805D148;
// 805D190: using guessed type int dword_805D190;
// 805D1B4: using guessed type int dword_805D1B4;

//----- (080538B9) --------------------------------------------------------
void *__usercall sub_80538B9@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, int a9@<ebp>, signed int a10, int a11, int a12, signed __int32 a13, size_t a14)
{
  char v14; // al
  signed __int32 v15; // et0
  signed __int32 v16; // ebx
  char v17; // t1
  signed __int32 v18; // ebx
  signed __int32 v19; // ebx
  signed __int32 v20; // ecx
  signed __int32 v21; // ecx
  signed __int32 v22; // ebx
  signed __int32 v23; // et2
  signed __int32 v24; // eax
  int v25; // edx
  signed __int32 v26; // ecx
  signed __int32 v27; // eax
  int v29; // [esp+10h] [ebp-3Ch]
  int v30; // [esp+14h] [ebp-38h]
  int v31; // [esp+18h] [ebp-34h]
  int v32; // [esp+1Ch] [ebp-30h]
  int v33; // [esp+20h] [ebp-2Ch]
  int v34; // [esp+24h] [ebp-28h]
  int v35; // [esp+28h] [ebp-24h]
  int v36; // [esp+2Ch] [ebp-20h]
  int v37; // [esp+30h] [ebp-1Ch]
  int v38; // [esp+34h] [ebp-18h]
  int v39; // [esp+38h] [ebp-14h]
  int v40; // [esp+3Ch] [ebp-10h]
  int v41; // [esp+42h] [ebp-Ah]
  int v42; // [esp+48h] [ebp-4h]

  v42 = a5;
  __asm { pushfw }
  v41 = a8;
  if ( a8 >= 10 )
  {
    v15 = _InterlockedExchange(&dword_805D178, a8);
    v14 = _InterlockedExchange(&dword_805D178, a7);
    a7 = _InterlockedExchange(&dword_805D178, v15);
    if ( ((_BYTE)a8 - 1) * v14 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( v41 >= 10 )
  {
    v16 = _InterlockedExchange(&dword_805D1B4, v41);
    v17 = _InterlockedExchange(&dword_805D1B4, a6);
    a6 = _InterlockedExchange(&dword_805D1B4, v16);
    if ( (v17 - 1) * (_BYTE)v41 & 1 )
      abort();
  }
  v18 = v41;
  __asm { popfw }
  v42 = a9;
  v29 = dword_805D802;
  v30 = dword_805D806;
  v31 = dword_805D80A;
  v32 = dword_805D80E;
  v33 = dword_805D812;
  v34 = dword_805D816;
  v35 = dword_805D81A;
  v36 = dword_805D81E;
  v37 = dword_805D822;
  v38 = dword_805D826;
  v39 = dword_805D82A;
  v40 = dword_805D82E;
  sub_805136F(
    (unsigned int)&v42 < 0x48,
    &v42 == 0,
    (signed int)&v42 < 0,
    __OFSUB__(&v42, 72),
    (signed __int32)&v29,
    a6,
    a7,
    v41,
    &v29,
    a11,
    a12);
  __asm { pushfw }
  v19 = _InterlockedExchange(&dword_805D10C, v18);
  v23 = _InterlockedExchange(&dword_805D10C, v20);
  v21 = v19;
  v22 = v23;
  _InterlockedExchange(&dword_805D10C, v21);
  v24 = sub_8049617();
  if ( v24 != -795 )
  {
    v27 = _InterlockedExchange(&dword_805D10C, v24);
    _InterlockedExchange(&dword_805D10C, v26);
    sub_8049621(_InterlockedExchange(&dword_805D10C, v27), v25);
  }
  __asm { popfw }
  return sub_80528BF(v22, a10, a13, a14, (int)&v29);
}
// 80538B9: could not find valid save-restore pair for ebp
// 8049621: using guessed type int __fastcall sub_8049621(_DWORD, _DWORD);
// 805D10C: using guessed type int dword_805D10C;
// 805D178: using guessed type int dword_805D178;
// 805D1B4: using guessed type int dword_805D1B4;
// 805D802: using guessed type int dword_805D802;
// 805D806: using guessed type int dword_805D806;
// 805D80A: using guessed type int dword_805D80A;
// 805D80E: using guessed type int dword_805D80E;
// 805D812: using guessed type int dword_805D812;
// 805D816: using guessed type int dword_805D816;
// 805D81A: using guessed type int dword_805D81A;
// 805D81E: using guessed type int dword_805D81E;
// 805D822: using guessed type int dword_805D822;
// 805D826: using guessed type int dword_805D826;
// 805D82A: using guessed type int dword_805D82A;
// 805D82E: using guessed type int dword_805D82E;

//----- (08053BA4) --------------------------------------------------------
void *__usercall sub_8053BA4@<eax>(signed __int32 a1@<ebx>, signed int a2, signed __int32 a3, size_t a4)
{
  return sub_80528BF(a1, a2, a3, a4, (int)&unk_805D21C);
}

//----- (08053D14) --------------------------------------------------------
void *__usercall sub_8053D14@<eax>(signed __int32 a1@<ebx>, signed int a2, signed __int32 a3)
{
  return sub_8053BA4(a1, a2, a3, 0xFFFFFFFF);
}

//----- (08053DCE) --------------------------------------------------------
int __usercall sub_8053DCE@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, int a9@<ebp>, int a10)
{
  char v10; // al
  signed __int32 v11; // et0
  signed __int32 v12; // ebx
  signed __int32 v13; // ecx
  signed __int32 v14; // ecx
  signed __int32 v15; // ebx
  signed __int32 v16; // et1
  unsigned __int32 v17; // eax
  signed __int32 v18; // edx
  signed __int32 v19; // ecx
  signed __int32 v24; // eax
  signed __int32 v25; // eax
  signed __int32 v26; // eax
  signed __int32 v27; // edx
  int v28; // ecx
  signed __int32 v29; // eax
  int v31; // [esp-4h] [ebp-20h]
  int v32; // [esp+18h] [ebp-4h]

  v32 = a5;
  __asm { pushfw }
  if ( a8 >= 10 )
  {
    v11 = _InterlockedExchange(&dword_805D10C, a8);
    v10 = _InterlockedExchange(&dword_805D10C, a6);
    a6 = _InterlockedExchange(&dword_805D10C, v11);
    if ( ((_BYTE)a8 - 1) * v10 & 1 )
      abort();
  }
  __asm { popfw }
  v32 = a9;
  v31 = sub_80555D5(
          (unsigned int)&v32 < 0x18,
          &v32 == 0,
          (signed int)&v32 < 0,
          __OFSUB__(&v32, 24),
          a10,
          a6,
          a7,
          a8,
          (int)&v32,
          a10,
          0,
          3);
  __asm { pushfw }
  v12 = _InterlockedExchange(&dword_805D178, a8);
  v16 = _InterlockedExchange(&dword_805D178, v13);
  v14 = v12;
  v15 = v16;
  _InterlockedExchange(&dword_805D178, v14);
  v17 = sub_804A5EF();
  _CF = v17 < 0x1A5;
  _OF = __OFSUB__(v17, 421);
  _ZF = v17 == 421;
  _SF = (signed int)(v17 - 421) < 0;
  if ( v17 != 421 )
  {
    v24 = _InterlockedExchange(&dword_805D178, v17);
    _InterlockedExchange(&dword_805D178, v18);
    sub_804A5F9(_CF, _ZF, _SF, _OF, _InterlockedExchange(&dword_805D178, v24), v15);
  }
  __asm { pushfw }
  v25 = _InterlockedExchange(&dword_805D160, 421);
  _InterlockedExchange(&dword_805D160, v19);
  _InterlockedExchange(&dword_805D160, v25);
  v26 = sub_804F071();
  if ( v26 != -48 )
  {
    v29 = _InterlockedExchange(&dword_805D160, v26);
    _InterlockedExchange(&dword_805D160, v27);
    sub_804F07B(v28, _InterlockedExchange(&dword_805D160, v29));
  }
  __asm
  {
    popfw
    popfw
  }
  return v31;
}
// 8053DCE: could not find valid save-restore pair for ebp
// 804F07B: using guessed type int __fastcall sub_804F07B(_DWORD, _DWORD);
// 805D10C: using guessed type int dword_805D10C;
// 805D160: using guessed type int dword_805D160;
// 805D178: using guessed type int dword_805D178;

//----- (08053E9E) --------------------------------------------------------
int __usercall sub_8053E9E@<eax>(signed __int32 a1@<ebx>, FILE *stream, int a3, int a4, int a5, int a6, int a7)
{
  char *v7; // eax
  signed __int32 v8; // ecx
  signed __int32 v9; // eax
  signed __int32 v10; // et0
  signed __int32 v11; // edx
  unsigned __int32 v12; // eax
  signed __int32 v13; // edx
  char *v14; // eax
  signed __int32 v19; // ecx
  signed __int32 v20; // eax
  signed __int32 v21; // eax
  signed __int32 v22; // edx
  int v23; // ecx
  signed __int32 v24; // eax
  signed __int32 v25; // ebx
  char *v26; // eax
  int result; // eax
  int v28; // esi
  signed __int32 v29; // ebx
  char *v30; // eax
  int v31; // edi
  int v32; // esi
  signed __int32 v33; // ebx
  char *v34; // eax
  int v35; // ST5C_4
  int v36; // ST58_4
  int v37; // edi
  int v38; // esi
  signed __int32 v39; // ebx
  char *v40; // eax
  int v41; // edi
  int v42; // esi
  signed __int32 v43; // ebx
  signed __int32 v44; // edx
  signed __int32 v49; // ebx
  signed __int32 v50; // edx
  signed __int32 v51; // ebx
  signed __int32 v52; // et0
  unsigned __int32 v53; // eax
  signed __int32 v54; // edx
  signed __int32 v55; // ecx
  signed __int32 v56; // ebx
  signed __int32 v57; // et1
  char v58; // al
  signed __int32 v59; // ebx
  char v60; // t2
  int v61; // esi
  int v62; // edi
  signed __int32 v63; // ebx
  char *v64; // eax
  signed __int32 v65; // eax
  signed __int32 v66; // ecx
  unsigned int v67; // eax
  signed __int32 v68; // edx
  int v69; // edi
  int v70; // ST5C_4
  int v71; // ST58_4
  int v72; // ST54_4
  int v73; // ST50_4
  int v74; // ST4C_4
  int v75; // esi
  signed __int32 v76; // ebx
  char *v77; // eax
  int v78; // edi
  int v79; // ST5C_4
  int v80; // ST58_4
  int v81; // ST54_4
  int v82; // ST50_4
  int v83; // ST4C_4
  int v84; // ST48_4
  int v85; // esi
  signed __int32 v86; // ebx
  char *v87; // eax
  int v88; // ST5C_4
  int v89; // edi
  int v90; // esi
  signed __int32 v91; // ebx
  char *v92; // eax
  int v93; // edi
  int v94; // ST5C_4
  int v95; // ST58_4
  int v96; // ST54_4
  int v97; // ST50_4
  int v98; // ST4C_4
  int v99; // ST48_4
  int v100; // esi
  signed __int32 v101; // ebx
  char *v102; // eax
  signed __int32 v103; // [esp-Ah] [ebp-72h]
  char *v104; // [esp-4h] [ebp-6Ch]
  char *v105; // [esp-4h] [ebp-6Ch]
  const char *v106; // [esp-4h] [ebp-6Ch]
  int v107; // [esp+40h] [ebp-28h]
  int v108; // [esp+44h] [ebp-24h]
  int v109; // [esp+44h] [ebp-24h]
  int v110; // [esp+48h] [ebp-20h]
  int v111; // [esp+48h] [ebp-20h]
  int v112; // [esp+4Ch] [ebp-1Ch]
  int v113; // [esp+4Ch] [ebp-1Ch]

  if ( a3 )
    fprintf(stream, "%s (%s) %s\n", a3, a4, a5);
  else
    fprintf(stream, "%s %s\n", a4, a5);
  v7 = gettext("(C)");
  v104 = v7;
  __asm { pushfw }
  v10 = _InterlockedExchange(&dword_805D19C, (signed __int32)v7);
  v9 = _InterlockedExchange(&dword_805D19C, v8);
  _InterlockedExchange(&dword_805D19C, v10);
  v12 = sub_804B771(_CF, _ZF, _SF, _OF, v9, v11, a1);
  if ( v12 != -342 )
    sub_804B82B(
      v12 < 0xFFFFFEAA,
      v12 == -342,
      (signed int)(v12 + 342) < 0,
      __OFSUB__(v12, -342),
      v12,
      _InterlockedExchange(&dword_805D19C, _InterlockedExchange(&dword_805D19C, a1)),
      _InterlockedExchange(&dword_805D19C, v13));
  __asm { popfw }
  fprintf(stream, "Copyright %s %d Free Software Foundation, Inc.", v104, 2017);
  v14 = gettext(aLicenseGplv3Gn);
  fputs_unlocked(v14, stream);
  switch ( a7 )
  {
    case 0:
      __asm { pushfw }
      v20 = _InterlockedExchange(&dword_805D160, a7);
      _InterlockedExchange(&dword_805D160, v19);
      _InterlockedExchange(&dword_805D160, v20);
      v21 = sub_804F071();
      if ( v21 != -48 )
      {
        v24 = _InterlockedExchange(&dword_805D160, v21);
        _InterlockedExchange(&dword_805D160, v22);
        sub_804F07B(v23, _InterlockedExchange(&dword_805D160, v24));
      }
      __asm { popfw }
      abort();
      return result;
    case 1:
      v25 = *(_DWORD *)a6;
      v26 = gettext(aWrit);
      result = fprintf(stream, v26, v25);
      break;
    case 2:
      v28 = *(_DWORD *)(a6 + 4);
      v29 = *(_DWORD *)a6;
      v30 = gettext(aWrittenBySAnd);
      result = fprintf(stream, v30, v29, v28);
      break;
    case 3:
      v31 = *(_DWORD *)(a6 + 8);
      v32 = *(_DWORD *)(a6 + 4);
      v33 = *(_DWORD *)a6;
      v34 = gettext("Written by %s, %s, and %s.\n");
      result = fprintf(stream, v34, v33, v32, v31);
      break;
    case 4:
      v88 = *(_DWORD *)(a6 + 12);
      v89 = *(_DWORD *)(a6 + 8);
      v90 = *(_DWORD *)(a6 + 4);
      v91 = *(_DWORD *)a6;
      v92 = gettext("Written by %s, %s, %s,\nand %s.\n");
      result = fprintf(stream, v92, v91, v90, v89, v88);
      break;
    case 5:
      v35 = *(_DWORD *)(a6 + 16);
      v36 = *(_DWORD *)(a6 + 12);
      v37 = *(_DWORD *)(a6 + 8);
      v38 = *(_DWORD *)(a6 + 4);
      v39 = *(_DWORD *)a6;
      v40 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
      result = fprintf(stream, v40, v39, v38, v37, v36, v35);
      break;
    case 6:
      v112 = *(_DWORD *)(a6 + 20);
      v110 = *(_DWORD *)(a6 + 16);
      v108 = *(_DWORD *)(a6 + 12);
      v41 = *(_DWORD *)(a6 + 8);
      v42 = *(_DWORD *)(a6 + 4);
      v43 = *(_DWORD *)a6;
      v105 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
      __asm { pushfw }
      v103 = v43;
      _CF = (unsigned int)v43 < 0xA;
      _OF = __OFSUB__(v43, 10);
      _ZF = v43 == 10;
      _SF = v43 - 10 < 0;
      if ( v43 >= 10 )
      {
        __asm { pushfw }
        v49 = _InterlockedExchange(&dword_805D148, v43);
        v52 = _InterlockedExchange(&dword_805D148, v44);
        v50 = v49;
        v51 = v52;
        _InterlockedExchange(&dword_805D148, v50);
        v53 = sub_80550FF();
        if ( v53 != 180 )
        {
          v56 = _InterlockedExchange(&dword_805D148, v51);
          v57 = _InterlockedExchange(&dword_805D148, v54);
          _InterlockedExchange(&dword_805D148, v56);
          sub_8055109(v53 < 0xB4, v53 == 180, (signed int)(v53 - 180) < 0, __OFSUB__(v53, 180), v53, v55, v57);
        }
        __asm { popfw }
        v58 = v51;
        v59 = _InterlockedExchange(&dword_805D178, v51);
        v60 = _InterlockedExchange(&dword_805D178, v55);
        _InterlockedExchange(&dword_805D178, v59);
        if ( (v60 - 1) * v58 & 1 )
          abort();
      }
      __asm { popfw }
      result = fprintf(stream, v105, v103, v42, v41, v108, v110, v112);
      break;
    case 7:
      v61 = *(_DWORD *)(a6 + 24);
      v113 = *(_DWORD *)(a6 + 20);
      v111 = *(_DWORD *)(a6 + 16);
      v109 = *(_DWORD *)(a6 + 12);
      v107 = *(_DWORD *)(a6 + 8);
      v62 = *(_DWORD *)(a6 + 4);
      v63 = *(_DWORD *)a6;
      v64 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
      v106 = v64;
      __asm { pushfw }
      v65 = _InterlockedExchange(&dword_805D118, (signed __int32)v64);
      _InterlockedExchange(&dword_805D118, v66);
      _InterlockedExchange(&dword_805D118, v65);
      v67 = sub_804B6EB();
      if ( v67 != -916 )
        sub_804B6F5(
          v67 < 0xFFFFFC6C,
          v67 == -916,
          (signed int)(v67 + 916) < 0,
          __OFSUB__(v67, -916),
          _InterlockedExchange(&dword_805D118, _InterlockedExchange(&dword_805D118, v63)),
          _InterlockedExchange(&dword_805D118, v68));
      __asm { popfw }
      result = fprintf(stream, v106, v63, v62, v107, v109, v111, v113, v61);
      break;
    case 8:
      v69 = *(_DWORD *)(a6 + 28);
      v70 = *(_DWORD *)(a6 + 24);
      v71 = *(_DWORD *)(a6 + 20);
      v72 = *(_DWORD *)(a6 + 16);
      v73 = *(_DWORD *)(a6 + 12);
      v74 = *(_DWORD *)(a6 + 8);
      v75 = *(_DWORD *)(a6 + 4);
      v76 = *(_DWORD *)a6;
      v77 = gettext(aWrittenBySSSSS_3);
      result = fprintf(stream, v77, v76, v75, v74, v73, v72, v71, v70, v69);
      break;
    case 9:
      v78 = *(_DWORD *)(a6 + 32);
      v79 = *(_DWORD *)(a6 + 28);
      v80 = *(_DWORD *)(a6 + 24);
      v81 = *(_DWORD *)(a6 + 20);
      v82 = *(_DWORD *)(a6 + 16);
      v83 = *(_DWORD *)(a6 + 12);
      v84 = *(_DWORD *)(a6 + 8);
      v85 = *(_DWORD *)(a6 + 4);
      v86 = *(_DWORD *)a6;
      v87 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
      result = fprintf(stream, v87, v86, v85, v84, v83, v82, v81, v80, v79, v78);
      break;
    default:
      v93 = *(_DWORD *)(a6 + 32);
      v94 = *(_DWORD *)(a6 + 28);
      v95 = *(_DWORD *)(a6 + 24);
      v96 = *(_DWORD *)(a6 + 20);
      v97 = *(_DWORD *)(a6 + 16);
      v98 = *(_DWORD *)(a6 + 12);
      v99 = *(_DWORD *)(a6 + 8);
      v100 = *(_DWORD *)(a6 + 4);
      v101 = *(_DWORD *)a6;
      v102 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
      result = fprintf(stream, v102, v101, v100, v99, v98, v97, v96, v95, v94, v93);
      break;
  }
  return result;
}
// 8048F20: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 804F07B: using guessed type int __fastcall sub_804F07B(_DWORD, _DWORD);
// 805D118: using guessed type int dword_805D118;
// 805D148: using guessed type int dword_805D148;
// 805D160: using guessed type int dword_805D160;
// 805D178: using guessed type int dword_805D178;
// 805D19C: using guessed type int dword_805D19C;

//----- (080545A2) --------------------------------------------------------
int __usercall sub_80545A2@<eax>(signed __int32 a1@<eax>, signed __int32 a2@<edx>, signed __int32 a3@<ebx>, FILE *stream, int a5, int a6, int a7, int a8)
{
  signed __int32 v8; // ebx
  signed __int32 v9; // edx
  signed __int32 v10; // et0
  unsigned __int32 v11; // eax
  signed __int32 v12; // ecx
  signed __int32 v17; // eax
  signed __int32 v18; // et1
  signed __int32 *v23; // eax
  signed __int32 v24; // eax
  int v25; // edx
  signed __int32 v26; // ecx
  signed __int32 v27; // ebx
  int v29; // [esp-4h] [ebp-5Ch]
  unsigned int i; // [esp+24h] [ebp-34h]
  int v31[12]; // [esp+28h] [ebp-30h]

  for ( i = 0; ; ++i )
  {
    _CF = i < 9;
    _OF = __OFSUB__(i, 9);
    _ZF = i == 9;
    _SF = (signed int)(i - 9) < 0;
    if ( i > 9 )
      break;
    v23 = (signed __int32 *)a8;
    a8 += 4;
    a2 = *v23;
    v31[i] = *v23;
    a1 = v31[i];
    _CF = 0;
    _OF = 0;
    _ZF = a1 == 0;
    _SF = a1 < 0;
    if ( !a1 )
      break;
    v29 = v31[i];
    __asm { pushfw }
    v8 = _InterlockedExchange(&dword_805D1B4, a3);
    v10 = _InterlockedExchange(&dword_805D1B4, a2);
    v9 = v8;
    a3 = v10;
    _InterlockedExchange(&dword_805D1B4, v9);
    v11 = sub_8056BAD();
    _CF = v11 < 0x2BE;
    _OF = __OFSUB__(v11, 702);
    _ZF = v11 == 702;
    _SF = (signed int)(v11 - 702) < 0;
    if ( v11 != 702 )
    {
      v18 = _InterlockedExchange(&dword_805D1B4, v11);
      v17 = _InterlockedExchange(&dword_805D1B4, a2);
      _InterlockedExchange(&dword_805D1B4, v18);
      sub_8056BB7(_CF, _ZF, _SF, _OF, v17, v12, a3);
    }
    __asm { popfw }
    a1 = v29;
  }
  __asm { pushfw }
  v24 = _InterlockedExchange(&dword_805D13C, a1);
  _InterlockedExchange(&dword_805D13C, a2);
  _InterlockedExchange(&dword_805D13C, v24);
  if ( sub_8055DB4() != -64 )
  {
    v27 = _InterlockedExchange(&dword_805D13C, a3);
    _InterlockedExchange(&dword_805D13C, v26);
    sub_8055DBE(_InterlockedExchange(&dword_805D13C, v27), v25);
  }
  __asm { popfw }
  return sub_8053E9E(a3, stream, a5, a6, a7, (int)v31, i);
}
// 8055DBE: using guessed type int __fastcall sub_8055DBE(_DWORD, _DWORD);
// 805D13C: using guessed type int dword_805D13C;
// 805D1B4: using guessed type int dword_805D1B4;
// 80545A2: using guessed type int var_30[12];

//----- (08054682) --------------------------------------------------------
int __usercall sub_8054682@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>, FILE *stream, int a4, int a5, int a6, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a6);
  return sub_80545A2((signed __int32)stream, a1, a2, stream, a4, a5, a6, (int)va);
}

//----- (08054904) --------------------------------------------------------
signed int __usercall sub_8054904@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>)
{
  char v7; // al
  signed __int32 v8; // ebx
  signed __int32 v9; // et0
  signed __int32 v10; // edx
  signed __int32 v11; // ebx
  int v12; // eax
  signed __int32 v17; // eax
  signed __int32 v18; // ecx
  char v19; // al
  signed __int32 v20; // ebx
  char v21; // t2
  signed __int32 v26; // eax
  unsigned __int32 v27; // eax
  signed __int32 v28; // edx
  signed __int32 v29; // ecx
  signed __int32 v34; // ebx
  char v35; // t1
  signed __int32 v37; // [esp-1Ah] [ebp-1Ah]
  unsigned __int32 v38; // [esp-14h] [ebp-14h]

  __asm { pushfw }
  if ( a7 >= 10 )
  {
    v7 = a7;
    v8 = _InterlockedExchange(&dword_805D1B4, a7);
    v9 = _InterlockedExchange(&dword_805D1B4, a5);
    v10 = _InterlockedExchange(&dword_805D1B4, v8);
    v11 = v9 - 1;
    v12 = ((_BYTE)v9 - 1) * v7 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = v12 == 0;
    _SF = v12 < 0;
    if ( v12 )
    {
      __asm { pushfw }
      v17 = _InterlockedExchange(&dword_805D184, v12);
      _InterlockedExchange(&dword_805D184, v10);
      v38 = sub_804C065(0, _ZF, _SF, 0, _InterlockedExchange(&dword_805D184, v17), a6, v11);
      __asm { pushfw }
      v37 = v11;
      if ( v11 >= 10 )
      {
        v19 = v11;
        v20 = _InterlockedExchange(&dword_805D130, v11);
        v21 = _InterlockedExchange(&dword_805D130, v18);
        v18 = _InterlockedExchange(&dword_805D130, v20);
        if ( (v21 - 1) * v19 & 1 )
          abort();
      }
      __asm { popfw }
      _CF = v38 < 0x12C;
      _OF = __OFSUB__(v38, 300);
      _ZF = v38 == 300;
      _SF = (signed int)(v38 - 300) < 0;
      if ( v38 != 300 )
      {
        __asm { pushfw }
        v26 = _InterlockedExchange(&dword_805D148, v38);
        _InterlockedExchange(&dword_805D148, v18);
        _InterlockedExchange(&dword_805D148, v26);
        v27 = sub_80550FF();
        _CF = v27 < 0xB4;
        _OF = __OFSUB__(v27, 180);
        _ZF = v27 == 180;
        _SF = (signed int)(v27 - 180) < 0;
        if ( v27 != 180 )
          sub_8055109(
            v27 < 0xB4,
            v27 == 180,
            (signed int)(v27 - 180) < 0,
            __OFSUB__(v27, 180),
            _InterlockedExchange(&dword_805D148, v29),
            _InterlockedExchange(&dword_805D148, _InterlockedExchange(&dword_805D148, v27)),
            v37);
        __asm { pushfw }
        if ( v37 >= 10 )
        {
          v34 = _InterlockedExchange(&dword_805D13C, v37);
          v35 = _InterlockedExchange(&dword_805D13C, v28);
          v28 = _InterlockedExchange(&dword_805D13C, v34);
          if ( (v35 - 1) * (_BYTE)v37 & 1 )
            abort();
        }
        __asm
        {
          popfw
          popfw
        }
        sub_804C18B(
          _CF,
          _ZF,
          _SF,
          _OF,
          v28,
          _InterlockedExchange(&dword_805D184, _InterlockedExchange(&dword_805D184, v37)),
          _InterlockedExchange(&dword_805D184, v29));
      }
      __asm { popfw }
      abort();
    }
  }
  __asm { popfw }
  return 655;
}
// 805D130: using guessed type int dword_805D130;
// 805D13C: using guessed type int dword_805D13C;
// 805D148: using guessed type int dword_805D148;
// 805D184: using guessed type int dword_805D184;
// 805D1B4: using guessed type int dword_805D1B4;

//----- (08054A34) --------------------------------------------------------
void __usercall __noreturn sub_8054A34(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>)
{
  signed __int32 v6; // ebx
  signed __int32 v7; // ecx
  signed __int32 v8; // ebx
  signed __int32 v9; // et0
  unsigned __int32 v10; // eax
  signed __int32 v11; // edx
  signed __int32 v12; // ecx
  signed __int32 v13; // ebx
  signed __int32 v14; // et1

  __asm { pushfw }
  v6 = _InterlockedExchange(&dword_805D1B4, a6);
  v9 = _InterlockedExchange(&dword_805D1B4, a5);
  v7 = v6;
  v8 = v9;
  _InterlockedExchange(&dword_805D1B4, v7);
  v10 = sub_8056BAD();
  if ( v10 != 702 )
  {
    v13 = _InterlockedExchange(&dword_805D1B4, v8);
    v14 = _InterlockedExchange(&dword_805D1B4, v11);
    _InterlockedExchange(&dword_805D1B4, v13);
    sub_8056BB7(v10 < 0x2BE, v10 == 702, (signed int)(v10 - 702) < 0, __OFSUB__(v10, 702), v10, v12, v14);
  }
  __asm { popfw }
  __halt();
  JUMPOUT(*(_DWORD *)sub_8054A74);
}
// 805D1B4: using guessed type int dword_805D1B4;

//----- (08054A74) --------------------------------------------------------
void *__usercall sub_8054A74@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, void *a8, signed __int32 *a9, unsigned int a10)
{
  char v10; // al
  signed __int32 v11; // et0
  char v12; // al
  signed __int32 v13; // et1
  signed __int32 v18; // eax
  unsigned __int32 v19; // eax
  signed __int32 v20; // edx
  bool v21; // cf
  bool v22; // zf
  bool v23; // sf
  char v24; // of
  signed __int32 v25; // eax
  signed __int32 v26; // ett
  signed __int32 v31; // ebx
  signed __int32 v32; // ecx
  signed __int32 v33; // ebx
  signed __int32 v34; // et0
  unsigned __int32 v35; // eax
  signed __int32 v36; // edx
  signed __int32 v37; // ecx
  signed __int32 v38; // ebx
  signed __int32 v39; // et1
  char v40; // al
  signed __int32 v41; // ebx
  signed __int32 v42; // et2
  signed __int32 v43; // edx
  signed __int32 v44; // ebx
  int v45; // eax
  char v50; // al
  signed __int32 v51; // ett
  signed __int32 v52; // ebx
  char v53; // t0
  signed __int32 v55; // [esp-14h] [ebp-40h]
  unsigned int v56; // [esp+1Ch] [ebp-10h]
  signed __int32 v57; // [esp+22h] [ebp-Ah]

  __asm { pushfw }
  v57 = a7;
  if ( a7 >= 10 )
  {
    v11 = _InterlockedExchange(&dword_805D124, a7);
    v10 = _InterlockedExchange(&dword_805D124, a5);
    a5 = _InterlockedExchange(&dword_805D124, v11);
    if ( ((_BYTE)a7 - 1) * v10 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( a7 >= 10 )
  {
    v13 = _InterlockedExchange(&dword_805D16C, a7);
    v12 = _InterlockedExchange(&dword_805D16C, a5);
    _InterlockedExchange(&dword_805D16C, v13);
    if ( ((_BYTE)a7 - 1) * v12 & 1 )
      abort();
  }
  __asm { popfw }
  v56 = *a9;
  _CF = 0;
  _OF = 0;
  _ZF = a8 == 0;
  _SF = (signed int)a8 < 0;
  if ( a8 )
  {
    if ( 0x55555554 / a10 <= v56 )
      sub_805517D(a7);
    v56 += (v56 >> 1) + 1;
  }
  else
  {
    __asm { pushfw }
    v18 = _InterlockedExchange(&dword_805D130, *a9);
    _InterlockedExchange(&dword_805D130, a6);
    _InterlockedExchange(&dword_805D130, v18);
    v19 = sub_80527A0();
    v21 = v19 < 0x229;
    v24 = __OFSUB__(v19, 553);
    v22 = v19 == 553;
    v23 = (signed int)(v19 - 553) < 0;
    if ( v19 != 553 )
    {
      v26 = _InterlockedExchange(&dword_805D130, v19);
      v25 = _InterlockedExchange(&dword_805D130, a6);
      _InterlockedExchange(&dword_805D130, v26);
      sub_80527AA(v21, v22, v23, v24, v25, v20);
    }
    __asm
    {
      popfw
      pushfw
    }
    _CF = (unsigned int)a7 < 0xA;
    _OF = __OFSUB__(a7, 10);
    _ZF = a7 == 10;
    _SF = a7 - 10 < 0;
    if ( a7 >= 10 )
    {
      __asm { pushfw }
      v31 = _InterlockedExchange(&dword_805D190, a7);
      v34 = _InterlockedExchange(&dword_805D190, a6);
      v32 = v31;
      v33 = v34;
      _InterlockedExchange(&dword_805D190, v32);
      v35 = sub_80554DE();
      if ( v35 != 553 )
      {
        v38 = _InterlockedExchange(&dword_805D190, v33);
        v39 = _InterlockedExchange(&dword_805D190, v36);
        _InterlockedExchange(&dword_805D190, v38);
        sub_80554E8(v35 < 0x229, v35 == 553, (signed int)(v35 - 553) < 0, __OFSUB__(v35, 553), v35, v37, v39);
      }
      __asm
      {
        popfw
        pushfw
      }
      v55 = v33;
      if ( v33 >= 10 )
      {
        v40 = v33;
        v41 = _InterlockedExchange(&dword_805D19C, v33);
        v42 = _InterlockedExchange(&dword_805D19C, v36);
        v43 = _InterlockedExchange(&dword_805D19C, v41);
        v44 = v42 - 1;
        v45 = ((_BYTE)v42 - 1) * v40 & 1;
        _CF = 0;
        _OF = 0;
        _ZF = v45 == 0;
        _SF = v45 < 0;
        if ( v45 )
        {
          __asm { pushfw }
          if ( v44 >= 10 )
          {
            v51 = _InterlockedExchange(&dword_805D13C, v44);
            v50 = _InterlockedExchange(&dword_805D13C, v43);
            _InterlockedExchange(&dword_805D13C, v51);
            if ( ((_BYTE)v44 - 1) * v50 & 1 )
              abort();
          }
          __asm { popfw }
          abort();
        }
      }
      __asm { popfw }
      v52 = _InterlockedExchange(&dword_805D1C0, v55);
      v53 = _InterlockedExchange(&dword_805D1C0, v37);
      a6 = _InterlockedExchange(&dword_805D1C0, v52);
      if ( (v53 - 1) * (_BYTE)v55 & 1 )
        abort();
    }
    a7 = v57;
    __asm { popfw }
    if ( !v56 )
      v56 = (0x40 / a10 == 0) + 0x40 / a10;
    if ( 0x7FFFFFFF / a10 < v56 )
      sub_805517D(v57);
  }
  *a9 = v56;
  return sub_8054E03(
           (unsigned __int64)((signed int)a10 * (signed __int64)(signed int)v56) >> 32 != 0,
           _ZF,
           _SF,
           (unsigned __int64)((signed int)a10 * (signed __int64)(signed int)v56) >> 32 != 0,
           (signed __int32)a8,
           v56,
           a6,
           a7,
           a8,
           a10 * v56);
}
// 8054A74: could not find valid save-restore pair for ebx
// 8054A74: could not find valid save-restore pair for ebp
// 805D124: using guessed type int dword_805D124;
// 805D130: using guessed type int dword_805D130;
// 805D13C: using guessed type int dword_805D13C;
// 805D16C: using guessed type int dword_805D16C;
// 805D190: using guessed type int dword_805D190;
// 805D19C: using guessed type int dword_805D19C;
// 805D1C0: using guessed type int dword_805D1C0;

//----- (08054C95) --------------------------------------------------------
void *__usercall sub_8054C95@<eax>(signed __int32 a1@<ebx>, size_t size)
{
  signed __int32 v2; // ebx
  signed __int32 v3; // ecx
  signed __int32 v4; // ecx
  signed __int32 v5; // ebx
  signed __int32 v6; // et0
  unsigned int v7; // eax
  signed __int32 v8; // ecx
  signed __int32 v13; // ebx
  signed __int32 v14; // ecx
  signed __int32 v15; // ebx
  signed __int32 v16; // et1
  unsigned __int32 v17; // eax
  signed __int32 v18; // edx
  signed __int32 v19; // ecx
  signed __int32 v24; // eax
  unsigned __int32 v25; // eax
  signed __int32 v26; // edx
  signed __int32 v27; // ecx
  signed __int32 v28; // ebx
  signed __int32 v29; // et1
  signed __int32 v31; // [esp-Ah] [ebp-22h]
  void *v32; // [esp-4h] [ebp-1Ch]

  v32 = sub_8054D68(a1, size);
  __asm { pushfw }
  v2 = _InterlockedExchange(&dword_805D190, a1);
  v6 = _InterlockedExchange(&dword_805D190, v3);
  v4 = v2;
  v5 = v6;
  _InterlockedExchange(&dword_805D190, v4);
  v7 = sub_80554DE();
  _CF = v7 < 0x229;
  _OF = __OFSUB__(v7, 553);
  _ZF = v7 == 553;
  _SF = (signed int)(v7 - 553) < 0;
  if ( v7 != 553 )
  {
    v31 = v7;
    __asm { pushfw }
    v13 = _InterlockedExchange(&dword_805D178, v5);
    v16 = _InterlockedExchange(&dword_805D178, v8);
    v14 = v13;
    v15 = v16;
    _InterlockedExchange(&dword_805D178, v14);
    v17 = sub_804A5EF();
    _CF = v17 < 0x1A5;
    _OF = __OFSUB__(v17, 421);
    _ZF = v17 == 421;
    _SF = (signed int)(v17 - 421) < 0;
    if ( v17 != 421 )
    {
      __asm { pushfw }
      v24 = _InterlockedExchange(&dword_805D148, v17);
      _InterlockedExchange(&dword_805D148, v18);
      _InterlockedExchange(&dword_805D148, v24);
      v25 = sub_80550FF();
      if ( v25 != 180 )
        sub_8055109(
          v25 < 0xB4,
          v25 == 180,
          (signed int)(v25 - 180) < 0,
          __OFSUB__(v25, 180),
          v25,
          _InterlockedExchange(&dword_805D148, _InterlockedExchange(&dword_805D148, v15)),
          _InterlockedExchange(&dword_805D148, v27));
      __asm { popfw }
      sub_804A5F9(
        _CF,
        _ZF,
        _SF,
        _OF,
        _InterlockedExchange(&dword_805D178, _InterlockedExchange(&dword_805D178, v15)),
        _InterlockedExchange(&dword_805D178, v26));
    }
    __asm { popfw }
    v28 = _InterlockedExchange(&dword_805D190, v15);
    v29 = _InterlockedExchange(&dword_805D190, v18);
    _InterlockedExchange(&dword_805D190, v28);
    sub_80554E8(_CF, _ZF, _SF, _OF, v31, v19, v29);
  }
  __asm { popfw }
  return v32;
}
// 805D148: using guessed type int dword_805D148;
// 805D178: using guessed type int dword_805D178;
// 805D190: using guessed type int dword_805D190;

//----- (08054D68) --------------------------------------------------------
void *__usercall sub_8054D68@<eax>(signed __int32 a1@<ebx>, size_t size)
{
  void *result; // eax
  signed __int32 v3; // edx
  signed __int32 v4; // ecx
  signed __int32 v9; // ebx
  signed __int32 v10; // ecx
  signed __int32 v11; // ebx
  signed __int32 v12; // et0
  unsigned __int32 v13; // eax
  signed __int32 v14; // edx
  signed __int32 v15; // ecx
  signed __int32 v20; // eax
  char v21; // al
  signed __int32 v22; // ebx
  char v23; // t2
  signed __int32 v24; // [esp-10h] [ebp-38h]

  result = malloc(size);
  if ( !result )
  {
    _CF = 0;
    _OF = 0;
    _ZF = size == 0;
    _SF = (size & 0x80000000) != 0;
    if ( size )
    {
      __asm { pushfw }
      v9 = _InterlockedExchange(&dword_805D154, a1);
      v12 = _InterlockedExchange(&dword_805D154, v4);
      v10 = v9;
      v11 = v12;
      v13 = sub_804B1D3(
              0,
              size == 0,
              (size & 0x80000000) != 0,
              0,
              0,
              v3,
              _InterlockedExchange(&dword_805D154, v10),
              v12);
      _CF = v13 < 0xF;
      _OF = __OFSUB__(v13, 15);
      _ZF = v13 == 15;
      _SF = (signed int)(v13 - 15) < 0;
      if ( v13 != 15 )
      {
        v20 = _InterlockedExchange(&dword_805D154, v13);
        _InterlockedExchange(&dword_805D154, v14);
        _InterlockedExchange(&dword_805D154, v20);
        sub_804B283(_CF, _ZF, _SF, _OF, v15, v11);
      }
      __asm { pushfw }
      v24 = v11;
      if ( v11 >= 10 )
      {
        v21 = v11;
        v22 = _InterlockedExchange(&dword_805D10C, v11);
        v23 = _InterlockedExchange(&dword_805D10C, v15);
        _InterlockedExchange(&dword_805D10C, v22);
        if ( (v23 - 1) * v21 & 1 )
          abort();
      }
      __asm
      {
        popfw
        popfw
      }
      sub_805517D(v24);
    }
  }
  return result;
}
// 805D10C: using guessed type int dword_805D10C;
// 805D154: using guessed type int dword_805D154;

//----- (08054E03) --------------------------------------------------------
void *__usercall sub_8054E03@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, void *ptr, signed int size)
{
  char v10; // al
  signed __int32 v11; // ebx
  char v12; // t0
  signed __int32 v13; // ebx
  char v14; // t1
  signed __int32 v15; // ebx
  signed __int32 v20; // eax
  signed __int32 v21; // edx
  signed __int32 v22; // ecx
  signed __int32 v23; // ebx
  signed __int32 v24; // ebx
  signed __int32 v25; // edx
  signed __int32 v26; // et0
  unsigned __int32 v27; // eax
  signed __int32 v28; // edx
  void *result; // eax
  signed __int32 v30; // [esp+12h] [ebp-Ah]
  signed __int32 v31; // [esp+18h] [ebp-4h]
  void *v32; // [esp+20h] [ebp+4h]

  v31 = a5;
  __asm { pushfw }
  v30 = a8;
  if ( a8 >= 10 )
  {
    v10 = a8;
    v11 = _InterlockedExchange(&dword_805D16C, a8);
    v12 = _InterlockedExchange(&dword_805D16C, a7);
    a7 = _InterlockedExchange(&dword_805D16C, v11);
    if ( (v12 - 1) * v10 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( v30 >= 10 )
  {
    v13 = _InterlockedExchange(&dword_805D1B4, v30);
    v14 = _InterlockedExchange(&dword_805D1B4, a7);
    _InterlockedExchange(&dword_805D1B4, v13);
    if ( (v14 - 1) * (_BYTE)v30 & 1 )
      abort();
  }
  v15 = v30;
  __asm { popfw }
  _CF = 0;
  _OF = 0;
  _ZF = size == 0;
  _SF = size < 0;
  if ( size )
    goto LABEL_20;
  __asm { pushfw }
  v20 = _InterlockedExchange(&dword_805D13C, v31);
  _InterlockedExchange(&dword_805D13C, a6);
  _InterlockedExchange(&dword_805D13C, v20);
  if ( sub_8055DB4() != -64 )
  {
    v23 = _InterlockedExchange(&dword_805D13C, v30);
    _InterlockedExchange(&dword_805D13C, v22);
    sub_8055DBE(_InterlockedExchange(&dword_805D13C, v23), v21);
  }
  __asm
  {
    popfw
    pushfw
  }
  v24 = _InterlockedExchange(&dword_805D19C, v30);
  v26 = _InterlockedExchange(&dword_805D19C, v21);
  v25 = v24;
  v15 = v26;
  v27 = sub_804B771(_CF, _ZF, _SF, _OF, v31, _InterlockedExchange(&dword_805D19C, v25), v26);
  if ( v27 != -342 )
    sub_804B82B(
      v27 < 0xFFFFFEAA,
      v27 == -342,
      (signed int)(v27 + 342) < 0,
      __OFSUB__(v27, -342),
      v27,
      _InterlockedExchange(&dword_805D19C, _InterlockedExchange(&dword_805D19C, v15)),
      _InterlockedExchange(&dword_805D19C, v28));
  __asm { popfw }
  if ( !ptr )
  {
LABEL_20:
    v32 = realloc(ptr, size);
    if ( !v32 )
    {
      if ( size )
        sub_805517D(v15);
    }
    result = v32;
  }
  else
  {
    free(ptr);
    result = 0;
  }
  return result;
}
// 8054E03: could not find valid save-restore pair for ebp
// 8055DBE: using guessed type int __fastcall sub_8055DBE(_DWORD, _DWORD);
// 805D13C: using guessed type int dword_805D13C;
// 805D16C: using guessed type int dword_805D16C;
// 805D19C: using guessed type int dword_805D19C;
// 805D1B4: using guessed type int dword_805D1B4;

//----- (08054FF9) --------------------------------------------------------
void *__usercall sub_8054FF9@<eax>(signed __int32 a1@<ebx>, void *src, size_t n)
{
  void *v3; // eax
  signed __int32 v8; // ebx
  signed __int32 v9; // edx
  signed __int32 v10; // edx
  signed __int32 v11; // ebx
  signed __int32 v12; // et0
  unsigned __int32 v13; // eax
  signed __int32 v14; // edx
  signed __int32 v15; // ebx
  void *v17; // [esp-4h] [ebp-1Ch]

  v3 = sub_8054D68(a1, n);
  v17 = memcpy(v3, src, n);
  __asm { pushfw }
  v8 = _InterlockedExchange(&dword_805D130, a1);
  v12 = _InterlockedExchange(&dword_805D130, v9);
  v10 = v8;
  v11 = v12;
  _InterlockedExchange(&dword_805D130, v10);
  v13 = sub_80527A0();
  if ( v13 != 553 )
  {
    v15 = _InterlockedExchange(&dword_805D130, v11);
    _InterlockedExchange(&dword_805D130, v14);
    sub_80527AA(
      v13 < 0x229,
      v13 == 553,
      (signed int)(v13 - 553) < 0,
      __OFSUB__(v13, 553),
      v13,
      _InterlockedExchange(&dword_805D130, v15));
  }
  __asm { popfw }
  return v17;
}
// 805D130: using guessed type int dword_805D130;

//----- (080550FF) --------------------------------------------------------
signed int sub_80550FF()
{
  return 180;
}

//----- (08055109) --------------------------------------------------------
void __usercall __noreturn sub_8055109(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>)
{
  signed __int32 v7; // eax
  unsigned int v8; // eax
  signed __int32 v9; // edx
  int v10; // ecx
  char v15; // al
  signed __int32 v16; // ebx
  char v17; // t1
  signed __int32 v18; // ebx
  signed __int32 v19; // [esp-10h] [ebp-10h]

  __asm { pushfw }
  v7 = _InterlockedExchange(&dword_805D124, a5);
  _InterlockedExchange(&dword_805D124, a6);
  _InterlockedExchange(&dword_805D124, v7);
  v8 = sub_804972F();
  _CF = v8 < 0x3B5;
  _OF = __OFSUB__(v8, 949);
  _ZF = v8 == 949;
  _SF = (signed int)(v8 - 949) < 0;
  if ( v8 != 949 )
  {
    __asm { pushfw }
    v19 = a7;
    if ( a7 >= 10 )
    {
      v15 = a7;
      v16 = _InterlockedExchange(&dword_805D118, a7);
      v17 = _InterlockedExchange(&dword_805D118, v9);
      v9 = _InterlockedExchange(&dword_805D118, v16);
      if ( (v17 - 1) * v15 & 1 )
        abort();
    }
    __asm { popfw }
    v18 = _InterlockedExchange(&dword_805D124, v19);
    _InterlockedExchange(&dword_805D124, v9);
    sub_8049739(v10, _InterlockedExchange(&dword_805D124, v18));
  }
  __asm { popfw }
  __halt();
  JUMPOUT(*(_DWORD *)sub_805517D);
}
// 8049739: using guessed type int __fastcall sub_8049739(_DWORD, _DWORD);
// 805D118: using guessed type int dword_805D118;
// 805D124: using guessed type int dword_805D124;

//----- (0805517D) --------------------------------------------------------
void __usercall __noreturn sub_805517D(signed __int32 a1@<ebx>)
{
  char *v1; // eax
  int v2; // eax
  signed __int32 v3; // edx
  signed __int32 v4; // ecx
  char v9; // al
  signed __int32 v10; // et0
  signed __int32 v11; // ebx
  signed __int32 v12; // ecx
  signed __int32 v13; // ebx
  signed __int32 v14; // et1
  signed __int32 v15; // eax
  signed __int32 v16; // eax
  signed __int32 v17; // edx
  signed __int32 v18; // edx
  signed __int32 v19; // ecx
  signed __int32 v20; // ebx
  signed __int32 v21; // eax
  unsigned __int32 v22; // [esp-14h] [ebp-2Ch]

  v1 = gettext("memory exhausted");
  error(status, 0, "%s", v1);
  __asm { pushfw }
  _CF = (unsigned int)a1 < 0xA;
  _OF = __OFSUB__(a1, 10);
  _ZF = a1 == 10;
  _SF = a1 - 10 < 0;
  if ( a1 >= 10 )
  {
    v10 = _InterlockedExchange(&dword_805D160, a1);
    v9 = _InterlockedExchange(&dword_805D160, v4);
    v4 = _InterlockedExchange(&dword_805D160, v10);
    v2 = (_BYTE)--a1 * v9 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = v2 == 0;
    _SF = v2 < 0;
    if ( v2 )
      abort();
  }
  __asm { pushfw }
  v11 = _InterlockedExchange(&dword_805D154, a1);
  v14 = _InterlockedExchange(&dword_805D154, v4);
  v12 = v11;
  v13 = v14;
  v15 = sub_804B1D3(_CF, _ZF, _SF, _OF, v2, v3, _InterlockedExchange(&dword_805D154, v12), v14);
  v22 = v15;
  __asm { pushfw }
  v16 = _InterlockedExchange(&dword_805D10C, v15);
  _InterlockedExchange(&dword_805D10C, v17);
  _InterlockedExchange(&dword_805D10C, v16);
  if ( sub_8049617() != -795 )
  {
    v20 = _InterlockedExchange(&dword_805D10C, v13);
    _InterlockedExchange(&dword_805D10C, v19);
    sub_8049621(_InterlockedExchange(&dword_805D10C, v20), v18);
  }
  __asm { popfw }
  if ( v22 != 15 )
  {
    v21 = _InterlockedExchange(&dword_805D154, v22);
    _InterlockedExchange(&dword_805D154, v18);
    _InterlockedExchange(&dword_805D154, v21);
    sub_804B283(v22 < 0xF, v22 == 15, (signed int)(v22 - 15) < 0, __OFSUB__(v22, 15), v19, v13);
  }
  __asm
  {
    popfw
    popfw
  }
  abort();
}
// 8049621: using guessed type int __fastcall sub_8049621(_DWORD, _DWORD);
// 805D10C: using guessed type int dword_805D10C;
// 805D154: using guessed type int dword_805D154;
// 805D160: using guessed type int dword_805D160;

//----- (08055264) --------------------------------------------------------
int __usercall sub_8055264@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, FILE *stream)
{
  signed __int32 v8; // eax
  unsigned int v9; // eax
  signed __int32 v10; // edx
  signed __int32 v11; // ecx
  char v16; // al
  signed __int32 v17; // ebx
  char v18; // t1
  signed __int32 v19; // ebx
  signed __int32 v20; // et2
  signed __int32 v21; // ebx
  signed __int32 v22; // ecx
  signed __int32 v23; // ebx
  signed __int32 v24; // ett
  unsigned int v25; // eax
  signed __int32 v26; // ecx
  int v27; // eax
  signed __int32 v28; // ecx
  int v33; // eax
  signed __int32 v34; // eax
  signed __int32 v35; // edx
  signed __int32 v36; // eax
  int v37; // edx
  signed __int32 v38; // ecx
  signed __int32 v39; // eax
  int result; // eax
  char v41; // al
  signed __int32 v42; // ett
  int v43; // eax
  signed __int32 v44; // edx
  bool v45; // zf
  bool v46; // sf
  int v47; // eax
  int v48; // eax
  int v49; // eax
  signed __int32 v50; // ebx
  signed __int32 v51; // edx
  unsigned __int32 v52; // eax
  signed __int32 v53; // edx
  int v54; // [esp-4h] [ebp-30h]
  int v55; // [esp-4h] [ebp-30h]
  int v56; // [esp+14h] [ebp-18h]
  int v57; // [esp+18h] [ebp-14h]
  signed __int32 v58; // [esp+1Ch] [ebp-10h]

  __asm { pushfw }
  v8 = _InterlockedExchange(&dword_805D178, a5);
  _InterlockedExchange(&dword_805D178, a6);
  _InterlockedExchange(&dword_805D178, v8);
  v9 = sub_804A5EF();
  _CF = v9 < 0x1A5;
  _OF = __OFSUB__(v9, 421);
  _ZF = v9 == 421;
  _SF = (signed int)(v9 - 421) < 0;
  if ( v9 != 421 )
  {
    __asm { pushfw }
    v58 = a7;
    if ( a7 >= 10 )
    {
      v16 = a7;
      v17 = _InterlockedExchange(&dword_805D16C, a7);
      v18 = _InterlockedExchange(&dword_805D16C, v11);
      v11 = _InterlockedExchange(&dword_805D16C, v17);
      if ( (v18 - 1) * v16 & 1 )
        abort();
    }
    __asm { popfw }
    v19 = _InterlockedExchange(&dword_805D178, v58);
    v20 = _InterlockedExchange(&dword_805D178, v11);
    _InterlockedExchange(&dword_805D178, v19);
    sub_804A5F9(_CF, _ZF, _SF, _OF, v10, v20);
  }
  __asm
  {
    popfw
    pushfw
  }
  v21 = _InterlockedExchange(&dword_805D1C0, a7);
  v24 = _InterlockedExchange(&dword_805D1C0, v11);
  v22 = v21;
  v23 = v24;
  v25 = sub_8054904(_CF, _ZF, _SF, _OF, v10, _InterlockedExchange(&dword_805D1C0, v22), v24);
  if ( v25 != 655 )
    sub_8054A34(
      v25 < 0x28F,
      v25 == 655,
      (signed int)(v25 - 655) < 0,
      __OFSUB__(v25, 655),
      _InterlockedExchange(&dword_805D1C0, _InterlockedExchange(&dword_805D1C0, v23)),
      _InterlockedExchange(&dword_805D1C0, v26));
  __asm { popfw }
  v56 = 0;
  v27 = fileno(stream);
  _CF = 0;
  _OF = 0;
  _ZF = v27 == 0;
  _SF = v27 < 0;
  if ( v27 >= 0 )
  {
    __asm { pushfw }
    if ( v23 >= 10 )
    {
      v42 = _InterlockedExchange(&dword_805D148, v23);
      v41 = _InterlockedExchange(&dword_805D148, v28);
      _InterlockedExchange(&dword_805D148, v42);
      if ( ((_BYTE)v23 - 1) * v41 & 1 )
        abort();
    }
    __asm { popfw }
    v43 = __freading(stream);
    v45 = v43 == 0;
    v46 = v43 < 0;
    if ( !v43
      || (v47 = fileno(stream), v48 = lseek64(v47, 0, 0, 1), v49 = ~v44 | ~v48, v45 = v49 == 0, v46 = v49 < 0, v49) )
    {
      v55 = sub_8055A4A(0, v45, v46, 0, v44, v23, stream);
      __asm { pushfw }
      v50 = _InterlockedExchange(&dword_805D130, v23);
      _InterlockedExchange(&dword_805D130, v51);
      _InterlockedExchange(&dword_805D130, v50);
      v52 = sub_80527A0();
      if ( v52 != 553 )
        sub_80527AA(
          v52 < 0x229,
          v52 == 553,
          (signed int)(v52 - 553) < 0,
          __OFSUB__(v52, 553),
          _InterlockedExchange(&dword_805D130, v53),
          _InterlockedExchange(&dword_805D130, _InterlockedExchange(&dword_805D130, v52)));
      __asm { popfw }
      if ( v55 )
        v56 = *__errno_location();
    }
    v57 = fclose(stream);
    if ( v56 )
    {
      *__errno_location() = v56;
      v57 = -1;
    }
    result = v57;
  }
  else
  {
    v33 = fclose(stream);
    v54 = v33;
    __asm { pushfw }
    v34 = _InterlockedExchange(&dword_805D10C, v33);
    _InterlockedExchange(&dword_805D10C, v35);
    _InterlockedExchange(&dword_805D10C, v34);
    v36 = sub_8049617();
    if ( v36 != -795 )
    {
      v39 = _InterlockedExchange(&dword_805D10C, v36);
      _InterlockedExchange(&dword_805D10C, v38);
      sub_8049621(_InterlockedExchange(&dword_805D10C, v39), v37);
    }
    __asm { popfw }
    result = v54;
  }
  return result;
}
// 8055264: could not find valid save-restore pair for ebp
// 8049030: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8049621: using guessed type int __fastcall sub_8049621(_DWORD, _DWORD);
// 805D10C: using guessed type int dword_805D10C;
// 805D130: using guessed type int dword_805D130;
// 805D148: using guessed type int dword_805D148;
// 805D16C: using guessed type int dword_805D16C;
// 805D178: using guessed type int dword_805D178;
// 805D1C0: using guessed type int dword_805D1C0;

//----- (080554DE) --------------------------------------------------------
signed int sub_80554DE()
{
  return 553;
}

//----- (080554E8) --------------------------------------------------------
void __usercall __noreturn sub_80554E8(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>)
{
  signed __int32 v7; // eax
  unsigned __int32 v8; // eax
  signed __int32 v9; // edx
  signed __int32 v10; // ecx
  bool v11; // cf
  bool v12; // zf
  bool v13; // sf
  char v14; // of
  signed __int32 v15; // eax
  signed __int32 v16; // ebx
  signed __int32 v17; // edx
  signed __int32 v18; // ebx
  signed __int32 v19; // et2
  unsigned int v20; // eax
  signed __int32 v21; // edx
  signed __int32 v22; // ecx
  char v27; // al
  signed __int32 v28; // ett
  signed __int32 v29; // eax
  signed __int32 v30; // eax
  unsigned __int32 v31; // eax
  signed __int32 v32; // edx
  signed __int32 v33; // ecx
  bool v34; // cf
  bool v35; // zf
  bool v36; // sf
  char v37; // of
  signed __int32 v38; // eax
  signed __int32 v39; // [esp-Ah] [ebp-Ah]
  signed __int32 v40; // [esp-4h] [ebp-4h]

  v40 = a5;
  __asm { pushfw }
  v7 = _InterlockedExchange(&dword_805D118, a5);
  _InterlockedExchange(&dword_805D118, a6);
  _InterlockedExchange(&dword_805D118, v7);
  v8 = sub_804B6EB();
  v11 = v8 < 0xFFFFFC6C;
  v14 = __OFSUB__(v8, -916);
  v12 = v8 == -916;
  v13 = (signed int)(v8 + 916) < 0;
  if ( v8 != -916 )
  {
    v15 = _InterlockedExchange(&dword_805D118, v8);
    _InterlockedExchange(&dword_805D118, v10);
    _InterlockedExchange(&dword_805D118, v15);
    sub_804B6F5(v11, v12, v13, v14, v9, a7);
  }
  __asm
  {
    popfw
    pushfw
  }
  v16 = _InterlockedExchange(&dword_805D124, a7);
  v19 = _InterlockedExchange(&dword_805D124, v9);
  v17 = v16;
  v18 = v19;
  _InterlockedExchange(&dword_805D124, v17);
  v20 = sub_804972F();
  _CF = v20 < 0x3B5;
  _OF = __OFSUB__(v20, 949);
  _ZF = v20 == 949;
  _SF = (signed int)(v20 - 949) < 0;
  if ( v20 != 949 )
  {
    v39 = v20;
    __asm { pushfw }
    if ( v18 >= 10 )
    {
      v28 = _InterlockedExchange(&dword_805D118, v18);
      v27 = _InterlockedExchange(&dword_805D118, v22);
      v22 = _InterlockedExchange(&dword_805D118, v28);
      if ( ((_BYTE)v18 - 1) * v27 & 1 )
        abort();
    }
    __asm { popfw }
    v29 = _InterlockedExchange(&dword_805D124, v39);
    _InterlockedExchange(&dword_805D124, v21);
    sub_8049739(v22, _InterlockedExchange(&dword_805D124, v29));
  }
  __asm
  {
    popfw
    pushfw
  }
  v30 = _InterlockedExchange(&dword_805D184, v40);
  _InterlockedExchange(&dword_805D184, v22);
  v31 = sub_804C065(_CF, _ZF, _SF, _OF, v21, _InterlockedExchange(&dword_805D184, v30), v18);
  v34 = v31 < 0x12C;
  v37 = __OFSUB__(v31, 300);
  v35 = v31 == 300;
  v36 = (signed int)(v31 - 300) < 0;
  if ( v31 != 300 )
  {
    v38 = _InterlockedExchange(&dword_805D184, v31);
    _InterlockedExchange(&dword_805D184, v32);
    sub_804C18B(v34, v35, v36, v37, _InterlockedExchange(&dword_805D184, v38), v33, v18);
  }
  __asm { popfw }
  __halt();
  JUMPOUT(*(_DWORD *)sub_80555D5);
}
// 8049739: using guessed type int __fastcall sub_8049739(_DWORD, _DWORD);
// 805D118: using guessed type int dword_805D118;
// 805D124: using guessed type int dword_805D124;
// 805D184: using guessed type int dword_805D184;

//----- (080555D5) --------------------------------------------------------
int __usercall sub_80555D5@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ecx>, signed __int32 a8@<ebx>, int a9@<ebp>, int fd, int cmd, int a12)
{
  char v12; // al
  signed __int32 v13; // ebx
  char v14; // t0
  char v15; // al
  signed __int32 v16; // et1
  signed __int32 v17; // ebx
  signed __int32 v18; // ecx
  signed __int32 v19; // ebx
  signed __int32 v20; // et2
  unsigned int v21; // eax
  signed __int32 v22; // edx
  signed __int32 v23; // ecx
  int v24; // eax
  signed __int32 v25; // edx
  signed __int32 v26; // ecx
  signed __int32 v31; // eax
  unsigned __int32 v32; // eax
  signed __int32 v33; // edx
  signed __int32 v34; // ecx
  bool v35; // cf
  bool v36; // zf
  bool v37; // sf
  char v38; // of
  signed __int32 v39; // eax
  signed __int32 v40; // eax
  signed __int32 v41; // et2
  unsigned __int32 v42; // eax
  signed __int32 v43; // edx
  signed __int32 v44; // ecx
  bool v45; // cf
  bool v46; // zf
  bool v47; // sf
  char v48; // of
  signed __int32 v49; // eax
  signed __int32 v54; // eax
  unsigned __int32 v55; // eax
  signed __int32 v56; // edx
  bool v57; // cf
  bool v58; // zf
  bool v59; // sf
  char v60; // of
  signed __int32 v61; // eax
  int v62; // eax
  signed __int32 v63; // ecx
  signed __int32 v64; // eax
  signed __int32 v65; // et2
  signed __int32 v66; // edx
  unsigned __int32 v67; // eax
  signed __int32 v68; // edx
  signed __int32 v69; // ebx
  signed __int32 v70; // ecx
  signed __int32 v71; // ecx
  signed __int32 v72; // ebx
  signed __int32 v73; // et0
  signed __int32 v74; // eax
  signed __int32 v75; // eax
  signed __int32 v76; // ecx
  int v77; // edx
  signed __int32 v78; // ecx
  signed __int32 v79; // ebx
  signed __int32 v84; // eax
  char v85; // al
  signed __int32 v86; // ebx
  char v87; // t0
  unsigned __int32 v89; // [esp-Ah] [ebp-46h]
  int *v90; // [esp-4h] [ebp-40h]
  int v91; // [esp+1Ch] [ebp-20h]
  int v92; // [esp+20h] [ebp-1Ch]
  int v93; // [esp+24h] [ebp-18h]
  int v94; // [esp+28h] [ebp-14h]
  signed __int32 v95; // [esp+32h] [ebp-Ah]
  int v96; // [esp+38h] [ebp-4h]

  v96 = a5;
  __asm { pushfw }
  v95 = a8;
  if ( a8 >= 10 )
  {
    v12 = a8;
    v13 = _InterlockedExchange(&dword_805D13C, a8);
    v14 = _InterlockedExchange(&dword_805D13C, a6);
    a6 = _InterlockedExchange(&dword_805D13C, v13);
    if ( (v14 - 1) * v12 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( v95 >= 10 )
  {
    v16 = _InterlockedExchange(&dword_805D148, v95);
    v15 = _InterlockedExchange(&dword_805D148, a7);
    a7 = _InterlockedExchange(&dword_805D148, v16);
    if ( ((_BYTE)v95 - 1) * v15 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  v17 = _InterlockedExchange(&dword_805D184, v95);
  v20 = _InterlockedExchange(&dword_805D184, a7);
  v18 = v17;
  v19 = v20;
  v21 = sub_804C065(_CF, _ZF, _SF, _OF, a6, _InterlockedExchange(&dword_805D184, v18), v20);
  if ( v21 != 300 )
    sub_804C18B(
      v21 < 0x12C,
      v21 == 300,
      (signed int)(v21 - 300) < 0,
      __OFSUB__(v21, 300),
      _InterlockedExchange(&dword_805D184, _InterlockedExchange(&dword_805D184, v19)),
      v23,
      _InterlockedExchange(&dword_805D184, v22));
  __asm { popfw }
  v96 = a9;
  if ( cmd != 1030 )
    return fcntl(fd, cmd, a12);
  v92 = a12;
  if ( dword_805D942 < 0 )
  {
    v24 = sub_80555D5(fd, 0, a12);
    v91 = v24;
    goto LABEL_19;
  }
  v24 = fcntl(fd, 1030, a12);
  v91 = v24;
  _CF = 0;
  _OF = 0;
  _ZF = v24 == 0;
  _SF = v24 < 0;
  if ( v24 >= 0
    || (v24 = *__errno_location(),
        _CF = (unsigned int)v24 < 0x16,
        _OF = __OFSUB__(v24, 22),
        _ZF = v24 == 22,
        _SF = v24 - 22 < 0,
        v24 != 22) )
  {
    dword_805D942 = 1;
LABEL_19:
    __asm { pushfw }
    v41 = _InterlockedExchange(&dword_805D1A8, v24);
    v40 = _InterlockedExchange(&dword_805D1A8, v26);
    _InterlockedExchange(&dword_805D1A8, v41);
    v42 = sub_80571DD(_CF, _ZF, _SF, _OF, v40, v25, v19);
    v45 = v42 < 0xFFFFFDFB;
    v48 = __OFSUB__(v42, -517);
    v46 = v42 == -517;
    v47 = (signed int)(v42 + 517) < 0;
    if ( v42 != -517 )
    {
      v49 = _InterlockedExchange(&dword_805D1A8, v42);
      _InterlockedExchange(&dword_805D1A8, v44);
      sub_8057259(v45, v46, v47, v48, _InterlockedExchange(&dword_805D1A8, v49), v19);
    }
    __asm { popfw }
    if ( v91 >= 0 )
    {
      _CF = (unsigned int)dword_805D942 < 0xFFFFFFFF;
      _OF = __OFSUB__(dword_805D942, -1);
      _ZF = dword_805D942 == -1;
      _SF = dword_805D942 + 1 < 0;
      if ( dword_805D942 == -1 )
      {
        __asm { pushfw }
        v54 = _InterlockedExchange(&dword_805D118, dword_805D942);
        _InterlockedExchange(&dword_805D118, v43);
        _InterlockedExchange(&dword_805D118, v54);
        v55 = sub_804B6EB();
        v57 = v55 < 0xFFFFFC6C;
        v60 = __OFSUB__(v55, -916);
        v58 = v55 == -916;
        v59 = (signed int)(v55 + 916) < 0;
        if ( v55 != -916 )
        {
          v61 = _InterlockedExchange(&dword_805D118, v55);
          _InterlockedExchange(&dword_805D118, v56);
          sub_804B6F5(v57, v58, v59, v60, _InterlockedExchange(&dword_805D118, v61), v19);
        }
        __asm { popfw }
        v93 = fcntl(v91, 1);
        if ( v93 < 0 || fcntl(v91, 2, v93 | 1) == -1 )
        {
          v94 = *__errno_location();
          v62 = close(v91);
          __asm { pushfw }
          v65 = _InterlockedExchange(&dword_805D19C, v62);
          v64 = _InterlockedExchange(&dword_805D19C, v63);
          _InterlockedExchange(&dword_805D19C, v65);
          v67 = sub_804B771(_CF, _ZF, _SF, _OF, v64, v66, v19);
          if ( v67 != -342 )
            sub_804B82B(
              v67 < 0xFFFFFEAA,
              v67 == -342,
              (signed int)(v67 + 342) < 0,
              __OFSUB__(v67, -342),
              v67,
              _InterlockedExchange(&dword_805D19C, _InterlockedExchange(&dword_805D19C, v19)),
              _InterlockedExchange(&dword_805D19C, v68));
          __asm { popfw }
          v90 = __errno_location();
          __asm { pushfw }
          v69 = _InterlockedExchange(&dword_805D13C, v19);
          v73 = _InterlockedExchange(&dword_805D13C, v70);
          v71 = v69;
          v72 = v73;
          _InterlockedExchange(&dword_805D13C, v71);
          v74 = sub_8055DB4();
          v89 = v74;
          __asm { pushfw }
          v75 = _InterlockedExchange(&dword_805D124, v74);
          _InterlockedExchange(&dword_805D124, v76);
          _InterlockedExchange(&dword_805D124, v75);
          if ( sub_804972F() != 949 )
          {
            v79 = _InterlockedExchange(&dword_805D124, v72);
            _InterlockedExchange(&dword_805D124, v78);
            sub_8049739(_InterlockedExchange(&dword_805D124, v79), v77);
          }
          __asm { popfw }
          _CF = v89 < 0xFFFFFFC0;
          _OF = __OFSUB__(v89, -64);
          _ZF = v89 == -64;
          _SF = (signed int)(v89 + 64) < 0;
          if ( v89 != -64 )
          {
            v84 = _InterlockedExchange(&dword_805D13C, v89);
            _InterlockedExchange(&dword_805D13C, v78);
            sub_8055DBE(_InterlockedExchange(&dword_805D13C, v84), v77);
          }
          __asm { pushfw }
          if ( v72 >= 10 )
          {
            v85 = v72;
            v86 = _InterlockedExchange(&dword_805D130, v72);
            v87 = _InterlockedExchange(&dword_805D130, v78);
            _InterlockedExchange(&dword_805D130, v86);
            if ( (v87 - 1) * v85 & 1 )
              abort();
          }
          __asm
          {
            popfw
            popfw
          }
          *v90 = v94;
          v91 = -1;
        }
      }
    }
    return v91;
  }
  __asm { pushfw }
  v31 = _InterlockedExchange(&dword_805D178, 22);
  _InterlockedExchange(&dword_805D178, v26);
  _InterlockedExchange(&dword_805D178, v31);
  v32 = sub_804A5EF();
  v35 = v32 < 0x1A5;
  v38 = __OFSUB__(v32, 421);
  v36 = v32 == 421;
  v37 = (signed int)(v32 - 421) < 0;
  if ( v32 != 421 )
  {
    v39 = _InterlockedExchange(&dword_805D178, v32);
    _InterlockedExchange(&dword_805D178, v34);
    _InterlockedExchange(&dword_805D178, v39);
    sub_804A5F9(v35, v36, v37, v38, v33, v19);
  }
  __asm { popfw }
  v24 = sub_80555D5(fd, 0, v92);
  v91 = v24;
  _CF = 0;
  _OF = 0;
  _ZF = v24 == 0;
  _SF = v24 < 0;
  if ( v24 >= 0 )
  {
    dword_805D942 = -1;
    goto LABEL_19;
  }
  return v91;
}
// 80555D5: could not find valid save-restore pair for ebp
// 8049739: using guessed type int __fastcall sub_8049739(_DWORD, _DWORD);
// 8055DBE: using guessed type int __fastcall sub_8055DBE(_DWORD, _DWORD);
// 805D118: using guessed type int dword_805D118;
// 805D124: using guessed type int dword_805D124;
// 805D130: using guessed type int dword_805D130;
// 805D13C: using guessed type int dword_805D13C;
// 805D148: using guessed type int dword_805D148;
// 805D178: using guessed type int dword_805D178;
// 805D184: using guessed type int dword_805D184;
// 805D19C: using guessed type int dword_805D19C;
// 805D1A8: using guessed type int dword_805D1A8;
// 805D942: using guessed type int dword_805D942;

//----- (0805599E) --------------------------------------------------------
int __usercall sub_805599E@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, FILE *stream)
{
  int v3; // eax
  signed __int32 v8; // eax
  unsigned __int32 v9; // eax
  signed __int32 v10; // edx
  signed __int32 v11; // ecx
  signed __int32 v12; // ebx
  char v13; // al
  signed __int32 v14; // ebx
  char v15; // t2
  int v17; // [esp-4h] [ebp-1Ch]

  v3 = stream->_flags & 0x100;
  _CF = 0;
  _OF = 0;
  _ZF = v3 == 0;
  _SF = v3 < 0;
  if ( v3 )
    v3 = sub_8055BB2(a1, a2, stream, 0, 0, 1);
  v17 = v3;
  __asm { pushfw }
  v8 = _InterlockedExchange(&dword_805D130, v3);
  _InterlockedExchange(&dword_805D130, a1);
  _InterlockedExchange(&dword_805D130, v8);
  v9 = sub_80527A0();
  if ( v9 != 553 )
  {
    v12 = _InterlockedExchange(&dword_805D130, a2);
    _InterlockedExchange(&dword_805D130, v11);
    _InterlockedExchange(&dword_805D130, v12);
    sub_80527AA(v9 < 0x229, v9 == 553, (signed int)(v9 - 553) < 0, __OFSUB__(v9, 553), v9, v10);
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( a2 >= 10 )
  {
    v13 = a2;
    v14 = _InterlockedExchange(&dword_805D184, a2);
    v15 = _InterlockedExchange(&dword_805D184, v10);
    _InterlockedExchange(&dword_805D184, v14);
    if ( (v15 - 1) * v13 & 1 )
      abort();
  }
  __asm { popfw }
  return v17;
}
// 805D130: using guessed type int dword_805D130;
// 805D184: using guessed type int dword_805D184;

//----- (08055A4A) --------------------------------------------------------
int __usercall sub_8055A4A@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>, FILE *fp)
{
  char v7; // al
  signed __int32 v8; // ebx
  char v9; // t0
  int v10; // eax
  signed __int32 v11; // eax
  signed __int32 v12; // edx
  unsigned __int32 v13; // eax
  signed __int32 v14; // edx
  signed __int32 v15; // ecx
  bool v16; // cf
  bool v17; // zf
  bool v18; // sf
  char v19; // of
  signed __int32 v20; // eax
  unsigned __int32 v21; // eax
  signed __int32 v22; // edx
  signed __int32 v23; // ecx
  bool v24; // cf
  bool v25; // zf
  bool v26; // sf
  char v27; // of
  signed __int32 v28; // eax
  int v29; // eax
  signed __int32 v30; // eax
  signed __int32 v31; // edx
  signed __int32 v32; // ecx
  unsigned int v33; // eax
  signed __int32 v34; // edx
  signed __int32 v35; // ecx
  signed __int32 v40; // ebx
  char v41; // t2
  signed __int32 v42; // ebx
  signed __int32 v43; // ett
  int result; // eax
  signed __int32 v45; // [esp-4h] [ebp-20h]
  int v46; // [esp-4h] [ebp-20h]
  signed __int32 v47; // [esp+12h] [ebp-Ah]

  __asm { pushfw }
  v47 = a6;
  if ( a6 >= 10 )
  {
    v7 = a6;
    v8 = _InterlockedExchange(&dword_805D10C, a6);
    v9 = _InterlockedExchange(&dword_805D10C, a5);
    _InterlockedExchange(&dword_805D10C, v8);
    if ( (v9 - 1) * v7 & 1 )
      abort();
  }
  __asm { popfw }
  if ( !fp )
    goto LABEL_19;
  v10 = __freading(fp);
  v45 = v10;
  __asm { pushfw }
  v11 = _InterlockedExchange(&dword_805D118, v10);
  _InterlockedExchange(&dword_805D118, v12);
  _InterlockedExchange(&dword_805D118, v11);
  v13 = sub_804B6EB();
  v16 = v13 < 0xFFFFFC6C;
  v19 = __OFSUB__(v13, -916);
  v17 = v13 == -916;
  v18 = (signed int)(v13 + 916) < 0;
  if ( v13 != -916 )
  {
    v20 = _InterlockedExchange(&dword_805D118, v13);
    _InterlockedExchange(&dword_805D118, v14);
    sub_804B6F5(v16, v17, v18, v19, _InterlockedExchange(&dword_805D118, v20), v47);
  }
  __asm
  {
    popfw
    pushfw
  }
  v21 = sub_804B1D3(
          _CF,
          _ZF,
          _SF,
          _OF,
          _InterlockedExchange(&dword_805D154, v14),
          _InterlockedExchange(&dword_805D154, _InterlockedExchange(&dword_805D154, v45)),
          v15,
          v47);
  v24 = v21 < 0xF;
  v27 = __OFSUB__(v21, 15);
  v25 = v21 == 15;
  v26 = (signed int)(v21 - 15) < 0;
  if ( v21 != 15 )
  {
    v28 = _InterlockedExchange(&dword_805D154, v21);
    _InterlockedExchange(&dword_805D154, v22);
    _InterlockedExchange(&dword_805D154, v28);
    sub_804B283(v24, v25, v26, v27, v23, v47);
  }
  __asm { popfw }
  if ( v45 )
  {
    sub_805599E(v23, v47, fp);
    result = fflush(fp);
  }
  else
  {
LABEL_19:
    v29 = fflush(fp);
    v46 = v29;
    __asm { pushfw }
    v30 = _InterlockedExchange(&dword_805D1C0, v29);
    _InterlockedExchange(&dword_805D1C0, v31);
    v33 = sub_8054904(_CF, _ZF, _SF, _OF, _InterlockedExchange(&dword_805D1C0, v30), v32, v47);
    _CF = v33 < 0x28F;
    _OF = __OFSUB__(v33, 655);
    _ZF = v33 == 655;
    _SF = (signed int)(v33 - 655) < 0;
    if ( v33 != 655 )
    {
      __asm { pushfw }
      if ( v47 >= 10 )
      {
        v40 = _InterlockedExchange(&dword_805D13C, v47);
        v41 = _InterlockedExchange(&dword_805D13C, v34);
        v34 = _InterlockedExchange(&dword_805D13C, v40);
        if ( (v41 - 1) * (_BYTE)v47 & 1 )
          abort();
      }
      __asm { popfw }
      v42 = _InterlockedExchange(&dword_805D1C0, v47);
      v43 = _InterlockedExchange(&dword_805D1C0, v34);
      _InterlockedExchange(&dword_805D1C0, v42);
      sub_8054A34(_CF, _ZF, _SF, _OF, v35, v43);
    }
    __asm { popfw }
    result = v46;
  }
  return result;
}
// 8055A4A: could not find valid save-restore pair for ebx
// 8055A4A: could not find valid save-restore pair for ebp
// 805D10C: using guessed type int dword_805D10C;
// 805D118: using guessed type int dword_805D118;
// 805D13C: using guessed type int dword_805D13C;
// 805D154: using guessed type int dword_805D154;
// 805D1C0: using guessed type int dword_805D1C0;

//----- (08055BB2) --------------------------------------------------------
int __usercall sub_8055BB2@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, FILE *stream, int a4, int a5, int a6)
{
  char *v6; // edx
  char *v7; // eax
  signed __int32 v12; // eax
  unsigned __int32 v13; // eax
  signed __int32 v14; // edx
  signed __int32 v15; // ecx
  bool v16; // cf
  bool v17; // zf
  bool v18; // sf
  char v19; // of
  signed __int32 v20; // eax
  int v21; // eax
  __off64_t v22; // rax
  signed __int32 v23; // ecx
  int v24; // edx
  char v29; // al
  signed __int32 v30; // ebx
  signed __int32 v31; // et2
  signed __int32 v32; // ebx
  int v33; // eax
  signed __int32 v38; // ebx
  signed __int32 v39; // ecx
  signed __int32 v40; // ebx
  signed __int32 v41; // ett
  unsigned int v42; // eax
  signed __int32 v43; // edx
  char v44; // al
  signed __int32 v45; // et1
  int v46; // eax
  signed __int32 v51; // ebx
  signed __int32 v52; // ecx
  signed __int32 v53; // ebx
  signed __int32 v54; // et2
  unsigned __int32 v55; // eax
  signed __int32 v56; // edx
  signed __int32 v57; // ecx
  signed __int32 v58; // ebx
  signed __int32 v59; // ett
  int result; // eax
  signed __int32 v61; // [esp-Ah] [ebp-42h]
  __off64_t v62; // [esp+28h] [ebp-10h]

  if ( stream->_IO_read_end != stream->_IO_read_ptr )
    return fseeko64(stream, a4, a5, a6);
  v6 = stream->_IO_write_ptr;
  v7 = stream->_IO_write_base;
  _CF = v6 < v7;
  _OF = __OFSUB__(v6, v7);
  _ZF = v6 == v7;
  _SF = v6 - v7 < 0;
  if ( v6 != v7 )
    return fseeko64(stream, a4, a5, a6);
  __asm { pushfw }
  v12 = _InterlockedExchange(&dword_805D184, (signed __int32)v7);
  _InterlockedExchange(&dword_805D184, (signed __int32)v6);
  v13 = sub_804C065(_CF, _ZF, _SF, _OF, _InterlockedExchange(&dword_805D184, v12), a1, a2);
  v16 = v13 < 0x12C;
  v19 = __OFSUB__(v13, 300);
  v17 = v13 == 300;
  v18 = (signed int)(v13 - 300) < 0;
  if ( v13 != 300 )
  {
    v20 = _InterlockedExchange(&dword_805D184, v13);
    _InterlockedExchange(&dword_805D184, v15);
    sub_804C18B(v16, v17, v18, v19, v14, _InterlockedExchange(&dword_805D184, v20), a2);
  }
  __asm { popfw }
  if ( stream->_IO_save_base )
    return fseeko64(stream, a4, a5, a6);
  v21 = fileno(stream);
  LODWORD(v22) = lseek64(v21, a4, a5, a6);
  v62 = v22;
  v24 = ~HIDWORD(v22);
  LODWORD(v22) = v24 | ~(_DWORD)v22;
  _CF = 0;
  _OF = 0;
  _ZF = (_DWORD)v22 == 0;
  _SF = (signed int)v22 < 0;
  if ( (_DWORD)v22 )
  {
    stream->_flags &= 0xFFFFFFEF;
    stream->_offset = v62;
    result = 0;
  }
  else
  {
    __asm { pushfw }
    v61 = a2;
    if ( a2 >= 10 )
    {
      v29 = a2;
      v30 = _InterlockedExchange(&dword_805D154, a2);
      v31 = _InterlockedExchange(&dword_805D154, v24);
      v24 = _InterlockedExchange(&dword_805D154, v30);
      v32 = v31 - 1;
      v33 = ((_BYTE)v31 - 1) * v29 & 1;
      _CF = 0;
      _OF = 0;
      _ZF = v33 == 0;
      _SF = v33 < 0;
      if ( v33 )
      {
        __asm { pushfw }
        v38 = _InterlockedExchange(&dword_805D118, v32);
        v41 = _InterlockedExchange(&dword_805D118, v23);
        v39 = v38;
        v40 = v41;
        _InterlockedExchange(&dword_805D118, v39);
        v42 = sub_804B6EB();
        if ( v42 != -916 )
          sub_804B6F5(
            v42 < 0xFFFFFC6C,
            v42 == -916,
            (signed int)(v42 + 916) < 0,
            __OFSUB__(v42, -916),
            _InterlockedExchange(&dword_805D118, _InterlockedExchange(&dword_805D118, v40)),
            _InterlockedExchange(&dword_805D118, v43));
        __asm { popfw }
        abort();
      }
    }
    __asm
    {
      popfw
      pushfw
    }
    if ( v61 >= 10 )
    {
      v45 = _InterlockedExchange(&dword_805D1B4, v61);
      v44 = _InterlockedExchange(&dword_805D1B4, v24);
      _InterlockedExchange(&dword_805D1B4, v45);
      v46 = ((_BYTE)v61 - 1) * v44 & 1;
      _CF = 0;
      _OF = 0;
      _ZF = v46 == 0;
      _SF = v46 < 0;
      if ( v46 )
      {
        __asm { pushfw }
        v51 = _InterlockedExchange(&dword_805D190, v61 - 1);
        v54 = _InterlockedExchange(&dword_805D190, v23);
        v52 = v51;
        v53 = v54;
        _InterlockedExchange(&dword_805D190, v52);
        v55 = sub_80554DE();
        if ( v55 != 553 )
        {
          v58 = _InterlockedExchange(&dword_805D190, v53);
          v59 = _InterlockedExchange(&dword_805D190, v56);
          _InterlockedExchange(&dword_805D190, v58);
          sub_80554E8(v55 < 0x229, v55 == 553, (signed int)(v55 - 553) < 0, __OFSUB__(v55, 553), v55, v57, v59);
        }
        __asm { popfw }
        abort();
      }
    }
    __asm { popfw }
    result = -1;
  }
  return result;
}
// 8048DC0: using guessed type int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8049030: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 805D118: using guessed type int dword_805D118;
// 805D154: using guessed type int dword_805D154;
// 805D184: using guessed type int dword_805D184;
// 805D190: using guessed type int dword_805D190;
// 805D1B4: using guessed type int dword_805D1B4;

//----- (08055DB4) --------------------------------------------------------
signed int sub_8055DB4()
{
  return -64;
}

//----- (08055DBF) --------------------------------------------------------
size_t __usercall sub_8055DBF@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>, int a8@<ebp>, wchar_t *pwc, const char *s, signed int n, mbstate_t *p)
{
  signed __int32 v12; // eax
  unsigned int v13; // eax
  signed __int32 v14; // edx
  signed __int32 v15; // edx
  int v17; // eax
  signed __int32 v18; // edx
  signed __int32 v23; // ebx
  signed __int32 v24; // ecx
  signed __int32 v25; // ecx
  signed __int32 v26; // ebx
  signed __int32 v27; // ett
  signed __int32 v28; // edx
  unsigned int v29; // eax
  signed __int32 v30; // edx
  signed __int32 v31; // ecx
  signed __int32 v32; // eax
  char v37; // al
  signed __int32 v38; // ebx
  char v39; // t2
  signed __int32 v40; // ebx
  unsigned __int32 v41; // [esp-Ah] [ebp-36h]
  signed __int32 v42; // [esp-Ah] [ebp-36h]
  int v43; // [esp+18h] [ebp-14h]
  size_t v44; // [esp+1Ch] [ebp-10h]
  int v45; // [esp+28h] [ebp-4h]

  v45 = a5;
  __asm { pushfw }
  v12 = _InterlockedExchange(&dword_805D118, a5);
  _InterlockedExchange(&dword_805D118, a6);
  _InterlockedExchange(&dword_805D118, v12);
  v13 = sub_804B6EB();
  if ( v13 != -916 )
    sub_804B6F5(
      v13 < 0xFFFFFC6C,
      v13 == -916,
      (signed int)(v13 + 916) < 0,
      __OFSUB__(v13, -916),
      _InterlockedExchange(&dword_805D118, _InterlockedExchange(&dword_805D118, a7)),
      _InterlockedExchange(&dword_805D118, v14));
  __asm { popfw }
  v45 = a8;
  if ( !pwc )
    pwc = &v43;
  v44 = mbrtowc(pwc, s, n, p);
  if ( v44 <= 0xFFFFFFFD )
    return v44;
  _CF = 0;
  _OF = 0;
  _ZF = n == 0;
  _SF = n < 0;
  if ( !n )
    return v44;
  __asm { pushfw }
  v42 = a7;
  if ( a7 >= 10 )
  {
    v37 = a7;
    v38 = _InterlockedExchange(&dword_805D178, a7);
    v39 = _InterlockedExchange(&dword_805D178, v15);
    _InterlockedExchange(&dword_805D178, v38);
    if ( (v39 - 1) * v37 & 1 )
      abort();
  }
  v40 = v42;
  __asm { popfw }
  v17 = sub_80561A0(v42, 0) ^ 1;
  _CF = 0;
  _OF = 0;
  _ZF = (_BYTE)v17 == 0;
  _SF = (v17 & 0x80u) != 0;
  if ( !(_BYTE)v17 )
    return v44;
  __asm { pushfw }
  v41 = sub_80571DD(
          0,
          (_BYTE)v17 == 0,
          (v17 & 0x80u) != 0,
          0,
          _InterlockedExchange(&dword_805D1A8, v18),
          _InterlockedExchange(&dword_805D1A8, _InterlockedExchange(&dword_805D1A8, v17)),
          v42);
  __asm { pushfw }
  v23 = _InterlockedExchange(&dword_805D184, v40);
  v27 = _InterlockedExchange(&dword_805D184, v24);
  v25 = v23;
  v26 = v27;
  v29 = sub_804C065(_CF, _ZF, _SF, _OF, v28, _InterlockedExchange(&dword_805D184, v25), v27);
  if ( v29 != 300 )
    sub_804C18B(
      v29 < 0x12C,
      v29 == 300,
      (signed int)(v29 - 300) < 0,
      __OFSUB__(v29, 300),
      _InterlockedExchange(&dword_805D184, _InterlockedExchange(&dword_805D184, v26)),
      v31,
      _InterlockedExchange(&dword_805D184, v30));
  __asm { popfw }
  if ( v41 != -517 )
  {
    v32 = _InterlockedExchange(&dword_805D1A8, v41);
    _InterlockedExchange(&dword_805D1A8, v30);
    _InterlockedExchange(&dword_805D1A8, v32);
    sub_8057259(v41 < 0xFFFFFDFB, v41 == -517, (signed int)(v41 + 517) < 0, __OFSUB__(v41, -517), v31, v26);
  }
  __asm { popfw }
  *pwc = *(unsigned __int8 *)s;
  return 1;
}
// 8055DBF: could not find valid save-restore pair for ebp
// 805D118: using guessed type int dword_805D118;
// 805D178: using guessed type int dword_805D178;
// 805D184: using guessed type int dword_805D184;
// 805D1A8: using guessed type int dword_805D1A8;

//----- (08055F4B) --------------------------------------------------------
int __usercall sub_8055F4B@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, unsigned __int8 *a3, unsigned __int8 *a4)
{
  unsigned __int8 *v4; // esi
  unsigned __int8 *v5; // ebx
  signed __int32 v7; // edx
  signed __int32 v8; // ecx
  unsigned __int8 v9; // [esp+1Eh] [ebp-Ah]
  unsigned __int8 v10; // [esp+1Fh] [ebp-9h]

  v4 = a3;
  v5 = a4;
  if ( a3 == a4 )
    return 0;
  do
  {
    v9 = sub_8056DCA(a1, a2, (signed __int32)v5, *v4);
    v10 = sub_8056DCA(v7, v8, (signed __int32)v5, *v5);
    if ( !v9 )
      break;
    ++v4;
    ++v5;
  }
  while ( v9 == v10 );
  return v9 - v10;
}

//----- (08055FB0) --------------------------------------------------------
signed __int32 __usercall sub_8055FB0@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>, FILE *fp)
{
  signed __int32 v7; // ebx
  signed __int32 v8; // ecx
  signed __int32 v9; // ebx
  signed __int32 v10; // et0
  unsigned int v11; // eax
  signed __int32 v12; // edx
  signed __int32 v13; // ecx
  signed __int32 v22; // ebx
  signed __int32 v23; // ecx
  signed __int32 v24; // ebx
  signed __int32 v25; // et1
  unsigned __int32 v26; // eax
  signed __int32 v27; // ecx
  signed __int32 v28; // ebx
  char v29; // al
  signed __int32 v30; // ebx
  char v31; // tt
  signed __int32 v32; // ebx
  signed __int32 v33; // et0
  int v34; // eax
  bool v35; // ST26_1
  signed __int32 v36; // ecx
  signed __int32 v37; // edx
  signed __int32 v38; // ecx
  int v39; // eax
  signed __int32 v44; // eax
  unsigned __int32 v45; // eax
  unsigned int v46; // eax
  signed __int32 v51; // eax
  signed __int32 v52; // ebx
  signed __int32 v53; // edx
  signed __int32 v54; // ett
  signed __int32 v55; // eax
  signed __int32 v56; // eax
  signed __int32 v57; // ebx
  signed __int32 v58; // ecx
  signed __int32 v59; // ebx
  signed __int32 v60; // et1
  unsigned int v61; // eax
  signed __int32 v62; // edx
  signed __int32 v63; // ecx
  signed __int32 v64; // ebx
  signed __int32 v65; // et2
  signed __int32 v67; // [esp-4h] [ebp-30h]
  signed __int32 v68; // [esp+1Ch] [ebp-10h]
  bool v69; // [esp+1Dh] [ebp-Fh]
  char v70; // [esp+1Fh] [ebp-Dh]
  signed __int32 v71; // [esp+22h] [ebp-Ah]

  __asm { pushfw }
  v7 = _InterlockedExchange(&dword_805D190, a6);
  v10 = _InterlockedExchange(&dword_805D190, a5);
  v8 = v7;
  v9 = v10;
  _InterlockedExchange(&dword_805D190, v8);
  v11 = sub_80554DE();
  _CF = v11 < 0x229;
  _OF = __OFSUB__(v11, 553);
  _ZF = v11 == 553;
  _SF = (signed int)(v11 - 553) < 0;
  if ( v11 != 553 )
  {
    v71 = v11;
    __asm { pushfw }
    v68 = v9;
    _CF = (unsigned int)v9 < 0xA;
    _OF = __OFSUB__(v9, 10);
    _ZF = v9 == 10;
    _SF = v9 - 10 < 0;
    if ( v9 >= 10 )
    {
      __asm { pushfw }
      v22 = _InterlockedExchange(&dword_805D130, v9);
      v25 = _InterlockedExchange(&dword_805D130, v13);
      v23 = v22;
      v24 = v25;
      _InterlockedExchange(&dword_805D130, v23);
      v26 = sub_80527A0();
      if ( v26 != 553 )
      {
        v28 = _InterlockedExchange(&dword_805D130, v24);
        _InterlockedExchange(&dword_805D130, v12);
        sub_80527AA(
          v26 < 0x229,
          v26 == 553,
          (signed int)(v26 - 553) < 0,
          __OFSUB__(v26, 553),
          v26,
          _InterlockedExchange(&dword_805D130, v28));
      }
      __asm { popfw }
      v29 = v24;
      v30 = _InterlockedExchange(&dword_805D148, v24);
      v31 = _InterlockedExchange(&dword_805D148, v27);
      v13 = _InterlockedExchange(&dword_805D148, v30);
      if ( (v31 - 1) * v29 & 1 )
        abort();
    }
    __asm { popfw }
    v32 = _InterlockedExchange(&dword_805D190, v68);
    v33 = _InterlockedExchange(&dword_805D190, v12);
    _InterlockedExchange(&dword_805D190, v32);
    sub_80554E8(_CF, _ZF, _SF, _OF, v71, v13, v33);
  }
  __asm { popfw }
  v69 = __fpending(fp) != 0;
  v34 = ferror_unlocked(fp);
  v35 = v34 != 0;
  v39 = sub_8055264(0, v34 == 0, v34 < 0, 0, (signed __int32)fp, v36, v9, fp);
  LOBYTE(v39) = v39 != 0;
  v70 = v39;
  if ( v35 )
    goto LABEL_25;
  _CF = 0;
  _OF = 0;
  _ZF = (_BYTE)v39 == 0;
  _SF = (v39 & 0x80u) != 0;
  if ( !(_BYTE)v39 )
    goto LABEL_26;
  __asm { pushfw }
  v44 = _InterlockedExchange(&dword_805D190, v39);
  _InterlockedExchange(&dword_805D190, v38);
  _InterlockedExchange(&dword_805D190, v44);
  v45 = sub_80554DE();
  if ( v45 != 553 )
    sub_80554E8(
      v45 < 0x229,
      v45 == 553,
      (signed int)(v45 - 553) < 0,
      __OFSUB__(v45, 553),
      _InterlockedExchange(&dword_805D190, v38),
      _InterlockedExchange(&dword_805D190, _InterlockedExchange(&dword_805D190, v45)),
      v9);
  __asm { popfw }
  if ( v69
    || (v46 = *__errno_location(),
        _CF = v46 < 9,
        _OF = __OFSUB__(v46, 9),
        _ZF = v46 == 9,
        _SF = (signed int)(v46 - 9) < 0,
        v46 != 9) )
  {
LABEL_25:
    _CF = 0;
    _OF = 0;
    _ZF = v70 == 1;
    _SF = ((v70 ^ 1) & 0x80u) != 0;
    if ( v70 != 1 )
      *__errno_location() = 0;
    v51 = -1;
  }
  else
  {
LABEL_26:
    __asm { pushfw }
    v52 = _InterlockedExchange(&dword_805D10C, v9);
    v54 = _InterlockedExchange(&dword_805D10C, v37);
    v53 = v52;
    v9 = v54;
    _InterlockedExchange(&dword_805D10C, v53);
    v55 = sub_8049617();
    if ( v55 != -795 )
    {
      v56 = _InterlockedExchange(&dword_805D10C, v55);
      _InterlockedExchange(&dword_805D10C, v37);
      sub_8049621(v38, _InterlockedExchange(&dword_805D10C, v56));
    }
    __asm { popfw }
    v51 = 0;
  }
  v67 = v51;
  __asm { pushfw }
  v57 = _InterlockedExchange(&dword_805D154, v9);
  v60 = _InterlockedExchange(&dword_805D154, v38);
  v58 = v57;
  v59 = v60;
  v61 = sub_804B1D3(_CF, _ZF, _SF, _OF, v51, v37, _InterlockedExchange(&dword_805D154, v58), v60);
  if ( v61 != 15 )
  {
    v64 = _InterlockedExchange(&dword_805D154, v59);
    v65 = _InterlockedExchange(&dword_805D154, v62);
    _InterlockedExchange(&dword_805D154, v64);
    sub_804B283(v61 < 0xF, v61 == 15, (signed int)(v61 - 15) < 0, __OFSUB__(v61, 15), v63, v65);
  }
  __asm { popfw }
  return v67;
}
// 8055FB0: could not find valid save-restore pair for ebp
// 8049621: using guessed type int __fastcall sub_8049621(_DWORD, _DWORD);
// 805D10C: using guessed type int dword_805D10C;
// 805D130: using guessed type int dword_805D130;
// 805D148: using guessed type int dword_805D148;
// 805D154: using guessed type int dword_805D154;
// 805D190: using guessed type int dword_805D190;

//----- (080561A0) --------------------------------------------------------
int __usercall sub_80561A0@<eax>(signed __int32 a1@<ebx>, int category)
{
  int v2; // eax
  signed __int32 v3; // edx
  signed __int32 v4; // ecx
  char v9; // al
  signed __int32 v10; // et0
  signed __int32 v11; // eax
  signed __int32 v12; // et1
  unsigned __int32 v13; // eax
  signed __int32 v14; // edx
  signed __int32 v15; // ecx
  bool v16; // cf
  bool v17; // zf
  bool v18; // sf
  char v19; // of
  signed __int32 v20; // eax
  char v21; // al
  signed __int32 v22; // ett
  signed __int32 v23; // ecx
  signed __int32 v24; // ebx
  int v25; // eax
  signed __int32 v30; // eax
  unsigned __int32 v31; // eax
  signed __int32 v32; // edx
  signed __int32 v37; // eax
  signed __int32 v38; // eax
  signed __int32 v39; // edx
  signed __int32 v40; // ecx
  signed __int32 v41; // eax
  signed __int32 v43; // [esp-14h] [ebp-3Ch]
  int v44; // [esp-4h] [ebp-2Ch]
  unsigned __int8 v45; // [esp+1Bh] [ebp-Dh]
  const char *s1; // [esp+1Ch] [ebp-Ch]

  v45 = 1;
  s1 = setlocale(category, 0);
  if ( s1 )
  {
    v2 = strcmp(s1, "C");
    _CF = 0;
    _OF = 0;
    _ZF = v2 == 0;
    _SF = v2 < 0;
    if ( !v2 )
      goto LABEL_20;
    v44 = strcmp(s1, "POSIX");
    __asm { pushfw }
    if ( a1 >= 10 )
    {
      v10 = _InterlockedExchange(&dword_805D13C, a1);
      v9 = _InterlockedExchange(&dword_805D13C, v4);
      v4 = _InterlockedExchange(&dword_805D13C, v10);
      if ( ((_BYTE)a1 - 1) * v9 & 1 )
        abort();
    }
    __asm { popfw }
    v2 = v44;
    _CF = 0;
    _OF = 0;
    _ZF = v44 == 0;
    _SF = v44 < 0;
    if ( !v44 )
    {
LABEL_20:
      __asm { pushfw }
      v12 = _InterlockedExchange(&dword_805D1A8, v2);
      v11 = _InterlockedExchange(&dword_805D1A8, v4);
      _InterlockedExchange(&dword_805D1A8, v12);
      v13 = sub_80571DD(0, _ZF, _SF, 0, v11, v3, a1);
      v16 = v13 < 0xFFFFFDFB;
      v19 = __OFSUB__(v13, -517);
      v17 = v13 == -517;
      v18 = (signed int)(v13 + 517) < 0;
      if ( v13 != -517 )
      {
        v20 = _InterlockedExchange(&dword_805D1A8, v13);
        _InterlockedExchange(&dword_805D1A8, v14);
        _InterlockedExchange(&dword_805D1A8, v20);
        sub_8057259(v16, v17, v18, v19, v15, a1);
      }
      __asm
      {
        popfw
        pushfw
      }
      if ( a1 >= 10 )
      {
        v22 = _InterlockedExchange(&dword_805D1C0, a1);
        v21 = _InterlockedExchange(&dword_805D1C0, v15);
        v23 = _InterlockedExchange(&dword_805D1C0, v22);
        v24 = a1 - 1;
        v25 = (_BYTE)v24 * v21 & 1;
        _CF = 0;
        _OF = 0;
        _ZF = v25 == 0;
        _SF = v25 < 0;
        if ( v25 )
        {
          __asm { pushfw }
          v30 = _InterlockedExchange(&dword_805D1B4, v25);
          _InterlockedExchange(&dword_805D1B4, v23);
          _InterlockedExchange(&dword_805D1B4, v30);
          v31 = sub_8056BAD();
          _CF = v31 < 0x2BE;
          _OF = __OFSUB__(v31, 702);
          _ZF = v31 == 702;
          _SF = (signed int)(v31 - 702) < 0;
          if ( v31 != 702 )
          {
            v43 = v31;
            __asm { pushfw }
            v37 = _InterlockedExchange(&dword_805D10C, v31);
            _InterlockedExchange(&dword_805D10C, v32);
            _InterlockedExchange(&dword_805D10C, v37);
            v38 = sub_8049617();
            if ( v38 != -795 )
            {
              v41 = _InterlockedExchange(&dword_805D10C, v38);
              _InterlockedExchange(&dword_805D10C, v39);
              sub_8049621(v40, _InterlockedExchange(&dword_805D10C, v41));
            }
            __asm { popfw }
            sub_8056BB7(
              _CF,
              _ZF,
              _SF,
              _OF,
              v43,
              _InterlockedExchange(&dword_805D1B4, _InterlockedExchange(&dword_805D1B4, v24)),
              _InterlockedExchange(&dword_805D1B4, v40));
          }
          __asm { popfw }
          abort();
        }
      }
      __asm { popfw }
      v45 = 0;
    }
  }
  return v45;
}
// 8049621: using guessed type int __fastcall sub_8049621(_DWORD, _DWORD);
// 805D10C: using guessed type int dword_805D10C;
// 805D13C: using guessed type int dword_805D13C;
// 805D1A8: using guessed type int dword_805D1A8;
// 805D1B4: using guessed type int dword_805D1B4;
// 805D1C0: using guessed type int dword_805D1C0;

//----- (0805632E) --------------------------------------------------------
void *__usercall sub_805632E@<eax>(signed __int32 a1@<ebx>)
{
  _BOOL4 v1; // eax
  signed __int32 v2; // edx
  signed __int32 v3; // ecx
  char v4; // al
  signed __int32 v5; // et0
  char v10; // al
  signed __int32 v11; // et1
  signed __int32 v12; // ecx
  signed __int32 v17; // ebx
  signed __int32 v18; // eax
  signed __int32 v19; // edx
  int v20; // ecx
  signed __int32 v21; // eax
  unsigned int v22; // eax
  signed __int32 v23; // edx
  signed __int32 v24; // ecx
  bool v25; // cf
  bool v26; // zf
  bool v27; // sf
  char v28; // of
  size_t v29; // eax
  signed __int32 v30; // eax
  unsigned int v31; // eax
  signed __int32 v32; // ecx
  signed __int32 v33; // ebx
  signed __int32 v34; // ecx
  signed __int32 v35; // ecx
  signed __int32 v36; // et2
  signed __int32 v37; // edx
  int v38; // ecx
  signed __int32 v39; // ebx
  int v40; // eax
  void *v46; // [esp+18h] [ebp-B0h]
  const char *s; // [esp+1Ch] [ebp-ACh]
  void *v48; // [esp+20h] [ebp-A8h]
  int v49; // [esp+24h] [ebp-A4h]
  size_t n; // [esp+2Ch] [ebp-9Ch]
  size_t v51; // [esp+30h] [ebp-98h]
  _BOOL4 v52; // [esp+34h] [ebp-94h]
  char *dest; // [esp+38h] [ebp-90h]
  int fd; // [esp+3Ch] [ebp-8Ch]
  FILE *stream; // [esp+40h] [ebp-88h]
  unsigned int c; // [esp+44h] [ebp-84h]
  unsigned int ca; // [esp+44h] [ebp-84h]
  size_t v58; // [esp+48h] [ebp-80h]
  size_t v59; // [esp+4Ch] [ebp-7Ch]
  void *v60; // [esp+50h] [ebp-78h]
  char src; // [esp+56h] [ebp-72h]
  char v62; // [esp+89h] [ebp-3Fh]
  unsigned int v63; // [esp+BCh] [ebp-Ch]

  v63 = __readgsdword(0x14u);
  v46 = (void *)dword_805D946;
  if ( !dword_805D946 )
  {
    s = getenv("CHARSETALIASDIR");
    if ( !s || !*s )
      s = "/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib";
    n = strlen(s);
    v51 = strlen("charset.alias");
    v1 = n && s[n - 1] != 47;
    v52 = v1;
    dest = (char *)malloc(n + v1 + v51 + 1);
    if ( dest )
    {
      memcpy(dest, s, n);
      __asm { pushfw }
      if ( a1 >= 10 )
      {
        v5 = _InterlockedExchange(&dword_805D19C, a1);
        v4 = _InterlockedExchange(&dword_805D19C, v3);
        _InterlockedExchange(&dword_805D19C, v5);
        if ( ((_BYTE)a1 - 1) * v4 & 1 )
          abort();
      }
      __asm { popfw }
      _CF = 0;
      _OF = 0;
      _ZF = v52 == 0;
      _SF = v52 < 0;
      if ( v52 )
      {
        v2 = (signed __int32)dest;
        _CF = __CFADD__(dest, n);
        _OF = __OFADD__(dest, n);
        _ZF = &dest[n] == 0;
        _SF = (signed int)&dest[n] < 0;
        dest[n] = 47;
      }
      __asm { pushfw }
      if ( a1 >= 10 )
      {
        v11 = _InterlockedExchange(&dword_805D160, a1);
        v10 = _InterlockedExchange(&dword_805D160, v2);
        _InterlockedExchange(&dword_805D160, v11);
        if ( ((_BYTE)a1 - 1) * v10 & 1 )
          abort();
      }
      __asm { popfw }
      memcpy(&dest[n + v52], "charset.alias", v51 + 1);
    }
    free(0);
    if ( dest )
    {
      fd = open64(dest, 0x20000);
      if ( fd >= 0 )
      {
        stream = fdopen(fd, "r");
        _CF = 0;
        _OF = 0;
        _ZF = stream == 0;
        _SF = (signed int)stream < 0;
        if ( stream )
        {
          v48 = 0;
          v49 = 0;
          while ( 1 )
          {
            v22 = getc_unlocked(stream);
            c = v22;
            v25 = v22 < 0xFFFFFFFF;
            v28 = __OFSUB__(v22, -1);
            v26 = v22 == -1;
            v27 = (signed int)(v22 + 1) < 0;
            if ( v22 == -1 )
              break;
            if ( v22 != 10 && v22 != 32 && v22 != 9 )
            {
              _CF = v22 < 0x23;
              _OF = __OFSUB__(v22, 35);
              _ZF = v22 == 35;
              _SF = (signed int)(v22 - 35) < 0;
              if ( v22 == 35 )
              {
                do
                  ca = getc_unlocked(stream);
                while ( ca != -1 && ca != 10 );
                v25 = ca < 0xFFFFFFFF;
                v28 = __OFSUB__(ca, -1);
                v26 = ca == -1;
                v27 = (signed int)(ca + 1) < 0;
                if ( ca == -1 )
                  break;
              }
              else
              {
                __asm { pushfw }
                v30 = _InterlockedExchange(&dword_805D1C0, v22);
                _InterlockedExchange(&dword_805D1C0, v24);
                v31 = sub_8054904(
                        c < 0x23,
                        c == 35,
                        (signed int)(c - 35) < 0,
                        __OFSUB__(c, 35),
                        v23,
                        _InterlockedExchange(&dword_805D1C0, v30),
                        a1);
                if ( v31 != 655 )
                  sub_8054A34(
                    v31 < 0x28F,
                    v31 == 655,
                    (signed int)(v31 - 655) < 0,
                    __OFSUB__(v31, 655),
                    _InterlockedExchange(&dword_805D1C0, _InterlockedExchange(&dword_805D1C0, a1)),
                    _InterlockedExchange(&dword_805D1C0, v32));
                __asm { popfw }
                ungetc(c, stream);
                __asm { pushfw }
                v33 = _InterlockedExchange(&dword_805D124, a1);
                v36 = _InterlockedExchange(&dword_805D124, v34);
                v35 = v33;
                a1 = v36;
                _InterlockedExchange(&dword_805D124, v35);
                if ( sub_804972F() != 949 )
                {
                  v39 = _InterlockedExchange(&dword_805D124, a1);
                  _InterlockedExchange(&dword_805D124, v37);
                  sub_8049739(v38, _InterlockedExchange(&dword_805D124, v39));
                }
                __asm { popfw }
                v40 = fscanf(stream, "%50s %50s", &src, &v62);
                v25 = (unsigned int)v40 < 1;
                v28 = __OFSUB__(v40, 1);
                v26 = v40 == 1;
                v27 = v40 - 1 < 0;
                if ( v40 <= 1 )
                  break;
                v58 = strlen(&src);
                v29 = strlen(&v62);
                v59 = v29;
                v60 = v48;
                if ( v49 )
                {
                  v49 += v29 + v58 + 2;
                  v48 = realloc(v48, v49 + 1);
                }
                else
                {
                  v49 = v58 + v29 + 2;
                  v48 = malloc(v58 + v29 + 3);
                }
                if ( !v48 )
                {
                  v49 = 0;
                  free(v60);
                  break;
                }
                strcpy((char *)v48 + v49 - v59 - v58 - 2, &src);
                strcpy((char *)v48 + v49 - v59 - 1, &v62);
              }
            }
          }
          sub_8055264(v25, v26, v27, v28, (signed __int32)stream, v24, a1, stream);
          if ( v49 )
          {
            *((_BYTE *)v48 + v49) = 0;
            v46 = v48;
          }
          else
          {
            v46 = &unk_80591CB;
          }
        }
        else
        {
          __asm { pushfw }
          v17 = _InterlockedExchange(&dword_805D13C, a1);
          _InterlockedExchange(&dword_805D13C, v12);
          _InterlockedExchange(&dword_805D13C, v17);
          v18 = sub_8055DB4();
          if ( v18 != -64 )
          {
            v21 = _InterlockedExchange(&dword_805D13C, v18);
            _InterlockedExchange(&dword_805D13C, v19);
            sub_8055DBE(v20, _InterlockedExchange(&dword_805D13C, v21));
          }
          __asm { popfw }
          close(fd);
          v46 = &unk_80591CB;
        }
      }
      else
      {
        v46 = &unk_80591CB;
      }
      free(dest);
    }
    else
    {
      v46 = &unk_80591CB;
    }
    dword_805D946 = (int)v46;
  }
  return v46;
}
// 8048D10: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 8049739: using guessed type int __fastcall sub_8049739(_DWORD, _DWORD);
// 8055DBE: using guessed type int __fastcall sub_8055DBE(_DWORD, _DWORD);
// 805D124: using guessed type int dword_805D124;
// 805D13C: using guessed type int dword_805D13C;
// 805D160: using guessed type int dword_805D160;
// 805D19C: using guessed type int dword_805D19C;
// 805D1C0: using guessed type int dword_805D1C0;
// 805D946: using guessed type int dword_805D946;

//----- (0805690D) --------------------------------------------------------
const char *__usercall sub_805690D@<eax>(signed __int32 a1@<ebx>)
{
  char *v1; // ST1C_4
  const char *s1; // [esp+18h] [ebp-10h]
  char *s2; // [esp+1Ch] [ebp-Ch]

  s1 = nl_langinfo(14);
  if ( !s1 )
    s1 = (const char *)&unk_80591CB;
  for ( s2 = (char *)sub_805632E(a1); *s2; s2 = &v1[strlen(v1) + 1] )
  {
    if ( !strcmp(s1, s2) || *s2 == 42 && !s2[1] )
    {
      s1 = &s2[strlen(s2) + 1];
      break;
    }
    v1 = &s2[strlen(s2) + 1];
  }
  if ( !*s1 )
    s1 = "ASCII";
  return s1;
}

//----- (08056BAD) --------------------------------------------------------
signed int sub_8056BAD()
{
  return 702;
}

//----- (08056BB7) --------------------------------------------------------
void __usercall __noreturn sub_8056BB7(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>)
{
  signed __int32 v7; // eax
  signed __int32 v8; // edx
  signed __int32 v9; // ecx
  signed __int32 v10; // ebx
  char v11; // al
  signed __int32 v12; // ebx
  char v13; // t2
  signed __int32 v14; // eax
  unsigned int v15; // eax
  signed __int32 v16; // edx
  signed __int32 v17; // ecx
  char v18; // al
  signed __int32 v19; // et1
  signed __int32 v20; // ebx
  char v21; // t2
  signed __int32 v22; // [esp-Ah] [ebp-Ah]
  signed __int32 v23; // [esp-4h] [ebp-4h]

  v23 = a5;
  __asm { pushfw }
  v7 = _InterlockedExchange(&dword_805D124, a5);
  _InterlockedExchange(&dword_805D124, a6);
  _InterlockedExchange(&dword_805D124, v7);
  if ( sub_804972F() != 949 )
  {
    v10 = _InterlockedExchange(&dword_805D124, a7);
    _InterlockedExchange(&dword_805D124, v8);
    sub_8049739(v9, _InterlockedExchange(&dword_805D124, v10));
  }
  __asm
  {
    popfw
    pushfw
  }
  v22 = a7;
  if ( a7 >= 10 )
  {
    v11 = a7;
    v12 = _InterlockedExchange(&dword_805D130, a7);
    v13 = _InterlockedExchange(&dword_805D130, v9);
    v9 = _InterlockedExchange(&dword_805D130, v12);
    if ( (v13 - 1) * v11 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  v14 = _InterlockedExchange(&dword_805D184, v23);
  _InterlockedExchange(&dword_805D184, v9);
  v15 = sub_804C065(_CF, _ZF, _SF, _OF, v8, _InterlockedExchange(&dword_805D184, v14), v22);
  if ( v15 != 300 )
    sub_804C18B(
      v15 < 0x12C,
      v15 == 300,
      (signed int)(v15 - 300) < 0,
      __OFSUB__(v15, 300),
      v16,
      _InterlockedExchange(&dword_805D184, _InterlockedExchange(&dword_805D184, v22)),
      _InterlockedExchange(&dword_805D184, v17));
  __asm
  {
    popfw
    pushfw
  }
  if ( v22 >= 10 )
  {
    v19 = _InterlockedExchange(&dword_805D190, v22);
    v18 = _InterlockedExchange(&dword_805D190, v17);
    _InterlockedExchange(&dword_805D190, v19);
    if ( ((_BYTE)v22 - 1) * v18 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( v22 >= 10 )
  {
    v20 = _InterlockedExchange(&dword_805D1A8, v22);
    v21 = _InterlockedExchange(&dword_805D1A8, v16);
    _InterlockedExchange(&dword_805D1A8, v20);
    if ( (v21 - 1) * (_BYTE)v22 & 1 )
      abort();
  }
  __asm { popfw }
  __halt();
  JUMPOUT(loc_8056CD2);
}
// 8049739: using guessed type int __fastcall sub_8049739(_DWORD, _DWORD);
// 805D124: using guessed type int dword_805D124;
// 805D130: using guessed type int dword_805D130;
// 805D184: using guessed type int dword_805D184;
// 805D190: using guessed type int dword_805D190;
// 805D1A8: using guessed type int dword_805D1A8;

//----- (08056DCA) --------------------------------------------------------
signed __int32 __usercall sub_8056DCA@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, signed __int32 a4)
{
  signed __int32 v8; // ebx
  signed __int32 v9; // ecx
  signed __int32 v10; // ebx
  signed __int32 v11; // et0
  char v12; // al
  signed __int32 v13; // et1
  signed __int32 v14; // eax
  signed __int32 v15; // eax
  signed __int32 v16; // eax
  int v17; // edx
  signed __int32 v18; // ecx
  signed __int32 v19; // eax
  char v20; // al
  signed __int32 v21; // ebx
  char v22; // t1
  signed __int32 v24; // [esp-10h] [ebp-10h]
  unsigned __int32 v25; // [esp-Ah] [ebp-Ah]
  signed __int32 v26; // [esp-4h] [ebp-4h]

  _CF = (unsigned int)(a4 - 65) < 0x19;
  _OF = __OFSUB__(a4 - 65, 25);
  _ZF = a4 == 90;
  _SF = a4 - 90 < 0;
  if ( (unsigned int)(a4 - 65) > 0x19 )
  {
    v14 = a4;
  }
  else
  {
    __asm { pushfw }
    v8 = _InterlockedExchange(&dword_805D16C, a3);
    v11 = _InterlockedExchange(&dword_805D16C, a2);
    v9 = v8;
    v10 = v11;
    _InterlockedExchange(&dword_805D16C, v9);
    v25 = sub_804C738();
    __asm { pushfw }
    v24 = v11;
    if ( v11 >= 10 )
    {
      v13 = _InterlockedExchange(&dword_805D148, v10);
      v12 = _InterlockedExchange(&dword_805D148, a1);
      a1 = _InterlockedExchange(&dword_805D148, v13);
      if ( ((_BYTE)v10 - 1) * v12 & 1 )
        abort();
    }
    a3 = v24;
    __asm { popfw }
    if ( v25 != 907 )
      sub_804C742(
        v25 < 0x38B,
        v25 == 907,
        (signed int)(v25 - 907) < 0,
        __OFSUB__(v25, 907),
        v25,
        _InterlockedExchange(&dword_805D16C, _InterlockedExchange(&dword_805D16C, v24)),
        _InterlockedExchange(&dword_805D16C, a1));
    __asm { popfw }
    _CF = __CFADD__(a4, 32);
    _OF = __OFADD__(32, a4);
    _ZF = a4 == -32;
    _SF = a4 + 32 < 0;
    v14 = a4 + 32;
  }
  v26 = v14;
  __asm { pushfw }
  v15 = _InterlockedExchange(&dword_805D10C, v14);
  _InterlockedExchange(&dword_805D10C, a1);
  _InterlockedExchange(&dword_805D10C, v15);
  v16 = sub_8049617();
  if ( v16 != -795 )
  {
    v19 = _InterlockedExchange(&dword_805D10C, v16);
    _InterlockedExchange(&dword_805D10C, v18);
    sub_8049621(_InterlockedExchange(&dword_805D10C, v19), v17);
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( a3 >= 10 )
  {
    v20 = a3;
    v21 = _InterlockedExchange(&dword_805D160, a3);
    v22 = _InterlockedExchange(&dword_805D160, v18);
    _InterlockedExchange(&dword_805D160, v21);
    if ( (v22 - 1) * v20 & 1 )
      abort();
  }
  __asm { popfw }
  return v26;
}
// 8049621: using guessed type int __fastcall sub_8049621(_DWORD, _DWORD);
// 805D10C: using guessed type int dword_805D10C;
// 805D148: using guessed type int dword_805D148;
// 805D160: using guessed type int dword_805D160;
// 805D16C: using guessed type int dword_805D16C;

//----- (08057062) --------------------------------------------------------
int __usercall sub_8057062@<eax>(signed __int32 a1@<ebx>, unsigned __int64 a2, unsigned int a3, unsigned __int32 a4)
{
  int v4; // ecx
  int v5; // edx
  int v6; // ebp
  int v11; // ebp
  char v12; // al
  signed __int32 v13; // ebx
  char v14; // t0
  int result; // eax
  unsigned int v20; // ebp
  unsigned __int64 v21; // rtt
  unsigned __int64 v22; // rax
  unsigned int v23; // edi
  unsigned __int64 v24; // rax
  unsigned int v25; // ecx
  signed __int32 v26; // ecx
  signed __int32 v27; // ebx
  signed __int32 v28; // edx
  signed __int32 v29; // ebx
  signed __int32 v30; // [esp-Ah] [ebp-2Ah]
  int v31; // [esp+4h] [ebp-1Ch]
  __int64 v32; // [esp+8h] [ebp-18h]
  unsigned int v33; // [esp+Ch] [ebp-14h]

  v4 = a2;
  LODWORD(v32) = a2;
  if ( a4 )
  {
    if ( a4 > HIDWORD(a2) )
    {
      result = a2;
    }
    else
    {
      _BitScanReverse((unsigned int *)&v6, a4);
      v11 = v6 ^ 0x1F;
      _CF = 0;
      _OF = 0;
      _ZF = v11 == 0;
      _SF = v11 < 0;
      if ( v11 )
      {
        v31 = (a4 << v11) | (a3 >> (32 - v11));
        HIDWORD(v22) = HIDWORD(a2) >> (32 - v11);
        LODWORD(v22) = (HIDWORD(a2) << v11) | ((unsigned int)a2 >> (32 - v11));
        v33 = (_DWORD)a2 << v11;
        v23 = v22 % (unsigned int)v31;
        v24 = (a3 << v11) * (unsigned __int64)(unsigned int)(v22 / (unsigned int)v31);
        v25 = v24;
        if ( v23 < HIDWORD(v24) || v33 < (unsigned int)v24 && v23 == HIDWORD(v24) )
        {
          HIDWORD(v24) = (v24 - __PAIR__(v31, a3 << v11)) >> 32;
          v25 = v24 - (a3 << v11);
        }
        result = ((__PAIR__(v23, v33) - __PAIR__(HIDWORD(v24), v25)) >> 32 << (32 - (unsigned __int8)v11)) | ((v33 - v25) >> v11);
      }
      else
      {
        __asm { pushfw }
        v30 = a1;
        if ( a1 >= 10 )
        {
          v12 = a1;
          v13 = _InterlockedExchange(&dword_805D190, a1);
          v14 = _InterlockedExchange(&dword_805D190, a4);
          _InterlockedExchange(&dword_805D190, v13);
          if ( (v14 - 1) * v12 & 1 )
            abort();
        }
        __asm { popfw }
        _CF = a3 < (unsigned int)a2;
        _OF = __OFSUB__(a3, (_DWORD)a2);
        _ZF = a3 == (_DWORD)a2;
        _SF = (signed int)(a3 - a2) < 0;
        if ( a3 <= (unsigned int)a2 )
          goto LABEL_28;
        __asm { pushfw }
        v26 = _InterlockedExchange(&dword_805D160, v30);
        v27 = _InterlockedExchange(&dword_805D160, a2);
        _InterlockedExchange(&dword_805D160, v26);
        if ( sub_804F071() != -48 )
        {
          v29 = _InterlockedExchange(&dword_805D160, v27);
          _InterlockedExchange(&dword_805D160, v28);
          sub_804F07B(v4, _InterlockedExchange(&dword_805D160, v29));
        }
        __asm { popfw }
        if ( a4 < HIDWORD(a2) )
LABEL_28:
          LODWORD(v32) = v4 - a3;
        result = v32;
      }
    }
  }
  else
  {
    if ( a3 <= HIDWORD(a2) )
    {
      v20 = a3;
      if ( !a3 )
        v20 = 1 / 0u;
      LODWORD(v21) = a2;
      HIDWORD(v21) = HIDWORD(a2) % v20;
      v5 = v21 % v20;
    }
    else
    {
      v5 = a2 % a3;
    }
    result = v5;
  }
  return result;
}
// 804F07B: using guessed type int __fastcall sub_804F07B(_DWORD, _DWORD);
// 805D160: using guessed type int dword_805D160;
// 805D190: using guessed type int dword_805D190;

//----- (080571DD) --------------------------------------------------------
signed int __usercall sub_80571DD@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>)
{
  signed __int32 v7; // eax
  unsigned __int32 v8; // eax
  signed __int32 v9; // edx
  signed __int32 v10; // ecx
  signed __int32 v15; // ebx
  signed __int32 v16; // et1
  char v17; // al
  signed __int32 v18; // et2

  __asm { pushfw }
  v7 = _InterlockedExchange(&dword_805D16C, a5);
  _InterlockedExchange(&dword_805D16C, a6);
  _InterlockedExchange(&dword_805D16C, v7);
  v8 = sub_804C738();
  _CF = v8 < 0x38B;
  _OF = __OFSUB__(v8, 907);
  _ZF = v8 == 907;
  _SF = (signed int)(v8 - 907) < 0;
  if ( v8 != 907 )
  {
    v15 = _InterlockedExchange(&dword_805D16C, a7);
    v16 = _InterlockedExchange(&dword_805D16C, v10);
    _InterlockedExchange(&dword_805D16C, v15);
    sub_804C742(v8 < 0x38B, v8 == 907, (signed int)(v8 - 907) < 0, __OFSUB__(v8, 907), v8, v9, v16);
  }
  __asm { pushfw }
  if ( a7 >= 10 )
  {
    v18 = _InterlockedExchange(&dword_805D160, a7);
    v17 = _InterlockedExchange(&dword_805D160, v10);
    _InterlockedExchange(&dword_805D160, v18);
    if ( ((_BYTE)a7 - 1) * v17 & 1 )
      abort();
  }
  __asm
  {
    popfw
    popfw
  }
  return -517;
}
// 805D160: using guessed type int dword_805D160;
// 805D16C: using guessed type int dword_805D16C;

//----- (08057259) --------------------------------------------------------
void __usercall __noreturn sub_8057259(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>)
{
  char v6; // al
  signed __int32 v7; // et0

  __asm { pushfw }
  if ( a6 >= 10 )
  {
    v7 = _InterlockedExchange(&dword_805D16C, a6);
    v6 = _InterlockedExchange(&dword_805D16C, a5);
    _InterlockedExchange(&dword_805D16C, v7);
    if ( ((_BYTE)a6 - 1) * v6 & 1 )
      abort();
  }
  __asm { popfw }
  __halt();
  JUMPOUT(loc_805728E);
}
// 805D16C: using guessed type int dword_805D16C;

//----- (08057493) --------------------------------------------------------
int __usercall sub_8057493@<eax>(char a1@<cf>, char a2@<zf>, char a3@<sf>, char a4@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>, int a7)
{
  sub_804C4A0(a1, a2, a3, a4, a5, a6);
  return __cxa_atexit(a7, 0, dword_805D1E0);
}
// 8048E80: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 805D1E0: using guessed type int dword_805D1E0;

//----- (08057BE0) --------------------------------------------------------
int (**sub_8057BE0())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_805CEC0;
  v1 = &off_805CEC4 - off_805CEC0;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_805CEC0[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 805CEC0: using guessed type int (*off_805CEC0[2])();
// 805CEC4: using guessed type int (*off_805CEC4)();

//----- (08057C44) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 2 decompilation failure(s) on 161 function(s)"
