/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8049750();
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// int raise(int sig);
// int dup2(int fd, int fd2);
// int strcmp(const char *s1, const char *s2);
// int putc_unlocked(int c, FILE *stream);
// ssize_t read(int fd, void *buf, size_t nbytes);
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void _exit(int status);
// int __cdecl wcwidth(_DWORD); weak
// void *memmove(void *dest, const void *src, size_t n);
// void free(void *ptr);
// uintmax_t strtoumax(const char *nptr, char **endptr, int base);
// void *memcpy(void *dest, const void *src, size_t n);
// int mbsinit(const mbstate_t *ps);
// int ferror(FILE *stream);
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// int fclose(FILE *stream);
// int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
// int getc_unlocked(FILE *stream);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// __sighandler_t signal(int sig, __sighandler_t handler);
// int __cdecl __sched_cpucount(_DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// double __cdecl strtold(_DWORD, _DWORD); weak
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// int fputc_unlocked(int c, FILE *stream);
// int __cdecl getrlimit64(_DWORD, _DWORD); weak
// int execlp(const char *file, const char *arg, ...);
// int sysconf(int name);
// __uid_t getuid(void);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// int unlink(const char *name);
// int sigismember(const sigset_t *set, int signo);
// int iswcntrl(wint_t wc);
// char *textdomain(const char *domainname);
// int __cdecl fopen64(_DWORD, _DWORD); weak
// int ferror_unlocked(FILE *stream);
// int __cdecl mkostemp64(_DWORD, _DWORD); weak
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD); weak
// size_t __ctype_get_mb_cur_max(void);
// __pid_t waitpid(__pid_t pid, int *stat_loc, int options);
// int pthread_sigmask(int how, const __sigset_t *newmask, __sigset_t *oldmask);
// char *strcpy(char *dest, const char *src);
// size_t __fpending(FILE *fp);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// __pid_t getpid(void);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// int pthread_cond_signal(pthread_cond_t *cond);
// void error(int status, int errnum, const char *format, ...);
// size_t fread_unlocked(void *ptr, size_t size, size_t n, FILE *stream);
// int strcoll(const char *s1, const char *s2);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int sysinfo(struct sysinfo *info);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// char *strchr(const char *s, int c);
// size_t strlen(const char *s);
// int fprintf(FILE *stream, const char *format, ...);
// ssize_t write(int fd, const void *buf, size_t n);
// int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *cond_attr);
// int __cdecl open64(_DWORD, _DWORD); weak
// int fcntl(int fd, int cmd, ...);
// int sigaddset(sigset_t *set, int signo);
// size_t strxfrm(char *dest, const char *src, size_t n);
// int setvbuf(FILE *stream, char *buf, int modes, size_t n);
// __gid_t getgid(void);
// void *memset(void *s, int c, size_t n);
// int *__errno_location(void);
// void *memchr(const void *s, int c, size_t n);
// int fileno(FILE *stream);
// int fgetc(FILE *stream);
// int pipe(int pipedes[2]);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// int __cdecl ftruncate64(_DWORD, _DWORD, _DWORD); weak
// __pid_t fork(void);
// int sigemptyset(sigset_t *set);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// int toupper(int c);
// void clearerr_unlocked(FILE *stream);
// char *strrchr(const char *s, int c);
// int pthread_join(pthread_t th, void **thread_return);
// struct lconv *localeconv(void);
// __pid_t getppid(void);
// int __cdecl explicit_bzero(_DWORD, _DWORD); weak
// int __cdecl pipe2(_DWORD, _DWORD); weak
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int nanosleep(const struct timespec *requested_time, struct timespec *remaining);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// char *bindtextdomain(const char *domainname, const char *dirname);
// int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl sched_getaffinity(_DWORD, _DWORD, _DWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// int feof_unlocked(FILE *stream);
// void abort(void);
// int __cdecl __xstat64(_DWORD, _DWORD, _DWORD); weak
// int strtol(const char *nptr, char **endptr, int base);
// char *ngettext(const char *msgid1, const char *msgid2, unsigned int n);
// int close(int fd);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// void *calloc(size_t nmemb, size_t size);
// int putchar_unlocked(int c);
// int _gmon_start__(void); weak
void sub_8049F73();
void sub_8049F90();
int sub_8049FA0();
int sub_804A010();
int sub_804A030();
void sub_804A08F();
void sub_804A0AA();
int sub_804A0BA();
void sub_804A19C();
void sub_804A1B7();
signed int sub_804A1C7();
signed int sub_804A251();
void sub_804A2C5();
void sub_804A2E0();
int sub_804A2F0();
void sub_804A3D2();
void sub_804A3ED();
int sub_804A3FD();
void sub_804A4DF();
void sub_804A4FA();
int sub_804A50A();
int nullsub_3(void); // weak
int sub_804A568();
void sub_804A608();
void sub_804A623();
int sub_804A633();
int nullsub_4(void); // weak
int sub_804A691();
void sub_804A731();
void sub_804A74C();
int sub_804A75C();
int sub_804A7E6();
void sub_804A85A();
void sub_804A875();
int sub_804A885();
// int __usercall sub_804A937@<eax>(void (__cdecl *a1)(int *)@<eax>);
void sub_804A995();
void sub_804A9B0();
int sub_804A9C0();
void sub_804AAA2();
void sub_804AABD();
int sub_804AACD();
void sub_804ABC4();
void sub_804ABDF();
int sub_804ABEF();
void sub_804ACD1();
void sub_804ACEC();
int sub_804ACFC();
// int __usercall sub_804ADAE@<eax>(void (__cdecl *a1)(int *)@<eax>);
void sub_804ADFA();
void sub_804AE15();
int sub_804AE25();
void sub_804AF35();
void sub_804AF50();
int sub_804AF60();
void sub_804B06D();
void sub_804B088();
// int __usercall sub_804B098@<eax>(double a1@<st0>);
int nullsub_5(void); // weak
int sub_804B10F();
void sub_804B1C1();
void sub_804B1DC();
int sub_804B1EC();
void sub_804B2CE();
void sub_804B2E9();
int sub_804B2F9();
int sub_804B383();
void sub_804B409();
void sub_804B424();
int sub_804B434();
int sub_804B4BE();
// int __usercall sub_804B4FF@<eax>(void (__cdecl *a1)(int *)@<eax>);
int __cdecl sub_804B519(int a1);
int __cdecl sub_804B53E(unsigned __int8 a1);
int __cdecl sub_804B550(unsigned __int8 a1);
// int __usercall sub_804B58F@<eax>(double a1@<st0>, unsigned __int64 a2);
int sub_804B5EA();
int sub_804B615();
// int __usercall sub_804B640@<eax>(double a1@<st0>, char *s1);
int __cdecl sub_804B7DF(int a1, const char *a2);
int __fastcall sub_804B8B7(int a1, int a2, int a3, int a4);
void __cdecl __noreturn sub_804B8F5(int errnum, char *format, int, int); // idb
// void __usercall __noreturn sub_804B93C(double a1@<st0>, int status);
int __cdecl sub_804BBF8(int a1);
int __cdecl sub_804BC2D(unsigned __int8 *a1);
int __cdecl sub_804BC5D(int a1, unsigned int a2);
bool __cdecl sub_804BC7B(int a1, int a2);
// int __usercall sub_804BCA0@<eax>(double a1@<st0>, __pid_t pid);
// int __usercall sub_804BDE2@<eax>(double st7_0@<st0>, int a1);
// int __usercall __noreturn sub_804BE56@<eax>(double st7_0@<st0>, int a1);
int sub_804BEC7(); // weak
// void __usercall __noreturn sub_804BEC9(double st7_0@<st0>, int a1);
// int __usercall sub_804BEEB@<eax>(int a1@<edx>, int a2@<ecx>, double a3@<st0>);
// int __usercall sub_804BF27@<eax>(double a1@<st0>);
// int __usercall sub_804BF40@<eax>(double a1@<st0>);
int __fastcall sub_804BF5F(int a1);
// int __usercall sub_804BFAC@<eax>(double a1@<st0>);
// void *__usercall sub_804BFE6@<eax>(double a1@<st0>, _DWORD *a2, char a3);
// FILE *__usercall sub_804C234@<eax>(double a1@<st0>, char *s1, char *modes);
// FILE *__usercall sub_804C370@<eax>(double a1@<st0>, char *s1, char *modes);
// void __usercall sub_804C3CA(double a1@<st0>, FILE *stream, int a3);
int __cdecl sub_804C48E(int fd, int fd2); // idb
__pid_t __cdecl sub_804C4BB(int pipedes[2], int a2);
// _BYTE *__usercall sub_804C667@<eax>(double a1@<st0>, FILE **a2, char a3);
// _BYTE *__usercall sub_804C7C8@<eax>(double a1@<st0>, FILE **a2);
// FILE *__usercall sub_804C7E3@<eax>(double a1@<st0>, int a2);
int __cdecl sub_804C9BC(int a1);
// void __usercall sub_804CA2D(double a1@<st0>, char *name);
int compar(const void *, const void *); // idb
void sub_804CBA8();
// unsigned int __usercall sub_804CDE0@<eax>(double st7_0@<st0>, int a1, char a2, char *a3);
// int __usercall sub_804D03F@<eax>(double a1@<st0>, int a2, int a3, char *nptr);
// int __usercall sub_804D2FD@<eax>(double a1@<st0>, int a2, int a3, char *nptr);
int sub_804D3A2();
int __cdecl sub_804D571(int a1, unsigned int a2, int a3, unsigned int a4, int a5);
int __cdecl sub_804D758(int, int, size_t size); // idb
int __cdecl sub_804D7DE(_DWORD *a1);
int __cdecl sub_804D7F9(int *a1, int *a2);
int __cdecl sub_804D85A(int a1);
int sub_804D871(); // weak
int sub_804D8E2(); // weak
int sub_804D940(); // weak
unsigned __int8 *__cdecl sub_804DB11(int a1, int a2);
// int __usercall sub_804DCDE@<eax>(double a1@<st0>, int a2, FILE *stream, int a4);
int __cdecl sub_804E109(char **a1);
int __cdecl sub_804E22A(_BYTE *a1);
// int __usercall sub_804E291@<eax>(double a1@<st0>, unsigned __int8 *a2, unsigned __int8 *a3);
// int __usercall sub_804E337@<eax>(double a1@<st0>, unsigned __int8 *a2, unsigned __int8 *a3);
int __cdecl sub_804E3C3(int a1, int a2);
int __cdecl sub_804E447(int a1, int a2);
// int __usercall sub_804E5AB@<eax>(double a1@<st0>, unsigned __int8 *a2, unsigned __int8 **a3);
// int __usercall __noreturn sub_804E708@<eax>(double a1@<st0>, int a2);
int sub_804E804(); // weak
// size_t __usercall sub_804E806@<eax>(double a1@<st0>, char *dest, char *src, size_t n);
// int __usercall sub_804E8EC@<eax>(double a1@<st0>, int a2, size_t a3, int a4, size_t a5);
// int __usercall sub_804EED4@<eax>(double a1@<st0>, char *a2, unsigned int a3);
int __cdecl sub_804EF39(int a1, int a2);
int __cdecl sub_804EFB3(_BYTE *a1);
// int __usercall sub_804EFE8@<eax>(int a1@<ecx>, long double a2@<st0>, int *a3, int a4);
// int __usercall sub_804F265@<eax>(int a1@<ecx>, long double a2@<st0>, int *a3);
unsigned int __cdecl sub_804F2BD(int a1);
// _BYTE *__usercall sub_804F4A9@<eax>(int a1@<edx>, int a2@<ecx>, int a3, _BYTE *a4);
int __cdecl sub_804F60A(int *a1);
int __cdecl sub_804F69E(char *src, char *format, int, int); // idb
int __cdecl sub_804F90B(int errnum, char *format, int); // idb
// int __usercall sub_804F9C9@<eax>(int a1@<ebp>, double a2@<st0>, int a3);
int __cdecl sub_804FA46(int errnum, char *format, int); // idb
// int __usercall __noreturn sub_8050104@<eax>(double a1@<st0>, int *a2, int *a3);
int sub_8050EF6(); // weak
// int __usercall sub_8050EFF@<eax>(double a1@<st0>, int *a2, int *a3);
// int __usercall sub_8051075@<eax>(int a1@<ecx>, long double a2@<st0>, int a3, FILE *stream, int a5);
// int __usercall sub_805119B@<eax>(long double a1@<st0>, char *a2, char a3);
int __cdecl sub_80513D4(int a1);
int __cdecl sub_80514DC(void *src, size_t n); // idb
// unsigned int __usercall sub_805163A@<eax>(double a1@<st0>, int a2, unsigned int a3, int *a4);
// void __usercall sub_8051733(long double a1@<st0>, int a2, int a3, int a4, FILE *stream, int a6, void *a7);
// int __usercall sub_80520CF@<eax>(long double a1@<st0>, int a2, int a3, int a4, FILE *stream, int a6);
// int __usercall sub_8052160@<eax>(double a1@<st0>, _DWORD *a2, unsigned int a3, int a4);
// int __usercall sub_8052270@<eax>(double a1@<st0>, int a2, unsigned int a3, _DWORD *a4, unsigned __int8 a5);
pthread_mutex_t *__cdecl sub_80524D9(unsigned int a1, int a2, int a3);
int __cdecl sub_8052608(unsigned int a1, pthread_mutex_t *a2, int a3, unsigned int a4, int a5, char a6);
_BOOL4 __cdecl sub_80527C9(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8052828(pthread_mutex_t *a1);
int __cdecl sub_805283E(pthread_mutex_t *a1);
int __cdecl sub_8052885(int a1, int a2);
int __cdecl sub_80528D3(int a1, int a2);
pthread_mutex_t *__cdecl sub_8052920(int a1);
// int __usercall sub_8052989@<eax>(int a1@<ecx>, long double a2@<st0>, int a3, FILE *stream, int a5);
// int __usercall sub_80529FC@<eax>(long double a1@<st0>, int a2, int a3, FILE *stream, int a5);
int __cdecl sub_8052E5E(int a1, int a2);
int __cdecl sub_8052F41(int a1, int a2);
int __cdecl sub_8052FA8(int); // weak
int __cdecl sub_8052FE3(int a1);
int __cdecl sub_8053043(int, FILE *stream, int); // idb
int sub_80530A5(); // weak
void *start_routine(void *); // idb
int __cdecl sub_8053114(int a1, unsigned int a2, int a3, _DWORD *a4, int a5, int a6, int a7);
int __cdecl sub_8053245(int, int, int); // weak
// int __usercall sub_8053378@<eax>(long double a1@<st0>, int a2, int a3, int a4, char *s1);
unsigned int __cdecl sub_80535D8(int a1, unsigned int a2);
// int __usercall sub_805368F@<eax>(double st7_0@<st0>, int a1);
// void __usercall sub_805370E(long double a1@<st0>, int a2, int a3, int a4, char *s1);
// int __usercall __noreturn sub_8053B07@<eax>(long double a1@<st0>, char **a2, unsigned int a3, char *a4, unsigned int a5);
int sub_8053F25(); // weak
int __cdecl sub_8053F2E(void *src); // idb
// unsigned int __usercall sub_8053F9E@<eax>(double a1@<st0>, int a2, char *msgid);
unsigned int __cdecl sub_8053FEC(int a1);
// int __usercall sub_8054110@<eax>(double a1@<st0>, char *nptr, int a3, char *msgid);
int __cdecl sub_8054216(int sig); // idb
char *__cdecl sub_8054241(char *a1, int a2, int a3);
void *__cdecl sub_8054374(void *s);
// void __usercall main(double a1@<st0>, int argc, char **argv);
int __cdecl sub_80552B8(int errnum, char *format, char *, int, int, int, int, int, int, int, char, char, int, int, int, int, int, int, size_t nmemb, void *ptr, char *s1, char *, int, int, int, int, int, int, int, FILE *stream, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, char src, int, int, int, int, int, char, char, char, int, int, int); // idb
// void __usercall __noreturn sub_8055B01(double a1@<st0>);
int __cdecl sub_8055B15(char *s, int a2);
// void __usercall sub_8055C26(double a1@<st0>, char *a2, char *a3, int a4);
// int __usercall sub_8055CA9@<eax>(double a1@<st0>, int a2, int a3, size_t n);
// int __usercall sub_8055DC0@<eax>(double a1@<st0>, int a2, char *s, int a4, int a5, size_t n, int a7);
// int __usercall sub_8055ED9@<eax>(double a1@<st0>);
_DWORD *__cdecl sub_8055FD2(_DWORD *a1);
_DWORD *__cdecl sub_805601E(_DWORD *a1, int a2);
_DWORD *__cdecl sub_805602B(int *a1, _DWORD *a2);
// _DWORD *__usercall sub_8056098@<eax>(double st7_0@<st0>, int *a1, _DWORD *a2);
// int __usercall sub_8056377@<eax>(int a1@<ecx>, double a2@<st0>, void *src, size_t a4, int a5);
// int *__usercall sub_805659A@<eax>(double st7_0@<st0>, int *a1, unsigned int a2, int *a3);
int __cdecl sub_8057276(int a1, int a2, int a3, int a4, int a5, int a6);
void __cdecl sub_80572C7(FILE *stream, int a2);
int __cdecl sub_805730F(int a1);
int __cdecl sub_80574B0(unsigned __int8 a1);
// signed int __usercall sub_8057501@<eax>(double a1@<st0>, int a2, unsigned int a3, int a4, unsigned int a5);
// int __usercall sub_8057767@<eax>(double a1@<st0>, char *s1, char *s2);
int __cdecl sub_80579D4(int category); // idb
int __cdecl sub_8057A4B(int a1);
int __cdecl sub_8057A56(int a1);
int __cdecl sub_8057A61(int a1);
// int __usercall sub_8057A71@<eax>(double a1@<st0>, int a2);
int __cdecl sub_8057B90(int a1, int a2);
bool __cdecl sub_8057EAF(unsigned int a1);
int __cdecl sub_8057F06(unsigned int a1);
unsigned int __cdecl sub_8057FBE(int a1, unsigned int a2);
bool __cdecl sub_8057FE9(int a1, int a2);
signed int __cdecl sub_8057FF7(int a1);
int __cdecl sub_80580B3(unsigned int a1, int a2);
int sub_8058130(); // weak
void *__cdecl sub_8058198(unsigned int a1, int a2, unsigned int (__cdecl *a3)(int a1, unsigned int a2), bool (__cdecl *a4)(int a1, int a2), int a5);
int __fastcall sub_80584CF(int a1, int a2, int a3);
int sub_8058519(); // weak
int __cdecl sub_805852D(int a1, _DWORD *a2);
// int __usercall sub_8058550@<eax>(double st7_0@<st0>, int a1, int a2, _DWORD *a3, char a4);
signed int __cdecl sub_80586CA(int a1, int a2, char a3);
int __cdecl sub_8058834(int a1, unsigned int a2);
int __cdecl sub_80588BB(size_t size); // idb
// signed int __usercall sub_8058AAD@<eax>(double st7_0@<st0>, unsigned int *a1, int a2, _DWORD *a3);
// int __usercall sub_8058D23@<eax>(double st7_0@<st0>, unsigned int *a1, int a2);
// int __usercall sub_8058D77@<eax>(double st7_0@<st0>, int a1, int a2);
int *__cdecl sub_8058F5C(int (*a1)(), unsigned int a2);
int sub_8058FD1();
void __cdecl sub_8058FDB(void *ptr);
int __cdecl sub_8058FFB(int a1, int a2);
// int __usercall sub_8059084@<eax>(int a1@<edx>, int a2@<ecx>, int a3);
unsigned int __cdecl sub_8059119(int a1, unsigned int a2, unsigned int a3, int (__cdecl *a4)(_DWORD, int));
int __cdecl sub_80591FC(int a1, unsigned int a2, int (__cdecl *a3)(_DWORD, int));
int __cdecl sub_805928C(int a1, int a2);
int __cdecl sub_8059366(unsigned int a1, int a2);
int __cdecl sub_80593DD(signed __int64 a1, int a2);
// int __usercall sub_8059490@<eax>(double a1@<st0>, char *a2, int a3, char a4);
int sub_805979E();
signed int __cdecl sub_8059812(int a1);
int __fastcall sub_80598CB(int a1, int a2, int a3);
int __cdecl sub_805991B(int a1);
int __cdecl sub_805992E(char **endptr, int base); // idb
unsigned int __cdecl sub_8059ACF(int a1);
long double sub_8059B69();
long double sub_8059C40();
// int __usercall sub_8059D1C@<eax>(double a1@<st0>, int pipedes[2], int a3);
int sub_8059F94();
int __cdecl sub_805A00B(int a1);
int __cdecl sub_805A053(int c); // idb
int __cdecl sub_805A09A(char *s2, size_t n); // idb
int __cdecl sub_805A255(int *a1, unsigned __int8 a2, char a3);
// void __usercall __noreturn sub_805A2FF(double a1@<st0>, int a2, int a3, int a4);
int sub_805A35E(); // weak
// _DWORD *__userpurge sub_805A372@<eax>(_DWORD *a1, int a2);
// char *__usercall sub_805A3F4@<eax>(double a1@<st0>, char *msgid);
// unsigned int __usercall sub_805A4C0@<eax>(double st7_0@<st0>, int a1, unsigned int a2, char *a3, size_t a4, char *a5, int a6, int a7, char *a8, char *a9);
// int __usercall sub_805B36A@<eax>(double a1@<st0>, char *a2, size_t a3, _DWORD *a4, int *a5);
// void *__usercall sub_805B543@<eax>(double st7_0@<st0>, signed int a1, char *a2, size_t a3, int a4);
// void *__usercall sub_805B79A@<eax>(double a1@<st0>, signed int a2, char *a3);
// void *__usercall sub_805B7C4@<eax>(double a1@<st0>, signed int a2, char *a3, size_t a4);
// void *__usercall sub_805B82A@<eax>(double a1@<st0>, signed int a2, int a3, char *a4);
// void *__usercall sub_805B868@<eax>(double a1@<st0>, signed int a2, int a3, char *a4, size_t a5);
// void *__usercall sub_805B8A5@<eax>(double a1@<st0>, int a2, char *a3);
// void *__usercall sub_805B8F0@<eax>(double st7_0@<st0>, char *a1, size_t a2, unsigned __int8 a3);
// void *__usercall sub_805B99A@<eax>(double st7_0@<st0>, char *a1, unsigned __int8 a2);
// void *__usercall sub_805B9C3@<eax>(double st7_0@<st0>, char *a1);
// void *__usercall sub_805BA00@<eax>(double a1@<st0>, signed int a2, int a3, char *a4);
// void __usercall __noreturn sub_805BAA1(double a1@<st0>, int a2, int a3, int a4);
// void __usercall __noreturn sub_805BAD1(double a1@<st0>, int a2, int a3, int a4);
// void *__usercall sub_805BBCB@<eax>(double st7_0@<st0>, signed int a1, char *a2, size_t a3);
// void *__usercall sub_805BC16@<eax>(double st7_0@<st0>, signed int a1, char *a2);
// void *__usercall sub_805BC38@<eax>(double st7_0@<st0>, char *a1);
// int __usercall sub_805BC53@<eax>(double a1@<st0>, int ecx0@<ecx>, char *a2);
void __cdecl __noreturn sub_805BCD3(int errnum, char *format, int); // idb
int *__cdecl sub_805BD06(int a1, int a2);
unsigned int __cdecl sub_805BD3B(int a1, int a2, size_t nbytes);
// char *__usercall sub_805BF48@<eax>(double a1@<st0>, int a2, size_t n);
size_t __cdecl sub_805C06F(int a1, void *ptr, size_t n);
int __cdecl sub_805C10C(int, void *dest, size_t n); // idb
size_t __cdecl sub_805C21B(int a1, void *ptr, size_t n);
int __cdecl sub_805C27C(void *ptr); // idb
int __cdecl sub_805C2C2(int a1);
int __cdecl sub_805C2D9(int a1, __int16 a2);
unsigned int *__cdecl sub_805C30A(unsigned int *a1, int *a2);
_DWORD *__cdecl sub_805C7AF(_DWORD *a1);
signed int __cdecl sub_805CBBE(_DWORD *a1);
_DWORD *__cdecl sub_805CD77(_DWORD *a1);
bool __cdecl sub_805CF0C(FILE *stream, int a2);
// int __usercall sub_805D1DE@<eax>(double a1@<st0>, int a2, int a3);
int __cdecl sub_805D207(_BYTE *a1, _BYTE *a2, char a3);
// int __usercall sub_805D37A@<eax>(double a1@<st0>, int ecx0@<ecx>, unsigned __int8 *a2, unsigned __int8 *a3, int a4, int a5);
// int __usercall sub_805D8A7@<eax>(double a1@<st0>, int ecx0@<ecx>, unsigned __int8 *a2, unsigned __int8 *a3, int a4, int a5);
// int __usercall sub_805D8CF@<eax>(double a1@<st0>, int fd);
// int __usercall sub_805D93D@<eax>(double a1@<st0>, FILE *stream, int a3, int a4, int a5, int a6, int a7);
// int __usercall sub_805DEF0@<eax>(double a1@<st0>, FILE *stream, int a3, int a4, int a5, int a6);
// int __usercall sub_805DF56@<eax>(double a1@<st0>, FILE *stream, int a3, int a4, int a5, ...);
int __cdecl sub_805DFF6(unsigned int a1, unsigned int a2);
int __cdecl sub_805E059(int a1, unsigned int *a2, unsigned int a3);
// int __usercall sub_805E0F2@<eax>(int a1@<ecx>, int a2@<ebp>);
int __cdecl sub_805E11B(size_t size); // idb
int __cdecl sub_805E14D(size_t size); // idb
int __cdecl sub_805E160(size_t size); // idb
int sub_805E1A9(); // weak
void *__cdecl sub_805E1AE(void *ptr, size_t size);
void __cdecl __noreturn sub_805E262(size_t nmemb, size_t size); // idb
int sub_805E2B3(); // weak
void *__cdecl sub_805E2B8(void *src, size_t n);
void __noreturn sub_805E306();
// void __usercall sub_805E33F(double a1@<st0>, int errnum, int a3, int a4, int a5, int a6);
// int __usercall sub_805E470@<eax>(double a1@<st0>, void *s1, size_t n, void *s2, int a5);
signed int __cdecl sub_805E4DB(double a1);
signed int __cdecl sub_805E566(unsigned int *a1, unsigned int a2);
int __cdecl sub_805E5AA(unsigned int *a1, unsigned int a2, int a3);
int __cdecl sub_805E5E0(char *nptr, int, int base, int, char *s); // idb
// void __usercall sub_805EAB7(int edx0@<edx>, int ecx0@<ecx>, double st7_0@<st0>, int a1, int a2, int a3, int a4, int a5, int status);
// void __usercall __noreturn sub_805EB97(int ecx0@<ecx>, int edx0@<edx>, double st7_0@<st0>, int a1, int a2, char a3, int a4, int a5);
signed int __cdecl sub_805EBDA(int a1, signed int a2);
int __cdecl sub_805EC66(int a1, signed int a2, int a3);
// int __usercall sub_805EC9C@<eax>(double a1@<st0>, char *nptr, int a3, int base, int a5, char *s);
int __cdecl sub_805F1E8(FILE *stream); // idb
int __cdecl sub_805F240(int, int, int); // weak
// int __usercall sub_805F313@<eax>(double a1@<st0>, int fd, int cmd, char a4);
int __cdecl sub_805F4AF(FILE *stream); // idb
int __cdecl sub_805F4E8(FILE *fp); // idb
int __cdecl sub_805F528(FILE *stream, int, int, int); // idb
size_t __cdecl sub_805F5FA(wchar_t *pwc, char *s, size_t n, mbstate_t *p);
int __cdecl sub_805F69E(int a1, int a2);
int __cdecl sub_805F6DC(int a1, int a2);
signed int __cdecl sub_805F71A(int a1, signed int a2, signed int a3);
signed int __cdecl sub_805F7F9(int a1, signed int a2, signed int a3, int a4, int a5);
int __cdecl sub_805F882(int a1, int a2);
int __cdecl sub_805FA65(int a1, unsigned int a2);
int __cdecl sub_805FC90(int a1, char a2);
signed int __cdecl sub_805FD85(signed int a1);
_BOOL4 __cdecl sub_805FDB5(signed int a1);
_BOOL4 __cdecl sub_805FE67(int a1);
_BOOL4 __cdecl sub_805FF3F(signed int a1);
int __fastcall sub_805FFB8(int ecx0, int a2, int a1);
int sub_805FFF1(); // weak
// int __usercall sub_8060034@<eax>(int edx0@<edx>, int ecx0@<ecx>, unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_80600C7(FILE *fp); // idb
// _DWORD *__userpurge sub_8060148@<eax>(_DWORD *a1, double a2);
// int __usercall sub_8060291@<eax>(int a1@<edx>, int a2@<ecx>, double a3@<st0>, int fd, int a5);
// int __usercall sub_8060306@<eax>(double a1@<st0>, int fd, int a3);
// FILE *__usercall sub_806033D@<eax>(double a1@<st0>, int a2, char *modes);
// void *__usercall sub_806041D@<eax>(double a1@<st0>);
// const char *__usercall sub_8060960@<eax>(double a1@<st0>);
// int __usercall sub_8060A65@<eax>(double a1@<st0>, char *s1, int a3, char *s2);
// int __usercall sub_8060B6D@<eax>(double a1@<st0>, void *s1, size_t n, void *s2, int a5);
// int __usercall sub_8060C28@<eax>(double a1@<st0>, void *s1, size_t n, void *s2, int a5);
// _DWORD *__userpurge sub_8060C87@<eax>(_DWORD *a1, int a2, int a3);
// int __usercall sub_8060D5E@<eax>(double a1@<st0>, int fd);
signed __int64 __cdecl sub_8060D83(unsigned __int64 a1, unsigned int a2, unsigned int a3);
unsigned __int64 __cdecl sub_8060EA3(unsigned __int64 a1, unsigned int a2, unsigned int a3);
int __cdecl sub_80610AD(int a1);
int __cdecl sub_80610DC(int a1, int a2);
int __cdecl sub_806110B(int a1, int a2);
int __fastcall sub_8061194(_DWORD, _DWORD); // weak
int __fastcall sub_8061268(_DWORD); // weak
int sub_8061308(void); // weak
// int __usercall sub_806141F@<eax>(double@<st0>); weak
int sub_8061521(void); // weak
int sub_8061591(void); // weak
int sub_8061601(void); // weak
int __fastcall sub_8061671(_DWORD, _DWORD); // weak
int sub_80616F8(void); // weak
int sub_806176A(void); // weak
// int __usercall sub_80617DA@<eax>(double@<st0>); weak
int __fastcall sub_806184C(_DWORD, _DWORD); // weak
int __fastcall sub_80618C4(_DWORD); // weak
int __fastcall sub_8061930(_DWORD); // weak
int (**sub_8061940())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_804A8B1; // weak
_UNKNOWN locret_804AF6F; // weak
_UNKNOWN locret_804B0A7; // weak
_UNKNOWN loc_804B53C; // weak
_UNKNOWN locret_804B5E8; // weak
_UNKNOWN loc_804B6FF; // weak
_UNKNOWN loc_804B708; // weak
_UNKNOWN loc_804B88C; // weak
_UNKNOWN loc_804B8F8; // weak
_UNKNOWN loc_804BD4B; // weak
_UNKNOWN loc_804BD5A; // weak
_UNKNOWN loc_804BEC2; // weak
_UNKNOWN loc_804BF15; // weak
_UNKNOWN locret_804BF25; // weak
_UNKNOWN loc_804BF9A; // weak
_UNKNOWN loc_804C0D7; // weak
_UNKNOWN loc_804C134; // weak
_UNKNOWN loc_804C19E; // weak
_UNKNOWN loc_804C1BC; // weak
_UNKNOWN loc_804C201; // weak
_UNKNOWN loc_804C219; // weak
_UNKNOWN loc_804C3AA; // weak
_UNKNOWN loc_804C3C5; // weak
_UNKNOWN loc_804C3FD; // weak
_UNKNOWN loc_804C41D; // weak
_UNKNOWN loc_804C580; // weak
_UNKNOWN loc_804C58B; // weak
_UNKNOWN locret_804C665; // weak
_UNKNOWN loc_804C6C3; // weak
_UNKNOWN loc_804C780; // weak
_UNKNOWN loc_804C94B; // weak
_UNKNOWN loc_804C9EA; // weak
_UNKNOWN loc_804CA0C; // weak
_UNKNOWN loc_804CB0C; // weak
_UNKNOWN loc_804CB53; // weak
_UNKNOWN loc_804CC91; // weak
_UNKNOWN loc_804CD5C; // weak
_UNKNOWN loc_804CD8D; // weak
_UNKNOWN loc_804CD91; // weak
_UNKNOWN loc_804CDDA; // weak
_UNKNOWN loc_804CF77; // weak
_UNKNOWN loc_804D00A; // weak
_UNKNOWN loc_804D118; // weak
_UNKNOWN loc_804D12D; // weak
_UNKNOWN loc_804D22C; // weak
_UNKNOWN loc_804D2A3; // weak
_UNKNOWN loc_804D2C5; // weak
_UNKNOWN loc_804D2CC; // weak
_UNKNOWN loc_804D2F5; // weak
_UNKNOWN loc_804D651; // weak
_UNKNOWN loc_804D67A; // weak
_UNKNOWN loc_804D722; // weak
_UNKNOWN loc_804D72F; // weak
_UNKNOWN loc_804DBB2; // weak
_UNKNOWN loc_804DC56; // weak
_UNKNOWN loc_804DC75; // weak
_UNKNOWN loc_804DC82; // weak
_UNKNOWN loc_804DCC6; // weak
_UNKNOWN loc_804DCD9; // weak
_UNKNOWN loc_804DD8B; // weak
_UNKNOWN loc_804DEAC; // weak
_UNKNOWN loc_804DEF1; // weak
_UNKNOWN loc_804DF8F; // weak
_UNKNOWN loc_804DFA9; // weak
_UNKNOWN loc_804E04F; // weak
_UNKNOWN loc_804E102; // weak
_UNKNOWN loc_804E166; // weak
_UNKNOWN loc_804E1A0; // weak
_UNKNOWN loc_804E1B1; // weak
_UNKNOWN loc_804E37D; // weak
_UNKNOWN loc_804E4A8; // weak
_UNKNOWN loc_804E520; // weak
_UNKNOWN loc_804E596; // weak
_UNKNOWN loc_804E59D; // weak
_UNKNOWN loc_804E5A4; // weak
_UNKNOWN loc_804E5C2; // weak
_UNKNOWN loc_804E5FE; // weak
_UNKNOWN loc_804E702; // weak
_UNKNOWN loc_804E754; // weak
_UNKNOWN loc_804E76F; // weak
_UNKNOWN loc_804E7FF; // weak
_UNKNOWN loc_804E8E3; // weak
_UNKNOWN loc_804EAB9; // weak
_UNKNOWN loc_804EAC9; // weak
_UNKNOWN loc_804ED8B; // weak
_UNKNOWN loc_804EF2C; // weak
_UNKNOWN loc_804EF41; // weak
_UNKNOWN loc_804EF73; // weak
_UNKNOWN loc_804F084; // weak
_UNKNOWN loc_804F0A8; // weak
_UNKNOWN loc_804F0BB; // weak
_UNKNOWN loc_804F173; // weak
_UNKNOWN loc_804F182; // weak
_UNKNOWN loc_804F1AD; // weak
_UNKNOWN loc_804F1B4; // weak
_UNKNOWN loc_804F4D0; // weak
_UNKNOWN loc_804F4DB; // weak
_UNKNOWN loc_804F50D; // weak
_UNKNOWN loc_804F519; // weak
_UNKNOWN loc_804F5F6; // weak
_UNKNOWN loc_804F602; // weak
_UNKNOWN loc_804FA0F; // weak
_UNKNOWN loc_804FA4B; // weak
_UNKNOWN loc_804FE9C; // weak
_UNKNOWN loc_80502BF; // weak
_UNKNOWN loc_8050313; // weak
_UNKNOWN loc_8050348; // weak
_UNKNOWN loc_8050382; // weak
_UNKNOWN loc_80503C3; // weak
_UNKNOWN loc_80503D4; // weak
_UNKNOWN loc_805046E; // weak
_UNKNOWN loc_80504CE; // weak
_UNKNOWN loc_80505D5; // weak
_UNKNOWN loc_80505F8; // weak
_UNKNOWN loc_80507BA; // weak
_UNKNOWN loc_80507C3; // weak
_UNKNOWN loc_805083D; // weak
_UNKNOWN loc_805085F; // weak
_UNKNOWN loc_8050989; // weak
_UNKNOWN loc_80509A0; // weak
_UNKNOWN loc_80509F8; // weak
_UNKNOWN loc_8050B33; // weak
_UNKNOWN loc_8050CC0; // weak
_UNKNOWN loc_8050D17; // weak
_UNKNOWN loc_8050D55; // weak
_UNKNOWN loc_8050DB3; // weak
_UNKNOWN loc_8050DF4; // weak
_UNKNOWN loc_8050EAE; // weak
_UNKNOWN loc_8050EF1; // weak
_UNKNOWN loc_805106F; // weak
_UNKNOWN loc_80510E6; // weak
_UNKNOWN loc_80510EC; // weak
_UNKNOWN loc_80513BA; // weak
_UNKNOWN loc_8051444; // weak
_UNKNOWN loc_80515A1; // weak
_UNKNOWN loc_80515DA; // weak
_UNKNOWN loc_8051701; // weak
_UNKNOWN loc_8051ADB; // weak
_UNKNOWN loc_8051B11; // weak
_UNKNOWN loc_8051B4B; // weak
_UNKNOWN loc_8051B6B; // weak
_UNKNOWN loc_8051B79; // weak
_UNKNOWN loc_8051C1E; // weak
_UNKNOWN loc_8051CBD; // weak
_UNKNOWN loc_8051D34; // weak
_UNKNOWN loc_80521F0; // weak
_UNKNOWN loc_8052220; // weak
_UNKNOWN loc_8052267; // weak
_UNKNOWN loc_8052269; // weak
_UNKNOWN loc_8052388; // weak
_UNKNOWN loc_8052465; // weak
_UNKNOWN loc_8052485; // weak
_UNKNOWN loc_80524A4; // weak
_UNKNOWN loc_80524B2; // weak
_UNKNOWN loc_8052633; // weak
_UNKNOWN loc_805263B; // weak
_UNKNOWN loc_8052AE5; // weak
_UNKNOWN loc_8052B8B; // weak
_UNKNOWN loc_8052C15; // weak
_UNKNOWN loc_8052C22; // weak
_UNKNOWN loc_8052C46; // weak
_UNKNOWN loc_8052CE4; // weak
_UNKNOWN loc_8052D1A; // weak
_UNKNOWN loc_8052D63; // weak
_UNKNOWN loc_8052DC0; // weak
_UNKNOWN loc_8052E15; // weak
_UNKNOWN loc_8052EF7; // weak
_UNKNOWN loc_8052F08; // weak
_UNKNOWN loc_8052F2D; // weak
_UNKNOWN locret_8052F3F; // weak
_UNKNOWN locret_8052FE1; // weak
_UNKNOWN locret_8053376; // weak
_UNKNOWN loc_805346D; // weak
_UNKNOWN loc_8053486; // weak
_UNKNOWN loc_80534FC; // weak
_UNKNOWN loc_8053503; // weak
_UNKNOWN loc_8053629; // weak
_UNKNOWN loc_805362B; // weak
_UNKNOWN loc_80536B4; // weak
_UNKNOWN locret_805370C; // weak
_UNKNOWN loc_8053E53; // weak
_UNKNOWN loc_8053EC2; // weak
_UNKNOWN loc_8053F20; // weak
_UNKNOWN loc_8053F6F; // weak
_UNKNOWN loc_805403B; // weak
_UNKNOWN loc_80540FD; // weak
_UNKNOWN loc_8054197; // weak
_UNKNOWN loc_8054199; // weak
_UNKNOWN loc_805420C; // weak
_UNKNOWN loc_80542AB; // weak
_UNKNOWN loc_80542B1; // weak
_UNKNOWN loc_805435D; // weak
_UNKNOWN loc_8054361; // weak
_UNKNOWN loc_8054432; // weak
_UNKNOWN loc_8054439; // weak
_UNKNOWN loc_80546FF; // weak
_UNKNOWN loc_805471F; // weak
_UNKNOWN loc_80547CE; // weak
_UNKNOWN loc_80547F1; // weak
_UNKNOWN loc_8054811; // weak
_UNKNOWN loc_8054828; // weak
_UNKNOWN loc_80549A5; // weak
_UNKNOWN loc_80549CB; // weak
_UNKNOWN loc_8054A92; // weak
_UNKNOWN loc_8054AB6; // weak
_UNKNOWN loc_8054B92; // weak
_UNKNOWN loc_8054BB6; // weak
_UNKNOWN loc_8054E92; // weak
_UNKNOWN loc_8054EA7; // weak
_UNKNOWN loc_8054FCE; // weak
_UNKNOWN loc_8055000; // weak
_UNKNOWN loc_8055024; // weak
_UNKNOWN loc_8055093; // weak
_UNKNOWN loc_80550B7; // weak
_UNKNOWN loc_80552B3; // weak
_UNKNOWN loc_8055540; // weak
_UNKNOWN loc_8055BA6; // weak
_UNKNOWN loc_8055BAB; // weak
_UNKNOWN loc_8055F0A; // weak
_UNKNOWN loc_8055FAE; // weak
_UNKNOWN loc_8056485; // weak
_UNKNOWN loc_80564CB; // weak
_UNKNOWN loc_8056515; // weak
_UNKNOWN loc_8056594; // weak
_UNKNOWN loc_8057245; // weak
_UNKNOWN loc_805748D; // weak
_UNKNOWN loc_8057560; // weak
_UNKNOWN loc_8057629; // weak
_UNKNOWN loc_805764F; // weak
_UNKNOWN loc_80576B3; // weak
_UNKNOWN loc_80576E6; // weak
_UNKNOWN locret_8057765; // weak
_UNKNOWN loc_805786B; // weak
_UNKNOWN loc_8057875; // weak
_UNKNOWN loc_8057898; // weak
_UNKNOWN loc_80578AC; // weak
_UNKNOWN loc_805790F; // weak
_UNKNOWN loc_8057929; // weak
_UNKNOWN loc_805792C; // weak
_UNKNOWN loc_8057A2A; // weak
_UNKNOWN loc_8057A41; // weak
_UNKNOWN loc_8057AA8; // weak
_UNKNOWN loc_8057AE1; // weak
_UNKNOWN loc_8057B0C; // weak
_UNKNOWN loc_8057B33; // weak
_UNKNOWN loc_8057B68; // weak
_UNKNOWN loc_8057B6F; // weak
_UNKNOWN loc_8057F2B; // weak
_UNKNOWN loc_8057F46; // weak
_UNKNOWN loc_8058152; // weak
_UNKNOWN locret_8058196; // weak
_UNKNOWN loc_80581F6; // weak
_UNKNOWN loc_80581FD; // weak
_UNKNOWN loc_80582D5; // weak
_UNKNOWN loc_8058528; // weak
_UNKNOWN loc_80585D8; // weak
_UNKNOWN loc_8058618; // weak
_UNKNOWN loc_8058651; // weak
_UNKNOWN loc_805866F; // weak
_UNKNOWN loc_8058886; // weak
_UNKNOWN locret_8058AAB; // weak
_UNKNOWN locret_8058D21; // weak
_UNKNOWN locret_8058D75; // weak
_UNKNOWN loc_8058E8C; // weak
_UNKNOWN loc_8058EC6; // weak
_UNKNOWN loc_80590AF; // weak
_UNKNOWN loc_80590B6; // weak
_UNKNOWN loc_805937B; // weak
_UNKNOWN loc_80593D8; // weak
_UNKNOWN loc_805950D; // weak
_UNKNOWN loc_8059527; // weak
_UNKNOWN loc_8059542; // weak
_UNKNOWN loc_80595BC; // weak
_UNKNOWN loc_80595CB; // weak
_UNKNOWN loc_805961C; // weak
_UNKNOWN loc_8059621; // weak
_UNKNOWN loc_8059687; // weak
_UNKNOWN loc_80596B5; // weak
_UNKNOWN loc_8059726; // weak
_UNKNOWN loc_8059737; // weak
_UNKNOWN loc_8059775; // weak
_UNKNOWN loc_8059786; // weak
_UNKNOWN locret_8059810; // weak
_UNKNOWN loc_8059837; // weak
_UNKNOWN loc_805987B; // weak
_UNKNOWN loc_80598C4; // weak
_UNKNOWN locret_80598C9; // weak
_UNKNOWN loc_8059905; // weak
_UNKNOWN loc_8059932; // weak
_UNKNOWN locret_8059ACD; // weak
_UNKNOWN loc_8059B3C; // weak
_UNKNOWN loc_8059B48; // weak
_UNKNOWN loc_8059C2B; // weak
_UNKNOWN loc_8059D07; // weak
_UNKNOWN loc_8059F42; // weak
_UNKNOWN loc_8059F49; // weak
_UNKNOWN loc_8059FD9; // weak
_UNKNOWN loc_805A006; // weak
_UNKNOWN loc_805A324; // weak
_UNKNOWN loc_805A32B; // weak
_UNKNOWN loc_805A359; // weak
_UNKNOWN loc_805A47F; // weak
_UNKNOWN loc_805A4AA; // weak
_UNKNOWN loc_805A4AC; // weak
_UNKNOWN loc_805A5C2; // weak
_UNKNOWN loc_805A5EE; // weak
_UNKNOWN loc_805A601; // weak
_UNKNOWN loc_805A644; // weak
_UNKNOWN loc_805A700; // weak
_UNKNOWN loc_805A760; // weak
_UNKNOWN loc_805A85C; // weak
_UNKNOWN loc_805A88A; // weak
_UNKNOWN loc_805AA4D; // weak
_UNKNOWN loc_805AA58; // weak
_UNKNOWN loc_805AA69; // weak
_UNKNOWN loc_805AAFC; // weak
_UNKNOWN loc_805AB01; // weak
_UNKNOWN loc_805AC3C; // weak
_UNKNOWN loc_805AC41; // weak
_UNKNOWN loc_805ADCE; // weak
_UNKNOWN loc_805AEB2; // weak
_UNKNOWN loc_805AF92; // weak
_UNKNOWN loc_805AFBE; // weak
_UNKNOWN loc_805B078; // weak
_UNKNOWN loc_805B0AA; // weak
_UNKNOWN loc_805B1BA; // weak
_UNKNOWN loc_805B1D9; // weak
_UNKNOWN loc_805B1EB; // weak
_UNKNOWN loc_805B240; // weak
_UNKNOWN loc_805B47E; // weak
_UNKNOWN loc_805B489; // weak
_UNKNOWN loc_805B5BD; // weak
_UNKNOWN loc_805B5D9; // weak
_UNKNOWN loc_805B5DC; // weak
_UNKNOWN loc_805BC88; // weak
_UNKNOWN loc_805BCE1; // weak
_UNKNOWN loc_805BD01; // weak
_UNKNOWN loc_805BFC1; // weak
_UNKNOWN loc_805BFCB; // weak
_UNKNOWN locret_805C051; // weak
_UNKNOWN loc_805C076; // weak
_UNKNOWN loc_805C243; // weak
_UNKNOWN loc_805C25E; // weak
_UNKNOWN loc_805D0A0; // weak
_UNKNOWN loc_805D0AD; // weak
_UNKNOWN loc_805D2F9; // weak
_UNKNOWN loc_805D333; // weak
_UNKNOWN loc_805D35A; // weak
_UNKNOWN loc_805D3E4; // weak
_UNKNOWN loc_805D410; // weak
_UNKNOWN loc_805D428; // weak
_UNKNOWN loc_805D45D; // weak
_UNKNOWN loc_805D4C4; // weak
_UNKNOWN loc_805D4F3; // weak
_UNKNOWN loc_805D53F; // weak
_UNKNOWN loc_805D56C; // weak
_UNKNOWN loc_805D643; // weak
_UNKNOWN loc_805D693; // weak
_UNKNOWN loc_805D6BF; // weak
_UNKNOWN loc_805D6F9; // weak
_UNKNOWN locret_805D8A5; // weak
_UNKNOWN loc_805D938; // weak
_UNKNOWN loc_805D9AC; // weak
_UNKNOWN loc_805DE7B; // weak
_UNKNOWN loc_805E094; // weak
_UNKNOWN loc_805E0C9; // weak
_UNKNOWN loc_805E12D; // weak
_UNKNOWN loc_805E1D3; // weak
_UNKNOWN loc_805E1EB; // weak
_UNKNOWN loc_805E2AE; // weak
_UNKNOWN loc_805E55B; // weak
_UNKNOWN loc_805E562; // weak
_UNKNOWN loc_805E612; // weak
_UNKNOWN loc_805E61A; // weak
_UNKNOWN loc_805E65B; // weak
_UNKNOWN loc_805E775; // weak
_UNKNOWN loc_805E77F; // weak
_UNKNOWN loc_805E786; // weak
_UNKNOWN loc_805E7A5; // weak
_UNKNOWN loc_805E7B5; // weak
_UNKNOWN locret_805EAB5; // weak
_UNKNOWN loc_805EB16; // weak
_UNKNOWN loc_805EB5E; // weak
_UNKNOWN loc_805ECF6; // weak
_UNKNOWN loc_805ED67; // weak
_UNKNOWN loc_805ED83; // weak
_UNKNOWN loc_805EDF9; // weak
_UNKNOWN loc_805EE1E; // weak
_UNKNOWN loc_805EE62; // weak
_UNKNOWN loc_805EF47; // weak
_UNKNOWN loc_805EF7D; // weak
_UNKNOWN loc_805EF96; // weak
_UNKNOWN loc_805EFA1; // weak
_UNKNOWN loc_805F1B0; // weak
_UNKNOWN locret_805F1E6; // weak
_UNKNOWN locret_805F311; // weak
_UNKNOWN loc_805F3EF; // weak
_UNKNOWN loc_805F4AA; // weak
_UNKNOWN loc_805F654; // weak
_UNKNOWN loc_805F680; // weak
_UNKNOWN loc_805F699; // weak
_UNKNOWN loc_805F9DA; // weak
_UNKNOWN loc_805F9F8; // weak
_UNKNOWN loc_805FD7B; // weak
_UNKNOWN loc_805FFF4; // weak
_UNKNOWN loc_806008E; // weak
_UNKNOWN loc_80600A5; // weak
_UNKNOWN loc_80600B4; // weak
_UNKNOWN loc_8060301; // weak
_UNKNOWN loc_8060413; // weak
_UNKNOWN loc_80604FC; // weak
_UNKNOWN loc_8060503; // weak
_UNKNOWN loc_8060557; // weak
_UNKNOWN loc_80605C8; // weak
_UNKNOWN loc_8060700; // weak
_UNKNOWN loc_806073F; // weak
_UNKNOWN loc_8060761; // weak
_UNKNOWN loc_8060766; // weak
_UNKNOWN loc_806076B; // weak
_UNKNOWN loc_806090A; // weak
_UNKNOWN loc_8060927; // weak
_UNKNOWN loc_8060935; // weak
_UNKNOWN loc_80609BE; // weak
_UNKNOWN loc_80609E1; // weak
_UNKNOWN loc_8060A07; // weak
_UNKNOWN loc_8060A1F; // weak
_UNKNOWN loc_8060B3F; // weak
_UNKNOWN loc_8060B46; // weak
_UNKNOWN loc_8060B68; // weak
_UNKNOWN loc_8060F10; // weak
_UNKNOWN loc_8060F69; // weak
char s = '\0'; // idb
struct option longopts = { "ignore-leading-blanks", 0, NULL, 98 }; // idb
char *off_8062F34[3] = { "quiet", "silent", "diagnose-first" }; // weak
char aCccgeneralNume[19] = "CCcgeneral-numeric"; // weak
void *off_8062F7C = (void *)0x8062F47; // weak
char byte_8062F98[6] = { 'g', 'h', 'M', 'n', 'R', 'V' }; // idb
char byte_8063208[256] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x06',
  '\0',
  '\x03',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0',
  '\x04',
  '\0',
  '\0',
  '\0',
  '\0',
  '\b',
  '\a',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
int sig[11] = { 14, 1, 2, 13, 3, 15, 29, 27, 26, 24, 25 }; // idb
_UNKNOWN unk_8063E88; // weak
_UNKNOWN unk_8063ED8; // weak
_UNKNOWN unk_80640D6; // weak
_UNKNOWN unk_80640DA; // weak
_UNKNOWN unk_80640EA; // weak
_UNKNOWN unk_80640ED; // weak
_UNKNOWN unk_8064DD7; // weak
int dword_8064F08 = 3452; // weak
_UNKNOWN unk_8066378; // weak
_UNKNOWN unk_806637B; // weak
int dword_8066EF0 = 131; // weak
_UNKNOWN unk_80673AC; // weak
_UNKNOWN unk_80673AF; // weak
int dword_8067EE0 = 28; // weak
_UNKNOWN unk_80683E4; // weak
_UNKNOWN unk_80683E7; // weak
int (*off_806AEB8[2])() = { &sub_804A030, &sub_804A010 }; // weak
int (*off_806AEBC)() = &sub_804A010; // weak
int (*dword_806B008)(void) = NULL; // weak
int dword_806B20C = 0; // weak
int dword_806B220 = 0; // weak
int dword_806B234 = 0; // weak
int dword_806B248 = 0; // weak
int dword_806B25C = 0; // weak
int dword_806B270 = 0; // weak
int dword_806B284 = 0; // weak
int dword_806B298 = 0; // weak
int dword_806B2AC = 0; // weak
int dword_806B2C0 = 0; // weak
int (__cdecl *dword_806B2D0)(_DWORD) = NULL; // weak
int dword_806B2E4 = 0; // weak
int dword_806B304 = 0; // weak
int dword_806B318 = 0; // weak
int (__fastcall *dword_806B328)(_DWORD, _DWORD) = NULL; // weak
int dword_806B33C = 0; // weak
int dword_806B354 = 0; // weak
char byte_806B370 = '\n'; // weak
char *off_806B390 = "APR"; // weak
int dword_806B394[] = { 4 }; // weak
size_t dword_806B3F0 = 262144u; // idb
int dword_806B3F4 = 128; // weak
int dword_806B3F8 = 16; // idb
int *off_806B3FC = &dword_806C16A; // weak
int off_806B410 = 134626816; // idb
int off_806B414 = 134568705; // idb
int status = 1; // idb
int dword_806B430 = 1; // weak
int dword_806B434 = 256; // weak
void *off_806B438 = &unk_806C28A; // weak
int *off_806B43C = &dword_806B434; // weak
_UNKNOWN unk_806B450; // weak
_UNKNOWN unk_806B470; // weak
_UNKNOWN unk_806B473; // weak
_UNKNOWN unk_806B474; // weak
_UNKNOWN unk_806B477; // weak
_UNKNOWN unk_806B478; // weak
_UNKNOWN unk_806B47B; // weak
_UNKNOWN unk_806B484; // weak
_UNKNOWN unk_806B487; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int optind; // weak
FILE *stdin; // idb
FILE *stdout; // idb
int (*obstack_alloc_failed_handler)(void); // weak
char *optarg; // idb
char byte_806B50C; // weak
char byte_806B5E6; // weak
_UNKNOWN unk_806B6C4; // weak
char byte_806B807; // weak
_UNKNOWN unk_806BBE0; // weak
char byte_806BC49; // weak
char byte_806BC96; // weak
int dword_806BCAA; // weak
int dword_806BCAE; // weak
char byte_806BCB2; // weak
char byte_806BCB3; // weak
int dword_806BCB6; // weak
int dword_806BCBA; // weak
int dword_806BCBE; // weak
int dword_806BCC2; // weak
char byte_806BCCA[256]; // idb
_UNKNOWN unk_806BDCA; // weak
_UNKNOWN unk_806BECA; // weak
char byte_806BFCA[256]; // idb
size_t size; // idb
int dword_806C0CE; // weak
int dword_806C0D2; // weak
int dword_806C0D6; // weak
char byte_806C0DA; // weak
char byte_806C0DB; // weak
char byte_806C0DC; // weak
char byte_806C0DD; // weak
int dword_806C0DE; // weak
char *s1; // idb
char byte_806C0E6; // weak
__sigset_t set; // idb
int dword_806C16A; // weak
int dword_806C16E; // weak
int dword_806C172; // weak
_UNKNOWN unk_806C18A; // weak
int dword_806C226; // weak
int dword_806C22A; // weak
int dword_806C22E; // weak
char byte_806C232; // weak
int dword_806C236; // weak
int dword_806C23A; // weak
int dword_806C24A; // weak
int dword_806C24E; // weak
int dword_806C252; // weak
int dword_806C256; // weak
int dword_806C25A; // weak
int dword_806C25E; // weak
int dword_806C262; // weak
int dword_806C266; // weak
int dword_806C26A; // weak
int dword_806C26E; // weak
int dword_806C272; // weak
int dword_806C276; // weak
_UNKNOWN unk_806C28A; // weak
int dword_806C38A; // weak
int dword_806C38E; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (0804972C) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 8049F30: using guessed type int _gmon_start__(void);

//----- (08049750) --------------------------------------------------------
int sub_8049750()
{
  return dword_806B008();
}
// 806B008: using guessed type int (*dword_806B008)(void);

//----- (08049F40) --------------------------------------------------------
#error "8049F43: positive sp value has been found (funcsize=2)"

//----- (08049F73) --------------------------------------------------------
void sub_8049F73()
{
  ;
}

//----- (08049F90) --------------------------------------------------------
void sub_8049F90()
{
  ;
}

//----- (08049FA0) --------------------------------------------------------
int sub_8049FA0()
{
  int result; // eax

  result = &unk_806B487 - &unk_806B484;
  if ( (unsigned int)(&unk_806B487 - &unk_806B484) > 6 )
    result = 0;
  return result;
}
// 8049FA0: could not find valid save-restore pair for ebp

//----- (0804A010) --------------------------------------------------------
int sub_804A010()
{
  int result; // eax

  if ( !byte_806B50C )
  {
    result = sub_8049FA0();
    byte_806B50C = 1;
  }
  return result;
}
// 804A010: could not find valid save-restore pair for ebp
// 806B50C: using guessed type char byte_806B50C;

//----- (0804A030) --------------------------------------------------------
int sub_804A030()
{
  return 0;
}
// 804A030: could not find valid save-restore pair for ebp

//----- (0804A08F) --------------------------------------------------------
void sub_804A08F()
{
  ;
}

//----- (0804A0AA) --------------------------------------------------------
void sub_804A0AA()
{
  ;
}

//----- (0804A0BA) --------------------------------------------------------
int sub_804A0BA()
{
  int result; // eax

  result = &unk_806B473 - &unk_806B470;
  if ( (unsigned int)(&unk_806B473 - &unk_806B470) > 6 )
    result = 0;
  return result;
}
// 804A0BA: could not find valid save-restore pair for ebp

//----- (0804A19C) --------------------------------------------------------
void sub_804A19C()
{
  ;
}

//----- (0804A1B7) --------------------------------------------------------
void sub_804A1B7()
{
  ;
}

//----- (0804A1C7) --------------------------------------------------------
signed int sub_804A1C7()
{
  return 3;
}
// 804A1C7: could not find valid save-restore pair for ebp

//----- (0804A251) --------------------------------------------------------
signed int sub_804A251()
{
  signed int result; // eax

  result = sub_804A1C7();
  byte_806B5E6 = 1;
  return result;
}
// 806B5E6: using guessed type char byte_806B5E6;

//----- (0804A2C5) --------------------------------------------------------
void sub_804A2C5()
{
  ;
}

//----- (0804A2E0) --------------------------------------------------------
void sub_804A2E0()
{
  ;
}

//----- (0804A2F0) --------------------------------------------------------
int sub_804A2F0()
{
  int result; // eax

  result = &unk_806B473 - &unk_806B470;
  if ( (unsigned int)(&unk_806B473 - &unk_806B470) > 6 )
    result = 0;
  return result;
}
// 804A2F0: could not find valid save-restore pair for ebp

//----- (0804A3D2) --------------------------------------------------------
void sub_804A3D2()
{
  ;
}

//----- (0804A3ED) --------------------------------------------------------
void sub_804A3ED()
{
  ;
}

//----- (0804A3FD) --------------------------------------------------------
int sub_804A3FD()
{
  int result; // eax

  result = &unk_806B473 - &unk_806B470;
  if ( (unsigned int)(&unk_806B473 - &unk_806B470) > 6 )
    result = 0;
  return result;
}
// 804A3FD: could not find valid save-restore pair for ebp

//----- (0804A4DF) --------------------------------------------------------
void sub_804A4DF()
{
  ;
}

//----- (0804A4FA) --------------------------------------------------------
void sub_804A4FA()
{
  ;
}

//----- (0804A50A) --------------------------------------------------------
int sub_804A50A()
{
  int result; // eax

  result = &unk_806B6C4 - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_806B6C4 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 804A50A: could not find valid save-restore pair for ebp
// 806B4A0: using guessed type int program_invocation_short_name;

//----- (0804A568) --------------------------------------------------------
int sub_804A568()
{
  return nullsub_3();
}
// 804A568: could not find valid save-restore pair for ebp
// 804A567: using guessed type int nullsub_3(void);

//----- (0804A608) --------------------------------------------------------
void sub_804A608()
{
  ;
}

//----- (0804A623) --------------------------------------------------------
void sub_804A623()
{
  ;
}

//----- (0804A633) --------------------------------------------------------
int sub_804A633()
{
  int result; // eax

  result = &unk_806B473 - &unk_806B470;
  if ( (unsigned int)(&unk_806B473 - &unk_806B470) > 6 )
    result = 0;
  return result;
}
// 804A633: could not find valid save-restore pair for ebp

//----- (0804A691) --------------------------------------------------------
int sub_804A691()
{
  return nullsub_4();
}
// 804A691: could not find valid save-restore pair for ebp
// 804A690: using guessed type int nullsub_4(void);

//----- (0804A731) --------------------------------------------------------
void sub_804A731()
{
  ;
}

//----- (0804A74C) --------------------------------------------------------
void sub_804A74C()
{
  ;
}

//----- (0804A75C) --------------------------------------------------------
int sub_804A75C()
{
  int result; // eax

  result = &unk_806B473 - &unk_806B470;
  if ( (unsigned int)(&unk_806B473 - &unk_806B470) > 6 )
    result = 0;
  return result;
}
// 804A75C: could not find valid save-restore pair for ebp

//----- (0804A7E6) --------------------------------------------------------
int sub_804A7E6()
{
  int result; // eax

  result = sub_804A75C();
  byte_806B807 = 1;
  return result;
}
// 806B807: using guessed type char byte_806B807;

//----- (0804A85A) --------------------------------------------------------
void sub_804A85A()
{
  ;
}

//----- (0804A875) --------------------------------------------------------
void sub_804A875()
{
  ;
}

//----- (0804A885) --------------------------------------------------------
int sub_804A885()
{
  int result; // eax

  result = &unk_80683E7 - &unk_80683E4;
  if ( (unsigned int)(&unk_80683E7 - &unk_80683E4) > 6 )
    result = 0;
  return result;
}
// 804A885: could not find valid save-restore pair for ebp

//----- (0804A937) --------------------------------------------------------
int __usercall sub_804A937@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  int v2; // edx
  int v3; // ecx

  a1(&dword_8067EE0);
  dword_806B284 = (int)&loc_804A8B1;
  sub_8061671(v3, v2);
  return 0;
}
// 8061671: using guessed type int __fastcall sub_8061671(_DWORD, _DWORD);
// 8067EE0: using guessed type int dword_8067EE0;
// 806B284: using guessed type int dword_806B284;

//----- (0804A995) --------------------------------------------------------
void sub_804A995()
{
  ;
}

//----- (0804A9B0) --------------------------------------------------------
void sub_804A9B0()
{
  ;
}

//----- (0804A9C0) --------------------------------------------------------
int sub_804A9C0()
{
  int result; // eax

  result = &unk_806B473 - &unk_806B470;
  if ( (unsigned int)(&unk_806B473 - &unk_806B470) > 6 )
    result = 0;
  return result;
}
// 804A9C0: could not find valid save-restore pair for ebp

//----- (0804AAA2) --------------------------------------------------------
void sub_804AAA2()
{
  ;
}

//----- (0804AABD) --------------------------------------------------------
void sub_804AABD()
{
  ;
}

//----- (0804AACD) --------------------------------------------------------
int sub_804AACD()
{
  int result; // eax

  result = &unk_806B473 - &unk_806B470;
  if ( (unsigned int)(&unk_806B473 - &unk_806B470) > 6 )
    result = 0;
  return result;
}
// 804AACD: could not find valid save-restore pair for ebp

//----- (0804ABC4) --------------------------------------------------------
void sub_804ABC4()
{
  ;
}

//----- (0804ABDF) --------------------------------------------------------
void sub_804ABDF()
{
  ;
}

//----- (0804ABEF) --------------------------------------------------------
int sub_804ABEF()
{
  int result; // eax

  result = &unk_80673AF - &unk_80673AC;
  if ( (unsigned int)(&unk_80673AF - &unk_80673AC) > 6 )
    result = 0;
  return result;
}
// 804ABEF: could not find valid save-restore pair for ebp

//----- (0804ACD1) --------------------------------------------------------
void sub_804ACD1()
{
  ;
}

//----- (0804ACEC) --------------------------------------------------------
void sub_804ACEC()
{
  ;
}

//----- (0804ACFC) --------------------------------------------------------
int sub_804ACFC()
{
  int result; // eax

  result = &unk_806B473 - &unk_806B470;
  if ( (unsigned int)(&unk_806B473 - &unk_806B470) > 6 )
    result = 0;
  return result;
}
// 804ACFC: could not find valid save-restore pair for ebp

//----- (0804ADAE) --------------------------------------------------------
int __usercall sub_804ADAE@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  a1(&dword_8066EF0);
  return 0;
}
// 8066EF0: using guessed type int dword_8066EF0;

//----- (0804ADFA) --------------------------------------------------------
void sub_804ADFA()
{
  ;
}

//----- (0804AE15) --------------------------------------------------------
void sub_804AE15()
{
  ;
}

//----- (0804AE25) --------------------------------------------------------
int sub_804AE25()
{
  int result; // eax

  result = &unk_806B47B - &unk_806B478;
  if ( (unsigned int)(&unk_806B47B - &unk_806B478) > 6 )
    result = 0;
  return result;
}
// 804AE25: could not find valid save-restore pair for ebp

//----- (0804AF35) --------------------------------------------------------
void sub_804AF35()
{
  ;
}

//----- (0804AF50) --------------------------------------------------------
void sub_804AF50()
{
  ;
}

//----- (0804AF60) --------------------------------------------------------
int sub_804AF60()
{
  int result; // eax
  int (__stdcall *v1)(void *, int, int, int, int, int); // eax
  int v2; // [esp+4h] [ebp-18h]
  int v3; // [esp+8h] [ebp-14h]
  int v4; // [esp+Ch] [ebp-10h]
  int v5; // [esp+10h] [ebp-Ch]
  int v6; // [esp+14h] [ebp-8h]
  int v7; // [esp+18h] [ebp-4h]

  result = &unk_806637B - &unk_8066378;
  if ( (unsigned int)(&unk_806637B - &unk_8066378) > 6 )
  {
    v7 = 0;
    dword_806B2C0 = (int)&locret_804AF6F;
    v1 = (int (__stdcall *)(void *, int, int, int, int, int))sub_8061521();
    result = v1(&unk_8066378, v2, v3, v4, v5, v6);
  }
  return result;
}
// 8061521: using guessed type int sub_8061521(void);
// 806B2C0: using guessed type int dword_806B2C0;

//----- (0804B06D) --------------------------------------------------------
void sub_804B06D()
{
  ;
}

//----- (0804B088) --------------------------------------------------------
void sub_804B088()
{
  ;
}

//----- (0804B098) --------------------------------------------------------
int __usercall sub_804B098@<eax>(double a1@<st0>)
{
  int result; // eax
  int (__stdcall *v2)(void *, int, int, int, int, int); // eax
  int v3; // [esp+4h] [ebp-18h]
  int v4; // [esp+8h] [ebp-14h]
  int v5; // [esp+Ch] [ebp-10h]
  int v6; // [esp+10h] [ebp-Ch]
  int v7; // [esp+14h] [ebp-8h]
  int v8; // [esp+18h] [ebp-4h]

  result = &unk_806B473 - &unk_806B470;
  if ( (unsigned int)(&unk_806B473 - &unk_806B470) > 6 )
  {
    v8 = 0;
    dword_806B248 = (int)&locret_804B0A7;
    v2 = (int (__stdcall *)(void *, int, int, int, int, int))sub_80617DA(a1);
    result = v2(&unk_806B470, v3, v4, v5, v6, v7);
  }
  return result;
}
// 80617DA: using guessed type int __usercall sub_80617DA@<eax>(double@<st0>);
// 806B248: using guessed type int dword_806B248;

//----- (0804B10F) --------------------------------------------------------
int sub_804B10F()
{
  return nullsub_5();
}
// 804B10F: could not find valid save-restore pair for ebp
// 804B10E: using guessed type int nullsub_5(void);

//----- (0804B1C1) --------------------------------------------------------
void sub_804B1C1()
{
  ;
}

//----- (0804B1DC) --------------------------------------------------------
void sub_804B1DC()
{
  ;
}

//----- (0804B1EC) --------------------------------------------------------
int sub_804B1EC()
{
  int result; // eax

  result = &unk_806B477 - &unk_806B474;
  if ( (unsigned int)(&unk_806B477 - &unk_806B474) > 6 )
    result = 0;
  return result;
}
// 804B1EC: could not find valid save-restore pair for ebp

//----- (0804B2CE) --------------------------------------------------------
void sub_804B2CE()
{
  ;
}

//----- (0804B2E9) --------------------------------------------------------
void sub_804B2E9()
{
  ;
}

//----- (0804B2F9) --------------------------------------------------------
int sub_804B2F9()
{
  int result; // eax

  result = &unk_806BBE0 - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_806BBE0 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 804B2F9: could not find valid save-restore pair for ebp
// 806B4A0: using guessed type int program_invocation_short_name;

//----- (0804B383) --------------------------------------------------------
int sub_804B383()
{
  int result; // eax

  result = sub_804B2F9();
  byte_806BC49 = 1;
  return result;
}
// 806BC49: using guessed type char byte_806BC49;

//----- (0804B409) --------------------------------------------------------
void sub_804B409()
{
  ;
}

//----- (0804B424) --------------------------------------------------------
void sub_804B424()
{
  ;
}

//----- (0804B434) --------------------------------------------------------
int sub_804B434()
{
  int result; // eax

  result = &unk_806B47B - &unk_806B478;
  if ( (unsigned int)(&unk_806B47B - &unk_806B478) > 6 )
    result = 0;
  return result;
}
// 804B434: could not find valid save-restore pair for ebp

//----- (0804B4BE) --------------------------------------------------------
int sub_804B4BE()
{
  int result; // eax

  result = sub_804B434();
  byte_806BC96 = 1;
  return result;
}
// 806BC96: using guessed type char byte_806BC96;

//----- (0804B4FF) --------------------------------------------------------
int __usercall sub_804B4FF@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  a1(&dword_8064F08);
  return 0;
}
// 8064F08: using guessed type int dword_8064F08;

//----- (0804B519) --------------------------------------------------------
int __cdecl sub_804B519(int a1)
{
  int result; // eax

  dword_806B2D0 = (int (__cdecl *)(_DWORD))&loc_804B53C;
  if ( a1 == 1 )
    return dword_806B2D0(1);
  result = a1;
  status = a1;
  return result;
}
// 806B2D0: using guessed type int (__cdecl *dword_806B2D0)(_DWORD);

//----- (0804B53E) --------------------------------------------------------
int __cdecl sub_804B53E(unsigned __int8 a1)
{
  return a1;
}

//----- (0804B550) --------------------------------------------------------
int __cdecl sub_804B550(unsigned __int8 a1)
{
  return (*__ctype_b_loc())[a1] & 1 || a1 == 10;
}

//----- (0804B58F) --------------------------------------------------------
int __usercall sub_804B58F@<eax>(double a1@<st0>, unsigned __int64 a2)
{
  if ( HIDWORD(a2) )
  {
    sub_8060EA3(a2, 0xF4240u, 0);
    dword_806B248 = (int)&locret_804B5E8;
    sub_80617DA(a1);
  }
  return a2;
}
// 80617DA: using guessed type int __usercall sub_80617DA@<eax>(double@<st0>);
// 806B248: using guessed type int dword_806B248;

//----- (0804B5EA) --------------------------------------------------------
int sub_804B5EA()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nWith no FILE, or when FILE is -, read standard input.\n");
  return fputs_unlocked(v1, v0);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804B615) --------------------------------------------------------
int sub_804B615()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nMandatory arguments to long options are mandatory for short options too.\n");
  return fputs_unlocked(v1, v0);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804B640) --------------------------------------------------------
int __usercall sub_804B640@<eax>(double a1@<st0>, char *s1)
{
  void *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // ebx
  char *v7; // eax
  char *v9; // [esp+1Ch] [ebp-4Ch]
  const char **i; // [esp+20h] [ebp-48h]
  const char *v11; // [esp+24h] [ebp-44h]
  const char *v12; // [esp+28h] [ebp-40h]
  const char *v13; // [esp+2Ch] [ebp-3Ch]
  const char *v14; // [esp+30h] [ebp-38h]
  const char *v15; // [esp+34h] [ebp-34h]
  const char *v16; // [esp+38h] [ebp-30h]
  const char *v17; // [esp+3Ch] [ebp-2Ch]
  const char *v18; // [esp+40h] [ebp-28h]
  const char *v19; // [esp+44h] [ebp-24h]
  const char *v20; // [esp+48h] [ebp-20h]
  const char *v21; // [esp+4Ch] [ebp-1Ch]
  const char *v22; // [esp+50h] [ebp-18h]
  const char *v23; // [esp+54h] [ebp-14h]
  int v24; // [esp+58h] [ebp-10h]
  int v25; // [esp+5Ch] [ebp-Ch]

  v12 = "[";
  v13 = "test invocation";
  v14 = "coreutils";
  v15 = "Multi-call invocation";
  v16 = "sha224sum";
  v17 = "sha2 utilities";
  v18 = "sha256sum";
  v19 = "sha2 utilities";
  v20 = "sha384sum";
  v21 = "sha2 utilities";
  v22 = "sha512sum";
  v23 = "sha2 utilities";
  v24 = 0;
  v25 = 0;
  for ( i = &v12; *i && strcmp(s1, *i); i += 2 )
    ;
  v2 = &loc_804B6FF;
  if ( !i[1] )
    v2 = &loc_804B708;
  dword_806B248 = (int)v2;
  sub_80617DA(a1);
  v9 = (char *)i[1];
  v3 = gettext("\n%s online help: <%s>\n");
  printf(v3, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  v11 = setlocale(5, 0);
  if ( v11 && strncmp(v11, "en_", 3u) )
  {
    v4 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
    printf(v4, s1);
  }
  v5 = gettext("Full documentation at: <%s%s>\n");
  printf(v5, "http://www.gnu.org/software/coreutils/", s1);
  if ( v9 == s1 )
    v6 = " invocation";
  else
    v6 = &s;
  v7 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  return printf(v7, v9, v6);
}
// 80617DA: using guessed type int __usercall sub_80617DA@<eax>(double@<st0>);
// 806B248: using guessed type int dword_806B248;

//----- (0804B7DF) --------------------------------------------------------
int __cdecl sub_804B7DF(int a1, const char *a2)
{
  size_t v2; // eax
  char *v3; // ST20_4
  size_t v4; // eax
  char v6; // [esp+30h] [ebp-18h]
  unsigned int v7; // [esp+3Ch] [ebp-Ch]

  v7 = __readgsdword(0x14u);
  v2 = strlen(a2);
  write(2, a2, v2);
  dword_806B2D0 = (int (__cdecl *)(_DWORD))&loc_804B88C;
  if ( a1 )
  {
    v3 = (char *)sub_805928C(a1, (int)&v6);
    write(2, ": errno ", 8u);
    v4 = strlen(v3);
    write(2, v3, v4);
    write(2, "\n", 1u);
    _exit(2);
  }
  return dword_806B2D0(0);
}
// 806B2D0: using guessed type int (__cdecl *dword_806B2D0)(_DWORD);

//----- (0804B8B7) --------------------------------------------------------
int __fastcall sub_804B8B7(int a1, int a2, int a3, int a4)
{
  dword_806B328 = (int (__fastcall *)(_DWORD, _DWORD))sub_804B8F5;
  if ( !a4 )
  {
    gettext("standard output");
    dword_806B328 = (int (__fastcall *)(_DWORD, _DWORD))&loc_804B8F8;
  }
  return dword_806B328(a1, a2);
}
// 806B328: using guessed type int (__fastcall *dword_806B328)(_DWORD, _DWORD);

//----- (0804B8F5) --------------------------------------------------------
#error "804B90B: call analysis failed (funcsize=15)"

//----- (0804B93C) --------------------------------------------------------
void __usercall __noreturn sub_804B93C(double a1@<st0>, int status)
{
  int v2; // ebx
  char *v3; // eax
  int v4; // esi
  int v5; // ebx
  char *v6; // eax
  FILE *v7; // ebx
  char *v8; // eax
  FILE *v9; // ebx
  char *v10; // eax
  FILE *v11; // ebx
  char *v12; // eax
  FILE *v13; // ebx
  char *v14; // eax
  FILE *v15; // ebx
  char *v16; // eax
  FILE *v17; // ebx
  char *v18; // eax
  FILE *v19; // ebx
  char *v20; // eax
  FILE *v21; // ebx
  char *v22; // eax
  FILE *v23; // ebx
  char *v24; // eax
  FILE *v25; // ebx
  char *v26; // eax
  FILE *v27; // ebx
  char *v28; // eax
  FILE *v29; // ebx
  char *v30; // eax
  FILE *v31; // ebx
  char *v32; // eax
  char *v33; // eax
  FILE *v34; // ebx
  char *v35; // eax
  FILE *v36; // ebx
  char *v37; // eax
  FILE *v38; // ebx
  char *v39; // eax
  FILE *v40; // ebx
  char *v41; // eax
  FILE *v42; // ebx
  char *v43; // eax

  if ( status )
  {
    v2 = dword_806C23A;
    v3 = gettext("Try '%s --help' for more information.\n");
    fprintf(stderr, v3, v2);
  }
  else
  {
    v4 = dword_806C23A;
    v5 = dword_806C23A;
    v6 = gettext("Usage: %s [OPTION]... [FILE]...\n  or:  %s [OPTION]... --files0-from=F\n");
    printf(v6, v5, v4);
    v7 = stdout;
    v8 = gettext("Write sorted concatenation of all FILE(s) to standard output.\n");
    fputs_unlocked(v8, v7);
    sub_804B5EA();
    sub_804B615();
    v9 = stdout;
    v10 = gettext("Ordering options:\n\n");
    fputs_unlocked(v10, v9);
    v11 = stdout;
    v12 = gettext(
            "  -b, --ignore-leading-blanks  ignore leading blanks\n"
            "  -d, --dictionary-order      consider only blanks and alphanumeric characters\n"
            "  -f, --ignore-case           fold lower case to upper case characters\n");
    fputs_unlocked(v12, v11);
    v13 = stdout;
    v14 = gettext(
            "  -g, --general-numeric-sort  compare according to general numerical value\n"
            "  -i, --ignore-nonprinting    consider only printable characters\n"
            "  -M, --month-sort            compare (unknown) < 'JAN' < ... < 'DEC'\n");
    fputs_unlocked(v14, v13);
    v15 = stdout;
    v16 = gettext("  -h, --human-numeric-sort    compare human readable numbers (e.g., 2K 1G)\n");
    fputs_unlocked(v16, v15);
    v17 = stdout;
    v18 = gettext(
            "  -n, --numeric-sort          compare according to string numerical value\n"
            "  -R, --random-sort           shuffle, but group identical keys.  See shuf(1)\n"
            "      --random-source=FILE    get random bytes from FILE\n"
            "  -r, --reverse               reverse the result of comparisons\n");
    fputs_unlocked(v18, v17);
    v19 = stdout;
    v20 = gettext(
            "      --sort=WORD             sort according to WORD:\n"
            "                                general-numeric -g, human-numeric -h, month -M,\n"
            "                                numeric -n, random -R, version -V\n"
            "  -V, --version-sort          natural sort of (version) numbers within text\n"
            "\n");
    fputs_unlocked(v20, v19);
    v21 = stdout;
    v22 = gettext("Other options:\n\n");
    fputs_unlocked(v22, v21);
    v23 = stdout;
    v24 = gettext(
            "      --batch-size=NMERGE   merge at most NMERGE inputs at once;\n"
            "                            for more use temp files\n");
    fputs_unlocked(v24, v23);
    v25 = stdout;
    v26 = gettext(
            "  -c, --check, --check=diagnose-first  check for sorted input; do not sort\n"
            "  -C, --check=quiet, --check=silent  like -c, but do not report first bad line\n"
            "      --compress-program=PROG  compress temporaries with PROG;\n"
            "                              decompress them with PROG -d\n");
    fputs_unlocked(v26, v25);
    v27 = stdout;
    v28 = gettext(
            "      --debug               annotate the part of the line used to sort,\n"
            "                              and warn about questionable usage to stderr\n"
            "      --files0-from=F       read input from the files specified by\n"
            "                            NUL-terminated names in file F;\n"
            "                            If F is - then read names from standard input\n");
    fputs_unlocked(v28, v27);
    v29 = stdout;
    v30 = gettext(
            "  -k, --key=KEYDEF          sort via a key; KEYDEF gives location and type\n"
            "  -m, --merge               merge already sorted files; do not sort\n");
    fputs_unlocked(v30, v29);
    v31 = stdout;
    v32 = gettext(
            "  -o, --output=FILE         write result to FILE instead of standard output\n"
            "  -s, --stable              stabilize sort by disabling last-resort comparison\n"
            "  -S, --buffer-size=SIZE    use SIZE for main memory buffer\n");
    fputs_unlocked(v32, v31);
    v33 = gettext(
            "  -t, --field-separator=SEP  use SEP instead of non-blank to blank transition\n"
            "  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or %s;\n"
            "                              multiple options specify multiple directories\n"
            "      --parallel=N          change the number of sorts run concurrently to N\n"
            "  -u, --unique              with -c, check for strict ordering;\n"
            "                              without -c, output only the first of an equal run\n");
    printf(v33, "/tmp");
    v34 = stdout;
    v35 = gettext("  -z, --zero-terminated     line delimiter is NUL, not newline\n");
    fputs_unlocked(v35, v34);
    v36 = stdout;
    v37 = gettext("      --help     display this help and exit\n");
    fputs_unlocked(v37, v36);
    v38 = stdout;
    v39 = gettext("      --version  output version information and exit\n");
    fputs_unlocked(v39, v38);
    v40 = stdout;
    v41 = gettext(
            "\n"
            "KEYDEF is F[.C][OPTS][,F[.C][OPTS]] for start and stop position, where F is a\n"
            "field number and C a character position in the field; both are origin 1, and\n"
            "the stop position defaults to the line's end.  If neither -t nor -b is in\n"
            "effect, characters in a field are counted from the beginning of the preceding\n"
            "whitespace.  OPTS is one or more single-letter ordering options [bdfgiMhnRrV],\n"
            "which override global ordering options for that key.  If no key is given, use\n"
            "the entire line as the key.  Use --debug to diagnose incorrect key usage.\n"
            "\n"
            "SIZE may be followed by the following multiplicative suffixes:\n");
    fputs_unlocked(v41, v40);
    v42 = stdout;
    v43 = gettext(
            "% 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, E, Z, Y.\n"
            "\n"
            "*** WARNING ***\n"
            "The locale specified by the environment affects sort order.\n"
            "Set LC_ALL=C to get the traditional sort order that uses\n"
            "native byte values.\n");
    fputs_unlocked(v43, v42);
    sub_804B640(a1, "sort");
  }
  exit(status);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 806C23A: using guessed type int dword_806C23A;

//----- (0804BBF8) --------------------------------------------------------
int __cdecl sub_804BBF8(int a1)
{
  bool v1; // dl
  int result; // eax

  v1 = pthread_sigmask(0, &set, (__sigset_t *)(a1 + 4)) == 0;
  result = a1;
  *(_BYTE *)a1 = v1;
  return result;
}

//----- (0804BC2D) --------------------------------------------------------
int __cdecl sub_804BC2D(unsigned __int8 *a1)
{
  int result; // eax

  result = *a1;
  if ( (_BYTE)result )
    result = pthread_sigmask(2, (const __sigset_t *)(a1 + 4), 0);
  return result;
}

//----- (0804BC5D) --------------------------------------------------------
int __cdecl sub_804BC5D(int a1, unsigned int a2)
{
  return *(_DWORD *)(a1 + 4) % a2;
}

//----- (0804BC7B) --------------------------------------------------------
bool __cdecl sub_804BC7B(int a1, int a2)
{
  return *(_DWORD *)(a1 + 4) == *(_DWORD *)(a2 + 4);
}

//----- (0804BCA0) --------------------------------------------------------
int __usercall sub_804BCA0@<eax>(double a1@<st0>, __pid_t pid)
{
  __pid_t v2; // eax
  void *v3; // esi
  char *v4; // ebx
  int *v5; // eax
  void *v6; // eax
  int stat_loc; // [esp+18h] [ebp-10h]
  int v9; // [esp+1Ch] [ebp-Ch]

  if ( pid )
    v2 = pid;
  else
    v2 = -1;
  v9 = waitpid(v2, &stat_loc, pid == 0);
  if ( v9 < 0 )
  {
    v3 = sub_805B8A5(a1, 4, s1);
    v4 = gettext("waiting for %s [-d]");
    v5 = __errno_location();
    error(2, *v5, v4, v3);
  }
  if ( v9 > 0 )
  {
    v6 = &loc_804BD4B;
    if ( pid > 0 )
      v6 = &loc_804BD5A;
    dword_806B270 = (int)v6;
    sub_80616F8();
    sub_804BE56(a1, v9);
  }
  return v9;
}
// 80616F8: using guessed type int sub_80616F8(void);
// 806B270: using guessed type int dword_806B270;

//----- (0804BDE2) --------------------------------------------------------
int __usercall sub_804BDE2@<eax>(double st7_0@<st0>, int a1)
{
  int result; // eax

  if ( !dword_806C16E )
  {
    dword_806C16E = (int)sub_8058198(0x2Fu, 0, (unsigned int (__cdecl *)(int, unsigned int))sub_804BC5D, sub_804BC7B, 0);
    if ( !dword_806C16E )
      sub_805E306();
  }
  *(_BYTE *)(a1 + 8) = 1;
  result = sub_8058D23(st7_0, (unsigned int *)dword_806C16E, a1);
  if ( !result )
    sub_805E306();
  return result;
}
// 806C16E: using guessed type int dword_806C16E;

//----- (0804BE56) --------------------------------------------------------
int __usercall __noreturn sub_804BE56@<eax>(double st7_0@<st0>, int a1)
{
  int v2; // ecx
  unsigned int v3; // et1
  int (*v4)(); // eax
  int v6; // [esp+1Ch] [ebp-1Ch]
  char v7; // [esp+20h] [ebp-18h]
  int v8; // [esp+24h] [ebp-14h]
  unsigned int v9; // [esp+2Ch] [ebp-Ch]

  v9 = __readgsdword(0x14u);
  v8 = a1;
  v6 = sub_8058D77(st7_0, dword_806C16E, (int)&v7);
  if ( v6 )
    *(_BYTE *)(v6 + 8) = 2;
  v3 = __readgsdword(0x14u);
  v2 = v3 ^ v9;
  v4 = (int (*)())&loc_804BEC2;
  if ( v3 == v9 )
    v4 = sub_804BEC7;
  dword_806B220 = (int)v4;
  return sub_80618C4(v2);
}
// 804BEC7: using guessed type int sub_804BEC7();
// 80618C4: using guessed type int __fastcall sub_80618C4(_DWORD);
// 806B220: using guessed type int dword_806B220;
// 806C16E: using guessed type int dword_806C16E;

//----- (0804BEC7) --------------------------------------------------------
#error "804BEC8: positive sp value has been found (funcsize=0)"

//----- (0804BEC9) --------------------------------------------------------
void __usercall __noreturn sub_804BEC9(double st7_0@<st0>, int a1)
{
  sub_804BE56(st7_0, a1);
}

//----- (0804BEEB) --------------------------------------------------------
int __usercall sub_804BEEB@<eax>(int a1@<edx>, int a2@<ecx>, double a3@<st0>)
{
  void *v3; // eax
  int result; // eax

  do
  {
    v3 = &loc_804BF15;
    if ( dword_806C172 <= 0 )
      v3 = &locret_804BF25;
    dword_806B284 = (int)v3;
    sub_8061671(a2, a1);
    result = sub_804BCA0(a3, 0);
  }
  while ( result );
  return result;
}
// 8061671: using guessed type int __fastcall sub_8061671(_DWORD, _DWORD);
// 806B284: using guessed type int dword_806B284;
// 806C172: using guessed type int dword_806C172;

//----- (0804BF27) --------------------------------------------------------
int __usercall sub_804BF27@<eax>(double a1@<st0>)
{
  int v1; // edx
  int v2; // ecx

  sub_804BCA0(a1, -1);
  return sub_804BEEB(v1, v2, a1);
}

//----- (0804BF40) --------------------------------------------------------
int __usercall sub_804BF40@<eax>(double a1@<st0>)
{
  int result; // eax

  while ( 1 )
  {
    result = dword_806C172;
    if ( dword_806C172 <= 0 )
      break;
    sub_804BCA0(a1, -1);
  }
  return result;
}
// 806C172: using guessed type int dword_806C172;

//----- (0804BF5F) --------------------------------------------------------
int __fastcall sub_804BF5F(int a1)
{
  int result; // eax
  int v2; // [esp+1Ch] [ebp-Ch]

  v2 = dword_806C16A;
  dword_806B318 = (int)&loc_804BF9A;
  sub_8061268(a1);
  do
  {
    unlink((const char *)(v2 + 9));
    result = *(_DWORD *)v2;
    v2 = *(_DWORD *)v2;
  }
  while ( v2 );
  dword_806C16A = 0;
  return result;
}
// 8061268: using guessed type int __fastcall sub_8061268(_DWORD);
// 806B318: using guessed type int dword_806B318;
// 806C16A: using guessed type int dword_806C16A;

//----- (0804BFAC) --------------------------------------------------------
int __usercall sub_804BFAC@<eax>(double a1@<st0>)
{
  int v1; // ecx
  char v3; // [esp+1Ch] [ebp-8Ch]

  if ( dword_806C16A )
  {
    sub_804BBF8((int)&v3);
    sub_804BF5F(v1);
    sub_804BC2D((unsigned __int8 *)&v3);
  }
  return sub_8055ED9(a1);
}
// 806C16A: using guessed type int dword_806C16A;

//----- (0804BFE6) --------------------------------------------------------
void *__usercall sub_804BFE6@<eax>(double a1@<st0>, _DWORD *a2, char a3)
{
  _DWORD *v3; // eax
  int v4; // ecx
  void *v5; // eax
  int v6; // eax
  void *v7; // esi
  char *v8; // ebx
  int v9; // eax
  void *v11; // [esp+Ch] [ebp-BCh]
  char v12; // [esp+1Ch] [ebp-ACh]
  void *ptr; // [esp+24h] [ebp-A4h]
  char *s; // [esp+28h] [ebp-A0h]
  size_t n; // [esp+2Ch] [ebp-9Ch]
  void *dest; // [esp+30h] [ebp-98h]
  int v17; // [esp+34h] [ebp-94h]
  int v18; // [esp+38h] [ebp-90h]
  char v19; // [esp+3Ch] [ebp-8Ch]

  v12 = a3;
  s = *(char **)(4 * dword_806C226 + dword_806C0CE);
  n = strlen(s);
  ptr = (void *)sub_805E160((n + 24) & 0xFFFFFFFC);
  dest = (char *)ptr + 9;
  memcpy((char *)ptr + 9, s, n);
  v3 = (char *)ptr + n + 9;
  *v3 = 1919906607;
  v3[1] = 1482184820;
  v3[2] = 5789784;
  *(_DWORD *)ptr = 0;
  ++dword_806C226;
  dword_806B2D0 = (int (__cdecl *)(_DWORD))&loc_804C0D7;
  if ( dword_806C226 != dword_806C0D2 )
    return (void *)dword_806B2D0(a2);
  dword_806C226 = 0;
  sub_804BBF8((int)&v19);
  v17 = sub_805D1DE(a1, (int)dest, 0x80000);
  dword_806B2D0 = (int (__cdecl *)(_DWORD))&loc_804C134;
  if ( v17 < 0 )
    return (void *)dword_806B2D0(a2);
  *off_806B3FC = (int)ptr;
  off_806B3FC = (int *)ptr;
  v18 = *__errno_location();
  sub_804BC2D((unsigned __int8 *)&v19);
  *__errno_location() = v18;
  dword_806B2D0 = (int (__cdecl *)(_DWORD))&loc_804C219;
  if ( v17 >= 0 )
    return (void *)dword_806B2D0(a2);
  v5 = &loc_804C19E;
  if ( v12 != 1 )
    v5 = &loc_804C1BC;
  dword_806B318 = (int)v5;
  sub_8061268(v4);
  v6 = *__errno_location();
  dword_806B2D0 = (int (__cdecl *)(_DWORD))&loc_804C201;
  if ( v6 == 24 )
    return (void *)dword_806B2D0(a2);
  v7 = sub_805B8A5(a1, 4, s);
  v8 = gettext("cannot create temporary file in %s");
  v9 = *__errno_location();
  v11 = v7;
  error(2, v9, v8, v7);
  free(ptr);
  ptr = 0;
  *a2 = v17;
  return ptr;
}
// 8061268: using guessed type int __fastcall sub_8061268(_DWORD);
// 806B2D0: using guessed type int (__cdecl *dword_806B2D0)(_DWORD);
// 806B318: using guessed type int dword_806B318;
// 806B3FC: using guessed type int *off_806B3FC;
// 806C0CE: using guessed type int dword_806C0CE;
// 806C0D2: using guessed type int dword_806C0D2;
// 806C226: using guessed type int dword_806C226;

//----- (0804C234) --------------------------------------------------------
FILE *__usercall sub_804C234@<eax>(double a1@<st0>, char *s1, char *modes)
{
  FILE *v3; // eax
  void *v4; // esi
  char *v5; // ebx
  int *v6; // eax
  FILE *stream; // [esp+18h] [ebp-10h]
  int fd; // [esp+1Ch] [ebp-Ch]

  if ( *modes == 114 )
  {
    if ( !strcmp(s1, "-") )
    {
      byte_806C0DD = 1;
      stream = stdin;
      sub_80572C7(stdin, 2);
    }
    else
    {
      fd = open64(s1, 0x80000);
      if ( fd < 0 )
        v3 = 0;
      else
        v3 = fdopen(fd, modes);
      stream = v3;
      sub_80572C7(v3, 2);
    }
  }
  else
  {
    if ( *modes != 119 )
      __assert_fail("!\"unexpected mode passed to stream_open\"", "src/sort.c", 0x3CCu, "stream_open");
    if ( s1 && ftruncate64(1, 0, 0) )
    {
      v4 = sub_805BA00(a1, 0, 3, s1);
      v5 = gettext("%s: error truncating");
      v6 = __errno_location();
      error(2, *v6, v5, v4);
    }
    stream = stdout;
  }
  return stream;
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 8049D20: using guessed type int __cdecl ftruncate64(_DWORD, _DWORD, _DWORD);
// 806C0DD: using guessed type char byte_806C0DD;

//----- (0804C370) --------------------------------------------------------
FILE *__usercall sub_804C370@<eax>(double a1@<st0>, char *s1, char *modes)
{
  FILE *v3; // eax
  int v4; // ecx
  bool v5; // zf
  void *v6; // eax
  char *v7; // eax
  int v8; // ecx
  FILE *v10; // [esp+1Ch] [ebp-Ch]

  v3 = sub_804C234(a1, s1, modes);
  v10 = v3;
  v5 = v3 == 0;
  v6 = &loc_804C3AA;
  if ( !v5 )
    v6 = &loc_804C3C5;
  dword_806B220 = (int)v6;
  sub_80618C4(v4);
  v7 = gettext("open failed");
  sub_804B8B7(v8, (int)s1, (int)v7, (int)s1);
  return v10;
}
// 80618C4: using guessed type int __fastcall sub_80618C4(_DWORD);
// 806B220: using guessed type int dword_806B220;

//----- (0804C3CA) --------------------------------------------------------
void __usercall sub_804C3CA(double a1@<st0>, FILE *stream, int a3)
{
  int v3; // eax
  bool v4; // zf
  void *v5; // eax
  char *v6; // eax
  int v7; // ecx

  v3 = fileno(stream);
  if ( v3 )
  {
    v4 = v3 == 1;
    v5 = &loc_804C3FD;
    if ( v4 )
      v5 = &loc_804C41D;
    dword_806B2E4 = (int)v5;
    sub_806141F(a1);
    if ( sub_805F1E8(stream) )
    {
      v6 = gettext("close failed");
      sub_804B8B7(v7, a3, (int)v6, a3);
    }
  }
  else if ( feof_unlocked(stream) )
  {
    clearerr_unlocked(stream);
  }
}
// 806141F: using guessed type int __usercall sub_806141F@<eax>(double@<st0>);
// 806B2E4: using guessed type int dword_806B2E4;

//----- (0804C48E) --------------------------------------------------------
int __cdecl sub_804C48E(int fd, int fd2)
{
  int result; // eax

  result = fd;
  if ( fd != fd2 )
  {
    dup2(fd, fd2);
    result = close(fd);
  }
  return result;
}

//----- (0804C4BB) --------------------------------------------------------
__pid_t __cdecl sub_804C4BB(int pipedes[2], int a2)
{
  long double v2; // fst7
  void *v3; // eax
  long double v4; // fst7
  int v5; // edx
  int v6; // ecx
  int v7; // eax
  __pid_t v9; // [esp+14h] [ebp-A4h]
  int v10; // [esp+18h] [ebp-A0h]
  int v11; // [esp+1Ch] [ebp-9Ch]
  double v12; // [esp+20h] [ebp-98h]
  char v13; // [esp+2Ch] [ebp-8Ch]

  v2 = 0.25;
  v12 = 0.25;
  if ( sub_8059D1C(*(double *)&v2, pipedes, 0x80000) < 0 )
  {
    dword_806B270 = (int)&locret_804C665;
    sub_80616F8();
  }
  if ( dword_806B3F8 + 1 < (unsigned int)dword_806C172 )
    sub_804BF27(*(double *)&v2);
  while ( 1 )
  {
    v7 = a2--;
    if ( !v7 )
      break;
    sub_804BBF8((int)&v13);
    v10 = dword_806C16A;
    dword_806C16A = 0;
    v9 = fork();
    v11 = *__errno_location();
    v3 = &loc_804C580;
    if ( !v9 )
      v3 = &loc_804C58B;
    dword_806B304 = (int)v3;
    sub_8061308();
    dword_806C16A = v10;
    sub_804BC2D((unsigned __int8 *)&v13);
    *__errno_location() = v11;
    if ( v9 >= 0 || *__errno_location() != 11 )
      break;
    sub_805E4DB(v12);
    v4 = v12 + v12;
    v12 = v4;
    sub_804BEEB(v5, v6, *(double *)&v4);
  }
  if ( v9 >= 0 )
  {
    if ( v9 )
    {
      ++dword_806C172;
    }
    else
    {
      close(0);
      close(1);
    }
  }
  else
  {
    v11 = *__errno_location();
    close(*pipedes);
    close(pipedes[1]);
    *__errno_location() = v11;
  }
  return v9;
}
// 8061308: using guessed type int sub_8061308(void);
// 80616F8: using guessed type int sub_80616F8(void);
// 806B270: using guessed type int dword_806B270;
// 806B304: using guessed type int dword_806B304;
// 806C16A: using guessed type int dword_806C16A;
// 806C172: using guessed type int dword_806C172;

//----- (0804C667) --------------------------------------------------------
_BYTE *__usercall sub_804C667@<eax>(double a1@<st0>, FILE **a2, char a3)
{
  int v3; // ecx
  void *v5; // eax
  __pid_t v6; // eax
  int *v7; // eax
  int v8; // ebx
  char *v9; // eax
  int v10; // edx
  int v11; // ecx
  int v12; // [esp+Ch] [ebp-1Ch]
  int fd; // [esp+10h] [ebp-18h]
  _BYTE *v14; // [esp+14h] [ebp-14h]
  int pipedes[2]; // [esp+18h] [ebp-10h]

  LOBYTE(v12) = a3;
  v14 = sub_804BFE6(a1, &fd, a3);
  if ( !v14 )
    return 0;
  v14[8] = 0;
  v5 = &loc_804C6C3;
  if ( !s1 )
    v5 = &loc_804C780;
  dword_806B318 = (int)v5;
  sub_8061268(v3);
  v6 = sub_804C4BB(pipedes, 4);
  *((_DWORD *)v14 + 1) = v6;
  if ( *((_DWORD *)v14 + 1) <= 0 )
  {
    if ( !*((_DWORD *)v14 + 1) )
    {
      close(pipedes[1]);
      sub_804C48E(fd, 1);
      sub_804C48E(pipedes[0], 0);
      execlp(s1, s1, 0, v12);
      v7 = __errno_location();
      sub_804B7DF(*v7, "couldn't execute compress program");
    }
  }
  else
  {
    close(fd);
    close(pipedes[0]);
    fd = pipedes[1];
    sub_804BDE2(a1, (int)v14);
  }
  *a2 = fdopen(fd, "w");
  if ( !*a2 )
  {
    v8 = (int)(v14 + 9);
    v9 = gettext("couldn't create temporary file");
    sub_804B8B7(v11, v10, (int)v9, v8);
  }
  return v14;
}
// 8061268: using guessed type int __fastcall sub_8061268(_DWORD);
// 806B318: using guessed type int dword_806B318;

//----- (0804C7C8) --------------------------------------------------------
_BYTE *__usercall sub_804C7C8@<eax>(double a1@<st0>, FILE **a2)
{
  return sub_804C667(a1, a2, 0);
}

//----- (0804C7E3) --------------------------------------------------------
FILE *__usercall sub_804C7E3@<eax>(double a1@<st0>, int a2)
{
  __pid_t v3; // eax
  void *v4; // esi
  char *v5; // ebx
  int v6; // eax
  int *v7; // eax
  const char *v8; // [esp+8h] [ebp-30h]
  void *v9; // [esp+Ch] [ebp-2Ch]
  FILE *v10; // [esp+18h] [ebp-20h]
  int fd; // [esp+1Ch] [ebp-1Ch]
  __pid_t v12; // [esp+20h] [ebp-18h]
  int v13; // [esp+24h] [ebp-14h]
  int pipedes[2]; // [esp+28h] [ebp-10h]

  v10 = 0;
  if ( *(_BYTE *)(a2 + 8) == 1 )
    sub_804BEC9(a1, *(_DWORD *)(a2 + 4));
  fd = open64(a2 + 9, 0);
  if ( fd < 0 )
    return 0;
  v3 = sub_804C4BB(pipedes, 9);
  v12 = v3;
  if ( v3 != -1 )
  {
    if ( !v3 )
    {
      close(pipedes[0]);
      sub_804C48E(fd, 0);
      sub_804C48E(pipedes[1], 1);
      v9 = 0;
      v8 = "-d";
      execlp(s1, s1, "-d", 0);
      v7 = __errno_location();
      sub_804B7DF(*v7, "couldn't execute compress program (with -d)");
      *(_DWORD *)(a2 + 4) = v12;
      sub_804BDE2(a1, a2);
      close(fd);
      close(pipedes[1]);
      v10 = fdopen(pipedes[0], "r");
      if ( !v10 )
      {
        v13 = *__errno_location();
        close(pipedes[0]);
        *__errno_location() = v13;
      }
      return v10;
    }
    dword_806B270 = (int)&loc_804C94B;
    sub_80616F8();
  }
  if ( *__errno_location() != 24 )
  {
    v4 = sub_805B8A5(a1, 4, s1);
    v5 = gettext("couldn't create process for %s -d");
    v6 = *__errno_location();
    v9 = v4;
    error(2, v6, v5, v4);
  }
  close(fd);
  *__errno_location() = 24;
  return v10;
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 80616F8: using guessed type int sub_80616F8(void);
// 806B270: using guessed type int dword_806B270;

//----- (0804C9BC) --------------------------------------------------------
int __cdecl sub_804C9BC(int a1)
{
  int v1; // ecx
  void *v2; // eax
  int v3; // eax
  int *v4; // edx
  int result; // eax

  v2 = &loc_804C9EA;
  if ( dword_806C0D2 != dword_806C0D6 )
    v2 = &loc_804CA0C;
  dword_806B234 = (int)v2;
  sub_806184C(v1, dword_806C0D2);
  dword_806C0CE = sub_805E059(dword_806C0CE, (unsigned int *)&dword_806C0D6, 4u);
  v3 = dword_806C0D2++;
  v4 = (int *)(dword_806C0CE + 4 * v3);
  result = a1;
  *v4 = a1;
  return result;
}
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD, _DWORD);
// 806B234: using guessed type int dword_806B234;
// 806C0CE: using guessed type int dword_806C0CE;
// 806C0D2: using guessed type int dword_806C0D2;
// 806C0D6: using guessed type int dword_806C0D6;

//----- (0804CA2D) --------------------------------------------------------
void __usercall sub_804CA2D(double a1@<st0>, char *name)
{
  int v2; // ST30_4
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  void *v6; // ebx
  char *v7; // eax
  int *i; // [esp+18h] [ebp-A0h]
  int errnum; // [esp+1Ch] [ebp-9Ch]
  _DWORD *ptr; // [esp+20h] [ebp-98h]
  int v11; // [esp+24h] [ebp-94h]
  char v12; // [esp+2Ch] [ebp-8Ch]

  for ( i = &dword_806C16A; ; i = (int *)*i )
  {
    ptr = (_DWORD *)*i;
    if ( (char *)(*i + 9) == name )
      break;
  }
  if ( *((_BYTE *)ptr + 8) == 1 )
    sub_804BEC9(a1, ptr[1]);
  v11 = *ptr;
  sub_804BBF8((int)&v12);
  v2 = unlink(name);
  errnum = *__errno_location();
  *i = v11;
  sub_804BC2D((unsigned __int8 *)&v12);
  v5 = &loc_804CB0C;
  if ( !v2 )
    v5 = &loc_804CB53;
  dword_806B234 = (int)v5;
  sub_806184C(v4, v3);
  v6 = sub_805BA00(a1, 0, 3, name);
  v7 = gettext("warning: cannot remove: %s");
  error(0, errnum, v7, v6);
  if ( !v11 )
    off_806B3FC = i;
  free(ptr);
}
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD, _DWORD);
// 806B234: using guessed type int dword_806B234;
// 806B3FC: using guessed type int *off_806B3FC;
// 806C16A: using guessed type int dword_806C16A;

//----- (0804CB7E) --------------------------------------------------------
int __cdecl compar(const void *a1, const void *a2)
{
  return strcmp(*(const char **)a1, *(const char **)a2);
}

//----- (0804CBA8) --------------------------------------------------------
void sub_804CBA8()
{
  bool v0; // al
  void *v1; // eax
  const unsigned __int16 *v2; // ebx
  bool v3; // zf
  void *v4; // eax
  int v5; // eax
  char *v6; // ebx
  int v7; // [esp+0h] [ebp-38h]
  int c; // [esp+18h] [ebp-20h]
  unsigned int v9; // [esp+1Ch] [ebp-1Ch]
  int v10; // [esp+20h] [ebp-18h]
  char *s; // [esp+24h] [ebp-14h]
  size_t v12; // [esp+28h] [ebp-10h]
  char *v13; // [esp+2Ch] [ebp-Ch]

  for ( c = 0; (unsigned int)c <= 0xFF; ++c )
  {
    *(_BYTE *)(c + 134659274) = sub_804B550(c);
    *(_BYTE *)(c + 134659530) = ((*__ctype_b_loc())[c] & 0x4000) == 0;
    v0 = !((*__ctype_b_loc())[c] & 8) && (unsigned __int8)sub_804B550(c) ^ 1;
    *(_BYTE *)(c + 134659786) = v0;
    *(_BYTE *)(c + 134660042) = toupper(c);
  }
  v1 = &loc_804CC91;
  if ( !byte_806BCB3 )
    v1 = &loc_804CDDA;
  dword_806B298 = (int)v1;
  sub_8061601();
  for ( c = 0; (unsigned int)c <= 0xB; ++c )
  {
    s = nl_langinfo(c + 131086);
    v12 = strlen(s);
    v13 = (char *)sub_805E160(v12 + 1);
    (&off_806B390)[2 * c] = v13;
    dword_806B394[2 * c] = c + 1;
    v10 = 0;
    v9 = 0;
    dword_806B2AC = (int)&loc_804CD91;
    sub_8061591();
    do
    {
      v2 = *__ctype_b_loc();
      v7 = s[v9];
      v3 = (v2[(unsigned __int8)sub_804B53E(v7)] & 1) == 0;
      v4 = &loc_804CD5C;
      if ( !v3 )
        v4 = &loc_804CD8D;
      dword_806B270 = (int)v4;
      sub_80616F8();
      v5 = v10++;
      v6 = &v13[v5];
      v7 = s[v9];
      *v6 = byte_806BFCA[(unsigned __int8)sub_804B53E(v7)];
      ++v9;
    }
    while ( v9 < v12 );
    v13[v10] = 0;
  }
  qsort(&off_806B390, 0xCu, 8u, compar);
}
// 8061591: using guessed type int sub_8061591(void);
// 8061601: using guessed type int sub_8061601(void);
// 80616F8: using guessed type int sub_80616F8(void);
// 806B270: using guessed type int dword_806B270;
// 806B298: using guessed type int dword_806B298;
// 806B2AC: using guessed type int dword_806B2AC;
// 806B390: using guessed type char *off_806B390;
// 806B394: using guessed type int dword_806B394[];
// 806BCB3: using guessed type char byte_806BCB3;

//----- (0804CDE0) --------------------------------------------------------
unsigned int __usercall sub_804CDE0@<eax>(double st7_0@<st0>, int a1, char a2, char *a3)
{
  int v4; // edx
  int v5; // ecx
  int v6; // eax
  unsigned __int64 v7; // kr00_8
  void *v8; // ebx
  int v9; // esi
  char *v10; // eax
  void *v11; // ebx
  int v12; // esi
  char *v13; // eax
  void *v15; // eax
  void *v16; // ebx
  int v17; // esi
  char *v18; // eax
  int v19; // ebx
  int v20; // esi
  char *v21; // eax
  int v22; // ecx
  signed int v23; // [esp+20h] [ebp-38h]
  unsigned int v24; // [esp+24h] [ebp-34h]
  unsigned __int64 v25; // [esp+28h] [ebp-30h]
  int v26; // [esp+30h] [ebp-28h]
  int v27; // [esp+34h] [ebp-24h]
  char v28; // [esp+41h] [ebp-17h]
  unsigned int v29; // [esp+4Ch] [ebp-Ch]

  v29 = __readgsdword(0x14u);
  v23 = sub_805EC9C(st7_0, a3, 0, 10, (int)&v25, 0);
  if ( getrlimit64(7, &v26) )
  {
    v6 = 17;
  }
  else
  {
    v4 = v27;
    v6 = v26 - 3;
  }
  v24 = v6;
  if ( v23 )
  {
LABEL_12:
    v15 = &loc_804CF77;
    if ( v23 != 1 )
      v15 = &loc_804D00A;
    dword_806B33C = (int)v15;
    sub_8061194(v5, v4);
    v16 = sub_805BC38(st7_0, a3);
    v17 = *((_DWORD *)&longopts.name + 4 * a1);
    v18 = gettext("--%s argument %s too large");
    error(0, 0, v18, v17, v16);
    v19 = sub_8059366(v24, (int)&v28);
    v20 = *((_DWORD *)&longopts.name + 4 * a1);
    v21 = gettext("maximum --%s argument with current rlimit is %s");
    error(2, 0, v21, v20, v19);
    sub_805EB97(v22, (int)a3, st7_0, v23, a1, a2, (int)&longopts, (int)a3);
  }
  v7 = v25;
  v4 = v7 >> 32;
  dword_806B3F8 = v7;
  v5 = v25;
  if ( v25 != (unsigned int)v25 )
  {
    v23 = 1;
    goto LABEL_12;
  }
  if ( (unsigned int)dword_806B3F8 <= 1 )
  {
    v8 = sub_805BC38(st7_0, a3);
    v9 = *((_DWORD *)&longopts.name + 4 * a1);
    v10 = gettext("invalid --%s argument %s");
    error(0, 0, v10, v9, v8);
    v11 = sub_805BC38(st7_0, "2");
    v12 = *((_DWORD *)&longopts.name + 4 * a1);
    v13 = gettext("minimum --%s argument is %s");
    error(2, 0, v13, v12, v11);
  }
  if ( v24 < dword_806B3F8 )
  {
    v23 = 1;
    goto LABEL_12;
  }
  return __readgsdword(0x14u) ^ v29;
}
// 8049920: using guessed type int __cdecl getrlimit64(_DWORD, _DWORD);
// 8061194: using guessed type int __fastcall sub_8061194(_DWORD, _DWORD);
// 806B33C: using guessed type int dword_806B33C;

//----- (0804D03F) --------------------------------------------------------
int __usercall sub_804D03F@<eax>(double a1@<st0>, int a2, int a3, char *nptr)
{
  void *v4; // eax
  void *v5; // eax
  void *v6; // eax
  int result; // eax
  int v8; // [esp+38h] [ebp-30h]
  int v9; // [esp+3Ch] [ebp-2Ch]
  unsigned __int64 v10; // [esp+40h] [ebp-28h]

  v9 = sub_805EC9C(a1, nptr, (int)&v8, 10, (int)&v10, "EgGkKmMPtTYZ");
  if ( !v9 && (unsigned int)(*(char *)(v8 - 1) - 48) <= 9 )
  {
    if ( HIDWORD(v10) > 0x3FFFFF )
      v9 = 1;
    else
      v10 <<= 10;
  }
  if ( v9 == 2 && (unsigned int)(*(char *)(v8 - 1) - 48) <= 9 && !*(_BYTE *)(v8 + 1) )
  {
    v4 = &loc_804D118;
    if ( *(_BYTE *)v8 == 37 )
      v4 = &loc_804D12D;
    dword_806B2AC = (int)v4;
    if ( sub_8061591() == 98 )
      v9 = 0;
  }
  v5 = &loc_804D22C;
  if ( v9 )
    v5 = &loc_804D2CC;
  dword_806B2C0 = (int)v5;
  sub_8061521();
  if ( size > v10 )
  {
    dword_806B2E4 = (int)&loc_804D2F5;
    sub_806141F(a1);
  }
  size = v10;
  v6 = &loc_804D2A3;
  if ( v10 != (unsigned int)v10 )
    v6 = &loc_804D2C5;
  dword_806B234 = (int)v6;
  sub_806184C(v10, HIDWORD(v10));
  result = size;
  if ( 18 * dword_806B3F8 >= size )
    result = 18 * dword_806B3F8;
  size = result;
  return result;
}
// 806141F: using guessed type int __usercall sub_806141F@<eax>(double@<st0>);
// 8061521: using guessed type int sub_8061521(void);
// 8061591: using guessed type int sub_8061591(void);
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD, _DWORD);
// 806B234: using guessed type int dword_806B234;
// 806B2AC: using guessed type int dword_806B2AC;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B2E4: using guessed type int dword_806B2E4;

//----- (0804D2FD) --------------------------------------------------------
int __usercall sub_804D2FD@<eax>(double a1@<st0>, int a2, int a3, char *nptr)
{
  int v4; // ecx
  char *v6; // eax
  int v7; // [esp+28h] [ebp-10h]
  int v8; // [esp+2Ch] [ebp-Ch]

  v8 = sub_805E5E0(nptr, 0, 10, (int)&v7, &s);
  if ( v8 == 1 )
    return -1;
  if ( v8 )
    sub_805EB97(v4, (int)nptr, a1, v8, a2, a3, (int)&longopts, (int)nptr);
  if ( !v7 )
  {
    v6 = gettext("number in parallel must be nonzero");
    error(2, 0, v6);
  }
  return v7;
}

//----- (0804D3A2) --------------------------------------------------------
int sub_804D3A2()
{
  long double v0; // fst7
  int result; // eax
  unsigned int v2; // [esp+24h] [ebp-34h]
  unsigned int v3; // [esp+24h] [ebp-34h]
  double v4; // [esp+28h] [ebp-30h]
  double v5; // [esp+30h] [ebp-28h]
  double v6; // [esp+38h] [ebp-20h]
  unsigned __int64 v7; // [esp+40h] [ebp-18h]

  v2 = -1;
  if ( !getrlimit64(2, &v7) && v7 < 0xFFFFFFFF )
    v2 = v7;
  if ( !getrlimit64(9, &v7) && v7 < v2 )
    v2 = v7;
  v3 = v2 >> 1;
  if ( !getrlimit64(5, &v7) && 15 * (v7 >> 4) < v3 )
    v3 = 15 * (v7 >> 4);
  v4 = sub_8059C40();
  v5 = sub_8059B69();
  if ( v4 <= v5 / 8.0 )
    v0 = v5 / 8.0;
  else
    v0 = v4;
  v6 = v0;
  if ( (long double)v3 > v5 * 0.75 )
    v3 = (signed __int64)(v5 * 0.75);
  if ( (long double)v3 > v6 )
    v3 = (signed __int64)v6;
  result = v3;
  if ( 18 * dword_806B3F8 >= v3 )
    result = 18 * dword_806B3F8;
  return result;
}
// 8049920: using guessed type int __cdecl getrlimit64(_DWORD, _DWORD);

//----- (0804D571) --------------------------------------------------------
int __cdecl sub_804D571(int a1, unsigned int a2, int a3, unsigned int a4, int a5)
{
  int v5; // eax
  bool v6; // al
  int v7; // edx
  int v8; // ecx
  int v9; // eax
  bool v10; // zf
  void *v11; // eax
  int v12; // ebx
  char *v13; // eax
  int v14; // edx
  int v15; // ecx
  void *v17; // eax
  int v18; // [esp+18h] [ebp-80h]
  unsigned int i; // [esp+1Ch] [ebp-7Ch]
  unsigned int v20; // [esp+20h] [ebp-78h]
  unsigned int v21; // [esp+24h] [ebp-74h]
  signed __int64 v22; // [esp+28h] [ebp-70h]
  char v23; // [esp+30h] [ebp-68h]
  int v24; // [esp+40h] [ebp-58h]
  __int64 v25; // [esp+5Ch] [ebp-3Ch]

  v20 = a5 + 1;
  v18 = a5 + 2;
  for ( i = 0; i < a4; ++i )
  {
    if ( i >= a2 )
    {
      if ( !strcmp(*(const char **)(4 * i + a3), "-") )
        v9 = sub_806110B(0, (int)&v23);
      else
        v9 = sub_80610DC(*(_DWORD *)(4 * i + a3), (int)&v23);
      v6 = v9 != 0;
    }
    else
    {
      v5 = fileno(*(FILE **)(4 * i + a1));
      v6 = sub_806110B(v5, (int)&v23) != 0;
    }
    v10 = v6 == 0;
    v11 = &loc_804D651;
    if ( v10 )
      v11 = &loc_804D67A;
    dword_806B234 = (int)v11;
    sub_806184C(v8, v7);
    v12 = *(_DWORD *)(4 * i + a3);
    v13 = gettext("stat failed");
    sub_804B8B7(v15, v14, (int)v13, v12);
    if ( (v24 & 0xF000) == 0x8000 )
    {
      v22 = v25;
    }
    else
    {
      if ( size )
        return size;
      v22 = 0x20000LL;
    }
    if ( !dword_806C22A )
    {
      dword_806C22A = size;
      if ( !size )
        dword_806C22A = sub_804D3A2();
    }
    v21 = v20 * v22 + 1;
    v17 = &loc_804D722;
    if ( v22 != v21 / v20 )
      v17 = &loc_804D72F;
    dword_806B2AC = (int)v17;
    sub_8061591();
    if ( dword_806C22A - v18 <= v21 )
      return dword_806C22A;
    v18 += v21;
  }
  return v18;
}
// 8061591: using guessed type int sub_8061591(void);
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD, _DWORD);
// 806B234: using guessed type int dword_806B234;
// 806B2AC: using guessed type int dword_806B2AC;
// 806C22A: using guessed type int dword_806C22A;

//----- (0804D758) --------------------------------------------------------
int __cdecl sub_804D758(int a1, int a2, size_t size)
{
  int result; // eax
  size_t sizea; // [esp+28h] [ebp+10h]

  while ( 1 )
  {
    sizea = (size & 0xFFFFFFF0) + 16;
    *(_DWORD *)a1 = malloc(sizea);
    if ( *(_DWORD *)a1 )
      break;
    size = sizea >> 1;
    if ( a2 + 1 >= size )
      sub_805E306();
  }
  *(_DWORD *)(a1 + 20) = a2;
  *(_DWORD *)(a1 + 12) = sizea;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a1 + 16);
  result = a1;
  *(_BYTE *)(a1 + 24) = 0;
  return result;
}

//----- (0804D7DE) --------------------------------------------------------
int __cdecl sub_804D7DE(_DWORD *a1)
{
  return *a1 + a1[3];
}

//----- (0804D7F9) --------------------------------------------------------
int __cdecl sub_804D7F9(int *a1, int *a2)
{
  int v2; // ST0C_4
  int v3; // ST08_4
  int v4; // ST10_4

  v2 = a1[1] - 1 + *a1;
  v3 = *a2;
  v4 = a2[1];
  dword_806B2D0 = (int (__cdecl *)(_DWORD))sub_804D940;
  if ( dword_806B3F4 != 128 )
    dword_806B2D0 = (int (__cdecl *)(_DWORD))sub_804D8E2;
  return dword_806B2D0(a1);
}
// 804D8E2: using guessed type int sub_804D8E2();
// 804D940: using guessed type int sub_804D940();
// 806B2D0: using guessed type int (__cdecl *dword_806B2D0)(_DWORD);
// 806B3F4: using guessed type int dword_806B3F4;

//----- (0804D85A) --------------------------------------------------------
int __cdecl sub_804D85A(int a1)
{
  dword_806B2D0 = (int (__cdecl *)(_DWORD))sub_804D871;
  return ((int (__cdecl *)(int))sub_804D871)(a1);
}
// 804D871: using guessed type int sub_804D871();
// 806B2D0: using guessed type int (__cdecl *dword_806B2D0)(_DWORD);

//----- (0804DB11) --------------------------------------------------------
unsigned __int8 *__cdecl sub_804DB11(int a1, int a2)
{
  int v2; // ecx
  int v3; // eax
  void *v4; // eax
  void *v5; // eax
  bool v6; // zf
  int v7; // edx
  int v8; // ecx
  void *v9; // eax
  unsigned __int8 *result; // eax
  unsigned __int8 *v11; // [esp+4h] [ebp-10h]
  int v12; // [esp+8h] [ebp-Ch]
  unsigned __int8 *v13; // [esp+Ch] [ebp-8h]
  int v14; // [esp+10h] [ebp-4h]

  v11 = *(unsigned __int8 **)a1;
  v13 = (unsigned __int8 *)(*(_DWORD *)(a1 + 4) - 1 + *(_DWORD *)a1);
  v12 = *(_DWORD *)(a2 + 8);
  v14 = *(_DWORD *)(a2 + 12);
  if ( !v14 )
    ++v12;
  if ( dword_806B3F4 == 128 )
  {
    if ( v11 < v13 )
    {
      v4 = &loc_804DC56;
      if ( v12 )
        v4 = &loc_804DBB2;
      dword_806B220 = (int)v4;
      sub_80618C4(v2);
    }
  }
  else
  {
    while ( v11 < v13 )
    {
      v3 = v12--;
      if ( !v3 )
        break;
      while ( v11 < v13 && (char)*v11 != dword_806B3F4 )
        ++v11;
      if ( v11 < v13 && (v12 || v14) )
        ++v11;
    }
  }
  v5 = &loc_804DC75;
  if ( !v14 )
    v5 = &loc_804DCD9;
  dword_806B298 = (int)v5;
  sub_8061601();
  if ( *(_BYTE *)(a2 + 25) && v11 < v13 )
  {
    v6 = byte_806BCCA[(unsigned __int8)sub_804B53E(*v11)] == 0;
    v9 = &loc_804DCC6;
    if ( !v6 )
      v9 = &loc_804DC82;
    dword_806B234 = (int)v9;
    sub_806184C(v8, v7);
  }
  result = v13;
  if ( &v11[v14] <= v13 )
    result = &v11[v14];
  return result;
}
// 804DB11: could not find valid save-restore pair for ebx
// 8061601: using guessed type int sub_8061601(void);
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD, _DWORD);
// 80618C4: using guessed type int __fastcall sub_80618C4(_DWORD);
// 806B220: using guessed type int dword_806B220;
// 806B234: using guessed type int dword_806B234;
// 806B298: using guessed type int dword_806B298;
// 806B3F4: using guessed type int dword_806B3F4;

//----- (0804DCDE) --------------------------------------------------------
int __usercall sub_804DCDE@<eax>(double a1@<st0>, int a2, FILE *stream, int a4)
{
  char *v4; // eax
  char *v5; // eax
  int v6; // ecx
  bool v7; // zf
  int v8; // edx
  int v9; // ecx
  void *v10; // eax
  int result; // eax
  char *v12; // eax
  size_t v13; // eax
  unsigned __int8 *v14; // eax
  void *v15; // eax
  int v16; // eax
  int v17; // eax
  unsigned int v18; // [esp+8h] [ebp-50h]
  char v19; // [esp+1Bh] [ebp-3Dh]
  int v20; // [esp+1Ch] [ebp-3Ch]
  size_t v21; // [esp+20h] [ebp-38h]
  void *ptr; // [esp+24h] [ebp-34h]
  int *v23; // [esp+28h] [ebp-30h]
  unsigned int v24; // [esp+2Ch] [ebp-2Ch]
  char *v25; // [esp+30h] [ebp-28h]
  char *v26; // [esp+34h] [ebp-24h]
  int *v27; // [esp+38h] [ebp-20h]
  int v28; // [esp+3Ch] [ebp-1Ch]
  int v29; // [esp+40h] [ebp-18h]
  size_t n; // [esp+44h] [ebp-14h]
  size_t v31; // [esp+48h] [ebp-10h]
  unsigned __int8 *v32; // [esp+4Ch] [ebp-Ch]

  v27 = (int *)dword_806C0DE;
  v19 = byte_806B370;
  v28 = *(_DWORD *)(a2 + 20);
  v21 = dword_806B3F0 - 18;
  if ( *(_BYTE *)(a2 + 24) )
  {
    dword_806B25C = (int)&loc_804E102;
    sub_806176A();
  }
  if ( *(_DWORD *)(a2 + 4) != *(_DWORD *)(a2 + 16) )
  {
    memmove(
      *(void **)a2,
      (const void *)(*(_DWORD *)(a2 + 4) - *(_DWORD *)(a2 + 16) + *(_DWORD *)a2),
      *(_DWORD *)(a2 + 16));
    *(_DWORD *)(a2 + 4) = *(_DWORD *)(a2 + 16);
    *(_DWORD *)(a2 + 8) = 0;
  }
  ptr = (void *)(*(_DWORD *)a2 + *(_DWORD *)(a2 + 4));
  v29 = sub_804D7DE((_DWORD *)a2);
  v23 = (int *)(-16 * *(_DWORD *)(a2 + 8) + v29);
  v24 = v29 - v28 * *(_DWORD *)(a2 + 8) - (_DWORD)ptr;
  if ( *(_DWORD *)(a2 + 8) )
    v4 = (char *)(*v23 + v23[1]);
  else
    v4 = *(char **)a2;
  v25 = v4;
  while ( v28 + 1 < v24 )
  {
    n = (v24 - 1) / (v28 + 1);
    v18 = (v24 - 1) / (v28 + 1);
    v31 = fread_unlocked(ptr, 1u, v18, stream);
    v26 = (char *)ptr + v31;
    v24 -= v31;
    if ( v31 != n )
    {
      if ( ferror_unlocked(stream) )
      {
        v5 = gettext("read failed");
        sub_804B8B7(v6, a4, (int)v5, a4);
      }
      v7 = feof_unlocked(stream) == 0;
      v10 = &loc_804DEAC;
      if ( v7 )
        v10 = &loc_804DEF1;
      dword_806B33C = (int)v10;
      sub_8061194(v9, v8);
      *(_BYTE *)(a2 + 24) = 1;
      if ( *(char **)a2 == v26 )
        return 0;
      if ( v25 != v26 && *(v26 - 1) != v19 )
      {
        v12 = v26++;
        *v12 = v19;
      }
    }
    while ( 1 )
    {
      v32 = (unsigned __int8 *)memchr(ptr, v19, v26 - (_BYTE *)ptr);
      if ( !v32 )
        break;
      *v32 = 0;
      ptr = v32 + 1;
      v23 -= 4;
      *v23 = (int)v25;
      v23[1] = (_BYTE *)ptr - v25;
      v13 = v21;
      if ( v23[1] >= v21 )
        v13 = v23[1];
      v21 = v13;
      v24 -= v28;
      if ( v27 )
      {
        if ( v27[2] == -1 )
          v14 = v32;
        else
          v14 = sub_804DB11((int)v23, (int)v27);
        v23[3] = (int)v14;
        v15 = &loc_804DF8F;
        if ( *v27 == -1 )
          v15 = &loc_804DFA9;
        dword_806B298 = (int)v15;
        sub_8061601();
        v16 = sub_804D7F9(v23, v27);
        v23[2] = v16;
      }
      v25 = (char *)ptr;
    }
    ptr = v26;
    if ( *(_BYTE *)(a2 + 24) )
    {
      dword_806B2C0 = (int)&loc_804E04F;
      sub_8061521();
    }
  }
  *(_DWORD *)(a2 + 4) = (char *)ptr - *(_DWORD *)a2;
  v17 = sub_804D7DE((_DWORD *)a2);
  *(_DWORD *)(a2 + 8) = (v17 - (signed int)v23) >> 4;
  if ( *(_DWORD *)(a2 + 8) )
  {
    *(_DWORD *)(a2 + 16) = (_BYTE *)ptr - v25;
    dword_806B3F0 = v21 + 18;
    result = 1;
  }
  else
  {
    v20 = *(_DWORD *)(a2 + 12) >> 4;
    *(_DWORD *)a2 = sub_805E059(*(_DWORD *)a2, (unsigned int *)&v20, 0x10u);
    *(_DWORD *)(a2 + 12) = 16 * v20;
    dword_806B2E4 = (int)&loc_804DD8B;
    result = sub_806141F(a1);
  }
  return result;
}
// 8061194: using guessed type int __fastcall sub_8061194(_DWORD, _DWORD);
// 806141F: using guessed type int __usercall sub_806141F@<eax>(double@<st0>);
// 8061521: using guessed type int sub_8061521(void);
// 8061601: using guessed type int sub_8061601(void);
// 806176A: using guessed type int sub_806176A(void);
// 806B25C: using guessed type int dword_806B25C;
// 806B298: using guessed type int dword_806B298;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B2E4: using guessed type int dword_806B2E4;
// 806B33C: using guessed type int dword_806B33C;
// 806B370: using guessed type char byte_806B370;
// 806C0DE: using guessed type int dword_806C0DE;

//----- (0804E109) --------------------------------------------------------
int __cdecl sub_804E109(char **a1)
{
  int v1; // ecx
  int v2; // ecx
  int v3; // edx
  char *v4; // eax
  void *v5; // eax
  unsigned __int8 v7; // [esp+9h] [ebp-7h]
  unsigned __int8 v8; // [esp+Bh] [ebp-5h]
  char *v9; // [esp+Ch] [ebp-4h]

  v9 = *a1;
  v7 = 0;
  dword_806B318 = (int)&loc_804E166;
  sub_8061268(v1);
  do
  {
    if ( v7 < v8 )
      v7 = v8;
    v3 = *v9;
    if ( v3 == dword_806BCAE )
      ++v9;
    v4 = v9++;
    v8 = *v4;
  }
  while ( (unsigned int)(unsigned __int8)*v4 - 48 <= 9 );
  v5 = &loc_804E1A0;
  if ( v3 != dword_806BCAE )
    v5 = &loc_804E1B1;
  dword_806B20C = (int)v5;
  sub_8061930(v2);
  *a1 = v9 - 2;
  return v7;
}
// 8061268: using guessed type int __fastcall sub_8061268(_DWORD);
// 8061930: using guessed type int __fastcall sub_8061930(_DWORD);
// 806B20C: using guessed type int dword_806B20C;
// 806B318: using guessed type int dword_806B318;
// 806BCAE: using guessed type int dword_806BCAE;

//----- (0804E22A) --------------------------------------------------------
int __cdecl sub_804E22A(_BYTE *a1)
{
  int result; // eax
  bool v2; // [esp+9h] [ebp-Bh]
  unsigned __int8 *v3; // [esp+Ch] [ebp-8h]
  int v4; // [esp+10h] [ebp-4h]

  v2 = *a1 == 45;
  v3 = &a1[v2];
  if ( (unsigned __int8)sub_804E109((char **)&v3) <= 0x30u )
    return 0;
  v4 = byte_8063208[*v3];
  if ( v2 )
    result = -v4;
  else
    result = v4;
  return result;
}

//----- (0804E291) --------------------------------------------------------
int __usercall sub_804E291@<eax>(double a1@<st0>, unsigned __int8 *a2, unsigned __int8 *a3)
{
  int v3; // ebx
  int v4; // eax
  int v5; // ecx
  int result; // eax

  while ( byte_806BCCA[(unsigned __int8)sub_804B53E(*a2)] )
    ++a2;
  while ( byte_806BCCA[(unsigned __int8)sub_804B53E(*a3)] )
    ++a3;
  v3 = sub_804E22A(a2);
  v4 = sub_804E22A(a3);
  if ( v3 == v4 )
    result = sub_805D8A7(a1, v5, a2, a3, dword_806BCAA, dword_806BCAE);
  else
    result = v3 - v4;
  return result;
}
// 806BCAA: using guessed type int dword_806BCAA;
// 806BCAE: using guessed type int dword_806BCAE;

//----- (0804E337) --------------------------------------------------------
int __usercall sub_804E337@<eax>(double a1@<st0>, unsigned __int8 *a2, unsigned __int8 *a3)
{
  int v3; // edx
  int v4; // ecx
  int v5; // ecx

  while ( byte_806BCCA[(unsigned __int8)sub_804B53E(*a2)] )
    ++a2;
  dword_806B234 = (int)&loc_804E37D;
  sub_806184C(v4, v3);
  do
    ++a3;
  while ( byte_806BCCA[(unsigned __int8)sub_804B53E(*a3)] );
  return sub_805D8A7(a1, v5, a2, a3, dword_806BCAA, dword_806BCAE);
}
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD, _DWORD);
// 806B234: using guessed type int dword_806B234;
// 806BCAA: using guessed type int dword_806BCAA;
// 806BCAE: using guessed type int dword_806BCAE;

//----- (0804E3C3) --------------------------------------------------------
int __cdecl sub_804E3C3(int a1, int a2)
{
  _TBYTE s; // [esp+10h] [ebp-28h]
  _TBYTE s2; // [esp+20h] [ebp-18h]

  memset(&s, 0, 0xCu);
  *(long double *)&s = strtold(a1, 0);
  memset(&s2, 0, 0xCu);
  *(long double *)&s2 = strtold(a2, 0);
  return memcmp(&s, &s2, 0xCu);
}
// 80498F0: using guessed type double __cdecl strtold(_DWORD, _DWORD);

//----- (0804E447) --------------------------------------------------------
int __cdecl sub_804E447(int a1, int a2)
{
  int v2; // edx
  int v3; // ecx
  int result; // eax
  void *v5; // eax
  long double v6; // fst7
  int v7; // [esp+18h] [ebp-30h]
  int v8; // [esp+1Ch] [ebp-2Ch]
  long double v9; // [esp+20h] [ebp-28h]
  long double v10; // [esp+30h] [ebp-18h]

  v9 = strtold(a1, &v7);
  v10 = strtold(a2, &v8);
  if ( a1 == v7 )
  {
    if ( a2 == v8 )
    {
      dword_806B284 = (int)&loc_804E4A8;
      sub_8061671(v3, v2);
    }
    result = -1;
  }
  else if ( a2 == v8 )
  {
    result = 1;
  }
  else if ( v10 <= v9 )
  {
    if ( v9 <= v10 )
    {
      v5 = &loc_804E520;
      if ( v10 == v9 )
        v5 = &loc_804E5A4;
      dword_806B20C = (int)v5;
      sub_8061930(v3);
      dword_806B25C = (int)&loc_804E59D;
      sub_806176A();
      v6 = v9;
      dword_806B248 = (int)&loc_804E596;
      sub_80617DA(*(double *)&v6);
      result = sub_804E3C3(a1, a2);
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}
// 804E447: could not find valid save-restore pair for ebx
// 80498F0: using guessed type double __cdecl strtold(_DWORD, _DWORD);
// 8061671: using guessed type int __fastcall sub_8061671(_DWORD, _DWORD);
// 806176A: using guessed type int sub_806176A(void);
// 80617DA: using guessed type int __usercall sub_80617DA@<eax>(double@<st0>);
// 8061930: using guessed type int __fastcall sub_8061930(_DWORD);
// 806B20C: using guessed type int dword_806B20C;
// 806B248: using guessed type int dword_806B248;
// 806B25C: using guessed type int dword_806B25C;
// 806B284: using guessed type int dword_806B284;

//----- (0804E5AB) --------------------------------------------------------
int __usercall sub_804E5AB@<eax>(double a1@<st0>, unsigned __int8 *a2, unsigned __int8 **a3)
{
  bool v3; // zf
  void *v4; // eax
  int v5; // eax
  unsigned __int8 v6; // al
  unsigned __int8 v7; // bl
  unsigned __int8 v8; // al
  unsigned __int8 v9; // bl
  unsigned int v11; // [esp+10h] [ebp-18h]
  unsigned int v12; // [esp+14h] [ebp-14h]
  unsigned __int8 *v13; // [esp+18h] [ebp-10h]
  unsigned __int8 *i; // [esp+1Ch] [ebp-Ch]
  unsigned int v15; // [esp+20h] [ebp-8h]

  v11 = 0;
  v12 = 12;
  v3 = byte_806BCCA[(unsigned __int8)sub_804B53E(*a2)] == 0;
  v4 = &loc_804E5FE;
  if ( !v3 )
    v4 = &loc_804E5C2;
  dword_806B270 = (int)v4;
  sub_80616F8();
  do
  {
    v15 = (v11 + v12) >> 1;
    v13 = a2;
    for ( i = (unsigned __int8 *)(&off_806B390)[2 * v15]; ; ++i )
    {
      if ( !*i )
      {
        if ( a3 )
          *a3 = v13;
        v5 = dword_806B394[2 * v15];
        dword_806B2E4 = (int)&loc_804E702;
        sub_806141F(a1);
      }
      v6 = sub_804B53E(*v13);
      v7 = sub_804B53E(byte_806BFCA[v6]);
      if ( v7 < (unsigned __int8)sub_804B53E(*i) )
      {
        v12 = (v11 + v12) >> 1;
        goto LABEL_14;
      }
      v8 = sub_804B53E(*v13);
      v9 = sub_804B53E(byte_806BFCA[v8]);
      if ( v9 > (unsigned __int8)sub_804B53E(*i) )
        break;
      ++v13;
    }
    v11 = v15 + 1;
LABEL_14:
    ;
  }
  while ( v11 < v12 );
  return 0;
}
// 806141F: using guessed type int __usercall sub_806141F@<eax>(double@<st0>);
// 80616F8: using guessed type int sub_80616F8(void);
// 806B270: using guessed type int dword_806B270;
// 806B2E4: using guessed type int dword_806B2E4;
// 806B390: using guessed type char *off_806B390;
// 806B394: using guessed type int dword_806B394[];

//----- (0804E708) --------------------------------------------------------
int __usercall __noreturn sub_804E708@<eax>(double a1@<st0>, int a2)
{
  char *v2; // eax
  int v3; // ecx
  bool v4; // zf
  void *v5; // eax
  char *v6; // eax
  int v7; // ecx
  char *v8; // eax
  int v9; // ecx
  int v10; // ecx
  int (*v11)(); // eax
  char *v13; // [esp+18h] [ebp-20h]
  char ptr; // [esp+1Ch] [ebp-1Ch]
  unsigned int v15; // [esp+2Ch] [ebp-Ch]

  v15 = __readgsdword(0x14u);
  v2 = sub_805BF48(a1, a2, 0x10u);
  v13 = v2;
  v4 = v2 == 0;
  v5 = &loc_804E754;
  if ( !v4 )
    v5 = &loc_804E76F;
  dword_806B220 = (int)v5;
  sub_80618C4(v3);
  v6 = gettext("open failed");
  sub_804B8B7(v7, a2, (int)v6, a2);
  sub_805C21B((int)v13, &ptr, 0x10u);
  if ( sub_805C27C(v13) )
  {
    v8 = gettext("close failed");
    sub_804B8B7(v9, a2, (int)v8, a2);
  }
  sub_8055FD2(&unk_806C18A);
  sub_8056377(v10, a1, &ptr, 0x10u, (int)&unk_806C18A);
  v11 = (int (*)())&loc_804E7FF;
  if ( __readgsdword(0x14u) == v15 )
    v11 = sub_804E804;
  dword_806B2E4 = (int)v11;
  return sub_806141F(a1);
}
// 804E708: could not find valid save-restore pair for ebx
// 804E804: using guessed type int sub_804E804();
// 806141F: using guessed type int __usercall sub_806141F@<eax>(double@<st0>);
// 80618C4: using guessed type int __fastcall sub_80618C4(_DWORD);
// 806B220: using guessed type int dword_806B220;
// 806B2E4: using guessed type int dword_806B2E4;

//----- (0804E804) --------------------------------------------------------
#error "804E805: positive sp value has been found (funcsize=0)"

//----- (0804E806) --------------------------------------------------------
size_t __usercall sub_804E806@<eax>(double a1@<st0>, char *dest, char *src, size_t n)
{
  int v4; // eax
  char *v5; // ebx
  int *v6; // eax
  char *v7; // eax
  void *v8; // ebx
  char *v9; // eax
  void *v11; // [esp+Ch] [ebp-1Ch]
  size_t v12; // [esp+1Ch] [ebp-Ch]

  *__errno_location() = 0;
  v12 = strxfrm(dest, src, n);
  v4 = *__errno_location();
  dword_806B2D0 = (int (__cdecl *)(_DWORD))&loc_804E8E3;
  if ( !v4 )
    return dword_806B2D0(dest);
  v5 = gettext("string transformation failed");
  v6 = __errno_location();
  error(0, *v6, v5);
  v7 = gettext("set LC_ALL='C' to work around the problem");
  error(0, 0, v7);
  v8 = sub_805B82A(a1, 0, 8, src);
  v9 = gettext("the untransformed string was %s");
  v11 = v8;
  error(2, 0, v9, v8);
  return v12;
}
// 806B2D0: using guessed type int (__cdecl *dword_806B2D0)(_DWORD);

//----- (0804E8EC) --------------------------------------------------------
int __usercall sub_804E8EC@<eax>(double a1@<st0>, int a2, size_t a3, int a4, size_t a5)
{
  int v5; // ecx
  size_t v6; // eax
  size_t v7; // eax
  void *v8; // eax
  char *v9; // eax
  size_t v10; // eax
  size_t v11; // eax
  size_t v12; // eax
  int v13; // ecx
  size_t v14; // eax
  int v15; // ecx
  size_t v16; // eax
  char *s; // [esp+18h] [ebp-1150h]
  char *src; // [esp+1Ch] [ebp-114Ch]
  bool v20; // [esp+2Bh] [ebp-113Dh]
  int v21; // [esp+2Ch] [ebp-113Ch]
  char *dest; // [esp+30h] [ebp-1138h]
  size_t size; // [esp+34h] [ebp-1134h]
  void *ptr; // [esp+38h] [ebp-1130h]
  int v25; // [esp+3Ch] [ebp-112Ch]
  char *v26; // [esp+40h] [ebp-1128h]
  char *v27; // [esp+44h] [ebp-1124h]
  size_t v28; // [esp+48h] [ebp-1120h]
  size_t n; // [esp+4Ch] [ebp-111Ch]
  size_t v30; // [esp+50h] [ebp-1118h]
  char s1; // [esp+54h] [ebp-1114h]
  int v32; // [esp+64h] [ebp-1104h]
  int v33; // [esp+74h] [ebp-10F4h]
  char v34; // [esp+110h] [ebp-1058h]
  char v35; // [esp+1ACh] [ebp-FBCh]
  unsigned int v36; // [esp+114Ch] [ebp-1Ch]

  src = (char *)a2;
  s = (char *)a4;
  v36 = __readgsdword(0x14u);
  v21 = 0;
  dest = &v35;
  size = 4000;
  ptr = 0;
  qmemcpy(&v34, &unk_806C18A, 0x9Cu);
  qmemcpy(&v33, &v34, 0x9Cu);
  v5 = 0;
  if ( byte_806BCB2 )
  {
    v26 = &src[a3];
    v27 = &s[a5];
    while ( 1 )
    {
      v28 = 3 * (a5 + a3) + 2;
      if ( size < v28 )
      {
        v6 = v28;
        if ( 3 * size >> 1 >= v28 )
          v6 = 3 * size >> 1;
        size = v6;
        free(ptr);
        ptr = malloc(size);
        dest = (char *)ptr;
        if ( !ptr )
        {
          dest = &v35;
          size = 4000;
        }
      }
      if ( src >= v26 )
        v7 = 0;
      else
        v7 = sub_804E806(a1, dest, src, size) + 1;
      n = v7;
      v20 = v7 <= size;
      if ( s >= v27 )
      {
        v10 = 0;
      }
      else
      {
        v8 = &loc_804EAB9;
        if ( !v20 )
          v8 = &loc_804EAC9;
        dword_806B270 = (int)v8;
        sub_80616F8();
        if ( v20 )
          v9 = &dest[n];
        else
          v9 = 0;
        v10 = sub_804E806(a1, v9, s, size - n) + 1;
      }
      v30 = v10;
      if ( v20 != 1 || n + v30 > size )
      {
        size = n + v30;
        if ( n + v30 <= 0x55555554 )
          size = 3 * size >> 1;
        free(ptr);
        ptr = (void *)sub_805E160(size);
        dest = (char *)ptr;
        if ( src < v26 )
          strxfrm(dest, src, n);
        if ( s < v27 )
          strxfrm(&dest[n], s, v30);
      }
      if ( src < v26 )
      {
        v11 = strlen(src);
        src += v11 + 1;
      }
      if ( s < v27 )
      {
        v12 = strlen(s);
        s += v12 + 1;
      }
      if ( src >= v26 && s >= v27 )
      {
        a3 = n;
        src = dest;
        a5 = v30;
        s = &dest[n];
        dword_806B234 = (int)&loc_804ED8B;
        sub_806184C(v5, dest);
      }
      sub_8056377(v5, a1, dest, n, (int)&v33);
      sub_8056377(v13, a1, &dest[n], v30, (int)&v34);
      if ( !v21 )
      {
        v14 = n;
        if ( v30 <= n )
          v14 = v30;
        v21 = memcmp(dest, &dest[n], v14);
        if ( !v21 )
          v21 = (n > v30) - (n < v30);
      }
    }
  }
  sub_8056377(0, a1, src, a3, (int)&v33);
  sub_8056098(a1, &v33, &s1);
  sub_8056377(v15, a1, s, a5, (int)&v34);
  sub_8056098(a1, (int *)&v34, &v32);
  v25 = memcmp(&s1, &v32, 0x10u);
  if ( !v25 )
  {
    if ( !v21 )
    {
      v16 = a3;
      if ( a5 <= a3 )
        v16 = a5;
      v21 = memcmp(src, s, v16);
      if ( !v21 )
        v21 = (a3 > a5) - (a3 < a5);
    }
    v25 = v21;
  }
  free(ptr);
  return v25;
}
// 80616F8: using guessed type int sub_80616F8(void);
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD, _DWORD);
// 806B234: using guessed type int dword_806B234;
// 806B270: using guessed type int dword_806B270;
// 806BCB2: using guessed type char byte_806BCB2;

//----- (0804EED4) --------------------------------------------------------
int __usercall sub_804EED4@<eax>(double a1@<st0>, char *a2, unsigned int a3)
{
  char *v3; // eax
  int v5; // [esp+1Ch] [ebp-Ch]

  v5 = sub_8059490(a1, a2, a3 - (_DWORD)a2, 0);
  dword_806B304 = (int)&loc_804EF2C;
  sub_8061308();
  do
  {
    v3 = a2++;
    v5 += *v3 == 9;
  }
  while ( (unsigned int)a2 < a3 );
  return v5;
}
// 8061308: using guessed type int sub_8061308(void);
// 806B304: using guessed type int dword_806B304;

//----- (0804EF39) --------------------------------------------------------
int __cdecl sub_804EF39(int a1, int a2)
{
  void *v2; // eax
  char *v3; // eax
  int result; // eax

  v2 = &loc_804EF73;
  if ( a1 )
    v2 = &loc_804EF41;
  dword_806B25C = (int)v2;
  sub_806176A();
  if ( a2 )
  {
    do
    {
      putchar_unlocked(95);
      --a2;
    }
    while ( a2 );
    result = putchar_unlocked(10);
  }
  else
  {
    v3 = gettext("^ no match for key\n");
    result = printf(v3);
  }
  return result;
}
// 806176A: using guessed type int sub_806176A(void);
// 806B25C: using guessed type int dword_806B25C;

//----- (0804EFB3) --------------------------------------------------------
int __cdecl sub_804EFB3(_BYTE *a1)
{
  return a1[26] || a1[28] || a1[29];
}

//----- (0804EFE8) --------------------------------------------------------
int __usercall sub_804EFE8@<eax>(int a1@<ecx>, long double a2@<st0>, int *a3, int a4)
{
  int v4; // edx
  void *v5; // eax
  void *v6; // eax
  void *v7; // eax
  int v8; // ecx
  void *v9; // eax
  signed int v10; // eax
  _BOOL4 v11; // eax
  unsigned __int8 v13; // [esp+11h] [ebp-37h]
  unsigned __int8 *v14; // [esp+14h] [ebp-34h]
  unsigned __int8 *v15; // [esp+18h] [ebp-30h]
  unsigned __int8 *v16; // [esp+1Ch] [ebp-2Ch]
  unsigned __int8 *v17; // [esp+20h] [ebp-28h]
  char *v18; // [esp+24h] [ebp-24h]
  int v19; // [esp+28h] [ebp-20h]
  int v20; // [esp+2Ch] [ebp-1Ch]

  v18 = (char *)*a3;
  v16 = (unsigned __int8 *)v18;
  v4 = a3[1] - 1;
  v17 = (unsigned __int8 *)&v18[v4];
  if ( a4 )
  {
    if ( *(_DWORD *)a4 != -1 )
      v16 = (unsigned __int8 *)sub_804D7F9(a3, (int *)a4);
    if ( *(_DWORD *)(a4 + 8) != -1 )
      v17 = sub_804DB11((int)a3, a4);
    if ( *(_BYTE *)(a4 + 24) )
    {
      v5 = &loc_804F084;
      if ( *(_DWORD *)a4 == -1 )
        v5 = &loc_804F0BB;
      dword_806B20C = (int)v5;
      sub_8061930(a1);
    }
    v6 = &loc_804F0A8;
    if ( *(_BYTE *)(a4 + 30) )
      v6 = &loc_804F0BB;
    dword_806B284 = (int)v6;
    sub_8061671(a1, v4);
    if ( (unsigned __int8)sub_804EFB3((_BYTE *)a4) )
    {
      v13 = *v17;
      *v17 = 0;
      while ( byte_806BCCA[(unsigned __int8)sub_804B53E(*v16)] )
        ++v16;
      v14 = v16;
      if ( v17 >= v16 )
      {
        if ( *(_BYTE *)(a4 + 30) )
        {
          sub_804E5AB(*(double *)&a2, v16, &v14);
        }
        else if ( *(_BYTE *)(a4 + 28) )
        {
          a2 = strtold(v16, &v14);
          __asm { fstp    tbyte ptr [ebp+var_18] }
        }
        else
        {
          v7 = &loc_804F173;
          if ( *(_BYTE *)(a4 + 26) )
            v7 = &loc_804F182;
          dword_806B270 = (int)v7;
          sub_80616F8();
          if ( *(_BYTE *)(a4 + 29) )
          {
            if ( v16 >= v17 )
            {
              v10 = 0;
            }
            else
            {
              v9 = &loc_804F1AD;
              if ( *v16 != 45 )
                v9 = &loc_804F1B4;
              dword_806B20C = (int)v9;
              sub_8061930(v8);
              v10 = 1;
            }
            v15 = &v16[v10];
            if ( (unsigned __int8)sub_804E109((char **)&v15) > 0x2Fu )
            {
              v11 = *(_BYTE *)(a4 + 29) && byte_8063208[*v15];
              v14 = &v15[v11];
            }
          }
          else
          {
            v14 = v17;
          }
        }
      }
      else
      {
        v14 = v17;
      }
      *v17 = v13;
      v17 = v14;
    }
  }
  v19 = sub_804EED4(*(double *)&a2, v18, (unsigned int)v16);
  v20 = sub_804EED4(*(double *)&a2, (char *)v16, (unsigned int)v17);
  return sub_804EF39(v19, v20);
}
// 804F147: inconsistent fpu stack
// 804EFE8: could not find valid save-restore pair for ebx
// 80498F0: using guessed type double __cdecl strtold(_DWORD, _DWORD);
// 8061671: using guessed type int __fastcall sub_8061671(_DWORD, _DWORD);
// 80616F8: using guessed type int sub_80616F8(void);
// 8061930: using guessed type int __fastcall sub_8061930(_DWORD);
// 806B20C: using guessed type int dword_806B20C;
// 806B270: using guessed type int dword_806B270;
// 806B284: using guessed type int dword_806B284;

//----- (0804F265) --------------------------------------------------------
int __usercall sub_804F265@<eax>(int a1@<ecx>, long double a2@<st0>, int *a3)
{
  int result; // eax
  int v4; // [esp+1Ch] [ebp-Ch]

  v4 = dword_806C0DE;
  while ( 1 )
  {
    result = sub_804EFE8(a1, a2, a3, v4);
    if ( !v4 )
      break;
    v4 = *(_DWORD *)(v4 + 36);
    if ( !v4 )
    {
      result = (unsigned __int8)byte_806C0DC ^ 1;
      if ( byte_806C0DC == 1 )
        break;
      result = (unsigned __int8)byte_806C0DB ^ 1;
      if ( byte_806C0DB == 1 )
        break;
    }
  }
  return result;
}
// 806C0DB: using guessed type char byte_806C0DB;
// 806C0DC: using guessed type char byte_806C0DC;
// 806C0DE: using guessed type int dword_806C0DE;

//----- (0804F2BD) --------------------------------------------------------
unsigned int __cdecl sub_804F2BD(int a1)
{
  _DWORD *i; // [esp+0h] [ebp-10h]
  unsigned int v3; // [esp+4h] [ebp-Ch]
  _DWORD *v4; // [esp+8h] [ebp-8h]
  unsigned int j; // [esp+Ch] [ebp-4h]

  v3 = 0;
  for ( i = *(_DWORD **)a1; *(_DWORD *)(a1 + 4) > (unsigned int)i; i += 2 )
  {
    if ( *i )
    {
      v4 = i;
      for ( j = 1; ; ++j )
      {
        v4 = (_DWORD *)v4[1];
        if ( !v4 )
          break;
      }
      if ( j > v3 )
        v3 = j;
    }
  }
  return v3;
}

//----- (0804F4A9) --------------------------------------------------------
_BYTE *__usercall sub_804F4A9@<eax>(int a1@<edx>, int a2@<ecx>, int a3, _BYTE *a4)
{
  void *v4; // eax
  int v5; // ecx
  _BYTE *v6; // eax
  void *v7; // eax
  int v8; // ecx
  _BYTE *v9; // eax
  _BYTE *v10; // eax
  _BYTE *v11; // eax
  _BYTE *v12; // eax
  _BYTE *v13; // eax
  _BYTE *v14; // eax
  _BYTE *v15; // eax
  _BYTE *v16; // eax
  _BYTE *v17; // eax
  void *v18; // eax
  _BYTE *result; // eax
  _BYTE *v20; // [esp+Ch] [ebp+Ch]

  v4 = &loc_804F4D0;
  if ( *(_BYTE *)(a3 + 24) )
    v4 = &loc_804F4DB;
  dword_806B33C = (int)v4;
  sub_8061194(a2, a1);
  if ( *(_BYTE *)(a3 + 25) )
  {
    v6 = a4++;
    *v6 = 98;
  }
  v7 = &loc_804F50D;
  if ( *(_UNKNOWN **)(a3 + 16) != &unk_806BECA )
    v7 = &loc_804F519;
  dword_806B318 = (int)v7;
  sub_8061268(v5);
  v9 = a4;
  v20 = a4 + 1;
  *v9 = 100;
  if ( *(_DWORD *)(a3 + 20) )
  {
    v10 = v20++;
    *v10 = 102;
  }
  if ( *(_BYTE *)(a3 + 28) )
  {
    v11 = v20++;
    *v11 = 103;
  }
  if ( *(_BYTE *)(a3 + 29) )
  {
    v12 = v20++;
    *v12 = 104;
  }
  if ( *(_UNKNOWN **)(a3 + 16) == &unk_806BDCA )
  {
    v13 = v20++;
    *v13 = 105;
  }
  if ( *(_BYTE *)(a3 + 30) )
  {
    v14 = v20++;
    *v14 = 77;
  }
  if ( *(_BYTE *)(a3 + 26) )
  {
    v15 = v20++;
    *v15 = 110;
  }
  if ( *(_BYTE *)(a3 + 27) )
  {
    v16 = v20++;
    *v16 = 82;
  }
  if ( *(_BYTE *)(a3 + 31) )
  {
    v17 = v20++;
    *v17 = 114;
  }
  v18 = &loc_804F5F6;
  if ( !*(_BYTE *)(a3 + 32) )
    v18 = &loc_804F602;
  dword_806B318 = (int)v18;
  sub_8061268(v8);
  *v20 = 86;
  result = v20 + 1;
  v20[1] = 0;
  return result;
}
// 804F4A9: could not find valid save-restore pair for ebx
// 8061194: using guessed type int __fastcall sub_8061194(_DWORD, _DWORD);
// 8061268: using guessed type int __fastcall sub_8061268(_DWORD);
// 806B318: using guessed type int dword_806B318;
// 806B33C: using guessed type int dword_806B33C;

//----- (0804F60A) --------------------------------------------------------
int __cdecl sub_804F60A(int *a1)
{
  int v1; // ST44_4
  int v2; // ST48_4
  int v3; // ST4C_4
  int v4; // ST50_4
  int v5; // ST54_4
  int v6; // ST58_4
  int v7; // ST5C_4
  int v8; // ST60_4
  int v9; // ST64_4
  int v10; // ST68_4

  v1 = *a1;
  v2 = a1[1];
  v3 = a1[2];
  v4 = a1[3];
  v5 = a1[4];
  v6 = a1[5];
  v7 = a1[6];
  v8 = a1[7];
  v9 = a1[8];
  v10 = a1[9];
  dword_806B2D0 = (int (__cdecl *)(_DWORD))&loc_804FE9C;
  return ((int (__cdecl *)(int *))loc_804FE9C)(a1);
}
// 806B2D0: using guessed type int (__cdecl *dword_806B2D0)(_DWORD);

//----- (0804F69E) --------------------------------------------------------
#error "804F728: call analysis failed (funcsize=141)"

//----- (0804F90B) --------------------------------------------------------
#error "804F946: call analysis failed (funcsize=44)"

//----- (0804F9C9) --------------------------------------------------------
int __usercall sub_804F9C9@<eax>(int a1@<ebp>, double a2@<st0>, int a3)
{
  int v3; // eax
  bool v4; // zf
  void *v5; // eax
  int v6; // eax
  int v8; // [esp-4h] [ebp-4h]
  void *retaddr; // [esp+0h] [ebp+0h]

  *(_BYTE *)(a1 - 167) = 0;
  *(_BYTE *)(a1 - 167) &= 1u;
  v3 = *(_DWORD *)(*(_DWORD *)(a1 - 164) + 8);
  v4 = v3 == 0;
  dword_806B2D0 = (int (__cdecl *)(_DWORD))sub_804FA46;
  v8 = v3;
  v5 = &loc_804FA0F;
  if ( !v4 )
    v5 = &loc_8060413;
  dword_806B248 = (int)v5;
  sub_80617DA(a2);
  v6 = *((_DWORD *)*(&retaddr - 41) + 3);
  dword_806B2D0 = (int (__cdecl *)(_DWORD))sub_804FA46;
  if ( v6 )
    dword_806B2D0 = (int (__cdecl *)(_DWORD))&loc_804FA4B;
  return dword_806B2D0(a3);
}
// 80617DA: using guessed type int __usercall sub_80617DA@<eax>(double@<st0>);
// 806B248: using guessed type int dword_806B248;
// 806B2D0: using guessed type int (__cdecl *dword_806B2D0)(_DWORD);

//----- (0804FA46) --------------------------------------------------------
#error "804FBAB: call analysis failed (funcsize=410)"

//----- (080500FA) --------------------------------------------------------
#error "8050100: positive sp value has been found (funcsize=0)"

//----- (08050104) --------------------------------------------------------
int __usercall __noreturn sub_8050104@<eax>(double a1@<st0>, int *a2, int *a3)
{
  unsigned __int8 *v3; // eax
  unsigned __int8 *v4; // eax
  int v5; // ecx
  void *v6; // eax
  unsigned __int8 v7; // al
  size_t v8; // eax
  void *v9; // eax
  unsigned __int8 v10; // al
  int v11; // eax
  unsigned __int8 v12; // al
  int v13; // ecx
  bool v14; // zf
  void *v15; // eax
  size_t v16; // eax
  char *v17; // ebx
  unsigned __int8 v18; // al
  char v19; // al
  int v20; // ecx
  void *v21; // eax
  void *v22; // eax
  void *v23; // eax
  void *v24; // eax
  unsigned __int8 v25; // al
  unsigned __int8 v26; // al
  unsigned __int8 v27; // al
  int v28; // ebx
  unsigned __int8 v29; // al
  unsigned __int8 v30; // al
  int v31; // ecx
  void *v32; // eax
  int v33; // edx
  int v34; // ecx
  void *v35; // eax
  void *v36; // eax
  int v37; // ecx
  unsigned int v38; // et1
  int (*v39)(); // eax
  char *v41; // [esp-8h] [ebp-1020h]
  int v42; // [esp+0h] [ebp-1018h]
  int *v43; // [esp+18h] [ebp-1000h]
  int *v44; // [esp+1Ch] [ebp-FFCh]
  char v45; // [esp+26h] [ebp-FF2h]
  char v46; // [esp+27h] [ebp-FF1h]
  int v47; // [esp+28h] [ebp-FF0h]
  void *s1; // [esp+2Ch] [ebp-FECh]
  void *s2; // [esp+30h] [ebp-FE8h]
  unsigned __int8 *v50; // [esp+34h] [ebp-FE4h]
  unsigned __int8 *v51; // [esp+38h] [ebp-FE0h]
  int v52; // [esp+3Ch] [ebp-FDCh]
  char *v53; // [esp+40h] [ebp-FD8h]
  char *v54; // [esp+44h] [ebp-FD4h]
  size_t v55; // [esp+48h] [ebp-FD0h]
  size_t v56; // [esp+4Ch] [ebp-FCCh]
  void *ptr; // [esp+50h] [ebp-FC8h]
  size_t v58; // [esp+54h] [ebp-FC4h]
  int v59; // [esp+58h] [ebp-FC0h]
  int v60; // [esp+5Ch] [ebp-FBCh]
  size_t v61; // [esp+60h] [ebp-FB8h]
  size_t n; // [esp+64h] [ebp-FB4h]
  size_t size; // [esp+68h] [ebp-FB0h]
  char v64; // [esp+6Ch] [ebp-FACh]
  unsigned int v65; // [esp+100Ch] [ebp-Ch]

  v44 = a2;
  v43 = a3;
  v65 = __readgsdword(0x14u);
  v47 = dword_806C0DE;
  s1 = (void *)a2[2];
  s2 = (void *)a3[2];
  v50 = (unsigned __int8 *)a2[3];
  v51 = (unsigned __int8 *)a3[3];
  while ( 1 )
  {
    v59 = *(_DWORD *)(v47 + 20);
    v60 = *(_DWORD *)(v47 + 16);
    v3 = (unsigned __int8 *)s1;
    if ( v50 >= s1 )
      v3 = v50;
    v50 = v3;
    v4 = (unsigned __int8 *)s2;
    if ( v51 >= s2 )
      v4 = v51;
    v51 = v4;
    v61 = v50 - (_BYTE *)s1;
    n = v4 - (_BYTE *)s2;
    if ( byte_806BCB2
      || (unsigned __int8)sub_804EFB3((_BYTE *)v47)
      || *(_BYTE *)(v47 + 30)
      || *(_BYTE *)(v47 + 27)
      || *(_BYTE *)(v47 + 32) )
    {
      if ( v60 || v59 )
      {
        size = v61 + n + 2;
        if ( size <= 0xFA0 )
        {
          v53 = &v64;
          ptr = 0;
          dword_806B298 = (int)&loc_80502BF;
          sub_8061601();
        }
        ptr = (void *)sub_805E160(size);
        v53 = (char *)ptr;
        v54 = (char *)ptr + v61 + 1;
        v58 = 0;
        v55 = 0;
        while ( v58 < v61 )
        {
          v6 = &loc_8050313;
          if ( !v60 )
            v6 = &loc_8050348;
          dword_806B20C = (int)v6;
          sub_8061930(v5);
          v42 = *((char *)s1 + v58);
          v7 = sub_804B53E(v42);
          if ( *(_BYTE *)(v7 + v60) ^ 1 )
          {
            v8 = v55++;
            v41 = &v53[v8];
            v9 = &loc_8050382;
            if ( !v59 )
              v9 = &loc_80503C3;
            dword_806B318 = (int)v9;
            sub_8061268(v5);
            v42 = *((char *)s1 + v58);
            v10 = sub_804B53E(v42);
            v11 = *(unsigned __int8 *)(v10 + v59);
            dword_806B25C = (int)&loc_80503D4;
            sub_806176A();
            *v41 = *((_BYTE *)s1 + v58);
          }
          ++v58;
        }
        v53[v55] = 0;
        v58 = 0;
        v56 = 0;
        while ( v58 < n )
        {
          if ( v60 )
          {
            v42 = *((char *)s2 + v58);
            v12 = sub_804B53E(v42);
            v14 = *(_BYTE *)(v12 + v60) == 1;
            v15 = &loc_805046E;
            if ( v14 )
              v15 = &loc_80504CE;
            dword_806B220 = (int)v15;
            sub_80618C4(v13);
          }
          v16 = v56++;
          v17 = &v54[v16];
          if ( v59 )
          {
            v42 = *((char *)s2 + v58);
            v18 = sub_804B53E(v42);
            v19 = *(_BYTE *)(v18 + v59);
          }
          else
          {
            v19 = *((_BYTE *)s2 + v58);
          }
          *v17 = v19;
          ++v58;
        }
        v54[v56] = 0;
      }
      else
      {
        v53 = (char *)s1;
        v55 = v61;
        v45 = *((_BYTE *)s1 + v61);
        *((_BYTE *)s1 + v61) = 0;
        v54 = (char *)s2;
        v56 = n;
        v46 = *((_BYTE *)s2 + n);
        *((_BYTE *)s2 + n) = 0;
      }
      if ( *(_BYTE *)(v47 + 26) )
      {
        v52 = sub_804E337(a1, (unsigned __int8 *)v53, (unsigned __int8 *)v54);
      }
      else
      {
        v21 = &loc_80505D5;
        if ( !*(_BYTE *)(v47 + 28) )
          v21 = &loc_80505F8;
        dword_806B25C = (int)v21;
        sub_806176A();
        v52 = sub_804E447((int)v53, (int)v54);
      }
      v22 = &loc_80507BA;
      if ( v60 )
        v22 = &loc_80507C3;
      dword_806B318 = (int)v22;
      sub_8061268(v20);
      if ( v59 )
      {
        free(ptr);
        goto LABEL_64;
      }
      v53[v55] = v45;
      v54[v56] = v46;
      dword_806B270 = (int)&loc_8050CC0;
      sub_80616F8();
    }
    v23 = &loc_805083D;
    if ( !v60 )
      v23 = &loc_8050B33;
    dword_806B2E4 = (int)v23;
    sub_806141F(a1);
    v24 = &loc_805085F;
    if ( !v59 )
      v24 = &loc_80509F8;
    dword_806B304 = (int)v24;
    sub_8061308();
    while ( s1 < v50 )
    {
      v42 = *(char *)s1;
      v25 = sub_804B53E(v42);
      if ( !*(_BYTE *)(v25 + v60) )
        break;
      s1 = (char *)s1 + 1;
    }
    while ( s2 < v51 )
    {
      v42 = *(char *)s2;
      v26 = sub_804B53E(v42);
      if ( !*(_BYTE *)(v26 + v60) )
        break;
      s2 = (char *)s2 + 1;
    }
    if ( s1 < v50 && s2 < v51 )
    {
      v42 = *(char *)s1;
      v27 = sub_804B53E(v42);
      v42 = *(char *)(v27 + v59);
      v28 = (unsigned __int8)sub_804B53E(v42);
      v42 = *(char *)s2;
      v29 = sub_804B53E(v42);
      v42 = *(char *)(v29 + v59);
      v30 = sub_804B53E(v42);
      v52 = v28 - v30;
      v14 = v28 == v30;
      v32 = &loc_8050989;
      if ( v14 )
        v32 = &loc_80509A0;
      dword_806B318 = (int)v32;
      sub_8061268(v31);
      dword_806B284 = (int)&loc_8050EAE;
      sub_8061671(v34, v33);
      s1 = (char *)s1 + 1;
      s2 = (char *)s2 + 1;
      dword_806B270 = (int)&loc_805085F;
      sub_80616F8();
    }
    v52 = (s1 < v50) - (s2 < v51);
LABEL_64:
    if ( v52 )
      break;
    v47 = *(_DWORD *)(v47 + 36);
    if ( !v47 )
      goto LABEL_72;
    v35 = &loc_8050D17;
    if ( *(_DWORD *)(v47 + 8) == -1 )
      v35 = &loc_8050D55;
    dword_806B248 = (int)v35;
    sub_80617DA(a1);
    v50 = sub_804DB11((int)v44, v47);
    v51 = sub_804DB11((int)v43, v47);
    v36 = &loc_8050DB3;
    if ( *(_DWORD *)v47 == -1 )
      v36 = &loc_8050DF4;
    dword_806B304 = (int)v36;
    sub_8061308();
    s1 = (void *)sub_804D7F9(v44, (int *)v47);
    s2 = (void *)sub_804D7F9(v43, (int *)v47);
  }
  *(_BYTE *)(v47 + 31);
LABEL_72:
  v38 = __readgsdword(0x14u);
  v37 = v38 ^ v65;
  v39 = (int (*)())&loc_8050EF1;
  if ( v38 == v65 )
    v39 = sub_8050EF6;
  dword_806B318 = (int)v39;
  return sub_8061268(v37);
}
// 8050EF6: using guessed type int sub_8050EF6();
// 8061268: using guessed type int __fastcall sub_8061268(_DWORD);
// 8061308: using guessed type int sub_8061308(void);
// 806141F: using guessed type int __usercall sub_806141F@<eax>(double@<st0>);
// 8061601: using guessed type int sub_8061601(void);
// 8061671: using guessed type int __fastcall sub_8061671(_DWORD, _DWORD);
// 80616F8: using guessed type int sub_80616F8(void);
// 806176A: using guessed type int sub_806176A(void);
// 80617DA: using guessed type int __usercall sub_80617DA@<eax>(double@<st0>);
// 80618C4: using guessed type int __fastcall sub_80618C4(_DWORD);
// 8061930: using guessed type int __fastcall sub_8061930(_DWORD);
// 806B20C: using guessed type int dword_806B20C;
// 806B220: using guessed type int dword_806B220;
// 806B248: using guessed type int dword_806B248;
// 806B25C: using guessed type int dword_806B25C;
// 806B270: using guessed type int dword_806B270;
// 806B284: using guessed type int dword_806B284;
// 806B298: using guessed type int dword_806B298;
// 806B2E4: using guessed type int dword_806B2E4;
// 806B304: using guessed type int dword_806B304;
// 806B318: using guessed type int dword_806B318;
// 806BCB2: using guessed type char byte_806BCB2;
// 806C0DE: using guessed type int dword_806C0DE;

//----- (08050EF6) --------------------------------------------------------
#error "8050EFC: positive sp value has been found (funcsize=0)"

//----- (08050EFF) --------------------------------------------------------
int __usercall sub_8050EFF@<eax>(double a1@<st0>, int *a2, int *a3)
{
  unsigned int v3; // eax
  signed int v4; // eax
  int v6; // [esp+14h] [ebp-14h]
  unsigned int v7; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]

  if ( dword_806C0DE )
    sub_8050104(a1, a2, a3);
  v7 = a2[1] - 1;
  n = a3[1] - 1;
  if ( v7 )
  {
    if ( n )
    {
      if ( byte_806BCB2 )
      {
        v6 = sub_805E470(a1, (void *)*a2, v7 + 1, (void *)*a3, n + 1);
      }
      else
      {
        v3 = v7;
        if ( n <= v7 )
          v3 = n;
        v6 = memcmp((const void *)*a2, (const void *)*a3, v3);
        if ( !v6 )
        {
          if ( v7 < n )
            v4 = -1;
          else
            v4 = v7 != n;
          v6 = v4;
        }
      }
    }
    else
    {
      v6 = 1;
    }
  }
  else
  {
    v6 = -(n != 0);
  }
  if ( byte_806C0DA )
  {
    dword_806B304 = (int)&loc_805106F;
    sub_8061308();
  }
  return v6;
}
// 8061308: using guessed type int sub_8061308(void);
// 806B304: using guessed type int dword_806B304;
// 806BCB2: using guessed type char byte_806BCB2;
// 806C0DA: using guessed type char byte_806C0DA;
// 806C0DE: using guessed type int dword_806C0DE;

//----- (08051075) --------------------------------------------------------
int __usercall sub_8051075@<eax>(int a1@<ecx>, long double a2@<st0>, int a3, FILE *stream, int a5)
{
  _BYTE *v5; // eax
  bool v6; // zf
  void *v7; // eax
  char *v8; // eax
  int v9; // ecx
  int result; // eax
  char *v11; // eax
  int v12; // ecx
  _BYTE *v13; // [esp+20h] [ebp-18h]
  _BYTE *ptr; // [esp+24h] [ebp-14h]
  size_t n; // [esp+28h] [ebp-10h]
  unsigned int v16; // [esp+2Ch] [ebp-Ch]

  ptr = *(_BYTE **)a3;
  n = *(_DWORD *)(a3 + 4);
  v16 = *(_DWORD *)a3 + n;
  if ( a5 || !byte_806C0E6 )
  {
    *(_BYTE *)(v16 - 1) = byte_806B370;
    if ( fwrite_unlocked(ptr, 1u, n, stream) != n )
    {
      v11 = gettext("write failed");
      sub_804B8B7(v12, a5, (int)v11, a5);
    }
    result = v16 - 1;
    *(_BYTE *)(v16 - 1) = 0;
  }
  else
  {
    v13 = *(_BYTE **)a3;
    while ( (unsigned int)v13 < v16 )
    {
      v5 = v13++;
      v6 = *v5 == 9;
      v7 = &loc_80510E6;
      if ( !v6 )
        v7 = &loc_80510EC;
      dword_806B20C = (int)v7;
      sub_8061930(a1);
      if ( fputc_unlocked(62, stream) == -1 )
      {
        v8 = gettext("write failed");
        sub_804B8B7(v9, 0, (int)v8, 0);
      }
    }
    result = sub_804F265(a1, a2, (int *)a3);
  }
  return result;
}
// 8061930: using guessed type int __fastcall sub_8061930(_DWORD);
// 806B20C: using guessed type int dword_806B20C;
// 806B370: using guessed type char byte_806B370;
// 806C0E6: using guessed type char byte_806C0E6;

//----- (0805119B) --------------------------------------------------------
int __usercall sub_805119B@<eax>(long double a1@<st0>, char *a2, char a3)
{
  size_t v3; // eax
  int v4; // ecx
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // ebx
  int v9; // esi
  char *v10; // eax
  char *v11; // eax
  int v12; // ecx
  __int64 v14; // [esp+0h] [ebp-B8h]
  int v15; // [esp+8h] [ebp-B0h]
  char *v16; // [esp+Ch] [ebp-ACh]
  int v17; // [esp+10h] [ebp-A8h]
  char v18; // [esp+18h] [ebp-A0h]
  char *s1; // [esp+1Ch] [ebp-9Ch]
  char v20; // [esp+2Eh] [ebp-8Ah]
  char v21[5]; // [esp+2Fh] [ebp-89h]
  int v22; // [esp+34h] [ebp-84h]
  FILE *v23; // [esp+38h] [ebp-80h]
  int v24; // [esp+3Ch] [ebp-7Ch]
  int v25; // [esp+40h] [ebp-78h]
  int v26; // [esp+44h] [ebp-74h]
  __int64 v27; // [esp+48h] [ebp-70h]
  __int64 v28; // [esp+50h] [ebp-68h]
  int v29; // [esp+58h] [ebp-60h]
  int v30; // [esp+68h] [ebp-50h]
  int v31; // [esp+70h] [ebp-48h]
  char v32; // [esp+87h] [ebp-31h]
  unsigned int v33; // [esp+9Ch] [ebp-1Ch]

  s1 = a2;
  v18 = a3;
  v33 = __readgsdword(0x14u);
  v23 = sub_804C370(*(double *)&a1, a2, "r");
  *(_DWORD *)&v21[1] = 0;
  v27 = 0LL;
  v24 = dword_806C0DE;
  *(_DWORD *)v21 = byte_806C0DC == 0;
  v21[0] &= 1u;
  v20 = 1;
  v3 = dword_806B3F0;
  if ( size >= dword_806B3F0 )
    v3 = size;
  sub_804D758((int)&v30, 16, v3);
  v29 = 0;
  dword_806B2D0 = (int (__cdecl *)(_DWORD))&loc_80515A1;
  dword_806B20C = (int)&loc_8060413;
  sub_8061930(v4);
  v22 = sub_804D7DE(&v30);
  v25 = -16 * v31 + v22;
  dword_806B2D0 = sub_80513D4;
  if ( *(_DWORD *)&v21[1] )
  {
    v5 = sub_8050EFF(*(double *)&a1, &v29, (int *)(v22 - 16));
    dword_806B2D0 = sub_80513D4;
    if ( (unsigned __int8)v21[0] <= v5 )
    {
      dword_806B2D0 = (int (__cdecl *)(_DWORD))&loc_80513BA;
      if ( v18 == 99 )
      {
        v26 = v22 - 16;
        v6 = sub_804D7DE(&v30);
        v7 = (v6 - v26) >> 4;
        v28 = v7 + v27;
        v14 = v7 + v27;
        v8 = sub_80593DD(v14, (int)&v32);
        v9 = dword_806C23A;
        v10 = gettext("%s: %s:%s: disorder: ");
        v17 = v8;
        v16 = s1;
        v15 = v9;
        fprintf(stderr, v10, v9, s1, v8);
        v11 = gettext("standard error");
        sub_8051075(v12, a1, v26, stderr, (int)v11);
        v20 = 0;
        dword_806B2D0 = (int (__cdecl *)(_DWORD))&loc_80515DA;
      }
    }
  }
  return dword_806B2D0(a2);
}
// 8061930: using guessed type int __fastcall sub_8061930(_DWORD);
// 806B20C: using guessed type int dword_806B20C;
// 806B2D0: using guessed type int (__cdecl *dword_806B2D0)(_DWORD);
// 806C0DC: using guessed type char byte_806C0DC;
// 806C0DE: using guessed type int dword_806C0DE;
// 806C23A: using guessed type int dword_806C23A;

//----- (080513D4) --------------------------------------------------------
int __cdecl sub_80513D4(int a1)
{
  dword_806B2D0 = (int (__cdecl *)(_DWORD))&loc_8051444;
  return ((int (__cdecl *)(int))loc_8051444)(a1);
}
// 806B2D0: using guessed type int (__cdecl *dword_806B2D0)(_DWORD);

//----- (080513E7) --------------------------------------------------------
#error "8051404: call analysis failed (funcsize=55)"

//----- (080514DC) --------------------------------------------------------
#error "8051505: call analysis failed (funcsize=90)"

//----- (0805162F) --------------------------------------------------------
#error "8051635: positive sp value has been found (funcsize=0)"

//----- (0805163A) --------------------------------------------------------
unsigned int __usercall sub_805163A@<eax>(double a1@<st0>, int a2, unsigned int a3, int *a4)
{
  int v4; // ecx
  unsigned int i; // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]

  *a4 = sub_805DFF6(a3, 4u);
  v7 = *a4;
  for ( i = 0; i < a3; ++i )
  {
    if ( *(_DWORD *)(8 * i + a2 + 4) && *(_BYTE *)(*(_DWORD *)(8 * i + a2 + 4) + 8) )
    {
      sub_804C7E3(a1, *(_DWORD *)(8 * i + a2 + 4));
      dword_806B220 = (int)&loc_8051701;
      sub_80618C4(v4);
    }
    *(_DWORD *)(4 * i + v7) = sub_804C234(a1, *(char **)(8 * i + a2), "r");
    if ( !*(_DWORD *)(4 * i + v7) )
      break;
  }
  return i;
}
// 80618C4: using guessed type int __fastcall sub_80618C4(_DWORD);
// 806B220: using guessed type int dword_806B220;

//----- (08051733) --------------------------------------------------------
void __usercall sub_8051733(long double a1@<st0>, int a2, int a3, int a4, FILE *stream, int a6, void *a7)
{
  int v7; // ecx
  size_t v8; // edx
  _DWORD *v9; // ecx
  _DWORD *v10; // eax
  int v11; // edx
  int v12; // edx
  void *v13; // eax
  void *v14; // eax
  int v15; // ecx
  FILE *v16; // edx
  int v17; // ebx
  bool v18; // zf
  int v19; // edx
  int v20; // ecx
  void *v21; // eax
  int *v22; // eax
  _DWORD *v23; // [esp+0h] [ebp-78h]
  int *v24; // [esp+4h] [ebp-74h]
  int v25; // [esp+8h] [ebp-70h]
  int *v26; // [esp+14h] [ebp-64h]
  size_t size; // [esp+18h] [ebp-60h]
  unsigned int j; // [esp+1Ch] [ebp-5Ch]
  unsigned int i; // [esp+20h] [ebp-58h]
  unsigned int v30; // [esp+24h] [ebp-54h]
  unsigned int v31; // [esp+28h] [ebp-50h]
  unsigned int v32; // [esp+2Ch] [ebp-4Ch]
  void *v33; // [esp+30h] [ebp-48h]
  void *v34; // [esp+34h] [ebp-44h]
  void *v35; // [esp+38h] [ebp-40h]
  void *v36; // [esp+3Ch] [ebp-3Ch]
  int v37; // [esp+40h] [ebp-38h]
  int v38; // [esp+44h] [ebp-34h]
  int v39; // [esp+48h] [ebp-30h]
  int v40; // [esp+4Ch] [ebp-2Ch]
  int v41; // [esp+50h] [ebp-28h]
  __int64 v42; // [esp+54h] [ebp-24h]
  unsigned int v43; // [esp+5Ch] [ebp-1Ch]
  void *ptr; // [esp+60h] [ebp-18h]
  size_t n; // [esp+64h] [ebp-14h]
  char *v46; // [esp+68h] [ebp-10h]
  char *v47; // [esp+6Ch] [ebp-Ch]

  v33 = (void *)sub_805DFF6(a4, 0x1Cu);
  v26 = 0;
  size = 0;
  v34 = (void *)sub_805DFF6(a4, 4u);
  v35 = (void *)sub_805DFF6(a4, 4u);
  v36 = (void *)sub_805DFF6(a4, 4u);
  v37 = dword_806C0DE;
  ptr = 0;
  j = 0;
  while ( j < a4 )
  {
    v8 = ::size / a4;
    if ( ::size / a4 < dword_806B3F0 )
      v8 = dword_806B3F0;
    sub_804D758((int)v33 + 28 * j, 16, v8);
    if ( (unsigned __int8)sub_804DCDE(*(double *)&a1, (int)v33 + 28 * j, *((FILE **)a7 + j), *(_DWORD *)(8 * j + a2)) )
    {
      v38 = sub_804D7DE((_DWORD *)v33 + 7 * j);
      *((_DWORD *)v34 + j) = v38 - 16;
      v7 = -16 * *((_DWORD *)v33 + 7 * j + 2);
      *((_DWORD *)v35 + j++) = v7 + v38;
    }
    else
    {
      sub_804C3CA(*(double *)&a1, *((FILE **)a7 + j), *(_DWORD *)(8 * j + a2));
      if ( j < a3 )
      {
        --a3;
        sub_804CA2D(*(double *)&a1, *(char **)(8 * j + a2));
      }
      free(*((void **)v33 + 7 * j));
      --a4;
      for ( i = j; i < a4; ++i )
      {
        v9 = (_DWORD *)(8 * i + a2);
        v10 = (_DWORD *)(8 * (i + 1) + a2);
        v11 = v10[1];
        *v9 = *v10;
        v9[1] = v11;
        v7 = 4 * (i + 1);
        *((_DWORD *)a7 + i) = *(_DWORD *)((char *)a7 + v7);
      }
    }
  }
  for ( j = 0; j < a4; ++j )
    *((_DWORD *)v36 + j) = j;
  for ( j = 1; j < a4; ++j )
  {
    if ( sub_8050EFF(
           *(double *)&a1,
           *((int **)v34 + *((_DWORD *)v36 + j + 0x3FFFFFFF)),
           *((int **)v34 + *((_DWORD *)v36 + j))) > 0 )
    {
      v39 = *((_DWORD *)v36 + j + 0x3FFFFFFF);
      v7 = 4 * j;
      *((_DWORD *)v36 + j + 0x3FFFFFFF) = *((_DWORD *)v36 + j);
      *((_DWORD *)v36 + j) = v39;
      j = 0;
    }
  }
  while ( a4 )
  {
    v12 = 4 * *(_DWORD *)v36;
    v40 = *(_DWORD *)((char *)v34 + v12);
    if ( !byte_806C0DC )
      goto LABEL_34;
    v13 = &loc_8051ADB;
    if ( !v26 )
      v13 = &loc_8051B11;
    dword_806B234 = (int)v13;
    sub_806184C(v7, v12);
    if ( sub_8050EFF(*(double *)&a1, v26, (int *)v40) )
    {
      v26 = 0;
      sub_8051075(v7, a1, (int)&ptr, stream, a6);
    }
    if ( !v26 )
    {
      v26 = (int *)&ptr;
      if ( *(_DWORD *)(v40 + 4) > size )
      {
        do
        {
          v14 = &loc_8051B4B;
          if ( size )
            v14 = &loc_8051B6B;
          dword_806B2C0 = (int)v14;
          sub_8061521();
          size = *(_DWORD *)(v40 + 4);
          dword_806B298 = (int)&loc_8051B79;
          sub_8061601();
          size *= 2;
        }
        while ( size < *(_DWORD *)(v40 + 4) );
        free(ptr);
        ptr = (void *)sub_805E160(size);
      }
      n = *(_DWORD *)(v40 + 4);
      memcpy(ptr, *(const void **)v40, n);
      if ( v37 )
      {
        v46 = (char *)ptr + *(_DWORD *)(v40 + 8) - *(_DWORD *)v40;
        v15 = *(_DWORD *)(v40 + 12) - *(_DWORD *)v40;
        v47 = (char *)ptr + v15;
        dword_806B318 = (int)&loc_8051C1E;
        sub_8061268(v15);
LABEL_34:
        sub_8051075(v7, a1, v40, stream, a6);
        goto LABEL_35;
      }
    }
LABEL_35:
    if ( *((_DWORD *)v35 + *(_DWORD *)v36) >= (unsigned int)v40 )
    {
      v16 = (FILE *)*((_DWORD *)a7 + *(_DWORD *)v36);
      v17 = 28 * *(_DWORD *)v36;
      v25 = *(_DWORD *)(8 * *(_DWORD *)v36 + a2);
      v18 = (unsigned __int8)sub_804DCDE(*(double *)&a1, (int)v33 + v17, v16, v25) == 0;
      v21 = &loc_8051CBD;
      if ( v18 )
        v21 = &loc_8051D34;
      dword_806B33C = (int)v21;
      sub_8061194(v20, v19);
      v23 = (char *)v33 + 28 * *(_DWORD *)v36;
      v41 = sub_804D7DE(v23);
      *((_DWORD *)v34 + *(_DWORD *)v36) = v41 - 16;
      v7 = -16 * *((_DWORD *)v33 + 7 * *(_DWORD *)v36 + 2);
      *((_DWORD *)v35 + *(_DWORD *)v36) = v7 + v41;
    }
    else
    {
      *((_DWORD *)v34 + *(_DWORD *)v36) = v40 - 16;
    }
    v30 = 1;
    v31 = a4;
    v32 = 1;
    LODWORD(v42) = *(_DWORD *)v36;
    while ( v30 < v31 )
    {
      v22 = (int *)*((_DWORD *)v34 + v42);
      v24 = (int *)*((_DWORD *)v34 + *((_DWORD *)v36 + v32));
      HIDWORD(v42) = sub_8050EFF(*(double *)&a1, v22, v24);
      if ( v42 >= *((unsigned int *)v36 + v32) )
        v30 = v32 + 1;
      else
        v31 = v32;
      v32 = (v30 + v31) >> 1;
    }
    v43 = v30 - 1;
    for ( i = 0; i < v43; ++i )
    {
      v7 = 4 * (i + 1);
      *((_DWORD *)v36 + i) = *(_DWORD *)((char *)v36 + v7);
    }
    *((_DWORD *)v36 + v43) = v42;
  }
  if ( byte_806C0DC && v26 )
  {
    sub_8051075(v7, a1, (int)&ptr, stream, a6);
    free(ptr);
  }
  sub_804C3CA(*(double *)&a1, stream, a6);
  free(a7);
  free(v33);
  free(v36);
  free(v35);
  free(v34);
}
// 8061194: using guessed type int __fastcall sub_8061194(_DWORD, _DWORD);
// 8061268: using guessed type int __fastcall sub_8061268(_DWORD);
// 8061521: using guessed type int sub_8061521(void);
// 8061601: using guessed type int sub_8061601(void);
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD, _DWORD);
// 806B234: using guessed type int dword_806B234;
// 806B298: using guessed type int dword_806B298;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B318: using guessed type int dword_806B318;
// 806B33C: using guessed type int dword_806B33C;
// 806C0DC: using guessed type char byte_806C0DC;
// 806C0DE: using guessed type int dword_806C0DE;

//----- (080520CF) --------------------------------------------------------
int __usercall sub_80520CF@<eax>(long double a1@<st0>, int a2, int a3, int a4, FILE *stream, int a6)
{
  int v6; // ebx
  char *v7; // eax
  int v8; // edx
  int v9; // ecx
  void *v11; // [esp+28h] [ebp-10h]
  int v12; // [esp+2Ch] [ebp-Ch]

  v12 = sub_805163A(*(double *)&a1, a2, a4, (int *)&v11);
  if ( v12 < (unsigned int)a4 && (unsigned int)v12 <= 1 )
  {
    v6 = *(_DWORD *)(8 * v12 + a2);
    v7 = gettext("open failed");
    sub_804B8B7(v9, v8, (int)v7, v6);
  }
  sub_8051733(a1, a2, a3, v12, stream, a6, v11);
  return v12;
}

//----- (08052160) --------------------------------------------------------
int __usercall sub_8052160@<eax>(double a1@<st0>, _DWORD *a2, unsigned int a3, int a4)
{
  int v4; // ecx
  void *v5; // eax
  _DWORD *v7; // eax
  void *v8; // eax
  unsigned int v9; // [esp+14h] [ebp-14h]
  int v10; // [esp+18h] [ebp-10h]
  _DWORD *v11; // [esp+1Ch] [ebp-Ch]
  _DWORD *v12; // [esp+30h] [ebp+8h]
  _DWORD *v13; // [esp+38h] [ebp+10h]

  v9 = a3 >> 1;
  v10 = a3 - (a3 >> 1);
  v11 = &a2[-4 * (a3 >> 1)];
  do
  {
    if ( sub_8050EFF(a1, (int *)(a4 - 16), v11 - 4) <= 0 )
    {
      v12 = a2 - 4;
      v13 = (_DWORD *)(a4 - 16);
      *v12 = *v13;
      v12[1] = v13[1];
      v4 = v13[2];
      v12[2] = v4;
      v12[3] = v13[3];
      v5 = &loc_80521F0;
      if ( v9 != 1 )
        v5 = &loc_8052269;
      dword_806B220 = (int)v5;
      return sub_80618C4(v4);
    }
    a2 -= 4;
    v11 -= 4;
    *a2 = *v11;
    a2[1] = v11[1];
    a2[2] = v11[2];
    a2[3] = v11[3];
    --v10;
  }
  while ( v10 );
  v7 = a2 - 4;
  *v7 = *(_DWORD *)(a4 - 16);
  v7[1] = *(_DWORD *)(a4 - 16 + 4);
  v7[2] = *(_DWORD *)(a4 - 16 + 8);
  v7[3] = *(_DWORD *)(a4 - 16 + 12);
  v8 = &loc_8052267;
  if ( v9 != 1 )
    v8 = &loc_8052220;
  dword_806B298 = (int)v8;
  return sub_8061601();
}
// 8061601: using guessed type int sub_8061601(void);
// 80618C4: using guessed type int __fastcall sub_80618C4(_DWORD);
// 806B220: using guessed type int dword_806B220;
// 806B298: using guessed type int dword_806B298;

//----- (08052270) --------------------------------------------------------
int __usercall sub_8052270@<eax>(double a1@<st0>, int a2, unsigned int a3, _DWORD *a4, unsigned __int8 a5)
{
  int result; // eax
  _DWORD *v6; // eax
  _DWORD *v7; // edx
  _DWORD *v8; // eax
  _DWORD *v9; // edx
  _DWORD *v10; // edx
  _DWORD *v11; // edx
  _DWORD *v12; // edx
  int v13; // eax
  int v14; // ecx
  void *v15; // eax
  _DWORD *v16; // edx
  int v17; // eax
  int v18; // ecx
  void *v19; // eax
  unsigned __int8 v20; // [esp+1Ch] [ebp-2Ch]
  int v21; // [esp+2Ch] [ebp-1Ch]
  unsigned int v22; // [esp+30h] [ebp-18h]
  unsigned int v23; // [esp+34h] [ebp-14h]
  int v24; // [esp+38h] [ebp-10h]
  unsigned int v25; // [esp+3Ch] [ebp-Ch]

  v20 = a5;
  if ( a3 == 2 )
  {
    result = sub_8050EFF(a1, (int *)(a2 - 16), (int *)(a2 - 32)) > 0;
    v21 = result;
    if ( v20 )
    {
      v6 = a4 - 4;
      v7 = (_DWORD *)(16 * ~v21 + a2);
      *v6 = *v7;
      v6[1] = v7[1];
      v6[2] = v7[2];
      v6[3] = v7[3];
      v8 = a4 - 8;
      v9 = (_DWORD *)(16 * (v21 - 2) + a2);
      *v8 = *v9;
      v8[1] = v9[1];
      v8[2] = v9[2];
      v8[3] = v9[3];
      dword_806B270 = (int)&loc_8052388;
      result = sub_80616F8();
    }
    if ( v21 )
    {
      v10 = a4 - 4;
      *v10 = *(_DWORD *)(a2 - 16);
      v10[1] = *(_DWORD *)(a2 - 12);
      v10[2] = *(_DWORD *)(a2 - 8);
      v10[3] = *(_DWORD *)(a2 - 4);
      v11 = (_DWORD *)(a2 - 16);
      *v11 = *(_DWORD *)(a2 - 32);
      v11[1] = *(_DWORD *)(a2 - 28);
      v11[2] = *(_DWORD *)(a2 - 24);
      v11[3] = *(_DWORD *)(a2 - 20);
      v12 = (_DWORD *)(a2 - 32);
      *v12 = *(a4 - 4);
      v12[1] = *(a4 - 3);
      v12[2] = *(a4 - 2);
      result = *(a4 - 1);
      v12[3] = result;
    }
  }
  else
  {
    v22 = a3 >> 1;
    v23 = a3 - (a3 >> 1);
    v24 = a2;
    v25 = -16 * (a3 >> 1) + a2;
    if ( v20 )
      v13 = -4 * v22;
    else
      v13 = 0;
    sub_8052270(v25, v23, &a4[v13], v20);
    if ( v22 > 1 )
    {
      sub_8052270(v24, v22, a4, v20 == 0);
      dword_806B220 = (int)&loc_8052485;
      sub_80618C4(v14);
    }
    v15 = &loc_8052465;
    if ( v20 == 1 )
      v15 = &loc_8052485;
    dword_806B270 = (int)v15;
    sub_80616F8();
    v16 = a4 - 4;
    v17 = v24;
    *v16 = *(_DWORD *)(v24 - 16);
    v16[1] = *(_DWORD *)(v17 - 12);
    v18 = *(_DWORD *)(v17 - 8);
    v16[2] = v18;
    v16[3] = *(_DWORD *)(v17 - 4);
    v19 = &loc_80524A4;
    if ( !v20 )
      v19 = &loc_80524B2;
    dword_806B220 = (int)v19;
    sub_80618C4(v18);
    result = sub_8052160(a1, a4, a3, a2);
  }
  return result;
}
// 8052270: could not find valid save-restore pair for ebx
// 80616F8: using guessed type int sub_80616F8(void);
// 80618C4: using guessed type int __fastcall sub_80618C4(_DWORD);
// 806B220: using guessed type int dword_806B220;
// 806B270: using guessed type int dword_806B270;

//----- (080524D9) --------------------------------------------------------
pthread_mutex_t *__cdecl sub_80524D9(unsigned int a1, int a2, int a3)
{
  pthread_mutex_t *v3; // eax
  pthread_mutex_t *v4; // ST28_4
  pthread_mutex_t *v5; // ST2C_4

  v3 = (pthread_mutex_t *)sub_805E160(144 * a1);
  v4 = v3;
  v5 = v3;
  v3->__kind = 0;
  v5->__owner = v5->__kind;
  v5->__count = v5->__owner;
  v5->__lock = v5->__count;
  v3->__nusers = 0;
  v3[1].__lock = a2;
  v3->__spins = v3[1].__lock;
  v3[1].__count = 0;
  v3[1].__nusers = 0;
  v3[1].__size[20] = 0;
  pthread_mutex_init(v3 + 2, 0);
  sub_8052608((unsigned int)v5, v5 + 3, a3, a1, a2, 0);
  return v4;
}

//----- (08052608) --------------------------------------------------------
int __cdecl sub_8052608(unsigned int a1, pthread_mutex_t *a2, int a3, unsigned int a4, int a5, char a6)
{
  void *v6; // eax
  unsigned int v7; // eax
  int v8; // eax
  int v9; // ST48_4
  pthread_mutex_t *v10; // eax
  int v11; // eax
  int v13; // [esp+30h] [ebp-28h]
  int v14; // [esp+34h] [ebp-24h]
  int v15; // [esp+38h] [ebp-20h]
  int v16; // [esp+3Ch] [ebp-1Ch]
  pthread_mutex_t *v17; // [esp+44h] [ebp-14h]
  int v18; // [esp+64h] [ebp+Ch]

  v6 = &loc_8052633;
  if ( !a6 )
    v6 = &loc_805263B;
  dword_806B2C0 = (int)v6;
  sub_8061521();
  v7 = *(_DWORD *)(a1 + 20);
  v13 = v7 >> 1;
  v14 = v7 - (v7 >> 1);
  v15 = -16 * a5 + a3;
  v16 = -16 * (v7 >> 1) + v15;
  if ( a6 )
    v8 = a1 + 8;
  else
    v8 = a1 + 12;
  v9 = v8;
  v10 = a2;
  v18 = (int)&a2[3];
  v17 = v10;
  v10->__owner = v15;
  v17->__lock = v17->__owner;
  v10->__kind = v16;
  v17->__count = v17->__kind;
  v10->__nusers = v9;
  v10->__spins = v13;
  v10[1].__lock = v14;
  v10[1].__count = a1;
  v10[1].__nusers = *(_DWORD *)(a1 + 40) + 1;
  v10[1].__size[20] = 0;
  pthread_mutex_init(v10 + 2, 0);
  if ( a4 <= 1 )
  {
    v17[1].__owner = 0;
    v17[1].__kind = 0;
  }
  else
  {
    v17[1].__owner = v18;
    v11 = sub_8052608(v17, v18, v15, a4 >> 1, a5, 1);
    v17[1].__kind = v11;
    v18 = sub_8052608(v17, v11, v16, a4 - (a4 >> 1), a5, 0);
  }
  return v18;
}
// 8061521: using guessed type int sub_8061521(void);
// 806B2C0: using guessed type int dword_806B2C0;

//----- (080527C9) --------------------------------------------------------
_BOOL4 __cdecl sub_80527C9(_DWORD *a1, _DWORD *a2)
{
  _BOOL4 result; // eax

  if ( a1[10] == a2[10] )
    result = a1[5] + a1[6] < (unsigned int)(a2[5] + a2[6]);
  else
    result = a1[10] < a2[10];
  return result;
}

//----- (08052828) --------------------------------------------------------
int __cdecl sub_8052828(pthread_mutex_t *a1)
{
  return pthread_mutex_lock(a1 + 2);
}

//----- (0805283E) --------------------------------------------------------
int __cdecl sub_805283E(pthread_mutex_t *a1)
{
  return pthread_mutex_unlock(a1 + 2);
}

//----- (08052885) --------------------------------------------------------
int __cdecl sub_8052885(int a1, int a2)
{
  *(_DWORD *)a1 = sub_8058F5C((int (*)())sub_80527C9, 2 * a2);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 4), 0);
  return pthread_cond_init((pthread_cond_t *)(a1 + 28), 0);
}

//----- (080528D3) --------------------------------------------------------
int __cdecl sub_80528D3(int a1, int a2)
{
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 4));
  sub_8058FFB(*(_DWORD *)a1, a2);
  *(_BYTE *)(a2 + 44) = 1;
  pthread_cond_signal((pthread_cond_t *)(a1 + 28));
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 4));
}

//----- (08052920) --------------------------------------------------------
pthread_mutex_t *__cdecl sub_8052920(int a1)
{
  int v1; // edx
  int v2; // ecx
  pthread_mutex_t *v4; // [esp+1Ch] [ebp-Ch]

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 4));
  while ( 1 )
  {
    v4 = (pthread_mutex_t *)sub_8059084(v1, v2, *(_DWORD *)a1);
    if ( v4 )
      break;
    pthread_cond_wait((pthread_cond_t *)(a1 + 28), (pthread_mutex_t *)(a1 + 4));
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 4));
  sub_8052828(v4);
  v4[1].__size[20] = 0;
  return v4;
}

//----- (08052989) --------------------------------------------------------
int __usercall sub_8052989@<eax>(int a1@<ecx>, long double a2@<st0>, int a3, FILE *stream, int a5)
{
  int result; // eax

  if ( !byte_806C0DC )
    goto LABEL_5;
  if ( !dword_806BCB6 || (result = sub_8050EFF(*(double *)&a2, (int *)a3, &dword_806BCB6)) != 0 )
  {
    dword_806BCB6 = *(_DWORD *)a3;
    dword_806BCBA = *(_DWORD *)(a3 + 4);
    dword_806BCBE = *(_DWORD *)(a3 + 8);
    dword_806BCC2 = *(_DWORD *)(a3 + 12);
LABEL_5:
    result = sub_8051075(a1, a2, a3, stream, a5);
  }
  return result;
}
// 806BCB6: using guessed type int dword_806BCB6;
// 806BCBA: using guessed type int dword_806BCBA;
// 806BCBE: using guessed type int dword_806BCBE;
// 806BCC2: using guessed type int dword_806BCC2;
// 806C0DC: using guessed type char byte_806C0DC;

//----- (080529FC) --------------------------------------------------------
int __usercall sub_80529FC@<eax>(long double a1@<st0>, int a2, int a3, FILE *stream, int a5)
{
  int v5; // ecx
  int *v6; // eax
  _DWORD *v7; // edx
  _DWORD *v8; // eax
  _DWORD *v9; // edx
  _DWORD *v10; // eax
  int v11; // eax
  _DWORD *v12; // edx
  _DWORD *v13; // eax
  int v14; // eax
  _DWORD *v15; // edx
  _DWORD *v16; // eax
  void *v17; // eax
  int v18; // eax
  void *v19; // eax
  int v20; // eax
  bool v21; // zf
  void *v22; // eax
  void *v23; // eax
  int v24; // ecx
  int v25; // eax
  int v26; // ecx
  int v27; // eax
  int result; // eax
  int *v29; // [esp+4h] [ebp-34h]
  unsigned int v30; // [esp+18h] [ebp-20h]
  _DWORD *v31; // [esp+1Ch] [ebp-1Ch]
  _DWORD *v32; // [esp+20h] [ebp-18h]
  int v33; // [esp+24h] [ebp-14h]
  int v34; // [esp+28h] [ebp-10h]
  int v35; // [esp+2Ch] [ebp-Ch]

  v32 = *(_DWORD **)a2;
  v33 = *(_DWORD *)(a2 + 4);
  v5 = 2 * (*(_DWORD *)(a2 + 40) + 1);
  v30 = ((unsigned int)a3 >> v5) + 1;
  if ( *(_DWORD *)(a2 + 40) > 1u )
  {
    v31 = **(_DWORD ***)(a2 + 16);
    while ( *(_DWORD *)a2 != *(_DWORD *)(a2 + 8) )
    {
      if ( *(_DWORD *)(a2 + 4) == *(_DWORD *)(a2 + 12) )
        break;
      v11 = v30--;
      if ( !v11 )
        break;
      v6 = (int *)(*(_DWORD *)a2 - 16);
      v29 = (int *)(*(_DWORD *)(a2 + 4) - 16);
      if ( sub_8050EFF(*(double *)&a1, v6, v29) <= 0 )
      {
        v31 -= 4;
        *(_DWORD *)a2 -= 16;
        v7 = *(_DWORD **)a2;
        v8 = v31;
        *v31 = **(_DWORD **)a2;
        v8[1] = v7[1];
        v8[2] = v7[2];
        v8[3] = v7[3];
        dword_806B2AC = (int)&loc_8052AE5;
        sub_8061591();
      }
      v31 -= 4;
      *(_DWORD *)(a2 + 4) -= 16;
      v9 = *(_DWORD **)(a2 + 4);
      v10 = v31;
      *v31 = *v9;
      v10[1] = v9[1];
      v5 = v9[2];
      v10[2] = v5;
      v10[3] = v9[3];
    }
    v34 = ((signed int)v32 - *(_DWORD *)a2) >> 4;
    v35 = (v33 - *(_DWORD *)(a2 + 4)) >> 4;
    if ( *(_DWORD *)(a2 + 24) == v35 )
    {
      dword_806B2AC = (int)&loc_8052B8B;
      sub_8061591();
      do
      {
        v31 -= 4;
        *(_DWORD *)a2 -= 16;
        v12 = *(_DWORD **)a2;
        v13 = v31;
        *v31 = **(_DWORD **)a2;
        v13[1] = v12[1];
        v5 = v12[2];
        v13[2] = v5;
        v13[3] = v12[3];
        if ( *(_DWORD *)a2 == *(_DWORD *)(a2 + 8) )
          break;
        v14 = v30--;
      }
      while ( v14 );
    }
    else if ( *(_DWORD *)(a2 + 20) == v34 )
    {
      while ( 1 )
      {
        v17 = &loc_8052C15;
        if ( *(_DWORD *)(a2 + 4) == *(_DWORD *)(a2 + 12) )
          v17 = &loc_8052C22;
        dword_806B20C = (int)v17;
        sub_8061930(v5);
        v18 = v30--;
        if ( !v18 )
          break;
        v31 -= 4;
        *(_DWORD *)(a2 + 4) -= 16;
        v15 = *(_DWORD **)(a2 + 4);
        v16 = v31;
        *v31 = *v15;
        v16[1] = v15[1];
        v5 = v15[2];
        v16[2] = v5;
        v16[3] = v15[3];
      }
    }
    **(_DWORD **)(a2 + 16) = v31;
    dword_806B20C = (int)&loc_8052E15;
    sub_8061930(v5);
  }
  v19 = &loc_8052CE4;
  if ( *(_DWORD *)a2 == *(_DWORD *)(a2 + 8) )
    v19 = &loc_8052D1A;
  dword_806B2E4 = (int)v19;
  sub_806141F(*(double *)&a1);
  if ( *(_DWORD *)(a2 + 4) != *(_DWORD *)(a2 + 12) )
  {
    v20 = v30--;
    v21 = v20 == 0;
    v22 = &loc_8052D1A;
    if ( !v21 )
      v22 = &loc_8052C46;
    dword_806B298 = (int)v22;
    sub_8061601();
  }
  v34 = ((signed int)v32 - *(_DWORD *)a2) >> 4;
  v35 = (v33 - *(_DWORD *)(a2 + 4)) >> 4;
  v23 = &loc_8052D63;
  if ( *(_DWORD *)(a2 + 24) != v35 )
    v23 = &loc_8052DC0;
  dword_806B248 = (int)v23;
  sub_80617DA(*(double *)&a1);
  while ( *(_DWORD *)a2 != *(_DWORD *)(a2 + 8) )
  {
    v25 = v30--;
    if ( !v25 )
    {
      dword_806B270 = (int)&loc_8052E15;
      sub_80616F8();
      if ( *(_DWORD *)(a2 + 20) == v34 )
      {
        while ( *(_DWORD *)(a2 + 4) != *(_DWORD *)(a2 + 12) )
        {
          v27 = v30--;
          if ( !v27 )
            break;
          *(_DWORD *)(a2 + 4) -= 16;
          sub_8052989(v26, a1, *(_DWORD *)(a2 + 4), stream, a5);
        }
      }
      break;
    }
    *(_DWORD *)a2 -= 16;
    sub_8052989(v24, a1, *(_DWORD *)a2, stream, a5);
  }
  v34 = ((signed int)v32 - *(_DWORD *)a2) >> 4;
  v35 = (v33 - *(_DWORD *)(a2 + 4)) >> 4;
  *(_DWORD *)(a2 + 20) -= v34;
  result = a2;
  *(_DWORD *)(a2 + 24) -= v35;
  return result;
}
// 80529FC: could not find valid save-restore pair for ebx
// 806141F: using guessed type int __usercall sub_806141F@<eax>(double@<st0>);
// 8061591: using guessed type int sub_8061591(void);
// 8061601: using guessed type int sub_8061601(void);
// 80616F8: using guessed type int sub_80616F8(void);
// 80617DA: using guessed type int __usercall sub_80617DA@<eax>(double@<st0>);
// 8061930: using guessed type int __fastcall sub_8061930(_DWORD);
// 806B20C: using guessed type int dword_806B20C;
// 806B248: using guessed type int dword_806B248;
// 806B270: using guessed type int dword_806B270;
// 806B298: using guessed type int dword_806B298;
// 806B2AC: using guessed type int dword_806B2AC;
// 806B2E4: using guessed type int dword_806B2E4;

//----- (08052E5E) --------------------------------------------------------
int __cdecl sub_8052E5E(int a1, int a2)
{
  int result; // eax
  bool v3; // al
  bool v4; // al
  void *v5; // eax
  bool v6; // zf
  void *v7; // eax

  result = *(unsigned __int8 *)(a2 + 44) ^ 1;
  if ( *(_BYTE *)(a2 + 44) != 1 )
  {
    if ( (unsigned int)(*(_DWORD *)a2 - *(_DWORD *)(a2 + 8) + 15) > 0x1E )
    {
      v3 = (unsigned int)(*(_DWORD *)(a2 + 4) - *(_DWORD *)(a2 + 12) + 15) > 0x1E || !*(_DWORD *)(a2 + 24);
      v4 = v3;
    }
    else
    {
      v5 = &loc_8052EF7;
      if ( (unsigned int)(*(_DWORD *)(a2 + 4) - *(_DWORD *)(a2 + 12) + 15) <= 0x1E )
        v5 = &loc_8052F08;
      dword_806B304 = (int)v5;
      sub_8061308();
      v4 = *(_DWORD *)(a2 + 20) == 0;
    }
    v6 = v4 == 0;
    v7 = &loc_8052F2D;
    if ( v6 )
      v7 = &locret_8052F3F;
    dword_806B25C = (int)v7;
    sub_806176A();
    result = sub_80528D3(a1, a2);
  }
  return result;
}
// 8052E5E: could not find valid save-restore pair for ebx
// 8061308: using guessed type int sub_8061308(void);
// 806176A: using guessed type int sub_806176A(void);
// 806B25C: using guessed type int dword_806B25C;
// 806B304: using guessed type int dword_806B304;

//----- (08052F41) --------------------------------------------------------
int __cdecl sub_8052F41(int a1, int a2)
{
  unsigned int v2; // eax

  v2 = *(_DWORD *)(a2 + 40);
  dword_806B2D0 = sub_8052FA8;
  if ( v2 > 1 )
  {
    sub_8052828(*(pthread_mutex_t **)(a2 + 28));
    sub_8052E5E(a1, *(_DWORD *)(a2 + 28));
    sub_805283E(*(pthread_mutex_t **)(a2 + 28));
    dword_806B2D0 = (int (__cdecl *)(_DWORD))&locret_8052FE1;
  }
  return dword_806B2D0(a1);
}
// 8052FA8: using guessed type int __cdecl sub_8052FA8(int);
// 806B2D0: using guessed type int (__cdecl *dword_806B2D0)(_DWORD);

//----- (08052FA8) --------------------------------------------------------
#error "8052FE2: positive sp value has been found (funcsize=17)"

//----- (08052FE3) --------------------------------------------------------
int __cdecl sub_8052FE3(int a1)
{
  pthread_mutex_t *v1; // eax
  int v2; // edx
  int v3; // ecx
  unsigned int v4; // eax
  pthread_mutex_t *v6; // [esp+1Ch] [ebp-Ch]

  v1 = sub_8052920(a1);
  v6 = v1;
  v4 = v1[1].__nusers;
  dword_806B328 = (int (__fastcall *)(_DWORD, _DWORD))sub_8053043;
  if ( !v4 )
  {
    sub_805283E(v6);
    sub_80528D3(a1, (int)v6);
    dword_806B328 = (int (__fastcall *)(_DWORD, _DWORD))sub_80530A5;
  }
  return dword_806B328(v3, v2);
}
// 80530A5: using guessed type int sub_80530A5();
// 806B328: using guessed type int (__fastcall *dword_806B328)(_DWORD, _DWORD);

//----- (08053043) --------------------------------------------------------
#error "805305E: call analysis failed (funcsize=29)"

//----- (080530A5) --------------------------------------------------------
#error "80530A6: positive sp value has been found (funcsize=0)"

//----- (080530A7) --------------------------------------------------------
void *__cdecl start_routine(void *a1)
{
  sub_8053114(
    *(_DWORD *)a1,
    *((_DWORD *)a1 + 1),
    *((_DWORD *)a1 + 2),
    *((_DWORD **)a1 + 3),
    *((_DWORD *)a1 + 4),
    *((_DWORD *)a1 + 5),
    *((_DWORD *)a1 + 6));
  return 0;
}

//----- (08053114) --------------------------------------------------------
int __cdecl sub_8053114(int a1, unsigned int a2, int a3, _DWORD *a4, int a5, int a6, int a7)
{
  int v7; // eax
  pthread_t newthread; // [esp+28h] [ebp-40h]
  unsigned int v10; // [esp+2Ch] [ebp-3Ch]
  unsigned int v11; // [esp+30h] [ebp-38h]
  unsigned int v12; // [esp+34h] [ebp-34h]
  int arg; // [esp+44h] [ebp-24h]
  unsigned int v14; // [esp+48h] [ebp-20h]
  int v15; // [esp+4Ch] [ebp-1Ch]
  int v16; // [esp+50h] [ebp-18h]
  int v17; // [esp+54h] [ebp-14h]
  int v18; // [esp+58h] [ebp-10h]
  int v19; // [esp+5Ch] [ebp-Ch]

  v10 = a4[5] + a4[6];
  v11 = a2 >> 1;
  v12 = a2 - (a2 >> 1);
  arg = a1;
  v14 = a2 >> 1;
  v15 = a3;
  v16 = a4[8];
  v17 = a5;
  v18 = a6;
  v19 = a7;
  dword_806B2D0 = (int (__cdecl *)(_DWORD))sub_8053245;
  if ( a2 > 1 )
  {
    dword_806B2D0 = (int (__cdecl *)(_DWORD))sub_8053245;
    if ( v10 > 0x1FFFF )
    {
      v7 = pthread_create(&newthread, 0, start_routine, &arg);
      dword_806B2D0 = (int (__cdecl *)(_DWORD))sub_8053245;
      if ( !v7 )
      {
        sub_8053114(a1 - 16 * a4[5], v12, a3, a4[9], a5, a6, a7);
        pthread_join(newthread, 0);
        dword_806B2D0 = (int (__cdecl *)(_DWORD))&locret_8053376;
      }
    }
  }
  return dword_806B2D0(a1);
}
// 8053245: using guessed type int __cdecl sub_8053245(int, int, int);
// 806B2D0: using guessed type int (__cdecl *dword_806B2D0)(_DWORD);

//----- (08053245) --------------------------------------------------------
#error "8053377: positive sp value has been found (funcsize=95)"

//----- (08053378) --------------------------------------------------------
int __usercall sub_8053378@<eax>(long double a1@<st0>, int a2, int a3, int a4, char *s1)
{
  int result; // eax
  void *v6; // eax
  void *v7; // eax
  char v8; // al
  char v9; // [esp+21h] [ebp-D7h]
  char v10; // [esp+22h] [ebp-D6h]
  bool v11; // [esp+23h] [ebp-D5h]
  FILE *stream; // [esp+24h] [ebp-D4h]
  _BYTE *v13; // [esp+28h] [ebp-D0h]
  unsigned int i; // [esp+2Ch] [ebp-CCh]
  __int64 v15; // [esp+30h] [ebp-C8h]
  __int64 v16; // [esp+88h] [ebp-70h]
  __int64 v17; // [esp+90h] [ebp-68h]
  __int64 v18; // [esp+E8h] [ebp-10h]

  v9 = 0;
  v13 = 0;
  for ( i = a3; ; ++i )
  {
    result = i;
    if ( i >= a4 )
      break;
    v11 = strcmp(*(const char **)(8 * i + a2), "-") == 0;
    if ( s1 && !strcmp(s1, *(const char **)(8 * i + a2)) && v11 != 1 )
    {
      v10 = 1;
    }
    else
    {
      if ( v9 != 1 )
      {
        result = sub_806110B(1, (int)&v15);
        if ( result )
          return result;
        v9 = 1;
      }
      v6 = &loc_805346D;
      if ( !v11 )
        v6 = &loc_8053486;
      dword_806B2E4 = (int)v6;
      sub_806141F(*(double *)&a1);
      if ( sub_806110B(0, (int)&v17) || v18 != v16 )
      {
        v8 = 0;
      }
      else
      {
        v7 = &loc_80534FC;
        if ( v17 != v15 )
          v7 = &loc_8053503;
        dword_806B33C = (int)v7;
        sub_8061194(v17, HIDWORD(v15));
        v8 = 1;
      }
      v10 = v8 & 1;
    }
    if ( v10 )
    {
      if ( !v13 )
      {
        v13 = sub_804C7C8(*(double *)&a1, &stream);
        sub_80520CF(a1, 8 * i + a2, 0, 1, stream, (int)(v13 + 9));
      }
      *(_DWORD *)(8 * i + a2) = v13 + 9;
      *(_DWORD *)(a2 + 8 * i + 4) = v13;
    }
  }
  return result;
}
// 8061194: using guessed type int __fastcall sub_8061194(_DWORD, _DWORD);
// 806141F: using guessed type int __usercall sub_806141F@<eax>(double@<st0>);
// 806B2E4: using guessed type int dword_806B2E4;
// 806B33C: using guessed type int dword_806B33C;

//----- (080535D8) --------------------------------------------------------
unsigned int __cdecl sub_80535D8(int a1, unsigned int a2)
{
  bool v2; // zf
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  unsigned int result; // eax
  unsigned int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a2 )
      break;
    v2 = strcmp(*(const char **)(4 * i + a1), "-") == 0;
    v5 = &loc_8053629;
    if ( !v2 )
      v5 = &loc_805362B;
    dword_806B284 = (int)v5;
    sub_8061671(v4, v3);
  }
  return result;
}
// 8061671: using guessed type int __fastcall sub_8061671(_DWORD, _DWORD);
// 806B284: using guessed type int dword_806B284;

//----- (0805368F) --------------------------------------------------------
int __usercall sub_805368F@<eax>(double st7_0@<st0>, int a1)
{
  void *v2; // eax
  char *v3; // eax
  int v4; // ecx
  int fd; // [esp+1Ch] [ebp-Ch]

  v2 = &loc_80536B4;
  if ( !a1 )
    v2 = &locret_805370C;
  dword_806B248 = (int)v2;
  sub_80617DA(st7_0);
  fd = open64(a1, 524353);
  if ( fd < 0 )
  {
    v3 = gettext("open failed");
    sub_804B8B7(v4, a1, (int)v3, a1);
  }
  return sub_804C48E(fd, 1);
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 80617DA: using guessed type int __usercall sub_80617DA@<eax>(double@<st0>);
// 806B248: using guessed type int dword_806B248;

//----- (0805370E) --------------------------------------------------------
void __usercall sub_805370E(long double a1@<st0>, int a2, int a3, int a4, char *s1)
{
  _BYTE *v5; // eax
  int v6; // esi
  int v7; // eax
  int v8; // eax
  _BYTE *v9; // eax
  int v10; // ebx
  int v11; // eax
  int v12; // eax
  int v13; // eax
  char *v14; // eax
  int v15; // ecx
  int v16; // ebx
  char *v17; // eax
  int v18; // edx
  int v19; // ecx
  int v20; // eax
  int v21; // eax
  void *v22; // [esp+28h] [ebp-50h]
  FILE *v23; // [esp+2Ch] [ebp-4Ch]
  int v24; // [esp+30h] [ebp-48h]
  unsigned int v25; // [esp+34h] [ebp-44h]
  int v26; // [esp+38h] [ebp-40h]
  _BYTE *v27; // [esp+3Ch] [ebp-3Ch]
  unsigned int v28; // [esp+40h] [ebp-38h]
  int v29; // [esp+44h] [ebp-34h]
  unsigned int v30; // [esp+48h] [ebp-30h]
  int v31; // [esp+4Ch] [ebp-2Ch]
  _BYTE *v32; // [esp+50h] [ebp-28h]
  unsigned int v33; // [esp+54h] [ebp-24h]
  FILE *stream; // [esp+58h] [ebp-20h]
  _BYTE *v35; // [esp+5Ch] [ebp-1Ch]
  int v36; // [esp+84h] [ebp+Ch]

  while ( dword_806B3F8 < (unsigned int)a4 )
  {
    v24 = 0;
    v25 = 0;
    while ( a4 - v24 >= (unsigned int)dword_806B3F8 )
    {
      v5 = sub_804C7C8(*(double *)&a1, &v23);
      v27 = v5;
      v6 = (int)(v5 + 9);
      v7 = a3;
      if ( dword_806B3F8 <= (unsigned int)a3 )
        v7 = dword_806B3F8;
      v28 = sub_80520CF(a1, 8 * v24 + a2, v7, dword_806B3F8, v23, v6);
      v8 = a3;
      if ( v28 <= a3 )
        v8 = v28;
      a3 -= v8;
      *(_DWORD *)(8 * v25 + a2) = v27 + 9;
      *(_DWORD *)(a2 + 8 * v25 + 4) = v27;
      v24 += v28;
      ++v25;
    }
    v29 = a4 - v24;
    v30 = dword_806B3F8 - v25 % dword_806B3F8;
    if ( dword_806B3F8 - v25 % dword_806B3F8 < a4 - v24 )
    {
      v31 = v29 - v30 + 1;
      v9 = sub_804C7C8(*(double *)&a1, &v23);
      v32 = v9;
      v10 = (int)(v9 + 9);
      v11 = a3;
      if ( v31 <= (unsigned int)a3 )
        v11 = v31;
      v33 = sub_80520CF(a1, 8 * v24 + a2, v11, v31, v23, v10);
      v12 = a3;
      if ( v33 <= a3 )
        v12 = v33;
      a3 -= v12;
      *(_DWORD *)(8 * v25 + a2) = v32 + 9;
      v13 = v25++;
      *(_DWORD *)(a2 + 8 * v13 + 4) = v32;
      v24 += v33;
    }
    memmove((void *)(8 * v25 + a2), (const void *)(a2 + 8 * v24), 8 * (a4 - v24));
    a3 += v25;
    a4 += v25 - v24;
  }
  sub_8053378(a1, a2, a3, a4, s1);
  while ( 1 )
  {
    v26 = sub_805163A(*(double *)&a1, a2, a4, (int *)&v22);
    if ( v26 == a4 )
      break;
    if ( (unsigned int)v26 <= 2 )
    {
      v16 = *(_DWORD *)(8 * v26 + a2);
      v17 = gettext("open failed");
      sub_804B8B7(v19, v18, (int)v17, v16);
    }
    do
    {
LABEL_27:
      --v26;
      sub_804C3CA(*(double *)&a1, *((FILE **)v22 + v26), *(_DWORD *)(8 * v26 + a2));
      v35 = sub_804C667(*(double *)&a1, &v23, (unsigned int)v26 > 2);
    }
    while ( !v35 );
    v20 = a3;
    if ( v26 <= (unsigned int)a3 )
      v20 = v26;
    sub_8051733(a1, a2, v20, v26, v23, (int)(v35 + 9), v22);
    v21 = a3;
    if ( v26 <= (unsigned int)a3 )
      v21 = v26;
    v36 = a3 - v21;
    *(_DWORD *)a2 = v35 + 9;
    *(_DWORD *)(a2 + 4) = v35;
    memmove((void *)(a2 + 8), (const void *)(a2 + 8 * v26), 8 * (a4 - v26));
    a3 = v36 + 1;
    a4 = a4 - v26 + 1;
  }
  stream = sub_804C234(*(double *)&a1, s1, "w");
  if ( !stream )
  {
    if ( *__errno_location() != 24 || (unsigned int)v26 <= 2 )
    {
      v14 = gettext("open failed");
      sub_804B8B7(v15, (int)s1, (int)v14, (int)s1);
    }
    goto LABEL_27;
  }
  sub_8051733(a1, a2, a3, a4, stream, (int)s1, v22);
}
// 806B3F4: using guessed type int dword_806B3F4;

//----- (08053B07) --------------------------------------------------------
int __usercall __noreturn sub_8053B07@<eax>(long double a1@<st0>, char **a2, unsigned int a3, char *a4, unsigned int a5)
{
  int v5; // eax
  int v6; // edx
  int v7; // ecx
  void *v8; // eax
  int v9; // ecx
  int (*v10)(); // eax
  char **v12; // [esp+2Ch] [ebp-BCh]
  char v13; // [esp+3Fh] [ebp-A9h]
  FILE *stream; // [esp+40h] [ebp-A8h]
  FILE *v15; // [esp+44h] [ebp-A4h]
  int v16; // [esp+48h] [ebp-A0h]
  int v17; // [esp+4Ch] [ebp-9Ch]
  int v18; // [esp+50h] [ebp-98h]
  unsigned int v19; // [esp+54h] [ebp-94h]
  int v20; // [esp+58h] [ebp-90h]
  int v21; // [esp+5Ch] [ebp-8Ch]
  int v22; // [esp+60h] [ebp-88h]
  char *s1; // [esp+64h] [ebp-84h]
  int v24; // [esp+68h] [ebp-80h]
  pthread_mutex_t *v25; // [esp+6Ch] [ebp-7Ch]
  void *v26; // [esp+70h] [ebp-78h]
  void *ptr; // [esp+74h] [ebp-74h]
  int v28; // [esp+78h] [ebp-70h]
  unsigned int v29; // [esp+7Ch] [ebp-6Ch]
  int v30; // [esp+80h] [ebp-68h]
  int v31; // [esp+84h] [ebp-64h]
  char v32; // [esp+8Ch] [ebp-5Ch]
  char v33; // [esp+90h] [ebp-58h]
  unsigned int v34; // [esp+DCh] [ebp-Ch]

  v12 = a2;
  v34 = __readgsdword(0x14u);
  v16 = 0;
  v13 = 0;
  v30 = 0;
  while ( a3 )
  {
    s1 = *v12;
    stream = sub_804C370(*(double *)&a1, s1, "r");
    if ( a5 <= 1 )
    {
      v18 = 24;
    }
    else
    {
      v19 = 1;
      v20 = 1;
      while ( v19 < a5 )
      {
        v19 *= 2;
        ++v20;
      }
      v18 = 16 * v20;
    }
    if ( !v30 )
    {
      v5 = sub_804D571((int)&stream, 1u, (int)v12, a3, v18);
      sub_804D758((int)&ptr, v18, v5);
    }
    v32 = 0;
    ++v12;
    --a3;
    while ( (unsigned __int8)sub_804DCDE(*(double *)&a1, (int)&ptr, stream, (int)s1) )
    {
      if ( v32 && a3 && v18 + 1 < v30 - v28 - v18 * v29 )
      {
        v31 = v28;
        break;
      }
      dword_806BCB6 = 0;
      v24 = sub_804D7DE(&ptr);
      if ( !v32 || a3 || v16 || v31 )
      {
        ++v16;
        v17 = (int)(sub_804C7C8(*(double *)&a1, &v15) + 9);
      }
      else
      {
        sub_804C3CA(*(double *)&a1, stream, (int)s1);
        v15 = sub_804C370(*(double *)&a1, a4, "w");
        v17 = (int)a4;
        v13 = 1;
      }
      if ( v29 <= 1 )
      {
        sub_8052989(v24 - 16, a1, v24 - 16, v15, v17);
      }
      else
      {
        sub_8052885((int)&v33, a5);
        v25 = sub_80524D9(a5, v29, v24);
        sub_8053114(v24, a5, v29, &v25[3].__lock, (int)&v33, (int)v15, v17);
      }
      sub_804C3CA(*(double *)&a1, v15, v17);
      if ( v13 )
        goto LABEL_28;
    }
    sub_804C3CA(*(double *)&a1, stream, (int)s1);
  }
LABEL_28:
  free(ptr);
  if ( v13 != 1 )
  {
    v21 = dword_806C16A;
    v26 = (void *)sub_805DFF6(v16, 8u);
    v22 = 0;
    v8 = &loc_8053EC2;
    if ( v21 )
      v8 = &loc_8053E53;
    dword_806B33C = (int)v8;
    sub_8061194(v7, v6);
    sub_805370E(a1, (int)v26, v16, v16, a4);
    free(v26);
  }
  sub_804BF40(*(double *)&a1);
  v10 = (int (*)())&loc_8053F20;
  if ( __readgsdword(0x14u) == v34 )
    v10 = sub_8053F25;
  dword_806B20C = (int)v10;
  return sub_8061930(v9);
}
// 8053F25: using guessed type int sub_8053F25();
// 8061194: using guessed type int __fastcall sub_8061194(_DWORD, _DWORD);
// 8061930: using guessed type int __fastcall sub_8061930(_DWORD);
// 806B20C: using guessed type int dword_806B20C;
// 806B33C: using guessed type int dword_806B33C;
// 806BCB6: using guessed type int dword_806BCB6;
// 806C16A: using guessed type int dword_806C16A;

//----- (08053F25) --------------------------------------------------------
#error "8053F2B: positive sp value has been found (funcsize=0)"

//----- (08053F2E) --------------------------------------------------------
int __cdecl sub_8053F2E(void *src)
{
  sub_805E2B8(src, 0x28u);
  dword_806B2D0 = (int (__cdecl *)(_DWORD))&loc_8053F6F;
  return ((int (__cdecl *)(void *))loc_8053F6F)(src);
}
// 806B2D0: using guessed type int (__cdecl *dword_806B2D0)(_DWORD);

//----- (08053F64) --------------------------------------------------------
#error "8053F9D: positive sp value has been found (funcsize=17)"

//----- (08053F9E) --------------------------------------------------------
unsigned int __usercall sub_8053F9E@<eax>(double a1@<st0>, int a2, char *msgid)
{
  void *v3; // esi
  char *v4; // ebx
  char *v5; // eax

  v3 = sub_805BC38(a1, (char *)a2);
  v4 = gettext(msgid);
  v5 = gettext("%s: invalid field specification %s");
  error(2, 0, v5, v4, v3);
  return sub_8053FEC(a2);
}

//----- (08053FEC) --------------------------------------------------------
unsigned int __cdecl sub_8053FEC(int a1)
{
  char *v1; // eax
  int v2; // edx
  int v3; // ecx
  void *v4; // eax
  unsigned int v6; // [esp+24h] [ebp-Ch]

  v1 = gettext("options '-%s' are incompatible");
  error(2, 0, v1, a1);
  v6 = __readgsdword(0x14u);
  v4 = &loc_80540FD;
  if ( dword_806C0DE )
    v4 = &loc_805403B;
  dword_806B284 = (int)v4;
  sub_8061671(v3, v2);
  return __readgsdword(0x14u) ^ v6;
}
// 8061671: using guessed type int __fastcall sub_8061671(_DWORD, _DWORD);
// 806B284: using guessed type int dword_806B284;
// 806C0DE: using guessed type int dword_806C0DE;

//----- (08054110) --------------------------------------------------------
int __usercall sub_8054110@<eax>(double a1@<st0>, char *nptr, int a3, char *msgid)
{
  int v4; // edx
  int v5; // ecx
  void *v6; // eax
  void *v7; // esi
  char *v8; // ebx
  char *v9; // eax
  int result; // eax
  char *v11; // [esp+Ch] [ebp-2Ch]
  void *v12; // [esp+10h] [ebp-28h]
  int v13; // [esp+24h] [ebp-14h]
  __int64 v14; // [esp+28h] [ebp-10h]

  switch ( sub_805EC9C(a1, nptr, (int)&v13, 10, (int)&v14, &s) )
  {
    case 0:
    case 2:
      *(_DWORD *)a3 = v14;
      v6 = &loc_8054197;
      if ( v14 != *(_DWORD *)a3 )
        v6 = &loc_8054199;
      dword_806B2E4 = (int)v6;
      sub_806141F(a1);
      goto LABEL_9;
    case 1:
    case 3:
      *(_DWORD *)a3 = -1;
      dword_806B234 = (int)&loc_805420C;
      sub_806184C(v5, v4);
      goto LABEL_6;
    case 4:
LABEL_6:
      if ( msgid )
      {
        v7 = sub_805BC38(a1, nptr);
        v8 = gettext(msgid);
        v9 = gettext("%s: invalid count at start of %s");
        v12 = v7;
        v11 = v8;
        error(2, 0, v9, v8, v7);
      }
      result = 0;
      break;
    default:
LABEL_9:
      result = v13;
      break;
  }
  return result;
}
// 806141F: using guessed type int __usercall sub_806141F@<eax>(double@<st0>);
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD, _DWORD);
// 806B234: using guessed type int dword_806B234;
// 806B2E4: using guessed type int dword_806B2E4;

//----- (08054216) --------------------------------------------------------
int __cdecl sub_8054216(int sig)
{
  int v1; // ecx

  sub_804BF5F(v1);
  signal(sig, 0);
  return raise(sig);
}

//----- (08054241) --------------------------------------------------------
char *__cdecl sub_8054241(char *a1, int a2, int a3)
{
  int v3; // ecx
  void *v4; // eax
  char *result; // eax

  dword_806B304 = (int)&loc_8054361;
  sub_8061308();
  while ( 2 )
  {
    switch ( *a1 )
    {
      case 77:
        *(_BYTE *)(a2 + 30) = 1;
        goto LABEL_24;
      case 82:
        *(_BYTE *)(a2 + 27) = 1;
        goto LABEL_24;
      case 86:
        *(_BYTE *)(a2 + 32) = 1;
        goto LABEL_24;
      case 98:
        if ( !a3 || a3 == 2 )
          *(_BYTE *)(a2 + 24) = 1;
        v4 = &loc_80542AB;
        if ( a3 == 1 )
          v4 = &loc_80542B1;
        dword_806B318 = (int)v4;
        sub_8061268(v3);
        if ( a3 == 2 )
        {
          *(_BYTE *)(a2 + 25) = 1;
          dword_806B2C0 = (int)&loc_805435D;
          sub_8061521();
        }
        goto LABEL_24;
      case 100:
        *(_DWORD *)(a2 + 16) = &unk_806BECA;
        goto LABEL_24;
      case 102:
        *(_DWORD *)(a2 + 20) = byte_806BFCA;
        goto LABEL_24;
      case 103:
        *(_BYTE *)(a2 + 28) = 1;
        dword_806B20C = (int)&loc_805435D;
        sub_8061930(v3);
        goto LABEL_14;
      case 104:
LABEL_14:
        *(_BYTE *)(a2 + 29) = 1;
        goto LABEL_24;
      case 105:
        if ( !*(_DWORD *)(a2 + 16) )
          *(_DWORD *)(a2 + 16) = &unk_806BDCA;
        goto LABEL_24;
      case 110:
        *(_BYTE *)(a2 + 26) = 1;
        goto LABEL_24;
      case 114:
        *(_BYTE *)(a2 + 31) = 1;
LABEL_24:
        if ( *++a1 )
          continue;
        result = a1;
        break;
      default:
        result = a1;
        break;
    }
    return result;
  }
}
// 8061268: using guessed type int __fastcall sub_8061268(_DWORD);
// 8061308: using guessed type int sub_8061308(void);
// 8061521: using guessed type int sub_8061521(void);
// 8061930: using guessed type int __fastcall sub_8061930(_DWORD);
// 806B20C: using guessed type int dword_806B20C;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B304: using guessed type int dword_806B304;
// 806B318: using guessed type int dword_806B318;

//----- (08054374) --------------------------------------------------------
void *__cdecl sub_8054374(void *s)
{
  memset(s, 0, 0x28u);
  *((_DWORD *)s + 2) = -1;
  return s;
}

//----- (080543A4) --------------------------------------------------------
void __usercall main(double a1@<st0>, int argc, char **argv)
{
  void *v3; // eax
  unsigned __int8 **v4; // eax
  unsigned __int8 v5; // al
  unsigned __int8 v6; // al
  void *v7; // eax
  void *v8; // eax
  int v9; // edx
  int v10; // ecx
  void *v11; // eax
  int v12; // edx
  int v13; // ecx
  int (__cdecl *v14)(int, char *, char *, int, int, int, int, int, int, int, char, char, int, int, int, int, int, int, size_t, void *, char *, char *, int, int, int, int, int, int, int, FILE *, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, char, int, int, int, int, int, char, char, char, int, int, int); // eax
  int v15; // eax
  _DWORD *v16; // ecx
  int v17; // eax
  char v18; // al
  _BOOL4 v19; // eax
  int v20; // edx
  int v21; // ecx
  void *v22; // eax
  int v23; // eax
  char *v24; // eax
  int v25; // ecx
  bool v26; // zf
  void *v27; // eax
  void *v28; // eax
  int v29; // eax
  signed int v30; // eax
  char *v31; // eax
  int v32; // eax
  int v33; // eax
  int v34; // eax
  void *v35; // eax
  char *v36; // eax
  void *v37; // eax
  void *v38; // eax
  char *v39; // eax
  void *v40; // eax
  char *v41; // eax
  void *v42; // ebx
  char *v43; // eax
  char *v44; // eax
  void *v45; // [esp+Ch] [ebp-170h]
  const char *v46; // [esp+10h] [ebp-16Ch]
  const char *v47; // [esp+14h] [ebp-168h]
  int v48; // [esp+18h] [ebp-164h]
  char v49; // [esp+2Dh] [ebp-14Fh]
  char v50; // [esp+2Eh] [ebp-14Eh]
  char v51; // [esp+2Fh] [ebp-14Dh]
  char v52; // [esp+30h] [ebp-14Ch]
  bool v53; // [esp+31h] [ebp-14Bh]
  bool v54; // [esp+32h] [ebp-14Ah]
  char v55; // [esp+33h] [ebp-149h]
  bool v56; // [esp+34h] [ebp-148h]
  char v57; // [esp+35h] [ebp-147h]
  char v58; // [esp+36h] [ebp-146h]
  char v59; // [esp+37h] [ebp-145h]
  _DWORD *v60; // [esp+38h] [ebp-144h]
  char *v61; // [esp+3Ch] [ebp-140h]
  int v62; // [esp+40h] [ebp-13Ch]
  const char *v63; // [esp+44h] [ebp-138h]
  int v64; // [esp+48h] [ebp-134h]
  int v65; // [esp+4Ch] [ebp-130h]
  int v66; // [esp+50h] [ebp-12Ch]
  char *v67; // [esp+54h] [ebp-128h]
  const char *v68; // [esp+58h] [ebp-124h]
  unsigned int i; // [esp+5Ch] [ebp-120h]
  char *j; // [esp+60h] [ebp-11Ch]
  int v71; // [esp+6Ch] [ebp-110h]
  unsigned __int8 **v72; // [esp+70h] [ebp-10Ch]
  char *v73; // [esp+74h] [ebp-108h]
  char v74; // [esp+90h] [ebp-ECh]
  char s; // [esp+B8h] [ebp-C4h]
  int longind; // [esp+E0h] [ebp-9Ch]
  __sigset_t v77; // [esp+E4h] [ebp-98h]
  int v78; // [esp+164h] [ebp-18h]

  v49 = 0;
  v62 = 0;
  v50 = 0;
  v51 = 0;
  v63 = 0;
  v52 = 0;
  v64 = 0;
  v65 = 0;
  v56 = getenv("POSIXLY_CORRECT") != 0;
  v71 = sub_8059F94();
  if ( v71 > 200111 )
  {
    v3 = &loc_8054432;
    if ( v71 <= 200808 )
      v3 = &loc_8054439;
    dword_806B298 = (int)v3;
    sub_8061601();
  }
  v53 = 1;
  v67 = 0;
  v68 = 0;
  sub_805A00B((int)*argv);
  v54 = setlocale(6, &::s) != 0;
  bindtextdomain("coreutils", "/home/hwangdz/coreutils/coreutils-8.28/install_m32/share/locale");
  textdomain("coreutils");
  sub_804B519(2);
  byte_806BCB2 = sub_80579D4(3);
  byte_806BCB3 = sub_80579D4(2);
  v4 = (unsigned __int8 **)localeconv();
  v72 = v4;
  v5 = sub_804B53E(**v4);
  dword_806BCAA = v5;
  if ( !v5 || (*v72)[1] )
    dword_806BCAA = 46;
  v6 = sub_804B53E(*v72[1]);
  dword_806BCAE = v6;
  if ( !v6 || v72[1][1] )
    dword_806BCAE = -1;
  byte_806C0DD = 0;
  sub_804CBA8();
  sigemptyset(&set);
  for ( i = 0; i <= 0xA; ++i )
  {
    sigaction(sig[i], 0, (struct sigaction *)&longind);
    if ( longind != 1 )
      sigaddset(&set, sig[i]);
  }
  longind = (int)sub_8054216;
  qmemcpy(&v77, &set, sizeof(v77));
  v78 = 0;
  for ( i = 0; i <= 0xA; ++i )
  {
    if ( sigismember(&set, sig[i]) )
      sigaction(sig[i], (const struct sigaction *)&longind, 0);
  }
  signal(17, 0);
  sub_80610AD((int)sub_804BFAC);
  sub_8054374(&s);
  *(_DWORD *)&s = -1;
  v66 = sub_805DFF6(argc, 4u);
  while ( 1 )
  {
    longind = -1;
    if ( v62 == -1 )
      goto LABEL_145;
    if ( v56 && v65 )
    {
      v7 = &loc_80546FF;
      if ( v53 != 1 )
        v7 = &loc_80547CE;
      dword_806B2AC = (int)v7;
      sub_8061591();
      v8 = &loc_805471F;
      if ( v50 )
        v8 = &loc_80547CE;
      dword_806B2E4 = (int)v8;
      sub_806141F(a1);
      if ( optind == argc || *argv[optind] != 45 || argv[optind][1] != 111 || !argv[optind][2] && optind + 1 == argc )
        goto LABEL_145;
    }
    v62 = getopt_long(argc, argv, "-bcCdfghik:mMno:rRsS:t:T:uVy:z", &longopts, &longind);
    if ( v62 == -1 )
    {
LABEL_145:
      v11 = &loc_80547F1;
      if ( argc > optind )
        v11 = &loc_8054828;
      dword_806B304 = (int)v11;
      sub_8061308();
      v14 = (int (__cdecl *)(int, char *, char *, int, int, int, int, int, int, int, char, char, int, int, int, int, int, int, size_t, void *, char *, char *, int, int, int, int, int, int, int, FILE *, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, char, int, int, int, int, int, char, char, char, int, int, int))&loc_8054811;
      if ( v67 )
        v14 = sub_80552B8;
      dword_806B33C = (int)v14;
      sub_8061194(v13, v12);
      dword_806B2C0 = (int)&loc_8055540;
      sub_8061521();
      v15 = v65++;
      v16 = (_DWORD *)(4 * v15 + v66);
      v17 = optind++;
      *v16 = argv[v17];
      dword_806B2AC = (int)&loc_80552B3;
      sub_8061591();
    }
    switch ( v62 )
    {
      case 4294967165:
        v48 = 0;
        v47 = "Paul Eggert";
        v46 = "Mike Haertel";
        sub_805DF56(a1, stdout, (int)"sort", (int)"GNU coreutils", off_806B410, "Mike Haertel", "Paul Eggert", 0);
        exit(0);
        return;
      case 4294967166:
        goto LABEL_138;
      case 1:
        v60 = 0;
        if ( *optarg == 43 )
        {
          v18 = optind == argc || *argv[optind] != 45 || (unsigned int)(argv[optind][1] - 48) > 9 ? 0 : 1;
          v57 = v18 & 1;
          v19 = v18 & 1 && v56 != 1;
          v53 = (v53 || v19) != 0;
          if ( v53 )
          {
            v60 = sub_8054374(&v74);
            v61 = (char *)sub_8054110(a1, optarg + 1, (int)v60, 0);
            if ( v61 )
            {
              v22 = &loc_80549A5;
              if ( *v61 != 46 )
                v22 = &loc_80549CB;
              dword_806B234 = (int)v22;
              sub_806184C(v21, v20);
              v61 = (char *)sub_8054110(a1, v61 + 1, (int)(v60 + 1), 0);
            }
            if ( !*v60 && !v60[1] )
              *v60 = -1;
            if ( v61 && !*sub_8054241(v61, (int)v60, 0) )
            {
              if ( v57 )
              {
                v23 = optind++;
                v73 = argv[v23];
                v24 = (char *)sub_8054110(a1, v73 + 1, (int)(v60 + 2), "invalid number after '-'");
                v61 = v24;
                v26 = v24 == 0;
                v27 = &loc_8054A92;
                if ( !v26 )
                  v27 = &loc_8054AB6;
                dword_806B318 = (int)v27;
                sub_8061268(v25);
                __assert_fail("s", "src/sort.c", 0x110Du, "main");
              }
              *((_BYTE *)v60 + 33) = 1;
              sub_8053F2E(v60);
            }
            else
            {
              v60 = 0;
            }
          }
        }
        v28 = &loc_8054B92;
        if ( v60 )
          v28 = &loc_8054BB6;
        dword_806B2E4 = (int)v28;
        sub_806141F(a1);
        v29 = v65++;
        *(_DWORD *)(v66 + 4 * v29) = optarg;
        continue;
      case 67:
      case 99:
        goto LABEL_77;
      case 77:
      case 82:
      case 86:
      case 98:
      case 100:
      case 102:
      case 103:
      case 104:
      case 105:
      case 110:
      case 114:
        goto LABEL_72;
      case 83:
        sub_804D03F(a1, longind, (char)v62, optarg);
        break;
      case 84:
        sub_804C9BC((int)optarg);
        break;
      case 107:
        v60 = sub_8054374(&v74);
        v61 = (char *)sub_8054110(a1, optarg, (int)v60, "invalid number at field start");
        v32 = (*v60)--;
        if ( !v32 )
          sub_8053F9E(a1, (int)optarg, "field number is zero");
        if ( *v61 == 46 )
        {
          v61 = (char *)sub_8054110(a1, v61 + 1, (int)(v60 + 1), "invalid number after '.'");
          v33 = v60[1];
          v60[1] = v33 - 1;
          if ( !v33 )
            sub_8053F9E(a1, (int)optarg, "character offset is zero");
        }
        if ( !*v60 && !v60[1] )
          *v60 = -1;
        v61 = sub_8054241(v61, (int)v60, 0);
        if ( *v61 == 44 )
        {
          v61 = (char *)sub_8054110(a1, v61 + 1, (int)(v60 + 2), "invalid number after ','");
          v34 = v60[2];
          v60[2] = v34 - 1;
          v26 = v34 == 0;
          v35 = &loc_8054E92;
          if ( !v26 )
            v35 = &loc_8054EA7;
          dword_806B2E4 = (int)v35;
          sub_806141F(a1);
          sub_8053F9E(a1, (int)optarg, "field number is zero");
          if ( *v61 == 46 )
            v61 = (char *)sub_8054110(a1, v61 + 1, (int)(v60 + 3), "invalid number after '.'");
          v61 = sub_8054241(v61, (int)v60, 1);
        }
        else
        {
          v60[2] = -1;
          v60[3] = 0;
        }
        if ( *v61 )
          sub_8053F9E(a1, (int)optarg, "stray character in field spec");
        sub_8053F2E(v60);
        break;
      case 109:
        v51 = 1;
        break;
      case 111:
        if ( v68 && strcmp(v68, optarg) )
        {
          v36 = gettext("multiple output files specified");
          error(2, 0, v36);
        }
        v68 = optarg;
        break;
      case 115:
        byte_806C0DB = 1;
        break;
      case 116:
        v55 = *optarg;
        v40 = &loc_8055093;
        if ( v55 )
          v40 = &loc_80550B7;
        dword_806B304 = (int)v40;
        sub_8061308();
        v41 = gettext("empty tab");
        error(2, 0, v41);
        if ( optarg[1] )
        {
          if ( !strcmp(optarg, "\\0") )
          {
            v55 = 0;
          }
          else
          {
            v42 = sub_805BC38(a1, optarg);
            v43 = gettext("multi-character tab %s");
            v45 = v42;
            error(2, 0, v43, v42);
          }
        }
        if ( dword_806B3F4 != 128 && v55 != dword_806B3F4 )
        {
          v44 = gettext("incompatible tabs");
          error(2, 0, v44);
        }
        dword_806B3F4 = v55;
        break;
      case 117:
        byte_806C0DC = 1;
        break;
      case 121:
        if ( argv[optind + 0x3FFFFFFF] == optarg )
        {
          for ( j = optarg; (unsigned int)(*j - 48) <= 9; ++j )
            ;
          optind -= *j != 0;
          dword_806B25C = (int)&loc_80552B3;
          sub_806176A();
        }
        break;
      case 122:
        byte_806B370 = 0;
        dword_806B248 = (int)&loc_80552B3;
        sub_80617DA(a1);
LABEL_138:
        sub_804B93C(a1, 0);
        return;
      case 128:
        if ( optarg )
          v30 = aCccgeneralNume[sub_8055DC0(
                                  a1,
                                  (int)"--check",
                                  optarg,
                                  (int)off_8062F34,
                                  (int)"CCcgeneral-numeric",
                                  1u,
                                  off_806B414)];
        else
          v30 = 99;
        v62 = v30;
LABEL_77:
        if ( v50 && v50 != v62 )
          sub_8053FEC((int)"cC");
        v50 = v62;
        break;
      case 129:
        if ( s1 && strcmp(s1, optarg) )
        {
          v31 = gettext("multiple compress programs specified");
          error(2, 0, v31);
        }
        s1 = optarg;
        break;
      case 130:
        byte_806C0E6 = 1;
        break;
      case 131:
        v67 = optarg;
        break;
      case 132:
        sub_804CDE0(a1, longind, v62, optarg);
        break;
      case 133:
        v37 = &loc_8054FCE;
        if ( !v63 )
          v37 = &loc_8055024;
        dword_806B284 = (int)v37;
        sub_8061671(v10, v9);
        v26 = strcmp(v63, optarg) == 0;
        v38 = &loc_8055000;
        if ( v26 )
          v38 = &loc_8055024;
        dword_806B248 = (int)v38;
        sub_80617DA(a1);
        v39 = gettext("multiple random sources specified");
        error(2, 0, v39);
        v63 = optarg;
        break;
      case 134:
        v62 = byte_8062F98[sub_8055DC0(a1, (int)"--sort", optarg, (int)&off_8062F7C, (int)byte_8062F98, 1u, off_806B414)];
LABEL_72:
        v58 = v62;
        v59 = 0;
        sub_8054241(&v58, (int)&s, 2);
        break;
      case 135:
        v64 = sub_804D2FD(a1, longind, (char)v62, optarg);
        break;
      default:
        sub_804B93C(a1, 2);
        return;
    }
  }
}
// 80: found interdependent unknown calls
// 8061194: using guessed type int __fastcall sub_8061194(_DWORD, _DWORD);
// 8061268: using guessed type int __fastcall sub_8061268(_DWORD);
// 8061308: using guessed type int sub_8061308(void);
// 806141F: using guessed type int __usercall sub_806141F@<eax>(double@<st0>);
// 8061521: using guessed type int sub_8061521(void);
// 8061591: using guessed type int sub_8061591(void);
// 8061601: using guessed type int sub_8061601(void);
// 8061671: using guessed type int __fastcall sub_8061671(_DWORD, _DWORD);
// 806176A: using guessed type int sub_806176A(void);
// 80617DA: using guessed type int __usercall sub_80617DA@<eax>(double@<st0>);
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD, _DWORD);
// 8062F34: using guessed type char *off_8062F34[3];
// 8062F7C: using guessed type void *off_8062F7C;
// 806B234: using guessed type int dword_806B234;
// 806B248: using guessed type int dword_806B248;
// 806B25C: using guessed type int dword_806B25C;
// 806B284: using guessed type int dword_806B284;
// 806B298: using guessed type int dword_806B298;
// 806B2AC: using guessed type int dword_806B2AC;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B2E4: using guessed type int dword_806B2E4;
// 806B304: using guessed type int dword_806B304;
// 806B318: using guessed type int dword_806B318;
// 806B33C: using guessed type int dword_806B33C;
// 806B370: using guessed type char byte_806B370;
// 806B3F4: using guessed type int dword_806B3F4;
// 806B4C0: using guessed type int optind;
// 806BCAA: using guessed type int dword_806BCAA;
// 806BCAE: using guessed type int dword_806BCAE;
// 806BCB2: using guessed type char byte_806BCB2;
// 806BCB3: using guessed type char byte_806BCB3;
// 806C0DB: using guessed type char byte_806C0DB;
// 806C0DC: using guessed type char byte_806C0DC;
// 806C0DD: using guessed type char byte_806C0DD;
// 806C0E6: using guessed type char byte_806C0E6;

//----- (080552B8) --------------------------------------------------------
#error "8055340: call analysis failed (funcsize=435)"

//----- (08055B01) --------------------------------------------------------
void __usercall __noreturn sub_8055B01(double a1@<st0>)
{
  sub_804B93C(a1, 1);
}

//----- (08055B15) --------------------------------------------------------
int __cdecl sub_8055B15(char *s, int a2)
{
  bool v2; // zf
  void *v3; // eax
  int i; // [esp+14h] [ebp-14h]
  size_t n; // [esp+1Ch] [ebp-Ch]

  n = strlen(s);
  for ( i = 0; ; ++i )
  {
    if ( !*(_DWORD *)(4 * i + a2) )
      return -1;
    if ( !strncmp(*(const char **)(4 * i + a2), s, n) )
      break;
  }
  v2 = strlen(*(const char **)(4 * i + a2)) == n;
  v3 = &loc_8055BA6;
  if ( !v2 )
    v3 = &loc_8055BAB;
  dword_806B304 = (int)v3;
  sub_8061308();
  return i;
}
// 8061308: using guessed type int sub_8061308(void);
// 806B304: using guessed type int dword_806B304;

//----- (08055C26) --------------------------------------------------------
void __usercall sub_8055C26(double a1@<st0>, char *a2, char *a3, int a4)
{
  char *v4; // eax
  char *format; // ST2C_4
  void *v6; // ebx
  void *v7; // eax

  if ( a4 == -1 )
    v4 = gettext("invalid argument %s for %s");
  else
    v4 = gettext("ambiguous argument %s for %s");
  format = v4;
  v6 = sub_805BC16(a1, 1, a2);
  v7 = sub_805B82A(a1, 0, 8, a3);
  error(0, 0, format, v7, v6);
}

//----- (08055CA9) --------------------------------------------------------
int __usercall sub_8055CA9@<eax>(double a1@<st0>, int a2, int a3, size_t n)
{
  FILE *v4; // ebx
  char *v5; // eax
  void *v6; // eax
  void *v7; // eax
  int i; // [esp+18h] [ebp-10h]
  void *s1; // [esp+1Ch] [ebp-Ch]

  s1 = 0;
  v4 = stderr;
  v5 = gettext("Valid arguments are:");
  fputs_unlocked(v5, v4);
  for ( i = 0; *(_DWORD *)(4 * i + a2); ++i )
  {
    if ( i && !memcmp(s1, (const void *)(a3 + i * n), n) )
    {
      v7 = sub_805BC38(a1, *(char **)(4 * i + a2));
      fprintf(stderr, ", %s", v7);
    }
    else
    {
      v6 = sub_805BC38(a1, *(char **)(4 * i + a2));
      fprintf(stderr, "\n  - %s", v6);
      s1 = (void *)(i * n + a3);
    }
  }
  return putc_unlocked(10, stderr);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (08055DC0) --------------------------------------------------------
int __usercall sub_8055DC0@<eax>(double a1@<st0>, int a2, char *s, int a4, int a5, size_t n, int a7)
{
  int v8; // [esp+1Ch] [ebp-Ch]

  v8 = sub_8055B15(s, a4);
  if ( v8 >= 0 )
    return v8;
  sub_8055C26(a1, (char *)a2, s, v8);
  sub_8055CA9(a1, a4, a5, n);
  ((void (*)(void))a7)();
  return -1;
}

//----- (08055ED9) --------------------------------------------------------
int __usercall sub_8055ED9@<eax>(double a1@<st0>)
{
  bool v1; // zf
  void *v2; // eax
  void *v3; // ebx
  int *v4; // eax
  int *v5; // eax
  int result; // eax
  char *v7; // [esp+2Ch] [ebp-Ch]

  v1 = sub_80600C7(stdout) == 0;
  v2 = &loc_8055F0A;
  if ( v1 )
    v2 = &loc_8055FAE;
  dword_806B2C0 = (int)v2;
  sub_8061521();
  if ( byte_806C232 != 1 || *__errno_location() != 32 )
  {
    v7 = gettext("write error");
    if ( dword_806C22E )
    {
      v3 = sub_805B9C3(a1, (char *)dword_806C22E);
      v4 = __errno_location();
      error(0, *v4, "%s: %s", v3, v7);
    }
    else
    {
      v5 = __errno_location();
      error(0, *v5, "%s", v7);
    }
    _exit(status);
  }
  result = sub_80600C7(stderr);
  if ( result )
    _exit(status);
  return result;
}
// 8061521: using guessed type int sub_8061521(void);
// 806B2C0: using guessed type int dword_806B2C0;
// 806C22E: using guessed type int dword_806C22E;
// 806C232: using guessed type char byte_806C232;

//----- (08055FD2) --------------------------------------------------------
_DWORD *__cdecl sub_8055FD2(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 1732584193;
  a1[1] = -271733879;
  a1[2] = -1732584194;
  a1[3] = 271733878;
  a1[5] = 0;
  a1[4] = a1[5];
  result = a1;
  a1[6] = 0;
  return result;
}

//----- (0805601E) --------------------------------------------------------
_DWORD *__cdecl sub_805601E(_DWORD *a1, int a2)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = a2;
  return result;
}

//----- (0805602B) --------------------------------------------------------
_DWORD *__cdecl sub_805602B(int *a1, _DWORD *a2)
{
  sub_805601E(a2, *a1);
  sub_805601E(a2 + 1, a1[1]);
  sub_805601E(a2 + 2, a1[2]);
  sub_805601E(a2 + 3, a1[3]);
  return a2;
}

//----- (08056098) --------------------------------------------------------
_DWORD *__usercall sub_8056098@<eax>(double st7_0@<st0>, int *a1, _DWORD *a2)
{
  signed int v3; // eax
  unsigned int v5; // [esp+18h] [ebp-10h]
  signed int v6; // [esp+1Ch] [ebp-Ch]

  v5 = a1[6];
  if ( v5 > 0x37 )
    v3 = 32;
  else
    v3 = 16;
  v6 = v3;
  a1[4] += v5;
  if ( a1[4] < v5 )
    ++a1[5];
  a1[v3 + 5] = 8 * a1[4];
  a1[v3 + 6] = *((_QWORD *)a1 + 2) >> 29;
  memcpy((char *)a1 + v5 + 28, &unk_8063E88, 4 * (v3 + 1073741822) - v5);
  sub_805659A(st7_0, a1 + 7, 4 * v6, a1);
  return sub_805602B(a1, a2);
}

//----- (08056377) --------------------------------------------------------
int __usercall sub_8056377@<eax>(int a1@<ecx>, double a2@<st0>, void *src, size_t a4, int a5)
{
  int v5; // eax
  void *v6; // eax
  int *v7; // eax
  void *v8; // eax
  size_t v9; // ST1C_4
  int result; // eax
  size_t v11; // [esp+14h] [ebp-14h]
  int v12; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]

  if ( *(_DWORD *)(a5 + 24) )
  {
    v12 = *(_DWORD *)(a5 + 24);
    v5 = a4;
    if ( 128 - v12 <= a4 )
      v5 = 128 - v12;
    n = v5;
    memcpy((void *)(v12 + a5 + 28), src, v5);
    *(_DWORD *)(a5 + 24) += n;
    if ( *(_DWORD *)(a5 + 24) > 0x40u )
    {
      sub_805659A(a2, (int *)(a5 + 28), *(_DWORD *)(a5 + 24) & 0xFFFFFFC0, (int *)a5);
      *(_DWORD *)(a5 + 24) &= 0x3Fu;
      memcpy((void *)(a5 + 28), (const void *)(a5 + 28 + ((v12 + n) & 0xFFFFFFC0)), *(_DWORD *)(a5 + 24));
    }
    src = (char *)src + n;
    a4 -= n;
  }
  if ( a4 > 0x3F )
  {
    v6 = &loc_8056485;
    if ( !((unsigned __int8)src & 3) )
      v6 = &loc_80564CB;
    dword_806B20C = (int)v6;
    sub_8061930(a1);
    while ( a4 > 0x40 )
    {
      v7 = (int *)memcpy((void *)(a5 + 28), src, 0x40u);
      sub_805659A(a2, v7, 0x40u, (int *)a5);
      src = (char *)src + 64;
      a4 -= 64;
    }
  }
  v8 = &loc_8056515;
  if ( !a4 )
    v8 = &loc_8056594;
  dword_806B318 = (int)v8;
  sub_8061268(a1);
  v9 = *(_DWORD *)(a5 + 24);
  memcpy((void *)(v9 + a5 + 28), src, a4);
  v11 = a4 + v9;
  if ( v11 > 0x3F )
  {
    sub_805659A(a2, (int *)(a5 + 28), 0x40u, (int *)a5);
    v11 -= 64;
    memcpy((void *)(a5 + 28), (const void *)(a5 + 92), v11);
  }
  result = a5;
  *(_DWORD *)(a5 + 24) = v11;
  return result;
}
// 8061268: using guessed type int __fastcall sub_8061268(_DWORD);
// 8061930: using guessed type int __fastcall sub_8061930(_DWORD);
// 806B20C: using guessed type int dword_806B20C;
// 806B318: using guessed type int dword_806B318;

//----- (0805659A) --------------------------------------------------------
int *__usercall sub_805659A@<eax>(double st7_0@<st0>, int *a1, unsigned int a2, int *a3)
{
  int v4; // ST30_4
  int v5; // ST34_4
  int v6; // ST38_4
  int v7; // ST3C_4
  int v8; // ST40_4
  int v9; // ST10_4
  int *v10; // ST0C_4
  int v11; // ST10_4
  int v12; // ST1C_4
  int v13; // ST18_4
  int v14; // ST14_4
  int v15; // ST10_4
  int v16; // ST1C_4
  int v17; // ST18_4
  int v18; // ST14_4
  int v19; // ST10_4
  int v20; // ST1C_4
  int v21; // ST18_4
  int v22; // ST14_4
  int v23; // ST10_4
  int v24; // ST1C_4
  int v25; // ST18_4
  int v26; // ST14_4
  int v27; // ST10_4
  int v28; // ST1C_4
  int v29; // ST18_4
  int v30; // ST14_4
  int v31; // ST10_4
  int v32; // ST1C_4
  int v33; // ST18_4
  int v34; // ST14_4
  int v35; // ST10_4
  int v36; // ST1C_4
  int v37; // ST18_4
  int v38; // ST14_4
  int v39; // ST10_4
  int v40; // ST1C_4
  int v41; // ST18_4
  int v42; // ST14_4
  int v43; // ST10_4
  int v44; // ST1C_4
  int v45; // ST18_4
  int v46; // ST14_4
  int v47; // ST10_4
  int v48; // ST1C_4
  int v49; // ST18_4
  int v50; // ST14_4
  int v51; // ST10_4
  int v52; // ST1C_4
  int v53; // ST18_4
  int v54; // ST14_4
  int v55; // ST10_4
  int v56; // ST1C_4
  int v57; // ST18_4
  int v58; // ST14_4
  int v59; // ST10_4
  int v60; // ST1C_4
  int v61; // ST18_4
  int v62; // ST14_4
  int v63; // ST10_4
  int v64; // ST1C_4
  int v65; // ST18_4
  int v66; // ST14_4
  int v67; // ST10_4
  int v68; // ST1C_4
  int v69; // ST18_4
  int v70; // ST14_4
  int v71; // ST10_4
  int v72; // ST1C_4
  int v73; // ST18_4
  int v74; // ST14_4
  int *result; // eax
  int *v76; // [esp+Ch] [ebp-74h]
  int v77; // [esp+10h] [ebp-70h]
  int v78; // [esp+14h] [ebp-6Ch]
  int v79; // [esp+18h] [ebp-68h]
  int v80; // [esp+1Ch] [ebp-64h]
  int v81; // [esp+44h] [ebp-3Ch]
  int v82; // [esp+48h] [ebp-38h]
  int v83; // [esp+4Ch] [ebp-34h]
  int v84; // [esp+50h] [ebp-30h]
  int v85; // [esp+54h] [ebp-2Ch]
  int v86; // [esp+58h] [ebp-28h]
  int v87; // [esp+5Ch] [ebp-24h]
  int v88; // [esp+60h] [ebp-20h]
  int v89; // [esp+64h] [ebp-1Ch]
  int v90; // [esp+68h] [ebp-18h]
  int v91; // [esp+6Ch] [ebp-14h]
  int v92; // [esp+70h] [ebp-10h]
  int v93; // [esp+74h] [ebp-Ch]
  int v94; // [esp+78h] [ebp-8h]
  int v95; // [esp+7Ch] [ebp-4h]

  v76 = a1;
  v77 = *a3;
  v78 = a3[1];
  v79 = a3[2];
  v80 = a3[3];
  a3[4] += a2;
  a3[5] += a3[4] < a2;
  dword_806B248 = (int)&loc_8057245;
  sub_80617DA(st7_0);
  do
  {
    v4 = v77;
    v5 = v78;
    v6 = v79;
    v7 = v80;
    v8 = *v76;
    v9 = (v80 ^ v78 & (v79 ^ v80)) + *v76 + v77 - 680876936;
    v10 = v76 + 1;
    v11 = v78 + __ROR4__(v9, 25);
    v81 = *v10;
    ++v10;
    v12 = v11 + __ROR4__((v79 ^ v11 & (v78 ^ v79)) + v81 + v80 - 389564586, 20);
    v82 = *v10;
    ++v10;
    v13 = v12 + __ROR4__((v78 ^ v12 & (v11 ^ v78)) + v82 + v79 + 606105819, 15);
    v83 = *v10;
    ++v10;
    v14 = v13 + __ROR4__((v11 ^ v13 & (v12 ^ v11)) + v83 + v78 - 1044525330, 10);
    v84 = *v10;
    ++v10;
    v15 = v14 + __ROR4__((v12 ^ v14 & (v13 ^ v12)) + v84 + v11 - 176418897, 25);
    v85 = *v10;
    ++v10;
    v16 = v15 + __ROR4__((v13 ^ v15 & (v14 ^ v13)) + v85 + v12 + 1200080426, 20);
    v86 = *v10;
    ++v10;
    v17 = v16 + __ROR4__((v14 ^ v16 & (v15 ^ v14)) + v86 + v13 - 1473231341, 15);
    v87 = *v10;
    ++v10;
    v18 = v17 + __ROR4__((v15 ^ v17 & (v16 ^ v15)) + v87 + v14 - 45705983, 10);
    v88 = *v10;
    ++v10;
    v19 = v18 + __ROR4__((v16 ^ v18 & (v17 ^ v16)) + v88 + v15 + 1770035416, 25);
    v89 = *v10;
    ++v10;
    v20 = v19 + __ROR4__((v17 ^ v19 & (v18 ^ v17)) + v89 + v16 - 1958414417, 20);
    v90 = *v10;
    ++v10;
    v21 = v20 + __ROR4__((v18 ^ v20 & (v19 ^ v18)) + v90 + v17 - 42063, 15);
    v91 = *v10;
    ++v10;
    v22 = v21 + __ROR4__((v19 ^ v21 & (v20 ^ v19)) + v91 + v18 - 1990404162, 10);
    v92 = *v10;
    ++v10;
    v23 = v22 + __ROR4__((v20 ^ v22 & (v21 ^ v20)) + v92 + v19 + 1804603682, 25);
    v93 = *v10;
    ++v10;
    v24 = v23 + __ROR4__((v21 ^ v23 & (v22 ^ v21)) + v93 + v20 - 40341101, 20);
    v94 = *v10;
    ++v10;
    v25 = v24 + __ROR4__((v22 ^ v24 & (v23 ^ v22)) + v94 + v21 - 1502002290, 15);
    v95 = *v10;
    v76 = v10 + 1;
    v26 = v25 + __ROR4__((v23 ^ v25 & (v24 ^ v23)) + v95 + v22 + 1236535329, 10);
    v27 = v26 + __ROR4__(v81 + (v25 ^ v24 & (v26 ^ v25)) + v23 - 165796510, 27);
    v28 = v27 + __ROR4__(v86 + (v26 ^ v25 & (v27 ^ v26)) + v24 - 1069501632, 23);
    v29 = v28 + __ROR4__(v91 + (v27 ^ v26 & (v28 ^ v27)) + v25 + 643717713, 18);
    v30 = v29 + __ROR4__(v8 + (v28 ^ v27 & (v29 ^ v28)) + v26 - 373897302, 12);
    v31 = v30 + __ROR4__(v85 + (v29 ^ v28 & (v30 ^ v29)) + v27 - 701558691, 27);
    v32 = v31 + __ROR4__(v90 + (v30 ^ v29 & (v31 ^ v30)) + v28 + 38016083, 23);
    v33 = v32 + __ROR4__(v95 + (v31 ^ v30 & (v32 ^ v31)) + v29 - 660478335, 18);
    v34 = v33 + __ROR4__(v84 + (v32 ^ v31 & (v33 ^ v32)) + v30 - 405537848, 12);
    v35 = v34 + __ROR4__(v89 + (v33 ^ v32 & (v34 ^ v33)) + v31 + 568446438, 27);
    v36 = v35 + __ROR4__(v94 + (v34 ^ v33 & (v35 ^ v34)) + v32 - 1019803690, 23);
    v37 = v36 + __ROR4__(v83 + (v35 ^ v34 & (v36 ^ v35)) + v33 - 187363961, 18);
    v38 = v37 + __ROR4__(v88 + (v36 ^ v35 & (v37 ^ v36)) + v34 + 1163531501, 12);
    v39 = v38 + __ROR4__(v93 + (v37 ^ v36 & (v38 ^ v37)) + v35 - 1444681467, 27);
    v40 = v39 + __ROR4__(v82 + (v38 ^ v37 & (v39 ^ v38)) + v36 - 51403784, 23);
    v41 = v40 + __ROR4__(v87 + (v39 ^ v38 & (v40 ^ v39)) + v37 + 1735328473, 18);
    v42 = v41 + __ROR4__(v92 + (v40 ^ v39 & (v41 ^ v40)) + v38 - 1926607734, 12);
    v43 = v42 + __ROR4__(v85 + (v40 ^ v42 ^ v41) + v39 - 378558, 28);
    v44 = v43 + __ROR4__(v88 + (v41 ^ v43 ^ v42) + v40 - 2022574463, 21);
    v45 = v44 + __ROR4__(v91 + (v42 ^ v44 ^ v43) + v41 + 1839030562, 16);
    v46 = v45 + __ROR4__(v94 + (v43 ^ v45 ^ v44) + v42 - 35309556, 9);
    v47 = v46 + __ROR4__(v81 + (v44 ^ v46 ^ v45) + v43 - 1530992060, 28);
    v48 = v47 + __ROR4__(v84 + (v45 ^ v47 ^ v46) + v44 + 1272893353, 21);
    v49 = v48 + __ROR4__(v87 + (v46 ^ v48 ^ v47) + v45 - 155497632, 16);
    v50 = v49 + __ROR4__(v90 + (v47 ^ v49 ^ v48) + v46 - 1094730640, 9);
    v51 = v50 + __ROR4__(v93 + (v48 ^ v50 ^ v49) + v47 + 681279174, 28);
    v52 = v51 + __ROR4__(v8 + (v49 ^ v51 ^ v50) + v48 - 358537222, 21);
    v53 = v52 + __ROR4__(v83 + (v50 ^ v52 ^ v51) + v49 - 722521979, 16);
    v54 = v53 + __ROR4__(v86 + (v51 ^ v53 ^ v52) + v50 + 76029189, 9);
    v55 = v54 + __ROR4__(v89 + (v52 ^ v54 ^ v53) + v51 - 640364487, 28);
    v56 = v55 + __ROR4__(v92 + (v53 ^ v55 ^ v54) + v52 - 421815835, 21);
    v57 = v56 + __ROR4__(v95 + (v54 ^ v56 ^ v55) + v53 + 530742520, 16);
    v58 = v57 + __ROR4__(v82 + (v55 ^ v57 ^ v56) + v54 - 995338651, 9);
    v59 = v58 + __ROR4__(v8 + (v57 ^ (v58 | ~v56)) + v55 - 198630844, 26);
    v60 = v59 + __ROR4__(v87 + (v58 ^ (v59 | ~v57)) + v56 + 1126891415, 22);
    v61 = v60 + __ROR4__(v94 + (v59 ^ (v60 | ~v58)) + v57 - 1416354905, 17);
    v62 = v61 + __ROR4__(v85 + (v60 ^ (v61 | ~v59)) + v58 - 57434055, 11);
    v63 = v62 + __ROR4__(v92 + (v61 ^ (v62 | ~v60)) + v59 + 1700485571, 26);
    v64 = v63 + __ROR4__(v83 + (v62 ^ (v63 | ~v61)) + v60 - 1894986606, 22);
    v65 = v64 + __ROR4__(v90 + (v63 ^ (v64 | ~v62)) + v61 - 1051523, 17);
    v66 = v65 + __ROR4__(v81 + (v64 ^ (v65 | ~v63)) + v62 - 2054922799, 11);
    v67 = v66 + __ROR4__(v88 + (v65 ^ (v66 | ~v64)) + v63 + 1873313359, 26);
    v68 = v67 + __ROR4__(v95 + (v66 ^ (v67 | ~v65)) + v64 - 30611744, 22);
    v69 = v68 + __ROR4__(v86 + (v67 ^ (v68 | ~v66)) + v65 - 1560198380, 17);
    v70 = v69 + __ROR4__(v93 + (v68 ^ (v69 | ~v67)) + v66 + 1309151649, 11);
    v71 = v70 + __ROR4__(v84 + (v69 ^ (v70 | ~v68)) + v67 - 145523070, 26);
    v72 = v71 + __ROR4__(v91 + (v70 ^ (v71 | ~v69)) + v68 - 1120210379, 22);
    v73 = v72 + __ROR4__(v82 + (v71 ^ (v72 | ~v70)) + v69 + 718787259, 17);
    v74 = v73 + __ROR4__(v89 + (v72 ^ (v73 | ~v71)) + v70 - 343485551, 11);
    v77 = v4 + v71;
    v78 = v5 + v74;
    v79 = v6 + v73;
    v80 = v7 + v72;
  }
  while ( v76 < &a1[a2 >> 2] );
  *a3 = v77;
  a3[1] = v78;
  a3[2] = v79;
  result = a3;
  a3[3] = v80;
  return result;
}
// 80617DA: using guessed type int __usercall sub_80617DA@<eax>(double@<st0>);
// 806B248: using guessed type int dword_806B248;

//----- (08057276) --------------------------------------------------------
int __cdecl sub_8057276(int a1, int a2, int a3, int a4, int a5, int a6)
{
  return posix_fadvise64(a1, a2, a3, a4, a5, a6);
}
// 8049E60: using guessed type int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (080572C7) --------------------------------------------------------
void __cdecl sub_80572C7(FILE *stream, int a2)
{
  int v2; // eax

  if ( stream )
  {
    v2 = fileno(stream);
    sub_8057276(v2, 0, 0, 0, 0, a2);
  }
}

//----- (0805730F) --------------------------------------------------------
int __cdecl sub_805730F(int a1)
{
  dword_806B2D0 = (int (__cdecl *)(_DWORD))&loc_805748D;
  return ((int (__cdecl *)(int))loc_805748D)(a1);
}
// 806B2D0: using guessed type int (__cdecl *dword_806B2D0)(_DWORD);

//----- (08057333) --------------------------------------------------------
#error "805735D: call analysis failed (funcsize=68)"

//----- (0805742F) --------------------------------------------------------
#error "80574AF: positive sp value has been found (funcsize=36)"

//----- (080574B0) --------------------------------------------------------
int __cdecl sub_80574B0(unsigned __int8 a1)
{
  if ( (unsigned __int8)sub_805FE67(a1) )
    return 0;
  if ( (unsigned __int8)sub_805FDB5(a1) )
    return a1;
  if ( a1 == 126 )
    return -1;
  return a1 + 256;
}

//----- (08057501) --------------------------------------------------------
signed int __usercall sub_8057501@<eax>(double a1@<st0>, int a2, unsigned int a3, int a4, unsigned int a5)
{
  int v5; // ecx
  int v6; // ecx
  int v7; // eax
  bool v8; // zf
  int v9; // ecx
  void *v10; // eax
  void *v11; // eax
  int v13; // [esp+0h] [ebp-38h]
  unsigned int v14; // [esp+1Ch] [ebp-1Ch]
  unsigned int v15; // [esp+20h] [ebp-18h]
  int v16; // [esp+24h] [ebp-14h]
  int v17; // [esp+28h] [ebp-10h]
  int v18; // [esp+2Ch] [ebp-Ch]

  v14 = 0;
  v15 = 0;
  while ( v14 < a3 || v15 < a5 )
  {
    v16 = 0;
    while ( 1 )
    {
      if ( v14 >= a3 || (v13 = *(char *)(a2 + v14), !((unsigned __int8)sub_805FE67(v13) ^ 1)) )
      {
        if ( v15 >= a5 )
          break;
        v13 = *(char *)(a4 + v15);
        if ( !((unsigned __int8)sub_805FE67(v13) ^ 1) )
          break;
      }
      if ( v14 != a3 )
      {
        sub_80574B0(*(_BYTE *)(a2 + v14));
        dword_806B318 = (int)&loc_8057560;
        sub_8061268(v5);
      }
      v17 = 0;
      if ( v15 == a5 )
      {
        v7 = 0;
      }
      else
      {
        v13 = *(unsigned __int8 *)(a4 + v15);
        v7 = sub_80574B0(v13);
      }
      v18 = v7;
      if ( v17 != v7 )
      {
        dword_806B284 = (int)&locret_8057765;
        sub_8061671(v6, v17 - v18);
      }
      ++v14;
      ++v15;
    }
    dword_806B2C0 = (int)&loc_8057629;
    sub_8061521();
    do
      ++v14;
    while ( *(_BYTE *)(a2 + v14) == 48 );
    while ( *(_BYTE *)(a4 + v15) == 48 )
      ++v15;
    v13 = *(char *)(a2 + v14);
    v8 = (unsigned __int8)sub_805FE67(v13) == 0;
    v10 = &loc_80576B3;
    if ( v8 )
      v10 = &loc_80576E6;
    dword_806B220 = (int)v10;
    sub_80618C4(v9);
    v13 = *(char *)(a4 + v15);
    v8 = (unsigned __int8)sub_805FE67(v13) == 0;
    v11 = &loc_80576E6;
    if ( !v8 )
      v11 = &loc_805764F;
    dword_806B2E4 = (int)v11;
    sub_806141F(a1);
    v13 = *(char *)(a2 + v14);
    if ( (unsigned __int8)sub_805FE67(v13) )
      return 1;
    v13 = *(char *)(a4 + v15);
    if ( (unsigned __int8)sub_805FE67(v13) )
      return -1;
    if ( v16 )
    {
      dword_806B248 = (int)&locret_8057765;
      sub_80617DA(a1);
    }
  }
  return 0;
}
// 8057501: could not find valid save-restore pair for ebx
// 8061268: using guessed type int __fastcall sub_8061268(_DWORD);
// 806141F: using guessed type int __usercall sub_806141F@<eax>(double@<st0>);
// 8061521: using guessed type int sub_8061521(void);
// 8061671: using guessed type int __fastcall sub_8061671(_DWORD, _DWORD);
// 80617DA: using guessed type int __usercall sub_80617DA@<eax>(double@<st0>);
// 80618C4: using guessed type int __fastcall sub_80618C4(_DWORD);
// 806B220: using guessed type int dword_806B220;
// 806B248: using guessed type int dword_806B248;
// 806B284: using guessed type int dword_806B284;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B2E4: using guessed type int dword_806B2E4;
// 806B318: using guessed type int dword_806B318;

//----- (08057767) --------------------------------------------------------
int __usercall sub_8057767@<eax>(double a1@<st0>, char *s1, char *s2)
{
  int result; // eax
  int v4; // ecx
  void *v5; // eax
  void *v6; // eax
  void *v7; // eax
  char *v8; // eax
  char *v9; // [esp+10h] [ebp-28h]
  char *v10; // [esp+14h] [ebp-24h]
  size_t n; // [esp+18h] [ebp-20h]
  unsigned int v12; // [esp+1Ch] [ebp-1Ch]
  int v13; // [esp+20h] [ebp-18h]
  int v14; // [esp+24h] [ebp-14h]
  char *v15; // [esp+28h] [ebp-10h]
  int v16; // [esp+2Ch] [ebp-Ch]

  v13 = strcmp(s1, s2);
  if ( !v13 )
    return 0;
  if ( !*s1 )
    return -1;
  if ( !*s2 )
    return 1;
  if ( !strcmp(".", s1) )
    return -1;
  if ( !strcmp(".", s2) )
    return 1;
  if ( !strcmp("..", s1) )
    return -1;
  if ( !strcmp("..", s2) )
    return 1;
  if ( *s1 == 46 )
  {
    v5 = &loc_805786B;
    if ( *s2 == 46 )
      v5 = &loc_8057875;
    dword_806B270 = (int)v5;
    sub_80616F8();
    result = -1;
  }
  else
  {
    v6 = &loc_8057898;
    if ( *s1 == 46 )
      v6 = &loc_80578AC;
    dword_806B318 = (int)v6;
    sub_8061268(v4);
    if ( *s2 == 46 )
    {
      result = 1;
    }
    else
    {
      if ( *s1 == 46 && *s2 == 46 )
      {
        ++s1;
        ++s2;
      }
      v9 = s1;
      v10 = s2;
      v14 = sub_805730F((int)&v9);
      v15 = (char *)sub_805730F((int)&v10);
      v7 = &loc_805790F;
      if ( !v14 )
        v7 = &loc_8057929;
      dword_806B270 = (int)v7;
      sub_80616F8();
      dword_806B25C = (int)&loc_805792C;
      sub_806176A();
      n = v9 - s1;
      if ( v15 )
        v8 = v15;
      else
        v8 = v10;
      v12 = v8 - s2;
      if ( (v14 || v15) && n == v12 && !strncmp(s1, s2, n) )
      {
        n = v9 - s1;
        v12 = v10 - s2;
      }
      v16 = sub_8057501(a1, (int)s1, n, (int)s2, v12);
      if ( v16 )
        result = v16;
      else
        result = v13;
    }
  }
  return result;
}
// 8057767: could not find valid save-restore pair for ebx
// 8061268: using guessed type int __fastcall sub_8061268(_DWORD);
// 80616F8: using guessed type int sub_80616F8(void);
// 806176A: using guessed type int sub_806176A(void);
// 806B25C: using guessed type int dword_806B25C;
// 806B270: using guessed type int dword_806B270;
// 806B318: using guessed type int dword_806B318;

//----- (080579D4) --------------------------------------------------------
int __cdecl sub_80579D4(int category)
{
  bool v1; // zf
  void *v2; // eax
  unsigned __int8 v4; // [esp+1Bh] [ebp-Dh]
  const char *s1; // [esp+1Ch] [ebp-Ch]

  v4 = 1;
  s1 = setlocale(category, 0);
  if ( s1 )
  {
    v1 = strcmp(s1, "C") == 0;
    v2 = &loc_8057A2A;
    if ( v1 )
      v2 = &loc_8057A41;
    dword_806B2AC = (int)v2;
    sub_8061591();
    if ( !strcmp(s1, "POSIX") )
      v4 = 0;
  }
  return v4;
}
// 8061591: using guessed type int sub_8061591(void);
// 806B2AC: using guessed type int dword_806B2AC;

//----- (08057A4B) --------------------------------------------------------
int __cdecl sub_8057A4B(int a1)
{
  return *(_DWORD *)(a1 + 8);
}

//----- (08057A56) --------------------------------------------------------
int __cdecl sub_8057A56(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (08057A61) --------------------------------------------------------
int __cdecl sub_8057A61(int a1)
{
  return *(_DWORD *)(a1 + 16);
}

//----- (08057A71) --------------------------------------------------------
int __usercall sub_8057A71@<eax>(double a1@<st0>, int a2)
{
  void *v2; // eax
  void *v3; // eax
  bool v4; // zf
  void *v5; // eax
  int v6; // edx
  int v7; // ecx
  void *v8; // eax
  int v9; // ecx
  void *v10; // eax
  char v11; // al

  if ( *(_DWORD *)(a2 + 16) )
    goto LABEL_19;
  v2 = &loc_8057AA8;
  if ( *(_DWORD *)(a2 + 20) )
    v2 = &loc_8057B6F;
  dword_806B248 = (int)v2;
  sub_80617DA(a1);
  if ( *(_BYTE *)(a2 + 24) == 1 )
    goto LABEL_19;
  v3 = &loc_8057AE1;
  if ( *(_BYTE *)(a2 + 25) == 1 )
    v3 = &loc_8057B6F;
  dword_806B270 = (int)v3;
  sub_80616F8();
  v4 = (unsigned __int8)sub_804EFB3((_BYTE *)a2) == 1;
  v5 = &loc_8057B0C;
  if ( v4 )
    v5 = &loc_8057B6F;
  dword_806B2E4 = (int)v5;
  sub_806141F(a1);
  v8 = &loc_8057B33;
  if ( *(_BYTE *)(a2 + 30) == 1 )
    v8 = &loc_8057B6F;
  dword_806B284 = (int)v8;
  sub_8061671(v7, v6);
  if ( *(_BYTE *)(a2 + 32) == 1 )
  {
LABEL_19:
    v11 = 0;
  }
  else
  {
    v10 = &loc_8057B68;
    if ( *(_BYTE *)(a2 + 27) == 1 )
      v10 = &loc_8057B6F;
    dword_806B220 = (int)v10;
    sub_80618C4(v9);
    v11 = 1;
  }
  return v11 & 1;
}
// 8057A71: could not find valid save-restore pair for ebx
// 806141F: using guessed type int __usercall sub_806141F@<eax>(double@<st0>);
// 8061671: using guessed type int __fastcall sub_8061671(_DWORD, _DWORD);
// 80616F8: using guessed type int sub_80616F8(void);
// 80617DA: using guessed type int __usercall sub_80617DA@<eax>(double@<st0>);
// 80618C4: using guessed type int __fastcall sub_80618C4(_DWORD);
// 806B220: using guessed type int dword_806B220;
// 806B248: using guessed type int dword_806B248;
// 806B270: using guessed type int dword_806B270;
// 806B284: using guessed type int dword_806B284;
// 806B2E4: using guessed type int dword_806B2E4;

//----- (08057B90) --------------------------------------------------------
int __cdecl sub_8057B90(int a1, int a2)
{
  unsigned int v3; // [esp+1Ch] [ebp-Ch]

  v3 = (*(int (__cdecl **)(int, _DWORD))(a1 + 24))(a2, *(_DWORD *)(a1 + 8));
  if ( *(_DWORD *)(a1 + 8) <= v3 )
    abort();
  return 8 * v3 + *(_DWORD *)a1;
}

//----- (08057EAF) --------------------------------------------------------
bool __cdecl sub_8057EAF(unsigned int a1)
{
  int v1; // ST08_4
  unsigned int v3; // [esp+8h] [ebp-8h]
  unsigned int v4; // [esp+Ch] [ebp-4h]

  v3 = 3;
  v4 = 9;
  while ( v4 < a1 && a1 % v3 )
  {
    v1 = v3 + 1;
    v4 += 4 * v1;
    v3 = v1 + 1;
  }
  return a1 % v3 != 0;
}

//----- (08057F06) --------------------------------------------------------
int __cdecl sub_8057F06(unsigned int a1)
{
  dword_806B2D0 = (int (__cdecl *)(_DWORD))&loc_8057F2B;
  if ( a1 <= 9 )
  {
    a1 = 11;
    dword_806B2D0 = (int (__cdecl *)(_DWORD))&loc_8057F46;
  }
  return dword_806B2D0(a1);
}
// 806B2D0: using guessed type int (__cdecl *dword_806B2D0)(_DWORD);

//----- (08057F42) --------------------------------------------------------
#error "8057F86: positive sp value has been found (funcsize=17)"

//----- (08057FBE) --------------------------------------------------------
unsigned int __cdecl sub_8057FBE(int a1, unsigned int a2)
{
  return sub_805FC90(a1, 3) % a2;
}

//----- (08057FE9) --------------------------------------------------------
bool __cdecl sub_8057FE9(int a1, int a2)
{
  return a1 == a2;
}

//----- (08057FF7) --------------------------------------------------------
signed int __cdecl sub_8057FF7(int a1)
{
  int v2; // [esp+8h] [ebp-8h]

  v2 = *(_DWORD *)(a1 + 20);
  if ( (_UNKNOWN *)v2 == &unk_8063ED8 )
    return 1;
  if ( *(float *)(v2 + 8) > 0.1
    && 1.0 - 0.1 > *(float *)(v2 + 8)
    && *(float *)(v2 + 12) > 0.1 + 1.0
    && *(float *)v2 >= 0.0
    && *(float *)(v2 + 4) > *(float *)v2 + 0.1
    && *(float *)(v2 + 4) <= 1.0
    && *(float *)(v2 + 8) > *(float *)v2 + 0.1 )
  {
    return 1;
  }
  *(_DWORD *)(a1 + 20) = &unk_8063ED8;
  return 0;
}

//----- (080580B3) --------------------------------------------------------
int __cdecl sub_80580B3(unsigned int a1, int a2)
{
  bool v2; // zf
  float v3; // ST20_4

  v2 = *(_BYTE *)(a2 + 16) == 1;
  dword_806B2D0 = (int (__cdecl *)(_DWORD))&loc_8058152;
  if ( !v2 )
  {
    v3 = (long double)a1 / *(float *)(a2 + 8);
    dword_806B2D0 = (int (__cdecl *)(_DWORD))sub_8058130;
    if ( v3 >= 4294967300.0 )
      dword_806B2D0 = (int (__cdecl *)(_DWORD))&locret_8058196;
  }
  return dword_806B2D0(a1);
}
// 8058130: using guessed type int sub_8058130();
// 806B2D0: using guessed type int (__cdecl *dword_806B2D0)(_DWORD);

//----- (08058130) --------------------------------------------------------
#error "8058158: call analysis failed (funcsize=28)"

//----- (08058193) --------------------------------------------------------
#error "8058197: positive sp value has been found (funcsize=0)"

//----- (08058198) --------------------------------------------------------
void *__cdecl sub_8058198(unsigned int a1, int a2, unsigned int (__cdecl *a3)(int a1, unsigned int a2), bool (__cdecl *a4)(int a1, int a2), int a5)
{
  void *result; // eax
  void *v6; // eax
  void *ptr; // [esp+1Ch] [ebp-Ch]

  if ( !a3 )
    a3 = sub_8057FBE;
  if ( !a4 )
    a4 = sub_8057FE9;
  ptr = malloc(0x28u);
  if ( !ptr )
    return 0;
  v6 = &loc_80581F6;
  if ( a2 )
    v6 = &loc_80581FD;
  dword_806B270 = (int)v6;
  sub_80616F8();
  *((_DWORD *)ptr + 5) = &unk_8063ED8;
  if ( (unsigned __int8)sub_8057FF7((int)ptr) ^ 1 || (*((_DWORD *)ptr + 2) = sub_80580B3(a1, (int)&unk_8063ED8)) == 0 )
  {
    free(ptr);
    result = 0;
  }
  else
  {
    *(_DWORD *)ptr = calloc(*((_DWORD *)ptr + 2), 8u);
    if ( !*(_DWORD *)ptr )
    {
      dword_806B304 = (int)&loc_80582D5;
      sub_8061308();
    }
    *((_DWORD *)ptr + 1) = 8 * *((_DWORD *)ptr + 2) + *(_DWORD *)ptr;
    *((_DWORD *)ptr + 3) = 0;
    *((_DWORD *)ptr + 4) = 0;
    *((_DWORD *)ptr + 6) = a3;
    *((_DWORD *)ptr + 7) = a4;
    *((_DWORD *)ptr + 8) = a5;
    *((_DWORD *)ptr + 9) = 0;
    result = ptr;
  }
  return result;
}
// 8061308: using guessed type int sub_8061308(void);
// 80616F8: using guessed type int sub_80616F8(void);
// 806B270: using guessed type int dword_806B270;
// 806B304: using guessed type int dword_806B304;

//----- (080584CF) --------------------------------------------------------
int __fastcall sub_80584CF(int a1, int a2, int a3)
{
  int v3; // eax

  v3 = *(_DWORD *)(a3 + 36);
  dword_806B328 = (int (__fastcall *)(_DWORD, _DWORD))sub_8058519;
  if ( v3 )
  {
    a2 = *(_DWORD *)(*(_DWORD *)(a3 + 36) + 4);
    *(_DWORD *)(a3 + 36) = a2;
    dword_806B328 = (int (__fastcall *)(_DWORD, _DWORD))&loc_8058528;
  }
  return dword_806B328(a1, a2);
}
// 8058519: using guessed type int sub_8058519();
// 806B328: using guessed type int (__fastcall *dword_806B328)(_DWORD, _DWORD);

//----- (08058519) --------------------------------------------------------
#error "805852C: positive sp value has been found (funcsize=0)"

//----- (0805852D) --------------------------------------------------------
int __cdecl sub_805852D(int a1, _DWORD *a2)
{
  int result; // eax

  *a2 = 0;
  a2[1] = *(_DWORD *)(a1 + 36);
  result = a1;
  *(_DWORD *)(a1 + 36) = a2;
  return result;
}

//----- (08058550) --------------------------------------------------------
int __usercall sub_8058550@<eax>(double st7_0@<st0>, int a1, int a2, _DWORD *a3, char a4)
{
  int result; // eax
  void *v6; // eax
  int *v7; // ST34_4
  int v8; // edx
  void *v9; // eax
  _DWORD *v10; // ST2C_4
  int *i; // [esp+18h] [ebp-20h]
  int *v12; // [esp+1Ch] [ebp-1Ch]
  int v13; // [esp+20h] [ebp-18h]
  int v14; // [esp+28h] [ebp-10h]

  v12 = (int *)sub_8057B90(a1, a2);
  *a3 = v12;
  if ( !*v12 )
    return 0;
  if ( *v12 == a2 || (*(unsigned __int8 (__cdecl **)(int, int))(a1 + 28))(a2, *v12) )
  {
    v14 = *v12;
    v6 = &loc_80585D8;
    if ( !a4 )
      v6 = &loc_8058618;
    dword_806B248 = (int)v6;
    sub_80617DA(st7_0);
    if ( v12[1] )
    {
      v7 = (int *)v12[1];
      v8 = v7[1];
      *v12 = *v7;
      v12[1] = v8;
      sub_805852D(a1, v7);
    }
    else
    {
      *v12 = 0;
    }
    result = v14;
  }
  else
  {
    for ( i = v12; ; i = (int *)i[1] )
    {
      if ( !i[1] )
        return 0;
      v9 = &loc_8058651;
      if ( *(_DWORD *)i[1] == a2 )
        v9 = &loc_805866F;
      dword_806B270 = (int)v9;
      sub_80616F8();
      if ( (*(unsigned __int8 (__cdecl **)(int, _DWORD))(a1 + 28))(a2, *(_DWORD *)i[1]) )
        break;
    }
    v13 = *(_DWORD *)i[1];
    if ( a4 )
    {
      v10 = (_DWORD *)i[1];
      i[1] = v10[1];
      sub_805852D(a1, v10);
    }
    result = v13;
  }
  return result;
}
// 80616F8: using guessed type int sub_80616F8(void);
// 80617DA: using guessed type int __usercall sub_80617DA@<eax>(double@<st0>);
// 806B248: using guessed type int dword_806B248;
// 806B270: using guessed type int dword_806B270;

//----- (080586CA) --------------------------------------------------------
signed int __cdecl sub_80586CA(int a1, int a2, char a3)
{
  int v3; // edx
  int v4; // ecx
  int *i; // [esp+18h] [ebp-20h]
  int *j; // [esp+1Ch] [ebp-1Ch]
  int v8; // [esp+20h] [ebp-18h]
  int v9; // [esp+20h] [ebp-18h]
  int *v10; // [esp+24h] [ebp-14h]
  int *v11; // [esp+24h] [ebp-14h]
  int *v12; // [esp+28h] [ebp-10h]
  int *v13; // [esp+2Ch] [ebp-Ch]

  for ( i = *(int **)a2; *(_DWORD *)(a2 + 4) > (unsigned int)i; i += 2 )
  {
    if ( *i )
    {
      for ( j = (int *)i[1]; j; j = v12 )
      {
        v8 = *j;
        v10 = (int *)sub_8057B90(a1, *j);
        v12 = (int *)j[1];
        if ( *v10 )
        {
          j[1] = v10[1];
          v10[1] = (int)j;
        }
        else
        {
          *v10 = v8;
          ++*(_DWORD *)(a1 + 12);
          sub_805852D(a1, j);
        }
      }
      v9 = *i;
      i[1] = 0;
      if ( !a3 )
      {
        v11 = (int *)sub_8057B90(a1, v9);
        if ( *v11 )
        {
          v13 = (int *)sub_80584CF(v4, v3, a1);
          if ( !v13 )
            return 0;
          *v13 = v9;
          v13[1] = v11[1];
          v11[1] = (int)v13;
        }
        else
        {
          *v11 = v9;
          ++*(_DWORD *)(a1 + 12);
        }
        *i = 0;
        --*(_DWORD *)(a2 + 12);
      }
    }
  }
  return 1;
}

//----- (08058834) --------------------------------------------------------
int __cdecl sub_8058834(int a1, unsigned int a2)
{
  int v2; // eax
  int v4; // [esp+10h] [ebp-38h]

  v4 = sub_80580B3(a2, *(_DWORD *)(a1 + 20));
  dword_806B2D0 = (int (__cdecl *)(_DWORD))&loc_8058886;
  if ( !v4 )
  {
    dword_806B304 = (int)&locret_8058AAB;
    sub_8061308();
    v2 = *(_DWORD *)(a1 + 8);
    dword_806B2D0 = sub_80588BB;
    if ( v2 == v4 )
      dword_806B2D0 = (int (__cdecl *)(_DWORD))&locret_8058AAB;
  }
  return dword_806B2D0(a1);
}
// 8061308: using guessed type int sub_8061308(void);
// 806B2D0: using guessed type int (__cdecl *dword_806B2D0)(_DWORD);
// 806B304: using guessed type int dword_806B304;

//----- (080588BB) --------------------------------------------------------
#error "80588CF: call analysis failed (funcsize=32)"

//----- (08058923) --------------------------------------------------------
#error "80589A4: call analysis failed (funcsize=108)"

//----- (08058A99) --------------------------------------------------------
#error "8058AAC: positive sp value has been found (funcsize=0)"

//----- (08058AAD) --------------------------------------------------------
signed int __usercall sub_8058AAD@<eax>(double st7_0@<st0>, unsigned int *a1, int a2, _DWORD *a3)
{
  int v4; // ecx
  long double v5; // fst7
  long double v6; // fst6
  int v7; // edx
  long double v8; // fst7
  long double v9; // fst6
  long double v10; // fst7
  signed int result; // eax
  long double v12; // fst7
  __int16 v13; // ax
  __int64 v14; // [esp+10h] [ebp-38h]
  __int16 v15; // [esp+1Ch] [ebp-2Ch]
  __int16 v16; // [esp+1Eh] [ebp-2Ah]
  int *v17; // [esp+2Ch] [ebp-1Ch]
  int v18; // [esp+30h] [ebp-18h]
  unsigned int v19; // [esp+34h] [ebp-14h]
  float v20; // [esp+38h] [ebp-10h]
  int *v21; // [esp+3Ch] [ebp-Ch]

  if ( !a2 )
    abort();
  v18 = sub_8058550(st7_0, (int)a1, a2, &v17, 0);
  if ( v18 )
  {
    if ( a3 )
      *a3 = v18;
    dword_806B298 = (int)&locret_8058D21;
    sub_8061601();
  }
  v14 = a1[3];
  v5 = (long double)v14;
  v6 = *(float *)(a1[5] + 8);
  v7 = 0;
  v14 = a1[2];
  if ( v5 > v6 * (long double)v14 )
  {
    sub_8057FF7((int)a1);
    v14 = a1[3];
    v8 = (long double)v14;
    v9 = *(float *)(a1[5] + 8);
    v7 = 0;
    v14 = a1[2];
    if ( v8 > v9 * (long double)v14 )
    {
      v19 = a1[5];
      if ( *(_BYTE *)(v19 + 16) )
      {
        v14 = a1[2];
        v10 = (long double)v14 * *(float *)(v19 + 12);
      }
      else
      {
        v14 = a1[2];
        v10 = (long double)v14 * *(float *)(v19 + 12) * *(float *)(v19 + 8);
      }
      v20 = v10;
      if ( v20 >= 4294967300.0 )
        return -1;
      v12 = v20;
      LOBYTE(v13) = v16;
      HIBYTE(v13) = 12;
      v15 = v13;
      v14 = (signed __int64)v20;
      if ( (unsigned __int8)sub_8058834((int)a1, v14) ^ 1 )
      {
        dword_806B2E4 = (int)&locret_8058D21;
        sub_806141F(*(double *)&v12);
      }
      if ( sub_8058550(*(double *)&v12, (int)a1, a2, &v17, 0) )
        abort();
    }
  }
  if ( *v17 )
  {
    v21 = (int *)sub_80584CF(v4, v7, (int)a1);
    if ( !v21 )
    {
      dword_806B2C0 = (int)&locret_8058D21;
      sub_8061521();
    }
    *v21 = a2;
    v21[1] = v17[1];
    v17[1] = (int)v21;
    ++a1[4];
    result = 1;
  }
  else
  {
    *v17 = a2;
    ++a1[4];
    ++a1[3];
    result = 1;
  }
  return result;
}
// 806141F: using guessed type int __usercall sub_806141F@<eax>(double@<st0>);
// 8061521: using guessed type int sub_8061521(void);
// 8061601: using guessed type int sub_8061601(void);
// 806B298: using guessed type int dword_806B298;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B2E4: using guessed type int dword_806B2E4;

//----- (08058D23) --------------------------------------------------------
int __usercall sub_8058D23@<eax>(double st7_0@<st0>, unsigned int *a1, int a2)
{
  int v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]

  v5 = sub_8058AAD(st7_0, a1, a2, &v4);
  if ( v5 != -1 )
  {
    if ( !v5 )
      return v4;
    dword_806B2AC = (int)&locret_8058D75;
    sub_8061591();
  }
  return 0;
}
// 8061591: using guessed type int sub_8061591(void);
// 806B2AC: using guessed type int dword_806B2AC;

//----- (08058D77) --------------------------------------------------------
int __usercall sub_8058D77@<eax>(double st7_0@<st0>, int a1, int a2)
{
  void *v4; // eax
  _DWORD *v5; // [esp+28h] [ebp-20h]
  void *ptr; // [esp+2Ch] [ebp-1Ch]
  int v7; // [esp+30h] [ebp-18h]
  int v8; // [esp+34h] [ebp-14h]
  unsigned int v9; // [esp+38h] [ebp-10h]
  void *v10; // [esp+3Ch] [ebp-Ch]

  v7 = sub_8058550(st7_0, a1, a2, &v5, 1);
  if ( !v7 )
    return 0;
  --*(_DWORD *)(a1 + 16);
  if ( !*v5
    && **(float **)(a1 + 20) * (long double)*(unsigned int *)(a1 + 8) > (long double)(unsigned int)--*(_DWORD *)(a1 + 12) )
  {
    sub_8057FF7(a1);
    if ( **(float **)(a1 + 20) * (long double)*(unsigned int *)(a1 + 8) > (long double)*(unsigned int *)(a1 + 12) )
    {
      v8 = *(_DWORD *)(a1 + 20);
      v4 = &loc_8058E8C;
      if ( !*(_BYTE *)(v8 + 16) )
        v4 = &loc_8058EC6;
      dword_806B2AC = (int)v4;
      sub_8061591();
      v9 = (signed __int64)((long double)*(unsigned int *)(a1 + 8) * *(float *)(v8 + 4));
      if ( (unsigned __int8)sub_8058834(a1, v9) ^ 1 )
      {
        for ( ptr = *(void **)(a1 + 36); ptr; ptr = v10 )
        {
          v10 = (void *)*((_DWORD *)ptr + 1);
          free(ptr);
        }
        *(_DWORD *)(a1 + 36) = 0;
      }
    }
  }
  return v7;
}
// 8061591: using guessed type int sub_8061591(void);
// 806B2AC: using guessed type int dword_806B2AC;

//----- (08058F5C) --------------------------------------------------------
int *__cdecl sub_8058F5C(int (*a1)(), unsigned int a2)
{
  int (*v2)(); // eax
  int *v4; // [esp+1Ch] [ebp-Ch]

  v4 = (int *)sub_805E160(0x10u);
  if ( !a2 )
    a2 = 1;
  *v4 = sub_805DFF6(a2, 4u);
  *(_DWORD *)*v4 = 0;
  v4[1] = a2;
  v4[2] = 0;
  if ( a1 )
    v2 = a1;
  else
    v2 = sub_8058FD1;
  v4[3] = (int)v2;
  return v4;
}

//----- (08058FD1) --------------------------------------------------------
int sub_8058FD1()
{
  return 0;
}

//----- (08058FDB) --------------------------------------------------------
void __cdecl sub_8058FDB(void *ptr)
{
  free(*(void **)ptr);
  free(ptr);
}

//----- (08058FFB) --------------------------------------------------------
int __cdecl sub_8058FFB(int a1, int a2)
{
  int v2; // edx

  if ( (unsigned int)(*(_DWORD *)(a1 + 4) - 1) <= *(_DWORD *)(a1 + 8) )
    *(_DWORD *)a1 = sub_805E059(*(_DWORD *)a1, (unsigned int *)(a1 + 4), 4u);
  v2 = *(_DWORD *)a1;
  *(_DWORD *)(4 * ++*(_DWORD *)(a1 + 8) + v2) = a2;
  sub_80591FC(*(_DWORD *)a1, *(_DWORD *)(a1 + 8), *(int (__cdecl **)(_DWORD, int))(a1 + 12));
  return 0;
}

//----- (08059084) --------------------------------------------------------
int __usercall sub_8059084@<eax>(int a1@<edx>, int a2@<ecx>, int a3)
{
  void *v3; // eax

  v3 = &loc_80590AF;
  if ( *(_DWORD *)(a3 + 8) )
    v3 = &loc_80590B6;
  dword_806B234 = (int)v3;
  sub_806184C(a2, a1);
  return 0;
}
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD, _DWORD);
// 806B234: using guessed type int dword_806B234;

//----- (08059119) --------------------------------------------------------
unsigned int __cdecl sub_8059119(int a1, unsigned int a2, unsigned int a3, int (__cdecl *a4)(_DWORD, int))
{
  unsigned int i; // [esp+14h] [ebp-14h]
  int v6; // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]

  v7 = *(_DWORD *)(4 * a3 + a1);
  for ( i = a3; a2 >> 1 >= i; i = v6 )
  {
    v6 = 2 * i;
    if ( 2 * i < a2 && a4(*(_DWORD *)(8 * i + a1), *(_DWORD *)(4 * (2 * i + 1) + a1)) < 0 )
      ++v6;
    if ( a4(*(_DWORD *)(4 * v6 + a1), v7) <= 0 )
      break;
    *(_DWORD *)(a1 + 4 * i) = *(_DWORD *)(4 * v6 + a1);
  }
  *(_DWORD *)(a1 + 4 * i) = v7;
  return i;
}

//----- (080591FC) --------------------------------------------------------
int __cdecl sub_80591FC(int a1, unsigned int a2, int (__cdecl *a3)(_DWORD, int))
{
  int result; // eax
  unsigned int v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]

  v4 = a2;
  v5 = *(_DWORD *)(4 * a2 + a1);
  while ( v4 != 1 && a3(*(_DWORD *)(4 * (v4 >> 1) + a1), v5) <= 0 )
  {
    *(_DWORD *)(a1 + 4 * v4) = *(_DWORD *)(4 * (v4 >> 1) + a1);
    v4 >>= 1;
  }
  result = v5;
  *(_DWORD *)(a1 + 4 * v4) = v5;
  return result;
}

//----- (0805928C) --------------------------------------------------------
int __cdecl sub_805928C(int a1, int a2)
{
  int v3; // [esp+Ch] [ebp-4h]

  v3 = a2 + 11;
  *(_BYTE *)(a2 + 11) = 0;
  if ( a1 >= 0 )
  {
    do
    {
      *(_BYTE *)--v3 = (char)a1 % 10 + 48;
      a1 /= 10;
    }
    while ( a1 );
  }
  else
  {
    do
    {
      *(_BYTE *)--v3 = 48 - (char)a1 % 10;
      a1 /= 10;
    }
    while ( a1 );
    *(_BYTE *)--v3 = 45;
  }
  return v3;
}

//----- (08059366) --------------------------------------------------------
int __cdecl sub_8059366(unsigned int a1, int a2)
{
  void *v2; // eax

  *(_BYTE *)(a2 + 10) = 0;
  *(_BYTE *)(a2 + 9) = a1 % 0xA + 48;
  v2 = &loc_80593D8;
  if ( a1 / 0xA )
    v2 = &loc_805937B;
  dword_806B234 = (int)v2;
  sub_806184C(a1 % 0xA, 3435973837u * (unsigned __int64)a1 >> 32);
  return a2 + 9;
}
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD, _DWORD);
// 806B234: using guessed type int dword_806B234;

//----- (080593DD) --------------------------------------------------------
int __cdecl sub_80593DD(signed __int64 a1, int a2)
{
  signed __int64 v3; // [esp+18h] [ebp-20h]
  int v4; // [esp+2Ch] [ebp-Ch]

  v3 = a1;
  v4 = a2 + 20;
  *(_BYTE *)(a2 + 20) = 0;
  do
  {
    *(_BYTE *)--v4 = sub_8060EA3(v3, 0xAu, 0) + 48;
    v3 = sub_8060D83(v3, 0xAu, 0);
  }
  while ( v3 );
  return v4;
}

//----- (08059490) --------------------------------------------------------
int __usercall sub_8059490@<eax>(double a1@<st0>, char *a2, int a3, char a4)
{
  int v4; // ecx
  signed int v5; // eax
  bool v6; // sf
  unsigned __int8 v7; // of
  void *v8; // eax
  int v9; // eax
  void *v11; // eax
  int v12; // edx
  int v13; // ecx
  void *v14; // eax
  int v15; // ecx
  bool v16; // zf
  int v17; // edx
  int v18; // ecx
  void *v19; // eax
  char *v20; // eax
  void *v21; // eax
  char *v22; // [esp+1Ch] [ebp-3Ch]
  unsigned __int8 v23; // [esp+2Bh] [ebp-2Dh]
  wint_t wc; // [esp+2Ch] [ebp-2Ch]
  char *v25; // [esp+30h] [ebp-28h]
  int v26; // [esp+34h] [ebp-24h]
  size_t v27; // [esp+38h] [ebp-20h]
  char *v28; // [esp+3Ch] [ebp-1Ch]
  int v29; // [esp+40h] [ebp-18h]
  const mbstate_t s; // [esp+44h] [ebp-14h]
  unsigned int v31; // [esp+4Ch] [ebp-Ch]

  v22 = a2;
  v31 = __readgsdword(0x14u);
  v25 = a2;
  v28 = &a2[a3];
  v26 = 0;
  if ( __ctype_get_mb_cur_max() > 1 )
  {
    while ( 1 )
    {
      if ( v25 >= v28 )
        return v26;
      v5 = *v25;
      if ( v5 > 63 )
      {
        v7 = __OFSUB__(v5, 65);
        v6 = v5 - 65 < 0;
        v8 = &loc_805950D;
        if ( v6 ^ v7 )
          v8 = &loc_8059527;
        dword_806B220 = (int)v8;
        v9 = sub_80618C4(v4);
        if ( v9 > 95 && (unsigned int)(v9 - 97) > 0x1D )
          goto LABEL_12;
LABEL_11:
        ++v25;
        ++v26;
      }
      else
      {
        if ( v5 >= 37 || (unsigned int)(v5 - 32) <= 3 )
          goto LABEL_11;
LABEL_12:
        memset((void *)&s, 0, 8u);
        v27 = sub_805F5FA((wchar_t *)&wc, v25, v28 - v25, (mbstate_t *)&s);
        if ( v27 == -1 )
        {
          if ( a4 & 1 )
            return -1;
          ++v25;
          ++v26;
        }
        else if ( v27 == -2 )
        {
          v11 = &loc_80595BC;
          if ( a4 & 1 )
            v11 = &loc_80595CB;
          dword_806B248 = (int)v11;
          sub_80617DA(a1);
          v25 = v28;
          ++v26;
        }
        else
        {
          if ( !v27 )
            v27 = 1;
          v29 = wcwidth(wc);
          if ( v29 >= 0 )
          {
            v14 = &loc_805961C;
            if ( 0x7FFFFFFF - v26 >= v29 )
              v14 = &loc_8059621;
            dword_806B284 = (int)v14;
            sub_8061671(v13, v12);
            return 0x7FFFFFFF;
          }
          if ( a4 & 2 )
            return -1;
          if ( !iswcntrl(wc) )
          {
            if ( v26 == 0x7FFFFFFF )
            {
              dword_806B20C = (int)&loc_8059786;
              sub_8061930(v15);
            }
            ++v26;
            dword_806B2AC = (int)&loc_8059687;
            sub_8061591();
            return -1;
          }
          v25 += v27;
          v16 = mbsinit(&s) == 0;
          v19 = &loc_80596B5;
          if ( v16 )
            v19 = &loc_8059542;
          dword_806B284 = (int)v19;
          sub_8061671(v18, v17);
        }
      }
    }
  }
  dword_806B298 = (int)&loc_8059775;
  sub_8061601();
  while ( 1 )
  {
    v20 = v25++;
    v23 = *v20;
    v16 = ((*__ctype_b_loc())[v23] & 0x4000) == 0;
    v21 = &loc_8059726;
    if ( v16 )
      v21 = &loc_8059737;
    dword_806B2E4 = (int)v21;
    sub_806141F(a1);
    if ( v26 == 0x7FFFFFFF )
      break;
    ++v26;
    if ( v25 >= v28 )
      return v26;
  }
  return 0x7FFFFFFF;
}
// 8059490: could not find valid save-restore pair for ebx
// 8049800: using guessed type int __cdecl wcwidth(_DWORD);
// 806141F: using guessed type int __usercall sub_806141F@<eax>(double@<st0>);
// 8061591: using guessed type int sub_8061591(void);
// 8061601: using guessed type int sub_8061601(void);
// 8061671: using guessed type int __fastcall sub_8061671(_DWORD, _DWORD);
// 80617DA: using guessed type int __usercall sub_80617DA@<eax>(double@<st0>);
// 80618C4: using guessed type int __fastcall sub_80618C4(_DWORD);
// 8061930: using guessed type int __fastcall sub_8061930(_DWORD);
// 806B20C: using guessed type int dword_806B20C;
// 806B220: using guessed type int dword_806B220;
// 806B248: using guessed type int dword_806B248;
// 806B284: using guessed type int dword_806B284;
// 806B298: using guessed type int dword_806B298;
// 806B2AC: using guessed type int dword_806B2AC;
// 806B2E4: using guessed type int dword_806B2E4;

//----- (0805979E) --------------------------------------------------------
int sub_805979E()
{
  int v0; // edx
  int v1; // ecx
  char v3; // [esp+20h] [ebp-88h]

  if ( !sched_getaffinity(0, 128, &v3) && __sched_cpucount(128, &v3) )
  {
    dword_806B33C = (int)&locret_8059810;
    sub_8061194(v1, v0);
  }
  return 0;
}
// 80498D0: using guessed type int __cdecl __sched_cpucount(_DWORD, _DWORD);
// 8049E70: using guessed type int __cdecl sched_getaffinity(_DWORD, _DWORD, _DWORD);
// 8061194: using guessed type int __fastcall sub_8061194(_DWORD, _DWORD);
// 806B33C: using guessed type int dword_806B33C;

//----- (08059812) --------------------------------------------------------
signed int __cdecl sub_8059812(int a1)
{
  void *v1; // eax
  int v3; // edx
  int v4; // ecx
  int v5; // [esp+10h] [ebp-18h]
  int v6; // [esp+14h] [ebp-14h]
  int v7; // [esp+18h] [ebp-10h]
  int v8; // [esp+1Ch] [ebp-Ch]

  v1 = &loc_8059837;
  if ( a1 != 1 )
    v1 = &loc_805987B;
  dword_806B2AC = (int)v1;
  sub_8061591();
  v6 = sub_805979E();
  if ( v6 )
    return v6;
  v7 = sysconf(84);
  if ( v7 > 0 )
    return v7;
  dword_806B234 = (int)&loc_80598C4;
  sub_806184C(v4, v3);
  v5 = sysconf(83);
  if ( v5 == 1 )
  {
    v8 = sub_805979E();
    if ( v8 )
      v5 = v8;
  }
  if ( v5 > 0 )
  {
    dword_806B298 = (int)&locret_80598C9;
    sub_8061601();
  }
  return 1;
}
// 8061591: using guessed type int sub_8061591(void);
// 8061601: using guessed type int sub_8061601(void);
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD, _DWORD);
// 806B234: using guessed type int dword_806B234;
// 806B298: using guessed type int dword_806B298;
// 806B2AC: using guessed type int dword_806B2AC;

//----- (080598CB) --------------------------------------------------------
int __fastcall sub_80598CB(int a1, int a2, int a3)
{
  void *v3; // eax

  dword_806B2D0 = sub_805991B;
  v3 = &loc_8059905;
  if ( a3 )
    v3 = &loc_8060413;
  dword_806B234 = (int)v3;
  sub_806184C(a1, a2);
  dword_806B2D0 = (int (__cdecl *)(_DWORD))&locret_8059ACD;
  return ((int (__cdecl *)(int))locret_8059ACD)(a3);
}
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD, _DWORD);
// 806B234: using guessed type int dword_806B234;
// 806B2D0: using guessed type int (__cdecl *dword_806B2D0)(_DWORD);

//----- (0805991B) --------------------------------------------------------
int __cdecl sub_805991B(int a1)
{
  dword_806B2D0 = (int (__cdecl *)(_DWORD))&loc_8059932;
  return ((int (__cdecl *)(int))loc_8059932)(a1);
}
// 806B2D0: using guessed type int (__cdecl *dword_806B2D0)(_DWORD);

//----- (0805992E) --------------------------------------------------------
#error "805996F: call analysis failed (funcsize=65)"

//----- (08059A16) --------------------------------------------------------
#error "8059A47: call analysis failed (funcsize=35)"

//----- (08059A94) --------------------------------------------------------
#error "8059ACE: positive sp value has been found (funcsize=16)"

//----- (08059ACF) --------------------------------------------------------
unsigned int __cdecl sub_8059ACF(int a1)
{
  char *v1; // eax
  int v2; // edx
  int v3; // ecx
  char *v4; // eax
  int v5; // edx
  int v6; // ecx
  int v7; // edx
  int v8; // ecx
  void *v9; // eax
  unsigned int result; // eax
  unsigned int v11; // [esp+14h] [ebp-14h]
  unsigned int v12; // [esp+18h] [ebp-10h]

  if ( a1 == 2 )
  {
    v1 = getenv("OMP_NUM_THREADS");
    v12 = sub_80598CB(v3, v2, (int)v1);
    v4 = getenv("OMP_THREAD_LIMIT");
    v11 = sub_80598CB(v6, v5, (int)v4);
    if ( !v11 )
      v11 = -1;
    v9 = &loc_8059B3C;
    if ( !v12 )
      v9 = &loc_8059B48;
    dword_806B284 = (int)v9;
    sub_8061671(v8, v7);
    result = v12;
    if ( v11 <= v12 )
      result = v11;
  }
  else
  {
    result = sub_8059812(a1);
    if ( result >= 0xFFFFFFFF )
      result = -1;
  }
  return result;
}
// 8061671: using guessed type int __fastcall sub_8061671(_DWORD, _DWORD);
// 806B284: using guessed type int dword_806B284;

//----- (08059B69) --------------------------------------------------------
long double sub_8059B69()
{
  long double v0; // fst7
  int v1; // ecx
  int v3; // [esp+4h] [ebp-74h]
  __int64 v4; // [esp+8h] [ebp-70h]
  double v5; // [esp+18h] [ebp-60h]
  double v6; // [esp+20h] [ebp-58h]
  char v7; // [esp+2Ch] [ebp-4Ch]
  unsigned int v8; // [esp+60h] [ebp-18h]
  unsigned int v9; // [esp+6Ch] [ebp-Ch]

  v9 = __readgsdword(0x14u);
  v5 = (long double)sysconf(85);
  v3 = sysconf(30);
  v6 = (long double)v3;
  if ( v5 >= 0.0 && v6 >= 0.0 )
  {
    v0 = v5 * v6;
    dword_806B2E4 = (int)&loc_8059C2B;
    sub_806141F(*(double *)&v0);
  }
  if ( !sysinfo((struct sysinfo *)&v7) )
  {
    v4 = v8;
    dword_806B284 = (int)&loc_8059C2B;
    sub_8061671(v1, 0);
  }
  return 67108864.0;
}
// 806141F: using guessed type int __usercall sub_806141F@<eax>(double@<st0>);
// 8061671: using guessed type int __fastcall sub_8061671(_DWORD, _DWORD);
// 806B284: using guessed type int dword_806B284;
// 806B2E4: using guessed type int dword_806B2E4;

//----- (08059C40) --------------------------------------------------------
long double sub_8059C40()
{
  long double v0; // fst7
  int v2; // [esp+4h] [ebp-74h]
  __int64 v3; // [esp+8h] [ebp-70h]
  double v4; // [esp+18h] [ebp-60h]
  double v5; // [esp+20h] [ebp-58h]
  char v6; // [esp+2Ch] [ebp-4Ch]
  unsigned int v7; // [esp+40h] [ebp-38h]
  unsigned int v8; // [esp+48h] [ebp-30h]
  unsigned int v9; // [esp+60h] [ebp-18h]
  unsigned int v10; // [esp+6Ch] [ebp-Ch]

  v10 = __readgsdword(0x14u);
  v4 = (long double)sysconf(86);
  v2 = sysconf(30);
  v5 = (long double)v2;
  if ( v4 >= 0.0 && v5 >= 0.0 )
  {
    v0 = v4 * v5;
    dword_806B248 = (int)&loc_8059D07;
    sub_80617DA(*(double *)&v0);
  }
  if ( sysinfo((struct sysinfo *)&v6) )
    return sub_8059B69() / 4.0;
  v3 = v9;
  return ((long double)v7 + (long double)v8) * (long double)v9;
}
// 80617DA: using guessed type int __usercall sub_80617DA@<eax>(double@<st0>);
// 806B248: using guessed type int dword_806B248;

//----- (08059D1C) --------------------------------------------------------
int __usercall sub_8059D1C@<eax>(double a1@<st0>, int pipedes[2], int a3)
{
  bool v4; // zf
  int v5; // edx
  int v6; // ecx
  void *v7; // eax
  int v8; // ST2C_4
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+1Ch] [ebp-1Ch]
  int v12; // [esp+20h] [ebp-18h]
  int v13; // [esp+20h] [ebp-18h]
  int v14; // [esp+28h] [ebp-10h]
  int v15; // [esp+2Ch] [ebp-Ch]

  v14 = *pipedes;
  v15 = pipedes[1];
  if ( dword_806C236 >= 0 )
  {
    v9 = pipe2(pipedes, a3);
    if ( v9 >= 0 || *__errno_location() != 38 )
    {
      dword_806C236 = 1;
      return v9;
    }
    dword_806C236 = -1;
  }
  if ( a3 & 0xFFF7F7FF )
  {
    *__errno_location() = 22;
    return -1;
  }
  if ( pipe(pipedes) < 0 )
    return -1;
  if ( !(a3 & 0x800)
    || (v10 = sub_805F313(a1, pipedes[1], 3, 0), v10 >= 0)
    && sub_805F313(a1, pipedes[1], 4, v10) != -1
    && (v11 = sub_805F313(a1, *pipedes, 3, 0), v11 >= 0)
    && sub_805F313(a1, *pipedes, 4, v11) != -1 )
  {
    if ( !(a3 & 0x80000) )
      return 0;
    v12 = sub_805F313(a1, pipedes[1], 1, 0);
    if ( v12 >= 0 && sub_805F313(a1, pipedes[1], 2, v12 | 1) != -1 )
    {
      v13 = sub_805F313(a1, *pipedes, 1, 0);
      if ( v13 >= 0 )
      {
        v4 = sub_805F313(a1, *pipedes, 2, v13 | 1) == -1;
        v7 = &loc_8059F42;
        if ( v4 )
          v7 = &loc_8059F49;
        dword_806B234 = (int)v7;
        sub_806184C(v6, v5);
        return 0;
      }
    }
  }
  v8 = *__errno_location();
  close(*pipedes);
  close(pipedes[1]);
  *pipedes = v14;
  pipedes[1] = v15;
  *__errno_location() = v8;
  return -1;
}
// 8049DF0: using guessed type int __cdecl pipe2(_DWORD, _DWORD);
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD, _DWORD);
// 806B234: using guessed type int dword_806B234;
// 806C236: using guessed type int dword_806C236;

//----- (08059F94) --------------------------------------------------------
int sub_8059F94()
{
  void *v0; // eax
  char *endptr; // [esp+10h] [ebp-18h]
  int v3; // [esp+14h] [ebp-14h]
  char *nptr; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]

  v3 = 200809;
  nptr = getenv("_POSIX2_VERSION");
  if ( nptr )
  {
    v0 = &loc_8059FD9;
    if ( !*nptr )
      v0 = &loc_805A006;
    dword_806B2AC = (int)v0;
    sub_8061591();
    v5 = strtol(nptr, &endptr, 10);
    if ( !*endptr )
      v3 = v5;
  }
  return v3;
}
// 8061591: using guessed type int sub_8061591(void);
// 806B2AC: using guessed type int dword_806B2AC;

//----- (0805A00B) --------------------------------------------------------
int __cdecl sub_805A00B(int a1)
{
  dword_806B2D0 = sub_805A053;
  if ( !a1 )
  {
    fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
    abort();
  }
  return dword_806B2D0(a1);
}
// 806B2D0: using guessed type int (__cdecl *dword_806B2D0)(_DWORD);

//----- (0805A053) --------------------------------------------------------
#error "805A061: call analysis failed (funcsize=19)"

//----- (0805A09A) --------------------------------------------------------
#error "805A163: positive sp value has been found (funcsize=52)"

//----- (0805A255) --------------------------------------------------------
int __cdecl sub_805A255(int *a1, unsigned __int8 a2, char a3)
{
  int *v3; // eax
  int v4; // ST10_4

  if ( a1 )
    v3 = a1;
  else
    v3 = &dword_806C24A;
  v4 = ((unsigned int)v3[(a2 >> 5) + 2] >> (a2 & 0x1F)) & 1;
  v3[(a2 >> 5) + 2] ^= (v4 ^ a3 & 1) << (a2 & 0x1F);
  return v4;
}
// 806C24A: using guessed type int dword_806C24A;

//----- (0805A2FF) --------------------------------------------------------
void __usercall __noreturn sub_805A2FF(double a1@<st0>, int a2, int a3, int a4)
{
  void *v4; // eax
  int v5; // ecx
  int (*v6)(); // eax

  v4 = &loc_805A324;
  if ( a2 )
    v4 = &loc_805A32B;
  dword_806B2E4 = (int)v4;
  sub_806141F(a1);
  dword_806C24A = 10;
  if ( a3 )
  {
    v6 = (int (*)())&loc_805A359;
    if ( a4 )
      v6 = sub_805A35E;
    dword_806B220 = (int)v6;
    sub_80618C4(v5);
  }
  abort();
}
// 805A35E: using guessed type int sub_805A35E();
// 806141F: using guessed type int __usercall sub_806141F@<eax>(double@<st0>);
// 80618C4: using guessed type int __fastcall sub_80618C4(_DWORD);
// 806B220: using guessed type int dword_806B220;
// 806B2E4: using guessed type int dword_806B2E4;
// 806C24A: using guessed type int dword_806C24A;

//----- (0805A35E) --------------------------------------------------------
#error "805A371: positive sp value has been found (funcsize=0)"

//----- (0805A372) --------------------------------------------------------
_DWORD *__userpurge sub_805A372@<eax>(_DWORD *a1, int a2)
{
  int v3; // [esp+0h] [ebp-38h]
  int v4; // [esp+4h] [ebp-34h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]

  memset(&v3, 0, 0x30u);
  if ( a2 == 10 )
    abort();
  *a1 = a2;
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = v6;
  a1[4] = v7;
  a1[5] = v8;
  a1[6] = v9;
  a1[7] = v10;
  a1[8] = v11;
  a1[9] = v12;
  a1[10] = v13;
  a1[11] = v14;
  return a1;
}

//----- (0805A3F4) --------------------------------------------------------
char *__usercall sub_805A3F4@<eax>(double a1@<st0>, char *msgid)
{
  char *result; // eax
  int v3; // edx
  int v4; // ecx
  int v5; // edx
  int v6; // ecx
  bool v7; // zf
  void *v8; // eax
  char *v9; // [esp+18h] [ebp-10h]
  unsigned __int8 *v10; // [esp+1Ch] [ebp-Ch]

  v9 = gettext(msgid);
  if ( v9 != msgid )
    return v9;
  v10 = (unsigned __int8 *)sub_8060960(a1);
  if ( sub_8060034(v3, v4, v10, "UTF-8") )
  {
    v7 = sub_8060034(v5, v6, v10, "GB18030") == 0;
    v8 = &loc_805A47F;
    if ( !v7 )
      v8 = &loc_805A4AC;
    dword_806B25C = (int)v8;
    sub_806176A();
    if ( *msgid == 96 )
    {
      dword_806B270 = (int)&loc_805A4AA;
      sub_80616F8();
    }
    result = (char *)&unk_80640EA;
  }
  else if ( *msgid == 96 )
  {
    result = (char *)&unk_80640D6;
  }
  else
  {
    result = (char *)&unk_80640DA;
  }
  return result;
}
// 80616F8: using guessed type int sub_80616F8(void);
// 806176A: using guessed type int sub_806176A(void);
// 806B25C: using guessed type int dword_806B25C;
// 806B270: using guessed type int dword_806B270;

//----- (0805A4C0) --------------------------------------------------------
unsigned int __usercall sub_805A4C0@<eax>(double st7_0@<st0>, int a1, unsigned int a2, char *a3, size_t a4, char *a5, int a6, int a7, char *a8, char *a9)
{
  int v10; // edx
  int v11; // ecx
  void *v12; // eax
  void *v13; // eax
  void *v14; // eax
  size_t v15; // ebx
  size_t v16; // eax
  char v17; // al
  bool v18; // zf
  bool v19; // sf
  unsigned __int8 v20; // of
  void *v21; // eax
  void *v22; // eax
  bool v23; // al
  void *v24; // eax
  const unsigned __int16 **v25; // eax
  size_t v26; // eax
  void *v27; // eax
  void *v28; // eax
  void *v29; // eax
  void *v30; // eax
  bool v31; // al
  unsigned int result; // eax
  void *v33; // eax
  void *v34; // eax
  char *v35; // [esp+4h] [ebp-84h]
  size_t v36; // [esp+8h] [ebp-80h]
  char *v37; // [esp+2Ch] [ebp-5Ch]
  char *v38; // [esp+30h] [ebp-58h]
  int v39; // [esp+34h] [ebp-54h]
  char *v40; // [esp+38h] [ebp-50h]
  int v41; // [esp+3Ch] [ebp-4Ch]
  char v42; // [esp+40h] [ebp-48h]
  bool v43; // [esp+41h] [ebp-47h]
  char v44; // [esp+42h] [ebp-46h]
  char v45; // [esp+43h] [ebp-45h]
  char v46; // [esp+44h] [ebp-44h]
  unsigned __int8 v47; // [esp+45h] [ebp-43h]
  char v48; // [esp+46h] [ebp-42h]
  char v49; // [esp+47h] [ebp-41h]
  char v50; // [esp+48h] [ebp-40h]
  bool v51; // [esp+49h] [ebp-3Fh]
  bool v52; // [esp+4Ah] [ebp-3Eh]
  bool v53; // [esp+4Bh] [ebp-3Dh]
  wint_t wc; // [esp+4Ch] [ebp-3Ch]
  int v55; // [esp+50h] [ebp-38h]
  unsigned int v56; // [esp+54h] [ebp-34h]
  unsigned int v57; // [esp+58h] [ebp-30h]
  char *s; // [esp+5Ch] [ebp-2Ch]
  size_t n; // [esp+60h] [ebp-28h]
  unsigned int v60; // [esp+64h] [ebp-24h]
  size_t v61; // [esp+6Ch] [ebp-1Ch]
  unsigned int v62; // [esp+70h] [ebp-18h]
  mbstate_t ps; // [esp+74h] [ebp-14h]
  unsigned int v64; // [esp+7Ch] [ebp-Ch]

  v41 = a1;
  v40 = a3;
  v39 = a7;
  v38 = a8;
  v37 = a9;
  v64 = __readgsdword(0x14u);
  v56 = 0;
  v57 = 0;
  s = 0;
  n = 0;
  v42 = 0;
  v53 = __ctype_get_mb_cur_max() == 1;
  v43 = (a6 & 2) != 0;
  v44 = 0;
  v45 = 0;
  v46 = 1;
  while ( 1 )
  {
    switch ( (unsigned int)a5 )
    {
      case 0u:
        v43 = 0;
        break;
      case 1u:
        goto LABEL_18;
      case 2u:
        goto LABEL_21;
      case 3u:
        v42 = 1;
LABEL_18:
        v43 = 1;
        goto LABEL_19;
      case 4u:
LABEL_19:
        if ( v43 != 1 )
          v42 = 1;
LABEL_21:
        a5 = (char *)2;
        if ( v43 != 1 )
        {
          if ( v56 < a2 )
          {
            v10 = v41;
            *(_BYTE *)(v41 + v56) = 39;
          }
          ++v56;
        }
        s = "'";
        n = 1;
        break;
      case 5u:
        goto LABEL_4;
      case 6u:
        a5 = (char *)5;
        v43 = 1;
LABEL_4:
        if ( v43 != 1 )
        {
          if ( v56 < a2 )
          {
            v10 = v41;
            *(_BYTE *)(v41 + v56) = 34;
          }
          ++v56;
        }
        v42 = 1;
        s = (char *)&unk_80640ED;
        n = 1;
        break;
      case 7u:
        v42 = 1;
        v43 = 0;
        break;
      case 8u:
      case 9u:
      case 0xAu:
        v12 = &loc_805A5C2;
        if ( a5 == (char *)10 )
          v12 = &loc_805A5EE;
        dword_806B304 = (int)v12;
        sub_8061308();
        v35 = a5;
        v38 = sub_805A3F4(st7_0, "`");
        v35 = a5;
        v37 = sub_805A3F4(st7_0, "'");
        if ( v43 != 1 )
        {
          s = v38;
          v13 = &loc_805A644;
          if ( *v38 )
            v13 = &loc_805A601;
          dword_806B2E4 = (int)v13;
          sub_806141F(st7_0);
        }
        v42 = 1;
        s = v37;
        n = strlen(v37);
        break;
      default:
        abort();
        return result;
    }
    v55 = 0;
LABEL_204:
    if ( a4 == -1 )
    {
      v10 = (int)v40;
      v31 = v40[v55] != 0;
    }
    else
    {
      v31 = v55 != a4;
    }
    if ( v31 )
      break;
    if ( !v56 && a5 == (char *)2 && v43 )
    {
      dword_806B270 = (int)&loc_805B240;
      sub_80616F8();
    }
    if ( a5 != (char *)2 || v43 == 1 || !v45 )
    {
      if ( s && v43 != 1 )
      {
        while ( *s )
        {
          if ( v56 < a2 )
            *(_BYTE *)(v56 + v41) = *s;
          ++v56;
          ++s;
        }
      }
      if ( v56 < a2 )
        *(_BYTE *)(v41 + v56) = 0;
      return v56;
    }
    if ( v46 )
      return sub_805A4C0(st7_0, v41, v57, v40, a4, (char *)5, a6, v39, v38, v37);
    v33 = &loc_805B1BA;
    if ( a2 )
      v33 = &loc_805B1EB;
    dword_806B33C = (int)v33;
    sub_8061194(v11, v10);
    v34 = &loc_805B1D9;
    if ( !v57 )
      v34 = &loc_805B1EB;
    dword_806B2E4 = (int)v34;
    sub_806141F(st7_0);
    a2 = v57;
    v56 = 0;
  }
  v49 = 0;
  v50 = 0;
  v51 = 0;
  if ( v42 && a5 != (char *)2 )
  {
    v14 = &loc_805A700;
    if ( !n )
      v14 = &loc_805A760;
    dword_806B2AC = (int)v14;
    sub_8061591();
    v15 = v55 + n;
    if ( a4 != -1 || n <= 1 )
    {
      v16 = a4;
    }
    else
    {
      v16 = strlen(v40);
      a4 = v16;
    }
    if ( v15 <= v16 && !memcmp(&v40[v55], s, n) )
    {
      if ( v43 )
        goto LABEL_232;
      v49 = 1;
    }
  }
  v10 = (int)v40;
  v47 = v40[v55];
  switch ( v47 )
  {
    case 0u:
      if ( v42 )
      {
        if ( v43 )
          goto LABEL_232;
        v50 = 1;
        if ( a5 == (char *)2 && v44 != 1 )
        {
          if ( v56 < a2 )
          {
            v10 = v41;
            *(_BYTE *)(v41 + v56) = 39;
          }
          if ( ++v56 < a2 )
          {
            v10 = v41;
            *(_BYTE *)(v41 + v56) = 36;
          }
          if ( ++v56 < a2 )
          {
            v10 = v41;
            *(_BYTE *)(v41 + v56) = 39;
          }
          ++v56;
          v44 = 1;
        }
        if ( v56 < a2 )
        {
          v10 = v41;
          *(_BYTE *)(v41 + v56) = 92;
        }
        ++v56;
        if ( a5 != (char *)2 && v55 + 1 < a4 )
        {
          v10 = v55 + 1;
          if ( v40[v55 + 1] > 47 )
          {
            v17 = v40[v55 + 1];
            v20 = __OFSUB__(v17, 57);
            v18 = v17 == 57;
            v19 = (char)(v17 - 57) < 0;
            v21 = &loc_805A85C;
            if ( !((unsigned __int8)(v19 ^ v20) | v18) )
              v21 = &loc_805A88A;
            dword_806B220 = (int)v21;
            sub_80618C4(v11);
            if ( v56 < a2 )
            {
              v10 = v41;
              *(_BYTE *)(v41 + v56) = 48;
            }
            if ( ++v56 < a2 )
            {
              v10 = v41;
              *(_BYTE *)(v41 + v56) = 48;
            }
            ++v56;
          }
        }
        v47 = 48;
      }
      else if ( a6 & 1 )
      {
        goto LABEL_203;
      }
      goto LABEL_171;
    case 7u:
      v48 = 97;
      goto LABEL_106;
    case 8u:
      v48 = 98;
      goto LABEL_106;
    case 9u:
      v48 = 116;
      goto LABEL_104;
    case 0xAu:
      goto LABEL_92;
    case 0xBu:
      v48 = 118;
      goto LABEL_106;
    case 0xCu:
      v48 = 102;
      dword_806B270 = (int)&loc_805AA69;
      sub_80616F8();
LABEL_92:
      v48 = 110;
      goto LABEL_104;
    case 0xDu:
      v48 = 114;
      goto LABEL_104;
    case 0x20u:
      goto LABEL_114;
    case 0x21u:
    case 0x22u:
    case 0x24u:
    case 0x26u:
    case 0x28u:
    case 0x29u:
    case 0x2Au:
    case 0x3Bu:
    case 0x3Cu:
    case 0x3Du:
    case 0x3Eu:
    case 0x5Bu:
    case 0x5Eu:
    case 0x60u:
    case 0x7Cu:
      goto LABEL_115;
    case 0x23u:
    case 0x7Eu:
      goto LABEL_113;
    case 0x25u:
    case 0x2Bu:
    case 0x2Cu:
    case 0x2Du:
    case 0x2Eu:
    case 0x2Fu:
    case 0x30u:
    case 0x31u:
    case 0x32u:
    case 0x33u:
    case 0x34u:
    case 0x35u:
    case 0x36u:
    case 0x37u:
    case 0x38u:
    case 0x39u:
    case 0x3Au:
    case 0x41u:
    case 0x42u:
    case 0x43u:
    case 0x44u:
    case 0x45u:
    case 0x46u:
    case 0x47u:
    case 0x48u:
    case 0x49u:
    case 0x4Au:
    case 0x4Bu:
    case 0x4Cu:
    case 0x4Du:
    case 0x4Eu:
    case 0x4Fu:
    case 0x50u:
    case 0x51u:
    case 0x52u:
    case 0x53u:
    case 0x54u:
    case 0x55u:
    case 0x56u:
    case 0x57u:
    case 0x58u:
    case 0x59u:
    case 0x5Au:
    case 0x5Du:
    case 0x5Fu:
    case 0x61u:
    case 0x62u:
    case 0x63u:
    case 0x64u:
    case 0x65u:
    case 0x66u:
    case 0x67u:
    case 0x68u:
    case 0x69u:
    case 0x6Au:
    case 0x6Bu:
    case 0x6Cu:
    case 0x6Du:
    case 0x6Eu:
    case 0x6Fu:
    case 0x70u:
    case 0x71u:
    case 0x72u:
    case 0x73u:
    case 0x74u:
    case 0x75u:
    case 0x76u:
    case 0x77u:
    case 0x78u:
    case 0x79u:
    case 0x7Au:
      v51 = 1;
      goto LABEL_171;
    case 0x27u:
      v45 = 1;
      v51 = 1;
      if ( a5 != (char *)2 )
        goto LABEL_171;
      v24 = &loc_805AAFC;
      if ( !v43 )
        v24 = &loc_805AB01;
      dword_806B33C = (int)v24;
      sub_8061194(v11, v40);
      goto LABEL_232;
    case 0x3Fu:
      if ( a5 == (char *)2 )
      {
        if ( v43 )
          goto LABEL_232;
      }
      else if ( a5 == (char *)5 )
      {
        if ( a6 & 4 )
        {
          if ( v55 + 2 < a4 )
          {
            v10 = v55 + 1;
            if ( v40[v55 + 1] == 63 )
            {
              v10 = v55 + 2;
              switch ( v40[v55 + 2] )
              {
                case 33:
                case 39:
                case 40:
                case 41:
                case 45:
                case 47:
                case 60:
                case 61:
                case 62:
                  if ( v43 )
                  {
                    dword_806B20C = (int)&loc_805B240;
                    sub_8061930(v11);
                  }
                  v10 = v55 + 2;
                  v47 = v40[v55 + 2];
                  v55 += 2;
                  if ( v56 < a2 )
                  {
                    v10 = v41;
                    *(_BYTE *)(v41 + v56) = 63;
                  }
                  if ( ++v56 < a2 )
                  {
                    v10 = v41;
                    *(_BYTE *)(v41 + v56) = 34;
                  }
                  if ( ++v56 < a2 )
                  {
                    v10 = v41;
                    *(_BYTE *)(v41 + v56) = 34;
                  }
                  if ( ++v56 < a2 )
                  {
                    v10 = v41;
                    *(_BYTE *)(v41 + v56) = 63;
                  }
                  ++v56;
                  break;
                default:
                  goto LABEL_171;
              }
            }
          }
        }
      }
      goto LABEL_171;
    case 0x5Cu:
      v48 = v47;
      if ( a5 == (char *)2 )
      {
        if ( v43 )
        {
          dword_806B298 = (int)&loc_805B240;
          sub_8061601();
        }
        goto LABEL_191;
      }
      if ( v42 )
      {
        v22 = &loc_805AA4D;
        if ( !v43 )
          v22 = &loc_805AA58;
        dword_806B25C = (int)v22;
        sub_806176A();
        if ( n )
          goto LABEL_191;
      }
LABEL_104:
      if ( a5 != (char *)2 || !v43 )
      {
LABEL_106:
        if ( v42 )
        {
          v47 = v48;
LABEL_178:
          if ( v43 )
            goto LABEL_232;
          v50 = 1;
          if ( a5 == (char *)2 && v44 != 1 )
          {
            if ( v56 < a2 )
            {
              v10 = v41;
              *(_BYTE *)(v41 + v56) = 39;
            }
            if ( ++v56 < a2 )
            {
              v10 = v41;
              *(_BYTE *)(v41 + v56) = 36;
            }
            if ( ++v56 < a2 )
            {
              v10 = v41;
              *(_BYTE *)(v41 + v56) = 39;
            }
            ++v56;
            v44 = 1;
          }
          if ( v56 < a2 )
          {
            v10 = v41;
            *(_BYTE *)(v41 + v56) = 92;
          }
          ++v56;
          goto LABEL_191;
        }
LABEL_171:
        if ( v42 == 1 && a5 != (char *)2 || v43 == 1 )
        {
          v29 = &loc_805AF92;
          if ( !v39 )
            v29 = &loc_805AFBE;
          dword_806B318 = (int)v29;
          sub_8061268(v11);
          v11 = v47 & 0x1F;
          v10 = *(_DWORD *)(4 * (v47 >> 5) + v39) >> v11;
          if ( v10 & 1 )
            goto LABEL_178;
        }
        if ( v49 == 1 )
          goto LABEL_178;
LABEL_191:
        if ( v44 )
        {
          v30 = &loc_805B078;
          if ( v50 == 1 )
            v30 = &loc_805B0AA;
          dword_806B234 = (int)v30;
          sub_806184C(v11, v10);
          if ( v56 < a2 )
          {
            v10 = v41;
            *(_BYTE *)(v41 + v56) = 39;
          }
          if ( ++v56 < a2 )
          {
            v10 = v41;
            *(_BYTE *)(v41 + v56) = 39;
          }
          ++v56;
          v44 = 0;
        }
        if ( v56 < a2 )
        {
          v10 = v56 + v41;
          *(_BYTE *)(v56 + v41) = v47;
        }
        ++v56;
        if ( v51 != 1 )
          v46 = 0;
LABEL_203:
        ++v55;
        goto LABEL_204;
      }
LABEL_232:
      if ( a5 == (char *)2 && v42 )
        a5 = (char *)4;
      return sub_805A4C0(st7_0, v41, a2, v40, a4, a5, a6 & 0xFFFFFFFD, 0, v38, v37);
    case 0x7Bu:
    case 0x7Du:
      if ( a4 == -1 )
        v23 = v40[1] != 0;
      else
        v23 = a4 != 1;
      if ( v23 )
        goto LABEL_171;
LABEL_113:
      if ( v55 )
        goto LABEL_171;
LABEL_114:
      v51 = 1;
LABEL_115:
      if ( a5 != (char *)2 || !v43 )
        goto LABEL_171;
      goto LABEL_232;
    default:
      if ( v53 )
      {
        v60 = 1;
        v25 = __ctype_b_loc();
        v10 = 2 * v47;
        v52 = (*(const unsigned __int16 *)((char *)*v25 + v10) & 0x4000) != 0;
      }
      else
      {
        memset(&ps, 0, 8u);
        v60 = 0;
        v52 = 1;
        if ( a4 == -1 )
          a4 = strlen(v40);
        v36 = a4 - (v60 + v55);
        v35 = &v40[v60 + v55];
        v26 = sub_805F5FA((wchar_t *)&wc, v35, v36, &ps);
        v61 = v26;
        v18 = v26 == 0;
        v27 = &loc_805AC3C;
        if ( !v18 )
          v27 = &loc_805AC41;
        dword_806B248 = (int)v27;
        sub_80617DA(st7_0);
      }
      v51 = v52;
      if ( v60 <= 1 && (!v42 || v52 == 1) )
        goto LABEL_171;
      v10 = v55;
      v62 = v55 + v60;
      while ( 1 )
      {
        if ( v42 )
        {
          v28 = &loc_805ADCE;
          if ( v52 == 1 )
            v28 = &loc_805AEB2;
          dword_806B33C = (int)v28;
          sub_8061194(v11, v10);
          if ( v43 )
          {
            dword_806B2AC = (int)&loc_805B240;
            sub_8061591();
          }
          v50 = 1;
          if ( a5 == (char *)2 && v44 != 1 )
          {
            if ( v56 < a2 )
            {
              v10 = v41;
              *(_BYTE *)(v41 + v56) = 39;
            }
            if ( ++v56 < a2 )
            {
              v10 = v41;
              *(_BYTE *)(v41 + v56) = 36;
            }
            if ( ++v56 < a2 )
            {
              v10 = v41;
              *(_BYTE *)(v41 + v56) = 39;
            }
            ++v56;
            v44 = 1;
          }
          if ( v56 < a2 )
          {
            v10 = v41;
            *(_BYTE *)(v41 + v56) = 92;
          }
          if ( ++v56 < a2 )
          {
            v10 = v56 + v41;
            *(_BYTE *)(v56 + v41) = (v47 >> 6) + 48;
          }
          if ( ++v56 < a2 )
          {
            v10 = v56 + v41;
            *(_BYTE *)(v56 + v41) = ((v47 >> 3) & 7) + 48;
          }
          ++v56;
          v47 = (v47 & 7) + 48;
        }
        else if ( v49 )
        {
          if ( v56 < a2 )
          {
            v10 = v41;
            *(_BYTE *)(v41 + v56) = 92;
          }
          ++v56;
          v49 = 0;
        }
        if ( v55 + 1 >= v62 )
          break;
        if ( v44 && v50 != 1 )
        {
          if ( v56 < a2 )
            *(_BYTE *)(v41 + v56) = 39;
          if ( ++v56 < a2 )
            *(_BYTE *)(v41 + v56) = 39;
          ++v56;
          v44 = 0;
        }
        if ( v56 < a2 )
          *(_BYTE *)(v56 + v41) = v47;
        ++v56;
        ++v55;
        v10 = (int)v40;
        v47 = v40[v55];
      }
      goto LABEL_191;
  }
}
// 8061194: using guessed type int __fastcall sub_8061194(_DWORD, _DWORD);
// 8061268: using guessed type int __fastcall sub_8061268(_DWORD);
// 8061308: using guessed type int sub_8061308(void);
// 806141F: using guessed type int __usercall sub_806141F@<eax>(double@<st0>);
// 8061591: using guessed type int sub_8061591(void);
// 8061601: using guessed type int sub_8061601(void);
// 80616F8: using guessed type int sub_80616F8(void);
// 806176A: using guessed type int sub_806176A(void);
// 80617DA: using guessed type int __usercall sub_80617DA@<eax>(double@<st0>);
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD, _DWORD);
// 80618C4: using guessed type int __fastcall sub_80618C4(_DWORD);
// 8061930: using guessed type int __fastcall sub_8061930(_DWORD);
// 806B20C: using guessed type int dword_806B20C;
// 806B220: using guessed type int dword_806B220;
// 806B234: using guessed type int dword_806B234;
// 806B248: using guessed type int dword_806B248;
// 806B25C: using guessed type int dword_806B25C;
// 806B270: using guessed type int dword_806B270;
// 806B298: using guessed type int dword_806B298;
// 806B2AC: using guessed type int dword_806B2AC;
// 806B2E4: using guessed type int dword_806B2E4;
// 806B304: using guessed type int dword_806B304;
// 806B318: using guessed type int dword_806B318;
// 806B33C: using guessed type int dword_806B33C;

//----- (0805B36A) --------------------------------------------------------
int __usercall sub_805B36A@<eax>(double a1@<st0>, char *a2, size_t a3, _DWORD *a4, int *a5)
{
  int *v5; // eax
  int *v6; // ST44_4
  int v7; // ST48_4
  int v8; // ST4C_4
  void *v9; // eax
  unsigned int size; // [esp+48h] [ebp-10h]
  int v12; // [esp+4Ch] [ebp-Ch]

  if ( a5 )
    v5 = a5;
  else
    v5 = &dword_806C24A;
  v6 = v5;
  v7 = *__errno_location();
  v8 = v6[1] | (a4 == 0);
  size = sub_805A4C0(a1, 0, 0, a2, a3, (char *)*v6, v8, (int)(v6 + 2), (char *)v6[10], (char *)v6[11]) + 1;
  v12 = sub_805E14D(size);
  sub_805A4C0(a1, v12, size, a2, a3, (char *)*v6, v8, (int)(v6 + 2), (char *)v6[10], (char *)v6[11]);
  *__errno_location() = v7;
  v9 = &loc_805B47E;
  if ( !a4 )
    v9 = &loc_805B489;
  dword_806B248 = (int)v9;
  sub_80617DA(a1);
  *a4 = size - 1;
  return v12;
}
// 80617DA: using guessed type int __usercall sub_80617DA@<eax>(double@<st0>);
// 806B248: using guessed type int dword_806B248;
// 806C24A: using guessed type int dword_806C24A;

//----- (0805B543) --------------------------------------------------------
void *__usercall sub_805B543@<eax>(double st7_0@<st0>, signed int a1, char *a2, size_t a3, int a4)
{
  int v5; // ecx
  void *v6; // eax
  size_t v7; // edx
  _DWORD *v8; // ecx
  void *v9; // edx
  char *v10; // edx
  char *v11; // eax
  char *v12; // ebx
  char *v14; // [esp+20h] [ebp-38h]
  bool v15; // [esp+37h] [ebp-21h]
  void *v16; // [esp+38h] [ebp-20h]
  void *ptr; // [esp+3Ch] [ebp-1Ch]
  int v18; // [esp+40h] [ebp-18h]
  size_t size; // [esp+44h] [ebp-14h]
  int v20; // [esp+48h] [ebp-10h]
  unsigned int v21; // [esp+4Ch] [ebp-Ch]

  v18 = *__errno_location();
  v16 = off_806B43C;
  if ( a1 < 0 )
    abort();
  if ( dword_806B430 <= a1 )
  {
    v15 = v16 == &dword_806B434;
    if ( (unsigned int)a1 > 0xFFFFFFE )
      sub_805E306();
    v6 = &loc_805B5BD;
    if ( !v15 )
      v6 = &loc_805B5D9;
    dword_806B284 = (int)v6;
    sub_8061671(v5, 8 * (a1 + 1));
    dword_806B2AC = (int)&loc_805B5DC;
    sub_8061591();
    v16 = sub_805E1AE(v16, v7);
    off_806B43C = (int *)v16;
    if ( v15 )
    {
      v8 = v16;
      v9 = off_806B438;
      *(_DWORD *)v16 = dword_806B434;
      v8[1] = v9;
    }
    memset((char *)v16 + 8 * dword_806B430, 0, 8 * (a1 + 1 - dword_806B430));
    dword_806B430 = a1 + 1;
  }
  size = *((_DWORD *)v16 + 2 * a1);
  ptr = (void *)*((_DWORD *)v16 + 2 * a1 + 1);
  v20 = *(_DWORD *)(a4 + 4) | 1;
  v10 = *(char **)(a4 + 40);
  v11 = *(char **)a4;
  v14 = *(char **)(a4 + 44);
  v21 = sub_805A4C0(st7_0, (int)ptr, size, a2, a3, v11, v20, a4 + 8, v10, v14);
  if ( size <= v21 )
  {
    size = v21 + 1;
    *((_DWORD *)v16 + 2 * a1) = v21 + 1;
    if ( ptr != &unk_806C28A )
      free(ptr);
    v12 = (char *)v16 + 8 * a1;
    ptr = (void *)sub_805E14D(size);
    *((_DWORD *)v12 + 1) = ptr;
    sub_805A4C0(st7_0, (int)ptr, size, a2, a3, *(char **)a4, v20, a4 + 8, *(char **)(a4 + 40), *(char **)(a4 + 44));
  }
  *__errno_location() = v18;
  return ptr;
}
// 8061591: using guessed type int sub_8061591(void);
// 8061671: using guessed type int __fastcall sub_8061671(_DWORD, _DWORD);
// 806B284: using guessed type int dword_806B284;
// 806B2AC: using guessed type int dword_806B2AC;
// 806B430: using guessed type int dword_806B430;
// 806B434: using guessed type int dword_806B434;
// 806B438: using guessed type void *off_806B438;
// 806B43C: using guessed type int *off_806B43C;

//----- (0805B79A) --------------------------------------------------------
void *__usercall sub_805B79A@<eax>(double a1@<st0>, signed int a2, char *a3)
{
  return sub_805B543(a1, a2, a3, 0xFFFFFFFF, (int)&dword_806C24A);
}
// 806C24A: using guessed type int dword_806C24A;

//----- (0805B7C4) --------------------------------------------------------
void *__usercall sub_805B7C4@<eax>(double a1@<st0>, signed int a2, char *a3, size_t a4)
{
  return sub_805B543(a1, a2, a3, a4, (int)&dword_806C24A);
}
// 806C24A: using guessed type int dword_806C24A;

//----- (0805B82A) --------------------------------------------------------
void *__usercall sub_805B82A@<eax>(double a1@<st0>, signed int a2, int a3, char *a4)
{
  char v5; // [esp+10h] [ebp-38h]

  sub_805A372(&v5, a3);
  return sub_805B543(a1, a2, a4, 0xFFFFFFFF, (int)&v5);
}

//----- (0805B868) --------------------------------------------------------
void *__usercall sub_805B868@<eax>(double a1@<st0>, signed int a2, int a3, char *a4, size_t a5)
{
  char v6; // [esp+10h] [ebp-38h]

  sub_805A372(&v6, a3);
  return sub_805B543(a1, a2, a4, a5, (int)&v6);
}

//----- (0805B8A5) --------------------------------------------------------
void *__usercall sub_805B8A5@<eax>(double a1@<st0>, int a2, char *a3)
{
  return sub_805B82A(a1, 0, a2, a3);
}

//----- (0805B8F0) --------------------------------------------------------
void *__usercall sub_805B8F0@<eax>(double st7_0@<st0>, char *a1, size_t a2, unsigned __int8 a3)
{
  int v5; // [esp+20h] [ebp-38h]
  int v6; // [esp+24h] [ebp-34h]
  int v7; // [esp+28h] [ebp-30h]
  int v8; // [esp+2Ch] [ebp-2Ch]
  int v9; // [esp+30h] [ebp-28h]
  int v10; // [esp+34h] [ebp-24h]
  int v11; // [esp+38h] [ebp-20h]
  int v12; // [esp+3Ch] [ebp-1Ch]
  int v13; // [esp+40h] [ebp-18h]
  int v14; // [esp+44h] [ebp-14h]
  int v15; // [esp+48h] [ebp-10h]
  int v16; // [esp+4Ch] [ebp-Ch]

  v5 = dword_806C24A;
  v6 = dword_806C24E;
  v7 = dword_806C252;
  v8 = dword_806C256;
  v9 = dword_806C25A;
  v10 = dword_806C25E;
  v11 = dword_806C262;
  v12 = dword_806C266;
  v13 = dword_806C26A;
  v14 = dword_806C26E;
  v15 = dword_806C272;
  v16 = dword_806C276;
  sub_805A255(&v5, a3, 1);
  return sub_805B543(st7_0, 0, a1, a2, (int)&v5);
}
// 806C24A: using guessed type int dword_806C24A;
// 806C24E: using guessed type int dword_806C24E;
// 806C252: using guessed type int dword_806C252;
// 806C256: using guessed type int dword_806C256;
// 806C25A: using guessed type int dword_806C25A;
// 806C25E: using guessed type int dword_806C25E;
// 806C262: using guessed type int dword_806C262;
// 806C266: using guessed type int dword_806C266;
// 806C26A: using guessed type int dword_806C26A;
// 806C26E: using guessed type int dword_806C26E;
// 806C272: using guessed type int dword_806C272;
// 806C276: using guessed type int dword_806C276;

//----- (0805B99A) --------------------------------------------------------
void *__usercall sub_805B99A@<eax>(double st7_0@<st0>, char *a1, unsigned __int8 a2)
{
  return sub_805B8F0(st7_0, a1, 0xFFFFFFFF, a2);
}

//----- (0805B9C3) --------------------------------------------------------
void *__usercall sub_805B9C3@<eax>(double st7_0@<st0>, char *a1)
{
  return sub_805B99A(st7_0, a1, 0x3Au);
}

//----- (0805BA00) --------------------------------------------------------
void *__usercall sub_805BA00@<eax>(double a1@<st0>, signed int a2, int a3, char *a4)
{
  int v5; // [esp+10h] [ebp-68h]
  int v6; // [esp+14h] [ebp-64h]
  int v7; // [esp+18h] [ebp-60h]
  int v8; // [esp+1Ch] [ebp-5Ch]
  int v9; // [esp+20h] [ebp-58h]
  int v10; // [esp+24h] [ebp-54h]
  int v11; // [esp+28h] [ebp-50h]
  int v12; // [esp+2Ch] [ebp-4Ch]
  int v13; // [esp+30h] [ebp-48h]
  int v14; // [esp+34h] [ebp-44h]
  int v15; // [esp+38h] [ebp-40h]
  int v16; // [esp+3Ch] [ebp-3Ch]
  int v17; // [esp+40h] [ebp-38h]
  int v18; // [esp+44h] [ebp-34h]
  int v19; // [esp+48h] [ebp-30h]
  int v20; // [esp+4Ch] [ebp-2Ch]
  int v21; // [esp+50h] [ebp-28h]
  int v22; // [esp+54h] [ebp-24h]
  int v23; // [esp+58h] [ebp-20h]
  int v24; // [esp+5Ch] [ebp-1Ch]
  int v25; // [esp+60h] [ebp-18h]
  int v26; // [esp+64h] [ebp-14h]
  int v27; // [esp+68h] [ebp-10h]
  int v28; // [esp+6Ch] [ebp-Ch]

  sub_805A372(&v5, a3);
  v17 = v5;
  v18 = v6;
  v19 = v7;
  v20 = v8;
  v21 = v9;
  v22 = v10;
  v23 = v11;
  v24 = v12;
  v25 = v13;
  v26 = v14;
  v27 = v15;
  v28 = v16;
  sub_805A255(&v17, 0x3Au, 1);
  return sub_805B543(a1, a2, a4, 0xFFFFFFFF, (int)&v17);
}

//----- (0805BAA1) --------------------------------------------------------
void __usercall __noreturn sub_805BAA1(double a1@<st0>, int a2, int a3, int a4)
{
  sub_805BAD1(a1, a2, a3, a4);
}

//----- (0805BAD1) --------------------------------------------------------
void __usercall __noreturn sub_805BAD1(double a1@<st0>, int a2, int a3, int a4)
{
  int v4; // [esp+10h] [ebp-38h]
  int v5; // [esp+14h] [ebp-34h]
  int v6; // [esp+18h] [ebp-30h]
  int v7; // [esp+1Ch] [ebp-2Ch]
  int v8; // [esp+20h] [ebp-28h]
  int v9; // [esp+24h] [ebp-24h]
  int v10; // [esp+28h] [ebp-20h]
  int v11; // [esp+2Ch] [ebp-1Ch]
  int v12; // [esp+30h] [ebp-18h]
  int v13; // [esp+34h] [ebp-14h]
  int v14; // [esp+38h] [ebp-10h]
  int v15; // [esp+3Ch] [ebp-Ch]

  v4 = dword_806C24A;
  v5 = dword_806C24E;
  v6 = dword_806C252;
  v7 = dword_806C256;
  v8 = dword_806C25A;
  v9 = dword_806C25E;
  v10 = dword_806C262;
  v11 = dword_806C266;
  v12 = dword_806C26A;
  v13 = dword_806C26E;
  v14 = dword_806C272;
  v15 = dword_806C276;
  sub_805A2FF(a1, (int)&v4, a3, a4);
}
// 806C24A: using guessed type int dword_806C24A;
// 806C24E: using guessed type int dword_806C24E;
// 806C252: using guessed type int dword_806C252;
// 806C256: using guessed type int dword_806C256;
// 806C25A: using guessed type int dword_806C25A;
// 806C25E: using guessed type int dword_806C25E;
// 806C262: using guessed type int dword_806C262;
// 806C266: using guessed type int dword_806C266;
// 806C26A: using guessed type int dword_806C26A;
// 806C26E: using guessed type int dword_806C26E;
// 806C272: using guessed type int dword_806C272;
// 806C276: using guessed type int dword_806C276;

//----- (0805BBCB) --------------------------------------------------------
void *__usercall sub_805BBCB@<eax>(double st7_0@<st0>, signed int a1, char *a2, size_t a3)
{
  return sub_805B543(st7_0, a1, a2, a3, (int)&unk_806B450);
}

//----- (0805BC16) --------------------------------------------------------
void *__usercall sub_805BC16@<eax>(double st7_0@<st0>, signed int a1, char *a2)
{
  return sub_805BBCB(st7_0, a1, a2, 0xFFFFFFFF);
}

//----- (0805BC38) --------------------------------------------------------
void *__usercall sub_805BC38@<eax>(double st7_0@<st0>, char *a1)
{
  return sub_805BC16(st7_0, 0, a1);
}

//----- (0805BC53) --------------------------------------------------------
int __usercall sub_805BC53@<eax>(double a1@<st0>, int ecx0@<ecx>, char *a2)
{
  void *v3; // eax
  int v4; // eax
  int v5; // edx
  int v6; // ecx

  dword_806B328 = (int (__fastcall *)(_DWORD, _DWORD))&loc_805BD01;
  v3 = &loc_805BC88;
  if ( !a2 )
    v3 = &loc_805FD7B;
  dword_806B318 = (int)v3;
  sub_8061268(ecx0);
  sub_805BC38(a1, a2);
  v4 = *__errno_location();
  dword_806B328 = (int (__fastcall *)(_DWORD, _DWORD))sub_805BCD3;
  if ( !v4 )
  {
    gettext("%s: end of file");
    dword_806B328 = (int (__fastcall *)(_DWORD, _DWORD))&loc_805BCE1;
  }
  return dword_806B328(v6, v5);
}
// 8061268: using guessed type int __fastcall sub_8061268(_DWORD);
// 806B318: using guessed type int dword_806B318;
// 806B328: using guessed type int (__fastcall *dword_806B328)(_DWORD, _DWORD);

//----- (0805BCD3) --------------------------------------------------------
#error "805BCDA: call analysis failed (funcsize=12)"

//----- (0805BD06) --------------------------------------------------------
int *__cdecl sub_805BD06(int a1, int a2)
{
  int *result; // eax

  result = (int *)sub_805E160(0x81Cu);
  *result = a1;
  result[1] = (int)sub_805BC53;
  result[2] = a2;
  return result;
}

//----- (0805BD3B) --------------------------------------------------------
unsigned int __cdecl sub_805BD3B(int a1, int a2, size_t nbytes)
{
  size_t v3; // eax
  int v4; // eax
  size_t n; // ST24_4
  int v6; // eax
  size_t v7; // ST28_4
  int v8; // eax
  size_t v9; // ST2C_4
  int v10; // eax
  size_t v11; // ST30_4
  unsigned int result; // eax
  int v13; // eax
  size_t v14; // ST34_4
  unsigned int v15; // [esp+18h] [ebp-30h]
  int fd; // [esp+20h] [ebp-28h]
  struct timeval tv; // [esp+38h] [ebp-10h]

  v15 = 0;
  fd = open64("/dev/urandom", 0);
  if ( fd >= 0 )
  {
    v3 = a2;
    if ( nbytes <= a2 )
      v3 = nbytes;
    v15 = read(fd, (void *)a1, v3);
    if ( (v15 & 0x80000000) != 0 )
      v15 = 0;
    close(fd);
  }
  if ( v15 < a2 )
  {
    v4 = a2 - v15;
    if ( a2 - v15 > 8 )
      v4 = 8;
    n = v4;
    gettimeofday(&tv, 0);
    memcpy((void *)(a1 + v15), &tv, n);
    v15 += n;
  }
  if ( v15 < a2 )
  {
    v6 = a2 - v15;
    if ( a2 - v15 > 4 )
      v6 = 4;
    v7 = v6;
    tv.tv_sec = getpid();
    memcpy((void *)(a1 + v15), &tv, v7);
    v15 += v7;
  }
  if ( v15 < a2 )
  {
    v8 = a2 - v15;
    if ( a2 - v15 > 4 )
      v8 = 4;
    v9 = v8;
    tv.tv_sec = getppid();
    memcpy((void *)(a1 + v15), &tv, v9);
    v15 += v9;
  }
  if ( v15 < a2 )
  {
    v10 = a2 - v15;
    if ( a2 - v15 > 4 )
      v10 = 4;
    v11 = v10;
    tv.tv_sec = getuid();
    memcpy((void *)(a1 + v15), &tv, v11);
    v15 += v11;
  }
  result = v15;
  if ( v15 < a2 )
  {
    v13 = a2 - v15;
    if ( a2 - v15 > 4 )
      v13 = 4;
    v14 = v13;
    tv.tv_sec = getgid();
    memcpy((void *)(a1 + v15), &tv, v14);
    result = v15 + v14;
  }
  return result;
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);

//----- (0805BF48) --------------------------------------------------------
char *__usercall sub_805BF48@<eax>(double a1@<st0>, int a2, size_t n)
{
  FILE *v3; // eax
  int v4; // edx
  int v5; // ecx
  bool v6; // zf
  void *v7; // eax
  char *result; // eax
  size_t v9; // eax
  FILE *stream; // [esp+18h] [ebp-10h]
  int *v11; // [esp+1Ch] [ebp-Ch]

  if ( !n )
  {
    sub_805BD06(0, 0);
    dword_806B304 = (int)&locret_805C051;
    sub_8061308();
  }
  stream = 0;
  if ( a2 )
  {
    v3 = sub_806033D(a1, a2, "rb");
    stream = v3;
    v6 = v3 == 0;
    v7 = &loc_805BFC1;
    if ( !v6 )
      v7 = &loc_805BFCB;
    dword_806B284 = (int)v7;
    sub_8061671(v5, v4);
    result = 0;
  }
  else
  {
    v11 = sub_805BD06((int)stream, 0);
    if ( stream )
    {
      v9 = 2048;
      if ( n <= 0x800 )
        v9 = n;
      setvbuf(stream, (char *)v11 + 12, 0, v9);
    }
    else
    {
      v11[3] = 0;
      sub_805BD3B((int)(v11 + 4), 1024, n);
      sub_805C7AF(v11 + 4);
    }
    result = (char *)v11;
  }
  return result;
}
// 8061308: using guessed type int sub_8061308(void);
// 8061671: using guessed type int __fastcall sub_8061671(_DWORD, _DWORD);
// 806B284: using guessed type int dword_806B284;
// 806B304: using guessed type int dword_806B304;

//----- (0805C06F) --------------------------------------------------------
size_t __cdecl sub_805C06F(int a1, void *ptr, size_t n)
{
  size_t v3; // ST18_4
  size_t result; // eax
  int *v5; // ebx
  int v6; // eax
  int v7; // edx
  int v8; // ecx
  int v9; // [esp+1Ch] [ebp-Ch]

  v3 = fread_unlocked(ptr, 1u, n, *(FILE **)a1);
  v9 = *__errno_location();
  result = v3;
  if ( n != v3 )
  {
    v5 = __errno_location();
    if ( ferror_unlocked(*(FILE **)a1) )
      v6 = v9;
    else
      v6 = 0;
    *v5 = v6;
    (*(void (__cdecl **)(_DWORD))(a1 + 4))(*(_DWORD *)(a1 + 8));
    dword_806B33C = (int)&loc_805C076;
    result = sub_8061194(v8, v7);
  }
  return result;
}
// 8061194: using guessed type int __fastcall sub_8061194(_DWORD, _DWORD);
// 806B33C: using guessed type int dword_806B33C;

//----- (0805C10C) --------------------------------------------------------
int __cdecl sub_805C10C(int a1, void *dest, size_t n)
{
  int result; // eax
  size_t i; // [esp+14h] [ebp-14h]
  int *v5; // [esp+18h] [ebp-10h]
  char v6; // [esp+1Ch] [ebp-Ch]

  for ( i = *(_DWORD *)a1; ; i = 1024 )
  {
    v6 = (char)dest;
    if ( n <= i )
      break;
    memcpy(dest, (const void *)(a1 + 1024 - i + 1040), i);
    dest = (char *)dest + i;
    n -= i;
    if ( !((v6 + (_BYTE)i) & 3) )
    {
      v5 = (int *)dest;
      while ( n > 0x3FF )
      {
        sub_805C30A((unsigned int *)(a1 + 4), v5);
        v5 += 256;
        n -= 1024;
        if ( !n )
        {
          result = a1;
          *(_DWORD *)a1 = 0;
          return result;
        }
      }
      dest = v5;
    }
    sub_805C30A((unsigned int *)(a1 + 4), (int *)(a1 + 1040));
  }
  memcpy(dest, (const void *)(a1 + 1024 - i + 1040), n);
  result = a1;
  *(_DWORD *)a1 = i - n;
  return result;
}

//----- (0805C21B) --------------------------------------------------------
size_t __cdecl sub_805C21B(int a1, void *ptr, size_t n)
{
  void *v3; // eax

  v3 = &loc_805C243;
  if ( !*(_DWORD *)a1 )
    v3 = &loc_805C25E;
  dword_806B304 = (int)v3;
  sub_8061308();
  return sub_805C06F(a1, ptr, n);
}
// 8061308: using guessed type int sub_8061308(void);
// 806B304: using guessed type int dword_806B304;

//----- (0805C27C) --------------------------------------------------------
int __cdecl sub_805C27C(void *ptr)
{
  int result; // eax
  FILE *stream; // [esp+1Ch] [ebp-Ch]

  stream = *(FILE **)ptr;
  explicit_bzero(ptr, 2076);
  free(ptr);
  if ( stream )
    result = sub_805F1E8(stream);
  else
    result = 0;
  return result;
}
// 8049DE0: using guessed type int __cdecl explicit_bzero(_DWORD, _DWORD);

//----- (0805C2C2) --------------------------------------------------------
int __cdecl sub_805C2C2(int a1)
{
  return a1;
}

//----- (0805C2D9) --------------------------------------------------------
int __cdecl sub_805C2D9(int a1, __int16 a2)
{
  return *(_DWORD *)((a2 & 0x3FC) + a1);
}

//----- (0805C30A) --------------------------------------------------------
unsigned int *__cdecl sub_805C30A(unsigned int *a1, int *a2)
{
  unsigned int v2; // edx
  int v3; // ST08_4
  unsigned int v4; // ST18_4
  unsigned int v5; // ST1C_4
  int v6; // eax
  int v7; // ST0C_4
  unsigned int v8; // ST08_4
  unsigned int v9; // ST20_4
  int v10; // eax
  int v11; // eax
  int v12; // ST0C_4
  int v13; // ST08_4
  unsigned int v14; // ST28_4
  int v15; // eax
  int v16; // eax
  int v17; // ST0C_4
  unsigned int v18; // ST30_4
  int v19; // eax
  int v20; // eax
  int v21; // ST08_4
  unsigned int v22; // ST38_4
  unsigned int v23; // ST3C_4
  int v24; // eax
  int v25; // ST0C_4
  unsigned int v26; // ST08_4
  unsigned int v27; // ST40_4
  int v28; // eax
  int v29; // eax
  int v30; // ST0C_4
  int v31; // ST08_4
  unsigned int v32; // ST48_4
  int v33; // eax
  int v34; // eax
  int v35; // ST0C_4
  unsigned int v36; // ST50_4
  int v37; // eax
  int v38; // eax
  unsigned int *result; // eax
  unsigned int v40; // [esp+8h] [ebp-54h]
  int v41; // [esp+Ch] [ebp-50h]
  unsigned int *v42; // [esp+10h] [ebp-4Ch]
  int *v43; // [esp+14h] [ebp-48h]

  v40 = a1[256];
  v2 = a1[257];
  v41 = v2 + ++a1[258];
  v42 = a1;
  v43 = a2;
  do
  {
    v3 = (v40 ^ (v40 << 13)) + v42[128];
    v4 = *v42;
    v5 = sub_805C2D9((int)a1, *v42) + v3 + v41;
    *v42 = v5;
    v6 = sub_805C2D9((int)a1, v5 >> 8);
    v7 = sub_805C2C2(v4 + v6);
    *v43 = v7;
    v8 = (v3 ^ ((unsigned int)sub_805C2C2(v3) >> 6)) + v42[129];
    v9 = v42[1];
    v10 = sub_805C2D9((int)a1, v42[1]);
    v42[1] = v10 + v8 + v7;
    v11 = sub_805C2D9((int)a1, (v10 + v8 + v7) >> 8);
    v12 = sub_805C2C2(v9 + v11);
    v43[1] = v12;
    v13 = (v8 ^ 4 * v8) + v42[130];
    v14 = v42[2];
    v15 = sub_805C2D9((int)a1, v42[2]);
    v42[2] = v15 + v13 + v12;
    v16 = sub_805C2D9((int)a1, (unsigned int)(v15 + v13 + v12) >> 8);
    v17 = sub_805C2C2(v14 + v16);
    v43[2] = v17;
    v40 = (v13 ^ ((unsigned int)sub_805C2C2(v13) >> 16)) + v42[131];
    v18 = v42[3];
    v19 = sub_805C2D9((int)a1, v42[3]);
    v42[3] = v19 + v40 + v17;
    v20 = sub_805C2D9((int)a1, (v19 + v40 + v17) >> 8);
    v41 = sub_805C2C2(v18 + v20);
    v43[3] = v41;
    v43 += 4;
    v42 += 4;
  }
  while ( v42 < a1 + 128 );
  do
  {
    v21 = (v40 ^ (v40 << 13)) + *(v42 - 128);
    v22 = *v42;
    v23 = sub_805C2D9((int)a1, *v42) + v21 + v41;
    *v42 = v23;
    v24 = sub_805C2D9((int)a1, v23 >> 8);
    v25 = sub_805C2C2(v22 + v24);
    *v43 = v25;
    v26 = (v21 ^ ((unsigned int)sub_805C2C2(v21) >> 6)) + *(v42 - 127);
    v27 = v42[1];
    v28 = sub_805C2D9((int)a1, v42[1]);
    v42[1] = v28 + v26 + v25;
    v29 = sub_805C2D9((int)a1, (v28 + v26 + v25) >> 8);
    v30 = sub_805C2C2(v27 + v29);
    v43[1] = v30;
    v31 = (v26 ^ 4 * v26) + *(v42 - 126);
    v32 = v42[2];
    v33 = sub_805C2D9((int)a1, v42[2]);
    v42[2] = v33 + v31 + v30;
    v34 = sub_805C2D9((int)a1, (unsigned int)(v33 + v31 + v30) >> 8);
    v35 = sub_805C2C2(v32 + v34);
    v43[2] = v35;
    v40 = (v31 ^ ((unsigned int)sub_805C2C2(v31) >> 16)) + *(v42 - 125);
    v36 = v42[3];
    v37 = sub_805C2D9((int)a1, v42[3]);
    v42[3] = v37 + v40 + v35;
    v38 = sub_805C2D9((int)a1, (v37 + v40 + v35) >> 8);
    v41 = sub_805C2C2(v36 + v38);
    v43[3] = v41;
    v43 += 4;
    v42 += 4;
  }
  while ( v42 < a1 + 256 );
  a1[256] = v40;
  result = a1;
  a1[257] = v41;
  return result;
}

//----- (0805C7AF) --------------------------------------------------------
_DWORD *__cdecl sub_805C7AF(_DWORD *a1)
{
  int v1; // ST10_4
  int v2; // ST14_4
  int v3; // ST1C_4
  int v4; // ST20_4
  int v5; // ST24_4
  int v6; // ST28_4
  int v7; // ST0C_4
  int v8; // ST18_4
  unsigned int v9; // ST10_4
  int v10; // ST1C_4
  int v11; // ST14_4
  int v12; // ST20_4
  int v13; // ST24_4
  int v14; // ST28_4
  int v15; // ST0C_4
  int v16; // ST10_4
  int v17; // ST14_4
  int v18; // ST1C_4
  int v19; // ST20_4
  int v20; // ST24_4
  int v21; // ST28_4
  int v22; // ST0C_4
  int v23; // ST18_4
  unsigned int v24; // ST10_4
  int v25; // ST1C_4
  int v26; // ST14_4
  int v27; // ST20_4
  int v28; // ST24_4
  int v29; // ST28_4
  int v30; // ST0C_4
  _DWORD *result; // eax
  int v32; // [esp+Ch] [ebp-28h]
  int v33; // [esp+10h] [ebp-24h]
  int v34; // [esp+14h] [ebp-20h]
  unsigned int v35; // [esp+18h] [ebp-1Ch]
  int v36; // [esp+1Ch] [ebp-18h]
  unsigned int v37; // [esp+20h] [ebp-14h]
  int v38; // [esp+24h] [ebp-10h]
  unsigned int v39; // [esp+28h] [ebp-Ch]
  signed int i; // [esp+2Ch] [ebp-8h]
  signed int j; // [esp+30h] [ebp-4h]

  v32 = 325574490;
  v33 = -1780940711;
  v34 = -1021952437;
  v35 = 255990488;
  v36 = -651539848;
  v37 = -1525007287;
  v38 = -990909925;
  v39 = 811634969;
  for ( i = 0; i <= 255; i += 8 )
  {
    v1 = a1[i + 1] + v33;
    v2 = a1[i + 2] + v34;
    v3 = a1[i + 4] + v36;
    v4 = a1[i + 5] + v37;
    v5 = a1[i + 6] + v38;
    v6 = a1[i + 7] + v39;
    v7 = (v1 << 11) ^ (a1[i] + v32);
    v8 = v7 + a1[i + 3] + v35;
    v9 = ((unsigned int)sub_805C2C2(v2) >> 2) ^ (v2 + v1);
    v10 = v9 + v3;
    v11 = (v8 << 8) ^ (v8 + v2);
    v12 = v11 + v4;
    v35 = ((unsigned int)sub_805C2C2(v10) >> 16) ^ (v10 + v8);
    v13 = v35 + v5;
    v36 = (v12 << 10) ^ (v12 + v10);
    v14 = v36 + v6;
    v37 = ((unsigned int)sub_805C2C2(v13) >> 4) ^ (v13 + v12);
    v15 = v37 + v7;
    v38 = (v14 << 8) ^ (v14 + v13);
    v33 = v38 + v9;
    v39 = ((unsigned int)sub_805C2C2(v15) >> 9) ^ (v15 + v14);
    v34 = v39 + v11;
    v32 = v33 + v15;
    a1[i] = v32;
    a1[i + 1] = v33;
    a1[i + 2] = v34;
    a1[i + 3] = v35;
    a1[i + 4] = v36;
    a1[i + 5] = v37;
    a1[i + 6] = v38;
    a1[i + 7] = v39;
  }
  for ( j = 0; j <= 255; j += 8 )
  {
    v16 = a1[j + 1] + v33;
    v17 = a1[j + 2] + v34;
    v18 = a1[j + 4] + v36;
    v19 = a1[j + 5] + v37;
    v20 = a1[j + 6] + v38;
    v21 = a1[j + 7] + v39;
    v22 = (v16 << 11) ^ (a1[j] + v32);
    v23 = v22 + a1[j + 3] + v35;
    v24 = ((unsigned int)sub_805C2C2(v17) >> 2) ^ (v17 + v16);
    v25 = v24 + v18;
    v26 = (v23 << 8) ^ (v23 + v17);
    v27 = v26 + v19;
    v35 = ((unsigned int)sub_805C2C2(v25) >> 16) ^ (v25 + v23);
    v28 = v35 + v20;
    v36 = (v27 << 10) ^ (v27 + v25);
    v29 = v36 + v21;
    v37 = ((unsigned int)sub_805C2C2(v28) >> 4) ^ (v28 + v27);
    v30 = v37 + v22;
    v38 = (v29 << 8) ^ (v29 + v28);
    v33 = v38 + v24;
    v39 = ((unsigned int)sub_805C2C2(v30) >> 9) ^ (v30 + v29);
    v34 = v39 + v26;
    v32 = v33 + v30;
    a1[j] = v32;
    a1[j + 1] = v33;
    a1[j + 2] = v34;
    a1[j + 3] = v35;
    a1[j + 4] = v36;
    a1[j + 5] = v37;
    a1[j + 6] = v38;
    a1[j + 7] = v39;
  }
  a1[258] = 0;
  a1[257] = a1[258];
  result = a1;
  a1[256] = a1[257];
  return result;
}

//----- (0805CBBE) --------------------------------------------------------
signed int __cdecl sub_805CBBE(_DWORD *a1)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_805F7F9((int)(a1 + 3), 0, 0, (int)malloc, (int)free);
  sub_805F7F9((int)(a1 + 14), 0, 0, (int)malloc, (int)free);
  return sub_805F7F9((int)(a1 + 25), 0, 0, (int)malloc, (int)free);
}

//----- (0805CD77) --------------------------------------------------------
_DWORD *__cdecl sub_805CD77(_DWORD *a1)
{
  _DWORD *result; // eax
  int src; // [esp+10h] [ebp-38h]
  _DWORD *v3; // [esp+14h] [ebp-34h]
  _DWORD *v4; // [esp+18h] [ebp-30h]
  int v5; // [esp+1Ch] [ebp-2Ch]
  int v6; // [esp+20h] [ebp-28h]
  _DWORD *v7; // [esp+24h] [ebp-24h]
  _DWORD *v8; // [esp+28h] [ebp-20h]
  _DWORD *v9; // [esp+2Ch] [ebp-1Ch]
  _DWORD *v10; // [esp+30h] [ebp-18h]
  _DWORD *v11; // [esp+34h] [ebp-14h]
  size_t n; // [esp+38h] [ebp-10h]
  _DWORD *v13; // [esp+3Ch] [ebp-Ch]

  v3 = a1 + 3;
  src = a1[6] - a1[5] - 1;
  v4 = a1 + 3;
  v5 = a1[5];
  if ( a1[6] == v5 )
    *((_BYTE *)v4 + 40) |= 2u;
  v4[3] = (v4[6] + v4[3]) & ~v4[6];
  if ( v4[3] - v4[1] > (unsigned int)(v4[4] - v4[1]) )
    v4[3] = v4[4];
  v4[2] = v4[3];
  v6 = v5;
  v7 = a1 + 14;
  v8 = a1 + 14;
  if ( (unsigned int)(a1[18] - a1[17]) <= 3 )
    sub_805F882((int)v7, 4);
  v9 = v7;
  v10 = (_DWORD *)v7[3];
  *v10 = v6;
  v9[3] += 4;
  v11 = a1 + 25;
  n = 4;
  v13 = a1 + 25;
  if ( (unsigned int)(a1[29] - a1[28]) < 4 )
    sub_805F882((int)v11, n);
  memcpy((void *)v11[3], &src, n);
  v11[3] += n;
  result = a1;
  ++*a1;
  return result;
}

//----- (0805CF0C) --------------------------------------------------------
bool __cdecl sub_805CF0C(FILE *stream, int a2)
{
  _BYTE *v2; // eax
  _BYTE *v3; // eax
  void *v4; // eax
  int v6; // [esp+14h] [ebp-44h]
  int v7; // [esp+3Ch] [ebp-1Ch]
  int v8; // [esp+44h] [ebp-14h]

  while ( 1 )
  {
    v6 = fgetc(stream);
    if ( v6 == -1 )
      break;
    if ( *(_DWORD *)(a2 + 28) == *(_DWORD *)(a2 + 24) )
      sub_805F882(a2 + 12, 1);
    v3 = *(_BYTE **)(a2 + 24);
    *(_DWORD *)(a2 + 24) = v3 + 1;
    *v3 = v6;
    if ( !v6 )
      sub_805CD77((_DWORD *)a2);
  }
  if ( *(_DWORD *)(a2 + 24) != *(_DWORD *)(a2 + 20) )
  {
    if ( *(_DWORD *)(a2 + 28) == *(_DWORD *)(a2 + 24) )
      sub_805F882(a2 + 12, 1);
    v2 = *(_BYTE **)(a2 + 24);
    *(_DWORD *)(a2 + 24) = v2 + 1;
    *v2 = 0;
    sub_805CD77((_DWORD *)a2);
  }
  if ( (unsigned int)(*(_DWORD *)(a2 + 72) - *(_DWORD *)(a2 + 68)) <= 3 )
    sub_805F882(a2 + 56, 4);
  **(_DWORD **)(a2 + 68) = 0;
  *(_DWORD *)(a2 + 68) += 4;
  v7 = *(_DWORD *)(a2 + 64);
  v4 = &loc_805D0A0;
  if ( *(_DWORD *)(a2 + 68) != v7 )
    v4 = &loc_805D0AD;
  dword_806B2AC = (int)v4;
  sub_8061591();
  *(_BYTE *)(a2 + 96) |= 2u;
  *(_DWORD *)(a2 + 68) = (*(_DWORD *)(a2 + 80) + *(_DWORD *)(a2 + 68)) & ~*(_DWORD *)(a2 + 80);
  if ( *(_DWORD *)(a2 + 68) - *(_DWORD *)(a2 + 60) > (unsigned int)(*(_DWORD *)(a2 + 72) - *(_DWORD *)(a2 + 60)) )
    *(_DWORD *)(a2 + 68) = *(_DWORD *)(a2 + 72);
  *(_DWORD *)(a2 + 64) = *(_DWORD *)(a2 + 68);
  *(_DWORD *)(a2 + 4) = v7;
  v8 = *(_DWORD *)(a2 + 108);
  if ( *(_DWORD *)(a2 + 112) == v8 )
    *(_BYTE *)(a2 + 140) |= 2u;
  *(_DWORD *)(a2 + 112) = (*(_DWORD *)(a2 + 124) + *(_DWORD *)(a2 + 112)) & ~*(_DWORD *)(a2 + 124);
  if ( *(_DWORD *)(a2 + 112) - *(_DWORD *)(a2 + 104) > (unsigned int)(*(_DWORD *)(a2 + 116) - *(_DWORD *)(a2 + 104)) )
    *(_DWORD *)(a2 + 112) = *(_DWORD *)(a2 + 116);
  *(_DWORD *)(a2 + 108) = *(_DWORD *)(a2 + 112);
  *(_DWORD *)(a2 + 8) = v8;
  return ferror(stream) == 0;
}
// 8061591: using guessed type int sub_8061591(void);
// 806B2AC: using guessed type int dword_806B2AC;

//----- (0805D1DE) --------------------------------------------------------
int __usercall sub_805D1DE@<eax>(double a1@<st0>, int a2, int a3)
{
  int v3; // eax
  int v4; // ecx

  v3 = mkostemp64(a2, a3);
  return sub_8060291(a3, v4, a1, v3, a3);
}
// 8049A10: using guessed type int __cdecl mkostemp64(_DWORD, _DWORD);

//----- (0805D207) --------------------------------------------------------
int __cdecl sub_805D207(_BYTE *a1, _BYTE *a2, char a3)
{
  _BYTE *v4; // eax
  _BYTE *v5; // eax
  void *v6; // eax
  char v7; // [esp+0h] [ebp-4h]
  _BYTE *v8; // [esp+Ch] [ebp+8h]

  v7 = a3;
  if ( *a1 == a3 && *a2 == v7 )
  {
    while ( *++a1 == *++a2 )
    {
      if ( (unsigned int)((char)*a1 - 48) > 9 )
        return 0;
    }
    if ( (unsigned int)((char)*a1 - 48) <= 9 && (unsigned int)((char)*a2 - 48) <= 9 )
      return (char)*a1 - (char)*a2;
    if ( (unsigned int)((char)*a1 - 48) <= 9 )
    {
      dword_806B2C0 = (int)&loc_805D2F9;
      sub_8061521();
    }
    if ( (unsigned int)((char)*a2 - 48) > 9 )
      return 0;
LABEL_20:
    v6 = &loc_805D35A;
    if ( *a2 == 48 )
      v6 = &loc_805D333;
    dword_806B298 = (int)v6;
    sub_8061601();
    return -((unsigned int)((char)*a2 - 48) <= 9);
  }
  v4 = a1;
  v8 = a1 + 1;
  if ( *v4 != v7 )
  {
    v5 = a2++;
    if ( *v5 != v7 )
      return 0;
    goto LABEL_20;
  }
  while ( *v8 == 48 )
    ++v8;
  return (unsigned int)((char)*v8 - 48) <= 9;
}
// 8061521: using guessed type int sub_8061521(void);
// 8061601: using guessed type int sub_8061601(void);
// 806B298: using guessed type int dword_806B298;
// 806B2C0: using guessed type int dword_806B2C0;

//----- (0805D37A) --------------------------------------------------------
int __usercall sub_805D37A@<eax>(double a1@<st0>, int ecx0@<ecx>, unsigned __int8 *a2, unsigned __int8 *a3, int a4, int a5)
{
  void *v6; // eax
  int v7; // edx
  int v8; // ecx
  void *v9; // eax
  int result; // eax
  void *v11; // eax
  void *v12; // eax
  void *v13; // eax
  int v14; // ecx
  int v15; // edx
  void *v16; // eax
  int v17; // ecx
  void *v18; // eax
  unsigned __int8 v19; // [esp+Eh] [ebp-Eh]
  unsigned __int8 v20; // [esp+Eh] [ebp-Eh]
  unsigned __int8 v21; // [esp+Eh] [ebp-Eh]
  unsigned __int8 v22; // [esp+Fh] [ebp-Dh]
  unsigned __int8 v23; // [esp+Fh] [ebp-Dh]
  unsigned __int8 v24; // [esp+Fh] [ebp-Dh]
  unsigned int v25; // [esp+10h] [ebp-Ch]
  unsigned int v26; // [esp+14h] [ebp-8h]
  int v27; // [esp+18h] [ebp-4h]

  v19 = *a2;
  v22 = *a3;
  if ( *a2 == 45 )
  {
    do
    {
      do
        v20 = *++a2;
      while ( *a2 == 48 );
    }
    while ( v20 == a5 );
    if ( v22 == 45 )
    {
      do
      {
        do
          v23 = *++a3;
        while ( *a3 == 48 );
      }
      while ( v23 == a5 );
      while ( v20 == v23 && (unsigned int)v20 - 48 <= 9 )
      {
        do
          v20 = *++a2;
        while ( *a2 == a5 );
        v23 = *++a3;
        v12 = &loc_805D4F3;
        if ( *a3 == a5 )
          v12 = &loc_805D4C4;
        dword_806B25C = (int)v12;
        sub_806176A();
      }
      if ( v20 == a4 && (unsigned int)v23 - 48 > 9 )
        goto LABEL_69;
      v13 = &loc_805D53F;
      if ( v23 != a4 )
        v13 = &loc_805D56C;
      dword_806B20C = (int)v13;
      sub_8061930(ecx0);
      if ( (unsigned int)v20 - 48 <= 9 )
      {
        v15 = v23 - v20;
        v27 = v23 - v20;
        v25 = 0;
        while ( (unsigned int)v20 - 48 <= 9 )
        {
          do
            v20 = *++a2;
          while ( *a2 == a5 );
          ++v25;
        }
        v26 = 0;
        while ( (unsigned int)v23 - 48 <= 9 )
        {
          do
            v23 = *++a3;
          while ( *a3 == a5 );
          ++v26;
        }
        if ( v25 == v26 )
        {
          if ( !v25 )
          {
            dword_806B234 = (int)&locret_805D8A5;
            sub_806184C(v14, v15);
          }
          result = v27;
        }
        else if ( v25 >= v26 )
        {
          result = -1;
        }
        else
        {
          result = 1;
        }
      }
      else
      {
LABEL_69:
        result = sub_805D207(a3, a2, a4);
      }
    }
    else
    {
      v6 = &loc_805D3E4;
      if ( v20 != a4 )
        v6 = &loc_805D410;
      dword_806B20C = (int)v6;
      sub_8061930(ecx0);
      v21 = a2[1];
      v9 = &loc_805D410;
      if ( v21 == 48 )
        v9 = &loc_805D3E4;
      dword_806B234 = (int)v9;
      sub_806184C(v8, v7);
      if ( (unsigned int)v21 - 48 > 9 )
      {
        while ( v22 == 48 )
          v22 = *++a3;
        v11 = &loc_805D45D;
        if ( v22 == a5 )
          v11 = &loc_805D428;
        dword_806B2C0 = (int)v11;
        sub_8061521();
        if ( v22 == a4 )
        {
          do
            v22 = *++a3;
          while ( *a3 == 48 );
        }
        result = -((unsigned int)v22 - 48 <= 9);
      }
      else
      {
        result = -1;
      }
    }
  }
  else
  {
    v16 = &loc_805D643;
    if ( v22 != 45 )
      v16 = &loc_805D6F9;
    dword_806B2E4 = (int)v16;
    sub_806141F(a1);
    do
    {
      do
        v24 = *++a3;
      while ( *a3 == 48 );
    }
    while ( v24 == a5 );
    if ( v24 == a4 )
    {
      do
        v24 = *++a3;
      while ( *a3 == 48 );
    }
    if ( (unsigned int)v24 - 48 > 9 )
    {
      while ( 1 )
      {
        v18 = &loc_805D6BF;
        if ( v19 == 48 )
          v18 = &loc_805D693;
        dword_806B318 = (int)v18;
        sub_8061268(v17);
        if ( v19 != a5 )
          break;
        v19 = *++a2;
      }
      if ( v19 == a4 )
      {
        do
          v19 = *++a2;
        while ( *a2 == 48 );
      }
      result = (unsigned int)v19 - 48 <= 9;
    }
    else
    {
      result = 1;
    }
  }
  return result;
}
// 805D37A: could not find valid save-restore pair for ebx
// 8061268: using guessed type int __fastcall sub_8061268(_DWORD);
// 806141F: using guessed type int __usercall sub_806141F@<eax>(double@<st0>);
// 8061521: using guessed type int sub_8061521(void);
// 806176A: using guessed type int sub_806176A(void);
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD, _DWORD);
// 8061930: using guessed type int __fastcall sub_8061930(_DWORD);
// 806B20C: using guessed type int dword_806B20C;
// 806B234: using guessed type int dword_806B234;
// 806B25C: using guessed type int dword_806B25C;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B2E4: using guessed type int dword_806B2E4;
// 806B318: using guessed type int dword_806B318;

//----- (0805D8A7) --------------------------------------------------------
int __usercall sub_805D8A7@<eax>(double a1@<st0>, int ecx0@<ecx>, unsigned __int8 *a2, unsigned __int8 *a3, int a4, int a5)
{
  return sub_805D37A(a1, ecx0, a2, a3, a4, a5);
}

//----- (0805D8CF) --------------------------------------------------------
int __usercall sub_805D8CF@<eax>(double a1@<st0>, int fd)
{
  int v2; // ST18_4
  int v3; // ST1C_4

  dword_806B2D0 = (int (__cdecl *)(_DWORD))&loc_805D938;
  if ( fd < 0 )
    return dword_806B2D0(fd);
  dword_806B2D0 = (int (__cdecl *)(_DWORD))&loc_805D938;
  if ( fd > 2 )
    return dword_806B2D0(fd);
  v2 = sub_8060D5E(a1, fd);
  v3 = *__errno_location();
  close(fd);
  *__errno_location() = v3;
  return v2;
}
// 806B2D0: using guessed type int (__cdecl *dword_806B2D0)(_DWORD);

//----- (0805D93D) --------------------------------------------------------
int __usercall sub_805D93D@<eax>(double a1@<st0>, FILE *stream, int a3, int a4, int a5, int a6, int a7)
{
  char *v7; // eax
  char *v8; // eax
  int v9; // ebx
  char *v10; // eax
  int result; // eax
  int v12; // esi
  int v13; // ebx
  char *v14; // eax
  int v15; // edi
  int v16; // esi
  int v17; // ebx
  char *v18; // eax
  int v19; // edi
  int v20; // esi
  int v21; // ebx
  char *v22; // eax
  int v23; // edi
  int v24; // esi
  int v25; // ebx
  char *v26; // eax
  int v27; // edi
  int v28; // esi
  int v29; // ebx
  char *v30; // eax
  int v31; // esi
  int v32; // edi
  int v33; // ebx
  char *v34; // eax
  int v35; // edi
  int v36; // esi
  int v37; // ebx
  char *v38; // eax
  int v39; // edi
  int v40; // esi
  int v41; // ebx
  char *v42; // eax
  int v43; // edi
  int v44; // esi
  int v45; // ebx
  char *v46; // eax
  char *v47; // [esp+8h] [ebp-60h]
  int v48; // [esp+Ch] [ebp-5Ch]
  int v49; // [esp+10h] [ebp-58h]
  int v50; // [esp+14h] [ebp-54h]
  int v51; // [esp+18h] [ebp-50h]
  int v52; // [esp+1Ch] [ebp-4Ch]
  int v53; // [esp+20h] [ebp-48h]
  int v54; // [esp+24h] [ebp-44h]
  int v55; // [esp+28h] [ebp-40h]
  int v56; // [esp+38h] [ebp-30h]
  int v57; // [esp+3Ch] [ebp-2Ch]
  int v58; // [esp+40h] [ebp-28h]
  int v59; // [esp+44h] [ebp-24h]
  int v60; // [esp+48h] [ebp-20h]
  int v61; // [esp+4Ch] [ebp-1Ch]

  if ( a3 )
  {
    v49 = a5;
    v48 = a4;
    v47 = (char *)a3;
    fprintf(stream, "%s (%s) %s\n", a3, a4, a5);
    dword_806B25C = (int)&loc_805D9AC;
    sub_806176A();
  }
  v48 = a5;
  v47 = (char *)a4;
  fprintf(stream, "%s %s\n", a4, a5);
  v7 = gettext("(C)");
  v48 = 2017;
  v47 = v7;
  fprintf(stream, "Copyright %s %d Free Software Foundation, Inc.", v7, 2017);
  v8 = gettext(
         "\n"
         "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\n"
         "This is free software: you are free to change and redistribute it.\n"
         "There is NO WARRANTY, to the extent permitted by law.\n"
         "\n");
  fputs_unlocked(v8, stream);
  switch ( a7 )
  {
    case 0:
      abort();
      return result;
    case 1:
      v9 = *(_DWORD *)a6;
      v10 = gettext("Written by %s.\n");
      v47 = (char *)v9;
      return fprintf(stream, v10, v9);
    case 2:
      v12 = *(_DWORD *)(a6 + 4);
      v13 = *(_DWORD *)a6;
      v14 = gettext("Written by %s and %s.\n");
      v48 = v12;
      v47 = (char *)v13;
      return fprintf(stream, v14, v13, v12);
    case 3:
      v15 = *(_DWORD *)(a6 + 8);
      v16 = *(_DWORD *)(a6 + 4);
      v17 = *(_DWORD *)a6;
      v18 = gettext("Written by %s, %s, and %s.\n");
      v49 = v15;
      v48 = v16;
      v47 = (char *)v17;
      fprintf(stream, v18, v17, v16, v15);
      dword_806B248 = (int)&loc_805DE7B;
      sub_80617DA(a1);
      goto LABEL_8;
    case 4:
LABEL_8:
      v61 = *(_DWORD *)(a6 + 12);
      v19 = *(_DWORD *)(a6 + 8);
      v20 = *(_DWORD *)(a6 + 4);
      v21 = *(_DWORD *)a6;
      v22 = gettext("Written by %s, %s, %s,\nand %s.\n");
      v50 = v61;
      v49 = v19;
      v48 = v20;
      v47 = (char *)v21;
      fprintf(stream, v22, v21, v20, v19, v61);
      dword_806B304 = (int)&loc_805DE7B;
      sub_8061308();
      goto LABEL_9;
    case 5:
LABEL_9:
      v61 = *(_DWORD *)(a6 + 16);
      v60 = *(_DWORD *)(a6 + 12);
      v23 = *(_DWORD *)(a6 + 8);
      v24 = *(_DWORD *)(a6 + 4);
      v25 = *(_DWORD *)a6;
      v26 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
      v51 = v61;
      v50 = v60;
      v49 = v23;
      v48 = v24;
      v47 = (char *)v25;
      result = fprintf(stream, v26, v25, v24, v23, v60, v61);
      break;
    case 6:
      v61 = *(_DWORD *)(a6 + 20);
      v60 = *(_DWORD *)(a6 + 16);
      v59 = *(_DWORD *)(a6 + 12);
      v27 = *(_DWORD *)(a6 + 8);
      v28 = *(_DWORD *)(a6 + 4);
      v29 = *(_DWORD *)a6;
      v30 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
      v52 = v61;
      v51 = v60;
      v50 = v59;
      v49 = v27;
      v48 = v28;
      v47 = (char *)v29;
      result = fprintf(stream, v30, v29, v28, v27, v59, v60, v61);
      break;
    case 7:
      v31 = *(_DWORD *)(a6 + 24);
      v61 = *(_DWORD *)(a6 + 20);
      v60 = *(_DWORD *)(a6 + 16);
      v59 = *(_DWORD *)(a6 + 12);
      v58 = *(_DWORD *)(a6 + 8);
      v32 = *(_DWORD *)(a6 + 4);
      v33 = *(_DWORD *)a6;
      v34 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
      v53 = v31;
      v52 = v61;
      v51 = v60;
      v50 = v59;
      v49 = v58;
      v48 = v32;
      v47 = (char *)v33;
      result = fprintf(stream, v34, v33, v32, v58, v59, v60, v61, v31);
      break;
    case 8:
      v35 = *(_DWORD *)(a6 + 28);
      v61 = *(_DWORD *)(a6 + 24);
      v60 = *(_DWORD *)(a6 + 20);
      v59 = *(_DWORD *)(a6 + 16);
      v58 = *(_DWORD *)(a6 + 12);
      v57 = *(_DWORD *)(a6 + 8);
      v36 = *(_DWORD *)(a6 + 4);
      v37 = *(_DWORD *)a6;
      v38 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
      v54 = v35;
      v53 = v61;
      v52 = v60;
      v51 = v59;
      v50 = v58;
      v49 = v57;
      v48 = v36;
      v47 = (char *)v37;
      result = fprintf(stream, v38, v37, v36, v57, v58, v59, v60, v61, v35);
      break;
    case 9:
      v39 = *(_DWORD *)(a6 + 32);
      v61 = *(_DWORD *)(a6 + 28);
      v60 = *(_DWORD *)(a6 + 24);
      v59 = *(_DWORD *)(a6 + 20);
      v58 = *(_DWORD *)(a6 + 16);
      v57 = *(_DWORD *)(a6 + 12);
      v56 = *(_DWORD *)(a6 + 8);
      v40 = *(_DWORD *)(a6 + 4);
      v41 = *(_DWORD *)a6;
      v42 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
      v55 = v39;
      v54 = v61;
      v53 = v60;
      v52 = v59;
      v51 = v58;
      v50 = v57;
      v49 = v56;
      v48 = v40;
      v47 = (char *)v41;
      result = fprintf(stream, v42, v41, v40, v56, v57, v58, v59, v60, v61, v39);
      break;
    default:
      v43 = *(_DWORD *)(a6 + 32);
      v61 = *(_DWORD *)(a6 + 28);
      v60 = *(_DWORD *)(a6 + 24);
      v59 = *(_DWORD *)(a6 + 20);
      v58 = *(_DWORD *)(a6 + 16);
      v57 = *(_DWORD *)(a6 + 12);
      v56 = *(_DWORD *)(a6 + 8);
      v44 = *(_DWORD *)(a6 + 4);
      v45 = *(_DWORD *)a6;
      v46 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
      v55 = v43;
      v54 = v61;
      v53 = v60;
      v52 = v59;
      v51 = v58;
      v50 = v57;
      v49 = v56;
      v48 = v44;
      v47 = (char *)v45;
      result = fprintf(stream, v46, v45, v44, v56, v57, v58, v59, v60, v61, v43);
      break;
  }
  return result;
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8061308: using guessed type int sub_8061308(void);
// 806176A: using guessed type int sub_806176A(void);
// 80617DA: using guessed type int __usercall sub_80617DA@<eax>(double@<st0>);
// 806B248: using guessed type int dword_806B248;
// 806B25C: using guessed type int dword_806B25C;
// 806B304: using guessed type int dword_806B304;

//----- (0805DEF0) --------------------------------------------------------
int __usercall sub_805DEF0@<eax>(double a1@<st0>, FILE *stream, int a3, int a4, int a5, int a6)
{
  int *v6; // eax
  unsigned int i; // [esp+24h] [ebp-34h]
  int v9[12]; // [esp+28h] [ebp-30h]

  for ( i = 0; i <= 9; ++i )
  {
    v6 = (int *)a6;
    a6 += 4;
    v9[i] = *v6;
    if ( !v9[i] )
      break;
  }
  return sub_805D93D(a1, stream, a3, a4, a5, (int)v9, i);
}
// 805DEF0: using guessed type int var_30[12];

//----- (0805DF56) --------------------------------------------------------
int __usercall sub_805DF56@<eax>(double a1@<st0>, FILE *stream, int a3, int a4, int a5, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a5);
  return sub_805DEF0(a1, stream, a3, a4, a5, (int)va);
}

//----- (0805DFF6) --------------------------------------------------------
int __cdecl sub_805DFF6(unsigned int a1, unsigned int a2)
{
  if ( 0x7FFFFFFF / a2 < a1 )
    sub_805E306();
  return sub_805E160(a2 * a1);
}

//----- (0805E059) --------------------------------------------------------
int __cdecl sub_805E059(int a1, unsigned int *a2, unsigned int a3)
{
  void *v3; // eax
  unsigned int v4; // edx
  int v5; // ecx
  unsigned int v7; // [esp+1Ch] [ebp-Ch]
  _DWORD *savedregs; // [esp+28h] [ebp+0h]

  savedregs = &savedregs;
  v7 = *a2;
  dword_806B328 = (int (__fastcall *)(_DWORD, _DWORD))sub_805E0F2;
  v3 = &loc_805E094;
  if ( a1 )
    v3 = &loc_805FD7B;
  dword_806B304 = (int)v3;
  sub_8061308();
  dword_806B328 = (int (__fastcall *)(_DWORD, _DWORD))&loc_805E0C9;
  if ( !v7 )
  {
    v7 = (0x40 / a3 == 0) + 0x40 / a3;
    v4 = 0x7FFFFFFF % a3;
    dword_806B328 = (int (__fastcall *)(_DWORD, _DWORD))&loc_805E12D;
    if ( 0x7FFFFFFF / a3 < v7 )
      sub_805E306();
  }
  return dword_806B328(v5, v4);
}
// 8061308: using guessed type int sub_8061308(void);
// 806B304: using guessed type int dword_806B304;
// 806B328: using guessed type int (__fastcall *dword_806B328)(_DWORD, _DWORD);

//----- (0805E0F2) --------------------------------------------------------
int __usercall sub_805E0F2@<eax>(int a1@<ecx>, int a2@<ebp>)
{
  unsigned int v2; // eax
  unsigned int v3; // edx
  bool v4; // cf
  bool v5; // zf

  v2 = 0x55555554u / *(_DWORD *)(a2 + 16);
  v3 = 0x55555554u % *(_DWORD *)(a2 + 16);
  v4 = v2 < *(_DWORD *)(a2 - 12);
  v5 = v2 == *(_DWORD *)(a2 - 12);
  dword_806B328 = (int (__fastcall *)(_DWORD, _DWORD))sub_805E11B;
  if ( v4 || v5 )
    sub_805E306();
  return dword_806B328(a1, v3);
}
// 806B328: using guessed type int (__fastcall *dword_806B328)(_DWORD, _DWORD);

//----- (0805E11B) --------------------------------------------------------
#error "805E14C: positive sp value has been found (funcsize=0)"

//----- (0805E14D) --------------------------------------------------------
int __cdecl sub_805E14D(size_t size)
{
  return sub_805E160(size);
}

//----- (0805E160) --------------------------------------------------------
int __cdecl sub_805E160(size_t size)
{
  int v1; // edx
  int v2; // ecx
  void *v3; // ST1C_4
  _DWORD *savedregs; // [esp+28h] [ebp+0h]

  savedregs = &savedregs;
  v3 = malloc(size);
  dword_806B328 = (int (__fastcall *)(_DWORD, _DWORD))sub_805E1A9;
  if ( !v3 )
  {
    dword_806B328 = (int (__fastcall *)(_DWORD, _DWORD))sub_805E1A9;
    if ( size )
      sub_805E306();
  }
  return dword_806B328(v2, v1);
}
// 805E1A9: using guessed type int sub_805E1A9();
// 806B328: using guessed type int (__fastcall *dword_806B328)(_DWORD, _DWORD);

//----- (0805E1A9) --------------------------------------------------------
#error "805E1AD: positive sp value has been found (funcsize=0)"

//----- (0805E1AE) --------------------------------------------------------
void *__cdecl sub_805E1AE(void *ptr, size_t size)
{
  int v2; // ecx
  void *v3; // eax
  void *result; // eax
  void *ptra; // [esp+20h] [ebp+8h]

  v3 = &loc_805E1D3;
  if ( size )
    v3 = &loc_805E1EB;
  dword_806B220 = (int)v3;
  sub_80618C4(v2);
  if ( ptr )
  {
    free(ptr);
    result = 0;
  }
  else
  {
    ptra = realloc(0, size);
    if ( !ptra )
    {
      if ( size )
        sub_805E306();
    }
    result = ptra;
  }
  return result;
}
// 80618C4: using guessed type int __fastcall sub_80618C4(_DWORD);
// 806B220: using guessed type int dword_806B220;

//----- (0805E262) --------------------------------------------------------
void __cdecl __noreturn sub_805E262(size_t nmemb, size_t size)
{
  bool v2; // zf
  int (*v3)(); // eax

  if ( 0x7FFFFFFF / size >= nmemb )
  {
    v2 = calloc(nmemb, size) == 0;
    v3 = (int (*)())&loc_805E2AE;
    if ( !v2 )
      v3 = sub_805E2B3;
    dword_806B2C0 = (int)v3;
    sub_8061521();
  }
  sub_805E306();
}
// 805E2B3: using guessed type int sub_805E2B3();
// 8061521: using guessed type int sub_8061521(void);
// 806B2C0: using guessed type int dword_806B2C0;

//----- (0805E2B3) --------------------------------------------------------
#error "805E2B7: positive sp value has been found (funcsize=0)"

//----- (0805E2B8) --------------------------------------------------------
void *__cdecl sub_805E2B8(void *src, size_t n)
{
  void *v2; // eax

  v2 = (void *)sub_805E160(n);
  return memcpy(v2, src, n);
}

//----- (0805E306) --------------------------------------------------------
void __noreturn sub_805E306()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (0805E33F) --------------------------------------------------------
void __usercall sub_805E33F(double a1@<st0>, int errnum, int a3, int a4, int a5, int a6)
{
  char *v6; // eax
  char *v7; // eax
  void *v8; // esi
  void *v9; // ebx
  char *v10; // eax

  v6 = gettext("string comparison failed");
  error(0, errnum, v6);
  v7 = gettext("Set LC_ALL='C' to work around the problem.");
  error(0, 0, v7);
  v8 = sub_805B868(a1, 1, 8, (char *)a5, a6);
  v9 = sub_805B868(a1, 0, 8, (char *)a3, a4);
  v10 = gettext("The strings compared were %s and %s.");
  error(status, 0, v10, v9, v8);
}

//----- (0805E470) --------------------------------------------------------
int __usercall sub_805E470@<eax>(double a1@<st0>, void *s1, size_t n, void *s2, int a5)
{
  int v6; // [esp+28h] [ebp-10h]
  int errnum; // [esp+2Ch] [ebp-Ch]

  v6 = sub_8060C28(a1, s1, n, s2, a5);
  errnum = *__errno_location();
  if ( errnum )
    sub_805E33F(a1, errnum, (int)s1, n - 1, (int)s2, a5 - 1);
  return v6;
}

//----- (0805E4DB) --------------------------------------------------------
signed int __cdecl sub_805E4DB(double a1)
{
  bool v2; // zf
  int v3; // ecx
  void *v4; // eax
  struct timespec requested_time; // [esp+28h] [ebp-10h]

  sub_8060148(&requested_time, a1);
  do
  {
    *__errno_location() = 0;
    if ( !nanosleep(&requested_time, 0) )
      return 0;
  }
  while ( *__errno_location() == 4 );
  v2 = *__errno_location() == 0;
  v4 = &loc_805E55B;
  if ( v2 )
    v4 = &loc_805E562;
  dword_806B20C = (int)v4;
  sub_8061930(v3);
  return -1;
}
// 8061930: using guessed type int __fastcall sub_8061930(_DWORD);
// 806B20C: using guessed type int dword_806B20C;

//----- (0805E566) --------------------------------------------------------
signed int __cdecl sub_805E566(unsigned int *a1, unsigned int a2)
{
  signed int result; // eax

  if ( 0xFFFFFFFF / a2 >= *a1 )
  {
    *a1 *= a2;
    result = 0;
  }
  else
  {
    *a1 = -1;
    result = 1;
  }
  return result;
}

//----- (0805E5AA) --------------------------------------------------------
int __cdecl sub_805E5AA(unsigned int *a1, unsigned int a2, int a3)
{
  int v3; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; i |= sub_805E566(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}

//----- (0805E5E0) --------------------------------------------------------
int __cdecl sub_805E5E0(char *nptr, int a2, int base, int a4, char *s)
{
  void *v5; // eax
  int v6; // ecx
  int v7; // ecx
  int result; // eax
  int v9; // ecx
  bool v10; // zf
  int v11; // edx
  int v12; // ecx
  void *v13; // eax
  void *v14; // eax
  int v15; // [esp+4h] [ebp-44h]
  unsigned __int8 i; // [esp+1Fh] [ebp-29h]
  unsigned int v17; // [esp+24h] [ebp-24h]
  int v18; // [esp+28h] [ebp-20h]
  char *v19; // [esp+2Ch] [ebp-1Ch]
  char **endptr; // [esp+3Ch] [ebp-Ch]

  v18 = 0;
  if ( base < 0 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoul");
  v5 = &loc_805E612;
  if ( base > 36 )
    v5 = &loc_805E61A;
  dword_806B304 = (int)v5;
  sub_8061308();
  if ( !a2 )
  {
    dword_806B298 = (int)&loc_805E65B;
    sub_8061601();
  }
  endptr = (char **)a2;
  *__errno_location() = 0;
  v19 = nptr;
  for ( i = *nptr; (*__ctype_b_loc())[i] & 0x2000; i = *v19 )
    ++v19;
  if ( i == 45 )
  {
    dword_806B318 = (int)&locret_805EAB5;
    sub_8061268(v6);
  }
  v17 = strtoul(nptr, endptr, base);
  if ( *endptr == nptr )
  {
    if ( s && **endptr )
    {
      v15 = **endptr;
      if ( strchr(s, v15) )
      {
        v17 = 1;
        dword_806B20C = (int)&loc_805E786;
        sub_8061930(v7);
      }
    }
    result = 4;
  }
  else if ( *__errno_location() )
  {
    v10 = *__errno_location() == 34;
    v13 = &loc_805E775;
    if ( v10 )
      v13 = &loc_805E77F;
    dword_806B33C = (int)v13;
    sub_8061194(v12, v11);
    result = 4;
  }
  else
  {
    v14 = &loc_805E7A5;
    if ( s )
      v14 = &loc_805E7B5;
    dword_806B318 = (int)v14;
    sub_8061268(v9);
    *(_DWORD *)a4 = v17;
    result = v18;
  }
  return result;
}
// 805E5E0: could not find valid save-restore pair for ebx
// 8061194: using guessed type int __fastcall sub_8061194(_DWORD, _DWORD);
// 8061268: using guessed type int __fastcall sub_8061268(_DWORD);
// 8061308: using guessed type int sub_8061308(void);
// 8061601: using guessed type int sub_8061601(void);
// 8061930: using guessed type int __fastcall sub_8061930(_DWORD);
// 806B20C: using guessed type int dword_806B20C;
// 806B298: using guessed type int dword_806B298;
// 806B304: using guessed type int dword_806B304;
// 806B318: using guessed type int dword_806B318;
// 806B33C: using guessed type int dword_806B33C;

//----- (0805EAB7) --------------------------------------------------------
void __usercall sub_805EAB7(int edx0@<edx>, int ecx0@<ecx>, double st7_0@<st0>, int a1, int a2, int a3, int a4, int a5, int status)
{
  char *v9; // eax
  const char *v10; // [esp+Ch] [ebp-2Ch]
  char *v11; // [esp+10h] [ebp-28h]
  int v12; // [esp+14h] [ebp-24h]
  char v13; // [esp+1Ch] [ebp-1Ch]
  char v14; // [esp+22h] [ebp-16h]
  char v15; // [esp+23h] [ebp-15h]
  const char *v16; // [esp+24h] [ebp-14h]
  char *msgid; // [esp+28h] [ebp-10h]
  char *v18; // [esp+2Ch] [ebp-Ch]

  v13 = a3;
  v16 = "--";
  if ( (unsigned int)a1 > 3 )
  {
    if ( a1 != 4 )
      goto LABEL_6;
    msgid = "invalid %s%s argument '%s'";
  }
  else
  {
    if ( (unsigned int)a1 >= 2 )
    {
      msgid = "invalid suffix in %s%s argument '%s'";
      dword_806B33C = (int)&loc_805EB16;
      sub_8061194(ecx0, edx0);
    }
    else if ( a1 != 1 )
    {
LABEL_6:
      abort();
    }
    msgid = "%s%s argument '%s' too large";
  }
  if ( a2 < 0 )
  {
    v16 -= a2;
    v14 = v13;
    v15 = 0;
    v18 = &v14;
    dword_806B248 = (int)&loc_805EB5E;
    sub_80617DA(st7_0);
  }
  v18 = *(char **)(16 * a2 + a4);
  v9 = gettext(msgid);
  v12 = a5;
  v11 = v18;
  v10 = v16;
  error(status, 0, v9, v16, v18, a5);
}
// 8061194: using guessed type int __fastcall sub_8061194(_DWORD, _DWORD);
// 80617DA: using guessed type int __usercall sub_80617DA@<eax>(double@<st0>);
// 806B248: using guessed type int dword_806B248;
// 806B33C: using guessed type int dword_806B33C;

//----- (0805EB97) --------------------------------------------------------
void __usercall __noreturn sub_805EB97(int ecx0@<ecx>, int edx0@<edx>, double st7_0@<st0>, int a1, int a2, char a3, int a4, int a5)
{
  sub_805EAB7(a4, ecx0, st7_0, a1, a2, a3, a4, a5, status);
  abort();
}

//----- (0805EBDA) --------------------------------------------------------
signed int __cdecl sub_805EBDA(int a1, signed int a2)
{
  signed int result; // eax
  int v3; // ebx

  if ( (unsigned __int64)sub_8060D83(0xFFFFFFFFFFFFFFFFLL, a2, a2 >> 31) >= *(_QWORD *)a1 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    *(_QWORD *)a1 *= a2;
    result = 0;
  }
  else
  {
    *(_DWORD *)a1 = -1;
    *(_DWORD *)(a1 + 4) = -1;
    result = 1;
  }
  return result;
}

//----- (0805EC66) --------------------------------------------------------
int __cdecl sub_805EC66(int a1, signed int a2, int a3)
{
  int v3; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; ; i |= sub_805EBDA(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}

//----- (0805EC9C) --------------------------------------------------------
int __usercall sub_805EC9C@<eax>(double a1@<st0>, char *nptr, int a3, int base, int a5, char *s)
{
  void *v6; // eax
  bool v7; // zf
  void *v8; // eax
  int v10; // edx
  int v11; // edx
  int v12; // ecx
  void *v13; // eax
  int v14; // eax
  void *v15; // eax
  int v16; // ecx
  int v17; // edx
  int v18; // ecx
  int v19; // edx
  int v20; // ecx
  int v21; // edx
  int v22; // edx
  int v23; // [esp+4h] [ebp-44h]
  unsigned __int8 i; // [esp+1Bh] [ebp-2Dh]
  int v25; // [esp+20h] [ebp-28h]
  char *v26; // [esp+24h] [ebp-24h]
  int v27; // [esp+28h] [ebp-20h]
  int v28; // [esp+2Ch] [ebp-1Ch]
  int v29; // [esp+30h] [ebp-18h]
  char **endptr; // [esp+34h] [ebp-14h]
  uintmax_t v31; // [esp+38h] [ebp-10h]

  v25 = 0;
  if ( base < 0 || base > 36 )
LABEL_5:
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoumax");
  if ( !a3 )
  {
    dword_806B270 = (int)&loc_805ECF6;
    sub_80616F8();
    goto LABEL_5;
  }
  endptr = (char **)a3;
  *__errno_location() = 0;
  v26 = nptr;
  for ( i = *nptr; (*__ctype_b_loc())[i] & 0x2000; i = *v26 )
    ++v26;
  v6 = &loc_805ED67;
  if ( i != 45 )
    v6 = &loc_805ED83;
  dword_806B2E4 = (int)v6;
  sub_806141F(a1);
  dword_806B298 = (int)&locret_805F1E6;
  sub_8061601();
  v31 = strtoumax(nptr, endptr, base);
  if ( *endptr == nptr )
  {
    if ( s && **endptr )
    {
      v23 = **endptr;
      v7 = strchr(s, v23) == 0;
      v8 = &loc_805EDF9;
      if ( v7 )
        v8 = &loc_805EE1E;
      dword_806B2E4 = (int)v8;
      sub_806141F(a1);
      v31 = 1LL;
      dword_806B25C = (int)&loc_805EE62;
      sub_806176A();
    }
    dword_806B298 = (int)&locret_805F1E6;
    sub_8061601();
  }
  if ( *__errno_location() )
  {
    if ( *__errno_location() != 34 )
      return 4;
    v25 = 1;
  }
  if ( !s )
  {
    v10 = HIDWORD(v31);
    *(_DWORD *)a5 = v31;
    *(_DWORD *)(a5 + 4) = v10;
    dword_806B270 = (int)&locret_805F1E6;
    sub_80616F8();
  }
  if ( **endptr )
  {
    v27 = 1024;
    v28 = 1;
    v23 = **endptr;
    if ( !strchr(s, v23) )
    {
      v11 = HIDWORD(v31);
      *(_DWORD *)a5 = v31;
      *(_DWORD *)(a5 + 4) = v11;
      dword_806B248 = (int)&locret_805F1E6;
      sub_80617DA(a1);
    }
    switch ( **endptr )
    {
      case 69:
      case 71:
      case 75:
      case 77:
      case 80:
      case 84:
      case 89:
      case 90:
      case 103:
      case 107:
      case 109:
      case 116:
        v7 = strchr(s, 48) == 0;
        v13 = &loc_805EF47;
        if ( v7 )
          v13 = &loc_805EFA1;
        dword_806B220 = (int)v13;
        sub_80618C4(v12);
        v14 = (*endptr)[1];
        if ( v14 == 68 )
        {
          v27 = 1000;
          ++v28;
        }
        else if ( v14 == 105 )
        {
          if ( (*endptr)[2] == 66 )
            v28 += 2;
        }
        else
        {
          v7 = v14 == 66;
          v15 = &loc_805EF7D;
          if ( v7 )
            v15 = &loc_805EF96;
          dword_806B304 = (int)v15;
          sub_8061308();
        }
        break;
      default:
        break;
    }
    switch ( **endptr )
    {
      case 66:
        goto LABEL_41;
      case 69:
        v29 = sub_805EC66((int)&v31, v27, 6);
        dword_806B318 = (int)&loc_805F1B0;
        sub_8061268(v16);
        goto LABEL_44;
      case 71:
      case 103:
LABEL_44:
        v29 = sub_805EC66((int)&v31, v27, 3);
        break;
      case 75:
      case 107:
        v29 = sub_805EC66((int)&v31, v27, 1);
        break;
      case 77:
      case 109:
        v29 = sub_805EC66((int)&v31, v27, 2);
        break;
      case 80:
        v29 = sub_805EC66((int)&v31, v27, 5);
        break;
      case 84:
      case 116:
        v29 = sub_805EC66((int)&v31, v27, 4);
        dword_806B284 = (int)&loc_805F1B0;
        sub_8061671(v18, v17);
        goto LABEL_49;
      case 89:
        goto LABEL_50;
      case 90:
        v29 = sub_805EC66((int)&v31, v27, 7);
        dword_806B33C = (int)&loc_805F1B0;
        sub_8061194(v20, v19);
        goto LABEL_52;
      case 98:
        v29 = sub_805EBDA((int)&v31, 512);
        dword_806B298 = (int)&loc_805F1B0;
        sub_8061601();
LABEL_41:
        v29 = sub_805EBDA((int)&v31, 1024);
        break;
      case 99:
        v29 = 0;
        break;
      case 119:
LABEL_49:
        v29 = sub_805EBDA((int)&v31, 2);
        dword_806B2C0 = (int)&loc_805F1B0;
        sub_8061521();
LABEL_50:
        v29 = sub_805EC66((int)&v31, v27, 8);
        break;
      default:
LABEL_52:
        v21 = HIDWORD(v31);
        *(_DWORD *)a5 = v31;
        *(_DWORD *)(a5 + 4) = v21;
        dword_806B318 = (int)&locret_805F1E6;
        sub_8061268(a5);
        break;
    }
    v25 |= v29;
    *endptr += v28;
    if ( **endptr )
      v25 |= 2u;
  }
  v22 = HIDWORD(v31);
  *(_DWORD *)a5 = v31;
  *(_DWORD *)(a5 + 4) = v22;
  return v25;
}
// 805EC9C: could not find valid save-restore pair for ebx
// 8061194: using guessed type int __fastcall sub_8061194(_DWORD, _DWORD);
// 8061268: using guessed type int __fastcall sub_8061268(_DWORD);
// 8061308: using guessed type int sub_8061308(void);
// 806141F: using guessed type int __usercall sub_806141F@<eax>(double@<st0>);
// 8061521: using guessed type int sub_8061521(void);
// 8061601: using guessed type int sub_8061601(void);
// 8061671: using guessed type int __fastcall sub_8061671(_DWORD, _DWORD);
// 80616F8: using guessed type int sub_80616F8(void);
// 806176A: using guessed type int sub_806176A(void);
// 80617DA: using guessed type int __usercall sub_80617DA@<eax>(double@<st0>);
// 80618C4: using guessed type int __fastcall sub_80618C4(_DWORD);
// 806B220: using guessed type int dword_806B220;
// 806B248: using guessed type int dword_806B248;
// 806B25C: using guessed type int dword_806B25C;
// 806B270: using guessed type int dword_806B270;
// 806B284: using guessed type int dword_806B284;
// 806B298: using guessed type int dword_806B298;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B2E4: using guessed type int dword_806B2E4;
// 806B304: using guessed type int dword_806B304;
// 806B318: using guessed type int dword_806B318;
// 806B33C: using guessed type int dword_806B33C;

//----- (0805F1E8) --------------------------------------------------------
int __cdecl sub_805F1E8(FILE *stream)
{
  int v1; // edx
  int v2; // ecx
  int v3; // ST1C_4

  v3 = fileno(stream);
  dword_806B328 = (int (__fastcall *)(_DWORD, _DWORD))sub_805F240;
  if ( v3 < 0 )
  {
    fclose(stream);
    dword_806B328 = (int (__fastcall *)(_DWORD, _DWORD))&locret_805F311;
  }
  return dword_806B328(v2, v1);
}
// 805F240: using guessed type int __cdecl sub_805F240(int, int, int);
// 806B328: using guessed type int (__fastcall *dword_806B328)(_DWORD, _DWORD);

//----- (0805F240) --------------------------------------------------------
#error "805F312: positive sp value has been found (funcsize=51)"

//----- (0805F313) --------------------------------------------------------
int __usercall sub_805F313@<eax>(double a1@<st0>, int fd, int cmd, char a4)
{
  char *v4; // eax
  char *v5; // eax
  int v7; // [esp+8h] [ebp-30h]
  char *v8; // [esp+18h] [ebp-20h]
  int v9; // [esp+1Ch] [ebp-1Ch]
  char v10[4]; // [esp+20h] [ebp-18h]
  int v11; // [esp+24h] [ebp-14h]
  int v12; // [esp+28h] [ebp-10h]

  v9 = -1;
  v8 = &a4;
  if ( cmd != 1030 )
  {
    v5 = v8;
    v8 += 4;
    return fcntl(fd, cmd, *(_DWORD *)v5);
  }
  v4 = v8;
  v8 += 4;
  *(_DWORD *)v10 = *(_DWORD *)v4;
  if ( dword_806C38A < 0 )
  {
    v9 = sub_805F313(a1, fd, 0, v10[0]);
    goto LABEL_9;
  }
  v7 = *(_DWORD *)v10;
  v9 = fcntl(fd, 1030, *(_DWORD *)v10);
  if ( v9 >= 0 || *__errno_location() != 22 )
  {
    dword_806C38A = 1;
    dword_806B248 = (int)&loc_805F3EF;
    sub_80617DA(a1);
  }
  v9 = sub_805F313(a1, fd, 0, v10[0]);
  if ( v9 >= 0 )
  {
    dword_806C38A = -1;
LABEL_9:
    if ( v9 >= 0 && dword_806C38A == -1 )
    {
      v11 = fcntl(v9, 1);
      if ( v11 < 0 || (v7 = v11 | 1, fcntl(v9, 2, v11 | 1) == -1) )
      {
        v12 = *__errno_location();
        close(v9);
        *__errno_location() = v12;
        v9 = -1;
        dword_806B2E4 = (int)&loc_805F4AA;
        sub_806141F(a1);
      }
    }
  }
  return v9;
}
// 806141F: using guessed type int __usercall sub_806141F@<eax>(double@<st0>);
// 80617DA: using guessed type int __usercall sub_80617DA@<eax>(double@<st0>);
// 806B248: using guessed type int dword_806B248;
// 806B2E4: using guessed type int dword_806B2E4;
// 806C38A: using guessed type int dword_806C38A;

//----- (0805F4AF) --------------------------------------------------------
int __cdecl sub_805F4AF(FILE *stream)
{
  int result; // eax

  result = stream->_flags & 0x100;
  if ( result )
    result = sub_805F528(stream, 0, 0, 1);
  return result;
}

//----- (0805F4E8) --------------------------------------------------------
int __cdecl sub_805F4E8(FILE *fp)
{
  if ( !fp || !__freading(fp) )
    return fflush(fp);
  sub_805F4AF(fp);
  return fflush(fp);
}

//----- (0805F528) --------------------------------------------------------
int __cdecl sub_805F528(FILE *stream, int a2, int a3, int a4)
{
  int v4; // eax
  __off64_t v5; // rax

  if ( stream->_IO_read_end != stream->_IO_read_ptr
    || stream->_IO_write_ptr != stream->_IO_write_base
    || stream->_IO_save_base )
  {
    return fseeko64(stream, a2, a3, a4);
  }
  v4 = fileno(stream);
  LODWORD(v5) = lseek64(v4, a2, a3, a4);
  if ( v5 == -1 )
    return -1;
  stream->_flags &= 0xFFFFFFEF;
  stream->_offset = v5;
  return 0;
}
// 80498B0: using guessed type int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8049A90: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0805F5FA) --------------------------------------------------------
size_t __cdecl sub_805F5FA(wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  int v4; // edx
  int v5; // ecx
  void *v6; // eax
  bool v7; // zf
  int v8; // edx
  int v9; // ecx
  void *v10; // eax
  char v12; // [esp+18h] [ebp-10h]
  size_t v13; // [esp+1Ch] [ebp-Ch]

  if ( !pwc )
    pwc = (wchar_t *)&v12;
  v13 = mbrtowc(pwc, s, n, p);
  if ( v13 <= 0xFFFFFFFD )
    return v13;
  v6 = &loc_805F654;
  if ( !n )
    v6 = &loc_805F699;
  dword_806B234 = (int)v6;
  sub_806184C(v5, v4);
  v7 = (unsigned __int8)sub_80579D4(0) == 1;
  v10 = &loc_805F680;
  if ( v7 )
    v10 = &loc_805F699;
  dword_806B284 = (int)v10;
  sub_8061671(v9, v8);
  *pwc = (unsigned __int8)*s;
  return 1;
}
// 805F5FA: could not find valid save-restore pair for ebx
// 8061671: using guessed type int __fastcall sub_8061671(_DWORD, _DWORD);
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD, _DWORD);
// 806B234: using guessed type int dword_806B234;
// 806B284: using guessed type int dword_806B284;

//----- (0805F69E) --------------------------------------------------------
int __cdecl sub_805F69E(int a1, int a2)
{
  int result; // eax

  if ( *(_BYTE *)(a1 + 40) & 1 )
    result = (*(int (__cdecl **)(_DWORD, int))(a1 + 28))(*(_DWORD *)(a1 + 36), a2);
  else
    result = (*(int (__cdecl **)(int))(a1 + 28))(a2);
  return result;
}

//----- (0805F6DC) --------------------------------------------------------
int __cdecl sub_805F6DC(int a1, int a2)
{
  int result; // eax

  if ( *(_BYTE *)(a1 + 40) & 1 )
    result = (*(int (__cdecl **)(_DWORD, int))(a1 + 32))(*(_DWORD *)(a1 + 36), a2);
  else
    result = (*(int (__cdecl **)(int))(a1 + 32))(a2);
  return result;
}

//----- (0805F71A) --------------------------------------------------------
signed int __cdecl sub_805F71A(int a1, signed int a2, signed int a3)
{
  _DWORD *v4; // [esp+1Ch] [ebp-Ch]

  if ( !a3 )
    a3 = 8;
  if ( !a2 )
    a2 = 4064;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 24) = a3 - 1;
  *(_DWORD *)(a1 + 4) = sub_805F69E(a1, *(_DWORD *)a1);
  v4 = *(_DWORD **)(a1 + 4);
  if ( !v4 )
    obstack_alloc_failed_handler();
  *(_DWORD *)(a1 + 8) = ((unsigned int)&v4[a3 / 4u + 1] + 3) & -a3;
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 8);
  *v4 = (char *)v4 + *(_DWORD *)a1;
  *(_DWORD *)(a1 + 16) = *v4;
  v4[1] = 0;
  *(_BYTE *)(a1 + 40) &= 0xFDu;
  *(_BYTE *)(a1 + 40) &= 0xFBu;
  return 1;
}
// 806B500: using guessed type int (*obstack_alloc_failed_handler)(void);

//----- (0805F7F9) --------------------------------------------------------
signed int __cdecl sub_805F7F9(int a1, signed int a2, signed int a3, int a4, int a5)
{
  *(_DWORD *)(a1 + 28) = a4;
  *(_DWORD *)(a1 + 32) = a5;
  *(_BYTE *)(a1 + 40) &= 0xFEu;
  return sub_805F71A(a1, a2, a3);
}

//----- (0805F882) --------------------------------------------------------
int __cdecl sub_805F882(int a1, int a2)
{
  int v2; // ecx
  void *v3; // eax
  int result; // eax
  _DWORD *v5; // [esp+14h] [ebp-24h]
  unsigned int v6; // [esp+18h] [ebp-20h]
  int v7; // [esp+1Ch] [ebp-1Ch]
  unsigned int n; // [esp+20h] [ebp-18h]
  unsigned int v9; // [esp+24h] [ebp-14h]
  unsigned int v10; // [esp+28h] [ebp-10h]
  void *dest; // [esp+2Ch] [ebp-Ch]

  v7 = *(_DWORD *)(a1 + 4);
  v5 = 0;
  n = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 8);
  v9 = n + a2;
  v10 = *(_DWORD *)(a1 + 24) + n + a2;
  v6 = (n >> 3) + v10 + 100;
  if ( v6 < v10 )
    v6 = *(_DWORD *)(a1 + 24) + n + a2;
  if ( *(_DWORD *)a1 > v6 )
    v6 = *(_DWORD *)a1;
  if ( n <= v9 && v9 <= v10 )
    v5 = (_DWORD *)sub_805F69E(a1, v6);
  if ( !v5 )
    obstack_alloc_failed_handler();
  *(_DWORD *)(a1 + 4) = v5;
  v5[1] = v7;
  *(_DWORD *)(a1 + 16) = (char *)v5 + v6;
  *v5 = *(_DWORD *)(a1 + 16);
  dest = (void *)(((unsigned int)v5 + *(_DWORD *)(a1 + 24) + 8) & ~*(_DWORD *)(a1 + 24));
  memcpy(dest, *(const void **)(a1 + 8), n);
  if ( !(*(_BYTE *)(a1 + 40) & 2) )
  {
    v2 = *(_DWORD *)(a1 + 24) + v7 + 8;
    v3 = &loc_805F9DA;
    if ( *(_DWORD *)(a1 + 8) != (v2 & ~*(_DWORD *)(a1 + 24)) )
      v3 = &loc_805F9F8;
    dword_806B318 = (int)v3;
    sub_8061268(v2);
    v5[1] = *(_DWORD *)(v7 + 4);
    sub_805F6DC(a1, v7);
  }
  *(_DWORD *)(a1 + 8) = dest;
  *(_DWORD *)(a1 + 12) = n + *(_DWORD *)(a1 + 8);
  result = a1;
  *(_BYTE *)(a1 + 40) &= 0xFDu;
  return result;
}
// 8061268: using guessed type int __fastcall sub_8061268(_DWORD);
// 806B318: using guessed type int dword_806B318;
// 806B500: using guessed type int (*obstack_alloc_failed_handler)(void);

//----- (0805FA65) --------------------------------------------------------
int __cdecl sub_805FA65(int a1, unsigned int a2)
{
  int result; // eax
  int *v3; // ST1C_4
  int *v4; // [esp+18h] [ebp-10h]

  result = *(_DWORD *)(a1 + 4);
  v4 = *(int **)(a1 + 4);
  while ( v4 )
  {
    if ( (unsigned int)v4 < a2 )
    {
      result = *v4;
      if ( *v4 >= a2 )
        break;
    }
    v3 = (int *)v4[1];
    sub_805F6DC(a1, (int)v4);
    v4 = v3;
    result = a1;
    *(_BYTE *)(a1 + 40) |= 2u;
  }
  if ( v4 )
  {
    *(_DWORD *)(a1 + 12) = a2;
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 16) = *v4;
    result = a1;
    *(_DWORD *)(a1 + 4) = v4;
  }
  else if ( a2 )
  {
    abort();
  }
  return result;
}

//----- (0805FC90) --------------------------------------------------------
int __cdecl sub_805FC90(int a1, char a2)
{
  return __ROR4__(a1, a2);
}

//----- (0805FD85) --------------------------------------------------------
signed int __cdecl sub_805FD85(signed int a1)
{
  if ( a1 > 90 )
  {
    if ( (unsigned int)(a1 - 97) <= 0x19 )
      return 1;
  }
  else if ( a1 >= 65 || (unsigned int)(a1 - 48) <= 9 )
  {
    return 1;
  }
  return 0;
}

//----- (0805FDB5) --------------------------------------------------------
_BOOL4 __cdecl sub_805FDB5(signed int a1)
{
  return a1 >= 65 && (a1 <= 90 || (unsigned int)(a1 - 97) <= 0x19);
}

//----- (0805FE67) --------------------------------------------------------
_BOOL4 __cdecl sub_805FE67(int a1)
{
  return (unsigned int)(a1 - 48) <= 9;
}

//----- (0805FF3F) --------------------------------------------------------
_BOOL4 __cdecl sub_805FF3F(signed int a1)
{
  return a1 >= 9 && (a1 <= 13 || a1 == 32);
}

//----- (0805FFB8) --------------------------------------------------------
int __fastcall sub_805FFB8(int ecx0, int a2, int a1)
{
  dword_806B328 = (int (__fastcall *)(_DWORD, _DWORD))sub_805FFF1;
  if ( (unsigned int)(a1 - 65) <= 0x19 )
    dword_806B328 = (int (__fastcall *)(_DWORD, _DWORD))&loc_805FFF4;
  return dword_806B328(ecx0, a2);
}
// 805FFF1: using guessed type int sub_805FFF1();
// 806B328: using guessed type int (__fastcall *dword_806B328)(_DWORD, _DWORD);

//----- (0805FFF1) --------------------------------------------------------
#error "805FFF5: positive sp value has been found (funcsize=0)"

//----- (08060034) --------------------------------------------------------
int __usercall sub_8060034@<eax>(int edx0@<edx>, int ecx0@<ecx>, unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v4; // esi
  unsigned __int8 *v5; // ebx
  int v7; // edx
  int v8; // ecx
  int v9; // ecx
  void *v10; // eax
  int v11; // [esp+0h] [ebp-28h]
  unsigned __int8 v12; // [esp+1Eh] [ebp-Ah]
  unsigned __int8 v13; // [esp+1Fh] [ebp-9h]

  v4 = a1;
  v5 = a2;
  if ( a1 == a2 )
    return 0;
  do
  {
    v11 = *v4;
    v12 = sub_805FFB8(ecx0, edx0, v11);
    v11 = *v5;
    v13 = sub_805FFB8(v8, v7, v11);
    v10 = &loc_806008E;
    if ( v12 )
      v10 = &loc_80600A5;
    dword_806B318 = (int)v10;
    sub_8061268(v9);
    dword_806B298 = (int)&loc_80600B4;
    sub_8061601();
    ++v4;
    ++v5;
  }
  while ( v12 == v13 );
  return v12 - v13;
}
// 8061268: using guessed type int __fastcall sub_8061268(_DWORD);
// 8061601: using guessed type int sub_8061601(void);
// 806B298: using guessed type int dword_806B298;
// 806B318: using guessed type int dword_806B318;

//----- (080600C7) --------------------------------------------------------
int __cdecl sub_80600C7(FILE *fp)
{
  bool v1; // ST1E_1
  bool v3; // [esp+1Dh] [ebp-Bh]
  bool v4; // [esp+1Fh] [ebp-9h]

  v3 = __fpending(fp) != 0;
  v1 = ferror_unlocked(fp) != 0;
  v4 = sub_805F1E8(fp) != 0;
  if ( !v1 && (!v4 || !v3 && *__errno_location() == 9) )
    return 0;
  if ( v4 != 1 )
    *__errno_location() = 0;
  return -1;
}

//----- (08060148) --------------------------------------------------------
_DWORD *__userpurge sub_8060148@<eax>(_DWORD *a1, double a2)
{
  signed int v2; // ST20_4
  double v3; // ST28_8
  int v4; // ST24_4
  int v6; // [esp+20h] [ebp-18h]
  int v7; // [esp+24h] [ebp-14h]

  if ( a2 <= -2147483648.0 )
  {
    sub_8060C87(a1, 2147483648, 0);
  }
  else if ( 2147483648.0 <= a2 )
  {
    sub_8060C87(a1, 0x7FFFFFFF, 999999999);
  }
  else
  {
    v2 = (signed int)a2;
    v3 = (a2 - (long double)v2) * 1000000000.0;
    v4 = (v3 > (long double)(signed int)v3) + (signed int)v3;
    v6 = v4 / 1000000000 + v2;
    v7 = v4 % 1000000000;
    if ( v7 < 0 )
    {
      --v6;
      v7 += 1000000000;
    }
    sub_8060C87(a1, v6, v7);
  }
  return a1;
}

//----- (08060291) --------------------------------------------------------
int __usercall sub_8060291@<eax>(int a1@<edx>, int a2@<ecx>, double a3@<st0>, int fd, int a5)
{
  int v5; // ST18_4
  int v6; // ST1C_4

  dword_806B328 = (int (__fastcall *)(_DWORD, _DWORD))&loc_8060301;
  if ( fd < 0 )
    return dword_806B328(a2, a1);
  dword_806B328 = (int (__fastcall *)(_DWORD, _DWORD))&loc_8060301;
  if ( fd > 2 )
    return dword_806B328(a2, a1);
  v5 = sub_8060306(a3, fd, a5);
  v6 = *__errno_location();
  close(fd);
  *__errno_location() = v6;
  return v5;
}
// 806B328: using guessed type int (__fastcall *dword_806B328)(_DWORD, _DWORD);

//----- (08060306) --------------------------------------------------------
int __usercall sub_8060306@<eax>(double a1@<st0>, int fd, int a3)
{
  int v3; // eax

  if ( a3 & 0x80000 )
    v3 = 1030;
  else
    v3 = 0;
  return sub_805F313(a1, fd, v3, 3);
}

//----- (0806033D) --------------------------------------------------------
FILE *__usercall sub_806033D@<eax>(double a1@<st0>, int a2, char *modes)
{
  int v3; // ST28_4
  int v5; // ST2C_4
  FILE *stream; // [esp+1Ch] [ebp-1Ch]
  signed int v7; // [esp+20h] [ebp-18h]
  int fd; // [esp+24h] [ebp-14h]

  stream = (FILE *)fopen64(a2, modes);
  if ( !stream )
    return stream;
  v7 = fileno(stream);
  if ( v7 < 0 || v7 > 2 )
    return stream;
  fd = sub_8060D5E(a1, v7);
  if ( fd < 0 )
  {
    v3 = *__errno_location();
    sub_805F1E8(stream);
    *__errno_location() = v3;
    return 0;
  }
  if ( !sub_805F1E8(stream) )
  {
    stream = fdopen(fd, modes);
    if ( stream )
      return stream;
  }
  v5 = *__errno_location();
  close(fd);
  *__errno_location() = v5;
  return 0;
}
// 80499F0: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (0806041D) --------------------------------------------------------
void *__usercall sub_806041D@<eax>(double a1@<st0>)
{
  int v1; // ecx
  void *v2; // eax
  signed int v3; // eax
  void *v4; // eax
  int v5; // edx
  int v6; // ecx
  bool v7; // zf
  void *v8; // eax
  int v9; // edx
  int v10; // ecx
  void *v11; // eax
  int v12; // edx
  int v13; // ecx
  void *v14; // eax
  void *v15; // eax
  void *ptr; // [esp+14h] [ebp-B4h]
  void *v18; // [esp+18h] [ebp-B0h]
  char *s; // [esp+1Ch] [ebp-ACh]
  void *v20; // [esp+20h] [ebp-A8h]
  int v21; // [esp+24h] [ebp-A4h]
  char *v22; // [esp+28h] [ebp-A0h]
  size_t n; // [esp+2Ch] [ebp-9Ch]
  size_t v24; // [esp+30h] [ebp-98h]
  int v25; // [esp+34h] [ebp-94h]
  void *dest; // [esp+38h] [ebp-90h]
  int fd; // [esp+3Ch] [ebp-8Ch]
  FILE *stream; // [esp+40h] [ebp-88h]
  int c; // [esp+44h] [ebp-84h]
  unsigned int v30; // [esp+BCh] [ebp-Ch]

  v30 = __readgsdword(0x14u);
  v18 = (void *)dword_806C38E;
  if ( dword_806C38E )
    return v18;
  ptr = 0;
  v22 = "charset.alias";
  s = getenv("CHARSETALIASDIR");
  if ( !s || !*s )
  {
    ptr = 0;
    s = "/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib";
  }
  n = strlen(s);
  v24 = strlen(v22);
  if ( n )
  {
    v2 = &loc_80604FC;
    if ( s[n - 1] == 47 )
      v2 = &loc_8060503;
    dword_806B20C = (int)v2;
    sub_8061930(v1);
    v3 = 1;
  }
  else
  {
    v3 = 0;
  }
  v25 = v3;
  v4 = malloc(n + v3 + v24 + 1);
  dest = v4;
  v7 = v4 == 0;
  v8 = &loc_8060557;
  if ( v7 )
    v8 = &loc_80605C8;
  dword_806B284 = (int)v8;
  sub_8061671(v6, v5);
  memcpy(dest, s, n);
  if ( v25 )
    *((_BYTE *)dest + n) = 47;
  memcpy((char *)dest + n + v25, v22, v24 + 1);
  free(ptr);
  if ( !dest )
  {
    v18 = &unk_8064DD7;
    dword_806B304 = (int)&loc_8060935;
    sub_8061308();
  }
  fd = open64(dest, 0x20000);
  if ( fd < 0 )
  {
    v18 = &unk_8064DD7;
    dword_806B304 = (int)&loc_8060927;
    sub_8061308();
  }
  stream = fdopen(fd, "r");
  if ( !stream )
  {
    close(fd);
    v18 = &unk_8064DD7;
    goto LABEL_39;
  }
  v20 = 0;
  v21 = 0;
  while ( 1 )
  {
    do
    {
      c = getc_unlocked(stream);
      if ( c == -1 )
        goto LABEL_35;
    }
    while ( c == 10 || c == 32 || c == 9 );
    v11 = &loc_8060700;
    if ( c != 35 )
      v11 = &loc_806076B;
    dword_806B234 = (int)v11;
    sub_806184C(v10, v9);
    c = getc_unlocked(stream);
    if ( c != -1 )
    {
      v14 = &loc_806073F;
      if ( c != 10 )
        v14 = &loc_8060700;
      dword_806B33C = (int)v14;
      sub_8061194(v13, v12);
    }
    v15 = &loc_8060761;
    if ( c != -1 )
      v15 = &loc_8060766;
    dword_806B33C = (int)v15;
    sub_8061194(v13, v12);
LABEL_35:
    sub_805F1E8(stream);
    if ( !v21 )
      break;
    dword_806B2E4 = (int)&loc_806090A;
    sub_806141F(a1);
  }
  v18 = &unk_8064DD7;
LABEL_39:
  free(dest);
  dword_806C38E = (int)v18;
  return v18;
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 8061194: using guessed type int __fastcall sub_8061194(_DWORD, _DWORD);
// 8061308: using guessed type int sub_8061308(void);
// 806141F: using guessed type int __usercall sub_806141F@<eax>(double@<st0>);
// 8061671: using guessed type int __fastcall sub_8061671(_DWORD, _DWORD);
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD, _DWORD);
// 8061930: using guessed type int __fastcall sub_8061930(_DWORD);
// 806B20C: using guessed type int dword_806B20C;
// 806B234: using guessed type int dword_806B234;
// 806B284: using guessed type int dword_806B284;
// 806B2E4: using guessed type int dword_806B2E4;
// 806B304: using guessed type int dword_806B304;
// 806B33C: using guessed type int dword_806B33C;
// 806C38E: using guessed type int dword_806C38E;

//----- (08060960) --------------------------------------------------------
const char *__usercall sub_8060960@<eax>(double a1@<st0>)
{
  bool v1; // zf
  void *v2; // eax
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  void *v6; // eax
  const char *s1; // [esp+18h] [ebp-10h]
  char *s2; // [esp+1Ch] [ebp-Ch]

  s1 = nl_langinfo(14);
  if ( !s1 )
    s1 = (const char *)&unk_8064DD7;
  s2 = (char *)sub_806041D(a1);
  if ( *s2 )
  {
    v1 = strcmp(s1, s2) == 0;
    v2 = &loc_80609BE;
    if ( v1 )
      v2 = &loc_8060A07;
    dword_806B298 = (int)v2;
    sub_8061601();
    v5 = &loc_80609E1;
    if ( *s2 != 42 )
      v5 = &loc_8060A1F;
    dword_806B33C = (int)v5;
    sub_8061194(v4, v3);
    v6 = &loc_8060A07;
    if ( s2[1] )
      v6 = &loc_8060A1F;
    dword_806B2AC = (int)v6;
    sub_8061591();
    s1 = &s2[strlen(s2) + 1];
  }
  if ( !*s1 )
    s1 = "ASCII";
  return s1;
}
// 8060960: could not find valid save-restore pair for ebx
// 8061194: using guessed type int __fastcall sub_8061194(_DWORD, _DWORD);
// 8061591: using guessed type int sub_8061591(void);
// 8061601: using guessed type int sub_8061601(void);
// 806B298: using guessed type int dword_806B298;
// 806B2AC: using guessed type int dword_806B2AC;
// 806B33C: using guessed type int dword_806B33C;

//----- (08060A65) --------------------------------------------------------
int __usercall sub_8060A65@<eax>(double a1@<st0>, char *s1, int a3, char *s2)
{
  bool v4; // zf
  int v5; // edx
  int v6; // ecx
  void *v7; // eax
  int v9; // [esp+14h] [ebp-14h]

  *__errno_location() = 0;
  v9 = strcoll(s1, s2);
  if ( !v9 )
  {
    v4 = *__errno_location() == 0;
    v7 = &loc_8060B3F;
    if ( v4 )
      v7 = &loc_8060B46;
    dword_806B284 = (int)v7;
    sub_8061671(v6, v5);
  }
  dword_806B2E4 = (int)&loc_8060B68;
  sub_806141F(a1);
  return v9;
}
// 8060A65: could not find valid save-restore pair for ebx
// 806141F: using guessed type int __usercall sub_806141F@<eax>(double@<st0>);
// 8061671: using guessed type int __fastcall sub_8061671(_DWORD, _DWORD);
// 806B284: using guessed type int dword_806B284;
// 806B2E4: using guessed type int dword_806B2E4;

//----- (08060B6D) --------------------------------------------------------
int __usercall sub_8060B6D@<eax>(double a1@<st0>, void *s1, size_t n, void *s2, int a5)
{
  char v5; // ST1A_1
  char v6; // ST1B_1
  int v8; // [esp+1Ch] [ebp-Ch]

  if ( n == a5 && !memcmp(s1, s2, n) )
  {
    *__errno_location() = 0;
    v8 = 0;
  }
  else
  {
    v5 = *((_BYTE *)s1 + n);
    v6 = *((_BYTE *)s2 + a5);
    *((_BYTE *)s1 + n) = 0;
    *((_BYTE *)s2 + a5) = 0;
    v8 = sub_8060A65(a1, (char *)s1, n + 1, (char *)s2);
    *((_BYTE *)s1 + n) = v5;
    *((_BYTE *)s2 + a5) = v6;
  }
  return v8;
}

//----- (08060C28) --------------------------------------------------------
int __usercall sub_8060C28@<eax>(double a1@<st0>, void *s1, size_t n, void *s2, int a5)
{
  if ( n != a5 || memcmp(s1, s2, n) )
    return sub_8060A65(a1, (char *)s1, n, (char *)s2);
  *__errno_location() = 0;
  return 0;
}

//----- (08060C87) --------------------------------------------------------
_DWORD *__userpurge sub_8060C87@<eax>(_DWORD *a1, int a2, int a3)
{
  *a1 = a2;
  a1[1] = a3;
  return a1;
}

//----- (08060D5E) --------------------------------------------------------
int __usercall sub_8060D5E@<eax>(double a1@<st0>, int fd)
{
  return sub_805F313(a1, fd, 0, 3);
}

//----- (08060D83) --------------------------------------------------------
signed __int64 __cdecl sub_8060D83(unsigned __int64 a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // esi
  signed __int64 result; // rax
  int v5; // ebp
  int v6; // ebp
  int v7; // ST08_4
  unsigned __int64 v8; // rtt
  unsigned int v9; // esi
  unsigned int v10; // edi
  unsigned __int64 v11; // rax

  if ( !a3 )
  {
    if ( a2 > HIDWORD(a1) )
      return (unsigned int)(a1 / a2);
    v3 = a2;
    if ( !a2 )
      v3 = 1 / 0u;
    LODWORD(result) = __PAIR__(HIDWORD(a1) % v3, (unsigned int)a1) / v3;
    HIDWORD(result) = HIDWORD(a1) / v3;
    return result;
  }
  if ( a3 > HIDWORD(a1) )
    return 0LL;
  _BitScanReverse((unsigned int *)&v5, a3);
  v6 = v5 ^ 0x1F;
  if ( !v6 )
  {
    if ( a2 <= (unsigned int)a1 || a3 < HIDWORD(a1) )
      return 1LL;
    return 0LL;
  }
  v7 = (a3 << v6) | (a2 >> (32 - v6));
  LODWORD(v8) = (HIDWORD(a1) << v6) | ((unsigned int)a1 >> (32 - v6));
  HIDWORD(v8) = HIDWORD(a1) >> (32 - v6);
  v9 = v8 % (unsigned int)v7;
  v10 = v8 / (unsigned int)v7;
  v11 = (a2 << v6) * (unsigned __int64)v10;
  if ( v9 < HIDWORD(v11) || (_DWORD)a1 << v6 < (unsigned int)v11 && v9 == (a2 << v6) * (unsigned __int64)v10 >> 32 )
    result = v10 - 1;
  else
    result = v10;
  return result;
}

//----- (08060EA3) --------------------------------------------------------
unsigned __int64 __cdecl sub_8060EA3(unsigned __int64 a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // edx
  unsigned __int64 result; // rax
  int v5; // ebp
  void *v6; // eax
  unsigned int v7; // eax
  unsigned int v8; // ecx
  unsigned int v9; // ebp
  unsigned __int64 v10; // rtt
  unsigned __int64 v11; // [esp+8h] [ebp-18h]

  v11 = a1;
  if ( a3 )
  {
    if ( a3 > HIDWORD(a1) )
    {
      result = a1;
    }
    else
    {
      _BitScanReverse((unsigned int *)&v5, a3);
      v6 = &loc_8060F10;
      if ( v5 ^ 0x1F )
        v6 = &loc_8060F69;
      dword_806B234 = (int)v6;
      v7 = sub_806184C(a1, a3);
      if ( a2 <= (unsigned int)a1 || v7 < HIDWORD(a1) )
        v11 = __PAIR__(HIDWORD(a1), v8) - __PAIR__(v7, a2);
      result = v11;
    }
  }
  else
  {
    if ( a2 <= HIDWORD(a1) )
    {
      v9 = a2;
      if ( !a2 )
        v9 = 1 / 0u;
      LODWORD(v10) = a1;
      HIDWORD(v10) = HIDWORD(a1) % v9;
      v3 = v10 % v9;
    }
    else
    {
      v3 = a1 % a2;
    }
    result = v3;
  }
  return result;
}
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD, _DWORD);
// 806B234: using guessed type int dword_806B234;

//----- (080610AD) --------------------------------------------------------
int __cdecl sub_80610AD(int a1)
{
  return __cxa_atexit(a1, 0, dword_806B354);
}
// 8049AC0: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 806B354: using guessed type int dword_806B354;

//----- (080610DC) --------------------------------------------------------
int __cdecl sub_80610DC(int a1, int a2)
{
  return __xstat64(3, a1, a2);
}
// 8049EB0: using guessed type int __cdecl __xstat64(_DWORD, _DWORD, _DWORD);

//----- (0806110B) --------------------------------------------------------
int __cdecl sub_806110B(int a1, int a2)
{
  return __fxstat64(3, a1, a2);
}
// 8049A30: using guessed type int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD);

//----- (08061194) --------------------------------------------------------
#error "806119A: positive sp value has been found (funcsize=0)"

//----- (08061268) --------------------------------------------------------
#error "806126E: positive sp value has been found (funcsize=0)"

//----- (080612C7) --------------------------------------------------------
#error "8061300: positive sp value has been found (funcsize=18)"

//----- (08061308) --------------------------------------------------------
#error "806130E: positive sp value has been found (funcsize=0)"

//----- (08061367) --------------------------------------------------------
#error "80613A0: positive sp value has been found (funcsize=18)"

//----- (0806141F) --------------------------------------------------------
#error "8061425: positive sp value has been found (funcsize=0)"

//----- (08061463) --------------------------------------------------------
#error "806149C: positive sp value has been found (funcsize=18)"

//----- (080614E0) --------------------------------------------------------
#error "8061519: positive sp value has been found (funcsize=18)"

//----- (08061521) --------------------------------------------------------
#error "8061527: positive sp value has been found (funcsize=0)"

//----- (08061591) --------------------------------------------------------
#error "8061597: positive sp value has been found (funcsize=0)"

//----- (08061601) --------------------------------------------------------
#error "8061607: positive sp value has been found (funcsize=0)"

//----- (08061671) --------------------------------------------------------
#error "8061677: positive sp value has been found (funcsize=0)"

//----- (080616F8) --------------------------------------------------------
#error "80616FE: positive sp value has been found (funcsize=0)"

//----- (0806176A) --------------------------------------------------------
#error "8061770: positive sp value has been found (funcsize=0)"

//----- (080617DA) --------------------------------------------------------
#error "80617E0: positive sp value has been found (funcsize=0)"

//----- (0806184C) --------------------------------------------------------
#error "8061852: positive sp value has been found (funcsize=0)"

//----- (080618C4) --------------------------------------------------------
#error "80618CA: positive sp value has been found (funcsize=0)"

//----- (08061930) --------------------------------------------------------
#error "8061936: positive sp value has been found (funcsize=0)"

//----- (08061940) --------------------------------------------------------
int (**sub_8061940())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_806AEB8;
  v1 = &off_806AEBC - off_806AEB8;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_806AEB8[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 806AEB8: using guessed type int (*off_806AEB8[2])();
// 806AEBC: using guessed type int (*off_806AEBC)();

//----- (080619A4) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 58 decompilation failure(s) on 395 function(s)"
