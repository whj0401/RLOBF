/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8049750();
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// int raise(int sig);
// int dup2(int fd, int fd2);
// int strcmp(const char *s1, const char *s2);
// int putc_unlocked(int c, FILE *stream);
// ssize_t read(int fd, void *buf, size_t nbytes);
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void _exit(int status);
// int __cdecl wcwidth(_DWORD); weak
// void *memmove(void *dest, const void *src, size_t n);
// void free(void *ptr);
// uintmax_t strtoumax(const char *nptr, char **endptr, int base);
// void *memcpy(void *dest, const void *src, size_t n);
// int mbsinit(const mbstate_t *ps);
// int ferror(FILE *stream);
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// int fclose(FILE *stream);
// int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// __sighandler_t signal(int sig, __sighandler_t handler);
// int __cdecl __sched_cpucount(_DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// double __cdecl strtold(_DWORD, _DWORD); weak
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// int fputc_unlocked(int c, FILE *stream);
// int __cdecl getrlimit64(_DWORD, _DWORD); weak
// int execlp(const char *file, const char *arg, ...);
// int sysconf(int name);
// __uid_t getuid(void);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// int unlink(const char *name);
// int sigismember(const sigset_t *set, int signo);
// int iswcntrl(wint_t wc);
// char *textdomain(const char *domainname);
// int iswprint(wint_t wc);
// int __cdecl fopen64(_DWORD, _DWORD); weak
// int ferror_unlocked(FILE *stream);
// int __cdecl mkostemp64(_DWORD, _DWORD); weak
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD); weak
// size_t __ctype_get_mb_cur_max(void);
// __pid_t waitpid(__pid_t pid, int *stat_loc, int options);
// int pthread_sigmask(int how, const __sigset_t *newmask, __sigset_t *oldmask);
// size_t __fpending(FILE *fp);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// __pid_t getpid(void);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// int pthread_cond_signal(pthread_cond_t *cond);
// void error(int status, int errnum, const char *format, ...);
// size_t fread_unlocked(void *ptr, size_t size, size_t n, FILE *stream);
// int strcoll(const char *s1, const char *s2);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int sysinfo(struct sysinfo *info);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// char *strchr(const char *s, int c);
// size_t strlen(const char *s);
// int fprintf(FILE *stream, const char *format, ...);
// ssize_t write(int fd, const void *buf, size_t n);
// int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *cond_attr);
// int __cdecl open64(_DWORD, _DWORD); weak
// int fcntl(int fd, int cmd, ...);
// int sigaddset(sigset_t *set, int signo);
// size_t strxfrm(char *dest, const char *src, size_t n);
// int setvbuf(FILE *stream, char *buf, int modes, size_t n);
// __gid_t getgid(void);
// void *memset(void *s, int c, size_t n);
// int *__errno_location(void);
// int fileno(FILE *stream);
// int fgetc(FILE *stream);
// int pipe(int pipedes[2]);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// int __cdecl ftruncate64(_DWORD, _DWORD, _DWORD); weak
// __pid_t fork(void);
// int sigemptyset(sigset_t *set);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// int toupper(int c);
// char *strrchr(const char *s, int c);
// int pthread_join(pthread_t th, void **thread_return);
// struct lconv *localeconv(void);
// __pid_t getppid(void);
// int __cdecl explicit_bzero(_DWORD, _DWORD); weak
// int __cdecl pipe2(_DWORD, _DWORD); weak
// int __cdecl euidaccess(_DWORD, _DWORD); weak
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int nanosleep(const struct timespec *requested_time, struct timespec *remaining);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// char *bindtextdomain(const char *domainname, const char *dirname);
// int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl sched_getaffinity(_DWORD, _DWORD, _DWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// void abort(void);
// int __cdecl __xstat64(_DWORD, _DWORD, _DWORD); weak
// int strtol(const char *nptr, char **endptr, int base);
// char *ngettext(const char *msgid1, const char *msgid2, unsigned int n);
// int close(int fd);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// void *calloc(size_t nmemb, size_t size);
// int putchar_unlocked(int c);
// int _gmon_start__(void); weak
void sub_8049F73();
void sub_8049F90();
int sub_8049FA0();
int sub_804A010();
int sub_804A030();
void sub_804A08F();
void sub_804A0AA();
int sub_804A0BA();
// int __usercall sub_804A121@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
void sub_804A1B8();
void sub_804A1D3();
int sub_804A1E3();
void sub_804A2C5();
void sub_804A2E0();
signed int sub_804A2F0();
int nullsub_4(void); // weak
int sub_804A367();
void sub_804A407();
void sub_804A422();
int sub_804A432();
void sub_804A514();
void sub_804A52F();
int sub_804A53F();
void sub_804A648();
void sub_804A663();
int sub_804A673();
int sub_804A716();
void sub_804A78A();
void sub_804A7A5();
int sub_804A7B5();
void sub_804A897();
void sub_804A8B2();
int sub_804A8C2();
void sub_804A9A4();
void sub_804A9BF();
int sub_804A9CF();
void sub_804AAC6();
void sub_804AAE1();
int sub_804AAF1();
// int __usercall sub_804AB58@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
void sub_804AC01();
void sub_804AC1C();
int sub_804AC2C();
void sub_804AD0E();
void sub_804AD29();
int sub_804AD39();
void sub_804AE1B();
void sub_804AE36();
int sub_804AE46();
int sub_804AED0();
void sub_804AF44();
void sub_804AF5F();
int sub_804AF6F();
int nullsub_6(void); // weak
// int __usercall sub_804AFD6@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
// int __usercall sub_804B03A@<eax>(void (__cdecl *a1)(int *)@<eax>);
void sub_804B086();
void sub_804B0A1();
int sub_804B0B1();
int nullsub_10(void); // weak
int sub_804B10F();
void sub_804B1EC();
void sub_804B207();
int sub_804B217();
int sub_804B2A1();
void sub_804B32E();
void sub_804B349();
int sub_804B359();
int nullsub_7(void); // weak
int sub_804B3B7();
// int __usercall sub_804B424@<eax>(void (__cdecl *a1)(int *)@<eax>);
void sub_804B482();
void sub_804B49D();
int sub_804B4AD();
int nullsub_8(); // weak
// int __usercall sub_804B50B@<eax>(int a1@<ebp>);
void sub_804B5C4();
void sub_804B5DF();
int sub_804B5EF();
void sub_804B6ED();
void sub_804B708();
int sub_804B718();
// int __usercall sub_804B77F@<eax>(int a1@<eax>, int (__cdecl *a2)(int *, int)@<edx>);
void sub_804B816();
void sub_804B831();
int __cdecl sub_804B926(int a1);
int __cdecl sub_804B939(unsigned __int8 a1);
signed int __cdecl sub_804B94B(unsigned __int8 a1);
int __cdecl sub_804B9BC(unsigned __int64 a1);
int sub_804BA17();
int sub_804BA42();
// int __usercall sub_804BA6D@<eax>(int a1@<edx>, int a2@<ecx>, char *s1);
void __cdecl __noreturn sub_804BC21(int a1, const char *a2);
void __fastcall __noreturn sub_804BCE7(int ecx0, int edx0, int a1, int a2);
void __cdecl __noreturn sub_804BD62(int status); // idb
int __cdecl sub_804C01E(int a1);
int __cdecl sub_804C053(int a1);
int __cdecl sub_804C09C(int a1, unsigned int a2);
bool __cdecl sub_804C0BA(int a1, int a2);
int __cdecl sub_804C0DF(int a1);
void __cdecl __noreturn sub_804C200(int a1);
int sub_804C28B(); // weak
signed int __cdecl sub_804C28D(int a1);
signed int __cdecl sub_804C2FC(int a1);
int sub_804C31E();
int sub_804C35A();
int __fastcall sub_804C373(int a1, int a2);
int sub_804C3A7();
int sub_804C3DF();
int *__cdecl sub_804C419(int *a1, char a2);
FILE *__cdecl sub_804C623(char *s1, char *modes);
int __cdecl sub_804C778(char *s1, char *modes); // idb
int sub_804C7C6(); // weak
int __cdecl sub_804C7CB(FILE *stream, int); // idb
int __cdecl sub_804C88F(int fd, int fd2); // idb
__pid_t __cdecl sub_804C8E3(int pipedes[2], int a2);
int *__cdecl sub_804CA8E(FILE **a1, char a2);
int *__cdecl sub_804CBF6(FILE **a1);
// int __usercall sub_804CC11@<eax>(int edx0@<edx>, int a2@<ecx>, int a1);
int __cdecl sub_804CE18(int a1);
// void __usercall sub_804CE70(int a1@<edx>, int a2@<ecx>, char *name);
int compar(const void *, const void *); // idb
void sub_804CFEB();
// unsigned int __usercall sub_804D1F1@<eax>(int edx0@<edx>, int ecx0@<ecx>, int a1, char a2, char *a3);
// int __usercall sub_804D47B@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, char *nptr);
int __cdecl sub_804D6EE(int, int, char *nptr); // idb
int __cdecl sub_804D7AA(int errnum, char *format); // idb
// unsigned int __usercall sub_804D7EC@<eax>(long double a1@<st0>);
// int __usercall sub_804D9D4@<eax>(long double a1@<st0>, int a2, unsigned int a3, int a4, unsigned int a5, int a6);
int __cdecl sub_804DBB7(int, int, size_t size); // idb
int __cdecl sub_804DC3D(_DWORD *a1);
char *__cdecl sub_804DC58(char **a1, int a2);
unsigned __int8 *__cdecl sub_804DE01(int a1, int a2);
int __cdecl sub_804E01D(int a1);
// int __usercall sub_804E44F@<eax>(int a1@<edx>, int a2@<ecx>, char **a3);
int __cdecl sub_804E53E(_BYTE *a1);
signed int __cdecl sub_804E5BA(unsigned __int8 *a1, unsigned __int8 *a2);
signed int __cdecl sub_804E679(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_804E6F0(int a1, int a2);
signed int __cdecl sub_804E774(int a1, int a2);
int __cdecl sub_804E891(unsigned __int8 *a1, unsigned __int8 **a2);
unsigned int __cdecl sub_804EA38(int a1);
size_t __cdecl sub_804EB04(char *dest, char *src, size_t n);
void __cdecl __noreturn sub_804EBDC(int, size_t, int, size_t); // idb
int sub_804F24A(); // weak
int __cdecl sub_804F255(char *a1, unsigned int a2);
int __cdecl sub_804F2DA(int a1, int a2);
int __cdecl sub_804F33B(_BYTE *a1);
int __cdecl sub_804F385(int a1, int a2);
int __cdecl sub_804F660(int a1);
int __cdecl sub_804F6B3(int a1);
// _BYTE *__usercall sub_804F7E9@<eax>(int a1@<edx>, int a2@<ecx>, int a3, _BYTE *a4);
unsigned int __cdecl sub_804F918(int *a1);
int __cdecl __noreturn sub_8050160(int a1, int a2);
int sub_8050F10(); // weak
// int __usercall sub_8050F19@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4);
int __cdecl sub_805105D(int, FILE *stream, int); // idb
int __cdecl sub_8051166(char *a1, char a2);
unsigned int __cdecl sub_8051502(int a1, unsigned int a2, void **a3);
void __cdecl sub_8051629(int a1, int a2, int a3, FILE *stream, int a5, void *a6);
int __cdecl sub_8051FFD(int, int, int, FILE *stream, int); // idb
_DWORD *__cdecl sub_805208E(_DWORD *a1, unsigned int a2, _DWORD *a3);
int __cdecl sub_805219E(_DWORD *a1, unsigned int a2, _DWORD *a3, unsigned __int8 a4);
pthread_mutex_t *__cdecl sub_80523EB(int a1, int a2, int a3);
int __cdecl sub_8052505(int a1, int a2, int a3, int a4, int a5, char a6);
// int __usercall sub_8052542@<eax>(_DWORD *a1@<ebp>, int a2);
int __cdecl sub_80525B5(pthread_mutexattr_t *mutexattr, int, int, int, int); // idb
int __cdecl sub_8052724(_DWORD *a1, _DWORD *a2);
int sub_8052790(); // weak
int __cdecl sub_80527A6(pthread_mutex_t *a1);
int __cdecl sub_80527BC(pthread_mutex_t *a1);
int __cdecl sub_8052803(int a1, int a2);
int __cdecl sub_8052851(int a1, int a2);
pthread_mutex_t *__cdecl sub_805289E(int a1);
// int __usercall sub_8052907@<eax>(int a1@<edx>, int a2@<ecx>, int a3);
int __cdecl sub_80529C5(int, int, FILE *stream, int); // idb
// int __usercall sub_8052E44@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4);
int __cdecl sub_8052F23(int a1, int a2);
int __cdecl sub_8052FA5(int, int, FILE *stream, int); // idb
void *start_routine(void *); // idb
int __cdecl sub_80530A5(int, int, int, int, int, FILE *stream, int); // idb
int __cdecl sub_80532A9(int, int, int, char *s1); // idb
unsigned int __cdecl sub_8053549(int a1, unsigned int a2);
void __cdecl sub_8053600(int a1);
void __cdecl sub_8053666(int a1, int a2, int a3, char *s1);
// unsigned int __usercall sub_8053A91@<eax>(long double a1@<st0>, int edx0@<edx>, int ecx0@<ecx>, char **a2, unsigned int a3, char *a4, unsigned int a5);
_DWORD *__cdecl sub_8053EF0(void *src);
unsigned int __cdecl sub_8053F3D(int a1, char *msgid);
unsigned int __cdecl sub_8053F8B(int a1);
unsigned int sub_8053FBC();
// int __usercall sub_80540AF@<eax>(int a1@<edx>, int a2@<ecx>, char *nptr, int a4, char *msgid);
int __cdecl sub_80541A0(int sig); // idb
// _BYTE *__usercall sub_80541CB@<eax>(int a1@<edx>, int a2@<ecx>, char *a3, int a4, int a5);
void *__cdecl sub_805434E(void *s);
int __cdecl main(int argc, char **argv);
void __noreturn sub_8055BA8();
int __cdecl sub_8055BBC(char *s, int a2);
void __cdecl sub_8055CE9(char *a1, char *a2, int a3);
int __cdecl sub_8055D6C(int, int, size_t n); // idb
int __cdecl sub_8055E83(int, char *s, int, int, size_t n, int); // idb
int sub_8055F9C();
_DWORD *__cdecl sub_80560B2(_DWORD *a1);
_DWORD *__cdecl sub_80560FE(_DWORD *a1, int a2);
_DWORD *__cdecl sub_805610B(int *a1, _DWORD *a2);
_DWORD *__cdecl sub_8056178(int *a1, _DWORD *a2);
int *__cdecl sub_8056451(void *src, size_t a2, int a3);
int *__cdecl sub_805663E(int *a1, unsigned int a2, int *a3);
int __cdecl sub_805731A(int a1, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_805736B@<eax>(int a1@<edx>, int a2@<ecx>, FILE *stream, int a4);
int __cdecl sub_80573CC(int a1);
int sub_805755C(); // weak
int __cdecl sub_805757F(unsigned __int8 a1);
// int __usercall sub_80575D0@<eax>(int a1@<edx>, int a2@<ecx>, int a3, unsigned int a4, int a5, unsigned int a6);
int __cdecl sub_805783E(char *s1, char *s2); // idb
int __cdecl sub_8057B3E(int category); // idb
int __cdecl sub_8057BB5(int a1);
int __cdecl sub_8057BC0(int a1);
int __cdecl sub_8057BCB(int a1);
// unsigned int __usercall sub_8057BD6@<eax>(int a1@<edx>, int a2@<ecx>, int a3);
int __cdecl sub_8057DCE(int a1, int a2);
bool __cdecl sub_8058130(unsigned int a1);
// unsigned int __usercall sub_80581A0@<eax>(int a1@<edx>, int a2@<ecx>, unsigned int a3);
unsigned int __cdecl sub_805823F(int a1, unsigned int a2);
bool __cdecl sub_805826A(int a1, int a2);
signed int __cdecl sub_8058278(int a1);
int __cdecl sub_8058334(unsigned int a1, int a2);
int sub_80583B1(); // weak
int __cdecl sub_8058419(unsigned int a1, void *a2);
void *__cdecl sub_8058794(int a1);
int __cdecl sub_80587CF(int a1, _DWORD *a2);
int __cdecl sub_80587F2(int a1, int a2, _DWORD *a3, char a4);
signed int __cdecl sub_8058985(int a1, int a2, char a3);
signed int __cdecl sub_8058B4F(int a1, unsigned int a2);
int __cdecl sub_8058D5D(int a1, int a2, _DWORD *a3);
int __cdecl sub_8058FDE(int a1, int a2);
int __cdecl sub_8059036(int a1, int a2);
_DWORD *__cdecl sub_805921B(int (*a1)(), unsigned int a2);
int sub_8059290();
void __cdecl sub_805929A(void *ptr);
int __cdecl sub_80592BA(int a1, int a2);
// int __usercall sub_8059343@<eax>(int a1@<edx>, int a2@<ecx>, int *a3);
unsigned int __cdecl sub_80593D4(int a1, unsigned int a2, unsigned int a3, int (__cdecl *a4)(int, int));
int __cdecl sub_80594C9(int a1, unsigned int a2, int (__cdecl *a3)(_DWORD, int));
int __cdecl sub_8059559(int a1, _BYTE *a2);
int __cdecl sub_805964C(unsigned int a1, int a2);
int __cdecl sub_80596AA(__int64 a1, int a2);
int __cdecl sub_805975D(char *a1, int a2, char a3);
int sub_8059A40();
// int __usercall sub_8059AB8@<eax>(int a1@<edx>, int a2@<ecx>, int a3);
// int __usercall sub_8059B60@<eax>(int a1@<edx>, int a2@<ecx>, char *nptr);
// unsigned int __usercall sub_8059C8E@<eax>(int a1@<edx>, int a2@<ecx>, int a3);
long double sub_8059D3D();
int __cdecl sub_8059DEA(int a1);
int sub_8059E7C(); // weak
// int __usercall sub_8059EE7@<eax>(int a1@<ebp>, int a2);
int sub_8059F19(); // weak
int __cdecl sub_8059F1B(int pipedes[2], int); // idb
int sub_805A1BA();
char *__cdecl sub_805A218(char *s);
int __cdecl sub_805A3EE(int *a1, unsigned __int8 a2, char a3);
// int *__usercall sub_805A498@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5);
// _DWORD *__userpurge sub_805A4F2@<eax>(_DWORD *a1, int a2);
int __cdecl sub_805A574(char *msgid); // idb
int __cdecl sub_805A5B8(int); // weak
// int __usercall sub_805A6B6@<eax>(int edx0@<edx>, int ecx0@<ecx>, int a1, int a2, int a3);
int sub_805A725(); // weak
unsigned int __cdecl sub_805A72C(int a1, unsigned int a2, char *a3, size_t a4, char *a5, int a6, int a7, char *a8, char *a9);
void *__cdecl sub_805B69D(char *a1, size_t a2, _DWORD *a3, int *a4);
void *__cdecl sub_805B88B(signed int a1, char *a2, size_t a3, int a4);
void *__cdecl sub_805BAE2(signed int a1, char *a2);
void *__cdecl sub_805BB0C(signed int a1, char *a2, size_t a3);
void *__cdecl sub_805BB72(signed int a1, int a2, char *a3);
void *__cdecl sub_805BBB0(signed int a1, int a2, char *a3, size_t a4);
void *__cdecl sub_805BBED(int a1, char *a2);
void *__cdecl sub_805BC38(char *a1, size_t a2, unsigned __int8 a3);
void *__cdecl sub_805BCE2(char *a1, unsigned __int8 a2);
void *__cdecl sub_805BD0B(char *a1);
void *__cdecl sub_805BD48(signed int a1, int a2, char *a3);
// void *__usercall sub_805BDE9@<eax>(int a1@<edx>, int a2@<ecx>, signed int a3, int a4, int a5, char *a6);
// void *__usercall sub_805BE19@<eax>(int a1@<edx>, int a2@<ecx>, signed int a3, int a4, int a5, char *a6, size_t a7);
void *__cdecl sub_805BF13(signed int a1, char *a2, size_t a3);
void *__cdecl sub_805BF5E(signed int a1, char *a2);
void *__cdecl sub_805BF80(char *a1);
void __cdecl __noreturn sub_805BF9B(char *a1);
_DWORD *__cdecl sub_805C004(int a1, int a2);
unsigned int __cdecl sub_805C039(int a1, int a2, size_t nbytes);
char *__cdecl sub_805C246(int a1, size_t n);
size_t __cdecl sub_805C366(int a1, void *ptr, size_t n);
int __cdecl sub_805C41C(int, void *dest, size_t n); // idb
size_t __cdecl sub_805C552(int a1, void *ptr, size_t n);
int __cdecl sub_805C59A(void *ptr); // idb
int __cdecl sub_805C5E0(int a1);
int __cdecl sub_805C5F7(int a1, __int16 a2);
unsigned int *__cdecl sub_805C628(unsigned int *a1, int *a2);
_DWORD *__cdecl sub_805CACD(_DWORD *a1);
signed int __cdecl sub_805CEDC(_DWORD *a1);
_DWORD *__cdecl sub_805D0AA(_DWORD *a1);
bool __cdecl sub_805D23F(FILE *stream, int a2);
int __cdecl sub_805D527(int a1, int a2);
int __cdecl sub_805D550(_BYTE *a1, _BYTE *a2, char a3);
signed int __cdecl sub_805D730(unsigned __int8 *a1, unsigned __int8 *a2, int a3, int a4);
signed int __cdecl sub_805DCA3(unsigned __int8 *a1, unsigned __int8 *a2, int a3, int a4);
// int __usercall sub_805DCCB@<eax>(int a1@<edx>, int a2@<ecx>, int fd);
// int __usercall sub_805DD2E@<eax>(int a1@<edx>, int a2@<ecx>, FILE *stream, int a4, int a5, int a6, int a7, int a8);
// int __usercall sub_805E2D0@<eax>(int a1@<edx>, int a2@<ecx>, FILE *stream, int a4, int a5, int a6, int a7);
// int __usercall sub_805E336@<eax>(int a1@<edx>, int a2@<ecx>, FILE *stream, int a4, int a5, int a6, ...);
void *__cdecl sub_805E3D6(unsigned int a1, unsigned int a2);
void *__cdecl sub_805E439(void *ptr, int a2, int a3);
void *__cdecl sub_805E4E9(size_t size);
void *__cdecl sub_805E4FC(size_t size);
void *__cdecl sub_805E53F(void *ptr, size_t size);
int __cdecl sub_805E5DA(size_t nmemb, size_t size); // idb
int sub_805E636(); // weak
void *__cdecl sub_805E63B(void *src, size_t n);
void __noreturn sub_805E689();
void __cdecl sub_805E6C2(int errnum, int a2, int a3, int a4, int a5);
int __cdecl sub_805E7F3(void *s1, size_t n, void *s2, int); // idb
int __cdecl sub_805E85E(double a1);
signed int __cdecl sub_805E8FE(unsigned int *a1, unsigned int a2);
int __cdecl sub_805E942(unsigned int *a1, unsigned int a2, int a3);
int __cdecl sub_805E978(char *nptr, int a2, int base);
// void __usercall sub_805EEA2(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, int a6, int a7, int status);
void __fastcall __noreturn sub_805EF86(int a1, int a2, int a3, int a4, char a5, int a6, int a7);
signed int __cdecl sub_805EFC9(int a1, int a2);
// int __usercall sub_805F055@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5);
// int __usercall sub_805F0A0@<eax>(int a1@<edx>, int a2@<ecx>, char *nptr, int a4, int base, int a6, char *s);
int __cdecl sub_805F563(FILE *stream); // idb
int __cdecl sub_805F63F(int fd, int cmd, char); // idb
int __cdecl sub_805F7DE(FILE *stream); // idb
int __cdecl sub_805F817(FILE *fp); // idb
int __cdecl sub_805F857(FILE *stream, int, int, int); // idb
// size_t __usercall sub_805F95F@<eax>(int a1@<edx>, int a2@<ecx>, wchar_t *pwc, char *s, size_t n, mbstate_t *p);
int __cdecl sub_805F9EA(int a1, int a2);
int __cdecl sub_805FA28(int a1, int a2);
signed int __cdecl sub_805FA66(int a1, signed int a2, signed int a3);
signed int __cdecl sub_805FB45(int a1, signed int a2, signed int a3, int a4, int a5);
int __cdecl sub_805FBCE(int a1, int a2);
int __cdecl sub_805FD98(int a1, unsigned int a2);
int __cdecl sub_805FFE0(int a1, char a2);
int __cdecl sub_80600CB(signed int a1);
_BOOL4 __cdecl sub_8060129(signed int a1);
_BOOL4 __cdecl sub_80601AD(int a1);
// signed int __usercall sub_806029A@<eax>(int a1@<edx>, int a2@<ecx>, signed int a3);
int __cdecl sub_806032C(int a1);
int __cdecl sub_8060362(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_80603C7(FILE *fp); // idb
// _DWORD *__userpurge sub_8060448@<eax>(_DWORD *a1, double a2);
int __cdecl sub_80605A3(int fd, int); // idb
int __cdecl sub_80605F4(int fd, int); // idb
FILE *__cdecl sub_806062B(int a1, char *modes);
void *sub_806075D();
const char *sub_8060CEC();
int __cdecl sub_8060DF1(char *s, int, char *s2, int); // idb
// int __usercall sub_8060EE1@<eax>(int a1@<edx>, int a2@<ecx>, void *s1, size_t n, void *s2, int a6);
int __cdecl sub_8060FB5(void *s1, size_t n, void *s2, int); // idb
// _DWORD *__userpurge sub_8061014@<eax>(_DWORD *a1, int a2, int a3);
int __cdecl sub_806111D(int fd); // idb
__int64 __cdecl sub_8061142(unsigned int a1, unsigned int a2, int a3, int a4);
unsigned __int64 __cdecl sub_8061294(unsigned __int64 a1, unsigned int a2, unsigned int a3);
int __cdecl sub_80614BE(int a1);
int __cdecl sub_80614ED(int a1, int a2);
int __cdecl sub_806151C(int a1, int a2);
int sub_80615BE(void); // weak
int sub_8061638(void); // weak
int __fastcall sub_80616AA(_DWORD, _DWORD); // weak
int __fastcall sub_8061791(_DWORD, _DWORD); // weak
int __fastcall sub_8061801(_DWORD, _DWORD, _DWORD);
int sub_8061877(void); // weak
int __fastcall sub_80618E9(_DWORD, _DWORD); // weak
int sub_8061957(void); // weak
int sub_80619CB(void); // weak
int sub_8061A43(void); // weak
int __fastcall sub_8061AB5(_DWORD, _DWORD); // weak
int __fastcall sub_8061B2F(_DWORD, _DWORD); // weak
int sub_8061B9D(void); // weak
int __fastcall sub_8061C11(_DWORD, _DWORD); // weak
int __fastcall sub_8061C89(_DWORD, _DWORD); // weak
int __fastcall sub_8061CFB(_DWORD, _DWORD); // weak
int sub_8061D73(void); // weak
int __fastcall sub_8061DE3(_DWORD, _DWORD); // weak
int sub_8061E55(void); // weak
int (**sub_8061E70())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN locret_804A682; // weak
_UNKNOWN loc_804B385; // weak
_UNKNOWN loc_804B98C; // weak
_UNKNOWN loc_804B9AB; // weak
_UNKNOWN loc_804B9B2; // weak
_UNKNOWN locret_804BA15; // weak
_UNKNOWN loc_804BAFD; // weak
_UNKNOWN loc_804BB41; // weak
_UNKNOWN loc_804BB4A; // weak
_UNKNOWN loc_804BD0D; // weak
_UNKNOWN loc_804BD1B; // weak
_UNKNOWN loc_804C07C; // weak
_UNKNOWN locret_804C09A; // weak
_UNKNOWN loc_804C116; // weak
_UNKNOWN loc_804C286; // weak
_UNKNOWN loc_804C2E9; // weak
_UNKNOWN loc_804C348; // weak
_UNKNOWN locret_804C358; // weak
_UNKNOWN loc_804C39C; // weak
_UNKNOWN loc_804C5AB; // weak
_UNKNOWN loc_804C5F0; // weak
_UNKNOWN loc_804C6AB; // weak
_UNKNOWN loc_804C7F9; // weak
_UNKNOWN loc_804C817; // weak
_UNKNOWN loc_804C819; // weak
_UNKNOWN loc_804C837; // weak
_UNKNOWN loc_804C8C4; // weak
_UNKNOWN locret_804C8E1; // weak
_UNKNOWN loc_804CA86; // weak
_UNKNOWN loc_804CB47; // weak
_UNKNOWN loc_804CBAE; // weak
_UNKNOWN loc_804CC44; // weak
_UNKNOWN loc_804CC52; // weak
_UNKNOWN loc_804CCB6; // weak
_UNKNOWN loc_804CD38; // weak
_UNKNOWN loc_804CE0E; // weak
_UNKNOWN loc_804CE90; // weak
_UNKNOWN loc_804CED1; // weak
_UNKNOWN loc_804D090; // weak
_UNKNOWN loc_804D2B3; // weak
_UNKNOWN loc_804D2D1; // weak
_UNKNOWN loc_804D394; // weak
_UNKNOWN loc_804D3B3; // weak
_UNKNOWN loc_804D446; // weak
_UNKNOWN loc_804D519; // weak
_UNKNOWN loc_804D645; // weak
_UNKNOWN loc_804D769; // weak
_UNKNOWN locret_804D7EA; // weak
_UNKNOWN loc_804D8A6; // weak
_UNKNOWN loc_804D8F4; // weak
_UNKNOWN loc_804DA86; // weak
_UNKNOWN loc_804DAA0; // weak
_UNKNOWN loc_804DAC5; // weak
_UNKNOWN loc_804DC98; // weak
_UNKNOWN loc_804DCCF; // weak
_UNKNOWN loc_804DD0F; // weak
_UNKNOWN loc_804DD53; // weak
_UNKNOWN loc_804DD9C; // weak
_UNKNOWN loc_804DDC2; // weak
_UNKNOWN loc_804DE65; // weak
_UNKNOWN loc_804DE69; // weak
_UNKNOWN loc_804DE9C; // weak
_UNKNOWN loc_804DEC9; // weak
_UNKNOWN loc_804DECD; // weak
_UNKNOWN loc_804DEF3; // weak
_UNKNOWN loc_804DF37; // weak
_UNKNOWN loc_804DF9F; // weak
_UNKNOWN loc_804DFC3; // weak
_UNKNOWN loc_804DFDE; // weak
_UNKNOWN loc_804E005; // weak
_UNKNOWN loc_804E018; // weak
_UNKNOWN loc_804E06F; // weak
_UNKNOWN loc_804E079; // weak
_UNKNOWN loc_804E4AC; // weak
_UNKNOWN locret_804E53C; // weak
_UNKNOWN locret_804E5B8; // weak
_UNKNOWN loc_804E5C3; // weak
_UNKNOWN loc_804E5FF; // weak
_UNKNOWN loc_804E8A8; // weak
_UNKNOWN loc_804E8E4; // weak
_UNKNOWN loc_804E927; // weak
_UNKNOWN loc_804E946; // weak
_UNKNOWN loc_804E94E; // weak
_UNKNOWN loc_804E95D; // weak
_UNKNOWN loc_804EC84; // weak
_UNKNOWN loc_804EDD3; // weak
_UNKNOWN loc_804EE06; // weak
_UNKNOWN loc_804EE3B; // weak
_UNKNOWN loc_804F043; // weak
_UNKNOWN loc_804F0A2; // weak
_UNKNOWN loc_804F0D5; // weak
_UNKNOWN loc_804F0DA; // weak
_UNKNOWN loc_804F1A0; // weak
_UNKNOWN loc_804F20C; // weak
_UNKNOWN loc_804F245; // weak
_UNKNOWN loc_804F2A4; // weak
_UNKNOWN loc_804F2BB; // weak
_UNKNOWN loc_804F380; // weak
_UNKNOWN loc_804F43B; // weak
_UNKNOWN loc_804F465; // weak
_UNKNOWN loc_804F51A; // weak
_UNKNOWN loc_804F529; // weak
_UNKNOWN loc_804F55C; // weak
_UNKNOWN loc_804F5AA; // weak
_UNKNOWN loc_804F5D5; // weak
_UNKNOWN loc_804F5DA; // weak
_UNKNOWN loc_804F613; // weak
_UNKNOWN loc_804F622; // weak
_UNKNOWN loc_804F6FC; // weak
_UNKNOWN loc_804F723; // weak
_UNKNOWN loc_804F74E; // weak
_UNKNOWN loc_804F775; // weak
_UNKNOWN loc_804F79C; // weak
_UNKNOWN loc_804F7C3; // weak
_UNKNOWN loc_804F7DF; // weak
_UNKNOWN loc_804F7E4; // weak
_UNKNOWN loc_804F861; // weak
_UNKNOWN loc_804F86D; // weak
_UNKNOWN loc_804F99E; // weak
_UNKNOWN loc_804FFDE; // weak
_UNKNOWN loc_80500FF; // weak
_UNKNOWN loc_8050121; // weak
_UNKNOWN loc_8050145; // weak
_UNKNOWN loc_80502B7; // weak
_UNKNOWN loc_80502D9; // weak
_UNKNOWN loc_8050349; // weak
_UNKNOWN loc_8050519; // weak
_UNKNOWN loc_8050522; // weak
_UNKNOWN loc_805054A; // weak
_UNKNOWN loc_80506CF; // weak
_UNKNOWN loc_8050706; // weak
_UNKNOWN loc_805086E; // weak
_UNKNOWN loc_80508C2; // weak
_UNKNOWN loc_8050972; // weak
_UNKNOWN loc_8050989; // weak
_UNKNOWN loc_8050B5A; // weak
_UNKNOWN loc_8050B69; // weak
_UNKNOWN loc_8050CC5; // weak
_UNKNOWN loc_8050D04; // weak
_UNKNOWN loc_8050D0E; // weak
_UNKNOWN loc_8050EAF; // weak
_UNKNOWN loc_8050ED6; // weak
_UNKNOWN loc_8050EE0; // weak
_UNKNOWN loc_8050F0B; // weak
_UNKNOWN loc_8051057; // weak
_UNKNOWN loc_805126C; // weak
_UNKNOWN loc_805135C; // weak
_UNKNOWN loc_805139E; // weak
_UNKNOWN loc_8051590; // weak
_UNKNOWN loc_80515C1; // weak
_UNKNOWN loc_80515E2; // weak
_UNKNOWN loc_8051620; // weak
_UNKNOWN loc_80518A8; // weak
_UNKNOWN loc_80518B0; // weak
_UNKNOWN loc_8051A34; // weak
_UNKNOWN loc_8051A79; // weak
_UNKNOWN loc_8051B09; // weak
_UNKNOWN loc_8051BA8; // weak
_UNKNOWN loc_8051C1F; // weak
_UNKNOWN loc_8051ED8; // weak
_UNKNOWN loc_8051EF6; // weak
_UNKNOWN loc_8052167; // weak
_UNKNOWN loc_8052197; // weak
_UNKNOWN locret_805219C; // weak
_UNKNOWN loc_8052313; // weak
_UNKNOWN loc_80523B6; // weak
_UNKNOWN loc_80523C4; // weak
_UNKNOWN locret_80523E9; // weak
_UNKNOWN loc_8052548; // weak
_UNKNOWN loc_80525BB; // weak
_UNKNOWN locret_80527A4; // weak
_UNKNOWN loc_8052931; // weak
_UNKNOWN loc_8052953; // weak
_UNKNOWN loc_8052983; // weak
_UNKNOWN loc_8052985; // weak
_UNKNOWN loc_80529AA; // weak
_UNKNOWN loc_8052A4F; // weak
_UNKNOWN loc_8052A80; // weak
_UNKNOWN loc_8052B6B; // weak
_UNKNOWN loc_8052B9E; // weak
_UNKNOWN loc_8052BEF; // weak
_UNKNOWN loc_8052C28; // weak
_UNKNOWN loc_8052C62; // weak
_UNKNOWN loc_8052C8C; // weak
_UNKNOWN loc_8052CB7; // weak
_UNKNOWN loc_8052CFC; // weak
_UNKNOWN loc_8052D7E; // weak
_UNKNOWN loc_8052DB1; // weak
_UNKNOWN loc_8052DFB; // weak
_UNKNOWN loc_8052E71; // weak
_UNKNOWN loc_8052F0F; // weak
_UNKNOWN locret_8052F21; // weak
_UNKNOWN locret_8052FA3; // weak
_UNKNOWN loc_8053333; // weak
_UNKNOWN loc_8053374; // weak
_UNKNOWN loc_80533E0; // weak
_UNKNOWN loc_805341E; // weak
_UNKNOWN loc_805344F; // weak
_UNKNOWN loc_8053474; // weak
_UNKNOWN loc_8053530; // weak
_UNKNOWN loc_80535C1; // weak
_UNKNOWN loc_80535EA; // weak
_UNKNOWN loc_80538CB; // weak
_UNKNOWN loc_8053900; // weak
_UNKNOWN loc_8053933; // weak
_UNKNOWN loc_8053962; // weak
_UNKNOWN loc_8053BC5; // weak
_UNKNOWN loc_8053DC3; // weak
_UNKNOWN loc_8053DDB; // weak
_UNKNOWN loc_8053E17; // weak
_UNKNOWN loc_8053ED1; // weak
_UNKNOWN loc_8053FDA; // weak
_UNKNOWN loc_805409C; // weak
_UNKNOWN loc_8054136; // weak
_UNKNOWN loc_8054138; // weak
_UNKNOWN loc_80541E5; // weak
_UNKNOWN loc_8054228; // weak
_UNKNOWN loc_805422F; // weak
_UNKNOWN loc_805424E; // weak
_UNKNOWN loc_8054254; // weak
_UNKNOWN loc_80542CD; // weak
_UNKNOWN loc_80542D9; // weak
_UNKNOWN loc_8054322; // weak
_UNKNOWN loc_8054326; // weak
_UNKNOWN loc_8054349; // weak
_UNKNOWN loc_805462C; // weak
_UNKNOWN loc_8054795; // weak
_UNKNOWN loc_80547A5; // weak
_UNKNOWN loc_805482B; // weak
_UNKNOWN loc_8054868; // weak
_UNKNOWN loc_80548A8; // weak
_UNKNOWN loc_80548AD; // weak
_UNKNOWN loc_805491A; // weak
_UNKNOWN loc_805497D; // weak
_UNKNOWN loc_80549A3; // weak
_UNKNOWN loc_8054A6A; // weak
_UNKNOWN loc_8054A8E; // weak
_UNKNOWN loc_8054B4A; // weak
_UNKNOWN loc_8054CBF; // weak
_UNKNOWN loc_8054CE3; // weak
_UNKNOWN loc_8054D6C; // weak
_UNKNOWN loc_8054D81; // weak
_UNKNOWN loc_8054DA5; // weak
_UNKNOWN loc_8054DF5; // weak
_UNKNOWN loc_8054F1F; // weak
_UNKNOWN loc_8054F34; // weak
_UNKNOWN loc_8054FAA; // weak
_UNKNOWN loc_8054FE7; // weak
_UNKNOWN loc_8055162; // weak
_UNKNOWN loc_8055189; // weak
_UNKNOWN loc_80551AD; // weak
_UNKNOWN loc_8055241; // weak
_UNKNOWN loc_8055283; // weak
_UNKNOWN loc_80552F1; // weak
_UNKNOWN loc_80555C8; // weak
_UNKNOWN loc_805566B; // weak
_UNKNOWN loc_8055725; // weak
_UNKNOWN loc_805574D; // weak
_UNKNOWN loc_805575E; // weak
_UNKNOWN loc_80557A7; // weak
_UNKNOWN loc_80557D3; // weak
_UNKNOWN loc_8055867; // weak
_UNKNOWN loc_80558E8; // weak
_UNKNOWN loc_80559CC; // weak
_UNKNOWN loc_80559E2; // weak
_UNKNOWN loc_8055A1E; // weak
_UNKNOWN loc_8055A63; // weak
_UNKNOWN loc_8055AE9; // weak
_UNKNOWN loc_8055C5B; // weak
_UNKNOWN loc_8055C63; // weak
_UNKNOWN loc_8055FDF; // weak
_UNKNOWN loc_8055FEF; // weak
_UNKNOWN loc_8056020; // weak
_UNKNOWN loc_805605B; // weak
_UNKNOWN loc_80572E9; // weak
_UNKNOWN loc_8057390; // weak
_UNKNOWN locret_80573CA; // weak
_UNKNOWN loc_8057607; // weak
_UNKNOWN loc_8057628; // weak
_UNKNOWN loc_8057640; // weak
_UNKNOWN loc_8057669; // weak
_UNKNOWN loc_8057681; // weak
_UNKNOWN loc_805770F; // weak
_UNKNOWN loc_805775A; // weak
_UNKNOWN loc_805777D; // weak
_UNKNOWN loc_80577EC; // weak
_UNKNOWN loc_80577F3; // weak
_UNKNOWN loc_805781F; // weak
_UNKNOWN loc_80578F4; // weak
_UNKNOWN loc_8057910; // weak
_UNKNOWN loc_8057940; // weak
_UNKNOWN loc_805794A; // weak
_UNKNOWN locret_8057B3C; // weak
_UNKNOWN loc_8057B7D; // weak
_UNKNOWN loc_8057BAF; // weak
_UNKNOWN loc_8057C1E; // weak
_UNKNOWN loc_8058149; // weak
_UNKNOWN loc_805818C; // weak
_UNKNOWN loc_80581CE; // weak
_UNKNOWN loc_80581D2; // weak
_UNKNOWN loc_8058203; // weak
_UNKNOWN loc_80583D3; // weak
_UNKNOWN locret_8058417; // weak
_UNKNOWN loc_8058499; // weak
_UNKNOWN loc_80584B0; // weak
_UNKNOWN loc_8058516; // weak
_UNKNOWN loc_8058518; // weak
_UNKNOWN loc_805856C; // weak
_UNKNOWN loc_8058970; // weak
_UNKNOWN locret_8058983; // weak
_UNKNOWN loc_80589CB; // weak
_UNKNOWN loc_8058A40; // weak
_UNKNOWN loc_8058A5F; // weak
_UNKNOWN loc_8058AB3; // weak
_UNKNOWN loc_8058AE0; // weak
_UNKNOWN loc_8058AE7; // weak
_UNKNOWN loc_8058B06; // weak
_UNKNOWN loc_8058BA1; // weak
_UNKNOWN loc_8058BAB; // weak
_UNKNOWN loc_8058DB1; // weak
_UNKNOWN loc_8058DC9; // weak
_UNKNOWN loc_805901F; // weak
_UNKNOWN loc_805902F; // weak
_UNKNOWN loc_805914B; // weak
_UNKNOWN loc_8059185; // weak
_UNKNOWN loc_80593CD; // weak
_UNKNOWN loc_80594A2; // weak
_UNKNOWN loc_8059574; // weak
_UNKNOWN loc_80595E7; // weak
_UNKNOWN loc_80597F4; // weak
_UNKNOWN loc_80597FC; // weak
_UNKNOWN loc_80598BD; // weak
_UNKNOWN loc_80598C4; // weak
_UNKNOWN loc_8059950; // weak
_UNKNOWN loc_8059A08; // weak
_UNKNOWN loc_8059A0A; // weak
_UNKNOWN loc_8059A28; // weak
_UNKNOWN loc_8059AA9; // weak
_UNKNOWN loc_8059AB1; // weak
_UNKNOWN loc_8059ADD; // weak
_UNKNOWN loc_8059B1E; // weak
_UNKNOWN loc_8059B23; // weak
_UNKNOWN loc_8059B25; // weak
_UNKNOWN loc_8059B8F; // weak
_UNKNOWN loc_8059BB6; // weak
_UNKNOWN loc_8059BE4; // weak
_UNKNOWN loc_8059C2A; // weak
_UNKNOWN loc_8059C6B; // weak
_UNKNOWN locret_8059C8C; // weak
_UNKNOWN loc_8059CBA; // weak
_UNKNOWN loc_8059D23; // weak
_UNKNOWN locret_8059D3B; // weak
_UNKNOWN loc_8059EF4; // weak
_UNKNOWN loc_805A049; // weak
_UNKNOWN loc_805A168; // weak
_UNKNOWN loc_805A16F; // weak
_UNKNOWN locret_805A1B8; // weak
_UNKNOWN loc_805A283; // weak
_UNKNOWN loc_805A2A0; // weak
_UNKNOWN loc_805A2A3; // weak
_UNKNOWN loc_805A326; // weak
_UNKNOWN loc_805A4BD; // weak
_UNKNOWN loc_805A4C4; // weak
_UNKNOWN loc_805A70D; // weak
_UNKNOWN locret_805A72A; // weak
_UNKNOWN loc_805A865; // weak
_UNKNOWN loc_805A897; // weak
_UNKNOWN loc_805A8F6; // weak
_UNKNOWN loc_805A90D; // weak
_UNKNOWN loc_805A93D; // weak
_UNKNOWN loc_805A97E; // weak
_UNKNOWN loc_805A99D; // weak
_UNKNOWN loc_805A9FD; // weak
_UNKNOWN loc_805AA4A; // weak
_UNKNOWN loc_805AA4F; // weak
_UNKNOWN loc_805AC8F; // weak
_UNKNOWN loc_805AD22; // weak
_UNKNOWN loc_805ADE0; // weak
_UNKNOWN loc_805AE22; // weak
_UNKNOWN loc_805AE2F; // weak
_UNKNOWN loc_805AE7D; // weak
_UNKNOWN loc_805AF28; // weak
_UNKNOWN loc_805AF36; // weak
_UNKNOWN loc_805B06F; // weak
_UNKNOWN loc_805B0B2; // weak
_UNKNOWN loc_805B0B7; // weak
_UNKNOWN loc_805B238; // weak
_UNKNOWN loc_805B273; // weak
_UNKNOWN loc_805B2B8; // weak
_UNKNOWN loc_805B2C8; // weak
_UNKNOWN loc_805B2F6; // weak
_UNKNOWN loc_805B31A; // weak
_UNKNOWN loc_805B363; // weak
_UNKNOWN loc_805B37A; // weak
_UNKNOWN loc_805B3E6; // weak
_UNKNOWN loc_805B438; // weak
_UNKNOWN loc_805B443; // weak
_UNKNOWN loc_805B485; // weak
_UNKNOWN loc_805B4CE; // weak
_UNKNOWN loc_805B55A; // weak
_UNKNOWN loc_805B57F; // weak
_UNKNOWN loc_805B586; // weak
_UNKNOWN loc_805B8D2; // weak
_UNKNOWN loc_805B91A; // weak
_UNKNOWN loc_805B921; // weak
_UNKNOWN loc_805B99A; // weak
_UNKNOWN locret_805C348; // weak
_UNKNOWN loc_805C36D; // weak
_UNKNOWN loc_805C3E2; // weak
_UNKNOWN loc_805C3E7; // weak
_UNKNOWN loc_805C42A; // weak
_UNKNOWN loc_805C508; // weak
_UNKNOWN loc_805D245; // weak
_UNKNOWN loc_805D2BF; // weak
_UNKNOWN loc_805D2D2; // weak
_UNKNOWN loc_805D580; // weak
_UNKNOWN loc_805D591; // weak
_UNKNOWN loc_805D5DD; // weak
_UNKNOWN loc_805D65F; // weak
_UNKNOWN loc_805D670; // weak
_UNKNOWN loc_805D6D4; // weak
_UNKNOWN loc_805D6D8; // weak
_UNKNOWN loc_805D6FB; // weak
_UNKNOWN locret_805D72E; // weak
_UNKNOWN loc_805D767; // weak
_UNKNOWN loc_805D7A2; // weak
_UNKNOWN loc_805D7AB; // weak
_UNKNOWN loc_805D7D7; // weak
_UNKNOWN loc_805D811; // weak
_UNKNOWN loc_805D842; // weak
_UNKNOWN loc_805D855; // weak
_UNKNOWN loc_805D87E; // weak
_UNKNOWN loc_805D9B0; // weak
_UNKNOWN loc_805D9DD; // weak
_UNKNOWN loc_805D9F6; // weak
_UNKNOWN loc_805DA20; // weak
_UNKNOWN locret_805DCA1; // weak
_UNKNOWN loc_805DCF6; // weak
_UNKNOWN loc_805DD29; // weak
_UNKNOWN loc_805DD56; // weak
_UNKNOWN loc_805DD80; // weak
_UNKNOWN loc_805E270; // weak
_UNKNOWN loc_805E466; // weak
_UNKNOWN loc_805E4A0; // weak
_UNKNOWN loc_805E52F; // weak
_UNKNOWN loc_805E53A; // weak
_UNKNOWN loc_805E631; // weak
_UNKNOWN loc_805E885; // weak
_UNKNOWN loc_805E8D3; // weak
_UNKNOWN loc_805E8E5; // weak
_UNKNOWN loc_805E9D2; // weak
_UNKNOWN loc_805EA0E; // weak
_UNKNOWN loc_805EA52; // weak
_UNKNOWN loc_805EA71; // weak
_UNKNOWN loc_805EA7B; // weak
_UNKNOWN loc_805EEE0; // weak
_UNKNOWN loc_805EF13; // weak
_UNKNOWN loc_805EF1A; // weak
_UNKNOWN loc_805F08E; // weak
_UNKNOWN loc_805F0FA; // weak
_UNKNOWN loc_805F233; // weak
_UNKNOWN loc_805F252; // weak
_UNKNOWN loc_805F268; // weak
_UNKNOWN locret_805F561; // weak
_UNKNOWN loc_805F5FC; // weak
_UNKNOWN loc_805F615; // weak
_UNKNOWN loc_805F675; // weak
_UNKNOWN loc_805F7A5; // weak
_UNKNOWN loc_805F7CF; // weak
_UNKNOWN loc_805F7D4; // weak
_UNKNOWN loc_805F8A6; // weak
_UNKNOWN loc_805F911; // weak
_UNKNOWN loc_805F918; // weak
_UNKNOWN loc_805F93D; // weak
_UNKNOWN loc_805F984; // weak
_UNKNOWN loc_805F98A; // weak
_UNKNOWN loc_80600F4; // weak
_UNKNOWN loc_8060106; // weak
_UNKNOWN loc_8060127; // weak
_UNKNOWN loc_80602C8; // weak
_UNKNOWN loc_80602CF; // weak
_UNKNOWN loc_806059C; // weak
_UNKNOWN loc_8060665; // weak
_UNKNOWN loc_80606FE; // weak
_UNKNOWN loc_8060732; // weak
_UNKNOWN loc_8060758; // weak
_UNKNOWN locret_806075B; // weak
_UNKNOWN loc_8060824; // weak
_UNKNOWN loc_8060843; // weak
_UNKNOWN loc_8060999; // weak
_UNKNOWN loc_80609B6; // weak
_UNKNOWN loc_8060CB3; // weak
_UNKNOWN loc_8060D20; // weak
_UNKNOWN loc_8060D27; // weak
_UNKNOWN loc_8060D63; // weak
_UNKNOWN loc_8060D7A; // weak
_UNKNOWN loc_8060DE5; // weak
_UNKNOWN loc_8060DEC; // weak
_UNKNOWN loc_8060EB3; // weak
_UNKNOWN loc_8060ECF; // weak
_UNKNOWN loc_8060ED4; // weak
_UNKNOWN locret_8060EDF; // weak
_UNKNOWN loc_8060F08; // weak
_UNKNOWN loc_8060F39; // weak
_UNKNOWN loc_806117E; // weak
_UNKNOWN loc_80611AA; // weak
_UNKNOWN loc_8061305; // weak
_UNKNOWN loc_8061350; // weak
_UNKNOWN loc_806135B; // weak
_UNKNOWN loc_806137A; // weak
char msgid[48] = "\nWith no FILE, or when FILE is -, read standard "; // idb
_UNKNOWN unk_8062035; // weak
char s = '\0'; // idb
char aKKeyKeydefSort[132] = "  -k, --key=KEYDEF          sort via a key; KEYDEF gives location and type\n  -m, --merge               merge already sorted files; d"; // idb
char aOOutputFileWri[84] = "  -o, --output=FILE         write result to FILE instead of standard output\n  -s, --"; // idb
struct option longopts = { "ignore-leading-blanks", 0, NULL, 98 }; // idb
char *off_806347C[3] = { "quiet", "silent", "diagnose-first" }; // weak
char aCccgeneralNume[19] = "CCcgeneral-numeric"; // weak
void *off_80634C4 = (void *)0x806348F; // weak
char byte_80634E0[6] = { 'g', 'h', 'M', 'n', 'R', 'V' }; // idb
char byte_8063750[256] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x06',
  '\0',
  '\x03',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0',
  '\x04',
  '\0',
  '\0',
  '\0',
  '\0',
  '\b',
  '\a',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
int sig[11] = { 14, 1, 2, 13, 3, 15, 29, 27, 26, 24, 25 }; // idb
_UNKNOWN unk_80643D0; // weak
_UNKNOWN unk_8064420; // weak
_UNKNOWN unk_8064635; // weak
_UNKNOWN unk_806531F; // weak
int dword_8065EF8 = 236208579; // weak
_UNKNOWN unk_806637C; // weak
_UNKNOWN unk_806637F; // weak
int dword_8066EEC = 1344536576; // weak
_UNKNOWN unk_80673C8; // weak
_UNKNOWN unk_80673CB; // weak
_UNKNOWN unk_8068404; // weak
_UNKNOWN unk_8068407; // weak
_UNKNOWN unk_8069454; // weak
_UNKNOWN unk_8069457; // weak
int (*off_806AEAC[2])() = { &sub_804A030, &sub_804A010 }; // weak
int (*off_806AEB0)() = &sub_804A010; // weak
int (*dword_806B008)(void) = NULL; // weak
int dword_806B20C = 0; // weak
int dword_806B220 = 0; // weak
int dword_806B234 = 0; // weak
int dword_806B248 = 0; // weak
int dword_806B25C = 0; // weak
int dword_806B270 = 0; // weak
int dword_806B284 = 0; // weak
int dword_806B298 = 0; // weak
int dword_806B2AC = 0; // weak
int dword_806B2C0 = 0; // weak
int dword_806B2D4 = 0; // weak
int dword_806B2E8 = 0; // weak
int dword_806B2FC = 0; // weak
int dword_806B310 = 0; // weak
int dword_806B324 = 0; // weak
int dword_806B338 = 0; // weak
int (__cdecl *dword_806B348)(_DWORD) = NULL; // weak
int dword_806B35C = 0; // weak
int dword_806B370 = 0; // weak
int dword_806B384 = 0; // weak
int dword_806B39C = 0; // weak
char byte_806B3B8 = '\n'; // weak
char *off_806B3D8 = "APR"; // weak
int dword_806B3DC[] = { 4 }; // weak
size_t dword_806B438 = 262144u; // idb
int dword_806B43C = 128; // weak
int dword_806B440 = 16; // idb
int *off_806B444 = &dword_806C2F1; // weak
char byte_806B448 = 'X'; // weak
char byte_806B452 = '\0'; // weak
int off_806B458 = 134628168; // idb
int off_806B45C = 134568872; // idb
int status = 1; // idb
int dword_806B478 = 1; // weak
int dword_806B47C = 256; // weak
void *off_806B480 = &unk_806C411; // weak
int *off_806B484 = &dword_806B47C; // weak
_UNKNOWN unk_806B498; // weak
_UNKNOWN unk_806B4B8; // weak
_UNKNOWN unk_806B4BB; // weak
_UNKNOWN unk_806B4CC; // weak
_UNKNOWN unk_806B4CF; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int program_invocation_name; // weak
int optind; // weak
FILE *stdin; // idb
FILE *stdout; // idb
int (*obstack_alloc_failed_handler)(void); // weak
char *optarg; // idb
char byte_806B54C; // weak
char byte_806B7DA; // weak
_UNKNOWN unk_806B7DE; // weak
char byte_806BAD5; // weak
_UNKNOWN unk_806BB46; // weak
char byte_806BC1C; // weak
_UNKNOWN unk_806BD67; // weak
int dword_806BE31; // weak
int dword_806BE35; // weak
char byte_806BE39; // weak
char byte_806BE3A; // weak
int dword_806BE3D; // weak
char byte_806BE51[256]; // idb
_UNKNOWN unk_806BF51; // weak
_UNKNOWN unk_806C051; // weak
char byte_806C151[256]; // idb
size_t size; // idb
void *ptr; // idb
int dword_806C259; // weak
int dword_806C25D; // weak
char byte_806C261; // weak
char byte_806C262; // weak
char byte_806C263; // weak
char byte_806C264; // weak
int dword_806C265; // weak
char *arg; // idb
char byte_806C26D; // weak
__sigset_t set; // idb
int dword_806C2F1; // weak
int dword_806C2F5; // weak
int dword_806C2F9; // weak
_UNKNOWN unk_806C311; // weak
int dword_806C3AD; // weak
int dword_806C3B1; // weak
int dword_806C3B5; // weak
char byte_806C3B9; // weak
int dword_806C3BD; // weak
int dword_806C3C1; // weak
int dword_806C3D1; // weak
int dword_806C3D5; // weak
int dword_806C3D9; // weak
int dword_806C3DD; // weak
int dword_806C3E1; // weak
int dword_806C3E5; // weak
int dword_806C3E9; // weak
int dword_806C3ED; // weak
int dword_806C3F1; // weak
int dword_806C3F5; // weak
int dword_806C3F9; // weak
int dword_806C3FD; // weak
_UNKNOWN unk_806C411; // weak
int dword_806C511; // weak
int dword_806C515; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (0804972C) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 8049F30: using guessed type int _gmon_start__(void);

//----- (08049750) --------------------------------------------------------
int sub_8049750()
{
  return dword_806B008();
}
// 806B008: using guessed type int (*dword_806B008)(void);

//----- (08049F40) --------------------------------------------------------
#error "8049F43: positive sp value has been found (funcsize=2)"

//----- (08049F73) --------------------------------------------------------
void sub_8049F73()
{
  ;
}

//----- (08049F90) --------------------------------------------------------
void sub_8049F90()
{
  ;
}

//----- (08049FA0) --------------------------------------------------------
int sub_8049FA0()
{
  int result; // eax

  result = &unk_806B4CF - &unk_806B4CC;
  if ( (unsigned int)(&unk_806B4CF - &unk_806B4CC) > 6 )
    result = 0;
  return result;
}
// 8049FA0: could not find valid save-restore pair for ebp

//----- (0804A010) --------------------------------------------------------
int sub_804A010()
{
  int result; // eax

  if ( !byte_806B54C )
  {
    result = sub_8049FA0();
    byte_806B54C = 1;
  }
  return result;
}
// 804A010: could not find valid save-restore pair for ebp
// 806B54C: using guessed type char byte_806B54C;

//----- (0804A030) --------------------------------------------------------
int sub_804A030()
{
  return 0;
}
// 804A030: could not find valid save-restore pair for ebp

//----- (0804A08F) --------------------------------------------------------
void sub_804A08F()
{
  ;
}

//----- (0804A0AA) --------------------------------------------------------
void sub_804A0AA()
{
  ;
}

//----- (0804A0BA) --------------------------------------------------------
int sub_804A0BA()
{
  int result; // eax

  result = &unk_806B4BB - &unk_806B4B8;
  if ( (unsigned int)(&unk_806B4BB - &unk_806B4B8) > 6 )
    result = 0;
  return result;
}
// 804A0BA: could not find valid save-restore pair for ebp

//----- (0804A121) --------------------------------------------------------
int __usercall sub_804A121@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_806B4B8, a1);
}

//----- (0804A1B8) --------------------------------------------------------
void sub_804A1B8()
{
  ;
}

//----- (0804A1D3) --------------------------------------------------------
void sub_804A1D3()
{
  ;
}

//----- (0804A1E3) --------------------------------------------------------
int sub_804A1E3()
{
  int result; // eax

  result = &unk_806B4BB - &unk_806B4B8;
  if ( (unsigned int)(&unk_806B4BB - &unk_806B4B8) > 6 )
    result = 0;
  return result;
}
// 804A1E3: could not find valid save-restore pair for ebp

//----- (0804A2C5) --------------------------------------------------------
void sub_804A2C5()
{
  ;
}

//----- (0804A2E0) --------------------------------------------------------
void sub_804A2E0()
{
  ;
}

//----- (0804A2F0) --------------------------------------------------------
signed int sub_804A2F0()
{
  return 3;
}
// 804A2F0: could not find valid save-restore pair for ebx
// 804A2F0: could not find valid save-restore pair for ebp
// 8061DE3: using guessed type int __fastcall sub_8061DE3(_DWORD, _DWORD);
// 806B220: using guessed type int dword_806B220;

//----- (0804A367) --------------------------------------------------------
int sub_804A367()
{
  return nullsub_4();
}
// 804A367: could not find valid save-restore pair for ebp
// 804A366: using guessed type int nullsub_4(void);

//----- (0804A407) --------------------------------------------------------
void sub_804A407()
{
  ;
}

//----- (0804A422) --------------------------------------------------------
void sub_804A422()
{
  ;
}

//----- (0804A432) --------------------------------------------------------
int sub_804A432()
{
  int result; // eax

  result = &unk_806B4BB - &unk_806B4B8;
  if ( (unsigned int)(&unk_806B4BB - &unk_806B4B8) > 6 )
    result = 0;
  return result;
}
// 804A432: could not find valid save-restore pair for ebp

//----- (0804A514) --------------------------------------------------------
void sub_804A514()
{
  ;
}

//----- (0804A52F) --------------------------------------------------------
void sub_804A52F()
{
  ;
}

//----- (0804A53F) --------------------------------------------------------
int sub_804A53F()
{
  int result; // eax

  result = &unk_806B4BB - &unk_806B4B8;
  if ( (unsigned int)(&unk_806B4BB - &unk_806B4B8) > 6 )
    result = 0;
  return result;
}
// 804A53F: could not find valid save-restore pair for ebp

//----- (0804A648) --------------------------------------------------------
void sub_804A648()
{
  ;
}

//----- (0804A663) --------------------------------------------------------
void sub_804A663()
{
  ;
}

//----- (0804A673) --------------------------------------------------------
int sub_804A673()
{
  int result; // eax
  int (__stdcall *v1)(void *, int, int, int, int, int); // eax
  int v2; // [esp+4h] [ebp-18h]
  int v3; // [esp+8h] [ebp-14h]
  int v4; // [esp+Ch] [ebp-10h]
  int v5; // [esp+10h] [ebp-Ch]
  int v6; // [esp+14h] [ebp-8h]
  int v7; // [esp+18h] [ebp-4h]

  result = &unk_8069457 - &unk_8069454;
  if ( (unsigned int)(&unk_8069457 - &unk_8069454) > 6 )
  {
    v7 = 0;
    dword_806B234 = (int)&locret_804A682;
    v1 = (int (__stdcall *)(void *, int, int, int, int, int))sub_8061D73();
    result = v1(&unk_8069454, v2, v3, v4, v5, v6);
  }
  return result;
}
// 8061D73: using guessed type int sub_8061D73(void);
// 806B234: using guessed type int dword_806B234;

//----- (0804A716) --------------------------------------------------------
int sub_804A716()
{
  int result; // eax

  result = sub_804A673();
  byte_806B7DA = 1;
  return result;
}
// 806B7DA: using guessed type char byte_806B7DA;

//----- (0804A78A) --------------------------------------------------------
void sub_804A78A()
{
  ;
}

//----- (0804A7A5) --------------------------------------------------------
void sub_804A7A5()
{
  ;
}

//----- (0804A7B5) --------------------------------------------------------
int sub_804A7B5()
{
  int result; // eax

  result = &unk_806B7DE - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_806B7DE - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 804A7B5: could not find valid save-restore pair for ebp
// 806B4E0: using guessed type int program_invocation_short_name;

//----- (0804A897) --------------------------------------------------------
void sub_804A897()
{
  ;
}

//----- (0804A8B2) --------------------------------------------------------
void sub_804A8B2()
{
  ;
}

//----- (0804A8C2) --------------------------------------------------------
int sub_804A8C2()
{
  int result; // eax

  result = &unk_806B4BB - &unk_806B4B8;
  if ( (unsigned int)(&unk_806B4BB - &unk_806B4B8) > 6 )
    result = 0;
  return result;
}
// 804A8C2: could not find valid save-restore pair for ebp

//----- (0804A9A4) --------------------------------------------------------
void sub_804A9A4()
{
  ;
}

//----- (0804A9BF) --------------------------------------------------------
void sub_804A9BF()
{
  ;
}

//----- (0804A9CF) --------------------------------------------------------
int sub_804A9CF()
{
  int result; // eax

  result = &unk_806B4BB - &unk_806B4B8;
  if ( (unsigned int)(&unk_806B4BB - &unk_806B4B8) > 6 )
    result = 0;
  return result;
}
// 804A9CF: could not find valid save-restore pair for ebp

//----- (0804AAC6) --------------------------------------------------------
void sub_804AAC6()
{
  ;
}

//----- (0804AAE1) --------------------------------------------------------
void sub_804AAE1()
{
  ;
}

//----- (0804AAF1) --------------------------------------------------------
int sub_804AAF1()
{
  int result; // eax

  result = &unk_8068407 - &unk_8068404;
  if ( (unsigned int)(&unk_8068407 - &unk_8068404) > 6 )
    result = 0;
  return result;
}
// 804AAF1: could not find valid save-restore pair for ebp

//----- (0804AB58) --------------------------------------------------------
int __usercall sub_804AB58@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_8068404, a1);
}

//----- (0804AC01) --------------------------------------------------------
void sub_804AC01()
{
  ;
}

//----- (0804AC1C) --------------------------------------------------------
void sub_804AC1C()
{
  ;
}

//----- (0804AC2C) --------------------------------------------------------
int sub_804AC2C()
{
  int result; // eax

  result = &unk_806B4BB - &unk_806B4B8;
  if ( (unsigned int)(&unk_806B4BB - &unk_806B4B8) > 6 )
    result = 0;
  return result;
}
// 804AC2C: could not find valid save-restore pair for ebp

//----- (0804AD0E) --------------------------------------------------------
void sub_804AD0E()
{
  ;
}

//----- (0804AD29) --------------------------------------------------------
void sub_804AD29()
{
  ;
}

//----- (0804AD39) --------------------------------------------------------
int sub_804AD39()
{
  int result; // eax

  result = &unk_806B4BB - &unk_806B4B8;
  if ( (unsigned int)(&unk_806B4BB - &unk_806B4B8) > 6 )
    result = 0;
  return result;
}
// 804AD39: could not find valid save-restore pair for ebp

//----- (0804AE1B) --------------------------------------------------------
void sub_804AE1B()
{
  ;
}

//----- (0804AE36) --------------------------------------------------------
void sub_804AE36()
{
  ;
}

//----- (0804AE46) --------------------------------------------------------
int sub_804AE46()
{
  int result; // eax

  result = &unk_80673CB - &unk_80673C8;
  if ( (unsigned int)(&unk_80673CB - &unk_80673C8) > 6 )
    result = 0;
  return result;
}
// 804AE46: could not find valid save-restore pair for ebp

//----- (0804AED0) --------------------------------------------------------
int sub_804AED0()
{
  int result; // eax

  result = sub_804AE46();
  byte_806BAD5 = 1;
  return result;
}
// 806BAD5: using guessed type char byte_806BAD5;

//----- (0804AF44) --------------------------------------------------------
void sub_804AF44()
{
  ;
}

//----- (0804AF5F) --------------------------------------------------------
void sub_804AF5F()
{
  ;
}

//----- (0804AF6F) --------------------------------------------------------
int sub_804AF6F()
{
  int result; // eax

  result = &unk_806B4BB - &unk_806B4B8;
  if ( (unsigned int)(&unk_806B4BB - &unk_806B4B8) > 6 )
    result = 0;
  return result;
}
// 804AF6F: could not find valid save-restore pair for ebp

//----- (0804AFD6) --------------------------------------------------------
int __usercall sub_804AFD6@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_806B4B8, a1);
}

//----- (0804B03A) --------------------------------------------------------
int __usercall sub_804B03A@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  a1(&dword_8066EEC);
  return nullsub_6();
}
// 804B03A: could not find valid save-restore pair for ebx
// 804AFB3: using guessed type int nullsub_6(void);
// 8061AB5: using guessed type int __fastcall sub_8061AB5(_DWORD, _DWORD);
// 8066EEC: using guessed type int dword_8066EEC;
// 806B2AC: using guessed type int dword_806B2AC;

//----- (0804B086) --------------------------------------------------------
void sub_804B086()
{
  ;
}

//----- (0804B0A1) --------------------------------------------------------
void sub_804B0A1()
{
  ;
}

//----- (0804B0B1) --------------------------------------------------------
int sub_804B0B1()
{
  int result; // eax

  result = &unk_806BB46 - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_806BB46 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 804B0B1: could not find valid save-restore pair for ebp
// 806B4E0: using guessed type int program_invocation_short_name;

//----- (0804B10F) --------------------------------------------------------
int sub_804B10F()
{
  return nullsub_10();
}
// 804B10F: could not find valid save-restore pair for ebp
// 804B10E: using guessed type int nullsub_10(void);

//----- (0804B1EC) --------------------------------------------------------
void sub_804B1EC()
{
  ;
}

//----- (0804B207) --------------------------------------------------------
void sub_804B207()
{
  ;
}

//----- (0804B217) --------------------------------------------------------
int sub_804B217()
{
  int result; // eax

  result = &unk_806B4BB - &unk_806B4B8;
  if ( (unsigned int)(&unk_806B4BB - &unk_806B4B8) > 6 )
    result = 0;
  return result;
}
// 804B217: could not find valid save-restore pair for ebp

//----- (0804B2A1) --------------------------------------------------------
int sub_804B2A1()
{
  int result; // eax

  result = sub_804B217();
  byte_806BC1C = 1;
  return result;
}
// 806BC1C: using guessed type char byte_806BC1C;

//----- (0804B32E) --------------------------------------------------------
void sub_804B32E()
{
  ;
}

//----- (0804B349) --------------------------------------------------------
void sub_804B349()
{
  ;
}

//----- (0804B359) --------------------------------------------------------
int sub_804B359()
{
  int result; // eax

  result = &unk_806637F - &unk_806637C;
  if ( (unsigned int)(&unk_806637F - &unk_806637C) > 6 )
    result = 0;
  return result;
}
// 804B359: could not find valid save-restore pair for ebp

//----- (0804B3B7) --------------------------------------------------------
int sub_804B3B7()
{
  return nullsub_7();
}
// 804B3B7: could not find valid save-restore pair for ebp
// 804B3B6: using guessed type int nullsub_7(void);

//----- (0804B424) --------------------------------------------------------
int __usercall sub_804B424@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  int v1; // ecx
  int v3; // edx
  int v4; // ecx
  int savedregs; // [esp+18h] [ebp+0h]

  a1(&dword_8065EF8);
  dword_806B2FC = (int)&loc_804B385;
  sub_80618E9(v4, v3);
  savedregs = 0;
  dword_806B2FC = (int)nullsub_7;
  sub_80618E9(v1, 0);
  return nullsub_7();
}
// 804B3B6: using guessed type int nullsub_7(void);
// 80618E9: using guessed type int __fastcall sub_80618E9(_DWORD, _DWORD);
// 8065EF8: using guessed type int dword_8065EF8;
// 806B2FC: using guessed type int dword_806B2FC;

//----- (0804B482) --------------------------------------------------------
void sub_804B482()
{
  ;
}

//----- (0804B49D) --------------------------------------------------------
void sub_804B49D()
{
  ;
}

//----- (0804B4AD) --------------------------------------------------------
int sub_804B4AD()
{
  int result; // eax

  result = &unk_806B4BB - &unk_806B4B8;
  if ( (unsigned int)(&unk_806B4BB - &unk_806B4B8) > 6 )
    result = 0;
  return result;
}
// 804B4AD: could not find valid save-restore pair for ebp

//----- (0804B50B) --------------------------------------------------------
int __usercall sub_804B50B@<eax>(int a1@<ebp>)
{
  int v1; // eax
  int (__cdecl *v2)(void *, int); // edx
  int v4; // [esp+18h] [ebp-4h]

  dword_806B20C = (int)nullsub_8;
  v1 = sub_8061E55();
  v4 = a1;
  return v2(&unk_806B4B8, v1);
}
// 804B50B: could not find valid save-restore pair for ebp
// 804B50A: using guessed type int nullsub_8();
// 8061E55: using guessed type int sub_8061E55(void);
// 806B20C: using guessed type int dword_806B20C;

//----- (0804B5C4) --------------------------------------------------------
void sub_804B5C4()
{
  ;
}

//----- (0804B5DF) --------------------------------------------------------
void sub_804B5DF()
{
  ;
}

//----- (0804B5EF) --------------------------------------------------------
int sub_804B5EF()
{
  int result; // eax

  result = &unk_806B4BB - &unk_806B4B8;
  if ( (unsigned int)(&unk_806B4BB - &unk_806B4B8) > 6 )
    result = 0;
  return result;
}
// 804B5EF: could not find valid save-restore pair for ebp

//----- (0804B6ED) --------------------------------------------------------
void sub_804B6ED()
{
  ;
}

//----- (0804B708) --------------------------------------------------------
void sub_804B708()
{
  ;
}

//----- (0804B718) --------------------------------------------------------
int sub_804B718()
{
  int result; // eax

  result = &unk_806BD67 - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_806BD67 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 804B718: could not find valid save-restore pair for ebp
// 806B4E0: using guessed type int program_invocation_short_name;

//----- (0804B77F) --------------------------------------------------------
int __usercall sub_804B77F@<eax>(int a1@<eax>, int (__cdecl *a2)(int *, int)@<edx>)
{
  return a2(&program_invocation_short_name, a1);
}
// 806B4E0: using guessed type int program_invocation_short_name;

//----- (0804B816) --------------------------------------------------------
void sub_804B816()
{
  ;
}

//----- (0804B831) --------------------------------------------------------
void sub_804B831()
{
  ;
}

//----- (0804B841) --------------------------------------------------------
#error "804B86E: call analysis failed (funcsize=23)"

//----- (0804B926) --------------------------------------------------------
int __cdecl sub_804B926(int a1)
{
  int result; // eax

  if ( a1 != 1 )
  {
    result = a1;
    status = a1;
  }
  return result;
}

//----- (0804B939) --------------------------------------------------------
int __cdecl sub_804B939(unsigned __int8 a1)
{
  return a1;
}

//----- (0804B94B) --------------------------------------------------------
signed int __cdecl sub_804B94B(unsigned __int8 a1)
{
  const unsigned __int16 **v1; // eax
  int v2; // ecx
  int v3; // edx
  bool v4; // zf
  void *v5; // eax
  int v6; // edx
  int v7; // ecx
  void *v8; // eax

  v1 = __ctype_b_loc();
  v3 = a1;
  v4 = ((*v1)[v3] & 1) == 0;
  v5 = &loc_804B98C;
  if ( !v4 )
    v5 = &loc_804B9AB;
  dword_806B298 = (int)v5;
  sub_8061B2F(v2, v3 * 2);
  v8 = &loc_804B9AB;
  if ( a1 != 10 )
    v8 = &loc_804B9B2;
  dword_806B2FC = (int)v8;
  sub_80618E9(v7, v6);
  return 1;
}
// 804B94B: could not find valid save-restore pair for ebx
// 80618E9: using guessed type int __fastcall sub_80618E9(_DWORD, _DWORD);
// 8061B2F: using guessed type int __fastcall sub_8061B2F(_DWORD, _DWORD);
// 806B298: using guessed type int dword_806B298;
// 806B2FC: using guessed type int dword_806B2FC;

//----- (0804B9BC) --------------------------------------------------------
int __cdecl sub_804B9BC(unsigned __int64 a1)
{
  unsigned __int64 v1; // rax
  int v2; // ecx
  unsigned __int64 v4; // [esp+18h] [ebp-10h]

  v4 = a1;
  if ( HIDWORD(a1) )
  {
    v1 = sub_8061294(v4, 0xF4240u, 0);
    dword_806B270 = (int)&locret_804BA15;
    sub_8061C11(v2, HIDWORD(v1));
  }
  return v4;
}
// 8061C11: using guessed type int __fastcall sub_8061C11(_DWORD, _DWORD);
// 806B270: using guessed type int dword_806B270;

//----- (0804BA17) --------------------------------------------------------
int sub_804BA17()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext(msgid);
  return fputs_unlocked(v1, v0);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804BA42) --------------------------------------------------------
int sub_804BA42()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nMandatory arguments to long options are mandatory for short options too.\n");
  return fputs_unlocked(v1, v0);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804BA6D) --------------------------------------------------------
int __usercall sub_804BA6D@<eax>(int a1@<edx>, int a2@<ecx>, char *s1)
{
  void *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // ebx
  char *v8; // eax
  char *v10; // [esp+4h] [ebp-64h]
  char *v11; // [esp+8h] [ebp-60h]
  char *v12; // [esp+1Ch] [ebp-4Ch]
  const char **v13; // [esp+20h] [ebp-48h]
  char *v14; // [esp+24h] [ebp-44h]
  const char *v15; // [esp+28h] [ebp-40h]
  void *v16; // [esp+2Ch] [ebp-3Ch]
  const char *v17; // [esp+30h] [ebp-38h]
  const char *v18; // [esp+34h] [ebp-34h]
  const char *v19; // [esp+38h] [ebp-30h]
  const char *v20; // [esp+3Ch] [ebp-2Ch]
  const char *v21; // [esp+40h] [ebp-28h]
  const char *v22; // [esp+44h] [ebp-24h]
  const char *v23; // [esp+48h] [ebp-20h]
  const char *v24; // [esp+4Ch] [ebp-1Ch]
  const char *v25; // [esp+50h] [ebp-18h]
  const char *v26; // [esp+54h] [ebp-14h]
  int v27; // [esp+58h] [ebp-10h]
  int v28; // [esp+5Ch] [ebp-Ch]

  v15 = "[";
  v16 = &unk_8062035;
  v17 = "coreutils";
  v18 = "Multi-call invocation";
  v19 = "sha224sum";
  v20 = "sha2 utilities";
  v21 = "sha256sum";
  v22 = "sha2 utilities";
  v23 = "sha384sum";
  v24 = "sha2 utilities";
  v25 = "sha512sum";
  v26 = "sha2 utilities";
  v27 = 0;
  v28 = 0;
  v12 = s1;
  v13 = &v15;
  dword_806B248 = (int)&loc_804BAFD;
  sub_8061CFB(a2, a1);
  do
  {
    v13 += 2;
    if ( !*v13 )
      break;
    v10 = (char *)*v13;
  }
  while ( strcmp(s1, v10) );
  v3 = &loc_804BB41;
  if ( !v13[1] )
    v3 = &loc_804BB4A;
  dword_806B2E8 = (int)v3;
  sub_8061957();
  v12 = (char *)v13[1];
  v4 = gettext("\n%s online help: <%s>\n");
  v11 = "http://www.gnu.org/software/coreutils/";
  v10 = "GNU coreutils";
  printf(v4, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  v14 = setlocale(5, 0);
  if ( v14 && strncmp(v14, "en_", 3u) )
  {
    v5 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
    v10 = s1;
    printf(v5, s1);
  }
  v6 = gettext("Full documentation at: <%s%s>\n");
  v11 = s1;
  v10 = "http://www.gnu.org/software/coreutils/";
  printf(v6, "http://www.gnu.org/software/coreutils/", s1);
  if ( v12 == s1 )
    v7 = " invocation";
  else
    v7 = &s;
  v8 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  v11 = v7;
  v10 = v12;
  return printf(v8, v12, v7);
}
// 8061957: using guessed type int sub_8061957(void);
// 8061CFB: using guessed type int __fastcall sub_8061CFB(_DWORD, _DWORD);
// 806B248: using guessed type int dword_806B248;
// 806B2E8: using guessed type int dword_806B2E8;

//----- (0804BC21) --------------------------------------------------------
void __cdecl __noreturn sub_804BC21(int a1, const char *a2)
{
  size_t v2; // eax
  char *v3; // ST20_4
  size_t v4; // eax
  char v5; // [esp+30h] [ebp-18h]
  unsigned int v6; // [esp+3Ch] [ebp-Ch]

  v6 = __readgsdword(0x14u);
  v2 = strlen(a2);
  write(2, a2, v2);
  if ( a1 )
  {
    v3 = (char *)sub_8059559(a1, &v5);
    write(2, ": errno ", 8u);
    v4 = strlen(v3);
    write(2, v3, v4);
  }
  write(2, "\n", 1u);
  _exit(2);
}

//----- (0804BCE7) --------------------------------------------------------
void __fastcall __noreturn sub_804BCE7(int ecx0, int edx0, int a1, int a2)
{
  void *v4; // eax
  char *v5; // eax
  void *v6; // ebx
  int *v7; // eax

  v4 = &loc_804BD0D;
  if ( a2 )
    v4 = &loc_804BD1B;
  dword_806B270 = (int)v4;
  sub_8061C11(ecx0, edx0);
  v5 = gettext("standard output");
  v6 = sub_805BD48(0, 3, v5);
  v7 = __errno_location();
  error(2, *v7, "%s: %s", a1, v6);
  sub_804BD62(a1);
}
// 8061C11: using guessed type int __fastcall sub_8061C11(_DWORD, _DWORD);
// 806B270: using guessed type int dword_806B270;

//----- (0804BD62) --------------------------------------------------------
void __cdecl __noreturn sub_804BD62(int status)
{
  int v1; // ebx
  char *v2; // eax
  int v3; // esi
  int v4; // ebx
  char *v5; // eax
  FILE *v6; // ebx
  char *v7; // eax
  FILE *v8; // ebx
  char *v9; // eax
  FILE *v10; // ebx
  char *v11; // eax
  FILE *v12; // ebx
  char *v13; // eax
  FILE *v14; // ebx
  char *v15; // eax
  FILE *v16; // ebx
  char *v17; // eax
  FILE *v18; // ebx
  char *v19; // eax
  FILE *v20; // ebx
  char *v21; // eax
  FILE *v22; // ebx
  char *v23; // eax
  FILE *v24; // ebx
  char *v25; // eax
  FILE *v26; // ebx
  char *v27; // eax
  FILE *v28; // ebx
  char *v29; // eax
  FILE *v30; // ebx
  char *v31; // eax
  char *v32; // eax
  FILE *v33; // ebx
  char *v34; // eax
  FILE *v35; // ebx
  char *v36; // eax
  FILE *v37; // ebx
  char *v38; // eax
  FILE *v39; // ebx
  char *v40; // eax
  FILE *v41; // ebx
  char *v42; // eax
  int v43; // edx
  int v44; // ecx

  if ( status )
  {
    v1 = dword_806C3C1;
    v2 = gettext("Try '%s --help' for more information.\n");
    fprintf(stderr, v2, v1);
  }
  else
  {
    v3 = dword_806C3C1;
    v4 = dword_806C3C1;
    v5 = gettext("Usage: %s [OPTION]... [FILE]...\n  or:  %s [OPTION]... --files0-from=F\n");
    printf(v5, v4, v3);
    v6 = stdout;
    v7 = gettext("Write sorted concatenation of all FILE(s) to standard output.\n");
    fputs_unlocked(v7, v6);
    sub_804BA17();
    sub_804BA42();
    v8 = stdout;
    v9 = gettext("Ordering options:\n\n");
    fputs_unlocked(v9, v8);
    v10 = stdout;
    v11 = gettext(
            "  -b, --ignore-leading-blanks  ignore leading blanks\n"
            "  -d, --dictionary-order      consider only blanks and alphanumeric characters\n"
            "  -f, --ignore-case           fold lower case to upper case characters\n");
    fputs_unlocked(v11, v10);
    v12 = stdout;
    v13 = gettext(
            "  -g, --general-numeric-sort  compare according to general numerical value\n"
            "  -i, --ignore-nonprinting    consider only printable characters\n"
            "  -M, --month-sort            compare (unknown) < 'JAN' < ... < 'DEC'\n");
    fputs_unlocked(v13, v12);
    v14 = stdout;
    v15 = gettext("  -h, --human-numeric-sort    compare human readable numbers (e.g., 2K 1G)\n");
    fputs_unlocked(v15, v14);
    v16 = stdout;
    v17 = gettext(
            "  -n, --numeric-sort          compare according to string numerical value\n"
            "  -R, --random-sort           shuffle, but group identical keys.  See shuf(1)\n"
            "      --random-source=FILE    get random bytes from FILE\n"
            "  -r, --reverse               reverse the result of comparisons\n");
    fputs_unlocked(v17, v16);
    v18 = stdout;
    v19 = gettext(
            "      --sort=WORD             sort according to WORD:\n"
            "                                general-numeric -g, human-numeric -h, month -M,\n"
            "                                numeric -n, random -R, version -V\n"
            "  -V, --version-sort          natural sort of (version) numbers within text\n"
            "\n");
    fputs_unlocked(v19, v18);
    v20 = stdout;
    v21 = gettext("Other options:\n\n");
    fputs_unlocked(v21, v20);
    v22 = stdout;
    v23 = gettext(
            "      --batch-size=NMERGE   merge at most NMERGE inputs at once;\n"
            "                            for more use temp files\n");
    fputs_unlocked(v23, v22);
    v24 = stdout;
    v25 = gettext(
            "  -c, --check, --check=diagnose-first  check for sorted input; do not sort\n"
            "  -C, --check=quiet, --check=silent  like -c, but do not report first bad line\n"
            "      --compress-program=PROG  compress temporaries with PROG;\n"
            "                              decompress them with PROG -d\n");
    fputs_unlocked(v25, v24);
    v26 = stdout;
    v27 = gettext(
            "      --debug               annotate the part of the line used to sort,\n"
            "                              and warn about questionable usage to stderr\n"
            "      --files0-from=F       read input from the files specified by\n"
            "                            NUL-terminated names in file F;\n"
            "                            If F is - then read names from standard input\n");
    fputs_unlocked(v27, v26);
    v28 = stdout;
    v29 = gettext(aKKeyKeydefSort);
    fputs_unlocked(v29, v28);
    v30 = stdout;
    v31 = gettext(aOOutputFileWri);
    fputs_unlocked(v31, v30);
    v32 = gettext(
            "  -t, --field-separator=SEP  use SEP instead of non-blank to blank transition\n"
            "  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or %s;\n"
            "                              multiple options specify multiple directories\n"
            "      --parallel=N          change the number of sorts run concurrently to N\n"
            "  -u, --unique              with -c, check for strict ordering;\n"
            "                              without -c, output only the first of an equal run\n");
    printf(v32, "/tmp");
    v33 = stdout;
    v34 = gettext("  -z, --zero-terminated     line delimiter is NUL, not newline\n");
    fputs_unlocked(v34, v33);
    v35 = stdout;
    v36 = gettext("      --help     display this help and exit\n");
    fputs_unlocked(v36, v35);
    v37 = stdout;
    v38 = gettext("      --version  output version information and exit\n");
    fputs_unlocked(v38, v37);
    v39 = stdout;
    v40 = gettext(
            "\n"
            "KEYDEF is F[.C][OPTS][,F[.C][OPTS]] for start and stop position, where F is a\n"
            "field number and C a character position in the field; both are origin 1, and\n"
            "the stop position defaults to the line's end.  If neither -t nor -b is in\n"
            "effect, characters in a field are counted from the beginning of the preceding\n"
            "whitespace.  OPTS is one or more single-letter ordering options [bdfgiMhnRrV],\n"
            "which override global ordering options for that key.  If no key is given, use\n"
            "the entire line as the key.  Use --debug to diagnose incorrect key usage.\n"
            "\n"
            "SIZE may be followed by the following multiplicative suffixes:\n");
    fputs_unlocked(v40, v39);
    v41 = stdout;
    v42 = gettext(
            "% 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, E, Z, Y.\n"
            "\n"
            "*** WARNING ***\n"
            "The locale specified by the environment affects sort order.\n"
            "Set LC_ALL=C to get the traditional sort order that uses\n"
            "native byte values.\n");
    fputs_unlocked(v42, v41);
    sub_804BA6D(v43, v44, "sort");
  }
  exit(status);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 806C3C1: using guessed type int dword_806C3C1;

//----- (0804C01E) --------------------------------------------------------
int __cdecl sub_804C01E(int a1)
{
  bool v1; // dl
  int result; // eax

  v1 = pthread_sigmask(0, &set, (__sigset_t *)(a1 + 4)) == 0;
  result = a1;
  *(_BYTE *)a1 = v1;
  return result;
}

//----- (0804C053) --------------------------------------------------------
int __cdecl sub_804C053(int a1)
{
  void *v1; // eax

  v1 = &loc_804C07C;
  if ( !*(_BYTE *)a1 )
    v1 = &locret_804C09A;
  dword_806B20C = (int)v1;
  sub_8061E55();
  return pthread_sigmask(2, (const __sigset_t *)(a1 + 4), 0);
}
// 8061E55: using guessed type int sub_8061E55(void);
// 806B20C: using guessed type int dword_806B20C;

//----- (0804C09C) --------------------------------------------------------
int __cdecl sub_804C09C(int a1, unsigned int a2)
{
  return *(_DWORD *)(a1 + 4) % a2;
}

//----- (0804C0BA) --------------------------------------------------------
bool __cdecl sub_804C0BA(int a1, int a2)
{
  return *(_DWORD *)(a1 + 4) == *(_DWORD *)(a2 + 4);
}

//----- (0804C0DF) --------------------------------------------------------
int __cdecl sub_804C0DF(int a1)
{
  int v1; // ecx
  int v2; // edx
  void *v3; // esi
  char *v4; // ebx
  int v5; // eax
  void *v6; // ebx
  char *v7; // eax
  void *v9; // [esp+Ch] [ebp-1Ch]
  int stat_loc; // [esp+18h] [ebp-10h]
  int v11; // [esp+1Ch] [ebp-Ch]

  v2 = a1 == 0;
  if ( a1 )
  {
    dword_806B220 = (int)&loc_804C116;
    sub_8061DE3(v1, v2);
  }
  v11 = waitpid(-1, &stat_loc, v2);
  if ( v11 < 0 )
  {
    v3 = sub_805BBED(4, arg);
    v4 = gettext("waiting for %s [-d]");
    v5 = *__errno_location();
    v9 = v3;
    error(2, v5, v4, v3);
  }
  if ( v11 > 0 && (a1 > 0 || (unsigned __int8)sub_804C28D(v11)) )
  {
    if ( stat_loc & 0x7F || (stat_loc & 0xFF00) >> 8 )
    {
      v6 = sub_805BBED(4, arg);
      v7 = gettext("%s [-d] terminated abnormally");
      v9 = v6;
      error(2, 0, v7, v6);
    }
    --dword_806C2F9;
  }
  return v11;
}
// 8061DE3: using guessed type int __fastcall sub_8061DE3(_DWORD, _DWORD);
// 806B220: using guessed type int dword_806B220;
// 806C2F9: using guessed type int dword_806C2F9;

//----- (0804C200) --------------------------------------------------------
void __cdecl __noreturn sub_804C200(int a1)
{
  bool v1; // zf
  int (*v2)(); // eax

  if ( !dword_806C2F5 )
  {
    dword_806C2F5 = sub_8058419(0x2Fu, 0);
    if ( !dword_806C2F5 )
      sub_805E689();
  }
  *(_BYTE *)(a1 + 8) = 1;
  v1 = sub_8058FDE(dword_806C2F5, a1) == 0;
  v2 = (int (*)())&loc_804C286;
  if ( !v1 )
    v2 = sub_804C28B;
  dword_806B20C = (int)v2;
  sub_8061E55();
  sub_805E689();
}
// 804C28B: using guessed type int sub_804C28B();
// 8061E55: using guessed type int sub_8061E55(void);
// 806B20C: using guessed type int dword_806B20C;
// 806C2F5: using guessed type int dword_806C2F5;

//----- (0804C28B) --------------------------------------------------------
#error "804C28C: positive sp value has been found (funcsize=0)"

//----- (0804C28D) --------------------------------------------------------
signed int __cdecl sub_804C28D(int a1)
{
  int v1; // edx
  int v2; // ecx
  int v4; // [esp+1Ch] [ebp-1Ch]
  char v5; // [esp+20h] [ebp-18h]
  int v6; // [esp+24h] [ebp-14h]
  unsigned int v7; // [esp+2Ch] [ebp-Ch]

  v7 = __readgsdword(0x14u);
  v6 = a1;
  v4 = sub_8059036(dword_806C2F5, (int)&v5);
  if ( !v4 )
  {
    dword_806B298 = (int)&loc_804C2E9;
    sub_8061B2F(v2, v1);
  }
  *(_BYTE *)(v4 + 8) = 2;
  return 1;
}
// 8061B2F: using guessed type int __fastcall sub_8061B2F(_DWORD, _DWORD);
// 806B298: using guessed type int dword_806B298;
// 806C2F5: using guessed type int dword_806C2F5;

//----- (0804C2FC) --------------------------------------------------------
signed int __cdecl sub_804C2FC(int a1)
{
  signed int result; // eax

  result = sub_804C28D(a1);
  if ( (_BYTE)result )
    result = sub_804C0DF(a1);
  return result;
}

//----- (0804C31E) --------------------------------------------------------
int sub_804C31E()
{
  void *v0; // eax
  int result; // eax

  do
  {
    v0 = &loc_804C348;
    if ( dword_806C2F9 <= 0 )
      v0 = &locret_804C358;
    dword_806B2D4 = (int)v0;
    sub_80619CB();
    result = sub_804C0DF(0);
  }
  while ( result );
  return result;
}
// 80619CB: using guessed type int sub_80619CB(void);
// 806B2D4: using guessed type int dword_806B2D4;
// 806C2F9: using guessed type int dword_806C2F9;

//----- (0804C35A) --------------------------------------------------------
int sub_804C35A()
{
  sub_804C0DF(-1);
  return sub_804C31E();
}

//----- (0804C373) --------------------------------------------------------
int __fastcall sub_804C373(int a1, int a2)
{
  int result; // eax

  dword_806B2AC = (int)&loc_804C39C;
  sub_8061AB5(a1, a2);
  do
  {
    sub_804C0DF(-1);
    result = dword_806C2F9;
  }
  while ( dword_806C2F9 > 0 );
  return result;
}
// 8061AB5: using guessed type int __fastcall sub_8061AB5(_DWORD, _DWORD);
// 806B2AC: using guessed type int dword_806B2AC;
// 806C2F9: using guessed type int dword_806C2F9;

//----- (0804C3A7) --------------------------------------------------------
int sub_804C3A7()
{
  int result; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  result = dword_806C2F1;
  for ( i = dword_806C2F1; i; i = *(_DWORD *)i )
  {
    unlink((const char *)(i + 9));
    result = *(_DWORD *)i;
  }
  dword_806C2F1 = 0;
  return result;
}
// 806C2F1: using guessed type int dword_806C2F1;

//----- (0804C3DF) --------------------------------------------------------
int sub_804C3DF()
{
  char v1; // [esp+1Ch] [ebp-8Ch]

  if ( dword_806C2F1 )
  {
    sub_804C01E((int)&v1);
    sub_804C3A7();
    sub_804C053((int)&v1);
  }
  return sub_8055F9C();
}
// 806C2F1: using guessed type int dword_806C2F1;

//----- (0804C419) --------------------------------------------------------
int *__cdecl sub_804C419(int *a1, char a2)
{
  size_t n; // ST34_4
  _DWORD *v3; // eax
  int v4; // ST40_4
  bool v5; // zf
  int v6; // edx
  int v7; // ecx
  void *v8; // eax
  void *v9; // esi
  char *v10; // ebx
  int *v11; // eax
  int *ptr; // [esp+24h] [ebp-A4h]
  char *s; // [esp+28h] [ebp-A0h]
  int v15; // [esp+34h] [ebp-94h]
  char v16; // [esp+3Ch] [ebp-8Ch]

  s = (char *)*((_DWORD *)::ptr + dword_806C3AD);
  n = strlen(*((const char **)::ptr + dword_806C3AD));
  ptr = (int *)sub_805E4FC((n + 24) & 0xFFFFFFFC);
  memcpy((char *)ptr + 9, s, n);
  v3 = (int *)((char *)ptr + n + 9);
  *v3 = 1919906607;
  v3[1] = 1482184820;
  v3[2] = 5789784;
  *ptr = 0;
  if ( ++dword_806C3AD == dword_806C259 )
    dword_806C3AD = 0;
  sub_804C01E((int)&v16);
  v15 = sub_805D527((int)ptr + 9, 0x80000);
  if ( v15 >= 0 )
  {
    *off_806B444 = (int)ptr;
    off_806B444 = ptr;
  }
  v4 = *__errno_location();
  sub_804C053((int)&v16);
  *__errno_location() = v4;
  if ( v15 < 0 )
  {
    if ( a2 == 1 )
    {
      v5 = *__errno_location() == 24;
      v8 = &loc_804C5AB;
      if ( v5 )
        v8 = &loc_804C5F0;
      dword_806B25C = (int)v8;
      sub_8061C89(v7, v6);
    }
    v9 = sub_805BBED(4, s);
    v10 = gettext("cannot create temporary file in %s");
    v11 = __errno_location();
    error(2, *v11, v10, v9);
    free(ptr);
    ptr = 0;
  }
  *a1 = v15;
  return ptr;
}
// 8061C89: using guessed type int __fastcall sub_8061C89(_DWORD, _DWORD);
// 806B25C: using guessed type int dword_806B25C;
// 806B444: using guessed type int *off_806B444;
// 806C259: using guessed type int dword_806C259;
// 806C3AD: using guessed type int dword_806C3AD;

//----- (0804C623) --------------------------------------------------------
FILE *__cdecl sub_804C623(char *s1, char *modes)
{
  int v2; // edx
  int v3; // ecx
  void *v4; // esi
  char *v5; // ebx
  int *v6; // eax
  FILE *stream; // [esp+18h] [ebp-10h]
  int fd; // [esp+1Ch] [ebp-Ch]

  if ( *modes == 114 )
  {
    if ( !strcmp(s1, "-") )
    {
      byte_806C264 = 1;
      stream = stdin;
    }
    else
    {
      fd = open64(s1, 0x80000);
      if ( fd >= 0 )
      {
        fdopen(fd, modes);
        dword_806B284 = (int)&loc_804C6AB;
        sub_8061B9D();
      }
      stream = 0;
    }
    sub_805736B(v2, v3, stream, 2);
  }
  else
  {
    if ( *modes != 119 )
      __assert_fail("!\"unexpected mode passed to stream_open\"", "src/sort.c", 0x3CCu, "stream_open");
    if ( s1 && ftruncate64(1, 0, 0) )
    {
      v4 = sub_805BD48(0, 3, s1);
      v5 = gettext("%s: error truncating");
      v6 = __errno_location();
      error(2, *v6, v5, v4);
    }
    stream = stdout;
  }
  return stream;
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 8049D20: using guessed type int __cdecl ftruncate64(_DWORD, _DWORD, _DWORD);
// 8061B9D: using guessed type int sub_8061B9D(void);
// 806B284: using guessed type int dword_806B284;
// 806C264: using guessed type char byte_806C264;

//----- (0804C778) --------------------------------------------------------
int __cdecl sub_804C778(char *s1, char *modes)
{
  FILE *v2; // ST1C_4
  char *v3; // eax
  int v4; // ecx

  v2 = sub_804C623(s1, modes);
  dword_806B348 = (int (__cdecl *)(_DWORD))sub_804C7C6;
  if ( !v2 )
  {
    v3 = gettext("open failed");
    sub_804BCE7(v4, (int)s1, (int)v3, (int)s1);
  }
  return dword_806B348(s1);
}
// 804C7C6: using guessed type int sub_804C7C6();
// 806B348: using guessed type int (__cdecl *dword_806B348)(_DWORD);

//----- (0804C7C6) --------------------------------------------------------
#error "804C7CA: positive sp value has been found (funcsize=0)"

//----- (0804C7CB) --------------------------------------------------------
int __cdecl sub_804C7CB(FILE *stream, int a2)
{
  bool v2; // zf
  void *v3; // eax
  void *v4; // eax
  int result; // eax
  char *v6; // eax
  int v7; // ecx

  v2 = fileno(stream) == 0;
  v3 = &loc_804C7F9;
  if ( v2 )
    v3 = &loc_804C819;
  dword_806B370 = (int)v3;
  v2 = sub_8061638() == 1;
  v4 = &loc_804C817;
  if ( v2 )
    v4 = &loc_804C837;
  dword_806B2D4 = (int)v4;
  sub_80619CB();
  result = sub_805F563(stream);
  if ( result )
  {
    v6 = gettext("close failed");
    sub_804BCE7(v7, a2, (int)v6, a2);
  }
  return result;
}
// 804C7CB: could not find valid save-restore pair for ebx
// 8061638: using guessed type int sub_8061638(void);
// 80619CB: using guessed type int sub_80619CB(void);
// 806B2D4: using guessed type int dword_806B2D4;
// 806B370: using guessed type int dword_806B370;

//----- (0804C88F) --------------------------------------------------------
int __cdecl sub_804C88F(int fd, int fd2)
{
  void *v2; // eax

  dword_806B348 = (int (__cdecl *)(_DWORD))&locret_804C8E1;
  v2 = &loc_804C8C4;
  if ( fd == fd2 )
    v2 = &loc_805F7D4;
  dword_806B2D4 = (int)v2;
  sub_80619CB();
  dup2(fd, fd2);
  return close(fd);
}
// 80619CB: using guessed type int sub_80619CB(void);
// 806B2D4: using guessed type int dword_806B2D4;
// 806B348: using guessed type int (__cdecl *dword_806B348)(_DWORD);

//----- (0804C8E3) --------------------------------------------------------
__pid_t __cdecl sub_804C8E3(int pipedes[2], int a2)
{
  int v3; // eax
  int *v4; // eax
  int v5; // edx
  int v6; // ecx
  __pid_t v7; // [esp+14h] [ebp-A4h]
  int v8; // [esp+18h] [ebp-A0h]
  int v9; // [esp+1Ch] [ebp-9Ch]
  double v10; // [esp+20h] [ebp-98h]
  char v11; // [esp+2Ch] [ebp-8Ch]

  v10 = 0.25;
  if ( sub_8059F1B(pipedes, 0x80000) < 0 )
    return -1;
  if ( dword_806B440 + 1 < (unsigned int)dword_806C2F9 )
    sub_804C35A();
  while ( 1 )
  {
    v3 = a2--;
    if ( !v3 )
      break;
    sub_804C01E((int)&v11);
    v8 = dword_806C2F1;
    dword_806C2F1 = 0;
    v7 = fork();
    v9 = *__errno_location();
    if ( v7 )
      dword_806C2F1 = v8;
    sub_804C053((int)&v11);
    *__errno_location() = v9;
    if ( v7 >= 0 || *__errno_location() != 11 )
      break;
    sub_805E85E(v10);
    v10 = v10 + v10;
    sub_804C31E();
  }
  if ( v7 < 0 )
  {
    v9 = *__errno_location();
    close(*pipedes);
    close(pipedes[1]);
    v4 = __errno_location();
    v5 = v9;
    *v4 = v9;
    dword_806B25C = (int)&loc_804CA86;
    sub_8061C89(v6, v5);
  }
  if ( !v7 )
  {
    close(0);
    close(1);
    dword_806B20C = (int)&loc_804CA86;
    sub_8061E55();
  }
  ++dword_806C2F9;
  return v7;
}
// 8061C89: using guessed type int __fastcall sub_8061C89(_DWORD, _DWORD);
// 8061E55: using guessed type int sub_8061E55(void);
// 806B20C: using guessed type int dword_806B20C;
// 806B25C: using guessed type int dword_806B25C;
// 806C2F1: using guessed type int dword_806C2F1;
// 806C2F9: using guessed type int dword_806C2F9;

//----- (0804CA8E) --------------------------------------------------------
int *__cdecl sub_804CA8E(FILE **a1, char a2)
{
  __pid_t v3; // eax
  int v4; // ecx
  int *v5; // edx
  void *v6; // eax
  int *v7; // eax
  int v8; // ebx
  char *v9; // eax
  int v10; // edx
  int v11; // ecx
  int v12; // [esp+Ch] [ebp-1Ch]
  int fd; // [esp+10h] [ebp-18h]
  int *v14; // [esp+14h] [ebp-14h]
  int pipedes[2]; // [esp+18h] [ebp-10h]

  LOBYTE(v12) = a2;
  v14 = sub_804C419(&fd, a2);
  if ( !v14 )
    return 0;
  *((_BYTE *)v14 + 8) = 0;
  if ( arg )
  {
    v3 = sub_804C8E3(pipedes, 4);
    v5 = v14;
    v14[1] = v3;
    if ( v14[1] > 0 )
    {
      close(fd);
      close(pipedes[0]);
      fd = pipedes[1];
      sub_804C200((int)v14);
    }
    v6 = &loc_804CB47;
    if ( v14[1] )
      v6 = &loc_804CBAE;
    dword_806B220 = (int)v6;
    sub_8061DE3(v4, v5);
    close(pipedes[1]);
    sub_804C88F(fd, 1);
    sub_804C88F(pipedes[0], 0);
    execlp(arg, arg, 0, v12);
    v7 = __errno_location();
    sub_804BC21(*v7, "couldn't execute compress program");
  }
  *a1 = fdopen(fd, "w");
  if ( !*a1 )
  {
    v8 = (int)v14 + 9;
    v9 = gettext("couldn't create temporary file");
    sub_804BCE7(v11, v10, (int)v9, v8);
  }
  return v14;
}
// 8061DE3: using guessed type int __fastcall sub_8061DE3(_DWORD, _DWORD);
// 806B220: using guessed type int dword_806B220;

//----- (0804CBF6) --------------------------------------------------------
int *__cdecl sub_804CBF6(FILE **a1)
{
  return sub_804CA8E(a1, 0);
}

//----- (0804CC11) --------------------------------------------------------
int __usercall sub_804CC11@<eax>(int edx0@<edx>, int a2@<ecx>, int a1)
{
  void *v3; // eax
  __pid_t v5; // eax
  int v6; // edx
  int v7; // ecx
  bool v8; // zf
  void *v9; // eax
  void *v10; // esi
  char *v11; // ebx
  int v12; // eax
  int *v13; // eax
  const char *v14; // [esp+8h] [ebp-30h]
  void *v15; // [esp+Ch] [ebp-2Ch]
  int v16; // [esp+18h] [ebp-20h]
  int fd; // [esp+1Ch] [ebp-1Ch]
  __pid_t v18; // [esp+20h] [ebp-18h]
  int pipedes[2]; // [esp+28h] [ebp-10h]

  v16 = 0;
  v3 = &loc_804CC44;
  if ( *(_BYTE *)(a1 + 8) != 1 )
    v3 = &loc_804CC52;
  dword_806B338 = (int)v3;
  sub_8061791(a2, edx0);
  sub_804C2FC(*(_DWORD *)(a1 + 4));
  fd = open64(a1 + 9, 0);
  if ( fd >= 0 )
  {
    v5 = sub_804C8E3(pipedes, 9);
    v18 = v5;
    if ( v5 != -1 )
    {
      v8 = v5 == 0;
      v9 = &loc_804CCB6;
      if ( v8 )
        v9 = &loc_804CD38;
      dword_806B220 = (int)v9;
      sub_8061DE3(v7, v6);
      *(_DWORD *)(a1 + 4) = v18;
      sub_804C200(a1);
    }
    if ( *__errno_location() != 24 )
    {
      v10 = sub_805BBED(4, arg);
      v11 = gettext("couldn't create process for %s -d");
      v12 = *__errno_location();
      v15 = v10;
      error(2, v12, v11, v10);
    }
    close(fd);
    *__errno_location() = 24;
    dword_806B284 = (int)&loc_804CE0E;
    sub_8061B9D();
    close(pipedes[0]);
    sub_804C88F(fd, 0);
    sub_804C88F(pipedes[1], 1);
    v15 = 0;
    v14 = "-d";
    execlp(arg, arg, "-d", 0);
    v13 = __errno_location();
    sub_804BC21(*v13, "couldn't execute compress program (with -d)");
  }
  return 0;
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 8061791: using guessed type int __fastcall sub_8061791(_DWORD, _DWORD);
// 8061B9D: using guessed type int sub_8061B9D(void);
// 8061DE3: using guessed type int __fastcall sub_8061DE3(_DWORD, _DWORD);
// 806B220: using guessed type int dword_806B220;
// 806B284: using guessed type int dword_806B284;
// 806B338: using guessed type int dword_806B338;

//----- (0804CE18) --------------------------------------------------------
int __cdecl sub_804CE18(int a1)
{
  int v1; // eax
  _DWORD *v2; // edx
  int result; // eax

  if ( dword_806C259 == dword_806C25D )
    ptr = sub_805E439(ptr, (int)&dword_806C25D, 4);
  v1 = dword_806C259++;
  v2 = (char *)ptr + 4 * v1;
  result = a1;
  *v2 = a1;
  return result;
}
// 806C259: using guessed type int dword_806C259;
// 806C25D: using guessed type int dword_806C25D;

//----- (0804CE70) --------------------------------------------------------
void __usercall sub_804CE70(int a1@<edx>, int a2@<ecx>, char *name)
{
  void *v3; // eax
  int v4; // ST30_4
  void *v5; // ebx
  char *v6; // eax
  int errnum; // [esp+1Ch] [ebp-9Ch]
  _DWORD *ptr; // [esp+20h] [ebp-98h]
  int v9; // [esp+24h] [ebp-94h]
  char v10; // [esp+2Ch] [ebp-8Ch]

  ptr = (_DWORD *)dword_806C2F1;
  v3 = &loc_804CED1;
  if ( (char *)(dword_806C2F1 + 9) != name )
    v3 = &loc_804CE90;
  dword_806B248 = (int)v3;
  sub_8061CFB(a2, a1);
  if ( *((_BYTE *)ptr + 8) == 1 )
    sub_804C2FC(ptr[1]);
  v9 = *ptr;
  sub_804C01E((int)&v10);
  v4 = unlink(name);
  errnum = *__errno_location();
  dword_806C2F1 = v9;
  sub_804C053((int)&v10);
  if ( v4 )
  {
    v5 = sub_805BD48(0, 3, name);
    v6 = gettext("warning: cannot remove: %s");
    error(0, errnum, v6, v5);
  }
  if ( !v9 )
    off_806B444 = &dword_806C2F1;
  free(ptr);
}
// 8061CFB: using guessed type int __fastcall sub_8061CFB(_DWORD, _DWORD);
// 806B248: using guessed type int dword_806B248;
// 806B444: using guessed type int *off_806B444;
// 806C2F1: using guessed type int dword_806C2F1;

//----- (0804CFC1) --------------------------------------------------------
int __cdecl compar(const void *a1, const void *a2)
{
  return strcmp(*(const char **)a1, *(const char **)a2);
}

//----- (0804CFEB) --------------------------------------------------------
void sub_804CFEB()
{
  int v0; // edx
  int v1; // ecx
  const unsigned __int16 *v2; // ebx
  int v3; // eax
  unsigned int c; // [esp+18h] [ebp-20h]
  unsigned int ca; // [esp+18h] [ebp-20h]
  size_t i; // [esp+1Ch] [ebp-1Ch]
  int v7; // [esp+20h] [ebp-18h]
  const char *s; // [esp+24h] [ebp-14h]
  size_t v9; // [esp+28h] [ebp-10h]
  char *v10; // [esp+2Ch] [ebp-Ch]

  for ( c = 0; c <= 0xFF; ++c )
  {
    *(_BYTE *)(c + 134659665) = sub_804B94B(c);
    *(_BYTE *)(c + 134659921) = ((*__ctype_b_loc())[c] & 0x4000) == 0;
    if ( !((*__ctype_b_loc())[c] & 8) && (unsigned __int8)sub_804B94B(c) ^ 1 )
    {
      dword_806B220 = (int)&loc_804D090;
      sub_8061DE3(v1, v0);
    }
    *(_BYTE *)(c + 134660177) = 0;
    *(_BYTE *)(c + 134660433) = toupper(c);
  }
  if ( byte_806BE3A )
  {
    for ( ca = 0; ca <= 0xB; ++ca )
    {
      s = nl_langinfo(ca + 131086);
      v9 = strlen(s);
      v10 = (char *)sub_805E4FC(v9 + 1);
      (&off_806B3D8)[2 * ca] = v10;
      dword_806B3DC[2 * ca] = ca + 1;
      v7 = 0;
      for ( i = 0; i < v9; ++i )
      {
        v2 = *__ctype_b_loc();
        if ( !(v2[(unsigned __int8)sub_804B939(s[i])] & 1) )
        {
          v3 = v7++;
          v10[v3] = byte_806C151[(unsigned __int8)sub_804B939(s[i])];
        }
      }
      v10[v7] = 0;
    }
    qsort(&off_806B3D8, 0xCu, 8u, compar);
  }
}
// 8061DE3: using guessed type int __fastcall sub_8061DE3(_DWORD, _DWORD);
// 806B220: using guessed type int dword_806B220;
// 806B3D8: using guessed type char *off_806B3D8;
// 806B3DC: using guessed type int dword_806B3DC[];
// 806BE3A: using guessed type char byte_806BE3A;

//----- (0804D1F1) --------------------------------------------------------
unsigned int __usercall sub_804D1F1@<eax>(int edx0@<edx>, int ecx0@<ecx>, int a1, char a2, char *a3)
{
  int v5; // edx
  int v6; // ecx
  int v7; // eax
  void *v8; // eax
  int v9; // edx
  int v10; // ecx
  void *v11; // ebx
  int v12; // esi
  char *v13; // eax
  void *v14; // ebx
  int v15; // esi
  char *v16; // eax
  void *v18; // eax
  void *v19; // ebx
  int v20; // esi
  char *v21; // eax
  int v22; // ebx
  int v23; // esi
  char *v24; // eax
  int v25; // ecx
  int v26; // [esp+Ch] [ebp-4Ch]
  int v27; // [esp+10h] [ebp-48h]
  char *nptr; // [esp+18h] [ebp-40h]
  char v29; // [esp+1Ch] [ebp-3Ch]
  int v30; // [esp+20h] [ebp-38h]
  unsigned int v31; // [esp+24h] [ebp-34h]
  __int64 v32; // [esp+28h] [ebp-30h]
  int v33; // [esp+30h] [ebp-28h]
  int v34; // [esp+34h] [ebp-24h]
  char v35; // [esp+41h] [ebp-17h]
  unsigned int v36; // [esp+4Ch] [ebp-Ch]

  v29 = a2;
  nptr = a3;
  v36 = __readgsdword(0x14u);
  v30 = sub_805F0A0(edx0, ecx0, a3, 0, 10, (int)&v32, 0);
  if ( getrlimit64(7, &v33) )
  {
    v7 = 17;
  }
  else
  {
    v5 = v34;
    v7 = v33 - 3;
  }
  v31 = v7;
  if ( v30 )
  {
LABEL_12:
    v18 = &loc_804D3B3;
    if ( v30 != 1 )
      v18 = &loc_804D446;
    dword_806B248 = (int)v18;
    sub_8061CFB(v6, v5);
    v19 = sub_805BF80(nptr);
    v20 = *((_DWORD *)&longopts.name + 4 * a1);
    v21 = gettext("--%s argument %s too large");
    v27 = (int)v19;
    v26 = v20;
    error(0, 0, v21, v20, v19);
    v22 = sub_805964C(v31, (int)&v35);
    v23 = *((_DWORD *)&longopts.name + 4 * a1);
    v24 = gettext("maximum --%s argument with current rlimit is %s");
    v27 = v22;
    v26 = v23;
    error(2, 0, v24, v23, v22);
    sub_805EF86(v25, (int)nptr, v30, a1, v29, (int)&longopts, (int)nptr);
  }
  dword_806B440 = v32;
  v8 = &loc_804D2B3;
  if ( v32 == (unsigned int)v32 )
    v8 = &loc_804D2D1;
  dword_806B220 = (int)v8;
  sub_8061DE3(v32, HIDWORD(v32));
  v30 = 1;
  dword_806B248 = (int)&loc_804D394;
  sub_8061CFB(v10, v9);
  if ( (unsigned int)dword_806B440 <= 1 )
  {
    v11 = sub_805BF80(nptr);
    v12 = *((_DWORD *)&longopts.name + 4 * a1);
    v13 = gettext("invalid --%s argument %s");
    v27 = (int)v11;
    v26 = v12;
    error(0, 0, v13, v12, v11);
    v14 = sub_805BF80("2");
    v15 = *((_DWORD *)&longopts.name + 4 * a1);
    v16 = gettext("minimum --%s argument is %s");
    v27 = (int)v14;
    v26 = v15;
    error(2, 0, v16, v15, v14);
  }
  if ( v31 < dword_806B440 )
  {
    v30 = 1;
    goto LABEL_12;
  }
  return __readgsdword(0x14u) ^ v36;
}
// 8049920: using guessed type int __cdecl getrlimit64(_DWORD, _DWORD);
// 8061CFB: using guessed type int __fastcall sub_8061CFB(_DWORD, _DWORD);
// 8061DE3: using guessed type int __fastcall sub_8061DE3(_DWORD, _DWORD);
// 806B220: using guessed type int dword_806B220;
// 806B248: using guessed type int dword_806B248;

//----- (0804D47B) --------------------------------------------------------
int __usercall sub_804D47B@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, char *nptr)
{
  __int64 v5; // rax
  int v6; // ecx
  int v7; // ecx
  int v8; // eax
  long double v9; // fst7
  __int16 v10; // ax
  unsigned __int64 v11; // rax
  __int16 v12; // ax
  int result; // eax
  unsigned __int64 v14; // [esp+18h] [ebp-50h]
  double v15; // [esp+20h] [ebp-48h]
  __int16 v16; // [esp+28h] [ebp-40h]
  __int16 v17; // [esp+2Ah] [ebp-3Eh]
  char v18; // [esp+2Ch] [ebp-3Ch]
  int v19; // [esp+38h] [ebp-30h]
  int v20; // [esp+3Ch] [ebp-2Ch]
  unsigned __int64 v21; // [esp+40h] [ebp-28h]
  double v22; // [esp+48h] [ebp-20h]

  v18 = a4;
  v20 = sub_805F0A0(a1, a2, nptr, (int)&v19, 10, (int)&v21, "EgGkKmMPtTYZ");
  if ( !v20 && (unsigned int)(*(char *)(v19 - 1) - 48) <= 9 )
  {
    HIDWORD(v5) = HIDWORD(v21);
    if ( HIDWORD(v21) > 0x3FFFFF )
    {
      v20 = 1;
    }
    else
    {
      v5 = v21 << 10;
      v21 <<= 10;
    }
  }
  LODWORD(v5) = &loc_804D519;
  if ( v20 != 2 )
    LODWORD(v5) = &loc_804D645;
  dword_806B2AC = v5;
  sub_8061AB5(v6, HIDWORD(v5));
  if ( (unsigned int)(*(char *)(v19 - 1) - 48) <= 9 && !*(_BYTE *)(v19 + 1) )
  {
    v8 = *(char *)v19;
    if ( v8 == 37 )
    {
      v9 = sub_8059D3D();
      v14 = v21;
      v15 = (long double)v21;
      v22 = v9 * v15 / 100.0;
      if ( v22 < 1.844674407370955e19 )
      {
        if ( v22 >= 9.223372036854776e18 )
        {
          LOBYTE(v12) = v17;
          HIBYTE(v12) = 12;
          v16 = v12;
          v14 = (signed __int64)(v22 - 9.223372036854776e18);
          v11 = v14 ^ 0x8000000000000000LL;
        }
        else
        {
          LOBYTE(v10) = v17;
          HIBYTE(v10) = 12;
          v16 = v10;
          v14 = (signed __int64)v22;
          v11 = (signed __int64)v22;
        }
        v21 = v11;
        v20 = 0;
        dword_806B2C0 = (int)&loc_804D645;
        sub_8061A43();
      }
      v20 = 1;
    }
    else if ( v8 == 98 )
    {
      v20 = 0;
    }
  }
  if ( v20 )
LABEL_26:
    sub_805EF86(v7, (int)nptr, v20, a3, v18, (int)&longopts, (int)nptr);
  result = v21;
  if ( size > v21 )
    return result;
  size = v21;
  v7 = v21;
  if ( v21 != (unsigned int)v21 )
  {
    v20 = 1;
    goto LABEL_26;
  }
  result = size;
  if ( 18 * dword_806B440 >= size )
    result = 18 * dword_806B440;
  size = result;
  return result;
}
// 8061A43: using guessed type int sub_8061A43(void);
// 8061AB5: using guessed type int __fastcall sub_8061AB5(_DWORD, _DWORD);
// 806B2AC: using guessed type int dword_806B2AC;
// 806B2C0: using guessed type int dword_806B2C0;

//----- (0804D6EE) --------------------------------------------------------
int __cdecl sub_804D6EE(int a1, int a2, char *nptr)
{
  int v3; // ecx
  int *v5; // [esp+Ch] [ebp-2Ch]
  char *v6; // [esp+10h] [ebp-28h]
  char v7; // [esp+1Ch] [ebp-1Ch]
  int v8; // [esp+28h] [ebp-10h]
  int v9; // [esp+2Ch] [ebp-Ch]
  _DWORD *savedregs; // [esp+38h] [ebp+0h]

  savedregs = &savedregs;
  v7 = a2;
  v6 = &s;
  v5 = &v8;
  v9 = sub_805E978(nptr, 0, 10);
  dword_806B348 = (int (__cdecl *)(_DWORD))&loc_804D769;
  if ( v9 == 1 )
  {
    dword_806B348 = (int (__cdecl *)(_DWORD))&locret_804D7EA;
    dword_806B20C = (int)&loc_805F7D4;
    sub_8061E55();
    dword_806B348 = (int (__cdecl *)(_DWORD))sub_804D7AA;
    if ( v9 )
      sub_805EF86(v3, (int)nptr, v9, a1, v7, (int)&longopts, (int)nptr);
  }
  return dword_806B348(a1);
}
// 8061E55: using guessed type int sub_8061E55(void);
// 806B20C: using guessed type int dword_806B20C;
// 806B348: using guessed type int (__cdecl *dword_806B348)(_DWORD);

//----- (0804D7AA) --------------------------------------------------------
#error "804D7EB: positive sp value has been found (funcsize=14)"

//----- (0804D7EC) --------------------------------------------------------
unsigned int __usercall sub_804D7EC@<eax>(long double a1@<st0>)
{
  bool v1; // zf
  void *v2; // eax
  long double v3; // fst7
  unsigned int result; // eax
  int v5; // [esp+0h] [ebp-58h]
  unsigned int v6; // [esp+24h] [ebp-34h]
  unsigned int v7; // [esp+24h] [ebp-34h]
  double v8; // [esp+28h] [ebp-30h]
  double v9; // [esp+30h] [ebp-28h]
  double v10; // [esp+38h] [ebp-20h]
  unsigned __int64 v11; // [esp+40h] [ebp-18h]

  v6 = -1;
  if ( !getrlimit64(2, &v11) && v11 < 0xFFFFFFFF )
    v6 = v11;
  if ( !getrlimit64(9, &v11) && v11 < v6 )
    v6 = v11;
  v7 = v6 >> 1;
  v1 = getrlimit64(5, &v11) == 0;
  v2 = &loc_804D8A6;
  if ( !v1 )
    v2 = &loc_804D8F4;
  dword_806B20C = (int)v2;
  sub_8061E55();
  if ( 15 * (v11 >> 4) < v7 )
    v7 = 15 * (v11 >> 4);
  sub_8059DEA(v5);
  v8 = a1;
  v9 = sub_8059D3D();
  if ( v8 <= v9 / 8.0 )
    v3 = v9 / 8.0;
  else
    v3 = v8;
  v10 = v3;
  if ( (long double)v7 > v9 * 0.75 )
    v7 = (signed __int64)(v9 * 0.75);
  if ( (long double)v7 > v10 )
    v7 = (signed __int64)v10;
  result = v7;
  if ( 18 * dword_806B440 >= v7 )
    result = 18 * dword_806B440;
  return result;
}
// 8049920: using guessed type int __cdecl getrlimit64(_DWORD, _DWORD);
// 8061E55: using guessed type int sub_8061E55(void);
// 806B20C: using guessed type int dword_806B20C;

//----- (0804D9D4) --------------------------------------------------------
int __usercall sub_804D9D4@<eax>(long double a1@<st0>, int a2, unsigned int a3, int a4, unsigned int a5, int a6)
{
  int v6; // eax
  bool v7; // zf
  int v8; // edx
  int v9; // ecx
  void *v10; // eax
  int v11; // ebx
  char *v12; // eax
  int v13; // edx
  int v14; // ecx
  int v16; // [esp+18h] [ebp-80h]
  unsigned int i; // [esp+1Ch] [ebp-7Ch]
  unsigned int v18; // [esp+20h] [ebp-78h]
  unsigned int v19; // [esp+24h] [ebp-74h]
  __int64 v20; // [esp+28h] [ebp-70h]
  char v21; // [esp+30h] [ebp-68h]
  int v22; // [esp+40h] [ebp-58h]
  __int64 v23; // [esp+5Ch] [ebp-3Ch]

  v18 = a6 + 1;
  v16 = a6 + 2;
  for ( i = 0; i < a5; ++i )
  {
    if ( i < a3 )
    {
      v6 = fileno(*(FILE **)(4 * i + a2));
      sub_806151C(v6, (int)&v21);
      dword_806B370 = (int)&loc_804DAC5;
      sub_8061638();
    }
    v7 = strcmp(*(const char **)(4 * i + a4), "-") == 0;
    v10 = &loc_804DA86;
    if ( !v7 )
      v10 = &loc_804DAA0;
    dword_806B25C = (int)v10;
    sub_8061C89(v9, v8);
    if ( sub_806151C(0, (int)&v21) != 0 )
    {
      v11 = *(_DWORD *)(4 * i + a4);
      v12 = gettext("stat failed");
      sub_804BCE7(v14, v13, (int)v12, v11);
    }
    if ( (v22 & 0xF000) == 0x8000 )
    {
      v20 = v23;
    }
    else
    {
      if ( size )
        return size;
      v20 = 0x20000LL;
    }
    if ( !dword_806C3B1 )
    {
      dword_806C3B1 = size;
      if ( !size )
        dword_806C3B1 = sub_804D7EC(a1);
    }
    v19 = v18 * v20 + 1;
    if ( v20 != v19 / v18 || dword_806C3B1 - v16 <= v19 )
      return dword_806C3B1;
    v16 += v19;
  }
  return v16;
}
// 8061638: using guessed type int sub_8061638(void);
// 8061C89: using guessed type int __fastcall sub_8061C89(_DWORD, _DWORD);
// 806B25C: using guessed type int dword_806B25C;
// 806B370: using guessed type int dword_806B370;
// 806C3B1: using guessed type int dword_806C3B1;

//----- (0804DBB7) --------------------------------------------------------
int __cdecl sub_804DBB7(int a1, int a2, size_t size)
{
  int result; // eax
  size_t sizea; // [esp+28h] [ebp+10h]

  while ( 1 )
  {
    sizea = (size & 0xFFFFFFF0) + 16;
    *(_DWORD *)a1 = malloc(sizea);
    if ( *(_DWORD *)a1 )
      break;
    size = sizea >> 1;
    if ( a2 + 1 >= size )
      sub_805E689();
  }
  *(_DWORD *)(a1 + 20) = a2;
  *(_DWORD *)(a1 + 12) = sizea;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a1 + 16);
  result = a1;
  *(_BYTE *)(a1 + 24) = 0;
  return result;
}

//----- (0804DC3D) --------------------------------------------------------
int __cdecl sub_804DC3D(_DWORD *a1)
{
  return *a1 + a1[3];
}

//----- (0804DC58) --------------------------------------------------------
char *__cdecl sub_804DC58(char **a1, int a2)
{
  void *v2; // eax
  int v3; // eax
  bool v4; // zf
  int v5; // edx
  int v6; // ecx
  void *v7; // eax
  int v8; // eax
  char *result; // eax
  int v10; // [esp+0h] [ebp-14h]
  char *v11; // [esp+4h] [ebp-10h]
  int v12; // [esp+8h] [ebp-Ch]
  char *v13; // [esp+Ch] [ebp-8h]
  int v14; // [esp+10h] [ebp-4h]

  v11 = *a1;
  v13 = &v11[(_DWORD)(a1[1] - 1)];
  v12 = *(_DWORD *)a2;
  v14 = *(_DWORD *)(a2 + 4);
  if ( dword_806B43C == 128 )
  {
LABEL_21:
    while ( v11 < v13 )
    {
      v8 = v12--;
      if ( !v8 )
        break;
      if ( v11 < v13 )
      {
        v10 = *v11;
        v4 = byte_806BE51[(unsigned __int8)sub_804B939(v10)] == 0;
        v7 = &loc_804DD53;
        if ( !v4 )
          v7 = &loc_804DD0F;
        dword_806B338 = (int)v7;
        sub_8061791(v6, v5);
      }
      while ( v11 < v13 )
      {
        v10 = *v11;
        if ( !((unsigned __int8)byte_806BE51[(unsigned __int8)sub_804B939(v10)] ^ 1) )
          break;
        ++v11;
      }
    }
  }
  else
  {
    while ( v11 < v13 )
    {
      v3 = v12--;
      if ( !v3 )
      {
        dword_806B2C0 = (int)&loc_804DD9C;
        sub_8061A43();
        goto LABEL_21;
      }
      if ( v11 < v13 )
      {
        v2 = &loc_804DCCF;
        if ( *v11 != dword_806B43C )
          v2 = &loc_804DC98;
        dword_806B384 = (int)v2;
        sub_80615BE();
      }
      if ( v11 < v13 )
        ++v11;
    }
  }
  if ( *(_BYTE *)(a2 + 24) )
  {
    dword_806B370 = (int)&loc_804DDC2;
    sub_8061638();
    do
    {
      if ( ++v11 >= v13 )
        break;
      v10 = *v11;
    }
    while ( byte_806BE51[(unsigned __int8)sub_804B939(v10)] );
  }
  result = v13;
  if ( &v11[v14] <= v13 )
    result = &v11[v14];
  return result;
}
// 804DC58: could not find valid save-restore pair for ebx
// 80615BE: using guessed type int sub_80615BE(void);
// 8061638: using guessed type int sub_8061638(void);
// 8061791: using guessed type int __fastcall sub_8061791(_DWORD, _DWORD);
// 8061A43: using guessed type int sub_8061A43(void);
// 806B2C0: using guessed type int dword_806B2C0;
// 806B338: using guessed type int dword_806B338;
// 806B370: using guessed type int dword_806B370;
// 806B384: using guessed type int dword_806B384;
// 806B43C: using guessed type int dword_806B43C;

//----- (0804DE01) --------------------------------------------------------
unsigned __int8 *__cdecl sub_804DE01(int a1, int a2)
{
  int v2; // ecx
  int v3; // edx
  void *v4; // eax
  void *v5; // eax
  int v6; // eax
  int v7; // edx
  bool v8; // zf
  int v9; // edx
  int v10; // ecx
  void *v11; // eax
  int v12; // eax
  void *v13; // eax
  void *v14; // eax
  unsigned __int8 *result; // eax
  int v16; // [esp+0h] [ebp-14h]
  unsigned __int8 *v17; // [esp+4h] [ebp-10h]
  int v18; // [esp+8h] [ebp-Ch]
  unsigned __int8 *v19; // [esp+Ch] [ebp-8h]
  int v20; // [esp+10h] [ebp-4h]

  v17 = *(unsigned __int8 **)a1;
  v19 = &v17[*(_DWORD *)(a1 + 4) - 1];
  v18 = *(_DWORD *)(a2 + 8);
  v20 = *(_DWORD *)(a2 + 12);
  if ( !v20 )
    ++v18;
  if ( dword_806B43C == 128 )
  {
    while ( v17 < v19 )
    {
      v12 = v18--;
      if ( !v12 )
        break;
      if ( v17 < v19 )
      {
        v8 = byte_806BE51[(unsigned __int8)sub_804B939(*v17)] == 0;
        v11 = &loc_804DF37;
        if ( !v8 )
          v11 = &loc_804DEF3;
        dword_806B248 = (int)v11;
        sub_8061CFB(v10, v9);
      }
      while ( v17 < v19 && (unsigned __int8)byte_806BE51[(unsigned __int8)sub_804B939(*v17)] ^ 1 )
        ++v17;
    }
  }
  else
  {
    while ( v17 < v19 )
    {
      v6 = v18;
      v7 = v18-- - 1;
      if ( !v6 )
        break;
      dword_806B2FC = (int)&loc_804DE69;
      sub_80618E9(v2, v7);
      if ( ++v17 < v19 )
      {
        v4 = &loc_804DE9C;
        if ( (char)*v17 != dword_806B43C )
          v4 = &loc_804DE65;
        dword_806B234 = (int)v4;
        sub_8061D73();
      }
      if ( v17 < v19 )
      {
        if ( !v18 )
        {
          v5 = &loc_804DEC9;
          if ( !v20 )
            v5 = &loc_804DECD;
          dword_806B338 = (int)v5;
          sub_8061791(v2, v3);
        }
        ++v17;
      }
    }
  }
  v13 = &loc_804DF9F;
  if ( !v20 )
    v13 = &loc_804E018;
  dword_806B2C0 = (int)v13;
  sub_8061A43();
  v14 = &loc_804DFC3;
  if ( !*(_BYTE *)(a2 + 25) )
    v14 = &loc_804E005;
  dword_806B2D4 = (int)v14;
  sub_80619CB();
  dword_806B310 = (int)&loc_804DFDE;
  sub_8061877();
  do
  {
    if ( ++v17 >= v19 )
      break;
    v16 = (char)*v17;
  }
  while ( byte_806BE51[(unsigned __int8)sub_804B939(v16)] );
  result = v19;
  if ( &v17[v20] <= v19 )
    result = &v17[v20];
  return result;
}
// 804DE01: could not find valid save-restore pair for ebx
// 8061791: using guessed type int __fastcall sub_8061791(_DWORD, _DWORD);
// 8061877: using guessed type int sub_8061877(void);
// 80618E9: using guessed type int __fastcall sub_80618E9(_DWORD, _DWORD);
// 80619CB: using guessed type int sub_80619CB(void);
// 8061A43: using guessed type int sub_8061A43(void);
// 8061CFB: using guessed type int __fastcall sub_8061CFB(_DWORD, _DWORD);
// 8061D73: using guessed type int sub_8061D73(void);
// 806B234: using guessed type int dword_806B234;
// 806B248: using guessed type int dword_806B248;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B2D4: using guessed type int dword_806B2D4;
// 806B2FC: using guessed type int dword_806B2FC;
// 806B310: using guessed type int dword_806B310;
// 806B338: using guessed type int dword_806B338;
// 806B43C: using guessed type int dword_806B43C;

//----- (0804E01D) --------------------------------------------------------
int __cdecl sub_804E01D(int a1)
{
  int v1; // ST44_4
  void *v2; // eax

  v1 = *(_DWORD *)(a1 + 20);
  v2 = &loc_804E06F;
  if ( !*(_BYTE *)(a1 + 24) )
    v2 = &loc_804E079;
  dword_806B370 = (int)v2;
  sub_8061638();
  return 0;
}
// 8061638: using guessed type int sub_8061638(void);
// 806B370: using guessed type int dword_806B370;
// 806C265: using guessed type int dword_806C265;

//----- (0804E44F) --------------------------------------------------------
int __usercall sub_804E44F@<eax>(int a1@<edx>, int a2@<ecx>, char **a3)
{
  int v3; // ecx
  int v4; // edx
  char *v5; // eax
  char *v6; // eax
  unsigned __int8 v8; // [esp+9h] [ebp-7h]
  unsigned __int8 v9; // [esp+Bh] [ebp-5h]
  char *v10; // [esp+Ch] [ebp-4h]

  v10 = *a3;
  v8 = 0;
  dword_806B270 = (int)&loc_804E4AC;
  sub_8061C11(a2, a1);
  do
  {
    if ( v8 < v9 )
      v8 = v9;
    v4 = *v10;
    if ( v4 == dword_806BE35 )
      ++v10;
    v5 = v10++;
    v9 = *v5;
  }
  while ( (unsigned int)(unsigned __int8)*v5 - 48 <= 9 );
  if ( v4 == dword_806BE35 )
  {
    *a3 = v10 - 2;
    dword_806B298 = (int)&locret_804E53C;
    sub_8061B2F(v3, v10 - 2);
  }
  if ( v9 == dword_806BE31 )
  {
    while ( 1 )
    {
      v6 = v10++;
      if ( (unsigned int)(unsigned __int8)*v6 - 48 > 9 )
        break;
      if ( v8 < (unsigned __int8)*v6 )
        v8 = *v6;
    }
  }
  *a3 = v10 - 1;
  return v8;
}
// 8061B2F: using guessed type int __fastcall sub_8061B2F(_DWORD, _DWORD);
// 8061C11: using guessed type int __fastcall sub_8061C11(_DWORD, _DWORD);
// 806B270: using guessed type int dword_806B270;
// 806B298: using guessed type int dword_806B298;
// 806BE31: using guessed type int dword_806BE31;
// 806BE35: using guessed type int dword_806BE35;

//----- (0804E53E) --------------------------------------------------------
int __cdecl sub_804E53E(_BYTE *a1)
{
  int v1; // ecx
  bool v3; // [esp+9h] [ebp-Bh]
  unsigned __int8 v4; // [esp+Ah] [ebp-Ah]
  unsigned __int8 v5; // [esp+Bh] [ebp-9h]
  char *v6; // [esp+Ch] [ebp-8h]
  int v7; // [esp+10h] [ebp-4h]

  v3 = *a1 == 45;
  v6 = &a1[v3];
  v4 = sub_804E44F(v3, v1, &v6);
  if ( v4 > 0x30u )
  {
    v5 = *v6;
    v7 = byte_8063750[v5];
    dword_806B234 = (int)&locret_804E5B8;
    sub_8061D73();
  }
  return 0;
}
// 8061D73: using guessed type int sub_8061D73(void);
// 806B234: using guessed type int dword_806B234;

//----- (0804E5BA) --------------------------------------------------------
signed int __cdecl sub_804E5BA(unsigned __int8 *a1, unsigned __int8 *a2)
{
  bool v2; // zf
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  int v6; // ebx
  int v7; // eax
  signed int result; // eax

  v2 = byte_806BE51[(unsigned __int8)sub_804B939(*a1)] == 0;
  v5 = &loc_804E5FF;
  if ( !v2 )
    v5 = &loc_804E5C3;
  dword_806B270 = (int)v5;
  sub_8061C11(v4, v3);
  while ( byte_806BE51[(unsigned __int8)sub_804B939(*a2)] )
    ++a2;
  v6 = sub_804E53E(a1);
  v7 = sub_804E53E(a2);
  if ( v6 == v7 )
    result = sub_805DCA3(a1, a2, dword_806BE31, dword_806BE35);
  else
    result = v6 - v7;
  return result;
}
// 8061C11: using guessed type int __fastcall sub_8061C11(_DWORD, _DWORD);
// 806B270: using guessed type int dword_806B270;
// 806BE31: using guessed type int dword_806BE31;
// 806BE35: using guessed type int dword_806BE35;

//----- (0804E679) --------------------------------------------------------
signed int __cdecl sub_804E679(unsigned __int8 *a1, unsigned __int8 *a2)
{
  while ( byte_806BE51[(unsigned __int8)sub_804B939(*a1)] )
    ++a1;
  while ( byte_806BE51[(unsigned __int8)sub_804B939(*a2)] )
    ++a2;
  return sub_805DCA3(a1, a2, dword_806BE31, dword_806BE35);
}
// 806BE31: using guessed type int dword_806BE31;
// 806BE35: using guessed type int dword_806BE35;

//----- (0804E6F0) --------------------------------------------------------
int __cdecl sub_804E6F0(int a1, int a2)
{
  _TBYTE s; // [esp+10h] [ebp-28h]
  _TBYTE s2; // [esp+20h] [ebp-18h]

  memset(&s, 0, 0xCu);
  *(long double *)&s = strtold(a1, 0);
  memset(&s2, 0, 0xCu);
  *(long double *)&s2 = strtold(a2, 0);
  return memcmp(&s, &s2, 0xCu);
}
// 80498F0: using guessed type double __cdecl strtold(_DWORD, _DWORD);

//----- (0804E774) --------------------------------------------------------
signed int __cdecl sub_804E774(int a1, int a2)
{
  signed int result; // eax
  int v3; // [esp+18h] [ebp-30h]
  int v4; // [esp+1Ch] [ebp-2Ch]
  long double v5; // [esp+20h] [ebp-28h]
  long double v6; // [esp+30h] [ebp-18h]

  v5 = strtold(a1, &v3);
  v6 = strtold(a2, &v4);
  if ( a1 == v3 )
  {
    if ( a2 == v4 )
      result = 0;
    else
      result = -1;
  }
  else if ( a2 == v4 )
  {
    result = 1;
  }
  else if ( v6 <= v5 )
  {
    if ( v5 <= v6 )
    {
      if ( v6 == v5 )
        result = 0;
      else
        result = -1;
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}
// 804E774: could not find valid save-restore pair for ebx
// 80498F0: using guessed type double __cdecl strtold(_DWORD, _DWORD);
// 8061C89: using guessed type int __fastcall sub_8061C89(_DWORD, _DWORD);
// 806B25C: using guessed type int dword_806B25C;

//----- (0804E891) --------------------------------------------------------
int __cdecl sub_804E891(unsigned __int8 *a1, unsigned __int8 **a2)
{
  bool v2; // zf
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  int v6; // ecx
  void *v7; // eax
  void *v8; // eax
  int v10; // [esp+0h] [ebp-28h]

  v2 = byte_806BE51[(unsigned __int8)sub_804B939(*a1)] == 0;
  v5 = &loc_804E8E4;
  if ( !v2 )
    v5 = &loc_804E8A8;
  dword_806B270 = (int)v5;
  sub_8061C11(v4, v3);
  v7 = &loc_804E927;
  if ( **(&off_806B3D8 + 12) )
    v7 = &loc_804E95D;
  dword_806B324 = (int)v7;
  sub_8061801(v6, 0, v10);
  v8 = &loc_804E946;
  if ( !a2 )
    v8 = &loc_804E94E;
  dword_806B234 = (int)v8;
  sub_8061D73();
  *a2 = a1;
  return dword_806B3DC[12];
}
// 8061C11: using guessed type int __fastcall sub_8061C11(_DWORD, _DWORD);
// 8061D73: using guessed type int sub_8061D73(void);
// 806B234: using guessed type int dword_806B234;
// 806B270: using guessed type int dword_806B270;
// 806B324: using guessed type int dword_806B324;
// 806B3D8: using guessed type char *off_806B3D8;
// 806B3DC: using guessed type int dword_806B3DC[];

//----- (0804EA38) --------------------------------------------------------
unsigned int __cdecl sub_804EA38(int a1)
{
  char *v1; // eax
  int v2; // ecx
  char *v3; // eax
  int v4; // ecx
  char *v6; // [esp+18h] [ebp-20h]
  char ptr; // [esp+1Ch] [ebp-1Ch]
  unsigned int v8; // [esp+2Ch] [ebp-Ch]

  v8 = __readgsdword(0x14u);
  v6 = sub_805C246(a1, 0x10u);
  if ( !v6 )
  {
    v1 = gettext("open failed");
    sub_804BCE7(v2, a1, (int)v1, a1);
  }
  sub_805C552((int)v6, &ptr, 0x10u);
  if ( sub_805C59A(v6) )
  {
    v3 = gettext("close failed");
    sub_804BCE7(v4, a1, (int)v3, a1);
  }
  sub_80560B2(&unk_806C311);
  sub_8056451(&ptr, 0x10u, (int)&unk_806C311);
  return __readgsdword(0x14u) ^ v8;
}

//----- (0804EB04) --------------------------------------------------------
size_t __cdecl sub_804EB04(char *dest, char *src, size_t n)
{
  char *v3; // ebx
  int *v4; // eax
  char *v5; // eax
  void *v6; // ebx
  char *v7; // eax
  size_t v9; // [esp+1Ch] [ebp-Ch]

  *__errno_location() = 0;
  v9 = strxfrm(dest, src, n);
  if ( *__errno_location() )
  {
    v3 = gettext("string transformation failed");
    v4 = __errno_location();
    error(0, *v4, v3);
    v5 = gettext("set LC_ALL='C' to work around the problem");
    error(0, 0, v5);
    v6 = sub_805BB72(0, 8, src);
    v7 = gettext("the untransformed string was %s");
    error(2, 0, v7, v6);
  }
  return v9;
}

//----- (0804EBDC) --------------------------------------------------------
void __cdecl __noreturn sub_804EBDC(int a1, size_t a2, int a3, size_t a4)
{
  void *v4; // eax
  int v5; // ecx
  size_t v6; // eax
  size_t v7; // eax
  size_t v8; // edx
  int v9; // edx
  int v10; // ecx
  size_t v11; // eax
  size_t v12; // eax
  void *v13; // eax
  size_t v14; // eax
  int v15; // eax
  bool v16; // zf
  void *v17; // eax
  int v18; // eax
  int v19; // edx
  int v20; // ecx
  void *v21; // eax
  size_t v22; // eax
  int (*v23)(); // eax
  int v24; // [esp+0h] [ebp-1168h]
  char *s; // [esp+18h] [ebp-1150h]
  char *src; // [esp+1Ch] [ebp-114Ch]
  bool v27; // [esp+2Bh] [ebp-113Dh]
  int v28; // [esp+2Ch] [ebp-113Ch]
  char *dest; // [esp+30h] [ebp-1138h]
  size_t size; // [esp+34h] [ebp-1134h]
  void *ptr; // [esp+38h] [ebp-1130h]
  int v32; // [esp+3Ch] [ebp-112Ch]
  char *v33; // [esp+40h] [ebp-1128h]
  char *v34; // [esp+44h] [ebp-1124h]
  size_t v35; // [esp+48h] [ebp-1120h]
  size_t n; // [esp+4Ch] [ebp-111Ch]
  size_t v37; // [esp+50h] [ebp-1118h]
  char s1; // [esp+54h] [ebp-1114h]
  int v39; // [esp+64h] [ebp-1104h]
  int v40; // [esp+74h] [ebp-10F4h]
  char v41; // [esp+110h] [ebp-1058h]
  char v42; // [esp+1ACh] [ebp-FBCh]
  unsigned int v43; // [esp+114Ch] [ebp-1Ch]
  size_t v44; // [esp+1174h] [ebp+Ch]
  size_t v45; // [esp+117Ch] [ebp+14h]

  src = (char *)a1;
  s = (char *)a3;
  v43 = __readgsdword(0x14u);
  v28 = 0;
  dest = &v42;
  size = 4000;
  ptr = 0;
  qmemcpy(&v41, &unk_806C311, 0x9Cu);
  qmemcpy(&v40, &v41, 0x9Cu);
  v4 = &loc_804EC84;
  if ( !byte_806BE39 )
    v4 = &loc_804F0DA;
  dword_806B2FC = (int)v4;
  sub_80618E9(0, &v40);
  v33 = &src[a2];
  v34 = &s[a4];
  while ( 1 )
  {
    v35 = 3 * (a4 + a2) + 2;
    if ( size < v35 )
    {
      v6 = v35;
      if ( 3 * size >> 1 >= v35 )
        v6 = 3 * size >> 1;
      size = v6;
      free(ptr);
      ptr = malloc(size);
      dest = (char *)ptr;
      if ( !ptr )
      {
        dest = &v42;
        size = 4000;
      }
    }
    if ( src >= v33 )
      v7 = 0;
    else
      v7 = sub_804EB04(dest, src, size) + 1;
    n = v7;
    v27 = v7 <= size;
    if ( s < v34 )
    {
      if ( v27 )
      {
        dword_806B298 = (int)&loc_804EDD3;
        sub_8061B2F(v5, size - n);
      }
      v8 = 0;
      if ( v27 )
      {
        dword_806B324 = (int)&loc_804EE06;
        sub_8061801(dest, 0, v24);
      }
      sub_804EB04(0, s, v8);
      dword_806B220 = (int)&loc_804EE3B;
      sub_8061DE3(v10, v9);
    }
    v37 = 0;
    if ( v27 != 1 || n + v37 > size )
    {
      size = n + v37;
      if ( n + v37 <= 0x55555554 )
        size = 3 * size >> 1;
      free(ptr);
      ptr = sub_805E4FC(size);
      dest = (char *)ptr;
      if ( src < v33 )
        strxfrm(dest, src, n);
      if ( s < v34 )
        strxfrm(&dest[n], s, v37);
    }
    if ( src < v33 )
    {
      v11 = strlen(src);
      src += v11 + 1;
    }
    if ( s < v34 )
    {
      v12 = strlen(s);
      s += v12 + 1;
    }
    if ( src >= v33 && s >= v34 )
      break;
    sub_8056451(dest, n, (int)&v40);
    sub_8056451(&dest[n], v37, (int)&v41);
    v13 = &loc_804F043;
    if ( v28 )
      v13 = &loc_804F0D5;
    dword_806B310 = (int)v13;
    sub_8061877();
    v14 = n;
    if ( v37 <= n )
      v14 = v37;
    v15 = memcmp(dest, &dest[n], v14);
    v28 = v15;
    v16 = v15 == 0;
    v17 = &loc_804F0A2;
    if ( !v16 )
      v17 = &loc_804F0D5;
    dword_806B20C = (int)v17;
    sub_8061E55();
    v28 = (n > v37) - (n < v37);
  }
  v44 = n;
  src = dest;
  v45 = v37;
  s = &dest[n];
  sub_8056451(dest, n, (int)&v40);
  sub_8056178(&v40, &s1);
  sub_8056451(s, v45, (int)&v41);
  sub_8056178((int *)&v41, &v39);
  v18 = memcmp(&s1, &v39, 0x10u);
  v32 = v18;
  v16 = v18 == 0;
  v21 = &loc_804F1A0;
  if ( !v16 )
    v21 = &loc_804F20C;
  dword_806B35C = (int)v21;
  sub_80616AA(v20, v19);
  if ( !v28 )
  {
    v22 = v44;
    if ( v45 <= v44 )
      v22 = v45;
    v28 = memcmp(src, s, v22);
    if ( !v28 )
      v28 = (v44 > v45) - (v44 < v45);
  }
  v32 = v28;
  free(ptr);
  v23 = (int (*)())&loc_804F245;
  if ( __readgsdword(0x14u) == v43 )
    v23 = sub_804F24A;
  dword_806B2C0 = (int)v23;
  sub_8061A43();
}
// 804F24A: using guessed type int sub_804F24A();
// 80616AA: using guessed type int __fastcall sub_80616AA(_DWORD, _DWORD);
// 8061877: using guessed type int sub_8061877(void);
// 80618E9: using guessed type int __fastcall sub_80618E9(_DWORD, _DWORD);
// 8061A43: using guessed type int sub_8061A43(void);
// 8061B2F: using guessed type int __fastcall sub_8061B2F(_DWORD, _DWORD);
// 8061DE3: using guessed type int __fastcall sub_8061DE3(_DWORD, _DWORD);
// 8061E55: using guessed type int sub_8061E55(void);
// 806B20C: using guessed type int dword_806B20C;
// 806B220: using guessed type int dword_806B220;
// 806B298: using guessed type int dword_806B298;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B2FC: using guessed type int dword_806B2FC;
// 806B310: using guessed type int dword_806B310;
// 806B324: using guessed type int dword_806B324;
// 806B35C: using guessed type int dword_806B35C;
// 806BE39: using guessed type char byte_806BE39;

//----- (0804F24A) --------------------------------------------------------
#error "804F250: positive sp value has been found (funcsize=0)"

//----- (0804F255) --------------------------------------------------------
int __cdecl sub_804F255(char *a1, unsigned int a2)
{
  int v2; // edx
  int v3; // ecx
  char *v4; // eax
  int result; // eax
  int v6; // [esp+1Ch] [ebp-Ch]
  unsigned int v7; // [esp+30h] [ebp+8h]

  v6 = sub_805975D(a1, a2 - (_DWORD)a1, 0);
  dword_806B348 = (int (__cdecl *)(_DWORD))&loc_804F2BB;
  dword_806B2FC = (int)&loc_805F7D4;
  sub_80618E9(v3, v2);
  v4 = a1;
  v7 = (unsigned int)(a1 + 1);
  v6 += *v4 == 9;
  dword_806B348 = (int (__cdecl *)(_DWORD))&loc_804F2A4;
  if ( v7 < a2 )
    result = dword_806B348(v7);
  else
    result = v6;
  return result;
}
// 80618E9: using guessed type int __fastcall sub_80618E9(_DWORD, _DWORD);
// 806B2FC: using guessed type int dword_806B2FC;
// 806B348: using guessed type int (__cdecl *dword_806B348)(_DWORD);

//----- (0804F2DA) --------------------------------------------------------
int __cdecl sub_804F2DA(int a1, int a2)
{
  int v2; // eax
  char *v3; // eax
  int result; // eax

  while ( 1 )
  {
    v2 = a1--;
    if ( !v2 )
      break;
    putchar_unlocked(32);
  }
  if ( a2 )
  {
    do
    {
      putchar_unlocked(95);
      --a2;
    }
    while ( a2 );
    result = putchar_unlocked(10);
  }
  else
  {
    v3 = gettext("^ no match for key\n");
    result = printf(v3);
  }
  return result;
}

//----- (0804F33B) --------------------------------------------------------
int __cdecl sub_804F33B(_BYTE *a1)
{
  if ( a1[26] || a1[28] || a1[29] )
  {
    dword_806B2C0 = (int)&loc_804F380;
    sub_8061A43();
  }
  return 0;
}
// 8061A43: using guessed type int sub_8061A43(void);
// 806B2C0: using guessed type int dword_806B2C0;

//----- (0804F385) --------------------------------------------------------
int __cdecl sub_804F385(int a1, int a2)
{
  bool v2; // zf
  void *v3; // eax
  int v4; // edx
  int v5; // ecx
  void *v6; // eax
  int v7; // edx
  int v8; // ecx
  int v9; // edx
  int v10; // ecx
  void *v11; // eax
  unsigned __int8 *v12; // edx
  int v13; // ecx
  int v15; // [esp+0h] [ebp-48h]
  unsigned __int8 v16; // [esp+11h] [ebp-37h]
  unsigned __int8 v17; // [esp+12h] [ebp-36h]
  unsigned __int8 v18; // [esp+13h] [ebp-35h]
  unsigned __int8 *v19; // [esp+14h] [ebp-34h]
  char *v20; // [esp+18h] [ebp-30h]
  unsigned __int8 *v21; // [esp+1Ch] [ebp-2Ch]
  unsigned __int8 *v22; // [esp+20h] [ebp-28h]
  char *v23; // [esp+24h] [ebp-24h]
  int v24; // [esp+28h] [ebp-20h]
  int v25; // [esp+2Ch] [ebp-1Ch]
  long double v26; // [esp+30h] [ebp-18h]

  v23 = *(char **)a1;
  v21 = (unsigned __int8 *)v23;
  v22 = (unsigned __int8 *)&v23[*(_DWORD *)(a1 + 4) - 1];
  if ( a2 )
  {
    if ( *(_DWORD *)a2 != -1 )
      v21 = (unsigned __int8 *)sub_804DC58((char **)a1, a2);
    if ( *(_DWORD *)(a2 + 8) != -1 )
      v22 = sub_804DE01(a1, a2);
    if ( (!*(_BYTE *)(a2 + 24) || *(_DWORD *)a2 != -1) && !*(_BYTE *)(a2 + 30) )
    {
      v2 = (unsigned __int8)sub_804F33B((_BYTE *)a2) == 0;
      v3 = &loc_804F43B;
      if ( v2 )
        v3 = &loc_804F622;
      dword_806B2C0 = (int)v3;
      sub_8061A43();
    }
    v16 = *v22;
    *v22 = 0;
    dword_806B2D4 = (int)&loc_804F465;
    sub_80619CB();
    do
      v15 = (char)*++v21;
    while ( byte_806BE51[(unsigned __int8)sub_804B939(v15)] );
    v19 = v21;
    if ( v22 < v21 )
    {
      v19 = v22;
      dword_806B220 = (int)&loc_804F613;
      sub_8061DE3(v5, v4);
    }
    if ( *(_BYTE *)(a2 + 30) )
    {
      sub_804E891(v21, &v19);
    }
    else if ( *(_BYTE *)(a2 + 28) )
    {
      v26 = strtold(v21, &v19);
    }
    else
    {
      v6 = &loc_804F51A;
      if ( *(_BYTE *)(a2 + 26) )
        v6 = &loc_804F529;
      dword_806B324 = (int)v6;
      sub_8061801(v5, v4, v15);
      if ( *(_BYTE *)(a2 + 29) )
      {
        if ( v21 < v22 && *v21 == 45 )
        {
          dword_806B2AC = (int)&loc_804F55C;
          sub_8061AB5(v8, v7);
        }
        v20 = (char *)v21;
        v17 = sub_804E44F(0, v8, &v20);
        if ( v17 > 0x2Fu )
        {
          v18 = *v20;
          v11 = &loc_804F5AA;
          if ( !*(_BYTE *)(a2 + 29) )
            v11 = &loc_804F5D5;
          dword_806B35C = (int)v11;
          sub_80616AA(v10, v20);
          if ( byte_8063750[v18] )
          {
            dword_806B2D4 = (int)&loc_804F5DA;
            sub_80619CB();
          }
          v19 = v12;
          dword_806B220 = (int)&loc_804F613;
          sub_8061DE3(v13, v12);
        }
        dword_806B220 = (int)&loc_804F613;
        sub_8061DE3(v10, v9);
      }
      v19 = v22;
    }
    *v22 = v16;
    v22 = v19;
  }
  v24 = sub_804F255(v23, (unsigned int)v21);
  v25 = sub_804F255((char *)v21, (unsigned int)v22);
  return sub_804F2DA(v24, v25);
}
// 804F385: could not find valid save-restore pair for ebx
// 80498F0: using guessed type double __cdecl strtold(_DWORD, _DWORD);
// 80616AA: using guessed type int __fastcall sub_80616AA(_DWORD, _DWORD);
// 80619CB: using guessed type int sub_80619CB(void);
// 8061A43: using guessed type int sub_8061A43(void);
// 8061AB5: using guessed type int __fastcall sub_8061AB5(_DWORD, _DWORD);
// 8061DE3: using guessed type int __fastcall sub_8061DE3(_DWORD, _DWORD);
// 806B220: using guessed type int dword_806B220;
// 806B2AC: using guessed type int dword_806B2AC;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B2D4: using guessed type int dword_806B2D4;
// 806B324: using guessed type int dword_806B324;
// 806B35C: using guessed type int dword_806B35C;

//----- (0804F660) --------------------------------------------------------
int __cdecl sub_804F660(int a1)
{
  int result; // eax
  int v2; // [esp+1Ch] [ebp-Ch]

  v2 = dword_806C265;
  while ( 1 )
  {
    result = sub_804F385(a1, v2);
    if ( !v2 )
      break;
    v2 = *(_DWORD *)(v2 + 36);
    if ( !v2 )
    {
      result = (unsigned __int8)byte_806C263 ^ 1;
      if ( byte_806C263 == 1 )
        break;
      result = (unsigned __int8)byte_806C262 ^ 1;
      if ( byte_806C262 == 1 )
        break;
    }
  }
  return result;
}
// 806C262: using guessed type char byte_806C262;
// 806C263: using guessed type char byte_806C263;
// 806C265: using guessed type int dword_806C265;

//----- (0804F6B3) --------------------------------------------------------
int __cdecl sub_804F6B3(int a1)
{
  void *v1; // eax
  int v2; // edx
  int v3; // ecx
  void *v4; // eax
  bool v5; // zf
  int v6; // edx
  int v7; // ecx
  void *v8; // eax
  int v9; // edx
  int v10; // ecx
  void *v11; // eax
  void *v12; // eax
  void *v13; // eax
  int v14; // edx
  int v15; // ecx

  if ( !*(_DWORD *)(a1 + 16) && !*(_DWORD *)(a1 + 20) )
  {
    v1 = &loc_804F6FC;
    if ( *(_BYTE *)(a1 + 24) == 1 )
      v1 = &loc_804F7DF;
    dword_806B370 = (int)v1;
    sub_8061638();
    v4 = &loc_804F723;
    if ( *(_BYTE *)(a1 + 25) == 1 )
      v4 = &loc_804F7DF;
    dword_806B2AC = (int)v4;
    sub_8061AB5(v3, v2);
    v5 = (unsigned __int8)sub_804F33B((_BYTE *)a1) == 1;
    v8 = &loc_804F74E;
    if ( v5 )
      v8 = &loc_804F7DF;
    dword_806B298 = (int)v8;
    sub_8061B2F(v7, v6);
    v11 = &loc_804F775;
    if ( *(_BYTE *)(a1 + 30) == 1 )
      v11 = &loc_804F7DF;
    dword_806B338 = (int)v11;
    sub_8061791(v10, v9);
    v12 = &loc_804F79C;
    if ( *(_BYTE *)(a1 + 32) == 1 )
      v12 = &loc_804F7DF;
    dword_806B370 = (int)v12;
    sub_8061638();
    v13 = &loc_804F7C3;
    if ( *(_BYTE *)(a1 + 27) == 1 )
      v13 = &loc_804F7DF;
    dword_806B370 = (int)v13;
    sub_8061638();
    dword_806B338 = (int)&loc_804F7E4;
    sub_8061791(v15, v14);
  }
  return 0;
}
// 804F6B3: could not find valid save-restore pair for ebx
// 8061638: using guessed type int sub_8061638(void);
// 8061791: using guessed type int __fastcall sub_8061791(_DWORD, _DWORD);
// 8061AB5: using guessed type int __fastcall sub_8061AB5(_DWORD, _DWORD);
// 8061B2F: using guessed type int __fastcall sub_8061B2F(_DWORD, _DWORD);
// 806B298: using guessed type int dword_806B298;
// 806B2AC: using guessed type int dword_806B2AC;
// 806B338: using guessed type int dword_806B338;
// 806B370: using guessed type int dword_806B370;

//----- (0804F7E9) --------------------------------------------------------
_BYTE *__usercall sub_804F7E9@<eax>(int a1@<edx>, int a2@<ecx>, int a3, _BYTE *a4)
{
  _BYTE *v4; // eax
  _BYTE *v5; // eax
  _BYTE *v6; // eax
  void *v7; // eax
  _BYTE *v8; // eax
  _BYTE *v9; // eax
  _BYTE *v10; // eax
  _BYTE *v11; // eax
  _BYTE *v12; // eax
  _BYTE *v13; // eax
  _BYTE *v14; // eax
  _BYTE *v15; // eax
  _BYTE *result; // eax
  _BYTE *v17; // [esp+Ch] [ebp+Ch]

  if ( *(_BYTE *)(a3 + 24) || *(_BYTE *)(a3 + 25) )
  {
    v4 = a4;
    a1 = (int)(a4++ + 1);
    *v4 = 98;
  }
  if ( *(_UNKNOWN **)(a3 + 16) == &unk_806C051 )
  {
    v5 = a4;
    a1 = (int)(a4++ + 1);
    *v5 = 100;
  }
  if ( *(_DWORD *)(a3 + 20) )
  {
    v6 = a4;
    a1 = (int)(a4++ + 1);
    *v6 = 102;
  }
  v7 = &loc_804F861;
  if ( !*(_BYTE *)(a3 + 28) )
    v7 = &loc_804F86D;
  dword_806B25C = (int)v7;
  sub_8061C89(a2, a1);
  v8 = a4;
  v17 = a4 + 1;
  *v8 = 103;
  if ( *(_BYTE *)(a3 + 29) )
  {
    v9 = v17++;
    *v9 = 104;
  }
  if ( *(_UNKNOWN **)(a3 + 16) == &unk_806BF51 )
  {
    v10 = v17++;
    *v10 = 105;
  }
  if ( *(_BYTE *)(a3 + 30) )
  {
    v11 = v17++;
    *v11 = 77;
  }
  if ( *(_BYTE *)(a3 + 26) )
  {
    v12 = v17++;
    *v12 = 110;
  }
  if ( *(_BYTE *)(a3 + 27) )
  {
    v13 = v17++;
    *v13 = 82;
  }
  if ( *(_BYTE *)(a3 + 31) )
  {
    v14 = v17++;
    *v14 = 114;
  }
  if ( *(_BYTE *)(a3 + 32) )
  {
    v15 = v17++;
    *v15 = 86;
  }
  result = v17;
  *v17 = 0;
  return result;
}
// 8061C89: using guessed type int __fastcall sub_8061C89(_DWORD, _DWORD);
// 806B25C: using guessed type int dword_806B25C;

//----- (0804F918) --------------------------------------------------------
unsigned int __cdecl sub_804F918(int *a1)
{
  void *v1; // eax
  int v2; // edx
  int v3; // ecx
  size_t v4; // eax
  int v5; // eax
  char *v6; // eax
  void *v7; // eax
  int v8; // edx
  int v9; // ecx
  void *v10; // eax
  char *v11; // eax
  char v13; // [esp+23h] [ebp-A5h]
  int v14; // [esp+44h] [ebp-84h]
  int v15; // [esp+48h] [ebp-80h]
  int v16; // [esp+4Ch] [ebp-7Ch]
  int v17; // [esp+50h] [ebp-78h]
  int v18; // [esp+54h] [ebp-74h]
  int v19; // [esp+58h] [ebp-70h]
  int v20; // [esp+5Ch] [ebp-6Ch]
  int v21; // [esp+60h] [ebp-68h]
  int v22; // [esp+64h] [ebp-64h]
  int v23; // [esp+68h] [ebp-60h]
  char s; // [esp+9Dh] [ebp-2Bh]
  unsigned int v25; // [esp+BCh] [ebp-Ch]

  v25 = __readgsdword(0x14u);
  v14 = *a1;
  v15 = a1[1];
  v16 = a1[2];
  v17 = a1[3];
  v18 = a1[4];
  v19 = a1[5];
  v20 = a1[6];
  v21 = a1[7];
  v22 = a1[8];
  v23 = a1[9];
  v1 = &loc_804FFDE;
  if ( dword_806C265 )
    v1 = &loc_804F99E;
  dword_806B20C = (int)v1;
  sub_8061E55();
  if ( (unsigned __int8)sub_804F6B3((int)&v14) ^ 1 || HIBYTE(v21) && (byte_806C262 || byte_806C263) && dword_806C265 )
  {
    v13 = HIBYTE(v21);
    if ( byte_806C262 != 1 && byte_806C263 != 1 )
      HIBYTE(v21) = 0;
    sub_804F7E9(v2, v3, (int)&v14, &s);
    v4 = strlen(&s);
    v5 = sub_804B9BC(v4);
    v6 = ngettext("option '-%s' is ignored", "options '-%s' are ignored", v5);
    error(0, 0, v6, &s);
    HIBYTE(v21) = v13;
  }
  if ( HIBYTE(v21) && byte_806C262 != 1 )
  {
    v7 = &loc_80500FF;
    if ( byte_806C263 == 1 )
      v7 = &loc_8050145;
    dword_806B2FC = (int)v7;
    sub_80618E9(v3, v2);
    v10 = &loc_8050121;
    if ( !dword_806C265 )
      v10 = &loc_8050145;
    dword_806B338 = (int)v10;
    sub_8061791(v9, v8);
    v11 = gettext("option '-r' only applies to last-resort comparison");
    error(0, 0, v11);
  }
  return __readgsdword(0x14u) ^ v25;
}
// 8061791: using guessed type int __fastcall sub_8061791(_DWORD, _DWORD);
// 80618E9: using guessed type int __fastcall sub_80618E9(_DWORD, _DWORD);
// 8061E55: using guessed type int sub_8061E55(void);
// 806B20C: using guessed type int dword_806B20C;
// 806B2FC: using guessed type int dword_806B2FC;
// 806B338: using guessed type int dword_806B338;
// 806C262: using guessed type char byte_806C262;
// 806C263: using guessed type char byte_806C263;
// 806C265: using guessed type int dword_806C265;

//----- (08050160) --------------------------------------------------------
int __cdecl __noreturn sub_8050160(int a1, int a2)
{
  void *v2; // eax
  _BYTE *v3; // eax
  int v4; // edx
  int v5; // ecx
  void *v6; // eax
  int v7; // edx
  int v8; // ecx
  void *v9; // eax
  int v10; // ecx
  int v11; // ecx
  size_t v12; // eax
  char *v13; // ebx
  char v14; // al
  char *v15; // edx
  unsigned __int8 v16; // al
  size_t v17; // eax
  char *v18; // ebx
  int v19; // edx
  int v20; // eax
  int v21; // ecx
  int v22; // ebx
  void *v23; // eax
  unsigned __int8 v24; // al
  int v25; // ecx
  int v26; // edx
  bool v27; // zf
  void *v28; // eax
  unsigned __int8 v29; // al
  int v30; // ebx
  unsigned __int8 v31; // al
  unsigned __int8 v32; // al
  int v33; // edx
  int v34; // ecx
  void *v35; // eax
  int v36; // edx
  int v37; // ecx
  unsigned __int8 v38; // al
  unsigned __int8 v39; // al
  int v40; // ebx
  void *v41; // eax
  int v42; // eax
  void *v43; // eax
  int v44; // edx
  void *v45; // eax
  int v46; // ecx
  unsigned int v47; // et1
  int (*v48)(); // eax
  int v50; // [esp+0h] [ebp-1018h]
  int v51; // [esp+18h] [ebp-1000h]
  int v52; // [esp+1Ch] [ebp-FFCh]
  char v53; // [esp+26h] [ebp-FF2h]
  char v54; // [esp+27h] [ebp-FF1h]
  int v55; // [esp+28h] [ebp-FF0h]
  void *s1; // [esp+2Ch] [ebp-FECh]
  void *s2; // [esp+30h] [ebp-FE8h]
  unsigned int v58; // [esp+34h] [ebp-FE4h]
  unsigned int v59; // [esp+38h] [ebp-FE0h]
  int v60; // [esp+3Ch] [ebp-FDCh]
  char *v61; // [esp+40h] [ebp-FD8h]
  char *v62; // [esp+44h] [ebp-FD4h]
  size_t v63; // [esp+48h] [ebp-FD0h]
  size_t v64; // [esp+4Ch] [ebp-FCCh]
  void *ptr; // [esp+50h] [ebp-FC8h]
  size_t v66; // [esp+54h] [ebp-FC4h]
  int v67; // [esp+58h] [ebp-FC0h]
  int v68; // [esp+5Ch] [ebp-FBCh]
  unsigned int v69; // [esp+60h] [ebp-FB8h]
  size_t n; // [esp+64h] [ebp-FB4h]
  size_t size; // [esp+68h] [ebp-FB0h]
  char v72; // [esp+6Ch] [ebp-FACh]
  unsigned int v73; // [esp+100Ch] [ebp-Ch]

  v52 = a1;
  v51 = a2;
  v73 = __readgsdword(0x14u);
  v55 = dword_806C265;
  s1 = *(void **)(a1 + 8);
  s2 = *(void **)(a2 + 8);
  v58 = *(_DWORD *)(a1 + 12);
  v59 = *(_DWORD *)(a2 + 12);
  v67 = *(_DWORD *)(dword_806C265 + 20);
  v68 = *(_DWORD *)(dword_806C265 + 16);
  v2 = s1;
  if ( v58 >= (unsigned int)s1 )
    v2 = (void *)v58;
  v58 = (unsigned int)v2;
  v3 = s2;
  if ( v59 >= (unsigned int)s2 )
    v3 = (_BYTE *)v59;
  v59 = (unsigned int)v3;
  v69 = v58 - (_DWORD)s1;
  n = v3 - (_BYTE *)s2;
  if ( byte_806BE39
    || (unsigned __int8)sub_804F33B((_BYTE *)v55)
    || *(_BYTE *)(v55 + 30)
    || *(_BYTE *)(v55 + 27)
    || *(_BYTE *)(v55 + 32) )
  {
    v6 = &loc_80502B7;
    if ( v68 )
      v6 = &loc_80502D9;
    dword_806B310 = (int)v6;
    sub_8061877();
    v9 = &loc_80502D9;
    if ( !v67 )
      v9 = &loc_805054A;
    dword_806B2AC = (int)v9;
    sub_8061AB5(v8, v7);
    size = v69 + n + 2;
    if ( size <= 0xFA0 )
    {
      v61 = &v72;
      ptr = 0;
      dword_806B324 = (int)&loc_8050349;
      sub_8061801(v10, v69, v50);
    }
    ptr = sub_805E4FC(size);
    v61 = (char *)ptr;
    v62 = (char *)ptr + v69 + 1;
    v66 = 0;
    v63 = 0;
    while ( v66 < v69 )
    {
      if ( !v68 || *(_BYTE *)((unsigned __int8)sub_804B939(*((_BYTE *)s1 + v66)) + v68) ^ 1 )
      {
        v12 = v63++;
        v13 = &v61[v12];
        if ( v67 )
          v14 = *(_BYTE *)((unsigned __int8)sub_804B939(*((_BYTE *)s1 + v66)) + v67);
        else
          v14 = *((_BYTE *)s1 + v66);
        *v13 = v14;
      }
      ++v66;
    }
    v15 = v61;
    v61[v63] = 0;
    v66 = 0;
    v64 = 0;
    dword_806B298 = (int)&loc_8050522;
    sub_8061B2F(v11, v15);
    do
    {
      if ( !v68 || (v50 = *((char *)s2 + v66), v16 = sub_804B939(v50), *(_BYTE *)(v16 + v68) ^ 1) )
      {
        v17 = v64++;
        v18 = &v62[v17];
        if ( v67 )
        {
          v50 = *((char *)s2 + v66);
          v19 = (unsigned __int8)sub_804B939(v50);
          v20 = *(unsigned __int8 *)(v19 + v67);
          dword_806B270 = (int)&loc_8050519;
          sub_8061C11(v21, v19);
        }
        *v18 = *((_BYTE *)s2 + v66);
      }
      ++v66;
    }
    while ( v66 < n );
    v62[v64] = 0;
    if ( *(_BYTE *)(v55 + 26) )
    {
      v60 = sub_804E679((unsigned __int8 *)v61, (unsigned __int8 *)v62);
    }
    else if ( *(_BYTE *)(v55 + 28) )
    {
      v60 = sub_804E774((int)v61, (int)v62);
    }
    else if ( *(_BYTE *)(v55 + 29) )
    {
      v60 = sub_804E5BA((unsigned __int8 *)v61, (unsigned __int8 *)v62);
    }
    else
    {
      if ( !*(_BYTE *)(v55 + 30) )
      {
        v23 = &loc_80506CF;
        if ( !*(_BYTE *)(v55 + 27) )
          v23 = &loc_8050706;
        dword_806B370 = (int)v23;
        sub_8061638();
        sub_804EBDC((int)v61, v63, (int)v62, v64);
      }
      v22 = sub_804E891((unsigned __int8 *)v61, 0);
      v60 = v22 - sub_804E891((unsigned __int8 *)v62, 0);
    }
    if ( v68 || v67 )
    {
      free(ptr);
    }
    else
    {
      v61[v63] = v53;
      v62[v64] = v54;
    }
  }
  else
  {
    if ( v68 )
    {
      if ( v67 )
      {
        while ( 1 )
        {
          while ( (unsigned int)s1 < v58 && *(_BYTE *)((unsigned __int8)sub_804B939(*(_BYTE *)s1) + v68) )
            s1 = (char *)s1 + 1;
          if ( (unsigned int)s2 < v59 )
          {
            v24 = sub_804B939(*(_BYTE *)s2);
            v26 = v24;
            v27 = *(_BYTE *)(v24 + v68) == 0;
            v28 = &loc_80508C2;
            if ( !v27 )
              v28 = &loc_805086E;
            dword_806B2AC = (int)v28;
            sub_8061AB5(v25, v26);
          }
          if ( (unsigned int)s1 >= v58 || (unsigned int)s2 >= v59 )
            break;
          v29 = sub_804B939(*(_BYTE *)s1);
          v30 = (unsigned __int8)sub_804B939(*(_BYTE *)(v29 + v67));
          v31 = sub_804B939(*(_BYTE *)s2);
          v32 = sub_804B939(*(_BYTE *)(v31 + v67));
          v60 = v30 - v32;
          v27 = v30 == v32;
          v35 = &loc_8050972;
          if ( v27 )
            v35 = &loc_8050989;
          dword_806B324 = (int)v35;
          sub_8061801(v34, v33, v50);
          dword_806B338 = (int)&loc_8050EAF;
          sub_8061791(v37, v36);
          s1 = (char *)s1 + 1;
          s2 = (char *)s2 + 1;
        }
        v60 = ((unsigned int)s1 < v58) - ((unsigned int)s2 < v59);
        dword_806B284 = (int)&loc_8050CC5;
        sub_8061B9D();
      }
      while ( 1 )
      {
        while ( (unsigned int)s1 < v58 )
        {
          v50 = *(char *)s1;
          v38 = sub_804B939(v50);
          if ( !*(_BYTE *)(v38 + v68) )
            break;
          s1 = (char *)s1 + 1;
        }
        while ( (unsigned int)s2 < v59 )
        {
          v50 = *(char *)s2;
          v39 = sub_804B939(v50);
          if ( !*(_BYTE *)(v39 + v68) )
            break;
          s2 = (char *)s2 + 1;
        }
        if ( (unsigned int)s1 >= v58 || (unsigned int)s2 >= v59 )
          break;
        v50 = *(char *)s1;
        v40 = (unsigned __int8)sub_804B939(v50);
        v50 = *(char *)s2;
        v60 = v40 - (unsigned __int8)sub_804B939(v50);
        if ( v60 )
          goto LABEL_86;
        s1 = (char *)s1 + 1;
        s2 = (char *)s2 + 1;
      }
      v60 = ((unsigned int)s1 < v58) - ((unsigned int)s2 < v59);
      dword_806B370 = (int)&loc_8050CC5;
      sub_8061638();
    }
    if ( v69 )
    {
      v41 = &loc_8050B5A;
      if ( n )
        v41 = &loc_8050B69;
      dword_806B35C = (int)v41;
      sub_80616AA(v5, v4);
      v60 = 1;
      goto LABEL_86;
    }
    v60 = -(n != 0);
  }
  if ( !v60 )
  {
    v42 = *(_DWORD *)(v55 + 36);
    v55 = v42;
    v27 = v42 == 0;
    v43 = &loc_8050D04;
    if ( !v27 )
      v43 = &loc_8050D0E;
    dword_806B20C = (int)v43;
    sub_8061E55();
    goto LABEL_89;
  }
LABEL_86:
  v45 = &loc_8050ED6;
  if ( !*(_BYTE *)(v55 + 31) )
    v45 = &loc_8050EE0;
  dword_806B2D4 = (int)v45;
  sub_80619CB();
LABEL_89:
  v47 = __readgsdword(0x14u);
  v46 = v47 ^ v73;
  v48 = (int (*)())&loc_8050F0B;
  if ( v47 == v73 )
    v48 = sub_8050F10;
  dword_806B220 = (int)v48;
  return sub_8061DE3(v46, v44);
}
// 8050F10: using guessed type int sub_8050F10();
// 8061638: using guessed type int sub_8061638(void);
// 80616AA: using guessed type int __fastcall sub_80616AA(_DWORD, _DWORD);
// 8061791: using guessed type int __fastcall sub_8061791(_DWORD, _DWORD);
// 8061877: using guessed type int sub_8061877(void);
// 80619CB: using guessed type int sub_80619CB(void);
// 8061AB5: using guessed type int __fastcall sub_8061AB5(_DWORD, _DWORD);
// 8061B2F: using guessed type int __fastcall sub_8061B2F(_DWORD, _DWORD);
// 8061B9D: using guessed type int sub_8061B9D(void);
// 8061C11: using guessed type int __fastcall sub_8061C11(_DWORD, _DWORD);
// 8061DE3: using guessed type int __fastcall sub_8061DE3(_DWORD, _DWORD);
// 8061E55: using guessed type int sub_8061E55(void);
// 806B20C: using guessed type int dword_806B20C;
// 806B220: using guessed type int dword_806B220;
// 806B270: using guessed type int dword_806B270;
// 806B284: using guessed type int dword_806B284;
// 806B298: using guessed type int dword_806B298;
// 806B2AC: using guessed type int dword_806B2AC;
// 806B2D4: using guessed type int dword_806B2D4;
// 806B310: using guessed type int dword_806B310;
// 806B324: using guessed type int dword_806B324;
// 806B338: using guessed type int dword_806B338;
// 806B35C: using guessed type int dword_806B35C;
// 806B370: using guessed type int dword_806B370;
// 806BE39: using guessed type char byte_806BE39;
// 806C265: using guessed type int dword_806C265;

//----- (08050F10) --------------------------------------------------------
#error "8050F16: positive sp value has been found (funcsize=0)"

//----- (08050F19) --------------------------------------------------------
int __usercall sub_8050F19@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4)
{
  size_t v4; // eax
  signed int v5; // eax
  int v7; // [esp+0h] [ebp-28h]
  int v8; // [esp+14h] [ebp-14h]
  unsigned int v9; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]

  if ( dword_806C265 )
    sub_8050160(a3, a4);
  v9 = *(_DWORD *)(a3 + 4) - 1;
  n = *(_DWORD *)(a4 + 4) - 1;
  if ( *(_DWORD *)(a3 + 4) == 1 )
  {
    v8 = -(*(_DWORD *)(a4 + 4) != 1);
  }
  else if ( *(_DWORD *)(a4 + 4) == 1 )
  {
    v8 = 1;
  }
  else if ( byte_806BE39 )
  {
    v8 = sub_805E7F3(*(void **)a3, *(_DWORD *)(a3 + 4), *(void **)a4, *(_DWORD *)(a4 + 4));
  }
  else
  {
    v4 = *(_DWORD *)(a3 + 4) - 1;
    if ( n <= v9 )
      v4 = *(_DWORD *)(a4 + 4) - 1;
    v8 = memcmp(*(const void **)a3, *(const void **)a4, v4);
    if ( !v8 )
    {
      if ( v9 < n )
        v5 = -1;
      else
        v5 = v9 != n;
      v8 = v5;
    }
  }
  if ( byte_806C261 )
  {
    dword_806B324 = (int)&loc_8051057;
    sub_8061801(a2, a1, v7);
  }
  return v8;
}
// 806B324: using guessed type int dword_806B324;
// 806BE39: using guessed type char byte_806BE39;
// 806C261: using guessed type char byte_806C261;
// 806C265: using guessed type int dword_806C265;

//----- (0805105D) --------------------------------------------------------
int __cdecl sub_805105D(int a1, FILE *stream, int a3)
{
  char *v3; // eax
  char *v4; // eax
  int v5; // ecx
  int result; // eax
  char *v7; // eax
  int v8; // ecx
  char v9; // [esp+1Fh] [ebp-19h]
  char *v10; // [esp+20h] [ebp-18h]
  char *ptr; // [esp+24h] [ebp-14h]
  size_t n; // [esp+28h] [ebp-10h]
  unsigned int v13; // [esp+2Ch] [ebp-Ch]

  ptr = *(char **)a1;
  n = *(_DWORD *)(a1 + 4);
  v13 = *(_DWORD *)a1 + n;
  if ( a3 || !byte_806C26D )
  {
    *(_BYTE *)(v13 - 1) = byte_806B3B8;
    if ( fwrite_unlocked(ptr, 1u, n, stream) != n )
    {
      v7 = gettext("write failed");
      sub_804BCE7(v8, a3, (int)v7, a3);
    }
    result = v13 - 1;
    *(_BYTE *)(v13 - 1) = 0;
  }
  else
  {
    v10 = *(char **)a1;
    while ( (unsigned int)v10 < v13 )
    {
      v3 = v10++;
      v9 = *v3;
      if ( *v3 == 9 )
      {
        v9 = 62;
      }
      else if ( v10 == (char *)v13 )
      {
        v9 = 10;
      }
      if ( fputc_unlocked(v9, stream) == -1 )
      {
        v4 = gettext("write failed");
        sub_804BCE7(v5, 0, (int)v4, 0);
      }
    }
    result = sub_804F660(a1);
  }
  return result;
}
// 806B3B8: using guessed type char byte_806B3B8;
// 806C26D: using guessed type char byte_806C26D;

//----- (08051166) --------------------------------------------------------
int __cdecl sub_8051166(char *a1, char a2)
{
  size_t v2; // eax
  int v3; // eax
  int v4; // ecx
  void *v5; // eax
  int v6; // ebx
  int v7; // edx
  int v8; // ecx
  int v9; // edx
  int v10; // ecx
  int v11; // eax
  int v12; // eax
  int v13; // ebx
  char *v14; // esi
  char *v15; // eax
  char *v16; // eax
  int v17; // edx
  int v18; // ecx
  int v19; // ebx
  __int64 v21; // [esp+0h] [ebp-B8h]
  char *v22; // [esp+8h] [ebp-B0h]
  char *v23; // [esp+Ch] [ebp-ACh]
  int v24; // [esp+10h] [ebp-A8h]
  char v25; // [esp+18h] [ebp-A0h]
  char *s1; // [esp+1Ch] [ebp-9Ch]
  unsigned __int8 v27; // [esp+2Eh] [ebp-8Ah]
  char v28[5]; // [esp+2Fh] [ebp-89h]
  unsigned int v29; // [esp+34h] [ebp-84h]
  FILE *stream; // [esp+38h] [ebp-80h]
  int v31; // [esp+3Ch] [ebp-7Ch]
  unsigned int v32; // [esp+40h] [ebp-78h]
  int v33; // [esp+44h] [ebp-74h]
  __int64 v34; // [esp+48h] [ebp-70h]
  __int64 v35; // [esp+50h] [ebp-68h]
  void *ptr; // [esp+58h] [ebp-60h]
  int v37; // [esp+5Ch] [ebp-5Ch]
  char *v38; // [esp+60h] [ebp-58h]
  char *v39; // [esp+64h] [ebp-54h]
  void *v40; // [esp+68h] [ebp-50h]
  unsigned int v41; // [esp+70h] [ebp-48h]
  char v42; // [esp+87h] [ebp-31h]
  unsigned int v43; // [esp+9Ch] [ebp-1Ch]

  s1 = a1;
  v25 = a2;
  v43 = __readgsdword(0x14u);
  stream = (FILE *)sub_804C778(a1, "r");
  *(_DWORD *)&v28[1] = 0;
  v34 = 0LL;
  v31 = dword_806C265;
  *(_DWORD *)v28 = byte_806C263 == 0;
  v28[0] &= 1u;
  v27 = 1;
  v2 = dword_806B438;
  if ( size >= dword_806B438 )
    v2 = size;
  sub_804DBB7((int)&v40, 16, v2);
  ptr = 0;
LABEL_20:
  v22 = s1;
  HIDWORD(v21) = stream;
  if ( (unsigned __int8)sub_804E01D((int)&v40) )
  {
    v3 = sub_804DC3D(&v40);
    v29 = v3;
    v32 = -16 * v41 + v3;
    v5 = &loc_805126C;
    if ( !*(_DWORD *)&v28[1] )
      v5 = &loc_805135C;
    dword_806B324 = (int)v5;
    sub_8061801(v4, -16 * v41, v21);
    v6 = (unsigned __int8)v28[0];
    if ( v6 > sub_8050F19(v7, v8, (int)&ptr, v29 - 16) )
    {
      dword_806B25C = (int)&loc_805139E;
      sub_8061C89(v10, v9);
      while ( 1 )
      {
        v19 = (unsigned __int8)v28[0];
        if ( v19 <= sub_8050F19(v17, v18, v29, v29 - 16) )
          break;
        v29 -= 16;
        if ( v29 <= v32 )
        {
          v34 += v41;
          if ( *(_DWORD *)(v29 + 4) > *(_DWORD *)&v28[1] )
          {
            while ( 1 )
            {
              *(_DWORD *)&v28[1] *= 2;
              if ( !*(_DWORD *)&v28[1] )
                break;
              if ( *(_DWORD *)(v29 + 4) <= *(_DWORD *)&v28[1] )
                goto LABEL_17;
            }
            *(_DWORD *)&v28[1] = *(_DWORD *)(v29 + 4);
LABEL_17:
            free(ptr);
            ptr = sub_805E4FC(*(size_t *)&v28[1]);
          }
          memcpy(ptr, *(const void **)v29, *(_DWORD *)(v29 + 4));
          v37 = *(_DWORD *)(v29 + 4);
          if ( v31 )
          {
            v38 = (char *)ptr + *(_DWORD *)(v29 + 8) - *(_DWORD *)v29;
            v39 = (char *)ptr + *(_DWORD *)(v29 + 12) - *(_DWORD *)v29;
          }
          goto LABEL_20;
        }
      }
    }
    if ( v25 == 99 )
    {
      v33 = v29 - 16;
      v11 = sub_804DC3D(&v40);
      v12 = (v11 - v33) >> 4;
      v35 = v12 + v34;
      v21 = v12 + v34;
      v13 = sub_80596AA(v21, (int)&v42);
      v14 = (char *)dword_806C3C1;
      v15 = gettext("%s: %s:%s: disorder: ");
      v24 = v13;
      v23 = s1;
      v22 = v14;
      fprintf(stderr, v15, v14, s1, v13);
      v16 = gettext("standard error");
      sub_805105D(v33, stderr, (int)v16);
    }
    v27 = 0;
  }
  sub_804C7CB(stream, (int)s1);
  free(v40);
  free(ptr);
  return v27;
}
// 8061C89: using guessed type int __fastcall sub_8061C89(_DWORD, _DWORD);
// 806B25C: using guessed type int dword_806B25C;
// 806B324: using guessed type int dword_806B324;
// 806C263: using guessed type char byte_806C263;
// 806C265: using guessed type int dword_806C265;
// 806C3C1: using guessed type int dword_806C3C1;

//----- (08051502) --------------------------------------------------------
unsigned int __cdecl sub_8051502(int a1, unsigned int a2, void **a3)
{
  int v3; // ecx
  FILE **v4; // ebx
  void *v5; // eax
  int v6; // ecx
  unsigned int i; // [esp+18h] [ebp-10h]
  _DWORD *v9; // [esp+1Ch] [ebp-Ch]

  *a3 = sub_805E3D6(a2, 4u);
  v9 = *a3;
  for ( i = 0; i < a2; ++i )
  {
    v4 = (FILE **)&v9[i];
    if ( *(_DWORD *)(8 * i + a1 + 4) )
    {
      v5 = &loc_8051590;
      if ( !*(_BYTE *)(*(_DWORD *)(8 * i + a1 + 4) + 8) )
        v5 = &loc_80515C1;
      dword_806B220 = (int)v5;
      v4 = (FILE **)&v9[i];
      sub_8061DE3(v3, 8 * i);
      sub_804CC11(8 * i, v6, *(_DWORD *)(8 * i + a1 + 4));
      dword_806B284 = (int)&loc_80515E2;
      sub_8061B9D();
    }
    *v4 = sub_804C623(*(char **)(8 * i + a1), "r");
    if ( !v9[i] )
    {
      dword_806B338 = (int)&loc_8051620;
      sub_8061791(v3, 4 * i);
    }
  }
  return i;
}
// 8061791: using guessed type int __fastcall sub_8061791(_DWORD, _DWORD);
// 8061B9D: using guessed type int sub_8061B9D(void);
// 8061DE3: using guessed type int __fastcall sub_8061DE3(_DWORD, _DWORD);
// 806B220: using guessed type int dword_806B220;
// 806B284: using guessed type int dword_806B284;
// 806B338: using guessed type int dword_806B338;

//----- (08051629) --------------------------------------------------------
void __cdecl sub_8051629(int a1, int a2, int a3, FILE *stream, int a5, void *a6)
{
  int v6; // edx
  int v7; // ecx
  size_t v8; // edx
  int v9; // edx
  int v10; // ecx
  int v11; // ecx
  _DWORD *v12; // ecx
  _DWORD *v13; // eax
  int v14; // edx
  int v15; // ecx
  int v16; // eax
  int v17; // edx
  void *v18; // eax
  int v19; // edx
  int v20; // ecx
  int v21; // edx
  int v22; // ebx
  bool v23; // zf
  int v24; // edx
  int v25; // ecx
  void *v26; // eax
  int v27; // eax
  void *v28; // eax
  char *v29; // [esp+0h] [ebp-78h]
  int v30; // [esp+4h] [ebp-74h]
  int v31; // [esp+8h] [ebp-70h]
  void **v32; // [esp+14h] [ebp-64h]
  size_t size; // [esp+18h] [ebp-60h]
  unsigned int i; // [esp+1Ch] [ebp-5Ch]
  unsigned int j; // [esp+20h] [ebp-58h]
  unsigned int v36; // [esp+24h] [ebp-54h]
  unsigned int v37; // [esp+28h] [ebp-50h]
  unsigned int v38; // [esp+2Ch] [ebp-4Ch]
  void *v39; // [esp+30h] [ebp-48h]
  void *v40; // [esp+34h] [ebp-44h]
  void *v41; // [esp+38h] [ebp-40h]
  void *v42; // [esp+3Ch] [ebp-3Ch]
  int v43; // [esp+40h] [ebp-38h]
  int v44; // [esp+44h] [ebp-34h]
  int v45; // [esp+48h] [ebp-30h]
  int v46; // [esp+4Ch] [ebp-2Ch]
  int v47; // [esp+50h] [ebp-28h]
  unsigned int v48; // [esp+54h] [ebp-24h]
  int v49; // [esp+58h] [ebp-20h]
  unsigned int v50; // [esp+5Ch] [ebp-1Ch]
  void *ptr; // [esp+60h] [ebp-18h]
  size_t n; // [esp+64h] [ebp-14h]
  char *v53; // [esp+68h] [ebp-10h]
  char *v54; // [esp+6Ch] [ebp-Ch]

  v39 = sub_805E3D6(a3, 0x1Cu);
  v32 = 0;
  size = 0;
  v40 = sub_805E3D6(a3, 4u);
  v41 = sub_805E3D6(a3, 4u);
  v42 = sub_805E3D6(a3, 4u);
  v43 = dword_806C265;
  ptr = 0;
  i = 0;
  dword_806B2FC = (int)&loc_80518B0;
  sub_80618E9(v7, v6);
  do
  {
    v8 = ::size / a3;
    if ( ::size / a3 < dword_806B438 )
      v8 = dword_806B438;
    sub_804DBB7((int)v39 + 28 * i, 16, v8);
    v9 = *((_DWORD *)a6 + i);
    v31 = *(_DWORD *)(8 * i + a1);
    v30 = v9;
    v29 = (char *)v39 + 28 * i;
    if ( (unsigned __int8)sub_804E01D((int)v29) )
    {
      v29 = (char *)v39 + 28 * i;
      v44 = sub_804DC3D(v29);
      *((_DWORD *)v40 + i) = v44 - 16;
      v10 = -16 * *((_DWORD *)v39 + 7 * i + 2);
      *((_DWORD *)v41 + i++) = v10 + v44;
    }
    else
    {
      sub_804C7CB(*((FILE **)a6 + i), *(_DWORD *)(8 * i + a1));
      if ( i < a2 )
      {
        --a2;
        sub_804CE70(8 * i, v11, *(char **)(8 * i + a1));
      }
      free(*((void **)v39 + 7 * i));
      --a3;
      j = i;
      dword_806B310 = (int)&loc_80518A8;
      sub_8061877();
      do
      {
        v12 = (_DWORD *)(8 * j + a1);
        v13 = (_DWORD *)(8 * (j + 1) + a1);
        v14 = v13[1];
        *v12 = *v13;
        v12[1] = v14;
        v10 = 4 * (j + 1);
        *((_DWORD *)a6 + j++) = *(_DWORD *)((char *)a6 + v10);
      }
      while ( j < a3 );
    }
  }
  while ( i < a3 );
  for ( i = 0; i < a3; ++i )
    *((_DWORD *)v42 + i) = i;
  for ( i = 1; i < a3; ++i )
  {
    v15 = 4 * *((_DWORD *)v42 + i + 0x3FFFFFFF);
    v16 = *(_DWORD *)((char *)v40 + v15);
    v30 = *((_DWORD *)v40 + *((_DWORD *)v42 + i));
    if ( sub_8050F19(v30, v15, v16, v30) > 0 )
    {
      v45 = *((_DWORD *)v42 + i + 0x3FFFFFFF);
      v10 = 4 * i;
      *((_DWORD *)v42 + i + 0x3FFFFFFF) = *((_DWORD *)v42 + i);
      *((_DWORD *)v42 + i) = v45;
      i = 0;
    }
  }
  while ( a3 )
  {
    v17 = 4 * *(_DWORD *)v42;
    v46 = *(_DWORD *)((char *)v40 + v17);
    if ( byte_806C263 )
    {
      if ( v32 && sub_8050F19(v17, v10, (int)v32, v46) )
      {
        v32 = 0;
        sub_805105D((int)&ptr, stream, a5);
      }
      v18 = &loc_8051A34;
      if ( v32 )
        v18 = &loc_8051B09;
      dword_806B310 = (int)v18;
      sub_8061877();
      v32 = &ptr;
      if ( *(_DWORD *)(v46 + 4) > size )
      {
        do
        {
          if ( !size )
          {
            size = *(_DWORD *)(v46 + 4);
            dword_806B2FC = (int)&loc_8051A79;
            sub_80618E9(v20, v19);
          }
          size *= 2;
        }
        while ( size < *(_DWORD *)(v46 + 4) );
        free(ptr);
        ptr = sub_805E4FC(size);
      }
      n = *(_DWORD *)(v46 + 4);
      memcpy(ptr, *(const void **)v46, n);
      if ( v43 )
      {
        v53 = (char *)ptr + *(_DWORD *)(v46 + 8) - *(_DWORD *)v46;
        v10 = *(_DWORD *)(v46 + 12) - *(_DWORD *)v46;
        v54 = (char *)ptr + v10;
      }
    }
    else
    {
      sub_805105D(v46, stream, a5);
    }
    if ( *((_DWORD *)v41 + *(_DWORD *)v42) >= (unsigned int)v46 )
    {
      v21 = *((_DWORD *)a6 + *(_DWORD *)v42);
      v22 = 28 * *(_DWORD *)v42;
      v31 = *(_DWORD *)(8 * *(_DWORD *)v42 + a1);
      v30 = v21;
      v23 = (unsigned __int8)sub_804E01D((int)v39 + v22) == 0;
      v26 = &loc_8051BA8;
      if ( v23 )
        v26 = &loc_8051C1F;
      dword_806B298 = (int)v26;
      sub_8061B2F(v25, v24);
      v29 = (char *)v39 + 28 * *(_DWORD *)v42;
      v47 = sub_804DC3D(v29);
      *((_DWORD *)v40 + *(_DWORD *)v42) = v47 - 16;
      v10 = -16 * *((_DWORD *)v39 + 7 * *(_DWORD *)v42 + 2);
      *((_DWORD *)v41 + *(_DWORD *)v42) = v10 + v47;
    }
    else
    {
      *((_DWORD *)v40 + *(_DWORD *)v42) = v46 - 16;
    }
    v36 = 1;
    v37 = a3;
    v38 = 1;
    v48 = *(_DWORD *)v42;
    while ( v36 < v37 )
    {
      v27 = *((_DWORD *)v40 + v48);
      v30 = *((_DWORD *)v40 + *((_DWORD *)v42 + v38));
      v49 = sub_8050F19(v30, 4 * v48, v27, v30);
      if ( v49 < 0 )
        goto LABEL_59;
      v28 = &loc_8051ED8;
      if ( v49 )
        v28 = &loc_8051EF6;
      dword_806B2C0 = (int)v28;
      sub_8061A43();
      if ( *((_DWORD *)v42 + v38) <= v48 )
        v36 = v38 + 1;
      else
LABEL_59:
        v37 = v38;
      v38 = (v36 + v37) >> 1;
    }
    v50 = v36 - 1;
    for ( j = 0; j < v50; ++j )
    {
      v10 = 4 * (j + 1);
      *((_DWORD *)v42 + j) = *(_DWORD *)((char *)v42 + v10);
    }
    *((_DWORD *)v42 + v50) = v48;
  }
  if ( byte_806C263 && v32 )
  {
    sub_805105D((int)&ptr, stream, a5);
    free(ptr);
  }
  sub_804C7CB(stream, a5);
  free(a6);
  free(v39);
  free(v42);
  free(v41);
  free(v40);
}
// 8061877: using guessed type int sub_8061877(void);
// 80618E9: using guessed type int __fastcall sub_80618E9(_DWORD, _DWORD);
// 8061A43: using guessed type int sub_8061A43(void);
// 8061B2F: using guessed type int __fastcall sub_8061B2F(_DWORD, _DWORD);
// 806B298: using guessed type int dword_806B298;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B2FC: using guessed type int dword_806B2FC;
// 806B310: using guessed type int dword_806B310;
// 806C263: using guessed type char byte_806C263;
// 806C265: using guessed type int dword_806C265;

//----- (08051FFD) --------------------------------------------------------
int __cdecl sub_8051FFD(int a1, int a2, int a3, FILE *stream, int a5)
{
  int v5; // ebx
  char *v6; // eax
  int v7; // edx
  int v8; // ecx
  void *v10; // [esp+28h] [ebp-10h]
  int v11; // [esp+2Ch] [ebp-Ch]

  v11 = sub_8051502(a1, a3, &v10);
  if ( v11 < (unsigned int)a3 && (unsigned int)v11 <= 1 )
  {
    v5 = *(_DWORD *)(8 * v11 + a1);
    v6 = gettext("open failed");
    sub_804BCE7(v8, v7, (int)v6, v5);
  }
  sub_8051629(a1, a2, v11, stream, a5, v10);
  return v11;
}

//----- (0805208E) --------------------------------------------------------
_DWORD *__cdecl sub_805208E(_DWORD *a1, unsigned int a2, _DWORD *a3)
{
  int v3; // ecx
  int v4; // edx
  int v5; // ecx
  int v6; // edx
  void *v7; // eax
  _DWORD *result; // eax
  unsigned int v9; // [esp+14h] [ebp-14h]
  _DWORD *v10; // [esp+1Ch] [ebp-Ch]
  _DWORD *v11; // [esp+30h] [ebp+8h]

  v9 = a2 >> 1;
  v10 = &a1[-4 * (a2 >> 1)];
  while ( sub_8050F19((int)(v10 - 4), v3, (int)(a3 - 4), (int)(v10 - 4)) <= 0 )
  {
    a1 -= 4;
    a3 -= 4;
    *a1 = *a3;
    a1[1] = a3[1];
    v3 = a3[2];
    a1[2] = v3;
    v4 = a3[3];
    a1[3] = v4;
    if ( !--v9 )
    {
      dword_806B270 = (int)&locret_805219C;
      sub_8061C11(v3, v4);
      break;
    }
  }
  v11 = a1 - 4;
  *v11 = *(v10 - 4);
  v11[1] = *(v10 - 3);
  v5 = *(v10 - 2);
  v11[2] = v5;
  v6 = *(v10 - 1);
  v11[3] = v6;
  v7 = &loc_8052167;
  if ( a2 - (a2 >> 1) != 1 )
    v7 = &loc_8052197;
  dword_806B338 = (int)v7;
  sub_8061791(v5, v6);
  do
  {
    v11 -= 4;
    a3 -= 4;
    result = v11;
    *v11 = *a3;
    v11[1] = a3[1];
    v11[2] = a3[2];
    v11[3] = a3[3];
    --v9;
  }
  while ( v9 );
  return result;
}
// 8061791: using guessed type int __fastcall sub_8061791(_DWORD, _DWORD);
// 8061C11: using guessed type int __fastcall sub_8061C11(_DWORD, _DWORD);
// 806B270: using guessed type int dword_806B270;
// 806B338: using guessed type int dword_806B338;

//----- (0805219E) --------------------------------------------------------
int __cdecl sub_805219E(_DWORD *a1, unsigned int a2, _DWORD *a3, unsigned __int8 a4)
{
  int v4; // ecx
  int result; // eax
  _DWORD *v6; // eax
  _DWORD *v7; // edx
  int v8; // ecx
  _DWORD *v9; // edx
  _DWORD *v10; // edx
  _DWORD *v11; // edx
  int v12; // edx
  _DWORD *v13; // edx
  int v14; // ecx
  int v15; // eax
  void *v16; // eax
  unsigned __int8 v17; // [esp+1Ch] [ebp-2Ch]
  int v18; // [esp+2Ch] [ebp-1Ch]
  unsigned int v19; // [esp+30h] [ebp-18h]
  unsigned int v20; // [esp+34h] [ebp-14h]
  _DWORD *v21; // [esp+38h] [ebp-10h]
  _DWORD *v22; // [esp+3Ch] [ebp-Ch]

  v17 = a4;
  if ( a2 == 2 )
  {
    result = sub_8050F19((int)(a1 - 8), v4, (int)(a1 - 4), (int)(a1 - 8)) > 0;
    v18 = result;
    if ( v17 )
    {
      v6 = a3 - 4;
      v7 = &a1[4 * ~v18];
      *v6 = *v7;
      v6[1] = v7[1];
      v6[2] = v7[2];
      v6[3] = v7[3];
      result = (int)(a3 - 8);
      v8 = 4 * (v18 - 2);
      *(_DWORD *)result = a1[v8];
      *(_DWORD *)(result + 4) = a1[v8 + 1];
      *(_DWORD *)(result + 8) = a1[v8 + 2];
      *(_DWORD *)(result + 12) = a1[v8 + 3];
    }
    else if ( v18 )
    {
      v9 = a3 - 4;
      *v9 = *(a1 - 4);
      v9[1] = *(a1 - 3);
      v9[2] = *(a1 - 2);
      v9[3] = *(a1 - 1);
      v10 = a1 - 4;
      *v10 = *(a1 - 8);
      v10[1] = *(a1 - 7);
      v10[2] = *(a1 - 6);
      v10[3] = *(a1 - 5);
      v11 = a1 - 8;
      *v11 = *(a3 - 4);
      v11[1] = *(a3 - 3);
      v11[2] = *(a3 - 2);
      v11[3] = *(a3 - 1);
      dword_806B2E8 = (int)&locret_80523E9;
      result = sub_8061957();
    }
  }
  else
  {
    v19 = a2 >> 1;
    v20 = a2 - (a2 >> 1);
    v21 = a1;
    v22 = &a1[-4 * (a2 >> 1)];
    v12 = v17;
    if ( v17 )
    {
      dword_806B35C = (int)&loc_8052313;
      sub_80616AA(v4, v17);
    }
    sub_805219E(v22, v20, a3, v12);
    if ( v19 <= 1 )
    {
      if ( v17 != 1 )
      {
        v13 = a3 - 4;
        v15 = (int)v21;
        *v13 = *(v21 - 4);
        v13[1] = *(_DWORD *)(v15 - 12);
        v14 = *(_DWORD *)(v15 - 8);
        v13[2] = v14;
        v13[3] = *(_DWORD *)(v15 - 4);
      }
    }
    else
    {
      sub_805219E(v21, v19, a3, v17 == 0);
    }
    v16 = &loc_80523B6;
    if ( !v17 )
      v16 = &loc_80523C4;
    dword_806B25C = (int)v16;
    sub_8061C89(v14, v13);
    result = (int)sub_805208E(a3, a2, a1);
  }
  return result;
}
// 80616AA: using guessed type int __fastcall sub_80616AA(_DWORD, _DWORD);
// 8061957: using guessed type int sub_8061957(void);
// 8061C89: using guessed type int __fastcall sub_8061C89(_DWORD, _DWORD);
// 806B25C: using guessed type int dword_806B25C;
// 806B2E8: using guessed type int dword_806B2E8;
// 806B35C: using guessed type int dword_806B35C;

//----- (080523EB) --------------------------------------------------------
pthread_mutex_t *__cdecl sub_80523EB(int a1, int a2, int a3)
{
  pthread_mutex_t *v3; // eax
  pthread_mutex_t *v4; // ST28_4
  pthread_mutex_t *v5; // ST2C_4

  v3 = (pthread_mutex_t *)sub_805E4FC(144 * a1);
  v4 = v3;
  v5 = v3;
  v3->__kind = 0;
  v5->__owner = v5->__kind;
  v5->__count = v5->__owner;
  v5->__lock = v5->__count;
  v3->__nusers = 0;
  v3[1].__lock = a2;
  v3->__spins = v3[1].__lock;
  v3[1].__count = 0;
  v3[1].__nusers = 0;
  v3[1].__size[20] = 0;
  pthread_mutex_init(v3 + 2, 0);
  sub_8052505((int)v5, (int)&v5[3], a3, a1, a2, 0);
  return v4;
}

//----- (08052505) --------------------------------------------------------
int __cdecl sub_8052505(int a1, int a2, int a3, int a4, int a5, char a6)
{
  int v6; // eax

  dword_806B348 = (int (__cdecl *)(_DWORD))sub_8052542;
  if ( a6 )
  {
    v6 = *(_DWORD *)(a1 + 20);
    dword_806B348 = (int (__cdecl *)(_DWORD))&loc_8052548;
  }
  return dword_806B348(a1);
}
// 806B348: using guessed type int (__cdecl *dword_806B348)(_DWORD);

//----- (08052542) --------------------------------------------------------
int __usercall sub_8052542@<eax>(_DWORD *a1@<ebp>, int a2)
{
  bool v2; // zf

  *(a1 - 11) = *(_DWORD *)(a1[2] + 24);
  *(a1 - 10) = *(a1 - 11) >> 1;
  *(a1 - 9) = *(a1 - 11) - *(a1 - 10);
  *(a1 - 8) = -16 * a1[6] + a1[4];
  *(a1 - 7) = -16 * *(a1 - 10) + *(a1 - 8);
  v2 = *((_BYTE *)a1 - 60) == 0;
  dword_806B348 = (int (__cdecl *)(_DWORD))sub_80525B5;
  if ( !v2 )
    dword_806B348 = (int (__cdecl *)(_DWORD))&loc_80525BB;
  return dword_806B348(a2);
}
// 806B348: using guessed type int (__cdecl *dword_806B348)(_DWORD);

//----- (080525B5) --------------------------------------------------------
#error "8052723: positive sp value has been found (funcsize=105)"

//----- (08052724) --------------------------------------------------------
int __cdecl sub_8052724(_DWORD *a1, _DWORD *a2)
{
  int v2; // edx
  int v3; // eax
  int v4; // ecx
  int v5; // eax

  v2 = a1[10];
  v3 = a2[10];
  dword_806B348 = (int (__cdecl *)(_DWORD))sub_8052790;
  if ( v2 == v3 )
  {
    v4 = a1[5] + a1[6];
    v5 = a2[5] + a2[6];
    dword_806B348 = (int (__cdecl *)(_DWORD))&locret_80527A4;
  }
  return dword_806B348(a1);
}
// 8052790: using guessed type int sub_8052790();
// 806B348: using guessed type int (__cdecl *dword_806B348)(_DWORD);

//----- (08052790) --------------------------------------------------------
#error "80527A5: positive sp value has been found (funcsize=0)"

//----- (080527A6) --------------------------------------------------------
int __cdecl sub_80527A6(pthread_mutex_t *a1)
{
  return pthread_mutex_lock(a1 + 2);
}

//----- (080527BC) --------------------------------------------------------
int __cdecl sub_80527BC(pthread_mutex_t *a1)
{
  return pthread_mutex_unlock(a1 + 2);
}

//----- (08052803) --------------------------------------------------------
int __cdecl sub_8052803(int a1, int a2)
{
  *(_DWORD *)a1 = sub_805921B((int (*)())sub_8052724, 2 * a2);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 4), 0);
  return pthread_cond_init((pthread_cond_t *)(a1 + 28), 0);
}

//----- (08052851) --------------------------------------------------------
int __cdecl sub_8052851(int a1, int a2)
{
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 4));
  sub_80592BA(*(_DWORD *)a1, a2);
  *(_BYTE *)(a2 + 44) = 1;
  pthread_cond_signal((pthread_cond_t *)(a1 + 28));
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 4));
}

//----- (0805289E) --------------------------------------------------------
pthread_mutex_t *__cdecl sub_805289E(int a1)
{
  int v1; // edx
  int v2; // ecx
  pthread_mutex_t *v4; // [esp+1Ch] [ebp-Ch]

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 4));
  while ( 1 )
  {
    v4 = (pthread_mutex_t *)sub_8059343(v1, v2, *(int **)a1);
    if ( v4 )
      break;
    pthread_cond_wait((pthread_cond_t *)(a1 + 28), (pthread_mutex_t *)(a1 + 4));
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 4));
  sub_80527A6(v4);
  v4[1].__size[20] = 0;
  return v4;
}

//----- (08052907) --------------------------------------------------------
int __usercall sub_8052907@<eax>(int a1@<edx>, int a2@<ecx>, int a3)
{
  void *v3; // eax
  int v4; // edx
  int v5; // ecx
  void *v6; // eax
  int v7; // edx
  int v8; // ecx
  bool v9; // zf
  void *v10; // eax
  int v12; // [esp+0h] [ebp-18h]

  v3 = &loc_8052931;
  if ( !byte_806C263 )
    v3 = &loc_80529AA;
  dword_806B298 = (int)v3;
  sub_8061B2F(a2, a1);
  v6 = &loc_8052953;
  if ( !dword_806BE3D )
    v6 = &loc_8052985;
  dword_806B324 = (int)v6;
  sub_8061801(v5, v4, v12);
  v9 = sub_8050F19(v7, v8, a3, (int)&dword_806BE3D) == 0;
  v10 = &loc_8052983;
  if ( !v9 )
    v10 = &loc_8052985;
  dword_806B2E8 = (int)v10;
  return sub_8061957();
}
// 8052907: could not find valid save-restore pair for ebx
// 8061957: using guessed type int sub_8061957(void);
// 8061B2F: using guessed type int __fastcall sub_8061B2F(_DWORD, _DWORD);
// 806B298: using guessed type int dword_806B298;
// 806B2E8: using guessed type int dword_806B2E8;
// 806B324: using guessed type int dword_806B324;
// 806BE3D: using guessed type int dword_806BE3D;
// 806C263: using guessed type char byte_806C263;

//----- (080529C5) --------------------------------------------------------
int __cdecl sub_80529C5(int a1, int a2, FILE *stream, int a4)
{
  int v4; // ecx
  unsigned int v5; // edx
  int v6; // eax
  bool v7; // zf
  bool v8; // sf
  void *v9; // eax
  _DWORD *v10; // edx
  _DWORD *v11; // eax
  int v12; // eax
  _DWORD *v13; // edx
  _DWORD *v14; // eax
  _DWORD *v15; // edx
  void *v16; // eax
  int v17; // eax
  void *v18; // eax
  _DWORD *v19; // edx
  _DWORD *v20; // eax
  int v21; // eax
  int v22; // eax
  int v23; // ecx
  int v24; // eax
  void *v25; // eax
  _DWORD *v26; // eax
  int v27; // ecx
  int v28; // ecx
  int v29; // eax
  void *v30; // eax
  int v31; // edx
  _DWORD *v32; // eax
  void *v33; // eax
  int v34; // ecx
  int v35; // eax
  void *v36; // eax
  int v37; // ecx
  int v38; // eax
  int v39; // eax
  int result; // eax
  FILE *v41; // [esp+4h] [ebp-34h]
  int v42; // [esp+8h] [ebp-30h]
  unsigned int v43; // [esp+18h] [ebp-20h]
  _DWORD *v44; // [esp+1Ch] [ebp-1Ch]
  _DWORD *v45; // [esp+20h] [ebp-18h]
  int v46; // [esp+24h] [ebp-14h]
  int v47; // [esp+28h] [ebp-10h]
  int v48; // [esp+2Ch] [ebp-Ch]

  v45 = *(_DWORD **)a1;
  v46 = *(_DWORD *)(a1 + 4);
  v4 = 2 * (*(_DWORD *)(a1 + 40) + 1);
  v5 = (unsigned int)a2 >> v4;
  v43 = ((unsigned int)a2 >> v4) + 1;
  if ( *(_DWORD *)(a1 + 40) > 1u )
  {
    v44 = **(_DWORD ***)(a1 + 16);
    while ( *(_DWORD *)a1 != *(_DWORD *)(a1 + 8) )
    {
      if ( *(_DWORD *)(a1 + 4) == *(_DWORD *)(a1 + 12) )
        break;
      v12 = v43--;
      if ( !v12 )
        break;
      v6 = sub_8050F19(*(_DWORD *)(a1 + 4) - 16, v4, *(_DWORD *)a1 - 16, *(_DWORD *)(a1 + 4) - 16);
      v7 = v6 == 0;
      v8 = v6 < 0;
      v9 = &loc_8052A4F;
      if ( !v8 && !v7 )
        v9 = &loc_8052A80;
      dword_806B2E8 = (int)v9;
      sub_8061957();
      v44 -= 4;
      *(_DWORD *)a1 -= 16;
      v10 = *(_DWORD **)a1;
      v11 = v44;
      *v44 = **(_DWORD **)a1;
      v11[1] = v10[1];
      v4 = v10[2];
      v11[2] = v4;
      v11[3] = v10[3];
    }
    v47 = ((signed int)v45 - *(_DWORD *)a1) >> 4;
    v48 = (v46 - *(_DWORD *)(a1 + 4)) >> 4;
    if ( *(_DWORD *)(a1 + 24) == v48 )
    {
      while ( 1 )
      {
        v15 = *(_DWORD **)a1;
        v16 = &loc_8052B6B;
        if ( *(_DWORD *)a1 == *(_DWORD *)(a1 + 8) )
          v16 = &loc_8052BEF;
        dword_806B248 = (int)v16;
        sub_8061CFB(v4, v15);
        v17 = v43--;
        if ( !v17 )
          break;
        v44 -= 4;
        *(_DWORD *)a1 -= 16;
        v13 = *(_DWORD **)a1;
        v14 = v44;
        *v44 = **(_DWORD **)a1;
        v14[1] = v13[1];
        v4 = v13[2];
        v14[2] = v4;
        v14[3] = v13[3];
      }
    }
    else
    {
      v18 = &loc_8052B9E;
      if ( *(_DWORD *)(a1 + 20) != v47 )
        v18 = &loc_8052BEF;
      dword_806B234 = (int)v18;
      sub_8061D73();
      while ( *(_DWORD *)(a1 + 4) != *(_DWORD *)(a1 + 12) )
      {
        v21 = v43--;
        if ( !v21 )
          break;
        v44 -= 4;
        *(_DWORD *)(a1 + 4) -= 16;
        v19 = *(_DWORD **)(a1 + 4);
        v20 = v44;
        *v44 = *v19;
        v20[1] = v19[1];
        v20[2] = v19[2];
        v20[3] = v19[3];
      }
    }
    **(_DWORD **)(a1 + 16) = v44;
    dword_806B2C0 = (int)&loc_8052DFB;
    sub_8061A43();
  }
  dword_806B270 = (int)&loc_8052CB7;
  sub_8061C11(v4, v5);
  v22 = *(_DWORD *)a1 - 16;
  v41 = (FILE *)(*(_DWORD *)(a1 + 4) - 16);
  v24 = sub_8050F19((int)v41, v23, v22, (int)v41);
  v7 = v24 == 0;
  v8 = v24 < 0;
  v25 = &loc_8052C62;
  if ( !v8 && !v7 )
    v25 = &loc_8052C8C;
  dword_806B2E8 = (int)v25;
  sub_8061957();
  *(_DWORD *)a1 -= 16;
  v26 = *(_DWORD **)a1;
  v42 = a4;
  v41 = stream;
  sub_8052907((int)stream, v27, (int)v26);
  if ( *(_DWORD *)a1 != *(_DWORD *)(a1 + 8) && *(_DWORD *)(a1 + 4) != *(_DWORD *)(a1 + 12) )
  {
    v29 = v43--;
    v7 = v29 == 0;
    v30 = &loc_8052CFC;
    if ( !v7 )
      v30 = &loc_8052C28;
    dword_806B370 = (int)v30;
    sub_8061638();
  }
  v47 = ((signed int)v45 - *(_DWORD *)a1) >> 4;
  v31 = v46 - *(_DWORD *)(a1 + 4);
  v48 = (v46 - *(_DWORD *)(a1 + 4)) >> 4;
  if ( *(_DWORD *)(a1 + 24) == v48 )
  {
    while ( 1 )
    {
      v33 = &loc_8052D7E;
      if ( *(_DWORD *)a1 == *(_DWORD *)(a1 + 8) )
        v33 = &loc_8052DFB;
      dword_806B284 = (int)v33;
      sub_8061B9D();
      v35 = v43--;
      if ( !v35 )
        break;
      *(_DWORD *)a1 -= 16;
      v32 = *(_DWORD **)a1;
      v42 = a4;
      v41 = stream;
      sub_8052907((int)stream, v34, (int)v32);
    }
  }
  else
  {
    v36 = &loc_8052DB1;
    if ( *(_DWORD *)(a1 + 20) != v47 )
      v36 = &loc_8052DFB;
    dword_806B220 = (int)v36;
    sub_8061DE3(v28, v31);
    while ( *(_DWORD *)(a1 + 4) != *(_DWORD *)(a1 + 12) )
    {
      v39 = v43--;
      if ( !v39 )
        break;
      *(_DWORD *)(a1 + 4) -= 16;
      v38 = *(_DWORD *)(a1 + 4);
      v42 = a4;
      v41 = stream;
      sub_8052907((int)stream, v37, v38);
    }
  }
  v47 = ((signed int)v45 - *(_DWORD *)a1) >> 4;
  v48 = (v46 - *(_DWORD *)(a1 + 4)) >> 4;
  *(_DWORD *)(a1 + 20) -= v47;
  result = a1;
  *(_DWORD *)(a1 + 24) -= v48;
  return result;
}
// 80529C5: could not find valid save-restore pair for ebx
// 8061638: using guessed type int sub_8061638(void);
// 8061957: using guessed type int sub_8061957(void);
// 8061A43: using guessed type int sub_8061A43(void);
// 8061B9D: using guessed type int sub_8061B9D(void);
// 8061C11: using guessed type int __fastcall sub_8061C11(_DWORD, _DWORD);
// 8061CFB: using guessed type int __fastcall sub_8061CFB(_DWORD, _DWORD);
// 8061D73: using guessed type int sub_8061D73(void);
// 8061DE3: using guessed type int __fastcall sub_8061DE3(_DWORD, _DWORD);
// 806B220: using guessed type int dword_806B220;
// 806B234: using guessed type int dword_806B234;
// 806B248: using guessed type int dword_806B248;
// 806B270: using guessed type int dword_806B270;
// 806B284: using guessed type int dword_806B284;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B2E8: using guessed type int dword_806B2E8;
// 806B370: using guessed type int dword_806B370;

//----- (08052E44) --------------------------------------------------------
int __usercall sub_8052E44@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4)
{
  void *v4; // eax
  int v5; // ecx
  int v6; // edx
  bool v7; // al
  bool v8; // al
  bool v9; // al
  bool v10; // zf
  void *v11; // eax
  bool v13; // [esp+1Fh] [ebp-9h]

  v4 = &loc_8052E71;
  if ( *(_BYTE *)(a4 + 44) == 1 )
    v4 = &locret_8052F21;
  dword_806B270 = (int)v4;
  sub_8061C11(a2, a1);
  v6 = *(_DWORD *)(a4 + 4) - *(_DWORD *)(a4 + 12);
  v13 = (unsigned int)(v6 + 15) > 0x1E;
  if ( (unsigned int)(*(_DWORD *)a4 - *(_DWORD *)(a4 + 8) + 15) > 0x1E )
  {
    v7 = v13 || !*(_DWORD *)(a4 + 24);
    v8 = v7;
  }
  else
  {
    v9 = v13 && !*(_DWORD *)(a4 + 20);
    v8 = v9;
  }
  v10 = v8 == 0;
  v11 = &loc_8052F0F;
  if ( v10 )
    v11 = &locret_8052F21;
  dword_806B220 = (int)v11;
  sub_8061DE3(v5, v6);
  return sub_8052851(a3, a4);
}
// 8052E44: could not find valid save-restore pair for ebx
// 8061C11: using guessed type int __fastcall sub_8061C11(_DWORD, _DWORD);
// 8061DE3: using guessed type int __fastcall sub_8061DE3(_DWORD, _DWORD);
// 806B220: using guessed type int dword_806B220;
// 806B270: using guessed type int dword_806B270;

//----- (08052F23) --------------------------------------------------------
int __cdecl sub_8052F23(int a1, int a2)
{
  int v2; // edx
  int v3; // ecx
  int result; // eax

  if ( *(_DWORD *)(a2 + 40) > 1u )
  {
    sub_80527A6(*(pthread_mutex_t **)(a2 + 28));
    sub_8052E44(v2, v3, a1, *(_DWORD *)(a2 + 28));
    sub_80527BC(*(pthread_mutex_t **)(a2 + 28));
    dword_806B370 = (int)&locret_8052FA3;
    sub_8061638();
  }
  result = *(_DWORD *)(a2 + 20) + *(_DWORD *)(a2 + 24);
  if ( !result )
    result = sub_8052851(a1, *(_DWORD *)(a2 + 28));
  return result;
}
// 8061638: using guessed type int sub_8061638(void);
// 806B370: using guessed type int dword_806B370;

//----- (08052FA5) --------------------------------------------------------
int __cdecl sub_8052FA5(int a1, int a2, FILE *stream, int a4)
{
  int v5; // edx
  int v6; // ecx
  pthread_mutex_t *v7; // [esp+1Ch] [ebp-Ch]

  while ( 1 )
  {
    v7 = sub_805289E(a1);
    if ( !v7[1].__nusers )
      break;
    sub_80529C5((int)v7, a2, stream, a4);
    sub_8052E44(v5, v6, a1, (int)v7);
    sub_8052F23(a1, (int)v7);
    sub_80527BC(v7);
  }
  sub_80527BC(v7);
  return sub_8052851(a1, (int)v7);
}

//----- (08053038) --------------------------------------------------------
void *__cdecl start_routine(void *a1)
{
  sub_80530A5(
    *(_DWORD *)a1,
    *((_DWORD *)a1 + 1),
    *((_DWORD *)a1 + 2),
    *((_DWORD *)a1 + 3),
    *((_DWORD *)a1 + 4),
    *((FILE **)a1 + 5),
    *((_DWORD *)a1 + 6));
  return 0;
}

//----- (080530A5) --------------------------------------------------------
int __cdecl sub_80530A5(int a1, int a2, int a3, int a4, int a5, FILE *stream, int a7)
{
  int result; // eax
  pthread_t newthread; // [esp+28h] [ebp-40h]
  unsigned int v9; // [esp+2Ch] [ebp-3Ch]
  unsigned int v10; // [esp+30h] [ebp-38h]
  int v11; // [esp+34h] [ebp-34h]
  unsigned int v12; // [esp+38h] [ebp-30h]
  unsigned int v13; // [esp+3Ch] [ebp-2Ch]
  _DWORD *v14; // [esp+40h] [ebp-28h]
  int arg; // [esp+44h] [ebp-24h]
  unsigned int v16; // [esp+48h] [ebp-20h]
  int v17; // [esp+4Ch] [ebp-1Ch]
  int v18; // [esp+50h] [ebp-18h]
  int v19; // [esp+54h] [ebp-14h]
  FILE *v20; // [esp+58h] [ebp-10h]
  int v21; // [esp+5Ch] [ebp-Ch]

  v9 = *(_DWORD *)(a4 + 20) + *(_DWORD *)(a4 + 24);
  v10 = (unsigned int)a2 >> 1;
  v11 = a2 - ((unsigned int)a2 >> 1);
  arg = a1;
  v16 = (unsigned int)a2 >> 1;
  v17 = a3;
  v18 = *(_DWORD *)(a4 + 32);
  v19 = a5;
  v20 = stream;
  v21 = a7;
  if ( (unsigned int)a2 <= 1 || v9 <= 0x1FFFF || pthread_create(&newthread, 0, start_routine, &arg) )
  {
    v12 = *(_DWORD *)(a4 + 20);
    v13 = *(_DWORD *)(a4 + 24);
    v14 = (_DWORD *)(-16 * a3 + a1);
    if ( v13 > 1 )
      sub_805219E((_DWORD *)(-16 * v12 + a1), v13, &v14[-4 * (v12 >> 1)], 0);
    if ( v12 > 1 )
      sub_805219E((_DWORD *)a1, v12, v14, 0);
    *(_DWORD *)a4 = a1;
    *(_DWORD *)(a4 + 4) = a1 - 16 * v12;
    *(_DWORD *)(a4 + 8) = a1 - 16 * v12;
    *(_DWORD *)(a4 + 12) = a1 + -16 * v12 - 16 * v13;
    sub_8052851(a5, a4);
    result = sub_8052FA5(a5, a3, stream, a7);
  }
  else
  {
    sub_80530A5(a1 - 16 * *(_DWORD *)(a4 + 20), v11, a3, *(_DWORD *)(a4 + 36), a5, stream, a7);
    result = pthread_join(newthread, 0);
  }
  return result;
}

//----- (080532A9) --------------------------------------------------------
int __cdecl sub_80532A9(int a1, int a2, int a3, char *s1)
{
  int v4; // edx
  int v5; // ecx
  void *v6; // eax
  int result; // eax
  bool v8; // zf
  int v9; // edx
  int v10; // ecx
  void *v11; // eax
  int v12; // edx
  int v13; // ecx
  void *v14; // eax
  char v15; // al
  const char *v16; // [esp+4h] [ebp-F4h]
  char v17; // [esp+21h] [ebp-D7h]
  char v18; // [esp+22h] [ebp-D6h]
  bool v19; // [esp+23h] [ebp-D5h]
  FILE *stream; // [esp+24h] [ebp-D4h]
  int *v21; // [esp+28h] [ebp-D0h]
  unsigned int v22; // [esp+2Ch] [ebp-CCh]
  __int64 v23; // [esp+30h] [ebp-C8h]
  __int64 v24; // [esp+88h] [ebp-70h]
  __int64 v25; // [esp+90h] [ebp-68h]
  __int64 v26; // [esp+E8h] [ebp-10h]

  v17 = 0;
  v21 = 0;
  v22 = a2;
  dword_806B20C = (int)&loc_8053530;
  sub_8061E55();
  do
  {
    v19 = strcmp(*(const char **)(8 * v22 + a1), "-") == 0;
    v6 = &loc_8053333;
    if ( !s1 )
      v6 = &loc_8053374;
    dword_806B2AC = (int)v6;
    sub_8061AB5(v5, v4);
    v16 = *(const char **)(8 * v22 + a1);
    if ( !strcmp(s1, v16) && v19 != 1 )
    {
      v18 = 1;
    }
    else
    {
      if ( v17 != 1 )
      {
        result = sub_806151C(1, (int)&v23);
        if ( result )
          return result;
        v17 = 1;
      }
      if ( v19 )
      {
        v8 = sub_806151C(0, (int)&v25) == 0;
        v11 = &loc_80533E0;
        if ( v8 )
          v11 = &loc_805341E;
        dword_806B35C = (int)v11;
        sub_80616AA(v10, v9);
        dword_806B220 = (int)&loc_8053474;
        sub_8061DE3(v13, v12);
      }
      if ( sub_80614ED(*(_DWORD *)(8 * v22 + a1), (int)&v25) )
        goto LABEL_28;
      v14 = &loc_805344F;
      if ( v26 != v24 )
        v14 = &loc_8053474;
      dword_806B298 = (int)v14;
      sub_8061B2F(v26, HIDWORD(v24));
      if ( v25 != v23 )
LABEL_28:
        v15 = 0;
      else
        v15 = 1;
      v18 = v15 & 1;
    }
    if ( v18 )
    {
      if ( !v21 )
      {
        v21 = sub_804CBF6(&stream);
        sub_8051FFD(8 * v22 + a1, 0, 1, stream, (int)v21 + 9);
      }
      *(_DWORD *)(8 * v22 + a1) = (char *)v21 + 9;
      *(_DWORD *)(a1 + 8 * v22 + 4) = v21;
    }
    result = ++v22;
  }
  while ( v22 < a3 );
  return result;
}
// 80616AA: using guessed type int __fastcall sub_80616AA(_DWORD, _DWORD);
// 8061AB5: using guessed type int __fastcall sub_8061AB5(_DWORD, _DWORD);
// 8061B2F: using guessed type int __fastcall sub_8061B2F(_DWORD, _DWORD);
// 8061DE3: using guessed type int __fastcall sub_8061DE3(_DWORD, _DWORD);
// 8061E55: using guessed type int sub_8061E55(void);
// 806B20C: using guessed type int dword_806B20C;
// 806B220: using guessed type int dword_806B220;
// 806B298: using guessed type int dword_806B298;
// 806B2AC: using guessed type int dword_806B2AC;
// 806B35C: using guessed type int dword_806B35C;

//----- (08053549) --------------------------------------------------------
unsigned int __cdecl sub_8053549(int a1, unsigned int a2)
{
  bool v2; // zf
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  int v6; // ebx
  char *v7; // eax
  int v8; // edx
  int v9; // ecx
  unsigned int result; // eax
  unsigned int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a2 )
      break;
    if ( strcmp(*(const char **)(4 * i + a1), "-") )
    {
      v2 = euidaccess(*(_DWORD *)(4 * i + a1), 4) == 0;
      v5 = &loc_80535C1;
      if ( v2 )
        v5 = &loc_80535EA;
      dword_806B2AC = (int)v5;
      sub_8061AB5(v4, v3);
      v6 = *(_DWORD *)(4 * i + a1);
      v7 = gettext("cannot read");
      sub_804BCE7(v9, v8, (int)v7, v6);
    }
  }
  return result;
}
// 8049E00: using guessed type int __cdecl euidaccess(_DWORD, _DWORD);
// 8061AB5: using guessed type int __fastcall sub_8061AB5(_DWORD, _DWORD);
// 806B2AC: using guessed type int dword_806B2AC;

//----- (08053600) --------------------------------------------------------
void __cdecl sub_8053600(int a1)
{
  char *v1; // eax
  int v2; // ecx
  int fd; // [esp+1Ch] [ebp-Ch]

  if ( a1 )
  {
    fd = open64(a1, 524353);
    if ( fd < 0 )
    {
      v1 = gettext("open failed");
      sub_804BCE7(v2, a1, (int)v1, a1);
    }
    sub_804C88F(fd, 1);
  }
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);

//----- (08053666) --------------------------------------------------------
void __cdecl sub_8053666(int a1, int a2, int a3, char *s1)
{
  int *v4; // eax
  int v5; // esi
  int v6; // eax
  int v7; // eax
  int *v8; // eax
  int v9; // ebx
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // edx
  int v15; // ecx
  bool v16; // zf
  void *v17; // eax
  FILE *v18; // eax
  void *v19; // eax
  void *v20; // [esp+28h] [ebp-50h]
  FILE *v21; // [esp+2Ch] [ebp-4Ch]
  int v22; // [esp+30h] [ebp-48h]
  unsigned int v23; // [esp+34h] [ebp-44h]
  int v24; // [esp+38h] [ebp-40h]
  int *v25; // [esp+3Ch] [ebp-3Ch]
  unsigned int v26; // [esp+40h] [ebp-38h]
  int v27; // [esp+44h] [ebp-34h]
  unsigned int v28; // [esp+48h] [ebp-30h]
  int v29; // [esp+4Ch] [ebp-2Ch]
  int *v30; // [esp+50h] [ebp-28h]
  unsigned int v31; // [esp+54h] [ebp-24h]
  FILE *stream; // [esp+58h] [ebp-20h]

  while ( dword_806B440 < (unsigned int)a3 )
  {
    v22 = 0;
    v23 = 0;
    while ( a3 - v22 >= (unsigned int)dword_806B440 )
    {
      v4 = sub_804CBF6(&v21);
      v25 = v4;
      v5 = (int)v4 + 9;
      v6 = a2;
      if ( dword_806B440 <= (unsigned int)a2 )
        v6 = dword_806B440;
      v26 = sub_8051FFD(8 * v22 + a1, v6, dword_806B440, v21, v5);
      v7 = a2;
      if ( v26 <= a2 )
        v7 = v26;
      a2 -= v7;
      *(_DWORD *)(8 * v23 + a1) = (char *)v25 + 9;
      *(_DWORD *)(a1 + 8 * v23 + 4) = v25;
      v22 += v26;
      ++v23;
    }
    v27 = a3 - v22;
    v28 = dword_806B440 - v23 % dword_806B440;
    if ( dword_806B440 - v23 % dword_806B440 < a3 - v22 )
    {
      v29 = v27 - v28 + 1;
      v8 = sub_804CBF6(&v21);
      v30 = v8;
      v9 = (int)v8 + 9;
      v10 = a2;
      if ( v29 <= (unsigned int)a2 )
        v10 = v29;
      v31 = sub_8051FFD(8 * v22 + a1, v10, v29, v21, v9);
      v11 = a2;
      if ( v31 <= a2 )
        v11 = v31;
      a2 -= v11;
      *(_DWORD *)(8 * v23 + a1) = (char *)v30 + 9;
      v12 = v23++;
      *(_DWORD *)(a1 + 8 * v12 + 4) = v30;
      v22 += v31;
    }
    memmove((void *)(8 * v23 + a1), (const void *)(a1 + 8 * v22), 8 * (a3 - v22));
    a2 += v23;
    a3 += v23 - v22;
  }
  sub_80532A9(a1, a2, a3, s1);
  v13 = sub_8051502(a1, a3, &v20);
  v24 = v13;
  v16 = v13 == a3;
  v17 = &loc_80538CB;
  if ( !v16 )
    v17 = &loc_8053962;
  dword_806B270 = (int)v17;
  sub_8061C11(v15, v14);
  v18 = sub_804C623(s1, "w");
  stream = v18;
  v16 = v18 == 0;
  v19 = &loc_8053900;
  if ( v16 )
    v19 = &loc_8053933;
  dword_806B20C = (int)v19;
  sub_8061E55();
  sub_8051629(a1, a2, a3, stream, (int)s1, v20);
}
// 8061C11: using guessed type int __fastcall sub_8061C11(_DWORD, _DWORD);
// 8061E55: using guessed type int sub_8061E55(void);
// 806B20C: using guessed type int dword_806B20C;
// 806B270: using guessed type int dword_806B270;
// 806B43C: using guessed type int dword_806B43C;

//----- (08053A91) --------------------------------------------------------
unsigned int __usercall sub_8053A91@<eax>(long double a1@<st0>, int edx0@<edx>, int ecx0@<ecx>, char **a2, unsigned int a3, char *a4, unsigned int a5)
{
  int v7; // eax
  bool v8; // zf
  void *v9; // eax
  void *v10; // eax
  int v11; // edx
  int v12; // ecx
  FILE *v14; // [esp+4h] [ebp-E4h]
  char *v15; // [esp+8h] [ebp-E0h]
  char *v16; // [esp+28h] [ebp-C0h]
  char **v17; // [esp+2Ch] [ebp-BCh]
  char v18; // [esp+3Fh] [ebp-A9h]
  FILE *stream; // [esp+40h] [ebp-A8h]
  int v20; // [esp+48h] [ebp-A0h]
  int v21; // [esp+50h] [ebp-98h]
  unsigned int v22; // [esp+54h] [ebp-94h]
  int v23; // [esp+58h] [ebp-90h]
  int *v24; // [esp+5Ch] [ebp-8Ch]
  int v25; // [esp+60h] [ebp-88h]
  char *s1; // [esp+64h] [ebp-84h]
  void *v27; // [esp+70h] [ebp-78h]
  void *ptr; // [esp+74h] [ebp-74h]
  int v29; // [esp+80h] [ebp-68h]
  char v30; // [esp+8Ch] [ebp-5Ch]
  unsigned int v31; // [esp+DCh] [ebp-Ch]

  v17 = a2;
  v16 = a4;
  v31 = __readgsdword(0x14u);
  v20 = 0;
  v18 = 0;
  v29 = 0;
  dword_806B338 = (int)&loc_8053DDB;
  sub_8061791(ecx0, edx0);
  do
  {
    s1 = *v17;
    stream = (FILE *)sub_804C778(s1, "r");
    if ( a5 <= 1 )
    {
      v21 = 24;
    }
    else
    {
      v22 = 1;
      v23 = 1;
      while ( v22 < a5 )
      {
        v22 *= 2;
        ++v23;
      }
      v21 = 16 * v23;
    }
    if ( !v29 )
    {
      v7 = sub_804D9D4(a1, (int)&stream, 1u, (int)v17, a3, v21);
      sub_804DBB7((int)&ptr, v21, v7);
    }
    v30 = 0;
    ++v17;
    --a3;
    v15 = s1;
    v14 = stream;
    v8 = (unsigned __int8)sub_804E01D((int)&ptr) == 0;
    v9 = &loc_8053DC3;
    if ( !v8 )
      v9 = &loc_8053BC5;
    dword_806B2C0 = (int)v9;
    sub_8061A43();
    sub_804C7CB(stream, (int)s1);
  }
  while ( a3 );
  free(ptr);
  v10 = &loc_8053E17;
  if ( v18 == 1 )
    v10 = &loc_8053ED1;
  dword_806B2D4 = (int)v10;
  sub_80619CB();
  v24 = (int *)dword_806C2F1;
  v27 = sub_805E3D6(v20, 8u);
  v25 = 0;
  while ( v24 )
  {
    *((_DWORD *)v27 + 2 * v25) = (char *)v24 + 9;
    *((_DWORD *)v27 + 2 * v25 + 1) = v24;
    v24 = (int *)*v24;
    ++v25;
  }
  sub_8053666((int)v27, v20, v20, v16);
  free(v27);
  sub_804C373(v12, v11);
  return __readgsdword(0x14u) ^ v31;
}
// 8061791: using guessed type int __fastcall sub_8061791(_DWORD, _DWORD);
// 80619CB: using guessed type int sub_80619CB(void);
// 8061A43: using guessed type int sub_8061A43(void);
// 806B2C0: using guessed type int dword_806B2C0;
// 806B2D4: using guessed type int dword_806B2D4;
// 806B338: using guessed type int dword_806B338;
// 806C2F1: using guessed type int dword_806C2F1;

//----- (08053EF0) --------------------------------------------------------
_DWORD *__cdecl sub_8053EF0(void *src)
{
  _DWORD *result; // eax
  int *i; // [esp+18h] [ebp-10h]
  _DWORD *v3; // [esp+1Ch] [ebp-Ch]

  v3 = sub_805E63B(src, 0x28u);
  for ( i = &dword_806C265; *i; i = (int *)(*i + 36) )
    ;
  *i = (int)v3;
  result = v3;
  v3[9] = 0;
  return result;
}
// 806C265: using guessed type int dword_806C265;

//----- (08053F3D) --------------------------------------------------------
unsigned int __cdecl sub_8053F3D(int a1, char *msgid)
{
  void *v2; // esi
  char *v3; // ebx
  char *v4; // eax

  v2 = sub_805BF80((char *)a1);
  v3 = gettext(msgid);
  v4 = gettext("%s: invalid field specification %s");
  error(2, 0, v4, v3, v2);
  return sub_8053F8B(a1);
}

//----- (08053F8B) --------------------------------------------------------
unsigned int __cdecl sub_8053F8B(int a1)
{
  char *v1; // eax

  v1 = gettext("options '-%s' are incompatible");
  error(2, 0, v1, a1);
  return sub_8053FBC();
}

//----- (08053FBC) --------------------------------------------------------
unsigned int sub_8053FBC()
{
  void *v0; // eax
  unsigned int v2; // [esp+3Ch] [ebp-Ch]

  v2 = __readgsdword(0x14u);
  v0 = &loc_805409C;
  if ( dword_806C265 )
    v0 = &loc_8053FDA;
  dword_806B2D4 = (int)v0;
  sub_80619CB();
  return __readgsdword(0x14u) ^ v2;
}
// 80619CB: using guessed type int sub_80619CB(void);
// 806B2D4: using guessed type int dword_806B2D4;
// 806C265: using guessed type int dword_806C265;

//----- (080540AF) --------------------------------------------------------
int __usercall sub_80540AF@<eax>(int a1@<edx>, int a2@<ecx>, char *nptr, int a4, char *msgid)
{
  int v5; // ecx
  void *v6; // eax
  void *v7; // esi
  char *v8; // ebx
  char *v9; // eax
  int result; // eax
  int v11; // [esp+24h] [ebp-14h]
  __int64 v12; // [esp+28h] [ebp-10h]

  switch ( sub_805F0A0(a1, a2, nptr, (int)&v11, 10, (int)&v12, &s) )
  {
    case 0:
    case 2:
      *(_DWORD *)a4 = v12;
      v5 = *(_DWORD *)a4;
      v6 = &loc_8054136;
      if ( v12 != *(_DWORD *)a4 )
        v6 = &loc_8054138;
      dword_806B25C = (int)v6;
      sub_8061C89(v5, HIDWORD(v12));
      goto LABEL_9;
    case 1:
    case 3:
      *(_DWORD *)a4 = -1;
      goto LABEL_9;
    case 4:
      if ( msgid )
      {
        v7 = sub_805BF80(nptr);
        v8 = gettext(msgid);
        v9 = gettext("%s: invalid count at start of %s");
        error(2, 0, v9, v8, v7);
      }
      result = 0;
      break;
    default:
LABEL_9:
      result = v11;
      break;
  }
  return result;
}
// 8061C89: using guessed type int __fastcall sub_8061C89(_DWORD, _DWORD);
// 806B25C: using guessed type int dword_806B25C;

//----- (080541A0) --------------------------------------------------------
int __cdecl sub_80541A0(int sig)
{
  sub_804C3A7();
  signal(sig, 0);
  return raise(sig);
}

//----- (080541CB) --------------------------------------------------------
_BYTE *__usercall sub_80541CB@<eax>(int a1@<edx>, int a2@<ecx>, char *a3, int a4, int a5)
{
  int v5; // edx
  int v6; // ecx
  void *v7; // eax
  void *v8; // eax
  void *v9; // eax
  _BYTE *result; // eax
  void *v11; // eax
  int savedregs; // [esp+0h] [ebp+0h]
  _BYTE *v13; // [esp+8h] [ebp+8h]

  dword_806B270 = (int)&loc_8054326;
  sub_8061C11(a2, a1);
  switch ( *a3 )
  {
    case 77:
      *(_BYTE *)(a4 + 30) = 1;
      goto LABEL_24;
    case 82:
      *(_BYTE *)(a4 + 27) = 1;
      goto LABEL_24;
    case 86:
      goto LABEL_22;
    case 98:
      if ( a5 )
      {
        v7 = &loc_8054228;
        if ( a5 != 2 )
          v7 = &loc_805422F;
        dword_806B324 = (int)v7;
        sub_8061801(v6, v5, savedregs);
      }
      *(_BYTE *)(a4 + 24) = 1;
      v8 = &loc_805424E;
      if ( a5 == 1 )
        v8 = &loc_8054254;
      dword_806B2C0 = (int)v8;
      sub_8061A43();
      if ( a5 == 2 )
        *(_BYTE *)(a4 + 25) = 1;
      goto LABEL_24;
    case 100:
      *(_DWORD *)(a4 + 16) = &unk_806C051;
      goto LABEL_24;
    case 102:
      *(_DWORD *)(a4 + 20) = byte_806C151;
      goto LABEL_24;
    case 103:
      *(_BYTE *)(a4 + 28) = 1;
      dword_806B370 = (int)&loc_8054322;
      sub_8061638();
      goto LABEL_14;
    case 104:
LABEL_14:
      *(_BYTE *)(a4 + 29) = 1;
      goto LABEL_24;
    case 105:
      v9 = &loc_80542CD;
      if ( *(_DWORD *)(a4 + 16) )
        v9 = &loc_80542D9;
      dword_806B370 = (int)v9;
      sub_8061638();
      *(_DWORD *)(a4 + 16) = &unk_806BF51;
      goto LABEL_24;
    case 110:
      *(_BYTE *)(a4 + 26) = 1;
      goto LABEL_24;
    case 114:
      *(_BYTE *)(a4 + 31) = 1;
      dword_806B20C = (int)&loc_8054322;
      sub_8061E55();
LABEL_22:
      *(_BYTE *)(a4 + 32) = 1;
LABEL_24:
      v13 = a3 + 1;
      v11 = &loc_8054349;
      if ( *v13 )
        v11 = &loc_80541E5;
      dword_806B2C0 = (int)v11;
      sub_8061A43();
      result = v13;
      break;
    default:
      result = a3;
      break;
  }
  return result;
}
// 80541CB: could not find valid save-restore pair for ebx
// 8061638: using guessed type int sub_8061638(void);
// 8061A43: using guessed type int sub_8061A43(void);
// 8061C11: using guessed type int __fastcall sub_8061C11(_DWORD, _DWORD);
// 8061E55: using guessed type int sub_8061E55(void);
// 806B20C: using guessed type int dword_806B20C;
// 806B270: using guessed type int dword_806B270;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B324: using guessed type int dword_806B324;
// 806B370: using guessed type int dword_806B370;

//----- (0805434E) --------------------------------------------------------
void *__cdecl sub_805434E(void *s)
{
  memset(s, 0, 0x28u);
  *((_DWORD *)s + 2) = -1;
  return s;
}

//----- (0805437E) --------------------------------------------------------
int __cdecl main(int argc, char **argv)
{
  bool v2; // al
  unsigned __int8 **v3; // eax
  unsigned __int8 v4; // al
  unsigned __int8 v5; // al
  int v6; // edx
  int v7; // ecx
  void *v8; // eax
  void *v9; // eax
  int v10; // ecx
  void *v11; // eax
  int v12; // edx
  void *v13; // eax
  int v14; // ecx
  int v15; // edx
  int v16; // ecx
  void *v17; // eax
  int v18; // ecx
  int v19; // ecx
  int v20; // eax
  char *v21; // eax
  bool v22; // zf
  void *v23; // eax
  int v24; // eax
  int v25; // edx
  int v26; // ecx
  signed int v27; // eax
  int v28; // edx
  int v29; // ecx
  void *v30; // eax
  char *v31; // eax
  char *v32; // eax
  int v33; // ecx
  int v34; // eax
  void *v35; // eax
  int v36; // edx
  int v37; // ecx
  void *v38; // eax
  int v39; // ecx
  int v40; // eax
  int v41; // ecx
  int v42; // edx
  int v43; // ecx
  int v44; // eax
  int v45; // ecx
  int v46; // edx
  void *v47; // eax
  int v48; // edx
  int v49; // ecx
  void *v50; // eax
  char *v51; // eax
  char *v52; // eax
  char *v53; // eax
  char *v54; // ebx
  char *v55; // eax
  void *v56; // eax
  int v57; // ecx
  void *v58; // eax
  char *v59; // eax
  char *v60; // edx
  void *v61; // eax
  char *v62; // ebx
  char *v63; // eax
  char *v64; // ebx
  char *v65; // eax
  char *v66; // ebx
  char *v67; // eax
  char *v68; // ebx
  char *v69; // eax
  char *v70; // ebx
  char *v71; // eax
  int v72; // edx
  int v73; // ecx
  void *v74; // eax
  int v75; // edx
  int v76; // ecx
  void *v77; // eax
  int v78; // edx
  int v79; // ecx
  void *v80; // eax
  char *v81; // eax
  char *v82; // ebx
  char *v83; // eax
  int v84; // edx
  int v85; // ecx
  int v86; // eax
  const char *v87; // esi
  char *v88; // ebx
  char *v89; // eax
  void *v90; // eax
  int result; // eax
  int v92; // edx
  int v93; // ecx
  void *v94; // eax
  char *v95; // eax
  int v96; // edx
  int v97; // ecx
  int v98; // [esp+0h] [ebp-17Ch]
  int v99; // [esp+4h] [ebp-178h]
  char *v100; // [esp+8h] [ebp-174h]
  char *v101; // [esp+Ch] [ebp-170h]
  const char *v102; // [esp+10h] [ebp-16Ch]
  const char *v103; // [esp+14h] [ebp-168h]
  int v104; // [esp+18h] [ebp-164h]
  unsigned __int8 v105; // [esp+2Dh] [ebp-14Fh]
  char v106; // [esp+2Eh] [ebp-14Eh]
  char v107; // [esp+2Fh] [ebp-14Dh]
  bool v108; // [esp+30h] [ebp-14Ch]
  unsigned __int8 v109; // [esp+31h] [ebp-14Bh]
  bool v110; // [esp+32h] [ebp-14Ah]
  char v111; // [esp+33h] [ebp-149h]
  bool v112; // [esp+34h] [ebp-148h]
  char v113; // [esp+35h] [ebp-147h]
  char v114; // [esp+36h] [ebp-146h]
  char v115; // [esp+37h] [ebp-145h]
  _DWORD *l; // [esp+38h] [ebp-144h]
  char *v117; // [esp+3Ch] [ebp-140h]
  int v118; // [esp+40h] [ebp-13Ch]
  const char *v119; // [esp+44h] [ebp-138h]
  int v120; // [esp+48h] [ebp-134h]
  unsigned int v121; // [esp+4Ch] [ebp-130h]
  int *v122; // [esp+50h] [ebp-12Ch]
  char *v123; // [esp+54h] [ebp-128h]
  char *v124; // [esp+58h] [ebp-124h]
  unsigned int i; // [esp+5Ch] [ebp-120h]
  char *j; // [esp+60h] [ebp-11Ch]
  unsigned int k; // [esp+64h] [ebp-118h]
  unsigned int m; // [esp+68h] [ebp-114h]
  int v129; // [esp+6Ch] [ebp-110h]
  unsigned __int8 **v130; // [esp+70h] [ebp-10Ch]
  char *v131; // [esp+74h] [ebp-108h]
  FILE *v132; // [esp+78h] [ebp-104h]
  const char *v133; // [esp+7Ch] [ebp-100h]
  char *v134; // [esp+80h] [ebp-FCh]
  int v135; // [esp+84h] [ebp-F8h]
  char v136; // [esp+90h] [ebp-ECh]
  int s[4]; // [esp+B8h] [ebp-C4h]
  int v138; // [esp+C8h] [ebp-B4h]
  int v139; // [esp+CCh] [ebp-B0h]
  char v140; // [esp+D0h] [ebp-ACh]
  char v141; // [esp+D1h] [ebp-ABh]
  char v142; // [esp+D2h] [ebp-AAh]
  unsigned __int8 v143; // [esp+D3h] [ebp-A9h]
  char v144; // [esp+D4h] [ebp-A8h]
  char v145; // [esp+D5h] [ebp-A7h]
  char v146; // [esp+D6h] [ebp-A6h]
  char v147; // [esp+D7h] [ebp-A5h]
  char v148; // [esp+D8h] [ebp-A4h]
  int longind; // [esp+E0h] [ebp-9Ch]
  int *v150; // [esp+E4h] [ebp-98h]
  int v151; // [esp+164h] [ebp-18h]

  v105 = 0;
  v118 = 0;
  v106 = 0;
  v107 = 0;
  v119 = 0;
  v108 = 0;
  v120 = 0;
  v121 = 0;
  v112 = getenv("POSIXLY_CORRECT") != 0;
  v129 = sub_805A1BA();
  v2 = v129 <= 200111 || v129 > 200808;
  v109 = v2;
  v123 = 0;
  v124 = 0;
  sub_805A218(*argv);
  v110 = setlocale(6, &::s) != 0;
  bindtextdomain("coreutils", "/home/hwangdz/coreutils/coreutils-8.28/install_m32/share/locale");
  textdomain("coreutils");
  sub_804B926(2);
  byte_806BE39 = sub_8057B3E(3);
  byte_806BE3A = sub_8057B3E(2);
  v3 = (unsigned __int8 **)localeconv();
  v130 = v3;
  v4 = sub_804B939(**v3);
  dword_806BE31 = v4;
  if ( !v4 || (*v130)[1] )
    dword_806BE31 = 46;
  v5 = sub_804B939(*v130[1]);
  dword_806BE35 = v5;
  if ( !v5 || v130[1][1] )
    dword_806BE35 = -1;
  byte_806C264 = 0;
  sub_804CFEB();
  sigemptyset(&set);
  for ( i = 0; i <= 0xA; ++i )
  {
    sigaction(sig[i], 0, (struct sigaction *)&longind);
    if ( longind != 1 )
      sigaddset(&set, sig[i]);
  }
  longind = (int)sub_80541A0;
  qmemcpy(&v150, &set, 0x80u);
  v151 = 0;
  i = 0;
  dword_806B338 = (int)&loc_805462C;
  sub_8061791(0, &v150);
  do
  {
    v99 = sig[i];
    if ( sigismember(&set, v99) )
      sigaction(sig[i], (const struct sigaction *)&longind, 0);
    ++i;
  }
  while ( i <= 0xA );
  signal(17, 0);
  sub_80614BE((int)sub_804C3DF);
  sub_805434E(s);
  s[0] = -1;
  v122 = (int *)sub_805E3D6(argc, 4u);
  while ( 1 )
  {
    longind = -1;
    if ( v118 == -1
      || v112
      && v121
      && (v109 != 1
       || v106
       || optind == argc
       || *argv[optind] != 45
       || argv[optind][1] != 111
       || !argv[optind][2] && optind + 1 == argc) )
    {
      break;
    }
    v118 = getopt_long(argc, argv, "-bcCdfghik:mMno:rRsS:t:T:uVy:z", &longopts, &longind);
    if ( v118 == -1 )
      break;
    switch ( v118 )
    {
      case 4294967165:
        v104 = 0;
        v103 = "Paul Eggert";
        v102 = "Mike Haertel";
        sub_805E336(
          off_806B458,
          v7,
          stdout,
          (int)"sort",
          (int)"GNU coreutils",
          off_806B458,
          "Mike Haertel",
          "Paul Eggert",
          0);
        exit(0);
        return result;
      case 4294967166:
        sub_804BD62(0);
        return result;
      case 1:
        l = 0;
        v9 = &loc_805482B;
        if ( *optarg != 43 )
          v9 = &loc_8054B4A;
        dword_806B298 = (int)v9;
        sub_8061B2F(v7, v6);
        if ( optind != argc )
        {
          v11 = &loc_8054868;
          if ( *argv[optind] != 45 )
            v11 = &loc_80548A8;
          dword_806B2FC = (int)v11;
          sub_80618E9(v10, 4 * optind);
          if ( (unsigned int)(argv[optind][1] - 48) <= 9 )
          {
            dword_806B2E8 = (int)&loc_80548AD;
            sub_8061957();
          }
        }
        v113 = 0;
        v12 = v109;
        v109 = v109 != 0;
        v13 = &loc_805491A;
        if ( !v12 )
          v13 = &loc_8054B4A;
        dword_806B2FC = (int)v13;
        sub_80618E9(v10, v12);
        l = sub_805434E(&v136);
        v117 = (char *)sub_80540AF((int)(optarg + 1), v14, optarg + 1, (int)l, 0);
        if ( v117 )
        {
          v17 = &loc_805497D;
          if ( *v117 != 46 )
            v17 = &loc_80549A3;
          dword_806B270 = (int)v17;
          sub_8061C11(v16, v15);
          v117 = (char *)sub_80540AF((int)(l + 1), v18, v117 + 1, (int)(l + 1), 0);
        }
        if ( !*l && !l[1] )
          *l = -1;
        if ( v117 && !*sub_80541CB(v15, v16, v117, (int)l, 0) )
        {
          if ( v113 )
          {
            v20 = optind++;
            v131 = argv[v20];
            v21 = (char *)sub_80540AF((int)(l + 2), v19, v131 + 1, (int)(l + 2), "invalid number after '-'");
            v117 = v21;
            v22 = v21 == 0;
            v23 = &loc_8054A6A;
            if ( !v22 )
              v23 = &loc_8054A8E;
            dword_806B284 = (int)v23;
            sub_8061B9D();
            __assert_fail("s", "src/sort.c", 0x110Du, "main");
          }
          *((_BYTE *)l + 33) = 1;
          sub_8053EF0(l);
        }
        else
        {
          l = 0;
        }
        if ( !l )
        {
          v24 = v121++;
          v122[v24] = (int)optarg;
        }
        continue;
      case 67:
      case 99:
        goto LABEL_71;
      case 77:
      case 82:
      case 86:
      case 98:
      case 100:
      case 102:
      case 103:
      case 104:
      case 105:
      case 110:
      case 114:
        goto LABEL_66;
      case 83:
        goto LABEL_113;
      case 84:
        sub_804CE18((int)optarg);
        continue;
      case 107:
        v32 = (char *)sub_805434E(&v136);
        l = v32;
        v99 = (int)v32;
        v117 = (char *)sub_80540AF(v99, v33, optarg, v99, "invalid number at field start");
        v34 = (*l)--;
        v22 = v34 == 0;
        v35 = &loc_8054D6C;
        if ( !v22 )
          v35 = &loc_8054D81;
        dword_806B2C0 = (int)v35;
        sub_8061A43();
        sub_8053F3D((int)optarg, "field number is zero");
        v38 = &loc_8054DA5;
        if ( *v117 != 46 )
          v38 = &loc_8054DF5;
        dword_806B324 = (int)v38;
        sub_8061801(v37, v36, v98);
        v117 = (char *)sub_80540AF((int)(l + 1), v39, v117 + 1, (int)(l + 1), "invalid number after '.'");
        v40 = l[1];
        v41 = v40 - 1;
        v42 = (int)l;
        l[1] = v40 - 1;
        if ( !v40 )
          sub_8053F3D((int)optarg, "character offset is zero");
        if ( !*l && !l[1] )
          *l = -1;
        v117 = sub_80541CB(v42, v41, v117, (int)l, 0);
        if ( *v117 == 44 )
        {
          v117 = (char *)sub_80540AF((int)(l + 2), v43, v117 + 1, (int)(l + 2), "invalid number after ','");
          v44 = l[2];
          v45 = v44 - 1;
          v46 = (int)l;
          l[2] = v44 - 1;
          if ( !v44 )
            sub_8053F3D((int)optarg, "field number is zero");
          if ( *v117 == 46 )
            v117 = (char *)sub_80540AF((int)(l + 3), v45, v117 + 1, (int)(l + 3), "invalid number after '.'");
          v117 = sub_80541CB(v46, v45, v117, (int)l, 1);
        }
        else
        {
          l[2] = -1;
          l[3] = 0;
        }
        v47 = &loc_8054F1F;
        if ( !*v117 )
          v47 = &loc_8054F34;
        dword_806B370 = (int)v47;
        sub_8061638();
        sub_8053F3D((int)optarg, "stray character in field spec");
        sub_8053EF0(l);
        continue;
      case 109:
        v107 = 1;
        continue;
      case 111:
        goto LABEL_103;
      case 115:
        byte_806C262 = 1;
        dword_806B25C = (int)&loc_80552F1;
        sub_8061C89(v7, v6);
LABEL_113:
        sub_804D47B((char)v118, (int)optarg, longind, (char)v118, optarg);
        continue;
      case 116:
        v111 = *optarg;
        if ( !v111 )
        {
          v53 = gettext("empty tab");
          error(2, 0, v53);
        }
        if ( optarg[1] )
        {
          if ( !strcmp(optarg, "\\0") )
          {
            v111 = 0;
          }
          else
          {
            v54 = (char *)sub_805BF80(optarg);
            v55 = gettext("multi-character tab %s");
            v101 = v54;
            error(2, 0, v55, v54);
          }
        }
        v56 = &loc_8055162;
        if ( dword_806B43C == 128 )
          v56 = &loc_80551AD;
        dword_806B2C0 = (int)v56;
        sub_8061A43();
        v58 = &loc_8055189;
        if ( v111 == dword_806B43C )
          v58 = &loc_80551AD;
        dword_806B270 = (int)v58;
        sub_8061C11(v57, v111);
        v59 = gettext("incompatible tabs");
        error(2, 0, v59);
        dword_806B43C = v111;
        continue;
      case 117:
        byte_806C263 = 1;
        continue;
      case 121:
        v60 = argv[optind + 0x3FFFFFFF];
        v61 = &loc_8055241;
        if ( v60 != optarg )
          v61 = &loc_8055283;
        dword_806B220 = (int)v61;
        sub_8061DE3(v7, v60);
        for ( j = optarg; (unsigned int)(*j - 48) <= 9; ++j )
          ;
        optind -= *j != 0;
        continue;
      case 122:
        byte_806B3B8 = 0;
        continue;
      case 128:
        goto LABEL_67;
      case 129:
        if ( arg )
        {
          v22 = strcmp(arg, optarg) == 0;
          v30 = &loc_8054CBF;
          if ( v22 )
            v30 = &loc_8054CE3;
          dword_806B2AC = (int)v30;
          sub_8061AB5(v29, v28);
          v31 = gettext("multiple compress programs specified");
          error(2, 0, v31);
        }
        arg = optarg;
        continue;
      case 130:
        byte_806C26D = 1;
        continue;
      case 131:
        v123 = optarg;
        continue;
      case 132:
        sub_804D1F1((char)v118, (int)optarg, longind, v118, optarg);
        dword_806B324 = (int)&loc_80552F1;
        sub_8061801(v49, v48, v98);
LABEL_103:
        v50 = &loc_8054FAA;
        if ( !v124 )
          v50 = &loc_8054FE7;
        dword_806B270 = (int)v50;
        sub_8061C11(v7, v6);
        if ( strcmp(v124, optarg) )
        {
          v51 = gettext("multiple output files specified");
          error(2, 0, v51);
        }
        v124 = optarg;
        dword_806B310 = (int)&loc_80552F1;
        sub_8061877();
        goto LABEL_108;
      case 133:
LABEL_108:
        if ( v119 && strcmp(v119, optarg) )
        {
          v52 = gettext("multiple random sources specified");
          error(2, 0, v52);
        }
        v119 = optarg;
        break;
      case 134:
        v118 = byte_80634E0[sub_8055E83((int)"--sort", optarg, (int)&off_80634C4, (int)byte_80634E0, 1u, off_806B45C)];
LABEL_66:
        v114 = v118;
        v115 = 0;
        sub_80541CB(v6, v7, &v114, (int)s, 2);
        dword_806B324 = (int)&loc_80552F1;
        sub_8061801(v26, v25, v98);
LABEL_67:
        if ( optarg )
          v27 = aCccgeneralNume[sub_8055E83(
                                  (int)"--check",
                                  optarg,
                                  (int)off_806347C,
                                  (int)"CCcgeneral-numeric",
                                  1u,
                                  off_806B45C)];
        else
          v27 = 99;
        v118 = v27;
LABEL_71:
        if ( v106 && v106 != v118 )
          sub_8053F8B((int)"cC");
        v106 = v118;
        break;
      case 135:
        v120 = sub_804D6EE(longind, (char)v118, optarg);
        break;
      default:
        sub_804BD62(2);
        return result;
    }
  }
  v8 = &loc_8054795;
  if ( argc > optind )
    v8 = &loc_80547A5;
  dword_806B2D4 = (int)v8;
  sub_80619CB();
  if ( v123 )
  {
    if ( v121 )
    {
      v99 = *v122;
      v62 = (char *)sub_805BBED(4, (char *)v99);
      v63 = gettext("extra operand %s");
      v101 = v62;
      error(0, 0, v63, v62);
      v100 = gettext("file operands cannot be combined with --files0-from");
      fprintf(stderr, "%s\n", v100);
      sub_804BD62(2);
    }
    v132 = (FILE *)sub_804C778(v123, "r");
    sub_805CEDC(&longind);
    if ( !sub_805D23F(v132, (int)&longind) )
    {
      v64 = (char *)sub_805BBED(4, v123);
      v65 = gettext("cannot read file names from %s");
      v101 = v64;
      error(2, 0, v65, v64);
    }
    sub_804C7CB(v132, (int)v123);
    if ( longind )
    {
      free(v122);
      v122 = v150;
      v121 = longind;
      for ( k = 0; k < v121; ++k )
      {
        if ( !strcmp((const char *)v122[k], "-") )
        {
          v99 = v122[k];
          v66 = (char *)sub_805BBED(4, (char *)v99);
          v67 = gettext("when reading file names from stdin, no file name of %s allowed");
          v101 = v66;
          error(2, 0, v67, v66);
        }
        if ( !*(_BYTE *)v122[k] )
        {
          v133 = (const char *)(k + 1);
          v68 = (char *)sub_805BD48(0, 3, v123);
          v69 = gettext("%s:%lu: invalid zero-length file name");
          v102 = v133;
          v101 = v68;
          error(2, 0, v69, v68, v133);
        }
      }
    }
    else
    {
      v70 = (char *)sub_805BBED(4, v123);
      v71 = gettext("no input from %s");
      v101 = v70;
      error(2, 0, v71, v70);
    }
  }
  for ( l = (_DWORD *)dword_806C265; l; l = (_DWORD *)l[9] )
  {
    if ( (unsigned __int8)sub_804F6B3((int)l) )
    {
      v74 = &loc_80555C8;
      if ( *((_BYTE *)l + 31) == 1 )
        v74 = &loc_805566B;
      dword_806B220 = (int)v74;
      sub_8061DE3(v73, v72);
      l[4] = v138;
      l[5] = v139;
      *((_BYTE *)l + 24) = v140;
      *((_BYTE *)l + 25) = v141;
      *((_BYTE *)l + 30) = v146;
      *((_BYTE *)l + 26) = v142;
      *((_BYTE *)l + 28) = v144;
      *((_BYTE *)l + 29) = v145;
      *((_BYTE *)l + 32) = v148;
      *((_BYTE *)l + 27) = v143;
      *((_BYTE *)l + 31) = v147;
    }
    v108 = (v108 | *((unsigned __int8 *)l + 27)) != 0;
  }
  if ( !dword_806C265 && (unsigned __int8)sub_804F6B3((int)s) ^ 1 )
  {
    v105 = 1;
    sub_8053EF0(s);
    v108 = (v108 | v143) != 0;
  }
  sub_8053FBC();
  if ( byte_806C26D )
  {
    if ( !v106 )
    {
      v77 = &loc_8055725;
      if ( !v124 )
        v77 = &loc_805575E;
      dword_806B270 = (int)v77;
      sub_8061C11(v76, v75);
    }
    if ( v106 )
    {
      dword_806B220 = (int)&loc_805574D;
      sub_8061DE3(v76, v75);
    }
    byte_806B448 = 111;
    sub_8053F8B((int)&byte_806B448);
    if ( v110 )
      v110 = setlocale(3, &::s) != 0;
    v80 = &loc_80557A7;
    if ( v110 == 1 )
      v80 = &loc_80557D3;
    dword_806B2FC = (int)v80;
    sub_80618E9(v79, v78);
    v101 = gettext("failed to set locale");
    error(0, 0, "%s", v101);
    if ( byte_806BE39 )
    {
      v81 = setlocale(3, 0);
      v82 = (char *)sub_805BF80(v81);
      v83 = gettext("using %s sorting rules");
      v101 = v82;
      error(0, 0, v83, v82);
      dword_806B324 = (int)&loc_8055867;
      sub_8061801(v85, v84, v98);
    }
    v101 = gettext("using simple byte comparison");
    error(0, 0, "%s", v101);
    v99 = v105;
    sub_804F918(s);
  }
  byte_806C261 = v147;
  if ( v108 )
    sub_804EA38((int)v119);
  if ( !dword_806C259 )
  {
    v134 = getenv("TMPDIR");
    if ( v134 )
    {
      dword_806B234 = (int)&loc_80558E8;
      sub_8061D73();
    }
    sub_804CE18((int)"/tmp");
  }
  if ( !v121 )
  {
    v121 = 1;
    free(v122);
    v122 = (int *)sub_805E4FC(4u);
    *v122 = (int)"-";
  }
  if ( size )
  {
    v75 = 18 * dword_806B440;
    v86 = size;
    if ( 18 * dword_806B440 >= size )
      v86 = 18 * dword_806B440;
    size = v86;
  }
  if ( v106 )
  {
    if ( v121 > 1 )
    {
      v87 = (const char *)v106;
      v99 = v122[1];
      v88 = (char *)sub_805BBED(4, (char *)v99);
      v89 = gettext("extra operand %s not allowed with -%c");
      v102 = v87;
      v101 = v88;
      error(2, 0, v89, v88, v87);
    }
    v90 = &loc_80559CC;
    if ( !v124 )
      v90 = &loc_80559E2;
    dword_806B35C = (int)v90;
    sub_80616AA(v76, v75);
    byte_806B452 = v106;
    sub_8053F8B((int)&byte_806B452);
    if ( (unsigned __int8)sub_8051166((char *)*v122, v106) )
    {
      dword_806B370 = (int)&loc_8055A1E;
      sub_8061638();
    }
    result = 1;
  }
  else
  {
    sub_8053549((int)v122, v121);
    sub_8053600((int)v124);
    v94 = &loc_8055A63;
    if ( !v107 )
      v94 = &loc_8055AE9;
    dword_806B2FC = (int)v94;
    sub_80618E9(v93, v92);
    v135 = sub_805E5DA(v121, 8u);
    for ( m = 0; m < v121; ++m )
      *(_DWORD *)(v135 + 8 * m) = v122[m];
    sub_8053666(v135, 0, v121, v124);
    if ( byte_806C264 && sub_805F563(stdin) == -1 )
    {
      v95 = gettext("close failed");
      sub_804BCE7(v97, v96, (int)v95, (int)"-");
    }
    result = 0;
  }
  return result;
}
// 8061638: using guessed type int sub_8061638(void);
// 80616AA: using guessed type int __fastcall sub_80616AA(_DWORD, _DWORD);
// 8061791: using guessed type int __fastcall sub_8061791(_DWORD, _DWORD);
// 8061877: using guessed type int sub_8061877(void);
// 80618E9: using guessed type int __fastcall sub_80618E9(_DWORD, _DWORD);
// 8061957: using guessed type int sub_8061957(void);
// 80619CB: using guessed type int sub_80619CB(void);
// 8061A43: using guessed type int sub_8061A43(void);
// 8061AB5: using guessed type int __fastcall sub_8061AB5(_DWORD, _DWORD);
// 8061B2F: using guessed type int __fastcall sub_8061B2F(_DWORD, _DWORD);
// 8061B9D: using guessed type int sub_8061B9D(void);
// 8061C11: using guessed type int __fastcall sub_8061C11(_DWORD, _DWORD);
// 8061C89: using guessed type int __fastcall sub_8061C89(_DWORD, _DWORD);
// 8061D73: using guessed type int sub_8061D73(void);
// 8061DE3: using guessed type int __fastcall sub_8061DE3(_DWORD, _DWORD);
// 806347C: using guessed type char *off_806347C[3];
// 80634C4: using guessed type void *off_80634C4;
// 806B220: using guessed type int dword_806B220;
// 806B234: using guessed type int dword_806B234;
// 806B25C: using guessed type int dword_806B25C;
// 806B270: using guessed type int dword_806B270;
// 806B284: using guessed type int dword_806B284;
// 806B298: using guessed type int dword_806B298;
// 806B2AC: using guessed type int dword_806B2AC;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B2D4: using guessed type int dword_806B2D4;
// 806B2E8: using guessed type int dword_806B2E8;
// 806B2FC: using guessed type int dword_806B2FC;
// 806B310: using guessed type int dword_806B310;
// 806B324: using guessed type int dword_806B324;
// 806B338: using guessed type int dword_806B338;
// 806B35C: using guessed type int dword_806B35C;
// 806B370: using guessed type int dword_806B370;
// 806B3B8: using guessed type char byte_806B3B8;
// 806B43C: using guessed type int dword_806B43C;
// 806B448: using guessed type char byte_806B448;
// 806B452: using guessed type char byte_806B452;
// 806B500: using guessed type int optind;
// 806BE31: using guessed type int dword_806BE31;
// 806BE35: using guessed type int dword_806BE35;
// 806BE39: using guessed type char byte_806BE39;
// 806BE3A: using guessed type char byte_806BE3A;
// 806C259: using guessed type int dword_806C259;
// 806C261: using guessed type char byte_806C261;
// 806C262: using guessed type char byte_806C262;
// 806C263: using guessed type char byte_806C263;
// 806C264: using guessed type char byte_806C264;
// 806C265: using guessed type int dword_806C265;
// 806C26D: using guessed type char byte_806C26D;

//----- (08055BA8) --------------------------------------------------------
void __noreturn sub_8055BA8()
{
  sub_804BD62(1);
}

//----- (08055BBC) --------------------------------------------------------
int __cdecl sub_8055BBC(char *s, int a2)
{
  int v2; // edx
  int v3; // ecx
  void *v5; // eax
  signed int i; // [esp+14h] [ebp-14h]
  signed int v7; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]

  v7 = -1;
  n = strlen(s);
  for ( i = 0; *(_DWORD *)(4 * i + a2); ++i )
  {
    if ( !strncmp(*(const char **)(4 * i + a2), s, n) )
    {
      if ( strlen(*(const char **)(4 * i + a2)) == n )
        return i;
      v5 = &loc_8055C5B;
      if ( v7 != -1 )
        v5 = &loc_8055C63;
      dword_806B35C = (int)v5;
      sub_80616AA(v3, v2);
      v7 = i;
    }
  }
  return v7;
}
// 80616AA: using guessed type int __fastcall sub_80616AA(_DWORD, _DWORD);
// 806B35C: using guessed type int dword_806B35C;

//----- (08055CE9) --------------------------------------------------------
void __cdecl sub_8055CE9(char *a1, char *a2, int a3)
{
  char *v3; // eax
  char *format; // ST2C_4
  void *v5; // ebx
  void *v6; // eax

  if ( a3 == -1 )
    v3 = gettext("invalid argument %s for %s");
  else
    v3 = gettext("ambiguous argument %s for %s");
  format = v3;
  v5 = sub_805BF5E(1, a1);
  v6 = sub_805BB72(0, 8, a2);
  error(0, 0, format, v6, v5);
}

//----- (08055D6C) --------------------------------------------------------
int __cdecl sub_8055D6C(int a1, int a2, size_t n)
{
  FILE *v3; // ebx
  char *v4; // eax
  void *v5; // eax
  void *v6; // eax
  int i; // [esp+18h] [ebp-10h]
  void *s1; // [esp+1Ch] [ebp-Ch]

  s1 = 0;
  v3 = stderr;
  v4 = gettext("Valid arguments are:");
  fputs_unlocked(v4, v3);
  for ( i = 0; *(_DWORD *)(4 * i + a1); ++i )
  {
    if ( i && !memcmp(s1, (const void *)(a2 + i * n), n) )
    {
      v6 = sub_805BF80(*(char **)(4 * i + a1));
      fprintf(stderr, ", %s", v6);
    }
    else
    {
      v5 = sub_805BF80(*(char **)(4 * i + a1));
      fprintf(stderr, "\n  - %s", v5);
      s1 = (void *)(i * n + a2);
    }
  }
  return putc_unlocked(10, stderr);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (08055E83) --------------------------------------------------------
int __cdecl sub_8055E83(int a1, char *s, int a3, int a4, size_t n, int a6)
{
  int v7; // [esp+1Ch] [ebp-Ch]

  v7 = sub_8055BBC(s, a3);
  if ( v7 >= 0 )
    return v7;
  sub_8055CE9((char *)a1, s, v7);
  sub_8055D6C(a3, a4, n);
  ((void (*)(void))a6)();
  return -1;
}

//----- (08055F9C) --------------------------------------------------------
int sub_8055F9C()
{
  int v0; // edx
  int v1; // ecx
  void *v2; // eax
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  void *v6; // ebx
  int *v7; // eax
  int result; // eax
  char *v9; // [esp+2Ch] [ebp-Ch]

  if ( sub_80603C7(stdout) )
  {
    v2 = &loc_8055FDF;
    if ( byte_806C3B9 != 1 )
      v2 = &loc_8055FEF;
    dword_806B25C = (int)v2;
    sub_8061C89(v1, v0);
    if ( *__errno_location() != 32 )
    {
      v9 = gettext("write error");
      v5 = &loc_8056020;
      if ( !dword_806C3B5 )
        v5 = &loc_805605B;
      dword_806B25C = (int)v5;
      sub_8061C89(v4, v3);
      v6 = sub_805BD0B((char *)dword_806C3B5);
      v7 = __errno_location();
      error(0, *v7, "%s: %s", v6, v9);
      _exit(status);
    }
  }
  result = sub_80603C7(stderr);
  if ( result )
    _exit(status);
  return result;
}
// 8061C89: using guessed type int __fastcall sub_8061C89(_DWORD, _DWORD);
// 806B25C: using guessed type int dword_806B25C;
// 806C3B5: using guessed type int dword_806C3B5;
// 806C3B9: using guessed type char byte_806C3B9;

//----- (080560B2) --------------------------------------------------------
_DWORD *__cdecl sub_80560B2(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 1732584193;
  a1[1] = -271733879;
  a1[2] = -1732584194;
  a1[3] = 271733878;
  a1[5] = 0;
  a1[4] = a1[5];
  result = a1;
  a1[6] = 0;
  return result;
}

//----- (080560FE) --------------------------------------------------------
_DWORD *__cdecl sub_80560FE(_DWORD *a1, int a2)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = a2;
  return result;
}

//----- (0805610B) --------------------------------------------------------
_DWORD *__cdecl sub_805610B(int *a1, _DWORD *a2)
{
  sub_80560FE(a2, *a1);
  sub_80560FE(a2 + 1, a1[1]);
  sub_80560FE(a2 + 2, a1[2]);
  sub_80560FE(a2 + 3, a1[3]);
  return a2;
}

//----- (08056178) --------------------------------------------------------
_DWORD *__cdecl sub_8056178(int *a1, _DWORD *a2)
{
  signed int v2; // eax
  unsigned int v4; // [esp+18h] [ebp-10h]
  signed int v5; // [esp+1Ch] [ebp-Ch]

  v4 = a1[6];
  if ( v4 > 0x37 )
    v2 = 32;
  else
    v2 = 16;
  v5 = v2;
  a1[4] += v4;
  if ( a1[4] < v4 )
    ++a1[5];
  a1[v2 + 5] = 8 * a1[4];
  a1[v2 + 6] = *((_QWORD *)a1 + 2) >> 29;
  memcpy((char *)a1 + v4 + 28, &unk_80643D0, 4 * (v2 + 1073741822) - v4);
  sub_805663E(a1 + 7, 4 * v5, a1);
  return sub_805610B(a1, a2);
}

//----- (08056451) --------------------------------------------------------
int *__cdecl sub_8056451(void *src, size_t a2, int a3)
{
  int *result; // eax
  int v4; // eax
  int *v5; // eax
  size_t v6; // ST14_4
  size_t v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]

  result = *(int **)(a3 + 24);
  if ( result )
  {
    v8 = *(_DWORD *)(a3 + 24);
    v4 = a2;
    if ( 128 - v8 <= a2 )
      v4 = 128 - v8;
    n = v4;
    memcpy((void *)(v8 + a3 + 28), src, v4);
    *(_DWORD *)(a3 + 24) += n;
    if ( *(_DWORD *)(a3 + 24) > 0x40u )
    {
      sub_805663E((int *)(a3 + 28), *(_DWORD *)(a3 + 24) & 0xFFFFFFC0, (int *)a3);
      *(_DWORD *)(a3 + 24) &= 0x3Fu;
      memcpy((void *)(a3 + 28), (const void *)(a3 + 28 + ((v8 + n) & 0xFFFFFFC0)), *(_DWORD *)(a3 + 24));
    }
    src = (char *)src + n;
    result = (int *)n;
    a2 -= n;
  }
  if ( a2 > 0x3F )
  {
    result = (int *)((unsigned __int8)src & 3);
    if ( (unsigned __int8)src & 3 )
    {
      while ( a2 > 0x40 )
      {
        v5 = (int *)memcpy((void *)(a3 + 28), src, 0x40u);
        result = sub_805663E(v5, 0x40u, (int *)a3);
        src = (char *)src + 64;
        a2 -= 64;
      }
    }
    else
    {
      sub_805663E((int *)src, a2 & 0xFFFFFFC0, (int *)a3);
      result = (int *)(a2 & 0xFFFFFFC0);
      src = (char *)src + (a2 & 0xFFFFFFC0);
      a2 &= 0x3Fu;
    }
  }
  if ( a2 )
  {
    v6 = *(_DWORD *)(a3 + 24);
    memcpy((void *)(v6 + a3 + 28), src, a2);
    v7 = a2 + v6;
    if ( v7 > 0x3F )
    {
      sub_805663E((int *)(a3 + 28), 0x40u, (int *)a3);
      v7 -= 64;
      memcpy((void *)(a3 + 28), (const void *)(a3 + 92), v7);
    }
    result = (int *)a3;
    *(_DWORD *)(a3 + 24) = v7;
  }
  return result;
}

//----- (0805663E) --------------------------------------------------------
int *__cdecl sub_805663E(int *a1, unsigned int a2, int *a3)
{
  int *result; // eax
  int *v4; // [esp+Ch] [ebp-74h]
  int v5; // [esp+10h] [ebp-70h]
  int v6; // [esp+14h] [ebp-6Ch]
  int v7; // [esp+18h] [ebp-68h]
  int v8; // [esp+1Ch] [ebp-64h]
  unsigned int v9; // [esp+20h] [ebp-60h]
  unsigned int v10; // [esp+24h] [ebp-5Ch]
  unsigned int v11; // [esp+28h] [ebp-58h]
  int *v12; // [esp+2Ch] [ebp-54h]
  int v13; // [esp+30h] [ebp-50h]
  int v14; // [esp+34h] [ebp-4Ch]
  int v15; // [esp+38h] [ebp-48h]
  int v16; // [esp+3Ch] [ebp-44h]
  int v17; // [esp+40h] [ebp-40h]
  int v18; // [esp+44h] [ebp-3Ch]
  int v19; // [esp+48h] [ebp-38h]
  int v20; // [esp+4Ch] [ebp-34h]
  int v21; // [esp+50h] [ebp-30h]
  int v22; // [esp+54h] [ebp-2Ch]
  int v23; // [esp+58h] [ebp-28h]
  int v24; // [esp+5Ch] [ebp-24h]
  int v25; // [esp+60h] [ebp-20h]
  int v26; // [esp+64h] [ebp-1Ch]
  int v27; // [esp+68h] [ebp-18h]
  int v28; // [esp+6Ch] [ebp-14h]
  int v29; // [esp+70h] [ebp-10h]
  int v30; // [esp+74h] [ebp-Ch]
  int v31; // [esp+78h] [ebp-8h]
  int v32; // [esp+7Ch] [ebp-4h]
  int savedregs; // [esp+80h] [ebp+0h]

  v4 = a1;
  v9 = a2 >> 2;
  v10 = (unsigned int)&a1[a2 >> 2];
  v5 = *a3;
  v6 = a3[1];
  v7 = a3[2];
  v8 = a3[3];
  v11 = a2;
  a3[4] += a2;
  a3[5] += a3[4] < v11;
  dword_806B384 = (int)&loc_80572E9;
  sub_80615BE();
  do
  {
    v13 = v5;
    v14 = v6;
    v15 = v7;
    v16 = v8;
    v12 = &v18;
    v17 = *v4;
    v5 = (v8 ^ v6 & (v7 ^ v8)) + v17 + v5 - 680876936;
    ++v4;
    v5 = __ROR4__(v5, 25);
    v5 += v6;
    v12 = &v19;
    v18 = *v4;
    v8 = (v7 ^ v5 & (v6 ^ v7)) + v18 + v8 - 389564586;
    ++v4;
    v8 = __ROR4__(v8, 20);
    v8 += v5;
    v12 = &v20;
    v19 = *v4;
    v7 += (v6 ^ v8 & (v5 ^ v6)) + v19 + 606105819;
    ++v4;
    v7 = __ROR4__(v7, 15);
    v7 += v8;
    v12 = &v21;
    v20 = *v4;
    v6 = (v5 ^ v7 & (v8 ^ v5)) + v20 + v6 - 1044525330;
    ++v4;
    v6 = __ROR4__(v6, 10);
    v6 += v7;
    v12 = &v22;
    v21 = *v4;
    v5 = (v8 ^ v6 & (v7 ^ v8)) + v21 + v5 - 176418897;
    ++v4;
    v5 = __ROR4__(v5, 25);
    v5 += v6;
    v12 = &v23;
    v22 = *v4;
    v8 += (v7 ^ v5 & (v6 ^ v7)) + v22 + 1200080426;
    ++v4;
    v8 = __ROR4__(v8, 20);
    v8 += v5;
    v12 = &v24;
    v23 = *v4;
    v7 = (v6 ^ v8 & (v5 ^ v6)) + v23 + v7 - 1473231341;
    ++v4;
    v7 = __ROR4__(v7, 15);
    v7 += v8;
    v12 = &v25;
    v24 = *v4;
    v6 = (v5 ^ v7 & (v8 ^ v5)) + v24 + v6 - 45705983;
    ++v4;
    v6 = __ROR4__(v6, 10);
    v6 += v7;
    v12 = &v26;
    v25 = *v4;
    v5 += (v8 ^ v6 & (v7 ^ v8)) + v25 + 1770035416;
    ++v4;
    v5 = __ROR4__(v5, 25);
    v5 += v6;
    v12 = &v27;
    v26 = *v4;
    v8 = (v7 ^ v5 & (v6 ^ v7)) + v26 + v8 - 1958414417;
    ++v4;
    v8 = __ROR4__(v8, 20);
    v8 += v5;
    v12 = &v28;
    v27 = *v4;
    v7 = (v6 ^ v8 & (v5 ^ v6)) + v27 + v7 - 42063;
    ++v4;
    v7 = __ROR4__(v7, 15);
    v7 += v8;
    v12 = &v29;
    v28 = *v4;
    v6 = (v5 ^ v7 & (v8 ^ v5)) + v28 + v6 - 1990404162;
    ++v4;
    v6 = __ROR4__(v6, 10);
    v6 += v7;
    v12 = &v30;
    v29 = *v4;
    v5 += (v8 ^ v6 & (v7 ^ v8)) + v29 + 1804603682;
    ++v4;
    v5 = __ROR4__(v5, 25);
    v5 += v6;
    v12 = &v31;
    v30 = *v4;
    v8 = (v7 ^ v5 & (v6 ^ v7)) + v30 + v8 - 40341101;
    ++v4;
    v8 = __ROR4__(v8, 20);
    v8 += v5;
    v12 = &v32;
    v31 = *v4;
    v7 = (v6 ^ v8 & (v5 ^ v6)) + v31 + v7 - 1502002290;
    ++v4;
    v7 = __ROR4__(v7, 15);
    v7 += v8;
    v12 = &savedregs;
    v32 = *v4;
    v6 += (v5 ^ v7 & (v8 ^ v5)) + v32 + 1236535329;
    ++v4;
    v6 = __ROR4__(v6, 10);
    v6 += v7;
    v5 = v18 + (v7 ^ v8 & (v6 ^ v7)) + v5 - 165796510;
    v5 = __ROR4__(v5, 27);
    v5 += v6;
    v8 = v23 + (v6 ^ v7 & (v5 ^ v6)) + v8 - 1069501632;
    v8 = __ROR4__(v8, 23);
    v8 += v5;
    v7 += v28 + (v5 ^ v6 & (v8 ^ v5)) + 643717713;
    v7 = __ROR4__(v7, 18);
    v7 += v8;
    v6 = v17 + (v8 ^ v5 & (v7 ^ v8)) + v6 - 373897302;
    v6 = __ROR4__(v6, 12);
    v6 += v7;
    v5 = v22 + (v7 ^ v8 & (v6 ^ v7)) + v5 - 701558691;
    v5 = __ROR4__(v5, 27);
    v5 += v6;
    v8 += v27 + (v6 ^ v7 & (v5 ^ v6)) + 38016083;
    v8 = __ROR4__(v8, 23);
    v8 += v5;
    v7 = v32 + (v5 ^ v6 & (v8 ^ v5)) + v7 - 660478335;
    v7 = __ROR4__(v7, 18);
    v7 += v8;
    v6 = v21 + (v8 ^ v5 & (v7 ^ v8)) + v6 - 405537848;
    v6 = __ROR4__(v6, 12);
    v6 += v7;
    v5 += v26 + (v7 ^ v8 & (v6 ^ v7)) + 568446438;
    v5 = __ROR4__(v5, 27);
    v5 += v6;
    v8 = v31 + (v6 ^ v7 & (v5 ^ v6)) + v8 - 1019803690;
    v8 = __ROR4__(v8, 23);
    v8 += v5;
    v7 = v20 + (v5 ^ v6 & (v8 ^ v5)) + v7 - 187363961;
    v7 = __ROR4__(v7, 18);
    v7 += v8;
    v6 += v25 + (v8 ^ v5 & (v7 ^ v8)) + 1163531501;
    v6 = __ROR4__(v6, 12);
    v6 += v7;
    v5 = v30 + (v7 ^ v8 & (v6 ^ v7)) + v5 - 1444681467;
    v5 = __ROR4__(v5, 27);
    v5 += v6;
    v8 = v19 + (v6 ^ v7 & (v5 ^ v6)) + v8 - 51403784;
    v8 = __ROR4__(v8, 23);
    v8 += v5;
    v7 += v24 + (v5 ^ v6 & (v8 ^ v5)) + 1735328473;
    v7 = __ROR4__(v7, 18);
    v7 += v8;
    v6 = v29 + (v8 ^ v5 & (v7 ^ v8)) + v6 - 1926607734;
    v6 = __ROR4__(v6, 12);
    v6 += v7;
    v5 = v22 + (v8 ^ v6 ^ v7) + v5 - 378558;
    v5 = __ROR4__(v5, 28);
    v5 += v6;
    v8 = v25 + (v7 ^ v5 ^ v6) + v8 - 2022574463;
    v8 = __ROR4__(v8, 21);
    v8 += v5;
    v7 += v28 + (v6 ^ v8 ^ v5) + 1839030562;
    v7 = __ROR4__(v7, 16);
    v7 += v8;
    v6 = v31 + (v5 ^ v7 ^ v8) + v6 - 35309556;
    v6 = __ROR4__(v6, 9);
    v6 += v7;
    v5 = v18 + (v8 ^ v6 ^ v7) + v5 - 1530992060;
    v5 = __ROR4__(v5, 28);
    v5 += v6;
    v8 += v21 + (v7 ^ v5 ^ v6) + 1272893353;
    v8 = __ROR4__(v8, 21);
    v8 += v5;
    v7 = v24 + (v6 ^ v8 ^ v5) + v7 - 155497632;
    v7 = __ROR4__(v7, 16);
    v7 += v8;
    v6 = v27 + (v5 ^ v7 ^ v8) + v6 - 1094730640;
    v6 = __ROR4__(v6, 9);
    v6 += v7;
    v5 += v30 + (v8 ^ v6 ^ v7) + 681279174;
    v5 = __ROR4__(v5, 28);
    v5 += v6;
    v8 = v17 + (v7 ^ v5 ^ v6) + v8 - 358537222;
    v8 = __ROR4__(v8, 21);
    v8 += v5;
    v7 = v20 + (v6 ^ v8 ^ v5) + v7 - 722521979;
    v7 = __ROR4__(v7, 16);
    v7 += v8;
    v6 += v23 + (v5 ^ v7 ^ v8) + 76029189;
    v6 = __ROR4__(v6, 9);
    v6 += v7;
    v5 = v26 + (v8 ^ v6 ^ v7) + v5 - 640364487;
    v5 = __ROR4__(v5, 28);
    v5 += v6;
    v8 = v29 + (v7 ^ v5 ^ v6) + v8 - 421815835;
    v8 = __ROR4__(v8, 21);
    v8 += v5;
    v7 += v32 + (v6 ^ v8 ^ v5) + 530742520;
    v7 = __ROR4__(v7, 16);
    v7 += v8;
    v6 = v19 + (v5 ^ v7 ^ v8) + v6 - 995338651;
    v6 = __ROR4__(v6, 9);
    v6 += v7;
    v5 = v17 + (v7 ^ (v6 | ~v8)) + v5 - 198630844;
    v5 = __ROR4__(v5, 26);
    v5 += v6;
    v8 += v24 + (v6 ^ (v5 | ~v7)) + 1126891415;
    v8 = __ROR4__(v8, 22);
    v8 += v5;
    v7 = v31 + (v5 ^ (v8 | ~v6)) + v7 - 1416354905;
    v7 = __ROR4__(v7, 17);
    v7 += v8;
    v6 = v22 + (v8 ^ (v7 | ~v5)) + v6 - 57434055;
    v6 = __ROR4__(v6, 11);
    v6 += v7;
    v5 += v29 + (v7 ^ (v6 | ~v8)) + 1700485571;
    v5 = __ROR4__(v5, 26);
    v5 += v6;
    v8 = v20 + (v6 ^ (v5 | ~v7)) + v8 - 1894986606;
    v8 = __ROR4__(v8, 22);
    v8 += v5;
    v7 = v27 + (v5 ^ (v8 | ~v6)) + v7 - 1051523;
    v7 = __ROR4__(v7, 17);
    v7 += v8;
    v6 = v18 + (v8 ^ (v7 | ~v5)) + v6 - 2054922799;
    v6 = __ROR4__(v6, 11);
    v6 += v7;
    v5 += v25 + (v7 ^ (v6 | ~v8)) + 1873313359;
    v5 = __ROR4__(v5, 26);
    v5 += v6;
    v8 = v32 + (v6 ^ (v5 | ~v7)) + v8 - 30611744;
    v8 = __ROR4__(v8, 22);
    v8 += v5;
    v7 = v23 + (v5 ^ (v8 | ~v6)) + v7 - 1560198380;
    v7 = __ROR4__(v7, 17);
    v7 += v8;
    v6 += v30 + (v8 ^ (v7 | ~v5)) + 1309151649;
    v6 = __ROR4__(v6, 11);
    v6 += v7;
    v5 = v21 + (v7 ^ (v6 | ~v8)) + v5 - 145523070;
    v5 = __ROR4__(v5, 26);
    v5 += v6;
    v8 = v28 + (v6 ^ (v5 | ~v7)) + v8 - 1120210379;
    v8 = __ROR4__(v8, 22);
    v8 += v5;
    v7 += v19 + (v5 ^ (v8 | ~v6)) + 718787259;
    v7 = __ROR4__(v7, 17);
    v7 += v8;
    v6 = v26 + (v8 ^ (v7 | ~v5)) + v6 - 343485551;
    v6 = __ROR4__(v6, 11);
    v6 += v7;
    v5 += v13;
    v6 += v14;
    v7 += v15;
    v8 += v16;
  }
  while ( (unsigned int)v4 < v10 );
  *a3 = v5;
  a3[1] = v6;
  a3[2] = v7;
  result = a3;
  a3[3] = v8;
  return result;
}
// 80615BE: using guessed type int sub_80615BE(void);
// 806B384: using guessed type int dword_806B384;

//----- (0805731A) --------------------------------------------------------
int __cdecl sub_805731A(int a1, int a2, int a3, int a4, int a5, int a6)
{
  return posix_fadvise64(a1, a2, a3, a4, a5, a6);
}
// 8049E60: using guessed type int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0805736B) --------------------------------------------------------
int __usercall sub_805736B@<eax>(int a1@<edx>, int a2@<ecx>, FILE *stream, int a4)
{
  void *v4; // eax
  int v5; // eax

  v4 = &loc_8057390;
  if ( !stream )
    v4 = &locret_80573CA;
  dword_806B35C = (int)v4;
  sub_80616AA(a2, a1);
  v5 = fileno(stream);
  return sub_805731A(v5, 0, 0, 0, 0, a4);
}
// 80616AA: using guessed type int __fastcall sub_80616AA(_DWORD, _DWORD);
// 806B35C: using guessed type int dword_806B35C;

//----- (080573CC) --------------------------------------------------------
int __cdecl sub_80573CC(int a1)
{
  dword_806B348 = (int (__cdecl *)(_DWORD))sub_805755C;
  return ((int (__cdecl *)(int))sub_805755C)(a1);
}
// 805755C: using guessed type int sub_805755C();
// 806B348: using guessed type int (__cdecl *dword_806B348)(_DWORD);

//----- (0805757F) --------------------------------------------------------
int __cdecl sub_805757F(unsigned __int8 a1)
{
  if ( (unsigned __int8)sub_80601AD(a1) )
    return 0;
  if ( (unsigned __int8)sub_8060129(a1) )
    return a1;
  if ( a1 == 126 )
    return -1;
  return a1 + 256;
}

//----- (080575D0) --------------------------------------------------------
int __usercall sub_80575D0@<eax>(int a1@<edx>, int a2@<ecx>, int a3, unsigned int a4, int a5, unsigned int a6)
{
  void *v6; // eax
  void *v7; // eax
  bool v9; // zf
  int v10; // edx
  int v11; // ecx
  void *v12; // eax
  void *v13; // eax
  int v14; // edx
  int v15; // ecx
  void *v16; // eax
  int v17; // [esp+0h] [ebp-38h]
  unsigned int v18; // [esp+1Ch] [ebp-1Ch]
  unsigned int v19; // [esp+20h] [ebp-18h]
  int v20; // [esp+24h] [ebp-14h]
  int v21; // [esp+28h] [ebp-10h]
  int v22; // [esp+2Ch] [ebp-Ch]

  v18 = 0;
  v19 = 0;
  dword_806B220 = (int)&loc_805781F;
  sub_8061DE3(a2, a1);
  v20 = 0;
  while ( v18 < a4 )
  {
    v17 = *(char *)(a3 + v18);
    if ( !((unsigned __int8)sub_80601AD(v17) ^ 1) )
      break;
    v6 = &loc_8057628;
    if ( v18 == a4 )
      v6 = &loc_8057640;
    dword_806B2C0 = (int)v6;
    sub_8061A43();
    v17 = *(unsigned __int8 *)(a3 + v18);
    v21 = sub_805757F(v17);
    v7 = &loc_8057669;
    if ( v19 == a6 )
      v7 = &loc_8057681;
    dword_806B2C0 = (int)v7;
    sub_8061A43();
    v17 = *(unsigned __int8 *)(a5 + v19);
    v22 = sub_805757F(v17);
    if ( v21 != v22 )
      return v21 - v22;
    ++v18;
    ++v19;
  }
  if ( v19 < a6 )
  {
    v17 = *(char *)(a5 + v19);
    v9 = (unsigned __int8)sub_80601AD(v17) == 1;
    v12 = &loc_805770F;
    if ( !v9 )
      v12 = &loc_8057607;
    dword_806B35C = (int)v12;
    sub_80616AA(v11, v10);
  }
  while ( *(_BYTE *)(a3 + v18) == 48 )
    ++v18;
  while ( *(_BYTE *)(a5 + v19) == 48 )
    ++v19;
  while ( 1 )
  {
    v17 = *(char *)(a3 + v18);
    if ( !(unsigned __int8)sub_80601AD(v17) )
      break;
    v17 = *(char *)(a5 + v19);
    if ( !(unsigned __int8)sub_80601AD(v17) )
      break;
    v13 = &loc_805775A;
    if ( v20 )
      v13 = &loc_805777D;
    dword_806B220 = (int)v13;
    sub_8061DE3(v15, v14);
    v20 = *(char *)(a3 + v18++) - *(char *)(a5 + v19++);
  }
  v17 = *(char *)(a3 + v18);
  v9 = (unsigned __int8)sub_80601AD(v17) == 0;
  v16 = &loc_80577EC;
  if ( v9 )
    v16 = &loc_80577F3;
  dword_806B2E8 = (int)v16;
  sub_8061957();
  return 1;
}
// 80575D0: could not find valid save-restore pair for ebx
// 80616AA: using guessed type int __fastcall sub_80616AA(_DWORD, _DWORD);
// 8061957: using guessed type int sub_8061957(void);
// 8061A43: using guessed type int sub_8061A43(void);
// 8061DE3: using guessed type int __fastcall sub_8061DE3(_DWORD, _DWORD);
// 806B220: using guessed type int dword_806B220;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B2E8: using guessed type int dword_806B2E8;
// 806B35C: using guessed type int dword_806B35C;

//----- (0805783E) --------------------------------------------------------
int __cdecl sub_805783E(char *s1, char *s2)
{
  bool v3; // zf
  int v4; // edx
  int v5; // ecx
  void *v6; // eax
  int v7; // edx
  int v8; // ecx
  int v9; // edx
  int v10; // ecx
  void *v11; // eax
  int v12; // [esp+20h] [ebp-18h]

  v12 = strcmp(s1, s2);
  if ( !v12 )
  {
    dword_806B2C0 = (int)&locret_8057B3C;
    sub_8061A43();
  }
  if ( !*s1 )
    return -1;
  if ( !*s2 )
    return 1;
  if ( !strcmp(".", s1) )
    return -1;
  v3 = strcmp(".", s2) == 0;
  v6 = &loc_80578F4;
  if ( !v3 )
    v6 = &loc_8057910;
  dword_806B220 = (int)v6;
  sub_8061DE3(v5, v4);
  dword_806B35C = (int)&locret_8057B3C;
  sub_80616AA(v8, v7);
  v3 = strcmp("..", s1) == 0;
  v11 = &loc_8057940;
  if ( !v3 )
    v11 = &loc_805794A;
  dword_806B25C = (int)v11;
  sub_8061C89(v10, v9);
  return -1;
}
// 805783E: could not find valid save-restore pair for ebx
// 80616AA: using guessed type int __fastcall sub_80616AA(_DWORD, _DWORD);
// 8061A43: using guessed type int sub_8061A43(void);
// 8061C89: using guessed type int __fastcall sub_8061C89(_DWORD, _DWORD);
// 8061DE3: using guessed type int __fastcall sub_8061DE3(_DWORD, _DWORD);
// 806B220: using guessed type int dword_806B220;
// 806B25C: using guessed type int dword_806B25C;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B35C: using guessed type int dword_806B35C;

//----- (08057B3E) --------------------------------------------------------
int __cdecl sub_8057B3E(int category)
{
  char *v1; // eax
  bool v2; // zf
  void *v3; // eax
  unsigned __int8 v5; // [esp+1Bh] [ebp-Dh]
  char *s1; // [esp+1Ch] [ebp-Ch]

  v5 = 1;
  v1 = setlocale(category, 0);
  s1 = v1;
  v2 = v1 == 0;
  v3 = &loc_8057B7D;
  if ( v2 )
    v3 = &loc_8057BAF;
  dword_806B284 = (int)v3;
  sub_8061B9D();
  if ( !strcmp(s1, "C") || !strcmp(s1, "POSIX") )
    v5 = 0;
  return v5;
}
// 8061B9D: using guessed type int sub_8061B9D(void);
// 806B284: using guessed type int dword_806B284;

//----- (08057BB5) --------------------------------------------------------
int __cdecl sub_8057BB5(int a1)
{
  return *(_DWORD *)(a1 + 8);
}

//----- (08057BC0) --------------------------------------------------------
int __cdecl sub_8057BC0(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (08057BCB) --------------------------------------------------------
int __cdecl sub_8057BCB(int a1)
{
  return *(_DWORD *)(a1 + 16);
}

//----- (08057BD6) --------------------------------------------------------
unsigned int __usercall sub_8057BD6@<eax>(int a1@<edx>, int a2@<ecx>, int a3)
{
  _DWORD *i; // [esp+0h] [ebp-10h]
  unsigned int v5; // [esp+4h] [ebp-Ch]
  _DWORD *v6; // [esp+8h] [ebp-8h]
  unsigned int v7; // [esp+Ch] [ebp-4h]

  v5 = 0;
  for ( i = *(_DWORD **)a3; *(_DWORD *)(a3 + 4) > (unsigned int)i; i += 2 )
  {
    if ( *i )
    {
      v6 = i;
      v7 = 1;
      dword_806B220 = (int)&loc_8057C1E;
      sub_8061DE3(a2, a1);
      do
      {
        ++v7;
        v6 = (_DWORD *)v6[1];
      }
      while ( v6 );
      if ( v7 > v5 )
        v5 = v7;
    }
  }
  return v5;
}
// 8061DE3: using guessed type int __fastcall sub_8061DE3(_DWORD, _DWORD);
// 806B220: using guessed type int dword_806B220;

//----- (08057DCE) --------------------------------------------------------
int __cdecl sub_8057DCE(int a1, int a2)
{
  unsigned int v3; // [esp+1Ch] [ebp-Ch]

  v3 = (*(int (__cdecl **)(int, _DWORD))(a1 + 24))(a2, *(_DWORD *)(a1 + 8));
  if ( *(_DWORD *)(a1 + 8) <= v3 )
    abort();
  return 8 * v3 + *(_DWORD *)a1;
}

//----- (08058130) --------------------------------------------------------
bool __cdecl sub_8058130(unsigned int a1)
{
  void *v1; // eax

  if ( a1 > 9 )
  {
    v1 = &loc_805818C;
    if ( a1 % 3 )
      v1 = &loc_8058149;
    dword_806B2C0 = (int)v1;
    sub_8061A43();
  }
  return a1 % 3 != 0;
}
// 8061A43: using guessed type int sub_8061A43(void);
// 806B2C0: using guessed type int dword_806B2C0;

//----- (080581A0) --------------------------------------------------------
unsigned int __usercall sub_80581A0@<eax>(int a1@<edx>, int a2@<ecx>, unsigned int a3)
{
  bool v3; // zf
  int v4; // edx
  int v5; // ecx
  void *v6; // eax
  unsigned int v8; // [esp+Ch] [ebp+8h]

  if ( a3 <= 9 )
    a3 = 10;
  dword_806B2AC = (int)&loc_80581D2;
  sub_8061AB5(a2, a1);
  v8 = (a3 | 1) + 2;
  if ( v8 != -1 )
  {
    v3 = sub_8058130(v8) == 1;
    v6 = &loc_8058203;
    if ( !v3 )
      v6 = &loc_80581CE;
    dword_806B2FC = (int)v6;
    sub_80618E9(v5, v4);
  }
  return v8;
}
// 80618E9: using guessed type int __fastcall sub_80618E9(_DWORD, _DWORD);
// 8061AB5: using guessed type int __fastcall sub_8061AB5(_DWORD, _DWORD);
// 806B2AC: using guessed type int dword_806B2AC;
// 806B2FC: using guessed type int dword_806B2FC;

//----- (0805823F) --------------------------------------------------------
unsigned int __cdecl sub_805823F(int a1, unsigned int a2)
{
  return sub_805FFE0(a1, 3) % a2;
}

//----- (0805826A) --------------------------------------------------------
bool __cdecl sub_805826A(int a1, int a2)
{
  return a1 == a2;
}

//----- (08058278) --------------------------------------------------------
signed int __cdecl sub_8058278(int a1)
{
  int v2; // [esp+8h] [ebp-8h]

  v2 = *(_DWORD *)(a1 + 20);
  if ( (_UNKNOWN *)v2 == &unk_8064420 )
    return 1;
  if ( *(float *)(v2 + 8) > 0.1
    && 1.0 - 0.1 > *(float *)(v2 + 8)
    && *(float *)(v2 + 12) > 0.1 + 1.0
    && *(float *)v2 >= 0.0
    && *(float *)(v2 + 4) > *(float *)v2 + 0.1
    && *(float *)(v2 + 4) <= 1.0
    && *(float *)(v2 + 8) > *(float *)v2 + 0.1 )
  {
    return 1;
  }
  *(_DWORD *)(a1 + 20) = &unk_8064420;
  return 0;
}

//----- (08058334) --------------------------------------------------------
int __cdecl sub_8058334(unsigned int a1, int a2)
{
  bool v2; // zf
  float v3; // ST24_4

  v2 = *(_BYTE *)(a2 + 16) == 1;
  dword_806B348 = (int (__cdecl *)(_DWORD))&loc_80583D3;
  if ( !v2 )
  {
    v3 = (long double)a1 / *(float *)(a2 + 8);
    dword_806B348 = (int (__cdecl *)(_DWORD))sub_80583B1;
    if ( v3 >= 4294967300.0 )
      dword_806B348 = (int (__cdecl *)(_DWORD))&locret_8058417;
  }
  return dword_806B348(a1);
}
// 80583B1: using guessed type int sub_80583B1();
// 806B348: using guessed type int (__cdecl *dword_806B348)(_DWORD);

//----- (080583B1) --------------------------------------------------------
#error "80583D9: call analysis failed (funcsize=28)"

//----- (08058414) --------------------------------------------------------
#error "8058418: positive sp value has been found (funcsize=0)"

//----- (08058419) --------------------------------------------------------
int __cdecl sub_8058419(unsigned int a1, void *a2)
{
  bool v3; // zf
  void *v4; // eax
  int v5; // edx
  int v6; // ecx
  void *v7; // eax
  int v8; // ecx
  void *v9; // edx
  void *v10; // eax
  _DWORD *ptr; // [esp+1Ch] [ebp-Ch]

  ptr = malloc(0x28u);
  if ( !ptr )
    return 0;
  if ( !a2 )
    a2 = &unk_8064420;
  ptr[5] = a2;
  v3 = (unsigned __int8)sub_8058278((int)ptr) == 1;
  v4 = &loc_8058499;
  if ( v3 )
    v4 = &loc_80584B0;
  dword_806B2C0 = (int)v4;
  sub_8061A43();
  dword_806B35C = (int)&loc_805856C;
  sub_80616AA(v6, v5);
  ptr[2] = sub_8058334(a1, (int)a2);
  if ( ptr[2] )
  {
    v7 = calloc(ptr[2], 8u);
    v9 = v7;
    *ptr = v7;
    v10 = &loc_8058516;
    if ( *ptr )
      v10 = &loc_8058518;
    dword_806B248 = (int)v10;
    sub_8061CFB(v8, v9);
  }
  free(ptr);
  return 0;
}
// 8058419: could not find valid save-restore pair for ebx
// 80616AA: using guessed type int __fastcall sub_80616AA(_DWORD, _DWORD);
// 8061A43: using guessed type int sub_8061A43(void);
// 8061CFB: using guessed type int __fastcall sub_8061CFB(_DWORD, _DWORD);
// 806B248: using guessed type int dword_806B248;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B35C: using guessed type int dword_806B35C;

//----- (08058794) --------------------------------------------------------
void *__cdecl sub_8058794(int a1)
{
  int v2; // [esp+1Ch] [ebp-Ch]

  if ( !*(_DWORD *)(a1 + 36) )
    return malloc(8u);
  v2 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(v2 + 4);
  return (void *)v2;
}

//----- (080587CF) --------------------------------------------------------
int __cdecl sub_80587CF(int a1, _DWORD *a2)
{
  int result; // eax

  *a2 = 0;
  a2[1] = *(_DWORD *)(a1 + 36);
  result = a1;
  *(_DWORD *)(a1 + 36) = a2;
  return result;
}

//----- (080587F2) --------------------------------------------------------
int __cdecl sub_80587F2(int a1, int a2, _DWORD *a3, char a4)
{
  int v4; // ecx
  _DWORD *v5; // edx
  unsigned __int8 (__cdecl *v6)(int, int); // eax
  int v7; // edx
  int v8; // ecx
  _DWORD *v9; // ecx
  int v10; // edx
  unsigned __int8 (__cdecl *v11)(int, int); // eax
  int v13; // [esp+4h] [ebp-34h]
  char v14; // [esp+Ch] [ebp-2Ch]
  _DWORD *v15; // [esp+18h] [ebp-20h]
  _DWORD *v16; // [esp+1Ch] [ebp-1Ch]
  int v17; // [esp+20h] [ebp-18h]
  _DWORD *v18; // [esp+24h] [ebp-14h]
  int v19; // [esp+28h] [ebp-10h]
  _DWORD *v20; // [esp+2Ch] [ebp-Ch]

  v14 = a4;
  v16 = (_DWORD *)sub_8057DCE(a1, a2);
  v5 = v16;
  *a3 = v16;
  if ( !*v16 )
  {
    dword_806B220 = (int)&locret_8058983;
    sub_8061DE3(v4, v5);
  }
  if ( *v16 == a2 || (v6 = *(unsigned __int8 (__cdecl **)(int, int))(a1 + 28), v13 = *v16, v6(a2, v13)) )
  {
    v19 = *v16;
    if ( v14 )
    {
      if ( v16[1] )
      {
        v20 = (_DWORD *)v16[1];
        v9 = v16;
        v10 = v20[1];
        *v16 = *v20;
        v9[1] = v10;
        sub_80587CF(a1, v20);
      }
      else
      {
        *v16 = 0;
      }
    }
    dword_806B2D4 = (int)&locret_8058983;
    sub_80619CB();
  }
  v15 = v16;
  dword_806B25C = (int)&loc_8058970;
  sub_8061C89(v8, v7);
  do
  {
    if ( *(_DWORD *)v15[1] == a2
      || (v11 = *(unsigned __int8 (__cdecl **)(int, int))(a1 + 28), v13 = *(_DWORD *)v15[1], v11(a2, v13)) )
    {
      v17 = *(_DWORD *)v15[1];
      if ( v14 )
      {
        v18 = (_DWORD *)v15[1];
        v15[1] = v18[1];
        sub_80587CF(a1, v18);
      }
      dword_806B234 = (int)&locret_8058983;
      sub_8061D73();
    }
    v15 = (_DWORD *)v15[1];
  }
  while ( v15[1] );
  return 0;
}
// 80619CB: using guessed type int sub_80619CB(void);
// 8061C89: using guessed type int __fastcall sub_8061C89(_DWORD, _DWORD);
// 8061D73: using guessed type int sub_8061D73(void);
// 8061DE3: using guessed type int __fastcall sub_8061DE3(_DWORD, _DWORD);
// 806B220: using guessed type int dword_806B220;
// 806B234: using guessed type int dword_806B234;
// 806B25C: using guessed type int dword_806B25C;
// 806B2D4: using guessed type int dword_806B2D4;

//----- (08058985) --------------------------------------------------------
signed int __cdecl sub_8058985(int a1, int a2, char a3)
{
  void *v3; // eax
  _DWORD *v4; // eax
  bool v5; // zf
  void *v6; // eax
  void *v7; // eax
  int v8; // edx
  int v9; // ecx
  void *v10; // eax
  char v12; // [esp+Ch] [ebp-2Ch]
  int *i; // [esp+18h] [ebp-20h]
  int *v14; // [esp+1Ch] [ebp-1Ch]
  int v15; // [esp+20h] [ebp-18h]
  _DWORD *v16; // [esp+24h] [ebp-14h]
  int *v17; // [esp+28h] [ebp-10h]
  void *v18; // [esp+2Ch] [ebp-Ch]

  v12 = a3;
  for ( i = *(int **)a2; ; i += 2 )
  {
    if ( *(_DWORD *)(a2 + 4) <= (unsigned int)i )
      return 1;
    if ( *i )
    {
      v14 = (int *)i[1];
      dword_806B234 = (int)&loc_8058A40;
      sub_8061D73();
      v15 = *v14;
      v16 = (_DWORD *)sub_8057DCE(a1, v15);
      v17 = (int *)v14[1];
      if ( *v16 )
      {
        v14[1] = v16[1];
        v16[1] = v14;
      }
      else
      {
        *v16 = v15;
        ++*(_DWORD *)(a1 + 12);
        sub_80587CF(a1, v14);
      }
      v14 = v17;
      v3 = &loc_8058A5F;
      if ( v17 )
        v3 = &loc_80589CB;
      dword_806B2C0 = (int)v3;
      sub_8061A43();
      v15 = *i;
      i[1] = 0;
      if ( !v12 )
        break;
    }
  }
  v4 = (_DWORD *)sub_8057DCE(a1, v15);
  v16 = v4;
  v5 = *v4 == 0;
  v6 = &loc_8058AB3;
  if ( v5 )
    v6 = &loc_8058B06;
  dword_806B370 = (int)v6;
  sub_8061638();
  v7 = sub_8058794(a1);
  v18 = v7;
  v5 = v7 == 0;
  v10 = &loc_8058AE0;
  if ( !v5 )
    v10 = &loc_8058AE7;
  dword_806B2FC = (int)v10;
  sub_80618E9(v9, v8);
  return 0;
}
// 8058985: could not find valid save-restore pair for ebx
// 8061638: using guessed type int sub_8061638(void);
// 80618E9: using guessed type int __fastcall sub_80618E9(_DWORD, _DWORD);
// 8061A43: using guessed type int sub_8061A43(void);
// 8061D73: using guessed type int sub_8061D73(void);
// 806B234: using guessed type int dword_806B234;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B2FC: using guessed type int dword_806B2FC;
// 806B370: using guessed type int dword_806B370;

//----- (08058B4F) --------------------------------------------------------
signed int __cdecl sub_8058B4F(int a1, unsigned int a2)
{
  void *v3; // eax
  int nmemb; // [esp+10h] [ebp-38h]

  nmemb = sub_8058334(a2, *(_DWORD *)(a1 + 20));
  if ( !nmemb )
    return 0;
  v3 = &loc_8058BA1;
  if ( *(_DWORD *)(a1 + 8) != nmemb )
    v3 = &loc_8058BAB;
  dword_806B2E8 = (int)v3;
  sub_8061957();
  return 1;
}
// 8061957: using guessed type int sub_8061957(void);
// 806B2E8: using guessed type int dword_806B2E8;

//----- (08058D5D) --------------------------------------------------------
int __cdecl sub_8058D5D(int a1, int a2, _DWORD *a3)
{
  int v3; // eax
  bool v4; // zf
  void *v5; // eax
  int v7; // [esp+2Ch] [ebp-1Ch]
  int v8; // [esp+30h] [ebp-18h]

  if ( !a2 )
    abort();
  v3 = sub_80587F2(a1, a2, &v7, 0);
  v8 = v3;
  v4 = v3 == 0;
  v5 = &loc_8058DB1;
  if ( v4 )
    v5 = &loc_8058DC9;
  dword_806B2D4 = (int)v5;
  sub_80619CB();
  if ( a3 )
    *a3 = v8;
  return 0;
}
// 80619CB: using guessed type int sub_80619CB(void);
// 806B2D4: using guessed type int dword_806B2D4;

//----- (08058FDE) --------------------------------------------------------
int __cdecl sub_8058FDE(int a1, int a2)
{
  int v2; // eax
  bool v3; // zf
  void *v4; // eax
  int result; // eax
  int v6; // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]

  v2 = sub_8058D5D(a1, a2, &v6);
  v7 = v2;
  v3 = v2 == -1;
  v4 = &loc_805901F;
  if ( v3 )
    v4 = &loc_805902F;
  dword_806B2E8 = (int)v4;
  sub_8061957();
  if ( v7 )
    result = a2;
  else
    result = v6;
  return result;
}
// 8061957: using guessed type int sub_8061957(void);
// 806B2E8: using guessed type int dword_806B2E8;

//----- (08059036) --------------------------------------------------------
int __cdecl sub_8059036(int a1, int a2)
{
  int v3; // ecx
  void *v4; // eax
  _DWORD *v5; // [esp+28h] [ebp-20h]
  void *ptr; // [esp+2Ch] [ebp-1Ch]
  int v7; // [esp+30h] [ebp-18h]
  int v8; // [esp+34h] [ebp-14h]
  unsigned int v9; // [esp+38h] [ebp-10h]
  void *v10; // [esp+3Ch] [ebp-Ch]

  v7 = sub_80587F2(a1, a2, &v5, 1);
  if ( !v7 )
    return 0;
  --*(_DWORD *)(a1 + 16);
  if ( !*v5
    && **(float **)(a1 + 20) * (long double)*(unsigned int *)(a1 + 8) > (long double)(unsigned int)--*(_DWORD *)(a1 + 12) )
  {
    sub_8058278(a1);
    if ( **(float **)(a1 + 20) * (long double)*(unsigned int *)(a1 + 8) > (long double)*(unsigned int *)(a1 + 12) )
    {
      v8 = *(_DWORD *)(a1 + 20);
      v4 = &loc_805914B;
      if ( !*(_BYTE *)(v8 + 16) )
        v4 = &loc_8059185;
      dword_806B35C = (int)v4;
      sub_80616AA(v3, 0);
      v9 = (signed __int64)((long double)*(unsigned int *)(a1 + 8) * *(float *)(v8 + 4));
      if ( (unsigned __int8)sub_8058B4F(a1, v9) ^ 1 )
      {
        for ( ptr = *(void **)(a1 + 36); ptr; ptr = v10 )
        {
          v10 = (void *)*((_DWORD *)ptr + 1);
          free(ptr);
        }
        *(_DWORD *)(a1 + 36) = 0;
      }
    }
  }
  return v7;
}
// 80616AA: using guessed type int __fastcall sub_80616AA(_DWORD, _DWORD);
// 806B35C: using guessed type int dword_806B35C;

//----- (0805921B) --------------------------------------------------------
_DWORD *__cdecl sub_805921B(int (*a1)(), unsigned int a2)
{
  int (*v2)(); // eax
  _DWORD *v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_805E4FC(0x10u);
  if ( !a2 )
    a2 = 1;
  *v4 = sub_805E3D6(a2, 4u);
  *(_DWORD *)*v4 = 0;
  v4[1] = a2;
  v4[2] = 0;
  if ( a1 )
    v2 = a1;
  else
    v2 = sub_8059290;
  v4[3] = v2;
  return v4;
}

//----- (08059290) --------------------------------------------------------
int sub_8059290()
{
  return 0;
}

//----- (0805929A) --------------------------------------------------------
void __cdecl sub_805929A(void *ptr)
{
  free(*(void **)ptr);
  free(ptr);
}

//----- (080592BA) --------------------------------------------------------
int __cdecl sub_80592BA(int a1, int a2)
{
  _DWORD *v2; // edx

  if ( (unsigned int)(*(_DWORD *)(a1 + 4) - 1) <= *(_DWORD *)(a1 + 8) )
    *(_DWORD *)a1 = sub_805E439(*(void **)a1, a1 + 4, 4);
  v2 = *(_DWORD **)a1;
  v2[++*(_DWORD *)(a1 + 8)] = a2;
  sub_80594C9(*(_DWORD *)a1, *(_DWORD *)(a1 + 8), *(int (__cdecl **)(_DWORD, int))(a1 + 12));
  return 0;
}

//----- (08059343) --------------------------------------------------------
int __usercall sub_8059343@<eax>(int a1@<edx>, int a2@<ecx>, int *a3)
{
  int v3; // ST1C_4
  _DWORD *v4; // ebx
  int v5; // esi
  int v6; // eax

  if ( !a3[2] )
  {
    dword_806B2FC = (int)&loc_80593CD;
    sub_80618E9(a2, a1);
  }
  v3 = *(_DWORD *)(*a3 + 4);
  v4 = (_DWORD *)(*a3 + 4);
  v5 = *a3;
  v6 = a3[2];
  a3[2] = v6 - 1;
  *v4 = *(_DWORD *)(v5 + 4 * v6);
  sub_80593D4(*a3, a3[2], 1u, (int (__cdecl *)(int, int))a3[3]);
  return v3;
}
// 80618E9: using guessed type int __fastcall sub_80618E9(_DWORD, _DWORD);
// 806B2FC: using guessed type int dword_806B2FC;

//----- (080593D4) --------------------------------------------------------
unsigned int __cdecl sub_80593D4(int a1, unsigned int a2, unsigned int a3, int (__cdecl *a4)(int, int))
{
  int v4; // eax
  int v6; // [esp+0h] [ebp-28h]
  int v7; // [esp+4h] [ebp-24h]
  unsigned int v8; // [esp+14h] [ebp-14h]
  unsigned int v9; // [esp+18h] [ebp-10h]
  int v10; // [esp+1Ch] [ebp-Ch]

  v10 = *(_DWORD *)(4 * a3 + a1);
  v8 = a3;
  dword_806B310 = (int)&loc_80594A2;
  sub_8061877();
  do
  {
    v9 = 2 * v8;
    if ( 2 * v8 < a2 )
    {
      v4 = *(_DWORD *)(4 * v9 + a1);
      v7 = *(_DWORD *)(4 * (v9 + 1) + a1);
      if ( a4(v4, v7) < 0 )
        ++v9;
    }
    v6 = *(_DWORD *)(4 * v9 + a1);
    if ( a4(v6, v10) <= 0 )
      break;
    *(_DWORD *)(a1 + 4 * v8) = *(_DWORD *)(4 * v9 + a1);
    v8 = v9;
  }
  while ( a2 >> 1 >= v9 );
  *(_DWORD *)(a1 + 4 * v8) = v10;
  return v8;
}
// 8061877: using guessed type int sub_8061877(void);
// 806B310: using guessed type int dword_806B310;

//----- (080594C9) --------------------------------------------------------
int __cdecl sub_80594C9(int a1, unsigned int a2, int (__cdecl *a3)(_DWORD, int))
{
  int result; // eax
  unsigned int v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]

  v4 = a2;
  v5 = *(_DWORD *)(4 * a2 + a1);
  while ( v4 != 1 && a3(*(_DWORD *)(4 * (v4 >> 1) + a1), v5) <= 0 )
  {
    *(_DWORD *)(a1 + 4 * v4) = *(_DWORD *)(4 * (v4 >> 1) + a1);
    v4 >>= 1;
  }
  result = v5;
  *(_DWORD *)(a1 + 4 * v4) = v5;
  return result;
}

//----- (08059559) --------------------------------------------------------
int __cdecl sub_8059559(int a1, _BYTE *a2)
{
  void *v2; // eax
  int v4; // [esp+Ch] [ebp-4h]

  v4 = (int)(a2 + 11);
  a2[11] = 0;
  if ( a1 >= 0 )
  {
    do
    {
      *(_BYTE *)--v4 = (char)a1 % 10 + 48;
      a1 /= 10;
    }
    while ( a1 );
  }
  else
  {
    a2[10] = 48 - (char)a1 % 10;
    v2 = &loc_80595E7;
    if ( a1 / 10 )
      v2 = &loc_8059574;
    dword_806B25C = (int)v2;
    sub_8061C89(a1, a1 / 10);
    v4 = (int)(a2 + 9);
    a2[9] = 45;
  }
  return v4;
}
// 8061C89: using guessed type int __fastcall sub_8061C89(_DWORD, _DWORD);
// 806B25C: using guessed type int dword_806B25C;

//----- (0805964C) --------------------------------------------------------
int __cdecl sub_805964C(unsigned int a1, int a2)
{
  int v3; // [esp+Ch] [ebp-4h]

  v3 = a2 + 10;
  *(_BYTE *)(a2 + 10) = 0;
  do
  {
    *(_BYTE *)--v3 = a1 % 0xA + 48;
    a1 /= 0xAu;
  }
  while ( a1 );
  return v3;
}

//----- (080596AA) --------------------------------------------------------
int __cdecl sub_80596AA(__int64 a1, int a2)
{
  __int64 v3; // [esp+18h] [ebp-20h]
  int v4; // [esp+2Ch] [ebp-Ch]

  v3 = a1;
  v4 = a2 + 20;
  *(_BYTE *)(a2 + 20) = 0;
  do
  {
    *(_BYTE *)--v4 = sub_8061294(v3, 0xAu, 0) + 48;
    v3 = sub_8061142(v3, HIDWORD(v3), 10, 0);
  }
  while ( v3 );
  return v4;
}

//----- (0805975D) --------------------------------------------------------
int __cdecl sub_805975D(char *a1, int a2, char a3)
{
  int v3; // edx
  int v4; // ecx
  int v5; // eax
  bool v6; // zf
  bool v7; // sf
  unsigned __int8 v8; // of
  void *v9; // eax
  void *v11; // eax
  int v12; // edx
  int v13; // ecx
  char *v14; // eax
  const unsigned __int16 **v15; // eax
  int v16; // ecx
  int v17; // edx
  void *v18; // eax
  char *v19; // [esp+1Ch] [ebp-3Ch]
  unsigned __int8 v20; // [esp+2Bh] [ebp-2Dh]
  wint_t wc; // [esp+2Ch] [ebp-2Ch]
  char *v22; // [esp+30h] [ebp-28h]
  int v23; // [esp+34h] [ebp-24h]
  size_t v24; // [esp+38h] [ebp-20h]
  char *v25; // [esp+3Ch] [ebp-1Ch]
  int v26; // [esp+40h] [ebp-18h]
  const mbstate_t s; // [esp+44h] [ebp-14h]
  unsigned int v28; // [esp+4Ch] [ebp-Ch]

  v19 = a1;
  v28 = __readgsdword(0x14u);
  v22 = a1;
  v25 = &a1[a2];
  v23 = 0;
  if ( __ctype_get_mb_cur_max() <= 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        if ( v22 >= v25 )
          return v23;
        v14 = v22++;
        v20 = *v14;
        if ( !((*__ctype_b_loc())[v20] & 0x4000) )
          break;
        if ( v23 == 0x7FFFFFFF )
          return 0x7FFFFFFF;
        ++v23;
      }
      if ( a3 & 2 )
        return -1;
      v15 = __ctype_b_loc();
      v17 = v20;
      if ( !((*v15)[v17] & 2) )
      {
        v18 = &loc_8059A08;
        if ( v23 != 0x7FFFFFFF )
          v18 = &loc_8059A0A;
        dword_806B338 = (int)v18;
        sub_8061791(v16, v17 * 2);
        return 0x7FFFFFFF;
      }
    }
  }
  while ( 1 )
  {
LABEL_33:
    if ( v22 >= v25 )
      return v23;
    v5 = *v22;
    if ( v5 <= 63 )
    {
      if ( v5 >= 37 )
        goto LABEL_11;
      if ( (unsigned int)(v5 - 32) > 3 )
        break;
      dword_806B2AC = (int)&loc_80597FC;
      v5 = sub_8061AB5(v4, v3);
    }
    if ( v5 < 65 )
      break;
    v8 = __OFSUB__(v5, 95);
    v6 = v5 == 95;
    v7 = v5 - 95 < 0;
    v9 = &loc_80597F4;
    if ( (unsigned __int8)(v7 ^ v8) | v6 )
      v9 = &loc_80597FC;
    dword_806B25C = (int)v9;
    if ( (unsigned int)(sub_8061C89(v4, v3) - 97) > 0x1D )
      break;
LABEL_11:
    ++v22;
    ++v23;
  }
  memset((void *)&s, 0, 8u);
  while ( 1 )
  {
    v24 = sub_805F95F((int)&s, v4, (wchar_t *)&wc, v22, v25 - v22, (mbstate_t *)&s);
    if ( v24 == -1 )
    {
      if ( !(a3 & 1) )
      {
        ++v22;
        ++v23;
        goto LABEL_33;
      }
      return -1;
    }
    if ( v24 == -2 )
      break;
    v11 = &loc_80598BD;
    if ( v24 )
      v11 = &loc_80598C4;
    dword_806B2E8 = (int)v11;
    sub_8061957();
    v24 = 1;
    v26 = wcwidth(wc);
    if ( v26 >= 0 )
    {
      if ( 0x7FFFFFFF - v23 < v26 )
      {
        dword_806B20C = (int)&loc_8059A28;
        sub_8061E55();
      }
      v23 += v26;
      dword_806B338 = (int)&loc_8059950;
      sub_8061791(v13, v12);
    }
    if ( a3 & 2 )
      return -1;
    if ( !iswcntrl(wc) )
    {
      if ( v23 == 0x7FFFFFFF )
        return 0x7FFFFFFF;
      ++v23;
    }
    v22 += v24;
    if ( mbsinit(&s) )
      goto LABEL_33;
  }
  if ( !(a3 & 1) )
  {
    v22 = v25;
    ++v23;
    goto LABEL_33;
  }
  return -1;
}
// 805975D: could not find valid save-restore pair for ebx
// 8049800: using guessed type int __cdecl wcwidth(_DWORD);
// 8061791: using guessed type int __fastcall sub_8061791(_DWORD, _DWORD);
// 8061957: using guessed type int sub_8061957(void);
// 8061AB5: using guessed type int __fastcall sub_8061AB5(_DWORD, _DWORD);
// 8061C89: using guessed type int __fastcall sub_8061C89(_DWORD, _DWORD);
// 8061E55: using guessed type int sub_8061E55(void);
// 806B20C: using guessed type int dword_806B20C;
// 806B25C: using guessed type int dword_806B25C;
// 806B2AC: using guessed type int dword_806B2AC;
// 806B2E8: using guessed type int dword_806B2E8;
// 806B338: using guessed type int dword_806B338;

//----- (08059A40) --------------------------------------------------------
int sub_8059A40()
{
  int v0; // eax
  bool v1; // zf
  void *v2; // eax
  int v4; // [esp+1Ch] [ebp-8Ch]
  char v5; // [esp+20h] [ebp-88h]

  if ( sched_getaffinity(0, 128, &v5) )
    return 0;
  v0 = __sched_cpucount(128, &v5);
  v4 = v0;
  v1 = v0 == 0;
  v2 = &loc_8059AA9;
  if ( v1 )
    v2 = &loc_8059AB1;
  dword_806B310 = (int)v2;
  sub_8061877();
  return v4;
}
// 80498D0: using guessed type int __cdecl __sched_cpucount(_DWORD, _DWORD);
// 8049E70: using guessed type int __cdecl sched_getaffinity(_DWORD, _DWORD, _DWORD);
// 8061877: using guessed type int sub_8061877(void);
// 806B310: using guessed type int dword_806B310;

//----- (08059AB8) --------------------------------------------------------
int __usercall sub_8059AB8@<eax>(int a1@<edx>, int a2@<ecx>, int a3)
{
  void *v3; // eax
  int v5; // eax
  int v6; // edx
  int v7; // ecx
  bool v8; // zf
  bool v9; // sf
  void *v10; // eax
  int v11; // [esp+14h] [ebp-14h]
  int v12; // [esp+18h] [ebp-10h]

  v3 = &loc_8059ADD;
  if ( a3 != 1 )
    v3 = &loc_8059B25;
  dword_806B270 = (int)v3;
  sub_8061C11(a2, a1);
  v11 = sub_8059A40();
  if ( v11 )
    return v11;
  v5 = sysconf(84);
  v12 = v5;
  v8 = v5 == 0;
  v9 = v5 < 0;
  v10 = &loc_8059B1E;
  if ( v9 || v8 )
    v10 = &loc_8059B23;
  dword_806B270 = (int)v10;
  sub_8061C11(v7, v6);
  return v12;
}
// 8059AB8: could not find valid save-restore pair for ebx
// 8061C11: using guessed type int __fastcall sub_8061C11(_DWORD, _DWORD);
// 806B270: using guessed type int dword_806B270;

//----- (08059B60) --------------------------------------------------------
int __usercall sub_8059B60@<eax>(int a1@<edx>, int a2@<ecx>, char *nptr)
{
  void *v3; // eax
  int v4; // edx
  int v5; // ecx
  bool v6; // zf
  int v7; // edx
  int v8; // ecx
  void *v9; // eax
  int v10; // edx
  int v11; // ecx
  void *v12; // eax
  int result; // eax
  int v14; // [esp+0h] [ebp-28h]
  char *endptr; // [esp+14h] [ebp-14h]
  int v16; // [esp+18h] [ebp-10h]
  unsigned int v17; // [esp+1Ch] [ebp-Ch]

  v16 = 0;
  if ( !nptr )
  {
    dword_806B2C0 = (int)&locret_8059C8C;
    sub_8061A43();
  }
  v3 = &loc_8059BB6;
  if ( !*nptr )
    v3 = &loc_8059BE4;
  dword_806B25C = (int)v3;
  sub_8061C89(a2, a1);
  v14 = *nptr;
  v6 = (unsigned __int8)sub_806029A(v4, v5, v14) == 0;
  v9 = &loc_8059BE4;
  if ( !v6 )
    v9 = &loc_8059B8F;
  dword_806B270 = (int)v9;
  sub_8061C11(v8, v7);
  v14 = *nptr;
  if ( !(unsigned __int8)sub_80601AD(v14) )
    goto LABEL_20;
  endptr = 0;
  v17 = strtoul(nptr, &endptr, 10);
  if ( !endptr )
    goto LABEL_20;
  if ( *endptr )
  {
    v14 = *endptr;
    v6 = (unsigned __int8)sub_806029A(v10, v11, v14) == 0;
    v12 = &loc_8059C6B;
    if ( !v6 )
      v12 = &loc_8059C2A;
    dword_806B370 = (int)v12;
    sub_8061638();
  }
  if ( !*endptr )
    return v17;
  if ( *endptr == 44 )
    result = v17;
  else
LABEL_20:
    result = v16;
  return result;
}
// 8059B60: could not find valid save-restore pair for ebx
// 8061638: using guessed type int sub_8061638(void);
// 8061A43: using guessed type int sub_8061A43(void);
// 8061C11: using guessed type int __fastcall sub_8061C11(_DWORD, _DWORD);
// 8061C89: using guessed type int __fastcall sub_8061C89(_DWORD, _DWORD);
// 806B25C: using guessed type int dword_806B25C;
// 806B270: using guessed type int dword_806B270;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B370: using guessed type int dword_806B370;

//----- (08059C8E) --------------------------------------------------------
unsigned int __usercall sub_8059C8E@<eax>(int a1@<edx>, int a2@<ecx>, int a3)
{
  void *v3; // eax
  char *v4; // eax
  int v5; // edx
  int v6; // ecx
  char *v7; // eax
  int v8; // edx
  int v9; // ecx
  int v10; // edx
  int v11; // ecx
  unsigned int result; // eax
  unsigned int v13; // [esp+14h] [ebp-14h]
  int v14; // [esp+18h] [ebp-10h]
  unsigned int v15; // [esp+1Ch] [ebp-Ch]

  v13 = -1;
  v3 = &loc_8059CBA;
  if ( a3 != 2 )
    v3 = &loc_8059D23;
  dword_806B270 = (int)v3;
  sub_8061C11(a2, a1);
  v4 = getenv("OMP_NUM_THREADS");
  v14 = sub_8059B60(v5, v6, v4);
  v7 = getenv("OMP_THREAD_LIMIT");
  v13 = sub_8059B60(v8, v9, v7);
  if ( !v13 )
    v13 = -1;
  if ( v14 )
  {
    dword_806B284 = (int)&locret_8059D3B;
    sub_8061B9D();
  }
  result = sub_8059AB8(v10, v11, 1);
  v15 = result;
  if ( v13 <= result )
    result = v13;
  return result;
}
// 8061B9D: using guessed type int sub_8061B9D(void);
// 8061C11: using guessed type int __fastcall sub_8061C11(_DWORD, _DWORD);
// 806B270: using guessed type int dword_806B270;
// 806B284: using guessed type int dword_806B284;

//----- (08059D3D) --------------------------------------------------------
long double sub_8059D3D()
{
  double v1; // [esp+18h] [ebp-60h]
  double v2; // [esp+20h] [ebp-58h]
  char v3; // [esp+2Ch] [ebp-4Ch]
  unsigned int v4; // [esp+3Ch] [ebp-3Ch]
  unsigned int v5; // [esp+60h] [ebp-18h]
  unsigned int v6; // [esp+6Ch] [ebp-Ch]

  v6 = __readgsdword(0x14u);
  v1 = (long double)sysconf(85);
  v2 = (long double)sysconf(30);
  if ( v1 >= 0.0 && v2 >= 0.0 )
    return v1 * v2;
  if ( sysinfo((struct sysinfo *)&v3) )
    return 67108864.0;
  return (long double)v4 * (long double)v5;
}

//----- (08059DEA) --------------------------------------------------------
int __cdecl sub_8059DEA(int a1)
{
  int v1; // ST04_4
  int v2; // ST04_4

  v1 = sysconf(86);
  __asm
  {
    fild    [ebp+var_74]
    fstp    [ebp+var_60]
  }
  v2 = sysconf(30);
  __asm
  {
    fild    [ebp+var_74]
    fstp    [ebp+var_58]
    fld     [ebp+var_60]
    fldz
    fxch    st(1)
    fucomip st, st(1)
    fstp    st
  }
  dword_806B348 = (int (__cdecl *)(_DWORD))sub_8059E7C;
  if ( !_CF )
  {
    __asm
    {
      fld     [ebp+var_58]
      fldz
      fxch    st(1)
      fucomip st, st(1)
      fstp    st
    }
    dword_806B348 = (int (__cdecl *)(_DWORD))sub_8059E7C;
    if ( !_CF )
    {
      __asm
      {
        fld     [ebp+var_60]
        fmul    [ebp+var_58]
      }
      dword_806B348 = (int (__cdecl *)(_DWORD))&loc_8059EF4;
    }
  }
  return dword_806B348(a1);
}
// 8059E0A: inconsistent fpu stack
// 8059E7C: using guessed type int sub_8059E7C();
// 806B348: using guessed type int (__cdecl *dword_806B348)(_DWORD);

//----- (08059E7C) --------------------------------------------------------
#error "8059E82: call analysis failed (funcsize=51)"

//----- (08059EE7) --------------------------------------------------------
int __usercall sub_8059EE7@<eax>(int a1@<ebp>, int a2)
{
  long double v2; // fst7
  bool v3; // zf

  v2 = sub_8059D3D() / 4.0;
  v3 = __readgsdword(0x14u) == *(_DWORD *)(a1 - 12);
  dword_806B348 = (int (__cdecl *)(_DWORD))sub_8059F19;
  if ( !v3 )
    JUMPOUT(*(_DWORD *)sub_8059F19);
  return dword_806B348(a2);
}
// 8059F19: using guessed type int sub_8059F19();
// 806B348: using guessed type int (__cdecl *dword_806B348)(_DWORD);

//----- (08059F19) --------------------------------------------------------
#error "8059F1A: positive sp value has been found (funcsize=0)"

//----- (08059F1B) --------------------------------------------------------
int __cdecl sub_8059F1B(int pipedes[2], int a2)
{
  int v3; // edx
  int v4; // ecx
  bool v5; // zf
  int v6; // edx
  int v7; // ecx
  void *v8; // eax
  void *v9; // eax
  int v10; // [esp+18h] [ebp-20h]
  int v11; // [esp+1Ch] [ebp-1Ch]
  int v12; // [esp+20h] [ebp-18h]
  int v13; // [esp+24h] [ebp-14h]
  int v14; // [esp+28h] [ebp-10h]
  int v15; // [esp+2Ch] [ebp-Ch]

  v14 = *pipedes;
  v15 = pipedes[1];
  if ( dword_806C3BD >= 0 )
  {
    v10 = pipe2(pipedes, a2);
    if ( v10 >= 0 || *__errno_location() != 38 )
    {
      dword_806C3BD = 1;
      return v10;
    }
    dword_806C3BD = -1;
  }
  if ( a2 & 0xFFF7F7FF )
  {
    *__errno_location() = 22;
    return -1;
  }
  if ( pipe(pipedes) < 0 )
  {
    dword_806B35C = (int)&locret_805A1B8;
    sub_80616AA(v4, v3);
  }
  if ( !(a2 & 0x800) )
    goto LABEL_27;
  v11 = sub_805F63F(pipedes[1], 3, 0);
  if ( v11 >= 0 )
  {
    v5 = sub_805F63F(pipedes[1], 4, v11) == -1;
    v8 = &loc_805A049;
    if ( v5 )
      v8 = &loc_805A16F;
    dword_806B2FC = (int)v8;
    sub_80618E9(v7, v6);
    v11 = sub_805F63F(*pipedes, 3, 0);
    if ( v11 >= 0 && sub_805F63F(*pipedes, 4, v11) != -1 )
    {
LABEL_27:
      if ( !(a2 & 0x80000) )
        return 0;
      v12 = sub_805F63F(pipedes[1], 1, 0);
      if ( v12 >= 0 && sub_805F63F(pipedes[1], 2, v12 | 1) != -1 )
      {
        v12 = sub_805F63F(*pipedes, 1, 0);
        if ( v12 >= 0 )
        {
          v5 = sub_805F63F(*pipedes, 2, v12 | 1) == -1;
          v9 = &loc_805A168;
          if ( v5 )
            v9 = &loc_805A16F;
          dword_806B2E8 = (int)v9;
          sub_8061957();
          return 0;
        }
      }
    }
  }
  v13 = *__errno_location();
  close(*pipedes);
  close(pipedes[1]);
  *pipedes = v14;
  pipedes[1] = v15;
  *__errno_location() = v13;
  return -1;
}
// 8059F1B: could not find valid save-restore pair for ebx
// 8049DF0: using guessed type int __cdecl pipe2(_DWORD, _DWORD);
// 80616AA: using guessed type int __fastcall sub_80616AA(_DWORD, _DWORD);
// 80618E9: using guessed type int __fastcall sub_80618E9(_DWORD, _DWORD);
// 8061957: using guessed type int sub_8061957(void);
// 806B2E8: using guessed type int dword_806B2E8;
// 806B2FC: using guessed type int dword_806B2FC;
// 806B35C: using guessed type int dword_806B35C;
// 806C3BD: using guessed type int dword_806C3BD;

//----- (0805A1BA) --------------------------------------------------------
int sub_805A1BA()
{
  char *endptr; // [esp+10h] [ebp-18h]
  int v2; // [esp+14h] [ebp-14h]
  char *nptr; // [esp+18h] [ebp-10h]
  int v4; // [esp+1Ch] [ebp-Ch]

  v2 = 200809;
  nptr = getenv("_POSIX2_VERSION");
  if ( nptr )
  {
    if ( *nptr )
    {
      v4 = strtol(nptr, &endptr, 10);
      if ( !*endptr )
        v2 = v4;
    }
  }
  return v2;
}

//----- (0805A218) --------------------------------------------------------
char *__cdecl sub_805A218(char *s)
{
  char *v1; // eax
  int v2; // edx
  int v3; // ecx
  bool v4; // zf
  void *v5; // eax
  int v6; // edx
  int v7; // ecx
  char *result; // eax
  char *v9; // [esp+18h] [ebp-10h]
  char *s1; // [esp+1Ch] [ebp-Ch]

  if ( !s )
  {
    fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
    abort();
  }
  v1 = strrchr(s, 47);
  v9 = v1;
  v4 = v1 == 0;
  v5 = &loc_805A283;
  if ( v4 )
    v5 = &loc_805A2A0;
  dword_806B248 = (int)v5;
  sub_8061CFB(v3, v2);
  dword_806B298 = (int)&loc_805A2A3;
  sub_8061B2F(v7, v6);
  s1 = s;
  dword_806B2C0 = (int)&loc_805A326;
  sub_8061A43();
  if ( !strncmp(s1 - 7, "/.libs/", 7u) )
  {
    s = s1;
    if ( !strncmp(s1, "lt-", 3u) )
    {
      s = s1 + 3;
      program_invocation_short_name = (int)(s1 + 3);
    }
  }
  dword_806C3C1 = (int)s;
  result = s;
  program_invocation_name = (int)s;
  return result;
}
// 805A218: could not find valid save-restore pair for ebx
// 8061A43: using guessed type int sub_8061A43(void);
// 8061B2F: using guessed type int __fastcall sub_8061B2F(_DWORD, _DWORD);
// 8061CFB: using guessed type int __fastcall sub_8061CFB(_DWORD, _DWORD);
// 806B248: using guessed type int dword_806B248;
// 806B298: using guessed type int dword_806B298;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B4E0: using guessed type int program_invocation_short_name;
// 806B4F0: using guessed type int program_invocation_name;
// 806C3C1: using guessed type int dword_806C3C1;

//----- (0805A3EE) --------------------------------------------------------
int __cdecl sub_805A3EE(int *a1, unsigned __int8 a2, char a3)
{
  int *v3; // eax
  int v4; // ST10_4

  if ( a1 )
    v3 = a1;
  else
    v3 = &dword_806C3D1;
  v4 = ((unsigned int)v3[(a2 >> 5) + 2] >> (a2 & 0x1F)) & 1;
  v3[(a2 >> 5) + 2] ^= (v4 ^ a3 & 1) << (a2 & 0x1F);
  return v4;
}
// 806C3D1: using guessed type int dword_806C3D1;

//----- (0805A498) --------------------------------------------------------
int *__usercall sub_805A498@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5)
{
  void *v5; // eax
  int *result; // eax

  v5 = &loc_805A4BD;
  if ( a3 )
    v5 = &loc_805A4C4;
  dword_806B220 = (int)v5;
  sub_8061DE3(a2, a1);
  dword_806C3D1 = 10;
  if ( !a4 || !a5 )
    abort();
  *(&dword_806C3D1 + 10) = a4;
  result = &dword_806C3D1;
  *(&dword_806C3D1 + 11) = a5;
  return result;
}
// 8061DE3: using guessed type int __fastcall sub_8061DE3(_DWORD, _DWORD);
// 806B220: using guessed type int dword_806B220;
// 806C3D1: using guessed type int dword_806C3D1;

//----- (0805A4F2) --------------------------------------------------------
_DWORD *__userpurge sub_805A4F2@<eax>(_DWORD *a1, int a2)
{
  int v3; // [esp+0h] [ebp-38h]
  int v4; // [esp+4h] [ebp-34h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]

  memset(&v3, 0, 0x30u);
  if ( a2 == 10 )
    abort();
  *a1 = a2;
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = v6;
  a1[4] = v7;
  a1[5] = v8;
  a1[6] = v9;
  a1[7] = v10;
  a1[8] = v11;
  a1[9] = v12;
  a1[10] = v13;
  a1[11] = v14;
  return a1;
}

//----- (0805A574) --------------------------------------------------------
int __cdecl sub_805A574(char *msgid)
{
  char *v1; // ST18_4

  v1 = gettext(msgid);
  dword_806B348 = sub_805A5B8;
  if ( v1 != msgid )
    dword_806B348 = (int (__cdecl *)(_DWORD))&locret_805A72A;
  return dword_806B348(msgid);
}
// 805A5B8: using guessed type int __cdecl sub_805A5B8(int);
// 806B348: using guessed type int (__cdecl *dword_806B348)(_DWORD);

//----- (0805A5B8) --------------------------------------------------------
#error "805A5CE: call analysis failed (funcsize=62)"

//----- (0805A6B6) --------------------------------------------------------
int __usercall sub_805A6B6@<eax>(int edx0@<edx>, int ecx0@<ecx>, int a1, int a2, int a3)
{
  int v5; // edx
  int v6; // ecx
  void *v7; // eax

  dword_806B348 = (int (__cdecl *)(_DWORD))&locret_805A72A;
  dword_806B2AC = (int)&loc_805F7D4;
  sub_8061AB5(ecx0, edx0);
  dword_806B348 = (int (__cdecl *)(_DWORD))sub_805A725;
  v7 = &loc_805A70D;
  if ( a3 != 9 )
    v7 = &loc_805F7D4;
  dword_806B2AC = (int)v7;
  sub_8061AB5(v6, v5);
  dword_806B348 = (int (__cdecl *)(_DWORD))&locret_805A72A;
  return ((int (__cdecl *)(int))locret_805A72A)(a1);
}
// 805A725: using guessed type int sub_805A725();
// 8061AB5: using guessed type int __fastcall sub_8061AB5(_DWORD, _DWORD);
// 806B2AC: using guessed type int dword_806B2AC;
// 806B348: using guessed type int (__cdecl *dword_806B348)(_DWORD);

//----- (0805A725) --------------------------------------------------------
#error "805A72B: positive sp value has been found (funcsize=0)"

//----- (0805A72C) --------------------------------------------------------
unsigned int __cdecl sub_805A72C(int a1, unsigned int a2, char *a3, size_t a4, char *a5, int a6, int a7, char *a8, char *a9)
{
  char *v9; // edx
  int v10; // ecx
  void *v11; // eax
  void *v12; // eax
  void *v13; // eax
  void *v14; // eax
  size_t v15; // ebx
  size_t v16; // eax
  void *v17; // eax
  int v18; // edx
  bool v19; // al
  void *v20; // eax
  void *v21; // eax
  const unsigned __int16 **v22; // eax
  int v23; // edx
  int v24; // ecx
  void *v25; // eax
  void *v26; // eax
  void *v27; // eax
  void *v28; // eax
  int v29; // ecx
  int v30; // edx
  void *v31; // eax
  void *v32; // eax
  int v33; // edx
  int v34; // ecx
  void *v35; // eax
  bool v36; // al
  void *v37; // eax
  void *v38; // eax
  unsigned int result; // eax
  void *v40; // eax
  char *v41; // [esp+4h] [ebp-84h]
  size_t v42; // [esp+8h] [ebp-80h]
  char *v43; // [esp+2Ch] [ebp-5Ch]
  char *v44; // [esp+30h] [ebp-58h]
  int v45; // [esp+34h] [ebp-54h]
  char *v46; // [esp+38h] [ebp-50h]
  char *v47; // [esp+3Ch] [ebp-4Ch]
  char v48; // [esp+40h] [ebp-48h]
  bool v49; // [esp+41h] [ebp-47h]
  char v50; // [esp+42h] [ebp-46h]
  char v51; // [esp+43h] [ebp-45h]
  char v52; // [esp+44h] [ebp-44h]
  unsigned __int8 v53; // [esp+45h] [ebp-43h]
  char v54; // [esp+46h] [ebp-42h]
  char v55; // [esp+47h] [ebp-41h]
  char v56; // [esp+48h] [ebp-40h]
  bool v57; // [esp+49h] [ebp-3Fh]
  bool v58; // [esp+4Ah] [ebp-3Eh]
  bool v59; // [esp+4Bh] [ebp-3Dh]
  wint_t wc; // [esp+4Ch] [ebp-3Ch]
  char *v61; // [esp+50h] [ebp-38h]
  unsigned int v62; // [esp+54h] [ebp-34h]
  unsigned int v63; // [esp+58h] [ebp-30h]
  char *s; // [esp+5Ch] [ebp-2Ch]
  size_t n; // [esp+60h] [ebp-28h]
  unsigned int v66; // [esp+64h] [ebp-24h]
  unsigned int v67; // [esp+68h] [ebp-20h]
  size_t v68; // [esp+6Ch] [ebp-1Ch]
  unsigned int v69; // [esp+70h] [ebp-18h]
  mbstate_t ps; // [esp+74h] [ebp-14h]
  unsigned int v71; // [esp+7Ch] [ebp-Ch]

  v47 = (char *)a1;
  v46 = a3;
  v45 = a7;
  v44 = a8;
  v43 = a9;
  v71 = __readgsdword(0x14u);
  v62 = 0;
  v63 = 0;
  s = 0;
  n = 0;
  v48 = 0;
  v59 = __ctype_get_mb_cur_max() == 1;
  v49 = (a6 & 2) != 0;
  v50 = 0;
  v51 = 0;
  v52 = 1;
  switch ( (unsigned int)a5 )
  {
    case 0u:
      goto LABEL_28;
    case 1u:
      goto LABEL_20;
    case 2u:
      goto LABEL_23;
    case 3u:
      v48 = 1;
LABEL_20:
      v49 = 1;
      goto LABEL_21;
    case 4u:
LABEL_21:
      if ( v49 != 1 )
        v48 = 1;
LABEL_23:
      a5 = (char *)2;
      v12 = &loc_805A8F6;
      if ( v49 == 1 )
        v12 = &loc_805A90D;
      dword_806B25C = (int)v12;
      sub_8061C89(v10, v9);
      if ( v62 < a2 )
        v47[v62] = 39;
      ++v62;
      s = "'";
      n = 1;
      dword_806B284 = (int)&loc_805A93D;
      sub_8061B9D();
LABEL_28:
      v49 = 0;
      break;
    case 5u:
      goto LABEL_3;
    case 6u:
      a5 = (char *)5;
      v49 = 1;
LABEL_3:
      if ( v49 != 1 )
      {
        if ( v62 < a2 )
        {
          v9 = v47;
          v47[v62] = 34;
        }
        ++v62;
      }
      v48 = 1;
      s = (char *)&unk_8064635;
      n = 1;
      break;
    case 7u:
      v48 = 1;
      v49 = 0;
      break;
    case 8u:
    case 9u:
    case 0xAu:
      if ( a5 != (char *)10 )
      {
        v44 = (char *)sub_805A574("`");
        v41 = a5;
        v43 = (char *)sub_805A574("'");
      }
      v11 = &loc_805A865;
      if ( v49 == 1 )
        v11 = &loc_805A897;
      dword_806B284 = (int)v11;
      sub_8061B9D();
      for ( s = v44; *s; ++s )
      {
        if ( v62 < a2 )
          v47[v62] = *s;
        ++v62;
      }
      v48 = 1;
      s = v43;
      n = strlen(v43);
      break;
    default:
      abort();
      return result;
  }
  v61 = 0;
  while ( 1 )
  {
    if ( a4 == -1 )
    {
      v9 = v46;
      v36 = v61[(_DWORD)v46] != 0;
    }
    else
    {
      v36 = v61 != (char *)a4;
    }
    if ( !v36 )
      break;
    v55 = 0;
    v56 = 0;
    v57 = 0;
    if ( v48 )
    {
      v13 = &loc_805A97E;
      if ( a5 == (char *)2 )
        v13 = &loc_805A9FD;
      dword_806B2D4 = (int)v13;
      sub_80619CB();
      v14 = &loc_805A99D;
      if ( !n )
        v14 = &loc_805A9FD;
      dword_806B370 = (int)v14;
      sub_8061638();
      v15 = (size_t)&v61[n];
      if ( a4 != -1 || n <= 1 )
      {
        v16 = a4;
      }
      else
      {
        v16 = strlen(v46);
        a4 = v16;
      }
      if ( v15 <= v16 && !memcmp(&v46[(_DWORD)v61], s, n) )
      {
        if ( v49 )
          goto LABEL_224;
        v55 = 1;
      }
    }
    v9 = v46;
    v53 = v61[(_DWORD)v46];
    switch ( v53 )
    {
      case 0u:
        if ( v48 )
        {
          v17 = &loc_805AA4A;
          if ( !v49 )
            v17 = &loc_805AA4F;
          dword_806B234 = (int)v17;
          sub_8061D73();
          goto LABEL_224;
        }
        if ( a6 & 1 )
        {
          dword_806B384 = (int)&loc_805B3E6;
          sub_80615BE();
        }
        goto LABEL_165;
      case 7u:
        v54 = 97;
        goto LABEL_88;
      case 8u:
        v54 = 98;
        goto LABEL_88;
      case 9u:
        v54 = 116;
        goto LABEL_85;
      case 0xAu:
        v54 = 110;
        dword_806B220 = (int)&loc_805AD22;
        sub_8061DE3(v10, v46);
        goto LABEL_76;
      case 0xBu:
        v54 = 118;
        goto LABEL_88;
      case 0xCu:
        v54 = 102;
        goto LABEL_88;
      case 0xDu:
LABEL_76:
        v54 = 114;
        goto LABEL_85;
      case 0x20u:
        goto LABEL_96;
      case 0x21u:
      case 0x22u:
      case 0x24u:
      case 0x26u:
      case 0x28u:
      case 0x29u:
      case 0x2Au:
      case 0x3Bu:
      case 0x3Cu:
      case 0x3Du:
      case 0x3Eu:
      case 0x5Bu:
      case 0x5Eu:
      case 0x60u:
      case 0x7Cu:
        goto LABEL_97;
      case 0x23u:
      case 0x7Eu:
        goto LABEL_95;
      case 0x25u:
      case 0x2Bu:
      case 0x2Cu:
      case 0x2Du:
      case 0x2Eu:
      case 0x2Fu:
      case 0x30u:
      case 0x31u:
      case 0x32u:
      case 0x33u:
      case 0x34u:
      case 0x35u:
      case 0x36u:
      case 0x37u:
      case 0x38u:
      case 0x39u:
      case 0x3Au:
      case 0x41u:
      case 0x42u:
      case 0x43u:
      case 0x44u:
      case 0x45u:
      case 0x46u:
      case 0x47u:
      case 0x48u:
      case 0x49u:
      case 0x4Au:
      case 0x4Bu:
      case 0x4Cu:
      case 0x4Du:
      case 0x4Eu:
      case 0x4Fu:
      case 0x50u:
      case 0x51u:
      case 0x52u:
      case 0x53u:
      case 0x54u:
      case 0x55u:
      case 0x56u:
      case 0x57u:
      case 0x58u:
      case 0x59u:
      case 0x5Au:
      case 0x5Du:
      case 0x5Fu:
      case 0x61u:
      case 0x62u:
      case 0x63u:
      case 0x64u:
      case 0x65u:
      case 0x66u:
      case 0x67u:
      case 0x68u:
      case 0x69u:
      case 0x6Au:
      case 0x6Bu:
      case 0x6Cu:
      case 0x6Du:
      case 0x6Eu:
      case 0x6Fu:
      case 0x70u:
      case 0x71u:
      case 0x72u:
      case 0x73u:
      case 0x74u:
      case 0x75u:
      case 0x76u:
      case 0x77u:
      case 0x78u:
      case 0x79u:
      case 0x7Au:
        v57 = 1;
        dword_806B338 = (int)&loc_805B238;
        sub_8061791(v10, v46);
        goto LABEL_116;
      case 0x27u:
        v51 = 1;
        v57 = 1;
        v20 = &loc_805ADE0;
        if ( a5 != (char *)2 )
          v20 = &loc_805AE7D;
        dword_806B298 = (int)v20;
        sub_8061B2F(v10, v46);
        if ( v49 )
        {
          dword_806B310 = (int)&loc_805B55A;
          sub_8061877();
        }
        if ( a2 )
        {
          v21 = &loc_805AE22;
          if ( v63 )
            v21 = &loc_805AE2F;
          dword_806B2E8 = (int)v21;
          sub_8061957();
          v63 = a2;
          a2 = 0;
        }
        if ( v62 < a2 )
        {
          v9 = v47;
          v47[v62] = 39;
        }
        if ( ++v62 < a2 )
        {
          v9 = v47;
          v47[v62] = 92;
        }
        if ( ++v62 < a2 )
        {
          v9 = v47;
          v47[v62] = 39;
        }
        ++v62;
        v50 = 0;
        goto LABEL_165;
      case 0x3Fu:
        if ( a5 == (char *)2 )
        {
          if ( v49 )
            goto LABEL_224;
        }
        else if ( a5 == (char *)5 )
        {
          if ( a6 & 4 )
          {
            if ( (unsigned int)(v61 + 2) < a4 )
            {
              v9 = v61 + 1;
              if ( v46[(_DWORD)(v61 + 1)] == 63 )
              {
                v9 = v61 + 2;
                switch ( v46[(_DWORD)(v61 + 2)] )
                {
                  case 33:
                  case 39:
                  case 40:
                  case 41:
                  case 45:
                  case 47:
                  case 60:
                  case 61:
                  case 62:
                    if ( v49 )
                      goto LABEL_224;
                    v18 = (int)(v61 + 2);
                    v53 = v46[(_DWORD)(v61 + 2)];
                    v61 += 2;
                    if ( v62 < a2 )
                    {
                      v18 = (int)v47;
                      v47[v62] = 63;
                    }
                    if ( ++v62 < a2 )
                    {
                      v18 = (int)v47;
                      v47[v62] = 34;
                    }
                    if ( ++v62 < a2 )
                    {
                      v18 = (int)v47;
                      v47[v62] = 34;
                    }
                    if ( ++v62 < a2 )
                    {
                      v18 = (int)v47;
                      v47[v62] = 63;
                    }
                    ++v62;
                    dword_806B270 = (int)&loc_805AC8F;
                    sub_8061C11(v10, v18);
                    break;
                  default:
                    goto LABEL_165;
                }
              }
            }
          }
        }
        goto LABEL_165;
      case 0x5Cu:
        v54 = v53;
        if ( a5 != (char *)2 )
          goto LABEL_82;
        if ( v49 )
          goto LABEL_224;
        dword_806B2D4 = (int)&loc_805B37A;
        sub_80619CB();
LABEL_82:
        if ( v48 && v49 && n )
          goto LABEL_188;
LABEL_85:
        if ( a5 == (char *)2 && v49 )
        {
          dword_806B310 = (int)&loc_805B55A;
          sub_8061877();
        }
LABEL_88:
        if ( v48 )
        {
          v53 = v54;
LABEL_174:
          if ( v49 )
            goto LABEL_224;
          v56 = 1;
          v32 = &loc_805B2F6;
          if ( a5 != (char *)2 )
            v32 = &loc_805B363;
          dword_806B298 = (int)v32;
          sub_8061B2F(v10, v9);
          v35 = &loc_805B31A;
          if ( v50 == 1 )
            v35 = &loc_805B363;
          dword_806B25C = (int)v35;
          sub_8061C89(v34, v33);
          if ( v62 < a2 )
          {
            v9 = v47;
            v47[v62] = 39;
          }
          if ( ++v62 < a2 )
          {
            v9 = v47;
            v47[v62] = 36;
          }
          if ( ++v62 < a2 )
          {
            v9 = v47;
            v47[v62] = 39;
          }
          ++v62;
          v50 = 1;
          if ( v62 < a2 )
          {
            v9 = v47;
            v47[v62] = 92;
          }
          ++v62;
          goto LABEL_188;
        }
        dword_806B270 = (int)&loc_805B238;
        sub_8061C11(v10, v9);
LABEL_91:
        if ( a4 == -1 )
          v19 = v46[1] != 0;
        else
          v19 = a4 != 1;
        if ( !v19 )
        {
LABEL_95:
          if ( !v61 )
          {
LABEL_96:
            v57 = 1;
LABEL_97:
            if ( a5 == (char *)2 && v49 )
              goto LABEL_224;
          }
        }
LABEL_165:
        if ( v48 == 1 && a5 != (char *)2 || v49 == 1 )
        {
          v28 = &loc_805B273;
          if ( !v45 )
            v28 = &loc_805B2B8;
          dword_806B338 = (int)v28;
          sub_8061791(v10, v9);
          v29 = v53 & 0x1F;
          v30 = *(_DWORD *)(4 * (v53 >> 5) + v45) >> v29;
          v31 = &loc_805B2B8;
          if ( v30 & 1 )
            v31 = &loc_805B2C8;
          dword_806B338 = (int)v31;
          sub_8061791(v29, v30);
        }
        if ( v55 == 1 )
          goto LABEL_174;
LABEL_188:
        if ( v50 && v56 != 1 )
        {
          if ( v62 < a2 )
          {
            v9 = v47;
            v47[v62] = 39;
          }
          if ( ++v62 < a2 )
          {
            v9 = v47;
            v47[v62] = 39;
          }
          ++v62;
          v50 = 0;
        }
        if ( v62 < a2 )
        {
          v9 = &v47[v62];
          v47[v62] = v53;
        }
        ++v62;
        if ( v57 != 1 )
          v52 = 0;
        ++v61;
        break;
      case 0x7Bu:
      case 0x7Du:
        goto LABEL_91;
      default:
LABEL_116:
        if ( v59 )
        {
          v66 = 1;
          v22 = __ctype_b_loc();
          v9 = (char *)(2 * v53);
          v58 = (*(const unsigned __int16 *)((_BYTE *)*v22 + (_DWORD)v9) & 0x4000) != 0;
          goto LABEL_139;
        }
        memset(&ps, 0, 8u);
        v66 = 0;
        v58 = 1;
        v25 = &loc_805AF28;
        if ( a4 != -1 )
          v25 = &loc_805AF36;
        dword_806B220 = (int)v25;
        sub_8061DE3(v24, v23);
        a4 = strlen(v46);
        while ( 2 )
        {
          v42 = a4 - (_DWORD)&v61[v66];
          v41 = &v61[v66 + (_DWORD)v46];
          v68 = sub_805F95F((int)&v61[v66 + (_DWORD)v46], a4 - (_DWORD)&v61[v66], (wchar_t *)&wc, v41, v42, &ps);
          if ( v68 )
          {
            if ( v68 == -1 )
            {
              v58 = 0;
            }
            else
            {
              if ( v68 != -2 )
              {
                if ( v49 && a5 == (char *)2 )
                {
                  v67 = 1;
                  while ( v67 < v68 )
                  {
                    switch ( v61[v66 + v67 + (_DWORD)v46] )
                    {
                      case 91:
                      case 92:
                      case 94:
                      case 96:
                      case 124:
                        goto LABEL_224;
                      default:
                        ++v67;
                        break;
                    }
                  }
                }
                if ( !iswprint(wc) )
                  v58 = 0;
                v66 += v68;
                if ( mbsinit(&ps) )
                  break;
                continue;
              }
              v58 = 0;
              while ( 1 )
              {
                v9 = v61;
                if ( (unsigned int)&v61[v66] >= a4 )
                  break;
                v9 = &v61[v66];
                if ( !v61[v66 + (_DWORD)v46] )
                  break;
                ++v66;
              }
            }
          }
          break;
        }
LABEL_139:
        v57 = v58;
        if ( v66 > 1 )
          goto LABEL_144;
        if ( !v48 )
          goto LABEL_165;
        v26 = &loc_805B06F;
        if ( v58 == 1 )
          v26 = &loc_805B238;
        dword_806B310 = (int)v26;
        sub_8061877();
LABEL_144:
        v9 = v61;
        v69 = (unsigned int)&v61[v66];
        while ( !v48 || v58 == 1 )
        {
          if ( v55 )
          {
            if ( v62 < a2 )
            {
              v9 = v47;
              v47[v62] = 92;
            }
            ++v62;
            v55 = 0;
          }
          if ( (unsigned int)(v61 + 1) >= v69 )
            goto LABEL_188;
          if ( v50 && v56 != 1 )
          {
            if ( v62 < a2 )
              v47[v62] = 39;
            if ( ++v62 < a2 )
              v47[v62] = 39;
            ++v62;
            v50 = 0;
          }
          if ( v62 < a2 )
            v47[v62] = v53;
          ++v62;
          ++v61;
          v9 = v46;
          v53 = v61[(_DWORD)v46];
        }
        v27 = &loc_805B0B2;
        if ( !v49 )
          v27 = &loc_805B0B7;
        dword_806B20C = (int)v27;
        sub_8061E55();
        goto LABEL_224;
    }
  }
  if ( v62 )
    goto LABEL_231;
  v37 = &loc_805B438;
  if ( a5 != (char *)2 )
    v37 = &loc_805B443;
  dword_806B248 = (int)v37;
  sub_8061CFB(v10, v9);
  if ( v49 )
  {
LABEL_224:
    if ( a5 == (char *)2 )
    {
      v40 = &loc_805B57F;
      if ( !v48 )
        v40 = &loc_805B586;
      dword_806B370 = (int)v40;
      sub_8061638();
      a5 = (char *)4;
    }
    result = sub_805A72C((int)v47, a2, v46, a4, a5, a6 & 0xFFFFFFFD, 0, v44, v43);
  }
  else
  {
LABEL_231:
    if ( a5 == (char *)2 && v49 != 1 && v51 )
    {
      v38 = &loc_805B485;
      if ( !v52 )
        v38 = &loc_805B4CE;
      dword_806B2C0 = (int)v38;
      sub_8061A43();
      result = sub_805A72C((int)v47, v63, v46, a4, (char *)5, a6, v45, v44, v43);
    }
    else
    {
      if ( s && v49 != 1 )
      {
        while ( *s )
        {
          if ( v62 < a2 )
            v47[v62] = *s;
          ++v62;
          ++s;
        }
      }
      if ( v62 < a2 )
        v47[v62] = 0;
      result = v62;
    }
  }
  return result;
}
// 80615BE: using guessed type int sub_80615BE(void);
// 8061638: using guessed type int sub_8061638(void);
// 8061791: using guessed type int __fastcall sub_8061791(_DWORD, _DWORD);
// 8061877: using guessed type int sub_8061877(void);
// 8061957: using guessed type int sub_8061957(void);
// 80619CB: using guessed type int sub_80619CB(void);
// 8061A43: using guessed type int sub_8061A43(void);
// 8061B2F: using guessed type int __fastcall sub_8061B2F(_DWORD, _DWORD);
// 8061B9D: using guessed type int sub_8061B9D(void);
// 8061C11: using guessed type int __fastcall sub_8061C11(_DWORD, _DWORD);
// 8061C89: using guessed type int __fastcall sub_8061C89(_DWORD, _DWORD);
// 8061CFB: using guessed type int __fastcall sub_8061CFB(_DWORD, _DWORD);
// 8061D73: using guessed type int sub_8061D73(void);
// 8061DE3: using guessed type int __fastcall sub_8061DE3(_DWORD, _DWORD);
// 8061E55: using guessed type int sub_8061E55(void);
// 806B20C: using guessed type int dword_806B20C;
// 806B220: using guessed type int dword_806B220;
// 806B234: using guessed type int dword_806B234;
// 806B248: using guessed type int dword_806B248;
// 806B25C: using guessed type int dword_806B25C;
// 806B270: using guessed type int dword_806B270;
// 806B284: using guessed type int dword_806B284;
// 806B298: using guessed type int dword_806B298;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B2D4: using guessed type int dword_806B2D4;
// 806B2E8: using guessed type int dword_806B2E8;
// 806B310: using guessed type int dword_806B310;
// 806B338: using guessed type int dword_806B338;
// 806B370: using guessed type int dword_806B370;
// 806B384: using guessed type int dword_806B384;

//----- (0805B69D) --------------------------------------------------------
void *__cdecl sub_805B69D(char *a1, size_t a2, _DWORD *a3, int *a4)
{
  int *v4; // eax
  int *v5; // ST3C_4
  int v6; // ST40_4
  int v7; // ST44_4
  unsigned int size; // [esp+48h] [ebp-10h]
  void *v10; // [esp+4Ch] [ebp-Ch]

  if ( a4 )
    v4 = a4;
  else
    v4 = &dword_806C3D1;
  v5 = v4;
  v6 = *__errno_location();
  v7 = v5[1] | (a3 == 0);
  size = sub_805A72C(0, 0, a1, a2, (char *)*v5, v7, (int)(v5 + 2), (char *)v5[10], (char *)v5[11]) + 1;
  v10 = sub_805E4E9(size);
  sub_805A72C((int)v10, size, a1, a2, (char *)*v5, v7, (int)(v5 + 2), (char *)v5[10], (char *)v5[11]);
  *__errno_location() = v6;
  if ( a3 )
    *a3 = size - 1;
  return v10;
}
// 806C3D1: using guessed type int dword_806C3D1;

//----- (0805B88B) --------------------------------------------------------
void *__cdecl sub_805B88B(signed int a1, char *a2, size_t a3, int a4)
{
  void *v4; // eax
  int v5; // ecx
  void *v6; // eax
  size_t v7; // edx
  void *v8; // edx
  size_t v9; // ST4C_4
  bool v11; // [esp+37h] [ebp-21h]
  int *v12; // [esp+38h] [ebp-20h]
  int *v13; // [esp+38h] [ebp-20h]
  void *ptr; // [esp+3Ch] [ebp-1Ch]
  int v15; // [esp+40h] [ebp-18h]
  int size; // [esp+44h] [ebp-14h]
  int v17; // [esp+48h] [ebp-10h]
  unsigned int v18; // [esp+4Ch] [ebp-Ch]

  v15 = *__errno_location();
  v12 = off_806B484;
  if ( a1 < 0 )
    abort();
  v4 = &loc_805B8D2;
  if ( dword_806B478 > a1 )
    v4 = &loc_805B99A;
  dword_806B2C0 = (int)v4;
  sub_8061A43();
  v11 = v12 == &dword_806B47C;
  if ( (unsigned int)a1 > 0xFFFFFFE )
    sub_805E689();
  v6 = &loc_805B91A;
  if ( !v11 )
    v6 = &loc_805B921;
  dword_806B220 = (int)v6;
  sub_8061DE3(v5, 8 * (a1 + 1));
  v13 = (int *)sub_805E53F(0, v7);
  off_806B484 = v13;
  if ( v11 )
  {
    v8 = off_806B480;
    *v13 = dword_806B47C;
    v13[1] = (int)v8;
  }
  memset(&v13[2 * dword_806B478], 0, 8 * (a1 + 1 - dword_806B478));
  dword_806B478 = a1 + 1;
  v9 = v13[2 * a1];
  ptr = (void *)v13[2 * a1 + 1];
  v17 = *(_DWORD *)(a4 + 4) | 1;
  v18 = sub_805A72C(
          v13[2 * a1 + 1],
          v13[2 * a1],
          a2,
          a3,
          *(char **)a4,
          v17,
          a4 + 8,
          *(char **)(a4 + 40),
          *(char **)(a4 + 44));
  if ( v9 <= v18 )
  {
    size = v18 + 1;
    v13[2 * a1] = v18 + 1;
    if ( ptr != &unk_806C411 )
      free(ptr);
    ptr = sub_805E4E9(size);
    v13[2 * a1 + 1] = (int)ptr;
    sub_805A72C((int)ptr, size, a2, a3, *(char **)a4, v17, a4 + 8, *(char **)(a4 + 40), *(char **)(a4 + 44));
  }
  *__errno_location() = v15;
  return ptr;
}
// 8061A43: using guessed type int sub_8061A43(void);
// 8061DE3: using guessed type int __fastcall sub_8061DE3(_DWORD, _DWORD);
// 806B220: using guessed type int dword_806B220;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B478: using guessed type int dword_806B478;
// 806B47C: using guessed type int dword_806B47C;
// 806B480: using guessed type void *off_806B480;
// 806B484: using guessed type int *off_806B484;

//----- (0805BAE2) --------------------------------------------------------
void *__cdecl sub_805BAE2(signed int a1, char *a2)
{
  return sub_805B88B(a1, a2, 0xFFFFFFFF, (int)&dword_806C3D1);
}
// 806C3D1: using guessed type int dword_806C3D1;

//----- (0805BB0C) --------------------------------------------------------
void *__cdecl sub_805BB0C(signed int a1, char *a2, size_t a3)
{
  return sub_805B88B(a1, a2, a3, (int)&dword_806C3D1);
}
// 806C3D1: using guessed type int dword_806C3D1;

//----- (0805BB72) --------------------------------------------------------
void *__cdecl sub_805BB72(signed int a1, int a2, char *a3)
{
  char v4; // [esp+10h] [ebp-38h]

  sub_805A4F2(&v4, a2);
  return sub_805B88B(a1, a3, 0xFFFFFFFF, (int)&v4);
}

//----- (0805BBB0) --------------------------------------------------------
void *__cdecl sub_805BBB0(signed int a1, int a2, char *a3, size_t a4)
{
  char v5; // [esp+10h] [ebp-38h]

  sub_805A4F2(&v5, a2);
  return sub_805B88B(a1, a3, a4, (int)&v5);
}

//----- (0805BBED) --------------------------------------------------------
void *__cdecl sub_805BBED(int a1, char *a2)
{
  return sub_805BB72(0, a1, a2);
}

//----- (0805BC38) --------------------------------------------------------
void *__cdecl sub_805BC38(char *a1, size_t a2, unsigned __int8 a3)
{
  int v4; // [esp+20h] [ebp-38h]
  int v5; // [esp+24h] [ebp-34h]
  int v6; // [esp+28h] [ebp-30h]
  int v7; // [esp+2Ch] [ebp-2Ch]
  int v8; // [esp+30h] [ebp-28h]
  int v9; // [esp+34h] [ebp-24h]
  int v10; // [esp+38h] [ebp-20h]
  int v11; // [esp+3Ch] [ebp-1Ch]
  int v12; // [esp+40h] [ebp-18h]
  int v13; // [esp+44h] [ebp-14h]
  int v14; // [esp+48h] [ebp-10h]
  int v15; // [esp+4Ch] [ebp-Ch]

  v4 = dword_806C3D1;
  v5 = dword_806C3D5;
  v6 = dword_806C3D9;
  v7 = dword_806C3DD;
  v8 = dword_806C3E1;
  v9 = dword_806C3E5;
  v10 = dword_806C3E9;
  v11 = dword_806C3ED;
  v12 = dword_806C3F1;
  v13 = dword_806C3F5;
  v14 = dword_806C3F9;
  v15 = dword_806C3FD;
  sub_805A3EE(&v4, a3, 1);
  return sub_805B88B(0, a1, a2, (int)&v4);
}
// 806C3D1: using guessed type int dword_806C3D1;
// 806C3D5: using guessed type int dword_806C3D5;
// 806C3D9: using guessed type int dword_806C3D9;
// 806C3DD: using guessed type int dword_806C3DD;
// 806C3E1: using guessed type int dword_806C3E1;
// 806C3E5: using guessed type int dword_806C3E5;
// 806C3E9: using guessed type int dword_806C3E9;
// 806C3ED: using guessed type int dword_806C3ED;
// 806C3F1: using guessed type int dword_806C3F1;
// 806C3F5: using guessed type int dword_806C3F5;
// 806C3F9: using guessed type int dword_806C3F9;
// 806C3FD: using guessed type int dword_806C3FD;

//----- (0805BCE2) --------------------------------------------------------
void *__cdecl sub_805BCE2(char *a1, unsigned __int8 a2)
{
  return sub_805BC38(a1, 0xFFFFFFFF, a2);
}

//----- (0805BD0B) --------------------------------------------------------
void *__cdecl sub_805BD0B(char *a1)
{
  return sub_805BCE2(a1, 0x3Au);
}

//----- (0805BD48) --------------------------------------------------------
void *__cdecl sub_805BD48(signed int a1, int a2, char *a3)
{
  int v4; // [esp+10h] [ebp-68h]
  int v5; // [esp+14h] [ebp-64h]
  int v6; // [esp+18h] [ebp-60h]
  int v7; // [esp+1Ch] [ebp-5Ch]
  int v8; // [esp+20h] [ebp-58h]
  int v9; // [esp+24h] [ebp-54h]
  int v10; // [esp+28h] [ebp-50h]
  int v11; // [esp+2Ch] [ebp-4Ch]
  int v12; // [esp+30h] [ebp-48h]
  int v13; // [esp+34h] [ebp-44h]
  int v14; // [esp+38h] [ebp-40h]
  int v15; // [esp+3Ch] [ebp-3Ch]
  int v16; // [esp+40h] [ebp-38h]
  int v17; // [esp+44h] [ebp-34h]
  int v18; // [esp+48h] [ebp-30h]
  int v19; // [esp+4Ch] [ebp-2Ch]
  int v20; // [esp+50h] [ebp-28h]
  int v21; // [esp+54h] [ebp-24h]
  int v22; // [esp+58h] [ebp-20h]
  int v23; // [esp+5Ch] [ebp-1Ch]
  int v24; // [esp+60h] [ebp-18h]
  int v25; // [esp+64h] [ebp-14h]
  int v26; // [esp+68h] [ebp-10h]
  int v27; // [esp+6Ch] [ebp-Ch]

  sub_805A4F2(&v4, a2);
  v16 = v4;
  v17 = v5;
  v18 = v6;
  v19 = v7;
  v20 = v8;
  v21 = v9;
  v22 = v10;
  v23 = v11;
  v24 = v12;
  v25 = v13;
  v26 = v14;
  v27 = v15;
  sub_805A3EE(&v16, 0x3Au, 1);
  return sub_805B88B(a1, a3, 0xFFFFFFFF, (int)&v16);
}

//----- (0805BDE9) --------------------------------------------------------
void *__usercall sub_805BDE9@<eax>(int a1@<edx>, int a2@<ecx>, signed int a3, int a4, int a5, char *a6)
{
  return sub_805BE19(a1, a2, a3, a4, a5, a6, 0xFFFFFFFF);
}

//----- (0805BE19) --------------------------------------------------------
void *__usercall sub_805BE19@<eax>(int a1@<edx>, int a2@<ecx>, signed int a3, int a4, int a5, char *a6, size_t a7)
{
  int v8; // [esp+10h] [ebp-38h]
  int v9; // [esp+14h] [ebp-34h]
  int v10; // [esp+18h] [ebp-30h]
  int v11; // [esp+1Ch] [ebp-2Ch]
  int v12; // [esp+20h] [ebp-28h]
  int v13; // [esp+24h] [ebp-24h]
  int v14; // [esp+28h] [ebp-20h]
  int v15; // [esp+2Ch] [ebp-1Ch]
  int v16; // [esp+30h] [ebp-18h]
  int v17; // [esp+34h] [ebp-14h]
  int v18; // [esp+38h] [ebp-10h]
  int v19; // [esp+3Ch] [ebp-Ch]

  v8 = dword_806C3D1;
  v9 = dword_806C3D5;
  v10 = dword_806C3D9;
  v11 = dword_806C3DD;
  v12 = dword_806C3E1;
  v13 = dword_806C3E5;
  v14 = dword_806C3E9;
  v15 = dword_806C3ED;
  v16 = dword_806C3F1;
  v17 = dword_806C3F5;
  v18 = dword_806C3F9;
  v19 = dword_806C3FD;
  sub_805A498(a1, a2, (int)&v8, a4, a5);
  return sub_805B88B(a3, a6, a7, (int)&v8);
}
// 806C3D1: using guessed type int dword_806C3D1;
// 806C3D5: using guessed type int dword_806C3D5;
// 806C3D9: using guessed type int dword_806C3D9;
// 806C3DD: using guessed type int dword_806C3DD;
// 806C3E1: using guessed type int dword_806C3E1;
// 806C3E5: using guessed type int dword_806C3E5;
// 806C3E9: using guessed type int dword_806C3E9;
// 806C3ED: using guessed type int dword_806C3ED;
// 806C3F1: using guessed type int dword_806C3F1;
// 806C3F5: using guessed type int dword_806C3F5;
// 806C3F9: using guessed type int dword_806C3F9;
// 806C3FD: using guessed type int dword_806C3FD;

//----- (0805BF13) --------------------------------------------------------
void *__cdecl sub_805BF13(signed int a1, char *a2, size_t a3)
{
  return sub_805B88B(a1, a2, a3, (int)&unk_806B498);
}

//----- (0805BF5E) --------------------------------------------------------
void *__cdecl sub_805BF5E(signed int a1, char *a2)
{
  return sub_805BF13(a1, a2, 0xFFFFFFFF);
}

//----- (0805BF80) --------------------------------------------------------
void *__cdecl sub_805BF80(char *a1)
{
  return sub_805BF5E(0, a1);
}

//----- (0805BF9B) --------------------------------------------------------
void __cdecl __noreturn sub_805BF9B(char *a1)
{
  void *v1; // esi
  char *v2; // ebx
  int *v3; // eax

  if ( a1 )
  {
    v1 = sub_805BF80(a1);
    if ( *__errno_location() )
      v2 = gettext("%s: read error");
    else
      v2 = gettext("%s: end of file");
    v3 = __errno_location();
    error(status, *v3, v2, v1);
  }
  abort();
}

//----- (0805C004) --------------------------------------------------------
_DWORD *__cdecl sub_805C004(int a1, int a2)
{
  _DWORD *result; // eax

  result = sub_805E4FC(0x81Cu);
  *result = a1;
  result[1] = sub_805BF9B;
  result[2] = a2;
  return result;
}

//----- (0805C039) --------------------------------------------------------
unsigned int __cdecl sub_805C039(int a1, int a2, size_t nbytes)
{
  size_t v3; // eax
  int v4; // eax
  size_t n; // ST24_4
  int v6; // eax
  size_t v7; // ST28_4
  int v8; // eax
  size_t v9; // ST2C_4
  int v10; // eax
  size_t v11; // ST30_4
  unsigned int result; // eax
  int v13; // eax
  size_t v14; // ST34_4
  unsigned int v15; // [esp+18h] [ebp-30h]
  int fd; // [esp+20h] [ebp-28h]
  struct timeval tv; // [esp+38h] [ebp-10h]

  v15 = 0;
  fd = open64("/dev/urandom", 0);
  if ( fd >= 0 )
  {
    v3 = a2;
    if ( nbytes <= a2 )
      v3 = nbytes;
    v15 = read(fd, (void *)a1, v3);
    if ( (v15 & 0x80000000) != 0 )
      v15 = 0;
    close(fd);
  }
  if ( v15 < a2 )
  {
    v4 = a2 - v15;
    if ( a2 - v15 > 8 )
      v4 = 8;
    n = v4;
    gettimeofday(&tv, 0);
    memcpy((void *)(a1 + v15), &tv, n);
    v15 += n;
  }
  if ( v15 < a2 )
  {
    v6 = a2 - v15;
    if ( a2 - v15 > 4 )
      v6 = 4;
    v7 = v6;
    tv.tv_sec = getpid();
    memcpy((void *)(a1 + v15), &tv, v7);
    v15 += v7;
  }
  if ( v15 < a2 )
  {
    v8 = a2 - v15;
    if ( a2 - v15 > 4 )
      v8 = 4;
    v9 = v8;
    tv.tv_sec = getppid();
    memcpy((void *)(a1 + v15), &tv, v9);
    v15 += v9;
  }
  if ( v15 < a2 )
  {
    v10 = a2 - v15;
    if ( a2 - v15 > 4 )
      v10 = 4;
    v11 = v10;
    tv.tv_sec = getuid();
    memcpy((void *)(a1 + v15), &tv, v11);
    v15 += v11;
  }
  result = v15;
  if ( v15 < a2 )
  {
    v13 = a2 - v15;
    if ( a2 - v15 > 4 )
      v13 = 4;
    v14 = v13;
    tv.tv_sec = getgid();
    memcpy((void *)(a1 + v15), &tv, v14);
    result = v15 + v14;
  }
  return result;
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);

//----- (0805C246) --------------------------------------------------------
char *__cdecl sub_805C246(int a1, size_t n)
{
  int v2; // edx
  int v3; // ecx
  size_t v4; // eax
  FILE *stream; // [esp+18h] [ebp-10h]
  char *v7; // [esp+1Ch] [ebp-Ch]

  if ( !n )
  {
    sub_805C004(0, 0);
    dword_806B2C0 = (int)&locret_805C348;
    sub_8061A43();
  }
  stream = 0;
  if ( a1 )
  {
    stream = sub_806062B(a1, "rb");
    if ( !stream )
    {
      dword_806B248 = (int)&locret_805C348;
      sub_8061CFB(v3, v2);
    }
  }
  v7 = (char *)sub_805C004((int)stream, a1);
  if ( stream )
  {
    v4 = 2048;
    if ( n <= 0x800 )
      v4 = n;
    setvbuf(stream, v7 + 12, 0, v4);
  }
  else
  {
    *((_DWORD *)v7 + 3) = 0;
    sub_805C039((int)(v7 + 16), 1024, n);
    sub_805CACD((_DWORD *)v7 + 4);
  }
  return v7;
}
// 8061A43: using guessed type int sub_8061A43(void);
// 8061CFB: using guessed type int __fastcall sub_8061CFB(_DWORD, _DWORD);
// 806B248: using guessed type int dword_806B248;
// 806B2C0: using guessed type int dword_806B2C0;

//----- (0805C366) --------------------------------------------------------
size_t __cdecl sub_805C366(int a1, void *ptr, size_t n)
{
  size_t result; // eax
  int *v4; // ebx
  bool v5; // zf
  void *v6; // eax
  size_t v7; // [esp+18h] [ebp-10h]
  int v8; // [esp+1Ch] [ebp-Ch]

  v7 = fread_unlocked(ptr, 1u, n, *(FILE **)a1);
  v8 = *__errno_location();
  result = v7;
  if ( n != v7 )
  {
    v4 = __errno_location();
    v5 = ferror_unlocked(*(FILE **)a1) == 0;
    v6 = &loc_805C3E2;
    if ( v5 )
      v6 = &loc_805C3E7;
    dword_806B234 = (int)v6;
    sub_8061D73();
    *v4 = v8;
    (*(void (__cdecl **)(_DWORD))(a1 + 4))(*(_DWORD *)(a1 + 8));
    dword_806B2E8 = (int)&loc_805C36D;
    result = sub_8061957();
  }
  return result;
}
// 8061957: using guessed type int sub_8061957(void);
// 8061D73: using guessed type int sub_8061D73(void);
// 806B234: using guessed type int dword_806B234;
// 806B2E8: using guessed type int dword_806B2E8;

//----- (0805C41C) --------------------------------------------------------
int __cdecl sub_805C41C(int a1, void *dest, size_t n)
{
  int result; // eax
  int v4; // edx
  int v5; // ecx
  size_t v6; // [esp+14h] [ebp-14h]
  int *v7; // [esp+18h] [ebp-10h]
  char *v8; // [esp+1Ch] [ebp-Ch]
  size_t na; // [esp+38h] [ebp+10h]

  v6 = *(_DWORD *)a1;
  v8 = (char *)dest;
  if ( n > v6 )
  {
    memcpy(dest, (const void *)(a1 + 1024 - v6 + 1040), v6);
    na = n - v6;
    if ( ((_BYTE)v8 + (_BYTE)v6) & 3 )
    {
LABEL_8:
      sub_805C628((unsigned int *)(a1 + 4), (int *)(a1 + 1040));
      v6 = 1024;
      dword_806B2FC = (int)&loc_805C42A;
      result = sub_80618E9(v5, v4);
    }
    else
    {
      v7 = (int *)&v8[v6];
      dword_806B284 = (int)&loc_805C508;
      sub_8061B9D();
      while ( 1 )
      {
        sub_805C628((unsigned int *)(a1 + 4), v7);
        v7 += 256;
        na -= 1024;
        if ( !na )
          break;
        if ( na <= 0x3FF )
          goto LABEL_8;
      }
      result = a1;
      *(_DWORD *)a1 = 0;
    }
  }
  else
  {
    memcpy(dest, (const void *)(a1 + 1024 - v6 + 1040), n);
    result = a1;
    *(_DWORD *)a1 = v6 - n;
  }
  return result;
}
// 80618E9: using guessed type int __fastcall sub_80618E9(_DWORD, _DWORD);
// 8061B9D: using guessed type int sub_8061B9D(void);
// 806B284: using guessed type int dword_806B284;
// 806B2FC: using guessed type int dword_806B2FC;

//----- (0805C552) --------------------------------------------------------
size_t __cdecl sub_805C552(int a1, void *ptr, size_t n)
{
  size_t result; // eax

  if ( *(_DWORD *)a1 )
    result = sub_805C366(a1, ptr, n);
  else
    result = sub_805C41C(a1 + 12, ptr, n);
  return result;
}

//----- (0805C59A) --------------------------------------------------------
int __cdecl sub_805C59A(void *ptr)
{
  int result; // eax
  FILE *stream; // [esp+1Ch] [ebp-Ch]

  stream = *(FILE **)ptr;
  explicit_bzero(ptr, 2076);
  free(ptr);
  if ( stream )
    result = sub_805F563(stream);
  else
    result = 0;
  return result;
}
// 8049DE0: using guessed type int __cdecl explicit_bzero(_DWORD, _DWORD);

//----- (0805C5E0) --------------------------------------------------------
int __cdecl sub_805C5E0(int a1)
{
  return a1;
}

//----- (0805C5F7) --------------------------------------------------------
int __cdecl sub_805C5F7(int a1, __int16 a2)
{
  return *(_DWORD *)((a2 & 0x3FC) + a1);
}

//----- (0805C628) --------------------------------------------------------
unsigned int *__cdecl sub_805C628(unsigned int *a1, int *a2)
{
  unsigned int v2; // edx
  int v3; // ST08_4
  unsigned int v4; // ST18_4
  unsigned int v5; // ST1C_4
  int v6; // eax
  int v7; // ST0C_4
  unsigned int v8; // ST08_4
  unsigned int v9; // ST20_4
  int v10; // eax
  int v11; // eax
  int v12; // ST0C_4
  int v13; // ST08_4
  unsigned int v14; // ST28_4
  int v15; // eax
  int v16; // eax
  int v17; // ST0C_4
  unsigned int v18; // ST30_4
  int v19; // eax
  int v20; // eax
  int v21; // ST08_4
  unsigned int v22; // ST38_4
  unsigned int v23; // ST3C_4
  int v24; // eax
  int v25; // ST0C_4
  unsigned int v26; // ST08_4
  unsigned int v27; // ST40_4
  int v28; // eax
  int v29; // eax
  int v30; // ST0C_4
  int v31; // ST08_4
  unsigned int v32; // ST48_4
  int v33; // eax
  int v34; // eax
  int v35; // ST0C_4
  unsigned int v36; // ST50_4
  int v37; // eax
  int v38; // eax
  unsigned int *result; // eax
  unsigned int v40; // [esp+8h] [ebp-54h]
  int v41; // [esp+Ch] [ebp-50h]
  unsigned int *v42; // [esp+10h] [ebp-4Ch]
  int *v43; // [esp+14h] [ebp-48h]

  v40 = a1[256];
  v2 = a1[257];
  v41 = v2 + ++a1[258];
  v42 = a1;
  v43 = a2;
  do
  {
    v3 = (v40 ^ (v40 << 13)) + v42[128];
    v4 = *v42;
    v5 = sub_805C5F7((int)a1, *v42) + v3 + v41;
    *v42 = v5;
    v6 = sub_805C5F7((int)a1, v5 >> 8);
    v7 = sub_805C5E0(v4 + v6);
    *v43 = v7;
    v8 = (v3 ^ ((unsigned int)sub_805C5E0(v3) >> 6)) + v42[129];
    v9 = v42[1];
    v10 = sub_805C5F7((int)a1, v42[1]);
    v42[1] = v10 + v8 + v7;
    v11 = sub_805C5F7((int)a1, (v10 + v8 + v7) >> 8);
    v12 = sub_805C5E0(v9 + v11);
    v43[1] = v12;
    v13 = (v8 ^ 4 * v8) + v42[130];
    v14 = v42[2];
    v15 = sub_805C5F7((int)a1, v42[2]);
    v42[2] = v15 + v13 + v12;
    v16 = sub_805C5F7((int)a1, (unsigned int)(v15 + v13 + v12) >> 8);
    v17 = sub_805C5E0(v14 + v16);
    v43[2] = v17;
    v40 = (v13 ^ ((unsigned int)sub_805C5E0(v13) >> 16)) + v42[131];
    v18 = v42[3];
    v19 = sub_805C5F7((int)a1, v42[3]);
    v42[3] = v19 + v40 + v17;
    v20 = sub_805C5F7((int)a1, (v19 + v40 + v17) >> 8);
    v41 = sub_805C5E0(v18 + v20);
    v43[3] = v41;
    v43 += 4;
    v42 += 4;
  }
  while ( v42 < a1 + 128 );
  do
  {
    v21 = (v40 ^ (v40 << 13)) + *(v42 - 128);
    v22 = *v42;
    v23 = sub_805C5F7((int)a1, *v42) + v21 + v41;
    *v42 = v23;
    v24 = sub_805C5F7((int)a1, v23 >> 8);
    v25 = sub_805C5E0(v22 + v24);
    *v43 = v25;
    v26 = (v21 ^ ((unsigned int)sub_805C5E0(v21) >> 6)) + *(v42 - 127);
    v27 = v42[1];
    v28 = sub_805C5F7((int)a1, v42[1]);
    v42[1] = v28 + v26 + v25;
    v29 = sub_805C5F7((int)a1, (v28 + v26 + v25) >> 8);
    v30 = sub_805C5E0(v27 + v29);
    v43[1] = v30;
    v31 = (v26 ^ 4 * v26) + *(v42 - 126);
    v32 = v42[2];
    v33 = sub_805C5F7((int)a1, v42[2]);
    v42[2] = v33 + v31 + v30;
    v34 = sub_805C5F7((int)a1, (unsigned int)(v33 + v31 + v30) >> 8);
    v35 = sub_805C5E0(v32 + v34);
    v43[2] = v35;
    v40 = (v31 ^ ((unsigned int)sub_805C5E0(v31) >> 16)) + *(v42 - 125);
    v36 = v42[3];
    v37 = sub_805C5F7((int)a1, v42[3]);
    v42[3] = v37 + v40 + v35;
    v38 = sub_805C5F7((int)a1, (v37 + v40 + v35) >> 8);
    v41 = sub_805C5E0(v36 + v38);
    v43[3] = v41;
    v43 += 4;
    v42 += 4;
  }
  while ( v42 < a1 + 256 );
  a1[256] = v40;
  result = a1;
  a1[257] = v41;
  return result;
}

//----- (0805CACD) --------------------------------------------------------
_DWORD *__cdecl sub_805CACD(_DWORD *a1)
{
  int v1; // ST10_4
  int v2; // ST14_4
  int v3; // ST1C_4
  int v4; // ST20_4
  int v5; // ST24_4
  int v6; // ST28_4
  int v7; // ST0C_4
  int v8; // ST18_4
  unsigned int v9; // ST10_4
  int v10; // ST1C_4
  int v11; // ST14_4
  int v12; // ST20_4
  int v13; // ST24_4
  int v14; // ST28_4
  int v15; // ST0C_4
  int v16; // ST10_4
  int v17; // ST14_4
  int v18; // ST1C_4
  int v19; // ST20_4
  int v20; // ST24_4
  int v21; // ST28_4
  int v22; // ST0C_4
  int v23; // ST18_4
  unsigned int v24; // ST10_4
  int v25; // ST1C_4
  int v26; // ST14_4
  int v27; // ST20_4
  int v28; // ST24_4
  int v29; // ST28_4
  int v30; // ST0C_4
  _DWORD *result; // eax
  int v32; // [esp+Ch] [ebp-28h]
  int v33; // [esp+10h] [ebp-24h]
  int v34; // [esp+14h] [ebp-20h]
  unsigned int v35; // [esp+18h] [ebp-1Ch]
  int v36; // [esp+1Ch] [ebp-18h]
  unsigned int v37; // [esp+20h] [ebp-14h]
  int v38; // [esp+24h] [ebp-10h]
  unsigned int v39; // [esp+28h] [ebp-Ch]
  signed int i; // [esp+2Ch] [ebp-8h]
  signed int j; // [esp+30h] [ebp-4h]

  v32 = 325574490;
  v33 = -1780940711;
  v34 = -1021952437;
  v35 = 255990488;
  v36 = -651539848;
  v37 = -1525007287;
  v38 = -990909925;
  v39 = 811634969;
  for ( i = 0; i <= 255; i += 8 )
  {
    v1 = a1[i + 1] + v33;
    v2 = a1[i + 2] + v34;
    v3 = a1[i + 4] + v36;
    v4 = a1[i + 5] + v37;
    v5 = a1[i + 6] + v38;
    v6 = a1[i + 7] + v39;
    v7 = (v1 << 11) ^ (a1[i] + v32);
    v8 = v7 + a1[i + 3] + v35;
    v9 = ((unsigned int)sub_805C5E0(v2) >> 2) ^ (v2 + v1);
    v10 = v9 + v3;
    v11 = (v8 << 8) ^ (v8 + v2);
    v12 = v11 + v4;
    v35 = ((unsigned int)sub_805C5E0(v10) >> 16) ^ (v10 + v8);
    v13 = v35 + v5;
    v36 = (v12 << 10) ^ (v12 + v10);
    v14 = v36 + v6;
    v37 = ((unsigned int)sub_805C5E0(v13) >> 4) ^ (v13 + v12);
    v15 = v37 + v7;
    v38 = (v14 << 8) ^ (v14 + v13);
    v33 = v38 + v9;
    v39 = ((unsigned int)sub_805C5E0(v15) >> 9) ^ (v15 + v14);
    v34 = v39 + v11;
    v32 = v33 + v15;
    a1[i] = v32;
    a1[i + 1] = v33;
    a1[i + 2] = v34;
    a1[i + 3] = v35;
    a1[i + 4] = v36;
    a1[i + 5] = v37;
    a1[i + 6] = v38;
    a1[i + 7] = v39;
  }
  for ( j = 0; j <= 255; j += 8 )
  {
    v16 = a1[j + 1] + v33;
    v17 = a1[j + 2] + v34;
    v18 = a1[j + 4] + v36;
    v19 = a1[j + 5] + v37;
    v20 = a1[j + 6] + v38;
    v21 = a1[j + 7] + v39;
    v22 = (v16 << 11) ^ (a1[j] + v32);
    v23 = v22 + a1[j + 3] + v35;
    v24 = ((unsigned int)sub_805C5E0(v17) >> 2) ^ (v17 + v16);
    v25 = v24 + v18;
    v26 = (v23 << 8) ^ (v23 + v17);
    v27 = v26 + v19;
    v35 = ((unsigned int)sub_805C5E0(v25) >> 16) ^ (v25 + v23);
    v28 = v35 + v20;
    v36 = (v27 << 10) ^ (v27 + v25);
    v29 = v36 + v21;
    v37 = ((unsigned int)sub_805C5E0(v28) >> 4) ^ (v28 + v27);
    v30 = v37 + v22;
    v38 = (v29 << 8) ^ (v29 + v28);
    v33 = v38 + v24;
    v39 = ((unsigned int)sub_805C5E0(v30) >> 9) ^ (v30 + v29);
    v34 = v39 + v26;
    v32 = v33 + v30;
    a1[j] = v32;
    a1[j + 1] = v33;
    a1[j + 2] = v34;
    a1[j + 3] = v35;
    a1[j + 4] = v36;
    a1[j + 5] = v37;
    a1[j + 6] = v38;
    a1[j + 7] = v39;
  }
  a1[258] = 0;
  a1[257] = a1[258];
  result = a1;
  a1[256] = a1[257];
  return result;
}

//----- (0805CEDC) --------------------------------------------------------
signed int __cdecl sub_805CEDC(_DWORD *a1)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_805FB45((int)(a1 + 3), 0, 0, (int)malloc, (int)free);
  sub_805FB45((int)(a1 + 14), 0, 0, (int)malloc, (int)free);
  return sub_805FB45((int)(a1 + 25), 0, 0, (int)malloc, (int)free);
}

//----- (0805D0AA) --------------------------------------------------------
_DWORD *__cdecl sub_805D0AA(_DWORD *a1)
{
  _DWORD *result; // eax
  int src; // [esp+10h] [ebp-38h]
  _DWORD *v3; // [esp+14h] [ebp-34h]
  _DWORD *v4; // [esp+18h] [ebp-30h]
  int v5; // [esp+1Ch] [ebp-2Ch]
  int v6; // [esp+20h] [ebp-28h]
  _DWORD *v7; // [esp+24h] [ebp-24h]
  _DWORD *v8; // [esp+28h] [ebp-20h]
  _DWORD *v9; // [esp+2Ch] [ebp-1Ch]
  _DWORD *v10; // [esp+30h] [ebp-18h]
  _DWORD *v11; // [esp+34h] [ebp-14h]
  size_t n; // [esp+38h] [ebp-10h]
  _DWORD *v13; // [esp+3Ch] [ebp-Ch]

  v3 = a1 + 3;
  src = a1[6] - a1[5] - 1;
  v4 = a1 + 3;
  v5 = a1[5];
  if ( a1[6] == v5 )
    *((_BYTE *)v4 + 40) |= 2u;
  v4[3] = (v4[6] + v4[3]) & ~v4[6];
  if ( v4[3] - v4[1] > (unsigned int)(v4[4] - v4[1]) )
    v4[3] = v4[4];
  v4[2] = v4[3];
  v6 = v5;
  v7 = a1 + 14;
  v8 = a1 + 14;
  if ( (unsigned int)(a1[18] - a1[17]) <= 3 )
    sub_805FBCE((int)v7, 4);
  v9 = v7;
  v10 = (_DWORD *)v7[3];
  *v10 = v6;
  v9[3] += 4;
  v11 = a1 + 25;
  n = 4;
  v13 = a1 + 25;
  if ( (unsigned int)(a1[29] - a1[28]) < 4 )
    sub_805FBCE((int)v11, n);
  memcpy((void *)v11[3], &src, n);
  v11[3] += n;
  result = a1;
  ++*a1;
  return result;
}

//----- (0805D23F) --------------------------------------------------------
bool __cdecl sub_805D23F(FILE *stream, int a2)
{
  int v2; // ecx
  int v3; // edx
  void *v4; // eax
  _BYTE *v5; // eax
  _BYTE *v6; // eax
  int v8; // [esp+14h] [ebp-44h]
  int v9; // [esp+18h] [ebp-40h]
  int v10; // [esp+1Ch] [ebp-3Ch]
  int v11; // [esp+20h] [ebp-38h]
  int v12; // [esp+24h] [ebp-34h]
  int v13; // [esp+28h] [ebp-30h]
  int v14; // [esp+2Ch] [ebp-2Ch]
  int v15; // [esp+30h] [ebp-28h]
  _DWORD *v16; // [esp+34h] [ebp-24h]
  int v17; // [esp+38h] [ebp-20h]
  int v18; // [esp+3Ch] [ebp-1Ch]
  int v19; // [esp+40h] [ebp-18h]
  int v20; // [esp+44h] [ebp-14h]
  int v21; // [esp+48h] [ebp-10h]
  int v22; // [esp+4Ch] [ebp-Ch]

  while ( 1 )
  {
    v8 = fgetc(stream);
    if ( v8 == -1 )
      break;
    v21 = a2 + 12;
    v22 = a2 + 12;
    if ( *(_DWORD *)(a2 + 28) == *(_DWORD *)(a2 + 24) )
      sub_805FBCE(v21, 1);
    v6 = *(_BYTE **)(v21 + 12);
    *(_DWORD *)(v21 + 12) = v6 + 1;
    *v6 = v8;
    if ( !v8 )
    {
      sub_805D0AA((_DWORD *)a2);
      dword_806B284 = (int)&loc_805D245;
      sub_8061B9D();
    }
  }
  v9 = a2 + 12;
  v10 = *(_DWORD *)(a2 + 24) - *(_DWORD *)(a2 + 20);
  if ( v10 )
  {
    v11 = a2 + 12;
    v12 = a2 + 12;
    v3 = *(_DWORD *)(a2 + 28) - *(_DWORD *)(a2 + 24);
    v4 = &loc_805D2BF;
    if ( *(_DWORD *)(a2 + 28) != *(_DWORD *)(a2 + 24) )
      v4 = &loc_805D2D2;
    dword_806B270 = (int)v4;
    sub_8061C11(v2, v3);
    sub_805FBCE(v11, 1);
    v5 = *(_BYTE **)(v11 + 12);
    *(_DWORD *)(v11 + 12) = v5 + 1;
    *v5 = 0;
    sub_805D0AA((_DWORD *)a2);
  }
  v13 = a2 + 56;
  v14 = a2 + 56;
  if ( (unsigned int)(*(_DWORD *)(a2 + 72) - *(_DWORD *)(a2 + 68)) <= 3 )
    sub_805FBCE(v13, 4);
  v15 = v13;
  v16 = *(_DWORD **)(v13 + 12);
  *v16 = 0;
  *(_DWORD *)(v15 + 12) += 4;
  v17 = a2 + 56;
  v18 = *(_DWORD *)(a2 + 64);
  if ( *(_DWORD *)(a2 + 68) == v18 )
    *(_BYTE *)(v17 + 40) |= 2u;
  *(_DWORD *)(v17 + 12) = (*(_DWORD *)(v17 + 24) + *(_DWORD *)(v17 + 12)) & ~*(_DWORD *)(v17 + 24);
  if ( *(_DWORD *)(v17 + 12) - *(_DWORD *)(v17 + 4) > (unsigned int)(*(_DWORD *)(v17 + 16) - *(_DWORD *)(v17 + 4)) )
    *(_DWORD *)(v17 + 12) = *(_DWORD *)(v17 + 16);
  *(_DWORD *)(v17 + 8) = *(_DWORD *)(v17 + 12);
  *(_DWORD *)(a2 + 4) = v18;
  v19 = a2 + 100;
  v20 = *(_DWORD *)(a2 + 108);
  if ( *(_DWORD *)(a2 + 112) == v20 )
    *(_BYTE *)(v19 + 40) |= 2u;
  *(_DWORD *)(v19 + 12) = (*(_DWORD *)(v19 + 24) + *(_DWORD *)(v19 + 12)) & ~*(_DWORD *)(v19 + 24);
  if ( *(_DWORD *)(v19 + 12) - *(_DWORD *)(v19 + 4) > (unsigned int)(*(_DWORD *)(v19 + 16) - *(_DWORD *)(v19 + 4)) )
    *(_DWORD *)(v19 + 12) = *(_DWORD *)(v19 + 16);
  *(_DWORD *)(v19 + 8) = *(_DWORD *)(v19 + 12);
  *(_DWORD *)(a2 + 8) = v20;
  return ferror(stream) == 0;
}
// 8061B9D: using guessed type int sub_8061B9D(void);
// 8061C11: using guessed type int __fastcall sub_8061C11(_DWORD, _DWORD);
// 806B270: using guessed type int dword_806B270;
// 806B284: using guessed type int dword_806B284;

//----- (0805D527) --------------------------------------------------------
int __cdecl sub_805D527(int a1, int a2)
{
  int v2; // eax

  v2 = mkostemp64(a1, a2);
  return sub_80605A3(v2, a2);
}
// 8049A10: using guessed type int __cdecl mkostemp64(_DWORD, _DWORD);

//----- (0805D550) --------------------------------------------------------
int __cdecl sub_805D550(_BYTE *a1, _BYTE *a2, char a3)
{
  void *v3; // eax
  int v4; // ecx
  int v5; // edx
  void *v6; // eax
  _BYTE *v7; // edx
  _BYTE *v9; // eax
  _BYTE *v10; // edx
  int v11; // eax
  _BYTE *v12; // eax
  void *v13; // eax
  int v14; // eax
  char v15; // [esp+0h] [ebp-4h]
  char *v16; // [esp+Ch] [ebp+8h]
  _BYTE *v17; // [esp+Ch] [ebp+8h]
  _BYTE *v18; // [esp+10h] [ebp+Ch]
  _BYTE *v19; // [esp+10h] [ebp+Ch]

  v15 = a3;
  v3 = &loc_805D580;
  if ( *a1 != a3 )
    v3 = &loc_805D65F;
  dword_806B310 = (int)v3;
  sub_8061877();
  if ( *a2 == v15 )
  {
    v16 = a1 + 1;
    v5 = (unsigned __int8)*v16;
    v18 = a2 + 1;
    v6 = &loc_805D5DD;
    if ( (_BYTE)v5 == *v18 )
      v6 = &loc_805D591;
    dword_806B270 = (int)v6;
    sub_8061C11(v4, v5);
    if ( (unsigned int)(*v16 - 48) <= 9 && (unsigned int)((char)*v18 - 48) <= 9 )
      return *v16 - (char)*v18;
    if ( (unsigned int)(*v16 - 48) <= 9 )
    {
      dword_806B234 = (int)&loc_805D670;
      sub_8061D73();
    }
    if ( (unsigned int)((char)*v18 - 48) > 9 )
      return 0;
  }
  else
  {
    v9 = a1;
    v10 = a1 + 1;
    v17 = a1 + 1;
    if ( *v9 == v15 )
    {
      while ( *v17 == 48 )
        ++v17;
      v11 = (char)*v17 - 48;
      dword_806B324 = (int)&locret_805D72E;
      sub_8061801(v4, v10, *(_DWORD *)&v15);
    }
    v12 = a2;
    v7 = a2 + 1;
    v18 = a2 + 1;
    if ( *v12 != v15 )
      return 0;
  }
  dword_806B298 = (int)&loc_805D6D8;
  sub_8061B2F(v4, v7);
  v19 = v18 + 1;
  v13 = &loc_805D6FB;
  if ( *v19 == 48 )
    v13 = &loc_805D6D4;
  dword_806B384 = (int)v13;
  sub_80615BE();
  v14 = -((unsigned int)((char)*v19 - 48) <= 9);
  dword_806B310 = (int)&locret_805D72E;
  sub_8061877();
  return 0;
}
// 805D550: could not find valid save-restore pair for ebx
// 80615BE: using guessed type int sub_80615BE(void);
// 8061877: using guessed type int sub_8061877(void);
// 8061B2F: using guessed type int __fastcall sub_8061B2F(_DWORD, _DWORD);
// 8061C11: using guessed type int __fastcall sub_8061C11(_DWORD, _DWORD);
// 8061D73: using guessed type int sub_8061D73(void);
// 806B234: using guessed type int dword_806B234;
// 806B270: using guessed type int dword_806B270;
// 806B298: using guessed type int dword_806B298;
// 806B310: using guessed type int dword_806B310;
// 806B324: using guessed type int dword_806B324;
// 806B384: using guessed type int dword_806B384;

//----- (0805D730) --------------------------------------------------------
signed int __cdecl sub_805D730(unsigned __int8 *a1, unsigned __int8 *a2, int a3, int a4)
{
  void *v4; // eax
  void *v5; // eax
  int v6; // edx
  int v7; // ecx
  void *v8; // eax
  signed int result; // eax
  void *v10; // eax
  int v11; // edx
  int v12; // ecx
  void *v13; // eax
  unsigned __int8 v14; // [esp+Eh] [ebp-Eh]
  unsigned __int8 v15; // [esp+Fh] [ebp-Dh]
  unsigned int v16; // [esp+10h] [ebp-Ch]
  unsigned int v17; // [esp+14h] [ebp-8h]
  int v18; // [esp+18h] [ebp-4h]

  v14 = *a1;
  v15 = *a2;
  v4 = &loc_805D767;
  if ( v14 != 45 )
    v4 = &loc_805DA20;
  dword_806B2E8 = (int)v4;
  sub_8061957();
  do
  {
    do
      v14 = *++a1;
    while ( v14 == 48 );
  }
  while ( v14 == a4 );
  v5 = &loc_805D7A2;
  if ( v15 == 45 )
    v5 = &loc_805D87E;
  dword_806B20C = (int)v5;
  sub_8061E55();
  if ( v14 == a3 )
  {
    v14 = *++a1;
    v8 = &loc_805D7D7;
    if ( v14 == 48 )
      v8 = &loc_805D7AB;
    dword_806B338 = (int)v8;
    sub_8061791(v7, v6);
  }
  if ( (unsigned int)v14 - 48 <= 9 )
    return -1;
  dword_806B2FC = (int)&loc_805D811;
  sub_80618E9(v7, v6);
  do
  {
    do
      v15 = *++a2;
    while ( v15 == 48 );
  }
  while ( v15 == a4 );
  v10 = &loc_805D842;
  if ( v15 != a3 )
    v10 = &loc_805D855;
  dword_806B370 = (int)v10;
  sub_8061638();
  do
    v15 = *++a2;
  while ( v15 == 48 );
  dword_806B270 = (int)&locret_805DCA1;
  sub_8061C11(v12, v11);
  do
  {
    do
      v15 = *++a2;
    while ( v15 == 48 );
  }
  while ( v15 == a4 );
  while ( v14 == v15 && (unsigned int)v14 - 48 <= 9 )
  {
    do
      v14 = *++a1;
    while ( v14 == a4 );
    do
      v15 = *++a2;
    while ( v15 == a4 );
  }
  if ( v14 == a3 && (unsigned int)v15 - 48 > 9 || v15 == a3 && (unsigned int)v14 - 48 > 9 )
  {
    sub_805D550(a2, a1, a3);
    dword_806B2E8 = (int)&locret_805DCA1;
    sub_8061957();
  }
  v18 = v15 - v14;
  v16 = 0;
  while ( (unsigned int)v14 - 48 <= 9 )
  {
    do
      v14 = *++a1;
    while ( v14 == a4 );
    ++v16;
  }
  v17 = 0;
  dword_806B284 = (int)&loc_805D9B0;
  sub_8061B9D();
  do
  {
    do
      v15 = *++a2;
    while ( v15 == a4 );
    ++v17;
  }
  while ( (unsigned int)v15 - 48 <= 9 );
  v13 = &loc_805D9DD;
  if ( v16 == v17 )
    v13 = &loc_805D9F6;
  dword_806B284 = (int)v13;
  sub_8061B9D();
  if ( v16 >= v17 )
    result = -1;
  else
    result = 1;
  return result;
}
// 805D730: could not find valid save-restore pair for ebx
// 8061638: using guessed type int sub_8061638(void);
// 8061791: using guessed type int __fastcall sub_8061791(_DWORD, _DWORD);
// 80618E9: using guessed type int __fastcall sub_80618E9(_DWORD, _DWORD);
// 8061957: using guessed type int sub_8061957(void);
// 8061B9D: using guessed type int sub_8061B9D(void);
// 8061C11: using guessed type int __fastcall sub_8061C11(_DWORD, _DWORD);
// 8061E55: using guessed type int sub_8061E55(void);
// 806B20C: using guessed type int dword_806B20C;
// 806B270: using guessed type int dword_806B270;
// 806B284: using guessed type int dword_806B284;
// 806B2E8: using guessed type int dword_806B2E8;
// 806B2FC: using guessed type int dword_806B2FC;
// 806B338: using guessed type int dword_806B338;
// 806B370: using guessed type int dword_806B370;

//----- (0805DCA3) --------------------------------------------------------
signed int __cdecl sub_805DCA3(unsigned __int8 *a1, unsigned __int8 *a2, int a3, int a4)
{
  return sub_805D730(a1, a2, a3, a4);
}

//----- (0805DCCB) --------------------------------------------------------
int __usercall sub_805DCCB@<eax>(int a1@<edx>, int a2@<ecx>, int fd)
{
  void *v3; // eax
  int v4; // ST20_4
  int v5; // ST24_4

  if ( fd >= 0 )
  {
    v3 = &loc_805DCF6;
    if ( fd > 2 )
      v3 = &loc_805DD29;
    dword_806B338 = (int)v3;
    sub_8061791(a2, a1);
    v4 = sub_806111D(fd);
    v5 = *__errno_location();
    close(fd);
    *__errno_location() = v5;
    fd = v4;
  }
  return fd;
}
// 8061791: using guessed type int __fastcall sub_8061791(_DWORD, _DWORD);
// 806B338: using guessed type int dword_806B338;

//----- (0805DD2E) --------------------------------------------------------
int __usercall sub_805DD2E@<eax>(int a1@<edx>, int a2@<ecx>, FILE *stream, int a4, int a5, int a6, int a7, int a8)
{
  void *v8; // eax
  char *v9; // eax
  char *v10; // ebx
  char *v11; // eax
  int v12; // esi
  char *v13; // ebx
  char *v14; // eax
  int result; // eax
  int v16; // edi
  int v17; // esi
  char *v18; // ebx
  char *v19; // eax
  int v20; // edi
  int v21; // esi
  char *v22; // ebx
  char *v23; // eax
  int v24; // edi
  int v25; // esi
  char *v26; // ebx
  char *v27; // eax
  int v28; // edi
  int v29; // esi
  char *v30; // ebx
  char *v31; // eax
  int v32; // esi
  int v33; // edi
  char *v34; // ebx
  char *v35; // eax
  int v36; // edi
  int v37; // esi
  char *v38; // ebx
  char *v39; // eax
  int v40; // edi
  int v41; // esi
  char *v42; // ebx
  char *v43; // eax
  int v44; // edi
  int v45; // esi
  char *v46; // ebx
  char *v47; // eax
  char *v48; // [esp+8h] [ebp-60h]
  int v49; // [esp+Ch] [ebp-5Ch]
  int v50; // [esp+10h] [ebp-58h]
  int v51; // [esp+14h] [ebp-54h]
  int v52; // [esp+38h] [ebp-30h]
  int v53; // [esp+3Ch] [ebp-2Ch]
  int v54; // [esp+40h] [ebp-28h]
  int v55; // [esp+44h] [ebp-24h]
  int v56; // [esp+48h] [ebp-20h]
  int v57; // [esp+4Ch] [ebp-1Ch]

  v8 = &loc_805DD56;
  if ( !a4 )
    v8 = &loc_805DD80;
  dword_806B2FC = (int)v8;
  sub_80618E9(a2, a1);
  v50 = a6;
  fprintf(stream, "%s (%s) %s\n", a4, a5, a6);
  v49 = 2017;
  v48 = gettext("(C)");
  fprintf(stream, "Copyright %s %d Free Software Foundation, Inc.", v48, 2017);
  v9 = gettext(
         "\n"
         "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\n"
         "This is free software: you are free to change and redistribute it.\n"
         "There is NO WARRANTY, to the extent permitted by law.\n"
         "\n");
  fputs_unlocked(v9, stream);
  switch ( a8 )
  {
    case 0:
      abort();
      return result;
    case 1:
      v10 = *(char **)a7;
      v11 = gettext("Written by %s.\n");
      v48 = v10;
      fprintf(stream, v11, v10);
      dword_806B384 = (int)&loc_805E270;
      sub_80615BE();
      goto LABEL_6;
    case 2:
LABEL_6:
      v12 = *(_DWORD *)(a7 + 4);
      v13 = *(char **)a7;
      v14 = gettext("Written by %s and %s.\n");
      v49 = v12;
      v48 = v13;
      return fprintf(stream, v14, v13, v12);
    case 3:
      v16 = *(_DWORD *)(a7 + 8);
      v17 = *(_DWORD *)(a7 + 4);
      v18 = *(char **)a7;
      v19 = gettext("Written by %s, %s, and %s.\n");
      v50 = v16;
      v49 = v17;
      v48 = v18;
      fprintf(stream, v19, v18, v17, v16);
      dword_806B370 = (int)&loc_805E270;
      sub_8061638();
      goto LABEL_8;
    case 4:
LABEL_8:
      v57 = *(_DWORD *)(a7 + 12);
      v20 = *(_DWORD *)(a7 + 8);
      v21 = *(_DWORD *)(a7 + 4);
      v22 = *(char **)a7;
      v23 = gettext("Written by %s, %s, %s,\nand %s.\n");
      v51 = v57;
      v50 = v20;
      v49 = v21;
      v48 = v22;
      result = fprintf(stream, v23, v22, v21, v20, v57);
      break;
    case 5:
      v57 = *(_DWORD *)(a7 + 16);
      v56 = *(_DWORD *)(a7 + 12);
      v24 = *(_DWORD *)(a7 + 8);
      v25 = *(_DWORD *)(a7 + 4);
      v26 = *(char **)a7;
      v27 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
      result = fprintf(stream, v27, v26, v25, v24, v56, v57);
      break;
    case 6:
      v57 = *(_DWORD *)(a7 + 20);
      v56 = *(_DWORD *)(a7 + 16);
      v55 = *(_DWORD *)(a7 + 12);
      v28 = *(_DWORD *)(a7 + 8);
      v29 = *(_DWORD *)(a7 + 4);
      v30 = *(char **)a7;
      v31 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
      result = fprintf(stream, v31, v30, v29, v28, v55, v56, v57);
      break;
    case 7:
      v32 = *(_DWORD *)(a7 + 24);
      v57 = *(_DWORD *)(a7 + 20);
      v56 = *(_DWORD *)(a7 + 16);
      v55 = *(_DWORD *)(a7 + 12);
      v54 = *(_DWORD *)(a7 + 8);
      v33 = *(_DWORD *)(a7 + 4);
      v34 = *(char **)a7;
      v35 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
      result = fprintf(stream, v35, v34, v33, v54, v55, v56, v57, v32);
      break;
    case 8:
      v36 = *(_DWORD *)(a7 + 28);
      v57 = *(_DWORD *)(a7 + 24);
      v56 = *(_DWORD *)(a7 + 20);
      v55 = *(_DWORD *)(a7 + 16);
      v54 = *(_DWORD *)(a7 + 12);
      v53 = *(_DWORD *)(a7 + 8);
      v37 = *(_DWORD *)(a7 + 4);
      v38 = *(char **)a7;
      v39 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
      result = fprintf(stream, v39, v38, v37, v53, v54, v55, v56, v57, v36);
      break;
    case 9:
      v40 = *(_DWORD *)(a7 + 32);
      v57 = *(_DWORD *)(a7 + 28);
      v56 = *(_DWORD *)(a7 + 24);
      v55 = *(_DWORD *)(a7 + 20);
      v54 = *(_DWORD *)(a7 + 16);
      v53 = *(_DWORD *)(a7 + 12);
      v52 = *(_DWORD *)(a7 + 8);
      v41 = *(_DWORD *)(a7 + 4);
      v42 = *(char **)a7;
      v43 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
      result = fprintf(stream, v43, v42, v41, v52, v53, v54, v55, v56, v57, v40);
      break;
    default:
      v44 = *(_DWORD *)(a7 + 32);
      v57 = *(_DWORD *)(a7 + 28);
      v56 = *(_DWORD *)(a7 + 24);
      v55 = *(_DWORD *)(a7 + 20);
      v54 = *(_DWORD *)(a7 + 16);
      v53 = *(_DWORD *)(a7 + 12);
      v52 = *(_DWORD *)(a7 + 8);
      v45 = *(_DWORD *)(a7 + 4);
      v46 = *(char **)a7;
      v47 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
      result = fprintf(stream, v47, v46, v45, v52, v53, v54, v55, v56, v57, v44);
      break;
  }
  return result;
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 80615BE: using guessed type int sub_80615BE(void);
// 8061638: using guessed type int sub_8061638(void);
// 80618E9: using guessed type int __fastcall sub_80618E9(_DWORD, _DWORD);
// 806B2FC: using guessed type int dword_806B2FC;
// 806B370: using guessed type int dword_806B370;
// 806B384: using guessed type int dword_806B384;

//----- (0805E2D0) --------------------------------------------------------
int __usercall sub_805E2D0@<eax>(int a1@<edx>, int a2@<ecx>, FILE *stream, int a4, int a5, int a6, int a7)
{
  int *v7; // eax
  unsigned int i; // [esp+24h] [ebp-34h]
  int v10[12]; // [esp+28h] [ebp-30h]

  for ( i = 0; i <= 9; ++i )
  {
    v7 = (int *)a7;
    a7 += 4;
    a1 = *v7;
    v10[i] = *v7;
    if ( !v10[i] )
      break;
  }
  return sub_805DD2E(a1, a2, stream, a4, a5, a6, (int)v10, i);
}
// 805E2D0: using guessed type int var_30[12];

//----- (0805E336) --------------------------------------------------------
int __usercall sub_805E336@<eax>(int a1@<edx>, int a2@<ecx>, FILE *stream, int a4, int a5, int a6, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a6);
  return sub_805E2D0(a1, a2, stream, a4, a5, a6, (int)va);
}

//----- (0805E3D6) --------------------------------------------------------
void *__cdecl sub_805E3D6(unsigned int a1, unsigned int a2)
{
  if ( 0x7FFFFFFF / a2 < a1 )
    sub_805E689();
  return sub_805E4FC(a2 * a1);
}

//----- (0805E439) --------------------------------------------------------
void *__cdecl sub_805E439(void *ptr, int a2, int a3)
{
  void *v3; // eax
  unsigned int v5; // [esp+1Ch] [ebp-Ch]

  v5 = *(_DWORD *)a2;
  v3 = &loc_805E466;
  if ( ptr )
    v3 = &loc_805E4A0;
  dword_806B2C0 = (int)v3;
  sub_8061A43();
  if ( !v5 )
    v5 = (0x40u / a3 == 0) + 0x40u / a3;
  if ( 0x7FFFFFFFu / a3 < v5 )
    sub_805E689();
  *(_DWORD *)a2 = v5;
  return sub_805E53F(ptr, a3 * v5);
}
// 8061A43: using guessed type int sub_8061A43(void);
// 806B2C0: using guessed type int dword_806B2C0;

//----- (0805E4E9) --------------------------------------------------------
void *__cdecl sub_805E4E9(size_t size)
{
  return sub_805E4FC(size);
}

//----- (0805E4FC) --------------------------------------------------------
void *__cdecl sub_805E4FC(size_t size)
{
  void *v1; // eax
  int v2; // edx
  int v3; // ecx
  bool v4; // zf
  void *v5; // eax
  void *v7; // [esp+1Ch] [ebp-Ch]

  v1 = malloc(size);
  v7 = v1;
  v4 = v1 == 0;
  v5 = &loc_805E52F;
  if ( !v4 )
    v5 = &loc_805E53A;
  dword_806B35C = (int)v5;
  sub_80616AA(v3, v2);
  if ( size )
    sub_805E689();
  return v7;
}
// 80616AA: using guessed type int __fastcall sub_80616AA(_DWORD, _DWORD);
// 806B35C: using guessed type int dword_806B35C;

//----- (0805E53F) --------------------------------------------------------
void *__cdecl sub_805E53F(void *ptr, size_t size)
{
  void *result; // eax
  void *ptra; // [esp+20h] [ebp+8h]

  if ( size || !ptr )
  {
    ptra = realloc(ptr, size);
    if ( !ptra )
    {
      if ( size )
        sub_805E689();
    }
    result = ptra;
  }
  else
  {
    free(ptr);
    result = 0;
  }
  return result;
}

//----- (0805E5DA) --------------------------------------------------------
int __cdecl sub_805E5DA(size_t nmemb, size_t size)
{
  void *v2; // ST1C_4
  _DWORD *savedregs; // [esp+28h] [ebp+0h]

  savedregs = &savedregs;
  dword_806B348 = (int (__cdecl *)(_DWORD))&loc_805E631;
  if ( 0x7FFFFFFF / size >= nmemb )
  {
    v2 = calloc(nmemb, size);
    dword_806B348 = (int (__cdecl *)(_DWORD))sub_805E636;
    if ( !v2 )
      sub_805E689();
  }
  return dword_806B348(nmemb);
}
// 805E636: using guessed type int sub_805E636();
// 806B348: using guessed type int (__cdecl *dword_806B348)(_DWORD);

//----- (0805E636) --------------------------------------------------------
#error "805E63A: positive sp value has been found (funcsize=0)"

//----- (0805E63B) --------------------------------------------------------
void *__cdecl sub_805E63B(void *src, size_t n)
{
  void *v2; // eax

  v2 = sub_805E4FC(n);
  return memcpy(v2, src, n);
}

//----- (0805E689) --------------------------------------------------------
void __noreturn sub_805E689()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (0805E6C2) --------------------------------------------------------
void __cdecl sub_805E6C2(int errnum, int a2, int a3, int a4, int a5)
{
  char *v5; // eax
  char *v6; // eax
  void *v7; // esi
  void *v8; // ebx
  char *v9; // eax

  v5 = gettext("string comparison failed");
  error(0, errnum, v5);
  v6 = gettext("Set LC_ALL='C' to work around the problem.");
  error(0, 0, v6);
  v7 = sub_805BBB0(1, 8, (char *)a4, a5);
  v8 = sub_805BBB0(0, 8, (char *)a2, a3);
  v9 = gettext("The strings compared were %s and %s.");
  error(status, 0, v9, v8, v7);
}

//----- (0805E7F3) --------------------------------------------------------
int __cdecl sub_805E7F3(void *s1, size_t n, void *s2, int a4)
{
  int v5; // [esp+28h] [ebp-10h]
  int errnum; // [esp+2Ch] [ebp-Ch]

  v5 = sub_8060FB5(s1, n, s2, a4);
  errnum = *__errno_location();
  if ( errnum )
    sub_805E6C2(errnum, (int)s1, n - 1, (int)s2, a4 - 1);
  return v5;
}

//----- (0805E85E) --------------------------------------------------------
int __cdecl sub_805E85E(double a1)
{
  bool v2; // zf
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  double v6; // [esp+18h] [ebp-20h]
  struct timespec requested_time; // [esp+28h] [ebp-10h]

  v6 = a1;
  sub_8060448(&requested_time, a1);
  *__errno_location() = 0;
  if ( !nanosleep(&requested_time, 0) )
    return 0;
  v2 = *__errno_location() == 4;
  v5 = &loc_805E8D3;
  if ( v2 )
    v5 = &loc_805E8E5;
  dword_806B298 = (int)v5;
  sub_8061B2F(v4, v3);
  if ( *__errno_location() )
    return -1;
  dword_806B384 = (int)&loc_805E885;
  return sub_80615BE();
}
// 80615BE: using guessed type int sub_80615BE(void);
// 8061B2F: using guessed type int __fastcall sub_8061B2F(_DWORD, _DWORD);
// 806B298: using guessed type int dword_806B298;
// 806B384: using guessed type int dword_806B384;

//----- (0805E8FE) --------------------------------------------------------
signed int __cdecl sub_805E8FE(unsigned int *a1, unsigned int a2)
{
  signed int result; // eax

  if ( 0xFFFFFFFF / a2 >= *a1 )
  {
    *a1 *= a2;
    result = 0;
  }
  else
  {
    *a1 = -1;
    result = 1;
  }
  return result;
}

//----- (0805E942) --------------------------------------------------------
int __cdecl sub_805E942(unsigned int *a1, unsigned int a2, int a3)
{
  int v3; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; i |= sub_805E8FE(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}

//----- (0805E978) --------------------------------------------------------
int __cdecl sub_805E978(char *nptr, int a2, int base)
{
  bool v3; // zf
  void *v4; // eax
  void *v5; // eax
  unsigned __int8 v7; // [esp+1Fh] [ebp-29h]
  int v8; // [esp+28h] [ebp-20h]
  char *v9; // [esp+2Ch] [ebp-1Ch]
  char **endptr; // [esp+3Ch] [ebp-Ch]

  v8 = 0;
  if ( base < 0 || base > 36 )
LABEL_5:
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoul");
  if ( !a2 )
  {
    dword_806B310 = (int)&loc_805E9D2;
    sub_8061877();
    goto LABEL_5;
  }
  endptr = (char **)a2;
  *__errno_location() = 0;
  v9 = nptr;
  v7 = *nptr;
  v3 = ((*__ctype_b_loc())[v7] & 0x2000) == 0;
  v4 = &loc_805EA52;
  if ( !v3 )
    v4 = &loc_805EA0E;
  dword_806B2E8 = (int)v4;
  sub_8061957();
  v5 = &loc_805EA71;
  if ( v7 != 45 )
    v5 = &loc_805EA7B;
  dword_806B2D4 = (int)v5;
  sub_80619CB();
  return 4;
}
// 805E978: could not find valid save-restore pair for ebx
// 8061877: using guessed type int sub_8061877(void);
// 8061957: using guessed type int sub_8061957(void);
// 80619CB: using guessed type int sub_80619CB(void);
// 806B2D4: using guessed type int dword_806B2D4;
// 806B2E8: using guessed type int dword_806B2E8;
// 806B310: using guessed type int dword_806B310;

//----- (0805EEA2) --------------------------------------------------------
void __usercall sub_805EEA2(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, int a6, int a7, int status)
{
  void *v8; // eax
  char *v9; // eax
  const char *v10; // [esp+Ch] [ebp-2Ch]
  char *v11; // [esp+10h] [ebp-28h]
  int v12; // [esp+14h] [ebp-24h]
  char v13; // [esp+1Ch] [ebp-1Ch]
  char v14; // [esp+22h] [ebp-16h]
  char v15; // [esp+23h] [ebp-15h]
  const char *v16; // [esp+24h] [ebp-14h]
  char *msgid; // [esp+28h] [ebp-10h]
  char *v18; // [esp+2Ch] [ebp-Ch]

  v13 = a5;
  v16 = "--";
  if ( (unsigned int)a3 > 3 )
  {
    if ( a3 != 4 )
      goto LABEL_7;
    msgid = "invalid %s%s argument '%s'";
    dword_806B370 = (int)&loc_805EF1A;
    sub_8061638();
  }
  else if ( (unsigned int)a3 < 2 )
  {
    v8 = &loc_805EEE0;
    if ( a3 == 1 )
      v8 = &loc_805EF13;
    dword_806B220 = (int)v8;
    sub_8061DE3(a2, a1);
LABEL_7:
    abort();
  }
  msgid = "invalid suffix in %s%s argument '%s'";
  if ( a4 >= 0 )
  {
    v18 = *(char **)(16 * a4 + a6);
  }
  else
  {
    v16 -= a4;
    v14 = v13;
    v15 = 0;
    v18 = &v14;
  }
  v9 = gettext(msgid);
  v12 = a7;
  v11 = v18;
  v10 = v16;
  error(status, 0, v9, v16, v18, a7);
}
// 8061638: using guessed type int sub_8061638(void);
// 8061DE3: using guessed type int __fastcall sub_8061DE3(_DWORD, _DWORD);
// 806B220: using guessed type int dword_806B220;
// 806B370: using guessed type int dword_806B370;

//----- (0805EF86) --------------------------------------------------------
void __fastcall __noreturn sub_805EF86(int a1, int a2, int a3, int a4, char a5, int a6, int a7)
{
  sub_805EEA2(a6, a1, a3, a4, a5, a6, a7, status);
  abort();
}

//----- (0805EFC9) --------------------------------------------------------
signed int __cdecl sub_805EFC9(int a1, int a2)
{
  signed int result; // eax
  int v3; // ebx

  if ( (unsigned __int64)sub_8061142(0xFFFFFFFF, 0xFFFFFFFF, a2, a2 >> 31) >= *(_QWORD *)a1 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    *(_QWORD *)a1 *= a2;
    result = 0;
  }
  else
  {
    *(_DWORD *)a1 = -1;
    *(_DWORD *)(a1 + 4) = -1;
    result = 1;
  }
  return result;
}

//----- (0805F055) --------------------------------------------------------
int __usercall sub_805F055@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5)
{
  int v5; // eax
  int v7; // [esp+1Ch] [ebp-Ch]

  v7 = 0;
  dword_806B220 = (int)&loc_805F08E;
  sub_8061DE3(a2, a1);
  do
  {
    v7 |= sub_805EFC9(a3, a4);
    v5 = a5--;
  }
  while ( v5 );
  return v7;
}
// 8061DE3: using guessed type int __fastcall sub_8061DE3(_DWORD, _DWORD);
// 806B220: using guessed type int dword_806B220;

//----- (0805F0A0) --------------------------------------------------------
int __usercall sub_805F0A0@<eax>(int a1@<edx>, int a2@<ecx>, char *nptr, int a4, int base, int a6, char *s)
{
  int v8; // edx
  int v9; // ecx
  void *v10; // eax
  int v11; // edx
  unsigned __int8 i; // [esp+1Bh] [ebp-2Dh]
  int v13; // [esp+20h] [ebp-28h]
  char *v14; // [esp+24h] [ebp-24h]
  char **endptr; // [esp+34h] [ebp-14h]
  uintmax_t v16; // [esp+38h] [ebp-10h]

  v13 = 0;
  if ( base < 0 || base > 36 )
LABEL_5:
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoumax");
  if ( !a4 )
  {
    dword_806B298 = (int)&loc_805F0FA;
    sub_8061B2F(a2, a1);
    goto LABEL_5;
  }
  endptr = (char **)a4;
  *__errno_location() = 0;
  v14 = nptr;
  for ( i = *nptr; (*__ctype_b_loc())[i] & 0x2000; i = *v14 )
    ++v14;
  if ( i == 45 )
    return 4;
  v16 = strtoumax(nptr, endptr, base);
  if ( *endptr == nptr )
  {
    if ( s && **endptr && strchr(s, **endptr) )
    {
      v16 = 1LL;
      dword_806B284 = (int)&loc_805F233;
      sub_8061B9D();
    }
    dword_806B2C0 = (int)&locret_805F561;
    sub_8061A43();
  }
  if ( *__errno_location() )
  {
    if ( *__errno_location() != 34 )
      return 4;
    v13 = 1;
  }
  v10 = &loc_805F252;
  if ( s )
    v10 = &loc_805F268;
  dword_806B2AC = (int)v10;
  sub_8061AB5(v9, v8);
  v11 = HIDWORD(v16);
  *(_DWORD *)a6 = v16;
  *(_DWORD *)(a6 + 4) = v11;
  return v13;
}
// 8061A43: using guessed type int sub_8061A43(void);
// 8061AB5: using guessed type int __fastcall sub_8061AB5(_DWORD, _DWORD);
// 8061B2F: using guessed type int __fastcall sub_8061B2F(_DWORD, _DWORD);
// 8061B9D: using guessed type int sub_8061B9D(void);
// 806B284: using guessed type int dword_806B284;
// 806B298: using guessed type int dword_806B298;
// 806B2AC: using guessed type int dword_806B2AC;
// 806B2C0: using guessed type int dword_806B2C0;

//----- (0805F563) --------------------------------------------------------
int __cdecl sub_805F563(FILE *stream)
{
  int v2; // eax
  __int64 v3; // rax
  bool v4; // zf
  void *v5; // eax
  int v6; // [esp+14h] [ebp-14h]
  int v7; // [esp+18h] [ebp-10h]

  v6 = 0;
  if ( fileno(stream) < 0 )
    return fclose(stream);
  if ( __freading(stream) )
  {
    v2 = fileno(stream);
    LODWORD(v3) = lseek64(v2, 0, 0, 1);
    v4 = v3 == -1;
    v5 = &loc_805F5FC;
    if ( v4 )
      v5 = &loc_805F615;
    dword_806B234 = (int)v5;
    sub_8061D73();
  }
  if ( sub_805F817(stream) )
    v6 = *__errno_location();
  v7 = fclose(stream);
  if ( v6 )
  {
    *__errno_location() = v6;
    v7 = -1;
  }
  return v7;
}
// 8049A90: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8061D73: using guessed type int sub_8061D73(void);
// 806B234: using guessed type int dword_806B234;

//----- (0805F63F) --------------------------------------------------------
int __cdecl sub_805F63F(int fd, int cmd, char a3)
{
  void *v3; // eax
  char *v4; // eax
  int v6; // [esp+8h] [ebp-30h]
  char *v7; // [esp+18h] [ebp-20h]
  int v8; // [esp+1Ch] [ebp-1Ch]
  char v9[4]; // [esp+20h] [ebp-18h]
  int v10; // [esp+24h] [ebp-14h]
  int v11; // [esp+28h] [ebp-10h]

  v8 = -1;
  v7 = &a3;
  v3 = &loc_805F675;
  if ( cmd != 1030 )
    v3 = &loc_805F7A5;
  dword_806B370 = (int)v3;
  sub_8061638();
  v4 = v7;
  v7 += 4;
  *(_DWORD *)v9 = *(_DWORD *)v4;
  if ( dword_806C511 < 0 )
  {
    v8 = sub_805F63F(fd, 0, v9[0]);
  }
  else
  {
    v6 = *(_DWORD *)v9;
    v8 = fcntl(fd, cmd, *(_DWORD *)v9);
    if ( v8 < 0 && *__errno_location() == 22 )
    {
      v8 = sub_805F63F(fd, 0, v9[0]);
      if ( v8 < 0 )
      {
        dword_806B234 = (int)&loc_805F7CF;
        sub_8061D73();
      }
      dword_806C511 = -1;
    }
    else
    {
      dword_806C511 = 1;
    }
  }
  if ( v8 >= 0 && dword_806C511 == -1 )
  {
    v10 = fcntl(v8, 1);
    if ( v10 < 0 || (v6 = v10 | 1, fcntl(v8, 2, v10 | 1) == -1) )
    {
      v11 = *__errno_location();
      close(v8);
      *__errno_location() = v11;
      v8 = -1;
    }
  }
  return v8;
}
// 8061638: using guessed type int sub_8061638(void);
// 8061D73: using guessed type int sub_8061D73(void);
// 806B234: using guessed type int dword_806B234;
// 806B370: using guessed type int dword_806B370;
// 806C511: using guessed type int dword_806C511;

//----- (0805F7DE) --------------------------------------------------------
int __cdecl sub_805F7DE(FILE *stream)
{
  int result; // eax

  result = stream->_flags & 0x100;
  if ( result )
    result = sub_805F857(stream, 0, 0, 1);
  return result;
}

//----- (0805F817) --------------------------------------------------------
int __cdecl sub_805F817(FILE *fp)
{
  if ( !fp || !__freading(fp) )
    return fflush(fp);
  sub_805F7DE(fp);
  return fflush(fp);
}

//----- (0805F857) --------------------------------------------------------
int __cdecl sub_805F857(FILE *stream, int a2, int a3, int a4)
{
  int v4; // ecx
  char *v5; // edx
  void *v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // ecx
  int v10; // edx
  int v11; // edx
  bool v12; // zf
  void *v13; // eax
  int v15; // [esp+0h] [ebp-38h]

  if ( stream->_IO_read_end != stream->_IO_read_ptr )
    return fseeko64(stream, a2, a3, a4);
  v5 = stream->_IO_write_ptr;
  v6 = &loc_805F8A6;
  if ( v5 != stream->_IO_write_base )
    v6 = &loc_805F93D;
  dword_806B2AC = (int)v6;
  sub_8061AB5(v4, v5);
  if ( stream->_IO_save_base )
    return fseeko64(stream, a2, a3, a4);
  v7 = fileno(stream);
  v8 = lseek64(v7, a2, a3, a4);
  v11 = ~v10;
  v12 = (v11 | ~v8) == 0;
  v13 = &loc_805F911;
  if ( !v12 )
    v13 = &loc_805F918;
  dword_806B324 = (int)v13;
  sub_8061801(v9, v11, v15);
  return -1;
}
// 805F857: could not find valid save-restore pair for ebx
// 80498B0: using guessed type int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8049A90: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8061AB5: using guessed type int __fastcall sub_8061AB5(_DWORD, _DWORD);
// 806B2AC: using guessed type int dword_806B2AC;
// 806B324: using guessed type int dword_806B324;

//----- (0805F95F) --------------------------------------------------------
size_t __usercall sub_805F95F@<eax>(int a1@<edx>, int a2@<ecx>, wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  void *v6; // eax
  wchar_t v8; // [esp+18h] [ebp-10h]
  size_t v9; // [esp+1Ch] [ebp-Ch]

  v6 = &loc_805F984;
  if ( pwc )
    v6 = &loc_805F98A;
  dword_806B35C = (int)v6;
  sub_80616AA(a2, a1);
  v9 = mbrtowc(&v8, s, n, p);
  if ( v9 <= 0xFFFFFFFD || !n || !((unsigned __int8)sub_8057B3E(0) ^ 1) )
    return v9;
  v8 = (unsigned __int8)*s;
  return 1;
}
// 80616AA: using guessed type int __fastcall sub_80616AA(_DWORD, _DWORD);
// 806B35C: using guessed type int dword_806B35C;

//----- (0805F9EA) --------------------------------------------------------
int __cdecl sub_805F9EA(int a1, int a2)
{
  int result; // eax

  if ( *(_BYTE *)(a1 + 40) & 1 )
    result = (*(int (__cdecl **)(_DWORD, int))(a1 + 28))(*(_DWORD *)(a1 + 36), a2);
  else
    result = (*(int (__cdecl **)(int))(a1 + 28))(a2);
  return result;
}

//----- (0805FA28) --------------------------------------------------------
int __cdecl sub_805FA28(int a1, int a2)
{
  int result; // eax

  if ( *(_BYTE *)(a1 + 40) & 1 )
    result = (*(int (__cdecl **)(_DWORD, int))(a1 + 32))(*(_DWORD *)(a1 + 36), a2);
  else
    result = (*(int (__cdecl **)(int))(a1 + 32))(a2);
  return result;
}

//----- (0805FA66) --------------------------------------------------------
signed int __cdecl sub_805FA66(int a1, signed int a2, signed int a3)
{
  _DWORD *v4; // [esp+1Ch] [ebp-Ch]

  if ( !a3 )
    a3 = 8;
  if ( !a2 )
    a2 = 4064;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 24) = a3 - 1;
  *(_DWORD *)(a1 + 4) = sub_805F9EA(a1, *(_DWORD *)a1);
  v4 = *(_DWORD **)(a1 + 4);
  if ( !v4 )
    obstack_alloc_failed_handler();
  *(_DWORD *)(a1 + 8) = ((unsigned int)&v4[a3 / 4u + 1] + 3) & -a3;
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 8);
  *v4 = (char *)v4 + *(_DWORD *)a1;
  *(_DWORD *)(a1 + 16) = *v4;
  v4[1] = 0;
  *(_BYTE *)(a1 + 40) &= 0xFDu;
  *(_BYTE *)(a1 + 40) &= 0xFBu;
  return 1;
}
// 806B540: using guessed type int (*obstack_alloc_failed_handler)(void);

//----- (0805FB45) --------------------------------------------------------
signed int __cdecl sub_805FB45(int a1, signed int a2, signed int a3, int a4, int a5)
{
  *(_DWORD *)(a1 + 28) = a4;
  *(_DWORD *)(a1 + 32) = a5;
  *(_BYTE *)(a1 + 40) &= 0xFEu;
  return sub_805FA66(a1, a2, a3);
}

//----- (0805FBCE) --------------------------------------------------------
int __cdecl sub_805FBCE(int a1, int a2)
{
  int result; // eax
  _DWORD *v3; // [esp+14h] [ebp-24h]
  unsigned int v4; // [esp+18h] [ebp-20h]
  int v5; // [esp+1Ch] [ebp-1Ch]
  unsigned int n; // [esp+20h] [ebp-18h]
  unsigned int v7; // [esp+24h] [ebp-14h]
  unsigned int v8; // [esp+28h] [ebp-10h]
  void *dest; // [esp+2Ch] [ebp-Ch]

  v5 = *(_DWORD *)(a1 + 4);
  v3 = 0;
  n = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 8);
  v7 = n + a2;
  v8 = *(_DWORD *)(a1 + 24) + n + a2;
  v4 = (n >> 3) + v8 + 100;
  if ( v4 < v8 )
    v4 = *(_DWORD *)(a1 + 24) + n + a2;
  if ( *(_DWORD *)a1 > v4 )
    v4 = *(_DWORD *)a1;
  if ( n <= v7 && v7 <= v8 )
    v3 = (_DWORD *)sub_805F9EA(a1, v4);
  if ( !v3 )
    obstack_alloc_failed_handler();
  *(_DWORD *)(a1 + 4) = v3;
  v3[1] = v5;
  *(_DWORD *)(a1 + 16) = (char *)v3 + v4;
  *v3 = *(_DWORD *)(a1 + 16);
  dest = (void *)(((unsigned int)v3 + *(_DWORD *)(a1 + 24) + 8) & ~*(_DWORD *)(a1 + 24));
  memcpy(dest, *(const void **)(a1 + 8), n);
  if ( !(*(_BYTE *)(a1 + 40) & 2) && *(_DWORD *)(a1 + 8) == ((*(_DWORD *)(a1 + 24) + v5 + 8) & ~*(_DWORD *)(a1 + 24)) )
  {
    v3[1] = *(_DWORD *)(v5 + 4);
    sub_805FA28(a1, v5);
  }
  *(_DWORD *)(a1 + 8) = dest;
  *(_DWORD *)(a1 + 12) = n + *(_DWORD *)(a1 + 8);
  result = a1;
  *(_BYTE *)(a1 + 40) &= 0xFDu;
  return result;
}
// 806B540: using guessed type int (*obstack_alloc_failed_handler)(void);

//----- (0805FD98) --------------------------------------------------------
int __cdecl sub_805FD98(int a1, unsigned int a2)
{
  int result; // eax
  int *v3; // ST1C_4
  int *v4; // [esp+18h] [ebp-10h]

  result = *(_DWORD *)(a1 + 4);
  v4 = *(int **)(a1 + 4);
  while ( v4 )
  {
    if ( (unsigned int)v4 < a2 )
    {
      result = *v4;
      if ( *v4 >= a2 )
        break;
    }
    v3 = (int *)v4[1];
    sub_805FA28(a1, (int)v4);
    v4 = v3;
    result = a1;
    *(_BYTE *)(a1 + 40) |= 2u;
  }
  if ( v4 )
  {
    *(_DWORD *)(a1 + 12) = a2;
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 16) = *v4;
    result = a1;
    *(_DWORD *)(a1 + 4) = v4;
  }
  else if ( a2 )
  {
    abort();
  }
  return result;
}

//----- (0805FFE0) --------------------------------------------------------
int __cdecl sub_805FFE0(int a1, char a2)
{
  return __ROR4__(a1, a2);
}

//----- (080600CB) --------------------------------------------------------
int __cdecl sub_80600CB(signed int a1)
{
  void *v1; // eax

  if ( a1 > 90 )
  {
    if ( (unsigned int)(a1 - 97) <= 0x19 )
    {
LABEL_7:
      dword_806B234 = (int)&loc_8060127;
      sub_8061D73();
      return 0;
    }
  }
  else
  {
    v1 = &loc_80600F4;
    if ( a1 >= 65 )
      v1 = &loc_8060106;
    dword_806B310 = (int)v1;
    if ( (unsigned int)(sub_8061877() - 48) <= 9 )
      goto LABEL_7;
  }
  return 0;
}
// 8061877: using guessed type int sub_8061877(void);
// 8061D73: using guessed type int sub_8061D73(void);
// 806B234: using guessed type int dword_806B234;
// 806B310: using guessed type int dword_806B310;

//----- (08060129) --------------------------------------------------------
_BOOL4 __cdecl sub_8060129(signed int a1)
{
  return a1 >= 65 && (a1 <= 90 || (unsigned int)(a1 - 97) <= 0x19);
}

//----- (080601AD) --------------------------------------------------------
_BOOL4 __cdecl sub_80601AD(int a1)
{
  return (unsigned int)(a1 - 48) <= 9;
}

//----- (0806029A) --------------------------------------------------------
signed int __usercall sub_806029A@<eax>(int a1@<edx>, int a2@<ecx>, signed int a3)
{
  void *v3; // eax

  if ( a3 < 9 )
    return 0;
  if ( a3 > 13 )
  {
    v3 = &loc_80602C8;
    if ( a3 != 32 )
      v3 = &loc_80602CF;
    dword_806B270 = (int)v3;
    sub_8061C11(a2, a1);
  }
  return 1;
}
// 8061C11: using guessed type int __fastcall sub_8061C11(_DWORD, _DWORD);
// 806B270: using guessed type int dword_806B270;

//----- (0806032C) --------------------------------------------------------
int __cdecl sub_806032C(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 65) > 0x19 )
    result = a1;
  else
    result = a1 + 32;
  return result;
}

//----- (08060362) --------------------------------------------------------
int __cdecl sub_8060362(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // esi
  unsigned __int8 *v3; // ebx
  unsigned __int8 v5; // [esp+1Eh] [ebp-Ah]
  unsigned __int8 v6; // [esp+1Fh] [ebp-9h]

  v2 = a1;
  v3 = a2;
  if ( a1 == a2 )
    return 0;
  do
  {
    v5 = sub_806032C(*v2);
    v6 = sub_806032C(*v3);
    if ( !v5 )
      break;
    ++v2;
    ++v3;
  }
  while ( v5 == v6 );
  return v5 - v6;
}

//----- (080603C7) --------------------------------------------------------
int __cdecl sub_80603C7(FILE *fp)
{
  bool v1; // ST1E_1
  bool v3; // [esp+1Dh] [ebp-Bh]
  bool v4; // [esp+1Fh] [ebp-9h]

  v3 = __fpending(fp) != 0;
  v1 = ferror_unlocked(fp) != 0;
  v4 = sub_805F563(fp) != 0;
  if ( !v1 && (!v4 || !v3 && *__errno_location() == 9) )
    return 0;
  if ( v4 != 1 )
    *__errno_location() = 0;
  return -1;
}

//----- (08060448) --------------------------------------------------------
_DWORD *__userpurge sub_8060448@<eax>(_DWORD *a1, double a2)
{
  __int16 v2; // ax
  __int16 v4; // [esp+14h] [ebp-24h]
  __int16 v5; // [esp+16h] [ebp-22h]
  double v6; // [esp+18h] [ebp-20h]
  int v7; // [esp+20h] [ebp-18h]
  int v8; // [esp+24h] [ebp-14h]
  double v9; // [esp+28h] [ebp-10h]

  v6 = a2;
  if ( a2 <= -2147483648.0 )
  {
    sub_8061014(a1, 2147483648, 0);
  }
  else
  {
    if ( 2147483648.0 <= v6 )
    {
      sub_8061014(a1, 0x7FFFFFFF, 999999999);
      dword_806B370 = (int)&loc_806059C;
      sub_8061638();
    }
    LOBYTE(v2) = v5;
    HIBYTE(v2) = 12;
    v4 = v2;
    v7 = (signed int)v6;
    v9 = (v6 - (long double)v7) * 1000000000.0;
    v8 = (signed int)v9;
    v8 += v9 > (long double)v8;
    v7 += v8 / 1000000000;
    v8 %= 1000000000;
    if ( v8 < 0 )
    {
      --v7;
      v8 += 1000000000;
    }
    sub_8061014(a1, v7, v8);
  }
  return a1;
}
// 8061638: using guessed type int sub_8061638(void);
// 806B370: using guessed type int dword_806B370;

//----- (080605A3) --------------------------------------------------------
int __cdecl sub_80605A3(int fd, int a2)
{
  int v2; // ST18_4
  int v3; // ST1C_4

  if ( fd >= 0 && fd <= 2 )
  {
    v2 = sub_80605F4(fd, a2);
    v3 = *__errno_location();
    close(fd);
    *__errno_location() = v3;
    fd = v2;
  }
  return fd;
}

//----- (080605F4) --------------------------------------------------------
int __cdecl sub_80605F4(int fd, int a2)
{
  int v2; // eax

  if ( a2 & 0x80000 )
    v2 = 1030;
  else
    v2 = 0;
  return sub_805F63F(fd, v2, 3);
}

//----- (0806062B) --------------------------------------------------------
FILE *__cdecl sub_806062B(int a1, char *modes)
{
  FILE *v2; // eax
  bool v3; // zf
  void *v4; // eax
  int v5; // edx
  int v6; // ecx
  void *v7; // eax
  FILE *v8; // eax
  int v9; // edx
  int v10; // ecx
  void *v11; // eax
  int v13; // [esp+0h] [ebp-38h]
  FILE *stream; // [esp+1Ch] [ebp-1Ch]
  int v15; // [esp+20h] [ebp-18h]
  int fd; // [esp+24h] [ebp-14h]
  int v17; // [esp+28h] [ebp-10h]
  int v18; // [esp+2Ch] [ebp-Ch]

  v2 = (FILE *)fopen64(a1, modes);
  stream = v2;
  v3 = v2 == 0;
  v4 = &loc_8060665;
  if ( v3 )
    v4 = &loc_8060758;
  dword_806B2C0 = (int)v4;
  sub_8061A43();
  v15 = fileno(stream);
  if ( v15 < 0 || v15 > 2 )
    return stream;
  fd = sub_806111D(v15);
  if ( fd < 0 )
  {
    v17 = *__errno_location();
    sub_805F563(stream);
    *__errno_location() = v17;
    dword_806B2E8 = (int)&locret_806075B;
    sub_8061957();
  }
  v3 = sub_805F563(stream) == 0;
  v7 = &loc_80606FE;
  if ( !v3 )
    v7 = &loc_8060732;
  dword_806B338 = (int)v7;
  sub_8061791(v6, v5);
  v8 = fdopen(fd, modes);
  stream = v8;
  v3 = v8 == 0;
  v11 = &loc_8060732;
  if ( !v3 )
    v11 = &loc_8060758;
  dword_806B324 = (int)v11;
  sub_8061801(v10, v9, v13);
  v18 = *__errno_location();
  close(fd);
  *__errno_location() = v18;
  return 0;
}
// 806062B: could not find valid save-restore pair for ebx
// 80499F0: using guessed type int __cdecl fopen64(_DWORD, _DWORD);
// 8061791: using guessed type int __fastcall sub_8061791(_DWORD, _DWORD);
// 8061957: using guessed type int sub_8061957(void);
// 8061A43: using guessed type int sub_8061A43(void);
// 806B2C0: using guessed type int dword_806B2C0;
// 806B2E8: using guessed type int dword_806B2E8;
// 806B324: using guessed type int dword_806B324;
// 806B338: using guessed type int dword_806B338;

//----- (0806075D) --------------------------------------------------------
void *sub_806075D()
{
  void *v0; // eax
  FILE *v1; // eax
  bool v2; // zf
  void *v3; // eax
  void *ptr; // [esp+14h] [ebp-B4h]
  void *v6; // [esp+18h] [ebp-B0h]
  char *s; // [esp+1Ch] [ebp-ACh]
  char *v8; // [esp+28h] [ebp-A0h]
  size_t n; // [esp+2Ch] [ebp-9Ch]
  size_t v10; // [esp+30h] [ebp-98h]
  _BOOL4 v11; // [esp+34h] [ebp-94h]
  void *dest; // [esp+38h] [ebp-90h]
  int fd; // [esp+3Ch] [ebp-8Ch]
  FILE *stream; // [esp+40h] [ebp-88h]
  unsigned int v15; // [esp+BCh] [ebp-Ch]

  v15 = __readgsdword(0x14u);
  v6 = (void *)dword_806C515;
  if ( !dword_806C515 )
  {
    ptr = 0;
    v8 = "charset.alias";
    s = getenv("CHARSETALIASDIR");
    if ( !s || !*s )
    {
      ptr = 0;
      s = "/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib";
    }
    n = strlen(s);
    v10 = strlen(v8);
    v0 = &loc_8060824;
    if ( !n )
      v0 = &loc_8060843;
    dword_806B234 = (int)v0;
    sub_8061D73();
    v11 = s[n - 1] != 47;
    dest = malloc(n + v11 + v10 + 1);
    if ( dest )
    {
      memcpy(dest, s, n);
      if ( v11 )
        *((_BYTE *)dest + n) = 47;
      memcpy((char *)dest + n + v11, v8, v10 + 1);
    }
    free(ptr);
    if ( dest )
    {
      fd = open64(dest, 0x20000);
      if ( fd < 0 )
      {
        v6 = &unk_806531F;
        dword_806B384 = (int)&loc_8060CB3;
        sub_80615BE();
      }
      v1 = fdopen(fd, "r");
      stream = v1;
      v2 = v1 == 0;
      v3 = &loc_8060999;
      if ( !v2 )
        v3 = &loc_80609B6;
      dword_806B384 = (int)v3;
      sub_80615BE();
      close(fd);
      v6 = &unk_806531F;
      free(dest);
    }
    else
    {
      v6 = &unk_806531F;
    }
    dword_806C515 = (int)v6;
  }
  return v6;
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 80615BE: using guessed type int sub_80615BE(void);
// 8061D73: using guessed type int sub_8061D73(void);
// 806B234: using guessed type int dword_806B234;
// 806B384: using guessed type int dword_806B384;
// 806C515: using guessed type int dword_806C515;

//----- (08060CEC) --------------------------------------------------------
const char *sub_8060CEC()
{
  bool v0; // zf
  int v1; // edx
  int v2; // ecx
  void *v3; // eax
  void *v4; // eax
  char *v5; // ST24_4
  void *v6; // eax
  char *s1; // [esp+18h] [ebp-10h]
  char *s2; // [esp+1Ch] [ebp-Ch]

  v0 = nl_langinfo(14) == 0;
  v3 = &loc_8060D20;
  if ( !v0 )
    v3 = &loc_8060D27;
  dword_806B2FC = (int)v3;
  sub_80618E9(v2, v1);
  s1 = (char *)&unk_806531F;
  for ( s2 = (char *)sub_806075D(); *s2; s2 = &v5[strlen(v5) + 1] )
  {
    v0 = strcmp((const char *)&unk_806531F, s2) == 0;
    v4 = &loc_8060D63;
    if ( v0 )
      v4 = &loc_8060D7A;
    dword_806B20C = (int)v4;
    sub_8061E55();
    if ( *s2 == 42 && !s2[1] )
    {
      s1 = &s2[strlen(s2) + 1];
      break;
    }
    v5 = &s2[strlen(s2) + 1];
  }
  v6 = &loc_8060DE5;
  if ( *s1 )
    v6 = &loc_8060DEC;
  dword_806B2C0 = (int)v6;
  sub_8061A43();
  return "ASCII";
}
// 8060CEC: could not find valid save-restore pair for ebx
// 80618E9: using guessed type int __fastcall sub_80618E9(_DWORD, _DWORD);
// 8061A43: using guessed type int sub_8061A43(void);
// 8061E55: using guessed type int sub_8061E55(void);
// 806B20C: using guessed type int dword_806B20C;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B2FC: using guessed type int dword_806B2FC;

//----- (08060DF1) --------------------------------------------------------
int __cdecl sub_8060DF1(char *s, int a2, char *s2, int a4)
{
  int v5; // edx
  int v6; // ecx
  bool v7; // zf
  void *v8; // eax
  int v9; // [esp+14h] [ebp-14h]
  size_t v10; // [esp+18h] [ebp-10h]
  size_t v11; // [esp+1Ch] [ebp-Ch]

  do
  {
    *__errno_location() = 0;
    v9 = strcoll(s, s2);
    if ( !v9 )
    {
      v7 = *__errno_location() == 0;
      v8 = &loc_8060EB3;
      if ( v7 )
        v8 = &loc_8060ECF;
      dword_806B2D4 = (int)v8;
      sub_80619CB();
    }
    dword_806B220 = (int)&loc_8060ED4;
    sub_8061DE3(v6, v5);
    v10 = strlen(s) + 1;
    v11 = strlen(s2) + 1;
    s += v10;
    s2 += v11;
    a2 -= v10;
    a4 -= v11;
    if ( !a2 )
    {
      dword_806B310 = (int)&locret_8060EDF;
      sub_8061877();
    }
  }
  while ( a4 );
  return 1;
}
// 8061877: using guessed type int sub_8061877(void);
// 80619CB: using guessed type int sub_80619CB(void);
// 8061DE3: using guessed type int __fastcall sub_8061DE3(_DWORD, _DWORD);
// 806B220: using guessed type int dword_806B220;
// 806B2D4: using guessed type int dword_806B2D4;
// 806B310: using guessed type int dword_806B310;

//----- (08060EE1) --------------------------------------------------------
int __usercall sub_8060EE1@<eax>(int a1@<edx>, int a2@<ecx>, void *s1, size_t n, void *s2, int a6)
{
  void *v6; // eax
  char v7; // ST22_1
  char v8; // ST23_1
  int v10; // [esp+1Ch] [ebp-Ch]

  v6 = &loc_8060F08;
  if ( n != a6 )
    v6 = &loc_8060F39;
  dword_806B338 = (int)v6;
  sub_8061791(a2, a1);
  if ( !memcmp(s1, s2, n) )
  {
    *__errno_location() = 0;
    v10 = 0;
  }
  else
  {
    v7 = *((_BYTE *)s1 + n);
    v8 = *((_BYTE *)s2 + a6);
    *((_BYTE *)s1 + n) = 0;
    *((_BYTE *)s2 + a6) = 0;
    v10 = sub_8060DF1((char *)s1, n + 1, (char *)s2, a6 + 1);
    *((_BYTE *)s1 + n) = v7;
    *((_BYTE *)s2 + a6) = v8;
  }
  return v10;
}
// 8061791: using guessed type int __fastcall sub_8061791(_DWORD, _DWORD);
// 806B338: using guessed type int dword_806B338;

//----- (08060FB5) --------------------------------------------------------
int __cdecl sub_8060FB5(void *s1, size_t n, void *s2, int a4)
{
  if ( n != a4 || memcmp(s1, s2, n) )
    return sub_8060DF1((char *)s1, n, (char *)s2, a4);
  *__errno_location() = 0;
  return 0;
}

//----- (08061014) --------------------------------------------------------
_DWORD *__userpurge sub_8061014@<eax>(_DWORD *a1, int a2, int a3)
{
  *a1 = a2;
  a1[1] = a3;
  return a1;
}

//----- (0806111D) --------------------------------------------------------
int __cdecl sub_806111D(int fd)
{
  return sub_805F63F(fd, 0, 3);
}

//----- (08061142) --------------------------------------------------------
__int64 __cdecl sub_8061142(unsigned int a1, unsigned int a2, int a3, int a4)
{
  void *v4; // eax
  unsigned int v5; // edx
  unsigned int v6; // ecx
  unsigned int v7; // esi
  __int64 result; // rax

  v4 = &loc_806117E;
  if ( a4 )
    v4 = &loc_80611AA;
  dword_806B324 = (int)v4;
  sub_8061801(a3, a2, a3);
  if ( v6 > a2 )
    return (unsigned int)(__PAIR__(v5, a1) / v6);
  v7 = v6;
  if ( !v6 )
    v7 = 1 / 0u;
  LODWORD(result) = __PAIR__(a2 % v7, a1) / v7;
  HIDWORD(result) = a2 / v7;
  return result;
}
// 806B324: using guessed type int dword_806B324;

//----- (08061294) --------------------------------------------------------
unsigned __int64 __cdecl sub_8061294(unsigned __int64 a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // edx
  unsigned __int64 result; // rax
  int v5; // ebp
  void *v6; // eax
  unsigned int v7; // eax
  unsigned int v8; // ecx
  void *v9; // eax
  int v10; // ecx
  unsigned __int64 v11; // rtt
  unsigned __int64 v12; // [esp+8h] [ebp-18h]

  v12 = a1;
  if ( a3 )
  {
    if ( a3 > HIDWORD(a1) )
    {
      result = a1;
    }
    else
    {
      _BitScanReverse((unsigned int *)&v5, a3);
      v6 = &loc_8061305;
      if ( v5 ^ 0x1F )
        v6 = &loc_806137A;
      dword_806B2AC = (int)v6;
      v7 = sub_8061AB5(a1, a3);
      if ( a2 <= (unsigned int)a1 || v7 < HIDWORD(a1) )
        v12 = __PAIR__(HIDWORD(a1), v8) - __PAIR__(v7, a2);
      result = v12;
    }
  }
  else
  {
    if ( a2 <= HIDWORD(a1) )
    {
      v9 = &loc_8061350;
      if ( a2 )
        v9 = &loc_806135B;
      dword_806B25C = (int)v9;
      sub_8061C89(a1, a3);
      LODWORD(v11) = v10;
      HIDWORD(v11) = HIDWORD(a1) % (1 / a2);
      v3 = v11 % (1 / a2);
    }
    else
    {
      v3 = a1 % a2;
    }
    result = v3;
  }
  return result;
}
// 8061AB5: using guessed type int __fastcall sub_8061AB5(_DWORD, _DWORD);
// 8061C89: using guessed type int __fastcall sub_8061C89(_DWORD, _DWORD);
// 806B25C: using guessed type int dword_806B25C;
// 806B2AC: using guessed type int dword_806B2AC;

//----- (080614BE) --------------------------------------------------------
int __cdecl sub_80614BE(int a1)
{
  return __cxa_atexit(a1, 0, dword_806B39C);
}
// 8049AC0: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 806B39C: using guessed type int dword_806B39C;

//----- (080614ED) --------------------------------------------------------
int __cdecl sub_80614ED(int a1, int a2)
{
  return __xstat64(3, a1, a2);
}
// 8049EB0: using guessed type int __cdecl __xstat64(_DWORD, _DWORD, _DWORD);

//----- (0806151C) --------------------------------------------------------
int __cdecl sub_806151C(int a1, int a2)
{
  return __fxstat64(3, a1, a2);
}
// 8049A30: using guessed type int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD);

//----- (0806157D) --------------------------------------------------------
#error "80615B6: positive sp value has been found (funcsize=18)"

//----- (080615BE) --------------------------------------------------------
#error "80615C4: positive sp value has been found (funcsize=0)"

//----- (08061638) --------------------------------------------------------
#error "806163E: positive sp value has been found (funcsize=0)"

//----- (080616AA) --------------------------------------------------------
#error "80616B0: positive sp value has been found (funcsize=0)"

//----- (08061791) --------------------------------------------------------
#error "8061797: positive sp value has been found (funcsize=0)"

//----- (08061801) --------------------------------------------------------
#error "8061807: positive sp value has been found (funcsize=0)"

//----- (08061877) --------------------------------------------------------
#error "806187D: positive sp value has been found (funcsize=0)"

//----- (080618E9) --------------------------------------------------------
#error "80618EF: positive sp value has been found (funcsize=0)"

//----- (08061957) --------------------------------------------------------
#error "806195D: positive sp value has been found (funcsize=0)"

//----- (080619CB) --------------------------------------------------------
#error "80619D1: positive sp value has been found (funcsize=0)"

//----- (08061A43) --------------------------------------------------------
#error "8061A49: positive sp value has been found (funcsize=0)"

//----- (08061AB5) --------------------------------------------------------
#error "8061ABB: positive sp value has been found (funcsize=0)"

//----- (08061B2F) --------------------------------------------------------
#error "8061B35: positive sp value has been found (funcsize=0)"

//----- (08061B9D) --------------------------------------------------------
#error "8061BA3: positive sp value has been found (funcsize=0)"

//----- (08061C11) --------------------------------------------------------
#error "8061C17: positive sp value has been found (funcsize=0)"

//----- (08061C89) --------------------------------------------------------
#error "8061C8F: positive sp value has been found (funcsize=0)"

//----- (08061CFB) --------------------------------------------------------
#error "8061D01: positive sp value has been found (funcsize=0)"

//----- (08061D73) --------------------------------------------------------
#error "8061D79: positive sp value has been found (funcsize=0)"

//----- (08061DE3) --------------------------------------------------------
#error "8061DE9: positive sp value has been found (funcsize=0)"

//----- (08061E55) --------------------------------------------------------
#error "8061E5B: positive sp value has been found (funcsize=0)"

//----- (08061E70) --------------------------------------------------------
int (**sub_8061E70())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_806AEAC;
  v1 = &off_806AEB0 - off_806AEAC;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_806AEAC[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 806AEAC: using guessed type int (*off_806AEAC[2])();
// 806AEB0: using guessed type int (*off_806AEB0)();

//----- (08061ED4) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 36 decompilation failure(s) on 383 function(s)"
