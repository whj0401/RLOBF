/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8049750();
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// int raise(int sig);
// int dup2(int fd, int fd2);
// int strcmp(const char *s1, const char *s2);
// int putc_unlocked(int c, FILE *stream);
// ssize_t read(int fd, void *buf, size_t nbytes);
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void _exit(int status);
// int __cdecl wcwidth(_DWORD); weak
// void *memmove(void *dest, const void *src, size_t n);
// void free(void *ptr);
// uintmax_t strtoumax(const char *nptr, char **endptr, int base);
// void *memcpy(void *dest, const void *src, size_t n);
// int mbsinit(const mbstate_t *ps);
// int ferror(FILE *stream);
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// int fclose(FILE *stream);
// int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
// int getc_unlocked(FILE *stream);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// __sighandler_t signal(int sig, __sighandler_t handler);
// int __cdecl __sched_cpucount(_DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// double __cdecl strtold(_DWORD, _DWORD); weak
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// int fputc_unlocked(int c, FILE *stream);
// int __cdecl getrlimit64(_DWORD, _DWORD); weak
// int __cdecl stpcpy(_DWORD, _DWORD); weak
// int execlp(const char *file, const char *arg, ...);
// int sysconf(int name);
// __uid_t getuid(void);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// int unlink(const char *name);
// int sigismember(const sigset_t *set, int signo);
// int iswcntrl(wint_t wc);
// char *textdomain(const char *domainname);
// int iswprint(wint_t wc);
// int __cdecl fopen64(_DWORD, _DWORD); weak
// int ferror_unlocked(FILE *stream);
// int __cdecl mkostemp64(_DWORD, _DWORD); weak
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD); weak
// size_t __ctype_get_mb_cur_max(void);
// __pid_t waitpid(__pid_t pid, int *stat_loc, int options);
// int pthread_sigmask(int how, const __sigset_t *newmask, __sigset_t *oldmask);
// char *strcpy(char *dest, const char *src);
// size_t __fpending(FILE *fp);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// __pid_t getpid(void);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// int pthread_cond_signal(pthread_cond_t *cond);
// void error(int status, int errnum, const char *format, ...);
// size_t fread_unlocked(void *ptr, size_t size, size_t n, FILE *stream);
// int strcoll(const char *s1, const char *s2);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int sysinfo(struct sysinfo *info);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// char *strchr(const char *s, int c);
// size_t strlen(const char *s);
// int fprintf(FILE *stream, const char *format, ...);
// ssize_t write(int fd, const void *buf, size_t n);
// int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *cond_attr);
// int __cdecl open64(_DWORD, _DWORD); weak
// int fcntl(int fd, int cmd, ...);
// int sigaddset(sigset_t *set, int signo);
// size_t strxfrm(char *dest, const char *src, size_t n);
// int setvbuf(FILE *stream, char *buf, int modes, size_t n);
// __gid_t getgid(void);
// void *memset(void *s, int c, size_t n);
// int *__errno_location(void);
// int fileno(FILE *stream);
// int fgetc(FILE *stream);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// __pid_t fork(void);
// int sigemptyset(sigset_t *set);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// int toupper(int c);
// void clearerr_unlocked(FILE *stream);
// char *strrchr(const char *s, int c);
// int pthread_join(pthread_t th, void **thread_return);
// struct lconv *localeconv(void);
// __pid_t getppid(void);
// int __cdecl explicit_bzero(_DWORD, _DWORD); weak
// int pipe2(void); weak
// int __cdecl euidaccess(_DWORD, _DWORD); weak
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int nanosleep(const struct timespec *requested_time, struct timespec *remaining);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// char *bindtextdomain(const char *domainname, const char *dirname);
// int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl sched_getaffinity(_DWORD, _DWORD, _DWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// int feof_unlocked(FILE *stream);
// void abort(void);
// int __cdecl __xstat64(_DWORD, _DWORD, _DWORD); weak
// int strtol(const char *nptr, char **endptr, int base);
// char *ngettext(const char *msgid1, const char *msgid2, unsigned int n);
// int close(int fd);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// void *calloc(size_t nmemb, size_t size);
// int putchar_unlocked(int c);
// int _gmon_start__(void); weak
void sub_8049F73();
void sub_8049F90();
int sub_8049FA0();
int sub_804A010();
int sub_804A030();
void sub_804A08F();
void sub_804A0AA();
int sub_804A0BA();
void sub_804A19C();
void sub_804A1B7();
signed int sub_804A1C7();
void sub_804A2A9();
void sub_804A2C4();
int sub_804A2D4();
// int __usercall sub_804A386@<eax>(void (__cdecl *a1)(signed int)@<eax>);
void sub_804A3D2();
void sub_804A3ED();
int sub_804A3FD();
void sub_804A4DF();
void sub_804A4FA();
int sub_804A50A();
int sub_804A594();
void sub_804A608();
void sub_804A623();
int sub_804A633();
void sub_804A715();
void sub_804A730();
int sub_804A740();
void sub_804A822();
void sub_804A83D();
int sub_804A84D();
void sub_804A92F();
void sub_804A94A();
int sub_804A95A();
// int __usercall sub_804A9C1@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
void sub_804AA58();
void sub_804AA73();
int sub_804AA83();
void sub_804AB65();
void sub_804AB80();
int sub_804AB90();
void sub_804AC8E();
void sub_804ACA9();
int sub_804ACB9();
void sub_804ADB7();
void sub_804ADD2();
int sub_804ADE2();
int nullsub_4(void); // weak
int sub_804AE59();
void sub_804AEF9();
void sub_804AF14();
int sub_804AF24();
void sub_804B006();
void sub_804B021();
int sub_804B031();
int sub_804B05D();
// int __usercall sub_804B0FC@<eax>(void (__cdecl *a1)(int *)@<eax>);
void sub_804B148();
void sub_804B163();
int sub_804B173();
int nullsub_5(void); // weak
// int __usercall sub_804B1DA@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
int sub_804B216();
// int __usercall sub_804B257@<eax>(void (__cdecl *a1)(int *)@<eax>);
void sub_804B2A3();
void sub_804B2BE();
int sub_804B2CE();
// int __usercall sub_804B335@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
void sub_804B3DE();
void sub_804B3F9();
int sub_804B409();
// int __usercall sub_804B470@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
void sub_804B507();
void sub_804B522();
int sub_804B532();
void sub_804B614();
void sub_804B62F();
int sub_804B63F();
int __cdecl sub_804B708(int a1);
int __cdecl sub_804B734(unsigned __int8 a1);
int __cdecl sub_804B746(unsigned __int8 a1);
char *__cdecl sub_804B785(unsigned __int64 a1);
int sub_804B7CB();
int sub_804B7F6();
int __cdecl sub_804B821(char *s1); // idb
void __cdecl __noreturn sub_804B9A7(int a1, const char *a2);
void __cdecl __noreturn sub_804BA86(int a1, int a2);
void __cdecl __noreturn sub_804BB01(int status); // idb
int __cdecl sub_804BDBD(int a1);
int __cdecl sub_804BDF2(unsigned __int8 *a1);
int __cdecl sub_804BE22(int a1, unsigned int a2);
bool __cdecl sub_804BE40(int a1, int a2);
int __cdecl sub_804BE65(__pid_t pid); // idb
int __cdecl sub_804BFA7(int a1);
signed int __cdecl sub_804C034(int a1);
int __cdecl sub_804C08E(__pid_t pid); // idb
int __fastcall sub_804C0B0(int a1, int a2);
int sub_804C101();
int sub_804C11A();
int sub_804C139();
int sub_804C171();
int *__cdecl sub_804C1AB(int *a1, char a2);
FILE *__cdecl sub_804C3B1(char *s1, char *modes);
FILE *__cdecl sub_804C51F(char *s1, char *modes);
void __cdecl sub_804C560(FILE *stream, int a2);
// int __usercall sub_804C624@<eax>(int a1@<edx>, int a2@<ecx>, int fd, int fd2);
__pid_t __cdecl sub_804C66A(int pipedes[2], int a2);
int __cdecl sub_804C816(FILE **a1, char a2);
int __cdecl sub_804C97B(FILE **a1);
FILE *__cdecl sub_804C996(int a1);
int __cdecl sub_804CB6E(int a1);
// void __usercall sub_804CBC6(int a1@<edx>, int a2@<ecx>, char *name);
int compar(const void *, const void *); // idb
void sub_804CD3D();
// unsigned int __usercall sub_804CF47@<eax>(int edx0@<edx>, int ecx0@<ecx>, int a1, char a2, char *a3);
// unsigned __int64 __usercall sub_804D1A3@<edx:eax>(int edx0@<edx>, int ecx0@<ecx>, int a1, int a2, char *nptr);
int __cdecl sub_804D419(int, int, char *nptr); // idb
int sub_804D4D7();
int __cdecl sub_804D6A6(int a1, unsigned int a2, int a3, unsigned int a4, int a5);
void __cdecl __noreturn sub_804D8B4(int, int, size_t size); // idb
int sub_804D912(); // weak
int __cdecl sub_804D94F(_DWORD *a1);
int __cdecl sub_804D96A(char **a1, int a2);
char *__cdecl sub_804DAF6(char **a1, int a2);
int __cdecl sub_804DCA6(int a1);
int __cdecl sub_804E0EA(char **a1);
int __cdecl sub_804E1E1(_BYTE *a1);
int __cdecl sub_804E25D(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_804E331(unsigned __int8 *a1, int a2);
int __cdecl sub_804E3D6(int a1, int a2);
signed int __cdecl sub_804E45A(int a1, int a2);
int __cdecl sub_804E5A9(unsigned __int8 *a1, unsigned __int8 **a2);
void __cdecl __noreturn sub_804E6ED(int a1);
void __cdecl __noreturn sub_804E798(size_t, int); // idb
size_t __cdecl sub_804E7EB(char *dest, char *src, size_t n);
void __cdecl __noreturn sub_804E8C3(int, size_t, int, size_t); // idb
int sub_804EF04(); // weak
int __cdecl sub_804EF0F(char *a1, unsigned int a2);
int __cdecl sub_804EF5F(int a1, int a2);
int __cdecl sub_804EFD9(_BYTE *a1);
int __cdecl sub_804F00E(int a1, int a2);
int __cdecl sub_804F284(int a1);
// int __usercall sub_804F309@<eax>(int edx0@<edx>, int a2@<ecx>, int a1);
int __cdecl sub_804F3DF(int a1, _BYTE *a2);
int __fastcall __noreturn sub_804F559(int a1, int a2, int *a3, char a4);
int sub_804FDBD(); // weak
int __cdecl sub_804FDC7(int a1, int a2);
int __cdecl sub_8050B61(int a1, int a2);
char *__cdecl sub_8050D4C(int a1, FILE *stream, int a3);
void __cdecl __noreturn sub_8050E87(char *a1, int a2);
unsigned int __cdecl sub_8051279(int a1, unsigned int a2, void **a3);
void __cdecl __noreturn sub_8051399(int a1, int a2, int a3);
void __cdecl __noreturn sub_8051D6A(int a1, int a2, int a3);
_DWORD *__cdecl sub_8051DFB(int a1, unsigned int a2, int a3);
_DWORD *__cdecl sub_8051F04(int a1, unsigned int a2, int a3, unsigned __int8 a4);
pthread_mutex_t *__cdecl sub_8052143(unsigned int a1, int a2, int a3);
int __cdecl sub_805225D(_DWORD *a1, pthread_mutex_t *a2, int a3, unsigned int a4, int a5, char a6);
_BOOL4 __cdecl sub_8052444(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80524A3(pthread_mutex_t *a1);
int __cdecl sub_80524B9(pthread_mutex_t *a1);
int __cdecl sub_8052500(int a1, int a2);
int __cdecl sub_805254E(int a1, int a2);
pthread_mutex_t *__cdecl sub_805259B(int a1);
char *__cdecl sub_8052604(int a1, FILE *stream, int a3);
int __cdecl sub_8052677(int, int, FILE *stream, int); // idb
int __cdecl sub_8052B19(int a1, int a2);
int __cdecl sub_8052C26(int a1, _DWORD *a2);
int __cdecl sub_8052C93(int a1);
void *start_routine(void *); // idb
int __cdecl sub_8052DAC(int, int, int, int, int, FILE *stream, int); // idb
int __cdecl sub_8052FB0(int, int, int, char *s1); // idb
unsigned int __cdecl sub_8053229(int a1, unsigned int a2);
void __cdecl sub_80532F5(int a1);
void __cdecl __noreturn sub_805335B(int, int, int, char *s1); // idb
int __cdecl sub_8053791(int a1, int a2, char *a3);
_DWORD *__cdecl sub_8053BF4(void *src);
unsigned int __cdecl sub_8053C5A(int a1, char *msgid);
unsigned int __cdecl sub_8053CA8(int a1);
unsigned int sub_8053CD9();
// int __usercall sub_8053DD0@<eax>(int a1@<edx>, int a2@<ecx>, char *nptr, int a4, char *msgid);
int __cdecl sub_8053EC1(int sig); // idb
// _BYTE *__usercall sub_8053EEC@<eax>(int a1@<edx>, int a2@<ecx>, _BYTE *a3, int a4, int a5);
void *__cdecl sub_8054092(void *s);
void __cdecl main(int argc, char **argv);
int sub_80558CB(); // weak
void __noreturn sub_805598A();
int __cdecl sub_805599E(char *s, int, int, size_t); // idb
void __cdecl __noreturn sub_8055ABC(char *a1, int a2, int a3);
int __cdecl sub_8055B3F(int, int, size_t n); // idb
int __cdecl sub_8055C6B(int a1, char *s, int a3, int a4, size_t n);
int sub_8055D80();
_DWORD *__cdecl sub_8055E79(_DWORD *a1);
_DWORD *__cdecl sub_8055EC5(_DWORD *a1, int a2);
_DWORD *__cdecl sub_8055ED2(int *a1, _DWORD *a2);
_DWORD *__cdecl sub_8055F3F(int *a1, _DWORD *a2);
// int *__usercall sub_8056207@<eax>(int a1@<edx>, int ecx0@<ecx>, void *src, size_t a2, int a3);
int *__cdecl sub_8056409(int *a1, unsigned int a2, int *a3);
int __cdecl sub_80570D3(int a1, int a2, int a3, int a4, int a5, int a6);
void __cdecl sub_8057124(FILE *stream, int a2);
// _BYTE *__usercall sub_805716C@<eax>(_BYTE *edx0@<edx>, int a2@<ecx>, _BYTE **a1);
int __cdecl sub_805723F(unsigned __int8 a1);
signed int __cdecl sub_80572C2(int a1, unsigned int a2, int a3, unsigned int a4);
int __cdecl sub_8057554(char *s1, char *s2); // idb
int __cdecl sub_805782D(int category); // idb
int __cdecl sub_805788B(int a1);
int __cdecl sub_8057896(int a1);
int __cdecl sub_80578A1(int a1);
unsigned int __cdecl sub_80578AC(int a1);
int __cdecl sub_8057AC1(int a1, int a2);
bool __cdecl sub_8057DE0(unsigned int a1);
int __cdecl sub_8057E37(unsigned int a1);
unsigned int __cdecl sub_8057EA8(int a1, unsigned int a2);
bool __cdecl sub_8057ED3(int a1, int a2);
signed int __cdecl sub_8057EE1(int a1);
// unsigned int __usercall sub_8057FB6@<eax>(int a1@<edx>, int a2@<ecx>, unsigned int a3, int a4);
int sub_805805C();
void *__cdecl sub_80583F8(int a1);
int __cdecl sub_8058433(int a1, _DWORD *a2);
int __cdecl sub_8058456(int a1, int a2, _DWORD *a3, char a4);
signed int __cdecl sub_8058617(int a1, int a2, char a3);
// signed int __usercall sub_8058813@<eax>(int a1@<edx>, int a2@<ecx>, int a3, unsigned int a4);
signed int __cdecl sub_8058A28(unsigned int *a1, int a2, _DWORD *a3);
int __cdecl sub_8058CB7(unsigned int *a1, int a2);
int __cdecl sub_8058D24(int a1, int a2);
_DWORD *__cdecl sub_8058F33(int a1, unsigned int a2);
int sub_8058FBD();
void __cdecl sub_8058FC7(void *ptr);
int __cdecl sub_8058FE7(int a1, int a2);
// int __usercall sub_8059070@<eax>(int a1@<edx>, int a2@<ecx>, int *a3);
unsigned int __cdecl sub_805911A(int a1, unsigned int a2, unsigned int a3, int (__cdecl *a4)(_DWORD, int));
int __cdecl sub_8059216(int a1, unsigned int a2, int (__cdecl *a3)(_DWORD, int));
int __cdecl sub_80592A6(int a1, int a2);
int __cdecl sub_8059380(unsigned int a1, int a2);
int __cdecl sub_80593DE(signed __int64 a1, int a2);
int __cdecl sub_8059491(char *a1, int a2, char a3);
int sub_80597BB();
signed int __cdecl sub_8059833(int a1);
unsigned int __cdecl sub_80598DA(char *nptr);
unsigned int __cdecl sub_80599EE(int a1);
long double sub_8059A6F();
long double sub_8059B31();
int __cdecl sub_8059BF8(int pipedes[2], int); // idb
int sub_8059EAB();
char *__cdecl sub_8059F22(char *s);
unsigned int __cdecl sub_805A09C(int a1, unsigned __int8 a2, char a3);
// int *__usercall sub_805A15B@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5);
void __cdecl __noreturn sub_805A1B5(int a1, int a2);
int __stdcall sub_805A1F4(int); // weak
void __cdecl __noreturn sub_805A250(char *msgid); // idb
int sub_805A35D(); // weak
int __cdecl sub_805A35F(int a1, unsigned int a2, char *a3, size_t a4, char *a5, int a6, int a7, char *a8, char *a9);
void *__cdecl sub_805B368(char *a1, size_t a2, _DWORD *a3, int *a4);
void *__cdecl sub_805B541(signed int a1, char *a2, size_t a3, int a4);
void *__cdecl sub_805B798(signed int a1, char *a2);
void *__cdecl sub_805B7C2(signed int a1, char *a2, size_t a3);
void __cdecl __noreturn sub_805B828(int a1, int a2);
void __cdecl __noreturn sub_805B866(int a1, int a2);
void __cdecl __noreturn sub_805B8A3(int a1);
void *__cdecl sub_805B8EE(char *a1, size_t a2, unsigned __int8 a3);
void *__cdecl sub_805B998(char *a1, unsigned __int8 a2);
void *__cdecl sub_805B9C1(char *a1);
void __cdecl __noreturn sub_805B9FE(int a1, int a2);
// void *__usercall sub_805BA9F@<eax>(int a1@<edx>, int a2@<ecx>, signed int a3, int a4, int a5, char *a6);
// void *__usercall sub_805BACF@<eax>(int a1@<edx>, int a2@<ecx>, signed int a3, int a4, int a5, char *a6, size_t a7);
void *__cdecl sub_805BBC9(signed int a1, char *a2, size_t a3);
void *__cdecl sub_805BC14(signed int a1, char *a2);
void *__cdecl sub_805BC36(char *a1);
void __cdecl __noreturn sub_805BC51(char *a1);
_DWORD *__cdecl sub_805BCBA(int a1, int a2);
unsigned int __cdecl sub_805BCEF(int a1, int a2, size_t nbytes);
char *__cdecl sub_805BEFC(int a1, size_t n);
void __cdecl __noreturn sub_805BFF8(int, void *ptr, size_t n); // idb
int sub_805C092(); // weak
int __cdecl sub_805C098(int, void *dest, size_t n); // idb
int __cdecl sub_805C1A7(int, void *ptr, size_t n); // idb
int __cdecl sub_805C204(void *ptr); // idb
int __cdecl sub_805C24A(int a1);
int __cdecl sub_805C261(int a1, __int16 a2);
unsigned int *__cdecl sub_805C292(unsigned int *a1, int *a2);
// _DWORD *__usercall sub_805C737@<eax>(int edx0@<edx>, int a2@<ecx>, _DWORD *a1);
signed int __cdecl sub_805CB58(_DWORD *a1);
_DWORD *__cdecl sub_805CD11(_DWORD *a1);
bool __cdecl sub_805CEA6(FILE *stream, int a2);
int __cdecl sub_805D182(int a1, int a2);
int __cdecl sub_805D1AB(_BYTE *a1, _BYTE *a2, char a3);
int __cdecl sub_805D376(char *a1, char *a2, int a3, int a4);
int __cdecl sub_805D902(char *a1, char *a2, int a3, int a4);
int __cdecl sub_805D92A(int fd); // idb
int __cdecl sub_805D974(FILE *stream, int, int, int, int, int); // idb
int __cdecl sub_805DF21(FILE *stream, int, int, int, int); // idb
int sub_805DF87(FILE *stream, int a2, int a3, int a4, ...);
void *__cdecl sub_805E027(unsigned int a1, unsigned int a2);
void *__cdecl sub_805E08A(void *ptr, int a2, int a3);
void *__cdecl sub_805E13A(size_t size);
void *__cdecl sub_805E14D(size_t size);
void *__cdecl sub_805E177(void *ptr, size_t size);
void *__cdecl sub_805E22B(size_t nmemb, size_t size);
void *__cdecl sub_805E268(void *src, size_t n);
void __noreturn sub_805E2B6();
void __cdecl __noreturn sub_805E2EF(int errnum);
void __cdecl __noreturn sub_805E420(void *s1, size_t n, void *s2, int); // idb
int sub_805E49F(); // weak
signed int __cdecl sub_805E4A4(double a1);
int __cdecl sub_805E544(unsigned int *a1, unsigned int a2);
int __cdecl sub_805E59D(unsigned int *a1, unsigned int a2, int a3);
int __cdecl sub_805E5D3(char *nptr, int, int base, int, char *s); // idb
void __cdecl sub_805EA77(int a1, int a2, int a3, int a4, int a5, int status);
void __cdecl __noreturn sub_805EB2D(int a1, int a2, char a3, int a4, int a5);
signed int __cdecl sub_805EB70(int a1, signed int a2);
int __cdecl sub_805EBFC(int a1, signed int a2, int a3);
// int __usercall sub_805EC32@<eax>(int a1@<edx>, int a2@<ecx>, char *nptr, int a4, int base, int a6, char *s);
int __cdecl sub_805F101(FILE *stream); // idb
int __cdecl sub_805F1F6(int fd, int cmd, char); // idb
int __cdecl sub_805F38E(FILE *stream); // idb
int __cdecl sub_805F3C7(FILE *fp); // idb
int __cdecl sub_805F407(FILE *stream, int, int, int); // idb
size_t __cdecl sub_805F50B(wchar_t *pwc, char *s, size_t n, mbstate_t *p);
int __cdecl sub_805F5AF(int a1, int a2);
// int __usercall sub_805F606@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4);
signed int __cdecl sub_805F65D(int a1, signed int a2, signed int a3);
signed int __cdecl sub_805F73C(int a1, signed int a2, signed int a3, int a4, int a5);
int __cdecl sub_805F7C5(int a1, int a2);
// int __usercall sub_805F9A4@<eax>(int a1@<edx>, int a2@<ecx>, int a3, unsigned int a4);
int __cdecl sub_805FC05(int a1, char a2);
// signed int __usercall sub_805FCF0@<eax>(int edx0@<edx>, int a2@<ecx>, signed int a1);
_BOOL4 __cdecl sub_805FD39(signed int a1);
_BOOL4 __cdecl sub_805FDD6(int a1);
_BOOL4 __cdecl sub_805FEAE(signed int a1);
int __cdecl sub_805FF12(int a1);
int __cdecl sub_805FF48(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_805FFAD(FILE *fp); // idb
// _DWORD *__userpurge sub_8060047@<eax>(_DWORD *a1, double a2);
int __cdecl sub_80601D4(int fd, int); // idb
int __cdecl sub_8060225(int fd, int); // idb
FILE *__cdecl sub_806025C(int a1, char *modes);
int __noreturn sub_8060332();
int sub_80608BC(); // weak
void __noreturn sub_80608C5();
int __cdecl sub_80609AD(char *s, int, char *s2, int); // idb
int __cdecl sub_8060AA0(void *s1, size_t n, void *s2, int); // idb
int __cdecl sub_8060B5B(void *s1, size_t n, void *s2, int); // idb
// _DWORD *__userpurge sub_8060BCF@<eax>(_DWORD *a1, int a2, int a3);
int __cdecl sub_8060CBB(int fd); // idb
signed __int64 __cdecl sub_8060CE0(unsigned __int64 a1, unsigned int a2, unsigned int a3);
char *__cdecl sub_8060E00(unsigned __int64 a1, __int64 a2);
int __cdecl sub_8060FEA(int a1);
int __cdecl sub_8061019(int a1, int a2);
int __cdecl sub_8061048(int a1, int a2);
int sub_80610EA(void); // weak
int sub_8061156(void); // weak
int __fastcall sub_80611C6(_DWORD, _DWORD); // weak
int sub_8061251(void); // weak
int __fastcall sub_80612C5(_DWORD, _DWORD); // weak
int __fastcall sub_8061339(_DWORD, _DWORD); // weak
int __cdecl sub_80613B1();
int __fastcall sub_8061429(_DWORD, _DWORD); // weak
int __cdecl sub_80614AE(_DWORD, _DWORD);
int sub_8061526(void); // weak
int __fastcall sub_806159C(_DWORD, _DWORD); // weak
int sub_8061616(void); // weak
int sub_8061686(void); // weak
int __fastcall sub_80616F6(_DWORD, _DWORD); // weak
int sub_806177B(void); // weak
int sub_80617ED(void); // weak
int sub_806185D(void); // weak
int sub_80618EC(void); // weak
int sub_806195A(void); // weak
int (**sub_8061970())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN locret_804ADF1; // weak
_UNKNOWN locret_804B64E; // weak
_UNKNOWN loc_804B72A; // weak
_UNKNOWN loc_804B732; // weak
_UNKNOWN loc_804BA02; // weak
_UNKNOWN loc_804BA5B; // weak
_UNKNOWN loc_804BAAC; // weak
_UNKNOWN loc_804BABA; // weak
_UNKNOWN loc_804BF10; // weak
_UNKNOWN loc_804BF38; // weak
_UNKNOWN loc_804BF9D; // weak
_UNKNOWN loc_804C009; // weak
_UNKNOWN loc_804C00E; // weak
_UNKNOWN loc_804C0CD; // weak
_UNKNOWN locret_804C0FF; // weak
_UNKNOWN loc_804C299; // weak
_UNKNOWN loc_804C2A3; // weak
_UNKNOWN loc_804C3DC; // weak
_UNKNOWN loc_804C40C; // weak
_UNKNOWN loc_804C41D; // weak
_UNKNOWN loc_804C46D; // weak
_UNKNOWN loc_804C593; // weak
_UNKNOWN loc_804C5B3; // weak
_UNKNOWN loc_804C64B; // weak
_UNKNOWN locret_804C668; // weak
_UNKNOWN loc_804C76A; // weak
_UNKNOWN loc_804C79C; // weak
_UNKNOWN locret_804C814; // weak
_UNKNOWN loc_804C954; // weak
_UNKNOWN loc_804C972; // weak
_UNKNOWN loc_804CB64; // weak
_UNKNOWN loc_804CC07; // weak
_UNKNOWN loc_804CDC5; // weak
_UNKNOWN loc_804CDE1; // weak
_UNKNOWN loc_804D0D1; // weak
_UNKNOWN loc_804D241; // weak
_UNKNOWN loc_804D354; // weak
_UNKNOWN loc_804D411; // weak
_UNKNOWN loc_804D471; // weak
_UNKNOWN loc_804D478; // weak
_UNKNOWN loc_804D7D5; // weak
_UNKNOWN loc_804D7F1; // weak
_UNKNOWN loc_804D821; // weak
_UNKNOWN loc_804D83E; // weak
_UNKNOWN loc_804D8AB; // weak
_UNKNOWN loc_804D9BF; // weak
_UNKNOWN loc_804D9F1; // weak
_UNKNOWN loc_804DA17; // weak
_UNKNOWN loc_804DA32; // weak
_UNKNOWN loc_804DB46; // weak
_UNKNOWN loc_804DB4A; // weak
_UNKNOWN loc_804DBE0; // weak
_UNKNOWN loc_804DC37; // weak
_UNKNOWN loc_804DCF8; // weak
_UNKNOWN loc_804DD02; // weak
_UNKNOWN loc_804E16C; // weak
_UNKNOWN loc_804E17D; // weak
_UNKNOWN locret_804E25B; // weak
_UNKNOWN loc_804E2EC; // weak
_UNKNOWN loc_804E328; // weak
_UNKNOWN loc_804E32B; // weak
_UNKNOWN loc_804E373; // weak
_UNKNOWN loc_804E377; // weak
_UNKNOWN loc_804E3AF; // weak
_UNKNOWN loc_804E4CC; // weak
_UNKNOWN loc_804E4D6; // weak
_UNKNOWN loc_804E6E7; // weak
_UNKNOWN loc_804E77D; // weak
_UNKNOWN loc_804E978; // weak
_UNKNOWN loc_804EAA5; // weak
_UNKNOWN loc_804EAC7; // weak
_UNKNOWN loc_804EAEC; // weak
_UNKNOWN loc_804EAF1; // weak
_UNKNOWN loc_804ED63; // weak
_UNKNOWN loc_804ED96; // weak
_UNKNOWN loc_804EEFF; // weak
_UNKNOWN loc_804EF9C; // weak
_UNKNOWN loc_804EFCB; // weak
_UNKNOWN loc_804F132; // weak
_UNKNOWN loc_804F149; // weak
_UNKNOWN loc_804F237; // weak
_UNKNOWN loc_804F292; // weak
_UNKNOWN loc_804F2C3; // weak
_UNKNOWN locret_804F307; // weak
_UNKNOWN loc_804F352; // weak
_UNKNOWN loc_804F379; // weak
_UNKNOWN loc_804F3B2; // weak
_UNKNOWN loc_804F3D5; // weak
_UNKNOWN loc_804F411; // weak
_UNKNOWN loc_804F41D; // weak
_UNKNOWN loc_804F443; // weak
_UNKNOWN loc_804F44F; // weak
_UNKNOWN loc_804F4FE; // weak
_UNKNOWN loc_804F50A; // weak
_UNKNOWN loc_804F545; // weak
_UNKNOWN loc_804F551; // weak
_UNKNOWN loc_804F606; // weak
_UNKNOWN loc_804F7D5; // weak
_UNKNOWN loc_804F7FB; // weak
_UNKNOWN loc_804F82C; // weak
_UNKNOWN loc_804F831; // weak
_UNKNOWN loc_804F91A; // weak
_UNKNOWN loc_804F93F; // weak
_UNKNOWN loc_804F9B8; // weak
_UNKNOWN loc_804F9F3; // weak
_UNKNOWN loc_804FA1A; // weak
_UNKNOWN loc_804FAA4; // weak
_UNKNOWN loc_804FAD4; // weak
_UNKNOWN loc_804FADB; // weak
_UNKNOWN loc_804FC8A; // weak
_UNKNOWN loc_804FC99; // weak
_UNKNOWN loc_804FDB8; // weak
_UNKNOWN loc_804FED5; // weak
_UNKNOWN loc_804FF15; // weak
_UNKNOWN loc_804FFDA; // weak
_UNKNOWN loc_805000B; // weak
_UNKNOWN loc_8050220; // weak
_UNKNOWN loc_8050255; // weak
_UNKNOWN loc_80502DE; // weak
_UNKNOWN loc_805031B; // weak
_UNKNOWN loc_805042C; // weak
_UNKNOWN loc_805044E; // weak
_UNKNOWN loc_8050470; // weak
_UNKNOWN loc_8050483; // weak
_UNKNOWN loc_80504D8; // weak
_UNKNOWN loc_8050524; // weak
_UNKNOWN loc_8050578; // weak
_UNKNOWN loc_805065A; // weak
_UNKNOWN loc_805078E; // weak
_UNKNOWN loc_8050A54; // weak
_UNKNOWN loc_8050AA4; // weak
_UNKNOWN loc_8050AA6; // weak
_UNKNOWN loc_8050AF6; // weak
_UNKNOWN loc_8050B22; // weak
_UNKNOWN loc_8050B41; // weak
_UNKNOWN loc_8050B47; // weak
_UNKNOWN loc_8050BB0; // weak
_UNKNOWN loc_8050BD4; // weak
_UNKNOWN loc_8050BDC; // weak
_UNKNOWN loc_8050C13; // weak
_UNKNOWN loc_8050C27; // weak
_UNKNOWN loc_8050D27; // weak
_UNKNOWN loc_8050D43; // weak
_UNKNOWN loc_8050D46; // weak
_UNKNOWN loc_8050DE0; // weak
_UNKNOWN loc_8050DE4; // weak
_UNKNOWN loc_8050E17; // weak
_UNKNOWN loc_8051352; // weak
_UNKNOWN loc_8051384; // weak
_UNKNOWN loc_8051390; // weak
_UNKNOWN loc_8051620; // weak
_UNKNOWN loc_8051E28; // weak
_UNKNOWN loc_8051E5D; // weak
_UNKNOWN loc_8051E8D; // weak
_UNKNOWN loc_8051F5C; // weak
_UNKNOWN loc_8051FB5; // weak
_UNKNOWN loc_8052075; // weak
_UNKNOWN loc_805207F; // weak
_UNKNOWN loc_8052292; // weak
_UNKNOWN loc_80522F7; // weak
_UNKNOWN loc_805243F; // weak
_UNKNOWN loc_805275D; // weak
_UNKNOWN loc_8052795; // weak
_UNKNOWN loc_80527A6; // weak
_UNKNOWN loc_80527EF; // weak
_UNKNOWN loc_8052848; // weak
_UNKNOWN loc_805285A; // weak
_UNKNOWN loc_80528E8; // weak
_UNKNOWN loc_80529E7; // weak
_UNKNOWN loc_8052A0F; // weak
_UNKNOWN loc_8052A48; // weak
_UNKNOWN loc_8052A9A; // weak
_UNKNOWN loc_8052AC3; // weak
_UNKNOWN loc_8052AD0; // weak
_UNKNOWN loc_8052BC7; // weak
_UNKNOWN loc_8052BEA; // weak
_UNKNOWN loc_8052C06; // weak
_UNKNOWN loc_8052C0B; // weak
_UNKNOWN loc_8052C0E; // weak
_UNKNOWN loc_8052CCA; // weak
_UNKNOWN loc_8052CE9; // weak
_UNKNOWN loc_805304F; // weak
_UNKNOWN loc_8053069; // weak
_UNKNOWN loc_80530D5; // weak
_UNKNOWN loc_80530FE; // weak
_UNKNOWN loc_805312F; // weak
_UNKNOWN loc_8053154; // weak
_UNKNOWN loc_805327A; // weak
_UNKNOWN loc_8053291; // weak
_UNKNOWN loc_80532DF; // weak
_UNKNOWN loc_8053567; // weak
_UNKNOWN loc_80535D2; // weak
_UNKNOWN loc_8053650; // weak
_UNKNOWN loc_80537D5; // weak
_UNKNOWN loc_8053AFE; // weak
_UNKNOWN loc_8053C19; // weak
_UNKNOWN loc_8053C46; // weak
_UNKNOWN loc_8053D6C; // weak
_UNKNOWN loc_8053DAA; // weak
_UNKNOWN loc_8053E57; // weak
_UNKNOWN loc_8053E59; // weak
_UNKNOWN loc_8053F43; // weak
_UNKNOWN loc_8053F49; // weak
_UNKNOWN loc_8053FFC; // weak
_UNKNOWN loc_805401D; // weak
_UNKNOWN loc_805407B; // weak
_UNKNOWN loc_805407F; // weak
_UNKNOWN loc_8054090; // weak
_UNKNOWN loc_805422B; // weak
_UNKNOWN loc_8054235; // weak
_UNKNOWN loc_8054274; // weak
_UNKNOWN loc_805429E; // weak
_UNKNOWN loc_80542A8; // weak
_UNKNOWN loc_8054315; // weak
_UNKNOWN loc_8054330; // weak
_UNKNOWN loc_8054473; // weak
_UNKNOWN loc_80544B4; // weak
_UNKNOWN loc_80544EA; // weak
_UNKNOWN loc_805452D; // weak
_UNKNOWN loc_8054565; // weak
_UNKNOWN loc_805458F; // weak
_UNKNOWN loc_805462C; // weak
_UNKNOWN loc_8054669; // weak
_UNKNOWN loc_8054694; // weak
_UNKNOWN loc_805476F; // weak
_UNKNOWN loc_8054793; // weak
_UNKNOWN loc_805479D; // weak
_UNKNOWN loc_80547BD; // weak
_UNKNOWN loc_80547E0; // weak
_UNKNOWN loc_80548BE; // weak
_UNKNOWN loc_80548DA; // weak
_UNKNOWN loc_8054925; // weak
_UNKNOWN loc_8054A52; // weak
_UNKNOWN loc_8054A69; // weak
_UNKNOWN loc_8054B6B; // weak
_UNKNOWN loc_8054B80; // weak
_UNKNOWN loc_8054BA4; // weak
_UNKNOWN loc_8054BF4; // weak
_UNKNOWN loc_8054D1E; // weak
_UNKNOWN loc_8054D33; // weak
_UNKNOWN loc_8054E8E; // weak
_UNKNOWN loc_8054EB2; // weak
_UNKNOWN loc_8054EDA; // weak
_UNKNOWN loc_8054F31; // weak
_UNKNOWN loc_805500F; // weak
_UNKNOWN loc_80550C7; // weak
_UNKNOWN loc_80550CC; // weak
_UNKNOWN loc_805537B; // weak
_UNKNOWN loc_805548B; // weak
_UNKNOWN loc_805550D; // weak
_UNKNOWN loc_8055514; // weak
_UNKNOWN loc_805553C; // weak
_UNKNOWN loc_805556D; // weak
_UNKNOWN loc_805558A; // weak
_UNKNOWN loc_80555AF; // weak
_UNKNOWN loc_80555DB; // weak
_UNKNOWN loc_80555FF; // weak
_UNKNOWN loc_8055647; // weak
_UNKNOWN loc_805573E; // weak
_UNKNOWN loc_805575E; // weak
_UNKNOWN loc_8055845; // weak
_UNKNOWN loc_8055A7C; // weak
_UNKNOWN locret_8055ABA; // weak
_UNKNOWN loc_8055C33; // weak
_UNKNOWN loc_8055DCF; // weak
_UNKNOWN loc_8055E55; // weak
_UNKNOWN loc_8056231; // weak
_UNKNOWN loc_80562FD; // weak
_UNKNOWN loc_805721D; // weak
_UNKNOWN loc_805728B; // weak
_UNKNOWN loc_8057291; // weak
_UNKNOWN loc_8057354; // weak
_UNKNOWN loc_805736C; // weak
_UNKNOWN loc_80573A5; // weak
_UNKNOWN loc_8057427; // weak
_UNKNOWN loc_8057457; // weak
_UNKNOWN loc_805747A; // weak
_UNKNOWN loc_80574E9; // weak
_UNKNOWN loc_80574F0; // weak
_UNKNOWN loc_8057535; // weak
_UNKNOWN locret_8057552; // weak
_UNKNOWN loc_80575C8; // weak
_UNKNOWN loc_80575E4; // weak
_UNKNOWN loc_8057614; // weak
_UNKNOWN loc_805761E; // weak
_UNKNOWN locret_805782B; // weak
_UNKNOWN loc_80578F4; // weak
_UNKNOWN locret_8057FB4; // weak
_UNKNOWN loc_8057FE3; // weak
_UNKNOWN loc_8058039; // weak
_UNKNOWN loc_80580AA; // weak
_UNKNOWN loc_80580B4; // weak
_UNKNOWN loc_80584E2; // weak
_UNKNOWN loc_8058505; // weak
_UNKNOWN loc_8058547; // weak
_UNKNOWN loc_8058550; // weak
_UNKNOWN loc_80585B8; // weak
_UNKNOWN loc_80585DF; // weak
_UNKNOWN locret_8058615; // weak
_UNKNOWN loc_805865D; // weak
_UNKNOWN loc_80586A5; // weak
_UNKNOWN loc_80586BC; // weak
_UNKNOWN loc_80586EB; // weak
_UNKNOWN loc_805870A; // weak
_UNKNOWN loc_805873B; // weak
_UNKNOWN loc_8058740; // weak
_UNKNOWN loc_8058865; // weak
_UNKNOWN loc_805886F; // weak
_UNKNOWN loc_8058A82; // weak
_UNKNOWN loc_8058A8A; // weak
_UNKNOWN locret_8058CB5; // weak
_UNKNOWN loc_8058CFE; // weak
_UNKNOWN loc_8058D18; // weak
_UNKNOWN locret_8058D22; // weak
_UNKNOWN loc_8058D8F; // weak
_UNKNOWN loc_8058E4E; // weak
_UNKNOWN loc_8058E88; // weak
_UNKNOWN loc_8058F1E; // weak
_UNKNOWN loc_8058F2E; // weak
_UNKNOWN loc_8058FB2; // weak
_UNKNOWN loc_805909B; // weak
_UNKNOWN loc_80590B7; // weak
_UNKNOWN loc_8059113; // weak
_UNKNOWN loc_80591C5; // weak
_UNKNOWN loc_80591C7; // weak
_UNKNOWN loc_8059621; // weak
_UNKNOWN loc_8059626; // weak
_UNKNOWN loc_8059693; // weak
_UNKNOWN loc_8059734; // weak
_UNKNOWN loc_8059776; // weak
_UNKNOWN loc_805977D; // weak
_UNKNOWN loc_80597A3; // weak
_UNKNOWN loc_80597A8; // weak
_UNKNOWN loc_8059824; // weak
_UNKNOWN loc_805982C; // weak
_UNKNOWN loc_80598C2; // weak
_UNKNOWN loc_80598C8; // weak
_UNKNOWN loc_80598D3; // weak
_UNKNOWN loc_805991E; // weak
_UNKNOWN loc_8059933; // weak
_UNKNOWN loc_8059997; // weak
_UNKNOWN locret_80599EC; // weak
_UNKNOWN loc_8059B1C; // weak
_UNKNOWN loc_8059C80; // weak
_UNKNOWN loc_8059C95; // weak
_UNKNOWN loc_8059EF0; // weak
_UNKNOWN loc_8059F1D; // weak
_UNKNOWN loc_8059F94; // weak
_UNKNOWN loc_805A0D5; // weak
_UNKNOWN loc_805A180; // weak
_UNKNOWN loc_805A187; // weak
_UNKNOWN loc_805A1EF; // weak
_UNKNOWN loc_805A510; // weak
_UNKNOWN loc_805A527; // weak
_UNKNOWN loc_805A557; // weak
_UNKNOWN loc_805A58E; // weak
_UNKNOWN loc_805A60C; // weak
_UNKNOWN loc_805A64F; // weak
_UNKNOWN loc_805A688; // weak
_UNKNOWN loc_805A6D1; // weak
_UNKNOWN loc_805A751; // weak
_UNKNOWN loc_805A7FF; // weak
_UNKNOWN loc_805A804; // weak
_UNKNOWN loc_805A963; // weak
_UNKNOWN loc_805A988; // weak
_UNKNOWN loc_805A98D; // weak
_UNKNOWN loc_805A99E; // weak
_UNKNOWN loc_805AA0F; // weak
_UNKNOWN loc_805AA14; // weak
_UNKNOWN loc_805AA52; // weak
_UNKNOWN loc_805AA7C; // weak
_UNKNOWN loc_805AA8F; // weak
_UNKNOWN loc_805AADD; // weak
_UNKNOWN loc_805ABE0; // weak
_UNKNOWN loc_805ABFB; // weak
_UNKNOWN loc_805AC68; // weak
_UNKNOWN loc_805ACA6; // weak
_UNKNOWN loc_805ACCE; // weak
_UNKNOWN loc_805ACD2; // weak
_UNKNOWN loc_805ACED; // weak
_UNKNOWN loc_805AD1E; // weak
_UNKNOWN loc_805AEE4; // weak
_UNKNOWN loc_805AF08; // weak
_UNKNOWN loc_805AF0E; // weak
_UNKNOWN loc_805AFA6; // weak
_UNKNOWN loc_805AFEF; // weak
_UNKNOWN loc_805B006; // weak
_UNKNOWN loc_805B087; // weak
_UNKNOWN loc_805B08B; // weak
_UNKNOWN loc_805B0C5; // weak
_UNKNOWN loc_805B0EC; // weak
_UNKNOWN loc_805B0FD; // weak
_UNKNOWN loc_805B135; // weak
_UNKNOWN loc_805B1A9; // weak
_UNKNOWN loc_805B1BB; // weak
_UNKNOWN loc_805B1E5; // weak
_UNKNOWN loc_805B211; // weak
_UNKNOWN loc_805B23E; // weak
_UNKNOWN loc_805B29A; // weak
_UNKNOWN loc_805B5BB; // weak
_UNKNOWN loc_805B5D7; // weak
_UNKNOWN loc_805B5DA; // weak
_UNKNOWN loc_805C949; // weak
_UNKNOWN loc_805CFB2; // weak
_UNKNOWN loc_805CFC2; // weak
_UNKNOWN loc_805D1EA; // weak
_UNKNOWN loc_805D1EC; // weak
_UNKNOWN loc_805D238; // weak
_UNKNOWN loc_805D2CF; // weak
_UNKNOWN loc_805D2F9; // weak
_UNKNOWN loc_805D314; // weak
_UNKNOWN loc_805D335; // weak
_UNKNOWN locret_805D374; // weak
_UNKNOWN loc_805D3D3; // weak
_UNKNOWN loc_805D419; // weak
_UNKNOWN loc_805D445; // weak
_UNKNOWN loc_805D470; // weak
_UNKNOWN loc_805D483; // weak
_UNKNOWN loc_805D49A; // weak
_UNKNOWN loc_805D662; // weak
_UNKNOWN loc_805D68E; // weak
_UNKNOWN loc_805D6FF; // weak
_UNKNOWN loc_805D73F; // weak
_UNKNOWN locret_805D900; // weak
_UNKNOWN loc_805DEC1; // weak
_UNKNOWN loc_805E0BD; // weak
_UNKNOWN loc_805E0DA; // weak
_UNKNOWN loc_805E1CF; // weak
_UNKNOWN loc_805E1DA; // weak
_UNKNOWN loc_805E472; // weak
_UNKNOWN loc_805E506; // weak
_UNKNOWN loc_805E522; // weak
_UNKNOWN locret_805E542; // weak
_UNKNOWN loc_805E59B; // weak
_UNKNOWN loc_805E689; // weak
_UNKNOWN loc_805E6A5; // weak
_UNKNOWN loc_805E6F6; // weak
_UNKNOWN loc_805E72D; // weak
_UNKNOWN loc_805E736; // weak
_UNKNOWN loc_805E764; // weak
_UNKNOWN loc_805E793; // weak
_UNKNOWN loc_805E848; // weak
_UNKNOWN loc_805E88F; // weak
_UNKNOWN loc_805E895; // weak
_UNKNOWN loc_805E8A2; // weak
_UNKNOWN loc_805EA45; // weak
_UNKNOWN locret_805EA75; // weak
_UNKNOWN loc_805EC64; // weak
_UNKNOWN loc_805EC6C; // weak
_UNKNOWN loc_805ECCC; // weak
_UNKNOWN loc_805ECD9; // weak
_UNKNOWN loc_805ED10; // weak
_UNKNOWN loc_805EDDA; // weak
_UNKNOWN loc_805EDF0; // weak
_UNKNOWN loc_805F19A; // weak
_UNKNOWN loc_805F1C2; // weak
_UNKNOWN loc_805F1CC; // weak
_UNKNOWN loc_805F22C; // weak
_UNKNOWN loc_805F35F; // weak
_UNKNOWN loc_805F389; // weak
_UNKNOWN loc_805F442; // weak
_UNKNOWN loc_805F4E9; // weak
_UNKNOWN locret_805F509; // weak
_UNKNOWN loc_805F530; // weak
_UNKNOWN loc_805F536; // weak
_UNKNOWN loc_805F57E; // weak
_UNKNOWN loc_805F5AA; // weak
_UNKNOWN loc_805F5DC; // weak
_UNKNOWN loc_805F5F6; // weak
_UNKNOWN loc_805F633; // weak
_UNKNOWN loc_805F64D; // weak
_UNKNOWN loc_805FD19; // weak
_UNKNOWN loc_805FD2B; // weak
_UNKNOWN loc_806000B; // weak
_UNKNOWN loc_8060023; // weak
_UNKNOWN loc_806008B; // weak
_UNKNOWN loc_80600C0; // weak
_UNKNOWN loc_80600F2; // weak
_UNKNOWN loc_8060115; // weak
_UNKNOWN loc_80601CD; // weak
_UNKNOWN loc_8060411; // weak
_UNKNOWN loc_8060418; // weak
_UNKNOWN loc_806049B; // weak
_UNKNOWN loc_80604AC; // weak
_UNKNOWN loc_806058B; // weak
_UNKNOWN loc_80605BA; // weak
_UNKNOWN loc_8060612; // weak
_UNKNOWN loc_8060624; // weak
_UNKNOWN loc_806064B; // weak
_UNKNOWN loc_8060684; // weak
_UNKNOWN loc_8060843; // weak
_UNKNOWN loc_806084A; // weak
_UNKNOWN loc_8060873; // weak
_UNKNOWN loc_8060881; // weak
_UNKNOWN loc_80608B7; // weak
_UNKNOWN loc_8060A28; // weak
_UNKNOWN loc_8060A67; // weak
_UNKNOWN loc_8060A72; // weak
_UNKNOWN loc_8060A93; // weak
_UNKNOWN locret_8060BCD; // weak
_UNKNOWN loc_8060E3B; // weak
_UNKNOWN loc_8060E71; // weak
char s = '\0'; // idb
struct option longopts = { "ignore-leading-blanks", 0, NULL, 98 }; // idb
char *off_8062F74[3] = { "quiet", "silent", "diagnose-first" }; // weak
char aCccgeneralNume[19] = "CCcgeneral-numeric"; // weak
void *off_8062FBC = (void *)0x8062F87; // weak
char byte_8062FD8[6] = { 'g', 'h', 'M', 'n', 'R', 'V' }; // idb
char byte_8063248[256] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x06',
  '\0',
  '\x03',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0',
  '\x04',
  '\0',
  '\0',
  '\0',
  '\0',
  '\b',
  '\a',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
int sig[11] = { 14, 1, 2, 13, 3, 15, 29, 27, 26, 24, 25 }; // idb
_UNKNOWN unk_8063EC8; // weak
_UNKNOWN unk_8063F18; // weak
_UNKNOWN unk_806412D; // weak
_UNKNOWN unk_8064E17; // weak
int dword_8065EF8 = 2; // weak
_UNKNOWN unk_806637C; // weak
_UNKNOWN unk_806637F; // weak
int dword_8066EF4 = 135151872; // weak
_UNKNOWN unk_80673CC; // weak
_UNKNOWN unk_80673CF; // weak
_UNKNOWN unk_8068408; // weak
_UNKNOWN unk_806840B; // weak
_UNKNOWN unk_8069444; // weak
_UNKNOWN unk_8069447; // weak
int (*off_806AEB0[2])() = { &sub_804A030, &sub_804A010 }; // weak
int (*off_806AEB4)() = &sub_804A010; // weak
Elf32_Dyn stru_806AEFC = { 1879047925, { 134513068u } }; // weak
Elf32_Dyn stru_806AF04 = { 5, { 134515372u } }; // weak
int (*dword_806B008)(void) = NULL; // weak
int dword_806B20C = 0; // weak
int dword_806B220 = 0; // weak
int dword_806B234 = 0; // weak
int dword_806B248 = 0; // weak
int dword_806B25C = 0; // weak
int dword_806B270 = 0; // weak
int dword_806B284 = 0; // weak
int dword_806B298 = 0; // weak
int dword_806B2AC = 0; // weak
int dword_806B2C0 = 0; // weak
int dword_806B2D4 = 0; // weak
int dword_806B2E8 = 0; // weak
int dword_806B2FC = 0; // weak
int dword_806B310 = 0; // weak
int dword_806B324 = 0; // weak
int dword_806B338 = 0; // weak
int dword_806B34C = 0; // weak
int dword_806B360 = 0; // weak
int dword_806B374 = 0; // weak
int dword_806B38C = 0; // weak
char byte_806B3A8 = '\n'; // weak
char *off_806B3C8 = "APR"; // weak
int dword_806B3CC[] = { 4 }; // weak
size_t dword_806B428 = 262144u; // idb
int dword_806B42C = 128; // weak
int dword_806B430 = 16; // idb
int *off_806B434 = &dword_806C264; // weak
char byte_806B438 = 'X'; // weak
char byte_806B442 = '\0'; // weak
int off_806B448 = 134626880; // idb
int off_806B44C = 134568330; // idb
int status = 1; // idb
int dword_806B468 = 1; // weak
int dword_806B46C = 256; // weak
void *off_806B470 = &unk_806C384; // weak
int *off_806B474 = &dword_806B46C; // weak
_UNKNOWN unk_806B488; // weak
_UNKNOWN unk_806B4A8; // weak
_UNKNOWN unk_806B4AB; // weak
_UNKNOWN unk_806B4B0; // weak
_UNKNOWN unk_806B4B3; // weak
_UNKNOWN unk_806B4BC; // weak
_UNKNOWN unk_806B4BF; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int program_invocation_name; // weak
int optind; // weak
_UNKNOWN stdin; // weak
FILE *stdout; // idb
int (*obstack_alloc_failed_handler)(void); // weak
char *optarg; // idb
char byte_806B52C; // weak
_UNKNOWN unk_806B60A; // weak
char byte_806B74D; // weak
_UNKNOWN unk_806B972; // weak
char byte_806BBFC; // weak
_UNKNOWN unk_806BCDA; // weak
int dword_806BDA4; // weak
int dword_806BDA8; // weak
char byte_806BDAC; // weak
char byte_806BDAD; // weak
int dword_806BDB0; // weak
int dword_806BDB4; // weak
int dword_806BDB8; // weak
int dword_806BDBC; // weak
char byte_806BDC4[256]; // idb
_UNKNOWN unk_806BEC4; // weak
_UNKNOWN unk_806BFC4; // weak
char byte_806C0C4[256]; // idb
size_t size; // idb
void *ptr; // idb
int dword_806C1CC; // weak
int dword_806C1D0; // weak
char byte_806C1D4; // weak
char byte_806C1D5; // weak
char byte_806C1D6; // weak
char byte_806C1D7; // weak
int dword_806C1D8; // weak
char *arg; // idb
char byte_806C1E0; // weak
__sigset_t set; // idb
int dword_806C264; // weak
int dword_806C268; // weak
int dword_806C26C; // weak
_UNKNOWN unk_806C284; // weak
int dword_806C320; // weak
int dword_806C324; // weak
int dword_806C328; // weak
char byte_806C32C; // weak
int dword_806C330; // weak
int dword_806C334; // weak
int dword_806C344[]; // weak
int dword_806C348; // weak
int dword_806C34C; // weak
int dword_806C350; // weak
int dword_806C354; // weak
int dword_806C358; // weak
int dword_806C35C; // weak
int dword_806C360; // weak
int dword_806C364; // weak
int dword_806C368; // weak
int dword_806C36C; // weak
int dword_806C370; // weak
_UNKNOWN unk_806C384; // weak
int dword_806C484; // weak
int dword_806C488; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (0804972C) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 8049F30: using guessed type int _gmon_start__(void);

//----- (08049750) --------------------------------------------------------
int sub_8049750()
{
  return dword_806B008();
}
// 806B008: using guessed type int (*dword_806B008)(void);

//----- (08049F40) --------------------------------------------------------
#error "8049F43: positive sp value has been found (funcsize=2)"

//----- (08049F73) --------------------------------------------------------
void sub_8049F73()
{
  ;
}

//----- (08049F90) --------------------------------------------------------
void sub_8049F90()
{
  ;
}

//----- (08049FA0) --------------------------------------------------------
int sub_8049FA0()
{
  int result; // eax

  result = &unk_806B4BF - &unk_806B4BC;
  if ( (unsigned int)(&unk_806B4BF - &unk_806B4BC) > 6 )
    result = 0;
  return result;
}
// 8049FA0: could not find valid save-restore pair for ebp

//----- (0804A010) --------------------------------------------------------
int sub_804A010()
{
  int result; // eax

  if ( !byte_806B52C )
  {
    result = sub_8049FA0();
    byte_806B52C = 1;
  }
  return result;
}
// 804A010: could not find valid save-restore pair for ebp
// 806B52C: using guessed type char byte_806B52C;

//----- (0804A030) --------------------------------------------------------
int sub_804A030()
{
  return 0;
}
// 804A030: could not find valid save-restore pair for ebp

//----- (0804A08F) --------------------------------------------------------
void sub_804A08F()
{
  ;
}

//----- (0804A0AA) --------------------------------------------------------
void sub_804A0AA()
{
  ;
}

//----- (0804A0BA) --------------------------------------------------------
int sub_804A0BA()
{
  int result; // eax

  result = &unk_806B4AB - &unk_806B4A8;
  if ( (unsigned int)(&unk_806B4AB - &unk_806B4A8) > 6 )
    result = 0;
  return result;
}
// 804A0BA: could not find valid save-restore pair for ebp

//----- (0804A19C) --------------------------------------------------------
void sub_804A19C()
{
  ;
}

//----- (0804A1B7) --------------------------------------------------------
void sub_804A1B7()
{
  ;
}

//----- (0804A1C7) --------------------------------------------------------
signed int sub_804A1C7()
{
  return 3;
}
// 804A1C7: could not find valid save-restore pair for ebp

//----- (0804A2A9) --------------------------------------------------------
void sub_804A2A9()
{
  ;
}

//----- (0804A2C4) --------------------------------------------------------
void sub_804A2C4()
{
  ;
}

//----- (0804A2D4) --------------------------------------------------------
int sub_804A2D4()
{
  int result; // eax

  result = &unk_806B60A - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_806B60A - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 804A2D4: could not find valid save-restore pair for ebp
// 806B4C0: using guessed type int program_invocation_short_name;

//----- (0804A386) --------------------------------------------------------
int __usercall sub_804A386@<eax>(void (__cdecl *a1)(signed int)@<eax>)
{
  a1(134651588);
  return 0;
}

//----- (0804A3D2) --------------------------------------------------------
void sub_804A3D2()
{
  ;
}

//----- (0804A3ED) --------------------------------------------------------
void sub_804A3ED()
{
  ;
}

//----- (0804A3FD) --------------------------------------------------------
int sub_804A3FD()
{
  int result; // eax

  result = &unk_806B4AB - &unk_806B4A8;
  if ( (unsigned int)(&unk_806B4AB - &unk_806B4A8) > 6 )
    result = 0;
  return result;
}
// 804A3FD: could not find valid save-restore pair for ebp

//----- (0804A4DF) --------------------------------------------------------
void sub_804A4DF()
{
  ;
}

//----- (0804A4FA) --------------------------------------------------------
void sub_804A4FA()
{
  ;
}

//----- (0804A50A) --------------------------------------------------------
int sub_804A50A()
{
  int result; // eax

  result = &unk_806B4AB - &unk_806B4A8;
  if ( (unsigned int)(&unk_806B4AB - &unk_806B4A8) > 6 )
    result = 0;
  return result;
}
// 804A50A: could not find valid save-restore pair for ebp

//----- (0804A594) --------------------------------------------------------
int sub_804A594()
{
  int result; // eax

  result = sub_804A50A();
  byte_806B74D = 1;
  return result;
}
// 806B74D: using guessed type char byte_806B74D;

//----- (0804A608) --------------------------------------------------------
void sub_804A608()
{
  ;
}

//----- (0804A623) --------------------------------------------------------
void sub_804A623()
{
  ;
}

//----- (0804A633) --------------------------------------------------------
int sub_804A633()
{
  int result; // eax

  result = &unk_8069447 - &unk_8069444;
  if ( (unsigned int)(&unk_8069447 - &unk_8069444) > 6 )
    result = 0;
  return result;
}
// 804A633: could not find valid save-restore pair for ebp

//----- (0804A715) --------------------------------------------------------
void sub_804A715()
{
  ;
}

//----- (0804A730) --------------------------------------------------------
void sub_804A730()
{
  ;
}

//----- (0804A740) --------------------------------------------------------
int sub_804A740()
{
  int result; // eax

  result = &unk_806B4AB - &unk_806B4A8;
  if ( (unsigned int)(&unk_806B4AB - &unk_806B4A8) > 6 )
    result = 0;
  return result;
}
// 804A740: could not find valid save-restore pair for ebp

//----- (0804A822) --------------------------------------------------------
void sub_804A822()
{
  ;
}

//----- (0804A83D) --------------------------------------------------------
void sub_804A83D()
{
  ;
}

//----- (0804A84D) --------------------------------------------------------
int sub_804A84D()
{
  int result; // eax

  result = &unk_806B4AB - &unk_806B4A8;
  if ( (unsigned int)(&unk_806B4AB - &unk_806B4A8) > 6 )
    result = 0;
  return result;
}
// 804A84D: could not find valid save-restore pair for ebp

//----- (0804A92F) --------------------------------------------------------
void sub_804A92F()
{
  ;
}

//----- (0804A94A) --------------------------------------------------------
void sub_804A94A()
{
  ;
}

//----- (0804A95A) --------------------------------------------------------
int sub_804A95A()
{
  int result; // eax

  result = &unk_806840B - &unk_8068408;
  if ( (unsigned int)(&unk_806840B - &unk_8068408) > 6 )
    result = 0;
  return result;
}
// 804A95A: could not find valid save-restore pair for ebp

//----- (0804A9C1) --------------------------------------------------------
int __usercall sub_804A9C1@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_8068408, a1);
}

//----- (0804AA58) --------------------------------------------------------
void sub_804AA58()
{
  ;
}

//----- (0804AA73) --------------------------------------------------------
void sub_804AA73()
{
  ;
}

//----- (0804AA83) --------------------------------------------------------
int sub_804AA83()
{
  int result; // eax

  result = &unk_806B4AB - &unk_806B4A8;
  if ( (unsigned int)(&unk_806B4AB - &unk_806B4A8) > 6 )
    result = 0;
  return result;
}
// 804AA83: could not find valid save-restore pair for ebp

//----- (0804AB65) --------------------------------------------------------
void sub_804AB65()
{
  ;
}

//----- (0804AB80) --------------------------------------------------------
void sub_804AB80()
{
  ;
}

//----- (0804AB90) --------------------------------------------------------
int sub_804AB90()
{
  int result; // eax

  result = &unk_806B972 - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_806B972 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 804AB90: could not find valid save-restore pair for ebp
// 806B4C0: using guessed type int program_invocation_short_name;

//----- (0804AC8E) --------------------------------------------------------
void sub_804AC8E()
{
  ;
}

//----- (0804ACA9) --------------------------------------------------------
void sub_804ACA9()
{
  ;
}

//----- (0804ACB9) --------------------------------------------------------
int sub_804ACB9()
{
  int result; // eax

  result = &unk_80673CF - &unk_80673CC;
  if ( (unsigned int)(&unk_80673CF - &unk_80673CC) > 6 )
    result = 0;
  return result;
}
// 804ACB9: could not find valid save-restore pair for ebp

//----- (0804ADB7) --------------------------------------------------------
void sub_804ADB7()
{
  ;
}

//----- (0804ADD2) --------------------------------------------------------
void sub_804ADD2()
{
  ;
}

//----- (0804ADE2) --------------------------------------------------------
int sub_804ADE2()
{
  int result; // eax
  int (__stdcall *v1)(void *, int, int, int, int, int); // eax
  int v2; // [esp+4h] [ebp-18h]
  int v3; // [esp+8h] [ebp-14h]
  int v4; // [esp+Ch] [ebp-10h]
  int v5; // [esp+10h] [ebp-Ch]
  int v6; // [esp+14h] [ebp-8h]
  int v7; // [esp+18h] [ebp-4h]

  result = &unk_806B4AB - &unk_806B4A8;
  if ( (unsigned int)(&unk_806B4AB - &unk_806B4A8) > 6 )
  {
    v7 = 0;
    dword_806B234 = (int)&locret_804ADF1;
    v1 = (int (__stdcall *)(void *, int, int, int, int, int))sub_806185D();
    result = v1(&unk_806B4A8, v2, v3, v4, v5, v6);
  }
  return result;
}
// 806185D: using guessed type int sub_806185D(void);
// 806B234: using guessed type int dword_806B234;

//----- (0804AE59) --------------------------------------------------------
int sub_804AE59()
{
  return nullsub_4();
}
// 804AE59: could not find valid save-restore pair for ebp
// 804AE58: using guessed type int nullsub_4(void);

//----- (0804AEF9) --------------------------------------------------------
void sub_804AEF9()
{
  ;
}

//----- (0804AF14) --------------------------------------------------------
void sub_804AF14()
{
  ;
}

//----- (0804AF24) --------------------------------------------------------
int sub_804AF24()
{
  int result; // eax

  result = &unk_806B4AB - &unk_806B4A8;
  if ( (unsigned int)(&unk_806B4AB - &unk_806B4A8) > 6 )
    result = 0;
  return result;
}
// 804AF24: could not find valid save-restore pair for ebp

//----- (0804B006) --------------------------------------------------------
void sub_804B006()
{
  ;
}

//----- (0804B021) --------------------------------------------------------
void sub_804B021()
{
  ;
}

//----- (0804B031) --------------------------------------------------------
int sub_804B031()
{
  int result; // eax

  result = &unk_806B4AB - &unk_806B4A8;
  if ( (unsigned int)(&unk_806B4AB - &unk_806B4A8) > 6 )
    result = 0;
  return result;
}
// 804B031: could not find valid save-restore pair for ebp

//----- (0804B05D) --------------------------------------------------------
int sub_804B05D()
{
  return 0;
}
// 804B05D: could not find valid save-restore pair for ebp

//----- (0804B0FC) --------------------------------------------------------
int __usercall sub_804B0FC@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  a1(&dword_8066EF4);
  return sub_804B05D();
}
// 8066EF4: using guessed type int dword_8066EF4;

//----- (0804B148) --------------------------------------------------------
void sub_804B148()
{
  ;
}

//----- (0804B163) --------------------------------------------------------
void sub_804B163()
{
  ;
}

//----- (0804B173) --------------------------------------------------------
int sub_804B173()
{
  int result; // eax

  result = &unk_806637F - &unk_806637C;
  if ( (unsigned int)(&unk_806637F - &unk_806637C) > 6 )
    result = 0;
  return result;
}
// 804B173: could not find valid save-restore pair for ebp

//----- (0804B1DA) --------------------------------------------------------
int __usercall sub_804B1DA@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_806637C, a1);
}

//----- (0804B216) --------------------------------------------------------
int sub_804B216()
{
  int result; // eax

  result = sub_804B173();
  byte_806BBFC = 1;
  return result;
}
// 806BBFC: using guessed type char byte_806BBFC;

//----- (0804B257) --------------------------------------------------------
int __usercall sub_804B257@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  a1(&dword_8065EF8);
  return nullsub_5();
}
// 804B257: could not find valid save-restore pair for ebx
// 804B1B7: using guessed type int nullsub_5(void);
// 80616F6: using guessed type int __fastcall sub_80616F6(_DWORD, _DWORD);
// 8065EF8: using guessed type int dword_8065EF8;
// 806B270: using guessed type int dword_806B270;

//----- (0804B2A3) --------------------------------------------------------
void sub_804B2A3()
{
  ;
}

//----- (0804B2BE) --------------------------------------------------------
void sub_804B2BE()
{
  ;
}

//----- (0804B2CE) --------------------------------------------------------
int sub_804B2CE()
{
  int result; // eax

  result = &unk_806B4AB - &unk_806B4A8;
  if ( (unsigned int)(&unk_806B4AB - &unk_806B4A8) > 6 )
    result = 0;
  return result;
}
// 804B2CE: could not find valid save-restore pair for ebp

//----- (0804B335) --------------------------------------------------------
int __usercall sub_804B335@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_806B4A8, a1);
}

//----- (0804B3DE) --------------------------------------------------------
void sub_804B3DE()
{
  ;
}

//----- (0804B3F9) --------------------------------------------------------
void sub_804B3F9()
{
  ;
}

//----- (0804B409) --------------------------------------------------------
int sub_804B409()
{
  int result; // eax

  result = &unk_806B4AB - &unk_806B4A8;
  if ( (unsigned int)(&unk_806B4AB - &unk_806B4A8) > 6 )
    result = 0;
  return result;
}
// 804B409: could not find valid save-restore pair for ebp

//----- (0804B470) --------------------------------------------------------
int __usercall sub_804B470@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_806B4A8, a1);
}

//----- (0804B507) --------------------------------------------------------
void sub_804B507()
{
  ;
}

//----- (0804B522) --------------------------------------------------------
void sub_804B522()
{
  ;
}

//----- (0804B532) --------------------------------------------------------
int sub_804B532()
{
  int result; // eax

  result = &unk_806BCDA - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_806BCDA - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 804B532: could not find valid save-restore pair for ebp
// 806B4C0: using guessed type int program_invocation_short_name;

//----- (0804B614) --------------------------------------------------------
void sub_804B614()
{
  ;
}

//----- (0804B62F) --------------------------------------------------------
void sub_804B62F()
{
  ;
}

//----- (0804B63F) --------------------------------------------------------
int sub_804B63F()
{
  int result; // eax
  int (__stdcall *v1)(void *, int, int, int, int, int); // eax
  int v2; // [esp+4h] [ebp-18h]
  int v3; // [esp+8h] [ebp-14h]
  int v4; // [esp+Ch] [ebp-10h]
  int v5; // [esp+10h] [ebp-Ch]
  int v6; // [esp+14h] [ebp-8h]
  int v7; // [esp+18h] [ebp-4h]

  result = &unk_806B4B3 - &unk_806B4B0;
  if ( (unsigned int)(&unk_806B4B3 - &unk_806B4B0) > 6 )
  {
    v7 = 0;
    dword_806B248 = (int)&locret_804B64E;
    v1 = (int (__stdcall *)(void *, int, int, int, int, int))sub_80617ED();
    result = v1(&unk_806B4B0, v2, v3, v4, v5, v6);
  }
  return result;
}
// 80617ED: using guessed type int sub_80617ED(void);
// 806B248: using guessed type int dword_806B248;

//----- (0804B708) --------------------------------------------------------
int __cdecl sub_804B708(int a1)
{
  void *v1; // eax
  int result; // eax

  v1 = &loc_804B72A;
  if ( a1 == 1 )
    v1 = &loc_804B732;
  dword_806B220 = (int)v1;
  sub_80618EC();
  result = a1;
  status = a1;
  return result;
}
// 80618EC: using guessed type int sub_80618EC(void);
// 806B220: using guessed type int dword_806B220;

//----- (0804B734) --------------------------------------------------------
int __cdecl sub_804B734(unsigned __int8 a1)
{
  return a1;
}

//----- (0804B746) --------------------------------------------------------
int __cdecl sub_804B746(unsigned __int8 a1)
{
  return (*__ctype_b_loc())[a1] & 1 || a1 == 10;
}

//----- (0804B785) --------------------------------------------------------
char *__cdecl sub_804B785(unsigned __int64 a1)
{
  char *result; // eax

  if ( HIDWORD(a1) )
    result = sub_8060E00(a1, 1000000LL) + 1000000;
  else
    result = (char *)a1;
  return result;
}

//----- (0804B7CB) --------------------------------------------------------
int sub_804B7CB()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nWith no FILE, or when FILE is -, read standard input.\n");
  return fputs_unlocked(v1, v0);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804B7F6) --------------------------------------------------------
int sub_804B7F6()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nMandatory arguments to long options are mandatory for short options too.\n");
  return fputs_unlocked(v1, v0);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804B821) --------------------------------------------------------
int __cdecl sub_804B821(char *s1)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // ebx
  char *v5; // eax
  char *v7; // [esp+1Ch] [ebp-4Ch]
  const char **i; // [esp+20h] [ebp-48h]
  const char *v9; // [esp+24h] [ebp-44h]
  const char *v10; // [esp+28h] [ebp-40h]
  const char *v11; // [esp+2Ch] [ebp-3Ch]
  const char *v12; // [esp+30h] [ebp-38h]
  const char *v13; // [esp+34h] [ebp-34h]
  const char *v14; // [esp+38h] [ebp-30h]
  const char *v15; // [esp+3Ch] [ebp-2Ch]
  const char *v16; // [esp+40h] [ebp-28h]
  const char *v17; // [esp+44h] [ebp-24h]
  const char *v18; // [esp+48h] [ebp-20h]
  const char *v19; // [esp+4Ch] [ebp-1Ch]
  const char *v20; // [esp+50h] [ebp-18h]
  const char *v21; // [esp+54h] [ebp-14h]
  int v22; // [esp+58h] [ebp-10h]
  int v23; // [esp+5Ch] [ebp-Ch]

  v10 = "[";
  v11 = "test invocation";
  v12 = "coreutils";
  v13 = "Multi-call invocation";
  v14 = "sha224sum";
  v15 = "sha2 utilities";
  v16 = "sha256sum";
  v17 = "sha2 utilities";
  v18 = "sha384sum";
  v19 = "sha2 utilities";
  v20 = "sha512sum";
  v21 = "sha2 utilities";
  v22 = 0;
  v23 = 0;
  v7 = s1;
  for ( i = &v10; *i && strcmp(s1, *i); i += 2 )
    ;
  if ( i[1] )
    v7 = (char *)i[1];
  v1 = gettext("\n%s online help: <%s>\n");
  printf(v1, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  v9 = setlocale(5, 0);
  if ( v9 && strncmp(v9, "en_", 3u) )
  {
    v2 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
    printf(v2, s1);
  }
  v3 = gettext("Full documentation at: <%s%s>\n");
  printf(v3, "http://www.gnu.org/software/coreutils/", s1);
  if ( v7 == s1 )
    v4 = " invocation";
  else
    v4 = &s;
  v5 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  return printf(v5, v7, v4);
}

//----- (0804B9A7) --------------------------------------------------------
void __cdecl __noreturn sub_804B9A7(int a1, const char *a2)
{
  size_t v2; // eax
  void *v3; // eax
  char *v4; // ST28_4
  size_t v5; // eax
  char v6; // [esp+30h] [ebp-18h]
  unsigned int v7; // [esp+3Ch] [ebp-Ch]

  v7 = __readgsdword(0x14u);
  v2 = strlen(a2);
  write(2, a2, v2);
  v3 = &loc_804BA02;
  if ( !a1 )
    v3 = &loc_804BA5B;
  dword_806B25C = (int)v3;
  sub_806177B();
  v4 = (char *)sub_80592A6(a1, (int)&v6);
  write(2, ": errno ", 8u);
  v5 = strlen(v4);
  write(2, v4, v5);
  write(2, "\n", 1u);
  _exit(2);
}
// 806177B: using guessed type int sub_806177B(void);
// 806B25C: using guessed type int dword_806B25C;

//----- (0804BA86) --------------------------------------------------------
void __cdecl __noreturn sub_804BA86(int a1, int a2)
{
  void *v2; // eax

  v2 = &loc_804BAAC;
  if ( a2 )
    v2 = &loc_804BABA;
  dword_806B248 = (int)v2;
  sub_80617ED();
  gettext("standard output");
  sub_805B9FE(0, 3);
}
// 80617ED: using guessed type int sub_80617ED(void);
// 806B248: using guessed type int dword_806B248;

//----- (0804BB01) --------------------------------------------------------
void __cdecl __noreturn sub_804BB01(int status)
{
  int v1; // ebx
  char *v2; // eax
  int v3; // esi
  int v4; // ebx
  char *v5; // eax
  FILE *v6; // ebx
  char *v7; // eax
  FILE *v8; // ebx
  char *v9; // eax
  FILE *v10; // ebx
  char *v11; // eax
  FILE *v12; // ebx
  char *v13; // eax
  FILE *v14; // ebx
  char *v15; // eax
  FILE *v16; // ebx
  char *v17; // eax
  FILE *v18; // ebx
  char *v19; // eax
  FILE *v20; // ebx
  char *v21; // eax
  FILE *v22; // ebx
  char *v23; // eax
  FILE *v24; // ebx
  char *v25; // eax
  FILE *v26; // ebx
  char *v27; // eax
  FILE *v28; // ebx
  char *v29; // eax
  FILE *v30; // ebx
  char *v31; // eax
  char *v32; // eax
  FILE *v33; // ebx
  char *v34; // eax
  FILE *v35; // ebx
  char *v36; // eax
  FILE *v37; // ebx
  char *v38; // eax
  FILE *v39; // ebx
  char *v40; // eax
  FILE *v41; // ebx
  char *v42; // eax

  if ( status )
  {
    v1 = dword_806C334;
    v2 = gettext("Try '%s --help' for more information.\n");
    fprintf(stderr, v2, v1);
  }
  else
  {
    v3 = dword_806C334;
    v4 = dword_806C334;
    v5 = gettext("Usage: %s [OPTION]... [FILE]...\n  or:  %s [OPTION]... --files0-from=F\n");
    printf(v5, v4, v3);
    v6 = stdout;
    v7 = gettext("Write sorted concatenation of all FILE(s) to standard output.\n");
    fputs_unlocked(v7, v6);
    sub_804B7CB();
    sub_804B7F6();
    v8 = stdout;
    v9 = gettext("Ordering options:\n\n");
    fputs_unlocked(v9, v8);
    v10 = stdout;
    v11 = gettext(
            "  -b, --ignore-leading-blanks  ignore leading blanks\n"
            "  -d, --dictionary-order      consider only blanks and alphanumeric characters\n"
            "  -f, --ignore-case           fold lower case to upper case characters\n");
    fputs_unlocked(v11, v10);
    v12 = stdout;
    v13 = gettext(
            "  -g, --general-numeric-sort  compare according to general numerical value\n"
            "  -i, --ignore-nonprinting    consider only printable characters\n"
            "  -M, --month-sort            compare (unknown) < 'JAN' < ... < 'DEC'\n");
    fputs_unlocked(v13, v12);
    v14 = stdout;
    v15 = gettext("  -h, --human-numeric-sort    compare human readable numbers (e.g., 2K 1G)\n");
    fputs_unlocked(v15, v14);
    v16 = stdout;
    v17 = gettext(
            "  -n, --numeric-sort          compare according to string numerical value\n"
            "  -R, --random-sort           shuffle, but group identical keys.  See shuf(1)\n"
            "      --random-source=FILE    get random bytes from FILE\n"
            "  -r, --reverse               reverse the result of comparisons\n");
    fputs_unlocked(v17, v16);
    v18 = stdout;
    v19 = gettext(
            "      --sort=WORD             sort according to WORD:\n"
            "                                general-numeric -g, human-numeric -h, month -M,\n"
            "                                numeric -n, random -R, version -V\n"
            "  -V, --version-sort          natural sort of (version) numbers within text\n"
            "\n");
    fputs_unlocked(v19, v18);
    v20 = stdout;
    v21 = gettext("Other options:\n\n");
    fputs_unlocked(v21, v20);
    v22 = stdout;
    v23 = gettext(
            "      --batch-size=NMERGE   merge at most NMERGE inputs at once;\n"
            "                            for more use temp files\n");
    fputs_unlocked(v23, v22);
    v24 = stdout;
    v25 = gettext(
            "  -c, --check, --check=diagnose-first  check for sorted input; do not sort\n"
            "  -C, --check=quiet, --check=silent  like -c, but do not report first bad line\n"
            "      --compress-program=PROG  compress temporaries with PROG;\n"
            "                              decompress them with PROG -d\n");
    fputs_unlocked(v25, v24);
    v26 = stdout;
    v27 = gettext(
            "      --debug               annotate the part of the line used to sort,\n"
            "                              and warn about questionable usage to stderr\n"
            "      --files0-from=F       read input from the files specified by\n"
            "                            NUL-terminated names in file F;\n"
            "                            If F is - then read names from standard input\n");
    fputs_unlocked(v27, v26);
    v28 = stdout;
    v29 = gettext(
            "  -k, --key=KEYDEF          sort via a key; KEYDEF gives location and type\n"
            "  -m, --merge               merge already sorted files; do not sort\n");
    fputs_unlocked(v29, v28);
    v30 = stdout;
    v31 = gettext(
            "  -o, --output=FILE         write result to FILE instead of standard output\n"
            "  -s, --stable              stabilize sort by disabling last-resort comparison\n"
            "  -S, --buffer-size=SIZE    use SIZE for main memory buffer\n");
    fputs_unlocked(v31, v30);
    v32 = gettext(
            "  -t, --field-separator=SEP  use SEP instead of non-blank to blank transition\n"
            "  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or %s;\n"
            "                              multiple options specify multiple directories\n"
            "      --parallel=N          change the number of sorts run concurrently to N\n"
            "  -u, --unique              with -c, check for strict ordering;\n"
            "                              without -c, output only the first of an equal run\n");
    printf(v32, "/tmp");
    v33 = stdout;
    v34 = gettext("  -z, --zero-terminated     line delimiter is NUL, not newline\n");
    fputs_unlocked(v34, v33);
    v35 = stdout;
    v36 = gettext("      --help     display this help and exit\n");
    fputs_unlocked(v36, v35);
    v37 = stdout;
    v38 = gettext("      --version  output version information and exit\n");
    fputs_unlocked(v38, v37);
    v39 = stdout;
    v40 = gettext(
            "\n"
            "KEYDEF is F[.C][OPTS][,F[.C][OPTS]] for start and stop position, where F is a\n"
            "field number and C a character position in the field; both are origin 1, and\n"
            "the stop position defaults to the line's end.  If neither -t nor -b is in\n"
            "effect, characters in a field are counted from the beginning of the preceding\n"
            "whitespace.  OPTS is one or more single-letter ordering options [bdfgiMhnRrV],\n"
            "which override global ordering options for that key.  If no key is given, use\n"
            "the entire line as the key.  Use --debug to diagnose incorrect key usage.\n"
            "\n"
            "SIZE may be followed by the following multiplicative suffixes:\n");
    fputs_unlocked(v40, v39);
    v41 = stdout;
    v42 = gettext(
            "% 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, E, Z, Y.\n"
            "\n"
            "*** WARNING ***\n"
            "The locale specified by the environment affects sort order.\n"
            "Set LC_ALL=C to get the traditional sort order that uses\n"
            "native byte values.\n");
    fputs_unlocked(v42, v41);
    sub_804B821("sort");
  }
  exit(status);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 806C334: using guessed type int dword_806C334;

//----- (0804BDBD) --------------------------------------------------------
int __cdecl sub_804BDBD(int a1)
{
  bool v1; // dl
  int result; // eax

  v1 = pthread_sigmask(0, &set, (__sigset_t *)(a1 + 4)) == 0;
  result = a1;
  *(_BYTE *)a1 = v1;
  return result;
}

//----- (0804BDF2) --------------------------------------------------------
int __cdecl sub_804BDF2(unsigned __int8 *a1)
{
  int result; // eax

  result = *a1;
  if ( (_BYTE)result )
    result = pthread_sigmask(2, (const __sigset_t *)(a1 + 4), 0);
  return result;
}

//----- (0804BE22) --------------------------------------------------------
int __cdecl sub_804BE22(int a1, unsigned int a2)
{
  return *(_DWORD *)(a1 + 4) % a2;
}

//----- (0804BE40) --------------------------------------------------------
bool __cdecl sub_804BE40(int a1, int a2)
{
  return *(_DWORD *)(a1 + 4) == *(_DWORD *)(a2 + 4);
}

//----- (0804BE65) --------------------------------------------------------
int __cdecl sub_804BE65(__pid_t pid)
{
  __pid_t v1; // eax
  void *v2; // eax
  bool v3; // zf
  void *v4; // eax
  int stat_loc; // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]

  if ( pid )
    v1 = pid;
  else
    v1 = -1;
  v7 = waitpid(v1, &stat_loc, pid == 0);
  if ( v7 < 0 )
    sub_805B8A3(4);
  if ( v7 > 0 )
  {
    v2 = &loc_804BF10;
    if ( pid > 0 )
      v2 = &loc_804BF38;
    dword_806B234 = (int)v2;
    sub_806185D();
    v3 = (unsigned __int8)sub_804C034(v7) == 0;
    v4 = &loc_804BF38;
    if ( v3 )
      v4 = &loc_804BF9D;
    dword_806B360 = (int)v4;
    sub_8061156();
    if ( stat_loc & 0x7F || (stat_loc & 0xFF00) >> 8 )
      sub_805B8A3(4);
    --dword_806C26C;
  }
  return v7;
}
// 8061156: using guessed type int sub_8061156(void);
// 806185D: using guessed type int sub_806185D(void);
// 806B234: using guessed type int dword_806B234;
// 806B360: using guessed type int dword_806B360;
// 806C26C: using guessed type int dword_806C26C;

//----- (0804BFA7) --------------------------------------------------------
int __cdecl sub_804BFA7(int a1)
{
  void *v1; // eax
  int result; // eax

  if ( !dword_806C268 )
  {
    dword_806C268 = sub_805805C();
    v1 = &loc_804C009;
    if ( dword_806C268 )
      v1 = &loc_804C00E;
    dword_806B2D4 = (int)v1;
    sub_80614AE(47, 0);
    sub_805E2B6();
  }
  *(_BYTE *)(a1 + 8) = 1;
  result = sub_8058CB7((unsigned int *)dword_806C268, a1);
  if ( !result )
    sub_805E2B6();
  return result;
}
// 806B2D4: using guessed type int dword_806B2D4;
// 806C268: using guessed type int dword_806C268;

//----- (0804C034) --------------------------------------------------------
signed int __cdecl sub_804C034(int a1)
{
  int v2; // [esp+1Ch] [ebp-1Ch]
  char v3; // [esp+20h] [ebp-18h]
  int v4; // [esp+24h] [ebp-14h]
  unsigned int v5; // [esp+2Ch] [ebp-Ch]

  v5 = __readgsdword(0x14u);
  v4 = a1;
  v2 = sub_8058D24(dword_806C268, (int)&v3);
  if ( !v2 )
    return 0;
  *(_BYTE *)(v2 + 8) = 2;
  return 1;
}
// 806C268: using guessed type int dword_806C268;

//----- (0804C08E) --------------------------------------------------------
int __cdecl sub_804C08E(__pid_t pid)
{
  int result; // eax

  result = sub_804C034(pid);
  if ( (_BYTE)result )
    result = sub_804BE65(pid);
  return result;
}

//----- (0804C0B0) --------------------------------------------------------
int __fastcall sub_804C0B0(int a1, int a2)
{
  int result; // eax
  bool v3; // zf
  void *v4; // eax

  dword_806B324 = (int)&loc_804C0CD;
  sub_80612C5(a1, a2);
  result = dword_806C26C;
  if ( dword_806C26C > 0 )
  {
    v3 = sub_804BE65(0) == 0;
    v4 = &locret_804C0FF;
    if ( !v3 )
      v4 = &loc_804C0CD;
    dword_806B20C = (int)v4;
    result = sub_806195A();
  }
  return result;
}
// 80612C5: using guessed type int __fastcall sub_80612C5(_DWORD, _DWORD);
// 806195A: using guessed type int sub_806195A(void);
// 806B20C: using guessed type int dword_806B20C;
// 806B324: using guessed type int dword_806B324;
// 806C26C: using guessed type int dword_806C26C;

//----- (0804C101) --------------------------------------------------------
int sub_804C101()
{
  int v0; // edx
  int v1; // ecx

  sub_804BE65(-1);
  return sub_804C0B0(v1, v0);
}

//----- (0804C11A) --------------------------------------------------------
int sub_804C11A()
{
  int result; // eax

  while ( 1 )
  {
    result = dword_806C26C;
    if ( dword_806C26C <= 0 )
      break;
    sub_804BE65(-1);
  }
  return result;
}
// 806C26C: using guessed type int dword_806C26C;

//----- (0804C139) --------------------------------------------------------
int sub_804C139()
{
  int result; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  result = dword_806C264;
  for ( i = dword_806C264; i; i = *(_DWORD *)i )
  {
    unlink((const char *)(i + 9));
    result = *(_DWORD *)i;
  }
  dword_806C264 = 0;
  return result;
}
// 806C264: using guessed type int dword_806C264;

//----- (0804C171) --------------------------------------------------------
int sub_804C171()
{
  char v1; // [esp+1Ch] [ebp-8Ch]

  if ( dword_806C264 )
  {
    sub_804BDBD((int)&v1);
    sub_804C139();
    sub_804BDF2((unsigned __int8 *)&v1);
  }
  return sub_8055D80();
}
// 806C264: using guessed type int dword_806C264;

//----- (0804C1AB) --------------------------------------------------------
int *__cdecl sub_804C1AB(int *a1, char a2)
{
  char *s; // ST30_4
  size_t v3; // eax
  size_t n; // ST34_4
  int *v5; // eax
  int v6; // ecx
  char *v7; // eax
  void *v8; // eax
  int v9; // ST40_4
  int *ptr; // [esp+24h] [ebp-A4h]
  char *dest; // [esp+30h] [ebp-98h]
  int v13; // [esp+34h] [ebp-94h]
  char v14; // [esp+3Ch] [ebp-8Ch]

  s = (char *)*((_DWORD *)::ptr + dword_806C320);
  v3 = strlen(*((const char **)::ptr + dword_806C320));
  n = v3;
  v5 = (int *)sub_805E14D((v3 + 24) & 0xFFFFFFFC);
  ptr = v5;
  dest = (char *)v5 + 9;
  memcpy((char *)v5 + 9, s, n);
  v7 = &dest[n];
  *(_DWORD *)v7 = 1919906607;
  *((_DWORD *)v7 + 1) = 1482184820;
  *((_DWORD *)v7 + 2) = 5789784;
  *ptr = 0;
  ++dword_806C320;
  v8 = &loc_804C299;
  if ( dword_806C320 != dword_806C1CC )
    v8 = &loc_804C2A3;
  dword_806B310 = (int)v8;
  sub_8061339(v6, dword_806C320);
  dword_806C320 = 0;
  sub_804BDBD((int)&v14);
  v13 = sub_805D182((int)dest, 0x80000);
  if ( v13 >= 0 )
  {
    *off_806B434 = (int)ptr;
    off_806B434 = ptr;
  }
  v9 = *__errno_location();
  sub_804BDF2((unsigned __int8 *)&v14);
  *__errno_location() = v9;
  if ( v13 < 0 )
  {
    if ( a2 != 1 || *__errno_location() != 24 )
      sub_805B8A3(4);
    free(ptr);
    ptr = 0;
  }
  *a1 = v13;
  return ptr;
}
// 8061339: using guessed type int __fastcall sub_8061339(_DWORD, _DWORD);
// 806B310: using guessed type int dword_806B310;
// 806B434: using guessed type int *off_806B434;
// 806C1CC: using guessed type int dword_806C1CC;
// 806C320: using guessed type int dword_806C320;

//----- (0804C3B1) --------------------------------------------------------
FILE *__cdecl sub_804C3B1(char *s1, char *modes)
{
  void *v2; // eax
  bool v3; // zf
  int v4; // edx
  int v5; // ecx
  void *v6; // eax
  FILE *stream; // ST20_4
  int v9; // [esp+0h] [ebp-28h]
  int v10; // [esp+4h] [ebp-24h]

  v2 = &loc_804C3DC;
  if ( *modes != 114 )
    v2 = &loc_804C46D;
  dword_806B2D4 = (int)v2;
  sub_80614AE(v9, v10);
  v3 = strcmp(s1, "-") == 0;
  v6 = &loc_804C40C;
  if ( !v3 )
    v6 = &loc_804C41D;
  dword_806B310 = (int)v6;
  sub_8061339(v5, v4);
  byte_806C1D7 = 1;
  stream = (FILE *)stdin;
  sub_8057124((FILE *)stdin, 2);
  return stream;
}
// 8061339: using guessed type int __fastcall sub_8061339(_DWORD, _DWORD);
// 806B2D4: using guessed type int dword_806B2D4;
// 806B310: using guessed type int dword_806B310;
// 806B500: using guessed type int stdin;
// 806C1D7: using guessed type char byte_806C1D7;

//----- (0804C51F) --------------------------------------------------------
FILE *__cdecl sub_804C51F(char *s1, char *modes)
{
  char *v2; // eax
  FILE *v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_804C3B1(s1, modes);
  if ( !v4 )
  {
    v2 = gettext("open failed");
    sub_804BA86((int)v2, (int)s1);
  }
  return v4;
}

//----- (0804C560) --------------------------------------------------------
void __cdecl sub_804C560(FILE *stream, int a2)
{
  int v2; // eax
  bool v3; // zf
  void *v4; // eax
  char *v5; // eax

  v2 = fileno(stream);
  if ( v2 )
  {
    v3 = v2 == 1;
    v4 = &loc_804C593;
    if ( v3 )
      v4 = &loc_804C5B3;
    dword_806B220 = (int)v4;
    sub_80618EC();
    if ( sub_805F101(stream) )
    {
      v5 = gettext("close failed");
      sub_804BA86((int)v5, a2);
    }
  }
  else if ( feof_unlocked(stream) )
  {
    clearerr_unlocked(stream);
  }
}
// 80618EC: using guessed type int sub_80618EC(void);
// 806B220: using guessed type int dword_806B220;

//----- (0804C624) --------------------------------------------------------
int __usercall sub_804C624@<eax>(int a1@<edx>, int a2@<ecx>, int fd, int fd2)
{
  void *v4; // eax

  v4 = &loc_804C64B;
  if ( fd == fd2 )
    v4 = &locret_804C668;
  dword_806B270 = (int)v4;
  sub_80616F6(a2, a1);
  dup2(fd, fd2);
  return close(fd);
}
// 80616F6: using guessed type int __fastcall sub_80616F6(_DWORD, _DWORD);
// 806B270: using guessed type int dword_806B270;

//----- (0804C66A) --------------------------------------------------------
__pid_t __cdecl sub_804C66A(int pipedes[2], int a2)
{
  int v2; // edx
  int v3; // ecx
  bool v4; // zf
  void *v5; // eax
  int v6; // edx
  int v7; // ecx
  int v8; // eax
  __pid_t v10; // [esp+14h] [ebp-A4h]
  int v11; // [esp+18h] [ebp-A0h]
  int v12; // [esp+1Ch] [ebp-9Ch]
  double v13; // [esp+20h] [ebp-98h]
  char v14; // [esp+2Ch] [ebp-8Ch]

  v13 = 0.25;
  if ( sub_8059BF8(pipedes, 0x80000) < 0 )
  {
    dword_806B324 = (int)&locret_804C814;
    sub_80612C5(v3, v2);
  }
  if ( dword_806B430 + 1 < (unsigned int)dword_806C26C )
    sub_804C101();
  while ( 1 )
  {
    v8 = a2--;
    if ( !v8 )
      break;
    sub_804BDBD((int)&v14);
    v11 = dword_806C264;
    dword_806C264 = 0;
    v10 = fork();
    v12 = *__errno_location();
    if ( v10 )
      dword_806C264 = v11;
    sub_804BDF2((unsigned __int8 *)&v14);
    *__errno_location() = v12;
    if ( v10 >= 0 )
      break;
    v4 = *__errno_location() == 11;
    v5 = &loc_804C76A;
    if ( !v4 )
      v5 = &loc_804C79C;
    dword_806B284 = (int)v5;
    sub_8061686();
    sub_805E4A4(v13);
    v13 = v13 + v13;
    sub_804C0B0(v7, v6);
  }
  if ( v10 >= 0 )
  {
    if ( v10 )
    {
      ++dword_806C26C;
    }
    else
    {
      close(0);
      close(1);
    }
  }
  else
  {
    v12 = *__errno_location();
    close(*pipedes);
    close(pipedes[1]);
    *__errno_location() = v12;
  }
  return v10;
}
// 80612C5: using guessed type int __fastcall sub_80612C5(_DWORD, _DWORD);
// 8061686: using guessed type int sub_8061686(void);
// 806B284: using guessed type int dword_806B284;
// 806B324: using guessed type int dword_806B324;
// 806C264: using guessed type int dword_806C264;
// 806C26C: using guessed type int dword_806C26C;

//----- (0804C816) --------------------------------------------------------
int __cdecl sub_804C816(FILE **a1, char a2)
{
  __pid_t v3; // eax
  int v4; // edx
  int v5; // ecx
  int v6; // edx
  int v7; // ecx
  int *v8; // eax
  void *v9; // eax
  int v10; // ebx
  char *v11; // eax
  int v12; // [esp+Ch] [ebp-1Ch]
  int fd; // [esp+10h] [ebp-18h]
  int *v14; // [esp+14h] [ebp-14h]
  int pipedes[2]; // [esp+18h] [ebp-10h]

  LOBYTE(v12) = a2;
  v14 = sub_804C1AB(&fd, a2);
  if ( v14 )
  {
    *((_BYTE *)v14 + 8) = 0;
    if ( arg )
    {
      v3 = sub_804C66A(pipedes, 4);
      v14[1] = v3;
      if ( v14[1] <= 0 )
      {
        if ( !v14[1] )
        {
          close(pipedes[1]);
          sub_804C624(v4, v5, fd, 1);
          sub_804C624(v6, v7, pipedes[0], 0);
          execlp(arg, arg, 0, v12);
          v8 = __errno_location();
          sub_804B9A7(*v8, "couldn't execute compress program");
        }
      }
      else
      {
        close(fd);
        close(pipedes[0]);
        fd = pipedes[1];
        sub_804BFA7((int)v14);
      }
    }
    *a1 = fdopen(fd, "w");
    v9 = &loc_804C954;
    if ( *a1 )
      v9 = &loc_804C972;
    dword_806B2FC = (int)v9;
    sub_80613B1();
    v10 = (int)v14 + 9;
    v11 = gettext("couldn't create temporary file");
    sub_804BA86((int)v11, v10);
  }
  return 0;
}
// 806B2FC: using guessed type int dword_806B2FC;

//----- (0804C97B) --------------------------------------------------------
int __cdecl sub_804C97B(FILE **a1)
{
  return sub_804C816(a1, 0);
}

//----- (0804C996) --------------------------------------------------------
FILE *__cdecl sub_804C996(int a1)
{
  __pid_t v2; // eax
  int v3; // edx
  int v4; // ecx
  int v5; // edx
  int v6; // ecx
  int *v7; // eax
  FILE *v8; // eax
  int v9; // ST24_4
  int v10; // ST00_4
  int v11; // [esp+4h] [ebp-34h]
  FILE *v12; // [esp+18h] [ebp-20h]
  int fd; // [esp+1Ch] [ebp-1Ch]
  int pipedes[2]; // [esp+28h] [ebp-10h]

  v12 = 0;
  if ( *(_BYTE *)(a1 + 8) == 1 )
    sub_804C08E(*(_DWORD *)(a1 + 4));
  fd = open64(a1 + 9, 0);
  if ( fd < 0 )
    return 0;
  v2 = sub_804C66A(pipedes, 9);
  if ( v2 == -1 )
  {
    if ( *__errno_location() != 24 )
      sub_805B8A3(4);
    close(fd);
    *__errno_location() = 24;
  }
  else
  {
    if ( !v2 )
    {
      close(pipedes[0]);
      sub_804C624(v3, v4, fd, 0);
      sub_804C624(v5, v6, pipedes[1], 1);
      execlp(arg, arg, "-d", 0);
      v7 = __errno_location();
      sub_804B9A7(*v7, "couldn't execute compress program (with -d)");
    }
    *(_DWORD *)(a1 + 4) = v2;
    sub_804BFA7(a1);
    close(fd);
    close(pipedes[1]);
    v8 = fdopen(pipedes[0], "r");
    v12 = v8;
    if ( !v8 )
    {
      v9 = *__errno_location();
      close(pipedes[0]);
      *__errno_location() = v9;
      dword_806B2D4 = (int)&loc_804CB64;
      sub_80614AE(v10, v11);
    }
  }
  return v12;
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 806B2D4: using guessed type int dword_806B2D4;

//----- (0804CB6E) --------------------------------------------------------
int __cdecl sub_804CB6E(int a1)
{
  int v1; // eax
  _DWORD *v2; // edx
  int result; // eax

  if ( dword_806C1CC == dword_806C1D0 )
    ptr = sub_805E08A(ptr, (int)&dword_806C1D0, 4);
  v1 = dword_806C1CC++;
  v2 = (char *)ptr + 4 * v1;
  result = a1;
  *v2 = a1;
  return result;
}
// 806C1CC: using guessed type int dword_806C1CC;
// 806C1D0: using guessed type int dword_806C1D0;

//----- (0804CBC6) --------------------------------------------------------
void __usercall sub_804CBC6(int a1@<edx>, int a2@<ecx>, char *name)
{
  int v3; // ST28_4
  int errnum; // ST1C_4
  int *v5; // [esp+18h] [ebp-A0h]
  int *ptr; // [esp+20h] [ebp-98h]
  int v7; // [esp+24h] [ebp-94h]
  char v8; // [esp+2Ch] [ebp-8Ch]

  dword_806B270 = (int)&loc_804CC07;
  sub_80616F6(a2, a1);
  do
  {
    v5 = ptr;
    ptr = (int *)*ptr;
  }
  while ( (char *)ptr + 9 != name );
  if ( *((_BYTE *)ptr + 8) == 1 )
    sub_804C08E(ptr[1]);
  v7 = *ptr;
  sub_804BDBD((int)&v8);
  v3 = unlink(name);
  errnum = *__errno_location();
  *v5 = v7;
  sub_804BDF2((unsigned __int8 *)&v8);
  if ( v3 )
    sub_805B9FE(0, 3);
  if ( !v7 )
    off_806B434 = v5;
  free(ptr);
}
// 80616F6: using guessed type int __fastcall sub_80616F6(_DWORD, _DWORD);
// 806B270: using guessed type int dword_806B270;
// 806B434: using guessed type int *off_806B434;

//----- (0804CD13) --------------------------------------------------------
int __cdecl compar(const void *a1, const void *a2)
{
  return strcmp(*(const char **)a1, *(const char **)a2);
}

//----- (0804CD3D) --------------------------------------------------------
void sub_804CD3D()
{
  bool v0; // zf
  void *v1; // eax
  const unsigned __int16 *v2; // ebx
  int v3; // eax
  unsigned int c; // [esp+18h] [ebp-20h]
  unsigned int ca; // [esp+18h] [ebp-20h]
  size_t i; // [esp+1Ch] [ebp-1Ch]
  int v7; // [esp+20h] [ebp-18h]
  const char *s; // [esp+24h] [ebp-14h]
  size_t v9; // [esp+28h] [ebp-10h]
  char *v10; // [esp+2Ch] [ebp-Ch]

  for ( c = 0; c <= 0xFF; ++c )
  {
    *(_BYTE *)(c + 134659524) = sub_804B746(c);
    *(_BYTE *)(c + 134659780) = ((*__ctype_b_loc())[c] & 0x4000) == 0;
    v0 = ((*__ctype_b_loc())[c] & 8) == 0;
    v1 = &loc_804CDC5;
    if ( !v0 )
      v1 = &loc_804CDE1;
    dword_806B2FC = (int)v1;
    sub_80613B1();
    *(_BYTE *)(c + 134660036) = (unsigned __int8)sub_804B746(c) != 1;
    *(_BYTE *)(c + 134660292) = toupper(c);
  }
  if ( byte_806BDAD )
  {
    for ( ca = 0; ca <= 0xB; ++ca )
    {
      s = nl_langinfo(ca + 131086);
      v9 = strlen(s);
      v10 = (char *)sub_805E14D(v9 + 1);
      (&off_806B3C8)[2 * ca] = v10;
      dword_806B3CC[2 * ca] = ca + 1;
      v7 = 0;
      for ( i = 0; i < v9; ++i )
      {
        v2 = *__ctype_b_loc();
        if ( !(v2[(unsigned __int8)sub_804B734(s[i])] & 1) )
        {
          v3 = v7++;
          v10[v3] = byte_806C0C4[(unsigned __int8)sub_804B734(s[i])];
        }
      }
      v10[v7] = 0;
    }
    qsort(&off_806B3C8, 0xCu, 8u, compar);
  }
}
// 806B2FC: using guessed type int dword_806B2FC;
// 806B3C8: using guessed type char *off_806B3C8;
// 806B3CC: using guessed type int dword_806B3CC[];
// 806BDAD: using guessed type char byte_806BDAD;

//----- (0804CF47) --------------------------------------------------------
unsigned int __usercall sub_804CF47@<eax>(int edx0@<edx>, int ecx0@<ecx>, int a1, char a2, char *a3)
{
  int v5; // eax
  void *v6; // ebx
  int v7; // esi
  char *v8; // eax
  void *v9; // ebx
  int v10; // esi
  char *v11; // eax
  void *v13; // ebx
  int v14; // esi
  char *v15; // eax
  int v16; // ebx
  int v17; // esi
  char *v18; // eax
  int v19; // [esp+Ch] [ebp-4Ch]
  int v20; // [esp+10h] [ebp-48h]
  char *nptr; // [esp+18h] [ebp-40h]
  char v22; // [esp+1Ch] [ebp-3Ch]
  int v23; // [esp+20h] [ebp-38h]
  unsigned int v24; // [esp+24h] [ebp-34h]
  __int64 v25; // [esp+28h] [ebp-30h]
  int v26; // [esp+30h] [ebp-28h]
  char v27; // [esp+41h] [ebp-17h]
  unsigned int v28; // [esp+4Ch] [ebp-Ch]

  v22 = a2;
  nptr = a3;
  v28 = __readgsdword(0x14u);
  v23 = sub_805EC32(edx0, ecx0, a3, 0, 10, (int)&v25, 0);
  if ( getrlimit64(7, &v26) )
    v5 = 17;
  else
    v5 = v26 - 3;
  v24 = v5;
  if ( v23 )
    goto LABEL_12;
  dword_806B430 = v25;
  if ( v25 != (unsigned int)v25 )
  {
    v23 = 1;
    dword_806B2C0 = (int)&loc_804D0D1;
    sub_8061526();
  }
  if ( (unsigned int)dword_806B430 <= 1 )
  {
    v6 = sub_805BC36(nptr);
    v7 = *((_DWORD *)&longopts.name + 4 * a1);
    v8 = gettext("invalid --%s argument %s");
    v20 = (int)v6;
    v19 = v7;
    error(0, 0, v8, v7, v6);
    v9 = sub_805BC36("2");
    v10 = *((_DWORD *)&longopts.name + 4 * a1);
    v11 = gettext("minimum --%s argument is %s");
    v20 = (int)v9;
    v19 = v10;
    error(2, 0, v11, v10, v9);
  }
  if ( v24 < dword_806B430 )
  {
    v23 = 1;
LABEL_12:
    if ( v23 == 1 )
    {
      v13 = sub_805BC36(nptr);
      v14 = *((_DWORD *)&longopts.name + 4 * a1);
      v15 = gettext("--%s argument %s too large");
      v20 = (int)v13;
      v19 = v14;
      error(0, 0, v15, v14, v13);
      v16 = sub_8059380(v24, (int)&v27);
      v17 = *((_DWORD *)&longopts.name + 4 * a1);
      v18 = gettext("maximum --%s argument with current rlimit is %s");
      v20 = v16;
      v19 = v17;
      error(2, 0, v18, v17, v16);
    }
    sub_805EB2D(v23, a1, v22, (int)&longopts, (int)nptr);
  }
  return __readgsdword(0x14u) ^ v28;
}
// 8049920: using guessed type int __cdecl getrlimit64(_DWORD, _DWORD);
// 8061526: using guessed type int sub_8061526(void);
// 806B2C0: using guessed type int dword_806B2C0;

//----- (0804D1A3) --------------------------------------------------------
unsigned __int64 __usercall sub_804D1A3@<edx:eax>(int edx0@<edx>, int ecx0@<ecx>, int a1, int a2, char *nptr)
{
  void *v5; // eax
  int v6; // eax
  unsigned __int64 v7; // rax
  unsigned __int64 result; // rax
  int v9; // eax
  int v10; // [esp+0h] [ebp-68h]
  int v11; // [esp+4h] [ebp-64h]
  int v12; // [esp+38h] [ebp-30h]
  int v13; // [esp+3Ch] [ebp-2Ch]
  unsigned __int64 v14; // [esp+40h] [ebp-28h]
  double v15; // [esp+48h] [ebp-20h]

  v13 = sub_805EC32(edx0, ecx0, nptr, (int)&v12, 10, (int)&v14, "EgGkKmMPtTYZ");
  if ( !v13 && (unsigned int)(*(char *)(v12 - 1) - 48) <= 9 )
  {
    if ( HIDWORD(v14) > 0x3FFFFF )
      v13 = 1;
    else
      v14 <<= 10;
  }
  v5 = &loc_804D241;
  if ( v13 != 2 )
    v5 = &loc_804D354;
  dword_806B2D4 = (int)v5;
  sub_80614AE(v10, v11);
  if ( (unsigned int)(*(char *)(v12 - 1) - 48) <= 9 && !*(_BYTE *)(v12 + 1) )
  {
    v6 = *(char *)v12;
    if ( v6 == 37 )
    {
      v15 = sub_8059A6F() * (double)v14 / 100.0;
      if ( v15 >= 1.844674407370955e19 )
      {
        v13 = 1;
      }
      else
      {
        if ( v15 >= 9.223372036854776e18 )
          v7 = (signed __int64)(v15 - 9.223372036854776e18) ^ 0x8000000000000000LL;
        else
          v7 = (signed __int64)v15;
        v14 = v7;
        v13 = 0;
      }
    }
    else if ( v6 == 98 )
    {
      v13 = 0;
    }
  }
  if ( v13 )
LABEL_26:
    sub_805EB2D(v13, a1, a2, (int)&longopts, (int)nptr);
  result = v14;
  if ( size <= v14 )
  {
    size = v14;
    if ( v14 == (unsigned int)v14 )
    {
      v9 = size;
      if ( 18 * dword_806B430 >= size )
        v9 = 18 * dword_806B430;
      size = v9;
      dword_806B270 = (int)&loc_804D411;
      sub_80616F6(v14, 18 * dword_806B430);
    }
    v13 = 1;
    goto LABEL_26;
  }
  return result;
}
// 80616F6: using guessed type int __fastcall sub_80616F6(_DWORD, _DWORD);
// 806B270: using guessed type int dword_806B270;
// 806B2D4: using guessed type int dword_806B2D4;

//----- (0804D419) --------------------------------------------------------
int __cdecl sub_804D419(int a1, int a2, char *nptr)
{
  int v3; // eax
  int v4; // edx
  int v5; // ecx
  bool v6; // zf
  void *v7; // eax
  int v9; // [esp+28h] [ebp-10h]
  int v10; // [esp+2Ch] [ebp-Ch]

  v3 = sub_805E5D3(nptr, 0, 10, (int)&v9, &s);
  v10 = v3;
  v6 = v3 == 1;
  v7 = &loc_804D471;
  if ( !v6 )
    v7 = &loc_804D478;
  dword_806B324 = (int)v7;
  sub_80612C5(v5, v4);
  return -1;
}
// 80612C5: using guessed type int __fastcall sub_80612C5(_DWORD, _DWORD);
// 806B324: using guessed type int dword_806B324;

//----- (0804D4D7) --------------------------------------------------------
int sub_804D4D7()
{
  long double v0; // fst7
  int result; // eax
  unsigned int v2; // [esp+24h] [ebp-34h]
  unsigned int v3; // [esp+24h] [ebp-34h]
  double v4; // [esp+28h] [ebp-30h]
  double v5; // [esp+30h] [ebp-28h]
  double v6; // [esp+38h] [ebp-20h]
  unsigned __int64 v7; // [esp+40h] [ebp-18h]

  v2 = -1;
  if ( !getrlimit64(2, &v7) && v7 < 0xFFFFFFFF )
    v2 = v7;
  if ( !getrlimit64(9, &v7) && v7 < v2 )
    v2 = v7;
  v3 = v2 >> 1;
  if ( !getrlimit64(5, &v7) && 15 * (v7 >> 4) < v3 )
    v3 = 15 * (v7 >> 4);
  v4 = sub_8059B31();
  v5 = sub_8059A6F();
  if ( v4 <= v5 / 8.0 )
    v0 = v5 / 8.0;
  else
    v0 = v4;
  v6 = v0;
  if ( (long double)v3 > v5 * 0.75 )
    v3 = (signed __int64)(v5 * 0.75);
  if ( (long double)v3 > v6 )
    v3 = (signed __int64)v6;
  result = v3;
  if ( 18 * dword_806B430 >= v3 )
    result = 18 * dword_806B430;
  return result;
}
// 8049920: using guessed type int __cdecl getrlimit64(_DWORD, _DWORD);

//----- (0804D6A6) --------------------------------------------------------
int __cdecl sub_804D6A6(int a1, unsigned int a2, int a3, unsigned int a4, int a5)
{
  int v5; // eax
  bool v6; // al
  int v7; // ebx
  char *v8; // eax
  void *v9; // eax
  void *v10; // eax
  FILE *v12; // [esp+0h] [ebp-98h]
  int v13; // [esp+18h] [ebp-80h]
  unsigned int i; // [esp+1Ch] [ebp-7Ch]
  unsigned int v15; // [esp+20h] [ebp-78h]
  unsigned int v16; // [esp+24h] [ebp-74h]
  __int64 v17; // [esp+28h] [ebp-70h]
  char v18; // [esp+30h] [ebp-68h]
  int v19; // [esp+40h] [ebp-58h]
  __int64 v20; // [esp+5Ch] [ebp-3Ch]

  v15 = a5 + 1;
  v13 = a5 + 2;
  for ( i = 0; i < a4; ++i )
  {
    if ( i >= a2 )
    {
      if ( !strcmp(*(const char **)(4 * i + a3), "-") )
        v6 = sub_8061048(0, (int)&v18) != 0;
      else
        v6 = sub_8061019(*(_DWORD *)(4 * i + a3), (int)&v18) != 0;
    }
    else
    {
      v12 = *(FILE **)(4 * i + a1);
      v5 = fileno(v12);
      v6 = sub_8061048(v5, (int)&v18) != 0;
    }
    if ( v6 )
    {
      v7 = *(_DWORD *)(4 * i + a3);
      v8 = gettext("stat failed");
      sub_804BA86((int)v8, v7);
    }
    if ( (v19 & 0xF000) == 0x8000 )
    {
      v17 = v20;
    }
    else
    {
      v9 = &loc_804D7D5;
      if ( !size )
        v9 = &loc_804D7F1;
      dword_806B234 = (int)v9;
      sub_806185D();
      dword_806B298 = (int)&loc_804D8AB;
      sub_8061616();
      v17 = 0x20000LL;
    }
    v10 = &loc_804D821;
    if ( dword_806C324 )
      v10 = &loc_804D83E;
    dword_806B20C = (int)v10;
    sub_806195A();
    dword_806C324 = size;
    if ( !size )
      dword_806C324 = sub_804D4D7();
    v16 = v15 * v17 + 1;
    if ( v17 != v16 / v15 || dword_806C324 - v13 <= v16 )
    {
      dword_806B2AC = (int)&loc_804D8AB;
      sub_806159C(HIDWORD(v17), 0);
    }
    v13 += v16;
  }
  return v13;
}
// 806159C: using guessed type int __fastcall sub_806159C(_DWORD, _DWORD);
// 8061616: using guessed type int sub_8061616(void);
// 806185D: using guessed type int sub_806185D(void);
// 806195A: using guessed type int sub_806195A(void);
// 806B20C: using guessed type int dword_806B20C;
// 806B234: using guessed type int dword_806B234;
// 806B298: using guessed type int dword_806B298;
// 806B2AC: using guessed type int dword_806B2AC;
// 806C324: using guessed type int dword_806C324;

//----- (0804D8B4) --------------------------------------------------------
void __cdecl __noreturn sub_804D8B4(int a1, int a2, size_t size)
{
  size_t sizea; // [esp+28h] [ebp+10h]

  while ( 1 )
  {
    sizea = (size & 0xFFFFFFF0) + 16;
    *(_DWORD *)a1 = malloc(sizea);
    if ( *(_DWORD *)a1 )
    {
      dword_806B20C = (int)sub_804D912;
      sub_806195A();
    }
    size = sizea >> 1;
    if ( a2 + 1 >= size )
      sub_805E2B6();
  }
}
// 804D912: using guessed type int sub_804D912();
// 806195A: using guessed type int sub_806195A(void);
// 806B20C: using guessed type int dword_806B20C;

//----- (0804D912) --------------------------------------------------------
#error "804D94E: positive sp value has been found (funcsize=0)"

//----- (0804D94F) --------------------------------------------------------
int __cdecl sub_804D94F(_DWORD *a1)
{
  return *a1 + a1[3];
}

//----- (0804D96A) --------------------------------------------------------
int __cdecl sub_804D96A(char **a1, int a2)
{
  int v2; // ecx
  int v3; // edx
  void *v4; // eax
  int v5; // eax
  int result; // eax
  int v7; // [esp+0h] [ebp-14h]
  char *v8; // [esp+4h] [ebp-10h]
  int v9; // [esp+8h] [ebp-Ch]
  unsigned int v10; // [esp+Ch] [ebp-8h]
  int v11; // [esp+10h] [ebp-4h]

  v8 = *a1;
  v3 = (int)(a1[1] - 1);
  v10 = (unsigned int)&v8[v3];
  v9 = *(_DWORD *)a2;
  v11 = *(_DWORD *)(a2 + 4);
  v4 = &loc_804D9BF;
  if ( dword_806B42C == 128 )
    v4 = &loc_804DA32;
  dword_806B270 = (int)v4;
  sub_80616F6(v2, v3);
  dword_806B20C = (int)&loc_804DA17;
  sub_806195A();
  do
  {
    dword_806B20C = (int)&loc_804D9F1;
    sub_806195A();
    do
      ++v8;
    while ( (unsigned int)v8 < v10 && *v8 != dword_806B42C );
    if ( (unsigned int)v8 < v10 )
      ++v8;
    if ( (unsigned int)v8 >= v10 )
      break;
    v5 = v9--;
  }
  while ( v5 );
  if ( *(_BYTE *)(a2 + 24) )
  {
    while ( (unsigned int)v8 < v10 )
    {
      v7 = *v8;
      if ( !byte_806BDC4[(unsigned __int8)sub_804B734(v7)] )
        break;
      ++v8;
    }
  }
  result = v10;
  if ( (unsigned int)&v8[v11] <= v10 )
    result = (int)&v8[v11];
  return result;
}
// 80616F6: using guessed type int __fastcall sub_80616F6(_DWORD, _DWORD);
// 806195A: using guessed type int sub_806195A(void);
// 806B20C: using guessed type int dword_806B20C;
// 806B270: using guessed type int dword_806B270;
// 806B42C: using guessed type int dword_806B42C;

//----- (0804DAF6) --------------------------------------------------------
char *__cdecl sub_804DAF6(char **a1, int a2)
{
  int v2; // eax
  bool v3; // zf
  void *v4; // eax
  int v5; // eax
  int v6; // eax
  char *v7; // eax
  int v9; // [esp+0h] [ebp-14h]
  char *v10; // [esp+4h] [ebp-10h]
  int v11; // [esp+8h] [ebp-Ch]
  char *v12; // [esp+Ch] [ebp-8h]
  int v13; // [esp+10h] [ebp-4h]

  v10 = *a1;
  v12 = &v10[(_DWORD)(a1[1] - 1)];
  v11 = *(_DWORD *)(a2 + 8);
  v2 = *(_DWORD *)(a2 + 12);
  v13 = v2;
  v3 = v2 == 0;
  v4 = &loc_804DB46;
  if ( !v3 )
    v4 = &loc_804DB4A;
  dword_806B298 = (int)v4;
  sub_8061616();
  ++v11;
  if ( dword_806B42C == 128 )
  {
    dword_806B234 = (int)&loc_804DC37;
    sub_806185D();
    do
    {
      dword_806B2D4 = (int)&loc_804DBE0;
      sub_80614AE(v9, v10);
      do
      {
        if ( ++v10 >= v12 )
          break;
        v9 = *v10;
      }
      while ( byte_806BDC4[(unsigned __int8)sub_804B734(v9)] );
      while ( v10 < v12 )
      {
        v9 = *v10;
        if ( !((unsigned __int8)byte_806BDC4[(unsigned __int8)sub_804B734(v9)] ^ 1) )
          break;
        ++v10;
      }
      if ( v10 >= v12 )
        break;
      v6 = v11--;
    }
    while ( v6 );
  }
  else
  {
    while ( v10 < v12 )
    {
      v5 = v11--;
      if ( !v5 )
        break;
      while ( v10 < v12 && *v10 != dword_806B42C )
        ++v10;
      if ( v10 < v12 && (v11 || v13) )
        ++v10;
    }
  }
  if ( v13 )
  {
    if ( *(_BYTE *)(a2 + 25) )
    {
      while ( v10 < v12 )
      {
        v9 = *v10;
        if ( !byte_806BDC4[(unsigned __int8)sub_804B734(v9)] )
          break;
        ++v10;
      }
    }
    v7 = v12;
    if ( &v10[v13] <= v12 )
      v7 = &v10[v13];
    v10 = v7;
  }
  return v10;
}
// 8061616: using guessed type int sub_8061616(void);
// 806185D: using guessed type int sub_806185D(void);
// 806B234: using guessed type int dword_806B234;
// 806B298: using guessed type int dword_806B298;
// 806B2D4: using guessed type int dword_806B2D4;
// 806B42C: using guessed type int dword_806B42C;

//----- (0804DCA6) --------------------------------------------------------
int __cdecl sub_804DCA6(int a1)
{
  int v1; // ST44_4
  void *v2; // eax

  v1 = *(_DWORD *)(a1 + 20);
  v2 = &loc_804DCF8;
  if ( !*(_BYTE *)(a1 + 24) )
    v2 = &loc_804DD02;
  dword_806B234 = (int)v2;
  sub_806185D();
  return 0;
}
// 806185D: using guessed type int sub_806185D(void);
// 806B234: using guessed type int dword_806B234;
// 806C1D8: using guessed type int dword_806C1D8;

//----- (0804E0EA) --------------------------------------------------------
int __cdecl sub_804E0EA(char **a1)
{
  int v1; // edx
  char *v2; // eax
  void *v3; // eax
  unsigned __int8 v5; // [esp+9h] [ebp-7h]
  bool v6; // [esp+Ah] [ebp-6h]
  char *v7; // [esp+Ch] [ebp-4h]

  v7 = *a1;
  v5 = 0;
  v6 = 0;
  while ( 1 )
  {
    v2 = v7++;
    if ( (unsigned int)(unsigned __int8)*v2 - 48 > 9 )
      break;
    if ( v5 < (unsigned __int8)*v2 )
      v5 = *v2;
    v1 = *v7;
    v6 = v1 == dword_806BDA8;
    if ( v1 == dword_806BDA8 )
      ++v7;
  }
  v3 = &loc_804E16C;
  if ( !v6 )
    v3 = &loc_804E17D;
  dword_806B234 = (int)v3;
  sub_806185D();
  *a1 = v7 - 2;
  return v5;
}
// 806185D: using guessed type int sub_806185D(void);
// 806B234: using guessed type int dword_806B234;
// 806BDA8: using guessed type int dword_806BDA8;

//----- (0804E1E1) --------------------------------------------------------
int __cdecl sub_804E1E1(_BYTE *a1)
{
  bool v2; // [esp+9h] [ebp-Bh]
  unsigned __int8 v3; // [esp+Ah] [ebp-Ah]
  unsigned __int8 v4; // [esp+Bh] [ebp-9h]
  char *v5; // [esp+Ch] [ebp-8h]
  int v6; // [esp+10h] [ebp-4h]

  v2 = *a1 == 45;
  v5 = &a1[v2];
  v3 = sub_804E0EA(&v5);
  if ( v3 > 0x30u )
  {
    v4 = *v5;
    v6 = byte_8063248[v4];
    dword_806B374 = (int)&locret_804E25B;
    sub_80610EA();
  }
  return 0;
}
// 80610EA: using guessed type int sub_80610EA(void);
// 806B374: using guessed type int dword_806B374;

//----- (0804E25D) --------------------------------------------------------
int __cdecl sub_804E25D(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v2; // ebx
  int v3; // eax
  int v4; // edx
  int v5; // ecx
  bool v6; // zf
  void *v7; // eax
  int v8; // edx
  int v9; // ecx
  int v11; // [esp+1Ch] [ebp-Ch]

  while ( byte_806BDC4[(unsigned __int8)sub_804B734(*a1)] )
    ++a1;
  while ( byte_806BDC4[(unsigned __int8)sub_804B734(*a2)] )
    ++a2;
  v2 = sub_804E1E1(a1);
  v3 = sub_804E1E1(a2);
  v11 = v2 - v3;
  v6 = v2 == v3;
  v7 = &loc_804E2EC;
  if ( !v6 )
    v7 = &loc_804E328;
  dword_806B2E8 = (int)v7;
  sub_8061429(v5, v4);
  sub_805D902((char *)a1, (char *)a2, dword_806BDA4, dword_806BDA8);
  dword_806B34C = (int)&loc_804E32B;
  sub_80611C6(v9, v8);
  return v11;
}
// 80611C6: using guessed type int __fastcall sub_80611C6(_DWORD, _DWORD);
// 8061429: using guessed type int __fastcall sub_8061429(_DWORD, _DWORD);
// 806B2E8: using guessed type int dword_806B2E8;
// 806B34C: using guessed type int dword_806B34C;
// 806BDA4: using guessed type int dword_806BDA4;
// 806BDA8: using guessed type int dword_806BDA8;

//----- (0804E331) --------------------------------------------------------
int __cdecl sub_804E331(unsigned __int8 *a1, int a2)
{
  bool v2; // zf
  void *v3; // eax
  int v5; // [esp+0h] [ebp-18h]
  char *v6; // [esp+24h] [ebp+Ch]

  while ( byte_806BDC4[(unsigned __int8)sub_804B734(*a1)] )
    ++a1;
  dword_806B20C = (int)&loc_804E377;
  sub_806195A();
  v6 = (char *)(a2 + 1);
  v5 = *v6;
  v2 = byte_806BDC4[(unsigned __int8)sub_804B734(v5)] == 0;
  v3 = &loc_804E3AF;
  if ( !v2 )
    v3 = &loc_804E373;
  dword_806B2C0 = (int)v3;
  sub_8061526();
  return sub_805D902((char *)a1, v6, dword_806BDA4, dword_806BDA8);
}
// 8061526: using guessed type int sub_8061526(void);
// 806195A: using guessed type int sub_806195A(void);
// 806B20C: using guessed type int dword_806B20C;
// 806B2C0: using guessed type int dword_806B2C0;
// 806BDA4: using guessed type int dword_806BDA4;
// 806BDA8: using guessed type int dword_806BDA8;

//----- (0804E3D6) --------------------------------------------------------
int __cdecl sub_804E3D6(int a1, int a2)
{
  _TBYTE s; // [esp+10h] [ebp-28h]
  _TBYTE s2; // [esp+20h] [ebp-18h]

  memset(&s, 0, 0xCu);
  *(long double *)&s = strtold(a1, 0);
  memset(&s2, 0, 0xCu);
  *(long double *)&s2 = strtold(a2, 0);
  return memcmp(&s, &s2, 0xCu);
}
// 80498F0: using guessed type double __cdecl strtold(_DWORD, _DWORD);

//----- (0804E45A) --------------------------------------------------------
signed int __cdecl sub_804E45A(int a1, int a2)
{
  signed int result; // eax
  void *v3; // eax
  int v4; // [esp+18h] [ebp-30h]
  int v5; // [esp+1Ch] [ebp-2Ch]
  long double v6; // [esp+20h] [ebp-28h]
  long double v7; // [esp+30h] [ebp-18h]

  v6 = strtold(a1, &v4);
  v7 = strtold(a2, &v5);
  if ( a1 == v4 )
  {
    if ( a2 == v5 )
      result = 0;
    else
      result = -1;
  }
  else
  {
    v3 = &loc_804E4CC;
    if ( a2 != v5 )
      v3 = &loc_804E4D6;
    dword_806B248 = (int)v3;
    sub_80617ED();
    result = 1;
  }
  return result;
}
// 80498F0: using guessed type double __cdecl strtold(_DWORD, _DWORD);
// 80617ED: using guessed type int sub_80617ED(void);
// 806B248: using guessed type int dword_806B248;

//----- (0804E5A9) --------------------------------------------------------
int __cdecl sub_804E5A9(unsigned __int8 *a1, unsigned __int8 **a2)
{
  int v2; // eax
  unsigned __int8 v3; // al
  unsigned __int8 v4; // bl
  unsigned __int8 v5; // al
  unsigned __int8 v6; // bl
  unsigned int v8; // [esp+10h] [ebp-18h]
  unsigned int v9; // [esp+14h] [ebp-14h]
  unsigned __int8 *v10; // [esp+18h] [ebp-10h]
  unsigned __int8 *i; // [esp+1Ch] [ebp-Ch]
  unsigned int v12; // [esp+20h] [ebp-8h]

  v8 = 0;
  v9 = 12;
  while ( byte_806BDC4[(unsigned __int8)sub_804B734(*a1)] )
    ++a1;
  do
  {
    v12 = (v8 + v9) >> 1;
    v10 = a1;
    for ( i = (unsigned __int8 *)(&off_806B3C8)[2 * v12]; ; ++i )
    {
      if ( !*i )
      {
        if ( a2 )
          *a2 = v10;
        v2 = dword_806B3CC[2 * v12];
        dword_806B2FC = (int)&loc_804E6E7;
        sub_80613B1();
      }
      v3 = sub_804B734(*v10);
      v4 = sub_804B734(byte_806C0C4[v3]);
      if ( v4 < (unsigned __int8)sub_804B734(*i) )
      {
        v9 = (v8 + v9) >> 1;
        goto LABEL_14;
      }
      v5 = sub_804B734(*v10);
      v6 = sub_804B734(byte_806C0C4[v5]);
      if ( v6 > (unsigned __int8)sub_804B734(*i) )
        break;
      ++v10;
    }
    v8 = v12 + 1;
LABEL_14:
    ;
  }
  while ( v8 < v9 );
  return 0;
}
// 806B2FC: using guessed type int dword_806B2FC;
// 806B3C8: using guessed type char *off_806B3C8;
// 806B3CC: using guessed type int dword_806B3CC[];

//----- (0804E6ED) --------------------------------------------------------
void __cdecl __noreturn sub_804E6ED(int a1)
{
  char *v1; // eax
  bool v2; // zf
  void (__cdecl __noreturn *v3)(size_t, int); // eax
  char *v4; // eax
  char *v5; // [esp+18h] [ebp-20h]
  char ptr; // [esp+1Ch] [ebp-1Ch]
  unsigned int v7; // [esp+2Ch] [ebp-Ch]

  v7 = __readgsdword(0x14u);
  v5 = sub_805BEFC(a1, 0x10u);
  if ( !v5 )
  {
    v1 = gettext("open failed");
    sub_804BA86((int)v1, a1);
  }
  sub_805C1A7((int)v5, &ptr, 0x10u);
  v2 = sub_805C204(v5) == 0;
  v3 = (void (__cdecl __noreturn *)(size_t, int))&loc_804E77D;
  if ( v2 )
    v3 = sub_804E798;
  dword_806B374 = (int)v3;
  sub_80610EA();
  v4 = gettext("close failed");
  sub_804BA86((int)v4, a1);
}
// 80610EA: using guessed type int sub_80610EA(void);
// 806B374: using guessed type int dword_806B374;

//----- (0804E798) --------------------------------------------------------
#error "804E79F: call analysis failed (funcsize=19)"

//----- (0804E7E9) --------------------------------------------------------
#error "804E7EA: positive sp value has been found (funcsize=0)"

//----- (0804E7EB) --------------------------------------------------------
size_t __cdecl sub_804E7EB(char *dest, char *src, size_t n)
{
  char *v3; // ebx
  int *v4; // eax
  char *v5; // eax
  size_t v7; // [esp+1Ch] [ebp-Ch]

  *__errno_location() = 0;
  v7 = strxfrm(dest, src, n);
  if ( *__errno_location() )
  {
    v3 = gettext("string transformation failed");
    v4 = __errno_location();
    error(0, *v4, v3);
    v5 = gettext("set LC_ALL='C' to work around the problem");
    error(0, 0, v5);
    sub_805B828(0, 8);
  }
  return v7;
}

//----- (0804E8C3) --------------------------------------------------------
void __cdecl __noreturn sub_804E8C3(int a1, size_t a2, int a3, size_t a4)
{
  int *v4; // edx
  int v5; // ecx
  unsigned int v6; // eax
  size_t v7; // eax
  void *v8; // eax
  int v9; // edx
  size_t v10; // edx
  size_t v11; // eax
  int v12; // edx
  int v13; // ecx
  int v14; // edx
  int v15; // ecx
  size_t v16; // eax
  bool v17; // zf
  int v18; // edx
  int v19; // ecx
  void *v20; // eax
  int v21; // edx
  int v22; // ecx
  size_t v23; // eax
  int v24; // edx
  int v25; // ecx
  int (*v26)(); // eax
  char *s; // [esp+18h] [ebp-1150h]
  char *src; // [esp+1Ch] [ebp-114Ch]
  bool v29; // [esp+2Bh] [ebp-113Dh]
  int v30; // [esp+2Ch] [ebp-113Ch]
  char *dest; // [esp+30h] [ebp-1138h]
  unsigned int size; // [esp+34h] [ebp-1134h]
  void *ptr; // [esp+38h] [ebp-1130h]
  size_t v34; // [esp+40h] [ebp-1128h]
  size_t v35; // [esp+44h] [ebp-1124h]
  unsigned int v36; // [esp+48h] [ebp-1120h]
  size_t n; // [esp+4Ch] [ebp-111Ch]
  size_t v38; // [esp+50h] [ebp-1118h]
  char s1; // [esp+54h] [ebp-1114h]
  int v40; // [esp+64h] [ebp-1104h]
  int v41; // [esp+74h] [ebp-10F4h]
  char v42; // [esp+110h] [ebp-1058h]
  char v43; // [esp+1ACh] [ebp-FBCh]
  unsigned int v44; // [esp+114Ch] [ebp-1Ch]

  src = (char *)a1;
  s = (char *)a3;
  v44 = __readgsdword(0x14u);
  v30 = 0;
  dest = &v43;
  size = 4000;
  ptr = 0;
  qmemcpy(&v42, &unk_806C284, 0x9Cu);
  v4 = &v41;
  qmemcpy(&v41, &v42, 0x9Cu);
  v5 = 0;
  if ( byte_806BDAC )
  {
    v34 = a1 + a2;
    v35 = a3 + a4;
    while ( 1 )
    {
      v36 = 3 * (a4 + a2) + 2;
      if ( size < v36 )
      {
        v6 = 3 * (a4 + a2) + 2;
        if ( 3 * size >> 1 >= v36 )
          v6 = 3 * size >> 1;
        size = v6;
        free(ptr);
        ptr = malloc(size);
        dest = (char *)ptr;
        if ( !ptr )
        {
          dest = &v43;
          size = 4000;
        }
      }
      if ( (unsigned int)src >= v34 )
        v7 = 0;
      else
        v7 = sub_804E7EB(dest, src, size) + 1;
      n = v7;
      v29 = v7 <= size;
      if ( (unsigned int)s >= v35 )
      {
        v11 = 0;
      }
      else
      {
        if ( v29 )
        {
          dword_806B310 = (int)&loc_804EAA5;
          sub_8061339(v5, size - v7);
        }
        v8 = &loc_804EAC7;
        if ( !v29 )
          v8 = &loc_804EAEC;
        dword_806B2AC = (int)v8;
        sub_806159C(v5, 0);
        dword_806B310 = (int)&loc_804EAF1;
        sub_8061339(dest, v9);
        v11 = sub_804E7EB(0, s, v10) + 1;
      }
      v38 = v11;
      if ( v29 != 1 || (v12 = n, n + v11 > size) )
      {
        size = n + v11;
        if ( n + v11 <= 0x55555554 )
          size = 3 * size >> 1;
        free(ptr);
        ptr = sub_805E14D(size);
        dest = (char *)ptr;
        if ( (unsigned int)src < v34 )
          strxfrm((char *)ptr, src, n);
        if ( (unsigned int)s < v35 )
          strxfrm((char *)ptr + n, s, v38);
      }
      if ( (unsigned int)src < v34 )
        src += strlen(src) + 1;
      if ( (unsigned int)s < v35 )
        s += strlen(s) + 1;
      if ( (unsigned int)src >= v34 && (unsigned int)s >= v35 )
      {
        a2 = n;
        src = dest;
        a4 = v38;
        s = &dest[n];
        sub_8056207((int)dest, v5, dest, n, (int)&v41);
        goto LABEL_41;
      }
      sub_8056207(v12, v5, dest, n, (int)&v41);
      sub_8056207((int)&dest[n], v13, &dest[n], v38, (int)&v42);
      if ( v30 )
        break;
      v16 = n;
      if ( v38 <= n )
        v16 = v38;
      v17 = memcmp(dest, &dest[n], v16) == 0;
      v20 = &loc_804ED63;
      if ( !v17 )
        v20 = &loc_804ED96;
      dword_806B2AC = (int)v20;
      sub_806159C(v19, v18);
      v30 = (n > v38) - (n < v38);
    }
    dword_806B2AC = (int)&loc_804E978;
    sub_806159C(v15, v14);
  }
  sub_8056207((int)v4, v5, src, a2, (int)&v41);
LABEL_41:
  sub_8055F3F(&v41, &s1);
  sub_8056207(v21, v22, s, a4, (int)&v42);
  sub_8055F3F((int *)&v42, &v40);
  if ( !memcmp(&s1, &v40, 0x10u) && !v30 )
  {
    v23 = a2;
    if ( a4 <= a2 )
      v23 = a4;
    memcmp(src, s, v23);
  }
  free(ptr);
  v26 = (int (*)())&loc_804EEFF;
  if ( __readgsdword(0x14u) == v44 )
    v26 = sub_804EF04;
  dword_806B310 = (int)v26;
  sub_8061339(v25, v24);
}
// 804EF04: using guessed type int sub_804EF04();
// 8061339: using guessed type int __fastcall sub_8061339(_DWORD, _DWORD);
// 806159C: using guessed type int __fastcall sub_806159C(_DWORD, _DWORD);
// 806B2AC: using guessed type int dword_806B2AC;
// 806B310: using guessed type int dword_806B310;
// 806BDAC: using guessed type char byte_806BDAC;

//----- (0804EF04) --------------------------------------------------------
#error "804EF0A: positive sp value has been found (funcsize=0)"

//----- (0804EF0F) --------------------------------------------------------
int __cdecl sub_804EF0F(char *a1, unsigned int a2)
{
  char *v2; // eax
  int v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_8059491(a1, a2 - (_DWORD)a1, 0);
  while ( (unsigned int)a1 < a2 )
  {
    v2 = a1++;
    v4 += *v2 == 9;
  }
  return v4;
}

//----- (0804EF5F) --------------------------------------------------------
int __cdecl sub_804EF5F(int a1, int a2)
{
  int v2; // eax
  char *v3; // eax
  int result; // eax
  void *v5; // eax

  while ( 1 )
  {
    v2 = a1--;
    if ( !v2 )
      break;
    putchar_unlocked(32);
  }
  if ( a2 )
  {
    putchar_unlocked(95);
    v5 = &loc_804EFCB;
    if ( a2 != 1 )
      v5 = &loc_804EF9C;
    dword_806B338 = (int)v5;
    sub_8061251();
    result = putchar_unlocked(10);
  }
  else
  {
    v3 = gettext("^ no match for key\n");
    result = printf(v3);
  }
  return result;
}
// 8061251: using guessed type int sub_8061251(void);
// 806B338: using guessed type int dword_806B338;

//----- (0804EFD9) --------------------------------------------------------
int __cdecl sub_804EFD9(_BYTE *a1)
{
  return a1[26] || a1[28] || a1[29];
}

//----- (0804F00E) --------------------------------------------------------
int __cdecl sub_804F00E(int a1, int a2)
{
  void *v2; // eax
  int v4; // [esp+0h] [ebp-48h]
  int v5; // [esp+4h] [ebp-44h]
  char v6; // [esp+11h] [ebp-37h]
  char *v7; // [esp+14h] [ebp-34h]
  unsigned __int8 *v8; // [esp+1Ch] [ebp-2Ch]
  char *v9; // [esp+20h] [ebp-28h]
  char *v10; // [esp+24h] [ebp-24h]
  int v11; // [esp+28h] [ebp-20h]
  int v12; // [esp+2Ch] [ebp-1Ch]

  v10 = *(char **)a1;
  v8 = (unsigned __int8 *)v10;
  v9 = &v10[*(_DWORD *)(a1 + 4) - 1];
  if ( a2 )
  {
    if ( *(_DWORD *)a2 != -1 )
      v8 = (unsigned __int8 *)sub_804D96A((char **)a1, a2);
    if ( *(_DWORD *)(a2 + 8) != -1 )
      v9 = sub_804DAF6((char **)a1, a2);
    if ( *(_BYTE *)(a2 + 24) && *(_DWORD *)a2 == -1 || *(_BYTE *)(a2 + 30) || (unsigned __int8)sub_804EFD9((_BYTE *)a2) )
    {
      v6 = *v9;
      *v9 = 0;
      while ( byte_806BDC4[(unsigned __int8)sub_804B734(*v8)] )
        ++v8;
      v7 = (char *)v8;
      if ( v9 < (char *)v8 )
      {
        v7 = v9;
        dword_806B2D4 = (int)&loc_804F237;
        sub_80614AE(v4, v5);
      }
      v2 = &loc_804F132;
      if ( !*(_BYTE *)(a2 + 30) )
        v2 = &loc_804F149;
      dword_806B2D4 = (int)v2;
      sub_80614AE(v4, v5);
      sub_804E5A9(v8, (unsigned __int8 **)&v7);
      *v9 = v6;
      v9 = v7;
    }
  }
  v11 = sub_804EF0F(v10, (unsigned int)v8);
  v12 = sub_804EF0F((char *)v8, (unsigned int)v9);
  return sub_804EF5F(v11, v12);
}
// 806B2D4: using guessed type int dword_806B2D4;

//----- (0804F284) --------------------------------------------------------
int __cdecl sub_804F284(int a1)
{
  int v1; // edx
  int v2; // ecx
  void *v3; // eax
  int v4; // edx
  int v5; // ecx
  int result; // eax
  void *v7; // eax
  int v8; // [esp+1Ch] [ebp-Ch]

  v8 = dword_806C1D8;
  do
  {
    sub_804F00E(a1, v8);
    v3 = &loc_804F2C3;
    if ( !v8 )
      v3 = &locret_804F307;
    dword_806B34C = (int)v3;
    sub_80611C6(v2, v1);
    v8 = *(_DWORD *)(v8 + 36);
  }
  while ( v8 );
  result = (unsigned __int8)byte_806C1D6 ^ 1;
  if ( byte_806C1D6 != 1 )
  {
    v7 = &locret_804F307;
    if ( byte_806C1D5 != 1 )
      v7 = &loc_804F292;
    dword_806B324 = (int)v7;
    result = sub_80612C5(v5, v4);
  }
  return result;
}
// 804F284: could not find valid save-restore pair for ebx
// 80611C6: using guessed type int __fastcall sub_80611C6(_DWORD, _DWORD);
// 80612C5: using guessed type int __fastcall sub_80612C5(_DWORD, _DWORD);
// 806B324: using guessed type int dword_806B324;
// 806B34C: using guessed type int dword_806B34C;
// 806C1D5: using guessed type char byte_806C1D5;
// 806C1D6: using guessed type char byte_806C1D6;
// 806C1D8: using guessed type int dword_806C1D8;

//----- (0804F309) --------------------------------------------------------
int __usercall sub_804F309@<eax>(int edx0@<edx>, int a2@<ecx>, int a1)
{
  void *v3; // eax
  void *v4; // eax
  int v5; // edx
  int v6; // ecx
  void *v7; // eax
  char v8; // al

  if ( *(_DWORD *)(a1 + 16) || *(_DWORD *)(a1 + 20) )
    goto LABEL_17;
  v3 = &loc_804F352;
  if ( *(_BYTE *)(a1 + 24) == 1 )
    v3 = &loc_804F3D5;
  dword_806B270 = (int)v3;
  sub_80616F6(a2, edx0);
  v4 = &loc_804F379;
  if ( *(_BYTE *)(a1 + 25) == 1 )
    v4 = &loc_804F3D5;
  dword_806B2C0 = (int)v4;
  sub_8061526();
  if ( !((unsigned __int8)sub_804EFD9((_BYTE *)a1) ^ 1) )
    goto LABEL_17;
  v7 = &loc_804F3B2;
  if ( *(_BYTE *)(a1 + 30) == 1 )
    v7 = &loc_804F3D5;
  dword_806B2E8 = (int)v7;
  sub_8061429(v6, v5);
  if ( *(_BYTE *)(a1 + 32) == 1 || *(_BYTE *)(a1 + 27) == 1 )
LABEL_17:
    v8 = 0;
  else
    v8 = 1;
  return v8 & 1;
}
// 804F309: could not find valid save-restore pair for ebx
// 8061429: using guessed type int __fastcall sub_8061429(_DWORD, _DWORD);
// 8061526: using guessed type int sub_8061526(void);
// 80616F6: using guessed type int __fastcall sub_80616F6(_DWORD, _DWORD);
// 806B270: using guessed type int dword_806B270;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B2E8: using guessed type int dword_806B2E8;

//----- (0804F3DF) --------------------------------------------------------
#error "804F43E: call analysis failed (funcsize=130)"

//----- (0804F559) --------------------------------------------------------
int __fastcall __noreturn sub_804F559(int a1, int a2, int *a3, char a4)
{
  int v4; // edx
  void *v5; // eax
  int v6; // eax
  int v7; // eax
  const char *v8; // edx
  int v9; // eax
  const char *v10; // eax
  void *v11; // esi
  char *v12; // ebx
  char *v13; // eax
  void *v14; // eax
  int v15; // ecx
  unsigned int v16; // edx
  int v17; // edx
  int v18; // ecx
  bool v19; // al
  bool v20; // al
  void *v21; // eax
  int v22; // edx
  int v23; // ecx
  void *v24; // eax
  void *v25; // eax
  char *v26; // eax
  void *v27; // eax
  char *v28; // eax
  void *v29; // eax
  int v30; // edx
  int v31; // ecx
  void *v32; // eax
  size_t v33; // eax
  char *v34; // eax
  char *v35; // eax
  char *v36; // eax
  int (*v37)(); // eax
  __int64 v39; // [esp+0h] [ebp-C8h]
  char *v40; // [esp+Ch] [ebp-BCh]
  void *v41; // [esp+10h] [ebp-B8h]
  char v42; // [esp+18h] [ebp-B0h]
  int *v43; // [esp+1Ch] [ebp-ACh]
  char v44; // [esp+20h] [ebp-A8h]
  bool v45; // [esp+21h] [ebp-A7h]
  bool v46; // [esp+22h] [ebp-A6h]
  char v47; // [esp+23h] [ebp-A5h]
  int v48; // [esp+24h] [ebp-A4h]
  char *v49; // [esp+28h] [ebp-A0h]
  unsigned int v50; // [esp+2Ch] [ebp-9Ch]
  unsigned int v51; // [esp+30h] [ebp-98h]
  int v52; // [esp+34h] [ebp-94h]
  char *v53; // [esp+38h] [ebp-90h]
  char *v54; // [esp+3Ch] [ebp-8Ch]
  unsigned int v55; // [esp+40h] [ebp-88h]
  int v56; // [esp+44h] [ebp-84h]
  int v57; // [esp+48h] [ebp-80h]
  int v58; // [esp+4Ch] [ebp-7Ch]
  int v59; // [esp+50h] [ebp-78h]
  int v60; // [esp+54h] [ebp-74h]
  int v61; // [esp+58h] [ebp-70h]
  int v62; // [esp+5Ch] [ebp-6Ch]
  int v63; // [esp+60h] [ebp-68h]
  int v64; // [esp+64h] [ebp-64h]
  int v65; // [esp+68h] [ebp-60h]
  char v66; // [esp+6Eh] [ebp-5Ah]
  char v67; // [esp+83h] [ebp-45h]
  char s; // [esp+9Dh] [ebp-2Bh]
  unsigned int v69; // [esp+BCh] [ebp-Ch]

  v43 = a3;
  v42 = a4;
  v69 = __readgsdword(0x14u);
  v56 = *a3;
  v57 = a3[1];
  v58 = a3[2];
  v59 = a3[3];
  v60 = a3[4];
  v61 = a3[5];
  v62 = a3[6];
  v63 = a3[7];
  v4 = a3[8];
  v64 = a3[8];
  v65 = a3[9];
  v49 = (char *)1;
  v48 = dword_806C1D8;
  while ( v48 )
  {
    v5 = &loc_804F606;
    if ( !*(_BYTE *)(v48 + 33) )
      v5 = &loc_804F7D5;
    dword_806B338 = (int)v5;
    sub_8061251();
    v50 = *(_DWORD *)v48;
    v52 = *(_DWORD *)(v48 + 8);
    v53 = &v67;
    v54 = &s;
    if ( v50 == -1 )
      v50 = 0;
    v6 = sub_80593DE(v50, (int)&v66);
    *(_WORD *)v53 = 43;
    v53 = (char *)stpcpy(v53 + 1, v6);
    v39 = v50 + 1;
    v7 = sub_80593DE(v39, (int)&v66);
    *(_DWORD *)v54 = 2124589;
    v54 = (char *)stpcpy(v54 + 3, v7);
    if ( *(_DWORD *)(v48 + 8) != -1 )
    {
      v39 = (unsigned int)(v52 + 1);
      v8 = (const char *)sub_80593DE(v39, (int)&v66);
      v9 = (int)v53;
      *(_WORD *)v53 = 11552;
      *(_BYTE *)(v9 + 2) = 0;
      strcpy(v53 + 2, v8);
      v10 = (const char *)sub_80593DE((unsigned int)(*(_DWORD *)(v48 + 12) == -1) + v52 + 1, (int)&v66);
      *(_WORD *)v54 = 44;
      strcpy(v54 + 1, v10);
    }
    v11 = sub_805BC14(1, &s);
    v12 = (char *)sub_805BC14(0, &v67);
    v13 = gettext("obsolescent key %s used; consider %s instead");
    v41 = v11;
    v40 = v12;
    error(0, 0, v13, v12, v11);
    v14 = &loc_804F7FB;
    if ( *(_DWORD *)v48 == -1 )
      v14 = &loc_804F82C;
    dword_806B2FC = (int)v14;
    sub_80613B1();
    v16 = *(_DWORD *)(v48 + 8);
    if ( v16 < *(_DWORD *)v48 )
    {
      dword_806B270 = (int)&loc_804F831;
      sub_80616F6(v15, v16);
    }
    v44 = 0;
    v19 = (unsigned __int8)sub_804EFD9((_BYTE *)v48) || *(_BYTE *)(v48 + 30);
    v45 = v19;
    v20 = !*(_DWORD *)(v48 + 8) && *(_DWORD *)(v48 + 12);
    v46 = v20;
    if ( v44 != 1 )
    {
      v21 = &loc_804F91A;
      if ( v42 == 1 )
        v21 = &loc_804F9F3;
      dword_806B220 = (int)v21;
      sub_80618EC();
      v24 = &loc_804F93F;
      if ( dword_806B42C != 128 )
        v24 = &loc_804F9F3;
      dword_806B2E8 = (int)v24;
      sub_8061429(v23, v22);
      if ( v46 != 1 )
      {
        if ( *(_BYTE *)(v48 + 24) != 1 && v45 != 1 || *(_BYTE *)(v48 + 24) != 1 && *(_DWORD *)(v48 + 4) )
          goto LABEL_71;
        v25 = &loc_804F9B8;
        if ( *(_BYTE *)(v48 + 25) == 1 )
          v25 = &loc_804F9F3;
        dword_806B2C0 = (int)v25;
        sub_8061526();
        if ( *(_DWORD *)(v48 + 12) )
        {
LABEL_71:
          v26 = gettext("leading blanks are significant in key %lu; consider also specifying 'b'");
          v40 = v49;
          error(0, 0, v26, v49);
        }
      }
    }
    v27 = &loc_804FA1A;
    if ( v42 == 1 )
      v27 = &loc_804FAA4;
    dword_806B2AC = (int)v27;
    sub_806159C(v18, v17);
    if ( (unsigned __int8)sub_804EFD9((_BYTE *)v48) )
    {
      v51 = *(_DWORD *)v48 + 1;
      v55 = *(_DWORD *)(v48 + 8) + 1;
      if ( !v51 )
        v51 = 1;
      if ( !v55 || v51 < v55 )
      {
        v28 = gettext("key %lu is numeric and spans multiple fields");
        v40 = v49;
        error(0, 0, v28, v49);
      }
    }
    if ( v60 )
    {
      v29 = &loc_804FAD4;
      if ( v60 != *(_DWORD *)(v48 + 16) )
        v29 = &loc_804FADB;
      dword_806B374 = (int)v29;
      sub_80610EA();
      v60 = 0;
    }
    if ( v61 && v61 == *(_DWORD *)(v48 + 20) )
      v61 = 0;
    LOBYTE(v62) = (unsigned __int8)(v62 & (*(_BYTE *)(v48 + 24) ^ 1)) != 0;
    BYTE1(v62) = (BYTE1(v62) & (*(_BYTE *)(v48 + 25) ^ 1)) != 0;
    BYTE2(v63) = (BYTE2(v63) & (*(_BYTE *)(v48 + 30) ^ 1)) != 0;
    BYTE2(v62) = (BYTE2(v62) & (*(_BYTE *)(v48 + 26) ^ 1)) != 0;
    LOBYTE(v63) = (unsigned __int8)(v63 & (*(_BYTE *)(v48 + 28) ^ 1)) != 0;
    BYTE1(v63) = (BYTE1(v63) & (*(_BYTE *)(v48 + 29) ^ 1)) != 0;
    HIBYTE(v62) = (HIBYTE(v62) & (*(_BYTE *)(v48 + 27) ^ 1)) != 0;
    LOBYTE(v64) = (unsigned __int8)(v64 & (*(_BYTE *)(v48 + 32) ^ 1)) != 0;
    v4 = HIBYTE(v63);
    HIBYTE(v63) = (HIBYTE(v63) & (*(_BYTE *)(v48 + 31) ^ 1)) != 0;
    v48 = *(_DWORD *)(v48 + 36);
    ++v49;
  }
  if ( (unsigned __int8)sub_804F309(v4, a1, (int)&v56) ^ 1 )
    goto LABEL_72;
  if ( HIBYTE(v63) )
  {
    v32 = &loc_804FC8A;
    if ( byte_806C1D5 )
      v32 = &loc_804FC99;
    dword_806B324 = (int)v32;
    sub_80612C5(v31, v30);
    if ( byte_806C1D6 )
    {
      if ( dword_806C1D8 )
      {
LABEL_72:
        v47 = HIBYTE(v63);
        if ( byte_806C1D5 != 1 && byte_806C1D6 != 1 )
          HIBYTE(v63) = 0;
        sub_804F3DF((int)&v56, &s);
        v33 = strlen(&s);
        v34 = sub_804B785(v33);
        v35 = ngettext("option '-%s' is ignored", "options '-%s' are ignored", (unsigned int)v34);
        v40 = &s;
        error(0, 0, v35, &s);
        HIBYTE(v63) = v47;
      }
    }
  }
  if ( HIBYTE(v63) && byte_806C1D5 != 1 && byte_806C1D6 != 1 && dword_806C1D8 )
  {
    v36 = gettext("option '-r' only applies to last-resort comparison");
    error(0, 0, v36);
  }
  v37 = (int (*)())&loc_804FDB8;
  if ( __readgsdword(0x14u) == v69 )
    v37 = sub_804FDBD;
  dword_806B2E8 = (int)v37;
  return sub_8061429(v31, v30);
}
// 8049930: using guessed type int __cdecl stpcpy(_DWORD, _DWORD);
// 804FDBD: using guessed type int sub_804FDBD();
// 80610EA: using guessed type int sub_80610EA(void);
// 8061251: using guessed type int sub_8061251(void);
// 80612C5: using guessed type int __fastcall sub_80612C5(_DWORD, _DWORD);
// 8061429: using guessed type int __fastcall sub_8061429(_DWORD, _DWORD);
// 8061526: using guessed type int sub_8061526(void);
// 806159C: using guessed type int __fastcall sub_806159C(_DWORD, _DWORD);
// 80616F6: using guessed type int __fastcall sub_80616F6(_DWORD, _DWORD);
// 80618EC: using guessed type int sub_80618EC(void);
// 806B220: using guessed type int dword_806B220;
// 806B270: using guessed type int dword_806B270;
// 806B2AC: using guessed type int dword_806B2AC;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B2E8: using guessed type int dword_806B2E8;
// 806B2FC: using guessed type int dword_806B2FC;
// 806B324: using guessed type int dword_806B324;
// 806B338: using guessed type int dword_806B338;
// 806B374: using guessed type int dword_806B374;
// 806B42C: using guessed type int dword_806B42C;
// 806C1D5: using guessed type char byte_806C1D5;
// 806C1D6: using guessed type char byte_806C1D6;
// 806C1D8: using guessed type int dword_806C1D8;

//----- (0804FDBD) --------------------------------------------------------
#error "804FDC3: positive sp value has been found (funcsize=0)"

//----- (0804FDC7) --------------------------------------------------------
int __cdecl sub_804FDC7(int a1, int a2)
{
  char *v2; // eax
  char *v3; // eax
  void *v4; // eax
  int v5; // ecx
  void *v6; // eax
  int v7; // edx
  size_t v8; // eax
  char *v9; // ebx
  int v10; // edx
  char v11; // al
  unsigned __int8 v12; // al
  size_t v13; // eax
  char *v14; // ebx
  unsigned __int8 v15; // al
  char v16; // al
  void *v17; // edx
  void *v18; // eax
  void *v19; // eax
  int v20; // ebx
  void *v21; // eax
  void *v22; // eax
  void *v23; // eax
  unsigned __int8 v24; // al
  unsigned __int8 v25; // al
  int v26; // ecx
  int v27; // edx
  bool v28; // zf
  void *v29; // eax
  unsigned __int8 v30; // al
  int v31; // ebx
  unsigned __int8 v32; // al
  unsigned __int8 v33; // al
  unsigned __int8 v34; // al
  int v35; // ebx
  int v36; // edx
  int v37; // ecx
  void *v39; // eax
  int v40; // edx
  int v41; // ecx
  void *v42; // eax
  void *v43; // eax
  int v44; // [esp+0h] [ebp-1018h]
  int v45; // [esp+18h] [ebp-1000h]
  int v46; // [esp+1Ch] [ebp-FFCh]
  char v47; // [esp+26h] [ebp-FF2h]
  char v48; // [esp+27h] [ebp-FF1h]
  int v49; // [esp+28h] [ebp-FF0h]
  void *s1; // [esp+2Ch] [ebp-FECh]
  void *s2; // [esp+30h] [ebp-FE8h]
  char *v52; // [esp+34h] [ebp-FE4h]
  char *v53; // [esp+38h] [ebp-FE0h]
  int v54; // [esp+3Ch] [ebp-FDCh]
  char *v55; // [esp+40h] [ebp-FD8h]
  char *v56; // [esp+44h] [ebp-FD4h]
  size_t v57; // [esp+48h] [ebp-FD0h]
  size_t v58; // [esp+4Ch] [ebp-FCCh]
  void *ptr; // [esp+50h] [ebp-FC8h]
  size_t v60; // [esp+54h] [ebp-FC4h]
  int v61; // [esp+58h] [ebp-FC0h]
  int v62; // [esp+5Ch] [ebp-FBCh]
  size_t v63; // [esp+60h] [ebp-FB8h]
  size_t n; // [esp+64h] [ebp-FB4h]
  size_t size; // [esp+68h] [ebp-FB0h]
  char v66; // [esp+6Ch] [ebp-FACh]
  unsigned int v67; // [esp+100Ch] [ebp-Ch]

  v46 = a1;
  v45 = a2;
  v67 = __readgsdword(0x14u);
  v49 = dword_806C1D8;
  s1 = *(void **)(a1 + 8);
  s2 = *(void **)(a2 + 8);
  v52 = *(char **)(a1 + 12);
  v53 = *(char **)(a2 + 12);
  while ( 1 )
  {
    v61 = *(_DWORD *)(v49 + 20);
    v62 = *(_DWORD *)(v49 + 16);
    v2 = (char *)s1;
    if ( v52 >= s1 )
      v2 = v52;
    v52 = v2;
    v3 = (char *)s2;
    if ( v53 >= s2 )
      v3 = v53;
    v53 = v3;
    v63 = v52 - (_BYTE *)s1;
    n = v3 - (_BYTE *)s2;
    v4 = &loc_804FED5;
    if ( byte_806BDAC )
      v4 = &loc_804FF15;
    dword_806B284 = (int)v4;
    sub_8061686();
    if ( (unsigned __int8)sub_804EFD9((_BYTE *)v49)
      || *(_BYTE *)(v49 + 30)
      || *(_BYTE *)(v49 + 27)
      || *(_BYTE *)(v49 + 32) )
    {
      if ( v62 || v61 )
      {
        size = v63 + n + 2;
        if ( size > 0xFA0 )
        {
          ptr = sub_805E14D(size);
          v55 = (char *)ptr;
        }
        else
        {
          v55 = &v66;
          ptr = 0;
        }
        v56 = &v55[v63 + 1];
        v60 = 0;
        v57 = 0;
        while ( v60 < v63 )
        {
          v6 = &loc_804FFDA;
          if ( !v62 )
            v6 = &loc_805000B;
          dword_806B298 = (int)v6;
          sub_8061616();
          v44 = *((char *)s1 + v60);
          v7 = (unsigned __int8)sub_804B734(v44);
          if ( *(_BYTE *)(v7 + v62) ^ 1 )
          {
            v8 = v57++;
            v9 = &v55[v8];
            if ( v61 )
            {
              v44 = *((char *)s1 + v60);
              v10 = (unsigned __int8)sub_804B734(v44);
              v11 = *(_BYTE *)(v10 + v61);
            }
            else
            {
              v11 = *((_BYTE *)s1 + v60);
            }
            *v9 = v11;
          }
          ++v60;
        }
        v55[v57] = 0;
        v60 = 0;
        v58 = 0;
        while ( v60 < n )
        {
          if ( !v62 || (v44 = *((char *)s2 + v60), v12 = sub_804B734(v44), *(_BYTE *)(v12 + v62) ^ 1) )
          {
            v13 = v58++;
            v14 = &v56[v13];
            if ( v61 )
            {
              v44 = *((char *)s2 + v60);
              v15 = sub_804B734(v44);
              v16 = *(_BYTE *)(v15 + v61);
            }
            else
            {
              v16 = *((_BYTE *)s2 + v60);
            }
            *v14 = v16;
          }
          ++v60;
        }
        v17 = v56;
        v56[v58] = 0;
      }
      else
      {
        v55 = (char *)s1;
        v57 = v63;
        v47 = *((_BYTE *)s1 + v63);
        *((_BYTE *)s1 + v63) = 0;
        v56 = (char *)s2;
        v58 = n;
        v48 = *((_BYTE *)s2 + n);
        v17 = s2;
        *((_BYTE *)s2 + n) = 0;
      }
      v18 = &loc_8050220;
      if ( !*(_BYTE *)(v49 + 26) )
        v18 = &loc_8050255;
      dword_806B310 = (int)v18;
      sub_8061339(v5, v17);
      v54 = sub_804E331((unsigned __int8 *)v55, (int)v56);
      dword_806B360 = (int)&loc_805042C;
      sub_8061156();
      if ( *(_BYTE *)(v49 + 28) )
      {
        v54 = sub_804E45A((int)v55, (int)v56);
      }
      else if ( *(_BYTE *)(v49 + 29) )
      {
        v54 = sub_804E25D((unsigned __int8 *)v55, (unsigned __int8 *)v56);
      }
      else
      {
        v19 = &loc_80502DE;
        if ( !*(_BYTE *)(v49 + 30) )
          v19 = &loc_805031B;
        dword_806B25C = (int)v19;
        sub_806177B();
        v20 = sub_804E5A9((unsigned __int8 *)v55, 0);
        v54 = v20 - sub_804E5A9((unsigned __int8 *)v56, 0);
      }
      v21 = &loc_805044E;
      if ( v62 )
        v21 = &loc_8050470;
      dword_806B234 = (int)v21;
      sub_806185D();
      v22 = &loc_8050470;
      if ( !v61 )
        v22 = &loc_8050483;
      dword_806B2C0 = (int)v22;
      sub_8061526();
      free(ptr);
    }
    else
    {
      v23 = &loc_80504D8;
      if ( !v62 )
        v23 = &loc_805078E;
      dword_806B234 = (int)v23;
      sub_806185D();
      if ( v61 )
      {
        while ( 1 )
        {
          while ( s1 < v52 )
          {
            v44 = *(char *)s1;
            v24 = sub_804B734(v44);
            if ( !*(_BYTE *)(v24 + v62) )
              break;
            s1 = (char *)s1 + 1;
          }
          if ( s2 < v53 )
          {
            v44 = *(char *)s2;
            v25 = sub_804B734(v44);
            v27 = v25;
            v28 = *(_BYTE *)(v25 + v62) == 0;
            v29 = &loc_8050578;
            if ( !v28 )
              v29 = &loc_8050524;
            dword_806B34C = (int)v29;
            sub_80611C6(v26, v27);
          }
          if ( s1 >= v52 || s2 >= v53 )
            break;
          v44 = *(char *)s1;
          v30 = sub_804B734(v44);
          v44 = *(char *)(v30 + v61);
          v31 = (unsigned __int8)sub_804B734(v44);
          v44 = *(char *)s2;
          v32 = sub_804B734(v44);
          v44 = *(char *)(v32 + v61);
          v54 = v31 - (unsigned __int8)sub_804B734(v44);
          if ( v54 )
            goto LABEL_99;
          s1 = (char *)s1 + 1;
          s2 = (char *)s2 + 1;
        }
        v54 = (s1 < v52) - (s2 < v53);
      }
      else
      {
        while ( s1 < v52 )
        {
          v44 = *(char *)s1;
          v33 = sub_804B734(v44);
          if ( !*(_BYTE *)(v33 + v62) )
            break;
          s1 = (char *)s1 + 1;
        }
        while ( s2 < v53 )
        {
          v44 = *(char *)s2;
          v34 = sub_804B734(v44);
          if ( !*(_BYTE *)(v34 + v62) )
            break;
          s2 = (char *)s2 + 1;
        }
        if ( s1 < v52 && s2 < v53 )
        {
          v44 = *(char *)s1;
          v35 = (unsigned __int8)sub_804B734(v44);
          v44 = *(char *)s2;
          v54 = v35 - (unsigned __int8)sub_804B734(v44);
          if ( v54 )
            break;
          s1 = (char *)s1 + 1;
          s2 = (char *)s2 + 1;
          dword_806B34C = (int)&loc_805065A;
          sub_80611C6(v37, v36);
        }
        v54 = (s1 < v52) - (s2 < v53);
      }
    }
    if ( v54 )
      break;
    v49 = *(_DWORD *)(v49 + 36);
    if ( !v49 )
      return 0;
    if ( *(_DWORD *)(v49 + 8) == -1 )
    {
      v52 = (char *)(*(_DWORD *)v46 + *(_DWORD *)(v46 + 4) - 1);
      v53 = (char *)(*(_DWORD *)v45 + *(_DWORD *)(v45 + 4) - 1);
    }
    else
    {
      v52 = sub_804DAF6((char **)v46, v49);
      v53 = sub_804DAF6((char **)v45, v49);
    }
    if ( *(_DWORD *)v49 == -1 )
    {
      s1 = *(void **)v46;
      s2 = *(void **)v45;
      if ( *(_BYTE *)(v49 + 24) )
      {
        if ( s1 < v52 )
        {
          v44 = *(char *)s1;
          v28 = byte_806BDC4[(unsigned __int8)sub_804B734(v44)] == 0;
          v39 = &loc_8050AA4;
          if ( !v28 )
            v39 = &loc_8050A54;
          dword_806B360 = (int)v39;
          sub_8061156();
        }
        if ( s2 < v53 )
        {
          v44 = *(char *)s2;
          v28 = byte_806BDC4[(unsigned __int8)sub_804B734(v44)] == 0;
          v42 = &loc_8050AF6;
          if ( !v28 )
            v42 = &loc_8050AA6;
          dword_806B270 = (int)v42;
          sub_80616F6(v41, v40);
        }
      }
    }
    else
    {
      s1 = (void *)sub_804D96A((char **)v46, v49);
      s2 = (void *)sub_804D96A((char **)v45, v49);
    }
  }
LABEL_99:
  v43 = &loc_8050B22;
  if ( !*(_BYTE *)(v49 + 31) )
    v43 = &loc_8050B41;
  dword_806B234 = (int)v43;
  sub_806185D();
  dword_806B234 = (int)&loc_8050B47;
  sub_806185D();
  return v54;
}
// 8061156: using guessed type int sub_8061156(void);
// 80611C6: using guessed type int __fastcall sub_80611C6(_DWORD, _DWORD);
// 8061339: using guessed type int __fastcall sub_8061339(_DWORD, _DWORD);
// 8061526: using guessed type int sub_8061526(void);
// 8061616: using guessed type int sub_8061616(void);
// 8061686: using guessed type int sub_8061686(void);
// 80616F6: using guessed type int __fastcall sub_80616F6(_DWORD, _DWORD);
// 806177B: using guessed type int sub_806177B(void);
// 806185D: using guessed type int sub_806185D(void);
// 806B234: using guessed type int dword_806B234;
// 806B25C: using guessed type int dword_806B25C;
// 806B270: using guessed type int dword_806B270;
// 806B284: using guessed type int dword_806B284;
// 806B298: using guessed type int dword_806B298;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B310: using guessed type int dword_806B310;
// 806B34C: using guessed type int dword_806B34C;
// 806B360: using guessed type int dword_806B360;
// 806BDAC: using guessed type char byte_806BDAC;
// 806C1D8: using guessed type int dword_806C1D8;

//----- (08050B61) --------------------------------------------------------
int __cdecl sub_8050B61(int a1, int a2)
{
  void *v2; // eax
  void *v3; // eax
  int result; // eax
  void *v5; // eax
  int v6; // edx
  int v7; // ecx
  void *v8; // eax
  int v9; // [esp+14h] [ebp-14h]
  int v10; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]

  if ( dword_806C1D8 )
  {
    v9 = sub_804FDC7(a1, a2);
    if ( !v9 )
    {
      v2 = &loc_8050BB0;
      if ( byte_806C1D6 )
        v2 = &loc_8050BD4;
      dword_806B284 = (int)v2;
      sub_8061686();
      v3 = &loc_8050BD4;
      if ( !byte_806C1D5 )
        v3 = &loc_8050BDC;
      dword_806B248 = (int)v3;
      sub_80617ED();
    }
    result = v9;
  }
  else
  {
    v10 = *(_DWORD *)(a1 + 4) - 1;
    n = *(_DWORD *)(a2 + 4) - 1;
    v5 = &loc_8050C13;
    if ( v10 )
      v5 = &loc_8050C27;
    dword_806B374 = (int)v5;
    sub_80610EA();
    v9 = -(n != 0);
    v8 = &loc_8050D27;
    if ( !byte_806C1D4 )
      v8 = &loc_8050D43;
    dword_806B2AC = (int)v8;
    sub_806159C(v7, v6);
    dword_806B220 = (int)&loc_8050D46;
    sub_80618EC();
    result = v9;
  }
  return result;
}
// 80610EA: using guessed type int sub_80610EA(void);
// 806159C: using guessed type int __fastcall sub_806159C(_DWORD, _DWORD);
// 8061686: using guessed type int sub_8061686(void);
// 80617ED: using guessed type int sub_80617ED(void);
// 80618EC: using guessed type int sub_80618EC(void);
// 806B220: using guessed type int dword_806B220;
// 806B248: using guessed type int dword_806B248;
// 806B284: using guessed type int dword_806B284;
// 806B2AC: using guessed type int dword_806B2AC;
// 806B374: using guessed type int dword_806B374;
// 806C1D4: using guessed type char byte_806C1D4;
// 806C1D5: using guessed type char byte_806C1D5;
// 806C1D6: using guessed type char byte_806C1D6;
// 806C1D8: using guessed type int dword_806C1D8;

//----- (08050D4C) --------------------------------------------------------
char *__cdecl sub_8050D4C(int a1, FILE *stream, int a3)
{
  int v3; // ecx
  char *v4; // eax
  void *v5; // eax
  char *v6; // eax
  char *result; // eax
  char *v8; // eax
  char v9; // [esp+1Fh] [ebp-19h]
  char *v10; // [esp+20h] [ebp-18h]
  void *ptr; // [esp+24h] [ebp-14h]
  size_t n; // [esp+28h] [ebp-10h]
  char *v13; // [esp+2Ch] [ebp-Ch]

  ptr = *(void **)a1;
  n = *(_DWORD *)(a1 + 4);
  v13 = (char *)ptr + n;
  if ( a3 || !byte_806C1E0 )
  {
    *(v13 - 1) = byte_806B3A8;
    if ( fwrite_unlocked(ptr, 1u, n, stream) != n )
    {
      v8 = gettext("write failed");
      sub_804BA86((int)v8, a3);
    }
    result = v13 - 1;
    *(v13 - 1) = 0;
  }
  else
  {
    v10 = (char *)ptr;
    dword_806B324 = (int)&loc_8050E17;
    sub_80612C5(v3, ptr);
    do
    {
      v4 = v10++;
      v9 = *v4;
      if ( v9 == 9 )
      {
        v9 = 62;
      }
      else
      {
        v5 = &loc_8050DE0;
        if ( v10 != v13 )
          v5 = &loc_8050DE4;
        dword_806B20C = (int)v5;
        sub_806195A();
        v9 = 10;
      }
      if ( fputc_unlocked(v9, stream) == -1 )
      {
        v6 = gettext("write failed");
        sub_804BA86((int)v6, 0);
      }
    }
    while ( v10 < v13 );
    result = (char *)sub_804F284(a1);
  }
  return result;
}
// 80612C5: using guessed type int __fastcall sub_80612C5(_DWORD, _DWORD);
// 806195A: using guessed type int sub_806195A(void);
// 806B20C: using guessed type int dword_806B20C;
// 806B324: using guessed type int dword_806B324;
// 806B3A8: using guessed type char byte_806B3A8;
// 806C1E0: using guessed type char byte_806C1E0;

//----- (08050E87) --------------------------------------------------------
void __cdecl __noreturn sub_8050E87(char *a1, int a2)
{
  size_t v2; // eax
  void *v3; // [esp+68h] [ebp-50h]
  unsigned int v4; // [esp+9Ch] [ebp-1Ch]

  v4 = __readgsdword(0x14u);
  sub_804C51F(a1, "r");
  v2 = dword_806B428;
  if ( size >= dword_806B428 )
    v2 = size;
  sub_804D8B4((int)&v3, 16, v2);
}
// 806C1D6: using guessed type char byte_806C1D6;
// 806C1D8: using guessed type int dword_806C1D8;

//----- (0805126E) --------------------------------------------------------
#error "8051274: positive sp value has been found (funcsize=0)"

//----- (08051279) --------------------------------------------------------
unsigned int __cdecl sub_8051279(int a1, unsigned int a2, void **a3)
{
  FILE **v3; // ebx
  unsigned int v5; // [esp+18h] [ebp-10h]
  _DWORD *v6; // [esp+1Ch] [ebp-Ch]

  *a3 = sub_805E027(a2, 4u);
  v6 = *a3;
  v5 = 0;
  dword_806B374 = (int)&loc_8051384;
  sub_80610EA();
  do
  {
    v3 = (FILE **)&v6[v5];
    if ( *(_DWORD *)(8 * v5 + a1 + 4) && *(_BYTE *)(*(_DWORD *)(8 * v5 + a1 + 4) + 8) )
    {
      sub_804C996(*(_DWORD *)(8 * v5 + a1 + 4));
      dword_806B248 = (int)&loc_8051352;
      sub_80617ED();
    }
    *v3 = sub_804C3B1(*(char **)(8 * v5 + a1), "r");
    if ( !v6[v5] )
    {
      dword_806B338 = (int)&loc_8051390;
      sub_8061251();
    }
    ++v5;
  }
  while ( v5 < a2 );
  return v5;
}
// 80610EA: using guessed type int sub_80610EA(void);
// 8061251: using guessed type int sub_8061251(void);
// 80617ED: using guessed type int sub_80617ED(void);
// 806B248: using guessed type int dword_806B248;
// 806B338: using guessed type int dword_806B338;
// 806B374: using guessed type int dword_806B374;

//----- (08051399) --------------------------------------------------------
void __cdecl __noreturn sub_8051399(int a1, int a2, int a3)
{
  size_t v3; // edx
  int v4; // [esp+14h] [ebp-64h]
  size_t size; // [esp+18h] [ebp-60h]
  int v6; // [esp+1Ch] [ebp-5Ch]
  void *v7; // [esp+30h] [ebp-48h]
  void *v8; // [esp+34h] [ebp-44h]
  void *v9; // [esp+38h] [ebp-40h]
  void *v10; // [esp+3Ch] [ebp-3Ch]
  int v11; // [esp+40h] [ebp-38h]
  void *ptr; // [esp+60h] [ebp-18h]

  v7 = sub_805E027(a3, 0x1Cu);
  v4 = 0;
  size = 0;
  v8 = sub_805E027(a3, 4u);
  v9 = sub_805E027(a3, 4u);
  v10 = sub_805E027(a3, 4u);
  v11 = dword_806C1D8;
  ptr = 0;
  v6 = 0;
  dword_806B234 = (int)&loc_8051620;
  sub_806185D();
  v3 = ::size / a3;
  if ( ::size / a3 < dword_806B428 )
    v3 = dword_806B428;
  sub_804D8B4((int)v7 + 28 * v6, 16, v3);
}
// 806185D: using guessed type int sub_806185D(void);
// 806B234: using guessed type int dword_806B234;
// 806C1D8: using guessed type int dword_806C1D8;

//----- (08051D6A) --------------------------------------------------------
void __cdecl __noreturn sub_8051D6A(int a1, int a2, int a3)
{
  int v3; // ebx
  char *v4; // eax
  void *v5; // [esp+28h] [ebp-10h]
  int v6; // [esp+2Ch] [ebp-Ch]

  v6 = sub_8051279(a1, a3, &v5);
  if ( v6 < (unsigned int)a3 && (unsigned int)v6 <= 1 )
  {
    v3 = *(_DWORD *)(8 * v6 + a1);
    v4 = gettext("open failed");
    sub_804BA86((int)v4, v3);
  }
  sub_8051399(a1, a2, v6);
}

//----- (08051DFB) --------------------------------------------------------
_DWORD *__cdecl sub_8051DFB(int a1, unsigned int a2, int a3)
{
  int v3; // eax
  int v4; // edx
  int v5; // ecx
  bool v6; // zf
  bool v7; // sf
  void *v8; // eax
  _DWORD *result; // eax
  unsigned int v10; // [esp+14h] [ebp-14h]
  unsigned int v11; // [esp+18h] [ebp-10h]
  unsigned int v12; // [esp+1Ch] [ebp-Ch]

  v10 = a2 >> 1;
  v11 = a2 - (a2 >> 1);
  v12 = -16 * (a2 >> 1) + a1;
  v3 = sub_8050B61(a3 - 16, v12 - 16);
  v6 = v3 == 0;
  v7 = v3 < 0;
  v8 = &loc_8051E5D;
  if ( !v7 && !v6 )
    v8 = &loc_8051E8D;
  dword_806B2AC = (int)v8;
  sub_806159C(v5, v4);
  result = (_DWORD *)(a1 - 16);
  *result = *(_DWORD *)(a3 - 16);
  result[1] = *(_DWORD *)(a3 - 16 + 4);
  result[2] = *(_DWORD *)(a3 - 16 + 8);
  result[3] = *(_DWORD *)(a3 - 16 + 12);
  if ( --v10 )
  {
    dword_806B374 = (int)&loc_8051E28;
    result = (_DWORD *)sub_80610EA();
  }
  return result;
}
// 80610EA: using guessed type int sub_80610EA(void);
// 806159C: using guessed type int __fastcall sub_806159C(_DWORD, _DWORD);
// 806B2AC: using guessed type int dword_806B2AC;
// 806B374: using guessed type int dword_806B374;

//----- (08051F04) --------------------------------------------------------
_DWORD *__cdecl sub_8051F04(int a1, unsigned int a2, int a3, unsigned __int8 a4)
{
  int v4; // ecx
  void *v5; // eax
  _DWORD *v6; // eax
  _DWORD *v7; // edx
  _DWORD *result; // eax
  int v9; // ecx
  void *v10; // eax
  int v11; // edx
  _DWORD *v12; // edx
  int v13; // [esp+2Ch] [ebp-1Ch]
  unsigned int v14; // [esp+30h] [ebp-18h]

  if ( a2 == 2 )
  {
    v13 = sub_8050B61(a1 - 16, a1 - 32) > 0;
    v5 = &loc_8051F5C;
    if ( !a4 )
      v5 = &loc_8051FB5;
    dword_806B360 = (int)v5;
    sub_8061156();
    v6 = (_DWORD *)(a3 - 16);
    v7 = (_DWORD *)(16 * ~v13 + a1);
    *v6 = *v7;
    v6[1] = v7[1];
    v6[2] = v7[2];
    v6[3] = v7[3];
    result = (_DWORD *)(a3 - 32);
    v9 = 16 * (v13 - 2);
    *result = *(_DWORD *)(v9 + a1);
    result[1] = *(_DWORD *)(v9 + a1 + 4);
    result[2] = *(_DWORD *)(v9 + a1 + 8);
    result[3] = *(_DWORD *)(v9 + a1 + 12);
  }
  else
  {
    v14 = a2 >> 1;
    v10 = &loc_8052075;
    if ( !a4 )
      v10 = &loc_805207F;
    dword_806B2E8 = (int)v10;
    sub_8061429(v4, a4);
    sub_8051F04(-16 * (a2 >> 1) + a1, a2 - (a2 >> 1), a3 - 16 * v14, v11);
    if ( v14 <= 1 )
    {
      if ( a4 != 1 )
      {
        v12 = (_DWORD *)(a3 - 16);
        *v12 = *(_DWORD *)(a1 - 16);
        v12[1] = *(_DWORD *)(a1 - 12);
        v12[2] = *(_DWORD *)(a1 - 8);
        v12[3] = *(_DWORD *)(a1 - 4);
      }
    }
    else
    {
      sub_8051F04(a1, v14, a3, a4 == 0);
    }
    if ( a4 )
      result = sub_8051DFB(a3, a2, a1);
    else
      result = sub_8051DFB(a1, a2, a3);
  }
  return result;
}
// 8061156: using guessed type int sub_8061156(void);
// 8061429: using guessed type int __fastcall sub_8061429(_DWORD, _DWORD);
// 806B2E8: using guessed type int dword_806B2E8;
// 806B360: using guessed type int dword_806B360;

//----- (08052143) --------------------------------------------------------
pthread_mutex_t *__cdecl sub_8052143(unsigned int a1, int a2, int a3)
{
  pthread_mutex_t *v3; // eax
  pthread_mutex_t *v4; // ST28_4
  pthread_mutex_t *v5; // ST2C_4

  v3 = (pthread_mutex_t *)sub_805E14D(144 * a1);
  v4 = v3;
  v5 = v3;
  v3->__kind = 0;
  v5->__owner = v5->__kind;
  v5->__count = v5->__owner;
  v5->__lock = v5->__count;
  v3->__nusers = 0;
  v3[1].__lock = a2;
  v3->__spins = v3[1].__lock;
  v3[1].__count = 0;
  v3[1].__nusers = 0;
  v3[1].__size[20] = 0;
  pthread_mutex_init(v3 + 2, 0);
  sub_805225D(v5, v5 + 3, a3, a1, a2, 0);
  return v4;
}

//----- (0805225D) --------------------------------------------------------
int __cdecl sub_805225D(_DWORD *a1, pthread_mutex_t *a2, int a3, unsigned int a4, int a5, char a6)
{
  int v6; // eax
  pthread_mutex_t *v7; // eax
  int v8; // eax
  int v9; // edx
  int v10; // ecx
  char v12; // [esp+1Ch] [ebp-3Ch]
  unsigned int v13; // [esp+2Ch] [ebp-2Ch]
  unsigned int v14; // [esp+30h] [ebp-28h]
  unsigned int v15; // [esp+34h] [ebp-24h]
  int v16; // [esp+38h] [ebp-20h]
  unsigned int v17; // [esp+3Ch] [ebp-1Ch]
  _DWORD *v18; // [esp+40h] [ebp-18h]
  pthread_mutex_t *v19; // [esp+44h] [ebp-14h]
  unsigned int v20; // [esp+48h] [ebp-10h]
  unsigned int v21; // [esp+4Ch] [ebp-Ch]
  int v22; // [esp+64h] [ebp+Ch]

  v12 = a6;
  if ( a6 )
  {
    v6 = a1[5];
    dword_806B220 = (int)&loc_8052292;
    sub_80618EC();
  }
  v13 = a1[6];
  v14 = v13 >> 1;
  v15 = v13 - (v13 >> 1);
  v16 = -16 * a5 + a3;
  v17 = -16 * (v13 >> 1) + v16;
  if ( v12 )
  {
    dword_806B298 = (int)&loc_80522F7;
    sub_8061616();
  }
  v18 = a1 + 3;
  v7 = a2;
  v22 = (int)&a2[3];
  v19 = v7;
  v7->__owner = v16;
  v19->__lock = v19->__owner;
  v19->__kind = v17;
  v19->__count = v19->__kind;
  v19->__nusers = (unsigned int)v18;
  v19->__spins = v14;
  v19[1].__lock = v15;
  v19[1].__count = (unsigned int)a1;
  v19[1].__nusers = a1[10] + 1;
  v19[1].__size[20] = 0;
  pthread_mutex_init(v19 + 2, 0);
  if ( a4 > 1 )
  {
    v20 = a4 >> 1;
    v21 = a4 - (a4 >> 1);
    v19[1].__owner = v22;
    v8 = sub_805225D(v19, v22, v16, v20, a5, 1);
    v19[1].__kind = v8;
    v22 = sub_805225D(v19, v8, v17, v21, a5, 0);
    dword_806B2AC = (int)&loc_805243F;
    sub_806159C(v10, v9);
  }
  v19[1].__owner = 0;
  v19[1].__kind = 0;
  return v22;
}
// 806159C: using guessed type int __fastcall sub_806159C(_DWORD, _DWORD);
// 8061616: using guessed type int sub_8061616(void);
// 80618EC: using guessed type int sub_80618EC(void);
// 806B220: using guessed type int dword_806B220;
// 806B298: using guessed type int dword_806B298;
// 806B2AC: using guessed type int dword_806B2AC;

//----- (08052444) --------------------------------------------------------
_BOOL4 __cdecl sub_8052444(_DWORD *a1, _DWORD *a2)
{
  _BOOL4 result; // eax

  if ( a1[10] == a2[10] )
    result = a1[5] + a1[6] < (unsigned int)(a2[5] + a2[6]);
  else
    result = a1[10] < a2[10];
  return result;
}

//----- (080524A3) --------------------------------------------------------
int __cdecl sub_80524A3(pthread_mutex_t *a1)
{
  return pthread_mutex_lock(a1 + 2);
}

//----- (080524B9) --------------------------------------------------------
int __cdecl sub_80524B9(pthread_mutex_t *a1)
{
  return pthread_mutex_unlock(a1 + 2);
}

//----- (08052500) --------------------------------------------------------
int __cdecl sub_8052500(int a1, int a2)
{
  *(_DWORD *)a1 = sub_8058F33((int)sub_8052444, 2 * a2);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 4), 0);
  return pthread_cond_init((pthread_cond_t *)(a1 + 28), 0);
}

//----- (0805254E) --------------------------------------------------------
int __cdecl sub_805254E(int a1, int a2)
{
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 4));
  sub_8058FE7(*(_DWORD *)a1, a2);
  *(_BYTE *)(a2 + 44) = 1;
  pthread_cond_signal((pthread_cond_t *)(a1 + 28));
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 4));
}

//----- (0805259B) --------------------------------------------------------
pthread_mutex_t *__cdecl sub_805259B(int a1)
{
  int v1; // edx
  int v2; // ecx
  pthread_mutex_t *v4; // [esp+1Ch] [ebp-Ch]

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 4));
  while ( 1 )
  {
    v4 = (pthread_mutex_t *)sub_8059070(v1, v2, *(int **)a1);
    if ( v4 )
      break;
    pthread_cond_wait((pthread_cond_t *)(a1 + 28), (pthread_mutex_t *)(a1 + 4));
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 4));
  sub_80524A3(v4);
  v4[1].__size[20] = 0;
  return v4;
}

//----- (08052604) --------------------------------------------------------
char *__cdecl sub_8052604(int a1, FILE *stream, int a3)
{
  char *result; // eax

  if ( !byte_806C1D6 )
    goto LABEL_5;
  if ( !dword_806BDB0 || (result = (char *)sub_8050B61(a1, (int)&dword_806BDB0)) != 0 )
  {
    dword_806BDB0 = *(_DWORD *)a1;
    dword_806BDB4 = *(_DWORD *)(a1 + 4);
    dword_806BDB8 = *(_DWORD *)(a1 + 8);
    dword_806BDBC = *(_DWORD *)(a1 + 12);
LABEL_5:
    result = sub_8050D4C(a1, stream, a3);
  }
  return result;
}
// 806BDB0: using guessed type int dword_806BDB0;
// 806BDB4: using guessed type int dword_806BDB4;
// 806BDB8: using guessed type int dword_806BDB8;
// 806BDBC: using guessed type int dword_806BDBC;
// 806C1D6: using guessed type char byte_806C1D6;

//----- (08052677) --------------------------------------------------------
int __cdecl sub_8052677(int a1, int a2, FILE *stream, int a4)
{
  int v4; // eax
  _DWORD *v5; // edx
  _DWORD *v6; // eax
  int v7; // ecx
  int v8; // edx
  void *v9; // eax
  int v10; // eax
  int v11; // edx
  void *v12; // eax
  int v13; // ecx
  _DWORD *v14; // edx
  _DWORD *v15; // eax
  int v16; // edx
  void *v17; // eax
  int v18; // eax
  int v19; // eax
  int v20; // eax
  bool v21; // zf
  void *v22; // eax
  int v23; // ecx
  int v24; // edx
  void *v25; // eax
  int v26; // eax
  int result; // eax
  int v28; // [esp+4h] [ebp-34h]
  unsigned int v29; // [esp+18h] [ebp-20h]
  _DWORD *v30; // [esp+1Ch] [ebp-1Ch]
  int v31; // [esp+20h] [ebp-18h]
  int v32; // [esp+24h] [ebp-14h]
  int v33; // [esp+28h] [ebp-10h]
  int v34; // [esp+2Ch] [ebp-Ch]

  v31 = *(_DWORD *)a1;
  v32 = *(_DWORD *)(a1 + 4);
  v29 = ((unsigned int)a2 >> 2 * (*(_BYTE *)(a1 + 40) + 1)) + 1;
  if ( *(_DWORD *)(a1 + 40) <= 1u )
  {
    while ( *(_DWORD *)a1 != *(_DWORD *)(a1 + 8) )
    {
      if ( *(_DWORD *)(a1 + 4) == *(_DWORD *)(a1 + 12) )
        break;
      v19 = v29--;
      if ( !v19 )
        break;
      if ( sub_8050B61(*(_DWORD *)a1 - 16, *(_DWORD *)(a1 + 4) - 16) > 0 )
      {
        *(_DWORD *)(a1 + 4) -= 16;
        sub_8052604(*(_DWORD *)(a1 + 4), stream, a4);
      }
      else
      {
        *(_DWORD *)a1 -= 16;
        sub_8052604(*(_DWORD *)a1, stream, a4);
      }
    }
    v33 = (v31 - *(_DWORD *)a1) >> 4;
    v34 = (v32 - *(_DWORD *)(a1 + 4)) >> 4;
    if ( *(_DWORD *)(a1 + 24) == v34 )
    {
      dword_806B360 = (int)&loc_8052A0F;
      sub_8061156();
      *(_DWORD *)a1 -= 16;
      sub_8052604(*(_DWORD *)a1, stream, a4);
      if ( *(_DWORD *)a1 != *(_DWORD *)(a1 + 8) )
      {
        v20 = v29--;
        v21 = v20 == 0;
        v22 = &loc_8052A48;
        if ( !v21 )
          v22 = &loc_80529E7;
        dword_806B2C0 = (int)v22;
        sub_8061526();
      }
    }
    else if ( *(_DWORD *)(a1 + 20) == v33 )
    {
      dword_806B220 = (int)&loc_8052A9A;
      sub_80618EC();
      do
      {
        *(_DWORD *)(a1 + 4) -= 16;
        sub_8052604(*(_DWORD *)(a1 + 4), stream, a4);
        v24 = *(_DWORD *)(a1 + 4);
        v25 = &loc_8052AC3;
        if ( v24 == *(_DWORD *)(a1 + 12) )
          v25 = &loc_8052AD0;
        dword_806B34C = (int)v25;
        sub_80611C6(v23, v24);
        v26 = v29--;
      }
      while ( v26 );
    }
  }
  else
  {
    v30 = **(_DWORD ***)(a1 + 16);
    dword_806B298 = (int)&loc_805275D;
    sub_8061616();
    do
    {
      v4 = *(_DWORD *)a1 - 16;
      v28 = *(_DWORD *)(a1 + 4) - 16;
      if ( sub_8050B61(v4, v28) > 0 )
      {
        v30 -= 4;
        *(_DWORD *)(a1 + 4) -= 16;
        v5 = *(_DWORD **)(a1 + 4);
        v6 = v30;
        *v30 = *v5;
      }
      else
      {
        v30 -= 4;
        *(_DWORD *)a1 -= 16;
        v5 = *(_DWORD **)a1;
        v6 = v30;
        *v30 = **(_DWORD **)a1;
      }
      v6[1] = v5[1];
      v7 = v5[2];
      v6[2] = v7;
      v6[3] = v5[3];
      if ( *(_DWORD *)a1 == *(_DWORD *)(a1 + 8) )
        break;
      v8 = *(_DWORD *)(a1 + 4);
      v9 = &loc_8052795;
      if ( v8 == *(_DWORD *)(a1 + 12) )
        v9 = &loc_80527A6;
      dword_806B324 = (int)v9;
      sub_80612C5(v7, v8);
      v10 = v29--;
    }
    while ( v10 );
    v33 = (v31 - *(_DWORD *)a1) >> 4;
    v11 = v32 - *(_DWORD *)(a1 + 4);
    v34 = (v32 - *(_DWORD *)(a1 + 4)) >> 4;
    v12 = &loc_80527EF;
    if ( *(_DWORD *)(a1 + 24) != v34 )
      v12 = &loc_805285A;
    dword_806B34C = (int)v12;
    sub_80611C6(v7, v11);
    while ( 1 )
    {
      v16 = *(_DWORD *)a1;
      v17 = &loc_8052848;
      if ( *(_DWORD *)a1 == *(_DWORD *)(a1 + 8) )
        v17 = &loc_80528E8;
      dword_806B270 = (int)v17;
      sub_80616F6(v13, v16);
      v18 = v29--;
      if ( !v18 )
        break;
      v30 -= 4;
      *(_DWORD *)a1 -= 16;
      v14 = *(_DWORD **)a1;
      v15 = v30;
      *v30 = **(_DWORD **)a1;
      v15[1] = v14[1];
      v13 = v14[2];
      v15[2] = v13;
      v15[3] = v14[3];
    }
    **(_DWORD **)(a1 + 16) = v30;
  }
  v33 = (v31 - *(_DWORD *)a1) >> 4;
  v34 = (v32 - *(_DWORD *)(a1 + 4)) >> 4;
  *(_DWORD *)(a1 + 20) -= v33;
  result = a1;
  *(_DWORD *)(a1 + 24) -= v34;
  return result;
}
// 8052677: could not find valid save-restore pair for ebx
// 8061156: using guessed type int sub_8061156(void);
// 80611C6: using guessed type int __fastcall sub_80611C6(_DWORD, _DWORD);
// 80612C5: using guessed type int __fastcall sub_80612C5(_DWORD, _DWORD);
// 8061526: using guessed type int sub_8061526(void);
// 8061616: using guessed type int sub_8061616(void);
// 80616F6: using guessed type int __fastcall sub_80616F6(_DWORD, _DWORD);
// 80618EC: using guessed type int sub_80618EC(void);
// 806B220: using guessed type int dword_806B220;
// 806B270: using guessed type int dword_806B270;
// 806B298: using guessed type int dword_806B298;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B324: using guessed type int dword_806B324;
// 806B34C: using guessed type int dword_806B34C;
// 806B360: using guessed type int dword_806B360;

//----- (08052B19) --------------------------------------------------------
int __cdecl sub_8052B19(int a1, int a2)
{
  int result; // eax
  void *v3; // eax
  int v4; // edx
  int v5; // ecx
  void *v6; // eax
  bool v7; // [esp+1Eh] [ebp-Ah]
  bool v8; // [esp+1Fh] [ebp-9h]

  result = *(unsigned __int8 *)(a2 + 44) ^ 1;
  if ( *(_BYTE *)(a2 + 44) != 1 )
  {
    v7 = (unsigned int)(*(_DWORD *)a2 - *(_DWORD *)(a2 + 8) + 15) > 0x1E;
    v8 = (unsigned int)(*(_DWORD *)(a2 + 4) - *(_DWORD *)(a2 + 12) + 15) > 0x1E;
    if ( v7 )
    {
      if ( !v8 )
        *(_DWORD *)(a2 + 24);
      dword_806B220 = (int)&loc_8052C0E;
      sub_80618EC();
    }
    v3 = &loc_8052BC7;
    if ( !v8 )
      v3 = &loc_8052C06;
    dword_806B25C = (int)v3;
    sub_806177B();
    v6 = &loc_8052BEA;
    if ( *(_DWORD *)(a2 + 20) )
      v6 = &loc_8052C06;
    dword_806B324 = (int)v6;
    sub_80612C5(v5, v4);
    dword_806B374 = (int)&loc_8052C0B;
    sub_80610EA();
    result = 0;
  }
  return result;
}
// 8052B19: could not find valid save-restore pair for ebx
// 80610EA: using guessed type int sub_80610EA(void);
// 80612C5: using guessed type int __fastcall sub_80612C5(_DWORD, _DWORD);
// 806177B: using guessed type int sub_806177B(void);
// 80618EC: using guessed type int sub_80618EC(void);
// 806B220: using guessed type int dword_806B220;
// 806B25C: using guessed type int dword_806B25C;
// 806B324: using guessed type int dword_806B324;
// 806B374: using guessed type int dword_806B374;

//----- (08052C26) --------------------------------------------------------
int __cdecl sub_8052C26(int a1, _DWORD *a2)
{
  int result; // eax

  if ( a2[10] <= 1u )
  {
    result = a2[5] + a2[6];
    if ( !result )
      result = sub_805254E(a1, a2[7]);
  }
  else
  {
    sub_80524A3((pthread_mutex_t *)a2[7]);
    sub_8052B19(a1, a2[7]);
    result = sub_80524B9((pthread_mutex_t *)a2[7]);
  }
  return result;
}

//----- (08052C93) --------------------------------------------------------
int __cdecl sub_8052C93(int a1)
{
  pthread_mutex_t *v1; // eax
  bool v2; // zf
  void *v3; // eax
  pthread_mutex_t *v5; // [esp+1Ch] [ebp-Ch]

  v1 = sub_805259B(a1);
  v5 = v1;
  v2 = v1[1].__nusers == 0;
  v3 = &loc_8052CCA;
  if ( !v2 )
    v3 = &loc_8052CE9;
  dword_806B2C0 = (int)v3;
  sub_8061526();
  sub_80524B9(v5);
  return sub_805254E(a1, (int)v5);
}
// 8061526: using guessed type int sub_8061526(void);
// 806B2C0: using guessed type int dword_806B2C0;

//----- (08052D3F) --------------------------------------------------------
void *__cdecl start_routine(void *a1)
{
  sub_8052DAC(
    *(_DWORD *)a1,
    *((_DWORD *)a1 + 1),
    *((_DWORD *)a1 + 2),
    *((_DWORD *)a1 + 3),
    *((_DWORD *)a1 + 4),
    *((FILE **)a1 + 5),
    *((_DWORD *)a1 + 6));
  return 0;
}

//----- (08052DAC) --------------------------------------------------------
int __cdecl sub_8052DAC(int a1, int a2, int a3, int a4, int a5, FILE *stream, int a7)
{
  int result; // eax
  pthread_t newthread; // [esp+28h] [ebp-40h]
  unsigned int v9; // [esp+2Ch] [ebp-3Ch]
  unsigned int v10; // [esp+30h] [ebp-38h]
  int v11; // [esp+34h] [ebp-34h]
  unsigned int v12; // [esp+38h] [ebp-30h]
  unsigned int v13; // [esp+3Ch] [ebp-2Ch]
  int v14; // [esp+40h] [ebp-28h]
  int arg; // [esp+44h] [ebp-24h]
  unsigned int v16; // [esp+48h] [ebp-20h]
  int v17; // [esp+4Ch] [ebp-1Ch]
  int v18; // [esp+50h] [ebp-18h]
  int v19; // [esp+54h] [ebp-14h]
  FILE *v20; // [esp+58h] [ebp-10h]
  int v21; // [esp+5Ch] [ebp-Ch]

  v9 = *(_DWORD *)(a4 + 20) + *(_DWORD *)(a4 + 24);
  v10 = (unsigned int)a2 >> 1;
  v11 = a2 - ((unsigned int)a2 >> 1);
  arg = a1;
  v16 = (unsigned int)a2 >> 1;
  v17 = a3;
  v18 = *(_DWORD *)(a4 + 32);
  v19 = a5;
  v20 = stream;
  v21 = a7;
  if ( (unsigned int)a2 <= 1 || v9 <= 0x1FFFF || pthread_create(&newthread, 0, start_routine, &arg) )
  {
    v12 = *(_DWORD *)(a4 + 20);
    v13 = *(_DWORD *)(a4 + 24);
    v14 = -16 * a3 + a1;
    if ( v13 > 1 )
      sub_8051F04(-16 * v12 + a1, v13, -16 * (v12 >> 1) + v14, 0);
    if ( v12 > 1 )
      sub_8051F04(a1, v12, v14, 0);
    *(_DWORD *)a4 = a1;
    *(_DWORD *)(a4 + 4) = a1 - 16 * v12;
    *(_DWORD *)(a4 + 8) = a1 - 16 * v12;
    *(_DWORD *)(a4 + 12) = a1 + -16 * v12 - 16 * v13;
    sub_805254E(a5, a4);
    result = sub_8052C93(a5);
  }
  else
  {
    sub_8052DAC(a1 - 16 * *(_DWORD *)(a4 + 20), v11, a3, *(_DWORD *)(a4 + 36), a5, stream, a7);
    result = pthread_join(newthread, 0);
  }
  return result;
}

//----- (08052FB0) --------------------------------------------------------
int __cdecl sub_8052FB0(int a1, int a2, int a3, char *s1)
{
  bool v4; // zf
  int v5; // edx
  int v6; // ecx
  void *v7; // eax
  int result; // eax
  void *v9; // eax
  void *v10; // eax
  char v11; // al
  char v12; // [esp+21h] [ebp-D7h]
  char v13; // [esp+22h] [ebp-D6h]
  bool v14; // [esp+23h] [ebp-D5h]
  FILE *stream; // [esp+24h] [ebp-D4h]
  int v16; // [esp+28h] [ebp-D0h]
  unsigned int i; // [esp+2Ch] [ebp-CCh]
  __int64 v18; // [esp+30h] [ebp-C8h]
  __int64 v19; // [esp+88h] [ebp-70h]
  __int64 v20; // [esp+90h] [ebp-68h]
  __int64 v21; // [esp+E8h] [ebp-10h]

  v12 = 0;
  v16 = 0;
  for ( i = a2; ; ++i )
  {
    result = i;
    if ( i >= a3 )
      break;
    v14 = strcmp(*(const char **)(8 * i + a1), "-") == 0;
    if ( s1 )
    {
      v4 = strcmp(s1, *(const char **)(8 * i + a1)) == 0;
      v7 = &loc_805304F;
      if ( !v4 )
        v7 = &loc_8053069;
      dword_806B310 = (int)v7;
      sub_8061339(v6, v5);
      if ( v14 != 1 )
      {
        v13 = 1;
        goto LABEL_21;
      }
    }
    if ( v12 != 1 )
    {
      result = sub_8061048(1, (int)&v18);
      if ( result )
        return result;
      v12 = 1;
    }
    if ( v14 )
    {
      v4 = sub_8061048(0, (int)&v20) == 0;
      v9 = &loc_80530D5;
      if ( v4 )
        v9 = &loc_80530FE;
      dword_806B248 = (int)v9;
      sub_80617ED();
LABEL_19:
      v11 = 0;
      goto LABEL_20;
    }
    if ( sub_8061019(*(_DWORD *)(8 * i + a1), (int)&v20) )
      goto LABEL_19;
    v10 = &loc_805312F;
    if ( v21 != v19 )
      v10 = &loc_8053154;
    dword_806B270 = (int)v10;
    sub_80616F6(v21, HIDWORD(v19));
    if ( v20 != v18 )
      goto LABEL_19;
    v11 = 1;
LABEL_20:
    v13 = v11 & 1;
LABEL_21:
    if ( v13 )
    {
      if ( !v16 )
      {
        v16 = sub_804C97B(&stream);
        sub_8051D6A(8 * i + a1, 0, 1);
      }
      *(_DWORD *)(8 * i + a1) = v16 + 9;
      *(_DWORD *)(a1 + 8 * i + 4) = v16;
    }
  }
  return result;
}
// 8061339: using guessed type int __fastcall sub_8061339(_DWORD, _DWORD);
// 80616F6: using guessed type int __fastcall sub_80616F6(_DWORD, _DWORD);
// 80617ED: using guessed type int sub_80617ED(void);
// 806B248: using guessed type int dword_806B248;
// 806B270: using guessed type int dword_806B270;
// 806B310: using guessed type int dword_806B310;

//----- (08053229) --------------------------------------------------------
unsigned int __cdecl sub_8053229(int a1, unsigned int a2)
{
  bool v2; // zf
  void *v3; // eax
  int v4; // edx
  int v5; // ecx
  int v6; // ebx
  char *v7; // eax
  unsigned int result; // eax
  unsigned int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a2 )
      break;
    v2 = strcmp(*(const char **)(4 * i + a1), "-") == 0;
    v3 = &loc_805327A;
    if ( !v2 )
      v3 = &loc_8053291;
    dword_806B284 = (int)v3;
    sub_8061686();
    dword_806B310 = (int)&loc_80532DF;
    sub_8061339(v5, v4);
    if ( euidaccess(*(_DWORD *)(4 * i + a1), 4) )
    {
      v6 = *(_DWORD *)(4 * i + a1);
      v7 = gettext("cannot read");
      sub_804BA86((int)v7, v6);
    }
  }
  return result;
}
// 8049E00: using guessed type int __cdecl euidaccess(_DWORD, _DWORD);
// 8061339: using guessed type int __fastcall sub_8061339(_DWORD, _DWORD);
// 8061686: using guessed type int sub_8061686(void);
// 806B284: using guessed type int dword_806B284;
// 806B310: using guessed type int dword_806B310;

//----- (080532F5) --------------------------------------------------------
void __cdecl sub_80532F5(int a1)
{
  int v1; // edx
  int v2; // ecx
  char *v3; // eax
  int fd; // [esp+1Ch] [ebp-Ch]

  if ( a1 )
  {
    fd = open64(a1, 524353);
    if ( fd < 0 )
    {
      v3 = gettext("open failed");
      sub_804BA86((int)v3, a1);
    }
    sub_804C624(v1, v2, fd, 1);
  }
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);

//----- (0805335B) --------------------------------------------------------
void __cdecl __noreturn sub_805335B(int a1, int a2, int a3, char *s1)
{
  int v4; // eax
  char *v5; // esi
  int v6; // eax
  int v7; // eax
  char *v8; // ebx
  int v9; // eax
  int v10; // eax
  int v11; // edx
  int v12; // ecx
  bool v13; // zf
  void *v14; // eax
  char *v15; // eax
  int v16; // eax
  _BOOL4 v17; // [esp+4h] [ebp-74h]
  FILE *v18; // [esp+Ch] [ebp-6Ch]
  char *v19; // [esp+10h] [ebp-68h]
  void *v20; // [esp+14h] [ebp-64h]
  void *v21; // [esp+28h] [ebp-50h]
  FILE *v22; // [esp+2Ch] [ebp-4Ch]
  int v23; // [esp+30h] [ebp-48h]
  unsigned int v24; // [esp+34h] [ebp-44h]
  int v25; // [esp+38h] [ebp-40h]
  int v26; // [esp+3Ch] [ebp-3Ch]
  int v27; // [esp+44h] [ebp-34h]
  unsigned int v28; // [esp+48h] [ebp-30h]
  int v29; // [esp+4Ch] [ebp-2Ch]
  int v30; // [esp+50h] [ebp-28h]
  FILE *stream; // [esp+58h] [ebp-20h]
  int v32; // [esp+5Ch] [ebp-1Ch]

  dword_806B360 = (int)&loc_8053567;
  sub_8061156();
  while ( 1 )
  {
    v23 = 0;
    v24 = 0;
    if ( a3 - v23 >= (unsigned int)dword_806B430 )
      break;
    v27 = a3 - v23;
    v28 = dword_806B430 - v24 % dword_806B430;
    if ( dword_806B430 - v24 % dword_806B430 < a3 - v23 )
    {
      v29 = v27 - v28 + 1;
      v7 = sub_804C97B(&v22);
      v30 = v7;
      v8 = (char *)(v7 + 9);
      v9 = a2;
      if ( v29 <= (unsigned int)a2 )
        v9 = v29;
      v19 = v8;
      v18 = v22;
      sub_8051D6A(8 * v23 + a1, v9, v29);
    }
    memmove((void *)(8 * v24 + a1), (const void *)(a1 + 8 * v23), 8 * (a3 - v23));
    a2 += v24;
    a3 += v24 - v23;
    if ( dword_806B430 >= (unsigned int)a3 )
    {
      sub_8052FB0(a1, a2, a3, s1);
      v10 = sub_8051279(a1, a3, &v21);
      v25 = v10;
      v13 = v10 == a3;
      v14 = &loc_80535D2;
      if ( !v13 )
        v14 = &loc_8053650;
      dword_806B34C = (int)v14;
      sub_80611C6(v12, v11);
      stream = sub_804C3B1(s1, "w");
      if ( stream )
      {
        v20 = v21;
        v19 = s1;
        v18 = stream;
        sub_8051399(a1, a2, a3);
      }
      if ( *__errno_location() != 24 || (unsigned int)v25 <= 2 )
      {
        v15 = gettext("open failed");
        sub_804BA86((int)v15, (int)s1);
      }
      do
      {
        --v25;
        sub_804C560(*((FILE **)v21 + v25), *(_DWORD *)(8 * v25 + a1));
        v17 = (unsigned int)v25 > 2;
        v32 = sub_804C816(&v22, v17);
      }
      while ( !v32 );
      v16 = a2;
      if ( v25 <= (unsigned int)a2 )
        v16 = v25;
      v20 = v21;
      v19 = (char *)(v32 + 9);
      v18 = v22;
      sub_8051399(a1, v16, v25);
    }
  }
  v4 = sub_804C97B(&v22);
  v26 = v4;
  v5 = (char *)(v4 + 9);
  v6 = a2;
  if ( dword_806B430 <= (unsigned int)a2 )
    v6 = dword_806B430;
  v19 = v5;
  v18 = v22;
  sub_8051D6A(8 * v23 + a1, v6, dword_806B430);
}
// 8061156: using guessed type int sub_8061156(void);
// 80611C6: using guessed type int __fastcall sub_80611C6(_DWORD, _DWORD);
// 806B34C: using guessed type int dword_806B34C;
// 806B360: using guessed type int dword_806B360;
// 806B42C: using guessed type int dword_806B42C;

//----- (08053791) --------------------------------------------------------
int __cdecl sub_8053791(int a1, int a2, char *a3)
{
  void *v3; // eax
  int result; // eax
  _DWORD *v6; // [esp+5Ch] [ebp-8Ch]
  int v7; // [esp+60h] [ebp-88h]
  _DWORD *v8; // [esp+70h] [ebp-78h]
  void *ptr; // [esp+74h] [ebp-74h]

  v3 = &loc_8053AFE;
  if ( a2 )
    v3 = &loc_80537D5;
  dword_806B284 = (int)v3;
  sub_8061686();
  free(ptr);
  v6 = (_DWORD *)dword_806C264;
  v8 = sub_805E027(0, 8u);
  v7 = 0;
  while ( v6 )
  {
    v8[2 * v7] = (char *)v6 + 9;
    v8[2 * v7 + 1] = v6;
    v6 = (_DWORD *)*v6;
    ++v7;
  }
  sub_805335B((int)v8, 0, 0, a3);
  return result;
}
// 8061686: using guessed type int sub_8061686(void);
// 806B284: using guessed type int dword_806B284;
// 806C264: using guessed type int dword_806C264;

//----- (08053BF4) --------------------------------------------------------
_DWORD *__cdecl sub_8053BF4(void *src)
{
  void *v1; // eax
  _DWORD *result; // eax
  _DWORD *v3; // [esp+1Ch] [ebp-Ch]

  v3 = sub_805E268(src, 0x28u);
  v1 = &loc_8053C46;
  if ( dword_806C1D8 )
    v1 = &loc_8053C19;
  dword_806B25C = (int)v1;
  sub_806177B();
  dword_806C1D8 = (int)v3;
  result = v3;
  v3[9] = 0;
  return result;
}
// 806177B: using guessed type int sub_806177B(void);
// 806B25C: using guessed type int dword_806B25C;
// 806C1D8: using guessed type int dword_806C1D8;

//----- (08053C5A) --------------------------------------------------------
unsigned int __cdecl sub_8053C5A(int a1, char *msgid)
{
  void *v2; // esi
  char *v3; // ebx
  char *v4; // eax

  v2 = sub_805BC36((char *)a1);
  v3 = gettext(msgid);
  v4 = gettext("%s: invalid field specification %s");
  error(2, 0, v4, v3, v2);
  return sub_8053CA8(a1);
}

//----- (08053CA8) --------------------------------------------------------
unsigned int __cdecl sub_8053CA8(int a1)
{
  char *v1; // eax

  v1 = gettext("options '-%s' are incompatible");
  error(2, 0, v1, a1);
  return sub_8053CD9();
}

//----- (08053CD9) --------------------------------------------------------
unsigned int sub_8053CD9()
{
  int v0; // eax
  bool v1; // zf
  bool v2; // sf
  unsigned __int8 v3; // of
  void *v4; // eax
  int v6; // [esp+0h] [ebp-48h]
  int v7; // [esp+4h] [ebp-44h]
  int i; // [esp+18h] [ebp-30h]
  char v9; // [esp+1Dh] [ebp-2Bh]
  unsigned int v10; // [esp+3Ch] [ebp-Ch]

  v10 = __readgsdword(0x14u);
  for ( i = dword_806C1D8; i; i = *(_DWORD *)(i + 36) )
  {
    v0 = *(unsigned __int8 *)(i + 29)
       + *(unsigned __int8 *)(i + 28)
       + *(unsigned __int8 *)(i + 26)
       + *(unsigned __int8 *)(i + 30)
       + (*(unsigned __int8 *)(i + 27) | *(unsigned __int8 *)(i + 32) | (*(_DWORD *)(i + 16) != 0));
    v3 = __OFSUB__(v0, 1);
    v1 = v0 == 1;
    v2 = v0 - 1 < 0;
    v4 = &loc_8053D6C;
    if ( (unsigned __int8)(v2 ^ v3) | v1 )
      v4 = &loc_8053DAA;
    dword_806B2D4 = (int)v4;
    sub_80614AE(v6, v7);
    *(_BYTE *)(i + 31) = 0;
    *(_BYTE *)(i + 25) = *(_BYTE *)(i + 31);
    *(_BYTE *)(i + 24) = *(_BYTE *)(i + 25);
    sub_804F3DF(i, &v9);
    sub_8053CA8((int)&v9);
  }
  return __readgsdword(0x14u) ^ v10;
}
// 806B2D4: using guessed type int dword_806B2D4;
// 806C1D8: using guessed type int dword_806C1D8;

//----- (08053DD0) --------------------------------------------------------
int __usercall sub_8053DD0@<eax>(int a1@<edx>, int a2@<ecx>, char *nptr, int a4, char *msgid)
{
  void *v5; // eax
  void *v6; // esi
  char *v7; // ebx
  char *v8; // eax
  int result; // eax
  int v10; // [esp+24h] [ebp-14h]
  __int64 v11; // [esp+28h] [ebp-10h]

  switch ( sub_805EC32(a1, a2, nptr, (int)&v10, 10, (int)&v11, &s) )
  {
    case 0:
    case 2:
      *(_DWORD *)a4 = v11;
      v5 = &loc_8053E57;
      if ( v11 != *(_DWORD *)a4 )
        v5 = &loc_8053E59;
      dword_806B374 = (int)v5;
      sub_80610EA();
      goto LABEL_9;
    case 1:
    case 3:
      *(_DWORD *)a4 = -1;
      goto LABEL_9;
    case 4:
      if ( msgid )
      {
        v6 = sub_805BC36(nptr);
        v7 = gettext(msgid);
        v8 = gettext("%s: invalid count at start of %s");
        error(2, 0, v8, v7, v6);
      }
      result = 0;
      break;
    default:
LABEL_9:
      result = v10;
      break;
  }
  return result;
}
// 80610EA: using guessed type int sub_80610EA(void);
// 806B374: using guessed type int dword_806B374;

//----- (08053EC1) --------------------------------------------------------
int __cdecl sub_8053EC1(int sig)
{
  sub_804C139();
  signal(sig, 0);
  return raise(sig);
}

//----- (08053EEC) --------------------------------------------------------
_BYTE *__usercall sub_8053EEC@<eax>(int a1@<edx>, int a2@<ecx>, _BYTE *a3, int a4, int a5)
{
  int v5; // edx
  int v6; // ecx
  void *v7; // eax
  void *v8; // eax

  dword_806B2AC = (int)&loc_805407F;
  sub_806159C(a2, a1);
  do
  {
    switch ( *a3 )
    {
      case 77:
        *(_BYTE *)(a4 + 30) = 1;
        break;
      case 82:
        *(_BYTE *)(a4 + 27) = 1;
        break;
      case 86:
        goto LABEL_22;
      case 98:
        v7 = &loc_8053F43;
        if ( !a5 )
          v7 = &loc_8053F49;
        dword_806B324 = (int)v7;
        sub_80612C5(v6, v5);
        if ( a5 == 2 )
          *(_BYTE *)(a4 + 24) = 1;
        if ( a5 == 1 || a5 == 2 )
        {
          *(_BYTE *)(a4 + 25) = 1;
          dword_806B298 = (int)&loc_805407B;
          sub_8061616();
        }
        break;
      case 100:
        *(_DWORD *)(a4 + 16) = &unk_806BFC4;
        break;
      case 102:
        *(_DWORD *)(a4 + 20) = byte_806C0C4;
        break;
      case 103:
        *(_BYTE *)(a4 + 28) = 1;
        dword_806B2AC = (int)&loc_805407B;
        sub_806159C(v6, v5);
        goto LABEL_14;
      case 104:
LABEL_14:
        *(_BYTE *)(a4 + 29) = 1;
        dword_806B2AC = (int)&loc_805407B;
        sub_806159C(v6, v5);
        goto LABEL_15;
      case 105:
LABEL_15:
        v8 = &loc_8053FFC;
        if ( *(_DWORD *)(a4 + 16) )
          v8 = &loc_805401D;
        dword_806B298 = (int)v8;
        sub_8061616();
        *(_DWORD *)(a4 + 16) = &unk_806BEC4;
        dword_806B2C0 = (int)&loc_805407B;
        sub_8061526();
        break;
      case 110:
        *(_BYTE *)(a4 + 26) = 1;
        break;
      case 114:
        *(_BYTE *)(a4 + 31) = 1;
        dword_806B20C = (int)&loc_805407B;
        sub_806195A();
LABEL_22:
        *(_BYTE *)(a4 + 32) = 1;
        break;
      default:
        dword_806B298 = (int)&loc_8054090;
        sub_8061616();
        break;
    }
    ++a3;
  }
  while ( *a3 );
  return a3;
}
// 8053EEC: could not find valid save-restore pair for ebx
// 80612C5: using guessed type int __fastcall sub_80612C5(_DWORD, _DWORD);
// 8061526: using guessed type int sub_8061526(void);
// 806159C: using guessed type int __fastcall sub_806159C(_DWORD, _DWORD);
// 8061616: using guessed type int sub_8061616(void);
// 806195A: using guessed type int sub_806195A(void);
// 806B20C: using guessed type int dword_806B20C;
// 806B298: using guessed type int dword_806B298;
// 806B2AC: using guessed type int dword_806B2AC;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B324: using guessed type int dword_806B324;

//----- (08054092) --------------------------------------------------------
void *__cdecl sub_8054092(void *s)
{
  memset(s, 0, 0x28u);
  *((_DWORD *)s + 2) = -1;
  return s;
}

//----- (080540C2) --------------------------------------------------------
void __cdecl main(int argc, char **argv)
{
  bool v2; // al
  unsigned __int8 **v3; // eax
  unsigned __int8 v4; // al
  int v5; // edx
  int v6; // ecx
  void *v7; // eax
  unsigned __int8 v8; // al
  bool v9; // zf
  void *v10; // eax
  int v11; // edx
  int v12; // ecx
  void *v13; // eax
  int v14; // edx
  int v15; // ecx
  void *v16; // eax
  unsigned __int64 v17; // rax
  int v18; // ecx
  void *v19; // eax
  void *v20; // eax
  void *v21; // eax
  void *v22; // eax
  int v23; // eax
  char **v24; // ecx
  int v25; // eax
  void *v26; // eax
  void *v27; // eax
  char v28; // al
  int v29; // edx
  _BOOL4 v30; // eax
  int v31; // ecx
  int v32; // edx
  int v33; // ecx
  void *v34; // eax
  void *v35; // eax
  void *v36; // eax
  int v37; // edx
  int v38; // ecx
  int v39; // eax
  int v40; // edx
  int v41; // ecx
  void *v42; // eax
  int v43; // edx
  int v44; // ecx
  int v45; // edx
  int v46; // ecx
  char *v47; // eax
  _DWORD *v48; // eax
  int v49; // ecx
  int v50; // eax
  void *v51; // eax
  int v52; // edx
  int v53; // ecx
  void *v54; // eax
  int v55; // ecx
  int v56; // eax
  int v57; // ecx
  _DWORD *v58; // edx
  int v59; // edx
  int v60; // ecx
  int v61; // eax
  int v62; // ecx
  _DWORD *v63; // edx
  void *v64; // eax
  char *v65; // eax
  char *v66; // eax
  char *v67; // eax
  void *v68; // eax
  char *v69; // ebx
  char *v70; // eax
  char *v71; // eax
  char *v72; // edx
  void *v73; // eax
  int v74; // edx
  int v75; // ecx
  int v76; // edx
  int v77; // ecx
  void *v78; // eax
  void *v79; // eax
  void *v80; // eax
  int v81; // edx
  int v82; // ecx
  void *v83; // eax
  char *v84; // eax
  char *v85; // ebx
  char *v86; // eax
  int v87; // edx
  int v88; // ecx
  const char *v89; // eax
  void *v90; // eax
  int v91; // eax
  int (*v92)(); // eax
  int v93; // [esp+0h] [ebp-17Ch]
  char *v94; // [esp+4h] [ebp-178h]
  char *v95; // [esp+Ch] [ebp-170h]
  const char *v96; // [esp+10h] [ebp-16Ch]
  const char *v97; // [esp+14h] [ebp-168h]
  int v98; // [esp+18h] [ebp-164h]
  char v99; // [esp+2Dh] [ebp-14Fh]
  char v100; // [esp+2Eh] [ebp-14Eh]
  char v101; // [esp+2Fh] [ebp-14Dh]
  bool v102; // [esp+30h] [ebp-14Ch]
  unsigned __int8 v103; // [esp+31h] [ebp-14Bh]
  bool v104; // [esp+32h] [ebp-14Ah]
  char v105; // [esp+33h] [ebp-149h]
  bool v106; // [esp+34h] [ebp-148h]
  char v107; // [esp+35h] [ebp-147h]
  char v108; // [esp+36h] [ebp-146h]
  char v109; // [esp+37h] [ebp-145h]
  _DWORD *v110; // [esp+38h] [ebp-144h]
  _BYTE *v111; // [esp+3Ch] [ebp-140h]
  int v112; // [esp+40h] [ebp-13Ch]
  const char *v113; // [esp+44h] [ebp-138h]
  int v114; // [esp+48h] [ebp-134h]
  unsigned int v115; // [esp+4Ch] [ebp-130h]
  char **v116; // [esp+50h] [ebp-12Ch]
  char *v117; // [esp+54h] [ebp-128h]
  char *v118; // [esp+58h] [ebp-124h]
  unsigned int i; // [esp+5Ch] [ebp-120h]
  char *v120; // [esp+60h] [ebp-11Ch]
  unsigned int j; // [esp+68h] [ebp-114h]
  int v122; // [esp+6Ch] [ebp-110h]
  unsigned __int8 **v123; // [esp+70h] [ebp-10Ch]
  char *v124; // [esp+74h] [ebp-108h]
  char *v125; // [esp+80h] [ebp-FCh]
  _DWORD *v126; // [esp+84h] [ebp-F8h]
  char v127; // [esp+90h] [ebp-ECh]
  char s; // [esp+B8h] [ebp-C4h]
  unsigned __int8 v129; // [esp+D3h] [ebp-A9h]
  char v130; // [esp+D7h] [ebp-A5h]
  int longind; // [esp+E0h] [ebp-9Ch]
  __sigset_t v132; // [esp+E4h] [ebp-98h]
  int v133; // [esp+164h] [ebp-18h]

  v99 = 0;
  v112 = 0;
  v100 = 0;
  v101 = 0;
  v113 = 0;
  v102 = 0;
  v114 = 0;
  v115 = 0;
  v106 = getenv("POSIXLY_CORRECT") != 0;
  v122 = sub_8059EAB();
  v2 = v122 <= 200111 || v122 > 200808;
  v103 = v2;
  v117 = 0;
  v118 = 0;
  sub_8059F22(*argv);
  v104 = setlocale(6, &::s) != 0;
  bindtextdomain("coreutils", "/home/hwangdz/coreutils/coreutils-8.28/install_m32/share/locale");
  textdomain("coreutils");
  sub_804B708(2);
  byte_806BDAC = sub_805782D(3);
  byte_806BDAD = sub_805782D(2);
  v3 = (unsigned __int8 **)localeconv();
  v123 = v3;
  v4 = sub_804B734(**v3);
  dword_806BDA4 = v4;
  if ( v4 )
  {
    v7 = &loc_805422B;
    if ( !(*v123)[1] )
      v7 = &loc_8054235;
    dword_806B34C = (int)v7;
    sub_80611C6(v6, v5);
  }
  dword_806BDA4 = 46;
  v8 = sub_804B734(*v123[1]);
  dword_806BDA8 = v8;
  v9 = v8 == 0;
  v10 = &loc_8054274;
  if ( v9 )
    v10 = &loc_805429E;
  dword_806B234 = (int)v10;
  sub_806185D();
  v13 = &loc_805429E;
  if ( !v123[1][1] )
    v13 = &loc_80542A8;
  dword_806B324 = (int)v13;
  sub_80612C5(v12, v11);
  dword_806BDA8 = -1;
  byte_806C1D7 = 0;
  sub_804CD3D();
  sigemptyset(&set);
  for ( i = 0; i <= 0xA; ++i )
  {
    sigaction(sig[i], 0, (struct sigaction *)&longind);
    v16 = &loc_8054315;
    if ( longind == 1 )
      v16 = &loc_8054330;
    dword_806B324 = (int)v16;
    sub_80612C5(v15, v14);
    sigaddset(&set, sig[i]);
  }
  longind = (int)sub_8053EC1;
  qmemcpy(&v132, &set, sizeof(v132));
  v133 = 0;
  for ( i = 0; i <= 0xA; ++i )
  {
    if ( sigismember(&set, sig[i]) )
      sigaction(sig[i], (const struct sigaction *)&longind, 0);
  }
  signal(17, 0);
  sub_8060FEA((int)sub_804C171);
  sub_8054092(&s);
  *(_DWORD *)&s = -1;
  v116 = (char **)sub_805E027(argc, 4u);
  while ( 1 )
  {
    longind = -1;
    if ( v112 != -1 )
    {
      if ( !v106 || !v115 )
        goto LABEL_39;
      if ( v103 == 1 )
      {
        v19 = &loc_8054473;
        if ( v100 )
          v19 = &loc_8054565;
        dword_806B20C = (int)v19;
        sub_806195A();
        if ( optind != argc )
          break;
      }
    }
LABEL_40:
    if ( argc <= optind )
    {
      LODWORD(v17) = &loc_805458F;
      if ( v117 )
        LODWORD(v17) = &loc_80550CC;
      dword_806B2AC = v17;
      sub_806159C(v18, HIDWORD(v17));
      v110 = (_DWORD *)dword_806C1D8;
      v73 = &loc_805548B;
      if ( v110 )
        v73 = &loc_805537B;
      dword_806B220 = (int)v73;
      sub_80618EC();
      if ( !dword_806C1D8 && (unsigned __int8)sub_804F309(v74, v75, (int)&s) ^ 1 )
      {
        v99 = 1;
        sub_8053BF4(&s);
        v102 = (v102 | v129) != 0;
      }
      sub_8053CD9();
      if ( byte_806C1E0 )
      {
        v78 = &loc_805550D;
        if ( v100 )
          v78 = &loc_8055514;
        dword_806B248 = (int)v78;
        sub_80617ED();
        if ( v118 )
        {
          if ( v100 )
          {
            dword_806B234 = (int)&loc_805553C;
            sub_806185D();
          }
          byte_806B438 = 111;
          sub_8053CA8((int)&byte_806B438);
        }
        v79 = &loc_805556D;
        if ( !v104 )
          v79 = &loc_805558A;
        dword_806B2FC = (int)v79;
        sub_80613B1();
        v104 = setlocale(3, &::s) != 0;
        v80 = &loc_80555AF;
        if ( v104 == 1 )
          v80 = &loc_80555DB;
        dword_806B374 = (int)v80;
        sub_80610EA();
        v95 = gettext("failed to set locale");
        error(0, 0, "%s", v95);
        v83 = &loc_80555FF;
        if ( !byte_806BDAC )
          v83 = &loc_8055647;
        dword_806B270 = (int)v83;
        sub_80616F6(v82, v81);
        v84 = setlocale(3, 0);
        v85 = (char *)sub_805BC36(v84);
        v86 = gettext("using %s sorting rules");
        v95 = v85;
        error(0, 0, v86, v85);
        sub_804F559(v88, v87, (int *)&s, v99);
      }
      byte_806C1D4 = v130;
      if ( v102 )
        sub_804E6ED((int)v113);
      if ( !dword_806C1CC )
      {
        v125 = getenv("TMPDIR");
        if ( v125 )
          v89 = v125;
        else
          v89 = "/tmp";
        sub_804CB6E((int)v89);
      }
      if ( !v115 )
      {
        v115 = 1;
        free(v116);
        v116 = (char **)sub_805E14D(4u);
        *v116 = "-";
      }
      v90 = &loc_805573E;
      if ( !size )
        v90 = &loc_805575E;
      dword_806B2E8 = (int)v90;
      sub_8061429(v77, v76);
      v91 = size;
      if ( 18 * dword_806B430 >= size )
        v91 = 18 * dword_806B430;
      size = v91;
      if ( v100 )
      {
        if ( v115 > 1 )
        {
          v94 = v116[1];
          sub_805B8A3(4);
        }
        if ( v118 )
        {
          byte_806B442 = v100;
          sub_8053CA8((int)&byte_806B442);
        }
        sub_8050E87(*v116, v100);
      }
      sub_8053229((int)v116, v115);
      sub_80532F5((int)v118);
      v92 = (int (*)())&loc_8055845;
      if ( !v101 )
        v92 = sub_80558CB;
      dword_806B248 = (int)v92;
      sub_80617ED();
      v126 = sub_805E22B(v115, 8u);
      for ( j = 0; j < v115; ++j )
        v126[2 * j] = v116[j];
      sub_805335B((int)v126, 0, v115, v118);
    }
    v23 = v115++;
    v24 = &v116[v23];
    v25 = optind++;
    *v24 = argv[v25];
    dword_806B298 = (int)&loc_80550C7;
    sub_8061616();
LABEL_45:
    switch ( v112 )
    {
      case 4294967165:
        v98 = 0;
        v97 = "Paul Eggert";
        v96 = "Mike Haertel";
        sub_805DF87(stdout, (int)"sort", (int)"GNU coreutils", off_806B448, "Mike Haertel", "Paul Eggert", 0);
        exit(0);
        return;
      case 4294967166:
        sub_804BB01(0);
        return;
      case 1:
        v110 = 0;
        v26 = &loc_805462C;
        if ( *optarg != 43 )
          v26 = &loc_8054925;
        dword_806B2C0 = (int)v26;
        sub_8061526();
        if ( optind == argc )
          goto LABEL_205;
        v27 = &loc_8054669;
        if ( *argv[optind] != 45 )
          v27 = &loc_8054694;
        dword_806B360 = (int)v27;
        sub_8061156();
        if ( (unsigned int)(argv[optind][1] - 48) > 9 )
LABEL_205:
          v28 = 0;
        else
          v28 = 1;
        v107 = v28 & 1;
        v29 = v103;
        v30 = v28 & 1 && v106 != 1;
        v103 = (v103 | v30) != 0;
        if ( v103 )
        {
          v110 = sub_8054092(&v127);
          v111 = (_BYTE *)sub_8053DD0((int)(optarg + 1), v31, optarg + 1, (int)v110, 0);
          if ( v111 && *v111 == 46 )
            v111 = (_BYTE *)sub_8053DD0((int)(v110 + 1), v33, v111 + 1, (int)(v110 + 1), 0);
          v34 = &loc_805476F;
          if ( *v110 )
            v34 = &loc_805479D;
          dword_806B34C = (int)v34;
          sub_80611C6(v33, v32);
          v35 = &loc_8054793;
          if ( v110[1] )
            v35 = &loc_805479D;
          dword_806B374 = (int)v35;
          sub_80610EA();
          *v110 = -1;
          v36 = &loc_80547BD;
          if ( !v111 )
            v36 = &loc_80547E0;
          dword_806B2D4 = (int)v36;
          sub_80614AE(v93, v94);
          if ( *sub_8053EEC(v37, v38, v111, (int)v110, 0) )
          {
            v110 = 0;
          }
          else
          {
            if ( v107 )
            {
              v39 = optind++;
              v124 = argv[v39];
              v111 = (_BYTE *)sub_8053DD0((int)(v110 + 2), v18, v124 + 1, (int)(v110 + 2), "invalid number after '-'");
              if ( !v111 )
                __assert_fail("s", "src/sort.c", 0x110Du, "main");
              if ( *v111 == 46 )
                v111 = (_BYTE *)sub_8053DD0((int)(v110 + 3), v41, v111 + 1, (int)(v110 + 3), "invalid number after '.'");
              v42 = &loc_80548BE;
              if ( v110[3] )
                v42 = &loc_80548DA;
              dword_806B2AC = (int)v42;
              sub_806159C(v41, v40);
              if ( v110[2] )
              {
                v43 = v110[2] - 1;
                v110[2] = v43;
              }
              if ( *sub_8053EEC(v43, v44, v111, (int)v110, 1) )
                sub_8053C5A((int)v124, "stray character in field spec");
            }
            *((_BYTE *)v110 + 33) = 1;
            sub_8053BF4(v110);
          }
        }
        if ( v110 )
        {
          dword_806B324 = (int)&loc_80550C7;
          sub_80612C5(v18, v29);
LABEL_85:
          v97 = (const char *)off_806B44C;
          v112 = byte_8062FD8[sub_8055C6B((int)"--sort", optarg, (int)&off_8062FBC, (int)byte_8062FD8, 1u)];
LABEL_86:
          v108 = v112;
          v109 = 0;
          sub_8053EEC(SHIDWORD(v17), v18, &v108, (int)&s, 2);
        }
        else
        {
          LODWORD(v17) = v115++;
          HIDWORD(v17) = &v116[v17];
          *(_DWORD *)HIDWORD(v17) = optarg;
        }
        break;
      case 67:
      case 99:
        goto LABEL_91;
      case 77:
      case 82:
      case 86:
      case 98:
      case 100:
      case 102:
      case 103:
      case 104:
      case 105:
      case 110:
      case 114:
        goto LABEL_86;
      case 83:
        v17 = sub_804D1A3((char)v112, (int)optarg, longind, (char)v112, optarg);
        continue;
      case 84:
        sub_804CB6E((int)optarg);
        continue;
      case 107:
        v48 = sub_8054092(&v127);
        v110 = v48;
        v94 = (char *)v48;
        v111 = (_BYTE *)sub_8053DD0((int)v94, v49, optarg, (int)v94, "invalid number at field start");
        v50 = (*v110)--;
        v9 = v50 == 0;
        v51 = &loc_8054B6B;
        if ( !v9 )
          v51 = &loc_8054B80;
        dword_806B338 = (int)v51;
        sub_8061251();
        sub_8053C5A((int)optarg, "field number is zero");
        v54 = &loc_8054BA4;
        if ( *v111 != 46 )
          v54 = &loc_8054BF4;
        dword_806B310 = (int)v54;
        sub_8061339(v53, v52);
        v111 = (_BYTE *)sub_8053DD0((int)(v110 + 1), v55, v111 + 1, (int)(v110 + 1), "invalid number after '.'");
        v56 = v110[1];
        v57 = v56 - 1;
        v58 = v110;
        v110[1] = v56 - 1;
        if ( !v56 )
          sub_8053C5A((int)optarg, "character offset is zero");
        if ( !*v110 && !v110[1] )
          *v110 = -1;
        v111 = sub_8053EEC((int)v58, v57, v111, (int)v110, 0);
        if ( *v111 == 44 )
        {
          v111 = (_BYTE *)sub_8053DD0((int)(v110 + 2), v60, v111 + 1, (int)(v110 + 2), "invalid number after ','");
          v61 = v110[2];
          v62 = v61 - 1;
          v63 = v110;
          v110[2] = v61 - 1;
          if ( !v61 )
            sub_8053C5A((int)optarg, "field number is zero");
          if ( *v111 == 46 )
            v111 = (_BYTE *)sub_8053DD0((int)(v110 + 3), v62, v111 + 1, (int)(v110 + 3), "invalid number after '.'");
          v111 = sub_8053EEC((int)v63, v62, v111, (int)v110, 1);
        }
        else
        {
          v110[2] = -1;
          v110[3] = 0;
        }
        v64 = &loc_8054D1E;
        if ( !*v111 )
          v64 = &loc_8054D33;
        dword_806B2E8 = (int)v64;
        sub_8061429(v60, v59);
        sub_8053C5A((int)optarg, "stray character in field spec");
        sub_8053BF4(v110);
        continue;
      case 109:
        v101 = 1;
        continue;
      case 111:
        if ( v118 && strcmp(v118, optarg) )
        {
          v65 = gettext("multiple output files specified");
          error(2, 0, v65);
        }
        v118 = optarg;
        dword_806B234 = (int)&loc_80550C7;
        sub_806185D();
        goto LABEL_127;
      case 115:
        byte_806C1D5 = 1;
        continue;
      case 116:
        v105 = *optarg;
        LODWORD(v17) = &loc_8054E8E;
        if ( v105 )
          LODWORD(v17) = &loc_8054EB2;
        dword_806B34C = v17;
        sub_80611C6(v18, HIDWORD(v17));
        v67 = gettext("empty tab");
        error(2, 0, v67);
        v68 = &loc_8054EDA;
        if ( !optarg[1] )
          v68 = &loc_8054F31;
        dword_806B25C = (int)v68;
        sub_806177B();
        if ( !strcmp(optarg, "\\0") )
        {
          v105 = 0;
        }
        else
        {
          v69 = (char *)sub_805BC36(optarg);
          v70 = gettext("multi-character tab %s");
          v95 = v69;
          error(2, 0, v70);
        }
        if ( dword_806B42C != 128 )
        {
          HIDWORD(v17) = v105;
          if ( v105 != dword_806B42C )
          {
            v71 = gettext("incompatible tabs");
            error(2, 0, v71);
          }
        }
        dword_806B42C = v105;
        continue;
      case 117:
        byte_806C1D6 = 1;
        continue;
      case 121:
        v72 = argv[optind + 0x3FFFFFFF];
        if ( v72 == optarg )
        {
          v120 = optarg;
          dword_806B270 = (int)&loc_805500F;
          sub_80616F6(v18, v72);
          do
            ++v120;
          while ( (unsigned int)(*v120 - 48) <= 9 );
          LODWORD(v17) = *v120 != 0;
          HIDWORD(v17) = optind - v17;
          optind -= v17;
        }
        else
        {
          dword_806B270 = (int)&loc_80550C7;
          sub_80616F6(v18, v72);
LABEL_152:
          byte_806B3A8 = 0;
        }
        continue;
      case 122:
        goto LABEL_152;
      case 128:
        if ( optarg )
        {
          v97 = (const char *)off_806B44C;
          LODWORD(v17) = aCccgeneralNume[sub_8055C6B(
                                           (int)"--check",
                                           optarg,
                                           (int)off_8062F74,
                                           (int)"CCcgeneral-numeric",
                                           1u)];
        }
        else
        {
          LODWORD(v17) = 99;
        }
        v112 = v17;
LABEL_91:
        LODWORD(v17) = &loc_8054A52;
        if ( !v100 )
          LODWORD(v17) = &loc_8054A69;
        dword_806B324 = v17;
        sub_80612C5(v18, HIDWORD(v17));
        if ( v100 != v112 )
          sub_8053CA8((int)"cC");
        v100 = v112;
        dword_806B310 = (int)&loc_80550C7;
        sub_8061339(v46, v45);
        goto LABEL_96;
      case 129:
LABEL_96:
        if ( arg && strcmp(arg, optarg) )
        {
          v47 = gettext("multiple compress programs specified");
          error(2, 0, v47);
        }
        arg = optarg;
        dword_806B338 = (int)&loc_80550C7;
        sub_8061251();
        goto LABEL_100;
      case 130:
LABEL_100:
        byte_806C1E0 = 1;
        continue;
      case 131:
        v117 = optarg;
        continue;
      case 132:
        sub_804CF47((char)v112, (int)optarg, longind, v112, optarg);
        continue;
      case 133:
LABEL_127:
        if ( v113 && strcmp(v113, optarg) )
        {
          v66 = gettext("multiple random sources specified");
          error(2, 0, v66);
        }
        v113 = optarg;
        continue;
      case 134:
        goto LABEL_85;
      case 135:
        v114 = sub_804D419(longind, (char)v112, optarg);
        break;
      default:
        sub_804BB01(2);
        return;
    }
  }
  v20 = &loc_80544B4;
  if ( *argv[optind] != 45 )
    v20 = &loc_8054565;
  dword_806B2D4 = (int)v20;
  sub_80614AE(v93, v94);
  v21 = &loc_80544EA;
  if ( argv[optind][1] != 111 )
    v21 = &loc_8054565;
  dword_806B2FC = (int)v21;
  sub_80613B1();
  if ( !argv[optind][2] )
  {
    v22 = &loc_805452D;
    if ( optind + 1 == argc )
      v22 = &loc_8054565;
    dword_806B338 = (int)v22;
    sub_8061251();
  }
LABEL_39:
  v112 = getopt_long(argc, argv, "-bcCdfghik:mMno:rRsS:t:T:uVy:z", &longopts, &longind);
  if ( v112 != -1 )
    goto LABEL_45;
  goto LABEL_40;
}
// 80558CB: using guessed type int sub_80558CB();
// 80610EA: using guessed type int sub_80610EA(void);
// 8061156: using guessed type int sub_8061156(void);
// 80611C6: using guessed type int __fastcall sub_80611C6(_DWORD, _DWORD);
// 8061251: using guessed type int sub_8061251(void);
// 80612C5: using guessed type int __fastcall sub_80612C5(_DWORD, _DWORD);
// 8061339: using guessed type int __fastcall sub_8061339(_DWORD, _DWORD);
// 8061429: using guessed type int __fastcall sub_8061429(_DWORD, _DWORD);
// 8061526: using guessed type int sub_8061526(void);
// 806159C: using guessed type int __fastcall sub_806159C(_DWORD, _DWORD);
// 8061616: using guessed type int sub_8061616(void);
// 80616F6: using guessed type int __fastcall sub_80616F6(_DWORD, _DWORD);
// 806177B: using guessed type int sub_806177B(void);
// 80617ED: using guessed type int sub_80617ED(void);
// 806185D: using guessed type int sub_806185D(void);
// 80618EC: using guessed type int sub_80618EC(void);
// 806195A: using guessed type int sub_806195A(void);
// 8062F74: using guessed type char *off_8062F74[3];
// 8062FBC: using guessed type void *off_8062FBC;
// 806B20C: using guessed type int dword_806B20C;
// 806B220: using guessed type int dword_806B220;
// 806B234: using guessed type int dword_806B234;
// 806B248: using guessed type int dword_806B248;
// 806B25C: using guessed type int dword_806B25C;
// 806B270: using guessed type int dword_806B270;
// 806B298: using guessed type int dword_806B298;
// 806B2AC: using guessed type int dword_806B2AC;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B2D4: using guessed type int dword_806B2D4;
// 806B2E8: using guessed type int dword_806B2E8;
// 806B2FC: using guessed type int dword_806B2FC;
// 806B310: using guessed type int dword_806B310;
// 806B324: using guessed type int dword_806B324;
// 806B338: using guessed type int dword_806B338;
// 806B34C: using guessed type int dword_806B34C;
// 806B360: using guessed type int dword_806B360;
// 806B374: using guessed type int dword_806B374;
// 806B3A8: using guessed type char byte_806B3A8;
// 806B42C: using guessed type int dword_806B42C;
// 806B438: using guessed type char byte_806B438;
// 806B442: using guessed type char byte_806B442;
// 806B4E0: using guessed type int optind;
// 806BDA4: using guessed type int dword_806BDA4;
// 806BDA8: using guessed type int dword_806BDA8;
// 806BDAC: using guessed type char byte_806BDAC;
// 806BDAD: using guessed type char byte_806BDAD;
// 806C1CC: using guessed type int dword_806C1CC;
// 806C1D4: using guessed type char byte_806C1D4;
// 806C1D5: using guessed type char byte_806C1D5;
// 806C1D6: using guessed type char byte_806C1D6;
// 806C1D7: using guessed type char byte_806C1D7;
// 806C1D8: using guessed type int dword_806C1D8;
// 806C1E0: using guessed type char byte_806C1E0;

//----- (0805598A) --------------------------------------------------------
void __noreturn sub_805598A()
{
  sub_804BB01(1);
}

//----- (0805599E) --------------------------------------------------------
int __cdecl sub_805599E(char *s, int a2, int a3, size_t a4)
{
  int v4; // ecx
  size_t v5; // eax
  const char *v7; // [esp+0h] [ebp-28h]
  const void *v8; // [esp+4h] [ebp-24h]
  char v9; // [esp+13h] [ebp-15h]
  int v10; // [esp+14h] [ebp-14h]
  int v11; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]

  v11 = -1;
  v9 = 0;
  n = strlen(s);
  v10 = 0;
  dword_806B298 = (int)&loc_8055A7C;
  sub_8061616();
  do
  {
    if ( !strncmp(*(const char **)(4 * v10 + a2), s, n) )
    {
      v7 = *(const char **)(4 * v10 + a2);
      v5 = strlen(v7);
      if ( v5 == n )
        return v10;
      if ( v11 == -1 )
      {
        v11 = v10;
      }
      else if ( !a3 || (v8 = (const void *)(v10 * a4 + a3), v7 = (const char *)(a3 + a4 * v11), memcmp(v7, v8, a4)) )
      {
        v9 = 1;
      }
    }
    ++v10;
  }
  while ( *(_DWORD *)(4 * v10 + a2) );
  if ( v9 )
  {
    dword_806B324 = (int)&locret_8055ABA;
    sub_80612C5(v4, 4 * v10);
  }
  return v11;
}
// 80612C5: using guessed type int __fastcall sub_80612C5(_DWORD, _DWORD);
// 8061616: using guessed type int sub_8061616(void);
// 806B298: using guessed type int dword_806B298;
// 806B324: using guessed type int dword_806B324;

//----- (08055ABC) --------------------------------------------------------
void __cdecl __noreturn sub_8055ABC(char *a1, int a2, int a3)
{
  if ( a3 == -1 )
    gettext("invalid argument %s for %s");
  else
    gettext("ambiguous argument %s for %s");
  sub_805BC14(1, a1);
  sub_805B828(0, 8);
}

//----- (08055B3F) --------------------------------------------------------
int __cdecl sub_8055B3F(int a1, int a2, size_t n)
{
  FILE *v3; // ebx
  char *v4; // eax
  int v5; // ecx
  const void *v7; // [esp+4h] [ebp-24h]
  void *v8; // [esp+8h] [ebp-20h]
  int i; // [esp+18h] [ebp-10h]
  void *s1; // [esp+1Ch] [ebp-Ch]

  s1 = 0;
  v3 = stderr;
  v4 = gettext("Valid arguments are:");
  fputs_unlocked(v4, v3);
  for ( i = 0; *(_DWORD *)(4 * i + a1); ++i )
  {
    if ( !i || (v7 = (const void *)(a2 + i * n), memcmp(s1, v7, n)) )
    {
      v8 = sub_805BC36(*(char **)(4 * i + a1));
      fprintf(stderr, "\n  - %s", v8);
      s1 = (void *)(i * n + a2);
      dword_806B324 = (int)&loc_8055C33;
      sub_80612C5(v5, i * n);
    }
    v8 = sub_805BC36(*(char **)(4 * i + a1));
    fprintf(stderr, ", %s", v8);
  }
  return putc_unlocked(10, stderr);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 80612C5: using guessed type int __fastcall sub_80612C5(_DWORD, _DWORD);
// 806B324: using guessed type int dword_806B324;

//----- (08055C6B) --------------------------------------------------------
int __cdecl sub_8055C6B(int a1, char *s, int a3, int a4, size_t n)
{
  int v6; // [esp+1Ch] [ebp-Ch]

  v6 = sub_805599E(s, a3, a4, n);
  if ( v6 < 0 )
    sub_8055ABC((char *)a1, (int)s, v6);
  return v6;
}

//----- (08055D80) --------------------------------------------------------
int sub_8055D80()
{
  bool v0; // zf
  int v1; // edx
  int v2; // ecx
  void *v3; // eax
  void *v4; // ebx
  int *v5; // eax
  int *v6; // eax
  int result; // eax
  char *v8; // [esp+2Ch] [ebp-Ch]

  if ( sub_805FFAD(stdout) )
  {
    if ( byte_806C32C == 1 )
    {
      v0 = *__errno_location() == 32;
      v3 = &loc_8055DCF;
      if ( v0 )
        v3 = &loc_8055E55;
      dword_806B324 = (int)v3;
      sub_80612C5(v2, v1);
    }
    v8 = gettext("write error");
    if ( dword_806C328 )
    {
      v4 = sub_805B9C1((char *)dword_806C328);
      v5 = __errno_location();
      error(0, *v5, "%s: %s", v4, v8);
    }
    else
    {
      v6 = __errno_location();
      error(0, *v6, "%s", v8);
    }
    _exit(status);
  }
  result = sub_805FFAD(stderr);
  if ( result )
    _exit(status);
  return result;
}
// 80612C5: using guessed type int __fastcall sub_80612C5(_DWORD, _DWORD);
// 806B324: using guessed type int dword_806B324;
// 806C328: using guessed type int dword_806C328;
// 806C32C: using guessed type char byte_806C32C;

//----- (08055E79) --------------------------------------------------------
_DWORD *__cdecl sub_8055E79(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 1732584193;
  a1[1] = -271733879;
  a1[2] = -1732584194;
  a1[3] = 271733878;
  a1[5] = 0;
  a1[4] = a1[5];
  result = a1;
  a1[6] = 0;
  return result;
}

//----- (08055EC5) --------------------------------------------------------
_DWORD *__cdecl sub_8055EC5(_DWORD *a1, int a2)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = a2;
  return result;
}

//----- (08055ED2) --------------------------------------------------------
_DWORD *__cdecl sub_8055ED2(int *a1, _DWORD *a2)
{
  sub_8055EC5(a2, *a1);
  sub_8055EC5(a2 + 1, a1[1]);
  sub_8055EC5(a2 + 2, a1[2]);
  sub_8055EC5(a2 + 3, a1[3]);
  return a2;
}

//----- (08055F3F) --------------------------------------------------------
_DWORD *__cdecl sub_8055F3F(int *a1, _DWORD *a2)
{
  signed int v2; // eax
  unsigned int v4; // [esp+18h] [ebp-10h]
  signed int v5; // [esp+1Ch] [ebp-Ch]

  v4 = a1[6];
  if ( v4 > 0x37 )
    v2 = 32;
  else
    v2 = 16;
  v5 = v2;
  a1[4] += v4;
  if ( a1[4] < v4 )
    ++a1[5];
  a1[v2 + 5] = 8 * a1[4];
  a1[v2 + 6] = *((_QWORD *)a1 + 2) >> 29;
  memcpy((char *)a1 + v4 + 28, &unk_8063EC8, 4 * (v2 + 1073741822) - v4);
  sub_8056409(a1 + 7, 4 * v5, a1);
  return sub_8055ED2(a1, a2);
}

//----- (08056207) --------------------------------------------------------
int *__usercall sub_8056207@<eax>(int a1@<edx>, int ecx0@<ecx>, void *src, size_t a2, int a3)
{
  void *v5; // eax
  int v6; // eax
  int *result; // eax
  int *v8; // eax
  size_t v9; // ST1C_4
  unsigned int v10; // [esp+14h] [ebp-14h]
  int v11; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]
  char *srca; // [esp+30h] [ebp+8h]
  size_t v14; // [esp+34h] [ebp+Ch]

  v5 = &loc_8056231;
  if ( !*(_DWORD *)(a3 + 24) )
    v5 = &loc_80562FD;
  dword_806B2E8 = (int)v5;
  sub_8061429(ecx0, a1);
  v11 = *(_DWORD *)(a3 + 24);
  v6 = a2;
  if ( 128 - v11 <= a2 )
    v6 = 128 - v11;
  n = v6;
  memcpy((void *)(v11 + a3 + 28), src, v6);
  *(_DWORD *)(a3 + 24) += n;
  if ( *(_DWORD *)(a3 + 24) > 0x40u )
  {
    sub_8056409((int *)(a3 + 28), *(_DWORD *)(a3 + 24) & 0xFFFFFFC0, (int *)a3);
    *(_DWORD *)(a3 + 24) &= 0x3Fu;
    memcpy((void *)(a3 + 28), (const void *)(a3 + 28 + ((v11 + n) & 0xFFFFFFC0)), *(_DWORD *)(a3 + 24));
  }
  srca = (char *)src + n;
  result = (int *)n;
  v14 = a2 - n;
  if ( v14 > 0x3F )
  {
    result = (int *)((unsigned __int8)srca & 3);
    if ( (unsigned __int8)srca & 3 )
    {
      while ( v14 > 0x40 )
      {
        v8 = (int *)memcpy((void *)(a3 + 28), srca, 0x40u);
        result = sub_8056409(v8, 0x40u, (int *)a3);
        srca += 64;
        v14 -= 64;
      }
    }
    else
    {
      sub_8056409((int *)srca, v14 & 0xFFFFFFC0, (int *)a3);
      result = (int *)(v14 & 0xFFFFFFC0);
      srca += v14 & 0xFFFFFFC0;
      v14 &= 0x3Fu;
    }
  }
  if ( v14 )
  {
    v9 = *(_DWORD *)(a3 + 24);
    memcpy((void *)(v9 + a3 + 28), srca, v14);
    v10 = v14 + v9;
    if ( v10 > 0x3F )
    {
      sub_8056409((int *)(a3 + 28), 0x40u, (int *)a3);
      v10 -= 64;
      memcpy((void *)(a3 + 28), (const void *)(a3 + 92), v10);
    }
    result = (int *)a3;
    *(_DWORD *)(a3 + 24) = v10;
  }
  return result;
}
// 8061429: using guessed type int __fastcall sub_8061429(_DWORD, _DWORD);
// 806B2E8: using guessed type int dword_806B2E8;

//----- (08056409) --------------------------------------------------------
int *__cdecl sub_8056409(int *a1, unsigned int a2, int *a3)
{
  int v3; // ST30_4
  int v4; // ST34_4
  int v5; // ST38_4
  int v6; // ST3C_4
  int v7; // ST40_4
  int v8; // ST10_4
  int *v9; // ST0C_4
  int v10; // ST10_4
  int v11; // ST44_4
  int v12; // ST1C_4
  int v13; // ST48_4
  int v14; // ST18_4
  int v15; // ST4C_4
  int v16; // ST14_4
  int v17; // ST50_4
  int v18; // ST10_4
  int v19; // ST54_4
  int v20; // ST1C_4
  int v21; // ST58_4
  int v22; // ST18_4
  int v23; // ST5C_4
  int v24; // ST14_4
  int v25; // ST60_4
  int v26; // ST10_4
  int v27; // ST64_4
  int v28; // ST1C_4
  int v29; // ST68_4
  int v30; // ST18_4
  int v31; // ST6C_4
  int v32; // ST14_4
  int v33; // ST70_4
  int v34; // ST10_4
  int v35; // ST74_4
  int v36; // ST1C_4
  int v37; // ST78_4
  int v38; // ST18_4
  int v39; // ST7C_4
  int v40; // ST14_4
  int v41; // ST10_4
  int v42; // ST1C_4
  int v43; // ST18_4
  int v44; // ST14_4
  int v45; // ST10_4
  int v46; // ST1C_4
  int v47; // ST18_4
  int v48; // ST14_4
  int v49; // ST10_4
  int v50; // ST1C_4
  int v51; // ST18_4
  int v52; // ST14_4
  int v53; // ST10_4
  int v54; // ST1C_4
  int v55; // ST18_4
  int v56; // ST14_4
  int v57; // ST10_4
  int v58; // ST1C_4
  int v59; // ST18_4
  int v60; // ST14_4
  int v61; // ST10_4
  int v62; // ST1C_4
  int v63; // ST18_4
  int v64; // ST14_4
  int v65; // ST10_4
  int v66; // ST1C_4
  int v67; // ST18_4
  int v68; // ST14_4
  int v69; // ST10_4
  int v70; // ST1C_4
  int v71; // ST18_4
  int v72; // ST14_4
  int v73; // ST10_4
  int v74; // ST1C_4
  int v75; // ST18_4
  int v76; // ST14_4
  int v77; // ST10_4
  int v78; // ST1C_4
  int v79; // ST18_4
  int v80; // ST14_4
  int v81; // ST10_4
  int v82; // ST1C_4
  int v83; // ST18_4
  int v84; // ST14_4
  int v85; // ST10_4
  int v86; // ST1C_4
  int v87; // ST18_4
  int v88; // ST14_4
  int *result; // eax
  int *v90; // [esp+Ch] [ebp-74h]
  int v91; // [esp+10h] [ebp-70h]
  int v92; // [esp+14h] [ebp-6Ch]
  int v93; // [esp+18h] [ebp-68h]
  int v94; // [esp+1Ch] [ebp-64h]

  v90 = a1;
  v91 = *a3;
  v92 = a3[1];
  v93 = a3[2];
  v94 = a3[3];
  a3[4] += a2;
  a3[5] += a3[4] < a2;
  while ( v90 < &a1[a2 >> 2] )
  {
    v3 = v91;
    v4 = v92;
    v5 = v93;
    v6 = v94;
    v7 = *v90;
    v8 = (v94 ^ v92 & (v93 ^ v94)) + *v90 + v91 - 680876936;
    v9 = v90 + 1;
    v10 = v92 + __ROR4__(v8, 25);
    v11 = *v9;
    ++v9;
    v12 = v10 + __ROR4__((v93 ^ v10 & (v92 ^ v93)) + v11 + v94 - 389564586, 20);
    v13 = *v9;
    ++v9;
    v14 = v12 + __ROR4__((v92 ^ v12 & (v10 ^ v92)) + v13 + v93 + 606105819, 15);
    v15 = *v9;
    ++v9;
    v16 = v14 + __ROR4__((v10 ^ v14 & (v12 ^ v10)) + v15 + v92 - 1044525330, 10);
    v17 = *v9;
    ++v9;
    v18 = v16 + __ROR4__((v12 ^ v16 & (v14 ^ v12)) + v17 + v10 - 176418897, 25);
    v19 = *v9;
    ++v9;
    v20 = v18 + __ROR4__((v14 ^ v18 & (v16 ^ v14)) + v19 + v12 + 1200080426, 20);
    v21 = *v9;
    ++v9;
    v22 = v20 + __ROR4__((v16 ^ v20 & (v18 ^ v16)) + v21 + v14 - 1473231341, 15);
    v23 = *v9;
    ++v9;
    v24 = v22 + __ROR4__((v18 ^ v22 & (v20 ^ v18)) + v23 + v16 - 45705983, 10);
    v25 = *v9;
    ++v9;
    v26 = v24 + __ROR4__((v20 ^ v24 & (v22 ^ v20)) + v25 + v18 + 1770035416, 25);
    v27 = *v9;
    ++v9;
    v28 = v26 + __ROR4__((v22 ^ v26 & (v24 ^ v22)) + v27 + v20 - 1958414417, 20);
    v29 = *v9;
    ++v9;
    v30 = v28 + __ROR4__((v24 ^ v28 & (v26 ^ v24)) + v29 + v22 - 42063, 15);
    v31 = *v9;
    ++v9;
    v32 = v30 + __ROR4__((v26 ^ v30 & (v28 ^ v26)) + v31 + v24 - 1990404162, 10);
    v33 = *v9;
    ++v9;
    v34 = v32 + __ROR4__((v28 ^ v32 & (v30 ^ v28)) + v33 + v26 + 1804603682, 25);
    v35 = *v9;
    ++v9;
    v36 = v34 + __ROR4__((v30 ^ v34 & (v32 ^ v30)) + v35 + v28 - 40341101, 20);
    v37 = *v9;
    ++v9;
    v38 = v36 + __ROR4__((v32 ^ v36 & (v34 ^ v32)) + v37 + v30 - 1502002290, 15);
    v39 = *v9;
    v90 = v9 + 1;
    v40 = v38 + __ROR4__((v34 ^ v38 & (v36 ^ v34)) + v39 + v32 + 1236535329, 10);
    v41 = v40 + __ROR4__(v11 + (v38 ^ v36 & (v40 ^ v38)) + v34 - 165796510, 27);
    v42 = v41 + __ROR4__(v21 + (v40 ^ v38 & (v41 ^ v40)) + v36 - 1069501632, 23);
    v43 = v42 + __ROR4__(v31 + (v41 ^ v40 & (v42 ^ v41)) + v38 + 643717713, 18);
    v44 = v43 + __ROR4__(v7 + (v42 ^ v41 & (v43 ^ v42)) + v40 - 373897302, 12);
    v45 = v44 + __ROR4__(v19 + (v43 ^ v42 & (v44 ^ v43)) + v41 - 701558691, 27);
    v46 = v45 + __ROR4__(v29 + (v44 ^ v43 & (v45 ^ v44)) + v42 + 38016083, 23);
    v47 = v46 + __ROR4__(v39 + (v45 ^ v44 & (v46 ^ v45)) + v43 - 660478335, 18);
    v48 = v47 + __ROR4__(v17 + (v46 ^ v45 & (v47 ^ v46)) + v44 - 405537848, 12);
    v49 = v48 + __ROR4__(v27 + (v47 ^ v46 & (v48 ^ v47)) + v45 + 568446438, 27);
    v50 = v49 + __ROR4__(v37 + (v48 ^ v47 & (v49 ^ v48)) + v46 - 1019803690, 23);
    v51 = v50 + __ROR4__(v15 + (v49 ^ v48 & (v50 ^ v49)) + v47 - 187363961, 18);
    v52 = v51 + __ROR4__(v25 + (v50 ^ v49 & (v51 ^ v50)) + v48 + 1163531501, 12);
    v53 = v52 + __ROR4__(v35 + (v51 ^ v50 & (v52 ^ v51)) + v49 - 1444681467, 27);
    v54 = v53 + __ROR4__(v13 + (v52 ^ v51 & (v53 ^ v52)) + v50 - 51403784, 23);
    v55 = v54 + __ROR4__(v23 + (v53 ^ v52 & (v54 ^ v53)) + v51 + 1735328473, 18);
    v56 = v55 + __ROR4__(v33 + (v54 ^ v53 & (v55 ^ v54)) + v52 - 1926607734, 12);
    v57 = v56 + __ROR4__(v19 + (v54 ^ v56 ^ v55) + v53 - 378558, 28);
    v58 = v57 + __ROR4__(v25 + (v55 ^ v57 ^ v56) + v54 - 2022574463, 21);
    v59 = v58 + __ROR4__(v31 + (v56 ^ v58 ^ v57) + v55 + 1839030562, 16);
    v60 = v59 + __ROR4__(v37 + (v57 ^ v59 ^ v58) + v56 - 35309556, 9);
    v61 = v60 + __ROR4__(v11 + (v58 ^ v60 ^ v59) + v57 - 1530992060, 28);
    v62 = v61 + __ROR4__(v17 + (v59 ^ v61 ^ v60) + v58 + 1272893353, 21);
    v63 = v62 + __ROR4__(v23 + (v60 ^ v62 ^ v61) + v59 - 155497632, 16);
    v64 = v63 + __ROR4__(v29 + (v61 ^ v63 ^ v62) + v60 - 1094730640, 9);
    v65 = v64 + __ROR4__(v35 + (v62 ^ v64 ^ v63) + v61 + 681279174, 28);
    v66 = v65 + __ROR4__(v7 + (v63 ^ v65 ^ v64) + v62 - 358537222, 21);
    v67 = v66 + __ROR4__(v15 + (v64 ^ v66 ^ v65) + v63 - 722521979, 16);
    v68 = v67 + __ROR4__(v21 + (v65 ^ v67 ^ v66) + v64 + 76029189, 9);
    v69 = v68 + __ROR4__(v27 + (v66 ^ v68 ^ v67) + v65 - 640364487, 28);
    v70 = v69 + __ROR4__(v33 + (v67 ^ v69 ^ v68) + v66 - 421815835, 21);
    v71 = v70 + __ROR4__(v39 + (v68 ^ v70 ^ v69) + v67 + 530742520, 16);
    v72 = v71 + __ROR4__(v13 + (v69 ^ v71 ^ v70) + v68 - 995338651, 9);
    v73 = v72 + __ROR4__(v7 + (v71 ^ (v72 | ~v70)) + v69 - 198630844, 26);
    v74 = v73 + __ROR4__(v23 + (v72 ^ (v73 | ~v71)) + v70 + 1126891415, 22);
    v75 = v74 + __ROR4__(v37 + (v73 ^ (v74 | ~v72)) + v71 - 1416354905, 17);
    v76 = v75 + __ROR4__(v19 + (v74 ^ (v75 | ~v73)) + v72 - 57434055, 11);
    v77 = v76 + __ROR4__(v33 + (v75 ^ (v76 | ~v74)) + v73 + 1700485571, 26);
    v78 = v77 + __ROR4__(v15 + (v76 ^ (v77 | ~v75)) + v74 - 1894986606, 22);
    v79 = v78 + __ROR4__(v29 + (v77 ^ (v78 | ~v76)) + v75 - 1051523, 17);
    v80 = v79 + __ROR4__(v11 + (v78 ^ (v79 | ~v77)) + v76 - 2054922799, 11);
    v81 = v80 + __ROR4__(v25 + (v79 ^ (v80 | ~v78)) + v77 + 1873313359, 26);
    v82 = v81 + __ROR4__(v39 + (v80 ^ (v81 | ~v79)) + v78 - 30611744, 22);
    v83 = v82 + __ROR4__(v21 + (v81 ^ (v82 | ~v80)) + v79 - 1560198380, 17);
    v84 = v83 + __ROR4__(v35 + (v82 ^ (v83 | ~v81)) + v80 + 1309151649, 11);
    v85 = v84 + __ROR4__(v17 + (v83 ^ (v84 | ~v82)) + v81 - 145523070, 26);
    v86 = v85 + __ROR4__(v31 + (v84 ^ (v85 | ~v83)) + v82 - 1120210379, 22);
    v87 = v86 + __ROR4__(v13 + (v85 ^ (v86 | ~v84)) + v83 + 718787259, 17);
    v88 = v87 + __ROR4__(v27 + (v86 ^ (v87 | ~v85)) + v84 - 343485551, 11);
    v91 = v3 + v85;
    v92 = v4 + v88;
    v93 = v5 + v87;
    v94 = v6 + v86;
  }
  *a3 = v91;
  a3[1] = v92;
  a3[2] = v93;
  result = a3;
  a3[3] = v94;
  return result;
}

//----- (080570D3) --------------------------------------------------------
int __cdecl sub_80570D3(int a1, int a2, int a3, int a4, int a5, int a6)
{
  return posix_fadvise64(a1, a2, a3, a4, a5, a6);
}
// 8049E60: using guessed type int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (08057124) --------------------------------------------------------
void __cdecl sub_8057124(FILE *stream, int a2)
{
  int v2; // eax

  if ( stream )
  {
    v2 = fileno(stream);
    sub_80570D3(v2, 0, 0, 0, 0, a2);
  }
}

//----- (0805716C) --------------------------------------------------------
_BYTE *__usercall sub_805716C@<eax>(_BYTE *edx0@<edx>, int a2@<ecx>, _BYTE **a1)
{
  int v4; // [esp+0h] [ebp-28h]
  char v5; // [esp+1Bh] [ebp-Dh]
  _BYTE *v6; // [esp+1Ch] [ebp-Ch]

  v6 = 0;
  v5 = 0;
  while ( **a1 )
  {
    if ( v5 )
    {
      v5 = 0;
      v4 = (char)**a1;
      if ( (unsigned __int8)sub_805FD39(v4) ^ 1 && **a1 != 126 )
        v6 = 0;
    }
    else
    {
      if ( **a1 == 46 )
      {
        v5 = 1;
        if ( v6 )
          goto LABEL_12;
        v6 = *a1;
        dword_806B374 = (int)&loc_805721D;
        sub_80610EA();
      }
      v4 = (char)**a1;
      if ( (unsigned __int8)sub_805FCF0((int)edx0, a2, v4) ^ 1 && **a1 != 126 )
        v6 = 0;
    }
LABEL_12:
    edx0 = *a1 + 1;
    *a1 = edx0;
  }
  return v6;
}
// 80610EA: using guessed type int sub_80610EA(void);
// 806B374: using guessed type int dword_806B374;

//----- (0805723F) --------------------------------------------------------
int __cdecl sub_805723F(unsigned __int8 a1)
{
  bool v2; // zf
  void *v3; // eax

  if ( (unsigned __int8)sub_805FDD6(a1) )
    return 0;
  v2 = (unsigned __int8)sub_805FD39(a1) == 0;
  v3 = &loc_805728B;
  if ( v2 )
    v3 = &loc_8057291;
  dword_806B2FC = (int)v3;
  sub_80613B1();
  return a1;
}
// 806B2FC: using guessed type int dword_806B2FC;

//----- (080572C2) --------------------------------------------------------
signed int __cdecl sub_80572C2(int a1, unsigned int a2, int a3, unsigned int a4)
{
  int v4; // eax
  void *v5; // eax
  void *v6; // eax
  bool v7; // zf
  void *v8; // eax
  int v10; // [esp+0h] [ebp-38h]
  int v11; // [esp+4h] [ebp-34h]
  unsigned int v12; // [esp+1Ch] [ebp-1Ch]
  unsigned int v13; // [esp+20h] [ebp-18h]
  int v14; // [esp+24h] [ebp-14h]
  int v15; // [esp+28h] [ebp-10h]
  int v16; // [esp+2Ch] [ebp-Ch]

  v12 = 0;
  v13 = 0;
  dword_806B2D4 = (int)&loc_8057535;
  sub_80614AE(v10, v11);
  v14 = 0;
  dword_806B360 = (int)&loc_80573A5;
  sub_8061156();
  while ( 1 )
  {
    if ( v12 == a2 )
    {
      v4 = 0;
    }
    else
    {
      v10 = *(unsigned __int8 *)(a1 + v12);
      v4 = sub_805723F(v10);
    }
    v15 = v4;
    v5 = &loc_8057354;
    if ( v13 == a4 )
      v5 = &loc_805736C;
    dword_806B2C0 = (int)v5;
    sub_8061526();
    v10 = *(unsigned __int8 *)(a3 + v13);
    v16 = sub_805723F(v10);
    if ( v15 != v16 )
    {
      dword_806B234 = (int)&locret_8057552;
      sub_806185D();
    }
    ++v12;
    ++v13;
    if ( v12 < a2 )
    {
      v10 = *(char *)(a1 + v12);
      if ( (unsigned __int8)sub_805FDD6(v10) ^ 1 )
        continue;
    }
    if ( v13 >= a4 )
      break;
    v10 = *(char *)(a3 + v13);
    if ( !((unsigned __int8)sub_805FDD6(v10) ^ 1) )
      break;
  }
  while ( *(_BYTE *)(a1 + v12) == 48 )
    ++v12;
  dword_806B248 = (int)&loc_8057427;
  sub_80617ED();
  do
    ++v13;
  while ( *(_BYTE *)(a3 + v13) == 48 );
  while ( 1 )
  {
    v10 = *(char *)(a1 + v12);
    if ( !(unsigned __int8)sub_805FDD6(v10) )
      break;
    v10 = *(char *)(a3 + v13);
    if ( !(unsigned __int8)sub_805FDD6(v10) )
      break;
    v6 = &loc_8057457;
    if ( v14 )
      v6 = &loc_805747A;
    dword_806B220 = (int)v6;
    sub_80618EC();
    v14 = *(char *)(a1 + v12++) - *(char *)(a3 + v13++);
  }
  v10 = *(char *)(a1 + v12);
  v7 = (unsigned __int8)sub_805FDD6(v10) == 0;
  v8 = &loc_80574E9;
  if ( v7 )
    v8 = &loc_80574F0;
  dword_806B298 = (int)v8;
  sub_8061616();
  return 1;
}
// 80572C2: could not find valid save-restore pair for ebx
// 8061156: using guessed type int sub_8061156(void);
// 8061526: using guessed type int sub_8061526(void);
// 8061616: using guessed type int sub_8061616(void);
// 80617ED: using guessed type int sub_80617ED(void);
// 806185D: using guessed type int sub_806185D(void);
// 80618EC: using guessed type int sub_80618EC(void);
// 806B220: using guessed type int dword_806B220;
// 806B234: using guessed type int dword_806B234;
// 806B248: using guessed type int dword_806B248;
// 806B298: using guessed type int dword_806B298;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B2D4: using guessed type int dword_806B2D4;
// 806B360: using guessed type int dword_806B360;

//----- (08057554) --------------------------------------------------------
int __cdecl sub_8057554(char *s1, char *s2)
{
  void *v3; // eax
  bool v4; // zf
  void *v5; // eax
  int v6; // [esp+20h] [ebp-18h]

  v6 = strcmp(s1, s2);
  if ( !v6 )
    return 0;
  if ( !*s1 )
  {
    dword_806B220 = (int)&locret_805782B;
    sub_80618EC();
  }
  v3 = &loc_80575C8;
  if ( *s2 )
    v3 = &loc_80575E4;
  dword_806B25C = (int)v3;
  sub_806177B();
  dword_806B338 = (int)&locret_805782B;
  sub_8061251();
  v4 = strcmp(".", s1) == 0;
  v5 = &loc_8057614;
  if ( !v4 )
    v5 = &loc_805761E;
  dword_806B2C0 = (int)v5;
  sub_8061526();
  return -1;
}
// 8057554: could not find valid save-restore pair for ebx
// 8061251: using guessed type int sub_8061251(void);
// 8061526: using guessed type int sub_8061526(void);
// 806177B: using guessed type int sub_806177B(void);
// 80618EC: using guessed type int sub_80618EC(void);
// 806B220: using guessed type int dword_806B220;
// 806B25C: using guessed type int dword_806B25C;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B338: using guessed type int dword_806B338;

//----- (0805782D) --------------------------------------------------------
int __cdecl sub_805782D(int category)
{
  unsigned __int8 v2; // [esp+1Bh] [ebp-Dh]
  const char *s1; // [esp+1Ch] [ebp-Ch]

  v2 = 1;
  s1 = setlocale(category, 0);
  if ( s1 && (!strcmp(s1, "C") || !strcmp(s1, "POSIX")) )
    v2 = 0;
  return v2;
}

//----- (0805788B) --------------------------------------------------------
int __cdecl sub_805788B(int a1)
{
  return *(_DWORD *)(a1 + 8);
}

//----- (08057896) --------------------------------------------------------
int __cdecl sub_8057896(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (080578A1) --------------------------------------------------------
int __cdecl sub_80578A1(int a1)
{
  return *(_DWORD *)(a1 + 16);
}

//----- (080578AC) --------------------------------------------------------
unsigned int __cdecl sub_80578AC(int a1)
{
  _DWORD *i; // [esp+0h] [ebp-10h]
  unsigned int v3; // [esp+4h] [ebp-Ch]
  _DWORD *v4; // [esp+8h] [ebp-8h]
  unsigned int v5; // [esp+Ch] [ebp-4h]

  v3 = 0;
  for ( i = *(_DWORD **)a1; *(_DWORD *)(a1 + 4) > (unsigned int)i; i += 2 )
  {
    if ( *i )
    {
      v4 = i;
      v5 = 1;
      dword_806B248 = (int)&loc_80578F4;
      sub_80617ED();
      do
      {
        ++v5;
        v4 = (_DWORD *)v4[1];
      }
      while ( v4 );
      if ( v5 > v3 )
        v3 = v5;
    }
  }
  return v3;
}
// 80617ED: using guessed type int sub_80617ED(void);
// 806B248: using guessed type int dword_806B248;

//----- (08057AC1) --------------------------------------------------------
int __cdecl sub_8057AC1(int a1, int a2)
{
  unsigned int v3; // [esp+1Ch] [ebp-Ch]

  v3 = (*(int (__cdecl **)(int, _DWORD))(a1 + 24))(a2, *(_DWORD *)(a1 + 8));
  if ( *(_DWORD *)(a1 + 8) <= v3 )
    abort();
  return 8 * v3 + *(_DWORD *)a1;
}

//----- (08057DE0) --------------------------------------------------------
bool __cdecl sub_8057DE0(unsigned int a1)
{
  int v1; // ST08_4
  unsigned int v3; // [esp+8h] [ebp-8h]
  unsigned int v4; // [esp+Ch] [ebp-4h]

  v3 = 3;
  v4 = 9;
  while ( v4 < a1 && a1 % v3 )
  {
    v1 = v3 + 1;
    v4 += 4 * v1;
    v3 = v1 + 1;
  }
  return a1 % v3 != 0;
}

//----- (08057E37) --------------------------------------------------------
int __cdecl sub_8057E37(unsigned int a1)
{
  int i; // [esp+Ch] [ebp+8h]

  if ( a1 <= 9 )
    a1 = 10;
  for ( i = a1 | 1; i != -1 && !sub_8057DE0(i); i += 2 )
    ;
  return i;
}

//----- (08057EA8) --------------------------------------------------------
unsigned int __cdecl sub_8057EA8(int a1, unsigned int a2)
{
  return sub_805FC05(a1, 3) % a2;
}

//----- (08057ED3) --------------------------------------------------------
bool __cdecl sub_8057ED3(int a1, int a2)
{
  return a1 == a2;
}

//----- (08057EE1) --------------------------------------------------------
signed int __cdecl sub_8057EE1(int a1)
{
  int v2; // [esp+8h] [ebp-8h]
  float v3; // [esp+Ch] [ebp-4h]

  v2 = *(_DWORD *)(a1 + 20);
  if ( (_UNKNOWN *)v2 == &unk_8063F18 )
    return 1;
  v3 = 0.1;
  if ( *(float *)(v2 + 8) > 0.1
    && 1.0 - v3 > *(float *)(v2 + 8)
    && *(float *)(v2 + 12) > v3 + 1.0
    && *(float *)v2 >= 0.0
    && *(float *)(v2 + 4) > *(float *)v2 + v3
    && *(float *)(v2 + 4) <= 1.0
    && *(float *)(v2 + 8) > *(float *)v2 + v3 )
  {
    dword_806B234 = (int)&locret_8057FB4;
    sub_806185D();
  }
  *(_DWORD *)(a1 + 20) = &unk_8063F18;
  return 0;
}
// 806185D: using guessed type int sub_806185D(void);
// 806B234: using guessed type int dword_806B234;

//----- (08057FB6) --------------------------------------------------------
unsigned int __usercall sub_8057FB6@<eax>(int a1@<edx>, int a2@<ecx>, unsigned int a3, int a4)
{
  void *v4; // eax
  unsigned int result; // eax
  float v6; // [esp+20h] [ebp-4h]
  unsigned int v7; // [esp+2Ch] [ebp+8h]

  v4 = &loc_8057FE3;
  if ( *(_BYTE *)(a4 + 16) == 1 )
    v4 = &loc_8058039;
  dword_806B270 = (int)v4;
  sub_80616F6(a2, a1);
  v6 = (long double)a3 / *(float *)(a4 + 8);
  if ( v6 >= 4294967300.0 )
    return 0;
  v7 = sub_8057E37((signed __int64)v6);
  if ( v7 <= 0x1FFFFFFF )
    result = v7;
  else
    result = 0;
  return result;
}
// 80616F6: using guessed type int __fastcall sub_80616F6(_DWORD, _DWORD);
// 806B270: using guessed type int dword_806B270;

//----- (0805805C) --------------------------------------------------------
int sub_805805C()
{
  bool v0; // zf
  void *v1; // eax

  v0 = malloc(0x28u) == 0;
  v1 = &loc_80580AA;
  if ( !v0 )
    v1 = &loc_80580B4;
  dword_806B2FC = (int)v1;
  sub_80613B1();
  return 0;
}
// 806B2FC: using guessed type int dword_806B2FC;

//----- (080583F8) --------------------------------------------------------
void *__cdecl sub_80583F8(int a1)
{
  int v2; // [esp+1Ch] [ebp-Ch]

  if ( !*(_DWORD *)(a1 + 36) )
    return malloc(8u);
  v2 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(v2 + 4);
  return (void *)v2;
}

//----- (08058433) --------------------------------------------------------
int __cdecl sub_8058433(int a1, _DWORD *a2)
{
  int result; // eax

  *a2 = 0;
  a2[1] = *(_DWORD *)(a1 + 36);
  result = a1;
  *(_DWORD *)(a1 + 36) = a2;
  return result;
}

//----- (08058456) --------------------------------------------------------
int __cdecl sub_8058456(int a1, int a2, _DWORD *a3, char a4)
{
  int v4; // ecx
  _DWORD *v5; // edx
  int result; // eax
  unsigned __int8 (*v7)(void); // eax
  void *v8; // eax
  void *v9; // eax
  _DWORD *v10; // ecx
  int v11; // edx
  int v12; // edx
  int v13; // ecx
  unsigned __int8 (__cdecl *v14)(int, int); // eax
  void *v15; // eax
  int v16; // edx
  int v17; // ecx
  int v18; // [esp+0h] [ebp-38h]
  int v19; // [esp+4h] [ebp-34h]
  char v20; // [esp+Ch] [ebp-2Ch]
  _DWORD *i; // [esp+18h] [ebp-20h]
  _DWORD *v22; // [esp+1Ch] [ebp-1Ch]
  int v23; // [esp+20h] [ebp-18h]
  _DWORD *v24; // [esp+24h] [ebp-14h]
  int v25; // [esp+28h] [ebp-10h]
  _DWORD *v26; // [esp+2Ch] [ebp-Ch]

  v20 = a4;
  v22 = (_DWORD *)sub_8057AC1(a1, a2);
  v5 = v22;
  *a3 = v22;
  if ( !*v22 )
    return 0;
  if ( *v22 == a2 || (v7 = *(unsigned __int8 (**)(void))(a1 + 28), v19 = *v22, v18 = a2, v7()) )
  {
    v25 = *v22;
    v8 = &loc_80584E2;
    if ( !v20 )
      v8 = &loc_8058550;
    dword_806B324 = (int)v8;
    sub_80612C5(v4, v5);
    v9 = &loc_8058505;
    if ( !v22[1] )
      v9 = &loc_8058547;
    dword_806B2D4 = (int)v9;
    sub_80614AE(v18, v19);
    v26 = (_DWORD *)v22[1];
    v10 = v22;
    v11 = v26[1];
    *v22 = *v26;
    v10[1] = v11;
    sub_8058433(a1, v26);
    dword_806B324 = (int)&loc_8058550;
    sub_80612C5(v13, v12);
    *v22 = 0;
    result = v25;
  }
  else
  {
    for ( i = v22; i[1]; i = (_DWORD *)i[1] )
    {
      if ( *(_DWORD *)i[1] != a2 )
      {
        v14 = *(unsigned __int8 (__cdecl **)(int, int))(a1 + 28);
        v19 = *(_DWORD *)i[1];
        if ( !v14(a2, v19) )
          continue;
      }
      v23 = *(_DWORD *)i[1];
      v15 = &loc_80585B8;
      if ( !v20 )
        v15 = &loc_80585DF;
      dword_806B220 = (int)v15;
      sub_80618EC();
      v24 = (_DWORD *)i[1];
      i[1] = v24[1];
      sub_8058433(a1, v24);
      dword_806B270 = (int)&locret_8058615;
      sub_80616F6(v17, v16);
    }
    result = 0;
  }
  return result;
}
// 8058456: could not find valid save-restore pair for ebx
// 80612C5: using guessed type int __fastcall sub_80612C5(_DWORD, _DWORD);
// 80616F6: using guessed type int __fastcall sub_80616F6(_DWORD, _DWORD);
// 80618EC: using guessed type int sub_80618EC(void);
// 806B220: using guessed type int dword_806B220;
// 806B270: using guessed type int dword_806B270;
// 806B2D4: using guessed type int dword_806B2D4;
// 806B324: using guessed type int dword_806B324;

//----- (08058617) --------------------------------------------------------
signed int __cdecl sub_8058617(int a1, int a2, char a3)
{
  _DWORD *v3; // eax
  bool v4; // zf
  void *v5; // eax
  void *v6; // eax
  void *v7; // eax
  int v9; // [esp+0h] [ebp-38h]
  int v10; // [esp+4h] [ebp-34h]
  char v11; // [esp+Ch] [ebp-2Ch]
  int *i; // [esp+18h] [ebp-20h]
  int *v13; // [esp+1Ch] [ebp-1Ch]
  int v14; // [esp+20h] [ebp-18h]
  _DWORD *v15; // [esp+24h] [ebp-14h]
  int *v16; // [esp+28h] [ebp-10h]

  v11 = a3;
  for ( i = *(int **)a2; *(_DWORD *)(a2 + 4) > (unsigned int)i; i += 2 )
  {
    if ( *i )
    {
      v13 = (int *)i[1];
      dword_806B2D4 = (int)&loc_80586EB;
      sub_80614AE(v9, v10);
      v14 = *v13;
      v3 = (_DWORD *)sub_8057AC1(a1, v14);
      v15 = v3;
      v16 = (int *)v13[1];
      v4 = *v3 == 0;
      v5 = &loc_80586A5;
      if ( v4 )
        v5 = &loc_80586BC;
      dword_806B338 = (int)v5;
      sub_8061251();
      v13[1] = v15[1];
      v15[1] = v13;
      v13 = v16;
      v6 = &loc_805870A;
      if ( v16 )
        v6 = &loc_805865D;
      dword_806B298 = (int)v6;
      sub_8061616();
      v14 = *i;
      i[1] = 0;
      v7 = &loc_805873B;
      if ( !v11 )
        v7 = &loc_8058740;
      dword_806B2C0 = (int)v7;
      sub_8061526();
    }
  }
  return 1;
}
// 8058617: could not find valid save-restore pair for ebx
// 8061251: using guessed type int sub_8061251(void);
// 8061526: using guessed type int sub_8061526(void);
// 8061616: using guessed type int sub_8061616(void);
// 806B298: using guessed type int dword_806B298;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B2D4: using guessed type int dword_806B2D4;
// 806B338: using guessed type int dword_806B338;

//----- (08058813) --------------------------------------------------------
signed int __usercall sub_8058813@<eax>(int a1@<edx>, int a2@<ecx>, int a3, unsigned int a4)
{
  void *v5; // eax
  unsigned int nmemb; // [esp+10h] [ebp-38h]

  nmemb = sub_8057FB6(a1, a2, a4, *(_DWORD *)(a3 + 20));
  if ( !nmemb )
    return 0;
  v5 = &loc_8058865;
  if ( *(_DWORD *)(a3 + 8) != nmemb )
    v5 = &loc_805886F;
  dword_806B284 = (int)v5;
  sub_8061686();
  return 1;
}
// 8061686: using guessed type int sub_8061686(void);
// 806B284: using guessed type int dword_806B284;

//----- (08058A28) --------------------------------------------------------
signed int __cdecl sub_8058A28(unsigned int *a1, int a2, _DWORD *a3)
{
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  signed int result; // eax
  long double v7; // fst7
  long double v8; // fst6
  int v9; // ecx
  long double v10; // fst7
  long double v11; // fst6
  long double v12; // fst7
  __int16 v13; // ax
  int v14; // [esp+0h] [ebp-48h]
  int v15; // [esp+4h] [ebp-44h]
  __int64 v16; // [esp+10h] [ebp-38h]
  __int16 v17; // [esp+1Ch] [ebp-2Ch]
  __int16 v18; // [esp+1Eh] [ebp-2Ah]
  int *v19; // [esp+2Ch] [ebp-1Ch]
  int v20; // [esp+30h] [ebp-18h]
  unsigned int v21; // [esp+34h] [ebp-14h]
  float v22; // [esp+38h] [ebp-10h]
  _DWORD *v23; // [esp+3Ch] [ebp-Ch]

  if ( !a2 )
    abort();
  v20 = sub_8058456((int)a1, a2, &v19, 0);
  if ( v20 )
  {
    v5 = &loc_8058A82;
    if ( !a3 )
      v5 = &loc_8058A8A;
    dword_806B270 = (int)v5;
    sub_80616F6(v4, v3);
    *a3 = v20;
    result = 0;
  }
  else
  {
    v16 = a1[3];
    v7 = (long double)v16;
    v8 = *(float *)(a1[5] + 8);
    v16 = a1[2];
    if ( v7 > v8 * (long double)v16 )
    {
      sub_8057EE1((int)a1);
      v16 = a1[3];
      v10 = (long double)v16;
      v11 = *(float *)(a1[5] + 8);
      v16 = a1[2];
      if ( v10 > v11 * (long double)v16 )
      {
        v21 = a1[5];
        if ( *(_BYTE *)(v21 + 16) )
          v12 = (long double)a1[2] * *(float *)(v21 + 12);
        else
          v12 = (long double)a1[2] * *(float *)(v21 + 12) * *(float *)(v21 + 8);
        v22 = v12;
        if ( v22 >= 4294967300.0 )
        {
          dword_806B324 = (int)&locret_8058CB5;
          sub_80612C5(v9, 0);
        }
        LOBYTE(v13) = v18;
        HIBYTE(v13) = 12;
        v17 = v13;
        v16 = (signed __int64)v22;
        if ( (unsigned __int8)sub_8058813(SHIDWORD(v16), v9, (int)a1, v16) ^ 1 )
        {
          dword_806B2D4 = (int)&locret_8058CB5;
          sub_80614AE(v14, v15);
        }
        if ( sub_8058456((int)a1, a2, &v19, 0) )
          abort();
      }
    }
    if ( *v19 )
    {
      v23 = sub_80583F8((int)a1);
      if ( !v23 )
        return -1;
      *v23 = a2;
      v23[1] = v19[1];
      v19[1] = (int)v23;
      ++a1[4];
      dword_806B360 = (int)&locret_8058CB5;
      sub_8061156();
    }
    *v19 = a2;
    ++a1[4];
    ++a1[3];
    result = 1;
  }
  return result;
}
// 8061156: using guessed type int sub_8061156(void);
// 80612C5: using guessed type int __fastcall sub_80612C5(_DWORD, _DWORD);
// 80616F6: using guessed type int __fastcall sub_80616F6(_DWORD, _DWORD);
// 806B270: using guessed type int dword_806B270;
// 806B2D4: using guessed type int dword_806B2D4;
// 806B324: using guessed type int dword_806B324;
// 806B360: using guessed type int dword_806B360;

//----- (08058CB7) --------------------------------------------------------
int __cdecl sub_8058CB7(unsigned int *a1, int a2)
{
  void *v2; // eax
  int v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]

  v5 = sub_8058A28(a1, a2, &v4);
  if ( v5 == -1 )
    return 0;
  v2 = &loc_8058CFE;
  if ( v5 )
    v2 = &loc_8058D18;
  dword_806B284 = (int)v2;
  sub_8061686();
  dword_806B298 = (int)&locret_8058D22;
  sub_8061616();
  return a2;
}
// 8061616: using guessed type int sub_8061616(void);
// 8061686: using guessed type int sub_8061686(void);
// 806B284: using guessed type int dword_806B284;
// 806B298: using guessed type int dword_806B298;

//----- (08058D24) --------------------------------------------------------
int __cdecl sub_8058D24(int a1, int a2)
{
  void *v3; // eax
  void *v4; // eax
  signed __int64 v5; // ST20_8
  int v6; // ecx
  int v7; // edx
  int v8; // ecx
  _DWORD *v9; // [esp+28h] [ebp-20h]
  void *ptr; // [esp+2Ch] [ebp-1Ch]
  int v11; // [esp+30h] [ebp-18h]
  int v12; // [esp+34h] [ebp-14h]
  int v13; // [esp+38h] [ebp-10h]
  void *v14; // [esp+3Ch] [ebp-Ch]

  v11 = sub_8058456(a1, a2, &v9, 1);
  if ( !v11 )
    return 0;
  --*(_DWORD *)(a1 + 16);
  v3 = &loc_8058D8F;
  if ( *v9 )
    v3 = &loc_8058F2E;
  dword_806B220 = (int)v3;
  sub_80618EC();
  if ( **(float **)(a1 + 20) * (long double)*(unsigned int *)(a1 + 8) > (long double)(unsigned int)--*(_DWORD *)(a1 + 12) )
  {
    sub_8057EE1(a1);
    if ( **(float **)(a1 + 20) * (long double)*(unsigned int *)(a1 + 8) > (long double)*(unsigned int *)(a1 + 12) )
    {
      v12 = *(_DWORD *)(a1 + 20);
      v4 = &loc_8058E4E;
      if ( !*(_BYTE *)(v12 + 16) )
        v4 = &loc_8058E88;
      dword_806B2FC = (int)v4;
      sub_80613B1();
      v5 = (signed __int64)((long double)*(unsigned int *)(a1 + 8) * *(float *)(v12 + 4));
      v13 = v5;
      if ( (unsigned __int8)sub_8058813(SHIDWORD(v5), v6, a1, v5) ^ 1 )
      {
        ptr = *(void **)(a1 + 36);
        dword_806B310 = (int)&loc_8058F1E;
        sub_8061339(v8, v7);
        do
        {
          v14 = (void *)*((_DWORD *)ptr + 1);
          free(ptr);
          ptr = v14;
        }
        while ( v14 );
        *(_DWORD *)(a1 + 36) = 0;
      }
    }
  }
  return v11;
}
// 8058D24: could not find valid save-restore pair for ebx
// 8061339: using guessed type int __fastcall sub_8061339(_DWORD, _DWORD);
// 80618EC: using guessed type int sub_80618EC(void);
// 806B220: using guessed type int dword_806B220;
// 806B2FC: using guessed type int dword_806B2FC;
// 806B310: using guessed type int dword_806B310;

//----- (08058F33) --------------------------------------------------------
_DWORD *__cdecl sub_8058F33(int a1, unsigned int a2)
{
  int v2; // ecx
  _DWORD *v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_805E14D(0x10u);
  if ( !a2 )
    a2 = 1;
  *v4 = sub_805E027(a2, 4u);
  *(_DWORD *)*v4 = 0;
  v4[1] = a2;
  v4[2] = 0;
  if ( a1 )
  {
    dword_806B310 = (int)&loc_8058FB2;
    sub_8061339(v2, a2);
  }
  v4[3] = sub_8058FBD;
  return v4;
}
// 8061339: using guessed type int __fastcall sub_8061339(_DWORD, _DWORD);
// 806B310: using guessed type int dword_806B310;

//----- (08058FBD) --------------------------------------------------------
int sub_8058FBD()
{
  return 0;
}

//----- (08058FC7) --------------------------------------------------------
void __cdecl sub_8058FC7(void *ptr)
{
  free(*(void **)ptr);
  free(ptr);
}

//----- (08058FE7) --------------------------------------------------------
int __cdecl sub_8058FE7(int a1, int a2)
{
  _DWORD *v2; // edx

  if ( (unsigned int)(*(_DWORD *)(a1 + 4) - 1) <= *(_DWORD *)(a1 + 8) )
    *(_DWORD *)a1 = sub_805E08A(*(void **)a1, a1 + 4, 4);
  v2 = *(_DWORD **)a1;
  v2[++*(_DWORD *)(a1 + 8)] = a2;
  sub_8059216(*(_DWORD *)a1, *(_DWORD *)(a1 + 8), *(int (__cdecl **)(_DWORD, int))(a1 + 12));
  return 0;
}

//----- (08059070) --------------------------------------------------------
int __usercall sub_8059070@<eax>(int a1@<edx>, int a2@<ecx>, int *a3)
{
  void *v3; // eax
  _DWORD *v4; // ebx
  int v5; // esi
  int v6; // eax
  int v8; // [esp+1Ch] [ebp-Ch]

  v3 = &loc_805909B;
  if ( a3[2] )
    v3 = &loc_80590B7;
  dword_806B324 = (int)v3;
  sub_80612C5(a2, a1);
  dword_806B220 = (int)&loc_8059113;
  sub_80618EC();
  v8 = *(_DWORD *)(*a3 + 4);
  v4 = (_DWORD *)(*a3 + 4);
  v5 = *a3;
  v6 = a3[2];
  a3[2] = v6 - 1;
  *v4 = *(_DWORD *)(v5 + 4 * v6);
  sub_805911A(*a3, a3[2], 1u, (int (__cdecl *)(_DWORD, int))a3[3]);
  return v8;
}
// 80612C5: using guessed type int __fastcall sub_80612C5(_DWORD, _DWORD);
// 80618EC: using guessed type int sub_80618EC(void);
// 806B220: using guessed type int dword_806B220;
// 806B324: using guessed type int dword_806B324;

//----- (0805911A) --------------------------------------------------------
unsigned int __cdecl sub_805911A(int a1, unsigned int a2, unsigned int a3, int (__cdecl *a4)(_DWORD, int))
{
  int v4; // eax
  bool v5; // zf
  bool v6; // sf
  void *v7; // eax
  int v9; // [esp+18h] [ebp-10h]
  int v10; // [esp+1Ch] [ebp-Ch]

  v10 = *(_DWORD *)(4 * a3 + a1);
  if ( a2 >> 1 >= a3 )
  {
    v9 = 2 * a3;
    if ( 2 * a3 < a2 && a4(*(_DWORD *)(8 * a3 + a1), *(_DWORD *)(4 * (2 * a3 + 1) + a1)) < 0 )
      ++v9;
    v4 = a4(*(_DWORD *)(4 * v9 + a1), v10);
    v5 = v4 == 0;
    v6 = v4 < 0;
    v7 = &loc_80591C5;
    if ( !v6 && !v5 )
      v7 = &loc_80591C7;
    dword_806B284 = (int)v7;
    sub_8061686();
  }
  *(_DWORD *)(a1 + 4 * a3) = v10;
  return a3;
}
// 8061686: using guessed type int sub_8061686(void);
// 806B284: using guessed type int dword_806B284;

//----- (08059216) --------------------------------------------------------
int __cdecl sub_8059216(int a1, unsigned int a2, int (__cdecl *a3)(_DWORD, int))
{
  int result; // eax
  unsigned int v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]

  v4 = a2;
  v5 = *(_DWORD *)(4 * a2 + a1);
  while ( v4 != 1 && a3(*(_DWORD *)(4 * (v4 >> 1) + a1), v5) <= 0 )
  {
    *(_DWORD *)(a1 + 4 * v4) = *(_DWORD *)(4 * (v4 >> 1) + a1);
    v4 >>= 1;
  }
  result = v5;
  *(_DWORD *)(a1 + 4 * v4) = v5;
  return result;
}

//----- (080592A6) --------------------------------------------------------
int __cdecl sub_80592A6(int a1, int a2)
{
  int v3; // [esp+Ch] [ebp-4h]

  v3 = a2 + 11;
  *(_BYTE *)(a2 + 11) = 0;
  if ( a1 >= 0 )
  {
    do
    {
      *(_BYTE *)--v3 = (char)a1 % 10 + 48;
      a1 /= 10;
    }
    while ( a1 );
  }
  else
  {
    do
    {
      *(_BYTE *)--v3 = 48 - (char)a1 % 10;
      a1 /= 10;
    }
    while ( a1 );
    *(_BYTE *)--v3 = 45;
  }
  return v3;
}

//----- (08059380) --------------------------------------------------------
int __cdecl sub_8059380(unsigned int a1, int a2)
{
  int v3; // [esp+Ch] [ebp-4h]

  v3 = a2 + 10;
  *(_BYTE *)(a2 + 10) = 0;
  do
  {
    *(_BYTE *)--v3 = a1 % 0xA + 48;
    a1 /= 0xAu;
  }
  while ( a1 );
  return v3;
}

//----- (080593DE) --------------------------------------------------------
int __cdecl sub_80593DE(signed __int64 a1, int a2)
{
  signed __int64 v3; // [esp+18h] [ebp-20h]
  int v4; // [esp+2Ch] [ebp-Ch]

  v3 = a1;
  v4 = a2 + 20;
  *(_BYTE *)(a2 + 20) = 0;
  do
  {
    *(_BYTE *)--v4 = sub_8060E00(v3, 10LL) + 48;
    v3 = sub_8060CE0(v3, 0xAu, 0);
  }
  while ( v3 );
  return v4;
}

//----- (08059491) --------------------------------------------------------
int __cdecl sub_8059491(char *a1, int a2, char a3)
{
  int v3; // edx
  int v4; // ecx
  signed int v5; // eax
  int v7; // edx
  int v8; // ecx
  void *v9; // eax
  char *v10; // eax
  const unsigned __int16 **v11; // eax
  int v12; // ecx
  int v13; // edx
  void *v14; // eax
  const unsigned __int16 **v15; // eax
  char *v16; // [esp+1Ch] [ebp-3Ch]
  unsigned __int8 v17; // [esp+2Bh] [ebp-2Dh]
  wint_t wc; // [esp+2Ch] [ebp-2Ch]
  char *v19; // [esp+30h] [ebp-28h]
  int v20; // [esp+34h] [ebp-24h]
  size_t v21; // [esp+38h] [ebp-20h]
  char *v22; // [esp+3Ch] [ebp-1Ch]
  int v23; // [esp+40h] [ebp-18h]
  const mbstate_t s; // [esp+44h] [ebp-14h]
  unsigned int v25; // [esp+4Ch] [ebp-Ch]

  v16 = a1;
  v25 = __readgsdword(0x14u);
  v19 = a1;
  v22 = &a1[a2];
  v20 = 0;
  if ( __ctype_get_mb_cur_max() <= 1 )
  {
    dword_806B2E8 = (int)&loc_805977D;
    sub_8061429(v4, v3);
    do
    {
      v10 = v19++;
      v17 = *v10;
      v11 = __ctype_b_loc();
      v13 = v17;
      if ( (*v11)[v13] & 0x4000 )
      {
        if ( v20 == 0x7FFFFFFF )
        {
          dword_806B298 = (int)&loc_80597A3;
          sub_8061616();
        }
        ++v20;
      }
      else
      {
        v14 = &loc_8059734;
        if ( a3 & 2 )
          v14 = &loc_8059776;
        dword_806B374 = (int)v14;
        sub_80610EA();
        v15 = __ctype_b_loc();
        v13 = v17;
        if ( !((*v15)[v13] & 2) )
        {
          if ( v20 == 0x7FFFFFFF )
          {
            dword_806B20C = (int)&loc_80597A3;
            sub_806195A();
          }
          ++v20;
        }
      }
    }
    while ( v19 < v22 );
    dword_806B270 = (int)&loc_80597A8;
    sub_80616F6(v12, v13 * 2);
    return 0x7FFFFFFF;
  }
LABEL_32:
  while ( 2 )
  {
    if ( v19 >= v22 )
      return v20;
    v5 = *v19;
    if ( v5 > 63 )
    {
      if ( v5 >= 65 && (v5 <= 95 || (unsigned int)(v5 - 97) <= 0x1D) )
        goto LABEL_10;
    }
    else if ( v5 >= 37 || (unsigned int)(v5 - 32) <= 3 )
    {
LABEL_10:
      ++v19;
      ++v20;
      dword_806B324 = (int)&loc_8059693;
      sub_80612C5(v4, v3);
      goto LABEL_11;
    }
LABEL_11:
    memset((void *)&s, 0, 8u);
    while ( 1 )
    {
      v21 = sub_805F50B((wchar_t *)&wc, v19, v22 - v19, (mbstate_t *)&s);
      if ( v21 == -1 )
      {
        if ( !(a3 & 1) )
        {
          ++v19;
          ++v20;
          dword_806B25C = (int)&loc_8059693;
          sub_806177B();
        }
        dword_806B298 = (int)&loc_80597A8;
        sub_8061616();
      }
      if ( v21 == -2 )
        break;
      if ( !v21 )
        v21 = 1;
      v23 = wcwidth(wc);
      if ( v23 >= 0 )
      {
        v9 = &loc_8059621;
        if ( 0x7FFFFFFF - v20 >= v23 )
          v9 = &loc_8059626;
        dword_806B324 = (int)v9;
        sub_80612C5(v8, v7);
        return 0x7FFFFFFF;
      }
      if ( a3 & 2 )
        return -1;
      if ( !iswcntrl(wc) )
      {
        if ( v20 == 0x7FFFFFFF )
          return 0x7FFFFFFF;
        ++v20;
      }
      v19 += v21;
      if ( mbsinit(&s) )
        goto LABEL_32;
    }
    if ( !(a3 & 1) )
    {
      v19 = v22;
      ++v20;
      continue;
    }
    return -1;
  }
}
// 8049800: using guessed type int __cdecl wcwidth(_DWORD);
// 80610EA: using guessed type int sub_80610EA(void);
// 80612C5: using guessed type int __fastcall sub_80612C5(_DWORD, _DWORD);
// 8061429: using guessed type int __fastcall sub_8061429(_DWORD, _DWORD);
// 8061616: using guessed type int sub_8061616(void);
// 80616F6: using guessed type int __fastcall sub_80616F6(_DWORD, _DWORD);
// 806177B: using guessed type int sub_806177B(void);
// 806195A: using guessed type int sub_806195A(void);
// 806B20C: using guessed type int dword_806B20C;
// 806B25C: using guessed type int dword_806B25C;
// 806B270: using guessed type int dword_806B270;
// 806B298: using guessed type int dword_806B298;
// 806B2E8: using guessed type int dword_806B2E8;
// 806B324: using guessed type int dword_806B324;
// 806B374: using guessed type int dword_806B374;

//----- (080597BB) --------------------------------------------------------
int sub_80597BB()
{
  int v0; // eax
  bool v1; // zf
  void *v2; // eax
  int v4; // [esp+1Ch] [ebp-8Ch]
  char v5; // [esp+20h] [ebp-88h]

  if ( sched_getaffinity(0, 128, &v5) )
    return 0;
  v0 = __sched_cpucount(128, &v5);
  v4 = v0;
  v1 = v0 == 0;
  v2 = &loc_8059824;
  if ( v1 )
    v2 = &loc_805982C;
  dword_806B248 = (int)v2;
  sub_80617ED();
  return v4;
}
// 80498D0: using guessed type int __cdecl __sched_cpucount(_DWORD, _DWORD);
// 8049E70: using guessed type int __cdecl sched_getaffinity(_DWORD, _DWORD, _DWORD);
// 80617ED: using guessed type int sub_80617ED(void);
// 806B248: using guessed type int dword_806B248;

//----- (08059833) --------------------------------------------------------
signed int __cdecl sub_8059833(int a1)
{
  signed int result; // eax
  int v2; // eax
  int v3; // edx
  int v4; // ecx
  bool v5; // zf
  void *v6; // eax
  int v7; // [esp+10h] [ebp-18h]
  int v8; // [esp+14h] [ebp-14h]
  int v9; // [esp+18h] [ebp-10h]
  int v10; // [esp+1Ch] [ebp-Ch]

  if ( a1 == 1 )
  {
    v8 = sub_80597BB();
    if ( v8 )
      return v8;
    v9 = sysconf(84);
    if ( v9 > 0 )
      return v9;
    dword_806B2FC = (int)&loc_80598D3;
    sub_80613B1();
  }
  v7 = sysconf(83);
  if ( v7 == 1 )
  {
    v2 = sub_80597BB();
    v10 = v2;
    v5 = v2 == 0;
    v6 = &loc_80598C2;
    if ( v5 )
      v6 = &loc_80598C8;
    dword_806B310 = (int)v6;
    sub_8061339(v4, v3);
    v7 = v10;
  }
  if ( v7 <= 0 )
    result = 1;
  else
    result = v7;
  return result;
}
// 8061339: using guessed type int __fastcall sub_8061339(_DWORD, _DWORD);
// 806B2FC: using guessed type int dword_806B2FC;
// 806B310: using guessed type int dword_806B310;

//----- (080598DA) --------------------------------------------------------
unsigned int __cdecl sub_80598DA(char *nptr)
{
  unsigned int result; // eax
  void *v2; // eax
  int v3; // edx
  int v4; // ecx
  int v5; // [esp+0h] [ebp-28h]
  int v6; // [esp+4h] [ebp-24h]
  char *endptr; // [esp+14h] [ebp-14h]
  unsigned int v8; // [esp+18h] [ebp-10h]
  unsigned int v9; // [esp+1Ch] [ebp-Ch]

  v8 = 0;
  if ( !nptr )
    return v8;
  while ( 1 )
  {
    v2 = &loc_805991E;
    if ( !*nptr )
      v2 = &loc_8059933;
    dword_806B2C0 = (int)v2;
    sub_8061526();
    if ( !(unsigned __int8)sub_805FEAE(*nptr) )
      break;
    ++nptr;
  }
  if ( !(unsigned __int8)sub_805FDD6(*nptr) )
    goto LABEL_20;
  endptr = 0;
  v9 = strtoul(nptr, &endptr, 10);
  if ( !endptr )
    goto LABEL_20;
  dword_806B310 = (int)&loc_8059997;
  sub_8061339(v4, v3);
  do
    ++endptr;
  while ( *endptr && (unsigned __int8)sub_805FEAE(*endptr) );
  if ( !*endptr )
  {
    dword_806B2D4 = (int)&locret_80599EC;
    sub_80614AE(v5, v6);
  }
  if ( *endptr == 44 )
    result = v9;
  else
LABEL_20:
    result = v8;
  return result;
}
// 8061339: using guessed type int __fastcall sub_8061339(_DWORD, _DWORD);
// 8061526: using guessed type int sub_8061526(void);
// 806B2C0: using guessed type int dword_806B2C0;
// 806B2D4: using guessed type int dword_806B2D4;
// 806B310: using guessed type int dword_806B310;

//----- (080599EE) --------------------------------------------------------
unsigned int __cdecl sub_80599EE(int a1)
{
  char *v1; // eax
  char *v2; // eax
  unsigned int result; // eax
  unsigned int v4; // [esp+14h] [ebp-14h]
  unsigned int v5; // [esp+18h] [ebp-10h]

  v4 = -1;
  if ( a1 == 2 )
  {
    v1 = getenv("OMP_NUM_THREADS");
    v5 = sub_80598DA(v1);
    v2 = getenv("OMP_THREAD_LIMIT");
    v4 = sub_80598DA(v2);
    if ( !v4 )
      v4 = -1;
    if ( v5 )
    {
      result = v5;
      if ( v4 <= v5 )
        result = v4;
      return result;
    }
    a1 = 1;
  }
  result = sub_8059833(a1);
  if ( v4 <= result )
    result = v4;
  return result;
}

//----- (08059A6F) --------------------------------------------------------
long double sub_8059A6F()
{
  int v1; // ecx
  double v2; // [esp+18h] [ebp-60h]
  double v3; // [esp+20h] [ebp-58h]
  char v4; // [esp+2Ch] [ebp-4Ch]
  unsigned int v5; // [esp+6Ch] [ebp-Ch]

  v5 = __readgsdword(0x14u);
  v2 = (long double)sysconf(85);
  v3 = (long double)sysconf(30);
  if ( v2 >= 0.0 && v3 >= 0.0 )
    return v2 * v3;
  if ( !sysinfo((struct sysinfo *)&v4) )
  {
    dword_806B34C = (int)&loc_8059B1C;
    sub_80611C6(v1, 0);
  }
  return 67108864.0;
}
// 80611C6: using guessed type int __fastcall sub_80611C6(_DWORD, _DWORD);
// 806B34C: using guessed type int dword_806B34C;

//----- (08059B31) --------------------------------------------------------
long double sub_8059B31()
{
  double v1; // [esp+18h] [ebp-60h]
  double v2; // [esp+20h] [ebp-58h]
  char v3; // [esp+2Ch] [ebp-4Ch]
  unsigned int v4; // [esp+40h] [ebp-38h]
  unsigned int v5; // [esp+48h] [ebp-30h]
  unsigned int v6; // [esp+60h] [ebp-18h]
  unsigned int v7; // [esp+6Ch] [ebp-Ch]

  v7 = __readgsdword(0x14u);
  v1 = (long double)sysconf(86);
  v2 = (long double)sysconf(30);
  if ( v1 >= 0.0 && v2 >= 0.0 )
    return v1 * v2;
  if ( sysinfo((struct sysinfo *)&v3) )
    return sub_8059A6F() / 4.0;
  return ((long double)v4 + (long double)v5) * (long double)v6;
}

//----- (08059BF8) --------------------------------------------------------
int __cdecl sub_8059BF8(int pipedes[2], int a2)
{
  int v2; // ST30_4
  int v3; // ST34_4
  void *v5; // eax
  int *__attribute__((__org_arrdim(0,2))) v6; // [esp+0h] [ebp-38h]
  int v7; // [esp+4h] [ebp-34h]
  int v8; // [esp+18h] [ebp-20h]

  v2 = *pipedes;
  v3 = pipedes[1];
  if ( dword_806C330 >= 0 )
  {
    v7 = a2;
    v6 = pipedes;
    v8 = pipe2();
    if ( v8 >= 0 || *__errno_location() != 38 )
    {
      dword_806C330 = 1;
      return v8;
    }
    dword_806C330 = -1;
  }
  v5 = &loc_8059C80;
  if ( !(a2 & 0xFFF7F7FF) )
    v5 = &loc_8059C95;
  dword_806B2D4 = (int)v5;
  sub_80614AE(v6, v7);
  *__errno_location() = 22;
  return -1;
}
// 8049DF0: using guessed type int pipe2(void);
// 806B2D4: using guessed type int dword_806B2D4;
// 806C330: using guessed type int dword_806C330;

//----- (08059EAB) --------------------------------------------------------
int sub_8059EAB()
{
  int v0; // edx
  int v1; // ecx
  void *v2; // eax
  char *endptr; // [esp+10h] [ebp-18h]
  int v5; // [esp+14h] [ebp-14h]
  char *nptr; // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]

  v5 = 200809;
  nptr = getenv("_POSIX2_VERSION");
  if ( nptr )
  {
    v2 = &loc_8059EF0;
    if ( !*nptr )
      v2 = &loc_8059F1D;
    dword_806B310 = (int)v2;
    sub_8061339(v1, v0);
    v7 = strtol(nptr, &endptr, 10);
    if ( !*endptr )
      v5 = v7;
  }
  return v5;
}
// 8061339: using guessed type int __fastcall sub_8061339(_DWORD, _DWORD);
// 806B310: using guessed type int dword_806B310;

//----- (08059F22) --------------------------------------------------------
char *__cdecl sub_8059F22(char *s)
{
  char *result; // eax
  char *v2; // [esp+18h] [ebp-10h]

  if ( !s )
  {
    fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
    abort();
  }
  v2 = strrchr(s, 47);
  if ( v2 )
  {
    dword_806B360 = (int)&loc_8059F94;
    sub_8061156();
  }
  dword_806C334 = (int)s;
  result = s;
  program_invocation_name = (int)s;
  return result;
}
// 8061156: using guessed type int sub_8061156(void);
// 806B360: using guessed type int dword_806B360;
// 806B4C0: using guessed type int program_invocation_short_name;
// 806B4D0: using guessed type int program_invocation_name;
// 806C334: using guessed type int dword_806C334;

//----- (0805A09C) --------------------------------------------------------
unsigned int __cdecl sub_805A09C(int a1, unsigned __int8 a2, char a3)
{
  unsigned int v3; // ST10_4

  if ( a1 )
  {
    dword_806B2FC = (int)&loc_805A0D5;
    sub_80613B1();
  }
  v3 = ((unsigned int)dword_806C344[(a2 >> 5) + 2] >> (a2 & 0x1F)) & 1;
  dword_806C344[(a2 >> 5) + 2] ^= (v3 ^ a3 & 1) << (a2 & 0x1F);
  return v3;
}
// 806B2FC: using guessed type int dword_806B2FC;
// 806C344: using guessed type int dword_806C344[];

//----- (0805A15B) --------------------------------------------------------
int *__usercall sub_805A15B@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5)
{
  void *v5; // eax
  int *result; // eax

  v5 = &loc_805A180;
  if ( a3 )
    v5 = &loc_805A187;
  dword_806B2E8 = (int)v5;
  sub_8061429(a2, a1);
  dword_806C344[0] = 10;
  if ( !a4 || !a5 )
    abort();
  dword_806C344[10] = a4;
  result = dword_806C344;
  dword_806C344[11] = a5;
  return result;
}
// 8061429: using guessed type int __fastcall sub_8061429(_DWORD, _DWORD);
// 806B2E8: using guessed type int dword_806B2E8;
// 806C344: using guessed type int dword_806C344[];

//----- (0805A1B5) --------------------------------------------------------
void __cdecl __noreturn sub_805A1B5(int a1, int a2)
{
  int (__stdcall *v2)(int); // eax
  char v3; // [esp+0h] [ebp-38h]

  memset(&v3, 0, 0x30u);
  v2 = (int (__stdcall *)(int))&loc_805A1EF;
  if ( a2 != 10 )
    v2 = sub_805A1F4;
  dword_806B2FC = (int)v2;
  sub_80613B1();
  abort();
}
// 805A1F4: using guessed type int __stdcall sub_805A1F4(int);
// 806B2FC: using guessed type int dword_806B2FC;

//----- (0805A1F4) --------------------------------------------------------
#error "805A24A: positive sp value has been found (funcsize=0)"

//----- (0805A250) --------------------------------------------------------
void __cdecl __noreturn sub_805A250(char *msgid)
{
  int v1; // edx
  int v2; // ecx

  if ( gettext(msgid) != msgid )
  {
    dword_806B324 = (int)sub_805A35D;
    sub_80612C5(v2, v1);
  }
  sub_80608C5();
}
// 805A35D: using guessed type int sub_805A35D();
// 80612C5: using guessed type int __fastcall sub_80612C5(_DWORD, _DWORD);
// 806B324: using guessed type int dword_806B324;

//----- (0805A35F) --------------------------------------------------------
int __cdecl sub_805A35F(int a1, unsigned int a2, char *a3, size_t a4, char *a5, int a6, int a7, char *a8, char *a9)
{
  int v9; // edx
  int v10; // ecx
  void *v11; // eax
  void *v12; // eax
  int v13; // ecx
  size_t v14; // ebx
  size_t v15; // eax
  int v16; // edx
  void *v17; // eax
  void *v18; // eax
  void *v19; // eax
  void *v20; // eax
  void *v21; // eax
  bool v22; // al
  void *v23; // eax
  void *v24; // eax
  void *v25; // eax
  const unsigned __int16 **v26; // eax
  int v27; // edx
  int v28; // ecx
  void *v29; // eax
  int v30; // edx
  int v31; // ecx
  void *v32; // eax
  bool v33; // zf
  void *v34; // eax
  void *v35; // eax
  void *v36; // eax
  void *v37; // eax
  char v38; // al
  void *v39; // eax
  void *v40; // eax
  int result; // eax
  void *v42; // eax
  void *v43; // eax
  int v44; // [esp+0h] [ebp-88h]
  char *v45; // [esp+4h] [ebp-84h]
  size_t v46; // [esp+8h] [ebp-80h]
  char *v47; // [esp+2Ch] [ebp-5Ch]
  char *v48; // [esp+30h] [ebp-58h]
  int v49; // [esp+34h] [ebp-54h]
  char *v50; // [esp+38h] [ebp-50h]
  int v51; // [esp+3Ch] [ebp-4Ch]
  char v52; // [esp+40h] [ebp-48h]
  bool v53; // [esp+41h] [ebp-47h]
  char v54; // [esp+42h] [ebp-46h]
  char v55; // [esp+43h] [ebp-45h]
  char v56; // [esp+44h] [ebp-44h]
  unsigned __int8 v57; // [esp+45h] [ebp-43h]
  char v58; // [esp+46h] [ebp-42h]
  char v59; // [esp+47h] [ebp-41h]
  char v60; // [esp+48h] [ebp-40h]
  bool v61; // [esp+49h] [ebp-3Fh]
  bool v62; // [esp+4Ah] [ebp-3Eh]
  bool v63; // [esp+4Bh] [ebp-3Dh]
  wint_t wc; // [esp+4Ch] [ebp-3Ch]
  int v65; // [esp+50h] [ebp-38h]
  unsigned int v66; // [esp+54h] [ebp-34h]
  unsigned int v67; // [esp+58h] [ebp-30h]
  char *s; // [esp+5Ch] [ebp-2Ch]
  size_t n; // [esp+60h] [ebp-28h]
  unsigned int v70; // [esp+64h] [ebp-24h]
  unsigned int v71; // [esp+68h] [ebp-20h]
  size_t v72; // [esp+6Ch] [ebp-1Ch]
  unsigned int v73; // [esp+70h] [ebp-18h]
  mbstate_t ps; // [esp+74h] [ebp-14h]
  unsigned int v75; // [esp+7Ch] [ebp-Ch]

  v51 = a1;
  v50 = a3;
  v49 = a7;
  v48 = a8;
  v47 = a9;
  v75 = __readgsdword(0x14u);
  v66 = 0;
  v67 = 0;
  s = 0;
  n = 0;
  v52 = 0;
  v63 = __ctype_get_mb_cur_max() == 1;
  v53 = (a6 & 2) != 0;
  v54 = 0;
  v55 = 0;
  v56 = 1;
  while ( 1 )
  {
    switch ( (unsigned int)a5 )
    {
      case 0u:
        v53 = 0;
        dword_806B2C0 = (int)&loc_805A557;
        sub_8061526();
        goto LABEL_29;
      case 1u:
        goto LABEL_20;
      case 2u:
        goto LABEL_23;
      case 3u:
        v52 = 1;
LABEL_20:
        v53 = 1;
        goto LABEL_21;
      case 4u:
LABEL_21:
        if ( v53 != 1 )
          v52 = 1;
LABEL_23:
        a5 = (char *)2;
        v11 = &loc_805A510;
        if ( v53 == 1 )
          v11 = &loc_805A527;
        dword_806B284 = (int)v11;
        sub_8061686();
        if ( v66 < a2 )
        {
          v9 = v51;
          *(_BYTE *)(v51 + v66) = 39;
        }
        ++v66;
        s = "'";
        n = 1;
        break;
      case 5u:
        goto LABEL_4;
      case 6u:
        a5 = (char *)5;
        v53 = 1;
LABEL_4:
        if ( v53 != 1 )
        {
          if ( v66 < a2 )
          {
            v9 = v51;
            *(_BYTE *)(v51 + v66) = 34;
          }
          ++v66;
        }
        v52 = 1;
        s = (char *)&unk_806412D;
        n = 1;
        break;
      case 7u:
        v52 = 1;
        v53 = 0;
        break;
      case 8u:
      case 9u:
      case 0xAu:
        if ( a5 != (char *)10 )
        {
          v45 = a5;
          sub_805A250("`");
        }
        if ( v53 != 1 )
        {
          for ( s = v48; *s; ++s )
          {
            if ( v66 < a2 )
              *(_BYTE *)(v66 + v51) = *s;
            ++v66;
          }
        }
        v52 = 1;
        s = v47;
        n = strlen(v47);
        break;
      default:
LABEL_29:
        abort();
        return result;
    }
    v65 = 0;
LABEL_228:
    if ( a4 == -1 )
    {
      v38 = v50[v65];
      dword_806B2C0 = (int)&loc_805B0C5;
      sub_8061526();
    }
    if ( v65 != a4 )
      break;
    v39 = &loc_805B0EC;
    if ( v66 )
      v39 = &loc_805B0FD;
    dword_806B2E8 = (int)v39;
    sub_8061429(v10, v9);
    if ( a5 == (char *)2 && v53 )
      goto LABEL_256;
    if ( a5 != (char *)2 || v53 == 1 )
      goto LABEL_262;
    v40 = &loc_805B135;
    if ( !v55 )
      v40 = &loc_805B1BB;
    dword_806B284 = (int)v40;
    sub_8061686();
    if ( v56 )
      return sub_805A35F(v51, v67, v50, a4, (char *)5, a6, v49, v48, v47);
    if ( a2 )
    {
LABEL_262:
      if ( s )
      {
        v43 = &loc_805B1E5;
        if ( v53 == 1 )
          v43 = &loc_805B211;
        dword_806B360 = (int)v43;
        sub_8061156();
        while ( *s )
        {
          if ( v66 < a2 )
            *(_BYTE *)(v66 + v51) = *s;
          ++v66;
          ++s;
        }
      }
      if ( v66 < a2 )
        *(_BYTE *)(v51 + v66) = 0;
      dword_806B2FC = (int)&loc_805B29A;
      sub_80613B1();
      goto LABEL_256;
    }
    v42 = &loc_805B1A9;
    if ( !v67 )
      v42 = &loc_805B1BB;
    dword_806B2FC = (int)v42;
    sub_80613B1();
    a2 = v67;
    v66 = 0;
  }
  v59 = 0;
  v60 = 0;
  v61 = 0;
  v12 = &loc_805A58E;
  if ( !v52 )
    v12 = &loc_805A60C;
  dword_806B34C = (int)v12;
  sub_80611C6(v10, v9);
  if ( a5 != (char *)2 && n )
  {
    v14 = v65 + n;
    if ( a4 != -1 || n <= 1 )
    {
      v15 = a4;
    }
    else
    {
      v15 = strlen(v50);
      a4 = v15;
    }
    if ( v14 <= v15 && !memcmp(&v50[v65], s, n) )
    {
      if ( v53 )
      {
        dword_806B25C = (int)&loc_805B23E;
        sub_806177B();
      }
      v59 = 1;
    }
  }
  v16 = (int)v50;
  v57 = v50[v65];
  switch ( v57 )
  {
    case 0u:
      v17 = &loc_805A64F;
      if ( !v52 )
        v17 = &loc_805A751;
      dword_806B284 = (int)v17;
      sub_8061686();
      if ( v53 )
        goto LABEL_256;
      v60 = 1;
      if ( a5 == (char *)2 )
      {
        v18 = &loc_805A688;
        if ( v54 == 1 )
          v18 = &loc_805A6D1;
        dword_806B2C0 = (int)v18;
        sub_8061526();
        if ( v66 < a2 )
        {
          v16 = v51;
          *(_BYTE *)(v51 + v66) = 39;
        }
        if ( ++v66 < a2 )
        {
          v16 = v51;
          *(_BYTE *)(v51 + v66) = 36;
        }
        if ( ++v66 < a2 )
        {
          v16 = v51;
          *(_BYTE *)(v51 + v66) = 39;
        }
        ++v66;
        v54 = 1;
      }
      if ( v66 < a2 )
      {
        v16 = v51;
        *(_BYTE *)(v51 + v66) = 92;
      }
      ++v66;
      if ( a5 != (char *)2 && v65 + 1 < a4 )
      {
        v16 = v65 + 1;
        if ( v50[v65 + 1] > 47 )
        {
          v16 = v65 + 1;
          if ( v50[v65 + 1] <= 57 )
          {
            if ( v66 < a2 )
            {
              v16 = v51;
              *(_BYTE *)(v51 + v66) = 48;
            }
            if ( ++v66 < a2 )
            {
              v16 = v51;
              *(_BYTE *)(v51 + v66) = 48;
            }
            ++v66;
          }
        }
      }
      v57 = 48;
      goto LABEL_194;
    case 7u:
      goto LABEL_83;
    case 8u:
      goto LABEL_84;
    case 9u:
      v58 = 116;
      goto LABEL_100;
    case 0xAu:
      goto LABEL_86;
    case 0xBu:
      v58 = 118;
      goto LABEL_102;
    case 0xCu:
      goto LABEL_85;
    case 0xDu:
      v58 = 114;
      goto LABEL_100;
    case 0x20u:
      goto LABEL_110;
    case 0x21u:
    case 0x22u:
    case 0x24u:
    case 0x26u:
    case 0x28u:
    case 0x29u:
    case 0x2Au:
    case 0x3Bu:
    case 0x3Cu:
    case 0x3Du:
    case 0x3Eu:
    case 0x5Bu:
    case 0x5Eu:
    case 0x60u:
    case 0x7Cu:
      goto LABEL_111;
    case 0x23u:
    case 0x7Eu:
      goto LABEL_109;
    case 0x25u:
    case 0x2Bu:
    case 0x2Cu:
    case 0x2Du:
    case 0x2Eu:
    case 0x2Fu:
    case 0x30u:
    case 0x31u:
    case 0x32u:
    case 0x33u:
    case 0x34u:
    case 0x35u:
    case 0x36u:
    case 0x37u:
    case 0x38u:
    case 0x39u:
    case 0x3Au:
    case 0x41u:
    case 0x42u:
    case 0x43u:
    case 0x44u:
    case 0x45u:
    case 0x46u:
    case 0x47u:
    case 0x48u:
    case 0x49u:
    case 0x4Au:
    case 0x4Bu:
    case 0x4Cu:
    case 0x4Du:
    case 0x4Eu:
    case 0x4Fu:
    case 0x50u:
    case 0x51u:
    case 0x52u:
    case 0x53u:
    case 0x54u:
    case 0x55u:
    case 0x56u:
    case 0x57u:
    case 0x58u:
    case 0x59u:
    case 0x5Au:
    case 0x5Du:
    case 0x5Fu:
    case 0x61u:
    case 0x62u:
    case 0x63u:
    case 0x64u:
    case 0x65u:
    case 0x66u:
    case 0x67u:
    case 0x68u:
    case 0x69u:
    case 0x6Au:
    case 0x6Bu:
    case 0x6Cu:
    case 0x6Du:
    case 0x6Eu:
    case 0x6Fu:
    case 0x70u:
    case 0x71u:
    case 0x72u:
    case 0x73u:
    case 0x74u:
    case 0x75u:
    case 0x76u:
    case 0x77u:
    case 0x78u:
    case 0x79u:
    case 0x7Au:
      v61 = 1;
      goto LABEL_194;
    case 0x27u:
      goto LABEL_116;
    case 0x3Fu:
      if ( a5 == (char *)2 )
      {
        if ( v53 )
          goto LABEL_256;
      }
      else if ( a5 == (char *)5 )
      {
        if ( a6 & 4 )
        {
          if ( v65 + 2 < a4 )
          {
            v16 = v65 + 1;
            if ( v50[v65 + 1] == 63 )
            {
              v16 = v65 + 2;
              switch ( v50[v65 + 2] )
              {
                case 33:
                case 39:
                case 40:
                case 41:
                case 45:
                case 47:
                case 60:
                case 61:
                case 62:
                  v19 = &loc_805A7FF;
                  if ( !v53 )
                    v19 = &loc_805A804;
                  dword_806B248 = (int)v19;
                  sub_80617ED();
                  goto LABEL_256;
                default:
                  break;
              }
            }
          }
        }
      }
      dword_806B34C = (int)&loc_805AEE4;
      sub_80611C6(v13, v16);
LABEL_83:
      v58 = 97;
      dword_806B248 = (int)&loc_805A99E;
      sub_80617ED();
LABEL_84:
      v58 = 98;
      dword_806B360 = (int)&loc_805A99E;
      sub_8061156();
LABEL_85:
      v58 = 102;
      dword_806B324 = (int)&loc_805A99E;
      sub_80612C5(v13, v16);
LABEL_86:
      v58 = 110;
LABEL_100:
      if ( a5 == (char *)2 && v53 )
        goto LABEL_256;
LABEL_102:
      if ( !v52 )
        goto LABEL_194;
      v57 = v58;
      goto LABEL_202;
    case 0x5Cu:
      v58 = v57;
      if ( a5 == (char *)2 )
      {
        if ( v53 )
        {
          dword_806B2C0 = (int)&loc_805B23E;
          sub_8061526();
        }
        dword_806B2D4 = (int)&loc_805B006;
        sub_80614AE(v44, v45);
      }
      v20 = &loc_805A963;
      if ( !v52 )
        v20 = &loc_805A98D;
      dword_806B324 = (int)v20;
      sub_80612C5(v13, v16);
      if ( !v53 )
        goto LABEL_100;
      v21 = &loc_805A988;
      if ( !n )
        v21 = &loc_805A98D;
      dword_806B310 = (int)v21;
      sub_8061339(v13, v16);
      goto LABEL_216;
    case 0x7Bu:
    case 0x7Du:
      if ( a4 == -1 )
        v22 = v50[1] != 0;
      else
        v22 = a4 != 1;
      if ( v22 )
        goto LABEL_194;
LABEL_109:
      if ( v65 )
        goto LABEL_194;
LABEL_110:
      v61 = 1;
LABEL_111:
      if ( a5 != (char *)2 )
      {
        dword_806B2D4 = (int)&loc_805AEE4;
        sub_80614AE(v44, v45);
LABEL_116:
        v55 = 1;
        v61 = 1;
        v24 = &loc_805AA52;
        if ( a5 != (char *)2 )
          v24 = &loc_805AADD;
        dword_806B234 = (int)v24;
        sub_806185D();
        if ( v53 )
          goto LABEL_256;
        v25 = &loc_805AA7C;
        if ( !a2 )
          v25 = &loc_805AA8F;
        dword_806B2FC = (int)v25;
        sub_80613B1();
        if ( !v67 )
        {
          v67 = a2;
          a2 = 0;
        }
        if ( v66 < a2 )
        {
          v16 = v51;
          *(_BYTE *)(v51 + v66) = 39;
        }
        if ( ++v66 < a2 )
        {
          v16 = v51;
          *(_BYTE *)(v51 + v66) = 92;
        }
        if ( ++v66 < a2 )
        {
          v16 = v51;
          *(_BYTE *)(v51 + v66) = 39;
        }
        ++v66;
        v54 = 0;
LABEL_194:
        v35 = &loc_805AF08;
        if ( v52 != 1 )
          v35 = &loc_805AF0E;
        dword_806B310 = (int)v35;
        sub_8061339(v13, v16);
        if ( a5 == (char *)2 && v53 != 1
          || !v49
          || (v13 = v57 & 0x1F, v16 = *(_DWORD *)(4 * (v57 >> 5) + v49) >> v13, !(v16 & 1)) )
        {
          if ( v59 != 1 )
          {
            dword_806B298 = (int)&loc_805B006;
            sub_8061616();
          }
        }
LABEL_202:
        if ( v53 )
          goto LABEL_256;
        v60 = 1;
        if ( a5 == (char *)2 )
        {
          v36 = &loc_805AFA6;
          if ( v54 == 1 )
            v36 = &loc_805AFEF;
          dword_806B324 = (int)v36;
          sub_80612C5(v13, v16);
          if ( v66 < a2 )
            *(_BYTE *)(v51 + v66) = 39;
          if ( ++v66 < a2 )
            *(_BYTE *)(v51 + v66) = 36;
          if ( ++v66 < a2 )
            *(_BYTE *)(v51 + v66) = 39;
          ++v66;
          v54 = 1;
        }
        if ( v66 < a2 )
          *(_BYTE *)(v51 + v66) = 92;
        ++v66;
LABEL_216:
        if ( v54 && v60 != 1 )
        {
          if ( v66 < a2 )
            *(_BYTE *)(v51 + v66) = 39;
          if ( ++v66 < a2 )
            *(_BYTE *)(v51 + v66) = 39;
          ++v66;
          v54 = 0;
        }
        if ( v66 < a2 )
          *(_BYTE *)(v66 + v51) = v57;
        ++v66;
        v37 = &loc_805B087;
        if ( v61 == 1 )
          v37 = &loc_805B08B;
        dword_806B220 = (int)v37;
        sub_80618EC();
        v56 = 0;
        ++v65;
        goto LABEL_228;
      }
      v23 = &loc_805AA0F;
      if ( !v53 )
        v23 = &loc_805AA14;
      dword_806B2AC = (int)v23;
      sub_806159C(v13, v50);
LABEL_256:
      if ( a5 == (char *)2 && v52 )
        a5 = (char *)4;
      return sub_805A35F(v51, a2, v50, a4, a5, a6 & 0xFFFFFFFD, 0, v48, v47);
    default:
      if ( v63 )
      {
        v70 = 1;
        v26 = __ctype_b_loc();
        v16 = 2 * v57;
        v62 = (*(const unsigned __int16 *)((char *)*v26 + v16) & 0x4000) != 0;
      }
      else
      {
        memset(&ps, 0, 8u);
        v70 = 0;
        v62 = 1;
        if ( a4 == -1 )
          a4 = strlen(v50);
        do
        {
          v46 = a4 - (v70 + v65);
          v45 = &v50[v70 + v65];
          v72 = sub_805F50B((wchar_t *)&wc, v45, v46, &ps);
          if ( !v72 )
          {
            dword_806B270 = (int)&loc_805ACED;
            sub_80616F6(v28, v27);
          }
          v29 = &loc_805ABE0;
          if ( v72 != -1 )
            v29 = &loc_805ABFB;
          dword_806B360 = (int)v29;
          sub_8061156();
          v62 = 0;
          dword_806B34C = (int)&loc_805ACED;
          sub_80611C6(v31, v30);
          if ( v72 == -2 )
          {
            v62 = 0;
            while ( v65 + v70 < a4 && v50[v70 + v65] )
              ++v70;
            dword_806B220 = (int)&loc_805ACED;
            sub_80618EC();
          }
          if ( v53 )
          {
            v32 = &loc_805AC68;
            if ( a5 != (char *)2 )
              v32 = &loc_805ACA6;
            dword_806B374 = (int)v32;
            sub_80610EA();
            v71 = 1;
            while ( v71 < v72 )
            {
              switch ( v50[v71 + v70 + v65] )
              {
                case 91:
                case 92:
                case 94:
                case 96:
                case 124:
                  goto LABEL_256;
                default:
                  ++v71;
                  break;
              }
            }
          }
          v33 = iswprint(wc) == 0;
          v34 = &loc_805ACCE;
          if ( !v33 )
            v34 = &loc_805ACD2;
          dword_806B374 = (int)v34;
          sub_80610EA();
          v62 = 0;
          v70 += v72;
        }
        while ( !mbsinit(&ps) );
      }
      v61 = v62;
      if ( v70 > 1 || v52 && v62 != 1 )
      {
        v73 = v65 + v70;
        if ( v52 && v62 != 1 )
        {
          if ( v53 )
          {
            dword_806B2C0 = (int)&loc_805B23E;
            sub_8061526();
          }
          v60 = 1;
          if ( a5 == (char *)2 && v54 != 1 )
          {
            if ( v66 < a2 )
              *(_BYTE *)(v51 + v66) = 39;
            if ( ++v66 < a2 )
              *(_BYTE *)(v51 + v66) = 36;
            if ( ++v66 < a2 )
              *(_BYTE *)(v51 + v66) = 39;
            ++v66;
            v54 = 1;
          }
          if ( v66 < a2 )
            *(_BYTE *)(v51 + v66) = 92;
          if ( ++v66 < a2 )
            *(_BYTE *)(v66 + v51) = (v57 >> 6) + 48;
          if ( ++v66 < a2 )
            *(_BYTE *)(v66 + v51) = ((v57 >> 3) & 7) + 48;
          ++v66;
          v57 = (v57 & 7) + 48;
        }
        else if ( v59 )
        {
          if ( v66 < a2 )
            *(_BYTE *)(v51 + v66) = 92;
          ++v66;
          v59 = 0;
        }
        if ( v65 + 1 >= v73 )
        {
          dword_806B234 = (int)&loc_805B006;
          sub_806185D();
        }
        if ( v54 && v60 != 1 )
        {
          if ( v66 < a2 )
            *(_BYTE *)(v51 + v66) = 39;
          if ( ++v66 < a2 )
            *(_BYTE *)(v51 + v66) = 39;
          ++v66;
          v54 = 0;
        }
        if ( v66 < a2 )
          *(_BYTE *)(v66 + v51) = v57;
        ++v66;
        v57 = v50[++v65];
        dword_806B2AC = (int)&loc_805AD1E;
        sub_806159C(v13, v50);
      }
      goto LABEL_194;
  }
}
// 80610EA: using guessed type int sub_80610EA(void);
// 8061156: using guessed type int sub_8061156(void);
// 80611C6: using guessed type int __fastcall sub_80611C6(_DWORD, _DWORD);
// 80612C5: using guessed type int __fastcall sub_80612C5(_DWORD, _DWORD);
// 8061339: using guessed type int __fastcall sub_8061339(_DWORD, _DWORD);
// 8061429: using guessed type int __fastcall sub_8061429(_DWORD, _DWORD);
// 8061526: using guessed type int sub_8061526(void);
// 806159C: using guessed type int __fastcall sub_806159C(_DWORD, _DWORD);
// 8061616: using guessed type int sub_8061616(void);
// 8061686: using guessed type int sub_8061686(void);
// 80616F6: using guessed type int __fastcall sub_80616F6(_DWORD, _DWORD);
// 806177B: using guessed type int sub_806177B(void);
// 80617ED: using guessed type int sub_80617ED(void);
// 806185D: using guessed type int sub_806185D(void);
// 80618EC: using guessed type int sub_80618EC(void);
// 806B220: using guessed type int dword_806B220;
// 806B234: using guessed type int dword_806B234;
// 806B248: using guessed type int dword_806B248;
// 806B25C: using guessed type int dword_806B25C;
// 806B270: using guessed type int dword_806B270;
// 806B284: using guessed type int dword_806B284;
// 806B298: using guessed type int dword_806B298;
// 806B2AC: using guessed type int dword_806B2AC;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B2D4: using guessed type int dword_806B2D4;
// 806B2E8: using guessed type int dword_806B2E8;
// 806B2FC: using guessed type int dword_806B2FC;
// 806B310: using guessed type int dword_806B310;
// 806B324: using guessed type int dword_806B324;
// 806B34C: using guessed type int dword_806B34C;
// 806B360: using guessed type int dword_806B360;
// 806B374: using guessed type int dword_806B374;

//----- (0805B368) --------------------------------------------------------
void *__cdecl sub_805B368(char *a1, size_t a2, _DWORD *a3, int *a4)
{
  int *v4; // eax
  int *v5; // ST3C_4
  int v6; // ST40_4
  int v7; // ST44_4
  int size; // [esp+48h] [ebp-10h]
  void *v10; // [esp+4Ch] [ebp-Ch]

  if ( a4 )
    v4 = a4;
  else
    v4 = dword_806C344;
  v5 = v4;
  v6 = *__errno_location();
  v7 = v5[1] | (a3 == 0);
  size = sub_805A35F(0, 0, a1, a2, (char *)*v5, v7, (int)(v5 + 2), (char *)v5[10], (char *)v5[11]) + 1;
  v10 = sub_805E13A(size);
  sub_805A35F((int)v10, size, a1, a2, (char *)*v5, v7, (int)(v5 + 2), (char *)v5[10], (char *)v5[11]);
  *__errno_location() = v6;
  if ( a3 )
    *a3 = size - 1;
  return v10;
}
// 806C344: using guessed type int dword_806C344[];

//----- (0805B541) --------------------------------------------------------
void *__cdecl sub_805B541(signed int a1, char *a2, size_t a3, int a4)
{
  int v4; // ecx
  void *v5; // eax
  size_t v6; // edx
  _DWORD *v7; // ecx
  void *v8; // edx
  char *v9; // edx
  char *v10; // eax
  char *v11; // ebx
  char *v13; // [esp+20h] [ebp-38h]
  bool v14; // [esp+37h] [ebp-21h]
  void *v15; // [esp+38h] [ebp-20h]
  void *ptr; // [esp+3Ch] [ebp-1Ch]
  int v17; // [esp+40h] [ebp-18h]
  size_t size; // [esp+44h] [ebp-14h]
  int v19; // [esp+48h] [ebp-10h]
  unsigned int v20; // [esp+4Ch] [ebp-Ch]

  v17 = *__errno_location();
  v15 = off_806B474;
  if ( a1 < 0 )
    abort();
  if ( dword_806B468 <= a1 )
  {
    v14 = v15 == &dword_806B46C;
    if ( (unsigned int)a1 > 0xFFFFFFE )
      sub_805E2B6();
    v5 = &loc_805B5BB;
    if ( !v14 )
      v5 = &loc_805B5D7;
    dword_806B34C = (int)v5;
    sub_80611C6(v4, 8 * (a1 + 1));
    dword_806B220 = (int)&loc_805B5DA;
    sub_80618EC();
    v15 = sub_805E177(v15, v6);
    off_806B474 = (int *)v15;
    if ( v14 )
    {
      v7 = v15;
      v8 = off_806B470;
      *(_DWORD *)v15 = dword_806B46C;
      v7[1] = v8;
    }
    memset((char *)v15 + 8 * dword_806B468, 0, 8 * (a1 + 1 - dword_806B468));
    dword_806B468 = a1 + 1;
  }
  size = *((_DWORD *)v15 + 2 * a1);
  ptr = (void *)*((_DWORD *)v15 + 2 * a1 + 1);
  v19 = *(_DWORD *)(a4 + 4) | 1;
  v9 = *(char **)(a4 + 40);
  v10 = *(char **)a4;
  v13 = *(char **)(a4 + 44);
  v20 = sub_805A35F((int)ptr, size, a2, a3, v10, v19, a4 + 8, v9, v13);
  if ( size <= v20 )
  {
    size = v20 + 1;
    *((_DWORD *)v15 + 2 * a1) = v20 + 1;
    if ( ptr != &unk_806C384 )
      free(ptr);
    v11 = (char *)v15 + 8 * a1;
    ptr = sub_805E13A(size);
    *((_DWORD *)v11 + 1) = ptr;
    sub_805A35F((int)ptr, size, a2, a3, *(char **)a4, v19, a4 + 8, *(char **)(a4 + 40), *(char **)(a4 + 44));
  }
  *__errno_location() = v17;
  return ptr;
}
// 80611C6: using guessed type int __fastcall sub_80611C6(_DWORD, _DWORD);
// 80618EC: using guessed type int sub_80618EC(void);
// 806B220: using guessed type int dword_806B220;
// 806B34C: using guessed type int dword_806B34C;
// 806B468: using guessed type int dword_806B468;
// 806B46C: using guessed type int dword_806B46C;
// 806B470: using guessed type void *off_806B470;
// 806B474: using guessed type int *off_806B474;

//----- (0805B798) --------------------------------------------------------
void *__cdecl sub_805B798(signed int a1, char *a2)
{
  return sub_805B541(a1, a2, 0xFFFFFFFF, (int)dword_806C344);
}
// 806C344: using guessed type int dword_806C344[];

//----- (0805B7C2) --------------------------------------------------------
void *__cdecl sub_805B7C2(signed int a1, char *a2, size_t a3)
{
  return sub_805B541(a1, a2, a3, (int)dword_806C344);
}
// 806C344: using guessed type int dword_806C344[];

//----- (0805B828) --------------------------------------------------------
void __cdecl __noreturn sub_805B828(int a1, int a2)
{
  char v2; // [esp+10h] [ebp-38h]

  sub_805A1B5((int)&v2, a2);
}

//----- (0805B866) --------------------------------------------------------
void __cdecl __noreturn sub_805B866(int a1, int a2)
{
  char v2; // [esp+10h] [ebp-38h]

  sub_805A1B5((int)&v2, a2);
}

//----- (0805B8A3) --------------------------------------------------------
void __cdecl __noreturn sub_805B8A3(int a1)
{
  sub_805B828(0, a1);
}

//----- (0805B8EE) --------------------------------------------------------
void *__cdecl sub_805B8EE(char *a1, size_t a2, unsigned __int8 a3)
{
  int v4; // [esp+20h] [ebp-38h]
  int v5; // [esp+24h] [ebp-34h]
  int v6; // [esp+28h] [ebp-30h]
  int v7; // [esp+2Ch] [ebp-2Ch]
  int v8; // [esp+30h] [ebp-28h]
  int v9; // [esp+34h] [ebp-24h]
  int v10; // [esp+38h] [ebp-20h]
  int v11; // [esp+3Ch] [ebp-1Ch]
  int v12; // [esp+40h] [ebp-18h]
  int v13; // [esp+44h] [ebp-14h]
  int v14; // [esp+48h] [ebp-10h]
  int v15; // [esp+4Ch] [ebp-Ch]

  v4 = dword_806C344[0];
  v5 = dword_806C348;
  v6 = dword_806C34C;
  v7 = dword_806C350;
  v8 = dword_806C354;
  v9 = dword_806C358;
  v10 = dword_806C35C;
  v11 = dword_806C360;
  v12 = dword_806C364;
  v13 = dword_806C368;
  v14 = dword_806C36C;
  v15 = dword_806C370;
  sub_805A09C((int)&v4, a3, 1);
  return sub_805B541(0, a1, a2, (int)&v4);
}
// 806C344: using guessed type int dword_806C344[];
// 806C348: using guessed type int dword_806C348;
// 806C34C: using guessed type int dword_806C34C;
// 806C350: using guessed type int dword_806C350;
// 806C354: using guessed type int dword_806C354;
// 806C358: using guessed type int dword_806C358;
// 806C35C: using guessed type int dword_806C35C;
// 806C360: using guessed type int dword_806C360;
// 806C364: using guessed type int dword_806C364;
// 806C368: using guessed type int dword_806C368;
// 806C36C: using guessed type int dword_806C36C;
// 806C370: using guessed type int dword_806C370;

//----- (0805B998) --------------------------------------------------------
void *__cdecl sub_805B998(char *a1, unsigned __int8 a2)
{
  return sub_805B8EE(a1, 0xFFFFFFFF, a2);
}

//----- (0805B9C1) --------------------------------------------------------
void *__cdecl sub_805B9C1(char *a1)
{
  return sub_805B998(a1, 0x3Au);
}

//----- (0805B9FE) --------------------------------------------------------
void __cdecl __noreturn sub_805B9FE(int a1, int a2)
{
  char v2; // [esp+10h] [ebp-68h]

  sub_805A1B5((int)&v2, a2);
}

//----- (0805BA9F) --------------------------------------------------------
void *__usercall sub_805BA9F@<eax>(int a1@<edx>, int a2@<ecx>, signed int a3, int a4, int a5, char *a6)
{
  return sub_805BACF(a1, a2, a3, a4, a5, a6, 0xFFFFFFFF);
}

//----- (0805BACF) --------------------------------------------------------
void *__usercall sub_805BACF@<eax>(int a1@<edx>, int a2@<ecx>, signed int a3, int a4, int a5, char *a6, size_t a7)
{
  int v8; // [esp+10h] [ebp-38h]
  int v9; // [esp+14h] [ebp-34h]
  int v10; // [esp+18h] [ebp-30h]
  int v11; // [esp+1Ch] [ebp-2Ch]
  int v12; // [esp+20h] [ebp-28h]
  int v13; // [esp+24h] [ebp-24h]
  int v14; // [esp+28h] [ebp-20h]
  int v15; // [esp+2Ch] [ebp-1Ch]
  int v16; // [esp+30h] [ebp-18h]
  int v17; // [esp+34h] [ebp-14h]
  int v18; // [esp+38h] [ebp-10h]
  int v19; // [esp+3Ch] [ebp-Ch]

  v8 = dword_806C344[0];
  v9 = dword_806C348;
  v10 = dword_806C34C;
  v11 = dword_806C350;
  v12 = dword_806C354;
  v13 = dword_806C358;
  v14 = dword_806C35C;
  v15 = dword_806C360;
  v16 = dword_806C364;
  v17 = dword_806C368;
  v18 = dword_806C36C;
  v19 = dword_806C370;
  sub_805A15B(a1, a2, (int)&v8, a4, a5);
  return sub_805B541(a3, a6, a7, (int)&v8);
}
// 806C344: using guessed type int dword_806C344[];
// 806C348: using guessed type int dword_806C348;
// 806C34C: using guessed type int dword_806C34C;
// 806C350: using guessed type int dword_806C350;
// 806C354: using guessed type int dword_806C354;
// 806C358: using guessed type int dword_806C358;
// 806C35C: using guessed type int dword_806C35C;
// 806C360: using guessed type int dword_806C360;
// 806C364: using guessed type int dword_806C364;
// 806C368: using guessed type int dword_806C368;
// 806C36C: using guessed type int dword_806C36C;
// 806C370: using guessed type int dword_806C370;

//----- (0805BBC9) --------------------------------------------------------
void *__cdecl sub_805BBC9(signed int a1, char *a2, size_t a3)
{
  return sub_805B541(a1, a2, a3, (int)&unk_806B488);
}

//----- (0805BC14) --------------------------------------------------------
void *__cdecl sub_805BC14(signed int a1, char *a2)
{
  return sub_805BBC9(a1, a2, 0xFFFFFFFF);
}

//----- (0805BC36) --------------------------------------------------------
void *__cdecl sub_805BC36(char *a1)
{
  return sub_805BC14(0, a1);
}

//----- (0805BC51) --------------------------------------------------------
void __cdecl __noreturn sub_805BC51(char *a1)
{
  void *v1; // esi
  char *v2; // ebx
  int *v3; // eax

  if ( a1 )
  {
    v1 = sub_805BC36(a1);
    if ( *__errno_location() )
      v2 = gettext("%s: read error");
    else
      v2 = gettext("%s: end of file");
    v3 = __errno_location();
    error(status, *v3, v2, v1);
  }
  abort();
}

//----- (0805BCBA) --------------------------------------------------------
_DWORD *__cdecl sub_805BCBA(int a1, int a2)
{
  _DWORD *result; // eax

  result = sub_805E14D(0x81Cu);
  *result = a1;
  result[1] = sub_805BC51;
  result[2] = a2;
  return result;
}

//----- (0805BCEF) --------------------------------------------------------
unsigned int __cdecl sub_805BCEF(int a1, int a2, size_t nbytes)
{
  size_t v3; // eax
  int v4; // eax
  size_t n; // ST24_4
  int v6; // eax
  size_t v7; // ST28_4
  int v8; // eax
  size_t v9; // ST2C_4
  int v10; // eax
  size_t v11; // ST30_4
  unsigned int result; // eax
  int v13; // eax
  size_t v14; // ST34_4
  unsigned int v15; // [esp+18h] [ebp-30h]
  int fd; // [esp+20h] [ebp-28h]
  struct timeval tv; // [esp+38h] [ebp-10h]

  v15 = 0;
  fd = open64("/dev/urandom", 0);
  if ( fd >= 0 )
  {
    v3 = a2;
    if ( nbytes <= a2 )
      v3 = nbytes;
    v15 = read(fd, (void *)a1, v3);
    if ( (v15 & 0x80000000) != 0 )
      v15 = 0;
    close(fd);
  }
  if ( v15 < a2 )
  {
    v4 = a2 - v15;
    if ( a2 - v15 > 8 )
      v4 = 8;
    n = v4;
    gettimeofday(&tv, 0);
    memcpy((void *)(a1 + v15), &tv, n);
    v15 += n;
  }
  if ( v15 < a2 )
  {
    v6 = a2 - v15;
    if ( a2 - v15 > 4 )
      v6 = 4;
    v7 = v6;
    tv.tv_sec = getpid();
    memcpy((void *)(a1 + v15), &tv, v7);
    v15 += v7;
  }
  if ( v15 < a2 )
  {
    v8 = a2 - v15;
    if ( a2 - v15 > 4 )
      v8 = 4;
    v9 = v8;
    tv.tv_sec = getppid();
    memcpy((void *)(a1 + v15), &tv, v9);
    v15 += v9;
  }
  if ( v15 < a2 )
  {
    v10 = a2 - v15;
    if ( a2 - v15 > 4 )
      v10 = 4;
    v11 = v10;
    tv.tv_sec = getuid();
    memcpy((void *)(a1 + v15), &tv, v11);
    v15 += v11;
  }
  result = v15;
  if ( v15 < a2 )
  {
    v13 = a2 - v15;
    if ( a2 - v15 > 4 )
      v13 = 4;
    v14 = v13;
    tv.tv_sec = getgid();
    memcpy((void *)(a1 + v15), &tv, v14);
    result = v15 + v14;
  }
  return result;
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);

//----- (0805BEFC) --------------------------------------------------------
char *__cdecl sub_805BEFC(int a1, size_t n)
{
  size_t v3; // eax
  int v4; // edx
  int v5; // ecx
  FILE *stream; // [esp+18h] [ebp-10h]
  char *v7; // [esp+1Ch] [ebp-Ch]

  if ( !n )
    return (char *)sub_805BCBA(0, 0);
  stream = 0;
  if ( a1 )
  {
    stream = sub_806025C(a1, "rb");
    if ( !stream )
      return 0;
  }
  v7 = (char *)sub_805BCBA((int)stream, a1);
  if ( stream )
  {
    v3 = 2048;
    if ( n <= 0x800 )
      v3 = n;
    setvbuf(stream, v7 + 12, 0, v3);
  }
  else
  {
    *((_DWORD *)v7 + 3) = 0;
    sub_805BCEF((int)(v7 + 16), 1024, n);
    sub_805C737(v4, v5, (_DWORD *)v7 + 4);
  }
  return v7;
}

//----- (0805BFF8) --------------------------------------------------------
void __cdecl __noreturn sub_805BFF8(int a1, void *ptr, size_t n)
{
  int *v3; // ebx
  int v4; // eax
  FILE *v5; // [esp+0h] [ebp-28h]
  FILE *v6; // [esp+Ch] [ebp-1Ch]
  size_t v7; // [esp+18h] [ebp-10h]
  int v8; // [esp+1Ch] [ebp-Ch]

  while ( 1 )
  {
    v6 = *(FILE **)a1;
    v7 = fread_unlocked(ptr, 1u, n, v6);
    v8 = *__errno_location();
    ptr = (char *)ptr + v7;
    n -= v7;
    if ( !n )
    {
      dword_806B284 = (int)sub_805C092;
      sub_8061686();
    }
    v3 = __errno_location();
    v5 = *(FILE **)a1;
    if ( ferror_unlocked(v5) )
      v4 = v8;
    else
      v4 = 0;
    *v3 = v4;
    (*(void (__cdecl **)(_DWORD))(a1 + 4))(*(_DWORD *)(a1 + 8));
  }
}
// 805C092: using guessed type int sub_805C092();
// 8061686: using guessed type int sub_8061686(void);
// 806B284: using guessed type int dword_806B284;

//----- (0805C092) --------------------------------------------------------
#error "805C095: positive sp value has been found (funcsize=0)"

//----- (0805C098) --------------------------------------------------------
int __cdecl sub_805C098(int a1, void *dest, size_t n)
{
  int result; // eax
  size_t i; // [esp+14h] [ebp-14h]
  int *v5; // [esp+18h] [ebp-10h]
  char v6; // [esp+1Ch] [ebp-Ch]

  for ( i = *(_DWORD *)a1; ; i = 1024 )
  {
    v6 = (char)dest;
    if ( n <= i )
      break;
    memcpy(dest, (const void *)(a1 + 1024 - i + 1040), i);
    dest = (char *)dest + i;
    n -= i;
    if ( !((v6 + (_BYTE)i) & 3) )
    {
      v5 = (int *)dest;
      while ( n > 0x3FF )
      {
        sub_805C292((unsigned int *)(a1 + 4), v5);
        v5 += 256;
        n -= 1024;
        if ( !n )
        {
          result = a1;
          *(_DWORD *)a1 = 0;
          return result;
        }
      }
      dest = v5;
    }
    sub_805C292((unsigned int *)(a1 + 4), (int *)(a1 + 1040));
  }
  memcpy(dest, (const void *)(a1 + 1024 - i + 1040), n);
  result = a1;
  *(_DWORD *)a1 = i - n;
  return result;
}

//----- (0805C1A7) --------------------------------------------------------
int __cdecl sub_805C1A7(int a1, void *ptr, size_t n)
{
  if ( *(_DWORD *)a1 )
    sub_805BFF8(a1, ptr, n);
  return sub_805C098(a1 + 12, ptr, n);
}

//----- (0805C204) --------------------------------------------------------
int __cdecl sub_805C204(void *ptr)
{
  int result; // eax
  FILE *stream; // [esp+1Ch] [ebp-Ch]

  stream = *(FILE **)ptr;
  explicit_bzero(ptr, 2076);
  free(ptr);
  if ( stream )
    result = sub_805F101(stream);
  else
    result = 0;
  return result;
}
// 8049DE0: using guessed type int __cdecl explicit_bzero(_DWORD, _DWORD);

//----- (0805C24A) --------------------------------------------------------
int __cdecl sub_805C24A(int a1)
{
  return a1;
}

//----- (0805C261) --------------------------------------------------------
int __cdecl sub_805C261(int a1, __int16 a2)
{
  return *(_DWORD *)((a2 & 0x3FC) + a1);
}

//----- (0805C292) --------------------------------------------------------
unsigned int *__cdecl sub_805C292(unsigned int *a1, int *a2)
{
  unsigned int v2; // edx
  int v3; // ST08_4
  unsigned int v4; // ST18_4
  unsigned int v5; // ST1C_4
  int v6; // eax
  int v7; // ST0C_4
  unsigned int v8; // ST08_4
  unsigned int v9; // ST20_4
  int v10; // eax
  int v11; // eax
  int v12; // ST0C_4
  int v13; // ST08_4
  unsigned int v14; // ST28_4
  int v15; // eax
  int v16; // eax
  int v17; // ST0C_4
  unsigned int v18; // ST30_4
  int v19; // eax
  int v20; // eax
  int v21; // ST08_4
  unsigned int v22; // ST38_4
  unsigned int v23; // ST3C_4
  int v24; // eax
  int v25; // ST0C_4
  unsigned int v26; // ST08_4
  unsigned int v27; // ST40_4
  int v28; // eax
  int v29; // eax
  int v30; // ST0C_4
  int v31; // ST08_4
  unsigned int v32; // ST48_4
  int v33; // eax
  int v34; // eax
  int v35; // ST0C_4
  unsigned int v36; // ST50_4
  int v37; // eax
  int v38; // eax
  unsigned int *result; // eax
  unsigned int v40; // [esp+8h] [ebp-54h]
  int v41; // [esp+Ch] [ebp-50h]
  unsigned int *v42; // [esp+10h] [ebp-4Ch]
  int *v43; // [esp+14h] [ebp-48h]

  v40 = a1[256];
  v2 = a1[257];
  v41 = v2 + ++a1[258];
  v42 = a1;
  v43 = a2;
  do
  {
    v3 = (v40 ^ (v40 << 13)) + v42[128];
    v4 = *v42;
    v5 = sub_805C261((int)a1, *v42) + v3 + v41;
    *v42 = v5;
    v6 = sub_805C261((int)a1, v5 >> 8);
    v7 = sub_805C24A(v4 + v6);
    *v43 = v7;
    v8 = (v3 ^ ((unsigned int)sub_805C24A(v3) >> 6)) + v42[129];
    v9 = v42[1];
    v10 = sub_805C261((int)a1, v42[1]);
    v42[1] = v10 + v8 + v7;
    v11 = sub_805C261((int)a1, (v10 + v8 + v7) >> 8);
    v12 = sub_805C24A(v9 + v11);
    v43[1] = v12;
    v13 = (v8 ^ 4 * v8) + v42[130];
    v14 = v42[2];
    v15 = sub_805C261((int)a1, v42[2]);
    v42[2] = v15 + v13 + v12;
    v16 = sub_805C261((int)a1, (unsigned int)(v15 + v13 + v12) >> 8);
    v17 = sub_805C24A(v14 + v16);
    v43[2] = v17;
    v40 = (v13 ^ ((unsigned int)sub_805C24A(v13) >> 16)) + v42[131];
    v18 = v42[3];
    v19 = sub_805C261((int)a1, v42[3]);
    v42[3] = v19 + v40 + v17;
    v20 = sub_805C261((int)a1, (v19 + v40 + v17) >> 8);
    v41 = sub_805C24A(v18 + v20);
    v43[3] = v41;
    v43 += 4;
    v42 += 4;
  }
  while ( v42 < a1 + 128 );
  do
  {
    v21 = (v40 ^ (v40 << 13)) + *(v42 - 128);
    v22 = *v42;
    v23 = sub_805C261((int)a1, *v42) + v21 + v41;
    *v42 = v23;
    v24 = sub_805C261((int)a1, v23 >> 8);
    v25 = sub_805C24A(v22 + v24);
    *v43 = v25;
    v26 = (v21 ^ ((unsigned int)sub_805C24A(v21) >> 6)) + *(v42 - 127);
    v27 = v42[1];
    v28 = sub_805C261((int)a1, v42[1]);
    v42[1] = v28 + v26 + v25;
    v29 = sub_805C261((int)a1, (v28 + v26 + v25) >> 8);
    v30 = sub_805C24A(v27 + v29);
    v43[1] = v30;
    v31 = (v26 ^ 4 * v26) + *(v42 - 126);
    v32 = v42[2];
    v33 = sub_805C261((int)a1, v42[2]);
    v42[2] = v33 + v31 + v30;
    v34 = sub_805C261((int)a1, (unsigned int)(v33 + v31 + v30) >> 8);
    v35 = sub_805C24A(v32 + v34);
    v43[2] = v35;
    v40 = (v31 ^ ((unsigned int)sub_805C24A(v31) >> 16)) + *(v42 - 125);
    v36 = v42[3];
    v37 = sub_805C261((int)a1, v42[3]);
    v42[3] = v37 + v40 + v35;
    v38 = sub_805C261((int)a1, (v37 + v40 + v35) >> 8);
    v41 = sub_805C24A(v36 + v38);
    v43[3] = v41;
    v43 += 4;
    v42 += 4;
  }
  while ( v42 < a1 + 256 );
  a1[256] = v40;
  result = a1;
  a1[257] = v41;
  return result;
}

//----- (0805C737) --------------------------------------------------------
_DWORD *__usercall sub_805C737@<eax>(int edx0@<edx>, int a2@<ecx>, _DWORD *a1)
{
  int v3; // ST10_4
  int v4; // ST14_4
  int v5; // ST1C_4
  int v6; // ST20_4
  int v7; // ST24_4
  int v8; // ST28_4
  int v9; // ST0C_4
  int v10; // ST18_4
  unsigned int v11; // ST10_4
  int v12; // ST1C_4
  int v13; // ST14_4
  int v14; // ST20_4
  int v15; // ST24_4
  int v16; // ST28_4
  int v17; // ST0C_4
  int v18; // ST10_4
  int v19; // ST14_4
  int v20; // ST1C_4
  int v21; // ST20_4
  int v22; // ST24_4
  int v23; // ST28_4
  int v24; // ST0C_4
  int v25; // ST18_4
  unsigned int v26; // ST10_4
  int v27; // ST1C_4
  int v28; // ST14_4
  int v29; // ST20_4
  int v30; // ST24_4
  int v31; // ST28_4
  int v32; // ST0C_4
  _DWORD *result; // eax
  int v34; // [esp+Ch] [ebp-28h]
  int v35; // [esp+10h] [ebp-24h]
  int v36; // [esp+14h] [ebp-20h]
  unsigned int v37; // [esp+18h] [ebp-1Ch]
  int v38; // [esp+1Ch] [ebp-18h]
  unsigned int v39; // [esp+20h] [ebp-14h]
  int v40; // [esp+24h] [ebp-10h]
  unsigned int v41; // [esp+28h] [ebp-Ch]
  signed int v42; // [esp+2Ch] [ebp-8h]
  signed int i; // [esp+30h] [ebp-4h]

  v34 = 325574490;
  v35 = -1780940711;
  v36 = -1021952437;
  v37 = 255990488;
  v38 = -651539848;
  v39 = -1525007287;
  v40 = -990909925;
  v41 = 811634969;
  v42 = 0;
  dword_806B2E8 = (int)&loc_805C949;
  sub_8061429(a2, edx0);
  do
  {
    v3 = a1[v42 + 1] + v35;
    v4 = a1[v42 + 2] + v36;
    v5 = a1[v42 + 4] + v38;
    v6 = a1[v42 + 5] + v39;
    v7 = a1[v42 + 6] + v40;
    v8 = a1[v42 + 7] + v41;
    v9 = (v3 << 11) ^ (a1[v42] + v34);
    v10 = v9 + a1[v42 + 3] + v37;
    v11 = ((unsigned int)sub_805C24A(v4) >> 2) ^ (v4 + v3);
    v12 = v11 + v5;
    v13 = (v10 << 8) ^ (v10 + v4);
    v14 = v13 + v6;
    v37 = ((unsigned int)sub_805C24A(v12) >> 16) ^ (v12 + v10);
    v15 = v37 + v7;
    v38 = (v14 << 10) ^ (v14 + v12);
    v16 = v38 + v8;
    v39 = ((unsigned int)sub_805C24A(v15) >> 4) ^ (v15 + v14);
    v17 = v39 + v9;
    v40 = (v16 << 8) ^ (v16 + v15);
    v35 = v40 + v11;
    v41 = ((unsigned int)sub_805C24A(v17) >> 9) ^ (v17 + v16);
    v36 = v41 + v13;
    v34 = v35 + v17;
    a1[v42] = v34;
    a1[v42 + 1] = v35;
    a1[v42 + 2] = v36;
    a1[v42 + 3] = v37;
    a1[v42 + 4] = v38;
    a1[v42 + 5] = v39;
    a1[v42 + 6] = v40;
    a1[v42 + 7] = v41;
    v42 += 8;
  }
  while ( v42 <= 255 );
  for ( i = 0; i <= 255; i += 8 )
  {
    v18 = a1[i + 1] + v35;
    v19 = a1[i + 2] + v36;
    v20 = a1[i + 4] + v38;
    v21 = a1[i + 5] + v39;
    v22 = a1[i + 6] + v40;
    v23 = a1[i + 7] + v41;
    v24 = (v18 << 11) ^ (a1[i] + v34);
    v25 = v24 + a1[i + 3] + v37;
    v26 = ((unsigned int)sub_805C24A(v19) >> 2) ^ (v19 + v18);
    v27 = v26 + v20;
    v28 = (v25 << 8) ^ (v25 + v19);
    v29 = v28 + v21;
    v37 = ((unsigned int)sub_805C24A(v27) >> 16) ^ (v27 + v25);
    v30 = v37 + v22;
    v38 = (v29 << 10) ^ (v29 + v27);
    v31 = v38 + v23;
    v39 = ((unsigned int)sub_805C24A(v30) >> 4) ^ (v30 + v29);
    v32 = v39 + v24;
    v40 = (v31 << 8) ^ (v31 + v30);
    v35 = v40 + v26;
    v41 = ((unsigned int)sub_805C24A(v32) >> 9) ^ (v32 + v31);
    v36 = v41 + v28;
    v34 = v35 + v32;
    a1[i] = v34;
    a1[i + 1] = v35;
    a1[i + 2] = v36;
    a1[i + 3] = v37;
    a1[i + 4] = v38;
    a1[i + 5] = v39;
    a1[i + 6] = v40;
    a1[i + 7] = v41;
  }
  a1[258] = 0;
  a1[257] = a1[258];
  result = a1;
  a1[256] = a1[257];
  return result;
}
// 8061429: using guessed type int __fastcall sub_8061429(_DWORD, _DWORD);
// 806B2E8: using guessed type int dword_806B2E8;

//----- (0805CB58) --------------------------------------------------------
signed int __cdecl sub_805CB58(_DWORD *a1)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_805F73C((int)(a1 + 3), 0, 0, (int)malloc, (int)free);
  sub_805F73C((int)(a1 + 14), 0, 0, (int)malloc, (int)free);
  return sub_805F73C((int)(a1 + 25), 0, 0, (int)malloc, (int)free);
}

//----- (0805CD11) --------------------------------------------------------
_DWORD *__cdecl sub_805CD11(_DWORD *a1)
{
  _DWORD *result; // eax
  int src; // [esp+10h] [ebp-38h]
  _DWORD *v3; // [esp+14h] [ebp-34h]
  _DWORD *v4; // [esp+18h] [ebp-30h]
  int v5; // [esp+1Ch] [ebp-2Ch]
  int v6; // [esp+20h] [ebp-28h]
  _DWORD *v7; // [esp+24h] [ebp-24h]
  _DWORD *v8; // [esp+28h] [ebp-20h]
  _DWORD *v9; // [esp+2Ch] [ebp-1Ch]
  _DWORD *v10; // [esp+30h] [ebp-18h]
  _DWORD *v11; // [esp+34h] [ebp-14h]
  size_t n; // [esp+38h] [ebp-10h]
  _DWORD *v13; // [esp+3Ch] [ebp-Ch]

  v3 = a1 + 3;
  src = a1[6] - a1[5] - 1;
  v4 = a1 + 3;
  v5 = a1[5];
  if ( a1[6] == v5 )
    *((_BYTE *)v4 + 40) |= 2u;
  v4[3] = (v4[6] + v4[3]) & ~v4[6];
  if ( v4[3] - v4[1] > (unsigned int)(v4[4] - v4[1]) )
    v4[3] = v4[4];
  v4[2] = v4[3];
  v6 = v5;
  v7 = a1 + 14;
  v8 = a1 + 14;
  if ( (unsigned int)(a1[18] - a1[17]) <= 3 )
    sub_805F7C5((int)v7, 4);
  v9 = v7;
  v10 = (_DWORD *)v7[3];
  *v10 = v6;
  v9[3] += 4;
  v11 = a1 + 25;
  n = 4;
  v13 = a1 + 25;
  if ( (unsigned int)(a1[29] - a1[28]) < 4 )
    sub_805F7C5((int)v11, n);
  memcpy((void *)v11[3], &src, n);
  v11[3] += n;
  result = a1;
  ++*a1;
  return result;
}

//----- (0805CEA6) --------------------------------------------------------
bool __cdecl sub_805CEA6(FILE *stream, int a2)
{
  _BYTE *v2; // eax
  _BYTE *v3; // eax
  void *v4; // eax
  int v6; // [esp+14h] [ebp-44h]
  int v7; // [esp+3Ch] [ebp-1Ch]
  int v8; // [esp+44h] [ebp-14h]

  while ( 1 )
  {
    v6 = fgetc(stream);
    if ( v6 == -1 )
      break;
    if ( *(_DWORD *)(a2 + 28) == *(_DWORD *)(a2 + 24) )
      sub_805F7C5(a2 + 12, 1);
    v3 = *(_BYTE **)(a2 + 24);
    *(_DWORD *)(a2 + 24) = v3 + 1;
    *v3 = v6;
    v4 = &loc_805CFB2;
    if ( v6 )
      v4 = &loc_805CFC2;
    dword_806B360 = (int)v4;
    sub_8061156();
    sub_805CD11((_DWORD *)a2);
  }
  if ( *(_DWORD *)(a2 + 24) != *(_DWORD *)(a2 + 20) )
  {
    if ( *(_DWORD *)(a2 + 28) == *(_DWORD *)(a2 + 24) )
      sub_805F7C5(a2 + 12, 1);
    v2 = *(_BYTE **)(a2 + 24);
    *(_DWORD *)(a2 + 24) = v2 + 1;
    *v2 = 0;
    sub_805CD11((_DWORD *)a2);
  }
  if ( (unsigned int)(*(_DWORD *)(a2 + 72) - *(_DWORD *)(a2 + 68)) <= 3 )
    sub_805F7C5(a2 + 56, 4);
  **(_DWORD **)(a2 + 68) = 0;
  *(_DWORD *)(a2 + 68) += 4;
  v7 = *(_DWORD *)(a2 + 64);
  if ( *(_DWORD *)(a2 + 68) == v7 )
    *(_BYTE *)(a2 + 96) |= 2u;
  *(_DWORD *)(a2 + 68) = (*(_DWORD *)(a2 + 80) + *(_DWORD *)(a2 + 68)) & ~*(_DWORD *)(a2 + 80);
  if ( *(_DWORD *)(a2 + 68) - *(_DWORD *)(a2 + 60) > (unsigned int)(*(_DWORD *)(a2 + 72) - *(_DWORD *)(a2 + 60)) )
    *(_DWORD *)(a2 + 68) = *(_DWORD *)(a2 + 72);
  *(_DWORD *)(a2 + 64) = *(_DWORD *)(a2 + 68);
  *(_DWORD *)(a2 + 4) = v7;
  v8 = *(_DWORD *)(a2 + 108);
  if ( *(_DWORD *)(a2 + 112) == v8 )
    *(_BYTE *)(a2 + 140) |= 2u;
  *(_DWORD *)(a2 + 112) = (*(_DWORD *)(a2 + 124) + *(_DWORD *)(a2 + 112)) & ~*(_DWORD *)(a2 + 124);
  if ( *(_DWORD *)(a2 + 112) - *(_DWORD *)(a2 + 104) > (unsigned int)(*(_DWORD *)(a2 + 116) - *(_DWORD *)(a2 + 104)) )
    *(_DWORD *)(a2 + 112) = *(_DWORD *)(a2 + 116);
  *(_DWORD *)(a2 + 108) = *(_DWORD *)(a2 + 112);
  *(_DWORD *)(a2 + 8) = v8;
  return ferror(stream) == 0;
}
// 8061156: using guessed type int sub_8061156(void);
// 806B360: using guessed type int dword_806B360;

//----- (0805D182) --------------------------------------------------------
int __cdecl sub_805D182(int a1, int a2)
{
  int v2; // eax

  v2 = mkostemp64(a1, a2);
  return sub_80601D4(v2, a2);
}
// 8049A10: using guessed type int __cdecl mkostemp64(_DWORD, _DWORD);

//----- (0805D1AB) --------------------------------------------------------
int __cdecl sub_805D1AB(_BYTE *a1, _BYTE *a2, char a3)
{
  int v3; // ecx
  void *v4; // eax
  void *v5; // eax
  _BYTE *v7; // eax
  _BYTE *v8; // edx
  bool v9; // zf
  void *v10; // eax
  char v11; // [esp+0h] [ebp-4h]
  int savedregs; // [esp+4h] [ebp+0h]
  _BYTE *v13; // [esp+Ch] [ebp+8h]
  _BYTE *v14; // [esp+10h] [ebp+Ch]

  v11 = a3;
  if ( *a1 == a3 )
  {
    v4 = &loc_805D1EA;
    if ( *a2 != v11 )
      v4 = &loc_805D2CF;
    dword_806B248 = (int)v4;
    sub_80617ED();
    ++a1;
    v14 = a2 + 1;
    v5 = &loc_805D238;
    if ( *a1 == *v14 )
      v5 = &loc_805D1EC;
    dword_806B360 = (int)v5;
    sub_8061156();
    if ( (unsigned int)((char)*a1 - 48) <= 9 && (unsigned int)((char)*v14 - 48) <= 9 )
      return (char)*a1 - (char)*v14;
    if ( (unsigned int)((char)*a1 - 48) <= 9 )
    {
      dword_806B248 = (int)&loc_805D2F9;
      sub_80617ED();
    }
    if ( (unsigned int)((char)*v14 - 48) <= 9 )
    {
      while ( *v14 == 48 )
        ++v14;
      return -((unsigned int)((char)*v14 - 48) <= 9);
    }
    dword_806B2C0 = (int)&locret_805D374;
    sub_8061526();
  }
  v7 = a1;
  v8 = a1 + 1;
  v13 = a1 + 1;
  v9 = *v7 == v11;
  v10 = &loc_805D2F9;
  if ( !v9 )
    v10 = &loc_805D335;
  dword_806B2AC = (int)v10;
  sub_806159C(v3, v8);
  dword_806B2D4 = (int)&loc_805D314;
  sub_80614AE(*(_DWORD *)&v11, savedregs);
  do
    ++v13;
  while ( *v13 == 48 );
  return (unsigned int)((char)*v13 - 48) <= 9;
}
// 805D1AB: could not find valid save-restore pair for ebx
// 8061156: using guessed type int sub_8061156(void);
// 8061526: using guessed type int sub_8061526(void);
// 806159C: using guessed type int __fastcall sub_806159C(_DWORD, _DWORD);
// 80617ED: using guessed type int sub_80617ED(void);
// 806B248: using guessed type int dword_806B248;
// 806B2AC: using guessed type int dword_806B2AC;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B2D4: using guessed type int dword_806B2D4;
// 806B360: using guessed type int dword_806B360;

//----- (0805D376) --------------------------------------------------------
int __cdecl sub_805D376(char *a1, char *a2, int a3, int a4)
{
  void *v4; // eax
  int v5; // edx
  int v6; // ecx
  void *v7; // eax
  void *v8; // eax
  int result; // eax
  void *v10; // eax
  void *v11; // eax
  int v12; // edx
  int v13; // ecx
  int v14; // [esp+0h] [ebp-1Ch]
  int v15; // [esp+4h] [ebp-18h]
  int v16; // [esp+Ch] [ebp-10h]

  BYTE2(v16) = *a1;
  HIBYTE(v16) = *a2;
  if ( BYTE2(v16) == 45 )
  {
    do
    {
      do
        BYTE2(v16) = *++a1;
      while ( BYTE2(v16) == 48 );
    }
    while ( BYTE2(v16) == a4 );
    v4 = &loc_805D3D3;
    if ( HIBYTE(v16) == 45 )
      v4 = &loc_805D49A;
    dword_806B374 = (int)v4;
    sub_80610EA();
    if ( BYTE2(v16) == a3 )
    {
      do
        BYTE2(v16) = *++a1;
      while ( BYTE2(v16) == 48 );
    }
    if ( (unsigned int)BYTE2(v16) - 48 <= 9 )
    {
      dword_806B2FC = (int)&locret_805D900;
      sub_80613B1();
    }
    while ( 1 )
    {
      v7 = &loc_805D445;
      if ( HIBYTE(v16) == 48 )
        v7 = &loc_805D419;
      dword_806B2E8 = (int)v7;
      sub_8061429(v6, v5);
      if ( HIBYTE(v16) != a4 )
        break;
      HIBYTE(v16) = *++a2;
    }
    v8 = &loc_805D470;
    if ( HIBYTE(v16) != a3 )
      v8 = &loc_805D483;
    dword_806B34C = (int)v8;
    sub_80611C6(v6, v5);
    do
      HIBYTE(v16) = *++a2;
    while ( HIBYTE(v16) == 48 );
    result = -((unsigned int)HIBYTE(v16) - 48 <= 9);
  }
  else
  {
    v10 = &loc_805D662;
    if ( HIBYTE(v16) != 45 )
      v10 = &loc_805D73F;
    dword_806B2D4 = (int)v10;
    sub_80614AE(v14, v15);
    do
    {
      HIBYTE(v16) = *++a2;
      v11 = &loc_805D68E;
      if ( HIBYTE(v16) == 48 )
        v11 = &loc_805D662;
      dword_806B25C = (int)v11;
      sub_806177B();
    }
    while ( HIBYTE(v16) == a4 );
    if ( HIBYTE(v16) == a3 )
    {
      do
        HIBYTE(v16) = *++a2;
      while ( HIBYTE(v16) == 48 );
    }
    if ( (unsigned int)HIBYTE(v16) - 48 <= 9 )
    {
      dword_806B25C = (int)&locret_805D900;
      sub_806177B();
    }
    dword_806B310 = (int)&loc_805D6FF;
    sub_8061339(v13, v12);
    do
    {
      do
        BYTE2(v16) = *++a1;
      while ( BYTE2(v16) == 48 );
    }
    while ( BYTE2(v16) == a4 );
    if ( BYTE2(v16) == a3 )
    {
      do
        BYTE2(v16) = *++a1;
      while ( BYTE2(v16) == 48 );
    }
    result = (unsigned int)BYTE2(v16) - 48 <= 9;
  }
  return result;
}
// 805D376: could not find valid save-restore pair for ebx
// 80610EA: using guessed type int sub_80610EA(void);
// 80611C6: using guessed type int __fastcall sub_80611C6(_DWORD, _DWORD);
// 8061339: using guessed type int __fastcall sub_8061339(_DWORD, _DWORD);
// 8061429: using guessed type int __fastcall sub_8061429(_DWORD, _DWORD);
// 806177B: using guessed type int sub_806177B(void);
// 806B25C: using guessed type int dword_806B25C;
// 806B2D4: using guessed type int dword_806B2D4;
// 806B2E8: using guessed type int dword_806B2E8;
// 806B2FC: using guessed type int dword_806B2FC;
// 806B310: using guessed type int dword_806B310;
// 806B34C: using guessed type int dword_806B34C;
// 806B374: using guessed type int dword_806B374;

//----- (0805D902) --------------------------------------------------------
int __cdecl sub_805D902(char *a1, char *a2, int a3, int a4)
{
  return sub_805D376(a1, a2, a3, a4);
}

//----- (0805D92A) --------------------------------------------------------
int __cdecl sub_805D92A(int fd)
{
  int v1; // ST18_4
  int v2; // ST1C_4

  if ( fd >= 0 && fd <= 2 )
  {
    v1 = sub_8060CBB(fd);
    v2 = *__errno_location();
    close(fd);
    *__errno_location() = v2;
    fd = v1;
  }
  return fd;
}

//----- (0805D974) --------------------------------------------------------
int __cdecl sub_805D974(FILE *stream, int a2, int a3, int a4, int a5, int a6)
{
  char *v6; // eax
  char *v7; // ebx
  char *v8; // eax
  int v9; // esi
  char *v10; // ebx
  char *v11; // eax
  int v12; // edi
  int v13; // esi
  char *v14; // ebx
  char *v15; // eax
  int v16; // edi
  int v17; // esi
  char *v18; // ebx
  char *v19; // eax
  int result; // eax
  int v21; // edi
  int v22; // esi
  char *v23; // ebx
  char *v24; // eax
  int v25; // edi
  int v26; // esi
  char *v27; // ebx
  char *v28; // eax
  int v29; // esi
  int v30; // edi
  char *v31; // ebx
  char *v32; // eax
  int v33; // edi
  int v34; // esi
  char *v35; // ebx
  char *v36; // eax
  int v37; // edi
  int v38; // esi
  char *v39; // ebx
  char *v40; // eax
  int v41; // edi
  int v42; // esi
  char *v43; // ebx
  char *v44; // eax
  char *v45; // [esp+8h] [ebp-60h]
  int v46; // [esp+Ch] [ebp-5Ch]
  int v47; // [esp+10h] [ebp-58h]
  int v48; // [esp+14h] [ebp-54h]
  int v49; // [esp+18h] [ebp-50h]
  int v50; // [esp+1Ch] [ebp-4Ch]
  int v51; // [esp+20h] [ebp-48h]
  int v52; // [esp+24h] [ebp-44h]
  int v53; // [esp+38h] [ebp-30h]
  int v54; // [esp+3Ch] [ebp-2Ch]
  int v55; // [esp+40h] [ebp-28h]
  int v56; // [esp+44h] [ebp-24h]
  int v57; // [esp+48h] [ebp-20h]
  int v58; // [esp+4Ch] [ebp-1Ch]

  if ( a2 )
  {
    v47 = a4;
    fprintf(stream, "%s (%s) %s\n", a2, a3, a4);
  }
  else
  {
    fprintf(stream, "%s %s\n", a3, a4);
  }
  v46 = 2017;
  v45 = gettext("(C)");
  fprintf(stream, "Copyright %s %d Free Software Foundation, Inc.", v45, 2017);
  v6 = gettext(
         "\n"
         "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\n"
         "This is free software: you are free to change and redistribute it.\n"
         "There is NO WARRANTY, to the extent permitted by law.\n"
         "\n");
  fputs_unlocked(v6, stream);
  switch ( a6 )
  {
    case 0:
      abort();
      return result;
    case 1:
      v7 = *(char **)a5;
      v8 = gettext("Written by %s.\n");
      v45 = v7;
      fprintf(stream, v8, v7);
      dword_806B2FC = (int)&loc_805DEC1;
      sub_80613B1();
      goto LABEL_7;
    case 2:
LABEL_7:
      v9 = *(_DWORD *)(a5 + 4);
      v10 = *(char **)a5;
      v11 = gettext("Written by %s and %s.\n");
      v46 = v9;
      v45 = v10;
      fprintf(stream, v11, v10, v9);
      dword_806B220 = (int)&loc_805DEC1;
      sub_80618EC();
      goto LABEL_8;
    case 3:
LABEL_8:
      v12 = *(_DWORD *)(a5 + 8);
      v13 = *(_DWORD *)(a5 + 4);
      v14 = *(char **)a5;
      v15 = gettext("Written by %s, %s, and %s.\n");
      v47 = v12;
      v46 = v13;
      v45 = v14;
      fprintf(stream, v15, v14, v13, v12);
      dword_806B360 = (int)&loc_805DEC1;
      sub_8061156();
      goto LABEL_9;
    case 4:
LABEL_9:
      v58 = *(_DWORD *)(a5 + 12);
      v16 = *(_DWORD *)(a5 + 8);
      v17 = *(_DWORD *)(a5 + 4);
      v18 = *(char **)a5;
      v19 = gettext("Written by %s, %s, %s,\nand %s.\n");
      v48 = v58;
      v47 = v16;
      v46 = v17;
      v45 = v18;
      return fprintf(stream, v19, v18, v17, v16, v58);
    case 5:
      v58 = *(_DWORD *)(a5 + 16);
      v57 = *(_DWORD *)(a5 + 12);
      v21 = *(_DWORD *)(a5 + 8);
      v22 = *(_DWORD *)(a5 + 4);
      v23 = *(char **)a5;
      v24 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
      return fprintf(stream, v24, v23, v22, v21, v57, v58);
    case 6:
      v58 = *(_DWORD *)(a5 + 20);
      v57 = *(_DWORD *)(a5 + 16);
      v56 = *(_DWORD *)(a5 + 12);
      v25 = *(_DWORD *)(a5 + 8);
      v26 = *(_DWORD *)(a5 + 4);
      v27 = *(char **)a5;
      v28 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
      return fprintf(stream, v28, v27, v26, v25, v56, v57, v58);
    case 7:
      v29 = *(_DWORD *)(a5 + 24);
      v58 = *(_DWORD *)(a5 + 20);
      v57 = *(_DWORD *)(a5 + 16);
      v56 = *(_DWORD *)(a5 + 12);
      v55 = *(_DWORD *)(a5 + 8);
      v30 = *(_DWORD *)(a5 + 4);
      v31 = *(char **)a5;
      v32 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
      v51 = v29;
      v50 = v58;
      v49 = v57;
      v48 = v56;
      v47 = v55;
      v46 = v30;
      v45 = v31;
      fprintf(stream, v32, v31, v30, v55, v56, v57, v58, v29);
      dword_806B248 = (int)&loc_805DEC1;
      sub_80617ED();
      goto LABEL_13;
    case 8:
LABEL_13:
      v33 = *(_DWORD *)(a5 + 28);
      v58 = *(_DWORD *)(a5 + 24);
      v57 = *(_DWORD *)(a5 + 20);
      v56 = *(_DWORD *)(a5 + 16);
      v55 = *(_DWORD *)(a5 + 12);
      v54 = *(_DWORD *)(a5 + 8);
      v34 = *(_DWORD *)(a5 + 4);
      v35 = *(char **)a5;
      v36 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
      v52 = v33;
      v51 = v58;
      v50 = v57;
      v49 = v56;
      v48 = v55;
      v47 = v54;
      v46 = v34;
      v45 = v35;
      result = fprintf(stream, v36, v35, v34, v54, v55, v56, v57, v58, v33);
      break;
    case 9:
      v37 = *(_DWORD *)(a5 + 32);
      v58 = *(_DWORD *)(a5 + 28);
      v57 = *(_DWORD *)(a5 + 24);
      v56 = *(_DWORD *)(a5 + 20);
      v55 = *(_DWORD *)(a5 + 16);
      v54 = *(_DWORD *)(a5 + 12);
      v53 = *(_DWORD *)(a5 + 8);
      v38 = *(_DWORD *)(a5 + 4);
      v39 = *(char **)a5;
      v40 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
      result = fprintf(stream, v40, v39, v38, v53, v54, v55, v56, v57, v58, v37);
      break;
    default:
      v41 = *(_DWORD *)(a5 + 32);
      v58 = *(_DWORD *)(a5 + 28);
      v57 = *(_DWORD *)(a5 + 24);
      v56 = *(_DWORD *)(a5 + 20);
      v55 = *(_DWORD *)(a5 + 16);
      v54 = *(_DWORD *)(a5 + 12);
      v53 = *(_DWORD *)(a5 + 8);
      v42 = *(_DWORD *)(a5 + 4);
      v43 = *(char **)a5;
      v44 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
      result = fprintf(stream, v44, v43, v42, v53, v54, v55, v56, v57, v58, v41);
      break;
  }
  return result;
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8061156: using guessed type int sub_8061156(void);
// 80617ED: using guessed type int sub_80617ED(void);
// 80618EC: using guessed type int sub_80618EC(void);
// 806B220: using guessed type int dword_806B220;
// 806B248: using guessed type int dword_806B248;
// 806B2FC: using guessed type int dword_806B2FC;
// 806B360: using guessed type int dword_806B360;

//----- (0805DF21) --------------------------------------------------------
int __cdecl sub_805DF21(FILE *stream, int a2, int a3, int a4, int a5)
{
  int *v5; // eax
  unsigned int i; // [esp+24h] [ebp-34h]
  int v8[12]; // [esp+28h] [ebp-30h]

  for ( i = 0; i <= 9; ++i )
  {
    v5 = (int *)a5;
    a5 += 4;
    v8[i] = *v5;
    if ( !v8[i] )
      break;
  }
  return sub_805D974(stream, a2, a3, a4, (int)v8, i);
}
// 805DF21: using guessed type int var_30[12];

//----- (0805DF87) --------------------------------------------------------
int sub_805DF87(FILE *stream, int a2, int a3, int a4, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a4);
  return sub_805DF21(stream, a2, a3, a4, (int)va);
}

//----- (0805E027) --------------------------------------------------------
void *__cdecl sub_805E027(unsigned int a1, unsigned int a2)
{
  if ( 0x7FFFFFFF / a2 < a1 )
    sub_805E2B6();
  return sub_805E14D(a2 * a1);
}

//----- (0805E08A) --------------------------------------------------------
void *__cdecl sub_805E08A(void *ptr, int a2, int a3)
{
  void *v3; // eax
  unsigned int v5; // [esp+1Ch] [ebp-Ch]
  unsigned int v6; // [esp+1Ch] [ebp-Ch]

  v5 = *(_DWORD *)a2;
  if ( ptr )
  {
    if ( 0x55555554u / a3 <= v5 )
      sub_805E2B6();
    v6 = (v5 >> 1) + v5 + 1;
  }
  else
  {
    v3 = &loc_805E0BD;
    if ( v5 )
      v3 = &loc_805E0DA;
    dword_806B2FC = (int)v3;
    sub_80613B1();
    v6 = (0x40u / a3 == 0) + 0x40u / a3;
    if ( 0x7FFFFFFFu / a3 < v6 )
      sub_805E2B6();
  }
  *(_DWORD *)a2 = v6;
  return sub_805E177(ptr, a3 * v6);
}
// 806B2FC: using guessed type int dword_806B2FC;

//----- (0805E13A) --------------------------------------------------------
void *__cdecl sub_805E13A(size_t size)
{
  return sub_805E14D(size);
}

//----- (0805E14D) --------------------------------------------------------
void *__cdecl sub_805E14D(size_t size)
{
  void *v2; // [esp+1Ch] [ebp-Ch]

  v2 = malloc(size);
  if ( !v2 && size )
    sub_805E2B6();
  return v2;
}

//----- (0805E177) --------------------------------------------------------
void *__cdecl sub_805E177(void *ptr, size_t size)
{
  void *result; // eax
  void *v3; // eax
  bool v4; // zf
  void *v5; // eax
  void *ptra; // [esp+20h] [ebp+8h]

  if ( size || !ptr )
  {
    v3 = realloc(ptr, size);
    ptra = v3;
    v4 = v3 == 0;
    v5 = &loc_805E1CF;
    if ( !v4 )
      v5 = &loc_805E1DA;
    dword_806B360 = (int)v5;
    sub_8061156();
    if ( size )
      sub_805E2B6();
    result = ptra;
  }
  else
  {
    free(ptr);
    result = 0;
  }
  return result;
}
// 8061156: using guessed type int sub_8061156(void);
// 806B360: using guessed type int dword_806B360;

//----- (0805E22B) --------------------------------------------------------
void *__cdecl sub_805E22B(size_t nmemb, size_t size)
{
  void *v3; // [esp+1Ch] [ebp-Ch]

  if ( 0x7FFFFFFF / size < nmemb || (v3 = calloc(nmemb, size)) == 0 )
    sub_805E2B6();
  return v3;
}

//----- (0805E268) --------------------------------------------------------
void *__cdecl sub_805E268(void *src, size_t n)
{
  void *v2; // eax

  v2 = sub_805E14D(n);
  return memcpy(v2, src, n);
}

//----- (0805E2B6) --------------------------------------------------------
void __noreturn sub_805E2B6()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (0805E2EF) --------------------------------------------------------
void __cdecl __noreturn sub_805E2EF(int errnum)
{
  char *v1; // eax
  char *v2; // eax

  v1 = gettext("string comparison failed");
  error(0, errnum, v1);
  v2 = gettext("Set LC_ALL='C' to work around the problem.");
  error(0, 0, v2);
  sub_805B866(1, 8);
}

//----- (0805E420) --------------------------------------------------------
void __cdecl __noreturn sub_805E420(void *s1, size_t n, void *s2, int a4)
{
  int v4; // eax
  bool v5; // zf
  int (*v6)(); // eax
  int errnum; // [esp+2Ch] [ebp-Ch]

  sub_8060B5B(s1, n, s2, a4);
  v4 = *__errno_location();
  errnum = v4;
  v5 = v4 == 0;
  v6 = (int (*)())&loc_805E472;
  if ( v5 )
    v6 = sub_805E49F;
  dword_806B2C0 = (int)v6;
  sub_8061526();
  sub_805E2EF(errnum);
}
// 805E49F: using guessed type int sub_805E49F();
// 8061526: using guessed type int sub_8061526(void);
// 806B2C0: using guessed type int dword_806B2C0;

//----- (0805E49F) --------------------------------------------------------
#error "805E4A3: positive sp value has been found (funcsize=0)"

//----- (0805E4A4) --------------------------------------------------------
signed int __cdecl sub_805E4A4(double a1)
{
  bool v1; // zf
  void *v2; // eax
  int v3; // edx
  int v4; // ecx
  double v6; // [esp+18h] [ebp-20h]
  struct timespec requested_time; // [esp+28h] [ebp-10h]

  v6 = a1;
  sub_8060047(&requested_time, a1);
  do
  {
    *__errno_location() = 0;
    v1 = nanosleep(&requested_time, 0) == 0;
    v2 = &loc_805E506;
    if ( !v1 )
      v2 = &loc_805E522;
    dword_806B284 = (int)v2;
    sub_8061686();
    dword_806B270 = (int)&locret_805E542;
    sub_80616F6(v4, v3);
  }
  while ( *__errno_location() == 4 || !*__errno_location() );
  return -1;
}
// 8061686: using guessed type int sub_8061686(void);
// 80616F6: using guessed type int __fastcall sub_80616F6(_DWORD, _DWORD);
// 806B270: using guessed type int dword_806B270;
// 806B284: using guessed type int dword_806B284;

//----- (0805E544) --------------------------------------------------------
int __cdecl sub_805E544(unsigned int *a1, unsigned int a2)
{
  if ( 0xFFFFFFFF / a2 < *a1 )
  {
    *a1 = -1;
    dword_806B2C0 = (int)&loc_805E59B;
    sub_8061526();
  }
  *a1 *= a2;
  return 0;
}
// 8061526: using guessed type int sub_8061526(void);
// 806B2C0: using guessed type int dword_806B2C0;

//----- (0805E59D) --------------------------------------------------------
int __cdecl sub_805E59D(unsigned int *a1, unsigned int a2, int a3)
{
  int v3; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; i |= sub_805E544(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}

//----- (0805E5D3) --------------------------------------------------------
int __cdecl sub_805E5D3(char *nptr, int a2, int base, int a4, char *s)
{
  char **v5; // eax
  void *v6; // eax
  int v7; // edx
  int v8; // ecx
  void *v9; // eax
  bool v10; // zf
  void *v11; // eax
  int result; // eax
  void *v13; // eax
  int v14; // edx
  int v15; // ecx
  void *v16; // eax
  int v17; // edx
  int v18; // ecx
  int v19; // eax
  void *v20; // eax
  int v21; // edx
  int v22; // ecx
  int v23; // [esp+0h] [ebp-48h]
  int v24; // [esp+4h] [ebp-44h]
  unsigned __int8 i; // [esp+1Fh] [ebp-29h]
  char v26; // [esp+20h] [ebp-28h]
  unsigned int v27; // [esp+24h] [ebp-24h]
  int v28; // [esp+28h] [ebp-20h]
  char *v29; // [esp+2Ch] [ebp-1Ch]
  unsigned int v30; // [esp+30h] [ebp-18h]
  int v31; // [esp+34h] [ebp-14h]
  int v32; // [esp+38h] [ebp-10h]
  char **endptr; // [esp+3Ch] [ebp-Ch]

  v28 = 0;
  if ( base < 0 || base > 36 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoul");
  if ( a2 )
    v5 = (char **)a2;
  else
    v5 = (char **)&v26;
  endptr = v5;
  *__errno_location() = 0;
  v29 = nptr;
  for ( i = *nptr; (*__ctype_b_loc())[i] & 0x2000; i = *v29 )
    ++v29;
  v6 = &loc_805E689;
  if ( i != 45 )
    v6 = &loc_805E6A5;
  dword_806B374 = (int)v6;
  sub_80610EA();
  dword_806B270 = (int)&locret_805EA75;
  sub_80616F6(v8, v7);
  v27 = strtoul(nptr, endptr, base);
  if ( *endptr == nptr )
  {
    if ( !s )
      return 4;
    v9 = &loc_805E6F6;
    if ( !**endptr )
      v9 = &loc_805E736;
    dword_806B360 = (int)v9;
    sub_8061156();
    v24 = **endptr;
    v10 = strchr(s, v24) == 0;
    v11 = &loc_805E72D;
    if ( v10 )
      v11 = &loc_805E736;
    dword_806B2D4 = (int)v11;
    sub_80614AE(v23, v24);
    v27 = 1;
  }
  else
  {
    v10 = *__errno_location() == 0;
    v13 = &loc_805E764;
    if ( v10 )
      v13 = &loc_805E793;
    dword_806B248 = (int)v13;
    sub_80617ED();
    if ( *__errno_location() != 34 )
    {
      dword_806B2FC = (int)&locret_805EA75;
      sub_80613B1();
    }
    v28 = 1;
  }
  if ( !s )
  {
    *(_DWORD *)a4 = v27;
    return v28;
  }
  if ( !**endptr )
  {
LABEL_57:
    *(_DWORD *)a4 = v27;
    return v28;
  }
  v30 = 1024;
  v31 = 1;
  v24 = **endptr;
  if ( !strchr(s, v24) )
  {
    *(_DWORD *)a4 = v27;
    return v28 | 2;
  }
  switch ( **endptr )
  {
    case 69:
    case 71:
    case 75:
    case 77:
    case 80:
    case 84:
    case 89:
    case 90:
    case 103:
    case 107:
    case 109:
    case 116:
      v10 = strchr(s, 48) == 0;
      v16 = &loc_805E848;
      if ( v10 )
        v16 = &loc_805E8A2;
      dword_806B34C = (int)v16;
      sub_80611C6(v15, v14);
      v19 = (*endptr)[1];
      switch ( v19 )
      {
        case 68:
          goto LABEL_60;
        case 105:
          v20 = &loc_805E88F;
          if ( (*endptr)[2] != 66 )
            v20 = &loc_805E895;
          dword_806B324 = (int)v20;
          sub_80612C5(v18, v17);
          v31 += 2;
          goto LABEL_41;
        case 66:
LABEL_60:
          v30 = 1000;
          ++v31;
          break;
      }
      break;
    default:
      break;
  }
LABEL_41:
  switch ( **endptr )
  {
    case 66:
      v32 = sub_805E544(&v27, 0x400u);
      goto LABEL_55;
    case 69:
      v32 = sub_805E59D(&v27, v30, 6);
      goto LABEL_55;
    case 71:
    case 103:
      v32 = sub_805E59D(&v27, v30, 3);
      goto LABEL_55;
    case 75:
    case 107:
      v32 = sub_805E59D(&v27, v30, 1);
      dword_806B2AC = (int)&loc_805EA45;
      sub_806159C(v22, v21);
      goto LABEL_48;
    case 77:
    case 109:
LABEL_48:
      v32 = sub_805E59D(&v27, v30, 2);
      goto LABEL_55;
    case 80:
      v32 = sub_805E59D(&v27, v30, 5);
      goto LABEL_55;
    case 84:
    case 116:
      v32 = sub_805E59D(&v27, v30, 4);
      goto LABEL_55;
    case 89:
      v32 = sub_805E59D(&v27, v30, 8);
      goto LABEL_55;
    case 90:
      v32 = sub_805E59D(&v27, v30, 7);
      goto LABEL_55;
    case 98:
      v32 = sub_805E544(&v27, 0x200u);
      goto LABEL_55;
    case 99:
      v32 = 0;
      goto LABEL_55;
    case 119:
      v32 = sub_805E544(&v27, 2u);
LABEL_55:
      v28 |= v32;
      *endptr += v31;
      if ( **endptr )
        v28 |= 2u;
      goto LABEL_57;
    default:
      *(_DWORD *)a4 = v27;
      result = v28 | 2;
      break;
  }
  return result;
}
// 805E5D3: could not find valid save-restore pair for ebx
// 80610EA: using guessed type int sub_80610EA(void);
// 8061156: using guessed type int sub_8061156(void);
// 80611C6: using guessed type int __fastcall sub_80611C6(_DWORD, _DWORD);
// 80612C5: using guessed type int __fastcall sub_80612C5(_DWORD, _DWORD);
// 806159C: using guessed type int __fastcall sub_806159C(_DWORD, _DWORD);
// 80616F6: using guessed type int __fastcall sub_80616F6(_DWORD, _DWORD);
// 80617ED: using guessed type int sub_80617ED(void);
// 806B248: using guessed type int dword_806B248;
// 806B270: using guessed type int dword_806B270;
// 806B2AC: using guessed type int dword_806B2AC;
// 806B2D4: using guessed type int dword_806B2D4;
// 806B2FC: using guessed type int dword_806B2FC;
// 806B324: using guessed type int dword_806B324;
// 806B34C: using guessed type int dword_806B34C;
// 806B360: using guessed type int dword_806B360;
// 806B374: using guessed type int dword_806B374;

//----- (0805EA77) --------------------------------------------------------
void __cdecl sub_805EA77(int a1, int a2, int a3, int a4, int a5, int status)
{
  char *v6; // eax
  char v7; // [esp+22h] [ebp-16h]
  char v8; // [esp+23h] [ebp-15h]
  const char *v9; // [esp+24h] [ebp-14h]
  char *msgid; // [esp+28h] [ebp-10h]
  char *v11; // [esp+2Ch] [ebp-Ch]

  v9 = "--";
  if ( (unsigned int)a1 > 3 )
  {
    if ( a1 != 4 )
      goto LABEL_6;
    msgid = "invalid %s%s argument '%s'";
  }
  else if ( (unsigned int)a1 >= 2 )
  {
    msgid = "invalid suffix in %s%s argument '%s'";
  }
  else
  {
    if ( a1 != 1 )
LABEL_6:
      abort();
    msgid = "%s%s argument '%s' too large";
  }
  if ( a2 >= 0 )
  {
    v11 = *(char **)(16 * a2 + a4);
  }
  else
  {
    v9 -= a2;
    v7 = a3;
    v8 = 0;
    v11 = &v7;
  }
  v6 = gettext(msgid);
  error(status, 0, v6, v9, v11, a5);
}

//----- (0805EB2D) --------------------------------------------------------
void __cdecl __noreturn sub_805EB2D(int a1, int a2, char a3, int a4, int a5)
{
  sub_805EA77(a1, a2, a3, a4, a5, status);
  abort();
}

//----- (0805EB70) --------------------------------------------------------
signed int __cdecl sub_805EB70(int a1, signed int a2)
{
  signed int result; // eax
  int v3; // ebx

  if ( (unsigned __int64)sub_8060CE0(0xFFFFFFFFFFFFFFFFLL, a2, a2 >> 31) >= *(_QWORD *)a1 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    *(_QWORD *)a1 *= a2;
    result = 0;
  }
  else
  {
    *(_DWORD *)a1 = -1;
    *(_DWORD *)(a1 + 4) = -1;
    result = 1;
  }
  return result;
}

//----- (0805EBFC) --------------------------------------------------------
int __cdecl sub_805EBFC(int a1, signed int a2, int a3)
{
  int v3; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; ; i |= sub_805EB70(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}

//----- (0805EC32) --------------------------------------------------------
int __usercall sub_805EC32@<eax>(int a1@<edx>, int a2@<ecx>, char *nptr, int a4, int base, int a6, char *s)
{
  void *v7; // eax
  char **v8; // eax
  bool v9; // zf
  void *v10; // eax
  void *v12; // eax
  int v13; // edx
  int v14; // [esp+4h] [ebp-44h]
  unsigned __int8 v15; // [esp+1Bh] [ebp-2Dh]
  char v16; // [esp+1Ch] [ebp-2Ch]
  int v17; // [esp+20h] [ebp-28h]
  char *v18; // [esp+24h] [ebp-24h]
  char **endptr; // [esp+34h] [ebp-14h]
  uintmax_t v20; // [esp+38h] [ebp-10h]

  v17 = 0;
  if ( base < 0 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoumax");
  v7 = &loc_805EC64;
  if ( base > 36 )
    v7 = &loc_805EC6C;
  dword_806B310 = (int)v7;
  sub_8061339(a2, a1);
  if ( a4 )
    v8 = (char **)a4;
  else
    v8 = (char **)&v16;
  endptr = v8;
  *__errno_location() = 0;
  v18 = nptr;
  v15 = *nptr;
  dword_806B20C = (int)&loc_805ECD9;
  sub_806195A();
  v15 = *++v18;
  v9 = ((*__ctype_b_loc())[v15] & 0x2000) == 0;
  v10 = &loc_805ED10;
  if ( !v9 )
    v10 = &loc_805ECCC;
  dword_806B360 = (int)v10;
  sub_8061156();
  if ( v15 == 45 )
    return 4;
  v20 = strtoumax(nptr, endptr, base);
  if ( *endptr == nptr )
  {
    if ( !s )
      return 4;
    if ( !**endptr )
      return 4;
    v14 = **endptr;
    if ( !strchr(s, v14) )
      return 4;
    v20 = 1LL;
  }
  else if ( *__errno_location() )
  {
    if ( *__errno_location() != 34 )
      return 4;
    v17 = 1;
  }
  v12 = &loc_805EDDA;
  if ( s )
    v12 = &loc_805EDF0;
  dword_806B20C = (int)v12;
  sub_806195A();
  v13 = HIDWORD(v20);
  *(_DWORD *)a6 = v20;
  *(_DWORD *)(a6 + 4) = v13;
  return v17;
}
// 805EC32: could not find valid save-restore pair for ebx
// 8061156: using guessed type int sub_8061156(void);
// 8061339: using guessed type int __fastcall sub_8061339(_DWORD, _DWORD);
// 806195A: using guessed type int sub_806195A(void);
// 806B20C: using guessed type int dword_806B20C;
// 806B310: using guessed type int dword_806B310;
// 806B360: using guessed type int dword_806B360;

//----- (0805F101) --------------------------------------------------------
int __cdecl sub_805F101(FILE *stream)
{
  int v2; // eax
  __int64 v3; // rax
  bool v4; // zf
  void *v5; // eax
  void *v6; // eax
  int v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+18h] [ebp-10h]

  if ( fileno(stream) < 0 )
    return fclose(stream);
  if ( __freading(stream) )
  {
    v2 = fileno(stream);
    LODWORD(v3) = lseek64(v2, 0, 0, 1);
    v4 = v3 == -1;
    v5 = &loc_805F19A;
    if ( v4 )
      v5 = &loc_805F1CC;
    dword_806B360 = (int)v5;
    sub_8061156();
  }
  v4 = sub_805F3C7(stream) == 0;
  v6 = &loc_805F1C2;
  if ( v4 )
    v6 = &loc_805F1CC;
  dword_806B374 = (int)v6;
  sub_80610EA();
  v7 = *__errno_location();
  v8 = fclose(stream);
  if ( v7 )
  {
    *__errno_location() = v7;
    v8 = -1;
  }
  return v8;
}
// 805F101: could not find valid save-restore pair for ebx
// 8049A90: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 80610EA: using guessed type int sub_80610EA(void);
// 8061156: using guessed type int sub_8061156(void);
// 806B360: using guessed type int dword_806B360;
// 806B374: using guessed type int dword_806B374;

//----- (0805F1F6) --------------------------------------------------------
int __cdecl sub_805F1F6(int fd, int cmd, char a3)
{
  void *v3; // eax
  int v4; // ST30_4
  int v5; // ecx
  int v7; // [esp+1Ch] [ebp-1Ch]
  char v8; // [esp+20h] [ebp-18h]
  int v9; // [esp+24h] [ebp-14h]

  v3 = &loc_805F22C;
  if ( cmd != 1030 )
    v3 = &loc_805F35F;
  dword_806B360 = (int)v3;
  sub_8061156();
  v8 = a3;
  if ( dword_806C484 < 0 )
  {
    v7 = sub_805F1F6(fd, 0, a3);
  }
  else
  {
    v7 = fcntl(fd, cmd, a3);
    if ( v7 < 0 && *__errno_location() == 22 )
    {
      v7 = sub_805F1F6(fd, 0, v8);
      if ( v7 < 0 )
        return v7;
      dword_806C484 = -1;
    }
    else
    {
      dword_806C484 = 1;
    }
  }
  if ( v7 >= 0 && dword_806C484 == -1 )
  {
    v9 = fcntl(v7, 1);
    if ( v9 < 0 || fcntl(v7, 2, v9 | 1) == -1 )
    {
      v4 = *__errno_location();
      close(v7);
      *__errno_location() = v4;
      v7 = -1;
      dword_806B324 = (int)&loc_805F389;
      sub_80612C5(v5, v4);
    }
  }
  return v7;
}
// 8061156: using guessed type int sub_8061156(void);
// 80612C5: using guessed type int __fastcall sub_80612C5(_DWORD, _DWORD);
// 806B324: using guessed type int dword_806B324;
// 806B360: using guessed type int dword_806B360;
// 806C484: using guessed type int dword_806C484;

//----- (0805F38E) --------------------------------------------------------
int __cdecl sub_805F38E(FILE *stream)
{
  int result; // eax

  result = stream->_flags & 0x100;
  if ( result )
    result = sub_805F407(stream, 0, 0, 1);
  return result;
}

//----- (0805F3C7) --------------------------------------------------------
int __cdecl sub_805F3C7(FILE *fp)
{
  if ( !fp || !__freading(fp) )
    return fflush(fp);
  sub_805F38E(fp);
  return fflush(fp);
}

//----- (0805F407) --------------------------------------------------------
int __cdecl sub_805F407(FILE *stream, int a2, int a3, int a4)
{
  void *v4; // eax
  int v5; // eax
  __int64 v6; // rax
  int v8; // edx
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  __int64 v11; // [esp+28h] [ebp-10h]

  v9 = a2;
  v10 = a3;
  v4 = &loc_805F442;
  if ( stream->_IO_read_end != stream->_IO_read_ptr )
    v4 = &loc_805F4E9;
  dword_806B360 = (int)v4;
  sub_8061156();
  if ( stream->_IO_write_ptr == stream->_IO_write_base && !stream->_IO_save_base )
  {
    v5 = fileno(stream);
    LODWORD(v6) = lseek64(v5, v9, v10, a4);
    v11 = v6;
    if ( v6 == -1 )
      return -1;
    stream->_flags &= 0xFFFFFFEF;
    v8 = HIDWORD(v11);
    LODWORD(stream->_offset) = v11;
    HIDWORD(stream->_offset) = v8;
    dword_806B25C = (int)&locret_805F509;
    sub_806177B();
  }
  return fseeko64(stream, v9, v10, a4);
}
// 80498B0: using guessed type int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8049A90: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8061156: using guessed type int sub_8061156(void);
// 806177B: using guessed type int sub_806177B(void);
// 806B25C: using guessed type int dword_806B25C;
// 806B360: using guessed type int dword_806B360;

//----- (0805F50B) --------------------------------------------------------
size_t __cdecl sub_805F50B(wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  void *v4; // eax
  void *v5; // eax
  wchar_t v7; // [esp+18h] [ebp-10h]
  size_t v8; // [esp+1Ch] [ebp-Ch]

  v4 = &loc_805F530;
  if ( pwc )
    v4 = &loc_805F536;
  dword_806B25C = (int)v4;
  sub_806177B();
  v8 = mbrtowc(&v7, s, n, p);
  if ( v8 <= 0xFFFFFFFD )
    return v8;
  v5 = &loc_805F57E;
  if ( !n )
    v5 = &loc_805F5AA;
  dword_806B338 = (int)v5;
  sub_8061251();
  if ( !((unsigned __int8)sub_805782D(0) ^ 1) )
    return v8;
  v7 = (unsigned __int8)*s;
  return 1;
}
// 805F50B: could not find valid save-restore pair for ebx
// 8061251: using guessed type int sub_8061251(void);
// 806177B: using guessed type int sub_806177B(void);
// 806B25C: using guessed type int dword_806B25C;
// 806B338: using guessed type int dword_806B338;

//----- (0805F5AF) --------------------------------------------------------
int __cdecl sub_805F5AF(int a1, int a2)
{
  void *v2; // eax

  v2 = &loc_805F5DC;
  if ( !(*(_BYTE *)(a1 + 40) & 1) )
    v2 = &loc_805F5F6;
  dword_806B220 = (int)v2;
  sub_80618EC();
  return (*(int (__cdecl **)(_DWORD, int))(a1 + 28))(*(_DWORD *)(a1 + 36), a2);
}
// 80618EC: using guessed type int sub_80618EC(void);
// 806B220: using guessed type int dword_806B220;

//----- (0805F606) --------------------------------------------------------
int __usercall sub_805F606@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4)
{
  void *v4; // eax

  v4 = &loc_805F633;
  if ( !(*(_BYTE *)(a3 + 40) & 1) )
    v4 = &loc_805F64D;
  dword_806B2AC = (int)v4;
  sub_806159C(a2, a1);
  return (*(int (__cdecl **)(_DWORD, int))(a3 + 32))(*(_DWORD *)(a3 + 36), a4);
}
// 806159C: using guessed type int __fastcall sub_806159C(_DWORD, _DWORD);
// 806B2AC: using guessed type int dword_806B2AC;

//----- (0805F65D) --------------------------------------------------------
signed int __cdecl sub_805F65D(int a1, signed int a2, signed int a3)
{
  _DWORD *v4; // [esp+1Ch] [ebp-Ch]

  if ( !a3 )
    a3 = 8;
  if ( !a2 )
    a2 = 4064;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 24) = a3 - 1;
  *(_DWORD *)(a1 + 4) = sub_805F5AF(a1, *(_DWORD *)a1);
  v4 = *(_DWORD **)(a1 + 4);
  if ( !v4 )
    obstack_alloc_failed_handler();
  *(_DWORD *)(a1 + 8) = ((unsigned int)&v4[a3 / 4u + 1] + 3) & -a3;
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 8);
  *v4 = (char *)v4 + *(_DWORD *)a1;
  *(_DWORD *)(a1 + 16) = *v4;
  v4[1] = 0;
  *(_BYTE *)(a1 + 40) &= 0xFDu;
  *(_BYTE *)(a1 + 40) &= 0xFBu;
  return 1;
}
// 806B520: using guessed type int (*obstack_alloc_failed_handler)(void);

//----- (0805F73C) --------------------------------------------------------
signed int __cdecl sub_805F73C(int a1, signed int a2, signed int a3, int a4, int a5)
{
  *(_DWORD *)(a1 + 28) = a4;
  *(_DWORD *)(a1 + 32) = a5;
  *(_BYTE *)(a1 + 40) &= 0xFEu;
  return sub_805F65D(a1, a2, a3);
}

//----- (0805F7C5) --------------------------------------------------------
int __cdecl sub_805F7C5(int a1, int a2)
{
  int v2; // ecx
  int v3; // edx
  int result; // eax
  _DWORD *v5; // [esp+14h] [ebp-24h]
  unsigned int v6; // [esp+18h] [ebp-20h]
  int v7; // [esp+1Ch] [ebp-1Ch]
  unsigned int n; // [esp+20h] [ebp-18h]
  unsigned int v9; // [esp+24h] [ebp-14h]
  unsigned int v10; // [esp+28h] [ebp-10h]
  void *dest; // [esp+2Ch] [ebp-Ch]

  v7 = *(_DWORD *)(a1 + 4);
  v5 = 0;
  n = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 8);
  v9 = n + a2;
  v10 = *(_DWORD *)(a1 + 24) + n + a2;
  v6 = (n >> 3) + v10 + 100;
  if ( v6 < v10 )
    v6 = *(_DWORD *)(a1 + 24) + n + a2;
  if ( *(_DWORD *)a1 > v6 )
    v6 = *(_DWORD *)a1;
  if ( n <= v9 && v9 <= v10 )
    v5 = (_DWORD *)sub_805F5AF(a1, v6);
  if ( !v5 )
    obstack_alloc_failed_handler();
  *(_DWORD *)(a1 + 4) = v5;
  v5[1] = v7;
  *(_DWORD *)(a1 + 16) = (char *)v5 + v6;
  *v5 = *(_DWORD *)(a1 + 16);
  dest = (void *)(((unsigned int)v5 + *(_DWORD *)(a1 + 24) + 8) & ~*(_DWORD *)(a1 + 24));
  memcpy(dest, *(const void **)(a1 + 8), n);
  if ( !(*(_BYTE *)(a1 + 40) & 2) )
  {
    v2 = *(_DWORD *)(a1 + 24) + v7 + 8;
    if ( *(_DWORD *)(a1 + 8) == (v2 & ~*(_DWORD *)(a1 + 24)) )
    {
      v3 = *(_DWORD *)(v7 + 4);
      v5[1] = v3;
      sub_805F606(v3, v2, a1, v7);
    }
  }
  *(_DWORD *)(a1 + 8) = dest;
  *(_DWORD *)(a1 + 12) = n + *(_DWORD *)(a1 + 8);
  result = a1;
  *(_BYTE *)(a1 + 40) &= 0xFDu;
  return result;
}
// 806B520: using guessed type int (*obstack_alloc_failed_handler)(void);

//----- (0805F9A4) --------------------------------------------------------
int __usercall sub_805F9A4@<eax>(int a1@<edx>, int a2@<ecx>, int a3, unsigned int a4)
{
  int result; // eax
  int *v5; // ST1C_4
  int *v6; // [esp+18h] [ebp-10h]

  result = *(_DWORD *)(a3 + 4);
  v6 = *(int **)(a3 + 4);
  while ( v6 )
  {
    if ( (unsigned int)v6 < a4 )
    {
      result = *v6;
      if ( *v6 >= a4 )
        break;
    }
    v5 = (int *)v6[1];
    sub_805F606(a1, a2, a3, (int)v6);
    v6 = v5;
    result = a3;
    a1 = *(unsigned __int8 *)(a3 + 40) | 2;
    *(_BYTE *)(a3 + 40) = a1;
  }
  if ( v6 )
  {
    *(_DWORD *)(a3 + 12) = a4;
    *(_DWORD *)(a3 + 8) = *(_DWORD *)(a3 + 12);
    *(_DWORD *)(a3 + 16) = *v6;
    result = a3;
    *(_DWORD *)(a3 + 4) = v6;
  }
  else if ( a4 )
  {
    abort();
  }
  return result;
}

//----- (0805FC05) --------------------------------------------------------
int __cdecl sub_805FC05(int a1, char a2)
{
  return __ROR4__(a1, a2);
}

//----- (0805FCF0) --------------------------------------------------------
signed int __usercall sub_805FCF0@<eax>(int edx0@<edx>, int a2@<ecx>, signed int a1)
{
  void *v3; // eax

  if ( a1 > 90 )
  {
    if ( (unsigned int)(a1 - 97) <= 0x19 )
      return 1;
  }
  else
  {
    v3 = &loc_805FD19;
    if ( a1 >= 65 )
      v3 = &loc_805FD2B;
    dword_806B2E8 = (int)v3;
    if ( (unsigned int)(sub_8061429(a2, edx0) - 48) <= 9 )
      return 1;
  }
  return 0;
}
// 8061429: using guessed type int __fastcall sub_8061429(_DWORD, _DWORD);
// 806B2E8: using guessed type int dword_806B2E8;

//----- (0805FD39) --------------------------------------------------------
_BOOL4 __cdecl sub_805FD39(signed int a1)
{
  return a1 >= 65 && (a1 <= 90 || (unsigned int)(a1 - 97) <= 0x19);
}

//----- (0805FDD6) --------------------------------------------------------
_BOOL4 __cdecl sub_805FDD6(int a1)
{
  return (unsigned int)(a1 - 48) <= 9;
}

//----- (0805FEAE) --------------------------------------------------------
_BOOL4 __cdecl sub_805FEAE(signed int a1)
{
  return a1 >= 9 && (a1 <= 13 || a1 == 32);
}

//----- (0805FF12) --------------------------------------------------------
int __cdecl sub_805FF12(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 65) > 0x19 )
    result = a1;
  else
    result = a1 + 32;
  return result;
}

//----- (0805FF48) --------------------------------------------------------
int __cdecl sub_805FF48(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // esi
  unsigned __int8 *v3; // ebx
  unsigned __int8 v5; // [esp+1Eh] [ebp-Ah]
  unsigned __int8 v6; // [esp+1Fh] [ebp-9h]

  v2 = a1;
  v3 = a2;
  if ( a1 == a2 )
    return 0;
  do
  {
    v5 = sub_805FF12(*v2);
    v6 = sub_805FF12(*v3);
    if ( !v5 )
      break;
    ++v2;
    ++v3;
  }
  while ( v5 == v6 );
  return v5 - v6;
}

//----- (0805FFAD) --------------------------------------------------------
int __cdecl sub_805FFAD(FILE *fp)
{
  bool v1; // ST26_1
  void *v2; // eax
  bool v4; // [esp+1Dh] [ebp-Bh]
  bool v5; // [esp+1Fh] [ebp-9h]

  v4 = __fpending(fp) != 0;
  v1 = ferror_unlocked(fp) != 0;
  v5 = sub_805F101(fp) != 0;
  v2 = &loc_806000B;
  if ( v1 )
    v2 = &loc_8060023;
  dword_806B298 = (int)v2;
  sub_8061616();
  if ( !v5 || !v4 && *__errno_location() == 9 )
    return 0;
  if ( v5 != 1 )
    *__errno_location() = 0;
  return -1;
}
// 8061616: using guessed type int sub_8061616(void);
// 806B298: using guessed type int dword_806B298;

//----- (08060047) --------------------------------------------------------
_DWORD *__userpurge sub_8060047@<eax>(_DWORD *a1, double a2)
{
  void *v2; // eax
  void *v3; // eax
  double v5; // [esp+18h] [ebp-20h]

  v5 = a2;
  v2 = &loc_806008B;
  if ( a2 > -2147483648.0 == 1 )
    v2 = &loc_80600C0;
  dword_806B284 = (int)v2;
  sub_8061686();
  sub_8060BCF(a1, 2147483648, 0);
  dword_806B360 = (int)&loc_80601CD;
  sub_8061156();
  v3 = &loc_80600F2;
  if ( 2147483648.0 > v5 == 1 )
    v3 = &loc_8060115;
  dword_806B338 = (int)v3;
  sub_8061251();
  sub_8060BCF(a1, 0x7FFFFFFF, 999999999);
  return a1;
}
// 8060047: could not find valid save-restore pair for ebx
// 8061156: using guessed type int sub_8061156(void);
// 8061251: using guessed type int sub_8061251(void);
// 8061686: using guessed type int sub_8061686(void);
// 806B284: using guessed type int dword_806B284;
// 806B338: using guessed type int dword_806B338;
// 806B360: using guessed type int dword_806B360;

//----- (080601D4) --------------------------------------------------------
int __cdecl sub_80601D4(int fd, int a2)
{
  int v2; // ST18_4
  int v3; // ST1C_4

  if ( fd >= 0 && fd <= 2 )
  {
    v2 = sub_8060225(fd, a2);
    v3 = *__errno_location();
    close(fd);
    *__errno_location() = v3;
    fd = v2;
  }
  return fd;
}

//----- (08060225) --------------------------------------------------------
int __cdecl sub_8060225(int fd, int a2)
{
  int v2; // eax

  if ( a2 & 0x80000 )
    v2 = 1030;
  else
    v2 = 0;
  return sub_805F1F6(fd, v2, 3);
}

//----- (0806025C) --------------------------------------------------------
FILE *__cdecl sub_806025C(int a1, char *modes)
{
  int v2; // ST28_4
  int v4; // ST2C_4
  FILE *stream; // [esp+1Ch] [ebp-1Ch]
  signed int v6; // [esp+20h] [ebp-18h]
  int fd; // [esp+24h] [ebp-14h]

  stream = (FILE *)fopen64(a1, modes);
  if ( !stream )
    return stream;
  v6 = fileno(stream);
  if ( v6 < 0 || v6 > 2 )
    return stream;
  fd = sub_8060CBB(v6);
  if ( fd < 0 )
  {
    v2 = *__errno_location();
    sub_805F101(stream);
    *__errno_location() = v2;
    return 0;
  }
  if ( !sub_805F101(stream) )
  {
    stream = fdopen(fd, modes);
    if ( stream )
      return stream;
  }
  v4 = *__errno_location();
  close(fd);
  *__errno_location() = v4;
  return 0;
}
// 80499F0: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (08060332) --------------------------------------------------------
int __noreturn sub_8060332()
{
  void *v0; // eax
  signed int v1; // eax
  void *v2; // eax
  FILE *v3; // eax
  int v4; // edx
  int v5; // ecx
  bool v6; // zf
  void *v7; // eax
  int v8; // edx
  int v9; // ecx
  void *v10; // eax
  void *v11; // eax
  void *v12; // eax
  int (*v13)(); // eax
  void *ptr; // [esp+14h] [ebp-B4h]
  void *v16; // [esp+18h] [ebp-B0h]
  char *s; // [esp+1Ch] [ebp-ACh]
  void *v18; // [esp+20h] [ebp-A8h]
  int v19; // [esp+24h] [ebp-A4h]
  char *v20; // [esp+28h] [ebp-A0h]
  size_t n; // [esp+2Ch] [ebp-9Ch]
  size_t v22; // [esp+30h] [ebp-98h]
  int v23; // [esp+34h] [ebp-94h]
  void *dest; // [esp+38h] [ebp-90h]
  int fd; // [esp+3Ch] [ebp-8Ch]
  FILE *stream; // [esp+40h] [ebp-88h]
  int c; // [esp+44h] [ebp-84h]
  unsigned int v28; // [esp+BCh] [ebp-Ch]

  v28 = __readgsdword(0x14u);
  v16 = (void *)dword_806C488;
  if ( !dword_806C488 )
  {
    ptr = 0;
    v20 = "charset.alias";
    s = getenv("CHARSETALIASDIR");
    if ( !s || !*s )
    {
      ptr = 0;
      s = "/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib";
    }
    n = strlen(s);
    v22 = strlen(v20);
    if ( n )
    {
      v0 = &loc_8060411;
      if ( s[n - 1] == 47 )
        v0 = &loc_8060418;
      dword_806B2FC = (int)v0;
      sub_80613B1();
      v1 = 1;
    }
    else
    {
      v1 = 0;
    }
    v23 = v1;
    dest = malloc(n + v1 + v22 + 1);
    if ( dest )
    {
      memcpy(dest, s, n);
      v2 = &loc_806049B;
      if ( !v23 )
        v2 = &loc_80604AC;
      dword_806B234 = (int)v2;
      sub_806185D();
      *((_BYTE *)dest + n) = 47;
      memcpy((char *)dest + n + v23, v20, v22 + 1);
    }
    free(ptr);
    if ( !dest )
    {
      v16 = &unk_8064E17;
      dword_806B25C = (int)&loc_8060881;
      sub_806177B();
    }
    fd = open64(dest, 0x20000);
    if ( fd >= 0 )
    {
      v3 = fdopen(fd, "r");
      stream = v3;
      v6 = v3 == 0;
      v7 = &loc_806058B;
      if ( !v6 )
        v7 = &loc_80605BA;
      dword_806B324 = (int)v7;
      sub_80612C5(v5, v4);
      close(fd);
      v16 = &unk_8064E17;
      dword_806B220 = (int)&loc_8060873;
      sub_80618EC();
      v18 = 0;
      v19 = 0;
      while ( 1 )
      {
        c = getc_unlocked(stream);
        if ( c == -1 )
          break;
        v10 = &loc_8060612;
        if ( c == 10 )
          v10 = &loc_8060624;
        dword_806B270 = (int)v10;
        sub_80616F6(v9, v8);
        if ( c != 32 && c != 9 )
        {
          v11 = &loc_806064B;
          if ( c != 35 )
            v11 = &loc_8060684;
          dword_806B298 = (int)v11;
          sub_8061616();
          do
            c = getc_unlocked(stream);
          while ( c != -1 && c != 10 );
          if ( c == -1 )
            break;
        }
      }
      sub_805F101(stream);
      v12 = &loc_8060843;
      if ( !v19 )
        v12 = &loc_806084A;
      dword_806B20C = (int)v12;
      sub_806195A();
      *((_BYTE *)v18 + v19) = 0;
      v16 = v18;
    }
    else
    {
      v16 = &unk_8064E17;
    }
    free(dest);
    dword_806C488 = (int)v16;
  }
  v13 = (int (*)())&loc_80608B7;
  if ( __readgsdword(0x14u) == v28 )
    v13 = sub_80608BC;
  dword_806B248 = (int)v13;
  return sub_80617ED();
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 80608BC: using guessed type int sub_80608BC();
// 80612C5: using guessed type int __fastcall sub_80612C5(_DWORD, _DWORD);
// 8061616: using guessed type int sub_8061616(void);
// 80616F6: using guessed type int __fastcall sub_80616F6(_DWORD, _DWORD);
// 806177B: using guessed type int sub_806177B(void);
// 80617ED: using guessed type int sub_80617ED(void);
// 806185D: using guessed type int sub_806185D(void);
// 80618EC: using guessed type int sub_80618EC(void);
// 806195A: using guessed type int sub_806195A(void);
// 806B20C: using guessed type int dword_806B20C;
// 806B220: using guessed type int dword_806B220;
// 806B234: using guessed type int dword_806B234;
// 806B248: using guessed type int dword_806B248;
// 806B25C: using guessed type int dword_806B25C;
// 806B270: using guessed type int dword_806B270;
// 806B298: using guessed type int dword_806B298;
// 806B2FC: using guessed type int dword_806B2FC;
// 806B324: using guessed type int dword_806B324;
// 806C488: using guessed type int dword_806C488;

//----- (080608BC) --------------------------------------------------------
#error "80608C2: positive sp value has been found (funcsize=0)"

//----- (080608C5) --------------------------------------------------------
void __noreturn sub_80608C5()
{
  nl_langinfo(14);
  sub_8060332();
}

//----- (080609AD) --------------------------------------------------------
int __cdecl sub_80609AD(char *s, int a2, char *s2, int a4)
{
  int v5; // eax
  bool v6; // zf
  void *v7; // eax
  int v8; // [esp+14h] [ebp-14h]
  size_t v9; // [esp+18h] [ebp-10h]
  size_t v10; // [esp+1Ch] [ebp-Ch]

  dword_806B374 = (int)&loc_8060A28;
  sub_80610EA();
  while ( 1 )
  {
    v9 = strlen(s) + 1;
    v10 = strlen(s2) + 1;
    s += v9;
    s2 += v10;
    a2 -= v9;
    a4 -= v10;
    if ( !a2 )
      return -(a4 != 0);
    if ( !a4 )
      break;
    *__errno_location() = 0;
    v5 = strcoll(s, s2);
    v8 = v5;
    v6 = v5 == 0;
    v7 = &loc_8060A67;
    if ( !v6 )
      v7 = &loc_8060A72;
    dword_806B220 = (int)v7;
    sub_80618EC();
    if ( *__errno_location() )
    {
      dword_806B2C0 = (int)&loc_8060A93;
      sub_8061526();
    }
  }
  return 1;
}
// 80610EA: using guessed type int sub_80610EA(void);
// 8061526: using guessed type int sub_8061526(void);
// 80618EC: using guessed type int sub_80618EC(void);
// 806B220: using guessed type int dword_806B220;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B374: using guessed type int dword_806B374;

//----- (08060AA0) --------------------------------------------------------
int __cdecl sub_8060AA0(void *s1, size_t n, void *s2, int a4)
{
  char v4; // ST1A_1
  char v5; // ST1B_1
  int v7; // [esp+1Ch] [ebp-Ch]

  if ( n == a4 && !memcmp(s1, s2, n) )
  {
    *__errno_location() = 0;
    v7 = 0;
  }
  else
  {
    v4 = *((_BYTE *)s1 + n);
    v5 = *((_BYTE *)s2 + a4);
    *((_BYTE *)s1 + n) = 0;
    *((_BYTE *)s2 + a4) = 0;
    v7 = sub_80609AD((char *)s1, n + 1, (char *)s2, a4 + 1);
    *((_BYTE *)s1 + n) = v4;
    *((_BYTE *)s2 + a4) = v5;
  }
  return v7;
}

//----- (08060B5B) --------------------------------------------------------
int __cdecl sub_8060B5B(void *s1, size_t n, void *s2, int a4)
{
  if ( n == a4 && !memcmp(s1, s2, n) )
  {
    *__errno_location() = 0;
    dword_806B2C0 = (int)&locret_8060BCD;
    sub_8061526();
  }
  return sub_80609AD((char *)s1, n, (char *)s2, a4);
}
// 8061526: using guessed type int sub_8061526(void);
// 806B2C0: using guessed type int dword_806B2C0;

//----- (08060BCF) --------------------------------------------------------
_DWORD *__userpurge sub_8060BCF@<eax>(_DWORD *a1, int a2, int a3)
{
  *a1 = a2;
  a1[1] = a3;
  return a1;
}

//----- (08060CBB) --------------------------------------------------------
int __cdecl sub_8060CBB(int fd)
{
  return sub_805F1F6(fd, 0, 3);
}

//----- (08060CE0) --------------------------------------------------------
signed __int64 __cdecl sub_8060CE0(unsigned __int64 a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // esi
  signed __int64 result; // rax
  int v5; // ebp
  int v6; // ebp
  int v7; // ST08_4
  unsigned __int64 v8; // rtt
  unsigned int v9; // esi
  unsigned int v10; // edi
  unsigned __int64 v11; // rax

  if ( !a3 )
  {
    if ( a2 > HIDWORD(a1) )
      return (unsigned int)(a1 / a2);
    v3 = a2;
    if ( !a2 )
      v3 = 1 / 0u;
    LODWORD(result) = __PAIR__(HIDWORD(a1) % v3, (unsigned int)a1) / v3;
    HIDWORD(result) = HIDWORD(a1) / v3;
    return result;
  }
  if ( a3 > HIDWORD(a1) )
    return 0LL;
  _BitScanReverse((unsigned int *)&v5, a3);
  v6 = v5 ^ 0x1F;
  if ( !v6 )
  {
    if ( a2 <= (unsigned int)a1 || a3 < HIDWORD(a1) )
      return 1LL;
    return 0LL;
  }
  v7 = (a3 << v6) | (a2 >> (32 - v6));
  LODWORD(v8) = (HIDWORD(a1) << v6) | ((unsigned int)a1 >> (32 - v6));
  HIDWORD(v8) = HIDWORD(a1) >> (32 - v6);
  v9 = v8 % (unsigned int)v7;
  v10 = v8 / (unsigned int)v7;
  v11 = (a2 << v6) * (unsigned __int64)v10;
  if ( v9 < HIDWORD(v11) || (_DWORD)a1 << v6 < (unsigned int)v11 && v9 == (a2 << v6) * (unsigned __int64)v10 >> 32 )
    result = v10 - 1;
  else
    result = v10;
  return result;
}

//----- (08060E00) --------------------------------------------------------
char *__cdecl sub_8060E00(unsigned __int64 a1, __int64 a2)
{
  int v2; // ecx
  char *result; // eax
  int v4; // ebp
  int v5; // ebp
  unsigned __int64 v6; // rax
  unsigned int v7; // edi
  unsigned __int64 v8; // rax
  unsigned int v9; // ecx
  int v10; // ebp
  int v11; // esi
  int v12; // edi
  void *v13; // [esp-1Ch] [ebp-3Ch]
  const void *v14; // [esp-18h] [ebp-38h]
  size_t v15; // [esp-14h] [ebp-34h]
  unsigned int v16; // [esp+0h] [ebp-20h]
  unsigned int v17; // [esp+4h] [ebp-1Ch]
  unsigned __int64 v18; // [esp+8h] [ebp-18h]
  unsigned int v19; // [esp+10h] [ebp-10h]

  v17 = HIDWORD(a1);
  v2 = a1;
  v19 = a1;
  v16 = a2;
  v18 = a1;
  if ( !HIDWORD(a2) )
  {
    if ( (unsigned int)a2 > HIDWORD(a1) )
      return (char *)(a1 % (unsigned int)a2);
    dword_806B2FC = (int)&loc_8060E3B;
    sub_80613B1();
    return (char *)v2;
  }
  if ( HIDWORD(a2) > HIDWORD(a1) )
    return (char *)v2;
  _BitScanReverse((unsigned int *)&v4, HIDWORD(a2));
  v5 = v4 ^ 0x1F;
  if ( v5 )
  {
    v17 = (HIDWORD(a2) << v5) | (v16 >> (32 - v5));
    LODWORD(v18) = v16 << v5;
    HIDWORD(v6) = HIDWORD(a1) >> (32 - v5);
    LODWORD(v6) = (HIDWORD(a1) << v5) | (v19 >> (32 - v5));
    HIDWORD(v18) = v19 << v5;
    v7 = v6 % v17;
    v8 = (v16 << v5) * (unsigned __int64)(unsigned int)(v6 / v17);
    v16 = HIDWORD(v8);
    v9 = v8;
    if ( v7 < HIDWORD(v8) || HIDWORD(v18) < (unsigned int)v8 && v7 == HIDWORD(v8) )
    {
      HIDWORD(v8) = v16;
      HIDWORD(v8) = (v8 - __PAIR__(v17, (unsigned int)v18)) >> 32;
      v9 = v8 - v18;
    }
    result = (char *)(((__PAIR__(v7, HIDWORD(v18)) - __PAIR__(HIDWORD(v8), v9)) >> 32 << (32 - (unsigned __int8)v5)) | ((HIDWORD(v18) - v9) >> v5));
  }
  else if ( v16 <= (unsigned int)v18 || HIDWORD(a2) < HIDWORD(v18) )
  {
    result = (char *)(a1 - a2);
  }
  else
  {
    dword_806B270 = (int)&loc_8060E71;
    sub_80616F6(a1, HIDWORD(a2));
    v10 = HIDWORD(v18);
    memcpy(v13, v14, v15);
    result = (char *)&stru_806AEFC.d_un;
    v11 = ((char *)&stru_806AF04 - (char *)&stru_806AEFC.d_un) >> 2;
    if ( v11 )
    {
      v12 = 0;
      do
        result = (char *)(*((int (__cdecl **)(unsigned int, _DWORD, int))&stru_806AEFC.d_un.d_val + v12++))(
                           v17,
                           v18,
                           v10);
      while ( v11 != v12 );
    }
  }
  return result;
}
// 80616F6: using guessed type int __fastcall sub_80616F6(_DWORD, _DWORD);
// 806AEFC: using guessed type Elf32_Dyn;
// 806AF04: using guessed type Elf32_Dyn stru_806AF04;
// 806B270: using guessed type int dword_806B270;
// 806B2FC: using guessed type int dword_806B2FC;

//----- (08060FEA) --------------------------------------------------------
int __cdecl sub_8060FEA(int a1)
{
  return __cxa_atexit(a1, 0, dword_806B38C);
}
// 8049AC0: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 806B38C: using guessed type int dword_806B38C;

//----- (08061019) --------------------------------------------------------
int __cdecl sub_8061019(int a1, int a2)
{
  return __xstat64(3, a1, a2);
}
// 8049EB0: using guessed type int __cdecl __xstat64(_DWORD, _DWORD, _DWORD);

//----- (08061048) --------------------------------------------------------
int __cdecl sub_8061048(int a1, int a2)
{
  return __fxstat64(3, a1, a2);
}
// 8049A30: using guessed type int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD);

//----- (080610EA) --------------------------------------------------------
#error "80610F0: positive sp value has been found (funcsize=0)"

//----- (08061156) --------------------------------------------------------
#error "806115C: positive sp value has been found (funcsize=0)"

//----- (080611C6) --------------------------------------------------------
#error "80611CC: positive sp value has been found (funcsize=0)"

//----- (08061210) --------------------------------------------------------
#error "8061249: positive sp value has been found (funcsize=18)"

//----- (08061251) --------------------------------------------------------
#error "8061257: positive sp value has been found (funcsize=0)"

//----- (080612C5) --------------------------------------------------------
#error "80612CB: positive sp value has been found (funcsize=0)"

//----- (08061339) --------------------------------------------------------
#error "806133F: positive sp value has been found (funcsize=0)"

//----- (080613B1) --------------------------------------------------------
#error "80613B7: positive sp value has been found (funcsize=0)"

//----- (08061429) --------------------------------------------------------
#error "806142F: positive sp value has been found (funcsize=0)"

//----- (0806146D) --------------------------------------------------------
#error "80614A6: positive sp value has been found (funcsize=18)"

//----- (080614AE) --------------------------------------------------------
#error "80614B4: positive sp value has been found (funcsize=0)"

//----- (08061526) --------------------------------------------------------
#error "806152C: positive sp value has been found (funcsize=0)"

//----- (0806159C) --------------------------------------------------------
#error "80615A2: positive sp value has been found (funcsize=0)"

//----- (08061616) --------------------------------------------------------
#error "806161C: positive sp value has been found (funcsize=0)"

//----- (08061686) --------------------------------------------------------
#error "806168C: positive sp value has been found (funcsize=0)"

//----- (080616F6) --------------------------------------------------------
#error "80616FC: positive sp value has been found (funcsize=0)"

//----- (0806177B) --------------------------------------------------------
#error "8061781: positive sp value has been found (funcsize=0)"

//----- (080617ED) --------------------------------------------------------
#error "80617F3: positive sp value has been found (funcsize=0)"

//----- (0806185D) --------------------------------------------------------
#error "8061863: positive sp value has been found (funcsize=0)"

//----- (080618EC) --------------------------------------------------------
#error "80618F2: positive sp value has been found (funcsize=0)"

//----- (0806195A) --------------------------------------------------------
#error "8061960: positive sp value has been found (funcsize=0)"

//----- (08061970) --------------------------------------------------------
int (**sub_8061970())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_806AEB0;
  v1 = &off_806AEB4 - off_806AEB0;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_806AEB0[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 806AEB0: using guessed type int (*off_806AEB0[2])();
// 806AEB4: using guessed type int (*off_806AEB4)();

//----- (080619D4) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 33 decompilation failure(s) on 372 function(s)"
