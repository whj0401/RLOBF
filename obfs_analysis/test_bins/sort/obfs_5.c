/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8049750();
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// int raise(int sig);
// int dup2(int fd, int fd2);
// int strcmp(const char *s1, const char *s2);
// int putc_unlocked(int c, FILE *stream);
// ssize_t read(int fd, void *buf, size_t nbytes);
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void _exit(int status);
// int __cdecl wcwidth(_DWORD); weak
// void *memmove(void *dest, const void *src, size_t n);
// void free(void *ptr);
// uintmax_t strtoumax(const char *nptr, char **endptr, int base);
// void *memcpy(void *dest, const void *src, size_t n);
// int mbsinit(const mbstate_t *ps);
// int ferror(FILE *stream);
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// int fclose(FILE *stream);
// int getc_unlocked(FILE *stream);
// int __stdcall fseeko64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// __sighandler_t signal(int sig, __sighandler_t handler);
// int __cdecl __sched_cpucount(_DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// double __cdecl strtold(_DWORD, _DWORD); weak
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// int fputc_unlocked(int c, FILE *stream);
// int __cdecl getrlimit64(_DWORD, _DWORD); weak
// int execlp(const char *file, const char *arg, ...);
// int sysconf(int name);
// __uid_t getuid(void);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// int unlink(const char *name);
// int sigismember(const sigset_t *set, int signo);
// int iswcntrl(wint_t wc);
// char *textdomain(const char *domainname);
// int iswprint(wint_t wc);
// int __cdecl fopen64(_DWORD, _DWORD); weak
// int ferror_unlocked(FILE *stream);
// int __cdecl mkostemp64(_DWORD, _DWORD); weak
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD); weak
// size_t __ctype_get_mb_cur_max(void);
// __pid_t waitpid(__pid_t pid, int *stat_loc, int options);
// int pthread_sigmask(int how, const __sigset_t *newmask, __sigset_t *oldmask);
// char *strcpy(char *dest, const char *src);
// size_t __fpending(FILE *fp);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// __pid_t getpid(void);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// int pthread_cond_signal(pthread_cond_t *cond);
// void error(int status, int errnum, const char *format, ...);
// size_t fread_unlocked(void *ptr, size_t size, size_t n, FILE *stream);
// int strcoll(const char *s1, const char *s2);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int sysinfo(struct sysinfo *info);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// char *strchr(const char *s, int c);
// int fscanf(FILE *stream, const char *format, ...);
// size_t strlen(const char *s);
// int fprintf(FILE *stream, const char *format, ...);
// ssize_t write(int fd, const void *buf, size_t n);
// int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *cond_attr);
// int __cdecl open64(_DWORD, _DWORD); weak
// int fcntl(int fd, int cmd, ...);
// int sigaddset(sigset_t *set, int signo);
// size_t strxfrm(char *dest, const char *src, size_t n);
// int setvbuf(FILE *stream, char *buf, int modes, size_t n);
// __gid_t getgid(void);
// void *memset(void *s, int c, size_t n);
// int ungetc(int c, FILE *stream);
// int *__errno_location(void);
// void *memchr(const void *s, int c, size_t n);
// int fileno(FILE *stream);
// int fgetc(FILE *stream);
// int pipe(int pipedes[2]);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// int __cdecl ftruncate64(_DWORD, _DWORD, _DWORD); weak
// __pid_t fork(void);
// int sigemptyset(sigset_t *set);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// int toupper(int c);
// void clearerr_unlocked(FILE *stream);
// char *strrchr(const char *s, int c);
// int pthread_join(pthread_t th, void **thread_return);
// struct lconv *localeconv(void);
// __pid_t getppid(void);
// int __cdecl explicit_bzero(_DWORD, _DWORD); weak
// int __cdecl pipe2(_DWORD); weak
// int __cdecl euidaccess(_DWORD, _DWORD); weak
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int nanosleep(const struct timespec *requested_time, struct timespec *remaining);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// char *bindtextdomain(const char *domainname, const char *dirname);
// int __stdcall posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl sched_getaffinity(_DWORD, _DWORD, _DWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// int feof_unlocked(FILE *stream);
// void abort(void);
// int __cdecl __xstat64(_DWORD, _DWORD, _DWORD); weak
// int strtol(const char *nptr, char **endptr, int base);
// char *ngettext(const char *msgid1, const char *msgid2, unsigned int n);
// int close(int fd);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// void *calloc(size_t nmemb, size_t size);
// int putchar_unlocked(int c);
// int _gmon_start__(void); weak
void sub_8049F73();
void sub_8049F90();
int sub_8049FA0();
int sub_804A010();
int sub_804A030();
void sub_804A08F();
void sub_804A0AA();
int sub_804A0BA();
void sub_804A19C();
void sub_804A1B7();
int sub_804A1C7();
void sub_804A2C5();
void sub_804A2E0();
int sub_804A2F0();
int nullsub_3(void); // weak
int sub_804A34E();
void sub_804A3EE();
void sub_804A409();
signed int sub_804A419();
void sub_804A4FB();
void sub_804A516();
int sub_804A526();
void sub_804A608();
void sub_804A623();
int sub_804A633();
// int __usercall sub_804A69A@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
int sub_804A6D6();
void sub_804A74A();
void sub_804A765();
void sub_804A870();
void sub_804A88B();
int sub_804A89B();
void sub_804A97D();
void sub_804A998();
int __fastcall sub_804A9A8(int a1, int a2);
int nullsub_5(); // weak
// int __usercall sub_804AA1F@<eax>(int a1@<ecx>, int a2@<ebp>);
void sub_804AAD8();
void sub_804AAF3();
int sub_804AB03();
void sub_804ABE5();
void sub_804AC00();
int sub_804AC10();
void sub_804AD09();
void sub_804AD24();
int sub_804AD34();
int nullsub_6(void); // weak
int sub_804AD92();
void sub_804AE32();
void sub_804AE4D();
int sub_804AE5D();
void sub_804AF7C();
void sub_804AF97();
int sub_804AFA7();
int __cdecl sub_804B09A(int a1);
int __cdecl sub_804B0AD(unsigned __int8 a1);
int __cdecl sub_804B0BF(unsigned __int8 a1);
int __cdecl sub_804B0FE(unsigned __int64 a1);
int sub_804B144();
int sub_804B16F();
// int __usercall sub_804B19A@<eax>(int a1@<ebx>, char *a2);
void __cdecl __noreturn sub_804B399(int a1, const char *a2);
void __cdecl __noreturn sub_804B47B(int a1, int a2);
void __cdecl __noreturn sub_804B4DD(int status); // idb
int __cdecl sub_804B799(int a1);
int __cdecl sub_804B7CE(unsigned __int8 *a1);
bool __cdecl sub_804B800(int a1, int a2);
int __cdecl sub_804B837(int a1, unsigned int a2);
int __cdecl sub_804B886(__pid_t pid); // idb
int __cdecl sub_804B9AF(int a1);
signed int __cdecl sub_804BA40(int a1);
int __cdecl sub_804BAB6(__pid_t pid); // idb
int sub_804BAD8();
int sub_804BAFB();
int sub_804BB14();
int __fastcall sub_804BB43(int a1, int a2);
void __noreturn sub_804BB94();
_DWORD __cdecl sub_804BBCE(_DWORD, _DWORD); // weak
int __cdecl sub_804BC11(void *src, size_t n, int); // idb
FILE *__cdecl sub_804BE65(char *s1, char *modes);
FILE *__cdecl sub_804BFBA(char *s1, char *modes);
void __cdecl sub_804BFFB(FILE *stream, int a2);
int __cdecl sub_804C0DA(int fd, int fd2); // idb
int __cdecl sub_804C117(int pipedes[2], int); // idb
// int __usercall sub_804C2E9@<eax>(int a1@<ebx>, FILE **a2, unsigned __int8 a3);
// int __usercall sub_804C46E@<eax>(int a1@<ebx>, FILE **a2);
FILE *__cdecl sub_804C489(int a1);
_DWORD __cdecl sub_804C693(_DWORD); // weak
void __cdecl sub_804C704(char *name);
int compar(const void *, const void *); // idb
void sub_804C88F();
int __cdecl sub_804CAD7(int a1, char a2, char *a3);
int __cdecl sub_804CD53(int, int, char *nptr); // idb
int __cdecl sub_804D046(int a1, char a2, char *nptr);
int sub_804D114();
_DWORD __cdecl sub_804D395(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_804D595(int, int, size_t size); // idb
int __cdecl sub_804D637(_DWORD *a1);
int __cdecl sub_804D662(int a1, int *a2);
_DWORD __cdecl sub_804D7F1(_DWORD, _DWORD); // weak
int __cdecl sub_804D9F4(int, FILE *stream, int); // idb
int __cdecl sub_804DEEC(char **a1);
int __cdecl sub_804DFE3(_BYTE *a1);
int __cdecl sub_804E08E(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_804E171(unsigned __int8 *a1, unsigned __int8 *a2);
void __cdecl __noreturn sub_804E200(int a1, int a2);
int sub_804E2A3(); // weak
signed int __cdecl sub_804E2A5(int a1, int a2);
int __cdecl sub_804E418(unsigned __int8 *a1, unsigned __int8 **a2);
// unsigned int __usercall sub_804E54A@<eax>(int a1@<ebx>, int a2);
size_t __cdecl sub_804E653(char *dest, char *src, size_t n);
int __cdecl sub_804E778(char *src, size_t n); // idb
// void __usercall __noreturn sub_804EDAB(int a1@<ebx>, char *a2, int a3);
int __cdecl sub_804EE9A(_BYTE *a1);
// void __usercall __noreturn sub_804EEDF(int a1@<ebx>, int *a2, int a3);
// void __usercall __noreturn sub_804F132(int a1@<ebx>, int *a2);
_DWORD __cdecl sub_804F1CB(_DWORD); // weak
_DWORD __cdecl sub_804F28C(_DWORD, _DWORD); // weak
_DWORD __cdecl sub_804F3BB(_DWORD, _DWORD); // weak
_DWORD __cdecl sub_804FC84(_DWORD, _DWORD); // weak
_DWORD __cdecl sub_8050A85(_DWORD, _DWORD); // weak
// unsigned int __usercall sub_8050C43@<eax>(int a1@<ebx>, int a2, FILE *stream, int a4);
_DWORD __cdecl sub_8050D89(_DWORD, _DWORD); // weak
_DWORD __cdecl sub_8051197(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_80512B2(int, int, int, FILE *stream, int, int); // idb
int __cdecl sub_8051DED(int, int, int, FILE *stream, int); // idb
_DWORD sub_8051F00(); // weak
_DWORD __cdecl sub_805203A(_DWORD, _DWORD, _DWORD, _DWORD); // weak
// pthread_mutex_t *__usercall sub_8052345@<eax>(double a1@<st0>, unsigned int a2, int a3, int a4);
// int __usercall sub_805247F@<eax>(double a1@<st0>, _DWORD *a2, pthread_mutex_t *a3, int a4, unsigned int a5, int a6, char a7);
_BOOL4 __cdecl sub_805267C(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80526FB(pthread_mutex_t *a1);
int __cdecl sub_8052711(pthread_mutex_t *a1);
int __cdecl sub_805276C(int a1, int a2);
int __cdecl sub_80527BA(int a1, int a2);
void __cdecl __noreturn sub_8052807(int a1);
int sub_8052889(); // weak
// unsigned int __usercall sub_80528AE@<eax>(int a1@<ebx>, int a2, FILE *stream, int a4);
int __cdecl sub_805296E(int, int, FILE *stream, int); // idb
int __cdecl sub_8052EBA(int a1, int a2);
int __cdecl sub_8052F7B(int a1, _DWORD *a2);
void __cdecl __noreturn sub_8052FF4(int a1);
void *start_routine(void *); // idb
_DWORD __cdecl sub_805311D(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_805318B(pthread_attr_t *attr, void *(*start_routine)(void *), void *arg, int, int, int); // idb
// int __usercall sub_8053386@<eax>(int a1@<ebx>, double st7_0@<st0>, int a2, int a3, int a4, char *s1);
unsigned int __cdecl sub_8053677(int a1, unsigned int a2);
void __cdecl sub_8053712(int a1);
// int __usercall sub_8053788@<eax>(FILE *a1@<ebx>, double st7_0@<st0>, int a2, int a3, int a4, char *s1);
// unsigned int __usercall sub_8053C25@<eax>(FILE *a1@<ebx>, double a2@<st0>, char **a3, int a4, char *a5, unsigned int a6);
_DWORD *__cdecl sub_80540AF(void *src);
int __cdecl sub_8054115(int, char *msgid); // idb
int __cdecl sub_8054188(int a1);
int sub_80541B9(void); // weak
// int __usercall sub_80542DC@<eax>(double a1@<st0>, char *nptr, int a3, char *msgid);
// int __usercall sub_8054402@<eax>(int a1@<edx>, int a2@<ecx>, int sig);
_DWORD __cdecl sub_805442D(_DWORD, _DWORD, _DWORD); // weak
void *__cdecl sub_8054563(void *s);
int __cdecl main(int, char **, char **); // idb
int __cdecl sub_8054805(int signo, struct sigaction *oact, struct option *longopts, int *longind, int, int, int, int, int, int, char, char, char, void *src, int, int, char *, int, size_t nmemb, void *ptr, char *, char *s1, int, int, int, int, int, int, int, FILE *stream, int, int, int, int, int, char, int, int, int, int, int, int, int, int, int, int s, int, int, int, int, int, char, char, char, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int); // idb
void __noreturn sub_8055E00();
int __cdecl sub_8055E14(char *s, int, int, size_t); // idb
void __cdecl sub_8055FA7(char *a1, char *a2, int a3);
int __cdecl sub_805602A(int, int, size_t n); // idb
int __cdecl sub_805618B(void *s1, char *s, int, size_t n, size_t, int); // idb
int sub_80562CB(void); // weak
_DWORD __cdecl sub_80563D9(_DWORD); // weak
_DWORD *__cdecl sub_805644A(_DWORD *a1, int a2);
_DWORD *__cdecl sub_8056457(int *a1, _DWORD *a2);
int __cdecl sub_8056818(void *src, size_t, int); // idb
int *__cdecl sub_8056A87(int a1, unsigned int a2, int *a3);
int __cdecl sub_8057793(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_80577F4(FILE *stream); // idb
int sub_8057867(); // weak
_DWORD __cdecl sub_8057971(_DWORD); // weak
signed int __cdecl sub_80579E3(int a1, unsigned int a2, int a3, unsigned int a4);
int __cdecl sub_8057BE8(char *s1, char *s2); // idb
int __cdecl sub_8057E90(int category); // idb
int __cdecl sub_8057F07(int a1);
int __cdecl sub_8057F12(int a1);
int __cdecl sub_8057F1D(int a1);
// unsigned int __usercall sub_8057F28@<eax>(int a1@<edx>, int a2@<ecx>, int a3);
int __cdecl sub_8058148(_DWORD, _DWORD); // weak
void __cdecl __noreturn sub_8058506(_DWORD); // weak
unsigned int __cdecl sub_80585D2(int a1, unsigned int a2);
bool __cdecl sub_80585FD(int a1, int a2);
signed int __cdecl sub_805860B(int a1);
int __cdecl sub_80586D9(unsigned int a1, int a2);
size_t *__cdecl sub_8058786(unsigned int a1, void *a2, unsigned int (__cdecl *a3)(int a1, unsigned int a2), bool (__cdecl *a4)(int a1, int a2), size_t a5);
// int __usercall sub_8058A81@<eax>(int a1@<edx>, int a2@<ecx>, int a3);
int __cdecl sub_8058AD5(int a1, _DWORD *a2);
int __cdecl sub_8058B08(int a1, int a2, _DWORD *a3, char a4);
signed int __cdecl sub_8058C70(int a1, int a2, char a3);
signed int __cdecl sub_8058E1A(int a1, unsigned int a2);
_DWORD __cdecl sub_8058FEF(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl sub_805931F(_DWORD, _DWORD); // weak
void sub_8059386();
int __cdecl sub_80593A9(int a1, int a2);
_DWORD *__cdecl sub_8059641(int a1, unsigned int a2);
int sub_80596DB();
void __cdecl sub_80596E5(void *ptr);
int __cdecl sub_8059705(int a1, int a2);
int __cdecl sub_805979E(_DWORD *a1);
_DWORD __cdecl sub_805982A(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_8059967(int a1, unsigned int a2, int (__cdecl *a3)(int, int));
_DWORD __cdecl sub_8059A3C(_DWORD, _DWORD); // weak
int __cdecl sub_8059B68(unsigned int a1, int a2);
_DWORD __cdecl sub_8059BD6(_DWORD, _DWORD, _DWORD); // weak
// int __usercall __noreturn sub_8059CC2@<eax>(int a1@<ebx>, char *a2, int a3, char a4);
int sub_8059F8C(); // weak
int sub_8059F8E();
signed int __cdecl sub_8059FF9(int a1);
int __cdecl sub_805A088(char *nptr); // idb
unsigned int __cdecl sub_805A1B8(int a1);
long double sub_805A297();
double sub_805A354(void); // weak
int __cdecl sub_805A48B(int pipedes[2], int); // idb
int sub_805A70F();
char *__cdecl sub_805A786(char *s);
int __cdecl sub_805A8EB(int a1, unsigned __int8 a2, char a3);
int *__cdecl sub_805A9BE(int *a1, int a2, int a3);
// _DWORD *__userpurge sub_805A9FF@<eax>(_DWORD *a1, int a2);
int __cdecl sub_805AAA1(char *msgid, int); // idb
// unsigned int __usercall sub_805AB8E@<eax>(size_t a1@<ebx>, int a2, unsigned int a3, char *a4, size_t a5, signed int a6, int a7, int a8, char *a9, char *a10);
void *__cdecl sub_805BD4F(signed int a1, char *a2, size_t a3, int a4);
void *__cdecl sub_805BFB8(signed int a1, char *a2);
void *__cdecl sub_805BFE2(signed int a1, char *a2, size_t a3);
void *__cdecl sub_805C058(signed int a1, int a2, char *a3);
void *__cdecl sub_805C096(signed int a1, int a2, char *a3, size_t a4);
void *__cdecl sub_805C0D3(int a1, char *a2);
void *__cdecl sub_805C12E(char *a1, size_t a2, unsigned __int8 a3);
_DWORD __cdecl sub_805C1E8(_DWORD, _DWORD); // weak
int __cdecl sub_805C236(int a1);
int __cdecl sub_805C2D5(int a1, int a2);
int sub_805C3AA(); // weak
void *__cdecl sub_805C3CF(signed int a1, int a2, int a3, char *a4);
void *__cdecl sub_805C40F(signed int a1, int a2, int a3, char *a4, size_t a5);
void *__cdecl sub_805C5AD(signed int a1, char *a2, size_t a3);
void *__cdecl sub_805C608(signed int a1, char *a2);
void *__cdecl sub_805C62A(char *a1);
void __cdecl __noreturn sub_805C645(char *a1);
_DWORD *__cdecl sub_805C6B6(int a1, int a2);
size_t __cdecl sub_805C6FB(int a1, int a2, size_t nbytes);
char *__cdecl sub_805C960(int a1, size_t n);
int __cdecl sub_805CA6C(int, void *ptr, size_t n); // idb
// int __usercall sub_805CB37@<eax>(int a1@<ebx>, int a2, void *dest, size_t n);
// int __usercall sub_805CCBF@<eax>(int a1@<ebx>, int a2, void *ptr, size_t n);
int __cdecl sub_805CD07(void *ptr); // idb
int __cdecl sub_805CD66(int a1);
int __cdecl sub_805CD7D(int a1, __int16 a2);
_DWORD __cdecl sub_805CDBE(_DWORD); // weak
_DWORD __cdecl sub_805D414(_DWORD); // weak
int __cdecl sub_805D922(_DWORD *a1);
_DWORD *__cdecl sub_805DAFA(_DWORD *a1);
int __cdecl sub_805DCDF(FILE *stream, int); // idb
int __cdecl sub_805E07E(int a1, int a2);
_DWORD __cdecl sub_805E0A7(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl sub_805E261(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_805E787(int a1, int a2, int a3, int a4);
int __cdecl sub_805E7BF(int fd); // idb
int __cdecl sub_805E809(FILE *stream, int, int, int, int, int); // idb
int __cdecl sub_805EEC9(FILE *stream, int, int, int, int); // idb
int sub_805EF3F(FILE *stream, int a2, int a3, int a4, ...);
void *__cdecl sub_805EFEF(unsigned int a1, unsigned int a2);
void *__cdecl sub_805F062(void *ptr, int a2, int a3);
void *__cdecl sub_805F115(size_t size);
void *__cdecl sub_805F128(size_t size);
void *__cdecl sub_805F1A5(void *ptr, size_t size);
void *__cdecl sub_805F27A(size_t nmemb, size_t size);
void *__cdecl sub_805F2B7(void *src, size_t n);
void __noreturn sub_805F305();
void __cdecl sub_805F33E(int errnum, int a2, int a3, int a4, int a5);
int __cdecl sub_805F4A8(void *a1, size_t n, void *s2, int a4);
int __cdecl sub_805F5BF(struct timespec *remaining); // idb
signed int __cdecl sub_805F634(unsigned int *a1, unsigned int a2);
int __cdecl sub_805F6CD(int a1, int a2, int a3);
int __cdecl sub_805F703(char *nptr, int, int base, int, char *s); // idb
void __cdecl sub_805FBD5(int a1, int a2, int a3, int a4, int a5, int status);
void __cdecl __noreturn sub_805FCCC(int a1, int a2, char a3, int a4, int a5);
signed int __cdecl sub_805FD1F(int a1, int a2);
int __cdecl sub_805FDD7(int a1, int a2, int a3);
int __cdecl sub_805FE21(char *nptr, int, int base, int, char *s); // idb
int __cdecl sub_80602BC(FILE *stream); // idb
int __cdecl sub_806038F(int fd, int cmd, char); // idb
int __cdecl sub_8060535(_DWORD *a1);
int __cdecl sub_806056E(FILE *fp); // idb
int __cdecl sub_80605AE(_DWORD *a1, int a2, int a3, int a4);
size_t __cdecl sub_8060706(wchar_t *pwc, char *s, size_t n, mbstate_t *p);
int __cdecl sub_80607A1(int a1, int a2);
int __cdecl sub_80607F4(int a1, int a2);
_DWORD __cdecl sub_8060956(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_8060AA5(int a1, int a2);
int __cdecl sub_8060CE1(int a1, unsigned int a2);
int __cdecl sub_8060F47(int a1, char a2);
signed int __cdecl sub_80610B0(signed int a1);
int __cdecl sub_80610EC(signed int a1);
int __cdecl sub_8061191(int a1);
_BOOL4 __cdecl sub_8061250(signed int a1);
int __cdecl sub_80612BC(int a1);
int __cdecl sub_806133B(int a1);
// int __usercall sub_806134D@<eax>(int edx0@<edx>, int ecx0@<ecx>, int a1, int a2);
int __cdecl sub_80613CB(FILE *fp); // idb
// _DWORD *__userpurge sub_80614A9@<eax>(int a1@<edx>, int a2@<ecx>, _DWORD *a3, double a4);
int __cdecl sub_8061654(int fd, int); // idb
int __cdecl sub_80616B1(int fd, int); // idb
FILE *__cdecl sub_80616E8(int a1, char *modes);
int sub_80617BE(void); // weak
int __cdecl sub_80617EF(void *src, size_t n, int); // idb
int sub_8061D86(void); // weak
int __cdecl sub_8061E76(char *s, int, char *s2, int); // idb
int __cdecl sub_8061F4E(void *s1, size_t n, void *s2, int); // idb
int __cdecl sub_8062045(void *s1, size_t n, void *s2, int); // idb
// _DWORD *__userpurge sub_80620ED@<eax>(_DWORD *a1, int a2, int a3);
int __cdecl sub_80621F7(int fd); // idb
_DWORD __cdecl sub_806221C(__int64, _DWORD, _DWORD); // weak
int __cdecl sub_806238C(unsigned __int64 a1, unsigned int a2, unsigned int a3);
int __cdecl sub_80625AD(int a1);
int __cdecl sub_80625E8(int a1, int a2);
int __cdecl sub_8062617(int a1, int a2);
int sub_80626B4(void); // weak
// int __usercall sub_8062753@<eax>(double@<st0>); weak
int __fastcall sub_80628B5(_DWORD, _DWORD); // weak
int __stdcall sub_8062925(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __fastcall sub_80629B0(_DWORD, _DWORD);
int __stdcall sub_8062A28(_DWORD); // weak
int __cdecl sub_8062A98();
int __stdcall sub_8062B10(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_8062B84(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __fastcall sub_8062BFE(_DWORD, _DWORD); // weak
int __stdcall sub_8062C70(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (**sub_8062C80())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN locret_804A9B7; // weak
_UNKNOWN loc_804B28A; // weak
_UNKNOWN loc_804B293; // weak
_UNKNOWN loc_804B35B; // weak
_UNKNOWN loc_804BB53; // weak
_UNKNOWN loc_804BB88; // weak
_UNKNOWN loc_804BF12; // weak
_UNKNOWN loc_804BF8C; // weak
_UNKNOWN loc_804C02E; // weak
_UNKNOWN loc_804C054; // weak
_UNKNOWN loc_804C0BD; // weak
_UNKNOWN locret_804C0D8; // weak
_UNKNOWN loc_804C447; // weak
_UNKNOWN loc_804C465; // weak
_UNKNOWN loc_804C511; // weak
_UNKNOWN loc_804C516; // weak
_UNKNOWN loc_804C532; // weak
_UNKNOWN loc_804C773; // weak
_UNKNOWN loc_804C784; // weak
_UNKNOWN loc_804CA8C; // weak
_UNKNOWN loc_804CAA3; // weak
_UNKNOWN loc_804CD47; // weak
_UNKNOWN loc_804D0EB; // weak
_UNKNOWN loc_804D10F; // weak
_UNKNOWN loc_804D7CB; // weak
_UNKNOWN loc_804DF6E; // weak
_UNKNOWN loc_804DF7F; // weak
_UNKNOWN loc_804E09A; // weak
_UNKNOWN loc_804E0EF; // weak
_UNKNOWN loc_804E2FE; // weak
_UNKNOWN loc_804E305; // weak
_UNKNOWN loc_804E342; // weak
_UNKNOWN loc_804E35E; // weak
_UNKNOWN locret_804E416; // weak
_UNKNOWN loc_804E5FE; // weak
_UNKNOWN loc_804F0E5; // weak
_UNKNOWN loc_8050CEE; // weak
_UNKNOWN loc_8050D09; // weak
_UNKNOWN loc_8052514; // weak
_UNKNOWN loc_805281D; // weak
_UNKNOWN loc_8052859; // weak
_UNKNOWN locret_805296C; // weak
_UNKNOWN loc_8053429; // weak
_UNKNOWN loc_8053460; // weak
_UNKNOWN loc_805346C; // weak
_UNKNOWN loc_805365E; // weak
_UNKNOWN loc_8053D24; // weak
_UNKNOWN loc_8053D6E; // weak
_UNKNOWN loc_8054053; // weak
_UNKNOWN loc_80540D4; // weak
_UNKNOWN loc_8054101; // weak
_UNKNOWN loc_8054383; // weak
_UNKNOWN loc_805439A; // weak
_UNKNOWN loc_80543F8; // weak
_UNKNOWN loc_80560B9; // weak
_UNKNOWN loc_80560FF; // weak
_UNKNOWN locret_8056270; // weak
_UNKNOWN loc_8057752; // weak
_UNKNOWN locret_8057BE6; // weak
_UNKNOWN loc_8057C6B; // weak
_UNKNOWN loc_8057C75; // weak
_UNKNOWN loc_8057EFD; // weak
_UNKNOWN loc_8057F01; // weak
_UNKNOWN loc_8057F61; // weak
_UNKNOWN loc_8057F91; // weak
_UNKNOWN locret_80586D7; // weak
_UNKNOWN loc_8058AAA; // weak
_UNKNOWN loc_8058AC1; // weak
_UNKNOWN loc_8058D87; // weak
_UNKNOWN loc_8058DD1; // weak
_UNKNOWN locret_805937D; // weak
_UNKNOWN loc_8059622; // weak
_UNKNOWN locret_805963F; // weak
_UNKNOWN loc_80596D0; // weak
_UNKNOWN loc_80599EA; // weak
_UNKNOWN loc_8059E7D; // weak
_UNKNOWN loc_8059E82; // weak
_UNKNOWN loc_8059F62; // weak
_UNKNOWN loc_8059F87; // weak
_UNKNOWN loc_805A046; // weak
_UNKNOWN loc_805A04B; // weak
_UNKNOWN loc_805A0B4; // weak
_UNKNOWN loc_805A0BC; // weak
_UNKNOWN loc_805A23B; // weak
_UNKNOWN loc_805A242; // weak
_UNKNOWN locret_805A295; // weak
_UNKNOWN locret_805A70D; // weak
_UNKNOWN loc_805A754; // weak
_UNKNOWN loc_805A781; // weak
_UNKNOWN loc_805A91E; // weak
_UNKNOWN loc_805A923; // weak
_UNKNOWN loc_805AD87; // weak
_UNKNOWN loc_805ADE0; // weak
_UNKNOWN loc_805AE5E; // weak
_UNKNOWN loc_805AF6E; // weak
_UNKNOWN loc_805AF9C; // weak
_UNKNOWN loc_805B15A; // weak
_UNKNOWN loc_805B17C; // weak
_UNKNOWN loc_805B193; // weak
_UNKNOWN loc_805B221; // weak
_UNKNOWN loc_805B23E; // weak
_UNKNOWN loc_805B27F; // weak
_UNKNOWN loc_805B292; // weak
_UNKNOWN loc_805B4EC; // weak
_UNKNOWN loc_805B51A; // weak
_UNKNOWN loc_805B57D; // weak
_UNKNOWN loc_805B5E6; // weak
_UNKNOWN loc_805B605; // weak
_UNKNOWN loc_805B620; // weak
_UNKNOWN loc_805B6A4; // weak
_UNKNOWN loc_805B6DF; // weak
_UNKNOWN loc_805B71B; // weak
_UNKNOWN loc_805B74A; // weak
_UNKNOWN loc_805B74F; // weak
_UNKNOWN loc_805B834; // weak
_UNKNOWN loc_805B87C; // weak
_UNKNOWN loc_805B88D; // weak
_UNKNOWN loc_805B8BB; // weak
_UNKNOWN loc_805B93E; // weak
_UNKNOWN loc_805B968; // weak
_UNKNOWN loc_805B994; // weak
_UNKNOWN loc_805B9AC; // weak
_UNKNOWN loc_805CC1B; // weak
_UNKNOWN loc_805CC6E; // weak
_UNKNOWN loc_805CC87; // weak
_UNKNOWN loc_805CC96; // weak
_UNKNOWN loc_805F187; // weak
_UNKNOWN loc_805F1A0; // weak
_UNKNOWN loc_805F203; // weak
_UNKNOWN loc_805F229; // weak
_UNKNOWN loc_805F4E8; // weak
_UNKNOWN loc_805F590; // weak
_UNKNOWN loc_805FF81; // weak
_UNKNOWN loc_805FFBF; // weak
_UNKNOWN loc_80600B9; // weak
_UNKNOWN loc_8060274; // weak
_UNKNOWN locret_80602BA; // weak
_UNKNOWN loc_806065B; // weak
_UNKNOWN loc_806073A; // weak
_UNKNOWN loc_8060766; // weak
_UNKNOWN locret_80607F2; // weak
_UNKNOWN loc_8060B70; // weak
_UNKNOWN loc_8060B77; // weak
_UNKNOWN loc_8060C12; // weak
_UNKNOWN loc_8060C64; // weak
_UNKNOWN loc_8061125; // weak
_UNKNOWN loc_80611C0; // weak
_UNKNOWN loc_80612EA; // weak
_UNKNOWN loc_8061378; // weak
_UNKNOWN loc_806137F; // weak
_UNKNOWN loc_8061486; // weak
_UNKNOWN loc_8061551; // weak
_UNKNOWN loc_8061F92; // weak
_UNKNOWN loc_8061FA9; // weak
_UNKNOWN loc_80624B7; // weak
_UNKNOWN loc_8062505; // weak
char locale = '\0'; // idb
struct option longopts = { "ignore-leading-blanks", 0, NULL, 98 }; // idb
char byte_8064528[256] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x06',
  '\0',
  '\x03',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0',
  '\x04',
  '\0',
  '\0',
  '\0',
  '\0',
  '\b',
  '\a',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_80651F8; // weak
_UNKNOWN unk_806540D; // weak
_UNKNOWN unk_8066368; // weak
_UNKNOWN unk_806636B; // weak
_UNKNOWN unk_8067374; // weak
_UNKNOWN unk_8067377; // weak
int (*off_806BEC8[2])() = { &sub_804A030, &sub_804A010 }; // weak
int (*off_806BECC)() = &sub_804A010; // weak
int (*dword_806C008)(void) = NULL; // weak
int dword_806C220 = 0; // weak
int dword_806C234 = 0; // weak
int dword_806C248 = 0; // weak
int dword_806C25C = 0; // weak
int dword_806C270 = 0; // weak
int dword_806C284 = 0; // weak
int dword_806C298 = 0; // weak
int dword_806C2AC = 0; // weak
int dword_806C2D8 = 0; // weak
int dword_806C2EC = 0; // weak
int dword_806C304 = 0; // weak
char byte_806C320 = '\n'; // weak
char *off_806C340 = "APR"; // weak
int dword_806C344[] = { 4 }; // weak
int dword_806C3A4 = 128; // weak
int dword_806C3A8 = 16; // idb
int *off_806C3AC = &dword_806CF56; // weak
int status = 1; // idb
int dword_806C3E0 = 1; // weak
int dword_806C3E4 = 256; // weak
void *off_806C3E8 = &unk_806D076; // weak
int *off_806C3EC = &dword_806C3E4; // weak
_UNKNOWN unk_806C400; // weak
_UNKNOWN unk_806C420; // weak
_UNKNOWN unk_806C423; // weak
_UNKNOWN unk_806C428; // weak
_UNKNOWN unk_806C42B; // weak
_UNKNOWN unk_806C434; // weak
_UNKNOWN unk_806C437; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int program_invocation_name; // weak
FILE *stdin; // idb
FILE *stdout; // idb
int (*obstack_alloc_failed_handler)(void); // weak
char byte_806C4AC; // weak
_UNKNOWN unk_806C4B0; // weak
char byte_806C73A; // weak
_UNKNOWN unk_806C818; // weak
_UNKNOWN unk_806C9CC; // weak
int dword_806CA96; // weak
int dword_806CA9A; // weak
char byte_806CA9F; // weak
int dword_806CAA2; // weak
int dword_806CAA6; // weak
int dword_806CAAA; // weak
int dword_806CAAE; // weak
char byte_806CAB6[256]; // idb
char byte_806CDB6[256]; // idb
char byte_806CEC8; // weak
char byte_806CEC9; // weak
int dword_806CECA; // weak
char *arg; // idb
char byte_806CED2; // weak
__sigset_t set; // idb
int dword_806CF56; // weak
int dword_806CF5A; // weak
int dword_806CF5E; // weak
_UNKNOWN unk_806CF76; // weak
int dword_806D022; // weak
int dword_806D026; // weak
int dword_806D036; // weak
int dword_806D03A; // weak
int dword_806D03E; // weak
int dword_806D042; // weak
int dword_806D046; // weak
int dword_806D04A; // weak
int dword_806D04E; // weak
int dword_806D052; // weak
int dword_806D056; // weak
int dword_806D05A; // weak
int dword_806D05E; // weak
int dword_806D062; // weak
_UNKNOWN unk_806D076; // weak
int dword_806D176; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (0804972C) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 8049F30: using guessed type int _gmon_start__(void);

//----- (08049750) --------------------------------------------------------
int sub_8049750()
{
  return dword_806C008();
}
// 806C008: using guessed type int (*dword_806C008)(void);

//----- (08049F40) --------------------------------------------------------
#error "8049F43: positive sp value has been found (funcsize=2)"

//----- (08049F73) --------------------------------------------------------
void sub_8049F73()
{
  ;
}

//----- (08049F90) --------------------------------------------------------
void sub_8049F90()
{
  ;
}

//----- (08049FA0) --------------------------------------------------------
int sub_8049FA0()
{
  int result; // eax

  result = &unk_806C437 - &unk_806C434;
  if ( (unsigned int)(&unk_806C437 - &unk_806C434) > 6 )
    result = 0;
  return result;
}
// 8049FA0: could not find valid save-restore pair for ebp

//----- (0804A010) --------------------------------------------------------
int sub_804A010()
{
  int result; // eax

  if ( !byte_806C4AC )
  {
    result = sub_8049FA0();
    byte_806C4AC = 1;
  }
  return result;
}
// 804A010: could not find valid save-restore pair for ebp
// 806C4AC: using guessed type char byte_806C4AC;

//----- (0804A030) --------------------------------------------------------
int sub_804A030()
{
  return 0;
}
// 804A030: could not find valid save-restore pair for ebp

//----- (0804A08F) --------------------------------------------------------
void sub_804A08F()
{
  ;
}

//----- (0804A0AA) --------------------------------------------------------
void sub_804A0AA()
{
  ;
}

//----- (0804A0BA) --------------------------------------------------------
int sub_804A0BA()
{
  int result; // eax

  result = &unk_806C4B0 - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_806C4B0 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 804A0BA: could not find valid save-restore pair for ebp
// 806C440: using guessed type int program_invocation_short_name;

//----- (0804A19C) --------------------------------------------------------
void sub_804A19C()
{
  ;
}

//----- (0804A1B7) --------------------------------------------------------
void sub_804A1B7()
{
  ;
}

//----- (0804A1C7) --------------------------------------------------------
int sub_804A1C7()
{
  int result; // eax

  result = &unk_806C423 - &unk_806C420;
  if ( (unsigned int)(&unk_806C423 - &unk_806C420) > 6 )
    result = 0;
  return result;
}
// 804A1C7: could not find valid save-restore pair for ebp

//----- (0804A2C5) --------------------------------------------------------
void sub_804A2C5()
{
  ;
}

//----- (0804A2E0) --------------------------------------------------------
void sub_804A2E0()
{
  ;
}

//----- (0804A2F0) --------------------------------------------------------
int sub_804A2F0()
{
  int result; // eax

  result = &unk_806C423 - &unk_806C420;
  if ( (unsigned int)(&unk_806C423 - &unk_806C420) > 6 )
    result = 0;
  return result;
}
// 804A2F0: could not find valid save-restore pair for ebp

//----- (0804A34E) --------------------------------------------------------
int sub_804A34E()
{
  return nullsub_3();
}
// 804A34E: could not find valid save-restore pair for ebp
// 804A34D: using guessed type int nullsub_3(void);

//----- (0804A3EE) --------------------------------------------------------
void sub_804A3EE()
{
  ;
}

//----- (0804A409) --------------------------------------------------------
void sub_804A409()
{
  ;
}

//----- (0804A419) --------------------------------------------------------
signed int sub_804A419()
{
  return 3;
}
// 804A419: could not find valid save-restore pair for ebp

//----- (0804A4FB) --------------------------------------------------------
void sub_804A4FB()
{
  ;
}

//----- (0804A516) --------------------------------------------------------
void sub_804A516()
{
  ;
}

//----- (0804A526) --------------------------------------------------------
int sub_804A526()
{
  int result; // eax

  result = &unk_806C423 - &unk_806C420;
  if ( (unsigned int)(&unk_806C423 - &unk_806C420) > 6 )
    result = 0;
  return result;
}
// 804A526: could not find valid save-restore pair for ebp

//----- (0804A608) --------------------------------------------------------
void sub_804A608()
{
  ;
}

//----- (0804A623) --------------------------------------------------------
void sub_804A623()
{
  ;
}

//----- (0804A633) --------------------------------------------------------
int sub_804A633()
{
  int result; // eax

  result = &unk_806C423 - &unk_806C420;
  if ( (unsigned int)(&unk_806C423 - &unk_806C420) > 6 )
    result = 0;
  return result;
}
// 804A633: could not find valid save-restore pair for ebp

//----- (0804A69A) --------------------------------------------------------
int __usercall sub_804A69A@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_806C420, a1);
}

//----- (0804A6D6) --------------------------------------------------------
int sub_804A6D6()
{
  int result; // eax

  result = sub_804A633();
  byte_806C73A = 1;
  return result;
}
// 806C73A: using guessed type char byte_806C73A;

//----- (0804A74A) --------------------------------------------------------
void sub_804A74A()
{
  ;
}

//----- (0804A765) --------------------------------------------------------
void sub_804A765()
{
  ;
}

//----- (0804A775) --------------------------------------------------------
#error "804A7A2: call analysis failed (funcsize=23)"

//----- (0804A870) --------------------------------------------------------
void sub_804A870()
{
  ;
}

//----- (0804A88B) --------------------------------------------------------
void sub_804A88B()
{
  ;
}

//----- (0804A89B) --------------------------------------------------------
int sub_804A89B()
{
  int result; // eax

  result = &unk_806C423 - &unk_806C420;
  if ( (unsigned int)(&unk_806C423 - &unk_806C420) > 6 )
    result = 0;
  return result;
}
// 804A89B: could not find valid save-restore pair for ebp

//----- (0804A97D) --------------------------------------------------------
void sub_804A97D()
{
  ;
}

//----- (0804A998) --------------------------------------------------------
void sub_804A998()
{
  ;
}

//----- (0804A9A8) --------------------------------------------------------
int __fastcall sub_804A9A8(int a1, int a2)
{
  int result; // eax
  int (__stdcall *v3)(int *, int, int, int, int, int); // eax
  int v4; // [esp+4h] [ebp-18h]
  int v5; // [esp+8h] [ebp-14h]
  int v6; // [esp+Ch] [ebp-10h]
  int v7; // [esp+10h] [ebp-Ch]
  int v8; // [esp+14h] [ebp-8h]
  int v9; // [esp+18h] [ebp-4h]

  result = &unk_806C818 - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_806C818 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
  {
    v9 = 0;
    dword_806C284 = (int)&locret_804A9B7;
    v3 = (int (__stdcall *)(int *, int, int, int, int, int))sub_80629B0(a1, a2);
    result = v3(&program_invocation_short_name, v4, v5, v6, v7, v8);
  }
  return result;
}
// 806C284: using guessed type int dword_806C284;
// 806C440: using guessed type int program_invocation_short_name;

//----- (0804AA1F) --------------------------------------------------------
int __usercall sub_804AA1F@<eax>(int a1@<ecx>, int a2@<ebp>)
{
  int v2; // eax
  int (__cdecl *v3)(int *, int); // edx
  int v5; // [esp+18h] [ebp-4h]

  dword_806C284 = (int)nullsub_5;
  v2 = sub_80629B0(a1, 0);
  v5 = a2;
  return v3(&program_invocation_short_name, v2);
}
// 804AA1F: could not find valid save-restore pair for ebp
// 804AA1E: using guessed type int nullsub_5();
// 806C284: using guessed type int dword_806C284;
// 806C440: using guessed type int program_invocation_short_name;

//----- (0804AAD8) --------------------------------------------------------
void sub_804AAD8()
{
  ;
}

//----- (0804AAF3) --------------------------------------------------------
void sub_804AAF3()
{
  ;
}

//----- (0804AB03) --------------------------------------------------------
int sub_804AB03()
{
  int result; // eax

  result = &unk_8067377 - &unk_8067374;
  if ( (unsigned int)(&unk_8067377 - &unk_8067374) > 6 )
    result = 0;
  return result;
}
// 804AB03: could not find valid save-restore pair for ebp

//----- (0804ABE5) --------------------------------------------------------
void sub_804ABE5()
{
  ;
}

//----- (0804AC00) --------------------------------------------------------
void sub_804AC00()
{
  ;
}

//----- (0804AC10) --------------------------------------------------------
int sub_804AC10()
{
  int result; // eax

  result = &unk_806636B - &unk_8066368;
  if ( (unsigned int)(&unk_806636B - &unk_8066368) > 6 )
    result = 0;
  return result;
}
// 804AC10: could not find valid save-restore pair for ebp

//----- (0804AD09) --------------------------------------------------------
void sub_804AD09()
{
  ;
}

//----- (0804AD24) --------------------------------------------------------
void sub_804AD24()
{
  ;
}

//----- (0804AD34) --------------------------------------------------------
int sub_804AD34()
{
  int result; // eax

  result = &unk_806C423 - &unk_806C420;
  if ( (unsigned int)(&unk_806C423 - &unk_806C420) > 6 )
    result = 0;
  return result;
}
// 804AD34: could not find valid save-restore pair for ebp

//----- (0804AD92) --------------------------------------------------------
int sub_804AD92()
{
  return nullsub_6();
}
// 804AD92: could not find valid save-restore pair for ebp
// 804AD91: using guessed type int nullsub_6(void);

//----- (0804AE32) --------------------------------------------------------
void sub_804AE32()
{
  ;
}

//----- (0804AE4D) --------------------------------------------------------
void sub_804AE4D()
{
  ;
}

//----- (0804AE5D) --------------------------------------------------------
int sub_804AE5D()
{
  int result; // eax

  result = &unk_806C9CC - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_806C9CC - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 804AE5D: could not find valid save-restore pair for ebp
// 806C440: using guessed type int program_invocation_short_name;

//----- (0804AF7C) --------------------------------------------------------
void sub_804AF7C()
{
  ;
}

//----- (0804AF97) --------------------------------------------------------
void sub_804AF97()
{
  ;
}

//----- (0804AFA7) --------------------------------------------------------
int sub_804AFA7()
{
  int result; // eax

  result = &unk_806C42B - &unk_806C428;
  if ( (unsigned int)(&unk_806C42B - &unk_806C428) > 6 )
    result = 0;
  return result;
}
// 804AFA7: could not find valid save-restore pair for ebp

//----- (0804B09A) --------------------------------------------------------
int __cdecl sub_804B09A(int a1)
{
  int result; // eax

  if ( a1 != 1 )
  {
    result = a1;
    status = a1;
  }
  return result;
}

//----- (0804B0AD) --------------------------------------------------------
int __cdecl sub_804B0AD(unsigned __int8 a1)
{
  return a1;
}

//----- (0804B0BF) --------------------------------------------------------
int __cdecl sub_804B0BF(unsigned __int8 a1)
{
  return (*__ctype_b_loc())[a1] & 1 || a1 == 10;
}

//----- (0804B0FE) --------------------------------------------------------
int __cdecl sub_804B0FE(unsigned __int64 a1)
{
  int result; // eax

  if ( HIDWORD(a1) )
    result = sub_806238C(a1, 0xF4240u, 0) + 1000000;
  else
    result = a1;
  return result;
}

//----- (0804B144) --------------------------------------------------------
int sub_804B144()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nWith no FILE, or when FILE is -, read standard input.\n");
  return fputs_unlocked(v1, v0);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804B16F) --------------------------------------------------------
int sub_804B16F()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nMandatory arguments to long options are mandatory for short options too.\n");
  return fputs_unlocked(v1, v0);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804B19A) --------------------------------------------------------
int __usercall sub_804B19A@<eax>(int a1@<ebx>, char *a2)
{
  char *v2; // ebx
  bool v3; // zf
  void *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  int v10; // [esp-8h] [ebp-70h]
  int v11; // [esp-4h] [ebp-6Ch]
  int v12; // [esp+0h] [ebp-68h]
  char *v13; // [esp+4h] [ebp-64h]
  char *v14; // [esp+8h] [ebp-60h]
  char *v15; // [esp+1Ch] [ebp-4Ch]
  int *v16; // [esp+20h] [ebp-48h]
  char *s1; // [esp+24h] [ebp-44h]
  const char *v18; // [esp+28h] [ebp-40h]
  const char *v19; // [esp+2Ch] [ebp-3Ch]
  const char *v20; // [esp+30h] [ebp-38h]
  const char *v21; // [esp+34h] [ebp-34h]
  const char *v22; // [esp+38h] [ebp-30h]
  const char *v23; // [esp+3Ch] [ebp-2Ch]
  const char *v24; // [esp+40h] [ebp-28h]
  const char *v25; // [esp+44h] [ebp-24h]
  const char *v26; // [esp+48h] [ebp-20h]
  const char *v27; // [esp+4Ch] [ebp-1Ch]
  const char *v28; // [esp+50h] [ebp-18h]
  const char *v29; // [esp+54h] [ebp-14h]
  int v30; // [esp+58h] [ebp-10h]
  int v31; // [esp+5Ch] [ebp-Ch]

  v18 = "[";
  v19 = "test invocation";
  v20 = "coreutils";
  v21 = "Multi-call invocation";
  v22 = "sha224sum";
  v23 = "sha2 utilities";
  v24 = "sha256sum";
  v25 = "sha2 utilities";
  v26 = "sha384sum";
  v27 = "sha2 utilities";
  v28 = "sha512sum";
  v29 = "sha2 utilities";
  v30 = 0;
  v31 = 0;
  v15 = a2;
  v16 = &v12 - 16;
  if ( *(&v12 - 16) )
  {
    dword_806C25C = (int)&loc_804B35B;
    sub_8062A98();
  }
  else
  {
    v3 = v16[1] == 0;
    v11 = v16[1];
    v10 = a1;
    v4 = &loc_804B28A;
    if ( v3 )
      v4 = &loc_804B293;
    dword_806C25C = (int)v4;
    sub_8062A98();
    v15 = (char *)v16[1];
    v5 = gettext("\n%s online help: <%s>\n");
    v14 = "http://www.gnu.org/software/coreutils/";
    v13 = "GNU coreutils";
    printf(v5, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
    s1 = setlocale(5, 0);
    if ( s1 && strncmp(s1, "en_", 3u) )
    {
      v6 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
      v13 = a2;
      printf(v6, a2);
    }
    v7 = gettext("Full documentation at: <%s%s>\n");
    v14 = a2;
    v13 = "http://www.gnu.org/software/coreutils/";
    printf(v7, "http://www.gnu.org/software/coreutils/", a2);
    if ( v15 == a2 )
    {
      v2 = " invocation";
      goto LABEL_11;
    }
  }
  v2 = &locale;
LABEL_11:
  v8 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  v14 = v2;
  v13 = v15;
  return printf(v8, v15, v2);
}
// 806C25C: using guessed type int dword_806C25C;

//----- (0804B399) --------------------------------------------------------
void __cdecl __noreturn sub_804B399(int a1, const char *a2)
{
  size_t v2; // eax
  char *v3; // ST20_4
  size_t v4; // eax
  char v5; // [esp+30h] [ebp-18h]
  unsigned int v6; // [esp+3Ch] [ebp-Ch]

  v6 = __readgsdword(0x14u);
  v2 = strlen(a2);
  write(2, a2, v2);
  if ( a1 )
  {
    v3 = (char *)sub_8059A3C(a1, &v5);
    write(2, ": errno ", 8u);
    v4 = strlen(v3);
    write(2, v3, v4);
  }
  write(2, "\n", 1u);
  _exit(2);
}
// 8059A3C: using guessed type _DWORD __cdecl sub_8059A3C(_DWORD, _DWORD);

//----- (0804B47B) --------------------------------------------------------
void __cdecl __noreturn sub_804B47B(int a1, int a2)
{
  int v2; // ebx
  int *v3; // eax

  if ( !a2 )
    gettext("standard output");
  v2 = sub_805C2D5(0, 3);
  v3 = __errno_location();
  error(2, *v3, "%s: %s", a1, v2);
  sub_804B4DD(a1);
}

//----- (0804B4DD) --------------------------------------------------------
void __cdecl __noreturn sub_804B4DD(int status)
{
  int v1; // ebx
  char *v2; // eax
  int v3; // esi
  int v4; // ebx
  char *v5; // eax
  FILE *v6; // ebx
  char *v7; // eax
  FILE *v8; // ebx
  char *v9; // eax
  FILE *v10; // ebx
  char *v11; // eax
  FILE *v12; // ebx
  char *v13; // eax
  FILE *v14; // ebx
  char *v15; // eax
  FILE *v16; // ebx
  char *v17; // eax
  FILE *v18; // ebx
  char *v19; // eax
  FILE *v20; // ebx
  char *v21; // eax
  FILE *v22; // ebx
  char *v23; // eax
  FILE *v24; // ebx
  char *v25; // eax
  FILE *v26; // ebx
  char *v27; // eax
  FILE *v28; // ebx
  char *v29; // eax
  FILE *v30; // ebx
  char *v31; // eax
  char *v32; // eax
  FILE *v33; // ebx
  char *v34; // eax
  FILE *v35; // ebx
  char *v36; // eax
  FILE *v37; // ebx
  char *v38; // eax
  FILE *v39; // ebx
  char *v40; // eax
  FILE *v41; // ebx
  char *v42; // eax

  if ( status )
  {
    v1 = dword_806D026;
    v2 = gettext("Try '%s --help' for more information.\n");
    fprintf(stderr, v2, v1);
  }
  else
  {
    v3 = dword_806D026;
    v4 = dword_806D026;
    v5 = gettext("Usage: %s [OPTION]... [FILE]...\n  or:  %s [OPTION]... --files0-from=F\n");
    printf(v5, v4, v3);
    v6 = stdout;
    v7 = gettext("Write sorted concatenation of all FILE(s) to standard output.\n");
    fputs_unlocked(v7, v6);
    sub_804B144();
    sub_804B16F();
    v8 = stdout;
    v9 = gettext("Ordering options:\n\n");
    fputs_unlocked(v9, v8);
    v10 = stdout;
    v11 = gettext(
            "  -b, --ignore-leading-blanks  ignore leading blanks\n"
            "  -d, --dictionary-order      consider only blanks and alphanumeric characters\n"
            "  -f, --ignore-case           fold lower case to upper case characters\n");
    fputs_unlocked(v11, v10);
    v12 = stdout;
    v13 = gettext(
            "  -g, --general-numeric-sort  compare according to general numerical value\n"
            "  -i, --ignore-nonprinting    consider only printable characters\n"
            "  -M, --month-sort            compare (unknown) < 'JAN' < ... < 'DEC'\n");
    fputs_unlocked(v13, v12);
    v14 = stdout;
    v15 = gettext("  -h, --human-numeric-sort    compare human readable numbers (e.g., 2K 1G)\n");
    fputs_unlocked(v15, v14);
    v16 = stdout;
    v17 = gettext(
            "  -n, --numeric-sort          compare according to string numerical value\n"
            "  -R, --random-sort           shuffle, but group identical keys.  See shuf(1)\n"
            "      --random-source=FILE    get random bytes from FILE\n"
            "  -r, --reverse               reverse the result of comparisons\n");
    fputs_unlocked(v17, v16);
    v18 = stdout;
    v19 = gettext(
            "      --sort=WORD             sort according to WORD:\n"
            "                                general-numeric -g, human-numeric -h, month -M,\n"
            "                                numeric -n, random -R, version -V\n"
            "  -V, --version-sort          natural sort of (version) numbers within text\n"
            "\n");
    fputs_unlocked(v19, v18);
    v20 = stdout;
    v21 = gettext("Other options:\n\n");
    fputs_unlocked(v21, v20);
    v22 = stdout;
    v23 = gettext(
            "      --batch-size=NMERGE   merge at most NMERGE inputs at once;\n"
            "                            for more use temp files\n");
    fputs_unlocked(v23, v22);
    v24 = stdout;
    v25 = gettext(
            "  -c, --check, --check=diagnose-first  check for sorted input; do not sort\n"
            "  -C, --check=quiet, --check=silent  like -c, but do not report first bad line\n"
            "      --compress-program=PROG  compress temporaries with PROG;\n"
            "                              decompress them with PROG -d\n");
    fputs_unlocked(v25, v24);
    v26 = stdout;
    v27 = gettext(
            "      --debug               annotate the part of the line used to sort,\n"
            "                              and warn about questionable usage to stderr\n"
            "      --files0-from=F       read input from the files specified by\n"
            "                            NUL-terminated names in file F;\n"
            "                            If F is - then read names from standard input\n");
    fputs_unlocked(v27, v26);
    v28 = stdout;
    v29 = gettext(
            "  -k, --key=KEYDEF          sort via a key; KEYDEF gives location and type\n"
            "  -m, --merge               merge already sorted files; do not sort\n");
    fputs_unlocked(v29, v28);
    v30 = stdout;
    v31 = gettext(
            "  -o, --output=FILE         write result to FILE instead of standard output\n"
            "  -s, --stable              stabilize sort by disabling last-resort comparison\n"
            "  -S, --buffer-size=SIZE    use SIZE for main memory buffer\n");
    fputs_unlocked(v31, v30);
    v32 = gettext(
            "  -t, --field-separator=SEP  use SEP instead of non-blank to blank transition\n"
            "  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or %s;\n"
            "                              multiple options specify multiple directories\n"
            "      --parallel=N          change the number of sorts run concurrently to N\n"
            "  -u, --unique              with -c, check for strict ordering;\n"
            "                              without -c, output only the first of an equal run\n");
    printf(v32, "/tmp");
    v33 = stdout;
    v34 = gettext("  -z, --zero-terminated     line delimiter is NUL, not newline\n");
    fputs_unlocked(v34, v33);
    v35 = stdout;
    v36 = gettext("      --help     display this help and exit\n");
    fputs_unlocked(v36, v35);
    v37 = stdout;
    v38 = gettext("      --version  output version information and exit\n");
    fputs_unlocked(v38, v37);
    v39 = stdout;
    v40 = gettext(
            "\n"
            "KEYDEF is F[.C][OPTS][,F[.C][OPTS]] for start and stop position, where F is a\n"
            "field number and C a character position in the field; both are origin 1, and\n"
            "the stop position defaults to the line's end.  If neither -t nor -b is in\n"
            "effect, characters in a field are counted from the beginning of the preceding\n"
            "whitespace.  OPTS is one or more single-letter ordering options [bdfgiMhnRrV],\n"
            "which override global ordering options for that key.  If no key is given, use\n"
            "the entire line as the key.  Use --debug to diagnose incorrect key usage.\n"
            "\n"
            "SIZE may be followed by the following multiplicative suffixes:\n");
    fputs_unlocked(v40, v39);
    v41 = stdout;
    v42 = gettext(
            "% 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, E, Z, Y.\n"
            "\n"
            "*** WARNING ***\n"
            "The locale specified by the environment affects sort order.\n"
            "Set LC_ALL=C to get the traditional sort order that uses\n"
            "native byte values.\n");
    fputs_unlocked(v42, v41);
    sub_804B19A((int)v41, "sort");
  }
  exit(status);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 806D026: using guessed type int dword_806D026;

//----- (0804B799) --------------------------------------------------------
int __cdecl sub_804B799(int a1)
{
  bool v1; // dl
  int result; // eax

  v1 = pthread_sigmask(0, &set, (__sigset_t *)(a1 + 4)) == 0;
  result = a1;
  *(_BYTE *)a1 = v1;
  return result;
}

//----- (0804B7CE) --------------------------------------------------------
int __cdecl sub_804B7CE(unsigned __int8 *a1)
{
  int result; // eax

  result = *a1;
  if ( (_BYTE)result )
    result = pthread_sigmask(2, (const __sigset_t *)(a1 + 4), 0);
  return result;
}

//----- (0804B800) --------------------------------------------------------
bool __cdecl sub_804B800(int a1, int a2)
{
  return *(_DWORD *)(a1 + 4) == *(_DWORD *)(a2 + 4);
}

//----- (0804B837) --------------------------------------------------------
int __cdecl sub_804B837(int a1, unsigned int a2)
{
  return *(_DWORD *)(a1 + 4) % a2;
}

//----- (0804B886) --------------------------------------------------------
#error "804B92C: call analysis failed (funcsize=83)"

//----- (0804B9AF) --------------------------------------------------------
int __cdecl sub_804B9AF(int a1)
{
  int result; // eax

  if ( !dword_806CF5A )
  {
    dword_806CF5A = (int)sub_8058786(0x2Fu, 0, (unsigned int (__cdecl *)(int, unsigned int))sub_804B837, sub_804B800, 0);
    if ( !dword_806CF5A )
      sub_805F305();
  }
  *(_BYTE *)(a1 + 8) = 1;
  result = sub_805931F(dword_806CF5A, a1);
  if ( !result )
    sub_805F305();
  return result;
}
// 805931F: using guessed type _DWORD __cdecl sub_805931F(_DWORD, _DWORD);
// 806CF5A: using guessed type int dword_806CF5A;

//----- (0804BA40) --------------------------------------------------------
signed int __cdecl sub_804BA40(int a1)
{
  signed int result; // eax
  int v2; // [esp+1Ch] [ebp-1Ch]
  char v3; // [esp+20h] [ebp-18h]
  int v4; // [esp+24h] [ebp-14h]
  unsigned int v5; // [esp+2Ch] [ebp-Ch]

  v5 = __readgsdword(0x14u);
  v4 = a1;
  v2 = sub_80593A9(dword_806CF5A, (int)&v3);
  if ( v2 )
  {
    *(_BYTE *)(v2 + 8) = 2;
    result = 1;
  }
  else
  {
    result = 0;
  }
  while ( __readgsdword(0x14u) != v5 )
    ;
  return result;
}
// 806CF5A: using guessed type int dword_806CF5A;

//----- (0804BAB6) --------------------------------------------------------
int __cdecl sub_804BAB6(__pid_t pid)
{
  int result; // eax

  result = sub_804BA40(pid);
  if ( (_BYTE)result )
    result = sub_804B886(pid);
  return result;
}

//----- (0804BAD8) --------------------------------------------------------
int sub_804BAD8()
{
  int result; // eax

  do
  {
    result = dword_806CF5E;
    if ( dword_806CF5E <= 0 )
      break;
    result = sub_804B886(0);
  }
  while ( result );
  return result;
}
// 806CF5E: using guessed type int dword_806CF5E;

//----- (0804BAFB) --------------------------------------------------------
int sub_804BAFB()
{
  sub_804B886(-1);
  return sub_804BAD8();
}

//----- (0804BB14) --------------------------------------------------------
int sub_804BB14()
{
  int result; // eax

  while ( 1 )
  {
    result = dword_806CF5E;
    if ( dword_806CF5E <= 0 )
      break;
    sub_804B886(-1);
  }
  return result;
}
// 806CF5E: using guessed type int dword_806CF5E;

//----- (0804BB43) --------------------------------------------------------
int __fastcall sub_804BB43(int a1, int a2)
{
  void *v2; // eax
  int result; // eax

  v2 = &loc_804BB88;
  if ( dword_806CF56 )
    v2 = &loc_804BB53;
  dword_806C284 = (int)v2;
  result = sub_80629B0(a1, a2);
  dword_806CF56 = 0;
  return result;
}
// 806C284: using guessed type int dword_806C284;
// 806CF56: using guessed type int dword_806CF56;

//----- (0804BB94) --------------------------------------------------------
void __noreturn sub_804BB94()
{
  int v0; // edx
  int v1; // ecx
  char v2; // [esp+1Ch] [ebp-8Ch]

  if ( dword_806CF56 )
  {
    sub_804B799((int)&v2);
    sub_804BB43(v1, v0);
    sub_804B7CE((unsigned __int8 *)&v2);
  }
  sub_80562CB();
}
// 80562CB: using guessed type int sub_80562CB(void);
// 806CF56: using guessed type int dword_806CF56;

//----- (0804BBCE) --------------------------------------------------------
#error "804BC0C: call analysis failed (funcsize=20)"

//----- (0804BC11) --------------------------------------------------------
#error "804BE61: positive sp value has been found (funcsize=117)"

//----- (0804BE65) --------------------------------------------------------
FILE *__cdecl sub_804BE65(char *s1, char *modes)
{
  FILE *v2; // eax
  void *v3; // eax
  int v4; // esi
  char *v5; // ebx
  int *v6; // eax
  FILE *stream; // [esp+18h] [ebp-10h]
  int fd; // [esp+1Ch] [ebp-Ch]

  if ( *modes == 114 )
  {
    if ( !strcmp(s1, "-") )
    {
      byte_806CEC9 = 1;
      stream = stdin;
    }
    else
    {
      fd = open64(s1, 0x80000);
      if ( fd < 0 )
        v2 = 0;
      else
        v2 = fdopen(fd, modes);
      stream = v2;
    }
    sub_80577F4(stream);
  }
  else
  {
    v3 = &loc_804BF12;
    if ( *modes != 119 )
      v3 = &loc_804BF8C;
    dword_806C25C = (int)v3;
    sub_8062A98();
    if ( s1 && ftruncate64(1, 0, 0) )
    {
      v4 = sub_805C2D5(0, 3);
      v5 = gettext("%s: error truncating");
      v6 = __errno_location();
      error(2, *v6, v5, v4);
    }
    stream = stdout;
  }
  return stream;
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 8049D20: using guessed type int __cdecl ftruncate64(_DWORD, _DWORD, _DWORD);
// 806C25C: using guessed type int dword_806C25C;
// 806CEC9: using guessed type char byte_806CEC9;

//----- (0804BFBA) --------------------------------------------------------
FILE *__cdecl sub_804BFBA(char *s1, char *modes)
{
  char *v2; // eax
  FILE *v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_804BE65(s1, modes);
  if ( !v4 )
  {
    v2 = gettext("open failed");
    sub_804B47B((int)v2, (int)s1);
  }
  return v4;
}

//----- (0804BFFB) --------------------------------------------------------
#error "804C029: call analysis failed (funcsize=50)"

//----- (0804C0DA) --------------------------------------------------------
int __cdecl sub_804C0DA(int fd, int fd2)
{
  int result; // eax

  result = fd;
  if ( fd != fd2 )
  {
    dup2(fd, fd2);
    result = close(fd);
  }
  return result;
}

//----- (0804C117) --------------------------------------------------------
#error "804C156: call analysis failed (funcsize=96)"

//----- (0804C2E9) --------------------------------------------------------
int __usercall sub_804C2E9@<eax>(int a1@<ebx>, FILE **a2, unsigned __int8 a3)
{
  int v4; // eax
  int *v5; // eax
  bool v6; // zf
  void *v7; // eax
  int v8; // ebx
  char *v9; // eax
  int v10; // [esp-8h] [ebp-30h]
  FILE *v11; // [esp-4h] [ebp-2Ch]
  int v12; // [esp+0h] [ebp-28h]
  int v13; // [esp+8h] [ebp-20h]
  unsigned __int8 v14; // [esp+Ch] [ebp-1Ch]
  int fd; // [esp+10h] [ebp-18h]
  int v16; // [esp+14h] [ebp-14h]
  int pipedes[2]; // [esp+18h] [ebp-10h]

  v14 = a3;
  v16 = sub_804BBCE(&v12 - 6, a3);
  if ( v16 )
  {
    *(_BYTE *)(v16 + 8) = 0;
    if ( arg )
    {
      v4 = sub_804C117(pipedes, 4);
      *(_DWORD *)(v16 + 4) = v4;
      if ( *(_DWORD *)(v16 + 4) <= 0 )
      {
        if ( !*(_DWORD *)(v16 + 4) )
        {
          close(pipedes[1]);
          sub_804C0DA(fd, 1);
          sub_804C0DA(pipedes[0], 0);
          v13 = 0;
          execlp(arg, arg, 0);
          v5 = __errno_location();
          sub_804B399(*v5, "couldn't execute compress program");
        }
      }
      else
      {
        close(fd);
        close(pipedes[0]);
        fd = pipedes[1];
        sub_804B9AF(v16);
      }
    }
    *a2 = fdopen(fd, "w");
    v6 = *a2 == 0;
    v11 = *a2;
    v10 = a1;
    v7 = &loc_804C447;
    if ( !v6 )
      v7 = &loc_804C465;
    dword_806C2EC = (int)v7;
    sub_80626B4();
    v8 = v16 + 9;
    v9 = gettext("couldn't create temporary file");
    sub_804B47B((int)v9, v8);
  }
  return 0;
}
// 804BBCE: using guessed type _DWORD __cdecl sub_804BBCE(_DWORD, _DWORD);
// 80626B4: using guessed type int sub_80626B4(void);
// 806C2EC: using guessed type int dword_806C2EC;

//----- (0804C46E) --------------------------------------------------------
int __usercall sub_804C46E@<eax>(int a1@<ebx>, FILE **a2)
{
  return sub_804C2E9(a1, a2, 0);
}

//----- (0804C489) --------------------------------------------------------
FILE *__cdecl sub_804C489(int a1)
{
  int v2; // eax
  bool v3; // zf
  void *v4; // eax
  int i; // eax
  int v6; // edx
  int v7; // ecx
  int v8; // [esp+0h] [ebp-38h]
  const char *v9; // [esp+8h] [ebp-30h]
  int v10; // [esp+Ch] [ebp-2Ch]
  FILE *v11; // [esp+18h] [ebp-20h]
  int v12; // [esp+1Ch] [ebp-1Ch]
  int v13; // [esp+20h] [ebp-18h]
  int v14; // [esp+24h] [ebp-14h]
  int fd; // [esp+28h] [ebp-10h]
  int v16; // [esp+2Ch] [ebp-Ch]

  v11 = 0;
  if ( *(_BYTE *)(a1 + 8) == 1 )
    sub_804BAB6(*(_DWORD *)(a1 + 4));
  v12 = open64(a1 + 9, 0);
  if ( v12 < 0 )
    return 0;
  v2 = sub_804C117(&fd, 9);
  v13 = v2;
  v3 = v2 == -1;
  v4 = &loc_804C511;
  if ( v3 )
    v4 = &loc_804C532;
  dword_806C270 = (int)v4;
  for ( i = sub_8062A28(v8); !i; i = sub_8062BFE(v7, v6) )
  {
    close(fd);
    sub_804C0DA(v12, 0);
    sub_804C0DA(v16, 1);
    v10 = 0;
    v9 = "-d";
    execlp(arg, arg, "-d", 0);
    __errno_location();
    dword_806C220 = (int)&loc_804C516;
  }
  *(_DWORD *)(a1 + 4) = v13;
  sub_804B9AF(a1);
  close(v12);
  close(v16);
  v11 = fdopen(fd, "r");
  if ( !v11 )
  {
    v14 = *__errno_location();
    close(fd);
    *__errno_location() = v14;
  }
  return v11;
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 8062A28: using guessed type int __stdcall sub_8062A28(_DWORD);
// 8062BFE: using guessed type int __fastcall sub_8062BFE(_DWORD, _DWORD);
// 806C220: using guessed type int dword_806C220;
// 806C270: using guessed type int dword_806C270;

//----- (0804C693) --------------------------------------------------------
#error "804C6BC: call analysis failed (funcsize=31)"

//----- (0804C704) --------------------------------------------------------
void __cdecl sub_804C704(char *name)
{
  void *v1; // eax
  int v2; // ST30_4
  int v3; // ebx
  char *v4; // eax
  int v5; // [esp+0h] [ebp-B8h]
  int v6; // [esp+4h] [ebp-B4h]
  int v7; // [esp+8h] [ebp-B0h]
  int v8; // [esp+Ch] [ebp-ACh]
  int v9; // [esp+10h] [ebp-A8h]
  int v10; // [esp+14h] [ebp-A4h]
  int *i; // [esp+18h] [ebp-A0h]
  int *v12; // [esp+18h] [ebp-A0h]
  int errnum; // [esp+1Ch] [ebp-9Ch]
  _BYTE *ptr; // [esp+20h] [ebp-98h]
  int *ptra; // [esp+20h] [ebp-98h]
  int v16; // [esp+24h] [ebp-94h]
  int v17; // [esp+24h] [ebp-94h]
  int v18; // [esp+28h] [ebp-90h]
  char v19; // [esp+2Ch] [ebp-8Ch]

  for ( i = &dword_806CF56; ; i = (int *)*i )
  {
    ptr = (_BYTE *)*i;
    if ( (char *)(*i + 9) == name )
      break;
  }
  v1 = &loc_804C773;
  if ( ptr[8] != 1 )
    v1 = &loc_804C784;
  dword_806C248 = (int)v1;
  sub_8062B10(v5, v6, v7, v8, v9, v10, i, 0, ptr, v16, v18);
  sub_804BAB6(ptra[1]);
  v17 = *ptra;
  sub_804B799((int)&v19);
  v2 = unlink(name);
  errnum = *__errno_location();
  *v12 = v17;
  sub_804B7CE((unsigned __int8 *)&v19);
  if ( v2 )
  {
    v3 = sub_805C2D5(0, 3);
    v4 = gettext("warning: cannot remove: %s");
    error(0, errnum, v4, v3);
  }
  if ( !v17 )
    off_806C3AC = v12;
  free(ptra);
}
// 8062B10: using guessed type int __stdcall sub_8062B10(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806C248: using guessed type int dword_806C248;
// 806C3AC: using guessed type int *off_806C3AC;
// 806CF56: using guessed type int dword_806CF56;

//----- (0804C855) --------------------------------------------------------
int __cdecl compar(const void *a1, const void *a2)
{
  return strcmp(*(const char **)a1, *(const char **)a2);
}

//----- (0804C88F) --------------------------------------------------------
void sub_804C88F()
{
  bool v0; // al
  int v1; // edx
  int v2; // ecx
  const unsigned __int16 *v3; // ebx
  int v4; // eax
  char *v5; // ebx
  int v6; // [esp+0h] [ebp-38h]
  int c; // [esp+18h] [ebp-20h]
  unsigned int v8; // [esp+1Ch] [ebp-1Ch]
  int v9; // [esp+20h] [ebp-18h]
  char *s; // [esp+24h] [ebp-14h]
  size_t v11; // [esp+28h] [ebp-10h]
  char *v12; // [esp+2Ch] [ebp-Ch]

  for ( c = 0; (unsigned int)c <= 0xFF; ++c )
  {
    *(_BYTE *)(c + 134662838) = sub_804B0BF(c);
    *(_BYTE *)(c + 134663094) = ((*__ctype_b_loc())[c] & 0x4000) == 0;
    v0 = !((*__ctype_b_loc())[c] & 8) && (unsigned __int8)sub_804B0BF(c) ^ 1;
    *(_BYTE *)(c + 134663350) = v0;
    *(_BYTE *)(c + 134663606) = toupper(c);
  }
  if ( byte_806CA9F )
  {
    c = 0;
    dword_806C2EC = (int)&loc_804CAA3;
    sub_80626B4();
    do
    {
      s = nl_langinfo(c + 131086);
      v11 = strlen(s);
      v12 = (char *)sub_805F128(v11 + 1);
      (&off_806C340)[2 * c] = v12;
      v1 = c + 1;
      dword_806C344[2 * c] = c + 1;
      v9 = 0;
      v8 = 0;
      dword_806C284 = (int)&loc_804CA8C;
      sub_80629B0(v2, v1);
      do
      {
        v3 = *__ctype_b_loc();
        v6 = s[v8];
        if ( !(v3[(unsigned __int8)sub_804B0AD(v6)] & 1) )
        {
          v4 = v9++;
          v5 = &v12[v4];
          *v5 = byte_806CDB6[(unsigned __int8)sub_804B0AD(s[v8])];
        }
        ++v8;
      }
      while ( v8 < v11 );
      v12[v9] = 0;
      ++c;
    }
    while ( (unsigned int)c <= 0xB );
    qsort(&off_806C340, 0xCu, 8u, compar);
  }
}
// 80626B4: using guessed type int sub_80626B4(void);
// 806C284: using guessed type int dword_806C284;
// 806C2EC: using guessed type int dword_806C2EC;
// 806C340: using guessed type char *off_806C340;
// 806C344: using guessed type int dword_806C344[];
// 806CA9F: using guessed type char byte_806CA9F;

//----- (0804CAD7) --------------------------------------------------------
int __cdecl sub_804CAD7(int a1, char a2, char *a3)
{
  int v3; // eax
  int v4; // edx
  int v5; // ecx
  unsigned __int64 v6; // kr00_8
  void *v7; // ebx
  int v8; // esi
  char *v9; // eax
  void *v10; // ebx
  int v11; // esi
  char *v12; // eax
  int result; // eax
  unsigned int v14; // et1
  void *v15; // ebx
  int v16; // esi
  char *v17; // eax
  int v18; // ebx
  int v19; // esi
  char *v20; // eax
  int v21; // [esp+0h] [ebp-58h]
  int v22; // [esp+Ch] [ebp-4Ch]
  int v23; // [esp+10h] [ebp-48h]
  char *nptr; // [esp+18h] [ebp-40h]
  char v25; // [esp+1Ch] [ebp-3Ch]
  int v26; // [esp+20h] [ebp-38h]
  unsigned int v27; // [esp+24h] [ebp-34h]
  unsigned __int64 v28; // [esp+28h] [ebp-30h]
  int v29; // [esp+30h] [ebp-28h]
  char v30; // [esp+41h] [ebp-17h]
  unsigned int v31; // [esp+4Ch] [ebp-Ch]

  v25 = a2;
  nptr = a3;
  v31 = __readgsdword(0x14u);
  v26 = sub_805FE21(a3, 0, 10, (int)(&v21 - 12), 0);
  if ( getrlimit64(7, &v29) )
    v3 = 17;
  else
    v3 = v29 - 3;
  v27 = v3;
  if ( v26 )
    goto LABEL_13;
  v6 = v28;
  v4 = v6 >> 32;
  dword_806C3A8 = v6;
  v5 = v28;
  if ( v28 != (unsigned int)v28 )
  {
    v26 = 1;
    goto LABEL_13;
  }
  if ( (unsigned int)dword_806C3A8 <= 1 )
  {
    v7 = sub_805C62A(nptr);
    v8 = *((_DWORD *)&longopts.name + 4 * a1);
    v9 = gettext("invalid --%s argument %s");
    v23 = (int)v7;
    v22 = v8;
    error(0, 0, v9, v8, v7);
    v10 = sub_805C62A("2");
    v11 = *((_DWORD *)&longopts.name + 4 * a1);
    v12 = gettext("minimum --%s argument is %s");
    v23 = (int)v10;
    v22 = v11;
    error(2, 0, v12, v11, v10);
  }
  if ( v27 < dword_806C3A8 )
  {
    v26 = 1;
    goto LABEL_13;
  }
  v14 = __readgsdword(0x14u);
  result = v14 ^ v31;
  if ( v14 != v31 )
  {
    dword_806C220 = (int)&loc_804CD47;
    sub_8062BFE(v5, v4);
LABEL_13:
    if ( v26 == 1 )
    {
      v15 = sub_805C62A(nptr);
      v16 = *((_DWORD *)&longopts.name + 4 * a1);
      v17 = gettext("--%s argument %s too large");
      v23 = (int)v15;
      v22 = v16;
      error(0, 0, v17, v16, v15);
      v18 = sub_8059B68(v27, (int)&v30);
      v19 = *((_DWORD *)&longopts.name + 4 * a1);
      v20 = gettext("maximum --%s argument with current rlimit is %s");
      v23 = v18;
      v22 = v19;
      error(2, 0, v20, v19, v18);
    }
    sub_805FCCC(v26, a1, v25, (int)&longopts, (int)nptr);
  }
  return result;
}
// 8049920: using guessed type int __cdecl getrlimit64(_DWORD, _DWORD);
// 8062BFE: using guessed type int __fastcall sub_8062BFE(_DWORD, _DWORD);
// 806C220: using guessed type int dword_806C220;

//----- (0804CD53) --------------------------------------------------------
#error "804CEE9: call analysis failed (funcsize=215)"

//----- (0804D046) --------------------------------------------------------
int __cdecl sub_804D046(int a1, char a2, char *nptr)
{
  void *v4; // eax
  char *v5; // eax
  int v6; // [esp+0h] [ebp-38h]
  char v7; // [esp+1Ch] [ebp-1Ch]
  int v8; // [esp+28h] [ebp-10h]
  int v9; // [esp+2Ch] [ebp-Ch]

  v7 = a2;
  v9 = sub_805F703(nptr, 0, 10, (int)&v8, &locale);
  if ( v9 == 1 )
    return -1;
  if ( v9 )
    sub_805FCCC(v9, a1, v7, (int)&longopts, (int)nptr);
  v4 = &loc_804D0EB;
  if ( v8 )
    v4 = &loc_804D10F;
  dword_806C270 = (int)v4;
  sub_8062A28(v6);
  v5 = gettext("number in parallel must be nonzero");
  error(2, 0, v5);
  return v8;
}
// 8062A28: using guessed type int __stdcall sub_8062A28(_DWORD);
// 806C270: using guessed type int dword_806C270;

//----- (0804D114) --------------------------------------------------------
int sub_804D114()
{
  __int16 v0; // ax
  long double v1; // fst7
  __int16 v2; // ax
  int result; // eax
  __int64 v4; // [esp+10h] [ebp-48h]
  __int16 v5; // [esp+1Ch] [ebp-3Ch]
  __int16 v6; // [esp+1Eh] [ebp-3Ah]
  unsigned int v7; // [esp+24h] [ebp-34h]
  double v8; // [esp+28h] [ebp-30h]
  double v9; // [esp+30h] [ebp-28h]
  double v10; // [esp+38h] [ebp-20h]
  unsigned __int64 v11; // [esp+40h] [ebp-18h]

  v7 = -1;
  if ( !getrlimit64(2, &v11) && v11 < v7 )
    v7 = v11;
  if ( !getrlimit64(9, &v11) && v11 < v7 )
    v7 = v11;
  v7 >>= 1;
  if ( !getrlimit64(5, &v11) && 15 * (v11 >> 4) < v7 )
    v7 = 15 * (v11 >> 4);
  v8 = sub_805A354();
  v9 = sub_805A297();
  if ( v8 <= v9 / 8.0 )
    v1 = v9 / 8.0;
  else
    v1 = v8;
  v10 = v1;
  v4 = v7;
  if ( (long double)v7 > v9 * 0.75 )
  {
    LOBYTE(v0) = v6;
    HIBYTE(v0) = 12;
    v5 = v0;
    v4 = (signed __int64)(v9 * 0.75);
    v7 = v4;
  }
  v4 = v7;
  if ( (long double)v7 > v10 )
  {
    LOBYTE(v2) = v6;
    HIBYTE(v2) = 12;
    v5 = v2;
    v4 = (signed __int64)v10;
    v7 = v4;
  }
  result = v7;
  if ( 18 * dword_806C3A8 >= v7 )
    result = 18 * dword_806C3A8;
  return result;
}
// 8049920: using guessed type int __cdecl getrlimit64(_DWORD, _DWORD);
// 805A354: using guessed type double sub_805A354(void);

//----- (0804D395) --------------------------------------------------------
#error "804D480: call analysis failed (funcsize=88)"

//----- (0804D595) --------------------------------------------------------
int __cdecl sub_804D595(int a1, int a2, size_t size)
{
  int result; // eax
  size_t sizea; // [esp+28h] [ebp+10h]

  while ( 1 )
  {
    sizea = (size & 0xFFFFFFF0) + 16;
    *(_DWORD *)a1 = malloc(sizea);
    if ( *(_DWORD *)a1 )
      break;
    size = sizea >> 1;
    if ( a2 + 1 >= size )
      sub_805F305();
  }
  *(_DWORD *)(a1 + 20) = a2;
  *(_DWORD *)(a1 + 12) = sizea;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a1 + 16);
  result = a1;
  *(_BYTE *)(a1 + 24) = 0;
  return result;
}

//----- (0804D637) --------------------------------------------------------
int __cdecl sub_804D637(_DWORD *a1)
{
  return *a1 + a1[3];
}

//----- (0804D662) --------------------------------------------------------
int __cdecl sub_804D662(int a1, int *a2)
{
  int v2; // ST00_4
  int v3; // eax
  int v4; // eax
  int result; // eax
  unsigned __int8 *v6; // [esp+4h] [ebp-10h]
  int v7; // [esp+8h] [ebp-Ch]
  unsigned int v8; // [esp+Ch] [ebp-8h]
  int v9; // [esp+10h] [ebp-4h]

  v6 = *(unsigned __int8 **)a1;
  v8 = *(_DWORD *)(a1 + 4) - 1 + *(_DWORD *)a1;
  v7 = *a2;
  v9 = a2[1];
  if ( dword_806C3A4 == 128 )
  {
    while ( (unsigned int)v6 < v8 )
    {
      v4 = v7--;
      if ( !v4 )
        break;
      while ( (unsigned int)v6 < v8 && byte_806CAB6[(unsigned __int8)sub_804B0AD(*v6)] )
        ++v6;
      while ( (unsigned int)v6 < v8 && (unsigned __int8)byte_806CAB6[(unsigned __int8)sub_804B0AD(*v6)] ^ 1 )
        ++v6;
    }
    goto LABEL_23;
  }
  while ( (unsigned int)v6 < v8 )
  {
    v3 = v7--;
    if ( !v3 )
      break;
    while ( (unsigned int)v6 < v8 && (char)*v6 != dword_806C3A4 )
      ++v6;
    if ( (unsigned int)v6 < v8 )
LABEL_8:
      ++v6;
  }
LABEL_23:
  if ( *((_BYTE *)a2 + 24) && (unsigned int)v6 < v8 )
  {
    sub_804B0AD(*v6);
    dword_806C270 = (int)&loc_804D7CB;
    sub_8062A28(v2);
    goto LABEL_8;
  }
  result = v8;
  if ( (unsigned int)&v6[v9] <= v8 )
    result = (int)&v6[v9];
  return result;
}
// 8062A28: using guessed type int __stdcall sub_8062A28(_DWORD);
// 806C270: using guessed type int dword_806C270;
// 806C3A4: using guessed type int dword_806C3A4;

//----- (0804D7F1) --------------------------------------------------------
#error "804D8F6: call analysis failed (funcsize=142)"

//----- (0804D9F4) --------------------------------------------------------
#error "804DEB8: call analysis failed (funcsize=372)"

//----- (0804DEEC) --------------------------------------------------------
int __cdecl sub_804DEEC(char **a1)
{
  int v1; // edx
  char *v2; // eax
  void *v3; // eax
  unsigned __int8 v5; // [esp+9h] [ebp-7h]
  bool v6; // [esp+Ah] [ebp-6h]
  char *v7; // [esp+Ch] [ebp-4h]

  v7 = *a1;
  v5 = 0;
  v6 = 0;
  while ( 1 )
  {
    v2 = v7++;
    if ( (unsigned int)(unsigned __int8)*v2 - 48 > 9 )
      break;
    if ( v5 < (unsigned __int8)*v2 )
      v5 = *v2;
    v1 = *v7;
    v6 = v1 == dword_806CA9A;
    if ( v1 == dword_806CA9A )
      ++v7;
  }
  v3 = &loc_804DF6E;
  if ( !v6 )
    v3 = &loc_804DF7F;
  dword_806C25C = (int)v3;
  sub_8062A98();
  *a1 = v7 - 2;
  return v5;
}
// 806C25C: using guessed type int dword_806C25C;
// 806CA9A: using guessed type int dword_806CA9A;

//----- (0804DFE3) --------------------------------------------------------
int __cdecl sub_804DFE3(_BYTE *a1)
{
  int result; // eax
  int v2; // [esp+0h] [ebp-14h]
  bool v3; // [esp+9h] [ebp-Bh]
  unsigned __int8 v4; // [esp+Ah] [ebp-Ah]
  unsigned __int8 v5; // [esp+Bh] [ebp-9h]
  char *v6; // [esp+Ch] [ebp-8h]
  int v7; // [esp+10h] [ebp-4h]

  v3 = *a1 == 45;
  v6 = &a1[v3];
  v4 = sub_804DEEC((char **)&v2 - 2);
  if ( v4 <= 0x30u )
    return 0;
  v5 = *v6;
  v7 = byte_8064528[v5];
  if ( v3 )
    result = -v7;
  else
    result = v7;
  return result;
}

//----- (0804E08E) --------------------------------------------------------
int __cdecl sub_804E08E(unsigned __int8 *a1, unsigned __int8 *a2)
{
  bool v2; // zf
  void *v3; // eax
  int v4; // ebx
  int v5; // eax
  unsigned __int8 v6; // al
  int result; // eax
  int v8; // [esp+0h] [ebp-28h]
  int v9; // [esp+4h] [ebp-24h]
  int v10; // [esp+8h] [ebp-20h]
  int v11; // [esp+Ch] [ebp-1Ch]
  int v12; // [esp+10h] [ebp-18h]
  int v13; // [esp+14h] [ebp-14h]
  int v14; // [esp+18h] [ebp-10h]
  int v15; // [esp+1Ch] [ebp-Ch]
  int v16; // [esp+20h] [ebp-8h]
  int v17; // [esp+24h] [ebp-4h]
  int savedregs; // [esp+28h] [ebp+0h]

  v6 = sub_804B0AD(*a1);
  v2 = byte_806CAB6[v6] == 0;
  v3 = &loc_804E0EF;
  if ( !v2 )
    v3 = &loc_804E09A;
  dword_806C248 = (int)v3;
  sub_8062B10(v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, savedregs);
  while ( byte_806CAB6[(unsigned __int8)sub_804B0AD(*a2)] )
    ++a2;
  v4 = sub_804DFE3(a1);
  v5 = sub_804DFE3(a2);
  if ( v4 == v5 )
    result = sub_805E787((int)a1, (int)a2, dword_806CA96, dword_806CA9A);
  else
    result = v4 - v5;
  return result;
}
// 8062B10: using guessed type int __stdcall sub_8062B10(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806C248: using guessed type int dword_806C248;
// 806CA96: using guessed type int dword_806CA96;
// 806CA9A: using guessed type int dword_806CA9A;

//----- (0804E171) --------------------------------------------------------
int __cdecl sub_804E171(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 v3; // al

  while ( byte_806CAB6[(unsigned __int8)sub_804B0AD(*a1)] )
    ++a1;
  while ( 1 )
  {
    v3 = sub_804B0AD(*a2);
    if ( !byte_806CAB6[v3] )
      break;
    ++a2;
  }
  return sub_805E787((int)a1, (int)a2, dword_806CA96, dword_806CA9A);
}
// 806CA96: using guessed type int dword_806CA96;
// 806CA9A: using guessed type int dword_806CA9A;

//----- (0804E200) --------------------------------------------------------
void __cdecl __noreturn sub_804E200(int a1, int a2)
{
  _TBYTE s; // [esp+10h] [ebp-28h]
  _TBYTE s2; // [esp+20h] [ebp-18h]

  memset(&s, 0, 0xCu);
  *(long double *)&s = strtold(a1, 0);
  memset(&s2, 0, 0xCu);
  while ( 1 )
  {
    *(long double *)&s2 = strtold(a2, 0);
    memcmp(&s, &s2, 0xCu);
    dword_806C25C = (int)sub_804E2A3;
    sub_8062A98();
  }
}
// 80498F0: using guessed type double __cdecl strtold(_DWORD, _DWORD);
// 804E2A3: using guessed type int sub_804E2A3();
// 806C25C: using guessed type int dword_806C25C;

//----- (0804E2A5) --------------------------------------------------------
signed int __cdecl sub_804E2A5(int a1, int a2)
{
  void *v2; // eax
  int v3; // ST08_4
  void *v4; // eax
  int v5; // edx
  int v6; // ecx
  int v8; // [esp+0h] [ebp-48h]
  int v9; // [esp+4h] [ebp-44h]
  int v10; // [esp+8h] [ebp-40h]
  int v11; // [esp+Ch] [ebp-3Ch]
  int v12; // [esp+10h] [ebp-38h]
  int v13; // [esp+14h] [ebp-34h]
  int v14; // [esp+18h] [ebp-30h]
  int v15; // [esp+1Ch] [ebp-2Ch]
  long double v16; // [esp+20h] [ebp-28h]
  long double v17; // [esp+30h] [ebp-18h]

  v16 = strtold(a1, &v14);
  v17 = strtold(a2, &v15);
  if ( a1 == v14 )
  {
    v2 = &loc_804E2FE;
    if ( a2 != v15 )
      v2 = &loc_804E305;
    dword_806C248 = (int)v2;
    sub_8062B10(v8, v9, v10, v11, v12, v13, v14, v15, LODWORD(v16), DWORD1(v16), HIDWORD(v16));
    dword_806C270 = (int)&locret_804E416;
    sub_8062A28(v3);
  }
  v4 = &loc_804E342;
  if ( a2 != v15 )
    v4 = &loc_804E35E;
  dword_806C25C = (int)v4;
  sub_8062A98();
  dword_806C2AC = (int)&locret_804E416;
  sub_80628B5(v6, v5);
  if ( v17 > v16 )
    return -1;
  if ( v16 > v17 )
    return 1;
  if ( v17 == v16 )
    return 0;
  return -1;
}
// 804E2A5: could not find valid save-restore pair for ebx
// 80498F0: using guessed type double __cdecl strtold(_DWORD, _DWORD);
// 80628B5: using guessed type int __fastcall sub_80628B5(_DWORD, _DWORD);
// 8062A28: using guessed type int __stdcall sub_8062A28(_DWORD);
// 8062B10: using guessed type int __stdcall sub_8062B10(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8062B84: using guessed type int __stdcall sub_8062B84(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806C234: using guessed type int dword_806C234;
// 806C248: using guessed type int dword_806C248;
// 806C25C: using guessed type int dword_806C25C;
// 806C270: using guessed type int dword_806C270;
// 806C2AC: using guessed type int dword_806C2AC;

//----- (0804E418) --------------------------------------------------------
int __cdecl sub_804E418(unsigned __int8 *a1, unsigned __int8 **a2)
{
  unsigned __int8 v3; // al
  unsigned __int8 v4; // bl
  unsigned __int8 v5; // al
  unsigned __int8 v6; // bl
  unsigned int v7; // [esp+10h] [ebp-18h]
  unsigned int v8; // [esp+14h] [ebp-14h]
  unsigned __int8 *v9; // [esp+18h] [ebp-10h]
  unsigned __int8 *i; // [esp+1Ch] [ebp-Ch]
  unsigned int v11; // [esp+20h] [ebp-8h]

  v7 = 0;
  v8 = 12;
  while ( byte_806CAB6[(unsigned __int8)sub_804B0AD(*a1)] )
    ++a1;
  while ( 2 )
  {
    v11 = (v7 + v8) >> 1;
    v9 = a1;
    for ( i = (unsigned __int8 *)(&off_806C340)[2 * v11]; ; ++i )
    {
      if ( !*i )
      {
        if ( a2 )
          *a2 = v9;
        return dword_806C344[2 * v11];
      }
      v3 = sub_804B0AD(*v9);
      v4 = sub_804B0AD(byte_806CDB6[v3]);
      if ( v4 < (unsigned __int8)sub_804B0AD(*i) )
      {
        v8 = (v7 + v8) >> 1;
        goto LABEL_14;
      }
      v5 = sub_804B0AD(*v9);
      v6 = sub_804B0AD(byte_806CDB6[v5]);
      if ( v6 > (unsigned __int8)sub_804B0AD(*i) )
        break;
      ++v9;
    }
    v7 = v11 + 1;
LABEL_14:
    if ( v7 < v8 )
      continue;
    return 0;
  }
}
// 806C340: using guessed type char *off_806C340;
// 806C344: using guessed type int dword_806C344[];

//----- (0804E54A) --------------------------------------------------------
unsigned int __usercall sub_804E54A@<eax>(int a1@<ebx>, int a2)
{
  char **v2; // ebp
  char *v3; // eax
  char *msgid; // [esp+0h] [ebp-3Ch]
  int v6; // [esp+Ch] [ebp-30h]
  char *v7; // [esp+18h] [ebp-24h]
  int v8; // [esp+1Ch] [ebp-20h]
  unsigned int v9; // [esp+2Ch] [ebp-10h]
  int v10; // [esp+38h] [ebp-4h]

  v2 = (char **)&v10;
  v6 = a2;
  v9 = __readgsdword(0x14u);
  v7 = sub_805C960(a2, 0x10u);
  if ( !v7 )
  {
    v3 = gettext("open failed");
    sub_804B47B((int)v3, v6);
  }
  sub_805CCBF(a1, (int)v7, &v8, 0x10u);
  while ( 1 )
  {
    msgid = *(v2 - 8);
    if ( !sub_805CD07(msgid) )
      break;
    dword_806C270 = (int)&loc_804E5FE;
    sub_8062A28(msgid);
    v2 = &msgid;
  }
  sub_80563D9(&unk_806CF76);
  sub_8056818(v2 - 7, 0x10u, (int)&unk_806CF76);
  return __readgsdword(0x14u) ^ (unsigned int)*(v2 - 3);
}
// 80563D9: using guessed type _DWORD __cdecl sub_80563D9(_DWORD);
// 8062A28: using guessed type int __stdcall sub_8062A28(_DWORD);
// 806C270: using guessed type int dword_806C270;

//----- (0804E653) --------------------------------------------------------
size_t __cdecl sub_804E653(char *dest, char *src, size_t n)
{
  char *v3; // eax
  char *v4; // ebx
  int *v5; // eax
  void *v6; // ebx
  char *v7; // eax
  size_t v9; // [esp+1Ch] [ebp-Ch]

  *__errno_location() = 0;
  v9 = strxfrm(dest, src, n);
  if ( *__errno_location() )
  {
    v4 = gettext("string transformation failed");
    v5 = __errno_location();
    error(0, *v5, v4);
    v3 = gettext("set LC_ALL='C' to work around the problem");
    error(0, 0, v3);
    v6 = sub_805C058(0, 8, src);
    v7 = gettext("the untransformed string was %s");
    error(2, 0, v7, v6);
  }
  return v9;
}

//----- (0804E733) --------------------------------------------------------
#error "804E773: call analysis failed (funcsize=21)"

//----- (0804E778) --------------------------------------------------------
#error "804EDA6: positive sp value has been found (funcsize=126)"

//----- (0804EDAB) --------------------------------------------------------
void __usercall __noreturn sub_804EDAB(int a1@<ebx>, char *a2, int a3)
{
  sub_8059CC2(a1, a2, a3 - (_DWORD)a2, 0);
}

//----- (0804EE0B) --------------------------------------------------------
#error "804EE1F: call analysis failed (funcsize=33)"

//----- (0804EE9A) --------------------------------------------------------
int __cdecl sub_804EE9A(_BYTE *a1)
{
  return a1[26] || a1[28] || a1[29];
}

//----- (0804EEDF) --------------------------------------------------------
void __usercall __noreturn sub_804EEDF(int a1@<ebx>, int *a2, int a3)
{
  _BOOL4 v3; // eax
  int v4; // ecx
  _BOOL4 v5; // eax
  int v6; // [esp+0h] [ebp-48h]
  int v7; // [esp+4h] [ebp-44h]
  int v8; // [esp+8h] [ebp-40h]
  int v9; // [esp+Ch] [ebp-3Ch]
  int v10; // [esp+10h] [ebp-38h]
  unsigned __int8 *v11; // [esp+14h] [ebp-34h]
  unsigned __int8 *v12; // [esp+18h] [ebp-30h]
  unsigned __int8 *v13; // [esp+1Ch] [ebp-2Ch]
  unsigned __int8 *v14; // [esp+20h] [ebp-28h]
  char *v15; // [esp+24h] [ebp-24h]
  int v16; // [esp+28h] [ebp-20h]
  int v17; // [esp+2Ch] [ebp-1Ch]
  long double v18; // [esp+30h] [ebp-18h]

  v15 = (char *)*a2;
  v13 = (unsigned __int8 *)v15;
  v14 = (unsigned __int8 *)&v15[a2[1] - 1];
  if ( a3 )
  {
    if ( *(_DWORD *)a3 != -1 )
      v13 = (unsigned __int8 *)sub_804D662((int)a2, (int *)a3);
    if ( *(_DWORD *)(a3 + 8) != -1 )
      v14 = (unsigned __int8 *)sub_804D7F1(a2, a3);
    if ( *(_BYTE *)(a3 + 24) && *(_DWORD *)a3 == -1 || *(_BYTE *)(a3 + 30) || (unsigned __int8)sub_804EE9A((_BYTE *)a3) )
    {
      BYTE1(v10) = *v14;
      *v14 = 0;
      while ( byte_806CAB6[(unsigned __int8)sub_804B0AD(*v13)] )
        ++v13;
      v11 = v13;
      if ( v14 >= v13 )
      {
        if ( *(_BYTE *)(a3 + 30) )
        {
          sub_804E418(v13, &v11);
        }
        else if ( *(_BYTE *)(a3 + 28) )
        {
          v18 = strtold(v13, &v11);
        }
        else
        {
          if ( *(_BYTE *)(a3 + 26) || *(_BYTE *)(a3 + 29) )
          {
            v3 = v13 < v14 && *v13 == 45;
            v12 = &v13[v3];
            BYTE2(v10) = sub_804DEEC((char **)&v12);
            if ( BYTE2(v10) > 0x2Fu )
            {
              HIBYTE(v10) = *v12;
              v5 = *(_BYTE *)(a3 + 29) && byte_8064528[HIBYTE(v10)];
              v11 = &v12[v5];
              dword_806C2AC = (int)&loc_804F0E5;
              sub_80628B5(v4, v12);
            }
            dword_806C234 = (int)&loc_804F0E5;
            sub_8062B84(v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, LODWORD(v18), DWORD1(v18));
          }
          v11 = v14;
        }
      }
      else
      {
        v11 = v14;
      }
      *v14 = BYTE1(v10);
      v14 = v11;
    }
  }
  sub_804EDAB(a1, v15, (int)v13);
}
// 80498F0: using guessed type double __cdecl strtold(_DWORD, _DWORD);
// 804D7F1: using guessed type _DWORD __cdecl sub_804D7F1(_DWORD, _DWORD);
// 80628B5: using guessed type int __fastcall sub_80628B5(_DWORD, _DWORD);
// 8062B84: using guessed type int __stdcall sub_8062B84(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806C234: using guessed type int dword_806C234;
// 806C2AC: using guessed type int dword_806C2AC;

//----- (0804F132) --------------------------------------------------------
void __usercall __noreturn sub_804F132(int a1@<ebx>, int *a2)
{
  sub_804EEDF(a1, a2, dword_806CECA);
}
// 806CECA: using guessed type int dword_806CECA;

//----- (0804F1CB) --------------------------------------------------------
#error "804F233: call analysis failed (funcsize=64)"

//----- (0804F28C) --------------------------------------------------------
#error "804F38B: call analysis failed (funcsize=106)"

//----- (0804F3BB) --------------------------------------------------------
#error "804F5CD: call analysis failed (funcsize=546)"

//----- (0804FC84) --------------------------------------------------------
#error "8050A5A: call analysis failed (funcsize=727)"

//----- (08050A5F) --------------------------------------------------------
#error "8050A71: positive sp value has been found (funcsize=0)"

//----- (08050A7C) --------------------------------------------------------
#error "8050A82: positive sp value has been found (funcsize=0)"

//----- (08050A85) --------------------------------------------------------
#error "8050B28: call analysis failed (funcsize=71)"

//----- (08050C43) --------------------------------------------------------
unsigned int __usercall sub_8050C43@<eax>(int a1@<ebx>, int a2, FILE *stream, int a4)
{
  bool v4; // zf
  int v5; // edx
  int v6; // ecx
  void *v7; // eax
  char *v8; // eax
  char *v9; // eax
  unsigned int result; // eax
  char v11; // [esp+1Fh] [ebp-19h]
  char *ptr; // [esp+24h] [ebp-14h]
  size_t n; // [esp+28h] [ebp-10h]
  unsigned int v14; // [esp+2Ch] [ebp-Ch]

  ptr = *(char **)a2;
  n = *(_DWORD *)(a2 + 4);
  v14 = *(_DWORD *)a2 + n;
  if ( !a4 && byte_806CED2 )
  {
    if ( (unsigned int)ptr >= v14 )
      sub_804F132(a1, (int *)a2);
    v11 = *ptr;
    if ( *ptr == 9 )
    {
      v11 = 62;
    }
    else if ( ptr + 1 == (char *)v14 )
    {
      v11 = 10;
    }
    v4 = fputc_unlocked(v11, stream) == -1;
    v7 = &loc_8050CEE;
    if ( !v4 )
      v7 = &loc_8050D09;
    dword_806C2AC = (int)v7;
    sub_80628B5(v6, v5);
    v8 = gettext("write failed");
    sub_804B47B((int)v8, 0);
  }
  *(_BYTE *)(v14 - 1) = byte_806C320;
  if ( fwrite_unlocked(ptr, 1u, n, stream) != n )
  {
    v9 = gettext("write failed");
    sub_804B47B((int)v9, a4);
  }
  result = v14 - 1;
  *(_BYTE *)(v14 - 1) = 0;
  return result;
}
// 80628B5: using guessed type int __fastcall sub_80628B5(_DWORD, _DWORD);
// 806C2AC: using guessed type int dword_806C2AC;
// 806C320: using guessed type char byte_806C320;
// 806CED2: using guessed type char byte_806CED2;

//----- (08050D89) --------------------------------------------------------
#error "80510D3: call analysis failed (funcsize=243)"

//----- (0805118C) --------------------------------------------------------
#error "8051192: positive sp value has been found (funcsize=0)"

//----- (08051197) --------------------------------------------------------
#error "80511D5: call analysis failed (funcsize=82)"

//----- (080512B2) --------------------------------------------------------
#error "8051D64: call analysis failed (funcsize=600)"

//----- (08051D69) --------------------------------------------------------
#error "8051D6E: positive sp value has been found (funcsize=0)"

//----- (08051DED) --------------------------------------------------------
int __cdecl sub_8051DED(int a1, int a2, int a3, FILE *stream, int a5)
{
  int v5; // ebx
  char *v6; // eax
  int v8; // [esp+0h] [ebp-10h]
  int v9; // [esp+4h] [ebp-Ch]

  v9 = sub_8051197(a1, a3, &v8);
  if ( v9 < (unsigned int)a3 && (unsigned int)v9 <= 1 )
  {
    v5 = *(_DWORD *)(8 * v9 + a1);
    v6 = gettext("open failed");
    sub_804B47B((int)v6, v5);
  }
  sub_80512B2(a1, a2, v9, stream, a5, v8);
  return v9;
}
// 8051197: using guessed type _DWORD __cdecl sub_8051197(_DWORD, _DWORD, _DWORD);

//----- (08051F00) --------------------------------------------------------
#error "8051FE0: call analysis failed (funcsize=74)"

//----- (0805203A) --------------------------------------------------------
#error "8052157: call analysis failed (funcsize=212)"

//----- (08052345) --------------------------------------------------------
pthread_mutex_t *__usercall sub_8052345@<eax>(double a1@<st0>, unsigned int a2, int a3, int a4)
{
  pthread_mutex_t *v4; // eax
  pthread_mutex_t *v5; // ST28_4
  pthread_mutex_t *v6; // ST2C_4

  v4 = (pthread_mutex_t *)sub_805F128(144 * a2);
  v5 = v4;
  v6 = v4;
  v4->__kind = 0;
  v6->__owner = v6->__kind;
  v6->__count = v6->__owner;
  v6->__lock = v6->__count;
  v4->__nusers = 0;
  v4[1].__lock = a3;
  v6->__spins = v6[1].__lock;
  v4[1].__count = 0;
  v4[1].__nusers = 0;
  v4[1].__size[20] = 0;
  pthread_mutex_init(v4 + 2, 0);
  sub_805247F(a1, v6, v6 + 3, a4, a2, a3, 0);
  return v5;
}

//----- (0805247F) --------------------------------------------------------
int __usercall sub_805247F@<eax>(double a1@<st0>, _DWORD *a2, pthread_mutex_t *a3, int a4, unsigned int a5, int a6, char a7)
{
  unsigned int v7; // eax
  pthread_mutex_t *v8; // eax
  int v9; // eax
  int v11; // [esp+30h] [ebp-28h]
  int v12; // [esp+34h] [ebp-24h]
  int v13; // [esp+38h] [ebp-20h]
  int v14; // [esp+3Ch] [ebp-1Ch]
  pthread_mutex_t *v15; // [esp+44h] [ebp-14h]
  int v16; // [esp+64h] [ebp+Ch]

  if ( a7 )
    v7 = a2[5];
  else
    v7 = a2[6];
  v11 = v7 >> 1;
  v12 = v7 - (v7 >> 1);
  v13 = -16 * a6 + a4;
  v14 = -16 * (v7 >> 1) + v13;
  if ( a7 )
  {
    dword_806C2D8 = (int)&loc_8052514;
    sub_8062753(a1);
  }
  v8 = a3;
  v16 = (int)&a3[3];
  v15 = v8;
  v8->__owner = v13;
  v15->__lock = v15->__owner;
  v8->__kind = v14;
  v15->__count = v15->__kind;
  v8->__nusers = (unsigned int)(a2 + 3);
  v8->__spins = v11;
  v8[1].__lock = v12;
  v8[1].__count = (unsigned int)a2;
  v8[1].__nusers = a2[10] + 1;
  v8[1].__size[20] = 0;
  pthread_mutex_init(v8 + 2, 0);
  if ( a5 <= 1 )
  {
    v15[1].__owner = 0;
    v15[1].__kind = 0;
  }
  else
  {
    v15[1].__owner = v16;
    v9 = sub_805247F(v15, v16, v13, a5 >> 1, a6, 1);
    v15[1].__kind = v9;
    v16 = sub_805247F(v15, v9, v14, a5 - (a5 >> 1), a6, 0);
  }
  return v16;
}
// 8062753: using guessed type int __usercall sub_8062753@<eax>(double@<st0>);
// 806C2D8: using guessed type int dword_806C2D8;

//----- (0805267C) --------------------------------------------------------
_BOOL4 __cdecl sub_805267C(_DWORD *a1, _DWORD *a2)
{
  _BOOL4 result; // eax

  if ( a1[10] == a2[10] )
    result = a1[5] + a1[6] < (unsigned int)(a2[5] + a2[6]);
  else
    result = a1[10] < a2[10];
  return result;
}

//----- (080526FB) --------------------------------------------------------
int __cdecl sub_80526FB(pthread_mutex_t *a1)
{
  return pthread_mutex_lock(a1 + 2);
}

//----- (08052711) --------------------------------------------------------
int __cdecl sub_8052711(pthread_mutex_t *a1)
{
  return pthread_mutex_unlock(a1 + 2);
}

//----- (0805276C) --------------------------------------------------------
int __cdecl sub_805276C(int a1, int a2)
{
  *(_DWORD *)a1 = sub_8059641((int)sub_805267C, 2 * a2);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 4), 0);
  return pthread_cond_init((pthread_cond_t *)(a1 + 28), 0);
}

//----- (080527BA) --------------------------------------------------------
int __cdecl sub_80527BA(int a1, int a2)
{
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 4));
  sub_8059705(*(_DWORD *)a1, a2);
  *(_BYTE *)(a2 + 44) = 1;
  pthread_cond_signal((pthread_cond_t *)(a1 + 28));
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 4));
}

//----- (08052807) --------------------------------------------------------
void __cdecl __noreturn sub_8052807(int a1)
{
  bool v1; // zf
  void *v2; // eax
  int v3; // edx
  int v4; // ecx

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 4));
  while ( 1 )
  {
    v1 = sub_805979E(*(_DWORD **)a1) == 0;
    v2 = &loc_8052859;
    if ( v1 )
      v2 = &loc_805281D;
    dword_806C25C = (int)v2;
    sub_8062A98();
    dword_806C2AC = (int)sub_8052889;
    sub_80628B5(v4, v3);
  }
}
// 8052889: using guessed type int sub_8052889();
// 80628B5: using guessed type int __fastcall sub_80628B5(_DWORD, _DWORD);
// 806C25C: using guessed type int dword_806C25C;
// 806C2AC: using guessed type int dword_806C2AC;

//----- (080528AE) --------------------------------------------------------
unsigned int __usercall sub_80528AE@<eax>(int a1@<ebx>, int a2, FILE *stream, int a4)
{
  int v4; // edx
  int v5; // ecx

  if ( byte_806CEC8 )
  {
    if ( dword_806CAA2 && !sub_8050A85(a2, &dword_806CAA2) )
    {
      dword_806C2AC = (int)&locret_805296C;
      sub_80628B5(v5, v4);
    }
    dword_806CAA2 = *(_DWORD *)a2;
    dword_806CAA6 = *(_DWORD *)(a2 + 4);
    dword_806CAAA = *(_DWORD *)(a2 + 8);
    dword_806CAAE = *(_DWORD *)(a2 + 12);
  }
  return sub_8050C43(a1, a2, stream, a4);
}
// 8050A85: using guessed type _DWORD __cdecl sub_8050A85(_DWORD, _DWORD);
// 80628B5: using guessed type int __fastcall sub_80628B5(_DWORD, _DWORD);
// 806C2AC: using guessed type int dword_806C2AC;
// 806CAA2: using guessed type int dword_806CAA2;
// 806CAA6: using guessed type int dword_806CAA6;
// 806CAAA: using guessed type int dword_806CAAA;
// 806CAAE: using guessed type int dword_806CAAE;
// 806CEC8: using guessed type char byte_806CEC8;

//----- (0805296E) --------------------------------------------------------
#error "8052AF2: call analysis failed (funcsize=225)"

//----- (08052EBA) --------------------------------------------------------
int __cdecl sub_8052EBA(int a1, int a2)
{
  int result; // eax
  bool v3; // al
  bool v4; // al
  bool v5; // [esp+1Fh] [ebp-9h]

  result = *(unsigned __int8 *)(a2 + 44) ^ 1;
  if ( *(_BYTE *)(a2 + 44) != 1 )
  {
    v5 = (unsigned int)(*(_DWORD *)(a2 + 4) - *(_DWORD *)(a2 + 12) + 15) > 0x1E;
    if ( (unsigned int)(*(_DWORD *)a2 - *(_DWORD *)(a2 + 8) + 15) > 0x1E )
    {
      v3 = v5 || !*(_DWORD *)(a2 + 24);
      result = v3;
    }
    else
    {
      v4 = v5 && !*(_DWORD *)(a2 + 20);
      result = v4;
    }
    if ( (_BYTE)result )
      result = sub_80527BA(a1, a2);
  }
  return result;
}

//----- (08052F7B) --------------------------------------------------------
int __cdecl sub_8052F7B(int a1, _DWORD *a2)
{
  int result; // eax

  if ( a2[10] <= 1u )
  {
    result = a2[5] + a2[6];
    if ( !result )
      result = sub_80527BA(a1, a2[7]);
  }
  else
  {
    sub_80526FB((pthread_mutex_t *)a2[7]);
    sub_8052EBA(a1, a2[7]);
    result = sub_8052711((pthread_mutex_t *)a2[7]);
  }
  return result;
}

//----- (08052FF4) --------------------------------------------------------
void __cdecl __noreturn sub_8052FF4(int a1)
{
  sub_8052807(a1);
}

//----- (080530A0) --------------------------------------------------------
void *__cdecl start_routine(void *a1)
{
  int v1; // ST18_4
  int v2; // ST14_4

  v1 = *((_DWORD *)a1 + 6);
  v2 = *((_DWORD *)a1 + 5);
  sub_805311D(*(_DWORD *)a1, *((_DWORD *)a1 + 1), *((_DWORD *)a1 + 2), *((_DWORD *)a1 + 3), *((_DWORD *)a1 + 4));
  return 0;
}
// 805311D: using guessed type _DWORD __cdecl sub_805311D(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0805311D) --------------------------------------------------------
#error "8053186: call analysis failed (funcsize=38)"

//----- (0805318B) --------------------------------------------------------
#error "8053385: positive sp value has been found (funcsize=147)"

//----- (08053386) --------------------------------------------------------
int __usercall sub_8053386@<eax>(int a1@<ebx>, double st7_0@<st0>, int a2, int a3, int a4, char *s1)
{
  bool v6; // zf
  void *v7; // eax
  void *v8; // eax
  int result; // eax
  int v10; // eax
  char v11; // al
  int v12; // [esp+0h] [ebp-F8h]
  int v13; // [esp+4h] [ebp-F4h]
  int v14; // [esp+8h] [ebp-F0h]
  int v15; // [esp+Ch] [ebp-ECh]
  int v16; // [esp+10h] [ebp-E8h]
  int v17; // [esp+14h] [ebp-E4h]
  int v18; // [esp+18h] [ebp-E0h]
  int v19; // [esp+1Ch] [ebp-DCh]
  int v20; // [esp+20h] [ebp-D8h]
  FILE *stream; // [esp+24h] [ebp-D4h]
  int v22; // [esp+28h] [ebp-D0h]
  unsigned int v23; // [esp+2Ch] [ebp-CCh]
  __int64 v24; // [esp+30h] [ebp-C8h]
  __int64 v25; // [esp+88h] [ebp-70h]
  __int64 v26; // [esp+90h] [ebp-68h]
  __int64 v27; // [esp+E8h] [ebp-10h]

  BYTE1(v20) = 0;
  v22 = 0;
  v23 = a3;
  result = v23;
  if ( v23 >= a4 )
    return result;
  HIBYTE(v20) = strcmp(*(const char **)(8 * v23 + a2), "-") == 0;
  if ( s1 )
  {
    v6 = strcmp(s1, *(const char **)(8 * v23 + a2)) == 0;
    v7 = &loc_8053429;
    if ( !v6 )
      v7 = &loc_805346C;
    dword_806C25C = (int)v7;
    sub_8062A98();
    v8 = &loc_8053460;
    if ( HIBYTE(v20) == 1 )
      v8 = &loc_805346C;
    dword_806C2D8 = (int)v8;
    sub_8062753(st7_0);
    for ( BYTE2(v20) = 1; ; BYTE2(v20) = v11 & 1 )
    {
      if ( BYTE2(v20) )
      {
        if ( !v22 )
        {
          v22 = sub_804C46E(a1, &stream);
          a1 = 8 * v23;
          sub_8051DED(8 * v23 + a2, 0, 1, stream, v22 + 9);
        }
        *(_DWORD *)(8 * v23 + a2) = v22 + 9;
        *(_DWORD *)(a2 + 8 * v23 + 4) = v22;
      }
      ++v23;
      dword_806C234 = (int)&loc_805365E;
      v10 = sub_8062B84(v12, v13, v14, v15, v16, v17, v18, v19, v20, stream, v22, v23, v24, HIDWORD(v24));
LABEL_13:
      if ( !v10 )
      {
LABEL_14:
        a1 = HIDWORD(v27);
        if ( v27 == v25 )
        {
          a1 = HIDWORD(v26);
          if ( v26 == v24 )
          {
            v11 = 1;
            continue;
          }
        }
      }
LABEL_17:
      v11 = 0;
    }
  }
  result = sub_8062617(1, (int)&v24);
  if ( !result )
  {
    BYTE1(v20) = 1;
    if ( HIBYTE(v20) )
    {
      if ( !sub_8062617(0, (int)&v26) )
        goto LABEL_14;
      goto LABEL_17;
    }
    v10 = sub_80625E8(*(_DWORD *)(8 * v23 + a2), (int)&v26);
    goto LABEL_13;
  }
  return result;
}
// 8062753: using guessed type int __usercall sub_8062753@<eax>(double@<st0>);
// 8062B84: using guessed type int __stdcall sub_8062B84(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806C234: using guessed type int dword_806C234;
// 806C25C: using guessed type int dword_806C25C;
// 806C2D8: using guessed type int dword_806C2D8;

//----- (08053677) --------------------------------------------------------
unsigned int __cdecl sub_8053677(int a1, unsigned int a2)
{
  int v2; // ebx
  char *v3; // eax
  unsigned int result; // eax
  unsigned int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a2 )
      break;
    if ( strcmp(*(const char **)(4 * i + a1), "-") && euidaccess(*(_DWORD *)(4 * i + a1), 4) )
    {
      v2 = *(_DWORD *)(4 * i + a1);
      v3 = gettext("cannot read");
      sub_804B47B((int)v3, v2);
    }
  }
  return result;
}
// 8049E00: using guessed type int __cdecl euidaccess(_DWORD, _DWORD);

//----- (08053712) --------------------------------------------------------
void __cdecl sub_8053712(int a1)
{
  char *v1; // eax
  int fd; // [esp+1Ch] [ebp-Ch]

  if ( a1 )
  {
    fd = open64(a1, 524353);
    if ( fd < 0 )
    {
      v1 = gettext("open failed");
      sub_804B47B((int)v1, a1);
    }
    sub_804C0DA(fd, 1);
  }
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);

//----- (08053788) --------------------------------------------------------
int __usercall sub_8053788@<eax>(FILE *a1@<ebx>, double st7_0@<st0>, int a2, int a3, int a4, char *s1)
{
  int v6; // eax
  int v7; // esi
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // ebx
  int v12; // eax
  int v13; // eax
  int v14; // eax
  char *v16; // eax
  int v17; // ebx
  char *v18; // eax
  int v19; // eax
  int v20; // eax
  int v21; // [esp+28h] [ebp-50h]
  FILE *v22; // [esp+2Ch] [ebp-4Ch]
  int v23; // [esp+30h] [ebp-48h]
  unsigned int v24; // [esp+34h] [ebp-44h]
  int v25; // [esp+38h] [ebp-40h]
  int v26; // [esp+3Ch] [ebp-3Ch]
  unsigned int v27; // [esp+40h] [ebp-38h]
  int v28; // [esp+44h] [ebp-34h]
  unsigned int v29; // [esp+48h] [ebp-30h]
  int v30; // [esp+4Ch] [ebp-2Ch]
  int v31; // [esp+50h] [ebp-28h]
  unsigned int v32; // [esp+54h] [ebp-24h]
  FILE *stream; // [esp+58h] [ebp-20h]
  int v34; // [esp+5Ch] [ebp-1Ch]
  int v35; // [esp+84h] [ebp+Ch]

  while ( dword_806C3A8 < (unsigned int)a4 )
  {
    v23 = 0;
    v24 = 0;
    while ( a4 - v23 >= (unsigned int)dword_806C3A8 )
    {
      v6 = sub_804C46E((int)a1, &v22);
      v26 = v6;
      v7 = v6 + 9;
      a1 = v22;
      v8 = a3;
      if ( dword_806C3A8 <= (unsigned int)a3 )
        v8 = dword_806C3A8;
      v27 = sub_8051DED(8 * v23 + a2, v8, dword_806C3A8, v22, v7);
      v9 = a3;
      if ( v27 <= a3 )
        v9 = v27;
      a3 -= v9;
      *(_DWORD *)(8 * v24 + a2) = v26 + 9;
      *(_DWORD *)(a2 + 8 * v24 + 4) = v26;
      v23 += v27;
      ++v24;
    }
    v28 = a4 - v23;
    v29 = dword_806C3A8 - v24 % dword_806C3A8;
    if ( v29 < a4 - v23 )
    {
      v30 = v28 - v29 + 1;
      v10 = sub_804C46E(dword_806C3A8, &v22);
      v31 = v10;
      v11 = v10 + 9;
      v12 = a3;
      if ( v30 <= (unsigned int)a3 )
        v12 = v30;
      v32 = sub_8051DED(8 * v23 + a2, v12, v30, v22, v11);
      v13 = a3;
      if ( v32 <= a3 )
        v13 = v32;
      a3 -= v13;
      *(_DWORD *)(8 * v24 + a2) = v31 + 9;
      v14 = v24++;
      *(_DWORD *)(a2 + 8 * v14 + 4) = v31;
      v23 += v32;
    }
    a1 = (FILE *)(8 * v24);
    memmove((void *)(8 * v24 + a2), (const void *)(a2 + 8 * v23), 8 * (a4 - v23));
    a3 += v24;
    a4 += v24 - v23;
  }
  sub_8053386((int)a1, st7_0, a2, a3, a4, s1);
  while ( 1 )
  {
    v25 = sub_8051197(a2, a4, &v21);
    if ( v25 == a4 )
      break;
    if ( (unsigned int)v25 <= 2 )
    {
      v17 = *(_DWORD *)(8 * v25 + a2);
      v18 = gettext("open failed");
      sub_804B47B((int)v18, v17);
    }
    do
    {
LABEL_28:
      --v25;
      sub_804BFFB(*(FILE **)(4 * v25 + v21), *(_DWORD *)(8 * v25 + a2));
      v34 = sub_804C2E9((int)a1, &v22, (unsigned int)v25 > 2);
    }
    while ( !v34 );
    a1 = (FILE *)(v34 + 9);
    v19 = a3;
    if ( v25 <= (unsigned int)a3 )
      v19 = v25;
    sub_80512B2(a2, v19, v25, v22, v34 + 9, v21);
    v20 = a3;
    if ( v25 <= (unsigned int)a3 )
      v20 = v25;
    v35 = a3 - v20;
    *(_DWORD *)a2 = v34 + 9;
    *(_DWORD *)(a2 + 4) = v34;
    memmove((void *)(a2 + 8), (const void *)(a2 + 8 * v25), 8 * (a4 - v25));
    a3 = v35 + 1;
    a4 = a4 - v25 + 1;
  }
  stream = sub_804BE65(s1, "w");
  if ( !stream )
  {
    if ( *__errno_location() != 24 || (unsigned int)v25 <= 2 )
    {
      v16 = gettext("open failed");
      sub_804B47B((int)v16, (int)s1);
    }
    goto LABEL_28;
  }
  return sub_80512B2(a2, a3, a4, stream, (int)s1, v21);
}
// 8051197: using guessed type _DWORD __cdecl sub_8051197(_DWORD, _DWORD, _DWORD);

//----- (08053C25) --------------------------------------------------------
unsigned int __usercall sub_8053C25@<eax>(FILE *a1@<ebx>, double a2@<st0>, char **a3, int a4, char *a5, unsigned int a6)
{
  int v6; // edx
  int v7; // ecx
  void *v8; // eax
  size_t v9; // eax
  char **v11; // [esp+4h] [ebp-BCh]
  char v12; // [esp+17h] [ebp-A9h]
  FILE *stream; // [esp+18h] [ebp-A8h]
  FILE *v14; // [esp+1Ch] [ebp-A4h]
  int v15; // [esp+20h] [ebp-A0h]
  int v16; // [esp+24h] [ebp-9Ch]
  int v17; // [esp+28h] [ebp-98h]
  unsigned int v18; // [esp+2Ch] [ebp-94h]
  int v19; // [esp+30h] [ebp-90h]
  int *v20; // [esp+34h] [ebp-8Ch]
  int v21; // [esp+38h] [ebp-88h]
  char *s1; // [esp+3Ch] [ebp-84h]
  int v23; // [esp+40h] [ebp-80h]
  pthread_mutex_t *v24; // [esp+44h] [ebp-7Ch]
  void *v25; // [esp+48h] [ebp-78h]
  void *ptr; // [esp+4Ch] [ebp-74h]
  int v27; // [esp+50h] [ebp-70h]
  unsigned int v28; // [esp+54h] [ebp-6Ch]
  int v29; // [esp+58h] [ebp-68h]
  int v30; // [esp+5Ch] [ebp-64h]
  char v31; // [esp+64h] [ebp-5Ch]
  char v32; // [esp+68h] [ebp-58h]
  unsigned int v33; // [esp+B4h] [ebp-Ch]
  FILE *v34; // [esp+BCh] [ebp-4h]

  v34 = a1;
  v11 = a3;
  v33 = __readgsdword(0x14u);
  v15 = 0;
  v12 = 0;
  v29 = 0;
  while ( a4 )
  {
    s1 = *v11;
    stream = sub_804BFBA(s1, "r");
    if ( a6 <= 1 )
    {
      v17 = 24;
    }
    else
    {
      v18 = 1;
      v19 = 1;
      while ( v18 < a6 )
      {
        v18 *= 2;
        ++v19;
      }
      v17 = 16 * v19;
    }
    v8 = &loc_8053D24;
    if ( v29 )
      v8 = &loc_8053D6E;
    dword_806C2AC = (int)v8;
    sub_80628B5(v7, v6);
    v9 = sub_804D395(&stream, 1, v11, a4, v17);
    sub_804D595((int)&ptr, v17, v9);
    v31 = 0;
    ++v11;
    --a4;
    while ( (unsigned __int8)sub_804D9F4((int)&ptr, stream, (int)s1) )
    {
      if ( v31 && a4 && v17 + 1 < v29 - v27 - v17 * v28 )
      {
        v30 = v27;
        break;
      }
      dword_806CAA2 = 0;
      v23 = sub_804D637(&ptr);
      if ( !v31 || a4 || v15 || v30 )
      {
        ++v15;
        v16 = sub_804C46E((int)a1, &v14) + 9;
      }
      else
      {
        sub_804BFFB(stream, (int)s1);
        v14 = sub_804BFBA(a5, "w");
        v16 = (int)a5;
        v12 = 1;
      }
      if ( v28 <= 1 )
      {
        sub_80528AE((int)a1, v23 - 16, v14, v16);
      }
      else
      {
        sub_805276C((int)&v32, a6);
        v24 = sub_8052345(a2, a6, v28, v23);
        a1 = (FILE *)&v24[3];
        sub_805311D(v23, a6, v28, &v24[3], &v32);
      }
      sub_804BFFB(v14, v16);
      if ( v12 )
        goto LABEL_28;
    }
    sub_804BFFB(stream, (int)s1);
  }
LABEL_28:
  free(ptr);
  if ( v12 != 1 )
  {
    v20 = (int *)dword_806CF56;
    v25 = sub_805EFEF(v15, 8u);
    v21 = 0;
    dword_806C2D8 = (int)&loc_8054053;
    sub_8062753(a2);
    do
    {
      *((_DWORD *)v25 + 2 * v21) = (char *)v20 + 9;
      *((_DWORD *)v25 + 2 * v21 + 1) = v20;
      v20 = (int *)*v20;
      ++v21;
    }
    while ( v20 );
    sub_8053788(a1, a2, (int)v25, v15, v15, a5);
    free(v25);
  }
  sub_804BB14();
  return __readgsdword(0x14u) ^ v33;
}
// 804D395: using guessed type _DWORD __cdecl sub_804D395(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 805311D: using guessed type _DWORD __cdecl sub_805311D(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8062753: using guessed type int __usercall sub_8062753@<eax>(double@<st0>);
// 80628B5: using guessed type int __fastcall sub_80628B5(_DWORD, _DWORD);
// 806C2AC: using guessed type int dword_806C2AC;
// 806C2D8: using guessed type int dword_806C2D8;
// 806CAA2: using guessed type int dword_806CAA2;
// 806CF56: using guessed type int dword_806CF56;

//----- (080540AF) --------------------------------------------------------
_DWORD *__cdecl sub_80540AF(void *src)
{
  int v1; // edx
  int v2; // ecx
  void *v3; // eax
  _DWORD *result; // eax
  _DWORD *v5; // [esp+1Ch] [ebp-Ch]

  v5 = sub_805F2B7(src, 0x28u);
  v3 = &loc_8054101;
  if ( dword_806CECA )
    v3 = &loc_80540D4;
  dword_806C284 = (int)v3;
  sub_80629B0(v2, v1);
  dword_806CECA = (int)v5;
  result = v5;
  v5[9] = 0;
  return result;
}
// 806C284: using guessed type int dword_806C284;
// 806CECA: using guessed type int dword_806CECA;

//----- (08054115) --------------------------------------------------------
#error "8054143: call analysis failed (funcsize=25)"

//----- (0805416E) --------------------------------------------------------
#error "8054177: call analysis failed (funcsize=4)"

//----- (08054188) --------------------------------------------------------
int __cdecl sub_8054188(int a1)
{
  char *v1; // eax

  v1 = gettext("options '-%s' are incompatible");
  error(2, 0, v1, a1);
  return sub_80541B9();
}
// 80541B9: using guessed type int sub_80541B9(void);

//----- (080541B9) --------------------------------------------------------
#error "8054273: call analysis failed (funcsize=72)"

//----- (080542DC) --------------------------------------------------------
int __usercall sub_80542DC@<eax>(double a1@<st0>, char *nptr, int a3, char *msgid)
{
  int v4; // ecx
  void *v5; // eax
  void *v6; // esi
  char *v7; // ebx
  char *v8; // eax
  int result; // eax
  int v10; // [esp-8h] [ebp-40h]
  int v11; // [esp-4h] [ebp-3Ch]
  int v12; // [esp+0h] [ebp-38h]
  int v13; // [esp+4h] [ebp-34h]
  int v14; // [esp+8h] [ebp-30h]
  char *v15; // [esp+Ch] [ebp-2Ch]
  void *v16; // [esp+10h] [ebp-28h]
  int v17; // [esp+14h] [ebp-24h]
  int v18; // [esp+18h] [ebp-20h]
  int v19; // [esp+1Ch] [ebp-1Ch]
  int v20; // [esp+20h] [ebp-18h]
  int v21; // [esp+24h] [ebp-14h]
  __int64 v22; // [esp+28h] [ebp-10h]

  switch ( sub_805FE21(nptr, (int)(&v12 - 5), 10, (int)(&v12 - 4), &locale) )
  {
    case 0:
    case 2:
      *(_DWORD *)a3 = v22;
      v4 = *(_DWORD *)a3;
      v11 = HIDWORD(v22) | *(_DWORD *)a3 ^ v22;
      v10 = 0;
      v5 = &loc_8054383;
      if ( v22 != v4 )
        v5 = &loc_805439A;
      dword_806C2D8 = (int)v5;
      sub_8062753(a1);
      dword_806C298 = (int)&loc_80543F8;
      sub_8062925(v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22);
      goto LABEL_5;
    case 1:
    case 3:
LABEL_5:
      *(_DWORD *)a3 = -1;
      goto LABEL_9;
    case 4:
      if ( msgid )
      {
        v6 = sub_805C62A(nptr);
        v7 = gettext(msgid);
        v8 = gettext("%s: invalid count at start of %s");
        v16 = v6;
        v15 = v7;
        error(2, 0, v8, v7, v6);
      }
      result = 0;
      break;
    default:
LABEL_9:
      result = v21;
      break;
  }
  return result;
}
// 8062753: using guessed type int __usercall sub_8062753@<eax>(double@<st0>);
// 8062925: using guessed type int __stdcall sub_8062925(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806C298: using guessed type int dword_806C298;
// 806C2D8: using guessed type int dword_806C2D8;

//----- (08054402) --------------------------------------------------------
int __usercall sub_8054402@<eax>(int a1@<edx>, int a2@<ecx>, int sig)
{
  sub_804BB43(a2, a1);
  signal(sig, 0);
  return raise(sig);
}

//----- (0805442D) --------------------------------------------------------
#error "80544CD: call analysis failed (funcsize=91)"

//----- (08054563) --------------------------------------------------------
void *__cdecl sub_8054563(void *s)
{
  memset(s, 0, 0x28u);
  *((_DWORD *)s + 2) = -1;
  return s;
}

//----- (08054593) --------------------------------------------------------
#error "8054800: call analysis failed (funcsize=141)"

//----- (08054805) --------------------------------------------------------
#error "8054846: call analysis failed (funcsize=1296)"

//----- (08055E00) --------------------------------------------------------
void __noreturn sub_8055E00()
{
  sub_804B4DD(1);
}

//----- (08055E14) --------------------------------------------------------
#error "8055E6A: call analysis failed (funcsize=39)"

//----- (08055FA7) --------------------------------------------------------
void __cdecl sub_8055FA7(char *a1, char *a2, int a3)
{
  char *v3; // eax
  char *format; // ST2C_4
  void *v5; // ebx
  void *v6; // eax

  if ( a3 == -1 )
    v3 = gettext("invalid argument %s for %s");
  else
    v3 = gettext("ambiguous argument %s for %s");
  format = v3;
  v5 = sub_805C608(1, a1);
  v6 = sub_805C058(0, 8, a2);
  error(0, 0, format, v6, v5);
}

//----- (0805602A) --------------------------------------------------------
int __cdecl sub_805602A(int a1, int a2, size_t n)
{
  FILE *v3; // ebx
  char *v4; // eax
  bool v5; // zf
  void *v6; // eax
  const void *v8; // [esp+4h] [ebp-24h]
  void *v9; // [esp+8h] [ebp-20h]
  int i; // [esp+18h] [ebp-10h]
  void *s1; // [esp+1Ch] [ebp-Ch]

  s1 = 0;
  v3 = stderr;
  v4 = gettext("Valid arguments are:");
  fputs_unlocked(v4, v3);
  for ( i = 0; *(_DWORD *)(4 * i + a1); ++i )
  {
    if ( i )
    {
      v8 = (const void *)(a2 + i * n);
      v5 = memcmp(s1, v8, n) == 0;
      v6 = &loc_80560B9;
      if ( v5 )
        v6 = &loc_80560FF;
      dword_806C2EC = (int)v6;
      sub_80626B4();
    }
    v9 = sub_805C62A(*(char **)(4 * i + a1));
    fprintf(stderr, "\n  - %s", v9);
    s1 = (void *)(i * n + a2);
  }
  return putc_unlocked(10, stderr);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 80626B4: using guessed type int sub_80626B4(void);
// 806C2EC: using guessed type int dword_806C2EC;

//----- (0805618B) --------------------------------------------------------
int __cdecl sub_805618B(void *s1, char *s, int a3, size_t n, size_t a5, int a6)
{
  int i; // eax
  int v8; // [esp+1Ch] [ebp-Ch]

  v8 = sub_8055E14(s, a3, n, a5);
  if ( v8 >= 0 )
    return v8;
  sub_8055FA7((char *)s1, s, v8);
  sub_805602A(a3, n, a5);
  ((void (*)(void))a6)();
  dword_806C25C = (int)&locret_8056270;
  for ( i = sub_8062A98(); ; i = memcmp(s1, (const void *)(a3 + v8 * n), n) )
  {
    if ( !i )
      return *(_DWORD *)&s[4 * v8];
    if ( !*(_DWORD *)&s[4 * ++v8] )
      break;
  }
  return 0;
}
// 806C25C: using guessed type int dword_806C25C;

//----- (080562CB) --------------------------------------------------------
#error "80562F7: call analysis failed (funcsize=64)"

//----- (080563B5) --------------------------------------------------------
#error "80563D6: positive sp value has been found (funcsize=0)"

//----- (080563D9) --------------------------------------------------------
#error "8056401: call analysis failed (funcsize=14)"

//----- (08056406) --------------------------------------------------------
#error "8056449: positive sp value has been found (funcsize=0)"

//----- (0805644A) --------------------------------------------------------
_DWORD *__cdecl sub_805644A(_DWORD *a1, int a2)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = a2;
  return result;
}

//----- (08056457) --------------------------------------------------------
_DWORD *__cdecl sub_8056457(int *a1, _DWORD *a2)
{
  sub_805644A(a2, *a1);
  sub_805644A(a2 + 1, a1[1]);
  sub_805644A(a2 + 2, a1[2]);
  sub_805644A(a2 + 3, a1[3]);
  return a2;
}

//----- (08056505) --------------------------------------------------------
#error "805652D: call analysis failed (funcsize=86)"

//----- (08056818) --------------------------------------------------------
#error "80568C1: call analysis failed (funcsize=139)"

//----- (08056A87) --------------------------------------------------------
int *__cdecl sub_8056A87(int a1, unsigned int a2, int *a3)
{
  int v3; // ST10_4
  int v4; // ST14_4
  int v5; // ST18_4
  int v6; // ST1C_4
  int v7; // ST30_4
  int v8; // ST34_4
  int v9; // ST38_4
  int v10; // ST3C_4
  int v11; // ST40_4
  int v12; // ST10_4
  int *v13; // ST0C_4
  int v14; // ST10_4
  int v15; // ST1C_4
  int v16; // ST18_4
  int v17; // ST14_4
  int v18; // ST10_4
  int v19; // ST1C_4
  int v20; // ST18_4
  int v21; // ST14_4
  int v22; // ST10_4
  int v23; // ST1C_4
  int v24; // ST18_4
  int v25; // ST14_4
  int v26; // ST10_4
  int v27; // ST1C_4
  int v28; // ST18_4
  int v29; // ST14_4
  int v30; // ST10_4
  int v31; // ST1C_4
  int v32; // ST18_4
  int v33; // ST14_4
  int v34; // ST10_4
  int v35; // ST1C_4
  int v36; // ST18_4
  int v37; // ST14_4
  int v38; // ST10_4
  int v39; // ST1C_4
  int v40; // ST18_4
  int v41; // ST14_4
  int v42; // ST10_4
  int v43; // ST1C_4
  int v44; // ST18_4
  int v45; // ST14_4
  int v46; // ST10_4
  int v47; // ST1C_4
  int v48; // ST18_4
  int v49; // ST14_4
  int v50; // ST10_4
  int v51; // ST1C_4
  int v52; // ST18_4
  int v53; // ST14_4
  int v54; // ST10_4
  int v55; // ST1C_4
  int v56; // ST18_4
  int v57; // ST14_4
  int v58; // ST10_4
  int v59; // ST1C_4
  int v60; // ST18_4
  int v61; // ST14_4
  int v62; // ST10_4
  int v63; // ST1C_4
  int v64; // ST18_4
  int v65; // ST14_4
  int v66; // ST10_4
  int v67; // ST1C_4
  int v68; // ST18_4
  int v69; // ST14_4
  int v70; // ST10_4
  int v71; // ST1C_4
  int v72; // ST18_4
  int v73; // ST14_4
  int v74; // ST10_4
  int v75; // ST1C_4
  int v76; // ST18_4
  int v77; // ST14_4
  int *result; // eax
  int v79; // [esp+0h] [ebp-80h]
  int v80; // [esp+4h] [ebp-7Ch]
  int v81; // [esp+8h] [ebp-78h]
  int *v82; // [esp+Ch] [ebp-74h]
  int v83; // [esp+10h] [ebp-70h]
  int v84; // [esp+14h] [ebp-6Ch]
  int v85; // [esp+18h] [ebp-68h]
  int v86; // [esp+1Ch] [ebp-64h]
  unsigned int v87; // [esp+24h] [ebp-5Ch]
  int v88; // [esp+2Ch] [ebp-54h]
  int v89; // [esp+30h] [ebp-50h]
  int v90; // [esp+34h] [ebp-4Ch]
  int v91; // [esp+44h] [ebp-3Ch]
  int v92; // [esp+48h] [ebp-38h]
  int v93; // [esp+4Ch] [ebp-34h]
  int v94; // [esp+50h] [ebp-30h]
  int v95; // [esp+54h] [ebp-2Ch]
  int v96; // [esp+58h] [ebp-28h]
  int v97; // [esp+5Ch] [ebp-24h]
  int v98; // [esp+60h] [ebp-20h]
  int v99; // [esp+64h] [ebp-1Ch]
  int v100; // [esp+68h] [ebp-18h]
  int v101; // [esp+6Ch] [ebp-14h]
  int v102; // [esp+70h] [ebp-10h]
  int v103; // [esp+74h] [ebp-Ch]
  int v104; // [esp+78h] [ebp-8h]
  int v105; // [esp+7Ch] [ebp-4h]

  v3 = *a3;
  v4 = a3[1];
  v5 = a3[2];
  v6 = a3[3];
  a3[4] += a2;
  a3[5] += a3[4] < a2;
  dword_806C234 = (int)&loc_8057752;
  sub_8062B84(v79, v80, v81, a1, v3, v4, v5, v6, a2 >> 2, 4 * (a2 >> 2) + a1, a2, v88, v89, v90);
  do
  {
    v7 = v83;
    v8 = v84;
    v9 = v85;
    v10 = v86;
    v11 = *v82;
    v12 = (v86 ^ v84 & (v85 ^ v86)) + *v82 + v83 - 680876936;
    v13 = v82 + 1;
    v14 = v84 + __ROR4__(v12, 25);
    v91 = *v13;
    ++v13;
    v15 = v14 + __ROR4__((v85 ^ v14 & (v84 ^ v85)) + v91 + v86 - 389564586, 20);
    v92 = *v13;
    ++v13;
    v16 = v15 + __ROR4__((v84 ^ v15 & (v14 ^ v84)) + v92 + v85 + 606105819, 15);
    v93 = *v13;
    ++v13;
    v17 = v16 + __ROR4__((v14 ^ v16 & (v15 ^ v14)) + v93 + v84 - 1044525330, 10);
    v94 = *v13;
    ++v13;
    v18 = v17 + __ROR4__((v15 ^ v17 & (v16 ^ v15)) + v94 + v14 - 176418897, 25);
    v95 = *v13;
    ++v13;
    v19 = v18 + __ROR4__((v16 ^ v18 & (v17 ^ v16)) + v95 + v15 + 1200080426, 20);
    v96 = *v13;
    ++v13;
    v20 = v19 + __ROR4__((v17 ^ v19 & (v18 ^ v17)) + v96 + v16 - 1473231341, 15);
    v97 = *v13;
    ++v13;
    v21 = v20 + __ROR4__((v18 ^ v20 & (v19 ^ v18)) + v97 + v17 - 45705983, 10);
    v98 = *v13;
    ++v13;
    v22 = v21 + __ROR4__((v19 ^ v21 & (v20 ^ v19)) + v98 + v18 + 1770035416, 25);
    v99 = *v13;
    ++v13;
    v23 = v22 + __ROR4__((v20 ^ v22 & (v21 ^ v20)) + v99 + v19 - 1958414417, 20);
    v100 = *v13;
    ++v13;
    v24 = v23 + __ROR4__((v21 ^ v23 & (v22 ^ v21)) + v100 + v20 - 42063, 15);
    v101 = *v13;
    ++v13;
    v25 = v24 + __ROR4__((v22 ^ v24 & (v23 ^ v22)) + v101 + v21 - 1990404162, 10);
    v102 = *v13;
    ++v13;
    v26 = v25 + __ROR4__((v23 ^ v25 & (v24 ^ v23)) + v102 + v22 + 1804603682, 25);
    v103 = *v13;
    ++v13;
    v27 = v26 + __ROR4__((v24 ^ v26 & (v25 ^ v24)) + v103 + v23 - 40341101, 20);
    v104 = *v13;
    ++v13;
    v28 = v27 + __ROR4__((v25 ^ v27 & (v26 ^ v25)) + v104 + v24 - 1502002290, 15);
    v105 = *v13;
    v82 = v13 + 1;
    v29 = v28 + __ROR4__((v26 ^ v28 & (v27 ^ v26)) + v105 + v25 + 1236535329, 10);
    v30 = v29 + __ROR4__(v91 + (v28 ^ v27 & (v29 ^ v28)) + v26 - 165796510, 27);
    v31 = v30 + __ROR4__(v96 + (v29 ^ v28 & (v30 ^ v29)) + v27 - 1069501632, 23);
    v32 = v31 + __ROR4__(v101 + (v30 ^ v29 & (v31 ^ v30)) + v28 + 643717713, 18);
    v33 = v32 + __ROR4__(v11 + (v31 ^ v30 & (v32 ^ v31)) + v29 - 373897302, 12);
    v34 = v33 + __ROR4__(v95 + (v32 ^ v31 & (v33 ^ v32)) + v30 - 701558691, 27);
    v35 = v34 + __ROR4__(v100 + (v33 ^ v32 & (v34 ^ v33)) + v31 + 38016083, 23);
    v36 = v35 + __ROR4__(v105 + (v34 ^ v33 & (v35 ^ v34)) + v32 - 660478335, 18);
    v37 = v36 + __ROR4__(v94 + (v35 ^ v34 & (v36 ^ v35)) + v33 - 405537848, 12);
    v38 = v37 + __ROR4__(v99 + (v36 ^ v35 & (v37 ^ v36)) + v34 + 568446438, 27);
    v39 = v38 + __ROR4__(v104 + (v37 ^ v36 & (v38 ^ v37)) + v35 - 1019803690, 23);
    v40 = v39 + __ROR4__(v93 + (v38 ^ v37 & (v39 ^ v38)) + v36 - 187363961, 18);
    v41 = v40 + __ROR4__(v98 + (v39 ^ v38 & (v40 ^ v39)) + v37 + 1163531501, 12);
    v42 = v41 + __ROR4__(v103 + (v40 ^ v39 & (v41 ^ v40)) + v38 - 1444681467, 27);
    v43 = v42 + __ROR4__(v92 + (v41 ^ v40 & (v42 ^ v41)) + v39 - 51403784, 23);
    v44 = v43 + __ROR4__(v97 + (v42 ^ v41 & (v43 ^ v42)) + v40 + 1735328473, 18);
    v45 = v44 + __ROR4__(v102 + (v43 ^ v42 & (v44 ^ v43)) + v41 - 1926607734, 12);
    v46 = v45 + __ROR4__(v95 + (v43 ^ v45 ^ v44) + v42 - 378558, 28);
    v47 = v46 + __ROR4__(v98 + (v44 ^ v46 ^ v45) + v43 - 2022574463, 21);
    v48 = v47 + __ROR4__(v101 + (v45 ^ v47 ^ v46) + v44 + 1839030562, 16);
    v49 = v48 + __ROR4__(v104 + (v46 ^ v48 ^ v47) + v45 - 35309556, 9);
    v50 = v49 + __ROR4__(v91 + (v47 ^ v49 ^ v48) + v46 - 1530992060, 28);
    v51 = v50 + __ROR4__(v94 + (v48 ^ v50 ^ v49) + v47 + 1272893353, 21);
    v52 = v51 + __ROR4__(v97 + (v49 ^ v51 ^ v50) + v48 - 155497632, 16);
    v53 = v52 + __ROR4__(v100 + (v50 ^ v52 ^ v51) + v49 - 1094730640, 9);
    v54 = v53 + __ROR4__(v103 + (v51 ^ v53 ^ v52) + v50 + 681279174, 28);
    v55 = v54 + __ROR4__(v11 + (v52 ^ v54 ^ v53) + v51 - 358537222, 21);
    v56 = v55 + __ROR4__(v93 + (v53 ^ v55 ^ v54) + v52 - 722521979, 16);
    v57 = v56 + __ROR4__(v96 + (v54 ^ v56 ^ v55) + v53 + 76029189, 9);
    v58 = v57 + __ROR4__(v99 + (v55 ^ v57 ^ v56) + v54 - 640364487, 28);
    v59 = v58 + __ROR4__(v102 + (v56 ^ v58 ^ v57) + v55 - 421815835, 21);
    v60 = v59 + __ROR4__(v105 + (v57 ^ v59 ^ v58) + v56 + 530742520, 16);
    v61 = v60 + __ROR4__(v92 + (v58 ^ v60 ^ v59) + v57 - 995338651, 9);
    v62 = v61 + __ROR4__(v11 + (v60 ^ (v61 | ~v59)) + v58 - 198630844, 26);
    v63 = v62 + __ROR4__(v97 + (v61 ^ (v62 | ~v60)) + v59 + 1126891415, 22);
    v64 = v63 + __ROR4__(v104 + (v62 ^ (v63 | ~v61)) + v60 - 1416354905, 17);
    v65 = v64 + __ROR4__(v95 + (v63 ^ (v64 | ~v62)) + v61 - 57434055, 11);
    v66 = v65 + __ROR4__(v102 + (v64 ^ (v65 | ~v63)) + v62 + 1700485571, 26);
    v67 = v66 + __ROR4__(v93 + (v65 ^ (v66 | ~v64)) + v63 - 1894986606, 22);
    v68 = v67 + __ROR4__(v100 + (v66 ^ (v67 | ~v65)) + v64 - 1051523, 17);
    v69 = v68 + __ROR4__(v91 + (v67 ^ (v68 | ~v66)) + v65 - 2054922799, 11);
    v70 = v69 + __ROR4__(v98 + (v68 ^ (v69 | ~v67)) + v66 + 1873313359, 26);
    v71 = v70 + __ROR4__(v105 + (v69 ^ (v70 | ~v68)) + v67 - 30611744, 22);
    v72 = v71 + __ROR4__(v96 + (v70 ^ (v71 | ~v69)) + v68 - 1560198380, 17);
    v73 = v72 + __ROR4__(v103 + (v71 ^ (v72 | ~v70)) + v69 + 1309151649, 11);
    v74 = v73 + __ROR4__(v94 + (v72 ^ (v73 | ~v71)) + v70 - 145523070, 26);
    v75 = v74 + __ROR4__(v101 + (v73 ^ (v74 | ~v72)) + v71 - 1120210379, 22);
    v76 = v75 + __ROR4__(v92 + (v74 ^ (v75 | ~v73)) + v72 + 718787259, 17);
    v77 = v76 + __ROR4__(v99 + (v75 ^ (v76 | ~v74)) + v73 - 343485551, 11);
    v83 = v7 + v74;
    v84 = v8 + v77;
    v85 = v9 + v76;
    v86 = v10 + v75;
  }
  while ( (unsigned int)v82 < v87 );
  *a3 = v83;
  a3[1] = v84;
  a3[2] = v85;
  result = a3;
  a3[3] = v86;
  return result;
}
// 8062B84: using guessed type int __stdcall sub_8062B84(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806C234: using guessed type int dword_806C234;

//----- (08057793) --------------------------------------------------------
int __cdecl sub_8057793(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // [esp+18h] [ebp-34h]
  int v8; // [esp+1Ch] [ebp-30h]
  int v9; // [esp+30h] [ebp-1Ch]
  int v10; // [esp+34h] [ebp-18h]
  int v11; // [esp+38h] [ebp-14h]
  int v12; // [esp+3Ch] [ebp-10h]
  int v13; // [esp+40h] [ebp-Ch]
  int v14; // [esp+44h] [ebp-8h]

  return posix_fadvise64(a1, a2, a3, a4, a5, a6, v7, v8, a4, a5, a2, a3, v9, v10, v11, v12, v13, v14);
}
// 8049E60: using guessed type int __stdcall posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (080577F4) --------------------------------------------------------
int __cdecl sub_80577F4(FILE *stream)
{
  int v1; // ST00_4
  int result; // eax
  int v3; // [esp+4h] [ebp-24h]
  int v4; // [esp+8h] [ebp-20h]
  int v5; // [esp+Ch] [ebp-1Ch]
  int v6; // [esp+10h] [ebp-18h]
  int v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+18h] [ebp-10h]
  int v9; // [esp+1Ch] [ebp-Ch]
  int v10; // [esp+20h] [ebp-8h]
  int v11; // [esp+24h] [ebp-4h]
  int savedregs; // [esp+28h] [ebp+0h]

  if ( stream )
  {
    fileno(stream);
    dword_806C248 = (int)sub_8057867;
    result = sub_8062B10(v1, v3, v4, v5, v6, v7, v8, v9, v10, v11, savedregs);
  }
  return result;
}
// 8057867: using guessed type int sub_8057867();
// 8062B10: using guessed type int __stdcall sub_8062B10(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806C248: using guessed type int dword_806C248;

//----- (0805789A) --------------------------------------------------------
#error "80578E8: call analysis failed (funcsize=73)"

//----- (08057971) --------------------------------------------------------
#error "80579C3: call analysis failed (funcsize=34)"

//----- (080579E3) --------------------------------------------------------
signed int __cdecl sub_80579E3(int a1, unsigned int a2, int a3, unsigned int a4)
{
  int v4; // eax
  int v5; // ecx
  int v6; // eax
  unsigned int v8; // [esp+1Ch] [ebp-1Ch]
  unsigned int v9; // [esp+20h] [ebp-18h]
  int v10; // [esp+24h] [ebp-14h]
  int v11; // [esp+28h] [ebp-10h]

  v8 = 0;
  v9 = 0;
  while ( v8 < a2 || v9 < a4 )
  {
    v10 = 0;
    while ( v8 < a2 && (unsigned __int8)sub_8061191(*(char *)(a1 + v8)) ^ 1
         || v9 < a4 && (unsigned __int8)sub_8061191(*(char *)(a3 + v9)) ^ 1 )
    {
      if ( v8 == a2 )
        v4 = 0;
      else
        v4 = sub_8057971(*(unsigned __int8 *)(a1 + v8));
      v11 = v4;
      if ( v9 == a4 )
        v6 = 0;
      else
        v6 = sub_8057971(*(unsigned __int8 *)(a3 + v9));
      if ( v11 != v6 )
      {
        dword_806C2AC = (int)&locret_8057BE6;
        sub_80628B5(v5, v11 - v6);
      }
      ++v8;
      ++v9;
    }
    while ( *(_BYTE *)(a1 + v8) == 48 )
      ++v8;
    while ( *(_BYTE *)(a3 + v9) == 48 )
      ++v9;
    while ( (unsigned __int8)sub_8061191(*(char *)(a1 + v8)) && (unsigned __int8)sub_8061191(*(char *)(a3 + v9)) )
    {
      if ( !v10 )
        v10 = *(char *)(a1 + v8) - *(char *)(a3 + v9);
      ++v8;
      ++v9;
    }
    if ( (unsigned __int8)sub_8061191(*(char *)(a1 + v8)) )
      return 1;
    if ( (unsigned __int8)sub_8061191(*(char *)(a3 + v9)) )
      return -1;
    if ( v10 )
      return v10;
  }
  return 0;
}
// 8057971: using guessed type _DWORD __cdecl sub_8057971(_DWORD);
// 80628B5: using guessed type int __fastcall sub_80628B5(_DWORD, _DWORD);
// 806C2AC: using guessed type int dword_806C2AC;

//----- (08057BE8) --------------------------------------------------------
int __cdecl sub_8057BE8(char *s1, char *s2)
{
  bool v3; // zf
  int v4; // edx
  int v5; // ecx
  void *v6; // eax

  if ( !strcmp(s1, s2) )
    return 0;
  if ( !*s1 )
    return -1;
  if ( !*s2 )
    return 1;
  v3 = strcmp(".", s1) == 0;
  v6 = &loc_8057C6B;
  if ( !v3 )
    v6 = &loc_8057C75;
  dword_806C2AC = (int)v6;
  sub_80628B5(v5, v4);
  return -1;
}
// 80628B5: using guessed type int __fastcall sub_80628B5(_DWORD, _DWORD);
// 806C2AC: using guessed type int dword_806C2AC;

//----- (08057E90) --------------------------------------------------------
int __cdecl sub_8057E90(int category)
{
  bool v1; // zf
  void *v2; // eax
  unsigned __int8 v4; // [esp+1Bh] [ebp-Dh]
  const char *s1; // [esp+1Ch] [ebp-Ch]

  v4 = 1;
  s1 = setlocale(category, 0);
  if ( s1 )
  {
    if ( strcmp(s1, "C") )
    {
      v1 = strcmp(s1, "POSIX") == 0;
      v2 = &loc_8057EFD;
      if ( !v1 )
        v2 = &loc_8057F01;
      dword_806C25C = (int)v2;
      sub_8062A98();
    }
    v4 = 0;
  }
  return v4;
}
// 806C25C: using guessed type int dword_806C25C;

//----- (08057F07) --------------------------------------------------------
int __cdecl sub_8057F07(int a1)
{
  return *(_DWORD *)(a1 + 8);
}

//----- (08057F12) --------------------------------------------------------
int __cdecl sub_8057F12(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (08057F1D) --------------------------------------------------------
int __cdecl sub_8057F1D(int a1)
{
  return *(_DWORD *)(a1 + 16);
}

//----- (08057F28) --------------------------------------------------------
unsigned int __usercall sub_8057F28@<eax>(int a1@<edx>, int a2@<ecx>, int a3)
{
  void *v3; // eax
  _DWORD *i; // [esp+0h] [ebp-10h]
  unsigned int v6; // [esp+4h] [ebp-Ch]
  _DWORD *v7; // [esp+8h] [ebp-8h]
  unsigned int j; // [esp+Ch] [ebp-4h]

  v6 = 0;
  for ( i = *(_DWORD **)a3; *(_DWORD *)(a3 + 4) > (unsigned int)i; i += 2 )
  {
    v3 = &loc_8057F61;
    if ( !*i )
      v3 = &loc_8057F91;
    dword_806C284 = (int)v3;
    sub_80629B0(a2, a1);
    v7 = i;
    for ( j = 1; ; ++j )
    {
      v7 = (_DWORD *)v7[1];
      if ( !v7 )
        break;
    }
    if ( j > v6 )
      v6 = j;
  }
  return v6;
}
// 806C284: using guessed type int dword_806C284;

//----- (08058148) --------------------------------------------------------
#error "805816A: call analysis failed (funcsize=13)"

//----- (0805816F) --------------------------------------------------------
#error "80581AC: positive sp value has been found (funcsize=0)"

//----- (0805847A) --------------------------------------------------------
#error "80584E1: call analysis failed (funcsize=35)"

//----- (08058506) --------------------------------------------------------
#error "8058563: call analysis failed (funcsize=32)"

//----- (080585D2) --------------------------------------------------------
unsigned int __cdecl sub_80585D2(int a1, unsigned int a2)
{
  return sub_8060F47(a1, 3) % a2;
}

//----- (080585FD) --------------------------------------------------------
bool __cdecl sub_80585FD(int a1, int a2)
{
  return a1 == a2;
}

//----- (0805860B) --------------------------------------------------------
#error "8058636: call analysis failed (funcsize=75)"

//----- (080586D9) --------------------------------------------------------
int __cdecl sub_80586D9(unsigned int a1, int a2)
{
  float v3; // [esp+20h] [ebp-4h]

  if ( *(_BYTE *)(a2 + 16) == 1 )
LABEL_5:
    sub_8058506(a1);
  v3 = (long double)a1 / *(float *)(a2 + 8);
  if ( v3 < 4294967300.0 )
  {
    a1 = (signed __int64)v3;
    goto LABEL_5;
  }
  return 0;
}
// 8058506: using guessed type void __cdecl __noreturn sub_8058506(_DWORD);

//----- (08058786) --------------------------------------------------------
size_t *__cdecl sub_8058786(unsigned int a1, void *a2, unsigned int (__cdecl *a3)(int a1, unsigned int a2), bool (__cdecl *a4)(int a1, int a2), size_t a5)
{
  size_t *result; // eax
  size_t *ptr; // [esp+1Ch] [ebp-Ch]

  if ( !a3 )
    a3 = sub_80585D2;
  if ( !a4 )
    a4 = sub_80585FD;
  ptr = (size_t *)malloc(0x28u);
  if ( !ptr )
    return 0;
  if ( !a2 )
    a2 = &unk_80651F8;
  ptr[5] = (size_t)a2;
  if ( !((unsigned __int8)sub_805860B((int)ptr) ^ 1)
    && (ptr[2] = sub_80586D9(a1, (int)a2)) != 0
    && (*ptr = (size_t)calloc(ptr[2], 8u)) != 0 )
  {
    ptr[1] = 8 * ptr[2] + *ptr;
    ptr[3] = 0;
    ptr[4] = 0;
    ptr[6] = (size_t)a3;
    ptr[7] = (size_t)a4;
    ptr[8] = a5;
    ptr[9] = 0;
    result = ptr;
  }
  else
  {
    free(ptr);
    result = 0;
  }
  return result;
}

//----- (08058A81) --------------------------------------------------------
int __usercall sub_8058A81@<eax>(int a1@<edx>, int a2@<ecx>, int a3)
{
  void *v3; // eax
  int v4; // ST24_4

  v3 = &loc_8058AAA;
  if ( !*(_DWORD *)(a3 + 36) )
    v3 = &loc_8058AC1;
  dword_806C220 = (int)v3;
  sub_8062BFE(a2, a1);
  v4 = *(_DWORD *)(a3 + 36);
  *(_DWORD *)(a3 + 36) = *(_DWORD *)(v4 + 4);
  return v4;
}
// 8062BFE: using guessed type int __fastcall sub_8062BFE(_DWORD, _DWORD);
// 806C220: using guessed type int dword_806C220;

//----- (08058AD5) --------------------------------------------------------
int __cdecl sub_8058AD5(int a1, _DWORD *a2)
{
  int result; // eax

  *a2 = 0;
  a2[1] = *(_DWORD *)(a1 + 36);
  result = a1;
  *(_DWORD *)(a1 + 36) = a2;
  return result;
}

//----- (08058B08) --------------------------------------------------------
int __cdecl sub_8058B08(int a1, int a2, _DWORD *a3, char a4)
{
  int result; // eax
  _DWORD *v5; // ST2C_4
  int v6; // edx
  _DWORD *v7; // ST24_4
  _DWORD *i; // [esp+18h] [ebp-20h]
  _DWORD *v9; // [esp+1Ch] [ebp-1Ch]
  int v10; // [esp+20h] [ebp-18h]
  int v11; // [esp+28h] [ebp-10h]

  v9 = (_DWORD *)sub_8058148(a1, a2);
  *a3 = v9;
  if ( !*v9 )
    return 0;
  if ( *v9 == a2 || (*(unsigned __int8 (__cdecl **)(int, _DWORD))(a1 + 28))(a2, *v9) )
  {
    v11 = *v9;
    if ( a4 )
    {
      if ( v9[1] )
      {
        v5 = (_DWORD *)v9[1];
        v6 = v5[1];
        *v9 = *v5;
        v9[1] = v6;
        sub_8058AD5(a1, v5);
      }
      else
      {
        *v9 = 0;
      }
    }
    result = v11;
  }
  else
  {
    for ( i = v9; ; i = (_DWORD *)i[1] )
    {
      if ( !i[1] )
        return 0;
      if ( *(_DWORD *)i[1] == a2 || (*(unsigned __int8 (__cdecl **)(int, _DWORD))(a1 + 28))(a2, *(_DWORD *)i[1]) )
        break;
    }
    v10 = *(_DWORD *)i[1];
    if ( a4 )
    {
      v7 = (_DWORD *)i[1];
      i[1] = *(_DWORD *)(i[1] + 4);
      sub_8058AD5(a1, v7);
    }
    result = v10;
  }
  return result;
}
// 8058148: using guessed type int __cdecl sub_8058148(_DWORD, _DWORD);

//----- (08058C70) --------------------------------------------------------
signed int __cdecl sub_8058C70(int a1, int a2, char a3)
{
  _DWORD *v3; // eax
  int v4; // edx
  int v5; // ecx
  bool v6; // zf
  void *v7; // eax
  int v8; // edx
  int v9; // ecx
  int *i; // [esp+18h] [ebp-20h]
  int *j; // [esp+1Ch] [ebp-1Ch]
  int v13; // [esp+20h] [ebp-18h]
  int v14; // [esp+20h] [ebp-18h]
  _DWORD *v15; // [esp+24h] [ebp-14h]
  _DWORD *v16; // [esp+24h] [ebp-14h]
  int *v17; // [esp+28h] [ebp-10h]
  _DWORD *v18; // [esp+2Ch] [ebp-Ch]

  for ( i = *(int **)a2; *(_DWORD *)(a2 + 4) > (unsigned int)i; i += 2 )
  {
    if ( *i )
    {
      for ( j = (int *)i[1]; j; j = v17 )
      {
        v13 = *j;
        v15 = (_DWORD *)sub_8058148(a1, *j);
        v17 = (int *)j[1];
        if ( *v15 )
        {
          j[1] = v15[1];
          v15[1] = j;
        }
        else
        {
          *v15 = v13;
          ++*(_DWORD *)(a1 + 12);
          sub_8058AD5(a1, j);
        }
      }
      v14 = *i;
      i[1] = 0;
      if ( !a3 )
      {
        v3 = (_DWORD *)sub_8058148(a1, v14);
        v16 = v3;
        v6 = *v3 == 0;
        v7 = &loc_8058D87;
        if ( v6 )
          v7 = &loc_8058DD1;
        dword_806C2AC = (int)v7;
        sub_80628B5(v5, v4);
        v18 = (_DWORD *)sub_8058A81(v8, v9, a1);
        if ( !v18 )
          return 0;
        *v18 = v14;
        v18[1] = v16[1];
        v16[1] = v18;
        *i = 0;
        --*(_DWORD *)(a2 + 12);
      }
    }
  }
  return 1;
}
// 8058148: using guessed type int __cdecl sub_8058148(_DWORD, _DWORD);
// 80628B5: using guessed type int __fastcall sub_80628B5(_DWORD, _DWORD);
// 806C2AC: using guessed type int dword_806C2AC;

//----- (08058E1A) --------------------------------------------------------
signed int __cdecl sub_8058E1A(int a1, unsigned int a2)
{
  signed int result; // eax
  int nmemb; // [esp+10h] [ebp-38h]
  char *v4; // [esp+18h] [ebp-30h]
  char *v5; // [esp+1Ch] [ebp-2Ch]
  int v6; // [esp+20h] [ebp-28h]
  int v7; // [esp+24h] [ebp-24h]
  int v8; // [esp+28h] [ebp-20h]
  int v9; // [esp+2Ch] [ebp-1Ch]
  int v10; // [esp+30h] [ebp-18h]
  int v11; // [esp+34h] [ebp-14h]
  int v12; // [esp+38h] [ebp-10h]
  int v13; // [esp+3Ch] [ebp-Ch]

  nmemb = sub_80586D9(a2, *(_DWORD *)(a1 + 20));
  if ( !nmemb )
    return 0;
  if ( *(_DWORD *)(a1 + 8) == nmemb )
    return 1;
  v4 = (char *)calloc(nmemb, 8u);
  if ( !v4 )
    return 0;
  v6 = nmemb;
  v5 = &v4[8 * nmemb];
  v7 = 0;
  v8 = 0;
  v9 = *(_DWORD *)(a1 + 20);
  v10 = *(_DWORD *)(a1 + 24);
  v11 = *(_DWORD *)(a1 + 28);
  v12 = *(_DWORD *)(a1 + 32);
  v13 = *(_DWORD *)(a1 + 36);
  if ( (unsigned __int8)sub_8058C70((int)&v4, a1, 0) )
  {
    free(*(void **)a1);
    *(_DWORD *)a1 = v4;
    *(_DWORD *)(a1 + 4) = v5;
    *(_DWORD *)(a1 + 8) = v6;
    *(_DWORD *)(a1 + 12) = v7;
    *(_DWORD *)(a1 + 36) = v13;
    result = 1;
  }
  else
  {
    *(_DWORD *)(a1 + 36) = v13;
    if ( (unsigned __int8)sub_8058C70(a1, (int)&v4, 1) ^ 1 || (unsigned __int8)sub_8058C70(a1, (int)&v4, 0) ^ 1 )
      abort();
    free(v4);
    result = 0;
  }
  return result;
}

//----- (08058FEF) --------------------------------------------------------
#error "8059094: call analysis failed (funcsize=50)"

//----- (08059099) --------------------------------------------------------
#error "805931E: positive sp value has been found (funcsize=167)"

//----- (0805931F) --------------------------------------------------------
#error "8059374: call analysis failed (funcsize=33)"

//----- (08059386) --------------------------------------------------------
void sub_8059386()
{
  JUMPOUT(&locret_805937D);
}

//----- (0805938D) --------------------------------------------------------
#error "805939E: call analysis failed (funcsize=8)"

//----- (080593A9) --------------------------------------------------------
int __cdecl sub_80593A9(int a1, int a2)
{
  int v2; // edx
  int v3; // ecx
  signed __int64 v4; // rax
  int v6; // [esp+0h] [ebp-48h]
  int v7; // [esp+4h] [ebp-44h]
  int v8; // [esp+8h] [ebp-40h]
  int v9; // [esp+Ch] [ebp-3Ch]
  int v10; // [esp+10h] [ebp-38h]
  int v11; // [esp+14h] [ebp-34h]
  int v12; // [esp+18h] [ebp-30h]
  int v13; // [esp+1Ch] [ebp-2Ch]
  int v14; // [esp+20h] [ebp-28h]
  int v15; // [esp+24h] [ebp-24h]
  _DWORD *v16; // [esp+28h] [ebp-20h]
  void *ptr; // [esp+2Ch] [ebp-1Ch]
  int v18; // [esp+30h] [ebp-18h]
  int v19; // [esp+34h] [ebp-14h]
  int v20; // [esp+38h] [ebp-10h]
  int v21; // [esp+3Ch] [ebp-Ch]

  v18 = sub_8058B08(a1, a2, &v16, 1);
  if ( !v18 )
  {
    dword_806C248 = (int)&locret_805963F;
    sub_8062B10(v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16);
  }
  --*(_DWORD *)(a1 + 16);
  if ( !*v16
    && **(float **)(a1 + 20) * (long double)*(unsigned int *)(a1 + 8) > (long double)(unsigned int)--*(_DWORD *)(a1 + 12) )
  {
    sub_805860B(a1);
    if ( **(float **)(a1 + 20) * (long double)*(unsigned int *)(a1 + 8) > (long double)*(unsigned int *)(a1 + 12) )
    {
      while ( 1 )
      {
        v19 = *(_DWORD *)(a1 + 20);
        v4 = *(_BYTE *)(v19 + 16) ? (signed __int64)((long double)*(unsigned int *)(a1 + 8) * *(float *)(v19 + 4)) : (signed __int64)((long double)*(unsigned int *)(a1 + 8) * *(float *)(v19 + 4) * *(float *)(v19 + 8));
        v20 = v4;
        if ( !((unsigned __int8)sub_8058E1A(a1, v4) ^ 1) )
          break;
        ptr = *(void **)(a1 + 36);
        if ( !ptr )
        {
          *(_DWORD *)(a1 + 36) = 0;
          return v18;
        }
        v21 = *((_DWORD *)ptr + 1);
        free(ptr);
        dword_806C284 = (int)&loc_8059622;
        sub_80629B0(v3, v2);
      }
    }
  }
  return v18;
}
// 8062B10: using guessed type int __stdcall sub_8062B10(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806C248: using guessed type int dword_806C248;
// 806C284: using guessed type int dword_806C284;

//----- (08059641) --------------------------------------------------------
_DWORD *__cdecl sub_8059641(int a1, unsigned int a2)
{
  _DWORD *v3; // [esp+1Ch] [ebp-Ch]

  v3 = sub_805F128(0x10u);
  if ( !a2 )
    a2 = 1;
  *v3 = sub_805EFEF(a2, 4u);
  *(_DWORD *)*v3 = 0;
  v3[1] = a2;
  v3[2] = 0;
  if ( a1 )
  {
    dword_806C25C = (int)&loc_80596D0;
    sub_8062A98();
  }
  v3[3] = sub_80596DB;
  return v3;
}
// 806C25C: using guessed type int dword_806C25C;

//----- (080596DB) --------------------------------------------------------
int sub_80596DB()
{
  return 0;
}

//----- (080596E5) --------------------------------------------------------
void __cdecl sub_80596E5(void *ptr)
{
  free(*(void **)ptr);
  free(ptr);
}

//----- (08059705) --------------------------------------------------------
int __cdecl sub_8059705(int a1, int a2)
{
  _DWORD *v2; // edx

  if ( (unsigned int)(*(_DWORD *)(a1 + 4) - 1) <= *(_DWORD *)(a1 + 8) )
    *(_DWORD *)a1 = sub_805F062(*(void **)a1, a1 + 4, 4);
  v2 = *(_DWORD **)a1;
  v2[++*(_DWORD *)(a1 + 8)] = a2;
  sub_8059967(*(_DWORD *)a1, *(_DWORD *)(a1 + 8), *(int (__cdecl **)(int, int))(a1 + 12));
  return 0;
}

//----- (0805979E) --------------------------------------------------------
int __cdecl sub_805979E(_DWORD *a1)
{
  int v2; // ST1C_4
  _DWORD *v3; // ebx
  int v4; // esi
  int v5; // eax

  if ( !a1[2] )
    return 0;
  v2 = *(_DWORD *)(*a1 + 4);
  v3 = (_DWORD *)(*a1 + 4);
  v4 = *a1;
  v5 = a1[2];
  a1[2] = v5 - 1;
  *v3 = *(_DWORD *)(v4 + 4 * v5);
  sub_805982A(*a1, a1[2], 1, a1[3]);
  return v2;
}
// 805982A: using guessed type _DWORD __cdecl sub_805982A(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0805982A) --------------------------------------------------------
#error "805989F: call analysis failed (funcsize=83)"

//----- (08059967) --------------------------------------------------------
int __cdecl sub_8059967(int a1, unsigned int a2, int (__cdecl *a3)(int, int))
{
  int result; // eax
  int v4; // [esp+0h] [ebp-28h]
  unsigned int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]

  v5 = a2;
  v6 = *(_DWORD *)(4 * a2 + a1);
  dword_806C25C = (int)&loc_80599EA;
  sub_8062A98();
  do
  {
    *(_DWORD *)(a1 + 4 * v5) = *(_DWORD *)(4 * (v5 >> 1) + a1);
    v5 >>= 1;
    if ( v5 == 1 )
      break;
    v4 = *(_DWORD *)(4 * (v5 >> 1) + a1);
  }
  while ( a3(v4, v6) <= 0 );
  result = v6;
  *(_DWORD *)(a1 + 4 * v5) = v6;
  return result;
}
// 806C25C: using guessed type int dword_806C25C;

//----- (08059A3C) --------------------------------------------------------
#error "8059ADD: call analysis failed (funcsize=102)"

//----- (08059B68) --------------------------------------------------------
int __cdecl sub_8059B68(unsigned int a1, int a2)
{
  int v3; // [esp+Ch] [ebp-4h]

  v3 = a2 + 10;
  *(_BYTE *)(a2 + 10) = 0;
  do
  {
    *(_BYTE *)--v3 = a1 % 0xA + 48;
    a1 /= 0xAu;
  }
  while ( a1 );
  return v3;
}

//----- (08059BD6) --------------------------------------------------------
#error "8059C8F: call analysis failed (funcsize=55)"

//----- (08059CC2) --------------------------------------------------------
int __usercall __noreturn sub_8059CC2@<eax>(int a1@<ebx>, char *a2, int a3, char a4)
{
  int v4; // edx
  signed int v5; // eax
  signed int v6; // eax
  void *v7; // eax
  char *v8; // eax
  const unsigned __int16 **v9; // eax
  const unsigned __int16 **v10; // eax
  int v11; // ecx
  unsigned int v12; // et1
  int (*v13)(); // eax
  int v15; // [esp-8h] [ebp-60h]
  signed int v16; // [esp-4h] [ebp-5Ch]
  int v17; // [esp+0h] [ebp-58h]
  char *v18; // [esp+1Ch] [ebp-3Ch]
  unsigned __int8 v19; // [esp+2Bh] [ebp-2Dh]
  wint_t wc; // [esp+2Ch] [ebp-2Ch]
  char *v21; // [esp+30h] [ebp-28h]
  int v22; // [esp+34h] [ebp-24h]
  size_t v23; // [esp+38h] [ebp-20h]
  char *v24; // [esp+3Ch] [ebp-1Ch]
  int v25; // [esp+40h] [ebp-18h]
  mbstate_t s; // [esp+44h] [ebp-14h]
  unsigned int v27; // [esp+4Ch] [ebp-Ch]

  v18 = a2;
  v27 = __readgsdword(0x14u);
  v21 = a2;
  v24 = &a2[a3];
  v22 = 0;
  if ( __ctype_get_mb_cur_max() <= 1 )
  {
    while ( 1 )
    {
      do
      {
        while ( 1 )
        {
          if ( v21 >= v24 )
          {
            v6 = v22;
            goto LABEL_48;
          }
          v8 = v21++;
          v19 = *v8;
          v9 = __ctype_b_loc();
          v4 = v19;
          if ( !((*v9)[v4] & 0x4000) )
            break;
          if ( v22 == 0x7FFFFFFF )
            goto LABEL_47;
          ++v22;
        }
        if ( a4 & 2 )
        {
          v6 = -1;
          goto LABEL_48;
        }
        v10 = __ctype_b_loc();
        v4 = v19;
      }
      while ( (*v10)[v4] & 2 );
      if ( v22 == 0x7FFFFFFF )
      {
LABEL_47:
        v6 = 0x7FFFFFFF;
        goto LABEL_48;
      }
      ++v22;
    }
  }
  while ( 1 )
  {
LABEL_32:
    if ( v21 >= v24 )
    {
      v6 = v22;
      goto LABEL_48;
    }
    v5 = *v21;
    if ( v5 > 63 )
      break;
    if ( v5 < 37 && (unsigned int)(v5 - 32) > 3 )
      goto LABEL_11;
LABEL_10:
    ++v21;
    ++v22;
  }
  if ( v5 >= 65 && (v5 <= 95 || (unsigned int)(v5 - 97) <= 0x1D) )
    goto LABEL_10;
LABEL_11:
  memset(&s, 0, 8u);
  while ( 1 )
  {
    v23 = sub_8060706(&v17 - 11, v21, v24 - v21, &s);
    if ( v23 == -1 )
    {
      if ( !(a4 & 1) )
      {
        ++v21;
        ++v22;
        goto LABEL_32;
      }
      dword_806C25C = (int)&loc_8059F62;
      sub_8062A98();
    }
    if ( v23 == -2 )
      break;
    if ( !v23 )
      v23 = 1;
    v25 = wcwidth(wc);
    if ( v25 < 0 )
    {
      if ( a4 & 2 )
      {
        v6 = -1;
        goto LABEL_48;
      }
      if ( !iswcntrl(wc) )
      {
        v16 = 0;
        v15 = a1;
        v7 = &loc_8059E7D;
        if ( v22 != 0x7FFFFFFF )
          v7 = &loc_8059E82;
        dword_806C2EC = (int)v7;
        a1 = v15;
        sub_80626B4();
        goto LABEL_47;
      }
    }
    else
    {
      if ( 0x7FFFFFFF - v22 < v25 )
        goto LABEL_47;
      v22 += v25;
    }
    v21 += v23;
    if ( mbsinit(&s) )
      goto LABEL_32;
  }
  if ( !(a4 & 1) )
  {
    v21 = v24;
    ++v22;
    goto LABEL_32;
  }
  v6 = -1;
LABEL_48:
  v12 = __readgsdword(0x14u);
  v11 = v12 ^ v27;
  v16 = v6;
  v15 = a1;
  v13 = (int (*)())&loc_8059F87;
  if ( v12 == v27 )
    v13 = sub_8059F8C;
  dword_806C2AC = (int)v13;
  return sub_80628B5(v11, v4 * 2);
}
// 8059CC2: could not find valid save-restore pair for ebx
// 8049800: using guessed type int __cdecl wcwidth(_DWORD);
// 8059F8C: using guessed type int sub_8059F8C();
// 80626B4: using guessed type int sub_80626B4(void);
// 80628B5: using guessed type int __fastcall sub_80628B5(_DWORD, _DWORD);
// 806C25C: using guessed type int dword_806C25C;
// 806C2AC: using guessed type int dword_806C2AC;
// 806C2EC: using guessed type int dword_806C2EC;

//----- (08059F8C) --------------------------------------------------------
#error "8059F8D: positive sp value has been found (funcsize=0)"

//----- (08059F8E) --------------------------------------------------------
int sub_8059F8E()
{
  int result; // eax
  char v1; // [esp+20h] [ebp-88h]

  if ( sched_getaffinity(0, 128, &v1) || (result = __sched_cpucount(128, &v1)) == 0 )
    result = 0;
  return result;
}
// 80498D0: using guessed type int __cdecl __sched_cpucount(_DWORD, _DWORD);
// 8049E70: using guessed type int __cdecl sched_getaffinity(_DWORD, _DWORD, _DWORD);

//----- (08059FF9) --------------------------------------------------------
signed int __cdecl sub_8059FF9(int a1)
{
  signed int result; // eax
  int v2; // eax
  int v3; // edx
  int v4; // ecx
  bool v5; // zf
  bool v6; // sf
  void *v7; // eax
  int v8; // [esp+10h] [ebp-18h]
  int v9; // [esp+14h] [ebp-14h]
  int v10; // [esp+18h] [ebp-10h]
  int v11; // [esp+1Ch] [ebp-Ch]

  if ( a1 == 1 )
  {
    v9 = sub_8059F8E();
    if ( v9 )
    {
      result = v9;
    }
    else
    {
      v2 = sysconf(84);
      v10 = v2;
      v5 = v2 == 0;
      v6 = v2 < 0;
      v7 = &loc_805A046;
      if ( v6 || v5 )
        v7 = &loc_805A04B;
      dword_806C284 = (int)v7;
      sub_80629B0(v4, v3);
      result = v10;
    }
  }
  else
  {
    v8 = sysconf(83);
    if ( v8 == 1 )
    {
      v11 = sub_8059F8E();
      if ( v11 )
        v8 = v11;
    }
    if ( v8 <= 0 )
      result = 1;
    else
      result = v8;
  }
  return result;
}
// 806C284: using guessed type int dword_806C284;

//----- (0805A088) --------------------------------------------------------
int __cdecl sub_805A088(char *nptr)
{
  void *v1; // eax
  int v2; // ST20_4
  int v4; // [esp+0h] [ebp-28h]
  int v5; // [esp+4h] [ebp-24h]
  int v6; // [esp+8h] [ebp-20h]
  int v7; // [esp+Ch] [ebp-1Ch]
  int v8; // [esp+10h] [ebp-18h]
  char *endptr; // [esp+14h] [ebp-14h]
  int v10; // [esp+1Ch] [ebp-Ch]
  int v11; // [esp+20h] [ebp-8h]
  int v12; // [esp+24h] [ebp-4h]
  int savedregs; // [esp+28h] [ebp+0h]

  v1 = &loc_805A0B4;
  if ( nptr )
    v1 = &loc_805A0BC;
  dword_806C248 = (int)v1;
  sub_8062B10(v4, v5, v6, v7, v8, endptr, 0, v10, v11, v12, savedregs);
  return v2;
}
// 8062B10: using guessed type int __stdcall sub_8062B10(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806C248: using guessed type int dword_806C248;

//----- (0805A1B8) --------------------------------------------------------
unsigned int __cdecl sub_805A1B8(int a1)
{
  char *v1; // eax
  char *v2; // eax
  unsigned int result; // eax
  bool v4; // zf
  void *v5; // eax
  int v6; // edx
  int v7; // ecx
  int v8; // eax
  int v9; // [esp-4h] [ebp-2Ch]
  unsigned int v10; // [esp+14h] [ebp-14h]
  int v11; // [esp+18h] [ebp-10h]
  unsigned int v12; // [esp+1Ch] [ebp-Ch]

  v10 = -1;
  if ( a1 == 2 )
  {
    v1 = getenv("OMP_NUM_THREADS");
    v11 = sub_805A088(v1);
    v2 = getenv("OMP_THREAD_LIMIT");
    v8 = sub_805A088(v2);
    v10 = v8;
    v4 = v8 == 0;
    v9 = v8;
    v5 = &loc_805A23B;
    if ( !v4 )
      v5 = &loc_805A242;
    dword_806C2EC = (int)v5;
    sub_80626B4();
    v10 = -1;
    if ( v11 )
    {
      dword_806C284 = (int)&locret_805A295;
      sub_80629B0(v7, v6);
    }
    a1 = 1;
  }
  result = sub_8059FF9(a1);
  v12 = result;
  if ( v10 <= result )
    result = v10;
  return result;
}
// 80626B4: using guessed type int sub_80626B4(void);
// 806C284: using guessed type int dword_806C284;
// 806C2EC: using guessed type int dword_806C2EC;

//----- (0805A297) --------------------------------------------------------
long double sub_805A297()
{
  double v1; // [esp+18h] [ebp-60h]
  double v2; // [esp+20h] [ebp-58h]
  char v3; // [esp+2Ch] [ebp-4Ch]
  unsigned int v4; // [esp+3Ch] [ebp-3Ch]
  unsigned int v5; // [esp+60h] [ebp-18h]
  unsigned int v6; // [esp+6Ch] [ebp-Ch]

  v6 = __readgsdword(0x14u);
  v1 = (long double)sysconf(85);
  v2 = (long double)sysconf(30);
  if ( v1 >= 0.0 && v2 >= 0.0 )
    return v1 * v2;
  if ( sysinfo((struct sysinfo *)&v3) )
    return 67108864.0;
  return (long double)v4 * (long double)v5;
}

//----- (0805A354) --------------------------------------------------------
#error "805A3E9: call analysis failed (funcsize=77)"

//----- (0805A48B) --------------------------------------------------------
int __cdecl sub_805A48B(int pipedes[2], int a2)
{
  int result; // eax
  int v3; // [esp+0h] [ebp-38h]
  int v4; // [esp+4h] [ebp-34h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]
  int v15; // [esp+30h] [ebp-8h]
  int v16; // [esp+34h] [ebp-4h]

  v13 = *pipedes;
  v14 = pipedes[1];
  if ( dword_806D022 >= 0 )
  {
    v4 = a2;
    v9 = pipe2(pipedes);
    if ( v9 >= 0 || *__errno_location() != 38 )
    {
      dword_806D022 = 1;
      return v9;
    }
    dword_806D022 = -1;
  }
  if ( a2 & 0xFFF7F7FF )
  {
    *__errno_location() = 22;
    result = -1;
  }
  else if ( pipe(pipedes) >= 0 )
  {
    if ( !(a2 & 0x800)
      || (v10 = sub_806038F(pipedes[1], 3, 0), v10 >= 0)
      && sub_806038F(pipedes[1], 4, v10) != -1
      && (v10 = sub_806038F(*pipedes, 3, 0), v10 >= 0)
      && sub_806038F(*pipedes, 4, v10) != -1 )
    {
      if ( !(a2 & 0x80000)
        || (v11 = sub_806038F(pipedes[1], 1, 0), v11 >= 0)
        && sub_806038F(pipedes[1], 2, v11 | 1) != -1
        && (v11 = sub_806038F(*pipedes, 1, 0), v11 >= 0)
        && sub_806038F(*pipedes, 2, v11 | 1) != -1 )
      {
        dword_806C234 = (int)&locret_805A70D;
        sub_8062B84(v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16);
      }
    }
    v12 = *__errno_location();
    close(*pipedes);
    close(pipedes[1]);
    *pipedes = v13;
    pipedes[1] = v14;
    *__errno_location() = v12;
    result = -1;
  }
  else
  {
    result = -1;
  }
  return result;
}
// 8049DF0: using guessed type int __cdecl pipe2(_DWORD);
// 8062B84: using guessed type int __stdcall sub_8062B84(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806C234: using guessed type int dword_806C234;
// 806D022: using guessed type int dword_806D022;

//----- (0805A70F) --------------------------------------------------------
int sub_805A70F()
{
  void *v0; // eax
  int v2; // [esp+0h] [ebp-28h]
  int v3; // [esp+4h] [ebp-24h]
  int v4; // [esp+8h] [ebp-20h]
  int v5; // [esp+Ch] [ebp-1Ch]
  char *endptr; // [esp+10h] [ebp-18h]
  int v7; // [esp+14h] [ebp-14h]
  char *nptr; // [esp+18h] [ebp-10h]
  int v9; // [esp+1Ch] [ebp-Ch]
  int v10; // [esp+20h] [ebp-8h]
  int v11; // [esp+24h] [ebp-4h]
  int savedregs; // [esp+28h] [ebp+0h]

  v7 = 200809;
  nptr = getenv("_POSIX2_VERSION");
  if ( nptr )
  {
    v0 = &loc_805A754;
    if ( !*nptr )
      v0 = &loc_805A781;
    dword_806C248 = (int)v0;
    sub_8062B10(v2, v3, v4, v5, endptr, v7, nptr, v9, v10, v11, savedregs);
    v9 = strtol(nptr, &endptr, 10);
    if ( !*endptr )
      v7 = v9;
  }
  return v7;
}
// 8062B10: using guessed type int __stdcall sub_8062B10(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806C248: using guessed type int dword_806C248;

//----- (0805A786) --------------------------------------------------------
char *__cdecl sub_805A786(char *s)
{
  char *v1; // eax
  char *result; // eax
  char *v3; // [esp+18h] [ebp-10h]
  char *s1; // [esp+1Ch] [ebp-Ch]

  if ( !s )
  {
    fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
    abort();
  }
  v3 = strrchr(s, 47);
  if ( v3 )
    v1 = v3 + 1;
  else
    v1 = s;
  s1 = v1;
  if ( v1 - s > 6 && !strncmp(v1 - 7, "/.libs/", 7u) )
  {
    s = s1;
    if ( !strncmp(s1, "lt-", 3u) )
    {
      s = s1 + 3;
      program_invocation_short_name = (int)(s1 + 3);
    }
  }
  dword_806D026 = (int)s;
  result = s;
  program_invocation_name = (int)s;
  return result;
}
// 806C440: using guessed type int program_invocation_short_name;
// 806C450: using guessed type int program_invocation_name;
// 806D026: using guessed type int dword_806D026;

//----- (0805A8EB) --------------------------------------------------------
int __cdecl sub_805A8EB(int a1, unsigned __int8 a2, char a3)
{
  void *v3; // eax
  int v4; // eax
  int v5; // ST18_4

  v3 = &loc_805A91E;
  if ( !a1 )
    v3 = &loc_805A923;
  dword_806C25C = (int)v3;
  sub_8062A98();
  v4 = 4 * (a2 >> 5) + a1;
  v5 = (*(_DWORD *)(v4 + 8) >> (a2 & 0x1F)) & 1;
  *(_DWORD *)(v4 + 8) ^= (v5 ^ a3 & 1) << (a2 & 0x1F);
  return v5;
}
// 806C25C: using guessed type int dword_806C25C;

//----- (0805A9BE) --------------------------------------------------------
int *__cdecl sub_805A9BE(int *a1, int a2, int a3)
{
  int *result; // eax

  if ( !a1 )
    a1 = &dword_806D036;
  *a1 = 10;
  if ( !a2 || !a3 )
    abort();
  a1[10] = a2;
  result = a1;
  a1[11] = a3;
  return result;
}
// 806D036: using guessed type int dword_806D036;

//----- (0805A9FF) --------------------------------------------------------
_DWORD *__userpurge sub_805A9FF@<eax>(_DWORD *a1, int a2)
{
  int v3; // [esp+0h] [ebp-38h]
  int v4; // [esp+4h] [ebp-34h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]

  memset(&v3, 0, 0x30u);
  if ( a2 == 10 )
    abort();
  *a1 = a2;
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = v6;
  a1[4] = v7;
  a1[5] = v8;
  a1[6] = v9;
  a1[7] = v10;
  a1[8] = v11;
  a1[9] = v12;
  a1[10] = v13;
  a1[11] = v14;
  return a1;
}

//----- (0805AAA1) --------------------------------------------------------
#error "805AB5C: call analysis failed (funcsize=66)"

//----- (0805AB8E) --------------------------------------------------------
unsigned int __usercall sub_805AB8E@<eax>(size_t a1@<ebx>, int a2, unsigned int a3, char *a4, size_t a5, signed int a6, int a7, int a8, char *a9, char *a10)
{
  int v10; // eax
  void *v11; // eax
  int v12; // ecx
  size_t v13; // eax
  int v14; // edx
  int v15; // edx
  int v16; // eax
  char v17; // al
  bool v18; // zf
  bool v19; // sf
  unsigned __int8 v20; // of
  void *v21; // eax
  void *v22; // eax
  int v23; // eax
  void *v24; // eax
  void *v25; // eax
  const unsigned __int16 *v26; // eax
  char *v27; // edx
  int v28; // eax
  void *v29; // eax
  int v30; // eax
  void *v31; // eax
  void *v32; // eax
  int v33; // eax
  void *v34; // eax
  void *v35; // eax
  void *v36; // eax
  int v37; // edx
  int v38; // ecx
  void *v39; // eax
  unsigned int result; // eax
  void *v41; // eax
  size_t v42; // [esp-8h] [ebp-90h]
  int v43; // [esp-4h] [ebp-8Ch]
  int v44; // [esp+0h] [ebp-88h]
  char *v45; // [esp+4h] [ebp-84h]
  size_t v46; // [esp+8h] [ebp-80h]
  int v47; // [esp+Ch] [ebp-7Ch]
  int v48; // [esp+10h] [ebp-78h]
  int v49; // [esp+14h] [ebp-74h]
  int v50; // [esp+18h] [ebp-70h]
  int v51; // [esp+1Ch] [ebp-6Ch]
  int v52; // [esp+20h] [ebp-68h]
  int v53; // [esp+24h] [ebp-64h]
  int v54; // [esp+28h] [ebp-60h]
  char *v55; // [esp+2Ch] [ebp-5Ch]
  char *v56; // [esp+30h] [ebp-58h]
  int v57; // [esp+34h] [ebp-54h]
  char *v58; // [esp+38h] [ebp-50h]
  int v59; // [esp+3Ch] [ebp-4Ch]
  unsigned __int8 v60; // [esp+40h] [ebp-48h]
  bool v61; // [esp+41h] [ebp-47h]
  char v62; // [esp+42h] [ebp-46h]
  char v63; // [esp+43h] [ebp-45h]
  char v64; // [esp+44h] [ebp-44h]
  unsigned __int8 v65; // [esp+45h] [ebp-43h]
  unsigned __int8 v66; // [esp+46h] [ebp-42h]
  unsigned __int8 v67; // [esp+47h] [ebp-41h]
  char v68; // [esp+48h] [ebp-40h]
  bool v69; // [esp+49h] [ebp-3Fh]
  bool v70; // [esp+4Ah] [ebp-3Eh]
  bool v71; // [esp+4Bh] [ebp-3Dh]
  wint_t wc; // [esp+4Ch] [ebp-3Ch]
  int v73; // [esp+50h] [ebp-38h]
  unsigned int v74; // [esp+54h] [ebp-34h]
  unsigned int v75; // [esp+58h] [ebp-30h]
  char *s; // [esp+5Ch] [ebp-2Ch]
  size_t n; // [esp+60h] [ebp-28h]
  unsigned int v78; // [esp+64h] [ebp-24h]
  unsigned int v79; // [esp+68h] [ebp-20h]
  size_t v80; // [esp+6Ch] [ebp-1Ch]
  unsigned int v81; // [esp+70h] [ebp-18h]
  mbstate_t ps; // [esp+74h] [ebp-14h]
  unsigned int v83; // [esp+7Ch] [ebp-Ch]

  v59 = a2;
  v58 = a4;
  v57 = a8;
  v56 = a9;
  v55 = a10;
  v83 = __readgsdword(0x14u);
  v74 = 0;
  v75 = 0;
  s = 0;
  n = 0;
  v60 = 0;
  v71 = __ctype_get_mb_cur_max() == 1;
  v61 = (a7 & 2) != 0;
  v62 = 0;
  v63 = 0;
  v64 = 1;
LABEL_2:
  switch ( a6 )
  {
    case 0:
      v61 = 0;
      break;
    case 1:
      goto LABEL_20;
    case 2:
      goto LABEL_23;
    case 3:
      v60 = 1;
LABEL_20:
      v61 = 1;
      goto LABEL_21;
    case 4:
LABEL_21:
      if ( v61 != 1 )
        v60 = 1;
LABEL_23:
      a6 = 2;
      if ( v61 != 1 )
      {
        if ( v74 < a3 )
          *(_BYTE *)(v59 + v74) = 39;
        ++v74;
      }
      s = "'";
      n = 1;
      break;
    case 5:
      goto LABEL_4;
    case 6:
      a6 = 5;
      v61 = 1;
LABEL_4:
      if ( v61 != 1 )
      {
        if ( v74 < a3 )
          *(_BYTE *)(v59 + v74) = 34;
        ++v74;
      }
      v60 = 1;
      s = (char *)&unk_806540D;
      n = 1;
      dword_806C270 = (int)&loc_805AD87;
      sub_8062A28(v44);
      goto LABEL_9;
    case 7:
LABEL_9:
      v60 = 1;
      v61 = 0;
      break;
    case 8:
    case 9:
    case 10:
      if ( a6 != 10 )
      {
        v56 = (char *)sub_805AAA1("`", a6);
        v55 = (char *)sub_805AAA1("'", a6);
      }
      if ( v61 != 1 )
      {
        for ( s = v56; *s; ++s )
        {
          if ( v74 < a3 )
            *(_BYTE *)(v74 + v59) = *s;
          ++v74;
        }
      }
      v60 = 1;
      s = v55;
      n = strlen(v55);
      break;
    default:
      abort();
      return result;
  }
  v73 = 0;
  dword_806C234 = (int)&loc_805B834;
  v10 = sub_8062B84(v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57);
  while ( 2 )
  {
    v67 = 0;
    v68 = 0;
    v69 = 0;
    v43 = v10;
    v42 = a1;
    v11 = &loc_805ADE0;
    if ( !v60 )
      v11 = &loc_805AE5E;
    dword_806C2EC = (int)v11;
    a1 = v42;
    sub_80626B4();
    if ( a6 != 2 && n )
    {
      a1 = v73 + n;
      if ( a5 != -1 || n <= 1 )
      {
        v13 = a5;
      }
      else
      {
        v13 = strlen(v58);
        a5 = v13;
      }
      if ( a1 <= v13 && !memcmp(&v58[v73], s, n) )
      {
        if ( v61 )
        {
          dword_806C2AC = (int)&loc_805B9AC;
          sub_80628B5(v12, v14);
        }
        v67 = 1;
      }
    }
    v15 = (int)v58;
    v65 = v58[v73];
    v16 = v65;
    switch ( v65 )
    {
      case 0u:
        if ( v60 )
        {
          if ( v61 )
            goto LABEL_247;
          v68 = 1;
          if ( a6 == 2 && v62 != 1 )
          {
            if ( v74 < a3 )
            {
              v15 = v59;
              *(_BYTE *)(v59 + v74) = 39;
            }
            if ( ++v74 < a3 )
            {
              v15 = v59;
              *(_BYTE *)(v59 + v74) = 36;
            }
            if ( ++v74 < a3 )
            {
              v15 = v59;
              *(_BYTE *)(v59 + v74) = 39;
            }
            ++v74;
            v62 = 1;
          }
          if ( v74 < a3 )
          {
            v15 = v59;
            *(_BYTE *)(v59 + v74) = 92;
          }
          ++v74;
          if ( a6 != 2 && v73 + 1 < a5 )
          {
            v15 = v73 + 1;
            if ( v58[v73 + 1] > 47 )
            {
              v17 = v58[v73 + 1];
              v20 = __OFSUB__(v17, 57);
              v18 = v17 == 57;
              v19 = (char)(v17 - 57) < 0;
              v43 = (unsigned __int8)v58[v73 + 1];
              v42 = a1;
              v21 = &loc_805AF6E;
              if ( !((unsigned __int8)(v19 ^ v20) | v18) )
                v21 = &loc_805AF9C;
              dword_806C2EC = (int)v21;
              a1 = v42;
              sub_80626B4();
              if ( v74 < a3 )
              {
                v15 = v59;
                *(_BYTE *)(v59 + v74) = 48;
              }
              if ( ++v74 < a3 )
              {
                v15 = v59;
                *(_BYTE *)(v59 + v74) = 48;
              }
              ++v74;
            }
          }
          v65 = 48;
        }
        else if ( a7 & 1 )
        {
          goto LABEL_219;
        }
        goto LABEL_198;
      case 7u:
        goto LABEL_91;
      case 8u:
        v66 = 98;
        goto LABEL_106;
      case 9u:
        v66 = 116;
        dword_806C25C = (int)&loc_805B193;
        sub_8062A98();
        goto LABEL_169;
      case 0xAu:
        v66 = 110;
        goto LABEL_104;
      case 0xBu:
LABEL_169:
        v66 = 118;
        goto LABEL_106;
      case 0xCu:
        v66 = 102;
        goto LABEL_106;
      case 0xDu:
        v66 = 114;
LABEL_104:
        if ( a6 != 2 || !v61 )
          goto LABEL_106;
        goto LABEL_247;
      case 0x20u:
        goto LABEL_114;
      case 0x21u:
      case 0x22u:
      case 0x24u:
      case 0x26u:
      case 0x28u:
      case 0x29u:
      case 0x2Au:
      case 0x3Bu:
      case 0x3Cu:
      case 0x3Du:
      case 0x3Eu:
      case 0x5Bu:
      case 0x5Eu:
      case 0x60u:
      case 0x7Cu:
        goto LABEL_115;
      case 0x23u:
      case 0x7Eu:
        goto LABEL_113;
      case 0x25u:
      case 0x2Bu:
      case 0x2Cu:
      case 0x2Du:
      case 0x2Eu:
      case 0x2Fu:
      case 0x30u:
      case 0x31u:
      case 0x32u:
      case 0x33u:
      case 0x34u:
      case 0x35u:
      case 0x36u:
      case 0x37u:
      case 0x38u:
      case 0x39u:
      case 0x3Au:
      case 0x41u:
      case 0x42u:
      case 0x43u:
      case 0x44u:
      case 0x45u:
      case 0x46u:
      case 0x47u:
      case 0x48u:
      case 0x49u:
      case 0x4Au:
      case 0x4Bu:
      case 0x4Cu:
      case 0x4Du:
      case 0x4Eu:
      case 0x4Fu:
      case 0x50u:
      case 0x51u:
      case 0x52u:
      case 0x53u:
      case 0x54u:
      case 0x55u:
      case 0x56u:
      case 0x57u:
      case 0x58u:
      case 0x59u:
      case 0x5Au:
      case 0x5Du:
      case 0x5Fu:
      case 0x61u:
      case 0x62u:
      case 0x63u:
      case 0x64u:
      case 0x65u:
      case 0x66u:
      case 0x67u:
      case 0x68u:
      case 0x69u:
      case 0x6Au:
      case 0x6Bu:
      case 0x6Cu:
      case 0x6Du:
      case 0x6Eu:
      case 0x6Fu:
      case 0x70u:
      case 0x71u:
      case 0x72u:
      case 0x73u:
      case 0x74u:
      case 0x75u:
      case 0x76u:
      case 0x77u:
      case 0x78u:
      case 0x79u:
      case 0x7Au:
        v69 = 1;
        goto LABEL_198;
      case 0x27u:
        v63 = 1;
        v69 = 1;
        if ( a6 != 2 )
          goto LABEL_198;
        if ( v61 )
          goto LABEL_247;
        v43 = v65;
        v42 = a1;
        v25 = &loc_805B27F;
        if ( !a3 )
          v25 = &loc_805B292;
        dword_806C284 = (int)v25;
        a1 = v42;
        sub_80629B0(v12, v58);
        if ( !v75 )
        {
          v75 = a3;
          a3 = 0;
        }
        if ( v74 < a3 )
        {
          v15 = v59;
          *(_BYTE *)(v59 + v74) = 39;
        }
        if ( ++v74 < a3 )
        {
          v15 = v59;
          *(_BYTE *)(v59 + v74) = 92;
        }
        if ( ++v74 < a3 )
        {
          v15 = v59;
          *(_BYTE *)(v59 + v74) = 39;
        }
        ++v74;
        v62 = 0;
        goto LABEL_198;
      case 0x3Fu:
        if ( a6 == 2 )
        {
          if ( v61 )
            goto LABEL_247;
        }
        else if ( a6 == 5 && a7 & 4 && v73 + 2 < a5 && v58[v73 + 1] == 63 )
        {
          switch ( v58[v73 + 2] )
          {
            case 33:
            case 39:
            case 40:
            case 41:
            case 45:
            case 47:
            case 60:
            case 61:
            case 62:
              if ( v61 )
                goto LABEL_247;
              v65 = v58[v73 + 2];
              v73 += 2;
              if ( v74 < a3 )
                *(_BYTE *)(v59 + v74) = 63;
              if ( ++v74 < a3 )
                *(_BYTE *)(v59 + v74) = 34;
              if ( ++v74 < a3 )
                *(_BYTE *)(v59 + v74) = 34;
              if ( ++v74 < a3 )
                *(_BYTE *)(v59 + v74) = 63;
              ++v74;
              break;
            default:
              break;
          }
        }
        dword_806C25C = (int)&loc_805B6A4;
        sub_8062A98();
LABEL_91:
        v66 = 97;
LABEL_106:
        if ( v60 )
        {
          v23 = v66;
          v65 = v66;
LABEL_205:
          v43 = v23;
          v42 = a1;
          v35 = &loc_805B74A;
          if ( !v61 )
            v35 = &loc_805B74F;
          dword_806C270 = (int)v35;
          a1 = v42;
          sub_8062A28(v44);
          goto LABEL_247;
        }
        dword_806C248 = (int)&loc_805B6A4;
        v16 = sub_8062B10(v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54);
LABEL_109:
        if ( a5 == -1 )
        {
          v16 = (unsigned __int8)v58[1];
          LOBYTE(v16) = (_BYTE)v16 != 0;
        }
        else
        {
          LOBYTE(v16) = a5 != 1;
        }
        if ( !(_BYTE)v16 )
        {
LABEL_113:
          if ( !v73 )
          {
LABEL_114:
            v69 = 1;
LABEL_115:
            v43 = v16;
            v42 = a1;
            v24 = &loc_805B221;
            if ( a6 != 2 )
              v24 = &loc_805B23E;
            dword_806C270 = (int)v24;
            a1 = v42;
            sub_8062A28(v44);
            if ( v61 )
            {
              dword_806C298 = (int)&loc_805B9AC;
              sub_8062925(v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54);
            }
          }
        }
LABEL_198:
        v33 = v60 ^ 1;
        if ( v60 == 1 && a6 != 2 || (v33 = !v61, v61 == 1) )
        {
          v43 = v33;
          v42 = a1;
          v34 = &loc_805B6DF;
          if ( !v57 )
            v34 = &loc_805B71B;
          dword_806C234 = (int)v34;
          a1 = v42;
          sub_8062B84(v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57);
          v12 = v65 & 0x1F;
          v15 = *(_DWORD *)(4 * (v65 >> 5) + v57) >> v12;
          v23 = v15 & 1;
          if ( v15 & 1 )
            goto LABEL_205;
        }
        v23 = v67 ^ 1;
        if ( v67 == 1 )
          goto LABEL_205;
LABEL_208:
        if ( v62 && v68 != 1 )
        {
          if ( v74 < a3 )
          {
            v15 = v59;
            *(_BYTE *)(v59 + v74) = 39;
          }
          if ( ++v74 < a3 )
          {
            v15 = v59;
            *(_BYTE *)(v59 + v74) = 39;
          }
          ++v74;
          v62 = 0;
        }
        if ( v74 < a3 )
        {
          v15 = v74 + v59;
          *(_BYTE *)(v74 + v59) = v65;
        }
        ++v74;
        if ( v69 != 1 )
          v64 = 0;
LABEL_219:
        ++v73;
        if ( a5 == -1 )
        {
          v15 = (int)v58;
          v10 = (unsigned __int8)v58[v73];
          LOBYTE(v10) = (_BYTE)v10 != 0;
        }
        else
        {
          v10 = v73;
          LOBYTE(v10) = v73 != a5;
        }
        if ( (_BYTE)v10 )
          continue;
        v43 = v10;
        v42 = a1;
        v36 = &loc_805B87C;
        if ( v74 )
          v36 = &loc_805B88D;
        dword_806C2AC = (int)v36;
        a1 = v42;
        sub_80628B5(v12, v15);
        if ( a6 == 2 && v61 )
        {
LABEL_247:
          if ( a6 == 2 )
          {
            if ( v60 )
              a6 = 4;
          }
          return sub_805AB8E(a1, v59, a3, v58, a5, a6, a7 & 0xFFFFFFFD, 0, v56, v55);
        }
        if ( a6 == 2 )
        {
          v43 = !v61;
          v42 = a1;
          v39 = &loc_805B8BB;
          if ( v61 == 1 )
            v39 = &loc_805B93E;
          dword_806C2AC = (int)v39;
          a1 = v42;
          sub_80628B5(v38, v37);
          if ( v63 )
          {
            if ( v64 )
              return sub_805AB8E(a1, v59, v75, v58, a5, 5, a7, v57, v56, v55);
            if ( !a3 && v75 )
            {
              a3 = v75;
              v74 = 0;
              goto LABEL_2;
            }
          }
        }
        if ( s )
        {
          v43 = !v61;
          v42 = a1;
          v41 = &loc_805B968;
          if ( v61 == 1 )
            v41 = &loc_805B994;
          dword_806C25C = (int)v41;
          sub_8062A98();
          while ( *s )
          {
            if ( v74 < a3 )
              *(_BYTE *)(v74 + v59) = *s;
            ++v74;
            ++s;
          }
        }
        if ( v74 < a3 )
          *(_BYTE *)(v59 + v74) = 0;
        return v74;
      case 0x5Cu:
        v66 = v65;
        v43 = v65;
        v42 = a1;
        v22 = &loc_805B15A;
        if ( a6 != 2 )
          v22 = &loc_805B17C;
        dword_806C2EC = (int)v22;
        a1 = v42;
        sub_80626B4();
        if ( v61 )
        {
          dword_806C270 = (int)&loc_805B9AC;
          sub_8062A28(v44);
        }
        goto LABEL_208;
      case 0x7Bu:
      case 0x7Du:
        goto LABEL_109;
      default:
        if ( v71 )
        {
          v78 = 1;
          v26 = *__ctype_b_loc();
          v15 = 2 * v65;
          v70 = (*(const unsigned __int16 *)((char *)v26 + v15) & 0x4000) != 0;
          goto LABEL_157;
        }
        memset(&ps, 0, 8u);
        v78 = 0;
        v70 = 1;
        if ( a5 == -1 )
          a5 = strlen(v58);
        while ( 2 )
        {
          v46 = a5 - (v78 + v73);
          v45 = &v58[v78 + v73];
          v80 = sub_8060706(&v44 - 15, v45, v46, (mbstate_t *)(&v44 - 5));
          if ( v80 )
          {
            if ( v80 == -1 )
            {
              v70 = 0;
            }
            else
            {
              if ( v80 != -2 )
              {
                if ( v61 && a6 == 2 )
                {
                  v79 = 1;
                  while ( v79 < v80 )
                  {
                    switch ( v58[v79 + v78 + v73] )
                    {
                      case 91:
                      case 92:
                      case 94:
                      case 96:
                      case 124:
                        goto LABEL_247;
                      default:
                        ++v79;
                        break;
                    }
                  }
                }
                if ( !iswprint(wc) )
                  v70 = 0;
                v78 += v80;
                if ( mbsinit(&ps) )
                  break;
                continue;
              }
              v70 = 0;
              while ( 1 )
              {
                v15 = v73;
                if ( v73 + v78 >= a5 )
                  break;
                v15 = v78 + v73;
                if ( !v58[v78 + v73] )
                  break;
                ++v78;
              }
            }
          }
          break;
        }
LABEL_157:
        v69 = v70;
        if ( v78 > 1 || v60 && v70 != 1 )
        {
          v27 = (char *)v73;
          v28 = v73 + v78;
          v81 = v73 + v78;
          while ( 1 )
          {
            if ( v60 )
            {
              v43 = !v70;
              v42 = a1;
              v29 = &loc_805B4EC;
              if ( v70 == 1 )
                v29 = &loc_805B5E6;
              dword_806C284 = (int)v29;
              a1 = v42;
              v30 = sub_80629B0(v12, v27);
              if ( v61 )
                goto LABEL_247;
              v68 = 1;
              v43 = v30;
              v42 = a1;
              v31 = &loc_805B51A;
              if ( a6 != 2 )
                v31 = &loc_805B57D;
              dword_806C248 = (int)v31;
              a1 = v42;
              sub_8062B10(v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54);
              if ( v62 != 1 )
              {
                if ( v74 < a3 )
                {
                  v15 = v59;
                  *(_BYTE *)(v59 + v74) = 39;
                }
                if ( ++v74 < a3 )
                {
                  v15 = v59;
                  *(_BYTE *)(v59 + v74) = 36;
                }
                if ( ++v74 < a3 )
                {
                  v15 = v59;
                  *(_BYTE *)(v59 + v74) = 39;
                }
                ++v74;
                v62 = 1;
              }
              if ( v74 < a3 )
              {
                v15 = v59;
                *(_BYTE *)(v59 + v74) = 92;
              }
              if ( ++v74 < a3 )
              {
                v15 = v74 + v59;
                *(_BYTE *)(v74 + v59) = (v65 >> 6) + 48;
              }
              if ( ++v74 < a3 )
              {
                v15 = v74 + v59;
                *(_BYTE *)(v74 + v59) = ((v65 >> 3) & 7) + 48;
              }
              ++v74;
              v65 = (v65 & 7) + 48;
            }
            else
            {
              v43 = v28;
              v42 = a1;
              v32 = &loc_805B605;
              if ( !v67 )
                v32 = &loc_805B620;
              dword_806C298 = (int)v32;
              a1 = v42;
              sub_8062925(v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54);
              if ( v74 < a3 )
              {
                v15 = v59;
                *(_BYTE *)(v59 + v74) = 92;
              }
              ++v74;
              v67 = 0;
            }
            if ( v73 + 1 >= v81 )
              goto LABEL_208;
            if ( v62 && v68 != 1 )
            {
              if ( v74 < a3 )
                *(_BYTE *)(v59 + v74) = 39;
              if ( ++v74 < a3 )
                *(_BYTE *)(v59 + v74) = 39;
              ++v74;
              v62 = 0;
            }
            if ( v74 < a3 )
              *(_BYTE *)(v74 + v59) = v65;
            ++v74;
            ++v73;
            v27 = v58;
            v28 = (unsigned __int8)v58[v73];
            v65 = v58[v73];
          }
        }
        goto LABEL_198;
    }
  }
}
// 80626B4: using guessed type int sub_80626B4(void);
// 80628B5: using guessed type int __fastcall sub_80628B5(_DWORD, _DWORD);
// 8062925: using guessed type int __stdcall sub_8062925(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8062A28: using guessed type int __stdcall sub_8062A28(_DWORD);
// 8062B10: using guessed type int __stdcall sub_8062B10(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8062B84: using guessed type int __stdcall sub_8062B84(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806C234: using guessed type int dword_806C234;
// 806C248: using guessed type int dword_806C248;
// 806C25C: using guessed type int dword_806C25C;
// 806C270: using guessed type int dword_806C270;
// 806C284: using guessed type int dword_806C284;
// 806C298: using guessed type int dword_806C298;
// 806C2AC: using guessed type int dword_806C2AC;
// 806C2EC: using guessed type int dword_806C2EC;

//----- (0805BB1F) --------------------------------------------------------
#error "805BC8F: call analysis failed (funcsize=106)"

//----- (0805BD4F) --------------------------------------------------------
void *__cdecl sub_805BD4F(signed int a1, char *a2, size_t a3, int a4)
{
  int *v4; // eax
  void *v5; // edx
  unsigned int v6; // ST44_4
  bool v8; // [esp+37h] [ebp-21h]
  int *v9; // [esp+38h] [ebp-20h]
  void *ptr; // [esp+3Ch] [ebp-1Ch]
  int v11; // [esp+40h] [ebp-18h]
  int size; // [esp+44h] [ebp-14h]
  int v13; // [esp+48h] [ebp-10h]
  unsigned int v14; // [esp+4Ch] [ebp-Ch]

  v11 = *__errno_location();
  v9 = off_806C3EC;
  if ( a1 < 0 )
    abort();
  if ( dword_806C3E0 <= a1 )
  {
    v8 = off_806C3EC == &dword_806C3E4;
    if ( (unsigned int)a1 > 0xFFFFFFE )
      sub_805F305();
    if ( v8 )
      v4 = 0;
    else
      v4 = off_806C3EC;
    v9 = (int *)sub_805F1A5(v4, 8 * (a1 + 1));
    off_806C3EC = v9;
    if ( v8 )
    {
      v5 = off_806C3E8;
      *v9 = dword_806C3E4;
      v9[1] = (int)v5;
    }
    memset(&v9[2 * dword_806C3E0], 0, 8 * (a1 + 1 - dword_806C3E0));
    dword_806C3E0 = a1 + 1;
  }
  v6 = v9[2 * a1];
  ptr = (void *)v9[2 * a1 + 1];
  v13 = *(_DWORD *)(a4 + 4) | 1;
  v14 = sub_805AB8E(a4 + 8, (int)ptr, v6, a2, a3, *(_DWORD *)a4, v13, a4 + 8, *(char **)(a4 + 40), *(char **)(a4 + 44));
  if ( v6 <= v14 )
  {
    size = v14 + 1;
    v9[2 * a1] = v14 + 1;
    if ( ptr != &unk_806D076 )
      free(ptr);
    ptr = sub_805F115(size);
    v9[2 * a1 + 1] = (int)ptr;
    sub_805AB8E(a4 + 8, (int)ptr, size, a2, a3, *(_DWORD *)a4, v13, a4 + 8, *(char **)(a4 + 40), *(char **)(a4 + 44));
  }
  *__errno_location() = v11;
  return ptr;
}
// 806C3E0: using guessed type int dword_806C3E0;
// 806C3E4: using guessed type int dword_806C3E4;
// 806C3E8: using guessed type void *off_806C3E8;
// 806C3EC: using guessed type int *off_806C3EC;

//----- (0805BFB8) --------------------------------------------------------
void *__cdecl sub_805BFB8(signed int a1, char *a2)
{
  return sub_805BD4F(a1, a2, 0xFFFFFFFF, (int)&dword_806D036);
}
// 806D036: using guessed type int dword_806D036;

//----- (0805BFE2) --------------------------------------------------------
void *__cdecl sub_805BFE2(signed int a1, char *a2, size_t a3)
{
  return sub_805BD4F(a1, a2, a3, (int)&dword_806D036);
}
// 806D036: using guessed type int dword_806D036;

//----- (0805C058) --------------------------------------------------------
void *__cdecl sub_805C058(signed int a1, int a2, char *a3)
{
  char v4; // [esp+10h] [ebp-38h]

  sub_805A9FF(&v4, a2);
  return sub_805BD4F(a1, a3, 0xFFFFFFFF, (int)&v4);
}

//----- (0805C096) --------------------------------------------------------
void *__cdecl sub_805C096(signed int a1, int a2, char *a3, size_t a4)
{
  char v5; // [esp+10h] [ebp-38h]

  sub_805A9FF(&v5, a2);
  return sub_805BD4F(a1, a3, a4, (int)&v5);
}

//----- (0805C0D3) --------------------------------------------------------
void *__cdecl sub_805C0D3(int a1, char *a2)
{
  return sub_805C058(0, a1, a2);
}

//----- (0805C12E) --------------------------------------------------------
void *__cdecl sub_805C12E(char *a1, size_t a2, unsigned __int8 a3)
{
  int v4; // [esp+0h] [ebp-58h]
  unsigned __int8 v5; // [esp+1Ch] [ebp-3Ch]
  int v6; // [esp+20h] [ebp-38h]
  int v7; // [esp+24h] [ebp-34h]
  int v8; // [esp+28h] [ebp-30h]
  int v9; // [esp+2Ch] [ebp-2Ch]
  int v10; // [esp+30h] [ebp-28h]
  int v11; // [esp+34h] [ebp-24h]
  int v12; // [esp+38h] [ebp-20h]
  int v13; // [esp+3Ch] [ebp-1Ch]
  int v14; // [esp+40h] [ebp-18h]
  int v15; // [esp+44h] [ebp-14h]
  int v16; // [esp+48h] [ebp-10h]
  int v17; // [esp+4Ch] [ebp-Ch]

  v5 = a3;
  v6 = dword_806D036;
  v7 = dword_806D03A;
  v8 = dword_806D03E;
  v9 = dword_806D042;
  v10 = dword_806D046;
  v11 = dword_806D04A;
  v12 = dword_806D04E;
  v13 = dword_806D052;
  v14 = dword_806D056;
  v15 = dword_806D05A;
  v16 = dword_806D05E;
  v17 = dword_806D062;
  sub_805A8EB((int)(&v4 - 14), a3, 1);
  return sub_805BD4F(0, a1, a2, (int)&v6);
}
// 806D036: using guessed type int dword_806D036;
// 806D03A: using guessed type int dword_806D03A;
// 806D03E: using guessed type int dword_806D03E;
// 806D042: using guessed type int dword_806D042;
// 806D046: using guessed type int dword_806D046;
// 806D04A: using guessed type int dword_806D04A;
// 806D04E: using guessed type int dword_806D04E;
// 806D052: using guessed type int dword_806D052;
// 806D056: using guessed type int dword_806D056;
// 806D05A: using guessed type int dword_806D05A;
// 806D05E: using guessed type int dword_806D05E;
// 806D062: using guessed type int dword_806D062;

//----- (0805C1E8) --------------------------------------------------------
#error "805C212: call analysis failed (funcsize=18)"

//----- (0805C225) --------------------------------------------------------
#error "805C235: positive sp value has been found (funcsize=0)"

//----- (0805C236) --------------------------------------------------------
int __cdecl sub_805C236(int a1)
{
  return sub_805C1E8(a1, 58);
}
// 805C1E8: using guessed type _DWORD __cdecl sub_805C1E8(_DWORD, _DWORD);

//----- (0805C2D5) --------------------------------------------------------
int __cdecl sub_805C2D5(int a1, int a2)
{
  int v2; // edx
  int v3; // ecx
  int v5; // [esp+0h] [ebp-78h]
  int v6; // [esp+10h] [ebp-68h]
  int v7; // [esp+14h] [ebp-64h]
  int v8; // [esp+18h] [ebp-60h]
  int v9; // [esp+1Ch] [ebp-5Ch]
  int v10; // [esp+20h] [ebp-58h]
  int v11; // [esp+24h] [ebp-54h]
  int v12; // [esp+28h] [ebp-50h]
  int v13; // [esp+2Ch] [ebp-4Ch]
  int v14; // [esp+30h] [ebp-48h]
  int v15; // [esp+34h] [ebp-44h]
  int v16; // [esp+38h] [ebp-40h]
  int v17; // [esp+3Ch] [ebp-3Ch]
  int v18; // [esp+40h] [ebp-38h]
  int v19; // [esp+44h] [ebp-34h]
  int v20; // [esp+48h] [ebp-30h]
  int v21; // [esp+4Ch] [ebp-2Ch]
  int v22; // [esp+50h] [ebp-28h]
  int v23; // [esp+54h] [ebp-24h]
  int v24; // [esp+58h] [ebp-20h]
  int v25; // [esp+5Ch] [ebp-1Ch]
  int v26; // [esp+60h] [ebp-18h]
  int v27; // [esp+64h] [ebp-14h]
  int v28; // [esp+68h] [ebp-10h]
  int v29; // [esp+6Ch] [ebp-Ch]

  sub_805A9FF(&v6, a2);
  v18 = v6;
  v19 = v7;
  v20 = v8;
  v21 = v9;
  v22 = v10;
  v23 = v11;
  v24 = v12;
  v25 = v13;
  v26 = v14;
  v27 = v15;
  v28 = v16;
  v29 = v17;
  sub_805A8EB((int)(&v5 - 14), 0x3Au, 1);
  dword_806C2AC = (int)sub_805C3AA;
  return sub_80628B5(v3, v2);
}
// 805C3AA: using guessed type int sub_805C3AA();
// 80628B5: using guessed type int __fastcall sub_80628B5(_DWORD, _DWORD);
// 806C2AC: using guessed type int dword_806C2AC;

//----- (0805C3CF) --------------------------------------------------------
void *__cdecl sub_805C3CF(signed int a1, int a2, int a3, char *a4)
{
  return sub_805C40F(a1, a2, a3, a4, 0xFFFFFFFF);
}

//----- (0805C40F) --------------------------------------------------------
void *__cdecl sub_805C40F(signed int a1, int a2, int a3, char *a4, size_t a5)
{
  int v6; // [esp+0h] [ebp-48h]
  int v7; // [esp+10h] [ebp-38h]
  int v8; // [esp+14h] [ebp-34h]
  int v9; // [esp+18h] [ebp-30h]
  int v10; // [esp+1Ch] [ebp-2Ch]
  int v11; // [esp+20h] [ebp-28h]
  int v12; // [esp+24h] [ebp-24h]
  int v13; // [esp+28h] [ebp-20h]
  int v14; // [esp+2Ch] [ebp-1Ch]
  int v15; // [esp+30h] [ebp-18h]
  int v16; // [esp+34h] [ebp-14h]
  int v17; // [esp+38h] [ebp-10h]
  int v18; // [esp+3Ch] [ebp-Ch]

  v7 = dword_806D036;
  v8 = dword_806D03A;
  v9 = dword_806D03E;
  v10 = dword_806D042;
  v11 = dword_806D046;
  v12 = dword_806D04A;
  v13 = dword_806D04E;
  v14 = dword_806D052;
  v15 = dword_806D056;
  v16 = dword_806D05A;
  v17 = dword_806D05E;
  v18 = dword_806D062;
  sub_805A9BE(&v6 - 14, a2, a3);
  return sub_805BD4F(a1, a4, a5, (int)&v7);
}
// 806D036: using guessed type int dword_806D036;
// 806D03A: using guessed type int dword_806D03A;
// 806D03E: using guessed type int dword_806D03E;
// 806D042: using guessed type int dword_806D042;
// 806D046: using guessed type int dword_806D046;
// 806D04A: using guessed type int dword_806D04A;
// 806D04E: using guessed type int dword_806D04E;
// 806D052: using guessed type int dword_806D052;
// 806D056: using guessed type int dword_806D056;
// 806D05A: using guessed type int dword_806D05A;
// 806D05E: using guessed type int dword_806D05E;
// 806D062: using guessed type int dword_806D062;

//----- (0805C5AD) --------------------------------------------------------
void *__cdecl sub_805C5AD(signed int a1, char *a2, size_t a3)
{
  return sub_805BD4F(a1, a2, a3, (int)&unk_806C400);
}

//----- (0805C608) --------------------------------------------------------
void *__cdecl sub_805C608(signed int a1, char *a2)
{
  return sub_805C5AD(a1, a2, 0xFFFFFFFF);
}

//----- (0805C62A) --------------------------------------------------------
void *__cdecl sub_805C62A(char *a1)
{
  return sub_805C608(0, a1);
}

//----- (0805C645) --------------------------------------------------------
void __cdecl __noreturn sub_805C645(char *a1)
{
  void *v1; // esi
  char *v2; // ebx
  int *v3; // eax

  if ( a1 )
  {
    v1 = sub_805C62A(a1);
    if ( *__errno_location() )
      v2 = gettext("%s: read error");
    else
      v2 = gettext("%s: end of file");
    v3 = __errno_location();
    error(status, *v3, v2, v1);
  }
  abort();
}

//----- (0805C6B6) --------------------------------------------------------
_DWORD *__cdecl sub_805C6B6(int a1, int a2)
{
  _DWORD *result; // eax

  result = sub_805F128(0x81Cu);
  *result = a1;
  result[1] = sub_805C645;
  result[2] = a2;
  return result;
}

//----- (0805C6FB) --------------------------------------------------------
size_t __cdecl sub_805C6FB(int a1, int a2, size_t nbytes)
{
  size_t v3; // eax
  size_t v4; // eax
  size_t v5; // eax
  size_t v6; // eax
  size_t v7; // eax
  size_t result; // eax
  size_t v9; // eax
  int v10; // [esp+0h] [ebp-48h]
  unsigned int v11; // [esp+18h] [ebp-30h]
  void *buf; // [esp+1Ch] [ebp-2Ch]
  int fd; // [esp+20h] [ebp-28h]
  size_t n; // [esp+24h] [ebp-24h]
  size_t v15; // [esp+28h] [ebp-20h]
  size_t v16; // [esp+2Ch] [ebp-1Ch]
  size_t v17; // [esp+30h] [ebp-18h]
  size_t v18; // [esp+34h] [ebp-14h]
  __uid_t src; // [esp+38h] [ebp-10h]

  buf = (void *)a1;
  v11 = 0;
  fd = open64("/dev/urandom", 0);
  if ( fd >= 0 )
  {
    v3 = a2;
    if ( nbytes <= a2 )
      v3 = nbytes;
    v11 = read(fd, buf, v3);
    if ( (v11 & 0x80000000) != 0 )
      v11 = 0;
    close(fd);
  }
  if ( v11 < a2 )
  {
    v5 = a2 - v11;
    if ( a2 - v11 > 8 )
      v5 = 8;
    n = v5;
    gettimeofday((struct timeval *)&v10 - 2, 0);
    memcpy((char *)buf + v11, &src, n);
    v11 += n;
  }
  if ( v11 < a2 )
  {
    v4 = a2 - v11;
    if ( a2 - v11 > 4 )
      v4 = 4;
    v15 = v4;
    src = getpid();
    memcpy((char *)buf + v11, &src, v15);
    v11 += v15;
  }
  if ( v11 < a2 )
  {
    v6 = a2 - v11;
    if ( a2 - v11 > 4 )
      v6 = 4;
    v16 = v6;
    src = getppid();
    memcpy((char *)buf + v11, &src, v16);
    v11 += v16;
  }
  if ( v11 < a2 )
  {
    v7 = a2 - v11;
    if ( a2 - v11 > 4 )
      v7 = 4;
    v17 = v7;
    src = getuid();
    memcpy((char *)buf + v11, &src, v17);
    v11 += v17;
  }
  result = v11;
  if ( v11 < a2 )
  {
    v9 = a2 - v11;
    if ( a2 - v11 > 4 )
      v9 = 4;
    v18 = v9;
    src = getgid();
    memcpy((char *)buf + v11, &src, v18);
    result = v11 + v18;
  }
  return result;
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);

//----- (0805C960) --------------------------------------------------------
char *__cdecl sub_805C960(int a1, size_t n)
{
  size_t v3; // eax
  FILE *stream; // [esp+18h] [ebp-10h]
  char *v5; // [esp+1Ch] [ebp-Ch]

  if ( !n )
    return (char *)sub_805C6B6(0, 0);
  stream = 0;
  if ( a1 )
  {
    stream = sub_80616E8(a1, "rb");
    if ( !stream )
      return 0;
  }
  v5 = (char *)sub_805C6B6((int)stream, a1);
  if ( stream )
  {
    v3 = 2048;
    if ( n <= 0x800 )
      v3 = n;
    setvbuf(stream, v5 + 12, 0, v3);
  }
  else
  {
    *((_DWORD *)v5 + 3) = 0;
    sub_805C6FB((int)(v5 + 16), 1024, n);
    sub_805D414(v5 + 16);
  }
  return v5;
}
// 805D414: using guessed type _DWORD __cdecl sub_805D414(_DWORD);

//----- (0805CA6C) --------------------------------------------------------
#error "805CADC: call analysis failed (funcsize=65)"

//----- (0805CB37) --------------------------------------------------------
int __usercall sub_805CB37@<eax>(int a1@<ebx>, int a2, void *dest, size_t n)
{
  int result; // eax
  void *v5; // eax
  void *v6; // eax
  int v7; // eax
  int v8; // edx
  int v9; // ecx
  int v10; // [esp-8h] [ebp-30h]
  int v11; // [esp-4h] [ebp-2Ch]
  void *v12; // [esp+4h] [ebp-24h]
  size_t i; // [esp+14h] [ebp-14h]
  char *v14; // [esp+18h] [ebp-10h]
  char *v15; // [esp+1Ch] [ebp-Ch]
  char *desta; // [esp+34h] [ebp+Ch]

  for ( i = *(_DWORD *)a2; ; i = 1024 )
  {
    v15 = (char *)dest;
    if ( n <= i )
    {
      memcpy(dest, (const void *)(a2 + 1024 - i + 1040), n);
      result = a2;
      *(_DWORD *)a2 = i - n;
      return result;
    }
    memcpy(dest, (const void *)(a2 + 1024 - i + 1040), i);
    desta = &v15[i];
    n -= i;
    v11 = ((_BYTE)v15 + (_BYTE)i) & 3;
    v10 = a1;
    v5 = &loc_805CC1B;
    if ( ((_BYTE)v15 + (_BYTE)i) & 3 )
      v5 = &loc_805CC96;
    dword_806C2EC = (int)v5;
    a1 = v10;
    sub_80626B4();
    v14 = desta;
    if ( n > 0x3FF )
      break;
    dest = v14;
    v12 = (void *)(a2 + 1040);
    sub_805CDBE(a2 + 4);
  }
  v12 = v14;
  v7 = sub_805CDBE(a2 + 4);
  v14 += 1024;
  v11 = v7;
  v10 = a1;
  v6 = &loc_805CC6E;
  if ( n != 1024 )
    v6 = &loc_805CC87;
  dword_806C2AC = (int)v6;
  sub_80628B5(v9, v8);
  result = a2;
  *(_DWORD *)a2 = 0;
  return result;
}
// 805CB37: could not find valid save-restore pair for ebx
// 805CDBE: using guessed type _DWORD __cdecl sub_805CDBE(_DWORD);
// 80626B4: using guessed type int sub_80626B4(void);
// 80628B5: using guessed type int __fastcall sub_80628B5(_DWORD, _DWORD);
// 806C2AC: using guessed type int dword_806C2AC;
// 806C2EC: using guessed type int dword_806C2EC;

//----- (0805CCBF) --------------------------------------------------------
int __usercall sub_805CCBF@<eax>(int a1@<ebx>, int a2, void *ptr, size_t n)
{
  int result; // eax

  if ( *(_DWORD *)a2 )
    result = sub_805CA6C(a2, ptr, n);
  else
    result = sub_805CB37(a1, a2 + 12, ptr, n);
  return result;
}

//----- (0805CD07) --------------------------------------------------------
#error "805CD4D: call analysis failed (funcsize=29)"

//----- (0805CD66) --------------------------------------------------------
int __cdecl sub_805CD66(int a1)
{
  return a1;
}

//----- (0805CD7D) --------------------------------------------------------
int __cdecl sub_805CD7D(int a1, __int16 a2)
{
  return *(_DWORD *)((a2 & 0x3FC) + a1);
}

//----- (0805CDBE) --------------------------------------------------------
#error "805CE1F: call analysis failed (funcsize=30)"

//----- (0805CE24) --------------------------------------------------------
#error "805CE6D: call analysis failed (funcsize=45)"

//----- (0805CEB0) --------------------------------------------------------
#error "805D18A: positive sp value has been found (funcsize=177)"

//----- (0805D414) --------------------------------------------------------
#error "805D911: call analysis failed (funcsize=207)"

//----- (0805D916) --------------------------------------------------------
#error "805D921: positive sp value has been found (funcsize=0)"

//----- (0805D922) --------------------------------------------------------
int __cdecl sub_805D922(_DWORD *a1)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_8060956(a1 + 3, 0, 0, malloc);
  sub_8060956(a1 + 14, 0, 0, malloc);
  return sub_8060956(a1 + 25, 0, 0, malloc);
}
// 8060956: using guessed type _DWORD __cdecl sub_8060956(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0805DAFA) --------------------------------------------------------
_DWORD *__cdecl sub_805DAFA(_DWORD *a1)
{
  _DWORD *result; // eax
  int src; // [esp+10h] [ebp-38h]
  _DWORD *v3; // [esp+14h] [ebp-34h]
  _DWORD *v4; // [esp+18h] [ebp-30h]
  int v5; // [esp+1Ch] [ebp-2Ch]
  int v6; // [esp+20h] [ebp-28h]
  _DWORD *v7; // [esp+24h] [ebp-24h]
  _DWORD *v8; // [esp+28h] [ebp-20h]
  _DWORD *v9; // [esp+2Ch] [ebp-1Ch]
  _DWORD *v10; // [esp+30h] [ebp-18h]
  _DWORD *v11; // [esp+34h] [ebp-14h]
  size_t n; // [esp+38h] [ebp-10h]
  _DWORD *v13; // [esp+3Ch] [ebp-Ch]

  v3 = a1 + 3;
  src = a1[6] - a1[5] - 1;
  v4 = a1 + 3;
  v5 = a1[5];
  if ( a1[6] == v5 )
    *((_BYTE *)v4 + 40) |= 2u;
  v4[3] = (v4[6] + v4[3]) & ~v4[6];
  if ( v4[3] - v4[1] > (unsigned int)(v4[4] - v4[1]) )
    v4[3] = v4[4];
  v4[2] = v4[3];
  v6 = v5;
  v7 = a1 + 14;
  v8 = a1 + 14;
  if ( (unsigned int)(a1[18] - a1[17]) <= 3 )
    sub_8060AA5((int)v7, 4);
  v9 = v7;
  v10 = (_DWORD *)v7[3];
  *v10 = v6;
  v9[3] += 4;
  v11 = a1 + 25;
  n = 4;
  v13 = a1 + 25;
  if ( (unsigned int)(a1[29] - a1[28]) < 4 )
    sub_8060AA5((int)v11, n);
  memcpy((void *)v11[3], &src, n);
  v11[3] += n;
  result = a1;
  ++*a1;
  return result;
}

//----- (0805DCDF) --------------------------------------------------------
#error "805DDDC: call analysis failed (funcsize=130)"

//----- (0805DF01) --------------------------------------------------------
#error "805E062: positive sp value has been found (funcsize=121)"

//----- (0805E07E) --------------------------------------------------------
int __cdecl sub_805E07E(int a1, int a2)
{
  int v2; // eax

  v2 = mkostemp64(a1, a2);
  return sub_8061654(v2, a2);
}
// 8049A10: using guessed type int __cdecl mkostemp64(_DWORD, _DWORD);

//----- (0805E0A7) --------------------------------------------------------
#error "805E251: call analysis failed (funcsize=123)"

//----- (0805E261) --------------------------------------------------------
#error "805E3AF: call analysis failed (funcsize=403)"

//----- (0805E787) --------------------------------------------------------
int __cdecl sub_805E787(int a1, int a2, int a3, int a4)
{
  return sub_805E261(a1, a2, a3, a4);
}
// 805E261: using guessed type _DWORD __cdecl sub_805E261(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0805E7BF) --------------------------------------------------------
int __cdecl sub_805E7BF(int fd)
{
  int v1; // ST18_4
  int v2; // ST1C_4

  if ( fd >= 0 && fd <= 2 )
  {
    v1 = sub_80621F7(fd);
    v2 = *__errno_location();
    close(fd);
    *__errno_location() = v2;
    fd = v1;
  }
  return fd;
}

//----- (0805E809) --------------------------------------------------------
#error "805ECA9: call analysis failed (funcsize=371)"

//----- (0805EEC9) --------------------------------------------------------
int __cdecl sub_805EEC9(FILE *stream, int a2, int a3, int a4, int a5)
{
  int *v5; // eax
  unsigned int i; // [esp+24h] [ebp-34h]
  int v8[12]; // [esp+28h] [ebp-30h]

  for ( i = 0; i <= 9; ++i )
  {
    v5 = (int *)a5;
    a5 += 4;
    v8[i] = *v5;
    if ( !v8[i] )
      break;
  }
  return sub_805E809(stream, a2, a3, a4, (int)v8, i);
}
// 805EEC9: using guessed type int var_30[12];

//----- (0805EF3F) --------------------------------------------------------
int sub_805EF3F(FILE *stream, int a2, int a3, int a4, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a4);
  return sub_805EEC9(stream, a2, a3, a4, (int)va);
}

//----- (0805EFEF) --------------------------------------------------------
void *__cdecl sub_805EFEF(unsigned int a1, unsigned int a2)
{
  if ( 0x7FFFFFFF / a2 < a1 )
    sub_805F305();
  return sub_805F128(a2 * a1);
}

//----- (0805F062) --------------------------------------------------------
void *__cdecl sub_805F062(void *ptr, int a2, int a3)
{
  unsigned int v4; // [esp+1Ch] [ebp-Ch]

  v4 = *(_DWORD *)a2;
  if ( ptr )
  {
    if ( 0x55555554u / a3 <= v4 )
      sub_805F305();
    v4 += (v4 >> 1) + 1;
  }
  else
  {
    if ( !v4 )
      v4 = (0x40u / a3 == 0) + 0x40u / a3;
    if ( 0x7FFFFFFFu / a3 < v4 )
      sub_805F305();
  }
  *(_DWORD *)a2 = v4;
  return sub_805F1A5(ptr, a3 * v4);
}

//----- (0805F115) --------------------------------------------------------
void *__cdecl sub_805F115(size_t size)
{
  return sub_805F128(size);
}

//----- (0805F128) --------------------------------------------------------
void *__cdecl sub_805F128(size_t size)
{
  void *result; // eax
  int v2; // edx
  int v3; // ecx
  void *v4; // eax

  result = malloc(size);
  if ( !result )
  {
    v4 = &loc_805F187;
    if ( !size )
      v4 = &loc_805F1A0;
    dword_806C220 = (int)v4;
    sub_8062BFE(v3, v2);
    sub_805F305();
  }
  return result;
}
// 8062BFE: using guessed type int __fastcall sub_8062BFE(_DWORD, _DWORD);
// 806C220: using guessed type int dword_806C220;

//----- (0805F1A5) --------------------------------------------------------
void *__cdecl sub_805F1A5(void *ptr, size_t size)
{
  void *v2; // eax
  bool v3; // zf
  void *v4; // eax
  void *result; // eax
  int v6; // [esp+0h] [ebp-18h]
  void *ptra; // [esp+20h] [ebp+8h]

  if ( size || !ptr )
  {
    v2 = realloc(ptr, size);
    ptra = v2;
    v3 = v2 == 0;
    v4 = &loc_805F203;
    if ( !v3 )
      v4 = &loc_805F229;
    dword_806C270 = (int)v4;
    sub_8062A28(v6);
    if ( size )
      sub_805F305();
    result = ptra;
  }
  else
  {
    free(ptr);
    result = 0;
  }
  return result;
}
// 8062A28: using guessed type int __stdcall sub_8062A28(_DWORD);
// 806C270: using guessed type int dword_806C270;

//----- (0805F27A) --------------------------------------------------------
void *__cdecl sub_805F27A(size_t nmemb, size_t size)
{
  void *v3; // [esp+1Ch] [ebp-Ch]

  if ( 0x7FFFFFFF / size < nmemb || (v3 = calloc(nmemb, size)) == 0 )
    sub_805F305();
  return v3;
}

//----- (0805F2B7) --------------------------------------------------------
void *__cdecl sub_805F2B7(void *src, size_t n)
{
  void *v2; // eax

  v2 = sub_805F128(n);
  return memcpy(v2, src, n);
}

//----- (0805F305) --------------------------------------------------------
void __noreturn sub_805F305()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (0805F33E) --------------------------------------------------------
void __cdecl sub_805F33E(int errnum, int a2, int a3, int a4, int a5)
{
  char *v5; // eax
  char *v6; // eax
  void *v7; // esi
  void *v8; // ebx
  char *v9; // eax

  v5 = gettext("string comparison failed");
  error(0, errnum, v5);
  v6 = gettext("Set LC_ALL='C' to work around the problem.");
  error(0, 0, v6);
  v7 = sub_805C096(1, 8, (char *)a4, a5);
  v8 = sub_805C096(0, 8, (char *)a2, a3);
  v9 = gettext("The strings compared were %s and %s.");
  error(status, 0, v9, v8, v7);
}

//----- (0805F4A8) --------------------------------------------------------
int __cdecl sub_805F4A8(void *a1, size_t n, void *s2, int a4)
{
  void **v4; // ebp
  int *v5; // eax
  int v6; // edx
  int v7; // ecx
  void *s1; // [esp+0h] [ebp-3Ch]
  int v10; // [esp+Ch] [ebp-30h]
  int v11; // [esp+14h] [ebp-28h]
  int v12; // [esp+28h] [ebp-14h]
  int v13; // [esp+38h] [ebp-4h]

  v4 = (void **)&v13;
  v12 = sub_8062045(a1, n, s2, a4);
  v5 = __errno_location();
  while ( 1 )
  {
    *(v4 - 3) = (void *)*v5;
    if ( !*(v4 - 3) )
      break;
    dword_806C2AC = (int)&loc_805F4E8;
    sub_80628B5(v7, v6);
    sub_805F33E((int)*(&s1 - 3), v10 - 1, v10 - 1, v11 - 1, v11 - 1);
    dword_806C25C = (int)&loc_805F590;
    v5 = (int *)sub_8062A98();
    v4 = &s1;
  }
  return (int)*(v4 - 4);
}
// 80628B5: using guessed type int __fastcall sub_80628B5(_DWORD, _DWORD);
// 806C25C: using guessed type int dword_806C25C;
// 806C2AC: using guessed type int dword_806C2AC;

//----- (0805F595) --------------------------------------------------------
#error "805F5BA: call analysis failed (funcsize=14)"

//----- (0805F5BF) --------------------------------------------------------
#error "805F5DE: positive sp value has been found (funcsize=10)"

//----- (0805F634) --------------------------------------------------------
signed int __cdecl sub_805F634(unsigned int *a1, unsigned int a2)
{
  signed int result; // eax

  if ( 0xFFFFFFFF / a2 >= *a1 )
  {
    *a1 *= a2;
    result = 0;
  }
  else
  {
    *a1 = -1;
    result = 1;
  }
  return result;
}

//----- (0805F6CD) --------------------------------------------------------
int __cdecl sub_805F6CD(int a1, int a2, int a3)
{
  int v3; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; i |= sub_805F634((unsigned int *)a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}

//----- (0805F703) --------------------------------------------------------
#error "805F99A: call analysis failed (funcsize=333)"

//----- (0805FBD5) --------------------------------------------------------
void __cdecl sub_805FBD5(int a1, int a2, int a3, int a4, int a5, int status)
{
  char *v6; // eax
  const char *v7; // [esp+Ch] [ebp-2Ch]
  char *v8; // [esp+10h] [ebp-28h]
  int v9; // [esp+14h] [ebp-24h]
  char v10; // [esp+1Ch] [ebp-1Ch]
  char v11; // [esp+22h] [ebp-16h]
  char v12; // [esp+23h] [ebp-15h]
  const char *v13; // [esp+24h] [ebp-14h]
  char *msgid; // [esp+28h] [ebp-10h]
  char *v15; // [esp+2Ch] [ebp-Ch]

  v10 = a3;
  v13 = "--";
  if ( (unsigned int)a1 > 3 )
  {
    if ( a1 != 4 )
      goto LABEL_6;
    msgid = "invalid %s%s argument '%s'";
  }
  else if ( (unsigned int)a1 >= 2 )
  {
    msgid = "invalid suffix in %s%s argument '%s'";
  }
  else
  {
    if ( a1 != 1 )
LABEL_6:
      abort();
    msgid = "%s%s argument '%s' too large";
  }
  if ( a2 >= 0 )
  {
    v15 = *(char **)(16 * a2 + a4);
  }
  else
  {
    v13 -= a2;
    v11 = v10;
    v12 = 0;
    v15 = &v11;
  }
  v6 = gettext(msgid);
  v9 = a5;
  v8 = v15;
  v7 = v13;
  error(status, 0, v6, v13, v15, a5);
}

//----- (0805FCCC) --------------------------------------------------------
void __cdecl __noreturn sub_805FCCC(int a1, int a2, char a3, int a4, int a5)
{
  sub_805FBD5(a1, a2, a3, a4, a5, status);
  abort();
}

//----- (0805FD1F) --------------------------------------------------------
signed int __cdecl sub_805FD1F(int a1, int a2)
{
  unsigned int v2; // ecx
  unsigned int v3; // edx
  unsigned int v4; // ebx
  unsigned int v5; // edx
  signed int result; // eax

  v2 = sub_806221C(-1LL, a2, a2 >> 31);
  v4 = v3;
  v5 = *(_DWORD *)(a1 + 4);
  if ( v4 > v5 || v4 >= v5 && v2 >= *(_DWORD *)a1 )
  {
    *(_QWORD *)a1 *= a2;
    result = 0;
  }
  else
  {
    *(_DWORD *)a1 = -1;
    *(_DWORD *)(a1 + 4) = -1;
    result = 1;
  }
  return result;
}
// 806221C: using guessed type _DWORD __cdecl sub_806221C(__int64, _DWORD, _DWORD);

//----- (0805FDD7) --------------------------------------------------------
int __cdecl sub_805FDD7(int a1, int a2, int a3)
{
  int v3; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; ; i |= sub_805FD1F(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}

//----- (0805FE21) --------------------------------------------------------
int __cdecl sub_805FE21(char *nptr, int a2, int base, int a4, char *s)
{
  char **v5; // eax
  int v6; // edx
  int v7; // ecx
  int result; // eax
  bool v9; // zf
  void *v10; // eax
  int v11; // edx
  int v12; // edx
  int v13; // eax
  int v14; // edx
  int v15; // edx
  int v16; // [esp+0h] [ebp-48h]
  int v17; // [esp+4h] [ebp-44h]
  int v18; // [esp+8h] [ebp-40h]
  int v19; // [esp+Ch] [ebp-3Ch]
  int v20; // [esp+10h] [ebp-38h]
  int v21; // [esp+14h] [ebp-34h]
  int v22; // [esp+18h] [ebp-30h]
  char v23; // [esp+1Ch] [ebp-2Ch]
  int v24; // [esp+20h] [ebp-28h]
  char *v25; // [esp+24h] [ebp-24h]
  int v26; // [esp+28h] [ebp-20h]
  int v27; // [esp+2Ch] [ebp-1Ch]
  int v28; // [esp+30h] [ebp-18h]
  char **endptr; // [esp+34h] [ebp-14h]
  uintmax_t v30; // [esp+38h] [ebp-10h]

  v24 = 0;
  if ( base < 0 || base > 36 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoumax");
  if ( a2 )
    v5 = (char **)a2;
  else
    v5 = (char **)&v23;
  endptr = v5;
  *__errno_location() = 0;
  v25 = nptr;
  HIBYTE(v22) = *nptr;
  while ( (*__ctype_b_loc())[HIBYTE(v22)] & 0x2000 )
    HIBYTE(v22) = *++v25;
  if ( HIBYTE(v22) == 45 )
    return 4;
  v30 = strtoumax(nptr, endptr, base);
  if ( *endptr == nptr )
  {
    if ( s && **endptr )
    {
      if ( strchr(s, **endptr) )
      {
        v30 = 1LL;
        dword_806C220 = (int)&loc_805FFBF;
        sub_8062BFE(v7, v6);
      }
    }
    return 4;
  }
  v9 = *__errno_location() == 0;
  v10 = &loc_805FF81;
  if ( v9 )
    v10 = &loc_805FFBF;
  dword_806C25C = (int)v10;
  sub_8062A98();
  if ( *__errno_location() != 34 )
  {
    dword_806C298 = (int)&locret_80602BA;
    sub_8062925(v16, v17, v18, v19, v20, v21, v22, *(_DWORD *)&v23, v24, v25, v26);
  }
  v24 = 1;
  if ( !s )
  {
    v11 = HIDWORD(v30);
    *(_DWORD *)a4 = v30;
    *(_DWORD *)(a4 + 4) = v11;
    return v24;
  }
  if ( !**endptr )
  {
LABEL_55:
    v15 = HIDWORD(v30);
    *(_DWORD *)a4 = v30;
    *(_DWORD *)(a4 + 4) = v15;
    return v24;
  }
  v26 = 1024;
  v27 = 1;
  if ( !strchr(s, **endptr) )
  {
    v12 = HIDWORD(v30);
    *(_DWORD *)a4 = v30;
    *(_DWORD *)(a4 + 4) = v12;
    return v24 | 2;
  }
  switch ( **endptr )
  {
    case 69:
    case 71:
    case 75:
    case 77:
    case 80:
    case 84:
    case 89:
    case 90:
    case 103:
    case 107:
    case 109:
    case 116:
      if ( !strchr(s, 48) )
        goto LABEL_39;
      v13 = (*endptr)[1];
      switch ( v13 )
      {
        case 68:
          goto LABEL_38;
        case 105:
          if ( (*endptr)[2] == 66 )
          {
            v27 += 2;
            break;
          }
          dword_806C25C = (int)&loc_80600B9;
          sub_8062A98();
          goto LABEL_38;
        case 66:
LABEL_38:
          v26 = 1000;
          ++v27;
          break;
      }
LABEL_39:
      switch ( **endptr )
      {
        case 66:
          v28 = sub_805FD1F((int)&v30, 1024);
          goto LABEL_53;
        case 69:
          v28 = sub_805FDD7((int)&v30, v26, 6);
          goto LABEL_53;
        case 71:
        case 103:
          v28 = sub_805FDD7((int)&v30, v26, 3);
          dword_806C2EC = (int)&loc_8060274;
          sub_80626B4();
          goto LABEL_45;
        case 75:
        case 107:
LABEL_45:
          v28 = sub_805FDD7((int)&v30, v26, 1);
          goto LABEL_53;
        case 77:
        case 109:
          v28 = sub_805FDD7((int)&v30, v26, 2);
          dword_806C248 = (int)&loc_8060274;
          sub_8062B10(v16, v17, v18, v19, v20, v21, v22, *(_DWORD *)&v23, v24, v25, v26);
          goto LABEL_47;
        case 80:
LABEL_47:
          v28 = sub_805FDD7((int)&v30, v26, 5);
          goto LABEL_53;
        case 84:
        case 116:
          v28 = sub_805FDD7((int)&v30, v26, 4);
          goto LABEL_53;
        case 89:
          v28 = sub_805FDD7((int)&v30, v26, 8);
          goto LABEL_53;
        case 90:
          v28 = sub_805FDD7((int)&v30, v26, 7);
          goto LABEL_53;
        case 98:
          v28 = sub_805FD1F((int)&v30, 512);
          goto LABEL_53;
        case 99:
          v28 = 0;
          goto LABEL_53;
        case 119:
          v28 = sub_805FD1F((int)&v30, 2);
LABEL_53:
          v24 |= v28;
          *endptr += v27;
          if ( **endptr )
            v24 |= 2u;
          goto LABEL_55;
        default:
          v14 = HIDWORD(v30);
          *(_DWORD *)a4 = v30;
          *(_DWORD *)(a4 + 4) = v14;
          result = v24 | 2;
          break;
      }
      return result;
    default:
      goto LABEL_39;
  }
}
// 80626B4: using guessed type int sub_80626B4(void);
// 8062925: using guessed type int __stdcall sub_8062925(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8062B10: using guessed type int __stdcall sub_8062B10(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8062BFE: using guessed type int __fastcall sub_8062BFE(_DWORD, _DWORD);
// 806C220: using guessed type int dword_806C220;
// 806C248: using guessed type int dword_806C248;
// 806C25C: using guessed type int dword_806C25C;
// 806C298: using guessed type int dword_806C298;
// 806C2EC: using guessed type int dword_806C2EC;

//----- (080602BC) --------------------------------------------------------
int __cdecl sub_80602BC(FILE *stream)
{
  int v2; // eax
  __int64 v3; // rax
  int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]

  v4 = 0;
  if ( fileno(stream) < 0 )
    return fclose(stream);
  if ( !__freading(stream) || (v2 = fileno(stream), LODWORD(v3) = lseek64(v2, 0, 0, 1), v3 != -1) )
  {
    if ( sub_806056E(stream) )
      v4 = *__errno_location();
  }
  v5 = fclose(stream);
  if ( v4 )
  {
    *__errno_location() = v4;
    v5 = -1;
  }
  return v5;
}
// 8049A90: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0806038F) --------------------------------------------------------
int __cdecl sub_806038F(int fd, int cmd, char a3)
{
  char *v3; // eax
  int v4; // eax
  int *v5; // eax
  int v7; // [esp+8h] [ebp-30h]
  char *v8; // [esp+18h] [ebp-20h]
  int v9; // [esp+1Ch] [ebp-1Ch]
  char v10[4]; // [esp+20h] [ebp-18h]
  int v11; // [esp+24h] [ebp-14h]
  int v12; // [esp+28h] [ebp-10h]
  int v13; // [esp+2Ch] [ebp-Ch]

  v9 = -1;
  v8 = &a3;
  if ( cmd != 1030 )
  {
    v5 = (int *)v8;
    v8 += 4;
    v13 = *v5;
    v7 = v13;
    return fcntl(fd, cmd, v13);
  }
  v3 = v8;
  v8 += 4;
  *(_DWORD *)v10 = *(_DWORD *)v3;
  if ( dword_806D176 < 0 )
  {
    v9 = sub_806038F(fd, 0, v10[0]);
  }
  else
  {
    v7 = *(_DWORD *)v10;
    v9 = fcntl(fd, 1030, *(_DWORD *)v10);
    if ( v9 < 0 && *__errno_location() == 22 )
    {
      v9 = sub_806038F(fd, 0, v10[0]);
      if ( v9 < 0 )
        return v9;
      dword_806D176 = -1;
    }
    else
    {
      dword_806D176 = 1;
    }
  }
  if ( v9 >= 0 && dword_806D176 == -1 )
  {
    v4 = fcntl(v9, 1);
    v11 = v4;
    if ( v4 < 0 || (v7 = v11 | 1, fcntl(v9, 2, v11 | 1) == -1) )
    {
      v12 = *__errno_location();
      close(v9);
      *__errno_location() = v12;
      v9 = -1;
    }
  }
  return v9;
}
// 806D176: using guessed type int dword_806D176;

//----- (08060535) --------------------------------------------------------
int __cdecl sub_8060535(_DWORD *a1)
{
  int result; // eax

  result = *a1 & 0x100;
  if ( result )
    result = sub_80605AE(a1, 0, 0, 1);
  return result;
}

//----- (0806056E) --------------------------------------------------------
int __cdecl sub_806056E(FILE *fp)
{
  if ( !fp || !__freading(fp) )
    return fflush(fp);
  sub_8060535(fp);
  return fflush(fp);
}

//----- (080605AE) --------------------------------------------------------
int __cdecl sub_80605AE(_DWORD *a1, int a2, int a3, int a4)
{
  __int64 v4; // rax
  int v6; // edx
  int v7; // [esp+0h] [ebp-3Ch]
  int v8; // [esp+4h] [ebp-38h]
  int v9; // [esp+8h] [ebp-34h]
  int v10; // [esp+Ch] [ebp-30h]
  int v11; // [esp+10h] [ebp-2Ch]
  int v12; // [esp+14h] [ebp-28h]
  int v13; // [esp+18h] [ebp-24h]
  int v14; // [esp+1Ch] [ebp-20h]
  int v15; // [esp+20h] [ebp-1Ch]
  int v16; // [esp+24h] [ebp-18h]
  __int64 v17; // [esp+28h] [ebp-14h]
  int v18; // [esp+30h] [ebp-Ch]
  int v19; // [esp+34h] [ebp-8h]

  v13 = a2;
  v14 = a3;
  if ( a1[2] != a1[1] || a1[5] != a1[4] )
    return fseeko64(a1, v13, v14, a4, v11, v12, v13, v14, v15, v16, v17, HIDWORD(v17), v18, v19);
  dword_806C234 = (int)&loc_806065B;
  LODWORD(v4) = sub_8062B84(v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, HIDWORD(v17), v18, v19);
  v17 = v4;
  if ( v4 == -1 )
    return -1;
  *a1 &= 0xFFFFFFEF;
  v6 = HIDWORD(v17);
  a1[19] = v17;
  a1[20] = v6;
  return 0;
}
// 80498B0: using guessed type int __stdcall fseeko64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8062B84: using guessed type int __stdcall sub_8062B84(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806C234: using guessed type int dword_806C234;

//----- (08060706) --------------------------------------------------------
size_t __cdecl sub_8060706(wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  size_t v4; // eax
  void *v6; // eax
  int v7; // [esp+0h] [ebp-28h]
  int v8; // [esp+4h] [ebp-24h]
  int v9; // [esp+8h] [ebp-20h]
  int v10; // [esp+Ch] [ebp-1Ch]
  int v11; // [esp+10h] [ebp-18h]
  int v12; // [esp+14h] [ebp-14h]
  char v13; // [esp+18h] [ebp-10h]
  size_t v14; // [esp+1Ch] [ebp-Ch]
  int v15; // [esp+20h] [ebp-8h]
  int v16; // [esp+24h] [ebp-4h]
  int savedregs; // [esp+28h] [ebp+0h]

  if ( !pwc )
    pwc = (wchar_t *)&v13;
  v4 = mbrtowc(pwc, s, n, p);
  v14 = v4;
  if ( v4 <= 0xFFFFFFFD )
    return v14;
  v6 = &loc_8060766;
  if ( !n )
    v6 = &loc_806073A;
  dword_806C248 = (int)v6;
  sub_8062B10(v7, v8, v9, v10, v11, v12, *(_DWORD *)&v13, v14, v15, v16, savedregs);
  if ( !((unsigned __int8)sub_8057E90(0) ^ 1) )
    return v14;
  *pwc = (unsigned __int8)*s;
  return 1;
}
// 8062B10: using guessed type int __stdcall sub_8062B10(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806C248: using guessed type int dword_806C248;

//----- (080607A1) --------------------------------------------------------
int __cdecl sub_80607A1(int a1, int a2)
{
  void (*v2)(void); // eax
  int v3; // edx
  int v5; // [esp+0h] [ebp-18h]
  int v6; // [esp+4h] [ebp-14h]

  if ( *(_BYTE *)(a1 + 40) & 1 )
  {
    v2 = *(void (**)(void))(a1 + 28);
    v3 = *(_DWORD *)(a1 + 36);
    v6 = a2;
    v5 = v3;
    v2();
    dword_806C270 = (int)&locret_80607F2;
    sub_8062A28(v5);
  }
  return (*(int (__cdecl **)(int))(a1 + 28))(a2);
}
// 8062A28: using guessed type int __stdcall sub_8062A28(_DWORD);
// 806C270: using guessed type int dword_806C270;

//----- (080607F4) --------------------------------------------------------
int __cdecl sub_80607F4(int a1, int a2)
{
  int result; // eax

  if ( *(_BYTE *)(a1 + 40) & 1 )
    result = (*(int (__cdecl **)(_DWORD, int))(a1 + 32))(*(_DWORD *)(a1 + 36), a2);
  else
    result = (*(int (__cdecl **)(int))(a1 + 32))(a2);
  return result;
}

//----- (08060832) --------------------------------------------------------
#error "8060875: call analysis failed (funcsize=90)"

//----- (08060956) --------------------------------------------------------
#error "8060984: call analysis failed (funcsize=17)"

//----- (08060989) --------------------------------------------------------
#error "80609BA: positive sp value has been found (funcsize=0)"

//----- (08060AA5) --------------------------------------------------------
int __cdecl sub_8060AA5(int a1, int a2)
{
  int v2; // ecx
  size_t v3; // edx
  unsigned int v4; // eax
  size_t v5; // edx
  void *v6; // eax
  int v7; // edx
  int v8; // ecx
  void *v9; // eax
  int result; // eax
  _DWORD *v11; // [esp+14h] [ebp-24h]
  unsigned int v12; // [esp+18h] [ebp-20h]
  int v13; // [esp+1Ch] [ebp-1Ch]
  size_t n; // [esp+20h] [ebp-18h]
  size_t v15; // [esp+24h] [ebp-14h]
  unsigned int v16; // [esp+28h] [ebp-10h]
  void *dest; // [esp+2Ch] [ebp-Ch]

  v13 = *(_DWORD *)(a1 + 4);
  v11 = 0;
  v3 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 8);
  v4 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 8);
  n = v3;
  v15 = v3 + a2;
  v16 = *(_DWORD *)(a1 + 24) + v3 + a2;
  v5 = v3 >> 3;
  v12 = (v4 >> 3) + v16 + 100;
  if ( v12 < v16 )
    v12 = v16;
  if ( *(_DWORD *)a1 > v12 )
    v12 = *(_DWORD *)a1;
  if ( n <= v15 && v15 <= v16 )
    v11 = (_DWORD *)sub_80607A1(a1, v12);
  v6 = &loc_8060B70;
  if ( v11 )
    v6 = &loc_8060B77;
  dword_806C220 = (int)v6;
  sub_8062BFE(v2, v5);
  obstack_alloc_failed_handler();
  *(_DWORD *)(a1 + 4) = v11;
  v11[1] = v13;
  *(_DWORD *)(a1 + 16) = (char *)v11 + v12;
  *v11 = *(_DWORD *)(a1 + 16);
  dest = (void *)(((unsigned int)v11 + *(_DWORD *)(a1 + 24) + 8) & ~*(_DWORD *)(a1 + 24));
  memcpy(dest, *(const void **)(a1 + 8), n);
  v9 = &loc_8060C12;
  if ( *(_BYTE *)(a1 + 40) & 2 )
    v9 = &loc_8060C64;
  dword_806C2AC = (int)v9;
  sub_80628B5(v8, v7);
  if ( *(_DWORD *)(a1 + 8) == ((*(_DWORD *)(a1 + 24) + v13 + 8) & ~*(_DWORD *)(a1 + 24)) )
  {
    v11[1] = *(_DWORD *)(v13 + 4);
    sub_80607F4(a1, v13);
  }
  *(_DWORD *)(a1 + 8) = dest;
  *(_DWORD *)(a1 + 12) = n + *(_DWORD *)(a1 + 8);
  result = a1;
  *(_BYTE *)(a1 + 40) &= 0xFDu;
  return result;
}
// 8060AA5: could not find valid save-restore pair for ebx
// 80628B5: using guessed type int __fastcall sub_80628B5(_DWORD, _DWORD);
// 8062BFE: using guessed type int __fastcall sub_8062BFE(_DWORD, _DWORD);
// 806C220: using guessed type int dword_806C220;
// 806C2AC: using guessed type int dword_806C2AC;
// 806C4A0: using guessed type int (*obstack_alloc_failed_handler)(void);

//----- (08060CE1) --------------------------------------------------------
int __cdecl sub_8060CE1(int a1, unsigned int a2)
{
  int result; // eax
  int *v3; // ST1C_4
  int *v4; // [esp+18h] [ebp-10h]

  result = *(_DWORD *)(a1 + 4);
  v4 = *(int **)(a1 + 4);
  while ( v4 )
  {
    if ( (unsigned int)v4 < a2 )
    {
      result = *v4;
      if ( *v4 >= a2 )
        break;
    }
    v3 = (int *)v4[1];
    sub_80607F4(a1, (int)v4);
    v4 = v3;
    result = a1;
    *(_BYTE *)(a1 + 40) |= 2u;
  }
  if ( v4 )
  {
    *(_DWORD *)(a1 + 12) = a2;
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 16) = *v4;
    result = a1;
    *(_DWORD *)(a1 + 4) = v4;
  }
  else if ( a2 )
  {
    abort();
  }
  return result;
}

//----- (08060F47) --------------------------------------------------------
int __cdecl sub_8060F47(int a1, char a2)
{
  return __ROR4__(a1, a2);
}

//----- (080610B0) --------------------------------------------------------
signed int __cdecl sub_80610B0(signed int a1)
{
  if ( a1 > 90 )
  {
    if ( (unsigned int)(a1 - 97) <= 0x19 )
      return 1;
  }
  else if ( a1 >= 65 || (unsigned int)(a1 - 48) <= 9 )
  {
    return 1;
  }
  return 0;
}

//----- (080610EC) --------------------------------------------------------
#error "8061117: call analysis failed (funcsize=20)"

//----- (08061191) --------------------------------------------------------
#error "80611B2: call analysis failed (funcsize=16)"

//----- (08061250) --------------------------------------------------------
_BOOL4 __cdecl sub_8061250(signed int a1)
{
  return a1 >= 9 && (a1 <= 13 || a1 == 32);
}

//----- (080612BC) --------------------------------------------------------
#error "80612DE: call analysis failed (funcsize=17)"

//----- (0806133B) --------------------------------------------------------
int __cdecl sub_806133B(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 97) > 0x19 )
    result = a1;
  else
    result = a1 - 32;
  return result;
}

//----- (0806134D) --------------------------------------------------------
int __usercall sub_806134D@<eax>(int edx0@<edx>, int ecx0@<ecx>, int a1, int a2)
{
  void *v4; // eax

  v4 = &loc_8061378;
  if ( a1 != a2 )
    v4 = &loc_806137F;
  dword_806C220 = (int)v4;
  sub_8062BFE(ecx0, edx0);
  return 0;
}
// 8062BFE: using guessed type int __fastcall sub_8062BFE(_DWORD, _DWORD);
// 806C220: using guessed type int dword_806C220;

//----- (080613CB) --------------------------------------------------------
int __cdecl sub_80613CB(FILE *fp)
{
  bool v1; // ST25_1
  int v2; // edx
  int v3; // ecx

  v1 = __fpending(fp) != 0;
  ferror_unlocked(fp);
  dword_806C2AC = (int)&loc_8061486;
  *(_DWORD *)sub_80628B5(v3, v2) = 0;
  return -1;
}
// 80628B5: using guessed type int __fastcall sub_80628B5(_DWORD, _DWORD);
// 806C2AC: using guessed type int dword_806C2AC;

//----- (080614A9) --------------------------------------------------------
_DWORD *__userpurge sub_80614A9@<eax>(int a1@<edx>, int a2@<ecx>, _DWORD *a3, double a4)
{
  signed int v4; // ST24_4
  double v5; // ST2C_8
  int v6; // ST28_4
  int v8; // [esp+20h] [ebp-18h]
  int v9; // [esp+24h] [ebp-14h]

  if ( a4 <= -2147483648.0 )
  {
    sub_80620ED(a3, 2147483648, 0);
  }
  else if ( 2147483648.0 <= a4 )
  {
    dword_806C284 = (int)&loc_8061551;
    sub_80629B0(a2, a1);
  }
  else
  {
    v4 = (signed int)a4;
    v5 = (a4 - (long double)v4) * 1000000000.0;
    v6 = (v5 > (long double)(signed int)v5) + (signed int)v5;
    v8 = v6 / 1000000000 + v4;
    v9 = v6 % 1000000000;
    if ( v9 < 0 )
    {
      --v8;
      v9 += 1000000000;
    }
    sub_80620ED(a3, v8, v9);
  }
  return a3;
}
// 806C284: using guessed type int dword_806C284;

//----- (08061654) --------------------------------------------------------
int __cdecl sub_8061654(int fd, int a2)
{
  int v2; // ST1C_4
  int v3; // ST18_4

  if ( fd >= 0 && fd <= 2 )
  {
    v3 = sub_80616B1(fd, a2);
    v2 = *__errno_location();
    close(fd);
    *__errno_location() = v2;
    fd = v3;
  }
  return fd;
}

//----- (080616B1) --------------------------------------------------------
int __cdecl sub_80616B1(int fd, int a2)
{
  int v2; // eax

  if ( a2 & 0x80000 )
    v2 = 1030;
  else
    v2 = 0;
  return sub_806038F(fd, v2, 3);
}

//----- (080616E8) --------------------------------------------------------
FILE *__cdecl sub_80616E8(int a1, char *modes)
{
  int v2; // ST28_4
  int v4; // ST2C_4
  FILE *stream; // [esp+1Ch] [ebp-1Ch]
  signed int v6; // [esp+20h] [ebp-18h]
  int fd; // [esp+24h] [ebp-14h]

  stream = (FILE *)fopen64(a1, modes);
  if ( !stream )
    return stream;
  v6 = fileno(stream);
  if ( v6 < 0 || v6 > 2 )
    return stream;
  fd = sub_80621F7(v6);
  if ( fd < 0 )
  {
    v2 = *__errno_location();
    sub_80602BC(stream);
    *__errno_location() = v2;
    return 0;
  }
  if ( !sub_80602BC(stream) )
  {
    stream = fdopen(fd, modes);
    if ( stream )
      return stream;
  }
  v4 = *__errno_location();
  close(fd);
  *__errno_location() = v4;
  return 0;
}
// 80499F0: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (080617BE) --------------------------------------------------------
#error "80617EA: call analysis failed (funcsize=15)"

//----- (080617EF) --------------------------------------------------------
#error "8061D83: positive sp value has been found (funcsize=302)"

//----- (08061D86) --------------------------------------------------------
#error "8061E43: call analysis failed (funcsize=67)"

//----- (08061E76) --------------------------------------------------------
int __cdecl sub_8061E76(char *s, int a2, char *s2, int a4)
{
  size_t v4; // ST18_4
  size_t v5; // ST1C_4
  _BOOL4 v7; // eax
  int v8; // [esp+14h] [ebp-14h]

  while ( 1 )
  {
    *__errno_location() = 0;
    v8 = strcoll(s, s2);
    v7 = v8 || *__errno_location();
    if ( v7 )
      break;
    v4 = strlen(s) + 1;
    v5 = strlen(s2) + 1;
    s += v4;
    s2 += v5;
    a2 -= v4;
    a4 -= v5;
    if ( !a2 )
      return -(a4 != 0);
    if ( !a4 )
      return 1;
  }
  return v8;
}

//----- (08061F4E) --------------------------------------------------------
int __cdecl sub_8061F4E(void *s1, size_t n, void *s2, int a4)
{
  bool v4; // zf
  void *v5; // eax
  char v6; // ST22_1
  char v7; // ST23_1
  int v9; // [esp+0h] [ebp-28h]
  int v10; // [esp+4h] [ebp-24h]
  int v11; // [esp+8h] [ebp-20h]
  int v12; // [esp+Ch] [ebp-1Ch]
  int v13; // [esp+10h] [ebp-18h]
  int v14; // [esp+14h] [ebp-14h]
  int v15; // [esp+18h] [ebp-10h]
  int v16; // [esp+1Ch] [ebp-Ch]
  int v17; // [esp+1Ch] [ebp-Ch]
  int v18; // [esp+20h] [ebp-8h]
  int v19; // [esp+24h] [ebp-4h]
  int savedregs; // [esp+28h] [ebp+0h]

  if ( n == a4 )
  {
    v4 = memcmp(s1, s2, n) == 0;
    v5 = &loc_8061F92;
    if ( !v4 )
      v5 = &loc_8061FA9;
    dword_806C298 = (int)v5;
    sub_8062925(v9, v10, v11, v12, v13, v14, v15, v16, v18, v19, savedregs);
    *__errno_location() = 0;
    v17 = 0;
  }
  else
  {
    v6 = *((_BYTE *)s1 + n);
    v7 = *((_BYTE *)s2 + a4);
    *((_BYTE *)s1 + n) = 0;
    *((_BYTE *)s2 + a4) = 0;
    v17 = sub_8061E76((char *)s1, n + 1, (char *)s2, a4 + 1);
    *((_BYTE *)s1 + n) = v6;
    *((_BYTE *)s2 + a4) = v7;
  }
  return v17;
}
// 8062925: using guessed type int __stdcall sub_8062925(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806C298: using guessed type int dword_806C298;

//----- (08062045) --------------------------------------------------------
int __cdecl sub_8062045(void *s1, size_t n, void *s2, int a4)
{
  if ( n != a4 || memcmp(s1, s2, n) )
    return sub_8061E76((char *)s1, n, (char *)s2, a4);
  *__errno_location() = 0;
  return 0;
}

//----- (080620ED) --------------------------------------------------------
_DWORD *__userpurge sub_80620ED@<eax>(_DWORD *a1, int a2, int a3)
{
  *a1 = a2;
  a1[1] = a3;
  return a1;
}

//----- (080621F7) --------------------------------------------------------
int __cdecl sub_80621F7(int fd)
{
  return sub_806038F(fd, 0, 3);
}

//----- (0806221C) --------------------------------------------------------
#error "8062271: call analysis failed (funcsize=129)"

//----- (0806238C) --------------------------------------------------------
int __cdecl sub_806238C(unsigned __int64 a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // ecx
  int v4; // esi
  unsigned int v5; // eax
  int v8; // ebp
  int v9; // ebp
  unsigned int v10; // ebp
  unsigned __int64 v11; // rtt
  unsigned __int64 v12; // rax
  unsigned int v13; // edi
  unsigned __int64 v14; // rax
  int v15; // ecx
  unsigned int v16; // [esp+0h] [ebp-20h]
  unsigned int v17; // [esp+4h] [ebp-1Ch]
  unsigned __int64 v18; // [esp+8h] [ebp-18h]
  unsigned int v19; // [esp+10h] [ebp-10h]

  v3 = a1;
  v4 = a2;
  v17 = HIDWORD(a1);
  v5 = a3;
  v19 = a1;
  v16 = a2;
  v18 = a1;
  if ( a3 )
  {
    if ( a3 > HIDWORD(a1) )
      return a1;
    _BitScanReverse((unsigned int *)&v8, a3);
    v9 = v8 ^ 0x1F;
    if ( v9 )
    {
      v4 = 32 - v9;
      v17 = (a3 << v9) | (v16 >> (32 - v9));
      LODWORD(v18) = v16 << v9;
      HIDWORD(v12) = HIDWORD(a1) >> (32 - v9);
      LODWORD(v12) = (HIDWORD(a1) << (char)&v16) | (v19 >> (32 - v9));
      HIDWORD(v18) = v19 << (char)&v16;
      v13 = v12 % v17;
      v14 = (v16 << v9) * (unsigned __int64)(unsigned int)(v12 / v17);
      v16 = HIDWORD(v14);
      v15 = v14;
      if ( v13 >= HIDWORD(v14) )
      {
        if ( HIDWORD(v18) >= (unsigned int)v14 )
          return ((__PAIR__(v13, HIDWORD(v18)) - v14) >> 32 << v4) | ((unsigned int)(HIDWORD(v18) - v14) >> (char)&v16);
        LODWORD(v14) = &loc_8062505;
        if ( v13 != HIDWORD(v14) )
          LODWORD(v14) = &loc_80624B7;
        dword_806C220 = v14;
        LODWORD(v14) = sub_8062BFE(v15, HIDWORD(v14));
      }
      dword_806C2AC = (int)&loc_80624B7;
      v5 = sub_80628B5(v14 - v18, (v14 - __PAIR__(v17, (unsigned int)v18)) >> 32);
    }
    else if ( v16 <= (unsigned int)v18 )
    {
      return __PAIR__(v17, v3) - __PAIR__(v5, v4);
    }
    if ( v5 >= HIDWORD(v18) )
      return v18;
    return __PAIR__(v17, v3) - __PAIR__(v5, v4);
  }
  if ( a2 > HIDWORD(a1) )
    return a1 % a2;
  v10 = a2;
  if ( !a2 )
    v10 = 1 / 0u;
  LODWORD(v11) = a1;
  HIDWORD(v11) = v17 % v10;
  return v11 % v10;
}
// 80628B5: using guessed type int __fastcall sub_80628B5(_DWORD, _DWORD);
// 8062BFE: using guessed type int __fastcall sub_8062BFE(_DWORD, _DWORD);
// 806C220: using guessed type int dword_806C220;
// 806C2AC: using guessed type int dword_806C2AC;

//----- (080625AD) --------------------------------------------------------
int __cdecl sub_80625AD(int a1)
{
  return __cxa_atexit(a1, 0, dword_806C304);
}
// 8049AC0: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 806C304: using guessed type int dword_806C304;

//----- (080625E8) --------------------------------------------------------
int __cdecl sub_80625E8(int a1, int a2)
{
  return __xstat64(3, a1, a2);
}
// 8049EB0: using guessed type int __cdecl __xstat64(_DWORD, _DWORD, _DWORD);

//----- (08062617) --------------------------------------------------------
int __cdecl sub_8062617(int a1, int a2)
{
  return __fxstat64(3, a1, a2);
}
// 8049A30: using guessed type int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD);

//----- (080626B4) --------------------------------------------------------
#error "80626BA: positive sp value has been found (funcsize=0)"

//----- (08062753) --------------------------------------------------------
#error "8062759: positive sp value has been found (funcsize=0)"

//----- (080628B5) --------------------------------------------------------
#error "80628BB: positive sp value has been found (funcsize=0)"

//----- (08062925) --------------------------------------------------------
#error "806292B: positive sp value has been found (funcsize=0)"

//----- (080629B0) --------------------------------------------------------
#error "80629B6: positive sp value has been found (funcsize=0)"

//----- (08062A28) --------------------------------------------------------
#error "8062A2E: positive sp value has been found (funcsize=0)"

//----- (08062A98) --------------------------------------------------------
#error "8062A9E: positive sp value has been found (funcsize=0)"

//----- (08062B10) --------------------------------------------------------
#error "8062B16: positive sp value has been found (funcsize=0)"

//----- (08062B84) --------------------------------------------------------
#error "8062B8A: positive sp value has been found (funcsize=0)"

//----- (08062BFE) --------------------------------------------------------
#error "8062C04: positive sp value has been found (funcsize=0)"

//----- (08062C70) --------------------------------------------------------
#error "8062C76: positive sp value has been found (funcsize=0)"

//----- (08062C80) --------------------------------------------------------
int (**sub_8062C80())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_806BEC8;
  v1 = &off_806BECC - off_806BEC8;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_806BEC8[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 806BEC8: using guessed type int (*off_806BEC8[2])();
// 806BECC: using guessed type int (*off_806BECC)();

//----- (08062CE4) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 101 decompilation failure(s) on 353 function(s)"
