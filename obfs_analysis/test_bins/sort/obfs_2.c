/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8049750();
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// int raise(int sig);
// int dup2(int fd, int fd2);
// int strcmp(const char *s1, const char *s2);
// int putc_unlocked(int c, FILE *stream);
// ssize_t read(int fd, void *buf, size_t nbytes);
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void _exit(int status);
// int __cdecl wcwidth(_DWORD); weak
// void *memmove(void *dest, const void *src, size_t n);
// void free(void *ptr);
// uintmax_t strtoumax(const char *nptr, char **endptr, int base);
// void *memcpy(void *dest, const void *src, size_t n);
// int mbsinit(const mbstate_t *ps);
// int ferror(FILE *stream);
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// int fclose(FILE *stream);
// int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// __sighandler_t signal(int sig, __sighandler_t handler);
// int __cdecl __sched_cpucount(_DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// double __cdecl strtold(_DWORD, _DWORD); weak
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// int fputc_unlocked(int c, FILE *stream);
// int __cdecl getrlimit64(_DWORD, _DWORD); weak
// int __cdecl stpcpy(_DWORD, _DWORD); weak
// int execlp(const char *file, const char *arg, ...);
// int sysconf(int name);
// __uid_t getuid(void);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// int unlink(const char *name);
// int sigismember(const sigset_t *set, int signo);
// int iswcntrl(wint_t wc);
// char *textdomain(const char *domainname);
// int iswprint(wint_t wc);
// int __cdecl fopen64(_DWORD, _DWORD); weak
// int ferror_unlocked(FILE *stream);
// int __cdecl mkostemp64(_DWORD, _DWORD); weak
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD); weak
// size_t __ctype_get_mb_cur_max(void);
// __pid_t waitpid(__pid_t pid, int *stat_loc, int options);
// int pthread_sigmask(int how, const __sigset_t *newmask, __sigset_t *oldmask);
// char *strcpy(char *dest, const char *src);
// size_t __fpending(FILE *fp);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// __pid_t getpid(void);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// int pthread_cond_signal(pthread_cond_t *cond);
// void error(int status, int errnum, const char *format, ...);
// size_t fread_unlocked(void *ptr, size_t size, size_t n, FILE *stream);
// int strcoll(const char *s1, const char *s2);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int sysinfo(struct sysinfo *info);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// char *strchr(const char *s, int c);
// size_t strlen(const char *s);
// int __cdecl __libc_start_main(int (__cdecl *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// int fprintf(FILE *stream, const char *format, ...);
// ssize_t write(int fd, const void *buf, size_t n);
// int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *cond_attr);
// int __cdecl open64(_DWORD, _DWORD); weak
// int fcntl(int fd, int cmd, ...);
// int sigaddset(sigset_t *set, int signo);
// size_t strxfrm(char *dest, const char *src, size_t n);
// __gid_t getgid(void);
// void *memset(void *s, int c, size_t n);
// int *__errno_location(void);
// void *memchr(const void *s, int c, size_t n);
// int fileno(FILE *stream);
// int fgetc(FILE *stream);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// int __cdecl ftruncate64(_DWORD, _DWORD, _DWORD); weak
// int sigemptyset(sigset_t *set);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// int toupper(int c);
// char *strrchr(const char *s, int c);
// int pthread_join(pthread_t th, void **thread_return);
// struct lconv *localeconv(void);
// __pid_t getppid(void);
// int __cdecl explicit_bzero(_DWORD, _DWORD); weak
// int __cdecl pipe2(_DWORD, _DWORD); weak
// int __cdecl euidaccess(_DWORD, _DWORD); weak
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int nanosleep(const struct timespec *requested_time, struct timespec *remaining);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// char *bindtextdomain(const char *domainname, const char *dirname);
// int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl sched_getaffinity(_DWORD, _DWORD, _DWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// int feof_unlocked(FILE *stream);
// void abort(void);
// int __cdecl __xstat64(_DWORD, _DWORD, _DWORD); weak
// int strtol(const char *nptr, char **endptr, int base);
// char *ngettext(const char *msgid1, const char *msgid2, unsigned int n);
// int close(int fd);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// void *calloc(size_t nmemb, size_t size);
// int putchar_unlocked(int c);
// int _gmon_start__(void); weak
void sub_8049F73();
void sub_8049F90();
int sub_8049FA0();
int sub_804A010();
int sub_804A030();
void sub_804A08F();
void sub_804A0AA();
int sub_804A0BA();
void sub_804A19C();
void sub_804A1B7();
int sub_804A1C7();
void sub_804A2A9();
void sub_804A2C4();
signed int sub_804A2D4();
void sub_804A3B6();
void sub_804A3D1();
int sub_804A3E1();
void sub_804A4C3();
void sub_804A4DE();
int sub_804A4EE();
void sub_804A5D0();
void sub_804A5EB();
int sub_804A5FB();
void sub_804A6DD();
void sub_804A6F8();
int __fastcall sub_804A708(int a1, int a2);
// int __usercall sub_804A7D3@<eax>(void (__cdecl *a1)(int *)@<eax>);
void sub_804A81F();
void sub_804A83A();
int sub_804A84A();
// int __usercall sub_804A8B1@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
void sub_804A95A();
void sub_804A975();
int sub_804A985();
// int __usercall sub_804AA37@<eax>(void (__cdecl *a1)(int *)@<eax>);
void sub_804AA95();
void sub_804AAB0();
int sub_804AAC0();
// int __usercall sub_804AB27@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
void sub_804ABD0();
void sub_804ABEB();
int sub_804ABFB();
int sub_804AC85();
void sub_804ACF9();
void sub_804AD14();
int sub_804AD24();
int sub_804ADAE();
void sub_804AE34();
void sub_804AE4F();
int sub_804AE5F();
void sub_804AF6F();
void sub_804AF8A();
int sub_804AF9A();
int sub_804AFC6(); // weak
// void __usercall __noreturn sub_804B04C(void (__cdecl *a1)(int *)@<eax>);
void sub_804B0BC();
void sub_804B0D7();
int sub_804B0E7();
int sub_804B171();
// int __usercall sub_804B1B2@<eax>(void (__cdecl *a1)(int *)@<eax>);
void sub_804B1FE();
void sub_804B219();
int sub_804B229();
int sub_804B2B3();
void sub_804B327();
void sub_804B342();
int sub_804B352();
int sub_804B37E();
int nullsub_5(void); // weak
// int __usercall sub_804B3B9@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
// int __usercall sub_804B436@<eax>(void (__cdecl *a1)(int *)@<eax>);
void sub_804B482();
void sub_804B49D();
int sub_804B4AD();
void sub_804B5BD();
void sub_804B5D8();
int sub_804B5E8();
void sub_804B6CA();
void sub_804B6E5();
int sub_804B6F5();
int nullsub_6(void); // weak
int sub_804B753();
void sub_804B7F3();
void sub_804B80E();
int sub_804B81E();
// int __usercall sub_804B885@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
int __cdecl sub_804B8FC(int a1);
int __cdecl sub_804B90F(unsigned __int8 a1);
int __cdecl sub_804B921(unsigned __int8 a1);
int __cdecl sub_804B960(unsigned __int64 a1);
int sub_804B9A6();
int sub_804B9D1();
int __cdecl sub_804B9FC(char *s1); // idb
void __cdecl __noreturn sub_804BB9B(int a1, const char *a2);
// void __usercall __noreturn sub_804BC7A(long double fst7_0@<st0>, int a1, char *a2);
void __cdecl __noreturn sub_804BCF1(int status); // idb
int __cdecl sub_804BFAD(int a1);
int __cdecl sub_804BFE2(unsigned __int8 *a1);
int __cdecl sub_804C012(int a1, unsigned int a2);
bool __cdecl sub_804C030(int a1, int a2);
// int __usercall sub_804C055@<eax>(int a1@<ecx>, long double a2@<st0>, int a3);
// int __usercall sub_804C193@<eax>(double st7_0@<st0>, int a1);
signed int __cdecl sub_804C220(int a1);
// signed int __usercall sub_804C27A@<eax>(long double a1@<st0>, int a2);
// int __usercall sub_804C29C@<eax>(long double a1@<st0>);
// int __usercall sub_804C2D8@<eax>(int a1@<ecx>, long double a2@<st0>);
// int __usercall sub_804C2F1@<eax>(int a1@<ecx>, long double a2@<st0>);
int sub_804C310();
// int __usercall sub_804C348@<eax>(long double a1@<st0>);
int *__cdecl sub_804C39B(int *a1, char a2);
// FILE *__usercall sub_804C5A5@<eax>(long double a1@<st0>, char *s1, char *modes);
// FILE *__usercall sub_804C71B@<eax>(long double a1@<st0>, char *s1, char *modes);
// int __usercall sub_804C75C@<eax>(long double a1@<st0>, FILE *stream, int a3);
// int __usercall sub_804C835@<eax>(double a1@<st0>, int fd, int fd2);
// int __usercall sub_804C87B@<eax>(int a1@<edx>, int a2@<ecx>, int pipedes[2], int a4);
// int __usercall sub_804CA23@<eax>(long double a1@<st0>, FILE **a2, char a3);
// int __usercall sub_804CB88@<eax>(long double a1@<st0>, FILE **a2);
// FILE *__usercall sub_804CBA3@<eax>(long double a1@<st0>, int a2);
int __cdecl sub_804CD95(int a1);
// void __usercall sub_804CE06(long double a1@<st0>, char *name);
int compar(const void *, const void *); // idb
void sub_804CF68();
// int __usercall __noreturn sub_804D159@<eax>(long double fst7_0@<st0>, int a1, char a2, char *a3);
int sub_804D3F1(); // weak
// unsigned __int64 __usercall sub_804D3F8@<edx:eax>(double a1@<st0>, int a2, int a3, char *nptr);
void __cdecl __noreturn sub_804D687(int a1, int a2, int a3);
void __noreturn sub_804D745();
// int __usercall sub_804D92D@<eax>(long double a1@<st0>, FILE **a2, unsigned int a3, int *a4, unsigned int a5, int a6);
int __cdecl sub_804DB2D(int, int, size_t size); // idb
int __cdecl sub_804DBC8(_DWORD *a1);
// char *__usercall sub_804DBE3@<eax>(double a1@<st0>, int ecx0@<ecx>, char **a2, int a3);
unsigned __int8 *__cdecl sub_804DD88(int a1, int a2);
// int __usercall sub_804DF39@<eax>(int a1@<edx>, int a2@<ecx>, long double a3@<st0>, int a4, FILE *stream, int a6);
int __cdecl sub_804E38E(char **a1);
int __cdecl sub_804E481(_BYTE *a1);
// int __usercall sub_804E4E8@<eax>(double st7_0@<st0>, int ecx0@<ecx>, unsigned __int8 *a1, unsigned __int8 *a2);
// int __usercall sub_804E5A3@<eax>(double st7_0@<st0>, unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_804E633(int a1, int a2);
signed int __cdecl sub_804E6B7(int a1, int a2);
int __cdecl sub_804E809(unsigned __int8 *a1, unsigned __int8 **a2);
// unsigned int __usercall sub_804E93B@<eax>(long double a1@<st0>, char *a2);
// size_t __usercall sub_804EA07@<eax>(long double a1@<st0>, char *dest, char *src, size_t n);
// void __usercall __noreturn sub_804EADF(long double a1@<st0>, int a2, size_t a3, int a4, size_t a5);
int sub_804F123(); // weak
int __cdecl sub_804F12E(char *a1, unsigned int a2);
int __cdecl sub_804F17E(int a1, int a2);
int __cdecl sub_804F211(_BYTE *a1);
// int __usercall sub_804F246@<eax>(int a1@<ecx>, double a2@<st0>, int a3, int a4);
// int __usercall sub_804F4EA@<eax>(int a1@<ecx>, double a2@<st0>, int a3);
// int __usercall sub_804F56F@<eax>(int edx0@<edx>, int a2@<ecx>, int a1);
_BYTE *__cdecl sub_804F62C(int a1, _BYTE *a2);
// unsigned int __usercall sub_804F774@<eax>(long double a1@<st0>, int ecx0@<ecx>, int *a2, char a3);
int __cdecl sub_804FFE6(int a1, int a2);
// _BOOL4 __usercall sub_8050D52@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4);
// int __usercall sub_8050F1E@<eax>(int a1@<ecx>, long double a2@<st0>, int a3, FILE *stream, int a5);
// int __usercall sub_8051096@<eax>(long double a1@<st0>, char *a2, char a3);
// unsigned int __usercall sub_8051448@<eax>(long double a1@<st0>, int a2, unsigned int a3, void **a4);
// void __usercall sub_805155A(long double a1@<st0>, int a2, int a3, int a4, FILE *stream, int a6, void *a7);
// int __usercall sub_8051F39@<eax>(long double a1@<st0>, int a2, int a3, int a4, FILE *stream, int a6);
// _DWORD *__usercall sub_8051FCA@<eax>(int a1@<ecx>, double a2@<st0>, _DWORD *a3, unsigned int a4, _DWORD *a5);
// int __usercall sub_80520EF@<eax>(int a1@<ecx>, double a2@<st0>, _DWORD *a3, unsigned int a4, _DWORD *a5, unsigned __int8 a6);
pthread_mutex_t *__cdecl sub_8052311(unsigned int a1, int a2, int a3);
// int __usercall sub_8052440@<eax>(int a1@<edx>, int a2@<ecx>, unsigned int a3, pthread_mutex_t *a4, int a5, unsigned int a6, int a7, char a8);
_BOOL4 __cdecl sub_805261A(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8052679(pthread_mutex_t *a1);
int __cdecl sub_805268F(pthread_mutex_t *a1);
int __cdecl sub_80526D6(int a1, int a2);
int __cdecl sub_8052724(int a1, int a2);
pthread_mutex_t *__cdecl sub_8052771(int a1);
// int __usercall sub_8052808@<eax>(long double a1@<st0>, int a2, FILE *stream, int a4);
// int __usercall sub_80528A9@<eax>(long double a1@<st0>, int a2, int a3, FILE *stream, int a5);
int __cdecl sub_8052D20(int a1, int a2);
int __cdecl sub_8052E14(int a1, _DWORD *a2);
int __cdecl sub_8052E81(int a1);
// void *__usercall start_routine@<eax>(double a1@<st0>, void *a2);
// int __usercall sub_8052FAC@<eax>(int a1@<ecx>, double a2@<st0>, int a3, int a4, int a5, int a6, int a7, FILE *stream, int a9);
// int __usercall sub_80531B0@<eax>(long double a1@<st0>, int ecx0@<ecx>, int a2, int a3, int a4, char *s1);
// unsigned int __usercall sub_8053449@<eax>(long double a1@<st0>, int a2, unsigned int a3);
// int __usercall sub_80534E4@<eax>(long double a1@<st0>, int edx0@<edx>, int a3@<ecx>, char *a2);
// void __usercall sub_8053563(int a1@<edx>, int a2@<ecx>, long double a3@<st0>, int a4, int a5, int a6, char *s1);
// unsigned int __usercall sub_8053987@<eax>(long double a1@<st0>, char **a2, unsigned int a3, char *a4, unsigned int a5);
_DWORD *__cdecl sub_8053DF1(void *src);
// void __usercall __noreturn sub_8053E3E(long double a1@<st0>, int a2, char *msgid);
void __cdecl __noreturn sub_8053E8C(int a1);
int __fastcall __noreturn sub_8053EBD(int a1, int a2);
int sub_8053FD9(); // weak
// int __usercall sub_8053FDB@<eax>(long double a1@<st0>, char *nptr, int a3, char *msgid);
int __cdecl sub_80540E0(int sig); // idb
// _BYTE *__usercall sub_805410B@<eax>(int a1@<edx>, int a2@<ecx>, _BYTE *a3);
void *__cdecl sub_805426E(void *s);
// void __usercall main(long double a1@<st0>, int argc, char **argv);
void __noreturn sub_8055B3B();
int __cdecl sub_8055B4F(char *s, int, int, size_t); // idb
// void __usercall sub_8055C78(long double a1@<st0>, char *a2, char *a3, int a4);
// int __usercall sub_8055CFB@<eax>(long double a1@<st0>, int a2, int a3, size_t n);
// int __usercall sub_8055E40@<eax>(long double a1@<st0>, int a2, char *s, int a4, int a5, size_t n, int a7);
// int __usercall sub_8055F55@<eax>(long double a1@<st0>);
_DWORD *__cdecl sub_8056063(_DWORD *a1);
_DWORD *__cdecl sub_80560AF(_DWORD *a1, int a2);
_DWORD *__cdecl sub_80560BC(int *a1, _DWORD *a2);
// _DWORD *__usercall sub_8056129@<eax>(double a1@<st0>, int *a2, _DWORD *a3);
// int __usercall sub_8056417@<eax>(int a1@<edx>, int a2@<ecx>, void *src, size_t a4, int a5);
int *__cdecl sub_805661D(int *a1, unsigned int a2, int *a3);
int __cdecl sub_80572F9(int a1, int a2, int a3, int a4, int a5, int a6);
void __cdecl sub_805734A(FILE *stream, int a2);
// _BYTE *__usercall sub_8057392@<eax>(int a1@<edx>, int a2@<ecx>, double st7_0@<st0>, _BYTE **a3);
signed int __cdecl sub_8057494(unsigned __int8 a1);
// int __usercall sub_8057513@<eax>(int edx0@<edx>, int ecx0@<ecx>, double st7_0@<st0>, int a1, unsigned int a2, int a3, unsigned int a4);
// int __usercall sub_80577AE@<eax>(double a1@<st0>, char *s1, char *s2);
int __cdecl sub_8057A49(int category); // idb
int __cdecl sub_8057AC0(int a1);
int __cdecl sub_8057ACB(int a1);
int __cdecl sub_8057AD6(int a1);
// unsigned int __usercall sub_8057AE1@<eax>(int a1@<edx>, int a2@<ecx>, int a3);
int __cdecl sub_8057CC4(int a1, int a2);
bool __cdecl sub_805802A(unsigned int a1);
int __cdecl sub_8058081(unsigned int a1);
unsigned int __cdecl sub_80580F2(int a1, unsigned int a2);
bool __cdecl sub_805811D(int a1, int a2);
signed int __cdecl sub_805812B(int a1);
unsigned int __cdecl sub_80581E7(unsigned int a1, int a2);
int __cdecl sub_8058289(int a1, void *a2);
void *__cdecl sub_80585FF(int a1);
int __cdecl sub_805864F(int a1, _DWORD *a2);
int __cdecl sub_8058672(int a1, int a2, _DWORD *a3, char a4);
// signed int __usercall sub_8058829@<eax>(int a1@<edx>, int a2@<ecx>, double a3@<st0>, int a4, int a5, char a6);
int __cdecl sub_80589F3(int a1, unsigned int a2);
int __cdecl sub_8058BDA(int a1, int a2, _DWORD *a3);
// int __usercall sub_8058E57@<eax>(double st7_0@<st0>, int a1, int a2);
int __cdecl sub_8058EC0(int a1, int a2);
_DWORD *__cdecl sub_80590D3(int a1, int a2);
int sub_805917A();
void __cdecl sub_8059184(void *ptr);
int __cdecl sub_80591A4(int a1, int a2);
// int __usercall sub_805922D@<eax>(int a1@<edx>, int a2@<ecx>, int *a3);
unsigned int __cdecl sub_80592BE(int a1, unsigned int a2, unsigned int a3, int (__cdecl *a4)(_DWORD, int));
int __cdecl sub_80593BA(int a1, unsigned int a2, int (__cdecl *a3)(int, int));
int __cdecl sub_805945F(int a1, int a2);
int __cdecl sub_805956B(unsigned int a1, int a2);
int __cdecl sub_80595C9(signed __int64 a1, int a2);
int __cdecl sub_805967C(char *a1, int a2, char a3);
int sub_805996A();
signed int __cdecl sub_80599F7(int a1);
int __cdecl sub_8059A86(char *nptr); // idb
unsigned int __cdecl sub_8059B89(int a1);
void __noreturn sub_8059C0A();
int sub_8059CE3(); // weak
long double sub_8059CE5();
// int __usercall sub_8059DDD@<eax>(int a1@<edx>, int a2@<ecx>, int pipedes[2], int a4);
int sub_805A091();
char *__cdecl sub_805A0EF(char *s);
int __cdecl sub_805A2C5(int *a1, unsigned __int8 a2, char a3);
// int *__usercall sub_805A36F@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5);
// _DWORD *__userpurge sub_805A3C9@<eax>(_DWORD *a1, int a2);
// char *__usercall sub_805A44B@<eax>(double a1@<st0>, char *msgid, int a2);
// int __usercall sub_805A55A@<eax>(long double fst7_0@<st0>, int a1, unsigned int a2, char *a3, size_t a4, signed int a5, int a6, int a7, char *a8, char *a9);
int sub_805B403(); // weak
// void *__usercall sub_805B4D9@<eax>(int a1@<ecx>, long double a2@<st0>, char *a3, size_t a4, _DWORD *a5, int a6);
// void *__usercall sub_805B699@<eax>(long double fst7_0@<st0>, signed int a1, char *a2, size_t a3, int a4);
// void *__usercall sub_805B8D7@<eax>(long double a1@<st0>, signed int a2, char *a3);
// void *__usercall sub_805B901@<eax>(long double a1@<st0>, signed int a2, char *a3, size_t a4);
// void *__usercall sub_805B967@<eax>(long double a1@<st0>, signed int a2, int a3, char *a4);
// void *__usercall sub_805B9A5@<eax>(long double a1@<st0>, signed int a2, int a3, char *a4, size_t a5);
// void *__usercall sub_805B9E2@<eax>(long double a1@<st0>, int a2, char *a3);
// void *__usercall sub_805BA2D@<eax>(long double fst7_0@<st0>, char *a1, size_t a2, unsigned __int8 a3);
// void *__usercall sub_805BAD7@<eax>(long double fst7_0@<st0>, char *a1, unsigned __int8 a2);
// void *__usercall sub_805BB00@<eax>(long double fst7_0@<st0>, char *a1);
// void *__usercall sub_805BB3D@<eax>(long double fst7_0@<st0>, signed int a1, int a2, char *a3);
// void *__usercall sub_805BBDE@<eax>(int a1@<edx>, int a2@<ecx>, long double a3@<st0>, signed int a4, int a5, int a6, char *a7);
// void *__usercall sub_805BC0E@<eax>(int a1@<edx>, int a2@<ecx>, long double a3@<st0>, signed int a4, int a5, int a6, char *a7, size_t a8);
// void *__usercall sub_805BD08@<eax>(long double fst7_0@<st0>, signed int a1, char *a2, size_t a3);
// void *__usercall sub_805BD53@<eax>(long double fst7_0@<st0>, signed int a1, char *a2);
// void *__usercall sub_805BD75@<eax>(long double fst7_0@<st0>, char *a1);
// void __usercall __noreturn sub_805BD90(long double a1@<st0>, char *a2);
_DWORD *__cdecl sub_805BE0E(int a1, int a2);
unsigned int __cdecl sub_805BE43(int a1, int a2, size_t nbytes);
// _DWORD *__usercall sub_805C050@<eax>(double st7_0@<st0>, int a1, size_t n);
size_t __cdecl sub_805C165(int a1, void *ptr, size_t n);
int __cdecl sub_805C209(int, void *dest, size_t n); // idb
size_t __cdecl sub_805C35C(int a1, void *ptr, size_t n);
// int __usercall sub_805C3A4@<eax>(double a1@<st0>, void *ptr);
int __cdecl sub_805C3EA(int a1);
int __cdecl sub_805C401(int a1, __int16 a2);
unsigned int *__cdecl sub_805C432(unsigned int *a1, int *a2);
// _DWORD *__usercall sub_805C8D7@<eax>(double a1@<st0>, _DWORD *a2);
signed int __cdecl sub_805CCFB(_DWORD *a1);
_DWORD *__cdecl sub_805CE9F(_DWORD *a1);
bool __cdecl sub_805D034(FILE *stream, int a2);
int __cdecl sub_805D322(int a1, int a2);
int __cdecl sub_805D34B(_BYTE *a1, _BYTE *a2, char a3);
// int __usercall sub_805D4A9@<eax>(int edx0@<edx>, int ecx0@<ecx>, double st7_0@<st0>, unsigned __int8 *a1, unsigned __int8 *a2, int a3, int a4);
// int __usercall sub_805DA4C@<eax>(int edx0@<edx>, int ecx0@<ecx>, double st7_0@<st0>, unsigned __int8 *a1, unsigned __int8 *a2, int a3, int a4);
int __cdecl sub_805DA74(int fd); // idb
int __cdecl sub_805DABE(FILE *stream, int, int, int, int, int); // idb
int __cdecl sub_805E06B(FILE *stream, int, int, int, int); // idb
int sub_805E0D1(FILE *stream, int a2, int a3, int a4, ...);
void *__cdecl sub_805E171(unsigned int a1, unsigned int a2);
// void *__usercall sub_805E1D4@<eax>(int a1@<edx>, int ecx0@<ecx>, void *ptr, int a2, int a3);
void *__cdecl sub_805E29D(size_t size);
void *__cdecl sub_805E2B0(size_t size);
void *__cdecl sub_805E2F3(void *ptr, size_t size);
void *__cdecl sub_805E3C0(size_t nmemb, size_t size);
void *__cdecl sub_805E3FD(void *src, size_t n);
void __noreturn sub_805E44B();
// void __usercall sub_805E484(long double a1@<st0>, int errnum, int a3, int a4, int a5, int a6);
// int __usercall sub_805E5CE@<eax>(long double a1@<st0>, int a2@<edx>, int a3@<ecx>, void *s1, size_t n, void *s2, int a5);
signed int __cdecl sub_805E639(double a1);
signed int __cdecl sub_805E6C4(unsigned int *a1, unsigned int a2);
int __cdecl sub_805E708(unsigned int *a1, unsigned int a2, int a3);
void __cdecl __noreturn sub_805E73E(int a1, int a2, signed int a3);
int __cdecl sub_805E7CA(char **endptr, int base); // idb
// void __usercall sub_805EC32(int edx0@<edx>, int ecx0@<ecx>, int a1, int a2, int a3, int a4, int a5, int status);
void __fastcall __noreturn sub_805ED2B(int ecx0, int edx0, int a1, int a2, char a3, int a4, int a5);
int __cdecl sub_805ED6E(_DWORD *a1, signed int a2);
int __cdecl sub_805EE0F(_DWORD *a1, signed int a2, int a3);
int __cdecl sub_805EE45(char *nptr, int, int base, int, char *s); // idb
// int __usercall sub_805F2A2@<eax>(double a1@<st0>, FILE *stream);
int __cdecl sub_805F37E(int fd, int cmd, char); // idb
// int __usercall sub_805F505@<eax>(double a1@<st0>, int a2@<edx>, int a3@<ecx>, FILE *stream);
// int __usercall sub_805F557@<eax>(double a1@<st0>, FILE *fp);
// int __usercall sub_805F597@<eax>(double a1@<st0>, FILE *stream, int a3, int a4, int a5);
size_t __cdecl sub_805F69F(wchar_t *pwc, char *s, size_t n, mbstate_t *p);
int __cdecl sub_805F72A(int a1, int a2);
int __cdecl sub_805F768(int a1, int a2);
// signed int __usercall sub_805F7BF@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5);
signed int __cdecl sub_805F8D0(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_805F959(int a1, int a2);
int __cdecl sub_805FB23(int a1, unsigned int a2);
int __cdecl sub_805FD67(int a1, char a2);
int __cdecl sub_805FE52(signed int a1);
// signed int __usercall sub_805FEAC@<eax>(int edx0@<edx>, int a2@<ecx>, signed int a1);
int __cdecl sub_805FF77(int a1);
int __cdecl sub_806004B(signed int a1);
int __cdecl sub_80600C4(int a1);
int __cdecl sub_80600FA(unsigned __int8 *a1, unsigned __int8 *a2);
// int __usercall sub_806015F@<eax>(double a1@<st0>, FILE *fp);
// _DWORD *__userpurge sub_80601F9@<eax>(_DWORD *a1, double a2);
// int __usercall sub_8060342@<eax>(int a1@<edx>, int a2@<ecx>, int fd, int a4);
int __cdecl sub_80603AC(int fd, int); // idb
// FILE *__usercall sub_80603E3@<eax>(double a1@<st0>, int a2, char *modes);
void *sub_80604E7();
// const char *__usercall sub_8060A3C@<eax>(double a1@<st0>);
int __cdecl sub_8060B1D(char *s, int, char *s2, int); // idb
int __cdecl sub_8060BDF(void *s1, size_t n, void *s2, int); // idb
// int __usercall sub_8060C9A@<eax>(int a1@<edx>, int a2@<ecx>, void *s1, size_t n, void *s2, int a6);
// _DWORD *__userpurge sub_8060D12@<eax>(_DWORD *a1, int a2, int a3);
int __cdecl sub_8060E02(int fd); // idb
signed __int64 __cdecl sub_8060E27(unsigned __int64 a1, unsigned int a2, unsigned int a3);
int __cdecl sub_8060F7D(unsigned __int64 a1, __int64 a2);
int __cdecl sub_806116B(int a1);
int __cdecl sub_806119A(int a1, int a2);
int __cdecl sub_80611C9(int a1, int a2);
int __fastcall sub_8061252(_DWORD, _DWORD); // weak
int sub_80612DD(void); // weak
int __fastcall sub_806137F(_DWORD, _DWORD); // weak
int __fastcall sub_80613F7(_DWORD); // weak
// int __usercall sub_8061467@<eax>(double@<st0>); weak
int __fastcall sub_80614D5(_DWORD, _DWORD); // weak
int __fastcall sub_8061566(_DWORD, _DWORD); // weak
int sub_80615DC(void); // weak
int __fastcall sub_8061650(_DWORD, _DWORD); // weak
int __fastcall sub_80616F8(_DWORD, _DWORD); // weak
int __fastcall sub_8061764(_DWORD); // weak
int __fastcall sub_80617DA(_DWORD, _DWORD); // weak
int __fastcall sub_806184C(_DWORD); // weak
int sub_80618C2(void); // weak
int __fastcall sub_8061936(_DWORD, _DWORD); // weak
// int __usercall sub_80619C7@<eax>(double@<st0>); weak
int sub_8061A50(void); // weak
double __fastcall sub_8061AC8(_DWORD, _DWORD); // weak
int sub_8061B42(void); // weak
int __fastcall sub_8061BBC(_DWORD, _DWORD); // weak
int (**sub_8061BD0())();
void term_proc();
void init(void); // idb
void fini(void); // idb

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN locret_804A717; // weak
_UNKNOWN loc_804A9B1; // weak
_UNKNOWN loc_804BB05; // weak
_UNKNOWN loc_804BB3F; // weak
_UNKNOWN loc_804BBF6; // weak
_UNKNOWN loc_804BC4F; // weak
_UNKNOWN loc_804BCAD; // weak
_UNKNOWN loc_804C08C; // weak
_UNKNOWN loc_804C124; // weak
_UNKNOWN loc_804C189; // weak
_UNKNOWN loc_804C1F5; // weak
_UNKNOWN loc_804C1FA; // weak
_UNKNOWN loc_804C2C6; // weak
_UNKNOWN locret_804C2D6; // weak
_UNKNOWN loc_804C373; // weak
_UNKNOWN loc_804C394; // weak
_UNKNOWN loc_804C521; // weak
_UNKNOWN loc_804C52D; // weak
_UNKNOWN loc_804C630; // weak
_UNKNOWN loc_804C699; // weak
_UNKNOWN loc_804C6E3; // weak
_UNKNOWN loc_804C78A; // weak
_UNKNOWN loc_804C7A8; // weak
_UNKNOWN loc_804C7AA; // weak
_UNKNOWN loc_804C7DD; // weak
_UNKNOWN loc_804C85C; // weak
_UNKNOWN locret_804C879; // weak
_UNKNOWN loc_804C8E3; // weak
_UNKNOWN loc_804C983; // weak
_UNKNOWN loc_804C9A9; // weak
_UNKNOWN loc_804CB61; // weak
_UNKNOWN loc_804CB7F; // weak
_UNKNOWN loc_804CC56; // weak
_UNKNOWN loc_804CC9A; // weak
_UNKNOWN loc_804CD8E; // weak
_UNKNOWN loc_804CDC3; // weak
_UNKNOWN loc_804CDE5; // weak
_UNKNOWN loc_804D1D5; // weak
_UNKNOWN loc_804D1E0; // weak
_UNKNOWN loc_804D321; // weak
_UNKNOWN loc_804D326; // weak
_UNKNOWN loc_804D496; // weak
_UNKNOWN loc_804D5C2; // weak
_UNKNOWN loc_804D67F; // weak
_UNKNOWN loc_804D783; // weak
_UNKNOWN loc_804D7A6; // weak
_UNKNOWN loc_804DA0D; // weak
_UNKNOWN loc_804DA36; // weak
_UNKNOWN loc_804DB33; // weak
_UNKNOWN loc_804DC21; // weak
_UNKNOWN loc_804DC7F; // weak
_UNKNOWN loc_804DCC8; // weak
_UNKNOWN loc_804DD1F; // weak
_UNKNOWN loc_804DD38; // weak
_UNKNOWN loc_804DE37; // weak
_UNKNOWN loc_804DE3B; // weak
_UNKNOWN loc_804DEF4; // weak
_UNKNOWN loc_804DF21; // weak
_UNKNOWN loc_804DFB7; // weak
_UNKNOWN loc_804DFFF; // weak
_UNKNOWN loc_804E0E3; // weak
_UNKNOWN loc_804E135; // weak
_UNKNOWN loc_804E17A; // weak
_UNKNOWN loc_804E17F; // weak
_UNKNOWN loc_804E2B2; // weak
_UNKNOWN loc_804E387; // weak
_UNKNOWN loc_804E443; // weak
_UNKNOWN loc_804E470; // weak
_UNKNOWN locret_804E47F; // weak
_UNKNOWN loc_804E50A; // weak
_UNKNOWN loc_804E5AB; // weak
_UNKNOWN loc_804E5E7; // weak
_UNKNOWN locret_804E807; // weak
_UNKNOWN loc_804EB87; // weak
_UNKNOWN loc_804EC43; // weak
_UNKNOWN loc_804EC59; // weak
_UNKNOWN loc_804ECF3; // weak
_UNKNOWN loc_804ED15; // weak
_UNKNOWN loc_804ED25; // weak
_UNKNOWN loc_804ED5F; // weak
_UNKNOWN loc_804EFCC; // weak
_UNKNOWN loc_804F11E; // weak
_UNKNOWN loc_804F1BE; // weak
_UNKNOWN loc_804F1D4; // weak
_UNKNOWN loc_804F2B8; // weak
_UNKNOWN loc_804F2CD; // weak
_UNKNOWN loc_804F2F1; // weak
_UNKNOWN loc_804F2FB; // weak
_UNKNOWN loc_804F31F; // weak
_UNKNOWN loc_804F332; // weak
_UNKNOWN loc_804F3FC; // weak
_UNKNOWN loc_804F40B; // weak
_UNKNOWN loc_804F49D; // weak
_UNKNOWN loc_804F529; // weak
_UNKNOWN loc_804F55F; // weak
_UNKNOWN locret_804F56D; // weak
_UNKNOWN loc_804F5B8; // weak
_UNKNOWN loc_804F60D; // weak
_UNKNOWN loc_804F622; // weak
_UNKNOWN loc_804F65E; // weak
_UNKNOWN loc_804F66A; // weak
_UNKNOWN loc_804F6BD; // weak
_UNKNOWN loc_804F6C9; // weak
_UNKNOWN loc_804FAC1; // weak
_UNKNOWN loc_804FB17; // weak
_UNKNOWN loc_804FB53; // weak
_UNKNOWN loc_804FB7A; // weak
_UNKNOWN loc_804FBB6; // weak
_UNKNOWN loc_804FBE4; // weak
_UNKNOWN loc_804FCB0; // weak
_UNKNOWN loc_804FCB7; // weak
_UNKNOWN loc_804FCD7; // weak
_UNKNOWN loc_804FCEE; // weak
_UNKNOWN loc_804FE70; // weak
_UNKNOWN loc_804FE9F; // weak
_UNKNOWN loc_804FEEB; // weak
_UNKNOWN loc_804FEEF; // weak
_UNKNOWN loc_804FF61; // weak
_UNKNOWN loc_804FFA7; // weak
_UNKNOWN loc_804FFCB; // weak
_UNKNOWN loc_80500F4; // weak
_UNKNOWN loc_8050134; // weak
_UNKNOWN loc_8050156; // weak
_UNKNOWN loc_8050163; // weak
_UNKNOWN loc_80501D3; // weak
_UNKNOWN loc_80503A3; // weak
_UNKNOWN loc_80503AC; // weak
_UNKNOWN loc_80504AC; // weak
_UNKNOWN loc_80504E1; // weak
_UNKNOWN loc_8050627; // weak
_UNKNOWN loc_8050633; // weak
_UNKNOWN loc_805066B; // weak
_UNKNOWN loc_80506DD; // weak
_UNKNOWN loc_805071C; // weak
_UNKNOWN loc_8050770; // weak
_UNKNOWN loc_8050958; // weak
_UNKNOWN loc_805095D; // weak
_UNKNOWN loc_80509FA; // weak
_UNKNOWN loc_8050A09; // weak
_UNKNOWN loc_8050B5E; // weak
_UNKNOWN loc_8050B80; // weak
_UNKNOWN loc_8050B85; // weak
_UNKNOWN loc_8050D96; // weak
_UNKNOWN loc_8050DAC; // weak
_UNKNOWN loc_8050DFD; // weak
_UNKNOWN loc_8050E11; // weak
_UNKNOWN loc_8050F0E; // weak
_UNKNOWN loc_8050F15; // weak
_UNKNOWN loc_8050F18; // weak
_UNKNOWN loc_8050F92; // weak
_UNKNOWN loc_8050F98; // weak
_UNKNOWN loc_8050FEE; // weak
_UNKNOWN loc_8051009; // weak
_UNKNOWN loc_8051070; // weak
_UNKNOWN loc_805108B; // weak
_UNKNOWN loc_80512CA; // weak
_UNKNOWN loc_80512CF; // weak
_UNKNOWN loc_8051346; // weak
_UNKNOWN loc_80513D6; // weak
_UNKNOWN loc_80514BC; // weak
_UNKNOWN loc_8051507; // weak
_UNKNOWN loc_8051528; // weak
_UNKNOWN loc_8051867; // weak
_UNKNOWN loc_80518C2; // weak
_UNKNOWN loc_8051911; // weak
_UNKNOWN loc_8051987; // weak
_UNKNOWN loc_8051992; // weak
_UNKNOWN loc_8051A17; // weak
_UNKNOWN loc_8051D43; // weak
_UNKNOWN loc_8051DE6; // weak
_UNKNOWN loc_8051E04; // weak
_UNKNOWN loc_8051E1A; // weak
_UNKNOWN loc_8051E76; // weak
_UNKNOWN loc_8051EC0; // weak
_UNKNOWN loc_8051EEA; // weak
_UNKNOWN loc_805205A; // weak
_UNKNOWN loc_80520B8; // weak
_UNKNOWN loc_80520E8; // weak
_UNKNOWN locret_80520ED; // weak
_UNKNOWN loc_8052207; // weak
_UNKNOWN loc_805246B; // weak
_UNKNOWN loc_8052473; // weak
_UNKNOWN loc_80524D4; // weak
_UNKNOWN loc_80524DC; // weak
_UNKNOWN loc_805279C; // weak
_UNKNOWN loc_80527B4; // weak
_UNKNOWN loc_80527E3; // weak
_UNKNOWN loc_8052832; // weak
_UNKNOWN loc_805288E; // weak
_UNKNOWN locret_80528A7; // weak
_UNKNOWN loc_8052992; // weak
_UNKNOWN loc_80529CA; // weak
_UNKNOWN loc_80529DB; // weak
_UNKNOWN loc_8052A85; // weak
_UNKNOWN loc_8052AE2; // weak
_UNKNOWN loc_8052AEF; // weak
_UNKNOWN loc_8052B04; // weak
_UNKNOWN loc_8052BD8; // weak
_UNKNOWN loc_8052CCA; // weak
_UNKNOWN loc_8052CD7; // weak
_UNKNOWN loc_8052D98; // weak
_UNKNOWN loc_8052DA2; // weak
_UNKNOWN loc_8052DC3; // weak
_UNKNOWN loc_8052DF9; // weak
_UNKNOWN loc_8052EB8; // weak
_UNKNOWN loc_8052ED7; // weak
_UNKNOWN loc_80532E0; // weak
_UNKNOWN loc_8053322; // weak
_UNKNOWN loc_805335F; // weak
_UNKNOWN loc_8053371; // weak
_UNKNOWN loc_8053393; // weak
_UNKNOWN loc_8053429; // weak
_UNKNOWN loc_8053430; // weak
_UNKNOWN loc_8053509; // weak
_UNKNOWN locret_8053561; // weak
_UNKNOWN loc_805376F; // weak
_UNKNOWN loc_805386E; // weak
_UNKNOWN loc_80538D7; // weak
_UNKNOWN loc_8053AA9; // weak
_UNKNOWN loc_8053CC0; // weak
_UNKNOWN loc_8053D2F; // weak
_UNKNOWN loc_8053D9E; // weak
_UNKNOWN loc_8053EED; // weak
_UNKNOWN loc_8053F90; // weak
_UNKNOWN loc_8053FAF; // weak
_UNKNOWN loc_8053FD4; // weak
_UNKNOWN loc_80540D6; // weak
_UNKNOWN loc_80540D9; // weak
_UNKNOWN loc_8054113; // weak
_UNKNOWN loc_8054269; // weak
_UNKNOWN loc_805432C; // weak
_UNKNOWN loc_8054333; // weak
_UNKNOWN loc_80544BF; // weak
_UNKNOWN loc_80544DA; // weak
_UNKNOWN loc_8054557; // weak
_UNKNOWN loc_805457D; // weak
_UNKNOWN loc_8054605; // weak
_UNKNOWN loc_8054625; // weak
_UNKNOWN loc_805468C; // weak
_UNKNOWN loc_80546C2; // weak
_UNKNOWN loc_80546F8; // weak
_UNKNOWN loc_805471E; // weak
_UNKNOWN loc_8054756; // weak
_UNKNOWN loc_80547F6; // weak
_UNKNOWN loc_805488C; // weak
_UNKNOWN loc_8054974; // weak
_UNKNOWN loc_8054981; // weak
_UNKNOWN loc_8054AB9; // weak
_UNKNOWN loc_8054AD9; // weak
_UNKNOWN loc_8054AFD; // weak
_UNKNOWN loc_8054BBE; // weak
_UNKNOWN loc_8054C01; // weak
_UNKNOWN loc_8054C35; // weak
_UNKNOWN loc_8054C41; // weak
_UNKNOWN loc_8054D31; // weak
_UNKNOWN unk_8054D46; // weak
_UNKNOWN loc_8055022; // weak
_UNKNOWN loc_8055046; // weak
_UNKNOWN loc_8055087; // weak
_UNKNOWN loc_805508E; // weak
_UNKNOWN loc_80550EA; // weak
_UNKNOWN loc_805511C; // weak
_UNKNOWN loc_80551C2; // weak
_UNKNOWN loc_80551E7; // weak
_UNKNOWN loc_805521C; // weak
_UNKNOWN loc_80552A2; // weak
_UNKNOWN loc_805565A; // weak
_UNKNOWN loc_805569F; // weak
_UNKNOWN loc_8055BFC; // weak
_UNKNOWN loc_8055C30; // weak
_UNKNOWN locret_8055C76; // weak
_UNKNOWN loc_8055D7A; // weak
_UNKNOWN loc_8055DD5; // weak
_UNKNOWN loc_8055E08; // weak
_UNKNOWN loc_8055FA4; // weak
_UNKNOWN loc_8056032; // weak
_UNKNOWN loc_805603F; // weak
_UNKNOWN loc_805615F; // weak
_UNKNOWN loc_8056592; // weak
_UNKNOWN loc_80572C8; // weak
_UNKNOWN loc_8057407; // weak
_UNKNOWN loc_8057472; // weak
_UNKNOWN loc_805747F; // weak
_UNKNOWN loc_8057501; // weak
_UNKNOWN loc_8057508; // weak
_UNKNOWN locret_8057511; // weak
_UNKNOWN loc_8057572; // weak
_UNKNOWN loc_8057596; // weak
_UNKNOWN loc_80575AE; // weak
_UNKNOWN loc_805763E; // weak
_UNKNOWN loc_8057642; // weak
_UNKNOWN loc_805766A; // weak
_UNKNOWN loc_8057681; // weak
_UNKNOWN loc_8057685; // weak
_UNKNOWN loc_80576AD; // weak
_UNKNOWN loc_80576F5; // weak
_UNKNOWN loc_805777D; // weak
_UNKNOWN loc_8057784; // weak
_UNKNOWN loc_80578E8; // weak
_UNKNOWN loc_80578F2; // weak
_UNKNOWN loc_8057977; // weak
_UNKNOWN loc_80579A6; // weak
_UNKNOWN locret_8057A47; // weak
_UNKNOWN loc_8057A9F; // weak
_UNKNOWN loc_8057AB6; // weak
_UNKNOWN loc_8057B29; // weak
_UNKNOWN locret_8058287; // weak
_UNKNOWN loc_8058309; // weak
_UNKNOWN loc_805830E; // weak
_UNKNOWN loc_805864A; // weak
_UNKNOWN loc_80586D1; // weak
_UNKNOWN loc_80586F0; // weak
_UNKNOWN loc_8058721; // weak
_UNKNOWN loc_805874E; // weak
_UNKNOWN loc_8058814; // weak
_UNKNOWN locret_8058827; // weak
_UNKNOWN loc_8058876; // weak
_UNKNOWN loc_80588CC; // weak
_UNKNOWN loc_80588E3; // weak
_UNKNOWN loc_8058984; // weak
_UNKNOWN loc_805898B; // weak
_UNKNOWN loc_80589D9; // weak
_UNKNOWN loc_80589DD; // weak
_UNKNOWN loc_8058A30; // weak
_UNKNOWN loc_8058A3A; // weak
_UNKNOWN loc_8058C2E; // weak
_UNKNOWN loc_8058C46; // weak
_UNKNOWN locret_8058EBE; // weak
_UNKNOWN loc_8058FD5; // weak
_UNKNOWN loc_805900F; // weak
_UNKNOWN loc_805908B; // weak
_UNKNOWN loc_80590A5; // weak
_UNKNOWN loc_80590C4; // weak
_UNKNOWN loc_8059107; // weak
_UNKNOWN loc_805910E; // weak
_UNKNOWN loc_8059165; // weak
_UNKNOWN loc_805916A; // weak
_UNKNOWN loc_80592B7; // weak
_UNKNOWN loc_8059369; // weak
_UNKNOWN loc_805936B; // weak
_UNKNOWN loc_805941D; // weak
_UNKNOWN loc_805947E; // weak
_UNKNOWN loc_80594F1; // weak
_UNKNOWN loc_8059566; // weak
_UNKNOWN loc_80596FE; // weak
_UNKNOWN loc_8059706; // weak
_UNKNOWN loc_805983F; // weak
_UNKNOWN loc_8059862; // weak
_UNKNOWN loc_805987E; // weak
_UNKNOWN loc_8059897; // weak
_UNKNOWN loc_8059952; // weak
_UNKNOWN loc_80599AE; // weak
_UNKNOWN loc_80599F0; // weak
_UNKNOWN locret_80599F5; // weak
_UNKNOWN loc_8059A1C; // weak
_UNKNOWN loc_8059A4B; // weak
_UNKNOWN loc_8059B0C; // weak
_UNKNOWN loc_8059B38; // weak
_UNKNOWN loc_8059B66; // weak
_UNKNOWN loc_8059CB7; // weak
_UNKNOWN loc_8059CDC; // weak
_UNKNOWN loc_8059D6D; // weak
_UNKNOWN loc_8059DBB; // weak
_UNKNOWN loc_8059DC8; // weak
_UNKNOWN loc_8059E3D; // weak
_UNKNOWN loc_8059E4F; // weak
_UNKNOWN loc_8059E7E; // weak
_UNKNOWN loc_8059E93; // weak
_UNKNOWN loc_805A15A; // weak
_UNKNOWN loc_805A177; // weak
_UNKNOWN loc_805A17A; // weak
_UNKNOWN loc_805A394; // weak
_UNKNOWN loc_805A39B; // weak
_UNKNOWN loc_805A4A7; // weak
_UNKNOWN loc_805A4D4; // weak
_UNKNOWN loc_805A504; // weak
_UNKNOWN loc_805A52F; // weak
_UNKNOWN loc_805A546; // weak
_UNKNOWN locret_805A558; // weak
_UNKNOWN loc_805A66E; // weak
_UNKNOWN loc_805A69A; // weak
_UNKNOWN loc_805A761; // weak
_UNKNOWN loc_805A7A2; // weak
_UNKNOWN loc_805A818; // weak
_UNKNOWN loc_805A81D; // weak
_UNKNOWN loc_805A821; // weak
_UNKNOWN loc_805A972; // weak
_UNKNOWN loc_805A987; // weak
_UNKNOWN loc_805AAEF; // weak
_UNKNOWN loc_805AB0E; // weak
_UNKNOWN loc_805AB13; // weak
_UNKNOWN loc_805AB18; // weak
_UNKNOWN loc_805ABEE; // weak
_UNKNOWN loc_805ABF3; // weak
_UNKNOWN loc_805AC3A; // weak
_UNKNOWN loc_805AC47; // weak
_UNKNOWN loc_805AD2E; // weak
_UNKNOWN loc_805AD3C; // weak
_UNKNOWN loc_805ADE4; // weak
_UNKNOWN loc_805AE03; // weak
_UNKNOWN loc_805AE4E; // weak
_UNKNOWN loc_805AE56; // weak
_UNKNOWN loc_805AE99; // weak
_UNKNOWN loc_805AED4; // weak
_UNKNOWN loc_805AF31; // weak
_UNKNOWN loc_805AF7A; // weak
_UNKNOWN loc_805B019; // weak
_UNKNOWN loc_805B048; // weak
_UNKNOWN loc_805B085; // weak
_UNKNOWN loc_805B0B6; // weak
_UNKNOWN loc_805B0EB; // weak
_UNKNOWN loc_805B11D; // weak
_UNKNOWN loc_805B141; // weak
_UNKNOWN loc_805B146; // weak
_UNKNOWN loc_805B17F; // weak
_UNKNOWN loc_805B1C8; // weak
_UNKNOWN loc_805B35B; // weak
_UNKNOWN loc_805B3FE; // weak
_UNKNOWN loc_805B4FF; // weak
_UNKNOWN loc_805B504; // weak
_UNKNOWN loc_805B6E0; // weak
_UNKNOWN loc_805B78F; // weak
_UNKNOWN loc_805BDE9; // weak
_UNKNOWN loc_805C075; // weak
_UNKNOWN loc_805C08E; // weak
_UNKNOWN loc_805C1E1; // weak
_UNKNOWN loc_805C1E6; // weak
_UNKNOWN loc_805C217; // weak
_UNKNOWN loc_805C2BD; // weak
_UNKNOWN loc_805C307; // weak
_UNKNOWN loc_805C312; // weak
_UNKNOWN loc_805C321; // weak
_UNKNOWN loc_805CAF0; // weak
_UNKNOWN loc_805D03A; // weak
_UNKNOWN loc_805D140; // weak
_UNKNOWN loc_805D162; // weak
_UNKNOWN loc_805D441; // weak
_UNKNOWN loc_805D468; // weak
_UNKNOWN loc_805D4CB; // weak
_UNKNOWN loc_805D500; // weak
_UNKNOWN loc_805D52C; // weak
_UNKNOWN loc_805D53F; // weak
_UNKNOWN loc_805D56C; // weak
_UNKNOWN loc_805D579; // weak
_UNKNOWN loc_805D5A1; // weak
_UNKNOWN loc_805D5AA; // weak
_UNKNOWN loc_805D5D6; // weak
_UNKNOWN loc_805D5ED; // weak
_UNKNOWN loc_805D622; // weak
_UNKNOWN loc_805D63A; // weak
_UNKNOWN loc_805D669; // weak
_UNKNOWN loc_805D6B5; // weak
_UNKNOWN loc_805D6E2; // weak
_UNKNOWN loc_805D729; // weak
_UNKNOWN loc_805D758; // weak
_UNKNOWN loc_805D85D; // weak
_UNKNOWN loc_805D870; // weak
_UNKNOWN loc_805D8A9; // weak
_UNKNOWN loc_805D8BA; // weak
_UNKNOWN loc_805D8EF; // weak
_UNKNOWN loc_805D907; // weak
_UNKNOWN loc_805D936; // weak
_UNKNOWN loc_805D982; // weak
_UNKNOWN loc_805D9AF; // weak
_UNKNOWN locret_805DA4A; // weak
_UNKNOWN loc_805E00B; // weak
_UNKNOWN loc_805E201; // weak
_UNKNOWN loc_805E220; // weak
_UNKNOWN loc_805E23D; // weak
_UNKNOWN loc_805E254; // weak
_UNKNOWN loc_805E2E3; // weak
_UNKNOWN loc_805E2EE; // weak
_UNKNOWN loc_805E318; // weak
_UNKNOWN loc_805E330; // weak
_UNKNOWN loc_805E36A; // weak
_UNKNOWN loc_805E36F; // weak
_UNKNOWN loc_805E6B9; // weak
_UNKNOWN loc_805E6C0; // weak
_UNKNOWN loc_805E770; // weak
_UNKNOWN loc_805E78F; // weak
_UNKNOWN loc_805E7A6; // weak
_UNKNOWN loc_805E7E4; // weak
_UNKNOWN loc_805EC8C; // weak
_UNKNOWN loc_805EC91; // weak
_UNKNOWN loc_805ECBF; // weak
_UNKNOWN loc_805EE07; // weak
_UNKNOWN loc_805EE9F; // weak
_UNKNOWN loc_805F01F; // weak
_UNKNOWN loc_805F038; // weak
_UNKNOWN locret_805F2A0; // weak
_UNKNOWN loc_805F368; // weak
_UNKNOWN loc_805F379; // weak
_UNKNOWN loc_805F4AC; // weak
_UNKNOWN loc_805F4D4; // weak
_UNKNOWN loc_805F532; // weak
_UNKNOWN locret_805F555; // weak
_UNKNOWN loc_805F5D2; // weak
_UNKNOWN loc_805F651; // weak
_UNKNOWN loc_805F658; // weak
_UNKNOWN loc_805F67D; // weak
_UNKNOWN loc_805F70C; // weak
_UNKNOWN loc_805F725; // weak
_UNKNOWN loc_805F795; // weak
_UNKNOWN loc_805F7AF; // weak
_UNKNOWN loc_805F7E4; // weak
_UNKNOWN loc_805F7EB; // weak
_UNKNOWN loc_805F80A; // weak
_UNKNOWN loc_805F81C; // weak
_UNKNOWN locret_805FBCB; // weak
_UNKNOWN loc_805FE89; // weak
_UNKNOWN loc_805FEAA; // weak
_UNKNOWN loc_805FED5; // weak
_UNKNOWN loc_805FEDD; // weak
_UNKNOWN loc_805FFA6; // weak
_UNKNOWN loc_8060081; // weak
_UNKNOWN loc_80601C3; // weak
_UNKNOWN loc_80601F2; // weak
_UNKNOWN loc_806036D; // weak
_UNKNOWN loc_80603A7; // weak
_UNKNOWN loc_80604A1; // weak
_UNKNOWN loc_80604BC; // weak
_UNKNOWN locret_80604E5; // weak
_UNKNOWN loc_8060569; // weak
_UNKNOWN loc_806057D; // weak
_UNKNOWN loc_80605DF; // weak
_UNKNOWN loc_80605E6; // weak
_UNKNOWN loc_80606C2; // weak
_UNKNOWN loc_80606D1; // weak
_UNKNOWN loc_8060AE4; // weak
_UNKNOWN loc_8060B11; // weak
_UNKNOWN loc_8060B18; // weak
_UNKNOWN loc_8060B95; // weak
_UNKNOWN loc_8060CC1; // weak
_UNKNOWN loc_8060CF0; // weak
_UNKNOWN loc_8060E71; // weak
_UNKNOWN loc_8060E7C; // weak
_UNKNOWN loc_8060EB8; // weak
_UNKNOWN loc_8060EED; // weak
_UNKNOWN loc_8060FEE; // weak
_UNKNOWN loc_8061131; // weak
_UNKNOWN loc_8061152; // weak
char locale = '\0'; // idb
char aBIgnoreLeading[128] = "  -b, --ignore-leading-blanks  ignore leading blanks\n  -d, --dictionary-order      consider only blanks and alphanumeric charact"; // idb
char aGGeneralNume[20] = "  -g, --general-nume"; // idb
struct option longopts = { "ignore-leading-blanks", 0, NULL, 98 }; // idb
char *off_80631DC[3] = { "quiet", "silent", "diagnose-first" }; // weak
char aCccgeneralNume[19] = "CCcgeneral-numeric"; // weak
void *off_8063224 = (void *)0x80631EF; // weak
char byte_8063240[6] = { 'g', 'h', 'M', 'n', 'R', 'V' }; // idb
char byte_80634B0[256] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x06',
  '\0',
  '\x03',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0',
  '\x04',
  '\0',
  '\0',
  '\0',
  '\0',
  '\b',
  '\a',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
int sig[11] = { 14, 1, 2, 13, 3, 15, 29, 27, 26, 24, 25 }; // idb
_UNKNOWN unk_8064130; // weak
_UNKNOWN unk_8064180; // weak
_UNKNOWN unk_8064395; // weak
char aHomeHwangdzCor_0[55] = "/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib"; // weak
_UNKNOWN unk_806507F; // weak
int dword_8065EF8 = 17333249; // weak
_UNKNOWN unk_806637C; // weak
_UNKNOWN unk_806637F; // weak
int dword_8066EEC = 4263432; // weak
int dword_8066EF0 = 687865856; // weak
_UNKNOWN unk_80673CC; // weak
_UNKNOWN unk_80673CF; // weak
_UNKNOWN unk_8068408; // weak
_UNKNOWN unk_806840B; // weak
int dword_8068ED0 = 469762048; // weak
int dword_8068ED8 = 91342092; // weak
_UNKNOWN unk_8069458; // weak
_UNKNOWN unk_806945B; // weak
int (*off_806AEAC[2])() = { &sub_804A030, &sub_804A010 }; // weak
int (*off_806AEB0)() = &sub_804A010; // weak
Elf32_Dyn stru_806AF00 = { 5, { 134515372u } }; // weak
int (*dword_806B008)(void) = NULL; // weak
int dword_806B20C = 0; // weak
int dword_806B220 = 0; // weak
int dword_806B234 = 0; // weak
int dword_806B248 = 0; // weak
int dword_806B25C = 0; // weak
int dword_806B270 = 0; // weak
int dword_806B284 = 0; // weak
int dword_806B298 = 0; // weak
int dword_806B2AC = 0; // weak
int dword_806B2C0 = 0; // weak
int dword_806B2D4 = 0; // weak
int dword_806B2E8 = 0; // weak
int dword_806B2FC = 0; // weak
int dword_806B310 = 0; // weak
int dword_806B324 = 0; // weak
int dword_806B338 = 0; // weak
int dword_806B34C = 0; // weak
int dword_806B360 = 0; // weak
int dword_806B374 = 0; // weak
int dword_806B388 = 0; // weak
int dword_806B3A0 = 0; // weak
char byte_806B3BC = '\n'; // weak
char *off_806B3DC = "APR"; // weak
int dword_806B3E0[] = { 4 }; // weak
size_t dword_806B43C = 262144u; // idb
int dword_806B440 = 128; // weak
int dword_806B444 = 16; // idb
int *off_806B448 = &dword_806C2F1; // weak
int off_806B45C = 134627496; // idb
int off_806B460 = 134568763; // idb
int status = 1; // idb
int dword_806B47C = 1; // weak
int dword_806B480 = 256; // weak
void *off_806B484 = &unk_806C411; // weak
int *off_806B488 = &dword_806B480; // weak
_UNKNOWN unk_806B49C; // weak
_UNKNOWN unk_806B4BC; // weak
_UNKNOWN unk_806B4BF; // weak
_UNKNOWN unk_806B4C4; // weak
_UNKNOWN unk_806B4C7; // weak
_UNKNOWN unk_806B4D0; // weak
_UNKNOWN unk_806B4D3; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int program_invocation_name; // weak
int optind; // weak
FILE *stdin; // idb
FILE *stdout; // idb
int (*obstack_alloc_failed_handler)(void); // weak
char *optarg; // idb
char byte_806B54C; // weak
_UNKNOWN unk_806B697; // weak
char byte_806B9FB; // weak
_UNKNOWN unk_806B9FF; // weak
char byte_806BA68; // weak
char byte_806BBAF; // weak
char byte_806BC1C; // weak
_UNKNOWN unk_806BD67; // weak
int dword_806BE31; // weak
int dword_806BE35; // weak
char byte_806BE39; // weak
char byte_806BE3A; // weak
int dword_806BE3D; // weak
int dword_806BE41; // weak
int dword_806BE45; // weak
int dword_806BE49; // weak
char byte_806BE51[256]; // idb
_UNKNOWN unk_806BF51; // weak
_UNKNOWN unk_806C051; // weak
char byte_806C151[256]; // idb
size_t size; // idb
void *ptr; // idb
int dword_806C259; // weak
int dword_806C25D; // weak
char byte_806C261; // weak
char byte_806C262; // weak
char byte_806C263; // weak
char byte_806C264; // weak
int dword_806C265; // weak
char *s1; // idb
char byte_806C26D; // weak
__sigset_t set; // idb
int dword_806C2F1; // weak
int dword_806C2F5; // weak
int dword_806C2F9; // weak
_UNKNOWN unk_806C311; // weak
int dword_806C3AD; // weak
int dword_806C3B5; // weak
char byte_806C3B9; // weak
int dword_806C3BD; // weak
int dword_806C3C1; // weak
int dword_806C3D1; // weak
int dword_806C3D5; // weak
int dword_806C3D9; // weak
int dword_806C3DD; // weak
int dword_806C3E1; // weak
int dword_806C3E5; // weak
int dword_806C3E9; // weak
int dword_806C3ED; // weak
int dword_806C3F1; // weak
int dword_806C3F5; // weak
int dword_806C3F9; // weak
int dword_806C3FD; // weak
_UNKNOWN unk_806C411; // weak
int dword_806C511; // weak
int dword_806C515; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (0804972C) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 8049F30: using guessed type int _gmon_start__(void);

//----- (08049750) --------------------------------------------------------
int sub_8049750()
{
  return dword_806B008();
}
// 806B008: using guessed type int (*dword_806B008)(void);

//----- (08049F40) --------------------------------------------------------
#error "8049F43: positive sp value has been found (funcsize=2)"

//----- (08049F73) --------------------------------------------------------
void sub_8049F73()
{
  ;
}

//----- (08049F90) --------------------------------------------------------
void sub_8049F90()
{
  ;
}

//----- (08049FA0) --------------------------------------------------------
int sub_8049FA0()
{
  int result; // eax

  result = &unk_806B4D3 - &unk_806B4D0;
  if ( (unsigned int)(&unk_806B4D3 - &unk_806B4D0) > 6 )
    result = 0;
  return result;
}
// 8049FA0: could not find valid save-restore pair for ebp

//----- (0804A010) --------------------------------------------------------
int sub_804A010()
{
  int result; // eax

  if ( !byte_806B54C )
  {
    result = sub_8049FA0();
    byte_806B54C = 1;
  }
  return result;
}
// 804A010: could not find valid save-restore pair for ebp
// 806B54C: using guessed type char byte_806B54C;

//----- (0804A030) --------------------------------------------------------
int sub_804A030()
{
  return 0;
}
// 804A030: could not find valid save-restore pair for ebp

//----- (0804A08F) --------------------------------------------------------
void sub_804A08F()
{
  ;
}

//----- (0804A0AA) --------------------------------------------------------
void sub_804A0AA()
{
  ;
}

//----- (0804A0BA) --------------------------------------------------------
int sub_804A0BA()
{
  int result; // eax

  result = &unk_806B4BF - &unk_806B4BC;
  if ( (unsigned int)(&unk_806B4BF - &unk_806B4BC) > 6 )
    result = 0;
  return result;
}
// 804A0BA: could not find valid save-restore pair for ebp

//----- (0804A19C) --------------------------------------------------------
void sub_804A19C()
{
  ;
}

//----- (0804A1B7) --------------------------------------------------------
void sub_804A1B7()
{
  ;
}

//----- (0804A1C7) --------------------------------------------------------
int sub_804A1C7()
{
  int result; // eax

  result = &unk_806B4BF - &unk_806B4BC;
  if ( (unsigned int)(&unk_806B4BF - &unk_806B4BC) > 6 )
    result = 0;
  return result;
}
// 804A1C7: could not find valid save-restore pair for ebp

//----- (0804A2A9) --------------------------------------------------------
void sub_804A2A9()
{
  ;
}

//----- (0804A2C4) --------------------------------------------------------
void sub_804A2C4()
{
  ;
}

//----- (0804A2D4) --------------------------------------------------------
signed int sub_804A2D4()
{
  return 3;
}
// 804A2D4: could not find valid save-restore pair for ebp

//----- (0804A3B6) --------------------------------------------------------
void sub_804A3B6()
{
  ;
}

//----- (0804A3D1) --------------------------------------------------------
void sub_804A3D1()
{
  ;
}

//----- (0804A3E1) --------------------------------------------------------
int sub_804A3E1()
{
  int result; // eax

  result = &unk_806B697 - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_806B697 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 804A3E1: could not find valid save-restore pair for ebp
// 806B4E0: using guessed type int program_invocation_short_name;

//----- (0804A4C3) --------------------------------------------------------
void sub_804A4C3()
{
  ;
}

//----- (0804A4DE) --------------------------------------------------------
void sub_804A4DE()
{
  ;
}

//----- (0804A4EE) --------------------------------------------------------
int sub_804A4EE()
{
  int result; // eax

  result = &unk_806B4BF - &unk_806B4BC;
  if ( (unsigned int)(&unk_806B4BF - &unk_806B4BC) > 6 )
    result = 0;
  return result;
}
// 804A4EE: could not find valid save-restore pair for ebp

//----- (0804A5D0) --------------------------------------------------------
void sub_804A5D0()
{
  ;
}

//----- (0804A5EB) --------------------------------------------------------
void sub_804A5EB()
{
  ;
}

//----- (0804A5FB) --------------------------------------------------------
int sub_804A5FB()
{
  int result; // eax

  result = &unk_806945B - &unk_8069458;
  if ( (unsigned int)(&unk_806945B - &unk_8069458) > 6 )
    result = 0;
  return result;
}
// 804A5FB: could not find valid save-restore pair for ebp

//----- (0804A6DD) --------------------------------------------------------
void sub_804A6DD()
{
  ;
}

//----- (0804A6F8) --------------------------------------------------------
void sub_804A6F8()
{
  ;
}

//----- (0804A708) --------------------------------------------------------
int __fastcall sub_804A708(int a1, int a2)
{
  int result; // eax
  int (__stdcall *v3)(void *, int, int, int, int, int); // eax
  int v4; // [esp+4h] [ebp-18h]
  int v5; // [esp+8h] [ebp-14h]
  int v6; // [esp+Ch] [ebp-10h]
  int v7; // [esp+10h] [ebp-Ch]
  int v8; // [esp+14h] [ebp-8h]
  int v9; // [esp+18h] [ebp-4h]

  result = &unk_806B4BF - &unk_806B4BC;
  if ( (unsigned int)(&unk_806B4BF - &unk_806B4BC) > 6 )
  {
    v9 = 0;
    dword_806B234 = (int)&locret_804A717;
    sub_8061AC8(a1, a2);
    result = v3(&unk_806B4BC, v4, v5, v6, v7, v8);
  }
  return result;
}
// 8061AC8: using guessed type double __fastcall sub_8061AC8(_DWORD, _DWORD);
// 806B234: using guessed type int dword_806B234;

//----- (0804A7D3) --------------------------------------------------------
int __usercall sub_804A7D3@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  a1(&dword_8068ED0);
  return 0;
}
// 8068ED0: using guessed type int dword_8068ED0;

//----- (0804A81F) --------------------------------------------------------
void sub_804A81F()
{
  ;
}

//----- (0804A83A) --------------------------------------------------------
void sub_804A83A()
{
  ;
}

//----- (0804A84A) --------------------------------------------------------
int sub_804A84A()
{
  int result; // eax

  result = &unk_806B4BF - &unk_806B4BC;
  if ( (unsigned int)(&unk_806B4BF - &unk_806B4BC) > 6 )
    result = 0;
  return result;
}
// 804A84A: could not find valid save-restore pair for ebp

//----- (0804A8B1) --------------------------------------------------------
int __usercall sub_804A8B1@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_806B4BC, a1);
}

//----- (0804A95A) --------------------------------------------------------
void sub_804A95A()
{
  ;
}

//----- (0804A975) --------------------------------------------------------
void sub_804A975()
{
  ;
}

//----- (0804A985) --------------------------------------------------------
int sub_804A985()
{
  int result; // eax

  result = &unk_806B4BF - &unk_806B4BC;
  if ( (unsigned int)(&unk_806B4BF - &unk_806B4BC) > 6 )
    result = 0;
  return result;
}
// 804A985: could not find valid save-restore pair for ebp

//----- (0804AA37) --------------------------------------------------------
int __usercall sub_804AA37@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  a1(&dword_8068ED8);
  dword_806B284 = (int)&loc_804A9B1;
  sub_80618C2();
  return 0;
}
// 80618C2: using guessed type int sub_80618C2(void);
// 8068ED8: using guessed type int dword_8068ED8;
// 806B284: using guessed type int dword_806B284;

//----- (0804AA95) --------------------------------------------------------
void sub_804AA95()
{
  ;
}

//----- (0804AAB0) --------------------------------------------------------
void sub_804AAB0()
{
  ;
}

//----- (0804AAC0) --------------------------------------------------------
int sub_804AAC0()
{
  int result; // eax

  result = &unk_806840B - &unk_8068408;
  if ( (unsigned int)(&unk_806840B - &unk_8068408) > 6 )
    result = 0;
  return result;
}
// 804AAC0: could not find valid save-restore pair for ebp

//----- (0804AB27) --------------------------------------------------------
int __usercall sub_804AB27@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_8068408, a1);
}

//----- (0804ABD0) --------------------------------------------------------
void sub_804ABD0()
{
  ;
}

//----- (0804ABEB) --------------------------------------------------------
void sub_804ABEB()
{
  ;
}

//----- (0804ABFB) --------------------------------------------------------
int sub_804ABFB()
{
  int result; // eax

  result = &unk_806B4BF - &unk_806B4BC;
  if ( (unsigned int)(&unk_806B4BF - &unk_806B4BC) > 6 )
    result = 0;
  return result;
}
// 804ABFB: could not find valid save-restore pair for ebp

//----- (0804AC85) --------------------------------------------------------
int sub_804AC85()
{
  int result; // eax

  result = sub_804ABFB();
  byte_806B9FB = 1;
  return result;
}
// 806B9FB: using guessed type char byte_806B9FB;

//----- (0804ACF9) --------------------------------------------------------
void sub_804ACF9()
{
  ;
}

//----- (0804AD14) --------------------------------------------------------
void sub_804AD14()
{
  ;
}

//----- (0804AD24) --------------------------------------------------------
int sub_804AD24()
{
  int result; // eax

  result = &unk_806B9FF - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_806B9FF - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 804AD24: could not find valid save-restore pair for ebp
// 806B4E0: using guessed type int program_invocation_short_name;

//----- (0804ADAE) --------------------------------------------------------
int sub_804ADAE()
{
  int result; // eax

  result = sub_804AD24();
  byte_806BA68 = 1;
  return result;
}
// 806BA68: using guessed type char byte_806BA68;

//----- (0804AE34) --------------------------------------------------------
void sub_804AE34()
{
  ;
}

//----- (0804AE4F) --------------------------------------------------------
void sub_804AE4F()
{
  ;
}

//----- (0804AE5F) --------------------------------------------------------
int sub_804AE5F()
{
  int result; // eax

  result = &unk_80673CF - &unk_80673CC;
  if ( (unsigned int)(&unk_80673CF - &unk_80673CC) > 6 )
    result = 0;
  return result;
}
// 804AE5F: could not find valid save-restore pair for ebp

//----- (0804AF6F) --------------------------------------------------------
void sub_804AF6F()
{
  ;
}

//----- (0804AF8A) --------------------------------------------------------
void sub_804AF8A()
{
  ;
}

//----- (0804AF9A) --------------------------------------------------------
int sub_804AF9A()
{
  int result; // eax

  result = &unk_806B4BF - &unk_806B4BC;
  if ( (unsigned int)(&unk_806B4BF - &unk_806B4BC) > 6 )
    result = 0;
  return result;
}
// 804AF9A: could not find valid save-restore pair for ebp

//----- (0804B04C) --------------------------------------------------------
void __usercall __noreturn sub_804B04C(void (__cdecl *a1)(int *)@<eax>)
{
  int v1; // ecx
  int v2; // ecx
  int v3; // eax
  int v4; // esi
  void (*v5)(void); // edx
  int savedregs; // [esp+18h] [ebp+0h]
  void *retaddr; // [esp+1Ch] [ebp+4h]

  a1(&dword_8066EEC);
  dword_806B2C0 = (int)sub_804AFC6;
  sub_8061764(v1);
  dword_806B298 = (int)sub_804AFC6;
  v3 = sub_806184C(v2);
  v4 = savedregs;
  savedregs = v3;
  __libc_start_main(
    (int (__cdecl *)(int, char **, char **))main,
    v4,
    (char **)&retaddr,
    (void (*)(void))"ers\n  -f, --ignore-case           fold lower case to upper case characters\n",
    (void (*)(void))"ric-sort  compare according to general numerical value\n"
                    "  -i, --ignore-nonprinting    consider only printable characters\n"
                    "  -M, --month-sort            compare (unknown) < 'JAN' < ... < 'DEC'\n",
    v5,
    &savedregs);
  __halt();
  JUMPOUT(*(_DWORD *)sub_804B0BC);
}
// 804AFC6: using guessed type int sub_804AFC6();
// 8061764: using guessed type int __fastcall sub_8061764(_DWORD);
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD);
// 8066EEC: using guessed type int dword_8066EEC;
// 806B298: using guessed type int dword_806B298;
// 806B2C0: using guessed type int dword_806B2C0;

//----- (0804B0BC) --------------------------------------------------------
void sub_804B0BC()
{
  ;
}

//----- (0804B0D7) --------------------------------------------------------
void sub_804B0D7()
{
  ;
}

//----- (0804B0E7) --------------------------------------------------------
int sub_804B0E7()
{
  int result; // eax

  result = &unk_806B4BF - &unk_806B4BC;
  if ( (unsigned int)(&unk_806B4BF - &unk_806B4BC) > 6 )
    result = 0;
  return result;
}
// 804B0E7: could not find valid save-restore pair for ebp

//----- (0804B171) --------------------------------------------------------
int sub_804B171()
{
  int result; // eax

  result = sub_804B0E7();
  byte_806BBAF = 1;
  return result;
}
// 806BBAF: using guessed type char byte_806BBAF;

//----- (0804B1B2) --------------------------------------------------------
int __usercall sub_804B1B2@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  a1(&dword_8066EF0);
  return 0;
}
// 8066EF0: using guessed type int dword_8066EF0;

//----- (0804B1FE) --------------------------------------------------------
void sub_804B1FE()
{
  ;
}

//----- (0804B219) --------------------------------------------------------
void sub_804B219()
{
  ;
}

//----- (0804B229) --------------------------------------------------------
int sub_804B229()
{
  int result; // eax

  result = &unk_806B4BF - &unk_806B4BC;
  if ( (unsigned int)(&unk_806B4BF - &unk_806B4BC) > 6 )
    result = 0;
  return result;
}
// 804B229: could not find valid save-restore pair for ebp

//----- (0804B2B3) --------------------------------------------------------
int sub_804B2B3()
{
  int result; // eax

  result = sub_804B229();
  byte_806BC1C = 1;
  return result;
}
// 806BC1C: using guessed type char byte_806BC1C;

//----- (0804B327) --------------------------------------------------------
void sub_804B327()
{
  ;
}

//----- (0804B342) --------------------------------------------------------
void sub_804B342()
{
  ;
}

//----- (0804B352) --------------------------------------------------------
int sub_804B352()
{
  int result; // eax

  result = &unk_806637F - &unk_806637C;
  if ( (unsigned int)(&unk_806637F - &unk_806637C) > 6 )
    result = 0;
  return result;
}
// 804B352: could not find valid save-restore pair for ebp

//----- (0804B37E) --------------------------------------------------------
int sub_804B37E()
{
  return nullsub_5();
}
// 804B37E: could not find valid save-restore pair for ebx
// 804B396: using guessed type int nullsub_5(void);
// 80616F8: using guessed type int __fastcall sub_80616F8(_DWORD, _DWORD);
// 806B2D4: using guessed type int dword_806B2D4;

//----- (0804B3B9) --------------------------------------------------------
int __usercall sub_804B3B9@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_806637C, a1);
}

//----- (0804B436) --------------------------------------------------------
int __usercall sub_804B436@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  a1(&dword_8065EF8);
  return sub_804B37E();
}
// 8065EF8: using guessed type int dword_8065EF8;

//----- (0804B482) --------------------------------------------------------
void sub_804B482()
{
  ;
}

//----- (0804B49D) --------------------------------------------------------
void sub_804B49D()
{
  ;
}

//----- (0804B4AD) --------------------------------------------------------
int sub_804B4AD()
{
  int result; // eax

  result = &unk_806B4BF - &unk_806B4BC;
  if ( (unsigned int)(&unk_806B4BF - &unk_806B4BC) > 6 )
    result = 0;
  return result;
}
// 804B4AD: could not find valid save-restore pair for ebp

//----- (0804B5BD) --------------------------------------------------------
void sub_804B5BD()
{
  ;
}

//----- (0804B5D8) --------------------------------------------------------
void sub_804B5D8()
{
  ;
}

//----- (0804B5E8) --------------------------------------------------------
int sub_804B5E8()
{
  int result; // eax

  result = &unk_806B4BF - &unk_806B4BC;
  if ( (unsigned int)(&unk_806B4BF - &unk_806B4BC) > 6 )
    result = 0;
  return result;
}
// 804B5E8: could not find valid save-restore pair for ebp

//----- (0804B6CA) --------------------------------------------------------
void sub_804B6CA()
{
  ;
}

//----- (0804B6E5) --------------------------------------------------------
void sub_804B6E5()
{
  ;
}

//----- (0804B6F5) --------------------------------------------------------
int sub_804B6F5()
{
  int result; // eax

  result = &unk_806BD67 - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_806BD67 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 804B6F5: could not find valid save-restore pair for ebp
// 806B4E0: using guessed type int program_invocation_short_name;

//----- (0804B753) --------------------------------------------------------
int sub_804B753()
{
  return nullsub_6();
}
// 804B753: could not find valid save-restore pair for ebp
// 804B752: using guessed type int nullsub_6(void);

//----- (0804B7F3) --------------------------------------------------------
void sub_804B7F3()
{
  ;
}

//----- (0804B80E) --------------------------------------------------------
void sub_804B80E()
{
  ;
}

//----- (0804B81E) --------------------------------------------------------
int sub_804B81E()
{
  int result; // eax

  result = &unk_806B4C7 - &unk_806B4C4;
  if ( (unsigned int)(&unk_806B4C7 - &unk_806B4C4) > 6 )
    result = 0;
  return result;
}
// 804B81E: could not find valid save-restore pair for ebp

//----- (0804B885) --------------------------------------------------------
int __usercall sub_804B885@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_806B4C4, a1);
}

//----- (0804B8FC) --------------------------------------------------------
int __cdecl sub_804B8FC(int a1)
{
  int result; // eax

  if ( a1 != 1 )
  {
    result = a1;
    status = a1;
  }
  return result;
}

//----- (0804B90F) --------------------------------------------------------
int __cdecl sub_804B90F(unsigned __int8 a1)
{
  return a1;
}

//----- (0804B921) --------------------------------------------------------
int __cdecl sub_804B921(unsigned __int8 a1)
{
  return (*__ctype_b_loc())[a1] & 1 || a1 == 10;
}

//----- (0804B960) --------------------------------------------------------
int __cdecl sub_804B960(unsigned __int64 a1)
{
  int result; // eax

  if ( HIDWORD(a1) )
    result = sub_8060F7D(a1, 1000000LL) + 1000000;
  else
    result = a1;
  return result;
}

//----- (0804B9A6) --------------------------------------------------------
int sub_804B9A6()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nWith no FILE, or when FILE is -, read standard input.\n");
  return fputs_unlocked(v1, v0);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804B9D1) --------------------------------------------------------
int sub_804B9D1()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nMandatory arguments to long options are mandatory for short options too.\n");
  return fputs_unlocked(v1, v0);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804B9FC) --------------------------------------------------------
int __cdecl sub_804B9FC(char *s1)
{
  char *v1; // eax
  char *v2; // eax
  bool v3; // zf
  void *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // ebx
  char *v8; // eax
  char *v10; // [esp+1Ch] [ebp-4Ch]
  const char **i; // [esp+20h] [ebp-48h]
  char *v12; // [esp+24h] [ebp-44h]
  const char *v13; // [esp+28h] [ebp-40h]
  const char *v14; // [esp+2Ch] [ebp-3Ch]
  const char *v15; // [esp+30h] [ebp-38h]
  const char *v16; // [esp+34h] [ebp-34h]
  const char *v17; // [esp+38h] [ebp-30h]
  const char *v18; // [esp+3Ch] [ebp-2Ch]
  const char *v19; // [esp+40h] [ebp-28h]
  const char *v20; // [esp+44h] [ebp-24h]
  const char *v21; // [esp+48h] [ebp-20h]
  const char *v22; // [esp+4Ch] [ebp-1Ch]
  const char *v23; // [esp+50h] [ebp-18h]
  const char *v24; // [esp+54h] [ebp-14h]
  int v25; // [esp+58h] [ebp-10h]
  int v26; // [esp+5Ch] [ebp-Ch]

  v13 = "[";
  v14 = "test invocation";
  v15 = "coreutils";
  v16 = "Multi-call invocation";
  v17 = "sha224sum";
  v18 = "sha2 utilities";
  v19 = "sha256sum";
  v20 = "sha2 utilities";
  v21 = "sha384sum";
  v22 = "sha2 utilities";
  v23 = "sha512sum";
  v24 = "sha2 utilities";
  v25 = 0;
  v26 = 0;
  v10 = s1;
  for ( i = &v13; *i && strcmp(s1, *i); i += 2 )
    ;
  if ( i[1] )
    v10 = (char *)i[1];
  v1 = gettext("\n%s online help: <%s>\n");
  printf(v1, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  v2 = setlocale(5, 0);
  v12 = v2;
  v3 = v2 == 0;
  v4 = &loc_804BB05;
  if ( v3 )
    v4 = &loc_804BB3F;
  dword_806B220 = (int)v4;
  sub_8061B42();
  if ( strncmp(v12, "en_", 3u) )
  {
    v5 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
    printf(v5, s1);
  }
  v6 = gettext("Full documentation at: <%s%s>\n");
  printf(v6, "http://www.gnu.org/software/coreutils/", s1);
  if ( v10 == s1 )
    v7 = " invocation";
  else
    v7 = &locale;
  v8 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  return printf(v8, v10, v7);
}
// 8061B42: using guessed type int sub_8061B42(void);
// 806B220: using guessed type int dword_806B220;

//----- (0804BB9B) --------------------------------------------------------
void __cdecl __noreturn sub_804BB9B(int a1, const char *a2)
{
  size_t v2; // eax
  void *v3; // eax
  char *v4; // ST28_4
  size_t v5; // eax
  char v6; // [esp+30h] [ebp-18h]
  unsigned int v7; // [esp+3Ch] [ebp-Ch]

  v7 = __readgsdword(0x14u);
  v2 = strlen(a2);
  write(2, a2, v2);
  v3 = &loc_804BBF6;
  if ( !a1 )
    v3 = &loc_804BC4F;
  dword_806B284 = (int)v3;
  sub_80618C2();
  v4 = (char *)sub_805945F(a1, (int)&v6);
  write(2, ": errno ", 8u);
  v5 = strlen(v4);
  write(2, v4, v5);
  write(2, "\n", 1u);
  _exit(2);
}
// 80618C2: using guessed type int sub_80618C2(void);
// 806B284: using guessed type int dword_806B284;

//----- (0804BC7A) --------------------------------------------------------
void __usercall __noreturn sub_804BC7A(long double fst7_0@<st0>, int a1, char *a2)
{
  int v3; // edx
  int v4; // ecx
  void *v5; // ebx
  int v6; // eax
  int v7; // [esp+Ch] [ebp-1Ch]
  void *v8; // [esp+10h] [ebp-18h]

  if ( !a2 )
  {
    gettext("standard output");
    dword_806B2D4 = (int)&loc_804BCAD;
    sub_80616F8(v4, v3);
  }
  v5 = sub_805BB3D(fst7_0, 0, 3, a2);
  v6 = *__errno_location();
  v8 = v5;
  v7 = a1;
  error(2, v6, "%s: %s", a1, v5);
  sub_804BCF1(a1);
}
// 80616F8: using guessed type int __fastcall sub_80616F8(_DWORD, _DWORD);
// 806B2D4: using guessed type int dword_806B2D4;

//----- (0804BCF1) --------------------------------------------------------
void __cdecl __noreturn sub_804BCF1(int status)
{
  int v1; // ebx
  char *v2; // eax
  int v3; // esi
  int v4; // ebx
  char *v5; // eax
  FILE *v6; // ebx
  char *v7; // eax
  FILE *v8; // ebx
  char *v9; // eax
  FILE *v10; // ebx
  char *v11; // eax
  FILE *v12; // ebx
  char *v13; // eax
  FILE *v14; // ebx
  char *v15; // eax
  FILE *v16; // ebx
  char *v17; // eax
  FILE *v18; // ebx
  char *v19; // eax
  FILE *v20; // ebx
  char *v21; // eax
  FILE *v22; // ebx
  char *v23; // eax
  FILE *v24; // ebx
  char *v25; // eax
  FILE *v26; // ebx
  char *v27; // eax
  FILE *v28; // ebx
  char *v29; // eax
  FILE *v30; // ebx
  char *v31; // eax
  char *v32; // eax
  FILE *v33; // ebx
  char *v34; // eax
  FILE *v35; // ebx
  char *v36; // eax
  FILE *v37; // ebx
  char *v38; // eax
  FILE *v39; // ebx
  char *v40; // eax
  FILE *v41; // ebx
  char *v42; // eax

  if ( status )
  {
    v1 = dword_806C3C1;
    v2 = gettext("Try '%s --help' for more information.\n");
    fprintf(stderr, v2, v1);
  }
  else
  {
    v3 = dword_806C3C1;
    v4 = dword_806C3C1;
    v5 = gettext("Usage: %s [OPTION]... [FILE]...\n  or:  %s [OPTION]... --files0-from=F\n");
    printf(v5, v4, v3);
    v6 = stdout;
    v7 = gettext("Write sorted concatenation of all FILE(s) to standard output.\n");
    fputs_unlocked(v7, v6);
    sub_804B9A6();
    sub_804B9D1();
    v8 = stdout;
    v9 = gettext("Ordering options:\n\n");
    fputs_unlocked(v9, v8);
    v10 = stdout;
    v11 = gettext(aBIgnoreLeading);
    fputs_unlocked(v11, v10);
    v12 = stdout;
    v13 = gettext(aGGeneralNume);
    fputs_unlocked(v13, v12);
    v14 = stdout;
    v15 = gettext("  -h, --human-numeric-sort    compare human readable numbers (e.g., 2K 1G)\n");
    fputs_unlocked(v15, v14);
    v16 = stdout;
    v17 = gettext(
            "  -n, --numeric-sort          compare according to string numerical value\n"
            "  -R, --random-sort           shuffle, but group identical keys.  See shuf(1)\n"
            "      --random-source=FILE    get random bytes from FILE\n"
            "  -r, --reverse               reverse the result of comparisons\n");
    fputs_unlocked(v17, v16);
    v18 = stdout;
    v19 = gettext(
            "      --sort=WORD             sort according to WORD:\n"
            "                                general-numeric -g, human-numeric -h, month -M,\n"
            "                                numeric -n, random -R, version -V\n"
            "  -V, --version-sort          natural sort of (version) numbers within text\n"
            "\n");
    fputs_unlocked(v19, v18);
    v20 = stdout;
    v21 = gettext("Other options:\n\n");
    fputs_unlocked(v21, v20);
    v22 = stdout;
    v23 = gettext(
            "      --batch-size=NMERGE   merge at most NMERGE inputs at once;\n"
            "                            for more use temp files\n");
    fputs_unlocked(v23, v22);
    v24 = stdout;
    v25 = gettext(
            "  -c, --check, --check=diagnose-first  check for sorted input; do not sort\n"
            "  -C, --check=quiet, --check=silent  like -c, but do not report first bad line\n"
            "      --compress-program=PROG  compress temporaries with PROG;\n"
            "                              decompress them with PROG -d\n");
    fputs_unlocked(v25, v24);
    v26 = stdout;
    v27 = gettext(
            "      --debug               annotate the part of the line used to sort,\n"
            "                              and warn about questionable usage to stderr\n"
            "      --files0-from=F       read input from the files specified by\n"
            "                            NUL-terminated names in file F;\n"
            "                            If F is - then read names from standard input\n");
    fputs_unlocked(v27, v26);
    v28 = stdout;
    v29 = gettext(
            "  -k, --key=KEYDEF          sort via a key; KEYDEF gives location and type\n"
            "  -m, --merge               merge already sorted files; do not sort\n");
    fputs_unlocked(v29, v28);
    v30 = stdout;
    v31 = gettext(
            "  -o, --output=FILE         write result to FILE instead of standard output\n"
            "  -s, --stable              stabilize sort by disabling last-resort comparison\n"
            "  -S, --buffer-size=SIZE    use SIZE for main memory buffer\n");
    fputs_unlocked(v31, v30);
    v32 = gettext(
            "  -t, --field-separator=SEP  use SEP instead of non-blank to blank transition\n"
            "  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or %s;\n"
            "                              multiple options specify multiple directories\n"
            "      --parallel=N          change the number of sorts run concurrently to N\n"
            "  -u, --unique              with -c, check for strict ordering;\n"
            "                              without -c, output only the first of an equal run\n");
    printf(v32, "/tmp");
    v33 = stdout;
    v34 = gettext("  -z, --zero-terminated     line delimiter is NUL, not newline\n");
    fputs_unlocked(v34, v33);
    v35 = stdout;
    v36 = gettext("      --help     display this help and exit\n");
    fputs_unlocked(v36, v35);
    v37 = stdout;
    v38 = gettext("      --version  output version information and exit\n");
    fputs_unlocked(v38, v37);
    v39 = stdout;
    v40 = gettext(
            "\n"
            "KEYDEF is F[.C][OPTS][,F[.C][OPTS]] for start and stop position, where F is a\n"
            "field number and C a character position in the field; both are origin 1, and\n"
            "the stop position defaults to the line's end.  If neither -t nor -b is in\n"
            "effect, characters in a field are counted from the beginning of the preceding\n"
            "whitespace.  OPTS is one or more single-letter ordering options [bdfgiMhnRrV],\n"
            "which override global ordering options for that key.  If no key is given, use\n"
            "the entire line as the key.  Use --debug to diagnose incorrect key usage.\n"
            "\n"
            "SIZE may be followed by the following multiplicative suffixes:\n");
    fputs_unlocked(v40, v39);
    v41 = stdout;
    v42 = gettext(
            "% 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, E, Z, Y.\n"
            "\n"
            "*** WARNING ***\n"
            "The locale specified by the environment affects sort order.\n"
            "Set LC_ALL=C to get the traditional sort order that uses\n"
            "native byte values.\n");
    fputs_unlocked(v42, v41);
    sub_804B9FC("sort");
  }
  exit(status);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 806C3C1: using guessed type int dword_806C3C1;

//----- (0804BFAD) --------------------------------------------------------
int __cdecl sub_804BFAD(int a1)
{
  bool v1; // dl
  int result; // eax

  v1 = pthread_sigmask(0, &set, (__sigset_t *)(a1 + 4)) == 0;
  result = a1;
  *(_BYTE *)a1 = v1;
  return result;
}

//----- (0804BFE2) --------------------------------------------------------
int __cdecl sub_804BFE2(unsigned __int8 *a1)
{
  int result; // eax

  result = *a1;
  if ( (_BYTE)result )
    result = pthread_sigmask(2, (const __sigset_t *)(a1 + 4), 0);
  return result;
}

//----- (0804C012) --------------------------------------------------------
int __cdecl sub_804C012(int a1, unsigned int a2)
{
  return *(_DWORD *)(a1 + 4) % a2;
}

//----- (0804C030) --------------------------------------------------------
bool __cdecl sub_804C030(int a1, int a2)
{
  return *(_DWORD *)(a1 + 4) == *(_DWORD *)(a2 + 4);
}

//----- (0804C055) --------------------------------------------------------
int __usercall sub_804C055@<eax>(int a1@<ecx>, long double a2@<st0>, int a3)
{
  int v3; // edx
  void *v4; // esi
  char *v5; // ebx
  int v6; // eax
  bool v7; // zf
  void *v8; // eax
  void *v9; // ebx
  char *v10; // eax
  void *v12; // [esp+Ch] [ebp-1Ch]
  int stat_loc; // [esp+18h] [ebp-10h]
  int v14; // [esp+1Ch] [ebp-Ch]

  v3 = a3 == 0;
  if ( a3 )
  {
    dword_806B2E8 = (int)&loc_804C08C;
    sub_8061650(a1, v3);
  }
  v14 = waitpid(-1, &stat_loc, v3);
  if ( v14 < 0 )
  {
    v4 = sub_805B9E2(a2, 4, s1);
    v5 = gettext("waiting for %s [-d]");
    v6 = *__errno_location();
    v12 = v4;
    error(2, v6, v5, v4);
  }
  if ( v14 > 0 )
  {
    if ( a3 <= 0 )
    {
      v7 = (unsigned __int8)sub_804C220(v14) == 0;
      v8 = &loc_804C124;
      if ( v7 )
        v8 = &loc_804C189;
      dword_806B374 = (int)v8;
      sub_80612DD();
    }
    if ( stat_loc & 0x7F || (stat_loc & 0xFF00) >> 8 )
    {
      v9 = sub_805B9E2(a2, 4, s1);
      v10 = gettext("%s [-d] terminated abnormally");
      v12 = v9;
      error(2, 0, v10, v9);
    }
    --dword_806C2F9;
  }
  return v14;
}
// 80612DD: using guessed type int sub_80612DD(void);
// 8061650: using guessed type int __fastcall sub_8061650(_DWORD, _DWORD);
// 806B2E8: using guessed type int dword_806B2E8;
// 806B374: using guessed type int dword_806B374;
// 806C2F9: using guessed type int dword_806C2F9;

//----- (0804C193) --------------------------------------------------------
int __usercall sub_804C193@<eax>(double st7_0@<st0>, int a1)
{
  int v2; // ecx
  void *v3; // eax
  int result; // eax

  if ( !dword_806C2F5 )
  {
    dword_806C2F5 = sub_8058289(47, 0);
    v3 = &loc_804C1F5;
    if ( dword_806C2F5 )
      v3 = &loc_804C1FA;
    dword_806B298 = (int)v3;
    sub_806184C(v2);
    sub_805E44B();
  }
  *(_BYTE *)(a1 + 8) = 1;
  result = sub_8058E57(st7_0, dword_806C2F5, a1);
  if ( !result )
    sub_805E44B();
  return result;
}
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD);
// 806B298: using guessed type int dword_806B298;
// 806C2F5: using guessed type int dword_806C2F5;

//----- (0804C220) --------------------------------------------------------
signed int __cdecl sub_804C220(int a1)
{
  int v2; // [esp+1Ch] [ebp-1Ch]
  char v3; // [esp+20h] [ebp-18h]
  int v4; // [esp+24h] [ebp-14h]
  unsigned int v5; // [esp+2Ch] [ebp-Ch]

  v5 = __readgsdword(0x14u);
  v4 = a1;
  v2 = sub_8058EC0(dword_806C2F5, (int)&v3);
  if ( !v2 )
    return 0;
  *(_BYTE *)(v2 + 8) = 2;
  return 1;
}
// 806C2F5: using guessed type int dword_806C2F5;

//----- (0804C27A) --------------------------------------------------------
signed int __usercall sub_804C27A@<eax>(long double a1@<st0>, int a2)
{
  signed int result; // eax
  int v3; // ecx

  result = sub_804C220(a2);
  if ( (_BYTE)result )
    result = sub_804C055(v3, a1, a2);
  return result;
}

//----- (0804C29C) --------------------------------------------------------
int __usercall sub_804C29C@<eax>(long double a1@<st0>)
{
  void *v1; // eax
  int v2; // ecx
  int result; // eax

  do
  {
    v1 = &loc_804C2C6;
    if ( dword_806C2F9 <= 0 )
      v1 = &locret_804C2D6;
    dword_806B374 = (int)v1;
    sub_80612DD();
    result = sub_804C055(v2, a1, 0);
  }
  while ( result );
  return result;
}
// 80612DD: using guessed type int sub_80612DD(void);
// 806B374: using guessed type int dword_806B374;
// 806C2F9: using guessed type int dword_806C2F9;

//----- (0804C2D8) --------------------------------------------------------
int __usercall sub_804C2D8@<eax>(int a1@<ecx>, long double a2@<st0>)
{
  sub_804C055(a1, a2, -1);
  return sub_804C29C(a2);
}

//----- (0804C2F1) --------------------------------------------------------
int __usercall sub_804C2F1@<eax>(int a1@<ecx>, long double a2@<st0>)
{
  int result; // eax

  while ( 1 )
  {
    result = dword_806C2F9;
    if ( dword_806C2F9 <= 0 )
      break;
    sub_804C055(a1, a2, -1);
  }
  return result;
}
// 806C2F9: using guessed type int dword_806C2F9;

//----- (0804C310) --------------------------------------------------------
int sub_804C310()
{
  int result; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  result = dword_806C2F1;
  for ( i = dword_806C2F1; i; i = *(_DWORD *)i )
  {
    unlink((const char *)(i + 9));
    result = *(_DWORD *)i;
  }
  dword_806C2F1 = 0;
  return result;
}
// 806C2F1: using guessed type int dword_806C2F1;

//----- (0804C348) --------------------------------------------------------
int __usercall sub_804C348@<eax>(long double a1@<st0>)
{
  void *v1; // eax
  char v3; // [esp+1Ch] [ebp-8Ch]

  v1 = &loc_804C373;
  if ( !dword_806C2F1 )
    v1 = &loc_804C394;
  dword_806B25C = (int)v1;
  sub_80619C7(*(double *)&a1);
  sub_804BFAD((int)&v3);
  sub_804C310();
  sub_804BFE2((unsigned __int8 *)&v3);
  return sub_8055F55(a1);
}
// 80619C7: using guessed type int __usercall sub_80619C7@<eax>(double@<st0>);
// 806B25C: using guessed type int dword_806B25C;
// 806C2F1: using guessed type int dword_806C2F1;

//----- (0804C39B) --------------------------------------------------------
int *__cdecl sub_804C39B(int *a1, char a2)
{
  size_t n; // ST34_4
  _DWORD *v3; // eax
  int v4; // ecx
  void *v5; // eax
  long double v6; // fst7
  void *v7; // esi
  char *v8; // ebx
  int *v9; // eax
  int *ptr; // [esp+24h] [ebp-A4h]
  char *s; // [esp+28h] [ebp-A0h]
  int v13; // [esp+34h] [ebp-94h]
  int v14; // [esp+38h] [ebp-90h]
  char v15; // [esp+3Ch] [ebp-8Ch]

  s = (char *)*((_DWORD *)::ptr + dword_806C3AD);
  n = strlen(*((const char **)::ptr + dword_806C3AD));
  ptr = (int *)sub_805E2B0((n + 24) & 0xFFFFFFFC);
  memcpy((char *)ptr + 9, s, n);
  v3 = (int *)((char *)ptr + n + 9);
  *v3 = 1919906607;
  v3[1] = 1482184820;
  v3[2] = 5789784;
  *ptr = 0;
  if ( ++dword_806C3AD == dword_806C259 )
    dword_806C3AD = 0;
  sub_804BFAD((int)&v15);
  v13 = sub_805D322((int)ptr + 9, 0x80000);
  if ( v13 >= 0 )
  {
    *off_806B448 = (int)ptr;
    off_806B448 = ptr;
  }
  v14 = *__errno_location();
  sub_804BFE2((unsigned __int8 *)&v15);
  *__errno_location() = v14;
  if ( v13 < 0 )
  {
    v5 = &loc_804C521;
    if ( a2 != 1 )
      v5 = &loc_804C52D;
    dword_806B234 = (int)v5;
    v6 = sub_8061AC8(v4, v14);
    if ( *__errno_location() != 24 )
    {
      v7 = sub_805B9E2(v6, 4, s);
      v8 = gettext("cannot create temporary file in %s");
      v9 = __errno_location();
      error(2, *v9, v8, v7);
    }
    free(ptr);
    ptr = 0;
  }
  *a1 = v13;
  return ptr;
}
// 8061AC8: using guessed type double __fastcall sub_8061AC8(_DWORD, _DWORD);
// 806B234: using guessed type int dword_806B234;
// 806B448: using guessed type int *off_806B448;
// 806C259: using guessed type int dword_806C259;
// 806C3AD: using guessed type int dword_806C3AD;

//----- (0804C5A5) --------------------------------------------------------
FILE *__usercall sub_804C5A5@<eax>(long double a1@<st0>, char *s1, char *modes)
{
  int v3; // ecx
  FILE *v4; // eax
  bool v5; // zf
  int v6; // ecx
  void *v7; // eax
  void *v8; // esi
  char *v9; // ebx
  int *v10; // eax
  FILE *stream; // [esp+18h] [ebp-10h]
  int fd; // [esp+1Ch] [ebp-Ch]

  if ( *modes == 114 )
  {
    if ( !strcmp(s1, "-") )
    {
      byte_806C264 = 1;
      dword_806B2C0 = (int)&loc_804C630;
      sub_8061764(v3);
    }
    fd = open64(s1, 0x80000);
    if ( fd < 0 )
      v4 = 0;
    else
      v4 = fdopen(fd, modes);
    stream = v4;
    sub_805734A(v4, 2);
  }
  else
  {
    if ( *modes != 119 )
      __assert_fail("!\"unexpected mode passed to stream_open\"", "src/sort.c", 0x3CCu, "stream_open");
    if ( s1 )
    {
      v5 = ftruncate64(1, 0, 0) == 0;
      v7 = &loc_804C699;
      if ( v5 )
        v7 = &loc_804C6E3;
      dword_806B298 = (int)v7;
      sub_806184C(v6);
      v8 = sub_805BB3D(a1, 0, 3, s1);
      v9 = gettext("%s: error truncating");
      v10 = __errno_location();
      error(2, *v10, v9, v8);
    }
    stream = stdout;
  }
  return stream;
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 8049D20: using guessed type int __cdecl ftruncate64(_DWORD, _DWORD, _DWORD);
// 8061764: using guessed type int __fastcall sub_8061764(_DWORD);
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD);
// 806B298: using guessed type int dword_806B298;
// 806B2C0: using guessed type int dword_806B2C0;
// 806C264: using guessed type char byte_806C264;

//----- (0804C71B) --------------------------------------------------------
FILE *__usercall sub_804C71B@<eax>(long double a1@<st0>, char *s1, char *modes)
{
  char *v3; // eax
  FILE *v5; // [esp+1Ch] [ebp-Ch]

  v5 = sub_804C5A5(a1, s1, modes);
  if ( !v5 )
  {
    v3 = gettext("open failed");
    sub_804BC7A(a1, (int)v3, s1);
  }
  return v5;
}

//----- (0804C75C) --------------------------------------------------------
int __usercall sub_804C75C@<eax>(long double a1@<st0>, FILE *stream, int a3)
{
  bool v3; // zf
  int v4; // edx
  int v5; // ecx
  void *v6; // eax
  void *v7; // eax
  int result; // eax
  char *v9; // eax

  v3 = fileno(stream) == 0;
  v6 = &loc_804C78A;
  if ( v3 )
    v6 = &loc_804C7AA;
  dword_806B388 = (int)v6;
  v3 = sub_8061252(v5, v4) == 1;
  v7 = &loc_804C7A8;
  if ( v3 )
    v7 = &loc_804C7DD;
  dword_806B374 = (int)v7;
  sub_80612DD();
  result = sub_805F2A2(*(double *)&a1, stream);
  if ( result )
  {
    v9 = gettext("close failed");
    sub_804BC7A(a1, (int)v9, (char *)a3);
  }
  return result;
}
// 804C75C: could not find valid save-restore pair for ebx
// 8061252: using guessed type int __fastcall sub_8061252(_DWORD, _DWORD);
// 80612DD: using guessed type int sub_80612DD(void);
// 806B374: using guessed type int dword_806B374;
// 806B388: using guessed type int dword_806B388;

//----- (0804C835) --------------------------------------------------------
int __usercall sub_804C835@<eax>(double a1@<st0>, int fd, int fd2)
{
  void *v3; // eax

  v3 = &loc_804C85C;
  if ( fd == fd2 )
    v3 = &locret_804C879;
  dword_806B25C = (int)v3;
  sub_80619C7(a1);
  dup2(fd, fd2);
  return close(fd);
}
// 80619C7: using guessed type int __usercall sub_80619C7@<eax>(double@<st0>);
// 806B25C: using guessed type int dword_806B25C;

//----- (0804C87B) --------------------------------------------------------
int __usercall sub_804C87B@<eax>(int a1@<edx>, int a2@<ecx>, int pipedes[2], int a4)
{
  int v4; // ecx
  int v6; // edx
  int v7; // ecx
  void *v8; // eax
  int v9; // ST24_4
  int v10; // [esp+14h] [ebp-A4h]

  if ( sub_8059DDD(a1, a2, pipedes, 0x80000) < 0 )
    return -1;
  if ( dword_806B444 + 1 < (unsigned int)dword_806C2F9 )
  {
    sub_804C2D8(v4, 0.25);
    dword_806B20C = (int)&loc_804C983;
    sub_8061BBC(v7, v6);
  }
  v8 = &loc_804C9A9;
  if ( a4 )
    v8 = &loc_804C8E3;
  dword_806B388 = (int)v8;
  sub_8061252(v4, a4 - 1);
  if ( v10 >= 0 )
  {
    if ( v10 )
    {
      ++dword_806C2F9;
    }
    else
    {
      close(0);
      close(1);
    }
  }
  else
  {
    v9 = *__errno_location();
    close(*pipedes);
    close(pipedes[1]);
    *__errno_location() = v9;
  }
  return v10;
}
// 8061252: using guessed type int __fastcall sub_8061252(_DWORD, _DWORD);
// 8061BBC: using guessed type int __fastcall sub_8061BBC(_DWORD, _DWORD);
// 806B20C: using guessed type int dword_806B20C;
// 806B388: using guessed type int dword_806B388;
// 806C2F9: using guessed type int dword_806C2F9;

//----- (0804CA23) --------------------------------------------------------
int __usercall sub_804CA23@<eax>(long double a1@<st0>, FILE **a2, char a3)
{
  int v3; // edx
  int v4; // ecx
  int v6; // eax
  int *v7; // eax
  int v8; // ecx
  void *v9; // eax
  char *v10; // ebx
  char *v11; // eax
  int v12; // [esp+Ch] [ebp-1Ch]
  int fd; // [esp+10h] [ebp-18h]
  int *v14; // [esp+14h] [ebp-14h]
  int pipedes[2]; // [esp+18h] [ebp-10h]

  LOBYTE(v12) = a3;
  v14 = sub_804C39B(&fd, a3);
  if ( v14 )
  {
    *((_BYTE *)v14 + 8) = 0;
    if ( s1 )
    {
      v6 = sub_804C87B(v3, v4, pipedes, 4);
      v14[1] = v6;
      if ( v14[1] <= 0 )
      {
        if ( !v14[1] )
        {
          close(pipedes[1]);
          sub_804C835(*(double *)&a1, fd, 1);
          sub_804C835(*(double *)&a1, pipedes[0], 0);
          execlp(s1, s1, 0, v12);
          v7 = __errno_location();
          sub_804BB9B(*v7, "couldn't execute compress program");
        }
      }
      else
      {
        close(fd);
        close(pipedes[0]);
        fd = pipedes[1];
        sub_804C193(*(double *)&a1, (int)v14);
      }
    }
    *a2 = fdopen(fd, "w");
    v9 = &loc_804CB61;
    if ( *a2 )
      v9 = &loc_804CB7F;
    dword_806B2D4 = (int)v9;
    sub_80616F8(v8, a2);
    v10 = (char *)v14 + 9;
    v11 = gettext("couldn't create temporary file");
    sub_804BC7A(a1, (int)v11, v10);
  }
  return 0;
}
// 80616F8: using guessed type int __fastcall sub_80616F8(_DWORD, _DWORD);
// 806B2D4: using guessed type int dword_806B2D4;

//----- (0804CB88) --------------------------------------------------------
int __usercall sub_804CB88@<eax>(long double a1@<st0>, FILE **a2)
{
  return sub_804CA23(a1, a2, 0);
}

//----- (0804CBA3) --------------------------------------------------------
FILE *__usercall sub_804CBA3@<eax>(long double a1@<st0>, int a2)
{
  int v2; // edx
  int v3; // ecx
  int v4; // eax
  bool v5; // zf
  int v6; // edx
  int v7; // ecx
  void *v8; // eax
  void *v9; // esi
  char *v10; // ebx
  int v11; // eax
  int *v12; // eax
  FILE *v13; // eax
  const char *v15; // [esp+8h] [ebp-30h]
  void *v16; // [esp+Ch] [ebp-2Ch]
  FILE *v17; // [esp+18h] [ebp-20h]
  int fd; // [esp+1Ch] [ebp-1Ch]
  int v19; // [esp+20h] [ebp-18h]
  int v20; // [esp+24h] [ebp-14h]
  int pipedes[2]; // [esp+28h] [ebp-10h]

  v17 = 0;
  if ( *(_BYTE *)(a2 + 8) == 1 )
    sub_804C27A(a1, *(_DWORD *)(a2 + 4));
  fd = open64(a2 + 9, 0);
  if ( fd < 0 )
  {
    dword_806B310 = (int)&loc_804CD8E;
    sub_8061566(v3, v2);
  }
  v4 = sub_804C87B(v2, v3, pipedes, 9);
  v19 = v4;
  if ( v4 == -1 )
  {
    v5 = *__errno_location() == 24;
    v8 = &loc_804CC56;
    if ( v5 )
      v8 = &loc_804CC9A;
    dword_806B2E8 = (int)v8;
    sub_8061650(v7, v6);
    v9 = sub_805B9E2(a1, 4, s1);
    v10 = gettext("couldn't create process for %s -d");
    v11 = *__errno_location();
    v16 = v9;
    error(2, v11, v10, v9);
    close(fd);
    *__errno_location() = 24;
  }
  else
  {
    if ( !v4 )
    {
      close(pipedes[0]);
      sub_804C835(*(double *)&a1, fd, 0);
      sub_804C835(*(double *)&a1, pipedes[1], 1);
      v16 = 0;
      v15 = "-d";
      execlp(s1, s1, "-d", 0);
      v12 = __errno_location();
      sub_804BB9B(*v12, "couldn't execute compress program (with -d)");
    }
    *(_DWORD *)(a2 + 4) = v19;
    sub_804C193(*(double *)&a1, a2);
    close(fd);
    close(pipedes[1]);
    v13 = fdopen(pipedes[0], "r");
    v17 = v13;
    if ( !v13 )
    {
      v20 = *__errno_location();
      close(pipedes[0]);
      *__errno_location() = v20;
    }
  }
  return v17;
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 8061566: using guessed type int __fastcall sub_8061566(_DWORD, _DWORD);
// 8061650: using guessed type int __fastcall sub_8061650(_DWORD, _DWORD);
// 806B2E8: using guessed type int dword_806B2E8;
// 806B310: using guessed type int dword_806B310;

//----- (0804CD95) --------------------------------------------------------
int __cdecl sub_804CD95(int a1)
{
  int v1; // ecx
  void *v2; // eax
  int v3; // edx
  int v4; // ecx
  int v5; // eax
  int *v6; // edx
  int result; // eax

  v2 = &loc_804CDC3;
  if ( dword_806C259 != dword_806C25D )
    v2 = &loc_804CDE5;
  dword_806B298 = (int)v2;
  sub_806184C(v1);
  ptr = sub_805E1D4(v3, v4, ptr, (int)&dword_806C25D, 4);
  v5 = dword_806C259++;
  v6 = (int *)((char *)ptr + 4 * v5);
  result = a1;
  *v6 = a1;
  return result;
}
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD);
// 806B298: using guessed type int dword_806B298;
// 806C259: using guessed type int dword_806C259;
// 806C25D: using guessed type int dword_806C25D;

//----- (0804CE06) --------------------------------------------------------
void __usercall sub_804CE06(long double a1@<st0>, char *name)
{
  int v2; // ST28_4
  void *v3; // ebx
  char *v4; // eax
  int *i; // [esp+18h] [ebp-A0h]
  int errnum; // [esp+1Ch] [ebp-9Ch]
  _DWORD *ptr; // [esp+20h] [ebp-98h]
  int v8; // [esp+24h] [ebp-94h]
  char v9; // [esp+2Ch] [ebp-8Ch]

  for ( i = &dword_806C2F1; ; i = (int *)*i )
  {
    ptr = (_DWORD *)*i;
    if ( (char *)(*i + 9) == name )
      break;
  }
  if ( *((_BYTE *)ptr + 8) == 1 )
    sub_804C27A(a1, ptr[1]);
  v8 = *ptr;
  sub_804BFAD((int)&v9);
  v2 = unlink(name);
  errnum = *__errno_location();
  *i = v8;
  sub_804BFE2((unsigned __int8 *)&v9);
  if ( v2 )
  {
    v3 = sub_805BB3D(a1, 0, 3, name);
    v4 = gettext("warning: cannot remove: %s");
    error(0, errnum, v4, v3);
  }
  if ( !v8 )
    off_806B448 = i;
  free(ptr);
}
// 806B448: using guessed type int *off_806B448;
// 806C2F1: using guessed type int dword_806C2F1;

//----- (0804CF3E) --------------------------------------------------------
int __cdecl compar(const void *a1, const void *a2)
{
  return strcmp(*(const char **)a1, *(const char **)a2);
}

//----- (0804CF68) --------------------------------------------------------
void sub_804CF68()
{
  bool v0; // al
  const unsigned __int16 *v1; // ebx
  int v2; // eax
  unsigned int c; // [esp+18h] [ebp-20h]
  unsigned int ca; // [esp+18h] [ebp-20h]
  size_t i; // [esp+1Ch] [ebp-1Ch]
  int v6; // [esp+20h] [ebp-18h]
  const char *s; // [esp+24h] [ebp-14h]
  size_t v8; // [esp+28h] [ebp-10h]
  char *v9; // [esp+2Ch] [ebp-Ch]

  for ( c = 0; c <= 0xFF; ++c )
  {
    *(_BYTE *)(c + 134659665) = sub_804B921(c);
    *(_BYTE *)(c + 134659921) = ((*__ctype_b_loc())[c] & 0x4000) == 0;
    v0 = !((*__ctype_b_loc())[c] & 8) && (unsigned __int8)sub_804B921(c) ^ 1;
    *(_BYTE *)(c + 134660177) = v0;
    *(_BYTE *)(c + 134660433) = toupper(c);
  }
  if ( byte_806BE3A )
  {
    for ( ca = 0; ca <= 0xB; ++ca )
    {
      s = nl_langinfo(ca + 131086);
      v8 = strlen(s);
      v9 = (char *)sub_805E2B0(v8 + 1);
      (&off_806B3DC)[2 * ca] = v9;
      dword_806B3E0[2 * ca] = ca + 1;
      v6 = 0;
      for ( i = 0; i < v8; ++i )
      {
        v1 = *__ctype_b_loc();
        if ( !(v1[(unsigned __int8)sub_804B90F(s[i])] & 1) )
        {
          v2 = v6++;
          v9[v2] = byte_806C151[(unsigned __int8)sub_804B90F(s[i])];
        }
      }
      v9[v6] = 0;
    }
    qsort(&off_806B3DC, 0xCu, 8u, compar);
  }
}
// 806B3DC: using guessed type char *off_806B3DC;
// 806B3E0: using guessed type int dword_806B3E0[];
// 806BE3A: using guessed type char byte_806BE3A;

//----- (0804D159) --------------------------------------------------------
int __usercall __noreturn sub_804D159@<eax>(long double fst7_0@<st0>, int a1, char a2, char *a3)
{
  bool v4; // zf
  int v5; // edx
  int v6; // ecx
  void *v7; // eax
  int v8; // ecx
  int v9; // ecx
  void *v10; // ebx
  int v11; // esi
  char *v12; // eax
  void *v13; // ebx
  int v14; // esi
  char *v15; // eax
  int (*v16)(); // eax
  void *v18; // ebx
  int v19; // esi
  char *v20; // eax
  int v21; // ebx
  int v22; // esi
  char *v23; // eax
  int v24; // [esp+Ch] [ebp-4Ch]
  void *v25; // [esp+10h] [ebp-48h]
  char *nptr; // [esp+18h] [ebp-40h]
  char v27; // [esp+1Ch] [ebp-3Ch]
  int v28; // [esp+20h] [ebp-38h]
  unsigned int v29; // [esp+24h] [ebp-34h]
  __int64 v30; // [esp+28h] [ebp-30h]
  int v31; // [esp+30h] [ebp-28h]
  char v32; // [esp+41h] [ebp-17h]
  unsigned int v33; // [esp+4Ch] [ebp-Ch]

  v27 = a2;
  nptr = a3;
  v33 = __readgsdword(0x14u);
  v28 = sub_805EE45(a3, 0, 10, (int)&v30, 0);
  v4 = getrlimit64(7, &v31) == 0;
  v7 = &loc_804D1D5;
  if ( !v4 )
    v7 = &loc_804D1E0;
  dword_806B324 = (int)v7;
  sub_80614D5(v6, v5);
  v29 = v31 - 3;
  if ( v28 )
  {
    if ( v28 == 1 )
    {
      v18 = sub_805BD75(fst7_0, nptr);
      v19 = *((_DWORD *)&longopts.name + 4 * a1);
      v20 = gettext("--%s argument %s too large");
      v25 = v18;
      v24 = v19;
      error(0, 0, v20, v19, v18);
      v21 = sub_805956B(v29, (int)&v32);
      v22 = *((_DWORD *)&longopts.name + 4 * a1);
      v23 = gettext("maximum --%s argument with current rlimit is %s");
      error(2, 0, v23, v22, v21);
    }
    sub_805ED2B(v8, (int)nptr, v28, a1, v27, (int)&longopts, (int)nptr);
  }
  dword_806B444 = v30;
  v9 = v30;
  if ( v30 != (unsigned int)v30 )
  {
    v28 = 1;
    dword_806B20C = (int)&loc_804D326;
    sub_8061BBC(v30, HIDWORD(v30));
  }
  if ( (unsigned int)dword_806B444 <= 1 )
  {
    v10 = sub_805BD75(fst7_0, nptr);
    v11 = *((_DWORD *)&longopts.name + 4 * a1);
    v12 = gettext("invalid --%s argument %s");
    v25 = v10;
    v24 = v11;
    error(0, 0, v12, v11, v10);
    v13 = sub_805BD75(fst7_0, "2");
    v14 = *((_DWORD *)&longopts.name + 4 * a1);
    v15 = gettext("minimum --%s argument is %s");
    v25 = v13;
    v24 = v14;
    error(2, 0, v15, v14, v13);
  }
  if ( v29 < dword_806B444 )
  {
    v28 = 1;
    dword_806B298 = (int)&loc_804D326;
    sub_806184C(v9);
  }
  v16 = (int (*)())&loc_804D321;
  if ( __readgsdword(0x14u) == v33 )
    v16 = sub_804D3F1;
  dword_806B374 = (int)v16;
  return sub_80612DD();
}
// 8049920: using guessed type int __cdecl getrlimit64(_DWORD, _DWORD);
// 804D3F1: using guessed type int sub_804D3F1();
// 80612DD: using guessed type int sub_80612DD(void);
// 80614D5: using guessed type int __fastcall sub_80614D5(_DWORD, _DWORD);
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD);
// 8061BBC: using guessed type int __fastcall sub_8061BBC(_DWORD, _DWORD);
// 806B20C: using guessed type int dword_806B20C;
// 806B298: using guessed type int dword_806B298;
// 806B324: using guessed type int dword_806B324;
// 806B374: using guessed type int dword_806B374;

//----- (0804D3F1) --------------------------------------------------------
#error "804D3F4: positive sp value has been found (funcsize=0)"

//----- (0804D3F8) --------------------------------------------------------
unsigned __int64 __usercall sub_804D3F8@<edx:eax>(double a1@<st0>, int a2, int a3, char *nptr)
{
  void *v4; // eax
  int v5; // ecx
  int v6; // eax
  unsigned __int64 result; // rax
  int v8; // eax
  char v9; // [esp+2Ch] [ebp-3Ch]
  int v10; // [esp+38h] [ebp-30h]
  int v11; // [esp+3Ch] [ebp-2Ch]
  unsigned __int64 v12; // [esp+40h] [ebp-28h]

  v9 = a3;
  v11 = sub_805EE45(nptr, (int)&v10, 10, (int)&v12, "EgGkKmMPtTYZ");
  if ( !v11 && (unsigned int)(*(char *)(v10 - 1) - 48) <= 9 )
  {
    if ( HIDWORD(v12) > 0x3FFFFF )
      v11 = 1;
    else
      v12 <<= 10;
  }
  v4 = &loc_804D496;
  if ( v11 != 2 )
    v4 = &loc_804D5C2;
  dword_806B338 = (int)v4;
  sub_8061467(a1);
  if ( (unsigned int)(*(char *)(v10 - 1) - 48) <= 9 && !*(_BYTE *)(v10 + 1) )
  {
    v6 = *(char *)v10;
    if ( v6 == 37 )
      sub_8059C0A();
    if ( v6 == 98 )
      v11 = 0;
  }
  if ( v11 )
LABEL_21:
    sub_805ED2B(v5, (int)nptr, v11, a2, v9, (int)&longopts, (int)nptr);
  result = v12;
  if ( size <= v12 )
  {
    size = v12;
    v5 = v12;
    if ( v12 == (unsigned int)v12 )
    {
      v8 = size;
      if ( 18 * dword_806B444 >= size )
        v8 = 18 * dword_806B444;
      size = v8;
      dword_806B2FC = (int)&loc_804D67F;
      sub_80615DC();
    }
    v11 = 1;
    goto LABEL_21;
  }
  return result;
}
// 8061467: using guessed type int __usercall sub_8061467@<eax>(double@<st0>);
// 80615DC: using guessed type int sub_80615DC(void);
// 806B2FC: using guessed type int dword_806B2FC;
// 806B338: using guessed type int dword_806B338;

//----- (0804D687) --------------------------------------------------------
void __cdecl __noreturn sub_804D687(int a1, int a2, int a3)
{
  sub_805E73E(a3, 0, 10);
}

//----- (0804D745) --------------------------------------------------------
void __noreturn sub_804D745()
{
  bool v0; // zf
  int v1; // edx
  int v2; // ecx
  void *v3; // eax
  double v4; // ST30_8
  __int64 v5; // [esp+40h] [ebp-18h]

  v0 = getrlimit64(2, &v5) == 0;
  v3 = &loc_804D783;
  if ( !v0 )
    v3 = &loc_804D7A6;
  dword_806B234 = (int)v3;
  sub_8061AC8(v2, v1);
  getrlimit64(9, &v5);
  getrlimit64(5, &v5);
  v4 = sub_8059CE5();
  sub_8059C0A();
}
// 8049920: using guessed type int __cdecl getrlimit64(_DWORD, _DWORD);
// 8061AC8: using guessed type double __fastcall sub_8061AC8(_DWORD, _DWORD);
// 806B234: using guessed type int dword_806B234;

//----- (0804D92D) --------------------------------------------------------
int __usercall sub_804D92D@<eax>(long double a1@<st0>, FILE **a2, unsigned int a3, int *a4, unsigned int a5, int a6)
{
  int v6; // eax
  bool v7; // al
  int v8; // ecx
  int v9; // eax
  bool v10; // zf
  void *v11; // eax
  char *v12; // ebx
  char *v13; // eax
  char v15; // [esp+30h] [ebp-68h]

  if ( a5 > 0 )
  {
    if ( a3 <= 0 )
    {
      if ( !strcmp((const char *)*a4, "-") )
        v9 = sub_80611C9(0, (int)&v15);
      else
        v9 = sub_806119A(*a4, (int)&v15);
      v7 = v9 != 0;
    }
    else
    {
      v6 = fileno(*a2);
      v7 = sub_80611C9(v6, (int)&v15) != 0;
    }
    v10 = v7 == 0;
    v11 = &loc_804DA0D;
    if ( v10 )
      v11 = &loc_804DA36;
    dword_806B298 = (int)v11;
    sub_806184C(v8);
    v12 = (char *)*a4;
    v13 = gettext("stat failed");
    sub_804BC7A(a1, (int)v13, v12);
  }
  return a6 + 2;
}
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD);
// 806B298: using guessed type int dword_806B298;

//----- (0804DB2D) --------------------------------------------------------
int __cdecl sub_804DB2D(int a1, int a2, size_t size)
{
  int v3; // ecx
  int result; // eax
  size_t sizea; // [esp+28h] [ebp+10h]

  sizea = (size & 0xFFFFFFF0) + 16;
  *(_DWORD *)a1 = malloc(sizea);
  if ( !*(_DWORD *)a1 )
  {
    sizea >>= 1;
    if ( a2 + 1 >= sizea )
      sub_805E44B();
    dword_806B34C = (int)&loc_804DB33;
    sub_80613F7(v3);
  }
  *(_DWORD *)(a1 + 20) = a2;
  *(_DWORD *)(a1 + 12) = sizea;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a1 + 16);
  result = a1;
  *(_BYTE *)(a1 + 24) = 0;
  return result;
}
// 80613F7: using guessed type int __fastcall sub_80613F7(_DWORD);
// 806B34C: using guessed type int dword_806B34C;

//----- (0804DBC8) --------------------------------------------------------
int __cdecl sub_804DBC8(_DWORD *a1)
{
  return *a1 + a1[3];
}

//----- (0804DBE3) --------------------------------------------------------
char *__usercall sub_804DBE3@<eax>(double a1@<st0>, int ecx0@<ecx>, char **a2, int a3)
{
  char *v4; // edx
  int v5; // edx
  void *v6; // eax
  int v7; // edx
  int v8; // ecx
  int v9; // eax
  char *result; // eax
  unsigned __int8 *v11; // [esp+4h] [ebp-10h]
  int v12; // [esp+8h] [ebp-Ch]
  char *v13; // [esp+Ch] [ebp-8h]
  int v14; // [esp+10h] [ebp-4h]

  v11 = (unsigned __int8 *)*a2;
  v4 = a2[1] - 1;
  v13 = &(*a2)[(_DWORD)v4];
  v12 = *(_DWORD *)a3;
  v14 = *(_DWORD *)(a3 + 4);
  if ( dword_806B440 == 128 )
  {
LABEL_6:
    dword_806B360 = (int)&loc_804DD1F;
    sub_806137F(ecx0, v4);
    do
    {
      dword_806B234 = (int)&loc_804DCC8;
      sub_8061AC8(v8, v7);
      do
        ++v11;
      while ( v11 < (unsigned __int8 *)v13 && byte_806BE51[(unsigned __int8)sub_804B90F(*v11)] );
      while ( v11 < (unsigned __int8 *)v13 && (unsigned __int8)byte_806BE51[(unsigned __int8)sub_804B90F(*v11)] ^ 1 )
        ++v11;
      if ( v11 >= (unsigned __int8 *)v13 )
        break;
      v9 = v12;
      v7 = v12-- - 1;
    }
    while ( v9 );
    goto LABEL_16;
  }
  if ( v11 < (unsigned __int8 *)v13 )
  {
    v5 = v12-- - 1;
    v6 = &loc_804DC7F;
    if ( *(_DWORD *)a3 )
      v6 = &loc_804DC21;
    dword_806B2D4 = (int)v6;
    sub_80616F8(ecx0, v5);
    dword_806B338 = (int)&loc_804DD38;
    sub_8061467(a1);
    goto LABEL_6;
  }
LABEL_16:
  if ( *(_BYTE *)(a3 + 24) )
  {
    while ( v11 < (unsigned __int8 *)v13 && byte_806BE51[(unsigned __int8)sub_804B90F(*v11)] )
      ++v11;
  }
  result = v13;
  if ( &v11[v14] <= (unsigned __int8 *)v13 )
    result = (char *)&v11[v14];
  return result;
}
// 806137F: using guessed type int __fastcall sub_806137F(_DWORD, _DWORD);
// 8061467: using guessed type int __usercall sub_8061467@<eax>(double@<st0>);
// 80616F8: using guessed type int __fastcall sub_80616F8(_DWORD, _DWORD);
// 8061AC8: using guessed type double __fastcall sub_8061AC8(_DWORD, _DWORD);
// 806B234: using guessed type int dword_806B234;
// 806B2D4: using guessed type int dword_806B2D4;
// 806B338: using guessed type int dword_806B338;
// 806B360: using guessed type int dword_806B360;
// 806B440: using guessed type int dword_806B440;

//----- (0804DD88) --------------------------------------------------------
unsigned __int8 *__cdecl sub_804DD88(int a1, int a2)
{
  int v2; // ecx
  int v3; // edx
  int v4; // edx
  void *v5; // eax
  int v6; // eax
  int v7; // eax
  void *v8; // eax
  int v9; // eax
  unsigned __int8 *v11; // [esp+4h] [ebp-10h]
  int v12; // [esp+8h] [ebp-Ch]
  unsigned int v13; // [esp+Ch] [ebp-8h]
  int v14; // [esp+10h] [ebp-4h]

  v11 = *(unsigned __int8 **)a1;
  v3 = *(_DWORD *)(a1 + 4) - 1;
  v13 = v3 + *(_DWORD *)a1;
  v12 = *(_DWORD *)(a2 + 8);
  v14 = *(_DWORD *)(a2 + 12);
  if ( !v14 )
    ++v12;
  if ( dword_806B440 == 128 )
  {
    while ( (unsigned int)v11 < v13 )
    {
      v7 = v12--;
      if ( !v7 )
        break;
      while ( (unsigned int)v11 < v13 && byte_806BE51[(unsigned __int8)sub_804B90F(*v11)] )
        ++v11;
      while ( (unsigned int)v11 < v13 && (unsigned __int8)byte_806BE51[(unsigned __int8)sub_804B90F(*v11)] ^ 1 )
        ++v11;
    }
  }
  else
  {
    dword_806B324 = (int)&loc_804DE3B;
    sub_80614D5(v2, v3);
    do
    {
      while ( (unsigned int)v11 < v13 )
      {
        v4 = (char)*v11;
        if ( v4 == dword_806B440 )
          break;
        ++v11;
      }
      if ( (unsigned int)v11 < v13 )
      {
        if ( !v12 )
        {
          v5 = &loc_804DE37;
          if ( !v14 )
            v5 = &loc_804DE3B;
          dword_806B2AC = (int)v5;
          sub_80617DA(v2, v4);
        }
        ++v11;
      }
      if ( (unsigned int)v11 >= v13 )
        break;
      v6 = v12;
      v4 = v12-- - 1;
    }
    while ( v6 );
  }
  if ( v14 )
  {
    v8 = &loc_804DEF4;
    if ( !*(_BYTE *)(a2 + 25) )
      v8 = &loc_804DF21;
    dword_806B298 = (int)v8;
    sub_806184C(v2);
    while ( (unsigned int)v11 < v13 && byte_806BE51[(unsigned __int8)sub_804B90F(*v11)] )
      ++v11;
    v9 = v13;
    if ( (unsigned int)&v11[v14] <= v13 )
      v9 = (int)&v11[v14];
    v11 = (unsigned __int8 *)v9;
  }
  return v11;
}
// 804DD88: could not find valid save-restore pair for ebx
// 80614D5: using guessed type int __fastcall sub_80614D5(_DWORD, _DWORD);
// 80617DA: using guessed type int __fastcall sub_80617DA(_DWORD, _DWORD);
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD);
// 806B298: using guessed type int dword_806B298;
// 806B2AC: using guessed type int dword_806B2AC;
// 806B324: using guessed type int dword_806B324;
// 806B440: using guessed type int dword_806B440;

//----- (0804DF39) --------------------------------------------------------
int __usercall sub_804DF39@<eax>(int a1@<edx>, int a2@<ecx>, long double a3@<st0>, int a4, FILE *stream, int a6)
{
  void *v6; // eax
  char *v7; // eax
  size_t v8; // eax
  int v9; // ecx
  bool v10; // zf
  void *v11; // eax
  char *v12; // eax
  int v13; // edx
  int v14; // ecx
  void *v15; // eax
  int result; // eax
  char *v17; // eax
  void *v18; // eax
  void *v19; // eax
  int v20; // eax
  int v21; // ecx
  int v22; // edx
  int v23; // ecx
  unsigned int v24; // [esp+8h] [ebp-50h]
  char v25; // [esp+1Bh] [ebp-3Dh]
  int v26; // [esp+1Ch] [ebp-3Ch]
  size_t v27; // [esp+20h] [ebp-38h]
  void *ptr; // [esp+24h] [ebp-34h]
  _DWORD *v29; // [esp+28h] [ebp-30h]
  unsigned int v30; // [esp+2Ch] [ebp-2Ch]
  char *v31; // [esp+30h] [ebp-28h]
  char *v32; // [esp+34h] [ebp-24h]
  int v33; // [esp+38h] [ebp-20h]
  int v34; // [esp+3Ch] [ebp-1Ch]
  int v35; // [esp+40h] [ebp-18h]
  size_t n; // [esp+44h] [ebp-14h]
  size_t v37; // [esp+48h] [ebp-10h]
  void *v38; // [esp+4Ch] [ebp-Ch]

  v33 = dword_806C265;
  v25 = byte_806B3BC;
  v34 = *(_DWORD *)(a4 + 20);
  v27 = dword_806B43C - 18;
  if ( *(_BYTE *)(a4 + 24) )
  {
    dword_806B270 = (int)&loc_804E387;
    sub_8061936(a2, a1);
  }
  v6 = &loc_804DFB7;
  if ( *(_DWORD *)(a4 + 4) == *(_DWORD *)(a4 + 16) )
    v6 = &loc_804DFFF;
  dword_806B34C = (int)v6;
  sub_80613F7(a2);
  memmove(
    *(void **)a4,
    (const void *)(*(_DWORD *)(a4 + 4) - *(_DWORD *)(a4 + 16) + *(_DWORD *)a4),
    *(_DWORD *)(a4 + 16));
  *(_DWORD *)(a4 + 4) = *(_DWORD *)(a4 + 16);
  *(_DWORD *)(a4 + 8) = 0;
  ptr = (void *)(*(_DWORD *)a4 + *(_DWORD *)(a4 + 4));
  v35 = sub_804DBC8((_DWORD *)a4);
  v29 = (_DWORD *)(-16 * *(_DWORD *)(a4 + 8) + v35);
  v30 = v35 - v34 * *(_DWORD *)(a4 + 8) - (_DWORD)ptr;
  if ( *(_DWORD *)(a4 + 8) )
    v7 = (char *)(*v29 + v29[1]);
  else
    v7 = *(char **)a4;
  v31 = v7;
  do
  {
    if ( v34 + 1 >= v30 )
      break;
    n = (v30 - 1) / (v34 + 1);
    v24 = (v30 - 1) / (v34 + 1);
    v8 = fread_unlocked(ptr, 1u, v24, stream);
    v37 = v8;
    v32 = (char *)ptr + v8;
    v30 -= v8;
    v10 = v8 == n;
    v11 = &loc_804E0E3;
    if ( v10 )
      v11 = &loc_804E17A;
    dword_806B388 = (int)v11;
    sub_8061252(v9, ptr);
    if ( ferror_unlocked(stream) )
    {
      v12 = gettext("read failed");
      sub_804BC7A(a3, (int)v12, (char *)a6);
    }
    v10 = feof_unlocked(stream) == 0;
    v15 = &loc_804E135;
    if ( v10 )
      v15 = &loc_804E17A;
    dword_806B234 = (int)v15;
    a3 = sub_8061AC8(v14, v13);
    *(_BYTE *)(a4 + 24) = 1;
    if ( *(char **)a4 == v32 )
      return 0;
    if ( v31 != v32 && *(v32 - 1) != v25 )
    {
      v17 = v32++;
      *v17 = v25;
    }
    v18 = memchr(ptr, v25, v32 - (_BYTE *)ptr);
    v38 = v18;
    v10 = v18 == 0;
    v19 = &loc_804E2B2;
    if ( !v10 )
      v19 = &loc_804E17F;
    dword_806B284 = (int)v19;
    sub_80618C2();
    ptr = v32;
  }
  while ( !*(_BYTE *)(a4 + 24) );
  *(_DWORD *)(a4 + 4) = (char *)ptr - *(_DWORD *)a4;
  v20 = sub_804DBC8((_DWORD *)a4);
  *(_DWORD *)(a4 + 8) = (v20 - (signed int)v29) >> 4;
  if ( *(_DWORD *)(a4 + 8) )
  {
    *(_DWORD *)(a4 + 16) = (_BYTE *)ptr - v31;
    dword_806B43C = v27 + 18;
    result = 1;
  }
  else
  {
    v26 = *(_DWORD *)(a4 + 12) >> 4;
    *(_DWORD *)a4 = sub_805E1D4((int)&v26, v21, *(void **)a4, (int)&v26, 16);
    v22 = 16 * v26;
    *(_DWORD *)(a4 + 12) = 16 * v26;
    dword_806B360 = (int)&loc_804DFFF;
    result = sub_806137F(v23, v22);
  }
  return result;
}
// 8061252: using guessed type int __fastcall sub_8061252(_DWORD, _DWORD);
// 806137F: using guessed type int __fastcall sub_806137F(_DWORD, _DWORD);
// 80613F7: using guessed type int __fastcall sub_80613F7(_DWORD);
// 80618C2: using guessed type int sub_80618C2(void);
// 8061936: using guessed type int __fastcall sub_8061936(_DWORD, _DWORD);
// 8061AC8: using guessed type double __fastcall sub_8061AC8(_DWORD, _DWORD);
// 806B234: using guessed type int dword_806B234;
// 806B270: using guessed type int dword_806B270;
// 806B284: using guessed type int dword_806B284;
// 806B34C: using guessed type int dword_806B34C;
// 806B360: using guessed type int dword_806B360;
// 806B388: using guessed type int dword_806B388;
// 806B3BC: using guessed type char byte_806B3BC;
// 806C265: using guessed type int dword_806C265;

//----- (0804E38E) --------------------------------------------------------
int __cdecl sub_804E38E(char **a1)
{
  int v1; // ecx
  int v2; // edx
  char *v3; // eax
  int v4; // edx
  void *v5; // eax
  char *v6; // eax
  unsigned __int8 v8; // [esp+9h] [ebp-7h]
  bool v9; // [esp+Ah] [ebp-6h]
  unsigned __int8 v10; // [esp+Bh] [ebp-5h]
  char *v11; // [esp+Ch] [ebp-4h]

  v11 = *a1;
  v8 = 0;
  v9 = 0;
  while ( 1 )
  {
    v3 = v11++;
    v10 = *v3;
    if ( (unsigned int)v10 - 48 > 9 )
      break;
    if ( v8 < v10 )
      v8 = v10;
    v2 = *v11;
    v9 = v2 == dword_806BE35;
    if ( v2 == dword_806BE35 )
      ++v11;
  }
  if ( v9 )
  {
    v4 = (int)(v11 - 2);
    *a1 = v11 - 2;
    dword_806B234 = (int)&locret_804E47F;
    sub_8061AC8(v1, v4);
  }
  v5 = &loc_804E443;
  if ( v10 != dword_806BE31 )
    v5 = &loc_804E470;
  dword_806B2FC = (int)v5;
  sub_80615DC();
  while ( 1 )
  {
    v6 = v11++;
    v10 = *v6;
    if ( (unsigned int)v10 - 48 > 9 )
      break;
    if ( v8 < v10 )
      v8 = v10;
  }
  *a1 = v11 - 1;
  return v8;
}
// 80615DC: using guessed type int sub_80615DC(void);
// 8061AC8: using guessed type double __fastcall sub_8061AC8(_DWORD, _DWORD);
// 806B234: using guessed type int dword_806B234;
// 806B2FC: using guessed type int dword_806B2FC;
// 806BE31: using guessed type int dword_806BE31;
// 806BE35: using guessed type int dword_806BE35;

//----- (0804E481) --------------------------------------------------------
int __cdecl sub_804E481(_BYTE *a1)
{
  int result; // eax
  bool v2; // [esp+9h] [ebp-Bh]
  unsigned __int8 *v3; // [esp+Ch] [ebp-8h]
  int v4; // [esp+10h] [ebp-4h]

  v2 = *a1 == 45;
  v3 = &a1[v2];
  if ( (unsigned __int8)sub_804E38E((char **)&v3) <= 0x30u )
    return 0;
  v4 = byte_80634B0[*v3];
  if ( v2 )
    result = -v4;
  else
    result = v4;
  return result;
}

//----- (0804E4E8) --------------------------------------------------------
int __usercall sub_804E4E8@<eax>(double st7_0@<st0>, int ecx0@<ecx>, unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v4; // ebx
  int v5; // eax
  int v6; // ecx
  int result; // eax

  dword_806B34C = (int)&loc_804E50A;
  sub_80613F7(ecx0);
  do
    ++a1;
  while ( byte_806BE51[(unsigned __int8)sub_804B90F(*a1)] );
  while ( byte_806BE51[(unsigned __int8)sub_804B90F(*a2)] )
    ++a2;
  v4 = sub_804E481(a1);
  v5 = sub_804E481(a2);
  if ( v4 == v5 )
    result = sub_805DA4C(dword_806BE35, v6, st7_0, a1, a2, dword_806BE31, dword_806BE35);
  else
    result = v4 - v5;
  return result;
}
// 80613F7: using guessed type int __fastcall sub_80613F7(_DWORD);
// 806B34C: using guessed type int dword_806B34C;
// 806BE31: using guessed type int dword_806BE31;
// 806BE35: using guessed type int dword_806BE35;

//----- (0804E5A3) --------------------------------------------------------
int __usercall sub_804E5A3@<eax>(double st7_0@<st0>, unsigned __int8 *a1, unsigned __int8 *a2)
{
  bool v3; // zf
  void *v4; // eax
  int v5; // ecx

  v3 = byte_806BE51[(unsigned __int8)sub_804B90F(*a1)] == 0;
  v4 = &loc_804E5E7;
  if ( !v3 )
    v4 = &loc_804E5AB;
  dword_806B25C = (int)v4;
  sub_80619C7(st7_0);
  while ( byte_806BE51[(unsigned __int8)sub_804B90F(*a2)] )
    ++a2;
  return sub_805DA4C(dword_806BE35, v5, st7_0, a1, a2, dword_806BE31, dword_806BE35);
}
// 80619C7: using guessed type int __usercall sub_80619C7@<eax>(double@<st0>);
// 806B25C: using guessed type int dword_806B25C;
// 806BE31: using guessed type int dword_806BE31;
// 806BE35: using guessed type int dword_806BE35;

//----- (0804E633) --------------------------------------------------------
int __cdecl sub_804E633(int a1, int a2)
{
  _TBYTE s; // [esp+10h] [ebp-28h]
  _TBYTE s2; // [esp+20h] [ebp-18h]

  memset(&s, 0, 0xCu);
  *(long double *)&s = strtold(a1, 0);
  memset(&s2, 0, 0xCu);
  *(long double *)&s2 = strtold(a2, 0);
  return memcmp(&s, &s2, 0xCu);
}
// 80498F0: using guessed type double __cdecl strtold(_DWORD, _DWORD);

//----- (0804E6B7) --------------------------------------------------------
signed int __cdecl sub_804E6B7(int a1, int a2)
{
  int v2; // edx
  int v3; // ecx
  signed int result; // eax
  int v5; // [esp+18h] [ebp-30h]
  int v6; // [esp+1Ch] [ebp-2Ch]
  long double v7; // [esp+20h] [ebp-28h]
  long double v8; // [esp+30h] [ebp-18h]

  v7 = strtold(a1, &v5);
  v8 = strtold(a2, &v6);
  if ( a1 == v5 )
  {
    dword_806B284 = (int)&locret_804E807;
    sub_80618C2();
  }
  if ( a2 == v6 )
    return 1;
  if ( v8 > v7 )
    return -1;
  if ( v7 > v8 )
  {
    dword_806B2D4 = (int)&locret_804E807;
    sub_80616F8(v3, v2);
  }
  if ( v8 == v7 )
    result = 0;
  else
    result = -1;
  return result;
}
// 80498F0: using guessed type double __cdecl strtold(_DWORD, _DWORD);
// 806137F: using guessed type int __fastcall sub_806137F(_DWORD, _DWORD);
// 80615DC: using guessed type int sub_80615DC(void);
// 80616F8: using guessed type int __fastcall sub_80616F8(_DWORD, _DWORD);
// 80618C2: using guessed type int sub_80618C2(void);
// 806B284: using guessed type int dword_806B284;
// 806B2D4: using guessed type int dword_806B2D4;
// 806B2FC: using guessed type int dword_806B2FC;
// 806B360: using guessed type int dword_806B360;

//----- (0804E809) --------------------------------------------------------
int __cdecl sub_804E809(unsigned __int8 *a1, unsigned __int8 **a2)
{
  unsigned __int8 v3; // al
  unsigned __int8 v4; // bl
  unsigned __int8 v5; // al
  unsigned __int8 v6; // bl
  unsigned int v7; // [esp+10h] [ebp-18h]
  unsigned int v8; // [esp+14h] [ebp-14h]
  unsigned __int8 *v9; // [esp+18h] [ebp-10h]
  unsigned __int8 *i; // [esp+1Ch] [ebp-Ch]
  unsigned int v11; // [esp+20h] [ebp-8h]

  v7 = 0;
  v8 = 12;
  while ( byte_806BE51[(unsigned __int8)sub_804B90F(*a1)] )
    ++a1;
  while ( 2 )
  {
    v11 = (v7 + v8) >> 1;
    v9 = a1;
    for ( i = (unsigned __int8 *)(&off_806B3DC)[2 * v11]; ; ++i )
    {
      if ( !*i )
      {
        if ( a2 )
          *a2 = v9;
        return dword_806B3E0[2 * v11];
      }
      v3 = sub_804B90F(*v9);
      v4 = sub_804B90F(byte_806C151[v3]);
      if ( v4 < (unsigned __int8)sub_804B90F(*i) )
      {
        v8 = (v7 + v8) >> 1;
        goto LABEL_14;
      }
      v5 = sub_804B90F(*v9);
      v6 = sub_804B90F(byte_806C151[v5]);
      if ( v6 > (unsigned __int8)sub_804B90F(*i) )
        break;
      ++v9;
    }
    v7 = v11 + 1;
LABEL_14:
    if ( v7 < v8 )
      continue;
    return 0;
  }
}
// 806B3DC: using guessed type char *off_806B3DC;
// 806B3E0: using guessed type int dword_806B3E0[];

//----- (0804E93B) --------------------------------------------------------
unsigned int __usercall sub_804E93B@<eax>(long double a1@<st0>, char *a2)
{
  char *v2; // eax
  char *v3; // eax
  int v4; // edx
  int v5; // ecx
  _DWORD *v7; // [esp+18h] [ebp-20h]
  char ptr; // [esp+1Ch] [ebp-1Ch]
  unsigned int v9; // [esp+2Ch] [ebp-Ch]

  v9 = __readgsdword(0x14u);
  v7 = sub_805C050(*(double *)&a1, (int)a2, 0x10u);
  if ( !v7 )
  {
    v2 = gettext("open failed");
    sub_804BC7A(a1, (int)v2, a2);
  }
  sub_805C35C((int)v7, &ptr, 0x10u);
  if ( sub_805C3A4(*(double *)&a1, v7) )
  {
    v3 = gettext("close failed");
    sub_804BC7A(a1, (int)v3, a2);
  }
  sub_8056063(&unk_806C311);
  sub_8056417(v4, v5, &ptr, 0x10u, (int)&unk_806C311);
  return __readgsdword(0x14u) ^ v9;
}

//----- (0804EA07) --------------------------------------------------------
size_t __usercall sub_804EA07@<eax>(long double a1@<st0>, char *dest, char *src, size_t n)
{
  char *v4; // ebx
  int *v5; // eax
  char *v6; // eax
  void *v7; // ebx
  char *v8; // eax
  size_t v10; // [esp+1Ch] [ebp-Ch]

  *__errno_location() = 0;
  v10 = strxfrm(dest, src, n);
  if ( *__errno_location() )
  {
    v4 = gettext("string transformation failed");
    v5 = __errno_location();
    error(0, *v5, v4);
    v6 = gettext("set LC_ALL='C' to work around the problem");
    error(0, 0, v6);
    v7 = sub_805B967(a1, 0, 8, src);
    v8 = gettext("the untransformed string was %s");
    error(2, 0, v8, v7);
  }
  return v10;
}

//----- (0804EADF) --------------------------------------------------------
void __usercall __noreturn sub_804EADF(long double a1@<st0>, int a2, size_t a3, int a4, size_t a5)
{
  void *v5; // eax
  int v6; // ecx
  size_t v7; // eax
  void *v8; // eax
  bool v9; // zf
  void *v10; // eax
  size_t v11; // eax
  void *v12; // eax
  size_t v13; // edx
  int v14; // edx
  int v15; // ecx
  int v16; // edx
  size_t v17; // eax
  size_t v18; // eax
  int v19; // ecx
  size_t v20; // eax
  int v21; // edx
  int v22; // ecx
  int v23; // eax
  size_t v24; // eax
  int v25; // edx
  int v26; // ecx
  int (*v27)(); // eax
  char *s; // [esp+18h] [ebp-1150h]
  char *src; // [esp+1Ch] [ebp-114Ch]
  bool v30; // [esp+2Bh] [ebp-113Dh]
  int v31; // [esp+2Ch] [ebp-113Ch]
  char *dest; // [esp+30h] [ebp-1138h]
  size_t size; // [esp+34h] [ebp-1134h]
  void *ptr; // [esp+38h] [ebp-1130h]
  int v35; // [esp+3Ch] [ebp-112Ch]
  char *v36; // [esp+40h] [ebp-1128h]
  char *v37; // [esp+44h] [ebp-1124h]
  size_t v38; // [esp+48h] [ebp-1120h]
  size_t n; // [esp+4Ch] [ebp-111Ch]
  size_t v40; // [esp+50h] [ebp-1118h]
  char s1; // [esp+54h] [ebp-1114h]
  int v42; // [esp+64h] [ebp-1104h]
  int v43; // [esp+74h] [ebp-10F4h]
  char v44; // [esp+110h] [ebp-1058h]
  char v45; // [esp+1ACh] [ebp-FBCh]
  unsigned int v46; // [esp+114Ch] [ebp-1Ch]
  size_t v47; // [esp+1174h] [ebp+Ch]
  size_t v48; // [esp+117Ch] [ebp+14h]

  src = (char *)a2;
  s = (char *)a4;
  v46 = __readgsdword(0x14u);
  v31 = 0;
  dest = &v45;
  size = 4000;
  ptr = 0;
  qmemcpy(&v44, &unk_806C311, 0x9Cu);
  qmemcpy(&v43, &v44, 0x9Cu);
  v5 = &loc_804EB87;
  if ( !byte_806BE39 )
    v5 = &loc_804EFCC;
  dword_806B324 = (int)v5;
  sub_80614D5(0, &v43);
  v36 = &src[a3];
  v37 = &s[a5];
  while ( 1 )
  {
    v38 = 3 * (a5 + a3) + 2;
    if ( size < v38 )
    {
      v7 = v38;
      if ( 3 * size >> 1 >= v38 )
        v7 = 3 * size >> 1;
      size = v7;
      free(ptr);
      v8 = malloc(size);
      ptr = v8;
      dest = (char *)v8;
      v9 = v8 == 0;
      v10 = &loc_804EC43;
      if ( !v9 )
        v10 = &loc_804EC59;
      dword_806B220 = (int)v10;
      sub_8061B42();
      dest = &v45;
      size = 4000;
    }
    if ( src >= v36 )
      v11 = 0;
    else
      v11 = sub_804EA07(a1, dest, src, size) + 1;
    n = v11;
    v30 = v11 <= size;
    if ( s < v37 )
    {
      if ( v30 )
      {
        dword_806B2D4 = (int)&loc_804ECF3;
        sub_80616F8(v6, size - n);
      }
      v12 = &loc_804ED15;
      if ( !v30 )
        v12 = &loc_804ED25;
      dword_806B2AC = (int)v12;
      sub_80617DA(v6, 0);
      sub_804EA07(a1, &dest[n], s, v13);
      dword_806B234 = (int)&loc_804ED5F;
      a1 = sub_8061AC8(v15, v14);
    }
    v40 = 0;
    if ( v30 != 1 || (v16 = n, n + v40 > size) )
    {
      size = n + v40;
      if ( n + v40 <= 0x55555554 )
        size = 3 * size >> 1;
      free(ptr);
      ptr = sub_805E2B0(size);
      dest = (char *)ptr;
      if ( src < v36 )
        strxfrm(dest, src, n);
      if ( s < v37 )
        strxfrm(&dest[n], s, v40);
    }
    if ( src < v36 )
    {
      v17 = strlen(src);
      src += v17 + 1;
    }
    if ( s < v37 )
    {
      v18 = strlen(s);
      s += v18 + 1;
    }
    if ( src >= v36 && s >= v37 )
      break;
    sub_8056417(v16, v6, dest, n, (int)&v43);
    sub_8056417((int)&dest[n], v19, &dest[n], v40, (int)&v44);
    if ( !v31 )
    {
      v20 = n;
      if ( v40 <= n )
        v20 = v40;
      v31 = memcmp(dest, &dest[n], v20);
      if ( !v31 )
        v31 = (n > v40) - (n < v40);
    }
  }
  v47 = n;
  src = dest;
  v48 = v40;
  s = &dest[n];
  sub_8056417((int)dest, v6, dest, n, (int)&v43);
  sub_8056129(*(double *)&a1, &v43, &s1);
  sub_8056417(v21, v22, s, v48, (int)&v44);
  sub_8056129(*(double *)&a1, (int *)&v44, &v42);
  v23 = memcmp(&s1, &v42, 0x10u);
  v35 = v23;
  if ( !v23 )
  {
    if ( !v31 )
    {
      v24 = v47;
      if ( v48 <= v47 )
        v24 = v48;
      v31 = memcmp(src, s, v24);
      if ( !v31 )
        v31 = (v47 > v48) - (v47 < v48);
    }
    v35 = v31;
  }
  free(ptr);
  v27 = (int (*)())&loc_804F11E;
  if ( __readgsdword(0x14u) == v46 )
    v27 = sub_804F123;
  dword_806B2AC = (int)v27;
  sub_80617DA(v26, v25);
}
// 804F123: using guessed type int sub_804F123();
// 80614D5: using guessed type int __fastcall sub_80614D5(_DWORD, _DWORD);
// 80616F8: using guessed type int __fastcall sub_80616F8(_DWORD, _DWORD);
// 80617DA: using guessed type int __fastcall sub_80617DA(_DWORD, _DWORD);
// 8061AC8: using guessed type double __fastcall sub_8061AC8(_DWORD, _DWORD);
// 8061B42: using guessed type int sub_8061B42(void);
// 806B220: using guessed type int dword_806B220;
// 806B234: using guessed type int dword_806B234;
// 806B2AC: using guessed type int dword_806B2AC;
// 806B2D4: using guessed type int dword_806B2D4;
// 806B324: using guessed type int dword_806B324;
// 806BE39: using guessed type char byte_806BE39;

//----- (0804F123) --------------------------------------------------------
#error "804F129: positive sp value has been found (funcsize=0)"

//----- (0804F12E) --------------------------------------------------------
int __cdecl sub_804F12E(char *a1, unsigned int a2)
{
  char *v2; // eax
  int v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_805967C(a1, a2 - (_DWORD)a1, 0);
  while ( (unsigned int)a1 < a2 )
  {
    v2 = a1++;
    v4 += *v2 == 9;
  }
  return v4;
}

//----- (0804F17E) --------------------------------------------------------
int __cdecl sub_804F17E(int a1, int a2)
{
  int v2; // ecx
  int v3; // eax
  int v4; // edx
  void *v5; // eax
  char *v6; // eax

  while ( 1 )
  {
    v3 = a1;
    v4 = a1-- - 1;
    if ( !v3 )
      break;
    putchar_unlocked(32);
  }
  v5 = &loc_804F1BE;
  if ( a2 )
    v5 = &loc_804F1D4;
  dword_806B388 = (int)v5;
  sub_8061252(v2, v4);
  v6 = gettext("^ no match for key\n");
  return printf(v6);
}
// 8061252: using guessed type int __fastcall sub_8061252(_DWORD, _DWORD);
// 806B388: using guessed type int dword_806B388;

//----- (0804F211) --------------------------------------------------------
int __cdecl sub_804F211(_BYTE *a1)
{
  return a1[26] || a1[28] || a1[29];
}

//----- (0804F246) --------------------------------------------------------
int __usercall sub_804F246@<eax>(int a1@<ecx>, double a2@<st0>, int a3, int a4)
{
  void *v4; // eax
  void *v5; // eax
  int v6; // ecx
  void *v7; // eax
  int v8; // edx
  int v9; // ecx
  int v10; // edx
  int v11; // ecx
  void *v12; // eax
  _BOOL4 v13; // eax
  int v14; // edx
  int v15; // ecx
  _BOOL4 v16; // eax
  unsigned __int8 v18; // [esp+11h] [ebp-37h]
  unsigned __int8 *v19; // [esp+14h] [ebp-34h]
  unsigned __int8 *v20; // [esp+18h] [ebp-30h]
  unsigned __int8 *v21; // [esp+1Ch] [ebp-2Ch]
  unsigned __int8 *v22; // [esp+20h] [ebp-28h]
  char *v23; // [esp+24h] [ebp-24h]
  int v24; // [esp+28h] [ebp-20h]
  int v25; // [esp+2Ch] [ebp-1Ch]

  v23 = *(char **)a3;
  v21 = (unsigned __int8 *)v23;
  v22 = (unsigned __int8 *)&v23[*(_DWORD *)(a3 + 4) - 1];
  if ( a4 )
  {
    if ( *(_DWORD *)a4 != -1 )
      v21 = (unsigned __int8 *)sub_804DBE3(a2, a1, (char **)a3, a4);
    v4 = &loc_804F2B8;
    if ( *(_DWORD *)(a4 + 8) == -1 )
      v4 = &loc_804F2CD;
    dword_806B298 = (int)v4;
    sub_806184C(a1);
    v22 = sub_804DD88(a3, a4);
    v5 = &loc_804F2F1;
    if ( !*(_BYTE *)(a4 + 24) )
      v5 = &loc_804F2FB;
    dword_806B25C = (int)v5;
    sub_80619C7(a2);
    if ( *(_DWORD *)a4 == -1 )
      goto LABEL_40;
    v7 = &loc_804F31F;
    if ( *(_BYTE *)(a4 + 30) )
      v7 = &loc_804F332;
    dword_806B298 = (int)v7;
    sub_806184C(v6);
    if ( (unsigned __int8)sub_804F211((_BYTE *)a4) )
    {
LABEL_40:
      v18 = *v22;
      *v22 = 0;
      while ( byte_806BE51[(unsigned __int8)sub_804B90F(*v21)] )
        ++v21;
      v19 = v21;
      if ( v22 >= v21 )
      {
        if ( *(_BYTE *)(a4 + 30) )
        {
          sub_804E809(v21, &v19);
        }
        else
        {
          if ( *(_BYTE *)(a4 + 28) )
          {
            strtold(v21, &v19);
            __asm { fstp    tbyte ptr [ebp+var_18] }
            dword_806B360 = (int)&loc_804F49D;
            sub_806137F(v11, v10);
          }
          v12 = &loc_804F3FC;
          if ( *(_BYTE *)(a4 + 26) )
            v12 = &loc_804F40B;
          dword_806B20C = (int)v12;
          sub_8061BBC(v9, v8);
          if ( *(_BYTE *)(a4 + 29) )
          {
            v13 = v21 < v22 && *v21 == 45;
            v20 = &v21[v13];
            if ( (unsigned __int8)sub_804E38E((char **)&v20) > 0x2Fu )
            {
              v16 = *(_BYTE *)(a4 + 29) && byte_80634B0[*v20];
              v19 = &v20[v16];
              goto LABEL_36;
            }
            dword_806B360 = (int)&loc_804F49D;
            sub_806137F(v15, v14);
          }
          v19 = v22;
        }
      }
      else
      {
        v19 = v22;
      }
LABEL_36:
      *v22 = v18;
      v22 = v19;
      goto LABEL_37;
    }
  }
LABEL_37:
  v24 = sub_804F12E(v23, (unsigned int)v21);
  v25 = sub_804F12E((char *)v21, (unsigned int)v22);
  return sub_804F17E(v24, v25);
}
// 804F3BE: inconsistent fpu stack
// 804F246: could not find valid save-restore pair for ebx
// 80498F0: using guessed type double __cdecl strtold(_DWORD, _DWORD);
// 806137F: using guessed type int __fastcall sub_806137F(_DWORD, _DWORD);
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD);
// 80619C7: using guessed type int __usercall sub_80619C7@<eax>(double@<st0>);
// 8061BBC: using guessed type int __fastcall sub_8061BBC(_DWORD, _DWORD);
// 806B20C: using guessed type int dword_806B20C;
// 806B25C: using guessed type int dword_806B25C;
// 806B298: using guessed type int dword_806B298;
// 806B360: using guessed type int dword_806B360;

//----- (0804F4EA) --------------------------------------------------------
int __usercall sub_804F4EA@<eax>(int a1@<ecx>, double a2@<st0>, int a3)
{
  void *v3; // eax
  void *v4; // eax
  int result; // eax
  int v6; // [esp+1Ch] [ebp-Ch]

  v6 = dword_806C265;
  while ( 1 )
  {
    sub_804F246(a1, a2, a3, v6);
    v3 = &loc_804F529;
    if ( !v6 )
      v3 = &locret_804F56D;
    dword_806B374 = (int)v3;
    sub_80612DD();
    v6 = *(_DWORD *)(v6 + 36);
    if ( !v6 )
    {
      v4 = &loc_804F55F;
      if ( byte_806C263 == 1 )
        v4 = &locret_804F56D;
      dword_806B298 = (int)v4;
      sub_806184C(a1);
      result = (unsigned __int8)byte_806C262 ^ 1;
      if ( byte_806C262 == 1 )
        break;
    }
  }
  return result;
}
// 804F4EA: could not find valid save-restore pair for ebx
// 80612DD: using guessed type int sub_80612DD(void);
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD);
// 806B298: using guessed type int dword_806B298;
// 806B374: using guessed type int dword_806B374;
// 806C262: using guessed type char byte_806C262;
// 806C263: using guessed type char byte_806C263;
// 806C265: using guessed type int dword_806C265;

//----- (0804F56F) --------------------------------------------------------
int __usercall sub_804F56F@<eax>(int edx0@<edx>, int a2@<ecx>, int a1)
{
  void *v3; // eax
  int v4; // ecx
  void *v5; // eax
  char v6; // al

  if ( *(_DWORD *)(a1 + 16) || *(_DWORD *)(a1 + 20) )
    goto LABEL_16;
  v3 = &loc_804F5B8;
  if ( *(_BYTE *)(a1 + 24) == 1 )
    v3 = &loc_804F622;
  dword_806B2E8 = (int)v3;
  sub_8061650(a2, edx0);
  if ( *(_BYTE *)(a1 + 25) == 1 || !((unsigned __int8)sub_804F211((_BYTE *)a1) ^ 1) || *(_BYTE *)(a1 + 30) == 1 )
    goto LABEL_16;
  v5 = &loc_804F60D;
  if ( *(_BYTE *)(a1 + 32) == 1 )
    v5 = &loc_804F622;
  dword_806B34C = (int)v5;
  sub_80613F7(v4);
  if ( *(_BYTE *)(a1 + 27) == 1 )
LABEL_16:
    v6 = 0;
  else
    v6 = 1;
  return v6 & 1;
}
// 804F56F: could not find valid save-restore pair for ebx
// 80613F7: using guessed type int __fastcall sub_80613F7(_DWORD);
// 8061650: using guessed type int __fastcall sub_8061650(_DWORD, _DWORD);
// 806B2E8: using guessed type int dword_806B2E8;
// 806B34C: using guessed type int dword_806B34C;

//----- (0804F62C) --------------------------------------------------------
_BYTE *__cdecl sub_804F62C(int a1, _BYTE *a2)
{
  int v2; // ecx
  void *v3; // eax
  _BYTE *v4; // eax
  _BYTE *v5; // edx
  _BYTE *v6; // eax
  _BYTE *v7; // eax
  void *v8; // eax
  _BYTE *v9; // eax
  _BYTE *v10; // eax
  _BYTE *v11; // eax
  _BYTE *v12; // eax
  _BYTE *v13; // eax
  _BYTE *v14; // eax
  _BYTE *v15; // eax
  _BYTE *v16; // eax
  _BYTE *result; // eax
  _BYTE *v18; // [esp+Ch] [ebp+Ch]
  _BYTE *v19; // [esp+Ch] [ebp+Ch]

  if ( !*(_BYTE *)(a1 + 24) )
  {
    v3 = &loc_804F65E;
    if ( !*(_BYTE *)(a1 + 25) )
      v3 = &loc_804F66A;
    dword_806B374 = (int)v3;
    sub_80612DD();
  }
  v4 = a2;
  v5 = a2 + 1;
  v18 = a2 + 1;
  *v4 = 98;
  if ( *(_UNKNOWN **)(a1 + 16) == &unk_806C051 )
  {
    v6 = v18;
    v5 = v18++ + 1;
    *v6 = 100;
  }
  if ( *(_DWORD *)(a1 + 20) )
  {
    v7 = v18;
    v5 = v18++ + 1;
    *v7 = 102;
  }
  v8 = &loc_804F6BD;
  if ( !*(_BYTE *)(a1 + 28) )
    v8 = &loc_804F6C9;
  dword_806B324 = (int)v8;
  sub_80614D5(v2, v5);
  v9 = v18;
  v19 = v18 + 1;
  *v9 = 103;
  if ( *(_BYTE *)(a1 + 29) )
  {
    v10 = v19++;
    *v10 = 104;
  }
  if ( *(_UNKNOWN **)(a1 + 16) == &unk_806BF51 )
  {
    v11 = v19++;
    *v11 = 105;
  }
  if ( *(_BYTE *)(a1 + 30) )
  {
    v12 = v19++;
    *v12 = 77;
  }
  if ( *(_BYTE *)(a1 + 26) )
  {
    v13 = v19++;
    *v13 = 110;
  }
  if ( *(_BYTE *)(a1 + 27) )
  {
    v14 = v19++;
    *v14 = 82;
  }
  if ( *(_BYTE *)(a1 + 31) )
  {
    v15 = v19++;
    *v15 = 114;
  }
  if ( *(_BYTE *)(a1 + 32) )
  {
    v16 = v19++;
    *v16 = 86;
  }
  result = v19;
  *v19 = 0;
  return result;
}
// 804F62C: could not find valid save-restore pair for ebx
// 80612DD: using guessed type int sub_80612DD(void);
// 80614D5: using guessed type int __fastcall sub_80614D5(_DWORD, _DWORD);
// 806B324: using guessed type int dword_806B324;
// 806B374: using guessed type int dword_806B374;

//----- (0804F774) --------------------------------------------------------
unsigned int __usercall sub_804F774@<eax>(long double a1@<st0>, int ecx0@<ecx>, int *a2, char a3)
{
  int v4; // edx
  int v5; // eax
  int v6; // eax
  const char *v7; // edx
  int v8; // eax
  const char *v9; // eax
  void *v10; // esi
  char *v11; // ebx
  char *v12; // eax
  bool v13; // al
  char *v14; // eax
  int v15; // ecx
  bool v16; // al
  void *v17; // eax
  int v18; // edx
  void *v19; // eax
  void *v20; // eax
  char *v21; // eax
  char *v22; // eax
  void *v23; // eax
  void *v24; // eax
  int v25; // edx
  int v26; // ecx
  void *v27; // eax
  int v28; // edx
  int v29; // ecx
  void *v30; // eax
  void *v31; // eax
  size_t v32; // eax
  int v33; // eax
  char *v34; // eax
  void *v35; // eax
  char *v36; // eax
  __int64 v38; // [esp+0h] [ebp-C8h]
  char *v39; // [esp+Ch] [ebp-BCh]
  void *v40; // [esp+10h] [ebp-B8h]
  char v41; // [esp+18h] [ebp-B0h]
  int *v42; // [esp+1Ch] [ebp-ACh]
  bool v43; // [esp+20h] [ebp-A8h]
  bool v44; // [esp+21h] [ebp-A7h]
  char v45; // [esp+22h] [ebp-A6h]
  char v46; // [esp+23h] [ebp-A5h]
  int v47; // [esp+24h] [ebp-A4h]
  char *v48; // [esp+28h] [ebp-A0h]
  unsigned int v49; // [esp+2Ch] [ebp-9Ch]
  unsigned int v50; // [esp+30h] [ebp-98h]
  int v51; // [esp+34h] [ebp-94h]
  char *v52; // [esp+38h] [ebp-90h]
  char *v53; // [esp+3Ch] [ebp-8Ch]
  unsigned int v54; // [esp+40h] [ebp-88h]
  int v55; // [esp+44h] [ebp-84h]
  int v56; // [esp+48h] [ebp-80h]
  int v57; // [esp+4Ch] [ebp-7Ch]
  int v58; // [esp+50h] [ebp-78h]
  int v59; // [esp+54h] [ebp-74h]
  int v60; // [esp+58h] [ebp-70h]
  int v61; // [esp+5Ch] [ebp-6Ch]
  int v62; // [esp+60h] [ebp-68h]
  int v63; // [esp+64h] [ebp-64h]
  int v64; // [esp+68h] [ebp-60h]
  char v65; // [esp+6Eh] [ebp-5Ah]
  char v66; // [esp+83h] [ebp-45h]
  char s; // [esp+9Dh] [ebp-2Bh]
  unsigned int v68; // [esp+BCh] [ebp-Ch]

  v42 = a2;
  v41 = a3;
  v68 = __readgsdword(0x14u);
  v55 = *a2;
  v56 = a2[1];
  v57 = a2[2];
  v58 = a2[3];
  v59 = a2[4];
  v60 = a2[5];
  v61 = a2[6];
  v62 = a2[7];
  v4 = a2[8];
  v63 = a2[8];
  v64 = a2[9];
  v48 = (char *)1;
  v47 = dword_806C265;
  while ( v47 )
  {
    if ( *(_BYTE *)(v47 + 33) )
    {
      v49 = *(_DWORD *)v47;
      v51 = *(_DWORD *)(v47 + 8);
      v52 = &v66;
      v53 = &s;
      if ( v49 == -1 )
        v49 = 0;
      v5 = sub_80595C9(v49, (int)&v65);
      *(_WORD *)v52 = 43;
      v52 = (char *)stpcpy(v52 + 1, v5);
      v38 = v49 + 1;
      v6 = sub_80595C9(v38, (int)&v65);
      *(_DWORD *)v53 = 2124589;
      v53 = (char *)stpcpy(v53 + 3, v6);
      if ( *(_DWORD *)(v47 + 8) != -1 )
      {
        v38 = (unsigned int)(v51 + 1);
        v7 = (const char *)sub_80595C9(v38, (int)&v65);
        v8 = (int)v52;
        *(_WORD *)v52 = 11552;
        *(_BYTE *)(v8 + 2) = 0;
        strcpy(v52 + 2, v7);
        v9 = (const char *)sub_80595C9((unsigned int)(*(_DWORD *)(v47 + 12) == -1) + v51 + 1, (int)&v65);
        *(_WORD *)v53 = 44;
        strcpy(v53 + 1, v9);
      }
      v10 = sub_805BD53(a1, 1, &s);
      v11 = (char *)sub_805BD53(a1, 0, &v66);
      v12 = gettext("obsolescent key %s used; consider %s instead");
      v40 = v10;
      v39 = v11;
      error(0, 0, v12, v11, v10);
    }
    v13 = *(_DWORD *)v47 != -1 && *(_DWORD *)(v47 + 8) < *(_DWORD *)v47;
    v43 = v13;
    if ( v13 )
    {
      v14 = gettext("key %lu has zero width and will be ignored");
      v39 = v48;
      error(0, 0, v14, v48);
    }
    v16 = (unsigned __int8)sub_804F211((_BYTE *)v47) || *(_BYTE *)(v47 + 30);
    v44 = v16;
    if ( !*(_DWORD *)(v47 + 8) && *(_DWORD *)(v47 + 12) )
    {
      dword_806B25C = (int)&loc_804FAC1;
      sub_80619C7(*(double *)&a1);
    }
    v45 = 0;
    if ( v43 != 1 && v41 != 1 )
    {
      v17 = &loc_804FB17;
      if ( dword_806B440 != 128 )
        v17 = &loc_804FBE4;
      dword_806B2C0 = (int)v17;
      sub_8061764(v15);
      if ( v45 != 1 )
      {
        v19 = &loc_804FB53;
        if ( *(_BYTE *)(v47 + 24) == 1 )
          v19 = &loc_804FB7A;
        dword_806B270 = (int)v19;
        sub_8061936(v15, v18);
        v20 = &loc_804FB7A;
        if ( v44 != 1 )
          v20 = &loc_804FBB6;
        dword_806B374 = (int)v20;
        sub_80612DD();
        if ( *(_BYTE *)(v47 + 24) != 1 && *(_DWORD *)(v47 + 4) || *(_BYTE *)(v47 + 25) != 1 && *(_DWORD *)(v47 + 12) )
        {
          v21 = gettext("leading blanks are significant in key %lu; consider also specifying 'b'");
          v39 = v48;
          error(0, 0, v21, v48);
        }
      }
    }
    if ( v41 != 1 && (unsigned __int8)sub_804F211((_BYTE *)v47) )
    {
      v50 = *(_DWORD *)v47 + 1;
      v54 = *(_DWORD *)(v47 + 8) + 1;
      if ( !v50 )
        v50 = 1;
      if ( !v54 || v50 < v54 )
      {
        v22 = gettext("key %lu is numeric and spans multiple fields");
        v39 = v48;
        error(0, 0, v22, v48);
      }
    }
    if ( v59 )
    {
      v23 = &loc_804FCB0;
      if ( v59 != *(_DWORD *)(v47 + 16) )
        v23 = &loc_804FCB7;
      dword_806B2E8 = (int)v23;
      sub_8061650(v15, v59);
      v59 = 0;
    }
    v24 = &loc_804FCD7;
    if ( !v60 )
      v24 = &loc_804FCEE;
    dword_806B34C = (int)v24;
    sub_80613F7(v15);
    if ( v60 == *(_DWORD *)(v47 + 20) )
      v60 = 0;
    LOBYTE(v61) = (unsigned __int8)(v61 & (*(_BYTE *)(v47 + 24) ^ 1)) != 0;
    BYTE1(v61) = (BYTE1(v61) & (*(_BYTE *)(v47 + 25) ^ 1)) != 0;
    BYTE2(v62) = (BYTE2(v62) & (*(_BYTE *)(v47 + 30) ^ 1)) != 0;
    BYTE2(v61) = (BYTE2(v61) & (*(_BYTE *)(v47 + 26) ^ 1)) != 0;
    LOBYTE(v62) = (unsigned __int8)(v62 & (*(_BYTE *)(v47 + 28) ^ 1)) != 0;
    BYTE1(v62) = (BYTE1(v62) & (*(_BYTE *)(v47 + 29) ^ 1)) != 0;
    HIBYTE(v61) = (HIBYTE(v61) & (*(_BYTE *)(v47 + 27) ^ 1)) != 0;
    LOBYTE(v63) = (unsigned __int8)(v63 & (*(_BYTE *)(v47 + 32) ^ 1)) != 0;
    v4 = HIBYTE(v62);
    HIBYTE(v62) = (HIBYTE(v62) & (*(_BYTE *)(v47 + 31) ^ 1)) != 0;
    v47 = *(_DWORD *)(v47 + 36);
    ++v48;
  }
  if ( (unsigned __int8)sub_804F56F(v4, ecx0, (int)&v55) ^ 1 )
    goto LABEL_74;
  v27 = &loc_804FE70;
  if ( !HIBYTE(v62) )
    v27 = &loc_804FF61;
  dword_806B360 = (int)v27;
  sub_806137F(v26, v25);
  if ( !byte_806C262 )
  {
    v30 = &loc_804FE9F;
    if ( !byte_806C263 )
      v30 = &loc_804FF61;
    dword_806B388 = (int)v30;
    sub_8061252(v29, v28);
  }
  if ( dword_806C265 )
  {
LABEL_74:
    v46 = HIBYTE(v62);
    if ( byte_806C262 != 1 )
    {
      v31 = &loc_804FEEB;
      if ( byte_806C263 == 1 )
        v31 = &loc_804FEEF;
      dword_806B284 = (int)v31;
      sub_80618C2();
      HIBYTE(v62) = 0;
    }
    sub_804F62C((int)&v55, &s);
    v32 = strlen(&s);
    v33 = sub_804B960(v32);
    v34 = ngettext("option '-%s' is ignored", "options '-%s' are ignored", v33);
    v39 = &s;
    error(0, 0, v34, &s);
    HIBYTE(v62) = v46;
  }
  if ( HIBYTE(v62) && byte_806C262 != 1 && byte_806C263 != 1 )
  {
    v35 = &loc_804FFA7;
    if ( !dword_806C265 )
      v35 = &loc_804FFCB;
    dword_806B388 = (int)v35;
    sub_8061252(v29, v28);
    v36 = gettext("option '-r' only applies to last-resort comparison");
    error(0, 0, v36);
  }
  return __readgsdword(0x14u) ^ v68;
}
// 8049930: using guessed type int __cdecl stpcpy(_DWORD, _DWORD);
// 8061252: using guessed type int __fastcall sub_8061252(_DWORD, _DWORD);
// 80612DD: using guessed type int sub_80612DD(void);
// 806137F: using guessed type int __fastcall sub_806137F(_DWORD, _DWORD);
// 80613F7: using guessed type int __fastcall sub_80613F7(_DWORD);
// 8061650: using guessed type int __fastcall sub_8061650(_DWORD, _DWORD);
// 8061764: using guessed type int __fastcall sub_8061764(_DWORD);
// 80618C2: using guessed type int sub_80618C2(void);
// 8061936: using guessed type int __fastcall sub_8061936(_DWORD, _DWORD);
// 80619C7: using guessed type int __usercall sub_80619C7@<eax>(double@<st0>);
// 806B25C: using guessed type int dword_806B25C;
// 806B270: using guessed type int dword_806B270;
// 806B284: using guessed type int dword_806B284;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B2E8: using guessed type int dword_806B2E8;
// 806B34C: using guessed type int dword_806B34C;
// 806B360: using guessed type int dword_806B360;
// 806B374: using guessed type int dword_806B374;
// 806B388: using guessed type int dword_806B388;
// 806B440: using guessed type int dword_806B440;
// 806C262: using guessed type char byte_806C262;
// 806C263: using guessed type char byte_806C263;
// 806C265: using guessed type int dword_806C265;

//----- (0804FFE6) --------------------------------------------------------
int __cdecl sub_804FFE6(int a1, int a2)
{
  int v2; // ecx
  void *v3; // eax
  _BYTE *v4; // eax
  int v5; // edx
  void *v6; // eax
  int v7; // edx
  int v8; // ecx
  void *v9; // eax
  int v10; // ecx
  long double v11; // fst7
  int v12; // ecx
  unsigned __int8 v13; // al
  size_t v14; // eax
  char *v15; // ebx
  unsigned __int8 v16; // al
  char v17; // al
  char *v18; // edx
  unsigned __int8 v19; // al
  size_t v20; // eax
  char *v21; // ebx
  unsigned __int8 v22; // al
  int v23; // eax
  void *v24; // edx
  void *v25; // eax
  int v26; // edx
  int v27; // ecx
  int v28; // ebx
  void *v29; // eax
  char *v30; // edx
  unsigned __int8 v31; // al
  int v32; // ecx
  int v33; // edx
  bool v34; // zf
  void *v35; // eax
  unsigned __int8 v36; // al
  int v37; // ebx
  unsigned __int8 v38; // al
  int v39; // ecx
  int v40; // ebx
  unsigned __int8 v41; // al
  int v42; // ecx
  void *v43; // eax
  void *v44; // eax
  void *v45; // eax
  int result; // eax
  int v47; // [esp+0h] [ebp-1018h]
  int v48; // [esp+18h] [ebp-1000h]
  int v49; // [esp+1Ch] [ebp-FFCh]
  char v50; // [esp+26h] [ebp-FF2h]
  char v51; // [esp+27h] [ebp-FF1h]
  _BYTE *v52; // [esp+28h] [ebp-FF0h]
  void *s1; // [esp+2Ch] [ebp-FECh]
  void *s2; // [esp+30h] [ebp-FE8h]
  unsigned int v55; // [esp+34h] [ebp-FE4h]
  unsigned int v56; // [esp+38h] [ebp-FE0h]
  int v57; // [esp+3Ch] [ebp-FDCh]
  char *v58; // [esp+40h] [ebp-FD8h]
  char *v59; // [esp+44h] [ebp-FD4h]
  size_t v60; // [esp+48h] [ebp-FD0h]
  size_t v61; // [esp+4Ch] [ebp-FCCh]
  void *ptr; // [esp+50h] [ebp-FC8h]
  size_t v63; // [esp+54h] [ebp-FC4h]
  int v64; // [esp+58h] [ebp-FC0h]
  int v65; // [esp+5Ch] [ebp-FBCh]
  size_t v66; // [esp+60h] [ebp-FB8h]
  size_t n; // [esp+64h] [ebp-FB4h]
  size_t size; // [esp+68h] [ebp-FB0h]
  char v69; // [esp+6Ch] [ebp-FACh]
  unsigned int v70; // [esp+100Ch] [ebp-Ch]

  v49 = a1;
  v48 = a2;
  v70 = __readgsdword(0x14u);
  v52 = (_BYTE *)dword_806C265;
  s1 = *(void **)(a1 + 8);
  s2 = *(void **)(a2 + 8);
  v55 = *(_DWORD *)(a1 + 12);
  v56 = *(_DWORD *)(a2 + 12);
  v64 = *(_DWORD *)(dword_806C265 + 20);
  v65 = *(_DWORD *)(dword_806C265 + 16);
  v3 = s1;
  if ( v55 >= (unsigned int)s1 )
    v3 = (void *)v55;
  v55 = (unsigned int)v3;
  v4 = s2;
  if ( v56 >= (unsigned int)s2 )
    v4 = (_BYTE *)v56;
  v56 = (unsigned int)v4;
  v66 = v55 - (_DWORD)s1;
  v5 = v4 - (_BYTE *)s2;
  n = v4 - (_BYTE *)s2;
  v6 = &loc_80500F4;
  if ( byte_806BE39 )
    v6 = &loc_8050134;
  dword_806B360 = (int)v6;
  sub_806137F(v2, v5);
  if ( (unsigned __int8)sub_804F211(v52) || v52[30] || v52[27] || v52[32] )
  {
    v9 = &loc_8050156;
    if ( v65 )
      v9 = &loc_8050163;
    dword_806B234 = (int)v9;
    v11 = sub_8061AC8(v8, v7);
    if ( v64 )
    {
      size = v66 + n + 2;
      if ( size <= 0xFA0 )
      {
        v58 = &v69;
        ptr = 0;
        dword_806B2FC = (int)&loc_80501D3;
        sub_80615DC();
      }
      ptr = sub_805E2B0(size);
      v58 = (char *)ptr;
      v59 = (char *)ptr + v66 + 1;
      v63 = 0;
      v60 = 0;
      while ( v63 < v66 )
      {
        if ( !v65 || (v47 = *((char *)s1 + v63), v13 = sub_804B90F(v47), *(_BYTE *)(v13 + v65) ^ 1) )
        {
          v14 = v60++;
          v15 = &v58[v14];
          if ( v64 )
          {
            v47 = *((char *)s1 + v63);
            v16 = sub_804B90F(v47);
            v17 = *(_BYTE *)(v16 + v64);
          }
          else
          {
            v17 = *((_BYTE *)s1 + v63);
          }
          *v15 = v17;
        }
        ++v63;
      }
      v18 = v58;
      v58[v60] = 0;
      v63 = 0;
      v61 = 0;
      dword_806B270 = (int)&loc_80503AC;
      sub_8061936(v12, v18);
      do
      {
        if ( !v65 || (v47 = *((char *)s2 + v63), v19 = sub_804B90F(v47), *(_BYTE *)(v19 + v65) ^ 1) )
        {
          v20 = v61++;
          v21 = &v59[v20];
          if ( v64 )
          {
            v47 = *((char *)s2 + v63);
            v22 = sub_804B90F(v47);
            v23 = *(unsigned __int8 *)(v22 + v64);
            dword_806B220 = (int)&loc_80503A3;
            sub_8061B42();
          }
          *v21 = *((_BYTE *)s2 + v63);
        }
        ++v63;
      }
      while ( v63 < n );
      v24 = v59;
      v59[v61] = 0;
    }
    else
    {
      v58 = (char *)s1;
      v60 = v66;
      v50 = *((_BYTE *)s1 + v66);
      *((_BYTE *)s1 + v66) = 0;
      v59 = (char *)s2;
      v61 = n;
      v51 = *((_BYTE *)s2 + n);
      v24 = s2;
      *((_BYTE *)s2 + n) = 0;
    }
    if ( v52[26] )
    {
      v57 = sub_804E5A3(*(double *)&v11, (unsigned __int8 *)v58, (unsigned __int8 *)v59);
    }
    else
    {
      v25 = &loc_80504AC;
      if ( !v52[28] )
        v25 = &loc_80504E1;
      dword_806B2E8 = (int)v25;
      sub_8061650(v10, v24);
      v57 = sub_804E6B7((int)v58, (int)v59);
      dword_806B310 = (int)&loc_805066B;
      sub_8061566(v27, v26);
      if ( v52[29] )
      {
        v57 = sub_804E4E8(*(double *)&v11, v8, (unsigned __int8 *)v58, (unsigned __int8 *)v59);
      }
      else if ( v52[30] )
      {
        v28 = sub_804E809((unsigned __int8 *)v58, 0);
        v57 = v28 - sub_804E809((unsigned __int8 *)v59, 0);
      }
      else
      {
        if ( v52[27] )
          sub_804EADF(v11, (int)v58, v60, (int)v59, v61);
        if ( v52[32] )
        {
          v57 = sub_80577AE(*(double *)&v11, v58, v59);
          dword_806B2FC = (int)&loc_805066B;
          sub_80615DC();
        }
        if ( v60 )
        {
          v29 = &loc_8050627;
          if ( v61 )
            v29 = &loc_8050633;
          dword_806B248 = (int)v29;
          sub_8061A50();
          v57 = 1;
        }
        else
        {
          v57 = -(v61 != 0);
        }
      }
    }
    if ( v65 || v64 )
    {
      free(ptr);
    }
    else
    {
      v58[v60] = v50;
      v30 = &v59[v61];
      v59[v61] = v51;
    }
    goto LABEL_89;
  }
  if ( v65 )
  {
    if ( v64 )
    {
      while ( (unsigned int)s1 < v55 && *(_BYTE *)((unsigned __int8)sub_804B90F(*(_BYTE *)s1) + v65) )
        s1 = (char *)s1 + 1;
      if ( (unsigned int)s2 < v56 )
      {
        v31 = sub_804B90F(*(_BYTE *)s2);
        v33 = v31;
        v34 = *(_BYTE *)(v31 + v65) == 0;
        v35 = &loc_8050770;
        if ( !v34 )
          v35 = &loc_805071C;
        dword_806B20C = (int)v35;
        sub_8061BBC(v32, v33);
      }
      if ( (unsigned int)s1 < v55 && (unsigned int)s2 < v56 )
      {
        v36 = sub_804B90F(*(_BYTE *)s1);
        v37 = (unsigned __int8)sub_804B90F(*(_BYTE *)(v36 + v64));
        v38 = sub_804B90F(*(_BYTE *)s2);
        v57 = v37 - (unsigned __int8)sub_804B90F(*(_BYTE *)(v38 + v64));
        if ( v57 )
          goto LABEL_92;
        s1 = (char *)s1 + 1;
        s2 = (char *)s2 + 1;
        dword_806B34C = (int)&loc_80506DD;
        sub_80613F7(v39);
      }
      v30 = (char *)(((unsigned int)s1 < v55) - ((unsigned int)s2 < v56));
      v57 = ((unsigned int)s1 < v55) - ((unsigned int)s2 < v56);
      goto LABEL_89;
    }
    while ( (unsigned int)s1 < v55 && *(_BYTE *)((unsigned __int8)sub_804B90F(*(_BYTE *)s1) + v65) )
      s1 = (char *)s1 + 1;
    while ( (unsigned int)s2 < v56 && *(_BYTE *)((unsigned __int8)sub_804B90F(*(_BYTE *)s2) + v65) )
      s2 = (char *)s2 + 1;
    if ( (unsigned int)s1 >= v55 || (unsigned int)s2 >= v56 )
    {
      v30 = (char *)(((unsigned int)s1 < v55) - ((unsigned int)s2 < v56));
      v57 = ((unsigned int)s1 < v55) - ((unsigned int)s2 < v56);
LABEL_89:
      v45 = &loc_8050B80;
      if ( !v57 )
        v45 = &loc_8050B85;
      dword_806B2E8 = (int)v45;
      sub_8061650(v8, v30);
      goto LABEL_92;
    }
    v40 = (unsigned __int8)sub_804B90F(*(_BYTE *)s1);
    v41 = sub_804B90F(*(_BYTE *)s2);
    v57 = v40 - v41;
    v34 = v40 == v41;
    v43 = &loc_8050958;
    if ( v34 )
      v43 = &loc_805095D;
    dword_806B34C = (int)v43;
    sub_80613F7(v42);
  }
  else
  {
    if ( !v66 )
    {
      v57 = -(n != 0);
      dword_806B2FC = (int)&loc_8050B5E;
      sub_80615DC();
    }
    v44 = &loc_80509FA;
    if ( n )
      v44 = &loc_8050A09;
    dword_806B2E8 = (int)v44;
    sub_8061650(v8, v7);
    v57 = 1;
  }
LABEL_92:
  if ( v52[31] )
    result = -v57;
  else
    result = v57;
  return result;
}
// 806137F: using guessed type int __fastcall sub_806137F(_DWORD, _DWORD);
// 80613F7: using guessed type int __fastcall sub_80613F7(_DWORD);
// 8061566: using guessed type int __fastcall sub_8061566(_DWORD, _DWORD);
// 80615DC: using guessed type int sub_80615DC(void);
// 8061650: using guessed type int __fastcall sub_8061650(_DWORD, _DWORD);
// 8061936: using guessed type int __fastcall sub_8061936(_DWORD, _DWORD);
// 8061A50: using guessed type int sub_8061A50(void);
// 8061AC8: using guessed type double __fastcall sub_8061AC8(_DWORD, _DWORD);
// 8061B42: using guessed type int sub_8061B42(void);
// 8061BBC: using guessed type int __fastcall sub_8061BBC(_DWORD, _DWORD);
// 806B20C: using guessed type int dword_806B20C;
// 806B220: using guessed type int dword_806B220;
// 806B234: using guessed type int dword_806B234;
// 806B248: using guessed type int dword_806B248;
// 806B270: using guessed type int dword_806B270;
// 806B2E8: using guessed type int dword_806B2E8;
// 806B2FC: using guessed type int dword_806B2FC;
// 806B310: using guessed type int dword_806B310;
// 806B34C: using guessed type int dword_806B34C;
// 806B360: using guessed type int dword_806B360;
// 806BE39: using guessed type char byte_806BE39;
// 806C265: using guessed type int dword_806C265;

//----- (08050D52) --------------------------------------------------------
_BOOL4 __usercall sub_8050D52@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4)
{
  bool v4; // zf
  int v5; // edx
  int v6; // ecx
  void *v7; // eax
  void *v8; // eax
  int v9; // edx
  int v10; // ecx
  void *v11; // eax
  size_t n; // [esp+1Ch] [ebp-Ch]

  if ( dword_806C265 )
  {
    v4 = sub_804FFE6(a3, a4) == 0;
    v7 = &loc_8050D96;
    if ( !v4 )
      v7 = &loc_8050DAC;
    dword_806B270 = (int)v7;
    sub_8061936(v6, v5);
    if ( byte_806C263 || byte_806C262 )
    {
      dword_806B360 = (int)&loc_8050F18;
      sub_806137F(a2, a1);
    }
  }
  n = *(_DWORD *)(a4 + 4) - 1;
  v8 = &loc_8050DFD;
  if ( *(_DWORD *)(a3 + 4) != 1 )
    v8 = &loc_8050E11;
  dword_806B270 = (int)v8;
  sub_8061936(a2, a1);
  v11 = &loc_8050F0E;
  if ( !byte_806C261 )
    v11 = &loc_8050F15;
  dword_806B270 = (int)v11;
  sub_8061936(v10, v9);
  return n != 0;
}
// 806137F: using guessed type int __fastcall sub_806137F(_DWORD, _DWORD);
// 8061936: using guessed type int __fastcall sub_8061936(_DWORD, _DWORD);
// 806B270: using guessed type int dword_806B270;
// 806B360: using guessed type int dword_806B360;
// 806C261: using guessed type char byte_806C261;
// 806C262: using guessed type char byte_806C262;
// 806C263: using guessed type char byte_806C263;
// 806C265: using guessed type int dword_806C265;

//----- (08050F1E) --------------------------------------------------------
int __usercall sub_8050F1E@<eax>(int a1@<ecx>, long double a2@<st0>, int a3, FILE *stream, int a5)
{
  void *v5; // eax
  bool v6; // zf
  void *v7; // eax
  char *v8; // eax
  void *v10; // eax
  char *v11; // eax
  _BYTE *ptr; // [esp+24h] [ebp-14h]
  size_t n; // [esp+28h] [ebp-10h]
  unsigned int v14; // [esp+2Ch] [ebp-Ch]

  ptr = *(_BYTE **)a3;
  n = *(_DWORD *)(a3 + 4);
  v14 = *(_DWORD *)a3 + n;
  if ( a5 || !byte_806C26D )
  {
    *(_BYTE *)(v14 - 1) = byte_806B3BC;
    v6 = fwrite_unlocked(ptr, 1u, n, stream) == n;
    v10 = &loc_8051070;
    if ( v6 )
      v10 = &loc_805108B;
    dword_806B284 = (int)v10;
    sub_80618C2();
    v11 = gettext("write failed");
    sub_804BC7A(a2, (int)v11, (char *)a5);
  }
  if ( (unsigned int)ptr < v14 )
  {
    v5 = &loc_8050F92;
    if ( *ptr != 9 )
      v5 = &loc_8050F98;
    dword_806B34C = (int)v5;
    sub_80613F7(a1);
    v6 = fputc_unlocked(62, stream) == -1;
    v7 = &loc_8050FEE;
    if ( !v6 )
      v7 = &loc_8051009;
    dword_806B220 = (int)v7;
    sub_8061B42();
    v8 = gettext("write failed");
    sub_804BC7A(a2, (int)v8, 0);
  }
  return sub_804F4EA(a1, *(double *)&a2, a3);
}
// 80613F7: using guessed type int __fastcall sub_80613F7(_DWORD);
// 80618C2: using guessed type int sub_80618C2(void);
// 8061B42: using guessed type int sub_8061B42(void);
// 806B220: using guessed type int dword_806B220;
// 806B284: using guessed type int dword_806B284;
// 806B34C: using guessed type int dword_806B34C;
// 806B3BC: using guessed type char byte_806B3BC;
// 806C26D: using guessed type char byte_806C26D;

//----- (08051096) --------------------------------------------------------
int __usercall sub_8051096@<eax>(long double a1@<st0>, char *a2, char a3)
{
  size_t v3; // eax
  int v4; // ecx
  int v5; // ecx
  int v6; // edx
  int v7; // ebx
  int v8; // eax
  int v9; // eax
  int v10; // ebx
  int v11; // esi
  char *v12; // eax
  char *v13; // eax
  int v14; // ecx
  int v15; // ebx
  _BOOL4 v16; // eax
  int v17; // edx
  int v18; // ecx
  bool v19; // zf
  bool v20; // sf
  unsigned __int8 v21; // of
  void *v22; // eax
  __int64 v23; // rax
  void *v24; // edx
  int v25; // ecx
  __int64 v27; // [esp+0h] [ebp-B8h]
  int v28; // [esp+8h] [ebp-B0h]
  char *v29; // [esp+Ch] [ebp-ACh]
  int v30; // [esp+10h] [ebp-A8h]
  char v31; // [esp+18h] [ebp-A0h]
  char *s1; // [esp+1Ch] [ebp-9Ch]
  unsigned __int8 v33; // [esp+2Eh] [ebp-8Ah]
  char v34[5]; // [esp+2Fh] [ebp-89h]
  unsigned int v35; // [esp+34h] [ebp-84h]
  FILE *stream; // [esp+38h] [ebp-80h]
  int v37; // [esp+3Ch] [ebp-7Ch]
  unsigned int v38; // [esp+40h] [ebp-78h]
  int v39; // [esp+44h] [ebp-74h]
  __int64 v40; // [esp+48h] [ebp-70h]
  __int64 v41; // [esp+50h] [ebp-68h]
  void *ptr; // [esp+58h] [ebp-60h]
  int v43; // [esp+5Ch] [ebp-5Ch]
  char *v44; // [esp+60h] [ebp-58h]
  char *v45; // [esp+64h] [ebp-54h]
  void *v46; // [esp+68h] [ebp-50h]
  unsigned int v47; // [esp+70h] [ebp-48h]
  char v48; // [esp+87h] [ebp-31h]
  unsigned int v49; // [esp+9Ch] [ebp-1Ch]

  s1 = a2;
  v31 = a3;
  v49 = __readgsdword(0x14u);
  stream = sub_804C71B(a1, a2, "r");
  *(_DWORD *)&v34[1] = 0;
  v40 = 0LL;
  v37 = dword_806C265;
  *(_DWORD *)v34 = byte_806C263 == 0;
  v34[0] &= 1u;
  v33 = 1;
  v3 = dword_806B43C;
  if ( size >= dword_806B43C )
    v3 = size;
  sub_804DB2D((int)&v46, 16, v3);
  ptr = 0;
  dword_806B34C = (int)&loc_80513D6;
  sub_80613F7(v4);
  while ( 1 )
  {
    v35 = sub_804DBC8(&v46);
    v6 = -16 * v47;
    v38 = -16 * v47 + v35;
    if ( *(_DWORD *)&v34[1] )
    {
      v7 = (unsigned __int8)v34[0];
      if ( v7 <= sub_8050D52(v6, v5, (int)&ptr, v35 - 16) )
        break;
    }
    v35 -= 16;
    if ( v35 > v38 )
    {
      v15 = (unsigned __int8)v34[0];
      v16 = sub_8050D52(v6, v5, v35, v35 - 16);
      v21 = __OFSUB__(v15, v16);
      v19 = v15 == v16;
      v20 = v15 - v16 < 0;
      v22 = &loc_80512CA;
      if ( !((unsigned __int8)(v20 ^ v21) | v19) )
        v22 = &loc_80512CF;
      dword_806B324 = (int)v22;
      sub_80614D5(v18, v17);
      break;
    }
    v23 = v47;
    v40 += v47;
    if ( *(_DWORD *)(v35 + 4) > *(_DWORD *)&v34[1] )
    {
      do
      {
        *(_DWORD *)&v34[1] *= 2;
        if ( !*(_DWORD *)&v34[1] )
        {
          *(_DWORD *)&v34[1] = *(_DWORD *)(v35 + 4);
          dword_806B234 = (int)&loc_8051346;
          a1 = sub_8061AC8(v5, HIDWORD(v23));
        }
      }
      while ( *(_DWORD *)(v35 + 4) > *(_DWORD *)&v34[1] );
      free(ptr);
      ptr = sub_805E2B0(*(size_t *)&v34[1]);
    }
    memcpy(ptr, *(const void **)v35, *(_DWORD *)(v35 + 4));
    v43 = *(_DWORD *)(v35 + 4);
    if ( v37 )
    {
      v44 = (char *)ptr + *(_DWORD *)(v35 + 8) - *(_DWORD *)v35;
      v24 = ptr;
      v25 = *(_DWORD *)(v35 + 12) - *(_DWORD *)v35;
      v45 = (char *)ptr + v25;
    }
    if ( !(unsigned __int8)sub_804DF39((int)v24, v25, a1, (int)&v46, stream, (int)s1) )
      goto LABEL_22;
  }
  if ( v31 == 99 )
  {
    v39 = v35 - 16;
    v8 = sub_804DBC8(&v46);
    v9 = (v8 - v39) >> 4;
    v41 = v9 + v40;
    v27 = v9 + v40;
    v10 = sub_80595C9(v27, (int)&v48);
    v11 = dword_806C3C1;
    v12 = gettext("%s: %s:%s: disorder: ");
    v30 = v10;
    v29 = s1;
    v28 = v11;
    fprintf(stderr, v12, v11, s1, v10);
    v13 = gettext("standard error");
    sub_8050F1E(v14, a1, v39, stderr, (int)v13);
  }
  v33 = 0;
LABEL_22:
  sub_804C75C(a1, stream, (int)s1);
  free(v46);
  free(ptr);
  return v33;
}
// 80613F7: using guessed type int __fastcall sub_80613F7(_DWORD);
// 80614D5: using guessed type int __fastcall sub_80614D5(_DWORD, _DWORD);
// 8061AC8: using guessed type double __fastcall sub_8061AC8(_DWORD, _DWORD);
// 806B234: using guessed type int dword_806B234;
// 806B324: using guessed type int dword_806B324;
// 806B34C: using guessed type int dword_806B34C;
// 806C263: using guessed type char byte_806C263;
// 806C265: using guessed type int dword_806C265;
// 806C3C1: using guessed type int dword_806C3C1;

//----- (08051448) --------------------------------------------------------
unsigned int __usercall sub_8051448@<eax>(long double a1@<st0>, int a2, unsigned int a3, void **a4)
{
  int v4; // ecx
  void *v5; // eax
  int v6; // edx
  int v7; // ecx
  unsigned int i; // [esp+18h] [ebp-10h]
  _DWORD *v10; // [esp+1Ch] [ebp-Ch]

  *a4 = sub_805E171(a3, 4u);
  v10 = *a4;
  for ( i = 0; i < a3; ++i )
  {
    v5 = &loc_80514BC;
    if ( !*(_DWORD *)(8 * i + a2 + 4) )
      v5 = &loc_8051507;
    dword_806B324 = (int)v5;
    sub_80614D5(v4, 8 * i);
    if ( *(_BYTE *)(*(_DWORD *)(8 * i + a2 + 4) + 8) )
    {
      sub_804CBA3(a1, *(_DWORD *)(8 * i + a2 + 4));
      dword_806B2D4 = (int)&loc_8051528;
      sub_80616F8(v7, v6);
    }
    v10[i] = sub_804C5A5(a1, *(char **)(8 * i + a2), "r");
    if ( !v10[i] )
      break;
  }
  return i;
}
// 80614D5: using guessed type int __fastcall sub_80614D5(_DWORD, _DWORD);
// 80616F8: using guessed type int __fastcall sub_80616F8(_DWORD, _DWORD);
// 806B2D4: using guessed type int dword_806B2D4;
// 806B324: using guessed type int dword_806B324;

//----- (0805155A) --------------------------------------------------------
void __usercall sub_805155A(long double a1@<st0>, int a2, int a3, int a4, FILE *stream, int a6, void *a7)
{
  unsigned int *v7; // edx
  int v8; // ecx
  size_t v9; // edx
  int v10; // eax
  _DWORD *v11; // ecx
  _DWORD *v12; // eax
  int v13; // edx
  _BOOL4 v14; // eax
  bool v15; // zf
  bool v16; // sf
  void *v17; // eax
  unsigned int v18; // ST50_4
  void *v19; // eax
  int v20; // edx
  int v21; // ecx
  void *v22; // eax
  _DWORD *v23; // edx
  int v24; // eax
  _DWORD *v25; // edx
  int v26; // ecx
  _DWORD *v27; // ecx
  _DWORD *v28; // eax
  int v29; // edx
  _DWORD *v30; // eax
  _DWORD *v31; // edx
  int v32; // ST0C_4
  int v33; // edx
  int v34; // ecx
  void *v35; // eax
  void *v36; // eax
  int v37; // ecx
  void **v38; // [esp+14h] [ebp-64h]
  size_t size; // [esp+18h] [ebp-60h]
  unsigned int v40; // [esp+1Ch] [ebp-5Ch]
  unsigned int j; // [esp+1Ch] [ebp-5Ch]
  unsigned int k; // [esp+1Ch] [ebp-5Ch]
  unsigned int l; // [esp+1Ch] [ebp-5Ch]
  unsigned int v44; // [esp+1Ch] [ebp-5Ch]
  unsigned int i; // [esp+20h] [ebp-58h]
  unsigned int v46; // [esp+20h] [ebp-58h]
  unsigned int v47; // [esp+24h] [ebp-54h]
  unsigned int v48; // [esp+28h] [ebp-50h]
  unsigned int v49; // [esp+2Ch] [ebp-4Ch]
  _DWORD *v50; // [esp+30h] [ebp-48h]
  _DWORD *v51; // [esp+34h] [ebp-44h]
  _DWORD *v52; // [esp+38h] [ebp-40h]
  unsigned int *v53; // [esp+3Ch] [ebp-3Ch]
  int v54; // [esp+40h] [ebp-38h]
  unsigned int v55; // [esp+4Ch] [ebp-2Ch]
  unsigned int v56; // [esp+54h] [ebp-24h]
  _BOOL4 v57; // [esp+58h] [ebp-20h]
  unsigned int v58; // [esp+5Ch] [ebp-1Ch]
  void *ptr; // [esp+60h] [ebp-18h]
  size_t n; // [esp+64h] [ebp-14h]
  char *v61; // [esp+68h] [ebp-10h]
  char *v62; // [esp+6Ch] [ebp-Ch]

  v50 = sub_805E171(a4, 0x1Cu);
  v38 = 0;
  size = 0;
  v51 = sub_805E171(a4, 4u);
  v52 = sub_805E171(a4, 4u);
  v53 = (unsigned int *)sub_805E171(a4, 4u);
  v54 = dword_806C265;
  ptr = 0;
  v40 = 0;
  while ( v40 < a4 )
  {
    v9 = ::size / a4;
    if ( ::size / a4 < dword_806B43C )
      v9 = dword_806B43C;
    sub_804DB2D((int)&v50[7 * v40], 16, v9);
    if ( (unsigned __int8)sub_804DF39(
                            *((_DWORD *)a7 + v40),
                            *(_DWORD *)(8 * v40 + a2),
                            a1,
                            (int)&v50[7 * v40],
                            *((FILE **)a7 + v40),
                            *(_DWORD *)(8 * v40 + a2)) )
    {
      v10 = sub_804DBC8(&v50[7 * v40]);
      v51[v40] = v10 - 16;
      v7 = &v52[v40];
      v8 = -4 * v50[7 * v40 + 2];
      *v7 = v8 * 4 + v10;
      ++v40;
    }
    else
    {
      sub_804C75C(a1, *((FILE **)a7 + v40), *(_DWORD *)(8 * v40 + a2));
      if ( v40 < a3 )
      {
        --a3;
        sub_804CE06(a1, *(char **)(8 * v40 + a2));
      }
      free((void *)v50[7 * v40]);
      --a4;
      for ( i = v40; i < a4; ++i )
      {
        v11 = (_DWORD *)(8 * i + a2);
        v12 = (_DWORD *)(8 * (i + 1) + a2);
        v13 = v12[1];
        *v11 = *v12;
        v11[1] = v13;
        v7 = (unsigned int *)((char *)a7 + 4 * i);
        v8 = i + 1;
        *v7 = *(_DWORD *)((char *)a7 + v8 * 4);
      }
    }
  }
  for ( j = 0; j < a4; ++j )
  {
    v7 = &v53[j];
    *v7 = j;
  }
  while ( (unsigned int)a4 > 1 )
  {
    v14 = sub_8050D52(v51[v53[1]], 4 * *v53, v51[*v53], v51[v53[1]]);
    v15 = v14 == 0;
    v16 = v14 < 0;
    v17 = &loc_8051867;
    if ( v16 || v15 )
      v17 = &loc_80518C2;
    dword_806B220 = (int)v17;
    sub_8061B42();
    v18 = *v53;
    v8 = 1;
    *v53 = v53[1];
    v7 = v53 + 1;
    v53[1] = v18;
  }
  while ( a4 )
  {
    v55 = v51[*v53];
    v19 = &loc_8051911;
    if ( !byte_806C263 )
      v19 = &loc_8051A17;
    dword_806B298 = (int)v19;
    sub_806184C(v8 * 4);
    if ( v38 && sub_8050D52(v20, v21, (int)v38, v55) )
    {
      v38 = 0;
      sub_8050F1E(v21, a1, (int)&ptr, stream, a6);
    }
    if ( !v38 )
    {
      v38 = &ptr;
      if ( *(_DWORD *)(v55 + 4) > size )
      {
        v22 = &loc_8051987;
        if ( size )
          v22 = &loc_8051992;
        dword_806B34C = (int)v22;
        sub_80613F7(v21);
        size = *(_DWORD *)(v55 + 4);
        free(ptr);
        ptr = sub_805E2B0(size);
      }
      n = *(_DWORD *)(v55 + 4);
      memcpy(ptr, *(const void **)v55, n);
      if ( v54 )
      {
        v61 = (char *)ptr + *(_DWORD *)(v55 + 8) - *(_DWORD *)v55;
        v21 = *(_DWORD *)(v55 + 12) - *(_DWORD *)v55;
        v62 = (char *)ptr + v21;
      }
    }
    if ( v52[*v53] >= v55 )
    {
      if ( (unsigned __int8)sub_804DF39(
                              *((_DWORD *)a7 + *v53),
                              *(_DWORD *)(8 * *v53 + a2),
                              a1,
                              (int)&v50[7 * *v53],
                              *((FILE **)a7 + *v53),
                              *(_DWORD *)(8 * *v53 + a2)) )
      {
        v24 = sub_804DBC8(&v50[7 * *v53]);
        v51[*v53] = v24 - 16;
        v23 = &v52[*v53];
        v21 = -16 * v50[7 * *v53 + 2];
        *v23 = v21 + v24;
        goto LABEL_50;
      }
      for ( k = 1; k < a4; ++k )
      {
        if ( v53[k] > *v53 )
          --v53[k];
      }
      --a4;
      sub_804C75C(a1, *((FILE **)a7 + *v53), *(_DWORD *)(8 * *v53 + a2));
      if ( *v53 < a3 )
      {
        --a3;
        sub_804CE06(a1, *(char **)(8 * *v53 + a2));
      }
      free((void *)v50[7 * *v53]);
      for ( l = *v53; l < a4; ++l )
      {
        *((_DWORD *)a7 + l) = *((_DWORD *)a7 + l + 1);
        v27 = (_DWORD *)(8 * l + a2);
        v28 = (_DWORD *)(8 * (l + 1) + a2);
        v29 = v28[1];
        *v27 = *v28;
        v27[1] = v29;
        v30 = &v50[7 * l];
        v31 = &v50[7 * (l + 1)];
        *v30 = *v31;
        v30[1] = v31[1];
        v30[2] = v31[2];
        v30[3] = v31[3];
        v30[4] = v31[4];
        v30[5] = v31[5];
        v30[6] = v31[6];
        v51[l] = v51[l + 1];
        v25 = &v52[l];
        v26 = l + 1;
        *v25 = v52[v26];
      }
      v44 = 0;
      dword_806B360 = (int)&loc_8051D43;
      sub_806137F(v26 * 4, v25);
      do
      {
        v7 = &v53[v44];
        v8 = v44 + 1;
        *v7 = v53[v8];
        ++v44;
      }
      while ( v44 < a4 );
    }
    else
    {
      v23 = (_DWORD *)(v55 - 16);
      v51[*v53] = v55 - 16;
LABEL_50:
      v47 = 1;
      v48 = a4;
      v49 = 1;
      v56 = *v53;
      dword_806B310 = (int)&loc_8051E1A;
      sub_8061566(v21, v23);
      do
      {
        v32 = v51[v53[v49]];
        v57 = sub_8050D52(v32, 4 * v56, v51[v56], v32);
        if ( v57 < 0 )
          goto LABEL_69;
        v35 = &loc_8051DE6;
        if ( v57 )
          v35 = &loc_8051E04;
        dword_806B2D4 = (int)v35;
        sub_80616F8(v34, v33);
        if ( v53[v49] <= v56 )
          v47 = v49 + 1;
        else
LABEL_69:
          v48 = v49;
        v49 = (v47 + v48) >> 1;
      }
      while ( v47 < v48 );
      v58 = v47 - 1;
      v46 = 0;
      dword_806B2C0 = (int)&loc_8051E76;
      sub_8061764(v34);
      do
      {
        v8 = v46 + 1;
        v53[v46++] = v53[v8];
      }
      while ( v46 < v58 );
      v7 = &v53[v58];
      *v7 = v56;
    }
  }
  v36 = &loc_8051EC0;
  if ( !byte_806C263 )
    v36 = &loc_8051EEA;
  dword_806B270 = (int)v36;
  sub_8061936(v8 * 4, v7);
  if ( v38 )
  {
    sub_8050F1E(v37, a1, (int)&ptr, stream, a6);
    free(ptr);
  }
  sub_804C75C(a1, stream, a6);
  free(a7);
  free(v50);
  free(v53);
  free(v52);
  free(v51);
}
// 806137F: using guessed type int __fastcall sub_806137F(_DWORD, _DWORD);
// 80613F7: using guessed type int __fastcall sub_80613F7(_DWORD);
// 8061566: using guessed type int __fastcall sub_8061566(_DWORD, _DWORD);
// 80616F8: using guessed type int __fastcall sub_80616F8(_DWORD, _DWORD);
// 8061764: using guessed type int __fastcall sub_8061764(_DWORD);
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD);
// 8061936: using guessed type int __fastcall sub_8061936(_DWORD, _DWORD);
// 8061B42: using guessed type int sub_8061B42(void);
// 806B220: using guessed type int dword_806B220;
// 806B270: using guessed type int dword_806B270;
// 806B298: using guessed type int dword_806B298;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B2D4: using guessed type int dword_806B2D4;
// 806B310: using guessed type int dword_806B310;
// 806B34C: using guessed type int dword_806B34C;
// 806B360: using guessed type int dword_806B360;
// 806C263: using guessed type char byte_806C263;
// 806C265: using guessed type int dword_806C265;

//----- (08051F39) --------------------------------------------------------
int __usercall sub_8051F39@<eax>(long double a1@<st0>, int a2, int a3, int a4, FILE *stream, int a6)
{
  char *v6; // ebx
  char *v7; // eax
  void *v9; // [esp+28h] [ebp-10h]
  int v10; // [esp+2Ch] [ebp-Ch]

  v10 = sub_8051448(a1, a2, a4, &v9);
  if ( v10 < (unsigned int)a4 && (unsigned int)v10 <= 1 )
  {
    v6 = *(char **)(8 * v10 + a2);
    v7 = gettext("open failed");
    sub_804BC7A(a1, (int)v7, v6);
  }
  sub_805155A(a1, a2, a3, v10, stream, a6, v9);
  return v10;
}

//----- (08051FCA) --------------------------------------------------------
_DWORD *__usercall sub_8051FCA@<eax>(int a1@<ecx>, double a2@<st0>, _DWORD *a3, unsigned int a4, _DWORD *a5)
{
  void *v5; // eax
  int v6; // edx
  int v7; // ecx
  void *v8; // eax
  _DWORD *result; // eax
  unsigned int v10; // [esp+14h] [ebp-14h]
  int v11; // [esp+1Ch] [ebp-Ch]
  _DWORD *v12; // [esp+30h] [ebp+8h]

  v10 = a4 >> 1;
  v11 = (int)&a3[-4 * (a4 >> 1)];
  if ( sub_8050D52(v11 - 16, a1, (int)(a5 - 4), v11 - 16) <= 0 )
  {
    a3 -= 4;
    a5 -= 4;
    *a3 = *a5;
    a3[1] = a5[1];
    a3[2] = a5[2];
    a3[3] = a5[3];
    --v10;
    v5 = &loc_805205A;
    if ( v10 )
      v5 = &loc_80520E8;
    dword_806B338 = (int)v5;
    sub_8061467(a2);
    dword_806B310 = (int)&locret_80520ED;
    sub_8061566(v7, v6);
  }
  v12 = a3 - 4;
  *v12 = *(_DWORD *)(v11 - 16);
  v12[1] = *(_DWORD *)(v11 - 16 + 4);
  v12[2] = *(_DWORD *)(v11 - 16 + 8);
  v12[3] = *(_DWORD *)(v11 - 16 + 12);
  v8 = &loc_80520B8;
  if ( a4 - (a4 >> 1) != 1 )
    v8 = &loc_80520E8;
  dword_806B25C = (int)v8;
  sub_80619C7(a2);
  do
  {
    v12 -= 4;
    a5 -= 4;
    result = v12;
    *v12 = *a5;
    v12[1] = a5[1];
    v12[2] = a5[2];
    v12[3] = a5[3];
    --v10;
  }
  while ( v10 );
  return result;
}
// 8051FCA: could not find valid save-restore pair for ebx
// 8061467: using guessed type int __usercall sub_8061467@<eax>(double@<st0>);
// 8061566: using guessed type int __fastcall sub_8061566(_DWORD, _DWORD);
// 80619C7: using guessed type int __usercall sub_80619C7@<eax>(double@<st0>);
// 806B25C: using guessed type int dword_806B25C;
// 806B310: using guessed type int dword_806B310;
// 806B338: using guessed type int dword_806B338;

//----- (080520EF) --------------------------------------------------------
int __usercall sub_80520EF@<eax>(int a1@<ecx>, double a2@<st0>, _DWORD *a3, unsigned int a4, _DWORD *a5, unsigned __int8 a6)
{
  int result; // eax
  _DWORD *v7; // eax
  _DWORD *v8; // edx
  _DWORD *v9; // eax
  _DWORD *v10; // edx
  _DWORD *v11; // edx
  _DWORD *v12; // edx
  _DWORD *v13; // edx
  int v14; // eax
  int v15; // ecx
  _DWORD *v16; // edx
  int v17; // eax
  unsigned __int8 v18; // [esp+1Ch] [ebp-2Ch]
  _DWORD *v19; // [esp+24h] [ebp-24h]
  _DWORD *v20; // [esp+28h] [ebp-20h]
  int v21; // [esp+2Ch] [ebp-1Ch]
  unsigned int v22; // [esp+30h] [ebp-18h]
  unsigned int v23; // [esp+34h] [ebp-14h]
  _DWORD *v24; // [esp+38h] [ebp-10h]
  _DWORD *v25; // [esp+3Ch] [ebp-Ch]

  v18 = a6;
  if ( a4 == 2 )
  {
    result = sub_8050D52((int)(a3 - 8), a1, (int)(a3 - 4), (int)(a3 - 8)) > 0;
    v21 = result;
    if ( v18 )
    {
      v7 = a5 - 4;
      v8 = &a3[4 * ~v21];
      *v7 = *v8;
      v7[1] = v8[1];
      v7[2] = v8[2];
      v7[3] = v8[3];
      v9 = a5 - 8;
      v10 = &a3[4 * (v21 - 2)];
      *v9 = *v10;
      v9[1] = v10[1];
      v9[2] = v10[2];
      v9[3] = v10[3];
      dword_806B220 = (int)&loc_8052207;
      result = sub_8061B42();
    }
    if ( v21 )
    {
      v11 = a5 - 4;
      *v11 = *(a3 - 4);
      v11[1] = *(a3 - 3);
      v11[2] = *(a3 - 2);
      v11[3] = *(a3 - 1);
      v12 = a3 - 4;
      *v12 = *(a3 - 8);
      v12[1] = *(a3 - 7);
      v12[2] = *(a3 - 6);
      v12[3] = *(a3 - 5);
      v13 = a3 - 8;
      *v13 = *(a5 - 4);
      v13[1] = *(a5 - 3);
      v13[2] = *(a5 - 2);
      result = *(a5 - 1);
      v13[3] = result;
    }
  }
  else
  {
    v22 = a4 >> 1;
    v23 = a4 - (a4 >> 1);
    v24 = a3;
    v25 = &a3[-4 * (a4 >> 1)];
    if ( v18 )
      v14 = -4 * v22;
    else
      v14 = 0;
    sub_80520EF(v25, v23, &a5[v14], v18);
    if ( v22 <= 1 )
    {
      if ( v18 != 1 )
      {
        v16 = a5 - 4;
        v17 = (int)v24;
        *v16 = *(v24 - 4);
        v16[1] = *(_DWORD *)(v17 - 12);
        v15 = *(_DWORD *)(v17 - 8);
        v16[2] = v15;
        v16[3] = *(_DWORD *)(v17 - 4);
      }
    }
    else
    {
      sub_80520EF(v24, v22, a5, v18 == 0);
    }
    if ( v18 )
    {
      v19 = a5;
      v20 = a3;
    }
    else
    {
      v19 = a3;
      v20 = a5;
    }
    result = (int)sub_8051FCA(v15, a2, v19, a4, v20);
  }
  return result;
}
// 8061B42: using guessed type int sub_8061B42(void);
// 806B220: using guessed type int dword_806B220;

//----- (08052311) --------------------------------------------------------
pthread_mutex_t *__cdecl sub_8052311(unsigned int a1, int a2, int a3)
{
  pthread_mutex_t *v3; // eax
  pthread_mutex_t *v4; // ST28_4
  pthread_mutex_t *v5; // ST2C_4
  int v6; // ecx

  v3 = (pthread_mutex_t *)sub_805E2B0(144 * a1);
  v4 = v3;
  v5 = v3;
  v3->__kind = 0;
  v5->__owner = v5->__kind;
  v5->__count = v5->__owner;
  v5->__lock = v5->__count;
  v3->__nusers = 0;
  v3[1].__lock = a2;
  v3->__spins = v3[1].__lock;
  v3[1].__count = 0;
  v3[1].__nusers = 0;
  v3[1].__size[20] = 0;
  pthread_mutex_init(v3 + 2, 0);
  sub_8052440((int)&v5[3], v6, (unsigned int)v5, v5 + 3, a3, a1, a2, 0);
  return v4;
}

//----- (08052440) --------------------------------------------------------
int __usercall sub_8052440@<eax>(int a1@<edx>, int a2@<ecx>, unsigned int a3, pthread_mutex_t *a4, int a5, unsigned int a6, int a7, char a8)
{
  void *v8; // eax
  int v9; // ecx
  unsigned int v10; // eax
  int v11; // edx
  void *v12; // eax
  pthread_mutex_t *v13; // eax
  int v14; // eax
  int v16; // [esp+30h] [ebp-28h]
  int v17; // [esp+34h] [ebp-24h]
  int v18; // [esp+38h] [ebp-20h]
  int v19; // [esp+3Ch] [ebp-1Ch]
  pthread_mutex_t *v20; // [esp+44h] [ebp-14h]
  int v21; // [esp+64h] [ebp+Ch]

  v8 = &loc_805246B;
  if ( !a8 )
    v8 = &loc_8052473;
  dword_806B2E8 = (int)v8;
  sub_8061650(a2, a1);
  v10 = *(_DWORD *)(a3 + 20);
  v16 = v10 >> 1;
  v17 = v10 - (v10 >> 1);
  v18 = -16 * a7 + a5;
  v11 = -16 * (v10 >> 1);
  v19 = v11 + v18;
  v12 = &loc_80524D4;
  if ( !a8 )
    v12 = &loc_80524DC;
  dword_806B2E8 = (int)v12;
  sub_8061650(v9, v11);
  v13 = a4;
  v21 = (int)&a4[3];
  v20 = v13;
  v13->__owner = v18;
  v20->__lock = v20->__owner;
  v13->__kind = v19;
  v20->__count = v20->__kind;
  v13->__nusers = a3 + 8;
  v13->__spins = v16;
  v13[1].__lock = v17;
  v13[1].__count = a3;
  v13[1].__nusers = *(_DWORD *)(a3 + 40) + 1;
  v13[1].__size[20] = 0;
  pthread_mutex_init(v13 + 2, 0);
  if ( a6 <= 1 )
  {
    v20[1].__owner = 0;
    v20[1].__kind = 0;
  }
  else
  {
    v20[1].__owner = v21;
    v14 = sub_8052440(v20, v21, v18, a6 >> 1, a7, 1);
    v20[1].__kind = v14;
    v21 = sub_8052440(v20, v14, v19, a6 - (a6 >> 1), a7, 0);
  }
  return v21;
}
// 8052440: could not find valid save-restore pair for ebx
// 8061650: using guessed type int __fastcall sub_8061650(_DWORD, _DWORD);
// 806B2E8: using guessed type int dword_806B2E8;

//----- (0805261A) --------------------------------------------------------
_BOOL4 __cdecl sub_805261A(_DWORD *a1, _DWORD *a2)
{
  _BOOL4 result; // eax

  if ( a1[10] == a2[10] )
    result = a1[5] + a1[6] < (unsigned int)(a2[5] + a2[6]);
  else
    result = a1[10] < a2[10];
  return result;
}

//----- (08052679) --------------------------------------------------------
int __cdecl sub_8052679(pthread_mutex_t *a1)
{
  return pthread_mutex_lock(a1 + 2);
}

//----- (0805268F) --------------------------------------------------------
int __cdecl sub_805268F(pthread_mutex_t *a1)
{
  return pthread_mutex_unlock(a1 + 2);
}

//----- (080526D6) --------------------------------------------------------
int __cdecl sub_80526D6(int a1, int a2)
{
  *(_DWORD *)a1 = sub_80590D3((int)sub_805261A, 2 * a2);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 4), 0);
  return pthread_cond_init((pthread_cond_t *)(a1 + 28), 0);
}

//----- (08052724) --------------------------------------------------------
int __cdecl sub_8052724(int a1, int a2)
{
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 4));
  sub_80591A4(*(_DWORD *)a1, a2);
  *(_BYTE *)(a2 + 44) = 1;
  pthread_cond_signal((pthread_cond_t *)(a1 + 28));
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 4));
}

//----- (08052771) --------------------------------------------------------
pthread_mutex_t *__cdecl sub_8052771(int a1)
{
  int v1; // ecx
  int v2; // edx
  int v3; // ecx
  int v4; // eax
  int v5; // edx
  int v6; // ecx
  bool v7; // zf
  void *v8; // eax
  pthread_mutex_t *v10; // [esp+1Ch] [ebp-Ch]

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 4));
  dword_806B298 = (int)&loc_80527B4;
  sub_806184C(v1);
  pthread_cond_wait((pthread_cond_t *)(a1 + 28), (pthread_mutex_t *)(a1 + 4));
  v4 = sub_805922D(v2, v3, *(int **)a1);
  v10 = (pthread_mutex_t *)v4;
  v7 = v4 == 0;
  v8 = &loc_80527E3;
  if ( v7 )
    v8 = &loc_805279C;
  dword_806B324 = (int)v8;
  sub_80614D5(v6, v5);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 4));
  sub_8052679(v10);
  v10[1].__size[20] = 0;
  return v10;
}
// 80614D5: using guessed type int __fastcall sub_80614D5(_DWORD, _DWORD);
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD);
// 806B298: using guessed type int dword_806B298;
// 806B324: using guessed type int dword_806B324;

//----- (08052808) --------------------------------------------------------
int __usercall sub_8052808@<eax>(long double a1@<st0>, int a2, FILE *stream, int a4)
{
  void *v4; // eax
  int v5; // edx
  int v6; // ecx

  v4 = &loc_8052832;
  if ( !byte_806C263 )
    v4 = &loc_805288E;
  dword_806B374 = (int)v4;
  sub_80612DD();
  if ( dword_806BE3D && !sub_8050D52(v5, v6, a2, (int)&dword_806BE3D) )
  {
    dword_806B2C0 = (int)&locret_80528A7;
    sub_8061764(v6);
  }
  dword_806BE3D = *(_DWORD *)a2;
  dword_806BE41 = *(_DWORD *)(a2 + 4);
  dword_806BE45 = *(_DWORD *)(a2 + 8);
  dword_806BE49 = *(_DWORD *)(a2 + 12);
  return sub_8050F1E(v6, a1, a2, stream, a4);
}
// 80612DD: using guessed type int sub_80612DD(void);
// 8061764: using guessed type int __fastcall sub_8061764(_DWORD);
// 806B2C0: using guessed type int dword_806B2C0;
// 806B374: using guessed type int dword_806B374;
// 806BE3D: using guessed type int dword_806BE3D;
// 806BE41: using guessed type int dword_806BE41;
// 806BE45: using guessed type int dword_806BE45;
// 806BE49: using guessed type int dword_806BE49;
// 806C263: using guessed type char byte_806C263;

//----- (080528A9) --------------------------------------------------------
int __usercall sub_80528A9@<eax>(long double a1@<st0>, int a2, int a3, FILE *stream, int a5)
{
  int v5; // ecx
  int v6; // eax
  _DWORD *v7; // edx
  _DWORD *v8; // eax
  int v9; // ecx
  int v10; // edx
  _DWORD *v11; // edx
  _DWORD *v12; // eax
  void *v13; // eax
  int v14; // ecx
  int v15; // eax
  _DWORD *v16; // edx
  _DWORD *v17; // eax
  int v18; // eax
  void *v19; // eax
  _DWORD *v20; // edx
  _DWORD *v21; // eax
  void *v22; // eax
  int v23; // eax
  int v24; // eax
  bool v25; // zf
  void *v26; // eax
  unsigned int v27; // eax
  int v28; // edx
  int v29; // edx
  void *v30; // eax
  long double v31; // fst7
  int v32; // eax
  int result; // eax
  int v34; // [esp+4h] [ebp-34h]
  unsigned int v35; // [esp+18h] [ebp-20h]
  _DWORD *v36; // [esp+1Ch] [ebp-1Ch]
  int v37; // [esp+20h] [ebp-18h]
  int v38; // [esp+24h] [ebp-14h]
  int v39; // [esp+28h] [ebp-10h]
  int v40; // [esp+2Ch] [ebp-Ch]

  v37 = *(_DWORD *)a2;
  v38 = *(_DWORD *)(a2 + 4);
  v5 = 2 * (*(_DWORD *)(a2 + 40) + 1);
  v35 = ((unsigned int)a3 >> v5) + 1;
  if ( *(_DWORD *)(a2 + 40) <= 1u )
  {
    if ( *(_DWORD *)a2 != *(_DWORD *)(a2 + 8) && *(_DWORD *)(a2 + 4) != *(_DWORD *)(a2 + 12) )
    {
      v24 = v35--;
      v25 = v24 == 0;
      v26 = &loc_8052BD8;
      if ( !v25 )
        v26 = &loc_8052B04;
      dword_806B34C = (int)v26;
      sub_80613F7(v5);
    }
    v39 = (v37 - *(_DWORD *)a2) >> 4;
    v40 = (v38 - *(_DWORD *)(a2 + 4)) >> 4;
    if ( *(_DWORD *)(a2 + 24) == v40 )
    {
      while ( *(_DWORD *)a2 != *(_DWORD *)(a2 + 8) )
      {
        v27 = v35;
        v28 = v35-- - 1;
        if ( !v27 )
        {
          dword_806B20C = (int)&loc_8052CD7;
          sub_8061BBC(v5, v28);
          goto LABEL_35;
        }
        *(_DWORD *)a2 -= 16;
        sub_8052808(a1, *(_DWORD *)a2, stream, a5);
      }
    }
    else
    {
LABEL_35:
      if ( *(_DWORD *)(a2 + 20) == v39 )
      {
        while ( 1 )
        {
          v29 = *(_DWORD *)(a2 + 4);
          v30 = &loc_8052CCA;
          if ( v29 == *(_DWORD *)(a2 + 12) )
            v30 = &loc_8052CD7;
          dword_806B234 = (int)v30;
          v31 = sub_8061AC8(v5, v29);
          v32 = v35--;
          if ( !v32 )
            break;
          *(_DWORD *)(a2 + 4) -= 16;
          sub_8052808(v31, *(_DWORD *)(a2 + 4), stream, a5);
        }
      }
    }
  }
  else
  {
    v36 = **(_DWORD ***)(a2 + 16);
    while ( *(_DWORD *)a2 != *(_DWORD *)(a2 + 8) )
    {
      v13 = &loc_80529CA;
      if ( *(_DWORD *)(a2 + 4) == *(_DWORD *)(a2 + 12) )
        v13 = &loc_80529DB;
      dword_806B25C = (int)v13;
      sub_80619C7(*(double *)&a1);
      v15 = v35--;
      if ( !v15 )
        break;
      v6 = *(_DWORD *)a2 - 16;
      v34 = *(_DWORD *)(a2 + 4) - 16;
      if ( sub_8050D52(v34, v14, v6, v34) <= 0 )
      {
        v36 -= 4;
        *(_DWORD *)a2 -= 16;
        v7 = *(_DWORD **)a2;
        v8 = v36;
        *v36 = **(_DWORD **)a2;
        v8[1] = v7[1];
        v9 = v7[2];
        v8[2] = v9;
        v10 = v7[3];
        v8[3] = v10;
        dword_806B360 = (int)&loc_8052992;
        sub_806137F(v9, v10);
      }
      v36 -= 4;
      *(_DWORD *)(a2 + 4) -= 16;
      v11 = *(_DWORD **)(a2 + 4);
      v12 = v36;
      *v36 = *v11;
      v12[1] = v11[1];
      v12[2] = v11[2];
      v12[3] = v11[3];
    }
    v39 = (v37 - *(_DWORD *)a2) >> 4;
    v40 = (v38 - *(_DWORD *)(a2 + 4)) >> 4;
    if ( *(_DWORD *)(a2 + 24) == v40 )
    {
      while ( *(_DWORD *)a2 != *(_DWORD *)(a2 + 8) )
      {
        v18 = v35--;
        if ( !v18 )
          break;
        v36 -= 4;
        *(_DWORD *)a2 -= 16;
        v16 = *(_DWORD **)a2;
        v17 = v36;
        *v36 = **(_DWORD **)a2;
        v17[1] = v16[1];
        v17[2] = v16[2];
        v17[3] = v16[3];
      }
    }
    else
    {
      v19 = &loc_8052A85;
      if ( *(_DWORD *)(a2 + 20) != v39 )
        v19 = &loc_8052AEF;
      dword_806B338 = (int)v19;
      sub_8061467(*(double *)&a1);
      while ( 1 )
      {
        v22 = &loc_8052AE2;
        if ( *(_DWORD *)(a2 + 4) == *(_DWORD *)(a2 + 12) )
          v22 = &loc_8052AEF;
        dword_806B284 = (int)v22;
        sub_80618C2();
        v23 = v35--;
        if ( !v23 )
          break;
        v36 -= 4;
        *(_DWORD *)(a2 + 4) -= 16;
        v20 = *(_DWORD **)(a2 + 4);
        v21 = v36;
        *v36 = *v20;
        v21[1] = v20[1];
        v21[2] = v20[2];
        v21[3] = v20[3];
      }
    }
    **(_DWORD **)(a2 + 16) = v36;
  }
  v39 = (v37 - *(_DWORD *)a2) >> 4;
  v40 = (v38 - *(_DWORD *)(a2 + 4)) >> 4;
  *(_DWORD *)(a2 + 20) -= v39;
  result = a2;
  *(_DWORD *)(a2 + 24) -= v40;
  return result;
}
// 80528A9: could not find valid save-restore pair for ebx
// 806137F: using guessed type int __fastcall sub_806137F(_DWORD, _DWORD);
// 80613F7: using guessed type int __fastcall sub_80613F7(_DWORD);
// 8061467: using guessed type int __usercall sub_8061467@<eax>(double@<st0>);
// 80618C2: using guessed type int sub_80618C2(void);
// 80619C7: using guessed type int __usercall sub_80619C7@<eax>(double@<st0>);
// 8061AC8: using guessed type double __fastcall sub_8061AC8(_DWORD, _DWORD);
// 8061BBC: using guessed type int __fastcall sub_8061BBC(_DWORD, _DWORD);
// 806B20C: using guessed type int dword_806B20C;
// 806B234: using guessed type int dword_806B234;
// 806B25C: using guessed type int dword_806B25C;
// 806B284: using guessed type int dword_806B284;
// 806B338: using guessed type int dword_806B338;
// 806B34C: using guessed type int dword_806B34C;
// 806B360: using guessed type int dword_806B360;

//----- (08052D20) --------------------------------------------------------
int __cdecl sub_8052D20(int a1, int a2)
{
  int v2; // ecx
  int result; // eax
  void *v4; // eax
  int v5; // ecx

  result = *(unsigned __int8 *)(a2 + 44) ^ 1;
  if ( *(_BYTE *)(a2 + 44) != 1 )
  {
    if ( (unsigned int)(*(_DWORD *)a2 - *(_DWORD *)(a2 + 8) + 15) > 0x1E )
    {
      v4 = &loc_8052D98;
      if ( (unsigned int)(*(_DWORD *)(a2 + 4) - *(_DWORD *)(a2 + 12) + 15) > 0x1E )
        v4 = &loc_8052DA2;
      dword_806B2C0 = (int)v4;
      sub_8061764(v2);
      if ( !*(_DWORD *)(a2 + 24) )
      {
        dword_806B298 = (int)&loc_8052DC3;
        sub_806184C(v5);
      }
      result = 0;
    }
    else
    {
      if ( (unsigned int)(*(_DWORD *)(a2 + 4) - *(_DWORD *)(a2 + 12) + 15) > 0x1E && !*(_DWORD *)(a2 + 20) )
      {
        dword_806B34C = (int)&loc_8052DF9;
        sub_80613F7(v2);
      }
      result = 0;
    }
  }
  return result;
}
// 80613F7: using guessed type int __fastcall sub_80613F7(_DWORD);
// 8061764: using guessed type int __fastcall sub_8061764(_DWORD);
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD);
// 806B298: using guessed type int dword_806B298;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B34C: using guessed type int dword_806B34C;

//----- (08052E14) --------------------------------------------------------
int __cdecl sub_8052E14(int a1, _DWORD *a2)
{
  int result; // eax

  if ( a2[10] <= 1u )
  {
    result = a2[5] + a2[6];
    if ( !result )
      result = sub_8052724(a1, a2[7]);
  }
  else
  {
    sub_8052679((pthread_mutex_t *)a2[7]);
    sub_8052D20(a1, a2[7]);
    result = sub_805268F((pthread_mutex_t *)a2[7]);
  }
  return result;
}

//----- (08052E81) --------------------------------------------------------
int __cdecl sub_8052E81(int a1)
{
  pthread_mutex_t *v1; // eax
  int v2; // edx
  int v3; // ecx
  bool v4; // zf
  void *v5; // eax
  pthread_mutex_t *v7; // [esp+1Ch] [ebp-Ch]

  v1 = sub_8052771(a1);
  v7 = v1;
  v4 = v1[1].__nusers == 0;
  v5 = &loc_8052EB8;
  if ( !v4 )
    v5 = &loc_8052ED7;
  dword_806B2E8 = (int)v5;
  sub_8061650(v3, v2);
  sub_805268F(v7);
  return sub_8052724(a1, (int)v7);
}
// 8061650: using guessed type int __fastcall sub_8061650(_DWORD, _DWORD);
// 806B2E8: using guessed type int dword_806B2E8;

//----- (08052F3F) --------------------------------------------------------
void *__usercall start_routine@<eax>(double a1@<st0>, void *a2)
{
  sub_8052FAC(
    *((_DWORD *)a2 + 1),
    a1,
    *(_DWORD *)a2,
    *((_DWORD *)a2 + 1),
    *((_DWORD *)a2 + 2),
    *((_DWORD *)a2 + 3),
    *((_DWORD *)a2 + 4),
    *((FILE **)a2 + 5),
    *((_DWORD *)a2 + 6));
  return 0;
}

//----- (08052FAC) --------------------------------------------------------
int __usercall sub_8052FAC@<eax>(int a1@<ecx>, double a2@<st0>, int a3, int a4, int a5, int a6, int a7, FILE *stream, int a9)
{
  int result; // eax
  pthread_t newthread; // [esp+28h] [ebp-40h]
  unsigned int v11; // [esp+2Ch] [ebp-3Ch]
  unsigned int v12; // [esp+30h] [ebp-38h]
  int v13; // [esp+34h] [ebp-34h]
  unsigned int v14; // [esp+38h] [ebp-30h]
  unsigned int v15; // [esp+3Ch] [ebp-2Ch]
  _DWORD *v16; // [esp+40h] [ebp-28h]
  int arg; // [esp+44h] [ebp-24h]
  unsigned int v18; // [esp+48h] [ebp-20h]
  int v19; // [esp+4Ch] [ebp-1Ch]
  int v20; // [esp+50h] [ebp-18h]
  int v21; // [esp+54h] [ebp-14h]
  FILE *v22; // [esp+58h] [ebp-10h]
  int v23; // [esp+5Ch] [ebp-Ch]

  v11 = *(_DWORD *)(a6 + 20) + *(_DWORD *)(a6 + 24);
  v12 = (unsigned int)a4 >> 1;
  v13 = a4 - ((unsigned int)a4 >> 1);
  arg = a3;
  v18 = (unsigned int)a4 >> 1;
  v19 = a5;
  v20 = *(_DWORD *)(a6 + 32);
  v21 = a7;
  v22 = stream;
  v23 = a9;
  if ( (unsigned int)a4 <= 1 || v11 <= 0x1FFFF || pthread_create(&newthread, 0, (void *(*)(void *))start_routine, &arg) )
  {
    v14 = *(_DWORD *)(a6 + 20);
    v15 = *(_DWORD *)(a6 + 24);
    v16 = (_DWORD *)(-16 * a5 + a3);
    if ( v15 > 1 )
      sub_80520EF(-16 * v14, a2, (_DWORD *)(-16 * v14 + a3), v15, &v16[-4 * (v14 >> 1)], 0);
    if ( v14 > 1 )
      sub_80520EF(a1, a2, (_DWORD *)a3, v14, v16, 0);
    *(_DWORD *)a6 = a3;
    *(_DWORD *)(a6 + 4) = a3 - 16 * v14;
    *(_DWORD *)(a6 + 8) = a3 - 16 * v14;
    *(_DWORD *)(a6 + 12) = a3 + -16 * v14 - 16 * v15;
    sub_8052724(a7, a6);
    result = sub_8052E81(a7);
  }
  else
  {
    sub_8052FAC(
      a3 - 16 * *(_DWORD *)(a6 + 20),
      a2,
      a3 - 16 * *(_DWORD *)(a6 + 20),
      v13,
      a5,
      *(_DWORD *)(a6 + 36),
      a7,
      stream,
      a9);
    result = pthread_join(newthread, 0);
  }
  return result;
}

//----- (080531B0) --------------------------------------------------------
int __usercall sub_80531B0@<eax>(long double a1@<st0>, int ecx0@<ecx>, int a2, int a3, int a4, char *s1)
{
  int v6; // edx
  int v7; // ecx
  int result; // eax
  bool v9; // zf
  int v10; // ecx
  void *v11; // eax
  int v12; // edx
  int v13; // ecx
  int v14; // ecx
  void *v15; // eax
  char v16; // al
  char v17; // ST2A_1
  void *v18; // eax
  char v19; // [esp+21h] [ebp-D7h]
  bool v20; // [esp+23h] [ebp-D5h]
  FILE *stream; // [esp+24h] [ebp-D4h]
  int v22; // [esp+28h] [ebp-D0h]
  unsigned int v23; // [esp+2Ch] [ebp-CCh]
  __int64 v24; // [esp+30h] [ebp-C8h]
  __int64 v25; // [esp+88h] [ebp-70h]
  __int64 v26; // [esp+90h] [ebp-68h]
  __int64 v27; // [esp+E8h] [ebp-10h]

  v19 = 0;
  v22 = 0;
  v23 = a3;
  dword_806B34C = (int)&loc_8053430;
  sub_80613F7(ecx0);
  do
  {
    v20 = strcmp(*(const char **)(8 * v23 + a2), "-") == 0;
    if ( s1 && !strcmp(s1, *(const char **)(8 * v23 + a2)) && v20 != 1 )
    {
      dword_806B2D4 = (int)&loc_8053371;
      sub_80616F8(v7, v6);
    }
    if ( v19 != 1 )
    {
      result = sub_80611C9(1, (int)&v24);
      if ( result )
        return result;
      v19 = 1;
    }
    if ( v20 )
    {
      v9 = sub_80611C9(0, (int)&v26) == 0;
      v11 = &loc_80532E0;
      if ( v9 )
        v11 = &loc_8053322;
      dword_806B298 = (int)v11;
      sub_806184C(v10);
    }
    else
    {
      v9 = sub_806119A(*(_DWORD *)(8 * v23 + a2), (int)&v26) == 0;
      v15 = &loc_8053322;
      if ( !v9 )
        v15 = &loc_805335F;
      dword_806B34C = (int)v15;
      sub_80613F7(v14);
      v13 = v27;
      v12 = HIDWORD(v25);
      if ( v27 == v25 )
      {
        v13 = v26;
        v12 = HIDWORD(v24);
        if ( v26 == v24 )
        {
          v16 = 1;
          goto LABEL_19;
        }
      }
    }
    v16 = 0;
LABEL_19:
    v17 = v16 & 1;
    v18 = &loc_8053393;
    if ( !v17 )
      v18 = &loc_8053429;
    dword_806B2E8 = (int)v18;
    sub_8061650(v13, v12);
    if ( !v22 )
    {
      v22 = sub_804CB88(a1, &stream);
      sub_8051F39(a1, 8 * v23 + a2, 0, 1, stream, v22 + 9);
    }
    *(_DWORD *)(8 * v23 + a2) = v22 + 9;
    *(_DWORD *)(a2 + 8 * v23++ + 4) = v22;
    result = v23;
  }
  while ( v23 < a4 );
  return result;
}
// 80613F7: using guessed type int __fastcall sub_80613F7(_DWORD);
// 8061650: using guessed type int __fastcall sub_8061650(_DWORD, _DWORD);
// 80616F8: using guessed type int __fastcall sub_80616F8(_DWORD, _DWORD);
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD);
// 806B298: using guessed type int dword_806B298;
// 806B2D4: using guessed type int dword_806B2D4;
// 806B2E8: using guessed type int dword_806B2E8;
// 806B34C: using guessed type int dword_806B34C;

//----- (08053449) --------------------------------------------------------
unsigned int __usercall sub_8053449@<eax>(long double a1@<st0>, int a2, unsigned int a3)
{
  char *v3; // ebx
  char *v4; // eax
  unsigned int result; // eax
  unsigned int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a3 )
      break;
    if ( strcmp(*(const char **)(4 * i + a2), "-") && euidaccess(*(_DWORD *)(4 * i + a2), 4) )
    {
      v3 = *(char **)(4 * i + a2);
      v4 = gettext("cannot read");
      sub_804BC7A(a1, (int)v4, v3);
    }
  }
  return result;
}
// 8049E00: using guessed type int __cdecl euidaccess(_DWORD, _DWORD);

//----- (080534E4) --------------------------------------------------------
int __usercall sub_80534E4@<eax>(long double a1@<st0>, int edx0@<edx>, int a3@<ecx>, char *a2)
{
  void *v4; // eax
  char *v5; // eax
  int fd; // [esp+1Ch] [ebp-Ch]

  v4 = &loc_8053509;
  if ( !a2 )
    v4 = &locret_8053561;
  dword_806B2E8 = (int)v4;
  sub_8061650(a3, edx0);
  fd = open64(a2, 524353);
  if ( fd < 0 )
  {
    v5 = gettext("open failed");
    sub_804BC7A(a1, (int)v5, a2);
  }
  return sub_804C835(*(double *)&a1, fd, 1);
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 8061650: using guessed type int __fastcall sub_8061650(_DWORD, _DWORD);
// 806B2E8: using guessed type int dword_806B2E8;

//----- (08053563) --------------------------------------------------------
void __usercall sub_8053563(int a1@<edx>, int a2@<ecx>, long double a3@<st0>, int a4, int a5, int a6, char *s1)
{
  int v7; // eax
  int v8; // esi
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // ebx
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // ecx
  char *v17; // eax
  char *v18; // ebx
  char *v19; // eax
  int v20; // eax
  int v21; // edx
  int v22; // ecx
  bool v23; // zf
  void *v24; // eax
  int v25; // eax
  int v26; // eax
  void *v27; // [esp+28h] [ebp-50h]
  FILE *v28; // [esp+2Ch] [ebp-4Ch]
  int v29; // [esp+30h] [ebp-48h]
  unsigned int v30; // [esp+34h] [ebp-44h]
  int v31; // [esp+38h] [ebp-40h]
  int v32; // [esp+3Ch] [ebp-3Ch]
  unsigned int v33; // [esp+40h] [ebp-38h]
  int v34; // [esp+44h] [ebp-34h]
  unsigned int v35; // [esp+48h] [ebp-30h]
  int v36; // [esp+4Ch] [ebp-2Ch]
  int v37; // [esp+50h] [ebp-28h]
  unsigned int v38; // [esp+54h] [ebp-24h]
  FILE *stream; // [esp+58h] [ebp-20h]
  int v40; // [esp+5Ch] [ebp-1Ch]
  int v41; // [esp+84h] [ebp+Ch]

  dword_806B388 = (int)&loc_805376F;
  sub_8061252(a2, a1);
  do
  {
    v29 = 0;
    v30 = 0;
    while ( a6 - v29 >= (unsigned int)dword_806B444 )
    {
      v7 = sub_804CB88(a3, &v28);
      v32 = v7;
      v8 = v7 + 9;
      v9 = a5;
      if ( dword_806B444 <= (unsigned int)a5 )
        v9 = dword_806B444;
      v33 = sub_8051F39(a3, 8 * v29 + a4, v9, dword_806B444, v28, v8);
      v10 = a5;
      if ( v33 <= a5 )
        v10 = v33;
      a5 -= v10;
      *(_DWORD *)(8 * v30 + a4) = v32 + 9;
      *(_DWORD *)(a4 + 8 * v30 + 4) = v32;
      v29 += v33;
      ++v30;
    }
    v34 = a6 - v29;
    v35 = dword_806B444 - v30 % dword_806B444;
    if ( dword_806B444 - v30 % dword_806B444 < a6 - v29 )
    {
      v36 = v34 - v35 + 1;
      v11 = sub_804CB88(a3, &v28);
      v37 = v11;
      v12 = v11 + 9;
      v13 = a5;
      if ( v36 <= (unsigned int)a5 )
        v13 = v36;
      v38 = sub_8051F39(a3, 8 * v29 + a4, v13, v36, v28, v12);
      v14 = a5;
      if ( v38 <= a5 )
        v14 = v38;
      a5 -= v14;
      *(_DWORD *)(8 * v30 + a4) = v37 + 9;
      v15 = v30++;
      *(_DWORD *)(a4 + 8 * v15 + 4) = v37;
      v29 += v38;
    }
    memmove((void *)(8 * v30 + a4), (const void *)(a4 + 8 * v29), 8 * (a6 - v29));
    a5 += v30;
    a6 += v30 - v29;
  }
  while ( dword_806B444 < (unsigned int)a6 );
  sub_80531B0(a3, v16, a4, a5, a6, s1);
  while ( 1 )
  {
    v31 = sub_8051448(a3, a4, a6, &v27);
    if ( v31 == a6 )
      break;
    if ( (unsigned int)v31 <= 2 )
    {
      v18 = *(char **)(8 * v31 + a4);
      v19 = gettext("open failed");
      sub_804BC7A(a3, (int)v19, v18);
    }
LABEL_27:
    --v31;
    sub_804C75C(a3, *((FILE **)v27 + v31), *(_DWORD *)(8 * v31 + a4));
    v20 = sub_804CA23(a3, &v28, (unsigned int)v31 > 2);
    v40 = v20;
    v23 = v20 == 0;
    v24 = &loc_80538D7;
    if ( v23 )
      v24 = &loc_805386E;
    dword_806B270 = (int)v24;
    sub_8061936(v22, v21);
    v25 = a5;
    if ( v31 <= (unsigned int)a5 )
      v25 = v31;
    sub_805155A(a3, a4, v25, v31, v28, v40 + 9, v27);
    v26 = a5;
    if ( v31 <= (unsigned int)a5 )
      v26 = v31;
    v41 = a5 - v26;
    *(_DWORD *)a4 = v40 + 9;
    *(_DWORD *)(a4 + 4) = v40;
    memmove((void *)(a4 + 8), (const void *)(a4 + 8 * v31), 8 * (a6 - v31));
    a5 = v41 + 1;
    a6 = a6 - v31 + 1;
  }
  stream = sub_804C5A5(a3, s1, "w");
  if ( !stream )
  {
    if ( *__errno_location() != 24 || (unsigned int)v31 <= 2 )
    {
      v17 = gettext("open failed");
      sub_804BC7A(a3, (int)v17, s1);
    }
    goto LABEL_27;
  }
  sub_805155A(a3, a4, a5, a6, stream, (int)s1, v27);
}
// 8061252: using guessed type int __fastcall sub_8061252(_DWORD, _DWORD);
// 8061936: using guessed type int __fastcall sub_8061936(_DWORD, _DWORD);
// 806B270: using guessed type int dword_806B270;
// 806B388: using guessed type int dword_806B388;
// 806B440: using guessed type int dword_806B440;

//----- (08053987) --------------------------------------------------------
unsigned int __usercall sub_8053987@<eax>(long double a1@<st0>, char **a2, unsigned int a3, char *a4, unsigned int a5)
{
  int v5; // ecx
  int v6; // eax
  bool v7; // zf
  void *v8; // eax
  void *v9; // eax
  int v10; // edx
  int v11; // ecx
  int v12; // ecx
  char **v14; // [esp+2Ch] [ebp-BCh]
  FILE *stream; // [esp+40h] [ebp-A8h]
  int v16; // [esp+48h] [ebp-A0h]
  int v17; // [esp+50h] [ebp-98h]
  unsigned int v18; // [esp+54h] [ebp-94h]
  int v19; // [esp+58h] [ebp-90h]
  int v20; // [esp+5Ch] [ebp-8Ch]
  int v21; // [esp+60h] [ebp-88h]
  char *s1; // [esp+64h] [ebp-84h]
  void *v23; // [esp+70h] [ebp-78h]
  void *ptr; // [esp+74h] [ebp-74h]
  int v25; // [esp+80h] [ebp-68h]
  char v26; // [esp+8Ch] [ebp-5Ch]
  unsigned int v27; // [esp+DCh] [ebp-Ch]

  v14 = a2;
  v27 = __readgsdword(0x14u);
  v16 = 0;
  v25 = 0;
  while ( a3 )
  {
    s1 = *v14;
    stream = sub_804C71B(a1, s1, "r");
    if ( a5 <= 1 )
    {
      v17 = 24;
    }
    else
    {
      v18 = 1;
      v19 = 1;
      while ( v18 < a5 )
      {
        v18 *= 2;
        ++v19;
      }
      v17 = 16 * v19;
    }
    if ( !v25 )
    {
      v6 = sub_804D92D(a1, &stream, 1u, (int *)v14, a3, v17);
      sub_804DB2D((int)&ptr, v17, v6);
    }
    v26 = 0;
    ++v14;
    --a3;
    v7 = (unsigned __int8)sub_804DF39((int)s1, v5, a1, (int)&ptr, stream, (int)s1) == 0;
    v8 = &loc_8053CC0;
    if ( !v7 )
      v8 = &loc_8053AA9;
    dword_806B25C = (int)v8;
    sub_80619C7(*(double *)&a1);
    sub_804C75C(a1, stream, (int)s1);
  }
  free(ptr);
  v20 = dword_806C2F1;
  v23 = sub_805E171(v16, 8u);
  v21 = 0;
  v9 = &loc_8053D9E;
  if ( v20 )
    v9 = &loc_8053D2F;
  dword_806B25C = (int)v9;
  sub_80619C7(*(double *)&a1);
  sub_8053563(v10, v11, a1, (int)v23, v16, v16, a4);
  free(v23);
  sub_804C2F1(v12, a1);
  return __readgsdword(0x14u) ^ v27;
}
// 80619C7: using guessed type int __usercall sub_80619C7@<eax>(double@<st0>);
// 806B25C: using guessed type int dword_806B25C;
// 806C2F1: using guessed type int dword_806C2F1;

//----- (08053DF1) --------------------------------------------------------
_DWORD *__cdecl sub_8053DF1(void *src)
{
  _DWORD *result; // eax
  int *i; // [esp+18h] [ebp-10h]
  _DWORD *v3; // [esp+1Ch] [ebp-Ch]

  v3 = sub_805E3FD(src, 0x28u);
  for ( i = &dword_806C265; *i; i = (int *)(*i + 36) )
    ;
  *i = (int)v3;
  result = v3;
  v3[9] = 0;
  return result;
}
// 806C265: using guessed type int dword_806C265;

//----- (08053E3E) --------------------------------------------------------
void __usercall __noreturn sub_8053E3E(long double a1@<st0>, int a2, char *msgid)
{
  void *v3; // esi
  char *v4; // ebx
  char *v5; // eax

  v3 = sub_805BD75(a1, (char *)a2);
  v4 = gettext(msgid);
  v5 = gettext("%s: invalid field specification %s");
  error(2, 0, v5, v4, v3);
  sub_8053E8C(a2);
}

//----- (08053E8C) --------------------------------------------------------
void __cdecl __noreturn sub_8053E8C(int a1)
{
  char *v1; // eax
  int v2; // edx
  int v3; // ecx

  v1 = gettext("options '-%s' are incompatible");
  error(2, 0, v1, a1);
  sub_8053EBD(v3, v2);
}

//----- (08053EBD) --------------------------------------------------------
int __fastcall __noreturn sub_8053EBD(int a1, int a2)
{
  int v2; // ecx
  int v3; // edx
  void *v4; // eax
  int v5; // edx
  int v6; // ecx
  int (*v7)(); // eax
  int v9; // [esp+18h] [ebp-30h]
  char v10; // [esp+1Dh] [ebp-2Bh]
  unsigned int v11; // [esp+3Ch] [ebp-Ch]

  v11 = __readgsdword(0x14u);
  v9 = dword_806C265;
  dword_806B310 = (int)&loc_8053F90;
  sub_8061566(a1, a2);
  v2 = *(unsigned __int8 *)(v9 + 29)
     + *(unsigned __int8 *)(v9 + 28)
     + *(unsigned __int8 *)(v9 + 26)
     + *(unsigned __int8 *)(v9 + 30);
  v3 = *(unsigned __int8 *)(v9 + 27) | *(unsigned __int8 *)(v9 + 32);
  if ( v2 + (v3 | (*(_DWORD *)(v9 + 16) != 0)) > 1 )
  {
    *(_BYTE *)(v9 + 31) = 0;
    *(_BYTE *)(v9 + 25) = *(_BYTE *)(v9 + 31);
    *(_BYTE *)(v9 + 24) = *(_BYTE *)(v9 + 25);
    sub_804F62C(v9, &v10);
    sub_8053E8C((int)&v10);
  }
  v4 = &loc_8053FAF;
  if ( *(_DWORD *)(v9 + 36) )
    v4 = &loc_8053EED;
  dword_806B2D4 = (int)v4;
  sub_80616F8(v2, v3);
  v7 = (int (*)())&loc_8053FD4;
  if ( __readgsdword(0x14u) == v11 )
    v7 = sub_8053FD9;
  dword_806B388 = (int)v7;
  return sub_8061252(v6, v5);
}
// 8053EBD: could not find valid save-restore pair for ebx
// 8053FD9: using guessed type int sub_8053FD9();
// 8061252: using guessed type int __fastcall sub_8061252(_DWORD, _DWORD);
// 8061566: using guessed type int __fastcall sub_8061566(_DWORD, _DWORD);
// 80616F8: using guessed type int __fastcall sub_80616F8(_DWORD, _DWORD);
// 806B2D4: using guessed type int dword_806B2D4;
// 806B310: using guessed type int dword_806B310;
// 806B388: using guessed type int dword_806B388;
// 806C265: using guessed type int dword_806C265;

//----- (08053FD9) --------------------------------------------------------
#error "8053FDA: positive sp value has been found (funcsize=0)"

//----- (08053FDB) --------------------------------------------------------
int __usercall sub_8053FDB@<eax>(long double a1@<st0>, char *nptr, int a3, char *msgid)
{
  int v4; // edx
  int v5; // ecx
  void *v6; // esi
  char *v7; // ebx
  char *v8; // eax
  char *v10; // [esp+Ch] [ebp-2Ch]
  void *v11; // [esp+10h] [ebp-28h]
  int v12; // [esp+24h] [ebp-14h]
  __int64 v13; // [esp+28h] [ebp-10h]

  switch ( sub_805EE45(nptr, (int)&v12, 10, (int)&v13, &locale) )
  {
    case 0:
    case 2:
      *(_DWORD *)a3 = v13;
      v5 = *(_DWORD *)a3;
      v4 = HIDWORD(v13);
      if ( v13 != *(_DWORD *)a3 )
        goto LABEL_3;
      break;
    case 1:
    case 3:
LABEL_3:
      *(_DWORD *)a3 = -1;
      dword_806B310 = (int)&loc_80540D6;
      sub_8061566(v5, v4);
      goto LABEL_4;
    case 4:
LABEL_4:
      if ( msgid )
      {
        v6 = sub_805BD75(a1, nptr);
        v7 = gettext(msgid);
        v8 = gettext("%s: invalid count at start of %s");
        v11 = v6;
        v10 = v7;
        error(2, 0, v8, v7, v6);
      }
      dword_806B338 = (int)&loc_80540D9;
      sub_8061467(*(double *)&a1);
      break;
    default:
      return v12;
  }
  return v12;
}
// 8061467: using guessed type int __usercall sub_8061467@<eax>(double@<st0>);
// 8061566: using guessed type int __fastcall sub_8061566(_DWORD, _DWORD);
// 806B310: using guessed type int dword_806B310;
// 806B338: using guessed type int dword_806B338;

//----- (080540E0) --------------------------------------------------------
int __cdecl sub_80540E0(int sig)
{
  sub_804C310();
  signal(sig, 0);
  return raise(sig);
}

//----- (0805410B) --------------------------------------------------------
_BYTE *__usercall sub_805410B@<eax>(int a1@<edx>, int a2@<ecx>, _BYTE *a3)
{
  void *v3; // eax

  v3 = &loc_8054269;
  if ( *a3 )
    v3 = &loc_8054113;
  dword_806B360 = (int)v3;
  sub_806137F(a2, a1);
  return a3;
}
// 806137F: using guessed type int __fastcall sub_806137F(_DWORD, _DWORD);
// 806B360: using guessed type int dword_806B360;

//----- (0805426E) --------------------------------------------------------
void *__cdecl sub_805426E(void *s)
{
  memset(s, 0, 0x28u);
  *((_DWORD *)s + 2) = -1;
  return s;
}

//----- (0805429E) --------------------------------------------------------
void __usercall main(long double a1@<st0>, int argc, char **argv)
{
  int v3; // ecx
  void *v4; // eax
  unsigned __int8 **v5; // eax
  unsigned __int8 v6; // al
  unsigned __int8 v7; // al
  void *v8; // eax
  bool v9; // zf
  int v10; // edx
  int v11; // ecx
  void *v12; // eax
  unsigned __int64 v13; // rax
  int *v14; // ecx
  int v15; // edx
  int v16; // ecx
  void *v17; // eax
  void *v18; // eax
  void *v19; // eax
  int v20; // ecx
  void *v21; // eax
  int v22; // edx
  int v23; // ecx
  void *v24; // eax
  int v25; // eax
  void *v26; // eax
  int v27; // ecx
  bool v28; // al
  _BOOL4 v29; // edx
  int v30; // edx
  int v31; // ecx
  void *v32; // eax
  void *v33; // eax
  void *v34; // eax
  void *v35; // eax
  char *v36; // eax
  int v37; // eax
  int v38; // ecx
  char *v39; // edx
  void *v40; // eax
  char *v41; // eax
  char *v42; // eax
  void *v43; // eax
  char *v44; // eax
  int v45; // edx
  int v46; // ecx
  void *v47; // eax
  void *v48; // eax
  char *v49; // eax
  char *v50; // edx
  void *v51; // eax
  void *v52; // ebx
  char *v53; // eax
  void *v54; // ebx
  char *v55; // eax
  void *v56; // ebx
  char *v57; // eax
  void *v58; // ebx
  char *v59; // eax
  void *v60; // ebx
  char *v61; // eax
  int v62; // edx
  int v63; // ecx
  int v64; // edx
  int v65; // ecx
  char *v66; // [esp+4h] [ebp-178h]
  char *v67; // [esp+8h] [ebp-174h]
  void *v68; // [esp+Ch] [ebp-170h]
  const char *v69; // [esp+10h] [ebp-16Ch]
  const char *v70; // [esp+14h] [ebp-168h]
  int v71; // [esp+18h] [ebp-164h]
  char v72; // [esp+2Dh] [ebp-14Fh]
  char v73; // [esp+2Eh] [ebp-14Eh]
  char v74; // [esp+2Fh] [ebp-14Dh]
  bool v75; // [esp+30h] [ebp-14Ch]
  bool v76; // [esp+31h] [ebp-14Bh]
  bool v77; // [esp+32h] [ebp-14Ah]
  char v78; // [esp+33h] [ebp-149h]
  bool v79; // [esp+34h] [ebp-148h]
  bool v80; // [esp+35h] [ebp-147h]
  char v81; // [esp+36h] [ebp-146h]
  char v82; // [esp+37h] [ebp-145h]
  char *k; // [esp+38h] [ebp-144h]
  _BYTE *v84; // [esp+3Ch] [ebp-140h]
  int v85; // [esp+40h] [ebp-13Ch]
  const char *v86; // [esp+44h] [ebp-138h]
  int v87; // [esp+48h] [ebp-134h]
  unsigned int v88; // [esp+4Ch] [ebp-130h]
  int *v89; // [esp+50h] [ebp-12Ch]
  char *v90; // [esp+54h] [ebp-128h]
  const char *v91; // [esp+58h] [ebp-124h]
  unsigned int i; // [esp+5Ch] [ebp-120h]
  char *v93; // [esp+60h] [ebp-11Ch]
  unsigned int j; // [esp+64h] [ebp-118h]
  int v95; // [esp+6Ch] [ebp-110h]
  unsigned __int8 **v96; // [esp+70h] [ebp-10Ch]
  FILE *v97; // [esp+78h] [ebp-104h]
  const char *v98; // [esp+7Ch] [ebp-100h]
  char v99; // [esp+90h] [ebp-ECh]
  char s; // [esp+B8h] [ebp-C4h]
  int v101; // [esp+C8h] [ebp-B4h]
  int v102; // [esp+CCh] [ebp-B0h]
  char v103; // [esp+D0h] [ebp-ACh]
  char v104; // [esp+D1h] [ebp-ABh]
  char v105; // [esp+D2h] [ebp-AAh]
  unsigned __int8 v106; // [esp+D3h] [ebp-A9h]
  char v107; // [esp+D4h] [ebp-A8h]
  char v108; // [esp+D5h] [ebp-A7h]
  char v109; // [esp+D6h] [ebp-A6h]
  char v110; // [esp+D7h] [ebp-A5h]
  char v111; // [esp+D8h] [ebp-A4h]
  int longind; // [esp+E0h] [ebp-9Ch]
  int *v113; // [esp+E4h] [ebp-98h]
  int v114; // [esp+164h] [ebp-18h]

  v72 = 0;
  v85 = 0;
  v73 = 0;
  v74 = 0;
  v86 = 0;
  v75 = 0;
  v87 = 0;
  v88 = 0;
  v79 = getenv("POSIXLY_CORRECT") != 0;
  v95 = sub_805A091();
  if ( v95 > 200111 )
  {
    v4 = &loc_805432C;
    if ( v95 <= 200808 )
      v4 = &loc_8054333;
    dword_806B298 = (int)v4;
    sub_806184C(v3);
  }
  v76 = 1;
  v90 = 0;
  v91 = 0;
  sub_805A0EF(*argv);
  v77 = setlocale(6, &locale) != 0;
  bindtextdomain("coreutils", "/home/hwangdz/coreutils/coreutils-8.28/install_m32/share/locale");
  textdomain("coreutils");
  sub_804B8FC(2);
  byte_806BE39 = sub_8057A49(3);
  byte_806BE3A = sub_8057A49(2);
  v5 = (unsigned __int8 **)localeconv();
  v96 = v5;
  v6 = sub_804B90F(**v5);
  dword_806BE31 = v6;
  if ( !v6 || (*v96)[1] )
    dword_806BE31 = 46;
  v7 = sub_804B90F(*v96[1]);
  dword_806BE35 = v7;
  if ( !v7 || v96[1][1] )
    dword_806BE35 = -1;
  byte_806C264 = 0;
  sub_804CF68();
  sigemptyset(&set);
  for ( i = 0; i <= 0xA; ++i )
  {
    sigaction(sig[i], 0, (struct sigaction *)&longind);
    v8 = &loc_80544BF;
    if ( longind == 1 )
      v8 = &loc_80544DA;
    dword_806B25C = (int)v8;
    sub_80619C7(*(double *)&a1);
    sigaddset(&set, sig[i]);
  }
  longind = (int)sub_80540E0;
  qmemcpy(&v113, &set, 0x80u);
  v114 = 0;
  for ( i = 0; i <= 0xA; ++i )
  {
    v9 = sigismember(&set, sig[i]) == 0;
    v12 = &loc_8054557;
    if ( v9 )
      v12 = &loc_805457D;
    dword_806B388 = (int)v12;
    sub_8061252(v11, v10);
    sigaction(sig[i], (const struct sigaction *)&longind, 0);
  }
  signal(17, 0);
  sub_806116B((int)sub_804C348);
  sub_805426E(&s);
  *(_DWORD *)&s = -1;
  v89 = (int *)sub_805E171(argc, 4u);
  while ( 1 )
  {
    while ( 1 )
    {
      longind = -1;
      LODWORD(v13) = &loc_8054605;
      if ( v85 == -1 )
        LODWORD(v13) = &loc_8054756;
      dword_806B388 = v13;
      sub_8061252(v14, HIDWORD(v13));
      v17 = &loc_8054625;
      if ( !v79 )
        v17 = &loc_805471E;
      dword_806B310 = (int)v17;
      sub_8061566(v16, v15);
      if ( v88 )
        break;
LABEL_39:
      v85 = getopt_long(argc, argv, "-bcCdfghik:mMno:rRsS:t:T:uVy:z", &longopts, &longind);
      if ( v85 == -1 )
        goto LABEL_40;
      switch ( v85 )
      {
        case 4294967165:
          v71 = 0;
          v70 = "Paul Eggert";
          v69 = "Mike Haertel";
          sub_805E0D1(stdout, (int)"sort", (int)"GNU coreutils", off_806B45C, "Mike Haertel", "Paul Eggert", 0);
          exit(0);
          return;
        case 4294967166:
          goto LABEL_123;
        case 1:
          k = 0;
          v26 = &loc_80547F6;
          if ( *optarg != 43 )
            v26 = &loc_8054AB9;
          dword_806B25C = (int)v26;
          sub_80619C7(*(double *)&a1);
          v28 = optind != argc && *argv[optind] == 45 && (unsigned int)(argv[optind][1] - 48) <= 9;
          v80 = v28;
          v29 = v76;
          if ( v28 && v79 != 1 )
          {
            dword_806B388 = (int)&loc_805488C;
            sub_8061252(v27, v76);
          }
          v76 = v29 != 0;
          if ( v29 != 0 )
          {
            k = (char *)sub_805426E(&v99);
            v84 = (_BYTE *)sub_8053FDB(a1, optarg + 1, (int)k, 0);
            if ( v84 && *v84 == 46 )
              v84 = (_BYTE *)sub_8053FDB(a1, v84 + 1, (int)(k + 4), 0);
            if ( !*(_DWORD *)k && !*((_DWORD *)k + 1) )
              *(_DWORD *)k = -1;
            if ( v84 )
            {
              v67 = 0;
              v66 = k;
              v9 = *sub_805410B(v30, v31, v84) == 0;
              v32 = &loc_8054974;
              if ( v9 )
                v32 = &loc_8054981;
              dword_806B2FC = (int)v32;
              sub_80615DC();
            }
            k = 0;
          }
          v33 = &loc_8054AD9;
          if ( k )
            v33 = &loc_8054AFD;
          dword_806B25C = (int)v33;
          sub_80619C7(*(double *)&a1);
          LODWORD(v13) = v88++;
          HIDWORD(v13) = &v89[v13];
          *(_DWORD *)HIDWORD(v13) = optarg;
          continue;
        case 67:
        case 99:
          goto LABEL_75;
        case 77:
        case 82:
        case 86:
        case 98:
        case 100:
        case 102:
        case 103:
        case 104:
        case 105:
        case 110:
        case 114:
          goto LABEL_71;
        case 83:
          goto LABEL_102;
        case 84:
          sub_804CD95((int)optarg);
          continue;
        case 107:
          k = (char *)sub_805426E(&v99);
          v84 = (_BYTE *)sub_8053FDB(a1, optarg, (int)k, "invalid number at field start");
          v37 = *(_DWORD *)k;
          v38 = *(_DWORD *)k - 1;
          v39 = k;
          *(_DWORD *)k = v38;
          v9 = v37 == 0;
          v40 = &loc_8054D31;
          if ( !v9 )
            v40 = &unk_8054D46;
          dword_806B2E8 = (int)v40;
          sub_8061650(v38, v39);
          sub_8053E3E(a1, (int)optarg, "field number is zero");
          return;
        case 109:
          v74 = 1;
          continue;
        case 111:
          if ( v91 && strcmp(v91, optarg) )
          {
            v41 = gettext("multiple output files specified");
            error(2, 0, v41);
          }
          v91 = optarg;
          continue;
        case 115:
          byte_806C262 = 1;
          dword_806B2D4 = (int)&loc_80552A2;
          sub_80616F8(v14, HIDWORD(v13));
LABEL_102:
          v13 = sub_804D3F8(*(double *)&a1, longind, (char)v85, optarg);
          continue;
        case 116:
          v78 = *optarg;
          v43 = &loc_8055022;
          if ( v78 )
            v43 = &loc_8055046;
          dword_806B25C = (int)v43;
          sub_80619C7(*(double *)&a1);
          v44 = gettext("empty tab");
          error(2, 0, v44);
          if ( optarg[1] )
          {
            v9 = strcmp(optarg, "\\0") == 0;
            v47 = &loc_8055087;
            if ( !v9 )
              v47 = &loc_805508E;
            dword_806B284 = (int)v47;
            sub_80618C2();
            v78 = 0;
          }
          v48 = &loc_80550EA;
          if ( dword_806B440 == 128 )
            v48 = &loc_805511C;
          dword_806B324 = (int)v48;
          sub_80614D5(v46, v45);
          HIDWORD(v13) = v78;
          if ( v78 != dword_806B440 )
          {
            v49 = gettext("incompatible tabs");
            error(2, 0, v49);
          }
          dword_806B440 = v78;
          continue;
        case 117:
          byte_806C263 = 1;
          continue;
        case 121:
          v50 = argv[optind + 0x3FFFFFFF];
          v51 = &loc_80551C2;
          if ( v50 != optarg )
            v51 = &loc_805521C;
          dword_806B324 = (int)v51;
          sub_80614D5(v14, v50);
          v93 = optarg;
          dword_806B2FC = (int)&loc_80551E7;
          sub_80615DC();
          do
            ++v93;
          while ( (unsigned int)(*v93 - 48) <= 9 );
          LODWORD(v13) = *v93 != 0;
          HIDWORD(v13) = optind - v13;
          optind -= v13;
          continue;
        case 122:
          byte_806B3BC = 0;
          dword_806B20C = (int)&loc_80552A2;
          sub_8061BBC(v14, HIDWORD(v13));
LABEL_123:
          sub_804BCF1(0);
          return;
        case 128:
          goto LABEL_72;
        case 129:
          if ( s1 && strcmp(s1, optarg) )
          {
            v36 = gettext("multiple compress programs specified");
            error(2, 0, v36);
          }
          s1 = optarg;
          continue;
        case 130:
          byte_806C26D = 1;
          dword_806B2C0 = (int)&loc_80552A2;
          sub_8061764(v14);
          goto LABEL_86;
        case 131:
LABEL_86:
          v90 = optarg;
          break;
        case 132:
          sub_804D159(a1, longind, v85, optarg);
          return;
        case 133:
          if ( v86 && strcmp(v86, optarg) )
          {
            v42 = gettext("multiple random sources specified");
            error(2, 0, v42);
          }
          v86 = optarg;
          break;
        case 134:
          v85 = byte_8063240[sub_8055E40(
                               a1,
                               (int)"--sort",
                               optarg,
                               (int)&off_8063224,
                               (int)byte_8063240,
                               1u,
                               off_806B460)];
LABEL_71:
          v81 = v85;
          v82 = 0;
          v67 = (char *)2;
          v66 = &s;
          sub_805410B(SHIDWORD(v13), (int)v14, &v81);
          dword_806B374 = (int)&loc_80552A2;
          sub_80612DD();
LABEL_72:
          v34 = &loc_8054BBE;
          if ( !optarg )
            v34 = &loc_8054C01;
          dword_806B374 = (int)v34;
          sub_80612DD();
          v85 = aCccgeneralNume[sub_8055E40(
                                  a1,
                                  (int)"--check",
                                  optarg,
                                  (int)off_80631DC,
                                  (int)"CCcgeneral-numeric",
                                  1u,
                                  off_806B460)];
LABEL_75:
          if ( v73 )
          {
            v35 = &loc_8054C35;
            if ( v73 == v85 )
              v35 = &loc_8054C41;
            dword_806B2C0 = (int)v35;
            sub_8061764(v14);
            sub_8053E8C((int)"cC");
          }
          v73 = v85;
          break;
        case 135:
          sub_804D687(longind, (char)v85, (int)optarg);
          return;
        default:
          sub_804BCF1(2);
          return;
      }
    }
    if ( v76 == 1 && !v73 && optind != argc )
    {
      v18 = &loc_805468C;
      if ( *argv[optind] != 45 )
        v18 = &loc_8054756;
      dword_806B284 = (int)v18;
      sub_80618C2();
      v19 = &loc_80546C2;
      if ( argv[optind][1] != 111 )
        v19 = &loc_8054756;
      dword_806B220 = (int)v19;
      sub_8061B42();
      v21 = &loc_80546F8;
      if ( argv[optind][2] )
        v21 = &loc_805471E;
      dword_806B298 = (int)v21;
      sub_806184C(v20);
      v24 = &loc_805471E;
      if ( optind + 1 == argc )
        v24 = &loc_8054756;
      dword_806B20C = (int)v24;
      sub_8061BBC(v23, v22);
      goto LABEL_39;
    }
LABEL_40:
    if ( argc <= optind )
    {
      if ( v90 )
      {
        if ( v88 )
        {
          v66 = (char *)*v89;
          v52 = sub_805B9E2(a1, 4, v66);
          v53 = gettext("extra operand %s");
          v68 = v52;
          error(0, 0, v53, v52);
          v67 = gettext("file operands cannot be combined with --files0-from");
          fprintf(stderr, "%s\n", v67);
          sub_804BCF1(2);
        }
        v97 = sub_804C71B(a1, v90, "r");
        sub_805CCFB(&longind);
        if ( !sub_805D034(v97, (int)&longind) )
        {
          v54 = sub_805B9E2(a1, 4, v90);
          v55 = gettext("cannot read file names from %s");
          v68 = v54;
          error(2, 0, v55, v54);
        }
        sub_804C75C(a1, v97, (int)v90);
        if ( longind )
        {
          free(v89);
          v89 = v113;
          v88 = longind;
          for ( j = 0; j < v88; ++j )
          {
            if ( !strcmp((const char *)v89[j], "-") )
            {
              v66 = (char *)v89[j];
              v56 = sub_805B9E2(a1, 4, v66);
              v57 = gettext("when reading file names from stdin, no file name of %s allowed");
              v68 = v56;
              error(2, 0, v57, v56);
            }
            HIDWORD(v13) = 4 * j;
            if ( !*(_BYTE *)v89[j] )
            {
              v98 = (const char *)(j + 1);
              v58 = sub_805BB3D(a1, 0, 3, v90);
              v59 = gettext("%s:%lu: invalid zero-length file name");
              v69 = v98;
              v68 = v58;
              error(2, 0, v59, v58, v98);
            }
          }
        }
        else
        {
          v60 = sub_805B9E2(a1, 4, v90);
          v61 = gettext("no input from %s");
          v68 = v60;
          error(2, 0, v61, v60);
        }
      }
      for ( k = (char *)dword_806C265; k; k = (char *)*((_DWORD *)k + 9) )
      {
        if ( (unsigned __int8)sub_804F56F(SHIDWORD(v13), (int)v14, (int)k) && k[31] != 1 )
        {
          *((_DWORD *)k + 4) = v101;
          *((_DWORD *)k + 5) = v102;
          k[24] = v103;
          k[25] = v104;
          k[30] = v109;
          k[26] = v105;
          k[28] = v107;
          k[29] = v108;
          k[32] = v111;
          k[27] = v106;
          k[31] = v110;
        }
        HIDWORD(v13) = v75;
        v75 = (v75 | (unsigned __int8)k[27]) != 0;
      }
      LODWORD(v13) = &loc_805565A;
      if ( dword_806C265 )
        LODWORD(v13) = &loc_805569F;
      dword_806B2AC = v13;
      sub_80617DA(v14, HIDWORD(v13));
      if ( (unsigned __int8)sub_804F56F(v62, v63, (int)&s) ^ 1 )
      {
        v72 = 1;
        sub_8053DF1(&s);
        v64 = v75;
        v75 = (v75 | v106) != 0;
      }
      sub_8053EBD(v65, v64);
    }
    v25 = v88++;
    v14 = &v89[v25];
    LODWORD(v13) = optind++;
    HIDWORD(v13) = 4 * v13;
    *v14 = (int)argv[(_DWORD)v13];
  }
}
// 8061252: using guessed type int __fastcall sub_8061252(_DWORD, _DWORD);
// 80612DD: using guessed type int sub_80612DD(void);
// 80614D5: using guessed type int __fastcall sub_80614D5(_DWORD, _DWORD);
// 8061566: using guessed type int __fastcall sub_8061566(_DWORD, _DWORD);
// 80615DC: using guessed type int sub_80615DC(void);
// 8061650: using guessed type int __fastcall sub_8061650(_DWORD, _DWORD);
// 80616F8: using guessed type int __fastcall sub_80616F8(_DWORD, _DWORD);
// 8061764: using guessed type int __fastcall sub_8061764(_DWORD);
// 80617DA: using guessed type int __fastcall sub_80617DA(_DWORD, _DWORD);
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD);
// 80618C2: using guessed type int sub_80618C2(void);
// 80619C7: using guessed type int __usercall sub_80619C7@<eax>(double@<st0>);
// 8061B42: using guessed type int sub_8061B42(void);
// 8061BBC: using guessed type int __fastcall sub_8061BBC(_DWORD, _DWORD);
// 80631DC: using guessed type char *off_80631DC[3];
// 8063224: using guessed type void *off_8063224;
// 806B20C: using guessed type int dword_806B20C;
// 806B220: using guessed type int dword_806B220;
// 806B25C: using guessed type int dword_806B25C;
// 806B284: using guessed type int dword_806B284;
// 806B298: using guessed type int dword_806B298;
// 806B2AC: using guessed type int dword_806B2AC;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B2D4: using guessed type int dword_806B2D4;
// 806B2E8: using guessed type int dword_806B2E8;
// 806B2FC: using guessed type int dword_806B2FC;
// 806B310: using guessed type int dword_806B310;
// 806B324: using guessed type int dword_806B324;
// 806B374: using guessed type int dword_806B374;
// 806B388: using guessed type int dword_806B388;
// 806B3BC: using guessed type char byte_806B3BC;
// 806B440: using guessed type int dword_806B440;
// 806B500: using guessed type int optind;
// 806BE31: using guessed type int dword_806BE31;
// 806BE35: using guessed type int dword_806BE35;
// 806BE39: using guessed type char byte_806BE39;
// 806BE3A: using guessed type char byte_806BE3A;
// 806C262: using guessed type char byte_806C262;
// 806C263: using guessed type char byte_806C263;
// 806C264: using guessed type char byte_806C264;
// 806C265: using guessed type int dword_806C265;
// 806C26D: using guessed type char byte_806C26D;

//----- (08055B3B) --------------------------------------------------------
void __noreturn sub_8055B3B()
{
  sub_804BCF1(1);
}

//----- (08055B4F) --------------------------------------------------------
int __cdecl sub_8055B4F(char *s, int a2, int a3, size_t a4)
{
  int v4; // ecx
  int v5; // edx
  void *v7; // eax
  char v8; // [esp+13h] [ebp-15h]
  signed int i; // [esp+14h] [ebp-14h]
  signed int v10; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]

  v10 = -1;
  v8 = 0;
  n = strlen(s);
  for ( i = 0; *(_DWORD *)(4 * i + a2); ++i )
  {
    if ( !strncmp(*(const char **)(4 * i + a2), s, n) )
    {
      if ( strlen(*(const char **)(4 * i + a2)) == n )
        return i;
      if ( v10 == -1 )
      {
        v10 = i;
      }
      else
      {
        v7 = &loc_8055BFC;
        if ( !a3 )
          v7 = &loc_8055C30;
        dword_806B324 = (int)v7;
        sub_80614D5(v4, v5);
        if ( memcmp((const void *)(a3 + a4 * v10), (const void *)(i * a4 + a3), a4) )
          v8 = 1;
      }
    }
  }
  if ( v8 )
  {
    dword_806B310 = (int)&locret_8055C76;
    sub_8061566(v4, 4 * i);
  }
  return v10;
}
// 80614D5: using guessed type int __fastcall sub_80614D5(_DWORD, _DWORD);
// 8061566: using guessed type int __fastcall sub_8061566(_DWORD, _DWORD);
// 806B310: using guessed type int dword_806B310;
// 806B324: using guessed type int dword_806B324;

//----- (08055C78) --------------------------------------------------------
void __usercall sub_8055C78(long double a1@<st0>, char *a2, char *a3, int a4)
{
  char *v4; // eax
  char *format; // ST2C_4
  void *v6; // ebx
  void *v7; // eax

  if ( a4 == -1 )
    v4 = gettext("invalid argument %s for %s");
  else
    v4 = gettext("ambiguous argument %s for %s");
  format = v4;
  v6 = sub_805BD53(a1, 1, a2);
  v7 = sub_805B967(a1, 0, 8, a3);
  error(0, 0, format, v7, v6);
}

//----- (08055CFB) --------------------------------------------------------
int __usercall sub_8055CFB@<eax>(long double a1@<st0>, int a2, int a3, size_t n)
{
  FILE *v4; // ebx
  char *v5; // eax
  bool v6; // zf
  int v7; // ecx
  void *v8; // eax
  const void *v10; // [esp+4h] [ebp-24h]
  void *v11; // [esp+8h] [ebp-20h]
  int i; // [esp+18h] [ebp-10h]
  void *s1; // [esp+1Ch] [ebp-Ch]

  s1 = 0;
  v4 = stderr;
  v5 = gettext("Valid arguments are:");
  fputs_unlocked(v5, v4);
  for ( i = 0; *(_DWORD *)(4 * i + a2); ++i )
  {
    if ( i )
    {
      v10 = (const void *)(a3 + i * n);
      v6 = memcmp(s1, v10, n) == 0;
      v8 = &loc_8055D7A;
      if ( v6 )
        v8 = &loc_8055DD5;
      dword_806B34C = (int)v8;
      sub_80613F7(v7);
    }
    v11 = sub_805BD75(a1, *(char **)(4 * i + a2));
    fprintf(stderr, "\n  - %s", v11);
    s1 = (void *)(i * n + a3);
    dword_806B220 = (int)&loc_8055E08;
    sub_8061B42();
    v11 = sub_805BD75(a1, *(char **)(4 * i + a2));
    fprintf(stderr, ", %s", v11);
  }
  return putc_unlocked(10, stderr);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 80613F7: using guessed type int __fastcall sub_80613F7(_DWORD);
// 8061B42: using guessed type int sub_8061B42(void);
// 806B220: using guessed type int dword_806B220;
// 806B34C: using guessed type int dword_806B34C;

//----- (08055E40) --------------------------------------------------------
int __usercall sub_8055E40@<eax>(long double a1@<st0>, int a2, char *s, int a4, int a5, size_t n, int a7)
{
  int v8; // [esp+1Ch] [ebp-Ch]

  v8 = sub_8055B4F(s, a4, a5, n);
  if ( v8 >= 0 )
    return v8;
  sub_8055C78(a1, (char *)a2, s, v8);
  sub_8055CFB(a1, a4, a5, n);
  ((void (*)(void))a7)();
  return -1;
}

//----- (08055F55) --------------------------------------------------------
int __usercall sub_8055F55@<eax>(long double a1@<st0>)
{
  bool v1; // zf
  void *v2; // eax
  char *v3; // ebx
  int v4; // eax
  int v5; // edx
  int v6; // ecx
  int v7; // eax
  int result; // eax
  char *v9; // [esp+Ch] [ebp-2Ch]
  char *v10; // [esp+10h] [ebp-28h]
  char *v11; // [esp+2Ch] [ebp-Ch]

  if ( sub_806015F(*(double *)&a1, stdout) )
  {
    if ( byte_806C3B9 == 1 )
    {
      v1 = *__errno_location() == 32;
      v2 = &loc_8055FA4;
      if ( v1 )
        v2 = &loc_805603F;
      dword_806B2FC = (int)v2;
      sub_80615DC();
    }
    v11 = gettext("write error");
    if ( dword_806C3B5 )
    {
      v3 = (char *)sub_805BB00(a1, (char *)dword_806C3B5);
      v4 = *__errno_location();
      v10 = v11;
      v9 = v3;
      error(0, v4, "%s: %s", v3, v11);
      dword_806B2AC = (int)&loc_8056032;
      sub_80617DA(v6, v5);
    }
    v7 = *__errno_location();
    v9 = v11;
    error(0, v7, "%s", v11);
    _exit(status);
  }
  result = sub_806015F(*(double *)&a1, stderr);
  if ( result )
    _exit(status);
  return result;
}
// 80615DC: using guessed type int sub_80615DC(void);
// 80617DA: using guessed type int __fastcall sub_80617DA(_DWORD, _DWORD);
// 806B2AC: using guessed type int dword_806B2AC;
// 806B2FC: using guessed type int dword_806B2FC;
// 806C3B5: using guessed type int dword_806C3B5;
// 806C3B9: using guessed type char byte_806C3B9;

//----- (08056063) --------------------------------------------------------
_DWORD *__cdecl sub_8056063(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 1732584193;
  a1[1] = -271733879;
  a1[2] = -1732584194;
  a1[3] = 271733878;
  a1[5] = 0;
  a1[4] = a1[5];
  result = a1;
  a1[6] = 0;
  return result;
}

//----- (080560AF) --------------------------------------------------------
_DWORD *__cdecl sub_80560AF(_DWORD *a1, int a2)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = a2;
  return result;
}

//----- (080560BC) --------------------------------------------------------
_DWORD *__cdecl sub_80560BC(int *a1, _DWORD *a2)
{
  sub_80560AF(a2, *a1);
  sub_80560AF(a2 + 1, a1[1]);
  sub_80560AF(a2 + 2, a1[2]);
  sub_80560AF(a2 + 3, a1[3]);
  return a2;
}

//----- (08056129) --------------------------------------------------------
_DWORD *__usercall sub_8056129@<eax>(double a1@<st0>, int *a2, _DWORD *a3)
{
  unsigned int v4; // [esp+18h] [ebp-10h]

  v4 = a2[6];
  if ( v4 <= 0x37 )
  {
    dword_806B338 = (int)&loc_805615F;
    sub_8061467(a1);
  }
  a2[4] += v4;
  if ( a2[4] < v4 )
    ++a2[5];
  a2[37] = 8 * a2[4];
  a2[38] = *((_QWORD *)a2 + 2) >> 29;
  memcpy((char *)a2 + v4 + 28, &unk_8064130, 120 - v4);
  sub_805661D(a2 + 7, 0x80u, a2);
  return sub_80560BC(a2, a3);
}
// 8061467: using guessed type int __usercall sub_8061467@<eax>(double@<st0>);
// 806B338: using guessed type int dword_806B338;

//----- (08056417) --------------------------------------------------------
int __usercall sub_8056417@<eax>(int a1@<edx>, int a2@<ecx>, void *src, size_t a4, int a5)
{
  int result; // eax
  int v6; // eax
  int *v7; // eax
  size_t v8; // ST14_4
  size_t v9; // [esp+14h] [ebp-14h]
  int v10; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]

  result = *(_DWORD *)(a5 + 24);
  if ( result )
  {
    v10 = *(_DWORD *)(a5 + 24);
    v6 = a4;
    if ( 128 - v10 <= a4 )
      v6 = 128 - v10;
    n = v6;
    memcpy((void *)(v10 + a5 + 28), src, v6);
    a1 = n + *(_DWORD *)(a5 + 24);
    *(_DWORD *)(a5 + 24) = a1;
    if ( *(_DWORD *)(a5 + 24) > 0x40u )
    {
      sub_805661D((int *)(a5 + 28), *(_DWORD *)(a5 + 24) & 0xFFFFFFC0, (int *)a5);
      *(_DWORD *)(a5 + 24) &= 0x3Fu;
      memcpy((void *)(a5 + 28), (const void *)(a5 + 28 + ((v10 + n) & 0xFFFFFFC0)), *(_DWORD *)(a5 + 24));
    }
    src = (char *)src + n;
    result = n;
    a4 -= n;
  }
  if ( a4 > 0x3F )
  {
    if ( (unsigned __int8)src & 3 )
    {
      while ( a4 > 0x40 )
      {
        v7 = (int *)memcpy((void *)(a5 + 28), src, 0x40u);
        sub_805661D(v7, 0x40u, (int *)a5);
        src = (char *)src + 64;
        a4 -= 64;
      }
      dword_806B234 = (int)&loc_8056592;
      sub_8061AC8(a2, a1);
    }
    sub_805661D((int *)src, a4 & 0xFFFFFFC0, (int *)a5);
    result = a4 & 0xFFFFFFC0;
    src = (char *)src + (a4 & 0xFFFFFFC0);
    a4 &= 0x3Fu;
  }
  if ( a4 )
  {
    v8 = *(_DWORD *)(a5 + 24);
    memcpy((void *)(v8 + a5 + 28), src, a4);
    v9 = a4 + v8;
    if ( v9 > 0x3F )
    {
      sub_805661D((int *)(a5 + 28), 0x40u, (int *)a5);
      v9 -= 64;
      memcpy((void *)(a5 + 28), (const void *)(a5 + 92), v9);
    }
    result = a5;
    *(_DWORD *)(a5 + 24) = v9;
  }
  return result;
}
// 8061AC8: using guessed type double __fastcall sub_8061AC8(_DWORD, _DWORD);
// 806B234: using guessed type int dword_806B234;

//----- (0805661D) --------------------------------------------------------
int *__cdecl sub_805661D(int *a1, unsigned int a2, int *a3)
{
  int *result; // eax
  int *v4; // [esp+Ch] [ebp-74h]
  int v5; // [esp+10h] [ebp-70h]
  int v6; // [esp+14h] [ebp-6Ch]
  int v7; // [esp+18h] [ebp-68h]
  int v8; // [esp+1Ch] [ebp-64h]
  unsigned int v9; // [esp+20h] [ebp-60h]
  unsigned int v10; // [esp+24h] [ebp-5Ch]
  unsigned int v11; // [esp+28h] [ebp-58h]
  int *v12; // [esp+2Ch] [ebp-54h]
  int v13; // [esp+30h] [ebp-50h]
  int v14; // [esp+34h] [ebp-4Ch]
  int v15; // [esp+38h] [ebp-48h]
  int v16; // [esp+3Ch] [ebp-44h]
  int v17; // [esp+40h] [ebp-40h]
  int v18; // [esp+44h] [ebp-3Ch]
  int v19; // [esp+48h] [ebp-38h]
  int v20; // [esp+4Ch] [ebp-34h]
  int v21; // [esp+50h] [ebp-30h]
  int v22; // [esp+54h] [ebp-2Ch]
  int v23; // [esp+58h] [ebp-28h]
  int v24; // [esp+5Ch] [ebp-24h]
  int v25; // [esp+60h] [ebp-20h]
  int v26; // [esp+64h] [ebp-1Ch]
  int v27; // [esp+68h] [ebp-18h]
  int v28; // [esp+6Ch] [ebp-14h]
  int v29; // [esp+70h] [ebp-10h]
  int v30; // [esp+74h] [ebp-Ch]
  int v31; // [esp+78h] [ebp-8h]
  int v32; // [esp+7Ch] [ebp-4h]
  int savedregs; // [esp+80h] [ebp+0h]

  v4 = a1;
  v9 = a2 >> 2;
  v10 = (unsigned int)&a1[a2 >> 2];
  v5 = *a3;
  v6 = a3[1];
  v7 = a3[2];
  v8 = a3[3];
  v11 = a2;
  a3[4] += a2;
  a3[5] += a3[4] < v11;
  dword_806B2FC = (int)&loc_80572C8;
  sub_80615DC();
  do
  {
    v13 = v5;
    v14 = v6;
    v15 = v7;
    v16 = v8;
    v12 = &v18;
    v17 = *v4;
    v5 = (v8 ^ v6 & (v7 ^ v8)) + v17 + v5 - 680876936;
    ++v4;
    v5 = __ROR4__(v5, 25);
    v5 += v6;
    v12 = &v19;
    v18 = *v4;
    v8 = (v7 ^ v5 & (v6 ^ v7)) + v18 + v8 - 389564586;
    ++v4;
    v8 = __ROR4__(v8, 20);
    v8 += v5;
    v12 = &v20;
    v19 = *v4;
    v7 += (v6 ^ v8 & (v5 ^ v6)) + v19 + 606105819;
    ++v4;
    v7 = __ROR4__(v7, 15);
    v7 += v8;
    v12 = &v21;
    v20 = *v4;
    v6 = (v5 ^ v7 & (v8 ^ v5)) + v20 + v6 - 1044525330;
    ++v4;
    v6 = __ROR4__(v6, 10);
    v6 += v7;
    v12 = &v22;
    v21 = *v4;
    v5 = (v8 ^ v6 & (v7 ^ v8)) + v21 + v5 - 176418897;
    ++v4;
    v5 = __ROR4__(v5, 25);
    v5 += v6;
    v12 = &v23;
    v22 = *v4;
    v8 += (v7 ^ v5 & (v6 ^ v7)) + v22 + 1200080426;
    ++v4;
    v8 = __ROR4__(v8, 20);
    v8 += v5;
    v12 = &v24;
    v23 = *v4;
    v7 = (v6 ^ v8 & (v5 ^ v6)) + v23 + v7 - 1473231341;
    ++v4;
    v7 = __ROR4__(v7, 15);
    v7 += v8;
    v12 = &v25;
    v24 = *v4;
    v6 = (v5 ^ v7 & (v8 ^ v5)) + v24 + v6 - 45705983;
    ++v4;
    v6 = __ROR4__(v6, 10);
    v6 += v7;
    v12 = &v26;
    v25 = *v4;
    v5 += (v8 ^ v6 & (v7 ^ v8)) + v25 + 1770035416;
    ++v4;
    v5 = __ROR4__(v5, 25);
    v5 += v6;
    v12 = &v27;
    v26 = *v4;
    v8 = (v7 ^ v5 & (v6 ^ v7)) + v26 + v8 - 1958414417;
    ++v4;
    v8 = __ROR4__(v8, 20);
    v8 += v5;
    v12 = &v28;
    v27 = *v4;
    v7 = (v6 ^ v8 & (v5 ^ v6)) + v27 + v7 - 42063;
    ++v4;
    v7 = __ROR4__(v7, 15);
    v7 += v8;
    v12 = &v29;
    v28 = *v4;
    v6 = (v5 ^ v7 & (v8 ^ v5)) + v28 + v6 - 1990404162;
    ++v4;
    v6 = __ROR4__(v6, 10);
    v6 += v7;
    v12 = &v30;
    v29 = *v4;
    v5 += (v8 ^ v6 & (v7 ^ v8)) + v29 + 1804603682;
    ++v4;
    v5 = __ROR4__(v5, 25);
    v5 += v6;
    v12 = &v31;
    v30 = *v4;
    v8 = (v7 ^ v5 & (v6 ^ v7)) + v30 + v8 - 40341101;
    ++v4;
    v8 = __ROR4__(v8, 20);
    v8 += v5;
    v12 = &v32;
    v31 = *v4;
    v7 = (v6 ^ v8 & (v5 ^ v6)) + v31 + v7 - 1502002290;
    ++v4;
    v7 = __ROR4__(v7, 15);
    v7 += v8;
    v12 = &savedregs;
    v32 = *v4;
    v6 += (v5 ^ v7 & (v8 ^ v5)) + v32 + 1236535329;
    ++v4;
    v6 = __ROR4__(v6, 10);
    v6 += v7;
    v5 = v18 + (v7 ^ v8 & (v6 ^ v7)) + v5 - 165796510;
    v5 = __ROR4__(v5, 27);
    v5 += v6;
    v8 = v23 + (v6 ^ v7 & (v5 ^ v6)) + v8 - 1069501632;
    v8 = __ROR4__(v8, 23);
    v8 += v5;
    v7 += v28 + (v5 ^ v6 & (v8 ^ v5)) + 643717713;
    v7 = __ROR4__(v7, 18);
    v7 += v8;
    v6 = v17 + (v8 ^ v5 & (v7 ^ v8)) + v6 - 373897302;
    v6 = __ROR4__(v6, 12);
    v6 += v7;
    v5 = v22 + (v7 ^ v8 & (v6 ^ v7)) + v5 - 701558691;
    v5 = __ROR4__(v5, 27);
    v5 += v6;
    v8 += v27 + (v6 ^ v7 & (v5 ^ v6)) + 38016083;
    v8 = __ROR4__(v8, 23);
    v8 += v5;
    v7 = v32 + (v5 ^ v6 & (v8 ^ v5)) + v7 - 660478335;
    v7 = __ROR4__(v7, 18);
    v7 += v8;
    v6 = v21 + (v8 ^ v5 & (v7 ^ v8)) + v6 - 405537848;
    v6 = __ROR4__(v6, 12);
    v6 += v7;
    v5 += v26 + (v7 ^ v8 & (v6 ^ v7)) + 568446438;
    v5 = __ROR4__(v5, 27);
    v5 += v6;
    v8 = v31 + (v6 ^ v7 & (v5 ^ v6)) + v8 - 1019803690;
    v8 = __ROR4__(v8, 23);
    v8 += v5;
    v7 = v20 + (v5 ^ v6 & (v8 ^ v5)) + v7 - 187363961;
    v7 = __ROR4__(v7, 18);
    v7 += v8;
    v6 += v25 + (v8 ^ v5 & (v7 ^ v8)) + 1163531501;
    v6 = __ROR4__(v6, 12);
    v6 += v7;
    v5 = v30 + (v7 ^ v8 & (v6 ^ v7)) + v5 - 1444681467;
    v5 = __ROR4__(v5, 27);
    v5 += v6;
    v8 = v19 + (v6 ^ v7 & (v5 ^ v6)) + v8 - 51403784;
    v8 = __ROR4__(v8, 23);
    v8 += v5;
    v7 += v24 + (v5 ^ v6 & (v8 ^ v5)) + 1735328473;
    v7 = __ROR4__(v7, 18);
    v7 += v8;
    v6 = v29 + (v8 ^ v5 & (v7 ^ v8)) + v6 - 1926607734;
    v6 = __ROR4__(v6, 12);
    v6 += v7;
    v5 = v22 + (v8 ^ v6 ^ v7) + v5 - 378558;
    v5 = __ROR4__(v5, 28);
    v5 += v6;
    v8 = v25 + (v7 ^ v5 ^ v6) + v8 - 2022574463;
    v8 = __ROR4__(v8, 21);
    v8 += v5;
    v7 += v28 + (v6 ^ v8 ^ v5) + 1839030562;
    v7 = __ROR4__(v7, 16);
    v7 += v8;
    v6 = v31 + (v5 ^ v7 ^ v8) + v6 - 35309556;
    v6 = __ROR4__(v6, 9);
    v6 += v7;
    v5 = v18 + (v8 ^ v6 ^ v7) + v5 - 1530992060;
    v5 = __ROR4__(v5, 28);
    v5 += v6;
    v8 += v21 + (v7 ^ v5 ^ v6) + 1272893353;
    v8 = __ROR4__(v8, 21);
    v8 += v5;
    v7 = v24 + (v6 ^ v8 ^ v5) + v7 - 155497632;
    v7 = __ROR4__(v7, 16);
    v7 += v8;
    v6 = v27 + (v5 ^ v7 ^ v8) + v6 - 1094730640;
    v6 = __ROR4__(v6, 9);
    v6 += v7;
    v5 += v30 + (v8 ^ v6 ^ v7) + 681279174;
    v5 = __ROR4__(v5, 28);
    v5 += v6;
    v8 = v17 + (v7 ^ v5 ^ v6) + v8 - 358537222;
    v8 = __ROR4__(v8, 21);
    v8 += v5;
    v7 = v20 + (v6 ^ v8 ^ v5) + v7 - 722521979;
    v7 = __ROR4__(v7, 16);
    v7 += v8;
    v6 += v23 + (v5 ^ v7 ^ v8) + 76029189;
    v6 = __ROR4__(v6, 9);
    v6 += v7;
    v5 = v26 + (v8 ^ v6 ^ v7) + v5 - 640364487;
    v5 = __ROR4__(v5, 28);
    v5 += v6;
    v8 = v29 + (v7 ^ v5 ^ v6) + v8 - 421815835;
    v8 = __ROR4__(v8, 21);
    v8 += v5;
    v7 += v32 + (v6 ^ v8 ^ v5) + 530742520;
    v7 = __ROR4__(v7, 16);
    v7 += v8;
    v6 = v19 + (v5 ^ v7 ^ v8) + v6 - 995338651;
    v6 = __ROR4__(v6, 9);
    v6 += v7;
    v5 = v17 + (v7 ^ (v6 | ~v8)) + v5 - 198630844;
    v5 = __ROR4__(v5, 26);
    v5 += v6;
    v8 += v24 + (v6 ^ (v5 | ~v7)) + 1126891415;
    v8 = __ROR4__(v8, 22);
    v8 += v5;
    v7 = v31 + (v5 ^ (v8 | ~v6)) + v7 - 1416354905;
    v7 = __ROR4__(v7, 17);
    v7 += v8;
    v6 = v22 + (v8 ^ (v7 | ~v5)) + v6 - 57434055;
    v6 = __ROR4__(v6, 11);
    v6 += v7;
    v5 += v29 + (v7 ^ (v6 | ~v8)) + 1700485571;
    v5 = __ROR4__(v5, 26);
    v5 += v6;
    v8 = v20 + (v6 ^ (v5 | ~v7)) + v8 - 1894986606;
    v8 = __ROR4__(v8, 22);
    v8 += v5;
    v7 = v27 + (v5 ^ (v8 | ~v6)) + v7 - 1051523;
    v7 = __ROR4__(v7, 17);
    v7 += v8;
    v6 = v18 + (v8 ^ (v7 | ~v5)) + v6 - 2054922799;
    v6 = __ROR4__(v6, 11);
    v6 += v7;
    v5 += v25 + (v7 ^ (v6 | ~v8)) + 1873313359;
    v5 = __ROR4__(v5, 26);
    v5 += v6;
    v8 = v32 + (v6 ^ (v5 | ~v7)) + v8 - 30611744;
    v8 = __ROR4__(v8, 22);
    v8 += v5;
    v7 = v23 + (v5 ^ (v8 | ~v6)) + v7 - 1560198380;
    v7 = __ROR4__(v7, 17);
    v7 += v8;
    v6 += v30 + (v8 ^ (v7 | ~v5)) + 1309151649;
    v6 = __ROR4__(v6, 11);
    v6 += v7;
    v5 = v21 + (v7 ^ (v6 | ~v8)) + v5 - 145523070;
    v5 = __ROR4__(v5, 26);
    v5 += v6;
    v8 = v28 + (v6 ^ (v5 | ~v7)) + v8 - 1120210379;
    v8 = __ROR4__(v8, 22);
    v8 += v5;
    v7 += v19 + (v5 ^ (v8 | ~v6)) + 718787259;
    v7 = __ROR4__(v7, 17);
    v7 += v8;
    v6 = v26 + (v8 ^ (v7 | ~v5)) + v6 - 343485551;
    v6 = __ROR4__(v6, 11);
    v6 += v7;
    v5 += v13;
    v6 += v14;
    v7 += v15;
    v8 += v16;
  }
  while ( (unsigned int)v4 < v10 );
  *a3 = v5;
  a3[1] = v6;
  a3[2] = v7;
  result = a3;
  a3[3] = v8;
  return result;
}
// 80615DC: using guessed type int sub_80615DC(void);
// 806B2FC: using guessed type int dword_806B2FC;

//----- (080572F9) --------------------------------------------------------
int __cdecl sub_80572F9(int a1, int a2, int a3, int a4, int a5, int a6)
{
  return posix_fadvise64(a1, a2, a3, a4, a5, a6);
}
// 8049E60: using guessed type int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0805734A) --------------------------------------------------------
void __cdecl sub_805734A(FILE *stream, int a2)
{
  int v2; // eax

  if ( stream )
  {
    v2 = fileno(stream);
    sub_80572F9(v2, 0, 0, 0, 0, a2);
  }
}

//----- (08057392) --------------------------------------------------------
_BYTE *__usercall sub_8057392@<eax>(int a1@<edx>, int a2@<ecx>, double st7_0@<st0>, _BYTE **a3)
{
  _BYTE *v4; // edx
  int v5; // ecx
  void *v6; // eax
  char v8; // [esp+1Bh] [ebp-Dh]
  _BYTE *v9; // [esp+1Ch] [ebp-Ch]

  v9 = 0;
  v8 = 0;
  dword_806B388 = (int)&loc_805747F;
  sub_8061252(a2, a1);
  do
  {
    if ( v8 )
    {
      v8 = 0;
      if ( !((unsigned __int8)sub_805FEAC((int)v4, v5, (char)**a3) ^ 1) )
        goto LABEL_13;
      v6 = &loc_8057407;
      if ( **a3 == 126 )
        v6 = &loc_8057472;
      dword_806B298 = (int)v6;
      sub_806184C(v5);
      v9 = 0;
      dword_806B25C = (int)&loc_8057472;
      sub_80619C7(st7_0);
    }
    if ( **a3 == 46 )
    {
      v8 = 1;
      if ( !v9 )
        v9 = *a3;
    }
    else if ( (unsigned __int8)sub_805FE52((char)**a3) ^ 1 && **a3 != 126 )
    {
      v9 = 0;
    }
LABEL_13:
    v4 = *a3 + 1;
    *a3 = v4;
  }
  while ( **a3 );
  return v9;
}
// 8061252: using guessed type int __fastcall sub_8061252(_DWORD, _DWORD);
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD);
// 80619C7: using guessed type int __usercall sub_80619C7@<eax>(double@<st0>);
// 806B25C: using guessed type int dword_806B25C;
// 806B298: using guessed type int dword_806B298;
// 806B388: using guessed type int dword_806B388;

//----- (08057494) --------------------------------------------------------
signed int __cdecl sub_8057494(unsigned __int8 a1)
{
  int v1; // edx
  int v2; // ecx
  void *v4; // eax
  unsigned __int8 v5; // [esp+Ch] [ebp-Ch]

  v5 = a1;
  if ( (unsigned __int8)sub_805FF77(a1) )
  {
    dword_806B34C = (int)&locret_8057511;
    sub_80613F7(v2);
  }
  if ( (unsigned __int8)sub_805FEAC(v1, v2, v5) )
    return v5;
  v4 = &loc_8057501;
  if ( v5 != 126 )
    v4 = &loc_8057508;
  dword_806B284 = (int)v4;
  sub_80618C2();
  return -1;
}
// 80613F7: using guessed type int __fastcall sub_80613F7(_DWORD);
// 80618C2: using guessed type int sub_80618C2(void);
// 806B284: using guessed type int dword_806B284;
// 806B34C: using guessed type int dword_806B34C;

//----- (08057513) --------------------------------------------------------
int __usercall sub_8057513@<eax>(int edx0@<edx>, int ecx0@<ecx>, double st7_0@<st0>, int a1, unsigned int a2, int a3, unsigned int a4)
{
  int v7; // edx
  int v8; // ecx
  void *v9; // eax
  void *v11; // eax
  void *v12; // eax
  bool v13; // zf
  int v14; // edx
  int v15; // ecx
  void *v16; // eax
  int v17; // [esp+0h] [ebp-38h]
  unsigned int v18; // [esp+1Ch] [ebp-1Ch]
  unsigned int v19; // [esp+20h] [ebp-18h]
  int v20; // [esp+24h] [ebp-14h]
  int v21; // [esp+28h] [ebp-10h]
  int v22; // [esp+2Ch] [ebp-Ch]

  v18 = 0;
  v19 = 0;
  if ( v18 >= a2 && v19 >= a4 )
    return 0;
  v20 = 0;
  while ( 1 )
  {
    if ( v18 >= a2 || (v17 = *(char *)(a1 + v18), !((unsigned __int8)sub_805FF77(v17) ^ 1)) )
    {
      if ( v19 >= a4 )
        break;
      v17 = *(char *)(a3 + v19);
      if ( !((unsigned __int8)sub_805FF77(v17) ^ 1) )
        break;
    }
    if ( v18 != a2 )
    {
      sub_8057494(*(_BYTE *)(a1 + v18));
      dword_806B2AC = (int)&loc_8057572;
      sub_80617DA(v8, v7);
    }
    v21 = 0;
    v9 = &loc_8057596;
    if ( v19 == a4 )
      v9 = &loc_80575AE;
    dword_806B374 = (int)v9;
    sub_80612DD();
    v17 = *(unsigned __int8 *)(a3 + v19);
    v22 = sub_8057494(v17);
    if ( v21 != v22 )
      return v21 - v22;
    ++v18;
    ++v19;
  }
  dword_806B2E8 = (int)&loc_8057642;
  sub_8061650(ecx0, edx0);
  ++v18;
  v11 = &loc_805766A;
  if ( *(_BYTE *)(a1 + v18) == 48 )
    v11 = &loc_805763E;
  dword_806B25C = (int)v11;
  sub_80619C7(st7_0);
  dword_806B25C = (int)&loc_8057685;
  sub_80619C7(st7_0);
  ++v19;
  v12 = &loc_80576AD;
  if ( *(_BYTE *)(a3 + v19) == 48 )
    v12 = &loc_8057681;
  dword_806B248 = (int)v12;
  sub_8061A50();
  dword_806B284 = (int)&loc_80576F5;
  sub_80618C2();
  do
  {
    if ( !v20 )
      v20 = *(char *)(a1 + v18) - *(char *)(a3 + v19);
    ++v18;
    ++v19;
    v17 = *(char *)(a1 + v18);
    if ( !(unsigned __int8)sub_805FF77(v17) )
      break;
    v17 = *(char *)(a3 + v19);
  }
  while ( (unsigned __int8)sub_805FF77(v17) );
  v17 = *(char *)(a1 + v18);
  if ( (unsigned __int8)sub_805FF77(v17) )
    return 1;
  v17 = *(char *)(a3 + v19);
  v13 = (unsigned __int8)sub_805FF77(v17) == 0;
  v16 = &loc_805777D;
  if ( v13 )
    v16 = &loc_8057784;
  dword_806B270 = (int)v16;
  sub_8061936(v15, v14);
  return -1;
}
// 8057513: could not find valid save-restore pair for ebx
// 80612DD: using guessed type int sub_80612DD(void);
// 8061650: using guessed type int __fastcall sub_8061650(_DWORD, _DWORD);
// 80617DA: using guessed type int __fastcall sub_80617DA(_DWORD, _DWORD);
// 80618C2: using guessed type int sub_80618C2(void);
// 8061936: using guessed type int __fastcall sub_8061936(_DWORD, _DWORD);
// 80619C7: using guessed type int __usercall sub_80619C7@<eax>(double@<st0>);
// 8061A50: using guessed type int sub_8061A50(void);
// 806B248: using guessed type int dword_806B248;
// 806B25C: using guessed type int dword_806B25C;
// 806B270: using guessed type int dword_806B270;
// 806B284: using guessed type int dword_806B284;
// 806B2AC: using guessed type int dword_806B2AC;
// 806B2E8: using guessed type int dword_806B2E8;
// 806B374: using guessed type int dword_806B374;

//----- (080577AE) --------------------------------------------------------
int __usercall sub_80577AE@<eax>(double a1@<st0>, char *s1, char *s2)
{
  int v3; // edx
  int v4; // ecx
  int result; // eax
  int v6; // edx
  int v7; // ecx
  int v8; // edx
  int v9; // ecx
  void *v10; // eax
  int v11; // edx
  int v12; // ecx
  int v13; // ecx
  int v14; // edx
  int v15; // edx
  int v16; // ecx
  char *v17; // [esp+10h] [ebp-28h]
  char *v18; // [esp+14h] [ebp-24h]
  size_t n; // [esp+18h] [ebp-20h]
  unsigned int v20; // [esp+1Ch] [ebp-1Ch]
  int v21; // [esp+20h] [ebp-18h]
  _BYTE *v22; // [esp+24h] [ebp-14h]
  _BYTE *v23; // [esp+28h] [ebp-10h]
  int v24; // [esp+2Ch] [ebp-Ch]

  v21 = strcmp(s1, s2);
  if ( !v21 )
  {
    dword_806B324 = (int)&locret_8057A47;
    sub_80614D5(v4, v3);
  }
  if ( !*s1 )
    return -1;
  if ( !*s2 )
    return 1;
  if ( !strcmp(".", s1) )
    return -1;
  if ( !strcmp(".", s2) )
  {
    dword_806B310 = (int)&locret_8057A47;
    sub_8061566(v7, v6);
  }
  if ( !strcmp("..", s1) )
    return -1;
  if ( !strcmp("..", s2) )
  {
    dword_806B34C = (int)&locret_8057A47;
    sub_80613F7(v9);
  }
  if ( *s1 == 46 )
  {
    v10 = &loc_80578E8;
    if ( *s2 == 46 )
      v10 = &loc_80578F2;
    dword_806B20C = (int)v10;
    sub_8061BBC(v9, v8);
    result = -1;
  }
  else if ( *s1 == 46 || *s2 != 46 )
  {
    if ( *s1 == 46 && *s2 == 46 )
    {
      ++s1;
      ++s2;
    }
    v17 = s1;
    v18 = s2;
    v22 = sub_8057392(v8, v9, a1, &v17);
    v23 = sub_8057392(v11, v12, a1, &v18);
    if ( v22 )
    {
      dword_806B2C0 = (int)&loc_8057977;
      sub_8061764(v13);
    }
    n = v17 - s1;
    if ( v23 )
    {
      dword_806B2C0 = (int)&loc_80579A6;
      sub_8061764(v13);
    }
    v14 = v18 - s2;
    v20 = v18 - s2;
    if ( (v22 || v23) && n == v20 && !strncmp(s1, s2, n) )
    {
      n = v17 - s1;
      v14 = v18 - s2;
      v20 = v18 - s2;
    }
    v24 = sub_8057513(v14, v13, a1, (int)s1, n, (int)s2, v20);
    if ( !v24 )
    {
      dword_806B20C = (int)&locret_8057A47;
      sub_8061BBC(v16, v15);
    }
    result = v24;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 80613F7: using guessed type int __fastcall sub_80613F7(_DWORD);
// 80614D5: using guessed type int __fastcall sub_80614D5(_DWORD, _DWORD);
// 8061566: using guessed type int __fastcall sub_8061566(_DWORD, _DWORD);
// 8061764: using guessed type int __fastcall sub_8061764(_DWORD);
// 8061BBC: using guessed type int __fastcall sub_8061BBC(_DWORD, _DWORD);
// 806B20C: using guessed type int dword_806B20C;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B310: using guessed type int dword_806B310;
// 806B324: using guessed type int dword_806B324;
// 806B34C: using guessed type int dword_806B34C;

//----- (08057A49) --------------------------------------------------------
int __cdecl sub_8057A49(int category)
{
  bool v1; // zf
  void *v2; // eax
  unsigned __int8 v4; // [esp+1Bh] [ebp-Dh]
  const char *s1; // [esp+1Ch] [ebp-Ch]

  v4 = 1;
  s1 = setlocale(category, 0);
  if ( s1 )
  {
    v1 = strcmp(s1, "C") == 0;
    v2 = &loc_8057A9F;
    if ( v1 )
      v2 = &loc_8057AB6;
    dword_806B248 = (int)v2;
    sub_8061A50();
    if ( !strcmp(s1, "POSIX") )
      v4 = 0;
  }
  return v4;
}
// 8061A50: using guessed type int sub_8061A50(void);
// 806B248: using guessed type int dword_806B248;

//----- (08057AC0) --------------------------------------------------------
int __cdecl sub_8057AC0(int a1)
{
  return *(_DWORD *)(a1 + 8);
}

//----- (08057ACB) --------------------------------------------------------
int __cdecl sub_8057ACB(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (08057AD6) --------------------------------------------------------
int __cdecl sub_8057AD6(int a1)
{
  return *(_DWORD *)(a1 + 16);
}

//----- (08057AE1) --------------------------------------------------------
unsigned int __usercall sub_8057AE1@<eax>(int a1@<edx>, int a2@<ecx>, int a3)
{
  _DWORD *i; // [esp+0h] [ebp-10h]
  unsigned int v5; // [esp+4h] [ebp-Ch]
  _DWORD *v6; // [esp+8h] [ebp-8h]
  unsigned int v7; // [esp+Ch] [ebp-4h]

  v5 = 0;
  for ( i = *(_DWORD **)a3; *(_DWORD *)(a3 + 4) > (unsigned int)i; i += 2 )
  {
    if ( *i )
    {
      v6 = i;
      v7 = 1;
      dword_806B360 = (int)&loc_8057B29;
      sub_806137F(a2, a1);
      do
      {
        ++v7;
        v6 = (_DWORD *)v6[1];
      }
      while ( v6 );
      if ( v7 > v5 )
        v5 = v7;
    }
  }
  return v5;
}
// 806137F: using guessed type int __fastcall sub_806137F(_DWORD, _DWORD);
// 806B360: using guessed type int dword_806B360;

//----- (08057CC4) --------------------------------------------------------
int __cdecl sub_8057CC4(int a1, int a2)
{
  unsigned int v3; // [esp+1Ch] [ebp-Ch]

  v3 = (*(int (__cdecl **)(int, _DWORD))(a1 + 24))(a2, *(_DWORD *)(a1 + 8));
  if ( *(_DWORD *)(a1 + 8) <= v3 )
    abort();
  return 8 * v3 + *(_DWORD *)a1;
}

//----- (0805802A) --------------------------------------------------------
bool __cdecl sub_805802A(unsigned int a1)
{
  int v1; // ST08_4
  unsigned int v3; // [esp+8h] [ebp-8h]
  unsigned int v4; // [esp+Ch] [ebp-4h]

  v3 = 3;
  v4 = 9;
  while ( v4 < a1 && a1 % v3 )
  {
    v1 = v3 + 1;
    v4 += 4 * v1;
    v3 = v1 + 1;
  }
  return a1 % v3 != 0;
}

//----- (08058081) --------------------------------------------------------
int __cdecl sub_8058081(unsigned int a1)
{
  int i; // [esp+Ch] [ebp+8h]

  if ( a1 <= 9 )
    a1 = 10;
  for ( i = a1 | 1; i != -1 && !sub_805802A(i); i += 2 )
    ;
  return i;
}

//----- (080580F2) --------------------------------------------------------
unsigned int __cdecl sub_80580F2(int a1, unsigned int a2)
{
  return sub_805FD67(a1, 3) % a2;
}

//----- (0805811D) --------------------------------------------------------
bool __cdecl sub_805811D(int a1, int a2)
{
  return a1 == a2;
}

//----- (0805812B) --------------------------------------------------------
signed int __cdecl sub_805812B(int a1)
{
  int v2; // [esp+8h] [ebp-8h]

  v2 = *(_DWORD *)(a1 + 20);
  if ( (_UNKNOWN *)v2 == &unk_8064180 )
    return 1;
  if ( *(float *)(v2 + 8) > 0.1
    && 1.0 - 0.1 > *(float *)(v2 + 8)
    && *(float *)(v2 + 12) > 0.1 + 1.0
    && *(float *)v2 >= 0.0
    && *(float *)(v2 + 4) > *(float *)v2 + 0.1
    && *(float *)(v2 + 4) <= 1.0
    && *(float *)(v2 + 8) > *(float *)v2 + 0.1 )
  {
    return 1;
  }
  *(_DWORD *)(a1 + 20) = &unk_8064180;
  return 0;
}

//----- (080581E7) --------------------------------------------------------
unsigned int __cdecl sub_80581E7(unsigned int a1, int a2)
{
  int v3; // edx
  int v4; // ecx
  float v5; // [esp+20h] [ebp-4h]
  unsigned int v6; // [esp+2Ch] [ebp+8h]

  if ( *(_BYTE *)(a2 + 16) != 1 )
  {
    v5 = (long double)a1 / *(float *)(a2 + 8);
    if ( v5 >= 4294967300.0 )
      return 0;
    a1 = (signed __int64)v5;
  }
  v6 = sub_8058081(a1);
  if ( v6 > 0x1FFFFFFF )
  {
    dword_806B2E8 = (int)&locret_8058287;
    sub_8061650(v4, v3);
  }
  return v6;
}
// 8061650: using guessed type int __fastcall sub_8061650(_DWORD, _DWORD);
// 806B2E8: using guessed type int dword_806B2E8;

//----- (08058289) --------------------------------------------------------
int __cdecl sub_8058289(int a1, void *a2)
{
  bool v3; // zf
  int v4; // ecx
  void *v5; // eax
  _DWORD *ptr; // [esp+1Ch] [ebp-Ch]

  ptr = malloc(0x28u);
  if ( !ptr )
    return 0;
  if ( !a2 )
    a2 = &unk_8064180;
  ptr[5] = a2;
  v3 = (unsigned __int8)sub_805812B((int)ptr) == 1;
  v5 = &loc_8058309;
  if ( v3 )
    v5 = &loc_805830E;
  dword_806B298 = (int)v5;
  sub_806184C(v4);
  free(ptr);
  return 0;
}
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD);
// 806B298: using guessed type int dword_806B298;

//----- (080585FF) --------------------------------------------------------
void *__cdecl sub_80585FF(int a1)
{
  int v2; // [esp+1Ch] [ebp-Ch]

  if ( *(_DWORD *)(a1 + 36) )
  {
    v2 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(v2 + 4);
    dword_806B220 = (int)&loc_805864A;
    sub_8061B42();
  }
  return malloc(8u);
}
// 8061B42: using guessed type int sub_8061B42(void);
// 806B220: using guessed type int dword_806B220;

//----- (0805864F) --------------------------------------------------------
int __cdecl sub_805864F(int a1, _DWORD *a2)
{
  int result; // eax

  *a2 = 0;
  a2[1] = *(_DWORD *)(a1 + 36);
  result = a1;
  *(_DWORD *)(a1 + 36) = a2;
  return result;
}

//----- (08058672) --------------------------------------------------------
int __cdecl sub_8058672(int a1, int a2, _DWORD *a3, char a4)
{
  int v4; // ecx
  _DWORD *v5; // edx
  void *v7; // eax
  int v8; // edx
  int v9; // ecx
  void *v10; // eax
  _DWORD *v11; // ecx
  int v12; // edx
  int v13; // ecx
  unsigned __int8 (__cdecl *v14)(int, int); // eax
  int v15; // [esp+4h] [ebp-34h]
  char v16; // [esp+Ch] [ebp-2Ch]
  _DWORD *v17; // [esp+18h] [ebp-20h]
  _DWORD *v18; // [esp+1Ch] [ebp-1Ch]
  int v19; // [esp+20h] [ebp-18h]
  _DWORD *v20; // [esp+24h] [ebp-14h]
  int v21; // [esp+28h] [ebp-10h]
  _DWORD *v22; // [esp+2Ch] [ebp-Ch]

  v16 = a4;
  v18 = (_DWORD *)sub_8057CC4(a1, a2);
  v5 = v18;
  *a3 = v18;
  if ( !*v18 )
    return 0;
  v7 = &loc_80586D1;
  if ( *v18 == a2 )
    v7 = &loc_80586F0;
  dword_806B324 = (int)v7;
  sub_80614D5(v4, v5);
  if ( (*(unsigned __int8 (__cdecl **)(int, _DWORD))(a1 + 28))(a2, *v18) )
  {
    v21 = *v18;
    if ( v16 )
    {
      v10 = &loc_8058721;
      if ( !v18[1] )
        v10 = &loc_805874E;
      dword_806B388 = (int)v10;
      sub_8061252(v9, v8);
      v22 = (_DWORD *)v18[1];
      v11 = v18;
      v12 = v22[1];
      *v18 = *v22;
      v11[1] = v12;
      sub_805864F(a1, v22);
    }
    dword_806B248 = (int)&locret_8058827;
    sub_8061A50();
  }
  v17 = v18;
  dword_806B2FC = (int)&loc_8058814;
  sub_80615DC();
  do
  {
    if ( *(_DWORD *)v17[1] == a2
      || (v14 = *(unsigned __int8 (__cdecl **)(int, int))(a1 + 28), v15 = *(_DWORD *)v17[1], v14(a2, v15)) )
    {
      v19 = *(_DWORD *)v17[1];
      if ( v16 )
      {
        v20 = (_DWORD *)v17[1];
        v17[1] = v20[1];
        sub_805864F(a1, v20);
      }
      dword_806B2C0 = (int)&locret_8058827;
      sub_8061764(v13);
    }
    v17 = (_DWORD *)v17[1];
  }
  while ( v17[1] );
  return 0;
}
// 8058672: could not find valid save-restore pair for ebx
// 8061252: using guessed type int __fastcall sub_8061252(_DWORD, _DWORD);
// 80614D5: using guessed type int __fastcall sub_80614D5(_DWORD, _DWORD);
// 80615DC: using guessed type int sub_80615DC(void);
// 8061764: using guessed type int __fastcall sub_8061764(_DWORD);
// 8061A50: using guessed type int sub_8061A50(void);
// 806B248: using guessed type int dword_806B248;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B2FC: using guessed type int dword_806B2FC;
// 806B324: using guessed type int dword_806B324;
// 806B388: using guessed type int dword_806B388;

//----- (08058829) --------------------------------------------------------
signed int __usercall sub_8058829@<eax>(int a1@<edx>, int a2@<ecx>, double a3@<st0>, int a4, int a5, char a6)
{
  int *v6; // edx
  int v7; // ecx
  void *v8; // eax
  _DWORD *v9; // eax
  bool v10; // zf
  void *v11; // eax
  void *v12; // eax
  void *v13; // eax
  char v15; // [esp+Ch] [ebp-2Ch]
  int *v16; // [esp+18h] [ebp-20h]
  int *i; // [esp+1Ch] [ebp-1Ch]
  int v18; // [esp+20h] [ebp-18h]
  _DWORD *v19; // [esp+24h] [ebp-14h]
  int *v20; // [esp+28h] [ebp-10h]
  void *v21; // [esp+2Ch] [ebp-Ch]

  v15 = a6;
  v16 = *(int **)a5;
  dword_806B270 = (int)&loc_80589DD;
  sub_8061936(a2, a1);
  while ( 1 )
  {
    v8 = &loc_8058876;
    if ( !*v16 )
      v8 = &loc_80589D9;
    dword_806B324 = (int)v8;
    sub_80614D5(v7, v6);
    for ( i = (int *)v16[1]; i; i = v20 )
    {
      v18 = *i;
      v9 = (_DWORD *)sub_8057CC4(a4, v18);
      v19 = v9;
      v20 = (int *)i[1];
      v10 = *v9 == 0;
      v11 = &loc_80588CC;
      if ( v10 )
        v11 = &loc_80588E3;
      dword_806B338 = (int)v11;
      sub_8061467(a3);
      i[1] = v19[1];
      v6 = i;
      v19[1] = i;
    }
    v18 = *v16;
    v16[1] = 0;
    if ( v15 )
      goto LABEL_15;
    v19 = (_DWORD *)sub_8057CC4(a4, v18);
    if ( *v19 )
      break;
    *v19 = v18;
    ++*(_DWORD *)(a4 + 12);
    *v16 = 0;
    v6 = (int *)(*(_DWORD *)(a5 + 12) - 1);
    *(_DWORD *)(a5 + 12) = v6;
LABEL_15:
    v16 += 2;
    if ( *(_DWORD *)(a5 + 4) <= (unsigned int)v16 )
      return 1;
  }
  v12 = sub_80585FF(a4);
  v21 = v12;
  v10 = v12 == 0;
  v13 = &loc_8058984;
  if ( !v10 )
    v13 = &loc_805898B;
  dword_806B220 = (int)v13;
  sub_8061B42();
  return 0;
}
// 8058829: could not find valid save-restore pair for ebx
// 8061467: using guessed type int __usercall sub_8061467@<eax>(double@<st0>);
// 80614D5: using guessed type int __fastcall sub_80614D5(_DWORD, _DWORD);
// 8061936: using guessed type int __fastcall sub_8061936(_DWORD, _DWORD);
// 8061B42: using guessed type int sub_8061B42(void);
// 806B220: using guessed type int dword_806B220;
// 806B270: using guessed type int dword_806B270;
// 806B324: using guessed type int dword_806B324;
// 806B338: using guessed type int dword_806B338;

//----- (080589F3) --------------------------------------------------------
int __cdecl sub_80589F3(int a1, unsigned int a2)
{
  bool v2; // zf
  int v3; // edx
  int v4; // ecx
  void *v5; // eax

  v2 = sub_80581E7(a2, *(_DWORD *)(a1 + 20)) == 0;
  v5 = &loc_8058A30;
  if ( !v2 )
    v5 = &loc_8058A3A;
  dword_806B360 = (int)v5;
  sub_806137F(v4, v3);
  return 0;
}
// 806137F: using guessed type int __fastcall sub_806137F(_DWORD, _DWORD);
// 806B360: using guessed type int dword_806B360;

//----- (08058BDA) --------------------------------------------------------
int __cdecl sub_8058BDA(int a1, int a2, _DWORD *a3)
{
  int v3; // eax
  bool v4; // zf
  void *v5; // eax
  int v7; // [esp+2Ch] [ebp-1Ch]
  int v8; // [esp+30h] [ebp-18h]

  if ( !a2 )
    abort();
  v3 = sub_8058672(a1, a2, &v7, 0);
  v8 = v3;
  v4 = v3 == 0;
  v5 = &loc_8058C2E;
  if ( v4 )
    v5 = &loc_8058C46;
  dword_806B2FC = (int)v5;
  sub_80615DC();
  if ( a3 )
    *a3 = v8;
  return 0;
}
// 80615DC: using guessed type int sub_80615DC(void);
// 806B2FC: using guessed type int dword_806B2FC;

//----- (08058E57) --------------------------------------------------------
int __usercall sub_8058E57@<eax>(double st7_0@<st0>, int a1, int a2)
{
  int v3; // ecx
  int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]

  v6 = sub_8058BDA(a1, a2, &v5);
  if ( v6 != -1 )
  {
    if ( !v6 )
    {
      dword_806B25C = (int)&locret_8058EBE;
      sub_80619C7(st7_0);
    }
    dword_806B2C0 = (int)&locret_8058EBE;
    sub_8061764(v3);
  }
  return 0;
}
// 8061764: using guessed type int __fastcall sub_8061764(_DWORD);
// 80619C7: using guessed type int __usercall sub_80619C7@<eax>(double@<st0>);
// 806B25C: using guessed type int dword_806B25C;
// 806B2C0: using guessed type int dword_806B2C0;

//----- (08058EC0) --------------------------------------------------------
int __cdecl sub_8058EC0(int a1, int a2)
{
  int v3; // ecx
  void *v4; // eax
  int v5; // edx
  int v6; // ecx
  int v7; // edx
  int v8; // ecx
  void *v9; // eax
  _DWORD *v10; // [esp+28h] [ebp-20h]
  void *ptr; // [esp+2Ch] [ebp-1Ch]
  int v12; // [esp+30h] [ebp-18h]
  int v13; // [esp+34h] [ebp-14h]
  unsigned int v14; // [esp+38h] [ebp-10h]
  void *v15; // [esp+3Ch] [ebp-Ch]

  v12 = sub_8058672(a1, a2, &v10, 1);
  if ( !v12 )
    return 0;
  --*(_DWORD *)(a1 + 16);
  if ( !*v10
    && **(float **)(a1 + 20) * (long double)*(unsigned int *)(a1 + 8) > (long double)(unsigned int)--*(_DWORD *)(a1 + 12) )
  {
    sub_805812B(a1);
    if ( **(float **)(a1 + 20) * (long double)*(unsigned int *)(a1 + 8) > (long double)*(unsigned int *)(a1 + 12) )
    {
      v13 = *(_DWORD *)(a1 + 20);
      v4 = &loc_8058FD5;
      if ( !*(_BYTE *)(v13 + 16) )
        v4 = &loc_805900F;
      dword_806B310 = (int)v4;
      sub_8061566(v3, 0);
      v14 = (signed __int64)((long double)*(unsigned int *)(a1 + 8) * *(float *)(v13 + 4));
      if ( (unsigned __int8)sub_80589F3(a1, v14) ^ 1 )
      {
        ptr = *(void **)(a1 + 36);
        dword_806B388 = (int)&loc_80590A5;
        sub_8061252(v6, v5);
        v15 = (void *)*((_DWORD *)ptr + 1);
        free(ptr);
        ptr = v15;
        v9 = &loc_80590C4;
        if ( v15 )
          v9 = &loc_805908B;
        dword_806B20C = (int)v9;
        sub_8061BBC(v8, v7);
        *(_DWORD *)(a1 + 36) = 0;
      }
    }
  }
  return v12;
}
// 8058EC0: could not find valid save-restore pair for ebx
// 8061252: using guessed type int __fastcall sub_8061252(_DWORD, _DWORD);
// 8061566: using guessed type int __fastcall sub_8061566(_DWORD, _DWORD);
// 8061BBC: using guessed type int __fastcall sub_8061BBC(_DWORD, _DWORD);
// 806B20C: using guessed type int dword_806B20C;
// 806B310: using guessed type int dword_806B310;
// 806B388: using guessed type int dword_806B388;

//----- (080590D3) --------------------------------------------------------
_DWORD *__cdecl sub_80590D3(int a1, int a2)
{
  int v2; // edx
  int v3; // ecx
  void *v4; // eax
  int v5; // ecx
  void *v6; // eax
  _DWORD *v8; // [esp+1Ch] [ebp-Ch]

  v8 = sub_805E2B0(0x10u);
  v4 = &loc_8059107;
  if ( a2 )
    v4 = &loc_805910E;
  dword_806B2AC = (int)v4;
  sub_80617DA(v3, v2);
  *v8 = sub_805E171(1u, 4u);
  *(_DWORD *)*v8 = 0;
  v8[1] = 1;
  v8[2] = 0;
  v6 = &loc_8059165;
  if ( !a1 )
    v6 = &loc_805916A;
  dword_806B2AC = (int)v6;
  sub_80617DA(v5, 1);
  v8[3] = a1;
  return v8;
}
// 80590D3: could not find valid save-restore pair for ebx
// 80617DA: using guessed type int __fastcall sub_80617DA(_DWORD, _DWORD);
// 806B2AC: using guessed type int dword_806B2AC;

//----- (0805917A) --------------------------------------------------------
int sub_805917A()
{
  return 0;
}

//----- (08059184) --------------------------------------------------------
void __cdecl sub_8059184(void *ptr)
{
  free(*(void **)ptr);
  free(ptr);
}

//----- (080591A4) --------------------------------------------------------
int __cdecl sub_80591A4(int a1, int a2)
{
  int v2; // ecx
  _DWORD *v3; // edx

  if ( (unsigned int)(*(_DWORD *)(a1 + 4) - 1) <= *(_DWORD *)(a1 + 8) )
    *(_DWORD *)a1 = sub_805E1D4(a1 + 4, v2, *(void **)a1, a1 + 4, 4);
  v3 = *(_DWORD **)a1;
  v3[++*(_DWORD *)(a1 + 8)] = a2;
  sub_80593BA(*(_DWORD *)a1, *(_DWORD *)(a1 + 8), *(int (__cdecl **)(int, int))(a1 + 12));
  return 0;
}

//----- (0805922D) --------------------------------------------------------
int __usercall sub_805922D@<eax>(int a1@<edx>, int a2@<ecx>, int *a3)
{
  int v3; // ST1C_4
  _DWORD *v4; // ebx
  int v5; // esi
  int v6; // eax

  if ( !a3[2] )
  {
    dword_806B2E8 = (int)&loc_80592B7;
    sub_8061650(a2, a1);
  }
  v3 = *(_DWORD *)(*a3 + 4);
  v4 = (_DWORD *)(*a3 + 4);
  v5 = *a3;
  v6 = a3[2];
  a3[2] = v6 - 1;
  *v4 = *(_DWORD *)(v5 + 4 * v6);
  sub_80592BE(*a3, a3[2], 1u, (int (__cdecl *)(_DWORD, int))a3[3]);
  return v3;
}
// 8061650: using guessed type int __fastcall sub_8061650(_DWORD, _DWORD);
// 806B2E8: using guessed type int dword_806B2E8;

//----- (080592BE) --------------------------------------------------------
unsigned int __cdecl sub_80592BE(int a1, unsigned int a2, unsigned int a3, int (__cdecl *a4)(_DWORD, int))
{
  int v4; // eax
  int v5; // edx
  int v6; // ecx
  bool v7; // zf
  bool v8; // sf
  void *v9; // eax
  int v11; // [esp+18h] [ebp-10h]
  int v12; // [esp+1Ch] [ebp-Ch]

  v12 = *(_DWORD *)(4 * a3 + a1);
  if ( a2 >> 1 >= a3 )
  {
    v11 = 2 * a3;
    if ( 2 * a3 < a2 && a4(*(_DWORD *)(8 * a3 + a1), *(_DWORD *)(4 * (2 * a3 + 1) + a1)) < 0 )
      ++v11;
    v4 = a4(*(_DWORD *)(4 * v11 + a1), v12);
    v7 = v4 == 0;
    v8 = v4 < 0;
    v9 = &loc_8059369;
    if ( !v8 && !v7 )
      v9 = &loc_805936B;
    dword_806B360 = (int)v9;
    sub_806137F(v6, v5);
  }
  *(_DWORD *)(a1 + 4 * a3) = v12;
  return a3;
}
// 806137F: using guessed type int __fastcall sub_806137F(_DWORD, _DWORD);
// 806B360: using guessed type int dword_806B360;

//----- (080593BA) --------------------------------------------------------
int __cdecl sub_80593BA(int a1, unsigned int a2, int (__cdecl *a3)(int, int))
{
  int v3; // ecx
  int result; // eax
  int v5; // [esp+0h] [ebp-28h]
  unsigned int v6; // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]

  v6 = a2;
  v7 = *(_DWORD *)(4 * a2 + a1);
  dword_806B298 = (int)&loc_805941D;
  sub_806184C(v3);
  do
  {
    *(_DWORD *)(a1 + 4 * v6) = *(_DWORD *)(4 * (v6 >> 1) + a1);
    v6 >>= 1;
    if ( v6 == 1 )
      break;
    v5 = *(_DWORD *)(4 * (v6 >> 1) + a1);
  }
  while ( a3(v5, v7) <= 0 );
  result = v7;
  *(_DWORD *)(a1 + 4 * v6) = v7;
  return result;
}
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD);
// 806B298: using guessed type int dword_806B298;

//----- (0805945F) --------------------------------------------------------
int __cdecl sub_805945F(int a1, int a2)
{
  int v2; // ecx
  int v3; // edx
  int v4; // eax
  bool v5; // zf
  void *v6; // eax
  int v8; // [esp+Ch] [ebp-4h]

  v8 = a2 + 11;
  *(_BYTE *)(a2 + 11) = 0;
  if ( a1 < 0 )
  {
    *(_BYTE *)--v8 = 48 - (char)a1 % 10;
    v2 = a1;
    v3 = a1 / 10;
    v4 = a1 / 10;
    a1 = v4;
    v5 = v4 == 0;
    v6 = &loc_80594F1;
    if ( !v5 )
      v6 = &loc_805947E;
    dword_806B310 = (int)v6;
    sub_8061566(v2, v3);
    *(_BYTE *)--v8 = 45;
    dword_806B2FC = (int)&loc_8059566;
    sub_80615DC();
  }
  do
  {
    *(_BYTE *)--v8 = (char)a1 % 10 + 48;
    a1 /= 10;
  }
  while ( a1 );
  return v8;
}
// 8061566: using guessed type int __fastcall sub_8061566(_DWORD, _DWORD);
// 80615DC: using guessed type int sub_80615DC(void);
// 806B2FC: using guessed type int dword_806B2FC;
// 806B310: using guessed type int dword_806B310;

//----- (0805956B) --------------------------------------------------------
int __cdecl sub_805956B(unsigned int a1, int a2)
{
  int v3; // [esp+Ch] [ebp-4h]

  v3 = a2 + 10;
  *(_BYTE *)(a2 + 10) = 0;
  do
  {
    *(_BYTE *)--v3 = a1 % 0xA + 48;
    a1 /= 0xAu;
  }
  while ( a1 );
  return v3;
}

//----- (080595C9) --------------------------------------------------------
int __cdecl sub_80595C9(signed __int64 a1, int a2)
{
  signed __int64 v3; // [esp+18h] [ebp-20h]
  int v4; // [esp+2Ch] [ebp-Ch]

  v3 = a1;
  v4 = a2 + 20;
  *(_BYTE *)(a2 + 20) = 0;
  do
  {
    *(_BYTE *)--v4 = sub_8060F7D(v3, 10LL) + 48;
    v3 = sub_8060E27(v3, 0xAu, 0);
  }
  while ( v3 );
  return v4;
}

//----- (0805967C) --------------------------------------------------------
int __cdecl sub_805967C(char *a1, int a2, char a3)
{
  int v3; // edx
  int v4; // ecx
  signed int v5; // eax
  bool v6; // zf
  bool v7; // sf
  unsigned __int8 v8; // of
  void *v9; // eax
  int v11; // edx
  int v12; // ecx
  void *v13; // eax
  char *v14; // eax
  const unsigned __int16 **v15; // eax
  int v16; // ecx
  int v17; // edx
  char *v18; // [esp+1Ch] [ebp-3Ch]
  unsigned __int8 v19; // [esp+2Bh] [ebp-2Dh]
  wint_t wc; // [esp+2Ch] [ebp-2Ch]
  char *v21; // [esp+30h] [ebp-28h]
  int v22; // [esp+34h] [ebp-24h]
  size_t v23; // [esp+38h] [ebp-20h]
  char *v24; // [esp+3Ch] [ebp-1Ch]
  int v25; // [esp+40h] [ebp-18h]
  const mbstate_t s; // [esp+44h] [ebp-14h]
  unsigned int v27; // [esp+4Ch] [ebp-Ch]

  v18 = a1;
  v27 = __readgsdword(0x14u);
  v21 = a1;
  v24 = &a1[a2];
  v22 = 0;
  if ( __ctype_get_mb_cur_max() > 1 )
  {
LABEL_33:
    while ( 2 )
    {
      if ( v21 >= v24 )
        return v22;
      v5 = *v21;
      if ( v5 > 63 )
      {
        if ( v5 >= 65 )
        {
          v8 = __OFSUB__(v5, 95);
          v6 = v5 == 95;
          v7 = v5 - 95 < 0;
          v9 = &loc_80596FE;
          if ( (unsigned __int8)(v7 ^ v8) | v6 )
            v9 = &loc_8059706;
          dword_806B2D4 = (int)v9;
          if ( (unsigned int)(sub_80616F8(v4, v3) - 97) <= 0x1D )
            goto LABEL_11;
        }
      }
      else if ( v5 >= 37 || (unsigned int)(v5 - 32) <= 3 )
      {
LABEL_11:
        ++v21;
        ++v22;
        dword_806B374 = (int)&loc_8059897;
        sub_80612DD();
        goto LABEL_12;
      }
LABEL_12:
      memset((void *)&s, 0, 8u);
      while ( 1 )
      {
        v23 = sub_805F69F((wchar_t *)&wc, v21, v24 - v21, (mbstate_t *)&s);
        if ( v23 == -1 )
        {
          if ( !(a3 & 1) )
          {
            ++v21;
            ++v22;
            goto LABEL_33;
          }
          return -1;
        }
        if ( v23 == -2 )
          break;
        if ( !v23 )
          v23 = 1;
        v25 = wcwidth(wc);
        if ( v25 >= 0 )
        {
          if ( 0x7FFFFFFF - v22 < v25 )
          {
            dword_806B284 = (int)&loc_8059952;
            sub_80618C2();
          }
          v22 += v25;
          dword_806B360 = (int)&loc_805987E;
          sub_806137F(v12, v11);
        }
        v13 = &loc_805983F;
        if ( a3 & 2 )
          v13 = &loc_8059862;
        dword_806B324 = (int)v13;
        sub_80614D5(v12, v11);
        if ( !iswcntrl(wc) )
        {
          if ( v22 == 0x7FFFFFFF )
            return 0x7FFFFFFF;
          ++v22;
        }
        v21 += v23;
        if ( mbsinit(&s) )
          goto LABEL_33;
      }
      if ( !(a3 & 1) )
      {
        v21 = v24;
        ++v22;
        continue;
      }
      return -1;
    }
  }
  while ( 1 )
  {
    do
    {
      while ( 1 )
      {
        if ( v21 >= v24 )
          return v22;
        v14 = v21++;
        v19 = *v14;
        v15 = __ctype_b_loc();
        v17 = v19;
        if ( !((*v15)[v17] & 0x4000) )
          break;
        if ( v22 == 0x7FFFFFFF )
        {
          dword_806B2AC = (int)&loc_8059952;
          sub_80617DA(v16, v17 * 2);
        }
        ++v22;
      }
      if ( a3 & 2 )
        return -1;
    }
    while ( (*__ctype_b_loc())[v19] & 2 );
    if ( v22 == 0x7FFFFFFF )
      break;
    ++v22;
  }
  return 0x7FFFFFFF;
}
// 805967C: could not find valid save-restore pair for ebx
// 8049800: using guessed type int __cdecl wcwidth(_DWORD);
// 80612DD: using guessed type int sub_80612DD(void);
// 806137F: using guessed type int __fastcall sub_806137F(_DWORD, _DWORD);
// 80614D5: using guessed type int __fastcall sub_80614D5(_DWORD, _DWORD);
// 80616F8: using guessed type int __fastcall sub_80616F8(_DWORD, _DWORD);
// 80617DA: using guessed type int __fastcall sub_80617DA(_DWORD, _DWORD);
// 80618C2: using guessed type int sub_80618C2(void);
// 806B284: using guessed type int dword_806B284;
// 806B2AC: using guessed type int dword_806B2AC;
// 806B2D4: using guessed type int dword_806B2D4;
// 806B324: using guessed type int dword_806B324;
// 806B360: using guessed type int dword_806B360;
// 806B374: using guessed type int dword_806B374;

//----- (0805996A) --------------------------------------------------------
int sub_805996A()
{
  bool v0; // zf
  void *v1; // eax
  int v2; // edx
  int v3; // ecx
  char v5; // [esp+20h] [ebp-88h]

  v0 = sched_getaffinity(0, 128, &v5) == 0;
  v1 = &loc_80599AE;
  if ( !v0 )
    v1 = &loc_80599F0;
  dword_806B374 = (int)v1;
  sub_80612DD();
  if ( __sched_cpucount(128, &v5) )
  {
    dword_806B20C = (int)&locret_80599F5;
    sub_8061BBC(v3, v2);
  }
  return 0;
}
// 80498D0: using guessed type int __cdecl __sched_cpucount(_DWORD, _DWORD);
// 8049E70: using guessed type int __cdecl sched_getaffinity(_DWORD, _DWORD, _DWORD);
// 80612DD: using guessed type int sub_80612DD(void);
// 8061BBC: using guessed type int __fastcall sub_8061BBC(_DWORD, _DWORD);
// 806B20C: using guessed type int dword_806B20C;
// 806B374: using guessed type int dword_806B374;

//----- (080599F7) --------------------------------------------------------
signed int __cdecl sub_80599F7(int a1)
{
  void *v1; // eax
  signed int result; // eax
  int v3; // [esp+14h] [ebp-14h]
  int v4; // [esp+18h] [ebp-10h]

  v1 = &loc_8059A1C;
  if ( a1 != 1 )
    v1 = &loc_8059A4B;
  dword_806B284 = (int)v1;
  sub_80618C2();
  v3 = sub_805996A();
  if ( v3 )
    return v3;
  v4 = sysconf(84);
  if ( v4 <= 0 )
    result = 1;
  else
    result = v4;
  return result;
}
// 80618C2: using guessed type int sub_80618C2(void);
// 806B284: using guessed type int dword_806B284;

//----- (08059A86) --------------------------------------------------------
int __cdecl sub_8059A86(char *nptr)
{
  int result; // eax
  int v2; // ecx
  void *v3; // eax
  bool v4; // zf
  int v5; // edx
  int v6; // ecx
  void *v7; // eax
  char *endptr; // [esp+14h] [ebp-14h]
  int v9; // [esp+18h] [ebp-10h]
  unsigned int v10; // [esp+1Ch] [ebp-Ch]

  v9 = 0;
  if ( !nptr )
    return v9;
  while ( *nptr && (unsigned __int8)sub_806004B(*nptr) )
    ++nptr;
  if ( !(unsigned __int8)sub_805FF77(*nptr) )
    goto LABEL_20;
  endptr = 0;
  v10 = strtoul(nptr, &endptr, 10);
  if ( !endptr )
    goto LABEL_20;
  v3 = &loc_8059B38;
  if ( !*endptr )
    v3 = &loc_8059B66;
  dword_806B34C = (int)v3;
  sub_80613F7(v2);
  v4 = (unsigned __int8)sub_806004B(*endptr) == 0;
  v7 = &loc_8059B66;
  if ( !v4 )
    v7 = &loc_8059B0C;
  dword_806B2D4 = (int)v7;
  sub_80616F8(v6, v5);
  if ( !*endptr )
    return v10;
  if ( *endptr == 44 )
    result = v10;
  else
LABEL_20:
    result = v9;
  return result;
}
// 8059A86: could not find valid save-restore pair for ebx
// 80613F7: using guessed type int __fastcall sub_80613F7(_DWORD);
// 80616F8: using guessed type int __fastcall sub_80616F8(_DWORD, _DWORD);
// 806B2D4: using guessed type int dword_806B2D4;
// 806B34C: using guessed type int dword_806B34C;

//----- (08059B89) --------------------------------------------------------
unsigned int __cdecl sub_8059B89(int a1)
{
  char *v1; // eax
  char *v2; // eax
  unsigned int result; // eax
  unsigned int v4; // [esp+14h] [ebp-14h]
  unsigned int v5; // [esp+18h] [ebp-10h]

  v4 = -1;
  if ( a1 == 2 )
  {
    v1 = getenv("OMP_NUM_THREADS");
    v5 = sub_8059A86(v1);
    v2 = getenv("OMP_THREAD_LIMIT");
    v4 = sub_8059A86(v2);
    if ( !v4 )
      v4 = -1;
    if ( v5 )
    {
      result = v5;
      if ( v4 <= v5 )
        result = v4;
      return result;
    }
    a1 = 1;
  }
  result = sub_80599F7(a1);
  if ( v4 <= result )
    result = v4;
  return result;
}

//----- (08059C0A) --------------------------------------------------------
void __noreturn sub_8059C0A()
{
  long double v0; // fst7
  int v1; // edx
  int v2; // ecx
  int (*v3)(); // eax
  double v4; // [esp+18h] [ebp-60h]
  double v5; // [esp+20h] [ebp-58h]
  char v6; // [esp+2Ch] [ebp-4Ch]
  unsigned int v7; // [esp+6Ch] [ebp-Ch]

  v7 = __readgsdword(0x14u);
  v4 = (long double)sysconf(85);
  v5 = (long double)sysconf(30);
  if ( v4 >= 0.0 && v5 >= 0.0 )
  {
    v0 = v4 * v5;
    dword_806B338 = (int)&loc_8059CB7;
    sub_8061467(*(double *)&v0);
  }
  if ( !sysinfo((struct sysinfo *)&v6) )
    v1 = 0;
  v3 = (int (*)())&loc_8059CDC;
  if ( __readgsdword(0x14u) == v7 )
    v3 = sub_8059CE3;
  dword_806B234 = (int)v3;
  sub_8061AC8(v2, v1);
  JUMPOUT(*(_DWORD *)sub_8059CE3);
}
// 8059CE3: using guessed type int sub_8059CE3();
// 8061467: using guessed type int __usercall sub_8061467@<eax>(double@<st0>);
// 8061AC8: using guessed type double __fastcall sub_8061AC8(_DWORD, _DWORD);
// 806B234: using guessed type int dword_806B234;
// 806B338: using guessed type int dword_806B338;

//----- (08059CE3) --------------------------------------------------------
#error "8059CE4: positive sp value has been found (funcsize=0)"

//----- (08059CE5) --------------------------------------------------------
long double sub_8059CE5()
{
  bool v1; // zf
  void *v2; // eax
  long double v3; // fst7
  int v4; // [esp+4h] [ebp-74h]
  __int64 v5; // [esp+8h] [ebp-70h]
  double v6; // [esp+18h] [ebp-60h]
  double v7; // [esp+20h] [ebp-58h]
  char v8; // [esp+2Ch] [ebp-4Ch]
  unsigned int v9; // [esp+40h] [ebp-38h]
  unsigned int v10; // [esp+48h] [ebp-30h]
  unsigned int v11; // [esp+60h] [ebp-18h]
  unsigned int v12; // [esp+6Ch] [ebp-Ch]

  v12 = __readgsdword(0x14u);
  v6 = (long double)sysconf(86);
  v4 = sysconf(30);
  v7 = (long double)v4;
  if ( v6 < 0.0 || v7 < 0.0 )
  {
    v1 = sysinfo((struct sysinfo *)&v8) == 0;
    v2 = &loc_8059D6D;
    if ( !v1 )
      v2 = &loc_8059DBB;
    dword_806B2FC = (int)v2;
    sub_80615DC();
    v5 = v11;
    v3 = ((long double)v9 + (long double)v10) * (long double)v11;
    dword_806B25C = (int)&loc_8059DC8;
    sub_80619C7(*(double *)&v3);
    sub_8059C0A();
  }
  return v6 * v7;
}
// 80615DC: using guessed type int sub_80615DC(void);
// 80619C7: using guessed type int __usercall sub_80619C7@<eax>(double@<st0>);
// 806B25C: using guessed type int dword_806B25C;
// 806B2FC: using guessed type int dword_806B2FC;

//----- (08059DDD) --------------------------------------------------------
int __usercall sub_8059DDD@<eax>(int a1@<edx>, int a2@<ecx>, int pipedes[2], int a4)
{
  int v4; // ST30_4
  int v5; // ST34_4
  bool v6; // zf
  void *v7; // eax
  int result; // eax
  void *v9; // eax
  int v10; // [esp+18h] [ebp-20h]

  v4 = *pipedes;
  v5 = pipedes[1];
  if ( dword_806C3BD < 0 )
  {
    v9 = &loc_8059E7E;
    if ( !(a4 & 0xFFF7F7FF) )
      v9 = &loc_8059E93;
    dword_806B310 = (int)v9;
    sub_8061566(a2, a1);
    *__errno_location() = 22;
    result = -1;
  }
  else
  {
    v10 = pipe2(pipedes, a4);
    if ( v10 < 0 )
    {
      v6 = *__errno_location() == 38;
      v7 = &loc_8059E3D;
      if ( v6 )
        v7 = &loc_8059E4F;
      dword_806B248 = (int)v7;
      sub_8061A50();
    }
    dword_806C3BD = 1;
    result = v10;
  }
  return result;
}
// 8049DF0: using guessed type int __cdecl pipe2(_DWORD, _DWORD);
// 8061566: using guessed type int __fastcall sub_8061566(_DWORD, _DWORD);
// 8061A50: using guessed type int sub_8061A50(void);
// 806B248: using guessed type int dword_806B248;
// 806B310: using guessed type int dword_806B310;
// 806C3BD: using guessed type int dword_806C3BD;

//----- (0805A091) --------------------------------------------------------
int sub_805A091()
{
  char *endptr; // [esp+10h] [ebp-18h]
  int v2; // [esp+14h] [ebp-14h]
  char *nptr; // [esp+18h] [ebp-10h]
  int v4; // [esp+1Ch] [ebp-Ch]

  v2 = 200809;
  nptr = getenv("_POSIX2_VERSION");
  if ( nptr )
  {
    if ( *nptr )
    {
      v4 = strtol(nptr, &endptr, 10);
      if ( !*endptr )
        v2 = v4;
    }
  }
  return v2;
}

//----- (0805A0EF) --------------------------------------------------------
char *__cdecl sub_805A0EF(char *s)
{
  char *v1; // eax
  int v2; // edx
  int v3; // ecx
  bool v4; // zf
  void *v5; // eax
  char *result; // eax
  char *v7; // [esp+18h] [ebp-10h]

  if ( !s )
  {
    fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
    abort();
  }
  v1 = strrchr(s, 47);
  v7 = v1;
  v4 = v1 == 0;
  v5 = &loc_805A15A;
  if ( v4 )
    v5 = &loc_805A177;
  dword_806B388 = (int)v5;
  sub_8061252(v3, v2);
  dword_806B284 = (int)&loc_805A17A;
  sub_80618C2();
  dword_806C3C1 = (int)s;
  result = s;
  program_invocation_name = (int)s;
  return result;
}
// 8061252: using guessed type int __fastcall sub_8061252(_DWORD, _DWORD);
// 80618C2: using guessed type int sub_80618C2(void);
// 806B284: using guessed type int dword_806B284;
// 806B388: using guessed type int dword_806B388;
// 806B4E0: using guessed type int program_invocation_short_name;
// 806B4F0: using guessed type int program_invocation_name;
// 806C3C1: using guessed type int dword_806C3C1;

//----- (0805A2C5) --------------------------------------------------------
int __cdecl sub_805A2C5(int *a1, unsigned __int8 a2, char a3)
{
  int *v3; // eax
  int v4; // ST10_4

  if ( a1 )
    v3 = a1;
  else
    v3 = &dword_806C3D1;
  v4 = ((unsigned int)v3[(a2 >> 5) + 2] >> (a2 & 0x1F)) & 1;
  v3[(a2 >> 5) + 2] ^= (v4 ^ a3 & 1) << (a2 & 0x1F);
  return v4;
}
// 806C3D1: using guessed type int dword_806C3D1;

//----- (0805A36F) --------------------------------------------------------
int *__usercall sub_805A36F@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5)
{
  void *v5; // eax
  int *result; // eax

  v5 = &loc_805A394;
  if ( a3 )
    v5 = &loc_805A39B;
  dword_806B234 = (int)v5;
  sub_8061AC8(a2, a1);
  dword_806C3D1 = 10;
  if ( !a4 || !a5 )
    abort();
  *(&dword_806C3D1 + 10) = a4;
  result = &dword_806C3D1;
  *(&dword_806C3D1 + 11) = a5;
  return result;
}
// 8061AC8: using guessed type double __fastcall sub_8061AC8(_DWORD, _DWORD);
// 806B234: using guessed type int dword_806B234;
// 806C3D1: using guessed type int dword_806C3D1;

//----- (0805A3C9) --------------------------------------------------------
_DWORD *__userpurge sub_805A3C9@<eax>(_DWORD *a1, int a2)
{
  int v3; // [esp+0h] [ebp-38h]
  int v4; // [esp+4h] [ebp-34h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]

  memset(&v3, 0, 0x30u);
  if ( a2 == 10 )
    abort();
  *a1 = a2;
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = v6;
  a1[4] = v7;
  a1[5] = v8;
  a1[6] = v9;
  a1[7] = v10;
  a1[8] = v11;
  a1[9] = v12;
  a1[10] = v13;
  a1[11] = v14;
  return a1;
}

//----- (0805A44B) --------------------------------------------------------
char *__usercall sub_805A44B@<eax>(double a1@<st0>, char *msgid, int a2)
{
  char *result; // eax
  bool v4; // zf
  int v5; // edx
  int v6; // ecx
  void *v7; // eax
  int v8; // edx
  int v9; // ecx
  void *v10; // eax
  int v11; // edx
  int v12; // ecx
  char *v13; // [esp+18h] [ebp-10h]
  unsigned __int8 *v14; // [esp+1Ch] [ebp-Ch]

  v13 = gettext(msgid);
  if ( v13 != msgid )
    return v13;
  v14 = (unsigned __int8 *)sub_8060A3C(a1);
  v4 = sub_80600FA(v14, "UTF-8") == 0;
  v7 = &loc_805A4A7;
  if ( !v4 )
    v7 = &loc_805A4D4;
  dword_806B270 = (int)v7;
  sub_8061936(v6, v5);
  *msgid;
  dword_806B2FC = (int)&locret_805A558;
  sub_80615DC();
  v4 = sub_80600FA(v14, "GB18030") == 0;
  v10 = &loc_805A504;
  if ( !v4 )
    v10 = &loc_805A546;
  dword_806B324 = (int)v10;
  sub_80614D5(v9, v8);
  if ( *msgid == 96 )
  {
    dword_806B234 = (int)&loc_805A52F;
    sub_8061AC8(v12, v11);
  }
  dword_806B234 = (int)&locret_805A558;
  sub_8061AC8(v12, v11);
  if ( a2 == 9 )
    result = (char *)&unk_8064395;
  else
    result = "'";
  return result;
}
// 805A44B: could not find valid save-restore pair for ebx
// 80614D5: using guessed type int __fastcall sub_80614D5(_DWORD, _DWORD);
// 80615DC: using guessed type int sub_80615DC(void);
// 8061936: using guessed type int __fastcall sub_8061936(_DWORD, _DWORD);
// 8061AC8: using guessed type double __fastcall sub_8061AC8(_DWORD, _DWORD);
// 806B234: using guessed type int dword_806B234;
// 806B270: using guessed type int dword_806B270;
// 806B2FC: using guessed type int dword_806B2FC;
// 806B324: using guessed type int dword_806B324;

//----- (0805A55A) --------------------------------------------------------
int __usercall sub_805A55A@<eax>(long double fst7_0@<st0>, int a1, unsigned int a2, char *a3, size_t a4, signed int a5, int a6, int a7, char *a8, char *a9)
{
  int v10; // edx
  int v11; // ecx
  void *v12; // eax
  void *v13; // eax
  size_t v14; // ebx
  size_t v15; // eax
  int v16; // edx
  void *v17; // eax
  void *v18; // eax
  void *v19; // eax
  void *v20; // eax
  bool v21; // al
  void *v22; // eax
  void *v23; // eax
  const unsigned __int16 **v24; // eax
  void *v25; // eax
  void *v26; // eax
  int v27; // ecx
  void *v28; // eax
  int v29; // edx
  int v30; // ecx
  void *v31; // eax
  void *v32; // eax
  void *v33; // eax
  void *v34; // eax
  void *v35; // eax
  void *v36; // eax
  bool v37; // al
  int (*v38)(); // eax
  int result; // eax
  char *v40; // [esp+4h] [ebp-84h]
  size_t v41; // [esp+8h] [ebp-80h]
  char *v42; // [esp+2Ch] [ebp-5Ch]
  char *v43; // [esp+30h] [ebp-58h]
  int v44; // [esp+34h] [ebp-54h]
  char *v45; // [esp+38h] [ebp-50h]
  int v46; // [esp+3Ch] [ebp-4Ch]
  char v47; // [esp+40h] [ebp-48h]
  bool v48; // [esp+41h] [ebp-47h]
  char v49; // [esp+42h] [ebp-46h]
  char v50; // [esp+43h] [ebp-45h]
  char v51; // [esp+44h] [ebp-44h]
  unsigned __int8 v52; // [esp+45h] [ebp-43h]
  char v53; // [esp+46h] [ebp-42h]
  char v54; // [esp+47h] [ebp-41h]
  char v55; // [esp+48h] [ebp-40h]
  bool v56; // [esp+49h] [ebp-3Fh]
  bool v57; // [esp+4Ah] [ebp-3Eh]
  bool v58; // [esp+4Bh] [ebp-3Dh]
  wint_t wc; // [esp+4Ch] [ebp-3Ch]
  int v60; // [esp+50h] [ebp-38h]
  unsigned int v61; // [esp+54h] [ebp-34h]
  unsigned int v62; // [esp+58h] [ebp-30h]
  char *s; // [esp+5Ch] [ebp-2Ch]
  size_t n; // [esp+60h] [ebp-28h]
  unsigned int v65; // [esp+64h] [ebp-24h]
  int v66; // [esp+68h] [ebp-20h]
  size_t v67; // [esp+6Ch] [ebp-1Ch]
  unsigned int v68; // [esp+70h] [ebp-18h]
  mbstate_t ps; // [esp+74h] [ebp-14h]
  unsigned int v70; // [esp+7Ch] [ebp-Ch]

  v46 = a1;
  v45 = a3;
  v44 = a7;
  v43 = a8;
  v42 = a9;
  v70 = __readgsdword(0x14u);
  v61 = 0;
  v62 = 0;
  s = 0;
  n = 0;
  v47 = 0;
  v58 = __ctype_get_mb_cur_max() == 1;
  v48 = (a6 & 2) != 0;
  v49 = 0;
  v50 = 0;
  v51 = 1;
  while ( 2 )
  {
    switch ( a5 )
    {
      case 0:
        v48 = 0;
        dword_806B2FC = (int)&loc_805A761;
        sub_80615DC();
        goto LABEL_29;
      case 1:
        goto LABEL_20;
      case 2:
        goto LABEL_23;
      case 3:
        v47 = 1;
LABEL_20:
        v48 = 1;
        goto LABEL_21;
      case 4:
LABEL_21:
        if ( v48 != 1 )
          v47 = 1;
LABEL_23:
        a5 = 2;
        if ( v48 != 1 )
        {
          if ( v61 < a2 )
          {
            v10 = v46;
            *(_BYTE *)(v46 + v61) = 39;
          }
          ++v61;
        }
        s = "'";
        n = 1;
        goto LABEL_30;
      case 5:
        goto LABEL_4;
      case 6:
        a5 = 5;
        v48 = 1;
LABEL_4:
        if ( v48 != 1 )
        {
          if ( v61 < a2 )
          {
            v10 = v46;
            *(_BYTE *)(v46 + v61) = 34;
          }
          ++v61;
        }
        v47 = 1;
        s = (char *)&unk_8064395;
        n = 1;
        goto LABEL_30;
      case 7:
        v47 = 1;
        v48 = 0;
        dword_806B248 = (int)&loc_805A761;
        sub_8061A50();
        break;
      case 8:
      case 9:
      case 10:
        break;
      default:
LABEL_29:
        abort();
        return result;
    }
    v12 = &loc_805A66E;
    if ( a5 == 10 )
      v12 = &loc_805A69A;
    dword_806B25C = (int)v12;
    sub_80619C7(*(double *)&fst7_0);
    v43 = sub_805A44B(*(double *)&fst7_0, "`", a5);
    v42 = sub_805A44B(*(double *)&fst7_0, "'", a5);
    if ( v48 != 1 )
    {
      for ( s = v43; *s; ++s )
      {
        if ( v61 < a2 )
          *(_BYTE *)(v61 + v46) = *s;
        ++v61;
      }
    }
    v47 = 1;
    s = v42;
    n = strlen(v42);
LABEL_30:
    v60 = 0;
    while ( 1 )
    {
      if ( a4 == -1 )
      {
        v10 = (int)v45;
        v37 = v45[v60] != 0;
      }
      else
      {
        v37 = v60 != a4;
      }
      if ( !v37 )
        break;
      v54 = 0;
      v55 = 0;
      v56 = 0;
      if ( v47 )
      {
        v13 = &loc_805A7A2;
        if ( a5 == 2 )
          v13 = &loc_805A821;
        dword_806B248 = (int)v13;
        sub_8061A50();
        if ( n )
        {
          v14 = v60 + n;
          if ( a4 != -1 || n <= 1 )
          {
            v15 = a4;
          }
          else
          {
            v15 = strlen(v45);
            a4 = v15;
          }
          if ( v14 <= v15 && !memcmp(&v45[v60], s, n) )
          {
            v17 = &loc_805A818;
            if ( !v48 )
              v17 = &loc_805A81D;
            dword_806B234 = (int)v17;
            fst7_0 = sub_8061AC8(v11, v16);
            goto LABEL_246;
          }
        }
      }
      v10 = (int)v45;
      v52 = v45[v60];
      switch ( v52 )
      {
        case 0u:
          if ( v47 )
          {
            if ( v48 )
              goto LABEL_246;
            v55 = 1;
            if ( a5 == 2 && v49 != 1 )
            {
              if ( v61 < a2 )
              {
                v10 = v46;
                *(_BYTE *)(v46 + v61) = 39;
              }
              if ( ++v61 < a2 )
              {
                v10 = v46;
                *(_BYTE *)(v46 + v61) = 36;
              }
              if ( ++v61 < a2 )
              {
                v10 = v46;
                *(_BYTE *)(v46 + v61) = 39;
              }
              ++v61;
              v49 = 1;
            }
            if ( v61 < a2 )
            {
              v10 = v46;
              *(_BYTE *)(v46 + v61) = 92;
            }
            ++v61;
            if ( a5 != 2 && v60 + 1 < a4 )
            {
              v10 = v60 + 1;
              if ( v45[v60 + 1] > 47 )
              {
                v10 = v60 + 1;
                if ( v45[v60 + 1] <= 57 )
                {
                  if ( v61 < a2 )
                  {
                    v10 = v46;
                    *(_BYTE *)(v46 + v61) = 48;
                  }
                  if ( ++v61 < a2 )
                  {
                    v10 = v46;
                    *(_BYTE *)(v46 + v61) = 48;
                  }
                  ++v61;
                }
              }
            }
            v52 = 48;
          }
          else if ( a6 & 1 )
          {
            goto LABEL_221;
          }
LABEL_186:
          if ( v47 != 1 || a5 == 2 )
          {
            v34 = &loc_805B0EB;
            if ( v48 != 1 )
              v34 = &loc_805B11D;
            dword_806B234 = (int)v34;
            fst7_0 = sub_8061AC8(v11, v10);
          }
          if ( v44 && (v11 = v52 & 0x1F, v10 = *(_DWORD *)(4 * (v52 >> 5) + v44) >> v11, v10 & 1) )
          {
            if ( v48 )
              goto LABEL_246;
            v55 = 1;
            if ( a5 == 2 )
            {
              v36 = &loc_805B17F;
              if ( v49 == 1 )
                v36 = &loc_805B1C8;
              dword_806B388 = (int)v36;
              sub_8061252(v11, v10);
              if ( v61 < a2 )
              {
                v10 = v46;
                *(_BYTE *)(v46 + v61) = 39;
              }
              if ( ++v61 < a2 )
              {
                v10 = v46;
                *(_BYTE *)(v46 + v61) = 36;
              }
              if ( ++v61 < a2 )
              {
                v10 = v46;
                *(_BYTE *)(v46 + v61) = 39;
              }
              ++v61;
              v49 = 1;
            }
            if ( v61 < a2 )
            {
              v10 = v46;
              *(_BYTE *)(v46 + v61) = 92;
            }
            ++v61;
          }
          else
          {
            v35 = &loc_805B141;
            if ( v54 == 1 )
              v35 = &loc_805B146;
            dword_806B298 = (int)v35;
            sub_806184C(v11);
          }
LABEL_210:
          if ( v49 && v55 != 1 )
          {
            if ( v61 < a2 )
            {
              v10 = v46;
              *(_BYTE *)(v46 + v61) = 39;
            }
            if ( ++v61 < a2 )
            {
              v10 = v46;
              *(_BYTE *)(v46 + v61) = 39;
            }
            ++v61;
            v49 = 0;
          }
          if ( v61 < a2 )
          {
            v10 = v61 + v46;
            *(_BYTE *)(v61 + v46) = v52;
          }
          ++v61;
          if ( v56 != 1 )
            v51 = 0;
LABEL_221:
          ++v60;
          break;
        case 7u:
          v53 = 97;
          goto LABEL_90;
        case 8u:
          v53 = 98;
          goto LABEL_90;
        case 9u:
          v53 = 116;
          goto LABEL_88;
        case 0xAu:
          v53 = 110;
          goto LABEL_88;
        case 0xBu:
          v53 = 118;
          goto LABEL_90;
        case 0xCu:
          v53 = 102;
          goto LABEL_90;
        case 0xDu:
          v53 = 114;
LABEL_88:
          if ( a5 == 2 && v48 )
            goto LABEL_246;
LABEL_90:
          if ( v47 )
          {
            v52 = v53;
            dword_806B324 = (int)&loc_805B146;
            sub_80614D5(v11, v45);
          }
          goto LABEL_186;
        case 0x20u:
          goto LABEL_98;
        case 0x21u:
        case 0x22u:
        case 0x24u:
        case 0x26u:
        case 0x28u:
        case 0x29u:
        case 0x2Au:
        case 0x3Bu:
        case 0x3Cu:
        case 0x3Du:
        case 0x3Eu:
        case 0x5Bu:
        case 0x5Eu:
        case 0x60u:
        case 0x7Cu:
          goto LABEL_99;
        case 0x23u:
        case 0x7Eu:
          goto LABEL_97;
        case 0x25u:
        case 0x2Bu:
        case 0x2Cu:
        case 0x2Du:
        case 0x2Eu:
        case 0x2Fu:
        case 0x30u:
        case 0x31u:
        case 0x32u:
        case 0x33u:
        case 0x34u:
        case 0x35u:
        case 0x36u:
        case 0x37u:
        case 0x38u:
        case 0x39u:
        case 0x3Au:
        case 0x41u:
        case 0x42u:
        case 0x43u:
        case 0x44u:
        case 0x45u:
        case 0x46u:
        case 0x47u:
        case 0x48u:
        case 0x49u:
        case 0x4Au:
        case 0x4Bu:
        case 0x4Cu:
        case 0x4Du:
        case 0x4Eu:
        case 0x4Fu:
        case 0x50u:
        case 0x51u:
        case 0x52u:
        case 0x53u:
        case 0x54u:
        case 0x55u:
        case 0x56u:
        case 0x57u:
        case 0x58u:
        case 0x59u:
        case 0x5Au:
        case 0x5Du:
        case 0x5Fu:
        case 0x61u:
        case 0x62u:
        case 0x63u:
        case 0x64u:
        case 0x65u:
        case 0x66u:
        case 0x67u:
        case 0x68u:
        case 0x69u:
        case 0x6Au:
        case 0x6Bu:
        case 0x6Cu:
        case 0x6Du:
        case 0x6Eu:
        case 0x6Fu:
        case 0x70u:
        case 0x71u:
        case 0x72u:
        case 0x73u:
        case 0x74u:
        case 0x75u:
        case 0x76u:
        case 0x77u:
        case 0x78u:
        case 0x79u:
        case 0x7Au:
          v56 = 1;
          goto LABEL_186;
        case 0x27u:
          v50 = 1;
          v56 = 1;
          if ( a5 != 2 )
            goto LABEL_186;
          if ( v48 )
            goto LABEL_246;
          if ( a2 )
          {
            v23 = &loc_805AC3A;
            if ( v62 )
              v23 = &loc_805AC47;
            dword_806B34C = (int)v23;
            sub_80613F7(v11);
            v62 = a2;
            a2 = 0;
          }
          if ( v61 < a2 )
            *(_BYTE *)(v46 + v61) = 39;
          if ( ++v61 < a2 )
            *(_BYTE *)(v46 + v61) = 92;
          if ( ++v61 < a2 )
            *(_BYTE *)(v46 + v61) = 39;
          ++v61;
          v49 = 0;
          dword_806B2C0 = (int)&loc_805B0B6;
          sub_8061764(v11);
          goto LABEL_186;
        case 0x3Fu:
          if ( a5 == 2 )
          {
            if ( v48 )
              goto LABEL_246;
          }
          else
          {
            v18 = &loc_805A972;
            if ( a5 == 5 )
              v18 = &loc_805A987;
            dword_806B388 = (int)v18;
            sub_8061252(v11, v45);
          }
          goto LABEL_186;
        case 0x5Cu:
          v53 = v52;
          v19 = &loc_805AAEF;
          if ( a5 != 2 )
            v19 = &loc_805AB18;
          dword_806B234 = (int)v19;
          fst7_0 = sub_8061AC8(v11, v45);
          v20 = &loc_805AB0E;
          if ( !v48 )
            v20 = &loc_805AB13;
          dword_806B374 = (int)v20;
          sub_80612DD();
          goto LABEL_246;
        case 0x7Bu:
        case 0x7Du:
          if ( a4 == -1 )
            v21 = v45[1] != 0;
          else
            v21 = a4 != 1;
          if ( v21 )
            goto LABEL_186;
LABEL_97:
          if ( v60 )
            goto LABEL_186;
LABEL_98:
          v56 = 1;
LABEL_99:
          if ( a5 != 2 )
            goto LABEL_186;
          v22 = &loc_805ABEE;
          if ( !v48 )
            v22 = &loc_805ABF3;
          dword_806B324 = (int)v22;
          sub_80614D5(v11, v45);
          goto LABEL_246;
        default:
          if ( v58 )
          {
            v65 = 1;
            v24 = __ctype_b_loc();
            v10 = 2 * v52;
            v57 = (*(const unsigned __int16 *)((char *)*v24 + v10) & 0x4000) != 0;
          }
          else
          {
            memset(&ps, 0, 8u);
            v65 = 0;
            v57 = 1;
            v25 = &loc_805AD2E;
            if ( a4 != -1 )
              v25 = &loc_805AD3C;
            dword_806B248 = (int)v25;
            sub_8061A50();
            a4 = strlen(v45);
LABEL_124:
            v41 = a4 - (v65 + v60);
            v40 = &v45[v65 + v60];
            v67 = sub_805F69F((wchar_t *)&wc, v40, v41, &ps);
            if ( v67 )
            {
              if ( v67 == -1 )
              {
                v57 = 0;
              }
              else if ( v67 == -2 )
              {
                v57 = 0;
                while ( 1 )
                {
                  v10 = v60;
                  if ( v60 + v65 >= a4 )
                    break;
                  v10 = v65 + v60;
                  if ( !v45[v65 + v60] )
                    break;
                  ++v65;
                }
              }
              else
              {
                v26 = &loc_805ADE4;
                if ( !v48 )
                  v26 = &loc_805AE56;
                dword_806B374 = (int)v26;
                sub_80612DD();
                v28 = &loc_805AE03;
                if ( a5 != 2 )
                  v28 = &loc_805AE56;
                dword_806B298 = (int)v28;
                sub_806184C(v27);
                v66 = 1;
                dword_806B234 = (int)&loc_805AE4E;
                fst7_0 = sub_8061AC8(v30, v29);
                while ( 2 )
                {
                  switch ( v45[v66 + v65 + v60] )
                  {
                    case 91:
                    case 92:
                    case 94:
                    case 96:
                    case 124:
                      goto LABEL_246;
                    default:
                      if ( ++v66 < v67 )
                        continue;
                      if ( !iswprint(wc) )
                        v57 = 0;
                      v65 += v67;
                      if ( !mbsinit(&ps) )
                        goto LABEL_124;
                      dword_806B2FC = (int)&loc_805AE99;
                      sub_80615DC();
                      break;
                  }
                  break;
                }
              }
            }
          }
          v56 = v57;
          if ( v65 > 1 )
            goto LABEL_149;
          if ( !v47 )
            goto LABEL_186;
          v31 = &loc_805AED4;
          if ( v57 == 1 )
            v31 = &loc_805B0B6;
          dword_806B248 = (int)v31;
          sub_8061A50();
LABEL_149:
          v10 = v60;
          v68 = v60 + v65;
          while ( 2 )
          {
            if ( !v47 || v57 == 1 )
              goto LABEL_170;
            if ( v48 )
              goto LABEL_246;
            v55 = 1;
            if ( a5 == 2 )
            {
              v32 = &loc_805AF31;
              if ( v49 == 1 )
                v32 = &loc_805AF7A;
              dword_806B2FC = (int)v32;
              sub_80615DC();
              if ( v61 < a2 )
              {
                v10 = v46;
                *(_BYTE *)(v46 + v61) = 39;
              }
              if ( ++v61 < a2 )
              {
                v10 = v46;
                *(_BYTE *)(v46 + v61) = 36;
              }
              if ( ++v61 < a2 )
              {
                v10 = v46;
                *(_BYTE *)(v46 + v61) = 39;
              }
              ++v61;
              v49 = 1;
            }
            if ( v61 < a2 )
            {
              v10 = v46;
              *(_BYTE *)(v46 + v61) = 92;
            }
            if ( ++v61 < a2 )
            {
              v10 = v61 + v46;
              *(_BYTE *)(v61 + v46) = (v52 >> 6) + 48;
            }
            if ( ++v61 < a2 )
            {
              v10 = v61 + v46;
              *(_BYTE *)(v61 + v46) = ((v52 >> 3) & 7) + 48;
            }
            ++v61;
            v52 = (v52 & 7) + 48;
            dword_806B20C = (int)&loc_805B019;
            sub_8061BBC(v11, v10);
LABEL_170:
            if ( v54 )
            {
              if ( v61 < a2 )
              {
                v10 = v46;
                *(_BYTE *)(v46 + v61) = 92;
              }
              ++v61;
              v54 = 0;
            }
            if ( v60 + 1 < v68 )
            {
              v33 = &loc_805B048;
              if ( !v49 )
                v33 = &loc_805B085;
              dword_806B248 = (int)v33;
              sub_8061A50();
              if ( v55 != 1 )
              {
                if ( v61 < a2 )
                  *(_BYTE *)(v46 + v61) = 39;
                if ( ++v61 < a2 )
                  *(_BYTE *)(v46 + v61) = 39;
                ++v61;
                v49 = 0;
              }
              if ( v61 < a2 )
                *(_BYTE *)(v61 + v46) = v52;
              ++v61;
              ++v60;
              v10 = (int)v45;
              v52 = v45[v60];
              continue;
            }
            goto LABEL_210;
          }
      }
    }
    if ( !v61 && a5 == 2 && v48 )
    {
LABEL_246:
      if ( a5 == 2 && v47 )
        a5 = 4;
      sub_805A55A(fst7_0, v46, a2, v45, a4, a5, a6 & 0xFFFFFFFD, 0, v43, v42);
      goto LABEL_250;
    }
    if ( a5 == 2 && v48 != 1 && v50 )
    {
      if ( v51 )
      {
        sub_805A55A(fst7_0, v46, v62, v45, a4, 5, a6, v44, v43, v42);
        goto LABEL_250;
      }
      if ( !a2 && v62 )
      {
        a2 = v62;
        v61 = 0;
        continue;
      }
    }
    break;
  }
  if ( s && v48 != 1 )
  {
    dword_806B20C = (int)&loc_805B35B;
    sub_8061BBC(v11, v10);
    do
    {
      if ( v61 < a2 )
        *(_BYTE *)(v61 + v46) = *s;
      ++v61;
      ++s;
    }
    while ( *s );
  }
  if ( v61 < a2 )
    *(_BYTE *)(v46 + v61) = 0;
LABEL_250:
  v38 = (int (*)())&loc_805B3FE;
  if ( __readgsdword(0x14u) == v70 )
    v38 = sub_805B403;
  dword_806B25C = (int)v38;
  return sub_80619C7(*(double *)&fst7_0);
}
// 805B403: using guessed type int sub_805B403();
// 8061252: using guessed type int __fastcall sub_8061252(_DWORD, _DWORD);
// 80612DD: using guessed type int sub_80612DD(void);
// 80613F7: using guessed type int __fastcall sub_80613F7(_DWORD);
// 80614D5: using guessed type int __fastcall sub_80614D5(_DWORD, _DWORD);
// 80615DC: using guessed type int sub_80615DC(void);
// 8061764: using guessed type int __fastcall sub_8061764(_DWORD);
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD);
// 80619C7: using guessed type int __usercall sub_80619C7@<eax>(double@<st0>);
// 8061A50: using guessed type int sub_8061A50(void);
// 8061AC8: using guessed type double __fastcall sub_8061AC8(_DWORD, _DWORD);
// 8061BBC: using guessed type int __fastcall sub_8061BBC(_DWORD, _DWORD);
// 806B20C: using guessed type int dword_806B20C;
// 806B234: using guessed type int dword_806B234;
// 806B248: using guessed type int dword_806B248;
// 806B25C: using guessed type int dword_806B25C;
// 806B298: using guessed type int dword_806B298;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B2FC: using guessed type int dword_806B2FC;
// 806B324: using guessed type int dword_806B324;
// 806B34C: using guessed type int dword_806B34C;
// 806B374: using guessed type int dword_806B374;
// 806B388: using guessed type int dword_806B388;

//----- (0805B403) --------------------------------------------------------
#error "805B406: positive sp value has been found (funcsize=0)"

//----- (0805B4D9) --------------------------------------------------------
void *__usercall sub_805B4D9@<eax>(int a1@<ecx>, long double a2@<st0>, char *a3, size_t a4, _DWORD *a5, int a6)
{
  void *v6; // eax
  int v7; // ST44_4
  int v8; // ST48_4
  int v9; // ST4C_4
  int size; // [esp+48h] [ebp-10h]
  void *v12; // [esp+4Ch] [ebp-Ch]

  v6 = &loc_805B4FF;
  if ( !a6 )
    v6 = &loc_805B504;
  dword_806B2C0 = (int)v6;
  sub_8061764(a1);
  v7 = a6;
  v8 = *__errno_location();
  v9 = *(_DWORD *)(a6 + 4) | (a5 == 0);
  size = sub_805A55A(
           a2,
           0,
           0,
           a3,
           a4,
           *(_DWORD *)v7,
           *(_DWORD *)(v7 + 4) | (a5 == 0),
           v7 + 8,
           *(char **)(v7 + 40),
           *(char **)(v7 + 44))
       + 1;
  v12 = sub_805E29D(size);
  sub_805A55A(a2, (int)v12, size, a3, a4, *(_DWORD *)v7, v9, v7 + 8, *(char **)(v7 + 40), *(char **)(v7 + 44));
  *__errno_location() = v8;
  if ( a5 )
    *a5 = size - 1;
  return v12;
}
// 8061764: using guessed type int __fastcall sub_8061764(_DWORD);
// 806B2C0: using guessed type int dword_806B2C0;

//----- (0805B699) --------------------------------------------------------
void *__usercall sub_805B699@<eax>(long double fst7_0@<st0>, signed int a1, char *a2, size_t a3, int a4)
{
  int v5; // ecx
  void *v6; // eax
  int *v7; // eax
  void *v8; // edx
  size_t v9; // ST4C_4
  bool v11; // [esp+37h] [ebp-21h]
  int *v12; // [esp+38h] [ebp-20h]
  int *v13; // [esp+38h] [ebp-20h]
  void *ptr; // [esp+3Ch] [ebp-1Ch]
  int v15; // [esp+40h] [ebp-18h]
  int size; // [esp+44h] [ebp-14h]
  int v17; // [esp+48h] [ebp-10h]
  unsigned int v18; // [esp+4Ch] [ebp-Ch]

  v15 = *__errno_location();
  v12 = off_806B488;
  if ( a1 < 0 )
    abort();
  v6 = &loc_805B6E0;
  if ( dword_806B47C > a1 )
    v6 = &loc_805B78F;
  dword_806B34C = (int)v6;
  sub_80613F7(v5);
  v11 = v12 == &dword_806B480;
  if ( (unsigned int)a1 > 0xFFFFFFE )
    sub_805E44B();
  if ( v11 )
    v7 = 0;
  else
    v7 = v12;
  v13 = (int *)sub_805E2F3(v7, 8 * (a1 + 1));
  off_806B488 = v13;
  if ( v11 )
  {
    v8 = off_806B484;
    *v13 = dword_806B480;
    v13[1] = (int)v8;
  }
  memset(&v13[2 * dword_806B47C], 0, 8 * (a1 + 1 - dword_806B47C));
  dword_806B47C = a1 + 1;
  v9 = v13[2 * a1];
  ptr = (void *)v13[2 * a1 + 1];
  v17 = *(_DWORD *)(a4 + 4) | 1;
  v18 = sub_805A55A(
          fst7_0,
          v13[2 * a1 + 1],
          v13[2 * a1],
          a2,
          a3,
          *(_DWORD *)a4,
          v17,
          a4 + 8,
          *(char **)(a4 + 40),
          *(char **)(a4 + 44));
  if ( v9 <= v18 )
  {
    size = v18 + 1;
    v13[2 * a1] = v18 + 1;
    if ( ptr != &unk_806C411 )
      free(ptr);
    ptr = sub_805E29D(size);
    v13[2 * a1 + 1] = (int)ptr;
    sub_805A55A(fst7_0, (int)ptr, size, a2, a3, *(_DWORD *)a4, v17, a4 + 8, *(char **)(a4 + 40), *(char **)(a4 + 44));
  }
  *__errno_location() = v15;
  return ptr;
}
// 80613F7: using guessed type int __fastcall sub_80613F7(_DWORD);
// 806B34C: using guessed type int dword_806B34C;
// 806B47C: using guessed type int dword_806B47C;
// 806B480: using guessed type int dword_806B480;
// 806B484: using guessed type void *off_806B484;
// 806B488: using guessed type int *off_806B488;

//----- (0805B8D7) --------------------------------------------------------
void *__usercall sub_805B8D7@<eax>(long double a1@<st0>, signed int a2, char *a3)
{
  return sub_805B699(a1, a2, a3, 0xFFFFFFFF, (int)&dword_806C3D1);
}
// 806C3D1: using guessed type int dword_806C3D1;

//----- (0805B901) --------------------------------------------------------
void *__usercall sub_805B901@<eax>(long double a1@<st0>, signed int a2, char *a3, size_t a4)
{
  return sub_805B699(a1, a2, a3, a4, (int)&dword_806C3D1);
}
// 806C3D1: using guessed type int dword_806C3D1;

//----- (0805B967) --------------------------------------------------------
void *__usercall sub_805B967@<eax>(long double a1@<st0>, signed int a2, int a3, char *a4)
{
  char v5; // [esp+10h] [ebp-38h]

  sub_805A3C9(&v5, a3);
  return sub_805B699(a1, a2, a4, 0xFFFFFFFF, (int)&v5);
}

//----- (0805B9A5) --------------------------------------------------------
void *__usercall sub_805B9A5@<eax>(long double a1@<st0>, signed int a2, int a3, char *a4, size_t a5)
{
  char v6; // [esp+10h] [ebp-38h]

  sub_805A3C9(&v6, a3);
  return sub_805B699(a1, a2, a4, a5, (int)&v6);
}

//----- (0805B9E2) --------------------------------------------------------
void *__usercall sub_805B9E2@<eax>(long double a1@<st0>, int a2, char *a3)
{
  return sub_805B967(a1, 0, a2, a3);
}

//----- (0805BA2D) --------------------------------------------------------
void *__usercall sub_805BA2D@<eax>(long double fst7_0@<st0>, char *a1, size_t a2, unsigned __int8 a3)
{
  int v5; // [esp+20h] [ebp-38h]
  int v6; // [esp+24h] [ebp-34h]
  int v7; // [esp+28h] [ebp-30h]
  int v8; // [esp+2Ch] [ebp-2Ch]
  int v9; // [esp+30h] [ebp-28h]
  int v10; // [esp+34h] [ebp-24h]
  int v11; // [esp+38h] [ebp-20h]
  int v12; // [esp+3Ch] [ebp-1Ch]
  int v13; // [esp+40h] [ebp-18h]
  int v14; // [esp+44h] [ebp-14h]
  int v15; // [esp+48h] [ebp-10h]
  int v16; // [esp+4Ch] [ebp-Ch]

  v5 = dword_806C3D1;
  v6 = dword_806C3D5;
  v7 = dword_806C3D9;
  v8 = dword_806C3DD;
  v9 = dword_806C3E1;
  v10 = dword_806C3E5;
  v11 = dword_806C3E9;
  v12 = dword_806C3ED;
  v13 = dword_806C3F1;
  v14 = dword_806C3F5;
  v15 = dword_806C3F9;
  v16 = dword_806C3FD;
  sub_805A2C5(&v5, a3, 1);
  return sub_805B699(fst7_0, 0, a1, a2, (int)&v5);
}
// 806C3D1: using guessed type int dword_806C3D1;
// 806C3D5: using guessed type int dword_806C3D5;
// 806C3D9: using guessed type int dword_806C3D9;
// 806C3DD: using guessed type int dword_806C3DD;
// 806C3E1: using guessed type int dword_806C3E1;
// 806C3E5: using guessed type int dword_806C3E5;
// 806C3E9: using guessed type int dword_806C3E9;
// 806C3ED: using guessed type int dword_806C3ED;
// 806C3F1: using guessed type int dword_806C3F1;
// 806C3F5: using guessed type int dword_806C3F5;
// 806C3F9: using guessed type int dword_806C3F9;
// 806C3FD: using guessed type int dword_806C3FD;

//----- (0805BAD7) --------------------------------------------------------
void *__usercall sub_805BAD7@<eax>(long double fst7_0@<st0>, char *a1, unsigned __int8 a2)
{
  return sub_805BA2D(fst7_0, a1, 0xFFFFFFFF, a2);
}

//----- (0805BB00) --------------------------------------------------------
void *__usercall sub_805BB00@<eax>(long double fst7_0@<st0>, char *a1)
{
  return sub_805BAD7(fst7_0, a1, 0x3Au);
}

//----- (0805BB3D) --------------------------------------------------------
void *__usercall sub_805BB3D@<eax>(long double fst7_0@<st0>, signed int a1, int a2, char *a3)
{
  int v5; // [esp+10h] [ebp-68h]
  int v6; // [esp+14h] [ebp-64h]
  int v7; // [esp+18h] [ebp-60h]
  int v8; // [esp+1Ch] [ebp-5Ch]
  int v9; // [esp+20h] [ebp-58h]
  int v10; // [esp+24h] [ebp-54h]
  int v11; // [esp+28h] [ebp-50h]
  int v12; // [esp+2Ch] [ebp-4Ch]
  int v13; // [esp+30h] [ebp-48h]
  int v14; // [esp+34h] [ebp-44h]
  int v15; // [esp+38h] [ebp-40h]
  int v16; // [esp+3Ch] [ebp-3Ch]
  int v17; // [esp+40h] [ebp-38h]
  int v18; // [esp+44h] [ebp-34h]
  int v19; // [esp+48h] [ebp-30h]
  int v20; // [esp+4Ch] [ebp-2Ch]
  int v21; // [esp+50h] [ebp-28h]
  int v22; // [esp+54h] [ebp-24h]
  int v23; // [esp+58h] [ebp-20h]
  int v24; // [esp+5Ch] [ebp-1Ch]
  int v25; // [esp+60h] [ebp-18h]
  int v26; // [esp+64h] [ebp-14h]
  int v27; // [esp+68h] [ebp-10h]
  int v28; // [esp+6Ch] [ebp-Ch]

  sub_805A3C9(&v5, a2);
  v17 = v5;
  v18 = v6;
  v19 = v7;
  v20 = v8;
  v21 = v9;
  v22 = v10;
  v23 = v11;
  v24 = v12;
  v25 = v13;
  v26 = v14;
  v27 = v15;
  v28 = v16;
  sub_805A2C5(&v17, 0x3Au, 1);
  return sub_805B699(fst7_0, a1, a3, 0xFFFFFFFF, (int)&v17);
}

//----- (0805BBDE) --------------------------------------------------------
void *__usercall sub_805BBDE@<eax>(int a1@<edx>, int a2@<ecx>, long double a3@<st0>, signed int a4, int a5, int a6, char *a7)
{
  return sub_805BC0E(a1, a2, a3, a4, a5, a6, a7, 0xFFFFFFFF);
}

//----- (0805BC0E) --------------------------------------------------------
void *__usercall sub_805BC0E@<eax>(int a1@<edx>, int a2@<ecx>, long double a3@<st0>, signed int a4, int a5, int a6, char *a7, size_t a8)
{
  int v9; // [esp+10h] [ebp-38h]
  int v10; // [esp+14h] [ebp-34h]
  int v11; // [esp+18h] [ebp-30h]
  int v12; // [esp+1Ch] [ebp-2Ch]
  int v13; // [esp+20h] [ebp-28h]
  int v14; // [esp+24h] [ebp-24h]
  int v15; // [esp+28h] [ebp-20h]
  int v16; // [esp+2Ch] [ebp-1Ch]
  int v17; // [esp+30h] [ebp-18h]
  int v18; // [esp+34h] [ebp-14h]
  int v19; // [esp+38h] [ebp-10h]
  int v20; // [esp+3Ch] [ebp-Ch]

  v9 = dword_806C3D1;
  v10 = dword_806C3D5;
  v11 = dword_806C3D9;
  v12 = dword_806C3DD;
  v13 = dword_806C3E1;
  v14 = dword_806C3E5;
  v15 = dword_806C3E9;
  v16 = dword_806C3ED;
  v17 = dword_806C3F1;
  v18 = dword_806C3F5;
  v19 = dword_806C3F9;
  v20 = dword_806C3FD;
  sub_805A36F(a1, a2, (int)&v9, a5, a6);
  return sub_805B699(a3, a4, a7, a8, (int)&v9);
}
// 806C3D1: using guessed type int dword_806C3D1;
// 806C3D5: using guessed type int dword_806C3D5;
// 806C3D9: using guessed type int dword_806C3D9;
// 806C3DD: using guessed type int dword_806C3DD;
// 806C3E1: using guessed type int dword_806C3E1;
// 806C3E5: using guessed type int dword_806C3E5;
// 806C3E9: using guessed type int dword_806C3E9;
// 806C3ED: using guessed type int dword_806C3ED;
// 806C3F1: using guessed type int dword_806C3F1;
// 806C3F5: using guessed type int dword_806C3F5;
// 806C3F9: using guessed type int dword_806C3F9;
// 806C3FD: using guessed type int dword_806C3FD;

//----- (0805BD08) --------------------------------------------------------
void *__usercall sub_805BD08@<eax>(long double fst7_0@<st0>, signed int a1, char *a2, size_t a3)
{
  return sub_805B699(fst7_0, a1, a2, a3, (int)&unk_806B49C);
}

//----- (0805BD53) --------------------------------------------------------
void *__usercall sub_805BD53@<eax>(long double fst7_0@<st0>, signed int a1, char *a2)
{
  return sub_805BD08(fst7_0, a1, a2, 0xFFFFFFFF);
}

//----- (0805BD75) --------------------------------------------------------
void *__usercall sub_805BD75@<eax>(long double fst7_0@<st0>, char *a1)
{
  return sub_805BD53(fst7_0, 0, a1);
}

//----- (0805BD90) --------------------------------------------------------
void __usercall __noreturn sub_805BD90(long double a1@<st0>, char *a2)
{
  void *v2; // esi
  int v3; // edx
  int v4; // ecx
  char *v5; // ebx
  int v6; // edx
  void *v7; // [esp+Ch] [ebp-Ch]

  if ( a2 )
  {
    v2 = sub_805BD75(a1, a2);
    if ( !*__errno_location() )
    {
      gettext("%s: end of file");
      dword_806B2AC = (int)&loc_805BDE9;
      sub_80617DA(v4, v3);
    }
    v5 = gettext("%s: read error");
    v6 = *__errno_location();
    v7 = v2;
    error(status, v6, v5, v2);
  }
  abort();
}
// 80617DA: using guessed type int __fastcall sub_80617DA(_DWORD, _DWORD);
// 806B2AC: using guessed type int dword_806B2AC;

//----- (0805BE0E) --------------------------------------------------------
_DWORD *__cdecl sub_805BE0E(int a1, int a2)
{
  _DWORD *result; // eax

  result = sub_805E2B0(0x81Cu);
  *result = a1;
  result[1] = sub_805BD90;
  result[2] = a2;
  return result;
}

//----- (0805BE43) --------------------------------------------------------
unsigned int __cdecl sub_805BE43(int a1, int a2, size_t nbytes)
{
  size_t v3; // eax
  int v4; // eax
  size_t n; // ST24_4
  int v6; // eax
  size_t v7; // ST28_4
  int v8; // eax
  size_t v9; // ST2C_4
  int v10; // eax
  size_t v11; // ST30_4
  unsigned int result; // eax
  int v13; // eax
  size_t v14; // ST34_4
  unsigned int v15; // [esp+18h] [ebp-30h]
  int fd; // [esp+20h] [ebp-28h]
  struct timeval tv; // [esp+38h] [ebp-10h]

  v15 = 0;
  fd = open64("/dev/urandom", 0);
  if ( fd >= 0 )
  {
    v3 = a2;
    if ( nbytes <= a2 )
      v3 = nbytes;
    v15 = read(fd, (void *)a1, v3);
    if ( (v15 & 0x80000000) != 0 )
      v15 = 0;
    close(fd);
  }
  if ( v15 < a2 )
  {
    v4 = a2 - v15;
    if ( a2 - v15 > 8 )
      v4 = 8;
    n = v4;
    gettimeofday(&tv, 0);
    memcpy((void *)(a1 + v15), &tv, n);
    v15 += n;
  }
  if ( v15 < a2 )
  {
    v6 = a2 - v15;
    if ( a2 - v15 > 4 )
      v6 = 4;
    v7 = v6;
    tv.tv_sec = getpid();
    memcpy((void *)(a1 + v15), &tv, v7);
    v15 += v7;
  }
  if ( v15 < a2 )
  {
    v8 = a2 - v15;
    if ( a2 - v15 > 4 )
      v8 = 4;
    v9 = v8;
    tv.tv_sec = getppid();
    memcpy((void *)(a1 + v15), &tv, v9);
    v15 += v9;
  }
  if ( v15 < a2 )
  {
    v10 = a2 - v15;
    if ( a2 - v15 > 4 )
      v10 = 4;
    v11 = v10;
    tv.tv_sec = getuid();
    memcpy((void *)(a1 + v15), &tv, v11);
    v15 += v11;
  }
  result = v15;
  if ( v15 < a2 )
  {
    v13 = a2 - v15;
    if ( a2 - v15 > 4 )
      v13 = 4;
    v14 = v13;
    tv.tv_sec = getgid();
    memcpy((void *)(a1 + v15), &tv, v14);
    result = v15 + v14;
  }
  return result;
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);

//----- (0805C050) --------------------------------------------------------
_DWORD *__usercall sub_805C050@<eax>(double st7_0@<st0>, int a1, size_t n)
{
  void *v3; // eax

  v3 = &loc_805C075;
  if ( n )
    v3 = &loc_805C08E;
  dword_806B25C = (int)v3;
  sub_80619C7(st7_0);
  return sub_805BE0E(0, 0);
}
// 80619C7: using guessed type int __usercall sub_80619C7@<eax>(double@<st0>);
// 806B25C: using guessed type int dword_806B25C;

//----- (0805C165) --------------------------------------------------------
size_t __cdecl sub_805C165(int a1, void *ptr, size_t n)
{
  size_t v3; // ST20_4
  size_t result; // eax
  int *v5; // ebx
  bool v6; // zf
  int v7; // edx
  int v8; // ecx
  void *v9; // eax
  int v10; // [esp+1Ch] [ebp-Ch]

  while ( 1 )
  {
    v3 = fread_unlocked(ptr, 1u, n, *(FILE **)a1);
    v10 = *__errno_location();
    ptr = (char *)ptr + v3;
    result = v3;
    n -= v3;
    if ( !n )
      break;
    v5 = __errno_location();
    v6 = ferror_unlocked(*(FILE **)a1) == 0;
    v9 = &loc_805C1E1;
    if ( v6 )
      v9 = &loc_805C1E6;
    dword_806B2AC = (int)v9;
    sub_80617DA(v8, v7);
    *v5 = v10;
    (*(void (__cdecl **)(_DWORD))(a1 + 4))(*(_DWORD *)(a1 + 8));
  }
  return result;
}
// 80617DA: using guessed type int __fastcall sub_80617DA(_DWORD, _DWORD);
// 806B2AC: using guessed type int dword_806B2AC;

//----- (0805C209) --------------------------------------------------------
int __cdecl sub_805C209(int a1, void *dest, size_t n)
{
  int result; // eax
  int v4; // ecx
  void *v5; // eax
  int v6; // edx
  int v7; // ecx
  void *v8; // eax
  int v9; // edx
  int v10; // ecx
  size_t v11; // [esp+14h] [ebp-14h]
  int *desta; // [esp+34h] [ebp+Ch]
  size_t na; // [esp+38h] [ebp+10h]

  v11 = *(_DWORD *)a1;
  if ( n > *(_DWORD *)a1 )
  {
    memcpy(dest, (const void *)(a1 + 1024 - v11 + 1040), v11);
    na = n - v11;
    v5 = &loc_805C2BD;
    if ( ((_BYTE)dest + (_BYTE)v11) & 3 )
      v5 = &loc_805C321;
    dword_806B2D4 = (int)v5;
    sub_80616F8(v4, dest);
    desta = (int *)((char *)dest + v11);
    if ( na > 0x3FF )
    {
      sub_805C432((unsigned int *)(a1 + 4), desta);
      v8 = &loc_805C307;
      if ( na != 1024 )
        v8 = &loc_805C312;
      dword_806B360 = (int)v8;
      sub_806137F(v7, v6);
      result = a1;
      *(_DWORD *)a1 = 0;
    }
    else
    {
      sub_805C432((unsigned int *)(a1 + 4), (int *)(a1 + 1040));
      dword_806B2AC = (int)&loc_805C217;
      result = sub_80617DA(v10, v9);
    }
  }
  else
  {
    memcpy(dest, (const void *)(a1 + 1024 - v11 + 1040), n);
    result = a1;
    *(_DWORD *)a1 = v11 - n;
  }
  return result;
}
// 805C209: could not find valid save-restore pair for ebx
// 806137F: using guessed type int __fastcall sub_806137F(_DWORD, _DWORD);
// 80616F8: using guessed type int __fastcall sub_80616F8(_DWORD, _DWORD);
// 80617DA: using guessed type int __fastcall sub_80617DA(_DWORD, _DWORD);
// 806B2AC: using guessed type int dword_806B2AC;
// 806B2D4: using guessed type int dword_806B2D4;
// 806B360: using guessed type int dword_806B360;

//----- (0805C35C) --------------------------------------------------------
size_t __cdecl sub_805C35C(int a1, void *ptr, size_t n)
{
  size_t result; // eax

  if ( *(_DWORD *)a1 )
    result = sub_805C165(a1, ptr, n);
  else
    result = sub_805C209(a1 + 12, ptr, n);
  return result;
}

//----- (0805C3A4) --------------------------------------------------------
int __usercall sub_805C3A4@<eax>(double a1@<st0>, void *ptr)
{
  int result; // eax
  FILE *stream; // [esp+1Ch] [ebp-Ch]

  stream = *(FILE **)ptr;
  explicit_bzero(ptr, 2076);
  free(ptr);
  if ( stream )
    result = sub_805F2A2(a1, stream);
  else
    result = 0;
  return result;
}
// 8049DE0: using guessed type int __cdecl explicit_bzero(_DWORD, _DWORD);

//----- (0805C3EA) --------------------------------------------------------
int __cdecl sub_805C3EA(int a1)
{
  return a1;
}

//----- (0805C401) --------------------------------------------------------
int __cdecl sub_805C401(int a1, __int16 a2)
{
  return *(_DWORD *)((a2 & 0x3FC) + a1);
}

//----- (0805C432) --------------------------------------------------------
unsigned int *__cdecl sub_805C432(unsigned int *a1, int *a2)
{
  unsigned int v2; // edx
  int v3; // ST08_4
  unsigned int v4; // ST18_4
  unsigned int v5; // ST1C_4
  int v6; // eax
  int v7; // ST0C_4
  unsigned int v8; // ST08_4
  unsigned int v9; // ST20_4
  int v10; // eax
  int v11; // eax
  int v12; // ST0C_4
  int v13; // ST08_4
  unsigned int v14; // ST28_4
  int v15; // eax
  int v16; // eax
  int v17; // ST0C_4
  unsigned int v18; // ST30_4
  int v19; // eax
  int v20; // eax
  int v21; // ST08_4
  unsigned int v22; // ST38_4
  unsigned int v23; // ST3C_4
  int v24; // eax
  int v25; // ST0C_4
  unsigned int v26; // ST08_4
  unsigned int v27; // ST40_4
  int v28; // eax
  int v29; // eax
  int v30; // ST0C_4
  int v31; // ST08_4
  unsigned int v32; // ST48_4
  int v33; // eax
  int v34; // eax
  int v35; // ST0C_4
  unsigned int v36; // ST50_4
  int v37; // eax
  int v38; // eax
  unsigned int *result; // eax
  unsigned int v40; // [esp+8h] [ebp-54h]
  int v41; // [esp+Ch] [ebp-50h]
  unsigned int *v42; // [esp+10h] [ebp-4Ch]
  int *v43; // [esp+14h] [ebp-48h]

  v40 = a1[256];
  v2 = a1[257];
  v41 = v2 + ++a1[258];
  v42 = a1;
  v43 = a2;
  do
  {
    v3 = (v40 ^ (v40 << 13)) + v42[128];
    v4 = *v42;
    v5 = sub_805C401((int)a1, *v42) + v3 + v41;
    *v42 = v5;
    v6 = sub_805C401((int)a1, v5 >> 8);
    v7 = sub_805C3EA(v4 + v6);
    *v43 = v7;
    v8 = (v3 ^ ((unsigned int)sub_805C3EA(v3) >> 6)) + v42[129];
    v9 = v42[1];
    v10 = sub_805C401((int)a1, v42[1]);
    v42[1] = v10 + v8 + v7;
    v11 = sub_805C401((int)a1, (v10 + v8 + v7) >> 8);
    v12 = sub_805C3EA(v9 + v11);
    v43[1] = v12;
    v13 = (v8 ^ 4 * v8) + v42[130];
    v14 = v42[2];
    v15 = sub_805C401((int)a1, v42[2]);
    v42[2] = v15 + v13 + v12;
    v16 = sub_805C401((int)a1, (unsigned int)(v15 + v13 + v12) >> 8);
    v17 = sub_805C3EA(v14 + v16);
    v43[2] = v17;
    v40 = (v13 ^ ((unsigned int)sub_805C3EA(v13) >> 16)) + v42[131];
    v18 = v42[3];
    v19 = sub_805C401((int)a1, v42[3]);
    v42[3] = v19 + v40 + v17;
    v20 = sub_805C401((int)a1, (v19 + v40 + v17) >> 8);
    v41 = sub_805C3EA(v18 + v20);
    v43[3] = v41;
    v43 += 4;
    v42 += 4;
  }
  while ( v42 < a1 + 128 );
  do
  {
    v21 = (v40 ^ (v40 << 13)) + *(v42 - 128);
    v22 = *v42;
    v23 = sub_805C401((int)a1, *v42) + v21 + v41;
    *v42 = v23;
    v24 = sub_805C401((int)a1, v23 >> 8);
    v25 = sub_805C3EA(v22 + v24);
    *v43 = v25;
    v26 = (v21 ^ ((unsigned int)sub_805C3EA(v21) >> 6)) + *(v42 - 127);
    v27 = v42[1];
    v28 = sub_805C401((int)a1, v42[1]);
    v42[1] = v28 + v26 + v25;
    v29 = sub_805C401((int)a1, (v28 + v26 + v25) >> 8);
    v30 = sub_805C3EA(v27 + v29);
    v43[1] = v30;
    v31 = (v26 ^ 4 * v26) + *(v42 - 126);
    v32 = v42[2];
    v33 = sub_805C401((int)a1, v42[2]);
    v42[2] = v33 + v31 + v30;
    v34 = sub_805C401((int)a1, (unsigned int)(v33 + v31 + v30) >> 8);
    v35 = sub_805C3EA(v32 + v34);
    v43[2] = v35;
    v40 = (v31 ^ ((unsigned int)sub_805C3EA(v31) >> 16)) + *(v42 - 125);
    v36 = v42[3];
    v37 = sub_805C401((int)a1, v42[3]);
    v42[3] = v37 + v40 + v35;
    v38 = sub_805C401((int)a1, (v37 + v40 + v35) >> 8);
    v41 = sub_805C3EA(v36 + v38);
    v43[3] = v41;
    v43 += 4;
    v42 += 4;
  }
  while ( v42 < a1 + 256 );
  a1[256] = v40;
  result = a1;
  a1[257] = v41;
  return result;
}

//----- (0805C8D7) --------------------------------------------------------
_DWORD *__usercall sub_805C8D7@<eax>(double a1@<st0>, _DWORD *a2)
{
  int v2; // ST18_4
  int v3; // ST1C_4
  int v4; // ST24_4
  int v5; // ST28_4
  int v6; // ST2C_4
  int v7; // ST30_4
  int v8; // ST14_4
  int v9; // ST20_4
  unsigned int v10; // ST18_4
  int v11; // ST24_4
  int v12; // ST1C_4
  int v13; // ST28_4
  int v14; // ST2C_4
  int v15; // ST30_4
  int v16; // ST14_4
  _DWORD *result; // eax
  int v18; // [esp+Ch] [ebp-28h]
  int v19; // [esp+10h] [ebp-24h]
  int v20; // [esp+14h] [ebp-20h]
  unsigned int v21; // [esp+18h] [ebp-1Ch]
  int v22; // [esp+1Ch] [ebp-18h]
  unsigned int v23; // [esp+20h] [ebp-14h]
  int v24; // [esp+24h] [ebp-10h]
  unsigned int v25; // [esp+28h] [ebp-Ch]
  signed int i; // [esp+2Ch] [ebp-8h]

  v18 = 325574490;
  v19 = -1780940711;
  v20 = -1021952437;
  v21 = 255990488;
  v22 = -651539848;
  v23 = -1525007287;
  v24 = -990909925;
  v25 = 811634969;
  for ( i = 0; i <= 255; i += 8 )
  {
    v2 = a2[i + 1] + v19;
    v3 = a2[i + 2] + v20;
    v4 = a2[i + 4] + v22;
    v5 = a2[i + 5] + v23;
    v6 = a2[i + 6] + v24;
    v7 = a2[i + 7] + v25;
    v8 = (v2 << 11) ^ (a2[i] + v18);
    v9 = v8 + a2[i + 3] + v21;
    v10 = ((unsigned int)sub_805C3EA(v3) >> 2) ^ (v3 + v2);
    v11 = v10 + v4;
    v12 = (v9 << 8) ^ (v9 + v3);
    v13 = v12 + v5;
    v21 = ((unsigned int)sub_805C3EA(v11) >> 16) ^ (v11 + v9);
    v14 = v21 + v6;
    v22 = (v13 << 10) ^ (v13 + v11);
    v15 = v22 + v7;
    v23 = ((unsigned int)sub_805C3EA(v14) >> 4) ^ (v14 + v13);
    v16 = v23 + v8;
    v24 = (v15 << 8) ^ (v15 + v14);
    v19 = v24 + v10;
    v25 = ((unsigned int)sub_805C3EA(v16) >> 9) ^ (v16 + v15);
    v20 = v25 + v12;
    v18 = v19 + v16;
    a2[i] = v18;
    a2[i + 1] = v19;
    a2[i + 2] = v20;
    a2[i + 3] = v21;
    a2[i + 4] = v22;
    a2[i + 5] = v23;
    a2[i + 6] = v24;
    a2[i + 7] = v25;
  }
  dword_806B338 = (int)&loc_805CAF0;
  sub_8061467(a1);
  a2[258] = 0;
  a2[257] = a2[258];
  result = a2;
  a2[256] = a2[257];
  return result;
}
// 8061467: using guessed type int __usercall sub_8061467@<eax>(double@<st0>);
// 806B338: using guessed type int dword_806B338;

//----- (0805CCFB) --------------------------------------------------------
signed int __cdecl sub_805CCFB(_DWORD *a1)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_805F8D0((int)(a1 + 3), 0, 0, (int)malloc, (int)free);
  sub_805F8D0((int)(a1 + 14), 0, 0, (int)malloc, (int)free);
  return sub_805F8D0((int)(a1 + 25), 0, 0, (int)malloc, (int)free);
}

//----- (0805CE9F) --------------------------------------------------------
_DWORD *__cdecl sub_805CE9F(_DWORD *a1)
{
  _DWORD *result; // eax
  int src; // [esp+10h] [ebp-38h]
  _DWORD *v3; // [esp+14h] [ebp-34h]
  _DWORD *v4; // [esp+18h] [ebp-30h]
  int v5; // [esp+1Ch] [ebp-2Ch]
  int v6; // [esp+20h] [ebp-28h]
  _DWORD *v7; // [esp+24h] [ebp-24h]
  _DWORD *v8; // [esp+28h] [ebp-20h]
  _DWORD *v9; // [esp+2Ch] [ebp-1Ch]
  _DWORD *v10; // [esp+30h] [ebp-18h]
  _DWORD *v11; // [esp+34h] [ebp-14h]
  size_t n; // [esp+38h] [ebp-10h]
  _DWORD *v13; // [esp+3Ch] [ebp-Ch]

  v3 = a1 + 3;
  src = a1[6] - a1[5] - 1;
  v4 = a1 + 3;
  v5 = a1[5];
  if ( a1[6] == v5 )
    *((_BYTE *)v4 + 40) |= 2u;
  v4[3] = (v4[6] + v4[3]) & ~v4[6];
  if ( v4[3] - v4[1] > (unsigned int)(v4[4] - v4[1]) )
    v4[3] = v4[4];
  v4[2] = v4[3];
  v6 = v5;
  v7 = a1 + 14;
  v8 = a1 + 14;
  if ( (unsigned int)(a1[18] - a1[17]) <= 3 )
    sub_805F959((int)v7, 4);
  v9 = v7;
  v10 = (_DWORD *)v7[3];
  *v10 = v6;
  v9[3] += 4;
  v11 = a1 + 25;
  n = 4;
  v13 = a1 + 25;
  if ( (unsigned int)(a1[29] - a1[28]) < 4 )
    sub_805F959((int)v11, n);
  memcpy((void *)v11[3], &src, n);
  v11[3] += n;
  result = a1;
  ++*a1;
  return result;
}

//----- (0805D034) --------------------------------------------------------
bool __cdecl sub_805D034(FILE *stream, int a2)
{
  _BYTE *v2; // eax
  _BYTE *v3; // eax
  void *v4; // eax
  int v6; // [esp+14h] [ebp-44h]
  int v7; // [esp+18h] [ebp-40h]
  int v8; // [esp+1Ch] [ebp-3Ch]
  int v9; // [esp+20h] [ebp-38h]
  int v10; // [esp+24h] [ebp-34h]
  int v11; // [esp+28h] [ebp-30h]
  int v12; // [esp+2Ch] [ebp-2Ch]
  int v13; // [esp+30h] [ebp-28h]
  _DWORD *v14; // [esp+34h] [ebp-24h]
  int v15; // [esp+38h] [ebp-20h]
  int v16; // [esp+3Ch] [ebp-1Ch]
  int v17; // [esp+40h] [ebp-18h]
  int v18; // [esp+44h] [ebp-14h]
  int v19; // [esp+48h] [ebp-10h]
  int v20; // [esp+4Ch] [ebp-Ch]

  while ( 1 )
  {
    v6 = fgetc(stream);
    if ( v6 == -1 )
      break;
    v19 = a2 + 12;
    v20 = a2 + 12;
    if ( *(_DWORD *)(a2 + 28) == *(_DWORD *)(a2 + 24) )
      sub_805F959(v19, 1);
    v3 = *(_BYTE **)(v19 + 12);
    *(_DWORD *)(v19 + 12) = v3 + 1;
    *v3 = v6;
    v4 = &loc_805D140;
    if ( v6 )
      v4 = &loc_805D162;
    dword_806B2FC = (int)v4;
    sub_80615DC();
    sub_805CE9F((_DWORD *)a2);
    dword_806B374 = (int)&loc_805D03A;
    sub_80612DD();
  }
  v7 = a2 + 12;
  v8 = *(_DWORD *)(a2 + 24) - *(_DWORD *)(a2 + 20);
  if ( v8 )
  {
    v9 = a2 + 12;
    v10 = a2 + 12;
    if ( *(_DWORD *)(a2 + 28) == *(_DWORD *)(a2 + 24) )
      sub_805F959(v9, 1);
    v2 = *(_BYTE **)(v9 + 12);
    *(_DWORD *)(v9 + 12) = v2 + 1;
    *v2 = 0;
    sub_805CE9F((_DWORD *)a2);
  }
  v11 = a2 + 56;
  v12 = a2 + 56;
  if ( (unsigned int)(*(_DWORD *)(a2 + 72) - *(_DWORD *)(a2 + 68)) <= 3 )
    sub_805F959(v11, 4);
  v13 = v11;
  v14 = *(_DWORD **)(v11 + 12);
  *v14 = 0;
  *(_DWORD *)(v13 + 12) += 4;
  v15 = a2 + 56;
  v16 = *(_DWORD *)(a2 + 64);
  if ( *(_DWORD *)(a2 + 68) == v16 )
    *(_BYTE *)(v15 + 40) |= 2u;
  *(_DWORD *)(v15 + 12) = (*(_DWORD *)(v15 + 24) + *(_DWORD *)(v15 + 12)) & ~*(_DWORD *)(v15 + 24);
  if ( *(_DWORD *)(v15 + 12) - *(_DWORD *)(v15 + 4) > (unsigned int)(*(_DWORD *)(v15 + 16) - *(_DWORD *)(v15 + 4)) )
    *(_DWORD *)(v15 + 12) = *(_DWORD *)(v15 + 16);
  *(_DWORD *)(v15 + 8) = *(_DWORD *)(v15 + 12);
  *(_DWORD *)(a2 + 4) = v16;
  v17 = a2 + 100;
  v18 = *(_DWORD *)(a2 + 108);
  if ( *(_DWORD *)(a2 + 112) == v18 )
    *(_BYTE *)(v17 + 40) |= 2u;
  *(_DWORD *)(v17 + 12) = (*(_DWORD *)(v17 + 24) + *(_DWORD *)(v17 + 12)) & ~*(_DWORD *)(v17 + 24);
  if ( *(_DWORD *)(v17 + 12) - *(_DWORD *)(v17 + 4) > (unsigned int)(*(_DWORD *)(v17 + 16) - *(_DWORD *)(v17 + 4)) )
    *(_DWORD *)(v17 + 12) = *(_DWORD *)(v17 + 16);
  *(_DWORD *)(v17 + 8) = *(_DWORD *)(v17 + 12);
  *(_DWORD *)(a2 + 8) = v18;
  return ferror(stream) == 0;
}
// 80612DD: using guessed type int sub_80612DD(void);
// 80615DC: using guessed type int sub_80615DC(void);
// 806B2FC: using guessed type int dword_806B2FC;
// 806B374: using guessed type int dword_806B374;

//----- (0805D322) --------------------------------------------------------
int __cdecl sub_805D322(int a1, int a2)
{
  int v2; // eax
  int v3; // ecx

  v2 = mkostemp64(a1, a2);
  return sub_8060342(a2, v3, v2, a2);
}
// 8049A10: using guessed type int __cdecl mkostemp64(_DWORD, _DWORD);

//----- (0805D34B) --------------------------------------------------------
int __cdecl sub_805D34B(_BYTE *a1, _BYTE *a2, char a3)
{
  int v3; // ecx
  _BYTE *v5; // eax
  _BYTE *v6; // edx
  bool v7; // zf
  void *v8; // eax

  if ( *a1 != a3 || *a2 != a3 )
  {
    v5 = a1;
    v6 = a1++ + 1;
    v7 = *v5 == a3;
    v8 = &loc_805D441;
    if ( !v7 )
      v8 = &loc_805D468;
    dword_806B20C = (int)v8;
    sub_8061BBC(v3, v6);
  }
  else
  {
    while ( *++a1 == *++a2 )
    {
      if ( (unsigned int)((char)*a1 - 48) > 9 )
        return 0;
    }
    if ( (unsigned int)((char)*a1 - 48) <= 9 && (unsigned int)((char)*a2 - 48) <= 9 )
      return (char)*a1 - (char)*a2;
    if ( (unsigned int)((char)*a1 - 48) > 9 )
    {
      if ( (unsigned int)((char)*a2 - 48) > 9 )
        return 0;
      while ( *a2 == 48 )
        ++a2;
      return -((unsigned int)((char)*a2 - 48) <= 9);
    }
  }
  while ( *a1 == 48 )
    ++a1;
  return (unsigned int)((char)*a1 - 48) <= 9;
}
// 8061BBC: using guessed type int __fastcall sub_8061BBC(_DWORD, _DWORD);
// 806B20C: using guessed type int dword_806B20C;

//----- (0805D4A9) --------------------------------------------------------
int __usercall sub_805D4A9@<eax>(int edx0@<edx>, int ecx0@<ecx>, double st7_0@<st0>, unsigned __int8 *a1, unsigned __int8 *a2, int a3, int a4)
{
  void *v7; // eax
  int v8; // edx
  int v9; // ecx
  void *v10; // eax
  int v11; // edx
  int v12; // ecx
  int result; // eax
  int v14; // ecx
  void *v15; // eax
  int v16; // ecx
  void *v17; // eax
  void *v18; // eax
  int v19; // edx
  int v20; // ecx
  void *v21; // eax
  void *v22; // eax
  int v23; // ecx
  int v24; // edx
  void *v25; // eax
  void *v26; // eax
  void *v27; // eax
  int v28; // edx
  int v29; // ecx
  void *v30; // eax
  void *v31; // eax
  unsigned __int8 v32; // [esp+Eh] [ebp-Eh]
  unsigned __int8 v33; // [esp+Fh] [ebp-Dh]
  unsigned int v34; // [esp+10h] [ebp-Ch]
  unsigned int v35; // [esp+14h] [ebp-8h]
  int v36; // [esp+18h] [ebp-4h]

  v32 = *a1;
  v33 = *a2;
  if ( v32 == 45 )
  {
    do
      v32 = *++a1;
    while ( v32 == 48 );
    v7 = &loc_805D500;
    if ( v32 == a4 )
      v7 = &loc_805D4CB;
    dword_806B20C = (int)v7;
    sub_8061BBC(ecx0, edx0);
    if ( v33 == 45 )
    {
      do
        v33 = *++a2;
      while ( v33 == 48 );
      v18 = &loc_805D622;
      if ( v33 == a4 )
        v18 = &loc_805D5ED;
      dword_806B25C = (int)v18;
      sub_80619C7(st7_0);
      while ( v32 == v33 && (unsigned int)v32 - 48 <= 9 )
      {
        do
          v32 = *++a1;
        while ( v32 == a4 );
        v33 = *++a2;
        v21 = &loc_805D669;
        if ( v33 == a4 )
          v21 = &loc_805D63A;
        dword_806B20C = (int)v21;
        sub_8061BBC(v20, v19);
      }
      if ( v32 == a3 && (unsigned int)v33 - 48 > 9 )
        goto LABEL_109;
      v22 = &loc_805D6B5;
      if ( v33 != a3 )
        v22 = &loc_805D6E2;
      dword_806B2AC = (int)v22;
      sub_80617DA(v20, v19);
      if ( (unsigned int)v32 - 48 <= 9 )
      {
        v24 = v33 - v32;
        v36 = v33 - v32;
        v34 = 0;
        while ( (unsigned int)v32 - 48 <= 9 )
        {
          do
            v32 = *++a1;
          while ( v32 == a4 );
          ++v34;
        }
        v35 = 0;
        while ( (unsigned int)v33 - 48 <= 9 )
        {
          v33 = *++a2;
          v25 = &loc_805D758;
          if ( v33 == a4 )
            v25 = &loc_805D729;
          dword_806B360 = (int)v25;
          sub_806137F(v23, v24);
          ++v35;
        }
        if ( v34 == v35 )
        {
          if ( !v34 )
          {
            dword_806B360 = (int)&locret_805DA4A;
            sub_806137F(v23, v24);
          }
          result = v36;
        }
        else if ( v34 >= v35 )
        {
          result = -1;
        }
        else
        {
          result = 1;
        }
      }
      else
      {
LABEL_109:
        result = sub_805D34B(a2, a1, a3);
      }
    }
    else
    {
      v10 = &loc_805D52C;
      if ( v32 != a3 )
        v10 = &loc_805D53F;
      dword_806B2AC = (int)v10;
      sub_80617DA(v9, v8);
      do
        v32 = *++a1;
      while ( v32 == 48 );
      if ( (unsigned int)v32 - 48 > 9 )
      {
        dword_806B270 = (int)&loc_805D579;
        sub_8061936(v12, v11);
        do
          v33 = *++a2;
        while ( v33 == 48 );
        v15 = &loc_805D5A1;
        if ( v33 == a4 )
          v15 = &loc_805D56C;
        dword_806B2C0 = (int)v15;
        sub_8061764(v14);
        if ( v33 == a3 )
        {
          v33 = a2[1];
          v17 = &loc_805D5D6;
          if ( v33 == 48 )
            v17 = &loc_805D5AA;
          dword_806B298 = (int)v17;
          sub_806184C(v16);
        }
        result = -((unsigned int)v33 - 48 <= 9);
      }
      else
      {
        result = -1;
      }
    }
  }
  else if ( v33 == 45 )
  {
    do
    {
      do
        v33 = *++a2;
      while ( v33 == 48 );
    }
    while ( v33 == a4 );
    if ( v33 == a3 )
    {
      do
        v33 = *++a2;
      while ( v33 == 48 );
    }
    if ( (unsigned int)v33 - 48 <= 9 )
    {
      dword_806B2C0 = (int)&locret_805DA4A;
      sub_8061764(ecx0);
    }
    while ( v32 == 48 || v32 == a4 )
      v32 = *++a1;
    v26 = &loc_805D85D;
    if ( v32 != a3 )
      v26 = &loc_805D870;
    dword_806B360 = (int)v26;
    sub_806137F(ecx0, edx0);
    do
      v32 = *++a1;
    while ( v32 == 48 );
    result = (unsigned int)v32 - 48 <= 9;
  }
  else
  {
    dword_806B2AC = (int)&loc_805D8A9;
    sub_80617DA(ecx0, edx0);
    do
    {
      do
        v32 = *++a1;
      while ( v32 == 48 );
    }
    while ( v32 == a4 );
    while ( v33 == 48 )
      v33 = *++a2;
    v27 = &loc_805D8EF;
    if ( v33 == a4 )
      v27 = &loc_805D8BA;
    dword_806B220 = (int)v27;
    sub_8061B42();
    while ( v32 == v33 && (unsigned int)v32 - 48 <= 9 )
    {
      do
        v32 = *++a1;
      while ( v32 == a4 );
      v33 = *++a2;
      v30 = &loc_805D936;
      if ( v33 == a4 )
        v30 = &loc_805D907;
      dword_806B270 = (int)v30;
      sub_8061936(v29, v28);
    }
    if ( v32 == a3 && (unsigned int)v33 - 48 > 9 )
      goto LABEL_110;
    v31 = &loc_805D982;
    if ( v33 != a3 )
      v31 = &loc_805D9AF;
    dword_806B2C0 = (int)v31;
    sub_8061764(v29);
    if ( (unsigned int)v32 - 48 <= 9 )
    {
      v36 = v32 - v33;
      v34 = 0;
      while ( (unsigned int)v32 - 48 <= 9 )
      {
        do
          v32 = *++a1;
        while ( v32 == a4 );
        ++v34;
      }
      v35 = 0;
      while ( (unsigned int)v33 - 48 <= 9 )
      {
        do
          v33 = *++a2;
        while ( v33 == a4 );
        ++v35;
      }
      if ( v34 == v35 )
      {
        if ( v34 )
          result = v36;
        else
          result = 0;
      }
      else if ( v34 >= v35 )
      {
        result = 1;
      }
      else
      {
        result = -1;
      }
    }
    else
    {
LABEL_110:
      result = sub_805D34B(a1, a2, a3);
    }
  }
  return result;
}
// 805D4A9: could not find valid save-restore pair for ebx
// 806137F: using guessed type int __fastcall sub_806137F(_DWORD, _DWORD);
// 8061764: using guessed type int __fastcall sub_8061764(_DWORD);
// 80617DA: using guessed type int __fastcall sub_80617DA(_DWORD, _DWORD);
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD);
// 8061936: using guessed type int __fastcall sub_8061936(_DWORD, _DWORD);
// 80619C7: using guessed type int __usercall sub_80619C7@<eax>(double@<st0>);
// 8061B42: using guessed type int sub_8061B42(void);
// 8061BBC: using guessed type int __fastcall sub_8061BBC(_DWORD, _DWORD);
// 806B20C: using guessed type int dword_806B20C;
// 806B220: using guessed type int dword_806B220;
// 806B25C: using guessed type int dword_806B25C;
// 806B270: using guessed type int dword_806B270;
// 806B298: using guessed type int dword_806B298;
// 806B2AC: using guessed type int dword_806B2AC;
// 806B2C0: using guessed type int dword_806B2C0;
// 806B360: using guessed type int dword_806B360;

//----- (0805DA4C) --------------------------------------------------------
int __usercall sub_805DA4C@<eax>(int edx0@<edx>, int ecx0@<ecx>, double st7_0@<st0>, unsigned __int8 *a1, unsigned __int8 *a2, int a3, int a4)
{
  return sub_805D4A9(edx0, ecx0, st7_0, a1, a2, a3, a4);
}

//----- (0805DA74) --------------------------------------------------------
int __cdecl sub_805DA74(int fd)
{
  int v1; // ST18_4
  int v2; // ST1C_4

  if ( fd >= 0 && fd <= 2 )
  {
    v1 = sub_8060E02(fd);
    v2 = *__errno_location();
    close(fd);
    *__errno_location() = v2;
    fd = v1;
  }
  return fd;
}

//----- (0805DABE) --------------------------------------------------------
int __cdecl sub_805DABE(FILE *stream, int a2, int a3, int a4, int a5, int a6)
{
  char *v6; // eax
  char *v7; // ebx
  char *v8; // eax
  int result; // eax
  int v10; // esi
  char *v11; // ebx
  char *v12; // eax
  int v13; // edi
  int v14; // esi
  char *v15; // ebx
  char *v16; // eax
  int v17; // edi
  int v18; // esi
  char *v19; // ebx
  char *v20; // eax
  int v21; // edx
  int v22; // ecx
  int v23; // edi
  int v24; // esi
  char *v25; // ebx
  char *v26; // eax
  int v27; // edi
  int v28; // esi
  char *v29; // ebx
  char *v30; // eax
  int v31; // esi
  int v32; // edi
  char *v33; // ebx
  char *v34; // eax
  int v35; // edx
  int v36; // ecx
  int v37; // edi
  int v38; // esi
  char *v39; // ebx
  char *v40; // eax
  int v41; // edx
  int v42; // ecx
  int v43; // edi
  int v44; // esi
  char *v45; // ebx
  char *v46; // eax
  int v47; // edx
  int v48; // ecx
  int v49; // edi
  int v50; // esi
  char *v51; // ebx
  char *v52; // eax
  char *v53; // [esp+8h] [ebp-60h]
  int v54; // [esp+Ch] [ebp-5Ch]
  int v55; // [esp+10h] [ebp-58h]
  int v56; // [esp+14h] [ebp-54h]
  int v57; // [esp+18h] [ebp-50h]
  int v58; // [esp+1Ch] [ebp-4Ch]
  int v59; // [esp+20h] [ebp-48h]
  int v60; // [esp+24h] [ebp-44h]
  int v61; // [esp+28h] [ebp-40h]
  int v62; // [esp+38h] [ebp-30h]
  int v63; // [esp+3Ch] [ebp-2Ch]
  int v64; // [esp+40h] [ebp-28h]
  int v65; // [esp+44h] [ebp-24h]
  int v66; // [esp+48h] [ebp-20h]
  int v67; // [esp+4Ch] [ebp-1Ch]

  if ( a2 )
  {
    v55 = a4;
    fprintf(stream, "%s (%s) %s\n", a2, a3, a4);
  }
  else
  {
    fprintf(stream, "%s %s\n", a3, a4);
  }
  v54 = 2017;
  v53 = gettext("(C)");
  fprintf(stream, "Copyright %s %d Free Software Foundation, Inc.", v53, 2017);
  v6 = gettext(
         "\n"
         "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\n"
         "This is free software: you are free to change and redistribute it.\n"
         "There is NO WARRANTY, to the extent permitted by law.\n"
         "\n");
  fputs_unlocked(v6, stream);
  switch ( a6 )
  {
    case 0:
      abort();
      return result;
    case 1:
      v7 = *(char **)a5;
      v8 = gettext("Written by %s.\n");
      return fprintf(stream, v8, v7);
    case 2:
      v10 = *(_DWORD *)(a5 + 4);
      v11 = *(char **)a5;
      v12 = gettext("Written by %s and %s.\n");
      return fprintf(stream, v12, v11, v10);
    case 3:
      v13 = *(_DWORD *)(a5 + 8);
      v14 = *(_DWORD *)(a5 + 4);
      v15 = *(char **)a5;
      v16 = gettext("Written by %s, %s, and %s.\n");
      return fprintf(stream, v16, v15, v14, v13);
    case 4:
      v67 = *(_DWORD *)(a5 + 12);
      v17 = *(_DWORD *)(a5 + 8);
      v18 = *(_DWORD *)(a5 + 4);
      v19 = *(char **)a5;
      v20 = gettext("Written by %s, %s, %s,\nand %s.\n");
      v56 = v67;
      v55 = v17;
      v54 = v18;
      v53 = v19;
      fprintf(stream, v20, v19, v18, v17, v67);
      dword_806B388 = (int)&loc_805E00B;
      sub_8061252(v22, v21);
      goto LABEL_10;
    case 5:
LABEL_10:
      v67 = *(_DWORD *)(a5 + 16);
      v66 = *(_DWORD *)(a5 + 12);
      v23 = *(_DWORD *)(a5 + 8);
      v24 = *(_DWORD *)(a5 + 4);
      v25 = *(char **)a5;
      v26 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
      v57 = v67;
      v56 = v66;
      v55 = v23;
      v54 = v24;
      v53 = v25;
      return fprintf(stream, v26, v25, v24, v23, v66, v67);
    case 6:
      v67 = *(_DWORD *)(a5 + 20);
      v66 = *(_DWORD *)(a5 + 16);
      v65 = *(_DWORD *)(a5 + 12);
      v27 = *(_DWORD *)(a5 + 8);
      v28 = *(_DWORD *)(a5 + 4);
      v29 = *(char **)a5;
      v30 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
      return fprintf(stream, v30, v29, v28, v27, v65, v66, v67);
    case 7:
      v31 = *(_DWORD *)(a5 + 24);
      v67 = *(_DWORD *)(a5 + 20);
      v66 = *(_DWORD *)(a5 + 16);
      v65 = *(_DWORD *)(a5 + 12);
      v64 = *(_DWORD *)(a5 + 8);
      v32 = *(_DWORD *)(a5 + 4);
      v33 = *(char **)a5;
      v34 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
      v59 = v31;
      v58 = v67;
      v57 = v66;
      v56 = v65;
      v55 = v64;
      v54 = v32;
      v53 = v33;
      fprintf(stream, v34, v33, v32, v64, v65, v66, v67, v31);
      dword_806B234 = (int)&loc_805E00B;
      sub_8061AC8(v36, v35);
      goto LABEL_13;
    case 8:
LABEL_13:
      v37 = *(_DWORD *)(a5 + 28);
      v67 = *(_DWORD *)(a5 + 24);
      v66 = *(_DWORD *)(a5 + 20);
      v65 = *(_DWORD *)(a5 + 16);
      v64 = *(_DWORD *)(a5 + 12);
      v63 = *(_DWORD *)(a5 + 8);
      v38 = *(_DWORD *)(a5 + 4);
      v39 = *(char **)a5;
      v40 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
      v60 = v37;
      v59 = v67;
      v58 = v66;
      v57 = v65;
      v56 = v64;
      v55 = v63;
      v54 = v38;
      v53 = v39;
      fprintf(stream, v40, v39, v38, v63, v64, v65, v66, v67, v37);
      dword_806B234 = (int)&loc_805E00B;
      sub_8061AC8(v42, v41);
      goto LABEL_14;
    case 9:
LABEL_14:
      v43 = *(_DWORD *)(a5 + 32);
      v67 = *(_DWORD *)(a5 + 28);
      v66 = *(_DWORD *)(a5 + 24);
      v65 = *(_DWORD *)(a5 + 20);
      v64 = *(_DWORD *)(a5 + 16);
      v63 = *(_DWORD *)(a5 + 12);
      v62 = *(_DWORD *)(a5 + 8);
      v44 = *(_DWORD *)(a5 + 4);
      v45 = *(char **)a5;
      v46 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
      v61 = v43;
      v60 = v67;
      v59 = v66;
      v58 = v65;
      v57 = v64;
      v56 = v63;
      v55 = v62;
      v54 = v44;
      v53 = v45;
      fprintf(stream, v46, v45, v44, v62, v63, v64, v65, v66, v67, v43);
      dword_806B270 = (int)&loc_805E00B;
      sub_8061936(v48, v47);
      break;
    default:
      break;
  }
  v49 = *(_DWORD *)(a5 + 32);
  v67 = *(_DWORD *)(a5 + 28);
  v66 = *(_DWORD *)(a5 + 24);
  v65 = *(_DWORD *)(a5 + 20);
  v64 = *(_DWORD *)(a5 + 16);
  v63 = *(_DWORD *)(a5 + 12);
  v62 = *(_DWORD *)(a5 + 8);
  v50 = *(_DWORD *)(a5 + 4);
  v51 = *(char **)a5;
  v52 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
  v61 = v49;
  v60 = v67;
  v59 = v66;
  v58 = v65;
  v57 = v64;
  v56 = v63;
  v55 = v62;
  v54 = v50;
  v53 = v51;
  return fprintf(stream, v52, v51, v50, v62, v63, v64, v65, v66, v67, v49);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8061252: using guessed type int __fastcall sub_8061252(_DWORD, _DWORD);
// 8061936: using guessed type int __fastcall sub_8061936(_DWORD, _DWORD);
// 8061AC8: using guessed type double __fastcall sub_8061AC8(_DWORD, _DWORD);
// 806B234: using guessed type int dword_806B234;
// 806B270: using guessed type int dword_806B270;
// 806B388: using guessed type int dword_806B388;

//----- (0805E06B) --------------------------------------------------------
int __cdecl sub_805E06B(FILE *stream, int a2, int a3, int a4, int a5)
{
  int *v5; // eax
  unsigned int i; // [esp+24h] [ebp-34h]
  int v8[12]; // [esp+28h] [ebp-30h]

  for ( i = 0; i <= 9; ++i )
  {
    v5 = (int *)a5;
    a5 += 4;
    v8[i] = *v5;
    if ( !v8[i] )
      break;
  }
  return sub_805DABE(stream, a2, a3, a4, (int)v8, i);
}
// 805E06B: using guessed type int var_30[12];

//----- (0805E0D1) --------------------------------------------------------
int sub_805E0D1(FILE *stream, int a2, int a3, int a4, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a4);
  return sub_805E06B(stream, a2, a3, a4, (int)va);
}

//----- (0805E171) --------------------------------------------------------
void *__cdecl sub_805E171(unsigned int a1, unsigned int a2)
{
  if ( 0x7FFFFFFF / a2 < a1 )
    sub_805E44B();
  return sub_805E2B0(a2 * a1);
}

//----- (0805E1D4) --------------------------------------------------------
void *__usercall sub_805E1D4@<eax>(int a1@<edx>, int ecx0@<ecx>, void *ptr, int a2, int a3)
{
  void *v5; // eax
  int v6; // edx
  int v7; // ecx
  void *v8; // eax
  int v10; // [esp+1Ch] [ebp-Ch]
  unsigned int v11; // [esp+1Ch] [ebp-Ch]

  v10 = *(_DWORD *)a2;
  v5 = &loc_805E201;
  if ( ptr )
    v5 = &loc_805E254;
  dword_806B270 = (int)v5;
  sub_8061936(ecx0, a1);
  v8 = &loc_805E220;
  if ( v10 )
    v8 = &loc_805E23D;
  dword_806B310 = (int)v8;
  sub_8061566(v7, v6);
  v11 = (0x40u / a3 == 0) + 0x40u / a3;
  if ( 0x7FFFFFFFu / a3 < v11 )
    sub_805E44B();
  *(_DWORD *)a2 = v11;
  return sub_805E2F3(ptr, a3 * v11);
}
// 805E1D4: could not find valid save-restore pair for ebx
// 8061566: using guessed type int __fastcall sub_8061566(_DWORD, _DWORD);
// 8061936: using guessed type int __fastcall sub_8061936(_DWORD, _DWORD);
// 806B270: using guessed type int dword_806B270;
// 806B310: using guessed type int dword_806B310;

//----- (0805E29D) --------------------------------------------------------
void *__cdecl sub_805E29D(size_t size)
{
  return sub_805E2B0(size);
}

//----- (0805E2B0) --------------------------------------------------------
void *__cdecl sub_805E2B0(size_t size)
{
  void *v1; // eax
  bool v2; // zf
  void *v3; // eax
  void *v5; // [esp+1Ch] [ebp-Ch]

  v1 = malloc(size);
  v5 = v1;
  v2 = v1 == 0;
  v3 = &loc_805E2E3;
  if ( !v2 )
    v3 = &loc_805E2EE;
  dword_806B374 = (int)v3;
  sub_80612DD();
  if ( size )
    sub_805E44B();
  return v5;
}
// 80612DD: using guessed type int sub_80612DD(void);
// 806B374: using guessed type int dword_806B374;

//----- (0805E2F3) --------------------------------------------------------
void *__cdecl sub_805E2F3(void *ptr, size_t size)
{
  int v2; // ecx
  void *v3; // eax
  void *result; // eax
  void *v5; // eax
  void *ptra; // [esp+20h] [ebp+8h]

  v3 = &loc_805E318;
  if ( size )
    v3 = &loc_805E330;
  dword_806B298 = (int)v3;
  sub_806184C(v2);
  if ( ptr )
  {
    free(ptr);
    result = 0;
  }
  else
  {
    ptra = realloc(0, size);
    if ( !ptra )
    {
      v5 = &loc_805E36A;
      if ( !size )
        v5 = &loc_805E36F;
      dword_806B2FC = (int)v5;
      sub_80615DC();
      sub_805E44B();
    }
    result = ptra;
  }
  return result;
}
// 80615DC: using guessed type int sub_80615DC(void);
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD);
// 806B298: using guessed type int dword_806B298;
// 806B2FC: using guessed type int dword_806B2FC;

//----- (0805E3C0) --------------------------------------------------------
void *__cdecl sub_805E3C0(size_t nmemb, size_t size)
{
  void *v3; // [esp+1Ch] [ebp-Ch]

  if ( 0x7FFFFFFF / size < nmemb || (v3 = calloc(nmemb, size)) == 0 )
    sub_805E44B();
  return v3;
}

//----- (0805E3FD) --------------------------------------------------------
void *__cdecl sub_805E3FD(void *src, size_t n)
{
  void *v2; // eax

  v2 = sub_805E2B0(n);
  return memcpy(v2, src, n);
}

//----- (0805E44B) --------------------------------------------------------
void __noreturn sub_805E44B()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (0805E484) --------------------------------------------------------
void __usercall sub_805E484(long double a1@<st0>, int errnum, int a3, int a4, int a5, int a6)
{
  char *v6; // eax
  char *v7; // eax
  void *v8; // esi
  void *v9; // ebx
  char *v10; // eax

  v6 = gettext("string comparison failed");
  error(0, errnum, v6);
  v7 = gettext("Set LC_ALL='C' to work around the problem.");
  error(0, 0, v7);
  v8 = sub_805B9A5(a1, 1, 8, (char *)a5, a6);
  v9 = sub_805B9A5(a1, 0, 8, (char *)a3, a4);
  v10 = gettext("The strings compared were %s and %s.");
  error(status, 0, v10, v9, v8);
}

//----- (0805E5CE) --------------------------------------------------------
int __usercall sub_805E5CE@<eax>(long double a1@<st0>, int a2@<edx>, int a3@<ecx>, void *s1, size_t n, void *s2, int a5)
{
  int v8; // [esp+28h] [ebp-10h]
  int errnum; // [esp+2Ch] [ebp-Ch]

  v8 = sub_8060C9A(a2, a3, s1, n, s2, a5);
  errnum = *__errno_location();
  if ( errnum )
    sub_805E484(a1, errnum, (int)s1, n - 1, (int)s2, a5 - 1);
  return v8;
}

//----- (0805E639) --------------------------------------------------------
signed int __cdecl sub_805E639(double a1)
{
  bool v2; // zf
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  struct timespec requested_time; // [esp+28h] [ebp-10h]

  sub_80601F9(&requested_time, a1);
  do
  {
    *__errno_location() = 0;
    if ( !nanosleep(&requested_time, 0) )
      return 0;
  }
  while ( *__errno_location() == 4 );
  v2 = *__errno_location() == 0;
  v5 = &loc_805E6B9;
  if ( v2 )
    v5 = &loc_805E6C0;
  dword_806B2D4 = (int)v5;
  sub_80616F8(v4, v3);
  return -1;
}
// 80616F8: using guessed type int __fastcall sub_80616F8(_DWORD, _DWORD);
// 806B2D4: using guessed type int dword_806B2D4;

//----- (0805E6C4) --------------------------------------------------------
signed int __cdecl sub_805E6C4(unsigned int *a1, unsigned int a2)
{
  signed int result; // eax

  if ( 0xFFFFFFFF / a2 >= *a1 )
  {
    *a1 *= a2;
    result = 0;
  }
  else
  {
    *a1 = -1;
    result = 1;
  }
  return result;
}

//----- (0805E708) --------------------------------------------------------
int __cdecl sub_805E708(unsigned int *a1, unsigned int a2, int a3)
{
  int v3; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; i |= sub_805E6C4(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}

//----- (0805E73E) --------------------------------------------------------
void __cdecl __noreturn sub_805E73E(int a1, int a2, signed int a3)
{
  void *v3; // eax
  int v4; // ecx
  void *v5; // eax
  int v6; // edx
  int v7; // ecx

  if ( a3 >= 0 )
  {
    v3 = &loc_805E770;
    if ( a3 > 36 )
      v3 = &loc_805E7A6;
    dword_806B220 = (int)v3;
    sub_8061B42();
    v5 = &loc_805E78F;
    if ( a2 )
      v5 = &loc_805E7E4;
    dword_806B298 = (int)v5;
    sub_806184C(v4);
    dword_806B2D4 = (int)sub_805E7CA;
    sub_80616F8(v7, v6);
  }
  __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoul");
}
// 80616F8: using guessed type int __fastcall sub_80616F8(_DWORD, _DWORD);
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD);
// 8061B42: using guessed type int sub_8061B42(void);
// 806B220: using guessed type int dword_806B220;
// 806B298: using guessed type int dword_806B298;
// 806B2D4: using guessed type int dword_806B2D4;

//----- (0805E7CA) --------------------------------------------------------
#error "805EC31: positive sp value has been found (funcsize=319)"

//----- (0805EC32) --------------------------------------------------------
void __usercall sub_805EC32(int edx0@<edx>, int ecx0@<ecx>, int a1, int a2, int a3, int a4, int a5, int status)
{
  int v8; // eax
  bool v9; // zf
  void *v10; // eax
  char *v11; // eax
  const char *v12; // [esp+Ch] [ebp-2Ch]
  char *v13; // [esp+10h] [ebp-28h]
  int v14; // [esp+14h] [ebp-24h]
  char v15; // [esp+1Ch] [ebp-1Ch]
  char v16; // [esp+22h] [ebp-16h]
  char v17; // [esp+23h] [ebp-15h]
  const char *v18; // [esp+24h] [ebp-14h]
  char *msgid; // [esp+28h] [ebp-10h]
  char *v20; // [esp+2Ch] [ebp-Ch]

  v15 = a3;
  v18 = "--";
  v8 = a1;
  if ( (unsigned int)a1 > 3 )
  {
LABEL_5:
    v9 = v8 == 4;
    v10 = &loc_805EC8C;
    if ( v9 )
      v10 = &loc_805EC91;
    dword_806B310 = (int)v10;
    sub_8061566(ecx0, edx0);
    abort();
  }
  if ( (unsigned int)a1 >= 2 )
  {
    msgid = "invalid suffix in %s%s argument '%s'";
    dword_806B360 = (int)&loc_805ECBF;
    sub_806137F(ecx0, edx0);
  }
  else if ( a1 != 1 )
  {
    dword_806B324 = (int)&loc_805EC8C;
    v8 = sub_80614D5(ecx0, edx0);
    goto LABEL_5;
  }
  msgid = "%s%s argument '%s' too large";
  if ( a2 >= 0 )
  {
    v20 = *(char **)(16 * a2 + a4);
  }
  else
  {
    v18 -= a2;
    v16 = v15;
    v17 = 0;
    v20 = &v16;
  }
  v11 = gettext(msgid);
  v14 = a5;
  v13 = v20;
  v12 = v18;
  error(status, 0, v11, v18, v20, a5);
}
// 806137F: using guessed type int __fastcall sub_806137F(_DWORD, _DWORD);
// 80614D5: using guessed type int __fastcall sub_80614D5(_DWORD, _DWORD);
// 8061566: using guessed type int __fastcall sub_8061566(_DWORD, _DWORD);
// 806B310: using guessed type int dword_806B310;
// 806B324: using guessed type int dword_806B324;
// 806B360: using guessed type int dword_806B360;

//----- (0805ED2B) --------------------------------------------------------
void __fastcall __noreturn sub_805ED2B(int ecx0, int edx0, int a1, int a2, char a3, int a4, int a5)
{
  sub_805EC32(a4, ecx0, a1, a2, a3, a4, a5, status);
  abort();
}

//----- (0805ED6E) --------------------------------------------------------
int __cdecl sub_805ED6E(_DWORD *a1, signed int a2)
{
  unsigned __int64 v2; // rcx
  int v3; // ebx

  v2 = sub_8060E27(0xFFFFFFFFFFFFFFFFLL, a2, a2 >> 31);
  if ( v2 < *(_QWORD *)a1 )
  {
    *a1 = -1;
    a1[1] = -1;
    dword_806B2C0 = (int)&loc_805EE07;
    sub_8061764(v2);
  }
  v3 = a1[1];
  *(_QWORD *)a1 *= a2;
  return 0;
}
// 8061764: using guessed type int __fastcall sub_8061764(_DWORD);
// 806B2C0: using guessed type int dword_806B2C0;

//----- (0805EE0F) --------------------------------------------------------
int __cdecl sub_805EE0F(_DWORD *a1, signed int a2, int a3)
{
  int v3; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; ; i |= sub_805ED6E(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}

//----- (0805EE45) --------------------------------------------------------
int __cdecl sub_805EE45(char *nptr, int a2, int base, int a4, char *s)
{
  int v5; // ecx
  int result; // eax
  int v7; // edx
  bool v8; // zf
  void *v9; // eax
  int v10; // edx
  int v11; // edx
  int v12; // [esp+4h] [ebp-44h]
  unsigned __int8 i; // [esp+1Bh] [ebp-2Dh]
  int v14; // [esp+20h] [ebp-28h]
  char *v15; // [esp+24h] [ebp-24h]
  int v16; // [esp+28h] [ebp-20h]
  int v17; // [esp+2Ch] [ebp-1Ch]
  char **endptr; // [esp+34h] [ebp-14h]
  uintmax_t v19; // [esp+38h] [ebp-10h]

  v14 = 0;
  if ( base < 0 || base > 36 )
LABEL_5:
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoumax");
  if ( !a2 )
  {
    dword_806B34C = (int)&loc_805EE9F;
    sub_80613F7(v5);
    goto LABEL_5;
  }
  endptr = (char **)a2;
  *__errno_location() = 0;
  v15 = nptr;
  for ( i = *nptr; (*__ctype_b_loc())[i] & 0x2000; i = *v15 )
    ++v15;
  if ( i == 45 )
    return 4;
  v19 = strtoumax(nptr, endptr, base);
  if ( *endptr == nptr )
  {
    if ( !s || !**endptr || !strchr(s, **endptr) )
      return 4;
    v19 = 1LL;
  }
  else if ( *__errno_location() )
  {
    if ( *__errno_location() != 34 )
    {
      dword_806B374 = (int)&locret_805F2A0;
      sub_80612DD();
    }
    v14 = 1;
  }
  if ( s )
  {
    if ( **endptr )
    {
      v16 = 1024;
      v17 = 1;
      v12 = **endptr;
      v8 = strchr(s, v12) == 0;
      v9 = &loc_805F01F;
      if ( !v8 )
        v9 = &loc_805F038;
      dword_806B284 = (int)v9;
      sub_80618C2();
      v10 = HIDWORD(v19);
      *(_DWORD *)a4 = v19;
      *(_DWORD *)(a4 + 4) = v10;
      result = v14 | 2;
    }
    else
    {
      v11 = HIDWORD(v19);
      *(_DWORD *)a4 = v19;
      *(_DWORD *)(a4 + 4) = v11;
      result = v14;
    }
  }
  else
  {
    v7 = HIDWORD(v19);
    *(_DWORD *)a4 = v19;
    *(_DWORD *)(a4 + 4) = v7;
    result = v14;
  }
  return result;
}
// 80612DD: using guessed type int sub_80612DD(void);
// 80613F7: using guessed type int __fastcall sub_80613F7(_DWORD);
// 80618C2: using guessed type int sub_80618C2(void);
// 806B284: using guessed type int dword_806B284;
// 806B34C: using guessed type int dword_806B34C;
// 806B374: using guessed type int dword_806B374;

//----- (0805F2A2) --------------------------------------------------------
int __usercall sub_805F2A2@<eax>(double a1@<st0>, FILE *stream)
{
  int v3; // eax
  __int64 v4; // rax
  void *v5; // eax
  int v6; // [esp+14h] [ebp-14h]

  v6 = 0;
  if ( fileno(stream) < 0 )
    return fclose(stream);
  if ( !__freading(stream) || (v3 = fileno(stream), LODWORD(v4) = lseek64(v3, 0, 0, 1), v4 != -1) )
  {
    if ( sub_805F557(a1, stream) )
      v6 = *__errno_location();
  }
  fclose(stream);
  v5 = &loc_805F368;
  if ( !v6 )
    v5 = &loc_805F379;
  dword_806B220 = (int)v5;
  sub_8061B42();
  *__errno_location() = v6;
  return -1;
}
// 8049A90: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8061B42: using guessed type int sub_8061B42(void);
// 806B220: using guessed type int dword_806B220;

//----- (0805F37E) --------------------------------------------------------
int __cdecl sub_805F37E(int fd, int cmd, char a3)
{
  bool v3; // zf
  void *v4; // eax
  int v5; // ST30_4
  int v7; // [esp+1Ch] [ebp-1Ch]
  char v8; // [esp+20h] [ebp-18h]
  int v9; // [esp+24h] [ebp-14h]

  if ( cmd != 1030 )
    return fcntl(fd, cmd, a3);
  v8 = a3;
  if ( dword_806C511 < 0 )
  {
    v7 = sub_805F37E(fd, 0, a3);
  }
  else
  {
    v7 = fcntl(fd, 1030, a3);
    if ( v7 < 0 && *__errno_location() == 22 )
    {
      v7 = sub_805F37E(fd, 0, v8);
      if ( v7 < 0 )
        return v7;
      dword_806C511 = -1;
    }
    else
    {
      dword_806C511 = 1;
    }
  }
  if ( v7 >= 0 && dword_806C511 == -1 )
  {
    v9 = fcntl(v7, 1);
    if ( v9 >= 0 )
    {
      v3 = fcntl(v7, 2, v9 | 1) == -1;
      v4 = &loc_805F4AC;
      if ( !v3 )
        v4 = &loc_805F4D4;
      dword_806B248 = (int)v4;
      sub_8061A50();
    }
    v5 = *__errno_location();
    close(v7);
    *__errno_location() = v5;
    v7 = -1;
  }
  return v7;
}
// 8061A50: using guessed type int sub_8061A50(void);
// 806B248: using guessed type int dword_806B248;
// 806C511: using guessed type int dword_806C511;

//----- (0805F505) --------------------------------------------------------
int __usercall sub_805F505@<eax>(double a1@<st0>, int a2@<edx>, int a3@<ecx>, FILE *stream)
{
  void *v4; // eax

  v4 = &loc_805F532;
  if ( !(stream->_flags & 0x100) )
    v4 = &locret_805F555;
  dword_806B310 = (int)v4;
  sub_8061566(a3, a2);
  return sub_805F597(a1, stream, 0, 0, 1);
}
// 8061566: using guessed type int __fastcall sub_8061566(_DWORD, _DWORD);
// 806B310: using guessed type int dword_806B310;

//----- (0805F557) --------------------------------------------------------
int __usercall sub_805F557@<eax>(double a1@<st0>, FILE *fp)
{
  int v2; // edx
  int v3; // ecx

  if ( !fp || !__freading(fp) )
    return fflush(fp);
  sub_805F505(a1, v2, v3, fp);
  return fflush(fp);
}

//----- (0805F597) --------------------------------------------------------
int __usercall sub_805F597@<eax>(double a1@<st0>, FILE *stream, int a3, int a4, int a5)
{
  void *v5; // eax
  int v6; // eax
  __int64 v7; // rax
  int v8; // ecx
  bool v9; // zf
  void *v10; // eax

  v5 = &loc_805F5D2;
  if ( stream->_IO_read_end != stream->_IO_read_ptr )
    v5 = &loc_805F67D;
  dword_806B338 = (int)v5;
  sub_8061467(a1);
  if ( stream->_IO_write_ptr != stream->_IO_write_base || stream->_IO_save_base )
    return fseeko64(stream, a3, a4, a5);
  v6 = fileno(stream);
  LODWORD(v7) = lseek64(v6, a3, a4, a5);
  v9 = v7 == -1;
  v10 = &loc_805F651;
  if ( !v9 )
    v10 = &loc_805F658;
  dword_806B34C = (int)v10;
  sub_80613F7(v8);
  return -1;
}
// 805F597: could not find valid save-restore pair for ebx
// 80498B0: using guessed type int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8049A90: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 80613F7: using guessed type int __fastcall sub_80613F7(_DWORD);
// 8061467: using guessed type int __usercall sub_8061467@<eax>(double@<st0>);
// 806B338: using guessed type int dword_806B338;
// 806B34C: using guessed type int dword_806B34C;

//----- (0805F69F) --------------------------------------------------------
size_t __cdecl sub_805F69F(wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  bool v4; // zf
  int v5; // edx
  int v6; // ecx
  void *v7; // eax
  char v9; // [esp+18h] [ebp-10h]
  size_t v10; // [esp+1Ch] [ebp-Ch]

  if ( !pwc )
    pwc = (wchar_t *)&v9;
  v10 = mbrtowc(pwc, s, n, p);
  if ( v10 <= 0xFFFFFFFD || !n )
    return v10;
  v4 = (unsigned __int8)sub_8057A49(0) == 1;
  v7 = &loc_805F70C;
  if ( v4 )
    v7 = &loc_805F725;
  dword_806B234 = (int)v7;
  sub_8061AC8(v6, v5);
  *pwc = (unsigned __int8)*s;
  return 1;
}
// 8061AC8: using guessed type double __fastcall sub_8061AC8(_DWORD, _DWORD);
// 806B234: using guessed type int dword_806B234;

//----- (0805F72A) --------------------------------------------------------
int __cdecl sub_805F72A(int a1, int a2)
{
  int result; // eax

  if ( *(_BYTE *)(a1 + 40) & 1 )
    result = (*(int (__cdecl **)(_DWORD, int))(a1 + 28))(*(_DWORD *)(a1 + 36), a2);
  else
    result = (*(int (__cdecl **)(int))(a1 + 28))(a2);
  return result;
}

//----- (0805F768) --------------------------------------------------------
int __cdecl sub_805F768(int a1, int a2)
{
  void *v2; // eax

  v2 = &loc_805F795;
  if ( !(*(_BYTE *)(a1 + 40) & 1) )
    v2 = &loc_805F7AF;
  dword_806B374 = (int)v2;
  sub_80612DD();
  return (*(int (__cdecl **)(_DWORD, int))(a1 + 32))(*(_DWORD *)(a1 + 36), a2);
}
// 80612DD: using guessed type int sub_80612DD(void);
// 806B374: using guessed type int dword_806B374;

//----- (0805F7BF) --------------------------------------------------------
signed int __usercall sub_805F7BF@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5)
{
  void *v5; // eax
  int v6; // edx
  int v7; // ecx
  void *v8; // eax
  _DWORD *v10; // [esp+1Ch] [ebp-Ch]

  v5 = &loc_805F7E4;
  if ( a5 )
    v5 = &loc_805F7EB;
  dword_806B270 = (int)v5;
  sub_8061936(a2, a1);
  v8 = &loc_805F80A;
  if ( a4 )
    v8 = &loc_805F81C;
  dword_806B20C = (int)v8;
  sub_8061BBC(v7, v6);
  *(_DWORD *)a3 = 4064;
  *(_DWORD *)(a3 + 24) = 7;
  *(_DWORD *)(a3 + 4) = sub_805F72A(a3, *(_DWORD *)a3);
  v10 = *(_DWORD **)(a3 + 4);
  if ( !v10 )
    obstack_alloc_failed_handler();
  *(_DWORD *)(a3 + 8) = ((unsigned int)v10 + 15) & 0xFFFFFFF8;
  *(_DWORD *)(a3 + 12) = *(_DWORD *)(a3 + 8);
  *v10 = (char *)v10 + *(_DWORD *)a3;
  *(_DWORD *)(a3 + 16) = *v10;
  v10[1] = 0;
  *(_BYTE *)(a3 + 40) &= 0xFDu;
  *(_BYTE *)(a3 + 40) &= 0xFBu;
  return 1;
}
// 805F7BF: could not find valid save-restore pair for ebx
// 8061936: using guessed type int __fastcall sub_8061936(_DWORD, _DWORD);
// 8061BBC: using guessed type int __fastcall sub_8061BBC(_DWORD, _DWORD);
// 806B20C: using guessed type int dword_806B20C;
// 806B270: using guessed type int dword_806B270;
// 806B540: using guessed type int (*obstack_alloc_failed_handler)(void);

//----- (0805F8D0) --------------------------------------------------------
signed int __cdecl sub_805F8D0(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // ecx
  int v6; // edx

  *(_DWORD *)(a1 + 28) = a4;
  *(_DWORD *)(a1 + 32) = a5;
  v6 = *(_BYTE *)(a1 + 40) & 0xFE;
  *(_BYTE *)(a1 + 40) = v6;
  return sub_805F7BF(v6, v5, a1, a2, a3);
}

//----- (0805F959) --------------------------------------------------------
int __cdecl sub_805F959(int a1, int a2)
{
  int result; // eax
  _DWORD *v3; // [esp+14h] [ebp-24h]
  unsigned int v4; // [esp+18h] [ebp-20h]
  int v5; // [esp+1Ch] [ebp-1Ch]
  unsigned int n; // [esp+20h] [ebp-18h]
  unsigned int v7; // [esp+24h] [ebp-14h]
  unsigned int v8; // [esp+28h] [ebp-10h]
  void *dest; // [esp+2Ch] [ebp-Ch]

  v5 = *(_DWORD *)(a1 + 4);
  v3 = 0;
  n = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 8);
  v7 = n + a2;
  v8 = *(_DWORD *)(a1 + 24) + n + a2;
  v4 = (n >> 3) + v8 + 100;
  if ( v4 < v8 )
    v4 = *(_DWORD *)(a1 + 24) + n + a2;
  if ( *(_DWORD *)a1 > v4 )
    v4 = *(_DWORD *)a1;
  if ( n <= v7 && v7 <= v8 )
    v3 = (_DWORD *)sub_805F72A(a1, v4);
  if ( !v3 )
    obstack_alloc_failed_handler();
  *(_DWORD *)(a1 + 4) = v3;
  v3[1] = v5;
  *(_DWORD *)(a1 + 16) = (char *)v3 + v4;
  *v3 = *(_DWORD *)(a1 + 16);
  dest = (void *)(((unsigned int)v3 + *(_DWORD *)(a1 + 24) + 8) & ~*(_DWORD *)(a1 + 24));
  memcpy(dest, *(const void **)(a1 + 8), n);
  if ( !(*(_BYTE *)(a1 + 40) & 2) && *(_DWORD *)(a1 + 8) == ((*(_DWORD *)(a1 + 24) + v5 + 8) & ~*(_DWORD *)(a1 + 24)) )
  {
    v3[1] = *(_DWORD *)(v5 + 4);
    sub_805F768(a1, v5);
  }
  *(_DWORD *)(a1 + 8) = dest;
  *(_DWORD *)(a1 + 12) = n + *(_DWORD *)(a1 + 8);
  result = a1;
  *(_BYTE *)(a1 + 40) &= 0xFDu;
  return result;
}
// 806B540: using guessed type int (*obstack_alloc_failed_handler)(void);

//----- (0805FB23) --------------------------------------------------------
int __cdecl sub_805FB23(int a1, unsigned int a2)
{
  int result; // eax
  int *v3; // [esp+18h] [ebp-10h]
  int *v4; // [esp+1Ch] [ebp-Ch]

  result = *(_DWORD *)(a1 + 4);
  v3 = *(int **)(a1 + 4);
  while ( v3 )
  {
    if ( (unsigned int)v3 < a2 )
    {
      result = *v3;
      if ( *v3 >= a2 )
        break;
    }
    v4 = (int *)v3[1];
    sub_805F768(a1, (int)v3);
    v3 = v4;
    result = a1;
    *(_BYTE *)(a1 + 40) |= 2u;
  }
  if ( v3 )
  {
    *(_DWORD *)(a1 + 12) = a2;
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 16) = *v3;
    *(_DWORD *)(a1 + 4) = v3;
    dword_806B220 = (int)&locret_805FBCB;
    result = sub_8061B42();
  }
  if ( a2 )
    abort();
  return result;
}
// 8061B42: using guessed type int sub_8061B42(void);
// 806B220: using guessed type int dword_806B220;

//----- (0805FD67) --------------------------------------------------------
int __cdecl sub_805FD67(int a1, char a2)
{
  return __ROR4__(a1, a2);
}

//----- (0805FE52) --------------------------------------------------------
int __cdecl sub_805FE52(signed int a1)
{
  int v1; // ecx
  signed int v2; // eax

  v2 = a1;
  if ( a1 > 90 )
  {
LABEL_5:
    if ( (unsigned int)(v2 - 97) <= 0x19 )
      goto LABEL_6;
    return 0;
  }
  if ( a1 >= 65 )
  {
LABEL_6:
    dword_806B298 = (int)&loc_805FEAA;
    sub_806184C(v1);
    return 0;
  }
  if ( (unsigned int)(a1 - 48) <= 9 )
  {
    dword_806B248 = (int)&loc_805FE89;
    v2 = sub_8061A50();
    goto LABEL_5;
  }
  return 0;
}
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD);
// 8061A50: using guessed type int sub_8061A50(void);
// 806B248: using guessed type int dword_806B248;
// 806B298: using guessed type int dword_806B298;

//----- (0805FEAC) --------------------------------------------------------
signed int __usercall sub_805FEAC@<eax>(int edx0@<edx>, int a2@<ecx>, signed int a1)
{
  void *v3; // eax
  signed int result; // eax

  if ( a1 < 65 )
    goto LABEL_9;
  v3 = &loc_805FED5;
  if ( a1 <= 90 )
    v3 = &loc_805FEDD;
  dword_806B20C = (int)v3;
  if ( (unsigned int)(sub_8061BBC(a2, edx0) - 97) > 0x19 )
LABEL_9:
    result = 0;
  else
    result = 1;
  return result;
}
// 8061BBC: using guessed type int __fastcall sub_8061BBC(_DWORD, _DWORD);
// 806B20C: using guessed type int dword_806B20C;

//----- (0805FF77) --------------------------------------------------------
int __cdecl sub_805FF77(int a1)
{
  if ( (unsigned int)(a1 - 48) <= 9 )
  {
    dword_806B220 = (int)&loc_805FFA6;
    sub_8061B42();
  }
  return 0;
}
// 8061B42: using guessed type int sub_8061B42(void);
// 806B220: using guessed type int dword_806B220;

//----- (0806004B) --------------------------------------------------------
int __cdecl sub_806004B(signed int a1)
{
  if ( a1 >= 9 && (a1 <= 13 || a1 == 32) )
  {
    dword_806B2FC = (int)&loc_8060081;
    sub_80615DC();
  }
  return 0;
}
// 80615DC: using guessed type int sub_80615DC(void);
// 806B2FC: using guessed type int dword_806B2FC;

//----- (080600C4) --------------------------------------------------------
int __cdecl sub_80600C4(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 65) > 0x19 )
    result = a1;
  else
    result = a1 + 32;
  return result;
}

//----- (080600FA) --------------------------------------------------------
int __cdecl sub_80600FA(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // esi
  unsigned __int8 *v3; // ebx
  unsigned __int8 v5; // [esp+1Eh] [ebp-Ah]
  unsigned __int8 v6; // [esp+1Fh] [ebp-9h]

  v2 = a1;
  v3 = a2;
  if ( a1 == a2 )
    return 0;
  do
  {
    v5 = sub_80600C4(*v2);
    v6 = sub_80600C4(*v3);
    if ( !v5 )
      break;
    ++v2;
    ++v3;
  }
  while ( v5 == v6 );
  return v5 - v6;
}

//----- (0806015F) --------------------------------------------------------
int __usercall sub_806015F@<eax>(double a1@<st0>, FILE *fp)
{
  bool v2; // ST26_1
  int v3; // ecx
  void *v4; // eax
  bool v6; // [esp+1Dh] [ebp-Bh]
  bool v7; // [esp+1Fh] [ebp-9h]

  v6 = __fpending(fp) != 0;
  v2 = ferror_unlocked(fp) != 0;
  v7 = sub_805F2A2(a1, fp) != 0;
  if ( !v2 )
  {
    v4 = &loc_80601C3;
    if ( !v7 )
      v4 = &loc_80601F2;
    dword_806B298 = (int)v4;
    sub_806184C(v3);
    if ( !v6 && *__errno_location() == 9 )
      return 0;
  }
  if ( v7 != 1 )
    *__errno_location() = 0;
  return -1;
}
// 806184C: using guessed type int __fastcall sub_806184C(_DWORD);
// 806B298: using guessed type int dword_806B298;

//----- (080601F9) --------------------------------------------------------
_DWORD *__userpurge sub_80601F9@<eax>(_DWORD *a1, double a2)
{
  signed int v2; // ST20_4
  double v3; // ST28_8
  int v4; // ST24_4
  int v6; // [esp+20h] [ebp-18h]
  int v7; // [esp+24h] [ebp-14h]

  if ( a2 <= -2147483648.0 )
  {
    sub_8060D12(a1, 2147483648, 0);
  }
  else if ( 2147483648.0 <= a2 )
  {
    sub_8060D12(a1, 0x7FFFFFFF, 999999999);
  }
  else
  {
    v2 = (signed int)a2;
    v3 = (a2 - (long double)v2) * 1000000000.0;
    v4 = (v3 > (long double)(signed int)v3) + (signed int)v3;
    v6 = v4 / 1000000000 + v2;
    v7 = v4 % 1000000000;
    if ( v7 < 0 )
    {
      --v6;
      v7 += 1000000000;
    }
    sub_8060D12(a1, v6, v7);
  }
  return a1;
}

//----- (08060342) --------------------------------------------------------
int __usercall sub_8060342@<eax>(int a1@<edx>, int a2@<ecx>, int fd, int a4)
{
  void *v4; // eax
  int v5; // ST20_4
  int v6; // ST24_4

  if ( fd >= 0 )
  {
    v4 = &loc_806036D;
    if ( fd > 2 )
      v4 = &loc_80603A7;
    dword_806B388 = (int)v4;
    sub_8061252(a2, a1);
    v5 = sub_80603AC(fd, a4);
    v6 = *__errno_location();
    close(fd);
    *__errno_location() = v6;
    fd = v5;
  }
  return fd;
}
// 8061252: using guessed type int __fastcall sub_8061252(_DWORD, _DWORD);
// 806B388: using guessed type int dword_806B388;

//----- (080603AC) --------------------------------------------------------
int __cdecl sub_80603AC(int fd, int a2)
{
  int v2; // eax

  if ( a2 & 0x80000 )
    v2 = 1030;
  else
    v2 = 0;
  return sub_805F37E(fd, v2, 3);
}

//----- (080603E3) --------------------------------------------------------
FILE *__usercall sub_80603E3@<eax>(double a1@<st0>, int a2, char *modes)
{
  int v3; // ST30_4
  int v4; // ecx
  bool v5; // zf
  void *v6; // eax
  int v7; // ST34_4
  FILE *stream; // [esp+1Ch] [ebp-1Ch]
  signed int v10; // [esp+20h] [ebp-18h]
  int fd; // [esp+24h] [ebp-14h]

  stream = (FILE *)fopen64(a2, modes);
  if ( !stream )
    return stream;
  v10 = fileno(stream);
  if ( v10 < 0 || v10 > 2 )
    return stream;
  fd = sub_8060E02(v10);
  if ( fd < 0 )
  {
    v3 = *__errno_location();
    sub_805F2A2(a1, stream);
    *__errno_location() = v3;
    dword_806B324 = (int)&locret_80604E5;
    sub_80614D5(v4, v3);
  }
  v5 = sub_805F2A2(a1, stream) == 0;
  v6 = &loc_80604A1;
  if ( !v5 )
    v6 = &loc_80604BC;
  dword_806B25C = (int)v6;
  sub_80619C7(a1);
  stream = fdopen(fd, modes);
  if ( stream )
    return stream;
  v7 = *__errno_location();
  close(fd);
  *__errno_location() = v7;
  return 0;
}
// 80499F0: using guessed type int __cdecl fopen64(_DWORD, _DWORD);
// 80614D5: using guessed type int __fastcall sub_80614D5(_DWORD, _DWORD);
// 80619C7: using guessed type int __usercall sub_80619C7@<eax>(double@<st0>);
// 806B25C: using guessed type int dword_806B25C;
// 806B324: using guessed type int dword_806B324;

//----- (080604E7) --------------------------------------------------------
void *sub_80604E7()
{
  void *v0; // eax
  void *v1; // eax
  signed int v2; // eax
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  void *v7; // [esp+18h] [ebp-B0h]
  char *s; // [esp+1Ch] [ebp-ACh]
  size_t n; // [esp+2Ch] [ebp-9Ch]
  size_t v10; // [esp+30h] [ebp-98h]
  signed int v11; // [esp+34h] [ebp-94h]
  char *dest; // [esp+38h] [ebp-90h]

  v7 = (void *)dword_806C515;
  if ( !dword_806C515 )
  {
    s = getenv("CHARSETALIASDIR");
    if ( s )
    {
      v0 = &loc_8060569;
      if ( *s )
        v0 = &loc_806057D;
      dword_806B248 = (int)v0;
      sub_8061A50();
    }
    n = strlen("/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib");
    v10 = strlen("charset.alias");
    if ( n )
    {
      v1 = &loc_80605DF;
      if ( aHomeHwangdzCor_0[n - 1] == 47 )
        v1 = &loc_80605E6;
      dword_806B220 = (int)v1;
      sub_8061B42();
      v2 = 1;
    }
    else
    {
      v2 = 0;
    }
    v11 = v2;
    dest = (char *)malloc(n + v2 + v10 + 1);
    if ( dest )
    {
      memcpy(dest, "/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib", n);
      if ( v11 )
        dest[n] = 47;
      memcpy(&dest[n + v11], "charset.alias", v10 + 1);
    }
    free(0);
    v5 = &loc_80606C2;
    if ( dest )
      v5 = &loc_80606D1;
    dword_806B2D4 = (int)v5;
    sub_80616F8(v4, v3);
    v7 = &unk_806507F;
    dword_806C515 = (int)&unk_806507F;
  }
  return v7;
}
// 80616F8: using guessed type int __fastcall sub_80616F8(_DWORD, _DWORD);
// 8061A50: using guessed type int sub_8061A50(void);
// 8061B42: using guessed type int sub_8061B42(void);
// 806B220: using guessed type int dword_806B220;
// 806B248: using guessed type int dword_806B248;
// 806B2D4: using guessed type int dword_806B2D4;
// 806C515: using guessed type int dword_806C515;

//----- (08060A3C) --------------------------------------------------------
const char *__usercall sub_8060A3C@<eax>(double a1@<st0>)
{
  size_t v1; // edx
  int v2; // ecx
  char *v3; // ST24_4
  void *v4; // eax
  const char *s1; // [esp+18h] [ebp-10h]
  char *s2; // [esp+1Ch] [ebp-Ch]

  s1 = nl_langinfo(14);
  if ( !s1 )
    s1 = (const char *)&unk_806507F;
  s2 = (char *)sub_80604E7();
  dword_806B338 = (int)&loc_8060AE4;
  sub_8061467(a1);
  while ( strcmp(s1, s2) && (*s2 != 42 || s2[1]) )
  {
    v3 = &s2[strlen(s2) + 1];
    s2 = &v3[strlen(v3) + 1];
    if ( !*s2 )
      goto LABEL_9;
  }
  v1 = strlen(s2) + 1;
  s1 = &s2[v1];
LABEL_9:
  v4 = &loc_8060B11;
  if ( *s1 )
    v4 = &loc_8060B18;
  dword_806B234 = (int)v4;
  sub_8061AC8(v2, v1);
  return "ASCII";
}
// 8061467: using guessed type int __usercall sub_8061467@<eax>(double@<st0>);
// 8061AC8: using guessed type double __fastcall sub_8061AC8(_DWORD, _DWORD);
// 806B234: using guessed type int dword_806B234;
// 806B338: using guessed type int dword_806B338;

//----- (08060B1D) --------------------------------------------------------
int __cdecl sub_8060B1D(char *s, int a2, char *s2, int a4)
{
  int v6; // [esp+14h] [ebp-14h]
  size_t v7; // [esp+18h] [ebp-10h]
  size_t v8; // [esp+1Ch] [ebp-Ch]

  dword_806B374 = (int)&loc_8060B95;
  sub_80612DD();
  do
  {
    v7 = strlen(s) + 1;
    v8 = strlen(s2) + 1;
    s += v7;
    s2 += v8;
    a2 -= v7;
    a4 -= v8;
    if ( !a2 )
      return -(a4 != 0);
    if ( !a4 )
      return 1;
    *__errno_location() = 0;
    v6 = strcoll(s, s2);
  }
  while ( !v6 && !*__errno_location() );
  return v6;
}
// 80612DD: using guessed type int sub_80612DD(void);
// 806B374: using guessed type int dword_806B374;

//----- (08060BDF) --------------------------------------------------------
int __cdecl sub_8060BDF(void *s1, size_t n, void *s2, int a4)
{
  char v4; // ST1A_1
  char v5; // ST1B_1
  int v7; // [esp+1Ch] [ebp-Ch]

  if ( n == a4 && !memcmp(s1, s2, n) )
  {
    *__errno_location() = 0;
    v7 = 0;
  }
  else
  {
    v4 = *((_BYTE *)s1 + n);
    v5 = *((_BYTE *)s2 + a4);
    *((_BYTE *)s1 + n) = 0;
    *((_BYTE *)s2 + a4) = 0;
    v7 = sub_8060B1D((char *)s1, n + 1, (char *)s2, a4 + 1);
    *((_BYTE *)s1 + n) = v4;
    *((_BYTE *)s2 + a4) = v5;
  }
  return v7;
}

//----- (08060C9A) --------------------------------------------------------
int __usercall sub_8060C9A@<eax>(int a1@<edx>, int a2@<ecx>, void *s1, size_t n, void *s2, int a6)
{
  void *v6; // eax

  v6 = &loc_8060CC1;
  if ( n != a6 )
    v6 = &loc_8060CF0;
  dword_806B360 = (int)v6;
  sub_806137F(a2, a1);
  if ( memcmp(s1, s2, n) )
    return sub_8060B1D((char *)s1, n, (char *)s2, a6);
  *__errno_location() = 0;
  return 0;
}
// 806137F: using guessed type int __fastcall sub_806137F(_DWORD, _DWORD);
// 806B360: using guessed type int dword_806B360;

//----- (08060D12) --------------------------------------------------------
_DWORD *__userpurge sub_8060D12@<eax>(_DWORD *a1, int a2, int a3)
{
  *a1 = a2;
  a1[1] = a3;
  return a1;
}

//----- (08060E02) --------------------------------------------------------
int __cdecl sub_8060E02(int fd)
{
  return sub_805F37E(fd, 0, 3);
}

//----- (08060E27) --------------------------------------------------------
signed __int64 __cdecl sub_8060E27(unsigned __int64 a1, unsigned int a2, unsigned int a3)
{
  void *v3; // eax
  unsigned int v4; // ecx
  signed __int64 result; // rax
  int v6; // ebp
  void *v7; // eax
  unsigned int v8; // eax
  unsigned int v9; // edx

  if ( a3 )
  {
    if ( a3 > HIDWORD(a1) )
      goto LABEL_17;
    _BitScanReverse((unsigned int *)&v6, a3);
    v7 = &loc_8060EB8;
    if ( v6 ^ 0x1F )
      v7 = &loc_8060EED;
    dword_806B388 = (int)v7;
    v8 = sub_8061252(a2, HIDWORD(a1));
    if ( a2 <= (unsigned int)a1 || v8 < v9 )
      result = 1LL;
    else
LABEL_17:
      result = 0LL;
  }
  else if ( a2 > HIDWORD(a1) )
  {
    result = (unsigned int)(a1 / a2);
  }
  else
  {
    v3 = &loc_8060E71;
    if ( a2 )
      v3 = &loc_8060E7C;
    dword_806B234 = (int)v3;
    sub_8061AC8(a2, HIDWORD(a1));
    LODWORD(result) = __PAIR__(HIDWORD(a1) % (1 / v4), (unsigned int)a1) / (1 / v4);
    HIDWORD(result) = HIDWORD(a1) / (1 / v4);
  }
  return result;
}
// 8061252: using guessed type int __fastcall sub_8061252(_DWORD, _DWORD);
// 8061AC8: using guessed type double __fastcall sub_8061AC8(_DWORD, _DWORD);
// 806B234: using guessed type int dword_806B234;
// 806B388: using guessed type int dword_806B388;

//----- (08060F7D) --------------------------------------------------------
int __cdecl sub_8060F7D(unsigned __int64 a1, __int64 a2)
{
  int v2; // edx
  int result; // eax
  int v4; // ebp
  int v5; // ebp
  unsigned int v6; // ebp
  unsigned __int64 v7; // rtt
  unsigned __int64 v8; // rax
  unsigned int v9; // edi
  unsigned __int64 v10; // rax
  unsigned int v11; // ecx
  int v12; // ebp
  int v13; // ecx
  int v14; // esi
  void *v15; // eax
  int v16; // edi
  void *v17; // [esp-1Ch] [ebp-3Ch]
  const void *v18; // [esp-18h] [ebp-38h]
  size_t v19; // [esp-14h] [ebp-34h]
  unsigned int v20; // [esp+0h] [ebp-20h]
  unsigned int v21; // [esp+4h] [ebp-1Ch]
  unsigned __int64 v22; // [esp+8h] [ebp-18h]
  unsigned int v23; // [esp+10h] [ebp-10h]

  v21 = HIDWORD(a1);
  v23 = a1;
  v20 = a2;
  v22 = a1;
  if ( HIDWORD(a2) )
  {
    if ( HIDWORD(a2) > HIDWORD(a1) )
    {
      result = a1;
    }
    else
    {
      _BitScanReverse((unsigned int *)&v4, HIDWORD(a2));
      v5 = v4 ^ 0x1F;
      if ( v5 )
      {
        v21 = (HIDWORD(a2) << v5) | (v20 >> (32 - v5));
        LODWORD(v22) = v20 << v5;
        HIDWORD(v8) = HIDWORD(a1) >> (32 - v5);
        LODWORD(v8) = (HIDWORD(a1) << v5) | (v23 >> (32 - v5));
        HIDWORD(v22) = v23 << v5;
        v9 = v8 % v21;
        v10 = (v20 << v5) * (unsigned __int64)(unsigned int)(v8 / v21);
        v20 = HIDWORD(v10);
        v11 = v10;
        if ( v9 < HIDWORD(v10) || HIDWORD(v22) < (unsigned int)v10 && v9 == HIDWORD(v10) )
        {
          HIDWORD(v10) = v20;
          HIDWORD(v10) = (v10 - __PAIR__(v21, (unsigned int)v22)) >> 32;
          v11 = v10 - v22;
        }
        result = ((__PAIR__(v9, HIDWORD(v22)) - __PAIR__(HIDWORD(v10), v11)) >> 32 << (32 - (unsigned __int8)v5)) | ((HIDWORD(v22) - v11) >> v5);
      }
      else if ( v20 <= (unsigned int)v22 || HIDWORD(a2) < HIDWORD(v22) )
      {
        result = a1 - a2;
      }
      else
      {
        dword_806B270 = (int)&loc_8060FEE;
        sub_8061936(a1, HIDWORD(a2));
        v12 = HIDWORD(v22);
        memcpy(v17, v18, v19);
        v14 = ((char *)&stru_806AF00.d_un - (char *)&stru_806AF00) >> 2;
        v15 = &loc_8061131;
        if ( !v14 )
          v15 = &loc_8061152;
        dword_806B34C = (int)v15;
        sub_80613F7(v13);
        v16 = 0;
        do
          result = (*((int (__cdecl **)(unsigned int, _DWORD, int))&stru_806AF00.d_tag + v16++))(v21, v22, v12);
        while ( v14 != v16 );
      }
    }
  }
  else
  {
    if ( (unsigned int)a2 <= HIDWORD(a1) )
    {
      v6 = a2;
      if ( !(_DWORD)a2 )
        v6 = 1 / 0u;
      LODWORD(v7) = a1;
      HIDWORD(v7) = v21 % v6;
      v2 = v7 % v6;
    }
    else
    {
      v2 = a1 % (unsigned int)a2;
    }
    result = v2;
  }
  return result;
}
// 80613F7: using guessed type int __fastcall sub_80613F7(_DWORD);
// 8061936: using guessed type int __fastcall sub_8061936(_DWORD, _DWORD);
// 806AF00: using guessed type Elf32_Dyn stru_806AF00;
// 806B270: using guessed type int dword_806B270;
// 806B34C: using guessed type int dword_806B34C;

//----- (0806116B) --------------------------------------------------------
int __cdecl sub_806116B(int a1)
{
  return __cxa_atexit(a1, 0, dword_806B3A0);
}
// 8049AC0: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 806B3A0: using guessed type int dword_806B3A0;

//----- (0806119A) --------------------------------------------------------
int __cdecl sub_806119A(int a1, int a2)
{
  return __xstat64(3, a1, a2);
}
// 8049EB0: using guessed type int __cdecl __xstat64(_DWORD, _DWORD, _DWORD);

//----- (080611C9) --------------------------------------------------------
int __cdecl sub_80611C9(int a1, int a2)
{
  return __fxstat64(3, a1, a2);
}
// 8049A30: using guessed type int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD);

//----- (08061252) --------------------------------------------------------
#error "8061258: positive sp value has been found (funcsize=0)"

//----- (080612DD) --------------------------------------------------------
#error "80612E3: positive sp value has been found (funcsize=0)"

//----- (0806133E) --------------------------------------------------------
#error "8061377: positive sp value has been found (funcsize=18)"

//----- (0806137F) --------------------------------------------------------
#error "8061385: positive sp value has been found (funcsize=0)"

//----- (080613F7) --------------------------------------------------------
#error "80613FD: positive sp value has been found (funcsize=0)"

//----- (08061467) --------------------------------------------------------
#error "806146D: positive sp value has been found (funcsize=0)"

//----- (080614D5) --------------------------------------------------------
#error "80614DB: positive sp value has been found (funcsize=0)"

//----- (08061566) --------------------------------------------------------
#error "806156C: positive sp value has been found (funcsize=0)"

//----- (080615DC) --------------------------------------------------------
#error "80615E2: positive sp value has been found (funcsize=0)"

//----- (08061650) --------------------------------------------------------
#error "8061656: positive sp value has been found (funcsize=0)"

//----- (080616B7) --------------------------------------------------------
#error "80616F0: positive sp value has been found (funcsize=18)"

//----- (080616F8) --------------------------------------------------------
#error "80616FE: positive sp value has been found (funcsize=0)"

//----- (08061764) --------------------------------------------------------
#error "806176A: positive sp value has been found (funcsize=0)"

//----- (080617DA) --------------------------------------------------------
#error "80617E0: positive sp value has been found (funcsize=0)"

//----- (0806184C) --------------------------------------------------------
#error "8061852: positive sp value has been found (funcsize=0)"

//----- (080618C2) --------------------------------------------------------
#error "80618C8: positive sp value has been found (funcsize=0)"

//----- (08061936) --------------------------------------------------------
#error "806193C: positive sp value has been found (funcsize=0)"

//----- (080619C7) --------------------------------------------------------
#error "80619CD: positive sp value has been found (funcsize=0)"

//----- (08061A0F) --------------------------------------------------------
#error "8061A48: positive sp value has been found (funcsize=18)"

//----- (08061A50) --------------------------------------------------------
#error "8061A56: positive sp value has been found (funcsize=0)"

//----- (08061AC8) --------------------------------------------------------
#error "8061ACE: positive sp value has been found (funcsize=0)"

//----- (08061B42) --------------------------------------------------------
#error "8061B48: positive sp value has been found (funcsize=0)"

//----- (08061BBC) --------------------------------------------------------
#error "8061BC2: positive sp value has been found (funcsize=0)"

//----- (08061BD0) --------------------------------------------------------
int (**sub_8061BD0())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_806AEAC;
  v1 = &off_806AEB0 - off_806AEAC;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_806AEAC[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 806AEAC: using guessed type int (*off_806AEAC[2])();
// 806AEB0: using guessed type int (*off_806AEB0)();

//----- (08061C34) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 30 decompilation failure(s) on 377 function(s)"
