/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8049750();
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// int raise(int sig);
// int dup2(int fd, int fd2);
// int strcmp(const char *s1, const char *s2);
// int putc_unlocked(int c, FILE *stream);
// ssize_t read(int fd, void *buf, size_t nbytes);
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void _exit(int status);
// int __cdecl wcwidth(_DWORD); weak
// void *memmove(void *dest, const void *src, size_t n);
// void free(void *ptr);
// uintmax_t strtoumax(const char *nptr, char **endptr, int base);
// void *memcpy(void *dest, const void *src, size_t n);
// int mbsinit(const mbstate_t *ps);
// int ferror(FILE *stream);
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// int fclose(FILE *stream);
// int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
// int getc_unlocked(FILE *stream);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// __sighandler_t signal(int sig, __sighandler_t handler);
// int __cdecl __sched_cpucount(_DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// double __cdecl strtold(_DWORD, _DWORD); weak
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// int fputc_unlocked(int c, FILE *stream);
// int __cdecl getrlimit64(_DWORD, _DWORD); weak
// int __cdecl stpcpy(_DWORD, _DWORD); weak
// int execlp(const char *file, const char *arg, ...);
// int sysconf(int name);
// __uid_t getuid(void);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// int unlink(const char *name);
// int sigismember(const sigset_t *set, int signo);
// int fflush_unlocked(FILE *stream);
// int iswcntrl(wint_t wc);
// char *textdomain(const char *domainname);
// int iswprint(wint_t wc);
// int __cdecl fopen64(_DWORD, _DWORD); weak
// int ferror_unlocked(FILE *stream);
// int __cdecl mkostemp64(_DWORD, _DWORD); weak
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD); weak
// size_t __ctype_get_mb_cur_max(void);
// __pid_t waitpid(__pid_t pid, int *stat_loc, int options);
// int pthread_sigmask(int how, const __sigset_t *newmask, __sigset_t *oldmask);
// char *strcpy(char *dest, const char *src);
// size_t __fpending(FILE *fp);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// __pid_t getpid(void);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// int pthread_cond_signal(pthread_cond_t *cond);
// void error(int status, int errnum, const char *format, ...);
// size_t fread_unlocked(void *ptr, size_t size, size_t n, FILE *stream);
// int strcoll(const char *s1, const char *s2);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int sysinfo(struct sysinfo *info);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// char *strchr(const char *s, int c);
// int fscanf(FILE *stream, const char *format, ...);
// size_t strlen(const char *s);
// int fprintf(FILE *stream, const char *format, ...);
// ssize_t write(int fd, const void *buf, size_t n);
// int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *cond_attr);
// int __cdecl open64(_DWORD, _DWORD); weak
// int fcntl(int fd, int cmd, ...);
// int sigaddset(sigset_t *set, int signo);
// size_t strxfrm(char *dest, const char *src, size_t n);
// int setvbuf(FILE *stream, char *buf, int modes, size_t n);
// __gid_t getgid(void);
// void *memset(void *s, int c, size_t n);
// int ungetc(int c, FILE *stream);
// int *__errno_location(void);
// void *memchr(const void *s, int c, size_t n);
// int fileno(FILE *stream);
// int fgetc(FILE *stream);
// int pipe(int pipedes[2]);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// int __cdecl ftruncate64(_DWORD, _DWORD, _DWORD); weak
// __pid_t fork(void);
// int sigemptyset(sigset_t *set);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// int toupper(int c);
// void clearerr_unlocked(FILE *stream);
// char *strrchr(const char *s, int c);
// int pthread_join(pthread_t th, void **thread_return);
// struct lconv *localeconv(void);
// __pid_t getppid(void);
// int __cdecl explicit_bzero(_DWORD, _DWORD); weak
// int __cdecl pipe2(_DWORD, _DWORD); weak
// int __cdecl euidaccess(_DWORD, _DWORD); weak
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int nanosleep(const struct timespec *requested_time, struct timespec *remaining);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// char *bindtextdomain(const char *domainname, const char *dirname);
// int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl sched_getaffinity(_DWORD, _DWORD, _DWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// int feof_unlocked(FILE *stream);
// void abort(void);
// int __cdecl __xstat64(_DWORD, _DWORD, _DWORD); weak
// int strtol(const char *nptr, char **endptr, int base);
// char *ngettext(const char *msgid1, const char *msgid2, unsigned int n);
// int close(int fd);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// void *calloc(size_t nmemb, size_t size);
// int putchar_unlocked(int c);
// int _gmon_start__(void); weak
void sub_8049F73();
void sub_8049F90();
int sub_8049FA0();
int sub_804A010();
int sub_804A030();
void sub_804A08F();
void sub_804A0AA();
int sub_804A0BA();
int __cdecl sub_804A16A(int a1);
int __cdecl sub_804A17D(unsigned __int8 a1);
int __cdecl sub_804A18F(unsigned __int8 a1);
int __cdecl sub_804A1CE(unsigned __int64 a1);
int sub_804A214();
int sub_804A23F();
int __cdecl sub_804A26A(char *s1); // idb
void __cdecl __noreturn sub_804A3F0(int a1, const char *a2);
void __cdecl __noreturn sub_804A4B6(int a1, char *a2);
void __cdecl __noreturn sub_804A518(int status); // idb
int __cdecl sub_804A7D4(int a1);
int __cdecl sub_804A809(unsigned __int8 *a1);
int __cdecl sub_804A839(int a1, unsigned int a2);
bool __cdecl sub_804A857(int a1, int a2);
int __cdecl sub_804A87C(__pid_t pid); // idb
int __cdecl sub_804A988(int a1);
signed int __cdecl sub_804A9FC(int a1);
int __cdecl sub_804AA56(__pid_t pid); // idb
int sub_804AA78();
int sub_804AA9B();
int sub_804AAB4();
int sub_804AAD3();
int sub_804AB0B();
int *__cdecl sub_804AB45(int *a1, char a2);
FILE *__cdecl sub_804AD32(char *s1, char *modes);
FILE *__cdecl sub_804AE6E(char *s1, char *modes);
void __cdecl sub_804AEAF(FILE *stream, int a2);
int __cdecl sub_804AF41(int fd, int fd2); // idb
__pid_t __cdecl sub_804AF6E(int pipedes[2], int a2);
int *__cdecl sub_804B0EF(FILE **a1, char a2);
int *__cdecl sub_804B23B(FILE **a1);
FILE *__cdecl sub_804B256(int a1);
int __cdecl sub_804B419(int a1);
void __cdecl sub_804B471(char *name);
int compar(const void *, const void *); // idb
void sub_804B5D3();
unsigned int __cdecl sub_804B7C4(int a1, char a2, char *a3);
int __cdecl sub_804BA0E(int, int, char *nptr); // idb
int __cdecl sub_804BC53(int, int, char *nptr); // idb
int sub_804BCF8();
int __cdecl sub_804BEC7(int a1, unsigned int a2, int a3, unsigned int a4, int a5);
int __cdecl sub_804C07C(int, int, size_t size); // idb
int __cdecl sub_804C102(_DWORD *a1);
int __cdecl sub_804C11D(int a1, int *a2);
unsigned __int8 *__cdecl sub_804C266(int a1, int a2);
int __cdecl sub_804C3CC(int, FILE *stream, int); // idb
int __cdecl sub_804C788(char **a1);
int __cdecl sub_804C84D(_BYTE *a1);
int __cdecl sub_804C8B4(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_804C95A(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_804C9D1(int a1, int a2);
signed int __cdecl sub_804CA55(int a1, int a2);
int __cdecl sub_804CB56(unsigned __int8 *a1, unsigned __int8 **a2);
unsigned int __cdecl sub_804CC88(char *a1);
size_t __cdecl sub_804CD54(char *dest, char *src, size_t n);
int __cdecl sub_804CE2C(int, size_t, int, size_t); // idb
int __cdecl sub_804D3E9(char *a1, unsigned int a2);
int __cdecl sub_804D439(int a1, int a2);
int __cdecl sub_804D49A(_BYTE *a1);
int __cdecl sub_804D4CF(int *a1, int a2);
int __cdecl sub_804D6E4(int *a1);
int __cdecl sub_804D737(int a1);
_BYTE *__cdecl sub_804D7BA(int a1, _BYTE *a2);
unsigned int __cdecl sub_804D8D0(int *a1, char a2);
int __cdecl sub_804E058(unsigned __int8 **a1, unsigned __int8 **a2);
int __cdecl sub_804EC4A(int a1, int a2);
int __cdecl sub_804ED79(int, FILE *stream, int); // idb
int __cdecl sub_804EE82(char *a1, char a2);
unsigned int __cdecl sub_804F1F4(int a1, unsigned int a2, void **a3);
void __cdecl sub_804F2D8(int a1, int a2, int a3, FILE *stream, int a5, void *a6);
int __cdecl sub_804FBFF(int, int, int, FILE *stream, int); // idb
_DWORD *__cdecl sub_804FC90(_DWORD *a1, unsigned int a2, _DWORD *a3);
int __cdecl sub_804FD6E(_DWORD *a1, unsigned int a2, _DWORD *a3, unsigned __int8 a4);
pthread_mutex_t *__cdecl sub_804FF7B(unsigned int a1, int a2, int a3);
int __cdecl sub_8050095(_DWORD *a1, pthread_mutex_t *a2, int a3, unsigned int a4, int a5, char a6);
_BOOL4 __cdecl sub_805023D(_DWORD *a1, _DWORD *a2);
int __cdecl sub_805029C(pthread_mutex_t *a1);
int __cdecl sub_80502B2(pthread_mutex_t *a1);
int __cdecl sub_80502F9(int a1, int a2);
int __cdecl sub_8050347(int a1, int a2);
pthread_mutex_t *__cdecl sub_8050394(int a1);
int __cdecl sub_80503FD(int, FILE *stream, int); // idb
int __cdecl sub_8050470(int, int, FILE *stream, int); // idb
int __cdecl sub_805081D(int a1, int a2);
int __cdecl sub_80508CE(int a1, _DWORD *a2);
int __cdecl sub_805093B(int, int, FILE *stream, int); // idb
void *start_routine(void *); // idb
int __cdecl sub_8050A3B(int, int, int, int, int, FILE *stream, int); // idb
int __cdecl sub_8050C3F(int, int, int, char *s1); // idb
unsigned int __cdecl sub_8050E6D(int a1, unsigned int a2);
void __cdecl sub_8050F08(char *a1);
void __cdecl sub_8050F6E(int a1, int a2, int a3, char *s1);
unsigned int __cdecl sub_8051367(char **a1, unsigned int a2, char *a3, unsigned int a4);
_DWORD *__cdecl sub_805175C(void *src);
unsigned int __cdecl sub_80517A9(int a1, char *msgid);
unsigned int __cdecl sub_80517F7(int a1);
unsigned int sub_8051828();
int __cdecl sub_8051906(char *nptr, int, char *msgid); // idb
int __cdecl sub_80519DE(int sig); // idb
_BYTE *__cdecl sub_8051A09(_BYTE *a1, int a2, int a3);
void *__cdecl sub_8051AE4(void *s);
_BOOL4 __cdecl main(int argc, char **argv);
void __noreturn sub_805307F();
int __cdecl sub_8053093(char *s, int, int, size_t); // idb
void __cdecl sub_8053187(int a1, int a2, int a3);
int __cdecl sub_805320A(int, int, size_t n); // idb
int __cdecl sub_8053321(int, char *s, int, int, size_t n, int); // idb
int sub_8053421();
_DWORD *__cdecl sub_8053505(_DWORD *a1);
_DWORD *__cdecl sub_8053551(_DWORD *a1, int a2);
_DWORD *__cdecl sub_805355E(int *a1, _DWORD *a2);
_DWORD *__cdecl sub_80535CB(int *a1, _DWORD *a2);
int *__cdecl sub_8053861(void *src, size_t a2, int a3);
int *__cdecl sub_8053A4E(int *a1, unsigned int a2, int *a3);
int __cdecl sub_8054718(int a1, int a2, int a3, int a4, int a5, int a6);
void __cdecl sub_8054769(FILE *stream, int a2);
_BYTE *__cdecl sub_80547B1(_BYTE **a1);
int __cdecl sub_805486F(unsigned __int8 a1);
int __cdecl sub_80548C0(int a1, unsigned int a2, int a3, unsigned int a4);
int __cdecl sub_8054AA0(char *s1, char *s2); // idb
int __cdecl sub_8054CAD(int category); // idb
int __cdecl sub_8054D0B(int a1);
int __cdecl sub_8054D16(int a1);
int __cdecl sub_8054D21(int a1);
unsigned int __cdecl sub_8054D2C(int a1);
int __cdecl sub_8054EE5(int a1, int a2);
bool __cdecl sub_805517E(unsigned int a1);
int __cdecl sub_80551D5(unsigned int a1);
unsigned int __cdecl sub_8055246(int a1, unsigned int a2);
bool __cdecl sub_8055271(int a1, int a2);
signed int __cdecl sub_805527F(int a1);
unsigned int __cdecl sub_805533B(unsigned int a1, int a2);
size_t *__cdecl sub_80553C8(unsigned int a1, void *a2, unsigned int (__cdecl *a3)(int a1, unsigned int a2), bool (__cdecl *a4)(int a1, int a2), size_t a5);
void *__cdecl sub_80556A0(int a1);
int __cdecl sub_80556DB(int a1, _DWORD *a2);
int __cdecl sub_80556FE(int a1, int a2, _DWORD *a3, char a4);
signed int __cdecl sub_805583F(int a1, int a2, char a3);
signed int __cdecl sub_80559A9(int a1, unsigned int a2);
signed int __cdecl sub_8055B5E(unsigned int *a1, int a2, _DWORD *a3);
int __cdecl sub_8055D9B(unsigned int *a1, int a2);
int __cdecl sub_8055DDA(int a1, int a2);
_DWORD *__cdecl sub_8055FA6(int (*a1)(), unsigned int a2);
int sub_805601B();
void __cdecl sub_8056025(void *ptr);
int __cdecl sub_8056045(int a1, int a2);
int __cdecl sub_80560CE(int *a1);
unsigned int __cdecl sub_805614A(int a1, unsigned int a2, unsigned int a3, int (__cdecl *a4)(_DWORD, int));
int __cdecl sub_805622D(int a1, unsigned int a2, int (__cdecl *a3)(_DWORD, int));
int __cdecl sub_80562BD(int a1, int a2);
int __cdecl sub_8056397(unsigned int a1, int a2);
int __cdecl sub_80563F5(signed __int64 a1, int a2);
int __cdecl sub_80564A8(char *a1, int a2, char a3);
int sub_8056701();
signed int __cdecl sub_8056760(int a1);
int __cdecl sub_80567D6(char *nptr); // idb
unsigned int __cdecl sub_80568A3(int a1);
long double sub_8056924();
long double sub_80569D1();
int __cdecl sub_8056A98(int pipedes[2], int); // idb
int sub_8056CF3();
char *__cdecl sub_8056D51(char *s);
int __cdecl sub_8056E9D(int *a1, unsigned __int8 a2, char a3);
int *__cdecl sub_8056F47(int *a1, int a2, int a3);
// _DWORD *__userpurge sub_8056F88@<eax>(_DWORD *a1, int a2);
const char *__cdecl sub_805700A(char *msgid, int a2);
unsigned int __cdecl sub_80570A5(int a1, unsigned int a2, int a3, size_t a4, signed int a5, int a6, int a7, char *a8, char *a9);
void *__cdecl sub_8057D3C(int a1, size_t a2, _DWORD *a3, int *a4);
void *__cdecl sub_8057EE3(signed int a1, int a2, size_t a3, int a4);
void *__cdecl sub_805810C(signed int a1, int a2);
void *__cdecl sub_8058136(signed int a1, int a2, size_t a3);
void *__cdecl sub_805819C(signed int a1, int a2, int a3);
void *__cdecl sub_80581DA(signed int a1, int a2, int a3, size_t a4);
void *__cdecl sub_8058217(int a1, int a2);
void *__cdecl sub_8058262(int a1, size_t a2, unsigned __int8 a3);
void *__cdecl sub_805830C(int a1, unsigned __int8 a2);
void *__cdecl sub_8058335(int a1);
void *__cdecl sub_8058372(signed int a1, int a2, int a3);
void *__cdecl sub_8058413(signed int a1, int a2, int a3, int a4);
void *__cdecl sub_8058443(signed int a1, int a2, int a3, int a4, size_t a5);
void *__cdecl sub_805853D(signed int a1, int a2, size_t a3);
void *__cdecl sub_8058588(signed int a1, int a2);
void *__cdecl sub_80585AA(int a1);
void __cdecl __noreturn sub_80585C5(int a1);
_DWORD *__cdecl sub_805862E(int a1, int a2);
unsigned int __cdecl sub_8058663(int a1, int a2, size_t nbytes);
char *__cdecl sub_8058870(int a1, size_t n);
size_t __cdecl sub_805896C(int a1, void *ptr, size_t n);
int __cdecl sub_80589F4(int, void *dest, size_t n); // idb
size_t __cdecl sub_8058B03(int a1, void *ptr, size_t n);
int __cdecl sub_8058B4B(void *ptr); // idb
int __cdecl sub_8058B91(int a1);
int __cdecl sub_8058BA8(int a1, __int16 a2);
unsigned int *__cdecl sub_8058BD9(unsigned int *a1, int *a2);
_DWORD *__cdecl sub_805907E(_DWORD *a1);
signed int __cdecl sub_805948D(_DWORD *a1);
_DWORD *__cdecl sub_8059631(_DWORD *a1);
bool __cdecl sub_80597C6(FILE *stream, int a2);
int __cdecl sub_8059A7F(int a1, int a2);
int __cdecl sub_8059AA8(_BYTE *a1, _BYTE *a2, char a3);
int __cdecl sub_8059BEA(unsigned __int8 *a1, unsigned __int8 *a2, int a3, int a4);
int __cdecl sub_805A013(unsigned __int8 *a1, unsigned __int8 *a2, int a3, int a4);
int __cdecl sub_805A03B(int fd); // idb
int __cdecl sub_805A085(FILE *stream, int, int, int, int, int); // idb
int __cdecl sub_805A5EA(FILE *stream, int, int, int, int); // idb
int sub_805A650(FILE *stream, int a2, int a3, int a4, ...);
void *__cdecl sub_805A6F0(unsigned int a1, unsigned int a2);
void *__cdecl sub_805A753(void *ptr, int a2, int a3);
void *__cdecl sub_805A7EA(size_t size);
void *__cdecl sub_805A7FD(size_t size);
void *__cdecl sub_805A827(void *ptr, size_t size);
void *__cdecl sub_805A8C2(size_t nmemb, size_t size);
void *__cdecl sub_805A8FF(void *src, size_t n);
void __noreturn sub_805A94D();
void __cdecl sub_805A986(int errnum, int a2, int a3, int a4, int a5);
int __cdecl sub_805AAB7(void *s1, size_t n, void *s2, int); // idb
signed int __cdecl sub_805AB22(double a1);
signed int __cdecl sub_805AB94(unsigned int *a1, unsigned int a2);
int __cdecl sub_805ABD8(unsigned int *a1, unsigned int a2, int a3);
int __cdecl sub_805AC0E(char *nptr, int, int base, int, char *s); // idb
void __cdecl sub_805AFE2(int a1, int a2, int a3, int a4, int a5, int status);
void __cdecl __noreturn sub_805B098(int a1, int a2, char a3, int a4, int a5);
signed int __cdecl sub_805B0DB(int a1, signed int a2);
int __cdecl sub_805B167(int a1, signed int a2, int a3);
int __cdecl sub_805B19D(char *nptr, int, int base, int, char *s); // idb
int __cdecl sub_805B593(FILE *stream); // idb
int __cdecl sub_805B656(int fd, int cmd, char); // idb
int __cdecl sub_805B7C0(FILE *stream); // idb
int __cdecl sub_805B7F9(FILE *fp); // idb
int __cdecl sub_805B839(FILE *stream, int, int, int); // idb
size_t __cdecl sub_805B90B(wchar_t *pwc, char *s, size_t n, mbstate_t *p);
int __cdecl sub_805B97D(int a1, int a2);
int __cdecl sub_805B9BB(int a1, int a2);
signed int __cdecl sub_805B9F9(int a1, signed int a2, signed int a3);
signed int __cdecl sub_805BAD8(int a1, signed int a2, signed int a3, int a4, int a5);
int __cdecl sub_805BB61(int a1, int a2);
int __cdecl sub_805BD2B(int a1, unsigned int a2);
int __cdecl sub_805BF41(int a1, char a2);
signed int __cdecl sub_805C02C(signed int a1);
_BOOL4 __cdecl sub_805C05C(signed int a1);
_BOOL4 __cdecl sub_805C0E0(int a1);
_BOOL4 __cdecl sub_805C18A(signed int a1);
int __cdecl sub_805C1EE(int a1);
int __cdecl sub_805C224(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_805C289(FILE *fp); // idb
// _DWORD *__userpurge sub_805C30A@<eax>(_DWORD *a1, double a2);
int __cdecl sub_805C453(int fd, int); // idb
int __cdecl sub_805C4A4(int fd, int); // idb
FILE *__cdecl sub_805C4DB(int a1, char *modes);
void *sub_805C5B1();
const char *sub_805CA29();
int __cdecl sub_805CADC(char *s, int, char *s2, int); // idb
int __cdecl sub_805CB89(void *s1, size_t n, void *s2, int); // idb
int __cdecl sub_805CC44(void *s1, size_t n, void *s2, int); // idb
// _DWORD *__userpurge sub_805CCA3@<eax>(_DWORD *a1, int a2, int a3);
int __cdecl sub_805CD4C(int fd); // idb
signed __int64 __cdecl sub_805CD71(unsigned __int64 a1, unsigned int a2, unsigned int a3);
int __cdecl sub_805CE91(unsigned __int64 a1, __int64 a2);
int __cdecl sub_805D054(int a1);
int __cdecl sub_805D083(int a1, int a2);
int __cdecl sub_805D0B2(int a1, int a2);
int (**sub_805D0E0())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

char s = '\0'; // idb
struct option longopts = { "ignore-leading-blanks", 0, NULL, 98 }; // idb
char *off_805E64C[3] = { "quiet", "silent", "diagnose-first" }; // weak
char aCccgeneralNume[19] = "CCcgeneral-numeric"; // weak
void *off_805E694 = (void *)0x805E65F; // weak
char byte_805E6B0[6] = { 'g', 'h', 'M', 'n', 'R', 'V' }; // idb
char byte_805E920[256] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x06',
  '\0',
  '\x03',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0',
  '\x04',
  '\0',
  '\0',
  '\0',
  '\0',
  '\b',
  '\a',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
int sig[11] = { 14, 1, 2, 13, 3, 15, 29, 27, 26, 24, 25 }; // idb
_UNKNOWN unk_805F5A0; // weak
_UNKNOWN unk_805F5F0; // weak
_UNKNOWN unk_805F7EE; // weak
_UNKNOWN unk_805F7F2; // weak
_UNKNOWN unk_805F7FE; // weak
_UNKNOWN unk_805F802; // weak
_UNKNOWN unk_805F805; // weak
_UNKNOWN unk_80604EF; // weak
int (*off_8064EFC[2])() = { &sub_804A030, &sub_804A010 }; // weak
int (*off_8064F00)() = &sub_804A010; // weak
int (*dword_8065008)(void) = NULL; // weak
int dword_8065210 = 0; // weak
char byte_806522C = '\n'; // weak
char *off_806524C = "APR"; // weak
int dword_8065250[] = { 4 }; // weak
size_t dword_80652AC = 262144u; // idb
int dword_80652B0 = 128; // weak
int dword_80652B4 = 16; // idb
int *off_80652B8 = &dword_80658CD; // weak
char byte_80652BC = 'X'; // weak
char byte_80652C6 = '\0'; // weak
int off_80652CC = 134608152; // idb
int off_80652D0 = 134557823; // idb
int status = 1; // idb
int dword_80652EC = 1; // weak
int dword_80652F0 = 256; // weak
void *off_80652F4 = &unk_80659ED; // weak
int *off_80652F8 = &dword_80652F0; // weak
_UNKNOWN unk_806530C; // weak
_UNKNOWN unk_8065334; // weak
_UNKNOWN unk_8065337; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int program_invocation_name; // weak
int optind; // weak
FILE *stdin; // idb
FILE *stdout; // idb
int (*obstack_alloc_failed_handler)(void); // weak
char *optarg; // idb
char byte_80653AC; // weak
int dword_806540D; // weak
int dword_8065411; // weak
char byte_8065415; // weak
char byte_8065416; // weak
int dword_8065419; // weak
int dword_806541D; // weak
int dword_8065421; // weak
int dword_8065425; // weak
char byte_806542D[256]; // idb
_UNKNOWN unk_806552D; // weak
_UNKNOWN unk_806562D; // weak
char byte_806572D[256]; // idb
size_t size; // idb
void *ptr; // idb
int dword_8065835; // weak
int dword_8065839; // weak
char byte_806583D; // weak
char byte_806583E; // weak
char byte_806583F; // weak
char byte_8065840; // weak
int dword_8065841; // weak
char *s1; // idb
char byte_8065849; // weak
__sigset_t set; // idb
int dword_80658CD; // weak
int dword_80658D1; // weak
int dword_80658D5; // weak
_UNKNOWN unk_80658ED; // weak
int dword_8065989; // weak
int dword_806598D; // weak
int dword_8065991; // weak
char byte_8065995; // weak
int dword_8065999; // weak
int dword_806599D; // weak
int dword_80659AD; // weak
int dword_80659B1; // weak
int dword_80659B5; // weak
int dword_80659B9; // weak
int dword_80659BD; // weak
int dword_80659C1; // weak
int dword_80659C5; // weak
int dword_80659C9; // weak
int dword_80659CD; // weak
int dword_80659D1; // weak
int dword_80659D5; // weak
int dword_80659D9; // weak
_UNKNOWN unk_80659ED; // weak
int dword_8065AED; // weak
int dword_8065AF1; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (0804972C) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 8049F30: using guessed type int _gmon_start__(void);

//----- (08049750) --------------------------------------------------------
int sub_8049750()
{
  return dword_8065008();
}
// 8065008: using guessed type int (*dword_8065008)(void);

//----- (08049F40) --------------------------------------------------------
#error "8049F43: positive sp value has been found (funcsize=2)"

//----- (08049F73) --------------------------------------------------------
void sub_8049F73()
{
  ;
}

//----- (08049F90) --------------------------------------------------------
void sub_8049F90()
{
  ;
}

//----- (08049FA0) --------------------------------------------------------
int sub_8049FA0()
{
  int result; // eax

  result = 134632259 - (_DWORD)&program_invocation_short_name;
  if ( (unsigned int)(134632259 - (_DWORD)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 8049FA0: could not find valid save-restore pair for ebp
// 8065340: using guessed type int program_invocation_short_name;

//----- (0804A010) --------------------------------------------------------
int sub_804A010()
{
  int result; // eax

  if ( !byte_80653AC )
  {
    result = sub_8049FA0();
    byte_80653AC = 1;
  }
  return result;
}
// 804A010: could not find valid save-restore pair for ebp
// 80653AC: using guessed type char byte_80653AC;

//----- (0804A030) --------------------------------------------------------
int sub_804A030()
{
  return 0;
}
// 804A030: could not find valid save-restore pair for ebp

//----- (0804A08F) --------------------------------------------------------
void sub_804A08F()
{
  ;
}

//----- (0804A0AA) --------------------------------------------------------
void sub_804A0AA()
{
  ;
}

//----- (0804A0BA) --------------------------------------------------------
int sub_804A0BA()
{
  int result; // eax

  result = &unk_8065337 - &unk_8065334;
  if ( (unsigned int)(&unk_8065337 - &unk_8065334) > 6 )
    result = 0;
  return result;
}
// 804A0BA: could not find valid save-restore pair for ebp

//----- (0804A16A) --------------------------------------------------------
int __cdecl sub_804A16A(int a1)
{
  int result; // eax

  if ( a1 != 1 )
  {
    result = a1;
    status = a1;
  }
  return result;
}

//----- (0804A17D) --------------------------------------------------------
int __cdecl sub_804A17D(unsigned __int8 a1)
{
  return a1;
}

//----- (0804A18F) --------------------------------------------------------
int __cdecl sub_804A18F(unsigned __int8 a1)
{
  return (*__ctype_b_loc())[a1] & 1 || a1 == 10;
}

//----- (0804A1CE) --------------------------------------------------------
int __cdecl sub_804A1CE(unsigned __int64 a1)
{
  int result; // eax

  if ( HIDWORD(a1) )
    result = sub_805CE91(a1, 1000000LL) + 1000000;
  else
    result = a1;
  return result;
}

//----- (0804A214) --------------------------------------------------------
int sub_804A214()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nWith no FILE, or when FILE is -, read standard input.\n");
  return fputs_unlocked(v1, v0);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804A23F) --------------------------------------------------------
int sub_804A23F()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nMandatory arguments to long options are mandatory for short options too.\n");
  return fputs_unlocked(v1, v0);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804A26A) --------------------------------------------------------
int __cdecl sub_804A26A(char *s1)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // ebx
  char *v5; // eax
  char *v7; // [esp+1Ch] [ebp-4Ch]
  const char **i; // [esp+20h] [ebp-48h]
  const char *v9; // [esp+24h] [ebp-44h]
  const char *v10; // [esp+28h] [ebp-40h]
  const char *v11; // [esp+2Ch] [ebp-3Ch]
  const char *v12; // [esp+30h] [ebp-38h]
  const char *v13; // [esp+34h] [ebp-34h]
  const char *v14; // [esp+38h] [ebp-30h]
  const char *v15; // [esp+3Ch] [ebp-2Ch]
  const char *v16; // [esp+40h] [ebp-28h]
  const char *v17; // [esp+44h] [ebp-24h]
  const char *v18; // [esp+48h] [ebp-20h]
  const char *v19; // [esp+4Ch] [ebp-1Ch]
  const char *v20; // [esp+50h] [ebp-18h]
  const char *v21; // [esp+54h] [ebp-14h]
  int v22; // [esp+58h] [ebp-10h]
  int v23; // [esp+5Ch] [ebp-Ch]

  v10 = "[";
  v11 = "test invocation";
  v12 = "coreutils";
  v13 = "Multi-call invocation";
  v14 = "sha224sum";
  v15 = "sha2 utilities";
  v16 = "sha256sum";
  v17 = "sha2 utilities";
  v18 = "sha384sum";
  v19 = "sha2 utilities";
  v20 = "sha512sum";
  v21 = "sha2 utilities";
  v22 = 0;
  v23 = 0;
  v7 = s1;
  for ( i = &v10; *i && strcmp(s1, *i); i += 2 )
    ;
  if ( i[1] )
    v7 = (char *)i[1];
  v1 = gettext("\n%s online help: <%s>\n");
  printf(v1, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  v9 = setlocale(5, 0);
  if ( v9 && strncmp(v9, "en_", 3u) )
  {
    v2 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
    printf(v2, s1);
  }
  v3 = gettext("Full documentation at: <%s%s>\n");
  printf(v3, "http://www.gnu.org/software/coreutils/", s1);
  if ( v7 == s1 )
    v4 = " invocation";
  else
    v4 = &s;
  v5 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  return printf(v5, v7, v4);
}

//----- (0804A3F0) --------------------------------------------------------
void __cdecl __noreturn sub_804A3F0(int a1, const char *a2)
{
  size_t v2; // eax
  char *v3; // ST20_4
  size_t v4; // eax
  char v5; // [esp+30h] [ebp-18h]
  unsigned int v6; // [esp+3Ch] [ebp-Ch]

  v6 = __readgsdword(0x14u);
  v2 = strlen(a2);
  write(2, a2, v2);
  if ( a1 )
  {
    v3 = (char *)sub_80562BD(a1, (int)&v5);
    write(2, ": errno ", 8u);
    v4 = strlen(v3);
    write(2, v3, v4);
  }
  write(2, "\n", 1u);
  _exit(2);
}

//----- (0804A4B6) --------------------------------------------------------
void __cdecl __noreturn sub_804A4B6(int a1, char *a2)
{
  char *v2; // eax
  void *v3; // ebx
  int *v4; // eax

  if ( a2 )
    v2 = a2;
  else
    v2 = gettext("standard output");
  v3 = sub_8058372(0, 3, (int)v2);
  v4 = __errno_location();
  error(2, *v4, "%s: %s", a1, v3);
  sub_804A518(a1);
}

//----- (0804A518) --------------------------------------------------------
void __cdecl __noreturn sub_804A518(int status)
{
  int v1; // ebx
  char *v2; // eax
  int v3; // esi
  int v4; // ebx
  char *v5; // eax
  FILE *v6; // ebx
  char *v7; // eax
  FILE *v8; // ebx
  char *v9; // eax
  FILE *v10; // ebx
  char *v11; // eax
  FILE *v12; // ebx
  char *v13; // eax
  FILE *v14; // ebx
  char *v15; // eax
  FILE *v16; // ebx
  char *v17; // eax
  FILE *v18; // ebx
  char *v19; // eax
  FILE *v20; // ebx
  char *v21; // eax
  FILE *v22; // ebx
  char *v23; // eax
  FILE *v24; // ebx
  char *v25; // eax
  FILE *v26; // ebx
  char *v27; // eax
  FILE *v28; // ebx
  char *v29; // eax
  FILE *v30; // ebx
  char *v31; // eax
  char *v32; // eax
  FILE *v33; // ebx
  char *v34; // eax
  FILE *v35; // ebx
  char *v36; // eax
  FILE *v37; // ebx
  char *v38; // eax
  FILE *v39; // ebx
  char *v40; // eax
  FILE *v41; // ebx
  char *v42; // eax

  if ( status )
  {
    v1 = dword_806599D;
    v2 = gettext("Try '%s --help' for more information.\n");
    fprintf(stderr, v2, v1);
  }
  else
  {
    v3 = dword_806599D;
    v4 = dword_806599D;
    v5 = gettext("Usage: %s [OPTION]... [FILE]...\n  or:  %s [OPTION]... --files0-from=F\n");
    printf(v5, v4, v3);
    v6 = stdout;
    v7 = gettext("Write sorted concatenation of all FILE(s) to standard output.\n");
    fputs_unlocked(v7, v6);
    sub_804A214();
    sub_804A23F();
    v8 = stdout;
    v9 = gettext("Ordering options:\n\n");
    fputs_unlocked(v9, v8);
    v10 = stdout;
    v11 = gettext(
            "  -b, --ignore-leading-blanks  ignore leading blanks\n"
            "  -d, --dictionary-order      consider only blanks and alphanumeric characters\n"
            "  -f, --ignore-case           fold lower case to upper case characters\n");
    fputs_unlocked(v11, v10);
    v12 = stdout;
    v13 = gettext(
            "  -g, --general-numeric-sort  compare according to general numerical value\n"
            "  -i, --ignore-nonprinting    consider only printable characters\n"
            "  -M, --month-sort            compare (unknown) < 'JAN' < ... < 'DEC'\n");
    fputs_unlocked(v13, v12);
    v14 = stdout;
    v15 = gettext("  -h, --human-numeric-sort    compare human readable numbers (e.g., 2K 1G)\n");
    fputs_unlocked(v15, v14);
    v16 = stdout;
    v17 = gettext(
            "  -n, --numeric-sort          compare according to string numerical value\n"
            "  -R, --random-sort           shuffle, but group identical keys.  See shuf(1)\n"
            "      --random-source=FILE    get random bytes from FILE\n"
            "  -r, --reverse               reverse the result of comparisons\n");
    fputs_unlocked(v17, v16);
    v18 = stdout;
    v19 = gettext(
            "      --sort=WORD             sort according to WORD:\n"
            "                                general-numeric -g, human-numeric -h, month -M,\n"
            "                                numeric -n, random -R, version -V\n"
            "  -V, --version-sort          natural sort of (version) numbers within text\n"
            "\n");
    fputs_unlocked(v19, v18);
    v20 = stdout;
    v21 = gettext("Other options:\n\n");
    fputs_unlocked(v21, v20);
    v22 = stdout;
    v23 = gettext(
            "      --batch-size=NMERGE   merge at most NMERGE inputs at once;\n"
            "                            for more use temp files\n");
    fputs_unlocked(v23, v22);
    v24 = stdout;
    v25 = gettext(
            "  -c, --check, --check=diagnose-first  check for sorted input; do not sort\n"
            "  -C, --check=quiet, --check=silent  like -c, but do not report first bad line\n"
            "      --compress-program=PROG  compress temporaries with PROG;\n"
            "                              decompress them with PROG -d\n");
    fputs_unlocked(v25, v24);
    v26 = stdout;
    v27 = gettext(
            "      --debug               annotate the part of the line used to sort,\n"
            "                              and warn about questionable usage to stderr\n"
            "      --files0-from=F       read input from the files specified by\n"
            "                            NUL-terminated names in file F;\n"
            "                            If F is - then read names from standard input\n");
    fputs_unlocked(v27, v26);
    v28 = stdout;
    v29 = gettext(
            "  -k, --key=KEYDEF          sort via a key; KEYDEF gives location and type\n"
            "  -m, --merge               merge already sorted files; do not sort\n");
    fputs_unlocked(v29, v28);
    v30 = stdout;
    v31 = gettext(
            "  -o, --output=FILE         write result to FILE instead of standard output\n"
            "  -s, --stable              stabilize sort by disabling last-resort comparison\n"
            "  -S, --buffer-size=SIZE    use SIZE for main memory buffer\n");
    fputs_unlocked(v31, v30);
    v32 = gettext(
            "  -t, --field-separator=SEP  use SEP instead of non-blank to blank transition\n"
            "  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or %s;\n"
            "                              multiple options specify multiple directories\n"
            "      --parallel=N          change the number of sorts run concurrently to N\n"
            "  -u, --unique              with -c, check for strict ordering;\n"
            "                              without -c, output only the first of an equal run\n");
    printf(v32, "/tmp");
    v33 = stdout;
    v34 = gettext("  -z, --zero-terminated     line delimiter is NUL, not newline\n");
    fputs_unlocked(v34, v33);
    v35 = stdout;
    v36 = gettext("      --help     display this help and exit\n");
    fputs_unlocked(v36, v35);
    v37 = stdout;
    v38 = gettext("      --version  output version information and exit\n");
    fputs_unlocked(v38, v37);
    v39 = stdout;
    v40 = gettext(
            "\n"
            "KEYDEF is F[.C][OPTS][,F[.C][OPTS]] for start and stop position, where F is a\n"
            "field number and C a character position in the field; both are origin 1, and\n"
            "the stop position defaults to the line's end.  If neither -t nor -b is in\n"
            "effect, characters in a field are counted from the beginning of the preceding\n"
            "whitespace.  OPTS is one or more single-letter ordering options [bdfgiMhnRrV],\n"
            "which override global ordering options for that key.  If no key is given, use\n"
            "the entire line as the key.  Use --debug to diagnose incorrect key usage.\n"
            "\n"
            "SIZE may be followed by the following multiplicative suffixes:\n");
    fputs_unlocked(v40, v39);
    v41 = stdout;
    v42 = gettext(
            "% 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, E, Z, Y.\n"
            "\n"
            "*** WARNING ***\n"
            "The locale specified by the environment affects sort order.\n"
            "Set LC_ALL=C to get the traditional sort order that uses\n"
            "native byte values.\n");
    fputs_unlocked(v42, v41);
    sub_804A26A("sort");
  }
  exit(status);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 806599D: using guessed type int dword_806599D;

//----- (0804A7D4) --------------------------------------------------------
int __cdecl sub_804A7D4(int a1)
{
  bool v1; // dl
  int result; // eax

  v1 = pthread_sigmask(0, &set, (__sigset_t *)(a1 + 4)) == 0;
  result = a1;
  *(_BYTE *)a1 = v1;
  return result;
}

//----- (0804A809) --------------------------------------------------------
int __cdecl sub_804A809(unsigned __int8 *a1)
{
  int result; // eax

  result = *a1;
  if ( (_BYTE)result )
    result = pthread_sigmask(2, (const __sigset_t *)(a1 + 4), 0);
  return result;
}

//----- (0804A839) --------------------------------------------------------
int __cdecl sub_804A839(int a1, unsigned int a2)
{
  return *(_DWORD *)(a1 + 4) % a2;
}

//----- (0804A857) --------------------------------------------------------
bool __cdecl sub_804A857(int a1, int a2)
{
  return *(_DWORD *)(a1 + 4) == *(_DWORD *)(a2 + 4);
}

//----- (0804A87C) --------------------------------------------------------
int __cdecl sub_804A87C(__pid_t pid)
{
  __pid_t v1; // eax
  void *v2; // esi
  char *v3; // ebx
  int *v4; // eax
  void *v5; // ebx
  char *v6; // eax
  int stat_loc; // [esp+18h] [ebp-10h]
  int v9; // [esp+1Ch] [ebp-Ch]

  if ( pid )
    v1 = pid;
  else
    v1 = -1;
  v9 = waitpid(v1, &stat_loc, pid == 0);
  if ( v9 < 0 )
  {
    v2 = sub_8058217(4, (int)s1);
    v3 = gettext("waiting for %s [-d]");
    v4 = __errno_location();
    error(2, *v4, v3, v2);
  }
  if ( v9 > 0 && (pid > 0 || (unsigned __int8)sub_804A9FC(v9)) )
  {
    if ( stat_loc & 0x7F || (stat_loc & 0xFF00) >> 8 )
    {
      v5 = sub_8058217(4, (int)s1);
      v6 = gettext("%s [-d] terminated abnormally");
      error(2, 0, v6, v5);
    }
    --dword_80658D5;
  }
  return v9;
}
// 80658D5: using guessed type int dword_80658D5;

//----- (0804A988) --------------------------------------------------------
int __cdecl sub_804A988(int a1)
{
  int result; // eax

  if ( !dword_80658D1 )
  {
    dword_80658D1 = (int)sub_80553C8(0x2Fu, 0, (unsigned int (__cdecl *)(int, unsigned int))sub_804A839, sub_804A857, 0);
    if ( !dword_80658D1 )
      sub_805A94D();
  }
  *(_BYTE *)(a1 + 8) = 1;
  result = sub_8055D9B((unsigned int *)dword_80658D1, a1);
  if ( !result )
    sub_805A94D();
  return result;
}
// 80658D1: using guessed type int dword_80658D1;

//----- (0804A9FC) --------------------------------------------------------
signed int __cdecl sub_804A9FC(int a1)
{
  int v2; // [esp+1Ch] [ebp-1Ch]
  char v3; // [esp+20h] [ebp-18h]
  int v4; // [esp+24h] [ebp-14h]
  unsigned int v5; // [esp+2Ch] [ebp-Ch]

  v5 = __readgsdword(0x14u);
  v4 = a1;
  v2 = sub_8055DDA(dword_80658D1, (int)&v3);
  if ( !v2 )
    return 0;
  *(_BYTE *)(v2 + 8) = 2;
  return 1;
}
// 80658D1: using guessed type int dword_80658D1;

//----- (0804AA56) --------------------------------------------------------
int __cdecl sub_804AA56(__pid_t pid)
{
  int result; // eax

  result = sub_804A9FC(pid);
  if ( (_BYTE)result )
    result = sub_804A87C(pid);
  return result;
}

//----- (0804AA78) --------------------------------------------------------
int sub_804AA78()
{
  int result; // eax

  do
  {
    result = dword_80658D5;
    if ( dword_80658D5 <= 0 )
      break;
    result = sub_804A87C(0);
  }
  while ( result );
  return result;
}
// 80658D5: using guessed type int dword_80658D5;

//----- (0804AA9B) --------------------------------------------------------
int sub_804AA9B()
{
  sub_804A87C(-1);
  return sub_804AA78();
}

//----- (0804AAB4) --------------------------------------------------------
int sub_804AAB4()
{
  int result; // eax

  while ( 1 )
  {
    result = dword_80658D5;
    if ( dword_80658D5 <= 0 )
      break;
    sub_804A87C(-1);
  }
  return result;
}
// 80658D5: using guessed type int dword_80658D5;

//----- (0804AAD3) --------------------------------------------------------
int sub_804AAD3()
{
  int result; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  result = dword_80658CD;
  for ( i = dword_80658CD; i; i = *(_DWORD *)i )
  {
    unlink((const char *)(i + 9));
    result = *(_DWORD *)i;
  }
  dword_80658CD = 0;
  return result;
}
// 80658CD: using guessed type int dword_80658CD;

//----- (0804AB0B) --------------------------------------------------------
int sub_804AB0B()
{
  char v1; // [esp+1Ch] [ebp-8Ch]

  if ( dword_80658CD )
  {
    sub_804A7D4((int)&v1);
    sub_804AAD3();
    sub_804A809((unsigned __int8 *)&v1);
  }
  return sub_8053421();
}
// 80658CD: using guessed type int dword_80658CD;

//----- (0804AB45) --------------------------------------------------------
int *__cdecl sub_804AB45(int *a1, char a2)
{
  size_t n; // ST2C_4
  _DWORD *v3; // eax
  int v4; // ST38_4
  void *v5; // esi
  char *v6; // ebx
  int *v7; // eax
  int *ptr; // [esp+24h] [ebp-A4h]
  char *s; // [esp+28h] [ebp-A0h]
  int v11; // [esp+34h] [ebp-94h]
  char v12; // [esp+3Ch] [ebp-8Ch]

  s = (char *)*((_DWORD *)::ptr + dword_8065989);
  n = strlen(*((const char **)::ptr + dword_8065989));
  ptr = (int *)sub_805A7FD((n + 24) & 0xFFFFFFFC);
  memcpy((char *)ptr + 9, s, n);
  v3 = (int *)((char *)ptr + n + 9);
  *v3 = 1919906607;
  v3[1] = 1482184820;
  v3[2] = 5789784;
  *ptr = 0;
  if ( ++dword_8065989 == dword_8065835 )
    dword_8065989 = 0;
  sub_804A7D4((int)&v12);
  v11 = sub_8059A7F((int)ptr + 9, 0x80000);
  if ( v11 >= 0 )
  {
    *off_80652B8 = (int)ptr;
    off_80652B8 = ptr;
  }
  v4 = *__errno_location();
  sub_804A809((unsigned __int8 *)&v12);
  *__errno_location() = v4;
  if ( v11 < 0 )
  {
    if ( a2 != 1 || *__errno_location() != 24 )
    {
      v5 = sub_8058217(4, (int)s);
      v6 = gettext("cannot create temporary file in %s");
      v7 = __errno_location();
      error(2, *v7, v6, v5);
    }
    free(ptr);
    ptr = 0;
  }
  *a1 = v11;
  return ptr;
}
// 80652B8: using guessed type int *off_80652B8;
// 8065835: using guessed type int dword_8065835;
// 8065989: using guessed type int dword_8065989;

//----- (0804AD32) --------------------------------------------------------
FILE *__cdecl sub_804AD32(char *s1, char *modes)
{
  FILE *v2; // eax
  void *v3; // esi
  char *v4; // ebx
  int *v5; // eax
  FILE *stream; // [esp+18h] [ebp-10h]
  int fd; // [esp+1Ch] [ebp-Ch]

  if ( *modes == 114 )
  {
    if ( !strcmp(s1, "-") )
    {
      byte_8065840 = 1;
      stream = stdin;
      sub_8054769(stdin, 2);
    }
    else
    {
      fd = open64(s1, 0x80000);
      if ( fd < 0 )
        v2 = 0;
      else
        v2 = fdopen(fd, modes);
      stream = v2;
      sub_8054769(v2, 2);
    }
  }
  else
  {
    if ( *modes != 119 )
      __assert_fail("!\"unexpected mode passed to stream_open\"", "src/sort.c", 0x3CCu, "stream_open");
    if ( s1 && ftruncate64(1, 0, 0) )
    {
      v3 = sub_8058372(0, 3, (int)s1);
      v4 = gettext("%s: error truncating");
      v5 = __errno_location();
      error(2, *v5, v4, v3);
    }
    stream = stdout;
  }
  return stream;
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 8049D20: using guessed type int __cdecl ftruncate64(_DWORD, _DWORD, _DWORD);
// 8065840: using guessed type char byte_8065840;

//----- (0804AE6E) --------------------------------------------------------
FILE *__cdecl sub_804AE6E(char *s1, char *modes)
{
  char *v2; // eax
  FILE *v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_804AD32(s1, modes);
  if ( !v4 )
  {
    v2 = gettext("open failed");
    sub_804A4B6((int)v2, s1);
  }
  return v4;
}

//----- (0804AEAF) --------------------------------------------------------
void __cdecl sub_804AEAF(FILE *stream, int a2)
{
  int v2; // eax
  char *v3; // eax
  char *v4; // eax

  v2 = fileno(stream);
  if ( v2 )
  {
    if ( v2 == 1 )
    {
      if ( fflush_unlocked(stream) )
      {
        v3 = gettext("fflush failed");
        sub_804A4B6((int)v3, (char *)a2);
      }
    }
    else if ( sub_805B593(stream) )
    {
      v4 = gettext("close failed");
      sub_804A4B6((int)v4, (char *)a2);
    }
  }
  else if ( feof_unlocked(stream) )
  {
    clearerr_unlocked(stream);
  }
}

//----- (0804AF41) --------------------------------------------------------
int __cdecl sub_804AF41(int fd, int fd2)
{
  int result; // eax

  result = fd;
  if ( fd != fd2 )
  {
    dup2(fd, fd2);
    result = close(fd);
  }
  return result;
}

//----- (0804AF6E) --------------------------------------------------------
__pid_t __cdecl sub_804AF6E(int pipedes[2], int a2)
{
  int v3; // eax
  int v4; // ST1C_4
  __pid_t v5; // [esp+14h] [ebp-A4h]
  int v6; // [esp+18h] [ebp-A0h]
  int v7; // [esp+1Ch] [ebp-9Ch]
  double v8; // [esp+20h] [ebp-98h]
  char v9; // [esp+2Ch] [ebp-8Ch]

  v8 = 0.25;
  if ( sub_8056A98(pipedes, 0x80000) < 0 )
    return -1;
  if ( dword_80652B4 + 1 < (unsigned int)dword_80658D5 )
    sub_804AA9B();
  while ( 1 )
  {
    v3 = a2--;
    if ( !v3 )
      break;
    sub_804A7D4((int)&v9);
    v6 = dword_80658CD;
    dword_80658CD = 0;
    v5 = fork();
    v7 = *__errno_location();
    if ( v5 )
      dword_80658CD = v6;
    sub_804A809((unsigned __int8 *)&v9);
    *__errno_location() = v7;
    if ( v5 >= 0 || *__errno_location() != 11 )
      break;
    sub_805AB22(v8);
    v8 = v8 + v8;
    sub_804AA78();
  }
  if ( v5 >= 0 )
  {
    if ( v5 )
    {
      ++dword_80658D5;
    }
    else
    {
      close(0);
      close(1);
    }
  }
  else
  {
    v4 = *__errno_location();
    close(*pipedes);
    close(pipedes[1]);
    *__errno_location() = v4;
  }
  return v5;
}
// 80658CD: using guessed type int dword_80658CD;
// 80658D5: using guessed type int dword_80658D5;

//----- (0804B0EF) --------------------------------------------------------
int *__cdecl sub_804B0EF(FILE **a1, char a2)
{
  __pid_t v3; // eax
  int *v4; // eax
  char *v5; // ebx
  char *v6; // eax
  int v7; // [esp+Ch] [ebp-1Ch]
  int fd; // [esp+10h] [ebp-18h]
  int *v9; // [esp+14h] [ebp-14h]
  int pipedes[2]; // [esp+18h] [ebp-10h]

  LOBYTE(v7) = a2;
  v9 = sub_804AB45(&fd, a2);
  if ( !v9 )
    return 0;
  *((_BYTE *)v9 + 8) = 0;
  if ( s1 )
  {
    v3 = sub_804AF6E(pipedes, 4);
    v9[1] = v3;
    if ( v9[1] <= 0 )
    {
      if ( !v9[1] )
      {
        close(pipedes[1]);
        sub_804AF41(fd, 1);
        sub_804AF41(pipedes[0], 0);
        execlp(s1, s1, 0, v7);
        v4 = __errno_location();
        sub_804A3F0(*v4, "couldn't execute compress program");
      }
    }
    else
    {
      close(fd);
      close(pipedes[0]);
      fd = pipedes[1];
      sub_804A988((int)v9);
    }
  }
  *a1 = fdopen(fd, "w");
  if ( !*a1 )
  {
    v5 = (char *)v9 + 9;
    v6 = gettext("couldn't create temporary file");
    sub_804A4B6((int)v6, v5);
  }
  return v9;
}

//----- (0804B23B) --------------------------------------------------------
int *__cdecl sub_804B23B(FILE **a1)
{
  return sub_804B0EF(a1, 0);
}

//----- (0804B256) --------------------------------------------------------
FILE *__cdecl sub_804B256(int a1)
{
  __pid_t v2; // eax
  void *v3; // esi
  char *v4; // ebx
  int *v5; // eax
  int *v6; // eax
  FILE *v7; // eax
  int v8; // ST24_4
  FILE *v9; // [esp+18h] [ebp-20h]
  int fd; // [esp+1Ch] [ebp-1Ch]
  int pipedes[2]; // [esp+28h] [ebp-10h]

  v9 = 0;
  if ( *(_BYTE *)(a1 + 8) == 1 )
    sub_804AA56(*(_DWORD *)(a1 + 4));
  fd = open64(a1 + 9, 0);
  if ( fd < 0 )
    return 0;
  v2 = sub_804AF6E(pipedes, 9);
  if ( v2 == -1 )
  {
    if ( *__errno_location() != 24 )
    {
      v3 = sub_8058217(4, (int)s1);
      v4 = gettext("couldn't create process for %s -d");
      v5 = __errno_location();
      error(2, *v5, v4, v3);
    }
    close(fd);
    *__errno_location() = 24;
  }
  else
  {
    if ( !v2 )
    {
      close(pipedes[0]);
      sub_804AF41(fd, 0);
      sub_804AF41(pipedes[1], 1);
      execlp(s1, s1, "-d", 0);
      v6 = __errno_location();
      sub_804A3F0(*v6, "couldn't execute compress program (with -d)");
    }
    *(_DWORD *)(a1 + 4) = v2;
    sub_804A988(a1);
    close(fd);
    close(pipedes[1]);
    v7 = fdopen(pipedes[0], "r");
    v9 = v7;
    if ( !v7 )
    {
      v8 = *__errno_location();
      close(pipedes[0]);
      *__errno_location() = v8;
    }
  }
  return v9;
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);

//----- (0804B419) --------------------------------------------------------
int __cdecl sub_804B419(int a1)
{
  int v1; // eax
  _DWORD *v2; // edx
  int result; // eax

  if ( dword_8065835 == dword_8065839 )
    ptr = sub_805A753(ptr, (int)&dword_8065839, 4);
  v1 = dword_8065835++;
  v2 = (char *)ptr + 4 * v1;
  result = a1;
  *v2 = a1;
  return result;
}
// 8065835: using guessed type int dword_8065835;
// 8065839: using guessed type int dword_8065839;

//----- (0804B471) --------------------------------------------------------
void __cdecl sub_804B471(char *name)
{
  int v1; // ST28_4
  void *v2; // ebx
  char *v3; // eax
  int *i; // [esp+18h] [ebp-A0h]
  int errnum; // [esp+1Ch] [ebp-9Ch]
  _DWORD *ptr; // [esp+20h] [ebp-98h]
  int v7; // [esp+24h] [ebp-94h]
  char v8; // [esp+2Ch] [ebp-8Ch]

  for ( i = &dword_80658CD; ; i = (int *)*i )
  {
    ptr = (_DWORD *)*i;
    if ( (char *)(*i + 9) == name )
      break;
  }
  if ( *((_BYTE *)ptr + 8) == 1 )
    sub_804AA56(ptr[1]);
  v7 = *ptr;
  sub_804A7D4((int)&v8);
  v1 = unlink(name);
  errnum = *__errno_location();
  *i = v7;
  sub_804A809((unsigned __int8 *)&v8);
  if ( v1 )
  {
    v2 = sub_8058372(0, 3, (int)name);
    v3 = gettext("warning: cannot remove: %s");
    error(0, errnum, v3, v2);
  }
  if ( !v7 )
    off_80652B8 = i;
  free(ptr);
}
// 80652B8: using guessed type int *off_80652B8;
// 80658CD: using guessed type int dword_80658CD;

//----- (0804B5A9) --------------------------------------------------------
int __cdecl compar(const void *a1, const void *a2)
{
  return strcmp(*(const char **)a1, *(const char **)a2);
}

//----- (0804B5D3) --------------------------------------------------------
void sub_804B5D3()
{
  bool v0; // al
  const unsigned __int16 *v1; // ebx
  int v2; // eax
  unsigned int c; // [esp+18h] [ebp-20h]
  unsigned int ca; // [esp+18h] [ebp-20h]
  size_t i; // [esp+1Ch] [ebp-1Ch]
  int v6; // [esp+20h] [ebp-18h]
  const char *s; // [esp+24h] [ebp-14h]
  size_t v8; // [esp+28h] [ebp-10h]
  char *v9; // [esp+2Ch] [ebp-Ch]

  for ( c = 0; c <= 0xFF; ++c )
  {
    *(_BYTE *)(c + 134632493) = sub_804A18F(c);
    *(_BYTE *)(c + 134632749) = ((*__ctype_b_loc())[c] & 0x4000) == 0;
    v0 = !((*__ctype_b_loc())[c] & 8) && (unsigned __int8)sub_804A18F(c) ^ 1;
    *(_BYTE *)(c + 134633005) = v0;
    *(_BYTE *)(c + 134633261) = toupper(c);
  }
  if ( byte_8065416 )
  {
    for ( ca = 0; ca <= 0xB; ++ca )
    {
      s = nl_langinfo(ca + 131086);
      v8 = strlen(s);
      v9 = (char *)sub_805A7FD(v8 + 1);
      (&off_806524C)[2 * ca] = v9;
      dword_8065250[2 * ca] = ca + 1;
      v6 = 0;
      for ( i = 0; i < v8; ++i )
      {
        v1 = *__ctype_b_loc();
        if ( !(v1[(unsigned __int8)sub_804A17D(s[i])] & 1) )
        {
          v2 = v6++;
          v9[v2] = byte_806572D[(unsigned __int8)sub_804A17D(s[i])];
        }
      }
      v9[v6] = 0;
    }
    qsort(&off_806524C, 0xCu, 8u, compar);
  }
}
// 806524C: using guessed type char *off_806524C;
// 8065250: using guessed type int dword_8065250[];
// 8065416: using guessed type char byte_8065416;

//----- (0804B7C4) --------------------------------------------------------
unsigned int __cdecl sub_804B7C4(int a1, char a2, char *a3)
{
  int v3; // eax
  void *v4; // ebx
  int v5; // esi
  char *v6; // eax
  void *v7; // ebx
  int v8; // esi
  char *v9; // eax
  void *v11; // ebx
  int v12; // esi
  char *v13; // eax
  int v14; // ebx
  int v15; // esi
  char *v16; // eax
  int v17; // [esp+20h] [ebp-38h]
  unsigned int v18; // [esp+24h] [ebp-34h]
  __int64 v19; // [esp+28h] [ebp-30h]
  int v20; // [esp+30h] [ebp-28h]
  char v21; // [esp+41h] [ebp-17h]
  unsigned int v22; // [esp+4Ch] [ebp-Ch]

  v22 = __readgsdword(0x14u);
  v17 = sub_805B19D(a3, 0, 10, (int)&v19, 0);
  if ( getrlimit64(7, &v20) )
    v3 = 17;
  else
    v3 = v20 - 3;
  v18 = v3;
  if ( v17 )
    goto LABEL_12;
  dword_80652B4 = v19;
  if ( v19 != (unsigned int)v19 )
  {
    v17 = 1;
    goto LABEL_12;
  }
  if ( (unsigned int)dword_80652B4 <= 1 )
  {
    v4 = sub_80585AA((int)a3);
    v5 = *((_DWORD *)&longopts.name + 4 * a1);
    v6 = gettext("invalid --%s argument %s");
    error(0, 0, v6, v5, v4);
    v7 = sub_80585AA((int)"2");
    v8 = *((_DWORD *)&longopts.name + 4 * a1);
    v9 = gettext("minimum --%s argument is %s");
    error(2, 0, v9, v8, v7);
  }
  if ( v18 < dword_80652B4 )
  {
    v17 = 1;
LABEL_12:
    if ( v17 == 1 )
    {
      v11 = sub_80585AA((int)a3);
      v12 = *((_DWORD *)&longopts.name + 4 * a1);
      v13 = gettext("--%s argument %s too large");
      error(0, 0, v13, v12, v11);
      v14 = sub_8056397(v18, (int)&v21);
      v15 = *((_DWORD *)&longopts.name + 4 * a1);
      v16 = gettext("maximum --%s argument with current rlimit is %s");
      error(2, 0, v16, v15, v14);
    }
    sub_805B098(v17, a1, a2, (int)&longopts, (int)a3);
  }
  return __readgsdword(0x14u) ^ v22;
}
// 8049920: using guessed type int __cdecl getrlimit64(_DWORD, _DWORD);

//----- (0804BA0E) --------------------------------------------------------
int __cdecl sub_804BA0E(int a1, int a2, char *nptr)
{
  int v3; // eax
  unsigned __int64 v4; // rax
  int result; // eax
  int v6; // [esp+38h] [ebp-30h]
  int v7; // [esp+3Ch] [ebp-2Ch]
  unsigned __int64 v8; // [esp+40h] [ebp-28h]
  double v9; // [esp+48h] [ebp-20h]

  v7 = sub_805B19D(nptr, (int)&v6, 10, (int)&v8, "EgGkKmMPtTYZ");
  if ( !v7 && (unsigned int)(*(char *)(v6 - 1) - 48) <= 9 )
  {
    if ( HIDWORD(v8) > 0x3FFFFF )
      v7 = 1;
    else
      v8 <<= 10;
  }
  if ( v7 == 2 && (unsigned int)(*(char *)(v6 - 1) - 48) <= 9 && !*(_BYTE *)(v6 + 1) )
  {
    v3 = *(char *)v6;
    if ( v3 == 37 )
    {
      v9 = sub_8056924() * (double)v8 / 100.0;
      if ( v9 >= 1.844674407370955e19 )
      {
        v7 = 1;
      }
      else
      {
        if ( v9 >= 9.223372036854776e18 )
          v4 = (signed __int64)(v9 - 9.223372036854776e18) ^ 0x8000000000000000LL;
        else
          v4 = (signed __int64)v9;
        v8 = v4;
        v7 = 0;
      }
    }
    else if ( v3 == 98 )
    {
      v7 = 0;
    }
  }
  if ( v7 )
LABEL_25:
    sub_805B098(v7, a1, a2, (int)&longopts, (int)nptr);
  result = v8;
  if ( size > v8 )
    return result;
  size = v8;
  if ( v8 != (unsigned int)v8 )
  {
    v7 = 1;
    goto LABEL_25;
  }
  result = size;
  if ( 18 * dword_80652B4 >= size )
    result = 18 * dword_80652B4;
  size = result;
  return result;
}

//----- (0804BC53) --------------------------------------------------------
int __cdecl sub_804BC53(int a1, int a2, char *nptr)
{
  char *v4; // eax
  int v5; // [esp+28h] [ebp-10h]
  int v6; // [esp+2Ch] [ebp-Ch]

  v6 = sub_805AC0E(nptr, 0, 10, (int)&v5, &s);
  if ( v6 == 1 )
    return -1;
  if ( v6 )
    sub_805B098(v6, a1, a2, (int)&longopts, (int)nptr);
  if ( !v5 )
  {
    v4 = gettext("number in parallel must be nonzero");
    error(2, 0, v4);
  }
  return v5;
}

//----- (0804BCF8) --------------------------------------------------------
int sub_804BCF8()
{
  long double v0; // fst7
  int result; // eax
  unsigned int v2; // [esp+24h] [ebp-34h]
  unsigned int v3; // [esp+24h] [ebp-34h]
  double v4; // [esp+28h] [ebp-30h]
  double v5; // [esp+30h] [ebp-28h]
  double v6; // [esp+38h] [ebp-20h]
  unsigned __int64 v7; // [esp+40h] [ebp-18h]

  v2 = -1;
  if ( !getrlimit64(2, &v7) && v7 < 0xFFFFFFFF )
    v2 = v7;
  if ( !getrlimit64(9, &v7) && v7 < v2 )
    v2 = v7;
  v3 = v2 >> 1;
  if ( !getrlimit64(5, &v7) && 15 * (v7 >> 4) < v3 )
    v3 = 15 * (v7 >> 4);
  v4 = sub_80569D1();
  v5 = sub_8056924();
  if ( v4 <= v5 / 8.0 )
    v0 = v5 / 8.0;
  else
    v0 = v4;
  v6 = v0;
  if ( (long double)v3 > v5 * 0.75 )
    v3 = (signed __int64)(v5 * 0.75);
  if ( (long double)v3 > v6 )
    v3 = (signed __int64)v6;
  result = v3;
  if ( 18 * dword_80652B4 >= v3 )
    result = 18 * dword_80652B4;
  return result;
}
// 8049920: using guessed type int __cdecl getrlimit64(_DWORD, _DWORD);

//----- (0804BEC7) --------------------------------------------------------
int __cdecl sub_804BEC7(int a1, unsigned int a2, int a3, unsigned int a4, int a5)
{
  int v5; // eax
  bool v6; // al
  char *v7; // ebx
  char *v8; // eax
  int v10; // [esp+18h] [ebp-80h]
  unsigned int i; // [esp+1Ch] [ebp-7Ch]
  unsigned int v12; // [esp+20h] [ebp-78h]
  unsigned int v13; // [esp+24h] [ebp-74h]
  signed __int64 v14; // [esp+28h] [ebp-70h]
  char v15; // [esp+30h] [ebp-68h]
  int v16; // [esp+40h] [ebp-58h]
  __int64 v17; // [esp+5Ch] [ebp-3Ch]

  v12 = a5 + 1;
  v10 = a5 + 2;
  for ( i = 0; i < a4; ++i )
  {
    if ( i >= a2 )
    {
      if ( !strcmp(*(const char **)(4 * i + a3), "-") )
        v6 = sub_805D0B2(0, (int)&v15) != 0;
      else
        v6 = sub_805D083(*(_DWORD *)(4 * i + a3), (int)&v15) != 0;
    }
    else
    {
      v5 = fileno(*(FILE **)(4 * i + a1));
      v6 = sub_805D0B2(v5, (int)&v15) != 0;
    }
    if ( v6 )
    {
      v7 = *(char **)(4 * i + a3);
      v8 = gettext("stat failed");
      sub_804A4B6((int)v8, v7);
    }
    if ( (v16 & 0xF000) == 0x8000 )
    {
      v14 = v17;
    }
    else
    {
      if ( size )
        return size;
      v14 = 0x20000LL;
    }
    if ( !dword_806598D )
    {
      dword_806598D = size;
      if ( !size )
        dword_806598D = sub_804BCF8();
    }
    v13 = v12 * v14 + 1;
    if ( v14 != v13 / v12 || dword_806598D - v10 <= v13 )
      return dword_806598D;
    v10 += v13;
  }
  return v10;
}
// 806598D: using guessed type int dword_806598D;

//----- (0804C07C) --------------------------------------------------------
int __cdecl sub_804C07C(int a1, int a2, size_t size)
{
  int result; // eax
  size_t sizea; // [esp+28h] [ebp+10h]

  while ( 1 )
  {
    sizea = (size & 0xFFFFFFF0) + 16;
    *(_DWORD *)a1 = malloc(sizea);
    if ( *(_DWORD *)a1 )
      break;
    size = sizea >> 1;
    if ( a2 + 1 >= size )
      sub_805A94D();
  }
  *(_DWORD *)(a1 + 20) = a2;
  *(_DWORD *)(a1 + 12) = sizea;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a1 + 16);
  result = a1;
  *(_BYTE *)(a1 + 24) = 0;
  return result;
}

//----- (0804C102) --------------------------------------------------------
int __cdecl sub_804C102(_DWORD *a1)
{
  return *a1 + a1[3];
}

//----- (0804C11D) --------------------------------------------------------
int __cdecl sub_804C11D(int a1, int *a2)
{
  int v2; // eax
  int v3; // eax
  int result; // eax
  unsigned __int8 *v5; // [esp+4h] [ebp-10h]
  int v6; // [esp+8h] [ebp-Ch]
  unsigned int v7; // [esp+Ch] [ebp-8h]
  int v8; // [esp+10h] [ebp-4h]

  v5 = *(unsigned __int8 **)a1;
  v7 = *(_DWORD *)(a1 + 4) - 1 + *(_DWORD *)a1;
  v6 = *a2;
  v8 = a2[1];
  if ( dword_80652B0 == 128 )
  {
    while ( (unsigned int)v5 < v7 )
    {
      v3 = v6--;
      if ( !v3 )
        break;
      while ( (unsigned int)v5 < v7 && byte_806542D[(unsigned __int8)sub_804A17D(*v5)] )
        ++v5;
      while ( (unsigned int)v5 < v7 && (unsigned __int8)byte_806542D[(unsigned __int8)sub_804A17D(*v5)] ^ 1 )
        ++v5;
    }
  }
  else
  {
    while ( (unsigned int)v5 < v7 )
    {
      v2 = v6--;
      if ( !v2 )
        break;
      while ( (unsigned int)v5 < v7 && (char)*v5 != dword_80652B0 )
        ++v5;
      if ( (unsigned int)v5 < v7 )
        ++v5;
    }
  }
  if ( *((_BYTE *)a2 + 24) )
  {
    while ( (unsigned int)v5 < v7 && byte_806542D[(unsigned __int8)sub_804A17D(*v5)] )
      ++v5;
  }
  result = v7;
  if ( (unsigned int)&v5[v8] <= v7 )
    result = (int)&v5[v8];
  return result;
}
// 80652B0: using guessed type int dword_80652B0;

//----- (0804C266) --------------------------------------------------------
unsigned __int8 *__cdecl sub_804C266(int a1, int a2)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  unsigned __int8 *v6; // [esp+4h] [ebp-10h]
  int v7; // [esp+8h] [ebp-Ch]
  unsigned int v8; // [esp+Ch] [ebp-8h]
  int v9; // [esp+10h] [ebp-4h]

  v6 = *(unsigned __int8 **)a1;
  v8 = *(_DWORD *)(a1 + 4) - 1 + *(_DWORD *)a1;
  v7 = *(_DWORD *)(a2 + 8);
  v9 = *(_DWORD *)(a2 + 12);
  if ( !v9 )
    ++v7;
  if ( dword_80652B0 == 128 )
  {
    while ( (unsigned int)v6 < v8 )
    {
      v3 = v7--;
      if ( !v3 )
        break;
      while ( (unsigned int)v6 < v8 && byte_806542D[(unsigned __int8)sub_804A17D(*v6)] )
        ++v6;
      while ( (unsigned int)v6 < v8 && (unsigned __int8)byte_806542D[(unsigned __int8)sub_804A17D(*v6)] ^ 1 )
        ++v6;
    }
  }
  else
  {
    while ( (unsigned int)v6 < v8 )
    {
      v2 = v7--;
      if ( !v2 )
        break;
      while ( (unsigned int)v6 < v8 && (char)*v6 != dword_80652B0 )
        ++v6;
      if ( (unsigned int)v6 < v8 && (v7 || v9) )
        ++v6;
    }
  }
  if ( v9 )
  {
    if ( *(_BYTE *)(a2 + 25) )
    {
      while ( (unsigned int)v6 < v8 && byte_806542D[(unsigned __int8)sub_804A17D(*v6)] )
        ++v6;
    }
    v4 = v8;
    if ( (unsigned int)&v6[v9] <= v8 )
      v4 = (int)&v6[v9];
    v6 = (unsigned __int8 *)v4;
  }
  return v6;
}
// 80652B0: using guessed type int dword_80652B0;

//----- (0804C3CC) --------------------------------------------------------
int __cdecl sub_804C3CC(int a1, FILE *stream, int a3)
{
  unsigned __int8 *v4; // eax
  char *v5; // eax
  char *v6; // eax
  size_t v7; // eax
  unsigned __int8 *v8; // eax
  int v9; // eax
  int v10; // eax
  char v11; // [esp+1Bh] [ebp-3Dh]
  int v12; // [esp+1Ch] [ebp-3Ch]
  size_t v13; // [esp+20h] [ebp-38h]
  void *ptr; // [esp+24h] [ebp-34h]
  unsigned __int8 **v15; // [esp+28h] [ebp-30h]
  unsigned int v16; // [esp+2Ch] [ebp-2Ch]
  unsigned __int8 *v17; // [esp+30h] [ebp-28h]
  unsigned __int8 *v18; // [esp+34h] [ebp-24h]
  int v19; // [esp+38h] [ebp-20h]
  int v20; // [esp+3Ch] [ebp-1Ch]
  int v21; // [esp+40h] [ebp-18h]
  size_t n; // [esp+44h] [ebp-14h]
  size_t v23; // [esp+48h] [ebp-10h]
  unsigned __int8 *v24; // [esp+4Ch] [ebp-Ch]

  v19 = dword_8065841;
  v11 = byte_806522C;
  v20 = *(_DWORD *)(a1 + 20);
  v13 = dword_80652AC - 18;
  if ( *(_BYTE *)(a1 + 24) )
    return 0;
  if ( *(_DWORD *)(a1 + 4) != *(_DWORD *)(a1 + 16) )
  {
    memmove(
      *(void **)a1,
      (const void *)(*(_DWORD *)(a1 + 4) - *(_DWORD *)(a1 + 16) + *(_DWORD *)a1),
      *(_DWORD *)(a1 + 16));
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 8) = 0;
  }
  while ( 1 )
  {
    ptr = (void *)(*(_DWORD *)a1 + *(_DWORD *)(a1 + 4));
    v21 = sub_804C102((_DWORD *)a1);
    v15 = (unsigned __int8 **)(-16 * *(_DWORD *)(a1 + 8) + v21);
    v16 = v21 - v20 * *(_DWORD *)(a1 + 8) - (_DWORD)ptr;
    v4 = *(_DWORD *)(a1 + 8) ? &v15[1][(_DWORD)*v15] : *(_DWORD *)a1;
    v17 = v4;
    do
    {
      if ( v20 + 1 >= v16 )
        break;
      n = (v16 - 1) / (v20 + 1);
      v23 = fread_unlocked(ptr, 1u, n, stream);
      v18 = (unsigned __int8 *)ptr + v23;
      v16 -= v23;
      if ( v23 != n )
      {
        if ( ferror_unlocked(stream) )
        {
          v5 = gettext("read failed");
          sub_804A4B6((int)v5, (char *)a3);
        }
        if ( feof_unlocked(stream) )
        {
          *(_BYTE *)(a1 + 24) = 1;
          if ( *(unsigned __int8 **)a1 == v18 )
            return 0;
          if ( v17 != v18 && *(v18 - 1) != v11 )
          {
            v6 = (char *)v18++;
            *v6 = v11;
          }
        }
      }
      while ( 1 )
      {
        v24 = (unsigned __int8 *)memchr(ptr, v11, v18 - (_BYTE *)ptr);
        if ( !v24 )
          break;
        *v24 = 0;
        ptr = v24 + 1;
        v15 -= 4;
        *v15 = v17;
        v15[1] = (unsigned __int8 *)((_BYTE *)ptr - v17);
        v7 = v13;
        if ( (unsigned int)v15[1] >= v13 )
          v7 = (size_t)v15[1];
        v13 = v7;
        v16 -= v20;
        if ( v19 )
        {
          if ( *(_DWORD *)(v19 + 8) == -1 )
            v8 = v24;
          else
            v8 = sub_804C266((int)v15, v19);
          v15[3] = v8;
          if ( *(_DWORD *)v19 == -1 )
          {
            if ( *(_BYTE *)(v19 + 24) )
            {
              while ( byte_806542D[(unsigned __int8)sub_804A17D(*v17)] )
                ++v17;
            }
            v15[2] = v17;
          }
          else
          {
            v9 = sub_804C11D((int)v15, (int *)v19);
            v15[2] = (unsigned __int8 *)v9;
          }
        }
        v17 = (unsigned __int8 *)ptr;
      }
      ptr = v18;
    }
    while ( !*(_BYTE *)(a1 + 24) );
    *(_DWORD *)(a1 + 4) = (char *)ptr - *(_DWORD *)a1;
    v10 = sub_804C102((_DWORD *)a1);
    *(_DWORD *)(a1 + 8) = (v10 - (signed int)v15) >> 4;
    if ( *(_DWORD *)(a1 + 8) )
      break;
    v12 = *(_DWORD *)(a1 + 12) >> 4;
    *(_DWORD *)a1 = sub_805A753(*(void **)a1, (int)&v12, 16);
    *(_DWORD *)(a1 + 12) = 16 * v12;
  }
  *(_DWORD *)(a1 + 16) = (_BYTE *)ptr - v17;
  dword_80652AC = v13 + 18;
  return 1;
}
// 806522C: using guessed type char byte_806522C;
// 8065841: using guessed type int dword_8065841;

//----- (0804C788) --------------------------------------------------------
int __cdecl sub_804C788(char **a1)
{
  int v1; // edx
  char *v2; // eax
  int result; // eax
  char *v4; // eax
  unsigned __int8 v5; // [esp+9h] [ebp-7h]
  bool v6; // [esp+Ah] [ebp-6h]
  unsigned __int8 v7; // [esp+Bh] [ebp-5h]
  char *v8; // [esp+Ch] [ebp-4h]

  v8 = *a1;
  v5 = 0;
  v6 = 0;
  while ( 1 )
  {
    v2 = v8++;
    v7 = *v2;
    if ( (unsigned int)(unsigned __int8)*v2 - 48 > 9 )
      break;
    if ( v5 < v7 )
      v5 = *v2;
    v1 = *v8;
    v6 = v1 == dword_8065411;
    if ( v1 == dword_8065411 )
      ++v8;
  }
  if ( v6 )
  {
    *a1 = v8 - 2;
    result = v5;
  }
  else
  {
    if ( v7 == dword_806540D )
    {
      while ( 1 )
      {
        v4 = v8++;
        if ( (unsigned int)(unsigned __int8)*v4 - 48 > 9 )
          break;
        if ( v5 < (unsigned __int8)*v4 )
          v5 = *v4;
      }
    }
    *a1 = v8 - 1;
    result = v5;
  }
  return result;
}
// 806540D: using guessed type int dword_806540D;
// 8065411: using guessed type int dword_8065411;

//----- (0804C84D) --------------------------------------------------------
int __cdecl sub_804C84D(_BYTE *a1)
{
  int result; // eax
  bool v2; // [esp+9h] [ebp-Bh]
  unsigned __int8 *v3; // [esp+Ch] [ebp-8h]
  int v4; // [esp+10h] [ebp-4h]

  v2 = *a1 == 45;
  v3 = &a1[v2];
  if ( (unsigned __int8)sub_804C788((char **)&v3) <= 0x30u )
    return 0;
  v4 = byte_805E920[*v3];
  if ( v2 )
    result = -v4;
  else
    result = v4;
  return result;
}

//----- (0804C8B4) --------------------------------------------------------
int __cdecl sub_804C8B4(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v2; // ebx
  int v3; // eax
  int result; // eax

  while ( byte_806542D[(unsigned __int8)sub_804A17D(*a1)] )
    ++a1;
  while ( byte_806542D[(unsigned __int8)sub_804A17D(*a2)] )
    ++a2;
  v2 = sub_804C84D(a1);
  v3 = sub_804C84D(a2);
  if ( v2 == v3 )
    result = sub_805A013(a1, a2, dword_806540D, dword_8065411);
  else
    result = v2 - v3;
  return result;
}
// 806540D: using guessed type int dword_806540D;
// 8065411: using guessed type int dword_8065411;

//----- (0804C95A) --------------------------------------------------------
int __cdecl sub_804C95A(unsigned __int8 *a1, unsigned __int8 *a2)
{
  while ( byte_806542D[(unsigned __int8)sub_804A17D(*a1)] )
    ++a1;
  while ( byte_806542D[(unsigned __int8)sub_804A17D(*a2)] )
    ++a2;
  return sub_805A013(a1, a2, dword_806540D, dword_8065411);
}
// 806540D: using guessed type int dword_806540D;
// 8065411: using guessed type int dword_8065411;

//----- (0804C9D1) --------------------------------------------------------
int __cdecl sub_804C9D1(int a1, int a2)
{
  _TBYTE s; // [esp+10h] [ebp-28h]
  _TBYTE s2; // [esp+20h] [ebp-18h]

  memset(&s, 0, 0xCu);
  *(long double *)&s = strtold(a1, 0);
  memset(&s2, 0, 0xCu);
  *(long double *)&s2 = strtold(a2, 0);
  return memcmp(&s, &s2, 0xCu);
}
// 80498F0: using guessed type double __cdecl strtold(_DWORD, _DWORD);

//----- (0804CA55) --------------------------------------------------------
signed int __cdecl sub_804CA55(int a1, int a2)
{
  signed int result; // eax
  int v3; // [esp+18h] [ebp-30h]
  int v4; // [esp+1Ch] [ebp-2Ch]
  long double v5; // [esp+20h] [ebp-28h]
  long double v6; // [esp+30h] [ebp-18h]

  v5 = strtold(a1, &v3);
  v6 = strtold(a2, &v4);
  if ( a1 == v3 )
  {
    if ( a2 == v4 )
      result = 0;
    else
      result = -1;
  }
  else if ( a2 == v4 )
  {
    result = 1;
  }
  else if ( v6 <= v5 )
  {
    if ( v5 <= v6 )
    {
      if ( v6 == v5 )
        result = 0;
      else
        result = -1;
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}
// 80498F0: using guessed type double __cdecl strtold(_DWORD, _DWORD);

//----- (0804CB56) --------------------------------------------------------
int __cdecl sub_804CB56(unsigned __int8 *a1, unsigned __int8 **a2)
{
  unsigned __int8 v3; // al
  unsigned __int8 v4; // bl
  unsigned __int8 v5; // al
  unsigned __int8 v6; // bl
  unsigned int v7; // [esp+10h] [ebp-18h]
  unsigned int v8; // [esp+14h] [ebp-14h]
  unsigned __int8 *v9; // [esp+18h] [ebp-10h]
  unsigned __int8 *i; // [esp+1Ch] [ebp-Ch]
  unsigned int v11; // [esp+20h] [ebp-8h]

  v7 = 0;
  v8 = 12;
  while ( byte_806542D[(unsigned __int8)sub_804A17D(*a1)] )
    ++a1;
  while ( 2 )
  {
    v11 = (v7 + v8) >> 1;
    v9 = a1;
    for ( i = (unsigned __int8 *)(&off_806524C)[2 * v11]; ; ++i )
    {
      if ( !*i )
      {
        if ( a2 )
          *a2 = v9;
        return dword_8065250[2 * v11];
      }
      v3 = sub_804A17D(*v9);
      v4 = sub_804A17D(byte_806572D[v3]);
      if ( v4 < (unsigned __int8)sub_804A17D(*i) )
      {
        v8 = (v7 + v8) >> 1;
        goto LABEL_14;
      }
      v5 = sub_804A17D(*v9);
      v6 = sub_804A17D(byte_806572D[v5]);
      if ( v6 > (unsigned __int8)sub_804A17D(*i) )
        break;
      ++v9;
    }
    v7 = v11 + 1;
LABEL_14:
    if ( v7 < v8 )
      continue;
    return 0;
  }
}
// 806524C: using guessed type char *off_806524C;
// 8065250: using guessed type int dword_8065250[];

//----- (0804CC88) --------------------------------------------------------
unsigned int __cdecl sub_804CC88(char *a1)
{
  char *v1; // eax
  char *v2; // eax
  char *ptr; // [esp+18h] [ebp-20h]
  char src; // [esp+1Ch] [ebp-1Ch]
  unsigned int v6; // [esp+2Ch] [ebp-Ch]

  v6 = __readgsdword(0x14u);
  ptr = sub_8058870((int)a1, 0x10u);
  if ( !ptr )
  {
    v1 = gettext("open failed");
    sub_804A4B6((int)v1, a1);
  }
  sub_8058B03((int)ptr, &src, 0x10u);
  if ( sub_8058B4B(ptr) )
  {
    v2 = gettext("close failed");
    sub_804A4B6((int)v2, a1);
  }
  sub_8053505(&unk_80658ED);
  sub_8053861(&src, 0x10u, (int)&unk_80658ED);
  return __readgsdword(0x14u) ^ v6;
}

//----- (0804CD54) --------------------------------------------------------
size_t __cdecl sub_804CD54(char *dest, char *src, size_t n)
{
  char *v3; // ebx
  int *v4; // eax
  char *v5; // eax
  void *v6; // ebx
  char *v7; // eax
  size_t v9; // [esp+1Ch] [ebp-Ch]

  *__errno_location() = 0;
  v9 = strxfrm(dest, src, n);
  if ( *__errno_location() )
  {
    v3 = gettext("string transformation failed");
    v4 = __errno_location();
    error(0, *v4, v3);
    v5 = gettext("set LC_ALL='C' to work around the problem");
    error(0, 0, v5);
    v6 = sub_805819C(0, 8, (int)src);
    v7 = gettext("the untransformed string was %s");
    error(2, 0, v7, v6);
  }
  return v9;
}

//----- (0804CE2C) --------------------------------------------------------
int __cdecl sub_804CE2C(int a1, size_t a2, int a3, size_t a4)
{
  unsigned int v4; // eax
  size_t v5; // eax
  size_t v6; // edx
  char *v7; // eax
  size_t v8; // eax
  size_t v9; // eax
  size_t v10; // eax
  char *s; // [esp+18h] [ebp-1150h]
  char *src; // [esp+1Ch] [ebp-114Ch]
  bool v14; // [esp+2Bh] [ebp-113Dh]
  int v15; // [esp+2Ch] [ebp-113Ch]
  char *dest; // [esp+30h] [ebp-1138h]
  unsigned int size; // [esp+34h] [ebp-1134h]
  void *ptr; // [esp+38h] [ebp-1130h]
  int v19; // [esp+3Ch] [ebp-112Ch]
  size_t v20; // [esp+40h] [ebp-1128h]
  size_t v21; // [esp+44h] [ebp-1124h]
  unsigned int v22; // [esp+48h] [ebp-1120h]
  size_t n; // [esp+4Ch] [ebp-111Ch]
  size_t v24; // [esp+50h] [ebp-1118h]
  char s1; // [esp+54h] [ebp-1114h]
  int v26; // [esp+64h] [ebp-1104h]
  int v27; // [esp+74h] [ebp-10F4h]
  char v28; // [esp+110h] [ebp-1058h]
  char v29; // [esp+1ACh] [ebp-FBCh]
  unsigned int v30; // [esp+114Ch] [ebp-1Ch]

  src = (char *)a1;
  s = (char *)a3;
  v30 = __readgsdword(0x14u);
  v15 = 0;
  dest = &v29;
  size = 4000;
  ptr = 0;
  qmemcpy(&v28, &unk_80658ED, 0x9Cu);
  qmemcpy(&v27, &v28, 0x9Cu);
  if ( byte_8065415 )
  {
    v20 = a1 + a2;
    v21 = a3 + a4;
    while ( 1 )
    {
      v22 = 3 * (a4 + a2) + 2;
      if ( size < v22 )
      {
        v4 = 3 * (a4 + a2) + 2;
        if ( 3 * size >> 1 >= v22 )
          v4 = 3 * size >> 1;
        size = v4;
        free(ptr);
        ptr = malloc(size);
        dest = (char *)ptr;
        if ( !ptr )
        {
          dest = &v29;
          size = 4000;
        }
      }
      if ( (unsigned int)src >= v20 )
        v5 = 0;
      else
        v5 = sub_804CD54(dest, src, size) + 1;
      n = v5;
      v14 = v5 <= size;
      if ( (unsigned int)s >= v21 )
      {
        v8 = 0;
      }
      else
      {
        if ( v14 )
          v6 = size - v5;
        else
          v6 = 0;
        if ( v14 )
          v7 = &dest[v5];
        else
          v7 = 0;
        v8 = sub_804CD54(v7, s, v6) + 1;
      }
      v24 = v8;
      if ( v14 != 1 || n + v8 > size )
      {
        size = n + v8;
        if ( n + v8 <= 0x55555554 )
          size = 3 * size >> 1;
        free(ptr);
        ptr = sub_805A7FD(size);
        dest = (char *)ptr;
        if ( (unsigned int)src < v20 )
          strxfrm((char *)ptr, src, n);
        if ( (unsigned int)s < v21 )
          strxfrm((char *)ptr + n, s, v24);
      }
      if ( (unsigned int)src < v20 )
        src += strlen(src) + 1;
      if ( (unsigned int)s < v21 )
        s += strlen(s) + 1;
      if ( (unsigned int)src >= v20 && (unsigned int)s >= v21 )
        break;
      sub_8053861(dest, n, (int)&v27);
      sub_8053861(&dest[n], v24, (int)&v28);
      if ( !v15 )
      {
        v9 = n;
        if ( v24 <= n )
          v9 = v24;
        v15 = memcmp(dest, &dest[n], v9);
        if ( !v15 )
          v15 = (n > v24) - (n < v24);
      }
    }
    a2 = n;
    src = dest;
    a4 = v24;
    s = &dest[n];
    sub_8053861(dest, n, (int)&v27);
  }
  else
  {
    sub_8053861((void *)a1, a2, (int)&v27);
  }
  sub_80535CB(&v27, &s1);
  sub_8053861(s, a4, (int)&v28);
  sub_80535CB((int *)&v28, &v26);
  v19 = memcmp(&s1, &v26, 0x10u);
  if ( !v19 )
  {
    if ( !v15 )
    {
      v10 = a2;
      if ( a4 <= a2 )
        v10 = a4;
      v15 = memcmp(src, s, v10);
      if ( !v15 )
        v15 = (a2 > a4) - (a2 < a4);
    }
    v19 = v15;
  }
  free(ptr);
  return v19;
}
// 8065415: using guessed type char byte_8065415;

//----- (0804D3E9) --------------------------------------------------------
int __cdecl sub_804D3E9(char *a1, unsigned int a2)
{
  char *v2; // eax
  int v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_80564A8(a1, a2 - (_DWORD)a1, 0);
  while ( (unsigned int)a1 < a2 )
  {
    v2 = a1++;
    v4 += *v2 == 9;
  }
  return v4;
}

//----- (0804D439) --------------------------------------------------------
int __cdecl sub_804D439(int a1, int a2)
{
  int v2; // eax
  char *v3; // eax
  int result; // eax

  while ( 1 )
  {
    v2 = a1--;
    if ( !v2 )
      break;
    putchar_unlocked(32);
  }
  if ( a2 )
  {
    do
    {
      putchar_unlocked(95);
      --a2;
    }
    while ( a2 );
    result = putchar_unlocked(10);
  }
  else
  {
    v3 = gettext("^ no match for key\n");
    result = printf(v3);
  }
  return result;
}

//----- (0804D49A) --------------------------------------------------------
int __cdecl sub_804D49A(_BYTE *a1)
{
  return a1[26] || a1[28] || a1[29];
}

//----- (0804D4CF) --------------------------------------------------------
int __cdecl sub_804D4CF(int *a1, int a2)
{
  _BOOL4 v2; // eax
  _BOOL4 v3; // eax
  unsigned __int8 v5; // [esp+11h] [ebp-37h]
  unsigned __int8 *v6; // [esp+14h] [ebp-34h]
  unsigned __int8 *v7; // [esp+18h] [ebp-30h]
  unsigned __int8 *v8; // [esp+1Ch] [ebp-2Ch]
  unsigned __int8 *v9; // [esp+20h] [ebp-28h]
  char *v10; // [esp+24h] [ebp-24h]
  int v11; // [esp+28h] [ebp-20h]
  int v12; // [esp+2Ch] [ebp-1Ch]
  long double v13; // [esp+30h] [ebp-18h]

  v10 = (char *)*a1;
  v8 = (unsigned __int8 *)v10;
  v9 = (unsigned __int8 *)&v10[a1[1] - 1];
  if ( a2 )
  {
    if ( *(_DWORD *)a2 != -1 )
      v8 = (unsigned __int8 *)sub_804C11D((int)a1, (int *)a2);
    if ( *(_DWORD *)(a2 + 8) != -1 )
      v9 = sub_804C266((int)a1, a2);
    if ( *(_BYTE *)(a2 + 24) && *(_DWORD *)a2 == -1 || *(_BYTE *)(a2 + 30) || (unsigned __int8)sub_804D49A((_BYTE *)a2) )
    {
      v5 = *v9;
      *v9 = 0;
      while ( byte_806542D[(unsigned __int8)sub_804A17D(*v8)] )
        ++v8;
      v6 = v8;
      if ( v9 >= v8 )
      {
        if ( *(_BYTE *)(a2 + 30) )
        {
          sub_804CB56(v8, &v6);
        }
        else if ( *(_BYTE *)(a2 + 28) )
        {
          v13 = strtold(v8, &v6);
        }
        else if ( *(_BYTE *)(a2 + 26) || *(_BYTE *)(a2 + 29) )
        {
          v2 = v8 < v9 && *v8 == 45;
          v7 = &v8[v2];
          if ( (unsigned __int8)sub_804C788((char **)&v7) > 0x2Fu )
          {
            v3 = *(_BYTE *)(a2 + 29) && byte_805E920[*v7];
            v6 = &v7[v3];
          }
        }
        else
        {
          v6 = v9;
        }
      }
      else
      {
        v6 = v9;
      }
      *v9 = v5;
      v9 = v6;
    }
  }
  v11 = sub_804D3E9(v10, (unsigned int)v8);
  v12 = sub_804D3E9((char *)v8, (unsigned int)v9);
  return sub_804D439(v11, v12);
}
// 80498F0: using guessed type double __cdecl strtold(_DWORD, _DWORD);

//----- (0804D6E4) --------------------------------------------------------
int __cdecl sub_804D6E4(int *a1)
{
  int result; // eax
  int v2; // [esp+1Ch] [ebp-Ch]

  v2 = dword_8065841;
  while ( 1 )
  {
    result = sub_804D4CF(a1, v2);
    if ( !v2 )
      break;
    v2 = *(_DWORD *)(v2 + 36);
    if ( !v2 )
    {
      result = (unsigned __int8)byte_806583F ^ 1;
      if ( byte_806583F == 1 )
        break;
      result = (unsigned __int8)byte_806583E ^ 1;
      if ( byte_806583E == 1 )
        break;
    }
  }
  return result;
}
// 806583E: using guessed type char byte_806583E;
// 806583F: using guessed type char byte_806583F;
// 8065841: using guessed type int dword_8065841;

//----- (0804D737) --------------------------------------------------------
int __cdecl sub_804D737(int a1)
{
  return !*(_DWORD *)(a1 + 16)
      && !*(_DWORD *)(a1 + 20)
      && *(_BYTE *)(a1 + 24) != 1
      && *(_BYTE *)(a1 + 25) != 1
      && (unsigned __int8)sub_804D49A((_BYTE *)a1) ^ 1
      && *(_BYTE *)(a1 + 30) != 1
      && *(_BYTE *)(a1 + 32) != 1
      && *(_BYTE *)(a1 + 27) != 1;
}

//----- (0804D7BA) --------------------------------------------------------
_BYTE *__cdecl sub_804D7BA(int a1, _BYTE *a2)
{
  _BYTE *v2; // eax
  _BYTE *v3; // eax
  _BYTE *v4; // eax
  _BYTE *v5; // eax
  _BYTE *v6; // eax
  _BYTE *v7; // eax
  _BYTE *v8; // eax
  _BYTE *v9; // eax
  _BYTE *v10; // eax
  _BYTE *v11; // eax
  _BYTE *v12; // eax
  _BYTE *result; // eax

  if ( *(_BYTE *)(a1 + 24) || *(_BYTE *)(a1 + 25) )
  {
    v2 = a2++;
    *v2 = 98;
  }
  if ( *(_UNKNOWN **)(a1 + 16) == &unk_806562D )
  {
    v3 = a2++;
    *v3 = 100;
  }
  if ( *(_DWORD *)(a1 + 20) )
  {
    v4 = a2++;
    *v4 = 102;
  }
  if ( *(_BYTE *)(a1 + 28) )
  {
    v5 = a2++;
    *v5 = 103;
  }
  if ( *(_BYTE *)(a1 + 29) )
  {
    v6 = a2++;
    *v6 = 104;
  }
  if ( *(_UNKNOWN **)(a1 + 16) == &unk_806552D )
  {
    v7 = a2++;
    *v7 = 105;
  }
  if ( *(_BYTE *)(a1 + 30) )
  {
    v8 = a2++;
    *v8 = 77;
  }
  if ( *(_BYTE *)(a1 + 26) )
  {
    v9 = a2++;
    *v9 = 110;
  }
  if ( *(_BYTE *)(a1 + 27) )
  {
    v10 = a2++;
    *v10 = 82;
  }
  if ( *(_BYTE *)(a1 + 31) )
  {
    v11 = a2++;
    *v11 = 114;
  }
  if ( *(_BYTE *)(a1 + 32) )
  {
    v12 = a2++;
    *v12 = 86;
  }
  result = a2;
  *a2 = 0;
  return result;
}

//----- (0804D8D0) --------------------------------------------------------
unsigned int __cdecl sub_804D8D0(int *a1, char a2)
{
  int v2; // eax
  int v3; // eax
  const char *v4; // eax
  const char *v5; // eax
  void *v6; // esi
  void *v7; // ebx
  char *v8; // eax
  bool v9; // al
  char *v10; // eax
  bool v11; // al
  bool v12; // al
  char *v13; // eax
  char *v14; // eax
  size_t v15; // eax
  int v16; // eax
  char *v17; // eax
  char *v18; // eax
  bool v20; // [esp+20h] [ebp-A8h]
  bool v21; // [esp+21h] [ebp-A7h]
  char v22; // [esp+23h] [ebp-A5h]
  int v23; // [esp+24h] [ebp-A4h]
  signed int v24; // [esp+28h] [ebp-A0h]
  unsigned int v25; // [esp+2Ch] [ebp-9Ch]
  unsigned int v26; // [esp+30h] [ebp-98h]
  int v27; // [esp+34h] [ebp-94h]
  int v28; // [esp+38h] [ebp-90h]
  int v29; // [esp+3Ch] [ebp-8Ch]
  int v30; // [esp+44h] [ebp-84h]
  int v31; // [esp+48h] [ebp-80h]
  int v32; // [esp+4Ch] [ebp-7Ch]
  int v33; // [esp+50h] [ebp-78h]
  int v34; // [esp+54h] [ebp-74h]
  int v35; // [esp+58h] [ebp-70h]
  int v36; // [esp+5Ch] [ebp-6Ch]
  int v37; // [esp+60h] [ebp-68h]
  int v38; // [esp+64h] [ebp-64h]
  int v39; // [esp+68h] [ebp-60h]
  char v40; // [esp+6Eh] [ebp-5Ah]
  __int16 v41; // [esp+83h] [ebp-45h]
  int s; // [esp+9Dh] [ebp-2Bh]
  unsigned int v43; // [esp+BCh] [ebp-Ch]

  v43 = __readgsdword(0x14u);
  v30 = *a1;
  v31 = a1[1];
  v32 = a1[2];
  v33 = a1[3];
  v34 = a1[4];
  v35 = a1[5];
  v36 = a1[6];
  v37 = a1[7];
  v38 = a1[8];
  v39 = a1[9];
  v24 = 1;
  v23 = dword_8065841;
  while ( v23 )
  {
    if ( *(_BYTE *)(v23 + 33) )
    {
      v25 = *(_DWORD *)v23;
      v27 = *(_DWORD *)(v23 + 8);
      if ( *(_DWORD *)v23 == -1 )
        v25 = 0;
      v2 = sub_80563F5(v25, (int)&v40);
      v41 = 43;
      v28 = stpcpy((char *)&v41 + 1, v2);
      v3 = sub_80563F5(v25 + 1, (int)&v40);
      s = 2124589;
      v29 = stpcpy((char *)&s + 3, v3);
      if ( *(_DWORD *)(v23 + 8) != -1 )
      {
        v4 = (const char *)sub_80563F5((unsigned int)(v27 + 1), (int)&v40);
        *(_WORD *)v28 = 11552;
        *(_BYTE *)(v28 + 2) = 0;
        strcpy((char *)(v28 + 2), v4);
        v5 = (const char *)sub_80563F5((unsigned int)(*(_DWORD *)(v23 + 12) == -1) + v27 + 1, (int)&v40);
        *(_WORD *)v29 = 44;
        strcpy((char *)(v29 + 1), v5);
      }
      v6 = sub_8058588(1, (int)&s);
      v7 = sub_8058588(0, (int)&v41);
      v8 = gettext("obsolescent key %s used; consider %s instead");
      error(0, 0, v8, v7, v6);
    }
    v9 = *(_DWORD *)v23 != -1 && *(_DWORD *)(v23 + 8) < *(_DWORD *)v23;
    v20 = v9;
    if ( v9 )
    {
      v10 = gettext("key %lu has zero width and will be ignored");
      error(0, 0, v10, v24);
    }
    v11 = (unsigned __int8)sub_804D49A((_BYTE *)v23) || *(_BYTE *)(v23 + 30);
    v21 = v11;
    v12 = !*(_DWORD *)(v23 + 8) && *(_DWORD *)(v23 + 12);
    if ( v20 != 1
      && a2 != 1
      && dword_80652B0 == 128
      && v12 != 1
      && (*(_BYTE *)(v23 + 24) != 1 && v21 != 1
       || *(_BYTE *)(v23 + 24) != 1 && *(_DWORD *)(v23 + 4)
       || *(_BYTE *)(v23 + 25) != 1 && *(_DWORD *)(v23 + 12)) )
    {
      v13 = gettext("leading blanks are significant in key %lu; consider also specifying 'b'");
      error(0, 0, v13, v24);
    }
    if ( a2 != 1 && (unsigned __int8)sub_804D49A((_BYTE *)v23) )
    {
      v26 = *(_DWORD *)v23 + 1;
      if ( *(_DWORD *)v23 == -1 )
        v26 = 1;
      if ( *(_DWORD *)(v23 + 8) == -1 || v26 < *(_DWORD *)(v23 + 8) + 1 )
      {
        v14 = gettext("key %lu is numeric and spans multiple fields");
        error(0, 0, v14, v24);
      }
    }
    if ( v34 && v34 == *(_DWORD *)(v23 + 16) )
      v34 = 0;
    if ( v35 && v35 == *(_DWORD *)(v23 + 20) )
      v35 = 0;
    LOBYTE(v36) = (unsigned __int8)(v36 & (*(_BYTE *)(v23 + 24) ^ 1)) != 0;
    BYTE1(v36) = (BYTE1(v36) & (*(_BYTE *)(v23 + 25) ^ 1)) != 0;
    BYTE2(v37) = (BYTE2(v37) & (*(_BYTE *)(v23 + 30) ^ 1)) != 0;
    BYTE2(v36) = (BYTE2(v36) & (*(_BYTE *)(v23 + 26) ^ 1)) != 0;
    LOBYTE(v37) = (unsigned __int8)(v37 & (*(_BYTE *)(v23 + 28) ^ 1)) != 0;
    BYTE1(v37) = (BYTE1(v37) & (*(_BYTE *)(v23 + 29) ^ 1)) != 0;
    HIBYTE(v36) = (HIBYTE(v36) & (*(_BYTE *)(v23 + 27) ^ 1)) != 0;
    LOBYTE(v38) = (unsigned __int8)(v38 & (*(_BYTE *)(v23 + 32) ^ 1)) != 0;
    HIBYTE(v37) = (HIBYTE(v37) & (*(_BYTE *)(v23 + 31) ^ 1)) != 0;
    v23 = *(_DWORD *)(v23 + 36);
    ++v24;
  }
  if ( (unsigned __int8)sub_804D737((int)&v30) ^ 1 || HIBYTE(v37) && (byte_806583E || byte_806583F) && dword_8065841 )
  {
    v22 = HIBYTE(v37);
    if ( byte_806583E != 1 && byte_806583F != 1 )
      HIBYTE(v37) = 0;
    sub_804D7BA((int)&v30, &s);
    v15 = strlen((const char *)&s);
    v16 = sub_804A1CE(v15);
    v17 = ngettext("option '-%s' is ignored", "options '-%s' are ignored", v16);
    error(0, 0, v17, &s);
    HIBYTE(v37) = v22;
  }
  if ( HIBYTE(v37) && byte_806583E != 1 && byte_806583F != 1 && dword_8065841 )
  {
    v18 = gettext("option '-r' only applies to last-resort comparison");
    error(0, 0, v18);
  }
  return __readgsdword(0x14u) ^ v43;
}
// 8049930: using guessed type int __cdecl stpcpy(_DWORD, _DWORD);
// 80652B0: using guessed type int dword_80652B0;
// 806583E: using guessed type char byte_806583E;
// 806583F: using guessed type char byte_806583F;
// 8065841: using guessed type int dword_8065841;

//----- (0804E058) --------------------------------------------------------
int __cdecl sub_804E058(unsigned __int8 **a1, unsigned __int8 **a2)
{
  unsigned __int8 *v2; // eax
  unsigned __int8 *v3; // eax
  int v4; // eax
  char *v5; // ebx
  unsigned __int8 v6; // al
  size_t v7; // eax
  unsigned __int8 *v8; // ebx
  unsigned __int8 v9; // al
  int v10; // ebx
  unsigned __int8 v11; // al
  int v12; // ebx
  unsigned __int8 v13; // al
  unsigned __int8 v14; // al
  int v15; // ebx
  unsigned __int8 v16; // al
  unsigned __int8 *v17; // eax
  unsigned __int8 v18; // al
  int v19; // ebx
  unsigned __int8 *v20; // eax
  unsigned __int8 v21; // al
  unsigned __int8 v22; // al
  size_t v23; // eax
  signed int v24; // eax
  int result; // eax
  char v26; // [esp+26h] [ebp-FF2h]
  unsigned __int8 v27; // [esp+27h] [ebp-FF1h]
  int v28; // [esp+28h] [ebp-FF0h]
  unsigned __int8 *s1; // [esp+2Ch] [ebp-FECh]
  unsigned __int8 *s2; // [esp+30h] [ebp-FE8h]
  unsigned __int8 *v31; // [esp+34h] [ebp-FE4h]
  unsigned __int8 *v32; // [esp+34h] [ebp-FE4h]
  unsigned __int8 *v33; // [esp+38h] [ebp-FE0h]
  unsigned int v34; // [esp+38h] [ebp-FE0h]
  int v35; // [esp+3Ch] [ebp-FDCh]
  char *v36; // [esp+40h] [ebp-FD8h]
  unsigned __int8 *v37; // [esp+44h] [ebp-FD4h]
  int v38; // [esp+48h] [ebp-FD0h]
  size_t v39; // [esp+4Ch] [ebp-FCCh]
  char *ptr; // [esp+50h] [ebp-FC8h]
  unsigned int v41; // [esp+54h] [ebp-FC4h]
  size_t v42; // [esp+54h] [ebp-FC4h]
  int v43; // [esp+58h] [ebp-FC0h]
  int v44; // [esp+5Ch] [ebp-FBCh]
  unsigned int v45; // [esp+60h] [ebp-FB8h]
  size_t n; // [esp+64h] [ebp-FB4h]
  unsigned int size; // [esp+68h] [ebp-FB0h]
  char v48; // [esp+6Ch] [ebp-FACh]
  unsigned int v49; // [esp+100Ch] [ebp-Ch]

  v49 = __readgsdword(0x14u);
  v28 = dword_8065841;
  s1 = a1[2];
  s2 = a2[2];
  v31 = a1[3];
  v33 = a2[3];
  while ( 1 )
  {
    v43 = *(_DWORD *)(v28 + 20);
    v44 = *(_DWORD *)(v28 + 16);
    v2 = s1;
    if ( v31 >= s1 )
      v2 = v31;
    v32 = v2;
    v3 = s2;
    if ( v33 >= s2 )
      v3 = v33;
    v34 = (unsigned int)v3;
    v45 = v32 - s1;
    n = v3 - s2;
    if ( byte_8065415
      || (unsigned __int8)sub_804D49A((_BYTE *)v28)
      || *(_BYTE *)(v28 + 30)
      || *(_BYTE *)(v28 + 27)
      || *(_BYTE *)(v28 + 32) )
    {
      if ( v44 || v43 )
      {
        size = v45 + n + 2;
        if ( size > 0xFA0 )
        {
          ptr = (char *)sub_805A7FD(size);
          v36 = ptr;
        }
        else
        {
          v36 = &v48;
          ptr = 0;
        }
        v37 = (unsigned __int8 *)&v36[v45 + 1];
        v41 = 0;
        v38 = 0;
        while ( v41 < v45 )
        {
          if ( !v44 || *(_BYTE *)((unsigned __int8)sub_804A17D(s1[v41]) + v44) ^ 1 )
          {
            v4 = v38++;
            v5 = &v36[v4];
            if ( v43 )
              v6 = *(_BYTE *)((unsigned __int8)sub_804A17D(s1[v41]) + v43);
            else
              v6 = s1[v41];
            *v5 = v6;
          }
          ++v41;
        }
        v36[v38] = 0;
        v42 = 0;
        v39 = 0;
        while ( v42 < n )
        {
          if ( !v44 || *(_BYTE *)((unsigned __int8)sub_804A17D(s2[v42]) + v44) ^ 1 )
          {
            v7 = v39++;
            v8 = &v37[v7];
            if ( v43 )
              v9 = *(_BYTE *)((unsigned __int8)sub_804A17D(s2[v42]) + v43);
            else
              v9 = s2[v42];
            *v8 = v9;
          }
          ++v42;
        }
        v37[v39] = 0;
      }
      else
      {
        v36 = (char *)s1;
        v38 = v32 - s1;
        v26 = *v32;
        *v32 = 0;
        v37 = s2;
        v39 = n;
        v27 = s2[n];
        s2[n] = 0;
      }
      if ( *(_BYTE *)(v28 + 26) )
      {
        v35 = sub_804C95A((unsigned __int8 *)v36, v37);
      }
      else if ( *(_BYTE *)(v28 + 28) )
      {
        v35 = sub_804CA55((int)v36, (int)v37);
      }
      else if ( *(_BYTE *)(v28 + 29) )
      {
        v35 = sub_804C8B4((unsigned __int8 *)v36, v37);
      }
      else if ( *(_BYTE *)(v28 + 30) )
      {
        v10 = sub_804CB56((unsigned __int8 *)v36, 0);
        v35 = v10 - sub_804CB56(v37, 0);
      }
      else if ( *(_BYTE *)(v28 + 27) )
      {
        v35 = sub_804CE2C((int)v36, v38, (int)v37, v39);
      }
      else if ( *(_BYTE *)(v28 + 32) )
      {
        v35 = sub_8054AA0(v36, (char *)v37);
      }
      else if ( v38 )
      {
        if ( v39 )
          v35 = sub_805AAB7(v36, v38 + 1, v37, v39 + 1);
        else
          v35 = 1;
      }
      else
      {
        v35 = -(v39 != 0);
      }
      if ( v44 || v43 )
      {
        free(ptr);
      }
      else
      {
        v36[v38] = v26;
        v37[v39] = v27;
      }
      goto LABEL_102;
    }
    if ( v44 )
    {
      if ( v43 )
      {
        while ( 1 )
        {
          while ( s1 < v32 && *(_BYTE *)((unsigned __int8)sub_804A17D(*s1) + v44) )
            ++s1;
          while ( (unsigned int)s2 < v34 && *(_BYTE *)((unsigned __int8)sub_804A17D(*s2) + v44) )
            ++s2;
          if ( s1 >= v32 || (unsigned int)s2 >= v34 )
            break;
          v11 = sub_804A17D(*s1);
          v12 = (unsigned __int8)sub_804A17D(*(_BYTE *)(v11 + v43));
          v13 = sub_804A17D(*s2);
          v14 = sub_804A17D(*(_BYTE *)(v13 + v43));
          v35 = v12 - v14;
          if ( v12 != v14 )
            goto LABEL_120;
          ++s1;
          ++s2;
        }
        v35 = (s1 < v32) - ((unsigned int)s2 < v34);
      }
      else
      {
        while ( 1 )
        {
          while ( s1 < v32 && *(_BYTE *)((unsigned __int8)sub_804A17D(*s1) + v44) )
            ++s1;
          while ( (unsigned int)s2 < v34 && *(_BYTE *)((unsigned __int8)sub_804A17D(*s2) + v44) )
            ++s2;
          if ( s1 >= v32 || (unsigned int)s2 >= v34 )
            break;
          v15 = (unsigned __int8)sub_804A17D(*s1);
          v16 = sub_804A17D(*s2);
          v35 = v15 - v16;
          if ( v15 != v16 )
            goto LABEL_120;
          ++s1;
          ++s2;
        }
        v35 = (s1 < v32) - ((unsigned int)s2 < v34);
      }
      goto LABEL_102;
    }
    if ( v32 == s1 )
    {
      v35 = -(n != 0);
      goto LABEL_102;
    }
    if ( !n )
      break;
    if ( v43 )
    {
      while ( s1 < v32 && (unsigned int)s2 < v34 )
      {
        v17 = s1++;
        v18 = sub_804A17D(*v17);
        v19 = (unsigned __int8)sub_804A17D(*(_BYTE *)(v18 + v43));
        v20 = s2++;
        v21 = sub_804A17D(*v20);
        v22 = sub_804A17D(*(_BYTE *)(v21 + v43));
        v35 = v19 - v22;
        if ( v19 != v22 )
          goto LABEL_120;
      }
    }
    else
    {
      v23 = v32 - s1;
      if ( n <= v45 )
        v23 = n;
      v35 = memcmp(s1, s2, v23);
      if ( v35 )
        goto LABEL_120;
    }
    if ( v45 < n )
      v24 = -1;
    else
      v24 = v45 != n;
    v35 = v24;
LABEL_102:
    if ( v35 )
      goto LABEL_120;
    v28 = *(_DWORD *)(v28 + 36);
    if ( !v28 )
      return 0;
    if ( *(_DWORD *)(v28 + 8) == -1 )
    {
      v31 = &a1[1][(_DWORD)*a1 - 1];
      v33 = &a2[1][(_DWORD)*a2 - 1];
    }
    else
    {
      v31 = sub_804C266((int)a1, v28);
      v33 = sub_804C266((int)a2, v28);
    }
    if ( *(_DWORD *)v28 == -1 )
    {
      s1 = *a1;
      s2 = *a2;
      if ( *(_BYTE *)(v28 + 24) )
      {
        while ( s1 < v31 && byte_806542D[(unsigned __int8)sub_804A17D(*s1)] )
          ++s1;
        while ( s2 < v33 && byte_806542D[(unsigned __int8)sub_804A17D(*s2)] )
          ++s2;
      }
    }
    else
    {
      s1 = (unsigned __int8 *)sub_804C11D((int)a1, (int *)v28);
      s2 = (unsigned __int8 *)sub_804C11D((int)a2, (int *)v28);
    }
  }
  v35 = 1;
LABEL_120:
  if ( *(_BYTE *)(v28 + 31) )
    result = -v35;
  else
    result = v35;
  return result;
}
// 8065415: using guessed type char byte_8065415;
// 8065841: using guessed type int dword_8065841;

//----- (0804EC4A) --------------------------------------------------------
int __cdecl sub_804EC4A(int a1, int a2)
{
  int result; // eax
  size_t v3; // eax
  signed int v4; // eax
  int v5; // [esp+14h] [ebp-14h]
  int v6; // [esp+14h] [ebp-14h]
  unsigned int v7; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]

  if ( dword_8065841 )
  {
    v5 = sub_804E058((unsigned __int8 **)a1, (unsigned __int8 **)a2);
    if ( v5 || byte_806583F || byte_806583E )
      return v5;
  }
  v7 = *(_DWORD *)(a1 + 4) - 1;
  n = *(_DWORD *)(a2 + 4) - 1;
  if ( *(_DWORD *)(a1 + 4) == 1 )
  {
    v6 = -(*(_DWORD *)(a2 + 4) != 1);
  }
  else if ( *(_DWORD *)(a2 + 4) == 1 )
  {
    v6 = 1;
  }
  else if ( byte_8065415 )
  {
    v6 = sub_805AAB7(*(void **)a1, *(_DWORD *)(a1 + 4), *(void **)a2, *(_DWORD *)(a2 + 4));
  }
  else
  {
    v3 = *(_DWORD *)(a1 + 4) - 1;
    if ( n <= v7 )
      v3 = *(_DWORD *)(a2 + 4) - 1;
    v6 = memcmp(*(const void **)a1, *(const void **)a2, v3);
    if ( !v6 )
    {
      if ( v7 < n )
        v4 = -1;
      else
        v4 = v7 != n;
      v6 = v4;
    }
  }
  if ( byte_806583D )
    result = -v6;
  else
    result = v6;
  return result;
}
// 8065415: using guessed type char byte_8065415;
// 806583D: using guessed type char byte_806583D;
// 806583E: using guessed type char byte_806583E;
// 806583F: using guessed type char byte_806583F;
// 8065841: using guessed type int dword_8065841;

//----- (0804ED79) --------------------------------------------------------
int __cdecl sub_804ED79(int a1, FILE *stream, int a3)
{
  char *v3; // eax
  char *v4; // eax
  int result; // eax
  char *v6; // eax
  char v7; // [esp+1Fh] [ebp-19h]
  char *v8; // [esp+20h] [ebp-18h]
  char *ptr; // [esp+24h] [ebp-14h]
  size_t n; // [esp+28h] [ebp-10h]
  unsigned int v11; // [esp+2Ch] [ebp-Ch]

  ptr = *(char **)a1;
  n = *(_DWORD *)(a1 + 4);
  v11 = *(_DWORD *)a1 + n;
  if ( a3 || !byte_8065849 )
  {
    *(_BYTE *)(v11 - 1) = byte_806522C;
    if ( fwrite_unlocked(ptr, 1u, n, stream) != n )
    {
      v6 = gettext("write failed");
      sub_804A4B6((int)v6, (char *)a3);
    }
    result = v11 - 1;
    *(_BYTE *)(v11 - 1) = 0;
  }
  else
  {
    v8 = *(char **)a1;
    while ( (unsigned int)v8 < v11 )
    {
      v3 = v8++;
      v7 = *v3;
      if ( *v3 == 9 )
      {
        v7 = 62;
      }
      else if ( v8 == (char *)v11 )
      {
        v7 = 10;
      }
      if ( fputc_unlocked(v7, stream) == -1 )
      {
        v4 = gettext("write failed");
        sub_804A4B6((int)v4, 0);
      }
    }
    result = sub_804D6E4((int *)a1);
  }
  return result;
}
// 806522C: using guessed type char byte_806522C;
// 8065849: using guessed type char byte_8065849;

//----- (0804EE82) --------------------------------------------------------
int __cdecl sub_804EE82(char *a1, char a2)
{
  size_t v2; // eax
  int v3; // eax
  int v4; // ebx
  int v5; // esi
  char *v6; // eax
  char *v7; // eax
  unsigned __int8 v9; // [esp+2Eh] [ebp-8Ah]
  _BYTE v10[5]; // [esp+2Fh] [ebp-89h]
  unsigned int v11; // [esp+34h] [ebp-84h]
  FILE *stream; // [esp+38h] [ebp-80h]
  int v13; // [esp+3Ch] [ebp-7Ch]
  unsigned int v14; // [esp+40h] [ebp-78h]
  __int64 v15; // [esp+48h] [ebp-70h]
  void *ptr; // [esp+58h] [ebp-60h]
  int v17; // [esp+5Ch] [ebp-5Ch]
  char *v18; // [esp+60h] [ebp-58h]
  char *v19; // [esp+64h] [ebp-54h]
  void *v20; // [esp+68h] [ebp-50h]
  unsigned int v21; // [esp+70h] [ebp-48h]
  char v22; // [esp+87h] [ebp-31h]
  unsigned int v23; // [esp+9Ch] [ebp-1Ch]

  v23 = __readgsdword(0x14u);
  stream = sub_804AE6E(a1, "r");
  v10[4] = 0;
  v15 = 0LL;
  v13 = dword_8065841;
  *(_DWORD *)v10 = byte_806583F == 0;
  v10[0] &= 1u;
  v9 = 1;
  v2 = dword_80652AC;
  if ( size >= dword_80652AC )
    v2 = size;
  sub_804C07C((int)&v20, 16, v2);
  ptr = 0;
  while ( (unsigned __int8)sub_804C3CC((int)&v20, stream, (int)a1) )
  {
    v11 = sub_804C102(&v20);
    v14 = -16 * v21 + v11;
    if ( *(_DWORD *)&v10[1] && v10[0] <= sub_804EC4A((int)&ptr, v11 - 16) )
    {
LABEL_6:
      if ( a2 == 99 )
      {
        v3 = sub_804C102(&v20);
        v4 = sub_80563F5(((signed int)(v3 - (v11 - 16)) >> 4) + v15, (int)&v22);
        v5 = dword_806599D;
        v6 = gettext("%s: %s:%s: disorder: ");
        fprintf(stderr, v6, v5, a1, v4);
        v7 = gettext("standard error");
        sub_804ED79(v11 - 16, stderr, (int)v7);
      }
      v9 = 0;
      break;
    }
    while ( 1 )
    {
      v11 -= 16;
      if ( v11 <= v14 )
        break;
      if ( v10[0] <= sub_804EC4A(v11, v11 - 16) )
        goto LABEL_6;
    }
    v15 += v21;
    if ( *(_DWORD *)(v11 + 4) > *(_DWORD *)&v10[1] )
    {
      while ( 1 )
      {
        *(_DWORD *)&v10[1] *= 2;
        if ( !*(_DWORD *)&v10[1] )
          break;
        if ( *(_DWORD *)(v11 + 4) <= *(_DWORD *)&v10[1] )
          goto LABEL_16;
      }
      *(_DWORD *)&v10[1] = *(_DWORD *)(v11 + 4);
LABEL_16:
      free(ptr);
      ptr = sub_805A7FD(*(size_t *)&v10[1]);
    }
    memcpy(ptr, *(const void **)v11, *(_DWORD *)(v11 + 4));
    v17 = *(_DWORD *)(v11 + 4);
    if ( v13 )
    {
      v18 = (char *)ptr + *(_DWORD *)(v11 + 8) - *(_DWORD *)v11;
      v19 = (char *)ptr + *(_DWORD *)(v11 + 12) - *(_DWORD *)v11;
    }
  }
  sub_804AEAF(stream, (int)a1);
  free(v20);
  free(ptr);
  return v9;
}
// 806583F: using guessed type char byte_806583F;
// 8065841: using guessed type int dword_8065841;
// 806599D: using guessed type int dword_806599D;

//----- (0804F1F4) --------------------------------------------------------
unsigned int __cdecl sub_804F1F4(int a1, unsigned int a2, void **a3)
{
  FILE *v3; // eax
  unsigned int i; // [esp+18h] [ebp-10h]
  _DWORD *v6; // [esp+1Ch] [ebp-Ch]

  *a3 = sub_805A6F0(a2, 4u);
  v6 = *a3;
  for ( i = 0; i < a2; ++i )
  {
    v3 = *(_DWORD *)(8 * i + a1 + 4) && *(_BYTE *)(*(_DWORD *)(8 * i + a1 + 4) + 8) ? sub_804B256(*(_DWORD *)(8 * i + a1 + 4)) : sub_804AD32(*(char **)(8 * i + a1), "r");
    v6[i] = v3;
    if ( !v6[i] )
      break;
  }
  return i;
}

//----- (0804F2D8) --------------------------------------------------------
void __cdecl sub_804F2D8(int a1, int a2, int a3, FILE *stream, int a5, void *a6)
{
  size_t v6; // edx
  int v7; // eax
  _DWORD *v8; // ecx
  _DWORD *v9; // eax
  int v10; // edx
  unsigned int v11; // ST48_4
  int v12; // eax
  _DWORD *v13; // ecx
  _DWORD *v14; // eax
  int v15; // edx
  _DWORD *v16; // eax
  _DWORD *v17; // edx
  void **v18; // [esp+14h] [ebp-64h]
  size_t size; // [esp+18h] [ebp-60h]
  unsigned int v20; // [esp+1Ch] [ebp-5Ch]
  unsigned int j; // [esp+1Ch] [ebp-5Ch]
  unsigned int k; // [esp+1Ch] [ebp-5Ch]
  unsigned int l; // [esp+1Ch] [ebp-5Ch]
  unsigned int m; // [esp+1Ch] [ebp-5Ch]
  unsigned int ii; // [esp+1Ch] [ebp-5Ch]
  unsigned int i; // [esp+20h] [ebp-58h]
  unsigned int jj; // [esp+20h] [ebp-58h]
  unsigned int v28; // [esp+24h] [ebp-54h]
  unsigned int v29; // [esp+28h] [ebp-50h]
  unsigned int v30; // [esp+2Ch] [ebp-4Ch]
  _DWORD *v31; // [esp+30h] [ebp-48h]
  _DWORD *v32; // [esp+34h] [ebp-44h]
  _DWORD *v33; // [esp+38h] [ebp-40h]
  unsigned int *v34; // [esp+3Ch] [ebp-3Ch]
  int v35; // [esp+40h] [ebp-38h]
  unsigned int v36; // [esp+4Ch] [ebp-2Ch]
  signed __int64 v37; // [esp+54h] [ebp-24h]
  unsigned int v38; // [esp+5Ch] [ebp-1Ch]
  void *ptr; // [esp+60h] [ebp-18h]
  size_t n; // [esp+64h] [ebp-14h]
  char *v41; // [esp+68h] [ebp-10h]
  char *v42; // [esp+6Ch] [ebp-Ch]

  v31 = sub_805A6F0(a3, 0x1Cu);
  v18 = 0;
  size = 0;
  v32 = sub_805A6F0(a3, 4u);
  v33 = sub_805A6F0(a3, 4u);
  v34 = (unsigned int *)sub_805A6F0(a3, 4u);
  v35 = dword_8065841;
  ptr = 0;
  v20 = 0;
  while ( v20 < a3 )
  {
    v6 = ::size / a3;
    if ( ::size / a3 < dword_80652AC )
      v6 = dword_80652AC;
    sub_804C07C((int)&v31[7 * v20], 16, v6);
    if ( (unsigned __int8)sub_804C3CC((int)&v31[7 * v20], *((FILE **)a6 + v20), *(_DWORD *)(8 * v20 + a1)) )
    {
      v7 = sub_804C102(&v31[7 * v20]);
      v32[v20] = v7 - 16;
      v33[v20] = -16 * v31[7 * v20 + 2] + v7;
      ++v20;
    }
    else
    {
      sub_804AEAF(*((FILE **)a6 + v20), *(_DWORD *)(8 * v20 + a1));
      if ( v20 < a2 )
      {
        --a2;
        sub_804B471(*(char **)(8 * v20 + a1));
      }
      free((void *)v31[7 * v20]);
      --a3;
      for ( i = v20; i < a3; ++i )
      {
        v8 = (_DWORD *)(8 * i + a1);
        v9 = (_DWORD *)(8 * (i + 1) + a1);
        v10 = v9[1];
        *v8 = *v9;
        v8[1] = v10;
        *((_DWORD *)a6 + i) = *((_DWORD *)a6 + i + 1);
      }
    }
  }
  for ( j = 0; j < a3; ++j )
    v34[j] = j;
  for ( k = 1; k < a3; ++k )
  {
    if ( sub_804EC4A(v32[v34[k + 0x3FFFFFFF]], v32[v34[k]]) > 0 )
    {
      v11 = v34[k + 0x3FFFFFFF];
      v34[k + 0x3FFFFFFF] = v34[k];
      v34[k] = v11;
      k = 0;
    }
  }
  while ( a3 )
  {
    v36 = v32[*v34];
    if ( byte_806583F )
    {
      if ( v18 && sub_804EC4A((int)v18, v36) )
      {
        v18 = 0;
        sub_804ED79((int)&ptr, stream, a5);
      }
      if ( !v18 )
      {
        v18 = &ptr;
        if ( *(_DWORD *)(v36 + 4) > size )
        {
          while ( size )
          {
            size *= 2;
            if ( size >= *(_DWORD *)(v36 + 4) )
              goto LABEL_30;
          }
          size = *(_DWORD *)(v36 + 4);
LABEL_30:
          free(ptr);
          ptr = sub_805A7FD(size);
        }
        n = *(_DWORD *)(v36 + 4);
        memcpy(ptr, *(const void **)v36, n);
        if ( v35 )
        {
          v41 = (char *)ptr + *(_DWORD *)(v36 + 8) - *(_DWORD *)v36;
          v42 = (char *)ptr + *(_DWORD *)(v36 + 12) - *(_DWORD *)v36;
        }
      }
    }
    else
    {
      sub_804ED79(v36, stream, a5);
    }
    if ( v33[*v34] >= v36 )
    {
      if ( (unsigned __int8)sub_804C3CC((int)&v31[7 * *v34], *((FILE **)a6 + *v34), *(_DWORD *)(8 * *v34 + a1)) )
      {
        v12 = sub_804C102(&v31[7 * *v34]);
        v32[*v34] = v12 - 16;
        v33[*v34] = -16 * v31[7 * *v34 + 2] + v12;
        goto LABEL_52;
      }
      for ( l = 1; l < a3; ++l )
      {
        if ( v34[l] > *v34 )
          --v34[l];
      }
      --a3;
      sub_804AEAF(*((FILE **)a6 + *v34), *(_DWORD *)(8 * *v34 + a1));
      if ( *v34 < a2 )
      {
        --a2;
        sub_804B471(*(char **)(8 * *v34 + a1));
      }
      free((void *)v31[7 * *v34]);
      for ( m = *v34; m < a3; ++m )
      {
        *((_DWORD *)a6 + m) = *((_DWORD *)a6 + m + 1);
        v13 = (_DWORD *)(8 * m + a1);
        v14 = (_DWORD *)(8 * (m + 1) + a1);
        v15 = v14[1];
        *v13 = *v14;
        v13[1] = v15;
        v16 = &v31[7 * m];
        v17 = &v31[7 * (m + 1)];
        *v16 = *v17;
        v16[1] = v17[1];
        v16[2] = v17[2];
        v16[3] = v17[3];
        v16[4] = v17[4];
        v16[5] = v17[5];
        v16[6] = v17[6];
        v32[m] = v32[m + 1];
        v33[m] = v33[m + 1];
      }
      for ( ii = 0; ii < a3; ++ii )
        v34[ii] = v34[ii + 1];
    }
    else
    {
      v32[*v34] = v36 - 16;
LABEL_52:
      v28 = 1;
      v29 = a3;
      v30 = 1;
      LODWORD(v37) = *v34;
      while ( v28 < v29 )
      {
        HIDWORD(v37) = sub_804EC4A(v32[(_DWORD)v37], v32[v34[v30]]);
        if ( v37 >= v34[v30] )
          v28 = v30 + 1;
        else
          v29 = v30;
        v30 = (v28 + v29) >> 1;
      }
      v38 = v28 - 1;
      for ( jj = 0; jj < v38; ++jj )
        v34[jj] = v34[jj + 1];
      v34[v38] = v37;
    }
  }
  if ( byte_806583F && v18 )
  {
    sub_804ED79((int)&ptr, stream, a5);
    free(ptr);
  }
  sub_804AEAF(stream, a5);
  free(a6);
  free(v31);
  free(v34);
  free(v33);
  free(v32);
}
// 806583F: using guessed type char byte_806583F;
// 8065841: using guessed type int dword_8065841;

//----- (0804FBFF) --------------------------------------------------------
int __cdecl sub_804FBFF(int a1, int a2, int a3, FILE *stream, int a5)
{
  char *v5; // ebx
  char *v6; // eax
  void *v8; // [esp+28h] [ebp-10h]
  int v9; // [esp+2Ch] [ebp-Ch]

  v9 = sub_804F1F4(a1, a3, &v8);
  if ( v9 < (unsigned int)a3 && (unsigned int)v9 <= 1 )
  {
    v5 = *(char **)(8 * v9 + a1);
    v6 = gettext("open failed");
    sub_804A4B6((int)v6, v5);
  }
  sub_804F2D8(a1, a2, v9, stream, a5, v8);
  return v9;
}

//----- (0804FC90) --------------------------------------------------------
_DWORD *__cdecl sub_804FC90(_DWORD *a1, unsigned int a2, _DWORD *a3)
{
  _DWORD *result; // eax
  unsigned int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]
  _DWORD *v6; // [esp+1Ch] [ebp-Ch]

  v4 = a2 >> 1;
  v5 = a2 - (a2 >> 1);
  v6 = &a1[-4 * (a2 >> 1)];
  do
  {
    while ( sub_804EC4A((int)(a3 - 4), (int)(v6 - 4)) <= 0 )
    {
      a1 -= 4;
      a3 -= 4;
      result = a1;
      *a1 = *a3;
      a1[1] = a3[1];
      a1[2] = a3[2];
      a1[3] = a3[3];
      if ( !--v4 )
        return result;
    }
    a1 -= 4;
    v6 -= 4;
    *a1 = *v6;
    a1[1] = v6[1];
    a1[2] = v6[2];
    a1[3] = v6[3];
    --v5;
  }
  while ( v5 );
  do
  {
    a1 -= 4;
    a3 -= 4;
    result = a1;
    *a1 = *a3;
    a1[1] = a3[1];
    a1[2] = a3[2];
    a1[3] = a3[3];
    --v4;
  }
  while ( v4 );
  return result;
}

//----- (0804FD6E) --------------------------------------------------------
int __cdecl sub_804FD6E(_DWORD *a1, unsigned int a2, _DWORD *a3, unsigned __int8 a4)
{
  int result; // eax
  _DWORD *v5; // eax
  _DWORD *v6; // edx
  int v7; // ecx
  _DWORD *v8; // edx
  _DWORD *v9; // edx
  _DWORD *v10; // edx
  int v11; // eax
  _DWORD *v12; // edx
  int v13; // [esp+2Ch] [ebp-1Ch]
  unsigned int v14; // [esp+30h] [ebp-18h]

  if ( a2 == 2 )
  {
    result = sub_804EC4A((int)(a1 - 4), (int)(a1 - 8)) > 0;
    v13 = result;
    if ( a4 )
    {
      v5 = a3 - 4;
      v6 = &a1[4 * ~v13];
      *v5 = *v6;
      v5[1] = v6[1];
      v5[2] = v6[2];
      v5[3] = v6[3];
      result = (int)(a3 - 8);
      v7 = 4 * (v13 - 2);
      *(_DWORD *)result = a1[v7];
      *(_DWORD *)(result + 4) = a1[v7 + 1];
      *(_DWORD *)(result + 8) = a1[v7 + 2];
      *(_DWORD *)(result + 12) = a1[v7 + 3];
    }
    else if ( result )
    {
      v8 = a3 - 4;
      *v8 = *(a1 - 4);
      v8[1] = *(a1 - 3);
      v8[2] = *(a1 - 2);
      v8[3] = *(a1 - 1);
      v9 = a1 - 4;
      *v9 = *(a1 - 8);
      v9[1] = *(a1 - 7);
      v9[2] = *(a1 - 6);
      v9[3] = *(a1 - 5);
      v10 = a1 - 8;
      *v10 = *(a3 - 4);
      v10[1] = *(a3 - 3);
      v10[2] = *(a3 - 2);
      result = *(a3 - 1);
      v10[3] = result;
    }
  }
  else
  {
    v14 = a2 >> 1;
    if ( a4 )
      v11 = -4 * v14;
    else
      v11 = 0;
    sub_804FD6E(&a1[-4 * (a2 >> 1)], a2 - (a2 >> 1), &a3[v11], a4);
    if ( v14 <= 1 )
    {
      if ( a4 != 1 )
      {
        v12 = a3 - 4;
        *v12 = *(a1 - 4);
        v12[1] = *(a1 - 3);
        v12[2] = *(a1 - 2);
        v12[3] = *(a1 - 1);
      }
    }
    else
    {
      sub_804FD6E(a1, v14, a3, a4 == 0);
    }
    if ( a4 )
      result = (int)sub_804FC90(a3, a2, a1);
    else
      result = (int)sub_804FC90(a1, a2, a3);
  }
  return result;
}

//----- (0804FF7B) --------------------------------------------------------
pthread_mutex_t *__cdecl sub_804FF7B(unsigned int a1, int a2, int a3)
{
  pthread_mutex_t *v3; // eax
  pthread_mutex_t *v4; // ST28_4
  pthread_mutex_t *v5; // ST2C_4

  v3 = (pthread_mutex_t *)sub_805A7FD(144 * a1);
  v4 = v3;
  v5 = v3;
  v3->__kind = 0;
  v5->__owner = v5->__kind;
  v5->__count = v5->__owner;
  v5->__lock = v5->__count;
  v3->__nusers = 0;
  v3[1].__lock = a2;
  v3->__spins = v3[1].__lock;
  v3[1].__count = 0;
  v3[1].__nusers = 0;
  v3[1].__size[20] = 0;
  pthread_mutex_init(v3 + 2, 0);
  sub_8050095(v5, v5 + 3, a3, a1, a2, 0);
  return v4;
}

//----- (08050095) --------------------------------------------------------
int __cdecl sub_8050095(_DWORD *a1, pthread_mutex_t *a2, int a3, unsigned int a4, int a5, char a6)
{
  unsigned int v6; // eax
  int v7; // eax
  int v8; // ST40_4
  pthread_mutex_t *v9; // eax
  int v10; // eax
  int v12; // [esp+30h] [ebp-28h]
  int v13; // [esp+34h] [ebp-24h]
  int v14; // [esp+38h] [ebp-20h]
  int v15; // [esp+3Ch] [ebp-1Ch]
  pthread_mutex_t *v16; // [esp+44h] [ebp-14h]
  int v17; // [esp+64h] [ebp+Ch]

  if ( a6 )
    v6 = a1[5];
  else
    v6 = a1[6];
  v12 = v6 >> 1;
  v13 = v6 - (v6 >> 1);
  v14 = -16 * a5 + a3;
  v15 = -16 * (v6 >> 1) + v14;
  if ( a6 )
    v7 = (int)(a1 + 2);
  else
    v7 = (int)(a1 + 3);
  v8 = v7;
  v9 = a2;
  v17 = (int)&a2[3];
  v16 = v9;
  v9->__owner = v14;
  v16->__lock = v16->__owner;
  v9->__kind = v15;
  v16->__count = v16->__kind;
  v9->__nusers = v8;
  v9->__spins = v12;
  v9[1].__lock = v13;
  v9[1].__count = (unsigned int)a1;
  v9[1].__nusers = a1[10] + 1;
  v9[1].__size[20] = 0;
  pthread_mutex_init(v9 + 2, 0);
  if ( a4 <= 1 )
  {
    v16[1].__owner = 0;
    v16[1].__kind = 0;
  }
  else
  {
    v16[1].__owner = v17;
    v10 = sub_8050095(v16, v17, v14, a4 >> 1, a5, 1);
    v16[1].__kind = v10;
    v17 = sub_8050095(v16, v10, v15, a4 - (a4 >> 1), a5, 0);
  }
  return v17;
}

//----- (0805023D) --------------------------------------------------------
_BOOL4 __cdecl sub_805023D(_DWORD *a1, _DWORD *a2)
{
  _BOOL4 result; // eax

  if ( a1[10] == a2[10] )
    result = a1[5] + a1[6] < (unsigned int)(a2[5] + a2[6]);
  else
    result = a1[10] < a2[10];
  return result;
}

//----- (0805029C) --------------------------------------------------------
int __cdecl sub_805029C(pthread_mutex_t *a1)
{
  return pthread_mutex_lock(a1 + 2);
}

//----- (080502B2) --------------------------------------------------------
int __cdecl sub_80502B2(pthread_mutex_t *a1)
{
  return pthread_mutex_unlock(a1 + 2);
}

//----- (080502F9) --------------------------------------------------------
int __cdecl sub_80502F9(int a1, int a2)
{
  *(_DWORD *)a1 = sub_8055FA6((int (*)())sub_805023D, 2 * a2);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 4), 0);
  return pthread_cond_init((pthread_cond_t *)(a1 + 28), 0);
}

//----- (08050347) --------------------------------------------------------
int __cdecl sub_8050347(int a1, int a2)
{
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 4));
  sub_8056045(*(_DWORD *)a1, a2);
  *(_BYTE *)(a2 + 44) = 1;
  pthread_cond_signal((pthread_cond_t *)(a1 + 28));
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 4));
}

//----- (08050394) --------------------------------------------------------
pthread_mutex_t *__cdecl sub_8050394(int a1)
{
  pthread_mutex_t *v2; // [esp+1Ch] [ebp-Ch]

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 4));
  while ( 1 )
  {
    v2 = (pthread_mutex_t *)sub_80560CE(*(int **)a1);
    if ( v2 )
      break;
    pthread_cond_wait((pthread_cond_t *)(a1 + 28), (pthread_mutex_t *)(a1 + 4));
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 4));
  sub_805029C(v2);
  v2[1].__size[20] = 0;
  return v2;
}

//----- (080503FD) --------------------------------------------------------
int __cdecl sub_80503FD(int a1, FILE *stream, int a3)
{
  int result; // eax

  if ( !byte_806583F )
    goto LABEL_5;
  if ( !dword_8065419 || (result = sub_804EC4A(a1, (int)&dword_8065419)) != 0 )
  {
    dword_8065419 = *(_DWORD *)a1;
    dword_806541D = *(_DWORD *)(a1 + 4);
    dword_8065421 = *(_DWORD *)(a1 + 8);
    dword_8065425 = *(_DWORD *)(a1 + 12);
LABEL_5:
    result = sub_804ED79(a1, stream, a3);
  }
  return result;
}
// 8065419: using guessed type int dword_8065419;
// 806541D: using guessed type int dword_806541D;
// 8065421: using guessed type int dword_8065421;
// 8065425: using guessed type int dword_8065425;
// 806583F: using guessed type char byte_806583F;

//----- (08050470) --------------------------------------------------------
int __cdecl sub_8050470(int a1, int a2, FILE *stream, int a4)
{
  _DWORD *v4; // edx
  _DWORD *v5; // eax
  unsigned int v6; // eax
  _DWORD *v7; // edx
  unsigned int v8; // eax
  _DWORD *v9; // edx
  unsigned int v10; // eax
  unsigned int v11; // eax
  unsigned int v12; // eax
  unsigned int v13; // eax
  int v14; // ST2C_4
  int result; // eax
  unsigned int v16; // [esp+18h] [ebp-20h]
  _DWORD *v17; // [esp+1Ch] [ebp-1Ch]
  int v18; // [esp+20h] [ebp-18h]
  int v19; // [esp+24h] [ebp-14h]

  v18 = *(_DWORD *)a1;
  v19 = *(_DWORD *)(a1 + 4);
  v16 = ((unsigned int)a2 >> 2 * (*(_BYTE *)(a1 + 40) + 1)) + 1;
  if ( *(_DWORD *)(a1 + 40) <= 1u )
  {
    while ( *(_DWORD *)a1 != *(_DWORD *)(a1 + 8) )
    {
      if ( *(_DWORD *)(a1 + 4) == *(_DWORD *)(a1 + 12) )
        break;
      v11 = v16--;
      if ( !v11 )
        break;
      if ( sub_804EC4A(*(_DWORD *)a1 - 16, *(_DWORD *)(a1 + 4) - 16) > 0 )
      {
        *(_DWORD *)(a1 + 4) -= 16;
        sub_80503FD(*(_DWORD *)(a1 + 4), stream, a4);
      }
      else
      {
        *(_DWORD *)a1 -= 16;
        sub_80503FD(*(_DWORD *)a1, stream, a4);
      }
    }
    if ( *(_DWORD *)(a1 + 24) == (v19 - *(_DWORD *)(a1 + 4)) >> 4 )
    {
      while ( *(_DWORD *)a1 != *(_DWORD *)(a1 + 8) )
      {
        v12 = v16--;
        if ( !v12 )
          break;
        *(_DWORD *)a1 -= 16;
        sub_80503FD(*(_DWORD *)a1, stream, a4);
      }
    }
    else if ( *(_DWORD *)(a1 + 20) == (v18 - *(_DWORD *)a1) >> 4 )
    {
      while ( *(_DWORD *)(a1 + 4) != *(_DWORD *)(a1 + 12) )
      {
        v13 = v16--;
        if ( !v13 )
          break;
        *(_DWORD *)(a1 + 4) -= 16;
        sub_80503FD(*(_DWORD *)(a1 + 4), stream, a4);
      }
    }
  }
  else
  {
    v17 = **(_DWORD ***)(a1 + 16);
    while ( *(_DWORD *)a1 != *(_DWORD *)(a1 + 8) )
    {
      if ( *(_DWORD *)(a1 + 4) == *(_DWORD *)(a1 + 12) )
        break;
      v6 = v16--;
      if ( !v6 )
        break;
      if ( sub_804EC4A(*(_DWORD *)a1 - 16, *(_DWORD *)(a1 + 4) - 16) > 0 )
      {
        v17 -= 4;
        *(_DWORD *)(a1 + 4) -= 16;
        v4 = *(_DWORD **)(a1 + 4);
        v5 = v17;
        *v17 = *v4;
      }
      else
      {
        v17 -= 4;
        *(_DWORD *)a1 -= 16;
        v4 = *(_DWORD **)a1;
        v5 = v17;
        *v17 = **(_DWORD **)a1;
      }
      v5[1] = v4[1];
      v5[2] = v4[2];
      v5[3] = v4[3];
    }
    if ( *(_DWORD *)(a1 + 24) == (v19 - *(_DWORD *)(a1 + 4)) >> 4 )
    {
      while ( *(_DWORD *)a1 != *(_DWORD *)(a1 + 8) )
      {
        v8 = v16--;
        if ( !v8 )
          break;
        v17 -= 4;
        *(_DWORD *)a1 -= 16;
        v7 = *(_DWORD **)a1;
        *v17 = **(_DWORD **)a1;
        v17[1] = v7[1];
        v17[2] = v7[2];
        v17[3] = v7[3];
      }
    }
    else if ( *(_DWORD *)(a1 + 20) == (v18 - *(_DWORD *)a1) >> 4 )
    {
      while ( *(_DWORD *)(a1 + 4) != *(_DWORD *)(a1 + 12) )
      {
        v10 = v16--;
        if ( !v10 )
          break;
        v17 -= 4;
        *(_DWORD *)(a1 + 4) -= 16;
        v9 = *(_DWORD **)(a1 + 4);
        *v17 = *v9;
        v17[1] = v9[1];
        v17[2] = v9[2];
        v17[3] = v9[3];
      }
    }
    **(_DWORD **)(a1 + 16) = v17;
  }
  v14 = (v19 - *(_DWORD *)(a1 + 4)) >> 4;
  *(_DWORD *)(a1 + 20) -= (v18 - *(_DWORD *)a1) >> 4;
  result = a1;
  *(_DWORD *)(a1 + 24) -= v14;
  return result;
}

//----- (0805081D) --------------------------------------------------------
int __cdecl sub_805081D(int a1, int a2)
{
  int result; // eax
  bool v3; // al
  bool v4; // al
  bool v5; // [esp+1Fh] [ebp-9h]

  result = *(unsigned __int8 *)(a2 + 44) ^ 1;
  if ( *(_BYTE *)(a2 + 44) != 1 )
  {
    v5 = (unsigned int)(*(_DWORD *)(a2 + 4) - *(_DWORD *)(a2 + 12) + 15) > 0x1E;
    if ( (unsigned int)(*(_DWORD *)a2 - *(_DWORD *)(a2 + 8) + 15) > 0x1E )
    {
      v3 = v5 || !*(_DWORD *)(a2 + 24);
      result = v3;
    }
    else
    {
      v4 = v5 && !*(_DWORD *)(a2 + 20);
      result = v4;
    }
    if ( (_BYTE)result )
      result = sub_8050347(a1, a2);
  }
  return result;
}

//----- (080508CE) --------------------------------------------------------
int __cdecl sub_80508CE(int a1, _DWORD *a2)
{
  int result; // eax

  if ( a2[10] <= 1u )
  {
    result = a2[5] + a2[6];
    if ( !result )
      result = sub_8050347(a1, a2[7]);
  }
  else
  {
    sub_805029C((pthread_mutex_t *)a2[7]);
    sub_805081D(a1, a2[7]);
    result = sub_80502B2((pthread_mutex_t *)a2[7]);
  }
  return result;
}

//----- (0805093B) --------------------------------------------------------
int __cdecl sub_805093B(int a1, int a2, FILE *stream, int a4)
{
  pthread_mutex_t *v5; // [esp+1Ch] [ebp-Ch]

  while ( 1 )
  {
    v5 = sub_8050394(a1);
    if ( !v5[1].__nusers )
      break;
    sub_8050470((int)v5, a2, stream, a4);
    sub_805081D(a1, (int)v5);
    sub_80508CE(a1, v5);
    sub_80502B2(v5);
  }
  sub_80502B2(v5);
  return sub_8050347(a1, (int)v5);
}

//----- (080509CE) --------------------------------------------------------
void *__cdecl start_routine(void *a1)
{
  sub_8050A3B(
    *(_DWORD *)a1,
    *((_DWORD *)a1 + 1),
    *((_DWORD *)a1 + 2),
    *((_DWORD *)a1 + 3),
    *((_DWORD *)a1 + 4),
    *((FILE **)a1 + 5),
    *((_DWORD *)a1 + 6));
  return 0;
}

//----- (08050A3B) --------------------------------------------------------
int __cdecl sub_8050A3B(int a1, int a2, int a3, int a4, int a5, FILE *stream, int a7)
{
  int result; // eax
  pthread_t newthread; // [esp+28h] [ebp-40h]
  unsigned int v9; // [esp+2Ch] [ebp-3Ch]
  unsigned int v10; // [esp+30h] [ebp-38h]
  int v11; // [esp+34h] [ebp-34h]
  unsigned int v12; // [esp+38h] [ebp-30h]
  unsigned int v13; // [esp+3Ch] [ebp-2Ch]
  _DWORD *v14; // [esp+40h] [ebp-28h]
  int arg; // [esp+44h] [ebp-24h]
  unsigned int v16; // [esp+48h] [ebp-20h]
  int v17; // [esp+4Ch] [ebp-1Ch]
  int v18; // [esp+50h] [ebp-18h]
  int v19; // [esp+54h] [ebp-14h]
  FILE *v20; // [esp+58h] [ebp-10h]
  int v21; // [esp+5Ch] [ebp-Ch]

  v9 = *(_DWORD *)(a4 + 20) + *(_DWORD *)(a4 + 24);
  v10 = (unsigned int)a2 >> 1;
  v11 = a2 - ((unsigned int)a2 >> 1);
  arg = a1;
  v16 = (unsigned int)a2 >> 1;
  v17 = a3;
  v18 = *(_DWORD *)(a4 + 32);
  v19 = a5;
  v20 = stream;
  v21 = a7;
  if ( (unsigned int)a2 <= 1 || v9 <= 0x1FFFF || pthread_create(&newthread, 0, start_routine, &arg) )
  {
    v12 = *(_DWORD *)(a4 + 20);
    v13 = *(_DWORD *)(a4 + 24);
    v14 = (_DWORD *)(-16 * a3 + a1);
    if ( v13 > 1 )
      sub_804FD6E((_DWORD *)(-16 * v12 + a1), v13, &v14[-4 * (v12 >> 1)], 0);
    if ( v12 > 1 )
      sub_804FD6E((_DWORD *)a1, v12, v14, 0);
    *(_DWORD *)a4 = a1;
    *(_DWORD *)(a4 + 4) = a1 - 16 * v12;
    *(_DWORD *)(a4 + 8) = a1 - 16 * v12;
    *(_DWORD *)(a4 + 12) = a1 + -16 * v12 - 16 * v13;
    sub_8050347(a5, a4);
    result = sub_805093B(a5, a3, stream, a7);
  }
  else
  {
    sub_8050A3B(a1 - 16 * *(_DWORD *)(a4 + 20), v11, a3, *(_DWORD *)(a4 + 36), a5, stream, a7);
    result = pthread_join(newthread, 0);
  }
  return result;
}

//----- (08050C3F) --------------------------------------------------------
int __cdecl sub_8050C3F(int a1, int a2, int a3, char *s1)
{
  int result; // eax
  char v5; // al
  char v6; // [esp+21h] [ebp-D7h]
  char v7; // [esp+22h] [ebp-D6h]
  bool v8; // [esp+23h] [ebp-D5h]
  FILE *stream; // [esp+24h] [ebp-D4h]
  int *v10; // [esp+28h] [ebp-D0h]
  unsigned int i; // [esp+2Ch] [ebp-CCh]
  __int64 v12; // [esp+30h] [ebp-C8h]
  __int64 v13; // [esp+88h] [ebp-70h]
  __int64 v14; // [esp+90h] [ebp-68h]
  __int64 v15; // [esp+E8h] [ebp-10h]

  v6 = 0;
  v10 = 0;
  for ( i = a2; ; ++i )
  {
    result = i;
    if ( i >= a3 )
      break;
    v8 = strcmp(*(const char **)(8 * i + a1), "-") == 0;
    if ( s1 && !strcmp(s1, *(const char **)(8 * i + a1)) && v8 != 1 )
    {
      v7 = 1;
      goto LABEL_18;
    }
    if ( v6 != 1 )
    {
      result = sub_805D0B2(1, (int)&v12);
      if ( result )
        return result;
      v6 = 1;
    }
    if ( v8 )
    {
      if ( sub_805D0B2(0, (int)&v14) )
        goto LABEL_16;
    }
    else if ( sub_805D083(*(_DWORD *)(8 * i + a1), (int)&v14) )
    {
      goto LABEL_16;
    }
    if ( v15 != v13 || v14 != v12 )
    {
LABEL_16:
      v5 = 0;
      goto LABEL_17;
    }
    v5 = 1;
LABEL_17:
    v7 = v5 & 1;
LABEL_18:
    if ( v7 )
    {
      if ( !v10 )
      {
        v10 = sub_804B23B(&stream);
        sub_804FBFF(8 * i + a1, 0, 1, stream, (int)v10 + 9);
      }
      *(_DWORD *)(8 * i + a1) = (char *)v10 + 9;
      *(_DWORD *)(a1 + 8 * i + 4) = v10;
    }
  }
  return result;
}

//----- (08050E6D) --------------------------------------------------------
unsigned int __cdecl sub_8050E6D(int a1, unsigned int a2)
{
  char *v2; // ebx
  char *v3; // eax
  unsigned int result; // eax
  unsigned int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a2 )
      break;
    if ( strcmp(*(const char **)(4 * i + a1), "-") && euidaccess(*(_DWORD *)(4 * i + a1), 4) )
    {
      v2 = *(char **)(4 * i + a1);
      v3 = gettext("cannot read");
      sub_804A4B6((int)v3, v2);
    }
  }
  return result;
}
// 8049E00: using guessed type int __cdecl euidaccess(_DWORD, _DWORD);

//----- (08050F08) --------------------------------------------------------
void __cdecl sub_8050F08(char *a1)
{
  char *v1; // eax
  int fd; // [esp+1Ch] [ebp-Ch]

  if ( a1 )
  {
    fd = open64(a1, 524353);
    if ( fd < 0 )
    {
      v1 = gettext("open failed");
      sub_804A4B6((int)v1, a1);
    }
    sub_804AF41(fd, 1);
  }
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);

//----- (08050F6E) --------------------------------------------------------
void __cdecl sub_8050F6E(int a1, int a2, int a3, char *s1)
{
  int *v4; // eax
  int v5; // esi
  int v6; // eax
  int v7; // eax
  int *v8; // eax
  int v9; // ebx
  int v10; // eax
  int v11; // eax
  int v12; // eax
  char *v13; // eax
  char *v14; // ebx
  char *v15; // eax
  int v16; // eax
  int v17; // eax
  void *v18; // [esp+28h] [ebp-50h]
  FILE *v19; // [esp+2Ch] [ebp-4Ch]
  int v20; // [esp+30h] [ebp-48h]
  unsigned int v21; // [esp+34h] [ebp-44h]
  int v22; // [esp+38h] [ebp-40h]
  int *v23; // [esp+3Ch] [ebp-3Ch]
  unsigned int v24; // [esp+40h] [ebp-38h]
  int v25; // [esp+44h] [ebp-34h]
  unsigned int v26; // [esp+48h] [ebp-30h]
  int v27; // [esp+4Ch] [ebp-2Ch]
  int *v28; // [esp+50h] [ebp-28h]
  unsigned int v29; // [esp+54h] [ebp-24h]
  FILE *stream; // [esp+58h] [ebp-20h]
  int *v31; // [esp+5Ch] [ebp-1Ch]
  int v32; // [esp+84h] [ebp+Ch]

  while ( dword_80652B4 < (unsigned int)a3 )
  {
    v20 = 0;
    v21 = 0;
    while ( a3 - v20 >= (unsigned int)dword_80652B4 )
    {
      v4 = sub_804B23B(&v19);
      v23 = v4;
      v5 = (int)v4 + 9;
      v6 = a2;
      if ( dword_80652B4 <= (unsigned int)a2 )
        v6 = dword_80652B4;
      v24 = sub_804FBFF(8 * v20 + a1, v6, dword_80652B4, v19, v5);
      v7 = a2;
      if ( v24 <= a2 )
        v7 = v24;
      a2 -= v7;
      *(_DWORD *)(8 * v21 + a1) = (char *)v23 + 9;
      *(_DWORD *)(a1 + 8 * v21 + 4) = v23;
      v20 += v24;
      ++v21;
    }
    v25 = a3 - v20;
    v26 = dword_80652B4 - v21 % dword_80652B4;
    if ( dword_80652B4 - v21 % dword_80652B4 < a3 - v20 )
    {
      v27 = v25 - v26 + 1;
      v8 = sub_804B23B(&v19);
      v28 = v8;
      v9 = (int)v8 + 9;
      v10 = a2;
      if ( v27 <= (unsigned int)a2 )
        v10 = v27;
      v29 = sub_804FBFF(8 * v20 + a1, v10, v27, v19, v9);
      v11 = a2;
      if ( v29 <= a2 )
        v11 = v29;
      a2 -= v11;
      *(_DWORD *)(8 * v21 + a1) = (char *)v28 + 9;
      v12 = v21++;
      *(_DWORD *)(a1 + 8 * v12 + 4) = v28;
      v20 += v29;
    }
    memmove((void *)(8 * v21 + a1), (const void *)(a1 + 8 * v20), 8 * (a3 - v20));
    a2 += v21;
    a3 += v21 - v20;
  }
  sub_8050C3F(a1, a2, a3, s1);
  while ( 1 )
  {
    v22 = sub_804F1F4(a1, a3, &v18);
    if ( v22 == a3 )
      break;
    if ( (unsigned int)v22 <= 2 )
    {
      v14 = *(char **)(8 * v22 + a1);
      v15 = gettext("open failed");
      sub_804A4B6((int)v15, v14);
    }
    do
    {
LABEL_28:
      --v22;
      sub_804AEAF(*((FILE **)v18 + v22), *(_DWORD *)(8 * v22 + a1));
      v31 = sub_804B0EF(&v19, (unsigned int)v22 > 2);
    }
    while ( !v31 );
    v16 = a2;
    if ( v22 <= (unsigned int)a2 )
      v16 = v22;
    sub_804F2D8(a1, v16, v22, v19, (int)v31 + 9, v18);
    v17 = a2;
    if ( v22 <= (unsigned int)a2 )
      v17 = v22;
    v32 = a2 - v17;
    *(_DWORD *)a1 = (char *)v31 + 9;
    *(_DWORD *)(a1 + 4) = v31;
    memmove((void *)(a1 + 8), (const void *)(a1 + 8 * v22), 8 * (a3 - v22));
    a2 = v32 + 1;
    a3 = a3 - v22 + 1;
  }
  stream = sub_804AD32(s1, "w");
  if ( !stream )
  {
    if ( *__errno_location() != 24 || (unsigned int)v22 <= 2 )
    {
      v13 = gettext("open failed");
      sub_804A4B6((int)v13, s1);
    }
    goto LABEL_28;
  }
  sub_804F2D8(a1, a2, a3, stream, (int)s1, v18);
}
// 80652B0: using guessed type int dword_80652B0;

//----- (08051367) --------------------------------------------------------
unsigned int __cdecl sub_8051367(char **a1, unsigned int a2, char *a3, unsigned int a4)
{
  int v4; // eax
  char **v6; // [esp+2Ch] [ebp-BCh]
  char v7; // [esp+3Fh] [ebp-A9h]
  FILE *stream; // [esp+40h] [ebp-A8h]
  FILE *v9; // [esp+44h] [ebp-A4h]
  int v10; // [esp+48h] [ebp-A0h]
  int v11; // [esp+4Ch] [ebp-9Ch]
  int v12; // [esp+50h] [ebp-98h]
  unsigned int v13; // [esp+54h] [ebp-94h]
  int v14; // [esp+58h] [ebp-90h]
  int *v15; // [esp+5Ch] [ebp-8Ch]
  int v16; // [esp+60h] [ebp-88h]
  char *s1; // [esp+64h] [ebp-84h]
  int v18; // [esp+68h] [ebp-80h]
  pthread_mutex_t *v19; // [esp+6Ch] [ebp-7Ch]
  void *v20; // [esp+70h] [ebp-78h]
  void *ptr; // [esp+74h] [ebp-74h]
  int v22; // [esp+78h] [ebp-70h]
  int v23; // [esp+7Ch] [ebp-6Ch]
  int v24; // [esp+80h] [ebp-68h]
  int v25; // [esp+84h] [ebp-64h]
  char v26; // [esp+8Ch] [ebp-5Ch]
  int v27; // [esp+90h] [ebp-58h]
  unsigned int v28; // [esp+DCh] [ebp-Ch]

  v6 = a1;
  v28 = __readgsdword(0x14u);
  v10 = 0;
  v7 = 0;
  v24 = 0;
  while ( a2 )
  {
    s1 = *v6;
    stream = sub_804AE6E(s1, "r");
    if ( a4 <= 1 )
    {
      v12 = 24;
    }
    else
    {
      v13 = 1;
      v14 = 1;
      while ( v13 < a4 )
      {
        v13 *= 2;
        ++v14;
      }
      v12 = 16 * v14;
    }
    if ( !v24 )
    {
      v4 = sub_804BEC7((int)&stream, 1u, (int)v6, a2, v12);
      sub_804C07C((int)&ptr, v12, v4);
    }
    v26 = 0;
    ++v6;
    --a2;
    while ( (unsigned __int8)sub_804C3CC((int)&ptr, stream, (int)s1) )
    {
      if ( v26 && a2 && v12 + 1 < (unsigned int)(v24 - v22 - v12 * v23) )
      {
        v25 = v22;
        break;
      }
      dword_8065419 = 0;
      v18 = sub_804C102(&ptr);
      if ( !v26 || a2 || v10 || v25 )
      {
        ++v10;
        v11 = (int)sub_804B23B(&v9) + 9;
      }
      else
      {
        sub_804AEAF(stream, (int)s1);
        v9 = sub_804AE6E(a3, "w");
        v11 = (int)a3;
        v7 = 1;
      }
      if ( (unsigned int)v23 <= 1 )
      {
        sub_80503FD(v18 - 16, v9, v11);
      }
      else
      {
        sub_80502F9((int)&v27, a4);
        v19 = sub_804FF7B(a4, v23, v18);
        sub_8050A3B(v18, a4, v23, (int)&v19[3], (int)&v27, v9, v11);
      }
      sub_804AEAF(v9, v11);
      if ( v7 )
        goto LABEL_28;
    }
    sub_804AEAF(stream, (int)s1);
  }
LABEL_28:
  free(ptr);
  if ( v7 != 1 )
  {
    v15 = (int *)dword_80658CD;
    v20 = sub_805A6F0(v10, 8u);
    v16 = 0;
    while ( v15 )
    {
      *((_DWORD *)v20 + 2 * v16) = (char *)v15 + 9;
      *((_DWORD *)v20 + 2 * v16 + 1) = v15;
      v15 = (int *)*v15;
      ++v16;
    }
    sub_8050F6E((int)v20, v10, v10, a3);
    free(v20);
  }
  sub_804AAB4();
  return __readgsdword(0x14u) ^ v28;
}
// 8065419: using guessed type int dword_8065419;
// 80658CD: using guessed type int dword_80658CD;

//----- (0805175C) --------------------------------------------------------
_DWORD *__cdecl sub_805175C(void *src)
{
  _DWORD *result; // eax
  int *i; // [esp+18h] [ebp-10h]
  _DWORD *v3; // [esp+1Ch] [ebp-Ch]

  v3 = sub_805A8FF(src, 0x28u);
  for ( i = &dword_8065841; *i; i = (int *)(*i + 36) )
    ;
  *i = (int)v3;
  result = v3;
  v3[9] = 0;
  return result;
}
// 8065841: using guessed type int dword_8065841;

//----- (080517A9) --------------------------------------------------------
unsigned int __cdecl sub_80517A9(int a1, char *msgid)
{
  void *v2; // esi
  char *v3; // ebx
  char *v4; // eax

  v2 = sub_80585AA(a1);
  v3 = gettext(msgid);
  v4 = gettext("%s: invalid field specification %s");
  error(2, 0, v4, v3, v2);
  return sub_80517F7(a1);
}

//----- (080517F7) --------------------------------------------------------
unsigned int __cdecl sub_80517F7(int a1)
{
  char *v1; // eax

  v1 = gettext("options '-%s' are incompatible");
  error(2, 0, v1, a1);
  return sub_8051828();
}

//----- (08051828) --------------------------------------------------------
unsigned int sub_8051828()
{
  int i; // [esp+18h] [ebp-30h]
  char v2; // [esp+1Dh] [ebp-2Bh]
  unsigned int v3; // [esp+3Ch] [ebp-Ch]

  v3 = __readgsdword(0x14u);
  for ( i = dword_8065841; i; i = *(_DWORD *)(i + 36) )
  {
    if ( *(unsigned __int8 *)(i + 29)
       + *(unsigned __int8 *)(i + 28)
       + *(unsigned __int8 *)(i + 26)
       + *(unsigned __int8 *)(i + 30)
       + (*(unsigned __int8 *)(i + 27) | *(unsigned __int8 *)(i + 32) | (*(_DWORD *)(i + 16) != 0)) > 1 )
    {
      *(_BYTE *)(i + 31) = 0;
      *(_BYTE *)(i + 25) = *(_BYTE *)(i + 31);
      *(_BYTE *)(i + 24) = *(_BYTE *)(i + 25);
      sub_804D7BA(i, &v2);
      sub_80517F7((int)&v2);
    }
  }
  return __readgsdword(0x14u) ^ v3;
}
// 8065841: using guessed type int dword_8065841;

//----- (08051906) --------------------------------------------------------
int __cdecl sub_8051906(char *nptr, int a2, char *msgid)
{
  void *v3; // esi
  char *v4; // ebx
  char *v5; // eax
  int result; // eax
  int v7; // [esp+24h] [ebp-14h]
  __int64 v8; // [esp+28h] [ebp-10h]

  switch ( sub_805B19D(nptr, (int)&v7, 10, (int)&v8, &s) )
  {
    case 0:
    case 2:
      *(_DWORD *)a2 = v8;
      if ( v8 == *(_DWORD *)a2 )
        goto LABEL_7;
      goto LABEL_3;
    case 1:
    case 3:
LABEL_3:
      *(_DWORD *)a2 = -1;
      goto LABEL_7;
    case 4:
      if ( msgid )
      {
        v3 = sub_80585AA((int)nptr);
        v4 = gettext(msgid);
        v5 = gettext("%s: invalid count at start of %s");
        error(2, 0, v5, v4, v3);
      }
      result = 0;
      break;
    default:
LABEL_7:
      result = v7;
      break;
  }
  return result;
}

//----- (080519DE) --------------------------------------------------------
int __cdecl sub_80519DE(int sig)
{
  sub_804AAD3();
  signal(sig, 0);
  return raise(sig);
}

//----- (08051A09) --------------------------------------------------------
_BYTE *__cdecl sub_8051A09(_BYTE *a1, int a2, int a3)
{
  _BYTE *result; // eax

  while ( 2 )
  {
    if ( !*a1 )
      return a1;
    switch ( *a1 )
    {
      case 77:
        *(_BYTE *)(a2 + 30) = 1;
        goto LABEL_23;
      case 82:
        *(_BYTE *)(a2 + 27) = 1;
        goto LABEL_23;
      case 86:
        *(_BYTE *)(a2 + 32) = 1;
        goto LABEL_23;
      case 98:
        if ( !a3 || a3 == 2 )
          *(_BYTE *)(a2 + 24) = 1;
        if ( a3 == 1 || a3 == 2 )
          *(_BYTE *)(a2 + 25) = 1;
        goto LABEL_23;
      case 100:
        *(_DWORD *)(a2 + 16) = &unk_806562D;
        goto LABEL_23;
      case 102:
        *(_DWORD *)(a2 + 20) = byte_806572D;
        goto LABEL_23;
      case 103:
        *(_BYTE *)(a2 + 28) = 1;
        goto LABEL_23;
      case 104:
        *(_BYTE *)(a2 + 29) = 1;
        goto LABEL_23;
      case 105:
        if ( !*(_DWORD *)(a2 + 16) )
          *(_DWORD *)(a2 + 16) = &unk_806552D;
        goto LABEL_23;
      case 110:
        *(_BYTE *)(a2 + 26) = 1;
        goto LABEL_23;
      case 114:
        *(_BYTE *)(a2 + 31) = 1;
LABEL_23:
        ++a1;
        continue;
      default:
        result = a1;
        break;
    }
    return result;
  }
}

//----- (08051AE4) --------------------------------------------------------
void *__cdecl sub_8051AE4(void *s)
{
  memset(s, 0, 0x28u);
  *((_DWORD *)s + 2) = -1;
  return s;
}

//----- (08051B14) --------------------------------------------------------
_BOOL4 __cdecl main(int argc, char **argv)
{
  bool v2; // al
  unsigned __int8 **v3; // eax
  unsigned __int8 v4; // al
  unsigned __int8 v5; // al
  int v6; // eax
  int *v7; // ecx
  int v8; // eax
  char v9; // al
  _BOOL4 v10; // eax
  int v11; // eax
  int v12; // eax
  signed int v13; // eax
  char *v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // eax
  char *v18; // eax
  char *v19; // eax
  char *v20; // eax
  void *v21; // ebx
  char *v22; // eax
  char *v23; // eax
  void *v24; // ebx
  char *v25; // eax
  char *v26; // eax
  void *v27; // ebx
  char *v28; // eax
  void *v29; // ebx
  char *v30; // eax
  void *v31; // ebx
  char *v32; // eax
  void *v33; // ebx
  char *v34; // eax
  char v35; // al
  char *v36; // eax
  char *v37; // eax
  void *v38; // ebx
  char *v39; // eax
  char *v40; // eax
  const char *v41; // eax
  int v42; // eax
  void *v43; // ebx
  char *v44; // eax
  _BOOL4 result; // eax
  signed int v46; // eax
  unsigned int v47; // eax
  char *v48; // eax
  char v49; // [esp+2Dh] [ebp-14Fh]
  char v50; // [esp+2Eh] [ebp-14Eh]
  char v51; // [esp+2Fh] [ebp-14Dh]
  bool v52; // [esp+30h] [ebp-14Ch]
  bool v53; // [esp+31h] [ebp-14Bh]
  bool v54; // [esp+32h] [ebp-14Ah]
  char v55; // [esp+33h] [ebp-149h]
  bool v56; // [esp+34h] [ebp-148h]
  char v57; // [esp+35h] [ebp-147h]
  char v58; // [esp+36h] [ebp-146h]
  char v59; // [esp+37h] [ebp-145h]
  _DWORD *l; // [esp+38h] [ebp-144h]
  _BYTE *v61; // [esp+3Ch] [ebp-140h]
  int v62; // [esp+40h] [ebp-13Ch]
  char *v63; // [esp+44h] [ebp-138h]
  unsigned int v64; // [esp+48h] [ebp-134h]
  unsigned int v65; // [esp+4Ch] [ebp-130h]
  int *v66; // [esp+50h] [ebp-12Ch]
  char *v67; // [esp+54h] [ebp-128h]
  char *v68; // [esp+58h] [ebp-124h]
  unsigned int i; // [esp+5Ch] [ebp-120h]
  char *j; // [esp+60h] [ebp-11Ch]
  unsigned int k; // [esp+64h] [ebp-118h]
  unsigned int m; // [esp+68h] [ebp-114h]
  int v73; // [esp+6Ch] [ebp-110h]
  unsigned __int8 **v74; // [esp+70h] [ebp-10Ch]
  char *v75; // [esp+74h] [ebp-108h]
  FILE *v76; // [esp+78h] [ebp-104h]
  unsigned int v77; // [esp+7Ch] [ebp-100h]
  char *v78; // [esp+80h] [ebp-FCh]
  _DWORD *v79; // [esp+84h] [ebp-F8h]
  unsigned int v80; // [esp+88h] [ebp-F4h]
  unsigned int v81; // [esp+8Ch] [ebp-F0h]
  char v82; // [esp+90h] [ebp-ECh]
  int s[4]; // [esp+B8h] [ebp-C4h]
  int v84; // [esp+C8h] [ebp-B4h]
  int v85; // [esp+CCh] [ebp-B0h]
  char v86; // [esp+D0h] [ebp-ACh]
  char v87; // [esp+D1h] [ebp-ABh]
  char v88; // [esp+D2h] [ebp-AAh]
  unsigned __int8 v89; // [esp+D3h] [ebp-A9h]
  char v90; // [esp+D4h] [ebp-A8h]
  char v91; // [esp+D5h] [ebp-A7h]
  char v92; // [esp+D6h] [ebp-A6h]
  char v93; // [esp+D7h] [ebp-A5h]
  char v94; // [esp+D8h] [ebp-A4h]
  int longind; // [esp+E0h] [ebp-9Ch]
  int *v96; // [esp+E4h] [ebp-98h]
  int v97; // [esp+164h] [ebp-18h]

  v49 = 0;
  v62 = 0;
  v50 = 0;
  v51 = 0;
  v63 = 0;
  v52 = 0;
  v64 = 0;
  v65 = 0;
  v56 = getenv("POSIXLY_CORRECT") != 0;
  v73 = sub_8056CF3();
  v2 = v73 <= 200111 || v73 > 200808;
  v53 = v2;
  v67 = 0;
  v68 = 0;
  sub_8056D51(*argv);
  v54 = setlocale(6, &::s) != 0;
  bindtextdomain("coreutils", "/home/hwangdz/coreutils/coreutils-8.28/install_m32/share/locale");
  textdomain("coreutils");
  sub_804A16A(2);
  byte_8065415 = sub_8054CAD(3);
  byte_8065416 = sub_8054CAD(2);
  v3 = (unsigned __int8 **)localeconv();
  v74 = v3;
  v4 = sub_804A17D(**v3);
  dword_806540D = v4;
  if ( !v4 || (*v74)[1] )
    dword_806540D = 46;
  v5 = sub_804A17D(*v74[1]);
  dword_8065411 = v5;
  if ( !v5 || v74[1][1] )
    dword_8065411 = -1;
  byte_8065840 = 0;
  sub_804B5D3();
  sigemptyset(&set);
  for ( i = 0; i <= 0xA; ++i )
  {
    sigaction(sig[i], 0, (struct sigaction *)&longind);
    if ( longind != 1 )
      sigaddset(&set, sig[i]);
  }
  longind = (int)sub_80519DE;
  qmemcpy(&v96, &set, 0x80u);
  v97 = 0;
  for ( i = 0; i <= 0xA; ++i )
  {
    if ( sigismember(&set, sig[i]) )
      sigaction(sig[i], (const struct sigaction *)&longind, 0);
  }
  signal(17, 0);
  sub_805D054((int)sub_804AB0B);
  sub_8051AE4(s);
  s[0] = -1;
  v66 = (int *)sub_805A6F0(argc, 4u);
  while ( 1 )
  {
    while ( 1 )
    {
      longind = -1;
      if ( v62 == -1
        || v56
        && v65
        && (v53 != 1
         || v50
         || optind == argc
         || *argv[optind] != 45
         || argv[optind][1] != 111
         || !argv[optind][2] && optind + 1 == argc) )
      {
        break;
      }
      v62 = getopt_long(argc, argv, "-bcCdfghik:mMno:rRsS:t:T:uVy:z", &longopts, &longind);
      if ( v62 == -1 )
        break;
      switch ( v62 )
      {
        case 4294967165:
          sub_805A650(stdout, (int)"sort", (int)"GNU coreutils", off_80652CC, "Mike Haertel", "Paul Eggert", 0);
          exit(0);
          return result;
        case 4294967166:
          sub_804A518(0);
          return result;
        case 1:
          l = 0;
          if ( *optarg == 43 )
          {
            v9 = optind == argc || *argv[optind] != 45 || (unsigned int)(argv[optind][1] - 48) > 9 ? 0 : 1;
            v57 = v9 & 1;
            v10 = v9 & 1 && v56 != 1;
            v53 = (v53 || v10) != 0;
            if ( v53 )
            {
              l = sub_8051AE4(&v82);
              v61 = (_BYTE *)sub_8051906(optarg + 1, (int)l, 0);
              if ( v61 && *v61 == 46 )
                v61 = (_BYTE *)sub_8051906(v61 + 1, (int)(l + 1), 0);
              if ( !*l && !l[1] )
                *l = -1;
              if ( v61 && !*sub_8051A09(v61, (int)l, 0) )
              {
                if ( v57 )
                {
                  v11 = optind++;
                  v75 = argv[v11];
                  v61 = (_BYTE *)sub_8051906(v75 + 1, (int)(l + 2), "invalid number after '-'");
                  if ( !v61 )
                    __assert_fail("s", "src/sort.c", 0x110Du, "main");
                  if ( *v61 == 46 )
                    v61 = (_BYTE *)sub_8051906(v61 + 1, (int)(l + 3), "invalid number after '.'");
                  if ( !l[3] && l[2] )
                    --l[2];
                  if ( *sub_8051A09(v61, (int)l, 1) )
                    sub_80517A9((int)v75, "stray character in field spec");
                }
                *((_BYTE *)l + 33) = 1;
                sub_805175C(l);
              }
              else
              {
                l = 0;
              }
            }
          }
          if ( !l )
          {
            v12 = v65++;
            v66[v12] = (int)optarg;
          }
          continue;
        case 67:
        case 99:
          goto LABEL_78;
        case 77:
        case 82:
        case 86:
        case 98:
        case 100:
        case 102:
        case 103:
        case 104:
        case 105:
        case 110:
        case 114:
          goto LABEL_73;
        case 83:
          sub_804BA0E(longind, (char)v62, optarg);
          break;
        case 84:
          sub_804B419((int)optarg);
          break;
        case 107:
          l = sub_8051AE4(&v82);
          v61 = (_BYTE *)sub_8051906(optarg, (int)l, "invalid number at field start");
          v15 = (*l)--;
          if ( !v15 )
            sub_80517A9((int)optarg, "field number is zero");
          if ( *v61 == 46 )
          {
            v61 = (_BYTE *)sub_8051906(v61 + 1, (int)(l + 1), "invalid number after '.'");
            v16 = l[1];
            l[1] = v16 - 1;
            if ( !v16 )
              sub_80517A9((int)optarg, "character offset is zero");
          }
          if ( !*l && !l[1] )
            *l = -1;
          v61 = sub_8051A09(v61, (int)l, 0);
          if ( *v61 == 44 )
          {
            v61 = (_BYTE *)sub_8051906(v61 + 1, (int)(l + 2), "invalid number after ','");
            v17 = l[2];
            l[2] = v17 - 1;
            if ( !v17 )
              sub_80517A9((int)optarg, "field number is zero");
            if ( *v61 == 46 )
              v61 = (_BYTE *)sub_8051906(v61 + 1, (int)(l + 3), "invalid number after '.'");
            v61 = sub_8051A09(v61, (int)l, 1);
          }
          else
          {
            l[2] = -1;
            l[3] = 0;
          }
          if ( *v61 )
            sub_80517A9((int)optarg, "stray character in field spec");
          sub_805175C(l);
          break;
        case 109:
          v51 = 1;
          break;
        case 111:
          if ( v68 && strcmp(v68, optarg) )
          {
            v18 = gettext("multiple output files specified");
            error(2, 0, v18);
          }
          v68 = optarg;
          break;
        case 115:
          byte_806583E = 1;
          break;
        case 116:
          v55 = *optarg;
          if ( !*optarg )
          {
            v20 = gettext("empty tab");
            error(2, 0, v20);
          }
          if ( optarg[1] )
          {
            if ( !strcmp(optarg, "\\0") )
            {
              v55 = 0;
            }
            else
            {
              v21 = sub_80585AA((int)optarg);
              v22 = gettext("multi-character tab %s");
              error(2, 0, v22, v21);
            }
          }
          if ( dword_80652B0 != 128 && v55 != dword_80652B0 )
          {
            v23 = gettext("incompatible tabs");
            error(2, 0, v23);
          }
          dword_80652B0 = v55;
          break;
        case 117:
          byte_806583F = 1;
          break;
        case 121:
          if ( argv[optind + 0x3FFFFFFF] == optarg )
          {
            for ( j = optarg; (unsigned int)(*j - 48) <= 9; ++j )
              ;
            optind -= *j != 0;
          }
          break;
        case 122:
          byte_806522C = 0;
          break;
        case 128:
          if ( optarg )
            v13 = aCccgeneralNume[sub_8053321(
                                    (int)"--check",
                                    optarg,
                                    (int)off_805E64C,
                                    (int)"CCcgeneral-numeric",
                                    1u,
                                    off_80652D0)];
          else
            v13 = 99;
          v62 = v13;
LABEL_78:
          if ( v50 && v50 != v62 )
            sub_80517F7((int)"cC");
          v50 = v62;
          break;
        case 129:
          if ( s1 && strcmp(s1, optarg) )
          {
            v14 = gettext("multiple compress programs specified");
            error(2, 0, v14);
          }
          s1 = optarg;
          break;
        case 130:
          byte_8065849 = 1;
          break;
        case 131:
          v67 = optarg;
          break;
        case 132:
          sub_804B7C4(longind, v62, optarg);
          break;
        case 133:
          if ( v63 && strcmp(v63, optarg) )
          {
            v19 = gettext("multiple random sources specified");
            error(2, 0, v19);
          }
          v63 = optarg;
          break;
        case 134:
          v62 = byte_805E6B0[sub_8053321((int)"--sort", optarg, (int)&off_805E694, (int)byte_805E6B0, 1u, off_80652D0)];
LABEL_73:
          v58 = v62;
          v59 = 0;
          sub_8051A09(&v58, (int)s, 2);
          break;
        case 135:
          v64 = sub_804BC53(longind, (char)v62, optarg);
          break;
        default:
          sub_804A518(2);
          return result;
      }
    }
    if ( argc <= optind )
      break;
    v6 = v65++;
    v7 = &v66[v6];
    v8 = optind++;
    *v7 = (int)argv[v8];
  }
  if ( v67 )
  {
    if ( v65 )
    {
      v24 = sub_8058217(4, *v66);
      v25 = gettext("extra operand %s");
      error(0, 0, v25, v24);
      v26 = gettext("file operands cannot be combined with --files0-from");
      fprintf(stderr, "%s\n", v26);
      sub_804A518(2);
    }
    v76 = sub_804AE6E(v67, "r");
    sub_805948D(&longind);
    if ( !sub_80597C6(v76, (int)&longind) )
    {
      v27 = sub_8058217(4, (int)v67);
      v28 = gettext("cannot read file names from %s");
      error(2, 0, v28, v27);
    }
    sub_804AEAF(v76, (int)v67);
    if ( longind )
    {
      free(v66);
      v66 = v96;
      v65 = longind;
      for ( k = 0; k < v65; ++k )
      {
        if ( !strcmp((const char *)v66[k], "-") )
        {
          v29 = sub_8058217(4, v66[k]);
          v30 = gettext("when reading file names from stdin, no file name of %s allowed");
          error(2, 0, v30, v29);
        }
        if ( !*(_BYTE *)v66[k] )
        {
          v77 = k + 1;
          v31 = sub_8058372(0, 3, (int)v67);
          v32 = gettext("%s:%lu: invalid zero-length file name");
          error(2, 0, v32, v31, v77);
        }
      }
    }
    else
    {
      v33 = sub_8058217(4, (int)v67);
      v34 = gettext("no input from %s");
      error(2, 0, v34, v33);
    }
  }
  for ( l = (_DWORD *)dword_8065841; l; l = (_DWORD *)l[9] )
  {
    if ( (unsigned __int8)sub_804D737((int)l) && *((_BYTE *)l + 31) != 1 )
    {
      l[4] = v84;
      l[5] = v85;
      *((_BYTE *)l + 24) = v86;
      *((_BYTE *)l + 25) = v87;
      *((_BYTE *)l + 30) = v92;
      *((_BYTE *)l + 26) = v88;
      *((_BYTE *)l + 28) = v90;
      *((_BYTE *)l + 29) = v91;
      *((_BYTE *)l + 32) = v94;
      *((_BYTE *)l + 27) = v89;
      *((_BYTE *)l + 31) = v93;
    }
    v52 = (v52 | *((unsigned __int8 *)l + 27)) != 0;
  }
  if ( !dword_8065841 && (unsigned __int8)sub_804D737((int)s) ^ 1 )
  {
    v49 = 1;
    sub_805175C(s);
    v52 = (v52 | v89) != 0;
  }
  sub_8051828();
  if ( byte_8065849 )
  {
    if ( v50 || v68 )
    {
      if ( v50 )
        v35 = v50;
      else
        v35 = 111;
      byte_80652BC = v35;
      sub_80517F7((int)&byte_80652BC);
    }
    if ( v54 )
      v54 = setlocale(3, &::s) != 0;
    if ( v54 != 1 )
    {
      v36 = gettext("failed to set locale");
      error(0, 0, "%s", v36);
    }
    if ( byte_8065415 )
    {
      v37 = setlocale(3, 0);
      v38 = sub_80585AA((int)v37);
      v39 = gettext("using %s sorting rules");
      error(0, 0, v39, v38);
    }
    else
    {
      v40 = gettext("using simple byte comparison");
      error(0, 0, "%s", v40);
    }
    sub_804D8D0(s, v49);
  }
  byte_806583D = v93;
  if ( v52 )
    sub_804CC88(v63);
  if ( !dword_8065835 )
  {
    v78 = getenv("TMPDIR");
    if ( v78 )
      v41 = v78;
    else
      v41 = "/tmp";
    sub_804B419((int)v41);
  }
  if ( !v65 )
  {
    v65 = 1;
    free(v66);
    v66 = (int *)sub_805A7FD(4u);
    *v66 = (int)"-";
  }
  if ( size )
  {
    v42 = size;
    if ( 18 * dword_80652B4 >= size )
      v42 = 18 * dword_80652B4;
    size = v42;
  }
  if ( v50 )
  {
    if ( v65 > 1 )
    {
      v43 = sub_8058217(4, v66[1]);
      v44 = gettext("extra operand %s not allowed with -%c");
      error(2, 0, v44, v43, v50);
    }
    if ( v68 )
    {
      byte_80652C6 = v50;
      sub_80517F7((int)&byte_80652C6);
    }
    result = (unsigned __int8)sub_804EE82((char *)*v66, v50) == 0;
  }
  else
  {
    sub_8050E6D((int)v66, v65);
    sub_8050F08(v68);
    if ( v51 )
    {
      v79 = sub_805A8C2(v65, 8u);
      for ( m = 0; m < v65; ++m )
        v79[2 * m] = v66[m];
      sub_8050F6E((int)v79, 0, v65, v68);
    }
    else
    {
      if ( !v64 )
      {
        v80 = sub_80568A3(2);
        v46 = 8;
        if ( v80 <= 8 )
          v46 = v80;
        v64 = v46;
      }
      v81 = 29826161;
      v47 = v64;
      if ( v64 >= 0x1C71C71 )
        v47 = v81;
      v64 = v47;
      sub_8051367((char **)v66, v65, v68, v47);
    }
    if ( byte_8065840 && sub_805B593(stdin) == -1 )
    {
      v48 = gettext("close failed");
      sub_804A4B6((int)v48, "-");
    }
    result = 0;
  }
  return result;
}
// 805E64C: using guessed type char *off_805E64C[3];
// 805E694: using guessed type void *off_805E694;
// 806522C: using guessed type char byte_806522C;
// 80652B0: using guessed type int dword_80652B0;
// 80652BC: using guessed type char byte_80652BC;
// 80652C6: using guessed type char byte_80652C6;
// 8065360: using guessed type int optind;
// 806540D: using guessed type int dword_806540D;
// 8065411: using guessed type int dword_8065411;
// 8065415: using guessed type char byte_8065415;
// 8065416: using guessed type char byte_8065416;
// 8065835: using guessed type int dword_8065835;
// 806583D: using guessed type char byte_806583D;
// 806583E: using guessed type char byte_806583E;
// 806583F: using guessed type char byte_806583F;
// 8065840: using guessed type char byte_8065840;
// 8065841: using guessed type int dword_8065841;
// 8065849: using guessed type char byte_8065849;

//----- (0805307F) --------------------------------------------------------
void __noreturn sub_805307F()
{
  sub_804A518(1);
}

//----- (08053093) --------------------------------------------------------
int __cdecl sub_8053093(char *s, int a2, int a3, size_t a4)
{
  int result; // eax
  char v5; // [esp+13h] [ebp-15h]
  signed int i; // [esp+14h] [ebp-14h]
  signed int v7; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]

  v7 = -1;
  v5 = 0;
  n = strlen(s);
  for ( i = 0; *(_DWORD *)(4 * i + a2); ++i )
  {
    if ( !strncmp(*(const char **)(4 * i + a2), s, n) )
    {
      if ( strlen(*(const char **)(4 * i + a2)) == n )
        return i;
      if ( v7 == -1 )
      {
        v7 = i;
      }
      else if ( !a3 || memcmp((const void *)(a3 + a4 * v7), (const void *)(i * a4 + a3), a4) )
      {
        v5 = 1;
      }
    }
  }
  if ( v5 )
    result = -2;
  else
    result = v7;
  return result;
}

//----- (08053187) --------------------------------------------------------
void __cdecl sub_8053187(int a1, int a2, int a3)
{
  char *v3; // eax
  char *format; // ST2C_4
  void *v5; // ebx
  void *v6; // eax

  if ( a3 == -1 )
    v3 = gettext("invalid argument %s for %s");
  else
    v3 = gettext("ambiguous argument %s for %s");
  format = v3;
  v5 = sub_8058588(1, a1);
  v6 = sub_805819C(0, 8, a2);
  error(0, 0, format, v6, v5);
}

//----- (0805320A) --------------------------------------------------------
int __cdecl sub_805320A(int a1, int a2, size_t n)
{
  FILE *v3; // ebx
  char *v4; // eax
  void *v5; // eax
  void *v6; // eax
  int i; // [esp+18h] [ebp-10h]
  void *s1; // [esp+1Ch] [ebp-Ch]

  s1 = 0;
  v3 = stderr;
  v4 = gettext("Valid arguments are:");
  fputs_unlocked(v4, v3);
  for ( i = 0; *(_DWORD *)(4 * i + a1); ++i )
  {
    if ( i && !memcmp(s1, (const void *)(a2 + i * n), n) )
    {
      v6 = sub_80585AA(*(_DWORD *)(4 * i + a1));
      fprintf(stderr, ", %s", v6);
    }
    else
    {
      v5 = sub_80585AA(*(_DWORD *)(4 * i + a1));
      fprintf(stderr, "\n  - %s", v5);
      s1 = (void *)(i * n + a2);
    }
  }
  return putc_unlocked(10, stderr);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (08053321) --------------------------------------------------------
int __cdecl sub_8053321(int a1, char *s, int a3, int a4, size_t n, int a6)
{
  int v7; // [esp+1Ch] [ebp-Ch]

  v7 = sub_8053093(s, a3, a4, n);
  if ( v7 >= 0 )
    return v7;
  sub_8053187(a1, (int)s, v7);
  sub_805320A(a3, a4, n);
  ((void (*)(void))a6)();
  return -1;
}

//----- (08053421) --------------------------------------------------------
int sub_8053421()
{
  void *v0; // ebx
  int *v1; // eax
  int *v2; // eax
  int result; // eax
  char *v4; // [esp+2Ch] [ebp-Ch]

  if ( sub_805C289(stdout) && (byte_8065995 != 1 || *__errno_location() != 32) )
  {
    v4 = gettext("write error");
    if ( dword_8065991 )
    {
      v0 = sub_8058335(dword_8065991);
      v1 = __errno_location();
      error(0, *v1, "%s: %s", v0, v4);
    }
    else
    {
      v2 = __errno_location();
      error(0, *v2, "%s", v4);
    }
    _exit(status);
  }
  result = sub_805C289(stderr);
  if ( result )
    _exit(status);
  return result;
}
// 8065991: using guessed type int dword_8065991;
// 8065995: using guessed type char byte_8065995;

//----- (08053505) --------------------------------------------------------
_DWORD *__cdecl sub_8053505(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 1732584193;
  a1[1] = -271733879;
  a1[2] = -1732584194;
  a1[3] = 271733878;
  a1[5] = 0;
  a1[4] = a1[5];
  result = a1;
  a1[6] = 0;
  return result;
}

//----- (08053551) --------------------------------------------------------
_DWORD *__cdecl sub_8053551(_DWORD *a1, int a2)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = a2;
  return result;
}

//----- (0805355E) --------------------------------------------------------
_DWORD *__cdecl sub_805355E(int *a1, _DWORD *a2)
{
  sub_8053551(a2, *a1);
  sub_8053551(a2 + 1, a1[1]);
  sub_8053551(a2 + 2, a1[2]);
  sub_8053551(a2 + 3, a1[3]);
  return a2;
}

//----- (080535CB) --------------------------------------------------------
_DWORD *__cdecl sub_80535CB(int *a1, _DWORD *a2)
{
  signed int v2; // eax
  unsigned int v4; // [esp+18h] [ebp-10h]
  signed int v5; // [esp+1Ch] [ebp-Ch]

  v4 = a1[6];
  if ( v4 > 0x37 )
    v2 = 32;
  else
    v2 = 16;
  v5 = v2;
  a1[4] += v4;
  if ( a1[4] < v4 )
    ++a1[5];
  a1[v2 + 5] = 8 * a1[4];
  a1[v2 + 6] = *((_QWORD *)a1 + 2) >> 29;
  memcpy((char *)a1 + v4 + 28, &unk_805F5A0, 4 * (v2 + 1073741822) - v4);
  sub_8053A4E(a1 + 7, 4 * v5, a1);
  return sub_805355E(a1, a2);
}

//----- (08053861) --------------------------------------------------------
int *__cdecl sub_8053861(void *src, size_t a2, int a3)
{
  int *result; // eax
  int v4; // eax
  int *v5; // eax
  size_t v6; // ST14_4
  size_t v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]

  result = *(int **)(a3 + 24);
  if ( result )
  {
    v8 = *(_DWORD *)(a3 + 24);
    v4 = a2;
    if ( 128 - v8 <= a2 )
      v4 = 128 - v8;
    n = v4;
    memcpy((void *)(v8 + a3 + 28), src, v4);
    *(_DWORD *)(a3 + 24) += n;
    if ( *(_DWORD *)(a3 + 24) > 0x40u )
    {
      sub_8053A4E((int *)(a3 + 28), *(_DWORD *)(a3 + 24) & 0xFFFFFFC0, (int *)a3);
      *(_DWORD *)(a3 + 24) &= 0x3Fu;
      memcpy((void *)(a3 + 28), (const void *)(a3 + 28 + ((v8 + n) & 0xFFFFFFC0)), *(_DWORD *)(a3 + 24));
    }
    src = (char *)src + n;
    result = (int *)n;
    a2 -= n;
  }
  if ( a2 > 0x3F )
  {
    result = (int *)((unsigned __int8)src & 3);
    if ( (unsigned __int8)src & 3 )
    {
      while ( a2 > 0x40 )
      {
        v5 = (int *)memcpy((void *)(a3 + 28), src, 0x40u);
        result = sub_8053A4E(v5, 0x40u, (int *)a3);
        src = (char *)src + 64;
        a2 -= 64;
      }
    }
    else
    {
      sub_8053A4E((int *)src, a2 & 0xFFFFFFC0, (int *)a3);
      result = (int *)(a2 & 0xFFFFFFC0);
      src = (char *)src + (a2 & 0xFFFFFFC0);
      a2 &= 0x3Fu;
    }
  }
  if ( a2 )
  {
    v6 = *(_DWORD *)(a3 + 24);
    memcpy((void *)(v6 + a3 + 28), src, a2);
    v7 = a2 + v6;
    if ( v7 > 0x3F )
    {
      sub_8053A4E((int *)(a3 + 28), 0x40u, (int *)a3);
      v7 -= 64;
      memcpy((void *)(a3 + 28), (const void *)(a3 + 92), v7);
    }
    result = (int *)a3;
    *(_DWORD *)(a3 + 24) = v7;
  }
  return result;
}

//----- (08053A4E) --------------------------------------------------------
int *__cdecl sub_8053A4E(int *a1, unsigned int a2, int *a3)
{
  int v3; // ST30_4
  int v4; // ST34_4
  int v5; // ST38_4
  int v6; // ST3C_4
  int v7; // ST40_4
  int v8; // ST10_4
  int *v9; // ST0C_4
  int v10; // ST10_4
  int v11; // ST44_4
  int v12; // ST1C_4
  int v13; // ST48_4
  int v14; // ST18_4
  int v15; // ST4C_4
  int v16; // ST14_4
  int v17; // ST50_4
  int v18; // ST10_4
  int v19; // ST54_4
  int v20; // ST1C_4
  int v21; // ST58_4
  int v22; // ST18_4
  int v23; // ST5C_4
  int v24; // ST14_4
  int v25; // ST60_4
  int v26; // ST10_4
  int v27; // ST64_4
  int v28; // ST1C_4
  int v29; // ST68_4
  int v30; // ST18_4
  int v31; // ST6C_4
  int v32; // ST14_4
  int v33; // ST70_4
  int v34; // ST10_4
  int v35; // ST74_4
  int v36; // ST1C_4
  int v37; // ST78_4
  int v38; // ST18_4
  int v39; // ST7C_4
  int v40; // ST14_4
  int v41; // ST10_4
  int v42; // ST1C_4
  int v43; // ST18_4
  int v44; // ST14_4
  int v45; // ST10_4
  int v46; // ST1C_4
  int v47; // ST18_4
  int v48; // ST14_4
  int v49; // ST10_4
  int v50; // ST1C_4
  int v51; // ST18_4
  int v52; // ST14_4
  int v53; // ST10_4
  int v54; // ST1C_4
  int v55; // ST18_4
  int v56; // ST14_4
  int v57; // ST10_4
  int v58; // ST1C_4
  int v59; // ST18_4
  int v60; // ST14_4
  int v61; // ST10_4
  int v62; // ST1C_4
  int v63; // ST18_4
  int v64; // ST14_4
  int v65; // ST10_4
  int v66; // ST1C_4
  int v67; // ST18_4
  int v68; // ST14_4
  int v69; // ST10_4
  int v70; // ST1C_4
  int v71; // ST18_4
  int v72; // ST14_4
  int v73; // ST10_4
  int v74; // ST1C_4
  int v75; // ST18_4
  int v76; // ST14_4
  int v77; // ST10_4
  int v78; // ST1C_4
  int v79; // ST18_4
  int v80; // ST14_4
  int v81; // ST10_4
  int v82; // ST1C_4
  int v83; // ST18_4
  int v84; // ST14_4
  int v85; // ST10_4
  int v86; // ST1C_4
  int v87; // ST18_4
  int v88; // ST14_4
  int *result; // eax
  int *v90; // [esp+Ch] [ebp-74h]
  int v91; // [esp+10h] [ebp-70h]
  int v92; // [esp+14h] [ebp-6Ch]
  int v93; // [esp+18h] [ebp-68h]
  int v94; // [esp+1Ch] [ebp-64h]

  v90 = a1;
  v91 = *a3;
  v92 = a3[1];
  v93 = a3[2];
  v94 = a3[3];
  a3[4] += a2;
  a3[5] += a3[4] < a2;
  while ( v90 < &a1[a2 >> 2] )
  {
    v3 = v91;
    v4 = v92;
    v5 = v93;
    v6 = v94;
    v7 = *v90;
    v8 = (v94 ^ v92 & (v93 ^ v94)) + *v90 + v91 - 680876936;
    v9 = v90 + 1;
    v10 = v92 + __ROR4__(v8, 25);
    v11 = *v9;
    ++v9;
    v12 = v10 + __ROR4__((v93 ^ v10 & (v92 ^ v93)) + v11 + v94 - 389564586, 20);
    v13 = *v9;
    ++v9;
    v14 = v12 + __ROR4__((v92 ^ v12 & (v10 ^ v92)) + v13 + v93 + 606105819, 15);
    v15 = *v9;
    ++v9;
    v16 = v14 + __ROR4__((v10 ^ v14 & (v12 ^ v10)) + v15 + v92 - 1044525330, 10);
    v17 = *v9;
    ++v9;
    v18 = v16 + __ROR4__((v12 ^ v16 & (v14 ^ v12)) + v17 + v10 - 176418897, 25);
    v19 = *v9;
    ++v9;
    v20 = v18 + __ROR4__((v14 ^ v18 & (v16 ^ v14)) + v19 + v12 + 1200080426, 20);
    v21 = *v9;
    ++v9;
    v22 = v20 + __ROR4__((v16 ^ v20 & (v18 ^ v16)) + v21 + v14 - 1473231341, 15);
    v23 = *v9;
    ++v9;
    v24 = v22 + __ROR4__((v18 ^ v22 & (v20 ^ v18)) + v23 + v16 - 45705983, 10);
    v25 = *v9;
    ++v9;
    v26 = v24 + __ROR4__((v20 ^ v24 & (v22 ^ v20)) + v25 + v18 + 1770035416, 25);
    v27 = *v9;
    ++v9;
    v28 = v26 + __ROR4__((v22 ^ v26 & (v24 ^ v22)) + v27 + v20 - 1958414417, 20);
    v29 = *v9;
    ++v9;
    v30 = v28 + __ROR4__((v24 ^ v28 & (v26 ^ v24)) + v29 + v22 - 42063, 15);
    v31 = *v9;
    ++v9;
    v32 = v30 + __ROR4__((v26 ^ v30 & (v28 ^ v26)) + v31 + v24 - 1990404162, 10);
    v33 = *v9;
    ++v9;
    v34 = v32 + __ROR4__((v28 ^ v32 & (v30 ^ v28)) + v33 + v26 + 1804603682, 25);
    v35 = *v9;
    ++v9;
    v36 = v34 + __ROR4__((v30 ^ v34 & (v32 ^ v30)) + v35 + v28 - 40341101, 20);
    v37 = *v9;
    ++v9;
    v38 = v36 + __ROR4__((v32 ^ v36 & (v34 ^ v32)) + v37 + v30 - 1502002290, 15);
    v39 = *v9;
    v90 = v9 + 1;
    v40 = v38 + __ROR4__((v34 ^ v38 & (v36 ^ v34)) + v39 + v32 + 1236535329, 10);
    v41 = v40 + __ROR4__(v11 + (v38 ^ v36 & (v40 ^ v38)) + v34 - 165796510, 27);
    v42 = v41 + __ROR4__(v21 + (v40 ^ v38 & (v41 ^ v40)) + v36 - 1069501632, 23);
    v43 = v42 + __ROR4__(v31 + (v41 ^ v40 & (v42 ^ v41)) + v38 + 643717713, 18);
    v44 = v43 + __ROR4__(v7 + (v42 ^ v41 & (v43 ^ v42)) + v40 - 373897302, 12);
    v45 = v44 + __ROR4__(v19 + (v43 ^ v42 & (v44 ^ v43)) + v41 - 701558691, 27);
    v46 = v45 + __ROR4__(v29 + (v44 ^ v43 & (v45 ^ v44)) + v42 + 38016083, 23);
    v47 = v46 + __ROR4__(v39 + (v45 ^ v44 & (v46 ^ v45)) + v43 - 660478335, 18);
    v48 = v47 + __ROR4__(v17 + (v46 ^ v45 & (v47 ^ v46)) + v44 - 405537848, 12);
    v49 = v48 + __ROR4__(v27 + (v47 ^ v46 & (v48 ^ v47)) + v45 + 568446438, 27);
    v50 = v49 + __ROR4__(v37 + (v48 ^ v47 & (v49 ^ v48)) + v46 - 1019803690, 23);
    v51 = v50 + __ROR4__(v15 + (v49 ^ v48 & (v50 ^ v49)) + v47 - 187363961, 18);
    v52 = v51 + __ROR4__(v25 + (v50 ^ v49 & (v51 ^ v50)) + v48 + 1163531501, 12);
    v53 = v52 + __ROR4__(v35 + (v51 ^ v50 & (v52 ^ v51)) + v49 - 1444681467, 27);
    v54 = v53 + __ROR4__(v13 + (v52 ^ v51 & (v53 ^ v52)) + v50 - 51403784, 23);
    v55 = v54 + __ROR4__(v23 + (v53 ^ v52 & (v54 ^ v53)) + v51 + 1735328473, 18);
    v56 = v55 + __ROR4__(v33 + (v54 ^ v53 & (v55 ^ v54)) + v52 - 1926607734, 12);
    v57 = v56 + __ROR4__(v19 + (v54 ^ v56 ^ v55) + v53 - 378558, 28);
    v58 = v57 + __ROR4__(v25 + (v55 ^ v57 ^ v56) + v54 - 2022574463, 21);
    v59 = v58 + __ROR4__(v31 + (v56 ^ v58 ^ v57) + v55 + 1839030562, 16);
    v60 = v59 + __ROR4__(v37 + (v57 ^ v59 ^ v58) + v56 - 35309556, 9);
    v61 = v60 + __ROR4__(v11 + (v58 ^ v60 ^ v59) + v57 - 1530992060, 28);
    v62 = v61 + __ROR4__(v17 + (v59 ^ v61 ^ v60) + v58 + 1272893353, 21);
    v63 = v62 + __ROR4__(v23 + (v60 ^ v62 ^ v61) + v59 - 155497632, 16);
    v64 = v63 + __ROR4__(v29 + (v61 ^ v63 ^ v62) + v60 - 1094730640, 9);
    v65 = v64 + __ROR4__(v35 + (v62 ^ v64 ^ v63) + v61 + 681279174, 28);
    v66 = v65 + __ROR4__(v7 + (v63 ^ v65 ^ v64) + v62 - 358537222, 21);
    v67 = v66 + __ROR4__(v15 + (v64 ^ v66 ^ v65) + v63 - 722521979, 16);
    v68 = v67 + __ROR4__(v21 + (v65 ^ v67 ^ v66) + v64 + 76029189, 9);
    v69 = v68 + __ROR4__(v27 + (v66 ^ v68 ^ v67) + v65 - 640364487, 28);
    v70 = v69 + __ROR4__(v33 + (v67 ^ v69 ^ v68) + v66 - 421815835, 21);
    v71 = v70 + __ROR4__(v39 + (v68 ^ v70 ^ v69) + v67 + 530742520, 16);
    v72 = v71 + __ROR4__(v13 + (v69 ^ v71 ^ v70) + v68 - 995338651, 9);
    v73 = v72 + __ROR4__(v7 + (v71 ^ (v72 | ~v70)) + v69 - 198630844, 26);
    v74 = v73 + __ROR4__(v23 + (v72 ^ (v73 | ~v71)) + v70 + 1126891415, 22);
    v75 = v74 + __ROR4__(v37 + (v73 ^ (v74 | ~v72)) + v71 - 1416354905, 17);
    v76 = v75 + __ROR4__(v19 + (v74 ^ (v75 | ~v73)) + v72 - 57434055, 11);
    v77 = v76 + __ROR4__(v33 + (v75 ^ (v76 | ~v74)) + v73 + 1700485571, 26);
    v78 = v77 + __ROR4__(v15 + (v76 ^ (v77 | ~v75)) + v74 - 1894986606, 22);
    v79 = v78 + __ROR4__(v29 + (v77 ^ (v78 | ~v76)) + v75 - 1051523, 17);
    v80 = v79 + __ROR4__(v11 + (v78 ^ (v79 | ~v77)) + v76 - 2054922799, 11);
    v81 = v80 + __ROR4__(v25 + (v79 ^ (v80 | ~v78)) + v77 + 1873313359, 26);
    v82 = v81 + __ROR4__(v39 + (v80 ^ (v81 | ~v79)) + v78 - 30611744, 22);
    v83 = v82 + __ROR4__(v21 + (v81 ^ (v82 | ~v80)) + v79 - 1560198380, 17);
    v84 = v83 + __ROR4__(v35 + (v82 ^ (v83 | ~v81)) + v80 + 1309151649, 11);
    v85 = v84 + __ROR4__(v17 + (v83 ^ (v84 | ~v82)) + v81 - 145523070, 26);
    v86 = v85 + __ROR4__(v31 + (v84 ^ (v85 | ~v83)) + v82 - 1120210379, 22);
    v87 = v86 + __ROR4__(v13 + (v85 ^ (v86 | ~v84)) + v83 + 718787259, 17);
    v88 = v87 + __ROR4__(v27 + (v86 ^ (v87 | ~v85)) + v84 - 343485551, 11);
    v91 = v3 + v85;
    v92 = v4 + v88;
    v93 = v5 + v87;
    v94 = v6 + v86;
  }
  *a3 = v91;
  a3[1] = v92;
  a3[2] = v93;
  result = a3;
  a3[3] = v94;
  return result;
}

//----- (08054718) --------------------------------------------------------
int __cdecl sub_8054718(int a1, int a2, int a3, int a4, int a5, int a6)
{
  return posix_fadvise64(a1, a2, a3, a4, a5, a6);
}
// 8049E60: using guessed type int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (08054769) --------------------------------------------------------
void __cdecl sub_8054769(FILE *stream, int a2)
{
  int v2; // eax

  if ( stream )
  {
    v2 = fileno(stream);
    sub_8054718(v2, 0, 0, 0, 0, a2);
  }
}

//----- (080547B1) --------------------------------------------------------
_BYTE *__cdecl sub_80547B1(_BYTE **a1)
{
  char v2; // [esp+1Bh] [ebp-Dh]
  _BYTE *v3; // [esp+1Ch] [ebp-Ch]

  v3 = 0;
  v2 = 0;
  while ( **a1 )
  {
    if ( v2 )
    {
      v2 = 0;
      if ( (unsigned __int8)sub_805C05C((char)**a1) ^ 1 && **a1 != 126 )
        v3 = 0;
    }
    else if ( **a1 == 46 )
    {
      v2 = 1;
      if ( !v3 )
        v3 = *a1;
    }
    else if ( (unsigned __int8)sub_805C02C((char)**a1) ^ 1 && **a1 != 126 )
    {
      v3 = 0;
    }
    ++*a1;
  }
  return v3;
}

//----- (0805486F) --------------------------------------------------------
int __cdecl sub_805486F(unsigned __int8 a1)
{
  if ( (unsigned __int8)sub_805C0E0(a1) )
    return 0;
  if ( (unsigned __int8)sub_805C05C(a1) )
    return a1;
  if ( a1 == 126 )
    return -1;
  return a1 + 256;
}

//----- (080548C0) --------------------------------------------------------
int __cdecl sub_80548C0(int a1, unsigned int a2, int a3, unsigned int a4)
{
  int v4; // eax
  int v5; // eax
  unsigned int v7; // [esp+1Ch] [ebp-1Ch]
  unsigned int v8; // [esp+20h] [ebp-18h]
  int v9; // [esp+24h] [ebp-14h]
  int v10; // [esp+28h] [ebp-10h]

  v7 = 0;
  v8 = 0;
  while ( v7 < a2 || v8 < a4 )
  {
    v9 = 0;
    while ( v7 < a2 && (unsigned __int8)sub_805C0E0(*(char *)(a1 + v7)) ^ 1
         || v8 < a4 && (unsigned __int8)sub_805C0E0(*(char *)(a3 + v8)) ^ 1 )
    {
      if ( v7 == a2 )
        v4 = 0;
      else
        v4 = sub_805486F(*(_BYTE *)(a1 + v7));
      v10 = v4;
      if ( v8 == a4 )
        v5 = 0;
      else
        v5 = sub_805486F(*(_BYTE *)(a3 + v8));
      if ( v10 != v5 )
        return v10 - v5;
      ++v7;
      ++v8;
    }
    while ( *(_BYTE *)(a1 + v7) == 48 )
      ++v7;
    while ( *(_BYTE *)(a3 + v8) == 48 )
      ++v8;
    while ( (unsigned __int8)sub_805C0E0(*(char *)(a1 + v7)) && (unsigned __int8)sub_805C0E0(*(char *)(a3 + v8)) )
    {
      if ( !v9 )
        v9 = *(char *)(a1 + v7) - *(char *)(a3 + v8);
      ++v7;
      ++v8;
    }
    if ( (unsigned __int8)sub_805C0E0(*(char *)(a1 + v7)) )
      return 1;
    if ( (unsigned __int8)sub_805C0E0(*(char *)(a3 + v8)) )
      return -1;
    if ( v9 )
      return v9;
  }
  return 0;
}

//----- (08054AA0) --------------------------------------------------------
int __cdecl sub_8054AA0(char *s1, char *s2)
{
  int result; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // [esp+10h] [ebp-28h]
  char *v6; // [esp+14h] [ebp-24h]
  size_t n; // [esp+18h] [ebp-20h]
  unsigned int v8; // [esp+1Ch] [ebp-1Ch]
  int v9; // [esp+20h] [ebp-18h]
  char *v10; // [esp+24h] [ebp-14h]
  char *v11; // [esp+28h] [ebp-10h]
  int v12; // [esp+2Ch] [ebp-Ch]

  v9 = strcmp(s1, s2);
  if ( !v9 )
    return 0;
  if ( !*s1 )
    return -1;
  if ( !*s2 )
    return 1;
  if ( !strcmp(".", s1) )
    return -1;
  if ( !strcmp(".", s2) )
    return 1;
  if ( !strcmp("..", s1) )
    return -1;
  if ( !strcmp("..", s2) )
    return 1;
  if ( *s1 == 46 && *s2 != 46 )
    return -1;
  if ( *s1 != 46 && *s2 == 46 )
    return 1;
  if ( *s1 == 46 && *s2 == 46 )
  {
    ++s1;
    ++s2;
  }
  v5 = s1;
  v6 = s2;
  v10 = sub_80547B1(&v5);
  v11 = sub_80547B1(&v6);
  if ( v10 )
    v3 = v10;
  else
    v3 = v5;
  n = v3 - s1;
  if ( v11 )
    v4 = v11;
  else
    v4 = v6;
  v8 = v4 - s2;
  if ( (v10 || v11) && n == v8 && !strncmp(s1, s2, n) )
  {
    n = v5 - s1;
    v8 = v6 - s2;
  }
  v12 = sub_80548C0((int)s1, n, (int)s2, v8);
  if ( v12 )
    result = v12;
  else
    result = v9;
  return result;
}

//----- (08054CAD) --------------------------------------------------------
int __cdecl sub_8054CAD(int category)
{
  unsigned __int8 v2; // [esp+1Bh] [ebp-Dh]
  const char *s1; // [esp+1Ch] [ebp-Ch]

  v2 = 1;
  s1 = setlocale(category, 0);
  if ( s1 && (!strcmp(s1, "C") || !strcmp(s1, "POSIX")) )
    v2 = 0;
  return v2;
}

//----- (08054D0B) --------------------------------------------------------
int __cdecl sub_8054D0B(int a1)
{
  return *(_DWORD *)(a1 + 8);
}

//----- (08054D16) --------------------------------------------------------
int __cdecl sub_8054D16(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (08054D21) --------------------------------------------------------
int __cdecl sub_8054D21(int a1)
{
  return *(_DWORD *)(a1 + 16);
}

//----- (08054D2C) --------------------------------------------------------
unsigned int __cdecl sub_8054D2C(int a1)
{
  _DWORD *i; // [esp+0h] [ebp-10h]
  unsigned int v3; // [esp+4h] [ebp-Ch]
  _DWORD *v4; // [esp+8h] [ebp-8h]
  unsigned int j; // [esp+Ch] [ebp-4h]

  v3 = 0;
  for ( i = *(_DWORD **)a1; *(_DWORD *)(a1 + 4) > (unsigned int)i; i += 2 )
  {
    if ( *i )
    {
      v4 = i;
      for ( j = 1; ; ++j )
      {
        v4 = (_DWORD *)v4[1];
        if ( !v4 )
          break;
      }
      if ( j > v3 )
        v3 = j;
    }
  }
  return v3;
}

//----- (08054EE5) --------------------------------------------------------
int __cdecl sub_8054EE5(int a1, int a2)
{
  unsigned int v3; // [esp+1Ch] [ebp-Ch]

  v3 = (*(int (__cdecl **)(int, _DWORD))(a1 + 24))(a2, *(_DWORD *)(a1 + 8));
  if ( *(_DWORD *)(a1 + 8) <= v3 )
    abort();
  return 8 * v3 + *(_DWORD *)a1;
}

//----- (0805517E) --------------------------------------------------------
bool __cdecl sub_805517E(unsigned int a1)
{
  int v1; // ST08_4
  unsigned int v3; // [esp+8h] [ebp-8h]
  unsigned int v4; // [esp+Ch] [ebp-4h]

  v3 = 3;
  v4 = 9;
  while ( v4 < a1 && a1 % v3 )
  {
    v1 = v3 + 1;
    v4 += 4 * v1;
    v3 = v1 + 1;
  }
  return a1 % v3 != 0;
}

//----- (080551D5) --------------------------------------------------------
int __cdecl sub_80551D5(unsigned int a1)
{
  int i; // [esp+Ch] [ebp+8h]

  if ( a1 <= 9 )
    a1 = 10;
  for ( i = a1 | 1; i != -1 && !sub_805517E(i); i += 2 )
    ;
  return i;
}

//----- (08055246) --------------------------------------------------------
unsigned int __cdecl sub_8055246(int a1, unsigned int a2)
{
  return sub_805BF41(a1, 3) % a2;
}

//----- (08055271) --------------------------------------------------------
bool __cdecl sub_8055271(int a1, int a2)
{
  return a1 == a2;
}

//----- (0805527F) --------------------------------------------------------
signed int __cdecl sub_805527F(int a1)
{
  int v2; // [esp+8h] [ebp-8h]

  v2 = *(_DWORD *)(a1 + 20);
  if ( (_UNKNOWN *)v2 == &unk_805F5F0 )
    return 1;
  if ( *(float *)(v2 + 8) > 0.1
    && 1.0 - 0.1 > *(float *)(v2 + 8)
    && *(float *)(v2 + 12) > 0.1 + 1.0
    && *(float *)v2 >= 0.0
    && *(float *)(v2 + 4) > *(float *)v2 + 0.1
    && *(float *)(v2 + 4) <= 1.0
    && *(float *)(v2 + 8) > *(float *)v2 + 0.1 )
  {
    return 1;
  }
  *(_DWORD *)(a1 + 20) = &unk_805F5F0;
  return 0;
}

//----- (0805533B) --------------------------------------------------------
unsigned int __cdecl sub_805533B(unsigned int a1, int a2)
{
  unsigned int result; // eax
  float v3; // [esp+20h] [ebp-4h]
  unsigned int v4; // [esp+2Ch] [ebp+8h]

  if ( *(_BYTE *)(a2 + 16) != 1 )
  {
    v3 = (long double)a1 / *(float *)(a2 + 8);
    if ( v3 >= 4294967300.0 )
      return 0;
    a1 = (signed __int64)v3;
  }
  v4 = sub_80551D5(a1);
  if ( v4 <= 0x1FFFFFFF )
    result = v4;
  else
    result = 0;
  return result;
}

//----- (080553C8) --------------------------------------------------------
size_t *__cdecl sub_80553C8(unsigned int a1, void *a2, unsigned int (__cdecl *a3)(int a1, unsigned int a2), bool (__cdecl *a4)(int a1, int a2), size_t a5)
{
  size_t *result; // eax
  size_t *ptr; // [esp+1Ch] [ebp-Ch]

  if ( !a3 )
    a3 = sub_8055246;
  if ( !a4 )
    a4 = sub_8055271;
  ptr = (size_t *)malloc(0x28u);
  if ( !ptr )
    return 0;
  if ( !a2 )
    a2 = &unk_805F5F0;
  ptr[5] = (size_t)a2;
  if ( !((unsigned __int8)sub_805527F((int)ptr) ^ 1)
    && (ptr[2] = sub_805533B(a1, (int)a2)) != 0
    && (*ptr = (size_t)calloc(ptr[2], 8u)) != 0 )
  {
    ptr[1] = 8 * ptr[2] + *ptr;
    ptr[3] = 0;
    ptr[4] = 0;
    ptr[6] = (size_t)a3;
    ptr[7] = (size_t)a4;
    ptr[8] = a5;
    ptr[9] = 0;
    result = ptr;
  }
  else
  {
    free(ptr);
    result = 0;
  }
  return result;
}

//----- (080556A0) --------------------------------------------------------
void *__cdecl sub_80556A0(int a1)
{
  int v2; // [esp+1Ch] [ebp-Ch]

  if ( !*(_DWORD *)(a1 + 36) )
    return malloc(8u);
  v2 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(v2 + 4);
  return (void *)v2;
}

//----- (080556DB) --------------------------------------------------------
int __cdecl sub_80556DB(int a1, _DWORD *a2)
{
  int result; // eax

  *a2 = 0;
  a2[1] = *(_DWORD *)(a1 + 36);
  result = a1;
  *(_DWORD *)(a1 + 36) = a2;
  return result;
}

//----- (080556FE) --------------------------------------------------------
int __cdecl sub_80556FE(int a1, int a2, _DWORD *a3, char a4)
{
  int result; // eax
  _DWORD *v5; // ST2C_4
  int v6; // edx
  _DWORD *v7; // ST24_4
  _DWORD *i; // [esp+18h] [ebp-20h]
  _DWORD *v9; // [esp+1Ch] [ebp-1Ch]
  int v10; // [esp+20h] [ebp-18h]
  int v11; // [esp+28h] [ebp-10h]

  v9 = (_DWORD *)sub_8054EE5(a1, a2);
  *a3 = v9;
  if ( !*v9 )
    return 0;
  if ( *v9 == a2 || (*(unsigned __int8 (__cdecl **)(int, _DWORD))(a1 + 28))(a2, *v9) )
  {
    v11 = *v9;
    if ( a4 )
    {
      if ( v9[1] )
      {
        v5 = (_DWORD *)v9[1];
        v6 = v5[1];
        *v9 = *v5;
        v9[1] = v6;
        sub_80556DB(a1, v5);
      }
      else
      {
        *v9 = 0;
      }
    }
    result = v11;
  }
  else
  {
    for ( i = v9; ; i = (_DWORD *)i[1] )
    {
      if ( !i[1] )
        return 0;
      if ( *(_DWORD *)i[1] == a2 || (*(unsigned __int8 (__cdecl **)(int, _DWORD))(a1 + 28))(a2, *(_DWORD *)i[1]) )
        break;
    }
    v10 = *(_DWORD *)i[1];
    if ( a4 )
    {
      v7 = (_DWORD *)i[1];
      i[1] = v7[1];
      sub_80556DB(a1, v7);
    }
    result = v10;
  }
  return result;
}

//----- (0805583F) --------------------------------------------------------
signed int __cdecl sub_805583F(int a1, int a2, char a3)
{
  int *i; // [esp+18h] [ebp-20h]
  int *j; // [esp+1Ch] [ebp-1Ch]
  int v6; // [esp+20h] [ebp-18h]
  int v7; // [esp+20h] [ebp-18h]
  int *v8; // [esp+24h] [ebp-14h]
  int *v9; // [esp+24h] [ebp-14h]
  int *v10; // [esp+28h] [ebp-10h]
  _DWORD *v11; // [esp+2Ch] [ebp-Ch]

  for ( i = *(int **)a2; *(_DWORD *)(a2 + 4) > (unsigned int)i; i += 2 )
  {
    if ( *i )
    {
      for ( j = (int *)i[1]; j; j = v10 )
      {
        v6 = *j;
        v8 = (int *)sub_8054EE5(a1, *j);
        v10 = (int *)j[1];
        if ( *v8 )
        {
          j[1] = v8[1];
          v8[1] = (int)j;
        }
        else
        {
          *v8 = v6;
          ++*(_DWORD *)(a1 + 12);
          sub_80556DB(a1, j);
        }
      }
      v7 = *i;
      i[1] = 0;
      if ( !a3 )
      {
        v9 = (int *)sub_8054EE5(a1, v7);
        if ( *v9 )
        {
          v11 = sub_80556A0(a1);
          if ( !v11 )
            return 0;
          *v11 = v7;
          v11[1] = v9[1];
          v9[1] = (int)v11;
        }
        else
        {
          *v9 = v7;
          ++*(_DWORD *)(a1 + 12);
        }
        *i = 0;
        --*(_DWORD *)(a2 + 12);
      }
    }
  }
  return 1;
}

//----- (080559A9) --------------------------------------------------------
signed int __cdecl sub_80559A9(int a1, unsigned int a2)
{
  signed int result; // eax
  unsigned int nmemb; // [esp+10h] [ebp-38h]
  char *v4; // [esp+18h] [ebp-30h]
  char *v5; // [esp+1Ch] [ebp-2Ch]
  unsigned int v6; // [esp+20h] [ebp-28h]
  int v7; // [esp+24h] [ebp-24h]
  int v8; // [esp+28h] [ebp-20h]
  int v9; // [esp+2Ch] [ebp-1Ch]
  int v10; // [esp+30h] [ebp-18h]
  int v11; // [esp+34h] [ebp-14h]
  int v12; // [esp+38h] [ebp-10h]
  int v13; // [esp+3Ch] [ebp-Ch]

  nmemb = sub_805533B(a2, *(_DWORD *)(a1 + 20));
  if ( !nmemb )
    return 0;
  if ( *(_DWORD *)(a1 + 8) == nmemb )
    return 1;
  v4 = (char *)calloc(nmemb, 8u);
  if ( !v4 )
    return 0;
  v6 = nmemb;
  v5 = &v4[8 * nmemb];
  v7 = 0;
  v8 = 0;
  v9 = *(_DWORD *)(a1 + 20);
  v10 = *(_DWORD *)(a1 + 24);
  v11 = *(_DWORD *)(a1 + 28);
  v12 = *(_DWORD *)(a1 + 32);
  v13 = *(_DWORD *)(a1 + 36);
  if ( (unsigned __int8)sub_805583F((int)&v4, a1, 0) )
  {
    free(*(void **)a1);
    *(_DWORD *)a1 = v4;
    *(_DWORD *)(a1 + 4) = v5;
    *(_DWORD *)(a1 + 8) = v6;
    *(_DWORD *)(a1 + 12) = v7;
    *(_DWORD *)(a1 + 36) = v13;
    result = 1;
  }
  else
  {
    *(_DWORD *)(a1 + 36) = v13;
    if ( (unsigned __int8)sub_805583F(a1, (int)&v4, 1) ^ 1 || (unsigned __int8)sub_805583F(a1, (int)&v4, 0) ^ 1 )
      abort();
    free(v4);
    result = 0;
  }
  return result;
}

//----- (08055B5E) --------------------------------------------------------
signed int __cdecl sub_8055B5E(unsigned int *a1, int a2, _DWORD *a3)
{
  signed int result; // eax
  long double v4; // fst7
  int *v5; // [esp+2Ch] [ebp-1Ch]
  int v6; // [esp+30h] [ebp-18h]
  unsigned int v7; // [esp+34h] [ebp-14h]
  float v8; // [esp+38h] [ebp-10h]
  _DWORD *v9; // [esp+3Ch] [ebp-Ch]

  if ( !a2 )
    abort();
  v6 = sub_80556FE((int)a1, a2, &v5, 0);
  if ( v6 )
  {
    if ( a3 )
      *a3 = v6;
    result = 0;
  }
  else
  {
    if ( (long double)a1[3] > *(float *)(a1[5] + 8) * (long double)a1[2] )
    {
      sub_805527F((int)a1);
      if ( (long double)a1[3] > *(float *)(a1[5] + 8) * (long double)a1[2] )
      {
        v7 = a1[5];
        if ( *(_BYTE *)(v7 + 16) )
          v4 = (long double)a1[2] * *(float *)(v7 + 12);
        else
          v4 = (long double)a1[2] * *(float *)(v7 + 12) * *(float *)(v7 + 8);
        v8 = v4;
        if ( v8 >= 4294967300.0 )
          return -1;
        if ( (unsigned __int8)sub_80559A9((int)a1, (signed __int64)v8) ^ 1 )
          return -1;
        if ( sub_80556FE((int)a1, a2, &v5, 0) )
          abort();
      }
    }
    if ( *v5 )
    {
      v9 = sub_80556A0((int)a1);
      if ( v9 )
      {
        *v9 = a2;
        v9[1] = v5[1];
        v5[1] = (int)v9;
        ++a1[4];
        result = 1;
      }
      else
      {
        result = -1;
      }
    }
    else
    {
      *v5 = a2;
      ++a1[4];
      ++a1[3];
      result = 1;
    }
  }
  return result;
}

//----- (08055D9B) --------------------------------------------------------
int __cdecl sub_8055D9B(unsigned int *a1, int a2)
{
  int v3; // [esp+18h] [ebp-10h]
  int v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_8055B5E(a1, a2, &v3);
  if ( v4 == -1 )
    return 0;
  if ( v4 )
    return a2;
  return v3;
}

//----- (08055DDA) --------------------------------------------------------
int __cdecl sub_8055DDA(int a1, int a2)
{
  long double v3; // fst7
  _DWORD *v4; // [esp+28h] [ebp-20h]
  void *ptr; // [esp+2Ch] [ebp-1Ch]
  int v6; // [esp+30h] [ebp-18h]
  int v7; // [esp+34h] [ebp-14h]
  unsigned int v8; // [esp+38h] [ebp-10h]
  void *v9; // [esp+3Ch] [ebp-Ch]

  v6 = sub_80556FE(a1, a2, &v4, 1);
  if ( !v6 )
    return 0;
  --*(_DWORD *)(a1 + 16);
  if ( !*v4
    && **(float **)(a1 + 20) * (long double)*(unsigned int *)(a1 + 8) > (long double)(unsigned int)--*(_DWORD *)(a1 + 12) )
  {
    sub_805527F(a1);
    if ( **(float **)(a1 + 20) * (long double)*(unsigned int *)(a1 + 8) > (long double)*(unsigned int *)(a1 + 12) )
    {
      v7 = *(_DWORD *)(a1 + 20);
      if ( *(_BYTE *)(v7 + 16) )
        v3 = (long double)*(unsigned int *)(a1 + 8) * *(float *)(v7 + 4);
      else
        v3 = (long double)*(unsigned int *)(a1 + 8) * *(float *)(v7 + 4) * *(float *)(v7 + 8);
      v8 = (signed __int64)v3;
      if ( (unsigned __int8)sub_80559A9(a1, v8) ^ 1 )
      {
        for ( ptr = *(void **)(a1 + 36); ptr; ptr = v9 )
        {
          v9 = (void *)*((_DWORD *)ptr + 1);
          free(ptr);
        }
        *(_DWORD *)(a1 + 36) = 0;
      }
    }
  }
  return v6;
}

//----- (08055FA6) --------------------------------------------------------
_DWORD *__cdecl sub_8055FA6(int (*a1)(), unsigned int a2)
{
  int (*v2)(); // eax
  _DWORD *v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_805A7FD(0x10u);
  if ( !a2 )
    a2 = 1;
  *v4 = sub_805A6F0(a2, 4u);
  *(_DWORD *)*v4 = 0;
  v4[1] = a2;
  v4[2] = 0;
  if ( a1 )
    v2 = a1;
  else
    v2 = sub_805601B;
  v4[3] = v2;
  return v4;
}

//----- (0805601B) --------------------------------------------------------
int sub_805601B()
{
  return 0;
}

//----- (08056025) --------------------------------------------------------
void __cdecl sub_8056025(void *ptr)
{
  free(*(void **)ptr);
  free(ptr);
}

//----- (08056045) --------------------------------------------------------
int __cdecl sub_8056045(int a1, int a2)
{
  _DWORD *v2; // edx

  if ( (unsigned int)(*(_DWORD *)(a1 + 4) - 1) <= *(_DWORD *)(a1 + 8) )
    *(_DWORD *)a1 = sub_805A753(*(void **)a1, a1 + 4, 4);
  v2 = *(_DWORD **)a1;
  v2[++*(_DWORD *)(a1 + 8)] = a2;
  sub_805622D(*(_DWORD *)a1, *(_DWORD *)(a1 + 8), *(int (__cdecl **)(_DWORD, int))(a1 + 12));
  return 0;
}

//----- (080560CE) --------------------------------------------------------
int __cdecl sub_80560CE(int *a1)
{
  int v2; // ST1C_4
  _DWORD *v3; // ebx
  int v4; // esi
  int v5; // eax

  if ( !a1[2] )
    return 0;
  v2 = *(_DWORD *)(*a1 + 4);
  v3 = (_DWORD *)(*a1 + 4);
  v4 = *a1;
  v5 = a1[2];
  a1[2] = v5 - 1;
  *v3 = *(_DWORD *)(v4 + 4 * v5);
  sub_805614A(*a1, a1[2], 1u, (int (__cdecl *)(_DWORD, int))a1[3]);
  return v2;
}

//----- (0805614A) --------------------------------------------------------
unsigned int __cdecl sub_805614A(int a1, unsigned int a2, unsigned int a3, int (__cdecl *a4)(_DWORD, int))
{
  unsigned int i; // [esp+14h] [ebp-14h]
  int v6; // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]

  v7 = *(_DWORD *)(4 * a3 + a1);
  for ( i = a3; a2 >> 1 >= i; i = v6 )
  {
    v6 = 2 * i;
    if ( 2 * i < a2 && a4(*(_DWORD *)(8 * i + a1), *(_DWORD *)(4 * (2 * i + 1) + a1)) < 0 )
      ++v6;
    if ( a4(*(_DWORD *)(4 * v6 + a1), v7) <= 0 )
      break;
    *(_DWORD *)(a1 + 4 * i) = *(_DWORD *)(4 * v6 + a1);
  }
  *(_DWORD *)(a1 + 4 * i) = v7;
  return i;
}

//----- (0805622D) --------------------------------------------------------
int __cdecl sub_805622D(int a1, unsigned int a2, int (__cdecl *a3)(_DWORD, int))
{
  int result; // eax
  unsigned int v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]

  v4 = a2;
  v5 = *(_DWORD *)(4 * a2 + a1);
  while ( v4 != 1 && a3(*(_DWORD *)(4 * (v4 >> 1) + a1), v5) <= 0 )
  {
    *(_DWORD *)(a1 + 4 * v4) = *(_DWORD *)(4 * (v4 >> 1) + a1);
    v4 >>= 1;
  }
  result = v5;
  *(_DWORD *)(a1 + 4 * v4) = v5;
  return result;
}

//----- (080562BD) --------------------------------------------------------
int __cdecl sub_80562BD(int a1, int a2)
{
  int v3; // [esp+Ch] [ebp-4h]

  v3 = a2 + 11;
  *(_BYTE *)(a2 + 11) = 0;
  if ( a1 >= 0 )
  {
    do
    {
      *(_BYTE *)--v3 = (char)a1 % 10 + 48;
      a1 /= 10;
    }
    while ( a1 );
  }
  else
  {
    do
    {
      *(_BYTE *)--v3 = 48 - (char)a1 % 10;
      a1 /= 10;
    }
    while ( a1 );
    *(_BYTE *)--v3 = 45;
  }
  return v3;
}

//----- (08056397) --------------------------------------------------------
int __cdecl sub_8056397(unsigned int a1, int a2)
{
  int v3; // [esp+Ch] [ebp-4h]

  v3 = a2 + 10;
  *(_BYTE *)(a2 + 10) = 0;
  do
  {
    *(_BYTE *)--v3 = a1 % 0xA + 48;
    a1 /= 0xAu;
  }
  while ( a1 );
  return v3;
}

//----- (080563F5) --------------------------------------------------------
int __cdecl sub_80563F5(signed __int64 a1, int a2)
{
  signed __int64 v3; // [esp+18h] [ebp-20h]
  int v4; // [esp+2Ch] [ebp-Ch]

  v3 = a1;
  v4 = a2 + 20;
  *(_BYTE *)(a2 + 20) = 0;
  do
  {
    *(_BYTE *)--v4 = sub_805CE91(v3, 10LL) + 48;
    v3 = sub_805CD71(v3, 0xAu, 0);
  }
  while ( v3 );
  return v4;
}

//----- (080564A8) --------------------------------------------------------
int __cdecl sub_80564A8(char *a1, int a2, char a3)
{
  signed int v3; // eax
  char *v5; // eax
  unsigned __int8 v6; // [esp+2Bh] [ebp-2Dh]
  wint_t wc; // [esp+2Ch] [ebp-2Ch]
  char *v8; // [esp+30h] [ebp-28h]
  int v9; // [esp+34h] [ebp-24h]
  size_t v10; // [esp+38h] [ebp-20h]
  char *v11; // [esp+3Ch] [ebp-1Ch]
  int v12; // [esp+40h] [ebp-18h]
  mbstate_t s; // [esp+44h] [ebp-14h]
  unsigned int v14; // [esp+4Ch] [ebp-Ch]

  v14 = __readgsdword(0x14u);
  v8 = a1;
  v11 = &a1[a2];
  v9 = 0;
  if ( __ctype_get_mb_cur_max() <= 1 )
  {
    while ( 1 )
    {
      do
      {
        while ( 1 )
        {
          if ( v8 >= v11 )
            return v9;
          v5 = v8++;
          v6 = *v5;
          if ( !((*__ctype_b_loc())[v6] & 0x4000) )
            break;
          if ( v9 == 0x7FFFFFFF )
            return 0x7FFFFFFF;
          ++v9;
        }
        if ( a3 & 2 )
          return -1;
      }
      while ( (*__ctype_b_loc())[v6] & 2 );
      if ( v9 == 0x7FFFFFFF )
        return 0x7FFFFFFF;
      ++v9;
    }
  }
  while ( 1 )
  {
LABEL_31:
    if ( v8 >= v11 )
      return v9;
    v3 = *v8;
    if ( v3 > 63 )
      break;
    if ( v3 < 37 && (unsigned int)(v3 - 32) > 3 )
      goto LABEL_11;
LABEL_10:
    ++v8;
    ++v9;
  }
  if ( v3 >= 65 && (v3 <= 95 || (unsigned int)(v3 - 97) <= 0x1D) )
    goto LABEL_10;
LABEL_11:
  memset(&s, 0, 8u);
  while ( 1 )
  {
    v10 = sub_805B90B((wchar_t *)&wc, v8, v11 - v8, &s);
    if ( v10 == -1 )
    {
      if ( !(a3 & 1) )
      {
        ++v8;
        ++v9;
        goto LABEL_31;
      }
      return -1;
    }
    if ( v10 == -2 )
      break;
    if ( !v10 )
      v10 = 1;
    v12 = wcwidth(wc);
    if ( v12 < 0 )
    {
      if ( a3 & 2 )
        return -1;
      if ( !iswcntrl(wc) )
      {
        if ( v9 == 0x7FFFFFFF )
          return 0x7FFFFFFF;
        ++v9;
      }
    }
    else
    {
      if ( 0x7FFFFFFF - v9 < v12 )
        return 0x7FFFFFFF;
      v9 += v12;
    }
    v8 += v10;
    if ( mbsinit(&s) )
      goto LABEL_31;
  }
  if ( !(a3 & 1) )
  {
    v8 = v11;
    ++v9;
    goto LABEL_31;
  }
  return -1;
}
// 8049800: using guessed type int __cdecl wcwidth(_DWORD);

//----- (08056701) --------------------------------------------------------
int sub_8056701()
{
  int result; // eax
  int v1; // [esp+1Ch] [ebp-8Ch]
  char v2; // [esp+20h] [ebp-88h]

  if ( sched_getaffinity(0, 128, &v2) || (v1 = __sched_cpucount(128, &v2)) == 0 )
    result = 0;
  else
    result = v1;
  return result;
}
// 80498D0: using guessed type int __cdecl __sched_cpucount(_DWORD, _DWORD);
// 8049E70: using guessed type int __cdecl sched_getaffinity(_DWORD, _DWORD, _DWORD);

//----- (08056760) --------------------------------------------------------
signed int __cdecl sub_8056760(int a1)
{
  int v2; // [esp+10h] [ebp-18h]
  int v3; // [esp+14h] [ebp-14h]
  int v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]

  if ( a1 == 1 )
  {
    v3 = sub_8056701();
    if ( v3 )
      return v3;
    v4 = sysconf(84);
    if ( v4 > 0 )
      return v4;
  }
  else
  {
    v2 = sysconf(83);
    if ( v2 == 1 )
    {
      v5 = sub_8056701();
      if ( v5 )
        v2 = v5;
    }
    if ( v2 > 0 )
      return v2;
  }
  return 1;
}

//----- (080567D6) --------------------------------------------------------
int __cdecl sub_80567D6(char *nptr)
{
  int result; // eax
  char *endptr; // [esp+14h] [ebp-14h]
  int v3; // [esp+18h] [ebp-10h]
  unsigned int v4; // [esp+1Ch] [ebp-Ch]

  v3 = 0;
  if ( !nptr )
    return v3;
  while ( *nptr && (unsigned __int8)sub_805C18A(*nptr) )
    ++nptr;
  if ( !(unsigned __int8)sub_805C0E0(*nptr) )
    goto LABEL_20;
  endptr = 0;
  v4 = strtoul(nptr, &endptr, 10);
  if ( !endptr )
    goto LABEL_20;
  while ( *endptr && (unsigned __int8)sub_805C18A(*endptr) )
    ++endptr;
  if ( !*endptr )
    return v4;
  if ( *endptr == 44 )
    result = v4;
  else
LABEL_20:
    result = v3;
  return result;
}

//----- (080568A3) --------------------------------------------------------
unsigned int __cdecl sub_80568A3(int a1)
{
  char *v1; // eax
  char *v2; // eax
  unsigned int result; // eax
  unsigned int v4; // [esp+14h] [ebp-14h]
  unsigned int v5; // [esp+18h] [ebp-10h]

  v4 = -1;
  if ( a1 == 2 )
  {
    v1 = getenv("OMP_NUM_THREADS");
    v5 = sub_80567D6(v1);
    v2 = getenv("OMP_THREAD_LIMIT");
    v4 = sub_80567D6(v2);
    if ( !v4 )
      v4 = -1;
    if ( v5 )
    {
      result = v5;
      if ( v4 <= v5 )
        result = v4;
      return result;
    }
    a1 = 1;
  }
  result = sub_8056760(a1);
  if ( v4 <= result )
    result = v4;
  return result;
}

//----- (08056924) --------------------------------------------------------
long double sub_8056924()
{
  double v1; // [esp+18h] [ebp-60h]
  double v2; // [esp+20h] [ebp-58h]
  char v3; // [esp+2Ch] [ebp-4Ch]
  unsigned int v4; // [esp+3Ch] [ebp-3Ch]
  unsigned int v5; // [esp+60h] [ebp-18h]
  unsigned int v6; // [esp+6Ch] [ebp-Ch]

  v6 = __readgsdword(0x14u);
  v1 = (long double)sysconf(85);
  v2 = (long double)sysconf(30);
  if ( v1 >= 0.0 && v2 >= 0.0 )
    return v1 * v2;
  if ( sysinfo((struct sysinfo *)&v3) )
    return 67108864.0;
  return (long double)v4 * (long double)v5;
}

//----- (080569D1) --------------------------------------------------------
long double sub_80569D1()
{
  double v1; // [esp+18h] [ebp-60h]
  double v2; // [esp+20h] [ebp-58h]
  char v3; // [esp+2Ch] [ebp-4Ch]
  unsigned int v4; // [esp+40h] [ebp-38h]
  unsigned int v5; // [esp+48h] [ebp-30h]
  unsigned int v6; // [esp+60h] [ebp-18h]
  unsigned int v7; // [esp+6Ch] [ebp-Ch]

  v7 = __readgsdword(0x14u);
  v1 = (long double)sysconf(86);
  v2 = (long double)sysconf(30);
  if ( v1 >= 0.0 && v2 >= 0.0 )
    return v1 * v2;
  if ( sysinfo((struct sysinfo *)&v3) )
    return sub_8056924() / 4.0;
  return ((long double)v4 + (long double)v5) * (long double)v6;
}

//----- (08056A98) --------------------------------------------------------
int __cdecl sub_8056A98(int pipedes[2], int a2)
{
  int result; // eax
  int v3; // ST24_4
  int v4; // [esp+18h] [ebp-20h]
  int v5; // [esp+1Ch] [ebp-1Ch]
  int v6; // [esp+1Ch] [ebp-1Ch]
  int v7; // [esp+20h] [ebp-18h]
  int v8; // [esp+20h] [ebp-18h]
  int v9; // [esp+28h] [ebp-10h]
  int v10; // [esp+2Ch] [ebp-Ch]

  v9 = *pipedes;
  v10 = pipedes[1];
  if ( dword_8065999 >= 0 )
  {
    v4 = pipe2(pipedes, a2);
    if ( v4 >= 0 || *__errno_location() != 38 )
    {
      dword_8065999 = 1;
      return v4;
    }
    dword_8065999 = -1;
  }
  if ( a2 & 0xFFF7F7FF )
  {
    *__errno_location() = 22;
    result = -1;
  }
  else if ( pipe(pipedes) >= 0 )
  {
    if ( a2 & 0x800
      && ((v5 = sub_805B656(pipedes[1], 3, 0), v5 < 0)
       || sub_805B656(pipedes[1], 4, v5) == -1
       || (v6 = sub_805B656(*pipedes, 3, 0), v6 < 0)
       || sub_805B656(*pipedes, 4, v6) == -1)
      || a2 & 0x80000
      && ((v7 = sub_805B656(pipedes[1], 1, 0), v7 < 0)
       || sub_805B656(pipedes[1], 2, v7 | 1) == -1
       || (v8 = sub_805B656(*pipedes, 1, 0), v8 < 0)
       || sub_805B656(*pipedes, 2, v8 | 1) == -1) )
    {
      v3 = *__errno_location();
      close(*pipedes);
      close(pipedes[1]);
      *pipedes = v9;
      pipedes[1] = v10;
      *__errno_location() = v3;
      result = -1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}
// 8049DF0: using guessed type int __cdecl pipe2(_DWORD, _DWORD);
// 8065999: using guessed type int dword_8065999;

//----- (08056CF3) --------------------------------------------------------
int sub_8056CF3()
{
  char *endptr; // [esp+10h] [ebp-18h]
  int v2; // [esp+14h] [ebp-14h]
  char *nptr; // [esp+18h] [ebp-10h]
  int v4; // [esp+1Ch] [ebp-Ch]

  v2 = 200809;
  nptr = getenv("_POSIX2_VERSION");
  if ( nptr )
  {
    if ( *nptr )
    {
      v4 = strtol(nptr, &endptr, 10);
      if ( !*endptr )
        v2 = v4;
    }
  }
  return v2;
}

//----- (08056D51) --------------------------------------------------------
char *__cdecl sub_8056D51(char *s)
{
  char *v1; // eax
  char *result; // eax
  char *v3; // [esp+18h] [ebp-10h]
  char *s1; // [esp+1Ch] [ebp-Ch]

  if ( !s )
  {
    fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
    abort();
  }
  v3 = strrchr(s, 47);
  if ( v3 )
    v1 = v3 + 1;
  else
    v1 = s;
  s1 = v1;
  if ( v1 - s > 6 && !strncmp(v1 - 7, "/.libs/", 7u) )
  {
    s = s1;
    if ( !strncmp(s1, "lt-", 3u) )
    {
      s = s1 + 3;
      program_invocation_short_name = (int)(s1 + 3);
    }
  }
  dword_806599D = (int)s;
  result = s;
  program_invocation_name = (int)s;
  return result;
}
// 8065340: using guessed type int program_invocation_short_name;
// 8065350: using guessed type int program_invocation_name;
// 806599D: using guessed type int dword_806599D;

//----- (08056E9D) --------------------------------------------------------
int __cdecl sub_8056E9D(int *a1, unsigned __int8 a2, char a3)
{
  int *v3; // eax
  int v4; // ST10_4

  if ( a1 )
    v3 = a1;
  else
    v3 = &dword_80659AD;
  v4 = ((unsigned int)v3[(a2 >> 5) + 2] >> (a2 & 0x1F)) & 1;
  v3[(a2 >> 5) + 2] ^= (v4 ^ a3 & 1) << (a2 & 0x1F);
  return v4;
}
// 80659AD: using guessed type int dword_80659AD;

//----- (08056F47) --------------------------------------------------------
int *__cdecl sub_8056F47(int *a1, int a2, int a3)
{
  int *result; // eax

  if ( !a1 )
    a1 = &dword_80659AD;
  *a1 = 10;
  if ( !a2 || !a3 )
    abort();
  a1[10] = a2;
  result = a1;
  a1[11] = a3;
  return result;
}
// 80659AD: using guessed type int dword_80659AD;

//----- (08056F88) --------------------------------------------------------
_DWORD *__userpurge sub_8056F88@<eax>(_DWORD *a1, int a2)
{
  int v3; // [esp+0h] [ebp-38h]
  int v4; // [esp+4h] [ebp-34h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]

  memset(&v3, 0, 0x30u);
  if ( a2 == 10 )
    abort();
  *a1 = a2;
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = v6;
  a1[4] = v7;
  a1[5] = v8;
  a1[6] = v9;
  a1[7] = v10;
  a1[8] = v11;
  a1[9] = v12;
  a1[10] = v13;
  a1[11] = v14;
  return a1;
}

//----- (0805700A) --------------------------------------------------------
const char *__cdecl sub_805700A(char *msgid, int a2)
{
  const char *result; // eax
  char *v3; // [esp+18h] [ebp-10h]
  unsigned __int8 *v4; // [esp+1Ch] [ebp-Ch]

  v3 = gettext(msgid);
  if ( v3 != msgid )
    return v3;
  v4 = (unsigned __int8 *)sub_805CA29();
  if ( sub_805C224(v4, "UTF-8") )
  {
    if ( sub_805C224(v4, "GB18030") )
    {
      if ( a2 == 9 )
        result = (const char *)&unk_805F805;
      else
        result = "'";
    }
    else if ( *msgid == 96 )
    {
      result = (const char *)&unk_805F7FE;
    }
    else
    {
      result = (const char *)&unk_805F802;
    }
  }
  else if ( *msgid == 96 )
  {
    result = (const char *)&unk_805F7EE;
  }
  else
  {
    result = (const char *)&unk_805F7F2;
  }
  return result;
}

//----- (080570A5) --------------------------------------------------------
unsigned int __cdecl sub_80570A5(int a1, unsigned int a2, int a3, size_t a4, signed int a5, int a6, int a7, char *a8, char *a9)
{
  size_t v9; // ebx
  size_t v10; // eax
  bool v11; // al
  bool v12; // al
  unsigned int result; // eax
  char *v14; // [esp+2Ch] [ebp-5Ch]
  char *v15; // [esp+30h] [ebp-58h]
  char v16; // [esp+40h] [ebp-48h]
  bool v17; // [esp+41h] [ebp-47h]
  char v18; // [esp+42h] [ebp-46h]
  char v19; // [esp+43h] [ebp-45h]
  char v20; // [esp+44h] [ebp-44h]
  unsigned __int8 v21; // [esp+45h] [ebp-43h]
  char v22; // [esp+46h] [ebp-42h]
  char v23; // [esp+47h] [ebp-41h]
  char v24; // [esp+48h] [ebp-40h]
  char v25; // [esp+49h] [ebp-3Fh]
  bool v26; // [esp+4Ah] [ebp-3Eh]
  bool v27; // [esp+4Bh] [ebp-3Dh]
  wint_t wc; // [esp+4Ch] [ebp-3Ch]
  int v29; // [esp+50h] [ebp-38h]
  unsigned int v30; // [esp+54h] [ebp-34h]
  unsigned int v31; // [esp+58h] [ebp-30h]
  char *s; // [esp+5Ch] [ebp-2Ch]
  size_t n; // [esp+60h] [ebp-28h]
  unsigned int v34; // [esp+64h] [ebp-24h]
  unsigned int v35; // [esp+68h] [ebp-20h]
  size_t v36; // [esp+6Ch] [ebp-1Ch]
  unsigned int v37; // [esp+70h] [ebp-18h]
  mbstate_t ps; // [esp+74h] [ebp-14h]
  unsigned int v39; // [esp+7Ch] [ebp-Ch]

  v15 = a8;
  v14 = a9;
  v39 = __readgsdword(0x14u);
  v30 = 0;
  v31 = 0;
  s = 0;
  n = 0;
  v16 = 0;
  v27 = __ctype_get_mb_cur_max() == 1;
  v17 = (a6 & 2) != 0;
  v18 = 0;
  v19 = 0;
  v20 = 1;
  while ( 1 )
  {
    switch ( a5 )
    {
      case 0:
        v17 = 0;
        break;
      case 1:
        goto LABEL_20;
      case 2:
        goto LABEL_23;
      case 3:
        v16 = 1;
LABEL_20:
        v17 = 1;
        goto LABEL_21;
      case 4:
LABEL_21:
        if ( v17 != 1 )
          v16 = 1;
LABEL_23:
        a5 = 2;
        if ( v17 != 1 )
        {
          if ( v30 < a2 )
            *(_BYTE *)(a1 + v30) = 39;
          ++v30;
        }
        s = "'";
        n = 1;
        break;
      case 5:
        goto LABEL_4;
      case 6:
        a5 = 5;
        v17 = 1;
LABEL_4:
        if ( v17 != 1 )
        {
          if ( v30 < a2 )
            *(_BYTE *)(a1 + v30) = 34;
          ++v30;
        }
        v16 = 1;
        s = (char *)&unk_805F805;
        n = 1;
        break;
      case 7:
        v16 = 1;
        v17 = 0;
        break;
      case 8:
      case 9:
      case 10:
        if ( a5 != 10 )
        {
          v15 = (char *)sub_805700A("`", a5);
          v14 = (char *)sub_805700A("'", a5);
        }
        if ( v17 != 1 )
        {
          for ( s = v15; *s; ++s )
          {
            if ( v30 < a2 )
              *(_BYTE *)(v30 + a1) = *s;
            ++v30;
          }
        }
        v16 = 1;
        s = v14;
        n = strlen(v14);
        break;
      default:
        abort();
        return result;
    }
    v29 = 0;
    while ( 1 )
    {
      v12 = a4 == -1 ? *(_BYTE *)(a3 + v29) != 0 : v29 != a4;
      if ( !v12 )
        break;
      v23 = 0;
      v24 = 0;
      v25 = 0;
      if ( v16 && a5 != 2 && n )
      {
        v9 = v29 + n;
        if ( a4 != -1 || n <= 1 )
        {
          v10 = a4;
        }
        else
        {
          v10 = strlen((const char *)a3);
          a4 = v10;
        }
        if ( v9 <= v10 && !memcmp((const void *)(v29 + a3), s, n) )
        {
          if ( v17 )
            goto LABEL_245;
          v23 = 1;
        }
      }
      v21 = *(_BYTE *)(a3 + v29);
      switch ( v21 )
      {
        case 0u:
          if ( v16 )
          {
            if ( v17 )
              goto LABEL_245;
            v24 = 1;
            if ( a5 == 2 && v18 != 1 )
            {
              if ( v30 < a2 )
                *(_BYTE *)(a1 + v30) = 39;
              if ( ++v30 < a2 )
                *(_BYTE *)(a1 + v30) = 36;
              if ( ++v30 < a2 )
                *(_BYTE *)(a1 + v30) = 39;
              ++v30;
              v18 = 1;
            }
            if ( v30 < a2 )
              *(_BYTE *)(a1 + v30) = 92;
            ++v30;
            if ( a5 != 2 && v29 + 1 < a4 && *(_BYTE *)(v29 + 1 + a3) > 47 && *(_BYTE *)(v29 + 1 + a3) <= 57 )
            {
              if ( v30 < a2 )
                *(_BYTE *)(a1 + v30) = 48;
              if ( ++v30 < a2 )
                *(_BYTE *)(a1 + v30) = 48;
              ++v30;
            }
            v21 = 48;
          }
          else if ( a6 & 1 )
          {
            goto LABEL_219;
          }
          goto LABEL_189;
        case 7u:
          v22 = 97;
          goto LABEL_103;
        case 8u:
          v22 = 98;
          goto LABEL_103;
        case 9u:
          v22 = 116;
          goto LABEL_101;
        case 0xAu:
          v22 = 110;
          goto LABEL_101;
        case 0xBu:
          v22 = 118;
          goto LABEL_103;
        case 0xCu:
          v22 = 102;
          goto LABEL_103;
        case 0xDu:
          v22 = 114;
          goto LABEL_101;
        case 0x20u:
          goto LABEL_111;
        case 0x21u:
        case 0x22u:
        case 0x24u:
        case 0x26u:
        case 0x28u:
        case 0x29u:
        case 0x2Au:
        case 0x3Bu:
        case 0x3Cu:
        case 0x3Du:
        case 0x3Eu:
        case 0x5Bu:
        case 0x5Eu:
        case 0x60u:
        case 0x7Cu:
          goto LABEL_112;
        case 0x23u:
        case 0x7Eu:
          goto LABEL_110;
        case 0x25u:
        case 0x2Bu:
        case 0x2Cu:
        case 0x2Du:
        case 0x2Eu:
        case 0x2Fu:
        case 0x30u:
        case 0x31u:
        case 0x32u:
        case 0x33u:
        case 0x34u:
        case 0x35u:
        case 0x36u:
        case 0x37u:
        case 0x38u:
        case 0x39u:
        case 0x3Au:
        case 0x41u:
        case 0x42u:
        case 0x43u:
        case 0x44u:
        case 0x45u:
        case 0x46u:
        case 0x47u:
        case 0x48u:
        case 0x49u:
        case 0x4Au:
        case 0x4Bu:
        case 0x4Cu:
        case 0x4Du:
        case 0x4Eu:
        case 0x4Fu:
        case 0x50u:
        case 0x51u:
        case 0x52u:
        case 0x53u:
        case 0x54u:
        case 0x55u:
        case 0x56u:
        case 0x57u:
        case 0x58u:
        case 0x59u:
        case 0x5Au:
        case 0x5Du:
        case 0x5Fu:
        case 0x61u:
        case 0x62u:
        case 0x63u:
        case 0x64u:
        case 0x65u:
        case 0x66u:
        case 0x67u:
        case 0x68u:
        case 0x69u:
        case 0x6Au:
        case 0x6Bu:
        case 0x6Cu:
        case 0x6Du:
        case 0x6Eu:
        case 0x6Fu:
        case 0x70u:
        case 0x71u:
        case 0x72u:
        case 0x73u:
        case 0x74u:
        case 0x75u:
        case 0x76u:
        case 0x77u:
        case 0x78u:
        case 0x79u:
        case 0x7Au:
          v25 = 1;
          goto LABEL_189;
        case 0x27u:
          v19 = 1;
          v25 = 1;
          if ( a5 != 2 )
            goto LABEL_189;
          if ( v17 )
            goto LABEL_245;
          if ( a2 && !v31 )
          {
            v31 = a2;
            a2 = 0;
          }
          if ( v30 < a2 )
            *(_BYTE *)(a1 + v30) = 39;
          if ( ++v30 < a2 )
            *(_BYTE *)(a1 + v30) = 92;
          if ( ++v30 < a2 )
            *(_BYTE *)(a1 + v30) = 39;
          ++v30;
          v18 = 0;
          goto LABEL_189;
        case 0x3Fu:
          if ( a5 == 2 )
          {
            if ( v17 )
              goto LABEL_245;
          }
          else if ( a5 == 5 && a6 & 4 && v29 + 2 < a4 && *(_BYTE *)(v29 + 1 + a3) == 63 )
          {
            switch ( *(char *)(v29 + 2 + a3) )
            {
              case 33:
              case 39:
              case 40:
              case 41:
              case 45:
              case 47:
              case 60:
              case 61:
              case 62:
                if ( v17 )
                  goto LABEL_245;
                v21 = *(_BYTE *)(v29 + 2 + a3);
                v29 += 2;
                if ( v30 < a2 )
                  *(_BYTE *)(a1 + v30) = 63;
                if ( ++v30 < a2 )
                  *(_BYTE *)(a1 + v30) = 34;
                if ( ++v30 < a2 )
                  *(_BYTE *)(a1 + v30) = 34;
                if ( ++v30 < a2 )
                  *(_BYTE *)(a1 + v30) = 63;
                ++v30;
                break;
              default:
                goto LABEL_189;
            }
          }
          goto LABEL_189;
        case 0x5Cu:
          v22 = *(_BYTE *)(a3 + v29);
          if ( a5 == 2 )
          {
            if ( v17 )
              goto LABEL_245;
          }
          else
          {
            if ( v16 && v17 && n )
              goto LABEL_208;
LABEL_101:
            if ( a5 == 2 && v17 )
              goto LABEL_245;
LABEL_103:
            if ( v16 )
            {
              v21 = v22;
            }
            else
            {
LABEL_189:
              if ( ((v16 != 1 || a5 == 2) && v17 != 1 || !a7
                                                      || !((*(_DWORD *)(4 * (v21 >> 5) + a7) >> (v21 & 0x1F)) & 1))
                && v23 != 1 )
              {
                goto LABEL_208;
              }
            }
            if ( v17 )
              goto LABEL_245;
            v24 = 1;
            if ( a5 == 2 && v18 != 1 )
            {
              if ( v30 < a2 )
                *(_BYTE *)(a1 + v30) = 39;
              if ( ++v30 < a2 )
                *(_BYTE *)(a1 + v30) = 36;
              if ( ++v30 < a2 )
                *(_BYTE *)(a1 + v30) = 39;
              ++v30;
              v18 = 1;
            }
            if ( v30 < a2 )
              *(_BYTE *)(a1 + v30) = 92;
            ++v30;
          }
LABEL_208:
          if ( v18 && v24 != 1 )
          {
            if ( v30 < a2 )
              *(_BYTE *)(a1 + v30) = 39;
            if ( ++v30 < a2 )
              *(_BYTE *)(a1 + v30) = 39;
            ++v30;
            v18 = 0;
          }
          if ( v30 < a2 )
            *(_BYTE *)(v30 + a1) = v21;
          ++v30;
          if ( v25 != 1 )
            v20 = 0;
LABEL_219:
          ++v29;
          break;
        case 0x7Bu:
        case 0x7Du:
          if ( a4 == -1 )
            v11 = *(_BYTE *)(a3 + 1) != 0;
          else
            v11 = a4 != 1;
          if ( v11 )
            goto LABEL_189;
LABEL_110:
          if ( v29 )
            goto LABEL_189;
LABEL_111:
          v25 = 1;
LABEL_112:
          if ( a5 != 2 || !v17 )
            goto LABEL_189;
          goto LABEL_245;
        default:
          if ( v27 )
          {
            v34 = 1;
            v26 = ((*__ctype_b_loc())[v21] & 0x4000) != 0;
            goto LABEL_151;
          }
          memset(&ps, 0, 8u);
          v34 = 0;
          v26 = 1;
          if ( a4 == -1 )
            a4 = strlen((const char *)a3);
          while ( 2 )
          {
            v36 = sub_805B90B((wchar_t *)&wc, (char *)(a3 + v34 + v29), a4 - (v34 + v29), &ps);
            if ( v36 )
            {
              if ( v36 == -1 )
              {
                v26 = 0;
              }
              else
              {
                if ( v36 != -2 )
                {
                  if ( v17 && a5 == 2 )
                  {
                    v35 = 1;
                    while ( v35 < v36 )
                    {
                      switch ( *(char *)(v35 + v34 + v29 + a3) )
                      {
                        case 91:
                        case 92:
                        case 94:
                        case 96:
                        case 124:
                          goto LABEL_245;
                        default:
                          ++v35;
                          break;
                      }
                    }
                  }
                  if ( !iswprint(wc) )
                    v26 = 0;
                  v34 += v36;
                  if ( mbsinit(&ps) )
                    break;
                  continue;
                }
                v26 = 0;
                while ( v29 + v34 < a4 && *(_BYTE *)(v34 + v29 + a3) )
                  ++v34;
              }
            }
            break;
          }
LABEL_151:
          v25 = v26;
          if ( v34 <= 1 && (!v16 || v26 == 1) )
            goto LABEL_189;
          v37 = v29 + v34;
          while ( 1 )
          {
            if ( v16 && v26 != 1 )
            {
              if ( v17 )
                goto LABEL_245;
              v24 = 1;
              if ( a5 == 2 && v18 != 1 )
              {
                if ( v30 < a2 )
                  *(_BYTE *)(a1 + v30) = 39;
                if ( ++v30 < a2 )
                  *(_BYTE *)(a1 + v30) = 36;
                if ( ++v30 < a2 )
                  *(_BYTE *)(a1 + v30) = 39;
                ++v30;
                v18 = 1;
              }
              if ( v30 < a2 )
                *(_BYTE *)(a1 + v30) = 92;
              if ( ++v30 < a2 )
                *(_BYTE *)(v30 + a1) = (v21 >> 6) + 48;
              if ( ++v30 < a2 )
                *(_BYTE *)(v30 + a1) = ((v21 >> 3) & 7) + 48;
              ++v30;
              v21 = (v21 & 7) + 48;
            }
            else if ( v23 )
            {
              if ( v30 < a2 )
                *(_BYTE *)(a1 + v30) = 92;
              ++v30;
              v23 = 0;
            }
            if ( v29 + 1 >= v37 )
              goto LABEL_208;
            if ( v18 && v24 != 1 )
            {
              if ( v30 < a2 )
                *(_BYTE *)(a1 + v30) = 39;
              if ( ++v30 < a2 )
                *(_BYTE *)(a1 + v30) = 39;
              ++v30;
              v18 = 0;
            }
            if ( v30 < a2 )
              *(_BYTE *)(v30 + a1) = v21;
            ++v30;
            v21 = *(_BYTE *)(a3 + ++v29);
          }
      }
    }
    if ( !v30 && a5 == 2 && v17 )
      break;
    if ( a5 != 2 || v17 == 1 || !v19 )
      goto LABEL_251;
    if ( v20 )
      return sub_80570A5(a1, v31, a3, a4, 5, a6, a7, v15, v14);
    if ( a2 || !v31 )
    {
LABEL_251:
      if ( s && v17 != 1 )
      {
        while ( *s )
        {
          if ( v30 < a2 )
            *(_BYTE *)(v30 + a1) = *s;
          ++v30;
          ++s;
        }
      }
      if ( v30 < a2 )
        *(_BYTE *)(a1 + v30) = 0;
      return v30;
    }
    a2 = v31;
    v30 = 0;
  }
LABEL_245:
  if ( a5 == 2 && v16 )
    a5 = 4;
  return sub_80570A5(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0, v15, v14);
}

//----- (08057D3C) --------------------------------------------------------
void *__cdecl sub_8057D3C(int a1, size_t a2, _DWORD *a3, int *a4)
{
  int *v4; // eax
  int *v5; // ST3C_4
  int v6; // ST40_4
  int v7; // ST44_4
  unsigned int size; // [esp+48h] [ebp-10h]
  void *v10; // [esp+4Ch] [ebp-Ch]

  if ( a4 )
    v4 = a4;
  else
    v4 = &dword_80659AD;
  v5 = v4;
  v6 = *__errno_location();
  v7 = v5[1] | (a3 == 0);
  size = sub_80570A5(0, 0, a1, a2, *v5, v7, (int)(v5 + 2), (char *)v5[10], (char *)v5[11]) + 1;
  v10 = sub_805A7EA(size);
  sub_80570A5((int)v10, size, a1, a2, *v5, v7, (int)(v5 + 2), (char *)v5[10], (char *)v5[11]);
  *__errno_location() = v6;
  if ( a3 )
    *a3 = size - 1;
  return v10;
}
// 80659AD: using guessed type int dword_80659AD;

//----- (08057EE3) --------------------------------------------------------
void *__cdecl sub_8057EE3(signed int a1, int a2, size_t a3, int a4)
{
  int *v4; // eax
  void *v5; // edx
  size_t v6; // ST44_4
  bool v8; // [esp+37h] [ebp-21h]
  int *v9; // [esp+38h] [ebp-20h]
  void *ptr; // [esp+3Ch] [ebp-1Ch]
  int v11; // [esp+40h] [ebp-18h]
  int size; // [esp+44h] [ebp-14h]
  int v13; // [esp+48h] [ebp-10h]
  unsigned int v14; // [esp+4Ch] [ebp-Ch]

  v11 = *__errno_location();
  v9 = off_80652F8;
  if ( a1 < 0 )
    abort();
  if ( dword_80652EC <= a1 )
  {
    v8 = off_80652F8 == &dword_80652F0;
    if ( (unsigned int)a1 > 0xFFFFFFE )
      sub_805A94D();
    if ( v8 )
      v4 = 0;
    else
      v4 = off_80652F8;
    v9 = (int *)sub_805A827(v4, 8 * (a1 + 1));
    off_80652F8 = v9;
    if ( v8 )
    {
      v5 = off_80652F4;
      *v9 = dword_80652F0;
      v9[1] = (int)v5;
    }
    memset(&v9[2 * dword_80652EC], 0, 8 * (a1 + 1 - dword_80652EC));
    dword_80652EC = a1 + 1;
  }
  v6 = v9[2 * a1];
  ptr = (void *)v9[2 * a1 + 1];
  v13 = *(_DWORD *)(a4 + 4) | 1;
  v14 = sub_80570A5(
          v9[2 * a1 + 1],
          v9[2 * a1],
          a2,
          a3,
          *(_DWORD *)a4,
          v13,
          a4 + 8,
          *(char **)(a4 + 40),
          *(char **)(a4 + 44));
  if ( v6 <= v14 )
  {
    size = v14 + 1;
    v9[2 * a1] = v14 + 1;
    if ( ptr != &unk_80659ED )
      free(ptr);
    ptr = sub_805A7EA(size);
    v9[2 * a1 + 1] = (int)ptr;
    sub_80570A5((int)ptr, size, a2, a3, *(_DWORD *)a4, v13, a4 + 8, *(char **)(a4 + 40), *(char **)(a4 + 44));
  }
  *__errno_location() = v11;
  return ptr;
}
// 80652EC: using guessed type int dword_80652EC;
// 80652F0: using guessed type int dword_80652F0;
// 80652F4: using guessed type void *off_80652F4;
// 80652F8: using guessed type int *off_80652F8;

//----- (0805810C) --------------------------------------------------------
void *__cdecl sub_805810C(signed int a1, int a2)
{
  return sub_8057EE3(a1, a2, 0xFFFFFFFF, (int)&dword_80659AD);
}
// 80659AD: using guessed type int dword_80659AD;

//----- (08058136) --------------------------------------------------------
void *__cdecl sub_8058136(signed int a1, int a2, size_t a3)
{
  return sub_8057EE3(a1, a2, a3, (int)&dword_80659AD);
}
// 80659AD: using guessed type int dword_80659AD;

//----- (0805819C) --------------------------------------------------------
void *__cdecl sub_805819C(signed int a1, int a2, int a3)
{
  char v4; // [esp+10h] [ebp-38h]

  sub_8056F88(&v4, a2);
  return sub_8057EE3(a1, a3, 0xFFFFFFFF, (int)&v4);
}

//----- (080581DA) --------------------------------------------------------
void *__cdecl sub_80581DA(signed int a1, int a2, int a3, size_t a4)
{
  char v5; // [esp+10h] [ebp-38h]

  sub_8056F88(&v5, a2);
  return sub_8057EE3(a1, a3, a4, (int)&v5);
}

//----- (08058217) --------------------------------------------------------
void *__cdecl sub_8058217(int a1, int a2)
{
  return sub_805819C(0, a1, a2);
}

//----- (08058262) --------------------------------------------------------
void *__cdecl sub_8058262(int a1, size_t a2, unsigned __int8 a3)
{
  int v4; // [esp+20h] [ebp-38h]
  int v5; // [esp+24h] [ebp-34h]
  int v6; // [esp+28h] [ebp-30h]
  int v7; // [esp+2Ch] [ebp-2Ch]
  int v8; // [esp+30h] [ebp-28h]
  int v9; // [esp+34h] [ebp-24h]
  int v10; // [esp+38h] [ebp-20h]
  int v11; // [esp+3Ch] [ebp-1Ch]
  int v12; // [esp+40h] [ebp-18h]
  int v13; // [esp+44h] [ebp-14h]
  int v14; // [esp+48h] [ebp-10h]
  int v15; // [esp+4Ch] [ebp-Ch]

  v4 = dword_80659AD;
  v5 = dword_80659B1;
  v6 = dword_80659B5;
  v7 = dword_80659B9;
  v8 = dword_80659BD;
  v9 = dword_80659C1;
  v10 = dword_80659C5;
  v11 = dword_80659C9;
  v12 = dword_80659CD;
  v13 = dword_80659D1;
  v14 = dword_80659D5;
  v15 = dword_80659D9;
  sub_8056E9D(&v4, a3, 1);
  return sub_8057EE3(0, a1, a2, (int)&v4);
}
// 80659AD: using guessed type int dword_80659AD;
// 80659B1: using guessed type int dword_80659B1;
// 80659B5: using guessed type int dword_80659B5;
// 80659B9: using guessed type int dword_80659B9;
// 80659BD: using guessed type int dword_80659BD;
// 80659C1: using guessed type int dword_80659C1;
// 80659C5: using guessed type int dword_80659C5;
// 80659C9: using guessed type int dword_80659C9;
// 80659CD: using guessed type int dword_80659CD;
// 80659D1: using guessed type int dword_80659D1;
// 80659D5: using guessed type int dword_80659D5;
// 80659D9: using guessed type int dword_80659D9;

//----- (0805830C) --------------------------------------------------------
void *__cdecl sub_805830C(int a1, unsigned __int8 a2)
{
  return sub_8058262(a1, 0xFFFFFFFF, a2);
}

//----- (08058335) --------------------------------------------------------
void *__cdecl sub_8058335(int a1)
{
  return sub_805830C(a1, 0x3Au);
}

//----- (08058372) --------------------------------------------------------
void *__cdecl sub_8058372(signed int a1, int a2, int a3)
{
  int v4; // [esp+10h] [ebp-68h]
  int v5; // [esp+14h] [ebp-64h]
  int v6; // [esp+18h] [ebp-60h]
  int v7; // [esp+1Ch] [ebp-5Ch]
  int v8; // [esp+20h] [ebp-58h]
  int v9; // [esp+24h] [ebp-54h]
  int v10; // [esp+28h] [ebp-50h]
  int v11; // [esp+2Ch] [ebp-4Ch]
  int v12; // [esp+30h] [ebp-48h]
  int v13; // [esp+34h] [ebp-44h]
  int v14; // [esp+38h] [ebp-40h]
  int v15; // [esp+3Ch] [ebp-3Ch]
  int v16; // [esp+40h] [ebp-38h]
  int v17; // [esp+44h] [ebp-34h]
  int v18; // [esp+48h] [ebp-30h]
  int v19; // [esp+4Ch] [ebp-2Ch]
  int v20; // [esp+50h] [ebp-28h]
  int v21; // [esp+54h] [ebp-24h]
  int v22; // [esp+58h] [ebp-20h]
  int v23; // [esp+5Ch] [ebp-1Ch]
  int v24; // [esp+60h] [ebp-18h]
  int v25; // [esp+64h] [ebp-14h]
  int v26; // [esp+68h] [ebp-10h]
  int v27; // [esp+6Ch] [ebp-Ch]

  sub_8056F88(&v4, a2);
  v16 = v4;
  v17 = v5;
  v18 = v6;
  v19 = v7;
  v20 = v8;
  v21 = v9;
  v22 = v10;
  v23 = v11;
  v24 = v12;
  v25 = v13;
  v26 = v14;
  v27 = v15;
  sub_8056E9D(&v16, 0x3Au, 1);
  return sub_8057EE3(a1, a3, 0xFFFFFFFF, (int)&v16);
}

//----- (08058413) --------------------------------------------------------
void *__cdecl sub_8058413(signed int a1, int a2, int a3, int a4)
{
  return sub_8058443(a1, a2, a3, a4, 0xFFFFFFFF);
}

//----- (08058443) --------------------------------------------------------
void *__cdecl sub_8058443(signed int a1, int a2, int a3, int a4, size_t a5)
{
  int v6; // [esp+10h] [ebp-38h]
  int v7; // [esp+14h] [ebp-34h]
  int v8; // [esp+18h] [ebp-30h]
  int v9; // [esp+1Ch] [ebp-2Ch]
  int v10; // [esp+20h] [ebp-28h]
  int v11; // [esp+24h] [ebp-24h]
  int v12; // [esp+28h] [ebp-20h]
  int v13; // [esp+2Ch] [ebp-1Ch]
  int v14; // [esp+30h] [ebp-18h]
  int v15; // [esp+34h] [ebp-14h]
  int v16; // [esp+38h] [ebp-10h]
  int v17; // [esp+3Ch] [ebp-Ch]

  v6 = dword_80659AD;
  v7 = dword_80659B1;
  v8 = dword_80659B5;
  v9 = dword_80659B9;
  v10 = dword_80659BD;
  v11 = dword_80659C1;
  v12 = dword_80659C5;
  v13 = dword_80659C9;
  v14 = dword_80659CD;
  v15 = dword_80659D1;
  v16 = dword_80659D5;
  v17 = dword_80659D9;
  sub_8056F47(&v6, a2, a3);
  return sub_8057EE3(a1, a4, a5, (int)&v6);
}
// 80659AD: using guessed type int dword_80659AD;
// 80659B1: using guessed type int dword_80659B1;
// 80659B5: using guessed type int dword_80659B5;
// 80659B9: using guessed type int dword_80659B9;
// 80659BD: using guessed type int dword_80659BD;
// 80659C1: using guessed type int dword_80659C1;
// 80659C5: using guessed type int dword_80659C5;
// 80659C9: using guessed type int dword_80659C9;
// 80659CD: using guessed type int dword_80659CD;
// 80659D1: using guessed type int dword_80659D1;
// 80659D5: using guessed type int dword_80659D5;
// 80659D9: using guessed type int dword_80659D9;

//----- (0805853D) --------------------------------------------------------
void *__cdecl sub_805853D(signed int a1, int a2, size_t a3)
{
  return sub_8057EE3(a1, a2, a3, (int)&unk_806530C);
}

//----- (08058588) --------------------------------------------------------
void *__cdecl sub_8058588(signed int a1, int a2)
{
  return sub_805853D(a1, a2, 0xFFFFFFFF);
}

//----- (080585AA) --------------------------------------------------------
void *__cdecl sub_80585AA(int a1)
{
  return sub_8058588(0, a1);
}

//----- (080585C5) --------------------------------------------------------
void __cdecl __noreturn sub_80585C5(int a1)
{
  void *v1; // esi
  char *v2; // ebx
  int *v3; // eax

  if ( a1 )
  {
    v1 = sub_80585AA(a1);
    if ( *__errno_location() )
      v2 = gettext("%s: read error");
    else
      v2 = gettext("%s: end of file");
    v3 = __errno_location();
    error(status, *v3, v2, v1);
  }
  abort();
}

//----- (0805862E) --------------------------------------------------------
_DWORD *__cdecl sub_805862E(int a1, int a2)
{
  _DWORD *result; // eax

  result = sub_805A7FD(0x81Cu);
  *result = a1;
  result[1] = sub_80585C5;
  result[2] = a2;
  return result;
}

//----- (08058663) --------------------------------------------------------
unsigned int __cdecl sub_8058663(int a1, int a2, size_t nbytes)
{
  size_t v3; // eax
  int v4; // eax
  size_t n; // ST24_4
  int v6; // eax
  size_t v7; // ST28_4
  int v8; // eax
  size_t v9; // ST2C_4
  int v10; // eax
  size_t v11; // ST30_4
  unsigned int result; // eax
  int v13; // eax
  size_t v14; // ST34_4
  unsigned int v15; // [esp+18h] [ebp-30h]
  int fd; // [esp+20h] [ebp-28h]
  struct timeval tv; // [esp+38h] [ebp-10h]

  v15 = 0;
  fd = open64("/dev/urandom", 0);
  if ( fd >= 0 )
  {
    v3 = a2;
    if ( nbytes <= a2 )
      v3 = nbytes;
    v15 = read(fd, (void *)a1, v3);
    if ( (v15 & 0x80000000) != 0 )
      v15 = 0;
    close(fd);
  }
  if ( v15 < a2 )
  {
    v4 = a2 - v15;
    if ( a2 - v15 > 8 )
      v4 = 8;
    n = v4;
    gettimeofday(&tv, 0);
    memcpy((void *)(a1 + v15), &tv, n);
    v15 += n;
  }
  if ( v15 < a2 )
  {
    v6 = a2 - v15;
    if ( a2 - v15 > 4 )
      v6 = 4;
    v7 = v6;
    tv.tv_sec = getpid();
    memcpy((void *)(a1 + v15), &tv, v7);
    v15 += v7;
  }
  if ( v15 < a2 )
  {
    v8 = a2 - v15;
    if ( a2 - v15 > 4 )
      v8 = 4;
    v9 = v8;
    tv.tv_sec = getppid();
    memcpy((void *)(a1 + v15), &tv, v9);
    v15 += v9;
  }
  if ( v15 < a2 )
  {
    v10 = a2 - v15;
    if ( a2 - v15 > 4 )
      v10 = 4;
    v11 = v10;
    tv.tv_sec = getuid();
    memcpy((void *)(a1 + v15), &tv, v11);
    v15 += v11;
  }
  result = v15;
  if ( v15 < a2 )
  {
    v13 = a2 - v15;
    if ( a2 - v15 > 4 )
      v13 = 4;
    v14 = v13;
    tv.tv_sec = getgid();
    memcpy((void *)(a1 + v15), &tv, v14);
    result = v15 + v14;
  }
  return result;
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);

//----- (08058870) --------------------------------------------------------
char *__cdecl sub_8058870(int a1, size_t n)
{
  size_t v3; // eax
  FILE *stream; // [esp+18h] [ebp-10h]
  char *v5; // [esp+1Ch] [ebp-Ch]

  if ( !n )
    return (char *)sub_805862E(0, 0);
  stream = 0;
  if ( a1 )
  {
    stream = sub_805C4DB(a1, "rb");
    if ( !stream )
      return 0;
  }
  v5 = (char *)sub_805862E((int)stream, a1);
  if ( stream )
  {
    v3 = 2048;
    if ( n <= 0x800 )
      v3 = n;
    setvbuf(stream, v5 + 12, 0, v3);
  }
  else
  {
    *((_DWORD *)v5 + 3) = 0;
    sub_8058663((int)(v5 + 16), 1024, n);
    sub_805907E((_DWORD *)v5 + 4);
  }
  return v5;
}

//----- (0805896C) --------------------------------------------------------
size_t __cdecl sub_805896C(int a1, void *ptr, size_t n)
{
  size_t v3; // ST18_4
  size_t result; // eax
  int *v5; // ebx
  int v6; // eax
  int v7; // [esp+1Ch] [ebp-Ch]

  while ( 1 )
  {
    v3 = fread_unlocked(ptr, 1u, n, *(FILE **)a1);
    v7 = *__errno_location();
    ptr = (char *)ptr + v3;
    result = v3;
    n -= v3;
    if ( !n )
      break;
    v5 = __errno_location();
    if ( ferror_unlocked(*(FILE **)a1) )
      v6 = v7;
    else
      v6 = 0;
    *v5 = v6;
    (*(void (__cdecl **)(_DWORD))(a1 + 4))(*(_DWORD *)(a1 + 8));
  }
  return result;
}

//----- (080589F4) --------------------------------------------------------
int __cdecl sub_80589F4(int a1, void *dest, size_t n)
{
  int result; // eax
  size_t i; // [esp+14h] [ebp-14h]
  int *v5; // [esp+18h] [ebp-10h]
  char v6; // [esp+1Ch] [ebp-Ch]

  for ( i = *(_DWORD *)a1; ; i = 1024 )
  {
    v6 = (char)dest;
    if ( n <= i )
      break;
    memcpy(dest, (const void *)(a1 + 1024 - i + 1040), i);
    dest = (char *)dest + i;
    n -= i;
    if ( !((v6 + (_BYTE)i) & 3) )
    {
      v5 = (int *)dest;
      while ( n > 0x3FF )
      {
        sub_8058BD9((unsigned int *)(a1 + 4), v5);
        v5 += 256;
        n -= 1024;
        if ( !n )
        {
          result = a1;
          *(_DWORD *)a1 = 0;
          return result;
        }
      }
      dest = v5;
    }
    sub_8058BD9((unsigned int *)(a1 + 4), (int *)(a1 + 1040));
  }
  memcpy(dest, (const void *)(a1 + 1024 - i + 1040), n);
  result = a1;
  *(_DWORD *)a1 = i - n;
  return result;
}

//----- (08058B03) --------------------------------------------------------
size_t __cdecl sub_8058B03(int a1, void *ptr, size_t n)
{
  size_t result; // eax

  if ( *(_DWORD *)a1 )
    result = sub_805896C(a1, ptr, n);
  else
    result = sub_80589F4(a1 + 12, ptr, n);
  return result;
}

//----- (08058B4B) --------------------------------------------------------
int __cdecl sub_8058B4B(void *ptr)
{
  int result; // eax
  FILE *stream; // [esp+1Ch] [ebp-Ch]

  stream = *(FILE **)ptr;
  explicit_bzero(ptr, 2076);
  free(ptr);
  if ( stream )
    result = sub_805B593(stream);
  else
    result = 0;
  return result;
}
// 8049DE0: using guessed type int __cdecl explicit_bzero(_DWORD, _DWORD);

//----- (08058B91) --------------------------------------------------------
int __cdecl sub_8058B91(int a1)
{
  return a1;
}

//----- (08058BA8) --------------------------------------------------------
int __cdecl sub_8058BA8(int a1, __int16 a2)
{
  return *(_DWORD *)((a2 & 0x3FC) + a1);
}

//----- (08058BD9) --------------------------------------------------------
unsigned int *__cdecl sub_8058BD9(unsigned int *a1, int *a2)
{
  unsigned int v2; // edx
  int v3; // ST08_4
  unsigned int v4; // ST18_4
  unsigned int v5; // ST1C_4
  int v6; // eax
  int v7; // ST0C_4
  unsigned int v8; // ST08_4
  unsigned int v9; // ST20_4
  int v10; // eax
  int v11; // eax
  int v12; // ST0C_4
  int v13; // ST08_4
  unsigned int v14; // ST28_4
  int v15; // eax
  int v16; // eax
  int v17; // ST0C_4
  unsigned int v18; // ST30_4
  int v19; // eax
  int v20; // eax
  int v21; // ST08_4
  unsigned int v22; // ST38_4
  unsigned int v23; // ST3C_4
  int v24; // eax
  int v25; // ST0C_4
  unsigned int v26; // ST08_4
  unsigned int v27; // ST40_4
  int v28; // eax
  int v29; // eax
  int v30; // ST0C_4
  int v31; // ST08_4
  unsigned int v32; // ST48_4
  int v33; // eax
  int v34; // eax
  int v35; // ST0C_4
  unsigned int v36; // ST50_4
  int v37; // eax
  int v38; // eax
  unsigned int *result; // eax
  unsigned int v40; // [esp+8h] [ebp-54h]
  int v41; // [esp+Ch] [ebp-50h]
  unsigned int *v42; // [esp+10h] [ebp-4Ch]
  int *v43; // [esp+14h] [ebp-48h]

  v40 = a1[256];
  v2 = a1[257];
  v41 = v2 + ++a1[258];
  v42 = a1;
  v43 = a2;
  do
  {
    v3 = (v40 ^ (v40 << 13)) + v42[128];
    v4 = *v42;
    v5 = sub_8058BA8((int)a1, *v42) + v3 + v41;
    *v42 = v5;
    v6 = sub_8058BA8((int)a1, v5 >> 8);
    v7 = sub_8058B91(v4 + v6);
    *v43 = v7;
    v8 = (v3 ^ ((unsigned int)sub_8058B91(v3) >> 6)) + v42[129];
    v9 = v42[1];
    v10 = sub_8058BA8((int)a1, v42[1]);
    v42[1] = v10 + v8 + v7;
    v11 = sub_8058BA8((int)a1, (v10 + v8 + v7) >> 8);
    v12 = sub_8058B91(v9 + v11);
    v43[1] = v12;
    v13 = (v8 ^ 4 * v8) + v42[130];
    v14 = v42[2];
    v15 = sub_8058BA8((int)a1, v42[2]);
    v42[2] = v15 + v13 + v12;
    v16 = sub_8058BA8((int)a1, (unsigned int)(v15 + v13 + v12) >> 8);
    v17 = sub_8058B91(v14 + v16);
    v43[2] = v17;
    v40 = (v13 ^ ((unsigned int)sub_8058B91(v13) >> 16)) + v42[131];
    v18 = v42[3];
    v19 = sub_8058BA8((int)a1, v42[3]);
    v42[3] = v19 + v40 + v17;
    v20 = sub_8058BA8((int)a1, (v19 + v40 + v17) >> 8);
    v41 = sub_8058B91(v18 + v20);
    v43[3] = v41;
    v43 += 4;
    v42 += 4;
  }
  while ( v42 < a1 + 128 );
  do
  {
    v21 = (v40 ^ (v40 << 13)) + *(v42 - 128);
    v22 = *v42;
    v23 = sub_8058BA8((int)a1, *v42) + v21 + v41;
    *v42 = v23;
    v24 = sub_8058BA8((int)a1, v23 >> 8);
    v25 = sub_8058B91(v22 + v24);
    *v43 = v25;
    v26 = (v21 ^ ((unsigned int)sub_8058B91(v21) >> 6)) + *(v42 - 127);
    v27 = v42[1];
    v28 = sub_8058BA8((int)a1, v42[1]);
    v42[1] = v28 + v26 + v25;
    v29 = sub_8058BA8((int)a1, (v28 + v26 + v25) >> 8);
    v30 = sub_8058B91(v27 + v29);
    v43[1] = v30;
    v31 = (v26 ^ 4 * v26) + *(v42 - 126);
    v32 = v42[2];
    v33 = sub_8058BA8((int)a1, v42[2]);
    v42[2] = v33 + v31 + v30;
    v34 = sub_8058BA8((int)a1, (unsigned int)(v33 + v31 + v30) >> 8);
    v35 = sub_8058B91(v32 + v34);
    v43[2] = v35;
    v40 = (v31 ^ ((unsigned int)sub_8058B91(v31) >> 16)) + *(v42 - 125);
    v36 = v42[3];
    v37 = sub_8058BA8((int)a1, v42[3]);
    v42[3] = v37 + v40 + v35;
    v38 = sub_8058BA8((int)a1, (v37 + v40 + v35) >> 8);
    v41 = sub_8058B91(v36 + v38);
    v43[3] = v41;
    v43 += 4;
    v42 += 4;
  }
  while ( v42 < a1 + 256 );
  a1[256] = v40;
  result = a1;
  a1[257] = v41;
  return result;
}

//----- (0805907E) --------------------------------------------------------
_DWORD *__cdecl sub_805907E(_DWORD *a1)
{
  int v1; // ST10_4
  int v2; // ST14_4
  int v3; // ST1C_4
  int v4; // ST20_4
  int v5; // ST24_4
  int v6; // ST28_4
  int v7; // ST0C_4
  int v8; // ST18_4
  unsigned int v9; // ST10_4
  int v10; // ST1C_4
  int v11; // ST14_4
  int v12; // ST20_4
  int v13; // ST24_4
  int v14; // ST28_4
  int v15; // ST0C_4
  int v16; // ST10_4
  int v17; // ST14_4
  int v18; // ST1C_4
  int v19; // ST20_4
  int v20; // ST24_4
  int v21; // ST28_4
  int v22; // ST0C_4
  int v23; // ST18_4
  unsigned int v24; // ST10_4
  int v25; // ST1C_4
  int v26; // ST14_4
  int v27; // ST20_4
  int v28; // ST24_4
  int v29; // ST28_4
  int v30; // ST0C_4
  _DWORD *result; // eax
  int v32; // [esp+Ch] [ebp-28h]
  int v33; // [esp+10h] [ebp-24h]
  int v34; // [esp+14h] [ebp-20h]
  unsigned int v35; // [esp+18h] [ebp-1Ch]
  int v36; // [esp+1Ch] [ebp-18h]
  unsigned int v37; // [esp+20h] [ebp-14h]
  int v38; // [esp+24h] [ebp-10h]
  unsigned int v39; // [esp+28h] [ebp-Ch]
  signed int i; // [esp+2Ch] [ebp-8h]
  signed int j; // [esp+30h] [ebp-4h]

  v32 = 325574490;
  v33 = -1780940711;
  v34 = -1021952437;
  v35 = 255990488;
  v36 = -651539848;
  v37 = -1525007287;
  v38 = -990909925;
  v39 = 811634969;
  for ( i = 0; i <= 255; i += 8 )
  {
    v1 = a1[i + 1] + v33;
    v2 = a1[i + 2] + v34;
    v3 = a1[i + 4] + v36;
    v4 = a1[i + 5] + v37;
    v5 = a1[i + 6] + v38;
    v6 = a1[i + 7] + v39;
    v7 = (v1 << 11) ^ (a1[i] + v32);
    v8 = v7 + a1[i + 3] + v35;
    v9 = ((unsigned int)sub_8058B91(v2) >> 2) ^ (v2 + v1);
    v10 = v9 + v3;
    v11 = (v8 << 8) ^ (v8 + v2);
    v12 = v11 + v4;
    v35 = ((unsigned int)sub_8058B91(v10) >> 16) ^ (v10 + v8);
    v13 = v35 + v5;
    v36 = (v12 << 10) ^ (v12 + v10);
    v14 = v36 + v6;
    v37 = ((unsigned int)sub_8058B91(v13) >> 4) ^ (v13 + v12);
    v15 = v37 + v7;
    v38 = (v14 << 8) ^ (v14 + v13);
    v33 = v38 + v9;
    v39 = ((unsigned int)sub_8058B91(v15) >> 9) ^ (v15 + v14);
    v34 = v39 + v11;
    v32 = v33 + v15;
    a1[i] = v32;
    a1[i + 1] = v33;
    a1[i + 2] = v34;
    a1[i + 3] = v35;
    a1[i + 4] = v36;
    a1[i + 5] = v37;
    a1[i + 6] = v38;
    a1[i + 7] = v39;
  }
  for ( j = 0; j <= 255; j += 8 )
  {
    v16 = a1[j + 1] + v33;
    v17 = a1[j + 2] + v34;
    v18 = a1[j + 4] + v36;
    v19 = a1[j + 5] + v37;
    v20 = a1[j + 6] + v38;
    v21 = a1[j + 7] + v39;
    v22 = (v16 << 11) ^ (a1[j] + v32);
    v23 = v22 + a1[j + 3] + v35;
    v24 = ((unsigned int)sub_8058B91(v17) >> 2) ^ (v17 + v16);
    v25 = v24 + v18;
    v26 = (v23 << 8) ^ (v23 + v17);
    v27 = v26 + v19;
    v35 = ((unsigned int)sub_8058B91(v25) >> 16) ^ (v25 + v23);
    v28 = v35 + v20;
    v36 = (v27 << 10) ^ (v27 + v25);
    v29 = v36 + v21;
    v37 = ((unsigned int)sub_8058B91(v28) >> 4) ^ (v28 + v27);
    v30 = v37 + v22;
    v38 = (v29 << 8) ^ (v29 + v28);
    v33 = v38 + v24;
    v39 = ((unsigned int)sub_8058B91(v30) >> 9) ^ (v30 + v29);
    v34 = v39 + v26;
    v32 = v33 + v30;
    a1[j] = v32;
    a1[j + 1] = v33;
    a1[j + 2] = v34;
    a1[j + 3] = v35;
    a1[j + 4] = v36;
    a1[j + 5] = v37;
    a1[j + 6] = v38;
    a1[j + 7] = v39;
  }
  a1[258] = 0;
  a1[257] = a1[258];
  result = a1;
  a1[256] = a1[257];
  return result;
}

//----- (0805948D) --------------------------------------------------------
signed int __cdecl sub_805948D(_DWORD *a1)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_805BAD8((int)(a1 + 3), 0, 0, (int)malloc, (int)free);
  sub_805BAD8((int)(a1 + 14), 0, 0, (int)malloc, (int)free);
  return sub_805BAD8((int)(a1 + 25), 0, 0, (int)malloc, (int)free);
}

//----- (08059631) --------------------------------------------------------
_DWORD *__cdecl sub_8059631(_DWORD *a1)
{
  _DWORD *result; // eax
  int src; // [esp+10h] [ebp-38h]
  _DWORD *v3; // [esp+14h] [ebp-34h]
  _DWORD *v4; // [esp+18h] [ebp-30h]
  int v5; // [esp+1Ch] [ebp-2Ch]
  int v6; // [esp+20h] [ebp-28h]
  _DWORD *v7; // [esp+24h] [ebp-24h]
  _DWORD *v8; // [esp+28h] [ebp-20h]
  _DWORD *v9; // [esp+2Ch] [ebp-1Ch]
  _DWORD *v10; // [esp+30h] [ebp-18h]
  _DWORD *v11; // [esp+34h] [ebp-14h]
  size_t n; // [esp+38h] [ebp-10h]
  _DWORD *v13; // [esp+3Ch] [ebp-Ch]

  v3 = a1 + 3;
  src = a1[6] - a1[5] - 1;
  v4 = a1 + 3;
  v5 = a1[5];
  if ( a1[6] == v5 )
    *((_BYTE *)v4 + 40) |= 2u;
  v4[3] = (v4[6] + v4[3]) & ~v4[6];
  if ( v4[3] - v4[1] > (unsigned int)(v4[4] - v4[1]) )
    v4[3] = v4[4];
  v4[2] = v4[3];
  v6 = v5;
  v7 = a1 + 14;
  v8 = a1 + 14;
  if ( (unsigned int)(a1[18] - a1[17]) <= 3 )
    sub_805BB61((int)v7, 4);
  v9 = v7;
  v10 = (_DWORD *)v7[3];
  *v10 = v6;
  v9[3] += 4;
  v11 = a1 + 25;
  n = 4;
  v13 = a1 + 25;
  if ( (unsigned int)(a1[29] - a1[28]) < 4 )
    sub_805BB61((int)v11, n);
  memcpy((void *)v11[3], &src, n);
  v11[3] += n;
  result = a1;
  ++*a1;
  return result;
}

//----- (080597C6) --------------------------------------------------------
bool __cdecl sub_80597C6(FILE *stream, int a2)
{
  _BYTE *v2; // eax
  _BYTE *v3; // eax
  int v5; // [esp+14h] [ebp-44h]
  int v6; // [esp+3Ch] [ebp-1Ch]
  int v7; // [esp+44h] [ebp-14h]

  while ( 1 )
  {
    v5 = fgetc(stream);
    if ( v5 == -1 )
      break;
    if ( *(_DWORD *)(a2 + 28) == *(_DWORD *)(a2 + 24) )
      sub_805BB61(a2 + 12, 1);
    v3 = *(_BYTE **)(a2 + 24);
    *(_DWORD *)(a2 + 24) = v3 + 1;
    *v3 = v5;
    if ( !v5 )
      sub_8059631((_DWORD *)a2);
  }
  if ( *(_DWORD *)(a2 + 24) != *(_DWORD *)(a2 + 20) )
  {
    if ( *(_DWORD *)(a2 + 28) == *(_DWORD *)(a2 + 24) )
      sub_805BB61(a2 + 12, 1);
    v2 = *(_BYTE **)(a2 + 24);
    *(_DWORD *)(a2 + 24) = v2 + 1;
    *v2 = 0;
    sub_8059631((_DWORD *)a2);
  }
  if ( (unsigned int)(*(_DWORD *)(a2 + 72) - *(_DWORD *)(a2 + 68)) <= 3 )
    sub_805BB61(a2 + 56, 4);
  **(_DWORD **)(a2 + 68) = 0;
  *(_DWORD *)(a2 + 68) += 4;
  v6 = *(_DWORD *)(a2 + 64);
  if ( *(_DWORD *)(a2 + 68) == v6 )
    *(_BYTE *)(a2 + 96) |= 2u;
  *(_DWORD *)(a2 + 68) = (*(_DWORD *)(a2 + 80) + *(_DWORD *)(a2 + 68)) & ~*(_DWORD *)(a2 + 80);
  if ( *(_DWORD *)(a2 + 68) - *(_DWORD *)(a2 + 60) > (unsigned int)(*(_DWORD *)(a2 + 72) - *(_DWORD *)(a2 + 60)) )
    *(_DWORD *)(a2 + 68) = *(_DWORD *)(a2 + 72);
  *(_DWORD *)(a2 + 64) = *(_DWORD *)(a2 + 68);
  *(_DWORD *)(a2 + 4) = v6;
  v7 = *(_DWORD *)(a2 + 108);
  if ( *(_DWORD *)(a2 + 112) == v7 )
    *(_BYTE *)(a2 + 140) |= 2u;
  *(_DWORD *)(a2 + 112) = (*(_DWORD *)(a2 + 124) + *(_DWORD *)(a2 + 112)) & ~*(_DWORD *)(a2 + 124);
  if ( *(_DWORD *)(a2 + 112) - *(_DWORD *)(a2 + 104) > (unsigned int)(*(_DWORD *)(a2 + 116) - *(_DWORD *)(a2 + 104)) )
    *(_DWORD *)(a2 + 112) = *(_DWORD *)(a2 + 116);
  *(_DWORD *)(a2 + 108) = *(_DWORD *)(a2 + 112);
  *(_DWORD *)(a2 + 8) = v7;
  return ferror(stream) == 0;
}

//----- (08059A7F) --------------------------------------------------------
int __cdecl sub_8059A7F(int a1, int a2)
{
  int v2; // eax

  v2 = mkostemp64(a1, a2);
  return sub_805C453(v2, a2);
}
// 8049A10: using guessed type int __cdecl mkostemp64(_DWORD, _DWORD);

//----- (08059AA8) --------------------------------------------------------
int __cdecl sub_8059AA8(_BYTE *a1, _BYTE *a2, char a3)
{
  _BYTE *v4; // eax
  _BYTE *v5; // eax

  if ( *a1 != a3 || *a2 != a3 )
  {
    v4 = a1++;
    if ( *v4 != a3 )
    {
      v5 = a2++;
      if ( *v5 != a3 )
        return 0;
      goto LABEL_21;
    }
  }
  else
  {
    while ( *++a1 == *++a2 )
    {
      if ( (unsigned int)((char)*a1 - 48) > 9 )
        return 0;
    }
    if ( (unsigned int)((char)*a1 - 48) <= 9 && (unsigned int)((char)*a2 - 48) <= 9 )
      return (char)*a1 - (char)*a2;
    if ( (unsigned int)((char)*a1 - 48) > 9 )
    {
      if ( (unsigned int)((char)*a2 - 48) > 9 )
        return 0;
LABEL_21:
      while ( *a2 == 48 )
        ++a2;
      return -((unsigned int)((char)*a2 - 48) <= 9);
    }
  }
  while ( *a1 == 48 )
    ++a1;
  return (unsigned int)((char)*a1 - 48) <= 9;
}

//----- (08059BEA) --------------------------------------------------------
int __cdecl sub_8059BEA(unsigned __int8 *a1, unsigned __int8 *a2, int a3, int a4)
{
  int result; // eax
  unsigned __int8 v5; // [esp+Eh] [ebp-Eh]
  unsigned __int8 v6; // [esp+Eh] [ebp-Eh]
  unsigned __int8 v7; // [esp+Fh] [ebp-Dh]
  unsigned __int8 v8; // [esp+Fh] [ebp-Dh]
  unsigned __int8 v9; // [esp+Fh] [ebp-Dh]
  unsigned int v10; // [esp+10h] [ebp-Ch]
  unsigned int v11; // [esp+10h] [ebp-Ch]
  unsigned int v12; // [esp+14h] [ebp-8h]
  unsigned int v13; // [esp+14h] [ebp-8h]
  int v14; // [esp+18h] [ebp-4h]
  int v15; // [esp+18h] [ebp-4h]

  v5 = *a1;
  v7 = *a2;
  if ( *a1 == 45 )
  {
    do
    {
      do
        v6 = *++a1;
      while ( *a1 == 48 );
    }
    while ( v6 == a4 );
    if ( v7 == 45 )
    {
      do
      {
        do
          v8 = *++a2;
        while ( *a2 == 48 );
      }
      while ( v8 == a4 );
      while ( v6 == v8 && (unsigned int)v6 - 48 <= 9 )
      {
        do
          v6 = *++a1;
        while ( *a1 == a4 );
        do
          v8 = *++a2;
        while ( *a2 == a4 );
      }
      if ( (v6 != a3 || (unsigned int)v8 - 48 <= 9) && (v8 != a3 || (unsigned int)v6 - 48 <= 9) )
      {
        v14 = v8 - v6;
        v10 = 0;
        while ( (unsigned int)v6 - 48 <= 9 )
        {
          do
            v6 = *++a1;
          while ( *a1 == a4 );
          ++v10;
        }
        v12 = 0;
        while ( (unsigned int)v8 - 48 <= 9 )
        {
          do
            v8 = *++a2;
          while ( *a2 == a4 );
          ++v12;
        }
        if ( v10 == v12 )
        {
          if ( v10 )
            result = v14;
          else
            result = 0;
        }
        else if ( v10 >= v12 )
        {
          result = -1;
        }
        else
        {
          result = 1;
        }
      }
      else
      {
        result = sub_8059AA8(a2, a1, a3);
      }
    }
    else
    {
      if ( v6 == a3 )
      {
        do
          v6 = *++a1;
        while ( *a1 == 48 );
      }
      if ( (unsigned int)v6 - 48 > 9 )
      {
        while ( v7 == 48 || v7 == a4 )
          v7 = *++a2;
        if ( v7 == a3 )
        {
          do
            v7 = *++a2;
          while ( *a2 == 48 );
        }
        result = -((unsigned int)v7 - 48 <= 9);
      }
      else
      {
        result = -1;
      }
    }
  }
  else if ( v7 == 45 )
  {
    do
    {
      do
        v9 = *++a2;
      while ( *a2 == 48 );
    }
    while ( v9 == a4 );
    if ( v9 == a3 )
    {
      do
        v9 = *++a2;
      while ( *a2 == 48 );
    }
    if ( (unsigned int)v9 - 48 > 9 )
    {
      while ( v5 == 48 || v5 == a4 )
        v5 = *++a1;
      if ( v5 == a3 )
      {
        do
          v5 = *++a1;
        while ( *a1 == 48 );
      }
      result = (unsigned int)v5 - 48 <= 9;
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    while ( v5 == 48 || v5 == a4 )
      v5 = *++a1;
    while ( v7 == 48 || v7 == a4 )
      v7 = *++a2;
    while ( v5 == v7 && (unsigned int)v5 - 48 <= 9 )
    {
      do
        v5 = *++a1;
      while ( *a1 == a4 );
      do
        v7 = *++a2;
      while ( *a2 == a4 );
    }
    if ( (v5 != a3 || (unsigned int)v7 - 48 <= 9) && (v7 != a3 || (unsigned int)v5 - 48 <= 9) )
    {
      v15 = v5 - v7;
      v11 = 0;
      while ( (unsigned int)v5 - 48 <= 9 )
      {
        do
          v5 = *++a1;
        while ( *a1 == a4 );
        ++v11;
      }
      v13 = 0;
      while ( (unsigned int)v7 - 48 <= 9 )
      {
        do
          v7 = *++a2;
        while ( *a2 == a4 );
        ++v13;
      }
      if ( v11 == v13 )
      {
        if ( v11 )
          result = v15;
        else
          result = 0;
      }
      else if ( v11 >= v13 )
      {
        result = 1;
      }
      else
      {
        result = -1;
      }
    }
    else
    {
      result = sub_8059AA8(a1, a2, a3);
    }
  }
  return result;
}

//----- (0805A013) --------------------------------------------------------
int __cdecl sub_805A013(unsigned __int8 *a1, unsigned __int8 *a2, int a3, int a4)
{
  return sub_8059BEA(a1, a2, a3, a4);
}

//----- (0805A03B) --------------------------------------------------------
int __cdecl sub_805A03B(int fd)
{
  int v1; // ST18_4
  int v2; // ST1C_4

  if ( fd >= 0 && fd <= 2 )
  {
    v1 = sub_805CD4C(fd);
    v2 = *__errno_location();
    close(fd);
    *__errno_location() = v2;
    fd = v1;
  }
  return fd;
}

//----- (0805A085) --------------------------------------------------------
int __cdecl sub_805A085(FILE *stream, int a2, int a3, int a4, int a5, int a6)
{
  char *v6; // eax
  char *v7; // eax
  int v8; // ebx
  char *v9; // eax
  int result; // eax
  int v11; // esi
  int v12; // ebx
  char *v13; // eax
  int v14; // edi
  int v15; // esi
  int v16; // ebx
  char *v17; // eax
  int v18; // ST4C_4
  int v19; // edi
  int v20; // esi
  int v21; // ebx
  char *v22; // eax
  int v23; // ST4C_4
  int v24; // ST48_4
  int v25; // edi
  int v26; // esi
  int v27; // ebx
  char *v28; // eax
  int v29; // ST4C_4
  int v30; // ST48_4
  int v31; // ST44_4
  int v32; // edi
  int v33; // esi
  int v34; // ebx
  char *v35; // eax
  int v36; // esi
  int v37; // ST4C_4
  int v38; // ST48_4
  int v39; // ST44_4
  int v40; // ST40_4
  int v41; // edi
  int v42; // ebx
  char *v43; // eax
  int v44; // edi
  int v45; // ST4C_4
  int v46; // ST48_4
  int v47; // ST44_4
  int v48; // ST40_4
  int v49; // ST3C_4
  int v50; // esi
  int v51; // ebx
  char *v52; // eax
  int v53; // edi
  int v54; // ST4C_4
  int v55; // ST48_4
  int v56; // ST44_4
  int v57; // ST40_4
  int v58; // ST3C_4
  int v59; // ST38_4
  int v60; // esi
  int v61; // ebx
  char *v62; // eax
  int v63; // edi
  int v64; // ST4C_4
  int v65; // ST48_4
  int v66; // ST44_4
  int v67; // ST40_4
  int v68; // ST3C_4
  int v69; // ST38_4
  int v70; // esi
  int v71; // ebx
  char *v72; // eax

  if ( a2 )
    fprintf(stream, "%s (%s) %s\n", a2, a3, a4);
  else
    fprintf(stream, "%s %s\n", a3, a4);
  v6 = gettext("(C)");
  fprintf(stream, "Copyright %s %d Free Software Foundation, Inc.", v6, 2017);
  v7 = gettext(
         "\n"
         "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\n"
         "This is free software: you are free to change and redistribute it.\n"
         "There is NO WARRANTY, to the extent permitted by law.\n"
         "\n");
  fputs_unlocked(v7, stream);
  switch ( a6 )
  {
    case 0:
      abort();
      return result;
    case 1:
      v8 = *(_DWORD *)a5;
      v9 = gettext("Written by %s.\n");
      result = fprintf(stream, v9, v8);
      break;
    case 2:
      v11 = *(_DWORD *)(a5 + 4);
      v12 = *(_DWORD *)a5;
      v13 = gettext("Written by %s and %s.\n");
      result = fprintf(stream, v13, v12, v11);
      break;
    case 3:
      v14 = *(_DWORD *)(a5 + 8);
      v15 = *(_DWORD *)(a5 + 4);
      v16 = *(_DWORD *)a5;
      v17 = gettext("Written by %s, %s, and %s.\n");
      result = fprintf(stream, v17, v16, v15, v14);
      break;
    case 4:
      v18 = *(_DWORD *)(a5 + 12);
      v19 = *(_DWORD *)(a5 + 8);
      v20 = *(_DWORD *)(a5 + 4);
      v21 = *(_DWORD *)a5;
      v22 = gettext("Written by %s, %s, %s,\nand %s.\n");
      result = fprintf(stream, v22, v21, v20, v19, v18);
      break;
    case 5:
      v23 = *(_DWORD *)(a5 + 16);
      v24 = *(_DWORD *)(a5 + 12);
      v25 = *(_DWORD *)(a5 + 8);
      v26 = *(_DWORD *)(a5 + 4);
      v27 = *(_DWORD *)a5;
      v28 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
      result = fprintf(stream, v28, v27, v26, v25, v24, v23);
      break;
    case 6:
      v29 = *(_DWORD *)(a5 + 20);
      v30 = *(_DWORD *)(a5 + 16);
      v31 = *(_DWORD *)(a5 + 12);
      v32 = *(_DWORD *)(a5 + 8);
      v33 = *(_DWORD *)(a5 + 4);
      v34 = *(_DWORD *)a5;
      v35 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
      result = fprintf(stream, v35, v34, v33, v32, v31, v30, v29);
      break;
    case 7:
      v36 = *(_DWORD *)(a5 + 24);
      v37 = *(_DWORD *)(a5 + 20);
      v38 = *(_DWORD *)(a5 + 16);
      v39 = *(_DWORD *)(a5 + 12);
      v40 = *(_DWORD *)(a5 + 8);
      v41 = *(_DWORD *)(a5 + 4);
      v42 = *(_DWORD *)a5;
      v43 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
      result = fprintf(stream, v43, v42, v41, v40, v39, v38, v37, v36);
      break;
    case 8:
      v44 = *(_DWORD *)(a5 + 28);
      v45 = *(_DWORD *)(a5 + 24);
      v46 = *(_DWORD *)(a5 + 20);
      v47 = *(_DWORD *)(a5 + 16);
      v48 = *(_DWORD *)(a5 + 12);
      v49 = *(_DWORD *)(a5 + 8);
      v50 = *(_DWORD *)(a5 + 4);
      v51 = *(_DWORD *)a5;
      v52 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
      result = fprintf(stream, v52, v51, v50, v49, v48, v47, v46, v45, v44);
      break;
    case 9:
      v53 = *(_DWORD *)(a5 + 32);
      v54 = *(_DWORD *)(a5 + 28);
      v55 = *(_DWORD *)(a5 + 24);
      v56 = *(_DWORD *)(a5 + 20);
      v57 = *(_DWORD *)(a5 + 16);
      v58 = *(_DWORD *)(a5 + 12);
      v59 = *(_DWORD *)(a5 + 8);
      v60 = *(_DWORD *)(a5 + 4);
      v61 = *(_DWORD *)a5;
      v62 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
      result = fprintf(stream, v62, v61, v60, v59, v58, v57, v56, v55, v54, v53);
      break;
    default:
      v63 = *(_DWORD *)(a5 + 32);
      v64 = *(_DWORD *)(a5 + 28);
      v65 = *(_DWORD *)(a5 + 24);
      v66 = *(_DWORD *)(a5 + 20);
      v67 = *(_DWORD *)(a5 + 16);
      v68 = *(_DWORD *)(a5 + 12);
      v69 = *(_DWORD *)(a5 + 8);
      v70 = *(_DWORD *)(a5 + 4);
      v71 = *(_DWORD *)a5;
      v72 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
      result = fprintf(stream, v72, v71, v70, v69, v68, v67, v66, v65, v64, v63);
      break;
  }
  return result;
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0805A5EA) --------------------------------------------------------
int __cdecl sub_805A5EA(FILE *stream, int a2, int a3, int a4, int a5)
{
  int *v5; // eax
  unsigned int i; // [esp+24h] [ebp-34h]
  int v8[12]; // [esp+28h] [ebp-30h]

  for ( i = 0; i <= 9; ++i )
  {
    v5 = (int *)a5;
    a5 += 4;
    v8[i] = *v5;
    if ( !v8[i] )
      break;
  }
  return sub_805A085(stream, a2, a3, a4, (int)v8, i);
}
// 805A5EA: using guessed type int var_30[12];

//----- (0805A650) --------------------------------------------------------
int sub_805A650(FILE *stream, int a2, int a3, int a4, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a4);
  return sub_805A5EA(stream, a2, a3, a4, (int)va);
}

//----- (0805A6F0) --------------------------------------------------------
void *__cdecl sub_805A6F0(unsigned int a1, unsigned int a2)
{
  if ( 0x7FFFFFFF / a2 < a1 )
    sub_805A94D();
  return sub_805A7FD(a2 * a1);
}

//----- (0805A753) --------------------------------------------------------
void *__cdecl sub_805A753(void *ptr, int a2, int a3)
{
  unsigned int v4; // [esp+1Ch] [ebp-Ch]

  v4 = *(_DWORD *)a2;
  if ( ptr )
  {
    if ( 0x55555554u / a3 <= v4 )
      sub_805A94D();
    v4 += (v4 >> 1) + 1;
  }
  else
  {
    if ( !v4 )
      v4 = (0x40u / a3 == 0) + 0x40u / a3;
    if ( 0x7FFFFFFFu / a3 < v4 )
      sub_805A94D();
  }
  *(_DWORD *)a2 = v4;
  return sub_805A827(ptr, a3 * v4);
}

//----- (0805A7EA) --------------------------------------------------------
void *__cdecl sub_805A7EA(size_t size)
{
  return sub_805A7FD(size);
}

//----- (0805A7FD) --------------------------------------------------------
void *__cdecl sub_805A7FD(size_t size)
{
  void *v2; // [esp+1Ch] [ebp-Ch]

  v2 = malloc(size);
  if ( !v2 && size )
    sub_805A94D();
  return v2;
}

//----- (0805A827) --------------------------------------------------------
void *__cdecl sub_805A827(void *ptr, size_t size)
{
  void *result; // eax
  void *ptra; // [esp+20h] [ebp+8h]

  if ( size || !ptr )
  {
    ptra = realloc(ptr, size);
    if ( !ptra )
    {
      if ( size )
        sub_805A94D();
    }
    result = ptra;
  }
  else
  {
    free(ptr);
    result = 0;
  }
  return result;
}

//----- (0805A8C2) --------------------------------------------------------
void *__cdecl sub_805A8C2(size_t nmemb, size_t size)
{
  void *v3; // [esp+1Ch] [ebp-Ch]

  if ( 0x7FFFFFFF / size < nmemb || (v3 = calloc(nmemb, size)) == 0 )
    sub_805A94D();
  return v3;
}

//----- (0805A8FF) --------------------------------------------------------
void *__cdecl sub_805A8FF(void *src, size_t n)
{
  void *v2; // eax

  v2 = sub_805A7FD(n);
  return memcpy(v2, src, n);
}

//----- (0805A94D) --------------------------------------------------------
void __noreturn sub_805A94D()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (0805A986) --------------------------------------------------------
void __cdecl sub_805A986(int errnum, int a2, int a3, int a4, int a5)
{
  char *v5; // eax
  char *v6; // eax
  void *v7; // esi
  void *v8; // ebx
  char *v9; // eax

  v5 = gettext("string comparison failed");
  error(0, errnum, v5);
  v6 = gettext("Set LC_ALL='C' to work around the problem.");
  error(0, 0, v6);
  v7 = sub_80581DA(1, 8, a4, a5);
  v8 = sub_80581DA(0, 8, a2, a3);
  v9 = gettext("The strings compared were %s and %s.");
  error(status, 0, v9, v8, v7);
}

//----- (0805AAB7) --------------------------------------------------------
int __cdecl sub_805AAB7(void *s1, size_t n, void *s2, int a4)
{
  int v5; // [esp+28h] [ebp-10h]
  int errnum; // [esp+2Ch] [ebp-Ch]

  v5 = sub_805CC44(s1, n, s2, a4);
  errnum = *__errno_location();
  if ( errnum )
    sub_805A986(errnum, (int)s1, n - 1, (int)s2, a4 - 1);
  return v5;
}

//----- (0805AB22) --------------------------------------------------------
signed int __cdecl sub_805AB22(double a1)
{
  struct timespec requested_time; // [esp+28h] [ebp-10h]

  sub_805C30A(&requested_time, a1);
  do
  {
    *__errno_location() = 0;
    if ( !nanosleep(&requested_time, 0) )
      return 0;
  }
  while ( *__errno_location() == 4 || !*__errno_location() );
  return -1;
}

//----- (0805AB94) --------------------------------------------------------
signed int __cdecl sub_805AB94(unsigned int *a1, unsigned int a2)
{
  signed int result; // eax

  if ( 0xFFFFFFFF / a2 >= *a1 )
  {
    *a1 *= a2;
    result = 0;
  }
  else
  {
    *a1 = -1;
    result = 1;
  }
  return result;
}

//----- (0805ABD8) --------------------------------------------------------
int __cdecl sub_805ABD8(unsigned int *a1, unsigned int a2, int a3)
{
  int v3; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; i |= sub_805AB94(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}

//----- (0805AC0E) --------------------------------------------------------
int __cdecl sub_805AC0E(char *nptr, int a2, int base, int a4, char *s)
{
  char **v5; // eax
  int result; // eax
  int v7; // eax
  unsigned __int8 i; // [esp+1Fh] [ebp-29h]
  char v9; // [esp+20h] [ebp-28h]
  unsigned int v10; // [esp+24h] [ebp-24h]
  int v11; // [esp+28h] [ebp-20h]
  char *v12; // [esp+2Ch] [ebp-1Ch]
  unsigned int v13; // [esp+30h] [ebp-18h]
  int v14; // [esp+34h] [ebp-14h]
  int v15; // [esp+38h] [ebp-10h]
  char **endptr; // [esp+3Ch] [ebp-Ch]

  v11 = 0;
  if ( base < 0 || base > 36 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoul");
  if ( a2 )
    v5 = (char **)a2;
  else
    v5 = (char **)&v9;
  endptr = v5;
  *__errno_location() = 0;
  v12 = nptr;
  for ( i = *nptr; (*__ctype_b_loc())[i] & 0x2000; i = *v12 )
    ++v12;
  if ( i == 45 )
    return 4;
  v10 = strtoul(nptr, endptr, base);
  if ( *endptr == nptr )
  {
    if ( !s || !**endptr || !strchr(s, **endptr) )
      return 4;
    v10 = 1;
  }
  else if ( *__errno_location() )
  {
    if ( *__errno_location() != 34 )
      return 4;
    v11 = 1;
  }
  if ( !s )
  {
    *(_DWORD *)a4 = v10;
    return v11;
  }
  if ( !**endptr )
  {
LABEL_53:
    *(_DWORD *)a4 = v10;
    return v11;
  }
  v13 = 1024;
  v14 = 1;
  if ( !strchr(s, **endptr) )
  {
    *(_DWORD *)a4 = v10;
    return v11 | 2;
  }
  switch ( **endptr )
  {
    case 69:
    case 71:
    case 75:
    case 77:
    case 80:
    case 84:
    case 89:
    case 90:
    case 103:
    case 107:
    case 109:
    case 116:
      if ( strchr(s, 48) )
      {
        v7 = (*endptr)[1];
        switch ( v7 )
        {
          case 68:
            goto LABEL_56;
          case 105:
            if ( (*endptr)[2] == 66 )
              v14 += 2;
            goto LABEL_37;
          case 66:
LABEL_56:
            v13 = 1000;
            ++v14;
            break;
        }
      }
      break;
    default:
      break;
  }
LABEL_37:
  switch ( **endptr )
  {
    case 66:
      v15 = sub_805AB94(&v10, 0x400u);
      goto LABEL_51;
    case 69:
      v15 = sub_805ABD8(&v10, v13, 6);
      goto LABEL_51;
    case 71:
    case 103:
      v15 = sub_805ABD8(&v10, v13, 3);
      goto LABEL_51;
    case 75:
    case 107:
      v15 = sub_805ABD8(&v10, v13, 1);
      goto LABEL_51;
    case 77:
    case 109:
      v15 = sub_805ABD8(&v10, v13, 2);
      goto LABEL_51;
    case 80:
      v15 = sub_805ABD8(&v10, v13, 5);
      goto LABEL_51;
    case 84:
    case 116:
      v15 = sub_805ABD8(&v10, v13, 4);
      goto LABEL_51;
    case 89:
      v15 = sub_805ABD8(&v10, v13, 8);
      goto LABEL_51;
    case 90:
      v15 = sub_805ABD8(&v10, v13, 7);
      goto LABEL_51;
    case 98:
      v15 = sub_805AB94(&v10, 0x200u);
      goto LABEL_51;
    case 99:
      v15 = 0;
      goto LABEL_51;
    case 119:
      v15 = sub_805AB94(&v10, 2u);
LABEL_51:
      v11 |= v15;
      *endptr += v14;
      if ( **endptr )
        v11 |= 2u;
      goto LABEL_53;
    default:
      *(_DWORD *)a4 = v10;
      result = v11 | 2;
      break;
  }
  return result;
}

//----- (0805AFE2) --------------------------------------------------------
void __cdecl sub_805AFE2(int a1, int a2, int a3, int a4, int a5, int status)
{
  char *v6; // eax
  char v7; // [esp+22h] [ebp-16h]
  char v8; // [esp+23h] [ebp-15h]
  const char *v9; // [esp+24h] [ebp-14h]
  char *msgid; // [esp+28h] [ebp-10h]
  char *v11; // [esp+2Ch] [ebp-Ch]

  v9 = "--";
  if ( (unsigned int)a1 > 3 )
  {
    if ( a1 != 4 )
      goto LABEL_6;
    msgid = "invalid %s%s argument '%s'";
  }
  else if ( (unsigned int)a1 >= 2 )
  {
    msgid = "invalid suffix in %s%s argument '%s'";
  }
  else
  {
    if ( a1 != 1 )
LABEL_6:
      abort();
    msgid = "%s%s argument '%s' too large";
  }
  if ( a2 >= 0 )
  {
    v11 = *(char **)(16 * a2 + a4);
  }
  else
  {
    v9 -= a2;
    v7 = a3;
    v8 = 0;
    v11 = &v7;
  }
  v6 = gettext(msgid);
  error(status, 0, v6, v9, v11, a5);
}

//----- (0805B098) --------------------------------------------------------
void __cdecl __noreturn sub_805B098(int a1, int a2, char a3, int a4, int a5)
{
  sub_805AFE2(a1, a2, a3, a4, a5, status);
  abort();
}

//----- (0805B0DB) --------------------------------------------------------
signed int __cdecl sub_805B0DB(int a1, signed int a2)
{
  signed int result; // eax
  int v3; // ebx

  if ( (unsigned __int64)sub_805CD71(0xFFFFFFFFFFFFFFFFLL, a2, a2 >> 31) >= *(_QWORD *)a1 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    *(_QWORD *)a1 *= a2;
    result = 0;
  }
  else
  {
    *(_DWORD *)a1 = -1;
    *(_DWORD *)(a1 + 4) = -1;
    result = 1;
  }
  return result;
}

//----- (0805B167) --------------------------------------------------------
int __cdecl sub_805B167(int a1, signed int a2, int a3)
{
  int v3; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; ; i |= sub_805B0DB(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}

//----- (0805B19D) --------------------------------------------------------
int __cdecl sub_805B19D(char *nptr, int a2, int base, int a4, char *s)
{
  char **v5; // eax
  int result; // eax
  int v7; // edx
  int v8; // edx
  int v9; // eax
  int v10; // edx
  int v11; // edx
  unsigned __int8 i; // [esp+1Bh] [ebp-2Dh]
  char v13; // [esp+1Ch] [ebp-2Ch]
  int v14; // [esp+20h] [ebp-28h]
  char *v15; // [esp+24h] [ebp-24h]
  int v16; // [esp+28h] [ebp-20h]
  int v17; // [esp+2Ch] [ebp-1Ch]
  int v18; // [esp+30h] [ebp-18h]
  char **endptr; // [esp+34h] [ebp-14h]
  uintmax_t v20; // [esp+38h] [ebp-10h]

  v14 = 0;
  if ( base < 0 || base > 36 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoumax");
  if ( a2 )
    v5 = (char **)a2;
  else
    v5 = (char **)&v13;
  endptr = v5;
  *__errno_location() = 0;
  v15 = nptr;
  for ( i = *nptr; (*__ctype_b_loc())[i] & 0x2000; i = *v15 )
    ++v15;
  if ( i == 45 )
    return 4;
  v20 = strtoumax(nptr, endptr, base);
  if ( *endptr == nptr )
  {
    if ( !s || !**endptr || !strchr(s, **endptr) )
      return 4;
    v20 = 1LL;
  }
  else if ( *__errno_location() )
  {
    if ( *__errno_location() != 34 )
      return 4;
    v14 = 1;
  }
  if ( !s )
  {
    v7 = HIDWORD(v20);
    *(_DWORD *)a4 = v20;
    *(_DWORD *)(a4 + 4) = v7;
    return v14;
  }
  if ( !**endptr )
  {
LABEL_53:
    v11 = HIDWORD(v20);
    *(_DWORD *)a4 = v20;
    *(_DWORD *)(a4 + 4) = v11;
    return v14;
  }
  v16 = 1024;
  v17 = 1;
  if ( !strchr(s, **endptr) )
  {
    v8 = HIDWORD(v20);
    *(_DWORD *)a4 = v20;
    *(_DWORD *)(a4 + 4) = v8;
    return v14 | 2;
  }
  switch ( **endptr )
  {
    case 69:
    case 71:
    case 75:
    case 77:
    case 80:
    case 84:
    case 89:
    case 90:
    case 103:
    case 107:
    case 109:
    case 116:
      if ( strchr(s, 48) )
      {
        v9 = (*endptr)[1];
        switch ( v9 )
        {
          case 68:
            goto LABEL_56;
          case 105:
            if ( (*endptr)[2] == 66 )
              v17 += 2;
            goto LABEL_37;
          case 66:
LABEL_56:
            v16 = 1000;
            ++v17;
            break;
        }
      }
      break;
    default:
      break;
  }
LABEL_37:
  switch ( **endptr )
  {
    case 66:
      v18 = sub_805B0DB((int)&v20, 1024);
      goto LABEL_51;
    case 69:
      v18 = sub_805B167((int)&v20, v16, 6);
      goto LABEL_51;
    case 71:
    case 103:
      v18 = sub_805B167((int)&v20, v16, 3);
      goto LABEL_51;
    case 75:
    case 107:
      v18 = sub_805B167((int)&v20, v16, 1);
      goto LABEL_51;
    case 77:
    case 109:
      v18 = sub_805B167((int)&v20, v16, 2);
      goto LABEL_51;
    case 80:
      v18 = sub_805B167((int)&v20, v16, 5);
      goto LABEL_51;
    case 84:
    case 116:
      v18 = sub_805B167((int)&v20, v16, 4);
      goto LABEL_51;
    case 89:
      v18 = sub_805B167((int)&v20, v16, 8);
      goto LABEL_51;
    case 90:
      v18 = sub_805B167((int)&v20, v16, 7);
      goto LABEL_51;
    case 98:
      v18 = sub_805B0DB((int)&v20, 512);
      goto LABEL_51;
    case 99:
      v18 = 0;
      goto LABEL_51;
    case 119:
      v18 = sub_805B0DB((int)&v20, 2);
LABEL_51:
      v14 |= v18;
      *endptr += v17;
      if ( **endptr )
        v14 |= 2u;
      goto LABEL_53;
    default:
      v10 = HIDWORD(v20);
      *(_DWORD *)a4 = v20;
      *(_DWORD *)(a4 + 4) = v10;
      result = v14 | 2;
      break;
  }
  return result;
}

//----- (0805B593) --------------------------------------------------------
int __cdecl sub_805B593(FILE *stream)
{
  int v2; // eax
  __int64 v3; // rax
  int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]

  v4 = 0;
  if ( fileno(stream) < 0 )
    return fclose(stream);
  if ( !__freading(stream) || (v2 = fileno(stream), LODWORD(v3) = lseek64(v2, 0, 0, 1), v3 != -1) )
  {
    if ( sub_805B7F9(stream) )
      v4 = *__errno_location();
  }
  v5 = fclose(stream);
  if ( v4 )
  {
    *__errno_location() = v4;
    v5 = -1;
  }
  return v5;
}
// 8049A90: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0805B656) --------------------------------------------------------
int __cdecl sub_805B656(int fd, int cmd, char a3)
{
  int v3; // ST28_4
  int v5; // [esp+1Ch] [ebp-1Ch]
  char v6; // [esp+20h] [ebp-18h]
  int v7; // [esp+24h] [ebp-14h]

  if ( cmd != 1030 )
    return fcntl(fd, cmd, a3);
  v6 = a3;
  if ( dword_8065AED < 0 )
  {
    v5 = sub_805B656(fd, 0, a3);
  }
  else
  {
    v5 = fcntl(fd, 1030, a3);
    if ( v5 < 0 && *__errno_location() == 22 )
    {
      v5 = sub_805B656(fd, 0, v6);
      if ( v5 < 0 )
        return v5;
      dword_8065AED = -1;
    }
    else
    {
      dword_8065AED = 1;
    }
  }
  if ( v5 >= 0 && dword_8065AED == -1 )
  {
    v7 = fcntl(v5, 1);
    if ( v7 < 0 || fcntl(v5, 2, v7 | 1) == -1 )
    {
      v3 = *__errno_location();
      close(v5);
      *__errno_location() = v3;
      v5 = -1;
    }
  }
  return v5;
}
// 8065AED: using guessed type int dword_8065AED;

//----- (0805B7C0) --------------------------------------------------------
int __cdecl sub_805B7C0(FILE *stream)
{
  int result; // eax

  result = stream->_flags & 0x100;
  if ( result )
    result = sub_805B839(stream, 0, 0, 1);
  return result;
}

//----- (0805B7F9) --------------------------------------------------------
int __cdecl sub_805B7F9(FILE *fp)
{
  if ( !fp || !__freading(fp) )
    return fflush(fp);
  sub_805B7C0(fp);
  return fflush(fp);
}

//----- (0805B839) --------------------------------------------------------
int __cdecl sub_805B839(FILE *stream, int a2, int a3, int a4)
{
  int v4; // eax
  __off64_t v5; // rax

  if ( stream->_IO_read_end != stream->_IO_read_ptr
    || stream->_IO_write_ptr != stream->_IO_write_base
    || stream->_IO_save_base )
  {
    return fseeko64(stream, a2, a3, a4);
  }
  v4 = fileno(stream);
  LODWORD(v5) = lseek64(v4, a2, a3, a4);
  if ( v5 == -1 )
    return -1;
  stream->_flags &= 0xFFFFFFEF;
  stream->_offset = v5;
  return 0;
}
// 80498B0: using guessed type int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8049A90: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0805B90B) --------------------------------------------------------
size_t __cdecl sub_805B90B(wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  char v5; // [esp+18h] [ebp-10h]
  size_t v6; // [esp+1Ch] [ebp-Ch]

  if ( !pwc )
    pwc = (wchar_t *)&v5;
  v6 = mbrtowc(pwc, s, n, p);
  if ( v6 <= 0xFFFFFFFD || !n || !((unsigned __int8)sub_8054CAD(0) ^ 1) )
    return v6;
  *pwc = (unsigned __int8)*s;
  return 1;
}

//----- (0805B97D) --------------------------------------------------------
int __cdecl sub_805B97D(int a1, int a2)
{
  int result; // eax

  if ( *(_BYTE *)(a1 + 40) & 1 )
    result = (*(int (__cdecl **)(_DWORD, int))(a1 + 28))(*(_DWORD *)(a1 + 36), a2);
  else
    result = (*(int (__cdecl **)(int))(a1 + 28))(a2);
  return result;
}

//----- (0805B9BB) --------------------------------------------------------
int __cdecl sub_805B9BB(int a1, int a2)
{
  int result; // eax

  if ( *(_BYTE *)(a1 + 40) & 1 )
    result = (*(int (__cdecl **)(_DWORD, int))(a1 + 32))(*(_DWORD *)(a1 + 36), a2);
  else
    result = (*(int (__cdecl **)(int))(a1 + 32))(a2);
  return result;
}

//----- (0805B9F9) --------------------------------------------------------
signed int __cdecl sub_805B9F9(int a1, signed int a2, signed int a3)
{
  _DWORD *v4; // [esp+1Ch] [ebp-Ch]

  if ( !a3 )
    a3 = 8;
  if ( !a2 )
    a2 = 4064;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 24) = a3 - 1;
  *(_DWORD *)(a1 + 4) = sub_805B97D(a1, *(_DWORD *)a1);
  v4 = *(_DWORD **)(a1 + 4);
  if ( !v4 )
    obstack_alloc_failed_handler();
  *(_DWORD *)(a1 + 8) = ((unsigned int)&v4[a3 / 4u + 1] + 3) & -a3;
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 8);
  *v4 = (char *)v4 + *(_DWORD *)a1;
  *(_DWORD *)(a1 + 16) = *v4;
  v4[1] = 0;
  *(_BYTE *)(a1 + 40) &= 0xFDu;
  *(_BYTE *)(a1 + 40) &= 0xFBu;
  return 1;
}
// 80653A0: using guessed type int (*obstack_alloc_failed_handler)(void);

//----- (0805BAD8) --------------------------------------------------------
signed int __cdecl sub_805BAD8(int a1, signed int a2, signed int a3, int a4, int a5)
{
  *(_DWORD *)(a1 + 28) = a4;
  *(_DWORD *)(a1 + 32) = a5;
  *(_BYTE *)(a1 + 40) &= 0xFEu;
  return sub_805B9F9(a1, a2, a3);
}

//----- (0805BB61) --------------------------------------------------------
int __cdecl sub_805BB61(int a1, int a2)
{
  int result; // eax
  _DWORD *v3; // [esp+14h] [ebp-24h]
  unsigned int v4; // [esp+18h] [ebp-20h]
  int v5; // [esp+1Ch] [ebp-1Ch]
  unsigned int n; // [esp+20h] [ebp-18h]
  unsigned int v7; // [esp+24h] [ebp-14h]
  unsigned int v8; // [esp+28h] [ebp-10h]
  void *dest; // [esp+2Ch] [ebp-Ch]

  v5 = *(_DWORD *)(a1 + 4);
  v3 = 0;
  n = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 8);
  v7 = n + a2;
  v8 = *(_DWORD *)(a1 + 24) + n + a2;
  v4 = (n >> 3) + v8 + 100;
  if ( v4 < v8 )
    v4 = *(_DWORD *)(a1 + 24) + n + a2;
  if ( *(_DWORD *)a1 > v4 )
    v4 = *(_DWORD *)a1;
  if ( n <= v7 && v7 <= v8 )
    v3 = (_DWORD *)sub_805B97D(a1, v4);
  if ( !v3 )
    obstack_alloc_failed_handler();
  *(_DWORD *)(a1 + 4) = v3;
  v3[1] = v5;
  *(_DWORD *)(a1 + 16) = (char *)v3 + v4;
  *v3 = *(_DWORD *)(a1 + 16);
  dest = (void *)(((unsigned int)v3 + *(_DWORD *)(a1 + 24) + 8) & ~*(_DWORD *)(a1 + 24));
  memcpy(dest, *(const void **)(a1 + 8), n);
  if ( !(*(_BYTE *)(a1 + 40) & 2) && *(_DWORD *)(a1 + 8) == ((*(_DWORD *)(a1 + 24) + v5 + 8) & ~*(_DWORD *)(a1 + 24)) )
  {
    v3[1] = *(_DWORD *)(v5 + 4);
    sub_805B9BB(a1, v5);
  }
  *(_DWORD *)(a1 + 8) = dest;
  *(_DWORD *)(a1 + 12) = n + *(_DWORD *)(a1 + 8);
  result = a1;
  *(_BYTE *)(a1 + 40) &= 0xFDu;
  return result;
}
// 80653A0: using guessed type int (*obstack_alloc_failed_handler)(void);

//----- (0805BD2B) --------------------------------------------------------
int __cdecl sub_805BD2B(int a1, unsigned int a2)
{
  int result; // eax
  int *v3; // ST1C_4
  int *v4; // [esp+18h] [ebp-10h]

  result = *(_DWORD *)(a1 + 4);
  v4 = *(int **)(a1 + 4);
  while ( v4 )
  {
    if ( (unsigned int)v4 < a2 )
    {
      result = *v4;
      if ( *v4 >= a2 )
        break;
    }
    v3 = (int *)v4[1];
    sub_805B9BB(a1, (int)v4);
    v4 = v3;
    result = a1;
    *(_BYTE *)(a1 + 40) |= 2u;
  }
  if ( v4 )
  {
    *(_DWORD *)(a1 + 12) = a2;
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 16) = *v4;
    result = a1;
    *(_DWORD *)(a1 + 4) = v4;
  }
  else if ( a2 )
  {
    abort();
  }
  return result;
}

//----- (0805BF41) --------------------------------------------------------
int __cdecl sub_805BF41(int a1, char a2)
{
  return __ROR4__(a1, a2);
}

//----- (0805C02C) --------------------------------------------------------
signed int __cdecl sub_805C02C(signed int a1)
{
  if ( a1 > 90 )
  {
    if ( (unsigned int)(a1 - 97) <= 0x19 )
      return 1;
  }
  else if ( a1 >= 65 || (unsigned int)(a1 - 48) <= 9 )
  {
    return 1;
  }
  return 0;
}

//----- (0805C05C) --------------------------------------------------------
_BOOL4 __cdecl sub_805C05C(signed int a1)
{
  return a1 >= 65 && (a1 <= 90 || (unsigned int)(a1 - 97) <= 0x19);
}

//----- (0805C0E0) --------------------------------------------------------
_BOOL4 __cdecl sub_805C0E0(int a1)
{
  return (unsigned int)(a1 - 48) <= 9;
}

//----- (0805C18A) --------------------------------------------------------
_BOOL4 __cdecl sub_805C18A(signed int a1)
{
  return a1 >= 9 && (a1 <= 13 || a1 == 32);
}

//----- (0805C1EE) --------------------------------------------------------
int __cdecl sub_805C1EE(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 65) > 0x19 )
    result = a1;
  else
    result = a1 + 32;
  return result;
}

//----- (0805C224) --------------------------------------------------------
int __cdecl sub_805C224(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // esi
  unsigned __int8 *v3; // ebx
  unsigned __int8 v5; // [esp+1Eh] [ebp-Ah]
  unsigned __int8 v6; // [esp+1Fh] [ebp-9h]

  v2 = a1;
  v3 = a2;
  if ( a1 == a2 )
    return 0;
  do
  {
    v5 = sub_805C1EE(*v2);
    v6 = sub_805C1EE(*v3);
    if ( !v5 )
      break;
    ++v2;
    ++v3;
  }
  while ( v5 == v6 );
  return v5 - v6;
}

//----- (0805C289) --------------------------------------------------------
int __cdecl sub_805C289(FILE *fp)
{
  bool v1; // ST1E_1
  bool v3; // [esp+1Dh] [ebp-Bh]
  bool v4; // [esp+1Fh] [ebp-9h]

  v3 = __fpending(fp) != 0;
  v1 = ferror_unlocked(fp) != 0;
  v4 = sub_805B593(fp) != 0;
  if ( !v1 && (!v4 || !v3 && *__errno_location() == 9) )
    return 0;
  if ( v4 != 1 )
    *__errno_location() = 0;
  return -1;
}

//----- (0805C30A) --------------------------------------------------------
_DWORD *__userpurge sub_805C30A@<eax>(_DWORD *a1, double a2)
{
  signed int v2; // ST20_4
  double v3; // ST28_8
  int v4; // ST24_4
  int v6; // [esp+20h] [ebp-18h]
  int v7; // [esp+24h] [ebp-14h]

  if ( a2 <= -2147483648.0 )
  {
    sub_805CCA3(a1, 2147483648, 0);
  }
  else if ( 2147483648.0 <= a2 )
  {
    sub_805CCA3(a1, 0x7FFFFFFF, 999999999);
  }
  else
  {
    v2 = (signed int)a2;
    v3 = (a2 - (long double)v2) * 1000000000.0;
    v4 = (v3 > (long double)(signed int)v3) + (signed int)v3;
    v6 = v4 / 1000000000 + v2;
    v7 = v4 % 1000000000;
    if ( v7 < 0 )
    {
      --v6;
      v7 += 1000000000;
    }
    sub_805CCA3(a1, v6, v7);
  }
  return a1;
}

//----- (0805C453) --------------------------------------------------------
int __cdecl sub_805C453(int fd, int a2)
{
  int v2; // ST18_4
  int v3; // ST1C_4

  if ( fd >= 0 && fd <= 2 )
  {
    v2 = sub_805C4A4(fd, a2);
    v3 = *__errno_location();
    close(fd);
    *__errno_location() = v3;
    fd = v2;
  }
  return fd;
}

//----- (0805C4A4) --------------------------------------------------------
int __cdecl sub_805C4A4(int fd, int a2)
{
  int v2; // eax

  if ( a2 & 0x80000 )
    v2 = 1030;
  else
    v2 = 0;
  return sub_805B656(fd, v2, 3);
}

//----- (0805C4DB) --------------------------------------------------------
FILE *__cdecl sub_805C4DB(int a1, char *modes)
{
  int v2; // ST28_4
  int v4; // ST2C_4
  FILE *stream; // [esp+1Ch] [ebp-1Ch]
  signed int v6; // [esp+20h] [ebp-18h]
  int fd; // [esp+24h] [ebp-14h]

  stream = (FILE *)fopen64(a1, modes);
  if ( !stream )
    return stream;
  v6 = fileno(stream);
  if ( v6 < 0 || v6 > 2 )
    return stream;
  fd = sub_805CD4C(v6);
  if ( fd < 0 )
  {
    v2 = *__errno_location();
    sub_805B593(stream);
    *__errno_location() = v2;
    return 0;
  }
  if ( !sub_805B593(stream) )
  {
    stream = fdopen(fd, modes);
    if ( stream )
      return stream;
  }
  v4 = *__errno_location();
  close(fd);
  *__errno_location() = v4;
  return 0;
}
// 80499F0: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (0805C5B1) --------------------------------------------------------
void *sub_805C5B1()
{
  _BOOL4 v0; // eax
  void *v2; // [esp+18h] [ebp-B0h]
  const char *s; // [esp+1Ch] [ebp-ACh]
  void *v4; // [esp+20h] [ebp-A8h]
  int v5; // [esp+24h] [ebp-A4h]
  size_t n; // [esp+2Ch] [ebp-9Ch]
  size_t v7; // [esp+30h] [ebp-98h]
  _BOOL4 v8; // [esp+34h] [ebp-94h]
  char *dest; // [esp+38h] [ebp-90h]
  int fd; // [esp+3Ch] [ebp-8Ch]
  FILE *stream; // [esp+40h] [ebp-88h]
  int c; // [esp+44h] [ebp-84h]
  int ca; // [esp+44h] [ebp-84h]
  size_t v14; // [esp+48h] [ebp-80h]
  size_t v15; // [esp+4Ch] [ebp-7Ch]
  void *v16; // [esp+50h] [ebp-78h]
  char src; // [esp+56h] [ebp-72h]
  char v18; // [esp+89h] [ebp-3Fh]
  unsigned int v19; // [esp+BCh] [ebp-Ch]

  v19 = __readgsdword(0x14u);
  v2 = (void *)dword_8065AF1;
  if ( !dword_8065AF1 )
  {
    s = getenv("CHARSETALIASDIR");
    if ( !s || !*s )
      s = "/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib";
    n = strlen(s);
    v7 = strlen("charset.alias");
    v0 = n && s[n - 1] != 47;
    v8 = v0;
    dest = (char *)malloc(n + v0 + v7 + 1);
    if ( dest )
    {
      memcpy(dest, s, n);
      if ( v8 )
        dest[n] = 47;
      memcpy(&dest[n + v8], "charset.alias", v7 + 1);
    }
    free(0);
    if ( dest )
    {
      fd = open64(dest, 0x20000);
      if ( fd >= 0 )
      {
        stream = fdopen(fd, "r");
        if ( stream )
        {
          v4 = 0;
          v5 = 0;
          while ( 1 )
          {
            c = getc_unlocked(stream);
            if ( c == -1 )
              break;
            if ( c != 10 && c != 32 && c != 9 )
            {
              if ( c == 35 )
              {
                do
                  ca = getc_unlocked(stream);
                while ( ca != -1 && ca != 10 );
                if ( ca == -1 )
                  break;
              }
              else
              {
                ungetc(c, stream);
                if ( fscanf(stream, "%50s %50s", &src, &v18) <= 1 )
                  break;
                v14 = strlen(&src);
                v15 = strlen(&v18);
                v16 = v4;
                if ( v5 )
                {
                  v5 += v15 + v14 + 2;
                  v4 = realloc(v4, v5 + 1);
                }
                else
                {
                  v5 = v14 + v15 + 2;
                  v4 = malloc(v14 + v15 + 3);
                }
                if ( !v4 )
                {
                  v5 = 0;
                  free(v16);
                  break;
                }
                strcpy((char *)v4 + v5 - v15 - v14 - 2, &src);
                strcpy((char *)v4 + v5 - v15 - 1, &v18);
              }
            }
          }
          sub_805B593(stream);
          if ( v5 )
          {
            *((_BYTE *)v4 + v5) = 0;
            v2 = v4;
          }
          else
          {
            v2 = &unk_80604EF;
          }
        }
        else
        {
          close(fd);
          v2 = &unk_80604EF;
        }
      }
      else
      {
        v2 = &unk_80604EF;
      }
      free(dest);
    }
    else
    {
      v2 = &unk_80604EF;
    }
    dword_8065AF1 = (int)v2;
  }
  return v2;
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 8065AF1: using guessed type int dword_8065AF1;

//----- (0805CA29) --------------------------------------------------------
const char *sub_805CA29()
{
  char *v0; // ST1C_4
  const char *s1; // [esp+18h] [ebp-10h]
  char *s2; // [esp+1Ch] [ebp-Ch]

  s1 = nl_langinfo(14);
  if ( !s1 )
    s1 = (const char *)&unk_80604EF;
  for ( s2 = (char *)sub_805C5B1(); *s2; s2 = &v0[strlen(v0) + 1] )
  {
    if ( !strcmp(s1, s2) || *s2 == 42 && !s2[1] )
    {
      s1 = &s2[strlen(s2) + 1];
      break;
    }
    v0 = &s2[strlen(s2) + 1];
  }
  if ( !*s1 )
    s1 = "ASCII";
  return s1;
}

//----- (0805CADC) --------------------------------------------------------
int __cdecl sub_805CADC(char *s, int a2, char *s2, int a4)
{
  size_t v4; // ST18_4
  size_t v5; // ST1C_4
  _BOOL4 v7; // eax
  int v8; // [esp+14h] [ebp-14h]

  while ( 1 )
  {
    *__errno_location() = 0;
    v8 = strcoll(s, s2);
    v7 = v8 || *__errno_location();
    if ( v7 )
      break;
    v4 = strlen(s) + 1;
    v5 = strlen(s2) + 1;
    s += v4;
    s2 += v5;
    a2 -= v4;
    a4 -= v5;
    if ( !a2 )
      return -(a4 != 0);
    if ( !a4 )
      return 1;
  }
  return v8;
}

//----- (0805CB89) --------------------------------------------------------
int __cdecl sub_805CB89(void *s1, size_t n, void *s2, int a4)
{
  char v4; // ST1A_1
  char v5; // ST1B_1
  int v7; // [esp+1Ch] [ebp-Ch]

  if ( n == a4 && !memcmp(s1, s2, n) )
  {
    *__errno_location() = 0;
    v7 = 0;
  }
  else
  {
    v4 = *((_BYTE *)s1 + n);
    v5 = *((_BYTE *)s2 + a4);
    *((_BYTE *)s1 + n) = 0;
    *((_BYTE *)s2 + a4) = 0;
    v7 = sub_805CADC((char *)s1, n + 1, (char *)s2, a4 + 1);
    *((_BYTE *)s1 + n) = v4;
    *((_BYTE *)s2 + a4) = v5;
  }
  return v7;
}

//----- (0805CC44) --------------------------------------------------------
int __cdecl sub_805CC44(void *s1, size_t n, void *s2, int a4)
{
  if ( n != a4 || memcmp(s1, s2, n) )
    return sub_805CADC((char *)s1, n, (char *)s2, a4);
  *__errno_location() = 0;
  return 0;
}

//----- (0805CCA3) --------------------------------------------------------
_DWORD *__userpurge sub_805CCA3@<eax>(_DWORD *a1, int a2, int a3)
{
  *a1 = a2;
  a1[1] = a3;
  return a1;
}

//----- (0805CD4C) --------------------------------------------------------
int __cdecl sub_805CD4C(int fd)
{
  return sub_805B656(fd, 0, 3);
}

//----- (0805CD71) --------------------------------------------------------
signed __int64 __cdecl sub_805CD71(unsigned __int64 a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // esi
  signed __int64 result; // rax
  int v5; // ebp
  int v6; // ebp
  int v7; // ST08_4
  unsigned __int64 v8; // rtt
  unsigned int v9; // esi
  unsigned int v10; // edi
  unsigned __int64 v11; // rax

  if ( !a3 )
  {
    if ( a2 > HIDWORD(a1) )
      return (unsigned int)(a1 / a2);
    v3 = a2;
    if ( !a2 )
      v3 = 1 / 0u;
    LODWORD(result) = __PAIR__(HIDWORD(a1) % v3, (unsigned int)a1) / v3;
    HIDWORD(result) = HIDWORD(a1) / v3;
    return result;
  }
  if ( a3 > HIDWORD(a1) )
    return 0LL;
  _BitScanReverse((unsigned int *)&v5, a3);
  v6 = v5 ^ 0x1F;
  if ( !v6 )
  {
    if ( a2 <= (unsigned int)a1 || a3 < HIDWORD(a1) )
      return 1LL;
    return 0LL;
  }
  v7 = (a3 << v6) | (a2 >> (32 - v6));
  LODWORD(v8) = (HIDWORD(a1) << v6) | ((unsigned int)a1 >> (32 - v6));
  HIDWORD(v8) = HIDWORD(a1) >> (32 - v6);
  v9 = v8 % (unsigned int)v7;
  v10 = v8 / (unsigned int)v7;
  v11 = (a2 << v6) * (unsigned __int64)v10;
  if ( v9 < HIDWORD(v11) || (_DWORD)a1 << v6 < (unsigned int)v11 && v9 == (a2 << v6) * (unsigned __int64)v10 >> 32 )
    result = v10 - 1;
  else
    result = v10;
  return result;
}

//----- (0805CE91) --------------------------------------------------------
int __cdecl sub_805CE91(unsigned __int64 a1, __int64 a2)
{
  int v2; // edx
  int result; // eax
  int v4; // ebp
  int v5; // ebp
  unsigned int v6; // ebp
  unsigned __int64 v7; // rtt
  unsigned __int64 v8; // rax
  unsigned int v9; // edi
  unsigned __int64 v10; // rax
  unsigned int v11; // ecx
  unsigned int v12; // [esp+4h] [ebp-1Ch]
  __int64 v13; // [esp+8h] [ebp-18h]
  unsigned int v14; // [esp+Ch] [ebp-14h]

  LODWORD(v13) = a1;
  if ( HIDWORD(a2) )
  {
    if ( HIDWORD(a2) > HIDWORD(a1) )
    {
      result = a1;
    }
    else
    {
      _BitScanReverse((unsigned int *)&v4, HIDWORD(a2));
      v5 = v4 ^ 0x1F;
      if ( v5 )
      {
        v12 = (HIDWORD(a2) << v5) | ((unsigned int)a2 >> (32 - v5));
        HIDWORD(v8) = HIDWORD(a1) >> (32 - v5);
        LODWORD(v8) = (HIDWORD(a1) << v5) | ((unsigned int)a1 >> (32 - v5));
        v14 = (_DWORD)a1 << v5;
        v9 = v8 % v12;
        v10 = (unsigned int)((_DWORD)a2 << v5) * (unsigned __int64)(unsigned int)(v8 / v12);
        v11 = v10;
        if ( v9 < HIDWORD(v10) || v14 < (unsigned int)v10 && v9 == HIDWORD(v10) )
        {
          HIDWORD(v10) = (v10 - __PAIR__(v12, (_DWORD)a2 << v5)) >> 32;
          v11 = v10 - ((_DWORD)a2 << v5);
        }
        result = ((__PAIR__(v9, v14) - __PAIR__(HIDWORD(v10), v11)) >> 32 << (32 - (unsigned __int8)v5)) | ((v14 - v11) >> v5);
      }
      else
      {
        if ( (unsigned int)a2 <= (unsigned int)a1 || HIDWORD(a2) < HIDWORD(a1) )
          LODWORD(v13) = a1 - a2;
        result = v13;
      }
    }
  }
  else
  {
    if ( (unsigned int)a2 <= HIDWORD(a1) )
    {
      v6 = a2;
      if ( !(_DWORD)a2 )
        v6 = 1 / 0u;
      LODWORD(v7) = a1;
      HIDWORD(v7) = HIDWORD(a1) % v6;
      v2 = v7 % v6;
    }
    else
    {
      v2 = a1 % (unsigned int)a2;
    }
    result = v2;
  }
  return result;
}

//----- (0805D054) --------------------------------------------------------
int __cdecl sub_805D054(int a1)
{
  return __cxa_atexit(a1, 0, dword_8065210);
}
// 8049AC0: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 8065210: using guessed type int dword_8065210;

//----- (0805D083) --------------------------------------------------------
int __cdecl sub_805D083(int a1, int a2)
{
  return __xstat64(3, a1, a2);
}
// 8049EB0: using guessed type int __cdecl __xstat64(_DWORD, _DWORD, _DWORD);

//----- (0805D0B2) --------------------------------------------------------
int __cdecl sub_805D0B2(int a1, int a2)
{
  return __fxstat64(3, a1, a2);
}
// 8049A30: using guessed type int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD);

//----- (0805D0E0) --------------------------------------------------------
int (**sub_805D0E0())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_8064EFC;
  v1 = &off_8064F00 - off_8064EFC;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_8064EFC[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 8064EFC: using guessed type int (*off_8064EFC[2])();
// 8064F00: using guessed type int (*off_8064F00)();

//----- (0805D144) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 1 decompilation failure(s) on 273 function(s)"
