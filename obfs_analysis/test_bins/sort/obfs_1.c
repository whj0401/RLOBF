/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8049750();
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// int raise(int sig);
// int dup2(int fd, int fd2);
// int strcmp(const char *s1, const char *s2);
// int putc_unlocked(int c, FILE *stream);
// ssize_t read(int fd, void *buf, size_t nbytes);
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void _exit(int status);
// int __cdecl wcwidth(_DWORD); weak
// void *memmove(void *dest, const void *src, size_t n);
// void free(void *ptr);
// uintmax_t strtoumax(const char *nptr, char **endptr, int base);
// void *memcpy(void *dest, const void *src, size_t n);
// int mbsinit(const mbstate_t *ps);
// int ferror(FILE *stream);
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// int fclose(FILE *stream);
// int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
// int getc_unlocked(FILE *stream);
// int __stdcall fseeko64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// __sighandler_t signal(int sig, __sighandler_t handler);
// int __cdecl __sched_cpucount(_DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// double __cdecl strtold(_DWORD, _DWORD); weak
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// int fputc_unlocked(int c, FILE *stream);
// int __cdecl getrlimit64(_DWORD, _DWORD); weak
// int __stdcall stpcpy(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int execlp(const char *file, const char *arg, ...);
// int sysconf(int name);
// __uid_t getuid(void);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// int unlink(const char *name);
// int sigismember(const sigset_t *set, int signo);
// int iswcntrl(wint_t wc);
// char *textdomain(const char *domainname);
// int __cdecl fopen64(_DWORD, _DWORD); weak
// int ferror_unlocked(FILE *stream);
// int __cdecl mkostemp64(_DWORD, _DWORD); weak
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD); weak
// size_t __ctype_get_mb_cur_max(void);
// __pid_t waitpid(__pid_t pid, int *stat_loc, int options);
// int pthread_sigmask(int how, const __sigset_t *newmask, __sigset_t *oldmask);
// size_t __fpending(FILE *fp);
// int __stdcall lseek64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// __pid_t getpid(void);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// int pthread_cond_signal(pthread_cond_t *cond);
// void error(int status, int errnum, const char *format, ...);
// size_t fread_unlocked(void *ptr, size_t size, size_t n, FILE *stream);
// int strcoll(const char *s1, const char *s2);
// char *getenv(const char *name);
// void *malloc(size_t size);
// int sysinfo(struct sysinfo *info);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// char *strchr(const char *s, int c);
// size_t strlen(const char *s);
// int fprintf(FILE *stream, const char *format, ...);
// ssize_t write(int fd, const void *buf, size_t n);
// int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *cond_attr);
// int __cdecl open64(_DWORD, _DWORD); weak
// int fcntl(int fd, int cmd, ...);
// int sigaddset(sigset_t *set, int signo);
// size_t strxfrm(char *dest, const char *src, size_t n);
// __gid_t getgid(void);
// void *memset(void *s, int c, size_t n);
// int *__errno_location(void);
// int fileno(FILE *stream);
// int fgetc(FILE *stream);
// int pipe(int pipedes[2]);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// int __cdecl ftruncate64(_DWORD, _DWORD, _DWORD); weak
// __pid_t fork(void);
// int sigemptyset(sigset_t *set);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// int toupper(int c);
// void clearerr_unlocked(FILE *stream);
// char *strrchr(const char *s, int c);
// int pthread_join(pthread_t th, void **thread_return);
// struct lconv *localeconv(void);
// __pid_t getppid(void);
// int __cdecl explicit_bzero(_DWORD, _DWORD); weak
// int __cdecl pipe2(_DWORD); weak
// int euidaccess(void); weak
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int nanosleep(const struct timespec *requested_time, struct timespec *remaining);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// char *bindtextdomain(const char *domainname, const char *dirname);
// int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl sched_getaffinity(_DWORD, _DWORD, _DWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// int feof_unlocked(FILE *stream);
// void abort(void);
// int __cdecl __xstat64(_DWORD, _DWORD, _DWORD); weak
// int strtol(const char *nptr, char **endptr, int base);
// char *ngettext(const char *msgid1, const char *msgid2, unsigned int n);
// int close(int fd);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// void *calloc(size_t nmemb, size_t size);
// int putchar_unlocked(int c);
// int _gmon_start__(void); weak
void sub_8049F73();
void sub_8049F90();
int sub_8049FA0();
int sub_804A010();
int sub_804A030();
void sub_804A08F();
void sub_804A0AA();
signed int sub_804A0BA();
void sub_804A19C();
void sub_804A1B7();
int sub_804A1C7();
void sub_804A2A9();
void sub_804A2C4();
int sub_804A2D4();
void sub_804A3C8();
void sub_804A3E3();
int sub_804A3F3();
void sub_804A4D5();
void sub_804A4F0();
int sub_804A500();
// int __usercall sub_804A5B2@<eax>(void (__cdecl *a1)(int *)@<eax>);
void sub_804A5FE();
void sub_804A619();
int sub_804A629();
void sub_804A720();
void sub_804A73B();
int sub_804A74B();
// int __usercall sub_804A7C2@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
void sub_804A86B();
void sub_804A886();
int sub_804A896();
// int __usercall sub_804A948@<eax>(void (__cdecl *a1)(int *)@<eax>);
void sub_804A9A6();
void sub_804A9C1();
int sub_804A9D1();
int nullsub_4(void); // weak
// int __usercall sub_804AA48@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
// int __usercall sub_804AAE5@<eax>(void (__cdecl *a1)(int *)@<eax>);
void sub_804AB43();
void sub_804AB5E();
int sub_804AB6E();
void sub_804AC56();
void sub_804AC71();
int sub_804AC81();
void sub_804AD92();
void sub_804ADAD();
int sub_804ADBD();
void sub_804AEA5();
void sub_804AEC0();
int sub_804AED0();
// int __usercall sub_804AF39@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
int __cdecl sub_804AF9F(int a1);
int __cdecl sub_804AFB2(unsigned __int8 a1);
signed int __cdecl sub_804AFC4(unsigned __int8 a1);
int __cdecl sub_804B01D(__int64 a1);
int sub_804B078();
int sub_804B0A3();
// int __usercall sub_804B0CE@<eax>(int a1@<ebx>, char *s1);
void __cdecl __noreturn sub_804B28D(int a1, const char *a2);
void __cdecl __noreturn sub_804B363(int a1, char *a2);
// void __usercall __noreturn sub_804B3C5(int a1@<edx>, int a2@<ecx>, int status);
int __cdecl sub_804B69A(int a1);
int __cdecl sub_804B6CF(unsigned __int8 *a1);
int __cdecl sub_804B6FF(int a1, unsigned int a2);
bool __cdecl sub_804B72E(int a1, int a2);
// int __usercall sub_804B763@<eax>(char *a1@<ebx>, __pid_t pid);
// void __usercall __noreturn sub_804B888(int a1@<edx>, int a2@<ecx>, int a3);
int sub_804B913(); // weak
// signed int __usercall sub_804B915@<eax>(int a1@<ebx>, int a2);
// int __usercall sub_804B980@<eax>(char *a1@<ebx>, __pid_t pid);
// int __usercall sub_804B9A2@<eax>(char *a1@<ebx>);
// int __usercall sub_804B9C5@<eax>(char *a1@<ebx>);
// int __usercall sub_804B9DE@<eax>(char *a1@<ebx>);
int sub_804B9FD();
// int __usercall sub_804BA35@<eax>(int a1@<ebx>);
// void *__usercall sub_804BA6F@<eax>(int a1@<ebx>, _DWORD *a2, char a3);
FILE *__cdecl sub_804BC8C(char *s1, char *modes);
FILE *__cdecl sub_804BDC9(char *s1, char *modes);
void __cdecl sub_804BE0A(FILE *stream, int a2);
int __cdecl sub_804BEB5(int fd, int fd2); // idb
// __pid_t __usercall sub_804BEE2@<eax>(char *a1@<ebx>, int pipedes[2], int a3);
// void *__usercall sub_804C08E@<eax>(char *a1@<ebx>, FILE **a2, char a3);
// void *__usercall sub_804C200@<eax>(char *a1@<ebx>, FILE **a2);
// int __usercall sub_804C21B@<eax>(char *a1@<ebx>, int a2);
int __cdecl sub_804C3F1(int a1);
// void __usercall sub_804C449(char *a1@<ebx>, char *name);
int compar(const void *, const void *); // idb
void sub_804C5BB();
void __fastcall __noreturn sub_804C7F2(int ecx0, int edx0, int a1, char a2, char *a3);
// int __usercall sub_804CA76@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, char *nptr);
// int __usercall sub_804CD59@<eax>(int a1@<ebx>, int a2, int a3, char *nptr);
int sub_804CE0E();
int __cdecl sub_804D057(int a1, unsigned int a2, int a3, unsigned int a4, int a5);
int __cdecl sub_804D2A2(int, int, size_t size); // idb
int __cdecl sub_804D34D(_DWORD *a1);
int __cdecl sub_804D378(int a1, int *a2);
char *__cdecl sub_804D4E6(char **a1, int a2);
int __cdecl sub_804D68A(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_804D6B3(void *src, size_t n, FILE *stream); // idb
int __cdecl sub_804DB8C(char **a1);
_DWORD __cdecl sub_804DC7A(_DWORD); // weak
// int __usercall sub_804DD07@<eax>(int a1@<ebx>, int a2, unsigned __int8 *a3);
int __cdecl sub_804DE14(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_804DEA0(int a1, int a2);
signed int __cdecl sub_804DF24(int a1, int a2);
int __cdecl sub_804E054(unsigned __int8 *a1, unsigned __int8 **a2);
void __cdecl __noreturn sub_804E187(char *a1);
int __cdecl sub_804E1FE(size_t, size_t n); // idb
size_t __cdecl sub_804E27C(char *dest, char *src, size_t n);
void __cdecl __noreturn sub_804E354(int, size_t, int, size_t); // idb
int sub_804E997(); // weak
int __cdecl sub_804E9A2(char *a1, unsigned int a2);
int __cdecl sub_804EA17(int a1, int a2);
int __cdecl sub_804EA8D(_BYTE *a1);
int __cdecl sub_804EAEC(int a1, int a2);
int __cdecl sub_804ED45(int a1);
int __cdecl sub_804EDB1(int a1);
// _BYTE *__usercall sub_804EE66@<eax>(int a1@<edx>, int a2@<ecx>, int a3, _BYTE *a4);
_DWORD __cdecl sub_804EFA5(_DWORD, _DWORD); // weak
// int __usercall sub_804F8AC@<eax>(char *a1@<ebx>, int a2, int a3);
// int __usercall sub_8050627@<eax>(int a1@<edx>, int a2@<ecx>, char *a3@<ebx>, int a4, int a5);
int __cdecl sub_805078F(int, FILE *stream, int); // idb
_DWORD __cdecl sub_80508B8(_DWORD, _DWORD); // weak
unsigned int __cdecl sub_8050CA7(int a1, unsigned int a2, void **a3);
int __cdecl sub_8050DB0(int, int, int, FILE *stream, int, void *); // idb
int __cdecl sub_8051849(_DWORD, _DWORD); // weak
int __cdecl sub_8051874(int, int, FILE *stream, int, void *); // idb
_DWORD __cdecl sub_805190F(_DWORD, _DWORD, _DWORD); // weak
// int __usercall sub_8051A7B@<eax>(int a1@<ecx>, char *a2@<ebx>, int a3, unsigned int a4, int a5, unsigned __int8 a6);
pthread_mutex_t *__cdecl sub_8051CEB(unsigned int a1, int a2, int a3);
int __cdecl sub_8051E25(_DWORD *a1, pthread_mutex_t *a2, int a3, unsigned int a4, int a5, char a6);
_BOOL4 __cdecl sub_805200D(_DWORD *a1, _DWORD *a2);
int __cdecl sub_805208C(pthread_mutex_t *a1);
int __cdecl sub_80520A2(pthread_mutex_t *a1);
int __cdecl sub_80520E9(int a1, int a2);
int __cdecl sub_8052137(int a1, int a2);
pthread_mutex_t *__cdecl sub_8052184(int a1);
// int __usercall sub_80521ED@<eax>(int a1@<edx>, int a2@<ecx>, char *a3@<ebx>, int a4, FILE *stream, int a6);
int __cdecl sub_8052260(int, int, FILE *stream, int); // idb
int __cdecl sub_8052717(int a1, int a2);
int __cdecl sub_8052835(int a1, _DWORD *a2);
int __cdecl sub_80528A2(int, int, FILE *stream, int); // idb
void *start_routine(void *); // idb
// int __usercall sub_80529B3@<eax>(int a1@<ecx>, char *a2@<ebx>, int a3, int a4, int a5, int a6, int a7, FILE *stream, int a9);
// int __usercall sub_8052C07@<eax>(char *a1@<ebx>, int a2, int a3, int a4, char *s1);
unsigned int __cdecl sub_8052EA6(int a1, unsigned int a2);
void __cdecl sub_8052F72(char *a1);
int __cdecl sub_8052FD8(int, int, int, char *s1); // idb
// unsigned int __usercall sub_805348B@<eax>(char *a1@<ebx>, char **a2, unsigned int a3, char *a4, unsigned int a5);
_DWORD *__cdecl sub_80538D5(void *src);
unsigned int __cdecl sub_8053922(int a1, char *msgid);
unsigned int __cdecl sub_8053970(int a1);
unsigned int __fastcall sub_80539A1(int a1, int a2);
// int __usercall sub_8053ADA@<eax>(int a1@<edx>, int a2@<ecx>, char *nptr, int a4, char *msgid);
int __cdecl sub_8053BE9(int sig); // idb
void *__cdecl sub_8053D38(void *s);
int __cdecl main(int, char **, char **); // idb
void __fastcall __noreturn sub_805560A(int a1, int a2);
int __cdecl sub_805561E(char *s, int, int, size_t); // idb
void __cdecl sub_8055739(int a1, int a2, int a3);
int __cdecl sub_80557BC(int, int, size_t n); // idb
int __cdecl sub_80558E3(int, char *s, int, int, size_t n, int); // idb
// int __usercall sub_8055A5B@<eax>(int a1@<ebx>);
_DWORD *__cdecl sub_8055B64(_DWORD *a1);
_DWORD *__cdecl sub_8055BC0(_DWORD *a1, int a2);
_DWORD *__cdecl sub_8055BCD(int *a1, _DWORD *a2);
_DWORD *__cdecl sub_8055C4A(int *a1, _DWORD *a2);
int __cdecl sub_8055F4F(void *src, size_t, int); // idb
int *__cdecl sub_80561CB(int *a1, unsigned int a2, int *a3);
int __cdecl sub_8056EC5(int a1, int a2, int a3, int a4, int a5, int a6);
void __cdecl sub_8056F26(FILE *stream, int a2);
// _BYTE *__usercall sub_8056F6E@<eax>(int a1@<edx>, int a2@<ecx>, int *a3);
int __cdecl sub_8057059(unsigned __int8 a1);
int __cdecl sub_80570AB(int a1, unsigned int a2, int a3, unsigned int a4);
int __cdecl sub_80572B3(char *s1, char *s2); // idb
int __cdecl sub_8057563(int category); // idb
int __cdecl sub_80575C1(int a1);
int __cdecl sub_80575CC(int a1);
int __cdecl sub_80575D7(int a1);
unsigned int __cdecl sub_80575E2(int a1);
int __cdecl sub_80577D8(int a1, int a2);
bool __cdecl sub_8057B53(unsigned int a1);
// unsigned int __usercall sub_8057BAC@<eax>(int a1@<edx>, int a2@<ecx>, unsigned int a3);
unsigned int __cdecl sub_8057C5B(int a1, unsigned int a2);
bool __cdecl sub_8057C87(int a1, int a2);
signed int __cdecl sub_8057C95(int a1);
// unsigned int __usercall sub_8057D64@<eax>(signed __int64 a1@<edx:eax>, int a2@<ecx>, unsigned int a3, int a4);
// int __usercall sub_8057E14@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, int a6);
void *__cdecl sub_80581F1(int a1);
__int64 __cdecl sub_805822C(__int64 a1);
int __cdecl sub_805825F(int a1, int a2, _DWORD *a3, char a4);
signed int __cdecl sub_805841D(int a1, int a2, char a3);
// int __usercall sub_80585C8@<eax>(signed __int64 a1@<edx:eax>, int a2@<ecx>, int a3, unsigned int a4);
signed int __cdecl sub_8058843(unsigned int *a1, int a2, _DWORD *a3);
int __cdecl sub_8058B77(unsigned int *a1, int a2);
// int __usercall sub_8058BB7@<eax>(int a1@<ebx>, int a2, int a3);
_DWORD *__cdecl sub_8058E28(int (*a1)(), unsigned int a2);
int sub_8058EAD();
void __cdecl sub_8058EB8(void *ptr);
int __cdecl sub_8058ED8(int a1, int a2);
// int __usercall sub_8058F72@<eax>(int a1@<edx>, int a2@<ecx>, int *a3);
unsigned int __cdecl sub_8059014(int a1, unsigned int a2, unsigned int a3, int (__cdecl *a4)(int, int));
int __cdecl sub_8059127(int a1, unsigned int a2, int (__cdecl *a3)(int, int));
int __cdecl sub_80591E7(int a1, int a2);
int __cdecl sub_80592E1(unsigned int a1, int a2);
int __cdecl sub_805934F(signed __int64 a1, int a2);
int __cdecl sub_8059422(char *a1, int a2, char a3);
int sub_80596CC();
signed int __cdecl sub_8059741(int a1);
// int __usercall sub_80597E0@<eax>(int a1@<edx>, int a2@<ecx>, char *nptr);
unsigned int __cdecl sub_80598D8(int a1);
double sub_8059997(void); // weak
long double sub_8059AAD();
// int __usercall sub_8059B87@<eax>(int a1@<ebx>, int pipedes[2], int a3);
int sub_8059E3E();
char *__cdecl sub_8059EC5(char *s);
unsigned int __cdecl sub_805A011(int a1, unsigned __int8 a2, char a3);
_DWORD __cdecl sub_805A0E0(_DWORD, _DWORD, _DWORD); // weak
// _DWORD *__userpurge sub_805A14A@<eax>(_DWORD *a1, int a2);
char *__cdecl sub_805A1ED(char *msgid, int a2);
void __cdecl sub_805A2A0(int a1, int a2, int a3, int a4, unsigned int a5, int a6, int a7, int a8, int a9);
// void __usercall sub_805A75F(int a1@<ebp>);
// void __usercall sub_805A8E0(int a1@<ebp>, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41);
void *__cdecl sub_805B1E4(int a1, int a2, _DWORD *a3, int a4);
void *__cdecl sub_805B402(signed int a1, int a2, int a3, unsigned int *a4);
void *__cdecl sub_805B681(signed int a1, int a2);
void *__cdecl sub_805B6AB(signed int a1, int a2, int a3);
void *__cdecl sub_805B721(signed int a1, int a2, int a3);
void *__cdecl sub_805B75F(signed int a1, int a2, int a3, int a4);
void *__cdecl sub_805B79C(int a1, int a2);
void *__cdecl sub_805B7F7(int a1, int a2, unsigned __int8 a3);
void *__cdecl sub_805B8B1(int a1, unsigned __int8 a2);
void *__cdecl sub_805B8EA(int a1);
void *__cdecl sub_805B927(signed int a1, int a2, int a3);
void *__cdecl sub_805B9D8(signed int a1, int a2, int a3, int a4);
void *__cdecl sub_805BA18(signed int a1, int a2, int a3, int a4, int a5);
void *__cdecl sub_805BB42(signed int a1, int a2, int a3);
void *__cdecl sub_805BB9D(signed int a1, int a2);
void *__cdecl sub_805BBBF(int a1);
void __cdecl __noreturn sub_805BBDA(int a1);
_DWORD __cdecl sub_805BC43(_DWORD); // weak
unsigned int __cdecl sub_805BC9D(int a1, int a2, size_t nbytes);
int __cdecl sub_805BEBA(int, size_t n); // idb
size_t __cdecl sub_805C02B(int a1, void *ptr, size_t n);
int __cdecl sub_805C0B4(int, void *dest, size_t n); // idb
size_t __cdecl sub_805C1E3(int a1, void *ptr, size_t n);
int __cdecl sub_805C22B(void *ptr); // idb
int __cdecl sub_805C272(int a1);
int __cdecl sub_805C289(int a1, __int16 a2);
_DWORD __cdecl sub_805C2CA(_DWORD, _DWORD); // weak
_DWORD *__cdecl sub_805C89A(_DWORD *a1);
signed int __cdecl sub_805CD81(_DWORD *a1);
_DWORD *__cdecl sub_805CF6A(_DWORD *a1);
bool __cdecl sub_805D14F(FILE *stream, int a2);
// int __usercall sub_805D4BD@<eax>(int a1@<ebx>, int a2, int a3);
int __cdecl sub_805D4E6(_BYTE *a1, _BYTE *a2, unsigned __int8 a3);
_DWORD __cdecl sub_805D668(_DWORD, _DWORD, char); // weak
int __cdecl sub_805DB98(int a1, int a2, char a3);
// int __usercall sub_805DBD0@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, int fd);
int __cdecl sub_805DC1A(FILE *stream, int, int, int, int, int); // idb
int __cdecl sub_805E25F(FILE *stream, int, int, int, int); // idb
int sub_805E2FE(FILE *stream, int a2, int a3, int a4, ...);
void *__cdecl sub_805E3AE(unsigned int a1, unsigned int a2);
int __cdecl sub_805E413(int a1, unsigned int *a2, unsigned int a3);
void *__cdecl sub_805E4D6(size_t size);
void *__cdecl sub_805E4E9(size_t size);
_DWORD __cdecl sub_805E513(_DWORD, _DWORD); // weak
int __cdecl sub_805E54D(int, void *ptr, size_t size); // idb
void *__cdecl sub_805E606(size_t nmemb, size_t size);
void *__cdecl sub_805E644(void *src, size_t n);
void __noreturn sub_805E692();
void __cdecl sub_805E6CB(int errnum, int a2, int a3, int a4, int a5);
int __cdecl sub_805E81C(void *s1, size_t n, void *s2, int); // idb
signed int __cdecl sub_805E8A7(double a1);
signed int __cdecl sub_805E92A(unsigned int *a1, signed int a2);
int __cdecl sub_805E980(unsigned int *a1, signed int a2, int a3);
// int __usercall sub_805E9B6@<eax>(int a1@<ebx>, char *nptr, int a3, int base, int a5, char *s);
// void __usercall sub_805EE51(int edx0@<edx>, int ecx0@<ecx>, int a1, int a2, int a3, int a4, int a5, int status);
void __fastcall __noreturn sub_805EF2C(int ecx0, int edx0, int a1, int a2, char a3, int a4, int a5);
signed int __cdecl sub_805EF7F(unsigned int *a1, signed int a2);
int __cdecl sub_805F02C(unsigned int *a1, signed int a2, int a3);
// int __usercall sub_805F062@<eax>(int a1@<edx>, int a2@<ecx>, char *nptr, int a4, int base, int a6, char *s);
int __cdecl sub_805F4C1(FILE *stream); // idb
// int __usercall sub_805F5D6@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, int fd, int cmd, char a6);
int __cdecl sub_805F7A2(FILE *a1);
int __cdecl sub_805F7DB(FILE *fp); // idb
int __cdecl sub_805F81B(FILE *stream, int a2, int a3, int a4);
int __cdecl sub_805F916(wchar_t *pwc, char *s, size_t n, mbstate_t *p); // idb
int __cdecl sub_805F9E3(int a1, int a2);
int __cdecl sub_805FA21(int a1, int a2);
signed int __cdecl sub_805FA5F(int a1, signed int a2, signed int a3);
signed int __cdecl sub_805FB5E(int a1, signed int a2, signed int a3, int a4, int a5);
_DWORD __cdecl sub_805FC07(_DWORD, _DWORD); // weak
int __cdecl sub_805FE3B(int a1, unsigned int a2);
int __cdecl sub_80600BA(int a1, char a2);
int __cdecl sub_80601E5(signed int a1);
// int __usercall sub_806022B@<eax>(int a1@<edx>, int a2@<ecx>, signed int a3);
signed int __cdecl sub_80602C8(int a1);
// signed int __usercall sub_80603A1@<eax>(int a1@<edx>, int a2@<ecx>, signed int a3);
int __cdecl sub_8060421(int a1);
int __cdecl sub_8060457(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_80604BD(FILE *fp); // idb
// _DWORD *__userpurge sub_8060568@<eax>(_DWORD *a1, double a2);
// int __usercall sub_806070C@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, int fd, int a5);
// int __usercall sub_806075D@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, int fd, int a5);
// FILE *__usercall sub_80607AA@<eax>(int a1@<ebx>, int a2, char *modes);
void *sub_8060882();
const char *sub_8060E1B();
int __cdecl sub_8060ECE(char *s1, int a2, char *s2);
int __cdecl sub_8060FFE(void *s1, size_t n, void *s2, int); // idb
int __cdecl sub_80610DC(void *s1, size_t n, void *s2, int); // idb
// _DWORD *__userpurge sub_806113C@<eax>(_DWORD *a1, int a2, int a3);
// int __usercall sub_8061206@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, int fd);
signed __int64 __cdecl sub_806122B(unsigned __int64 a1, unsigned int a2, unsigned int a3);
_DWORD __cdecl sub_806137E(__int64, __int64); // weak
int __cdecl sub_80615AC(int a1);
int __cdecl sub_80615DB(int a1, int a2);
int __cdecl sub_806160A(int a1, int a2);
int sub_8061693(void); // weak
int __cdecl sub_8061709();
int __fastcall sub_8061819(_DWORD, _DWORD); // weak
int sub_80618A3(void); // weak
double __fastcall sub_806190F(_DWORD, _DWORD); // weak
int __stdcall sub_806197F(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int sub_80619F1(void); // weak
int __stdcall sub_8061ADD(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __fastcall sub_8061B4D(_DWORD, _DWORD, _DWORD, _DWORD);
int __stdcall sub_8061BBB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (**sub_8061BD0())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_804A8C2; // weak
_UNKNOWN loc_804B00B; // weak
_UNKNOWN loc_804B012; // weak
_UNKNOWN locret_804B076; // weak
_UNKNOWN loc_804B18B; // weak
_UNKNOWN loc_804B1A3; // weak
_UNKNOWN loc_804B3EC; // weak
_UNKNOWN loc_804B419; // weak
_UNKNOWN loc_804B804; // weak
_UNKNOWN loc_804B87E; // weak
_UNKNOWN loc_804B90E; // weak
_UNKNOWN loc_804BE3D; // weak
_UNKNOWN loc_804BE5D; // weak
_UNKNOWN loc_804BFE2; // weak
_UNKNOWN loc_804C003; // weak
_UNKNOWN loc_804C014; // weak
_UNKNOWN loc_804C3EA; // weak
_UNKNOWN loc_804C7A7; // weak
_UNKNOWN loc_804C8D5; // weak
_UNKNOWN loc_804C8E1; // weak
_UNKNOWN loc_804CC6E; // weak
_UNKNOWN loc_804CCEF; // weak
_UNKNOWN loc_804CD21; // weak
_UNKNOWN loc_804CF59; // weak
_UNKNOWN loc_804D104; // weak
_UNKNOWN loc_804D11E; // weak
_UNKNOWN loc_804D160; // weak
_UNKNOWN loc_804D189; // weak
_UNKNOWN loc_804D2A8; // weak
_UNKNOWN loc_804D4A7; // weak
_UNKNOWN loc_804D546; // weak
_UNKNOWN loc_804D54A; // weak
_UNKNOWN loc_804D5A5; // weak
_UNKNOWN loc_804DBF9; // weak
_UNKNOWN loc_804DBFD; // weak
_UNKNOWN loc_804DD25; // weak
_UNKNOWN loc_804DD29; // weak
_UNKNOWN loc_804DD71; // weak
_UNKNOWN loc_804DD73; // weak
_UNKNOWN loc_804DDBF; // weak
_UNKNOWN loc_804DE5A; // weak
_UNKNOWN loc_804DF86; // weak
_UNKNOWN loc_804E1E3; // weak
_UNKNOWN loc_804E992; // weak
_UNKNOWN loc_804EA0A; // weak
_UNKNOWN locret_804EA8B; // weak
_UNKNOWN loc_804EAC4; // weak
_UNKNOWN loc_804EADA; // weak
_UNKNOWN loc_804ECB8; // weak
_UNKNOWN loc_804ECE3; // weak
_UNKNOWN loc_804ECE9; // weak
_UNKNOWN loc_804EDA1; // weak
_UNKNOWN locret_804EDAF; // weak
_UNKNOWN loc_804EE54; // weak
_UNKNOWN loc_804EE5B; // weak
_UNKNOWN loc_804EF63; // weak
_UNKNOWN loc_804EF6F; // weak
_UNKNOWN loc_804FA23; // weak
_UNKNOWN loc_804FA45; // weak
_UNKNOWN loc_804FC39; // weak
_UNKNOWN loc_804FC7A; // weak
_UNKNOWN loc_804FC8B; // weak
_UNKNOWN loc_804FCBC; // weak
_UNKNOWN loc_804FFB0; // weak
_UNKNOWN loc_8050004; // weak
_UNKNOWN loc_8050151; // weak
_UNKNOWN loc_8050571; // weak
_UNKNOWN loc_80505D1; // weak
_UNKNOWN loc_80505D6; // weak
_UNKNOWN loc_80505FD; // weak
_UNKNOWN loc_8050607; // weak
_UNKNOWN loc_80506C1; // weak
_UNKNOWN loc_80506CD; // weak
_UNKNOWN loc_8050DA7; // weak
_UNKNOWN locret_8051CE9; // weak
_UNKNOWN loc_8052799; // weak
_UNKNOWN loc_80527D2; // weak
_UNKNOWN loc_80527D9; // weak
_UNKNOWN loc_80527E4; // weak
_UNKNOWN loc_8052C8F; // weak
_UNKNOWN loc_8052CE2; // weak
_UNKNOWN loc_8052DAE; // weak
_UNKNOWN loc_8052DD0; // weak
_UNKNOWN loc_8052E86; // weak
_UNKNOWN loc_8052EF7; // weak
_UNKNOWN loc_8052F0E; // weak
_UNKNOWN loc_8052F5C; // weak
_UNKNOWN loc_80535BD; // weak
_UNKNOWN loc_80537AD; // weak
_UNKNOWN loc_8053A66; // weak
_UNKNOWN loc_8053AB4; // weak
_UNKNOWN loc_8053ABD; // weak
_UNKNOWN loc_8053BDF; // weak
_UNKNOWN loc_8055ABA; // weak
_UNKNOWN loc_8055B40; // weak
_UNKNOWN loc_8056FF6; // weak
_UNKNOWN loc_805700A; // weak
_UNKNOWN loc_80570CD; // weak
_UNKNOWN loc_80571A5; // weak
_UNKNOWN loc_8057326; // weak
_UNKNOWN loc_8057330; // weak
_UNKNOWN loc_8057BDA; // weak
_UNKNOWN loc_8057BDE; // weak
_UNKNOWN loc_8057C0F; // weak
_UNKNOWN locret_8057D62; // weak
_UNKNOWN loc_8057E46; // weak
_UNKNOWN loc_8057E4D; // weak
_UNKNOWN loc_8057E8C; // weak
_UNKNOWN loc_8057E93; // weak
_UNKNOWN loc_8057ED7; // weak
_UNKNOWN loc_8057EDC; // weak
_UNKNOWN loc_8058304; // weak
_UNKNOWN loc_8058341; // weak
_UNKNOWN loc_80583C2; // weak
_UNKNOWN loc_80583F9; // weak
_UNKNOWN locret_805841B; // weak
_UNKNOWN loc_8058511; // weak
_UNKNOWN loc_8058516; // weak
_UNKNOWN loc_8058615; // weak
_UNKNOWN loc_8058620; // weak
_UNKNOWN loc_805889D; // weak
_UNKNOWN loc_80588A5; // weak
_UNKNOWN loc_805899A; // weak
_UNKNOWN loc_80589C9; // weak
_UNKNOWN loc_8058AC7; // weak
_UNKNOWN loc_8058B3A; // weak
_UNKNOWN locret_8058B75; // weak
_UNKNOWN loc_8058C43; // weak
_UNKNOWN loc_8058D36; // weak
_UNKNOWN loc_8058D81; // weak
_UNKNOWN loc_8058E23; // weak
_UNKNOWN loc_805900D; // weak
_UNKNOWN loc_8059648; // weak
_UNKNOWN loc_805964A; // weak
_UNKNOWN loc_80596A3; // weak
_UNKNOWN locret_805973F; // weak
_UNKNOWN loc_80597BA; // weak
_UNKNOWN loc_80597CE; // weak
_UNKNOWN loc_805980F; // weak
_UNKNOWN loc_805984B; // weak
_UNKNOWN locret_80598D6; // weak
_UNKNOWN loc_8059914; // weak
_UNKNOWN loc_805997D; // weak
_UNKNOWN locret_8059995; // weak
_UNKNOWN loc_8059D71; // weak
_UNKNOWN loc_8059DD6; // weak
_UNKNOWN loc_8059DF3; // weak
_UNKNOWN locret_8059E3C; // weak
_UNKNOWN loc_8059EBA; // weak
_UNKNOWN loc_8059EC0; // weak
_UNKNOWN loc_805A04A; // weak
_UNKNOWN locret_805A29E; // weak
_UNKNOWN loc_805A7D2; // weak
_UNKNOWN loc_805A8F0; // weak
_UNKNOWN loc_805AD8D; // weak
_UNKNOWN loc_805ADB3; // weak
_UNKNOWN loc_805B210; // weak
_UNKNOWN loc_805B33D; // weak
_UNKNOWN loc_805B348; // weak
_UNKNOWN loc_805B449; // weak
_UNKNOWN loc_805B509; // weak
_UNKNOWN loc_805BEEF; // weak
_UNKNOWN loc_805BF08; // weak
_UNKNOWN loc_805D299; // weak
_UNKNOWN loc_805D406; // weak
_UNKNOWN loc_805D413; // weak
_UNKNOWN loc_805D543; // weak
_UNKNOWN locret_805D666; // weak
_UNKNOWN loc_805E26E; // weak
_UNKNOWN loc_805E2BE; // weak
_UNKNOWN loc_805E450; // weak
_UNKNOWN loc_805E48C; // weak
_UNKNOWN loc_805EACC; // weak
_UNKNOWN loc_805EAD5; // weak
_UNKNOWN loc_805EB25; // weak
_UNKNOWN loc_805EB42; // weak
_UNKNOWN loc_805EC18; // weak
_UNKNOWN loc_805EC52; // weak
_UNKNOWN loc_805EC58; // weak
_UNKNOWN loc_805EC5A; // weak
_UNKNOWN loc_805EE40; // weak
_UNKNOWN loc_805EE44; // weak
_UNKNOWN locret_805EE4F; // weak
_UNKNOWN loc_805EEB0; // weak
_UNKNOWN loc_805F094; // weak
_UNKNOWN loc_805F09C; // weak
_UNKNOWN loc_805F109; // weak
_UNKNOWN loc_805F2BE; // weak
_UNKNOWN loc_805F2D7; // weak
_UNKNOWN locret_805F4BF; // weak
_UNKNOWN loc_805F61C; // weak
_UNKNOWN loc_805F68E; // weak
_UNKNOWN loc_805F69A; // weak
_UNKNOWN loc_805F763; // weak
_UNKNOWN loc_8060229; // weak
_UNKNOWN loc_8060265; // weak
_UNKNOWN loc_80603CA; // weak
_UNKNOWN loc_80603CF; // weak
_UNKNOWN loc_806054E; // weak
_UNKNOWN loc_8060559; // weak
_UNKNOWN loc_806061A; // weak
_UNKNOWN loc_806063D; // weak
_UNKNOWN loc_8060705; // weak
_UNKNOWN loc_8060791; // weak
_UNKNOWN loc_8060981; // weak
_UNKNOWN loc_8060988; // weak
_UNKNOWN loc_8060B4F; // weak
_UNKNOWN loc_8060B7A; // weak
_UNKNOWN loc_8060B7F; // weak
_UNKNOWN loc_8060DC5; // weak
_UNKNOWN loc_8060DF0; // weak
_UNKNOWN loc_8060ED9; // weak
_UNKNOWN loc_8060FC4; // weak
_UNKNOWN loc_8060FCF; // weak
_UNKNOWN loc_8060FF9; // weak
char locale = '\0'; // idb
struct option longopts = { "ignore-leading-blanks", 0, NULL, 98 }; // idb
char byte_8063470[256] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x06',
  '\0',
  '\x03',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0',
  '\x04',
  '\0',
  '\0',
  '\0',
  '\0',
  '\b',
  '\a',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_80640F0; // weak
_UNKNOWN unk_8064140; // weak
_UNKNOWN unk_806433E; // weak
_UNKNOWN unk_8064342; // weak
_UNKNOWN unk_806434E; // weak
_UNKNOWN unk_8064352; // weak
_DWORD off_806435C[11] =
{
  134587516,
  134587440,
  134587459,
  134587436,
  134587444,
  134587229,
  134587218,
  134587286,
  134587299,
  134587299,
  134587299
}; // idb
void *off_8064914 = &loc_805DCD3; // weak
_UNKNOWN unk_806503F; // weak
int dword_8065EF8 = 236208579; // weak
_UNKNOWN unk_8066374; // weak
_UNKNOWN unk_8066377; // weak
int dword_8066EE8 = 4263432; // weak
int dword_8066EF4 = 136183808; // weak
_UNKNOWN unk_80673C4; // weak
_UNKNOWN unk_80673C7; // weak
_UNKNOWN unk_80683D8; // weak
_UNKNOWN unk_80683DB; // weak
int (*off_806AECC[2])() = { &sub_804A030, &sub_804A010 }; // weak
int (*off_806AED0)() = &sub_804A010; // weak
int (*dword_806B008)(void) = NULL; // weak
int dword_806B20C = 0; // weak
int dword_806B220 = 0; // weak
int dword_806B234 = 0; // weak
int dword_806B254 = 0; // weak
int dword_806B268 = 0; // weak
int dword_806B27C = 0; // weak
int dword_806B290 = 0; // weak
int dword_806B2A4 = 0; // weak
int dword_806B2C4 = 0; // weak
int dword_806B2D8 = 0; // weak
int dword_806B2F0 = 0; // weak
char byte_806B30C = '\n'; // weak
char *off_806B32C = "APR"; // weak
int dword_806B330[] = { 4 }; // weak
int dword_806B390 = 128; // weak
int dword_806B394 = 16; // weak
int *off_806B398 = &dword_806BEC9; // weak
int status = 1; // idb
int dword_806B3CC = 1; // weak
int dword_806B3D0 = 256; // weak
void *off_806B3D4 = &unk_806BFE9; // weak
int *off_806B3D8 = &dword_806B3D0; // weak
_UNKNOWN unk_806B3EC; // weak
_UNKNOWN unk_806B40C; // weak
_UNKNOWN unk_806B40F; // weak
_UNKNOWN unk_806B414; // weak
_UNKNOWN unk_806B417; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int program_invocation_name; // weak
FILE *stdin; // idb
FILE *stdout; // idb
int (*obstack_alloc_failed_handler)(void); // weak
char byte_806B48C; // weak
_UNKNOWN unk_806B93F; // weak
int dword_806BA09; // weak
int dword_806BA0D; // weak
char byte_806BA11; // weak
char byte_806BA12; // weak
int dword_806BA15; // weak
int dword_806BA19; // weak
int dword_806BA1D; // weak
int dword_806BA21; // weak
char byte_806BA29[256]; // idb
_UNKNOWN unk_806BB29; // weak
_UNKNOWN unk_806BC29; // weak
char byte_806BD29[256]; // idb
size_t size; // idb
int dword_806BE2D; // weak
int dword_806BE31; // weak
int dword_806BE35; // weak
char byte_806BE39; // weak
char byte_806BE3A; // weak
char byte_806BE3B; // weak
char byte_806BE3C; // weak
int dword_806BE3D; // weak
char *s1; // idb
char byte_806BE45; // weak
__sigset_t set; // idb
int dword_806BEC9; // weak
int dword_806BECD; // weak
int dword_806BED1; // weak
_UNKNOWN unk_806BEE9; // weak
int dword_806BF85; // weak
int dword_806BF8D; // weak
char byte_806BF91; // weak
int dword_806BF95; // weak
int dword_806BF99; // weak
int dword_806BFA9[]; // weak
int dword_806BFAD; // weak
int dword_806BFB1; // weak
int dword_806BFB5; // weak
int dword_806BFB9; // weak
int dword_806BFBD; // weak
int dword_806BFC1; // weak
int dword_806BFC5; // weak
int dword_806BFC9; // weak
int dword_806BFCD; // weak
int dword_806BFD1; // weak
int dword_806BFD5; // weak
_UNKNOWN unk_806BFE9; // weak
int dword_806C0E9; // weak
int dword_806C0ED; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (0804972C) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 8049F30: using guessed type int _gmon_start__(void);

//----- (08049750) --------------------------------------------------------
int sub_8049750()
{
  return dword_806B008();
}
// 806B008: using guessed type int (*dword_806B008)(void);

//----- (08049F40) --------------------------------------------------------
#error "8049F43: positive sp value has been found (funcsize=2)"

//----- (08049F73) --------------------------------------------------------
void sub_8049F73()
{
  ;
}

//----- (08049F90) --------------------------------------------------------
void sub_8049F90()
{
  ;
}

//----- (08049FA0) --------------------------------------------------------
int sub_8049FA0()
{
  int result; // eax

  result = 134657059 - (_DWORD)&program_invocation_short_name;
  if ( (unsigned int)(134657059 - (_DWORD)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 8049FA0: could not find valid save-restore pair for ebp
// 806B420: using guessed type int program_invocation_short_name;

//----- (0804A010) --------------------------------------------------------
int sub_804A010()
{
  int result; // eax

  if ( !byte_806B48C )
  {
    result = sub_8049FA0();
    byte_806B48C = 1;
  }
  return result;
}
// 804A010: could not find valid save-restore pair for ebp
// 806B48C: using guessed type char byte_806B48C;

//----- (0804A030) --------------------------------------------------------
int sub_804A030()
{
  return 0;
}
// 804A030: could not find valid save-restore pair for ebp

//----- (0804A08F) --------------------------------------------------------
void sub_804A08F()
{
  ;
}

//----- (0804A0AA) --------------------------------------------------------
void sub_804A0AA()
{
  ;
}

//----- (0804A0BA) --------------------------------------------------------
signed int sub_804A0BA()
{
  return 3;
}
// 804A0BA: could not find valid save-restore pair for ebp

//----- (0804A19C) --------------------------------------------------------
void sub_804A19C()
{
  ;
}

//----- (0804A1B7) --------------------------------------------------------
void sub_804A1B7()
{
  ;
}

//----- (0804A1C7) --------------------------------------------------------
int sub_804A1C7()
{
  int result; // eax

  result = &unk_806B40F - &unk_806B40C;
  if ( (unsigned int)(&unk_806B40F - &unk_806B40C) > 6 )
    result = 0;
  return result;
}
// 804A1C7: could not find valid save-restore pair for ebp

//----- (0804A2A9) --------------------------------------------------------
void sub_804A2A9()
{
  ;
}

//----- (0804A2C4) --------------------------------------------------------
void sub_804A2C4()
{
  ;
}

//----- (0804A2D4) --------------------------------------------------------
int sub_804A2D4()
{
  int result; // eax

  result = &unk_806B40F - &unk_806B40C;
  if ( (unsigned int)(&unk_806B40F - &unk_806B40C) > 6 )
    result = 0;
  return result;
}
// 804A2D4: could not find valid save-restore pair for ebp

//----- (0804A3C8) --------------------------------------------------------
void sub_804A3C8()
{
  ;
}

//----- (0804A3E3) --------------------------------------------------------
void sub_804A3E3()
{
  ;
}

//----- (0804A3F3) --------------------------------------------------------
int sub_804A3F3()
{
  int result; // eax

  result = &unk_80683DB - &unk_80683D8;
  if ( (unsigned int)(&unk_80683DB - &unk_80683D8) > 6 )
    result = 0;
  return result;
}
// 804A3F3: could not find valid save-restore pair for ebp

//----- (0804A4D5) --------------------------------------------------------
void sub_804A4D5()
{
  ;
}

//----- (0804A4F0) --------------------------------------------------------
void sub_804A4F0()
{
  ;
}

//----- (0804A500) --------------------------------------------------------
int sub_804A500()
{
  int result; // eax

  result = &unk_80673C7 - &unk_80673C4;
  if ( (unsigned int)(&unk_80673C7 - &unk_80673C4) > 6 )
    result = 0;
  return result;
}
// 804A500: could not find valid save-restore pair for ebp

//----- (0804A5B2) --------------------------------------------------------
int __usercall sub_804A5B2@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  a1(&dword_8066EE8);
  return 0;
}
// 8066EE8: using guessed type int dword_8066EE8;

//----- (0804A5FE) --------------------------------------------------------
void sub_804A5FE()
{
  ;
}

//----- (0804A619) --------------------------------------------------------
void sub_804A619()
{
  ;
}

//----- (0804A629) --------------------------------------------------------
int sub_804A629()
{
  int result; // eax

  result = &unk_806B40F - &unk_806B40C;
  if ( (unsigned int)(&unk_806B40F - &unk_806B40C) > 6 )
    result = 0;
  return result;
}
// 804A629: could not find valid save-restore pair for ebp

//----- (0804A720) --------------------------------------------------------
void sub_804A720()
{
  ;
}

//----- (0804A73B) --------------------------------------------------------
void sub_804A73B()
{
  ;
}

//----- (0804A74B) --------------------------------------------------------
int sub_804A74B()
{
  int result; // eax

  result = &unk_806B40F - &unk_806B40C;
  if ( (unsigned int)(&unk_806B40F - &unk_806B40C) > 6 )
    result = 0;
  return result;
}
// 804A74B: could not find valid save-restore pair for ebp

//----- (0804A7C2) --------------------------------------------------------
int __usercall sub_804A7C2@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_806B40C, a1);
}

//----- (0804A86B) --------------------------------------------------------
void sub_804A86B()
{
  ;
}

//----- (0804A886) --------------------------------------------------------
void sub_804A886()
{
  ;
}

//----- (0804A896) --------------------------------------------------------
int sub_804A896()
{
  int result; // eax

  result = &unk_806B40F - &unk_806B40C;
  if ( (unsigned int)(&unk_806B40F - &unk_806B40C) > 6 )
    result = 0;
  return result;
}
// 804A896: could not find valid save-restore pair for ebp

//----- (0804A948) --------------------------------------------------------
int __usercall sub_804A948@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  a1(&dword_8066EF4);
  dword_806B254 = (int)&loc_804A8C2;
  sub_80619F1();
  return 0;
}
// 80619F1: using guessed type int sub_80619F1(void);
// 8066EF4: using guessed type int dword_8066EF4;
// 806B254: using guessed type int dword_806B254;

//----- (0804A9A6) --------------------------------------------------------
void sub_804A9A6()
{
  ;
}

//----- (0804A9C1) --------------------------------------------------------
void sub_804A9C1()
{
  ;
}

//----- (0804A9D1) --------------------------------------------------------
int sub_804A9D1()
{
  int result; // eax

  result = &unk_8066377 - &unk_8066374;
  if ( (unsigned int)(&unk_8066377 - &unk_8066374) > 6 )
    result = 0;
  return result;
}
// 804A9D1: could not find valid save-restore pair for ebp

//----- (0804AA48) --------------------------------------------------------
int __usercall sub_804AA48@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_8066374, a1);
}

//----- (0804AAE5) --------------------------------------------------------
int __usercall sub_804AAE5@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  a1(&dword_8065EF8);
  return nullsub_4();
}
// 804AAE5: could not find valid save-restore pair for ebx
// 804AA15: using guessed type int nullsub_4(void);
// 8061819: using guessed type int __fastcall sub_8061819(_DWORD, _DWORD);
// 8065EF8: using guessed type int dword_8065EF8;
// 806B2A4: using guessed type int dword_806B2A4;

//----- (0804AB43) --------------------------------------------------------
void sub_804AB43()
{
  ;
}

//----- (0804AB5E) --------------------------------------------------------
void sub_804AB5E()
{
  ;
}

//----- (0804AB6E) --------------------------------------------------------
int sub_804AB6E()
{
  int result; // eax

  result = &unk_806B417 - &unk_806B414;
  _CF = (unsigned int)(&unk_806B417 - &unk_806B414) < 6;
  _OF = __OFSUB__(&unk_806B417 - &unk_806B414, 6);
  _ZF = &unk_806B417 - &unk_806B414 == 6;
  _SF = &unk_806B417 - &unk_806B414 - 6 < 0;
  if ( (unsigned int)(&unk_806B417 - &unk_806B414) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 804AB6E: could not find valid save-restore pair for ebp

//----- (0804AC56) --------------------------------------------------------
void sub_804AC56()
{
  ;
}

//----- (0804AC71) --------------------------------------------------------
void sub_804AC71()
{
  ;
}

//----- (0804AC81) --------------------------------------------------------
int sub_804AC81()
{
  int result; // eax

  result = &unk_806B40F - &unk_806B40C;
  _CF = (unsigned int)(&unk_806B40F - &unk_806B40C) < 6;
  _OF = __OFSUB__(&unk_806B40F - &unk_806B40C, 6);
  _ZF = &unk_806B40F - &unk_806B40C == 6;
  _SF = &unk_806B40F - &unk_806B40C - 6 < 0;
  if ( (unsigned int)(&unk_806B40F - &unk_806B40C) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 804AC81: could not find valid save-restore pair for ebp

//----- (0804AD92) --------------------------------------------------------
void sub_804AD92()
{
  ;
}

//----- (0804ADAD) --------------------------------------------------------
void sub_804ADAD()
{
  ;
}

//----- (0804ADBD) --------------------------------------------------------
int sub_804ADBD()
{
  int result; // eax

  result = &unk_806B93F - (_UNKNOWN *)&program_invocation_short_name;
  _CF = (unsigned int)(&unk_806B93F - (_UNKNOWN *)&program_invocation_short_name) < 6;
  _OF = __OFSUB__(&unk_806B93F - (_UNKNOWN *)&program_invocation_short_name, 6);
  _ZF = &unk_806B93F - (_UNKNOWN *)&program_invocation_short_name == 6;
  _SF = &unk_806B93F - (_UNKNOWN *)&program_invocation_short_name - 6 < 0;
  if ( (unsigned int)(&unk_806B93F - (_UNKNOWN *)&program_invocation_short_name) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 804ADBD: could not find valid save-restore pair for ebp
// 806B420: using guessed type int program_invocation_short_name;

//----- (0804AEA5) --------------------------------------------------------
void sub_804AEA5()
{
  ;
}

//----- (0804AEC0) --------------------------------------------------------
void sub_804AEC0()
{
  ;
}

//----- (0804AED0) --------------------------------------------------------
int sub_804AED0()
{
  int result; // eax

  result = &unk_806B417 - &unk_806B414;
  _CF = (unsigned int)(&unk_806B417 - &unk_806B414) < 6;
  _OF = __OFSUB__(&unk_806B417 - &unk_806B414, 6);
  _ZF = &unk_806B417 - &unk_806B414 == 6;
  _SF = &unk_806B417 - &unk_806B414 - 6 < 0;
  if ( (unsigned int)(&unk_806B417 - &unk_806B414) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 804AED0: could not find valid save-restore pair for ebp

//----- (0804AF39) --------------------------------------------------------
int __usercall sub_804AF39@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_806B414, a1);
}

//----- (0804AF9F) --------------------------------------------------------
int __cdecl sub_804AF9F(int a1)
{
  int result; // eax

  if ( a1 != 1 )
  {
    result = a1;
    status = a1;
  }
  return result;
}

//----- (0804AFB2) --------------------------------------------------------
int __cdecl sub_804AFB2(unsigned __int8 a1)
{
  return a1;
}

//----- (0804AFC4) --------------------------------------------------------
signed int __cdecl sub_804AFC4(unsigned __int8 a1)
{
  void *v1; // eax
  int v3; // [esp+0h] [ebp-18h]
  int v4; // [esp+4h] [ebp-14h]
  int v5; // [esp+8h] [ebp-10h]
  _DWORD v6[3]; // [esp+Ch] [ebp-Ch]
  int v7; // [esp+10h] [ebp-8h]
  int v8; // [esp+14h] [ebp-4h]
  int savedregs; // [esp+18h] [ebp+0h]

  LOBYTE(v6[0]) = a1;
  if ( !((*__ctype_b_loc())[a1] & 1) )
  {
    v1 = &loc_804B00B;
    if ( a1 != 10 )
      v1 = &loc_804B012;
    dword_806B268 = (int)v1;
    sub_806197F(v3, v4, v5, v6[0], v7, v8, savedregs);
  }
  return 1;
}
// 806197F: using guessed type int __stdcall sub_806197F(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806B268: using guessed type int dword_806B268;

//----- (0804B01D) --------------------------------------------------------
int __cdecl sub_804B01D(__int64 a1)
{
  int v1; // edx
  int v2; // ecx

  if ( HIDWORD(a1) )
  {
    sub_806137E(a1, 1000000LL);
    dword_806B2A4 = (int)&locret_804B076;
    sub_8061819(v2, v1);
  }
  return a1;
}
// 806137E: using guessed type _DWORD __cdecl sub_806137E(__int64, __int64);
// 8061819: using guessed type int __fastcall sub_8061819(_DWORD, _DWORD);
// 806B2A4: using guessed type int dword_806B2A4;

//----- (0804B078) --------------------------------------------------------
int sub_804B078()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nWith no FILE, or when FILE is -, read standard input.\n");
  return fputs_unlocked(v1, v0);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804B0A3) --------------------------------------------------------
int sub_804B0A3()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nMandatory arguments to long options are mandatory for short options too.\n");
  return fputs_unlocked(v1, v0);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804B0CE) --------------------------------------------------------
int __usercall sub_804B0CE@<eax>(int a1@<ebx>, char *s1)
{
  bool v2; // zf
  void *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // ebx
  char *v8; // eax
  int v10; // [esp-8h] [ebp-70h]
  char *v11; // [esp-4h] [ebp-6Ch]
  int v12; // [esp+0h] [ebp-68h]
  char *v13; // [esp+4h] [ebp-64h]
  char *v14; // [esp+8h] [ebp-60h]
  char *v15; // [esp+1Ch] [ebp-4Ch]
  char **i; // [esp+20h] [ebp-48h]
  char *v17; // [esp+24h] [ebp-44h]
  const char *v18; // [esp+28h] [ebp-40h]
  const char *v19; // [esp+2Ch] [ebp-3Ch]
  const char *v20; // [esp+30h] [ebp-38h]
  const char *v21; // [esp+34h] [ebp-34h]
  const char *v22; // [esp+38h] [ebp-30h]
  const char *v23; // [esp+3Ch] [ebp-2Ch]
  const char *v24; // [esp+40h] [ebp-28h]
  const char *v25; // [esp+44h] [ebp-24h]
  const char *v26; // [esp+48h] [ebp-20h]
  const char *v27; // [esp+4Ch] [ebp-1Ch]
  const char *v28; // [esp+50h] [ebp-18h]
  const char *v29; // [esp+54h] [ebp-14h]
  int v30; // [esp+58h] [ebp-10h]
  int v31; // [esp+5Ch] [ebp-Ch]

  v18 = "[";
  v19 = "test invocation";
  v20 = "coreutils";
  v21 = "Multi-call invocation";
  v22 = "sha224sum";
  v23 = "sha2 utilities";
  v24 = "sha256sum";
  v25 = "sha2 utilities";
  v26 = "sha384sum";
  v27 = "sha2 utilities";
  v28 = "sha512sum";
  v29 = "sha2 utilities";
  v30 = 0;
  v31 = 0;
  v15 = s1;
  for ( i = (char **)(&v12 - 16); ; i += 2 )
  {
    v2 = *i == 0;
    v11 = *i;
    v10 = a1;
    v3 = &loc_804B18B;
    if ( v2 )
      v3 = &loc_804B1A3;
    dword_806B290 = (int)v3;
    a1 = v10;
    sub_80618A3();
    v13 = *i;
    if ( !strcmp(s1, v13) )
      break;
  }
  if ( i[1] )
    v15 = i[1];
  v4 = gettext("\n%s online help: <%s>\n");
  v14 = "http://www.gnu.org/software/coreutils/";
  v13 = "GNU coreutils";
  printf(v4, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  v17 = setlocale(5, 0);
  if ( v17 && strncmp(v17, "en_", 3u) )
  {
    v5 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
    v13 = s1;
    printf(v5, s1);
  }
  v6 = gettext("Full documentation at: <%s%s>\n");
  v14 = s1;
  v13 = "http://www.gnu.org/software/coreutils/";
  printf(v6, "http://www.gnu.org/software/coreutils/", s1);
  if ( v15 == s1 )
    v7 = " invocation";
  else
    v7 = &locale;
  v8 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  v14 = v7;
  v13 = v15;
  return printf(v8, v15, v7);
}
// 80618A3: using guessed type int sub_80618A3(void);
// 806B290: using guessed type int dword_806B290;

//----- (0804B28D) --------------------------------------------------------
void __cdecl __noreturn sub_804B28D(int a1, const char *a2)
{
  size_t v2; // eax
  char *v3; // ST20_4
  size_t v4; // eax
  char v5; // [esp+24h] [ebp-18h]
  unsigned int v6; // [esp+30h] [ebp-Ch]

  v6 = __readgsdword(0x14u);
  v2 = strlen(a2);
  write(2, a2, v2);
  if ( a1 )
  {
    v3 = (char *)sub_80591E7(a1, (int)&v5);
    write(2, ": errno ", 8u);
    v4 = strlen(v3);
    write(2, v3, v4);
  }
  write(2, "\n", 1u);
  _exit(2);
}

//----- (0804B363) --------------------------------------------------------
void __cdecl __noreturn sub_804B363(int a1, char *a2)
{
  char *v2; // eax
  void *v3; // ebx
  int *v4; // eax
  int v5; // edx
  int v6; // ecx

  if ( a2 )
    v2 = a2;
  else
    v2 = gettext("standard output");
  v3 = sub_805B927(0, 3, (int)v2);
  v4 = __errno_location();
  error(2, *v4, "%s: %s", a1, v3);
  sub_804B3C5(v5, v6, a1);
}

//----- (0804B3C5) --------------------------------------------------------
void __usercall __noreturn sub_804B3C5(int a1@<edx>, int a2@<ecx>, int status)
{
  void *v3; // eax
  int v4; // ebx
  char *v5; // eax
  int v6; // [esp+0h] [ebp-18h]
  int v7; // [esp+4h] [ebp-14h]

  v3 = &loc_804B3EC;
  if ( !status )
    v3 = &loc_804B419;
  dword_806B220 = (int)v3;
  sub_8061B4D(a2, a1, v6, v7);
  v4 = dword_806BF99;
  v5 = gettext("Try '%s --help' for more information.\n");
  fprintf(stderr, v5, v4);
  exit(status);
}
// 806B220: using guessed type int dword_806B220;
// 806BF99: using guessed type int dword_806BF99;

//----- (0804B69A) --------------------------------------------------------
int __cdecl sub_804B69A(int a1)
{
  bool v1; // dl
  int result; // eax

  v1 = pthread_sigmask(0, &set, (__sigset_t *)(a1 + 4)) == 0;
  result = a1;
  *(_BYTE *)a1 = v1;
  return result;
}

//----- (0804B6CF) --------------------------------------------------------
int __cdecl sub_804B6CF(unsigned __int8 *a1)
{
  int result; // eax

  result = *a1;
  if ( (_BYTE)result )
    result = pthread_sigmask(2, (const __sigset_t *)(a1 + 4), 0);
  return result;
}

//----- (0804B6FF) --------------------------------------------------------
int __cdecl sub_804B6FF(int a1, unsigned int a2)
{
  return *(_DWORD *)(a1 + 4) % a2;
}

//----- (0804B72E) --------------------------------------------------------
bool __cdecl sub_804B72E(int a1, int a2)
{
  return *(_DWORD *)(a1 + 4) == *(_DWORD *)(a2 + 4);
}

//----- (0804B763) --------------------------------------------------------
int __usercall sub_804B763@<eax>(char *a1@<ebx>, __pid_t pid)
{
  __pid_t v2; // eax
  void *v3; // esi
  int *v4; // eax
  void *v5; // eax
  void *v6; // ebx
  char *v7; // eax
  int stat_loc; // [esp+18h] [ebp-10h]
  int v10; // [esp+1Ch] [ebp-Ch]

  if ( pid )
    v2 = pid;
  else
    v2 = -1;
  v10 = waitpid(v2, &stat_loc, pid == 0);
  if ( v10 < 0 )
  {
    v3 = sub_805B79C(4, (int)s1);
    a1 = gettext("waiting for %s [-d]");
    v4 = __errno_location();
    error(2, *v4, a1, v3);
  }
  v5 = &loc_804B804;
  if ( v10 <= 0 )
    v5 = &loc_804B87E;
  dword_806B2D8 = (int)v5;
  sub_8061693();
  if ( pid > 0 || (unsigned __int8)sub_804B915((int)a1, v10) )
  {
    if ( stat_loc & 0x7F || (stat_loc & 0xFF00) >> 8 )
    {
      v6 = sub_805B79C(4, (int)s1);
      v7 = gettext("%s [-d] terminated abnormally");
      error(2, 0, v7, v6);
    }
    --dword_806BED1;
  }
  return v10;
}
// 8061693: using guessed type int sub_8061693(void);
// 806B2D8: using guessed type int dword_806B2D8;
// 806BED1: using guessed type int dword_806BED1;

//----- (0804B888) --------------------------------------------------------
void __usercall __noreturn sub_804B888(int a1@<edx>, int a2@<ecx>, int a3)
{
  bool v3; // zf
  int (*v4)(); // eax

  if ( !dword_806BECD )
  {
    dword_806BECD = sub_8057E14(a1, a2, 47, 0, (int)sub_804B6FF, (int)sub_804B72E);
    if ( !dword_806BECD )
      sub_805E692();
  }
  *(_BYTE *)(a3 + 8) = 1;
  v3 = sub_8058B77((unsigned int *)dword_806BECD, a3) == 0;
  v4 = (int (*)())&loc_804B90E;
  if ( !v3 )
    v4 = sub_804B913;
  dword_806B254 = (int)v4;
  sub_80619F1();
  sub_805E692();
}
// 804B913: using guessed type int sub_804B913();
// 80619F1: using guessed type int sub_80619F1(void);
// 806B254: using guessed type int dword_806B254;
// 806BECD: using guessed type int dword_806BECD;

//----- (0804B913) --------------------------------------------------------
#error "804B914: positive sp value has been found (funcsize=0)"

//----- (0804B915) --------------------------------------------------------
signed int __usercall sub_804B915@<eax>(int a1@<ebx>, int a2)
{
  signed int result; // eax
  int v7; // [esp+0h] [ebp-38h]
  int v8; // [esp+1Ch] [ebp-1Ch]
  int v9; // [esp+24h] [ebp-14h]
  unsigned int v10; // [esp+2Ch] [ebp-Ch]

  v10 = __readgsdword(0x14u);
  v9 = a2;
  v8 = sub_8058BB7(a1, dword_806BECD, (int)(&v7 - 6));
  _CF = 0;
  _OF = 0;
  _ZF = v8 == 0;
  _SF = v8 < 0;
  if ( v8 )
  {
    *(_BYTE *)(v8 + 8) = 2;
    result = 1;
  }
  else
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 806BECD: using guessed type int dword_806BECD;

//----- (0804B980) --------------------------------------------------------
int __usercall sub_804B980@<eax>(char *a1@<ebx>, __pid_t pid)
{
  int result; // eax

  result = sub_804B915((int)a1, pid);
  if ( (_BYTE)result )
    result = sub_804B763(a1, pid);
  return result;
}

//----- (0804B9A2) --------------------------------------------------------
int __usercall sub_804B9A2@<eax>(char *a1@<ebx>)
{
  int result; // eax

  do
  {
    result = dword_806BED1;
    if ( dword_806BED1 <= 0 )
      break;
    result = sub_804B763(a1, 0);
  }
  while ( result );
  return result;
}
// 806BED1: using guessed type int dword_806BED1;

//----- (0804B9C5) --------------------------------------------------------
int __usercall sub_804B9C5@<eax>(char *a1@<ebx>)
{
  sub_804B763(a1, -1);
  return sub_804B9A2(a1);
}

//----- (0804B9DE) --------------------------------------------------------
int __usercall sub_804B9DE@<eax>(char *a1@<ebx>)
{
  int result; // eax

  while ( 1 )
  {
    result = dword_806BED1;
    if ( dword_806BED1 <= 0 )
      break;
    sub_804B763(a1, -1);
  }
  return result;
}
// 806BED1: using guessed type int dword_806BED1;

//----- (0804B9FD) --------------------------------------------------------
int sub_804B9FD()
{
  int result; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  result = dword_806BEC9;
  for ( i = dword_806BEC9; i; i = *(_DWORD *)i )
  {
    unlink((const char *)(i + 9));
    result = *(_DWORD *)i;
  }
  dword_806BEC9 = 0;
  return result;
}
// 806BEC9: using guessed type int dword_806BEC9;

//----- (0804BA35) --------------------------------------------------------
int __usercall sub_804BA35@<eax>(int a1@<ebx>)
{
  char v2; // [esp+1Ch] [ebp-8Ch]

  if ( dword_806BEC9 )
  {
    sub_804B69A((int)&v2);
    sub_804B9FD();
    sub_804B6CF((unsigned __int8 *)&v2);
  }
  return sub_8055A5B(a1);
}
// 806BEC9: using guessed type int dword_806BEC9;

//----- (0804BA6F) --------------------------------------------------------
void *__usercall sub_804BA6F@<eax>(int a1@<ebx>, _DWORD *a2, char a3)
{
  _DWORD *v3; // eax
  void *v4; // esi
  char *v5; // ebx
  int v6; // eax
  void *v8; // [esp-10h] [ebp-BCh]
  char v9; // [esp+0h] [ebp-ACh]
  void *ptr; // [esp+8h] [ebp-A4h]
  char *s; // [esp+Ch] [ebp-A0h]
  size_t n; // [esp+10h] [ebp-9Ch]
  void *dest; // [esp+14h] [ebp-98h]
  int v14; // [esp+18h] [ebp-94h]
  int v15; // [esp+1Ch] [ebp-90h]
  char v16; // [esp+20h] [ebp-8Ch]
  int v17; // [esp+A4h] [ebp-8h]

  v17 = a1;
  v9 = a3;
  s = *(char **)(4 * dword_806BF85 + dword_806BE2D);
  n = strlen(s);
  ptr = sub_805E4E9((n + 24) & 0xFFFFFFFC);
  dest = (char *)ptr + 9;
  memcpy((char *)ptr + 9, s, n);
  v3 = (char *)ptr + n + 9;
  *v3 = 1919906607;
  v3[1] = 1482184820;
  v3[2] = 5789784;
  *(_DWORD *)ptr = 0;
  if ( ++dword_806BF85 == dword_806BE31 )
    dword_806BF85 = 0;
  sub_804B69A((int)&v16);
  v14 = sub_805D4BD(a1, (int)dest, 0x80000);
  if ( v14 >= 0 )
  {
    *off_806B398 = (int)ptr;
    off_806B398 = (int *)ptr;
  }
  v15 = *__errno_location();
  sub_804B6CF((unsigned __int8 *)&v16);
  *__errno_location() = v15;
  if ( v14 < 0 )
  {
    if ( v9 != 1 || *__errno_location() != 24 )
    {
      v4 = sub_805B79C(4, (int)s);
      v5 = gettext("cannot create temporary file in %s");
      v6 = *__errno_location();
      v8 = v4;
      error(2, v6, v5, v4);
    }
    free(ptr);
    ptr = 0;
  }
  *a2 = v14;
  return ptr;
}
// 806B398: using guessed type int *off_806B398;
// 806BE2D: using guessed type int dword_806BE2D;
// 806BE31: using guessed type int dword_806BE31;
// 806BF85: using guessed type int dword_806BF85;

//----- (0804BC8C) --------------------------------------------------------
FILE *__cdecl sub_804BC8C(char *s1, char *modes)
{
  FILE *v6; // eax
  void *v7; // esi
  char *v8; // ebx
  int *v9; // eax
  FILE *stream; // [esp+18h] [ebp-10h]
  int fd; // [esp+1Ch] [ebp-Ch]

  if ( *modes == 114 )
  {
    if ( !strcmp(s1, "-") )
    {
      byte_806BE3C = 1;
      stream = stdin;
      sub_8056F26(stdin, 2);
    }
    else
    {
      fd = open64(s1, 0x80000);
      _CF = 0;
      _OF = 0;
      _ZF = fd == 0;
      _SF = fd < 0;
      if ( fd < 0 )
      {
        __asm { pushfw }
        v6 = 0;
        __asm { popfw }
      }
      else
      {
        v6 = fdopen(fd, modes);
      }
      stream = v6;
      sub_8056F26(v6, 2);
    }
  }
  else
  {
    if ( *modes != 119 )
      __assert_fail("!\"unexpected mode passed to stream_open\"", "src/sort.c", 0x3CCu, "stream_open");
    if ( s1 && ftruncate64(1, 0, 0) )
    {
      v7 = sub_805B927(0, 3, (int)s1);
      v8 = gettext("%s: error truncating");
      v9 = __errno_location();
      error(2, *v9, v8, v7);
    }
    stream = stdout;
  }
  return stream;
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 8049D20: using guessed type int __cdecl ftruncate64(_DWORD, _DWORD, _DWORD);
// 806BE3C: using guessed type char byte_806BE3C;

//----- (0804BDC9) --------------------------------------------------------
FILE *__cdecl sub_804BDC9(char *s1, char *modes)
{
  char *v2; // eax
  FILE *v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_804BC8C(s1, modes);
  if ( !v4 )
  {
    v2 = gettext("open failed");
    sub_804B363((int)v2, s1);
  }
  return v4;
}

//----- (0804BE0A) --------------------------------------------------------
void __cdecl sub_804BE0A(FILE *stream, int a2)
{
  int v2; // eax
  bool v3; // zf
  void *v4; // eax
  char *v5; // eax

  v2 = fileno(stream);
  if ( v2 )
  {
    v3 = v2 == 1;
    v4 = &loc_804BE3D;
    if ( v3 )
      v4 = &loc_804BE5D;
    dword_806B254 = (int)v4;
    sub_80619F1();
    if ( sub_805F4C1(stream) )
    {
      v5 = gettext("close failed");
      sub_804B363((int)v5, (char *)a2);
    }
  }
  else if ( feof_unlocked(stream) )
  {
    clearerr_unlocked(stream);
  }
}
// 80619F1: using guessed type int sub_80619F1(void);
// 806B254: using guessed type int dword_806B254;

//----- (0804BEB5) --------------------------------------------------------
int __cdecl sub_804BEB5(int fd, int fd2)
{
  int result; // eax

  result = fd;
  if ( fd != fd2 )
  {
    dup2(fd, fd2);
    result = close(fd);
  }
  return result;
}

//----- (0804BEE2) --------------------------------------------------------
__pid_t __usercall sub_804BEE2@<eax>(char *a1@<ebx>, int pipedes[2], int a3)
{
  bool v4; // zf
  int v5; // edx
  int v6; // ecx
  void *v7; // eax
  int v8; // eax
  int v9; // [esp+0h] [ebp-B8h]
  int v10; // [esp+4h] [ebp-B4h]
  __pid_t v11; // [esp+14h] [ebp-A4h]
  int v12; // [esp+18h] [ebp-A0h]
  int v13; // [esp+1Ch] [ebp-9Ch]
  double v14; // [esp+20h] [ebp-98h]
  char v15; // [esp+2Ch] [ebp-8Ch]

  v14 = 0.25;
  if ( sub_8059B87((int)a1, pipedes, 0x80000) < 0 )
    return -1;
  if ( dword_806B394 + 1 >= (unsigned int)dword_806BED1 )
  {
    dword_806B290 = (int)&loc_804C003;
    sub_80618A3();
    goto LABEL_6;
  }
  sub_804B9C5(a1);
  while ( 1 )
  {
    v8 = a3--;
    if ( !v8 )
      break;
LABEL_6:
    sub_804B69A((int)&v15);
    v12 = dword_806BEC9;
    dword_806BEC9 = 0;
    v11 = fork();
    v13 = *__errno_location();
    if ( v11 )
      dword_806BEC9 = v12;
    sub_804B6CF((unsigned __int8 *)&v15);
    *__errno_location() = v13;
    if ( v11 >= 0 )
      break;
    v4 = *__errno_location() == 11;
    v7 = &loc_804BFE2;
    if ( !v4 )
      v7 = &loc_804C014;
    dword_806B220 = (int)v7;
    sub_8061B4D(v6, v5, v9, v10);
    sub_805E8A7(v14);
    v14 = v14 + v14;
    sub_804B9A2(a1);
  }
  if ( v11 >= 0 )
  {
    if ( v11 )
    {
      ++dword_806BED1;
    }
    else
    {
      close(0);
      close(1);
    }
  }
  else
  {
    v13 = *__errno_location();
    close(*pipedes);
    close(pipedes[1]);
    *__errno_location() = v13;
  }
  return v11;
}
// 80618A3: using guessed type int sub_80618A3(void);
// 806B220: using guessed type int dword_806B220;
// 806B290: using guessed type int dword_806B290;
// 806B394: using guessed type int dword_806B394;
// 806BEC9: using guessed type int dword_806BEC9;
// 806BED1: using guessed type int dword_806BED1;

//----- (0804C08E) --------------------------------------------------------
void *__usercall sub_804C08E@<eax>(char *a1@<ebx>, FILE **a2, char a3)
{
  void *result; // eax
  __pid_t v8; // eax
  int v9; // edx
  int v10; // ecx
  int *v11; // eax
  char *v12; // ebx
  char *v13; // eax
  int v14; // [esp+0h] [ebp-1Ch]
  int fd; // [esp+4h] [ebp-18h]
  char *v16; // [esp+8h] [ebp-14h]
  int pipedes[2]; // [esp+Ch] [ebp-10h]

  LOBYTE(v14) = a3;
  v16 = (char *)sub_804BA6F((int)a1, &fd, a3);
  _CF = 0;
  _OF = 0;
  _ZF = v16 == 0;
  _SF = (signed int)v16 < 0;
  if ( v16 )
  {
    v16[8] = 0;
    if ( s1 )
    {
      v8 = sub_804BEE2(a1, pipedes, 4);
      *((_DWORD *)v16 + 1) = v8;
      if ( *((_DWORD *)v16 + 1) > 0 )
      {
        close(fd);
        close(pipedes[0]);
        fd = pipedes[1];
        sub_804B888(v9, v10, (int)v16);
      }
      if ( !*((_DWORD *)v16 + 1) )
      {
        close(pipedes[1]);
        sub_804BEB5(fd, 1);
        sub_804BEB5(pipedes[0], 0);
        execlp(s1, s1, 0, v14);
        v11 = __errno_location();
        sub_804B28D(*v11, "couldn't execute compress program");
      }
    }
    *a2 = fdopen(fd, "w");
    if ( !*a2 )
    {
      v12 = v16 + 9;
      v13 = gettext("couldn't create temporary file");
      sub_804B363((int)v13, v12);
    }
    result = v16;
  }
  else
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}

//----- (0804C200) --------------------------------------------------------
void *__usercall sub_804C200@<eax>(char *a1@<ebx>, FILE **a2)
{
  return sub_804C08E(a1, a2, 0);
}

//----- (0804C21B) --------------------------------------------------------
int __usercall sub_804C21B@<eax>(char *a1@<ebx>, int a2)
{
  __pid_t v2; // eax
  int v3; // ecx
  void *v4; // esi
  char *v5; // ebx
  int v6; // eax
  int *v7; // eax
  int v8; // edx
  const char *v10; // [esp+8h] [ebp-30h]
  void *v11; // [esp+Ch] [ebp-2Ch]
  int v12; // [esp+18h] [ebp-20h]
  int fd; // [esp+1Ch] [ebp-1Ch]
  int v14; // [esp+20h] [ebp-18h]
  int pipedes[2]; // [esp+28h] [ebp-10h]

  v12 = 0;
  if ( *(_BYTE *)(a2 + 8) == 1 )
    sub_804B980(a1, *(_DWORD *)(a2 + 4));
  fd = open64(a2 + 9, 0);
  if ( fd < 0 )
  {
    dword_806B290 = (int)&loc_804C3EA;
    sub_80618A3();
  }
  v2 = sub_804BEE2(a1, pipedes, 9);
  v14 = v2;
  if ( v2 != -1 )
  {
    if ( v2 )
    {
      v8 = v14;
      *(_DWORD *)(a2 + 4) = v14;
      sub_804B888(v8, v3, a2);
    }
    close(pipedes[0]);
    sub_804BEB5(fd, 0);
    sub_804BEB5(pipedes[1], 1);
    v11 = 0;
    v10 = "-d";
    execlp(s1, s1, "-d", 0);
    v7 = __errno_location();
    sub_804B28D(*v7, "couldn't execute compress program (with -d)");
  }
  if ( *__errno_location() != 24 )
  {
    v4 = sub_805B79C(4, (int)s1);
    v5 = gettext("couldn't create process for %s -d");
    v6 = *__errno_location();
    v11 = v4;
    error(2, v6, v5, v4);
  }
  close(fd);
  *__errno_location() = 24;
  return v12;
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 80618A3: using guessed type int sub_80618A3(void);
// 806B290: using guessed type int dword_806B290;

//----- (0804C3F1) --------------------------------------------------------
int __cdecl sub_804C3F1(int a1)
{
  int v1; // eax
  _DWORD *v2; // edx
  int result; // eax

  if ( dword_806BE31 == dword_806BE35 )
    dword_806BE2D = sub_805E413(dword_806BE2D, (unsigned int *)&dword_806BE35, 4u);
  v1 = dword_806BE31++;
  v2 = (_DWORD *)(dword_806BE2D + 4 * v1);
  result = a1;
  *v2 = a1;
  return result;
}
// 806BE2D: using guessed type int dword_806BE2D;
// 806BE31: using guessed type int dword_806BE31;
// 806BE35: using guessed type int dword_806BE35;

//----- (0804C449) --------------------------------------------------------
void __usercall sub_804C449(char *a1@<ebx>, char *name)
{
  int v2; // ST28_4
  void *v3; // ebx
  char *v4; // eax
  int *i; // [esp+18h] [ebp-A0h]
  int errnum; // [esp+1Ch] [ebp-9Ch]
  _DWORD *ptr; // [esp+20h] [ebp-98h]
  int v8; // [esp+24h] [ebp-94h]
  char v9; // [esp+2Ch] [ebp-8Ch]

  for ( i = &dword_806BEC9; ; i = (int *)*i )
  {
    ptr = (_DWORD *)*i;
    if ( (char *)(*i + 9) == name )
      break;
  }
  if ( *((_BYTE *)ptr + 8) == 1 )
    sub_804B980(a1, ptr[1]);
  v8 = *ptr;
  sub_804B69A((int)&v9);
  v2 = unlink(name);
  errnum = *__errno_location();
  *i = v8;
  sub_804B6CF((unsigned __int8 *)&v9);
  if ( v2 )
  {
    v3 = sub_805B927(0, 3, (int)name);
    v4 = gettext("warning: cannot remove: %s");
    error(0, errnum, v4, v3);
  }
  if ( !v8 )
    off_806B398 = i;
  free(ptr);
}
// 806B398: using guessed type int *off_806B398;
// 806BEC9: using guessed type int dword_806BEC9;

//----- (0804C581) --------------------------------------------------------
int __cdecl compar(const void *a1, const void *a2)
{
  return strcmp(*(const char **)a1, *(const char **)a2);
}

//----- (0804C5BB) --------------------------------------------------------
void sub_804C5BB()
{
  int v0; // eax
  char v3; // al
  char v4; // al
  int v7; // ecx
  int v8; // ST04_4
  const unsigned __int16 *v9; // ebx
  int v10; // eax
  int v11; // [esp+4h] [ebp-34h]
  unsigned int c; // [esp+18h] [ebp-20h]
  unsigned int ca; // [esp+18h] [ebp-20h]
  size_t v14; // [esp+1Ch] [ebp-1Ch]
  int v15; // [esp+20h] [ebp-18h]
  const char *s; // [esp+24h] [ebp-14h]
  size_t v17; // [esp+28h] [ebp-10h]
  char *v18; // [esp+2Ch] [ebp-Ch]

  for ( c = 0; c <= 0xFF; ++c )
  {
    *(_BYTE *)(c + 134658601) = sub_804AFC4(c);
    *(_BYTE *)(c + 134658857) = ((*__ctype_b_loc())[c] & 0x4000) == 0;
    v0 = (*__ctype_b_loc())[c] & 8;
    _ZF = v0 == 0;
    _SF = v0 < 0;
    if ( v0 || (v3 = sub_804AFC4(c) ^ 1, _ZF = v3 == 0, _SF = v3 < 0, !v3) )
    {
      __asm { pushfw }
      v4 = 0;
      __asm { popfw }
    }
    else
    {
      v4 = 1;
    }
    *(_BYTE *)(c + 134659113) = v4 & 1;
    *(_BYTE *)(c + 134659369) = toupper(c);
  }
  if ( byte_806BA12 )
  {
    for ( ca = 0; ca <= 0xB; ++ca )
    {
      s = nl_langinfo(ca + 131086);
      v17 = strlen(s);
      v18 = (char *)sub_805E4E9(v17 + 1);
      (&off_806B32C)[2 * ca] = v18;
      dword_806B330[2 * ca] = ca + 1;
      v15 = 0;
      v14 = 0;
      dword_806B220 = (int)&loc_804C7A7;
      sub_8061B4D(v7, ca + 1, v8, v11);
      do
      {
        v9 = *__ctype_b_loc();
        if ( !(v9[(unsigned __int8)sub_804AFB2(s[v14])] & 1) )
        {
          v10 = v15++;
          v18[v10] = byte_806BD29[(unsigned __int8)sub_804AFB2(s[v14])];
        }
        ++v14;
      }
      while ( v14 < v17 );
      v18[v15] = 0;
    }
    qsort(&off_806B32C, 0xCu, 8u, compar);
  }
}
// 806B220: using guessed type int dword_806B220;
// 806B32C: using guessed type char *off_806B32C;
// 806B330: using guessed type int dword_806B330[];
// 806BA12: using guessed type char byte_806BA12;

//----- (0804C7F2) --------------------------------------------------------
void __fastcall __noreturn sub_804C7F2(int ecx0, int edx0, int a1, char a2, char *a3)
{
  int v5; // ecx
  int v6; // eax
  void *v7; // eax
  void *v8; // ebx
  int v9; // esi
  char *v10; // eax
  int v11; // ebx
  int v12; // esi
  char *v13; // eax
  int v14; // [esp+Ch] [ebp-4Ch]
  int v15; // [esp+10h] [ebp-48h]
  char *nptr; // [esp+18h] [ebp-40h]
  char v17; // [esp+1Ch] [ebp-3Ch]
  int v18; // [esp+20h] [ebp-38h]
  unsigned int v19; // [esp+24h] [ebp-34h]
  __int64 v20; // [esp+28h] [ebp-30h]
  int v21; // [esp+30h] [ebp-28h]
  char v22; // [esp+41h] [ebp-17h]
  unsigned int v23; // [esp+4Ch] [ebp-Ch]

  v17 = a2;
  nptr = a3;
  v23 = __readgsdword(0x14u);
  v18 = sub_805F062(edx0, ecx0, a3, 0, 10, (int)&v20, 0);
  if ( getrlimit64(7, &v21) )
    v6 = 17;
  else
    v6 = v21 - 3;
  v19 = v6;
  if ( !v18 )
  {
    dword_806B394 = v20;
    v7 = &loc_804C8D5;
    if ( v20 == (unsigned int)v20 )
      v7 = &loc_804C8E1;
    dword_806B254 = (int)v7;
    sub_80619F1();
    v18 = 1;
  }
  if ( v18 == 1 )
  {
    v8 = sub_805BBBF((int)nptr);
    v9 = *((_DWORD *)&longopts.name + 4 * a1);
    v10 = gettext("--%s argument %s too large");
    v15 = (int)v8;
    v14 = v9;
    error(0, 0, v10, v9, v8);
    v11 = sub_80592E1(v19, (int)&v22);
    v12 = *((_DWORD *)&longopts.name + 4 * a1);
    v13 = gettext("maximum --%s argument with current rlimit is %s");
    v15 = v11;
    v14 = v12;
    error(2, 0, v13, v12, v11);
  }
  sub_805EF2C(v5, (int)nptr, v18, a1, v17, (int)&longopts, (int)nptr);
}
// 8049920: using guessed type int __cdecl getrlimit64(_DWORD, _DWORD);
// 80619F1: using guessed type int sub_80619F1(void);
// 806B254: using guessed type int dword_806B254;
// 806B394: using guessed type int dword_806B394;

//----- (0804CA76) --------------------------------------------------------
int __usercall sub_804CA76@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, char *nptr)
{
  int v5; // ecx
  int v6; // eax
  long double v7; // fst7
  __int16 v8; // ax
  unsigned __int64 v9; // rax
  __int16 v10; // ax
  int result; // eax
  void *v12; // eax
  int v13; // [esp-8h] [ebp-70h]
  int v14; // [esp-4h] [ebp-6Ch]
  int v15; // [esp+0h] [ebp-68h]
  unsigned __int64 v16; // [esp+18h] [ebp-50h]
  double v17; // [esp+20h] [ebp-48h]
  __int16 v18; // [esp+28h] [ebp-40h]
  __int16 v19; // [esp+2Ah] [ebp-3Eh]
  char v20; // [esp+2Ch] [ebp-3Ch]
  int v21; // [esp+38h] [ebp-30h]
  int v22; // [esp+3Ch] [ebp-2Ch]
  unsigned __int64 v23; // [esp+40h] [ebp-28h]
  double v24; // [esp+48h] [ebp-20h]

  v20 = a4;
  v22 = sub_805F062(a1, a2, nptr, (int)(&v15 - 12), 10, (int)(&v15 - 10), "EgGkKmMPtTYZ");
  if ( !v22 && (unsigned int)(*(char *)(v21 - 1) - 48) <= 9 )
  {
    if ( HIDWORD(v23) > 0x3FFFFF )
      v22 = 1;
    else
      v23 <<= 10;
  }
  if ( v22 == 2 && (unsigned int)(*(char *)(v21 - 1) - 48) <= 9 && !*(_BYTE *)(v21 + 1) )
  {
    v6 = *(char *)v21;
    if ( v6 == 37 )
    {
      v7 = sub_8059997();
      v16 = v23;
      v17 = (long double)v23;
      v24 = v7 * v17 / 100.0;
      if ( v24 < 1.844674407370955e19 )
      {
        if ( v24 >= 9.223372036854776e18 )
        {
          LOBYTE(v10) = v19;
          HIBYTE(v10) = 12;
          v18 = v10;
          v16 = (signed __int64)(v24 - 9.223372036854776e18);
          v9 = v16 ^ 0x8000000000000000LL;
        }
        else
        {
          LOBYTE(v8) = v19;
          HIBYTE(v8) = 12;
          v18 = v8;
          v16 = (signed __int64)v24;
          v9 = (signed __int64)v24;
        }
        v23 = v9;
        v22 = 0;
        dword_806B2D8 = (int)&loc_804CC6E;
        sub_8061693();
      }
      v22 = 1;
    }
    else if ( v6 == 98 )
    {
      v22 = 0;
    }
  }
  if ( v22 )
    sub_805EF2C(v5, (int)nptr, v22, a3, v20, (int)&longopts, (int)nptr);
  result = v23;
  if ( size <= v23 )
  {
    size = v23;
    v14 = HIDWORD(v23) | v23 ^ v23;
    v13 = 0;
    v12 = &loc_804CCEF;
    if ( v23 != (unsigned int)v23 )
      v12 = &loc_804CD21;
    dword_806B2A4 = (int)v12;
    sub_8061819(v23, HIDWORD(v23));
    result = size;
    if ( 18 * dword_806B394 >= size )
      result = 18 * dword_806B394;
    size = result;
  }
  return result;
}
// 8059997: using guessed type double sub_8059997(void);
// 8061693: using guessed type int sub_8061693(void);
// 8061819: using guessed type int __fastcall sub_8061819(_DWORD, _DWORD);
// 806B2A4: using guessed type int dword_806B2A4;
// 806B2D8: using guessed type int dword_806B2D8;
// 806B394: using guessed type int dword_806B394;

//----- (0804CD59) --------------------------------------------------------
int __usercall sub_804CD59@<eax>(int a1@<ebx>, int a2, int a3, char *nptr)
{
  int v4; // ecx
  char *v6; // eax
  char v7; // [esp+1Ch] [ebp-1Ch]
  int v8; // [esp+28h] [ebp-10h]
  int v9; // [esp+2Ch] [ebp-Ch]

  v7 = a3;
  v9 = sub_805E9B6(a1, nptr, 0, 10, (int)&v8, &locale);
  if ( v9 == 1 )
    return -1;
  if ( v9 )
    sub_805EF2C(v4, (int)nptr, v9, a2, v7, (int)&longopts, (int)nptr);
  if ( !v8 )
  {
    v6 = gettext("number in parallel must be nonzero");
    error(2, 0, v6);
  }
  return v8;
}

//----- (0804CE0E) --------------------------------------------------------
int sub_804CE0E()
{
  __int16 v0; // ax
  __int16 v1; // ax
  int result; // eax
  int v3; // [esp+0h] [ebp-58h]
  int v4; // [esp+4h] [ebp-54h]
  int v5; // [esp+8h] [ebp-50h]
  int v6; // [esp+Ch] [ebp-4Ch]
  __int64 v7; // [esp+10h] [ebp-48h]
  int v8; // [esp+18h] [ebp-40h]
  int v9; // [esp+1Ch] [ebp-3Ch]
  int v10; // [esp+20h] [ebp-38h]
  unsigned int v11; // [esp+24h] [ebp-34h]
  double v12; // [esp+28h] [ebp-30h]
  double v13; // [esp+30h] [ebp-28h]
  double v14; // [esp+38h] [ebp-20h]
  unsigned __int64 v15; // [esp+40h] [ebp-18h]

  v11 = -1;
  if ( !getrlimit64(2, &v15) && v15 < v11 )
    v11 = v15;
  if ( !getrlimit64(9, &v15) && v15 < v11 )
    v11 = v15;
  v11 >>= 1;
  if ( !getrlimit64(5, &v15) && is_mul_ok(0xFu, v15 >> 4) && 15 * (unsigned int)(v15 >> 4) < v11 )
    v11 = 15 * (v15 >> 4);
  v12 = sub_8059AAD();
  v13 = sub_8059997();
  if ( v12 > v13 / 8.0 )
  {
    dword_806B20C = (int)&loc_804CF59;
    sub_8061BBB(v3, v4, v5, v6, v7, HIDWORD(v7), v8, v9, v10, v11, LODWORD(v12), HIDWORD(v12), LODWORD(v13));
  }
  v14 = v13 / 8.0;
  v7 = v11;
  if ( (long double)v11 > v13 * 0.75 )
  {
    LOBYTE(v0) = BYTE2(v9);
    HIBYTE(v0) = 12;
    LOWORD(v9) = v0;
    v7 = (signed __int64)(v13 * 0.75);
    v11 = v7;
  }
  v7 = v11;
  if ( (long double)v11 > v14 )
  {
    LOBYTE(v1) = BYTE2(v9);
    HIBYTE(v1) = 12;
    LOWORD(v9) = v1;
    v7 = (signed __int64)v14;
    v11 = v7;
  }
  result = v11;
  if ( 18 * dword_806B394 >= v11 )
    result = 18 * dword_806B394;
  return result;
}
// 8049920: using guessed type int __cdecl getrlimit64(_DWORD, _DWORD);
// 8059997: using guessed type double sub_8059997(void);
// 8061BBB: using guessed type int __stdcall sub_8061BBB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806B20C: using guessed type int dword_806B20C;
// 806B394: using guessed type int dword_806B394;

//----- (0804D057) --------------------------------------------------------
int __cdecl sub_804D057(int a1, unsigned int a2, int a3, unsigned int a4, int a5)
{
  int v5; // eax
  bool v6; // al
  bool v7; // zf
  void *v8; // eax
  void *v9; // eax
  char *v10; // ebx
  char *v11; // eax
  FILE *v13; // [esp+0h] [ebp-98h]
  int v14; // [esp+18h] [ebp-80h]
  unsigned int v15; // [esp+1Ch] [ebp-7Ch]
  int v16; // [esp+20h] [ebp-78h]
  char v17; // [esp+30h] [ebp-68h]

  v16 = a5 + 1;
  v14 = a5 + 2;
  v15 = 0;
  if ( v15 < a4 )
  {
    if ( v15 >= a2 )
    {
      v7 = strcmp(*(const char **)(4 * v15 + a3), "-") == 0;
      v8 = &loc_804D104;
      if ( !v7 )
        v8 = &loc_804D11E;
      dword_806B254 = (int)v8;
      sub_80619F1();
      v6 = sub_806160A(0, (int)&v17) != 0;
    }
    else
    {
      v13 = *(FILE **)(4 * v15 + a1);
      v5 = fileno(v13);
      v6 = sub_806160A(v5, (int)&v17) != 0;
    }
    v7 = v6 == 0;
    v9 = &loc_804D160;
    if ( v7 )
      v9 = &loc_804D189;
    dword_806B290 = (int)v9;
    sub_80618A3();
    v10 = *(char **)(4 * v15 + a3);
    v11 = gettext("stat failed");
    sub_804B363((int)v11, v10);
  }
  return v14;
}
// 80618A3: using guessed type int sub_80618A3(void);
// 80619F1: using guessed type int sub_80619F1(void);
// 806B254: using guessed type int dword_806B254;
// 806B290: using guessed type int dword_806B290;

//----- (0804D2A2) --------------------------------------------------------
int __cdecl sub_804D2A2(int a1, int a2, size_t size)
{
  int result; // eax
  size_t sizea; // [esp+28h] [ebp+10h]

  sizea = (size & 0xFFFFFFF0) + 16;
  *(_DWORD *)a1 = malloc(sizea);
  if ( !*(_DWORD *)a1 )
  {
    sizea >>= 1;
    if ( a2 + 1 >= sizea )
      sub_805E692();
    dword_806B2C4 = (int)&loc_804D2A8;
    sub_8061709();
  }
  *(_DWORD *)(a1 + 20) = a2;
  *(_DWORD *)(a1 + 12) = sizea;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a1 + 16);
  result = a1;
  *(_BYTE *)(a1 + 24) = 0;
  return result;
}
// 806B2C4: using guessed type int dword_806B2C4;

//----- (0804D34D) --------------------------------------------------------
int __cdecl sub_804D34D(_DWORD *a1)
{
  return *a1 + a1[3];
}

//----- (0804D378) --------------------------------------------------------
int __cdecl sub_804D378(int a1, int *a2)
{
  int v2; // ecx
  int v3; // edx
  int v4; // eax
  int v5; // eax
  int result; // eax
  unsigned __int8 *v7; // [esp+4h] [ebp-10h]
  int v8; // [esp+8h] [ebp-Ch]
  unsigned int v9; // [esp+Ch] [ebp-8h]
  int v10; // [esp+10h] [ebp-4h]

  v7 = *(unsigned __int8 **)a1;
  v3 = *(_DWORD *)(a1 + 4) - 1;
  v9 = v3 + *(_DWORD *)a1;
  v8 = *a2;
  v10 = a2[1];
  if ( dword_806B390 == 128 )
  {
    while ( (unsigned int)v7 < v9 )
    {
      v5 = v8;
      v3 = v8-- - 1;
      if ( !v5 )
        break;
      while ( (unsigned int)v7 < v9 && byte_806BA29[(unsigned __int8)sub_804AFB2(*v7)] )
        ++v7;
      while ( (unsigned int)v7 < v9 && (unsigned __int8)byte_806BA29[(unsigned __int8)sub_804AFB2(*v7)] ^ 1 )
        ++v7;
    }
  }
  else
  {
    while ( (unsigned int)v7 < v9 )
    {
      v4 = v8;
      v3 = v8-- - 1;
      if ( !v4 )
        break;
      while ( (unsigned int)v7 < v9 )
      {
        v3 = (char)*v7;
        if ( v3 == dword_806B390 )
          break;
        ++v7;
      }
      if ( (unsigned int)v7 < v9 )
        ++v7;
    }
  }
  if ( *((_BYTE *)a2 + 24) )
  {
    dword_806B27C = (int)&loc_804D4A7;
    sub_806190F(v2, v3);
    do
      ++v7;
    while ( (unsigned int)v7 < v9 && byte_806BA29[(unsigned __int8)sub_804AFB2(*v7)] );
  }
  result = v9;
  if ( (unsigned int)&v7[v10] <= v9 )
    result = (int)&v7[v10];
  return result;
}
// 806190F: using guessed type double __fastcall sub_806190F(_DWORD, _DWORD);
// 806B27C: using guessed type int dword_806B27C;
// 806B390: using guessed type int dword_806B390;

//----- (0804D4E6) --------------------------------------------------------
char *__cdecl sub_804D4E6(char **a1, int a2)
{
  int v2; // eax
  bool v3; // zf
  void *v4; // eax
  int v5; // edx
  int v6; // ecx
  int v7; // eax
  int v8; // eax
  char *v9; // eax
  int v11; // [esp+0h] [ebp-14h]
  char *v12; // [esp+4h] [ebp-10h]
  int v13; // [esp+8h] [ebp-Ch]
  unsigned int v14; // [esp+Ch] [ebp-8h]
  int v15; // [esp+10h] [ebp-4h]

  v12 = *a1;
  v14 = (unsigned int)&v12[(_DWORD)(a1[1] - 1)];
  v13 = *(_DWORD *)(a2 + 8);
  v2 = *(_DWORD *)(a2 + 12);
  v15 = v2;
  v3 = v2 == 0;
  v4 = &loc_804D546;
  if ( !v3 )
    v4 = &loc_804D54A;
  dword_806B2D8 = (int)v4;
  sub_8061693();
  ++v13;
  if ( dword_806B390 == 128 )
  {
    while ( (unsigned int)v12 < v14 )
    {
      v8 = v13--;
      if ( !v8 )
        break;
      while ( (unsigned int)v12 < v14 )
      {
        v11 = *v12;
        if ( !byte_806BA29[(unsigned __int8)sub_804AFB2(v11)] )
          break;
        ++v12;
      }
      while ( (unsigned int)v12 < v14 )
      {
        v11 = *v12;
        if ( !((unsigned __int8)byte_806BA29[(unsigned __int8)sub_804AFB2(v11)] ^ 1) )
          break;
        ++v12;
      }
    }
  }
  else
  {
    dword_806B2A4 = (int)&loc_804D5A5;
    sub_8061819(v6, v5);
    do
    {
      while ( (unsigned int)v12 < v14 && *v12 != dword_806B390 )
        ++v12;
      if ( (unsigned int)v12 < v14 && (v13 || v15) )
        ++v12;
      if ( (unsigned int)v12 >= v14 )
        break;
      v7 = v13--;
    }
    while ( v7 );
  }
  if ( v15 )
  {
    if ( *(_BYTE *)(a2 + 25) )
    {
      while ( (unsigned int)v12 < v14 )
      {
        v11 = *v12;
        if ( !byte_806BA29[(unsigned __int8)sub_804AFB2(v11)] )
          break;
        ++v12;
      }
    }
    v9 = (char *)v14;
    if ( (unsigned int)&v12[v15] <= v14 )
      v9 = &v12[v15];
    v12 = v9;
  }
  return v12;
}
// 8061693: using guessed type int sub_8061693(void);
// 8061819: using guessed type int __fastcall sub_8061819(_DWORD, _DWORD);
// 806B2A4: using guessed type int dword_806B2A4;
// 806B2D8: using guessed type int dword_806B2D8;
// 806B390: using guessed type int dword_806B390;

//----- (0804D68A) --------------------------------------------------------
#error "804D6AE: call analysis failed (funcsize=15)"

//----- (0804D6B3) --------------------------------------------------------
#error "804DA20: positive sp value has been found (funcsize=213)"

//----- (0804DB8C) --------------------------------------------------------
int __cdecl sub_804DB8C(char **a1)
{
  int v1; // edx
  int v2; // eax
  void *v3; // eax
  char *v4; // eax
  int result; // eax
  char *v6; // eax
  int v7; // [esp-4h] [ebp-14h]
  unsigned __int8 v8; // [esp+9h] [ebp-7h]
  bool v9; // [esp+Ah] [ebp-6h]
  unsigned __int8 v10; // [esp+Bh] [ebp-5h]
  char *v11; // [esp+Ch] [ebp-4h]

  v11 = *a1;
  v8 = 0;
  v9 = 0;
  while ( 1 )
  {
    v4 = v11++;
    v10 = *v4;
    if ( (unsigned int)v10 - 48 > 9 )
      break;
    if ( v8 < v10 )
      v8 = v10;
    v1 = *v11;
    v2 = dword_806BA0D;
    LOBYTE(v2) = v1 == dword_806BA0D;
    v9 = v1 == dword_806BA0D;
    v7 = v2;
    v3 = &loc_804DBF9;
    if ( v1 != dword_806BA0D )
      v3 = &loc_804DBFD;
    dword_806B2D8 = (int)v3;
    sub_8061693();
    ++v11;
  }
  if ( v9 )
  {
    *a1 = v11 - 2;
    result = v8;
  }
  else
  {
    if ( v10 == dword_806BA09 )
    {
      while ( 1 )
      {
        v6 = v11++;
        v10 = *v6;
        if ( (unsigned int)v10 - 48 > 9 )
          break;
        if ( v8 < v10 )
          v8 = v10;
      }
    }
    *a1 = v11 - 1;
    result = v8;
  }
  return result;
}
// 8061693: using guessed type int sub_8061693(void);
// 806B2D8: using guessed type int dword_806B2D8;
// 806BA09: using guessed type int dword_806BA09;
// 806BA0D: using guessed type int dword_806BA0D;

//----- (0804DC7A) --------------------------------------------------------
#error "804DCF1: call analysis failed (funcsize=45)"

//----- (0804DD07) --------------------------------------------------------
int __usercall sub_804DD07@<eax>(int a1@<ebx>, int a2, unsigned __int8 *a3)
{
  int v3; // eax
  bool v4; // zf
  void *v5; // eax
  int v6; // eax
  void *v7; // eax
  int v8; // ebx
  int v9; // eax
  int v11; // [esp-8h] [ebp-30h]
  int v12; // [esp-4h] [ebp-2Ch]
  int v13; // [esp+Ch] [ebp-1Ch]
  int v14; // [esp+1Ch] [ebp-Ch]
  unsigned __int8 *v15; // [esp+30h] [ebp+8h]

  dword_806B2C4 = (int)&loc_804DD29;
  sub_8061709();
  v15 = (unsigned __int8 *)(a2 + 1);
  v3 = (unsigned __int8)byte_806BA29[(unsigned __int8)sub_804AFB2(*v15)];
  v4 = (_BYTE)v3 == 0;
  v12 = v3;
  v11 = a1;
  v5 = &loc_804DD71;
  if ( !v4 )
    v5 = &loc_804DD25;
  dword_806B2C4 = (int)v5;
  sub_8061709();
  v6 = (unsigned __int8)byte_806BA29[(unsigned __int8)sub_804AFB2(*a3)];
  v4 = (_BYTE)v6 == 0;
  v12 = v6;
  v7 = &loc_804DDBF;
  if ( !v4 )
    v7 = &loc_804DD73;
  dword_806B254 = (int)v7;
  sub_80619F1();
  v8 = sub_804DC7A(v15);
  v9 = sub_804DC7A(a3);
  v14 = v8 - v9;
  if ( v8 != v9 )
    return v14;
  v13 = dword_806BA0D;
  return sub_805DB98((int)v15, (int)a3, dword_806BA09);
}
// 804DC7A: using guessed type _DWORD __cdecl sub_804DC7A(_DWORD);
// 80619F1: using guessed type int sub_80619F1(void);
// 806B254: using guessed type int dword_806B254;
// 806B2C4: using guessed type int dword_806B2C4;
// 806BA09: using guessed type int dword_806BA09;
// 806BA0D: using guessed type int dword_806BA0D;

//----- (0804DE14) --------------------------------------------------------
int __cdecl sub_804DE14(unsigned __int8 *a1, unsigned __int8 *a2)
{
  while ( byte_806BA29[(unsigned __int8)sub_804AFB2(*a1)] )
    ++a1;
  dword_806B2C4 = (int)&loc_804DE5A;
  sub_8061709();
  do
    ++a2;
  while ( byte_806BA29[(unsigned __int8)sub_804AFB2(*a2)] );
  return sub_805DB98((int)a1, (int)a2, dword_806BA09);
}
// 806B2C4: using guessed type int dword_806B2C4;
// 806BA09: using guessed type int dword_806BA09;
// 806BA0D: using guessed type int dword_806BA0D;

//----- (0804DEA0) --------------------------------------------------------
int __cdecl sub_804DEA0(int a1, int a2)
{
  _TBYTE s; // [esp+10h] [ebp-28h]
  _TBYTE s2; // [esp+20h] [ebp-18h]

  memset(&s, 0, 0xCu);
  *(long double *)&s = strtold(a1, 0);
  memset(&s2, 0, 0xCu);
  *(long double *)&s2 = strtold(a2, 0);
  return memcmp(&s, &s2, 0xCu);
}
// 80498F0: using guessed type double __cdecl strtold(_DWORD, _DWORD);

//----- (0804DF24) --------------------------------------------------------
signed int __cdecl sub_804DF24(int a1, int a2)
{
  signed int result; // eax
  int v7; // [esp+0h] [ebp-48h]
  int v8; // [esp+4h] [ebp-44h]
  int v9; // [esp+8h] [ebp-40h]
  int v10; // [esp+Ch] [ebp-3Ch]
  int v11; // [esp+10h] [ebp-38h]
  int v12; // [esp+14h] [ebp-34h]
  int v13; // [esp+18h] [ebp-30h]
  int v14; // [esp+1Ch] [ebp-2Ch]
  long double v15; // [esp+20h] [ebp-28h]
  long double v16; // [esp+30h] [ebp-18h]

  v15 = strtold(a1, &v13);
  v16 = strtold(a2, &v14);
  if ( a1 == v13 )
  {
    if ( a2 == v14 )
    {
      dword_806B234 = (int)&loc_804DF86;
      sub_8061ADD(v7, v8, v9, v10, v11, v12, v13, v14, LODWORD(v15));
    }
    result = -1;
  }
  else
  {
    _OF = __OFSUB__(a2, v14);
    _SF = a2 - v14 < 0;
    if ( a2 == v14 )
    {
      result = 1;
    }
    else if ( v16 <= v15 )
    {
      if ( v15 <= v16 )
      {
        _CF = v16 < v15;
        _ZF = v16 == v15;
        if ( v16 == v15 )
        {
          __asm { pushfw }
          result = 0;
          __asm { popfw }
        }
        else
        {
          result = -1;
        }
      }
      else
      {
        result = 1;
      }
    }
    else
    {
      result = -1;
    }
  }
  return result;
}
// 80498F0: using guessed type double __cdecl strtold(_DWORD, _DWORD);
// 806190F: using guessed type double __fastcall sub_806190F(_DWORD, _DWORD);
// 8061ADD: using guessed type int __stdcall sub_8061ADD(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806B234: using guessed type int dword_806B234;
// 806B27C: using guessed type int dword_806B27C;

//----- (0804E054) --------------------------------------------------------
int __cdecl sub_804E054(unsigned __int8 *a1, unsigned __int8 **a2)
{
  int result; // eax
  unsigned __int8 v3; // al
  unsigned __int8 v4; // bl
  unsigned __int8 v5; // al
  unsigned __int8 v6; // bl
  unsigned int v11; // [esp+10h] [ebp-18h]
  unsigned int v12; // [esp+14h] [ebp-14h]
  unsigned __int8 *v13; // [esp+18h] [ebp-10h]
  unsigned __int8 *i; // [esp+1Ch] [ebp-Ch]
  unsigned int v15; // [esp+20h] [ebp-8h]

  v11 = 0;
  v12 = 12;
  while ( byte_806BA29[(unsigned __int8)sub_804AFB2(*a1)] )
    ++a1;
  while ( 2 )
  {
    v15 = (v11 + v12) >> 1;
    v13 = a1;
    for ( i = (unsigned __int8 *)(&off_806B32C)[2 * v15]; ; ++i )
    {
      if ( !*i )
      {
        if ( a2 )
          *a2 = v13;
        return dword_806B330[2 * v15];
      }
      v3 = sub_804AFB2(*v13);
      v4 = sub_804AFB2(byte_806BD29[v3]);
      if ( v4 < (unsigned __int8)sub_804AFB2(*i) )
      {
        v12 = (v11 + v12) >> 1;
        goto LABEL_14;
      }
      v5 = sub_804AFB2(*v13);
      v6 = sub_804AFB2(byte_806BD29[v5]);
      if ( v6 > (unsigned __int8)sub_804AFB2(*i) )
        break;
      ++v13;
    }
    v11 = v15 + 1;
LABEL_14:
    _CF = v11 < v12;
    _OF = __OFSUB__(v11, v12);
    _ZF = v11 == v12;
    _SF = (signed int)(v11 - v12) < 0;
    if ( v11 < v12 )
      continue;
    break;
  }
  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}
// 806B32C: using guessed type char *off_806B32C;
// 806B330: using guessed type int dword_806B330[];

//----- (0804E187) --------------------------------------------------------
void __cdecl __noreturn sub_804E187(char *a1)
{
  bool v1; // zf
  int v2; // edx
  int v3; // ecx
  int (__cdecl *v4)(size_t, size_t); // eax
  char *v5; // eax
  int v6; // [esp+0h] [ebp-38h]
  int v7; // [esp+4h] [ebp-34h]

  v1 = sub_805BEBA((int)a1, 0x10u) == 0;
  v4 = (int (__cdecl *)(size_t, size_t))&loc_804E1E3;
  if ( !v1 )
    v4 = sub_804E1FE;
  dword_806B220 = (int)v4;
  sub_8061B4D(v3, v2, v6, v7);
  v5 = gettext("open failed");
  sub_804B363((int)v5, a1);
}
// 806B220: using guessed type int dword_806B220;

//----- (0804E1FE) --------------------------------------------------------
#error "804E27B: positive sp value has been found (funcsize=0)"

//----- (0804E27C) --------------------------------------------------------
size_t __cdecl sub_804E27C(char *dest, char *src, size_t n)
{
  char *v3; // ebx
  int *v4; // eax
  char *v5; // eax
  void *v6; // ebx
  char *v7; // eax
  size_t v9; // [esp+1Ch] [ebp-Ch]

  *__errno_location() = 0;
  v9 = strxfrm(dest, src, n);
  if ( *__errno_location() )
  {
    v3 = gettext("string transformation failed");
    v4 = __errno_location();
    error(0, *v4, v3);
    v5 = gettext("set LC_ALL='C' to work around the problem");
    error(0, 0, v5);
    v6 = sub_805B721(0, 8, (int)src);
    v7 = gettext("the untransformed string was %s");
    error(2, 0, v7, v6);
  }
  return v9;
}

//----- (0804E354) --------------------------------------------------------
void __cdecl __noreturn sub_804E354(int a1, size_t a2, int a3, size_t a4)
{
  size_t v4; // eax
  size_t v9; // eax
  size_t v18; // edx
  char *v23; // eax
  size_t v24; // eax
  size_t v25; // eax
  size_t v26; // eax
  size_t v27; // eax
  size_t v28; // eax
  unsigned int v29; // et1
  int (*v30)(); // eax
  int v31; // [esp-8h] [ebp-1170h]
  int v32; // [esp-4h] [ebp-116Ch]
  int v33; // [esp+0h] [ebp-1168h]
  int v34; // [esp+4h] [ebp-1164h]
  int v35; // [esp+8h] [ebp-1160h]
  int v36; // [esp+Ch] [ebp-115Ch]
  int v37; // [esp+10h] [ebp-1158h]
  int v38; // [esp+14h] [ebp-1154h]
  char *s; // [esp+18h] [ebp-1150h]
  char *src; // [esp+1Ch] [ebp-114Ch]
  int v41; // [esp+20h] [ebp-1148h]
  bool v42; // [esp+2Bh] [ebp-113Dh]
  int v43; // [esp+2Ch] [ebp-113Ch]
  char *dest; // [esp+30h] [ebp-1138h]
  size_t size; // [esp+34h] [ebp-1134h]
  void *ptr; // [esp+38h] [ebp-1130h]
  int v47; // [esp+3Ch] [ebp-112Ch]
  char *v48; // [esp+40h] [ebp-1128h]
  char *v49; // [esp+44h] [ebp-1124h]
  size_t v50; // [esp+48h] [ebp-1120h]
  size_t n; // [esp+4Ch] [ebp-111Ch]
  size_t v52; // [esp+50h] [ebp-1118h]
  char s1; // [esp+54h] [ebp-1114h]
  int v54; // [esp+64h] [ebp-1104h]
  int v55; // [esp+74h] [ebp-10F4h]
  char v56; // [esp+110h] [ebp-1058h]
  char v57; // [esp+1ACh] [ebp-FBCh]
  unsigned int v58; // [esp+114Ch] [ebp-1Ch]

  src = (char *)a1;
  s = (char *)a3;
  v58 = __readgsdword(0x14u);
  v43 = 0;
  dest = (char *)(&v33 - 1007);
  size = 4000;
  ptr = 0;
  qmemcpy(&v33 - 1046, &unk_806BEE9, 0x9Cu);
  qmemcpy(&v55, &v56, 0x9Cu);
  if ( byte_806BA11 )
  {
    v48 = &src[a2];
    v49 = &s[a4];
    while ( 1 )
    {
      v50 = 3 * (a4 + a2) + 2;
      if ( size < v50 )
      {
        v4 = v50;
        if ( 3 * size >> 1 >= v50 )
          v4 = 3 * size >> 1;
        size = v4;
        free(ptr);
        ptr = malloc(size);
        dest = (char *)ptr;
        if ( !ptr )
        {
          dest = &v57;
          size = 4000;
        }
      }
      _CF = src < v48;
      _OF = __OFSUB__(src, v48);
      _ZF = src == v48;
      _SF = src - v48 < 0;
      if ( src >= v48 )
      {
        __asm { pushfw }
        v9 = 0;
        __asm { popfw }
      }
      else
      {
        v9 = sub_804E27C(dest, src, size) + 1;
      }
      n = v9;
      v42 = v9 <= size;
      _CF = s < v49;
      _OF = __OFSUB__(s, v49);
      _ZF = s == v49;
      _SF = s - v49 < 0;
      if ( s >= v49 )
      {
        __asm { pushfw }
        v24 = 0;
        __asm { popfw }
      }
      else
      {
        _CF = 0;
        _OF = 0;
        _ZF = v42 == 0;
        _SF = v42 < 0;
        if ( v42 )
        {
          v18 = size - n;
        }
        else
        {
          __asm { pushfw }
          v18 = 0;
          __asm { popfw }
        }
        _CF = 0;
        _OF = 0;
        _ZF = v42 == 0;
        _SF = v42 < 0;
        if ( v42 )
        {
          v23 = &dest[n];
        }
        else
        {
          __asm { pushfw }
          v23 = 0;
          __asm { popfw }
        }
        v24 = sub_804E27C(v23, s, v18) + 1;
      }
      v52 = v24;
      if ( v42 != 1 || n + v52 > size )
      {
        size = n + v52;
        if ( n + v52 <= 0x55555554 )
          size = 3 * size >> 1;
        free(ptr);
        ptr = sub_805E4E9(size);
        dest = (char *)ptr;
        if ( src < v48 )
          strxfrm(dest, src, n);
        if ( s < v49 )
          strxfrm(&dest[n], s, v52);
      }
      if ( src < v48 )
      {
        v25 = strlen(src);
        src += v25 + 1;
      }
      if ( s < v49 )
      {
        v26 = strlen(s);
        s += v26 + 1;
      }
      if ( src >= v48 && s >= v49 )
        break;
      sub_8055F4F(dest, n, (int)&v55);
      sub_8055F4F(&dest[n], v52, (int)&v56);
      if ( !v43 )
      {
        v27 = n;
        if ( v52 <= n )
          v27 = v52;
        v43 = memcmp(dest, &dest[n], v27);
        if ( !v43 )
          v43 = (n > v52) - (n < v52);
      }
    }
    a2 = n;
    src = dest;
    a4 = v52;
    s = &dest[n];
  }
  sub_8055F4F(src, a2, (int)&v55);
  sub_8055C4A(&v55, &s1);
  sub_8055F4F(s, a4, (int)&v56);
  sub_8055C4A((int *)&v56, &v54);
  v47 = memcmp(&s1, &v54, 0x10u);
  if ( !v47 )
  {
    if ( !v43 )
    {
      v28 = a2;
      if ( a4 <= a2 )
        v28 = a4;
      v43 = memcmp(src, s, v28);
      if ( !v43 )
        v43 = (a2 > a4) - (a2 < a4);
    }
    v47 = v43;
  }
  free(ptr);
  v29 = __readgsdword(0x14u);
  v32 = v47;
  v31 = v29 ^ v58;
  v30 = (int (*)())&loc_804E992;
  if ( v29 == v58 )
    v30 = sub_804E997;
  dword_806B234 = (int)v30;
  sub_8061ADD(v33, v34, v35, v36, v37, v38, s, src, v41);
}
// 804E997: using guessed type int sub_804E997();
// 8061ADD: using guessed type int __stdcall sub_8061ADD(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806B234: using guessed type int dword_806B234;
// 806BA11: using guessed type char byte_806BA11;

//----- (0804E997) --------------------------------------------------------
#error "804E99D: positive sp value has been found (funcsize=0)"

//----- (0804E9A2) --------------------------------------------------------
int __cdecl sub_804E9A2(char *a1, unsigned int a2)
{
  char *v2; // eax
  int v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_8059422(a1, a2 - (_DWORD)a1, 0);
  dword_806B254 = (int)&loc_804EA0A;
  sub_80619F1();
  do
  {
    v2 = a1++;
    v4 += *v2 == 9;
  }
  while ( (unsigned int)a1 < a2 );
  return v4;
}
// 80619F1: using guessed type int sub_80619F1(void);
// 806B254: using guessed type int dword_806B254;

//----- (0804EA17) --------------------------------------------------------
int __cdecl sub_804EA17(int a1, int a2)
{
  int v2; // eax
  char *v3; // eax

  while ( 1 )
  {
    v2 = a1--;
    if ( !v2 )
      break;
    putchar_unlocked(32);
  }
  if ( !a2 )
  {
    v3 = gettext("^ no match for key\n");
    printf(v3);
    dword_806B2D8 = (int)&locret_804EA8B;
    sub_8061693();
  }
  do
  {
    putchar_unlocked(95);
    --a2;
  }
  while ( a2 );
  return putchar_unlocked(10);
}
// 8061693: using guessed type int sub_8061693(void);
// 806B2D8: using guessed type int dword_806B2D8;

//----- (0804EA8D) --------------------------------------------------------
int __cdecl sub_804EA8D(_BYTE *a1)
{
  void *v1; // eax
  char v2; // al
  char v7; // al

  v1 = &loc_804EAC4;
  if ( a1[26] )
    v1 = &loc_804EADA;
  dword_806B2C4 = (int)v1;
  sub_8061709();
  if ( a1[28] || (v2 = a1[29], _CF = 0, _OF = 0, _ZF = v2 == 0, _SF = v2 < 0, v2) )
  {
    v7 = 1;
  }
  else
  {
    __asm { pushfw }
    v7 = 0;
    __asm { popfw }
  }
  return v7 & 1;
}
// 806B2C4: using guessed type int dword_806B2C4;

//----- (0804EAEC) --------------------------------------------------------
int __cdecl sub_804EAEC(int a1, int a2)
{
  signed int v6; // eax
  void *v7; // eax
  char *v8; // edx
  int v9; // ecx
  int v11; // [esp+0h] [ebp-48h]
  int v12; // [esp+4h] [ebp-44h]
  int v13; // [esp+8h] [ebp-40h]
  int v14; // [esp+Ch] [ebp-3Ch]
  int v15; // [esp+10h] [ebp-38h]
  char *v16; // [esp+14h] [ebp-34h]
  unsigned __int8 *v17; // [esp+18h] [ebp-30h]
  unsigned __int8 *v18; // [esp+1Ch] [ebp-2Ch]
  char *v19; // [esp+20h] [ebp-28h]
  char *v20; // [esp+24h] [ebp-24h]
  int v21; // [esp+28h] [ebp-20h]
  int v22; // [esp+2Ch] [ebp-1Ch]
  long double v23; // [esp+30h] [ebp-18h]

  v20 = *(char **)a1;
  v18 = (unsigned __int8 *)v20;
  v19 = &v20[*(_DWORD *)(a1 + 4) - 1];
  if ( a2 )
  {
    if ( *(_DWORD *)a2 != -1 )
      v18 = (unsigned __int8 *)sub_804D378(a1, (int *)a2);
    if ( *(_DWORD *)(a2 + 8) != -1 )
      v19 = sub_804D4E6((char **)a1, a2);
    if ( *(_BYTE *)(a2 + 24) && *(_DWORD *)a2 == -1 || *(_BYTE *)(a2 + 30) || (unsigned __int8)sub_804EA8D((_BYTE *)a2) )
    {
      BYTE1(v15) = *v19;
      *v19 = 0;
      while ( byte_806BA29[(unsigned __int8)sub_804AFB2(*v18)] )
        ++v18;
      v16 = (char *)v18;
      if ( v19 >= (char *)v18 )
      {
        if ( *(_BYTE *)(a2 + 30) )
        {
          sub_804E054(v18, (unsigned __int8 **)&v16);
        }
        else if ( *(_BYTE *)(a2 + 28) )
        {
          v23 = strtold(v18, &v16);
        }
        else if ( *(_BYTE *)(a2 + 26) || *(_BYTE *)(a2 + 29) )
        {
          _CF = v18 < (unsigned __int8 *)v19;
          _OF = __OFSUB__(v18, v19);
          _ZF = v18 == (unsigned __int8 *)v19;
          _SF = v18 - (unsigned __int8 *)v19 < 0;
          if ( v18 >= (unsigned __int8 *)v19
            || (_CF = *v18 < 0x2Du, _OF = __OFSUB__(*v18, 45), _ZF = *v18 == 45, _SF = (char)(*v18 - 45) < 0, *v18 != 45) )
          {
            __asm { pushfw }
            v6 = 0;
            __asm { popfw }
          }
          else
          {
            v6 = 1;
          }
          v17 = &v18[v6];
          BYTE2(v15) = sub_804DB8C((char **)&v17);
          if ( BYTE2(v15) > 0x2Fu )
          {
            HIBYTE(v15) = *v17;
            v7 = &loc_804ECB8;
            if ( !*(_BYTE *)(a2 + 29) )
              v7 = &loc_804ECE3;
            dword_806B234 = (int)v7;
            sub_8061ADD(v11, v12, v13, v14, v15, v16, v17, v18, v19);
            if ( byte_8063470[HIBYTE(v15)] )
            {
              dword_806B27C = (int)&loc_804ECE9;
              sub_806190F(v9, v8);
            }
            v16 = v8;
          }
        }
        else
        {
          v16 = v19;
        }
      }
      else
      {
        v16 = v19;
      }
      *v19 = BYTE1(v15);
      v19 = v16;
    }
  }
  v21 = sub_804E9A2(v20, (unsigned int)v18);
  v22 = sub_804E9A2((char *)v18, (unsigned int)v19);
  return sub_804EA17(v21, v22);
}
// 80498F0: using guessed type double __cdecl strtold(_DWORD, _DWORD);
// 806190F: using guessed type double __fastcall sub_806190F(_DWORD, _DWORD);
// 8061ADD: using guessed type int __stdcall sub_8061ADD(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806B234: using guessed type int dword_806B234;
// 806B27C: using guessed type int dword_806B27C;

//----- (0804ED45) --------------------------------------------------------
int __cdecl sub_804ED45(int a1)
{
  int result; // eax
  void *v2; // eax
  int v3; // [esp+0h] [ebp-28h]
  int v4; // [esp+4h] [ebp-24h]
  int v5; // [esp+8h] [ebp-20h]
  int v6; // [esp+Ch] [ebp-1Ch]
  int v7; // [esp+10h] [ebp-18h]
  int v8; // [esp+14h] [ebp-14h]
  int v9; // [esp+18h] [ebp-10h]
  int v10; // [esp+1Ch] [ebp-Ch]
  int v11; // [esp+20h] [ebp-8h]

  v10 = dword_806BE3D;
  while ( 1 )
  {
    result = sub_804EAEC(a1, v10);
    if ( !v10 )
      break;
    v10 = *(_DWORD *)(v10 + 36);
    if ( !v10 )
    {
      v2 = &loc_804EDA1;
      if ( byte_806BE3B == 1 )
        v2 = &locret_804EDAF;
      dword_806B234 = (int)v2;
      sub_8061ADD(v3, v4, v5, v6, v7, v8, v9, 0, v11);
      result = (unsigned __int8)byte_806BE3A ^ 1;
      if ( byte_806BE3A == 1 )
        break;
    }
  }
  return result;
}
// 8061ADD: using guessed type int __stdcall sub_8061ADD(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806B234: using guessed type int dword_806B234;
// 806BE3A: using guessed type char byte_806BE3A;
// 806BE3B: using guessed type char byte_806BE3B;
// 806BE3D: using guessed type int dword_806BE3D;

//----- (0804EDB1) --------------------------------------------------------
int __cdecl sub_804EDB1(int a1)
{
  int v1; // eax
  int v4; // eax
  char v5; // al
  void *v6; // eax
  char v7; // al

  v1 = *(_DWORD *)(a1 + 16);
  _ZF = v1 == 0;
  _SF = v1 < 0;
  if ( v1 )
    goto LABEL_15;
  v4 = *(_DWORD *)(a1 + 20);
  _ZF = v4 == 0;
  _SF = v4 < 0;
  if ( v4 )
    goto LABEL_15;
  _ZF = *(_BYTE *)(a1 + 24) == 1;
  _SF = ((*(_BYTE *)(a1 + 24) ^ 1) & 0x80u) != 0;
  if ( *(_BYTE *)(a1 + 24) == 1 )
    goto LABEL_15;
  _ZF = *(_BYTE *)(a1 + 25) == 1;
  _SF = ((*(_BYTE *)(a1 + 25) ^ 1) & 0x80u) != 0;
  if ( *(_BYTE *)(a1 + 25) == 1
    || (v5 = sub_804EA8D((_BYTE *)a1) ^ 1, _ZF = v5 == 0, _SF = v5 < 0, !v5)
    || (_ZF = *(_BYTE *)(a1 + 30) == 1, _SF = ((*(_BYTE *)(a1 + 30) ^ 1) & 0x80u) != 0, *(_BYTE *)(a1 + 30) == 1)
    || (_ZF = *(_BYTE *)(a1 + 32) == 1, _SF = ((*(_BYTE *)(a1 + 32) ^ 1) & 0x80u) != 0, *(_BYTE *)(a1 + 32) == 1) )
  {
LABEL_15:
    __asm { pushfw }
    v7 = 0;
    __asm { popfw }
  }
  else
  {
    v6 = &loc_804EE54;
    if ( *(_BYTE *)(a1 + 27) == 1 )
      v6 = &loc_804EE5B;
    dword_806B2C4 = (int)v6;
    sub_8061709();
    v7 = 1;
  }
  return v7 & 1;
}
// 806B2C4: using guessed type int dword_806B2C4;

//----- (0804EE66) --------------------------------------------------------
_BYTE *__usercall sub_804EE66@<eax>(int a1@<edx>, int a2@<ecx>, int a3, _BYTE *a4)
{
  _BYTE *v4; // eax
  _BYTE *v5; // eax
  _BYTE *v6; // eax
  _BYTE *v7; // eax
  _BYTE *v8; // eax
  _BYTE *v9; // eax
  _BYTE *v10; // eax
  _BYTE *v11; // eax
  void *v12; // eax
  _BYTE *v13; // eax
  _BYTE *v14; // eax
  _BYTE *v15; // eax
  _BYTE *result; // eax
  _BYTE *v17; // [esp+Ch] [ebp+Ch]

  if ( *(_BYTE *)(a3 + 24) || *(_BYTE *)(a3 + 25) )
  {
    v4 = a4;
    a1 = (int)(a4++ + 1);
    *v4 = 98;
  }
  if ( *(_UNKNOWN **)(a3 + 16) == &unk_806BC29 )
  {
    v5 = a4;
    a1 = (int)(a4++ + 1);
    *v5 = 100;
  }
  if ( *(_DWORD *)(a3 + 20) )
  {
    v6 = a4;
    a1 = (int)(a4++ + 1);
    *v6 = 102;
  }
  if ( *(_BYTE *)(a3 + 28) )
  {
    v7 = a4;
    a1 = (int)(a4++ + 1);
    *v7 = 103;
  }
  if ( *(_BYTE *)(a3 + 29) )
  {
    v8 = a4;
    a1 = (int)(a4++ + 1);
    *v8 = 104;
  }
  if ( *(_UNKNOWN **)(a3 + 16) == &unk_806BB29 )
  {
    v9 = a4;
    a1 = (int)(a4++ + 1);
    *v9 = 105;
  }
  if ( *(_BYTE *)(a3 + 30) )
  {
    v10 = a4;
    a1 = (int)(a4++ + 1);
    *v10 = 77;
  }
  if ( *(_BYTE *)(a3 + 26) )
  {
    v11 = a4;
    a1 = (int)(a4++ + 1);
    *v11 = 110;
  }
  v12 = &loc_804EF63;
  if ( !*(_BYTE *)(a3 + 27) )
    v12 = &loc_804EF6F;
  dword_806B2A4 = (int)v12;
  sub_8061819(a2, a1);
  v13 = a4;
  v17 = a4 + 1;
  *v13 = 82;
  if ( *(_BYTE *)(a3 + 31) )
  {
    v14 = v17++;
    *v14 = 114;
  }
  if ( *(_BYTE *)(a3 + 32) )
  {
    v15 = v17++;
    *v15 = 86;
  }
  result = v17;
  *v17 = 0;
  return result;
}
// 8061819: using guessed type int __fastcall sub_8061819(_DWORD, _DWORD);
// 806B2A4: using guessed type int dword_806B2A4;

//----- (0804EFA5) --------------------------------------------------------
#error "804F105: call analysis failed (funcsize=519)"

//----- (0804F8AC) --------------------------------------------------------
int __usercall sub_804F8AC@<eax>(char *a1@<ebx>, int a2, int a3)
{
  char *v3; // eax
  char *v4; // eax
  void *v5; // eax
  void *v6; // eax
  unsigned __int8 v7; // al
  size_t v8; // eax
  unsigned __int8 v9; // al
  char v10; // al
  unsigned __int8 v11; // al
  size_t v12; // eax
  void *v13; // eax
  int v14; // edx
  int v15; // eax
  int v16; // ecx
  int v17; // ebx
  unsigned __int8 v18; // al
  int v19; // ecx
  int v20; // edx
  void *v21; // eax
  unsigned __int8 v22; // al
  unsigned __int8 v23; // al
  int v24; // ebx
  unsigned __int8 v25; // al
  unsigned __int8 v26; // al
  unsigned __int8 v27; // al
  int v28; // ebx
  char *v29; // eax
  unsigned __int8 v30; // al
  int v31; // ebx
  char *v32; // eax
  unsigned __int8 v33; // al
  size_t v34; // eax
  signed int v35; // eax
  int result; // eax
  int v41; // edx
  int v42; // ecx
  void *v43; // eax
  void *v44; // eax
  char *v45; // [esp-20h] [ebp-1020h]
  int v46; // [esp-18h] [ebp-1018h]
  int v47; // [esp-14h] [ebp-1014h]
  int v48; // [esp-10h] [ebp-1010h]
  int v49; // [esp-Ch] [ebp-100Ch]
  int v50; // [esp-8h] [ebp-1008h]
  int v51; // [esp-4h] [ebp-1004h]
  int v52; // [esp+0h] [ebp-1000h]
  int v53; // [esp+4h] [ebp-FFCh]
  int v54; // [esp+8h] [ebp-FF8h]
  int v55; // [esp+Ch] [ebp-FF4h]
  int v56; // [esp+10h] [ebp-FF0h]
  void *s1; // [esp+14h] [ebp-FECh]
  void *s2; // [esp+18h] [ebp-FE8h]
  char *v59; // [esp+1Ch] [ebp-FE4h]
  char *v60; // [esp+20h] [ebp-FE0h]
  int v61; // [esp+24h] [ebp-FDCh]
  char *v62; // [esp+28h] [ebp-FD8h]
  char *v63; // [esp+2Ch] [ebp-FD4h]
  size_t v64; // [esp+30h] [ebp-FD0h]
  size_t v65; // [esp+34h] [ebp-FCCh]
  void *ptr; // [esp+38h] [ebp-FC8h]
  size_t v67; // [esp+3Ch] [ebp-FC4h]
  int v68; // [esp+40h] [ebp-FC0h]
  int v69; // [esp+44h] [ebp-FBCh]
  size_t v70; // [esp+48h] [ebp-FB8h]
  size_t n; // [esp+4Ch] [ebp-FB4h]
  size_t size; // [esp+50h] [ebp-FB0h]
  char v73; // [esp+54h] [ebp-FACh]
  unsigned int v74; // [esp+FF4h] [ebp-Ch]

  v53 = a2;
  v52 = a3;
  v74 = __readgsdword(0x14u);
  v56 = dword_806BE3D;
  s1 = *(void **)(a2 + 8);
  s2 = *(void **)(a3 + 8);
  v59 = *(char **)(a2 + 12);
  v60 = *(char **)(a3 + 12);
  while ( 1 )
  {
    v68 = *(_DWORD *)(v56 + 20);
    v69 = *(_DWORD *)(v56 + 16);
    v3 = (char *)s1;
    if ( v59 >= s1 )
      v3 = v59;
    v59 = v3;
    v4 = (char *)s2;
    if ( v60 >= s2 )
      v4 = v60;
    v60 = v4;
    v70 = v59 - (_BYTE *)s1;
    n = v4 - (_BYTE *)s2;
    if ( byte_806BA11
      || (unsigned __int8)sub_804EA8D((_BYTE *)v56)
      || *(_BYTE *)(v56 + 30)
      || *(_BYTE *)(v56 + 27)
      || *(_BYTE *)(v56 + 32) )
    {
      v5 = &loc_804FA23;
      if ( v69 )
        v5 = &loc_804FA45;
      dword_806B290 = (int)v5;
      sub_80618A3();
      v6 = &loc_804FA45;
      if ( !v68 )
        v6 = &loc_804FCBC;
      dword_806B268 = (int)v6;
      sub_806197F(v46, v47, v48, v49, v50, v51, v52);
      size = v70 + n + 2;
      if ( size > 0xFA0 )
      {
        ptr = sub_805E4E9(size);
        v62 = (char *)ptr;
      }
      else
      {
        v62 = &v73;
        ptr = 0;
      }
      v63 = &v62[v70 + 1];
      v67 = 0;
      v64 = 0;
      while ( v67 < v70 )
      {
        if ( !v69 || (v46 = *((char *)s1 + v67), v7 = sub_804AFB2(v46), *(_BYTE *)(v7 + v69) ^ 1) )
        {
          v8 = v64++;
          a1 = &v62[v8];
          if ( v68 )
          {
            v46 = *((char *)s1 + v67);
            v9 = sub_804AFB2(v46);
            v10 = *(_BYTE *)(v9 + v68);
          }
          else
          {
            v10 = *((_BYTE *)s1 + v67);
          }
          *a1 = v10;
        }
        ++v67;
      }
      v62[v64] = 0;
      v67 = 0;
      v65 = 0;
      while ( v67 < n )
      {
        if ( !v69 || (v46 = *((char *)s2 + v67), v11 = sub_804AFB2(v46), *(_BYTE *)(v11 + v69) ^ 1) )
        {
          v12 = v65++;
          v45 = &v63[v12];
          v13 = &loc_804FC39;
          if ( !v68 )
            v13 = &loc_804FC7A;
          dword_806B2C4 = (int)v13;
          a1 = v45;
          sub_8061709();
          v46 = *((char *)s2 + v67);
          v14 = (unsigned __int8)sub_804AFB2(v46);
          v15 = *(unsigned __int8 *)(v14 + v68);
          dword_806B220 = (int)&loc_804FC8B;
          sub_8061B4D(v16, v14, v46, v47);
          *v45 = *((_BYTE *)s2 + v67);
        }
        ++v67;
      }
      v63[v65] = 0;
      if ( *(_BYTE *)(v56 + 26) )
      {
        v61 = sub_804DE14((unsigned __int8 *)v62, (unsigned __int8 *)v63);
      }
      else if ( *(_BYTE *)(v56 + 28) )
      {
        v61 = sub_804DF24((int)v62, (int)v63);
      }
      else if ( *(_BYTE *)(v56 + 29) )
      {
        v61 = sub_804DD07((int)a1, (int)v62, (unsigned __int8 *)v63);
      }
      else if ( *(_BYTE *)(v56 + 30) )
      {
        v17 = sub_804E054((unsigned __int8 *)v62, 0);
        a1 = (char *)(v17 - sub_804E054((unsigned __int8 *)v63, 0));
        v61 = (int)a1;
      }
      else
      {
        if ( *(_BYTE *)(v56 + 27) )
          sub_804E354((int)v62, v64, (int)v63, v65);
        if ( *(_BYTE *)(v56 + 32) )
        {
          v61 = sub_80572B3(v62, v63);
        }
        else if ( v64 )
        {
          if ( v65 )
            v61 = sub_805E81C(v62, v64 + 1, v63, v65 + 1);
          else
            v61 = 1;
        }
        else
        {
          v61 = -(v65 != 0);
        }
      }
      if ( v69 || v68 )
      {
        free(ptr);
      }
      else
      {
        v62[v64] = BYTE2(v55);
        v63[v65] = HIBYTE(v55);
      }
      goto LABEL_101;
    }
    if ( v69 )
    {
      if ( v68 )
      {
        while ( 1 )
        {
          if ( s1 < v59 )
          {
            v46 = *(char *)s1;
            v18 = sub_804AFB2(v46);
            v20 = v18;
            _ZF = *(_BYTE *)(v18 + v69) == 0;
            v21 = &loc_8050004;
            if ( !_ZF )
              v21 = &loc_804FFB0;
            dword_806B220 = (int)v21;
            sub_8061B4D(v19, v20, v46, v47);
          }
          while ( s2 < v60 )
          {
            v46 = *(char *)s2;
            v22 = sub_804AFB2(v46);
            if ( !*(_BYTE *)(v22 + v69) )
              break;
            s2 = (char *)s2 + 1;
          }
          if ( s1 >= v59 || s2 >= v60 )
            break;
          v46 = *(char *)s1;
          v23 = sub_804AFB2(v46);
          v46 = *(char *)(v23 + v68);
          v24 = (unsigned __int8)sub_804AFB2(v46);
          v46 = *(char *)s2;
          v25 = sub_804AFB2(v46);
          v46 = *(char *)(v25 + v68);
          a1 = (char *)(v24 - (unsigned __int8)sub_804AFB2(v46));
          v61 = (int)a1;
          if ( a1 )
            goto LABEL_119;
          s1 = (char *)s1 + 1;
          s2 = (char *)s2 + 1;
        }
        v61 = (s1 < v59) - (s2 < v60);
      }
      else
      {
        while ( 1 )
        {
          dword_806B2D8 = (int)&loc_8050151;
          sub_8061693();
          do
          {
            s1 = (char *)s1 + 1;
            if ( s1 >= v59 )
              break;
            v46 = *(char *)s1;
            v26 = sub_804AFB2(v46);
          }
          while ( *(_BYTE *)(v26 + v69) );
          while ( s2 < v60 )
          {
            v46 = *(char *)s2;
            v27 = sub_804AFB2(v46);
            if ( !*(_BYTE *)(v27 + v69) )
              break;
            s2 = (char *)s2 + 1;
          }
          if ( s1 >= v59 || s2 >= v60 )
            break;
          v46 = *(char *)s1;
          v28 = (unsigned __int8)sub_804AFB2(v46);
          v46 = *(char *)s2;
          a1 = (char *)(v28 - (unsigned __int8)sub_804AFB2(v46));
          v61 = (int)a1;
          if ( a1 )
          {
            dword_806B2C4 = (int)&loc_80505D6;
            sub_8061709();
          }
          s1 = (char *)s1 + 1;
          s2 = (char *)s2 + 1;
        }
        v61 = (s1 < v59) - (s2 < v60);
      }
      goto LABEL_101;
    }
    if ( !v70 )
    {
      v61 = -(n != 0);
      goto LABEL_101;
    }
    if ( !n )
      break;
    if ( v68 )
    {
      while ( s1 < v59 && s2 < v60 )
      {
        v29 = (char *)s1;
        s1 = (char *)s1 + 1;
        v46 = *v29;
        v30 = sub_804AFB2(v46);
        v46 = *(char *)(v30 + v68);
        v31 = (unsigned __int8)sub_804AFB2(v46);
        v32 = (char *)s2;
        s2 = (char *)s2 + 1;
        v46 = *v32;
        v33 = sub_804AFB2(v46);
        v46 = *(char *)(v33 + v68);
        a1 = (char *)(v31 - (unsigned __int8)sub_804AFB2(v46));
        v61 = (int)a1;
        if ( a1 )
          goto LABEL_119;
      }
    }
    else
    {
      v34 = v70;
      if ( n <= v70 )
        v34 = n;
      v61 = memcmp(s1, s2, v34);
      if ( v61 )
        goto LABEL_119;
    }
    if ( v70 < n )
      v35 = -1;
    else
      v35 = v70 != n;
    v61 = v35;
LABEL_101:
    if ( v61 )
      goto LABEL_119;
    v56 = *(_DWORD *)(v56 + 36);
    _CF = 0;
    _OF = 0;
    _ZF = v56 == 0;
    _SF = v56 < 0;
    if ( !v56 )
    {
      __asm { pushfw }
      result = 0;
      __asm { popfw }
      return result;
    }
    if ( *(_DWORD *)(v56 + 8) == -1 )
    {
      v59 = (char *)(*(_DWORD *)v53 + *(_DWORD *)(v53 + 4) - 1);
      v60 = (char *)(*(_DWORD *)v52 + *(_DWORD *)(v52 + 4) - 1);
    }
    else
    {
      v59 = sub_804D4E6((char **)v53, v56);
      v60 = sub_804D4E6((char **)v52, v56);
    }
    if ( *(_DWORD *)v56 == -1 )
    {
      s1 = *(void **)v53;
      s2 = *(void **)v52;
      if ( *(_BYTE *)(v56 + 24) )
      {
        while ( s1 < v59 )
        {
          v46 = *(char *)s1;
          if ( !byte_806BA29[(unsigned __int8)sub_804AFB2(v46)] )
            break;
          s1 = (char *)s1 + 1;
        }
        if ( s2 < v60 )
        {
          v46 = *(char *)s2;
          _ZF = byte_806BA29[(unsigned __int8)sub_804AFB2(v46)] == 0;
          v43 = &loc_80505D1;
          if ( !_ZF )
            v43 = &loc_8050571;
          dword_806B27C = (int)v43;
          sub_806190F(v42, v41);
        }
      }
    }
    else
    {
      s1 = (void *)sub_804D378(v53, (int *)v56);
      s2 = (void *)sub_804D378(v52, (int *)v56);
    }
  }
  v61 = 1;
LABEL_119:
  v44 = &loc_80505FD;
  if ( !*(_BYTE *)(v56 + 31) )
    v44 = &loc_8050607;
  dword_806B20C = (int)v44;
  sub_8061BBB(v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, s1, s2);
  return -v61;
}
// 8061693: using guessed type int sub_8061693(void);
// 80618A3: using guessed type int sub_80618A3(void);
// 806190F: using guessed type double __fastcall sub_806190F(_DWORD, _DWORD);
// 806197F: using guessed type int __stdcall sub_806197F(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8061BBB: using guessed type int __stdcall sub_8061BBB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806B20C: using guessed type int dword_806B20C;
// 806B220: using guessed type int dword_806B220;
// 806B268: using guessed type int dword_806B268;
// 806B27C: using guessed type int dword_806B27C;
// 806B290: using guessed type int dword_806B290;
// 806B2C4: using guessed type int dword_806B2C4;
// 806B2D8: using guessed type int dword_806B2D8;
// 806BA11: using guessed type char byte_806BA11;
// 806BE3D: using guessed type int dword_806BE3D;

//----- (08050627) --------------------------------------------------------
int __usercall sub_8050627@<eax>(int a1@<edx>, int a2@<ecx>, char *a3@<ebx>, int a4, int a5)
{
  int result; // eax
  void *v6; // eax
  int v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+14h] [ebp-14h]

  if ( dword_806BE3D )
  {
    v7 = sub_804F8AC(a3, a4, a5);
    if ( v7 || byte_806BE3B || byte_806BE3A )
      return v7;
  }
  if ( *(_DWORD *)(a4 + 4) == 1 )
  {
    v8 = -(*(_DWORD *)(a5 + 4) != 1);
  }
  else
  {
    v6 = &loc_80506C1;
    if ( *(_DWORD *)(a5 + 4) != 1 )
      v6 = &loc_80506CD;
    dword_806B2A4 = (int)v6;
    sub_8061819(a2, a1);
    v8 = 1;
  }
  if ( byte_806BE39 )
    result = -v8;
  else
    result = v8;
  return result;
}
// 8061819: using guessed type int __fastcall sub_8061819(_DWORD, _DWORD);
// 806B2A4: using guessed type int dword_806B2A4;
// 806BE39: using guessed type char byte_806BE39;
// 806BE3A: using guessed type char byte_806BE3A;
// 806BE3B: using guessed type char byte_806BE3B;
// 806BE3D: using guessed type int dword_806BE3D;

//----- (0805078F) --------------------------------------------------------
int __cdecl sub_805078F(int a1, FILE *stream, int a3)
{
  char *v3; // eax
  char *v4; // eax
  int result; // eax
  char *v6; // eax
  char v7; // [esp+1Fh] [ebp-19h]
  char *v8; // [esp+20h] [ebp-18h]
  char *ptr; // [esp+24h] [ebp-14h]
  size_t n; // [esp+28h] [ebp-10h]
  unsigned int v11; // [esp+2Ch] [ebp-Ch]

  ptr = *(char **)a1;
  n = *(_DWORD *)(a1 + 4);
  v11 = *(_DWORD *)a1 + n;
  if ( a3 || !byte_806BE45 )
  {
    *(_BYTE *)(v11 - 1) = byte_806B30C;
    if ( fwrite_unlocked(ptr, 1u, n, stream) != n )
    {
      v6 = gettext("write failed");
      sub_804B363((int)v6, (char *)a3);
    }
    result = v11 - 1;
    *(_BYTE *)(v11 - 1) = 0;
  }
  else
  {
    v8 = *(char **)a1;
    while ( (unsigned int)v8 < v11 )
    {
      v3 = v8++;
      v7 = *v3;
      if ( *v3 == 9 )
      {
        v7 = 62;
      }
      else if ( v8 == (char *)v11 )
      {
        v7 = 10;
      }
      if ( fputc_unlocked(v7, stream) == -1 )
      {
        v4 = gettext("write failed");
        sub_804B363((int)v4, 0);
      }
    }
    result = sub_804ED45(a1);
  }
  return result;
}
// 806B30C: using guessed type char byte_806B30C;
// 806BE45: using guessed type char byte_806BE45;

//----- (080508B8) --------------------------------------------------------
#error "8050A3C: call analysis failed (funcsize=217)"

//----- (08050CA7) --------------------------------------------------------
unsigned int __cdecl sub_8050CA7(int a1, unsigned int a2, void **a3)
{
  char *v3; // ebx
  FILE *v4; // eax
  int v6; // [esp+0h] [ebp-28h]
  unsigned int i; // [esp+18h] [ebp-10h]
  _DWORD *v8; // [esp+1Ch] [ebp-Ch]

  *a3 = sub_805E3AE(a2, 4u);
  v8 = *a3;
  for ( i = 0; i < a2; ++i )
  {
    v3 = (char *)&v8[i];
    if ( *(_DWORD *)(8 * i + a1 + 4) && *(_BYTE *)(*(_DWORD *)(8 * i + a1 + 4) + 8) )
    {
      v6 = *(_DWORD *)(8 * i + a1 + 4);
      v4 = (FILE *)sub_804C21B(v3, v6);
    }
    else
    {
      v4 = sub_804BC8C(*(char **)(8 * i + a1), "r");
    }
    *(_DWORD *)v3 = v4;
    if ( !v8[i] )
    {
      dword_806B2D8 = (int)&loc_8050DA7;
      sub_8061693();
    }
  }
  return i;
}
// 8061693: using guessed type int sub_8061693(void);
// 806B2D8: using guessed type int dword_806B2D8;

//----- (08050DB0) --------------------------------------------------------
#error "8050ECE: call analysis failed (funcsize=201)"

//----- (08051849) --------------------------------------------------------
#error "805186F: call analysis failed (funcsize=15)"

//----- (08051874) --------------------------------------------------------
#error "805190C: positive sp value has been found (funcsize=42)"

//----- (0805190F) --------------------------------------------------------
#error "8051A6B: call analysis failed (funcsize=110)"

//----- (08051A7B) --------------------------------------------------------
int __usercall sub_8051A7B@<eax>(int a1@<ecx>, char *a2@<ebx>, int a3, unsigned int a4, int a5, unsigned __int8 a6)
{
  _DWORD *v6; // eax
  _DWORD *v7; // edx
  _DWORD *v8; // eax
  _DWORD *v9; // edx
  _DWORD *v10; // edx
  _DWORD *v11; // edx
  _DWORD *v12; // edx
  int result; // eax
  int v18; // eax
  _DWORD *v19; // edx
  int v20; // eax
  unsigned __int8 v21; // [esp+1Ch] [ebp-2Ch]
  int v22; // [esp+24h] [ebp-24h]
  int v23; // [esp+28h] [ebp-20h]
  int v24; // [esp+2Ch] [ebp-1Ch]
  unsigned int v25; // [esp+30h] [ebp-18h]
  unsigned int v26; // [esp+34h] [ebp-14h]
  int v27; // [esp+38h] [ebp-10h]
  unsigned int v28; // [esp+3Ch] [ebp-Ch]

  v21 = a6;
  if ( a4 == 2 )
  {
    v24 = sub_8050627(a3 - 32, a1, a2, a3 - 16, a3 - 32) > 0;
    if ( v21 )
    {
      v6 = (_DWORD *)(a5 - 16);
      v7 = (_DWORD *)(16 * ~v24 + a3);
      *v6 = *v7;
      v6[1] = v7[1];
      v6[2] = v7[2];
      v6[3] = v7[3];
      v8 = (_DWORD *)(a5 - 32);
      v9 = (_DWORD *)(16 * (v24 - 2) + a3);
      *v8 = *v9;
      v8[1] = v9[1];
      v8[2] = v9[2];
      v8[3] = v9[3];
    }
    else if ( v24 )
    {
      v10 = (_DWORD *)(a5 - 16);
      *v10 = *(_DWORD *)(a3 - 16);
      v10[1] = *(_DWORD *)(a3 - 12);
      v10[2] = *(_DWORD *)(a3 - 8);
      v10[3] = *(_DWORD *)(a3 - 4);
      v11 = (_DWORD *)(a3 - 16);
      *v11 = *(_DWORD *)(a3 - 32);
      v11[1] = *(_DWORD *)(a3 - 28);
      v11[2] = *(_DWORD *)(a3 - 24);
      v11[3] = *(_DWORD *)(a3 - 20);
      v12 = (_DWORD *)(a3 - 32);
      *v12 = *(_DWORD *)(a5 - 16);
      v12[1] = *(_DWORD *)(a5 - 12);
      v12[2] = *(_DWORD *)(a5 - 8);
      result = *(_DWORD *)(a5 - 4);
      v12[3] = result;
      return result;
    }
    dword_806B2D8 = (int)&locret_8051CE9;
    sub_8061693();
  }
  v25 = a4 >> 1;
  v26 = a4 - (a4 >> 1);
  v27 = a3;
  v28 = -16 * (a4 >> 1) + a3;
  _CF = 0;
  _OF = 0;
  _ZF = v21 == 0;
  _SF = (v21 & 0x80u) != 0;
  if ( v21 )
  {
    v18 = -16 * v25;
  }
  else
  {
    __asm { pushfw }
    v18 = 0;
    __asm { popfw }
  }
  sub_8051A7B(v28, v26, a5 + v18, v21);
  if ( v25 <= 1 )
  {
    if ( v21 != 1 )
    {
      v19 = (_DWORD *)(a5 - 16);
      v20 = v27;
      *v19 = *(_DWORD *)(v27 - 16);
      v19[1] = *(_DWORD *)(v20 - 12);
      v19[2] = *(_DWORD *)(v20 - 8);
      v19[3] = *(_DWORD *)(v20 - 4);
    }
  }
  else
  {
    sub_8051A7B(v27, v25, a5, v21 == 0);
  }
  if ( v21 )
  {
    v22 = a5;
    v23 = a3;
  }
  else
  {
    v22 = a3;
    v23 = a5;
  }
  return sub_805190F(v22, a4, v23);
}
// 805190F: using guessed type _DWORD __cdecl sub_805190F(_DWORD, _DWORD, _DWORD);
// 8061693: using guessed type int sub_8061693(void);
// 806B2D8: using guessed type int dword_806B2D8;

//----- (08051CEB) --------------------------------------------------------
pthread_mutex_t *__cdecl sub_8051CEB(unsigned int a1, int a2, int a3)
{
  pthread_mutex_t *v3; // eax
  pthread_mutex_t *v4; // ST28_4
  pthread_mutex_t *v5; // ST2C_4

  v3 = (pthread_mutex_t *)sub_805E4E9(144 * a1);
  v4 = v3;
  v5 = v3;
  v3->__kind = 0;
  v5->__owner = v5->__kind;
  v5->__count = v5->__owner;
  v5->__lock = v5->__count;
  v3->__nusers = 0;
  v3[1].__lock = a2;
  v5->__spins = v5[1].__lock;
  v3[1].__count = 0;
  v3[1].__nusers = 0;
  v3[1].__size[20] = 0;
  pthread_mutex_init(v3 + 2, 0);
  sub_8051E25(v5, v5 + 3, a3, a1, a2, 0);
  return v4;
}

//----- (08051E25) --------------------------------------------------------
int __cdecl sub_8051E25(_DWORD *a1, pthread_mutex_t *a2, int a3, unsigned int a4, int a5, char a6)
{
  unsigned int v6; // eax
  int v7; // eax
  int v8; // ST40_4
  pthread_mutex_t *v9; // eax
  int v11; // [esp+30h] [ebp-28h]
  int v12; // [esp+34h] [ebp-24h]
  int v13; // [esp+38h] [ebp-20h]
  int v14; // [esp+3Ch] [ebp-1Ch]
  pthread_mutex_t *v15; // [esp+44h] [ebp-14h]
  int v16; // [esp+64h] [ebp+Ch]
  int v17; // [esp+64h] [ebp+Ch]

  if ( a6 )
    v6 = a1[5];
  else
    v6 = a1[6];
  v11 = v6 >> 1;
  v12 = v6 - (v6 >> 1);
  v13 = -16 * a5 + a3;
  v14 = -16 * (v6 >> 1) + v13;
  if ( a6 )
    v7 = (int)(a1 + 2);
  else
    v7 = (int)(a1 + 3);
  v8 = v7;
  v9 = a2;
  v16 = (int)&a2[3];
  v15 = v9;
  v9->__owner = v13;
  v15->__lock = v15->__owner;
  v9->__kind = v14;
  v15->__count = v15->__kind;
  v9->__nusers = v8;
  v9->__spins = v11;
  v9[1].__lock = v12;
  v9[1].__count = (unsigned int)a1;
  v9[1].__nusers = a1[10] + 1;
  v9[1].__size[20] = 0;
  pthread_mutex_init(v9 + 2, 0);
  if ( a4 <= 1 )
  {
    v15[1].__owner = 0;
    v15[1].__kind = 0;
  }
  else
  {
    v15[1].__owner = v16;
    v17 = sub_8051E25(v15, v16, v13, a4 >> 1, a5, 1);
    v15[1].__kind = v17;
    v16 = sub_8051E25(v15, v17, v14, a4 - (a4 >> 1), a5, 0);
  }
  return v16;
}

//----- (0805200D) --------------------------------------------------------
_BOOL4 __cdecl sub_805200D(_DWORD *a1, _DWORD *a2)
{
  _BOOL4 result; // eax

  if ( a1[10] == a2[10] )
    result = a1[5] + a1[6] < (unsigned int)(a2[5] + a2[6]);
  else
    result = a1[10] < a2[10];
  return result;
}

//----- (0805208C) --------------------------------------------------------
int __cdecl sub_805208C(pthread_mutex_t *a1)
{
  return pthread_mutex_lock(a1 + 2);
}

//----- (080520A2) --------------------------------------------------------
int __cdecl sub_80520A2(pthread_mutex_t *a1)
{
  return pthread_mutex_unlock(a1 + 2);
}

//----- (080520E9) --------------------------------------------------------
int __cdecl sub_80520E9(int a1, int a2)
{
  *(_DWORD *)a1 = sub_8058E28((int (*)())sub_805200D, 2 * a2);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 4), 0);
  return pthread_cond_init((pthread_cond_t *)(a1 + 28), 0);
}

//----- (08052137) --------------------------------------------------------
int __cdecl sub_8052137(int a1, int a2)
{
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 4));
  sub_8058ED8(*(_DWORD *)a1, a2);
  *(_BYTE *)(a2 + 44) = 1;
  pthread_cond_signal((pthread_cond_t *)(a1 + 28));
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 4));
}

//----- (08052184) --------------------------------------------------------
pthread_mutex_t *__cdecl sub_8052184(int a1)
{
  int v1; // edx
  int v2; // ecx
  pthread_mutex_t *v4; // [esp+1Ch] [ebp-Ch]

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 4));
  while ( 1 )
  {
    v4 = (pthread_mutex_t *)sub_8058F72(v1, v2, *(int **)a1);
    if ( v4 )
      break;
    pthread_cond_wait((pthread_cond_t *)(a1 + 28), (pthread_mutex_t *)(a1 + 4));
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 4));
  sub_805208C(v4);
  v4[1].__size[20] = 0;
  return v4;
}

//----- (080521ED) --------------------------------------------------------
int __usercall sub_80521ED@<eax>(int a1@<edx>, int a2@<ecx>, char *a3@<ebx>, int a4, FILE *stream, int a6)
{
  int result; // eax

  if ( !byte_806BE3B )
    goto LABEL_5;
  if ( !dword_806BA15 || (result = sub_8050627(a1, a2, a3, a4, (int)&dword_806BA15)) != 0 )
  {
    dword_806BA15 = *(_DWORD *)a4;
    dword_806BA19 = *(_DWORD *)(a4 + 4);
    dword_806BA1D = *(_DWORD *)(a4 + 8);
    dword_806BA21 = *(_DWORD *)(a4 + 12);
LABEL_5:
    result = sub_805078F(a4, stream, a6);
  }
  return result;
}
// 806BA15: using guessed type int dword_806BA15;
// 806BA19: using guessed type int dword_806BA19;
// 806BA1D: using guessed type int dword_806BA1D;
// 806BA21: using guessed type int dword_806BA21;
// 806BE3B: using guessed type char byte_806BE3B;

//----- (08052260) --------------------------------------------------------
#error "8052323: call analysis failed (funcsize=386)"

//----- (08052717) --------------------------------------------------------
int __cdecl sub_8052717(int a1, int a2)
{
  int v2; // ecx
  int result; // eax
  int v4; // edx
  void *v5; // eax
  void *v6; // eax
  bool v7; // [esp+1Eh] [ebp-Ah]
  bool v8; // [esp+1Fh] [ebp-9h]

  result = *(unsigned __int8 *)(a2 + 44) ^ 1;
  if ( *(_BYTE *)(a2 + 44) != 1 )
  {
    v7 = (unsigned int)(*(_DWORD *)a2 - *(_DWORD *)(a2 + 8) + 15) > 0x1E;
    v4 = *(_DWORD *)(a2 + 4) - *(_DWORD *)(a2 + 12);
    v8 = (unsigned int)(v4 + 15) > 0x1E;
    v5 = &loc_8052799;
    if ( !v7 )
      v5 = &loc_80527E4;
    dword_806B2A4 = (int)v5;
    sub_8061819(v2, v4);
    if ( !v8 )
    {
      v6 = &loc_80527D2;
      if ( *(_DWORD *)(a2 + 24) )
        v6 = &loc_80527D9;
      dword_806B254 = (int)v6;
      sub_80619F1();
    }
    result = sub_8052137(a1, a2);
  }
  return result;
}
// 8052717: could not find valid save-restore pair for ebx
// 8061819: using guessed type int __fastcall sub_8061819(_DWORD, _DWORD);
// 80619F1: using guessed type int sub_80619F1(void);
// 806B254: using guessed type int dword_806B254;
// 806B2A4: using guessed type int dword_806B2A4;

//----- (08052835) --------------------------------------------------------
int __cdecl sub_8052835(int a1, _DWORD *a2)
{
  int result; // eax

  if ( a2[10] <= 1u )
  {
    result = a2[5] + a2[6];
    if ( !result )
      result = sub_8052137(a1, a2[7]);
  }
  else
  {
    sub_805208C((pthread_mutex_t *)a2[7]);
    sub_8052717(a1, a2[7]);
    result = sub_80520A2((pthread_mutex_t *)a2[7]);
  }
  return result;
}

//----- (080528A2) --------------------------------------------------------
int __cdecl sub_80528A2(int a1, int a2, FILE *stream, int a4)
{
  pthread_mutex_t *v5; // [esp+1Ch] [ebp-Ch]

  while ( 1 )
  {
    v5 = sub_8052184(a1);
    if ( !v5[1].__nusers )
      break;
    sub_8052260((int)v5, a2, stream, a4);
    sub_8052717(a1, (int)v5);
    sub_8052835(a1, v5);
    sub_80520A2(v5);
  }
  sub_80520A2(v5);
  return sub_8052137(a1, (int)v5);
}

//----- (08052935) --------------------------------------------------------
void *__cdecl start_routine(void *a1)
{
  void *result; // eax

  sub_80529B3(
    *((_DWORD *)a1 + 1),
    *((char **)a1 + 3),
    *(_DWORD *)a1,
    *((_DWORD *)a1 + 1),
    *((_DWORD *)a1 + 2),
    *((_DWORD *)a1 + 3),
    *((_DWORD *)a1 + 4),
    *((FILE **)a1 + 5),
    *((_DWORD *)a1 + 6));
  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}

//----- (080529B3) --------------------------------------------------------
int __usercall sub_80529B3@<eax>(int a1@<ecx>, char *a2@<ebx>, int a3, int a4, int a5, int a6, int a7, FILE *stream, int a9)
{
  int result; // eax
  pthread_t newthread; // [esp+28h] [ebp-40h]
  unsigned int v11; // [esp+2Ch] [ebp-3Ch]
  unsigned int v12; // [esp+30h] [ebp-38h]
  int v13; // [esp+34h] [ebp-34h]
  unsigned int v14; // [esp+38h] [ebp-30h]
  unsigned int v15; // [esp+3Ch] [ebp-2Ch]
  int v16; // [esp+40h] [ebp-28h]
  int arg; // [esp+44h] [ebp-24h]
  unsigned int v18; // [esp+48h] [ebp-20h]
  int v19; // [esp+4Ch] [ebp-1Ch]
  int v20; // [esp+50h] [ebp-18h]
  int v21; // [esp+54h] [ebp-14h]
  FILE *v22; // [esp+58h] [ebp-10h]
  int v23; // [esp+5Ch] [ebp-Ch]

  v11 = *(_DWORD *)(a6 + 20) + *(_DWORD *)(a6 + 24);
  v12 = (unsigned int)a4 >> 1;
  v13 = a4 - ((unsigned int)a4 >> 1);
  arg = a3;
  v18 = (unsigned int)a4 >> 1;
  v19 = a5;
  v20 = *(_DWORD *)(a6 + 32);
  v21 = a7;
  v22 = stream;
  v23 = a9;
  if ( (unsigned int)a4 <= 1 || v11 <= 0x1FFFF || pthread_create(&newthread, 0, start_routine, &arg) )
  {
    v14 = *(_DWORD *)(a6 + 20);
    v15 = *(_DWORD *)(a6 + 24);
    v16 = -16 * a5 + a3;
    if ( v15 > 1 )
      sub_8051A7B(-16 * v14, a2, -16 * v14 + a3, v15, -16 * (v14 >> 1) + v16, 0);
    if ( v14 > 1 )
      sub_8051A7B(a1, a2, a3, v14, v16, 0);
    *(_DWORD *)a6 = a3;
    *(_DWORD *)(a6 + 4) = a3 - 16 * v14;
    *(_DWORD *)(a6 + 8) = a3 - 16 * v14;
    *(_DWORD *)(a6 + 12) = a3 + -16 * v14 - 16 * v15;
    sub_8052137(a7, a6);
    result = sub_80528A2(a7, a5, stream, a9);
  }
  else
  {
    sub_80529B3(a3 - 16 * *(_DWORD *)(a6 + 20), v13, a5, *(_DWORD *)(a6 + 36), a7, stream, a9);
    result = pthread_join(newthread, 0);
  }
  return result;
}

//----- (08052C07) --------------------------------------------------------
int __usercall sub_8052C07@<eax>(char *a1@<ebx>, int a2, int a3, int a4, char *s1)
{
  int v5; // eax
  void *v6; // eax
  char *v7; // ebx
  int v8; // edx
  int v9; // ecx
  int result; // eax
  int v11; // eax
  int v14; // eax
  signed int v15; // eax
  void *v18; // eax
  char *v19; // [esp-8h] [ebp-100h]
  int v20; // [esp-4h] [ebp-FCh]
  int v21; // [esp+0h] [ebp-F8h]
  const char *v22; // [esp+4h] [ebp-F4h]
  int v23; // [esp+8h] [ebp-F0h]
  int v24; // [esp+Ch] [ebp-ECh]
  char *v25; // [esp+10h] [ebp-E8h]
  int v26; // [esp+14h] [ebp-E4h]
  int v27; // [esp+18h] [ebp-E0h]
  int v28; // [esp+1Ch] [ebp-DCh]
  int v29; // [esp+20h] [ebp-D8h]
  int v30; // [esp+24h] [ebp-D4h]
  char *v31; // [esp+28h] [ebp-D0h]
  unsigned int i; // [esp+2Ch] [ebp-CCh]
  __int64 v33; // [esp+30h] [ebp-C8h]
  __int64 v34; // [esp+88h] [ebp-70h]
  __int64 v35; // [esp+90h] [ebp-68h]
  __int64 v36; // [esp+E8h] [ebp-10h]

  BYTE1(v29) = 0;
  v31 = 0;
  for ( i = a3; ; ++i )
  {
    result = i;
    if ( i >= a4 )
      break;
    v5 = strcmp(*(const char **)(8 * i + a2), "-");
    LOBYTE(v5) = v5 == 0;
    HIBYTE(v29) = v5;
    v20 = v5;
    v19 = a1;
    v6 = &loc_8052C8F;
    if ( !s1 )
      v6 = &loc_8052CE2;
    dword_806B2D8 = (int)v6;
    v7 = v19;
    sub_8061693();
    v22 = *(const char **)(8 * i + a2);
    if ( !strcmp(s1, v22) && HIBYTE(v29) != 1 )
    {
      BYTE2(v29) = 1;
      dword_806B220 = (int)&loc_8052DAE;
      sub_8061B4D(v9, v8, v21, v22);
    }
    if ( BYTE1(v29) != 1 )
    {
      result = sub_806160A(1, (int)&v33);
      if ( result )
        return result;
      BYTE1(v29) = 1;
    }
    if ( HIBYTE(v29) )
    {
      v11 = sub_806160A(0, (int)&v35);
      _ZF = v11 == 0;
      _SF = v11 < 0;
      if ( v11 )
        goto LABEL_17;
    }
    else
    {
      v14 = sub_80615DB(*(_DWORD *)(8 * i + a2), (int)&v35);
      _ZF = v14 == 0;
      _SF = v14 < 0;
      if ( v14 )
        goto LABEL_17;
    }
    v7 = (char *)HIDWORD(v36);
    _ZF = v36 == v34;
    _SF = (signed int)(HIDWORD(v34) ^ HIDWORD(v36) | v36 ^ v34) < 0;
    if ( v36 == v34 )
    {
      v7 = (char *)HIDWORD(v35);
      _ZF = v35 == v33;
      _SF = (signed int)(HIDWORD(v33) ^ HIDWORD(v35) | v35 ^ v33) < 0;
      if ( v35 == v33 )
      {
        v15 = 1;
        goto LABEL_18;
      }
    }
LABEL_17:
    __asm { pushfw }
    v15 = 0;
    __asm { popfw }
LABEL_18:
    BYTE2(v29) = v15 & 1;
    v20 = v15;
    v19 = v7;
    v18 = &loc_8052DD0;
    if ( !BYTE2(v29) )
      v18 = &loc_8052E86;
    dword_806B20C = (int)v18;
    a1 = v19;
    sub_8061BBB(v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, i, v33);
    if ( !v31 )
    {
      v31 = (char *)sub_804C200(a1, (FILE **)&v30);
      a1 = (char *)(8 * i);
      v25 = v31 + 9;
      v24 = v30;
      v23 = 1;
      sub_8051849(8 * i + a2, 0);
    }
    *(_DWORD *)(8 * i + a2) = v31 + 9;
    *(_DWORD *)(a2 + 8 * i + 4) = v31;
  }
  return result;
}
// 8051849: using guessed type int __cdecl sub_8051849(_DWORD, _DWORD);
// 8061693: using guessed type int sub_8061693(void);
// 8061BBB: using guessed type int __stdcall sub_8061BBB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806B20C: using guessed type int dword_806B20C;
// 806B220: using guessed type int dword_806B220;
// 806B2D8: using guessed type int dword_806B2D8;

//----- (08052EA6) --------------------------------------------------------
unsigned int __cdecl sub_8052EA6(int a1, unsigned int a2)
{
  bool v2; // zf
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  int v6; // eax
  char *v7; // ebx
  char *v8; // eax
  unsigned int result; // eax
  int v10; // [esp+0h] [ebp-28h]
  int v11; // [esp+4h] [ebp-24h]
  int v12; // [esp+8h] [ebp-20h]
  int v13; // [esp+Ch] [ebp-1Ch]
  int v14; // [esp+10h] [ebp-18h]
  int v15; // [esp+14h] [ebp-14h]
  int v16; // [esp+18h] [ebp-10h]
  unsigned int i; // [esp+1Ch] [ebp-Ch]
  int v18; // [esp+20h] [ebp-8h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a2 )
      break;
    v2 = strcmp(*(const char **)(4 * i + a1), "-") == 0;
    v5 = &loc_8052EF7;
    if ( !v2 )
      v5 = &loc_8052F0E;
    dword_806B27C = (int)v5;
    sub_806190F(v4, v3);
    dword_806B234 = (int)&loc_8052F5C;
    sub_8061ADD(v10, v11, v12, v13, v14, v15, v16, i, v18);
    v6 = *(_DWORD *)(4 * i + a1);
    v11 = 4;
    v10 = v6;
    if ( euidaccess() )
    {
      v7 = *(char **)(4 * i + a1);
      v8 = gettext("cannot read");
      sub_804B363((int)v8, v7);
    }
  }
  return result;
}
// 8049E00: using guessed type int euidaccess(void);
// 806190F: using guessed type double __fastcall sub_806190F(_DWORD, _DWORD);
// 8061ADD: using guessed type int __stdcall sub_8061ADD(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806B234: using guessed type int dword_806B234;
// 806B27C: using guessed type int dword_806B27C;

//----- (08052F72) --------------------------------------------------------
void __cdecl sub_8052F72(char *a1)
{
  char *v1; // eax
  int fd; // [esp+1Ch] [ebp-Ch]

  if ( a1 )
  {
    fd = open64(a1, 524353);
    if ( fd < 0 )
    {
      v1 = gettext("open failed");
      sub_804B363((int)v1, a1);
    }
    sub_804BEB5(fd, 1);
  }
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);

//----- (08052FD8) --------------------------------------------------------
#error "80532E4: call analysis failed (funcsize=328)"

//----- (0805348B) --------------------------------------------------------
unsigned int __usercall sub_805348B@<eax>(char *a1@<ebx>, char **a2, unsigned int a3, char *a4, unsigned int a5)
{
  int v5; // eax
  bool v6; // zf
  void *v7; // eax
  char **v9; // [esp+4h] [ebp-BCh]
  FILE *stream; // [esp+18h] [ebp-A8h]
  int v11; // [esp+20h] [ebp-A0h]
  int v12; // [esp+28h] [ebp-98h]
  unsigned int v13; // [esp+2Ch] [ebp-94h]
  int v14; // [esp+30h] [ebp-90h]
  int *v15; // [esp+34h] [ebp-8Ch]
  int v16; // [esp+38h] [ebp-88h]
  char *s1; // [esp+3Ch] [ebp-84h]
  void *v18; // [esp+48h] [ebp-78h]
  void *ptr; // [esp+4Ch] [ebp-74h]
  int v20; // [esp+58h] [ebp-68h]
  char v21; // [esp+64h] [ebp-5Ch]
  unsigned int v22; // [esp+B4h] [ebp-Ch]
  char *v23; // [esp+BCh] [ebp-4h]

  v23 = a1;
  v9 = a2;
  v22 = __readgsdword(0x14u);
  v11 = 0;
  v20 = 0;
  while ( a3 )
  {
    s1 = *v9;
    stream = sub_804BDC9(s1, "r");
    if ( a5 <= 1 )
    {
      v12 = 24;
    }
    else
    {
      v13 = 1;
      v14 = 1;
      while ( v13 < a5 )
      {
        v13 *= 2;
        ++v14;
      }
      v12 = 16 * v14;
    }
    if ( !v20 )
    {
      v5 = sub_804D057((int)&stream, 1u, (int)v9, a3, v12);
      sub_804D2A2((int)&ptr, v12, v5);
    }
    v21 = 0;
    ++v9;
    --a3;
    v6 = (unsigned __int8)sub_804D68A(&ptr, stream, s1) == 0;
    v7 = &loc_80537AD;
    if ( !v6 )
      v7 = &loc_80535BD;
    dword_806B2D8 = (int)v7;
    sub_8061693();
    sub_804BE0A(stream, (int)s1);
  }
  free(ptr);
  v15 = (int *)dword_806BEC9;
  v18 = sub_805E3AE(v11, 8u);
  v16 = 0;
  while ( v15 )
  {
    *((_DWORD *)v18 + 2 * v16) = (char *)v15 + 9;
    *((_DWORD *)v18 + 2 * v16 + 1) = v15;
    v15 = (int *)*v15;
    ++v16;
  }
  sub_8052FD8((int)v18, v11, v11, a4);
  free(v18);
  sub_804B9DE(a1);
  return __readgsdword(0x14u) ^ v22;
}
// 804D68A: using guessed type int __cdecl sub_804D68A(_DWORD, _DWORD, _DWORD);
// 8061693: using guessed type int sub_8061693(void);
// 806B2D8: using guessed type int dword_806B2D8;
// 806BEC9: using guessed type int dword_806BEC9;

//----- (080538D5) --------------------------------------------------------
_DWORD *__cdecl sub_80538D5(void *src)
{
  _DWORD *result; // eax
  int *i; // [esp+18h] [ebp-10h]
  _DWORD *v3; // [esp+1Ch] [ebp-Ch]

  v3 = sub_805E644(src, 0x28u);
  for ( i = &dword_806BE3D; *i; i = (int *)(*i + 36) )
    ;
  *i = (int)v3;
  result = v3;
  v3[9] = 0;
  return result;
}
// 806BE3D: using guessed type int dword_806BE3D;

//----- (08053922) --------------------------------------------------------
unsigned int __cdecl sub_8053922(int a1, char *msgid)
{
  void *v2; // esi
  char *v3; // ebx
  char *v4; // eax

  v2 = sub_805BBBF(a1);
  v3 = gettext(msgid);
  v4 = gettext("%s: invalid field specification %s");
  error(2, 0, v4, v3, v2);
  return sub_8053970(a1);
}

//----- (08053970) --------------------------------------------------------
unsigned int __cdecl sub_8053970(int a1)
{
  char *v1; // eax
  int v2; // edx
  int v3; // ecx

  v1 = gettext("options '-%s' are incompatible");
  error(2, 0, v1, a1);
  return sub_80539A1(v3, v2);
}

//----- (080539A1) --------------------------------------------------------
unsigned int __fastcall sub_80539A1(int a1, int a2)
{
  int v2; // ecx
  int v3; // edx
  int v4; // eax
  bool v5; // zf
  bool v6; // sf
  unsigned __int8 v7; // of
  void *v8; // eax
  int v9; // edx
  int v10; // ecx
  int v12; // [esp-4h] [ebp-4Ch]
  int v13; // [esp+0h] [ebp-48h]
  int v14; // [esp+18h] [ebp-30h]
  char v15; // [esp+1Dh] [ebp-2Bh]
  unsigned int v16; // [esp+3Ch] [ebp-Ch]

  v16 = __readgsdword(0x14u);
  v14 = dword_806BE3D;
  dword_806B27C = (int)&loc_8053ABD;
  sub_806190F(a1, a2);
  do
  {
    v2 = *(unsigned __int8 *)(v14 + 29)
       + *(unsigned __int8 *)(v14 + 28)
       + *(unsigned __int8 *)(v14 + 26)
       + *(unsigned __int8 *)(v14 + 30);
    v3 = *(unsigned __int8 *)(v14 + 27) | *(unsigned __int8 *)(v14 + 32);
    v4 = v2 + (v3 | (*(_DWORD *)(v14 + 16) != 0));
    v7 = __OFSUB__(v4, 1);
    v5 = v4 == 1;
    v6 = v4 - 1 < 0;
    v12 = v2 + (v3 | (*(_DWORD *)(v14 + 16) != 0));
    v8 = &loc_8053A66;
    if ( (unsigned __int8)(v6 ^ v7) | v5 )
      v8 = &loc_8053AB4;
    dword_806B2C4 = (int)v8;
    sub_8061709();
    *(_BYTE *)(v14 + 31) = 0;
    *(_BYTE *)(v14 + 25) = *(_BYTE *)(v14 + 31);
    v9 = *(unsigned __int8 *)(v14 + 25);
    *(_BYTE *)(v14 + 24) = v9;
    sub_804EE66(v9, v10, v14, (_BYTE *)&v13 - 43);
    sub_8053970((int)&v15);
    v14 = *(_DWORD *)(v14 + 36);
  }
  while ( v14 );
  return __readgsdword(0x14u) ^ v16;
}
// 806190F: using guessed type double __fastcall sub_806190F(_DWORD, _DWORD);
// 806B27C: using guessed type int dword_806B27C;
// 806B2C4: using guessed type int dword_806B2C4;
// 806BE3D: using guessed type int dword_806BE3D;

//----- (08053ADA) --------------------------------------------------------
int __usercall sub_8053ADA@<eax>(int a1@<edx>, int a2@<ecx>, char *nptr, int a4, char *msgid)
{
  void *v9; // esi
  char *v10; // ebx
  char *v11; // eax
  int result; // eax
  int v13; // [esp+0h] [ebp-38h]
  int v14; // [esp+4h] [ebp-34h]
  int v15; // [esp+8h] [ebp-30h]
  char *v16; // [esp+Ch] [ebp-2Ch]
  void *v17; // [esp+10h] [ebp-28h]
  int v18; // [esp+14h] [ebp-24h]
  int v19; // [esp+18h] [ebp-20h]
  int v20; // [esp+24h] [ebp-14h]
  __int64 v21; // [esp+28h] [ebp-10h]

  switch ( sub_805F062(a1, a2, nptr, (int)&v20, 10, (int)&v21, &locale) )
  {
    case 0:
    case 2:
      *(_DWORD *)a4 = v21;
      if ( v21 == *(_DWORD *)a4 )
      {
        dword_806B268 = (int)&loc_8053BDF;
        sub_806197F(v13, v14, v15, v16, v17, v18, v19);
      }
      goto LABEL_4;
    case 1:
    case 3:
LABEL_4:
      *(_DWORD *)a4 = -1;
      goto LABEL_8;
    case 4:
      _CF = 0;
      _OF = 0;
      _ZF = msgid == 0;
      _SF = (signed int)msgid < 0;
      if ( msgid )
      {
        v9 = sub_805BBBF((int)nptr);
        v10 = gettext(msgid);
        v11 = gettext("%s: invalid count at start of %s");
        v17 = v9;
        v16 = v10;
        error(2, 0, v11, v10, v9);
      }
      __asm { pushfw }
      result = 0;
      __asm { popfw }
      break;
    default:
LABEL_8:
      result = v20;
      break;
  }
  return result;
}
// 806197F: using guessed type int __stdcall sub_806197F(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806B268: using guessed type int dword_806B268;

//----- (08053BE9) --------------------------------------------------------
int __cdecl sub_8053BE9(int sig)
{
  sub_804B9FD();
  signal(sig, 0);
  return raise(sig);
}

//----- (08053C14) --------------------------------------------------------
#error "8053D2E: call analysis failed (funcsize=18)"

//----- (08053D38) --------------------------------------------------------
void *__cdecl sub_8053D38(void *s)
{
  memset(s, 0, 0x28u);
  *((_DWORD *)s + 2) = -1;
  return s;
}

//----- (08053D68) --------------------------------------------------------
#error "80550F1: call analysis failed (funcsize=770)"

//----- (0805560A) --------------------------------------------------------
void __fastcall __noreturn sub_805560A(int a1, int a2)
{
  sub_804B3C5(a2, a1, 1);
}

//----- (0805561E) --------------------------------------------------------
int __cdecl sub_805561E(char *s, int a2, int a3, size_t a4)
{
  int result; // eax
  char v5; // [esp+13h] [ebp-15h]
  signed int i; // [esp+14h] [ebp-14h]
  signed int v7; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]

  v7 = -1;
  v5 = 0;
  n = strlen(s);
  for ( i = 0; *(_DWORD *)(4 * i + a2); ++i )
  {
    if ( !strncmp(*(const char **)(4 * i + a2), s, n) )
    {
      if ( strlen(*(const char **)(4 * i + a2)) == n )
        return i;
      if ( v7 == -1 )
      {
        v7 = i;
      }
      else if ( !a3 || memcmp((const void *)(a3 + a4 * v7), (const void *)(i * a4 + a3), a4) )
      {
        v5 = 1;
      }
    }
  }
  if ( v5 )
    result = -2;
  else
    result = v7;
  return result;
}

//----- (08055739) --------------------------------------------------------
void __cdecl sub_8055739(int a1, int a2, int a3)
{
  char *v3; // eax
  char *format; // ST2C_4
  void *v5; // ebx
  void *v6; // eax

  if ( a3 == -1 )
    v3 = gettext("invalid argument %s for %s");
  else
    v3 = gettext("ambiguous argument %s for %s");
  format = v3;
  v5 = sub_805BB9D(1, a1);
  v6 = sub_805B721(0, 8, a2);
  error(0, 0, format, v6, v5);
}

//----- (080557BC) --------------------------------------------------------
int __cdecl sub_80557BC(int a1, int a2, size_t n)
{
  FILE *v3; // ebx
  char *v4; // eax
  const void *v6; // [esp+4h] [ebp-24h]
  void *v7; // [esp+8h] [ebp-20h]
  int i; // [esp+18h] [ebp-10h]
  void *s1; // [esp+1Ch] [ebp-Ch]

  s1 = 0;
  v3 = stderr;
  v4 = gettext("Valid arguments are:");
  fputs_unlocked(v4, v3);
  for ( i = 0; *(_DWORD *)(4 * i + a1); ++i )
  {
    if ( i && (v6 = (const void *)(a2 + i * n), !memcmp(s1, v6, n)) )
    {
      v7 = sub_805BBBF(*(_DWORD *)(4 * i + a1));
      fprintf(stderr, ", %s", v7);
    }
    else
    {
      v7 = sub_805BBBF(*(_DWORD *)(4 * i + a1));
      fprintf(stderr, "\n  - %s", v7);
      s1 = (void *)(i * n + a2);
    }
  }
  return putc_unlocked(10, stderr);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (080558E3) --------------------------------------------------------
int __cdecl sub_80558E3(int a1, char *s, int a3, int a4, size_t n, int a6)
{
  int v7; // [esp+1Ch] [ebp-Ch]

  v7 = sub_805561E(s, a3, a4, n);
  if ( v7 >= 0 )
    return v7;
  sub_8055739(a1, (int)s, v7);
  sub_80557BC(a3, a4, n);
  ((void (*)(void))a6)();
  return -1;
}

//----- (08055A5B) --------------------------------------------------------
int __usercall sub_8055A5B@<eax>(int a1@<ebx>)
{
  int v1; // eax
  bool v2; // zf
  void *v3; // eax
  char *v4; // ebx
  int v5; // eax
  int v6; // eax
  int result; // eax
  int v8; // [esp-8h] [ebp-40h]
  int v9; // [esp-4h] [ebp-3Ch]
  char *v10; // [esp+Ch] [ebp-2Ch]
  char *v11; // [esp+10h] [ebp-28h]
  char *v12; // [esp+2Ch] [ebp-Ch]

  if ( sub_80604BD(stdout) )
  {
    if ( byte_806BF91 == 1 )
    {
      v1 = *__errno_location();
      v2 = v1 == 32;
      v9 = v1;
      v8 = a1;
      v3 = &loc_8055ABA;
      if ( v2 )
        v3 = &loc_8055B40;
      dword_806B2D8 = (int)v3;
      sub_8061693();
    }
    v12 = gettext("write error");
    if ( dword_806BF8D )
    {
      v4 = (char *)sub_805B8EA(dword_806BF8D);
      v5 = *__errno_location();
      v11 = v12;
      v10 = v4;
      error(0, v5, "%s: %s", v4, v12);
    }
    else
    {
      v6 = *__errno_location();
      v10 = v12;
      error(0, v6, "%s", v12);
    }
    _exit(status);
  }
  result = sub_80604BD(stderr);
  if ( result )
    _exit(status);
  return result;
}
// 8061693: using guessed type int sub_8061693(void);
// 806B2D8: using guessed type int dword_806B2D8;
// 806BF8D: using guessed type int dword_806BF8D;
// 806BF91: using guessed type char byte_806BF91;

//----- (08055B64) --------------------------------------------------------
_DWORD *__cdecl sub_8055B64(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 1732584193;
  a1[1] = -271733879;
  a1[2] = -1732584194;
  a1[3] = 271733878;
  a1[5] = 0;
  a1[4] = a1[5];
  result = a1;
  a1[6] = 0;
  return result;
}

//----- (08055BC0) --------------------------------------------------------
_DWORD *__cdecl sub_8055BC0(_DWORD *a1, int a2)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = a2;
  return result;
}

//----- (08055BCD) --------------------------------------------------------
_DWORD *__cdecl sub_8055BCD(int *a1, _DWORD *a2)
{
  sub_8055BC0(a2, *a1);
  sub_8055BC0(a2 + 1, a1[1]);
  sub_8055BC0(a2 + 2, a1[2]);
  sub_8055BC0(a2 + 3, a1[3]);
  return a2;
}

//----- (08055C4A) --------------------------------------------------------
_DWORD *__cdecl sub_8055C4A(int *a1, _DWORD *a2)
{
  signed int v2; // eax
  unsigned int v4; // [esp+18h] [ebp-10h]
  signed int v5; // [esp+1Ch] [ebp-Ch]

  v4 = a1[6];
  if ( v4 > 0x37 )
    v2 = 32;
  else
    v2 = 16;
  v5 = v2;
  a1[4] += v4;
  if ( a1[4] < v4 )
    ++a1[5];
  a1[v2 + 5] = 8 * a1[4];
  a1[v2 + 6] = *((_QWORD *)a1 + 2) >> 29;
  memcpy((char *)a1 + v4 + 28, &unk_80640F0, 4 * (v2 + 1073741822) - v4);
  sub_80561CB(a1 + 7, 4 * v5, a1);
  return sub_8055BCD(a1, a2);
}

//----- (08055F4F) --------------------------------------------------------
#error "8055FFA: call analysis failed (funcsize=137)"

//----- (080561CB) --------------------------------------------------------
int *__cdecl sub_80561CB(int *a1, unsigned int a2, int *a3)
{
  int v3; // ST30_4
  int v4; // ST34_4
  int v5; // ST38_4
  int v6; // ST3C_4
  int v7; // ST40_4
  int v8; // ST10_4
  int *v9; // ST0C_4
  int v10; // ST10_4
  int v11; // ST1C_4
  int v12; // ST18_4
  int v13; // ST14_4
  int v14; // ST10_4
  int v15; // ST1C_4
  int v16; // ST18_4
  int v17; // ST14_4
  int v18; // ST10_4
  int v19; // ST1C_4
  int v20; // ST18_4
  int v21; // ST14_4
  int v22; // ST10_4
  int v23; // ST1C_4
  int v24; // ST18_4
  int v25; // ST14_4
  int v26; // ST10_4
  int v27; // ST1C_4
  int v28; // ST18_4
  int v29; // ST14_4
  int v30; // ST10_4
  int v31; // ST1C_4
  int v32; // ST18_4
  int v33; // ST14_4
  int v34; // ST10_4
  int v35; // ST1C_4
  int v36; // ST18_4
  int v37; // ST14_4
  int v38; // ST10_4
  int v39; // ST1C_4
  int v40; // ST18_4
  int v41; // ST14_4
  int v42; // ST10_4
  int v43; // ST1C_4
  int v44; // ST18_4
  int v45; // ST14_4
  int v46; // ST10_4
  int v47; // ST1C_4
  int v48; // ST18_4
  int v49; // ST14_4
  int v50; // ST10_4
  int v51; // ST1C_4
  int v52; // ST18_4
  int v53; // ST14_4
  int v54; // ST10_4
  int v55; // ST1C_4
  int v56; // ST18_4
  int v57; // ST14_4
  int v58; // ST10_4
  int v59; // ST1C_4
  int v60; // ST18_4
  int v61; // ST14_4
  int v62; // ST10_4
  int v63; // ST1C_4
  int v64; // ST18_4
  int v65; // ST14_4
  int v66; // ST10_4
  int v67; // ST1C_4
  int v68; // ST18_4
  int v69; // ST14_4
  int v70; // ST10_4
  int v71; // ST1C_4
  int v72; // ST18_4
  int v73; // ST14_4
  int *result; // eax
  int *v75; // [esp+Ch] [ebp-74h]
  int v76; // [esp+10h] [ebp-70h]
  int v77; // [esp+14h] [ebp-6Ch]
  int v78; // [esp+18h] [ebp-68h]
  int v79; // [esp+1Ch] [ebp-64h]
  int v80; // [esp+44h] [ebp-3Ch]
  int v81; // [esp+48h] [ebp-38h]
  int v82; // [esp+4Ch] [ebp-34h]
  int v83; // [esp+50h] [ebp-30h]
  int v84; // [esp+54h] [ebp-2Ch]
  int v85; // [esp+58h] [ebp-28h]
  int v86; // [esp+5Ch] [ebp-24h]
  int v87; // [esp+60h] [ebp-20h]
  int v88; // [esp+64h] [ebp-1Ch]
  int v89; // [esp+68h] [ebp-18h]
  int v90; // [esp+6Ch] [ebp-14h]
  int v91; // [esp+70h] [ebp-10h]
  int v92; // [esp+74h] [ebp-Ch]
  int v93; // [esp+78h] [ebp-8h]
  int v94; // [esp+7Ch] [ebp-4h]

  v75 = a1;
  v76 = *a3;
  v77 = a3[1];
  v78 = a3[2];
  v79 = a3[3];
  a3[4] += a2;
  a3[5] += a3[4] < a2;
  while ( v75 < &a1[a2 >> 2] )
  {
    v3 = v76;
    v4 = v77;
    v5 = v78;
    v6 = v79;
    v7 = *v75;
    v8 = (v79 ^ v77 & (v78 ^ v79)) + *v75 + v76 - 680876936;
    v9 = v75 + 1;
    v10 = v77 + __ROR4__(v8, 25);
    v80 = *v9;
    ++v9;
    v11 = v10 + __ROR4__((v78 ^ v10 & (v77 ^ v78)) + v80 + v79 - 389564586, 20);
    v81 = *v9;
    ++v9;
    v12 = v11 + __ROR4__((v77 ^ v11 & (v10 ^ v77)) + v81 + v78 + 606105819, 15);
    v82 = *v9;
    ++v9;
    v13 = v12 + __ROR4__((v10 ^ v12 & (v11 ^ v10)) + v82 + v77 - 1044525330, 10);
    v83 = *v9;
    ++v9;
    v14 = v13 + __ROR4__((v11 ^ v13 & (v12 ^ v11)) + v83 + v10 - 176418897, 25);
    v84 = *v9;
    ++v9;
    v15 = v14 + __ROR4__((v12 ^ v14 & (v13 ^ v12)) + v84 + v11 + 1200080426, 20);
    v85 = *v9;
    ++v9;
    v16 = v15 + __ROR4__((v13 ^ v15 & (v14 ^ v13)) + v85 + v12 - 1473231341, 15);
    v86 = *v9;
    ++v9;
    v17 = v16 + __ROR4__((v14 ^ v16 & (v15 ^ v14)) + v86 + v13 - 45705983, 10);
    v87 = *v9;
    ++v9;
    v18 = v17 + __ROR4__((v15 ^ v17 & (v16 ^ v15)) + v87 + v14 + 1770035416, 25);
    v88 = *v9;
    ++v9;
    v19 = v18 + __ROR4__((v16 ^ v18 & (v17 ^ v16)) + v88 + v15 - 1958414417, 20);
    v89 = *v9;
    ++v9;
    v20 = v19 + __ROR4__((v17 ^ v19 & (v18 ^ v17)) + v89 + v16 - 42063, 15);
    v90 = *v9;
    ++v9;
    v21 = v20 + __ROR4__((v18 ^ v20 & (v19 ^ v18)) + v90 + v17 - 1990404162, 10);
    v91 = *v9;
    ++v9;
    v22 = v21 + __ROR4__((v19 ^ v21 & (v20 ^ v19)) + v91 + v18 + 1804603682, 25);
    v92 = *v9;
    ++v9;
    v23 = v22 + __ROR4__((v20 ^ v22 & (v21 ^ v20)) + v92 + v19 - 40341101, 20);
    v93 = *v9;
    ++v9;
    v24 = v23 + __ROR4__((v21 ^ v23 & (v22 ^ v21)) + v93 + v20 - 1502002290, 15);
    v94 = *v9;
    v75 = v9 + 1;
    v25 = v24 + __ROR4__((v22 ^ v24 & (v23 ^ v22)) + v94 + v21 + 1236535329, 10);
    v26 = v25 + __ROR4__(v80 + (v24 ^ v23 & (v25 ^ v24)) + v22 - 165796510, 27);
    v27 = v26 + __ROR4__(v85 + (v25 ^ v24 & (v26 ^ v25)) + v23 - 1069501632, 23);
    v28 = v27 + __ROR4__(v90 + (v26 ^ v25 & (v27 ^ v26)) + v24 + 643717713, 18);
    v29 = v28 + __ROR4__(v7 + (v27 ^ v26 & (v28 ^ v27)) + v25 - 373897302, 12);
    v30 = v29 + __ROR4__(v84 + (v28 ^ v27 & (v29 ^ v28)) + v26 - 701558691, 27);
    v31 = v30 + __ROR4__(v89 + (v29 ^ v28 & (v30 ^ v29)) + v27 + 38016083, 23);
    v32 = v31 + __ROR4__(v94 + (v30 ^ v29 & (v31 ^ v30)) + v28 - 660478335, 18);
    v33 = v32 + __ROR4__(v83 + (v31 ^ v30 & (v32 ^ v31)) + v29 - 405537848, 12);
    v34 = v33 + __ROR4__(v88 + (v32 ^ v31 & (v33 ^ v32)) + v30 + 568446438, 27);
    v35 = v34 + __ROR4__(v93 + (v33 ^ v32 & (v34 ^ v33)) + v31 - 1019803690, 23);
    v36 = v35 + __ROR4__(v82 + (v34 ^ v33 & (v35 ^ v34)) + v32 - 187363961, 18);
    v37 = v36 + __ROR4__(v87 + (v35 ^ v34 & (v36 ^ v35)) + v33 + 1163531501, 12);
    v38 = v37 + __ROR4__(v92 + (v36 ^ v35 & (v37 ^ v36)) + v34 - 1444681467, 27);
    v39 = v38 + __ROR4__(v81 + (v37 ^ v36 & (v38 ^ v37)) + v35 - 51403784, 23);
    v40 = v39 + __ROR4__(v86 + (v38 ^ v37 & (v39 ^ v38)) + v36 + 1735328473, 18);
    v41 = v40 + __ROR4__(v91 + (v39 ^ v38 & (v40 ^ v39)) + v37 - 1926607734, 12);
    v42 = v41 + __ROR4__(v84 + (v39 ^ v41 ^ v40) + v38 - 378558, 28);
    v43 = v42 + __ROR4__(v87 + (v40 ^ v42 ^ v41) + v39 - 2022574463, 21);
    v44 = v43 + __ROR4__(v90 + (v41 ^ v43 ^ v42) + v40 + 1839030562, 16);
    v45 = v44 + __ROR4__(v93 + (v42 ^ v44 ^ v43) + v41 - 35309556, 9);
    v46 = v45 + __ROR4__(v80 + (v43 ^ v45 ^ v44) + v42 - 1530992060, 28);
    v47 = v46 + __ROR4__(v83 + (v44 ^ v46 ^ v45) + v43 + 1272893353, 21);
    v48 = v47 + __ROR4__(v86 + (v45 ^ v47 ^ v46) + v44 - 155497632, 16);
    v49 = v48 + __ROR4__(v89 + (v46 ^ v48 ^ v47) + v45 - 1094730640, 9);
    v50 = v49 + __ROR4__(v92 + (v47 ^ v49 ^ v48) + v46 + 681279174, 28);
    v51 = v50 + __ROR4__(v7 + (v48 ^ v50 ^ v49) + v47 - 358537222, 21);
    v52 = v51 + __ROR4__(v82 + (v49 ^ v51 ^ v50) + v48 - 722521979, 16);
    v53 = v52 + __ROR4__(v85 + (v50 ^ v52 ^ v51) + v49 + 76029189, 9);
    v54 = v53 + __ROR4__(v88 + (v51 ^ v53 ^ v52) + v50 - 640364487, 28);
    v55 = v54 + __ROR4__(v91 + (v52 ^ v54 ^ v53) + v51 - 421815835, 21);
    v56 = v55 + __ROR4__(v94 + (v53 ^ v55 ^ v54) + v52 + 530742520, 16);
    v57 = v56 + __ROR4__(v81 + (v54 ^ v56 ^ v55) + v53 - 995338651, 9);
    v58 = v57 + __ROR4__(v7 + (v56 ^ (v57 | ~v55)) + v54 - 198630844, 26);
    v59 = v58 + __ROR4__(v86 + (v57 ^ (v58 | ~v56)) + v55 + 1126891415, 22);
    v60 = v59 + __ROR4__(v93 + (v58 ^ (v59 | ~v57)) + v56 - 1416354905, 17);
    v61 = v60 + __ROR4__(v84 + (v59 ^ (v60 | ~v58)) + v57 - 57434055, 11);
    v62 = v61 + __ROR4__(v91 + (v60 ^ (v61 | ~v59)) + v58 + 1700485571, 26);
    v63 = v62 + __ROR4__(v82 + (v61 ^ (v62 | ~v60)) + v59 - 1894986606, 22);
    v64 = v63 + __ROR4__(v89 + (v62 ^ (v63 | ~v61)) + v60 - 1051523, 17);
    v65 = v64 + __ROR4__(v80 + (v63 ^ (v64 | ~v62)) + v61 - 2054922799, 11);
    v66 = v65 + __ROR4__(v87 + (v64 ^ (v65 | ~v63)) + v62 + 1873313359, 26);
    v67 = v66 + __ROR4__(v94 + (v65 ^ (v66 | ~v64)) + v63 - 30611744, 22);
    v68 = v67 + __ROR4__(v85 + (v66 ^ (v67 | ~v65)) + v64 - 1560198380, 17);
    v69 = v68 + __ROR4__(v92 + (v67 ^ (v68 | ~v66)) + v65 + 1309151649, 11);
    v70 = v69 + __ROR4__(v83 + (v68 ^ (v69 | ~v67)) + v66 - 145523070, 26);
    v71 = v70 + __ROR4__(v90 + (v69 ^ (v70 | ~v68)) + v67 - 1120210379, 22);
    v72 = v71 + __ROR4__(v81 + (v70 ^ (v71 | ~v69)) + v68 + 718787259, 17);
    v73 = v72 + __ROR4__(v88 + (v71 ^ (v72 | ~v70)) + v69 - 343485551, 11);
    v76 = v3 + v70;
    v77 = v4 + v73;
    v78 = v5 + v72;
    v79 = v6 + v71;
  }
  *a3 = v76;
  a3[1] = v77;
  a3[2] = v78;
  result = a3;
  a3[3] = v79;
  return result;
}

//----- (08056EC5) --------------------------------------------------------
int __cdecl sub_8056EC5(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // [esp+20h] [ebp-28h]
  int v8; // [esp+24h] [ebp-24h]
  int v9; // [esp+2Ch] [ebp-1Ch]

  v9 = a3;
  v7 = a4;
  v8 = a5;
  return posix_fadvise64(a1, a2, a3, a4, a5, a6);
}
// 8049E60: using guessed type int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (08056F26) --------------------------------------------------------
void __cdecl sub_8056F26(FILE *stream, int a2)
{
  int v2; // eax

  if ( stream )
  {
    v2 = fileno(stream);
    sub_8056EC5(v2, 0, 0, 0, 0, a2);
  }
}

//----- (08056F6E) --------------------------------------------------------
_BYTE *__usercall sub_8056F6E@<eax>(int a1@<edx>, int a2@<ecx>, int *a3)
{
  void *v3; // eax
  char v5; // [esp+1Bh] [ebp-Dh]
  _BYTE *v6; // [esp+1Ch] [ebp-Ch]

  v6 = 0;
  v5 = 0;
  while ( *(_BYTE *)*a3 )
  {
    if ( v5 )
    {
      v5 = 0;
      if ( (unsigned __int8)sub_806022B(a1, a2, *(char *)*a3) ^ 1 && *(_BYTE *)*a3 != 126 )
        v6 = 0;
    }
    else
    {
      v3 = &loc_8056FF6;
      if ( *(_BYTE *)*a3 != 46 )
        v3 = &loc_805700A;
      dword_806B2A4 = (int)v3;
      sub_8061819(a2, a1);
      v5 = 1;
      if ( !v6 )
        v6 = (_BYTE *)*a3;
    }
    a1 = *a3 + 1;
    *a3 = a1;
  }
  return v6;
}
// 8061819: using guessed type int __fastcall sub_8061819(_DWORD, _DWORD);
// 806B2A4: using guessed type int dword_806B2A4;

//----- (08057059) --------------------------------------------------------
int __cdecl sub_8057059(unsigned __int8 a1)
{
  char v1; // al
  int v2; // edx
  int v3; // ecx
  int result; // eax

  v1 = sub_80602C8(a1);
  _CF = 0;
  _OF = 0;
  _ZF = v1 == 0;
  _SF = v1 < 0;
  if ( v1 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  else if ( (unsigned __int8)sub_806022B(v2, v3, a1) )
  {
    result = a1;
  }
  else if ( a1 == 126 )
  {
    result = -1;
  }
  else
  {
    result = a1 + 256;
  }
  return result;
}

//----- (080570AB) --------------------------------------------------------
int __cdecl sub_80570AB(int a1, unsigned int a2, int a3, unsigned int a4)
{
  int v8; // eax
  int v13; // eax
  int result; // eax
  int v15; // edx
  int v16; // ecx
  void *v17; // eax
  int v22; // [esp+0h] [ebp-38h]
  int v23; // [esp+4h] [ebp-34h]
  unsigned int v24; // [esp+1Ch] [ebp-1Ch]
  unsigned int v25; // [esp+20h] [ebp-18h]
  int v26; // [esp+24h] [ebp-14h]
  int v27; // [esp+28h] [ebp-10h]

  v24 = 0;
  v25 = 0;
  while ( 1 )
  {
    if ( v24 >= a2 )
    {
      _CF = v25 < a4;
      _OF = __OFSUB__(v25, a4);
      _ZF = v25 == a4;
      _SF = (signed int)(v25 - a4) < 0;
      if ( v25 >= a4 )
        break;
    }
    v26 = 0;
    while ( v24 < a2 && (unsigned __int8)sub_80602C8(*(char *)(a1 + v24)) ^ 1 )
    {
      _CF = v24 < a2;
      _OF = __OFSUB__(v24, a2);
      _ZF = v24 == a2;
      _SF = (signed int)(v24 - a2) < 0;
      if ( v24 == a2 )
      {
        __asm { pushfw }
        v8 = 0;
        __asm { popfw }
      }
      else
      {
        v8 = sub_8057059(*(_BYTE *)(a1 + v24));
      }
      v27 = v8;
      _CF = v25 < a4;
      _OF = __OFSUB__(v25, a4);
      _ZF = v25 == a4;
      _SF = (signed int)(v25 - a4) < 0;
      if ( v25 == a4 )
      {
        __asm { pushfw }
        v13 = 0;
        __asm { popfw }
      }
      else
      {
        v13 = sub_8057059(*(_BYTE *)(a3 + v25));
      }
      if ( v27 != v13 )
        return v27 - v13;
      ++v24;
      ++v25;
    }
    if ( v25 < a4 )
    {
      _ZF = (unsigned __int8)sub_80602C8(*(char *)(a3 + v25)) == 1;
      v17 = &loc_80571A5;
      if ( !_ZF )
        v17 = &loc_80570CD;
      dword_806B220 = (int)v17;
      sub_8061B4D(v16, v15, v22, v23);
    }
    while ( *(_BYTE *)(a1 + v24) == 48 )
      ++v24;
    while ( *(_BYTE *)(a3 + v25) == 48 )
      ++v25;
    while ( (unsigned __int8)sub_80602C8(*(char *)(a1 + v24)) && (unsigned __int8)sub_80602C8(*(char *)(a3 + v25)) )
    {
      if ( !v26 )
        v26 = *(char *)(a1 + v24) - *(char *)(a3 + v25);
      ++v24;
      ++v25;
    }
    if ( (unsigned __int8)sub_80602C8(*(char *)(a1 + v24)) )
      return 1;
    if ( (unsigned __int8)sub_80602C8(*(char *)(a3 + v25)) )
      return -1;
    if ( v26 )
      return v26;
  }
  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}
// 806B220: using guessed type int dword_806B220;

//----- (080572B3) --------------------------------------------------------
int __cdecl sub_80572B3(char *s1, char *s2)
{
  int v2; // edx
  int v3; // ecx
  int v4; // ST28_4
  int result; // eax
  void *v10; // eax

  v4 = strcmp(s1, s2);
  _CF = 0;
  _OF = 0;
  _ZF = v4 == 0;
  _SF = v4 < 0;
  if ( v4 )
  {
    if ( *s1 )
    {
      v10 = &loc_8057326;
      if ( *s2 )
        v10 = &loc_8057330;
      dword_806B27C = (int)v10;
      sub_806190F(v3, v2);
      result = 1;
    }
    else
    {
      result = -1;
    }
  }
  else
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 806190F: using guessed type double __fastcall sub_806190F(_DWORD, _DWORD);
// 806B27C: using guessed type int dword_806B27C;

//----- (08057563) --------------------------------------------------------
int __cdecl sub_8057563(int category)
{
  unsigned __int8 v2; // [esp+1Bh] [ebp-Dh]
  const char *s1; // [esp+1Ch] [ebp-Ch]

  v2 = 1;
  s1 = setlocale(category, 0);
  if ( s1 && (!strcmp(s1, "C") || !strcmp(s1, "POSIX")) )
    v2 = 0;
  return v2;
}

//----- (080575C1) --------------------------------------------------------
int __cdecl sub_80575C1(int a1)
{
  return *(_DWORD *)(a1 + 8);
}

//----- (080575CC) --------------------------------------------------------
int __cdecl sub_80575CC(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (080575D7) --------------------------------------------------------
int __cdecl sub_80575D7(int a1)
{
  return *(_DWORD *)(a1 + 16);
}

//----- (080575E2) --------------------------------------------------------
unsigned int __cdecl sub_80575E2(int a1)
{
  _DWORD *i; // [esp+0h] [ebp-10h]
  unsigned int v3; // [esp+4h] [ebp-Ch]
  _DWORD *v4; // [esp+8h] [ebp-8h]
  unsigned int j; // [esp+Ch] [ebp-4h]

  v3 = 0;
  for ( i = *(_DWORD **)a1; *(_DWORD *)(a1 + 4) > (unsigned int)i; i += 2 )
  {
    if ( *i )
    {
      v4 = i;
      for ( j = 1; ; ++j )
      {
        v4 = (_DWORD *)v4[1];
        if ( !v4 )
          break;
      }
      if ( j > v3 )
        v3 = j;
    }
  }
  return v3;
}

//----- (080577D8) --------------------------------------------------------
int __cdecl sub_80577D8(int a1, int a2)
{
  int v3; // [esp-14h] [ebp-20h]
  int v4; // [esp-10h] [ebp-1Ch]
  int v5; // [esp-Ch] [ebp-18h]
  int v6; // [esp-8h] [ebp-14h]
  int v7; // [esp-4h] [ebp-10h]
  int v8; // [esp+0h] [ebp-Ch]
  unsigned int v9; // [esp+0h] [ebp-Ch]
  int v10; // [esp+4h] [ebp-8h]
  int v11; // [esp+8h] [ebp-4h]

  v9 = (*(int (__stdcall **)(int, _DWORD, int, int, int, int, int, int, int, int))(a1 + 24))(
         a2,
         *(_DWORD *)(a1 + 8),
         v3,
         v4,
         v5,
         v6,
         v7,
         v8,
         v10,
         v11);
  if ( *(_DWORD *)(a1 + 8) <= v9 )
    abort();
  return 8 * v9 + *(_DWORD *)a1;
}

//----- (08057B53) --------------------------------------------------------
bool __cdecl sub_8057B53(unsigned int a1)
{
  int v1; // ST0C_4
  unsigned int v3; // [esp+8h] [ebp-8h]
  unsigned int v4; // [esp+Ch] [ebp-4h]

  v3 = 3;
  v4 = 9;
  while ( v4 < a1 && a1 % v3 )
  {
    v1 = v3 + 1;
    v4 += 4 * v1;
    v3 = v1 + 1;
  }
  return a1 % v3 != 0;
}

//----- (08057BAC) --------------------------------------------------------
unsigned int __usercall sub_8057BAC@<eax>(int a1@<edx>, int a2@<ecx>, unsigned int a3)
{
  bool v3; // zf
  int v4; // edx
  int v5; // ecx
  void *v6; // eax
  int v8; // [esp+0h] [ebp-4h]
  int savedregs; // [esp+4h] [ebp+0h]
  unsigned int v10; // [esp+Ch] [ebp+8h]

  if ( a3 <= 9 )
    a3 = 10;
  dword_806B27C = (int)&loc_8057BDE;
  sub_806190F(a2, a1);
  v10 = (a3 | 1) + 2;
  if ( v10 != -1 )
  {
    v3 = sub_8057B53(v10) == 1;
    v6 = &loc_8057C0F;
    if ( !v3 )
      v6 = &loc_8057BDA;
    dword_806B220 = (int)v6;
    sub_8061B4D(v5, v4, v8, savedregs);
  }
  return v10;
}
// 806190F: using guessed type double __fastcall sub_806190F(_DWORD, _DWORD);
// 806B220: using guessed type int dword_806B220;
// 806B27C: using guessed type int dword_806B27C;

//----- (08057C5B) --------------------------------------------------------
unsigned int __cdecl sub_8057C5B(int a1, unsigned int a2)
{
  return sub_80600BA(a1, 3) % a2;
}

//----- (08057C87) --------------------------------------------------------
bool __cdecl sub_8057C87(int a1, int a2)
{
  return a1 == a2;
}

//----- (08057C95) --------------------------------------------------------
signed int __cdecl sub_8057C95(int a1)
{
  long double v3; // fst6
  long double v6; // fst7
  long double v7; // fst6
  long double v8; // fst7
  long double v9; // fst6
  long double v10; // fst6
  long double v11; // fst7
  long double v12; // fst6
  long double v13; // fst7
  long double v14; // fst7
  long double v15; // fst6
  signed int result; // eax
  int v17; // [esp+8h] [ebp-8h]
  float v18; // [esp+Ch] [ebp-4h]

  v17 = *(_DWORD *)(a1 + 20);
  _OF = __OFSUB__(v17, &unk_8064140);
  _SF = v17 - (signed int)&unk_8064140 < 0;
  if ( (_UNKNOWN *)v17 == &unk_8064140 )
  {
    dword_806B2D8 = (int)&locret_8057D62;
    sub_8061693();
  }
  v18 = 0.1;
  v3 = *(float *)(v17 + 8);
  _CF = v3 < 0.1;
  _ZF = v3 == 0.1;
  if ( v3 > 0.1 )
  {
    v6 = *(float *)(v17 + 8);
    v7 = 1.0 - v18;
    _CF = v7 < v6;
    _ZF = v7 == v6;
    if ( v7 > v6 )
    {
      v8 = v18 + 1.0;
      v9 = *(float *)(v17 + 12);
      _CF = v9 < v8;
      _ZF = v9 == v8;
      if ( v9 > v8 )
      {
        v10 = *(float *)v17;
        _CF = v10 < 0.0;
        _ZF = v10 == 0.0;
        if ( v10 >= 0.0 )
        {
          v11 = *(float *)v17 + v18;
          v12 = *(float *)(v17 + 4);
          _CF = v12 < v11;
          _ZF = v12 == v11;
          if ( v12 > v11 )
          {
            v13 = *(float *)(v17 + 4);
            _CF = 1.0 < v13;
            _ZF = 1.0 == v13;
            if ( v13 <= 1.0 )
            {
              v14 = *(float *)v17 + v18;
              v15 = *(float *)(v17 + 8);
              _CF = v15 < v14;
              _ZF = v15 == v14;
              if ( v15 > v14 )
                return 1;
            }
          }
        }
      }
    }
  }
  *(_DWORD *)(a1 + 20) = &unk_8064140;
  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}
// 8061693: using guessed type int sub_8061693(void);
// 806B2D8: using guessed type int dword_806B2D8;

//----- (08057D64) --------------------------------------------------------
unsigned int __usercall sub_8057D64@<eax>(signed __int64 a1@<edx:eax>, int a2@<ecx>, unsigned int a3, int a4)
{
  unsigned int result; // eax
  float v13; // [esp+20h] [ebp-4h]
  unsigned int v14; // [esp+2Ch] [ebp+8h]

  _OF = 0;
  _SF = ((*(_BYTE *)(a4 + 16) ^ 1) & 0x80u) != 0;
  if ( *(_BYTE *)(a4 + 16) != 1 )
  {
    v13 = (long double)a3 / *(float *)(a4 + 8);
    _CF = v13 < 4294967300.0;
    _ZF = v13 == 4294967300.0;
    if ( v13 >= 4294967300.0 )
    {
      __asm { pushfw }
      result = 0;
      __asm { popfw }
      return result;
    }
    a1 = (signed __int64)v13;
    a3 = a1;
  }
  v14 = sub_8057BAC(SHIDWORD(a1), a2, a3);
  _CF = v14 < 0x1FFFFFFF;
  _OF = __OFSUB__(v14, 0x1FFFFFFF);
  _ZF = v14 == 0x1FFFFFFF;
  _SF = (signed int)(v14 - 0x1FFFFFFF) < 0;
  if ( v14 <= 0x1FFFFFFF )
    return v14;
  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}

//----- (08057E14) --------------------------------------------------------
int __usercall sub_8057E14@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, int a6)
{
  void *v6; // eax
  int v7; // edx
  int v8; // ecx
  int result; // eax
  void *v14; // eax
  void *v15; // eax
  _DWORD *ptr; // [esp+1Ch] [ebp-Ch]

  v6 = &loc_8057E46;
  if ( a6 )
    v6 = &loc_8057E4D;
  dword_806B27C = (int)v6;
  sub_806190F(a2, a1);
  ptr = malloc(0x28u);
  _CF = 0;
  _OF = 0;
  _ZF = ptr == 0;
  _SF = (signed int)ptr < 0;
  if ( ptr )
  {
    v14 = &loc_8057E8C;
    if ( a4 )
      v14 = &loc_8057E93;
    dword_806B2A4 = (int)v14;
    sub_8061819(v8, v7);
    ptr[5] = &unk_8064140;
    _ZF = (unsigned __int8)sub_8057C95((int)ptr) == 1;
    v15 = &loc_8057ED7;
    if ( _ZF )
      v15 = &loc_8057EDC;
    dword_806B2C4 = (int)v15;
    sub_8061709();
    free(ptr);
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  else
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 8057E14: could not find valid save-restore pair for ebx
// 8061819: using guessed type int __fastcall sub_8061819(_DWORD, _DWORD);
// 806190F: using guessed type double __fastcall sub_806190F(_DWORD, _DWORD);
// 806B27C: using guessed type int dword_806B27C;
// 806B2A4: using guessed type int dword_806B2A4;
// 806B2C4: using guessed type int dword_806B2C4;

//----- (080581F1) --------------------------------------------------------
void *__cdecl sub_80581F1(int a1)
{
  int v2; // [esp+1Ch] [ebp-Ch]

  if ( !*(_DWORD *)(a1 + 36) )
    return malloc(8u);
  v2 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(v2 + 4);
  return (void *)v2;
}

//----- (0805822C) --------------------------------------------------------
__int64 __cdecl sub_805822C(__int64 a1)
{
  __int64 result; // rax

  *(_DWORD *)HIDWORD(a1) = 0;
  *(_DWORD *)(HIDWORD(a1) + 4) = *(_DWORD *)(a1 + 36);
  result = a1;
  *(_DWORD *)(a1 + 36) = HIDWORD(a1);
  return result;
}

//----- (0805825F) --------------------------------------------------------
int __cdecl sub_805825F(int a1, int a2, _DWORD *a3, char a4)
{
  unsigned __int8 (*v4)(void); // eax
  void *v5; // eax
  _DWORD *v6; // ecx
  int v7; // edx
  int result; // eax
  unsigned __int8 (__cdecl *v9)(int, _DWORD); // eax
  void *v10; // eax
  int v11; // eax
  int v16; // [esp-4h] [ebp-3Ch]
  __int64 v17; // [esp+0h] [ebp-38h]
  int v18; // [esp+8h] [ebp-30h]
  char v19; // [esp+Ch] [ebp-2Ch]
  int v20; // [esp+10h] [ebp-28h]
  int v21; // [esp+14h] [ebp-24h]
  _DWORD *i; // [esp+18h] [ebp-20h]
  _DWORD *v23; // [esp+1Ch] [ebp-1Ch]
  int v24; // [esp+20h] [ebp-18h]
  unsigned int v25; // [esp+24h] [ebp-14h]
  int v26; // [esp+28h] [ebp-10h]
  _DWORD *v27; // [esp+2Ch] [ebp-Ch]
  int v28; // [esp+30h] [ebp-8h]

  v19 = a4;
  v23 = (_DWORD *)sub_80577D8(a1, a2);
  *a3 = v23;
  if ( !*v23 )
  {
    dword_806B234 = (int)&locret_805841B;
    sub_8061ADD(v17, HIDWORD(v17), v18, *(_DWORD *)&v19, v20, v21, i, v23, v24);
  }
  if ( *v23 == a2 || (v4 = *(unsigned __int8 (**)(void))(a1 + 28), HIDWORD(v17) = *v23, LODWORD(v17) = a2, v4()) )
  {
    v26 = *v23;
    if ( v19 )
    {
      _ZF = v23[1] == 0;
      v16 = v23[1];
      v5 = &loc_8058304;
      if ( _ZF )
        v5 = &loc_8058341;
      dword_806B20C = (int)v5;
      sub_8061BBB(v17, HIDWORD(v17), v18, *(_DWORD *)&v19, v20, v21, i, v23, v24, v25, v26, v27, v28);
      v27 = (_DWORD *)v23[1];
      v6 = v23;
      v7 = v27[1];
      *v23 = *v27;
      v6[1] = v7;
      sub_805822C(__PAIR__((unsigned int)v27, a1));
    }
    result = v26;
  }
  else
  {
    for ( i = v23; ; i = (_DWORD *)i[1] )
    {
      v11 = i[1];
      _CF = 0;
      _OF = 0;
      _ZF = v11 == 0;
      _SF = v11 < 0;
      if ( !v11 )
      {
        __asm { pushfw }
        result = 0;
        __asm { popfw }
        return result;
      }
      if ( *(_DWORD *)i[1] == a2 )
        break;
      v9 = *(unsigned __int8 (__cdecl **)(int, _DWORD))(a1 + 28);
      HIDWORD(v17) = *(_DWORD *)i[1];
      if ( v9(a2, HIDWORD(v17)) )
        break;
    }
    v24 = *(_DWORD *)i[1];
    v16 = v24;
    v10 = &loc_80583C2;
    if ( !v19 )
      v10 = &loc_80583F9;
    dword_806B2D8 = (int)v10;
    sub_8061693();
    v25 = i[1];
    i[1] = *(_DWORD *)(v25 + 4);
    sub_805822C(__PAIR__(v25, a1));
    result = v24;
  }
  return result;
}
// 8061693: using guessed type int sub_8061693(void);
// 8061ADD: using guessed type int __stdcall sub_8061ADD(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8061BBB: using guessed type int __stdcall sub_8061BBB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806B20C: using guessed type int dword_806B20C;
// 806B234: using guessed type int dword_806B234;
// 806B2D8: using guessed type int dword_806B2D8;

//----- (0805841D) --------------------------------------------------------
signed int __cdecl sub_805841D(int a1, int a2, char a3)
{
  void *v3; // eax
  int v5; // [esp+0h] [ebp-38h]
  int v6; // [esp+4h] [ebp-34h]
  int v7; // [esp+8h] [ebp-30h]
  _DWORD v8[3]; // [esp+Ch] [ebp-2Ch]
  int v9; // [esp+10h] [ebp-28h]
  int v10; // [esp+14h] [ebp-24h]
  int *i; // [esp+18h] [ebp-20h]
  int *j; // [esp+1Ch] [ebp-1Ch]
  int v13; // [esp+20h] [ebp-18h]
  int v14; // [esp+20h] [ebp-18h]
  int *v15; // [esp+24h] [ebp-14h]
  int *v16; // [esp+28h] [ebp-10h]
  int v17; // [esp+2Ch] [ebp-Ch]
  int v18; // [esp+30h] [ebp-8h]

  LOBYTE(v8[0]) = a3;
  for ( i = *(int **)a2; *(_DWORD *)(a2 + 4) > (unsigned int)i; i += 2 )
  {
    if ( *i )
    {
      for ( j = (int *)i[1]; j; j = v16 )
      {
        v13 = *j;
        v15 = (int *)sub_80577D8(a1, *j);
        v16 = (int *)j[1];
        if ( *v15 )
        {
          j[1] = v15[1];
          v15[1] = (int)j;
        }
        else
        {
          *v15 = v13;
          ++*(_DWORD *)(a1 + 12);
          sub_805822C(__PAIR__((unsigned int)j, a1));
        }
      }
      v14 = *i;
      i[1] = 0;
      v3 = &loc_8058511;
      if ( !LOBYTE(v8[0]) )
        v3 = &loc_8058516;
      dword_806B20C = (int)v3;
      sub_8061BBB(v5, v6, v7, v8[0], v9, v10, i, 0, v14, v15, v16, v17, v18);
    }
  }
  return 1;
}
// 8061BBB: using guessed type int __stdcall sub_8061BBB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806B20C: using guessed type int dword_806B20C;

//----- (080585C8) --------------------------------------------------------
int __usercall sub_80585C8@<eax>(signed __int64 a1@<edx:eax>, int a2@<ecx>, int a3, unsigned int a4)
{
  unsigned int v4; // eax
  void *v6; // eax
  int result; // eax
  int v11; // [esp+0h] [ebp-48h]
  int v12; // [esp+4h] [ebp-44h]
  int v13; // [esp+8h] [ebp-40h]
  int v14; // [esp+Ch] [ebp-3Ch]
  size_t nmemb; // [esp+10h] [ebp-38h]
  int v16; // [esp+14h] [ebp-34h]
  int v17; // [esp+18h] [ebp-30h]

  LODWORD(a1) = a4;
  v4 = sub_8057D64(a1, a2, a4, *(_DWORD *)(a3 + 20));
  nmemb = v4;
  _ZF = v4 == 0;
  v6 = &loc_8058615;
  if ( !_ZF )
    v6 = &loc_8058620;
  dword_806B268 = (int)v6;
  sub_806197F(v11, v12, v13, v14, nmemb, v16, v17);
  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}
// 806197F: using guessed type int __stdcall sub_806197F(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806B268: using guessed type int dword_806B268;

//----- (08058843) --------------------------------------------------------
signed int __cdecl sub_8058843(unsigned int *a1, int a2, _DWORD *a3)
{
  void *v3; // eax
  signed int result; // eax
  long double v9; // fst7
  long double v10; // fst6
  int v11; // ecx
  long double v12; // fst7
  long double v13; // fst6
  void *v14; // eax
  int v15; // ecx
  __int16 v16; // ax
  signed __int64 v17; // rax
  void *v18; // eax
  int v19; // [esp+0h] [ebp-48h]
  int v20; // [esp+4h] [ebp-44h]
  int v21; // [esp+8h] [ebp-40h]
  int v22; // [esp+Ch] [ebp-3Ch]
  __int64 v23; // [esp+10h] [ebp-38h]
  int v24; // [esp+18h] [ebp-30h]
  __int16 v25; // [esp+1Ch] [ebp-2Ch]
  __int16 v26; // [esp+1Eh] [ebp-2Ah]
  int v27; // [esp+20h] [ebp-28h]
  int v28; // [esp+24h] [ebp-24h]
  int v29; // [esp+28h] [ebp-20h]
  _DWORD *v30; // [esp+2Ch] [ebp-1Ch]
  int v31; // [esp+30h] [ebp-18h]
  unsigned int v32; // [esp+34h] [ebp-14h]
  float v33; // [esp+38h] [ebp-10h]
  _DWORD *v34; // [esp+3Ch] [ebp-Ch]

  if ( !a2 )
    abort();
  v31 = sub_805825F((int)a1, a2, &v30, 0);
  if ( v31 )
  {
    v3 = &loc_805889D;
    if ( !a3 )
      v3 = &loc_80588A5;
    dword_806B290 = (int)v3;
    sub_80618A3();
    *a3 = v31;
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  else
  {
    v23 = a1[3];
    v9 = (long double)v23;
    v10 = *(float *)(a1[5] + 8);
    v23 = a1[2];
    if ( v9 > v10 * (long double)v23 )
    {
      sub_8057C95((int)a1);
      v23 = a1[3];
      v12 = (long double)v23;
      v13 = *(float *)(a1[5] + 8);
      v23 = a1[2];
      if ( v12 > v13 * (long double)v23 )
      {
        v32 = a1[5];
        v14 = &loc_805899A;
        if ( !*(_BYTE *)(v32 + 16) )
          v14 = &loc_80589C9;
        dword_806B27C = (int)v14;
        sub_806190F(v11, 0);
        v33 = (long double)a1[2] * *(float *)(v32 + 12);
        if ( v33 >= 4294967300.0 )
          return -1;
        LOBYTE(v16) = v26;
        HIBYTE(v16) = 12;
        v25 = v16;
        v23 = (signed __int64)v33;
        v17 = (signed __int64)v33;
        LODWORD(v17) = a1;
        if ( (unsigned __int8)sub_80585C8(v17, v15, (int)a1, v23) ^ 1 )
          return -1;
        if ( sub_805825F((int)a1, a2, &v30, 0) )
          abort();
      }
    }
    v18 = &loc_8058AC7;
    if ( !*v30 )
      v18 = &loc_8058B3A;
    dword_806B254 = (int)v18;
    sub_80619F1();
    v34 = sub_80581F1((int)a1);
    if ( !v34 )
    {
      dword_806B20C = (int)&locret_8058B75;
      sub_8061BBB(v19, v20, v21, v22, v23, HIDWORD(v23), v24, *(_DWORD *)&v25, v27, v28, v29, v30, v31);
    }
    *v34 = a2;
    v34[1] = v30[1];
    v30[1] = v34;
    ++a1[4];
    result = 1;
  }
  return result;
}
// 8058843: could not find valid save-restore pair for ebx
// 80618A3: using guessed type int sub_80618A3(void);
// 806190F: using guessed type double __fastcall sub_806190F(_DWORD, _DWORD);
// 80619F1: using guessed type int sub_80619F1(void);
// 8061BBB: using guessed type int __stdcall sub_8061BBB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806B20C: using guessed type int dword_806B20C;
// 806B254: using guessed type int dword_806B254;
// 806B27C: using guessed type int dword_806B27C;
// 806B290: using guessed type int dword_806B290;

//----- (08058B77) --------------------------------------------------------
int __cdecl sub_8058B77(unsigned int *a1, int a2)
{
  int result; // eax
  int v7; // [esp+18h] [ebp-10h]
  unsigned int v8; // [esp+1Ch] [ebp-Ch]

  v8 = sub_8058843(a1, a2, &v7);
  _CF = v8 < 0xFFFFFFFF;
  _OF = __OFSUB__(v8, -1);
  _ZF = v8 == -1;
  _SF = (signed int)(v8 + 1) < 0;
  if ( v8 == -1 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  else if ( v8 )
  {
    result = a2;
  }
  else
  {
    result = v7;
  }
  return result;
}

//----- (08058BB7) --------------------------------------------------------
int __usercall sub_8058BB7@<eax>(int a1@<ebx>, int a2, int a3)
{
  int v3; // ecx
  int result; // eax
  int v9; // eax
  int v10; // edx
  void *v11; // eax
  int v12; // ebx
  long double v13; // fst7
  long double v14; // fst6
  long double v15; // fst7
  long double v16; // fst6
  void *v17; // eax
  long double v18; // fst7
  __int16 v19; // ax
  signed __int64 v20; // rax
  int v21; // ecx
  int v22; // [esp-8h] [ebp-50h]
  int v23; // [esp-4h] [ebp-4Ch]
  unsigned int v24; // [esp+4h] [ebp-44h]
  __int16 v25; // [esp+14h] [ebp-34h]
  __int16 v26; // [esp+16h] [ebp-32h]
  __int64 v27; // [esp+18h] [ebp-30h]
  int *v28; // [esp+28h] [ebp-20h]
  void *ptr; // [esp+2Ch] [ebp-1Ch]
  int v30; // [esp+30h] [ebp-18h]
  int v31; // [esp+34h] [ebp-14h]
  int v32; // [esp+38h] [ebp-10h]
  void *v33; // [esp+3Ch] [ebp-Ch]

  v30 = sub_805825F(a2, a3, &v28, 1);
  _CF = 0;
  _OF = 0;
  _ZF = v30 == 0;
  _SF = v30 < 0;
  if ( v30 )
  {
    v9 = *(_DWORD *)(a2 + 16);
    v10 = v9 - 1;
    *(_DWORD *)(a2 + 16) = v9 - 1;
    _ZF = *v28 == 0;
    v23 = *v28;
    v22 = a1;
    v11 = &loc_8058C43;
    if ( !_ZF )
      v11 = &loc_8058E23;
    dword_806B2A4 = (int)v11;
    v12 = v22;
    sub_8061819(v3, v10);
    v27 = (unsigned int)--*(_DWORD *)(a2 + 12);
    v13 = (long double)v27;
    v14 = **(float **)(a2 + 20);
    v27 = *(unsigned int *)(a2 + 8);
    if ( v14 * (long double)v27 > v13 )
    {
      sub_8057C95(a2);
      v27 = *(unsigned int *)(a2 + 12);
      v15 = (long double)v27;
      v16 = **(float **)(a2 + 20);
      v27 = *(unsigned int *)(a2 + 8);
      if ( v16 * (long double)v27 > v15 )
      {
        v31 = *(_DWORD *)(a2 + 20);
        _ZF = *(_BYTE *)(v31 + 16) == 0;
        v23 = *(unsigned __int8 *)(v31 + 16);
        v22 = v12;
        v17 = &loc_8058D36;
        if ( _ZF )
          v17 = &loc_8058D81;
        dword_806B290 = (int)v17;
        sub_80618A3();
        v27 = *(unsigned int *)(a2 + 8);
        v18 = (long double)v27 * *(float *)(v31 + 4);
        LOBYTE(v19) = v26;
        HIBYTE(v19) = 12;
        v25 = v19;
        v27 = (signed __int64)v18;
        v20 = (signed __int64)v18;
        v32 = (signed __int64)v18;
        v24 = (signed __int64)v18;
        LODWORD(v20) = a2;
        if ( (unsigned __int8)sub_80585C8(v20, v21, a2, v24) ^ 1 )
        {
          for ( ptr = *(void **)(a2 + 36); ptr; ptr = v33 )
          {
            v33 = (void *)*((_DWORD *)ptr + 1);
            free(ptr);
          }
          *(_DWORD *)(a2 + 36) = 0;
        }
      }
    }
    result = v30;
  }
  else
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 8058BB7: could not find valid save-restore pair for ebx
// 8061819: using guessed type int __fastcall sub_8061819(_DWORD, _DWORD);
// 80618A3: using guessed type int sub_80618A3(void);
// 806B290: using guessed type int dword_806B290;
// 806B2A4: using guessed type int dword_806B2A4;

//----- (08058E28) --------------------------------------------------------
_DWORD *__cdecl sub_8058E28(int (*a1)(), unsigned int a2)
{
  int (*v2)(); // eax
  _DWORD *v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_805E4E9(0x10u);
  if ( !a2 )
    a2 = 1;
  *v4 = sub_805E3AE(a2, 4u);
  *(_DWORD *)*v4 = 0;
  v4[1] = a2;
  v4[2] = 0;
  if ( a1 )
    v2 = a1;
  else
    v2 = sub_8058EAD;
  v4[3] = v2;
  return v4;
}

//----- (08058EAD) --------------------------------------------------------
int sub_8058EAD()
{
  int result; // eax

  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}

//----- (08058EB8) --------------------------------------------------------
void __cdecl sub_8058EB8(void *ptr)
{
  free(*(void **)ptr);
  free(ptr);
}

//----- (08058ED8) --------------------------------------------------------
int __cdecl sub_8058ED8(int a1, int a2)
{
  int v2; // edx
  int result; // eax

  if ( (unsigned int)(*(_DWORD *)(a1 + 4) - 1) <= *(_DWORD *)(a1 + 8) )
    *(_DWORD *)a1 = sub_805E413(*(_DWORD *)a1, (unsigned int *)(a1 + 4), 4u);
  v2 = *(_DWORD *)a1;
  *(_DWORD *)(4 * ++*(_DWORD *)(a1 + 8) + v2) = a2;
  sub_8059127(*(_DWORD *)a1, *(_DWORD *)(a1 + 8), *(int (__cdecl **)(int, int))(a1 + 12));
  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}

//----- (08058F72) --------------------------------------------------------
int __usercall sub_8058F72@<eax>(int a1@<edx>, int a2@<ecx>, int *a3)
{
  int v3; // ST20_4
  _DWORD *v4; // ebx
  int v5; // esi
  int v6; // eax
  int v8; // [esp+0h] [ebp-28h]
  int v9; // [esp+4h] [ebp-24h]

  if ( !a3[2] )
  {
    dword_806B220 = (int)&loc_805900D;
    sub_8061B4D(a2, a1, v8, v9);
  }
  v3 = *(_DWORD *)(*a3 + 4);
  v4 = (_DWORD *)(*a3 + 4);
  v5 = *a3;
  v6 = a3[2];
  a3[2] = v6 - 1;
  *v4 = *(_DWORD *)(v5 + 4 * v6);
  sub_8059014(*a3, a3[2], 1u, (int (__cdecl *)(int, int))a3[3]);
  return v3;
}
// 806B220: using guessed type int dword_806B220;

//----- (08059014) --------------------------------------------------------
unsigned int __cdecl sub_8059014(int a1, unsigned int a2, unsigned int a3, int (__cdecl *a4)(int, int))
{
  int v4; // edx
  int v6; // [esp+0h] [ebp-28h]
  unsigned int i; // [esp+14h] [ebp-14h]
  unsigned int v8; // [esp+18h] [ebp-10h]
  int v9; // [esp+1Ch] [ebp-Ch]

  v9 = *(_DWORD *)(4 * a3 + a1);
  for ( i = a3; a2 >> 1 >= i; i = v8 )
  {
    v8 = 2 * i;
    if ( 2 * i < a2 )
    {
      v4 = *(_DWORD *)(4 * (v8 + 1) + a1);
      v6 = *(_DWORD *)(4 * v8 + a1);
      if ( a4(v6, v4) < 0 )
        ++v8;
    }
    v6 = *(_DWORD *)(4 * v8 + a1);
    if ( a4(v6, v9) <= 0 )
      break;
    *(_DWORD *)(a1 + 4 * i) = *(_DWORD *)(4 * v8 + a1);
  }
  *(_DWORD *)(a1 + 4 * i) = v9;
  return i;
}

//----- (08059127) --------------------------------------------------------
int __cdecl sub_8059127(int a1, unsigned int a2, int (__cdecl *a3)(int, int))
{
  int result; // eax
  int v4; // [esp+0h] [ebp-28h]
  unsigned int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]

  v5 = a2;
  v6 = *(_DWORD *)(4 * a2 + a1);
  while ( v5 != 1 )
  {
    v4 = *(_DWORD *)(4 * (v5 >> 1) + a1);
    if ( a3(v4, v6) > 0 )
      break;
    *(_DWORD *)(a1 + 4 * v5) = *(_DWORD *)(4 * (v5 >> 1) + a1);
    v5 >>= 1;
  }
  result = v6;
  *(_DWORD *)(a1 + 4 * v5) = v6;
  return result;
}

//----- (080591E7) --------------------------------------------------------
int __cdecl sub_80591E7(int a1, int a2)
{
  int v3; // [esp+Ch] [ebp-4h]

  v3 = a2 + 11;
  *(_BYTE *)(a2 + 11) = 0;
  if ( a1 >= 0 )
  {
    do
    {
      *(_BYTE *)--v3 = a1 - 10 * (((signed int)((unsigned __int64)(1717986919LL * a1) >> 32) >> 2) - (a1 >> 31)) + 48;
      a1 /= 10;
    }
    while ( a1 );
  }
  else
  {
    do
    {
      *(_BYTE *)--v3 = 48 - a1 % 10;
      a1 /= 10;
    }
    while ( a1 );
    *(_BYTE *)--v3 = 45;
  }
  return v3;
}

//----- (080592E1) --------------------------------------------------------
int __cdecl sub_80592E1(unsigned int a1, int a2)
{
  int v3; // [esp+Ch] [ebp-4h]

  v3 = a2 + 10;
  *(_BYTE *)(a2 + 10) = 0;
  do
  {
    *(_BYTE *)--v3 = a1 % 0xA + 48;
    a1 /= 0xAu;
  }
  while ( a1 );
  return v3;
}

//----- (0805934F) --------------------------------------------------------
int __cdecl sub_805934F(signed __int64 a1, int a2)
{
  signed __int64 v3; // [esp+18h] [ebp-20h]
  int v4; // [esp+2Ch] [ebp-Ch]

  v3 = a1;
  v4 = a2 + 20;
  *(_BYTE *)(a2 + 20) = 0;
  do
  {
    *(_BYTE *)--v4 = sub_806137E(v3, 10LL) + 48;
    v3 = sub_806122B(v3, 0xAu, 0);
  }
  while ( v3 );
  return v4;
}
// 806137E: using guessed type _DWORD __cdecl sub_806137E(__int64, __int64);

//----- (08059422) --------------------------------------------------------
int __cdecl sub_8059422(char *a1, int a2, char a3)
{
  signed int v3; // eax
  char *v5; // eax
  int v6; // eax
  void *v7; // eax
  int v8; // [esp-4h] [ebp-5Ch]
  int v9; // [esp+0h] [ebp-58h]
  int v10; // [esp+4h] [ebp-54h]
  int v11; // [esp+8h] [ebp-50h]
  int v12; // [esp+Ch] [ebp-4Ch]
  int v13; // [esp+10h] [ebp-48h]
  int v14; // [esp+14h] [ebp-44h]
  int v15; // [esp+18h] [ebp-40h]
  char *v16; // [esp+1Ch] [ebp-3Ch]
  int v17; // [esp+20h] [ebp-38h]
  int v18; // [esp+24h] [ebp-34h]
  int v19; // [esp+28h] [ebp-30h]
  wint_t wc; // [esp+2Ch] [ebp-2Ch]
  char *v21; // [esp+30h] [ebp-28h]
  int v22; // [esp+34h] [ebp-24h]
  int v23; // [esp+38h] [ebp-20h]
  char *v24; // [esp+3Ch] [ebp-1Ch]
  int v25; // [esp+40h] [ebp-18h]
  mbstate_t s; // [esp+44h] [ebp-14h]
  unsigned int v27; // [esp+4Ch] [ebp-Ch]

  v16 = a1;
  v27 = __readgsdword(0x14u);
  v21 = a1;
  v24 = &a1[a2];
  v22 = 0;
  if ( __ctype_get_mb_cur_max() <= 1 )
  {
    while ( 1 )
    {
      if ( v21 >= v24 )
        return v22;
      v5 = v21++;
      HIBYTE(v19) = *v5;
      v6 = (*__ctype_b_loc())[HIBYTE(v19)] & 0x4000;
      if ( v6 )
        break;
      if ( a3 & 2 )
        return -1;
      if ( !((*__ctype_b_loc())[HIBYTE(v19)] & 2) )
      {
        if ( v22 != 0x7FFFFFFF )
        {
          ++v22;
          dword_806B20C = (int)&loc_80596A3;
          sub_8061BBB(v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, wc, v21);
          return -1;
        }
        return 0x7FFFFFFF;
      }
    }
    v8 = v6;
    v7 = &loc_8059648;
    if ( v22 != 0x7FFFFFFF )
      v7 = &loc_805964A;
    dword_806B234 = (int)v7;
    sub_8061ADD(v9, v10, v11, v12, v13, v14, v15, v16, v17);
    return 0x7FFFFFFF;
  }
  while ( 1 )
  {
LABEL_31:
    if ( v21 >= v24 )
      return v22;
    v3 = *v21;
    if ( v3 > 63 )
      break;
    if ( v3 < 37 && (unsigned int)(v3 - 32) > 3 )
      goto LABEL_11;
LABEL_10:
    ++v21;
    ++v22;
  }
  if ( v3 >= 65 && (v3 <= 95 || (unsigned int)(v3 - 97) <= 0x1D) )
    goto LABEL_10;
LABEL_11:
  memset(&s, 0, 8u);
  while ( 1 )
  {
    v23 = sub_805F916(&v9 - 11, v21, v24 - v21, &s);
    if ( v23 == -1 )
    {
      if ( !(a3 & 1) )
      {
        ++v21;
        ++v22;
        goto LABEL_31;
      }
      return -1;
    }
    if ( v23 == -2 )
      break;
    if ( !v23 )
      v23 = 1;
    v25 = wcwidth(wc);
    if ( v25 < 0 )
    {
      if ( a3 & 2 )
        return -1;
      if ( !iswcntrl(wc) )
      {
        if ( v22 == 0x7FFFFFFF )
          return 0x7FFFFFFF;
        ++v22;
      }
    }
    else
    {
      if ( 0x7FFFFFFF - v22 < v25 )
        return 0x7FFFFFFF;
      v22 += v25;
    }
    v21 += v23;
    if ( mbsinit(&s) )
      goto LABEL_31;
  }
  if ( !(a3 & 1) )
  {
    v21 = v24;
    ++v22;
    goto LABEL_31;
  }
  return -1;
}
// 8049800: using guessed type int __cdecl wcwidth(_DWORD);
// 8061ADD: using guessed type int __stdcall sub_8061ADD(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8061BBB: using guessed type int __stdcall sub_8061BBB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806B20C: using guessed type int dword_806B20C;
// 806B234: using guessed type int dword_806B234;

//----- (080596CC) --------------------------------------------------------
int sub_80596CC()
{
  int v0; // eax
  int result; // eax
  int v6; // [esp+1Ch] [ebp-8Ch]
  char v7; // [esp+20h] [ebp-88h]

  v0 = sched_getaffinity(0, 128, &v7);
  _CF = 0;
  _OF = 0;
  _ZF = v0 == 0;
  _SF = v0 < 0;
  if ( !v0 )
  {
    v6 = __sched_cpucount(128, &v7);
    _CF = 0;
    _OF = 0;
    _ZF = v6 == 0;
    _SF = v6 < 0;
    if ( v6 )
    {
      dword_806B254 = (int)&locret_805973F;
      sub_80619F1();
    }
  }
  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}
// 80498D0: using guessed type int __cdecl __sched_cpucount(_DWORD, _DWORD);
// 8049E70: using guessed type int __cdecl sched_getaffinity(_DWORD, _DWORD, _DWORD);
// 80619F1: using guessed type int sub_80619F1(void);
// 806B254: using guessed type int dword_806B254;

//----- (08059741) --------------------------------------------------------
signed int __cdecl sub_8059741(int a1)
{
  void *v2; // eax
  int v3; // [esp+10h] [ebp-18h]
  int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]

  if ( a1 == 1 )
  {
    v4 = sub_80596CC();
    if ( v4 )
      return v4;
    v5 = sysconf(84);
    if ( v5 > 0 )
      return v5;
  }
  else
  {
    v3 = sysconf(83);
    v2 = &loc_80597BA;
    if ( v3 != 1 )
      v2 = &loc_80597CE;
    dword_806B254 = (int)v2;
    sub_80619F1();
    v6 = sub_80596CC();
    if ( v6 )
      v3 = v6;
    if ( v3 > 0 )
      return v3;
  }
  return 1;
}
// 80619F1: using guessed type int sub_80619F1(void);
// 806B254: using guessed type int dword_806B254;

//----- (080597E0) --------------------------------------------------------
int __usercall sub_80597E0@<eax>(int a1@<edx>, int a2@<ecx>, char *nptr)
{
  bool v3; // zf
  int v4; // edx
  int v5; // ecx
  void *v6; // eax
  int v7; // edx
  int v8; // ecx
  int result; // eax
  char *endptr; // [esp+14h] [ebp-14h]
  int v11; // [esp+18h] [ebp-10h]
  unsigned int v12; // [esp+1Ch] [ebp-Ch]

  v11 = 0;
  if ( !nptr )
  {
    dword_806B27C = (int)&locret_80598D6;
    sub_806190F(a2, a1);
  }
  if ( *nptr )
  {
    v3 = (unsigned __int8)sub_80603A1(a1, a2, *nptr) == 0;
    v6 = &loc_805984B;
    if ( !v3 )
      v6 = &loc_805980F;
    dword_806B27C = (int)v6;
    sub_806190F(v5, v4);
  }
  if ( !(unsigned __int8)sub_80602C8(*nptr) )
    goto LABEL_20;
  endptr = 0;
  v12 = strtoul(nptr, &endptr, 10);
  if ( !endptr )
    goto LABEL_20;
  while ( *endptr && (unsigned __int8)sub_80603A1(v7, v8, *endptr) )
    ++endptr;
  if ( !*endptr )
    return v12;
  if ( *endptr == 44 )
    result = v12;
  else
LABEL_20:
    result = v11;
  return result;
}
// 806190F: using guessed type double __fastcall sub_806190F(_DWORD, _DWORD);
// 806B27C: using guessed type int dword_806B27C;

//----- (080598D8) --------------------------------------------------------
unsigned int __cdecl sub_80598D8(int a1)
{
  void *v1; // eax
  char *v2; // eax
  int v3; // edx
  int v4; // ecx
  char *v5; // eax
  int v6; // edx
  int v7; // ecx
  int v8; // edx
  int v9; // ecx
  unsigned int result; // eax
  int v11; // [esp+0h] [ebp-28h]
  int v12; // [esp+4h] [ebp-24h]
  unsigned int v13; // [esp+14h] [ebp-14h]
  int v14; // [esp+18h] [ebp-10h]

  v1 = &loc_8059914;
  if ( a1 != 2 )
    v1 = &loc_805997D;
  dword_806B2C4 = (int)v1;
  sub_8061709();
  v2 = getenv("OMP_NUM_THREADS");
  v14 = sub_80597E0(v3, v4, v2);
  v5 = getenv("OMP_THREAD_LIMIT");
  v13 = sub_80597E0(v6, v7, v5);
  if ( !v13 )
    v13 = -1;
  if ( v14 )
  {
    dword_806B220 = (int)&locret_8059995;
    sub_8061B4D(v9, v8, v11, v12);
  }
  result = sub_8059741(1);
  if ( v13 <= result )
    result = v13;
  return result;
}
// 806B220: using guessed type int dword_806B220;
// 806B2C4: using guessed type int dword_806B2C4;

//----- (08059997) --------------------------------------------------------
#error "8059A3B: call analysis failed (funcsize=71)"

//----- (08059AAB) --------------------------------------------------------
#error "8059AAC: positive sp value has been found (funcsize=0)"

//----- (08059AAD) --------------------------------------------------------
long double sub_8059AAD()
{
  double v1; // [esp+18h] [ebp-60h]
  double v2; // [esp+20h] [ebp-58h]
  char v3; // [esp+2Ch] [ebp-4Ch]
  unsigned int v4; // [esp+40h] [ebp-38h]
  unsigned int v5; // [esp+48h] [ebp-30h]
  unsigned int v6; // [esp+60h] [ebp-18h]
  unsigned int v7; // [esp+6Ch] [ebp-Ch]

  v7 = __readgsdword(0x14u);
  v1 = (long double)sysconf(86);
  v2 = (long double)sysconf(30);
  if ( v1 >= 0.0 && v2 >= 0.0 )
    return v1 * v2;
  if ( sysinfo((struct sysinfo *)&v3) )
    return sub_8059997() / 4.0;
  return ((long double)v4 + (long double)v5) * (long double)v6;
}
// 8059997: using guessed type double sub_8059997(void);

//----- (08059B87) --------------------------------------------------------
int __usercall sub_8059B87@<eax>(int a1@<ebx>, int pipedes[2], int a3)
{
  int v4; // edx
  int v5; // ecx
  int v6; // ecx
  int v7; // eax
  int v8; // edx
  int v9; // ecx
  int v10; // ecx
  int v11; // eax
  int v12; // ecx
  bool v13; // zf
  void *v14; // eax
  int v15; // edx
  int v16; // ecx
  int v17; // ecx
  int v18; // edx
  int v19; // ecx
  void *v20; // eax
  int v21; // [esp+0h] [ebp-38h]
  int v22; // [esp+4h] [ebp-34h]
  int v23; // [esp+8h] [ebp-30h]
  int v24; // [esp+Ch] [ebp-2Ch]
  int v25; // [esp+10h] [ebp-28h]
  int v26; // [esp+14h] [ebp-24h]
  int v27; // [esp+18h] [ebp-20h]
  int v28; // [esp+1Ch] [ebp-1Ch]
  int v29; // [esp+20h] [ebp-18h]
  int v30; // [esp+24h] [ebp-14h]
  int v31; // [esp+28h] [ebp-10h]
  int v32; // [esp+2Ch] [ebp-Ch]
  int v33; // [esp+30h] [ebp-8h]

  v31 = *pipedes;
  v32 = pipedes[1];
  if ( dword_806BF95 >= 0 )
  {
    v22 = a3;
    v27 = pipe2(pipedes);
    if ( v27 >= 0 || *__errno_location() != 38 )
    {
      dword_806BF95 = 1;
      return v27;
    }
    dword_806BF95 = -1;
  }
  if ( a3 & 0xFFF7F7FF )
  {
    *__errno_location() = 22;
    return -1;
  }
  if ( pipe(pipedes) < 0 )
    return -1;
  if ( !(a3 & 0x800)
    || (v28 = sub_805F5D6(v4, v5, a1, pipedes[1], 3, 0), v28 >= 0)
    && (v7 = v28, BYTE1(v7) |= 8u, sub_805F5D6(v7, v6, a1, pipedes[1], 4, v7) != -1)
    && (v28 = sub_805F5D6(v8, v9, a1, *pipedes, 3, 0), v28 >= 0)
    && (v11 = v28, BYTE1(v11) |= 8u, sub_805F5D6(v11, v10, a1, *pipedes, 4, v11) != -1) )
  {
    if ( a3 & 0x80000 )
    {
      v29 = sub_805F5D6(v4, v5, a1, pipedes[1], 1, 0);
      if ( v29 < 0 )
        goto LABEL_24;
      v13 = sub_805F5D6(v29 | 1, v12, a1, pipedes[1], 2, v29 | 1) == -1;
      v14 = &loc_8059D71;
      if ( v13 )
        v14 = &loc_8059DF3;
      dword_806B20C = (int)v14;
      sub_8061BBB(v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33);
      v29 = sub_805F5D6(v15, v16, a1, *pipedes, 1, 0);
      if ( v29 < 0 )
        goto LABEL_24;
      v13 = sub_805F5D6(v29 | 1, v17, a1, *pipedes, 2, v29 | 1) == -1;
      v20 = &loc_8059DD6;
      if ( v13 )
        v20 = &loc_8059DF3;
      dword_806B220 = (int)v20;
      sub_8061B4D(v19, v18, v21, v22);
    }
    dword_806B2D8 = (int)&locret_8059E3C;
    sub_8061693();
  }
LABEL_24:
  v30 = *__errno_location();
  close(*pipedes);
  close(pipedes[1]);
  *pipedes = v31;
  pipedes[1] = v32;
  *__errno_location() = v30;
  return -1;
}
// 8049DF0: using guessed type int __cdecl pipe2(_DWORD);
// 8061693: using guessed type int sub_8061693(void);
// 8061BBB: using guessed type int __stdcall sub_8061BBB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806B20C: using guessed type int dword_806B20C;
// 806B220: using guessed type int dword_806B220;
// 806B2D8: using guessed type int dword_806B2D8;
// 806BF95: using guessed type int dword_806BF95;

//----- (08059E3E) --------------------------------------------------------
int sub_8059E3E()
{
  void *v0; // eax
  char *endptr; // [esp+10h] [ebp-18h]
  int v3; // [esp+14h] [ebp-14h]
  char *nptr; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]

  v3 = 200809;
  nptr = getenv("_POSIX2_VERSION");
  if ( nptr && *nptr )
  {
    v5 = strtol(nptr, &endptr, 10);
    v0 = &loc_8059EBA;
    if ( *endptr )
      v0 = &loc_8059EC0;
    dword_806B2C4 = (int)v0;
    sub_8061709();
    v3 = v5;
  }
  return v3;
}
// 806B2C4: using guessed type int dword_806B2C4;

//----- (08059EC5) --------------------------------------------------------
char *__cdecl sub_8059EC5(char *s)
{
  char *v1; // eax
  char *result; // eax
  char *v3; // [esp+18h] [ebp-10h]
  char *s1; // [esp+1Ch] [ebp-Ch]

  if ( !s )
  {
    fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
    abort();
  }
  v3 = strrchr(s, 47);
  if ( v3 )
    v1 = v3 + 1;
  else
    v1 = s;
  s1 = v1;
  if ( v1 - s > 6 && !strncmp(v1 - 7, "/.libs/", 7u) )
  {
    s = s1;
    if ( !strncmp(s1, "lt-", 3u) )
    {
      s = s1 + 3;
      program_invocation_short_name = (int)(s1 + 3);
    }
  }
  dword_806BF99 = (int)s;
  result = s;
  program_invocation_name = (int)s;
  return result;
}
// 806B420: using guessed type int program_invocation_short_name;
// 806B430: using guessed type int program_invocation_name;
// 806BF99: using guessed type int dword_806BF99;

//----- (0805A011) --------------------------------------------------------
unsigned int __cdecl sub_805A011(int a1, unsigned __int8 a2, char a3)
{
  int *v3; // ST08_4
  unsigned int v4; // edx

  if ( a1 )
  {
    dword_806B2C4 = (int)&loc_805A04A;
    sub_8061709();
  }
  v3 = &dword_806BFA9[(a2 >> 5) + 2];
  v4 = (unsigned int)*v3 >> (a2 & 0x1F);
  *v3 ^= (((unsigned int)*v3 >> (a2 & 0x1F)) & 1 ^ a3 & 1) << (a2 & 0x1F);
  return v4 & 1;
}
// 806B2C4: using guessed type int dword_806B2C4;
// 806BFA9: using guessed type int dword_806BFA9[];

//----- (0805A0E0) --------------------------------------------------------
#error "805A110: call analysis failed (funcsize=32)"

//----- (0805A14A) --------------------------------------------------------
_DWORD *__userpurge sub_805A14A@<eax>(_DWORD *a1, int a2)
{
  int v3; // [esp+0h] [ebp-38h]
  int v4; // [esp+4h] [ebp-34h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]

  memset(&v3, 0, 0x30u);
  if ( a2 == 10 )
    abort();
  *a1 = a2;
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = v6;
  a1[4] = v7;
  a1[5] = v8;
  a1[6] = v9;
  a1[7] = v10;
  a1[8] = v11;
  a1[9] = v12;
  a1[10] = v13;
  a1[11] = v14;
  return a1;
}

//----- (0805A1ED) --------------------------------------------------------
char *__cdecl sub_805A1ED(char *msgid, int a2)
{
  char *result; // eax
  int v3; // [esp+0h] [ebp-28h]
  int v4; // [esp+4h] [ebp-24h]
  int v5; // [esp+8h] [ebp-20h]
  int v6; // [esp+Ch] [ebp-1Ch]
  int v7; // [esp+10h] [ebp-18h]
  int v8; // [esp+14h] [ebp-14h]
  char *v9; // [esp+18h] [ebp-10h]
  unsigned __int8 *v10; // [esp+1Ch] [ebp-Ch]

  v9 = gettext(msgid);
  if ( v9 != msgid )
    return v9;
  v10 = (unsigned __int8 *)sub_8060E1B();
  if ( sub_8060457(v10, "UTF-8") )
  {
    if ( sub_8060457(v10, "GB18030") )
    {
      if ( a2 == 9 )
      {
        dword_806B268 = (int)&locret_805A29E;
        sub_806197F(v3, v4, v5, v6, v7, v8, v9);
      }
      result = "'";
    }
    else if ( *msgid == 96 )
    {
      result = (char *)&unk_806434E;
    }
    else
    {
      result = (char *)&unk_8064352;
    }
  }
  else if ( *msgid == 96 )
  {
    result = (char *)&unk_806433E;
  }
  else
  {
    result = (char *)&unk_8064342;
  }
  return result;
}
// 806197F: using guessed type int __stdcall sub_806197F(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806B268: using guessed type int dword_806B268;

//----- (0805A2A0) --------------------------------------------------------
void __cdecl sub_805A2A0(int a1, int a2, int a3, int a4, unsigned int a5, int a6, int a7, int a8, int a9)
{
  bool v9; // ST53_1

  v9 = __ctype_get_mb_cur_max() == 1;
  if ( a5 <= 0xA )
    JUMPOUT(__CS__, off_806435C[a5]);
  abort();
}

//----- (0805A75F) --------------------------------------------------------
void __usercall sub_805A75F(int a1@<ebp>)
{
  *(_BYTE *)(a1 - 67) = *(_BYTE *)(*(_DWORD *)(a1 - 56) + 2 + *(_DWORD *)(a1 - 80));
  *(_DWORD *)(a1 - 56) += 2;
  if ( *(_DWORD *)(a1 - 52) < *(_DWORD *)(a1 + 12) )
    *(_BYTE *)(*(_DWORD *)(a1 - 76) + *(_DWORD *)(a1 - 52)) = 63;
  if ( ++*(_DWORD *)(a1 - 52) < *(_DWORD *)(a1 + 12) )
    *(_BYTE *)(*(_DWORD *)(a1 - 76) + *(_DWORD *)(a1 - 52)) = 34;
  if ( ++*(_DWORD *)(a1 - 52) < *(_DWORD *)(a1 + 12) )
    *(_BYTE *)(*(_DWORD *)(a1 - 76) + *(_DWORD *)(a1 - 52)) = 34;
  if ( ++*(_DWORD *)(a1 - 52) < *(_DWORD *)(a1 + 12) )
    *(_BYTE *)(*(_DWORD *)(a1 - 76) + *(_DWORD *)(a1 - 52)) = 63;
  ++*(_DWORD *)(a1 - 52);
  JUMPOUT(&loc_805A7D2);
}

//----- (0805A8E0) --------------------------------------------------------
void __usercall sub_805A8E0(int a1@<ebp>, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41)
{
  JUMPOUT(*(_DWORD *)(a1 + 20) != 1, 0, &loc_805A8F0);
  if ( (_BYTE)a17 != 1 || a41 == 2 )
    JUMPOUT(HIBYTE(a17), 1, &loc_805ADB3);
  JUMPOUT(a14, 0, &loc_805ADB3);
  JUMPOUT(&loc_805AD8D);
}

//----- (0805B1E4) --------------------------------------------------------
void *__cdecl sub_805B1E4(int a1, int a2, _DWORD *a3, int a4)
{
  int v4; // ST4C_4
  int v5; // eax
  int v6; // ecx
  void *v7; // eax
  int v9; // [esp+0h] [ebp-58h]
  int v10; // [esp+4h] [ebp-54h]
  int v11; // [esp+8h] [ebp-50h]
  int v12; // [esp+Ch] [ebp-4Ch]
  int v13; // [esp+10h] [ebp-48h]
  int v14; // [esp+14h] [ebp-44h]
  int v15; // [esp+18h] [ebp-40h]
  int v16; // [esp+40h] [ebp-18h]
  int size; // [esp+48h] [ebp-10h]
  void *v18; // [esp+4Ch] [ebp-Ch]

  if ( a4 )
  {
    dword_806B268 = (int)&loc_805B210;
    sub_806197F(v9, v10, v11, v12, v13, v14, v15);
  }
  v16 = *__errno_location();
  v4 = dword_806BFA9[1] | (a3 == 0);
  sub_805A2A0(0, 0, a1, a2, dword_806BFA9[0], v4, (int)&dword_806BFA9[2], dword_806BFA9[10], dword_806BFA9[11]);
  size = v5 + 1;
  v18 = sub_805E4D6(v5 + 1);
  sub_805A2A0(
    (int)v18,
    size,
    a1,
    a2,
    dword_806BFA9[0],
    v4,
    (int)&dword_806BFA9[2],
    dword_806BFA9[10],
    dword_806BFA9[11]);
  *__errno_location() = v16;
  v7 = &loc_805B33D;
  if ( !a3 )
    v7 = &loc_805B348;
  dword_806B27C = (int)v7;
  sub_806190F(v6, v16);
  *a3 = size - 1;
  return v18;
}
// 806190F: using guessed type double __fastcall sub_806190F(_DWORD, _DWORD);
// 806197F: using guessed type int __stdcall sub_806197F(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806B268: using guessed type int dword_806B268;
// 806B27C: using guessed type int dword_806B27C;
// 806BFA9: using guessed type int dword_806BFA9[];

//----- (0805B402) --------------------------------------------------------
void *__cdecl sub_805B402(signed int a1, int a2, int a3, unsigned int *a4)
{
  void *v4; // eax
  int *v9; // eax
  void *v10; // edx
  unsigned int v11; // ST4C_4
  unsigned int v12; // eax
  int v14; // [esp+0h] [ebp-58h]
  int v15; // [esp+4h] [ebp-54h]
  int v16; // [esp+8h] [ebp-50h]
  int v17; // [esp+Ch] [ebp-4Ch]
  int v18; // [esp+10h] [ebp-48h]
  int v19; // [esp+14h] [ebp-44h]
  int v20; // [esp+18h] [ebp-40h]
  int v21; // [esp+1Ch] [ebp-3Ch]
  int v22; // [esp+20h] [ebp-38h]
  bool v23; // [esp+37h] [ebp-21h]
  int *v24; // [esp+38h] [ebp-20h]
  int *v25; // [esp+38h] [ebp-20h]
  void *ptr; // [esp+3Ch] [ebp-1Ch]
  int v27; // [esp+40h] [ebp-18h]
  int size; // [esp+44h] [ebp-14h]
  int v29; // [esp+48h] [ebp-10h]

  v27 = *__errno_location();
  v24 = off_806B3D8;
  if ( a1 < 0 )
    abort();
  v4 = &loc_805B449;
  if ( dword_806B3CC > a1 )
    v4 = &loc_805B509;
  dword_806B234 = (int)v4;
  sub_8061ADD(v14, v15, v16, v17, v18, v19, v20, v21, v22);
  v23 = v24 == &dword_806B3D0;
  if ( (unsigned int)a1 > 0xFFFFFFE )
    sub_805E692();
  _CF = 0;
  _OF = 0;
  _ZF = v24 != &dword_806B3D0;
  _SF = v23 < 0;
  if ( v23 )
  {
    __asm { pushfw }
    v9 = 0;
    __asm { popfw }
  }
  else
  {
    v9 = v24;
  }
  v25 = (int *)sub_805E513(v9, 8 * (a1 + 1));
  off_806B3D8 = v25;
  if ( v23 )
  {
    v10 = off_806B3D4;
    *v25 = dword_806B3D0;
    v25[1] = (int)v10;
  }
  memset(&v25[2 * dword_806B3CC], 0, 8 * (a1 + 1 - dword_806B3CC));
  dword_806B3CC = a1 + 1;
  v11 = v25[2 * a1];
  ptr = (void *)v25[2 * a1 + 1];
  v29 = a4[1] | 1;
  sub_805A2A0((int)ptr, v11, a2, a3, *a4, v29, (int)(a4 + 2), a4[10], a4[11]);
  if ( v11 <= v12 )
  {
    size = v12 + 1;
    v25[2 * a1] = v12 + 1;
    if ( ptr != &unk_806BFE9 )
      free(ptr);
    ptr = sub_805E4D6(size);
    v25[2 * a1 + 1] = (int)ptr;
    sub_805A2A0((int)ptr, size, a2, a3, *a4, v29, (int)(a4 + 2), a4[10], a4[11]);
  }
  *__errno_location() = v27;
  return ptr;
}
// 805E513: using guessed type _DWORD __cdecl sub_805E513(_DWORD, _DWORD);
// 8061ADD: using guessed type int __stdcall sub_8061ADD(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806B234: using guessed type int dword_806B234;
// 806B3CC: using guessed type int dword_806B3CC;
// 806B3D0: using guessed type int dword_806B3D0;
// 806B3D4: using guessed type void *off_806B3D4;
// 806B3D8: using guessed type int *off_806B3D8;

//----- (0805B681) --------------------------------------------------------
void *__cdecl sub_805B681(signed int a1, int a2)
{
  return sub_805B402(a1, a2, -1, (unsigned int *)dword_806BFA9);
}
// 806BFA9: using guessed type int dword_806BFA9[];

//----- (0805B6AB) --------------------------------------------------------
void *__cdecl sub_805B6AB(signed int a1, int a2, int a3)
{
  return sub_805B402(a1, a2, a3, (unsigned int *)dword_806BFA9);
}
// 806BFA9: using guessed type int dword_806BFA9[];

//----- (0805B721) --------------------------------------------------------
void *__cdecl sub_805B721(signed int a1, int a2, int a3)
{
  unsigned int v4[14]; // [esp+10h] [ebp-38h]

  sub_805A14A(v4, a2);
  return sub_805B402(a1, a3, -1, v4);
}

//----- (0805B75F) --------------------------------------------------------
void *__cdecl sub_805B75F(signed int a1, int a2, int a3, int a4)
{
  unsigned int v5[14]; // [esp+10h] [ebp-38h]

  sub_805A14A(v5, a2);
  return sub_805B402(a1, a3, a4, v5);
}

//----- (0805B79C) --------------------------------------------------------
void *__cdecl sub_805B79C(int a1, int a2)
{
  return sub_805B721(0, a1, a2);
}

//----- (0805B7F7) --------------------------------------------------------
void *__cdecl sub_805B7F7(int a1, int a2, unsigned __int8 a3)
{
  int v4; // [esp+0h] [ebp-58h]
  unsigned __int8 v5; // [esp+1Ch] [ebp-3Ch]
  int v6; // [esp+20h] [ebp-38h]
  int v7; // [esp+24h] [ebp-34h]
  int v8; // [esp+28h] [ebp-30h]
  int v9; // [esp+2Ch] [ebp-2Ch]
  int v10; // [esp+30h] [ebp-28h]
  int v11; // [esp+34h] [ebp-24h]
  int v12; // [esp+38h] [ebp-20h]
  int v13; // [esp+3Ch] [ebp-1Ch]
  int v14; // [esp+40h] [ebp-18h]
  int v15; // [esp+44h] [ebp-14h]
  int v16; // [esp+48h] [ebp-10h]
  int v17; // [esp+4Ch] [ebp-Ch]

  v5 = a3;
  v6 = dword_806BFA9[0];
  v7 = dword_806BFAD;
  v8 = dword_806BFB1;
  v9 = dword_806BFB5;
  v10 = dword_806BFB9;
  v11 = dword_806BFBD;
  v12 = dword_806BFC1;
  v13 = dword_806BFC5;
  v14 = dword_806BFC9;
  v15 = dword_806BFCD;
  v16 = dword_806BFD1;
  v17 = dword_806BFD5;
  sub_805A011((int)(&v4 - 14), a3, 1);
  return sub_805B402(0, a1, a2, (unsigned int *)&v6);
}
// 806BFA9: using guessed type int dword_806BFA9[];
// 806BFAD: using guessed type int dword_806BFAD;
// 806BFB1: using guessed type int dword_806BFB1;
// 806BFB5: using guessed type int dword_806BFB5;
// 806BFB9: using guessed type int dword_806BFB9;
// 806BFBD: using guessed type int dword_806BFBD;
// 806BFC1: using guessed type int dword_806BFC1;
// 806BFC5: using guessed type int dword_806BFC5;
// 806BFC9: using guessed type int dword_806BFC9;
// 806BFCD: using guessed type int dword_806BFCD;
// 806BFD1: using guessed type int dword_806BFD1;
// 806BFD5: using guessed type int dword_806BFD5;

//----- (0805B8B1) --------------------------------------------------------
void *__cdecl sub_805B8B1(int a1, unsigned __int8 a2)
{
  return sub_805B7F7(a1, -1, a2);
}

//----- (0805B8EA) --------------------------------------------------------
void *__cdecl sub_805B8EA(int a1)
{
  return sub_805B8B1(a1, 0x3Au);
}

//----- (0805B927) --------------------------------------------------------
void *__cdecl sub_805B927(signed int a1, int a2, int a3)
{
  int v4; // [esp+0h] [ebp-78h]
  int v5; // [esp+10h] [ebp-68h]
  int v6; // [esp+14h] [ebp-64h]
  int v7; // [esp+18h] [ebp-60h]
  int v8; // [esp+1Ch] [ebp-5Ch]
  int v9; // [esp+20h] [ebp-58h]
  int v10; // [esp+24h] [ebp-54h]
  int v11; // [esp+28h] [ebp-50h]
  int v12; // [esp+2Ch] [ebp-4Ch]
  int v13; // [esp+30h] [ebp-48h]
  int v14; // [esp+34h] [ebp-44h]
  int v15; // [esp+38h] [ebp-40h]
  int v16; // [esp+3Ch] [ebp-3Ch]
  int v17; // [esp+40h] [ebp-38h]
  int v18; // [esp+44h] [ebp-34h]
  int v19; // [esp+48h] [ebp-30h]
  int v20; // [esp+4Ch] [ebp-2Ch]
  int v21; // [esp+50h] [ebp-28h]
  int v22; // [esp+54h] [ebp-24h]
  int v23; // [esp+58h] [ebp-20h]
  int v24; // [esp+5Ch] [ebp-1Ch]
  int v25; // [esp+60h] [ebp-18h]
  int v26; // [esp+64h] [ebp-14h]
  int v27; // [esp+68h] [ebp-10h]
  int v28; // [esp+6Ch] [ebp-Ch]

  sub_805A14A(&v5, a2);
  v17 = v5;
  v18 = v6;
  v19 = v7;
  v20 = v8;
  v21 = v9;
  v22 = v10;
  v23 = v11;
  v24 = v12;
  v25 = v13;
  v26 = v14;
  v27 = v15;
  v28 = v16;
  sub_805A011((int)(&v4 - 14), 0x3Au, 1);
  return sub_805B402(a1, a3, -1, (unsigned int *)&v17);
}

//----- (0805B9D8) --------------------------------------------------------
void *__cdecl sub_805B9D8(signed int a1, int a2, int a3, int a4)
{
  return sub_805BA18(a1, a2, a3, a4, -1);
}

//----- (0805BA18) --------------------------------------------------------
void *__cdecl sub_805BA18(signed int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [esp+0h] [ebp-48h]
  int v7; // [esp+10h] [ebp-38h]
  int v8; // [esp+14h] [ebp-34h]
  int v9; // [esp+18h] [ebp-30h]
  int v10; // [esp+1Ch] [ebp-2Ch]
  int v11; // [esp+20h] [ebp-28h]
  int v12; // [esp+24h] [ebp-24h]
  int v13; // [esp+28h] [ebp-20h]
  int v14; // [esp+2Ch] [ebp-1Ch]
  int v15; // [esp+30h] [ebp-18h]
  int v16; // [esp+34h] [ebp-14h]
  int v17; // [esp+38h] [ebp-10h]
  int v18; // [esp+3Ch] [ebp-Ch]

  v7 = dword_806BFA9[0];
  v8 = dword_806BFAD;
  v9 = dword_806BFB1;
  v10 = dword_806BFB5;
  v11 = dword_806BFB9;
  v12 = dword_806BFBD;
  v13 = dword_806BFC1;
  v14 = dword_806BFC5;
  v15 = dword_806BFC9;
  v16 = dword_806BFCD;
  v17 = dword_806BFD1;
  v18 = dword_806BFD5;
  sub_805A0E0(&v6 - 14, a2, a3);
  return sub_805B402(a1, a4, a5, (unsigned int *)&v7);
}
// 805A0E0: using guessed type _DWORD __cdecl sub_805A0E0(_DWORD, _DWORD, _DWORD);
// 806BFA9: using guessed type int dword_806BFA9[];
// 806BFAD: using guessed type int dword_806BFAD;
// 806BFB1: using guessed type int dword_806BFB1;
// 806BFB5: using guessed type int dword_806BFB5;
// 806BFB9: using guessed type int dword_806BFB9;
// 806BFBD: using guessed type int dword_806BFBD;
// 806BFC1: using guessed type int dword_806BFC1;
// 806BFC5: using guessed type int dword_806BFC5;
// 806BFC9: using guessed type int dword_806BFC9;
// 806BFCD: using guessed type int dword_806BFCD;
// 806BFD1: using guessed type int dword_806BFD1;
// 806BFD5: using guessed type int dword_806BFD5;

//----- (0805BB42) --------------------------------------------------------
void *__cdecl sub_805BB42(signed int a1, int a2, int a3)
{
  return sub_805B402(a1, a2, a3, (unsigned int *)&unk_806B3EC);
}

//----- (0805BB9D) --------------------------------------------------------
void *__cdecl sub_805BB9D(signed int a1, int a2)
{
  return sub_805BB42(a1, a2, -1);
}

//----- (0805BBBF) --------------------------------------------------------
void *__cdecl sub_805BBBF(int a1)
{
  return sub_805BB9D(0, a1);
}

//----- (0805BBDA) --------------------------------------------------------
void __cdecl __noreturn sub_805BBDA(int a1)
{
  void *v1; // esi
  char *v2; // ebx
  int *v3; // eax

  if ( a1 )
  {
    v1 = sub_805BBBF(a1);
    if ( *__errno_location() )
      v2 = gettext("%s: read error");
    else
      v2 = gettext("%s: end of file");
    v3 = __errno_location();
    error(status, *v3, v2, v1);
  }
  abort();
}

//----- (0805BC43) --------------------------------------------------------
#error "805BC6E: call analysis failed (funcsize=19)"

//----- (0805BC81) --------------------------------------------------------
#error "805BC9C: positive sp value has been found (funcsize=0)"

//----- (0805BC9D) --------------------------------------------------------
unsigned int __cdecl sub_805BC9D(int a1, int a2, size_t nbytes)
{
  size_t v3; // eax
  int v4; // eax
  size_t n; // ST24_4
  int v6; // eax
  size_t v7; // ST28_4
  int v8; // eax
  size_t v9; // ST2C_4
  int v10; // eax
  size_t v11; // ST30_4
  unsigned int result; // eax
  int v13; // eax
  size_t v14; // ST34_4
  unsigned int v15; // [esp+18h] [ebp-30h]
  int fd; // [esp+20h] [ebp-28h]
  struct timeval tv; // [esp+38h] [ebp-10h]

  v15 = 0;
  fd = open64("/dev/urandom", 0);
  if ( fd >= 0 )
  {
    v3 = a2;
    if ( nbytes <= a2 )
      v3 = nbytes;
    v15 = read(fd, (void *)a1, v3);
    if ( (v15 & 0x80000000) != 0 )
      v15 = 0;
    close(fd);
  }
  if ( v15 < a2 )
  {
    v4 = a2 - v15;
    if ( a2 - v15 > 8 )
      v4 = 8;
    n = v4;
    gettimeofday(&tv, 0);
    memcpy((void *)(a1 + v15), &tv, n);
    v15 += n;
  }
  if ( v15 < a2 )
  {
    v6 = a2 - v15;
    if ( a2 - v15 > 4 )
      v6 = 4;
    v7 = v6;
    tv.tv_sec = getpid();
    memcpy((void *)(a1 + v15), &tv, v7);
    v15 += v7;
  }
  if ( v15 < a2 )
  {
    v8 = a2 - v15;
    if ( a2 - v15 > 4 )
      v8 = 4;
    v9 = v8;
    tv.tv_sec = getppid();
    memcpy((void *)(a1 + v15), &tv, v9);
    v15 += v9;
  }
  if ( v15 < a2 )
  {
    v10 = a2 - v15;
    if ( a2 - v15 > 4 )
      v10 = 4;
    v11 = v10;
    tv.tv_sec = getuid();
    memcpy((void *)(a1 + v15), &tv, v11);
    v15 += v11;
  }
  result = v15;
  if ( v15 < a2 )
  {
    v13 = a2 - v15;
    if ( a2 - v15 > 4 )
      v13 = 4;
    v14 = v13;
    tv.tv_sec = getgid();
    memcpy((void *)(a1 + v15), &tv, v14);
    result = v15 + v14;
  }
  return result;
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);

//----- (0805BEBA) --------------------------------------------------------
int __cdecl sub_805BEBA(int a1, size_t n)
{
  void *v2; // eax
  int v4; // [esp+0h] [ebp-28h]
  int v5; // [esp+4h] [ebp-24h]
  int v6; // [esp+8h] [ebp-20h]
  int v7; // [esp+Ch] [ebp-1Ch]
  int v8; // [esp+10h] [ebp-18h]
  int v9; // [esp+14h] [ebp-14h]
  FILE *stream; // [esp+18h] [ebp-10h]

  v2 = &loc_805BEEF;
  if ( n )
    v2 = &loc_805BF08;
  dword_806B268 = (int)v2;
  sub_806197F(v4, v5, v6, v7, v8, v9, stream);
  return sub_805BC43(0);
}
// 805BC43: using guessed type _DWORD __cdecl sub_805BC43(_DWORD);
// 806197F: using guessed type int __stdcall sub_806197F(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806B268: using guessed type int dword_806B268;

//----- (0805C02B) --------------------------------------------------------
size_t __cdecl sub_805C02B(int a1, void *ptr, size_t n)
{
  size_t v3; // ST1C_4
  size_t result; // eax
  int *v5; // ebx
  int v6; // eax
  int v11; // eax
  int v12; // [esp+1Ch] [ebp-Ch]

  while ( 1 )
  {
    v3 = fread_unlocked(ptr, 1u, n, *(FILE **)a1);
    v12 = *__errno_location();
    ptr = (char *)ptr + v3;
    result = v3;
    n -= v3;
    if ( !n )
      break;
    v5 = __errno_location();
    v6 = ferror_unlocked(*(FILE **)a1);
    _CF = 0;
    _OF = 0;
    _ZF = v6 == 0;
    _SF = v6 < 0;
    if ( v6 )
    {
      v11 = v12;
    }
    else
    {
      __asm { pushfw }
      v11 = 0;
      __asm { popfw }
    }
    *v5 = v11;
    (*(void (__cdecl **)(_DWORD))(a1 + 4))(*(_DWORD *)(a1 + 8));
  }
  return result;
}

//----- (0805C0B4) --------------------------------------------------------
int __cdecl sub_805C0B4(int a1, void *dest, size_t n)
{
  int result; // eax
  size_t i; // [esp+14h] [ebp-14h]
  char *v5; // [esp+18h] [ebp-10h]
  char v6; // [esp+1Ch] [ebp-Ch]

  for ( i = *(_DWORD *)a1; ; i = 1024 )
  {
    v6 = (char)dest;
    if ( n <= i )
      break;
    memcpy(dest, (const void *)(a1 + 1024 - i + 1040), i);
    dest = (char *)dest + i;
    n -= i;
    if ( !((v6 + (_BYTE)i) & 3) )
    {
      v5 = (char *)dest;
      while ( n > 0x3FF )
      {
        sub_805C2CA(a1 + 4, v5);
        v5 += 1024;
        n -= 1024;
        if ( !n )
        {
          result = a1;
          *(_DWORD *)a1 = 0;
          return result;
        }
      }
      dest = v5;
    }
    sub_805C2CA(a1 + 4, a1 + 1040);
  }
  memcpy(dest, (const void *)(a1 + 1024 - i + 1040), n);
  result = a1;
  *(_DWORD *)a1 = i - n;
  return result;
}
// 805C2CA: using guessed type _DWORD __cdecl sub_805C2CA(_DWORD, _DWORD);

//----- (0805C1E3) --------------------------------------------------------
size_t __cdecl sub_805C1E3(int a1, void *ptr, size_t n)
{
  size_t result; // eax

  if ( *(_DWORD *)a1 )
    result = sub_805C02B(a1, ptr, n);
  else
    result = sub_805C0B4(a1 + 12, ptr, n);
  return result;
}

//----- (0805C22B) --------------------------------------------------------
int __cdecl sub_805C22B(void *ptr)
{
  int result; // eax
  FILE *stream; // [esp+1Ch] [ebp-Ch]

  stream = *(FILE **)ptr;
  explicit_bzero(ptr, 2076);
  free(ptr);
  _CF = 0;
  _OF = 0;
  _ZF = stream == 0;
  _SF = (signed int)stream < 0;
  if ( stream )
    return sub_805F4C1(stream);
  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}
// 8049DE0: using guessed type int __cdecl explicit_bzero(_DWORD, _DWORD);

//----- (0805C272) --------------------------------------------------------
int __cdecl sub_805C272(int a1)
{
  return a1;
}

//----- (0805C289) --------------------------------------------------------
int __cdecl sub_805C289(int a1, __int16 a2)
{
  return *(_DWORD *)((a2 & 0x3FC) + a1);
}

//----- (0805C2CA) --------------------------------------------------------
#error "805C410: call analysis failed (funcsize=98)"

//----- (0805C415) --------------------------------------------------------
#error "805C897: positive sp value has been found (funcsize=343)"

//----- (0805C89A) --------------------------------------------------------
_DWORD *__cdecl sub_805C89A(_DWORD *a1)
{
  int v1; // ST10_4
  int v2; // ST14_4
  int v3; // ST1C_4
  int v4; // ST20_4
  int v5; // ST24_4
  int v6; // ST28_4
  int v7; // ST0C_4
  int v8; // ST18_4
  unsigned int v9; // ST10_4
  int v10; // ST1C_4
  int v11; // ST14_4
  int v12; // ST20_4
  int v13; // ST24_4
  int v14; // ST28_4
  int v15; // ST0C_4
  int v16; // ST10_4
  int v17; // ST14_4
  int v18; // ST1C_4
  int v19; // ST20_4
  int v20; // ST24_4
  int v21; // ST28_4
  int v22; // ST0C_4
  int v23; // ST18_4
  unsigned int v24; // ST10_4
  int v25; // ST1C_4
  int v26; // ST14_4
  int v27; // ST20_4
  int v28; // ST24_4
  int v29; // ST28_4
  int v30; // ST0C_4
  _DWORD *result; // eax
  int v32; // [esp+Ch] [ebp-28h]
  int v33; // [esp+10h] [ebp-24h]
  int v34; // [esp+14h] [ebp-20h]
  unsigned int v35; // [esp+18h] [ebp-1Ch]
  int v36; // [esp+1Ch] [ebp-18h]
  unsigned int v37; // [esp+20h] [ebp-14h]
  int v38; // [esp+24h] [ebp-10h]
  unsigned int v39; // [esp+28h] [ebp-Ch]
  signed int i; // [esp+2Ch] [ebp-8h]
  signed int j; // [esp+30h] [ebp-4h]

  v32 = 325574490;
  v33 = -1780940711;
  v34 = -1021952437;
  v35 = 255990488;
  v36 = -651539848;
  v37 = -1525007287;
  v38 = -990909925;
  v39 = 811634969;
  for ( i = 0; i <= 255; i += 8 )
  {
    v1 = a1[i + 1] + v33;
    v2 = a1[i + 2] + v34;
    v3 = a1[i + 4] + v36;
    v4 = a1[i + 5] + v37;
    v5 = a1[i + 6] + v38;
    v6 = a1[i + 7] + v39;
    v7 = (v1 << 11) ^ (a1[i] + v32);
    v8 = v7 + a1[i + 3] + v35;
    v9 = ((unsigned int)sub_805C272(v2) >> 2) ^ (v2 + v1);
    v10 = v9 + v3;
    v11 = (v8 << 8) ^ (v8 + v2);
    v12 = v11 + v4;
    v35 = ((unsigned int)sub_805C272(v10) >> 16) ^ (v10 + v8);
    v13 = v35 + v5;
    v36 = (v12 << 10) ^ (v12 + v10);
    v14 = v36 + v6;
    v37 = ((unsigned int)sub_805C272(v13) >> 4) ^ (v13 + v12);
    v15 = v37 + v7;
    v38 = (v14 << 8) ^ (v14 + v13);
    v33 = v38 + v9;
    v39 = ((unsigned int)sub_805C272(v15) >> 9) ^ (v15 + v14);
    v34 = v39 + v11;
    v32 = v33 + v15;
    a1[i] = v32;
    a1[i + 1] = v33;
    a1[i + 2] = v34;
    a1[i + 3] = v35;
    a1[i + 4] = v36;
    a1[i + 5] = v37;
    a1[i + 6] = v38;
    a1[i + 7] = v39;
  }
  for ( j = 0; j <= 255; j += 8 )
  {
    v16 = a1[j + 1] + v33;
    v17 = a1[j + 2] + v34;
    v18 = a1[j + 4] + v36;
    v19 = a1[j + 5] + v37;
    v20 = a1[j + 6] + v38;
    v21 = a1[j + 7] + v39;
    v22 = (v16 << 11) ^ (a1[j] + v32);
    v23 = v22 + a1[j + 3] + v35;
    v24 = ((unsigned int)sub_805C272(v17) >> 2) ^ (v17 + v16);
    v25 = v24 + v18;
    v26 = (v23 << 8) ^ (v23 + v17);
    v27 = v26 + v19;
    v35 = ((unsigned int)sub_805C272(v25) >> 16) ^ (v25 + v23);
    v28 = v35 + v20;
    v36 = (v27 << 10) ^ (v27 + v25);
    v29 = v36 + v21;
    v37 = ((unsigned int)sub_805C272(v28) >> 4) ^ (v28 + v27);
    v30 = v37 + v22;
    v38 = (v29 << 8) ^ (v29 + v28);
    v33 = v38 + v24;
    v39 = ((unsigned int)sub_805C272(v30) >> 9) ^ (v30 + v29);
    v34 = v39 + v26;
    v32 = v33 + v30;
    a1[j] = v32;
    a1[j + 1] = v33;
    a1[j + 2] = v34;
    a1[j + 3] = v35;
    a1[j + 4] = v36;
    a1[j + 5] = v37;
    a1[j + 6] = v38;
    a1[j + 7] = v39;
  }
  a1[258] = 0;
  a1[257] = a1[258];
  result = a1;
  a1[256] = a1[257];
  return result;
}

//----- (0805CD81) --------------------------------------------------------
signed int __cdecl sub_805CD81(_DWORD *a1)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_805FB5E((int)(a1 + 3), 0, 0, (int)malloc, (int)free);
  sub_805FB5E((int)(a1 + 14), 0, 0, (int)malloc, (int)free);
  return sub_805FB5E((int)(a1 + 25), 0, 0, (int)malloc, (int)free);
}

//----- (0805CF6A) --------------------------------------------------------
_DWORD *__cdecl sub_805CF6A(_DWORD *a1)
{
  _DWORD *result; // eax
  int src; // [esp+10h] [ebp-38h]
  _DWORD *v3; // [esp+14h] [ebp-34h]
  _DWORD *v4; // [esp+18h] [ebp-30h]
  int v5; // [esp+1Ch] [ebp-2Ch]
  int v6; // [esp+20h] [ebp-28h]
  _DWORD *v7; // [esp+24h] [ebp-24h]
  _DWORD *v8; // [esp+28h] [ebp-20h]
  _DWORD *v9; // [esp+2Ch] [ebp-1Ch]
  _DWORD *v10; // [esp+30h] [ebp-18h]
  _DWORD *v11; // [esp+34h] [ebp-14h]
  size_t n; // [esp+38h] [ebp-10h]
  _DWORD *v13; // [esp+3Ch] [ebp-Ch]

  v3 = a1 + 3;
  src = a1[6] - a1[5] - 1;
  v4 = a1 + 3;
  v5 = a1[5];
  if ( a1[6] == v5 )
    *((_BYTE *)v4 + 40) |= 2u;
  v4[3] = (v4[6] + v4[3]) & ~v4[6];
  if ( v4[3] - v4[1] > (unsigned int)(v4[4] - v4[1]) )
    v4[3] = v4[4];
  v4[2] = v4[3];
  v6 = v5;
  v7 = a1 + 14;
  v8 = a1 + 14;
  if ( (unsigned int)(a1[18] - a1[17]) <= 3 )
    sub_805FC07(v7, 4);
  v9 = v7;
  v10 = (_DWORD *)v7[3];
  *v10 = v6;
  v9[3] += 4;
  v11 = a1 + 25;
  n = 4;
  v13 = a1 + 25;
  if ( (unsigned int)(a1[29] - a1[28]) < 4 )
    sub_805FC07(v11, n);
  memcpy((void *)v11[3], &src, n);
  v11[3] += n;
  result = a1;
  ++*a1;
  return result;
}
// 805FC07: using guessed type _DWORD __cdecl sub_805FC07(_DWORD, _DWORD);

//----- (0805D14F) --------------------------------------------------------
bool __cdecl sub_805D14F(FILE *stream, int a2)
{
  int v2; // ecx
  int v3; // eax
  int v4; // edx
  _BYTE *v5; // eax
  _BYTE *v6; // eax
  unsigned int v7; // ecx
  void *v8; // eax
  int v10; // [esp+0h] [ebp-58h]
  int v11; // [esp+4h] [ebp-54h]
  int v12; // [esp+14h] [ebp-44h]
  int v13; // [esp+3Ch] [ebp-1Ch]
  int v14; // [esp+44h] [ebp-14h]

  while ( 1 )
  {
    v12 = fgetc(stream);
    if ( v12 != -1 )
      goto LABEL_7;
    v3 = *(_DWORD *)(a2 + 24);
    v4 = v3 - *(_DWORD *)(a2 + 20);
    if ( v3 != *(_DWORD *)(a2 + 20) )
      break;
    dword_806B220 = (int)&loc_805D299;
    sub_8061B4D(v2, v4, v10, v11);
LABEL_7:
    if ( *(_DWORD *)(a2 + 28) == *(_DWORD *)(a2 + 24) )
      sub_805FC07(a2 + 12, 1);
    v6 = *(_BYTE **)(a2 + 24);
    *(_DWORD *)(a2 + 24) = v6 + 1;
    *v6 = v12;
    if ( !v12 )
      sub_805CF6A((_DWORD *)a2);
  }
  if ( *(_DWORD *)(a2 + 28) == *(_DWORD *)(a2 + 24) )
    sub_805FC07(a2 + 12, 1);
  v5 = *(_BYTE **)(a2 + 24);
  *(_DWORD *)(a2 + 24) = v5 + 1;
  *v5 = 0;
  sub_805CF6A((_DWORD *)a2);
  if ( (unsigned int)(*(_DWORD *)(a2 + 72) - *(_DWORD *)(a2 + 68)) <= 3 )
    sub_805FC07(a2 + 56, 4);
  **(_DWORD **)(a2 + 68) = 0;
  *(_DWORD *)(a2 + 68) += 4;
  v13 = *(_DWORD *)(a2 + 64);
  if ( *(_DWORD *)(a2 + 68) == v13 )
    *(_BYTE *)(a2 + 96) |= 2u;
  *(_DWORD *)(a2 + 68) = (*(_DWORD *)(a2 + 80) + *(_DWORD *)(a2 + 68)) & ~*(_DWORD *)(a2 + 80);
  v7 = *(_DWORD *)(a2 + 72) - *(_DWORD *)(a2 + 60);
  if ( *(_DWORD *)(a2 + 68) - *(_DWORD *)(a2 + 60) > v7 )
    *(_DWORD *)(a2 + 68) = *(_DWORD *)(a2 + 72);
  *(_DWORD *)(a2 + 64) = *(_DWORD *)(a2 + 68);
  *(_DWORD *)(a2 + 4) = v13;
  v14 = *(_DWORD *)(a2 + 108);
  v8 = &loc_805D406;
  if ( *(_DWORD *)(a2 + 112) != v14 )
    v8 = &loc_805D413;
  dword_806B27C = (int)v8;
  sub_806190F(v7, v13);
  *(_BYTE *)(a2 + 140) |= 2u;
  *(_DWORD *)(a2 + 112) = (*(_DWORD *)(a2 + 124) + *(_DWORD *)(a2 + 112)) & ~*(_DWORD *)(a2 + 124);
  if ( *(_DWORD *)(a2 + 112) - *(_DWORD *)(a2 + 104) > (unsigned int)(*(_DWORD *)(a2 + 116) - *(_DWORD *)(a2 + 104)) )
    *(_DWORD *)(a2 + 112) = *(_DWORD *)(a2 + 116);
  *(_DWORD *)(a2 + 108) = *(_DWORD *)(a2 + 112);
  *(_DWORD *)(a2 + 8) = v14;
  return ferror(stream) == 0;
}
// 805FC07: using guessed type _DWORD __cdecl sub_805FC07(_DWORD, _DWORD);
// 806190F: using guessed type double __fastcall sub_806190F(_DWORD, _DWORD);
// 806B220: using guessed type int dword_806B220;
// 806B27C: using guessed type int dword_806B27C;

//----- (0805D4BD) --------------------------------------------------------
int __usercall sub_805D4BD@<eax>(int a1@<ebx>, int a2, int a3)
{
  int v3; // eax
  int v4; // ecx

  v3 = mkostemp64(a2, a3);
  return sub_806070C(a3, v4, a1, v3, a3);
}
// 8049A10: using guessed type int __cdecl mkostemp64(_DWORD, _DWORD);

//----- (0805D4E6) --------------------------------------------------------
int __cdecl sub_805D4E6(_BYTE *a1, _BYTE *a2, unsigned __int8 a3)
{
  unsigned int v3; // eax
  int result; // eax
  unsigned int v9; // eax
  _BYTE *v14; // eax
  _BYTE *v15; // eax
  int v20; // eax
  unsigned __int8 v21; // [esp+0h] [ebp-4h]

  v21 = a3;
  if ( *a1 != a3 || *a2 != v21 )
  {
    v14 = a1++;
    if ( *v14 != v21 )
    {
      v15 = a2++;
      LOBYTE(v15) = *v15;
      _CF = (unsigned __int8)v15 < v21;
      _OF = __OFSUB__((_BYTE)v15, v21);
      _ZF = (_BYTE)v15 == v21;
      _SF = (char)((_BYTE)v15 - v21) < 0;
      if ( (_BYTE)v15 != v21 )
      {
LABEL_23:
        __asm { pushfw }
        result = 0;
        __asm { popfw }
        return result;
      }
LABEL_21:
      while ( *a2 == 48 )
        ++a2;
      v20 = (unsigned __int8)*a2;
      dword_806B2C4 = (int)&locret_805D666;
      sub_8061709();
      goto LABEL_23;
    }
  }
  else
  {
    dword_806B290 = (int)&loc_805D543;
    sub_80618A3();
    do
    {
      v3 = (char)*a1 - 48;
      _CF = v3 < 9;
      _OF = __OFSUB__(v3, 9);
      _ZF = v3 == 9;
      _SF = (char)*a1 - 57 < 0;
      if ( v3 > 9 )
      {
        __asm { pushfw }
        result = 0;
        __asm { popfw }
        return result;
      }
      ++a1;
      ++a2;
    }
    while ( *a1 == *a2 );
    if ( (unsigned int)((char)*a1 - 48) <= 9 && (unsigned int)((char)*a2 - 48) <= 9 )
      return (char)*a1 - (char)*a2;
    if ( (unsigned int)((char)*a1 - 48) > 9 )
    {
      v9 = (char)*a2 - 48;
      _CF = v9 < 9;
      _OF = __OFSUB__(v9, 9);
      _ZF = v9 == 9;
      _SF = (char)*a2 - 57 < 0;
      if ( v9 > 9 )
      {
        __asm { pushfw }
        result = 0;
        __asm { popfw }
        return result;
      }
      goto LABEL_21;
    }
  }
  while ( *a1 == 48 )
    ++a1;
  return (unsigned int)((char)*a1 - 48) <= 9;
}
// 80618A3: using guessed type int sub_80618A3(void);
// 806B290: using guessed type int dword_806B290;
// 806B2C4: using guessed type int dword_806B2C4;

//----- (0805D668) --------------------------------------------------------
#error "805D6DF: call analysis failed (funcsize=197)"

//----- (0805DB98) --------------------------------------------------------
int __cdecl sub_805DB98(int a1, int a2, char a3)
{
  return sub_805D668(a1, a2, a3);
}
// 805D668: using guessed type _DWORD __cdecl sub_805D668(_DWORD, _DWORD, char);

//----- (0805DBD0) --------------------------------------------------------
int __usercall sub_805DBD0@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, int fd)
{
  int v4; // ST18_4
  int v5; // ST1C_4

  if ( fd >= 0 && fd <= 2 )
  {
    v4 = sub_8061206(a1, a2, a3, fd);
    v5 = *__errno_location();
    close(fd);
    *__errno_location() = v5;
    fd = v4;
  }
  return fd;
}

//----- (0805DC1A) --------------------------------------------------------
int __cdecl sub_805DC1A(FILE *stream, int a2, int a3, int a4, int a5, int a6)
{
  char *v6; // eax
  int v7; // edi
  int v8; // esi
  char *v9; // ebx
  char *v11; // [esp+4h] [ebp-64h]
  char *v12; // [esp+8h] [ebp-60h]
  int v13; // [esp+Ch] [ebp-5Ch]
  int v14; // [esp+10h] [ebp-58h]
  int v15; // [esp+14h] [ebp-54h]
  int v16; // [esp+18h] [ebp-50h]
  int v17; // [esp+1Ch] [ebp-4Ch]
  int v18; // [esp+20h] [ebp-48h]
  int v19; // [esp+24h] [ebp-44h]
  int v20; // [esp+28h] [ebp-40h]
  int v21; // [esp+38h] [ebp-30h]
  int v22; // [esp+3Ch] [ebp-2Ch]
  int v23; // [esp+40h] [ebp-28h]
  int v24; // [esp+44h] [ebp-24h]
  int v25; // [esp+48h] [ebp-20h]
  int v26; // [esp+4Ch] [ebp-1Ch]

  if ( a2 )
  {
    v14 = a4;
    fprintf(stream, "%s (%s) %s\n", a2, a3, a4);
  }
  else
  {
    fprintf(stream, "%s %s\n", a3, a4);
  }
  v13 = 2017;
  v12 = gettext("(C)");
  fprintf(stream, "Copyright %s %d Free Software Foundation, Inc.", v12, 2017);
  v6 = gettext(
         "\n"
         "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\n"
         "This is free software: you are free to change and redistribute it.\n"
         "There is NO WARRANTY, to the extent permitted by law.\n"
         "\n");
  fputs_unlocked(v6, stream);
  if ( (unsigned int)a6 <= 9 )
    JUMPOUT(__CS__, *(&off_8064914 + a6));
  v7 = *(_DWORD *)(a5 + 32);
  v26 = *(_DWORD *)(a5 + 28);
  v25 = *(_DWORD *)(a5 + 24);
  v24 = *(_DWORD *)(a5 + 20);
  v23 = *(_DWORD *)(a5 + 16);
  v22 = *(_DWORD *)(a5 + 12);
  v21 = *(_DWORD *)(a5 + 8);
  v8 = *(_DWORD *)(a5 + 4);
  v9 = *(char **)a5;
  v20 = v7;
  v19 = v26;
  v18 = v25;
  v17 = v24;
  v16 = v23;
  v15 = v22;
  v14 = v21;
  v13 = v8;
  v12 = v9;
  v11 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
  return fprintf(stream, v11, v9, v8, v21, v22, v23, v24, v25, v26, v7);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8064914: using guessed type void *;

//----- (0805E25F) --------------------------------------------------------
int __cdecl sub_805E25F(FILE *stream, int a2, int a3, int a4, int a5)
{
  int v5; // ecx
  int v6; // edx
  void *v7; // eax
  int v9; // [esp+28h] [ebp-30h]

  v6 = *(_DWORD *)a5;
  v9 = *(_DWORD *)a5;
  v7 = &loc_805E2BE;
  if ( v9 )
    v7 = &loc_805E26E;
  dword_806B2A4 = (int)v7;
  sub_8061819(v5, v6);
  return sub_805DC1A(stream, a2, a3, a4, (int)&v9, 0);
}
// 8061819: using guessed type int __fastcall sub_8061819(_DWORD, _DWORD);
// 806B2A4: using guessed type int dword_806B2A4;

//----- (0805E2FE) --------------------------------------------------------
int sub_805E2FE(FILE *stream, int a2, int a3, int a4, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a4);
  return sub_805E25F(stream, a2, a3, a4, (int)va);
}

//----- (0805E3AE) --------------------------------------------------------
void *__cdecl sub_805E3AE(unsigned int a1, unsigned int a2)
{
  if ( 0x7FFFFFFF / a2 < a1 )
    sub_805E692();
  return sub_805E4E9(a2 * a1);
}

//----- (0805E413) --------------------------------------------------------
int __cdecl sub_805E413(int a1, unsigned int *a2, unsigned int a3)
{
  void *v3; // eax
  unsigned int v5; // [esp+1Ch] [ebp-Ch]

  v5 = *a2;
  v3 = &loc_805E450;
  if ( a1 )
    v3 = &loc_805E48C;
  dword_806B2C4 = (int)v3;
  sub_8061709();
  if ( !v5 )
    v5 = (0x40 / a3 == 0) + 0x40 / a3;
  if ( 0x7FFFFFFF / a3 < v5 )
    sub_805E692();
  *a2 = v5;
  return sub_805E513(a1, a3 * v5);
}
// 805E513: using guessed type _DWORD __cdecl sub_805E513(_DWORD, _DWORD);
// 806B2C4: using guessed type int dword_806B2C4;

//----- (0805E4D6) --------------------------------------------------------
void *__cdecl sub_805E4D6(size_t size)
{
  return sub_805E4E9(size);
}

//----- (0805E4E9) --------------------------------------------------------
void *__cdecl sub_805E4E9(size_t size)
{
  void *v2; // [esp+1Ch] [ebp-Ch]

  v2 = malloc(size);
  if ( !v2 && size )
    sub_805E692();
  return v2;
}

//----- (0805E513) --------------------------------------------------------
#error "805E548: call analysis failed (funcsize=19)"

//----- (0805E54D) --------------------------------------------------------
#error "805E557: positive sp value has been found (funcsize=4)"

//----- (0805E606) --------------------------------------------------------
void *__cdecl sub_805E606(size_t nmemb, size_t size)
{
  void *v3; // [esp+1Ch] [ebp-Ch]

  if ( 0x7FFFFFFF / size < nmemb || (v3 = calloc(nmemb, size)) == 0 )
    sub_805E692();
  return v3;
}

//----- (0805E644) --------------------------------------------------------
void *__cdecl sub_805E644(void *src, size_t n)
{
  void *v2; // eax

  v2 = sub_805E4E9(n);
  return memcpy(v2, src, n);
}

//----- (0805E692) --------------------------------------------------------
void __noreturn sub_805E692()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (0805E6CB) --------------------------------------------------------
void __cdecl sub_805E6CB(int errnum, int a2, int a3, int a4, int a5)
{
  char *v5; // eax
  char *v6; // eax
  void *v7; // esi
  void *v8; // ebx
  char *v9; // eax

  v5 = gettext("string comparison failed");
  error(0, errnum, v5);
  v6 = gettext("Set LC_ALL='C' to work around the problem.");
  error(0, 0, v6);
  v7 = sub_805B75F(1, 8, a4, a5);
  v8 = sub_805B75F(0, 8, a2, a3);
  v9 = gettext("The strings compared were %s and %s.");
  error(status, 0, v9, v8, v7);
}

//----- (0805E81C) --------------------------------------------------------
int __cdecl sub_805E81C(void *s1, size_t n, void *s2, int a4)
{
  int v5; // [esp+28h] [ebp-10h]
  int errnum; // [esp+2Ch] [ebp-Ch]

  v5 = sub_80610DC(s1, n, s2, a4);
  errnum = *__errno_location();
  if ( errnum )
    sub_805E6CB(errnum, (int)s1, n - 1, (int)s2, a4 - 1);
  return v5;
}

//----- (0805E8A7) --------------------------------------------------------
signed int __cdecl sub_805E8A7(double a1)
{
  int v1; // eax
  signed int result; // eax
  int v7; // [esp+0h] [ebp-38h]
  double v8; // [esp+18h] [ebp-20h]
  struct timespec requested_time; // [esp+28h] [ebp-10h]

  v8 = a1;
  sub_8060568(&v7 - 4, a1);
  do
  {
    *__errno_location() = 0;
    v1 = nanosleep(&requested_time, 0);
    _CF = 0;
    _OF = 0;
    _ZF = v1 == 0;
    _SF = v1 < 0;
    if ( !v1 )
    {
      __asm { pushfw }
      result = 0;
      __asm { popfw }
      return result;
    }
  }
  while ( *__errno_location() == 4 || !*__errno_location() );
  return -1;
}

//----- (0805E92A) --------------------------------------------------------
signed int __cdecl sub_805E92A(unsigned int *a1, signed int a2)
{
  signed int result; // eax

  if ( 0xFFFFFFFF / a2 >= *a1 )
  {
    _CF = (unsigned __int64)(a2 * (signed __int64)(signed int)*a1) >> 32 != 0;
    _OF = (unsigned __int64)(a2 * (signed __int64)(signed int)*a1) >> 32 != 0;
    *a1 *= a2;
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  else
  {
    *a1 = -1;
    result = 1;
  }
  return result;
}

//----- (0805E980) --------------------------------------------------------
int __cdecl sub_805E980(unsigned int *a1, signed int a2, int a3)
{
  int v3; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; i |= sub_805E92A(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}

//----- (0805E9B6) --------------------------------------------------------
int __usercall sub_805E9B6@<eax>(int a1@<ebx>, char *nptr, int a3, int base, int a5, char *s)
{
  char **v6; // eax
  int result; // eax
  char *v8; // eax
  bool v9; // zf
  void *v10; // eax
  int v11; // ebx
  int v12; // eax
  void *v13; // eax
  int v14; // edx
  int v15; // ecx
  int v16; // eax
  void *v17; // eax
  void *v18; // eax
  void *v19; // eax
  int v20; // [esp-8h] [ebp-50h]
  char *v21; // [esp-4h] [ebp-4Ch]
  int v22; // [esp+0h] [ebp-48h]
  int v23; // [esp+4h] [ebp-44h]
  int v24; // [esp+8h] [ebp-40h]
  int v25; // [esp+Ch] [ebp-3Ch]
  int v26; // [esp+10h] [ebp-38h]
  int v27; // [esp+14h] [ebp-34h]
  int v28; // [esp+18h] [ebp-30h]
  unsigned __int8 i; // [esp+1Fh] [ebp-29h]
  char v30; // [esp+20h] [ebp-28h]
  unsigned int v31; // [esp+24h] [ebp-24h]
  int v32; // [esp+28h] [ebp-20h]
  char *v33; // [esp+2Ch] [ebp-1Ch]
  int v34; // [esp+30h] [ebp-18h]
  int v35; // [esp+34h] [ebp-14h]
  int v36; // [esp+38h] [ebp-10h]
  char **endptr; // [esp+3Ch] [ebp-Ch]

  v32 = 0;
  if ( base < 0 || base > 36 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoul");
  if ( a3 )
    v6 = (char **)a3;
  else
    v6 = (char **)&v30;
  endptr = v6;
  *__errno_location() = 0;
  v33 = nptr;
  for ( i = *nptr; (*__ctype_b_loc())[i] & 0x2000; i = *v33 )
    ++v33;
  if ( i == 45 )
    return 4;
  v31 = strtoul(nptr, endptr, base);
  if ( *endptr == nptr )
  {
    if ( s && **endptr )
    {
      v8 = strchr(s, **endptr);
      v9 = v8 == 0;
      v21 = v8;
      v20 = a1;
      v10 = &loc_805EACC;
      if ( v9 )
        v10 = &loc_805EAD5;
      dword_806B290 = (int)v10;
      v11 = v20;
      sub_80618A3();
      v31 = 1;
      goto LABEL_24;
    }
    dword_806B268 = (int)&locret_805EE4F;
    sub_806197F(v22, v23, v24, v25, v26, v27, v28);
  }
  v12 = *__errno_location();
  v9 = v12 == 0;
  v21 = (char *)v12;
  v20 = a1;
  v13 = &loc_805EB25;
  if ( v9 )
    v13 = &loc_805EB42;
  dword_806B254 = (int)v13;
  v11 = v20;
  sub_80619F1();
  if ( *__errno_location() != 34 )
    return 4;
  v32 = 1;
LABEL_24:
  if ( s )
  {
    if ( **endptr )
    {
      v34 = 1024;
      v35 = 1;
      v23 = **endptr;
      if ( strchr(s, v23) )
      {
        switch ( **endptr )
        {
          case 69:
          case 71:
          case 75:
          case 77:
          case 80:
          case 84:
          case 89:
          case 90:
          case 103:
          case 107:
          case 109:
          case 116:
            if ( strchr(s, 48) )
            {
              v16 = (*endptr)[1];
              if ( v16 == 68 )
              {
                v34 = 1000;
                ++v35;
              }
              else if ( v16 == 105 )
              {
                v9 = (*endptr)[2] == 66;
                v21 = (char *)(unsigned __int8)(*endptr)[2];
                v20 = v11;
                v18 = &loc_805EC52;
                if ( !v9 )
                  v18 = &loc_805EC58;
                dword_806B2A4 = (int)v18;
                v11 = v20;
                sub_8061819(v15, v14);
                v35 += 2;
              }
              else
              {
                v9 = v16 == 66;
                v21 = (char *)(*endptr)[1];
                v20 = v11;
                v17 = &loc_805EC18;
                if ( v9 )
                  v17 = &loc_805EC5A;
                dword_806B268 = (int)v17;
                v11 = v20;
                sub_806197F(v22, v23, v24, v25, v26, v27, v28);
              }
            }
            break;
          default:
            break;
        }
        switch ( **endptr )
        {
          case 66:
            v36 = sub_805E92A(&v31, 1024);
            goto LABEL_54;
          case 69:
            v36 = sub_805E980(&v31, v34, 6);
            goto LABEL_54;
          case 71:
          case 103:
            v36 = sub_805E980(&v31, v34, 3);
            goto LABEL_54;
          case 75:
          case 107:
            v36 = sub_805E980(&v31, v34, 1);
            goto LABEL_54;
          case 77:
          case 109:
            v36 = sub_805E980(&v31, v34, 2);
            goto LABEL_54;
          case 80:
            v36 = sub_805E980(&v31, v34, 5);
            goto LABEL_54;
          case 84:
          case 116:
            v36 = sub_805E980(&v31, v34, 4);
            goto LABEL_54;
          case 89:
            v36 = sub_805E980(&v31, v34, 8);
            goto LABEL_54;
          case 90:
            v36 = sub_805E980(&v31, v34, 7);
            goto LABEL_54;
          case 98:
            v36 = sub_805E92A(&v31, 512);
            goto LABEL_54;
          case 99:
            v36 = 0;
            goto LABEL_54;
          case 119:
            v36 = sub_805E92A(&v31, 2);
LABEL_54:
            v32 |= v36;
            *endptr += v35;
            v9 = **endptr == 0;
            v21 = (char *)(unsigned __int8)**endptr;
            v20 = v11;
            v19 = &loc_805EE40;
            if ( v9 )
              v19 = &loc_805EE44;
            dword_806B2D8 = (int)v19;
            sub_8061693();
            v32 |= 2u;
            goto LABEL_57;
          default:
            *(_DWORD *)a5 = v31;
            result = v32 | 2;
            break;
        }
      }
      else
      {
        *(_DWORD *)a5 = v31;
        result = v32 | 2;
      }
    }
    else
    {
LABEL_57:
      *(_DWORD *)a5 = v31;
      result = v32;
    }
  }
  else
  {
    *(_DWORD *)a5 = v31;
    result = v32;
  }
  return result;
}
// 805E9B6: could not find valid save-restore pair for ebx
// 8061693: using guessed type int sub_8061693(void);
// 8061819: using guessed type int __fastcall sub_8061819(_DWORD, _DWORD);
// 80618A3: using guessed type int sub_80618A3(void);
// 806197F: using guessed type int __stdcall sub_806197F(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80619F1: using guessed type int sub_80619F1(void);
// 806B254: using guessed type int dword_806B254;
// 806B268: using guessed type int dword_806B268;
// 806B290: using guessed type int dword_806B290;
// 806B2A4: using guessed type int dword_806B2A4;
// 806B2D8: using guessed type int dword_806B2D8;

//----- (0805EE51) --------------------------------------------------------
void __usercall sub_805EE51(int edx0@<edx>, int ecx0@<ecx>, int a1, int a2, int a3, int a4, int a5, int status)
{
  char *v8; // eax
  const char *v9; // [esp+Ch] [ebp-2Ch]
  char *v10; // [esp+10h] [ebp-28h]
  int v11; // [esp+14h] [ebp-24h]
  char v12; // [esp+1Ch] [ebp-1Ch]
  char v13; // [esp+22h] [ebp-16h]
  char v14; // [esp+23h] [ebp-15h]
  const char *v15; // [esp+24h] [ebp-14h]
  char *msgid; // [esp+28h] [ebp-10h]
  char *v17; // [esp+2Ch] [ebp-Ch]

  v12 = a3;
  v15 = "--";
  if ( (unsigned int)a1 > 3 )
  {
    if ( a1 != 4 )
      goto LABEL_6;
    msgid = "invalid %s%s argument '%s'";
    dword_806B2A4 = (int)&loc_805EEB0;
    sub_8061819(ecx0, edx0);
    goto LABEL_8;
  }
  if ( (unsigned int)a1 >= 2 )
  {
LABEL_8:
    msgid = "invalid suffix in %s%s argument '%s'";
    goto LABEL_10;
  }
  if ( a1 != 1 )
LABEL_6:
    abort();
  msgid = "%s%s argument '%s' too large";
LABEL_10:
  if ( a2 >= 0 )
  {
    v17 = *(char **)(16 * a2 + a4);
  }
  else
  {
    v15 -= a2;
    v13 = v12;
    v14 = 0;
    v17 = &v13;
  }
  v8 = gettext(msgid);
  v11 = a5;
  v10 = v17;
  v9 = v15;
  error(status, 0, v8, v15, v17, a5);
}
// 8061819: using guessed type int __fastcall sub_8061819(_DWORD, _DWORD);
// 806B2A4: using guessed type int dword_806B2A4;

//----- (0805EF2C) --------------------------------------------------------
void __fastcall __noreturn sub_805EF2C(int ecx0, int edx0, int a1, int a2, char a3, int a4, int a5)
{
  sub_805EE51(a4, ecx0, a1, a2, a3, a4, a5, status);
  abort();
}

//----- (0805EF7F) --------------------------------------------------------
signed int __cdecl sub_805EF7F(unsigned int *a1, signed int a2)
{
  signed int result; // eax
  int v3; // esi
  unsigned __int64 v8; // rax

  if ( (unsigned __int64)sub_806122B(0xFFFFFFFFFFFFFFFFLL, a2, a2 >> 31) >= *(_QWORD *)a1 )
  {
    v3 = a2 * a1[1] + *a1 * (a2 >> 31);
    v8 = *a1 * (unsigned __int64)(unsigned int)a2;
    _CF = v8 >> 32 != 0;
    _OF = v8 >> 32 != 0;
    *a1 = v8;
    a1[1] = v3 + HIDWORD(v8);
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  else
  {
    *a1 = -1;
    a1[1] = -1;
    result = 1;
  }
  return result;
}

//----- (0805F02C) --------------------------------------------------------
int __cdecl sub_805F02C(unsigned int *a1, signed int a2, int a3)
{
  int v3; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; ; i |= sub_805EF7F(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}

//----- (0805F062) --------------------------------------------------------
int __usercall sub_805F062@<eax>(int a1@<edx>, int a2@<ecx>, char *nptr, int a4, int base, int a6, char *s)
{
  void *v7; // eax
  char **v8; // eax
  int v9; // edx
  int v10; // ecx
  int result; // eax
  int v12; // edx
  int v13; // edx
  int v14; // eax
  bool v15; // zf
  void *v16; // eax
  int v17; // edx
  int v18; // edx
  int v19; // [esp+0h] [ebp-48h]
  int v20; // [esp+4h] [ebp-44h]
  int v21; // [esp+8h] [ebp-40h]
  int v22; // [esp+Ch] [ebp-3Ch]
  int v23; // [esp+10h] [ebp-38h]
  int v24; // [esp+14h] [ebp-34h]
  int v25; // [esp+18h] [ebp-30h]
  char v26; // [esp+1Ch] [ebp-2Ch]
  int v27; // [esp+20h] [ebp-28h]
  char *v28; // [esp+24h] [ebp-24h]
  int v29; // [esp+28h] [ebp-20h]
  int v30; // [esp+2Ch] [ebp-1Ch]
  int v31; // [esp+30h] [ebp-18h]
  char **endptr; // [esp+34h] [ebp-14h]
  uintmax_t v33; // [esp+38h] [ebp-10h]

  v27 = 0;
  if ( base < 0 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoumax");
  v7 = &loc_805F094;
  if ( base > 36 )
    v7 = &loc_805F09C;
  dword_806B27C = (int)v7;
  sub_806190F(a2, a1);
  if ( a4 )
    v8 = (char **)a4;
  else
    v8 = (char **)&v26;
  endptr = v8;
  *__errno_location() = 0;
  v28 = nptr;
  HIBYTE(v25) = *nptr;
  dword_806B27C = (int)&loc_805F109;
  sub_806190F(v10, v9);
  do
    HIBYTE(v25) = *++v28;
  while ( (*__ctype_b_loc())[HIBYTE(v25)] & 0x2000 );
  if ( HIBYTE(v25) == 45 )
    return 4;
  v33 = strtoumax(nptr, endptr, base);
  if ( *endptr == nptr )
  {
    if ( s && **endptr && strchr(s, **endptr) )
    {
      v33 = 1LL;
      goto LABEL_22;
    }
    dword_806B2D8 = (int)&locret_805F4BF;
    sub_8061693();
  }
  if ( *__errno_location() )
  {
    if ( *__errno_location() != 34 )
      return 4;
    v27 = 1;
  }
LABEL_22:
  if ( s )
  {
    if ( **endptr )
    {
      v29 = 1024;
      v30 = 1;
      v20 = **endptr;
      if ( strchr(s, v20) )
      {
        switch ( **endptr )
        {
          case 69:
          case 71:
          case 75:
          case 77:
          case 80:
          case 84:
          case 89:
          case 90:
          case 103:
          case 107:
          case 109:
          case 116:
            if ( strchr(s, 48) )
            {
              v14 = (*endptr)[1];
              if ( v14 == 68 )
              {
                v29 = 1000;
                ++v30;
              }
              else if ( v14 == 105 )
              {
                if ( (*endptr)[2] == 66 )
                  v30 += 2;
              }
              else
              {
                v15 = v14 == 66;
                v16 = &loc_805F2BE;
                if ( v15 )
                  v16 = &loc_805F2D7;
                dword_806B268 = (int)v16;
                sub_806197F(v19, v20, v21, v22, v23, v24, v25);
              }
            }
            break;
          default:
            break;
        }
        switch ( **endptr )
        {
          case 66:
            v31 = sub_805EF7F((unsigned int *)&v33, 1024);
            goto LABEL_52;
          case 69:
            v31 = sub_805F02C((unsigned int *)&v33, v29, 6);
            goto LABEL_52;
          case 71:
          case 103:
            v31 = sub_805F02C((unsigned int *)&v33, v29, 3);
            goto LABEL_52;
          case 75:
          case 107:
            v31 = sub_805F02C((unsigned int *)&v33, v29, 1);
            goto LABEL_52;
          case 77:
          case 109:
            v31 = sub_805F02C((unsigned int *)&v33, v29, 2);
            goto LABEL_52;
          case 80:
            v31 = sub_805F02C((unsigned int *)&v33, v29, 5);
            goto LABEL_52;
          case 84:
          case 116:
            v31 = sub_805F02C((unsigned int *)&v33, v29, 4);
            goto LABEL_52;
          case 89:
            v31 = sub_805F02C((unsigned int *)&v33, v29, 8);
            goto LABEL_52;
          case 90:
            v31 = sub_805F02C((unsigned int *)&v33, v29, 7);
            goto LABEL_52;
          case 98:
            v31 = sub_805EF7F((unsigned int *)&v33, 512);
            goto LABEL_52;
          case 99:
            v31 = 0;
            goto LABEL_52;
          case 119:
            v31 = sub_805EF7F((unsigned int *)&v33, 2);
LABEL_52:
            v27 |= v31;
            *endptr += v30;
            if ( **endptr )
              v27 |= 2u;
            goto LABEL_54;
          default:
            v17 = HIDWORD(v33);
            *(_DWORD *)a6 = v33;
            *(_DWORD *)(a6 + 4) = v17;
            result = v27 | 2;
            break;
        }
      }
      else
      {
        v13 = HIDWORD(v33);
        *(_DWORD *)a6 = v33;
        *(_DWORD *)(a6 + 4) = v13;
        result = v27 | 2;
      }
    }
    else
    {
LABEL_54:
      v18 = HIDWORD(v33);
      *(_DWORD *)a6 = v33;
      *(_DWORD *)(a6 + 4) = v18;
      result = v27;
    }
  }
  else
  {
    v12 = HIDWORD(v33);
    *(_DWORD *)a6 = v33;
    *(_DWORD *)(a6 + 4) = v12;
    result = v27;
  }
  return result;
}
// 805F062: could not find valid save-restore pair for ebx
// 8061693: using guessed type int sub_8061693(void);
// 806190F: using guessed type double __fastcall sub_806190F(_DWORD, _DWORD);
// 806197F: using guessed type int __stdcall sub_806197F(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806B268: using guessed type int dword_806B268;
// 806B27C: using guessed type int dword_806B27C;
// 806B2D8: using guessed type int dword_806B2D8;

//----- (0805F4C1) --------------------------------------------------------
#error "805F52E: call analysis failed (funcsize=77)"

//----- (0805F5D6) --------------------------------------------------------
int __usercall sub_805F5D6@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, int fd, int cmd, char a6)
{
  void *v6; // eax
  int v7; // ebx
  char *v8; // eax
  int v9; // eax
  bool v10; // zf
  void *v11; // eax
  int v13; // [esp-8h] [ebp-40h]
  int v14; // [esp-4h] [ebp-3Ch]
  int v15; // [esp+8h] [ebp-30h]
  char *v16; // [esp+18h] [ebp-20h]
  int v17; // [esp+1Ch] [ebp-1Ch]
  char v18[4]; // [esp+20h] [ebp-18h]
  int v19; // [esp+24h] [ebp-14h]
  int v20; // [esp+28h] [ebp-10h]

  v17 = -1;
  v16 = &a6;
  v14 = cmd;
  v13 = a3;
  v6 = &loc_805F61C;
  if ( cmd != 1030 )
    v6 = &loc_805F763;
  dword_806B2A4 = (int)v6;
  v7 = v13;
  sub_8061819(a2, a1);
  v8 = v16;
  v16 += 4;
  *(_DWORD *)v18 = *(_DWORD *)v8;
  if ( dword_806C0E9 < 0 )
  {
    v17 = sub_805F5D6(fd, 0, v18[0]);
  }
  else
  {
    v15 = *(_DWORD *)v18;
    v17 = fcntl(fd, cmd, *(_DWORD *)v18);
    if ( v17 < 0 )
    {
      v9 = *__errno_location();
      v10 = v9 == 22;
      v14 = v9;
      v13 = v7;
      v11 = &loc_805F68E;
      if ( v10 )
        v11 = &loc_805F69A;
      dword_806B2C4 = (int)v11;
      sub_8061709();
    }
    dword_806C0E9 = 1;
  }
  if ( v17 >= 0 && dword_806C0E9 == -1 )
  {
    v19 = fcntl(v17, 1);
    if ( v19 < 0 || (v15 = v19 | 1, fcntl(v17, 2, v19 | 1) == -1) )
    {
      v20 = *__errno_location();
      close(v17);
      *__errno_location() = v20;
      v17 = -1;
    }
  }
  return v17;
}
// 805F5D6: could not find valid save-restore pair for ebx
// 8061819: using guessed type int __fastcall sub_8061819(_DWORD, _DWORD);
// 806B2A4: using guessed type int dword_806B2A4;
// 806B2C4: using guessed type int dword_806B2C4;
// 806C0E9: using guessed type int dword_806C0E9;

//----- (0805F7A2) --------------------------------------------------------
int __cdecl sub_805F7A2(FILE *a1)
{
  int result; // eax

  result = a1->_flags & 0x100;
  if ( result )
    result = sub_805F81B(a1, 0, 0, 1);
  return result;
}

//----- (0805F7DB) --------------------------------------------------------
int __cdecl sub_805F7DB(FILE *fp)
{
  if ( !fp || !__freading(fp) )
    return fflush(fp);
  sub_805F7A2(fp);
  return fflush(fp);
}

//----- (0805F81B) --------------------------------------------------------
int __cdecl sub_805F81B(FILE *stream, int a2, int a3, int a4)
{
  int v4; // eax
  __off64_t v5; // rax
  int result; // eax
  int v11; // [esp+10h] [ebp-2Ch]
  int v12; // [esp+14h] [ebp-28h]
  int v13; // [esp+20h] [ebp-1Ch]
  int v14; // [esp+24h] [ebp-18h]
  int v15; // [esp+28h] [ebp-14h]
  int v16; // [esp+2Ch] [ebp-10h]
  int v17; // [esp+30h] [ebp-Ch]
  int v18; // [esp+34h] [ebp-8h]

  if ( stream->_IO_read_end != stream->_IO_read_ptr
    || stream->_IO_write_ptr != stream->_IO_write_base
    || stream->_IO_save_base )
  {
    return fseeko64(stream, a2, a3, a4, v11, v12, a2, a3, v13, v14, v15, v16, v17, v18);
  }
  v4 = fileno(stream);
  LODWORD(v5) = lseek64(v4, a2, a3, a4, v11, v12, a2, a3, v13, v14, v15, v16, v17, v18);
  if ( v5 == -1 )
    return -1;
  _CF = 0;
  _OF = 0;
  _ZF = (stream->_flags & 0xFFFFFFEF) == 0;
  _SF = (stream->_flags & 0xFFFFFFEF & 0x80000000) != 0;
  stream->_flags &= 0xFFFFFFEF;
  stream->_offset = v5;
  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}
// 80498B0: using guessed type int __stdcall fseeko64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8049A90: using guessed type int __stdcall lseek64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0805F916) --------------------------------------------------------
#error "805F9B0: call analysis failed (funcsize=51)"

//----- (0805F9E3) --------------------------------------------------------
int __cdecl sub_805F9E3(int a1, int a2)
{
  int result; // eax

  if ( *(_BYTE *)(a1 + 40) & 1 )
    result = (*(int (__cdecl **)(_DWORD, int))(a1 + 28))(*(_DWORD *)(a1 + 36), a2);
  else
    result = (*(int (__cdecl **)(int))(a1 + 28))(a2);
  return result;
}

//----- (0805FA21) --------------------------------------------------------
int __cdecl sub_805FA21(int a1, int a2)
{
  int result; // eax

  if ( *(_BYTE *)(a1 + 40) & 1 )
    result = (*(int (__cdecl **)(_DWORD, int))(a1 + 32))(*(_DWORD *)(a1 + 36), a2);
  else
    result = (*(int (__cdecl **)(int))(a1 + 32))(a2);
  return result;
}

//----- (0805FA5F) --------------------------------------------------------
signed int __cdecl sub_805FA5F(int a1, signed int a2, signed int a3)
{
  int v4; // [esp+4h] [ebp-24h]
  int v5; // [esp+18h] [ebp-10h]
  _DWORD *v6; // [esp+1Ch] [ebp-Ch]

  if ( !a3 )
    a3 = 8;
  if ( !a2 )
  {
    v5 = 32;
    a2 = 4064;
  }
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 24) = a3 - 1;
  v4 = *(_DWORD *)a1;
  *(_DWORD *)(a1 + 4) = sub_805F9E3(a1, v4);
  v6 = *(_DWORD **)(a1 + 4);
  if ( !v6 )
    obstack_alloc_failed_handler();
  *(_DWORD *)(a1 + 8) = ((unsigned int)&v6[a3 / 4u + 1] + 3) & -a3;
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 8);
  *v6 = (char *)v6 + *(_DWORD *)a1;
  *(_DWORD *)(a1 + 16) = *v6;
  v6[1] = 0;
  *(_BYTE *)(a1 + 40) &= 0xFDu;
  *(_BYTE *)(a1 + 40) &= 0xFBu;
  return 1;
}
// 806B480: using guessed type int (*obstack_alloc_failed_handler)(void);

//----- (0805FB5E) --------------------------------------------------------
signed int __cdecl sub_805FB5E(int a1, signed int a2, signed int a3, int a4, int a5)
{
  *(_DWORD *)(a1 + 28) = a4;
  *(_DWORD *)(a1 + 32) = a5;
  *(_BYTE *)(a1 + 40) &= 0xFEu;
  return sub_805FA5F(a1, a2, a3);
}

//----- (0805FC07) --------------------------------------------------------
#error "805FDBC: call analysis failed (funcsize=144)"

//----- (0805FDC1) --------------------------------------------------------
#error "805FDE1: positive sp value has been found (funcsize=0)"

//----- (0805FE3B) --------------------------------------------------------
int __cdecl sub_805FE3B(int a1, unsigned int a2)
{
  int result; // eax
  int *v3; // ST1C_4
  int *v4; // [esp+18h] [ebp-10h]

  result = *(_DWORD *)(a1 + 4);
  v4 = *(int **)(a1 + 4);
  while ( v4 )
  {
    if ( (unsigned int)v4 < a2 )
    {
      result = *v4;
      if ( *v4 >= a2 )
        break;
    }
    v3 = (int *)v4[1];
    sub_805FA21(a1, (int)v4);
    v4 = v3;
    result = a1;
    *(_BYTE *)(a1 + 40) |= 2u;
  }
  if ( v4 )
  {
    *(_DWORD *)(a1 + 12) = a2;
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 16) = *v4;
    result = a1;
    *(_DWORD *)(a1 + 4) = v4;
  }
  else if ( a2 )
  {
    abort();
  }
  return result;
}

//----- (080600BA) --------------------------------------------------------
int __cdecl sub_80600BA(int a1, char a2)
{
  return __ROR4__(a1, a2);
}

//----- (080601E5) --------------------------------------------------------
int __cdecl sub_80601E5(signed int a1)
{
  int result; // eax

  if ( a1 > 90 )
  {
    _CF = (unsigned int)(a1 - 97) < 0x19;
    _OF = __OFSUB__(a1 - 97, 25);
    _ZF = a1 == 122;
    _SF = a1 - 122 < 0;
    if ( (unsigned int)(a1 - 97) <= 0x19 )
    {
LABEL_6:
      dword_806B2D8 = (int)&loc_8060229;
      sub_8061693();
      goto LABEL_7;
    }
  }
  else
  {
    if ( a1 >= 65 )
      goto LABEL_6;
    _CF = (unsigned int)(a1 - 48) < 9;
    _OF = __OFSUB__(a1 - 48, 9);
    _ZF = a1 == 57;
    _SF = a1 - 57 < 0;
    if ( (unsigned int)(a1 - 48) <= 9 )
      goto LABEL_6;
  }
LABEL_7:
  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}
// 8061693: using guessed type int sub_8061693(void);
// 806B2D8: using guessed type int dword_806B2D8;

//----- (0806022B) --------------------------------------------------------
int __usercall sub_806022B@<eax>(int a1@<edx>, int a2@<ecx>, signed int a3)
{
  int result; // eax

  _CF = (unsigned int)a3 < 0x41;
  _OF = __OFSUB__(a3, 65);
  _ZF = a3 == 65;
  _SF = a3 - 65 < 0;
  if ( a3 >= 65 )
  {
    if ( a3 <= 90
      || (_CF = (unsigned int)(a3 - 97) < 0x19,
          _OF = __OFSUB__(a3 - 97, 25),
          _ZF = a3 == 122,
          _SF = a3 - 122 < 0,
          (unsigned int)(a3 - 97) <= 0x19) )
    {
      dword_806B27C = (int)&loc_8060265;
      sub_806190F(a2, a1);
    }
  }
  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}
// 806190F: using guessed type double __fastcall sub_806190F(_DWORD, _DWORD);
// 806B27C: using guessed type int dword_806B27C;

//----- (080602C8) --------------------------------------------------------
signed int __cdecl sub_80602C8(int a1)
{
  signed int result; // eax

  _CF = (unsigned int)(a1 - 48) < 9;
  _OF = __OFSUB__(a1 - 48, 9);
  _ZF = a1 == 57;
  _SF = a1 - 57 < 0;
  if ( (unsigned int)(a1 - 48) <= 9 )
    return 1;
  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}

//----- (080603A1) --------------------------------------------------------
signed int __usercall sub_80603A1@<eax>(int a1@<edx>, int a2@<ecx>, signed int a3)
{
  void *v7; // eax
  unsigned int v8; // eax
  signed int result; // eax

  _CF = (unsigned int)a3 < 9;
  _OF = __OFSUB__(a3, 9);
  _ZF = a3 == 9;
  _SF = a3 - 9 < 0;
  if ( a3 >= 9 )
  {
    v7 = &loc_80603CA;
    if ( a3 <= 13 )
      v7 = &loc_80603CF;
    dword_806B2A4 = (int)v7;
    v8 = sub_8061819(a2, a1);
    _CF = v8 < 0x20;
    _OF = __OFSUB__(v8, 32);
    _ZF = v8 == 32;
    _SF = (signed int)(v8 - 32) < 0;
    if ( v8 == 32 )
      return 1;
  }
  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}
// 8061819: using guessed type int __fastcall sub_8061819(_DWORD, _DWORD);
// 806B2A4: using guessed type int dword_806B2A4;

//----- (08060421) --------------------------------------------------------
int __cdecl sub_8060421(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 65) > 0x19 )
    result = a1;
  else
    result = a1 + 32;
  return result;
}

//----- (08060457) --------------------------------------------------------
int __cdecl sub_8060457(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // esi
  unsigned __int8 *v3; // ebx
  int result; // eax
  unsigned __int8 v9; // [esp+1Eh] [ebp-Ah]
  unsigned __int8 v10; // [esp+1Fh] [ebp-9h]

  v2 = a1;
  v3 = a2;
  _CF = a1 < a2;
  _OF = __OFSUB__(a1, a2);
  _ZF = a1 == a2;
  _SF = a1 - a2 < 0;
  if ( a1 == a2 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  else
  {
    do
    {
      v9 = sub_8060421(*v2);
      v10 = sub_8060421(*v3);
      if ( !v9 )
        break;
      ++v2;
      ++v3;
    }
    while ( v9 == v10 );
    result = v9 - v10;
  }
  return result;
}

//----- (080604BD) --------------------------------------------------------
int __cdecl sub_80604BD(FILE *fp)
{
  bool v1; // ST26_1
  unsigned int v6; // eax
  void *v7; // eax
  int result; // eax
  bool v9; // [esp+1Dh] [ebp-Bh]
  bool v10; // [esp+1Fh] [ebp-9h]

  v9 = __fpending(fp) != 0;
  v1 = ferror_unlocked(fp) != 0;
  v10 = sub_805F4C1(fp) != 0;
  if ( v1 )
    goto LABEL_11;
  _CF = 0;
  _OF = 0;
  _ZF = v10 == 0;
  _SF = v10 < 0;
  if ( !v10 )
    goto LABEL_12;
  if ( v9
    || (v6 = *__errno_location(),
        _CF = v6 < 9,
        _OF = __OFSUB__(v6, 9),
        _ZF = v6 == 9,
        _SF = (signed int)(v6 - 9) < 0,
        v6 != 9) )
  {
LABEL_11:
    v7 = &loc_806054E;
    if ( v10 == 1 )
      v7 = &loc_8060559;
    dword_806B2C4 = (int)v7;
    sub_8061709();
    *__errno_location() = 0;
    result = -1;
  }
  else
  {
LABEL_12:
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 806B2C4: using guessed type int dword_806B2C4;

//----- (08060568) --------------------------------------------------------
_DWORD *__userpurge sub_8060568@<eax>(_DWORD *a1, double a2)
{
  int v2; // eax
  int v3; // eax
  int v4; // edx
  int v5; // ecx
  int v6; // eax
  bool v7; // zf
  void *v8; // eax
  int v10; // [esp-4h] [ebp-3Ch]
  double v11; // [esp+18h] [ebp-20h]

  v11 = a2;
  v2 = HIDWORD(a2);
  LOBYTE(v2) = a2 > -2147483648.0;
  v3 = v2 ^ 1;
  if ( (_BYTE)v3 )
  {
    sub_806113C(a1, 2147483648, 0);
    dword_806B2A4 = (int)&loc_8060705;
    v3 = sub_8061819(v5, v4);
  }
  LOBYTE(v3) = 2147483648.0 > v11;
  v6 = v3 ^ 1;
  v7 = (_BYTE)v6 == 0;
  v10 = v6;
  v8 = &loc_806061A;
  if ( v7 )
    v8 = &loc_806063D;
  dword_806B2D8 = (int)v8;
  sub_8061693();
  sub_806113C(a1, 0x7FFFFFFF, 999999999);
  return a1;
}
// 8061693: using guessed type int sub_8061693(void);
// 8061819: using guessed type int __fastcall sub_8061819(_DWORD, _DWORD);
// 806B2A4: using guessed type int dword_806B2A4;
// 806B2D8: using guessed type int dword_806B2D8;

//----- (0806070C) --------------------------------------------------------
int __usercall sub_806070C@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, int fd, int a5)
{
  int v5; // ST18_4
  int v6; // ST1C_4

  if ( fd >= 0 && fd <= 2 )
  {
    v5 = sub_806075D(a1, a2, a3, fd, a5);
    v6 = *__errno_location();
    close(fd);
    *__errno_location() = v6;
    fd = v5;
  }
  return fd;
}

//----- (0806075D) --------------------------------------------------------
int __usercall sub_806075D@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, int fd, int a5)
{
  if ( a5 & 0x80000 )
  {
    dword_806B2D8 = (int)&loc_8060791;
    sub_8061693();
  }
  return sub_805F5D6(a1, a2, a3, fd, 0, 3);
}
// 8061693: using guessed type int sub_8061693(void);
// 806B2D8: using guessed type int dword_806B2D8;

//----- (080607AA) --------------------------------------------------------
FILE *__usercall sub_80607AA@<eax>(int a1@<ebx>, int a2, char *modes)
{
  int v3; // edx
  int v4; // ecx
  int v5; // ST2C_4
  FILE *result; // eax
  int v11; // ST30_4
  FILE *stream; // [esp+1Ch] [ebp-1Ch]
  signed int v13; // [esp+20h] [ebp-18h]
  int fd; // [esp+24h] [ebp-14h]

  stream = (FILE *)fopen64(a2, modes);
  if ( !stream )
    return stream;
  v13 = fileno(stream);
  if ( v13 < 0 || v13 > 2 )
    return stream;
  fd = sub_8061206(v3, v4, a1, v13);
  if ( fd < 0 )
  {
    v5 = *__errno_location();
    sub_805F4C1(stream);
    *__errno_location() = v5;
    __asm { pushfw }
    result = 0;
    __asm { popfw }
    return result;
  }
  if ( !sub_805F4C1(stream) )
  {
    stream = fdopen(fd, modes);
    if ( stream )
      return stream;
  }
  v11 = *__errno_location();
  close(fd);
  *__errno_location() = v11;
  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}
// 80499F0: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (08060882) --------------------------------------------------------
void *sub_8060882()
{
  void *v4; // eax
  signed int v5; // eax
  int v6; // edx
  int v7; // ecx
  int v8; // eax
  void *v9; // eax
  int v10; // eax
  void *v11; // eax
  int v13; // [esp-4h] [ebp-CCh]
  size_t v14; // [esp+0h] [ebp-C8h]
  int v15; // [esp+4h] [ebp-C4h]
  int v16; // [esp+8h] [ebp-C0h]
  int v17; // [esp+Ch] [ebp-BCh]
  int v18; // [esp+10h] [ebp-B8h]
  void *ptr; // [esp+14h] [ebp-B4h]
  void *v20; // [esp+18h] [ebp-B0h]
  char *s; // [esp+1Ch] [ebp-ACh]
  void *v22; // [esp+20h] [ebp-A8h]
  int v23; // [esp+24h] [ebp-A4h]
  char *v24; // [esp+28h] [ebp-A0h]
  size_t n; // [esp+2Ch] [ebp-9Ch]
  size_t v26; // [esp+30h] [ebp-98h]
  int v27; // [esp+34h] [ebp-94h]
  void *dest; // [esp+38h] [ebp-90h]
  int fd; // [esp+3Ch] [ebp-8Ch]
  FILE *stream; // [esp+40h] [ebp-88h]
  int c; // [esp+44h] [ebp-84h]
  unsigned int v32; // [esp+BCh] [ebp-Ch]

  v32 = __readgsdword(0x14u);
  v20 = (void *)dword_806C0ED;
  if ( !dword_806C0ED )
  {
    ptr = 0;
    v24 = "charset.alias";
    s = getenv("CHARSETALIASDIR");
    if ( !s || !*s )
    {
      ptr = 0;
      s = "/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib";
    }
    n = strlen(s);
    v26 = strlen(v24);
    _CF = 0;
    _OF = 0;
    _ZF = n == 0;
    _SF = (n & 0x80000000) != 0;
    if ( n )
    {
      _ZF = s[n - 1] == 47;
      v13 = (unsigned __int8)s[n - 1];
      v4 = &loc_8060981;
      if ( _ZF )
        v4 = &loc_8060988;
      dword_806B254 = (int)v4;
      sub_80619F1();
      v5 = 1;
    }
    else
    {
      __asm { pushfw }
      v5 = 0;
      __asm { popfw }
    }
    v27 = v5;
    v14 = n + v5 + v26 + 1;
    dest = malloc(v14);
    if ( dest )
    {
      memcpy(dest, s, n);
      if ( v27 )
        *((_BYTE *)dest + n) = 47;
      memcpy((char *)dest + n + v27, v24, v26 + 1);
    }
    free(ptr);
    if ( !dest )
    {
      v20 = &unk_806503F;
      dword_806B2A4 = (int)&loc_8060DF0;
      sub_8061819(v7, v6);
    }
    fd = open64(dest, 0x20000);
    if ( fd >= 0 )
    {
      stream = fdopen(fd, "r");
      if ( stream )
      {
        v22 = 0;
        v23 = 0;
        while ( 1 )
        {
          while ( 1 )
          {
            v8 = getc_unlocked(stream);
            c = v8;
            if ( v8 == -1 )
              break;
            v13 = v8;
            v9 = &loc_8060B4F;
            if ( c == 10 )
              v9 = &loc_8060B7A;
            dword_806B268 = (int)v9;
            v10 = sub_806197F(v14, v15, v16, v17, v18, ptr, v20);
            if ( c != 32 )
            {
              v13 = v10;
              v11 = &loc_8060B7A;
              if ( c != 9 )
                v11 = &loc_8060B7F;
              dword_806B268 = (int)v11;
              sub_806197F(v14, v15, v16, v17, v18, ptr, v20);
            }
          }
          sub_805F4C1(stream);
          if ( !v23 )
            break;
          dword_806B268 = (int)&loc_8060DC5;
          sub_806197F(v14, v15, v16, v17, v18, ptr, v20);
        }
        v20 = &unk_806503F;
      }
      else
      {
        close(fd);
        v20 = &unk_806503F;
      }
    }
    else
    {
      v20 = &unk_806503F;
    }
    free(dest);
    dword_806C0ED = (int)v20;
  }
  return v20;
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 8061819: using guessed type int __fastcall sub_8061819(_DWORD, _DWORD);
// 806197F: using guessed type int __stdcall sub_806197F(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80619F1: using guessed type int sub_80619F1(void);
// 806B254: using guessed type int dword_806B254;
// 806B268: using guessed type int dword_806B268;
// 806B2A4: using guessed type int dword_806B2A4;
// 806C0ED: using guessed type int dword_806C0ED;

//----- (08060E1B) --------------------------------------------------------
const char *sub_8060E1B()
{
  char *v0; // ST1C_4
  const char *s1; // [esp+18h] [ebp-10h]
  char *s2; // [esp+1Ch] [ebp-Ch]

  s1 = nl_langinfo(14);
  if ( !s1 )
    s1 = (const char *)&unk_806503F;
  for ( s2 = (char *)sub_8060882(); *s2; s2 = &v0[strlen(v0) + 1] )
  {
    if ( !strcmp(s1, s2) || *s2 == 42 && !s2[1] )
    {
      s1 = &s2[strlen(s2) + 1];
      break;
    }
    v0 = &s2[strlen(s2) + 1];
  }
  if ( !*s1 )
    s1 = "ASCII";
  return s1;
}

//----- (08060ECE) --------------------------------------------------------
int __cdecl sub_8060ECE(char *s1, int a2, char *s2)
{
  int v3; // eax
  int v4; // edx
  int v5; // ecx
  void *v6; // eax
  int v7; // eax
  signed int v12; // eax
  void *v13; // eax
  int v15; // [esp-4h] [ebp-2Ch]
  int v16; // [esp+14h] [ebp-14h]

  *__errno_location() = 0;
  v3 = strcoll(s1, s2);
  v16 = v3;
  _ZF = v3 == 0;
  v15 = v3;
  v6 = &loc_8060FC4;
  if ( !_ZF )
    v6 = &loc_8060FCF;
  dword_806B2A4 = (int)v6;
  sub_8061819(v5, v4);
  v7 = *__errno_location();
  _CF = 0;
  _OF = 0;
  _ZF = v7 == 0;
  _SF = v7 < 0;
  if ( v7 )
  {
    v12 = 1;
  }
  else
  {
    __asm { pushfw }
    v12 = 0;
    __asm { popfw }
  }
  _ZF = v12 == 0;
  v15 = v12;
  v13 = &loc_8060FF9;
  if ( _ZF )
    v13 = &loc_8060ED9;
  dword_806B254 = (int)v13;
  sub_80619F1();
  return v16;
}
// 8060ECE: could not find valid save-restore pair for ebx
// 8061819: using guessed type int __fastcall sub_8061819(_DWORD, _DWORD);
// 80619F1: using guessed type int sub_80619F1(void);
// 806B254: using guessed type int dword_806B254;
// 806B2A4: using guessed type int dword_806B2A4;

//----- (08060FFE) --------------------------------------------------------
int __cdecl sub_8060FFE(void *s1, size_t n, void *s2, int a4)
{
  char v4; // ST1A_1
  char v5; // ST1B_1
  int v7; // [esp+1Ch] [ebp-Ch]

  if ( n == a4 && !memcmp(s1, s2, n) )
  {
    *__errno_location() = 0;
    v7 = 0;
  }
  else
  {
    v4 = *((_BYTE *)s1 + n);
    v5 = *((_BYTE *)s2 + a4);
    *((_BYTE *)s1 + n) = 0;
    *((_BYTE *)s2 + a4) = 0;
    v7 = sub_8060ECE((char *)s1, n + 1, (char *)s2);
    *((_BYTE *)s1 + n) = v4;
    *((_BYTE *)s2 + a4) = v5;
  }
  return v7;
}

//----- (080610DC) --------------------------------------------------------
int __cdecl sub_80610DC(void *s1, size_t n, void *s2, int a4)
{
  int result; // eax

  if ( n != a4 || memcmp(s1, s2, n) )
    return sub_8060ECE((char *)s1, n, (char *)s2);
  *__errno_location() = 0;
  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}

//----- (0806113C) --------------------------------------------------------
_DWORD *__userpurge sub_806113C@<eax>(_DWORD *a1, int a2, int a3)
{
  *a1 = a2;
  a1[1] = a3;
  return a1;
}

//----- (08061206) --------------------------------------------------------
int __usercall sub_8061206@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, int fd)
{
  return sub_805F5D6(a1, a2, a3, fd, 0, 3);
}

//----- (0806122B) --------------------------------------------------------
signed __int64 __cdecl sub_806122B(unsigned __int64 a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // esi
  signed __int64 result; // rax
  int v5; // ebp
  int v6; // ebp
  char v7; // sp
  char v8; // al
  unsigned __int64 v9; // rtt
  unsigned int v10; // esi
  unsigned int v11; // edi
  unsigned __int64 v12; // rax
  unsigned int v13; // [esp+0h] [ebp-18h]
  unsigned int v14; // [esp+4h] [ebp-14h]
  unsigned int v15; // [esp+8h] [ebp-10h]

  v14 = a1;
  v13 = a2;
  if ( !a3 )
  {
    if ( a2 > HIDWORD(a1) )
      return (unsigned int)(a1 / a2);
    v3 = a2;
    if ( !a2 )
      v3 = 1 / 0u;
    LODWORD(result) = __PAIR__(HIDWORD(a1) % v3, (unsigned int)a1) / v3;
    HIDWORD(result) = HIDWORD(a1) / v3;
    return result;
  }
  if ( a3 > HIDWORD(a1) )
    return 0LL;
  _BitScanReverse((unsigned int *)&v5, a3);
  v6 = v5 ^ 0x1F;
  if ( !v6 )
  {
    if ( v13 <= v14 || a3 < HIDWORD(a1) )
      return 1LL;
    return 0LL;
  }
  v7 = v6;
  v8 = 32 - v7;
  v15 = (a3 << v6) | (v13 >> v8);
  v13 <<= (unsigned int)&v13;
  LODWORD(v9) = (HIDWORD(a1) << (char)&v13) | (v14 >> (32 - (_DWORD)&v13));
  HIDWORD(v9) = HIDWORD(a1) >> (32 - v7);
  v10 = v9 % v15;
  v11 = v9 / v15;
  v12 = v13 * (unsigned __int64)v11;
  v13 = HIDWORD(v12);
  if ( v10 < HIDWORD(v12) || v14 << (char)&v13 < (unsigned int)v12 && v10 == v13 )
    result = v11 - 1;
  else
    result = v11;
  return result;
}

//----- (0806137E) --------------------------------------------------------
#error "8061428: call analysis failed (funcsize=192)"

//----- (080615AC) --------------------------------------------------------
int __cdecl sub_80615AC(int a1)
{
  return __cxa_atexit(a1, 0, dword_806B2F0);
}
// 8049AC0: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 806B2F0: using guessed type int dword_806B2F0;

//----- (080615DB) --------------------------------------------------------
int __cdecl sub_80615DB(int a1, int a2)
{
  return __xstat64(3, a1, a2);
}
// 8049EB0: using guessed type int __cdecl __xstat64(_DWORD, _DWORD, _DWORD);

//----- (0806160A) --------------------------------------------------------
int __cdecl sub_806160A(int a1, int a2)
{
  return __fxstat64(3, a1, a2);
}
// 8049A30: using guessed type int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD);

//----- (08061693) --------------------------------------------------------
#error "8061699: positive sp value has been found (funcsize=0)"

//----- (08061709) --------------------------------------------------------
#error "806170F: positive sp value has been found (funcsize=0)"

//----- (080617C8) --------------------------------------------------------
#error "8061811: positive sp value has been found (funcsize=21)"

//----- (08061819) --------------------------------------------------------
#error "806181F: positive sp value has been found (funcsize=0)"

//----- (080618A3) --------------------------------------------------------
#error "80618A9: positive sp value has been found (funcsize=0)"

//----- (0806190F) --------------------------------------------------------
#error "8061915: positive sp value has been found (funcsize=0)"

//----- (0806197F) --------------------------------------------------------
#error "8061985: positive sp value has been found (funcsize=0)"

//----- (080619F1) --------------------------------------------------------
#error "80619F7: positive sp value has been found (funcsize=0)"

//----- (08061ADD) --------------------------------------------------------
#error "8061AE3: positive sp value has been found (funcsize=0)"

//----- (08061B4D) --------------------------------------------------------
#error "8061B53: positive sp value has been found (funcsize=0)"

//----- (08061BBB) --------------------------------------------------------
#error "8061BC1: positive sp value has been found (funcsize=0)"

//----- (08061BD0) --------------------------------------------------------
int (**sub_8061BD0())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_806AECC;
  v1 = &off_806AED0 - off_806AECC;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_806AECC[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 806AECC: using guessed type int (*off_806AECC[2])();
// 806AED0: using guessed type int (*off_806AED0)();

//----- (08061C34) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 44 decompilation failure(s) on 338 function(s)"
