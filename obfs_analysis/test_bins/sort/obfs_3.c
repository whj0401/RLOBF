/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8049750();
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// int raise(int sig);
// int dup2(int fd, int fd2);
// int strcmp(const char *s1, const char *s2);
// int putc_unlocked(int c, FILE *stream);
// ssize_t read(int fd, void *buf, size_t nbytes);
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void _exit(int status);
// void *memmove(void *dest, const void *src, size_t n);
// void free(void *ptr);
// uintmax_t strtoumax(const char *nptr, char **endptr, int base);
// void *memcpy(void *dest, const void *src, size_t n);
// int mbsinit(const mbstate_t *ps);
// int ferror(FILE *stream);
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// int fclose(FILE *stream);
// int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
// __sighandler_t signal(int sig, __sighandler_t handler);
// int __cdecl __sched_cpucount(_DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// double __cdecl strtold(_DWORD, _DWORD); weak
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// int fputc_unlocked(int c, FILE *stream);
// int __cdecl getrlimit64(_DWORD, _DWORD); weak
// int __cdecl stpcpy(_DWORD, _DWORD); weak
// int execlp(const char *file, const char *arg, ...);
// int sysconf(int name);
// __uid_t getuid(void);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// int unlink(const char *name);
// int sigismember(const sigset_t *set, int signo);
// int fflush_unlocked(FILE *stream);
// char *textdomain(const char *domainname);
// int iswprint(wint_t wc);
// int __cdecl fopen64(_DWORD, _DWORD); weak
// int ferror_unlocked(FILE *stream);
// int __cdecl mkostemp64(_DWORD, _DWORD); weak
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD); weak
// size_t __ctype_get_mb_cur_max(void);
// __pid_t waitpid(__pid_t pid, int *stat_loc, int options);
// int pthread_sigmask(int how, const __sigset_t *newmask, __sigset_t *oldmask);
// char *strcpy(char *dest, const char *src);
// size_t __fpending(FILE *fp);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __stdcall __cxa_atexit(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int pthread_cond_signal(pthread_cond_t *cond);
// void error(int status, int errnum, const char *format, ...);
// size_t fread_unlocked(void *ptr, size_t size, size_t n, FILE *stream);
// int strcoll(const char *s1, const char *s2);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int sysinfo(struct sysinfo *info);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// char *strchr(const char *s, int c);
// size_t strlen(const char *s);
// int fprintf(FILE *stream, const char *format, ...);
// ssize_t write(int fd, const void *buf, size_t n);
// int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *cond_attr);
// int __cdecl open64(_DWORD, _DWORD); weak
// int fcntl(int fd, int cmd, ...);
// int sigaddset(sigset_t *set, int signo);
// size_t strxfrm(char *dest, const char *src, size_t n);
// int setvbuf(FILE *stream, char *buf, int modes, size_t n);
// __gid_t getgid(void);
// void *memset(void *s, int c, size_t n);
// int *__errno_location(void);
// void *memchr(const void *s, int c, size_t n);
// int fileno(FILE *stream);
// int fgetc(FILE *stream);
// int pipe(int pipedes[2]);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// int __cdecl ftruncate64(_DWORD, _DWORD, _DWORD); weak
// int sigemptyset(sigset_t *set);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// int toupper(int c);
// void clearerr_unlocked(FILE *stream);
// char *strrchr(const char *s, int c);
// int pthread_join(pthread_t th, void **thread_return);
// struct lconv *localeconv(void);
// __pid_t getppid(void);
// int __cdecl explicit_bzero(_DWORD, _DWORD); weak
// int __cdecl pipe2(_DWORD, _DWORD); weak
// int __cdecl euidaccess(_DWORD, _DWORD); weak
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int nanosleep(const struct timespec *requested_time, struct timespec *remaining);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// char *bindtextdomain(const char *domainname, const char *dirname);
// int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl sched_getaffinity(_DWORD, _DWORD, _DWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// int feof_unlocked(FILE *stream);
// void abort(void);
// int __cdecl __xstat64(_DWORD, _DWORD, _DWORD); weak
// int strtol(const char *nptr, char **endptr, int base);
// char *ngettext(const char *msgid1, const char *msgid2, unsigned int n);
// int close(int fd);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// void *calloc(size_t nmemb, size_t size);
// int _gmon_start__(void); weak
void sub_8049F73();
void sub_8049F90();
int sub_8049FA0();
int sub_804A010();
int sub_804A030();
void sub_804A08F();
void sub_804A0AA();
signed int sub_804A0BA();
void sub_804A19C();
void sub_804A1B7();
int sub_804A1C7();
void sub_804A2A9();
void sub_804A2C4();
int sub_804A2D4();
void sub_804A3C8();
void sub_804A3E3();
signed int sub_804A3F3();
// int __usercall sub_804A45A@<eax>(int a1@<eax>, int (__cdecl *a2)(signed int, int)@<edx>);
void sub_804A503();
void sub_804A51E();
int sub_804A52E();
void sub_804A625();
void sub_804A640();
int __fastcall sub_804A650(int a1, int a2);
void sub_804A767();
void sub_804A782();
int sub_804A792();
void sub_804A886();
void sub_804A8A1();
int sub_804A8B1();
int sub_804A93B();
void sub_804A9AF();
void sub_804A9CA();
int sub_804A9DA();
void sub_804AABC();
void sub_804AAD7();
int __fastcall sub_804AAE7(int a1, int a2);
int nullsub_4(void); // weak
int sub_804AB5E();
// int __usercall sub_804ABCB@<eax>(void (__cdecl *a1)(int *)@<eax>, double a2@<st0>);
void sub_804AC17();
void sub_804AC32();
int sub_804AC42();
void sub_804AD4B();
void sub_804AD66();
int sub_804AD76();
void sub_804AE58();
void sub_804AE73();
int sub_804AE83();
void sub_804AF7E();
void sub_804AF99();
int sub_804AFA9();
void sub_804B0A0();
void sub_804B0BB();
int sub_804B0CB();
// int __usercall sub_804B17D@<eax>(void (__cdecl *a1)(int *)@<eax>);
void sub_804B1DB();
void sub_804B1F6();
int sub_804B206();
void sub_804B334();
void sub_804B34F();
int sub_804B35F();
int sub_804B3E9();
void sub_804B45D();
void sub_804B478();
int sub_804B488();
int nullsub_5(void); // weak
int sub_804B4E6();
void sub_804B586();
void sub_804B5A1();
int sub_804B5B1();
int __cdecl sub_804B6C8(int a1);
int __cdecl sub_804B6F4(unsigned __int8 a1);
int __cdecl sub_804B706(unsigned __int8 a1);
int __cdecl sub_804B745(int a1, int a2);
int sub_804B78B();
int sub_804B7B6();
int __cdecl sub_804B7E1(char *s1); // idb
void __cdecl __noreturn sub_804B980(int a1, char *a2);
void __cdecl __noreturn sub_804BA80(int a1, int a2);
void __cdecl __noreturn sub_804BAE2(int status); // idb
int __cdecl sub_804BD9E(int a1);
int __cdecl sub_804BDD3(int a1);
int __cdecl sub_804BE1C(int a1, unsigned int a2);
bool __cdecl sub_804BE3A(int a1, int a2);
int __cdecl sub_804BE5F(int a1);
// int __usercall sub_804BFD6@<eax>(int a1@<edx>, int a2@<ecx>, double a3@<st0>, int a4);
int __cdecl sub_804C04A(int a1);
int __cdecl sub_804C0F3(int a1);
int sub_804C125();
int sub_804C154();
int sub_804C16D();
int sub_804C18C();
int *__cdecl sub_804C21B(int *a1, char a2);
// FILE *__usercall sub_804C43E@<eax>(double a1@<st0>, char *s1, char *modes);
// FILE *__usercall sub_804C5A3@<eax>(double a1@<st0>, char *s1, char *modes);
// void __usercall sub_804C609(double a1@<st0>, FILE *stream, int a3);
int __cdecl sub_804C6C0(int fd, int fd2); // idb
int __cdecl sub_804C712(int pipedes[2], int); // idb
// int *__usercall sub_804C8A8@<eax>(double a1@<st0>, FILE **a2, char a3);
// int *__usercall sub_804CA06@<eax>(double a1@<st0>, FILE **a2);
int __cdecl sub_804CA21(int a1);
int __cdecl sub_804CC13(int a1);
void __cdecl __noreturn sub_804CCA8(char *name); // idb
int sub_804CDE7(); // weak
int compar(const void *, const void *); // idb
void sub_804CE55();
// unsigned int __usercall sub_804D08D@<eax>(double st7_0@<st0>, int edx0@<edx>, int ecx0@<ecx>, int a1, char a2, char *a3);
// int __usercall sub_804D318@<eax>(int edx0@<edx>, int ecx0@<ecx>, int a1, char a2, char *nptr);
int __cdecl sub_804D576(int a1, char a2, char *nptr);
// int __usercall sub_804D634@<eax>(double a1@<st0>);
// int __usercall sub_804D849@<eax>(double a1@<st0>, int a2, unsigned int a3, int a4, unsigned int a5, int a6);
int __cdecl sub_804DA6D(int, int, size_t size); // idb
int __cdecl sub_804DAF3(_DWORD *a1);
char *__cdecl sub_804DB0E(char **a1, int a2);
char *__cdecl sub_804DC73(char **a1, int a2);
int __cdecl sub_804DE26(int, FILE *stream, int); // idb
int __cdecl sub_804E2F1(char **a1);
int __cdecl sub_804E3CF(_BYTE *a1);
int __cdecl sub_804E442(unsigned __int8 *a1, _BYTE *a2);
int __cdecl sub_804E4FD(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_804E5BA(int a1, int a2);
signed int __cdecl sub_804E63E(int a1, int a2);
int __cdecl sub_804E76A(unsigned __int8 *a1, unsigned __int8 **a2);
int sub_804E908(); // weak
// unsigned int __usercall sub_804E920@<eax>(double a1@<st0>, int a2);
int __cdecl sub_804E9EC(char *dest, char *src, size_t n);
// int __usercall sub_804EB01@<eax>(double a1@<st0>, int a2, size_t a3, int a4, size_t a5);
signed int __cdecl sub_804F19A(char *a1, unsigned int a2);
int __cdecl sub_804F20A(int a1, int a2);
// signed int __usercall sub_804F2AD@<eax>(int a1@<edx>, int a2@<ecx>, _BYTE *a3);
int __cdecl sub_804F2FB(int a1, int a2);
int __cdecl sub_804F5CA(int a1);
// int __usercall sub_804F61D@<eax>(int a1@<edx>, int a2@<ecx>, int a3);
// _BYTE *__usercall sub_804F6A0@<eax>(double a1@<st0>, _BYTE *edx0@<edx>, int ecx0@<ecx>, int a2, _BYTE *a3);
// unsigned int __usercall sub_804F833@<eax>(double a1@<st0>, int ecx0@<ecx>, int *a2, char a3);
int __cdecl sub_80500BE(int a1, int a2);
int __cdecl sub_8050E84(int a1, int a2);
int __cdecl sub_8050FCE(int, FILE *stream, int); // idb
// signed int __usercall sub_8051110@<eax>(double a1@<st0>, char *a2);
// unsigned int __usercall sub_80514AC@<eax>(double a1@<st0>, int a2, unsigned int a3, void **a4);
// void __usercall sub_80515BE(double a1@<st0>, int a2, int a3, int a4, FILE *stream, int a6, void *a7);
// int __usercall sub_8051F8E@<eax>(double a1@<st0>, int a2, int a3, int a4, FILE *stream, int a6);
int __cdecl sub_805201F(int a1, unsigned int a2, int a3);
// _DWORD *__usercall sub_805216B@<eax>(int a1@<ecx>, double a2@<st0>, int a3, unsigned int a4, int a5, unsigned __int8 a6);
pthread_mutex_t *__cdecl sub_8052475(unsigned int a1, int a2, int a3);
int __cdecl sub_80525A8(_DWORD *a1, pthread_mutex_t *a2, int a3, unsigned int a4, int a5, char a6);
_BOOL4 __cdecl sub_8052750(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80527C4(pthread_mutex_t *a1);
int __cdecl sub_80527DA(pthread_mutex_t *a1);
int __cdecl sub_8052821(int a1, int a2);
int __cdecl sub_8052887(int a1, int a2);
// pthread_mutex_t *__usercall sub_80528D4@<eax>(double a1@<st0>, int a2);
// int __usercall sub_805293D@<eax>(int a1@<edx>, int a2@<ecx>, int a3, FILE *stream, int a5);
int __cdecl sub_80529DE(int, int, FILE *stream, int); // idb
int __cdecl sub_8052E59(int a1, int a2);
int __cdecl sub_8052F55(int a1, _DWORD *a2);
// void __usercall __noreturn sub_8052FDF(double a1@<st0>, int a2, int a3, FILE *stream, int a5);
int sub_8053085(); // weak
// void *__usercall start_routine@<eax>(double a1@<st0>, void *a2);
// int __usercall sub_80530F4@<eax>(int a1@<ecx>, double a2@<st0>, int a3, int a4, int a5, int a6, int a7, FILE *stream, int a9);
// unsigned int __usercall sub_8053339@<eax>(double a1@<st0>, int a2, int a3, int a4, char *s1);
unsigned int __cdecl sub_8053655(int a1, unsigned int a2);
void __cdecl sub_8053728(int a1);
// void __usercall sub_805378E(double a1@<st0>, int a2, int a3, int a4, char *s1);
// unsigned int __usercall sub_8053C27@<eax>(double a1@<st0>, char **a2, unsigned int a3, char *a4, unsigned int a5);
_DWORD *__cdecl sub_80540B7(void *src);
// int __usercall sub_8054104@<eax>(double a1@<st0>, int a2, char *msgid);
int __cdecl sub_8054152(int a1);
// int __usercall sub_80542B4@<eax>(double a1@<st0>, int a2@<edx>, int ecx0@<ecx>, int nptr, int a3, char *msgid);
int __cdecl sub_80543BD(int sig); // idb
// char *__usercall sub_80543E8@<eax>(double a1@<st0>, int edx0@<edx>, int ecx0@<ecx>, char *a2, int a3, int a4);
void *__cdecl sub_8054532(void *s);
// void __usercall main(double a1@<st0>, int argc, char **argv);
int __cdecl sub_8055506(char *s2, char *format, char *, int, int, int, int, int, int, int, char, char, int, int, int, int, int, int, size_t nmemb, void *ptr, char *s1, char *, int, int, int, int, int, int, int, FILE *stream, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, char src, int, int, int, int, int, char, char, char, int, int, int); // idb
void __noreturn sub_8055D8F();
int __cdecl sub_8055DA3(char *s, int a2);
// void __usercall __noreturn sub_8055EC8(double a1@<st0>, char *a2, int a3, int a4);
// int __usercall sub_8055F4B@<eax>(double a1@<st0>, int a2, int a3, size_t n);
// int __usercall sub_805607B@<eax>(double a1@<st0>, void *s1, char *s, int a4);
// int __usercall sub_80561A8@<eax>(double a1@<st0>);
_DWORD *__cdecl sub_805628C(_DWORD *a1);
_DWORD *__cdecl sub_80562D8(_DWORD *a1, int a2);
_DWORD *__cdecl sub_80562E5(int *a1, _DWORD *a2);
_DWORD *__cdecl sub_8056352(int *a1, _DWORD *a2);
// int __usercall sub_805664E@<eax>(size_t a1@<edx>, int a2@<ecx>, void *src, size_t a4, int a5);
int *__cdecl sub_80568D9(int *a1, unsigned int a2, int *a3);
int __cdecl sub_80575A3(int a1, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_80575F4@<eax>(int a1@<edx>, int a2@<ecx>, FILE *stream, int a4);
int __cdecl sub_8057655(_BYTE **a1);
signed int __cdecl sub_8057754(unsigned __int8 a1);
// int __usercall sub_80577F4@<eax>(int a1@<edx>, int a2@<ecx>, double a3@<st0>, int a4, unsigned int a5, int a6, unsigned int a7);
int __cdecl sub_8057A50(char *s1, char *s2); // idb
int __cdecl sub_8057CFE(int category); // idb
int __cdecl sub_8057D7D(int a1);
int __cdecl sub_8057D88(int a1);
int __cdecl sub_8057D93(int a1);
unsigned int __cdecl sub_8057D9E(int a1);
int __cdecl sub_8057F85(int a1, int a2);
// bool __usercall sub_8058314@<al>(int edx0@<edx>, int a2@<ecx>, unsigned int a1);
unsigned int __cdecl sub_80583A5(unsigned int a1);
bool __cdecl sub_8058487(int a1, int a2);
signed int __cdecl sub_8058495(int a1);
unsigned int __cdecl sub_8058594(unsigned int a1, int a2);
// int __usercall sub_8058621@<eax>(int a1@<edx>, int a2@<ecx>, double a3@<st0>, int a4, int a5, int a6);
// int __usercall sub_80589CB@<eax>(int edx0@<edx>, int a2@<ecx>, int a1);
int __cdecl sub_8058A2B(int a1, _DWORD *a2);
int __cdecl sub_8058A4E(int a1, int a2, _DWORD *a3, char a4);
signed int __cdecl sub_8058C03(int a1, int a2, char a3);
signed int __cdecl sub_8058DDF(int a1, unsigned int a2);
signed int __cdecl sub_8058FD4(unsigned int *a1, int a2, _DWORD *a3);
int __cdecl sub_8059258(unsigned int *a1, int a2);
int __cdecl sub_80592B8(int a1, int a2);
_DWORD *__cdecl sub_80594AF(void *a1, unsigned int a2);
void __cdecl sub_8059542(void *ptr);
int __cdecl sub_8059562(int a1, int a2);
// int __usercall sub_8059669@<eax>(double a1@<st0>, int *a2);
// unsigned int __usercall sub_80596F9@<eax>(double a1@<st0>, int a2, unsigned int a3, unsigned int a4, int (__cdecl *a5)(int, int));
int __cdecl sub_8059832(int a1, unsigned int a2, int (__cdecl *a3)(int, int));
int __cdecl sub_80598D7(int a1, int a2);
int __cdecl sub_80599B1(unsigned int a1, int a2);
int __cdecl sub_8059A28(signed __int64 a1, int a2);
signed int __cdecl sub_8059ADB(char *a1, int a2, char a3);
int sub_8059E41();
signed int __cdecl sub_8059EDA(int a1);
int __cdecl sub_8059FB7(char *nptr); // idb
unsigned int __cdecl sub_805A139(int a1);
long double sub_805A1BA();
long double sub_805A27C();
int __cdecl sub_805A358(int pipedes[2], int); // idb
int sub_805A628();
char *__cdecl sub_805A69F(char *s);
unsigned int __cdecl sub_805A84E(int a1, unsigned __int8 a2, char a3);
int *__cdecl sub_805A9BE(int *a1, int a2, int a3);
void __cdecl __noreturn sub_805AA24(int a1, int a2);
int __stdcall sub_805AA63(int); // weak
// void *__usercall sub_805AABF@<eax>(double a1@<st0>, char *msgid);
// int __usercall sub_805ABEF@<eax>(double st7_0@<st0>, int a1, unsigned int a2, char *a3, size_t a4, char *a5, int a6, int a7, char *a8, char *a9);
// void *__usercall sub_805BC1C@<eax>(int a1@<edx>, int a2@<ecx>, double a3@<st0>, char *a4, size_t a5, _DWORD *a6, int a7);
// void *__usercall sub_805BE0A@<eax>(double st7_0@<st0>, signed int a1, char *a2, size_t a3, int a4);
// void *__usercall sub_805C053@<eax>(double a1@<st0>, signed int a2, char *a3);
// void *__usercall sub_805C07D@<eax>(double a1@<st0>, signed int a2, char *a3, size_t a4);
void __cdecl __noreturn sub_805C0E3(int a1, int a2);
void __cdecl __noreturn sub_805C121(int a1, int a2);
void __cdecl __noreturn sub_805C15E(int a1);
void __cdecl __noreturn sub_805C1C3(int a1, int a2, int a3);
// void *__usercall sub_805C203@<eax>(double a1@<st0>, char *a2, size_t a3, unsigned __int8 a4);
// void *__usercall sub_805C2AD@<eax>(double a1@<st0>, char *a2, unsigned __int8 a3);
// void *__usercall sub_805C2D6@<eax>(double a1@<st0>, char *a2);
void __cdecl __noreturn sub_805C313(int a1, int a2);
// void *__usercall sub_805C3D8@<eax>(double a1@<st0>, signed int a2, int a3, int a4, char *a5);
// void *__usercall sub_805C408@<eax>(double a1@<st0>, signed int a2, int a3, int a4, char *a5, size_t a6);
// void *__usercall sub_805C502@<eax>(double st7_0@<st0>, signed int a1, char *a2, size_t a3);
// void *__usercall sub_805C54D@<eax>(double st7_0@<st0>, signed int a1, char *a2);
// void *__usercall sub_805C56F@<eax>(double st7_0@<st0>, char *a1);
int __cdecl sub_805C5FD(int); // weak
void __cdecl __noreturn sub_805C626(int errnum, char *format, int); // idb
_DWORD *__cdecl sub_805C659(int a1, int a2);
unsigned int __cdecl sub_805C68E(int a1, int a2, size_t nbytes);
// char *__usercall sub_805C8D5@<eax>(double a1@<st0>, int a2, size_t n);
int __cdecl sub_805C9E9(int a1, int a2);
int __cdecl sub_805C9F7(int, void *ptr, size_t n); // idb
int __cdecl sub_805CA9B(int, void *dest, size_t n); // idb
int __cdecl sub_805CBD5(int, void *ptr, size_t n); // idb
int __cdecl sub_805CC1D(void *ptr); // idb
int __cdecl sub_805CC99(int a1);
int __cdecl sub_805CCB0(int a1, __int16 a2);
int *__cdecl sub_805CCE1(int *a1, _DWORD *a2);
_DWORD *__cdecl sub_805D1D6(_DWORD *a1);
signed int __cdecl sub_805D5FA(_DWORD *a1);
_DWORD *__cdecl sub_805D79E(_DWORD *a1);
bool __cdecl sub_805D9A8(FILE *stream, int a2);
int __cdecl sub_805DCAC(int a1, int a2);
int __cdecl sub_805DCD5(_BYTE *a1, _BYTE *a2, char a3);
_DWORD __cdecl sub_805DE58(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_805E402(int a1, int a2, int a3, int a4);
int __cdecl sub_805E42A(int fd); // idb
int __cdecl sub_805E48D(FILE *stream, int, int, int, int, int); // idb
int __cdecl sub_805EA40(FILE *stream, int, int, int, int); // idb
int sub_805EAB6(FILE *stream, int a2, int a3, int a4, ...);
void *__cdecl sub_805EB56(unsigned int a1, unsigned int a2);
// void *__usercall sub_805EBB9@<eax>(int a1@<edx>, int ecx0@<ecx>, void *ptr, int a2, int a3);
void *__cdecl sub_805EC69(size_t size);
void *__cdecl sub_805EC7C(size_t size);
void __noreturn sub_805ECCF(); // weak
void *__cdecl sub_805ECDC(void *ptr, size_t size);
void *__cdecl sub_805EDD1(size_t nmemb, size_t size);
void *__cdecl sub_805EE0E(void *src, size_t n);
void __noreturn sub_805EE5C();
void __cdecl __noreturn sub_805EE95(int errnum);
int __cdecl sub_805EFDF(void *s1, size_t n, void *s2, int); // idb
signed int __cdecl sub_805F06B(double a1);
signed int __cdecl sub_805F0ED(unsigned int *a1, unsigned int a2);
int __cdecl sub_805F131(unsigned int *a1, unsigned int a2, int a3);
int __cdecl sub_805F17B(char *nptr, int, int base, int, char *s); // idb
void __cdecl sub_805F5F4(int a1, int a2, int a3, int a4, int a5, int status);
void __cdecl __noreturn sub_805F6DA(int a1, int a2, char a3, int a4, int a5);
signed int __cdecl sub_805F71D(int a1, signed int a2);
int __cdecl sub_805F7A9(int a1, int a2, int a3);
// int __usercall sub_805F808@<eax>(int a1@<edx>, int ecx0@<ecx>, char *nptr, int a2, int base, int a4);
// int __usercall sub_805FD2C@<eax>(double a1@<st0>, FILE *stream);
int __cdecl sub_805FDEF(int fd, int cmd, char); // idb
int __cdecl sub_805FF59(FILE *stream); // idb
// int __usercall sub_805FF92@<eax>(double a1@<st0>, FILE *fp);
int __cdecl sub_8060000(FILE *stream, int, int, int); // idb
size_t __cdecl sub_8060119(wchar_t *pwc, char *s, size_t n, mbstate_t *p);
int __cdecl sub_8060197(int a1, int a2);
int __cdecl sub_8060228(int a1, int a2);
signed int __cdecl sub_80602A8(int a1, signed int a2, int a3);
signed int __cdecl sub_80603A0(int a1, signed int a2, int a3, int a4, int a5);
_DWORD __cdecl sub_8060429(_DWORD, _DWORD); // weak
int __cdecl sub_806064D(int a1, unsigned int a2);
int __cdecl sub_8060895(int a1, char a2);
_BOOL4 __cdecl sub_8060980(signed int a1);
_BOOL4 __cdecl sub_80609C9(signed int a1);
_BOOL4 __cdecl sub_8060A7F(int a1);
signed int __cdecl sub_8060B29(signed int a1);
int __cdecl sub_8060BBF(int a1);
int __cdecl sub_8060C0A(unsigned __int8 *a1, unsigned __int8 *a2);
// int __usercall sub_8060C6F@<eax>(double a1@<st0>, FILE *fp);
// _DWORD *__userpurge sub_8060CF0@<eax>(_DWORD *a1, double a2);
// int __usercall sub_8060F1E@<eax>(int a1@<edx>, int a2@<ecx>, int fd, int a4);
// int __usercall sub_8060F6F@<eax>(int a1@<edx>, int a2@<ecx>, int fd, int a4);
// FILE *__usercall sub_8060FEC@<eax>(double a1@<st0>, int a2, char *modes);
void *sub_8061111();
char *sub_806160A();
int __cdecl sub_8061742(char *s1, int a2, char *s2);
int __cdecl sub_8061835(void *s1, size_t n, void *s2, int); // idb
int __cdecl sub_8061953(void *s1, size_t n, void *s2, int); // idb
// _DWORD *__userpurge sub_80619EF@<eax>(_DWORD *a1, int a2, int a3);
int __cdecl sub_8061AAD(int fd); // idb
signed __int64 __cdecl sub_8061AD2(unsigned __int64 a1, unsigned int a2, unsigned int a3);
_DWORD __cdecl sub_8061C5F(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_8061E71(int a1, int a2);
int sub_8061EB4(); // weak
int __cdecl sub_8061EC1(int a1, int a2);
int __cdecl sub_8061EF0(int a1, int a2);
int sub_8061FAB(void); // weak
// void __usercall __noreturn sub_8061FE8(int a1@<ebx>, int a2@<edi>, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11);
int sub_8062042(); // weak
int __fastcall sub_80620D8(_DWORD, _DWORD); // weak
int __fastcall sub_8062148(_DWORD, _DWORD); // weak
int __fastcall sub_80621CD(_DWORD, _DWORD); // weak
int sub_806223F(void); // weak
int __stdcall sub_80622AD(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int sub_8062323(void); // weak
int __cdecl sub_806239B();
int sub_8062420(void); // weak
int sub_80624B3(void); // weak
int __fastcall sub_806253E(_DWORD, _DWORD); // weak
int __fastcall sub_80625B6(_DWORD, _DWORD); // weak
// int __usercall sub_8062626@<eax>(double@<st0>); weak
int sub_8062696(void); // weak
int __fastcall sub_8062704(_DWORD, _DWORD); // weak
int sub_806277E(void); // weak
int __fastcall sub_80627EE(_DWORD, _DWORD); // weak
int (**sub_8062800())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN locret_804A65F; // weak
_UNKNOWN locret_804AAF6; // weak
_UNKNOWN locret_804AE92; // weak
_UNKNOWN loc_804B0F7; // weak
_UNKNOWN locret_804B5C4; // weak
_UNKNOWN loc_804B5D8; // weak
_UNKNOWN loc_804B6EA; // weak
_UNKNOWN loc_804B6F2; // weak
_UNKNOWN loc_804B87E; // weak
_UNKNOWN loc_804B896; // weak
_UNKNOWN loc_804B9DB; // weak
_UNKNOWN loc_804B9DD; // weak
_UNKNOWN loc_804BA55; // weak
_UNKNOWN loc_804BDFC; // weak
_UNKNOWN locret_804BE1A; // weak
_UNKNOWN loc_804BECB; // weak
_UNKNOWN loc_804BED0; // weak
_UNKNOWN loc_804BF47; // weak
_UNKNOWN loc_804BFCC; // weak
_UNKNOWN loc_804C097; // weak
_UNKNOWN loc_804C0B2; // weak
_UNKNOWN loc_804C1E3; // weak
_UNKNOWN loc_804C309; // weak
_UNKNOWN loc_804C313; // weak
_UNKNOWN loc_804C3BA; // weak
_UNKNOWN loc_804C3C6; // weak
_UNKNOWN loc_804C544; // weak
_UNKNOWN loc_804C56B; // weak
_UNKNOWN sub_804C5F6; // weak
_UNKNOWN loc_804C64D; // weak
_UNKNOWN loc_804C65A; // weak
_UNKNOWN loc_804C768; // weak
_UNKNOWN loc_804C82E; // weak
_UNKNOWN loc_804CA00; // weak
_UNKNOWN loc_804CB89; // weak
_UNKNOWN loc_804CD17; // weak
_UNKNOWN loc_804CE78; // weak
_UNKNOWN loc_804D042; // weak
_UNKNOWN loc_804D109; // weak
_UNKNOWN loc_804D117; // weak
_UNKNOWN loc_804D246; // weak
_UNKNOWN loc_804D56E; // weak
_UNKNOWN loc_804D60B; // weak
_UNKNOWN loc_804D62F; // weak
_UNKNOWN loc_804D690; // weak
_UNKNOWN loc_804D8F8; // weak
_UNKNOWN loc_804D912; // weak
_UNKNOWN loc_804D9A3; // weak
_UNKNOWN loc_804D9BF; // weak
_UNKNOWN loc_804DA02; // weak
_UNKNOWN loc_804DA0C; // weak
_UNKNOWN loc_804DA55; // weak
_UNKNOWN loc_804DA64; // weak
_UNKNOWN loc_804DBE0; // weak
_UNKNOWN loc_804DD5B; // weak
_UNKNOWN loc_804DD5F; // weak
_UNKNOWN loc_804DDA2; // weak
_UNKNOWN loc_804DDE7; // weak
_UNKNOWN loc_804DE92; // weak
_UNKNOWN loc_804DEDA; // weak
_UNKNOWN loc_804DFF6; // weak
_UNKNOWN loc_804E011; // weak
_UNKNOWN loc_804E146; // weak
_UNKNOWN loc_804E175; // weak
_UNKNOWN loc_804E199; // weak
_UNKNOWN loc_804E1BE; // weak
_UNKNOWN loc_804E1C7; // weak
_UNKNOWN loc_804E1CD; // weak
_UNKNOWN loc_804E234; // weak
_UNKNOWN loc_804E2EA; // weak
_UNKNOWN loc_804E373; // weak
_UNKNOWN loc_804E384; // weak
_UNKNOWN loc_804E489; // weak
_UNKNOWN loc_804E505; // weak
_UNKNOWN loc_804E541; // weak
_UNKNOWN loc_804E56A; // weak
_UNKNOWN loc_804E56C; // weak
_UNKNOWN loc_804E697; // weak
_UNKNOWN loc_804E69E; // weak
_UNKNOWN locret_804E768; // weak
_UNKNOWN loc_804E781; // weak
_UNKNOWN loc_804E7BD; // weak
_UNKNOWN loc_804E800; // weak
_UNKNOWN loc_804E82F; // weak
_UNKNOWN loc_804E86C; // weak
_UNKNOWN loc_804EA1C; // weak
_UNKNOWN loc_804ECD2; // weak
_UNKNOWN loc_804ECF7; // weak
_UNKNOWN loc_804ECFC; // weak
_UNKNOWN loc_804ED1E; // weak
_UNKNOWN loc_804ED43; // weak
_UNKNOWN loc_804ED48; // weak
_UNKNOWN loc_804ED7D; // weak
_UNKNOWN loc_804EFE1; // weak
_UNKNOWN loc_804F01C; // weak
_UNKNOWN loc_804F021; // weak
_UNKNOWN loc_804F13C; // weak
_UNKNOWN loc_804F15E; // weak
_UNKNOWN loc_804F212; // weak
_UNKNOWN loc_804F253; // weak
_UNKNOWN loc_804F269; // weak
_UNKNOWN loc_804F29D; // weak
_UNKNOWN loc_804F2EA; // weak
_UNKNOWN loc_804F2F1; // weak
_UNKNOWN loc_804F35D; // weak
_UNKNOWN loc_804F3EE; // weak
_UNKNOWN loc_804F49A; // weak
_UNKNOWN loc_804F4D2; // weak
_UNKNOWN loc_804F54D; // weak
_UNKNOWN loc_804F569; // weak
_UNKNOWN loc_804F56E; // weak
_UNKNOWN loc_804F577; // weak
_UNKNOWN loc_804F57D; // weak
_UNKNOWN loc_804F6EB; // weak
_UNKNOWN loc_804F6F7; // weak
_UNKNOWN loc_804F778; // weak
_UNKNOWN loc_804F784; // weak
_UNKNOWN loc_804F7A8; // weak
_UNKNOWN loc_804F7B4; // weak
_UNKNOWN loc_804F7D8; // weak
_UNKNOWN loc_804F7E4; // weak
_UNKNOWN loc_804F808; // weak
_UNKNOWN loc_804F814; // weak
_UNKNOWN loc_804FB92; // weak
_UNKNOWN loc_804FBD8; // weak
_UNKNOWN loc_804FC43; // weak
_UNKNOWN loc_804FC50; // weak
_UNKNOWN loc_804FC7A; // weak
_UNKNOWN loc_804FCB5; // weak
_UNKNOWN loc_804FCF2; // weak
_UNKNOWN loc_804FD37; // weak
_UNKNOWN loc_804FD3E; // weak
_UNKNOWN loc_804FD83; // weak
_UNKNOWN loc_804FDA3; // weak
_UNKNOWN loc_804FDBA; // weak
_UNKNOWN loc_804FF17; // weak
_UNKNOWN loc_804FF6A; // weak
_UNKNOWN loc_805002D; // weak
_UNKNOWN loc_805005C; // weak
_UNKNOWN loc_80500A3; // weak
_UNKNOWN loc_805012C; // weak
_UNKNOWN loc_8050208; // weak
_UNKNOWN loc_8050233; // weak
_UNKNOWN loc_80502A3; // weak
_UNKNOWN loc_805035B; // weak
_UNKNOWN loc_8050387; // weak
_UNKNOWN loc_80503A1; // weak
_UNKNOWN loc_80504A8; // weak
_UNKNOWN loc_80505E2; // weak
_UNKNOWN loc_805061F; // weak
_UNKNOWN loc_805072A; // weak
_UNKNOWN loc_805073D; // weak
_UNKNOWN loc_8050770; // weak
_UNKNOWN loc_8050E45; // weak
_UNKNOWN loc_8050E64; // weak
_UNKNOWN loc_8050E6A; // weak
_UNKNOWN loc_8050F42; // weak
_UNKNOWN loc_805100F; // weak
_UNKNOWN loc_80510AA; // weak
_UNKNOWN loc_80511CE; // weak
_UNKNOWN loc_805145E; // weak
_UNKNOWN loc_805158E; // weak
_UNKNOWN loc_80515A5; // weak
_UNKNOWN loc_80515B5; // weak
_UNKNOWN loc_8051990; // weak
_UNKNOWN loc_8051A7D; // weak
_UNKNOWN loc_8051F00; // weak
_UNKNOWN loc_805204C; // weak
_UNKNOWN loc_8052081; // weak
_UNKNOWN loc_80520C8; // weak
_UNKNOWN loc_80520DF; // weak
_UNKNOWN loc_8052152; // weak
_UNKNOWN locret_8052169; // weak
_UNKNOWN loc_8052225; // weak
_UNKNOWN loc_80522C6; // weak
_UNKNOWN loc_805231B; // weak
_UNKNOWN loc_8052325; // weak
_UNKNOWN loc_80523C3; // weak
_UNKNOWN loc_80523E2; // weak
_UNKNOWN loc_805244E; // weak
_UNKNOWN locret_80527C2; // weak
_UNKNOWN loc_8052967; // weak
_UNKNOWN loc_80529C3; // weak
_UNKNOWN locret_80529DC; // weak
_UNKNOWN loc_8052BED; // weak
_UNKNOWN loc_8052BFA; // weak
_UNKNOWN loc_8052C5B; // weak
_UNKNOWN loc_8052C85; // weak
_UNKNOWN loc_8052CD8; // weak
_UNKNOWN loc_8052CF9; // weak
_UNKNOWN loc_8052D9C; // weak
_UNKNOWN loc_8052DEA; // weak
_UNKNOWN loc_8052E10; // weak
_UNKNOWN loc_8052F21; // weak
_UNKNOWN loc_8052F8D; // weak
_UNKNOWN loc_80531A1; // weak
_UNKNOWN loc_8053200; // weak
_UNKNOWN loc_80533D8; // weak
_UNKNOWN loc_80533FF; // weak
_UNKNOWN loc_805340B; // weak
_UNKNOWN loc_8053432; // weak
_UNKNOWN loc_8053465; // weak
_UNKNOWN loc_805346C; // weak
_UNKNOWN loc_805348E; // weak
_UNKNOWN loc_80534BC; // weak
_UNKNOWN loc_80534FC; // weak
_UNKNOWN loc_805352D; // weak
_UNKNOWN loc_8053567; // weak
_UNKNOWN loc_805356C; // weak
_UNKNOWN loc_80535A8; // weak
_UNKNOWN loc_80535FD; // weak
_UNKNOWN loc_805364B; // weak
_UNKNOWN loc_80536D4; // weak
_UNKNOWN loc_8053810; // weak
_UNKNOWN loc_8053A44; // weak
_UNKNOWN loc_8053E05; // weak
_UNKNOWN loc_8053E2D; // weak
_UNKNOWN loc_8053E7D; // weak
_UNKNOWN loc_8053F3B; // weak
_UNKNOWN loc_8053F58; // weak
_UNKNOWN loc_8053F63; // weak
_UNKNOWN loc_8053FDE; // weak
_UNKNOWN loc_8054098; // weak
_UNKNOWN loc_80541A1; // weak
_UNKNOWN loc_8054282; // weak
_UNKNOWN loc_8054366; // weak
_UNKNOWN loc_80543AC; // weak
_UNKNOWN loc_80543B3; // weak
_UNKNOWN loc_8054402; // weak
_UNKNOWN loc_8054506; // weak
_UNKNOWN loc_805450A; // weak
_UNKNOWN loc_805452D; // weak
_UNKNOWN loc_80545E6; // weak
_UNKNOWN loc_8054609; // weak
_UNKNOWN loc_8054610; // weak
_UNKNOWN loc_80546ED; // weak
_UNKNOWN loc_80546FD; // weak
_UNKNOWN loc_8054757; // weak
_UNKNOWN loc_8054761; // weak
_UNKNOWN loc_805484D; // weak
_UNKNOWN loc_8054873; // weak
_UNKNOWN loc_8054979; // weak
_UNKNOWN loc_80549DB; // weak
_UNKNOWN loc_8054A05; // weak
_UNKNOWN loc_8054B1B; // weak
_UNKNOWN loc_8054B22; // weak
_UNKNOWN loc_8054B52; // weak
_UNKNOWN loc_8054BAA; // weak
_UNKNOWN loc_8054BCE; // weak
_UNKNOWN loc_8054BF4; // weak
_UNKNOWN loc_8054C22; // weak
_UNKNOWN loc_8054C2C; // weak
_UNKNOWN loc_8054D73; // weak
_UNKNOWN loc_8054D87; // weak
_UNKNOWN loc_8054D9B; // weak
_UNKNOWN loc_8054DBB; // weak
_UNKNOWN loc_8054DDF; // weak
_UNKNOWN loc_8054F17; // weak
_UNKNOWN loc_8054F3B; // weak
_UNKNOWN loc_8054FC4; // weak
_UNKNOWN loc_8054FD9; // weak
_UNKNOWN loc_80550ED; // weak
_UNKNOWN loc_8055102; // weak
_UNKNOWN loc_8055126; // weak
_UNKNOWN loc_805514C; // weak
_UNKNOWN loc_8055209; // weak
_UNKNOWN loc_805522D; // weak
_UNKNOWN loc_8055501; // weak
_UNKNOWN loc_80557A3; // weak
_UNKNOWN loc_8055DCE; // weak
_UNKNOWN loc_8055E9D; // weak
_UNKNOWN loc_8055EC3; // weak
_UNKNOWN loc_8055FCA; // weak
_UNKNOWN loc_8056010; // weak
_UNKNOWN loc_8056388; // weak
_UNKNOWN loc_80566E7; // weak
_UNKNOWN loc_805673B; // weak
_UNKNOWN loc_8056774; // weak
_UNKNOWN loc_80567CF; // weak
_UNKNOWN loc_80567FA; // weak
_UNKNOWN loc_8057619; // weak
_UNKNOWN locret_8057653; // weak
_UNKNOWN loc_805766B; // weak
_UNKNOWN loc_8057729; // weak
_UNKNOWN loc_80577E5; // weak
_UNKNOWN loc_80577E9; // weak
_UNKNOWN locret_80577F2; // weak
_UNKNOWN loc_8057862; // weak
_UNKNOWN loc_8057898; // weak
_UNKNOWN loc_805792C; // weak
_UNKNOWN loc_8057A18; // weak
_UNKNOWN loc_8057A1D; // weak
_UNKNOWN loc_8057A49; // weak
_UNKNOWN loc_8057A9E; // weak
_UNKNOWN loc_8057AA8; // weak
_UNKNOWN loc_8057D56; // weak
_UNKNOWN loc_8057D77; // weak
_UNKNOWN loc_8058355; // weak
_UNKNOWN loc_8058368; // weak
_UNKNOWN loc_80583E1; // weak
_UNKNOWN loc_8058470; // weak
_UNKNOWN loc_8058646; // weak
_UNKNOWN loc_805864D; // weak
_UNKNOWN loc_8058688; // weak
_UNKNOWN loc_8058692; // weak
_UNKNOWN loc_80589F4; // weak
_UNKNOWN loc_8058A0B; // weak
_UNKNOWN loc_8058AAD; // weak
_UNKNOWN loc_8058AE1; // weak
_UNKNOWN loc_8058B12; // weak
_UNKNOWN loc_8058B5E; // weak
_UNKNOWN loc_8058B6F; // weak
_UNKNOWN loc_8058BF7; // weak
_UNKNOWN loc_8058D48; // weak
_UNKNOWN loc_8058D52; // weak
_UNKNOWN loc_8058DA2; // weak
_UNKNOWN loc_8058E31; // weak
_UNKNOWN loc_8058E3B; // weak
_UNKNOWN loc_805902E; // weak
_UNKNOWN loc_8059036; // weak
_UNKNOWN loc_80590F6; // weak
_UNKNOWN loc_8059114; // weak
_UNKNOWN locret_8059256; // weak
_UNKNOWN locret_80592B6; // weak
_UNKNOWN loc_8059475; // weak
_UNKNOWN loc_80594AA; // weak
_UNKNOWN locret_80594AD; // weak
_UNKNOWN loc_8059511; // weak
_UNKNOWN loc_805961A; // weak
_UNKNOWN loc_8059765; // weak
_UNKNOWN loc_80597E1; // weak
_UNKNOWN loc_80597E3; // weak
_UNKNOWN loc_8059895; // weak
_UNKNOWN loc_80599C6; // weak
_UNKNOWN loc_8059A23; // weak
_UNKNOWN loc_8059B70; // weak
_UNKNOWN loc_8059C08; // weak
_UNKNOWN loc_8059C3D; // weak
_UNKNOWN loc_8059D41; // weak
_UNKNOWN loc_8059DB2; // weak
_UNKNOWN loc_8059DC6; // weak
_UNKNOWN loc_8059E07; // weak
_UNKNOWN loc_8059E85; // weak
_UNKNOWN loc_8059EC3; // weak
_UNKNOWN loc_8059ED1; // weak
_UNKNOWN loc_8059F0D; // weak
_UNKNOWN loc_8059F2C; // weak
_UNKNOWN loc_8059F72; // weak
_UNKNOWN loc_8059F88; // weak
_UNKNOWN loc_805A267; // weak
_UNKNOWN loc_805A343; // weak
_UNKNOWN loc_805A3B8; // weak
_UNKNOWN loc_805A3CA; // weak
_UNKNOWN loc_805A40E; // weak
_UNKNOWN locret_805A626; // weak
_UNKNOWN loc_805A663; // weak
_UNKNOWN loc_805A69A; // weak
_UNKNOWN loc_805A78A; // weak
_UNKNOWN loc_805A79B; // weak
_UNKNOWN loc_805A928; // weak
_UNKNOWN loc_805AA5E; // weak
_UNKNOWN loc_805AAFF; // weak
_UNKNOWN loc_805AB41; // weak
_UNKNOWN loc_805AB48; // weak
_UNKNOWN loc_805AB82; // weak
_UNKNOWN locret_805ABED; // weak
_UNKNOWN loc_805AC68; // weak
_UNKNOWN loc_805AD5E; // weak
_UNKNOWN loc_805AE00; // weak
_UNKNOWN loc_805AE1E; // weak
_UNKNOWN loc_805AE53; // weak
_UNKNOWN loc_805AE81; // weak
_UNKNOWN loc_805AE9A; // weak
_UNKNOWN loc_805AED2; // weak
_UNKNOWN loc_805AF1F; // weak
_UNKNOWN loc_805AF24; // weak
_UNKNOWN loc_805B03E; // weak
_UNKNOWN loc_805B043; // weak
_UNKNOWN loc_805B06E; // weak
_UNKNOWN loc_805B083; // weak
_UNKNOWN loc_805B1F4; // weak
_UNKNOWN loc_805B204; // weak
_UNKNOWN loc_805B21B; // weak
_UNKNOWN loc_805B274; // weak
_UNKNOWN loc_805B284; // weak
_UNKNOWN loc_805B2FB; // weak
_UNKNOWN loc_805B308; // weak
_UNKNOWN loc_805B431; // weak
_UNKNOWN loc_805B46F; // weak
_UNKNOWN loc_805B4AB; // weak
_UNKNOWN loc_805B4F6; // weak
_UNKNOWN loc_805B4FE; // weak
_UNKNOWN loc_805B52C; // weak
_UNKNOWN loc_805B567; // weak
_UNKNOWN loc_805B5AA; // weak
_UNKNOWN loc_805B5AF; // weak
_UNKNOWN loc_805B74D; // weak
_UNKNOWN loc_805B771; // weak
_UNKNOWN loc_805B777; // weak
_UNKNOWN loc_805B7A1; // weak
_UNKNOWN loc_805B7E6; // weak
_UNKNOWN loc_805B7F6; // weak
_UNKNOWN loc_805B824; // weak
_UNKNOWN loc_805B878; // weak
_UNKNOWN loc_805B8AE; // weak
_UNKNOWN loc_805B8EB; // weak
_UNKNOWN loc_805B929; // weak
_UNKNOWN loc_805B92D; // weak
_UNKNOWN loc_805B931; // weak
_UNKNOWN loc_805B967; // weak
_UNKNOWN loc_805B984; // weak
_UNKNOWN loc_805BA50; // weak
_UNKNOWN loc_805BA7A; // weak
_UNKNOWN loc_805BAF2; // weak
_UNKNOWN loc_805BB4E; // weak
_UNKNOWN loc_805BC48; // weak
_UNKNOWN loc_805BD45; // weak
_UNKNOWN loc_805BD50; // weak
_UNKNOWN loc_805C768; // weak
_UNKNOWN loc_805C920; // weak
_UNKNOWN loc_805C943; // weak
_UNKNOWN loc_805CA59; // weak
_UNKNOWN loc_805CA5B; // weak
_UNKNOWN loc_805CAA9; // weak
_UNKNOWN loc_805CB4F; // weak
_UNKNOWN loc_805CB9A; // weak
_UNKNOWN loc_805CC68; // weak
_UNKNOWN loc_805D06A; // weak
_UNKNOWN loc_805D3EF; // weak
_UNKNOWN loc_805D9DB; // weak
_UNKNOWN loc_805DA3D; // weak
_UNKNOWN loc_805DA50; // weak
_UNKNOWN loc_805DA71; // weak
_UNKNOWN loc_805DC05; // weak
_UNKNOWN loc_805DC12; // weak
_UNKNOWN loc_805DDD4; // weak
_UNKNOWN locret_805DE56; // weak
_UNKNOWN loc_805E455; // weak
_UNKNOWN loc_805E488; // weak
_UNKNOWN loc_805E4FC; // weak
_UNKNOWN loc_805E9CB; // weak
_UNKNOWN loc_805EBE6; // weak
_UNKNOWN loc_805EC20; // weak
_UNKNOWN loc_805ED31; // weak
_UNKNOWN loc_805F273; // weak
_UNKNOWN loc_805F29A; // weak
_UNKNOWN loc_805F398; // weak
_UNKNOWN loc_805F3BB; // weak
_UNKNOWN loc_805F3E5; // weak
_UNKNOWN loc_805F3EB; // weak
_UNKNOWN loc_805F3ED; // weak
_UNKNOWN loc_805F5C2; // weak
_UNKNOWN loc_805F7B8; // weak
_UNKNOWN loc_805F7F9; // weak
_UNKNOWN loc_805F840; // weak
_UNKNOWN loc_805F86B; // weak
_UNKNOWN loc_805F916; // weak
_UNKNOWN loc_805FD15; // weak
_UNKNOWN loc_805FD19; // weak
_UNKNOWN locret_805FD2A; // weak
_UNKNOWN loc_805FFC6; // weak
_UNKNOWN loc_805FFE8; // weak
_UNKNOWN locret_805FFFE; // weak
_UNKNOWN loc_806003B; // weak
_UNKNOWN loc_8060064; // weak
_UNKNOWN loc_8060087; // weak
_UNKNOWN loc_80600F7; // weak
_UNKNOWN locret_8060226; // weak
_UNKNOWN locret_8060282; // weak
_UNKNOWN loc_8060296; // weak
_UNKNOWN loc_80602CD; // weak
_UNKNOWN loc_80602D4; // weak
_UNKNOWN loc_80609A4; // weak
_UNKNOWN loc_80609B3; // weak
_UNKNOWN loc_80609ED; // weak
_UNKNOWN loc_8060A01; // weak
_UNKNOWN loc_8060B52; // weak
_UNKNOWN loc_8060B70; // weak
_UNKNOWN loc_8060B77; // weak
_UNKNOWN loc_8060BED; // weak
_UNKNOWN loc_8060F17; // weak
_UNKNOWN loc_8060F9A; // weak
_UNKNOWN loc_8060FA1; // weak
_UNKNOWN loc_8061079; // weak
_UNKNOWN loc_8061334; // weak
_UNKNOWN loc_8061351; // weak
_UNKNOWN loc_80615D1; // weak
_UNKNOWN loc_8061648; // weak
_UNKNOWN loc_806166B; // weak
_UNKNOWN loc_806169C; // weak
_UNKNOWN loc_80616B3; // weak
_UNKNOWN loc_80616E4; // weak
_UNKNOWN loc_80616FC; // weak
_UNKNOWN loc_8061807; // weak
_UNKNOWN loc_806180E; // weak
_UNKNOWN loc_8061830; // weak
_UNKNOWN loc_806189B; // weak
_UNKNOWN loc_806194E; // weak
_UNKNOWN locret_80619ED; // weak
_UNKNOWN loc_8061B72; // weak
_UNKNOWN loc_8061BA7; // weak
char s = '\0'; // idb
char aSortWordSortAc[176] = "      --sort=WORD             sort according to WORD:\n                                general-numeric -g, human-numeric -h, month -M,\n                                numeric -n"; // idb
struct option longopts = { "ignore-leading-blanks", 0, NULL, 98 }; // idb
char *off_8063DFC[3] = { "quiet", "silent", "diagnose-first" }; // weak
char aCccgeneralNume[19] = "CCcgeneral-numeric"; // weak
void *off_8063E44 = (void *)0x8063E0F; // weak
char byte_8063E60[6] = { 'g', 'h', 'M', 'n', 'R', 'V' }; // idb
char byte_80640D0[256] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x06',
  '\0',
  '\x03',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0',
  '\x04',
  '\0',
  '\0',
  '\0',
  '\0',
  '\b',
  '\a',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
int sig[11] = { 14, 1, 2, 13, 3, 15, 29, 27, 26, 24, 25 }; // idb
_UNKNOWN unk_8064D50; // weak
_UNKNOWN unk_8064DA0; // weak
_UNKNOWN unk_8064F9E; // weak
_UNKNOWN unk_8064FAE; // weak
_UNKNOWN unk_8064FB2; // weak
_UNKNOWN unk_8064FB5; // weak
_UNKNOWN unk_8065C9F; // weak
_UNKNOWN unk_8066354; // weak
_UNKNOWN unk_8066357; // weak
int dword_8066EF8 = 392; // weak
_UNKNOWN unk_8067388; // weak
_UNKNOWN unk_806738B; // weak
_UNKNOWN unk_80683C4; // weak
_UNKNOWN unk_80683C7; // weak
int dword_8068EE4 = 201589760; // weak
int (*off_806BEB4[2])() = { &sub_804A030, &sub_804A010 }; // weak
int (*off_806BEB8)() = &sub_804A010; // weak
int (*dword_806C008)(void) = NULL; // weak
int dword_806C20C = 0; // weak
int dword_806C220 = 0; // weak
int dword_806C234 = 0; // weak
int dword_806C248 = 0; // weak
int dword_806C25C = 0; // weak
int dword_806C270 = 0; // weak
int dword_806C284 = 0; // weak
int dword_806C298 = 0; // weak
int dword_806C2AC = 0; // weak
int dword_806C2C0 = 0; // weak
int dword_806C2D4 = 0; // weak
int dword_806C2E8 = 0; // weak
int dword_806C2FC = 0; // weak
int dword_806C310 = 0; // weak
int dword_806C324 = 0; // weak
int dword_806C338 = 0; // weak
int dword_806C358 = 0; // weak
int dword_806C370 = 0; // weak
char byte_806C38C = '\n'; // weak
char *off_806C3AC = "APR"; // weak
int dword_806C3B0[] = { 4 }; // weak
size_t dword_806C40C = 262144u; // idb
int dword_806C410 = 128; // weak
int dword_806C414 = 16; // idb
int *off_806C418 = &dword_806D1D7; // weak
int off_806C42C = 134630600; // idb
int off_806C430 = 134569359; // idb
int status = 1; // idb
int dword_806C44C = 1; // weak
int dword_806C450 = 256; // weak
void *off_806C454 = &unk_806D2F7; // weak
int *off_806C458 = &dword_806C450; // weak
_UNKNOWN unk_806C46C; // weak
_UNKNOWN unk_806C48C; // weak
_UNKNOWN unk_806C48F; // weak
_UNKNOWN unk_806C494; // weak
_UNKNOWN unk_806C497; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int program_invocation_name; // weak
int optind; // weak
FILE *stdin; // idb
FILE *stdout; // idb
int (*obstack_alloc_failed_handler)(void); // weak
char *optarg; // idb
char byte_806C50C; // weak
_UNKNOWN unk_806C80B; // weak
char byte_806C874; // weak
_UNKNOWN unk_806CB73; // weak
char byte_806CC49; // weak
_UNKNOWN unk_806CC4D; // weak
int dword_806CD17; // weak
int dword_806CD1B; // weak
char byte_806CD1F; // weak
char byte_806CD20; // weak
int dword_806CD23; // weak
int dword_806CD27; // weak
int dword_806CD2B; // weak
int dword_806CD2F; // weak
char byte_806CD37[256]; // idb
_UNKNOWN unk_806CE37; // weak
_UNKNOWN unk_806CF37; // weak
char byte_806D037[256]; // idb
size_t size; // idb
void *ptr; // idb
int dword_806D13F; // weak
int dword_806D143; // weak
char byte_806D147; // weak
char byte_806D148; // weak
char byte_806D149; // weak
char byte_806D14A; // weak
int dword_806D14B; // weak
char *arg; // idb
char byte_806D153; // weak
__sigset_t set; // idb
int dword_806D1D7; // weak
int dword_806D1DB; // weak
int dword_806D1DF; // weak
_UNKNOWN unk_806D1F7; // weak
int dword_806D293; // weak
int dword_806D297; // weak
int dword_806D29B; // weak
char byte_806D29F; // weak
int dword_806D2A3; // weak
int dword_806D2A7; // weak
int dword_806D2B7[]; // weak
int dword_806D2BB; // weak
int dword_806D2BF; // weak
int dword_806D2C3; // weak
int dword_806D2C7; // weak
int dword_806D2CB; // weak
int dword_806D2CF; // weak
int dword_806D2D3; // weak
int dword_806D2D7; // weak
int dword_806D2DB; // weak
int dword_806D2DF; // weak
int dword_806D2E3; // weak
_UNKNOWN unk_806D2F7; // weak
int dword_806D3F7; // weak
int dword_806D3FB; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (0804972C) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 8049F30: using guessed type int _gmon_start__(void);

//----- (08049750) --------------------------------------------------------
int sub_8049750()
{
  return dword_806C008();
}
// 806C008: using guessed type int (*dword_806C008)(void);

//----- (08049F40) --------------------------------------------------------
#error "8049F43: positive sp value has been found (funcsize=2)"

//----- (08049F73) --------------------------------------------------------
void sub_8049F73()
{
  ;
}

//----- (08049F90) --------------------------------------------------------
void sub_8049F90()
{
  ;
}

//----- (08049FA0) --------------------------------------------------------
int sub_8049FA0()
{
  int result; // eax

  result = 134661283 - (_DWORD)&program_invocation_short_name;
  if ( (unsigned int)(134661283 - (_DWORD)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 8049FA0: could not find valid save-restore pair for ebp
// 806C4A0: using guessed type int program_invocation_short_name;

//----- (0804A010) --------------------------------------------------------
int sub_804A010()
{
  int result; // eax

  if ( !byte_806C50C )
  {
    result = sub_8049FA0();
    byte_806C50C = 1;
  }
  return result;
}
// 804A010: could not find valid save-restore pair for ebp
// 806C50C: using guessed type char byte_806C50C;

//----- (0804A030) --------------------------------------------------------
int sub_804A030()
{
  return 0;
}
// 804A030: could not find valid save-restore pair for ebp

//----- (0804A08F) --------------------------------------------------------
void sub_804A08F()
{
  ;
}

//----- (0804A0AA) --------------------------------------------------------
void sub_804A0AA()
{
  ;
}

//----- (0804A0BA) --------------------------------------------------------
signed int sub_804A0BA()
{
  return 3;
}
// 804A0BA: could not find valid save-restore pair for ebp

//----- (0804A19C) --------------------------------------------------------
void sub_804A19C()
{
  ;
}

//----- (0804A1B7) --------------------------------------------------------
void sub_804A1B7()
{
  ;
}

//----- (0804A1C7) --------------------------------------------------------
int sub_804A1C7()
{
  int result; // eax

  result = &unk_806C48F - &unk_806C48C;
  if ( (unsigned int)(&unk_806C48F - &unk_806C48C) > 6 )
    result = 0;
  return result;
}
// 804A1C7: could not find valid save-restore pair for ebp

//----- (0804A2A9) --------------------------------------------------------
void sub_804A2A9()
{
  ;
}

//----- (0804A2C4) --------------------------------------------------------
void sub_804A2C4()
{
  ;
}

//----- (0804A2D4) --------------------------------------------------------
int sub_804A2D4()
{
  int result; // eax

  result = &unk_806C48F - &unk_806C48C;
  if ( (unsigned int)(&unk_806C48F - &unk_806C48C) > 6 )
    result = 0;
  return result;
}
// 804A2D4: could not find valid save-restore pair for ebp

//----- (0804A3C8) --------------------------------------------------------
void sub_804A3C8()
{
  ;
}

//----- (0804A3E3) --------------------------------------------------------
void sub_804A3E3()
{
  ;
}

//----- (0804A3F3) --------------------------------------------------------
signed int sub_804A3F3()
{
  return 3;
}
// 804A3F3: could not find valid save-restore pair for ebp

//----- (0804A45A) --------------------------------------------------------
int __usercall sub_804A45A@<eax>(int a1@<eax>, int (__cdecl *a2)(signed int, int)@<edx>)
{
  return a2(134653008, a1);
}

//----- (0804A503) --------------------------------------------------------
void sub_804A503()
{
  ;
}

//----- (0804A51E) --------------------------------------------------------
void sub_804A51E()
{
  ;
}

//----- (0804A52E) --------------------------------------------------------
int sub_804A52E()
{
  int result; // eax

  result = &unk_806C48F - &unk_806C48C;
  if ( (unsigned int)(&unk_806C48F - &unk_806C48C) > 6 )
    result = 0;
  return result;
}
// 804A52E: could not find valid save-restore pair for ebp

//----- (0804A625) --------------------------------------------------------
void sub_804A625()
{
  ;
}

//----- (0804A640) --------------------------------------------------------
void sub_804A640()
{
  ;
}

//----- (0804A650) --------------------------------------------------------
int __fastcall sub_804A650(int a1, int a2)
{
  int result; // eax
  int (__stdcall *v3)(void *, int, int, int, int, int); // eax
  int v4; // [esp+4h] [ebp-18h]
  int v5; // [esp+8h] [ebp-14h]
  int v6; // [esp+Ch] [ebp-10h]
  int v7; // [esp+10h] [ebp-Ch]
  int v8; // [esp+14h] [ebp-8h]
  int v9; // [esp+18h] [ebp-4h]

  result = &unk_806C48F - &unk_806C48C;
  if ( (unsigned int)(&unk_806C48F - &unk_806C48C) > 6 )
  {
    v9 = 0;
    dword_806C234 = (int)&locret_804A65F;
    v3 = (int (__stdcall *)(void *, int, int, int, int, int))sub_8062704(a1, a2);
    result = v3(&unk_806C48C, v4, v5, v6, v7, v8);
  }
  return result;
}
// 8062704: using guessed type int __fastcall sub_8062704(_DWORD, _DWORD);
// 806C234: using guessed type int dword_806C234;

//----- (0804A767) --------------------------------------------------------
void sub_804A767()
{
  ;
}

//----- (0804A782) --------------------------------------------------------
void sub_804A782()
{
  ;
}

//----- (0804A792) --------------------------------------------------------
int sub_804A792()
{
  int result; // eax

  result = &unk_806C48F - &unk_806C48C;
  if ( (unsigned int)(&unk_806C48F - &unk_806C48C) > 6 )
    result = 0;
  return result;
}
// 804A792: could not find valid save-restore pair for ebp

//----- (0804A886) --------------------------------------------------------
void sub_804A886()
{
  ;
}

//----- (0804A8A1) --------------------------------------------------------
void sub_804A8A1()
{
  ;
}

//----- (0804A8B1) --------------------------------------------------------
int sub_804A8B1()
{
  int result; // eax

  result = &unk_806C80B - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_806C80B - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 804A8B1: could not find valid save-restore pair for ebp
// 806C4A0: using guessed type int program_invocation_short_name;

//----- (0804A93B) --------------------------------------------------------
int sub_804A93B()
{
  int result; // eax

  result = sub_804A8B1();
  byte_806C874 = 1;
  return result;
}
// 806C874: using guessed type char byte_806C874;

//----- (0804A9AF) --------------------------------------------------------
void sub_804A9AF()
{
  ;
}

//----- (0804A9CA) --------------------------------------------------------
void sub_804A9CA()
{
  ;
}

//----- (0804A9DA) --------------------------------------------------------
int sub_804A9DA()
{
  int result; // eax

  result = &unk_806C48F - &unk_806C48C;
  if ( (unsigned int)(&unk_806C48F - &unk_806C48C) > 6 )
    result = 0;
  return result;
}
// 804A9DA: could not find valid save-restore pair for ebp

//----- (0804AABC) --------------------------------------------------------
void sub_804AABC()
{
  ;
}

//----- (0804AAD7) --------------------------------------------------------
void sub_804AAD7()
{
  ;
}

//----- (0804AAE7) --------------------------------------------------------
int __fastcall sub_804AAE7(int a1, int a2)
{
  int result; // eax
  int (__stdcall *v3)(void *, int, int, int, int, int); // eax
  int v4; // [esp+4h] [ebp-18h]
  int v5; // [esp+8h] [ebp-14h]
  int v6; // [esp+Ch] [ebp-10h]
  int v7; // [esp+10h] [ebp-Ch]
  int v8; // [esp+14h] [ebp-8h]
  int v9; // [esp+18h] [ebp-4h]

  result = &unk_806C48F - &unk_806C48C;
  if ( (unsigned int)(&unk_806C48F - &unk_806C48C) > 6 )
  {
    v9 = 0;
    dword_806C234 = (int)&locret_804AAF6;
    v3 = (int (__stdcall *)(void *, int, int, int, int, int))sub_8062704(a1, a2);
    result = v3(&unk_806C48C, v4, v5, v6, v7, v8);
  }
  return result;
}
// 8062704: using guessed type int __fastcall sub_8062704(_DWORD, _DWORD);
// 806C234: using guessed type int dword_806C234;

//----- (0804AB5E) --------------------------------------------------------
int sub_804AB5E()
{
  return nullsub_4();
}
// 804AB5E: could not find valid save-restore pair for ebp
// 804AB5D: using guessed type int nullsub_4(void);

//----- (0804ABCB) --------------------------------------------------------
int __usercall sub_804ABCB@<eax>(void (__cdecl *a1)(int *)@<eax>, double a2@<st0>)
{
  int savedregs; // [esp+18h] [ebp+0h]

  a1(&dword_8068EE4);
  savedregs = 0;
  dword_806C25C = (int)nullsub_4;
  sub_8062626(a2);
  return nullsub_4();
}
// 804AB5D: using guessed type int nullsub_4(void);
// 8062626: using guessed type int __usercall sub_8062626@<eax>(double@<st0>);
// 8068EE4: using guessed type int dword_8068EE4;
// 806C25C: using guessed type int dword_806C25C;

//----- (0804AC17) --------------------------------------------------------
void sub_804AC17()
{
  ;
}

//----- (0804AC32) --------------------------------------------------------
void sub_804AC32()
{
  ;
}

//----- (0804AC42) --------------------------------------------------------
int sub_804AC42()
{
  int result; // eax

  result = &unk_80683C7 - &unk_80683C4;
  if ( (unsigned int)(&unk_80683C7 - &unk_80683C4) > 6 )
    result = 0;
  return result;
}
// 804AC42: could not find valid save-restore pair for ebp

//----- (0804AD4B) --------------------------------------------------------
void sub_804AD4B()
{
  ;
}

//----- (0804AD66) --------------------------------------------------------
void sub_804AD66()
{
  ;
}

//----- (0804AD76) --------------------------------------------------------
int sub_804AD76()
{
  int result; // eax

  result = &unk_806C48F - &unk_806C48C;
  if ( (unsigned int)(&unk_806C48F - &unk_806C48C) > 6 )
    result = 0;
  return result;
}
// 804AD76: could not find valid save-restore pair for ebp

//----- (0804AE58) --------------------------------------------------------
void sub_804AE58()
{
  ;
}

//----- (0804AE73) --------------------------------------------------------
void sub_804AE73()
{
  ;
}

//----- (0804AE83) --------------------------------------------------------
int sub_804AE83()
{
  int result; // eax
  int (__stdcall *v1)(void *, int, int, int, int, int); // eax
  int v2; // [esp+4h] [ebp-18h]
  int v3; // [esp+8h] [ebp-14h]
  int v4; // [esp+Ch] [ebp-10h]
  int v5; // [esp+10h] [ebp-Ch]
  int v6; // [esp+14h] [ebp-8h]
  int v7; // [esp+18h] [ebp-4h]

  result = &unk_806C48F - &unk_806C48C;
  if ( (unsigned int)(&unk_806C48F - &unk_806C48C) > 6 )
  {
    v7 = 0;
    dword_806C2C0 = (int)&locret_804AE92;
    v1 = (int (__stdcall *)(void *, int, int, int, int, int))sub_806239B();
    result = v1(&unk_806C48C, v2, v3, v4, v5, v6);
  }
  return result;
}
// 806C2C0: using guessed type int dword_806C2C0;

//----- (0804AF7E) --------------------------------------------------------
void sub_804AF7E()
{
  ;
}

//----- (0804AF99) --------------------------------------------------------
void sub_804AF99()
{
  ;
}

//----- (0804AFA9) --------------------------------------------------------
int sub_804AFA9()
{
  int result; // eax

  result = &unk_806738B - &unk_8067388;
  if ( (unsigned int)(&unk_806738B - &unk_8067388) > 6 )
    result = 0;
  return result;
}
// 804AFA9: could not find valid save-restore pair for ebp

//----- (0804B0A0) --------------------------------------------------------
void sub_804B0A0()
{
  ;
}

//----- (0804B0BB) --------------------------------------------------------
void sub_804B0BB()
{
  ;
}

//----- (0804B0CB) --------------------------------------------------------
int sub_804B0CB()
{
  int result; // eax

  result = &unk_806C48F - &unk_806C48C;
  if ( (unsigned int)(&unk_806C48F - &unk_806C48C) > 6 )
    result = 0;
  return result;
}
// 804B0CB: could not find valid save-restore pair for ebp

//----- (0804B17D) --------------------------------------------------------
int __usercall sub_804B17D@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  int v2; // edx
  int v3; // ecx

  a1(&dword_8066EF8);
  dword_806C324 = (int)&loc_804B0F7;
  sub_8062148(v3, v2);
  return 0;
}
// 8062148: using guessed type int __fastcall sub_8062148(_DWORD, _DWORD);
// 8066EF8: using guessed type int dword_8066EF8;
// 806C324: using guessed type int dword_806C324;

//----- (0804B1DB) --------------------------------------------------------
void sub_804B1DB()
{
  ;
}

//----- (0804B1F6) --------------------------------------------------------
void sub_804B1F6()
{
  ;
}

//----- (0804B206) --------------------------------------------------------
int sub_804B206()
{
  int result; // eax

  result = &unk_806CB73 - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_806CB73 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 804B206: could not find valid save-restore pair for ebp
// 806C4A0: using guessed type int program_invocation_short_name;

//----- (0804B334) --------------------------------------------------------
void sub_804B334()
{
  ;
}

//----- (0804B34F) --------------------------------------------------------
void sub_804B34F()
{
  ;
}

//----- (0804B35F) --------------------------------------------------------
int sub_804B35F()
{
  int result; // eax

  result = &unk_8066357 - &unk_8066354;
  if ( (unsigned int)(&unk_8066357 - &unk_8066354) > 6 )
    result = 0;
  return result;
}
// 804B35F: could not find valid save-restore pair for ebp

//----- (0804B3E9) --------------------------------------------------------
int sub_804B3E9()
{
  int result; // eax

  result = sub_804B35F();
  byte_806CC49 = 1;
  return result;
}
// 806CC49: using guessed type char byte_806CC49;

//----- (0804B45D) --------------------------------------------------------
void sub_804B45D()
{
  ;
}

//----- (0804B478) --------------------------------------------------------
void sub_804B478()
{
  ;
}

//----- (0804B488) --------------------------------------------------------
int sub_804B488()
{
  int result; // eax

  result = &unk_806CC4D - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_806CC4D - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 804B488: could not find valid save-restore pair for ebp
// 806C4A0: using guessed type int program_invocation_short_name;

//----- (0804B4E6) --------------------------------------------------------
int sub_804B4E6()
{
  return nullsub_5();
}
// 804B4E6: could not find valid save-restore pair for ebp
// 804B4E5: using guessed type int nullsub_5(void);

//----- (0804B586) --------------------------------------------------------
void sub_804B586()
{
  ;
}

//----- (0804B5A1) --------------------------------------------------------
void sub_804B5A1()
{
  ;
}

//----- (0804B5B1) --------------------------------------------------------
int sub_804B5B1()
{
  int result; // eax
  int v1; // edx
  int v2; // ecx

  result = &unk_806C497 - &unk_806C494;
  if ( (unsigned int)(&unk_806C497 - &unk_806C494) > 6 )
  {
    dword_806C2AC = (int)&locret_804B5C4;
    sub_8062420();
    dword_806C270 = (int)&loc_804B5D8;
    sub_80625B6(v2, v1);
    result = 0;
  }
  return result;
}
// 8061FAB: using guessed type int sub_8061FAB(void);
// 8062420: using guessed type int sub_8062420(void);
// 80625B6: using guessed type int __fastcall sub_80625B6(_DWORD, _DWORD);
// 806C270: using guessed type int dword_806C270;
// 806C2AC: using guessed type int dword_806C2AC;
// 806C358: using guessed type int dword_806C358;

//----- (0804B6C8) --------------------------------------------------------
#error "804B6E5: call analysis failed (funcsize=16)"

//----- (0804B6F4) --------------------------------------------------------
int __cdecl sub_804B6F4(unsigned __int8 a1)
{
  return a1;
}

//----- (0804B706) --------------------------------------------------------
int __cdecl sub_804B706(unsigned __int8 a1)
{
  return (*__ctype_b_loc())[a1] & 1 || a1 == 10;
}

//----- (0804B745) --------------------------------------------------------
int __cdecl sub_804B745(int a1, int a2)
{
  int result; // eax

  if ( a2 )
    result = sub_8061C5F(a1, a2, 1000000, 0) + 1000000;
  else
    result = a1;
  return result;
}
// 8061C5F: using guessed type _DWORD __cdecl sub_8061C5F(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804B78B) --------------------------------------------------------
int sub_804B78B()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nWith no FILE, or when FILE is -, read standard input.\n");
  return fputs_unlocked(v1, v0);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804B7B6) --------------------------------------------------------
int sub_804B7B6()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nMandatory arguments to long options are mandatory for short options too.\n");
  return fputs_unlocked(v1, v0);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804B7E1) --------------------------------------------------------
int __cdecl sub_804B7E1(char *s1)
{
  void *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // ebx
  char *v6; // eax
  char *v8; // [esp+1Ch] [ebp-4Ch]
  const char **i; // [esp+20h] [ebp-48h]
  const char *v10; // [esp+24h] [ebp-44h]
  const char *v11; // [esp+28h] [ebp-40h]
  const char *v12; // [esp+2Ch] [ebp-3Ch]
  const char *v13; // [esp+30h] [ebp-38h]
  const char *v14; // [esp+34h] [ebp-34h]
  const char *v15; // [esp+38h] [ebp-30h]
  const char *v16; // [esp+3Ch] [ebp-2Ch]
  const char *v17; // [esp+40h] [ebp-28h]
  const char *v18; // [esp+44h] [ebp-24h]
  const char *v19; // [esp+48h] [ebp-20h]
  const char *v20; // [esp+4Ch] [ebp-1Ch]
  const char *v21; // [esp+50h] [ebp-18h]
  const char *v22; // [esp+54h] [ebp-14h]
  int v23; // [esp+58h] [ebp-10h]
  int v24; // [esp+5Ch] [ebp-Ch]

  v11 = "[";
  v12 = "test invocation";
  v13 = "coreutils";
  v14 = "Multi-call invocation";
  v15 = "sha224sum";
  v16 = "sha2 utilities";
  v17 = "sha256sum";
  v18 = "sha2 utilities";
  v19 = "sha384sum";
  v20 = "sha2 utilities";
  v21 = "sha512sum";
  v22 = "sha2 utilities";
  v23 = 0;
  v24 = 0;
  v8 = s1;
  for ( i = &v11; ; i += 2 )
  {
    v1 = &loc_804B87E;
    if ( !*i )
      v1 = &loc_804B896;
    dword_806C220 = (int)v1;
    sub_806277E();
    if ( !strcmp(s1, *i) )
      break;
  }
  if ( i[1] )
    v8 = (char *)i[1];
  v2 = gettext("\n%s online help: <%s>\n");
  printf(v2, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  v10 = setlocale(5, 0);
  if ( v10 && strncmp(v10, "en_", 3u) )
  {
    v3 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
    printf(v3, s1);
  }
  v4 = gettext("Full documentation at: <%s%s>\n");
  printf(v4, "http://www.gnu.org/software/coreutils/", s1);
  if ( v8 == s1 )
    v5 = " invocation";
  else
    v5 = &s;
  v6 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  return printf(v6, v8, v5);
}
// 806277E: using guessed type int sub_806277E(void);
// 806C220: using guessed type int dword_806C220;

//----- (0804B980) --------------------------------------------------------
void __cdecl __noreturn sub_804B980(int a1, char *a2)
{
  size_t v2; // eax
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  int v6; // edx
  int v7; // ecx
  char v8; // [esp+30h] [ebp-18h]
  unsigned int v9; // [esp+3Ch] [ebp-Ch]

  v9 = __readgsdword(0x14u);
  v2 = strlen(a2);
  write(2, a2, v2);
  v5 = &loc_804B9DB;
  if ( !a1 )
    v5 = &loc_804BA55;
  dword_806C324 = (int)v5;
  sub_8062148(v4, v3);
  while ( 1 )
  {
    sub_80598D7(a1, (int)&v8);
    write(2, ": errno ", 8u);
    dword_806C20C = (int)&loc_804B9DD;
    sub_80627EE(v7, v6);
  }
}
// 8062148: using guessed type int __fastcall sub_8062148(_DWORD, _DWORD);
// 80627EE: using guessed type int __fastcall sub_80627EE(_DWORD, _DWORD);
// 806C20C: using guessed type int dword_806C20C;
// 806C324: using guessed type int dword_806C324;

//----- (0804BA80) --------------------------------------------------------
void __cdecl __noreturn sub_804BA80(int a1, int a2)
{
  if ( !a2 )
    gettext("standard output");
  sub_805C313(0, 3);
}

//----- (0804BAE2) --------------------------------------------------------
void __cdecl __noreturn sub_804BAE2(int status)
{
  int v1; // ebx
  char *v2; // eax
  int v3; // esi
  int v4; // ebx
  char *v5; // eax
  FILE *v6; // ebx
  char *v7; // eax
  FILE *v8; // ebx
  char *v9; // eax
  FILE *v10; // ebx
  char *v11; // eax
  FILE *v12; // ebx
  char *v13; // eax
  FILE *v14; // ebx
  char *v15; // eax
  FILE *v16; // ebx
  char *v17; // eax
  FILE *v18; // ebx
  char *v19; // eax
  FILE *v20; // ebx
  char *v21; // eax
  FILE *v22; // ebx
  char *v23; // eax
  FILE *v24; // ebx
  char *v25; // eax
  FILE *v26; // ebx
  char *v27; // eax
  FILE *v28; // ebx
  char *v29; // eax
  FILE *v30; // ebx
  char *v31; // eax
  char *v32; // eax
  FILE *v33; // ebx
  char *v34; // eax
  FILE *v35; // ebx
  char *v36; // eax
  FILE *v37; // ebx
  char *v38; // eax
  FILE *v39; // ebx
  char *v40; // eax
  FILE *v41; // ebx
  char *v42; // eax

  if ( status )
  {
    v1 = dword_806D2A7;
    v2 = gettext("Try '%s --help' for more information.\n");
    fprintf(stderr, v2, v1);
  }
  else
  {
    v3 = dword_806D2A7;
    v4 = dword_806D2A7;
    v5 = gettext("Usage: %s [OPTION]... [FILE]...\n  or:  %s [OPTION]... --files0-from=F\n");
    printf(v5, v4, v3);
    v6 = stdout;
    v7 = gettext("Write sorted concatenation of all FILE(s) to standard output.\n");
    fputs_unlocked(v7, v6);
    sub_804B78B();
    sub_804B7B6();
    v8 = stdout;
    v9 = gettext("Ordering options:\n\n");
    fputs_unlocked(v9, v8);
    v10 = stdout;
    v11 = gettext(
            "  -b, --ignore-leading-blanks  ignore leading blanks\n"
            "  -d, --dictionary-order      consider only blanks and alphanumeric characters\n"
            "  -f, --ignore-case           fold lower case to upper case characters\n");
    fputs_unlocked(v11, v10);
    v12 = stdout;
    v13 = gettext(
            "  -g, --general-numeric-sort  compare according to general numerical value\n"
            "  -i, --ignore-nonprinting    consider only printable characters\n"
            "  -M, --month-sort            compare (unknown) < 'JAN' < ... < 'DEC'\n");
    fputs_unlocked(v13, v12);
    v14 = stdout;
    v15 = gettext("  -h, --human-numeric-sort    compare human readable numbers (e.g., 2K 1G)\n");
    fputs_unlocked(v15, v14);
    v16 = stdout;
    v17 = gettext(
            "  -n, --numeric-sort          compare according to string numerical value\n"
            "  -R, --random-sort           shuffle, but group identical keys.  See shuf(1)\n"
            "      --random-source=FILE    get random bytes from FILE\n"
            "  -r, --reverse               reverse the result of comparisons\n");
    fputs_unlocked(v17, v16);
    v18 = stdout;
    v19 = gettext(aSortWordSortAc);
    fputs_unlocked(v19, v18);
    v20 = stdout;
    v21 = gettext("Other options:\n\n");
    fputs_unlocked(v21, v20);
    v22 = stdout;
    v23 = gettext(
            "      --batch-size=NMERGE   merge at most NMERGE inputs at once;\n"
            "                            for more use temp files\n");
    fputs_unlocked(v23, v22);
    v24 = stdout;
    v25 = gettext(
            "  -c, --check, --check=diagnose-first  check for sorted input; do not sort\n"
            "  -C, --check=quiet, --check=silent  like -c, but do not report first bad line\n"
            "      --compress-program=PROG  compress temporaries with PROG;\n"
            "                              decompress them with PROG -d\n");
    fputs_unlocked(v25, v24);
    v26 = stdout;
    v27 = gettext(
            "      --debug               annotate the part of the line used to sort,\n"
            "                              and warn about questionable usage to stderr\n"
            "      --files0-from=F       read input from the files specified by\n"
            "                            NUL-terminated names in file F;\n"
            "                            If F is - then read names from standard input\n");
    fputs_unlocked(v27, v26);
    v28 = stdout;
    v29 = gettext(
            "  -k, --key=KEYDEF          sort via a key; KEYDEF gives location and type\n"
            "  -m, --merge               merge already sorted files; do not sort\n");
    fputs_unlocked(v29, v28);
    v30 = stdout;
    v31 = gettext(
            "  -o, --output=FILE         write result to FILE instead of standard output\n"
            "  -s, --stable              stabilize sort by disabling last-resort comparison\n"
            "  -S, --buffer-size=SIZE    use SIZE for main memory buffer\n");
    fputs_unlocked(v31, v30);
    v32 = gettext(
            "  -t, --field-separator=SEP  use SEP instead of non-blank to blank transition\n"
            "  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or %s;\n"
            "                              multiple options specify multiple directories\n"
            "      --parallel=N          change the number of sorts run concurrently to N\n"
            "  -u, --unique              with -c, check for strict ordering;\n"
            "                              without -c, output only the first of an equal run\n");
    printf(v32, "/tmp");
    v33 = stdout;
    v34 = gettext("  -z, --zero-terminated     line delimiter is NUL, not newline\n");
    fputs_unlocked(v34, v33);
    v35 = stdout;
    v36 = gettext("      --help     display this help and exit\n");
    fputs_unlocked(v36, v35);
    v37 = stdout;
    v38 = gettext("      --version  output version information and exit\n");
    fputs_unlocked(v38, v37);
    v39 = stdout;
    v40 = gettext(
            "\n"
            "KEYDEF is F[.C][OPTS][,F[.C][OPTS]] for start and stop position, where F is a\n"
            "field number and C a character position in the field; both are origin 1, and\n"
            "the stop position defaults to the line's end.  If neither -t nor -b is in\n"
            "effect, characters in a field are counted from the beginning of the preceding\n"
            "whitespace.  OPTS is one or more single-letter ordering options [bdfgiMhnRrV],\n"
            "which override global ordering options for that key.  If no key is given, use\n"
            "the entire line as the key.  Use --debug to diagnose incorrect key usage.\n"
            "\n"
            "SIZE may be followed by the following multiplicative suffixes:\n");
    fputs_unlocked(v40, v39);
    v41 = stdout;
    v42 = gettext(
            "% 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, E, Z, Y.\n"
            "\n"
            "*** WARNING ***\n"
            "The locale specified by the environment affects sort order.\n"
            "Set LC_ALL=C to get the traditional sort order that uses\n"
            "native byte values.\n");
    fputs_unlocked(v42, v41);
    sub_804B7E1("sort");
  }
  exit(status);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 806D2A7: using guessed type int dword_806D2A7;

//----- (0804BD9E) --------------------------------------------------------
int __cdecl sub_804BD9E(int a1)
{
  bool v1; // dl
  int result; // eax

  v1 = pthread_sigmask(0, &set, (__sigset_t *)(a1 + 4)) == 0;
  result = a1;
  *(_BYTE *)a1 = v1;
  return result;
}

//----- (0804BDD3) --------------------------------------------------------
int __cdecl sub_804BDD3(int a1)
{
  void *v1; // eax

  v1 = &loc_804BDFC;
  if ( !*(_BYTE *)a1 )
    v1 = &locret_804BE1A;
  dword_806C220 = (int)v1;
  sub_806277E();
  return pthread_sigmask(2, (const __sigset_t *)(a1 + 4), 0);
}
// 806277E: using guessed type int sub_806277E(void);
// 806C220: using guessed type int dword_806C220;

//----- (0804BE1C) --------------------------------------------------------
int __cdecl sub_804BE1C(int a1, unsigned int a2)
{
  return *(_DWORD *)(a1 + 4) % a2;
}

//----- (0804BE3A) --------------------------------------------------------
bool __cdecl sub_804BE3A(int a1, int a2)
{
  return *(_DWORD *)(a1 + 4) == *(_DWORD *)(a2 + 4);
}

//----- (0804BE5F) --------------------------------------------------------
int __cdecl sub_804BE5F(int a1)
{
  int v1; // ecx
  void *v2; // eax
  char *v4; // [esp+4h] [ebp-24h]
  int stat_loc; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]

  if ( a1 )
  {
    dword_806C324 = (int)&loc_804BED0;
    sub_8062148(v1, a1 == 0);
    dword_806C298 = (int)&loc_804BF47;
    sub_80624B3();
  }
  else
  {
    v6 = waitpid(-1, &stat_loc, 1);
    if ( v6 < 0 )
    {
      v4 = arg;
      sub_805C15E(4);
    }
  }
  v2 = &loc_804BECB;
  if ( v6 <= 0 )
    v2 = &loc_804BFCC;
  dword_806C298 = (int)v2;
  sub_80624B3();
  if ( a1 > 0 || (unsigned __int8)sub_804C04A(v6) )
  {
    if ( stat_loc & 0x7F || (stat_loc & 0xFF00) >> 8 )
    {
      v4 = arg;
      sub_805C15E(4);
    }
    --dword_806D1DF;
  }
  return v6;
}
// 8062148: using guessed type int __fastcall sub_8062148(_DWORD, _DWORD);
// 80624B3: using guessed type int sub_80624B3(void);
// 806C298: using guessed type int dword_806C298;
// 806C324: using guessed type int dword_806C324;
// 806D1DF: using guessed type int dword_806D1DF;

//----- (0804BFD6) --------------------------------------------------------
int __usercall sub_804BFD6@<eax>(int a1@<edx>, int a2@<ecx>, double a3@<st0>, int a4)
{
  int result; // eax

  if ( !dword_806D1DB )
  {
    dword_806D1DB = sub_8058621(a1, a2, a3, 47, 0, (int)sub_804BE1C);
    if ( !dword_806D1DB )
      sub_805EE5C();
  }
  *(_BYTE *)(a4 + 8) = 1;
  result = sub_8059258((unsigned int *)dword_806D1DB, a4);
  if ( !result )
    sub_805EE5C();
  return result;
}
// 806D1DB: using guessed type int dword_806D1DB;

//----- (0804C04A) --------------------------------------------------------
int __cdecl sub_804C04A(int a1)
{
  bool v1; // zf
  void *v2; // eax
  char v4; // [esp+20h] [ebp-18h]
  int v5; // [esp+24h] [ebp-14h]
  unsigned int v6; // [esp+2Ch] [ebp-Ch]

  v6 = __readgsdword(0x14u);
  v5 = a1;
  v1 = sub_80592B8(dword_806D1DB, (int)&v4) == 0;
  v2 = &loc_804C097;
  if ( !v1 )
    v2 = &loc_804C0B2;
  dword_806C220 = (int)v2;
  sub_806277E();
  return 0;
}
// 806277E: using guessed type int sub_806277E(void);
// 806C220: using guessed type int dword_806C220;
// 806D1DB: using guessed type int dword_806D1DB;

//----- (0804C0F3) --------------------------------------------------------
int __cdecl sub_804C0F3(int a1)
{
  int result; // eax

  result = sub_804C04A(a1);
  if ( (_BYTE)result )
    result = sub_804BE5F(a1);
  return result;
}

//----- (0804C125) --------------------------------------------------------
int sub_804C125()
{
  int result; // eax

  do
  {
    result = dword_806D1DF;
    if ( dword_806D1DF <= 0 )
      break;
    result = sub_804BE5F(0);
  }
  while ( result );
  return result;
}
// 806D1DF: using guessed type int dword_806D1DF;

//----- (0804C154) --------------------------------------------------------
int sub_804C154()
{
  sub_804BE5F(-1);
  return sub_804C125();
}

//----- (0804C16D) --------------------------------------------------------
int sub_804C16D()
{
  int result; // eax

  while ( 1 )
  {
    result = dword_806D1DF;
    if ( dword_806D1DF <= 0 )
      break;
    sub_804BE5F(-1);
  }
  return result;
}
// 806D1DF: using guessed type int dword_806D1DF;

//----- (0804C18C) --------------------------------------------------------
int sub_804C18C()
{
  int result; // eax
  int i; // [esp+80h] [ebp-Ch]

  result = dword_806D1D7;
  for ( i = dword_806D1D7; i; i = *(_DWORD *)i )
  {
    unlink((const char *)(i + 9));
    result = *(_DWORD *)i;
  }
  dword_806D1D7 = 0;
  return result;
}
// 806D1D7: using guessed type int dword_806D1D7;

//----- (0804C201) --------------------------------------------------------
#error "804C21A: positive sp value has been found (funcsize=0)"

//----- (0804C21B) --------------------------------------------------------
int *__cdecl sub_804C21B(int *a1, char a2)
{
  char *s; // ST30_4
  size_t v3; // eax
  size_t n; // ST34_4
  int *v5; // eax
  char *v6; // eax
  void *v7; // eax
  int v8; // ecx
  void *v9; // eax
  int *ptr; // [esp+24h] [ebp-A4h]
  char *dest; // [esp+30h] [ebp-98h]
  int v13; // [esp+34h] [ebp-94h]
  int v14; // [esp+38h] [ebp-90h]
  char v15; // [esp+3Ch] [ebp-8Ch]

  s = (char *)*((_DWORD *)::ptr + dword_806D293);
  v3 = strlen(*((const char **)::ptr + dword_806D293));
  n = v3;
  v5 = (int *)sub_805EC7C((v3 + 24) & 0xFFFFFFFC);
  ptr = v5;
  dest = (char *)v5 + 9;
  memcpy((char *)v5 + 9, s, n);
  v6 = &dest[n];
  *(_DWORD *)v6 = 1919906607;
  *((_DWORD *)v6 + 1) = 1482184820;
  *((_DWORD *)v6 + 2) = 5789784;
  *ptr = 0;
  ++dword_806D293;
  v7 = &loc_804C309;
  if ( dword_806D293 != dword_806D13F )
    v7 = &loc_804C313;
  dword_806C2FC = (int)v7;
  sub_806223F();
  dword_806D293 = 0;
  sub_804BD9E((int)&v15);
  v13 = sub_805DCAC((int)dest, 0x80000);
  if ( v13 >= 0 )
  {
    *off_806C418 = (int)ptr;
    off_806C418 = ptr;
  }
  v14 = *__errno_location();
  sub_804BDD3((int)&v15);
  *__errno_location() = v14;
  if ( v13 < 0 )
  {
    v9 = &loc_804C3BA;
    if ( a2 != 1 )
      v9 = &loc_804C3C6;
    dword_806C338 = (int)v9;
    sub_80620D8(v8, v14);
    if ( *__errno_location() != 24 )
      sub_805C15E(4);
    free(ptr);
    ptr = 0;
  }
  *a1 = v13;
  return ptr;
}
// 80620D8: using guessed type int __fastcall sub_80620D8(_DWORD, _DWORD);
// 806223F: using guessed type int sub_806223F(void);
// 806C2FC: using guessed type int dword_806C2FC;
// 806C338: using guessed type int dword_806C338;
// 806C418: using guessed type int *off_806C418;
// 806D13F: using guessed type int dword_806D13F;
// 806D293: using guessed type int dword_806D293;

//----- (0804C43E) --------------------------------------------------------
FILE *__usercall sub_804C43E@<eax>(double a1@<st0>, char *s1, char *modes)
{
  int v3; // edx
  int v4; // ecx
  int v5; // edx
  int v6; // ecx
  FILE *v7; // eax
  void *v8; // eax
  FILE *stream; // [esp+18h] [ebp-10h]
  int fd; // [esp+1Ch] [ebp-Ch]

  if ( *modes == 114 )
  {
    if ( !strcmp(s1, "-") )
    {
      byte_806D14A = 1;
      stream = stdin;
      sub_80575F4(v3, v4, stdin, 2);
    }
    else
    {
      fd = open64(s1, 0x80000);
      if ( fd < 0 )
        v7 = 0;
      else
        v7 = fdopen(fd, modes);
      stream = v7;
      sub_80575F4(v5, v6, v7, 2);
    }
  }
  else
  {
    if ( *modes != 119 )
      __assert_fail("!\"unexpected mode passed to stream_open\"", "src/sort.c", 0x3CCu, "stream_open");
    v8 = &loc_804C544;
    if ( !s1 )
      v8 = &loc_804C56B;
    dword_806C25C = (int)v8;
    sub_8062626(a1);
    if ( ftruncate64(1, 0, 0) )
      sub_805C313(0, 3);
    stream = stdout;
  }
  return stream;
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 8049D20: using guessed type int __cdecl ftruncate64(_DWORD, _DWORD, _DWORD);
// 8062626: using guessed type int __usercall sub_8062626@<eax>(double@<st0>);
// 806C25C: using guessed type int dword_806C25C;
// 806D14A: using guessed type char byte_806D14A;

//----- (0804C5A3) --------------------------------------------------------
FILE *__usercall sub_804C5A3@<eax>(double a1@<st0>, char *s1, char *modes)
{
  FILE *v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_804C43E(a1, s1, modes);
  if ( !v4 )
  {
    gettext("open failed");
    dword_806C220 = (int)sub_804C5F6;
    sub_806277E();
  }
  return v4;
}
// 804C5F6: using guessed type int sub_804C5F6();
// 806277E: using guessed type int sub_806277E(void);
// 806C220: using guessed type int dword_806C220;

//----- (0804C609) --------------------------------------------------------
void __usercall sub_804C609(double a1@<st0>, FILE *stream, int a3)
{
  int v3; // eax
  bool v4; // zf
  int v5; // edx
  int v6; // ecx
  void *v7; // eax
  char *v8; // eax
  char *v9; // eax

  v3 = fileno(stream);
  if ( v3 )
  {
    if ( v3 == 1 )
    {
      if ( fflush_unlocked(stream) )
      {
        v8 = gettext("fflush failed");
        sub_804BA80((int)v8, a3);
      }
    }
    else if ( sub_805FD2C(a1, stream) )
    {
      v9 = gettext("close failed");
      sub_804BA80((int)v9, a3);
    }
  }
  else
  {
    v4 = feof_unlocked(stream) == 0;
    v7 = &loc_804C64D;
    if ( v4 )
      v7 = &loc_804C65A;
    dword_806C270 = (int)v7;
    sub_80625B6(v6, v5);
    clearerr_unlocked(stream);
  }
}
// 80625B6: using guessed type int __fastcall sub_80625B6(_DWORD, _DWORD);
// 806C270: using guessed type int dword_806C270;

//----- (0804C6C0) --------------------------------------------------------
int __cdecl sub_804C6C0(int fd, int fd2)
{
  int result; // eax

  result = fd;
  if ( fd != fd2 )
  {
    dup2(fd, fd2);
    result = close(fd);
  }
  return result;
}

//----- (0804C712) --------------------------------------------------------
int __cdecl sub_804C712(int pipedes[2], int a2)
{
  int v2; // ecx
  void *v4; // eax
  int v5; // ST24_4
  int v6; // [esp+14h] [ebp-A4h]

  if ( sub_805A358(pipedes, 0x80000) < 0 )
    return -1;
  if ( dword_806C414 + 1 < (unsigned int)dword_806D1DF )
    sub_804C154();
  v4 = &loc_804C82E;
  if ( a2 )
    v4 = &loc_804C768;
  dword_806C20C = (int)v4;
  sub_80627EE(v2, a2 - 1);
  if ( v6 >= 0 )
  {
    if ( v6 )
    {
      ++dword_806D1DF;
    }
    else
    {
      close(0);
      close(1);
    }
  }
  else
  {
    v5 = *__errno_location();
    close(*pipedes);
    close(pipedes[1]);
    *__errno_location() = v5;
  }
  return v6;
}
// 80627EE: using guessed type int __fastcall sub_80627EE(_DWORD, _DWORD);
// 806C20C: using guessed type int dword_806C20C;
// 806D1DF: using guessed type int dword_806D1DF;

//----- (0804C8A8) --------------------------------------------------------
int *__usercall sub_804C8A8@<eax>(double a1@<st0>, FILE **a2, char a3)
{
  int v3; // eax
  int v4; // edx
  int v5; // ecx
  int *v6; // eax
  int v7; // ebx
  char *v8; // eax
  int v10; // [esp+8h] [ebp-20h]
  char v11; // [esp+Ch] [ebp-1Ch]
  int fd; // [esp+10h] [ebp-18h]
  int *v13; // [esp+14h] [ebp-14h]
  int pipedes[2]; // [esp+18h] [ebp-10h]

  v11 = a3;
  v13 = sub_804C21B(&fd, a3);
  if ( !v13 )
  {
    dword_806C2FC = (int)&loc_804CA00;
    sub_806223F();
  }
  *((_BYTE *)v13 + 8) = 0;
  if ( arg )
  {
    v3 = sub_804C712(pipedes, 4);
    v13[1] = v3;
    if ( v13[1] <= 0 )
    {
      if ( !v13[1] )
      {
        close(pipedes[1]);
        sub_804C6C0(fd, 1);
        sub_804C6C0(pipedes[0], 0);
        v10 = 0;
        execlp(arg, arg, 0, *(_DWORD *)&v11);
        v6 = __errno_location();
        sub_804B980(*v6, "couldn't execute compress program");
      }
    }
    else
    {
      close(fd);
      close(pipedes[0]);
      fd = pipedes[1];
      sub_804BFD6(v4, v5, a1, (int)v13);
    }
  }
  *a2 = fdopen(fd, "w");
  if ( !*a2 )
  {
    v7 = (int)v13 + 9;
    v8 = gettext("couldn't create temporary file");
    sub_804BA80((int)v8, v7);
  }
  return v13;
}
// 806223F: using guessed type int sub_806223F(void);
// 806C2FC: using guessed type int dword_806C2FC;

//----- (0804CA06) --------------------------------------------------------
int *__usercall sub_804CA06@<eax>(double a1@<st0>, FILE **a2)
{
  return sub_804C8A8(a1, a2, 0);
}

//----- (0804CA21) --------------------------------------------------------
int __cdecl sub_804CA21(int a1)
{
  int v2; // eax
  int *v3; // eax
  char *v4; // [esp+4h] [ebp-34h]
  const char *v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+18h] [ebp-20h]
  int fd; // [esp+1Ch] [ebp-1Ch]
  int v9; // [esp+20h] [ebp-18h]
  int pipedes[2]; // [esp+28h] [ebp-10h]

  v7 = 0;
  if ( *(_BYTE *)(a1 + 8) == 1 )
    sub_804C0F3(*(_DWORD *)(a1 + 4));
  fd = open64(a1 + 9, 0);
  if ( fd < 0 )
    return 0;
  v2 = sub_804C712(pipedes, 9);
  v9 = v2;
  if ( v2 != -1 )
  {
    if ( !v2 )
    {
      close(pipedes[0]);
      sub_804C6C0(fd, 0);
      sub_804C6C0(pipedes[1], 1);
      v6 = 0;
      v5 = "-d";
      execlp(arg, arg, "-d", 0);
      v3 = __errno_location();
      sub_804B980(*v3, "couldn't execute compress program (with -d)");
    }
    dword_806C248 = (int)&loc_804CB89;
    sub_8062696();
  }
  if ( *__errno_location() != 24 )
  {
    v4 = arg;
    sub_805C15E(4);
  }
  close(fd);
  *__errno_location() = 24;
  return v7;
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 8062696: using guessed type int sub_8062696(void);
// 806C248: using guessed type int dword_806C248;

//----- (0804CC13) --------------------------------------------------------
int __cdecl sub_804CC13(int a1)
{
  int v1; // ecx
  int v2; // eax
  int *v3; // edx
  int result; // eax

  if ( dword_806D13F == dword_806D143 )
    ptr = sub_805EBB9(dword_806D13F, v1, ptr, (int)&dword_806D143, 4);
  v2 = dword_806D13F++;
  v3 = (int *)((char *)ptr + 4 * v2);
  result = a1;
  *v3 = a1;
  return result;
}
// 806D13F: using guessed type int dword_806D13F;
// 806D143: using guessed type int dword_806D143;

//----- (0804CCA8) --------------------------------------------------------
void __cdecl __noreturn sub_804CCA8(char *name)
{
  int (*v1)(); // eax
  int v2; // ST2C_4
  int v3; // ST24_4
  int *i; // [esp+18h] [ebp-A0h]
  int v5; // [esp+20h] [ebp-98h]
  int v6; // [esp+28h] [ebp-90h]
  char v7; // [esp+2Ch] [ebp-8Ch]

  for ( i = &dword_806D1D7; ; i = (int *)*i )
  {
    v5 = *i;
    if ( (char *)(*i + 9) == name )
      break;
  }
  if ( *(_BYTE *)(v5 + 8) == 1 )
    sub_804C0F3(*(_DWORD *)(v5 + 4));
  v2 = *(_DWORD *)v5;
  sub_804BD9E((int)&v7);
  v6 = unlink(name);
  v3 = *__errno_location();
  *i = v2;
  sub_804BDD3((int)&v7);
  v1 = (int (*)())&loc_804CD17;
  if ( !v6 )
    v1 = sub_804CDE7;
  dword_806C248 = (int)v1;
  sub_8062696();
  sub_805C313(0, 3);
}
// 804CDE7: using guessed type int sub_804CDE7();
// 8062696: using guessed type int sub_8062696(void);
// 806C248: using guessed type int dword_806C248;
// 806D1D7: using guessed type int dword_806D1D7;

//----- (0804CE2B) --------------------------------------------------------
int __cdecl compar(const void *a1, const void *a2)
{
  return strcmp(*(const char **)a1, *(const char **)a2);
}

//----- (0804CE55) --------------------------------------------------------
void sub_804CE55()
{
  char i; // al
  int v1; // ecx
  int v2; // ecx
  const unsigned __int16 *v3; // ebx
  int v4; // eax
  unsigned int c; // [esp+18h] [ebp-20h]
  unsigned int ca; // [esp+18h] [ebp-20h]
  size_t v7; // [esp+1Ch] [ebp-1Ch]
  int v8; // [esp+20h] [ebp-18h]
  const char *s; // [esp+24h] [ebp-14h]
  size_t v10; // [esp+28h] [ebp-10h]
  char *v11; // [esp+2Ch] [ebp-Ch]

  for ( c = 0; c <= 0xFF; ++c )
  {
    for ( i = sub_804B706(c); ; i = sub_806253E(v1, 2 * c) )
    {
      *(_BYTE *)(c + 134663479) = i;
      *(_BYTE *)(c + 134663735) = ((*__ctype_b_loc())[c] & 0x4000) == 0;
      if ( (*__ctype_b_loc())[c] & 8 )
        break;
      dword_806C284 = (int)&loc_804CE78;
    }
    *(_BYTE *)(c + 134663991) = 0;
    *(_BYTE *)(c + 134664247) = toupper(c);
  }
  if ( byte_806CD20 )
  {
    for ( ca = 0; ca <= 0xB; ++ca )
    {
      s = nl_langinfo(ca + 131086);
      v10 = strlen(s);
      v11 = (char *)sub_805EC7C(v10 + 1);
      (&off_806C3AC)[2 * ca] = v11;
      dword_806C3B0[2 * ca] = ca + 1;
      v8 = 0;
      v7 = 0;
      dword_806C338 = (int)&loc_804D042;
      sub_80620D8(v2, ca + 1);
      do
      {
        v3 = *__ctype_b_loc();
        if ( !(v3[(unsigned __int8)sub_804B6F4(s[v7])] & 1) )
        {
          v4 = v8++;
          v11[v4] = byte_806D037[(unsigned __int8)sub_804B6F4(s[v7])];
        }
        ++v7;
      }
      while ( v7 < v10 );
      v11[v8] = 0;
    }
    qsort(&off_806C3AC, 0xCu, 8u, compar);
  }
}
// 80620D8: using guessed type int __fastcall sub_80620D8(_DWORD, _DWORD);
// 806253E: using guessed type int __fastcall sub_806253E(_DWORD, _DWORD);
// 806C284: using guessed type int dword_806C284;
// 806C338: using guessed type int dword_806C338;
// 806C3AC: using guessed type char *off_806C3AC;
// 806C3B0: using guessed type int dword_806C3B0[];
// 806CD20: using guessed type char byte_806CD20;

//----- (0804D08D) --------------------------------------------------------
unsigned int __usercall sub_804D08D@<eax>(double st7_0@<st0>, int edx0@<edx>, int ecx0@<ecx>, int a1, char a2, char *a3)
{
  bool v6; // zf
  int v7; // edx
  int v8; // ecx
  void *v9; // eax
  int v10; // edx
  int v11; // ecx
  unsigned __int64 v12; // kr00_8
  void *v13; // ebx
  int v14; // esi
  char *v15; // eax
  void *v16; // ebx
  int v17; // esi
  char *v18; // eax
  void *v20; // ebx
  int v21; // esi
  char *v22; // eax
  int v23; // ebx
  int v24; // esi
  char *v25; // eax
  signed int v26; // [esp+20h] [ebp-38h]
  unsigned int v27; // [esp+24h] [ebp-34h]
  unsigned __int64 v28; // [esp+28h] [ebp-30h]
  int v29; // [esp+30h] [ebp-28h]
  char v30; // [esp+41h] [ebp-17h]
  unsigned int v31; // [esp+4Ch] [ebp-Ch]

  v31 = __readgsdword(0x14u);
  v26 = sub_805F808(edx0, ecx0, a3, 0, 10, (int)&v28);
  v6 = getrlimit64(7, &v29) == 0;
  v9 = &loc_804D109;
  if ( !v6 )
    v9 = &loc_804D117;
  dword_806C284 = (int)v9;
  sub_806253E(v8, v7);
  v27 = v29 - 3;
  if ( v26 )
  {
LABEL_13:
    if ( v26 == 1 )
    {
      v20 = sub_805C56F(st7_0, a3);
      v21 = *((_DWORD *)&longopts.name + 4 * a1);
      v22 = gettext("--%s argument %s too large");
      error(0, 0, v22, v21, v20);
      v23 = sub_80599B1(v27, (int)&v30);
      v24 = *((_DWORD *)&longopts.name + 4 * a1);
      v25 = gettext("maximum --%s argument with current rlimit is %s");
      error(2, 0, v25, v24, v23);
    }
    sub_805F6DA(v26, a1, a2, (int)&longopts, (int)a3);
  }
  v12 = v28;
  v10 = v12 >> 32;
  dword_806C414 = v12;
  v11 = v28;
  if ( v28 != (unsigned int)v28 )
  {
    v26 = 1;
    goto LABEL_13;
  }
  if ( (unsigned int)dword_806C414 <= 1 )
  {
    v13 = sub_805C56F(st7_0, a3);
    v14 = *((_DWORD *)&longopts.name + 4 * a1);
    v15 = gettext("invalid --%s argument %s");
    error(0, 0, v15, v14, v13);
    v16 = sub_805C56F(st7_0, "2");
    v17 = *((_DWORD *)&longopts.name + 4 * a1);
    v18 = gettext("minimum --%s argument is %s");
    error(2, 0, v18, v17, v16);
  }
  if ( v27 < dword_806C414 )
  {
    dword_806C310 = (int)&loc_804D246;
    sub_80621CD(v11, v10);
  }
  return __readgsdword(0x14u) ^ v31;
}
// 8049920: using guessed type int __cdecl getrlimit64(_DWORD, _DWORD);
// 80621CD: using guessed type int __fastcall sub_80621CD(_DWORD, _DWORD);
// 806253E: using guessed type int __fastcall sub_806253E(_DWORD, _DWORD);
// 806C284: using guessed type int dword_806C284;
// 806C310: using guessed type int dword_806C310;

//----- (0804D318) --------------------------------------------------------
int __usercall sub_804D318@<eax>(int edx0@<edx>, int ecx0@<ecx>, int a1, char a2, char *nptr)
{
  int v5; // eax
  unsigned __int64 v6; // rax
  int result; // eax
  int v8; // [esp+38h] [ebp-30h]
  int v9; // [esp+3Ch] [ebp-2Ch]
  unsigned __int64 v10; // [esp+40h] [ebp-28h]
  double v11; // [esp+48h] [ebp-20h]

  v9 = sub_805F808(edx0, ecx0, nptr, (int)&v8, 10, (int)&v10);
  if ( !v9 && (unsigned int)(*(char *)(v8 - 1) - 48) <= 9 )
  {
    if ( HIDWORD(v10) > 0x3FFFFF )
      v9 = 1;
    else
      v10 <<= 10;
  }
  if ( v9 == 2 && (unsigned int)(*(char *)(v8 - 1) - 48) <= 9 && !*(_BYTE *)(v8 + 1) )
  {
    v5 = *(char *)v8;
    if ( v5 == 37 )
    {
      v11 = sub_805A1BA() * (double)v10 / 100.0;
      if ( v11 >= 1.844674407370955e19 )
      {
        v9 = 1;
      }
      else
      {
        if ( v11 >= 9.223372036854776e18 )
          v6 = (signed __int64)(v11 - 9.223372036854776e18) ^ 0x8000000000000000LL;
        else
          v6 = (signed __int64)v11;
        v10 = v6;
        v9 = 0;
      }
    }
    else if ( v5 == 98 )
    {
      v9 = 0;
    }
  }
  if ( v9 )
LABEL_26:
    sub_805F6DA(v9, a1, a2, (int)&longopts, (int)nptr);
  if ( size > v10 )
  {
    dword_806C270 = (int)&loc_804D56E;
    sub_80625B6(size, HIDWORD(v10));
  }
  size = v10;
  if ( v10 != (unsigned int)v10 )
  {
    v9 = 1;
    goto LABEL_26;
  }
  result = size;
  if ( 18 * dword_806C414 >= size )
    result = 18 * dword_806C414;
  size = result;
  return result;
}
// 80625B6: using guessed type int __fastcall sub_80625B6(_DWORD, _DWORD);
// 806C270: using guessed type int dword_806C270;

//----- (0804D576) --------------------------------------------------------
int __cdecl sub_804D576(int a1, char a2, char *nptr)
{
  int v3; // edx
  int v4; // ecx
  void *v6; // eax
  char *v7; // eax
  int v8; // [esp+28h] [ebp-10h]
  int v9; // [esp+2Ch] [ebp-Ch]

  v9 = sub_805F17B(nptr, 0, 10, (int)&v8, &s);
  if ( v9 == 1 )
    return -1;
  if ( v9 )
    sub_805F6DA(v9, a1, a2, (int)&longopts, (int)nptr);
  v6 = &loc_804D60B;
  if ( v8 )
    v6 = &loc_804D62F;
  dword_806C234 = (int)v6;
  sub_8062704(v4, v3);
  v7 = gettext("number in parallel must be nonzero");
  error(2, 0, v7);
  return v8;
}
// 8062704: using guessed type int __fastcall sub_8062704(_DWORD, _DWORD);
// 806C234: using guessed type int dword_806C234;

//----- (0804D634) --------------------------------------------------------
int __usercall sub_804D634@<eax>(double a1@<st0>)
{
  long double v1; // fst7
  long double v2; // fst7
  int result; // eax
  unsigned int v4; // [esp+24h] [ebp-34h]
  double v5; // [esp+28h] [ebp-30h]
  double v6; // [esp+30h] [ebp-28h]
  double v7; // [esp+38h] [ebp-20h]
  unsigned __int64 v8; // [esp+40h] [ebp-18h]

  v4 = -1;
  if ( !getrlimit64(2, &v8) && !HIDWORD(v8) )
  {
    dword_806C25C = (int)&loc_804D690;
    sub_8062626(a1);
LABEL_13:
    v2 = v5;
    goto LABEL_15;
  }
  if ( !getrlimit64(9, &v8) && v8 < 0xFFFFFFFF )
    v4 = v8;
  v4 >>= 1;
  if ( !getrlimit64(5, &v8) && 15 * (v8 >> 4) < v4 )
    v4 = 15 * (v8 >> 4);
  v5 = sub_805A27C();
  v1 = sub_805A1BA();
  v6 = v1;
  if ( v5 > (double)v1 / 8.0 )
    goto LABEL_13;
  v2 = v6 / 8.0;
LABEL_15:
  v7 = v2;
  if ( (long double)v4 > v6 * 0.75 )
    v4 = (signed __int64)(v6 * 0.75);
  if ( (long double)v4 > v7 )
    v4 = (signed __int64)v7;
  result = v4;
  if ( 18 * dword_806C414 >= v4 )
    result = 18 * dword_806C414;
  return result;
}
// 8049920: using guessed type int __cdecl getrlimit64(_DWORD, _DWORD);
// 8062626: using guessed type int __usercall sub_8062626@<eax>(double@<st0>);
// 806C25C: using guessed type int dword_806C25C;

//----- (0804D849) --------------------------------------------------------
int __usercall sub_804D849@<eax>(double a1@<st0>, int a2, unsigned int a3, int a4, unsigned int a5, int a6)
{
  int v6; // eax
  bool v7; // al
  bool v8; // zf
  void *v9; // eax
  int v10; // ebx
  char *v11; // eax
  void *v12; // eax
  int v13; // edx
  int v14; // ecx
  void *v15; // eax
  FILE *v17; // [esp+0h] [ebp-98h]
  int v18; // [esp+4h] [ebp-94h]
  int v19; // [esp+8h] [ebp-90h]
  int v20; // [esp+Ch] [ebp-8Ch]
  int v21; // [esp+10h] [ebp-88h]
  int v22; // [esp+14h] [ebp-84h]
  int v23; // [esp+18h] [ebp-80h]
  unsigned int v24; // [esp+1Ch] [ebp-7Ch]
  unsigned int v25; // [esp+20h] [ebp-78h]
  unsigned int v26; // [esp+24h] [ebp-74h]
  __int64 v27; // [esp+28h] [ebp-70h]
  char v28; // [esp+30h] [ebp-68h]
  int v29; // [esp+34h] [ebp-64h]
  int v30; // [esp+38h] [ebp-60h]
  int v31; // [esp+3Ch] [ebp-5Ch]
  int v32; // [esp+40h] [ebp-58h]
  int v33; // [esp+44h] [ebp-54h]
  int v34; // [esp+48h] [ebp-50h]
  __int64 v35; // [esp+5Ch] [ebp-3Ch]

  v25 = a6 + 1;
  v23 = a6 + 2;
  v24 = 0;
  dword_806C2C0 = (int)&loc_804DA55;
  sub_806239B();
  do
  {
    if ( v24 >= a3 )
    {
      v8 = strcmp(*(const char **)(4 * v24 + a4), "-") == 0;
      v9 = &loc_804D8F8;
      if ( !v8 )
        v9 = &loc_804D912;
      dword_806C2C0 = (int)v9;
      sub_806239B();
      v7 = sub_8061EF0(0, (int)&v28) != 0;
    }
    else
    {
      v17 = *(FILE **)(4 * v24 + a2);
      v6 = fileno(v17);
      v7 = sub_8061EF0(v6, (int)&v28) != 0;
    }
    if ( v7 )
    {
      v10 = *(_DWORD *)(4 * v24 + a4);
      v11 = gettext("stat failed");
      sub_804BA80((int)v11, v10);
    }
    if ( (v32 & 0xF000) == 0x8000 )
    {
      v27 = v35;
    }
    else
    {
      v12 = &loc_804D9A3;
      if ( !size )
        v12 = &loc_804D9BF;
      dword_806C2E8 = (int)v12;
      sub_80622AD(
        v17,
        v18,
        v19,
        v20,
        v21,
        v22,
        v23,
        v24,
        v25,
        v26,
        v27,
        HIDWORD(v27),
        *(_DWORD *)&v28,
        v29,
        v30,
        v31,
        v32,
        v33,
        v34);
      dword_806C324 = (int)&loc_804DA64;
      sub_8062148(v14, v13);
      v27 = 0x20000LL;
    }
    if ( !dword_806D297 )
    {
      dword_806D297 = size;
      v15 = &loc_804DA02;
      if ( size )
        v15 = &loc_804DA0C;
      dword_806C248 = (int)v15;
      sub_8062696();
      dword_806D297 = sub_804D634(a1);
    }
    v26 = v25 * v27 + 1;
    if ( v27 != v26 / v25 || dword_806D297 - v23 <= v26 )
      return dword_806D297;
    v23 += v26;
    ++v24;
  }
  while ( v24 < a5 );
  return v23;
}
// 8062148: using guessed type int __fastcall sub_8062148(_DWORD, _DWORD);
// 80622AD: using guessed type int __stdcall sub_80622AD(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8062696: using guessed type int sub_8062696(void);
// 806C248: using guessed type int dword_806C248;
// 806C2C0: using guessed type int dword_806C2C0;
// 806C2E8: using guessed type int dword_806C2E8;
// 806C324: using guessed type int dword_806C324;
// 806D297: using guessed type int dword_806D297;

//----- (0804DA6D) --------------------------------------------------------
int __cdecl sub_804DA6D(int a1, int a2, size_t size)
{
  int result; // eax
  size_t sizea; // [esp+28h] [ebp+10h]

  while ( 1 )
  {
    sizea = (size & 0xFFFFFFF0) + 16;
    *(_DWORD *)a1 = malloc(sizea);
    if ( *(_DWORD *)a1 )
      break;
    size = sizea >> 1;
    if ( a2 + 1 >= size )
      sub_805EE5C();
  }
  *(_DWORD *)(a1 + 20) = a2;
  *(_DWORD *)(a1 + 12) = sizea;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a1 + 16);
  result = a1;
  *(_BYTE *)(a1 + 24) = 0;
  return result;
}

//----- (0804DAF3) --------------------------------------------------------
int __cdecl sub_804DAF3(_DWORD *a1)
{
  return *a1 + a1[3];
}

//----- (0804DB0E) --------------------------------------------------------
char *__cdecl sub_804DB0E(char **a1, int a2)
{
  int v2; // ecx
  int v3; // eax
  int v4; // edx
  int v5; // eax
  char *result; // eax
  unsigned __int8 *v7; // [esp+4h] [ebp-10h]
  int v8; // [esp+8h] [ebp-Ch]
  char *v9; // [esp+Ch] [ebp-8h]
  int v10; // [esp+10h] [ebp-4h]

  v7 = (unsigned __int8 *)*a1;
  v9 = &(*a1)[(_DWORD)(a1[1] - 1)];
  v8 = *(_DWORD *)a2;
  v10 = *(_DWORD *)(a2 + 4);
  if ( dword_806C410 == 128 )
  {
    while ( v7 < (unsigned __int8 *)v9 )
    {
      v5 = v8;
      v4 = v8-- - 1;
      if ( !v5 )
        break;
      while ( v7 < (unsigned __int8 *)v9 && byte_806CD37[(unsigned __int8)sub_804B6F4(*v7)] )
        ++v7;
      dword_806C20C = (int)&loc_804DBE0;
      sub_80627EE(v2, v4);
      do
        ++v7;
      while ( v7 < (unsigned __int8 *)v9 && (unsigned __int8)byte_806CD37[(unsigned __int8)sub_804B6F4(*v7)] ^ 1 );
    }
  }
  else
  {
    while ( v7 < (unsigned __int8 *)v9 )
    {
      v3 = v8--;
      if ( !v3 )
        break;
      while ( v7 < (unsigned __int8 *)v9 && (char)*v7 != dword_806C410 )
        ++v7;
      if ( v7 < (unsigned __int8 *)v9 )
        ++v7;
    }
  }
  if ( *(_BYTE *)(a2 + 24) )
  {
    while ( v7 < (unsigned __int8 *)v9 && byte_806CD37[(unsigned __int8)sub_804B6F4(*v7)] )
      ++v7;
  }
  result = v9;
  if ( &v7[v10] <= (unsigned __int8 *)v9 )
    result = (char *)&v7[v10];
  return result;
}
// 80627EE: using guessed type int __fastcall sub_80627EE(_DWORD, _DWORD);
// 806C20C: using guessed type int dword_806C20C;
// 806C410: using guessed type int dword_806C410;

//----- (0804DC73) --------------------------------------------------------
char *__cdecl sub_804DC73(char **a1, int a2)
{
  int v2; // ecx
  int v3; // edx
  int v4; // eax
  bool v5; // zf
  void *v6; // eax
  int v7; // eax
  char *v8; // eax
  int v10; // [esp+0h] [ebp-14h]
  char *v11; // [esp+4h] [ebp-10h]
  int v12; // [esp+8h] [ebp-Ch]
  unsigned int v13; // [esp+Ch] [ebp-8h]
  int v14; // [esp+10h] [ebp-4h]

  v11 = *a1;
  v3 = (int)(a1[1] - 1);
  v13 = (unsigned int)&v11[v3];
  v12 = *(_DWORD *)(a2 + 8);
  v14 = *(_DWORD *)(a2 + 12);
  if ( !v14 )
    ++v12;
  if ( dword_806C410 == 128 )
  {
    while ( (unsigned int)v11 < v13 )
    {
      v7 = v12;
      v3 = v12-- - 1;
      if ( !v7 )
        break;
      while ( (unsigned int)v11 < v13 )
      {
        v10 = *v11;
        if ( !byte_806CD37[(unsigned __int8)sub_804B6F4(v10)] )
          break;
        ++v11;
      }
      dword_806C358 = (int)&loc_804DD5F;
      sub_8061FAB();
      if ( (unsigned int)++v11 < v13 )
      {
        v10 = *v11;
        v5 = byte_806CD37[(unsigned __int8)sub_804B6F4(v10)] == 1;
        v6 = &loc_804DDA2;
        if ( !v5 )
          v6 = &loc_804DD5B;
        dword_806C358 = (int)v6;
        sub_8061FAB();
      }
    }
  }
  else
  {
    while ( (unsigned int)v11 < v13 )
    {
      v4 = v12;
      v3 = v12-- - 1;
      if ( !v4 )
        break;
      while ( (unsigned int)v11 < v13 )
      {
        v3 = *v11;
        if ( v3 == dword_806C410 )
          break;
        ++v11;
      }
      if ( (unsigned int)v11 < v13 && (v12 || v14) )
        ++v11;
    }
  }
  if ( v14 )
  {
    if ( *(_BYTE *)(a2 + 25) )
    {
      dword_806C338 = (int)&loc_804DDE7;
      sub_80620D8(v2, v3);
      do
      {
        if ( (unsigned int)++v11 >= v13 )
          break;
        v10 = *v11;
      }
      while ( byte_806CD37[(unsigned __int8)sub_804B6F4(v10)] );
    }
    v8 = (char *)v13;
    if ( (unsigned int)&v11[v14] <= v13 )
      v8 = &v11[v14];
    v11 = v8;
  }
  return v11;
}
// 8061FAB: using guessed type int sub_8061FAB(void);
// 80620D8: using guessed type int __fastcall sub_80620D8(_DWORD, _DWORD);
// 806C338: using guessed type int dword_806C338;
// 806C358: using guessed type int dword_806C358;
// 806C410: using guessed type int dword_806C410;

//----- (0804DE26) --------------------------------------------------------
int __cdecl sub_804DE26(int a1, FILE *stream, int a3)
{
  int v3; // ecx
  int v5; // edx
  void *v6; // eax
  char *v7; // eax
  size_t v8; // eax
  int v9; // ecx
  bool v10; // zf
  int v11; // edx
  int v12; // ecx
  void *v13; // eax
  char *v14; // eax
  size_t v15; // eax
  char *v16; // eax
  int v17; // edx
  void *v18; // eax
  char *v19; // eax
  int v20; // edx
  int v21; // ecx
  void *v22; // eax
  int v23; // edx
  int v24; // eax
  int v25; // ecx
  char *v26; // edx
  int v27; // [esp+0h] [ebp-58h]
  unsigned int v28; // [esp+8h] [ebp-50h]
  char v29; // [esp+1Bh] [ebp-3Dh]
  int v30; // [esp+1Ch] [ebp-3Ch]
  size_t v31; // [esp+20h] [ebp-38h]
  void *ptr; // [esp+24h] [ebp-34h]
  int v33; // [esp+28h] [ebp-30h]
  unsigned int v34; // [esp+2Ch] [ebp-2Ch]
  char *v35; // [esp+30h] [ebp-28h]
  char *v36; // [esp+34h] [ebp-24h]
  int v37; // [esp+38h] [ebp-20h]
  int v38; // [esp+3Ch] [ebp-1Ch]
  int v39; // [esp+40h] [ebp-18h]
  size_t n; // [esp+44h] [ebp-14h]
  size_t v41; // [esp+48h] [ebp-10h]
  char *v42; // [esp+4Ch] [ebp-Ch]

  v37 = dword_806D14B;
  v29 = byte_806C38C;
  v38 = *(_DWORD *)(a1 + 20);
  v31 = dword_806C40C - 18;
  if ( !*(_BYTE *)(a1 + 24) )
  {
    v5 = *(_DWORD *)(a1 + 4);
    v6 = &loc_804DE92;
    if ( v5 == *(_DWORD *)(a1 + 16) )
      v6 = &loc_804DEDA;
    dword_806C270 = (int)v6;
    sub_80625B6(v3, v5);
    memmove(
      *(void **)a1,
      (const void *)(*(_DWORD *)(a1 + 4) - *(_DWORD *)(a1 + 16) + *(_DWORD *)a1),
      *(_DWORD *)(a1 + 16));
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 8) = 0;
    while ( 1 )
    {
      ptr = (void *)(*(_DWORD *)a1 + *(_DWORD *)(a1 + 4));
      v39 = sub_804DAF3((_DWORD *)a1);
      v33 = -16 * *(_DWORD *)(a1 + 8) + v39;
      v34 = v39 - v38 * *(_DWORD *)(a1 + 8) - (_DWORD)ptr;
      if ( *(_DWORD *)(a1 + 8) )
        v7 = (char *)(*(_DWORD *)v33 + *(_DWORD *)(v33 + 4));
      else
        v7 = *(char **)a1;
      v35 = v7;
      while ( v38 + 1 < v34 )
      {
        n = (v34 - 1) / (v38 + 1);
        v28 = (v34 - 1) / (v38 + 1);
        v8 = fread_unlocked(ptr, 1u, v28, stream);
        v41 = v8;
        v36 = (char *)ptr + v8;
        v34 -= v8;
        if ( v8 != n )
        {
          v10 = ferror_unlocked(stream) == 0;
          v13 = &loc_804DFF6;
          if ( v10 )
            v13 = &loc_804E011;
          dword_806C284 = (int)v13;
          sub_806253E(v12, v11);
          v14 = gettext("read failed");
          sub_804BA80((int)v14, a3);
        }
        dword_806C248 = (int)&loc_804E1CD;
        sub_8062696();
        do
        {
          *v42 = 0;
          ptr = v42 + 1;
          v33 -= 16;
          *(_DWORD *)v33 = v35;
          *(_DWORD *)(v33 + 4) = (_BYTE *)ptr - v35;
          v15 = v31;
          if ( *(_DWORD *)(v33 + 4) >= v31 )
            v15 = *(_DWORD *)(v33 + 4);
          v31 = v15;
          v34 -= v38;
          if ( v37 )
          {
            if ( *(_DWORD *)(v37 + 8) == -1 )
              v16 = v42;
            else
              v16 = sub_804DC73((char **)v33, v37);
            v17 = v33;
            *(_DWORD *)(v33 + 12) = v16;
            v18 = &loc_804E146;
            if ( *(_DWORD *)v37 == -1 )
              v18 = &loc_804E175;
            dword_806C234 = (int)v18;
            sub_8062704(v9, v17);
            v19 = sub_804DB0E((char **)v33, v37);
            *(_DWORD *)(v33 + 8) = v19;
            dword_806C2FC = (int)&loc_804E1C7;
            sub_806223F();
            v22 = &loc_804E199;
            if ( !*(_BYTE *)(v37 + 24) )
              v22 = &loc_804E1BE;
            dword_806C338 = (int)v22;
            sub_80620D8(v21, v20);
            while ( 1 )
            {
              v27 = *v35;
              if ( !byte_806CD37[(unsigned __int8)sub_804B6F4(v27)] )
                break;
              ++v35;
            }
            *(_DWORD *)(v33 + 8) = v35;
          }
          v35 = (char *)ptr;
          v42 = (char *)memchr(ptr, v29, v36 - (_BYTE *)ptr);
        }
        while ( v42 );
        ptr = v36;
        if ( *(_BYTE *)(a1 + 24) )
        {
          dword_806C284 = (int)&loc_804E234;
          sub_806253E(v9, v23);
        }
      }
      *(_DWORD *)(a1 + 4) = (char *)ptr - *(_DWORD *)a1;
      v24 = sub_804DAF3((_DWORD *)a1);
      *(_DWORD *)(a1 + 8) = (v24 - v33) >> 4;
      if ( *(_DWORD *)(a1 + 8) )
      {
        v26 = (char *)((_BYTE *)ptr - v35);
        *(_DWORD *)(a1 + 16) = (_BYTE *)ptr - v35;
        dword_806C40C = v31 + 18;
        dword_806C324 = (int)&loc_804E2EA;
        sub_8062148(v25, v26);
      }
      v30 = *(_DWORD *)(a1 + 12) >> 4;
      *(_DWORD *)a1 = sub_805EBB9((int)&v30, v25, *(void **)a1, (int)&v30, 16);
      *(_DWORD *)(a1 + 12) = 16 * v30;
    }
  }
  return 0;
}
// 80620D8: using guessed type int __fastcall sub_80620D8(_DWORD, _DWORD);
// 8062148: using guessed type int __fastcall sub_8062148(_DWORD, _DWORD);
// 806223F: using guessed type int sub_806223F(void);
// 806253E: using guessed type int __fastcall sub_806253E(_DWORD, _DWORD);
// 80625B6: using guessed type int __fastcall sub_80625B6(_DWORD, _DWORD);
// 8062696: using guessed type int sub_8062696(void);
// 8062704: using guessed type int __fastcall sub_8062704(_DWORD, _DWORD);
// 806C234: using guessed type int dword_806C234;
// 806C248: using guessed type int dword_806C248;
// 806C270: using guessed type int dword_806C270;
// 806C284: using guessed type int dword_806C284;
// 806C2FC: using guessed type int dword_806C2FC;
// 806C324: using guessed type int dword_806C324;
// 806C338: using guessed type int dword_806C338;
// 806C38C: using guessed type char byte_806C38C;
// 806D14B: using guessed type int dword_806D14B;

//----- (0804E2F1) --------------------------------------------------------
int __cdecl sub_804E2F1(char **a1)
{
  int v1; // ecx
  int v2; // edx
  char *v3; // eax
  int v4; // edx
  void *v5; // eax
  unsigned __int8 v7; // [esp+9h] [ebp-7h]
  bool v8; // [esp+Ah] [ebp-6h]
  char *v9; // [esp+Ch] [ebp-4h]

  v9 = *a1;
  v7 = 0;
  v8 = 0;
  while ( 1 )
  {
    v3 = v9;
    v4 = (int)(v9++ + 1);
    if ( (unsigned int)(unsigned __int8)*v3 - 48 > 9 )
      break;
    if ( v7 < (unsigned __int8)*v3 )
      v7 = *v3;
    v2 = *v9;
    v8 = v2 == dword_806CD1B;
    if ( v2 == dword_806CD1B )
      ++v9;
  }
  v5 = &loc_804E373;
  if ( !v8 )
    v5 = &loc_804E384;
  dword_806C310 = (int)v5;
  sub_80621CD(v1, v4);
  *a1 = v9 - 2;
  return v7;
}
// 80621CD: using guessed type int __fastcall sub_80621CD(_DWORD, _DWORD);
// 806C310: using guessed type int dword_806C310;
// 806CD1B: using guessed type int dword_806CD1B;

//----- (0804E3CF) --------------------------------------------------------
int __cdecl sub_804E3CF(_BYTE *a1)
{
  int result; // eax
  bool v2; // [esp+9h] [ebp-Bh]
  unsigned __int8 *v3; // [esp+Ch] [ebp-8h]
  int v4; // [esp+10h] [ebp-4h]

  v2 = *a1 == 45;
  v3 = &a1[v2];
  if ( (unsigned __int8)sub_804E2F1((char **)&v3) <= 0x30u )
    return 0;
  v4 = byte_80640D0[*v3];
  if ( v2 )
    result = -v4;
  else
    result = v4;
  return result;
}

//----- (0804E442) --------------------------------------------------------
int __cdecl sub_804E442(unsigned __int8 *a1, _BYTE *a2)
{
  int v2; // edx
  int v3; // ecx
  int v4; // ebx
  int v5; // eax
  int result; // eax

  while ( byte_806CD37[(unsigned __int8)sub_804B6F4(*a1)] )
    ++a1;
  dword_806C20C = (int)&loc_804E489;
  sub_80627EE(v3, v2);
  do
    ++a2;
  while ( byte_806CD37[(unsigned __int8)sub_804B6F4(*a2)] );
  v4 = sub_804E3CF(a1);
  v5 = sub_804E3CF(a2);
  if ( v4 == v5 )
    result = sub_805E402((int)a1, (int)a2, dword_806CD17, dword_806CD1B);
  else
    result = v4 - v5;
  return result;
}
// 80627EE: using guessed type int __fastcall sub_80627EE(_DWORD, _DWORD);
// 806C20C: using guessed type int dword_806C20C;
// 806CD17: using guessed type int dword_806CD17;
// 806CD1B: using guessed type int dword_806CD1B;

//----- (0804E4FD) --------------------------------------------------------
int __cdecl sub_804E4FD(unsigned __int8 *a1, unsigned __int8 *a2)
{
  bool v2; // zf
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  int v6; // edx
  int v7; // ecx
  void *v8; // eax

  v2 = byte_806CD37[(unsigned __int8)sub_804B6F4(*a1)] == 0;
  v5 = &loc_804E541;
  if ( !v2 )
    v5 = &loc_804E505;
  dword_806C338 = (int)v5;
  sub_80620D8(v4, v3);
  v2 = byte_806CD37[(unsigned __int8)sub_804B6F4(*a2)] == 0;
  v8 = &loc_804E56A;
  if ( !v2 )
    v8 = &loc_804E56C;
  dword_806C270 = (int)v8;
  sub_80625B6(v7, v6);
  return sub_805E402((int)a1, (int)a2, dword_806CD17, dword_806CD1B);
}
// 804E4FD: could not find valid save-restore pair for ebx
// 80620D8: using guessed type int __fastcall sub_80620D8(_DWORD, _DWORD);
// 80625B6: using guessed type int __fastcall sub_80625B6(_DWORD, _DWORD);
// 806C270: using guessed type int dword_806C270;
// 806C338: using guessed type int dword_806C338;
// 806CD17: using guessed type int dword_806CD17;
// 806CD1B: using guessed type int dword_806CD1B;

//----- (0804E5BA) --------------------------------------------------------
int __cdecl sub_804E5BA(int a1, int a2)
{
  _TBYTE s; // [esp+10h] [ebp-28h]
  _TBYTE s2; // [esp+20h] [ebp-18h]

  memset(&s, 0, 0xCu);
  *(long double *)&s = strtold(a1, 0);
  memset(&s2, 0, 0xCu);
  *(long double *)&s2 = strtold(a2, 0);
  return memcmp(&s, &s2, 0xCu);
}
// 80498F0: using guessed type double __cdecl strtold(_DWORD, _DWORD);

//----- (0804E63E) --------------------------------------------------------
signed int __cdecl sub_804E63E(int a1, int a2)
{
  void *v2; // eax
  signed int result; // eax
  int v4; // [esp+0h] [ebp-48h]
  int v5; // [esp+4h] [ebp-44h]
  int v6; // [esp+8h] [ebp-40h]
  int v7; // [esp+Ch] [ebp-3Ch]
  int v8; // [esp+10h] [ebp-38h]
  int v9; // [esp+14h] [ebp-34h]
  int v10; // [esp+18h] [ebp-30h]
  int v11; // [esp+1Ch] [ebp-2Ch]
  long double v12; // [esp+20h] [ebp-28h]
  int v13; // [esp+2Ch] [ebp-1Ch]
  long double v14; // [esp+30h] [ebp-18h]
  int v15; // [esp+3Ch] [ebp-Ch]
  int v16; // [esp+40h] [ebp-8h]
  int v17; // [esp+44h] [ebp-4h]
  int savedregs; // [esp+48h] [ebp+0h]

  v12 = strtold(a1, &v10);
  v14 = strtold(a2, &v11);
  if ( a1 == v10 )
  {
    v2 = &loc_804E697;
    if ( a2 != v11 )
      v2 = &loc_804E69E;
    dword_806C298 = (int)v2;
    sub_80624B3();
    result = 0;
  }
  else
  {
    if ( a2 == v11 )
    {
      dword_806C2E8 = (int)&locret_804E768;
      sub_80622AD(
        v4,
        v5,
        v6,
        v7,
        v8,
        v9,
        v10,
        v11,
        LODWORD(v12),
        DWORD1(v12),
        HIDWORD(v12),
        v13,
        LODWORD(v14),
        DWORD1(v14),
        HIDWORD(v14),
        v15,
        v16,
        v17,
        savedregs);
    }
    if ( v14 <= v12 )
    {
      if ( v12 <= v14 )
      {
        if ( v14 == v12 )
          result = 0;
        else
          result = -1;
      }
      else
      {
        result = 1;
      }
    }
    else
    {
      result = -1;
    }
  }
  return result;
}
// 80498F0: using guessed type double __cdecl strtold(_DWORD, _DWORD);
// 80622AD: using guessed type int __stdcall sub_80622AD(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80624B3: using guessed type int sub_80624B3(void);
// 806C298: using guessed type int dword_806C298;
// 806C2E8: using guessed type int dword_806C2E8;

//----- (0804E76A) --------------------------------------------------------
int __cdecl sub_804E76A(unsigned __int8 *a1, unsigned __int8 **a2)
{
  bool v2; // zf
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  void *v6; // eax
  int v7; // eax
  int v9; // [esp+0h] [ebp-28h]
  int v10; // [esp+10h] [ebp-18h]
  int v11; // [esp+14h] [ebp-14h]
  unsigned __int8 *v12; // [esp+18h] [ebp-10h]
  char *v13; // [esp+1Ch] [ebp-Ch]
  unsigned int v14; // [esp+20h] [ebp-8h]

  v10 = 0;
  v11 = 12;
  v2 = byte_806CD37[(unsigned __int8)sub_804B6F4(*a1)] == 0;
  v5 = &loc_804E7BD;
  if ( !v2 )
    v5 = &loc_804E781;
  dword_806C20C = (int)v5;
  sub_80627EE(v4, v3);
  v14 = (unsigned int)(v10 + v11) >> 1;
  v12 = a1;
  v13 = (&off_806C3AC)[2 * v14];
  v6 = &loc_804E800;
  if ( *v13 )
    v6 = &loc_804E82F;
  dword_806C2C0 = (int)v6;
  sub_806239B();
  if ( a2 )
    *a2 = v12;
  v7 = dword_806C3B0[2 * v14];
  dword_806C248 = (int)&loc_804E86C;
  sub_8062696();
  v9 = byte_806D037[(unsigned __int8)sub_804B6F4(*v12)];
  sub_804B6F4(v9);
  dword_806C2FC = (int)sub_804E908;
  return sub_806223F();
}
// 804E908: using guessed type int sub_804E908();
// 806223F: using guessed type int sub_806223F(void);
// 8062696: using guessed type int sub_8062696(void);
// 80627EE: using guessed type int __fastcall sub_80627EE(_DWORD, _DWORD);
// 806C20C: using guessed type int dword_806C20C;
// 806C248: using guessed type int dword_806C248;
// 806C2C0: using guessed type int dword_806C2C0;
// 806C2FC: using guessed type int dword_806C2FC;
// 806C3AC: using guessed type char *off_806C3AC;
// 806C3B0: using guessed type int dword_806C3B0[];

//----- (0804E920) --------------------------------------------------------
unsigned int __usercall sub_804E920@<eax>(double a1@<st0>, int a2)
{
  char *v2; // eax
  char *v3; // eax
  size_t v4; // edx
  int v5; // ecx
  char *ptr; // [esp+18h] [ebp-20h]
  char src; // [esp+1Ch] [ebp-1Ch]
  unsigned int v9; // [esp+2Ch] [ebp-Ch]

  v9 = __readgsdword(0x14u);
  ptr = sub_805C8D5(a1, a2, 0x10u);
  if ( !ptr )
  {
    v2 = gettext("open failed");
    sub_804BA80((int)v2, a2);
  }
  sub_805CBD5((int)ptr, &src, 0x10u);
  if ( sub_805CC1D(ptr) )
  {
    v3 = gettext("close failed");
    sub_804BA80((int)v3, a2);
  }
  sub_805628C(&unk_806D1F7);
  sub_805664E(v4, v5, &src, 0x10u, (int)&unk_806D1F7);
  return __readgsdword(0x14u) ^ v9;
}

//----- (0804E9EC) --------------------------------------------------------
int __cdecl sub_804E9EC(char *dest, char *src, size_t n)
{
  size_t i; // eax
  char *v4; // ebx
  int *v5; // eax
  int v6; // edx
  int v7; // ecx
  size_t v9; // [esp+1Ch] [ebp-Ch]

  *__errno_location() = 0;
  for ( i = strxfrm(dest, src, n); ; i = sub_80621CD(v7, v6) )
  {
    v9 = i;
    if ( !*__errno_location() )
      break;
    v4 = gettext("string transformation failed");
    v5 = __errno_location();
    error(0, *v5, v4);
    gettext("set LC_ALL='C' to work around the problem");
    dword_806C310 = (int)&loc_804EA1C;
  }
  return v9;
}
// 80621CD: using guessed type int __fastcall sub_80621CD(_DWORD, _DWORD);
// 806C310: using guessed type int dword_806C310;

//----- (0804EB01) --------------------------------------------------------
int __usercall sub_804EB01@<eax>(double a1@<st0>, int a2, size_t a3, int a4, size_t a5)
{
  int v5; // ecx
  size_t v6; // eax
  unsigned int v7; // eax
  void *v8; // eax
  int v9; // ecx
  int v10; // ecx
  void *v11; // eax
  size_t v12; // edx
  int v13; // edx
  int v14; // ecx
  size_t v15; // edx
  size_t v16; // eax
  size_t v17; // eax
  int v18; // ecx
  size_t v19; // eax
  int v20; // eax
  bool v21; // zf
  void *v22; // eax
  size_t v23; // edx
  int v24; // ecx
  size_t v25; // eax
  int v26; // eax
  void *v27; // eax
  char *s; // [esp+18h] [ebp-1150h]
  char *src; // [esp+1Ch] [ebp-114Ch]
  bool v31; // [esp+2Bh] [ebp-113Dh]
  int v32; // [esp+2Ch] [ebp-113Ch]
  char *dest; // [esp+30h] [ebp-1138h]
  size_t size; // [esp+34h] [ebp-1134h]
  void *ptr; // [esp+38h] [ebp-1130h]
  int v36; // [esp+3Ch] [ebp-112Ch]
  char *v37; // [esp+40h] [ebp-1128h]
  char *v38; // [esp+44h] [ebp-1124h]
  size_t v39; // [esp+48h] [ebp-1120h]
  size_t n; // [esp+4Ch] [ebp-111Ch]
  size_t v41; // [esp+50h] [ebp-1118h]
  char s1; // [esp+54h] [ebp-1114h]
  int v43; // [esp+64h] [ebp-1104h]
  int v44; // [esp+74h] [ebp-10F4h]
  char v45; // [esp+110h] [ebp-1058h]
  char v46; // [esp+1ACh] [ebp-FBCh]
  unsigned int v47; // [esp+114Ch] [ebp-1Ch]

  src = (char *)a2;
  s = (char *)a4;
  v47 = __readgsdword(0x14u);
  v32 = 0;
  dest = &v46;
  size = 4000;
  ptr = 0;
  qmemcpy(&v45, &unk_806D1F7, 0x9Cu);
  qmemcpy(&v44, &v45, 0x9Cu);
  v5 = 0;
  if ( byte_806CD1F )
  {
    v37 = &src[a3];
    v38 = &s[a5];
    while ( 1 )
    {
      v39 = 3 * (a5 + a3) + 2;
      if ( size < v39 )
      {
        v6 = v39;
        if ( 3 * size >> 1 >= v39 )
          v6 = 3 * size >> 1;
        size = v6;
        free(ptr);
        ptr = malloc(size);
        dest = (char *)ptr;
        if ( !ptr )
        {
          dest = &v46;
          size = 4000;
        }
      }
      if ( src >= v37 )
        v7 = 0;
      else
        v7 = sub_804E9EC(dest, src, size) + 1;
      n = v7;
      v31 = v7 <= size;
      if ( s < v38 )
      {
        v8 = &loc_804ECD2;
        if ( !v31 )
          v8 = &loc_804ECF7;
        dword_806C2C0 = (int)v8;
        sub_806239B();
        dword_806C310 = (int)&loc_804ECFC;
        sub_80621CD(v9, size - n);
        v11 = &loc_804ED1E;
        if ( !v31 )
          v11 = &loc_804ED43;
        dword_806C338 = (int)v11;
        sub_80620D8(v10, 0);
        dword_806C2FC = (int)&loc_804ED48;
        sub_806223F();
        sub_804E9EC(0, s, v12);
        dword_806C234 = (int)&loc_804ED7D;
        sub_8062704(v14, v13);
      }
      v41 = 0;
      if ( v31 != 1 || (v15 = n, n + v41 > size) )
      {
        size = n + v41;
        if ( n + v41 <= 0x55555554 )
          size = 3 * size >> 1;
        free(ptr);
        ptr = sub_805EC7C(size);
        dest = (char *)ptr;
        if ( src < v37 )
          strxfrm(dest, src, n);
        if ( s < v38 )
          strxfrm(&dest[n], s, v41);
      }
      if ( src < v37 )
      {
        v16 = strlen(src);
        src += v16 + 1;
      }
      if ( s < v38 )
      {
        v17 = strlen(s);
        s += v17 + 1;
      }
      if ( src >= v37 && s >= v38 )
      {
        a3 = n;
        src = dest;
        a5 = v41;
        s = &dest[n];
        dword_806C2C0 = (int)&loc_804F021;
        sub_806239B();
      }
      sub_805664E(v15, v5, dest, n, (int)&v44);
      sub_805664E((size_t)&dest[n], v18, &dest[n], v41, (int)&v45);
      if ( !v32 )
      {
        v19 = n;
        if ( v41 <= n )
          v19 = v41;
        v20 = memcmp(dest, &dest[n], v19);
        v32 = v20;
        v21 = v20 == 0;
        v22 = &loc_804EFE1;
        if ( !v21 )
          v22 = &loc_804F01C;
        dword_806C25C = (int)v22;
        sub_8062626(a1);
        v32 = (n > v41) - (n < v41);
      }
    }
  }
  sub_805664E((size_t)&v44, 0, src, a3, (int)&v44);
  sub_8056352(&v44, &s1);
  sub_805664E(v23, v24, s, a5, (int)&v45);
  sub_8056352((int *)&v45, &v43);
  v36 = memcmp(&s1, &v43, 0x10u);
  if ( !v36 )
  {
    if ( !v32 )
    {
      v25 = a3;
      if ( a5 <= a3 )
        v25 = a5;
      v26 = memcmp(src, s, v25);
      v32 = v26;
      v21 = v26 == 0;
      v27 = &loc_804F13C;
      if ( !v21 )
        v27 = &loc_804F15E;
      dword_806C358 = (int)v27;
      sub_8061FAB();
      v32 = (a3 > a5) - (a3 < a5);
    }
    v36 = v32;
  }
  free(ptr);
  return v36;
}
// 8061FAB: using guessed type int sub_8061FAB(void);
// 80620D8: using guessed type int __fastcall sub_80620D8(_DWORD, _DWORD);
// 80621CD: using guessed type int __fastcall sub_80621CD(_DWORD, _DWORD);
// 806223F: using guessed type int sub_806223F(void);
// 8062626: using guessed type int __usercall sub_8062626@<eax>(double@<st0>);
// 8062704: using guessed type int __fastcall sub_8062704(_DWORD, _DWORD);
// 806C234: using guessed type int dword_806C234;
// 806C25C: using guessed type int dword_806C25C;
// 806C2C0: using guessed type int dword_806C2C0;
// 806C2FC: using guessed type int dword_806C2FC;
// 806C310: using guessed type int dword_806C310;
// 806C338: using guessed type int dword_806C338;
// 806C358: using guessed type int dword_806C358;
// 806CD1F: using guessed type char byte_806CD1F;

//----- (0804F19A) --------------------------------------------------------
signed int __cdecl sub_804F19A(char *a1, unsigned int a2)
{
  char *v2; // eax
  signed int v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_8059ADB(a1, a2 - (_DWORD)a1, 0);
  while ( (unsigned int)a1 < a2 )
  {
    v2 = a1++;
    v4 += *v2 == 9;
  }
  return v4;
}

//----- (0804F20A) --------------------------------------------------------
int __cdecl sub_804F20A(int a1, int a2)
{
  void *v2; // eax
  char *v3; // eax
  void *v5; // eax

  v5 = &loc_804F29D;
  if ( a1 )
    v5 = &loc_804F212;
  dword_806C2D4 = (int)v5;
  sub_8062323();
  v2 = &loc_804F253;
  if ( a2 )
    v2 = &loc_804F269;
  dword_806C298 = (int)v2;
  sub_80624B3();
  v3 = gettext("^ no match for key\n");
  return printf(v3);
}
// 804F20A: could not find valid save-restore pair for ebx
// 8062323: using guessed type int sub_8062323(void);
// 80624B3: using guessed type int sub_80624B3(void);
// 806C298: using guessed type int dword_806C298;
// 806C2D4: using guessed type int dword_806C2D4;

//----- (0804F2AD) --------------------------------------------------------
signed int __usercall sub_804F2AD@<eax>(int a1@<edx>, int a2@<ecx>, _BYTE *a3)
{
  void *v3; // eax

  if ( !a3[26] && !a3[28] )
  {
    v3 = &loc_804F2EA;
    if ( !a3[29] )
      v3 = &loc_804F2F1;
    dword_806C324 = (int)v3;
    sub_8062148(a2, a1);
  }
  return 1;
}
// 8062148: using guessed type int __fastcall sub_8062148(_DWORD, _DWORD);
// 806C324: using guessed type int dword_806C324;

//----- (0804F2FB) --------------------------------------------------------
int __cdecl sub_804F2FB(int a1, int a2)
{
  int v2; // ecx
  int v3; // edx
  void *v4; // eax
  _BOOL4 v5; // eax
  int v6; // ecx
  char *v7; // edx
  void *v8; // eax
  int v9; // edx
  int v10; // ecx
  int v12; // [esp+0h] [ebp-48h]
  char v13; // [esp+11h] [ebp-37h]
  unsigned __int8 v14; // [esp+12h] [ebp-36h]
  unsigned __int8 v15; // [esp+13h] [ebp-35h]
  char *v16; // [esp+14h] [ebp-34h]
  char *v17; // [esp+18h] [ebp-30h]
  unsigned __int8 *v18; // [esp+1Ch] [ebp-2Ch]
  char *v19; // [esp+20h] [ebp-28h]
  char *v20; // [esp+24h] [ebp-24h]
  int v21; // [esp+28h] [ebp-20h]
  int v22; // [esp+2Ch] [ebp-1Ch]
  long double v23; // [esp+30h] [ebp-18h]

  v20 = *(char **)a1;
  v18 = (unsigned __int8 *)v20;
  v3 = *(_DWORD *)(a1 + 4) - 1;
  v19 = &v20[v3];
  if ( a2 )
  {
    if ( *(_DWORD *)a2 == -1 )
    {
      while ( 1 )
      {
        if ( *(_DWORD *)(a2 + 8) != -1 )
          v19 = sub_804DC73((char **)a1, a2);
        if ( (!*(_BYTE *)(a2 + 24) || *(_DWORD *)a2 != -1)
          && !*(_BYTE *)(a2 + 30)
          && !(unsigned __int8)sub_804F2AD(v3, v2, (_BYTE *)a2) )
        {
          break;
        }
        v13 = *v19;
        *v19 = 0;
        dword_806C270 = (int)&loc_804F3EE;
        sub_80625B6(v2, v3);
        do
          v12 = (char)*++v18;
        while ( byte_806CD37[(unsigned __int8)sub_804B6F4(v12)] );
        v16 = (char *)v18;
        if ( v19 < (char *)v18 )
        {
          v16 = v19;
          goto LABEL_33;
        }
        if ( *(_BYTE *)(a2 + 30) )
        {
          sub_804E76A(v18, (unsigned __int8 **)&v16);
          goto LABEL_33;
        }
        if ( !*(_BYTE *)(a2 + 28) )
          goto LABEL_4;
        v23 = strtold(v18, &v16);
        dword_806C248 = (int)&loc_804F57D;
        sub_8062696();
        dword_806C2D4 = (int)&loc_804F35D;
        v18 = (unsigned __int8 *)sub_8062323();
      }
    }
    else
    {
      sub_804DB0E((char **)a1, a2);
      dword_806C298 = (int)&loc_804F49A;
      sub_80624B3();
LABEL_4:
      if ( !*(_BYTE *)(a2 + 26) )
      {
        v4 = &loc_804F4D2;
        if ( !*(_BYTE *)(a2 + 29) )
          v4 = &loc_804F577;
        dword_806C2C0 = (int)v4;
        sub_806239B();
      }
      v5 = v18 < (unsigned __int8 *)v19 && *v18 == 45;
      v17 = (char *)&v18[v5];
      v14 = sub_804E2F1(&v17);
      if ( v14 > 0x2Fu )
      {
        v15 = *v17;
        v7 = v17;
        if ( *(_BYTE *)(a2 + 29) )
        {
          v8 = &loc_804F54D;
          if ( !byte_80640D0[v15] )
            v8 = &loc_804F569;
          dword_806C284 = (int)v8;
          sub_806253E(v6, v17);
          dword_806C20C = (int)&loc_804F56E;
          sub_80627EE(v10, v9);
        }
        v16 = v7;
      }
LABEL_33:
      *v19 = v13;
      v19 = v16;
    }
  }
  v21 = sub_804F19A(v20, (unsigned int)v18);
  v22 = sub_804F19A((char *)v18, (unsigned int)v19);
  return sub_804F20A(v21, v22);
}
// 804F2FB: could not find valid save-restore pair for ebx
// 80498F0: using guessed type double __cdecl strtold(_DWORD, _DWORD);
// 8062323: using guessed type int sub_8062323(void);
// 80624B3: using guessed type int sub_80624B3(void);
// 806253E: using guessed type int __fastcall sub_806253E(_DWORD, _DWORD);
// 80625B6: using guessed type int __fastcall sub_80625B6(_DWORD, _DWORD);
// 8062696: using guessed type int sub_8062696(void);
// 80627EE: using guessed type int __fastcall sub_80627EE(_DWORD, _DWORD);
// 806C20C: using guessed type int dword_806C20C;
// 806C248: using guessed type int dword_806C248;
// 806C270: using guessed type int dword_806C270;
// 806C284: using guessed type int dword_806C284;
// 806C298: using guessed type int dword_806C298;
// 806C2C0: using guessed type int dword_806C2C0;
// 806C2D4: using guessed type int dword_806C2D4;

//----- (0804F5CA) --------------------------------------------------------
int __cdecl sub_804F5CA(int a1)
{
  int result; // eax
  int v2; // [esp+1Ch] [ebp-Ch]

  v2 = dword_806D14B;
  while ( 1 )
  {
    result = sub_804F2FB(a1, v2);
    if ( !v2 )
      break;
    v2 = *(_DWORD *)(v2 + 36);
    if ( !v2 )
    {
      result = (unsigned __int8)byte_806D149 ^ 1;
      if ( byte_806D149 == 1 )
        break;
      result = (unsigned __int8)byte_806D148 ^ 1;
      if ( byte_806D148 == 1 )
        break;
    }
  }
  return result;
}
// 806D148: using guessed type char byte_806D148;
// 806D149: using guessed type char byte_806D149;
// 806D14B: using guessed type int dword_806D14B;

//----- (0804F61D) --------------------------------------------------------
int __usercall sub_804F61D@<eax>(int a1@<edx>, int a2@<ecx>, int a3)
{
  return !*(_DWORD *)(a3 + 16)
      && !*(_DWORD *)(a3 + 20)
      && *(_BYTE *)(a3 + 24) != 1
      && *(_BYTE *)(a3 + 25) != 1
      && (unsigned __int8)sub_804F2AD(a1, a2, (_BYTE *)a3) ^ 1
      && *(_BYTE *)(a3 + 30) != 1
      && *(_BYTE *)(a3 + 32) != 1
      && *(_BYTE *)(a3 + 27) != 1;
}

//----- (0804F6A0) --------------------------------------------------------
_BYTE *__usercall sub_804F6A0@<eax>(double a1@<st0>, _BYTE *edx0@<edx>, int ecx0@<ecx>, int a2, _BYTE *a3)
{
  _BYTE *v5; // eax
  void *v6; // eax
  _BYTE *v7; // eax
  _BYTE *v8; // eax
  _BYTE *v9; // eax
  _BYTE *v10; // eax
  _BYTE *v11; // eax
  void *v12; // eax
  _BYTE *v13; // eax
  void *v14; // eax
  _BYTE *v15; // eax
  void *v16; // eax
  _BYTE *v17; // eax
  void *v18; // eax
  _BYTE *v19; // eax
  _BYTE *v20; // eax
  _BYTE *result; // eax
  _BYTE *v22; // [esp+Ch] [ebp+Ch]
  int v23; // [esp+Ch] [ebp+Ch]
  int v24; // [esp+Ch] [ebp+Ch]
  int v25; // [esp+Ch] [ebp+Ch]
  _BYTE *v26; // [esp+Ch] [ebp+Ch]

  if ( *(_BYTE *)(a2 + 24) || *(_BYTE *)(a2 + 25) )
  {
    v5 = a3;
    edx0 = a3++ + 1;
    *v5 = 98;
  }
  v6 = &loc_804F6EB;
  if ( *(_UNKNOWN **)(a2 + 16) != &unk_806CF37 )
    v6 = &loc_804F6F7;
  dword_806C338 = (int)v6;
  sub_80620D8(ecx0, edx0);
  v7 = a3;
  v22 = a3 + 1;
  *v7 = 100;
  if ( *(_DWORD *)(a2 + 20) )
  {
    v8 = v22++;
    *v8 = 102;
  }
  if ( *(_BYTE *)(a2 + 28) )
  {
    v9 = v22++;
    *v9 = 103;
  }
  if ( *(_BYTE *)(a2 + 29) )
  {
    v10 = v22++;
    *v10 = 104;
  }
  if ( *(_UNKNOWN **)(a2 + 16) == &unk_806CE37 )
  {
    v11 = v22++;
    *v11 = 105;
  }
  v12 = &loc_804F778;
  if ( !*(_BYTE *)(a2 + 30) )
    v12 = &loc_804F784;
  dword_806C25C = (int)v12;
  sub_8062626(a1);
  v13 = v22;
  v23 = (int)(v22 + 1);
  *v13 = 77;
  v14 = &loc_804F7A8;
  if ( !*(_BYTE *)(a2 + 26) )
    v14 = &loc_804F7B4;
  dword_806C2FC = (int)v14;
  sub_806223F();
  v15 = (_BYTE *)v23;
  v24 = v23 + 1;
  *v15 = 110;
  v16 = &loc_804F7D8;
  if ( !*(_BYTE *)(a2 + 27) )
    v16 = &loc_804F7E4;
  dword_806C220 = (int)v16;
  sub_806277E();
  v17 = (_BYTE *)v24;
  v25 = v24 + 1;
  *v17 = 82;
  v18 = &loc_804F808;
  if ( !*(_BYTE *)(a2 + 31) )
    v18 = &loc_804F814;
  dword_806C2D4 = (int)v18;
  sub_8062323();
  v19 = (_BYTE *)v25;
  v26 = (_BYTE *)(v25 + 1);
  *v19 = 114;
  if ( *(_BYTE *)(a2 + 32) )
  {
    v20 = v26++;
    *v20 = 86;
  }
  result = v26;
  *v26 = 0;
  return result;
}
// 804F6A0: could not find valid save-restore pair for ebx
// 80620D8: using guessed type int __fastcall sub_80620D8(_DWORD, _DWORD);
// 806223F: using guessed type int sub_806223F(void);
// 8062323: using guessed type int sub_8062323(void);
// 8062626: using guessed type int __usercall sub_8062626@<eax>(double@<st0>);
// 806277E: using guessed type int sub_806277E(void);
// 806C220: using guessed type int dword_806C220;
// 806C25C: using guessed type int dword_806C25C;
// 806C2D4: using guessed type int dword_806C2D4;
// 806C2FC: using guessed type int dword_806C2FC;
// 806C338: using guessed type int dword_806C338;

//----- (0804F833) --------------------------------------------------------
unsigned int __usercall sub_804F833@<eax>(double a1@<st0>, int ecx0@<ecx>, int *a2, char a3)
{
  unsigned int v4; // edx
  int v5; // ecx
  int v6; // eax
  int v7; // eax
  const char *v8; // edx
  int v9; // eax
  const char *v10; // eax
  void *v11; // esi
  char *v12; // ebx
  char *v13; // eax
  bool v14; // al
  char *v15; // eax
  int v16; // edx
  int v17; // ecx
  bool v18; // al
  void *v19; // eax
  void *v20; // eax
  void *v21; // eax
  char *v22; // eax
  bool v23; // zf
  int v24; // edx
  int v25; // ecx
  void *v26; // eax
  int v27; // edx
  int v28; // ecx
  void *v29; // eax
  char *v30; // eax
  void *v31; // eax
  unsigned __int8 v32; // al
  _BYTE *v33; // edx
  int v34; // ecx
  void *v35; // eax
  int v36; // eax
  int v37; // eax
  char *v38; // eax
  void *v39; // eax
  char *v40; // eax
  __int64 v42; // [esp+0h] [ebp-C8h]
  char *v43; // [esp+Ch] [ebp-BCh]
  void *v44; // [esp+10h] [ebp-B8h]
  char v45; // [esp+18h] [ebp-B0h]
  int *v46; // [esp+1Ch] [ebp-ACh]
  bool v47; // [esp+20h] [ebp-A8h]
  bool v48; // [esp+21h] [ebp-A7h]
  char v49; // [esp+22h] [ebp-A6h]
  char v50; // [esp+23h] [ebp-A5h]
  int v51; // [esp+24h] [ebp-A4h]
  char *v52; // [esp+28h] [ebp-A0h]
  unsigned int v53; // [esp+2Ch] [ebp-9Ch]
  unsigned int v54; // [esp+30h] [ebp-98h]
  int v55; // [esp+34h] [ebp-94h]
  char *v56; // [esp+38h] [ebp-90h]
  char *v57; // [esp+3Ch] [ebp-8Ch]
  unsigned int v58; // [esp+40h] [ebp-88h]
  int v59; // [esp+44h] [ebp-84h]
  int v60; // [esp+48h] [ebp-80h]
  int v61; // [esp+4Ch] [ebp-7Ch]
  int v62; // [esp+50h] [ebp-78h]
  int v63; // [esp+54h] [ebp-74h]
  int v64; // [esp+58h] [ebp-70h]
  int v65; // [esp+5Ch] [ebp-6Ch]
  int v66; // [esp+60h] [ebp-68h]
  int v67; // [esp+64h] [ebp-64h]
  int v68; // [esp+68h] [ebp-60h]
  char v69; // [esp+6Eh] [ebp-5Ah]
  char v70; // [esp+83h] [ebp-45h]
  char s; // [esp+9Dh] [ebp-2Bh]
  unsigned int v72; // [esp+BCh] [ebp-Ch]

  v46 = a2;
  v45 = a3;
  v72 = __readgsdword(0x14u);
  v59 = *a2;
  v60 = a2[1];
  v61 = a2[2];
  v62 = a2[3];
  v63 = a2[4];
  v64 = a2[5];
  v65 = a2[6];
  v66 = a2[7];
  v67 = a2[8];
  v68 = a2[9];
  v52 = (char *)1;
  v51 = dword_806D14B;
  dword_806C20C = (int)&loc_804FF17;
  sub_80627EE(ecx0, v67);
  do
  {
    if ( *(_BYTE *)(v51 + 33) )
    {
      v53 = *(_DWORD *)v51;
      v55 = *(_DWORD *)(v51 + 8);
      v56 = &v70;
      v57 = &s;
      if ( v53 == -1 )
        v53 = 0;
      v6 = sub_8059A28(v53, (int)&v69);
      *(_WORD *)v56 = 43;
      v56 = (char *)stpcpy(v56 + 1, v6);
      v42 = v53 + 1;
      v7 = sub_8059A28(v42, (int)&v69);
      *(_DWORD *)v57 = 2124589;
      v57 = (char *)stpcpy(v57 + 3, v7);
      if ( *(_DWORD *)(v51 + 8) != -1 )
      {
        v42 = (unsigned int)(v55 + 1);
        v8 = (const char *)sub_8059A28(v42, (int)&v69);
        v9 = (int)v56;
        *(_WORD *)v56 = 11552;
        *(_BYTE *)(v9 + 2) = 0;
        strcpy(v56 + 2, v8);
        v10 = (const char *)sub_8059A28((unsigned int)(*(_DWORD *)(v51 + 12) == -1) + v55 + 1, (int)&v69);
        *(_WORD *)v57 = 44;
        strcpy(v57 + 1, v10);
      }
      v11 = sub_805C54D(a1, 1, &s);
      v12 = (char *)sub_805C54D(a1, 0, &v70);
      v13 = gettext("obsolescent key %s used; consider %s instead");
      v44 = v11;
      v43 = v12;
      error(0, 0, v13, v12, v11);
    }
    v14 = 0;
    if ( *(_DWORD *)v51 != -1 )
    {
      v4 = *(_DWORD *)(v51 + 8);
      if ( v4 < *(_DWORD *)v51 )
        v14 = 1;
    }
    v47 = v14;
    if ( v14 )
    {
      v15 = gettext("key %lu has zero width and will be ignored");
      v43 = v52;
      error(0, 0, v15, v52);
    }
    v18 = (unsigned __int8)sub_804F2AD(v4, v5, (_BYTE *)v51) || *(_BYTE *)(v51 + 30);
    v48 = v18;
    if ( !*(_DWORD *)(v51 + 8) && *(_DWORD *)(v51 + 12) )
    {
      dword_806C2AC = (int)&loc_804FB92;
      sub_8062420();
    }
    v49 = 0;
    if ( v47 != 1 )
    {
      v19 = &loc_804FBD8;
      if ( v45 == 1 )
        v19 = &loc_804FCB5;
      dword_806C234 = (int)v19;
      sub_8062704(v17, v16);
      if ( dword_806C410 == 128 && v49 != 1 )
      {
        if ( *(_BYTE *)(v51 + 24) != 1 && v48 != 1 )
          goto LABEL_73;
        v20 = &loc_804FC43;
        if ( *(_BYTE *)(v51 + 24) == 1 )
          v20 = &loc_804FC50;
        dword_806C234 = (int)v20;
        sub_8062704(v17, v16);
        if ( *(_DWORD *)(v51 + 4) )
          goto LABEL_73;
        v21 = &loc_804FC7A;
        if ( *(_BYTE *)(v51 + 25) == 1 )
          v21 = &loc_804FCB5;
        dword_806C2C0 = (int)v21;
        sub_806239B();
        if ( *(_DWORD *)(v51 + 12) )
        {
LABEL_73:
          v22 = gettext("leading blanks are significant in key %lu; consider also specifying 'b'");
          v43 = v52;
          error(0, 0, v22, v52);
        }
      }
    }
    if ( v45 != 1 )
    {
      v23 = (unsigned __int8)sub_804F2AD(v16, v17, (_BYTE *)v51) == 0;
      v26 = &loc_804FCF2;
      if ( v23 )
        v26 = &loc_804FD83;
      dword_806C20C = (int)v26;
      sub_80627EE(v25, v24);
      v54 = *(_DWORD *)v51 + 1;
      v58 = *(_DWORD *)(v51 + 8) + 1;
      v29 = &loc_804FD37;
      if ( v54 )
        v29 = &loc_804FD3E;
      dword_806C324 = (int)v29;
      sub_8062148(v28, v27);
      ++v54;
      if ( !v58 || v54 < v58 )
      {
        v30 = gettext("key %lu is numeric and spans multiple fields");
        v43 = v52;
        error(0, 0, v30, v52);
      }
    }
    v31 = &loc_804FDA3;
    if ( !v63 )
      v31 = &loc_804FDBA;
    dword_806C310 = (int)v31;
    sub_80621CD(v17, v16);
    if ( v63 == *(_DWORD *)(v51 + 16) )
      v63 = 0;
    if ( v64 && v64 == *(_DWORD *)(v51 + 20) )
      v64 = 0;
    LOBYTE(v65) = (unsigned __int8)(v65 & (*(_BYTE *)(v51 + 24) ^ 1)) != 0;
    BYTE1(v65) = (BYTE1(v65) & (*(_BYTE *)(v51 + 25) ^ 1)) != 0;
    BYTE2(v66) = (BYTE2(v66) & (*(_BYTE *)(v51 + 30) ^ 1)) != 0;
    BYTE2(v65) = (BYTE2(v65) & (*(_BYTE *)(v51 + 26) ^ 1)) != 0;
    LOBYTE(v66) = (unsigned __int8)(v66 & (*(_BYTE *)(v51 + 28) ^ 1)) != 0;
    BYTE1(v66) = (BYTE1(v66) & (*(_BYTE *)(v51 + 29) ^ 1)) != 0;
    HIBYTE(v65) = (HIBYTE(v65) & (*(_BYTE *)(v51 + 27) ^ 1)) != 0;
    LOBYTE(v67) = (unsigned __int8)(v67 & (*(_BYTE *)(v51 + 32) ^ 1)) != 0;
    v4 = HIBYTE(v66);
    HIBYTE(v66) = (HIBYTE(v66) & (*(_BYTE *)(v51 + 31) ^ 1)) != 0;
    v51 = *(_DWORD *)(v51 + 36);
    ++v52;
  }
  while ( v51 );
  v32 = sub_804F61D(v4, v5, (int)&v59);
  if ( v32 ^ 1 )
    goto LABEL_74;
  v35 = &loc_804FF6A;
  if ( !HIBYTE(v66) )
    v35 = &loc_805002D;
  dword_806C270 = (int)v35;
  sub_80625B6(v34, v33);
  if ( byte_806D148 || byte_806D149 )
  {
    if ( dword_806D14B )
    {
LABEL_74:
      v50 = HIBYTE(v66);
      if ( byte_806D148 != 1 && byte_806D149 != 1 )
        HIBYTE(v66) = 0;
      sub_804F6A0(a1, v33, v34, (int)&v59, &s);
      v36 = strlen(&s);
      v37 = sub_804B745(v36, 0);
      v38 = ngettext("option '-%s' is ignored", "options '-%s' are ignored", v37);
      v43 = &s;
      error(0, 0, v38, &s);
      HIBYTE(v66) = v50;
    }
  }
  if ( HIBYTE(v66) )
  {
    v39 = &loc_805005C;
    if ( byte_806D148 == 1 )
      v39 = &loc_80500A3;
    dword_806C20C = (int)v39;
    sub_80627EE(v34, v33);
    if ( byte_806D149 != 1 && dword_806D14B )
    {
      v40 = gettext("option '-r' only applies to last-resort comparison");
      error(0, 0, v40);
    }
  }
  return __readgsdword(0x14u) ^ v72;
}
// 8049930: using guessed type int __cdecl stpcpy(_DWORD, _DWORD);
// 8062148: using guessed type int __fastcall sub_8062148(_DWORD, _DWORD);
// 80621CD: using guessed type int __fastcall sub_80621CD(_DWORD, _DWORD);
// 8062420: using guessed type int sub_8062420(void);
// 80625B6: using guessed type int __fastcall sub_80625B6(_DWORD, _DWORD);
// 8062704: using guessed type int __fastcall sub_8062704(_DWORD, _DWORD);
// 80627EE: using guessed type int __fastcall sub_80627EE(_DWORD, _DWORD);
// 806C20C: using guessed type int dword_806C20C;
// 806C234: using guessed type int dword_806C234;
// 806C270: using guessed type int dword_806C270;
// 806C2AC: using guessed type int dword_806C2AC;
// 806C2C0: using guessed type int dword_806C2C0;
// 806C310: using guessed type int dword_806C310;
// 806C324: using guessed type int dword_806C324;
// 806C410: using guessed type int dword_806C410;
// 806D148: using guessed type char byte_806D148;
// 806D149: using guessed type char byte_806D149;
// 806D14B: using guessed type int dword_806D14B;

//----- (080500BE) --------------------------------------------------------
int __cdecl sub_80500BE(int a1, int a2)
{
  int v2; // ecx
  char *v3; // eax
  char *v4; // eax
  void *v5; // eax
  void *v6; // eax
  unsigned __int8 v7; // al
  size_t v8; // eax
  void *v9; // eax
  unsigned __int8 v10; // al
  unsigned __int8 v11; // al
  size_t v12; // eax
  char *v13; // ebx
  unsigned __int8 v14; // al
  char v15; // al
  void *v16; // eax
  int v17; // ebx
  void *v18; // eax
  void *v20; // eax
  int v21; // edx
  int v22; // ecx
  char *v23; // [esp-8h] [ebp-1020h]
  int v24; // [esp+0h] [ebp-1018h]
  int v25; // [esp+4h] [ebp-1014h]
  int v26; // [esp+8h] [ebp-1010h]
  int v27; // [esp+Ch] [ebp-100Ch]
  int v28; // [esp+10h] [ebp-1008h]
  int v29; // [esp+14h] [ebp-1004h]
  int v30; // [esp+18h] [ebp-1000h]
  int v31; // [esp+1Ch] [ebp-FFCh]
  int v32; // [esp+20h] [ebp-FF8h]
  int v33; // [esp+24h] [ebp-FF4h]
  int v34; // [esp+28h] [ebp-FF0h]
  void *s1; // [esp+2Ch] [ebp-FECh]
  void *s2; // [esp+30h] [ebp-FE8h]
  char *v37; // [esp+34h] [ebp-FE4h]
  char *v38; // [esp+38h] [ebp-FE0h]
  int v39; // [esp+3Ch] [ebp-FDCh]
  char *v40; // [esp+40h] [ebp-FD8h]
  char *v41; // [esp+44h] [ebp-FD4h]
  size_t v42; // [esp+48h] [ebp-FD0h]
  size_t v43; // [esp+4Ch] [ebp-FCCh]
  void *ptr; // [esp+50h] [ebp-FC8h]
  size_t v45; // [esp+54h] [ebp-FC4h]
  int v46; // [esp+58h] [ebp-FC0h]
  int v47; // [esp+5Ch] [ebp-FBCh]
  unsigned int v48; // [esp+60h] [ebp-FB8h]
  size_t n; // [esp+64h] [ebp-FB4h]
  size_t size; // [esp+68h] [ebp-FB0h]
  char v51; // [esp+6Ch] [ebp-FACh]
  unsigned int v52; // [esp+100Ch] [ebp-Ch]

  v31 = a1;
  v30 = a2;
  v52 = __readgsdword(0x14u);
  v34 = dword_806D14B;
  s1 = *(void **)(a1 + 8);
  s2 = *(void **)(a2 + 8);
  v37 = *(char **)(a1 + 12);
  v38 = *(char **)(a2 + 12);
  v46 = *(_DWORD *)(dword_806D14B + 20);
  v47 = *(_DWORD *)(dword_806D14B + 16);
  v3 = (char *)s1;
  if ( v37 >= s1 )
    v3 = v37;
  v37 = v3;
  v4 = (char *)s2;
  if ( v38 >= s2 )
    v4 = v38;
  v38 = v4;
  v48 = v37 - (_BYTE *)s1;
  n = v4 - (_BYTE *)s2;
  if ( !byte_806CD1F
    && !(unsigned __int8)sub_804F2AD(v4 - (_BYTE *)s2, v2, (_BYTE *)v34)
    && !*(_BYTE *)(v34 + 30)
    && !*(_BYTE *)(v34 + 27) )
  {
    v5 = &loc_8050208;
    if ( !*(_BYTE *)(v34 + 32) )
      v5 = &loc_8050770;
    dword_806C248 = (int)v5;
    sub_8062696();
  }
  if ( !v47 )
  {
    v6 = &loc_8050233;
    if ( !v46 )
      v6 = &loc_80504A8;
    dword_806C358 = (int)v6;
    sub_8061FAB();
  }
  size = v48 + n + 2;
  if ( size <= 0xFA0 )
  {
    v40 = &v51;
    ptr = 0;
    dword_806C2D4 = (int)&loc_80502A3;
    sub_8062323();
  }
  ptr = sub_805EC7C(size);
  v40 = (char *)ptr;
  v41 = (char *)ptr + v48 + 1;
  v45 = 0;
  v42 = 0;
  dword_806C358 = (int)&loc_80503A1;
  sub_8061FAB();
  do
  {
    if ( !v47 || (v24 = *((char *)s1 + v45), v7 = sub_804B6F4(v24), *(_BYTE *)(v7 + v47) ^ 1) )
    {
      v8 = v42++;
      v23 = &v40[v8];
      v9 = &loc_805035B;
      if ( !v46 )
        v9 = &loc_8050387;
      dword_806C2FC = (int)v9;
      sub_806223F();
      v24 = *((char *)s1 + v45);
      v10 = sub_804B6F4(v24);
      *v23 = *(_BYTE *)(v10 + v46);
    }
    ++v45;
  }
  while ( v45 < v48 );
  v40[v42] = 0;
  v45 = 0;
  v43 = 0;
  while ( v45 < n )
  {
    if ( !v47 || (v24 = *((char *)s2 + v45), v11 = sub_804B6F4(v24), *(_BYTE *)(v11 + v47) ^ 1) )
    {
      v12 = v43++;
      v13 = &v41[v12];
      if ( v46 )
      {
        v24 = *((char *)s2 + v45);
        v14 = sub_804B6F4(v24);
        v15 = *(_BYTE *)(v14 + v46);
      }
      else
      {
        v15 = *((_BYTE *)s2 + v45);
      }
      *v13 = v15;
    }
    ++v45;
  }
  v41[v43] = 0;
  if ( *(_BYTE *)(v34 + 26) )
  {
    v39 = sub_804E4FD((unsigned __int8 *)v40, (unsigned __int8 *)v41);
  }
  else if ( *(_BYTE *)(v34 + 28) )
  {
    v39 = sub_804E63E((int)v40, (int)v41);
  }
  else if ( *(_BYTE *)(v34 + 29) )
  {
    v39 = sub_804E442((unsigned __int8 *)v40, v41);
  }
  else
  {
    v16 = &loc_80505E2;
    if ( !*(_BYTE *)(v34 + 30) )
      v16 = &loc_805061F;
    dword_806C358 = (int)v16;
    sub_8061FAB();
    v17 = sub_804E76A((unsigned __int8 *)v40, 0);
    v39 = v17 - sub_804E76A((unsigned __int8 *)v41, 0);
  }
  if ( !v47 )
  {
    v18 = &loc_805072A;
    if ( !v46 )
      v18 = &loc_805073D;
    dword_806C298 = (int)v18;
    sub_80624B3();
  }
  free(ptr);
  if ( !v39 )
  {
    v34 = *(_DWORD *)(v34 + 36);
    if ( !v34 )
      return 0;
    if ( *(_DWORD *)(v34 + 8) == -1 )
    {
      v37 = (char *)(*(_DWORD *)v31 + *(_DWORD *)(v31 + 4) - 1);
      v38 = (char *)(*(_DWORD *)v30 + *(_DWORD *)(v30 + 4) - 1);
    }
    else
    {
      v37 = sub_804DC73((char **)v31, v34);
      v38 = sub_804DC73((char **)v30, v34);
    }
    if ( *(_DWORD *)v34 == -1 )
    {
      s1 = *(void **)v31;
      s2 = *(void **)v30;
      if ( *(_BYTE *)(v34 + 24) )
      {
        while ( s1 < v37 )
        {
          v24 = *(char *)s1;
          if ( !byte_806CD37[(unsigned __int8)sub_804B6F4(v24)] )
            break;
          s1 = (char *)s1 + 1;
        }
        while ( s2 < v38 )
        {
          v24 = *(char *)s2;
          if ( !byte_806CD37[(unsigned __int8)sub_804B6F4(v24)] )
            break;
          s2 = (char *)s2 + 1;
        }
      }
    }
    else
    {
      s1 = sub_804DB0E((char **)v31, v34);
      s2 = sub_804DB0E((char **)v30, v34);
    }
    dword_806C358 = (int)&loc_805012C;
    sub_8061FAB();
  }
  v20 = &loc_8050E45;
  if ( !*(_BYTE *)(v34 + 31) )
    v20 = &loc_8050E64;
  dword_806C2E8 = (int)v20;
  sub_80622AD(v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, s1, s2, v37, v38, v39, v40, v41, v42);
  dword_806C234 = (int)&loc_8050E6A;
  sub_8062704(v22, v21);
  return v39;
}
// 8061FAB: using guessed type int sub_8061FAB(void);
// 806223F: using guessed type int sub_806223F(void);
// 80622AD: using guessed type int __stdcall sub_80622AD(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8062323: using guessed type int sub_8062323(void);
// 80624B3: using guessed type int sub_80624B3(void);
// 8062696: using guessed type int sub_8062696(void);
// 8062704: using guessed type int __fastcall sub_8062704(_DWORD, _DWORD);
// 806C234: using guessed type int dword_806C234;
// 806C248: using guessed type int dword_806C248;
// 806C298: using guessed type int dword_806C298;
// 806C2D4: using guessed type int dword_806C2D4;
// 806C2E8: using guessed type int dword_806C2E8;
// 806C2FC: using guessed type int dword_806C2FC;
// 806C358: using guessed type int dword_806C358;
// 806CD1F: using guessed type char byte_806CD1F;
// 806D14B: using guessed type int dword_806D14B;

//----- (08050E84) --------------------------------------------------------
int __cdecl sub_8050E84(int a1, int a2)
{
  int result; // eax
  unsigned int v3; // eax
  signed int v4; // eax
  int v5; // [esp+14h] [ebp-14h]
  unsigned int v6; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]

  if ( dword_806D14B )
  {
    v5 = sub_80500BE(a1, a2);
    if ( v5 || byte_806D149 || byte_806D148 )
      return v5;
  }
  v6 = *(_DWORD *)(a1 + 4) - 1;
  n = *(_DWORD *)(a2 + 4) - 1;
  if ( v6 )
  {
    if ( n )
    {
      if ( byte_806CD1F )
      {
        v5 = sub_805EFDF(*(void **)a1, v6 + 1, *(void **)a2, n + 1);
        dword_806C248 = (int)&loc_8050F42;
        sub_8062696();
      }
      v3 = v6;
      if ( n <= v6 )
        v3 = n;
      v5 = memcmp(*(const void **)a1, *(const void **)a2, v3);
      if ( !v5 )
      {
        if ( v6 < n )
          v4 = -1;
        else
          v4 = v6 != n;
        v5 = v4;
      }
    }
    else
    {
      v5 = 1;
    }
  }
  else
  {
    v5 = -(n != 0);
  }
  if ( byte_806D147 )
    result = -v5;
  else
    result = v5;
  return result;
}
// 8062696: using guessed type int sub_8062696(void);
// 806C248: using guessed type int dword_806C248;
// 806CD1F: using guessed type char byte_806CD1F;
// 806D147: using guessed type char byte_806D147;
// 806D148: using guessed type char byte_806D148;
// 806D149: using guessed type char byte_806D149;
// 806D14B: using guessed type int dword_806D14B;

//----- (08050FCE) --------------------------------------------------------
int __cdecl sub_8050FCE(int a1, FILE *stream, int a3)
{
  int v3; // ecx
  char *v4; // edx
  void *v5; // eax
  char *v6; // eax
  char *v7; // eax
  int result; // eax
  char *v9; // eax
  char v10; // [esp+1Fh] [ebp-19h]
  char *v11; // [esp+20h] [ebp-18h]
  char *ptr; // [esp+24h] [ebp-14h]
  size_t n; // [esp+28h] [ebp-10h]
  unsigned int v14; // [esp+2Ch] [ebp-Ch]

  ptr = *(char **)a1;
  n = *(_DWORD *)(a1 + 4);
  v4 = *(char **)a1;
  v14 = *(_DWORD *)a1 + n;
  v5 = &loc_805100F;
  if ( a3 )
    v5 = &loc_80510AA;
  dword_806C234 = (int)v5;
  sub_8062704(v3, v4);
  if ( byte_806D153 )
  {
    v11 = ptr;
    while ( (unsigned int)v11 < v14 )
    {
      v6 = v11++;
      v10 = *v6;
      if ( *v6 == 9 )
      {
        v10 = 62;
      }
      else if ( v11 == (char *)v14 )
      {
        v10 = 10;
      }
      if ( fputc_unlocked(v10, stream) == -1 )
      {
        v7 = gettext("write failed");
        sub_804BA80((int)v7, a3);
      }
    }
    result = sub_804F5CA(a1);
  }
  else
  {
    *(_BYTE *)(v14 - 1) = byte_806C38C;
    if ( fwrite_unlocked(ptr, 1u, n, stream) != n )
    {
      v9 = gettext("write failed");
      sub_804BA80((int)v9, a3);
    }
    result = v14 - 1;
    *(_BYTE *)(v14 - 1) = 0;
  }
  return result;
}
// 8062704: using guessed type int __fastcall sub_8062704(_DWORD, _DWORD);
// 806C234: using guessed type int dword_806C234;
// 806C38C: using guessed type char byte_806C38C;
// 806D153: using guessed type char byte_806D153;

//----- (08051110) --------------------------------------------------------
signed int __usercall sub_8051110@<eax>(double a1@<st0>, char *a2)
{
  size_t v2; // eax
  bool v3; // zf
  int v4; // edx
  int v5; // ecx
  void *v6; // eax
  FILE *stream; // [esp+38h] [ebp-80h]
  void *ptr; // [esp+68h] [ebp-50h]
  unsigned int v10; // [esp+9Ch] [ebp-1Ch]

  v10 = __readgsdword(0x14u);
  stream = sub_804C5A3(a1, a2, "r");
  v2 = dword_806C40C;
  if ( size >= dword_806C40C )
    v2 = size;
  sub_804DA6D((int)&ptr, 16, v2);
  v3 = (unsigned __int8)sub_804DE26((int)&ptr, stream, (int)a2) == 0;
  v6 = &loc_805145E;
  if ( !v3 )
    v6 = &loc_80511CE;
  dword_806C338 = (int)v6;
  sub_80620D8(v5, v4);
  sub_804C609(a1, stream, (int)a2);
  free(ptr);
  free(0);
  return 1;
}
// 80620D8: using guessed type int __fastcall sub_80620D8(_DWORD, _DWORD);
// 806C338: using guessed type int dword_806C338;
// 806D149: using guessed type char byte_806D149;
// 806D14B: using guessed type int dword_806D14B;

//----- (080514AC) --------------------------------------------------------
unsigned int __usercall sub_80514AC@<eax>(double a1@<st0>, int a2, unsigned int a3, void **a4)
{
  FILE **v4; // ebx
  FILE *v5; // eax
  void *v6; // eax
  int v7; // edx
  int v8; // ecx
  int v10; // [esp+0h] [ebp-28h]
  unsigned int i; // [esp+18h] [ebp-10h]
  _DWORD *v12; // [esp+1Ch] [ebp-Ch]

  *a4 = sub_805EB56(a3, 4u);
  v12 = *a4;
  for ( i = 0; i < a3; ++i )
  {
    v4 = (FILE **)&v12[i];
    if ( *(_DWORD *)(8 * i + a2 + 4) && *(_BYTE *)(*(_DWORD *)(8 * i + a2 + 4) + 8) )
    {
      v10 = *(_DWORD *)(8 * i + a2 + 4);
      v5 = (FILE *)sub_804CA21(v10);
    }
    else
    {
      v5 = sub_804C43E(a1, *(char **)(8 * i + a2), "r");
    }
    *v4 = v5;
    v6 = &loc_805158E;
    if ( v12[i] )
      v6 = &loc_80515A5;
    dword_806C248 = (int)v6;
    sub_8062696();
    dword_806C338 = (int)&loc_80515B5;
    sub_80620D8(v8, v7);
  }
  return i;
}
// 80620D8: using guessed type int __fastcall sub_80620D8(_DWORD, _DWORD);
// 8062696: using guessed type int sub_8062696(void);
// 806C248: using guessed type int dword_806C248;
// 806C338: using guessed type int dword_806C338;

//----- (080515BE) --------------------------------------------------------
void __usercall sub_80515BE(double a1@<st0>, int a2, int a3, int a4, FILE *stream, int a6, void *a7)
{
  unsigned int *v7; // edx
  int v8; // ecx
  size_t v9; // edx
  int v10; // eax
  _DWORD *v11; // ecx
  _DWORD *v12; // eax
  int v13; // edx
  unsigned int v14; // ST50_4
  int v15; // ecx
  int v16; // edx
  void *v17; // eax
  int v18; // eax
  _DWORD *v19; // ecx
  _DWORD *v20; // eax
  int v21; // edx
  _DWORD *v22; // eax
  _DWORD *v23; // edx
  void **v24; // [esp+14h] [ebp-64h]
  size_t size; // [esp+18h] [ebp-60h]
  unsigned int v26; // [esp+1Ch] [ebp-5Ch]
  unsigned int j; // [esp+1Ch] [ebp-5Ch]
  unsigned int k; // [esp+1Ch] [ebp-5Ch]
  unsigned int m; // [esp+1Ch] [ebp-5Ch]
  unsigned int ii; // [esp+1Ch] [ebp-5Ch]
  unsigned int jj; // [esp+1Ch] [ebp-5Ch]
  unsigned int i; // [esp+20h] [ebp-58h]
  unsigned int l; // [esp+20h] [ebp-58h]
  unsigned int v34; // [esp+24h] [ebp-54h]
  unsigned int v35; // [esp+28h] [ebp-50h]
  unsigned int v36; // [esp+2Ch] [ebp-4Ch]
  _DWORD *v37; // [esp+30h] [ebp-48h]
  _DWORD *v38; // [esp+34h] [ebp-44h]
  _DWORD *v39; // [esp+38h] [ebp-40h]
  unsigned int *v40; // [esp+3Ch] [ebp-3Ch]
  int v41; // [esp+40h] [ebp-38h]
  unsigned int v42; // [esp+4Ch] [ebp-2Ch]
  signed __int64 v43; // [esp+54h] [ebp-24h]
  unsigned int v44; // [esp+5Ch] [ebp-1Ch]
  void *ptr; // [esp+60h] [ebp-18h]
  size_t n; // [esp+64h] [ebp-14h]
  char *v47; // [esp+68h] [ebp-10h]
  char *v48; // [esp+6Ch] [ebp-Ch]

  v37 = sub_805EB56(a4, 0x1Cu);
  v24 = 0;
  size = 0;
  v38 = sub_805EB56(a4, 4u);
  v39 = sub_805EB56(a4, 4u);
  v40 = (unsigned int *)sub_805EB56(a4, 4u);
  v41 = dword_806D14B;
  ptr = 0;
  v26 = 0;
  while ( v26 < a4 )
  {
    v9 = ::size / a4;
    if ( ::size / a4 < dword_806C40C )
      v9 = dword_806C40C;
    sub_804DA6D((int)&v37[7 * v26], 16, v9);
    if ( (unsigned __int8)sub_804DE26((int)&v37[7 * v26], *((FILE **)a7 + v26), *(_DWORD *)(8 * v26 + a2)) )
    {
      v10 = sub_804DAF3(&v37[7 * v26]);
      v38[v26] = v10 - 16;
      v7 = &v39[v26];
      v8 = -16 * v37[7 * v26 + 2];
      *v7 = v8 + v10;
      ++v26;
    }
    else
    {
      sub_804C609(a1, *((FILE **)a7 + v26), *(_DWORD *)(8 * v26 + a2));
      if ( v26 < a3 )
        sub_804CCA8(*(char **)(8 * v26 + a2));
      free((void *)v37[7 * v26]);
      --a4;
      for ( i = v26; i < a4; ++i )
      {
        v11 = (_DWORD *)(8 * i + a2);
        v12 = (_DWORD *)(8 * (i + 1) + a2);
        v13 = v12[1];
        *v11 = *v12;
        v11[1] = v13;
        v7 = (unsigned int *)((char *)a7 + 4 * i);
        v8 = 4 * (i + 1);
        *v7 = *(_DWORD *)((char *)a7 + v8);
      }
    }
  }
  for ( j = 0; j < a4; ++j )
  {
    v7 = &v40[j];
    *v7 = j;
  }
  for ( k = 1; k < a4; ++k )
  {
    if ( sub_8050E84(v38[v40[k + 0x3FFFFFFF]], v38[v40[k]]) > 0 )
    {
      v14 = v40[k + 0x3FFFFFFF];
      v8 = 4 * k;
      v40[k + 0x3FFFFFFF] = v40[k];
      v7 = &v40[k];
      *v7 = v14;
      k = 0;
    }
  }
  dword_806C324 = (int)&loc_8051F00;
  sub_8062148(v8, v7);
  do
  {
    v16 = *v40;
    v42 = v38[v16];
    v17 = &loc_8051990;
    if ( !byte_806D149 )
      v17 = &loc_8051A7D;
    dword_806C284 = (int)v17;
    sub_806253E(v15, v16 * 4);
    if ( v24 && sub_8050E84((int)v24, v42) )
    {
      v24 = 0;
      sub_8050FCE((int)&ptr, stream, a6);
    }
    if ( !v24 )
    {
      v24 = &ptr;
      if ( *(_DWORD *)(v42 + 4) > size )
      {
        while ( size )
        {
          size *= 2;
          if ( size >= *(_DWORD *)(v42 + 4) )
            goto LABEL_31;
        }
        size = *(_DWORD *)(v42 + 4);
LABEL_31:
        free(ptr);
        ptr = sub_805EC7C(size);
      }
      n = *(_DWORD *)(v42 + 4);
      memcpy(ptr, *(const void **)v42, n);
      if ( v41 )
      {
        v47 = (char *)ptr + *(_DWORD *)(v42 + 8) - *(_DWORD *)v42;
        v15 = *(_DWORD *)(v42 + 12) - *(_DWORD *)v42;
        v48 = (char *)ptr + v15;
      }
    }
    if ( v39[*v40] < v42 )
    {
      v38[*v40] = v42 - 16;
      goto LABEL_52;
    }
    if ( (unsigned __int8)sub_804DE26((int)&v37[7 * *v40], *((FILE **)a7 + *v40), *(_DWORD *)(8 * *v40 + a2)) )
    {
      v18 = sub_804DAF3(&v37[7 * *v40]);
      v38[*v40] = v18 - 16;
      v15 = -16 * v37[7 * *v40 + 2];
      v39[*v40] = v15 + v18;
LABEL_52:
      v34 = 1;
      v35 = a4;
      v36 = 1;
      LODWORD(v43) = *v40;
      while ( v34 < v35 )
      {
        HIDWORD(v43) = sub_8050E84(v38[(_DWORD)v43], v38[v40[v36]]);
        if ( v43 >= v40[v36] )
          v34 = v36 + 1;
        else
          v35 = v36;
        v36 = (v34 + v35) >> 1;
      }
      v44 = v34 - 1;
      for ( l = 0; l < v44; ++l )
      {
        v15 = 4 * (l + 1);
        v40[l] = *(unsigned int *)((char *)v40 + v15);
      }
      v40[v44] = v43;
      continue;
    }
    for ( m = 1; m < a4; ++m )
    {
      if ( v40[m] > *v40 )
        --v40[m];
    }
    --a4;
    sub_804C609(a1, *((FILE **)a7 + *v40), *(_DWORD *)(8 * *v40 + a2));
    if ( *v40 < a3 )
      sub_804CCA8(*(char **)(8 * *v40 + a2));
    free((void *)v37[7 * *v40]);
    for ( ii = *v40; ii < a4; ++ii )
    {
      *((_DWORD *)a7 + ii) = *((_DWORD *)a7 + ii + 1);
      v19 = (_DWORD *)(8 * ii + a2);
      v20 = (_DWORD *)(8 * (ii + 1) + a2);
      v21 = v20[1];
      *v19 = *v20;
      v19[1] = v21;
      v22 = &v37[7 * ii];
      v23 = &v37[7 * (ii + 1)];
      *v22 = *v23;
      v22[1] = v23[1];
      v22[2] = v23[2];
      v22[3] = v23[3];
      v22[4] = v23[4];
      v22[5] = v23[5];
      v22[6] = v23[6];
      v38[ii] = v38[ii + 1];
      v15 = 4 * (ii + 1);
      v39[ii] = *(_DWORD *)((char *)v39 + v15);
    }
    for ( jj = 0; jj < a4; ++jj )
    {
      v15 = 4 * (jj + 1);
      v40[jj] = *(unsigned int *)((char *)v40 + v15);
    }
  }
  while ( a4 );
  if ( byte_806D149 && v24 )
  {
    sub_8050FCE((int)&ptr, stream, a6);
    free(ptr);
  }
  sub_804C609(a1, stream, a6);
  free(a7);
  free(v37);
  free(v40);
  free(v39);
  free(v38);
}
// 8062148: using guessed type int __fastcall sub_8062148(_DWORD, _DWORD);
// 806253E: using guessed type int __fastcall sub_806253E(_DWORD, _DWORD);
// 806C284: using guessed type int dword_806C284;
// 806C324: using guessed type int dword_806C324;
// 806D149: using guessed type char byte_806D149;
// 806D14B: using guessed type int dword_806D14B;

//----- (08051F8E) --------------------------------------------------------
int __usercall sub_8051F8E@<eax>(double a1@<st0>, int a2, int a3, int a4, FILE *stream, int a6)
{
  int v6; // ebx
  char *v7; // eax
  void *v9; // [esp+28h] [ebp-10h]
  int v10; // [esp+2Ch] [ebp-Ch]

  v10 = sub_80514AC(a1, a2, a4, &v9);
  if ( v10 < (unsigned int)a4 && (unsigned int)v10 <= 1 )
  {
    v6 = *(_DWORD *)(8 * v10 + a2);
    v7 = gettext("open failed");
    sub_804BA80((int)v7, v6);
  }
  sub_80515BE(a1, a2, a3, v10, stream, a6, v9);
  return v10;
}

//----- (0805201F) --------------------------------------------------------
int __cdecl sub_805201F(int a1, unsigned int a2, int a3)
{
  int v3; // eax
  bool v4; // zf
  bool v5; // sf
  void *v6; // eax
  void *v7; // eax
  int v8; // edx
  int v9; // ecx
  int v10; // ecx
  int v11; // edx
  int v12; // ecx
  int v13; // edx
  int v15; // [esp+14h] [ebp-14h]
  int v16; // [esp+1Ch] [ebp-Ch]
  _DWORD *v17; // [esp+30h] [ebp+8h]
  _DWORD *v18; // [esp+30h] [ebp+8h]
  _DWORD *v19; // [esp+38h] [ebp+10h]

  v16 = -16 * (a2 >> 1) + a1;
  v3 = sub_8050E84(a3 - 16, v16 - 16);
  v4 = v3 == 0;
  v5 = v3 < 0;
  v6 = &loc_8052081;
  if ( !v5 && !v4 )
    v6 = &loc_80520DF;
  dword_806C2AC = (int)v6;
  sub_8062420();
  v17 = (_DWORD *)(a1 - 16);
  v19 = (_DWORD *)(a3 - 16);
  *v17 = *v19;
  v17[1] = v19[1];
  v17[2] = v19[2];
  v17[3] = v19[3];
  v15 = (a2 >> 1) - 1;
  v7 = &loc_80520C8;
  if ( a2 >> 1 != 1 )
    v7 = &loc_8052152;
  dword_806C2FC = (int)v7;
  sub_806223F();
  dword_806C270 = (int)&locret_8052169;
  sub_80625B6(v9, v8);
  v18 = v17 - 4;
  *v18 = *(_DWORD *)(v16 - 16);
  v18[1] = *(_DWORD *)(v16 - 16 + 4);
  v10 = *(_DWORD *)(v16 - 16 + 8);
  v18[2] = v10;
  v11 = *(_DWORD *)(v16 - 16 + 12);
  v18[3] = v11;
  if ( a2 - (a2 >> 1) == 1 )
  {
    do
    {
      v18 -= 4;
      v19 -= 4;
      *v18 = *v19;
      v18[1] = v19[1];
      v12 = v19[2];
      v18[2] = v12;
      v13 = v19[3];
      v18[3] = v13;
      --v15;
    }
    while ( v15 );
    dword_806C324 = (int)&locret_8052169;
    sub_8062148(v12, v13);
  }
  dword_806C324 = (int)&loc_805204C;
  return sub_8062148(v10, v11);
}
// 805201F: could not find valid save-restore pair for ebx
// 8062148: using guessed type int __fastcall sub_8062148(_DWORD, _DWORD);
// 806223F: using guessed type int sub_806223F(void);
// 8062420: using guessed type int sub_8062420(void);
// 80625B6: using guessed type int __fastcall sub_80625B6(_DWORD, _DWORD);
// 806C270: using guessed type int dword_806C270;
// 806C2AC: using guessed type int dword_806C2AC;
// 806C2FC: using guessed type int dword_806C2FC;
// 806C324: using guessed type int dword_806C324;

//----- (0805216B) --------------------------------------------------------
_DWORD *__usercall sub_805216B@<eax>(int a1@<ecx>, double a2@<st0>, int a3, unsigned int a4, int a5, unsigned __int8 a6)
{
  _DWORD *v6; // eax
  _DWORD *v7; // edx
  _DWORD *result; // eax
  int v9; // ecx
  void *v10; // eax
  void *v11; // eax
  int v12; // edx
  int v13; // edx
  int v14; // ecx
  _DWORD *v15; // edx
  int v16; // eax
  void *v17; // eax
  _DWORD *v18; // edx
  _DWORD *v19; // edx
  _DWORD *v20; // edx
  unsigned __int8 v21; // [esp+1Ch] [ebp-2Ch]
  int v22; // [esp+2Ch] [ebp-1Ch]
  unsigned int v23; // [esp+30h] [ebp-18h]
  unsigned int v24; // [esp+34h] [ebp-14h]
  int v25; // [esp+38h] [ebp-10h]
  unsigned int v26; // [esp+3Ch] [ebp-Ch]

  v21 = a6;
  if ( a4 == 2 )
  {
    v22 = sub_8050E84(a3 - 16, a3 - 32) > 0;
    if ( v21 )
    {
      v6 = (_DWORD *)(a5 - 16);
      v7 = (_DWORD *)(16 * ~v22 + a3);
      *v6 = *v7;
      v6[1] = v7[1];
      v6[2] = v7[2];
      v6[3] = v7[3];
      result = (_DWORD *)(a5 - 32);
      v9 = 16 * (v22 - 2);
      *result = *(_DWORD *)(v9 + a3);
      result[1] = *(_DWORD *)(v9 + a3 + 4);
      result[2] = *(_DWORD *)(v9 + a3 + 8);
      result[3] = *(_DWORD *)(v9 + a3 + 12);
    }
    else
    {
      v10 = &loc_8052225;
      if ( !v22 )
        v10 = &loc_80522C6;
      dword_806C25C = (int)v10;
      sub_8062626(a2);
      v18 = (_DWORD *)(a5 - 16);
      *v18 = *(_DWORD *)(a3 - 16);
      v18[1] = *(_DWORD *)(a3 - 12);
      v18[2] = *(_DWORD *)(a3 - 8);
      v18[3] = *(_DWORD *)(a3 - 4);
      v19 = (_DWORD *)(a3 - 16);
      *v19 = *(_DWORD *)(a3 - 32);
      v19[1] = *(_DWORD *)(a3 - 28);
      v19[2] = *(_DWORD *)(a3 - 24);
      v19[3] = *(_DWORD *)(a3 - 20);
      v20 = (_DWORD *)(a3 - 32);
      *v20 = *(_DWORD *)(a5 - 16);
      v20[1] = *(_DWORD *)(a5 - 12);
      v20[2] = *(_DWORD *)(a5 - 8);
      result = *(_DWORD **)(a5 - 4);
      v20[3] = result;
    }
  }
  else
  {
    v23 = a4 >> 1;
    v24 = a4 - (a4 >> 1);
    v25 = a3;
    v26 = -16 * (a4 >> 1) + a3;
    v11 = &loc_805231B;
    if ( !v21 )
      v11 = &loc_8052325;
    dword_806C284 = (int)v11;
    sub_806253E(a1, v21);
    sub_805216B(v26, v24, a5 - 16 * v23, v12);
    if ( v23 > 1 )
    {
      sub_805216B(v25, v23, a5, v21 == 0);
      dword_806C338 = (int)&loc_80523C3;
      sub_80620D8(v14, v13);
    }
    if ( v21 != 1 )
    {
      v15 = (_DWORD *)(a5 - 16);
      v16 = v25;
      *v15 = *(_DWORD *)(v25 - 16);
      v15[1] = *(_DWORD *)(v16 - 12);
      v15[2] = *(_DWORD *)(v16 - 8);
      v15[3] = *(_DWORD *)(v16 - 4);
    }
    v17 = &loc_80523E2;
    if ( !v21 )
      v17 = &loc_805244E;
    dword_806C220 = (int)v17;
    sub_806277E();
    result = (_DWORD *)sub_805201F(a5, a4, a3);
  }
  return result;
}
// 805216B: could not find valid save-restore pair for ebx
// 80620D8: using guessed type int __fastcall sub_80620D8(_DWORD, _DWORD);
// 806253E: using guessed type int __fastcall sub_806253E(_DWORD, _DWORD);
// 8062626: using guessed type int __usercall sub_8062626@<eax>(double@<st0>);
// 806277E: using guessed type int sub_806277E(void);
// 806C220: using guessed type int dword_806C220;
// 806C25C: using guessed type int dword_806C25C;
// 806C284: using guessed type int dword_806C284;
// 806C338: using guessed type int dword_806C338;

//----- (08052475) --------------------------------------------------------
pthread_mutex_t *__cdecl sub_8052475(unsigned int a1, int a2, int a3)
{
  pthread_mutex_t *v3; // eax
  pthread_mutex_t *v4; // ST28_4
  pthread_mutex_t *v5; // ST2C_4

  v3 = (pthread_mutex_t *)sub_805EC7C(144 * a1);
  v4 = v3;
  v5 = v3;
  v3->__kind = 0;
  v5->__owner = v5->__kind;
  v5->__count = v5->__owner;
  v5->__lock = v5->__count;
  v3->__nusers = 0;
  v3[1].__lock = a2;
  v3->__spins = v3[1].__lock;
  v3[1].__count = 0;
  v3[1].__nusers = 0;
  v3[1].__size[20] = 0;
  pthread_mutex_init(v3 + 2, 0);
  sub_80525A8(v5, v5 + 3, a3, a1, a2, 0);
  return v4;
}

//----- (080525A8) --------------------------------------------------------
int __cdecl sub_80525A8(_DWORD *a1, pthread_mutex_t *a2, int a3, unsigned int a4, int a5, char a6)
{
  unsigned int v6; // eax
  int v7; // eax
  int v8; // ST40_4
  pthread_mutex_t *v9; // eax
  int v10; // eax
  int v12; // [esp+30h] [ebp-28h]
  int v13; // [esp+34h] [ebp-24h]
  int v14; // [esp+38h] [ebp-20h]
  int v15; // [esp+3Ch] [ebp-1Ch]
  pthread_mutex_t *v16; // [esp+44h] [ebp-14h]
  int v17; // [esp+64h] [ebp+Ch]

  if ( a6 )
    v6 = a1[5];
  else
    v6 = a1[6];
  v12 = v6 >> 1;
  v13 = v6 - (v6 >> 1);
  v14 = -16 * a5 + a3;
  v15 = -16 * (v6 >> 1) + v14;
  if ( a6 )
    v7 = (int)(a1 + 2);
  else
    v7 = (int)(a1 + 3);
  v8 = v7;
  v9 = a2;
  v17 = (int)&a2[3];
  v16 = v9;
  v9->__owner = v14;
  v16->__lock = v16->__owner;
  v9->__kind = v15;
  v16->__count = v16->__kind;
  v9->__nusers = v8;
  v9->__spins = v12;
  v9[1].__lock = v13;
  v9[1].__count = (unsigned int)a1;
  v9[1].__nusers = a1[10] + 1;
  v9[1].__size[20] = 0;
  pthread_mutex_init(v9 + 2, 0);
  if ( a4 <= 1 )
  {
    v16[1].__owner = 0;
    v16[1].__kind = 0;
  }
  else
  {
    v16[1].__owner = v17;
    v10 = sub_80525A8(v16, v17, v14, a4 >> 1, a5, 1);
    v16[1].__kind = v10;
    v17 = sub_80525A8(v16, v10, v15, a4 - (a4 >> 1), a5, 0);
  }
  return v17;
}

//----- (08052750) --------------------------------------------------------
_BOOL4 __cdecl sub_8052750(_DWORD *a1, _DWORD *a2)
{
  int v2; // ecx
  int v3; // eax
  _DWORD *v5; // [esp+8h] [ebp-8h]
  _DWORD *v6; // [esp+Ch] [ebp-4h]

  v5 = a1;
  v6 = a2;
  if ( a1[10] == a2[10] )
  {
    v2 = v5[5] + v5[6];
    v3 = v6[5] + v6[6];
    dword_806C358 = (int)&locret_80527C2;
    sub_8061FAB();
  }
  return v5[10] < v6[10];
}
// 8061FAB: using guessed type int sub_8061FAB(void);
// 806C358: using guessed type int dword_806C358;

//----- (080527C4) --------------------------------------------------------
int __cdecl sub_80527C4(pthread_mutex_t *a1)
{
  return pthread_mutex_lock(a1 + 2);
}

//----- (080527DA) --------------------------------------------------------
int __cdecl sub_80527DA(pthread_mutex_t *a1)
{
  return pthread_mutex_unlock(a1 + 2);
}

//----- (08052821) --------------------------------------------------------
int __cdecl sub_8052821(int a1, int a2)
{
  *(_DWORD *)a1 = sub_80594AF(sub_8052750, 2 * a2);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 4), 0);
  return pthread_cond_init((pthread_cond_t *)(a1 + 28), 0);
}

//----- (08052887) --------------------------------------------------------
int __cdecl sub_8052887(int a1, int a2)
{
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 4));
  sub_8059562(*(_DWORD *)a1, a2);
  *(_BYTE *)(a2 + 44) = 1;
  pthread_cond_signal((pthread_cond_t *)(a1 + 28));
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 4));
}

//----- (080528D4) --------------------------------------------------------
pthread_mutex_t *__usercall sub_80528D4@<eax>(double a1@<st0>, int a2)
{
  pthread_mutex_t *v3; // [esp+1Ch] [ebp-Ch]

  pthread_mutex_lock((pthread_mutex_t *)(a2 + 4));
  while ( 1 )
  {
    v3 = (pthread_mutex_t *)sub_8059669(a1, *(int **)a2);
    if ( v3 )
      break;
    pthread_cond_wait((pthread_cond_t *)(a2 + 28), (pthread_mutex_t *)(a2 + 4));
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a2 + 4));
  sub_80527C4(v3);
  v3[1].__size[20] = 0;
  return v3;
}

//----- (0805293D) --------------------------------------------------------
int __usercall sub_805293D@<eax>(int a1@<edx>, int a2@<ecx>, int a3, FILE *stream, int a5)
{
  void *v5; // eax
  int v6; // edx
  int v7; // ecx

  v5 = &loc_8052967;
  if ( !byte_806D149 )
    v5 = &loc_80529C3;
  dword_806C284 = (int)v5;
  sub_806253E(a2, a1);
  if ( dword_806CD23 && !sub_8050E84(a3, (int)&dword_806CD23) )
  {
    dword_806C234 = (int)&locret_80529DC;
    sub_8062704(v7, v6);
  }
  dword_806CD23 = *(_DWORD *)a3;
  dword_806CD27 = *(_DWORD *)(a3 + 4);
  dword_806CD2B = *(_DWORD *)(a3 + 8);
  dword_806CD2F = *(_DWORD *)(a3 + 12);
  return sub_8050FCE(a3, stream, a5);
}
// 806253E: using guessed type int __fastcall sub_806253E(_DWORD, _DWORD);
// 8062704: using guessed type int __fastcall sub_8062704(_DWORD, _DWORD);
// 806C234: using guessed type int dword_806C234;
// 806C284: using guessed type int dword_806C284;
// 806CD23: using guessed type int dword_806CD23;
// 806CD27: using guessed type int dword_806CD27;
// 806CD2B: using guessed type int dword_806CD2B;
// 806CD2F: using guessed type int dword_806CD2F;
// 806D149: using guessed type char byte_806D149;

//----- (080529DE) --------------------------------------------------------
int __cdecl sub_80529DE(int a1, int a2, FILE *stream, int a4)
{
  int v4; // ecx
  int v5; // eax
  _DWORD *v6; // edx
  _DWORD *v7; // eax
  int v8; // edx
  int v9; // eax
  _DWORD *v10; // edx
  _DWORD *v11; // eax
  int v12; // eax
  _DWORD *v13; // edx
  _DWORD *v14; // eax
  int v15; // edx
  void *v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // eax
  bool v20; // zf
  bool v21; // sf
  void *v22; // eax
  int v23; // ecx
  void *v24; // eax
  int v25; // ecx
  int v26; // eax
  int v27; // eax
  void *v28; // eax
  int v29; // ecx
  int result; // eax
  int v31; // [esp+4h] [ebp-34h]
  unsigned int v32; // [esp+18h] [ebp-20h]
  _DWORD *v33; // [esp+1Ch] [ebp-1Ch]
  _DWORD *v34; // [esp+20h] [ebp-18h]
  int v35; // [esp+24h] [ebp-14h]
  int v36; // [esp+28h] [ebp-10h]
  int v37; // [esp+2Ch] [ebp-Ch]

  v34 = *(_DWORD **)a1;
  v35 = *(_DWORD *)(a1 + 4);
  v4 = 2 * (*(_DWORD *)(a1 + 40) + 1);
  v32 = ((unsigned int)a2 >> v4) + 1;
  if ( *(_DWORD *)(a1 + 40) <= 1u )
    goto LABEL_29;
  v33 = **(_DWORD ***)(a1 + 16);
LABEL_7:
  if ( *(_DWORD *)a1 == *(_DWORD *)(a1 + 8) || *(_DWORD *)(a1 + 4) == *(_DWORD *)(a1 + 12) )
    goto LABEL_12;
  while ( 1 )
  {
    v9 = v32--;
    if ( v9 )
    {
      v5 = *(_DWORD *)a1 - 16;
      v31 = *(_DWORD *)(a1 + 4) - 16;
      if ( sub_8050E84(v5, v31) > 0 )
      {
        v33 -= 4;
        *(_DWORD *)(a1 + 4) -= 16;
        v6 = *(_DWORD **)(a1 + 4);
        v7 = v33;
        *v33 = *v6;
      }
      else
      {
        v33 -= 4;
        *(_DWORD *)a1 -= 16;
        v6 = *(_DWORD **)a1;
        v7 = v33;
        *v33 = **(_DWORD **)a1;
      }
      v7[1] = v6[1];
      v4 = v6[2];
      v7[2] = v4;
      v7[3] = v6[3];
      goto LABEL_7;
    }
LABEL_12:
    v36 = ((signed int)v34 - *(_DWORD *)a1) >> 4;
    v37 = (v35 - *(_DWORD *)(a1 + 4)) >> 4;
    if ( *(_DWORD *)(a1 + 24) == v37 )
    {
      while ( *(_DWORD *)a1 != *(_DWORD *)(a1 + 8) )
      {
        v12 = v32--;
        if ( !v12 )
          break;
        v33 -= 4;
        *(_DWORD *)a1 -= 16;
        v10 = *(_DWORD **)a1;
        v11 = v33;
        *v33 = **(_DWORD **)a1;
        v11[1] = v10[1];
        v11[2] = v10[2];
        v11[3] = v10[3];
      }
    }
    else if ( *(_DWORD *)(a1 + 20) == v36 )
    {
      while ( 1 )
      {
        v15 = *(_DWORD *)(a1 + 4);
        v16 = &loc_8052BED;
        if ( v15 == *(_DWORD *)(a1 + 12) )
          v16 = &loc_8052BFA;
        dword_806C310 = (int)v16;
        sub_80621CD(v4, v15);
        v17 = v32--;
        if ( !v17 )
          break;
        v33 -= 4;
        *(_DWORD *)(a1 + 4) -= 16;
        v13 = *(_DWORD **)(a1 + 4);
        v14 = v33;
        *v33 = *v13;
        v14[1] = v13[1];
        v4 = v13[2];
        v14[2] = v4;
        v14[3] = v13[3];
      }
    }
    **(_DWORD **)(a1 + 16) = v33;
    dword_806C2D4 = (int)&loc_8052E10;
    sub_8062323();
    while ( 1 )
    {
LABEL_29:
      v24 = &loc_8052CD8;
      if ( *(_DWORD *)a1 == *(_DWORD *)(a1 + 8) )
        v24 = &loc_8052CF9;
      dword_806C358 = (int)v24;
      sub_8061FAB();
      if ( *(_DWORD *)(a1 + 4) == *(_DWORD *)(a1 + 12) )
        break;
      v26 = v32--;
      if ( !v26 )
        break;
      v18 = *(_DWORD *)a1 - 16;
      v31 = *(_DWORD *)(a1 + 4) - 16;
      v19 = sub_8050E84(v18, v31);
      v20 = v19 == 0;
      v21 = v19 < 0;
      v22 = &loc_8052C5B;
      if ( !v21 && !v20 )
        v22 = &loc_8052C85;
      dword_806C2C0 = (int)v22;
      sub_806239B();
      *(_DWORD *)a1 -= 16;
      sub_805293D((int)stream, v23, *(_DWORD *)a1, stream, a4);
    }
    v36 = ((signed int)v34 - *(_DWORD *)a1) >> 4;
    v37 = (v35 - *(_DWORD *)(a1 + 4)) >> 4;
    if ( *(_DWORD *)(a1 + 24) == v37 )
      break;
    v28 = &loc_8052D9C;
    if ( *(_DWORD *)(a1 + 20) != v36 )
      v28 = &loc_8052E10;
    dword_806C2C0 = (int)v28;
    sub_806239B();
    v8 = *(_DWORD *)(a1 + 4);
    if ( v8 == *(_DWORD *)(a1 + 12) )
      goto LABEL_44;
    dword_806C310 = (int)&loc_8052DEA;
    sub_80621CD(v29, v8);
  }
  while ( *(_DWORD *)a1 != *(_DWORD *)(a1 + 8) )
  {
    v27 = v32--;
    if ( !v27 )
      break;
    *(_DWORD *)a1 -= 16;
    sub_805293D((int)stream, v25, *(_DWORD *)a1, stream, a4);
  }
LABEL_44:
  v36 = ((signed int)v34 - *(_DWORD *)a1) >> 4;
  v37 = (v35 - *(_DWORD *)(a1 + 4)) >> 4;
  *(_DWORD *)(a1 + 20) -= v36;
  result = a1;
  *(_DWORD *)(a1 + 24) -= v37;
  return result;
}
// 80529DE: could not find valid save-restore pair for ebx
// 8061FAB: using guessed type int sub_8061FAB(void);
// 80621CD: using guessed type int __fastcall sub_80621CD(_DWORD, _DWORD);
// 8062323: using guessed type int sub_8062323(void);
// 806C2C0: using guessed type int dword_806C2C0;
// 806C2D4: using guessed type int dword_806C2D4;
// 806C310: using guessed type int dword_806C310;
// 806C358: using guessed type int dword_806C358;

//----- (08052E59) --------------------------------------------------------
int __cdecl sub_8052E59(int a1, int a2)
{
  int v2; // ecx
  int result; // eax
  int v4; // edx
  char v5; // al
  bool v6; // [esp+1Fh] [ebp-9h]

  result = *(unsigned __int8 *)(a2 + 44) ^ 1;
  if ( *(_BYTE *)(a2 + 44) != 1 )
  {
    v4 = *(_DWORD *)(a2 + 4) - *(_DWORD *)(a2 + 12);
    v6 = (unsigned int)(v4 + 15) > 0x1E;
    if ( (unsigned int)(*(_DWORD *)a2 - *(_DWORD *)(a2 + 8) + 15) > 0x1E )
    {
      if ( v6 || !*(_DWORD *)(a2 + 24) )
      {
        dword_806C20C = (int)&loc_8052F21;
        sub_80627EE(v2, v4);
      }
      dword_806C20C = (int)&loc_8052F21;
      v5 = sub_80627EE(v2, v4);
    }
    else
    {
      v5 = v6 && !*(_DWORD *)(a2 + 20);
    }
    result = v5 & 1;
    if ( (_BYTE)result )
      result = sub_8052887(a1, a2);
  }
  return result;
}
// 80627EE: using guessed type int __fastcall sub_80627EE(_DWORD, _DWORD);
// 806C20C: using guessed type int dword_806C20C;

//----- (08052F55) --------------------------------------------------------
int __cdecl sub_8052F55(int a1, _DWORD *a2)
{
  int v2; // edx
  int v3; // ecx
  int result; // eax

  if ( a2[10] <= 1u )
  {
    result = a2[5] + a2[6];
    if ( !result )
      result = sub_8052887(a1, a2[7]);
  }
  else
  {
    sub_80527C4((pthread_mutex_t *)a2[7]);
    sub_8052E59(a1, a2[7]);
    dword_806C338 = (int)&loc_8052F8D;
    result = sub_80620D8(v3, v2);
  }
  return result;
}
// 80620D8: using guessed type int __fastcall sub_80620D8(_DWORD, _DWORD);
// 806C338: using guessed type int dword_806C338;

//----- (08052FDF) --------------------------------------------------------
void __usercall __noreturn sub_8052FDF(double a1@<st0>, int a2, int a3, FILE *stream, int a5)
{
  int v5; // edx
  int v6; // ecx
  pthread_mutex_t *v7; // [esp+1Ch] [ebp-Ch]

  while ( 1 )
  {
    v7 = sub_80528D4(a1, a2);
    if ( !v7[1].__nusers )
    {
      sub_80527DA(v7);
      sub_8052887(a2, (int)v7);
      dword_806C324 = (int)sub_8053085;
      sub_8062148(v6, v5);
    }
    sub_80529DE((int)v7, a3, stream, a5);
    sub_8052E59(a2, (int)v7);
    sub_8052F55(a2, v7);
    sub_80527DA(v7);
  }
}
// 8053085: using guessed type int sub_8053085();
// 8062148: using guessed type int __fastcall sub_8062148(_DWORD, _DWORD);
// 806C324: using guessed type int dword_806C324;

//----- (08053085) --------------------------------------------------------
#error "8053086: positive sp value has been found (funcsize=0)"

//----- (08053087) --------------------------------------------------------
void *__usercall start_routine@<eax>(double a1@<st0>, void *a2)
{
  sub_80530F4(
    *((_DWORD *)a2 + 1),
    a1,
    *(_DWORD *)a2,
    *((_DWORD *)a2 + 1),
    *((_DWORD *)a2 + 2),
    *((_DWORD *)a2 + 3),
    *((_DWORD *)a2 + 4),
    *((FILE **)a2 + 5),
    *((_DWORD *)a2 + 6));
  return 0;
}

//----- (080530F4) --------------------------------------------------------
int __usercall sub_80530F4@<eax>(int a1@<ecx>, double a2@<st0>, int a3, int a4, int a5, int a6, int a7, FILE *stream, int a9)
{
  bool v9; // zf
  int v10; // edx
  int v11; // ecx
  void *v12; // eax
  pthread_t th; // [esp+28h] [ebp-40h]
  unsigned int v15; // [esp+2Ch] [ebp-3Ch]
  unsigned int v16; // [esp+30h] [ebp-38h]
  int v17; // [esp+34h] [ebp-34h]
  unsigned int v18; // [esp+38h] [ebp-30h]
  unsigned int v19; // [esp+3Ch] [ebp-2Ch]
  int v20; // [esp+40h] [ebp-28h]
  int arg; // [esp+44h] [ebp-24h]
  unsigned int v22; // [esp+48h] [ebp-20h]
  int v23; // [esp+4Ch] [ebp-1Ch]
  int v24; // [esp+50h] [ebp-18h]
  int v25; // [esp+54h] [ebp-14h]
  FILE *v26; // [esp+58h] [ebp-10h]
  int v27; // [esp+5Ch] [ebp-Ch]

  v15 = *(_DWORD *)(a6 + 20) + *(_DWORD *)(a6 + 24);
  v16 = (unsigned int)a4 >> 1;
  v17 = a4 - ((unsigned int)a4 >> 1);
  arg = a3;
  v22 = (unsigned int)a4 >> 1;
  v23 = a5;
  v24 = *(_DWORD *)(a6 + 32);
  v25 = a7;
  v26 = stream;
  v27 = a9;
  if ( (unsigned int)a4 <= 1 || v15 <= 0x1FFFF )
  {
    v18 = *(_DWORD *)(a6 + 20);
    v19 = *(_DWORD *)(a6 + 24);
    v20 = -16 * a5 + a3;
    if ( v19 > 1 )
      sub_805216B(-16 * v18, a2, -16 * v18 + a3, v19, -16 * (v18 >> 1) + v20, 0);
    if ( v18 > 1 )
      sub_805216B(a1, a2, a3, v18, v20, 0);
    *(_DWORD *)a6 = a3;
    *(_DWORD *)(a6 + 4) = a3 - 16 * v18;
    *(_DWORD *)(a6 + 8) = a3 - 16 * v18;
    *(_DWORD *)(a6 + 12) = a3 + -16 * v18 - 16 * v19;
    sub_8052887(a7, a6);
    sub_8052FDF(a2, a7, a5, stream, a9);
  }
  v9 = pthread_create(&th, 0, (void *(*)(void *))start_routine, &arg) == 0;
  v12 = &loc_80531A1;
  if ( !v9 )
    v12 = &loc_8053200;
  dword_806C20C = (int)v12;
  sub_80627EE(v11, v10);
  sub_80530F4(
    a3 - 16 * *(_DWORD *)(a6 + 20),
    a2,
    a3 - 16 * *(_DWORD *)(a6 + 20),
    v17,
    a5,
    *(_DWORD *)(a6 + 36),
    a7,
    stream,
    a9);
  return pthread_join(th, 0);
}
// 80627EE: using guessed type int __fastcall sub_80627EE(_DWORD, _DWORD);
// 806C20C: using guessed type int dword_806C20C;

//----- (08053339) --------------------------------------------------------
unsigned int __usercall sub_8053339@<eax>(double a1@<st0>, int a2, int a3, int a4, char *s1)
{
  bool v5; // zf
  int v6; // edx
  int v7; // ecx
  void *v8; // eax
  int v9; // edx
  int v10; // ecx
  void *v11; // eax
  void *v12; // eax
  void *v13; // eax
  void *v14; // eax
  void *v15; // eax
  void *v16; // eax
  void *v17; // eax
  unsigned int result; // eax
  const char *v19; // [esp+4h] [ebp-F4h]
  char v20; // [esp+21h] [ebp-D7h]
  char v21; // [esp+22h] [ebp-D6h]
  bool v22; // [esp+23h] [ebp-D5h]
  FILE *stream; // [esp+24h] [ebp-D4h]
  int *v24; // [esp+28h] [ebp-D0h]
  unsigned int i; // [esp+2Ch] [ebp-CCh]
  __int64 v26; // [esp+30h] [ebp-C8h]
  __int64 v27; // [esp+88h] [ebp-70h]
  __int64 v28; // [esp+90h] [ebp-68h]
  __int64 v29; // [esp+E8h] [ebp-10h]

  v20 = 0;
  v24 = 0;
  for ( i = a3; ; ++i )
  {
    result = i;
    if ( i >= a4 )
      break;
    v22 = strcmp(*(const char **)(8 * i + a2), "-") == 0;
    if ( s1 )
    {
      v19 = *(const char **)(8 * i + a2);
      v5 = strcmp(s1, v19) == 0;
      v8 = &loc_80533D8;
      if ( !v5 )
        v8 = &loc_805340B;
      dword_806C324 = (int)v8;
      sub_8062148(v7, v6);
      v11 = &loc_80533FF;
      if ( v22 == 1 )
        v11 = &loc_805340B;
      dword_806C310 = (int)v11;
      sub_80621CD(v10, v9);
      v21 = 1;
    }
    else
    {
      v12 = &loc_8053432;
      if ( v20 == 1 )
        v12 = &loc_805346C;
      dword_806C2FC = (int)v12;
      sub_806223F();
      v5 = sub_8061EF0(1, (int)&v26) == 0;
      v13 = &loc_8053465;
      if ( !v5 )
        v13 = &loc_805364B;
      dword_806C2D4 = (int)v13;
      sub_8062323();
      v20 = 1;
      v14 = &loc_805348E;
      if ( !v22 )
        v14 = &loc_80534BC;
      dword_806C248 = (int)v14;
      sub_8062696();
      if ( sub_8061EF0(0, (int)&v28) )
      {
        dword_806C2D4 = (int)&loc_8053567;
        sub_8062323();
        v5 = sub_8061EC1(*(_DWORD *)(8 * i + a2), (int)&v28) == 0;
        v15 = &loc_80534FC;
        if ( !v5 )
          v15 = &loc_8053567;
        dword_806C220 = (int)v15;
        sub_806277E();
      }
      v16 = &loc_805352D;
      if ( v29 != v27 )
        v16 = &loc_8053567;
      dword_806C20C = (int)v16;
      sub_80627EE(v29, HIDWORD(v27));
      if ( v28 == v26 )
      {
        dword_806C2AC = (int)&loc_805356C;
        sub_8062420();
      }
      v21 = 0;
    }
    if ( v21 )
    {
      v17 = &loc_80535A8;
      if ( v24 )
        v17 = &loc_80535FD;
      dword_806C2AC = (int)v17;
      sub_8062420();
      v24 = sub_804CA06(a1, &stream);
      sub_8051F8E(a1, 8 * i + a2, 0, 1, stream, (int)v24 + 9);
      *(_DWORD *)(8 * i + a2) = (char *)v24 + 9;
      *(_DWORD *)(a2 + 8 * i + 4) = v24;
    }
  }
  return result;
}
// 8062148: using guessed type int __fastcall sub_8062148(_DWORD, _DWORD);
// 80621CD: using guessed type int __fastcall sub_80621CD(_DWORD, _DWORD);
// 806223F: using guessed type int sub_806223F(void);
// 8062323: using guessed type int sub_8062323(void);
// 8062420: using guessed type int sub_8062420(void);
// 8062696: using guessed type int sub_8062696(void);
// 806277E: using guessed type int sub_806277E(void);
// 80627EE: using guessed type int __fastcall sub_80627EE(_DWORD, _DWORD);
// 806C20C: using guessed type int dword_806C20C;
// 806C220: using guessed type int dword_806C220;
// 806C248: using guessed type int dword_806C248;
// 806C2AC: using guessed type int dword_806C2AC;
// 806C2D4: using guessed type int dword_806C2D4;
// 806C2FC: using guessed type int dword_806C2FC;
// 806C310: using guessed type int dword_806C310;
// 806C324: using guessed type int dword_806C324;

//----- (08053655) --------------------------------------------------------
unsigned int __cdecl sub_8053655(int a1, unsigned int a2)
{
  int v2; // ebx
  unsigned int result; // eax
  unsigned int v4; // [esp+1Ch] [ebp-Ch]

  v4 = 0;
  while ( 1 )
  {
    result = v4;
    if ( v4 >= a2 )
      break;
    if ( strcmp(*(const char **)(4 * v4 + a1), "-") && euidaccess(*(_DWORD *)(4 * v4 + a1), 4) )
    {
      v2 = *(_DWORD *)(4 * v4 + a1);
      gettext("cannot read");
      dword_806C2C0 = (int)&loc_80536D4;
      sub_806239B();
    }
    else
    {
      ++v4;
    }
  }
  return result;
}
// 8049E00: using guessed type int __cdecl euidaccess(_DWORD, _DWORD);
// 806C2C0: using guessed type int dword_806C2C0;

//----- (08053728) --------------------------------------------------------
void __cdecl sub_8053728(int a1)
{
  char *v1; // eax
  int fd; // [esp+1Ch] [ebp-Ch]

  if ( a1 )
  {
    fd = open64(a1, 524353);
    if ( fd < 0 )
    {
      v1 = gettext("open failed");
      sub_804BA80((int)v1, a1);
    }
    sub_804C6C0(fd, 1);
  }
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);

//----- (0805378E) --------------------------------------------------------
void __usercall sub_805378E(double a1@<st0>, int a2, int a3, int a4, char *s1)
{
  int *v5; // eax
  int v6; // ebx
  int v7; // eax
  int v8; // eax
  int v9; // eax
  char *v10; // eax
  int v11; // ebx
  char *v12; // eax
  int v13; // eax
  int v14; // ecx
  int v15; // [esp+0h] [ebp-78h]
  _BOOL4 v16; // [esp+4h] [ebp-74h]
  void *v17; // [esp+28h] [ebp-50h]
  FILE *v18; // [esp+2Ch] [ebp-4Ch]
  int v19; // [esp+30h] [ebp-48h]
  unsigned int v20; // [esp+34h] [ebp-44h]
  int v21; // [esp+38h] [ebp-40h]
  int v22; // [esp+44h] [ebp-34h]
  unsigned int v23; // [esp+48h] [ebp-30h]
  int v24; // [esp+4Ch] [ebp-2Ch]
  int *v25; // [esp+50h] [ebp-28h]
  unsigned int v26; // [esp+54h] [ebp-24h]
  FILE *stream; // [esp+58h] [ebp-20h]
  int *v28; // [esp+5Ch] [ebp-1Ch]

  while ( dword_806C414 < (unsigned int)a4 )
  {
    v19 = 0;
    v20 = 0;
    while ( a4 - v19 >= (unsigned int)dword_806C414 )
    {
      sub_804CA06(a1, &v18);
      dword_806C248 = (int)&loc_8053810;
      sub_8062696();
    }
    v22 = a4 - v19;
    v23 = dword_806C414 - v20 % dword_806C414;
    if ( dword_806C414 - v20 % dword_806C414 < a4 - v19 )
    {
      v24 = v22 - v23 + 1;
      v5 = sub_804CA06(a1, &v18);
      v25 = v5;
      v6 = (int)v5 + 9;
      v7 = a3;
      if ( v24 <= (unsigned int)a3 )
        v7 = v24;
      v15 = 8 * v19 + a2;
      v26 = sub_8051F8E(a1, v15, v7, v24, v18, v6);
      v8 = a3;
      if ( v26 <= a3 )
        v8 = v26;
      a3 -= v8;
      *(_DWORD *)(8 * v20 + a2) = (char *)v25 + 9;
      v9 = v20++;
      *(_DWORD *)(a2 + 8 * v9 + 4) = v25;
      v19 += v26;
    }
    memmove((void *)(8 * v20 + a2), (const void *)(a2 + 8 * v19), 8 * (a4 - v19));
    a3 += v20;
    a4 += v20 - v19;
  }
  sub_8053339(a1, a2, a3, a4, s1);
  v21 = sub_80514AC(a1, a2, a4, &v17);
  if ( v21 == a4 )
  {
    stream = sub_804C43E(a1, s1, "w");
    if ( stream )
    {
      sub_80515BE(a1, a2, a3, a4, stream, (int)s1, v17);
      return;
    }
    if ( *__errno_location() != 24 || (unsigned int)v21 <= 2 )
    {
      v10 = gettext("open failed");
      sub_804BA80((int)v10, (int)s1);
    }
  }
  else if ( (unsigned int)v21 <= 2 )
  {
    v11 = *(_DWORD *)(8 * v21 + a2);
    v12 = gettext("open failed");
    sub_804BA80((int)v12, v11);
  }
  do
  {
    --v21;
    sub_804C609(a1, *((FILE **)v17 + v21), *(_DWORD *)(8 * v21 + a2));
    v16 = (unsigned int)v21 > 2;
    v28 = sub_804C8A8(a1, &v18, v16);
  }
  while ( !v28 );
  v13 = a3;
  if ( v21 <= (unsigned int)a3 )
    v13 = v21;
  sub_80515BE(a1, a2, v13, v21, v18, (int)v28 + 9, v17);
  *(_DWORD *)a2 = (char *)v28 + 9;
  *(_DWORD *)(a2 + 4) = v28;
  memmove((void *)(a2 + 8), (const void *)(a2 + 8 * v21), 8 * (a4 - v21));
  dword_806C324 = (int)&loc_8053A44;
  sub_8062148(v14, a4 - v21);
}
// 8062148: using guessed type int __fastcall sub_8062148(_DWORD, _DWORD);
// 8062696: using guessed type int sub_8062696(void);
// 806C248: using guessed type int dword_806C248;
// 806C324: using guessed type int dword_806C324;
// 806C410: using guessed type int dword_806C410;

//----- (08053C27) --------------------------------------------------------
unsigned int __usercall sub_8053C27@<eax>(double a1@<st0>, char **a2, unsigned int a3, char *a4, unsigned int a5)
{
  int v5; // eax
  void *v6; // eax
  void *v7; // eax
  int v8; // edx
  int v9; // ecx
  void *v10; // eax
  int v12; // [esp+0h] [ebp-E8h]
  int v13; // [esp+4h] [ebp-E4h]
  int v14; // [esp+8h] [ebp-E0h]
  int v15; // [esp+Ch] [ebp-DCh]
  int v16; // [esp+10h] [ebp-D8h]
  int v17; // [esp+14h] [ebp-D4h]
  int v18; // [esp+18h] [ebp-D0h]
  int v19; // [esp+1Ch] [ebp-CCh]
  int v20; // [esp+20h] [ebp-C8h]
  int v21; // [esp+24h] [ebp-C4h]
  char *v22; // [esp+28h] [ebp-C0h]
  char **v23; // [esp+2Ch] [ebp-BCh]
  int v24; // [esp+30h] [ebp-B8h]
  int v25; // [esp+34h] [ebp-B4h]
  int v26; // [esp+38h] [ebp-B0h]
  int v27; // [esp+3Ch] [ebp-ACh]
  FILE *stream; // [esp+40h] [ebp-A8h]
  FILE *v29; // [esp+44h] [ebp-A4h]
  int v30; // [esp+48h] [ebp-A0h]
  int v31; // [esp+4Ch] [ebp-9Ch]
  int v32; // [esp+50h] [ebp-98h]
  unsigned int v33; // [esp+54h] [ebp-94h]
  int v34; // [esp+58h] [ebp-90h]
  int *v35; // [esp+5Ch] [ebp-8Ch]
  int v36; // [esp+60h] [ebp-88h]
  char *s1; // [esp+64h] [ebp-84h]
  int v38; // [esp+68h] [ebp-80h]
  pthread_mutex_t *v39; // [esp+6Ch] [ebp-7Ch]
  void *v40; // [esp+70h] [ebp-78h]
  void *ptr; // [esp+74h] [ebp-74h]
  int v42; // [esp+78h] [ebp-70h]
  int v43; // [esp+7Ch] [ebp-6Ch]
  int v44; // [esp+80h] [ebp-68h]
  int v45; // [esp+84h] [ebp-64h]
  char v46; // [esp+8Ch] [ebp-5Ch]
  int v47; // [esp+90h] [ebp-58h]
  unsigned int v48; // [esp+DCh] [ebp-Ch]

  v23 = a2;
  v22 = a4;
  v48 = __readgsdword(0x14u);
  v30 = 0;
  HIBYTE(v27) = 0;
  v44 = 0;
  while ( a3 )
  {
    s1 = *v23;
    stream = sub_804C5A3(a1, s1, "r");
    if ( a5 > 1 )
    {
      v33 = 1;
      v34 = 1;
      while ( v33 < a5 )
      {
        v33 *= 2;
        ++v34;
      }
      dword_806C25C = (int)&loc_8053F3B;
      sub_8062626(a1);
      goto LABEL_7;
    }
    while ( 1 )
    {
      v32 = 24;
      if ( !v44 )
      {
        v5 = sub_804D849(a1, (int)&stream, 1u, (int)v23, a3, v32);
        sub_804DA6D((int)&ptr, v32, v5);
      }
      v46 = 0;
      ++v23;
      --a3;
      dword_806C2C0 = (int)&loc_8053F63;
      sub_806239B();
      if ( v46 )
      {
        if ( a3 && v32 + 1 < (unsigned int)(v44 - v42 - v32 * v43) )
          break;
      }
      dword_806CD23 = 0;
      v38 = sub_804DAF3(&ptr);
      v6 = &loc_8053E05;
      if ( !v46 )
        v6 = &loc_8053E7D;
      dword_806C2C0 = (int)v6;
      sub_806239B();
      if ( a3 )
        goto LABEL_34;
      v7 = &loc_8053E2D;
      if ( v30 )
        v7 = &loc_8053E7D;
      dword_806C2E8 = (int)v7;
      sub_80622AD(v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, stream, v29, v30);
      if ( v45 )
      {
LABEL_34:
        ++v30;
        v31 = (int)sub_804CA06(a1, &v29) + 9;
      }
      else
      {
        sub_804C609(a1, stream, (int)s1);
        v29 = sub_804C5A3(a1, v22, "w");
        v31 = (int)v22;
        HIBYTE(v27) = 1;
      }
      if ( (unsigned int)v43 <= 1 )
      {
        sub_805293D(v31, v38 - 16, v38 - 16, v29, v31);
      }
      else
      {
        sub_8052821((int)&v47, a5);
        v39 = sub_8052475(a5, v43, v38);
        sub_80530F4(v31, a1, v38, a5, v43, (int)&v39[3], (int)&v47, v29, v31);
      }
LABEL_7:
      sub_804C609(a1, v29, v31);
      dword_806C2D4 = (int)&loc_8053F58;
      sub_8062323();
    }
    v45 = v42;
    sub_804C609(a1, stream, (int)s1);
  }
  free(ptr);
  v10 = &loc_8053FDE;
  if ( HIBYTE(v27) == 1 )
    v10 = &loc_8054098;
  dword_806C324 = (int)v10;
  sub_8062148(v9, v8);
  v35 = (int *)dword_806D1D7;
  v40 = sub_805EB56(v30, 8u);
  v36 = 0;
  while ( v35 )
  {
    *((_DWORD *)v40 + 2 * v36) = (char *)v35 + 9;
    *((_DWORD *)v40 + 2 * v36 + 1) = v35;
    v35 = (int *)*v35;
    ++v36;
  }
  sub_805378E(a1, (int)v40, v30, v30, v22);
  free(v40);
  sub_804C16D();
  return __readgsdword(0x14u) ^ v48;
}
// 8062148: using guessed type int __fastcall sub_8062148(_DWORD, _DWORD);
// 80622AD: using guessed type int __stdcall sub_80622AD(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8062323: using guessed type int sub_8062323(void);
// 8062626: using guessed type int __usercall sub_8062626@<eax>(double@<st0>);
// 806C25C: using guessed type int dword_806C25C;
// 806C2C0: using guessed type int dword_806C2C0;
// 806C2D4: using guessed type int dword_806C2D4;
// 806C2E8: using guessed type int dword_806C2E8;
// 806C324: using guessed type int dword_806C324;
// 806CD23: using guessed type int dword_806CD23;
// 806D1D7: using guessed type int dword_806D1D7;

//----- (080540B7) --------------------------------------------------------
_DWORD *__cdecl sub_80540B7(void *src)
{
  _DWORD *result; // eax
  int *i; // [esp+18h] [ebp-10h]
  _DWORD *v3; // [esp+1Ch] [ebp-Ch]

  v3 = sub_805EE0E(src, 0x28u);
  for ( i = &dword_806D14B; *i; i = (int *)(*i + 36) )
    ;
  *i = (int)v3;
  result = v3;
  v3[9] = 0;
  return result;
}
// 806D14B: using guessed type int dword_806D14B;

//----- (08054104) --------------------------------------------------------
int __usercall sub_8054104@<eax>(double a1@<st0>, int a2, char *msgid)
{
  void *v3; // esi
  char *v4; // ebx
  char *v5; // eax

  v3 = sub_805C56F(a1, (char *)a2);
  v4 = gettext(msgid);
  v5 = gettext("%s: invalid field specification %s");
  error(2, 0, v5, v4, v3);
  return sub_8054152(a2);
}

//----- (08054152) --------------------------------------------------------
int __cdecl sub_8054152(int a1)
{
  char *v1; // eax
  void *v2; // eax
  int result; // eax
  unsigned int v4; // et1
  int v5; // [esp-34h] [ebp-64h]
  int v6; // [esp-30h] [ebp-60h]
  int v7; // [esp-2Ch] [ebp-5Ch]
  int v8; // [esp-28h] [ebp-58h]
  int v9; // [esp-24h] [ebp-54h]
  int v10; // [esp-20h] [ebp-50h]
  int v11; // [esp-1Ch] [ebp-4Ch]
  int v12; // [esp-18h] [ebp-48h]
  int v13; // [esp-14h] [ebp-44h]
  int v14; // [esp-10h] [ebp-40h]
  int v15; // [esp-Ch] [ebp-3Ch]
  int v16; // [esp-8h] [ebp-38h]
  int v17; // [esp-4h] [ebp-34h]
  int v18; // [esp+0h] [ebp-30h]
  int v19; // [esp+4h] [ebp-2Ch]
  int v20; // [esp+8h] [ebp-28h]
  int v21; // [esp+Ch] [ebp-24h]
  int v22; // [esp+10h] [ebp-20h]
  int *v23; // [esp+14h] [ebp-1Ch]
  unsigned int v24; // [esp+24h] [ebp-Ch]
  int savedregs; // [esp+30h] [ebp+0h]

  v1 = gettext("options '-%s' are incompatible");
  error(2, 0, v1, a1);
  v23 = &savedregs;
  v24 = __readgsdword(0x14u);
  v18 = dword_806D14B;
  do
  {
    v2 = &loc_8054282;
    if ( v18 )
      v2 = &loc_80541A1;
    dword_806C2E8 = (int)v2;
    sub_80622AD(v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23);
    v4 = __readgsdword(0x14u);
    result = v4 ^ v24;
  }
  while ( v4 != v24 );
  return result;
}
// 80622AD: using guessed type int __stdcall sub_80622AD(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806C2E8: using guessed type int dword_806C2E8;
// 806D14B: using guessed type int dword_806D14B;

//----- (080542B4) --------------------------------------------------------
int __usercall sub_80542B4@<eax>(double a1@<st0>, int a2@<edx>, int ecx0@<ecx>, int nptr, int a3, char *msgid)
{
  void *v6; // eax
  char *v7; // esi
  char *v8; // ebx
  char *v9; // eax
  int result; // eax
  char *v11; // [esp+Ch] [ebp-2Ch]
  char *v12; // [esp+10h] [ebp-28h]
  int v13; // [esp+24h] [ebp-14h]
  __int64 v14; // [esp+28h] [ebp-10h]

  v12 = &s;
  switch ( sub_805F808(a2, ecx0, (char *)nptr, (int)&v13, 10, (int)&v14) )
  {
    case 0:
    case 2:
      *(_DWORD *)a3 = v14;
      if ( v14 == *(_DWORD *)a3 )
        goto LABEL_7;
      goto LABEL_3;
    case 1:
    case 3:
LABEL_3:
      *(_DWORD *)a3 = -1;
      dword_806C2FC = (int)&loc_80543B3;
      sub_806223F();
      goto LABEL_4;
    case 4:
LABEL_4:
      v6 = &loc_8054366;
      if ( !msgid )
        v6 = &loc_80543AC;
      dword_806C220 = (int)v6;
      sub_806277E();
      v7 = (char *)sub_805C56F(a1, (char *)nptr);
      v8 = gettext(msgid);
      v9 = gettext("%s: invalid count at start of %s");
      v12 = v7;
      v11 = v8;
      error(2, 0, v9, v8, v7);
      result = 0;
      break;
    default:
LABEL_7:
      result = v13;
      break;
  }
  return result;
}
// 806223F: using guessed type int sub_806223F(void);
// 806277E: using guessed type int sub_806277E(void);
// 806C220: using guessed type int dword_806C220;
// 806C2FC: using guessed type int dword_806C2FC;

//----- (080543BD) --------------------------------------------------------
int __cdecl sub_80543BD(int sig)
{
  sub_804C18C();
  signal(sig, 0);
  return raise(sig);
}

//----- (080543E8) --------------------------------------------------------
char *__usercall sub_80543E8@<eax>(double a1@<st0>, int edx0@<edx>, int ecx0@<ecx>, char *a2, int a3, int a4)
{
  int v6; // edx
  int v7; // ecx
  char *result; // eax
  void *v9; // eax
  char *v10; // [esp+8h] [ebp+8h]

  dword_806C310 = (int)&loc_805450A;
  sub_80621CD(ecx0, edx0);
  switch ( *a2 )
  {
    case 77:
      *(_BYTE *)(a3 + 30) = 1;
      goto LABEL_22;
    case 82:
      goto LABEL_18;
    case 86:
      *(_BYTE *)(a3 + 32) = 1;
      goto LABEL_22;
    case 98:
      if ( !a4 || a4 == 2 )
        *(_BYTE *)(a3 + 24) = 1;
      if ( a4 != 1 && a4 != 2 )
      {
        dword_806C270 = (int)&loc_8054506;
        sub_80625B6(v7, v6);
LABEL_9:
        *(_DWORD *)(a3 + 16) = &unk_806CF37;
      }
      else
      {
        *(_BYTE *)(a3 + 25) = 1;
      }
      goto LABEL_22;
    case 100:
      goto LABEL_9;
    case 102:
      *(_DWORD *)(a3 + 20) = byte_806D037;
      goto LABEL_22;
    case 103:
      *(_BYTE *)(a3 + 28) = 1;
      goto LABEL_22;
    case 104:
      *(_BYTE *)(a3 + 29) = 1;
      dword_806C310 = (int)&loc_8054506;
      sub_80621CD(v7, v6);
      goto LABEL_13;
    case 105:
LABEL_13:
      if ( !*(_DWORD *)(a3 + 16) )
        *(_DWORD *)(a3 + 16) = &unk_806CE37;
      goto LABEL_22;
    case 110:
      *(_BYTE *)(a3 + 26) = 1;
      dword_806C2AC = (int)&loc_8054506;
      sub_8062420();
LABEL_18:
      *(_BYTE *)(a3 + 27) = 1;
      goto LABEL_22;
    case 114:
      *(_BYTE *)(a3 + 31) = 1;
LABEL_22:
      v10 = a2 + 1;
      v9 = &loc_805452D;
      if ( *v10 )
        v9 = &loc_8054402;
      dword_806C25C = (int)v9;
      sub_8062626(a1);
      result = v10;
      break;
    default:
      result = a2;
      break;
  }
  return result;
}
// 80621CD: using guessed type int __fastcall sub_80621CD(_DWORD, _DWORD);
// 8062420: using guessed type int sub_8062420(void);
// 80625B6: using guessed type int __fastcall sub_80625B6(_DWORD, _DWORD);
// 8062626: using guessed type int __usercall sub_8062626@<eax>(double@<st0>);
// 806C25C: using guessed type int dword_806C25C;
// 806C270: using guessed type int dword_806C270;
// 806C2AC: using guessed type int dword_806C2AC;
// 806C310: using guessed type int dword_806C310;

//----- (08054532) --------------------------------------------------------
void *__cdecl sub_8054532(void *s)
{
  memset(s, 0, 0x28u);
  *((_DWORD *)s + 2) = -1;
  return s;
}

//----- (08054562) --------------------------------------------------------
void __usercall main(double a1@<st0>, int argc, char **argv)
{
  int v3; // eax
  bool v4; // zf
  bool v5; // sf
  unsigned __int8 v6; // of
  void *v7; // eax
  void *v8; // eax
  unsigned __int8 **v9; // eax
  unsigned __int8 v10; // al
  int v11; // edx
  int v12; // ecx
  void *v13; // eax
  unsigned __int8 v14; // al
  int v15; // edx
  int v16; // ecx
  void *v17; // eax
  void *v18; // eax
  void *v19; // eax
  int v20; // edx
  int v21; // ecx
  int (__cdecl *v22)(char *, char *, char *, int, int, int, int, int, int, int, char, char, int, int, int, int, int, int, size_t, void *, char *, char *, int, int, int, int, int, int, int, FILE *, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, char, int, int, int, int, int, char, char, char, int, int, int); // eax
  int v23; // eax
  _DWORD *v24; // ecx
  int v25; // eax
  bool v26; // al
  __int64 v27; // rax
  void *v28; // eax
  bool v29; // al
  void *v30; // eax
  _DWORD *v31; // eax
  int v32; // ecx
  char *v33; // eax
  int v34; // edx
  int v35; // ecx
  void *v36; // eax
  void *v37; // eax
  int v38; // ecx
  void *v39; // eax
  int v40; // eax
  int v41; // edx
  int v42; // ecx
  int v43; // edx
  int v44; // ecx
  void *v45; // eax
  void *v46; // eax
  int v47; // eax
  signed int v48; // eax
  void *v49; // eax
  char *v50; // eax
  _DWORD *v51; // eax
  int v52; // ecx
  int v53; // eax
  void *v54; // eax
  _DWORD *v55; // edx
  int v56; // ecx
  int v57; // eax
  int v58; // ecx
  int v59; // eax
  int v60; // ecx
  _DWORD *v61; // edx
  void *v62; // eax
  void *v63; // eax
  int v64; // ecx
  int v65; // edx
  int v66; // ecx
  void *v67; // eax
  char *v68; // eax
  char *v69; // eax
  char *v70; // eax
  char *v71; // ebx
  char *v72; // eax
  char *v73; // eax
  _DWORD *v74; // [esp+4h] [ebp-178h]
  char *v75; // [esp+Ch] [ebp-170h]
  const char *v76; // [esp+10h] [ebp-16Ch]
  const char *v77; // [esp+14h] [ebp-168h]
  int v78; // [esp+18h] [ebp-164h]
  char v79; // [esp+2Dh] [ebp-14Fh]
  char v80; // [esp+2Eh] [ebp-14Eh]
  char v81; // [esp+2Fh] [ebp-14Dh]
  char v82; // [esp+30h] [ebp-14Ch]
  unsigned __int8 v83; // [esp+31h] [ebp-14Bh]
  bool v84; // [esp+32h] [ebp-14Ah]
  char v85; // [esp+33h] [ebp-149h]
  bool v86; // [esp+34h] [ebp-148h]
  bool v87; // [esp+35h] [ebp-147h]
  char v88; // [esp+36h] [ebp-146h]
  char v89; // [esp+37h] [ebp-145h]
  _DWORD *v90; // [esp+38h] [ebp-144h]
  char *v91; // [esp+3Ch] [ebp-140h]
  int v92; // [esp+40h] [ebp-13Ch]
  const char *v93; // [esp+44h] [ebp-138h]
  int v94; // [esp+48h] [ebp-134h]
  int v95; // [esp+4Ch] [ebp-130h]
  _DWORD *v96; // [esp+50h] [ebp-12Ch]
  char *v97; // [esp+54h] [ebp-128h]
  const char *v98; // [esp+58h] [ebp-124h]
  unsigned int i; // [esp+5Ch] [ebp-120h]
  char *j; // [esp+60h] [ebp-11Ch]
  int v101; // [esp+6Ch] [ebp-110h]
  unsigned __int8 **v102; // [esp+70h] [ebp-10Ch]
  char *v103; // [esp+74h] [ebp-108h]
  char v104; // [esp+90h] [ebp-ECh]
  char s; // [esp+B8h] [ebp-C4h]
  int longind; // [esp+E0h] [ebp-9Ch]
  __sigset_t v107; // [esp+E4h] [ebp-98h]
  int v108; // [esp+164h] [ebp-18h]

  v79 = 0;
  v92 = 0;
  v80 = 0;
  v81 = 0;
  v93 = 0;
  v82 = 0;
  v94 = 0;
  v95 = 0;
  v86 = getenv("POSIXLY_CORRECT") != 0;
  v3 = sub_805A628();
  v101 = v3;
  v6 = __OFSUB__(v3, 200111);
  v4 = v3 == 200111;
  v5 = v3 - 200111 < 0;
  v7 = &loc_80545E6;
  if ( (unsigned __int8)(v5 ^ v6) | v4 )
    v7 = &loc_8054609;
  dword_806C2D4 = (int)v7;
  sub_8062323();
  v8 = &loc_8054609;
  if ( v101 <= 200808 )
    v8 = &loc_8054610;
  dword_806C358 = (int)v8;
  sub_8061FAB();
  v83 = 1;
  v97 = 0;
  v98 = 0;
  sub_805A69F(*argv);
  v84 = setlocale(6, &::s) != 0;
  bindtextdomain("coreutils", "/home/hwangdz/coreutils/coreutils-8.28/install_m32/share/locale");
  textdomain("coreutils");
  sub_804B6C8(2);
  byte_806CD1F = sub_8057CFE(3);
  byte_806CD20 = sub_8057CFE(2);
  v9 = (unsigned __int8 **)localeconv();
  v102 = v9;
  v10 = sub_804B6F4(**v9);
  dword_806CD17 = v10;
  v4 = v10 == 0;
  v13 = &loc_80546ED;
  if ( v4 )
    v13 = &loc_80546FD;
  dword_806C270 = (int)v13;
  sub_80625B6(v12, v11);
  if ( (*v102)[1] )
    dword_806CD17 = 46;
  v14 = sub_804B6F4(*v102[1]);
  dword_806CD1B = v14;
  if ( v14 )
  {
    v17 = &loc_8054757;
    if ( !v102[1][1] )
      v17 = &loc_8054761;
    dword_806C338 = (int)v17;
    sub_80620D8(v16, v15);
  }
  dword_806CD1B = -1;
  byte_806D14A = 0;
  sub_804CE55();
  sigemptyset(&set);
  for ( i = 0; i <= 0xA; ++i )
  {
    sigaction(sig[i], 0, (struct sigaction *)&longind);
    if ( longind != 1 )
      sigaddset(&set, sig[i]);
  }
  longind = (int)sub_80543BD;
  qmemcpy(&v107, &set, sizeof(v107));
  v108 = 0;
  for ( i = 0; i <= 0xA; ++i )
  {
    v4 = sigismember(&set, sig[i]) == 0;
    v18 = &loc_805484D;
    if ( v4 )
      v18 = &loc_8054873;
    dword_806C2D4 = (int)v18;
    sub_8062323();
    sigaction(sig[i], (const struct sigaction *)&longind, 0);
  }
  signal(17, 0);
  sub_8061E71((int)&loc_804C1E3, (int)v74);
  sub_8054532(&s);
  *(_DWORD *)&s = -1;
  v96 = sub_805EB56(argc, 4u);
  while ( 1 )
  {
    longind = -1;
    if ( v92 == -1 )
      goto LABEL_156;
    if ( v86 && v95 )
    {
      if ( v83 != 1 || v80 || optind == argc || *argv[optind] != 45 )
        goto LABEL_156;
      v19 = &loc_8054979;
      if ( argv[optind][1] != 111 )
        v19 = &loc_80549DB;
      dword_806C358 = (int)v19;
      sub_8061FAB();
      if ( !argv[optind][2] && optind + 1 == argc )
        goto LABEL_156;
    }
    v92 = getopt_long(argc, argv, "-bcCdfghik:mMno:rRsS:t:T:uVy:z", &longopts, &longind);
    if ( v92 == -1 )
    {
LABEL_156:
      if ( argc <= optind )
      {
        v22 = (int (__cdecl *)(char *, char *, char *, int, int, int, int, int, int, int, char, char, int, int, int, int, int, int, size_t, void *, char *, char *, int, int, int, int, int, int, int, FILE *, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, char, int, int, int, int, int, char, char, char, int, int, int))&loc_8054A05;
        if ( v97 )
          v22 = sub_8055506;
        dword_806C2C0 = (int)v22;
        sub_806239B();
        dword_806C2AC = (int)&loc_80557A3;
        sub_8062420();
      }
      v23 = v95++;
      v24 = &v96[v23];
      v25 = optind++;
      *v24 = argv[v25];
    }
    else
    {
      switch ( v92 )
      {
        case 4294967165:
          v78 = 0;
          v77 = "Paul Eggert";
          v76 = "Mike Haertel";
          sub_805EAB6(stdout, (int)"sort", (int)"GNU coreutils", off_806C42C, "Mike Haertel", "Paul Eggert", 0);
          exit(0);
          return;
        case 4294967166:
          sub_804BAE2(0);
          return;
        case 1:
          v90 = 0;
          if ( *optarg == 43 )
          {
            v26 = optind != argc && *argv[optind] == 45 && (unsigned int)(argv[optind][1] - 48) <= 9;
            v87 = v26;
            HIDWORD(v27) = v83;
            if ( v26 )
            {
              v28 = &loc_8054B1B;
              if ( v86 == 1 )
                v28 = &loc_8054B22;
              dword_806C20C = (int)v28;
              sub_80627EE(v21, v83);
              LODWORD(v27) = 1;
            }
            else
            {
              LODWORD(v27) = 0;
            }
            v29 = v27 != 0;
            v83 = v29;
            v4 = v29 == 0;
            v30 = &loc_8054B52;
            if ( v4 )
              v30 = &loc_8054D9B;
            dword_806C2D4 = (int)v30;
            sub_8062323();
            v31 = sub_8054532(&v104);
            v90 = v31;
            v33 = (char *)sub_80542B4(a1, (int)(optarg + 1), v32, (int)(optarg + 1), (int)v31, 0);
            v91 = v33;
            v4 = v33 == 0;
            v36 = &loc_8054BAA;
            if ( v4 )
              v36 = &loc_8054BF4;
            dword_806C270 = (int)v36;
            sub_80625B6(v35, v34);
            v37 = &loc_8054BCE;
            if ( *v91 != 46 )
              v37 = &loc_8054BF4;
            dword_806C298 = (int)v37;
            sub_80624B3();
            v91 = (char *)sub_80542B4(a1, (int)(v90 + 1), v38, (int)(v91 + 1), (int)(v90 + 1), 0);
            if ( !*v90 )
            {
              v39 = &loc_8054C22;
              if ( v90[1] )
                v39 = &loc_8054C2C;
              dword_806C2AC = (int)v39;
              sub_8062420();
              *v90 = -1;
            }
            if ( v91 && !*sub_80543E8(a1, v20, v21, v91, (int)v90, 0) )
            {
              if ( v87 )
              {
                v40 = optind++;
                v103 = argv[v40];
                v91 = (char *)sub_80542B4(
                                a1,
                                (int)(v90 + 2),
                                v21,
                                (int)(v103 + 1),
                                (int)(v90 + 2),
                                "invalid number after '-'");
                if ( !v91 )
                  __assert_fail("s", "src/sort.c", 0x110Du, "main");
                if ( *v91 == 46 )
                  v91 = (char *)sub_80542B4(
                                  a1,
                                  (int)(v90 + 3),
                                  v42,
                                  (int)(v91 + 1),
                                  (int)(v90 + 3),
                                  "invalid number after '.'");
                if ( !v90[3] && v90[2] )
                {
                  v41 = v90[2] - 1;
                  v90[2] = v41;
                }
                v4 = *sub_80543E8(a1, v41, v42, v91, (int)v90, 1) == 0;
                v45 = &loc_8054D73;
                if ( v4 )
                  v45 = &loc_8054D87;
                dword_806C324 = (int)v45;
                sub_8062148(v44, v43);
                sub_8054104(a1, (int)v103, "stray character in field spec");
              }
              *((_BYTE *)v90 + 33) = 1;
              sub_80540B7(v90);
            }
            else
            {
              v90 = 0;
            }
          }
          v46 = &loc_8054DBB;
          if ( v90 )
            v46 = &loc_8054DDF;
          dword_806C310 = (int)v46;
          sub_80621CD(v21, v20);
          v47 = v95++;
          v96[v47] = optarg;
          continue;
        case 67:
        case 99:
          goto LABEL_87;
        case 77:
        case 82:
        case 86:
        case 98:
        case 100:
        case 102:
        case 103:
        case 104:
        case 105:
        case 110:
        case 114:
          goto LABEL_82;
        case 83:
          sub_804D318((char)v92, (int)optarg, longind, v92, optarg);
          dword_806C298 = (int)&loc_8055501;
          sub_80624B3();
          goto LABEL_129;
        case 84:
          sub_804CC13((int)optarg);
          continue;
        case 107:
          v51 = sub_8054532(&v104);
          v90 = v51;
          v74 = v51;
          v91 = (char *)sub_80542B4(a1, (int)v74, v52, (int)optarg, (int)v74, "invalid number at field start");
          v53 = (*v90)--;
          v4 = v53 == 0;
          v54 = &loc_8054FC4;
          if ( !v4 )
            v54 = &loc_8054FD9;
          dword_806C2C0 = (int)v54;
          sub_806239B();
          sub_8054104(a1, (int)optarg, "field number is zero");
          if ( *v91 == 46 )
          {
            v91 = (char *)sub_80542B4(
                            a1,
                            (int)(v90 + 1),
                            v56,
                            (int)(v91 + 1),
                            (int)(v90 + 1),
                            "invalid number after '.'");
            v57 = v90[1];
            v56 = v57 - 1;
            v55 = v90;
            v90[1] = v57 - 1;
            if ( !v57 )
              sub_8054104(a1, (int)optarg, "character offset is zero");
          }
          if ( !*v90 && !v90[1] )
            *v90 = -1;
          v91 = sub_80543E8(a1, (int)v55, v56, v91, (int)v90, 0);
          if ( *v91 == 44 )
          {
            v91 = (char *)sub_80542B4(
                            a1,
                            (int)(v90 + 2),
                            v58,
                            (int)(v91 + 1),
                            (int)(v90 + 2),
                            "invalid number after ','");
            v59 = v90[2];
            v60 = v59 - 1;
            v61 = v90;
            v90[2] = v59 - 1;
            v4 = v59 == 0;
            v62 = &loc_80550ED;
            if ( !v4 )
              v62 = &loc_8055102;
            dword_806C234 = (int)v62;
            sub_8062704(v60, v61);
            sub_8054104(a1, (int)optarg, "field number is zero");
            v63 = &loc_8055126;
            if ( *v91 != 46 )
              v63 = &loc_805514C;
            dword_806C20C = (int)v63;
            ((void (*)(void))sub_80627EE)();
            v91 = (char *)sub_80542B4(
                            a1,
                            (int)(v90 + 3),
                            v64,
                            (int)(v91 + 1),
                            (int)(v90 + 3),
                            "invalid number after '.'");
            v91 = sub_80543E8(a1, v65, v66, v91, (int)v90, 1);
          }
          else
          {
            v90[2] = -1;
            v90[3] = 0;
          }
          if ( *v91 )
            sub_8054104(a1, (int)optarg, "stray character in field spec");
          sub_80540B7(v90);
          continue;
        case 109:
          v81 = 1;
          continue;
        case 111:
          if ( v98 )
          {
            v4 = strcmp(v98, optarg) == 0;
            v67 = &loc_8055209;
            if ( v4 )
              v67 = &loc_805522D;
            dword_806C2D4 = (int)v67;
            sub_8062323();
            v68 = gettext("multiple output files specified");
            error(2, 0, v68);
          }
          v98 = optarg;
          dword_806C2AC = (int)&loc_8055501;
          sub_8062420();
          goto LABEL_123;
        case 115:
          byte_806D148 = 1;
          break;
        case 116:
LABEL_129:
          v85 = *optarg;
          if ( !v85 )
          {
            v70 = gettext("empty tab");
            error(2, 0, v70);
          }
          if ( optarg[1] )
          {
            if ( !strcmp(optarg, "\\0") )
            {
              v85 = 0;
            }
            else
            {
              v71 = (char *)sub_805C56F(a1, optarg);
              v72 = gettext("multi-character tab %s");
              v75 = v71;
              error(2, 0, v72, v71);
            }
          }
          if ( dword_806C410 != 128 && v85 != dword_806C410 )
          {
            v73 = gettext("incompatible tabs");
            error(2, 0, v73);
          }
          dword_806C410 = v85;
          break;
        case 117:
          byte_806D149 = 1;
          break;
        case 121:
          if ( argv[optind + 0x3FFFFFFF] == optarg )
          {
            for ( j = optarg; (unsigned int)(*j - 48) <= 9; ++j )
              ;
            optind -= *j != 0;
            dword_806C25C = (int)&loc_8055501;
            sub_8062626(a1);
          }
          break;
        case 122:
          byte_806C38C = 0;
          break;
        case 128:
          if ( optarg )
          {
            v77 = (const char *)off_806C430;
            v76 = (const char *)1;
            v75 = "CCcgeneral-numeric";
            v48 = aCccgeneralNume[sub_805607B(a1, "--check", optarg, (int)off_8063DFC)];
          }
          else
          {
            v48 = 99;
          }
          v92 = v48;
LABEL_87:
          if ( v80 && v80 != v92 )
            sub_8054152((int)"cC");
          v80 = v92;
          break;
        case 129:
          if ( arg )
          {
            v4 = strcmp(arg, optarg) == 0;
            v49 = &loc_8054F17;
            if ( v4 )
              v49 = &loc_8054F3B;
            dword_806C2C0 = (int)v49;
            sub_806239B();
            v50 = gettext("multiple compress programs specified");
            error(2, 0, v50);
          }
          arg = optarg;
          break;
        case 130:
          byte_806D153 = 1;
          break;
        case 131:
          v97 = optarg;
          break;
        case 132:
          sub_804D08D(a1, (char)v92, (int)optarg, longind, v92, optarg);
          break;
        case 133:
LABEL_123:
          if ( v93 && strcmp(v93, optarg) )
          {
            v69 = gettext("multiple random sources specified");
            error(2, 0, v69);
          }
          v93 = optarg;
          break;
        case 134:
          v77 = (const char *)off_806C430;
          v76 = (const char *)1;
          v75 = byte_8063E60;
          v92 = byte_8063E60[sub_805607B(a1, "--sort", optarg, (int)&off_8063E44)];
LABEL_82:
          v88 = v92;
          v89 = 0;
          sub_80543E8(a1, v20, v21, &v88, (int)&s, 2);
          break;
        case 135:
          v94 = sub_804D576(longind, v92, optarg);
          break;
        default:
          sub_804BAE2(2);
          return;
      }
    }
  }
}
// 8061FAB: using guessed type int sub_8061FAB(void);
// 80620D8: using guessed type int __fastcall sub_80620D8(_DWORD, _DWORD);
// 8062148: using guessed type int __fastcall sub_8062148(_DWORD, _DWORD);
// 80621CD: using guessed type int __fastcall sub_80621CD(_DWORD, _DWORD);
// 8062323: using guessed type int sub_8062323(void);
// 8062420: using guessed type int sub_8062420(void);
// 80624B3: using guessed type int sub_80624B3(void);
// 80625B6: using guessed type int __fastcall sub_80625B6(_DWORD, _DWORD);
// 8062626: using guessed type int __usercall sub_8062626@<eax>(double@<st0>);
// 8062704: using guessed type int __fastcall sub_8062704(_DWORD, _DWORD);
// 80627EE: using guessed type int __fastcall sub_80627EE(_DWORD, _DWORD);
// 8063DFC: using guessed type char *off_8063DFC[3];
// 8063E44: using guessed type void *off_8063E44;
// 806C20C: using guessed type int dword_806C20C;
// 806C234: using guessed type int dword_806C234;
// 806C25C: using guessed type int dword_806C25C;
// 806C270: using guessed type int dword_806C270;
// 806C298: using guessed type int dword_806C298;
// 806C2AC: using guessed type int dword_806C2AC;
// 806C2C0: using guessed type int dword_806C2C0;
// 806C2D4: using guessed type int dword_806C2D4;
// 806C310: using guessed type int dword_806C310;
// 806C324: using guessed type int dword_806C324;
// 806C338: using guessed type int dword_806C338;
// 806C358: using guessed type int dword_806C358;
// 806C38C: using guessed type char byte_806C38C;
// 806C410: using guessed type int dword_806C410;
// 806C4C0: using guessed type int optind;
// 806CD17: using guessed type int dword_806CD17;
// 806CD1B: using guessed type int dword_806CD1B;
// 806CD1F: using guessed type char byte_806CD1F;
// 806CD20: using guessed type char byte_806CD20;
// 806D148: using guessed type char byte_806D148;
// 806D149: using guessed type char byte_806D149;
// 806D14A: using guessed type char byte_806D14A;
// 806D153: using guessed type char byte_806D153;

//----- (08055506) --------------------------------------------------------
#error "805558E: call analysis failed (funcsize=405)"

//----- (08055D8F) --------------------------------------------------------
void __noreturn sub_8055D8F()
{
  sub_804BAE2(1);
}

//----- (08055DA3) --------------------------------------------------------
int __cdecl sub_8055DA3(char *s, int a2)
{
  int v2; // ecx
  void *v3; // eax

  strlen(s);
  v3 = &loc_8055E9D;
  if ( *(_DWORD *)a2 )
    v3 = &loc_8055DCE;
  dword_806C284 = (int)v3;
  sub_806253E(v2, 0);
  dword_806C248 = (int)&loc_8055EC3;
  sub_8062696();
  return -2;
}
// 8055DA3: could not find valid save-restore pair for ebx
// 806253E: using guessed type int __fastcall sub_806253E(_DWORD, _DWORD);
// 8062696: using guessed type int sub_8062696(void);
// 806C248: using guessed type int dword_806C248;
// 806C284: using guessed type int dword_806C284;

//----- (08055EC8) --------------------------------------------------------
void __usercall __noreturn sub_8055EC8(double a1@<st0>, char *a2, int a3, int a4)
{
  if ( a4 == -1 )
    gettext("invalid argument %s for %s");
  else
    gettext("ambiguous argument %s for %s");
  sub_805C54D(a1, 1, a2);
  sub_805C0E3(0, 8);
}

//----- (08055F4B) --------------------------------------------------------
int __usercall sub_8055F4B@<eax>(double a1@<st0>, int a2, int a3, size_t n)
{
  FILE *v4; // ebx
  char *v5; // eax
  bool v6; // zf
  void *v7; // eax
  void *v8; // eax
  int i; // [esp+18h] [ebp-10h]
  void *s1; // [esp+1Ch] [ebp-Ch]

  s1 = 0;
  v4 = stderr;
  v5 = gettext("Valid arguments are:");
  fputs_unlocked(v5, v4);
  for ( i = 0; *(_DWORD *)(4 * i + a2); ++i )
  {
    if ( i )
    {
      v6 = memcmp(s1, (const void *)(a3 + i * n), n) == 0;
      v7 = &loc_8055FCA;
      if ( v6 )
        v7 = &loc_8056010;
      dword_806C2FC = (int)v7;
      sub_806223F();
    }
    v8 = sub_805C56F(a1, *(char **)(4 * i + a2));
    fprintf(stderr, "\n  - %s", v8);
    s1 = (void *)(i * n + a3);
  }
  return putc_unlocked(10, stderr);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 806223F: using guessed type int sub_806223F(void);
// 806C2FC: using guessed type int dword_806C2FC;

//----- (0805607B) --------------------------------------------------------
int __usercall sub_805607B@<eax>(double a1@<st0>, void *s1, char *s, int a4)
{
  int v5; // [esp+1Ch] [ebp-Ch]

  v5 = sub_8055DA3(s, a4);
  if ( v5 < 0 )
    sub_8055EC8(a1, (char *)s1, (int)s, v5);
  return v5;
}

//----- (080561A8) --------------------------------------------------------
int __usercall sub_80561A8@<eax>(double a1@<st0>)
{
  void *v1; // ebx
  int *v2; // eax
  int *v3; // eax
  int result; // eax
  char *v5; // [esp+2Ch] [ebp-Ch]

  if ( sub_8060C6F(a1, stdout) && (byte_806D29F != 1 || *__errno_location() != 32) )
  {
    v5 = gettext("write error");
    if ( dword_806D29B )
    {
      v1 = sub_805C2D6(a1, (char *)dword_806D29B);
      v2 = __errno_location();
      error(0, *v2, "%s: %s", v1, v5);
    }
    else
    {
      v3 = __errno_location();
      error(0, *v3, "%s", v5);
    }
    _exit(status);
  }
  result = sub_8060C6F(a1, stderr);
  if ( result )
    _exit(status);
  return result;
}
// 806D29B: using guessed type int dword_806D29B;
// 806D29F: using guessed type char byte_806D29F;

//----- (0805628C) --------------------------------------------------------
_DWORD *__cdecl sub_805628C(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 1732584193;
  a1[1] = -271733879;
  a1[2] = -1732584194;
  a1[3] = 271733878;
  a1[5] = 0;
  a1[4] = a1[5];
  result = a1;
  a1[6] = 0;
  return result;
}

//----- (080562D8) --------------------------------------------------------
_DWORD *__cdecl sub_80562D8(_DWORD *a1, int a2)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = a2;
  return result;
}

//----- (080562E5) --------------------------------------------------------
_DWORD *__cdecl sub_80562E5(int *a1, _DWORD *a2)
{
  sub_80562D8(a2, *a1);
  sub_80562D8(a2 + 1, a1[1]);
  sub_80562D8(a2 + 2, a1[2]);
  sub_80562D8(a2 + 3, a1[3]);
  return a2;
}

//----- (08056352) --------------------------------------------------------
_DWORD *__cdecl sub_8056352(int *a1, _DWORD *a2)
{
  unsigned int v3; // [esp+18h] [ebp-10h]
  int v4; // [esp+1Ch] [ebp-Ch]

  v3 = a1[6];
  if ( v3 <= 0x37 )
  {
    dword_806C220 = (int)&loc_8056388;
    sub_806277E();
  }
  v4 = 32;
  a1[4] += v3;
  if ( a1[4] < v3 )
    ++a1[5];
  a1[v4 + 5] = 8 * a1[4];
  a1[v4 + 6] = *((_QWORD *)a1 + 2) >> 29;
  memcpy((char *)a1 + v3 + 28, &unk_8064D50, 4 * (v4 + 1073741822) - v3);
  sub_80568D9(a1 + 7, 4 * v4, a1);
  return sub_80562E5(a1, a2);
}
// 806277E: using guessed type int sub_806277E(void);
// 806C220: using guessed type int dword_806C220;

//----- (0805664E) --------------------------------------------------------
int __usercall sub_805664E@<eax>(size_t a1@<edx>, int a2@<ecx>, void *src, size_t a4, int a5)
{
  int result; // eax
  int v6; // eax
  void *v7; // eax
  int *v8; // eax
  int v9; // edx
  int v10; // ecx
  int v11; // edx
  int v12; // ecx
  size_t v13; // [esp+14h] [ebp-14h]
  int v14; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]

  result = *(_DWORD *)(a5 + 24);
  if ( result )
  {
    v14 = *(_DWORD *)(a5 + 24);
    v6 = a4;
    if ( 128 - v14 <= a4 )
      v6 = 128 - v14;
    n = v6;
    memcpy((void *)(v14 + a5 + 28), src, v6);
    a1 = n + *(_DWORD *)(a5 + 24);
    *(_DWORD *)(a5 + 24) = a1;
    if ( *(_DWORD *)(a5 + 24) > 0x40u )
    {
      sub_80568D9((int *)(a5 + 28), *(_DWORD *)(a5 + 24) & 0xFFFFFFC0, (int *)a5);
      goto LABEL_17;
    }
    src = (char *)src + n;
    result = n;
    a4 -= n;
  }
  if ( a4 > 0x3F )
  {
    v7 = &loc_8056774;
    if ( !((unsigned __int8)src & 3) )
      v7 = &loc_80567CF;
    dword_806C284 = (int)v7;
    sub_806253E(a2, a1);
    while ( a4 > 0x40 )
    {
      v8 = (int *)memcpy((void *)(a5 + 28), src, 0x40u);
      sub_80568D9(v8, 0x40u, (int *)a5);
      src = (char *)src + 64;
      a4 -= 64;
    }
    dword_806C248 = (int)&loc_80567FA;
    sub_8062696();
    sub_80568D9((int *)src, a4 & 0xFFFFFFC0, (int *)a5);
    result = a4 & 0xFFFFFFC0;
    src = (char *)src + (a4 & 0xFFFFFFC0);
    a4 &= 0x3Fu;
  }
  if ( a4 )
  {
    v13 = *(_DWORD *)(a5 + 24);
    memcpy((void *)(v13 + a5 + 28), src, a4);
    v13 += a4;
    if ( v13 <= 0x3F )
    {
LABEL_18:
      result = a5;
      *(_DWORD *)(a5 + 24) = v13;
      return result;
    }
    sub_80568D9((int *)(a5 + 28), 0x40u, (int *)a5);
    dword_806C338 = (int)&loc_80566E7;
    sub_80620D8(v10, v9);
LABEL_17:
    *(_DWORD *)(a5 + 24) &= 0x3Fu;
    memcpy((void *)(a5 + 28), (const void *)(a5 + 28 + ((v14 + n) & 0xFFFFFFC0)), *(_DWORD *)(a5 + 24));
    dword_806C310 = (int)&loc_805673B;
    sub_80621CD(v12, v11);
    goto LABEL_18;
  }
  return result;
}
// 80620D8: using guessed type int __fastcall sub_80620D8(_DWORD, _DWORD);
// 80621CD: using guessed type int __fastcall sub_80621CD(_DWORD, _DWORD);
// 806253E: using guessed type int __fastcall sub_806253E(_DWORD, _DWORD);
// 8062696: using guessed type int sub_8062696(void);
// 806C248: using guessed type int dword_806C248;
// 806C284: using guessed type int dword_806C284;
// 806C310: using guessed type int dword_806C310;
// 806C338: using guessed type int dword_806C338;

//----- (080568D9) --------------------------------------------------------
int *__cdecl sub_80568D9(int *a1, unsigned int a2, int *a3)
{
  int v3; // ST30_4
  int v4; // ST34_4
  int v5; // ST38_4
  int v6; // ST3C_4
  int v7; // ST40_4
  int v8; // ST10_4
  int *v9; // ST0C_4
  int v10; // ST10_4
  int v11; // ST44_4
  int v12; // ST1C_4
  int v13; // ST48_4
  int v14; // ST18_4
  int v15; // ST4C_4
  int v16; // ST14_4
  int v17; // ST50_4
  int v18; // ST10_4
  int v19; // ST54_4
  int v20; // ST1C_4
  int v21; // ST58_4
  int v22; // ST18_4
  int v23; // ST5C_4
  int v24; // ST14_4
  int v25; // ST60_4
  int v26; // ST10_4
  int v27; // ST64_4
  int v28; // ST1C_4
  int v29; // ST68_4
  int v30; // ST18_4
  int v31; // ST6C_4
  int v32; // ST14_4
  int v33; // ST70_4
  int v34; // ST10_4
  int v35; // ST74_4
  int v36; // ST1C_4
  int v37; // ST78_4
  int v38; // ST18_4
  int v39; // ST7C_4
  int v40; // ST14_4
  int v41; // ST10_4
  int v42; // ST1C_4
  int v43; // ST18_4
  int v44; // ST14_4
  int v45; // ST10_4
  int v46; // ST1C_4
  int v47; // ST18_4
  int v48; // ST14_4
  int v49; // ST10_4
  int v50; // ST1C_4
  int v51; // ST18_4
  int v52; // ST14_4
  int v53; // ST10_4
  int v54; // ST1C_4
  int v55; // ST18_4
  int v56; // ST14_4
  int v57; // ST10_4
  int v58; // ST1C_4
  int v59; // ST18_4
  int v60; // ST14_4
  int v61; // ST10_4
  int v62; // ST1C_4
  int v63; // ST18_4
  int v64; // ST14_4
  int v65; // ST10_4
  int v66; // ST1C_4
  int v67; // ST18_4
  int v68; // ST14_4
  int v69; // ST10_4
  int v70; // ST1C_4
  int v71; // ST18_4
  int v72; // ST14_4
  int v73; // ST10_4
  int v74; // ST1C_4
  int v75; // ST18_4
  int v76; // ST14_4
  int v77; // ST10_4
  int v78; // ST1C_4
  int v79; // ST18_4
  int v80; // ST14_4
  int v81; // ST10_4
  int v82; // ST1C_4
  int v83; // ST18_4
  int v84; // ST14_4
  int v85; // ST10_4
  int v86; // ST1C_4
  int v87; // ST18_4
  int v88; // ST14_4
  int *result; // eax
  int *v90; // [esp+Ch] [ebp-74h]
  int v91; // [esp+10h] [ebp-70h]
  int v92; // [esp+14h] [ebp-6Ch]
  int v93; // [esp+18h] [ebp-68h]
  int v94; // [esp+1Ch] [ebp-64h]

  v90 = a1;
  v91 = *a3;
  v92 = a3[1];
  v93 = a3[2];
  v94 = a3[3];
  a3[4] += a2;
  a3[5] += a3[4] < a2;
  while ( v90 < &a1[a2 >> 2] )
  {
    v3 = v91;
    v4 = v92;
    v5 = v93;
    v6 = v94;
    v7 = *v90;
    v8 = (v94 ^ v92 & (v93 ^ v94)) + *v90 + v91 - 680876936;
    v9 = v90 + 1;
    v10 = v92 + __ROR4__(v8, 25);
    v11 = *v9;
    ++v9;
    v12 = v10 + __ROR4__((v93 ^ v10 & (v92 ^ v93)) + v11 + v94 - 389564586, 20);
    v13 = *v9;
    ++v9;
    v14 = v12 + __ROR4__((v92 ^ v12 & (v10 ^ v92)) + v13 + v93 + 606105819, 15);
    v15 = *v9;
    ++v9;
    v16 = v14 + __ROR4__((v10 ^ v14 & (v12 ^ v10)) + v15 + v92 - 1044525330, 10);
    v17 = *v9;
    ++v9;
    v18 = v16 + __ROR4__((v12 ^ v16 & (v14 ^ v12)) + v17 + v10 - 176418897, 25);
    v19 = *v9;
    ++v9;
    v20 = v18 + __ROR4__((v14 ^ v18 & (v16 ^ v14)) + v19 + v12 + 1200080426, 20);
    v21 = *v9;
    ++v9;
    v22 = v20 + __ROR4__((v16 ^ v20 & (v18 ^ v16)) + v21 + v14 - 1473231341, 15);
    v23 = *v9;
    ++v9;
    v24 = v22 + __ROR4__((v18 ^ v22 & (v20 ^ v18)) + v23 + v16 - 45705983, 10);
    v25 = *v9;
    ++v9;
    v26 = v24 + __ROR4__((v20 ^ v24 & (v22 ^ v20)) + v25 + v18 + 1770035416, 25);
    v27 = *v9;
    ++v9;
    v28 = v26 + __ROR4__((v22 ^ v26 & (v24 ^ v22)) + v27 + v20 - 1958414417, 20);
    v29 = *v9;
    ++v9;
    v30 = v28 + __ROR4__((v24 ^ v28 & (v26 ^ v24)) + v29 + v22 - 42063, 15);
    v31 = *v9;
    ++v9;
    v32 = v30 + __ROR4__((v26 ^ v30 & (v28 ^ v26)) + v31 + v24 - 1990404162, 10);
    v33 = *v9;
    ++v9;
    v34 = v32 + __ROR4__((v28 ^ v32 & (v30 ^ v28)) + v33 + v26 + 1804603682, 25);
    v35 = *v9;
    ++v9;
    v36 = v34 + __ROR4__((v30 ^ v34 & (v32 ^ v30)) + v35 + v28 - 40341101, 20);
    v37 = *v9;
    ++v9;
    v38 = v36 + __ROR4__((v32 ^ v36 & (v34 ^ v32)) + v37 + v30 - 1502002290, 15);
    v39 = *v9;
    v90 = v9 + 1;
    v40 = v38 + __ROR4__((v34 ^ v38 & (v36 ^ v34)) + v39 + v32 + 1236535329, 10);
    v41 = v40 + __ROR4__(v11 + (v38 ^ v36 & (v40 ^ v38)) + v34 - 165796510, 27);
    v42 = v41 + __ROR4__(v21 + (v40 ^ v38 & (v41 ^ v40)) + v36 - 1069501632, 23);
    v43 = v42 + __ROR4__(v31 + (v41 ^ v40 & (v42 ^ v41)) + v38 + 643717713, 18);
    v44 = v43 + __ROR4__(v7 + (v42 ^ v41 & (v43 ^ v42)) + v40 - 373897302, 12);
    v45 = v44 + __ROR4__(v19 + (v43 ^ v42 & (v44 ^ v43)) + v41 - 701558691, 27);
    v46 = v45 + __ROR4__(v29 + (v44 ^ v43 & (v45 ^ v44)) + v42 + 38016083, 23);
    v47 = v46 + __ROR4__(v39 + (v45 ^ v44 & (v46 ^ v45)) + v43 - 660478335, 18);
    v48 = v47 + __ROR4__(v17 + (v46 ^ v45 & (v47 ^ v46)) + v44 - 405537848, 12);
    v49 = v48 + __ROR4__(v27 + (v47 ^ v46 & (v48 ^ v47)) + v45 + 568446438, 27);
    v50 = v49 + __ROR4__(v37 + (v48 ^ v47 & (v49 ^ v48)) + v46 - 1019803690, 23);
    v51 = v50 + __ROR4__(v15 + (v49 ^ v48 & (v50 ^ v49)) + v47 - 187363961, 18);
    v52 = v51 + __ROR4__(v25 + (v50 ^ v49 & (v51 ^ v50)) + v48 + 1163531501, 12);
    v53 = v52 + __ROR4__(v35 + (v51 ^ v50 & (v52 ^ v51)) + v49 - 1444681467, 27);
    v54 = v53 + __ROR4__(v13 + (v52 ^ v51 & (v53 ^ v52)) + v50 - 51403784, 23);
    v55 = v54 + __ROR4__(v23 + (v53 ^ v52 & (v54 ^ v53)) + v51 + 1735328473, 18);
    v56 = v55 + __ROR4__(v33 + (v54 ^ v53 & (v55 ^ v54)) + v52 - 1926607734, 12);
    v57 = v56 + __ROR4__(v19 + (v54 ^ v56 ^ v55) + v53 - 378558, 28);
    v58 = v57 + __ROR4__(v25 + (v55 ^ v57 ^ v56) + v54 - 2022574463, 21);
    v59 = v58 + __ROR4__(v31 + (v56 ^ v58 ^ v57) + v55 + 1839030562, 16);
    v60 = v59 + __ROR4__(v37 + (v57 ^ v59 ^ v58) + v56 - 35309556, 9);
    v61 = v60 + __ROR4__(v11 + (v58 ^ v60 ^ v59) + v57 - 1530992060, 28);
    v62 = v61 + __ROR4__(v17 + (v59 ^ v61 ^ v60) + v58 + 1272893353, 21);
    v63 = v62 + __ROR4__(v23 + (v60 ^ v62 ^ v61) + v59 - 155497632, 16);
    v64 = v63 + __ROR4__(v29 + (v61 ^ v63 ^ v62) + v60 - 1094730640, 9);
    v65 = v64 + __ROR4__(v35 + (v62 ^ v64 ^ v63) + v61 + 681279174, 28);
    v66 = v65 + __ROR4__(v7 + (v63 ^ v65 ^ v64) + v62 - 358537222, 21);
    v67 = v66 + __ROR4__(v15 + (v64 ^ v66 ^ v65) + v63 - 722521979, 16);
    v68 = v67 + __ROR4__(v21 + (v65 ^ v67 ^ v66) + v64 + 76029189, 9);
    v69 = v68 + __ROR4__(v27 + (v66 ^ v68 ^ v67) + v65 - 640364487, 28);
    v70 = v69 + __ROR4__(v33 + (v67 ^ v69 ^ v68) + v66 - 421815835, 21);
    v71 = v70 + __ROR4__(v39 + (v68 ^ v70 ^ v69) + v67 + 530742520, 16);
    v72 = v71 + __ROR4__(v13 + (v69 ^ v71 ^ v70) + v68 - 995338651, 9);
    v73 = v72 + __ROR4__(v7 + (v71 ^ (v72 | ~v70)) + v69 - 198630844, 26);
    v74 = v73 + __ROR4__(v23 + (v72 ^ (v73 | ~v71)) + v70 + 1126891415, 22);
    v75 = v74 + __ROR4__(v37 + (v73 ^ (v74 | ~v72)) + v71 - 1416354905, 17);
    v76 = v75 + __ROR4__(v19 + (v74 ^ (v75 | ~v73)) + v72 - 57434055, 11);
    v77 = v76 + __ROR4__(v33 + (v75 ^ (v76 | ~v74)) + v73 + 1700485571, 26);
    v78 = v77 + __ROR4__(v15 + (v76 ^ (v77 | ~v75)) + v74 - 1894986606, 22);
    v79 = v78 + __ROR4__(v29 + (v77 ^ (v78 | ~v76)) + v75 - 1051523, 17);
    v80 = v79 + __ROR4__(v11 + (v78 ^ (v79 | ~v77)) + v76 - 2054922799, 11);
    v81 = v80 + __ROR4__(v25 + (v79 ^ (v80 | ~v78)) + v77 + 1873313359, 26);
    v82 = v81 + __ROR4__(v39 + (v80 ^ (v81 | ~v79)) + v78 - 30611744, 22);
    v83 = v82 + __ROR4__(v21 + (v81 ^ (v82 | ~v80)) + v79 - 1560198380, 17);
    v84 = v83 + __ROR4__(v35 + (v82 ^ (v83 | ~v81)) + v80 + 1309151649, 11);
    v85 = v84 + __ROR4__(v17 + (v83 ^ (v84 | ~v82)) + v81 - 145523070, 26);
    v86 = v85 + __ROR4__(v31 + (v84 ^ (v85 | ~v83)) + v82 - 1120210379, 22);
    v87 = v86 + __ROR4__(v13 + (v85 ^ (v86 | ~v84)) + v83 + 718787259, 17);
    v88 = v87 + __ROR4__(v27 + (v86 ^ (v87 | ~v85)) + v84 - 343485551, 11);
    v91 = v3 + v85;
    v92 = v4 + v88;
    v93 = v5 + v87;
    v94 = v6 + v86;
  }
  *a3 = v91;
  a3[1] = v92;
  a3[2] = v93;
  result = a3;
  a3[3] = v94;
  return result;
}

//----- (080575A3) --------------------------------------------------------
int __cdecl sub_80575A3(int a1, int a2, int a3, int a4, int a5, int a6)
{
  return posix_fadvise64(a1, a2, a3, a4, a5, a6);
}
// 8049E60: using guessed type int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (080575F4) --------------------------------------------------------
int __usercall sub_80575F4@<eax>(int a1@<edx>, int a2@<ecx>, FILE *stream, int a4)
{
  void *v4; // eax
  int v5; // eax

  v4 = &loc_8057619;
  if ( !stream )
    v4 = &locret_8057653;
  dword_806C338 = (int)v4;
  sub_80620D8(a2, a1);
  v5 = fileno(stream);
  return sub_80575A3(v5, 0, 0, 0, 0, a4);
}
// 80620D8: using guessed type int __fastcall sub_80620D8(_DWORD, _DWORD);
// 806C338: using guessed type int dword_806C338;

//----- (08057655) --------------------------------------------------------
int __cdecl sub_8057655(_BYTE **a1)
{
  void *v1; // eax

  v1 = &loc_8057729;
  if ( **a1 )
    v1 = &loc_805766B;
  dword_806C2FC = (int)v1;
  sub_806223F();
  return 0;
}
// 806223F: using guessed type int sub_806223F(void);
// 806C2FC: using guessed type int dword_806C2FC;

//----- (08057754) --------------------------------------------------------
signed int __cdecl sub_8057754(unsigned __int8 a1)
{
  void *v2; // eax
  unsigned __int8 v3; // [esp+Ch] [ebp-Ch]

  v3 = a1;
  if ( (unsigned __int8)sub_8060A7F(a1) )
    return 0;
  if ( (unsigned __int8)sub_80609C9(v3) )
  {
    dword_806C2C0 = (int)&locret_80577F2;
    sub_806239B();
  }
  v2 = &loc_80577E5;
  if ( v3 != 126 )
    v2 = &loc_80577E9;
  dword_806C2AC = (int)v2;
  sub_8062420();
  return -1;
}
// 8062420: using guessed type int sub_8062420(void);
// 806C2AC: using guessed type int dword_806C2AC;
// 806C2C0: using guessed type int dword_806C2C0;

//----- (080577F4) --------------------------------------------------------
int __usercall sub_80577F4@<eax>(int a1@<edx>, int a2@<ecx>, double a3@<st0>, int a4, unsigned int a5, int a6, unsigned int a7)
{
  signed int v7; // eax
  void *v8; // eax
  void *v10; // eax
  signed int i; // eax
  int v12; // [esp+0h] [ebp-38h]
  unsigned int v13; // [esp+1Ch] [ebp-1Ch]
  unsigned int v14; // [esp+20h] [ebp-18h]
  int v15; // [esp+24h] [ebp-14h]
  int v16; // [esp+28h] [ebp-10h]
  int v17; // [esp+2Ch] [ebp-Ch]

  v13 = 0;
  v14 = 0;
  if ( v13 < a5 || v14 < a7 )
  {
    v15 = 0;
    goto LABEL_14;
  }
  dword_806C220 = (int)&loc_8057A49;
  for ( i = sub_806277E(); ; i = sub_8057754(v12) )
  {
    v17 = i;
    if ( v16 != i )
      return v16 - v17;
    ++v13;
    ++v14;
LABEL_14:
    if ( v13 >= a5 )
      goto LABEL_40;
    v12 = *(char *)(a4 + v13);
    if ( !((unsigned __int8)sub_8060A7F(v12) ^ 1) )
    {
LABEL_40:
      if ( v14 >= a7 )
        break;
      v12 = *(char *)(a6 + v14);
      if ( !((unsigned __int8)sub_8060A7F(v12) ^ 1) )
        break;
    }
    if ( v13 == a5 )
    {
      v7 = 0;
    }
    else
    {
      v12 = *(unsigned __int8 *)(a4 + v13);
      v7 = sub_8057754(v12);
    }
    v16 = v7;
    v8 = &loc_8057862;
    if ( v14 == a7 )
      v8 = &loc_8057898;
    dword_806C2FC = (int)v8;
    sub_806223F();
    v12 = *(unsigned __int8 *)(a6 + v14);
  }
  dword_806C324 = (int)&loc_805792C;
  sub_8062148(a2, a1);
  do
    ++v13;
  while ( *(_BYTE *)(a4 + v13) == 48 );
  while ( *(_BYTE *)(a6 + v14) == 48 )
    ++v14;
  while ( 1 )
  {
    v12 = *(char *)(a4 + v13);
    if ( !(unsigned __int8)sub_8060A7F(v12) )
      break;
    v12 = *(char *)(a6 + v14);
    if ( !(unsigned __int8)sub_8060A7F(v12) )
      break;
    if ( !v15 )
      v15 = *(char *)(a4 + v13) - *(char *)(a6 + v14);
    ++v13;
    ++v14;
  }
  v12 = *(char *)(a4 + v13);
  if ( (unsigned __int8)sub_8060A7F(v12) )
    return 1;
  v12 = *(char *)(a6 + v14);
  if ( (unsigned __int8)sub_8060A7F(v12) )
    return -1;
  v10 = &loc_8057A18;
  if ( !v15 )
    v10 = &loc_8057A1D;
  dword_806C25C = (int)v10;
  sub_8062626(a3);
  return v15;
}
// 80577F4: could not find valid save-restore pair for ebx
// 8062148: using guessed type int __fastcall sub_8062148(_DWORD, _DWORD);
// 806223F: using guessed type int sub_806223F(void);
// 8062626: using guessed type int __usercall sub_8062626@<eax>(double@<st0>);
// 806277E: using guessed type int sub_806277E(void);
// 806C220: using guessed type int dword_806C220;
// 806C25C: using guessed type int dword_806C25C;
// 806C2FC: using guessed type int dword_806C2FC;
// 806C324: using guessed type int dword_806C324;

//----- (08057A50) --------------------------------------------------------
int __cdecl sub_8057A50(char *s1, char *s2)
{
  void *v3; // eax

  if ( !strcmp(s1, s2) )
    return 0;
  v3 = &loc_8057A9E;
  if ( *s1 )
    v3 = &loc_8057AA8;
  dword_806C298 = (int)v3;
  sub_80624B3();
  return -1;
}
// 80624B3: using guessed type int sub_80624B3(void);
// 806C298: using guessed type int dword_806C298;

//----- (08057CFE) --------------------------------------------------------
int __cdecl sub_8057CFE(int category)
{
  bool v1; // zf
  void *v2; // eax
  unsigned __int8 v4; // [esp+1Bh] [ebp-Dh]
  const char *s1; // [esp+1Ch] [ebp-Ch]

  v4 = 1;
  s1 = setlocale(category, 0);
  if ( s1 )
  {
    if ( strcmp(s1, "C") )
    {
      v1 = strcmp(s1, "POSIX") == 0;
      v2 = &loc_8057D56;
      if ( !v1 )
        v2 = &loc_8057D77;
      dword_806C220 = (int)v2;
      sub_806277E();
    }
    v4 = 0;
  }
  return v4;
}
// 806277E: using guessed type int sub_806277E(void);
// 806C220: using guessed type int dword_806C220;

//----- (08057D7D) --------------------------------------------------------
int __cdecl sub_8057D7D(int a1)
{
  return *(_DWORD *)(a1 + 8);
}

//----- (08057D88) --------------------------------------------------------
int __cdecl sub_8057D88(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (08057D93) --------------------------------------------------------
int __cdecl sub_8057D93(int a1)
{
  return *(_DWORD *)(a1 + 16);
}

//----- (08057D9E) --------------------------------------------------------
unsigned int __cdecl sub_8057D9E(int a1)
{
  _DWORD *i; // [esp+0h] [ebp-10h]
  unsigned int v3; // [esp+4h] [ebp-Ch]
  _DWORD *v4; // [esp+8h] [ebp-8h]
  unsigned int j; // [esp+Ch] [ebp-4h]

  v3 = 0;
  for ( i = *(_DWORD **)a1; *(_DWORD *)(a1 + 4) > (unsigned int)i; i += 2 )
  {
    if ( *i )
    {
      v4 = i;
      for ( j = 1; ; ++j )
      {
        v4 = (_DWORD *)v4[1];
        if ( !v4 )
          break;
      }
      if ( j > v3 )
        v3 = j;
    }
  }
  return v3;
}

//----- (08057F85) --------------------------------------------------------
int __cdecl sub_8057F85(int a1, int a2)
{
  unsigned int v3; // [esp+1Ch] [ebp-Ch]

  v3 = (*(int (__cdecl **)(int, _DWORD))(a1 + 24))(a2, *(_DWORD *)(a1 + 8));
  if ( *(_DWORD *)(a1 + 8) <= v3 )
    abort();
  return 8 * v3 + *(_DWORD *)a1;
}

//----- (08058314) --------------------------------------------------------
bool __usercall sub_8058314@<al>(int edx0@<edx>, int a2@<ecx>, unsigned int a1)
{
  unsigned int v4; // [esp+8h] [ebp-8h]
  unsigned int v5; // [esp+Ch] [ebp-4h]

  v4 = 3;
  v5 = 9;
  dword_806C310 = (int)&loc_8058368;
  sub_80621CD(a2, edx0);
  do
  {
    v5 += 4 * ++v4;
    ++v4;
    if ( v5 >= a1 )
      break;
    dword_806C298 = (int)&loc_8058355;
    sub_80624B3();
  }
  while ( a1 % v4 );
  return a1 % v4 != 0;
}
// 80621CD: using guessed type int __fastcall sub_80621CD(_DWORD, _DWORD);
// 80624B3: using guessed type int sub_80624B3(void);
// 806C298: using guessed type int dword_806C298;
// 806C310: using guessed type int dword_806C310;

//----- (080583A5) --------------------------------------------------------
unsigned int __cdecl sub_80583A5(unsigned int a1)
{
  void *v1; // eax
  int v2; // edx
  int v3; // ecx
  unsigned int i; // [esp+14h] [ebp+8h]

  if ( a1 <= 9 )
    a1 = 10;
  for ( i = a1 | 1; ; i += 2 )
  {
    v1 = &loc_80583E1;
    if ( i == -1 )
      v1 = &loc_8058470;
    dword_806C2C0 = (int)v1;
    sub_806239B();
    if ( sub_8058314(v2, v3, i) )
      break;
  }
  return i;
}
// 806C2C0: using guessed type int dword_806C2C0;

//----- (08058487) --------------------------------------------------------
bool __cdecl sub_8058487(int a1, int a2)
{
  return a1 == a2;
}

//----- (08058495) --------------------------------------------------------
signed int __cdecl sub_8058495(int a1)
{
  int v2; // [esp+8h] [ebp-8h]

  v2 = *(_DWORD *)(a1 + 20);
  if ( (_UNKNOWN *)v2 == &unk_8064DA0 )
    return 1;
  if ( *(float *)(v2 + 8) > 0.1
    && 1.0 - 0.1 > *(float *)(v2 + 8)
    && *(float *)(v2 + 12) > 0.1 + 1.0
    && *(float *)v2 >= 0.0
    && *(float *)(v2 + 4) > *(float *)v2 + 0.1
    && *(float *)(v2 + 4) <= 1.0
    && *(float *)(v2 + 8) > *(float *)v2 + 0.1 )
  {
    return 1;
  }
  *(_DWORD *)(a1 + 20) = &unk_8064DA0;
  return 0;
}

//----- (08058594) --------------------------------------------------------
unsigned int __cdecl sub_8058594(unsigned int a1, int a2)
{
  unsigned int result; // eax
  float v3; // [esp+20h] [ebp-4h]
  unsigned int v4; // [esp+2Ch] [ebp+8h]

  if ( *(_BYTE *)(a2 + 16) != 1 )
  {
    v3 = (long double)a1 / *(float *)(a2 + 8);
    if ( v3 >= 4294967300.0 )
      return 0;
    a1 = (signed __int64)v3;
  }
  v4 = sub_80583A5(a1);
  if ( v4 <= 0x1FFFFFFF )
    result = v4;
  else
    result = 0;
  return result;
}

//----- (08058621) --------------------------------------------------------
int __usercall sub_8058621@<eax>(int a1@<edx>, int a2@<ecx>, double a3@<st0>, int a4, int a5, int a6)
{
  void *v6; // eax
  bool v7; // zf
  void *v8; // eax

  v6 = &loc_8058646;
  if ( a6 )
    v6 = &loc_805864D;
  dword_806C338 = (int)v6;
  sub_80620D8(a2, a1);
  v7 = malloc(0x28u) == 0;
  v8 = &loc_8058688;
  if ( !v7 )
    v8 = &loc_8058692;
  dword_806C25C = (int)v8;
  sub_8062626(a3);
  return 0;
}
// 8058621: could not find valid save-restore pair for ebx
// 80620D8: using guessed type int __fastcall sub_80620D8(_DWORD, _DWORD);
// 8062626: using guessed type int __usercall sub_8062626@<eax>(double@<st0>);
// 806C25C: using guessed type int dword_806C25C;
// 806C338: using guessed type int dword_806C338;

//----- (080589CB) --------------------------------------------------------
int __usercall sub_80589CB@<eax>(int edx0@<edx>, int a2@<ecx>, int a1)
{
  void *v3; // eax
  int v4; // ST24_4

  v3 = &loc_80589F4;
  if ( !*(_DWORD *)(a1 + 36) )
    v3 = &loc_8058A0B;
  dword_806C338 = (int)v3;
  sub_80620D8(a2, edx0);
  v4 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(v4 + 4);
  return v4;
}
// 80620D8: using guessed type int __fastcall sub_80620D8(_DWORD, _DWORD);
// 806C338: using guessed type int dword_806C338;

//----- (08058A2B) --------------------------------------------------------
int __cdecl sub_8058A2B(int a1, _DWORD *a2)
{
  int result; // eax

  *a2 = 0;
  a2[1] = *(_DWORD *)(a1 + 36);
  result = a1;
  *(_DWORD *)(a1 + 36) = a2;
  return result;
}

//----- (08058A4E) --------------------------------------------------------
#error "8058B0D: call analysis failed (funcsize=93)"

//----- (08058C03) --------------------------------------------------------
signed int __cdecl sub_8058C03(int a1, int a2, char a3)
{
  int v3; // edx
  int v4; // ecx
  int v5; // eax
  bool v6; // zf
  void *v7; // eax
  char v9; // [esp+Ch] [ebp-2Ch]
  int *i; // [esp+18h] [ebp-20h]
  int *v11; // [esp+1Ch] [ebp-1Ch]
  int v12; // [esp+20h] [ebp-18h]
  _DWORD *v13; // [esp+24h] [ebp-14h]
  int *v14; // [esp+28h] [ebp-10h]
  int v15; // [esp+2Ch] [ebp-Ch]

  v9 = a3;
  for ( i = *(int **)a2; ; i += 2 )
  {
    if ( *(_DWORD *)(a2 + 4) <= (unsigned int)i )
      return 1;
    if ( *i )
    {
      v11 = (int *)i[1];
      dword_806C2FC = (int)&loc_8058DA2;
      sub_806223F();
      do
      {
        v12 = *v11;
        v13 = (_DWORD *)sub_8057F85(a1, v12);
        v14 = (int *)v11[1];
        if ( *v13 )
        {
          v11[1] = v13[1];
          v13[1] = v11;
        }
        else
        {
          *v13 = v12;
          ++*(_DWORD *)(a1 + 12);
          sub_8058A2B(a1, v11);
        }
        v11 = v14;
      }
      while ( v11 );
      v12 = *i;
      i[1] = 0;
      if ( !v9 )
        break;
    }
LABEL_16:
    ;
  }
  v13 = (_DWORD *)sub_8057F85(a1, v12);
  if ( !*v13 )
  {
    *v13 = v12;
    ++*(_DWORD *)(a1 + 12);
    *i = 0;
    --*(_DWORD *)(a2 + 12);
    goto LABEL_16;
  }
  v5 = sub_80589CB(v3, v4, a1);
  v15 = v5;
  v6 = v5 == 0;
  v7 = &loc_8058D48;
  if ( !v6 )
    v7 = &loc_8058D52;
  dword_806C2D4 = (int)v7;
  sub_8062323();
  return 0;
}
// 806223F: using guessed type int sub_806223F(void);
// 8062323: using guessed type int sub_8062323(void);
// 806C2D4: using guessed type int dword_806C2D4;
// 806C2FC: using guessed type int dword_806C2FC;

//----- (08058DDF) --------------------------------------------------------
signed int __cdecl sub_8058DDF(int a1, unsigned int a2)
{
  int v2; // edx
  int v3; // ecx
  void *v5; // eax
  unsigned int nmemb; // [esp+10h] [ebp-38h]

  nmemb = sub_8058594(a2, *(_DWORD *)(a1 + 20));
  if ( !nmemb )
    return 0;
  v5 = &loc_8058E31;
  if ( *(_DWORD *)(a1 + 8) != nmemb )
    v5 = &loc_8058E3B;
  dword_806C270 = (int)v5;
  sub_80625B6(v3, v2);
  return 1;
}
// 80625B6: using guessed type int __fastcall sub_80625B6(_DWORD, _DWORD);
// 806C270: using guessed type int dword_806C270;

//----- (08058FD4) --------------------------------------------------------
signed int __cdecl sub_8058FD4(unsigned int *a1, int a2, _DWORD *a3)
{
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  signed int result; // eax
  int v7; // edx
  void *v8; // eax
  int v9; // ecx
  int v10; // edx
  int *v11; // [esp+2Ch] [ebp-1Ch]
  int v12; // [esp+30h] [ebp-18h]
  unsigned int v13; // [esp+34h] [ebp-14h]
  float v14; // [esp+38h] [ebp-10h]
  int *v15; // [esp+3Ch] [ebp-Ch]

  if ( !a2 )
    abort();
  v12 = sub_8058A4E((int)a1, a2, &v11, 0);
  if ( v12 )
  {
    v5 = &loc_805902E;
    if ( !a3 )
      v5 = &loc_8059036;
    dword_806C284 = (int)v5;
    sub_806253E(v4, v3);
    *a3 = v12;
    result = 0;
  }
  else
  {
    v7 = 0;
    if ( (long double)a1[3] > *(float *)(a1[5] + 8) * (long double)a1[2] )
    {
      sub_8058495((int)a1);
      v7 = 0;
      if ( (long double)a1[3] > *(float *)(a1[5] + 8) * (long double)a1[2] )
      {
        v13 = a1[5];
        v8 = &loc_80590F6;
        if ( !*(_BYTE *)(v13 + 16) )
          v8 = &loc_8059114;
        dword_806C2D4 = (int)v8;
        sub_8062323();
        v14 = (long double)a1[2] * *(float *)(v13 + 12);
        if ( v14 >= 4294967300.0 )
          return -1;
        if ( (unsigned __int8)sub_8058DDF((int)a1, (signed __int64)v14) ^ 1 )
          return -1;
        if ( sub_8058A4E((int)a1, a2, &v11, 0) )
          abort();
      }
    }
    if ( *v11 )
    {
      v15 = (int *)sub_80589CB(v7, v4, (int)a1);
      if ( !v15 )
        return -1;
      *v15 = a2;
      v15[1] = v11[1];
      v11[1] = (int)v15;
      v10 = a1[4] + 1;
      a1[4] = v10;
      dword_806C270 = (int)&locret_8059256;
      sub_80625B6(v9, v10);
    }
    *v11 = a2;
    ++a1[4];
    ++a1[3];
    result = 1;
  }
  return result;
}
// 8062323: using guessed type int sub_8062323(void);
// 806253E: using guessed type int __fastcall sub_806253E(_DWORD, _DWORD);
// 80625B6: using guessed type int __fastcall sub_80625B6(_DWORD, _DWORD);
// 806C270: using guessed type int dword_806C270;
// 806C284: using guessed type int dword_806C284;
// 806C2D4: using guessed type int dword_806C2D4;

//----- (08059258) --------------------------------------------------------
int __cdecl sub_8059258(unsigned int *a1, int a2)
{
  int v2; // edx
  int v3; // ecx
  int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]

  v6 = sub_8058FD4(a1, a2, &v5);
  if ( v6 != -1 )
  {
    if ( !v6 )
      return v5;
    dword_806C310 = (int)&locret_80592B6;
    sub_80621CD(v3, v2);
  }
  return 0;
}
// 80621CD: using guessed type int __fastcall sub_80621CD(_DWORD, _DWORD);
// 806C310: using guessed type int dword_806C310;

//----- (080592B8) --------------------------------------------------------
int __cdecl sub_80592B8(int a1, int a2)
{
  long double v2; // fst7
  bool v3; // zf
  void *v4; // eax
  int v6; // [esp+0h] [ebp-48h]
  int v7; // [esp+4h] [ebp-44h]
  int v8; // [esp+8h] [ebp-40h]
  int v9; // [esp+Ch] [ebp-3Ch]
  int v10; // [esp+10h] [ebp-38h]
  int v11; // [esp+14h] [ebp-34h]
  int v12; // [esp+18h] [ebp-30h]
  int v13; // [esp+1Ch] [ebp-2Ch]
  int v14; // [esp+20h] [ebp-28h]
  int v15; // [esp+24h] [ebp-24h]
  _DWORD *v16; // [esp+28h] [ebp-20h]
  void *ptr; // [esp+2Ch] [ebp-1Ch]
  int v18; // [esp+30h] [ebp-18h]
  int v19; // [esp+34h] [ebp-14h]
  unsigned int v20; // [esp+38h] [ebp-10h]
  void *v21; // [esp+3Ch] [ebp-Ch]
  int v22; // [esp+40h] [ebp-8h]
  int v23; // [esp+44h] [ebp-4h]
  int savedregs; // [esp+48h] [ebp+0h]

  v18 = sub_8058A4E(a1, a2, &v16, 1);
  if ( !v18 )
  {
    dword_806C2E8 = (int)&locret_80594AD;
    sub_80622AD(v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, ptr, 0, v19, v20, v21, v22, v23, savedregs);
  }
  --*(_DWORD *)(a1 + 16);
  if ( !*v16
    && **(float **)(a1 + 20) * (long double)*(unsigned int *)(a1 + 8) > (long double)(unsigned int)--*(_DWORD *)(a1 + 12) )
  {
    sub_8058495(a1);
    if ( **(float **)(a1 + 20) * (long double)*(unsigned int *)(a1 + 8) > (long double)*(unsigned int *)(a1 + 12) )
    {
      v19 = *(_DWORD *)(a1 + 20);
      if ( *(_BYTE *)(v19 + 16) )
        v2 = (long double)*(unsigned int *)(a1 + 8) * *(float *)(v19 + 4);
      else
        v2 = (long double)*(unsigned int *)(a1 + 8) * *(float *)(v19 + 4) * *(float *)(v19 + 8);
      v20 = (signed __int64)v2;
      v3 = (unsigned __int8)sub_8058DDF(a1, v20) == 1;
      v4 = &loc_8059475;
      if ( v3 )
        v4 = &loc_80594AA;
      dword_806C25C = (int)v4;
      sub_8062626(*(double *)&v2);
      for ( ptr = *(void **)(a1 + 36); ptr; ptr = v21 )
      {
        v21 = (void *)*((_DWORD *)ptr + 1);
        free(ptr);
      }
      *(_DWORD *)(a1 + 36) = 0;
    }
  }
  return v18;
}
// 80622AD: using guessed type int __stdcall sub_80622AD(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8062626: using guessed type int __usercall sub_8062626@<eax>(double@<st0>);
// 806C25C: using guessed type int dword_806C25C;
// 806C2E8: using guessed type int dword_806C2E8;

//----- (080594AF) --------------------------------------------------------
_DWORD *__cdecl sub_80594AF(void *a1, unsigned int a2)
{
  void *v2; // eax
  _DWORD *v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_805EC7C(0x10u);
  if ( !a2 )
    a2 = 1;
  *v4 = sub_805EB56(a2, 4u);
  *(_DWORD *)*v4 = 0;
  v4[1] = a2;
  v4[2] = 0;
  if ( a1 )
    v2 = a1;
  else
    v2 = &loc_8059511;
  v4[3] = v2;
  return v4;
}

//----- (08059542) --------------------------------------------------------
void __cdecl sub_8059542(void *ptr)
{
  free(*(void **)ptr);
  free(ptr);
}

//----- (08059562) --------------------------------------------------------
int __cdecl sub_8059562(int a1, int a2)
{
  int v2; // ecx
  int v3; // ecx
  int v5; // edx

  if ( (unsigned int)(*(_DWORD *)(a1 + 4) - 1) > *(_DWORD *)(a1 + 8) )
  {
    v5 = *(_DWORD *)a1;
    *(_DWORD *)(4 * ++*(_DWORD *)(a1 + 8) + v5) = a2;
    sub_8059832(*(_DWORD *)a1, *(_DWORD *)(a1 + 8), *(int (__cdecl **)(int, int))(a1 + 12));
  }
  else
  {
    *(_DWORD *)a1 = sub_805EBB9(a1 + 4, v2, *(void **)a1, a1 + 4, 4);
    dword_806C310 = (int)&loc_805961A;
    sub_80621CD(v3, a1);
  }
  return 0;
}
// 80621CD: using guessed type int __fastcall sub_80621CD(_DWORD, _DWORD);
// 806C310: using guessed type int dword_806C310;

//----- (08059669) --------------------------------------------------------
int __usercall sub_8059669@<eax>(double a1@<st0>, int *a2)
{
  int v3; // ST1C_4
  _DWORD *v4; // ebx
  int v5; // esi
  int v6; // eax

  if ( !a2[2] )
    return 0;
  v3 = *(_DWORD *)(*a2 + 4);
  v4 = (_DWORD *)(*a2 + 4);
  v5 = *a2;
  v6 = a2[2];
  a2[2] = v6 - 1;
  *v4 = *(_DWORD *)(v5 + 4 * v6);
  sub_80596F9(a1, *a2, a2[2], 1u, (int (__cdecl *)(int, int))a2[3]);
  return v3;
}

//----- (080596F9) --------------------------------------------------------
unsigned int __usercall sub_80596F9@<eax>(double a1@<st0>, int a2, unsigned int a3, unsigned int a4, int (__cdecl *a5)(int, int))
{
  int v5; // edx
  int v6; // ecx
  int v7; // eax
  bool v8; // zf
  bool v9; // sf
  void *v10; // eax
  int v12; // [esp+0h] [ebp-28h]
  unsigned int v13; // [esp+14h] [ebp-14h]
  unsigned int v14; // [esp+18h] [ebp-10h]
  int v15; // [esp+1Ch] [ebp-Ch]

  v15 = *(_DWORD *)(4 * a4 + a2);
  v13 = a4;
  if ( a3 >> 1 >= v13 )
  {
    v14 = 2 * v13;
    if ( 2 * v13 < a3 && a5(*(_DWORD *)(4 * v14 + a2), *(_DWORD *)(4 * (v14 + 1) + a2)) < 0 )
    {
      ++v14;
      dword_806C338 = (int)&loc_8059765;
      sub_80620D8(v6, v5);
    }
    v12 = *(_DWORD *)(4 * v14 + a2);
    v7 = a5(v12, v15);
    v8 = v7 == 0;
    v9 = v7 < 0;
    v10 = &loc_80597E1;
    if ( !v9 && !v8 )
      v10 = &loc_80597E3;
    dword_806C25C = (int)v10;
    sub_8062626(a1);
  }
  *(_DWORD *)(a2 + 4 * v13) = v15;
  return v13;
}
// 80620D8: using guessed type int __fastcall sub_80620D8(_DWORD, _DWORD);
// 8062626: using guessed type int __usercall sub_8062626@<eax>(double@<st0>);
// 806C25C: using guessed type int dword_806C25C;
// 806C338: using guessed type int dword_806C338;

//----- (08059832) --------------------------------------------------------
int __cdecl sub_8059832(int a1, unsigned int a2, int (__cdecl *a3)(int, int))
{
  int result; // eax
  int v4; // [esp+0h] [ebp-28h]
  unsigned int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]

  v5 = a2;
  v6 = *(_DWORD *)(4 * a2 + a1);
  dword_806C298 = (int)&loc_8059895;
  sub_80624B3();
  do
  {
    *(_DWORD *)(a1 + 4 * v5) = *(_DWORD *)(4 * (v5 >> 1) + a1);
    v5 >>= 1;
    if ( v5 == 1 )
      break;
    v4 = *(_DWORD *)(4 * (v5 >> 1) + a1);
  }
  while ( a3(v4, v6) <= 0 );
  result = v6;
  *(_DWORD *)(a1 + 4 * v5) = v6;
  return result;
}
// 80624B3: using guessed type int sub_80624B3(void);
// 806C298: using guessed type int dword_806C298;

//----- (080598D7) --------------------------------------------------------
int __cdecl sub_80598D7(int a1, int a2)
{
  int v3; // [esp+Ch] [ebp-4h]

  v3 = a2 + 11;
  *(_BYTE *)(a2 + 11) = 0;
  if ( a1 >= 0 )
  {
    do
    {
      *(_BYTE *)--v3 = (char)a1 % 10 + 48;
      a1 /= 10;
    }
    while ( a1 );
  }
  else
  {
    do
    {
      *(_BYTE *)--v3 = 48 - (char)a1 % 10;
      a1 /= 10;
    }
    while ( a1 );
    *(_BYTE *)--v3 = 45;
  }
  return v3;
}

//----- (080599B1) --------------------------------------------------------
int __cdecl sub_80599B1(unsigned int a1, int a2)
{
  void *v2; // eax

  *(_BYTE *)(a2 + 10) = 0;
  *(_BYTE *)(a2 + 9) = a1 % 0xA + 48;
  v2 = &loc_8059A23;
  if ( a1 / 0xA )
    v2 = &loc_80599C6;
  dword_806C248 = (int)v2;
  sub_8062696();
  return a2 + 9;
}
// 8062696: using guessed type int sub_8062696(void);
// 806C248: using guessed type int dword_806C248;

//----- (08059A28) --------------------------------------------------------
int __cdecl sub_8059A28(signed __int64 a1, int a2)
{
  signed __int64 v3; // [esp+18h] [ebp-20h]
  int v4; // [esp+2Ch] [ebp-Ch]

  v3 = a1;
  v4 = a2 + 20;
  *(_BYTE *)(a2 + 20) = 0;
  do
  {
    *(_BYTE *)--v4 = sub_8061C5F(v3, HIDWORD(v3), 10, 0) + 48;
    v3 = sub_8061AD2(v3, 0xAu, 0);
  }
  while ( v3 );
  return v4;
}
// 8061C5F: using guessed type _DWORD __cdecl sub_8061C5F(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08059ADB) --------------------------------------------------------
signed int __cdecl sub_8059ADB(char *a1, int a2, char a3)
{
  int v3; // edx
  int v4; // ecx
  int v5; // eax
  void *v7; // eax
  char *v8; // eax
  const unsigned __int16 **v9; // eax
  int v10; // ecx
  int v11; // edx
  bool v12; // zf
  void *v13; // eax
  char *v14; // [esp+1Ch] [ebp-3Ch]
  unsigned __int8 v15; // [esp+2Bh] [ebp-2Dh]
  wint_t wc; // [esp+2Ch] [ebp-2Ch]
  char *v17; // [esp+30h] [ebp-28h]
  int v18; // [esp+34h] [ebp-24h]
  size_t v19; // [esp+38h] [ebp-20h]
  char *v20; // [esp+3Ch] [ebp-1Ch]
  char s; // [esp+44h] [ebp-14h]
  unsigned int v22; // [esp+4Ch] [ebp-Ch]

  v14 = a1;
  v22 = __readgsdword(0x14u);
  v17 = a1;
  v20 = &a1[a2];
  v18 = 0;
  if ( __ctype_get_mb_cur_max() > 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        if ( v17 >= v20 )
          return v18;
        v5 = *v17;
        if ( v5 <= 63 )
          break;
LABEL_7:
        if ( v5 < 65 || v5 > 95 && (unsigned int)(v5 - 97) > 0x1D )
          goto LABEL_11;
LABEL_10:
        ++v17;
        ++v18;
      }
      if ( v5 >= 37 )
        goto LABEL_10;
      if ( (unsigned int)(v5 - 32) <= 3 )
      {
        dword_806C284 = (int)&loc_8059B70;
        v5 = sub_806253E(v4, v3);
        goto LABEL_7;
      }
LABEL_11:
      memset(&s, 0, 8u);
      v19 = sub_8060119((wchar_t *)&wc, v17, v20 - v17, (mbstate_t *)&s);
      if ( v19 != -1 )
      {
        v7 = &loc_8059C08;
        if ( v19 != -2 )
          v7 = &loc_8059C3D;
        dword_806C338 = (int)v7;
        sub_80620D8(v4, v3);
        if ( !(a3 & 1) )
        {
          v17 = v20;
          ++v18;
          dword_806C2D4 = (int)&loc_8059D41;
          sub_8062323();
        }
        return -1;
      }
      if ( a3 & 1 )
        return -1;
      ++v17;
      ++v18;
    }
  }
  dword_806C20C = (int)&loc_8059E07;
  sub_80627EE(v4, v3);
  do
  {
    v8 = v17++;
    v15 = *v8;
    v9 = __ctype_b_loc();
    v11 = v15;
    v12 = ((*v9)[v11] & 0x4000) == 0;
    v13 = &loc_8059DB2;
    if ( v12 )
      v13 = &loc_8059DC6;
    dword_806C284 = (int)v13;
    sub_806253E(v10, v11 * 2);
    if ( v18 == 0x7FFFFFFF )
      return 0x7FFFFFFF;
    ++v18;
  }
  while ( v17 < v20 );
  return v18;
}
// 80620D8: using guessed type int __fastcall sub_80620D8(_DWORD, _DWORD);
// 8062323: using guessed type int sub_8062323(void);
// 806253E: using guessed type int __fastcall sub_806253E(_DWORD, _DWORD);
// 80627EE: using guessed type int __fastcall sub_80627EE(_DWORD, _DWORD);
// 806C20C: using guessed type int dword_806C20C;
// 806C284: using guessed type int dword_806C284;
// 806C2D4: using guessed type int dword_806C2D4;
// 806C338: using guessed type int dword_806C338;

//----- (08059E41) --------------------------------------------------------
int sub_8059E41()
{
  bool v0; // zf
  void *v1; // eax
  int v2; // eax
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  int v7; // [esp+1Ch] [ebp-8Ch]
  char v8; // [esp+20h] [ebp-88h]

  v0 = sched_getaffinity(0, 128, &v8) == 0;
  v1 = &loc_8059E85;
  if ( !v0 )
    v1 = &loc_8059ED1;
  dword_806C2FC = (int)v1;
  sub_806223F();
  v2 = __sched_cpucount(128, &v8);
  v7 = v2;
  v0 = v2 == 0;
  v5 = &loc_8059EC3;
  if ( v0 )
    v5 = &loc_8059ED1;
  dword_806C234 = (int)v5;
  sub_8062704(v4, v3);
  return v7;
}
// 8059E41: could not find valid save-restore pair for ebx
// 80498D0: using guessed type int __cdecl __sched_cpucount(_DWORD, _DWORD);
// 8049E70: using guessed type int __cdecl sched_getaffinity(_DWORD, _DWORD, _DWORD);
// 806223F: using guessed type int sub_806223F(void);
// 8062704: using guessed type int __fastcall sub_8062704(_DWORD, _DWORD);
// 806C234: using guessed type int dword_806C234;
// 806C2FC: using guessed type int dword_806C2FC;

//----- (08059EDA) --------------------------------------------------------
signed int __cdecl sub_8059EDA(int a1)
{
  int v1; // eax
  bool v2; // zf
  void *v3; // eax
  signed int result; // eax
  int v5; // eax
  void *v6; // eax
  int v7; // [esp+10h] [ebp-18h]
  int v8; // [esp+14h] [ebp-14h]
  int v9; // [esp+1Ch] [ebp-Ch]

  if ( a1 == 1 )
  {
    v1 = sub_8059E41();
    v8 = v1;
    v2 = v1 == 0;
    v3 = &loc_8059F0D;
    if ( v2 )
      v3 = &loc_8059F88;
    dword_806C2C0 = (int)v3;
    sub_806239B();
    result = v8;
  }
  else
  {
    v5 = sysconf(83);
    v7 = v5;
    v2 = v5 == 1;
    v6 = &loc_8059F72;
    if ( !v2 )
      v6 = &loc_8059F2C;
    dword_806C2D4 = (int)v6;
    sub_8062323();
    v9 = sub_8059E41();
    if ( v9 )
      v7 = v9;
    if ( v7 <= 0 )
      result = 1;
    else
      result = v7;
  }
  return result;
}
// 8062323: using guessed type int sub_8062323(void);
// 806C2C0: using guessed type int dword_806C2C0;
// 806C2D4: using guessed type int dword_806C2D4;

//----- (08059FB7) --------------------------------------------------------
#error "805A042: call analysis failed (funcsize=98)"

//----- (0805A139) --------------------------------------------------------
unsigned int __cdecl sub_805A139(int a1)
{
  char *v1; // eax
  char *v2; // eax
  unsigned int result; // eax
  unsigned int v4; // [esp+14h] [ebp-14h]
  unsigned int v5; // [esp+18h] [ebp-10h]

  v4 = -1;
  if ( a1 == 2 )
  {
    v1 = getenv("OMP_NUM_THREADS");
    v5 = sub_8059FB7(v1);
    v2 = getenv("OMP_THREAD_LIMIT");
    v4 = sub_8059FB7(v2);
    if ( !v4 )
      v4 = -1;
    if ( v5 )
    {
      result = v5;
      if ( v4 <= v5 )
        result = v4;
      return result;
    }
    a1 = 1;
  }
  result = sub_8059EDA(a1);
  if ( v4 <= result )
    result = v4;
  return result;
}

//----- (0805A1BA) --------------------------------------------------------
long double sub_805A1BA()
{
  long double v0; // fst7
  int v2; // [esp+4h] [ebp-74h]
  __int64 v3; // [esp+8h] [ebp-70h]
  double v4; // [esp+18h] [ebp-60h]
  double v5; // [esp+20h] [ebp-58h]
  char v6; // [esp+2Ch] [ebp-4Ch]
  unsigned int v7; // [esp+3Ch] [ebp-3Ch]
  unsigned int v8; // [esp+60h] [ebp-18h]
  unsigned int v9; // [esp+6Ch] [ebp-Ch]

  v9 = __readgsdword(0x14u);
  v4 = (long double)sysconf(85);
  v2 = sysconf(30);
  v5 = (long double)v2;
  if ( v4 >= 0.0 && v5 >= 0.0 )
  {
    v0 = v4 * v5;
    dword_806C25C = (int)&loc_805A267;
    sub_8062626(*(double *)&v0);
  }
  if ( sysinfo((struct sysinfo *)&v6) )
    return 67108864.0;
  v3 = v8;
  return (long double)v7 * (long double)v8;
}
// 8062626: using guessed type int __usercall sub_8062626@<eax>(double@<st0>);
// 806C25C: using guessed type int dword_806C25C;

//----- (0805A27C) --------------------------------------------------------
long double sub_805A27C()
{
  int v1; // ecx
  double v2; // [esp+18h] [ebp-60h]
  double v3; // [esp+20h] [ebp-58h]
  char v4; // [esp+2Ch] [ebp-4Ch]
  unsigned int v5; // [esp+6Ch] [ebp-Ch]

  v5 = __readgsdword(0x14u);
  v2 = (long double)sysconf(86);
  v3 = (long double)sysconf(30);
  if ( v2 >= 0.0 && v3 >= 0.0 )
    return v2 * v3;
  if ( !sysinfo((struct sysinfo *)&v4) )
  {
    dword_806C310 = (int)&loc_805A343;
    sub_80621CD(v1, 0);
  }
  return sub_805A1BA() / 4.0;
}
// 80621CD: using guessed type int __fastcall sub_80621CD(_DWORD, _DWORD);
// 806C310: using guessed type int dword_806C310;

//----- (0805A358) --------------------------------------------------------
int __cdecl sub_805A358(int pipedes[2], int a2)
{
  bool v2; // zf
  void *v3; // eax
  int v5; // eax
  int v6; // [esp+18h] [ebp-20h]
  int v7; // [esp+1Ch] [ebp-1Ch]
  int v8; // [esp+20h] [ebp-18h]
  int v9; // [esp+24h] [ebp-14h]
  int v10; // [esp+28h] [ebp-10h]
  int v11; // [esp+2Ch] [ebp-Ch]

  v10 = *pipedes;
  v11 = pipedes[1];
  if ( dword_806D2A3 < 0 )
  {
    if ( a2 & 0xFFF7F7FF )
    {
      __errno_location();
      dword_806C2AC = (int)&loc_805A40E;
      v5 = sub_8062420();
    }
    else
    {
      if ( pipe(pipedes) < 0 )
      {
        dword_806C220 = (int)&locret_805A626;
        sub_806277E();
      }
      if ( !(a2 & 0x800) )
      {
LABEL_17:
        if ( !(a2 & 0x80000) )
          return 0;
        v8 = sub_805FDEF(pipedes[1], 1, 0);
        if ( v8 >= 0 && sub_805FDEF(pipedes[1], 2, v8 | 1) != -1 )
        {
          v8 = sub_805FDEF(*pipedes, 1, 0);
          if ( v8 >= 0 && sub_805FDEF(*pipedes, 2, v8 | 1) != -1 )
            return 0;
        }
        goto LABEL_23;
      }
      v7 = sub_805FDEF(pipedes[1], 3, 0);
      if ( v7 < 0 )
      {
LABEL_23:
        v9 = *__errno_location();
        close(*pipedes);
        close(pipedes[1]);
        *pipedes = v10;
        pipedes[1] = v11;
        *__errno_location() = v9;
        return -1;
      }
      v5 = sub_805FDEF(pipedes[1], 4, v7);
    }
    if ( v5 != -1 )
    {
      v7 = sub_805FDEF(*pipedes, 3, 0);
      if ( v7 >= 0 && sub_805FDEF(*pipedes, 4, v7) != -1 )
        goto LABEL_17;
    }
    goto LABEL_23;
  }
  v6 = pipe2(pipedes, a2);
  if ( v6 < 0 )
  {
    v2 = *__errno_location() == 38;
    v3 = &loc_805A3B8;
    if ( v2 )
      v3 = &loc_805A3CA;
    dword_806C2D4 = (int)v3;
    sub_8062323();
  }
  dword_806D2A3 = 1;
  return v6;
}
// 8049DF0: using guessed type int __cdecl pipe2(_DWORD, _DWORD);
// 8062323: using guessed type int sub_8062323(void);
// 8062420: using guessed type int sub_8062420(void);
// 806277E: using guessed type int sub_806277E(void);
// 806C220: using guessed type int dword_806C220;
// 806C2AC: using guessed type int dword_806C2AC;
// 806C2D4: using guessed type int dword_806C2D4;
// 806D2A3: using guessed type int dword_806D2A3;

//----- (0805A628) --------------------------------------------------------
int sub_805A628()
{
  char *v0; // eax
  int v1; // edx
  int v2; // ecx
  bool v3; // zf
  void *v4; // eax
  char *endptr; // [esp+10h] [ebp-18h]
  int v7; // [esp+14h] [ebp-14h]
  char *nptr; // [esp+18h] [ebp-10h]
  int v9; // [esp+1Ch] [ebp-Ch]

  v7 = 200809;
  v0 = getenv("_POSIX2_VERSION");
  nptr = v0;
  v3 = v0 == 0;
  v4 = &loc_805A663;
  if ( v3 )
    v4 = &loc_805A69A;
  dword_806C310 = (int)v4;
  sub_80621CD(v2, v1);
  if ( *nptr )
  {
    v9 = strtol(nptr, &endptr, 10);
    if ( !*endptr )
      v7 = v9;
  }
  return v7;
}
// 80621CD: using guessed type int __fastcall sub_80621CD(_DWORD, _DWORD);
// 806C310: using guessed type int dword_806C310;

//----- (0805A69F) --------------------------------------------------------
char *__cdecl sub_805A69F(char *s)
{
  char *v1; // eax
  bool v2; // zf
  void *v3; // eax
  char *result; // eax
  char *v5; // [esp+18h] [ebp-10h]
  char *s1; // [esp+1Ch] [ebp-Ch]

  if ( !s )
  {
    fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
    abort();
  }
  v5 = strrchr(s, 47);
  if ( v5 )
    v1 = v5 + 1;
  else
    v1 = s;
  s1 = v1;
  if ( v1 - s > 6 && !strncmp(v1 - 7, "/.libs/", 7u) )
  {
    v2 = strncmp(s1, "lt-", 3u) == 0;
    v3 = &loc_805A78A;
    if ( !v2 )
      v3 = &loc_805A79B;
    dword_806C2D4 = (int)v3;
    sub_8062323();
    s = s1 + 3;
    program_invocation_short_name = (int)(s1 + 3);
  }
  dword_806D2A7 = (int)s;
  result = s;
  program_invocation_name = (int)s;
  return result;
}
// 8062323: using guessed type int sub_8062323(void);
// 806C2D4: using guessed type int dword_806C2D4;
// 806C4A0: using guessed type int program_invocation_short_name;
// 806C4B0: using guessed type int program_invocation_name;
// 806D2A7: using guessed type int dword_806D2A7;

//----- (0805A84E) --------------------------------------------------------
unsigned int __cdecl sub_805A84E(int a1, unsigned __int8 a2, char a3)
{
  unsigned int v3; // ST18_4

  if ( a1 )
  {
    dword_806C2C0 = (int)&loc_805A928;
    sub_806239B();
  }
  v3 = ((unsigned int)dword_806D2B7[(a2 >> 5) + 2] >> (a2 & 0x1F)) & 1;
  dword_806D2B7[(a2 >> 5) + 2] ^= (v3 ^ a3 & 1) << (a2 & 0x1F);
  return v3;
}
// 806C2C0: using guessed type int dword_806C2C0;
// 806D2B7: using guessed type int dword_806D2B7[];

//----- (0805A9BE) --------------------------------------------------------
int *__cdecl sub_805A9BE(int *a1, int a2, int a3)
{
  int *result; // eax

  if ( !a1 )
    a1 = dword_806D2B7;
  *a1 = 10;
  if ( !a2 || !a3 )
    abort();
  a1[10] = a2;
  result = a1;
  a1[11] = a3;
  return result;
}
// 806D2B7: using guessed type int dword_806D2B7[];

//----- (0805AA24) --------------------------------------------------------
void __cdecl __noreturn sub_805AA24(int a1, int a2)
{
  int (__stdcall *v2)(int); // eax
  char v3; // [esp+0h] [ebp-38h]

  memset(&v3, 0, 0x30u);
  v2 = (int (__stdcall *)(int))&loc_805AA5E;
  if ( a2 != 10 )
    v2 = sub_805AA63;
  dword_806C234 = (int)v2;
  sub_8062704(0, 12);
  abort();
}
// 805AA63: using guessed type int __stdcall sub_805AA63(int);
// 8062704: using guessed type int __fastcall sub_8062704(_DWORD, _DWORD);
// 806C234: using guessed type int dword_806C234;

//----- (0805AA63) --------------------------------------------------------
#error "805AAB9: positive sp value has been found (funcsize=0)"

//----- (0805AABF) --------------------------------------------------------
#error "805AB3C: call analysis failed (funcsize=66)"

//----- (0805ABEF) --------------------------------------------------------
int __usercall sub_805ABEF@<eax>(double st7_0@<st0>, int a1, unsigned int a2, char *a3, size_t a4, char *a5, int a6, int a7, char *a8, char *a9)
{
  int v10; // edx
  int v11; // ecx
  int v12; // ecx
  void *v13; // eax
  void *v14; // eax
  size_t v15; // eax
  char *v16; // edx
  void *v17; // eax
  void *v18; // eax
  int v19; // ecx
  void *v20; // eax
  void *v21; // eax
  void *v22; // eax
  void *v23; // eax
  const unsigned __int16 **v24; // eax
  void *v25; // eax
  void *v26; // eax
  int v27; // edx
  int v28; // ecx
  void *v29; // eax
  char *v30; // edx
  void *v31; // eax
  void *v32; // eax
  void *v33; // eax
  void *v34; // eax
  void *v35; // eax
  void *v36; // eax
  void *v37; // eax
  char v38; // al
  void *v39; // eax
  int v40; // edx
  int v41; // ecx
  void *v42; // eax
  int result; // eax
  size_t v44; // [esp-8h] [ebp-90h]
  int v45; // [esp+0h] [ebp-88h]
  char *v46; // [esp+4h] [ebp-84h]
  size_t v47; // [esp+8h] [ebp-80h]
  int v48; // [esp+Ch] [ebp-7Ch]
  int v49; // [esp+10h] [ebp-78h]
  int v50; // [esp+14h] [ebp-74h]
  int v51; // [esp+18h] [ebp-70h]
  int v52; // [esp+1Ch] [ebp-6Ch]
  int v53; // [esp+20h] [ebp-68h]
  int v54; // [esp+24h] [ebp-64h]
  int v55; // [esp+28h] [ebp-60h]
  char *v56; // [esp+2Ch] [ebp-5Ch]
  char *v57; // [esp+30h] [ebp-58h]
  int v58; // [esp+34h] [ebp-54h]
  char *v59; // [esp+38h] [ebp-50h]
  char *v60; // [esp+3Ch] [ebp-4Ch]
  char v61; // [esp+40h] [ebp-48h]
  bool v62; // [esp+41h] [ebp-47h]
  char v63; // [esp+42h] [ebp-46h]
  char v64; // [esp+43h] [ebp-45h]
  char v65; // [esp+44h] [ebp-44h]
  unsigned __int8 v66; // [esp+45h] [ebp-43h]
  char v67; // [esp+46h] [ebp-42h]
  char v68; // [esp+47h] [ebp-41h]
  char v69; // [esp+48h] [ebp-40h]
  bool v70; // [esp+49h] [ebp-3Fh]
  bool v71; // [esp+4Ah] [ebp-3Eh]
  bool v72; // [esp+4Bh] [ebp-3Dh]
  wint_t wc; // [esp+4Ch] [ebp-3Ch]
  char *v74; // [esp+50h] [ebp-38h]
  unsigned int v75; // [esp+54h] [ebp-34h]
  unsigned int v76; // [esp+58h] [ebp-30h]
  char *s; // [esp+5Ch] [ebp-2Ch]
  size_t n; // [esp+60h] [ebp-28h]
  unsigned int v79; // [esp+64h] [ebp-24h]
  int v80; // [esp+68h] [ebp-20h]
  size_t v81; // [esp+6Ch] [ebp-1Ch]
  unsigned int v82; // [esp+70h] [ebp-18h]
  mbstate_t ps; // [esp+74h] [ebp-14h]
  unsigned int v84; // [esp+7Ch] [ebp-Ch]

  v60 = (char *)a1;
  v59 = a3;
  v58 = a7;
  v57 = a8;
  v56 = a9;
  v84 = __readgsdword(0x14u);
  v75 = 0;
  v76 = 0;
  s = 0;
  n = 0;
  v61 = 0;
  v72 = __ctype_get_mb_cur_max() == 1;
  v62 = (a6 & 2) != 0;
  v63 = 0;
  v64 = 0;
  v65 = 1;
  switch ( (unsigned int)a5 )
  {
    case 0u:
      v62 = 0;
      break;
    case 1u:
      goto LABEL_18;
    case 2u:
      goto LABEL_21;
    case 3u:
      goto LABEL_17;
    case 4u:
      goto LABEL_198;
    case 5u:
      goto LABEL_3;
    case 6u:
      a5 = (char *)5;
      v62 = 1;
LABEL_3:
      if ( v62 != 1 )
      {
        if ( v75 < a2 )
          v60[v75] = 34;
        ++v75;
      }
      v61 = 1;
      s = (char *)&unk_8064FB5;
      n = 1;
      dword_806C2C0 = (int)&loc_805AE00;
      sub_806239B();
      goto LABEL_8;
    case 7u:
LABEL_8:
      v61 = 1;
      v62 = 0;
      break;
    case 8u:
    case 9u:
    case 0xAu:
      if ( a5 != (char *)10 )
      {
        v57 = (char *)sub_805AABF(st7_0, "`");
        v46 = a5;
        v56 = (char *)sub_805AABF(st7_0, "'");
      }
      if ( v62 != 1 )
      {
        s = v57;
        dword_806C25C = (int)&loc_805AD5E;
        sub_8062626(st7_0);
        do
        {
          if ( v75 < a2 )
            v60[v75] = *s;
          ++v75;
          ++s;
        }
        while ( *s );
      }
      v61 = 1;
      s = v56;
      n = strlen(v56);
      dword_806C25C = (int)&loc_805AE00;
      sub_8062626(st7_0);
LABEL_17:
      v61 = 1;
LABEL_18:
      v62 = 1;
LABEL_198:
      if ( v62 != 1 )
        v61 = 1;
LABEL_21:
      a5 = (char *)2;
      if ( v62 != 1 )
      {
        if ( v75 < a2 )
        {
          v10 = (int)v60;
          v60[v75] = 39;
        }
        ++v75;
      }
      s = "'";
      n = 1;
      break;
    default:
      abort();
      return result;
  }
  v74 = 0;
  dword_806C324 = (int)&loc_805B931;
  sub_8062148(v11, v10);
  v68 = 0;
  v69 = 0;
  v70 = 0;
  if ( v61 )
  {
    v13 = &loc_805AE53;
    if ( a5 == (char *)2 )
      v13 = &loc_805AED2;
    dword_806C2E8 = (int)v13;
    sub_80622AD(
      v45,
      v46,
      v47,
      v48,
      v49,
      v50,
      v51,
      v52,
      v53,
      v54,
      v55,
      v56,
      v57,
      v58,
      v59,
      v60,
      *(_DWORD *)&v61,
      *(_DWORD *)&v65,
      *(_DWORD *)&v69);
    if ( n )
    {
      v44 = (size_t)&v74[n];
      v14 = &loc_805AE81;
      if ( a4 != -1 )
        v14 = &loc_805AE9A;
      dword_806C2AC = (int)v14;
      sub_8062420();
      if ( n <= 1 )
      {
        v15 = a4;
      }
      else
      {
        v15 = strlen(v59);
        a4 = v15;
      }
      if ( v44 <= v15 && !memcmp(&v59[(_DWORD)v74], s, n) )
      {
        if ( v62 )
          goto LABEL_207;
        v68 = 1;
      }
    }
  }
  v16 = v59;
  v66 = v74[(_DWORD)v59];
  switch ( v66 )
  {
    case 0u:
      if ( !v61 )
      {
        v18 = &loc_805B03E;
        if ( !(a6 & 1) )
          v18 = &loc_805B043;
        dword_806C358 = (int)v18;
        sub_8061FAB();
        goto LABEL_179;
      }
      v17 = &loc_805AF1F;
      if ( !v62 )
        v17 = &loc_805AF24;
      dword_806C310 = (int)v17;
      sub_80621CD(v12, v59);
      goto LABEL_207;
    case 7u:
      v67 = 97;
      goto LABEL_68;
    case 8u:
      v67 = 98;
      goto LABEL_68;
    case 9u:
      v67 = 116;
      dword_806C338 = (int)&loc_805B21B;
      sub_80620D8(v12, v59);
      goto LABEL_61;
    case 0xAu:
      v67 = 110;
      goto LABEL_66;
    case 0xBu:
LABEL_61:
      v67 = 118;
      goto LABEL_68;
    case 0xCu:
      v67 = 102;
      goto LABEL_68;
    case 0xDu:
      v67 = 114;
LABEL_66:
      if ( a5 == (char *)2 && v62 )
        goto LABEL_207;
LABEL_68:
      if ( v61 )
      {
        v66 = v67;
        dword_806C220 = (int)&loc_805B7F6;
        sub_806277E();
      }
      goto LABEL_142;
    case 0x20u:
      goto LABEL_75;
    case 0x21u:
    case 0x22u:
    case 0x24u:
    case 0x26u:
    case 0x28u:
    case 0x29u:
    case 0x2Au:
    case 0x3Bu:
    case 0x3Cu:
    case 0x3Du:
    case 0x3Eu:
    case 0x5Bu:
    case 0x5Eu:
    case 0x60u:
    case 0x7Cu:
      goto LABEL_76;
    case 0x23u:
    case 0x7Eu:
      goto LABEL_74;
    case 0x25u:
    case 0x2Bu:
    case 0x2Cu:
    case 0x2Du:
    case 0x2Eu:
    case 0x2Fu:
    case 0x30u:
    case 0x31u:
    case 0x32u:
    case 0x33u:
    case 0x34u:
    case 0x35u:
    case 0x36u:
    case 0x37u:
    case 0x38u:
    case 0x39u:
    case 0x3Au:
    case 0x41u:
    case 0x42u:
    case 0x43u:
    case 0x44u:
    case 0x45u:
    case 0x46u:
    case 0x47u:
    case 0x48u:
    case 0x49u:
    case 0x4Au:
    case 0x4Bu:
    case 0x4Cu:
    case 0x4Du:
    case 0x4Eu:
    case 0x4Fu:
    case 0x50u:
    case 0x51u:
    case 0x52u:
    case 0x53u:
    case 0x54u:
    case 0x55u:
    case 0x56u:
    case 0x57u:
    case 0x58u:
    case 0x59u:
    case 0x5Au:
    case 0x5Du:
    case 0x5Fu:
    case 0x61u:
    case 0x62u:
    case 0x63u:
    case 0x64u:
    case 0x65u:
    case 0x66u:
    case 0x67u:
    case 0x68u:
    case 0x69u:
    case 0x6Au:
    case 0x6Bu:
    case 0x6Cu:
    case 0x6Du:
    case 0x6Eu:
    case 0x6Fu:
    case 0x70u:
    case 0x71u:
    case 0x72u:
    case 0x73u:
    case 0x74u:
    case 0x75u:
    case 0x76u:
    case 0x77u:
    case 0x78u:
    case 0x79u:
    case 0x7Au:
      v70 = 1;
      goto LABEL_142;
    case 0x27u:
      v64 = 1;
      v70 = 1;
      if ( a5 != (char *)2 )
        goto LABEL_142;
      if ( v62 )
        goto LABEL_207;
      if ( a2 )
      {
        v23 = &loc_805B2FB;
        if ( v76 )
          v23 = &loc_805B308;
        dword_806C234 = (int)v23;
        sub_8062704(v12, v59);
        v76 = a2;
        a2 = 0;
      }
      if ( v75 < a2 )
      {
        v16 = v60;
        v60[v75] = 39;
      }
      if ( ++v75 < a2 )
      {
        v16 = v60;
        v60[v75] = 92;
      }
      if ( ++v75 < a2 )
      {
        v16 = v60;
        v60[v75] = 39;
      }
      ++v75;
      v63 = 0;
      goto LABEL_142;
    case 0x3Fu:
      if ( a5 == (char *)2 )
      {
        if ( v62 )
          goto LABEL_207;
      }
      else
      {
        v20 = &loc_805B06E;
        if ( a5 == (char *)5 )
          v20 = &loc_805B083;
        dword_806C2D4 = (int)v20;
        sub_8062323();
      }
      goto LABEL_142;
    case 0x5Cu:
      v67 = v66;
      v21 = &loc_805B1F4;
      if ( a5 != (char *)2 )
        v21 = &loc_805B204;
      dword_806C324 = (int)v21;
      sub_8062148(v12, v59);
      if ( !v62 )
        goto LABEL_166;
      goto LABEL_207;
    case 0x7Bu:
    case 0x7Du:
      v22 = &loc_805B274;
      if ( a4 != -1 )
        v22 = &loc_805B284;
      dword_806C20C = (int)v22;
      sub_80627EE(v12, v59);
      if ( v59[1] )
        goto LABEL_142;
LABEL_74:
      if ( v74 )
        goto LABEL_142;
LABEL_75:
      v70 = 1;
LABEL_76:
      if ( a5 != (char *)2 || !v62 )
        goto LABEL_142;
      goto LABEL_207;
    default:
      if ( v72 )
      {
        v79 = 1;
        v24 = __ctype_b_loc();
        v16 = (char *)(2 * v66);
        v71 = (*(const unsigned __int16 *)((_BYTE *)*v24 + (_DWORD)v16) & 0x4000) != 0;
        goto LABEL_116;
      }
      memset(&ps, 0, 8u);
      v79 = 0;
      v71 = 1;
      if ( a4 == -1 )
        a4 = strlen(v59);
      break;
  }
  do
  {
    v47 = a4 - (_DWORD)&v74[v79];
    v46 = &v74[v79 + (_DWORD)v59];
    v81 = sub_8060119((wchar_t *)&wc, v46, v47, &ps);
    if ( !v81 )
      break;
    if ( v81 == -1 )
    {
      v71 = 0;
      break;
    }
    if ( v81 == -2 )
    {
      v71 = 0;
      if ( (unsigned int)&v74[v79] < a4 )
      {
        v25 = &loc_805B46F;
        if ( v74[v79 + (_DWORD)v59] )
          v25 = &loc_805B431;
        dword_806C2E8 = (int)v25;
        sub_80622AD(
          v45,
          v46,
          v47,
          v48,
          v49,
          v50,
          v51,
          v52,
          v53,
          v54,
          v55,
          v56,
          v57,
          v58,
          v59,
          v60,
          *(_DWORD *)&v61,
          *(_DWORD *)&v65,
          *(_DWORD *)&v69);
      }
      dword_806C358 = (int)&loc_805B52C;
      sub_8061FAB();
    }
    if ( v62 )
    {
      v26 = &loc_805B4AB;
      if ( a5 != (char *)2 )
        v26 = &loc_805B4FE;
      dword_806C324 = (int)v26;
      sub_8062148(v12, v16);
      v80 = 1;
      dword_806C338 = (int)&loc_805B4F6;
      sub_80620D8(v28, v27);
      while ( 2 )
      {
        switch ( v74[v79 + v80 + (_DWORD)v59] )
        {
          case 91:
          case 92:
          case 94:
          case 96:
          case 124:
            goto LABEL_207;
          default:
            if ( ++v80 >= v81 )
              goto LABEL_113;
            continue;
        }
      }
      goto LABEL_207;
    }
LABEL_113:
    if ( !iswprint(wc) )
      v71 = 0;
    v79 += v81;
  }
  while ( !mbsinit(&ps) );
LABEL_116:
  v70 = v71;
  if ( v79 > 1 )
    goto LABEL_121;
  if ( v61 )
  {
    v29 = &loc_805B567;
    if ( v71 == 1 )
      v29 = &loc_805B74D;
    dword_806C358 = (int)v29;
    sub_8061FAB();
LABEL_121:
    v30 = v74;
    v82 = (unsigned int)&v74[v79];
    while ( 1 )
    {
      if ( v61 && v71 != 1 )
      {
        v31 = &loc_805B5AA;
        if ( !v62 )
          v31 = &loc_805B5AF;
        dword_806C270 = (int)v31;
        sub_80625B6(v12, v30);
        goto LABEL_207;
      }
      if ( v68 )
      {
        if ( v75 < a2 )
          v60[v75] = 92;
        ++v75;
        v68 = 0;
      }
      if ( (unsigned int)(v74 + 1) >= v82 )
        goto LABEL_166;
      if ( v63 && v69 != 1 )
      {
        if ( v75 < a2 )
          v60[v75] = 39;
        if ( ++v75 < a2 )
          v60[v75] = 39;
        ++v75;
        v63 = 0;
      }
      if ( v75 < a2 )
        v60[v75] = v66;
      ++v75;
      ++v74;
      v30 = v59;
      v66 = v74[(_DWORD)v59];
    }
  }
LABEL_142:
  v32 = &loc_805B771;
  if ( v61 != 1 )
    v32 = &loc_805B777;
  dword_806C338 = (int)v32;
  sub_80620D8(v12, v16);
  if ( a5 != (char *)2 || v62 == 1 )
  {
    v33 = &loc_805B7A1;
    if ( !v58 )
      v33 = &loc_805B7E6;
    dword_806C220 = (int)v33;
    sub_806277E();
    v34 = &loc_805B7E6;
    if ( (*(_DWORD *)(4 * (v66 >> 5) + v58) >> (v66 & 0x1F)) & 1 )
      v34 = &loc_805B7F6;
    dword_806C2D4 = (int)v34;
    sub_8062323();
  }
  if ( v68 == 1 )
  {
    if ( v62 )
      goto LABEL_207;
    v69 = 1;
    v35 = &loc_805B824;
    if ( a5 != (char *)2 )
      v35 = &loc_805B878;
    dword_806C2D4 = (int)v35;
    sub_8062323();
    if ( v63 != 1 )
    {
      if ( v75 < a2 )
        v60[v75] = 39;
      if ( ++v75 < a2 )
        v60[v75] = 36;
      if ( ++v75 < a2 )
        v60[v75] = 39;
      ++v75;
      v63 = 1;
    }
    if ( v75 < a2 )
      v60[v75] = 92;
    ++v75;
  }
LABEL_166:
  v36 = &loc_805B8AE;
  if ( !v63 )
    v36 = &loc_805B8EB;
  dword_806C2FC = (int)v36;
  sub_806223F();
  if ( v69 != 1 )
  {
    if ( v75 < a2 )
      v60[v75] = 39;
    if ( ++v75 < a2 )
      v60[v75] = 39;
    ++v75;
    v63 = 0;
  }
  if ( v75 < a2 )
    v60[v75] = v66;
  ++v75;
  v37 = &loc_805B929;
  if ( v70 == 1 )
    v37 = &loc_805B92D;
  dword_806C248 = (int)v37;
  sub_8062696();
  v65 = 0;
LABEL_179:
  ++v74;
  if ( a4 == -1 )
  {
    v38 = v74[(_DWORD)v59];
    dword_806C338 = (int)&loc_805B967;
    sub_80620D8(v19, v59);
  }
  v39 = &loc_805B984;
  if ( v74 != (char *)a4 )
    v39 = &loc_805AE1E;
  dword_806C220 = (int)v39;
  sub_806277E();
  if ( !v75 && a5 == (char *)2 && v62 )
  {
    dword_806C2AC = (int)&loc_805BAF2;
    sub_8062420();
  }
  if ( a5 == (char *)2 && v62 != 1 && v64 )
  {
    if ( v65 )
    {
      sub_805ABEF(st7_0, (int)v60, v76, v59, a4, (char *)5, a6, v58, v57, v56);
      dword_806C2D4 = (int)&loc_805BB4E;
      sub_8062323();
    }
    v42 = &loc_805BA50;
    if ( a2 )
      v42 = &loc_805BA7A;
    dword_806C2C0 = (int)v42;
    sub_806239B();
    if ( v76 )
    {
      a2 = v76;
      v75 = 0;
      dword_806C248 = (int)&loc_805AC68;
      sub_8062696();
    }
  }
  if ( s && v62 != 1 )
  {
    while ( *s )
    {
      if ( v75 < a2 )
      {
        v40 = (int)&v60[v75];
        v60[v75] = *s;
      }
      ++v75;
      ++s;
    }
  }
  if ( v75 < a2 )
  {
    v40 = (int)v60;
    v60[v75] = 0;
  }
  dword_806C310 = (int)&loc_805BB4E;
  sub_80621CD(v41, v40);
LABEL_207:
  if ( a5 == (char *)2 && v61 )
    a5 = (char *)4;
  return sub_805ABEF(st7_0, (int)v60, a2, v59, a4, a5, a6 & 0xFFFFFFFD, 0, v57, v56);
}
// 8061FAB: using guessed type int sub_8061FAB(void);
// 80620D8: using guessed type int __fastcall sub_80620D8(_DWORD, _DWORD);
// 8062148: using guessed type int __fastcall sub_8062148(_DWORD, _DWORD);
// 80621CD: using guessed type int __fastcall sub_80621CD(_DWORD, _DWORD);
// 806223F: using guessed type int sub_806223F(void);
// 80622AD: using guessed type int __stdcall sub_80622AD(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8062323: using guessed type int sub_8062323(void);
// 8062420: using guessed type int sub_8062420(void);
// 80625B6: using guessed type int __fastcall sub_80625B6(_DWORD, _DWORD);
// 8062626: using guessed type int __usercall sub_8062626@<eax>(double@<st0>);
// 8062696: using guessed type int sub_8062696(void);
// 8062704: using guessed type int __fastcall sub_8062704(_DWORD, _DWORD);
// 806277E: using guessed type int sub_806277E(void);
// 80627EE: using guessed type int __fastcall sub_80627EE(_DWORD, _DWORD);
// 806C20C: using guessed type int dword_806C20C;
// 806C220: using guessed type int dword_806C220;
// 806C234: using guessed type int dword_806C234;
// 806C248: using guessed type int dword_806C248;
// 806C25C: using guessed type int dword_806C25C;
// 806C270: using guessed type int dword_806C270;
// 806C2AC: using guessed type int dword_806C2AC;
// 806C2C0: using guessed type int dword_806C2C0;
// 806C2D4: using guessed type int dword_806C2D4;
// 806C2E8: using guessed type int dword_806C2E8;
// 806C2FC: using guessed type int dword_806C2FC;
// 806C310: using guessed type int dword_806C310;
// 806C324: using guessed type int dword_806C324;
// 806C338: using guessed type int dword_806C338;
// 806C358: using guessed type int dword_806C358;

//----- (0805BC1C) --------------------------------------------------------
void *__usercall sub_805BC1C@<eax>(int a1@<edx>, int a2@<ecx>, double a3@<st0>, char *a4, size_t a5, _DWORD *a6, int a7)
{
  int v7; // ST4C_4
  int v8; // ecx
  void *v9; // eax
  int v11; // [esp+40h] [ebp-18h]
  int size; // [esp+48h] [ebp-10h]
  void *v13; // [esp+4Ch] [ebp-Ch]

  if ( a7 )
  {
    dword_806C310 = (int)&loc_805BC48;
    sub_80621CD(a2, a1);
  }
  v11 = *__errno_location();
  v7 = dword_806D2B7[1] | (a6 == 0);
  size = sub_805ABEF(
           a3,
           0,
           0,
           a4,
           a5,
           (char *)dword_806D2B7[0],
           v7,
           (int)&dword_806D2B7[2],
           (char *)dword_806D2B7[10],
           (char *)dword_806D2B7[11])
       + 1;
  v13 = sub_805EC69(size);
  sub_805ABEF(
    a3,
    (int)v13,
    size,
    a4,
    a5,
    (char *)dword_806D2B7[0],
    v7,
    (int)&dword_806D2B7[2],
    (char *)dword_806D2B7[10],
    (char *)dword_806D2B7[11]);
  *__errno_location() = v11;
  v9 = &loc_805BD45;
  if ( !a6 )
    v9 = &loc_805BD50;
  dword_806C324 = (int)v9;
  sub_8062148(v8, v11);
  *a6 = size - 1;
  return v13;
}
// 8062148: using guessed type int __fastcall sub_8062148(_DWORD, _DWORD);
// 80621CD: using guessed type int __fastcall sub_80621CD(_DWORD, _DWORD);
// 806C310: using guessed type int dword_806C310;
// 806C324: using guessed type int dword_806C324;
// 806D2B7: using guessed type int dword_806D2B7[];

//----- (0805BE0A) --------------------------------------------------------
void *__usercall sub_805BE0A@<eax>(double st7_0@<st0>, signed int a1, char *a2, size_t a3, int a4)
{
  int *v5; // eax
  void *v6; // edx
  size_t v7; // ST44_4
  bool v9; // [esp+37h] [ebp-21h]
  int *v10; // [esp+38h] [ebp-20h]
  void *ptr; // [esp+3Ch] [ebp-1Ch]
  int v12; // [esp+40h] [ebp-18h]
  int size; // [esp+44h] [ebp-14h]
  int v14; // [esp+48h] [ebp-10h]
  unsigned int v15; // [esp+4Ch] [ebp-Ch]

  v12 = *__errno_location();
  v10 = off_806C458;
  if ( a1 < 0 )
    abort();
  if ( dword_806C44C <= a1 )
  {
    v9 = off_806C458 == &dword_806C450;
    if ( (unsigned int)a1 > 0xFFFFFFE )
      sub_805EE5C();
    if ( v9 )
      v5 = 0;
    else
      v5 = off_806C458;
    v10 = (int *)sub_805ECDC(v5, 8 * (a1 + 1));
    off_806C458 = v10;
    if ( v9 )
    {
      v6 = off_806C454;
      *v10 = dword_806C450;
      v10[1] = (int)v6;
    }
    memset(&v10[2 * dword_806C44C], 0, 8 * (a1 + 1 - dword_806C44C));
    dword_806C44C = a1 + 1;
  }
  v7 = v10[2 * a1];
  ptr = (void *)v10[2 * a1 + 1];
  v14 = *(_DWORD *)(a4 + 4) | 1;
  v15 = sub_805ABEF(
          st7_0,
          v10[2 * a1 + 1],
          v10[2 * a1],
          a2,
          a3,
          *(char **)a4,
          v14,
          a4 + 8,
          *(char **)(a4 + 40),
          *(char **)(a4 + 44));
  if ( v7 <= v15 )
  {
    size = v15 + 1;
    v10[2 * a1] = v15 + 1;
    if ( ptr != &unk_806D2F7 )
      free(ptr);
    ptr = sub_805EC69(size);
    v10[2 * a1 + 1] = (int)ptr;
    sub_805ABEF(st7_0, (int)ptr, size, a2, a3, *(char **)a4, v14, a4 + 8, *(char **)(a4 + 40), *(char **)(a4 + 44));
  }
  *__errno_location() = v12;
  return ptr;
}
// 806C44C: using guessed type int dword_806C44C;
// 806C450: using guessed type int dword_806C450;
// 806C454: using guessed type void *off_806C454;
// 806C458: using guessed type int *off_806C458;

//----- (0805C053) --------------------------------------------------------
void *__usercall sub_805C053@<eax>(double a1@<st0>, signed int a2, char *a3)
{
  return sub_805BE0A(a1, a2, a3, 0xFFFFFFFF, (int)dword_806D2B7);
}
// 806D2B7: using guessed type int dword_806D2B7[];

//----- (0805C07D) --------------------------------------------------------
void *__usercall sub_805C07D@<eax>(double a1@<st0>, signed int a2, char *a3, size_t a4)
{
  return sub_805BE0A(a1, a2, a3, a4, (int)dword_806D2B7);
}
// 806D2B7: using guessed type int dword_806D2B7[];

//----- (0805C0E3) --------------------------------------------------------
void __cdecl __noreturn sub_805C0E3(int a1, int a2)
{
  char v2; // [esp+10h] [ebp-38h]

  sub_805AA24((int)&v2, a2);
}

//----- (0805C121) --------------------------------------------------------
void __cdecl __noreturn sub_805C121(int a1, int a2)
{
  char v2; // [esp+10h] [ebp-38h]

  sub_805AA24((int)&v2, a2);
}

//----- (0805C15E) --------------------------------------------------------
void __cdecl __noreturn sub_805C15E(int a1)
{
  sub_805C0E3(0, a1);
}

//----- (0805C1C3) --------------------------------------------------------
void __cdecl __noreturn sub_805C1C3(int a1, int a2, int a3)
{
  sub_805C121(0, a1);
}

//----- (0805C203) --------------------------------------------------------
void *__usercall sub_805C203@<eax>(double a1@<st0>, char *a2, size_t a3, unsigned __int8 a4)
{
  int v5; // [esp+20h] [ebp-38h]
  int v6; // [esp+24h] [ebp-34h]
  int v7; // [esp+28h] [ebp-30h]
  int v8; // [esp+2Ch] [ebp-2Ch]
  int v9; // [esp+30h] [ebp-28h]
  int v10; // [esp+34h] [ebp-24h]
  int v11; // [esp+38h] [ebp-20h]
  int v12; // [esp+3Ch] [ebp-1Ch]
  int v13; // [esp+40h] [ebp-18h]
  int v14; // [esp+44h] [ebp-14h]
  int v15; // [esp+48h] [ebp-10h]
  int v16; // [esp+4Ch] [ebp-Ch]

  v5 = dword_806D2B7[0];
  v6 = dword_806D2BB;
  v7 = dword_806D2BF;
  v8 = dword_806D2C3;
  v9 = dword_806D2C7;
  v10 = dword_806D2CB;
  v11 = dword_806D2CF;
  v12 = dword_806D2D3;
  v13 = dword_806D2D7;
  v14 = dword_806D2DB;
  v15 = dword_806D2DF;
  v16 = dword_806D2E3;
  sub_805A84E((int)&v5, a4, 1);
  return sub_805BE0A(a1, 0, a2, a3, (int)&v5);
}
// 806D2B7: using guessed type int dword_806D2B7[];
// 806D2BB: using guessed type int dword_806D2BB;
// 806D2BF: using guessed type int dword_806D2BF;
// 806D2C3: using guessed type int dword_806D2C3;
// 806D2C7: using guessed type int dword_806D2C7;
// 806D2CB: using guessed type int dword_806D2CB;
// 806D2CF: using guessed type int dword_806D2CF;
// 806D2D3: using guessed type int dword_806D2D3;
// 806D2D7: using guessed type int dword_806D2D7;
// 806D2DB: using guessed type int dword_806D2DB;
// 806D2DF: using guessed type int dword_806D2DF;
// 806D2E3: using guessed type int dword_806D2E3;

//----- (0805C2AD) --------------------------------------------------------
void *__usercall sub_805C2AD@<eax>(double a1@<st0>, char *a2, unsigned __int8 a3)
{
  return sub_805C203(a1, a2, 0xFFFFFFFF, a3);
}

//----- (0805C2D6) --------------------------------------------------------
void *__usercall sub_805C2D6@<eax>(double a1@<st0>, char *a2)
{
  return sub_805C2AD(a1, a2, 0x3Au);
}

//----- (0805C313) --------------------------------------------------------
void __cdecl __noreturn sub_805C313(int a1, int a2)
{
  char v2; // [esp+10h] [ebp-68h]

  sub_805AA24((int)&v2, a2);
}

//----- (0805C3D8) --------------------------------------------------------
void *__usercall sub_805C3D8@<eax>(double a1@<st0>, signed int a2, int a3, int a4, char *a5)
{
  return sub_805C408(a1, a2, a3, a4, a5, 0xFFFFFFFF);
}

//----- (0805C408) --------------------------------------------------------
void *__usercall sub_805C408@<eax>(double a1@<st0>, signed int a2, int a3, int a4, char *a5, size_t a6)
{
  int v7; // [esp+10h] [ebp-38h]
  int v8; // [esp+14h] [ebp-34h]
  int v9; // [esp+18h] [ebp-30h]
  int v10; // [esp+1Ch] [ebp-2Ch]
  int v11; // [esp+20h] [ebp-28h]
  int v12; // [esp+24h] [ebp-24h]
  int v13; // [esp+28h] [ebp-20h]
  int v14; // [esp+2Ch] [ebp-1Ch]
  int v15; // [esp+30h] [ebp-18h]
  int v16; // [esp+34h] [ebp-14h]
  int v17; // [esp+38h] [ebp-10h]
  int v18; // [esp+3Ch] [ebp-Ch]

  v7 = dword_806D2B7[0];
  v8 = dword_806D2BB;
  v9 = dword_806D2BF;
  v10 = dword_806D2C3;
  v11 = dword_806D2C7;
  v12 = dword_806D2CB;
  v13 = dword_806D2CF;
  v14 = dword_806D2D3;
  v15 = dword_806D2D7;
  v16 = dword_806D2DB;
  v17 = dword_806D2DF;
  v18 = dword_806D2E3;
  sub_805A9BE(&v7, a3, a4);
  return sub_805BE0A(a1, a2, a5, a6, (int)&v7);
}
// 806D2B7: using guessed type int dword_806D2B7[];
// 806D2BB: using guessed type int dword_806D2BB;
// 806D2BF: using guessed type int dword_806D2BF;
// 806D2C3: using guessed type int dword_806D2C3;
// 806D2C7: using guessed type int dword_806D2C7;
// 806D2CB: using guessed type int dword_806D2CB;
// 806D2CF: using guessed type int dword_806D2CF;
// 806D2D3: using guessed type int dword_806D2D3;
// 806D2D7: using guessed type int dword_806D2D7;
// 806D2DB: using guessed type int dword_806D2DB;
// 806D2DF: using guessed type int dword_806D2DF;
// 806D2E3: using guessed type int dword_806D2E3;

//----- (0805C502) --------------------------------------------------------
void *__usercall sub_805C502@<eax>(double st7_0@<st0>, signed int a1, char *a2, size_t a3)
{
  return sub_805BE0A(st7_0, a1, a2, a3, (int)&unk_806C46C);
}

//----- (0805C54D) --------------------------------------------------------
void *__usercall sub_805C54D@<eax>(double st7_0@<st0>, signed int a1, char *a2)
{
  return sub_805C502(st7_0, a1, a2, 0xFFFFFFFF);
}

//----- (0805C56F) --------------------------------------------------------
void *__usercall sub_805C56F@<eax>(double st7_0@<st0>, char *a1)
{
  return sub_805C54D(st7_0, 0, a1);
}

//----- (0805C5FD) --------------------------------------------------------
#error "805C5EA: call analysis failed (funcsize=37)"

//----- (0805C626) --------------------------------------------------------
#error "805C62D: call analysis failed (funcsize=12)"

//----- (0805C659) --------------------------------------------------------
_DWORD *__cdecl sub_805C659(int a1, int a2)
{
  _DWORD *result; // eax

  result = sub_805EC7C(0x81Cu);
  *result = a1;
  result[1] = sub_805C5FD;
  result[2] = a2;
  return result;
}
// 805C5FD: using guessed type int __cdecl sub_805C5FD(int);

//----- (0805C68E) --------------------------------------------------------
unsigned int __cdecl sub_805C68E(int a1, int a2, size_t nbytes)
{
  unsigned int v3; // edx
  int v4; // ecx
  size_t v5; // eax
  int v6; // eax
  size_t n; // ST24_4
  int v8; // eax
  size_t v9; // ST2C_4
  int v10; // eax
  size_t v11; // ST30_4
  unsigned int result; // eax
  int v13; // eax
  size_t v14; // ST34_4
  unsigned int v15; // [esp+18h] [ebp-30h]
  int fd; // [esp+20h] [ebp-28h]
  struct timeval tv; // [esp+38h] [ebp-10h]

  v15 = 0;
  fd = open64("/dev/urandom", 0);
  if ( fd >= 0 )
  {
    v5 = a2;
    if ( nbytes <= a2 )
      v5 = nbytes;
    v15 = read(fd, (void *)a1, v5);
    if ( (v15 & 0x80000000) != 0 )
      v15 = 0;
    close(fd);
  }
  if ( v15 < a2 )
  {
    v6 = a2 - v15;
    if ( a2 - v15 > 8 )
      v6 = 8;
    n = v6;
    gettimeofday(&tv, 0);
    memcpy((void *)(a1 + v15), &tv, n);
    v3 = v15;
    v15 += n;
  }
  if ( v15 < a2 )
  {
    dword_806C324 = (int)&loc_805C768;
    sub_8062148(v4, v3);
  }
  if ( v15 < a2 )
  {
    v8 = a2 - v15;
    if ( a2 - v15 > 4 )
      v8 = 4;
    v9 = v8;
    tv.tv_sec = getppid();
    memcpy((void *)(a1 + v15), &tv, v9);
    v15 += v9;
  }
  if ( v15 < a2 )
  {
    v10 = a2 - v15;
    if ( a2 - v15 > 4 )
      v10 = 4;
    v11 = v10;
    tv.tv_sec = getuid();
    memcpy((void *)(a1 + v15), &tv, v11);
    v15 += v11;
  }
  result = v15;
  if ( v15 < a2 )
  {
    v13 = a2 - v15;
    if ( a2 - v15 > 4 )
      v13 = 4;
    v14 = v13;
    tv.tv_sec = getgid();
    memcpy((void *)(a1 + v15), &tv, v14);
    result = v15 + v14;
  }
  return result;
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 8062148: using guessed type int __fastcall sub_8062148(_DWORD, _DWORD);
// 806C324: using guessed type int dword_806C324;

//----- (0805C8D5) --------------------------------------------------------
char *__usercall sub_805C8D5@<eax>(double a1@<st0>, int a2, size_t n)
{
  void *v4; // eax
  size_t v5; // eax
  FILE *stream; // [esp+18h] [ebp-10h]
  char *v7; // [esp+1Ch] [ebp-Ch]

  if ( !n )
    return (char *)sub_805C659(0, 0);
  v4 = &loc_805C920;
  if ( !a2 )
    v4 = &loc_805C943;
  dword_806C248 = (int)v4;
  sub_8062696();
  stream = sub_8060FEC(a1, a2, "rb");
  if ( !stream )
    return 0;
  v7 = (char *)sub_805C659((int)stream, a2);
  if ( stream )
  {
    v5 = 2048;
    if ( n <= 0x800 )
      v5 = n;
    setvbuf(stream, v7 + 12, 0, v5);
  }
  else
  {
    *((_DWORD *)v7 + 3) = 0;
    sub_805C68E((int)(v7 + 16), 1024, n);
    sub_805D1D6((_DWORD *)v7 + 4);
  }
  return v7;
}
// 8062696: using guessed type int sub_8062696(void);
// 806C248: using guessed type int dword_806C248;

//----- (0805C9E9) --------------------------------------------------------
int __cdecl sub_805C9E9(int a1, int a2)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 8) = a2;
  return result;
}

//----- (0805C9F7) --------------------------------------------------------
int __cdecl sub_805C9F7(int a1, void *ptr, size_t n)
{
  size_t v3; // ST20_4
  int v4; // ST24_4
  void *v5; // eax

  v3 = fread_unlocked(ptr, 1u, n, *(FILE **)a1);
  v4 = *__errno_location();
  v5 = &loc_805CA59;
  if ( n != v3 )
    v5 = &loc_805CA5B;
  dword_806C2C0 = (int)v5;
  return sub_806239B();
}
// 806C2C0: using guessed type int dword_806C2C0;

//----- (0805CA9B) --------------------------------------------------------
int __cdecl sub_805CA9B(int a1, void *dest, size_t n)
{
  int result; // eax
  void *v4; // eax
  size_t v5; // [esp+14h] [ebp-14h]
  char *v6; // [esp+18h] [ebp-10h]
  char *v7; // [esp+1Ch] [ebp-Ch]
  size_t na; // [esp+38h] [ebp+10h]

  v5 = *(_DWORD *)a1;
  v7 = (char *)dest;
  if ( n > v5 )
  {
    memcpy(dest, (const void *)(a1 + 1024 - v5 + 1040), v5);
    na = n - v5;
    v4 = &loc_805CB4F;
    if ( ((_BYTE)v7 + (_BYTE)v5) & 3 )
      v4 = &loc_805CB9A;
    dword_806C2D4 = (int)v4;
    sub_8062323();
    v6 = &v7[v5];
    while ( na > 0x3FF )
    {
      sub_805CCE1((int *)(a1 + 4), v6);
      v6 += 1024;
      na -= 1024;
      if ( !na )
      {
        result = a1;
        *(_DWORD *)a1 = 0;
        return result;
      }
    }
    sub_805CCE1((int *)(a1 + 4), (_DWORD *)(a1 + 1040));
    v5 = 1024;
    dword_806C2D4 = (int)&loc_805CAA9;
    result = sub_8062323();
  }
  else
  {
    memcpy(dest, (const void *)(a1 + 1024 - v5 + 1040), n);
    result = a1;
    *(_DWORD *)a1 = v5 - n;
  }
  return result;
}
// 8062323: using guessed type int sub_8062323(void);
// 806C2D4: using guessed type int dword_806C2D4;

//----- (0805CBD5) --------------------------------------------------------
int __cdecl sub_805CBD5(int a1, void *ptr, size_t n)
{
  int result; // eax

  if ( *(_DWORD *)a1 )
    result = sub_805C9F7(a1, ptr, n);
  else
    result = sub_805CA9B(a1 + 12, ptr, n);
  return result;
}

//----- (0805CC1D) --------------------------------------------------------
int __cdecl sub_805CC1D(void *ptr)
{
  FILE *stream; // [esp+1Ch] [ebp-Ch]

  stream = *(FILE **)ptr;
  explicit_bzero(ptr, 2076);
  free(ptr);
  if ( stream )
  {
    dword_806C2AC = (int)&loc_805CC68;
    sub_8062420();
  }
  return 0;
}
// 8049DE0: using guessed type int __cdecl explicit_bzero(_DWORD, _DWORD);
// 8062420: using guessed type int sub_8062420(void);
// 806C2AC: using guessed type int dword_806C2AC;

//----- (0805CC99) --------------------------------------------------------
int __cdecl sub_805CC99(int a1)
{
  return a1;
}

//----- (0805CCB0) --------------------------------------------------------
int __cdecl sub_805CCB0(int a1, __int16 a2)
{
  return *(_DWORD *)((a2 & 0x3FC) + a1);
}

//----- (0805CCE1) --------------------------------------------------------
int *__cdecl sub_805CCE1(int *a1, _DWORD *a2)
{
  int v2; // edx
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  unsigned int v9; // eax
  unsigned int *v10; // ebx
  int v11; // eax
  _DWORD *v12; // ebx
  int v13; // eax
  int v14; // eax
  unsigned int v15; // eax
  unsigned int *v16; // ebx
  int v17; // eax
  _DWORD *v18; // ebx
  int v19; // eax
  int *result; // eax
  int v21; // [esp+8h] [ebp-54h]
  int v22; // [esp+Ch] [ebp-50h]
  int *v23; // [esp+10h] [ebp-4Ch]
  _DWORD *v24; // [esp+14h] [ebp-48h]
  int v25; // [esp+18h] [ebp-44h]
  unsigned int v26; // [esp+1Ch] [ebp-40h]
  int v27; // [esp+20h] [ebp-3Ch]
  unsigned int v28; // [esp+24h] [ebp-38h]
  int v29; // [esp+28h] [ebp-34h]
  unsigned int v30; // [esp+2Ch] [ebp-30h]
  int v31; // [esp+30h] [ebp-2Ch]
  unsigned int v32; // [esp+34h] [ebp-28h]
  int v33; // [esp+38h] [ebp-24h]
  unsigned int v34; // [esp+3Ch] [ebp-20h]
  int v35; // [esp+40h] [ebp-1Ch]
  unsigned int v36; // [esp+44h] [ebp-18h]
  int v37; // [esp+48h] [ebp-14h]
  int v38; // [esp+50h] [ebp-Ch]
  unsigned int v39; // [esp+54h] [ebp-8h]

  v21 = a1[256];
  v2 = a1[257];
  v22 = v2 + ++a1[258];
  v23 = a1;
  v24 = a2;
  do
  {
    v21 = (v21 ^ (v21 << 13)) + v23[128];
    v25 = *v23;
    v26 = sub_805CCB0((int)a1, v25) + v21 + v22;
    *v23 = v26;
    v3 = sub_805CCB0((int)a1, v26 >> 8);
    v22 = sub_805CC99(v25 + v3);
    *v24 = v22;
    v21 = (v21 ^ ((unsigned int)sub_805CC99(v21) >> 6)) + v23[129];
    v27 = v23[1];
    v28 = sub_805CCB0((int)a1, v27) + v21 + v22;
    v23[1] = v28;
    v4 = sub_805CCB0((int)a1, v28 >> 8);
    v22 = sub_805CC99(v27 + v4);
    v24[1] = v22;
    v21 = (v21 ^ 4 * v21) + v23[130];
    v29 = v23[2];
    v30 = sub_805CCB0((int)a1, v29) + v21 + v22;
    v23[2] = v30;
    v5 = sub_805CCB0((int)a1, v30 >> 8);
    v22 = sub_805CC99(v29 + v5);
    v24[2] = v22;
    v21 = (v21 ^ ((unsigned int)sub_805CC99(v21) >> 16)) + v23[131];
    v31 = v23[3];
    v32 = sub_805CCB0((int)a1, v31) + v21 + v22;
    v23[3] = v32;
    v6 = sub_805CCB0((int)a1, v32 >> 8);
    v22 = sub_805CC99(v31 + v6);
    v24[3] = v22;
    v24 += 4;
    v23 += 4;
  }
  while ( v23 < a1 + 128 );
  do
  {
    v21 = (v21 ^ (v21 << 13)) + *(v23 - 128);
    v33 = *v23;
    v7 = sub_805CCB0((int)a1, v33);
    v34 = v7 + v21 + v22;
    *v23 = v34;
    v8 = sub_805CCB0((int)a1, v34 >> 8);
    v22 = sub_805CC99(v33 + v8);
    *v24 = v22;
    v9 = sub_805CC99(v21);
    v21 = (v21 ^ (v9 >> 6)) + *(v23 - 127);
    v35 = v23[1];
    v10 = (unsigned int *)(v23 + 1);
    v11 = sub_805CCB0((int)a1, v35);
    v36 = v11 + v21 + v22;
    *v10 = v36;
    v12 = v24 + 1;
    v13 = sub_805CCB0((int)a1, v36 >> 8);
    sub_805CC99(v35 + v13);
    dword_806C2AC = (int)&loc_805D06A;
    v14 = sub_8062420();
    v22 = sub_805CC99(v37 + v14);
    *v12 = v22;
    v15 = sub_805CC99(v21);
    v21 = (v21 ^ (v15 >> 16)) + *(v23 - 125);
    v38 = v23[3];
    v16 = (unsigned int *)(v23 + 3);
    v17 = sub_805CCB0((int)a1, v38);
    v39 = v17 + v21 + v22;
    *v16 = v39;
    v18 = v24 + 3;
    v19 = sub_805CCB0((int)a1, v39 >> 8);
    v22 = sub_805CC99(v38 + v19);
    *v18 = v22;
    v24 += 4;
    v23 += 4;
  }
  while ( v23 < a1 + 256 );
  a1[256] = v21;
  result = a1;
  a1[257] = v22;
  return result;
}
// 8062420: using guessed type int sub_8062420(void);
// 806C2AC: using guessed type int dword_806C2AC;

//----- (0805D1D6) --------------------------------------------------------
_DWORD *__cdecl sub_805D1D6(_DWORD *a1)
{
  int v1; // ST18_4
  int v2; // ST1C_4
  int v3; // ST24_4
  int v4; // ST28_4
  int v5; // ST2C_4
  int v6; // ST30_4
  int v7; // ST14_4
  int v8; // ST20_4
  unsigned int v9; // ST18_4
  int v10; // ST24_4
  int v11; // ST1C_4
  int v12; // ST28_4
  int v13; // ST2C_4
  int v14; // ST30_4
  int v15; // ST14_4
  _DWORD *result; // eax
  int v17; // [esp+Ch] [ebp-28h]
  int v18; // [esp+10h] [ebp-24h]
  int v19; // [esp+14h] [ebp-20h]
  unsigned int v20; // [esp+18h] [ebp-1Ch]
  int v21; // [esp+1Ch] [ebp-18h]
  unsigned int v22; // [esp+20h] [ebp-14h]
  int v23; // [esp+24h] [ebp-10h]
  unsigned int v24; // [esp+28h] [ebp-Ch]
  signed int i; // [esp+2Ch] [ebp-8h]

  v17 = 325574490;
  v18 = -1780940711;
  v19 = -1021952437;
  v20 = 255990488;
  v21 = -651539848;
  v22 = -1525007287;
  v23 = -990909925;
  v24 = 811634969;
  for ( i = 0; i <= 255; i += 8 )
  {
    v1 = a1[i + 1] + v18;
    v2 = a1[i + 2] + v19;
    v3 = a1[i + 4] + v21;
    v4 = a1[i + 5] + v22;
    v5 = a1[i + 6] + v23;
    v6 = a1[i + 7] + v24;
    v7 = (v1 << 11) ^ (a1[i] + v17);
    v8 = v7 + a1[i + 3] + v20;
    v9 = ((unsigned int)sub_805CC99(v2) >> 2) ^ (v2 + v1);
    v10 = v9 + v3;
    v11 = (v8 << 8) ^ (v8 + v2);
    v12 = v11 + v4;
    v20 = ((unsigned int)sub_805CC99(v10) >> 16) ^ (v10 + v8);
    v13 = v20 + v5;
    v21 = (v12 << 10) ^ (v12 + v10);
    v14 = v21 + v6;
    v22 = ((unsigned int)sub_805CC99(v13) >> 4) ^ (v13 + v12);
    v15 = v22 + v7;
    v23 = (v14 << 8) ^ (v14 + v13);
    v18 = v23 + v9;
    v24 = ((unsigned int)sub_805CC99(v15) >> 9) ^ (v15 + v14);
    v19 = v24 + v11;
    v17 = v18 + v15;
    a1[i] = v17;
    a1[i + 1] = v18;
    a1[i + 2] = v19;
    a1[i + 3] = v20;
    a1[i + 4] = v21;
    a1[i + 5] = v22;
    a1[i + 6] = v23;
    a1[i + 7] = v24;
  }
  dword_806C358 = (int)&loc_805D3EF;
  sub_8061FAB();
  a1[258] = 0;
  a1[257] = a1[258];
  result = a1;
  a1[256] = a1[257];
  return result;
}
// 8061FAB: using guessed type int sub_8061FAB(void);
// 806C358: using guessed type int dword_806C358;

//----- (0805D5FA) --------------------------------------------------------
signed int __cdecl sub_805D5FA(_DWORD *a1)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_80603A0((int)(a1 + 3), 0, 0, (int)malloc, (int)free);
  sub_80603A0((int)(a1 + 14), 0, 0, (int)malloc, (int)free);
  return sub_80603A0((int)(a1 + 25), 0, 0, (int)malloc, (int)free);
}

//----- (0805D79E) --------------------------------------------------------
_DWORD *__cdecl sub_805D79E(_DWORD *a1)
{
  _DWORD *result; // eax
  int src; // [esp+10h] [ebp-38h]
  _DWORD *v3; // [esp+14h] [ebp-34h]
  _DWORD *v4; // [esp+18h] [ebp-30h]
  int v5; // [esp+1Ch] [ebp-2Ch]
  int v6; // [esp+20h] [ebp-28h]
  _DWORD *v7; // [esp+24h] [ebp-24h]
  _DWORD *v8; // [esp+28h] [ebp-20h]
  _DWORD *v9; // [esp+2Ch] [ebp-1Ch]
  _DWORD *v10; // [esp+30h] [ebp-18h]
  _DWORD *v11; // [esp+34h] [ebp-14h]
  size_t n; // [esp+38h] [ebp-10h]
  _DWORD *v13; // [esp+3Ch] [ebp-Ch]

  v3 = a1 + 3;
  src = a1[6] - a1[5] - 1;
  v4 = a1 + 3;
  v5 = a1[5];
  if ( a1[6] == v5 )
    *((_BYTE *)v4 + 40) |= 2u;
  v4[3] = (v4[6] + v4[3]) & ~v4[6];
  if ( v4[3] - v4[1] > (unsigned int)(v4[4] - v4[1]) )
    v4[3] = v4[4];
  v4[2] = v4[3];
  v6 = v5;
  v7 = a1 + 14;
  v8 = a1 + 14;
  if ( (unsigned int)(a1[18] - a1[17]) <= 3 )
    sub_8060429(v7, 4);
  v9 = v7;
  v10 = (_DWORD *)v7[3];
  *v10 = v6;
  v9[3] += 4;
  v11 = a1 + 25;
  n = 4;
  v13 = a1 + 25;
  if ( (unsigned int)(a1[29] - a1[28]) < 4 )
    sub_8060429(v11, n);
  memcpy((void *)v11[3], &src, n);
  v11[3] += n;
  result = a1;
  ++*a1;
  return result;
}
// 8060429: using guessed type _DWORD __cdecl sub_8060429(_DWORD, _DWORD);

//----- (0805D9A8) --------------------------------------------------------
bool __cdecl sub_805D9A8(FILE *stream, int a2)
{
  bool v2; // zf
  void *v3; // eax
  int v4; // ecx
  int v5; // edx
  void *v6; // eax
  _BYTE *v7; // eax
  unsigned int v8; // ecx
  void *v9; // eax
  int v11; // [esp+3Ch] [ebp-1Ch]
  int v12; // [esp+44h] [ebp-14h]

  v2 = fgetc(stream) == -1;
  v3 = &loc_805D9DB;
  if ( !v2 )
    v3 = &loc_805DA71;
  dword_806C358 = (int)v3;
  sub_8061FAB();
  if ( *(_DWORD *)(a2 + 24) != *(_DWORD *)(a2 + 20) )
  {
    v5 = *(_DWORD *)(a2 + 28) - *(_DWORD *)(a2 + 24);
    v6 = &loc_805DA3D;
    if ( *(_DWORD *)(a2 + 28) != *(_DWORD *)(a2 + 24) )
      v6 = &loc_805DA50;
    dword_806C284 = (int)v6;
    sub_806253E(v4, v5);
    sub_8060429(a2 + 12, 1);
    v7 = *(_BYTE **)(a2 + 24);
    *(_DWORD *)(a2 + 24) = v7 + 1;
    *v7 = 0;
    sub_805D79E((_DWORD *)a2);
  }
  if ( (unsigned int)(*(_DWORD *)(a2 + 72) - *(_DWORD *)(a2 + 68)) <= 3 )
    sub_8060429(a2 + 56, 4);
  **(_DWORD **)(a2 + 68) = 0;
  *(_DWORD *)(a2 + 68) += 4;
  v11 = *(_DWORD *)(a2 + 64);
  if ( *(_DWORD *)(a2 + 68) == v11 )
    *(_BYTE *)(a2 + 96) |= 2u;
  *(_DWORD *)(a2 + 68) = (*(_DWORD *)(a2 + 80) + *(_DWORD *)(a2 + 68)) & ~*(_DWORD *)(a2 + 80);
  v8 = *(_DWORD *)(a2 + 72) - *(_DWORD *)(a2 + 60);
  if ( *(_DWORD *)(a2 + 68) - *(_DWORD *)(a2 + 60) > v8 )
    *(_DWORD *)(a2 + 68) = *(_DWORD *)(a2 + 72);
  *(_DWORD *)(a2 + 64) = *(_DWORD *)(a2 + 68);
  *(_DWORD *)(a2 + 4) = v11;
  v12 = *(_DWORD *)(a2 + 108);
  v9 = &loc_805DC05;
  if ( *(_DWORD *)(a2 + 112) != v12 )
    v9 = &loc_805DC12;
  dword_806C234 = (int)v9;
  sub_8062704(v8, v11);
  *(_BYTE *)(a2 + 140) |= 2u;
  *(_DWORD *)(a2 + 112) = (*(_DWORD *)(a2 + 124) + *(_DWORD *)(a2 + 112)) & ~*(_DWORD *)(a2 + 124);
  if ( *(_DWORD *)(a2 + 112) - *(_DWORD *)(a2 + 104) > (unsigned int)(*(_DWORD *)(a2 + 116) - *(_DWORD *)(a2 + 104)) )
    *(_DWORD *)(a2 + 112) = *(_DWORD *)(a2 + 116);
  *(_DWORD *)(a2 + 108) = *(_DWORD *)(a2 + 112);
  *(_DWORD *)(a2 + 8) = v12;
  return ferror(stream) == 0;
}
// 805D9A8: could not find valid save-restore pair for ebx
// 8060429: using guessed type _DWORD __cdecl sub_8060429(_DWORD, _DWORD);
// 8061FAB: using guessed type int sub_8061FAB(void);
// 806253E: using guessed type int __fastcall sub_806253E(_DWORD, _DWORD);
// 8062704: using guessed type int __fastcall sub_8062704(_DWORD, _DWORD);
// 806C234: using guessed type int dword_806C234;
// 806C284: using guessed type int dword_806C284;
// 806C358: using guessed type int dword_806C358;

//----- (0805DCAC) --------------------------------------------------------
int __cdecl sub_805DCAC(int a1, int a2)
{
  int v2; // eax
  int v3; // ecx

  v2 = mkostemp64(a1, a2);
  return sub_8060F1E(a2, v3, v2, a2);
}
// 8049A10: using guessed type int __cdecl mkostemp64(_DWORD, _DWORD);

//----- (0805DCD5) --------------------------------------------------------
int __cdecl sub_805DCD5(_BYTE *a1, _BYTE *a2, char a3)
{
  int result; // eax
  _BYTE *v4; // eax
  _BYTE *v5; // eax
  int v6; // eax
  char v7; // [esp+0h] [ebp-4h]
  _BYTE *v8; // [esp+Ch] [ebp+8h]

  v7 = a3;
  if ( *a1 != a3 || *a2 != v7 )
  {
    v4 = a1;
    v8 = a1 + 1;
    if ( *v4 != v7 )
    {
      v5 = a2++;
      if ( *v5 != v7 )
        return 0;
LABEL_24:
      while ( *a2 == 48 )
        ++a2;
      v6 = -((unsigned int)((char)*a2 - 48) <= 9);
      dword_806C248 = (int)&locret_805DE56;
      sub_8062696();
      return 0;
    }
    while ( *v8 == 48 )
      ++v8;
    result = (unsigned int)((char)*v8 - 48) <= 9;
  }
  else
  {
    while ( *++a1 == *++a2 )
    {
      if ( (unsigned int)((char)*a1 - 48) > 9 )
        return 0;
    }
    if ( (unsigned int)((char)*a1 - 48) <= 9 && (unsigned int)((char)*a2 - 48) <= 9 )
      return (char)*a1 - (char)*a2;
    if ( (unsigned int)((char)*a1 - 48) <= 9 )
    {
      dword_806C248 = (int)&loc_805DDD4;
      sub_8062696();
    }
    if ( (unsigned int)((char)*a2 - 48) <= 9 )
      goto LABEL_24;
    result = 0;
  }
  return result;
}
// 8062696: using guessed type int sub_8062696(void);
// 806C248: using guessed type int dword_806C248;

//----- (0805DE58) --------------------------------------------------------
#error "805DEDA: call analysis failed (funcsize=436)"

//----- (0805E402) --------------------------------------------------------
int __cdecl sub_805E402(int a1, int a2, int a3, int a4)
{
  return sub_805DE58(a1, a2, a3, a4);
}
// 805DE58: using guessed type _DWORD __cdecl sub_805DE58(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0805E42A) --------------------------------------------------------
int __cdecl sub_805E42A(int fd)
{
  void *v1; // eax
  int v2; // ST20_4
  int v3; // ST24_4

  if ( fd >= 0 )
  {
    v1 = &loc_805E455;
    if ( fd > 2 )
      v1 = &loc_805E488;
    dword_806C220 = (int)v1;
    sub_806277E();
    v2 = sub_8061AAD(fd);
    v3 = *__errno_location();
    close(fd);
    *__errno_location() = v3;
    fd = v2;
  }
  return fd;
}
// 806277E: using guessed type int sub_806277E(void);
// 806C220: using guessed type int dword_806C220;

//----- (0805E48D) --------------------------------------------------------
int __cdecl sub_805E48D(FILE *stream, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // edx
  int v7; // ecx
  char *v8; // eax
  char *v9; // eax
  int v10; // ebx
  char *v11; // eax
  int result; // eax
  int v13; // esi
  int v14; // ebx
  char *v15; // eax
  int v16; // edx
  int v17; // ecx
  int v18; // edi
  int v19; // esi
  int v20; // ebx
  char *v21; // eax
  int v22; // edi
  int v23; // esi
  int v24; // ebx
  char *v25; // eax
  int v26; // edi
  int v27; // esi
  int v28; // ebx
  char *v29; // eax
  int v30; // edi
  int v31; // esi
  int v32; // ebx
  char *v33; // eax
  int v34; // esi
  int v35; // edi
  int v36; // ebx
  char *v37; // eax
  int v38; // edi
  int v39; // esi
  int v40; // ebx
  char *v41; // eax
  int v42; // edi
  int v43; // esi
  int v44; // ebx
  char *v45; // eax
  int v46; // edi
  int v47; // esi
  int v48; // ebx
  char *v49; // eax
  char *v50; // [esp+8h] [ebp-60h]
  int v51; // [esp+Ch] [ebp-5Ch]
  int v52; // [esp+10h] [ebp-58h]
  int v53; // [esp+14h] [ebp-54h]
  int v54; // [esp+18h] [ebp-50h]
  int v55; // [esp+1Ch] [ebp-4Ch]
  int v56; // [esp+20h] [ebp-48h]
  int v57; // [esp+24h] [ebp-44h]
  int v58; // [esp+28h] [ebp-40h]
  int v59; // [esp+38h] [ebp-30h]
  int v60; // [esp+3Ch] [ebp-2Ch]
  int v61; // [esp+40h] [ebp-28h]
  int v62; // [esp+44h] [ebp-24h]
  int v63; // [esp+48h] [ebp-20h]
  int v64; // [esp+4Ch] [ebp-1Ch]

  if ( a2 )
  {
    v52 = a4;
    fprintf(stream, "%s (%s) %s\n", a2, a3, a4);
    dword_806C234 = (int)&loc_805E4FC;
    sub_8062704(v7, v6);
  }
  v51 = a4;
  v50 = (char *)a3;
  fprintf(stream, "%s %s\n", a3, a4);
  v8 = gettext("(C)");
  v51 = 2017;
  v50 = v8;
  fprintf(stream, "Copyright %s %d Free Software Foundation, Inc.", v8, 2017);
  v9 = gettext(
         "\n"
         "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\n"
         "This is free software: you are free to change and redistribute it.\n"
         "There is NO WARRANTY, to the extent permitted by law.\n"
         "\n");
  fputs_unlocked(v9, stream);
  switch ( a6 )
  {
    case 0:
      abort();
      return result;
    case 1:
      v10 = *(_DWORD *)a5;
      v11 = gettext("Written by %s.\n");
      v50 = (char *)v10;
      return fprintf(stream, v11, v10);
    case 2:
      v13 = *(_DWORD *)(a5 + 4);
      v14 = *(_DWORD *)a5;
      v15 = gettext("Written by %s and %s.\n");
      v51 = v13;
      v50 = (char *)v14;
      fprintf(stream, v15, v14, v13);
      dword_806C338 = (int)&loc_805E9CB;
      sub_80620D8(v17, v16);
      goto LABEL_7;
    case 3:
LABEL_7:
      v18 = *(_DWORD *)(a5 + 8);
      v19 = *(_DWORD *)(a5 + 4);
      v20 = *(_DWORD *)a5;
      v21 = gettext("Written by %s, %s, and %s.\n");
      v52 = v18;
      v51 = v19;
      v50 = (char *)v20;
      return fprintf(stream, v21, v20, v19, v18);
    case 4:
      v64 = *(_DWORD *)(a5 + 12);
      v22 = *(_DWORD *)(a5 + 8);
      v23 = *(_DWORD *)(a5 + 4);
      v24 = *(_DWORD *)a5;
      v25 = gettext("Written by %s, %s, %s,\nand %s.\n");
      v53 = v64;
      v52 = v22;
      v51 = v23;
      v50 = (char *)v24;
      return fprintf(stream, v25, v24, v23, v22, v64);
    case 5:
      v64 = *(_DWORD *)(a5 + 16);
      v63 = *(_DWORD *)(a5 + 12);
      v26 = *(_DWORD *)(a5 + 8);
      v27 = *(_DWORD *)(a5 + 4);
      v28 = *(_DWORD *)a5;
      v29 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
      v54 = v64;
      v53 = v63;
      v52 = v26;
      v51 = v27;
      v50 = (char *)v28;
      fprintf(stream, v29, v28, v27, v26, v63, v64);
      dword_806C2FC = (int)&loc_805E9CB;
      sub_806223F();
      goto LABEL_10;
    case 6:
LABEL_10:
      v64 = *(_DWORD *)(a5 + 20);
      v63 = *(_DWORD *)(a5 + 16);
      v62 = *(_DWORD *)(a5 + 12);
      v30 = *(_DWORD *)(a5 + 8);
      v31 = *(_DWORD *)(a5 + 4);
      v32 = *(_DWORD *)a5;
      v33 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
      v55 = v64;
      v54 = v63;
      v53 = v62;
      v52 = v30;
      v51 = v31;
      v50 = (char *)v32;
      result = fprintf(stream, v33, v32, v31, v30, v62, v63, v64);
      break;
    case 7:
      v34 = *(_DWORD *)(a5 + 24);
      v64 = *(_DWORD *)(a5 + 20);
      v63 = *(_DWORD *)(a5 + 16);
      v62 = *(_DWORD *)(a5 + 12);
      v61 = *(_DWORD *)(a5 + 8);
      v35 = *(_DWORD *)(a5 + 4);
      v36 = *(_DWORD *)a5;
      v37 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
      v56 = v34;
      v55 = v64;
      v54 = v63;
      v53 = v62;
      v52 = v61;
      v51 = v35;
      v50 = (char *)v36;
      result = fprintf(stream, v37, v36, v35, v61, v62, v63, v64, v34);
      break;
    case 8:
      v38 = *(_DWORD *)(a5 + 28);
      v64 = *(_DWORD *)(a5 + 24);
      v63 = *(_DWORD *)(a5 + 20);
      v62 = *(_DWORD *)(a5 + 16);
      v61 = *(_DWORD *)(a5 + 12);
      v60 = *(_DWORD *)(a5 + 8);
      v39 = *(_DWORD *)(a5 + 4);
      v40 = *(_DWORD *)a5;
      v41 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
      v57 = v38;
      v56 = v64;
      v55 = v63;
      v54 = v62;
      v53 = v61;
      v52 = v60;
      v51 = v39;
      v50 = (char *)v40;
      result = fprintf(stream, v41, v40, v39, v60, v61, v62, v63, v64, v38);
      break;
    case 9:
      v42 = *(_DWORD *)(a5 + 32);
      v64 = *(_DWORD *)(a5 + 28);
      v63 = *(_DWORD *)(a5 + 24);
      v62 = *(_DWORD *)(a5 + 20);
      v61 = *(_DWORD *)(a5 + 16);
      v60 = *(_DWORD *)(a5 + 12);
      v59 = *(_DWORD *)(a5 + 8);
      v43 = *(_DWORD *)(a5 + 4);
      v44 = *(_DWORD *)a5;
      v45 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
      v58 = v42;
      v57 = v64;
      v56 = v63;
      v55 = v62;
      v54 = v61;
      v53 = v60;
      v52 = v59;
      v51 = v43;
      v50 = (char *)v44;
      result = fprintf(stream, v45, v44, v43, v59, v60, v61, v62, v63, v64, v42);
      break;
    default:
      v46 = *(_DWORD *)(a5 + 32);
      v64 = *(_DWORD *)(a5 + 28);
      v63 = *(_DWORD *)(a5 + 24);
      v62 = *(_DWORD *)(a5 + 20);
      v61 = *(_DWORD *)(a5 + 16);
      v60 = *(_DWORD *)(a5 + 12);
      v59 = *(_DWORD *)(a5 + 8);
      v47 = *(_DWORD *)(a5 + 4);
      v48 = *(_DWORD *)a5;
      v49 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
      v58 = v46;
      v57 = v64;
      v56 = v63;
      v55 = v62;
      v54 = v61;
      v53 = v60;
      v52 = v59;
      v51 = v47;
      v50 = (char *)v48;
      result = fprintf(stream, v49, v48, v47, v59, v60, v61, v62, v63, v64, v46);
      break;
  }
  return result;
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 80620D8: using guessed type int __fastcall sub_80620D8(_DWORD, _DWORD);
// 806223F: using guessed type int sub_806223F(void);
// 8062704: using guessed type int __fastcall sub_8062704(_DWORD, _DWORD);
// 806C234: using guessed type int dword_806C234;
// 806C2FC: using guessed type int dword_806C2FC;
// 806C338: using guessed type int dword_806C338;

//----- (0805EA40) --------------------------------------------------------
int __cdecl sub_805EA40(FILE *stream, int a2, int a3, int a4, int a5)
{
  int *v6; // eax
  unsigned int i; // [esp+24h] [ebp-34h]
  int v8[12]; // [esp+28h] [ebp-30h]

  for ( i = 0; i <= 9; ++i )
  {
    v6 = (int *)a5;
    a5 += 4;
    v8[i] = *v6;
    if ( !v8[i] )
      break;
  }
  return sub_805E48D(stream, a2, a3, a4, (int)v8, i);
}
// 805EA40: using guessed type int var_30[12];

//----- (0805EAB6) --------------------------------------------------------
int sub_805EAB6(FILE *stream, int a2, int a3, int a4, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a4);
  return sub_805EA40(stream, a2, a3, a4, (int)va);
}

//----- (0805EB56) --------------------------------------------------------
void *__cdecl sub_805EB56(unsigned int a1, unsigned int a2)
{
  if ( 0x7FFFFFFF / a2 < a1 )
    sub_805EE5C();
  return sub_805EC7C(a2 * a1);
}

//----- (0805EBB9) --------------------------------------------------------
void *__usercall sub_805EBB9@<eax>(int a1@<edx>, int ecx0@<ecx>, void *ptr, int a2, int a3)
{
  void *v5; // eax
  unsigned int v7; // [esp+1Ch] [ebp-Ch]

  v7 = *(_DWORD *)a2;
  v5 = &loc_805EBE6;
  if ( ptr )
    v5 = &loc_805EC20;
  dword_806C20C = (int)v5;
  sub_80627EE(ecx0, a1);
  if ( !v7 )
    v7 = (0x40u / a3 == 0) + 0x40u / a3;
  if ( 0x7FFFFFFFu / a3 < v7 )
    sub_805EE5C();
  *(_DWORD *)a2 = v7;
  return sub_805ECDC(ptr, a3 * v7);
}
// 80627EE: using guessed type int __fastcall sub_80627EE(_DWORD, _DWORD);
// 806C20C: using guessed type int dword_806C20C;

//----- (0805EC69) --------------------------------------------------------
void *__cdecl sub_805EC69(size_t size)
{
  return sub_805EC7C(size);
}

//----- (0805EC7C) --------------------------------------------------------
void *__cdecl sub_805EC7C(size_t size)
{
  void *v2; // [esp+1Ch] [ebp-Ch]

  v2 = malloc(size);
  if ( !v2 && size )
  {
    dword_806C298 = (int)sub_805ECCF;
    sub_80624B3();
  }
  return v2;
}
// 805ECCF: using guessed type void __noreturn sub_805ECCF();
// 80624B3: using guessed type int sub_80624B3(void);
// 806C298: using guessed type int dword_806C298;

//----- (0805ECDC) --------------------------------------------------------
void *__cdecl sub_805ECDC(void *ptr, size_t size)
{
  void *result; // eax

  if ( size || !ptr )
  {
    realloc(ptr, size);
    dword_806C2D4 = (int)&loc_805ED31;
    sub_8062323();
    result = ptr;
  }
  else
  {
    free(ptr);
    result = 0;
  }
  return result;
}
// 8062323: using guessed type int sub_8062323(void);
// 806C2D4: using guessed type int dword_806C2D4;

//----- (0805EDD1) --------------------------------------------------------
void *__cdecl sub_805EDD1(size_t nmemb, size_t size)
{
  void *v3; // [esp+1Ch] [ebp-Ch]

  if ( 0x7FFFFFFF / size < nmemb || (v3 = calloc(nmemb, size)) == 0 )
    sub_805EE5C();
  return v3;
}

//----- (0805EE0E) --------------------------------------------------------
void *__cdecl sub_805EE0E(void *src, size_t n)
{
  void *v2; // eax

  v2 = sub_805EC7C(n);
  return memcpy(v2, src, n);
}

//----- (0805EE5C) --------------------------------------------------------
void __noreturn sub_805EE5C()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (0805EE95) --------------------------------------------------------
void __cdecl __noreturn sub_805EE95(int errnum)
{
  char *v1; // eax
  char *v2; // eax

  v1 = gettext("string comparison failed");
  error(0, errnum, v1);
  v2 = gettext("Set LC_ALL='C' to work around the problem.");
  error(0, 0, v2);
  sub_805C121(1, 8);
}

//----- (0805EFDF) --------------------------------------------------------
int __cdecl sub_805EFDF(void *s1, size_t n, void *s2, int a4)
{
  int *v4; // eax
  int v6; // [esp+28h] [ebp-10h]

  v6 = sub_8061953(s1, n, s2, a4);
  v4 = __errno_location();
  if ( *v4 )
    sub_805EE95(*v4);
  return v6;
}

//----- (0805F06B) --------------------------------------------------------
signed int __cdecl sub_805F06B(double a1)
{
  struct timespec requested_time; // [esp+28h] [ebp-10h]

  sub_8060CF0(&requested_time, a1);
  do
  {
    *__errno_location() = 0;
    if ( !nanosleep(&requested_time, 0) )
      return 0;
  }
  while ( *__errno_location() == 4 || !*__errno_location() );
  return -1;
}

//----- (0805F0ED) --------------------------------------------------------
signed int __cdecl sub_805F0ED(unsigned int *a1, unsigned int a2)
{
  signed int result; // eax

  if ( 0xFFFFFFFF / a2 >= *a1 )
  {
    *a1 *= a2;
    result = 0;
  }
  else
  {
    *a1 = -1;
    result = 1;
  }
  return result;
}

//----- (0805F131) --------------------------------------------------------
int __cdecl sub_805F131(unsigned int *a1, unsigned int a2, int a3)
{
  int v4; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; i |= sub_805F0ED(a1, a2) )
  {
    v4 = a3--;
    if ( !v4 )
      break;
  }
  return i;
}

//----- (0805F17B) --------------------------------------------------------
int __cdecl sub_805F17B(char *nptr, int a2, int base, int a4, char *s)
{
  char **v5; // eax
  int result; // eax
  int v7; // edx
  int v8; // ecx
  void *v9; // eax
  int v10; // edx
  int v11; // ecx
  void *v12; // eax
  int v13; // eax
  int v14; // edx
  int v15; // ecx
  bool v16; // zf
  void *v17; // eax
  void *v18; // eax
  int v19; // eax
  int v20; // ST08_4
  int v21; // ST0C_4
  int v22; // ST10_4
  int v23; // edx
  int v24; // ecx
  int v25; // [esp+Ch] [ebp-3Ch]
  int v26; // [esp+10h] [ebp-38h]
  int v27; // [esp+14h] [ebp-34h]
  int v28; // [esp+18h] [ebp-30h]
  int v29; // [esp+1Ch] [ebp-2Ch]
  char v30; // [esp+20h] [ebp-28h]
  unsigned int v31; // [esp+24h] [ebp-24h]
  int v32; // [esp+28h] [ebp-20h]
  char *v33; // [esp+2Ch] [ebp-1Ch]
  unsigned int v34; // [esp+30h] [ebp-18h]
  int v35; // [esp+34h] [ebp-14h]
  int v36; // [esp+38h] [ebp-10h]
  char **endptr; // [esp+3Ch] [ebp-Ch]
  int v38; // [esp+40h] [ebp-8h]
  int v39; // [esp+44h] [ebp-4h]
  int savedregs; // [esp+48h] [ebp+0h]

  v32 = 0;
  if ( base < 0 || base > 36 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoul");
  if ( a2 )
    v5 = (char **)a2;
  else
    v5 = (char **)&v30;
  endptr = v5;
  *__errno_location() = 0;
  v33 = nptr;
  HIBYTE(v29) = *nptr;
  while ( (*__ctype_b_loc())[HIBYTE(v29)] & 0x2000 )
    HIBYTE(v29) = *++v33;
  if ( HIBYTE(v29) == 45 )
    return 4;
  v31 = strtoul(nptr, endptr, base);
  if ( *endptr == nptr )
  {
    if ( !s )
      return 4;
    v9 = &loc_805F273;
    if ( !**endptr )
      v9 = &loc_805F29A;
    dword_806C284 = (int)v9;
    sub_806253E(v8, v7);
    if ( !strchr(s, **endptr) )
      return 4;
    v31 = 1;
  }
  else if ( *__errno_location() )
  {
    if ( *__errno_location() != 34 )
      return 4;
    v32 = 1;
  }
  if ( s )
  {
    if ( **endptr )
    {
      v34 = 1024;
      v35 = 1;
      if ( strchr(s, **endptr) )
      {
        switch ( **endptr )
        {
          case 69:
          case 71:
          case 75:
          case 77:
          case 80:
          case 84:
          case 89:
          case 90:
          case 103:
          case 107:
          case 109:
          case 116:
            if ( strchr(s, 48) )
            {
              v12 = &loc_805F398;
              if ( (*endptr)[1] == 68 )
                v12 = &loc_805F3ED;
              dword_806C310 = (int)v12;
              v13 = sub_80621CD(v11, v10);
              if ( v13 == 105 )
              {
                v18 = &loc_805F3E5;
                if ( (*endptr)[2] != 66 )
                  v18 = &loc_805F3EB;
                dword_806C324 = (int)v18;
                sub_8062148(v15, v14);
                v35 += 2;
              }
              else
              {
                v16 = v13 == 66;
                v17 = &loc_805F3BB;
                if ( v16 )
                  v17 = &loc_805F3ED;
                dword_806C338 = (int)v17;
                sub_80620D8(v15, v14);
              }
            }
            break;
          default:
            break;
        }
        switch ( **endptr )
        {
          case 66:
            v36 = sub_805F0ED(&v31, 0x400u);
            goto LABEL_53;
          case 69:
            v36 = sub_805F131(&v31, v34, 6);
            goto LABEL_53;
          case 71:
          case 103:
            v19 = sub_805F131(&v31, v34, 3);
            dword_806C2E8 = (int)&loc_805F5C2;
            sub_80622AD(
              v20,
              v21,
              v22,
              v25,
              v26,
              v27,
              v28,
              v29,
              *(_DWORD *)&v30,
              v31,
              v32,
              v33,
              v34,
              v35,
              v19,
              endptr,
              v38,
              v39,
              savedregs);
            goto LABEL_45;
          case 75:
          case 107:
LABEL_45:
            v36 = sub_805F131(&v31, v34, 1);
            dword_806C338 = (int)&loc_805F5C2;
            sub_80620D8(v24, v23);
            goto LABEL_46;
          case 77:
          case 109:
LABEL_46:
            v36 = sub_805F131(&v31, v34, 2);
            goto LABEL_53;
          case 80:
            v36 = sub_805F131(&v31, v34, 5);
            goto LABEL_53;
          case 84:
          case 116:
            v36 = sub_805F131(&v31, v34, 4);
            goto LABEL_53;
          case 89:
            v36 = sub_805F131(&v31, v34, 8);
            dword_806C2C0 = (int)&loc_805F5C2;
            sub_806239B();
            goto LABEL_51;
          case 90:
LABEL_51:
            v36 = sub_805F131(&v31, v34, 7);
            goto LABEL_53;
          case 98:
            v36 = sub_805F0ED(&v31, 0x200u);
            goto LABEL_53;
          case 99:
            v36 = 0;
            goto LABEL_53;
          case 119:
            v36 = sub_805F0ED(&v31, 2u);
LABEL_53:
            v32 |= v36;
            *endptr += v35;
            if ( **endptr )
              v32 |= 2u;
            goto LABEL_55;
          default:
            *(_DWORD *)a4 = v31;
            result = v32 | 2;
            break;
        }
      }
      else
      {
        *(_DWORD *)a4 = v31;
        result = v32 | 2;
      }
    }
    else
    {
LABEL_55:
      *(_DWORD *)a4 = v31;
      result = v32;
    }
  }
  else
  {
    *(_DWORD *)a4 = v31;
    result = v32;
  }
  return result;
}
// 805F17B: could not find valid save-restore pair for ebx
// 80620D8: using guessed type int __fastcall sub_80620D8(_DWORD, _DWORD);
// 8062148: using guessed type int __fastcall sub_8062148(_DWORD, _DWORD);
// 80621CD: using guessed type int __fastcall sub_80621CD(_DWORD, _DWORD);
// 80622AD: using guessed type int __stdcall sub_80622AD(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806253E: using guessed type int __fastcall sub_806253E(_DWORD, _DWORD);
// 806C284: using guessed type int dword_806C284;
// 806C2C0: using guessed type int dword_806C2C0;
// 806C2E8: using guessed type int dword_806C2E8;
// 806C310: using guessed type int dword_806C310;
// 806C324: using guessed type int dword_806C324;
// 806C338: using guessed type int dword_806C338;

//----- (0805F5F4) --------------------------------------------------------
void __cdecl sub_805F5F4(int a1, int a2, int a3, int a4, int a5, int status)
{
  char *v6; // eax
  char v7; // [esp+22h] [ebp-16h]
  char v8; // [esp+23h] [ebp-15h]
  const char *v9; // [esp+24h] [ebp-14h]
  char *msgid; // [esp+28h] [ebp-10h]
  char *v11; // [esp+2Ch] [ebp-Ch]

  v9 = "--";
  if ( (unsigned int)a1 > 3 )
  {
    if ( a1 != 4 )
      goto LABEL_6;
    msgid = "invalid %s%s argument '%s'";
  }
  else if ( (unsigned int)a1 >= 2 )
  {
    msgid = "invalid suffix in %s%s argument '%s'";
  }
  else
  {
    if ( a1 != 1 )
LABEL_6:
      abort();
    msgid = "%s%s argument '%s' too large";
  }
  if ( a2 >= 0 )
  {
    v11 = *(char **)(16 * a2 + a4);
  }
  else
  {
    v9 -= a2;
    v7 = a3;
    v8 = 0;
    v11 = &v7;
  }
  v6 = gettext(msgid);
  error(status, 0, v6, v9, v11, a5);
}

//----- (0805F6DA) --------------------------------------------------------
void __cdecl __noreturn sub_805F6DA(int a1, int a2, char a3, int a4, int a5)
{
  sub_805F5F4(a1, a2, a3, a4, a5, status);
  abort();
}

//----- (0805F71D) --------------------------------------------------------
signed int __cdecl sub_805F71D(int a1, signed int a2)
{
  signed int result; // eax
  int v3; // ebx

  if ( (unsigned __int64)sub_8061AD2(0xFFFFFFFFFFFFFFFFLL, a2, a2 >> 31) >= *(_QWORD *)a1 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    *(_QWORD *)a1 *= a2;
    result = 0;
  }
  else
  {
    *(_DWORD *)a1 = -1;
    *(_DWORD *)(a1 + 4) = -1;
    result = 1;
  }
  return result;
}

//----- (0805F7A9) --------------------------------------------------------
int __cdecl sub_805F7A9(int a1, int a2, int a3)
{
  int v3; // ecx
  void *v5; // eax

  v5 = &loc_805F7F9;
  if ( a3 )
    v5 = &loc_805F7B8;
  dword_806C284 = (int)v5;
  sub_806253E(v3, a3 - 1);
  return 0;
}
// 806253E: using guessed type int __fastcall sub_806253E(_DWORD, _DWORD);
// 806C284: using guessed type int dword_806C284;

//----- (0805F808) --------------------------------------------------------
int __usercall sub_805F808@<eax>(int a1@<edx>, int ecx0@<ecx>, char *nptr, int a2, int base, int a4)
{
  void *v6; // eax
  const unsigned __int16 **v7; // eax
  int v8; // ecx
  int v9; // edx
  uintmax_t v10; // rax
  int v11; // ecx
  int v12; // ecx
  char *v13; // edx
  void *v14; // eax
  int v15; // edx
  unsigned __int8 i; // [esp+1Bh] [ebp-2Dh]
  char v18; // [esp+1Ch] [ebp-2Ch]
  int v19; // [esp+20h] [ebp-28h]
  char *v20; // [esp+24h] [ebp-24h]
  int v21; // [esp+28h] [ebp-20h]
  int v22; // [esp+2Ch] [ebp-1Ch]
  int v23; // [esp+30h] [ebp-18h]
  char **endptr; // [esp+34h] [ebp-14h]
  int v25; // [esp+38h] [ebp-10h]
  int v26; // [esp+3Ch] [ebp-Ch]

  v19 = 0;
  if ( base < 0 || base > 36 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoumax");
  v6 = &loc_805F840;
  if ( a2 )
    v6 = &loc_805F86B;
  dword_806C338 = (int)v6;
  sub_80620D8(ecx0, a1);
  endptr = (char **)&v18;
  *__errno_location() = 0;
  v20 = nptr;
  for ( i = *nptr; ; i = *v20 )
  {
    v7 = __ctype_b_loc();
    v9 = i;
    if ( !((*v7)[v9] & 0x2000) )
      break;
    ++v20;
  }
  if ( i == 45 )
  {
    dword_806C324 = (int)&locret_805FD2A;
    sub_8062148(v8, v9 * 2);
  }
  v10 = strtoumax(nptr, endptr, base);
  dword_806C270 = (int)&loc_805F916;
  sub_80625B6(v11, HIDWORD(v10));
  v23 = sub_805F7A9((int)&v25, v21, 5);
  v19 |= v23;
  v13 = &(*endptr)[v22];
  *endptr = v13;
  v14 = &loc_805FD15;
  if ( !**endptr )
    v14 = &loc_805FD19;
  dword_806C284 = (int)v14;
  sub_806253E(v12, v13);
  v19 |= 2u;
  v15 = v26;
  *(_DWORD *)a4 = v25;
  *(_DWORD *)(a4 + 4) = v15;
  return v19;
}
// 805F808: could not find valid save-restore pair for ebx
// 80620D8: using guessed type int __fastcall sub_80620D8(_DWORD, _DWORD);
// 8062148: using guessed type int __fastcall sub_8062148(_DWORD, _DWORD);
// 806253E: using guessed type int __fastcall sub_806253E(_DWORD, _DWORD);
// 80625B6: using guessed type int __fastcall sub_80625B6(_DWORD, _DWORD);
// 806C270: using guessed type int dword_806C270;
// 806C284: using guessed type int dword_806C284;
// 806C324: using guessed type int dword_806C324;
// 806C338: using guessed type int dword_806C338;

//----- (0805FD2C) --------------------------------------------------------
int __usercall sub_805FD2C@<eax>(double a1@<st0>, FILE *stream)
{
  int v3; // eax
  __int64 v4; // rax
  int v5; // [esp+14h] [ebp-14h]
  int v6; // [esp+18h] [ebp-10h]

  v5 = 0;
  if ( fileno(stream) < 0 )
    return fclose(stream);
  if ( !__freading(stream) || (v3 = fileno(stream), LODWORD(v4) = lseek64(v3, 0, 0, 1), v4 != -1) )
  {
    if ( sub_805FF92(a1, stream) )
      v5 = *__errno_location();
  }
  v6 = fclose(stream);
  if ( v5 )
  {
    *__errno_location() = v5;
    v6 = -1;
  }
  return v6;
}
// 8049A90: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0805FDEF) --------------------------------------------------------
int __cdecl sub_805FDEF(int fd, int cmd, char a3)
{
  int v3; // ST28_4
  int v5; // [esp+1Ch] [ebp-1Ch]
  char v6; // [esp+20h] [ebp-18h]
  int v7; // [esp+24h] [ebp-14h]

  if ( cmd != 1030 )
    return fcntl(fd, cmd, a3);
  v6 = a3;
  if ( dword_806D3F7 < 0 )
  {
    v5 = sub_805FDEF(fd, 0, a3);
  }
  else
  {
    v5 = fcntl(fd, 1030, a3);
    if ( v5 < 0 && *__errno_location() == 22 )
    {
      v5 = sub_805FDEF(fd, 0, v6);
      if ( v5 < 0 )
        return v5;
      dword_806D3F7 = -1;
    }
    else
    {
      dword_806D3F7 = 1;
    }
  }
  if ( v5 >= 0 && dword_806D3F7 == -1 )
  {
    v7 = fcntl(v5, 1);
    if ( v7 < 0 || fcntl(v5, 2, v7 | 1) == -1 )
    {
      v3 = *__errno_location();
      close(v5);
      *__errno_location() = v3;
      v5 = -1;
    }
  }
  return v5;
}
// 806D3F7: using guessed type int dword_806D3F7;

//----- (0805FF59) --------------------------------------------------------
int __cdecl sub_805FF59(FILE *stream)
{
  int result; // eax

  result = stream->_flags & 0x100;
  if ( result )
    result = sub_8060000(stream, 0, 0, 1);
  return result;
}

//----- (0805FF92) --------------------------------------------------------
int __usercall sub_805FF92@<eax>(double a1@<st0>, FILE *fp)
{
  bool v2; // zf
  void *v3; // eax

  if ( fp )
  {
    v2 = __freading(fp) == 0;
    v3 = &loc_805FFC6;
    if ( !v2 )
      v3 = &loc_805FFE8;
    dword_806C248 = (int)v3;
    sub_8062696();
  }
  fflush(fp);
  dword_806C25C = (int)&locret_805FFFE;
  sub_8062626(a1);
  sub_805FF59(fp);
  return fflush(fp);
}
// 8062626: using guessed type int __usercall sub_8062626@<eax>(double@<st0>);
// 8062696: using guessed type int sub_8062696(void);
// 806C248: using guessed type int dword_806C248;
// 806C25C: using guessed type int dword_806C25C;

//----- (08060000) --------------------------------------------------------
int __cdecl sub_8060000(FILE *stream, int a2, int a3, int a4)
{
  int v4; // ecx
  char *v5; // edx
  void *v6; // eax
  void *v7; // eax
  void *v8; // eax
  int v9; // eax
  __off64_t v10; // rax

  v5 = stream->_IO_read_end;
  v6 = &loc_806003B;
  if ( v5 != stream->_IO_read_ptr )
    v6 = &loc_80600F7;
  dword_806C284 = (int)v6;
  sub_806253E(v4, v5);
  v7 = &loc_8060064;
  if ( stream->_IO_write_ptr != stream->_IO_write_base )
    v7 = &loc_80600F7;
  dword_806C2D4 = (int)v7;
  sub_8062323();
  v8 = &loc_8060087;
  if ( stream->_IO_save_base )
    v8 = &loc_80600F7;
  dword_806C220 = (int)v8;
  sub_806277E();
  v9 = fileno(stream);
  LODWORD(v10) = lseek64(v9, a2, a3, a4);
  if ( v10 == -1 )
    return -1;
  stream->_flags &= 0xFFFFFFEF;
  stream->_offset = v10;
  return 0;
}
// 8060000: could not find valid save-restore pair for ebx
// 8049A90: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8062323: using guessed type int sub_8062323(void);
// 806253E: using guessed type int __fastcall sub_806253E(_DWORD, _DWORD);
// 806277E: using guessed type int sub_806277E(void);
// 806C220: using guessed type int dword_806C220;
// 806C284: using guessed type int dword_806C284;
// 806C2D4: using guessed type int dword_806C2D4;

//----- (08060119) --------------------------------------------------------
size_t __cdecl sub_8060119(wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  char v5; // [esp+18h] [ebp-10h]
  size_t v6; // [esp+1Ch] [ebp-Ch]

  if ( !pwc )
    pwc = (wchar_t *)&v5;
  v6 = mbrtowc(pwc, s, n, p);
  if ( v6 <= 0xFFFFFFFD || !n || !((unsigned __int8)sub_8057CFE(0) ^ 1) )
    return v6;
  *pwc = (unsigned __int8)*s;
  return 1;
}

//----- (08060197) --------------------------------------------------------
int __cdecl sub_8060197(int a1, int a2)
{
  if ( *(_BYTE *)(a1 + 40) & 1 )
    return (*(int (__cdecl **)(_DWORD, int))(a1 + 28))(*(_DWORD *)(a1 + 36), a2);
  (*(void (__cdecl **)(int))(a1 + 28))(a2);
  dword_806C2C0 = (int)&locret_8060226;
  return sub_806239B();
}
// 806C2C0: using guessed type int dword_806C2C0;

//----- (08060228) --------------------------------------------------------
int __cdecl sub_8060228(int a1, int a2)
{
  int v2; // edx
  int v3; // ecx

  if ( !(*(_BYTE *)(a1 + 40) & 1) )
    return (*(int (__cdecl **)(int))(a1 + 32))(a2);
  (*(void (__cdecl **)(_DWORD, int))(a1 + 32))(*(_DWORD *)(a1 + 36), a2);
  dword_806C270 = (int)&locret_8060282;
  sub_80625B6(v3, v2);
  dword_806C220 = (int)&loc_8060296;
  return sub_806277E();
}
// 80625B6: using guessed type int __fastcall sub_80625B6(_DWORD, _DWORD);
// 806277E: using guessed type int sub_806277E(void);
// 806C220: using guessed type int dword_806C220;
// 806C270: using guessed type int dword_806C270;

//----- (080602A8) --------------------------------------------------------
signed int __cdecl sub_80602A8(int a1, signed int a2, int a3)
{
  void *v3; // eax
  _DWORD *v5; // [esp+1Ch] [ebp-Ch]

  v3 = &loc_80602CD;
  if ( a3 )
    v3 = &loc_80602D4;
  dword_806C248 = (int)v3;
  sub_8062696();
  if ( !a2 )
    a2 = 4064;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 24) = 7;
  *(_DWORD *)(a1 + 4) = sub_8060197(a1, *(_DWORD *)a1);
  v5 = *(_DWORD **)(a1 + 4);
  if ( !v5 )
    obstack_alloc_failed_handler();
  *(_DWORD *)(a1 + 8) = ((unsigned int)v5 + 15) & 0xFFFFFFF8;
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 8);
  *v5 = (char *)v5 + *(_DWORD *)a1;
  *(_DWORD *)(a1 + 16) = *v5;
  v5[1] = 0;
  *(_BYTE *)(a1 + 40) &= 0xFDu;
  *(_BYTE *)(a1 + 40) &= 0xFBu;
  return 1;
}
// 8062696: using guessed type int sub_8062696(void);
// 806C248: using guessed type int dword_806C248;
// 806C500: using guessed type int (*obstack_alloc_failed_handler)(void);

//----- (080603A0) --------------------------------------------------------
signed int __cdecl sub_80603A0(int a1, signed int a2, int a3, int a4, int a5)
{
  *(_DWORD *)(a1 + 28) = a4;
  *(_DWORD *)(a1 + 32) = a5;
  *(_BYTE *)(a1 + 40) &= 0xFEu;
  return sub_80602A8(a1, a2, a3);
}

//----- (08060429) --------------------------------------------------------
#error "8060638: call analysis failed (funcsize=149)"

//----- (0806064D) --------------------------------------------------------
int __cdecl sub_806064D(int a1, unsigned int a2)
{
  int result; // eax
  int *v3; // ST1C_4
  int *v4; // [esp+18h] [ebp-10h]

  result = *(_DWORD *)(a1 + 4);
  v4 = *(int **)(a1 + 4);
  while ( v4 )
  {
    if ( (unsigned int)v4 < a2 )
    {
      result = *v4;
      if ( *v4 >= a2 )
        break;
    }
    v3 = (int *)v4[1];
    sub_8060228(a1, (int)v4);
    v4 = v3;
    result = a1;
    *(_BYTE *)(a1 + 40) |= 2u;
  }
  if ( v4 )
  {
    *(_DWORD *)(a1 + 12) = a2;
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 16) = *v4;
    result = a1;
    *(_DWORD *)(a1 + 4) = v4;
  }
  else if ( a2 )
  {
    abort();
  }
  return result;
}

//----- (08060895) --------------------------------------------------------
int __cdecl sub_8060895(int a1, char a2)
{
  return __ROR4__(a1, a2);
}

//----- (08060980) --------------------------------------------------------
_BOOL4 __cdecl sub_8060980(signed int a1)
{
  void *v1; // eax
  int v2; // eax

  v1 = &loc_80609A4;
  if ( a1 > 90 )
    v1 = &loc_80609B3;
  dword_806C248 = (int)v1;
  v2 = sub_8062696();
  return v2 >= 65 || (unsigned int)(v2 - 48) <= 9;
}
// 8062696: using guessed type int sub_8062696(void);
// 806C248: using guessed type int dword_806C248;

//----- (080609C9) --------------------------------------------------------
_BOOL4 __cdecl sub_80609C9(signed int a1)
{
  void *v1; // eax
  int v2; // eax

  v1 = &loc_80609ED;
  if ( a1 < 65 )
    v1 = &loc_8060A01;
  dword_806C2FC = (int)v1;
  v2 = sub_806223F();
  return v2 <= 90 || (unsigned int)(v2 - 97) <= 0x19;
}
// 806223F: using guessed type int sub_806223F(void);
// 806C2FC: using guessed type int dword_806C2FC;

//----- (08060A7F) --------------------------------------------------------
_BOOL4 __cdecl sub_8060A7F(int a1)
{
  return (unsigned int)(a1 - 48) <= 9;
}

//----- (08060B29) --------------------------------------------------------
signed int __cdecl sub_8060B29(signed int a1)
{
  void *v1; // eax
  bool v2; // zf
  int v3; // edx
  int v4; // ecx
  void *v5; // eax

  if ( a1 < 9 )
    return 0;
  v1 = &loc_8060B52;
  if ( a1 <= 13 )
    v1 = &loc_8060B70;
  dword_806C248 = (int)v1;
  v2 = sub_8062696() == 32;
  v5 = &loc_8060B70;
  if ( !v2 )
    v5 = &loc_8060B77;
  dword_806C20C = (int)v5;
  sub_80627EE(v4, v3);
  return 1;
}
// 8060B29: could not find valid save-restore pair for ebx
// 8062696: using guessed type int sub_8062696(void);
// 80627EE: using guessed type int __fastcall sub_80627EE(_DWORD, _DWORD);
// 806C20C: using guessed type int dword_806C20C;
// 806C248: using guessed type int dword_806C248;

//----- (08060BBF) --------------------------------------------------------
int __cdecl sub_8060BBF(int a1)
{
  if ( (unsigned int)(a1 - 65) <= 0x19 )
  {
    dword_806C2FC = (int)&loc_8060BED;
    sub_806223F();
  }
  return a1;
}
// 806223F: using guessed type int sub_806223F(void);
// 806C2FC: using guessed type int dword_806C2FC;

//----- (08060C0A) --------------------------------------------------------
int __cdecl sub_8060C0A(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // esi
  unsigned __int8 *v3; // ebx
  unsigned __int8 v5; // [esp+1Eh] [ebp-Ah]
  unsigned __int8 v6; // [esp+1Fh] [ebp-9h]

  v2 = a1;
  v3 = a2;
  if ( a1 == a2 )
    return 0;
  do
  {
    v5 = sub_8060BBF(*v2);
    v6 = sub_8060BBF(*v3);
    if ( !v5 )
      break;
    ++v2;
    ++v3;
  }
  while ( v5 == v6 );
  return v5 - v6;
}

//----- (08060C6F) --------------------------------------------------------
int __usercall sub_8060C6F@<eax>(double a1@<st0>, FILE *fp)
{
  bool v2; // ST1E_1
  bool v4; // [esp+1Dh] [ebp-Bh]
  bool v5; // [esp+1Fh] [ebp-9h]

  v4 = __fpending(fp) != 0;
  v2 = ferror_unlocked(fp) != 0;
  v5 = sub_805FD2C(a1, fp) != 0;
  if ( !v2 && (!v5 || !v4 && *__errno_location() == 9) )
    return 0;
  if ( v5 != 1 )
    *__errno_location() = 0;
  return -1;
}

//----- (08060CF0) --------------------------------------------------------
_DWORD *__userpurge sub_8060CF0@<eax>(_DWORD *a1, double a2)
{
  signed int v2; // ST20_4
  double v3; // ST28_8
  int v4; // ST24_4
  long double v5; // fst7
  int v7; // [esp+20h] [ebp-18h]
  int v8; // [esp+24h] [ebp-14h]

  if ( a2 <= -2147483648.0 )
  {
    sub_80619EF(a1, 2147483648, 0);
  }
  else
  {
    v5 = a2;
    if ( 2147483648.0 <= a2 )
    {
      sub_80619EF(a1, 0x7FFFFFFF, 999999999);
      dword_806C25C = (int)&loc_8060F17;
      sub_8062626(*(double *)&v5);
    }
    v2 = (signed int)a2;
    v3 = (a2 - (long double)v2) * 1000000000.0;
    v4 = (v3 > (long double)(signed int)v3) + (signed int)v3;
    v7 = v4 / 1000000000 + v2;
    v8 = v4 % 1000000000;
    if ( v8 < 0 )
    {
      --v7;
      v8 += 1000000000;
    }
    sub_80619EF(a1, v7, v8);
  }
  return a1;
}
// 8062626: using guessed type int __usercall sub_8062626@<eax>(double@<st0>);
// 806C25C: using guessed type int dword_806C25C;

//----- (08060F1E) --------------------------------------------------------
int __usercall sub_8060F1E@<eax>(int a1@<edx>, int a2@<ecx>, int fd, int a4)
{
  int v4; // ST18_4
  int v5; // ST1C_4

  if ( fd >= 0 && fd <= 2 )
  {
    v4 = sub_8060F6F(a1, a2, fd, a4);
    v5 = *__errno_location();
    close(fd);
    *__errno_location() = v5;
    fd = v4;
  }
  return fd;
}

//----- (08060F6F) --------------------------------------------------------
int __usercall sub_8060F6F@<eax>(int a1@<edx>, int a2@<ecx>, int fd, int a4)
{
  void *v4; // eax

  v4 = &loc_8060F9A;
  if ( !(a4 & 0x80000) )
    v4 = &loc_8060FA1;
  dword_806C20C = (int)v4;
  sub_80627EE(a2, a1);
  return sub_805FDEF(fd, 1030, 3);
}
// 80627EE: using guessed type int __fastcall sub_80627EE(_DWORD, _DWORD);
// 806C20C: using guessed type int dword_806C20C;

//----- (08060FEC) --------------------------------------------------------
FILE *__usercall sub_8060FEC@<eax>(double a1@<st0>, int a2, char *modes)
{
  int v3; // ST28_4
  FILE *stream; // [esp+1Ch] [ebp-1Ch]
  signed int v6; // [esp+20h] [ebp-18h]

  stream = (FILE *)fopen64(a2, modes);
  if ( !stream )
    return stream;
  v6 = fileno(stream);
  if ( v6 < 0 || v6 > 2 )
    return stream;
  dword_806C25C = (int)&loc_8061079;
  sub_8062626(a1);
  v3 = *__errno_location();
  sub_805FD2C(a1, stream);
  *__errno_location() = v3;
  return 0;
}
// 80499F0: using guessed type int __cdecl fopen64(_DWORD, _DWORD);
// 8062626: using guessed type int __usercall sub_8062626@<eax>(double@<st0>);
// 806C25C: using guessed type int dword_806C25C;

//----- (08061111) --------------------------------------------------------
void *sub_8061111()
{
  _BOOL4 v0; // eax
  FILE *v1; // eax
  int v2; // edx
  int v3; // ecx
  bool v4; // zf
  void *v5; // eax
  void *ptr; // [esp+14h] [ebp-B4h]
  void *v8; // [esp+18h] [ebp-B0h]
  char *s; // [esp+1Ch] [ebp-ACh]
  char *v10; // [esp+28h] [ebp-A0h]
  size_t n; // [esp+2Ch] [ebp-9Ch]
  size_t v12; // [esp+30h] [ebp-98h]
  _BOOL4 v13; // [esp+34h] [ebp-94h]
  void *dest; // [esp+38h] [ebp-90h]
  int fd; // [esp+3Ch] [ebp-8Ch]
  FILE *stream; // [esp+40h] [ebp-88h]
  unsigned int v17; // [esp+BCh] [ebp-Ch]

  v17 = __readgsdword(0x14u);
  v8 = (void *)dword_806D3FB;
  if ( !dword_806D3FB )
  {
    ptr = 0;
    v10 = "charset.alias";
    s = getenv("CHARSETALIASDIR");
    if ( !s || !*s )
    {
      ptr = 0;
      s = "/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib";
    }
    n = strlen(s);
    v12 = strlen(v10);
    v0 = n && s[n - 1] != 47;
    v13 = v0;
    dest = malloc(n + v0 + v12 + 1);
    if ( dest )
    {
      memcpy(dest, s, n);
      if ( v13 )
        *((_BYTE *)dest + n) = 47;
      memcpy((char *)dest + n + v13, v10, v12 + 1);
    }
    free(ptr);
    if ( dest )
    {
      fd = open64(dest, 0x20000);
      if ( fd < 0 )
      {
        v8 = &unk_8065C9F;
        dword_806C298 = (int)&loc_80615D1;
        sub_80624B3();
      }
      v1 = fdopen(fd, "r");
      stream = v1;
      v4 = v1 == 0;
      v5 = &loc_8061334;
      if ( !v4 )
        v5 = &loc_8061351;
      dword_806C338 = (int)v5;
      sub_80620D8(v3, v2);
      close(fd);
      v8 = &unk_8065C9F;
      free(dest);
    }
    else
    {
      v8 = &unk_8065C9F;
    }
    dword_806D3FB = (int)v8;
  }
  return v8;
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 80620D8: using guessed type int __fastcall sub_80620D8(_DWORD, _DWORD);
// 80624B3: using guessed type int sub_80624B3(void);
// 806C298: using guessed type int dword_806C298;
// 806C338: using guessed type int dword_806C338;
// 806D3FB: using guessed type int dword_806D3FB;

//----- (0806160A) --------------------------------------------------------
char *sub_806160A()
{
  void *v0; // eax
  bool v1; // zf
  int v2; // edx
  int v3; // ecx
  void *v4; // eax
  size_t v5; // edx
  size_t v6; // eax
  size_t v7; // eax
  char *s1; // [esp+18h] [ebp-10h]
  char *s2; // [esp+1Ch] [ebp-Ch]

  s1 = nl_langinfo(14);
  if ( !s1 )
    s1 = (char *)&unk_8065C9F;
  sub_8061111();
  dword_806C2FC = (int)&loc_80616B3;
  sub_806223F();
  v0 = &loc_806166B;
  if ( *s2 != 42 )
    v0 = &loc_80616FC;
  dword_806C2D4 = (int)v0;
  sub_8062323();
  if ( s2[1] )
  {
    v6 = strlen(s2);
    s2 += v6 + 1;
    v7 = strlen(s2);
    for ( s2 += v7 + 1; *s2; s2 = (char *)sub_80624B3() )
    {
      v1 = strcmp(s1, s2) == 0;
      v4 = &loc_806169C;
      if ( v1 )
        v4 = &loc_80616E4;
      dword_806C324 = (int)v4;
      sub_8062148(v3, v2);
      dword_806C298 = (int)&loc_8061648;
    }
  }
  else
  {
    v5 = strlen(s2) + 1;
    s1 = &s2[v5];
  }
  if ( !*s1 )
    s1 = "ASCII";
  return s1;
}
// 806160A: could not find valid save-restore pair for ebx
// 8062148: using guessed type int __fastcall sub_8062148(_DWORD, _DWORD);
// 806223F: using guessed type int sub_806223F(void);
// 8062323: using guessed type int sub_8062323(void);
// 80624B3: using guessed type int sub_80624B3(void);
// 806C298: using guessed type int dword_806C298;
// 806C2D4: using guessed type int dword_806C2D4;
// 806C2FC: using guessed type int dword_806C2FC;
// 806C324: using guessed type int dword_806C324;

//----- (08061742) --------------------------------------------------------
int __cdecl sub_8061742(char *s1, int a2, char *s2)
{
  bool v3; // zf
  void *v4; // eax
  int v6; // [esp+14h] [ebp-14h]

  *__errno_location() = 0;
  v6 = strcoll(s1, s2);
  if ( !v6 )
  {
    v3 = *__errno_location() == 0;
    v4 = &loc_8061807;
    if ( v3 )
      v4 = &loc_806180E;
    dword_806C2C0 = (int)v4;
    sub_806239B();
  }
  dword_806C2D4 = (int)&loc_8061830;
  sub_8062323();
  return v6;
}
// 8061742: could not find valid save-restore pair for ebx
// 8062323: using guessed type int sub_8062323(void);
// 806C2C0: using guessed type int dword_806C2C0;
// 806C2D4: using guessed type int dword_806C2D4;

//----- (08061835) --------------------------------------------------------
int __cdecl sub_8061835(void *s1, size_t n, void *s2, int a4)
{
  int v4; // edx
  int v5; // ecx
  int v7; // [esp+Ch] [ebp-1Ch]
  char v8; // [esp+1Ah] [ebp-Eh]
  char v9; // [esp+1Bh] [ebp-Dh]
  int v10; // [esp+1Ch] [ebp-Ch]

  if ( n == a4 && !memcmp(s1, s2, n) )
  {
    __errno_location();
    dword_806C338 = (int)&loc_806189B;
    sub_80620D8(v5, v4);
  }
  else
  {
    v8 = *((_BYTE *)s1 + n);
    v9 = *((_BYTE *)s2 + a4);
    *((_BYTE *)s1 + n) = 0;
    *((_BYTE *)s2 + a4) = 0;
    v7 = a4 + 1;
    v10 = sub_8061742((char *)s1, n + 1, (char *)s2);
    *((_BYTE *)s1 + n) = v8;
    *((_BYTE *)s2 + a4) = v9;
    dword_806C220 = (int)&loc_806194E;
    *(_DWORD *)sub_806277E() = 0;
    v10 = 0;
  }
  return v10;
}
// 80620D8: using guessed type int __fastcall sub_80620D8(_DWORD, _DWORD);
// 806277E: using guessed type int sub_806277E(void);
// 806C220: using guessed type int dword_806C220;
// 806C338: using guessed type int dword_806C338;

//----- (08061953) --------------------------------------------------------
int __cdecl sub_8061953(void *s1, size_t n, void *s2, int a4)
{
  int *v4; // eax
  int v6; // [esp+Ch] [ebp-Ch]

  if ( n == a4 && !memcmp(s1, s2, n) )
  {
    v4 = __errno_location();
  }
  else
  {
    v6 = a4;
    sub_8061742((char *)s1, n, (char *)s2);
    dword_806C298 = (int)&locret_80619ED;
    v4 = (int *)sub_80624B3();
  }
  *v4 = 0;
  return 0;
}
// 80624B3: using guessed type int sub_80624B3(void);
// 806C298: using guessed type int dword_806C298;

//----- (080619EF) --------------------------------------------------------
_DWORD *__userpurge sub_80619EF@<eax>(_DWORD *a1, int a2, int a3)
{
  *a1 = a2;
  a1[1] = a3;
  return a1;
}

//----- (08061AAD) --------------------------------------------------------
int __cdecl sub_8061AAD(int fd)
{
  return sub_805FDEF(fd, 0, 3);
}

//----- (08061AD2) --------------------------------------------------------
signed __int64 __cdecl sub_8061AD2(unsigned __int64 a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // esi
  signed __int64 result; // rax
  int v5; // ebp
  void *v6; // eax
  unsigned int v7; // eax
  unsigned int v8; // edx

  if ( a3 )
  {
    if ( a3 > HIDWORD(a1) )
      goto LABEL_18;
    _BitScanReverse((unsigned int *)&v5, a3);
    v6 = &loc_8061B72;
    if ( v5 ^ 0x1F )
      v6 = &loc_8061BA7;
    dword_806C298 = (int)v6;
    v7 = sub_80624B3();
    if ( a2 <= (unsigned int)a1 || v7 < v8 )
      result = 1LL;
    else
LABEL_18:
      result = 0LL;
  }
  else if ( a2 > HIDWORD(a1) )
  {
    result = (unsigned int)(a1 / a2);
  }
  else
  {
    v3 = a2;
    if ( !a2 )
      v3 = 1 / 0u;
    LODWORD(result) = __PAIR__(HIDWORD(a1) % v3, (unsigned int)a1) / v3;
    HIDWORD(result) = HIDWORD(a1) / v3;
  }
  return result;
}
// 80624B3: using guessed type int sub_80624B3(void);
// 806C298: using guessed type int dword_806C298;

//----- (08061C5F) --------------------------------------------------------
#error "8061CB0: positive sp value has been found (funcsize=30)"

//----- (08061E71) --------------------------------------------------------
int __cdecl sub_8061E71(int a1, int a2)
{
  int v3; // [esp-Ch] [ebp-10h]
  int v4; // [esp-8h] [ebp-Ch]
  int v5; // [esp-4h] [ebp-8h]
  int v6; // [esp+0h] [ebp-4h]

  __cxa_atexit(a1, 0, dword_806C370, v3, v4, v5, v6);
  dword_806C2C0 = (int)sub_8061EB4;
  sub_806239B();
  return sub_8061EC1(a1, a2);
}
// 8049AC0: using guessed type int __stdcall __cxa_atexit(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8061EB4: using guessed type int sub_8061EB4();
// 806C2C0: using guessed type int dword_806C2C0;
// 806C370: using guessed type int dword_806C370;

//----- (08061EB4) --------------------------------------------------------
#error "8061EB7: positive sp value has been found (funcsize=0)"

//----- (08061EC1) --------------------------------------------------------
int __cdecl sub_8061EC1(int a1, int a2)
{
  return __xstat64(3, a1, a2);
}
// 8049EB0: using guessed type int __cdecl __xstat64(_DWORD, _DWORD, _DWORD);

//----- (08061EF0) --------------------------------------------------------
int __cdecl sub_8061EF0(int a1, int a2)
{
  return __fxstat64(3, a1, a2);
}
// 8049A30: using guessed type int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD);

//----- (08061F6A) --------------------------------------------------------
#error "8061FA3: positive sp value has been found (funcsize=18)"

//----- (08061FAB) --------------------------------------------------------
#error "8061FB1: positive sp value has been found (funcsize=0)"

//----- (08061FE8) --------------------------------------------------------
void __usercall __noreturn sub_8061FE8(int a1@<ebx>, int a2@<edi>, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11)
{
  int v11; // edx
  int v12; // ecx
  int v13; // [esp-8h] [ebp-10h]
  int v14; // [esp-4h] [ebp-Ch]

  while ( 1 )
  {
    v14 = a11;
    v13 = a10;
    (*(void (__cdecl **)(int, int))(a1 + 4 * a2 - 264))(a10, a11);
    dword_806C20C = (int)sub_8062042;
    sub_80627EE(v12, v11);
    a2 = 0;
  }
}
// 8062042: using guessed type int sub_8062042();
// 80627EE: using guessed type int __fastcall sub_80627EE(_DWORD, _DWORD);
// 806C20C: using guessed type int dword_806C20C;

//----- (080620D8) --------------------------------------------------------
#error "80620DE: positive sp value has been found (funcsize=0)"

//----- (08062148) --------------------------------------------------------
#error "806214E: positive sp value has been found (funcsize=0)"

//----- (0806218C) --------------------------------------------------------
#error "80621C5: positive sp value has been found (funcsize=18)"

//----- (080621CD) --------------------------------------------------------
#error "80621D3: positive sp value has been found (funcsize=0)"

//----- (0806223F) --------------------------------------------------------
#error "8062245: positive sp value has been found (funcsize=0)"

//----- (080622AD) --------------------------------------------------------
#error "80622B3: positive sp value has been found (funcsize=0)"

//----- (08062323) --------------------------------------------------------
#error "8062329: positive sp value has been found (funcsize=0)"

//----- (0806239B) --------------------------------------------------------
#error "80623A1: positive sp value has been found (funcsize=0)"

//----- (08062420) --------------------------------------------------------
#error "8062426: positive sp value has been found (funcsize=0)"

//----- (08062472) --------------------------------------------------------
#error "80624AB: positive sp value has been found (funcsize=18)"

//----- (080624B3) --------------------------------------------------------
#error "80624B9: positive sp value has been found (funcsize=0)"

//----- (080624FD) --------------------------------------------------------
#error "8062536: positive sp value has been found (funcsize=18)"

//----- (0806253E) --------------------------------------------------------
#error "8062544: positive sp value has been found (funcsize=0)"

//----- (080625B6) --------------------------------------------------------
#error "80625BC: positive sp value has been found (funcsize=0)"

//----- (08062626) --------------------------------------------------------
#error "806262C: positive sp value has been found (funcsize=0)"

//----- (08062696) --------------------------------------------------------
#error "806269C: positive sp value has been found (funcsize=0)"

//----- (08062704) --------------------------------------------------------
#error "806270A: positive sp value has been found (funcsize=0)"

//----- (0806277E) --------------------------------------------------------
#error "8062784: positive sp value has been found (funcsize=0)"

//----- (080627EE) --------------------------------------------------------
#error "80627F4: positive sp value has been found (funcsize=0)"

//----- (08062800) --------------------------------------------------------
int (**sub_8062800())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_806BEB4;
  v1 = &off_806BEB8 - off_806BEB4;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_806BEB4[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 806BEB4: using guessed type int (*off_806BEB4[2])();
// 806BEB8: using guessed type int (*off_806BEB8)();

//----- (08062864) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 36 decompilation failure(s) on 360 function(s)"
