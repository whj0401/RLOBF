/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8049750();
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// int raise(int sig);
// int dup2(int fd, int fd2);
// int strcmp(const char *s1, const char *s2);
// int putc_unlocked(int c, FILE *stream);
// ssize_t read(int fd, void *buf, size_t nbytes);
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void _exit(int status);
// void *memmove(void *dest, const void *src, size_t n);
// void free(void *ptr);
// uintmax_t strtoumax(const char *nptr, char **endptr, int base);
// void *memcpy(void *dest, const void *src, size_t n);
// int mbsinit(const mbstate_t *ps);
// int ferror(FILE *stream);
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// int fclose(FILE *stream);
// int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
// int getc_unlocked(FILE *stream);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// __sighandler_t signal(int sig, __sighandler_t handler);
// int __cdecl __sched_cpucount(_DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// double __cdecl strtold(_DWORD, _DWORD); weak
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// int fputc_unlocked(int c, FILE *stream);
// int __fastcall getrlimit64(_DWORD); weak
// int __cdecl stpcpy(_DWORD, _DWORD); weak
// int execlp(const char *file, const char *arg, ...);
// int sysconf(int name);
// __uid_t getuid(void);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// int unlink(const char *name);
// int sigismember(const sigset_t *set, int signo);
// int fflush_unlocked(FILE *stream);
// int iswcntrl(wint_t wc);
// char *textdomain(const char *domainname);
// int __cdecl fopen64(_DWORD, _DWORD); weak
// int ferror_unlocked(FILE *stream);
// int __cdecl mkostemp64(_DWORD, _DWORD); weak
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD); weak
// size_t __ctype_get_mb_cur_max(void);
// __pid_t waitpid(__pid_t pid, int *stat_loc, int options);
// int pthread_sigmask(int how, const __sigset_t *newmask, __sigset_t *oldmask);
// char *strcpy(char *dest, const char *src);
// size_t __fpending(FILE *fp);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// __pid_t getpid(void);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// int pthread_cond_signal(pthread_cond_t *cond);
// void error(int status, int errnum, const char *format, ...);
// size_t fread_unlocked(void *ptr, size_t size, size_t n, FILE *stream);
// int strcoll(const char *s1, const char *s2);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int sysinfo(struct sysinfo *info);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// char *strchr(const char *s, int c);
// size_t strlen(const char *s);
// int fprintf(FILE *stream, const char *format, ...);
// ssize_t write(int fd, const void *buf, size_t n);
// int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *cond_attr);
// int __cdecl open64(_DWORD, _DWORD); weak
// int fcntl(int fd, int cmd, ...);
// int sigaddset(sigset_t *set, int signo);
// size_t strxfrm(char *dest, const char *src, size_t n);
// __gid_t getgid(void);
// void *memset(void *s, int c, size_t n);
// int *__errno_location(void);
// int fileno(FILE *stream);
// int fgetc(FILE *stream);
// int pipe(int pipedes[2]);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// int __cdecl ftruncate64(_DWORD, _DWORD, _DWORD); weak
// __pid_t fork(void);
// int sigemptyset(sigset_t *set);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// int toupper(int c);
// void clearerr_unlocked(FILE *stream);
// char *strrchr(const char *s, int c);
// int pthread_join(pthread_t th, void **thread_return);
// struct lconv *localeconv(void);
// __pid_t getppid(void);
// int __cdecl explicit_bzero(_DWORD, _DWORD); weak
// int __cdecl pipe2(_DWORD, _DWORD); weak
// int __cdecl euidaccess(_DWORD, _DWORD); weak
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int nanosleep(const struct timespec *requested_time, struct timespec *remaining);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// char *bindtextdomain(const char *domainname, const char *dirname);
// int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl sched_getaffinity(_DWORD, _DWORD, _DWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// int feof_unlocked(FILE *stream);
// void abort(void);
// int __cdecl __xstat64(_DWORD, _DWORD, _DWORD); weak
// int strtol(const char *nptr, char **endptr, int base);
// char *ngettext(const char *msgid1, const char *msgid2, unsigned int n);
// int close(int fd);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// void *calloc(size_t nmemb, size_t size);
// int putchar_unlocked(int c);
// int _gmon_start__(void); weak
void sub_8049F73();
void sub_8049F90();
int sub_8049FA0();
int sub_804A010();
int sub_804A030();
void sub_804A08F();
void sub_804A0AA();
int sub_804A0BA();
void sub_804A19C();
void sub_804A1B7();
int sub_804A1C7();
void sub_804A2A9();
void sub_804A2C4();
signed int sub_804A2D4();
void sub_804A3B6();
void sub_804A3D1();
int sub_804A3E1();
void sub_804A4C3();
void sub_804A4DE();
int sub_804A4EE();
void sub_804A5D0();
void sub_804A5EB();
int sub_804A5FB();
// int __usercall sub_804A6AD@<eax>(void (__cdecl *a1)(int *)@<eax>);
void sub_804A6F9();
void sub_804A714();
int sub_804A724();
void sub_804A806();
void sub_804A821();
int sub_804A831();
void sub_804A913();
void sub_804A92E();
int sub_804A93E();
void sub_804AA20();
void sub_804AA3B();
int sub_804AA4B();
void sub_804AB2D();
void sub_804AB48();
int sub_804AB58();
int nullsub_3(void); // weak
// int __usercall sub_804ABBF@<eax>(int a1@<eax>, int (__cdecl *a2)(int *, int)@<edx>);
// int __usercall sub_804AC33@<eax>(void (__cdecl *a1)(int *)@<eax>);
void sub_804AC7F();
void sub_804AC9A();
int sub_804ACAA();
int __cdecl sub_804AD5A(int a1);
int __cdecl sub_804AD6D(unsigned __int8 a1);
int __cdecl sub_804AD7F(unsigned __int8 a1);
int __cdecl sub_804ADD3(unsigned __int64 a1);
int sub_804AE19();
int sub_804AE44();
// int __usercall sub_804AE6F@<eax>(int a1@<ebx>, int a2@<ecx>, char *s1);
_DWORD __cdecl sub_804B033(_DWORD, _DWORD); // weak
void __cdecl __noreturn sub_804B11E(int a1, char *a2);
void __cdecl __noreturn sub_804B180(int status); // idb
int __cdecl sub_804B43C(int a1);
int __cdecl sub_804B471(unsigned __int8 *a1);
int __cdecl sub_804B4A1(int a1, unsigned int a2);
bool __cdecl sub_804B4CF(int a1, int a2);
int __cdecl sub_804B504(__pid_t pid); // idb
void __cdecl __noreturn sub_804B646(int a1);
// int __usercall sub_804B6BA@<eax>(double a1@<st0>, int a2);
// int __usercall sub_804B73D@<eax>(double a1@<st0>, __pid_t pid);
int sub_804B75F();
int sub_804B782();
int sub_804B79B();
int sub_804B7BA();
int sub_804B7F2();
_DWORD __cdecl sub_804B82C(_DWORD, _DWORD); // weak
FILE *__cdecl sub_804BA5E(char *s1, char *modes);
FILE *__cdecl sub_804BBCC(char *s1, char *modes);
int __cdecl sub_804BC0D(FILE *stream, int); // idb
int __cdecl sub_804BCB4(int fd, int fd2); // idb
__pid_t __cdecl sub_804BCE1(int pipedes[2], int a2);
// int __usercall sub_804BE77@<eax>(int a1@<ebx>, int a2, unsigned __int8 a3);
// int __usercall sub_804C001@<eax>(int a1@<ebx>, int a2);
// int __usercall sub_804C01C@<eax>(double a1@<st0>, int a2);
int __cdecl sub_804C1FC(int a1);
// void __usercall sub_804C254(int a1@<edx>, int a2@<ecx>, double a3@<st0>, char *name);
int compar(const void *, const void *); // idb
int sub_804C3DF(void); // weak
// unsigned int __usercall sub_804C62A@<eax>(double st7_0@<st0>, int edx0@<edx>, int ecx0@<ecx>, int a1, char a2, char *a3);
int __cdecl sub_804C8A9(int, int, char *nptr); // idb
int __cdecl sub_804CB83(int, int, char *nptr); // idb
int sub_804CC38();
// int __usercall sub_804CE70@<eax>(double a1@<st0>, int a2, unsigned int a3, int a4, unsigned int a5, int a6);
void __cdecl __noreturn sub_804D085(int, int, size_t size); // idb
int sub_804D0E3(); // weak
int __cdecl sub_804D130(_DWORD *a1);
_DWORD __cdecl sub_804D15B(_DWORD); // weak
unsigned __int8 *__cdecl sub_804D313(int a1, int a2);
int __cdecl sub_804D489(int, FILE *stream, int); // idb
int __cdecl sub_804D98C(char **a1);
int __cdecl sub_804DA51(_BYTE *a1);
int __cdecl sub_804DAE1(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_804DB87(unsigned __int8 *a1, int a2);
int __cdecl sub_804DC13(int a1, int a2);
signed int __cdecl sub_804DC97(int a1, int a2);
int __cdecl sub_804DDB1(unsigned __int8 *a1, unsigned __int8 **a2);
unsigned int __cdecl sub_804DEE3(char *a1);
size_t __cdecl sub_804DFBF(char *dest, char *src, size_t n);
int __cdecl sub_804E097(int, size_t, int, size_t); // idb
_DWORD __cdecl sub_804E752(_DWORD, _DWORD); // weak
int __cdecl sub_804E7C7(int a1, int a2);
// int __usercall sub_804E841@<eax>(int edx0@<edx>, int a2@<ecx>, _BYTE *a1);
_DWORD __cdecl sub_804E88F(_DWORD, _DWORD); // weak
int __cdecl sub_804EB14(int a1);
_DWORD __cdecl sub_804EB67(_DWORD); // weak
_BYTE *__cdecl sub_804EC07(int a1, _BYTE *a2);
// int __usercall __noreturn sub_804ED1D@<eax>(int a1@<ecx>, char *a2@<ebx>, int *a3, char a4);
int sub_804F50D(); // weak
_DWORD __cdecl sub_804F517(_DWORD, _DWORD); // weak
int __cdecl sub_80503D0(int a1, int *a2);
void __cdecl __noreturn sub_8050538(int, FILE *stream, int); // idb
void __cdecl __noreturn sub_80506D6(int a1, char *a2, char a3);
// unsigned int __usercall sub_8050AB2@<eax>(double a1@<st0>, int a2, unsigned int a3, void **a4);
void __cdecl sub_8050BA6(int a1, int a2, int a3, FILE *stream, int a5, void *ptr);
int __cdecl sub_8051642(_DWORD, _DWORD); // weak
int __cdecl sub_8051708(_DWORD *a1, unsigned int a2, _DWORD *a3);
_DWORD __cdecl sub_8051870(_DWORD, _DWORD, _DWORD, _DWORD); // weak
pthread_mutex_t *__cdecl sub_8051B57(int a1, int a2, int a3);
_DWORD __cdecl sub_8051CA6(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_8051D2A(pthread_mutexattr_t *mutexattr, int, int, int); // idb
_BOOL4 __cdecl sub_8051ED1(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8051F50(pthread_mutex_t *a1);
int __cdecl sub_8051F66(pthread_mutex_t *a1);
int __cdecl sub_8051FAD(int a1, int a2);
int __cdecl sub_8051FFB(int a1, int a2);
pthread_mutex_t *__cdecl sub_8052048(int a1);
void __cdecl __noreturn sub_80520C6(int, FILE *stream, int); // idb
int sub_805214C(); // weak
_DWORD __cdecl sub_805214E(_DWORD, _DWORD); // weak
int __cdecl sub_80521A0(FILE *stream, int); // idb
int __cdecl sub_8052641(int a1, int a2);
int __cdecl sub_8052744(int a1, _DWORD *a2);
void __cdecl __noreturn sub_80527B1(int a1, int a2, int a3, int a4);
int sub_8052857(); // weak
void *start_routine(void *); // idb
_DWORD __cdecl sub_80528D6(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
// int __usercall sub_8052B3F@<eax>(int a1@<ebx>, double a2@<st0>, int a3, int a4, int a5, char *s1);
unsigned int __cdecl sub_8052DBF(int a1, unsigned int a2);
void __cdecl sub_8052E76(char *a1);
// void __usercall sub_8052EDC(int a1@<edx>, int a2@<ecx>, FILE *a3@<ebx>, double a4@<st0>, int a5, int a6, int a7, char *s1);
// unsigned int __usercall sub_805338B@<eax>(FILE *a1@<ebx>, double a2@<st0>, char **a3, unsigned int a4, char *a5, unsigned int a6);
_DWORD *__cdecl sub_80537D2(void *src);
void __cdecl __noreturn sub_805381F(int, char *msgid); // idb
void __cdecl __noreturn sub_805386D(int a1);
int __fastcall __noreturn sub_805389E(int a1, int a2);
int sub_80539D8(); // weak
int __cdecl sub_80539DA(char *nptr, int, char *msgid); // idb
int __cdecl sub_8053AE7(int sig); // idb
// _BYTE *__usercall sub_8053B12@<eax>(int a1@<edx>, int a2@<ecx>, _BYTE *a3, int a4, int a5);
void *__cdecl sub_8053C06(void *s);
// void __usercall __noreturn main(double a1@<st0>, int argc, char **argv);
void __noreturn sub_805537D();
int __cdecl sub_8055391(char *s, int, int, size_t); // idb
void __cdecl sub_80554DA(int a1, int a2, int a3);
_DWORD __cdecl sub_805555D(_DWORD, _DWORD, _DWORD); // weak
signed int __cdecl sub_80556AE(int a1, char *s, int a3, int a4, size_t a5, void (*a6)(void));
int sub_80557CE();
_DWORD *__cdecl sub_80558E0(_DWORD *a1);
_DWORD *__cdecl sub_805593C(_DWORD *a1, int a2);
_DWORD *__cdecl sub_8055949(int *a1, _DWORD *a2);
// _DWORD *__usercall sub_80559C6@<eax>(double a1@<st0>, int *a2, _DWORD *a3);
int __cdecl sub_8055CEE(void *src, size_t, int); // idb
int *__cdecl sub_8055F66(int *a1, unsigned int a2, int *a3);
int __cdecl sub_8056C60(int a1, int a2, int a3, int a4, int a5, int a6);
void __cdecl sub_8056CC1(FILE *stream, int a2);
// int __usercall sub_8056D09@<eax>(double a1@<st0>, _BYTE **a2);
// int __usercall sub_8056DF5@<eax>(int a1@<edx>, int a2@<ecx>, double a3@<st0>, unsigned __int8 a4);
signed int __cdecl sub_8056E46(int a1, unsigned int a2, int a3, unsigned int a4);
int __cdecl sub_805707D(char *s1, char *s2); // idb
int __cdecl sub_8057340(int category); // idb
int __cdecl sub_805739E(int a1);
int __cdecl sub_80573A9(int a1);
int __cdecl sub_80573B4(int a1);
// unsigned int __usercall sub_80573BF@<eax>(int a1@<edx>, int a2@<ecx>, int a3);
int __cdecl sub_805759D(_DWORD *a1, int a2);
bool __cdecl sub_8057926(unsigned int a1);
int __cdecl sub_805797D(unsigned int a1);
unsigned int __cdecl sub_80579FE(int a1, unsigned int a2);
bool __cdecl sub_8057A29(int a1, int a2);
// signed int __usercall sub_8057A37@<eax>(double a1@<st0>, int a2);
unsigned int __cdecl sub_8057B05(unsigned int a1, int a2);
_DWORD __cdecl sub_8057BB2(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
void *__cdecl sub_8057F3C(int a1);
int __cdecl sub_8057F77(int a1, _DWORD *a2);
// int __usercall sub_8057FAA@<eax>(double a1@<st0>, int a2, int a3, _DWORD *a4, char a5);
signed int __cdecl sub_805812B(_DWORD *a1, int a2, char a3);
void __cdecl __noreturn sub_80584BF(_DWORD, _DWORD); // weak
void __cdecl __noreturn sub_80587D0(int a1, int a2);
// int __usercall sub_805880F@<eax>(double a1@<st0>, int a2, int a3);
_DWORD *__cdecl sub_8058A59(int (*a1)(), unsigned int a2);
int sub_8058ADE();
void __cdecl sub_8058AE8(void *ptr);
int __cdecl sub_8058B08(int a1, int a2);
_DWORD __cdecl sub_8058BA1(_DWORD); // weak
unsigned int __cdecl sub_8058C69(int a1, unsigned int a2, int a3, int (__cdecl *a4)(int));
int __cdecl sub_8058D7F(int a1, unsigned int a2, int (__cdecl *a3)(int, int));
int __cdecl sub_8058E3F(int a1, int a2);
int __cdecl sub_8058F52(unsigned int a1, int a2);
int __cdecl sub_8058FC0(unsigned __int64 a1, int a2);
int sub_805939C();
_DWORD __cdecl sub_80593FB(_DWORD); // weak
int __cdecl sub_80594BB(char *nptr); // idb
unsigned int __cdecl sub_80595D3(signed int a1);
long double sub_8059669();
long double sub_805973B();
// int __usercall sub_8059812@<eax>(double a1@<st0>, int pipedes[2], int a3);
// int __usercall sub_8059AB9@<eax>(double a1@<st0>);
char *__cdecl sub_8059B30(char *s);
int __cdecl sub_8059CA5(int *a1, unsigned __int8 a2, char a3);
void __fastcall __noreturn sub_8059D5F(int a1, int a2, int *a3, int a4, int a5);
int sub_8059DA5(); // weak
// _DWORD *__userpurge sub_8059DB9@<eax>(_DWORD *a1, int a2);
// const char *__usercall sub_8059E5B@<eax>(int a1@<ebx>, double a2@<st0>, char *msgid, int a3);
_DWORD __cdecl sub_8059F0B(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_8059F72(void *s2, size_t n, mbstate_t *p, int, int, int, int, int); // idb
void *__cdecl sub_805AE44(int a1, int a2, _DWORD *a3, int *a4);
void *__cdecl sub_805B024(signed int a1, int a2, int a3, _DWORD *a4);
void *__cdecl sub_805B28D(signed int a1, int a2);
void *__cdecl sub_805B2B7(signed int a1, int a2, int a3);
void *__cdecl sub_805B32D(signed int a1, int a2, int a3);
void *__cdecl sub_805B36B(signed int a1, int a2, int a3, int a4);
void *__cdecl sub_805B3A8(int a1, int a2);
void *__cdecl sub_805B403(int a1, int a2, unsigned __int8 a3);
void *__cdecl sub_805B4BD(int a1, unsigned __int8 a2);
void *__cdecl sub_805B4F6(int a1);
void *__cdecl sub_805B533(signed int a1, int a2, int a3);
int __cdecl sub_805B5E4(int a1, int a2, int a3, int a4);
int __cdecl sub_805B624(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
void *__cdecl sub_805B778(signed int a1, int a2, int a3);
void *__cdecl sub_805B7D3(signed int a1, int a2);
void *__cdecl sub_805B7F5(int a1);
void __cdecl __noreturn sub_805B810(int a1);
_DWORD *__cdecl sub_805B879(int a1, int a2);
unsigned int __cdecl sub_805B8BE(int a1, int a2, size_t nbytes);
int __cdecl sub_805BADB(int, size_t n); // idb
size_t __cdecl sub_805BC00(int a1, void *ptr, size_t n);
int __cdecl sub_805BC88(int, void *dest, size_t n); // idb
size_t __cdecl sub_805BDB7(int a1, void *ptr, size_t n);
int __cdecl sub_805BDFF(void *ptr); // idb
int __cdecl sub_805BE5A(int a1);
int __cdecl sub_805BE71(int a1, __int16 a2);
_DWORD __cdecl sub_805BEB2(_DWORD, _DWORD); // weak
signed int __cdecl sub_805C975(_DWORD *a1);
_DWORD __cdecl sub_805CB39(_DWORD); // weak
int __cdecl sub_805CBE8(void *src, size_t n); // idb
int __cdecl sub_805CD33(FILE *stream, int); // idb
int __cdecl sub_805D09A(int a1, int a2);
_DWORD __cdecl sub_805D248(_DWORD); // weak
int __cdecl sub_805D7C4(int a1);
// int __usercall sub_805D7FC@<eax>(int a1@<edx>, int a2@<ecx>, int fd);
int __cdecl sub_805D85F(FILE *stream, int, int, int, int, int); // idb
int __cdecl sub_805DEF5(FILE *stream, int, int, int, int); // idb
int sub_805DF6B(FILE *stream, int a2, int a3, int a4, ...);
void *__cdecl sub_805E01B(unsigned int a1, unsigned int a2);
void *__cdecl sub_805E07E(void *ptr, int a2, int a3);
void *__cdecl sub_805E115(size_t size);
void *__cdecl sub_805E128(size_t size);
void *__cdecl sub_805E152(void *ptr, size_t size);
void *__cdecl sub_805E1ED(size_t nmemb, size_t size);
void *__cdecl sub_805E22A(void *src, size_t n);
void __noreturn sub_805E278();
void __cdecl sub_805E2B1(int errnum, int a2, int a3, int a4, int a5);
// int __usercall sub_805E41B@<eax>(int a1@<edx>, int a2@<ecx>, void *s1, size_t n, void *s2, int a6);
int __cdecl sub_805E4A6(double a1);
signed int __cdecl sub_805E552(unsigned int *a1, unsigned int a2);
int __cdecl sub_805E5A6(unsigned int *a1, unsigned int a2, int a3);
int __cdecl sub_805E5DC(char *nptr, int, int base, int, char *s); // idb
// void __usercall sub_805EA12(int edx0@<edx>, int ecx0@<ecx>, int a1, int a2, int a3, int a4, int a5, int status);
void __fastcall __noreturn sub_805EAED(int ecx0, int edx0, int a1, int a2, char a3, int a4, int a5);
signed int __cdecl sub_805EB40(unsigned int *a1, signed int a2);
// int __usercall sub_805EBEC@<eax>(double st7_0@<st0>, int a1, int a2, int a3);
// int __usercall sub_805EC3B@<eax>(double a1@<st0>, int a2@<edx>, int ecx0@<ecx>, char *nptr, int a3, int base, int a5, char *s);
int __cdecl sub_805F0A8(FILE *stream); // idb
// int __usercall sub_805F16B@<eax>(int a1@<edx>, int a2@<ecx>, int fd, int cmd, char a5);
int __cdecl sub_805F2FA(FILE *stream); // idb
int __cdecl sub_805F333(FILE *fp); // idb
int __cdecl sub_805F38C(FILE *stream, int, int, int); // idb
size_t __cdecl sub_805F4B0(wchar_t *pwc, char *s, size_t n, mbstate_t *p);
int __cdecl sub_805F522(int a1, int a2);
int __cdecl sub_805F560(int a1, int a2);
signed int __cdecl sub_805F59E(int a1, signed int a2, signed int a3);
signed int __cdecl sub_805F69D(int a1, signed int a2, signed int a3, int a4, int a5);
_DWORD __cdecl sub_805F746(_DWORD, _DWORD); // weak
// int __usercall sub_805F965@<eax>(int a1@<edx>, int a2@<ecx>, int a3, unsigned int a4);
int __cdecl sub_805FBF5(int a1, char a2);
// signed int __usercall sub_805FD20@<eax>(double a1@<st0>, signed int a2);
// int __usercall sub_805FD65@<eax>(double a1@<st0>, signed int a2);
// int __usercall sub_805FE45@<eax>(int a1@<edx>, int a2@<ecx>, int a3);
signed int __cdecl sub_805FF19(signed int a1);
int __cdecl sub_805FFAB(int a1);
// int __usercall sub_805FFE1@<eax>(double st7_0@<st0>, int a1, int a2);
int __cdecl sub_806005F(FILE *fp); // idb
// _DWORD *__userpurge sub_80600E0@<eax>(_DWORD *a1, double a2);
// int __usercall sub_8060249@<eax>(int a1@<edx>, int a2@<ecx>, int fd, int a4);
// int __usercall sub_806029A@<eax>(int a1@<edx>, int a2@<ecx>, int fd, int a4);
FILE *__cdecl sub_80602D1(int a1, char *modes);
// int __usercall sub_80603A7@<eax>(int a1@<ebx>);
// const char *__usercall sub_80608CC@<eax>(int a1@<ebx>);
int __cdecl sub_806097F(char *s, int, char *s2, int); // idb
int __cdecl sub_8060A55(void *s1, size_t n, void *s2, int); // idb
int __cdecl sub_8060AE6(int, char *s2, int); // idb
// int __usercall sub_8060B5A@<eax>(int a1@<edx>, int a2@<ecx>, void *s1, size_t n, void *s2, int a6);
// _DWORD *__userpurge sub_8060BD2@<eax>(_DWORD *a1, int a2, int a3);
// int __usercall sub_8060C9B@<eax>(int a1@<edx>, int a2@<ecx>, int fd);
int __cdecl sub_8060CC0(unsigned int a1, int a2, unsigned int a3, unsigned int a4);
unsigned __int64 __cdecl sub_8060E13(unsigned __int64 a1, unsigned int a2, unsigned int a3);
int __cdecl sub_806104D(int a1);
int __cdecl sub_806107C(int a1, int a2);
int __cdecl sub_80610AB(int a1, int a2);
int __fastcall sub_8061134(_DWORD); // weak
// int __usercall sub_8061223@<eax>(double@<st0>); weak
// int __userpurge sub_806129D@<eax>(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, double@<st0>); weak
int __fastcall sub_806132A(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
int __fastcall sub_80613B3(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
int __fastcall sub_806141F(_DWORD, _DWORD); // weak
int __fastcall sub_8061491(_DWORD, _DWORD); // weak
int __fastcall sub_8061505(_DWORD, _DWORD, _DWORD, _DWORD);
int __stdcall sub_8061579(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_80615ED(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (**sub_8061600())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_804ADCE; // weak
_UNKNOWN loc_804AF0F; // weak
_UNKNOWN loc_804B002; // weak
_UNKNOWN loc_804B009; // weak
_UNKNOWN loc_804B717; // weak
_UNKNOWN loc_804B71E; // weak
_UNKNOWN loc_804BAA4; // weak
_UNKNOWN loc_804BACA; // weak
_UNKNOWN loc_804BB02; // weak
_UNKNOWN locret_804BCB2; // weak
_UNKNOWN loc_804BE6F; // weak
_UNKNOWN loc_804BF52; // weak
_UNKNOWN loc_804BFB9; // weak
_UNKNOWN loc_804BFFB; // weak
_UNKNOWN loc_804C0BD; // weak
_UNKNOWN loc_804C101; // weak
_UNKNOWN loc_804C2C3; // weak
_UNKNOWN loc_804C2D4; // weak
_UNKNOWN loc_804C6C2; // weak
_UNKNOWN loc_804CC76; // weak
_UNKNOWN loc_804CC99; // weak
_UNKNOWN loc_804CF1D; // weak
_UNKNOWN loc_804CF37; // weak
_UNKNOWN loc_804D07C; // weak
_UNKNOWN loc_804DACE; // weak
_UNKNOWN loc_804DAD5; // weak
_UNKNOWN loc_804DBCD; // weak
_UNKNOWN loc_804DCF0; // weak
_UNKNOWN loc_804DCF7; // weak
_UNKNOWN loc_804E807; // weak
_UNKNOWN loc_804E81D; // weak
_UNKNOWN loc_804E873; // weak
_UNKNOWN loc_804E87E; // weak
_UNKNOWN loc_804F4B6; // weak
_UNKNOWN loc_804F4E3; // weak
_UNKNOWN loc_804F508; // weak
_UNKNOWN loc_8050414; // weak
_UNKNOWN loc_805042A; // weak
_UNKNOWN loc_8050F93; // weak
_UNKNOWN loc_80515BE; // weak
_UNKNOWN loc_80517B8; // weak
_UNKNOWN loc_80517FB; // weak
_UNKNOWN loc_8051852; // weak
_UNKNOWN loc_8051869; // weak
_UNKNOWN locret_805186E; // weak
_UNKNOWN loc_805208B; // weak
_UNKNOWN loc_80526EA; // weak
_UNKNOWN loc_805271D; // weak
_UNKNOWN loc_8052724; // weak
_UNKNOWN loc_8052C34; // weak
_UNKNOWN loc_8052C4D; // weak
_UNKNOWN loc_8052E37; // weak
_UNKNOWN loc_8052E60; // weak
_UNKNOWN loc_8052FC6; // weak
_UNKNOWN loc_80536AA; // weak
_UNKNOWN loc_80538BC; // weak
_UNKNOWN loc_805399E; // weak
_UNKNOWN loc_80539D3; // weak
_UNKNOWN loc_8053B70; // weak
_UNKNOWN loc_8053B79; // weak
_UNKNOWN loc_8053CD4; // weak
_UNKNOWN loc_8053CDB; // weak
_UNKNOWN loc_8053E83; // weak
_UNKNOWN loc_8053FAB; // weak
_UNKNOWN loc_8054044; // weak
_UNKNOWN loc_8054095; // weak
_UNKNOWN loc_80540FB; // weak
_UNKNOWN loc_8054D59; // weak
_UNKNOWN loc_80557FF; // weak
_UNKNOWN loc_805584E; // weak
_UNKNOWN loc_8055889; // weak
_UNKNOWN loc_80558BC; // weak
_UNKNOWN loc_80559FC; // weak
_UNKNOWN loc_8056D1F; // weak
_UNKNOWN loc_8056DF0; // weak
_UNKNOWN loc_8056E68; // weak
_UNKNOWN loc_8056F15; // weak
_UNKNOWN loc_8056F53; // weak
_UNKNOWN loc_8056FF3; // weak
_UNKNOWN loc_8057011; // weak
_UNKNOWN loc_80570C7; // weak
_UNKNOWN loc_80570D1; // weak
_UNKNOWN loc_8057407; // weak
_UNKNOWN locret_8057B03; // weak
_UNKNOWN loc_8058009; // weak
_UNKNOWN loc_8058024; // weak
_UNKNOWN locret_80582CF; // weak
_UNKNOWN loc_8058868; // weak
_UNKNOWN loc_8058872; // weak
_UNKNOWN loc_8058D58; // weak
_UNKNOWN loc_8058F4D; // weak
_UNKNOWN locret_8059667; // weak
_UNKNOWN loc_8059726; // weak
_UNKNOWN loc_80598F6; // weak
_UNKNOWN loc_80599B9; // weak
_UNKNOWN loc_8059A6E; // weak
_UNKNOWN locret_8059AB7; // weak
_UNKNOWN loc_8059AFE; // weak
_UNKNOWN loc_8059B2B; // weak
_UNKNOWN loc_8059BC8; // weak
_UNKNOWN loc_8059C20; // weak
_UNKNOWN loc_8059DA0; // weak
_UNKNOWN locret_8059F09; // weak
_UNKNOWN loc_805D827; // weak
_UNKNOWN loc_805D85A; // weak
_UNKNOWN loc_805E4DD; // weak
_UNKNOWN locret_805E550; // weak
_UNKNOWN loc_805EAA4; // weak
_UNKNOWN loc_805EBFB; // weak
_UNKNOWN loc_805EC36; // weak
_UNKNOWN loc_805EC9D; // weak
_UNKNOWN loc_805EDA7; // weak
_UNKNOWN loc_805EDC6; // weak
_UNKNOWN loc_805EDDC; // weak
_UNKNOWN loc_805F1A1; // weak
_UNKNOWN loc_805F2BB; // weak
_UNKNOWN loc_805F367; // weak
_UNKNOWN loc_805F374; // weak
_UNKNOWN loc_805F9B9; // weak
_UNKNOWN loc_805FD57; // weak
_UNKNOWN loc_805FD89; // weak
_UNKNOWN loc_805FDA7; // weak
_UNKNOWN loc_805FDAF; // weak
_UNKNOWN loc_805FDCB; // weak
_UNKNOWN loc_805FDD0; // weak
_UNKNOWN loc_805FE74; // weak
_UNKNOWN loc_805FF42; // weak
_UNKNOWN loc_805FF47; // weak
_UNKNOWN loc_806000C; // weak
_UNKNOWN loc_8060013; // weak
_UNKNOWN loc_8060439; // weak
_UNKNOWN loc_806044D; // weak
_UNKNOWN loc_8060683; // weak
_UNKNOWN loc_80606BC; // weak
_UNKNOWN loc_806084C; // weak
_UNKNOWN loc_8060B81; // weak
_UNKNOWN loc_8060BB0; // weak
_UNKNOWN loc_8060E90; // weak
_UNKNOWN loc_8060EE9; // weak
char s = '\0'; // idb
struct option longopts = { "ignore-leading-blanks", 0, NULL, 98 }; // idb
char byte_8062E98[256] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x06',
  '\0',
  '\x03',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0',
  '\x04',
  '\0',
  '\0',
  '\0',
  '\0',
  '\b',
  '\a',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
int sig[11] = { 14, 1, 2, 13, 3, 15, 29, 27, 26, 24, 25 }; // idb
_UNKNOWN unk_8063B18; // weak
_UNKNOWN unk_8063B68; // weak
_UNKNOWN unk_8063D66; // weak
_UNKNOWN unk_8063D6A; // weak
_UNKNOWN unk_8063D76; // weak
_UNKNOWN unk_8063D7A; // weak
_UNKNOWN unk_8063D7D; // weak
_UNKNOWN unk_8064A67; // weak
int dword_8064F04 = 4294920505; // weak
_UNKNOWN unk_8066354; // weak
_UNKNOWN unk_8066357; // weak
int dword_8067EF0 = 4294936318; // weak
_UNKNOWN unk_806839C; // weak
_UNKNOWN unk_806839F; // weak
int (*off_8069ED0[2])() = { &sub_804A030, &sub_804A010 }; // weak
int (*off_8069ED4)() = &sub_804A010; // weak
int (*dword_806A008)(void) = NULL; // weak
int dword_806A20C = 0; // weak
int dword_806A220 = 0; // weak
int dword_806A234 = 0; // weak
int dword_806A248 = 0; // weak
int dword_806A25C = 0; // weak
int dword_806A270 = 0; // weak
int dword_806A284 = 0; // weak
int dword_806A298 = 0; // weak
int dword_806A2AC = 0; // weak
int dword_806A2CC = 0; // weak
int dword_806A2E4 = 0; // weak
char *off_806A320 = "APR"; // weak
int dword_806A324[] = { 4 }; // weak
size_t dword_806A380 = 262144u; // idb
int dword_806A384 = 128; // weak
int dword_806A388 = 16; // weak
int *off_806A38C = &dword_806AE5C; // weak
int status = 1; // idb
int dword_806A3C0 = 1; // weak
int dword_806A3C4 = 256; // weak
void *off_806A3C8 = &unk_806AF7C; // weak
int *off_806A3CC = &dword_806A3C4; // weak
_UNKNOWN unk_806A3E0; // weak
_UNKNOWN unk_806A400; // weak
_UNKNOWN unk_806A403; // weak
_UNKNOWN unk_806A408; // weak
_UNKNOWN unk_806A40B; // weak
_UNKNOWN unk_806A414; // weak
_UNKNOWN unk_806A417; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int program_invocation_name; // weak
int optind; // weak
FILE *stdin; // idb
FILE *stdout; // idb
int (*obstack_alloc_failed_handler)(void); // weak
char byte_806A48C; // weak
_UNKNOWN unk_806A490; // weak
_UNKNOWN unk_806A7F8; // weak
_UNKNOWN unk_806A8D2; // weak
int dword_806A99C; // weak
int dword_806A9A0; // weak
char byte_806A9A4; // weak
char byte_806A9A5; // weak
int dword_806A9A8; // weak
int dword_806A9AC; // weak
int dword_806A9B0; // weak
int dword_806A9B4; // weak
char byte_806A9BC[256]; // idb
_UNKNOWN unk_806AABC; // weak
_UNKNOWN unk_806ABBC; // weak
char byte_806ACBC[256]; // idb
size_t size; // idb
void *ptr; // idb
int dword_806ADC4; // weak
int dword_806ADC8; // weak
char byte_806ADCC; // weak
char byte_806ADCD; // weak
char byte_806ADCE; // weak
char byte_806ADCF; // weak
int dword_806ADD0; // weak
char *s1; // idb
__sigset_t set; // idb
int dword_806AE5C; // weak
int dword_806AE60; // weak
int dword_806AE64; // weak
_UNKNOWN unk_806AE7C; // weak
int dword_806AF1C; // weak
int dword_806AF20; // weak
char byte_806AF24; // weak
int dword_806AF28; // weak
int dword_806AF2C; // weak
int dword_806AF3C; // weak
int dword_806AF40; // weak
int dword_806AF44; // weak
int dword_806AF48; // weak
int dword_806AF4C; // weak
int dword_806AF50; // weak
int dword_806AF54; // weak
int dword_806AF58; // weak
int dword_806AF5C; // weak
int dword_806AF60; // weak
int dword_806AF64; // weak
int dword_806AF68; // weak
_UNKNOWN unk_806AF7C; // weak
int dword_806B07C; // weak
int dword_806B080; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (0804972C) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 8049F30: using guessed type int _gmon_start__(void);

//----- (08049750) --------------------------------------------------------
int sub_8049750()
{
  return dword_806A008();
}
// 806A008: using guessed type int (*dword_806A008)(void);

//----- (08049F40) --------------------------------------------------------
#error "8049F43: positive sp value has been found (funcsize=2)"

//----- (08049F73) --------------------------------------------------------
void sub_8049F73()
{
  ;
}

//----- (08049F90) --------------------------------------------------------
void sub_8049F90()
{
  ;
}

//----- (08049FA0) --------------------------------------------------------
int sub_8049FA0()
{
  int result; // eax

  result = &unk_806A417 - &unk_806A414;
  if ( (unsigned int)(&unk_806A417 - &unk_806A414) > 6 )
    result = 0;
  return result;
}
// 8049FA0: could not find valid save-restore pair for ebp

//----- (0804A010) --------------------------------------------------------
int sub_804A010()
{
  int result; // eax

  if ( !byte_806A48C )
  {
    result = sub_8049FA0();
    byte_806A48C = 1;
  }
  return result;
}
// 804A010: could not find valid save-restore pair for ebp
// 806A48C: using guessed type char byte_806A48C;

//----- (0804A030) --------------------------------------------------------
int sub_804A030()
{
  return 0;
}
// 804A030: could not find valid save-restore pair for ebp

//----- (0804A08F) --------------------------------------------------------
void sub_804A08F()
{
  ;
}

//----- (0804A0AA) --------------------------------------------------------
void sub_804A0AA()
{
  ;
}

//----- (0804A0BA) --------------------------------------------------------
int sub_804A0BA()
{
  int result; // eax

  result = &unk_806A490 - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_806A490 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 804A0BA: could not find valid save-restore pair for ebp
// 806A420: using guessed type int program_invocation_short_name;

//----- (0804A19C) --------------------------------------------------------
void sub_804A19C()
{
  ;
}

//----- (0804A1B7) --------------------------------------------------------
void sub_804A1B7()
{
  ;
}

//----- (0804A1C7) --------------------------------------------------------
int sub_804A1C7()
{
  int result; // eax

  result = &unk_806A403 - &unk_806A400;
  if ( (unsigned int)(&unk_806A403 - &unk_806A400) > 6 )
    result = 0;
  return result;
}
// 804A1C7: could not find valid save-restore pair for ebp

//----- (0804A2A9) --------------------------------------------------------
void sub_804A2A9()
{
  ;
}

//----- (0804A2C4) --------------------------------------------------------
void sub_804A2C4()
{
  ;
}

//----- (0804A2D4) --------------------------------------------------------
signed int sub_804A2D4()
{
  return 3;
}
// 804A2D4: could not find valid save-restore pair for ebp

//----- (0804A3B6) --------------------------------------------------------
void sub_804A3B6()
{
  ;
}

//----- (0804A3D1) --------------------------------------------------------
void sub_804A3D1()
{
  ;
}

//----- (0804A3E1) --------------------------------------------------------
int sub_804A3E1()
{
  int result; // eax

  result = &unk_806A403 - &unk_806A400;
  if ( (unsigned int)(&unk_806A403 - &unk_806A400) > 6 )
    result = 0;
  return result;
}
// 804A3E1: could not find valid save-restore pair for ebp

//----- (0804A4C3) --------------------------------------------------------
void sub_804A4C3()
{
  ;
}

//----- (0804A4DE) --------------------------------------------------------
void sub_804A4DE()
{
  ;
}

//----- (0804A4EE) --------------------------------------------------------
int sub_804A4EE()
{
  int result; // eax

  result = &unk_806A403 - &unk_806A400;
  if ( (unsigned int)(&unk_806A403 - &unk_806A400) > 6 )
    result = 0;
  return result;
}
// 804A4EE: could not find valid save-restore pair for ebp

//----- (0804A5D0) --------------------------------------------------------
void sub_804A5D0()
{
  ;
}

//----- (0804A5EB) --------------------------------------------------------
void sub_804A5EB()
{
  ;
}

//----- (0804A5FB) --------------------------------------------------------
int sub_804A5FB()
{
  int result; // eax

  result = &unk_806839F - &unk_806839C;
  if ( (unsigned int)(&unk_806839F - &unk_806839C) > 6 )
    result = 0;
  return result;
}
// 804A5FB: could not find valid save-restore pair for ebp

//----- (0804A6AD) --------------------------------------------------------
int __usercall sub_804A6AD@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  a1(&dword_8067EF0);
  return 0;
}
// 8067EF0: using guessed type int dword_8067EF0;

//----- (0804A6F9) --------------------------------------------------------
void sub_804A6F9()
{
  ;
}

//----- (0804A714) --------------------------------------------------------
void sub_804A714()
{
  ;
}

//----- (0804A724) --------------------------------------------------------
int sub_804A724()
{
  int result; // eax

  result = &unk_806A403 - &unk_806A400;
  if ( (unsigned int)(&unk_806A403 - &unk_806A400) > 6 )
    result = 0;
  return result;
}
// 804A724: could not find valid save-restore pair for ebp

//----- (0804A806) --------------------------------------------------------
void sub_804A806()
{
  ;
}

//----- (0804A821) --------------------------------------------------------
void sub_804A821()
{
  ;
}

//----- (0804A831) --------------------------------------------------------
int sub_804A831()
{
  int result; // eax

  result = &unk_806A403 - &unk_806A400;
  if ( (unsigned int)(&unk_806A403 - &unk_806A400) > 6 )
    result = 0;
  return result;
}
// 804A831: could not find valid save-restore pair for ebp

//----- (0804A913) --------------------------------------------------------
void sub_804A913()
{
  ;
}

//----- (0804A92E) --------------------------------------------------------
void sub_804A92E()
{
  ;
}

//----- (0804A93E) --------------------------------------------------------
int sub_804A93E()
{
  int result; // eax

  result = &unk_806A7F8 - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_806A7F8 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 804A93E: could not find valid save-restore pair for ebp
// 806A420: using guessed type int program_invocation_short_name;

//----- (0804AA20) --------------------------------------------------------
void sub_804AA20()
{
  ;
}

//----- (0804AA3B) --------------------------------------------------------
void sub_804AA3B()
{
  ;
}

//----- (0804AA4B) --------------------------------------------------------
int sub_804AA4B()
{
  int result; // eax

  result = &unk_8066357 - &unk_8066354;
  if ( (unsigned int)(&unk_8066357 - &unk_8066354) > 6 )
    result = 0;
  return result;
}
// 804AA4B: could not find valid save-restore pair for ebp

//----- (0804AB2D) --------------------------------------------------------
void sub_804AB2D()
{
  ;
}

//----- (0804AB48) --------------------------------------------------------
void sub_804AB48()
{
  ;
}

//----- (0804AB58) --------------------------------------------------------
int sub_804AB58()
{
  int result; // eax

  result = &unk_806A8D2 - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_806A8D2 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 804AB58: could not find valid save-restore pair for ebp
// 806A420: using guessed type int program_invocation_short_name;

//----- (0804ABBF) --------------------------------------------------------
int __usercall sub_804ABBF@<eax>(int a1@<eax>, int (__cdecl *a2)(int *, int)@<edx>)
{
  return a2(&program_invocation_short_name, a1);
}
// 806A420: using guessed type int program_invocation_short_name;

//----- (0804AC33) --------------------------------------------------------
int __usercall sub_804AC33@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  a1(&dword_8064F04);
  return nullsub_3();
}
// 804AC33: could not find valid save-restore pair for ebx
// 804AB9C: using guessed type int nullsub_3(void);
// 8061223: using guessed type int __usercall sub_8061223@<eax>(double@<st0>);
// 8064F04: using guessed type int dword_8064F04;
// 806A2AC: using guessed type int dword_806A2AC;

//----- (0804AC7F) --------------------------------------------------------
void sub_804AC7F()
{
  ;
}

//----- (0804AC9A) --------------------------------------------------------
void sub_804AC9A()
{
  ;
}

//----- (0804ACAA) --------------------------------------------------------
int sub_804ACAA()
{
  int result; // eax

  result = &unk_806A40B - &unk_806A408;
  if ( (unsigned int)(&unk_806A40B - &unk_806A408) > 6 )
    result = 0;
  return result;
}
// 804ACAA: could not find valid save-restore pair for ebp

//----- (0804AD5A) --------------------------------------------------------
int __cdecl sub_804AD5A(int a1)
{
  int result; // eax

  if ( a1 != 1 )
  {
    result = a1;
    status = a1;
  }
  return result;
}

//----- (0804AD6D) --------------------------------------------------------
int __cdecl sub_804AD6D(unsigned __int8 a1)
{
  return a1;
}

//----- (0804AD7F) --------------------------------------------------------
int __cdecl sub_804AD7F(unsigned __int8 a1)
{
  const unsigned __int16 **v1; // eax
  int v2; // ecx
  int v3; // edx

  v1 = __ctype_b_loc();
  v3 = a1;
  if ( (*v1)[v3] & 1 || a1 == 10 )
  {
    dword_806A248 = (int)&loc_804ADCE;
    sub_8061491(v2, v3 * 2);
  }
  return 0;
}
// 8061491: using guessed type int __fastcall sub_8061491(_DWORD, _DWORD);
// 806A248: using guessed type int dword_806A248;

//----- (0804ADD3) --------------------------------------------------------
int __cdecl sub_804ADD3(unsigned __int64 a1)
{
  int result; // eax

  if ( HIDWORD(a1) )
    result = sub_8060E13(a1, 0xF4240u, 0) + 1000000;
  else
    result = a1;
  return result;
}

//----- (0804AE19) --------------------------------------------------------
int sub_804AE19()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nWith no FILE, or when FILE is -, read standard input.\n");
  return fputs_unlocked(v1, v0);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804AE44) --------------------------------------------------------
int sub_804AE44()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nMandatory arguments to long options are mandatory for short options too.\n");
  return fputs_unlocked(v1, v0);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804AE6F) --------------------------------------------------------
int __usercall sub_804AE6F@<eax>(int a1@<ebx>, int a2@<ecx>, char *s1)
{
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  void *v6; // eax
  char *v7; // eax
  int v9; // [esp-8h] [ebp-70h]
  char *v10; // [esp-4h] [ebp-6Ch]
  int v11; // [esp+0h] [ebp-68h]
  char *v12; // [esp+4h] [ebp-64h]
  char *v13; // [esp+8h] [ebp-60h]
  int v14; // [esp+Ch] [ebp-5Ch]
  int v15; // [esp+10h] [ebp-58h]
  int v16; // [esp+14h] [ebp-54h]
  int v17; // [esp+18h] [ebp-50h]
  char *v18; // [esp+1Ch] [ebp-4Ch]
  char **v19; // [esp+20h] [ebp-48h]
  char *v20; // [esp+24h] [ebp-44h]
  const char *v21; // [esp+28h] [ebp-40h]
  const char *v22; // [esp+2Ch] [ebp-3Ch]
  const char *v23; // [esp+30h] [ebp-38h]
  const char *v24; // [esp+34h] [ebp-34h]
  const char *v25; // [esp+38h] [ebp-30h]
  const char *v26; // [esp+3Ch] [ebp-2Ch]
  const char *v27; // [esp+40h] [ebp-28h]
  const char *v28; // [esp+44h] [ebp-24h]
  const char *v29; // [esp+48h] [ebp-20h]
  const char *v30; // [esp+4Ch] [ebp-1Ch]
  const char *v31; // [esp+50h] [ebp-18h]
  const char *v32; // [esp+54h] [ebp-14h]
  int v33; // [esp+58h] [ebp-10h]
  int v34; // [esp+5Ch] [ebp-Ch]

  v21 = "[";
  v22 = "test invocation";
  v23 = "coreutils";
  v24 = "Multi-call invocation";
  v25 = "sha224sum";
  v26 = "sha2 utilities";
  v27 = "sha256sum";
  v28 = "sha2 utilities";
  v29 = "sha384sum";
  v30 = "sha2 utilities";
  v31 = "sha512sum";
  v32 = "sha2 utilities";
  v33 = 0;
  v34 = 0;
  v18 = s1;
  v19 = (char **)(&v11 - 16);
  dword_806A2CC = (int)&loc_804AF0F;
  sub_8061134(a2);
  do
  {
    v19 += 2;
    if ( !*v19 )
      break;
    v12 = *v19;
  }
  while ( strcmp(s1, v12) );
  if ( v19[1] )
    v18 = v19[1];
  v3 = gettext("\n%s online help: <%s>\n");
  v13 = "http://www.gnu.org/software/coreutils/";
  v12 = "GNU coreutils";
  printf(v3, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  v20 = setlocale(5, 0);
  if ( v20 && strncmp(v20, "en_", 3u) )
  {
    v4 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
    v12 = s1;
    printf(v4, s1);
  }
  v5 = gettext("Full documentation at: <%s%s>\n");
  v13 = s1;
  v12 = "http://www.gnu.org/software/coreutils/";
  printf(v5, "http://www.gnu.org/software/coreutils/");
  v10 = v18;
  v9 = a1;
  v6 = &loc_804B002;
  if ( v18 != s1 )
    v6 = &loc_804B009;
  dword_806A220 = (int)v6;
  sub_8061579(v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25);
  v7 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  v13 = " invocation";
  v12 = v18;
  return printf(v7, v18, " invocation");
}
// 8061134: using guessed type int __fastcall sub_8061134(_DWORD);
// 8061579: using guessed type int __stdcall sub_8061579(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806A220: using guessed type int dword_806A220;
// 806A2CC: using guessed type int dword_806A2CC;

//----- (0804B033) --------------------------------------------------------
#error "804B069: call analysis failed (funcsize=19)"

//----- (0804B06E) --------------------------------------------------------
#error "804B075: call analysis failed (funcsize=39)"

//----- (0804B11E) --------------------------------------------------------
void __cdecl __noreturn sub_804B11E(int a1, char *a2)
{
  char *v2; // eax
  void *v3; // ebx
  int *v4; // eax

  if ( a2 )
    v2 = a2;
  else
    v2 = gettext("standard output");
  v3 = sub_805B533(0, 3, (int)v2);
  v4 = __errno_location();
  error(2, *v4, "%s: %s", a1, v3);
  sub_804B180(a1);
}

//----- (0804B180) --------------------------------------------------------
void __cdecl __noreturn sub_804B180(int status)
{
  int v1; // ebx
  char *v2; // eax
  int v3; // esi
  int v4; // ebx
  char *v5; // eax
  FILE *v6; // ebx
  char *v7; // eax
  FILE *v8; // ebx
  char *v9; // eax
  FILE *v10; // ebx
  char *v11; // eax
  FILE *v12; // ebx
  char *v13; // eax
  FILE *v14; // ebx
  char *v15; // eax
  FILE *v16; // ebx
  char *v17; // eax
  FILE *v18; // ebx
  char *v19; // eax
  FILE *v20; // ebx
  char *v21; // eax
  FILE *v22; // ebx
  char *v23; // eax
  FILE *v24; // ebx
  char *v25; // eax
  FILE *v26; // ebx
  char *v27; // eax
  FILE *v28; // ebx
  char *v29; // eax
  FILE *v30; // ebx
  char *v31; // eax
  char *v32; // eax
  FILE *v33; // ebx
  char *v34; // eax
  FILE *v35; // ebx
  char *v36; // eax
  FILE *v37; // ebx
  char *v38; // eax
  FILE *v39; // ebx
  char *v40; // eax
  FILE *v41; // ebx
  char *v42; // eax
  int v43; // ecx

  if ( status )
  {
    v1 = dword_806AF2C;
    v2 = gettext("Try '%s --help' for more information.\n");
    fprintf(stderr, v2, v1);
  }
  else
  {
    v3 = dword_806AF2C;
    v4 = dword_806AF2C;
    v5 = gettext("Usage: %s [OPTION]... [FILE]...\n  or:  %s [OPTION]... --files0-from=F\n");
    printf(v5, v4, v3);
    v6 = stdout;
    v7 = gettext("Write sorted concatenation of all FILE(s) to standard output.\n");
    fputs_unlocked(v7, v6);
    sub_804AE19();
    sub_804AE44();
    v8 = stdout;
    v9 = gettext("Ordering options:\n\n");
    fputs_unlocked(v9, v8);
    v10 = stdout;
    v11 = gettext(
            "  -b, --ignore-leading-blanks  ignore leading blanks\n"
            "  -d, --dictionary-order      consider only blanks and alphanumeric characters\n"
            "  -f, --ignore-case           fold lower case to upper case characters\n");
    fputs_unlocked(v11, v10);
    v12 = stdout;
    v13 = gettext(
            "  -g, --general-numeric-sort  compare according to general numerical value\n"
            "  -i, --ignore-nonprinting    consider only printable characters\n"
            "  -M, --month-sort            compare (unknown) < 'JAN' < ... < 'DEC'\n");
    fputs_unlocked(v13, v12);
    v14 = stdout;
    v15 = gettext("  -h, --human-numeric-sort    compare human readable numbers (e.g., 2K 1G)\n");
    fputs_unlocked(v15, v14);
    v16 = stdout;
    v17 = gettext(
            "  -n, --numeric-sort          compare according to string numerical value\n"
            "  -R, --random-sort           shuffle, but group identical keys.  See shuf(1)\n"
            "      --random-source=FILE    get random bytes from FILE\n"
            "  -r, --reverse               reverse the result of comparisons\n");
    fputs_unlocked(v17, v16);
    v18 = stdout;
    v19 = gettext(
            "      --sort=WORD             sort according to WORD:\n"
            "                                general-numeric -g, human-numeric -h, month -M,\n"
            "                                numeric -n, random -R, version -V\n"
            "  -V, --version-sort          natural sort of (version) numbers within text\n"
            "\n");
    fputs_unlocked(v19, v18);
    v20 = stdout;
    v21 = gettext("Other options:\n\n");
    fputs_unlocked(v21, v20);
    v22 = stdout;
    v23 = gettext(
            "      --batch-size=NMERGE   merge at most NMERGE inputs at once;\n"
            "                            for more use temp files\n");
    fputs_unlocked(v23, v22);
    v24 = stdout;
    v25 = gettext(
            "  -c, --check, --check=diagnose-first  check for sorted input; do not sort\n"
            "  -C, --check=quiet, --check=silent  like -c, but do not report first bad line\n"
            "      --compress-program=PROG  compress temporaries with PROG;\n"
            "                              decompress them with PROG -d\n");
    fputs_unlocked(v25, v24);
    v26 = stdout;
    v27 = gettext(
            "      --debug               annotate the part of the line used to sort,\n"
            "                              and warn about questionable usage to stderr\n"
            "      --files0-from=F       read input from the files specified by\n"
            "                            NUL-terminated names in file F;\n"
            "                            If F is - then read names from standard input\n");
    fputs_unlocked(v27, v26);
    v28 = stdout;
    v29 = gettext(
            "  -k, --key=KEYDEF          sort via a key; KEYDEF gives location and type\n"
            "  -m, --merge               merge already sorted files; do not sort\n");
    fputs_unlocked(v29, v28);
    v30 = stdout;
    v31 = gettext(
            "  -o, --output=FILE         write result to FILE instead of standard output\n"
            "  -s, --stable              stabilize sort by disabling last-resort comparison\n"
            "  -S, --buffer-size=SIZE    use SIZE for main memory buffer\n");
    fputs_unlocked(v31, v30);
    v32 = gettext(
            "  -t, --field-separator=SEP  use SEP instead of non-blank to blank transition\n"
            "  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or %s;\n"
            "                              multiple options specify multiple directories\n"
            "      --parallel=N          change the number of sorts run concurrently to N\n"
            "  -u, --unique              with -c, check for strict ordering;\n"
            "                              without -c, output only the first of an equal run\n");
    printf(v32, "/tmp");
    v33 = stdout;
    v34 = gettext("  -z, --zero-terminated     line delimiter is NUL, not newline\n");
    fputs_unlocked(v34, v33);
    v35 = stdout;
    v36 = gettext("      --help     display this help and exit\n");
    fputs_unlocked(v36, v35);
    v37 = stdout;
    v38 = gettext("      --version  output version information and exit\n");
    fputs_unlocked(v38, v37);
    v39 = stdout;
    v40 = gettext(
            "\n"
            "KEYDEF is F[.C][OPTS][,F[.C][OPTS]] for start and stop position, where F is a\n"
            "field number and C a character position in the field; both are origin 1, and\n"
            "the stop position defaults to the line's end.  If neither -t nor -b is in\n"
            "effect, characters in a field are counted from the beginning of the preceding\n"
            "whitespace.  OPTS is one or more single-letter ordering options [bdfgiMhnRrV],\n"
            "which override global ordering options for that key.  If no key is given, use\n"
            "the entire line as the key.  Use --debug to diagnose incorrect key usage.\n"
            "\n"
            "SIZE may be followed by the following multiplicative suffixes:\n");
    fputs_unlocked(v40, v39);
    v41 = stdout;
    v42 = gettext(
            "% 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, E, Z, Y.\n"
            "\n"
            "*** WARNING ***\n"
            "The locale specified by the environment affects sort order.\n"
            "Set LC_ALL=C to get the traditional sort order that uses\n"
            "native byte values.\n");
    fputs_unlocked(v42, v41);
    sub_804AE6F((int)v41, v43, "sort");
  }
  exit(status);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 806AF2C: using guessed type int dword_806AF2C;

//----- (0804B43C) --------------------------------------------------------
int __cdecl sub_804B43C(int a1)
{
  bool v1; // dl
  int result; // eax

  v1 = pthread_sigmask(0, &set, (__sigset_t *)(a1 + 4)) == 0;
  result = a1;
  *(_BYTE *)a1 = v1;
  return result;
}

//----- (0804B471) --------------------------------------------------------
int __cdecl sub_804B471(unsigned __int8 *a1)
{
  int result; // eax

  result = *a1;
  if ( (_BYTE)result )
    result = pthread_sigmask(2, (const __sigset_t *)(a1 + 4), 0);
  return result;
}

//----- (0804B4A1) --------------------------------------------------------
int __cdecl sub_804B4A1(int a1, unsigned int a2)
{
  return *(_DWORD *)(a1 + 4) % a2;
}

//----- (0804B4CF) --------------------------------------------------------
bool __cdecl sub_804B4CF(int a1, int a2)
{
  return *(_DWORD *)(a1 + 4) == *(_DWORD *)(a2 + 4);
}

//----- (0804B504) --------------------------------------------------------
#error "804B5B9: call analysis failed (funcsize=91)"

//----- (0804B646) --------------------------------------------------------
void __cdecl __noreturn sub_804B646(int a1)
{
  if ( !dword_806AE60 )
  {
    dword_806AE60 = sub_8057BB2(47, 0, sub_804B4A1, sub_804B4CF, 0);
    if ( !dword_806AE60 )
      sub_805E278();
  }
  *(_BYTE *)(a1 + 8) = 1;
  sub_80587D0(dword_806AE60, a1);
}
// 8057BB2: using guessed type _DWORD __cdecl sub_8057BB2(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806AE60: using guessed type int dword_806AE60;

//----- (0804B6BA) --------------------------------------------------------
int __usercall sub_804B6BA@<eax>(double a1@<st0>, int a2)
{
  int v2; // eax
  int v3; // edx
  int v4; // ecx
  bool v5; // zf
  void *v6; // eax
  int v8; // [esp-4h] [ebp-3Ch]
  int v9; // [esp+0h] [ebp-38h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+24h] [ebp-14h]
  unsigned int v12; // [esp+2Ch] [ebp-Ch]

  v12 = __readgsdword(0x14u);
  v11 = a2;
  v2 = sub_805880F(a1, dword_806AE60, (int)(&v9 - 6));
  v10 = v2;
  v5 = v2 == 0;
  v8 = v2;
  v6 = &loc_804B717;
  if ( !v5 )
    v6 = &loc_804B71E;
  dword_806A25C = (int)v6;
  sub_806141F(v4, v3);
  return 0;
}
// 806141F: using guessed type int __fastcall sub_806141F(_DWORD, _DWORD);
// 806A25C: using guessed type int dword_806A25C;
// 806AE60: using guessed type int dword_806AE60;

//----- (0804B73D) --------------------------------------------------------
int __usercall sub_804B73D@<eax>(double a1@<st0>, __pid_t pid)
{
  int result; // eax

  result = sub_804B6BA(a1, pid);
  if ( (_BYTE)result )
    result = sub_804B504(pid);
  return result;
}

//----- (0804B75F) --------------------------------------------------------
int sub_804B75F()
{
  int result; // eax

  do
  {
    result = dword_806AE64;
    if ( dword_806AE64 <= 0 )
      break;
    result = sub_804B504(0);
  }
  while ( result );
  return result;
}
// 806AE64: using guessed type int dword_806AE64;

//----- (0804B782) --------------------------------------------------------
int sub_804B782()
{
  sub_804B504(-1);
  return sub_804B75F();
}

//----- (0804B79B) --------------------------------------------------------
int sub_804B79B()
{
  int result; // eax

  while ( 1 )
  {
    result = dword_806AE64;
    if ( dword_806AE64 <= 0 )
      break;
    sub_804B504(-1);
  }
  return result;
}
// 806AE64: using guessed type int dword_806AE64;

//----- (0804B7BA) --------------------------------------------------------
int sub_804B7BA()
{
  int result; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  result = dword_806AE5C;
  for ( i = dword_806AE5C; i; i = *(_DWORD *)i )
  {
    unlink((const char *)(i + 9));
    result = *(_DWORD *)i;
  }
  dword_806AE5C = 0;
  return result;
}
// 806AE5C: using guessed type int dword_806AE5C;

//----- (0804B7F2) --------------------------------------------------------
int sub_804B7F2()
{
  char v1; // [esp+1Ch] [ebp-8Ch]

  if ( dword_806AE5C )
  {
    sub_804B43C((int)&v1);
    sub_804B7BA();
    sub_804B471((unsigned __int8 *)&v1);
  }
  return sub_80557CE();
}
// 806AE5C: using guessed type int dword_806AE5C;

//----- (0804B82C) --------------------------------------------------------
#error "804B929: call analysis failed (funcsize=59)"

//----- (0804B92E) --------------------------------------------------------
#error "804BA5A: positive sp value has been found (funcsize=0)"

//----- (0804BA5E) --------------------------------------------------------
FILE *__cdecl sub_804BA5E(char *s1, char *modes)
{
  bool v2; // zf
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  int v6; // edx
  int v7; // ecx
  int v8; // ST08_4
  int v9; // ST0C_4
  FILE *v10; // eax
  void *v11; // esi
  char *v12; // ebx
  int *v13; // eax
  int v15; // [esp+0h] [ebp-28h]
  int v16; // [esp+4h] [ebp-24h]
  int v17; // [esp+8h] [ebp-20h]
  FILE *stream; // [esp+18h] [ebp-10h]
  int fd; // [esp+1Ch] [ebp-Ch]

  if ( *modes == 114 )
  {
    v2 = strcmp(s1, "-") == 0;
    v5 = &loc_804BAA4;
    if ( !v2 )
      v5 = &loc_804BACA;
    dword_806A284 = (int)v5;
    sub_806132A(v4, v3, v15, v16, v17);
    byte_806ADCF = 1;
    dword_806A234 = (int)&loc_804BB02;
    sub_8061505(v7, v6, v8, v9);
    fd = open64(s1, 0x80000);
    if ( fd < 0 )
      v10 = 0;
    else
      v10 = fdopen(fd, modes);
    stream = v10;
    sub_8056CC1(v10, 2);
  }
  else
  {
    if ( *modes != 119 )
      __assert_fail("!\"unexpected mode passed to stream_open\"", "src/sort.c", 0x3CCu, "stream_open");
    if ( s1 && ftruncate64(1, 0, 0) )
    {
      v11 = sub_805B533(0, 3, (int)s1);
      v12 = gettext("%s: error truncating");
      v13 = __errno_location();
      error(2, *v13, v12, v11);
    }
    stream = stdout;
  }
  return stream;
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 8049D20: using guessed type int __cdecl ftruncate64(_DWORD, _DWORD, _DWORD);
// 806A234: using guessed type int dword_806A234;
// 806A284: using guessed type int dword_806A284;
// 806ADCF: using guessed type char byte_806ADCF;

//----- (0804BBCC) --------------------------------------------------------
FILE *__cdecl sub_804BBCC(char *s1, char *modes)
{
  char *v2; // eax
  FILE *v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_804BA5E(s1, modes);
  if ( !v4 )
  {
    v2 = gettext("open failed");
    sub_804B11E((int)v2, s1);
  }
  return v4;
}

//----- (0804BC0D) --------------------------------------------------------
#error "804BC51: call analysis failed (funcsize=51)"

//----- (0804BCB4) --------------------------------------------------------
int __cdecl sub_804BCB4(int fd, int fd2)
{
  int result; // eax

  result = fd;
  if ( fd != fd2 )
  {
    dup2(fd, fd2);
    result = close(fd);
  }
  return result;
}

//----- (0804BCE1) --------------------------------------------------------
__pid_t __cdecl sub_804BCE1(int pipedes[2], int a2)
{
  long double v2; // fst7
  int v4; // eax
  int v5; // ST1C_4
  int v6; // ST00_4
  int v7; // [esp+4h] [ebp-B4h]
  int v8; // [esp+8h] [ebp-B0h]
  int v9; // [esp+Ch] [ebp-ACh]
  int v10; // [esp+10h] [ebp-A8h]
  __pid_t v11; // [esp+14h] [ebp-A4h]
  int v12; // [esp+18h] [ebp-A0h]
  int v13; // [esp+1Ch] [ebp-9Ch]
  double v14; // [esp+20h] [ebp-98h]
  int v15; // [esp+28h] [ebp-90h]
  char v16; // [esp+2Ch] [ebp-8Ch]
  int v17; // [esp+30h] [ebp-88h]
  int v18; // [esp+34h] [ebp-84h]
  int v19; // [esp+38h] [ebp-80h]
  int v20; // [esp+3Ch] [ebp-7Ch]
  int v21; // [esp+40h] [ebp-78h]
  int v22; // [esp+44h] [ebp-74h]
  int v23; // [esp+48h] [ebp-70h]
  int v24; // [esp+4Ch] [ebp-6Ch]
  int v25; // [esp+50h] [ebp-68h]
  int v26; // [esp+54h] [ebp-64h]
  int v27; // [esp+58h] [ebp-60h]
  int v28; // [esp+5Ch] [ebp-5Ch]
  int v29; // [esp+60h] [ebp-58h]
  int v30; // [esp+64h] [ebp-54h]
  int v31; // [esp+68h] [ebp-50h]

  v2 = 0.25;
  v14 = 0.25;
  if ( sub_8059812(*(double *)&v2, pipedes, 0x80000) < 0 )
    return -1;
  if ( dword_806A388 + 1 < (unsigned int)dword_806AE64 )
    sub_804B782();
  while ( 1 )
  {
    v4 = a2--;
    if ( !v4 )
      break;
    sub_804B43C((int)&v16);
    v12 = dword_806AE5C;
    dword_806AE5C = 0;
    v11 = fork();
    v13 = *__errno_location();
    if ( v11 )
      dword_806AE5C = v12;
    sub_804B471((unsigned __int8 *)&v16);
    *__errno_location() = v13;
    if ( v11 >= 0 || *__errno_location() != 11 )
      break;
    sub_805E4A6(v14);
    v2 = v14 + v14;
    v14 = v2;
    sub_804B75F();
  }
  if ( v11 >= 0 )
  {
    if ( !v11 )
    {
      close(0);
      close(1);
      dword_806A298 = (int)&loc_804BE6F;
      sub_806129D(
        v6,
        v7,
        v8,
        v9,
        v10,
        0,
        v12,
        v13,
        LODWORD(v14),
        HIDWORD(v14),
        v15,
        *(_DWORD *)&v16,
        v17,
        v18,
        v19,
        v20,
        v21,
        v22,
        v23,
        v24,
        v25,
        v26,
        v27,
        v28,
        v29,
        v30,
        v31,
        *(double *)&v2);
    }
    ++dword_806AE64;
  }
  else
  {
    v5 = *__errno_location();
    close(*pipedes);
    close(pipedes[1]);
    *__errno_location() = v5;
  }
  return v11;
}
// 806129D: using guessed type int __userpurge sub_806129D@<eax>(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, double@<st0>);
// 806A298: using guessed type int dword_806A298;
// 806A388: using guessed type int dword_806A388;
// 806AE5C: using guessed type int dword_806AE5C;
// 806AE64: using guessed type int dword_806AE64;

//----- (0804BE77) --------------------------------------------------------
int __usercall sub_804BE77@<eax>(int a1@<ebx>, int a2, unsigned __int8 a3)
{
  int *v3; // ebp
  int v4; // edx
  int v5; // ecx
  __pid_t v6; // eax
  int v7; // ecx
  int v8; // edx
  bool v9; // zf
  void *v10; // eax
  int *v11; // eax
  char *v12; // ebx
  char *v13; // eax
  int v15; // [esp-8h] [ebp-34h]
  int v16; // [esp-4h] [ebp-30h]
  int fd; // [esp+0h] [ebp-2Ch]
  char *arg; // [esp+4h] [ebp-28h]
  int v19; // [esp+8h] [ebp-24h]
  unsigned __int8 v20; // [esp+Ch] [ebp-20h]
  int v21; // [esp+10h] [ebp-1Ch]
  int v22; // [esp+14h] [ebp-18h]
  int v23; // [esp+28h] [ebp-4h]

  v3 = &v23;
  v20 = a3;
  v22 = sub_804B82C(&v21, a3);
  if ( !v22 )
  {
    dword_806A248 = (int)&loc_804BFFB;
    sub_8061491(v5, v4);
    v3 = &fd;
  }
  *(_BYTE *)(*(v3 - 5) + 8) = 0;
  if ( s1 )
  {
    v6 = sub_804BCE1(v3 - 4, 4);
    v8 = *(v3 - 5);
    *(_DWORD *)(v8 + 4) = v6;
    if ( *(_DWORD *)(*(v3 - 5) + 4) > 0 )
    {
      close(*(v3 - 6));
      close(*(v3 - 4));
      *(v3 - 6) = *(v3 - 3);
      sub_804B646(*(v3 - 5));
    }
    v9 = *(_DWORD *)(*(v3 - 5) + 4) == 0;
    v16 = *(_DWORD *)(*(v3 - 5) + 4);
    v15 = a1;
    v10 = &loc_804BF52;
    if ( !v9 )
      v10 = &loc_804BFB9;
    dword_806A284 = (int)v10;
    sub_806132A(v7, v8, fd, arg, v19);
    close(*(v3 - 3));
    sub_804BCB4(*(v3 - 6), 1);
    sub_804BCB4(*(v3 - 4), 0);
    v19 = 0;
    execlp(s1, s1, 0, *(_DWORD *)&v20);
    v11 = __errno_location();
    sub_804B033(*v11, "couldn't execute compress program");
  }
  *(_DWORD *)v3[2] = fdopen(*(v3 - 6), "w");
  if ( !*(_DWORD *)v3[2] )
  {
    v12 = (char *)(*(v3 - 5) + 9);
    v13 = gettext("couldn't create temporary file");
    sub_804B11E((int)v13, v12);
  }
  return *(v3 - 5);
}
// 804B033: using guessed type _DWORD __cdecl sub_804B033(_DWORD, _DWORD);
// 804B82C: using guessed type _DWORD __cdecl sub_804B82C(_DWORD, _DWORD);
// 8061491: using guessed type int __fastcall sub_8061491(_DWORD, _DWORD);
// 806A248: using guessed type int dword_806A248;
// 806A284: using guessed type int dword_806A284;

//----- (0804C001) --------------------------------------------------------
int __usercall sub_804C001@<eax>(int a1@<ebx>, int a2)
{
  return sub_804BE77(a1, a2, 0);
}

//----- (0804C01C) --------------------------------------------------------
int __usercall sub_804C01C@<eax>(double a1@<st0>, int a2)
{
  __pid_t v3; // eax
  bool v4; // zf
  void *v5; // eax
  void *v6; // esi
  char *v7; // ebx
  int *v8; // eax
  int *v9; // eax
  int fd; // [esp+1Ch] [ebp-1Ch]
  __pid_t v11; // [esp+20h] [ebp-18h]
  int pipedes[2]; // [esp+28h] [ebp-10h]

  if ( *(_BYTE *)(a2 + 8) == 1 )
    sub_804B73D(a1, *(_DWORD *)(a2 + 4));
  fd = open64(a2 + 9, 0);
  if ( fd < 0 )
    return 0;
  v3 = sub_804BCE1(pipedes, 9);
  v11 = v3;
  if ( v3 != -1 )
  {
    if ( !v3 )
    {
      close(pipedes[0]);
      sub_804BCB4(fd, 0);
      sub_804BCB4(pipedes[1], 1);
      execlp(s1, s1, "-d", 0);
      v9 = __errno_location();
      sub_804B033(*v9, "couldn't execute compress program (with -d)");
    }
    *(_DWORD *)(a2 + 4) = v11;
    sub_804B646(a2);
  }
  v4 = *__errno_location() == 24;
  v5 = &loc_804C0BD;
  if ( v4 )
    v5 = &loc_804C101;
  dword_806A2AC = (int)v5;
  sub_8061223(a1);
  v6 = sub_805B3A8(4, (int)s1);
  v7 = gettext("couldn't create process for %s -d");
  v8 = __errno_location();
  error(2, *v8, v7, v6);
  close(fd);
  *__errno_location() = 24;
  return 0;
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 804B033: using guessed type _DWORD __cdecl sub_804B033(_DWORD, _DWORD);
// 8061223: using guessed type int __usercall sub_8061223@<eax>(double@<st0>);
// 806A2AC: using guessed type int dword_806A2AC;

//----- (0804C1FC) --------------------------------------------------------
int __cdecl sub_804C1FC(int a1)
{
  int v1; // eax
  _DWORD *v2; // edx
  int result; // eax

  if ( dword_806ADC4 == dword_806ADC8 )
    ptr = sub_805E07E(ptr, (int)&dword_806ADC8, 4);
  v1 = dword_806ADC4++;
  v2 = (char *)ptr + 4 * v1;
  result = a1;
  *v2 = a1;
  return result;
}
// 806ADC4: using guessed type int dword_806ADC4;
// 806ADC8: using guessed type int dword_806ADC8;

//----- (0804C254) --------------------------------------------------------
void __usercall sub_804C254(int a1@<edx>, int a2@<ecx>, double a3@<st0>, char *name)
{
  void *v4; // eax
  int v5; // ST30_4
  void *v6; // ebx
  char *v7; // eax
  int *i; // [esp+18h] [ebp-A0h]
  int errnum; // [esp+1Ch] [ebp-9Ch]
  void *ptr; // [esp+20h] [ebp-98h]
  int v11; // [esp+24h] [ebp-94h]
  char v12; // [esp+2Ch] [ebp-8Ch]

  for ( i = &dword_806AE5C; ; i = (int *)*i )
  {
    ptr = (void *)*i;
    if ( (char *)(*i + 9) == name )
      break;
  }
  v4 = &loc_804C2C3;
  if ( *((_BYTE *)ptr + 8) != 1 )
    v4 = &loc_804C2D4;
  dword_806A25C = (int)v4;
  sub_806141F(a2, a1);
  sub_804B73D(a3, *((_DWORD *)ptr + 1));
  v11 = *(_DWORD *)ptr;
  sub_804B43C((int)&v12);
  v5 = unlink(name);
  errnum = *__errno_location();
  *i = v11;
  sub_804B471((unsigned __int8 *)&v12);
  if ( v5 )
  {
    v6 = sub_805B533(0, 3, (int)name);
    v7 = gettext("warning: cannot remove: %s");
    error(0, errnum, v7, v6);
  }
  if ( !v11 )
    off_806A38C = i;
  free(ptr);
}
// 806141F: using guessed type int __fastcall sub_806141F(_DWORD, _DWORD);
// 806A25C: using guessed type int dword_806A25C;
// 806A38C: using guessed type int *off_806A38C;
// 806AE5C: using guessed type int dword_806AE5C;

//----- (0804C3A5) --------------------------------------------------------
int __cdecl compar(const void *a1, const void *a2)
{
  return strcmp(*(const char **)a1, *(const char **)a2);
}

//----- (0804C3DF) --------------------------------------------------------
#error "804C547: call analysis failed (funcsize=113)"

//----- (0804C62A) --------------------------------------------------------
unsigned int __usercall sub_804C62A@<eax>(double st7_0@<st0>, int edx0@<edx>, int ecx0@<ecx>, int a1, char a2, char *a3)
{
  int v6; // ecx
  int v7; // ecx
  void *v8; // ebx
  int v9; // esi
  char *v10; // eax
  void *v11; // ebx
  int v12; // esi
  char *v13; // eax
  void *v15; // ebx
  int v16; // esi
  char *v17; // eax
  int v18; // ebx
  int v19; // esi
  char *v20; // eax
  signed int v21; // [esp+0h] [ebp-58h]
  int *v22; // [esp+4h] [ebp-54h]
  int v23; // [esp+Ch] [ebp-4Ch]
  int v24; // [esp+10h] [ebp-48h]
  char *nptr; // [esp+18h] [ebp-40h]
  char v26; // [esp+1Ch] [ebp-3Ch]
  int v27; // [esp+20h] [ebp-38h]
  unsigned int v28; // [esp+24h] [ebp-34h]
  __int64 v29; // [esp+28h] [ebp-30h]
  int v30; // [esp+30h] [ebp-28h]
  int v31; // [esp+34h] [ebp-24h]
  char v32; // [esp+41h] [ebp-17h]
  unsigned int v33; // [esp+4Ch] [ebp-Ch]

  v26 = a2;
  nptr = a3;
  v33 = __readgsdword(0x14u);
  v27 = sub_805EC3B(st7_0, edx0, ecx0, a3, 0, 10, (int)(&v21 - 12), 0);
  v22 = &v30;
  v21 = 7;
  if ( !getrlimit64(v6) )
  {
    dword_806A234 = (int)&loc_804C6C2;
    sub_8061505(v7, v31, v21, v22);
  }
  v28 = 17;
  if ( v27 )
  {
LABEL_11:
    if ( v27 == 1 )
    {
      v15 = sub_805B7F5((int)nptr);
      v16 = *((_DWORD *)&longopts.name + 4 * a1);
      v17 = gettext("--%s argument %s too large");
      v24 = (int)v15;
      v23 = v16;
      error(0, 0, v17, v16, v15);
      v18 = sub_8058F52(v28, (int)&v32);
      v19 = *((_DWORD *)&longopts.name + 4 * a1);
      v20 = gettext("maximum --%s argument with current rlimit is %s");
      v24 = v18;
      v23 = v19;
      error(2, 0, v20, v19, v18);
    }
    sub_805EAED(v7, (int)nptr, v27, a1, v26, (int)&longopts, (int)nptr);
  }
  dword_806A388 = v29;
  v7 = v29;
  if ( v29 != (unsigned int)v29 )
  {
    v27 = 1;
    goto LABEL_11;
  }
  if ( (unsigned int)dword_806A388 <= 1 )
  {
    v8 = sub_805B7F5((int)nptr);
    v9 = *((_DWORD *)&longopts.name + 4 * a1);
    v10 = gettext("invalid --%s argument %s");
    v24 = (int)v8;
    v23 = v9;
    error(0, 0, v10, v9, v8);
    v11 = sub_805B7F5((int)"2");
    v12 = *((_DWORD *)&longopts.name + 4 * a1);
    v13 = gettext("minimum --%s argument is %s");
    v24 = (int)v11;
    v23 = v12;
    error(2, 0, v13, v12, v11);
  }
  if ( v28 < dword_806A388 )
  {
    v27 = 1;
    goto LABEL_11;
  }
  return __readgsdword(0x14u) ^ v33;
}
// 8049920: using guessed type int __fastcall getrlimit64(_DWORD);
// 806A234: using guessed type int dword_806A234;
// 806A388: using guessed type int dword_806A388;

//----- (0804C8A9) --------------------------------------------------------
#error "804C9EF: call analysis failed (funcsize=160)"

//----- (0804CB83) --------------------------------------------------------
int __cdecl sub_804CB83(int a1, int a2, char *nptr)
{
  int v3; // ecx
  char *v5; // eax
  int v6; // [esp+0h] [ebp-38h]
  char v7; // [esp+1Ch] [ebp-1Ch]
  int v8; // [esp+28h] [ebp-10h]
  int v9; // [esp+2Ch] [ebp-Ch]

  v7 = a2;
  v9 = sub_805E5DC(nptr, 0, 10, (int)(&v6 - 4), &s);
  if ( v9 == 1 )
    return -1;
  if ( v9 )
    sub_805EAED(v3, (int)nptr, v9, a1, v7, (int)&longopts, (int)nptr);
  if ( !v8 )
  {
    v5 = gettext("number in parallel must be nonzero");
    error(2, 0, v5);
  }
  return v8;
}

//----- (0804CC38) --------------------------------------------------------
int sub_804CC38()
{
  bool v0; // zf
  int v1; // edx
  int v2; // ecx
  void *v3; // eax
  int v4; // ecx
  long double v5; // fst7
  int result; // eax
  int v7; // [esp+8h] [ebp-50h]
  int v8; // [esp+Ch] [ebp-4Ch]
  unsigned int v9; // [esp+24h] [ebp-34h]
  unsigned int v10; // [esp+24h] [ebp-34h]
  double v11; // [esp+28h] [ebp-30h]
  double v12; // [esp+30h] [ebp-28h]
  double v13; // [esp+38h] [ebp-20h]
  unsigned __int64 v14; // [esp+40h] [ebp-18h]

  v9 = -1;
  v0 = ((int (*)(void))getrlimit64)() == 0;
  v3 = &loc_804CC76;
  if ( !v0 )
    v3 = &loc_804CC99;
  dword_806A270 = (int)v3;
  sub_80613B3(v2, v1, 2, &v14, v7, v8);
  if ( v14 < 0xFFFFFFFF )
    v9 = v14;
  if ( !getrlimit64(v14) )
  {
    v4 = v14;
    if ( v14 < v9 )
      v9 = v14;
  }
  v10 = v9 >> 1;
  if ( !getrlimit64(v4) && 15 * (v14 >> 4) < v10 )
    v10 = 15 * (v14 >> 4);
  v11 = sub_805973B();
  v12 = sub_8059669();
  if ( v11 <= v12 / 8.0 )
    v5 = v12 / 8.0;
  else
    v5 = v11;
  v13 = v5;
  if ( (long double)v10 > v12 * 0.75 )
    v10 = (signed __int64)(v12 * 0.75);
  if ( (long double)v10 > v13 )
    v10 = (signed __int64)v13;
  result = v10;
  if ( 18 * dword_806A388 >= v10 )
    result = 18 * dword_806A388;
  return result;
}
// 8049920: using guessed type int __fastcall getrlimit64(_DWORD);
// 806A270: using guessed type int dword_806A270;
// 806A388: using guessed type int dword_806A388;

//----- (0804CE70) --------------------------------------------------------
int __usercall sub_804CE70@<eax>(double a1@<st0>, int a2, unsigned int a3, int a4, unsigned int a5, int a6)
{
  int v6; // eax
  bool v7; // al
  bool v8; // zf
  void *v9; // eax
  char *v10; // ebx
  char *v11; // eax
  int v13; // [esp+0h] [ebp-98h]
  int v14; // [esp+4h] [ebp-94h]
  int v15; // [esp+8h] [ebp-90h]
  int v16; // [esp+Ch] [ebp-8Ch]
  int v17; // [esp+10h] [ebp-88h]
  int v18; // [esp+14h] [ebp-84h]
  int v19; // [esp+18h] [ebp-80h]
  unsigned int i; // [esp+1Ch] [ebp-7Ch]
  unsigned int v21; // [esp+20h] [ebp-78h]
  unsigned int v22; // [esp+24h] [ebp-74h]
  signed __int64 v23; // [esp+28h] [ebp-70h]
  char v24; // [esp+30h] [ebp-68h]
  int v25; // [esp+34h] [ebp-64h]
  int v26; // [esp+38h] [ebp-60h]
  int v27; // [esp+40h] [ebp-58h]
  __int64 v28; // [esp+5Ch] [ebp-3Ch]

  v21 = a6 + 1;
  v19 = a6 + 2;
  for ( i = 0; i < a5; ++i )
  {
    if ( i >= a3 )
    {
      v8 = strcmp(*(const char **)(4 * i + a4), "-") == 0;
      v9 = &loc_804CF1D;
      if ( !v8 )
        v9 = &loc_804CF37;
      dword_806A2AC = (int)v9;
      sub_8061223(a1);
      v7 = sub_80610AB(0, (int)&v24) != 0;
    }
    else
    {
      v6 = fileno(*(FILE **)(4 * i + a2));
      v7 = sub_80610AB(v6, (int)&v24) != 0;
    }
    if ( v7 )
    {
      v10 = *(char **)(4 * i + a4);
      v11 = gettext("stat failed");
      sub_804B11E((int)v11, v10);
    }
    if ( (v27 & 0xF000) == 0x8000 )
    {
      v23 = v28;
    }
    else
    {
      if ( size )
      {
        dword_806A220 = (int)&loc_804D07C;
        sub_8061579(v13, v14, v15, v16, v17, v18, v19, i, v21, v22, v23, HIDWORD(v23), *(_DWORD *)&v24, v25, v26);
      }
      v23 = 0x20000LL;
    }
    if ( !dword_806AF1C )
    {
      dword_806AF1C = size;
      if ( !size )
        dword_806AF1C = sub_804CC38();
    }
    v22 = v21 * v23 + 1;
    if ( v23 != v22 / v21 || dword_806AF1C - v19 <= v22 )
    {
      dword_806A2CC = (int)&loc_804D07C;
      sub_8061134(HIDWORD(v23));
    }
    v19 += v22;
  }
  return v19;
}
// 8061134: using guessed type int __fastcall sub_8061134(_DWORD);
// 8061223: using guessed type int __usercall sub_8061223@<eax>(double@<st0>);
// 8061579: using guessed type int __stdcall sub_8061579(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806A220: using guessed type int dword_806A220;
// 806A2AC: using guessed type int dword_806A2AC;
// 806A2CC: using guessed type int dword_806A2CC;
// 806AF1C: using guessed type int dword_806AF1C;

//----- (0804D085) --------------------------------------------------------
void __cdecl __noreturn sub_804D085(int a1, int a2, size_t size)
{
  void *v3; // edx
  int v4; // ecx
  size_t sizea; // [esp+28h] [ebp+10h]

  while ( 1 )
  {
    sizea = (size & 0xFFFFFFF0) + 16;
    v3 = malloc(sizea);
    *(_DWORD *)a1 = v3;
    if ( *(_DWORD *)a1 )
    {
      dword_806A248 = (int)sub_804D0E3;
      sub_8061491(v4, v3);
    }
    size = sizea >> 1;
    if ( a2 + 1 >= size )
      sub_805E278();
  }
}
// 804D0E3: using guessed type int sub_804D0E3();
// 8061491: using guessed type int __fastcall sub_8061491(_DWORD, _DWORD);
// 806A248: using guessed type int dword_806A248;

//----- (0804D0E3) --------------------------------------------------------
#error "804D12F: positive sp value has been found (funcsize=22)"

//----- (0804D130) --------------------------------------------------------
int __cdecl sub_804D130(_DWORD *a1)
{
  return *a1 + a1[3];
}

//----- (0804D15B) --------------------------------------------------------
#error "804D18E: call analysis failed (funcsize=19)"

//----- (0804D193) --------------------------------------------------------
#error "804D312: positive sp value has been found (funcsize=102)"

//----- (0804D313) --------------------------------------------------------
unsigned __int8 *__cdecl sub_804D313(int a1, int a2)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  unsigned __int8 *v6; // [esp+4h] [ebp-10h]
  int v7; // [esp+8h] [ebp-Ch]
  unsigned int v8; // [esp+Ch] [ebp-8h]
  int v9; // [esp+10h] [ebp-4h]

  v6 = *(unsigned __int8 **)a1;
  v8 = *(_DWORD *)(a1 + 4) - 1 + *(_DWORD *)a1;
  v7 = *(_DWORD *)(a2 + 8);
  v9 = *(_DWORD *)(a2 + 12);
  if ( !v9 )
    ++v7;
  if ( dword_806A384 == 128 )
  {
    while ( (unsigned int)v6 < v8 )
    {
      v3 = v7--;
      if ( !v3 )
        break;
      while ( (unsigned int)v6 < v8 && byte_806A9BC[(unsigned __int8)sub_804AD6D(*v6)] )
        ++v6;
      while ( (unsigned int)v6 < v8 && (unsigned __int8)byte_806A9BC[(unsigned __int8)sub_804AD6D(*v6)] ^ 1 )
        ++v6;
    }
  }
  else
  {
    while ( (unsigned int)v6 < v8 )
    {
      v2 = v7--;
      if ( !v2 )
        break;
      while ( (unsigned int)v6 < v8 && (char)*v6 != dword_806A384 )
        ++v6;
      if ( (unsigned int)v6 < v8 && (v7 || v9) )
        ++v6;
    }
  }
  if ( v9 )
  {
    if ( *(_BYTE *)(a2 + 25) )
    {
      while ( (unsigned int)v6 < v8 && byte_806A9BC[(unsigned __int8)sub_804AD6D(*v6)] )
        ++v6;
    }
    v4 = v8;
    if ( (unsigned int)&v6[v9] <= v8 )
      v4 = (int)&v6[v9];
    v6 = (unsigned __int8 *)v4;
  }
  return v6;
}
// 806A384: using guessed type int dword_806A384;

//----- (0804D489) --------------------------------------------------------
#error "804D585: call analysis failed (funcsize=89)"

//----- (0804D98C) --------------------------------------------------------
int __cdecl sub_804D98C(char **a1)
{
  int v1; // edx
  char *v2; // eax
  int result; // eax
  char *v4; // eax
  unsigned __int8 v5; // [esp+9h] [ebp-7h]
  bool v6; // [esp+Ah] [ebp-6h]
  unsigned __int8 v7; // [esp+Bh] [ebp-5h]
  char *v8; // [esp+Ch] [ebp-4h]

  v8 = *a1;
  v5 = 0;
  v6 = 0;
  while ( 1 )
  {
    v2 = v8++;
    v7 = *v2;
    if ( (unsigned int)(unsigned __int8)*v2 - 48 > 9 )
      break;
    if ( v5 < v7 )
      v5 = *v2;
    v1 = *v8;
    v6 = v1 == dword_806A9A0;
    if ( v1 == dword_806A9A0 )
      ++v8;
  }
  if ( v6 )
  {
    *a1 = v8 - 2;
    result = v5;
  }
  else
  {
    if ( v7 == dword_806A99C )
    {
      while ( 1 )
      {
        v4 = v8++;
        if ( (unsigned int)(unsigned __int8)*v4 - 48 > 9 )
          break;
        if ( v5 < (unsigned __int8)*v4 )
          v5 = *v4;
      }
    }
    *a1 = v8 - 1;
    result = v5;
  }
  return result;
}
// 806A99C: using guessed type int dword_806A99C;
// 806A9A0: using guessed type int dword_806A9A0;

//----- (0804DA51) --------------------------------------------------------
#error "804DAC9: call analysis failed (funcsize=45)"

//----- (0804DAE1) --------------------------------------------------------
int __cdecl sub_804DAE1(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v2; // ebx
  int v3; // eax
  int result; // eax

  while ( byte_806A9BC[(unsigned __int8)sub_804AD6D(*a1)] )
    ++a1;
  while ( byte_806A9BC[(unsigned __int8)sub_804AD6D(*a2)] )
    ++a2;
  v2 = sub_804DA51(a1);
  v3 = sub_804DA51(a2);
  if ( v2 == v3 )
    result = sub_805D7C4((int)a1);
  else
    result = v2 - v3;
  return result;
}
// 806A99C: using guessed type int dword_806A99C;
// 806A9A0: using guessed type int dword_806A9A0;

//----- (0804DB87) --------------------------------------------------------
#error "804DBC0: call analysis failed (funcsize=41)"

//----- (0804DC13) --------------------------------------------------------
int __cdecl sub_804DC13(int a1, int a2)
{
  _TBYTE s; // [esp+10h] [ebp-28h]
  _TBYTE s2; // [esp+20h] [ebp-18h]

  memset(&s, 0, 0xCu);
  *(long double *)&s = strtold(a1, 0);
  memset(&s2, 0, 0xCu);
  *(long double *)&s2 = strtold(a2, 0);
  return memcmp(&s, &s2, 0xCu);
}
// 80498F0: using guessed type double __cdecl strtold(_DWORD, _DWORD);

//----- (0804DC97) --------------------------------------------------------
signed int __cdecl sub_804DC97(int a1, int a2)
{
  int v2; // edx
  int v3; // ecx
  void *v4; // eax
  signed int result; // eax
  int v6; // [esp+18h] [ebp-30h]
  int v7; // [esp+1Ch] [ebp-2Ch]
  long double v8; // [esp+20h] [ebp-28h]
  long double v9; // [esp+30h] [ebp-18h]

  v8 = strtold(a1, &v6);
  v9 = strtold(a2, &v7);
  if ( a1 == v6 )
  {
    v4 = &loc_804DCF0;
    if ( a2 != v7 )
      v4 = &loc_804DCF7;
    dword_806A248 = (int)v4;
    sub_8061491(v3, v2);
    result = 0;
  }
  else if ( a2 == v7 )
  {
    result = 1;
  }
  else if ( v9 <= v8 )
  {
    if ( v8 <= v9 )
    {
      if ( v9 == v8 )
        result = 0;
      else
        result = -1;
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}
// 80498F0: using guessed type double __cdecl strtold(_DWORD, _DWORD);
// 8061491: using guessed type int __fastcall sub_8061491(_DWORD, _DWORD);
// 806A248: using guessed type int dword_806A248;

//----- (0804DDB1) --------------------------------------------------------
int __cdecl sub_804DDB1(unsigned __int8 *a1, unsigned __int8 **a2)
{
  unsigned __int8 v3; // al
  unsigned __int8 v4; // bl
  unsigned __int8 v5; // al
  unsigned __int8 v6; // bl
  unsigned int v7; // [esp+10h] [ebp-18h]
  unsigned int v8; // [esp+14h] [ebp-14h]
  unsigned __int8 *v9; // [esp+18h] [ebp-10h]
  unsigned __int8 *i; // [esp+1Ch] [ebp-Ch]
  unsigned int v11; // [esp+20h] [ebp-8h]

  v7 = 0;
  v8 = 12;
  while ( byte_806A9BC[(unsigned __int8)sub_804AD6D(*a1)] )
    ++a1;
  while ( 2 )
  {
    v11 = (v7 + v8) >> 1;
    v9 = a1;
    for ( i = (unsigned __int8 *)(&off_806A320)[2 * v11]; ; ++i )
    {
      if ( !*i )
      {
        if ( a2 )
          *a2 = v9;
        return dword_806A324[2 * v11];
      }
      v3 = sub_804AD6D(*v9);
      v4 = sub_804AD6D(byte_806ACBC[v3]);
      if ( v4 < (unsigned __int8)sub_804AD6D(*i) )
      {
        v8 = (v7 + v8) >> 1;
        goto LABEL_14;
      }
      v5 = sub_804AD6D(*v9);
      v6 = sub_804AD6D(byte_806ACBC[v5]);
      if ( v6 > (unsigned __int8)sub_804AD6D(*i) )
        break;
      ++v9;
    }
    v7 = v11 + 1;
LABEL_14:
    if ( v7 < v8 )
      continue;
    return 0;
  }
}
// 806A320: using guessed type char *off_806A320;
// 806A324: using guessed type int dword_806A324[];

//----- (0804DEE3) --------------------------------------------------------
unsigned int __cdecl sub_804DEE3(char *a1)
{
  char *v1; // eax
  char *v2; // eax
  void *ptr; // [esp+18h] [ebp-20h]
  char src; // [esp+1Ch] [ebp-1Ch]
  unsigned int v6; // [esp+2Ch] [ebp-Ch]

  v6 = __readgsdword(0x14u);
  ptr = (void *)sub_805BADB((int)a1, 0x10u);
  if ( !ptr )
  {
    v1 = gettext("open failed");
    sub_804B11E((int)v1, a1);
  }
  sub_805BDB7((int)ptr, &src, 0x10u);
  if ( sub_805BDFF(ptr) )
  {
    v2 = gettext("close failed");
    sub_804B11E((int)v2, a1);
  }
  sub_80558E0(&unk_806AE7C);
  sub_8055CEE(&src, 0x10u, (int)&unk_806AE7C);
  return __readgsdword(0x14u) ^ v6;
}

//----- (0804DFBF) --------------------------------------------------------
size_t __cdecl sub_804DFBF(char *dest, char *src, size_t n)
{
  char *v3; // ebx
  int *v4; // eax
  char *v5; // eax
  void *v6; // ebx
  char *v7; // eax
  size_t v9; // [esp+1Ch] [ebp-Ch]

  *__errno_location() = 0;
  v9 = strxfrm(dest, src, n);
  if ( *__errno_location() )
  {
    v3 = gettext("string transformation failed");
    v4 = __errno_location();
    error(0, *v4, v3);
    v5 = gettext("set LC_ALL='C' to work around the problem");
    error(0, 0, v5);
    v6 = sub_805B32D(0, 8, (int)src);
    v7 = gettext("the untransformed string was %s");
    error(2, 0, v7, v6);
  }
  return v9;
}

//----- (0804E097) --------------------------------------------------------
#error "804E6FA: call analysis failed (funcsize=369)"

//----- (0804E752) --------------------------------------------------------
#error "804E777: call analysis failed (funcsize=14)"

//----- (0804E77C) --------------------------------------------------------
#error "804E7C6: positive sp value has been found (funcsize=0)"

//----- (0804E7C7) --------------------------------------------------------
int __cdecl sub_804E7C7(int a1, int a2)
{
  int v2; // ecx
  int v3; // eax
  int v4; // edx
  void *v5; // eax
  char *v6; // eax
  int v8; // [esp+0h] [ebp-18h]
  int v9; // [esp+4h] [ebp-14h]
  int v10; // [esp+8h] [ebp-10h]
  int v11; // [esp+Ch] [ebp-Ch]

  while ( 1 )
  {
    v3 = a1;
    v4 = a1-- - 1;
    if ( !v3 )
      break;
    putchar_unlocked(32);
  }
  v5 = &loc_804E807;
  if ( a2 )
    v5 = &loc_804E81D;
  dword_806A270 = (int)v5;
  sub_80613B3(v2, v4, v8, v9, v10, v11);
  v6 = gettext("^ no match for key\n");
  return printf(v6);
}
// 806A270: using guessed type int dword_806A270;

//----- (0804E841) --------------------------------------------------------
int __usercall sub_804E841@<eax>(int edx0@<edx>, int a2@<ecx>, _BYTE *a1)
{
  void *v3; // eax
  char v4; // al

  if ( a1[26] )
    goto LABEL_10;
  v3 = &loc_804E873;
  if ( a1[28] )
    v3 = &loc_804E87E;
  dword_806A25C = (int)v3;
  sub_806141F(a2, edx0);
  if ( a1[29] )
LABEL_10:
    v4 = 1;
  else
    v4 = 0;
  return v4 & 1;
}
// 806141F: using guessed type int __fastcall sub_806141F(_DWORD, _DWORD);
// 806A25C: using guessed type int dword_806A25C;

//----- (0804E88F) --------------------------------------------------------
#error "804EA0C: call analysis failed (funcsize=200)"

//----- (0804EB14) --------------------------------------------------------
int __cdecl sub_804EB14(int a1)
{
  int result; // eax
  int v2; // [esp+1Ch] [ebp-Ch]

  v2 = dword_806ADD0;
  while ( 1 )
  {
    result = sub_804E88F(a1, v2);
    if ( !v2 )
      break;
    v2 = *(_DWORD *)(v2 + 36);
    if ( !v2 )
    {
      result = (unsigned __int8)byte_806ADCE ^ 1;
      if ( byte_806ADCE == 1 )
        break;
      result = (unsigned __int8)byte_806ADCD ^ 1;
      if ( byte_806ADCD == 1 )
        break;
    }
  }
  return result;
}
// 804E88F: using guessed type _DWORD __cdecl sub_804E88F(_DWORD, _DWORD);
// 806ADCD: using guessed type char byte_806ADCD;
// 806ADCE: using guessed type char byte_806ADCE;
// 806ADD0: using guessed type int dword_806ADD0;

//----- (0804EB67) --------------------------------------------------------
#error "804EBE3: call analysis failed (funcsize=56)"

//----- (0804EC07) --------------------------------------------------------
_BYTE *__cdecl sub_804EC07(int a1, _BYTE *a2)
{
  _BYTE *v2; // eax
  _BYTE *v3; // eax
  _BYTE *v4; // eax
  _BYTE *v5; // eax
  _BYTE *v6; // eax
  _BYTE *v7; // eax
  _BYTE *v8; // eax
  _BYTE *v9; // eax
  _BYTE *v10; // eax
  _BYTE *v11; // eax
  _BYTE *v12; // eax
  _BYTE *result; // eax

  if ( *(_BYTE *)(a1 + 24) || *(_BYTE *)(a1 + 25) )
  {
    v2 = a2++;
    *v2 = 98;
  }
  if ( *(_UNKNOWN **)(a1 + 16) == &unk_806ABBC )
  {
    v3 = a2++;
    *v3 = 100;
  }
  if ( *(_DWORD *)(a1 + 20) )
  {
    v4 = a2++;
    *v4 = 102;
  }
  if ( *(_BYTE *)(a1 + 28) )
  {
    v5 = a2++;
    *v5 = 103;
  }
  if ( *(_BYTE *)(a1 + 29) )
  {
    v6 = a2++;
    *v6 = 104;
  }
  if ( *(_UNKNOWN **)(a1 + 16) == &unk_806AABC )
  {
    v7 = a2++;
    *v7 = 105;
  }
  if ( *(_BYTE *)(a1 + 30) )
  {
    v8 = a2++;
    *v8 = 77;
  }
  if ( *(_BYTE *)(a1 + 26) )
  {
    v9 = a2++;
    *v9 = 110;
  }
  if ( *(_BYTE *)(a1 + 27) )
  {
    v10 = a2++;
    *v10 = 82;
  }
  if ( *(_BYTE *)(a1 + 31) )
  {
    v11 = a2++;
    *v11 = 114;
  }
  if ( *(_BYTE *)(a1 + 32) )
  {
    v12 = a2++;
    *v12 = 86;
  }
  result = a2;
  *a2 = 0;
  return result;
}

//----- (0804ED1D) --------------------------------------------------------
int __usercall __noreturn sub_804ED1D@<eax>(int a1@<ecx>, char *a2@<ebx>, int *a3, char a4)
{
  unsigned int v4; // edx
  int v5; // eax
  int v6; // eax
  const char *v7; // edx
  char *v8; // eax
  const char *v9; // eax
  void *v10; // esi
  char *v11; // eax
  bool v12; // al
  char *v13; // eax
  int v14; // edx
  bool v15; // al
  bool v16; // al
  char *v17; // eax
  char *v18; // eax
  int v19; // edx
  int v20; // ecx
  size_t v21; // eax
  int v22; // eax
  char *v23; // eax
  void *v24; // eax
  char *v25; // eax
  unsigned int v26; // et1
  int (*v27)(); // eax
  char *v29; // [esp-8h] [ebp-D0h]
  int v30; // [esp-4h] [ebp-CCh]
  unsigned __int64 v31; // [esp+0h] [ebp-C8h]
  char *v32; // [esp+Ch] [ebp-BCh]
  void *v33; // [esp+10h] [ebp-B8h]
  char v34; // [esp+18h] [ebp-B0h]
  int *v35; // [esp+1Ch] [ebp-ACh]
  bool v36; // [esp+20h] [ebp-A8h]
  bool v37; // [esp+21h] [ebp-A7h]
  bool v38; // [esp+22h] [ebp-A6h]
  char v39; // [esp+23h] [ebp-A5h]
  int v40; // [esp+24h] [ebp-A4h]
  char *v41; // [esp+28h] [ebp-A0h]
  unsigned int v42; // [esp+2Ch] [ebp-9Ch]
  unsigned int v43; // [esp+30h] [ebp-98h]
  int v44; // [esp+34h] [ebp-94h]
  char *v45; // [esp+38h] [ebp-90h]
  char *v46; // [esp+3Ch] [ebp-8Ch]
  unsigned int v47; // [esp+40h] [ebp-88h]
  int v48; // [esp+44h] [ebp-84h]
  int v49; // [esp+48h] [ebp-80h]
  int v50; // [esp+4Ch] [ebp-7Ch]
  int v51; // [esp+50h] [ebp-78h]
  int v52; // [esp+54h] [ebp-74h]
  int v53; // [esp+58h] [ebp-70h]
  int v54; // [esp+5Ch] [ebp-6Ch]
  int v55; // [esp+60h] [ebp-68h]
  int v56; // [esp+64h] [ebp-64h]
  int v57; // [esp+68h] [ebp-60h]
  char v58; // [esp+6Eh] [ebp-5Ah]
  char v59; // [esp+83h] [ebp-45h]
  char s; // [esp+9Dh] [ebp-2Bh]
  unsigned int v61; // [esp+BCh] [ebp-Ch]

  v35 = a3;
  v34 = a4;
  v61 = __readgsdword(0x14u);
  v48 = *a3;
  v49 = a3[1];
  v50 = a3[2];
  v51 = a3[3];
  v52 = a3[4];
  v53 = a3[5];
  v54 = a3[6];
  v55 = a3[7];
  v4 = a3[8];
  v56 = a3[8];
  v57 = a3[9];
  v41 = (char *)1;
  v40 = dword_806ADD0;
  while ( v40 )
  {
    if ( *(_BYTE *)(v40 + 33) )
    {
      v42 = *(_DWORD *)v40;
      v44 = *(_DWORD *)(v40 + 8);
      v45 = (char *)&v31 - 69;
      v46 = (char *)&v31 - 43;
      if ( v42 == -1 )
        v42 = 0;
      v5 = sub_8058FC0(v42, (int)&v58);
      *(_WORD *)v45 = 43;
      v45 = (char *)stpcpy(v45 + 1, v5);
      v31 = v42 + 1;
      v6 = sub_8058FC0(v31, (int)&v58);
      *(_DWORD *)v46 = 2124589;
      v46 = (char *)stpcpy(v46 + 3, v6);
      if ( *(_DWORD *)(v40 + 8) != -1 )
      {
        v31 = (unsigned int)(v44 + 1);
        v7 = (const char *)sub_8058FC0(v31, (int)&v58);
        v8 = v45;
        *(_WORD *)v45 = 11552;
        v8[2] = 0;
        strcpy(v45 + 2, v7);
        v9 = (const char *)sub_8058FC0((unsigned int)(*(_DWORD *)(v40 + 12) == -1) + v44 + 1, (int)&v31 - 90);
        *(_WORD *)v46 = 44;
        strcpy(v46 + 1, v9);
      }
      v10 = sub_805B7D3(1, (int)&s);
      a2 = (char *)sub_805B7D3(0, (int)&v59);
      v11 = gettext("obsolescent key %s used; consider %s instead");
      v33 = v10;
      v32 = a2;
      error(0, 0, v11, a2, v10);
    }
    v12 = 0;
    if ( *(_DWORD *)v40 != -1 )
    {
      v4 = *(_DWORD *)(v40 + 8);
      if ( v4 < *(_DWORD *)v40 )
        v12 = 1;
    }
    v36 = v12;
    if ( v12 )
    {
      v13 = gettext("key %lu has zero width and will be ignored");
      v32 = v41;
      error(0, 0, v13, v41);
    }
    v15 = (unsigned __int8)sub_804E841(v4, a1, (_BYTE *)v40) || *(_BYTE *)(v40 + 30);
    v37 = v15;
    v16 = !*(_DWORD *)(v40 + 8) && *(_DWORD *)(v40 + 12);
    v38 = v16;
    if ( v36 != 1
      && v34 != 1
      && dword_806A384 == 128
      && v38 != 1
      && (*(_BYTE *)(v40 + 24) != 1 && v37 != 1
       || *(_BYTE *)(v40 + 24) != 1 && *(_DWORD *)(v40 + 4)
       || *(_BYTE *)(v40 + 25) != 1 && *(_DWORD *)(v40 + 12)) )
    {
      v17 = gettext("leading blanks are significant in key %lu; consider also specifying 'b'");
      v32 = v41;
      error(0, 0, v17, v41);
    }
    if ( v34 != 1 && (unsigned __int8)sub_804E841(v14, a1, (_BYTE *)v40) )
    {
      v43 = *(_DWORD *)v40 + 1;
      v47 = *(_DWORD *)(v40 + 8) + 1;
      if ( !v43 )
        v43 = 1;
      if ( !v47 || v43 < v47 )
      {
        v18 = gettext("key %lu is numeric and spans multiple fields");
        v32 = v41;
        error(0, 0, v18, v41);
      }
    }
    if ( v52 && v52 == *(_DWORD *)(v40 + 16) )
      v52 = 0;
    if ( v53 && v53 == *(_DWORD *)(v40 + 20) )
      v53 = 0;
    LOBYTE(v54) = (unsigned __int8)(v54 & (*(_BYTE *)(v40 + 24) ^ 1)) != 0;
    BYTE1(v54) = (BYTE1(v54) & (*(_BYTE *)(v40 + 25) ^ 1)) != 0;
    BYTE2(v55) = (BYTE2(v55) & (*(_BYTE *)(v40 + 30) ^ 1)) != 0;
    BYTE2(v54) = (BYTE2(v54) & (*(_BYTE *)(v40 + 26) ^ 1)) != 0;
    LOBYTE(v55) = (unsigned __int8)(v55 & (*(_BYTE *)(v40 + 28) ^ 1)) != 0;
    BYTE1(v55) = (BYTE1(v55) & (*(_BYTE *)(v40 + 29) ^ 1)) != 0;
    HIBYTE(v54) = (HIBYTE(v54) & (*(_BYTE *)(v40 + 27) ^ 1)) != 0;
    LOBYTE(v56) = (unsigned __int8)(v56 & (*(_BYTE *)(v40 + 32) ^ 1)) != 0;
    v4 = HIBYTE(v55);
    HIBYTE(v55) = (HIBYTE(v55) & (*(_BYTE *)(v40 + 31) ^ 1)) != 0;
    v40 = *(_DWORD *)(v40 + 36);
    ++v41;
  }
  if ( (unsigned __int8)sub_804EB67(&v48) ^ 1 || HIBYTE(v55) && (byte_806ADCD || byte_806ADCE) && dword_806ADD0 )
  {
    v39 = HIBYTE(v55);
    if ( byte_806ADCD != 1 && byte_806ADCE != 1 )
      HIBYTE(v55) = 0;
    sub_804EC07((int)&v48, &s);
    v21 = strlen(&s);
    v22 = sub_804ADD3(v21);
    v23 = ngettext("option '-%s' is ignored", "options '-%s' are ignored", v22);
    v32 = &s;
    error(0, 0, v23, &s);
    HIBYTE(v55) = v39;
  }
  if ( HIBYTE(v55) && byte_806ADCD != 1 )
  {
    v30 = (unsigned __int8)byte_806ADCE ^ 1;
    v29 = a2;
    v24 = &loc_804F4B6;
    if ( byte_806ADCE == 1 )
      v24 = &loc_804F4E3;
    dword_806A234 = (int)v24;
    a2 = v29;
    sub_8061505(v20, v19, v31, HIDWORD(v31));
    if ( dword_806ADD0 )
    {
      v25 = gettext("option '-r' only applies to last-resort comparison");
      error(0, 0, v25);
    }
  }
  v26 = __readgsdword(0x14u);
  v30 = v26 ^ v61;
  v29 = a2;
  v27 = (int (*)())&loc_804F508;
  if ( v26 == v61 )
    v27 = sub_804F50D;
  dword_806A248 = (int)v27;
  return sub_8061491(v20, v19);
}
// 8049930: using guessed type int __cdecl stpcpy(_DWORD, _DWORD);
// 804EB67: using guessed type _DWORD __cdecl sub_804EB67(_DWORD);
// 804F50D: using guessed type int sub_804F50D();
// 8061491: using guessed type int __fastcall sub_8061491(_DWORD, _DWORD);
// 806A234: using guessed type int dword_806A234;
// 806A248: using guessed type int dword_806A248;
// 806A384: using guessed type int dword_806A384;
// 806ADCD: using guessed type char byte_806ADCD;
// 806ADCE: using guessed type char byte_806ADCE;
// 806ADD0: using guessed type int dword_806ADD0;

//----- (0804F50D) --------------------------------------------------------
#error "804F513: positive sp value has been found (funcsize=0)"

//----- (0804F517) --------------------------------------------------------
#error "804F68E: call analysis failed (funcsize=399)"

//----- (080503D0) --------------------------------------------------------
#error "805040F: call analysis failed (funcsize=111)"

//----- (08050538) --------------------------------------------------------
#error "8050684: call analysis failed (funcsize=94)"

//----- (080506A4) --------------------------------------------------------
#error "80506AE: positive sp value has been found (funcsize=0)"

//----- (080506AF) --------------------------------------------------------
#error "80506C3: call analysis failed (funcsize=15)"

//----- (080506D6) --------------------------------------------------------
void __cdecl __noreturn sub_80506D6(int a1, char *a2, char a3)
{
  size_t size; // eax
  char *s1; // [esp+0h] [ebp-ACh]
  char v5; // [esp+Ch] [ebp-A0h]
  char *v6; // [esp+10h] [ebp-9Ch]
  char v7; // [esp+22h] [ebp-8Ah]
  char v8[5]; // [esp+23h] [ebp-89h]
  FILE *v9; // [esp+2Ch] [ebp-80h]
  int v10; // [esp+30h] [ebp-7Ch]
  int v11; // [esp+3Ch] [ebp-70h]
  int v12; // [esp+40h] [ebp-6Ch]
  unsigned int v13; // [esp+90h] [ebp-1Ch]

  v6 = a2;
  v5 = a3;
  v13 = __readgsdword(0x14u);
  v9 = sub_804BBCC(a2, "r");
  *(_DWORD *)&v8[1] = 0;
  v11 = 0;
  v12 = 0;
  v10 = dword_806ADD0;
  *(_DWORD *)v8 = byte_806ADCE == 0;
  v8[0] &= 1u;
  v7 = 1;
  size = dword_806A380;
  if ( ::size >= dword_806A380 )
    size = ::size;
  sub_804D085((int)(&s1 - 20), 16, size);
}
// 806ADCE: using guessed type char byte_806ADCE;
// 806ADD0: using guessed type int dword_806ADD0;

//----- (08050AB2) --------------------------------------------------------
unsigned int __usercall sub_8050AB2@<eax>(double a1@<st0>, int a2, unsigned int a3, void **a4)
{
  int v4; // eax
  unsigned int i; // [esp+18h] [ebp-10h]
  _DWORD *v7; // [esp+1Ch] [ebp-Ch]

  *a4 = sub_805E01B(a3, 4u);
  v7 = *a4;
  for ( i = 0; i < a3; ++i )
  {
    v4 = *(_DWORD *)(8 * i + a2 + 4) && *(_BYTE *)(*(_DWORD *)(8 * i + a2 + 4) + 8) ? sub_804C01C(
                                                                                        a1,
                                                                                        *(_DWORD *)(8 * i + a2 + 4)) : sub_804BA5E(*(char **)(8 * i + a2), "r");
    v7[i] = v4;
    if ( !v7[i] )
      break;
  }
  return i;
}

//----- (08050BA6) --------------------------------------------------------
void __cdecl sub_8050BA6(int a1, int a2, int a3, FILE *stream, int a5, void *ptr)
{
  unsigned int *v6; // edx
  int v7; // ecx
  size_t v8; // edx
  unsigned int v9; // ST50_4
  void *v10; // eax
  int v11; // [esp+0h] [ebp-78h]
  int v12; // [esp+4h] [ebp-74h]
  unsigned int i; // [esp+1Ch] [ebp-5Ch]
  unsigned int j; // [esp+1Ch] [ebp-5Ch]
  void *v15; // [esp+30h] [ebp-48h]
  _DWORD *v16; // [esp+34h] [ebp-44h]
  void *v17; // [esp+38h] [ebp-40h]
  _DWORD *v18; // [esp+3Ch] [ebp-3Ch]
  void *dest; // [esp+60h] [ebp-18h]

  v15 = sub_805E01B(a3, 0x1Cu);
  v16 = sub_805E01B(a3, 4u);
  v17 = sub_805E01B(a3, 4u);
  v18 = sub_805E01B(a3, 4u);
  dest = 0;
  if ( (unsigned int)a3 > 0 )
  {
    v8 = size / a3;
    if ( size / a3 < dword_806A380 )
      v8 = dword_806A380;
    sub_804D085((int)v15, 16, v8);
  }
  for ( i = 0; i < a3; ++i )
  {
    v6 = &v18[i];
    *v6 = i;
  }
  for ( j = 1; j < a3; ++j )
  {
    if ( sub_80503D0(v16[v18[j + 0x3FFFFFFF]], (int *)v16[v18[j]]) > 0 )
    {
      v9 = v18[j + 0x3FFFFFFF];
      v7 = 4 * j;
      v18[j + 0x3FFFFFFF] = v18[j];
      v6 = &v18[j];
      *v6 = v9;
      j = 0;
    }
  }
  v10 = &loc_80515BE;
  if ( a3 )
    v10 = &loc_8050F93;
  dword_806A234 = (int)v10;
  sub_8061505(v7, v6, v11, v12);
  sub_804BC0D(stream, a5);
  free(ptr);
  free(v15);
  free(v18);
  free(v17);
  free(v16);
}
// 806A234: using guessed type int dword_806A234;
// 806ADCE: using guessed type char byte_806ADCE;
// 806ADD0: using guessed type int dword_806ADD0;

//----- (08051642) --------------------------------------------------------
#error "8051661: call analysis failed (funcsize=12)"

//----- (08051666) --------------------------------------------------------
#error "8051707: positive sp value has been found (funcsize=47)"

//----- (08051708) --------------------------------------------------------
int __cdecl sub_8051708(_DWORD *a1, unsigned int a2, _DWORD *a3)
{
  int v3; // ecx
  void *v4; // eax
  int v6; // ecx
  int v7; // edx
  void *v8; // eax
  int v9; // edx
  int v10; // ecx
  unsigned int v11; // [esp+14h] [ebp-14h]
  int v12; // [esp+18h] [ebp-10h]
  _DWORD *v13; // [esp+1Ch] [ebp-Ch]
  _DWORD *v14; // [esp+30h] [ebp+8h]
  _DWORD *v15; // [esp+38h] [ebp+10h]

  v11 = a2 >> 1;
  v12 = a2 - (a2 >> 1);
  v13 = &a1[-4 * (a2 >> 1)];
  while ( sub_80503D0((int)(a3 - 4), v13 - 4) > 0 )
  {
    a1 -= 4;
    v13 -= 4;
    *a1 = *v13;
    a1[1] = v13[1];
    a1[2] = v13[2];
    a1[3] = v13[3];
    if ( !--v12 )
    {
      a1 -= 4;
      a3 -= 4;
      *a1 = *a3;
      a1[1] = a3[1];
      v6 = a3[2];
      a1[2] = v6;
      v7 = a3[3];
      a1[3] = v7;
      --v11;
      v8 = &loc_8051852;
      if ( v11 )
        v8 = &loc_80517FB;
      dword_806A248 = (int)v8;
      sub_8061491(v6, v7);
      dword_806A248 = (int)&locret_805186E;
      sub_8061491(v10, v9);
    }
  }
  v14 = a1 - 4;
  v15 = a3 - 4;
  *v14 = *v15;
  v14[1] = v15[1];
  v3 = v15[2];
  v14[2] = v3;
  v14[3] = v15[3];
  v4 = &loc_80517B8;
  if ( v11 != 1 )
    v4 = &loc_8051869;
  dword_806A2CC = (int)v4;
  return sub_8061134(v3);
}
// 8051708: could not find valid save-restore pair for ebx
// 8061134: using guessed type int __fastcall sub_8061134(_DWORD);
// 8061491: using guessed type int __fastcall sub_8061491(_DWORD, _DWORD);
// 806A248: using guessed type int dword_806A248;
// 806A2CC: using guessed type int dword_806A2CC;

//----- (08051870) --------------------------------------------------------
#error "8051B08: call analysis failed (funcsize=175)"

//----- (08051B57) --------------------------------------------------------
pthread_mutex_t *__cdecl sub_8051B57(int a1, int a2, int a3)
{
  pthread_mutex_t *v3; // eax
  pthread_mutex_t *v4; // ST28_4
  pthread_mutex_t *v5; // ST2C_4

  v3 = (pthread_mutex_t *)sub_805E128(144 * a1);
  v4 = v3;
  v5 = v3;
  v3->__kind = 0;
  v5->__owner = v5->__kind;
  v5->__count = v5->__owner;
  v5->__lock = v5->__count;
  v3->__nusers = 0;
  v3[1].__lock = a2;
  v5->__spins = v5[1].__lock;
  v3[1].__count = 0;
  v3[1].__nusers = 0;
  v3[1].__size[20] = 0;
  pthread_mutex_init(v3 + 2, 0);
  sub_8051CA6(v5, &v5[3], a3, a1, a2, 0);
  return v4;
}
// 8051CA6: using guessed type _DWORD __cdecl sub_8051CA6(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (08051CA6) --------------------------------------------------------
#error "8051CCC: call analysis failed (funcsize=44)"

//----- (08051D2A) --------------------------------------------------------
#error "8051DE7: call analysis failed (funcsize=92)"

//----- (08051ED1) --------------------------------------------------------
_BOOL4 __cdecl sub_8051ED1(_DWORD *a1, _DWORD *a2)
{
  _BOOL4 result; // eax

  if ( a1[10] == a2[10] )
    result = a1[5] + a1[6] < (unsigned int)(a2[5] + a2[6]);
  else
    result = a1[10] < a2[10];
  return result;
}

//----- (08051F50) --------------------------------------------------------
int __cdecl sub_8051F50(pthread_mutex_t *a1)
{
  return pthread_mutex_lock(a1 + 2);
}

//----- (08051F66) --------------------------------------------------------
int __cdecl sub_8051F66(pthread_mutex_t *a1)
{
  return pthread_mutex_unlock(a1 + 2);
}

//----- (08051FAD) --------------------------------------------------------
int __cdecl sub_8051FAD(int a1, int a2)
{
  *(_DWORD *)a1 = sub_8058A59((int (*)())sub_8051ED1, 2 * a2);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 4), 0);
  return pthread_cond_init((pthread_cond_t *)(a1 + 28), 0);
}

//----- (08051FFB) --------------------------------------------------------
int __cdecl sub_8051FFB(int a1, int a2)
{
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 4));
  sub_8058B08(*(_DWORD *)a1, a2);
  *(_BYTE *)(a2 + 44) = 1;
  pthread_cond_signal((pthread_cond_t *)(a1 + 28));
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 4));
}

//----- (08052048) --------------------------------------------------------
pthread_mutex_t *__cdecl sub_8052048(int a1)
{
  int v1; // edx
  int v2; // ecx
  pthread_mutex_t *v4; // [esp+1Ch] [ebp-Ch]

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 4));
  dword_806A248 = (int)&loc_805208B;
  sub_8061491(v2, v1);
  do
  {
    pthread_cond_wait((pthread_cond_t *)(a1 + 28), (pthread_mutex_t *)(a1 + 4));
    v4 = (pthread_mutex_t *)sub_8058BA1(*(_DWORD *)a1);
  }
  while ( !v4 );
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 4));
  sub_8051F50(v4);
  v4[1].__size[20] = 0;
  return v4;
}
// 8058BA1: using guessed type _DWORD __cdecl sub_8058BA1(_DWORD);
// 8061491: using guessed type int __fastcall sub_8061491(_DWORD, _DWORD);
// 806A248: using guessed type int dword_806A248;

//----- (080520C6) --------------------------------------------------------
void __cdecl __noreturn sub_80520C6(int a1, FILE *stream, int a3)
{
  int v3; // edx
  int v4; // ecx
  int v5; // [esp+0h] [ebp-18h]
  int v6; // [esp+4h] [ebp-14h]
  int v7; // [esp+8h] [ebp-10h]

  if ( byte_806ADCE )
  {
    if ( dword_806A9A8 )
    {
      if ( !sub_80503D0(a1, &dword_806A9A8) )
      {
        dword_806A284 = (int)sub_805214C;
        sub_806132A(v4, v3, v5, v6, v7);
      }
    }
    dword_806A9A8 = *(_DWORD *)a1;
    dword_806A9AC = *(_DWORD *)(a1 + 4);
    dword_806A9B0 = *(_DWORD *)(a1 + 8);
    dword_806A9B4 = *(_DWORD *)(a1 + 12);
  }
  sub_8050538(a1, stream, a3);
}
// 805214C: using guessed type int sub_805214C();
// 806A284: using guessed type int dword_806A284;
// 806A9A8: using guessed type int dword_806A9A8;
// 806A9AC: using guessed type int dword_806A9AC;
// 806A9B0: using guessed type int dword_806A9B0;
// 806A9B4: using guessed type int dword_806A9B4;
// 806ADCE: using guessed type char byte_806ADCE;

//----- (0805214C) --------------------------------------------------------
#error "805214D: positive sp value has been found (funcsize=0)"

//----- (0805214E) --------------------------------------------------------
#error "805219B: call analysis failed (funcsize=29)"

//----- (080521A0) --------------------------------------------------------
#error "805232D: positive sp value has been found (funcsize=114)"

//----- (08052641) --------------------------------------------------------
int __cdecl sub_8052641(int a1, int a2)
{
  int v2; // ecx
  int result; // eax
  bool v4; // al
  void *v5; // eax
  int v6; // ecx
  void *v7; // eax

  result = *(unsigned __int8 *)(a2 + 44) ^ 1;
  if ( *(_BYTE *)(a2 + 44) != 1 )
  {
    if ( (unsigned int)(*(_DWORD *)a2 - *(_DWORD *)(a2 + 8) + 15) > 0x1E )
    {
      v4 = (unsigned int)(*(_DWORD *)(a2 + 4) - *(_DWORD *)(a2 + 12) + 15) > 0x1E || !*(_DWORD *)(a2 + 24);
      result = v4;
    }
    else
    {
      v5 = &loc_80526EA;
      if ( (unsigned int)(*(_DWORD *)(a2 + 4) - *(_DWORD *)(a2 + 12) + 15) <= 0x1E )
        v5 = &loc_8052724;
      dword_806A2CC = (int)v5;
      sub_8061134(v2);
      v7 = &loc_805271D;
      if ( *(_DWORD *)(a2 + 20) )
        v7 = &loc_8052724;
      dword_806A2CC = (int)v7;
      sub_8061134(v6);
      result = 1;
    }
    if ( (_BYTE)result )
      result = sub_8051FFB(a1, a2);
  }
  return result;
}
// 8052641: could not find valid save-restore pair for ebx
// 8061134: using guessed type int __fastcall sub_8061134(_DWORD);
// 806A2CC: using guessed type int dword_806A2CC;

//----- (08052744) --------------------------------------------------------
int __cdecl sub_8052744(int a1, _DWORD *a2)
{
  int result; // eax

  if ( a2[10] <= 1u )
  {
    result = a2[5] + a2[6];
    if ( !result )
      result = sub_8051FFB(a1, a2[7]);
  }
  else
  {
    sub_8051F50((pthread_mutex_t *)a2[7]);
    sub_8052641(a1, a2[7]);
    result = sub_8051F66((pthread_mutex_t *)a2[7]);
  }
  return result;
}

//----- (080527B1) --------------------------------------------------------
void __cdecl __noreturn sub_80527B1(int a1, int a2, int a3, int a4)
{
  int v4; // edx
  int v5; // ecx
  int v6; // ST00_4
  int v7; // ST04_4
  int v8; // [esp+8h] [ebp-20h]
  pthread_mutex_t *v9; // [esp+1Ch] [ebp-Ch]

  while ( 1 )
  {
    v9 = sub_8052048(a1);
    if ( !v9[1].__nusers )
    {
      sub_8051F66(v9);
      sub_8051FFB(a1, (int)v9);
      dword_806A284 = (int)sub_8052857;
      sub_806132A(v5, v4, v6, v7, v8);
    }
    v8 = a3;
    sub_805214E(v9, a2);
    sub_8052641(a1, (int)v9);
    sub_8052744(a1, v9);
    sub_8051F66(v9);
  }
}
// 805214E: using guessed type _DWORD __cdecl sub_805214E(_DWORD, _DWORD);
// 8052857: using guessed type int sub_8052857();
// 806A284: using guessed type int dword_806A284;

//----- (08052857) --------------------------------------------------------
#error "8052858: positive sp value has been found (funcsize=0)"

//----- (08052859) --------------------------------------------------------
void *__cdecl start_routine(void *a1)
{
  sub_80528D6(
    *(_DWORD *)a1,
    *((_DWORD *)a1 + 1),
    *((_DWORD *)a1 + 2),
    *((_DWORD *)a1 + 3),
    *((_DWORD *)a1 + 4),
    *((_DWORD *)a1 + 5),
    *((_DWORD *)a1 + 6));
  return 0;
}
// 80528D6: using guessed type _DWORD __cdecl sub_80528D6(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (080528D6) --------------------------------------------------------
#error "8052A55: call analysis failed (funcsize=173)"

//----- (08052B3F) --------------------------------------------------------
int __usercall sub_8052B3F@<eax>(int a1@<ebx>, double a2@<st0>, int a3, int a4, int a5, char *s1)
{
  int result; // eax
  void *v7; // eax
  bool v8; // al
  int v9; // [esp+0h] [ebp-F8h]
  int v10; // [esp+4h] [ebp-F4h]
  signed int v11; // [esp+8h] [ebp-F0h]
  int v12; // [esp+Ch] [ebp-ECh]
  int v13; // [esp+10h] [ebp-E8h]
  int v14; // [esp+14h] [ebp-E4h]
  int v15; // [esp+18h] [ebp-E0h]
  int v16; // [esp+1Ch] [ebp-DCh]
  int v17; // [esp+20h] [ebp-D8h]
  int v18; // [esp+24h] [ebp-D4h]
  int v19; // [esp+28h] [ebp-D0h]
  unsigned int i; // [esp+2Ch] [ebp-CCh]
  __int64 v21; // [esp+30h] [ebp-C8h]
  int v22; // [esp+38h] [ebp-C0h]
  int v23; // [esp+3Ch] [ebp-BCh]
  int v24; // [esp+40h] [ebp-B8h]
  int v25; // [esp+44h] [ebp-B4h]
  int v26; // [esp+48h] [ebp-B0h]
  int v27; // [esp+4Ch] [ebp-ACh]
  int v28; // [esp+50h] [ebp-A8h]
  int v29; // [esp+54h] [ebp-A4h]
  int v30; // [esp+58h] [ebp-A0h]
  int v31; // [esp+5Ch] [ebp-9Ch]
  int v32; // [esp+60h] [ebp-98h]
  int v33; // [esp+64h] [ebp-94h]
  int v34; // [esp+68h] [ebp-90h]
  __int64 v35; // [esp+88h] [ebp-70h]
  __int64 v36; // [esp+90h] [ebp-68h]
  __int64 v37; // [esp+E8h] [ebp-10h]

  BYTE1(v17) = 0;
  v19 = 0;
  for ( i = a4; ; ++i )
  {
    result = i;
    if ( i >= a5 )
      break;
    HIBYTE(v17) = strcmp(*(const char **)(8 * i + a3), "-") == 0;
    if ( s1 && !strcmp(s1, *(const char **)(8 * i + a3)) && HIBYTE(v17) != 1 )
    {
      BYTE2(v17) = 1;
    }
    else
    {
      if ( BYTE1(v17) != 1 )
      {
        result = sub_80610AB(1, (int)&v21);
        if ( result )
          return result;
        BYTE1(v17) = 1;
      }
      v7 = &loc_8052C34;
      if ( !HIBYTE(v17) )
        v7 = &loc_8052C4D;
      dword_806A298 = (int)v7;
      sub_806129D(
        v9,
        v10,
        v11,
        v12,
        v13,
        v14,
        v15,
        v16,
        v17,
        v18,
        v19,
        i,
        v21,
        HIDWORD(v21),
        v22,
        v23,
        v24,
        v25,
        v26,
        v27,
        v28,
        v29,
        v30,
        v31,
        v32,
        v33,
        v34,
        a2);
      v8 = 0;
      if ( !sub_80610AB(0, (int)&v36) )
      {
        a1 = HIDWORD(v37);
        if ( v37 == v35 )
        {
          a1 = HIDWORD(v36);
          if ( v36 == v21 )
            v8 = 1;
        }
      }
      BYTE2(v17) = v8;
    }
    if ( BYTE2(v17) )
    {
      if ( !v19 )
      {
        v19 = sub_804C001(a1, (int)&v18);
        a1 = 8 * i;
        v13 = v19 + 9;
        v12 = v18;
        v11 = 1;
        sub_8051642(8 * i + a3, 0);
      }
      *(_DWORD *)(8 * i + a3) = v19 + 9;
      *(_DWORD *)(a3 + 8 * i + 4) = v19;
    }
  }
  return result;
}
// 8051642: using guessed type int __cdecl sub_8051642(_DWORD, _DWORD);
// 806129D: using guessed type int __userpurge sub_806129D@<eax>(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, double@<st0>);
// 806A298: using guessed type int dword_806A298;

//----- (08052DBF) --------------------------------------------------------
unsigned int __cdecl sub_8052DBF(int a1, unsigned int a2)
{
  bool v2; // zf
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  char *v6; // ebx
  char *v7; // eax
  unsigned int result; // eax
  unsigned int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a2 )
      break;
    if ( strcmp(*(const char **)(4 * i + a1), "-") )
    {
      v2 = euidaccess(*(_DWORD *)(4 * i + a1), 4) == 0;
      v5 = &loc_8052E37;
      if ( v2 )
        v5 = &loc_8052E60;
      dword_806A25C = (int)v5;
      sub_806141F(v4, v3);
      v6 = *(char **)(4 * i + a1);
      v7 = gettext("cannot read");
      sub_804B11E((int)v7, v6);
    }
  }
  return result;
}
// 8049E00: using guessed type int __cdecl euidaccess(_DWORD, _DWORD);
// 806141F: using guessed type int __fastcall sub_806141F(_DWORD, _DWORD);
// 806A25C: using guessed type int dword_806A25C;

//----- (08052E76) --------------------------------------------------------
void __cdecl sub_8052E76(char *a1)
{
  char *v1; // eax
  int fd; // [esp+1Ch] [ebp-Ch]

  if ( a1 )
  {
    fd = open64(a1, 524353);
    if ( fd < 0 )
    {
      v1 = gettext("open failed");
      sub_804B11E((int)v1, a1);
    }
    sub_804BCB4(fd, 1);
  }
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);

//----- (08052EDC) --------------------------------------------------------
void __usercall sub_8052EDC(int a1@<edx>, int a2@<ecx>, FILE *a3@<ebx>, double a4@<st0>, int a5, int a6, int a7, char *s1)
{
  int v8; // eax
  int v9; // esi
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  char *v15; // eax
  char *v16; // ebx
  char *v17; // eax
  int v18; // eax
  int v19; // eax
  int v20; // [esp+0h] [ebp-78h]
  _BOOL4 v21; // [esp+4h] [ebp-74h]
  unsigned int v22; // [esp+8h] [ebp-70h]
  FILE *v23; // [esp+Ch] [ebp-6Ch]
  int v24; // [esp+10h] [ebp-68h]
  void *ptr; // [esp+28h] [ebp-50h]
  FILE *v26; // [esp+2Ch] [ebp-4Ch]
  int v27; // [esp+30h] [ebp-48h]
  unsigned int v28; // [esp+34h] [ebp-44h]
  int v29; // [esp+38h] [ebp-40h]
  int v30; // [esp+3Ch] [ebp-3Ch]
  unsigned int v31; // [esp+40h] [ebp-38h]
  int v32; // [esp+44h] [ebp-34h]
  unsigned int v33; // [esp+48h] [ebp-30h]
  unsigned int v34; // [esp+4Ch] [ebp-2Ch]
  int v35; // [esp+50h] [ebp-28h]
  unsigned int v36; // [esp+54h] [ebp-24h]
  FILE *stream; // [esp+58h] [ebp-20h]
  int v38; // [esp+5Ch] [ebp-1Ch]
  int v39; // [esp+84h] [ebp+Ch]

  while ( dword_806A388 < (unsigned int)a7 )
  {
    v27 = 0;
    v28 = 0;
    dword_806A270 = (int)&loc_8052FC6;
    sub_80613B3(a2, a1, v20, v21, v22, v23);
    do
    {
      v8 = sub_804C001((int)a3, (int)&v26);
      v30 = v8;
      v9 = v8 + 9;
      a3 = v26;
      v10 = a6;
      if ( dword_806A388 <= (unsigned int)a6 )
        v10 = dword_806A388;
      v24 = v9;
      v23 = v26;
      v22 = dword_806A388;
      v20 = 8 * v27 + a5;
      v31 = sub_8051642(v20, v10);
      v11 = a6;
      if ( v31 <= a6 )
        v11 = v31;
      a6 -= v11;
      *(_DWORD *)(8 * v28 + a5) = v30 + 9;
      *(_DWORD *)(a5 + 8 * v28 + 4) = v30;
      v27 += v31;
      ++v28;
    }
    while ( a7 - v27 >= (unsigned int)dword_806A388 );
    v32 = a7 - v27;
    v33 = dword_806A388 - v28 % dword_806A388;
    if ( dword_806A388 - v28 % dword_806A388 < a7 - v27 )
    {
      v34 = v32 - v33 + 1;
      v35 = sub_804C001(dword_806A388, (int)&v26);
      v12 = a6;
      if ( v34 <= a6 )
        v12 = v34;
      v24 = v35 + 9;
      v23 = v26;
      v22 = v34;
      v20 = 8 * v27 + a5;
      v36 = sub_8051642(v20, v12);
      v13 = a6;
      if ( v36 <= a6 )
        v13 = v36;
      a6 -= v13;
      *(_DWORD *)(8 * v28 + a5) = v35 + 9;
      v14 = v28++;
      *(_DWORD *)(a5 + 8 * v14 + 4) = v35;
      v27 += v36;
    }
    a3 = (FILE *)(8 * v28);
    memmove((void *)(8 * v28 + a5), (const void *)(a5 + 8 * v27), 8 * (a7 - v27));
    a6 += v28;
    a1 = v28 - v27;
    a7 += v28 - v27;
  }
  sub_8052B3F((int)a3, a4, a5, a6, a7, s1);
  while ( 1 )
  {
    v29 = sub_8050AB2(a4, a5, a7, &ptr);
    if ( v29 == a7 )
      break;
    if ( (unsigned int)v29 <= 2 )
    {
      v16 = *(char **)(8 * v29 + a5);
      v17 = gettext("open failed");
      sub_804B11E((int)v17, v16);
    }
    do
    {
LABEL_27:
      --v29;
      sub_804BC0D(*((FILE **)ptr + v29), *(_DWORD *)(8 * v29 + a5));
      v21 = (unsigned int)v29 > 2;
      v38 = sub_804BE77((int)a3, (int)&v26, v21);
    }
    while ( !v38 );
    a3 = (FILE *)(v38 + 9);
    v18 = a6;
    if ( v29 <= (unsigned int)a6 )
      v18 = v29;
    sub_8050BA6(a5, v18, v29, v26, v38 + 9, ptr);
    v19 = a6;
    if ( v29 <= (unsigned int)a6 )
      v19 = v29;
    v39 = a6 - v19;
    *(_DWORD *)a5 = v38 + 9;
    *(_DWORD *)(a5 + 4) = v38;
    memmove((void *)(a5 + 8), (const void *)(a5 + 8 * v29), 8 * (a7 - v29));
    a6 = v39 + 1;
    a7 = a7 - v29 + 1;
  }
  stream = sub_804BA5E(s1, "w");
  if ( !stream )
  {
    if ( *__errno_location() != 24 || (unsigned int)v29 <= 2 )
    {
      v15 = gettext("open failed");
      sub_804B11E((int)v15, s1);
    }
    goto LABEL_27;
  }
  sub_8050BA6(a5, a6, a7, stream, (int)s1, ptr);
}
// 8051642: using guessed type int __cdecl sub_8051642(_DWORD, _DWORD);
// 806A270: using guessed type int dword_806A270;
// 806A384: using guessed type int dword_806A384;
// 806A388: using guessed type int dword_806A388;

//----- (0805338B) --------------------------------------------------------
unsigned int __usercall sub_805338B@<eax>(FILE *a1@<ebx>, double a2@<st0>, char **a3, unsigned int a4, char *a5, unsigned int a6)
{
  int v6; // eax
  char *v7; // edx
  int v8; // ecx
  int v10; // [esp+0h] [ebp-E8h]
  char *v11; // [esp+28h] [ebp-C0h]
  char **v12; // [esp+2Ch] [ebp-BCh]
  char v13; // [esp+3Fh] [ebp-A9h]
  FILE *stream; // [esp+40h] [ebp-A8h]
  FILE *v15; // [esp+44h] [ebp-A4h]
  int v16; // [esp+48h] [ebp-A0h]
  int v17; // [esp+4Ch] [ebp-9Ch]
  int v18; // [esp+50h] [ebp-98h]
  unsigned int v19; // [esp+54h] [ebp-94h]
  int v20; // [esp+58h] [ebp-90h]
  int *v21; // [esp+5Ch] [ebp-8Ch]
  int v22; // [esp+60h] [ebp-88h]
  char *s1; // [esp+64h] [ebp-84h]
  int v24; // [esp+68h] [ebp-80h]
  pthread_mutex_t *v25; // [esp+6Ch] [ebp-7Ch]
  void *v26; // [esp+70h] [ebp-78h]
  void *ptr; // [esp+74h] [ebp-74h]
  int v28; // [esp+78h] [ebp-70h]
  unsigned int v29; // [esp+7Ch] [ebp-6Ch]
  int v30; // [esp+80h] [ebp-68h]
  int v31; // [esp+84h] [ebp-64h]
  char v32; // [esp+8Ch] [ebp-5Ch]
  char v33; // [esp+90h] [ebp-58h]
  unsigned int v34; // [esp+DCh] [ebp-Ch]

  v12 = a3;
  v11 = a5;
  v34 = __readgsdword(0x14u);
  v16 = 0;
  v13 = 0;
  v30 = 0;
  while ( a4 )
  {
    s1 = *v12;
    stream = sub_804BBCC(s1, "r");
    if ( a6 <= 1 )
    {
      v18 = 24;
    }
    else
    {
      v19 = 1;
      v20 = 1;
      while ( v19 < a6 )
      {
        v19 *= 2;
        ++v20;
      }
      v18 = 16 * v20;
    }
    if ( !v30 )
    {
      v6 = sub_804CE70(a2, (int)&stream, 1u, (int)v12, a4, v18);
      sub_804D085((int)&ptr, v18, v6);
    }
    v32 = 0;
    ++v12;
    --a4;
    while ( (unsigned __int8)sub_804D489((int)&ptr, stream, (int)s1) )
    {
      if ( v32 && a4 && v18 + 1 < v30 - v28 - v18 * v29 )
      {
        v31 = v28;
        dword_806A25C = (int)&loc_80536AA;
        sub_806141F(v18 + 1, v30 - v28 - v18 * v29);
      }
      dword_806A9A8 = 0;
      v24 = sub_804D130(&ptr);
      if ( !v32 || a4 || v16 || v31 )
      {
        ++v16;
        v17 = sub_804C001((int)a1, (int)&v15) + 9;
      }
      else
      {
        sub_804BC0D(stream, (int)s1);
        v15 = sub_804BBCC(v11, "w");
        v17 = (int)v11;
        v13 = 1;
      }
      if ( v29 <= 1 )
        sub_80520C6(v24 - 16, v15, v17);
      sub_8051FAD((int)&v33, a6);
      v25 = sub_8051B57(a6, v29, v24);
      a1 = (FILE *)&v25[3];
      sub_80528D6(v24, a6, v29, &v25[3], &v10 - 22, v15, v17);
      sub_804BC0D(v15, v17);
      if ( v13 )
        goto LABEL_28;
    }
    sub_804BC0D(stream, (int)s1);
  }
LABEL_28:
  free(ptr);
  if ( v13 != 1 )
  {
    v21 = (int *)dword_806AE5C;
    v26 = sub_805E01B(v16, 8u);
    v22 = 0;
    while ( v21 )
    {
      *((_DWORD *)v26 + 2 * v22) = (char *)v21 + 9;
      v7 = (char *)v26 + 8 * v22;
      *((_DWORD *)v7 + 1) = v21;
      v21 = (int *)*v21;
      ++v22;
    }
    sub_8052EDC((int)v7, v8, a1, a2, (int)v26, v16, v16, v11);
    free(v26);
  }
  sub_804B79B();
  return __readgsdword(0x14u) ^ v34;
}
// 80528D6: using guessed type _DWORD __cdecl sub_80528D6(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806141F: using guessed type int __fastcall sub_806141F(_DWORD, _DWORD);
// 806A25C: using guessed type int dword_806A25C;
// 806A9A8: using guessed type int dword_806A9A8;
// 806AE5C: using guessed type int dword_806AE5C;

//----- (080537D2) --------------------------------------------------------
_DWORD *__cdecl sub_80537D2(void *src)
{
  _DWORD *result; // eax
  int *i; // [esp+18h] [ebp-10h]
  _DWORD *v3; // [esp+1Ch] [ebp-Ch]

  v3 = sub_805E22A(src, 0x28u);
  for ( i = &dword_806ADD0; *i; i = (int *)(*i + 36) )
    ;
  *i = (int)v3;
  result = v3;
  v3[9] = 0;
  return result;
}
// 806ADD0: using guessed type int dword_806ADD0;

//----- (0805381F) --------------------------------------------------------
void __cdecl __noreturn sub_805381F(int a1, char *msgid)
{
  void *v2; // esi
  char *v3; // ebx
  char *v4; // eax

  v2 = sub_805B7F5(a1);
  v3 = gettext(msgid);
  v4 = gettext("%s: invalid field specification %s");
  error(2, 0, v4, v3, v2);
  sub_805386D(a1);
}

//----- (0805386D) --------------------------------------------------------
void __cdecl __noreturn sub_805386D(int a1)
{
  char *v1; // eax
  int v2; // edx
  int v3; // ecx

  v1 = gettext("options '-%s' are incompatible");
  error(2, 0, v1, a1);
  sub_805389E(v3, v2);
}

//----- (0805389E) --------------------------------------------------------
int __fastcall __noreturn sub_805389E(int a1, int a2)
{
  void *v2; // eax
  int v3; // ecx
  int (*v4)(); // eax
  int v6; // [esp+0h] [ebp-48h]
  int v7; // [esp+4h] [ebp-44h]
  int v8; // [esp+8h] [ebp-40h]
  int v9; // [esp+Ch] [ebp-3Ch]
  unsigned int v10; // [esp+3Ch] [ebp-Ch]

  v10 = __readgsdword(0x14u);
  v2 = &loc_805399E;
  if ( dword_806ADD0 )
    v2 = &loc_80538BC;
  dword_806A270 = (int)v2;
  sub_80613B3(a1, a2, v6, v7, v8, v9);
  v4 = (int (*)())&loc_80539D3;
  if ( __readgsdword(0x14u) == v10 )
    v4 = sub_80539D8;
  dword_806A2CC = (int)v4;
  return sub_8061134(v3);
}
// 805389E: could not find valid save-restore pair for ebx
// 80539D8: using guessed type int sub_80539D8();
// 8061134: using guessed type int __fastcall sub_8061134(_DWORD);
// 806A270: using guessed type int dword_806A270;
// 806A2CC: using guessed type int dword_806A2CC;
// 806ADD0: using guessed type int dword_806ADD0;

//----- (080539D8) --------------------------------------------------------
#error "80539D9: positive sp value has been found (funcsize=0)"

//----- (080539DA) --------------------------------------------------------
#error "8053AD4: call analysis failed (funcsize=76)"

//----- (08053AE7) --------------------------------------------------------
int __cdecl sub_8053AE7(int sig)
{
  sub_804B7BA();
  signal(sig, 0);
  return raise(sig);
}

//----- (08053B12) --------------------------------------------------------
_BYTE *__usercall sub_8053B12@<eax>(int a1@<edx>, int a2@<ecx>, _BYTE *a3, int a4, int a5)
{
  void *v5; // eax
  _BYTE *result; // eax

  while ( 2 )
  {
    if ( !*a3 )
      return a3;
    switch ( *a3 )
    {
      case 77:
        *(_BYTE *)(a4 + 30) = 1;
        goto LABEL_24;
      case 82:
        *(_BYTE *)(a4 + 27) = 1;
        goto LABEL_24;
      case 86:
        *(_BYTE *)(a4 + 32) = 1;
        goto LABEL_24;
      case 98:
        if ( !a5 || a5 == 2 )
          *(_BYTE *)(a4 + 24) = 1;
        if ( a5 != 1 )
        {
          v5 = &loc_8053B70;
          if ( a5 != 2 )
            v5 = &loc_8053B79;
          dword_806A248 = (int)v5;
          sub_8061491(a2, a1);
        }
        *(_BYTE *)(a4 + 25) = 1;
        goto LABEL_24;
      case 100:
        *(_DWORD *)(a4 + 16) = &unk_806ABBC;
        goto LABEL_24;
      case 102:
        *(_DWORD *)(a4 + 20) = byte_806ACBC;
        goto LABEL_24;
      case 103:
        *(_BYTE *)(a4 + 28) = 1;
        goto LABEL_24;
      case 104:
        *(_BYTE *)(a4 + 29) = 1;
        goto LABEL_24;
      case 105:
        if ( !*(_DWORD *)(a4 + 16) )
          *(_DWORD *)(a4 + 16) = &unk_806AABC;
        goto LABEL_24;
      case 110:
        *(_BYTE *)(a4 + 26) = 1;
        goto LABEL_24;
      case 114:
        *(_BYTE *)(a4 + 31) = 1;
LABEL_24:
        ++a3;
        continue;
      default:
        result = a3;
        break;
    }
    return result;
  }
}
// 8061491: using guessed type int __fastcall sub_8061491(_DWORD, _DWORD);
// 806A248: using guessed type int dword_806A248;

//----- (08053C06) --------------------------------------------------------
void *__cdecl sub_8053C06(void *s)
{
  memset(s, 0, 0x28u);
  *((_DWORD *)s + 2) = -1;
  return s;
}

//----- (08053C36) --------------------------------------------------------
void __usercall __noreturn main(double a1@<st0>, int argc, char **argv)
{
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  unsigned __int8 v6; // al
  unsigned __int8 v7; // al
  int v8; // edx
  int *v9; // ecx
  void *v10; // eax
  int v11; // eax
  int v12; // edx
  int v13; // ecx
  bool v14; // zf
  void *v15; // eax
  int v16; // eax
  int v17; // eax
  void *v18; // ebx
  char *v19; // eax
  void *v20; // ebx
  char *v21; // eax
  int v22; // edx
  int v23; // ecx
  void *v24; // ebx
  char *v25; // eax
  void *v26; // ebx
  char *v27; // eax
  void *v28; // ebx
  char *v29; // eax
  int v30; // [esp+0h] [ebp-17Ch]
  int v31; // [esp+4h] [ebp-178h]
  char *v32; // [esp+8h] [ebp-174h]
  void *v33; // [esp+Ch] [ebp-170h]
  unsigned int v34; // [esp+10h] [ebp-16Ch]
  int v35; // [esp+14h] [ebp-168h]
  int v36; // [esp+18h] [ebp-164h]
  int v37; // [esp+1Ch] [ebp-160h]
  int v38; // [esp+20h] [ebp-15Ch]
  int v39; // [esp+24h] [ebp-158h]
  int v40; // [esp+28h] [ebp-154h]
  int v41; // [esp+2Ch] [ebp-150h]
  bool v42; // [esp+30h] [ebp-14Ch]
  char v43; // [esp+31h] [ebp-14Bh]
  bool v44; // [esp+32h] [ebp-14Ah]
  bool v45; // [esp+34h] [ebp-148h]
  int j; // [esp+38h] [ebp-144h]
  int v47; // [esp+3Ch] [ebp-140h]
  int v48; // [esp+40h] [ebp-13Ch]
  int v49; // [esp+44h] [ebp-138h]
  int v50; // [esp+48h] [ebp-134h]
  unsigned int v51; // [esp+4Ch] [ebp-130h]
  int *v52; // [esp+50h] [ebp-12Ch]
  char *v53; // [esp+54h] [ebp-128h]
  int v54; // [esp+58h] [ebp-124h]
  unsigned int i; // [esp+5Ch] [ebp-120h]
  int v56; // [esp+60h] [ebp-11Ch]
  unsigned int v57; // [esp+64h] [ebp-118h]
  int v58; // [esp+68h] [ebp-114h]
  int v59; // [esp+6Ch] [ebp-110h]
  struct lconv *v60; // [esp+70h] [ebp-10Ch]
  int v61; // [esp+74h] [ebp-108h]
  FILE *v62; // [esp+78h] [ebp-104h]
  unsigned int v63; // [esp+7Ch] [ebp-100h]
  int v64; // [esp+80h] [ebp-FCh]
  int v65; // [esp+84h] [ebp-F8h]
  int v66; // [esp+88h] [ebp-F4h]
  char s; // [esp+B8h] [ebp-C4h]
  int v68; // [esp+C8h] [ebp-B4h]
  int v69; // [esp+CCh] [ebp-B0h]
  char v70; // [esp+D0h] [ebp-ACh]
  char v71; // [esp+D1h] [ebp-ABh]
  char v72; // [esp+D2h] [ebp-AAh]
  unsigned __int8 v73; // [esp+D3h] [ebp-A9h]
  char v74; // [esp+D4h] [ebp-A8h]
  char v75; // [esp+D5h] [ebp-A7h]
  char v76; // [esp+D6h] [ebp-A6h]
  char v77; // [esp+D7h] [ebp-A5h]
  char v78; // [esp+D8h] [ebp-A4h]
  int longind; // [esp+E0h] [ebp-9Ch]
  int *v80; // [esp+E4h] [ebp-98h]
  int v81; // [esp+164h] [ebp-18h]

  *(_WORD *)((char *)&v41 + 1) = 0;
  v48 = 0;
  HIBYTE(v41) = 0;
  v49 = 0;
  v42 = 0;
  v50 = 0;
  v51 = 0;
  v45 = getenv("POSIXLY_CORRECT") != 0;
  v59 = sub_8059AB9(a1);
  if ( v59 > 200111 )
  {
    v5 = &loc_8053CD4;
    if ( v59 <= 200808 )
      v5 = &loc_8053CDB;
    dword_806A270 = (int)v5;
    sub_80613B3(v4, v3, v30, v31, v32, v33);
  }
  v43 = 1;
  v53 = 0;
  v54 = 0;
  sub_8059B30(*argv);
  v44 = setlocale(6, &::s) != 0;
  bindtextdomain("coreutils", "/home/hwangdz/coreutils/coreutils-8.28/install_m32/share/locale");
  textdomain("coreutils");
  sub_804AD5A(2);
  byte_806A9A4 = sub_8057340(3);
  byte_806A9A5 = sub_8057340(2);
  v60 = localeconv();
  v30 = *v60->decimal_point;
  v6 = sub_804AD6D(v30);
  dword_806A99C = v6;
  if ( !v6 || v60->decimal_point[1] )
    dword_806A99C = 46;
  v30 = *v60->thousands_sep;
  v7 = sub_804AD6D(v30);
  dword_806A9A0 = v7;
  if ( !v7 || v60->thousands_sep[1] )
    dword_806A9A0 = -1;
  byte_806ADCF = 0;
  sub_804C3DF();
  sigemptyset(&set);
  dword_806A20C = (int)&loc_8053E83;
  sub_80615ED(
    v30,
    v31,
    v32,
    v33,
    v34,
    v35,
    v36,
    v37,
    v38,
    v39,
    v40,
    v41,
    *(_DWORD *)&v42,
    *(_DWORD *)&v45,
    j,
    v47,
    v48,
    v49,
    v50,
    v51,
    v52,
    v53,
    v54,
    0,
    v56,
    v57,
    v58,
    v59,
    v60,
    v61,
    v62,
    v63,
    v64,
    v65,
    v66);
  while ( 1 )
  {
    sigaction(sig[i], 0, (struct sigaction *)&longind);
    if ( longind != 1 )
      sigaddset(&set, sig[i]);
    if ( ++i > 0xA )
    {
      longind = (int)sub_8053AE7;
      qmemcpy(&v80, &set, 0x80u);
      v81 = 0;
      for ( i = 0; i <= 0xA; ++i )
      {
        v31 = sig[i];
        if ( sigismember(&set, v31) )
          sigaction(sig[i], (const struct sigaction *)&longind, 0);
      }
      signal(17, 0);
      sub_806104D((int)sub_804B7F2);
      sub_8053C06(&s);
      *(_DWORD *)&s = -1;
      v52 = (int *)sub_805E01B(argc, 4u);
      while ( 1 )
      {
        longind = -1;
        if ( v48 != -1 )
        {
          v10 = &loc_8053FAB;
          if ( !v45 )
            v10 = &loc_8054044;
          dword_806A298 = (int)v10;
          sub_806129D(
            v30,
            v31,
            v32,
            v33,
            v34,
            v35,
            v36,
            v37,
            v38,
            v39,
            v40,
            v41,
            *(_DWORD *)&v42,
            *(_DWORD *)&v45,
            j,
            v47,
            v48,
            v49,
            v50,
            v51,
            v52,
            v53,
            v54,
            i,
            v56,
            v57,
            v58,
            a1);
          if ( !v51
            || v43 == 1
            && !BYTE2(v41)
            && optind != argc
            && (v8 = 4 * optind, *argv[optind] == 45)
            && (v8 = 4 * optind, argv[optind][1] == 111)
            && ((v8 = 4 * optind, argv[optind][2]) || optind + 1 != argc) )
          {
            v11 = getopt_long(argc, argv, "-bcCdfghik:mMno:rRsS:t:T:uVy:z", &longopts, &longind);
            v48 = v11;
            v14 = v11 == -1;
            v15 = &loc_8054095;
            if ( !v14 )
              v15 = &loc_80540FB;
            dword_806A270 = (int)v15;
            sub_80613B3(v13, v12, v30, v31, v32, v33);
          }
        }
        if ( argc <= optind )
        {
          if ( v53 )
          {
            if ( v51 )
            {
              v31 = *v52;
              v18 = sub_805B3A8(4, v31);
              v19 = gettext("extra operand %s");
              v33 = v18;
              error(0, 0, v19, v18);
              v32 = gettext("file operands cannot be combined with --files0-from");
              fprintf(stderr, "%s\n", v32);
              sub_804B180(2);
            }
            v62 = sub_804BBCC(v53, "r");
            sub_805C975(&longind);
            if ( (unsigned __int8)sub_805CD33(v62, (int)&longind) ^ 1 )
            {
              v20 = sub_805B3A8(4, (int)v53);
              v21 = gettext("cannot read file names from %s");
              v33 = v20;
              error(2, 0, v21);
            }
            sub_804BC0D(v62, (int)v53);
            if ( longind )
            {
              free(v52);
              v52 = v80;
              v51 = longind;
              v57 = 0;
              dword_806A234 = (int)&loc_8054D59;
              sub_8061505(v23, v22, v30, v31);
              do
              {
                if ( !strcmp((const char *)v52[v57], "-") )
                {
                  v31 = v52[v57];
                  v24 = sub_805B3A8(4, v31);
                  v25 = gettext("when reading file names from stdin, no file name of %s allowed");
                  v33 = v24;
                  error(2, 0, v25, v24);
                }
                v8 = 4 * v57;
                if ( !*(_BYTE *)v52[v57] )
                {
                  v63 = v57 + 1;
                  v26 = sub_805B533(0, 3, (int)v53);
                  v27 = gettext("%s:%lu: invalid zero-length file name");
                  v34 = v63;
                  v33 = v26;
                  error(2, 0, v27, v26, v63);
                }
                ++v57;
              }
              while ( v57 < v51 );
            }
            else
            {
              v28 = sub_805B3A8(4, (int)v53);
              v29 = gettext("no input from %s");
              v33 = v28;
              error(2, 0, v29, v28);
            }
          }
          for ( j = dword_806ADD0; j; j = *(_DWORD *)(j + 36) )
          {
            if ( (unsigned __int8)sub_804EB67(j) && *(_BYTE *)(j + 31) != 1 )
            {
              *(_DWORD *)(j + 16) = v68;
              *(_DWORD *)(j + 20) = v69;
              *(_BYTE *)(j + 24) = v70;
              *(_BYTE *)(j + 25) = v71;
              *(_BYTE *)(j + 30) = v76;
              *(_BYTE *)(j + 26) = v72;
              *(_BYTE *)(j + 28) = v74;
              *(_BYTE *)(j + 29) = v75;
              *(_BYTE *)(j + 32) = v78;
              *(_BYTE *)(j + 27) = v73;
              *(_BYTE *)(j + 31) = v77;
            }
            v8 = v42;
            v42 = (v42 | *(unsigned __int8 *)(j + 27)) != 0;
          }
          if ( !dword_806ADD0 )
          {
            if ( (unsigned __int8)sub_804EB67(&s) ^ 1 )
            {
              BYTE1(v41) = 1;
              sub_80537D2(&s);
              v8 = v42;
              v42 = (v42 | v73) != 0;
            }
          }
          sub_805389E((int)v9, v8);
        }
        v16 = v51++;
        v9 = &v52[v16];
        v17 = optind++;
        v8 = 4 * v17;
        *v9 = (int)argv[v17];
      }
    }
  }
}
// 804C3DF: using guessed type int sub_804C3DF(void);
// 804EB67: using guessed type _DWORD __cdecl sub_804EB67(_DWORD);
// 806129D: using guessed type int __userpurge sub_806129D@<eax>(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, double@<st0>);
// 80615ED: using guessed type int __stdcall sub_80615ED(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806A20C: using guessed type int dword_806A20C;
// 806A234: using guessed type int dword_806A234;
// 806A270: using guessed type int dword_806A270;
// 806A298: using guessed type int dword_806A298;
// 806A440: using guessed type int optind;
// 806A99C: using guessed type int dword_806A99C;
// 806A9A0: using guessed type int dword_806A9A0;
// 806A9A4: using guessed type char byte_806A9A4;
// 806A9A5: using guessed type char byte_806A9A5;
// 806ADCF: using guessed type char byte_806ADCF;
// 806ADD0: using guessed type int dword_806ADD0;

//----- (0805537D) --------------------------------------------------------
void __noreturn sub_805537D()
{
  sub_804B180(1);
}

//----- (08055391) --------------------------------------------------------
#error "8055454: call analysis failed (funcsize=72)"

//----- (080554DA) --------------------------------------------------------
void __cdecl sub_80554DA(int a1, int a2, int a3)
{
  char *v3; // eax
  char *format; // ST2C_4
  void *v5; // ebx
  void *v6; // eax

  if ( a3 == -1 )
    v3 = gettext("invalid argument %s for %s");
  else
    v3 = gettext("ambiguous argument %s for %s");
  format = v3;
  v5 = sub_805B7D3(1, a1);
  v6 = sub_805B32D(0, 8, a2);
  error(0, 0, format, v6, v5);
}

//----- (0805555D) --------------------------------------------------------
#error "80555CC: call analysis failed (funcsize=84)"

//----- (080556AE) --------------------------------------------------------
signed int __cdecl sub_80556AE(int a1, char *s, int a3, int a4, size_t a5, void (*a6)(void))
{
  int v7; // [esp+1Ch] [ebp-10h]

  v7 = sub_8055391(s, a3, a4, a5);
  if ( v7 >= 0 )
    return v7;
  sub_80554DA(a1, (int)s, v7);
  sub_805555D(a3, a4, a5);
  a6();
  return -1;
}
// 805555D: using guessed type _DWORD __cdecl sub_805555D(_DWORD, _DWORD, _DWORD);

//----- (080557CE) --------------------------------------------------------
#error "80557FA: call analysis failed (funcsize=68)"

//----- (080558E0) --------------------------------------------------------
_DWORD *__cdecl sub_80558E0(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 1732584193;
  a1[1] = -271733879;
  a1[2] = -1732584194;
  a1[3] = 271733878;
  a1[5] = 0;
  a1[4] = a1[5];
  result = a1;
  a1[6] = 0;
  return result;
}

//----- (0805593C) --------------------------------------------------------
_DWORD *__cdecl sub_805593C(_DWORD *a1, int a2)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = a2;
  return result;
}

//----- (08055949) --------------------------------------------------------
_DWORD *__cdecl sub_8055949(int *a1, _DWORD *a2)
{
  sub_805593C(a2, *a1);
  sub_805593C(a2 + 1, a1[1]);
  sub_805593C(a2 + 2, a1[2]);
  sub_805593C(a2 + 3, a1[3]);
  return a2;
}

//----- (080559C6) --------------------------------------------------------
_DWORD *__usercall sub_80559C6@<eax>(double a1@<st0>, int *a2, _DWORD *a3)
{
  unsigned int v4; // [esp+18h] [ebp-10h]

  v4 = a2[6];
  if ( v4 <= 0x37 )
  {
    dword_806A2AC = (int)&loc_80559FC;
    sub_8061223(a1);
  }
  a2[4] += v4;
  if ( a2[4] < v4 )
    ++a2[5];
  a2[37] = 8 * a2[4];
  a2[38] = *((_QWORD *)a2 + 2) >> 29;
  memcpy((char *)a2 + v4 + 28, &unk_8063B18, 120 - v4);
  sub_8055F66(a2 + 7, 0x80u, a2);
  return sub_8055949(a2, a3);
}
// 8061223: using guessed type int __usercall sub_8061223@<eax>(double@<st0>);
// 806A2AC: using guessed type int dword_806A2AC;

//----- (08055CEE) --------------------------------------------------------
#error "8055D13: call analysis failed (funcsize=182)"

//----- (08055F66) --------------------------------------------------------
int *__cdecl sub_8055F66(int *a1, unsigned int a2, int *a3)
{
  int v3; // ST30_4
  int v4; // ST34_4
  int v5; // ST38_4
  int v6; // ST3C_4
  int *v7; // ST0C_4
  int v8; // ST10_4
  int v9; // ST1C_4
  int v10; // ST18_4
  int v11; // ST14_4
  int v12; // ST10_4
  int v13; // ST1C_4
  int v14; // ST18_4
  int v15; // ST14_4
  int v16; // ST10_4
  int v17; // ST1C_4
  int v18; // ST18_4
  int v19; // ST14_4
  int v20; // ST10_4
  int v21; // ST1C_4
  int v22; // ST18_4
  int v23; // ST14_4
  int v24; // ST10_4
  int v25; // ST1C_4
  int v26; // ST18_4
  int v27; // ST14_4
  int v28; // ST10_4
  int v29; // ST1C_4
  int v30; // ST18_4
  int v31; // ST14_4
  int v32; // ST10_4
  int v33; // ST1C_4
  int v34; // ST18_4
  int v35; // ST14_4
  int v36; // ST10_4
  int v37; // ST1C_4
  int v38; // ST18_4
  int v39; // ST14_4
  int v40; // ST10_4
  int v41; // ST1C_4
  int v42; // ST18_4
  int v43; // ST14_4
  int v44; // ST10_4
  int v45; // ST1C_4
  int v46; // ST18_4
  int v47; // ST14_4
  int v48; // ST10_4
  int v49; // ST1C_4
  int v50; // ST18_4
  int v51; // ST14_4
  int v52; // ST10_4
  int v53; // ST1C_4
  int v54; // ST18_4
  int v55; // ST14_4
  int v56; // ST10_4
  int v57; // ST1C_4
  int v58; // ST18_4
  int v59; // ST14_4
  int v60; // ST10_4
  int v61; // ST1C_4
  int v62; // ST18_4
  int v63; // ST14_4
  int v64; // ST10_4
  int v65; // ST1C_4
  int v66; // ST18_4
  int v67; // ST14_4
  int v68; // ST10_4
  int v69; // ST1C_4
  int v70; // ST18_4
  int v71; // ST14_4
  int *result; // eax
  int *v73; // [esp+Ch] [ebp-74h]
  int v74; // [esp+10h] [ebp-70h]
  int v75; // [esp+14h] [ebp-6Ch]
  int v76; // [esp+18h] [ebp-68h]
  int v77; // [esp+1Ch] [ebp-64h]
  int v78; // [esp+40h] [ebp-40h]
  int v79; // [esp+44h] [ebp-3Ch]
  int v80; // [esp+48h] [ebp-38h]
  int v81; // [esp+4Ch] [ebp-34h]
  int v82; // [esp+50h] [ebp-30h]
  int v83; // [esp+54h] [ebp-2Ch]
  int v84; // [esp+58h] [ebp-28h]
  int v85; // [esp+5Ch] [ebp-24h]
  int v86; // [esp+60h] [ebp-20h]
  int v87; // [esp+64h] [ebp-1Ch]
  int v88; // [esp+68h] [ebp-18h]
  int v89; // [esp+6Ch] [ebp-14h]
  int v90; // [esp+70h] [ebp-10h]
  int v91; // [esp+74h] [ebp-Ch]
  int v92; // [esp+78h] [ebp-8h]
  int v93; // [esp+7Ch] [ebp-4h]

  v73 = a1;
  v74 = *a3;
  v75 = a3[1];
  v76 = a3[2];
  v77 = a3[3];
  a3[4] += a2;
  a3[5] += a3[4] < a2;
  while ( v73 < &a1[a2 >> 2] )
  {
    v3 = v74;
    v4 = v75;
    v5 = v76;
    v6 = v77;
    v78 = *v73;
    v7 = v73 + 1;
    v8 = v75 + __ROR4__((v77 ^ v75 & (v76 ^ v77)) + v78 + v74 - 680876936, 25);
    v79 = *v7;
    ++v7;
    v9 = v8 + __ROR4__((v76 ^ v8 & (v75 ^ v76)) + v79 + v77 - 389564586, 20);
    v80 = *v7;
    ++v7;
    v10 = v9 + __ROR4__((v75 ^ v9 & (v8 ^ v75)) + v80 + v76 + 606105819, 15);
    v81 = *v7;
    ++v7;
    v11 = v10 + __ROR4__((v8 ^ v10 & (v9 ^ v8)) + v81 + v75 - 1044525330, 10);
    v82 = *v7;
    ++v7;
    v12 = v11 + __ROR4__((v9 ^ v11 & (v10 ^ v9)) + v82 + v8 - 176418897, 25);
    v83 = *v7;
    ++v7;
    v13 = v12 + __ROR4__((v10 ^ v12 & (v11 ^ v10)) + v83 + v9 + 1200080426, 20);
    v84 = *v7;
    ++v7;
    v14 = v13 + __ROR4__((v11 ^ v13 & (v12 ^ v11)) + v84 + v10 - 1473231341, 15);
    v85 = *v7;
    ++v7;
    v15 = v14 + __ROR4__((v12 ^ v14 & (v13 ^ v12)) + v85 + v11 - 45705983, 10);
    v86 = *v7;
    ++v7;
    v16 = v15 + __ROR4__((v13 ^ v15 & (v14 ^ v13)) + v86 + v12 + 1770035416, 25);
    v87 = *v7;
    ++v7;
    v17 = v16 + __ROR4__((v14 ^ v16 & (v15 ^ v14)) + v87 + v13 - 1958414417, 20);
    v88 = *v7;
    ++v7;
    v18 = v17 + __ROR4__((v15 ^ v17 & (v16 ^ v15)) + v88 + v14 - 42063, 15);
    v89 = *v7;
    ++v7;
    v19 = v18 + __ROR4__((v16 ^ v18 & (v17 ^ v16)) + v89 + v15 - 1990404162, 10);
    v90 = *v7;
    ++v7;
    v20 = v19 + __ROR4__((v17 ^ v19 & (v18 ^ v17)) + v90 + v16 + 1804603682, 25);
    v91 = *v7;
    ++v7;
    v21 = v20 + __ROR4__((v18 ^ v20 & (v19 ^ v18)) + v91 + v17 - 40341101, 20);
    v92 = *v7;
    ++v7;
    v22 = v21 + __ROR4__((v19 ^ v21 & (v20 ^ v19)) + v92 + v18 - 1502002290, 15);
    v93 = *v7;
    v73 = v7 + 1;
    v23 = v22 + __ROR4__((v20 ^ v22 & (v21 ^ v20)) + v93 + v19 + 1236535329, 10);
    v24 = v23 + __ROR4__(v79 + (v22 ^ v21 & (v23 ^ v22)) + v20 - 165796510, 27);
    v25 = v24 + __ROR4__(v84 + (v23 ^ v22 & (v24 ^ v23)) + v21 - 1069501632, 23);
    v26 = v25 + __ROR4__(v89 + (v24 ^ v23 & (v25 ^ v24)) + v22 + 643717713, 18);
    v27 = v26 + __ROR4__(v78 + (v25 ^ v24 & (v26 ^ v25)) + v23 - 373897302, 12);
    v28 = v27 + __ROR4__(v83 + (v26 ^ v25 & (v27 ^ v26)) + v24 - 701558691, 27);
    v29 = v28 + __ROR4__(v88 + (v27 ^ v26 & (v28 ^ v27)) + v25 + 38016083, 23);
    v30 = v29 + __ROR4__(v93 + (v28 ^ v27 & (v29 ^ v28)) + v26 - 660478335, 18);
    v31 = v30 + __ROR4__(v82 + (v29 ^ v28 & (v30 ^ v29)) + v27 - 405537848, 12);
    v32 = v31 + __ROR4__(v87 + (v30 ^ v29 & (v31 ^ v30)) + v28 + 568446438, 27);
    v33 = v32 + __ROR4__(v92 + (v31 ^ v30 & (v32 ^ v31)) + v29 - 1019803690, 23);
    v34 = v33 + __ROR4__(v81 + (v32 ^ v31 & (v33 ^ v32)) + v30 - 187363961, 18);
    v35 = v34 + __ROR4__(v86 + (v33 ^ v32 & (v34 ^ v33)) + v31 + 1163531501, 12);
    v36 = v35 + __ROR4__(v91 + (v34 ^ v33 & (v35 ^ v34)) + v32 - 1444681467, 27);
    v37 = v36 + __ROR4__(v80 + (v35 ^ v34 & (v36 ^ v35)) + v33 - 51403784, 23);
    v38 = v37 + __ROR4__(v85 + (v36 ^ v35 & (v37 ^ v36)) + v34 + 1735328473, 18);
    v39 = v38 + __ROR4__(v90 + (v37 ^ v36 & (v38 ^ v37)) + v35 - 1926607734, 12);
    v40 = v39 + __ROR4__(v83 + (v37 ^ v39 ^ v38) + v36 - 378558, 28);
    v41 = v40 + __ROR4__(v86 + (v38 ^ v40 ^ v39) + v37 - 2022574463, 21);
    v42 = v41 + __ROR4__(v89 + (v39 ^ v41 ^ v40) + v38 + 1839030562, 16);
    v43 = v42 + __ROR4__(v92 + (v40 ^ v42 ^ v41) + v39 - 35309556, 9);
    v44 = v43 + __ROR4__(v79 + (v41 ^ v43 ^ v42) + v40 - 1530992060, 28);
    v45 = v44 + __ROR4__(v82 + (v42 ^ v44 ^ v43) + v41 + 1272893353, 21);
    v46 = v45 + __ROR4__(v85 + (v43 ^ v45 ^ v44) + v42 - 155497632, 16);
    v47 = v46 + __ROR4__(v88 + (v44 ^ v46 ^ v45) + v43 - 1094730640, 9);
    v48 = v47 + __ROR4__(v91 + (v45 ^ v47 ^ v46) + v44 + 681279174, 28);
    v49 = v48 + __ROR4__(v78 + (v46 ^ v48 ^ v47) + v45 - 358537222, 21);
    v50 = v49 + __ROR4__(v81 + (v47 ^ v49 ^ v48) + v46 - 722521979, 16);
    v51 = v50 + __ROR4__(v84 + (v48 ^ v50 ^ v49) + v47 + 76029189, 9);
    v52 = v51 + __ROR4__(v87 + (v49 ^ v51 ^ v50) + v48 - 640364487, 28);
    v53 = v52 + __ROR4__(v90 + (v50 ^ v52 ^ v51) + v49 - 421815835, 21);
    v54 = v53 + __ROR4__(v93 + (v51 ^ v53 ^ v52) + v50 + 530742520, 16);
    v55 = v54 + __ROR4__(v80 + (v52 ^ v54 ^ v53) + v51 - 995338651, 9);
    v56 = v55 + __ROR4__(v78 + (v54 ^ (v55 | ~v53)) + v52 - 198630844, 26);
    v57 = v56 + __ROR4__(v85 + (v55 ^ (v56 | ~v54)) + v53 + 1126891415, 22);
    v58 = v57 + __ROR4__(v92 + (v56 ^ (v57 | ~v55)) + v54 - 1416354905, 17);
    v59 = v58 + __ROR4__(v83 + (v57 ^ (v58 | ~v56)) + v55 - 57434055, 11);
    v60 = v59 + __ROR4__(v90 + (v58 ^ (v59 | ~v57)) + v56 + 1700485571, 26);
    v61 = v60 + __ROR4__(v81 + (v59 ^ (v60 | ~v58)) + v57 - 1894986606, 22);
    v62 = v61 + __ROR4__(v88 + (v60 ^ (v61 | ~v59)) + v58 - 1051523, 17);
    v63 = v62 + __ROR4__(v79 + (v61 ^ (v62 | ~v60)) + v59 - 2054922799, 11);
    v64 = v63 + __ROR4__(v86 + (v62 ^ (v63 | ~v61)) + v60 + 1873313359, 26);
    v65 = v64 + __ROR4__(v93 + (v63 ^ (v64 | ~v62)) + v61 - 30611744, 22);
    v66 = v65 + __ROR4__(v84 + (v64 ^ (v65 | ~v63)) + v62 - 1560198380, 17);
    v67 = v66 + __ROR4__(v91 + (v65 ^ (v66 | ~v64)) + v63 + 1309151649, 11);
    v68 = v67 + __ROR4__(v82 + (v66 ^ (v67 | ~v65)) + v64 - 145523070, 26);
    v69 = v68 + __ROR4__(v89 + (v67 ^ (v68 | ~v66)) + v65 - 1120210379, 22);
    v70 = v69 + __ROR4__(v80 + (v68 ^ (v69 | ~v67)) + v66 + 718787259, 17);
    v71 = v70 + __ROR4__(v87 + (v69 ^ (v70 | ~v68)) + v67 - 343485551, 11);
    v74 = v3 + v68;
    v75 = v4 + v71;
    v76 = v5 + v70;
    v77 = v6 + v69;
  }
  *a3 = v74;
  a3[1] = v75;
  a3[2] = v76;
  result = a3;
  a3[3] = v77;
  return result;
}

//----- (08056C60) --------------------------------------------------------
int __cdecl sub_8056C60(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // [esp+20h] [ebp-28h]
  int v8; // [esp+24h] [ebp-24h]
  int v9; // [esp+28h] [ebp-20h]
  int v10; // [esp+2Ch] [ebp-1Ch]

  v9 = a2;
  v10 = a3;
  v7 = a4;
  v8 = a5;
  return posix_fadvise64(a1, a2, a3, a4, a5, a6);
}
// 8049E60: using guessed type int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (08056CC1) --------------------------------------------------------
void __cdecl sub_8056CC1(FILE *stream, int a2)
{
  int v2; // eax

  if ( stream )
  {
    v2 = fileno(stream);
    sub_8056C60(v2, 0, 0, 0, 0, a2);
  }
}

//----- (08056D09) --------------------------------------------------------
int __usercall sub_8056D09@<eax>(double a1@<st0>, _BYTE **a2)
{
  void *v2; // eax

  v2 = &loc_8056DF0;
  if ( **a2 )
    v2 = &loc_8056D1F;
  dword_806A2AC = (int)v2;
  sub_8061223(a1);
  return 0;
}
// 8061223: using guessed type int __usercall sub_8061223@<eax>(double@<st0>);
// 806A2AC: using guessed type int dword_806A2AC;

//----- (08056DF5) --------------------------------------------------------
int __usercall sub_8056DF5@<eax>(int a1@<edx>, int a2@<ecx>, double a3@<st0>, unsigned __int8 a4)
{
  if ( (unsigned __int8)sub_805FE45(a1, a2, a4) )
    return 0;
  if ( (unsigned __int8)sub_805FD65(a3, a4) )
    return a4;
  if ( a4 == 126 )
    return -1;
  return a4 + 256;
}

//----- (08056E46) --------------------------------------------------------
signed int __cdecl sub_8056E46(int a1, unsigned int a2, int a3, unsigned int a4)
{
  int v4; // ecx
  bool v5; // zf
  int v6; // edx
  int v7; // ecx
  void *v8; // eax
  int v9; // edx
  int v10; // ecx
  void *v11; // eax
  int v12; // ecx
  void *v13; // eax
  int v14; // ecx
  int v15; // ecx
  int v17; // [esp+0h] [ebp-38h]
  int v18; // [esp+0h] [ebp-38h]
  int v19; // [esp+4h] [ebp-34h]
  int v20; // [esp+8h] [ebp-30h]
  unsigned int v21; // [esp+1Ch] [ebp-1Ch]
  unsigned int v22; // [esp+20h] [ebp-18h]
  int v23; // [esp+24h] [ebp-14h]

  v21 = 0;
  v22 = 0;
  while ( v21 < a2 || v22 < a4 )
  {
    v23 = 0;
    if ( v21 < a2 )
    {
      v5 = (unsigned __int8)sub_805FE45(a1, v4, *(char *)(a1 + v21)) == 1;
      v8 = &loc_8056F15;
      if ( !v5 )
        v8 = &loc_8056E68;
      dword_806A284 = (int)v8;
      sub_806132A(v7, v6, v17, v19, v20);
    }
    if ( v22 < a4 )
    {
      v5 = (unsigned __int8)sub_805FE45(a3, v4, *(char *)(a3 + v22)) == 1;
      v11 = &loc_8056F53;
      if ( !v5 )
        v11 = &loc_8056E68;
      dword_806A284 = (int)v11;
      sub_806132A(v10, v9, v18, v19, v20);
    }
    while ( *(_BYTE *)(a1 + v21) == 48 )
      ++v21;
    while ( *(_BYTE *)(a3 + v22) == 48 )
      ++v22;
    while ( 1 )
    {
      v5 = (unsigned __int8)sub_805FE45(a1, v4, *(char *)(a1 + v21)) == 0;
      v13 = &loc_8056FF3;
      if ( v5 )
        v13 = &loc_8057011;
      dword_806A2CC = (int)v13;
      sub_8061134(v12);
      if ( !(unsigned __int8)sub_805FE45(a3, v14, *(char *)(a3 + v22)) )
        break;
      if ( !v23 )
      {
        v4 = a3;
        v23 = *(char *)(a1 + v21) - *(char *)(a3 + v22);
      }
      ++v21;
      ++v22;
    }
    if ( (unsigned __int8)sub_805FE45(a1, v4, *(char *)(a1 + v21)) )
      return 1;
    if ( (unsigned __int8)sub_805FE45(a3, v15, *(char *)(a3 + v22)) )
      return -1;
    if ( v23 )
      return v23;
  }
  return 0;
}
// 8056E46: could not find valid save-restore pair for ebx
// 8061134: using guessed type int __fastcall sub_8061134(_DWORD);
// 806A284: using guessed type int dword_806A284;
// 806A2CC: using guessed type int dword_806A2CC;

//----- (0805707D) --------------------------------------------------------
int __cdecl sub_805707D(char *s1, char *s2)
{
  bool v2; // zf
  int v3; // ecx
  void *v4; // eax

  v2 = strcmp(s1, s2) == 0;
  v4 = &loc_80570C7;
  if ( !v2 )
    v4 = &loc_80570D1;
  dword_806A2CC = (int)v4;
  sub_8061134(v3);
  return 0;
}
// 8061134: using guessed type int __fastcall sub_8061134(_DWORD);
// 806A2CC: using guessed type int dword_806A2CC;

//----- (08057340) --------------------------------------------------------
int __cdecl sub_8057340(int category)
{
  unsigned __int8 v2; // [esp+1Bh] [ebp-Dh]
  const char *s1; // [esp+1Ch] [ebp-Ch]

  v2 = 1;
  s1 = setlocale(category, 0);
  if ( s1 && (!strcmp(s1, "C") || !strcmp(s1, "POSIX")) )
    v2 = 0;
  return v2;
}

//----- (0805739E) --------------------------------------------------------
int __cdecl sub_805739E(int a1)
{
  return *(_DWORD *)(a1 + 8);
}

//----- (080573A9) --------------------------------------------------------
int __cdecl sub_80573A9(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (080573B4) --------------------------------------------------------
int __cdecl sub_80573B4(int a1)
{
  return *(_DWORD *)(a1 + 16);
}

//----- (080573BF) --------------------------------------------------------
unsigned int __usercall sub_80573BF@<eax>(int a1@<edx>, int a2@<ecx>, int a3)
{
  _DWORD *i; // [esp+0h] [ebp-10h]
  unsigned int v5; // [esp+4h] [ebp-Ch]
  _DWORD *v6; // [esp+8h] [ebp-8h]
  unsigned int v7; // [esp+Ch] [ebp-4h]

  v5 = 0;
  for ( i = *(_DWORD **)a3; *(_DWORD *)(a3 + 4) > (unsigned int)i; i += 2 )
  {
    if ( *i )
    {
      v6 = i;
      v7 = 1;
      dword_806A25C = (int)&loc_8057407;
      sub_806141F(a2, a1);
      do
      {
        ++v7;
        v6 = (_DWORD *)v6[1];
      }
      while ( v6 );
      if ( v7 > v5 )
        v5 = v7;
    }
  }
  return v5;
}
// 806141F: using guessed type int __fastcall sub_806141F(_DWORD, _DWORD);
// 806A25C: using guessed type int dword_806A25C;

//----- (0805759D) --------------------------------------------------------
int __cdecl sub_805759D(_DWORD *a1, int a2)
{
  int (__cdecl *v2)(int, int); // eax
  int v4; // [esp+4h] [ebp-24h]
  unsigned int v5; // [esp+1Ch] [ebp-Ch]

  v2 = (int (__cdecl *)(int, int))a1[6];
  v4 = a1[2];
  v5 = v2(a2, v4);
  if ( a1[2] <= v5 )
    abort();
  return 8 * v5 + *a1;
}

//----- (08057926) --------------------------------------------------------
bool __cdecl sub_8057926(unsigned int a1)
{
  int v1; // ST08_4
  unsigned int v3; // [esp+8h] [ebp-8h]
  unsigned int v4; // [esp+Ch] [ebp-4h]

  v3 = 3;
  v4 = 9;
  while ( v4 < a1 && a1 % v3 )
  {
    v1 = v3 + 1;
    v4 += 4 * v1;
    v3 = v1 + 1;
  }
  return a1 % v3 != 0;
}

//----- (0805797D) --------------------------------------------------------
int __cdecl sub_805797D(unsigned int a1)
{
  int i; // [esp+Ch] [ebp+8h]

  if ( a1 <= 9 )
    a1 = 10;
  for ( i = a1 | 1; i != -1 && !sub_8057926(i); i += 2 )
    ;
  return i;
}

//----- (080579FE) --------------------------------------------------------
unsigned int __cdecl sub_80579FE(int a1, unsigned int a2)
{
  return sub_805FBF5(a1, 3) % a2;
}

//----- (08057A29) --------------------------------------------------------
bool __cdecl sub_8057A29(int a1, int a2)
{
  return a1 == a2;
}

//----- (08057A37) --------------------------------------------------------
signed int __usercall sub_8057A37@<eax>(double a1@<st0>, int a2)
{
  int v3; // [esp+8h] [ebp-8h]

  v3 = *(_DWORD *)(a2 + 20);
  if ( (_UNKNOWN *)v3 == &unk_8063B68 )
  {
    dword_806A2AC = (int)&locret_8057B03;
    sub_8061223(a1);
  }
  if ( *(float *)(v3 + 8) > 0.1
    && 1.0 - 0.1 > *(float *)(v3 + 8)
    && *(float *)(v3 + 12) > 0.1 + 1.0
    && *(float *)v3 >= 0.0
    && *(float *)(v3 + 4) > *(float *)v3 + 0.1
    && *(float *)(v3 + 4) <= 1.0
    && *(float *)(v3 + 8) > *(float *)v3 + 0.1 )
  {
    return 1;
  }
  *(_DWORD *)(a2 + 20) = &unk_8063B68;
  return 0;
}
// 8061223: using guessed type int __usercall sub_8061223@<eax>(double@<st0>);
// 806A2AC: using guessed type int dword_806A2AC;

//----- (08057B05) --------------------------------------------------------
unsigned int __cdecl sub_8057B05(unsigned int a1, int a2)
{
  unsigned int result; // eax
  float v3; // [esp+20h] [ebp-4h]
  unsigned int v4; // [esp+2Ch] [ebp+8h]

  if ( *(_BYTE *)(a2 + 16) != 1 )
  {
    v3 = (long double)a1 / *(float *)(a2 + 8);
    if ( v3 >= 4294967300.0 )
      return 0;
    a1 = (signed __int64)v3;
  }
  v4 = sub_805797D(a1);
  if ( v4 <= 0x1FFFFFFF )
    result = v4;
  else
    result = 0;
  return result;
}

//----- (08057BB2) --------------------------------------------------------
#error "8057C2D: call analysis failed (funcsize=43)"

//----- (08057F3C) --------------------------------------------------------
void *__cdecl sub_8057F3C(int a1)
{
  int v2; // [esp+1Ch] [ebp-Ch]

  if ( !*(_DWORD *)(a1 + 36) )
    return malloc(8u);
  v2 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(v2 + 4);
  return (void *)v2;
}

//----- (08057F77) --------------------------------------------------------
int __cdecl sub_8057F77(int a1, _DWORD *a2)
{
  int result; // eax

  *a2 = 0;
  a2[1] = *(_DWORD *)(a1 + 36);
  result = a1;
  *(_DWORD *)(a1 + 36) = a2;
  return result;
}

//----- (08057FAA) --------------------------------------------------------
int __usercall sub_8057FAA@<eax>(double a1@<st0>, int a2, int a3, _DWORD *a4, char a5)
{
  int result; // eax
  void *v6; // eax
  _DWORD *v7; // ST34_4
  int v8; // edx
  _DWORD *v9; // ST2C_4
  _DWORD *i; // [esp+18h] [ebp-20h]
  _DWORD *v11; // [esp+1Ch] [ebp-1Ch]
  int v12; // [esp+20h] [ebp-18h]
  int v13; // [esp+28h] [ebp-10h]

  v11 = (_DWORD *)sub_805759D((_DWORD *)a2, a3);
  *a4 = v11;
  if ( !*v11 )
    return 0;
  v6 = &loc_8058009;
  if ( *v11 == a3 )
    v6 = &loc_8058024;
  dword_806A2AC = (int)v6;
  sub_8061223(a1);
  if ( (*(unsigned __int8 (__cdecl **)(int, _DWORD))(a2 + 28))(a3, *v11) )
  {
    v13 = *v11;
    if ( a5 )
    {
      if ( v11[1] )
      {
        v7 = (_DWORD *)v11[1];
        v8 = v7[1];
        *v11 = *v7;
        v11[1] = v8;
        sub_8057F77(a2, v7);
      }
      else
      {
        *v11 = 0;
      }
    }
    result = v13;
  }
  else
  {
    for ( i = v11; ; i = (_DWORD *)i[1] )
    {
      if ( !i[1] )
        return 0;
      if ( *(_DWORD *)i[1] == a3 || (*(unsigned __int8 (__cdecl **)(int, _DWORD))(a2 + 28))(a3, *(_DWORD *)i[1]) )
        break;
    }
    v12 = *(_DWORD *)i[1];
    if ( a5 )
    {
      v9 = (_DWORD *)i[1];
      i[1] = v9[1];
      sub_8057F77(a2, v9);
    }
    result = v12;
  }
  return result;
}
// 8061223: using guessed type int __usercall sub_8061223@<eax>(double@<st0>);
// 806A2AC: using guessed type int dword_806A2AC;

//----- (0805812B) --------------------------------------------------------
signed int __cdecl sub_805812B(_DWORD *a1, int a2, char a3)
{
  int v3; // edx
  int v4; // ecx
  int v6; // [esp+0h] [ebp-38h]
  int v7; // [esp+4h] [ebp-34h]
  int v8; // [esp+8h] [ebp-30h]
  int *i; // [esp+18h] [ebp-20h]
  int *j; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+20h] [ebp-18h]
  int *v13; // [esp+24h] [ebp-14h]
  int *v14; // [esp+24h] [ebp-14h]
  int *v15; // [esp+28h] [ebp-10h]
  _DWORD *v16; // [esp+2Ch] [ebp-Ch]

  for ( i = *(int **)a2; *(_DWORD *)(a2 + 4) > (unsigned int)i; i += 2 )
  {
    if ( *i )
    {
      for ( j = (int *)i[1]; j; j = v15 )
      {
        v11 = *j;
        v13 = (int *)sub_805759D(a1, *j);
        v15 = (int *)j[1];
        if ( *v13 )
        {
          j[1] = v13[1];
          v13[1] = (int)j;
        }
        else
        {
          *v13 = v11;
          ++a1[3];
          sub_8057F77((int)a1, j);
        }
      }
      v12 = *i;
      i[1] = 0;
      if ( !a3 )
      {
        v14 = (int *)sub_805759D(a1, v12);
        if ( *v14 )
        {
          v16 = sub_8057F3C((int)a1);
          if ( !v16 )
          {
            dword_806A284 = (int)&locret_80582CF;
            sub_806132A(v4, v3, v6, v7, v8);
          }
          *v16 = v12;
          v16[1] = v14[1];
          v14[1] = (int)v16;
        }
        else
        {
          *v14 = v12;
          ++a1[3];
        }
        *i = 0;
        --*(_DWORD *)(a2 + 12);
      }
    }
  }
  return 1;
}
// 806A284: using guessed type int dword_806A284;

//----- (080582D1) --------------------------------------------------------
#error "80584A1: call analysis failed (funcsize=142)"

//----- (080584BF) --------------------------------------------------------
#error "80584DF: call analysis failed (funcsize=14)"

//----- (080584E9) --------------------------------------------------------
#error "80587CF: positive sp value has been found (funcsize=47)"

//----- (080587D0) --------------------------------------------------------
void __cdecl __noreturn sub_80587D0(int a1, int a2)
{
  sub_80584BF(a1, a2);
}
// 80584BF: using guessed type void __cdecl __noreturn sub_80584BF(_DWORD, _DWORD);

//----- (0805880F) --------------------------------------------------------
int __usercall sub_805880F@<eax>(double a1@<st0>, int a2, int a3)
{
  int v3; // eax
  int v4; // edx
  int v5; // ecx
  bool v6; // zf
  void *v7; // eax
  int v9; // [esp+0h] [ebp-48h]
  int v10; // [esp+4h] [ebp-44h]
  int v11; // [esp+8h] [ebp-40h]
  int v12; // [esp+Ch] [ebp-3Ch]
  int v13; // [esp+28h] [ebp-20h]
  int v14; // [esp+30h] [ebp-18h]

  v3 = sub_8057FAA(a1, a2, a3, &v13, 1);
  v14 = v3;
  v6 = v3 == 0;
  v7 = &loc_8058868;
  if ( !v6 )
    v7 = &loc_8058872;
  dword_806A270 = (int)v7;
  sub_80613B3(v5, v4, v9, v10, v11, v12);
  return 0;
}
// 806A270: using guessed type int dword_806A270;

//----- (08058A59) --------------------------------------------------------
_DWORD *__cdecl sub_8058A59(int (*a1)(), unsigned int a2)
{
  int (*v2)(); // eax
  _DWORD *v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_805E128(0x10u);
  if ( !a2 )
    a2 = 1;
  *v4 = sub_805E01B(a2, 4u);
  *(_DWORD *)*v4 = 0;
  v4[1] = a2;
  v4[2] = 0;
  if ( a1 )
    v2 = a1;
  else
    v2 = sub_8058ADE;
  v4[3] = v2;
  return v4;
}

//----- (08058ADE) --------------------------------------------------------
int sub_8058ADE()
{
  return 0;
}

//----- (08058AE8) --------------------------------------------------------
void __cdecl sub_8058AE8(void *ptr)
{
  free(*(void **)ptr);
  free(ptr);
}

//----- (08058B08) --------------------------------------------------------
int __cdecl sub_8058B08(int a1, int a2)
{
  _DWORD *v2; // edx

  if ( (unsigned int)(*(_DWORD *)(a1 + 4) - 1) <= *(_DWORD *)(a1 + 8) )
    *(_DWORD *)a1 = sub_805E07E(*(void **)a1, a1 + 4, 4);
  v2 = *(_DWORD **)a1;
  v2[++*(_DWORD *)(a1 + 8)] = a2;
  sub_8058D7F(*(_DWORD *)a1, *(_DWORD *)(a1 + 8), *(int (__cdecl **)(int, int))(a1 + 12));
  return 0;
}

//----- (08058BA1) --------------------------------------------------------
#error "8058C09: call analysis failed (funcsize=44)"

//----- (08058C45) --------------------------------------------------------
#error "8058C56: call analysis failed (funcsize=12)"

//----- (08058C69) --------------------------------------------------------
unsigned int __cdecl sub_8058C69(int a1, unsigned int a2, int a3, int (__cdecl *a4)(int))
{
  int v4; // ecx
  int v5; // ST1C_4
  int v7; // [esp+0h] [ebp-28h]
  int v8; // [esp+4h] [ebp-24h]
  unsigned int v9; // [esp+10h] [ebp-18h]
  unsigned int v10; // [esp+14h] [ebp-14h]
  int v11; // [esp+18h] [ebp-10h]
  int v12; // [esp+24h] [ebp-4h]
  int retaddr; // [esp+28h] [ebp+0h]

  v5 = *(_DWORD *)(4 * (_DWORD)a4 + a2);
  dword_806A234 = (int)&loc_8058D58;
  sub_8061505(v4, 4 * (_DWORD)a4, v7, v8);
  do
  {
    v10 = 2 * v9;
    if ( 2 * v9 < a2 )
    {
      retaddr = *(_DWORD *)(4 * (v10 + 1) + a1);
      if ( a4(*(_DWORD *)(8 * v9 + a1)) < 0 )
        ++v10;
    }
    retaddr = v11;
    v12 = *(_DWORD *)(4 * v10 + a1);
    if ( a4(v12) <= 0 )
      break;
    *(_DWORD *)(a1 + 4 * v9) = *(_DWORD *)(4 * v10 + a1);
    v9 = v10;
  }
  while ( a2 >> 1 >= v10 );
  *(_DWORD *)(a1 + 4 * v9) = v11;
  return v9;
}
// 8058C69: could not find valid save-restore pair for ebp
// 806A234: using guessed type int dword_806A234;

//----- (08058D7F) --------------------------------------------------------
int __cdecl sub_8058D7F(int a1, unsigned int a2, int (__cdecl *a3)(int, int))
{
  int result; // eax
  int v4; // [esp+0h] [ebp-28h]
  unsigned int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]

  v5 = a2;
  v6 = *(_DWORD *)(4 * a2 + a1);
  while ( v5 != 1 )
  {
    v4 = *(_DWORD *)(4 * (v5 >> 1) + a1);
    if ( a3(v4, v6) > 0 )
      break;
    *(_DWORD *)(a1 + 4 * v5) = *(_DWORD *)(4 * (v5 >> 1) + a1);
    v5 >>= 1;
  }
  result = v6;
  *(_DWORD *)(a1 + 4 * v5) = v6;
  return result;
}

//----- (08058E3F) --------------------------------------------------------
#error "8058EE0: call analysis failed (funcsize=94)"

//----- (08058F52) --------------------------------------------------------
int __cdecl sub_8058F52(unsigned int a1, int a2)
{
  int v3; // [esp+Ch] [ebp-4h]

  v3 = a2 + 10;
  *(_BYTE *)(a2 + 10) = 0;
  do
  {
    *(_BYTE *)--v3 = a1 % 0xA + 48;
    a1 /= 0xAu;
  }
  while ( a1 );
  return v3;
}

//----- (08058FC0) --------------------------------------------------------
int __cdecl sub_8058FC0(unsigned __int64 a1, int a2)
{
  unsigned __int64 v2; // rax
  unsigned __int64 v4; // [esp+18h] [ebp-20h]
  int v5; // [esp+2Ch] [ebp-Ch]

  v4 = a1;
  v5 = a2 + 20;
  *(_BYTE *)(a2 + 20) = 0;
  do
  {
    *(_BYTE *)--v5 = sub_8060E13(v4, 0xAu, 0) + 48;
    LODWORD(v2) = sub_8060CC0(v4, SHIDWORD(v4), 0xAu, 0);
    v4 = v2;
  }
  while ( v2 );
  return v5;
}

//----- (08059093) --------------------------------------------------------
#error "805934A: call analysis failed (funcsize=226)"

//----- (0805939C) --------------------------------------------------------
int sub_805939C()
{
  int result; // eax
  int v1; // [esp+1Ch] [ebp-8Ch]
  char v2; // [esp+20h] [ebp-88h]

  if ( sched_getaffinity(0, 128, &v2) || (v1 = __sched_cpucount(128, &v2)) == 0 )
    result = 0;
  else
    result = v1;
  return result;
}
// 80498D0: using guessed type int __cdecl __sched_cpucount(_DWORD, _DWORD);
// 8049E70: using guessed type int __cdecl sched_getaffinity(_DWORD, _DWORD, _DWORD);

//----- (080593FB) --------------------------------------------------------
#error "805941B: call analysis failed (funcsize=57)"

//----- (080594BB) --------------------------------------------------------
#error "80594FA: call analysis failed (funcsize=92)"

//----- (080595D3) --------------------------------------------------------
unsigned int __cdecl sub_80595D3(signed int a1)
{
  char *v1; // eax
  char *v2; // eax
  int v3; // edx
  int v4; // ecx
  unsigned int result; // eax
  int v6; // [esp+0h] [ebp-28h]
  int v7; // [esp+4h] [ebp-24h]
  int v8; // [esp+8h] [ebp-20h]
  int v9; // [esp+Ch] [ebp-1Ch]
  unsigned int v10; // [esp+14h] [ebp-14h]
  int v11; // [esp+18h] [ebp-10h]

  v10 = -1;
  if ( a1 == 2 )
  {
    v1 = getenv("OMP_NUM_THREADS");
    v11 = sub_80594BB(v1);
    v2 = getenv("OMP_THREAD_LIMIT");
    v10 = sub_80594BB(v2);
    if ( !v10 )
      v10 = -1;
    if ( v11 )
    {
      dword_806A270 = (int)&locret_8059667;
      sub_80613B3(v4, v3, v6, v7, v8, v9);
    }
    a1 = 1;
  }
  result = sub_80593FB(a1);
  if ( v10 <= result )
    result = v10;
  return result;
}
// 80593FB: using guessed type _DWORD __cdecl sub_80593FB(_DWORD);
// 806A270: using guessed type int dword_806A270;

//----- (08059669) --------------------------------------------------------
long double sub_8059669()
{
  long double v1; // fst7
  int v2; // [esp+4h] [ebp-74h]
  __int64 v3; // [esp+8h] [ebp-70h]
  double v4; // [esp+18h] [ebp-60h]
  double v5; // [esp+20h] [ebp-58h]
  char v6; // [esp+2Ch] [ebp-4Ch]
  unsigned int v7; // [esp+3Ch] [ebp-3Ch]
  unsigned int v8; // [esp+60h] [ebp-18h]
  unsigned int v9; // [esp+6Ch] [ebp-Ch]

  v9 = __readgsdword(0x14u);
  v4 = (long double)sysconf(85);
  v2 = sysconf(30);
  v5 = (long double)v2;
  if ( v4 >= 0.0 && v5 >= 0.0 )
    return v4 * v5;
  if ( !sysinfo((struct sysinfo *)&v6) )
  {
    v3 = v8;
    v1 = (long double)v7 * (long double)v8;
    dword_806A2AC = (int)&loc_8059726;
    sub_8061223(*(double *)&v1);
  }
  return 67108864.0;
}
// 8061223: using guessed type int __usercall sub_8061223@<eax>(double@<st0>);
// 806A2AC: using guessed type int dword_806A2AC;

//----- (0805973B) --------------------------------------------------------
long double sub_805973B()
{
  double v1; // [esp+18h] [ebp-60h]
  double v2; // [esp+20h] [ebp-58h]
  char v3; // [esp+2Ch] [ebp-4Ch]
  unsigned int v4; // [esp+40h] [ebp-38h]
  unsigned int v5; // [esp+48h] [ebp-30h]
  unsigned int v6; // [esp+60h] [ebp-18h]
  unsigned int v7; // [esp+6Ch] [ebp-Ch]

  v7 = __readgsdword(0x14u);
  v1 = (long double)sysconf(86);
  v2 = (long double)sysconf(30);
  if ( v1 >= 0.0 && v2 >= 0.0 )
    return v1 * v2;
  if ( sysinfo((struct sysinfo *)&v3) )
    return sub_8059669() / 4.0;
  return ((long double)v4 + (long double)v5) * (long double)v6;
}

//----- (08059812) --------------------------------------------------------
int __usercall sub_8059812@<eax>(double a1@<st0>, int pipedes[2], int a3)
{
  void *v4; // eax
  int v5; // edx
  int v6; // ecx
  int v7; // ecx
  int v8; // eax
  int v9; // edx
  int v10; // ecx
  int v11; // ecx
  int v12; // eax
  bool v13; // zf
  int v14; // edx
  int v15; // ecx
  void *v16; // eax
  int v17; // edx
  int v18; // ecx
  int v19; // ecx
  int v20; // edx
  int v21; // ecx
  int v22; // ecx
  int v23; // ST2C_4
  int v24; // [esp+18h] [ebp-20h]
  int v25; // [esp+1Ch] [ebp-1Ch]
  int v26; // [esp+1Ch] [ebp-1Ch]
  int v27; // [esp+20h] [ebp-18h]
  int v28; // [esp+20h] [ebp-18h]
  int v29; // [esp+28h] [ebp-10h]
  int v30; // [esp+2Ch] [ebp-Ch]

  v29 = *pipedes;
  v30 = pipedes[1];
  if ( dword_806AF28 >= 0 )
  {
    v24 = pipe2(pipedes, a3);
    if ( v24 >= 0 || *__errno_location() != 38 )
    {
      dword_806AF28 = 1;
      return v24;
    }
    dword_806AF28 = -1;
  }
  if ( a3 & 0xFFF7F7FF )
  {
    *__errno_location() = 22;
    dword_806A2AC = (int)&locret_8059AB7;
    sub_8061223(a1);
  }
  if ( pipe(pipedes) < 0 )
    return -1;
  v4 = &loc_80598F6;
  if ( !(a3 & 0x800) )
    v4 = &loc_80599B9;
  dword_806A2AC = (int)v4;
  sub_8061223(a1);
  v25 = sub_805F16B(v5, v6, pipedes[1], 3, 0);
  if ( v25 < 0 )
    goto LABEL_26;
  v8 = v25;
  BYTE1(v8) |= 8u;
  if ( sub_805F16B(v8, v7, pipedes[1], 4, v8) == -1 )
    goto LABEL_26;
  v26 = sub_805F16B(v9, v10, *pipedes, 3, 0);
  if ( v26 < 0 )
    goto LABEL_26;
  v12 = v26;
  BYTE1(v12) |= 8u;
  v13 = sub_805F16B(v12, v11, *pipedes, 4, v12) == -1;
  v16 = &loc_80599B9;
  if ( v13 )
    v16 = &loc_8059A6E;
  dword_806A248 = (int)v16;
  sub_8061491(v15, v14);
  if ( !(a3 & 0x80000) )
    return 0;
  v27 = sub_805F16B(v17, v18, pipedes[1], 1, 0);
  if ( v27 >= 0 && sub_805F16B(v27 | 1, v19, pipedes[1], 2, v27 | 1) != -1 )
  {
    v28 = sub_805F16B(v20, v21, *pipedes, 1, 0);
    if ( v28 >= 0 && sub_805F16B(v28 | 1, v22, *pipedes, 2, v28 | 1) != -1 )
      return 0;
  }
LABEL_26:
  v23 = *__errno_location();
  close(*pipedes);
  close(pipedes[1]);
  *pipedes = v29;
  pipedes[1] = v30;
  *__errno_location() = v23;
  return -1;
}
// 8059812: could not find valid save-restore pair for ebx
// 8049DF0: using guessed type int __cdecl pipe2(_DWORD, _DWORD);
// 8061223: using guessed type int __usercall sub_8061223@<eax>(double@<st0>);
// 8061491: using guessed type int __fastcall sub_8061491(_DWORD, _DWORD);
// 806A248: using guessed type int dword_806A248;
// 806A2AC: using guessed type int dword_806A2AC;
// 806AF28: using guessed type int dword_806AF28;

//----- (08059AB9) --------------------------------------------------------
int __usercall sub_8059AB9@<eax>(double a1@<st0>)
{
  void *v1; // eax
  char *endptr; // [esp+10h] [ebp-18h]
  int v4; // [esp+14h] [ebp-14h]
  char *nptr; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]

  v4 = 200809;
  nptr = getenv("_POSIX2_VERSION");
  if ( nptr )
  {
    v1 = &loc_8059AFE;
    if ( !*nptr )
      v1 = &loc_8059B2B;
    dword_806A2AC = (int)v1;
    sub_8061223(a1);
    v6 = strtol(nptr, &endptr, 10);
    if ( !*endptr )
      v4 = v6;
  }
  return v4;
}
// 8061223: using guessed type int __usercall sub_8061223@<eax>(double@<st0>);
// 806A2AC: using guessed type int dword_806A2AC;

//----- (08059B30) --------------------------------------------------------
char *__cdecl sub_8059B30(char *s)
{
  int v1; // ecx
  char *v2; // eax
  int v3; // ST04_4
  void *v4; // eax
  char *result; // eax
  char *v6; // [esp+18h] [ebp-10h]
  char *s1; // [esp+1Ch] [ebp-Ch]

  if ( !s )
  {
    fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
    abort();
  }
  v6 = strrchr(s, 47);
  if ( v6 )
    v2 = v6 + 1;
  else
    v2 = s;
  s1 = v2;
  v3 = v2 - s;
  v4 = &loc_8059BC8;
  if ( v3 <= 6 )
    v4 = &loc_8059C20;
  dword_806A2CC = (int)v4;
  sub_8061134(v1);
  if ( !strncmp(s1 - 7, "/.libs/", 7u) )
  {
    s = s1;
    if ( !strncmp(s1, "lt-", 3u) )
    {
      s = s1 + 3;
      program_invocation_short_name = (int)(s1 + 3);
    }
  }
  dword_806AF2C = (int)s;
  result = s;
  program_invocation_name = (int)s;
  return result;
}
// 8061134: using guessed type int __fastcall sub_8061134(_DWORD);
// 806A2CC: using guessed type int dword_806A2CC;
// 806A420: using guessed type int program_invocation_short_name;
// 806A430: using guessed type int program_invocation_name;
// 806AF2C: using guessed type int dword_806AF2C;

//----- (08059CA5) --------------------------------------------------------
int __cdecl sub_8059CA5(int *a1, unsigned __int8 a2, char a3)
{
  int *v3; // eax
  int *v4; // ST08_4
  int v5; // ST10_4

  if ( a1 )
    v3 = a1;
  else
    v3 = &dword_806AF3C;
  v4 = &v3[(a2 >> 5) + 2];
  v5 = ((unsigned int)*v4 >> (a2 & 0x1F)) & 1;
  *v4 ^= (v5 ^ a3 & 1) << (a2 & 0x1F);
  return v5;
}
// 806AF3C: using guessed type int dword_806AF3C;

//----- (08059D5F) --------------------------------------------------------
void __fastcall __noreturn sub_8059D5F(int a1, int a2, int *a3, int a4, int a5)
{
  int (*v5)(); // eax
  int v6; // [esp+0h] [ebp-8h]
  int v7; // [esp+4h] [ebp-4h]

  if ( !a3 )
    a3 = &dword_806AF3C;
  *a3 = 10;
  if ( a4 )
  {
    v5 = (int (*)())&loc_8059DA0;
    if ( a5 )
      v5 = sub_8059DA5;
    dword_806A234 = (int)v5;
    sub_8061505(a1, a2, v6, v7);
  }
  abort();
}
// 8059DA5: using guessed type int sub_8059DA5();
// 806A234: using guessed type int dword_806A234;
// 806AF3C: using guessed type int dword_806AF3C;

//----- (08059DA5) --------------------------------------------------------
#error "8059DB8: positive sp value has been found (funcsize=0)"

//----- (08059DB9) --------------------------------------------------------
_DWORD *__userpurge sub_8059DB9@<eax>(_DWORD *a1, int a2)
{
  int v3; // [esp+0h] [ebp-38h]
  int v4; // [esp+4h] [ebp-34h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]

  memset(&v3, 0, 0x30u);
  if ( a2 == 10 )
    abort();
  *a1 = a2;
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = v6;
  a1[4] = v7;
  a1[5] = v8;
  a1[6] = v9;
  a1[7] = v10;
  a1[8] = v11;
  a1[9] = v12;
  a1[10] = v13;
  a1[11] = v14;
  return a1;
}

//----- (08059E5B) --------------------------------------------------------
const char *__usercall sub_8059E5B@<eax>(int a1@<ebx>, double a2@<st0>, char *msgid, int a3)
{
  int v4; // ecx
  const char *result; // eax
  const char *v6; // [esp+1Ch] [ebp-Ch]

  if ( gettext(msgid) != msgid )
  {
    dword_806A2CC = (int)&locret_8059F09;
    sub_8061134(v4);
  }
  v6 = sub_80608CC(a1);
  if ( sub_805FFE1(a2, (int)v6, (int)"UTF-8") )
  {
    if ( sub_805FFE1(a2, (int)v6, (int)"GB18030") )
    {
      if ( a3 == 9 )
        result = (const char *)&unk_8063D7D;
      else
        result = "'";
    }
    else if ( *msgid == 96 )
    {
      result = (const char *)&unk_8063D76;
    }
    else
    {
      result = (const char *)&unk_8063D7A;
    }
  }
  else if ( *msgid == 96 )
  {
    result = (const char *)&unk_8063D66;
  }
  else
  {
    result = (const char *)&unk_8063D6A;
  }
  return result;
}
// 8061134: using guessed type int __fastcall sub_8061134(_DWORD);
// 806A2CC: using guessed type int dword_806A2CC;

//----- (08059F0B) --------------------------------------------------------
#error "8059F6D: call analysis failed (funcsize=31)"

//----- (08059F72) --------------------------------------------------------
#error "805AD6A: positive sp value has been found (funcsize=266)"

//----- (0805AE44) --------------------------------------------------------
void *__cdecl sub_805AE44(int a1, int a2, _DWORD *a3, int *a4)
{
  int *v4; // eax
  int *v5; // ST3C_4
  int v6; // ST40_4
  int v7; // ST44_4
  int size; // [esp+48h] [ebp-10h]
  void *v10; // [esp+4Ch] [ebp-Ch]

  if ( a4 )
    v4 = a4;
  else
    v4 = &dword_806AF3C;
  v5 = v4;
  v6 = *__errno_location();
  v7 = v5[1] | (a3 == 0);
  size = sub_8059F0B(0, 0, a1, a2, *v5, v7, v5 + 2, v5[10], v5[11]) + 1;
  v10 = sub_805E115(size);
  sub_8059F0B(v10, size, a1, a2, *v5, v7, v5 + 2, v5[10], v5[11]);
  *__errno_location() = v6;
  if ( a3 )
    *a3 = size - 1;
  return v10;
}
// 8059F0B: using guessed type _DWORD __cdecl sub_8059F0B(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806AF3C: using guessed type int dword_806AF3C;

//----- (0805B024) --------------------------------------------------------
void *__cdecl sub_805B024(signed int a1, int a2, int a3, _DWORD *a4)
{
  int *v4; // eax
  void *v5; // edx
  size_t v6; // ST44_4
  bool v8; // [esp+37h] [ebp-21h]
  int *v9; // [esp+38h] [ebp-20h]
  void *ptr; // [esp+3Ch] [ebp-1Ch]
  int v11; // [esp+40h] [ebp-18h]
  int size; // [esp+44h] [ebp-14h]
  int v13; // [esp+48h] [ebp-10h]
  size_t v14; // [esp+4Ch] [ebp-Ch]

  v11 = *__errno_location();
  v9 = off_806A3CC;
  if ( a1 < 0 )
    abort();
  if ( dword_806A3C0 <= a1 )
  {
    v8 = off_806A3CC == &dword_806A3C4;
    if ( (unsigned int)a1 > 0xFFFFFFE )
      sub_805E278();
    if ( v8 )
      v4 = 0;
    else
      v4 = off_806A3CC;
    v9 = (int *)sub_805E152(v4, 8 * (a1 + 1));
    off_806A3CC = v9;
    if ( v8 )
    {
      v5 = off_806A3C8;
      *v9 = dword_806A3C4;
      v9[1] = (int)v5;
    }
    memset(&v9[2 * dword_806A3C0], 0, 8 * (a1 + 1 - dword_806A3C0));
    dword_806A3C0 = a1 + 1;
  }
  v6 = v9[2 * a1];
  ptr = (void *)v9[2 * a1 + 1];
  v13 = a4[1] | 1;
  v14 = sub_8059F0B(ptr, v6, a2, a3, *a4, v13, a4 + 2, a4[10], a4[11]);
  if ( v6 <= v14 )
  {
    size = v14 + 1;
    v9[2 * a1] = v14 + 1;
    if ( ptr != &unk_806AF7C )
      free(ptr);
    ptr = sub_805E115(size);
    v9[2 * a1 + 1] = (int)ptr;
    sub_8059F0B(ptr, size, a2, a3, *a4, v13, a4 + 2, a4[10], a4[11]);
  }
  *__errno_location() = v11;
  return ptr;
}
// 8059F0B: using guessed type _DWORD __cdecl sub_8059F0B(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806A3C0: using guessed type int dword_806A3C0;
// 806A3C4: using guessed type int dword_806A3C4;
// 806A3C8: using guessed type void *off_806A3C8;
// 806A3CC: using guessed type int *off_806A3CC;

//----- (0805B28D) --------------------------------------------------------
void *__cdecl sub_805B28D(signed int a1, int a2)
{
  return sub_805B024(a1, a2, -1, &dword_806AF3C);
}
// 806AF3C: using guessed type int dword_806AF3C;

//----- (0805B2B7) --------------------------------------------------------
void *__cdecl sub_805B2B7(signed int a1, int a2, int a3)
{
  return sub_805B024(a1, a2, a3, &dword_806AF3C);
}
// 806AF3C: using guessed type int dword_806AF3C;

//----- (0805B32D) --------------------------------------------------------
void *__cdecl sub_805B32D(signed int a1, int a2, int a3)
{
  char v4; // [esp+10h] [ebp-38h]

  sub_8059DB9(&v4, a2);
  return sub_805B024(a1, a3, -1, &v4);
}

//----- (0805B36B) --------------------------------------------------------
void *__cdecl sub_805B36B(signed int a1, int a2, int a3, int a4)
{
  char v5; // [esp+10h] [ebp-38h]

  sub_8059DB9(&v5, a2);
  return sub_805B024(a1, a3, a4, &v5);
}

//----- (0805B3A8) --------------------------------------------------------
void *__cdecl sub_805B3A8(int a1, int a2)
{
  return sub_805B32D(0, a1, a2);
}

//----- (0805B403) --------------------------------------------------------
void *__cdecl sub_805B403(int a1, int a2, unsigned __int8 a3)
{
  int v4; // [esp+0h] [ebp-58h]
  unsigned __int8 v5; // [esp+1Ch] [ebp-3Ch]
  int v6; // [esp+20h] [ebp-38h]
  int v7; // [esp+24h] [ebp-34h]
  int v8; // [esp+28h] [ebp-30h]
  int v9; // [esp+2Ch] [ebp-2Ch]
  int v10; // [esp+30h] [ebp-28h]
  int v11; // [esp+34h] [ebp-24h]
  int v12; // [esp+38h] [ebp-20h]
  int v13; // [esp+3Ch] [ebp-1Ch]
  int v14; // [esp+40h] [ebp-18h]
  int v15; // [esp+44h] [ebp-14h]
  int v16; // [esp+48h] [ebp-10h]
  int v17; // [esp+4Ch] [ebp-Ch]

  v5 = a3;
  v6 = dword_806AF3C;
  v7 = dword_806AF40;
  v8 = dword_806AF44;
  v9 = dword_806AF48;
  v10 = dword_806AF4C;
  v11 = dword_806AF50;
  v12 = dword_806AF54;
  v13 = dword_806AF58;
  v14 = dword_806AF5C;
  v15 = dword_806AF60;
  v16 = dword_806AF64;
  v17 = dword_806AF68;
  sub_8059CA5(&v4 - 14, a3, 1);
  return sub_805B024(0, a1, a2, &v6);
}
// 806AF3C: using guessed type int dword_806AF3C;
// 806AF40: using guessed type int dword_806AF40;
// 806AF44: using guessed type int dword_806AF44;
// 806AF48: using guessed type int dword_806AF48;
// 806AF4C: using guessed type int dword_806AF4C;
// 806AF50: using guessed type int dword_806AF50;
// 806AF54: using guessed type int dword_806AF54;
// 806AF58: using guessed type int dword_806AF58;
// 806AF5C: using guessed type int dword_806AF5C;
// 806AF60: using guessed type int dword_806AF60;
// 806AF64: using guessed type int dword_806AF64;
// 806AF68: using guessed type int dword_806AF68;

//----- (0805B4BD) --------------------------------------------------------
void *__cdecl sub_805B4BD(int a1, unsigned __int8 a2)
{
  return sub_805B403(a1, -1, a2);
}

//----- (0805B4F6) --------------------------------------------------------
void *__cdecl sub_805B4F6(int a1)
{
  return sub_805B4BD(a1, 0x3Au);
}

//----- (0805B533) --------------------------------------------------------
void *__cdecl sub_805B533(signed int a1, int a2, int a3)
{
  int v4; // [esp+0h] [ebp-78h]
  int v5; // [esp+10h] [ebp-68h]
  int v6; // [esp+14h] [ebp-64h]
  int v7; // [esp+18h] [ebp-60h]
  int v8; // [esp+1Ch] [ebp-5Ch]
  int v9; // [esp+20h] [ebp-58h]
  int v10; // [esp+24h] [ebp-54h]
  int v11; // [esp+28h] [ebp-50h]
  int v12; // [esp+2Ch] [ebp-4Ch]
  int v13; // [esp+30h] [ebp-48h]
  int v14; // [esp+34h] [ebp-44h]
  int v15; // [esp+38h] [ebp-40h]
  int v16; // [esp+3Ch] [ebp-3Ch]
  int v17; // [esp+40h] [ebp-38h]
  int v18; // [esp+44h] [ebp-34h]
  int v19; // [esp+48h] [ebp-30h]
  int v20; // [esp+4Ch] [ebp-2Ch]
  int v21; // [esp+50h] [ebp-28h]
  int v22; // [esp+54h] [ebp-24h]
  int v23; // [esp+58h] [ebp-20h]
  int v24; // [esp+5Ch] [ebp-1Ch]
  int v25; // [esp+60h] [ebp-18h]
  int v26; // [esp+64h] [ebp-14h]
  int v27; // [esp+68h] [ebp-10h]
  int v28; // [esp+6Ch] [ebp-Ch]

  sub_8059DB9(&v5, a2);
  v17 = v5;
  v18 = v6;
  v19 = v7;
  v20 = v8;
  v21 = v9;
  v22 = v10;
  v23 = v11;
  v24 = v12;
  v25 = v13;
  v26 = v14;
  v27 = v15;
  v28 = v16;
  sub_8059CA5(&v4 - 14, 0x3Au, 1);
  return sub_805B024(a1, a3, -1, &v17);
}

//----- (0805B5E4) --------------------------------------------------------
int __cdecl sub_805B5E4(int a1, int a2, int a3, int a4)
{
  return sub_805B624(a1, a2, a3, a4, -1);
}
// 805B624: using guessed type int __cdecl sub_805B624(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0805B624) --------------------------------------------------------
#error "805B6A6: call analysis failed (funcsize=37)"

//----- (0805B6AB) --------------------------------------------------------
#error "805B6C3: call analysis failed (funcsize=9)"

//----- (0805B778) --------------------------------------------------------
void *__cdecl sub_805B778(signed int a1, int a2, int a3)
{
  return sub_805B024(a1, a2, a3, &unk_806A3E0);
}

//----- (0805B7D3) --------------------------------------------------------
void *__cdecl sub_805B7D3(signed int a1, int a2)
{
  return sub_805B778(a1, a2, -1);
}

//----- (0805B7F5) --------------------------------------------------------
void *__cdecl sub_805B7F5(int a1)
{
  return sub_805B7D3(0, a1);
}

//----- (0805B810) --------------------------------------------------------
void __cdecl __noreturn sub_805B810(int a1)
{
  void *v1; // esi
  char *v2; // ebx
  int *v3; // eax

  if ( a1 )
  {
    v1 = sub_805B7F5(a1);
    if ( *__errno_location() )
      v2 = gettext("%s: read error");
    else
      v2 = gettext("%s: end of file");
    v3 = __errno_location();
    error(status, *v3, v2, v1);
  }
  abort();
}

//----- (0805B879) --------------------------------------------------------
_DWORD *__cdecl sub_805B879(int a1, int a2)
{
  _DWORD *result; // eax

  result = sub_805E128(0x81Cu);
  *result = a1;
  result[1] = sub_805B810;
  result[2] = a2;
  return result;
}

//----- (0805B8BE) --------------------------------------------------------
unsigned int __cdecl sub_805B8BE(int a1, int a2, size_t nbytes)
{
  size_t v3; // eax
  int v4; // eax
  size_t n; // ST24_4
  int v6; // eax
  size_t v7; // ST28_4
  int v8; // eax
  size_t v9; // ST2C_4
  int v10; // eax
  size_t v11; // ST30_4
  unsigned int result; // eax
  int v13; // eax
  size_t v14; // ST34_4
  unsigned int v15; // [esp+18h] [ebp-30h]
  int fd; // [esp+20h] [ebp-28h]
  struct timeval tv; // [esp+38h] [ebp-10h]

  v15 = 0;
  fd = open64("/dev/urandom", 0);
  if ( fd >= 0 )
  {
    v3 = a2;
    if ( nbytes <= a2 )
      v3 = nbytes;
    v15 = read(fd, (void *)a1, v3);
    if ( (v15 & 0x80000000) != 0 )
      v15 = 0;
    close(fd);
  }
  if ( v15 < a2 )
  {
    v4 = a2 - v15;
    if ( a2 - v15 > 8 )
      v4 = 8;
    n = v4;
    gettimeofday(&tv, 0);
    memcpy((void *)(a1 + v15), &tv, n);
    v15 += n;
  }
  if ( v15 < a2 )
  {
    v6 = a2 - v15;
    if ( a2 - v15 > 4 )
      v6 = 4;
    v7 = v6;
    tv.tv_sec = getpid();
    memcpy((void *)(a1 + v15), &tv, v7);
    v15 += v7;
  }
  if ( v15 < a2 )
  {
    v8 = a2 - v15;
    if ( a2 - v15 > 4 )
      v8 = 4;
    v9 = v8;
    tv.tv_sec = getppid();
    memcpy((void *)(a1 + v15), &tv, v9);
    v15 += v9;
  }
  if ( v15 < a2 )
  {
    v10 = a2 - v15;
    if ( a2 - v15 > 4 )
      v10 = 4;
    v11 = v10;
    tv.tv_sec = getuid();
    memcpy((void *)(a1 + v15), &tv, v11);
    v15 += v11;
  }
  result = v15;
  if ( v15 < a2 )
  {
    v13 = a2 - v15;
    if ( a2 - v15 > 4 )
      v13 = 4;
    v14 = v13;
    tv.tv_sec = getgid();
    memcpy((void *)(a1 + v15), &tv, v14);
    result = v15 + v14;
  }
  return result;
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);

//----- (0805BADB) --------------------------------------------------------
#error "805BAFB: call analysis failed (funcsize=19)"

//----- (0805BC00) --------------------------------------------------------
size_t __cdecl sub_805BC00(int a1, void *ptr, size_t n)
{
  size_t v3; // ST18_4
  size_t result; // eax
  int *v5; // ebx
  int v6; // eax
  int v7; // [esp+1Ch] [ebp-Ch]

  while ( 1 )
  {
    v3 = fread_unlocked(ptr, 1u, n, *(FILE **)a1);
    v7 = *__errno_location();
    ptr = (char *)ptr + v3;
    result = v3;
    n -= v3;
    if ( !n )
      break;
    v5 = __errno_location();
    if ( ferror_unlocked(*(FILE **)a1) )
      v6 = v7;
    else
      v6 = 0;
    *v5 = v6;
    (*(void (__cdecl **)(_DWORD))(a1 + 4))(*(_DWORD *)(a1 + 8));
  }
  return result;
}

//----- (0805BC88) --------------------------------------------------------
int __cdecl sub_805BC88(int a1, void *dest, size_t n)
{
  int result; // eax
  size_t i; // [esp+14h] [ebp-14h]
  char *v5; // [esp+18h] [ebp-10h]
  char v6; // [esp+1Ch] [ebp-Ch]

  for ( i = *(_DWORD *)a1; ; i = 1024 )
  {
    v6 = (char)dest;
    if ( n <= i )
      break;
    memcpy(dest, (const void *)(a1 + 1024 - i + 1040), i);
    dest = (char *)dest + i;
    n -= i;
    if ( !((v6 + (_BYTE)i) & 3) )
    {
      v5 = (char *)dest;
      while ( n > 0x3FF )
      {
        sub_805BEB2(a1 + 4, v5);
        v5 += 1024;
        n -= 1024;
        if ( !n )
        {
          result = a1;
          *(_DWORD *)a1 = 0;
          return result;
        }
      }
      dest = v5;
    }
    sub_805BEB2(a1 + 4, a1 + 1040);
  }
  memcpy(dest, (const void *)(a1 + 1024 - i + 1040), n);
  result = a1;
  *(_DWORD *)a1 = i - n;
  return result;
}
// 805BEB2: using guessed type _DWORD __cdecl sub_805BEB2(_DWORD, _DWORD);

//----- (0805BDB7) --------------------------------------------------------
size_t __cdecl sub_805BDB7(int a1, void *ptr, size_t n)
{
  size_t result; // eax

  if ( *(_DWORD *)a1 )
    result = sub_805BC00(a1, ptr, n);
  else
    result = sub_805BC88(a1 + 12, ptr, n);
  return result;
}

//----- (0805BDFF) --------------------------------------------------------
#error "805BE4A: call analysis failed (funcsize=27)"

//----- (0805BE5A) --------------------------------------------------------
int __cdecl sub_805BE5A(int a1)
{
  return a1;
}

//----- (0805BE71) --------------------------------------------------------
int __cdecl sub_805BE71(int a1, __int16 a2)
{
  return *(_DWORD *)((a2 & 0x3FC) + a1);
}

//----- (0805BEB2) --------------------------------------------------------
#error "805C066: call analysis failed (funcsize=130)"

//----- (0805C06B) --------------------------------------------------------
#error "805C0A7: call analysis failed (funcsize=273)"

//----- (0805C3ED) --------------------------------------------------------
#error "805C48E: positive sp value has been found (funcsize=47)"

//----- (0805C491) --------------------------------------------------------
#error "805C7CF: call analysis failed (funcsize=263)"

//----- (0805C975) --------------------------------------------------------
signed int __cdecl sub_805C975(_DWORD *a1)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_805F69D((int)(a1 + 3), 0, 0, (int)malloc, (int)free);
  sub_805F69D((int)(a1 + 14), 0, 0, (int)malloc, (int)free);
  return sub_805F69D((int)(a1 + 25), 0, 0, (int)malloc, (int)free);
}

//----- (0805CB39) --------------------------------------------------------
#error "805CBE3: call analysis failed (funcsize=59)"

//----- (0805CBE8) --------------------------------------------------------
#error "805CD32: positive sp value has been found (funcsize=105)"

//----- (0805CD33) --------------------------------------------------------
#error "805CD7C: call analysis failed (funcsize=59)"

//----- (0805CFD7) --------------------------------------------------------
#error "805D07E: positive sp value has been found (funcsize=59)"

//----- (0805D09A) --------------------------------------------------------
int __cdecl sub_805D09A(int a1, int a2)
{
  int v2; // eax
  int v3; // ecx

  v2 = mkostemp64(a1, a2);
  return sub_8060249(a2, v3, v2, a2);
}
// 8049A10: using guessed type int __cdecl mkostemp64(_DWORD, _DWORD);

//----- (0805D0C3) --------------------------------------------------------
#error "805D136: call analysis failed (funcsize=121)"

//----- (0805D248) --------------------------------------------------------
#error "805D270: call analysis failed (funcsize=15)"

//----- (0805D275) --------------------------------------------------------
#error "805D7C3: positive sp value has been found (funcsize=206)"

//----- (0805D7C4) --------------------------------------------------------
int __cdecl sub_805D7C4(int a1)
{
  return sub_805D248(a1);
}
// 805D248: using guessed type _DWORD __cdecl sub_805D248(_DWORD);

//----- (0805D7FC) --------------------------------------------------------
int __usercall sub_805D7FC@<eax>(int a1@<edx>, int a2@<ecx>, int fd)
{
  void *v3; // eax
  int v4; // edx
  int v5; // ecx
  int v6; // ST20_4
  int v7; // ST24_4
  int v9; // [esp+0h] [ebp-28h]
  int v10; // [esp+4h] [ebp-24h]
  int v11; // [esp+8h] [ebp-20h]

  if ( fd >= 0 )
  {
    v3 = &loc_805D827;
    if ( fd > 2 )
      v3 = &loc_805D85A;
    dword_806A284 = (int)v3;
    sub_806132A(a2, a1, v9, v10, v11);
    v6 = sub_8060C9B(v4, v5, fd);
    v7 = *__errno_location();
    close(fd);
    *__errno_location() = v7;
    fd = v6;
  }
  return fd;
}
// 806A284: using guessed type int dword_806A284;

//----- (0805D85F) --------------------------------------------------------
#error "805DD86: call analysis failed (funcsize=423)"

//----- (0805DEF5) --------------------------------------------------------
int __cdecl sub_805DEF5(FILE *stream, int a2, int a3, int a4, int a5)
{
  int *v5; // eax
  int v7; // [esp+0h] [ebp-58h]
  int i; // [esp+24h] [ebp-34h]
  int v9[12]; // [esp+28h] [ebp-30h]

  for ( i = 0; (unsigned int)i <= 9; ++i )
  {
    v5 = (int *)a5;
    a5 += 4;
    v9[i] = *v5;
    if ( !v9[i] )
      break;
  }
  return sub_805D85F(stream, a2, a3, a4, (int)(&v7 - 12), i);
}
// 805DEF5: using guessed type int var_30[12];

//----- (0805DF6B) --------------------------------------------------------
int sub_805DF6B(FILE *stream, int a2, int a3, int a4, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a4);
  return sub_805DEF5(stream, a2, a3, a4, (int)va);
}

//----- (0805E01B) --------------------------------------------------------
void *__cdecl sub_805E01B(unsigned int a1, unsigned int a2)
{
  if ( 0x7FFFFFFF / a2 < a1 )
    sub_805E278();
  return sub_805E128(a2 * a1);
}

//----- (0805E07E) --------------------------------------------------------
void *__cdecl sub_805E07E(void *ptr, int a2, int a3)
{
  unsigned int v4; // [esp+1Ch] [ebp-Ch]

  v4 = *(_DWORD *)a2;
  if ( ptr )
  {
    if ( 0x55555554u / a3 <= v4 )
      sub_805E278();
    v4 += (v4 >> 1) + 1;
  }
  else
  {
    if ( !v4 )
      v4 = (0x40u / a3 == 0) + 0x40u / a3;
    if ( 0x7FFFFFFFu / a3 < v4 )
      sub_805E278();
  }
  *(_DWORD *)a2 = v4;
  return sub_805E152(ptr, a3 * v4);
}

//----- (0805E115) --------------------------------------------------------
void *__cdecl sub_805E115(size_t size)
{
  return sub_805E128(size);
}

//----- (0805E128) --------------------------------------------------------
void *__cdecl sub_805E128(size_t size)
{
  void *v2; // [esp+1Ch] [ebp-Ch]

  v2 = malloc(size);
  if ( !v2 && size )
    sub_805E278();
  return v2;
}

//----- (0805E152) --------------------------------------------------------
void *__cdecl sub_805E152(void *ptr, size_t size)
{
  void *result; // eax
  void *ptra; // [esp+20h] [ebp+8h]

  if ( size || !ptr )
  {
    ptra = realloc(ptr, size);
    if ( !ptra )
    {
      if ( size )
        sub_805E278();
    }
    result = ptra;
  }
  else
  {
    free(ptr);
    result = 0;
  }
  return result;
}

//----- (0805E1ED) --------------------------------------------------------
void *__cdecl sub_805E1ED(size_t nmemb, size_t size)
{
  void *v3; // [esp+1Ch] [ebp-Ch]

  if ( 0x7FFFFFFF / size < nmemb || (v3 = calloc(nmemb, size)) == 0 )
    sub_805E278();
  return v3;
}

//----- (0805E22A) --------------------------------------------------------
void *__cdecl sub_805E22A(void *src, size_t n)
{
  void *v2; // eax

  v2 = sub_805E128(n);
  return memcpy(v2, src, n);
}

//----- (0805E278) --------------------------------------------------------
void __noreturn sub_805E278()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (0805E2B1) --------------------------------------------------------
void __cdecl sub_805E2B1(int errnum, int a2, int a3, int a4, int a5)
{
  char *v5; // eax
  char *v6; // eax
  void *v7; // esi
  void *v8; // ebx
  char *v9; // eax

  v5 = gettext("string comparison failed");
  error(0, errnum, v5);
  v6 = gettext("Set LC_ALL='C' to work around the problem.");
  error(0, 0, v6);
  v7 = sub_805B36B(1, 8, a4, a5);
  v8 = sub_805B36B(0, 8, a2, a3);
  v9 = gettext("The strings compared were %s and %s.");
  error(status, 0, v9, v8, v7);
}

//----- (0805E41B) --------------------------------------------------------
int __usercall sub_805E41B@<eax>(int a1@<edx>, int a2@<ecx>, void *s1, size_t n, void *s2, int a6)
{
  int v7; // [esp+28h] [ebp-10h]
  int errnum; // [esp+2Ch] [ebp-Ch]

  v7 = sub_8060B5A(a1, a2, s1, n, s2, a6);
  errnum = *__errno_location();
  if ( errnum )
    sub_805E2B1(errnum, (int)s1, n - 1, (int)s2, a6 - 1);
  return v7;
}

//----- (0805E4A6) --------------------------------------------------------
int __cdecl sub_805E4A6(double a1)
{
  int v2; // edx
  int v3; // ecx
  int v4; // [esp+0h] [ebp-38h]
  int v5; // [esp+4h] [ebp-34h]
  int v6; // [esp+8h] [ebp-30h]
  int v7; // [esp+Ch] [ebp-2Ch]
  double v8; // [esp+18h] [ebp-20h]
  struct timespec requested_time; // [esp+28h] [ebp-10h]

  v8 = a1;
  sub_80600E0(&v4 - 4, a1);
  *__errno_location() = 0;
  if ( !nanosleep(&requested_time, 0) )
    return 0;
  if ( *__errno_location() != 4 )
  {
    if ( *__errno_location() )
    {
      dword_806A284 = (int)&locret_805E550;
      sub_806132A(v3, v2, v4, v5, v6);
    }
  }
  dword_806A270 = (int)&loc_805E4DD;
  return sub_80613B3(v3, v2, v4, v5, v6, v7);
}
// 806A270: using guessed type int dword_806A270;
// 806A284: using guessed type int dword_806A284;

//----- (0805E552) --------------------------------------------------------
signed int __cdecl sub_805E552(unsigned int *a1, unsigned int a2)
{
  signed int result; // eax

  if ( 0xFFFFFFFF / a2 >= *a1 )
  {
    *a1 *= a2;
    result = 0;
  }
  else
  {
    *a1 = -1;
    result = 1;
  }
  return result;
}

//----- (0805E5A6) --------------------------------------------------------
int __cdecl sub_805E5A6(unsigned int *a1, unsigned int a2, int a3)
{
  int v3; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; i |= sub_805E552(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}

//----- (0805E5DC) --------------------------------------------------------
#error "805E740: call analysis failed (funcsize=112)"

//----- (0805EA12) --------------------------------------------------------
void __usercall sub_805EA12(int edx0@<edx>, int ecx0@<ecx>, int a1, int a2, int a3, int a4, int a5, int status)
{
  char *v8; // eax
  const char *v9; // [esp+Ch] [ebp-2Ch]
  char *v10; // [esp+10h] [ebp-28h]
  int v11; // [esp+14h] [ebp-24h]
  char v12; // [esp+1Ch] [ebp-1Ch]
  char v13; // [esp+22h] [ebp-16h]
  char v14; // [esp+23h] [ebp-15h]
  const char *v15; // [esp+24h] [ebp-14h]
  char *msgid; // [esp+28h] [ebp-10h]
  char *v17; // [esp+2Ch] [ebp-Ch]

  v12 = a3;
  v15 = "--";
  if ( (unsigned int)a1 > 3 )
  {
    if ( a1 != 4 )
      goto LABEL_6;
    msgid = "invalid %s%s argument '%s'";
  }
  else if ( (unsigned int)a1 >= 2 )
  {
    msgid = "invalid suffix in %s%s argument '%s'";
  }
  else
  {
    if ( a1 != 1 )
LABEL_6:
      abort();
    msgid = "%s%s argument '%s' too large";
  }
  if ( a2 < 0 )
  {
    v15 -= a2;
    v13 = v12;
    v14 = 0;
    v17 = &v13;
    dword_806A25C = (int)&loc_805EAA4;
    sub_806141F(ecx0, edx0);
  }
  v17 = *(char **)(16 * a2 + a4);
  v8 = gettext(msgid);
  v11 = a5;
  v10 = v17;
  v9 = v15;
  error(status, 0, v8, v15, v17, a5);
}
// 806141F: using guessed type int __fastcall sub_806141F(_DWORD, _DWORD);
// 806A25C: using guessed type int dword_806A25C;

//----- (0805EAED) --------------------------------------------------------
void __fastcall __noreturn sub_805EAED(int ecx0, int edx0, int a1, int a2, char a3, int a4, int a5)
{
  sub_805EA12(a4, ecx0, a1, a2, a3, a4, a5, status);
  abort();
}

//----- (0805EB40) --------------------------------------------------------
signed int __cdecl sub_805EB40(unsigned int *a1, signed int a2)
{
  unsigned __int64 v2; // rcx
  int v3; // edx
  signed int result; // eax
  int v5; // esi
  unsigned __int64 v6; // rax

  LODWORD(v2) = sub_8060CC0(0xFFFFFFFF, -1, a2, a2 >> 31);
  HIDWORD(v2) = v3;
  if ( v2 >= *(_QWORD *)a1 )
  {
    v5 = a2 * a1[1] + *a1 * (a2 >> 31);
    v6 = *a1 * (unsigned __int64)(unsigned int)a2;
    *a1 = v6;
    a1[1] = v5 + HIDWORD(v6);
    result = 0;
  }
  else
  {
    *a1 = -1;
    a1[1] = -1;
    result = 1;
  }
  return result;
}

//----- (0805EBEC) --------------------------------------------------------
int __usercall sub_805EBEC@<eax>(double st7_0@<st0>, int a1, int a2, int a3)
{
  void *v4; // eax

  v4 = &loc_805EC36;
  if ( a3 )
    v4 = &loc_805EBFB;
  dword_806A2AC = (int)v4;
  sub_8061223(st7_0);
  return 0;
}
// 8061223: using guessed type int __usercall sub_8061223@<eax>(double@<st0>);
// 806A2AC: using guessed type int dword_806A2AC;

//----- (0805EC3B) --------------------------------------------------------
int __usercall sub_805EC3B@<eax>(double a1@<st0>, int a2@<edx>, int ecx0@<ecx>, char *nptr, int a3, int base, int a5, char *s)
{
  int result; // eax
  int v9; // edx
  int v10; // ecx
  void *v11; // eax
  int v12; // [esp+0h] [ebp-48h]
  int v13; // [esp+4h] [ebp-44h]
  int v14; // [esp+8h] [ebp-40h]
  unsigned __int8 i; // [esp+1Bh] [ebp-2Dh]
  signed int v16; // [esp+20h] [ebp-28h]
  char *v17; // [esp+24h] [ebp-24h]
  uintmax_t v18; // [esp+38h] [ebp-10h]

  v16 = 0;
  if ( base < 0 || base > 36 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoumax");
  if ( !a3 )
  {
    dword_806A248 = (int)&loc_805EC9D;
    sub_8061491(ecx0, a2);
  }
  *__errno_location() = 0;
  v17 = nptr;
  for ( i = *nptr; (*__ctype_b_loc())[i] & 0x2000; i = *v17 )
    ++v17;
  if ( i == 45 )
    return 4;
  v18 = strtoumax(nptr, (char **)a3, base);
  if ( *(char **)a3 == nptr )
  {
    if ( s && **(_BYTE **)a3 )
    {
      if ( strchr(s, **(char **)a3) )
      {
        dword_806A2AC = (int)&loc_805EDA7;
        sub_8061223(a1);
      }
    }
    result = 4;
  }
  else
  {
    if ( *__errno_location() )
    {
      if ( *__errno_location() != 34 )
        return 4;
      v16 = 1;
    }
    v11 = &loc_805EDC6;
    if ( s )
      v11 = &loc_805EDDC;
    dword_806A284 = (int)v11;
    sub_806132A(v10, v9, v12, v13, v14);
    *(_QWORD *)a5 = v18;
    result = v16;
  }
  return result;
}
// 8061223: using guessed type int __usercall sub_8061223@<eax>(double@<st0>);
// 8061491: using guessed type int __fastcall sub_8061491(_DWORD, _DWORD);
// 806A248: using guessed type int dword_806A248;
// 806A284: using guessed type int dword_806A284;
// 806A2AC: using guessed type int dword_806A2AC;

//----- (0805F0A8) --------------------------------------------------------
int __cdecl sub_805F0A8(FILE *stream)
{
  int v2; // eax
  __int64 v3; // rax
  int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]

  v4 = 0;
  if ( fileno(stream) < 0 )
    return fclose(stream);
  if ( !__freading(stream) || (v2 = fileno(stream), LODWORD(v3) = lseek64(v2, 0, 0, 1), v3 != -1) )
  {
    if ( sub_805F333(stream) )
      v4 = *__errno_location();
  }
  v5 = fclose(stream);
  if ( v4 )
  {
    *__errno_location() = v4;
    v5 = -1;
  }
  return v5;
}
// 8049A90: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0805F16B) --------------------------------------------------------
int __usercall sub_805F16B@<eax>(int a1@<edx>, int a2@<ecx>, int fd, int cmd, char a5)
{
  void *v5; // eax
  int v6; // ST30_4
  int v8; // [esp+1Ch] [ebp-1Ch]
  char v9; // [esp+20h] [ebp-18h]
  int v10; // [esp+24h] [ebp-14h]

  v5 = &loc_805F1A1;
  if ( cmd != 1030 )
    v5 = &loc_805F2BB;
  dword_806A248 = (int)v5;
  sub_8061491(a2, a1);
  v9 = a5;
  if ( dword_806B07C < 0 )
  {
    v8 = sub_805F16B(fd, 0, a5);
  }
  else
  {
    v8 = fcntl(fd, cmd, a5);
    if ( v8 < 0 && *__errno_location() == 22 )
    {
      v8 = sub_805F16B(fd, 0, v9);
      if ( v8 < 0 )
        return v8;
      dword_806B07C = -1;
    }
    else
    {
      dword_806B07C = 1;
    }
  }
  if ( v8 >= 0 && dword_806B07C == -1 )
  {
    v10 = fcntl(v8, 1);
    if ( v10 < 0 || fcntl(v8, 2, v10 | 1) == -1 )
    {
      v6 = *__errno_location();
      close(v8);
      *__errno_location() = v6;
      v8 = -1;
    }
  }
  return v8;
}
// 8061491: using guessed type int __fastcall sub_8061491(_DWORD, _DWORD);
// 806A248: using guessed type int dword_806A248;
// 806B07C: using guessed type int dword_806B07C;

//----- (0805F2FA) --------------------------------------------------------
int __cdecl sub_805F2FA(FILE *stream)
{
  int result; // eax

  result = stream->_flags & 0x100;
  if ( result )
    result = sub_805F38C(stream, 0, 0, 1);
  return result;
}

//----- (0805F333) --------------------------------------------------------
#error "805F362: call analysis failed (funcsize=24)"

//----- (0805F38C) --------------------------------------------------------
#error "805F478: call analysis failed (funcsize=88)"

//----- (0805F4B0) --------------------------------------------------------
size_t __cdecl sub_805F4B0(wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  char v5; // [esp+18h] [ebp-10h]
  size_t v6; // [esp+1Ch] [ebp-Ch]

  if ( !pwc )
    pwc = (wchar_t *)&v5;
  v6 = mbrtowc(pwc, s, n, p);
  if ( v6 <= 0xFFFFFFFD || !n || !((unsigned __int8)sub_8057340(0) ^ 1) )
    return v6;
  *pwc = (unsigned __int8)*s;
  return 1;
}

//----- (0805F522) --------------------------------------------------------
int __cdecl sub_805F522(int a1, int a2)
{
  int result; // eax

  if ( *(_BYTE *)(a1 + 40) & 1 )
    result = (*(int (__cdecl **)(_DWORD, int))(a1 + 28))(*(_DWORD *)(a1 + 36), a2);
  else
    result = (*(int (__cdecl **)(int))(a1 + 28))(a2);
  return result;
}

//----- (0805F560) --------------------------------------------------------
int __cdecl sub_805F560(int a1, int a2)
{
  int result; // eax

  if ( *(_BYTE *)(a1 + 40) & 1 )
    result = (*(int (__cdecl **)(_DWORD, int))(a1 + 32))(*(_DWORD *)(a1 + 36), a2);
  else
    result = (*(int (__cdecl **)(int))(a1 + 32))(a2);
  return result;
}

//----- (0805F59E) --------------------------------------------------------
signed int __cdecl sub_805F59E(int a1, signed int a2, signed int a3)
{
  int v4; // [esp+4h] [ebp-24h]
  int v5; // [esp+18h] [ebp-10h]
  _DWORD *v6; // [esp+1Ch] [ebp-Ch]

  if ( !a3 )
    a3 = 8;
  if ( !a2 )
  {
    v5 = 32;
    a2 = 4064;
  }
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 24) = a3 - 1;
  v4 = *(_DWORD *)a1;
  *(_DWORD *)(a1 + 4) = sub_805F522(a1, v4);
  v6 = *(_DWORD **)(a1 + 4);
  if ( !v6 )
    obstack_alloc_failed_handler();
  *(_DWORD *)(a1 + 8) = ((unsigned int)&v6[a3 / 4u + 1] + 3) & -a3;
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 8);
  *v6 = (char *)v6 + *(_DWORD *)a1;
  *(_DWORD *)(a1 + 16) = *v6;
  v6[1] = 0;
  *(_BYTE *)(a1 + 40) &= 0xFDu;
  *(_BYTE *)(a1 + 40) &= 0xFBu;
  return 1;
}
// 806A480: using guessed type int (*obstack_alloc_failed_handler)(void);

//----- (0805F69D) --------------------------------------------------------
signed int __cdecl sub_805F69D(int a1, signed int a2, signed int a3, int a4, int a5)
{
  *(_DWORD *)(a1 + 28) = a4;
  *(_DWORD *)(a1 + 32) = a5;
  *(_BYTE *)(a1 + 40) &= 0xFEu;
  return sub_805F59E(a1, a2, a3);
}

//----- (0805F746) --------------------------------------------------------
#error "805F8FB: call analysis failed (funcsize=144)"

//----- (0805F900) --------------------------------------------------------
#error "805F920: positive sp value has been found (funcsize=0)"

//----- (0805F965) --------------------------------------------------------
int __usercall sub_805F965@<eax>(int a1@<edx>, int a2@<ecx>, int a3, unsigned int a4)
{
  int result; // eax
  int v5; // [esp+18h] [ebp-10h]
  int *v6; // [esp+1Ch] [ebp-Ch]

  v5 = *(_DWORD *)(a3 + 4);
  dword_806A25C = (int)&loc_805F9B9;
  sub_806141F(a2, a1);
  while ( 1 )
  {
    v6 = *(int **)(v5 + 4);
    sub_805F560(a3, v5);
    v5 = (int)v6;
    result = a3;
    *(_BYTE *)(a3 + 40) |= 2u;
    if ( !v6 )
      break;
    if ( (unsigned int)v6 < a4 )
    {
      result = *v6;
      if ( *v6 >= a4 )
        break;
    }
  }
  if ( v6 )
  {
    *(_DWORD *)(a3 + 12) = a4;
    *(_DWORD *)(a3 + 8) = *(_DWORD *)(a3 + 12);
    *(_DWORD *)(a3 + 16) = *v6;
    result = a3;
    *(_DWORD *)(a3 + 4) = v6;
  }
  else if ( a4 )
  {
    abort();
  }
  return result;
}
// 806141F: using guessed type int __fastcall sub_806141F(_DWORD, _DWORD);
// 806A25C: using guessed type int dword_806A25C;

//----- (0805FBF5) --------------------------------------------------------
int __cdecl sub_805FBF5(int a1, char a2)
{
  return __ROR4__(a1, a2);
}

//----- (0805FD20) --------------------------------------------------------
signed int __usercall sub_805FD20@<eax>(double a1@<st0>, signed int a2)
{
  int v2; // eax

  v2 = a2;
  if ( a2 > 90 )
  {
LABEL_5:
    if ( (unsigned int)(v2 - 97) <= 0x19 )
      return 1;
    return 0;
  }
  if ( a2 >= 65 )
    return 1;
  if ( (unsigned int)(a2 - 48) <= 9 )
  {
    dword_806A2AC = (int)&loc_805FD57;
    v2 = sub_8061223(a1);
    goto LABEL_5;
  }
  return 0;
}
// 8061223: using guessed type int __usercall sub_8061223@<eax>(double@<st0>);
// 806A2AC: using guessed type int dword_806A2AC;

//----- (0805FD65) --------------------------------------------------------
#error "805FD84: call analysis failed (funcsize=36)"

//----- (0805FE45) --------------------------------------------------------
int __usercall sub_805FE45@<eax>(int a1@<edx>, int a2@<ecx>, int a3)
{
  if ( (unsigned int)(a3 - 48) <= 9 )
  {
    dword_806A25C = (int)&loc_805FE74;
    sub_806141F(a2, a1);
  }
  return 0;
}
// 806141F: using guessed type int __fastcall sub_806141F(_DWORD, _DWORD);
// 806A25C: using guessed type int dword_806A25C;

//----- (0805FF19) --------------------------------------------------------
signed int __cdecl sub_805FF19(signed int a1)
{
  int v1; // ecx
  void *v2; // eax
  signed int result; // eax

  if ( a1 < 9 )
    goto LABEL_9;
  v2 = &loc_805FF42;
  if ( a1 <= 13 )
    v2 = &loc_805FF47;
  dword_806A2CC = (int)v2;
  if ( sub_8061134(v1) != 32 )
LABEL_9:
    result = 0;
  else
    result = 1;
  return result;
}
// 8061134: using guessed type int __fastcall sub_8061134(_DWORD);
// 806A2CC: using guessed type int dword_806A2CC;

//----- (0805FFAB) --------------------------------------------------------
int __cdecl sub_805FFAB(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 65) > 0x19 )
    result = a1;
  else
    result = a1 + 32;
  return result;
}

//----- (0805FFE1) --------------------------------------------------------
int __usercall sub_805FFE1@<eax>(double st7_0@<st0>, int a1, int a2)
{
  void *v3; // eax

  v3 = &loc_806000C;
  if ( a1 != a2 )
    v3 = &loc_8060013;
  dword_806A2AC = (int)v3;
  sub_8061223(st7_0);
  return 0;
}
// 8061223: using guessed type int __usercall sub_8061223@<eax>(double@<st0>);
// 806A2AC: using guessed type int dword_806A2AC;

//----- (0806005F) --------------------------------------------------------
int __cdecl sub_806005F(FILE *fp)
{
  bool v1; // ST1E_1
  bool v3; // [esp+1Dh] [ebp-Bh]
  bool v4; // [esp+1Fh] [ebp-9h]

  v3 = __fpending(fp) != 0;
  v1 = ferror_unlocked(fp) != 0;
  v4 = sub_805F0A8(fp) != 0;
  if ( !v1 && (!v4 || !v3 && *__errno_location() == 9) )
    return 0;
  if ( v4 != 1 )
    *__errno_location() = 0;
  return -1;
}

//----- (080600E0) --------------------------------------------------------
_DWORD *__userpurge sub_80600E0@<eax>(_DWORD *a1, double a2)
{
  signed int v2; // ST20_4
  double v3; // ST28_8
  int v4; // ST24_4
  int v6; // [esp+20h] [ebp-18h]
  int v7; // [esp+24h] [ebp-14h]

  if ( a2 <= -2147483648.0 )
  {
    sub_8060BD2(a1, 2147483648, 0);
  }
  else if ( 2147483648.0 <= a2 )
  {
    sub_8060BD2(a1, 0x7FFFFFFF, 999999999);
  }
  else
  {
    v2 = (signed int)a2;
    v3 = (a2 - (long double)v2) * 1000000000.0;
    v4 = (v3 > (long double)(signed int)v3) + (signed int)v3;
    v6 = v4 / 1000000000 + v2;
    v7 = v4 % 1000000000;
    if ( v7 < 0 )
    {
      --v6;
      v7 += 1000000000;
    }
    sub_8060BD2(a1, v6, v7);
  }
  return a1;
}

//----- (08060249) --------------------------------------------------------
int __usercall sub_8060249@<eax>(int a1@<edx>, int a2@<ecx>, int fd, int a4)
{
  int v4; // ST18_4
  int v5; // ST1C_4

  if ( fd >= 0 && fd <= 2 )
  {
    v4 = sub_806029A(a1, a2, fd, a4);
    v5 = *__errno_location();
    close(fd);
    *__errno_location() = v5;
    fd = v4;
  }
  return fd;
}

//----- (0806029A) --------------------------------------------------------
int __usercall sub_806029A@<eax>(int a1@<edx>, int a2@<ecx>, int fd, int a4)
{
  int v4; // eax

  if ( a4 & 0x80000 )
    v4 = 1030;
  else
    v4 = 0;
  return sub_805F16B(a1, a2, fd, v4, 3);
}

//----- (080602D1) --------------------------------------------------------
FILE *__cdecl sub_80602D1(int a1, char *modes)
{
  int v2; // edx
  int v3; // ecx
  int v4; // ST28_4
  int v6; // ST2C_4
  FILE *stream; // [esp+1Ch] [ebp-1Ch]
  signed int v8; // [esp+20h] [ebp-18h]
  int fd; // [esp+24h] [ebp-14h]

  stream = (FILE *)fopen64(a1, modes);
  if ( !stream )
    return stream;
  v8 = fileno(stream);
  if ( v8 < 0 || v8 > 2 )
    return stream;
  fd = sub_8060C9B(v2, v3, v8);
  if ( fd < 0 )
  {
    v4 = *__errno_location();
    sub_805F0A8(stream);
    *__errno_location() = v4;
    return 0;
  }
  if ( !sub_805F0A8(stream) )
  {
    stream = fdopen(fd, modes);
    if ( stream )
      return stream;
  }
  v6 = *__errno_location();
  close(fd);
  *__errno_location() = v6;
  return 0;
}
// 80499F0: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (080603A7) --------------------------------------------------------
int __usercall sub_80603A7@<eax>(int a1@<ebx>)
{
  char **v1; // ebp
  int v2; // edx
  int v3; // ecx
  bool v4; // zf
  void *v5; // eax
  _BOOL4 v6; // eax
  int v7; // eax
  void *v8; // eax
  int result; // eax
  unsigned int v10; // ebx
  int v11; // [esp-8h] [ebp-D4h]
  int v12; // [esp-4h] [ebp-D0h]
  char *name; // [esp+0h] [ebp-CCh]
  void *src; // [esp+4h] [ebp-C8h]
  size_t n; // [esp+8h] [ebp-C4h]
  int v16; // [esp+Ch] [ebp-C0h]
  int v17; // [esp+10h] [ebp-BCh]
  int v18; // [esp+14h] [ebp-B8h]
  int v19; // [esp+18h] [ebp-B4h]
  char *v20; // [esp+1Ch] [ebp-B0h]
  int v21; // [esp+20h] [ebp-ACh]
  int v22; // [esp+24h] [ebp-A8h]
  const char *v23; // [esp+28h] [ebp-A4h]
  size_t v24; // [esp+2Ch] [ebp-A0h]
  size_t v25; // [esp+30h] [ebp-9Ch]
  _BOOL4 v26; // [esp+34h] [ebp-98h]
  void *v27; // [esp+38h] [ebp-94h]
  unsigned int v28; // [esp+BCh] [ebp-10h]
  int v29; // [esp+C8h] [ebp-4h]

  v1 = (char **)&v29;
  v28 = __readgsdword(0x14u);
  v19 = dword_806B080;
  if ( !dword_806B080 )
  {
    v18 = 0;
    v23 = "charset.alias";
    v20 = getenv("CHARSETALIASDIR");
    if ( v20 )
    {
      v4 = *v20 == 0;
      v12 = (unsigned __int8)*v20;
      v11 = a1;
      v5 = &loc_8060439;
      if ( !v4 )
        v5 = &loc_806044D;
      dword_806A25C = (int)v5;
      a1 = v11;
      sub_806141F(v3, v2);
    }
    v18 = 0;
    v20 = "/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib";
    v24 = strlen("/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib");
    v25 = strlen(v23);
    v6 = v24 && v20[v24 - 1] != 47;
    v26 = v6;
    v27 = malloc(v24 + v6 + v25 + 1);
    if ( v27 )
    {
      memcpy(v27, v20, v24);
      if ( v26 )
        *((_BYTE *)v27 + v24) = 47;
      v1 = &name;
      memcpy(&(*(v1 - 37))[(_DWORD)*(v1 - 39) + (unsigned int)*(&name - 36)], *(&name - 40), v25 + 1);
    }
    free(*(v1 - 45));
    if ( *(v1 - 36) )
    {
      src = (void *)0x20000;
      name = *(v1 - 36);
      *(v1 - 35) = (char *)open64(name, 0x20000);
      if ( (signed int)*(v1 - 35) >= 0 )
      {
        src = "r";
        name = *(v1 - 35);
        *(v1 - 34) = (char *)fdopen((int)name, "r");
        if ( *(v1 - 34) )
        {
          *(v1 - 42) = 0;
          *(v1 - 41) = 0;
          while ( 1 )
          {
            name = *(v1 - 34);
            v7 = getc_unlocked((FILE *)name);
            *(v1 - 33) = (char *)v7;
            if ( *(v1 - 33) == (char *)-1 )
            {
              dword_806A220 = (int)&loc_806084C;
              v7 = sub_8061579(name, src, n, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27);
              v1 = &name;
            }
            if ( *(v1 - 33) != (char *)10 && *(v1 - 33) != (char *)32 && *(v1 - 33) != (char *)9 )
            {
              v4 = *(v1 - 33) == (char *)35;
              v12 = v7;
              v11 = a1;
              v8 = &loc_8060683;
              if ( !v4 )
                v8 = &loc_80606BC;
              dword_806A220 = (int)v8;
              a1 = v11;
              sub_8061579(name, src, n, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27);
              do
              {
                name = *(v1 - 34);
                *(v1 - 33) = (char *)getc_unlocked((FILE *)name);
              }
              while ( *(v1 - 33) != (char *)-1 && *(v1 - 33) != (char *)10 );
              if ( *(v1 - 33) == (char *)-1 )
                break;
            }
          }
          sub_805F0A8((FILE *)*(v1 - 34));
          if ( *(v1 - 41) )
          {
            (*(v1 - 41))[(_DWORD)*(v1 - 42)] = 0;
            *(v1 - 44) = *(v1 - 42);
          }
          else
          {
            *(v1 - 44) = (char *)&unk_8064A67;
          }
        }
        else
        {
          close((int)*(v1 - 35));
          *(v1 - 44) = (char *)&unk_8064A67;
        }
      }
      else
      {
        *(v1 - 44) = (char *)&unk_8064A67;
      }
      free(*(v1 - 36));
    }
    else
    {
      *(v1 - 44) = (char *)&unk_8064A67;
    }
    dword_806B080 = (int)*(v1 - 44);
  }
  result = (int)*(v1 - 44);
  v10 = __readgsdword(0x14u) ^ (unsigned int)*(v1 - 3);
  return result;
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 806141F: using guessed type int __fastcall sub_806141F(_DWORD, _DWORD);
// 8061579: using guessed type int __stdcall sub_8061579(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806A220: using guessed type int dword_806A220;
// 806A25C: using guessed type int dword_806A25C;
// 806B080: using guessed type int dword_806B080;

//----- (080608CC) --------------------------------------------------------
const char *__usercall sub_80608CC@<eax>(int a1@<ebx>)
{
  char *v1; // ST1C_4
  const char *s1; // [esp+18h] [ebp-10h]
  char *s2; // [esp+1Ch] [ebp-Ch]

  s1 = nl_langinfo(14);
  if ( !s1 )
    s1 = (const char *)&unk_8064A67;
  for ( s2 = (char *)sub_80603A7(a1); *s2; s2 = &v1[strlen(v1) + 1] )
  {
    if ( !strcmp(s1, s2) || *s2 == 42 && !s2[1] )
    {
      s1 = &s2[strlen(s2) + 1];
      break;
    }
    v1 = &s2[strlen(s2) + 1];
  }
  if ( !*s1 )
    s1 = "ASCII";
  return s1;
}

//----- (0806097F) --------------------------------------------------------
#error "8060A37: call analysis failed (funcsize=65)"

//----- (08060A55) --------------------------------------------------------
#error "8060AD3: call analysis failed (funcsize=44)"

//----- (08060AE6) --------------------------------------------------------
#error "8060B59: positive sp value has been found (funcsize=37)"

//----- (08060B5A) --------------------------------------------------------
int __usercall sub_8060B5A@<eax>(int a1@<edx>, int a2@<ecx>, void *s1, size_t n, void *s2, int a6)
{
  void *v6; // eax
  int v8; // [esp+0h] [ebp-18h]
  int v9; // [esp+4h] [ebp-14h]
  int v10; // [esp+8h] [ebp-10h]

  v6 = &loc_8060B81;
  if ( n != a6 )
    v6 = &loc_8060BB0;
  dword_806A284 = (int)v6;
  sub_806132A(a2, a1, v8, v9, v10);
  if ( memcmp(s1, s2, n) )
    return sub_806097F((char *)s1, n, (char *)s2, a6);
  *__errno_location() = 0;
  return 0;
}
// 806A284: using guessed type int dword_806A284;

//----- (08060BD2) --------------------------------------------------------
_DWORD *__userpurge sub_8060BD2@<eax>(_DWORD *a1, int a2, int a3)
{
  *a1 = a2;
  a1[1] = a3;
  return a1;
}

//----- (08060C9B) --------------------------------------------------------
int __usercall sub_8060C9B@<eax>(int a1@<edx>, int a2@<ecx>, int fd)
{
  return sub_805F16B(a1, a2, fd, 0, 3);
}

//----- (08060CC0) --------------------------------------------------------
int __cdecl sub_8060CC0(unsigned int a1, int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4; // esi
  int result; // eax
  int v6; // ebp
  int v7; // ebp
  unsigned int v8; // edi
  unsigned int v9; // edx
  unsigned int v10; // esi
  int v11; // edi
  unsigned __int64 v12; // rax
  unsigned int v13; // [esp+0h] [ebp-18h]
  unsigned int v14; // [esp+4h] [ebp-14h]
  unsigned int v15; // [esp+8h] [ebp-10h]

  v14 = a1;
  v13 = a3;
  if ( !a4 )
  {
    if ( a3 > (unsigned int)&v13 )
      return __PAIR__(&v13, a1) / a3;
    v4 = a3;
    if ( !a3 )
      v4 = 1 / 0u;
    return __PAIR__((unsigned int)&v13 % v4, a1) / v4;
  }
  if ( a4 > (unsigned int)&v13 )
    return 0;
  _BitScanReverse((unsigned int *)&v6, a4);
  v7 = v6 ^ 0x1F;
  if ( !v7 )
  {
    if ( v13 <= v14 || a4 < (unsigned int)&v13 )
      return 1;
    return 0;
  }
  v15 = v13 >> (32 - v7);
  v15 |= a4 << v7;
  v13 <<= v7;
  v8 = ((_DWORD)&v13 << v7) | (v14 >> (32 - v7));
  v9 = (unsigned int)&v13 >> (32 - v7);
  v10 = __PAIR__(v9, v8) % v15;
  v11 = __PAIR__(v9, v8) / v15;
  v12 = v13 * (unsigned __int64)(unsigned int)v11;
  v13 = HIDWORD(v12);
  if ( v10 < HIDWORD(v12) || v14 << (char)&v13 < (unsigned int)v12 && v10 == v13 )
    result = v11 - 1;
  else
    result = v11;
  return result;
}

//----- (08060E13) --------------------------------------------------------
unsigned __int64 __cdecl sub_8060E13(unsigned __int64 a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // edx
  unsigned __int64 result; // rax
  int v5; // ebp
  void *v6; // eax
  unsigned int v7; // eax
  unsigned int v8; // ecx
  unsigned int v9; // ebp
  unsigned __int64 v10; // rtt
  unsigned __int64 v11; // [esp+8h] [ebp-18h]

  v11 = a1;
  if ( a3 )
  {
    if ( a3 > HIDWORD(a1) )
    {
      result = a1;
    }
    else
    {
      _BitScanReverse((unsigned int *)&v5, a3);
      v6 = &loc_8060E90;
      if ( v5 ^ 0x1F )
        v6 = &loc_8060EE9;
      dword_806A25C = (int)v6;
      v7 = sub_806141F(a1, a3);
      if ( a2 <= (unsigned int)a1 || v7 < HIDWORD(a1) )
        v11 = __PAIR__(HIDWORD(a1), v8) - __PAIR__(v7, a2);
      result = v11;
    }
  }
  else
  {
    if ( a2 <= HIDWORD(a1) )
    {
      v9 = a2;
      if ( !a2 )
        v9 = 1 / 0u;
      LODWORD(v10) = a1;
      HIDWORD(v10) = HIDWORD(a1) % v9;
      v3 = v10 % v9;
    }
    else
    {
      v3 = a1 % a2;
    }
    result = v3;
  }
  return result;
}
// 806141F: using guessed type int __fastcall sub_806141F(_DWORD, _DWORD);
// 806A25C: using guessed type int dword_806A25C;

//----- (0806104D) --------------------------------------------------------
int __cdecl sub_806104D(int a1)
{
  return __cxa_atexit(a1, 0, dword_806A2E4);
}
// 8049AC0: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 806A2E4: using guessed type int dword_806A2E4;

//----- (0806107C) --------------------------------------------------------
int __cdecl sub_806107C(int a1, int a2)
{
  return __xstat64(3, a1, a2);
}
// 8049EB0: using guessed type int __cdecl __xstat64(_DWORD, _DWORD, _DWORD);

//----- (080610AB) --------------------------------------------------------
int __cdecl sub_80610AB(int a1, int a2)
{
  return __fxstat64(3, a1, a2);
}
// 8049A30: using guessed type int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD);

//----- (08061134) --------------------------------------------------------
#error "806113A: positive sp value has been found (funcsize=0)"

//----- (0806117A) --------------------------------------------------------
#error "80611B3: positive sp value has been found (funcsize=18)"

//----- (08061223) --------------------------------------------------------
#error "8061229: positive sp value has been found (funcsize=0)"

//----- (0806129D) --------------------------------------------------------
#error "80612A3: positive sp value has been found (funcsize=0)"

//----- (0806132A) --------------------------------------------------------
#error "8061330: positive sp value has been found (funcsize=0)"

//----- (080613B3) --------------------------------------------------------
#error "80613B9: positive sp value has been found (funcsize=0)"

//----- (0806141F) --------------------------------------------------------
#error "8061425: positive sp value has been found (funcsize=0)"

//----- (08061491) --------------------------------------------------------
#error "8061497: positive sp value has been found (funcsize=0)"

//----- (08061505) --------------------------------------------------------
#error "806150B: positive sp value has been found (funcsize=0)"

//----- (08061579) --------------------------------------------------------
#error "806157F: positive sp value has been found (funcsize=0)"

//----- (080615ED) --------------------------------------------------------
#error "80615F3: positive sp value has been found (funcsize=0)"

//----- (08061600) --------------------------------------------------------
int (**sub_8061600())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_8069ED0;
  v1 = &off_8069ED4 - off_8069ED0;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_8069ED0[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 8069ED0: using guessed type int (*off_8069ED0[2])();
// 8069ED4: using guessed type int (*off_8069ED4)();

//----- (08061664) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 91 decompilation failure(s) on 346 function(s)"
