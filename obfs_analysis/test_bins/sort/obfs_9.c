/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8049750();
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// int raise(int sig);
// int dup2(int fd, int fd2);
// int strcmp(const char *s1, const char *s2);
// int putc_unlocked(int c, FILE *stream);
// ssize_t read(int fd, void *buf, size_t nbytes);
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void _exit(int status);
// int __cdecl wcwidth(_DWORD); weak
// void *memmove(void *dest, const void *src, size_t n);
// void free(void *ptr);
// void *memcpy(void *dest, const void *src, size_t n);
// int mbsinit(const mbstate_t *ps);
// int ferror(FILE *stream);
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// int fclose(FILE *stream);
// int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
// int getc_unlocked(FILE *stream);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// __sighandler_t signal(int sig, __sighandler_t handler);
// int __cdecl __sched_cpucount(_DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// double __cdecl strtold(_DWORD, _DWORD); weak
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// int fputc_unlocked(int c, FILE *stream);
// int __cdecl getrlimit64(_DWORD, _DWORD); weak
// int execlp(const char *file, const char *arg, ...);
// int sysconf(int name);
// __uid_t getuid(void);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// int unlink(const char *name);
// int sigismember(const sigset_t *set, int signo);
// int fflush_unlocked(FILE *stream);
// int iswcntrl(wint_t wc);
// char *textdomain(const char *domainname);
// int iswprint(wint_t wc);
// int __cdecl fopen64(_DWORD, _DWORD); weak
// int ferror_unlocked(FILE *stream);
// int __cdecl mkostemp64(_DWORD, _DWORD); weak
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD); weak
// size_t __ctype_get_mb_cur_max(void);
// __pid_t waitpid(__pid_t pid, int *stat_loc, int options);
// int pthread_sigmask(int how, const __sigset_t *newmask, __sigset_t *oldmask);
// size_t __fpending(FILE *fp);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// __pid_t getpid(void);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// int pthread_cond_signal(pthread_cond_t *cond);
// void error(int status, int errnum, const char *format, ...);
// size_t fread_unlocked(void *ptr, size_t size, size_t n, FILE *stream);
// int strcoll(const char *s1, const char *s2);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int sysinfo(struct sysinfo *info);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// char *strchr(const char *s, int c);
// size_t strlen(const char *s);
// int fprintf(FILE *stream, const char *format, ...);
// ssize_t write(int fd, const void *buf, size_t n);
// int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *cond_attr);
// int __cdecl open64(_DWORD, _DWORD); weak
// int fcntl(int fd, int cmd, ...);
// int sigaddset(sigset_t *set, int signo);
// size_t strxfrm(char *dest, const char *src, size_t n);
// int setvbuf(FILE *stream, char *buf, int modes, size_t n);
// __gid_t getgid(void);
// void *memset(void *s, int c, size_t n);
// int *__errno_location(void);
// void *memchr(const void *s, int c, size_t n);
// int fileno(FILE *stream);
// int fgetc(FILE *stream);
// int pipe(int pipedes[2]);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// int __cdecl ftruncate64(_DWORD, _DWORD, _DWORD); weak
// __pid_t fork(void);
// int sigemptyset(sigset_t *set);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// int toupper(int c);
// void clearerr_unlocked(FILE *stream);
// char *strrchr(const char *s, int c);
// int pthread_join(pthread_t th, void **thread_return);
// struct lconv *localeconv(void);
// __pid_t getppid(void);
// int __cdecl explicit_bzero(_DWORD, _DWORD); weak
// int __cdecl pipe2(_DWORD, _DWORD); weak
// int __cdecl euidaccess(_DWORD, _DWORD); weak
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int nanosleep(const struct timespec *requested_time, struct timespec *remaining);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// char *bindtextdomain(const char *domainname, const char *dirname);
// int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl sched_getaffinity(_DWORD, _DWORD, _DWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// int feof_unlocked(FILE *stream);
// void abort(void);
// int __stdcall __xstat64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int strtol(const char *nptr, char **endptr, int base);
// char *ngettext(const char *msgid1, const char *msgid2, unsigned int n);
// int close(int fd);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// void *calloc(size_t nmemb, size_t size);
// int putchar_unlocked(int c);
// int _gmon_start__(void); weak
void sub_8049F73();
void sub_8049F90();
int sub_8049FA0();
int sub_804A010();
int sub_804A030();
void sub_804A08F();
void sub_804A0AA();
int sub_804A0BA();
void sub_804A19C();
void sub_804A1B7();
signed int sub_804A1C7();
void sub_804A2A9();
void sub_804A2C4();
int sub_804A2D4();
void sub_804A3B6();
void sub_804A3D1();
int sub_804A3E1();
void sub_804A4C3();
void sub_804A4DE();
int sub_804A4EE();
void sub_804A5D0();
void sub_804A5EB();
// int __usercall sub_804A5FB@<eax>(double a1@<st0>);
void sub_804A6F6();
void sub_804A711();
int sub_804A721();
void sub_804A81F();
void sub_804A83A();
int sub_804A84A();
void sub_804A92C();
void sub_804A947();
int sub_804A957();
void sub_804AA8F();
void sub_804AAAA();
int __fastcall sub_804AABA(int a1, int a2);
// int __usercall sub_804AB3A@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
void sub_804AC07();
void sub_804AC22();
int sub_804AC32();
// int __usercall sub_804AC99@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
void sub_804AD49();
void sub_804AD64();
int sub_804AD74();
// int __usercall sub_804ADF4@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
void sub_804AEA2();
void sub_804AEBD();
int __fastcall sub_804AECD(int a1, int a2);
void sub_804AFC8();
void sub_804AFE3();
int __fastcall sub_804AFF3(int a1, int a2);
// int __usercall sub_804B0CB@<eax>(void (__cdecl *a1)(int *)@<eax>);
// int __usercall sub_804B0E5@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
void sub_804B12C();
void sub_804B147();
int sub_804B157();
void sub_804B275();
void sub_804B290();
int sub_804B2A0();
// int __usercall sub_804B320@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
// int __usercall sub_804B389@<eax>(int edx0@<edx>, int a2@<ecx>, int a1);
int __cdecl sub_804B3B5(unsigned __int8 a1);
int __cdecl sub_804B3C7(unsigned __int8 a1);
char *__cdecl sub_804B427(unsigned __int64 a1);
int sub_804B46D();
int sub_804B498();
int __cdecl sub_804B4C3(char *s1); // idb
void __cdecl __noreturn sub_804B67B(int a1, const char *a2);
void __cdecl __noreturn sub_804B777(int a1, char *a2);
void __cdecl __noreturn sub_804B802(int status); // idb
int __cdecl sub_804BACA(int a1);
int __cdecl sub_804BAFF(unsigned __int8 *a1);
int __cdecl sub_804BB2F(int a1, unsigned int a2);
bool __cdecl sub_804BB4D(int a1, int a2);
// void __usercall __noreturn sub_804BB72(double a1@<st0>, __pid_t pid);
int sub_804BC41(); // weak
int sub_804BCBF(); // weak
void __cdecl __noreturn sub_804BCC9(int a1);
// void __usercall __noreturn sub_804BD5E(double st7_0@<st0>, int a1);
// void __usercall __noreturn sub_804BE27(double st7_0@<st0>, int a1);
// int __usercall sub_804BE49@<eax>(double a1@<st0>);
// void __usercall __noreturn sub_804BE6C(double a1@<st0>);
// int __usercall sub_804BE85@<eax>(double a1@<st0>);
int sub_804BEC9();
// int __usercall sub_804BF01@<eax>(double a1@<st0>);
int *__cdecl sub_804BF3B(int *a2, char a3);
FILE *__cdecl sub_804C128(char *s1, char *modes);
void __cdecl __noreturn sub_804C285(char *s1, char *modes);
int sub_804C2DA(); // weak
// void __usercall sub_804C2DF(double a1@<st0>, FILE *stream, int a3);
int __cdecl sub_804C3A3(int fd, int fd2); // idb
__pid_t __cdecl sub_804C3D0(int pipedes[2], int a2);
int *__cdecl sub_804C5A0(FILE **a2, char a3);
int *__cdecl sub_804C6EC(FILE **a2);
// int __usercall sub_804C707@<eax>(double a1@<st0>, int a2);
int __cdecl sub_804C8FC(int a1);
// void __usercall sub_804C995(double a1@<st0>, char *name);
int compar(const void *, const void *); // idb
void sub_804CAF7();
unsigned int __cdecl sub_804CD24(int a1, char a2, char *a3);
int __cdecl sub_804CFBD(int, int, char *nptr); // idb
// int __usercall sub_804D22C@<eax>(int a1@<edx>, int ecx0@<ecx>, int a2, char a3, char *nptr);
void __noreturn sub_804D2F9();
int __cdecl sub_804D4DC(int a1, unsigned int a2, int a3, unsigned int a4, int a5);
void __cdecl __noreturn sub_804D6BF(int, int, size_t size); // idb
int sub_804D779(); // weak
int __cdecl sub_804D7B6(_DWORD *a1);
unsigned __int8 *__cdecl sub_804D7D1(int a1, int a2);
int __cdecl sub_804D9DE(char **a1, int a2);
int __cdecl sub_804DBA3(int a2, FILE *stream, int a4);
// void __usercall sub_804DFFC(double a1@<st0>, char **a2);
// int __usercall sub_804E128@<eax>(double a1@<st0>, _BYTE *a2);
// int __usercall sub_804E18F@<eax>(double a1@<st0>, unsigned __int8 *a2, unsigned __int8 *a3);
// int __usercall sub_804E291@<eax>(double a1@<st0>, _BYTE *a2, unsigned __int8 *a3);
int __cdecl sub_804E34A(int a1, int a2);
signed int __cdecl sub_804E3CE(int a1, int a2);
// int __usercall sub_804E4F9@<eax>(unsigned __int8 a1@<bl>, unsigned __int8 *a2, unsigned __int8 **a3);
// unsigned int __usercall sub_804E6B4@<eax>(double a1@<st0>, char *a2);
size_t __cdecl sub_804E7A9(char *dest, char *src, size_t n);
// int __usercall sub_804E881@<eax>(double a1@<st0>, int a2, size_t a3, int a4, size_t a5);
int __cdecl sub_804EE70(char *a1, unsigned int a2);
int __cdecl sub_804EECC(int a1, int a2);
_BOOL4 __cdecl sub_804EF84(_BYTE *a1);
// int __usercall sub_804EFEB@<eax>(int a1@<ecx>, unsigned __int8 a2@<bl>, double a3@<st0>, int a4, int a5);
// int __usercall sub_804F24B@<eax>(int a1@<ecx>, unsigned __int8 a2@<bl>, double a3@<st0>, int a4);
// int __usercall sub_804F2BF@<eax>(double a1@<st0>, int a2);
// _BYTE *__usercall sub_804F3C1@<eax>(int a1@<edx>, int a2@<ecx>, int a3, _BYTE *a4);
// unsigned int __usercall sub_804F509@<eax>(double a1@<st0>, int *a2);
// int __usercall sub_804FD6E@<eax>(int a1@<ecx>, double a2@<st0>, char **a3, char **a4);
// int __usercall sub_8050AA3@<eax>(int a1@<edx>, int a2@<ecx>, double a3@<st0>, int a4, int a5);
// int __usercall sub_8050C29@<eax>(int a1@<ecx>, unsigned __int8 a2@<bl>, double a3@<st0>, int a4, FILE *stream, int a6);
void __cdecl __noreturn sub_8050D4F(char *a2);
// unsigned int __usercall sub_8051154@<eax>(double a1@<st0>, int a2, unsigned int a3, void **a4);
// void __usercall sub_8051251(int a1@<ebx>, double a2@<st0>, int a3, int a4, int a5, FILE *stream, int a7, void *a8);
// int __usercall sub_8051C2A@<eax>(int a1@<ebx>, double a2@<st0>, int a3, int a4, int a5, FILE *stream, int a7);
// int __usercall sub_8051CCF@<eax>(int a1@<ecx>, double a2@<st0>, _DWORD *a3, unsigned int a4, _DWORD *a5);
// int __usercall sub_8051DC6@<eax>(int a1@<ecx>, double a2@<st0>, _DWORD *a3, unsigned int a4, _DWORD *a5, unsigned __int8 a6);
pthread_mutex_t *__cdecl sub_8051FEC(unsigned int a1, int a2, int a3);
int __cdecl sub_805211F(_DWORD *a1, pthread_mutex_t *a2, int a3, unsigned int a4, int a5, char a6);
_BOOL4 __cdecl sub_80522DC(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8052350(pthread_mutex_t *a1);
int __cdecl sub_8052366(pthread_mutex_t *a1);
int __cdecl sub_80523C1(int a1, int a2);
int __cdecl sub_805240F(int a1, int a2);
pthread_mutex_t *__cdecl sub_805245C(int a1);
// int __usercall sub_80524C5@<eax>(int a1@<edx>, int a2@<ecx>, unsigned __int8 a3@<bl>, double a4@<st0>, int a5, FILE *stream, int a7);
// int __usercall sub_805258E@<eax>(double a1@<st0>, unsigned __int8 bl0@<bl>, int a2, int a3, FILE *stream, int a5);
void __cdecl sub_8052A34(int a1, int a2);
int __cdecl sub_8052B6A(int a1, _DWORD *a2);
// int __usercall sub_8052C0C@<eax>(unsigned __int8 a1@<bl>, double a2@<st0>, int a3, int a4, FILE *stream, int a6);
void *start_routine(void *); // idb
// int __usercall sub_8052D90@<eax>(int a1@<ecx>, unsigned __int8 a2@<bl>, double a3@<st0>, int a4, int a5, int a6, int a7, int a8, FILE *stream, int a10);
// int __usercall sub_8052FC4@<eax>(double a1@<st0>, int a2, int a3, int a4, char *s1);
unsigned int __cdecl sub_8053268(int a2, unsigned int a3);
void __cdecl sub_805333C(char *a2);
// void __usercall sub_80533AE(double a1@<st0>, int a2, int a3, int a4, char *s1);
// int __usercall __noreturn sub_80537EB@<eax>(double a1@<st0>, char **a2, int a3, char *a4, int a5);
int sub_8053C4C(); // weak
_DWORD *__cdecl sub_8053C55(void *src);
unsigned int __cdecl sub_8053CA2(int a1, char *msgid);
unsigned int __cdecl sub_8053D15(int a1);
unsigned int sub_8053D46();
int __cdecl sub_8053E3D(char *nptr, int, char *msgid); // idb
int __cdecl sub_8053F15(int sig); // idb
// _BYTE *__usercall sub_8053F40@<eax>(int a1@<edx>, int a2@<ecx>, double a3@<st0>, _BYTE *a4, int a5, int a6);
void *__cdecl sub_80540CC(void *s);
int __cdecl main(int argc, char **argv);
void __noreturn sub_8055832();
int __cdecl sub_8055846(char *s, int, int, size_t); // idb
void __cdecl sub_805596C(char *a1, char *a2, int a3);
int __cdecl sub_80559EF(int a1);
int __cdecl sub_8055B1B(void *s1, char *s, int, size_t n, size_t, int); // idb
int __cdecl sub_8055C45(unsigned __int8 a1);
// int __usercall sub_8055C5C@<eax>(double a1@<st0>);
_DWORD *__cdecl sub_8055D6A(_DWORD *a1);
_DWORD *__cdecl sub_8055DB6(_DWORD *a1, int a2);
// int __usercall sub_8055DC3@<eax>(double a1@<st0>, int *a2, _DWORD *a3);
// int __usercall sub_8055E5D@<eax>(double a1@<st0>, int *a2, _DWORD *a3);
// int __usercall sub_805612C@<eax>(int a1@<edx>, int a2@<ecx>, void *src, size_t a4, int a5);
int *__cdecl sub_8056347(int *a1, unsigned int a2, int *a3);
int __cdecl sub_8057041(int a1, int a2, int a3, int a4, int a5, int a6);
void __cdecl sub_8057092(FILE *stream, int a2);
_BYTE *__cdecl sub_80570DA(_BYTE **a1);
int __cdecl sub_80571D2(unsigned __int8 a1);
// int __usercall sub_805726A@<eax>(double a1@<st0>, int a2, unsigned int a3, int a4, unsigned int a5);
// int __usercall sub_80574BE@<eax>(double a1@<st0>, char *s1, char *s2);
int __cdecl sub_8057768(int category); // idb
int __cdecl sub_80577C6(int a1);
int __cdecl sub_80577D1(int a1);
int __cdecl sub_80577DC(int a1);
unsigned int __cdecl sub_80577E7(int a1);
int __cdecl sub_80579FD(int a1, int a2);
bool __cdecl sub_8057CF6(unsigned int a1);
int __cdecl sub_8057D69(unsigned int a1);
// signed int __usercall sub_8057E42@<eax>(int edx0@<edx>, int a2@<ecx>, int a1);
unsigned int __cdecl sub_8057F23(unsigned int a1, int a2);
int sub_8057FF1();
void *__cdecl sub_80583EF(int a1);
int __cdecl sub_805842A(int a1, _DWORD *a2);
int __cdecl sub_805844D(int a1, int a2, _DWORD *a3, char a4);
signed int __cdecl sub_80585D2(int a1, int a2, char a3);
signed int __cdecl sub_80587AE(int a1, unsigned int a2);
signed int __cdecl sub_805897C(unsigned int *a1, int a2, _DWORD *a3);
int __cdecl sub_8058BD2(unsigned int *a1, int a2);
// int __usercall sub_8058C47@<eax>(double st7_0@<st0>, int a1, int a2);
_DWORD *__cdecl sub_8058E89(int (*a1)(), unsigned int a2);
int sub_8058EFE();
void __cdecl sub_8058F08(void *ptr);
int __cdecl sub_8058F28(int a1, int a2);
int __cdecl sub_8058FB1(int *a1);
unsigned int __cdecl sub_805902D(int a1, unsigned int a2, unsigned int a3, int (__cdecl *a4)(_DWORD, int));
int __cdecl sub_805911D(int a1, unsigned int a2, int (__cdecl *a3)(_DWORD, int));
void __cdecl __noreturn sub_80591C6(int a1, int a2);
int sub_8059351(); // weak
int __cdecl sub_8059356(unsigned int a1, int a2);
int __cdecl sub_80593B4(__int64 a1, int a2);
int __cdecl sub_8059467(char *a1, int a2, char a3);
int sub_805977E();
signed int __cdecl sub_80597F6(int a1);
int __cdecl sub_80598C1(char *nptr); // idb
unsigned int __cdecl sub_80599AB(int a1);
long double sub_8059A5D();
void __noreturn sub_8059B1F();
int sub_8059C5D(); // weak
int __cdecl sub_8059C5F(int pipedes[2], int); // idb
int sub_8059F1F();
char *__cdecl sub_8059F9E(char *s);
int __cdecl sub_805A16B(int a1, unsigned __int8 a2, char a3);
int *__cdecl sub_805A247(int *a1, int a2, int a3);
// _DWORD *__userpurge sub_805A288@<eax>(_DWORD *a1, int a2);
char *__cdecl sub_805A30A(char *msgid);
unsigned int __cdecl sub_805A3CD(int a1, unsigned int a2, char *a3, size_t a4, char *a5, int a6, int a7, char *a8, char *a9);
void *__cdecl sub_805B35B(char *a1, size_t a2, _DWORD *a3, int *a4);
void *__cdecl sub_805B53F(signed int a1, char *a2, size_t a3, int a4);
void *__cdecl sub_805B781(signed int a1, char *a2);
void *__cdecl sub_805B7AB(signed int a1, char *a2, size_t a3);
void *__cdecl sub_805B839(signed int a2, int a3, char *a4);
void *__cdecl sub_805B877(signed int a2, int a3, char *a4, size_t a5);
void *__cdecl sub_805B8B4(int a2, char *a3);
void *__cdecl sub_805B919(int a1, char *a2, size_t a3);
void *__cdecl sub_805B944(char *a1, size_t a2, unsigned __int8 a3);
void *__cdecl sub_805B9EE(char *a1, unsigned __int8 a2);
void *__cdecl sub_805BA17(char *a1);
void *__cdecl sub_805BA91(signed int a1, int a2, char *a3);
void *__cdecl sub_805BB32(signed int a1, int a2, int a3, char *a4);
void *__cdecl sub_805BB62(signed int a1, int a2, int a3, char *a4, size_t a5);
void *__cdecl sub_805BC5C(signed int a1, char *a2, size_t a3);
void *__cdecl sub_805BCCF(signed int a1, char *a2);
void *__cdecl sub_805BCF1(char *a1);
void __cdecl __noreturn sub_805BD0C(char *a2);
_DWORD *__cdecl sub_805BD92(int a1, int a2);
unsigned int __cdecl sub_805BDC7(int a1, int a2, size_t nbytes);
// char *__usercall sub_805BFD4@<eax>(double a1@<st0>, int a2, size_t n);
size_t __cdecl sub_805C0FB(int a1, void *ptr, size_t n);
int __cdecl sub_805C19B(int, void *dest, size_t n); // idb
size_t __cdecl sub_805C2BC(int a1, void *ptr, size_t n);
// int __usercall sub_805C304@<eax>(double a1@<st0>, void *ptr);
int __cdecl sub_805C34A(int a1);
int __cdecl sub_805C361(int a1, __int16 a2);
void __cdecl __noreturn sub_805C392(unsigned int *a1, int *a2);
int sub_805C81A(); // weak
// _DWORD *__usercall sub_805C895@<eax>(int a1@<edx>, int a2@<ecx>, _DWORD *a3);
int __cdecl sub_805CCB6(_DWORD *a1);
_DWORD *__cdecl sub_805CE98(_DWORD *a1);
bool __cdecl sub_805D096(FILE *stream, int a2);
int __cdecl sub_805D381(int a1, int a2);
// int __usercall sub_805D3AA@<eax>(double a1@<st0>, _BYTE *a2, _BYTE *a3, char a4);
// int __usercall sub_805D528@<eax>(int edx0@<edx>, int ecx0@<ecx>, _BYTE *a1, unsigned __int8 *a2, int a3, int a4);
// int __usercall sub_805DAFB@<eax>(int edx0@<edx>, int ecx0@<ecx>, _BYTE *a1, unsigned __int8 *a2, int a3, int a4);
// int __usercall sub_805DB23@<eax>(int a1@<edx>, int a2@<ecx>, int fd);
int __cdecl sub_805DBAB(FILE *stream, int, int, int, int, int); // idb
// int __usercall sub_805E190@<eax>(int a1@<edx>, int a2@<ecx>, FILE *stream, int a4, int a5, int a6, int a7);
// int __usercall sub_805E233@<eax>(int a1@<edx>, int a2@<ecx>, FILE *stream, int a4, int a5, int a6, ...);
void *__cdecl sub_805E2D3(unsigned int a1, unsigned int a2);
void *__cdecl sub_805E315(size_t n, unsigned int a2, unsigned int a3);
void *__cdecl sub_805E34A(size_t n, unsigned int *a2, unsigned int a3);
void *__cdecl sub_805E3E1(size_t size);
void *__cdecl sub_805E3F4(size_t size);
void *__cdecl sub_805E447(size_t n, size_t size);
void *__cdecl sub_805E513(size_t nmemb, size_t size);
void *__cdecl sub_805E550(void *src, size_t n);
void __noreturn sub_805E5AE();
void __cdecl sub_805E5E7(int errnum, int a3, int a4, int a5, int a6);
int __cdecl sub_805E744(void *s1, size_t n, void *s2, int a5);
signed int __cdecl sub_805E7AF(double a1);
signed int __cdecl sub_805E821(unsigned int *a1, unsigned int a2);
int __cdecl sub_805E865(unsigned int *a1, unsigned int a2, int a3);
// int __usercall sub_805E8AB@<eax>(int a1@<edx>, int a2@<ecx>, char *nptr, int a3, int base, int a5, char *s);
// void __usercall sub_805ED75(int edx0@<edx>, int ecx0@<ecx>, int a1, int a2, int a3, int a4, int a5, int status);
void __fastcall __noreturn sub_805EE44(int ecx0, int edx0, int a1, int a2, char a3, int a4, int a5);
signed int __cdecl sub_805EE87(int a1, int a2);
int __cdecl sub_805EF13(int a1, int a2, int a3);
int __cdecl sub_805EF49(char *nptr, int a2, int base);
// int __usercall sub_805F3D1@<eax>(double a1@<st0>, FILE *stream);
int __cdecl sub_805F494(int fd, int cmd, char); // idb
int __cdecl sub_805F641(FILE *stream); // idb
// int __usercall sub_805F67A@<eax>(double a1@<st0>, FILE *fp);
int __cdecl sub_805F6F0(FILE *stream, int, int, int); // idb
int __cdecl sub_805F7FA(wchar_t *pwc, char *s, size_t n, mbstate_t *p); // idb
int __cdecl sub_805F8B7(int a1, int a2);
int __cdecl sub_805F901(int a1, int a2);
signed int __cdecl sub_805F93F(int a1, signed int a2, int a3);
signed int __cdecl sub_805FA43(int a1, signed int a2, int a3, int a4, int a5);
int __cdecl sub_805FACC(int a1, int a2);
int __cdecl sub_805FCD0(int a1, unsigned int a2);
int __cdecl sub_805FEFB(int a1, char a2);
_BOOL4 __cdecl sub_805FFE6(signed int a1);
_BOOL4 __cdecl sub_806002F(signed int a1);
_BOOL4 __cdecl sub_80600C8(int a1);
_BOOL4 __cdecl sub_80601B9(signed int a1);
int __cdecl sub_806023A(int a1);
int __cdecl sub_806028C(unsigned __int8 *a1, unsigned __int8 *a2);
// int __usercall sub_8060338@<eax>(double a1@<st0>, FILE *fp);
// _DWORD *__userpurge sub_80603EB@<eax>(_DWORD *a1, double a2);
int __cdecl sub_8060540(int fd, int); // idb
int __cdecl sub_80605AA(int fd, int); // idb
// FILE *__usercall sub_806060A@<eax>(double a1@<st0>, int a2, char *modes);
int __noreturn sub_806073E();
int sub_8060C99(); // weak
void __noreturn sub_8060CA2();
int __cdecl sub_8060DB5(char *s, int, char *s2, int); // idb
int __cdecl sub_8060E8C(void *s1, size_t n, void *s2, int); // idb
int __cdecl sub_8060F72(void *s1, size_t n, void *s2, int); // idb
// _DWORD *__userpurge sub_8060FD1@<eax>(_DWORD *a1, int a2, int a3);
int __cdecl sub_806109B(int fd); // idb
__int64 __cdecl sub_80610C0(unsigned int a1, unsigned int a2, int a3, int a4);
char *__cdecl sub_806123A(unsigned __int64 a1, __int64 a2);
int __cdecl sub_8061428(int a1);
int __cdecl sub_806148D(int a1, int a2);
int sub_80614D0(); // weak
int __cdecl sub_80614E1(int a1, int a2);
int __fastcall sub_8061576(_DWORD, _DWORD); // weak
int sub_806160F(void); // weak
int __cdecl sub_80616BF();
int __fastcall sub_806174E(_DWORD, _DWORD); // weak
int sub_80617DA(void); // weak
int sub_8061881(void); // weak
int __fastcall sub_8061955(_DWORD, _DWORD);
double __fastcall sub_80619DA(_DWORD, _DWORD); // weak
int __fastcall sub_8061A4C(_DWORD, _DWORD); // weak
int __fastcall sub_8061AC4(_DWORD, _DWORD); // weak
int sub_8061B34(void); // weak
int sub_8061BAC(void); // weak
int __fastcall sub_8061C20(_DWORD, _DWORD); // weak
// int __usercall sub_8061C98@<eax>(double@<st0>); weak
int (**sub_8061CB0())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN locret_804A60A; // weak
_UNKNOWN locret_804A966; // weak
_UNKNOWN locret_804AAC9; // weak
_UNKNOWN locret_804AEDC; // weak
_UNKNOWN locret_804B002; // weak
_UNKNOWN loc_804B3AB; // weak
_UNKNOWN loc_804B3B3; // weak
_UNKNOWN loc_804B53A; // weak
_UNKNOWN loc_804B578; // weak
_UNKNOWN loc_804B604; // weak
_UNKNOWN loc_804B61F; // weak
_UNKNOWN loc_804B7C1; // weak
_UNKNOWN loc_804BC13; // weak
_UNKNOWN loc_804BC32; // weak
_UNKNOWN loc_804BD53; // weak
_UNKNOWN locret_804BD5C; // weak
_UNKNOWN locret_804BDBC; // weak
_UNKNOWN loc_804BDE4; // weak
_UNKNOWN loc_804BE00; // weak
_UNKNOWN loc_804C203; // weak
_UNKNOWN loc_804C24D; // weak
_UNKNOWN loc_804C2BF; // weak
_UNKNOWN loc_804C323; // weak
_UNKNOWN loc_804C330; // weak
_UNKNOWN loc_804C35A; // weak
_UNKNOWN loc_804C375; // weak
_UNKNOWN loc_804C483; // weak
_UNKNOWN loc_804C48E; // weak
_UNKNOWN loc_804C55C; // weak
_UNKNOWN loc_804C58B; // weak
_UNKNOWN loc_804C598; // weak
_UNKNOWN loc_804C793; // weak
_UNKNOWN loc_804C7BD; // weak
_UNKNOWN loc_804C801; // weak
_UNKNOWN loc_804C81C; // weak
_UNKNOWN loc_804C92A; // weak
_UNKNOWN loc_804C949; // weak
_UNKNOWN loc_804CB7F; // weak
_UNKNOWN loc_804CB9B; // weak
_UNKNOWN loc_804CDAC; // weak
_UNKNOWN loc_804CEDE; // weak
_UNKNOWN loc_804D051; // weak
_UNKNOWN loc_804D0B0; // weak
_UNKNOWN loc_804D183; // weak
_UNKNOWN loc_804D5B4; // weak
_UNKNOWN loc_804D641; // weak
_UNKNOWN loc_804D65E; // weak
_UNKNOWN loc_804D71D; // weak
_UNKNOWN loc_804D734; // weak
_UNKNOWN loc_804D81A; // weak
_UNKNOWN loc_804D879; // weak
_UNKNOWN loc_804D8C7; // weak
_UNKNOWN loc_804D8F7; // weak
_UNKNOWN loc_804D999; // weak
_UNKNOWN loc_804D9C6; // weak
_UNKNOWN loc_804DA2E; // weak
_UNKNOWN loc_804DA32; // weak
_UNKNOWN loc_804DA8D; // weak
_UNKNOWN loc_804DB1F; // weak
_UNKNOWN loc_804DB53; // weak
_UNKNOWN loc_804DB9E; // weak
_UNKNOWN loc_804DC6D; // weak
_UNKNOWN loc_804DCE1; // weak
_UNKNOWN loc_804DE5B; // weak
_UNKNOWN loc_804DE6F; // weak
_UNKNOWN loc_804DEDB; // weak
_UNKNOWN loc_804DFF5; // weak
_UNKNOWN loc_804E09C; // weak
_UNKNOWN loc_804E0E5; // weak
_UNKNOWN loc_804E0F6; // weak
_UNKNOWN loc_804E1CE; // weak
_UNKNOWN loc_804E20A; // weak
_UNKNOWN loc_804E248; // weak
_UNKNOWN loc_804E288; // weak
_UNKNOWN loc_804E2B2; // weak
_UNKNOWN loc_804E2FA; // weak
_UNKNOWN loc_804E2FC; // weak
_UNKNOWN locret_804E4F7; // weak
_UNKNOWN loc_804E510; // weak
_UNKNOWN loc_804E54C; // weak
_UNKNOWN loc_804E5EA; // weak
_UNKNOWN loc_804E69D; // weak
_UNKNOWN loc_804E739; // weak
_UNKNOWN loc_804EAB5; // weak
_UNKNOWN loc_804EACF; // weak
_UNKNOWN loc_804ECA9; // weak
_UNKNOWN loc_804ED22; // weak
_UNKNOWN loc_804EEE2; // weak
_UNKNOWN loc_804EEFC; // weak
_UNKNOWN loc_804EF76; // weak
_UNKNOWN loc_804EFAB; // weak
_UNKNOWN loc_804EFCF; // weak
_UNKNOWN loc_804EFDA; // weak
_UNKNOWN loc_804F07D; // weak
_UNKNOWN loc_804F0A0; // weak
_UNKNOWN loc_804F0C4; // weak
_UNKNOWN loc_804F0D7; // weak
_UNKNOWN loc_804F259; // weak
_UNKNOWN loc_804F299; // weak
_UNKNOWN loc_804F31A; // weak
_UNKNOWN loc_804F345; // weak
_UNKNOWN loc_804F3B0; // weak
_UNKNOWN loc_804F3B7; // weak
_UNKNOWN loc_804F481; // weak
_UNKNOWN loc_804F4EA; // weak
_UNKNOWN loc_804F58F; // weak
_UNKNOWN loc_804FBEC; // weak
_UNKNOWN loc_804FC1A; // weak
_UNKNOWN loc_804FC4A; // weak
_UNKNOWN loc_804FC59; // weak
_UNKNOWN loc_804FC66; // weak
_UNKNOWN loc_804FDDC; // weak
_UNKNOWN loc_804FEB8; // weak
_UNKNOWN loc_804FF3E; // weak
_UNKNOWN loc_804FF92; // weak
_UNKNOWN loc_804FFC3; // weak
_UNKNOWN loc_805023A; // weak
_UNKNOWN loc_805025D; // weak
_UNKNOWN loc_80503D4; // weak
_UNKNOWN loc_80503DD; // weak
_UNKNOWN loc_8050423; // weak
_UNKNOWN loc_8050894; // weak
_UNKNOWN loc_80508D2; // weak
_UNKNOWN loc_805099B; // weak
_UNKNOWN loc_805099D; // weak
_UNKNOWN loc_80509ED; // weak
_UNKNOWN loc_8050A04; // weak
_UNKNOWN loc_8050A0B; // weak
_UNKNOWN loc_8050A54; // weak
_UNKNOWN loc_8050B3D; // weak
_UNKNOWN loc_8050B49; // weak
_UNKNOWN loc_8050C19; // weak
_UNKNOWN loc_8050C20; // weak
_UNKNOWN loc_8050C9A; // weak
_UNKNOWN loc_8050CA0; // weak
_UNKNOWN loc_80511E2; // weak
_UNKNOWN loc_80511FE; // weak
_UNKNOWN loc_805155E; // weak
_UNKNOWN loc_80515B9; // weak
_UNKNOWN loc_805161A; // weak
_UNKNOWN loc_8051639; // weak
_UNKNOWN loc_8051668; // weak
_UNKNOWN loc_8051688; // weak
_UNKNOWN loc_80516D7; // weak
_UNKNOWN loc_805174E; // weak
_UNKNOWN loc_8051A88; // weak
_UNKNOWN loc_8051B80; // weak
_UNKNOWN loc_8051B9C; // weak
_UNKNOWN loc_8051D5F; // weak
_UNKNOWN loc_8051DBF; // weak
_UNKNOWN loc_8051FB7; // weak
_UNKNOWN loc_8051FC5; // weak
_UNKNOWN loc_80521A4; // weak
_UNKNOWN locret_805234E; // weak
_UNKNOWN loc_8052513; // weak
_UNKNOWN loc_8052567; // weak
_UNKNOWN loc_805268A; // weak
_UNKNOWN loc_80526AB; // weak
_UNKNOWN loc_80526F4; // weak
_UNKNOWN loc_80526F6; // weak
_UNKNOWN loc_805275E; // weak
_UNKNOWN loc_8052775; // weak
_UNKNOWN loc_80527D1; // weak
_UNKNOWN loc_80527F8; // weak
_UNKNOWN loc_8052832; // weak
_UNKNOWN loc_805285C; // weak
_UNKNOWN loc_8052887; // weak
_UNKNOWN loc_80528AF; // weak
_UNKNOWN loc_8052905; // weak
_UNKNOWN loc_805298A; // weak
_UNKNOWN loc_80529EB; // weak
_UNKNOWN loc_8052A61; // weak
_UNKNOWN loc_8052ACB; // weak
_UNKNOWN loc_8052AD2; // weak
_UNKNOWN loc_8052B0A; // weak
_UNKNOWN loc_8052B1E; // weak
_UNKNOWN loc_8052B21; // weak
_UNKNOWN locret_8052B68; // weak
_UNKNOWN loc_8052BF0; // weak
_UNKNOWN locret_8052C0A; // weak
_UNKNOWN loc_8053014; // weak
_UNKNOWN loc_805306F; // weak
_UNKNOWN loc_80530B5; // weak
_UNKNOWN loc_805318C; // weak
_UNKNOWN loc_8053193; // weak
_UNKNOWN loc_80532F5; // weak
_UNKNOWN loc_805331E; // weak
_UNKNOWN loc_80535BA; // weak
_UNKNOWN loc_8053625; // weak
_UNKNOWN loc_8053699; // weak
_UNKNOWN loc_805369F; // weak
_UNKNOWN loc_80536BC; // weak
_UNKNOWN loc_8053AEB; // weak
_UNKNOWN loc_8053DD9; // weak
_UNKNOWN loc_8053E17; // weak
_UNKNOWN loc_8053F8B; // weak
_UNKNOWN loc_8053F92; // weak
_UNKNOWN loc_8053FC2; // weak
_UNKNOWN loc_80540B5; // weak
_UNKNOWN loc_8054180; // weak
_UNKNOWN loc_805418A; // weak
_UNKNOWN loc_8054336; // weak
_UNKNOWN loc_8054351; // weak
_UNKNOWN loc_80543F5; // weak
_UNKNOWN loc_8054565; // weak
_UNKNOWN loc_8054618; // weak
_UNKNOWN loc_8054643; // weak
_UNKNOWN loc_8054676; // weak
_UNKNOWN loc_8054689; // weak
_UNKNOWN loc_80546FC; // weak
_UNKNOWN loc_805472D; // weak
_UNKNOWN loc_80548B4; // weak
_UNKNOWN loc_80549C0; // weak
_UNKNOWN loc_8054D9F; // weak
_UNKNOWN loc_8054DC3; // weak
_UNKNOWN loc_8054E3E; // weak
_UNKNOWN loc_8054E71; // weak
_UNKNOWN loc_8054E95; // weak
_UNKNOWN loc_8054FE4; // weak
_UNKNOWN loc_8054FE9; // weak
_UNKNOWN loc_805541C; // weak
_UNKNOWN loc_8055440; // weak
_UNKNOWN loc_805566B; // weak
_UNKNOWN loc_8055681; // weak
_UNKNOWN loc_8055905; // weak
_UNKNOWN loc_8055939; // weak
_UNKNOWN locret_805596A; // weak
_UNKNOWN loc_8055A27; // weak
_UNKNOWN loc_8055B00; // weak
_UNKNOWN loc_8055CAB; // weak
_UNKNOWN loc_8055D39; // weak
_UNKNOWN loc_8055D46; // weak
_UNKNOWN loc_8055E14; // weak
_UNKNOWN loc_8056274; // weak
_UNKNOWN loc_80562BC; // weak
_UNKNOWN loc_8057160; // weak
_UNKNOWN loc_8057193; // weak
_UNKNOWN locret_8057205; // weak
_UNKNOWN loc_8057261; // weak
_UNKNOWN loc_805728C; // weak
_UNKNOWN loc_8057362; // weak
_UNKNOWN loc_80573F2; // weak
_UNKNOWN loc_805740C; // weak
_UNKNOWN loc_8057463; // weak
_UNKNOWN loc_805747F; // weak
_UNKNOWN locret_80574BC; // weak
_UNKNOWN loc_80575CA; // weak
_UNKNOWN loc_80575DE; // weak
_UNKNOWN loc_805763B; // weak
_UNKNOWN loc_8057643; // weak
_UNKNOWN loc_80576A4; // weak
_UNKNOWN loc_80576BE; // weak
_UNKNOWN loc_80576C1; // weak
_UNKNOWN loc_805775E; // weak
_UNKNOWN loc_8057763; // weak
_UNKNOWN locret_8057766; // weak
_UNKNOWN loc_8057816; // weak
_UNKNOWN loc_8057842; // weak
_UNKNOWN loc_8057E73; // weak
_UNKNOWN loc_8057E7D; // weak
_UNKNOWN locret_8057F82; // weak
_UNKNOWN loc_805803F; // weak
_UNKNOWN loc_8058049; // weak
_UNKNOWN loc_8058588; // weak
_UNKNOWN loc_80585AF; // weak
_UNKNOWN loc_80585BD; // weak
_UNKNOWN locret_80585D0; // weak
_UNKNOWN loc_8058615; // weak
_UNKNOWN loc_80586A9; // weak
_UNKNOWN loc_80586DA; // weak
_UNKNOWN loc_80586DF; // weak
_UNKNOWN loc_8058798; // weak
_UNKNOWN loc_8058800; // weak
_UNKNOWN loc_805880A; // weak
_UNKNOWN loc_8058B6B; // weak
_UNKNOWN loc_8058B72; // weak
_UNKNOWN loc_8058C90; // weak
_UNKNOWN loc_8058CAC; // weak
_UNKNOWN loc_8058E6A; // weak
_UNKNOWN loc_8058E70; // weak
_UNKNOWN locret_8058E87; // weak
_UNKNOWN loc_805918A; // weak
_UNKNOWN loc_80591B0; // weak
_UNKNOWN loc_80594D5; // weak
_UNKNOWN loc_80594F1; // weak
_UNKNOWN loc_80595EC; // weak
_UNKNOWN loc_80595F1; // weak
_UNKNOWN loc_8059634; // weak
_UNKNOWN loc_8059639; // weak
_UNKNOWN loc_8059707; // weak
_UNKNOWN loc_805971E; // weak
_UNKNOWN loc_8059740; // weak
_UNKNOWN loc_8059766; // weak
_UNKNOWN loc_805976B; // weak
_UNKNOWN loc_80597E7; // weak
_UNKNOWN loc_80597EF; // weak
_UNKNOWN loc_8059894; // weak
_UNKNOWN loc_805989A; // weak
_UNKNOWN locret_80598BF; // weak
_UNKNOWN loc_8059973; // weak
_UNKNOWN loc_8059988; // weak
_UNKNOWN locret_8059A5B; // weak
_UNKNOWN loc_8059B0A; // weak
_UNKNOWN loc_8059B81; // weak
_UNKNOWN loc_8059C24; // weak
_UNKNOWN loc_8059C56; // weak
_UNKNOWN loc_8059CEA; // weak
_UNKNOWN loc_8059E2F; // weak
_UNKNOWN loc_8059ECD; // weak
_UNKNOWN locret_8059F1D; // weak
_UNKNOWN loc_8059F43; // weak
_UNKNOWN loc_805A04C; // weak
_UNKNOWN loc_805A0A2; // weak
_UNKNOWN loc_805A19E; // weak
_UNKNOWN loc_805A1A3; // weak
_UNKNOWN loc_805A507; // weak
_UNKNOWN loc_805A54A; // weak
_UNKNOWN loc_805A5A6; // weak
_UNKNOWN loc_805A5BD; // weak
_UNKNOWN loc_805A5D8; // weak
_UNKNOWN loc_805A621; // weak
_UNKNOWN loc_805A68D; // weak
_UNKNOWN loc_805A6F4; // weak
_UNKNOWN loc_805A73D; // weak
_UNKNOWN loc_805A790; // weak
_UNKNOWN loc_805A7D0; // weak
_UNKNOWN loc_805A82F; // weak
_UNKNOWN loc_805A899; // weak
_UNKNOWN loc_805A89E; // weak
_UNKNOWN loc_805A911; // weak
_UNKNOWN loc_805A9E0; // weak
_UNKNOWN loc_805A9F1; // weak
_UNKNOWN loc_805AA10; // weak
_UNKNOWN loc_805AA1C; // weak
_UNKNOWN loc_805AA52; // weak
_UNKNOWN loc_805AA62; // weak
_UNKNOWN loc_805AAB2; // weak
_UNKNOWN loc_805AACF; // weak
_UNKNOWN loc_805AAFB; // weak
_UNKNOWN loc_805AB2B; // weak
_UNKNOWN loc_805AB38; // weak
_UNKNOWN loc_805AB86; // weak
_UNKNOWN loc_805AC5A; // weak
_UNKNOWN loc_805AC71; // weak
_UNKNOWN loc_805ACED; // weak
_UNKNOWN loc_805AD2B; // weak
_UNKNOWN loc_805AD53; // weak
_UNKNOWN loc_805AD57; // weak
_UNKNOWN loc_805AD87; // weak
_UNKNOWN loc_805ADFF; // weak
_UNKNOWN loc_805AE53; // weak
_UNKNOWN loc_805AF61; // weak
_UNKNOWN loc_805B03F; // weak
_UNKNOWN loc_805B0AF; // weak
_UNKNOWN loc_805B0FD; // weak
_UNKNOWN loc_805B11A; // weak
_UNKNOWN loc_805B15C; // weak
_UNKNOWN loc_805B1A5; // weak
_UNKNOWN loc_805B1D6; // weak
_UNKNOWN loc_805B219; // weak
_UNKNOWN loc_805B231; // weak
_UNKNOWN loc_805B484; // weak
_UNKNOWN loc_805B48F; // weak
_UNKNOWN loc_805B5B9; // weak
_UNKNOWN loc_805B5C0; // weak
_UNKNOWN loc_805BD6D; // weak
_UNKNOWN loc_805C01F; // weak
_UNKNOWN loc_805C057; // weak
_UNKNOWN locret_805C0DD; // weak
_UNKNOWN loc_805C17D; // weak
_UNKNOWN loc_805CAA7; // weak
_UNKNOWN loc_805CD73; // weak
_UNKNOWN loc_805D0C9; // weak
_UNKNOWN loc_805D146; // weak
_UNKNOWN loc_805D2DA; // weak
_UNKNOWN loc_805D2E7; // weak
_UNKNOWN locret_805D526; // weak
_UNKNOWN loc_805D55F; // weak
_UNKNOWN loc_805D594; // weak
_UNKNOWN loc_805D5B3; // weak
_UNKNOWN loc_805D649; // weak
_UNKNOWN loc_805D7F5; // weak
_UNKNOWN loc_805DB4E; // weak
_UNKNOWN loc_805DB78; // weak
_UNKNOWN loc_805E130; // weak
_UNKNOWN loc_805E1B8; // weak
_UNKNOWN loc_805E438; // weak
_UNKNOWN loc_805E442; // weak
_UNKNOWN locret_805E4BF; // weak
_UNKNOWN loc_805E8DD; // weak
_UNKNOWN loc_805E8E5; // weak
_UNKNOWN loc_805E9F8; // weak
_UNKNOWN loc_805EA63; // weak
_UNKNOWN loc_805EAF6; // weak
_UNKNOWN loc_805ED43; // weak
_UNKNOWN locret_805ED73; // weak
_UNKNOWN loc_805EDB3; // weak
_UNKNOWN loc_805EDD1; // weak
_UNKNOWN loc_805EFFF; // weak
_UNKNOWN loc_805F009; // weak
_UNKNOWN loc_805F4CA; // weak
_UNKNOWN loc_805F585; // weak
_UNKNOWN loc_805F612; // weak
_UNKNOWN loc_805F63C; // weak
_UNKNOWN loc_805F69F; // weak
_UNKNOWN loc_805F6C1; // weak
_UNKNOWN loc_805F6CE; // weak
_UNKNOWN locret_805F7F8; // weak
_UNKNOWN loc_805F854; // weak
_UNKNOWN locret_805F86B; // weak
_UNKNOWN loc_805F88F; // weak
_UNKNOWN loc_805F8A9; // weak
_UNKNOWN loc_805F964; // weak
_UNKNOWN loc_805F981; // weak
_UNKNOWN loc_805FB4D; // weak
_UNKNOWN loc_805FC21; // weak
_UNKNOWN loc_805FC63; // weak
_UNKNOWN loc_806000A; // weak
_UNKNOWN loc_8060019; // weak
_UNKNOWN loc_80602B7; // weak
_UNKNOWN loc_80602D3; // weak
_UNKNOWN loc_8060314; // weak
_UNKNOWN loc_8060316; // weak
_UNKNOWN loc_8060331; // weak
_UNKNOWN loc_806039C; // weak
_UNKNOWN loc_80603D2; // weak
_UNKNOWN loc_80603DD; // weak
_UNKNOWN loc_80603E4; // weak
_UNKNOWN loc_806056B; // weak
_UNKNOWN loc_80605A5; // weak
_UNKNOWN loc_80605C5; // weak
_UNKNOWN loc_8060644; // weak
_UNKNOWN loc_8060706; // weak
_UNKNOWN loc_8060725; // weak
_UNKNOWN loc_8060739; // weak
_UNKNOWN loc_80607C0; // weak
_UNKNOWN loc_80607D4; // weak
_UNKNOWN loc_8060836; // weak
_UNKNOWN loc_806083D; // weak
_UNKNOWN loc_80608C0; // weak
_UNKNOWN loc_80608D1; // weak
_UNKNOWN loc_8060A27; // weak
_UNKNOWN loc_8060A30; // weak
_UNKNOWN loc_8060A57; // weak
_UNKNOWN loc_8060A90; // weak
_UNKNOWN loc_8060BF4; // weak
_UNKNOWN loc_8060C50; // weak
_UNKNOWN loc_8060C94; // weak
_UNKNOWN loc_8060CD6; // weak
_UNKNOWN loc_8060CDD; // weak
_UNKNOWN loc_8060E7F; // weak
_UNKNOWN locret_8060E8A; // weak
_UNKNOWN loc_80610FC; // weak
_UNKNOWN loc_806112C; // weak
_UNKNOWN loc_80612AB; // weak
_UNKNOWN loc_80613D9; // weak
_UNKNOWN loc_806140F; // weak
_UNKNOWN loc_8061480; // weak
char locale = '\0'; // idb
struct option longopts = { "ignore-leading-blanks", 0, NULL, 98 }; // idb
char *off_8063294[3] = { "quiet", "silent", "diagnose-first" }; // weak
char aCccgeneralNume[19] = "CCcgeneral-numeric"; // weak
void *off_80632DC = (void *)0x80632A7; // weak
char byte_80632F8[6] = { 'g', 'h', 'M', 'n', 'R', 'V' }; // idb
char byte_8063568[256] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x06',
  '\0',
  '\x03',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0',
  '\x04',
  '\0',
  '\0',
  '\0',
  '\0',
  '\b',
  '\a',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
int sig[11] = { 14, 1, 2, 13, 3, 15, 29, 27, 26, 24, 25 }; // idb
_UNKNOWN unk_80641E8; // weak
_UNKNOWN unk_8064238; // weak
_UNKNOWN unk_806444D; // weak
void *off_8064BF4 = &loc_805EB05; // weak
_UNKNOWN unk_8065137; // weak
int dword_8065F00 = 572797482; // weak
_UNKNOWN unk_806637C; // weak
_UNKNOWN unk_806637F; // weak
_UNKNOWN unk_80673B8; // weak
_UNKNOWN unk_80673BB; // weak
_UNKNOWN unk_80683C4; // weak
_UNKNOWN unk_80683C7; // weak
int (*off_806AEC0[2])() = { &sub_804A030, &sub_804A010 }; // weak
int (*off_806AEC4)() = &sub_804A010; // weak
Elf32_Dyn stru_806AEFC = { 26, { 134655684u } }; // weak
Elf32_Dyn stru_806AF04 = { 28, { 4u } }; // weak
int (*dword_806B008)(void) = NULL; // weak
int dword_806B20C = 0; // weak
int dword_806B220 = 0; // weak
int dword_806B234 = 0; // weak
int dword_806B248 = 0; // weak
int dword_806B25C = 0; // weak
int dword_806B270 = 0; // weak
int dword_806B284 = 0; // weak
int dword_806B298 = 0; // weak
int dword_806B2B8 = 0; // weak
int dword_806B2CC = 0; // weak
int dword_806B2E0 = 0; // weak
int dword_806B2F4 = 0; // weak
int dword_806B308 = 0; // weak
int dword_806B31C = 0; // weak
int dword_806B334 = 0; // weak
char byte_806B350 = '\n'; // weak
char *off_806B370 = "APR"; // weak
int dword_806B374[] = { 4 }; // weak
size_t dword_806B3D0 = 262144u; // idb
int dword_806B3D4 = 128; // weak
int dword_806B3D8 = 16; // idb
int *off_806B3DC = &dword_806C070; // weak
char byte_806B3E0 = 'X'; // weak
char byte_806B3EA = '\0'; // weak
int off_806B3F0 = 134627680; // idb
int off_806B3F4 = 134567986; // idb
int status = 1; // idb
int dword_806B410 = 1; // weak
int dword_806B414 = 256; // weak
void *off_806B418 = &unk_806C190; // weak
int *off_806B41C = &dword_806B414; // weak
_UNKNOWN unk_806B430; // weak
_UNKNOWN unk_806B450; // weak
_UNKNOWN unk_806B453; // weak
_UNKNOWN unk_806B458; // weak
_UNKNOWN unk_806B45B; // weak
_UNKNOWN unk_806B464; // weak
_UNKNOWN unk_806B467; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int program_invocation_name; // weak
int optind; // weak
FILE *stdin; // idb
FILE *stdout; // idb
int (*obstack_alloc_failed_handler)(void); // weak
char *optarg; // idb
char byte_806B4EC; // weak
_UNKNOWN unk_806B6A4; // weak
_UNKNOWN unk_806BAE6; // weak
int dword_806BBB0; // weak
int dword_806BBB4; // weak
char byte_806BBB8; // weak
char byte_806BBB9; // weak
int dword_806BBBC; // weak
int dword_806BBC0; // weak
int dword_806BBC4; // weak
int dword_806BBC8; // weak
char byte_806BBD0[256]; // idb
_UNKNOWN unk_806BCD0; // weak
_UNKNOWN unk_806BDD0; // weak
char byte_806BED0[256]; // idb
size_t size; // idb
int dword_806BFD4; // weak
int dword_806BFD8; // weak
int dword_806BFDC; // weak
char byte_806BFE0; // weak
char byte_806BFE1; // weak
char byte_806BFE2; // weak
char byte_806BFE3; // weak
int dword_806BFE4; // weak
char *arg; // idb
char byte_806BFEC; // weak
__sigset_t set; // idb
int dword_806C070; // weak
int dword_806C074; // weak
int dword_806C078; // weak
_UNKNOWN unk_806C090; // weak
int dword_806C12C; // weak
int dword_806C130; // weak
int dword_806C134; // weak
char byte_806C138; // weak
int dword_806C13C; // weak
int dword_806C140; // weak
int dword_806C150; // weak
int dword_806C154; // weak
int dword_806C158; // weak
int dword_806C15C; // weak
int dword_806C160; // weak
int dword_806C164; // weak
int dword_806C168; // weak
int dword_806C16C; // weak
int dword_806C170; // weak
int dword_806C174; // weak
int dword_806C178; // weak
int dword_806C17C; // weak
_UNKNOWN unk_806C190; // weak
int dword_806C290; // weak
int dword_806C294; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (0804972C) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 8049F30: using guessed type int _gmon_start__(void);

//----- (08049750) --------------------------------------------------------
int sub_8049750()
{
  return dword_806B008();
}
// 806B008: using guessed type int (*dword_806B008)(void);

//----- (08049F40) --------------------------------------------------------
#error "8049F43: positive sp value has been found (funcsize=2)"

//----- (08049F73) --------------------------------------------------------
void sub_8049F73()
{
  ;
}

//----- (08049F90) --------------------------------------------------------
void sub_8049F90()
{
  ;
}

//----- (08049FA0) --------------------------------------------------------
int sub_8049FA0()
{
  int result; // eax

  result = &unk_806B467 - &unk_806B464;
  if ( (unsigned int)(&unk_806B467 - &unk_806B464) > 6 )
    result = 0;
  return result;
}
// 8049FA0: could not find valid save-restore pair for ebp

//----- (0804A010) --------------------------------------------------------
int sub_804A010()
{
  int result; // eax

  if ( !byte_806B4EC )
  {
    result = sub_8049FA0();
    byte_806B4EC = 1;
  }
  return result;
}
// 804A010: could not find valid save-restore pair for ebp
// 806B4EC: using guessed type char byte_806B4EC;

//----- (0804A030) --------------------------------------------------------
int sub_804A030()
{
  return 0;
}
// 804A030: could not find valid save-restore pair for ebp

//----- (0804A08F) --------------------------------------------------------
void sub_804A08F()
{
  ;
}

//----- (0804A0AA) --------------------------------------------------------
void sub_804A0AA()
{
  ;
}

//----- (0804A0BA) --------------------------------------------------------
int sub_804A0BA()
{
  int result; // eax

  result = &unk_806B453 - &unk_806B450;
  if ( (unsigned int)(&unk_806B453 - &unk_806B450) > 6 )
    result = 0;
  return result;
}
// 804A0BA: could not find valid save-restore pair for ebp

//----- (0804A19C) --------------------------------------------------------
void sub_804A19C()
{
  ;
}

//----- (0804A1B7) --------------------------------------------------------
void sub_804A1B7()
{
  ;
}

//----- (0804A1C7) --------------------------------------------------------
signed int sub_804A1C7()
{
  return 3;
}
// 804A1C7: could not find valid save-restore pair for ebp

//----- (0804A2A9) --------------------------------------------------------
void sub_804A2A9()
{
  ;
}

//----- (0804A2C4) --------------------------------------------------------
void sub_804A2C4()
{
  ;
}

//----- (0804A2D4) --------------------------------------------------------
int sub_804A2D4()
{
  int result; // eax

  result = &unk_806B453 - &unk_806B450;
  if ( (unsigned int)(&unk_806B453 - &unk_806B450) > 6 )
    result = 0;
  return result;
}
// 804A2D4: could not find valid save-restore pair for ebp

//----- (0804A3B6) --------------------------------------------------------
void sub_804A3B6()
{
  ;
}

//----- (0804A3D1) --------------------------------------------------------
void sub_804A3D1()
{
  ;
}

//----- (0804A3E1) --------------------------------------------------------
int sub_804A3E1()
{
  int result; // eax

  result = &unk_806B453 - &unk_806B450;
  if ( (unsigned int)(&unk_806B453 - &unk_806B450) > 6 )
    result = 0;
  return result;
}
// 804A3E1: could not find valid save-restore pair for ebp

//----- (0804A4C3) --------------------------------------------------------
void sub_804A4C3()
{
  ;
}

//----- (0804A4DE) --------------------------------------------------------
void sub_804A4DE()
{
  ;
}

//----- (0804A4EE) --------------------------------------------------------
int sub_804A4EE()
{
  int result; // eax

  result = &unk_806B6A4 - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_806B6A4 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 804A4EE: could not find valid save-restore pair for ebp
// 806B480: using guessed type int program_invocation_short_name;

//----- (0804A5D0) --------------------------------------------------------
void sub_804A5D0()
{
  ;
}

//----- (0804A5EB) --------------------------------------------------------
void sub_804A5EB()
{
  ;
}

//----- (0804A5FB) --------------------------------------------------------
int __usercall sub_804A5FB@<eax>(double a1@<st0>)
{
  int result; // eax
  int (__stdcall *v2)(void *, int, int, int, int, int); // eax
  int v3; // [esp+4h] [ebp-18h]
  int v4; // [esp+8h] [ebp-14h]
  int v5; // [esp+Ch] [ebp-10h]
  int v6; // [esp+10h] [ebp-Ch]
  int v7; // [esp+14h] [ebp-8h]
  int v8; // [esp+18h] [ebp-4h]

  result = &unk_806B453 - &unk_806B450;
  if ( (unsigned int)(&unk_806B453 - &unk_806B450) > 6 )
  {
    v8 = 0;
    dword_806B20C = (int)&locret_804A60A;
    v2 = (int (__stdcall *)(void *, int, int, int, int, int))sub_8061C98(a1);
    result = v2(&unk_806B450, v3, v4, v5, v6, v7);
  }
  return result;
}
// 8061C98: using guessed type int __usercall sub_8061C98@<eax>(double@<st0>);
// 806B20C: using guessed type int dword_806B20C;

//----- (0804A6F6) --------------------------------------------------------
void sub_804A6F6()
{
  ;
}

//----- (0804A711) --------------------------------------------------------
void sub_804A711()
{
  ;
}

//----- (0804A721) --------------------------------------------------------
int sub_804A721()
{
  int result; // eax

  result = &unk_806B453 - &unk_806B450;
  if ( (unsigned int)(&unk_806B453 - &unk_806B450) > 6 )
    result = 0;
  return result;
}
// 804A721: could not find valid save-restore pair for ebp

//----- (0804A81F) --------------------------------------------------------
void sub_804A81F()
{
  ;
}

//----- (0804A83A) --------------------------------------------------------
void sub_804A83A()
{
  ;
}

//----- (0804A84A) --------------------------------------------------------
int sub_804A84A()
{
  int result; // eax

  result = &unk_80683C7 - &unk_80683C4;
  if ( (unsigned int)(&unk_80683C7 - &unk_80683C4) > 6 )
    result = 0;
  return result;
}
// 804A84A: could not find valid save-restore pair for ebp

//----- (0804A92C) --------------------------------------------------------
void sub_804A92C()
{
  ;
}

//----- (0804A947) --------------------------------------------------------
void sub_804A947()
{
  ;
}

//----- (0804A957) --------------------------------------------------------
int sub_804A957()
{
  int result; // eax
  int (__stdcall *v1)(void *, int, int, int, int, int); // eax
  int v2; // [esp+4h] [ebp-18h]
  int v3; // [esp+8h] [ebp-14h]
  int v4; // [esp+Ch] [ebp-10h]
  int v5; // [esp+10h] [ebp-Ch]
  int v6; // [esp+14h] [ebp-8h]
  int v7; // [esp+18h] [ebp-4h]

  result = &unk_80673BB - &unk_80673B8;
  if ( (unsigned int)(&unk_80673BB - &unk_80673B8) > 6 )
  {
    v7 = 0;
    dword_806B234 = (int)&locret_804A966;
    v1 = (int (__stdcall *)(void *, int, int, int, int, int))sub_8061BAC();
    result = v1(&unk_80673B8, v2, v3, v4, v5, v6);
  }
  return result;
}
// 8061BAC: using guessed type int sub_8061BAC(void);
// 806B234: using guessed type int dword_806B234;

//----- (0804AA8F) --------------------------------------------------------
void sub_804AA8F()
{
  ;
}

//----- (0804AAAA) --------------------------------------------------------
void sub_804AAAA()
{
  ;
}

//----- (0804AABA) --------------------------------------------------------
int __fastcall sub_804AABA(int a1, int a2)
{
  int result; // eax
  int (__stdcall *v3)(void *, int, int, int, int, int); // eax
  int v4; // [esp+4h] [ebp-18h]
  int v5; // [esp+8h] [ebp-14h]
  int v6; // [esp+Ch] [ebp-10h]
  int v7; // [esp+10h] [ebp-Ch]
  int v8; // [esp+14h] [ebp-8h]
  int v9; // [esp+18h] [ebp-4h]

  result = &unk_806B453 - &unk_806B450;
  if ( (unsigned int)(&unk_806B453 - &unk_806B450) > 6 )
  {
    v9 = 0;
    dword_806B270 = (int)&locret_804AAC9;
    v3 = (int (__stdcall *)(void *, int, int, int, int, int))sub_8061A4C(a1, a2);
    result = v3(&unk_806B450, v4, v5, v6, v7, v8);
  }
  return result;
}
// 8061A4C: using guessed type int __fastcall sub_8061A4C(_DWORD, _DWORD);
// 806B270: using guessed type int dword_806B270;

//----- (0804AB3A) --------------------------------------------------------
int __usercall sub_804AB3A@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_806B450, a1);
}

//----- (0804AC07) --------------------------------------------------------
void sub_804AC07()
{
  ;
}

//----- (0804AC22) --------------------------------------------------------
void sub_804AC22()
{
  ;
}

//----- (0804AC32) --------------------------------------------------------
int sub_804AC32()
{
  int result; // eax

  result = &unk_806B453 - &unk_806B450;
  if ( (unsigned int)(&unk_806B453 - &unk_806B450) > 6 )
    result = 0;
  return result;
}
// 804AC32: could not find valid save-restore pair for ebp

//----- (0804AC99) --------------------------------------------------------
int __usercall sub_804AC99@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_806B450, a1);
}

//----- (0804AD49) --------------------------------------------------------
void sub_804AD49()
{
  ;
}

//----- (0804AD64) --------------------------------------------------------
void sub_804AD64()
{
  ;
}

//----- (0804AD74) --------------------------------------------------------
int sub_804AD74()
{
  int result; // eax

  result = &unk_806637F - &unk_806637C;
  if ( (unsigned int)(&unk_806637F - &unk_806637C) > 6 )
    result = 0;
  return result;
}
// 804AD74: could not find valid save-restore pair for ebp

//----- (0804ADF4) --------------------------------------------------------
int __usercall sub_804ADF4@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_806637C, a1);
}

//----- (0804AEA2) --------------------------------------------------------
void sub_804AEA2()
{
  ;
}

//----- (0804AEBD) --------------------------------------------------------
void sub_804AEBD()
{
  ;
}

//----- (0804AECD) --------------------------------------------------------
int __fastcall sub_804AECD(int a1, int a2)
{
  int result; // eax
  int (__stdcall *v3)(void *, int, int, int, int, int); // eax
  int v4; // [esp+4h] [ebp-18h]
  int v5; // [esp+8h] [ebp-14h]
  int v6; // [esp+Ch] [ebp-10h]
  int v7; // [esp+10h] [ebp-Ch]
  int v8; // [esp+14h] [ebp-8h]
  int v9; // [esp+18h] [ebp-4h]

  result = &unk_806B453 - &unk_806B450;
  if ( (unsigned int)(&unk_806B453 - &unk_806B450) > 6 )
  {
    v9 = 0;
    dword_806B270 = (int)&locret_804AEDC;
    v3 = (int (__stdcall *)(void *, int, int, int, int, int))sub_8061A4C(a1, a2);
    result = v3(&unk_806B450, v4, v5, v6, v7, v8);
  }
  return result;
}
// 8061A4C: using guessed type int __fastcall sub_8061A4C(_DWORD, _DWORD);
// 806B270: using guessed type int dword_806B270;

//----- (0804AFC8) --------------------------------------------------------
void sub_804AFC8()
{
  ;
}

//----- (0804AFE3) --------------------------------------------------------
void sub_804AFE3()
{
  ;
}

//----- (0804AFF3) --------------------------------------------------------
int __fastcall sub_804AFF3(int a1, int a2)
{
  int result; // eax
  int (__stdcall *v3)(void *, int, int, int, int, int); // eax
  int v4; // [esp+4h] [ebp-18h]
  int v5; // [esp+8h] [ebp-14h]
  int v6; // [esp+Ch] [ebp-10h]
  int v7; // [esp+10h] [ebp-Ch]
  int v8; // [esp+14h] [ebp-8h]
  int v9; // [esp+18h] [ebp-4h]

  result = &unk_806B453 - &unk_806B450;
  if ( (unsigned int)(&unk_806B453 - &unk_806B450) > 6 )
  {
    v9 = 0;
    dword_806B270 = (int)&locret_804B002;
    v3 = (int (__stdcall *)(void *, int, int, int, int, int))sub_8061A4C(a1, a2);
    result = v3(&unk_806B450, v4, v5, v6, v7, v8);
  }
  return result;
}
// 8061A4C: using guessed type int __fastcall sub_8061A4C(_DWORD, _DWORD);
// 806B270: using guessed type int dword_806B270;

//----- (0804B0CB) --------------------------------------------------------
int __usercall sub_804B0CB@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  a1(&dword_8065F00);
  return 0;
}
// 8065F00: using guessed type int dword_8065F00;

//----- (0804B0E5) --------------------------------------------------------
int __usercall sub_804B0E5@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_806B450, a1);
}

//----- (0804B12C) --------------------------------------------------------
void sub_804B12C()
{
  ;
}

//----- (0804B147) --------------------------------------------------------
void sub_804B147()
{
  ;
}

//----- (0804B157) --------------------------------------------------------
int sub_804B157()
{
  int result; // eax

  result = &unk_806BAE6 - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_806BAE6 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 804B157: could not find valid save-restore pair for ebp
// 806B480: using guessed type int program_invocation_short_name;

//----- (0804B275) --------------------------------------------------------
void sub_804B275()
{
  ;
}

//----- (0804B290) --------------------------------------------------------
void sub_804B290()
{
  ;
}

//----- (0804B2A0) --------------------------------------------------------
int sub_804B2A0()
{
  int result; // eax

  result = &unk_806B45B - &unk_806B458;
  if ( (unsigned int)(&unk_806B45B - &unk_806B458) > 6 )
    result = 0;
  return result;
}
// 804B2A0: could not find valid save-restore pair for ebp

//----- (0804B320) --------------------------------------------------------
int __usercall sub_804B320@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_806B458, a1);
}

//----- (0804B389) --------------------------------------------------------
int __usercall sub_804B389@<eax>(int edx0@<edx>, int a2@<ecx>, int a1)
{
  void *v3; // eax
  int result; // eax

  v3 = &loc_804B3AB;
  if ( a1 == 1 )
    v3 = &loc_804B3B3;
  dword_806B298 = (int)v3;
  sub_8061955(a2, edx0);
  result = a1;
  status = a1;
  return result;
}
// 806B298: using guessed type int dword_806B298;

//----- (0804B3B5) --------------------------------------------------------
int __cdecl sub_804B3B5(unsigned __int8 a1)
{
  return a1;
}

//----- (0804B3C7) --------------------------------------------------------
int __cdecl sub_804B3C7(unsigned __int8 a1)
{
  return (*__ctype_b_loc())[a1] & 1 || a1 == 10;
}

//----- (0804B427) --------------------------------------------------------
char *__cdecl sub_804B427(unsigned __int64 a1)
{
  char *result; // eax

  if ( HIDWORD(a1) )
    result = sub_806123A(a1, 1000000LL) + 1000000;
  else
    result = (char *)a1;
  return result;
}

//----- (0804B46D) --------------------------------------------------------
int sub_804B46D()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nWith no FILE, or when FILE is -, read standard input.\n");
  return fputs_unlocked(v1, v0);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804B498) --------------------------------------------------------
int sub_804B498()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nMandatory arguments to long options are mandatory for short options too.\n");
  return fputs_unlocked(v1, v0);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804B4C3) --------------------------------------------------------
int __cdecl sub_804B4C3(char *s1)
{
  bool v1; // zf
  void *v2; // eax
  char *v3; // eax
  int v4; // edx
  int v5; // ecx
  void *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // ebx
  char *v10; // eax
  const char *v12; // [esp+1Ch] [ebp-4Ch]
  const char *v13; // [esp+24h] [ebp-44h]
  const char *v14; // [esp+28h] [ebp-40h]
  const char *v15; // [esp+2Ch] [ebp-3Ch]
  const char *v16; // [esp+30h] [ebp-38h]
  const char *v17; // [esp+34h] [ebp-34h]
  const char *v18; // [esp+38h] [ebp-30h]
  const char *v19; // [esp+3Ch] [ebp-2Ch]
  const char *v20; // [esp+40h] [ebp-28h]
  const char *v21; // [esp+44h] [ebp-24h]
  const char *v22; // [esp+48h] [ebp-20h]
  const char *v23; // [esp+4Ch] [ebp-1Ch]
  const char *v24; // [esp+50h] [ebp-18h]
  const char *v25; // [esp+54h] [ebp-14h]
  int v26; // [esp+58h] [ebp-10h]
  int v27; // [esp+5Ch] [ebp-Ch]

  v14 = "[";
  v15 = "test invocation";
  v16 = "coreutils";
  v17 = "Multi-call invocation";
  v18 = "sha224sum";
  v19 = "sha2 utilities";
  v20 = "sha256sum";
  v21 = "sha2 utilities";
  v22 = "sha384sum";
  v23 = "sha2 utilities";
  v24 = "sha512sum";
  v25 = "sha2 utilities";
  v26 = 0;
  v27 = 0;
  v12 = s1;
  if ( "[" )
  {
    v1 = strcmp(s1, v14) == 0;
    v2 = &loc_804B578;
    if ( !v1 )
      v2 = &loc_804B53A;
    dword_806B248 = (int)v2;
    sub_8061B34();
  }
  if ( v15 )
    v12 = v15;
  v3 = gettext("\n%s online help: <%s>\n");
  printf(v3, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  v13 = setlocale(5, 0);
  if ( v13 )
  {
    v1 = strncmp(v13, "en_", 3u) == 0;
    v6 = &loc_804B604;
    if ( v1 )
      v6 = &loc_804B61F;
    dword_806B2E0 = (int)v6;
    sub_806174E(v5, v4);
    v7 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
    printf(v7, s1);
  }
  v8 = gettext("Full documentation at: <%s%s>\n");
  printf(v8, "http://www.gnu.org/software/coreutils/", s1);
  if ( v12 == s1 )
    v9 = " invocation";
  else
    v9 = &locale;
  v10 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  return printf(v10, v12, v9);
}
// 806174E: using guessed type int __fastcall sub_806174E(_DWORD, _DWORD);
// 8061B34: using guessed type int sub_8061B34(void);
// 806B248: using guessed type int dword_806B248;
// 806B2E0: using guessed type int dword_806B2E0;

//----- (0804B67B) --------------------------------------------------------
void __cdecl __noreturn sub_804B67B(int a1, const char *a2)
{
  size_t v2; // eax
  char v3; // [esp+30h] [ebp-18h]
  unsigned int v4; // [esp+3Ch] [ebp-Ch]

  v4 = __readgsdword(0x14u);
  v2 = strlen(a2);
  write(2, a2, v2);
  if ( a1 )
    sub_80591C6(a1, (int)&v3);
  write(2, "\n", 1u);
  _exit(2);
}

//----- (0804B777) --------------------------------------------------------
void __cdecl __noreturn sub_804B777(int a1, char *a2)
{
  int v2; // edx
  int v3; // ecx
  void *v4; // ebx
  int v5; // eax
  int v6; // [esp+Ch] [ebp-1Ch]
  void *v7; // [esp+10h] [ebp-18h]

  if ( !a2 )
  {
    gettext("standard output");
    dword_806B284 = (int)&loc_804B7C1;
    sub_80619DA(v3, v2);
  }
  v4 = sub_805BA91(0, 3, a2);
  v5 = *__errno_location();
  v7 = v4;
  v6 = a1;
  error(2, v5, "%s: %s", a1, v4);
  sub_804B802(a1);
}
// 80619DA: using guessed type double __fastcall sub_80619DA(_DWORD, _DWORD);
// 806B284: using guessed type int dword_806B284;

//----- (0804B802) --------------------------------------------------------
void __cdecl __noreturn sub_804B802(int status)
{
  int v1; // ebx
  char *v2; // eax
  int v3; // esi
  int v4; // ebx
  char *v5; // eax
  FILE *v6; // ebx
  char *v7; // eax
  FILE *v8; // ebx
  char *v9; // eax
  FILE *v10; // ebx
  char *v11; // eax
  FILE *v12; // ebx
  char *v13; // eax
  FILE *v14; // ebx
  char *v15; // eax
  FILE *v16; // ebx
  char *v17; // eax
  FILE *v18; // ebx
  char *v19; // eax
  FILE *v20; // ebx
  char *v21; // eax
  FILE *v22; // ebx
  char *v23; // eax
  FILE *v24; // ebx
  char *v25; // eax
  FILE *v26; // ebx
  char *v27; // eax
  FILE *v28; // ebx
  char *v29; // eax
  FILE *v30; // ebx
  char *v31; // eax
  char *v32; // eax
  FILE *v33; // ebx
  char *v34; // eax
  FILE *v35; // ebx
  char *v36; // eax
  FILE *v37; // ebx
  char *v38; // eax
  FILE *v39; // ebx
  char *v40; // eax
  FILE *v41; // ebx
  char *v42; // eax

  if ( status )
  {
    v1 = dword_806C140;
    v2 = gettext("Try '%s --help' for more information.\n");
    fprintf(stderr, v2, v1);
  }
  else
  {
    v3 = dword_806C140;
    v4 = dword_806C140;
    v5 = gettext("Usage: %s [OPTION]... [FILE]...\n  or:  %s [OPTION]... --files0-from=F\n");
    printf(v5, v4, v3);
    v6 = stdout;
    v7 = gettext("Write sorted concatenation of all FILE(s) to standard output.\n");
    fputs_unlocked(v7, v6);
    sub_804B46D();
    sub_804B498();
    v8 = stdout;
    v9 = gettext("Ordering options:\n\n");
    fputs_unlocked(v9, v8);
    v10 = stdout;
    v11 = gettext(
            "  -b, --ignore-leading-blanks  ignore leading blanks\n"
            "  -d, --dictionary-order      consider only blanks and alphanumeric characters\n"
            "  -f, --ignore-case           fold lower case to upper case characters\n");
    fputs_unlocked(v11, v10);
    v12 = stdout;
    v13 = gettext(
            "  -g, --general-numeric-sort  compare according to general numerical value\n"
            "  -i, --ignore-nonprinting    consider only printable characters\n"
            "  -M, --month-sort            compare (unknown) < 'JAN' < ... < 'DEC'\n");
    fputs_unlocked(v13, v12);
    v14 = stdout;
    v15 = gettext("  -h, --human-numeric-sort    compare human readable numbers (e.g., 2K 1G)\n");
    fputs_unlocked(v15, v14);
    v16 = stdout;
    v17 = gettext(
            "  -n, --numeric-sort          compare according to string numerical value\n"
            "  -R, --random-sort           shuffle, but group identical keys.  See shuf(1)\n"
            "      --random-source=FILE    get random bytes from FILE\n"
            "  -r, --reverse               reverse the result of comparisons\n");
    fputs_unlocked(v17, v16);
    v18 = stdout;
    v19 = gettext(
            "      --sort=WORD             sort according to WORD:\n"
            "                                general-numeric -g, human-numeric -h, month -M,\n"
            "                                numeric -n, random -R, version -V\n"
            "  -V, --version-sort          natural sort of (version) numbers within text\n"
            "\n");
    fputs_unlocked(v19, v18);
    v20 = stdout;
    v21 = gettext("Other options:\n\n");
    fputs_unlocked(v21, v20);
    v22 = stdout;
    v23 = gettext(
            "      --batch-size=NMERGE   merge at most NMERGE inputs at once;\n"
            "                            for more use temp files\n");
    fputs_unlocked(v23, v22);
    v24 = stdout;
    v25 = gettext(
            "  -c, --check, --check=diagnose-first  check for sorted input; do not sort\n"
            "  -C, --check=quiet, --check=silent  like -c, but do not report first bad line\n"
            "      --compress-program=PROG  compress temporaries with PROG;\n"
            "                              decompress them with PROG -d\n");
    fputs_unlocked(v25, v24);
    v26 = stdout;
    v27 = gettext(
            "      --debug               annotate the part of the line used to sort,\n"
            "                              and warn about questionable usage to stderr\n"
            "      --files0-from=F       read input from the files specified by\n"
            "                            NUL-terminated names in file F;\n"
            "                            If F is - then read names from standard input\n");
    fputs_unlocked(v27, v26);
    v28 = stdout;
    v29 = gettext(
            "  -k, --key=KEYDEF          sort via a key; KEYDEF gives location and type\n"
            "  -m, --merge               merge already sorted files; do not sort\n");
    fputs_unlocked(v29, v28);
    v30 = stdout;
    v31 = gettext(
            "  -o, --output=FILE         write result to FILE instead of standard output\n"
            "  -s, --stable              stabilize sort by disabling last-resort comparison\n"
            "  -S, --buffer-size=SIZE    use SIZE for main memory buffer\n");
    fputs_unlocked(v31, v30);
    v32 = gettext(
            "  -t, --field-separator=SEP  use SEP instead of non-blank to blank transition\n"
            "  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or %s;\n"
            "                              multiple options specify multiple directories\n"
            "      --parallel=N          change the number of sorts run concurrently to N\n"
            "  -u, --unique              with -c, check for strict ordering;\n"
            "                              without -c, output only the first of an equal run\n");
    printf(v32, "/tmp");
    v33 = stdout;
    v34 = gettext("  -z, --zero-terminated     line delimiter is NUL, not newline\n");
    fputs_unlocked(v34, v33);
    v35 = stdout;
    v36 = gettext("      --help     display this help and exit\n");
    fputs_unlocked(v36, v35);
    v37 = stdout;
    v38 = gettext("      --version  output version information and exit\n");
    fputs_unlocked(v38, v37);
    v39 = stdout;
    v40 = gettext(
            "\n"
            "KEYDEF is F[.C][OPTS][,F[.C][OPTS]] for start and stop position, where F is a\n"
            "field number and C a character position in the field; both are origin 1, and\n"
            "the stop position defaults to the line's end.  If neither -t nor -b is in\n"
            "effect, characters in a field are counted from the beginning of the preceding\n"
            "whitespace.  OPTS is one or more single-letter ordering options [bdfgiMhnRrV],\n"
            "which override global ordering options for that key.  If no key is given, use\n"
            "the entire line as the key.  Use --debug to diagnose incorrect key usage.\n"
            "\n"
            "SIZE may be followed by the following multiplicative suffixes:\n");
    fputs_unlocked(v40, v39);
    v41 = stdout;
    v42 = gettext(
            "% 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, E, Z, Y.\n"
            "\n"
            "*** WARNING ***\n"
            "The locale specified by the environment affects sort order.\n"
            "Set LC_ALL=C to get the traditional sort order that uses\n"
            "native byte values.\n");
    fputs_unlocked(v42, v41);
    sub_804B4C3("sort");
  }
  exit(status);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 806C140: using guessed type int dword_806C140;

//----- (0804BACA) --------------------------------------------------------
int __cdecl sub_804BACA(int a1)
{
  bool v1; // dl
  int result; // eax

  v1 = pthread_sigmask(0, &set, (__sigset_t *)(a1 + 4)) == 0;
  result = a1;
  *(_BYTE *)a1 = v1;
  return result;
}

//----- (0804BAFF) --------------------------------------------------------
int __cdecl sub_804BAFF(unsigned __int8 *a1)
{
  int result; // eax

  result = *a1;
  if ( (_BYTE)result )
    result = pthread_sigmask(2, (const __sigset_t *)(a1 + 4), 0);
  return result;
}

//----- (0804BB2F) --------------------------------------------------------
int __cdecl sub_804BB2F(int a1, unsigned int a2)
{
  return *(_DWORD *)(a1 + 4) % a2;
}

//----- (0804BB4D) --------------------------------------------------------
bool __cdecl sub_804BB4D(int a1, int a2)
{
  return *(_DWORD *)(a1 + 4) == *(_DWORD *)(a2 + 4);
}

//----- (0804BB72) --------------------------------------------------------
void __usercall __noreturn sub_804BB72(double a1@<st0>, __pid_t pid)
{
  __pid_t v2; // eax
  void *v3; // esi
  char *v4; // ebx
  int *v5; // eax
  int (*v6)(); // eax
  int v7; // edx
  int v8; // ecx
  int (*v9)(); // eax
  int stat_loc; // [esp+18h] [ebp-10h]
  int v11; // [esp+1Ch] [ebp-Ch]

  if ( pid )
    v2 = pid;
  else
    v2 = -1;
  v11 = waitpid(v2, &stat_loc, pid == 0);
  if ( v11 < 0 )
  {
    v3 = sub_805B8B4(4, arg);
    v4 = gettext("waiting for %s [-d]");
    v5 = __errno_location();
    error(2, *v5, v4, v3);
  }
  v6 = (int (*)())&loc_804BC13;
  if ( v11 <= 0 )
    v6 = sub_804BCBF;
  dword_806B20C = (int)v6;
  sub_8061C98(a1);
  v9 = (int (*)())&loc_804BC32;
  if ( pid > 0 )
    v9 = sub_804BC41;
  dword_806B220 = (int)v9;
  sub_8061C20(v8, v7);
  sub_804BD5E(a1, v11);
}
// 804BC41: using guessed type int sub_804BC41();
// 804BCBF: using guessed type int sub_804BCBF();
// 8061C20: using guessed type int __fastcall sub_8061C20(_DWORD, _DWORD);
// 8061C98: using guessed type int __usercall sub_8061C98@<eax>(double@<st0>);
// 806B20C: using guessed type int dword_806B20C;
// 806B220: using guessed type int dword_806B220;

//----- (0804BCC9) --------------------------------------------------------
void __cdecl __noreturn sub_804BCC9(int a1)
{
  bool v1; // zf
  int v2; // edx
  int v3; // ecx
  void *v4; // eax

  if ( !dword_806C074 )
  {
    dword_806C074 = sub_8057FF1();
    if ( !dword_806C074 )
      sub_805E5AE();
  }
  *(_BYTE *)(a1 + 8) = 1;
  v1 = sub_8058BD2((unsigned int *)dword_806C074, a1) == 0;
  v4 = &loc_804BD53;
  if ( !v1 )
    v4 = &locret_804BD5C;
  dword_806B298 = (int)v4;
  sub_8061955(v3, v2);
  sub_805E5AE();
}
// 806B298: using guessed type int dword_806B298;
// 806C074: using guessed type int dword_806C074;

//----- (0804BD5E) --------------------------------------------------------
void __usercall __noreturn sub_804BD5E(double st7_0@<st0>, int a1)
{
  int v2; // edx
  int v3; // ecx
  void *v4; // eax
  int v5; // [esp+1Ch] [ebp-1Ch]
  char v6; // [esp+20h] [ebp-18h]
  int v7; // [esp+24h] [ebp-14h]
  unsigned int v8; // [esp+2Ch] [ebp-Ch]

  v8 = __readgsdword(0x14u);
  v7 = a1;
  v5 = sub_8058C47(st7_0, dword_806C074, (int)&v6);
  if ( !v5 )
  {
    dword_806B25C = (int)&loc_804BE00;
    sub_8061AC4(v3, v2);
  }
  *(_BYTE *)(v5 + 8) = 2;
  while ( 1 )
  {
    v4 = &loc_804BDE4;
    if ( __readgsdword(0x14u) == v8 )
      v4 = &locret_804BDBC;
    dword_806B2F4 = (int)v4;
    sub_80616BF();
  }
}
// 8061AC4: using guessed type int __fastcall sub_8061AC4(_DWORD, _DWORD);
// 806B25C: using guessed type int dword_806B25C;
// 806B2F4: using guessed type int dword_806B2F4;
// 806C074: using guessed type int dword_806C074;

//----- (0804BE27) --------------------------------------------------------
void __usercall __noreturn sub_804BE27(double st7_0@<st0>, int a1)
{
  sub_804BD5E(st7_0, a1);
}

//----- (0804BE49) --------------------------------------------------------
int __usercall sub_804BE49@<eax>(double a1@<st0>)
{
  int result; // eax

  result = dword_806C078;
  if ( dword_806C078 > 0 )
    sub_804BB72(a1, 0);
  return result;
}
// 806C078: using guessed type int dword_806C078;

//----- (0804BE6C) --------------------------------------------------------
void __usercall __noreturn sub_804BE6C(double a1@<st0>)
{
  sub_804BB72(a1, -1);
}

//----- (0804BE85) --------------------------------------------------------
int __usercall sub_804BE85@<eax>(double a1@<st0>)
{
  int result; // eax

  result = dword_806C078;
  if ( dword_806C078 > 0 )
    sub_804BB72(a1, -1);
  return result;
}
// 806C078: using guessed type int dword_806C078;

//----- (0804BEC9) --------------------------------------------------------
int sub_804BEC9()
{
  int result; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  result = dword_806C070;
  for ( i = dword_806C070; i; i = *(_DWORD *)i )
  {
    unlink((const char *)(i + 9));
    result = *(_DWORD *)i;
  }
  dword_806C070 = 0;
  return result;
}
// 806C070: using guessed type int dword_806C070;

//----- (0804BF01) --------------------------------------------------------
int __usercall sub_804BF01@<eax>(double a1@<st0>)
{
  char v2; // [esp+1Ch] [ebp-8Ch]

  if ( dword_806C070 )
  {
    sub_804BACA((int)&v2);
    sub_804BEC9();
    sub_804BAFF((unsigned __int8 *)&v2);
  }
  return sub_8055C5C(a1);
}
// 806C070: using guessed type int dword_806C070;

//----- (0804BF3B) --------------------------------------------------------
int *__cdecl sub_804BF3B(int *a2, char a3)
{
  size_t n; // ST2C_4
  _DWORD *v4; // eax
  int v5; // ST38_4
  void *v6; // esi
  char *v7; // ebx
  int *v8; // eax
  int *ptr; // [esp+24h] [ebp-A4h]
  char *s; // [esp+28h] [ebp-A0h]
  int v12; // [esp+34h] [ebp-94h]
  char v13; // [esp+3Ch] [ebp-8Ch]

  s = *(char **)(4 * dword_806C12C + dword_806BFD4);
  n = strlen(*(const char **)(4 * dword_806C12C + dword_806BFD4));
  ptr = (int *)sub_805E3F4((n + 24) & 0xFFFFFFFC);
  memcpy((char *)ptr + 9, s, n);
  v4 = (int *)((char *)ptr + n + 9);
  *v4 = 1919906607;
  v4[1] = 1482184820;
  v4[2] = 5789784;
  *ptr = 0;
  if ( ++dword_806C12C == dword_806BFD8 )
    dword_806C12C = 0;
  sub_804BACA((int)&v13);
  v12 = sub_805D381((int)ptr + 9, 0x80000);
  if ( v12 >= 0 )
  {
    *off_806B3DC = (int)ptr;
    off_806B3DC = ptr;
  }
  v5 = *__errno_location();
  sub_804BAFF((unsigned __int8 *)&v13);
  *__errno_location() = v5;
  if ( v12 < 0 )
  {
    if ( a3 != 1 || *__errno_location() != 24 )
    {
      v6 = sub_805B8B4(4, s);
      v7 = gettext("cannot create temporary file in %s");
      v8 = __errno_location();
      error(2, *v8, v7, v6);
    }
    free(ptr);
    ptr = 0;
  }
  *a2 = v12;
  return ptr;
}
// 806B3DC: using guessed type int *off_806B3DC;
// 806BFD4: using guessed type int dword_806BFD4;
// 806BFD8: using guessed type int dword_806BFD8;
// 806C12C: using guessed type int dword_806C12C;

//----- (0804C128) --------------------------------------------------------
FILE *__cdecl sub_804C128(char *s1, char *modes)
{
  FILE *v2; // eax
  bool v3; // zf
  int v4; // edx
  int v5; // ecx
  void *v6; // eax
  void *v7; // esi
  char *v8; // ebx
  int *v9; // eax
  FILE *stream; // [esp+18h] [ebp-10h]
  int fd; // [esp+1Ch] [ebp-Ch]

  if ( *modes == 114 )
  {
    if ( !strcmp(s1, "-") )
    {
      byte_806BFE3 = 1;
      stream = stdin;
      sub_8057092(stdin, 2);
    }
    else
    {
      fd = open64(s1, 0x80000);
      if ( fd < 0 )
        v2 = 0;
      else
        v2 = fdopen(fd, modes);
      stream = v2;
      sub_8057092(v2, 2);
    }
  }
  else
  {
    if ( *modes != 119 )
      __assert_fail("!\"unexpected mode passed to stream_open\"", "src/sort.c", 0x3CCu, "stream_open");
    if ( s1 )
    {
      v3 = ftruncate64(1, 0, 0) == 0;
      v6 = &loc_804C203;
      if ( v3 )
        v6 = &loc_804C24D;
      dword_806B220 = (int)v6;
      sub_8061C20(v5, v4);
      v7 = sub_805BA91(0, 3, s1);
      v8 = gettext("%s: error truncating");
      v9 = __errno_location();
      error(2, *v9, v8, v7);
    }
    stream = stdout;
  }
  return stream;
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 8049D20: using guessed type int __cdecl ftruncate64(_DWORD, _DWORD, _DWORD);
// 8061C20: using guessed type int __fastcall sub_8061C20(_DWORD, _DWORD);
// 806B220: using guessed type int dword_806B220;
// 806BFE3: using guessed type char byte_806BFE3;

//----- (0804C285) --------------------------------------------------------
void __cdecl __noreturn sub_804C285(char *s1, char *modes)
{
  bool v3; // zf
  int (*v4)(); // eax
  char *v5; // eax

  v3 = sub_804C128(s1, modes) == 0;
  v4 = (int (*)())&loc_804C2BF;
  if ( !v3 )
    v4 = sub_804C2DA;
  dword_806B234 = (int)v4;
  sub_8061BAC();
  v5 = gettext("open failed");
  sub_804B777((int)v5, s1);
}
// 804C2DA: using guessed type int sub_804C2DA();
// 8061BAC: using guessed type int sub_8061BAC(void);
// 806B234: using guessed type int dword_806B234;

//----- (0804C2DA) --------------------------------------------------------
#error "804C2DE: positive sp value has been found (funcsize=0)"

//----- (0804C2DF) --------------------------------------------------------
void __usercall sub_804C2DF(double a1@<st0>, FILE *stream, int a3)
{
  int v3; // eax
  bool v4; // zf
  int v5; // edx
  int v6; // ecx
  void *v7; // eax
  void *v8; // eax
  char *v9; // eax
  char *v10; // eax

  v3 = fileno(stream);
  if ( v3 )
  {
    if ( v3 == 1 )
    {
      v4 = fflush_unlocked(stream) == 0;
      v8 = &loc_804C35A;
      if ( v4 )
        v8 = &loc_804C375;
      dword_806B234 = (int)v8;
      sub_8061BAC();
      v9 = gettext("fflush failed");
      sub_804B777((int)v9, (char *)a3);
    }
    if ( sub_805F3D1(a1, stream) )
    {
      v10 = gettext("close failed");
      sub_804B777((int)v10, (char *)a3);
    }
  }
  else
  {
    v4 = feof_unlocked(stream) == 0;
    v7 = &loc_804C323;
    if ( v4 )
      v7 = &loc_804C330;
    dword_806B31C = (int)v7;
    sub_8061576(v6, v5);
    clearerr_unlocked(stream);
  }
}
// 8061576: using guessed type int __fastcall sub_8061576(_DWORD, _DWORD);
// 8061BAC: using guessed type int sub_8061BAC(void);
// 806B234: using guessed type int dword_806B234;
// 806B31C: using guessed type int dword_806B31C;

//----- (0804C3A3) --------------------------------------------------------
int __cdecl sub_804C3A3(int fd, int fd2)
{
  int result; // eax

  result = fd;
  if ( fd != fd2 )
  {
    dup2(fd, fd2);
    result = close(fd);
  }
  return result;
}

//----- (0804C3D0) --------------------------------------------------------
__pid_t __cdecl sub_804C3D0(int pipedes[2], int a2)
{
  long double v2; // fst7
  int v3; // ecx
  int v5; // edx
  int v6; // ecx
  void *v7; // eax
  int *v8; // eax
  long double v9; // fst7
  int v10; // edx
  int v11; // eax
  int v12; // ST24_4
  void *v13; // eax
  int v14; // edx
  int v15; // ecx
  __pid_t v16; // [esp+14h] [ebp-A4h]
  int v17; // [esp+18h] [ebp-A0h]
  int v18; // [esp+1Ch] [ebp-9Ch]
  double v19; // [esp+20h] [ebp-98h]
  char v20; // [esp+2Ch] [ebp-8Ch]

  v2 = 0.25;
  v19 = 0.25;
  if ( sub_8059C5F(pipedes, 0x80000) < 0 )
    return -1;
  if ( dword_806B3D8 + 1 < (unsigned int)dword_806C078 )
    sub_804BE6C(*(double *)&v2);
  while ( 1 )
  {
    v11 = a2;
    v10 = a2-- - 1;
    if ( !v11 )
      break;
    sub_804BACA((int)&v20);
    v17 = dword_806C070;
    dword_806C070 = 0;
    v16 = fork();
    v18 = *__errno_location();
    v7 = &loc_804C483;
    if ( !v16 )
      v7 = &loc_804C48E;
    dword_806B298 = (int)v7;
    sub_8061955(v6, v5);
    dword_806C070 = v17;
    sub_804BAFF((unsigned __int8 *)&v20);
    v8 = __errno_location();
    v10 = v18;
    *v8 = v18;
    if ( v16 >= 0 || *__errno_location() != 11 )
      break;
    sub_805E7AF(v19);
    v9 = v19 + v19;
    v19 = v9;
    sub_804BE49(*(double *)&v9);
  }
  if ( v16 >= 0 )
  {
    v13 = &loc_804C55C;
    if ( v16 )
      v13 = &loc_804C58B;
    dword_806B25C = (int)v13;
    sub_8061AC4(v3, v10);
    close(0);
    close(1);
    dword_806B220 = (int)&loc_804C598;
    sub_8061C20(v15, v14);
    ++dword_806C078;
  }
  else
  {
    v12 = *__errno_location();
    close(*pipedes);
    close(pipedes[1]);
    *__errno_location() = v12;
  }
  return v16;
}
// 804C3D0: could not find valid save-restore pair for ebx
// 8061AC4: using guessed type int __fastcall sub_8061AC4(_DWORD, _DWORD);
// 8061C20: using guessed type int __fastcall sub_8061C20(_DWORD, _DWORD);
// 806B220: using guessed type int dword_806B220;
// 806B25C: using guessed type int dword_806B25C;
// 806B298: using guessed type int dword_806B298;
// 806C070: using guessed type int dword_806C070;
// 806C078: using guessed type int dword_806C078;

//----- (0804C5A0) --------------------------------------------------------
int *__cdecl sub_804C5A0(FILE **a2, char a3)
{
  __pid_t v4; // eax
  int *v5; // eax
  char *v6; // ebx
  char *v7; // eax
  int v8; // [esp+Ch] [ebp-1Ch]
  int fd; // [esp+10h] [ebp-18h]
  int *v10; // [esp+14h] [ebp-14h]
  int pipedes[2]; // [esp+18h] [ebp-10h]

  LOBYTE(v8) = a3;
  v10 = sub_804BF3B(&fd, a3);
  if ( !v10 )
    return 0;
  *((_BYTE *)v10 + 8) = 0;
  if ( arg )
  {
    v4 = sub_804C3D0(pipedes, 4);
    v10[1] = v4;
    if ( v10[1] > 0 )
    {
      close(fd);
      close(pipedes[0]);
      fd = pipedes[1];
      sub_804BCC9((int)v10);
    }
    if ( !v10[1] )
    {
      close(pipedes[1]);
      sub_804C3A3(fd, 1);
      sub_804C3A3(pipedes[0], 0);
      execlp(arg, arg, 0, v8);
      v5 = __errno_location();
      sub_804B67B(*v5, "couldn't execute compress program");
    }
  }
  *a2 = fdopen(fd, "w");
  if ( !*a2 )
  {
    v6 = (char *)v10 + 9;
    v7 = gettext("couldn't create temporary file");
    sub_804B777((int)v7, v6);
  }
  return v10;
}

//----- (0804C6EC) --------------------------------------------------------
int *__cdecl sub_804C6EC(FILE **a2)
{
  return sub_804C5A0(a2, 0);
}

//----- (0804C707) --------------------------------------------------------
int __usercall sub_804C707@<eax>(double a1@<st0>, int a2)
{
  __pid_t v3; // eax
  int v4; // edx
  int v5; // ecx
  bool v6; // zf
  void *v7; // eax
  void *v8; // eax
  void *v9; // esi
  char *v10; // ebx
  int *v11; // eax
  int fd; // [esp+1Ch] [ebp-1Ch]
  __pid_t v13; // [esp+20h] [ebp-18h]
  int pipedes[2]; // [esp+28h] [ebp-10h]

  if ( *(_BYTE *)(a2 + 8) == 1 )
    sub_804BE27(a1, *(_DWORD *)(a2 + 4));
  fd = open64(a2 + 9, 0);
  if ( fd < 0 )
    return 0;
  v3 = sub_804C3D0(pipedes, 9);
  v13 = v3;
  if ( v3 != -1 )
  {
    v6 = v3 == 0;
    v7 = &loc_804C793;
    if ( v6 )
      v7 = &loc_804C81C;
    dword_806B270 = (int)v7;
    sub_8061A4C(v5, v4);
    *(_DWORD *)(a2 + 4) = v13;
    sub_804BCC9(a2);
  }
  v6 = *__errno_location() == 24;
  v8 = &loc_804C7BD;
  if ( v6 )
    v8 = &loc_804C801;
  dword_806B2CC = (int)v8;
  sub_80617DA();
  v9 = sub_805B8B4(4, arg);
  v10 = gettext("couldn't create process for %s -d");
  v11 = __errno_location();
  error(2, *v11, v10, v9);
  close(fd);
  *__errno_location() = 24;
  return 0;
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 80617DA: using guessed type int sub_80617DA(void);
// 8061A4C: using guessed type int __fastcall sub_8061A4C(_DWORD, _DWORD);
// 806B270: using guessed type int dword_806B270;
// 806B2CC: using guessed type int dword_806B2CC;

//----- (0804C8FC) --------------------------------------------------------
int __cdecl sub_804C8FC(int a1)
{
  void *v1; // eax
  int v2; // eax
  _DWORD *v3; // edx
  int result; // eax

  v1 = &loc_804C92A;
  if ( dword_806BFD8 != dword_806BFDC )
    v1 = &loc_804C949;
  dword_806B308 = (int)v1;
  sub_806160F();
  dword_806BFD4 = (int)sub_805E34A(dword_806BFD4, (unsigned int *)&dword_806BFDC, 4u);
  v2 = dword_806BFD8++;
  v3 = (_DWORD *)(dword_806BFD4 + 4 * v2);
  result = a1;
  *v3 = a1;
  return result;
}
// 806160F: using guessed type int sub_806160F(void);
// 806B308: using guessed type int dword_806B308;
// 806BFD4: using guessed type int dword_806BFD4;
// 806BFD8: using guessed type int dword_806BFD8;
// 806BFDC: using guessed type int dword_806BFDC;

//----- (0804C995) --------------------------------------------------------
void __usercall sub_804C995(double a1@<st0>, char *name)
{
  int v2; // ST28_4
  void *v3; // ebx
  char *v4; // eax
  int *i; // [esp+18h] [ebp-A0h]
  int errnum; // [esp+1Ch] [ebp-9Ch]
  _DWORD *ptr; // [esp+20h] [ebp-98h]
  int v8; // [esp+24h] [ebp-94h]
  char v9; // [esp+2Ch] [ebp-8Ch]

  for ( i = &dword_806C070; ; i = (int *)*i )
  {
    ptr = (_DWORD *)*i;
    if ( (char *)(*i + 9) == name )
      break;
  }
  if ( *((_BYTE *)ptr + 8) == 1 )
    sub_804BE27(a1, ptr[1]);
  v8 = *ptr;
  sub_804BACA((int)&v9);
  v2 = unlink(name);
  errnum = *__errno_location();
  *i = v8;
  sub_804BAFF((unsigned __int8 *)&v9);
  if ( v2 )
  {
    v3 = sub_805BA91(0, 3, name);
    v4 = gettext("warning: cannot remove: %s");
    error(0, errnum, v4, v3);
  }
  if ( !v8 )
    off_806B3DC = i;
  free(ptr);
}
// 806B3DC: using guessed type int *off_806B3DC;
// 806C070: using guessed type int dword_806C070;

//----- (0804CACD) --------------------------------------------------------
int __cdecl compar(const void *a1, const void *a2)
{
  return strcmp(*(const char **)a1, *(const char **)a2);
}

//----- (0804CAF7) --------------------------------------------------------
void sub_804CAF7()
{
  bool v0; // zf
  int v1; // ecx
  void *v2; // eax
  int v3; // eax
  const unsigned __int16 *v4; // ebx
  unsigned int c; // [esp+18h] [ebp-20h]
  unsigned int ca; // [esp+18h] [ebp-20h]
  size_t i; // [esp+1Ch] [ebp-1Ch]
  int v8; // [esp+20h] [ebp-18h]
  const char *s; // [esp+24h] [ebp-14h]
  size_t v10; // [esp+28h] [ebp-10h]
  char *v11; // [esp+2Ch] [ebp-Ch]

  for ( c = 0; c <= 0xFF; ++c )
  {
    *(_BYTE *)(c + 134659024) = sub_804B3C7(c);
    *(_BYTE *)(c + 134659280) = ((*__ctype_b_loc())[c] & 0x4000) == 0;
    v0 = ((*__ctype_b_loc())[c] & 8) == 0;
    v2 = &loc_804CB7F;
    if ( !v0 )
      v2 = &loc_804CB9B;
    dword_806B31C = (int)v2;
    sub_8061576(v1, 2 * c);
    *(_BYTE *)(c + 134659536) = (unsigned __int8)sub_804B3C7(c) != 1;
    *(_BYTE *)(c + 134659792) = toupper(c);
  }
  if ( byte_806BBB9 )
  {
    for ( ca = 0; ca <= 0xB; ++ca )
    {
      s = nl_langinfo(ca + 131086);
      v10 = strlen(s);
      v11 = (char *)sub_805E3F4(v10 + 1);
      (&off_806B370)[2 * ca] = v11;
      dword_806B374[2 * ca] = ca + 1;
      v8 = 0;
      for ( i = 0; i < v10; ++i )
      {
        v4 = *__ctype_b_loc();
        if ( !(v4[(unsigned __int8)sub_804B3B5(s[i])] & 1) )
        {
          v3 = v8++;
          v11[v3] = byte_806BED0[(unsigned __int8)sub_804B3B5(s[i])];
        }
      }
      v11[v8] = 0;
    }
    qsort(&off_806B370, 0xCu, 8u, compar);
  }
}
// 8061576: using guessed type int __fastcall sub_8061576(_DWORD, _DWORD);
// 806B31C: using guessed type int dword_806B31C;
// 806B370: using guessed type char *off_806B370;
// 806B374: using guessed type int dword_806B374[];
// 806BBB9: using guessed type char byte_806BBB9;

//----- (0804CD24) --------------------------------------------------------
unsigned int __cdecl sub_804CD24(int a1, char a2, char *a3)
{
  int v3; // ecx
  void *v4; // ebx
  int v5; // esi
  char *v6; // eax
  void *v7; // ebx
  int v8; // esi
  char *v9; // eax
  int v10; // ebx
  int v11; // esi
  char *v12; // eax
  void *v14; // ebx
  int v15; // esi
  char *v16; // eax
  __int64 *v17; // [esp+Ch] [ebp-4Ch]
  int v18; // [esp+10h] [ebp-48h]
  char *nptr; // [esp+18h] [ebp-40h]
  char v20; // [esp+1Ch] [ebp-3Ch]
  int v21; // [esp+20h] [ebp-38h]
  unsigned int v22; // [esp+24h] [ebp-34h]
  __int64 v23; // [esp+28h] [ebp-30h]
  int v24; // [esp+30h] [ebp-28h]
  int v25; // [esp+34h] [ebp-24h]
  char v26; // [esp+41h] [ebp-17h]
  unsigned int v27; // [esp+4Ch] [ebp-Ch]

  v20 = a2;
  nptr = a3;
  v27 = __readgsdword(0x14u);
  v18 = 0;
  v17 = &v23;
  v21 = sub_805EF49(a3, 0, 10);
  if ( !getrlimit64(7, &v24) )
  {
    dword_806B25C = (int)&loc_804CDAC;
    sub_8061AC4(v3, v25);
  }
  v22 = 17;
  if ( v21 )
  {
LABEL_9:
    if ( v21 == 1 )
    {
      v14 = sub_805BCF1(nptr);
      v15 = *((_DWORD *)&longopts.name + 4 * a1);
      v16 = gettext("--%s argument %s too large");
      v18 = (int)v14;
      v17 = (__int64 *)v15;
      error(0, 0, v16, v15, v14);
      v10 = sub_8059356(v22, (int)&v26);
      v11 = *((_DWORD *)&longopts.name + 4 * a1);
      v12 = gettext("maximum --%s argument with current rlimit is %s");
      v18 = v10;
      v17 = (__int64 *)v11;
      error(2, 0, v12, v11, v10);
    }
    sub_805EE44(v3, (int)nptr, v21, a1, v20, (int)&longopts, (int)nptr);
  }
  dword_806B3D8 = v23;
  v3 = v23;
  if ( v23 != (unsigned int)v23 )
  {
    v21 = 1;
    dword_806B298 = (int)&loc_804CEDE;
    sub_8061955(v23, HIDWORD(v23));
  }
  if ( (unsigned int)dword_806B3D8 <= 1 )
  {
    v4 = sub_805BCF1(nptr);
    v5 = *((_DWORD *)&longopts.name + 4 * a1);
    v6 = gettext("invalid --%s argument %s");
    v18 = (int)v4;
    v17 = (__int64 *)v5;
    error(0, 0, v6, v5, v4);
    v7 = sub_805BCF1("2");
    v8 = *((_DWORD *)&longopts.name + 4 * a1);
    v9 = gettext("minimum --%s argument is %s");
    v18 = (int)v7;
    v17 = (__int64 *)v8;
    error(2, 0, v9, v8, v7);
  }
  if ( v22 < dword_806B3D8 )
  {
    v21 = 1;
    goto LABEL_9;
  }
  return __readgsdword(0x14u) ^ v27;
}
// 8049920: using guessed type int __cdecl getrlimit64(_DWORD, _DWORD);
// 8061AC4: using guessed type int __fastcall sub_8061AC4(_DWORD, _DWORD);
// 806B25C: using guessed type int dword_806B25C;
// 806B298: using guessed type int dword_806B298;

//----- (0804CFBD) --------------------------------------------------------
int __cdecl sub_804CFBD(int a1, int a2, char *nptr)
{
  int v3; // edx
  int v4; // ecx
  int v5; // eax
  bool v6; // zf
  void *v7; // eax
  long double v8; // fst7
  __int16 v9; // ax
  unsigned __int64 v10; // rax
  __int16 v11; // ax
  int result; // eax
  unsigned __int64 *v13; // [esp+Ch] [ebp-5Ch]
  const char *v14; // [esp+10h] [ebp-58h]
  unsigned __int64 v15; // [esp+18h] [ebp-50h]
  double v16; // [esp+20h] [ebp-48h]
  __int16 v17; // [esp+28h] [ebp-40h]
  __int16 v18; // [esp+2Ah] [ebp-3Eh]
  char v19; // [esp+2Ch] [ebp-3Ch]
  int v20; // [esp+38h] [ebp-30h]
  int v21; // [esp+3Ch] [ebp-2Ch]
  unsigned __int64 v22; // [esp+40h] [ebp-28h]
  double v23; // [esp+48h] [ebp-20h]

  v19 = a2;
  v14 = "EgGkKmMPtTYZ";
  v13 = &v22;
  v21 = sub_805EF49(nptr, (int)&v20, 10);
  if ( !v21 && (unsigned int)(*(char *)(v20 - 1) - 48) <= 9 )
  {
    v3 = HIDWORD(v22);
    if ( HIDWORD(v22) <= 0x3FFFFF )
    {
      v22 <<= 10;
      dword_806B308 = (int)&loc_804D051;
      sub_806160F();
    }
    v21 = 1;
  }
  if ( v21 == 2 && (unsigned int)(*(char *)(v20 - 1) - 48) <= 9 && !*(_BYTE *)(v20 + 1) )
  {
    v5 = *(char *)v20;
    if ( v5 == 37 )
    {
      v8 = sub_8059A5D();
      v15 = v22;
      v16 = (long double)v22;
      v23 = v8 * v16 / 100.0;
      if ( v23 >= 1.844674407370955e19 )
      {
        v21 = 1;
      }
      else
      {
        if ( v23 >= 9.223372036854776e18 )
        {
          LOBYTE(v11) = v18;
          HIBYTE(v11) = 12;
          v17 = v11;
          v15 = (signed __int64)(v23 - 9.223372036854776e18);
          v10 = v15 ^ 0x8000000000000000LL;
        }
        else
        {
          LOBYTE(v9) = v18;
          HIBYTE(v9) = 12;
          v17 = v9;
          v15 = (signed __int64)v23;
          v10 = (signed __int64)v23;
        }
        v22 = v10;
        v21 = 0;
      }
    }
    else
    {
      v6 = v5 == 98;
      v7 = &loc_804D0B0;
      if ( !v6 )
        v7 = &loc_804D183;
      dword_806B2E0 = (int)v7;
      sub_806174E(v4, v3);
      v21 = 0;
    }
  }
  if ( v21 )
LABEL_26:
    sub_805EE44(v4, (int)nptr, v21, a1, v19, (int)&longopts, (int)nptr);
  result = v22;
  if ( size > v22 )
    return result;
  size = v22;
  v4 = v22;
  if ( v22 != (unsigned int)v22 )
  {
    v21 = 1;
    goto LABEL_26;
  }
  result = size;
  if ( 18 * dword_806B3D8 >= size )
    result = 18 * dword_806B3D8;
  size = result;
  return result;
}
// 806160F: using guessed type int sub_806160F(void);
// 806174E: using guessed type int __fastcall sub_806174E(_DWORD, _DWORD);
// 806B2E0: using guessed type int dword_806B2E0;
// 806B308: using guessed type int dword_806B308;

//----- (0804D22C) --------------------------------------------------------
int __usercall sub_804D22C@<eax>(int a1@<edx>, int ecx0@<ecx>, int a2, char a3, char *nptr)
{
  int v5; // ecx
  char *v7; // eax
  int v8; // [esp+28h] [ebp-10h]
  int v9; // [esp+2Ch] [ebp-Ch]

  v9 = sub_805E8AB(a1, ecx0, nptr, 0, 10, (int)&v8, &locale);
  if ( v9 == 1 )
    return -1;
  if ( v9 )
    sub_805EE44(v5, (int)nptr, v9, a2, a3, (int)&longopts, (int)nptr);
  if ( !v8 )
  {
    v7 = gettext("number in parallel must be nonzero");
    error(2, 0, v7);
  }
  return v8;
}

//----- (0804D2F9) --------------------------------------------------------
void __noreturn sub_804D2F9()
{
  __int64 v0; // [esp+40h] [ebp-18h]

  getrlimit64(2, &v0);
  getrlimit64(9, &v0);
  getrlimit64(5, &v0);
  sub_8059B1F();
}
// 8049920: using guessed type int __cdecl getrlimit64(_DWORD, _DWORD);

//----- (0804D4DC) --------------------------------------------------------
int __cdecl sub_804D4DC(int a1, unsigned int a2, int a3, unsigned int a4, int a5)
{
  int v5; // eax
  bool v6; // al
  char *v7; // ebx
  char *v8; // eax
  void *v10; // eax
  FILE *v11; // [esp+0h] [ebp-98h]
  int v12; // [esp+18h] [ebp-80h]
  unsigned int i; // [esp+1Ch] [ebp-7Ch]
  unsigned int v14; // [esp+20h] [ebp-78h]
  unsigned int v15; // [esp+24h] [ebp-74h]
  __int64 v16; // [esp+28h] [ebp-70h]
  char v17; // [esp+30h] [ebp-68h]
  int v18; // [esp+40h] [ebp-58h]
  __int64 v19; // [esp+5Ch] [ebp-3Ch]

  v14 = a5 + 1;
  v12 = a5 + 2;
  for ( i = 0; i < a4; ++i )
  {
    if ( i >= a2 )
    {
      if ( !strcmp(*(const char **)(4 * i + a3), "-") )
      {
        sub_80614E1(0, (int)&v17);
        dword_806B234 = (int)&loc_804D5B4;
        sub_8061BAC();
      }
      v6 = sub_806148D(*(_DWORD *)(4 * i + a3), (int)&v17) != 0;
    }
    else
    {
      v11 = *(FILE **)(4 * i + a1);
      v5 = fileno(v11);
      v6 = sub_80614E1(v5, (int)&v17) != 0;
    }
    if ( v6 )
    {
      v7 = *(char **)(4 * i + a3);
      v8 = gettext("stat failed");
      sub_804B777((int)v8, v7);
    }
    if ( (v18 & 0xF000) == 0x8000 )
    {
      v16 = v19;
    }
    else
    {
      if ( size )
        return size;
      v16 = 0x20000LL;
    }
    v10 = &loc_804D641;
    if ( dword_806C130 )
      v10 = &loc_804D65E;
    dword_806B2F4 = (int)v10;
    sub_80616BF();
    dword_806C130 = size;
    if ( !size )
      sub_804D2F9();
    v15 = v14 * v16 + 1;
    if ( v16 != v15 / v14 || dword_806C130 - v12 <= v15 )
      return dword_806C130;
    v12 += v15;
  }
  return v12;
}
// 8061BAC: using guessed type int sub_8061BAC(void);
// 806B234: using guessed type int dword_806B234;
// 806B2F4: using guessed type int dword_806B2F4;
// 806C130: using guessed type int dword_806C130;

//----- (0804D6BF) --------------------------------------------------------
void __cdecl __noreturn sub_804D6BF(int a1, int a2, size_t size)
{
  void *v3; // eax
  int v4; // edx
  int v5; // ecx
  size_t sizea; // [esp+28h] [ebp+10h]

  while ( 1 )
  {
    sizea = (size & 0xFFFFFFF0) + 16;
    *(_DWORD *)a1 = malloc(sizea);
    v3 = &loc_804D71D;
    if ( !*(_DWORD *)a1 )
      v3 = &loc_804D734;
    dword_806B2CC = (int)v3;
    sub_80617DA();
    dword_806B25C = (int)sub_804D779;
    sub_8061AC4(v5, v4);
    size = sizea >> 1;
    if ( a2 + 1 >= size )
      sub_805E5AE();
  }
}
// 804D779: using guessed type int sub_804D779();
// 80617DA: using guessed type int sub_80617DA(void);
// 8061AC4: using guessed type int __fastcall sub_8061AC4(_DWORD, _DWORD);
// 806B25C: using guessed type int dword_806B25C;
// 806B2CC: using guessed type int dword_806B2CC;

//----- (0804D779) --------------------------------------------------------
#error "804D7B5: positive sp value has been found (funcsize=0)"

//----- (0804D7B6) --------------------------------------------------------
int __cdecl sub_804D7B6(_DWORD *a1)
{
  return *a1 + a1[3];
}

//----- (0804D7D1) --------------------------------------------------------
unsigned __int8 *__cdecl sub_804D7D1(int a1, int a2)
{
  int v2; // ecx
  void *v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // edx
  void *v7; // eax
  unsigned __int8 *result; // eax
  int v9; // [esp+0h] [ebp-14h]
  unsigned __int8 *v10; // [esp+4h] [ebp-10h]
  int v11; // [esp+8h] [ebp-Ch]
  unsigned int v12; // [esp+Ch] [ebp-8h]
  int v13; // [esp+10h] [ebp-4h]

  v10 = *(unsigned __int8 **)a1;
  v12 = (unsigned int)&v10[*(_DWORD *)(a1 + 4) - 1];
  v11 = *(_DWORD *)a2;
  v13 = *(_DWORD *)(a2 + 4);
  if ( dword_806B3D4 == 128 )
  {
    while ( (unsigned int)v10 < v12 )
    {
      v5 = v11;
      v6 = v11-- - 1;
      if ( !v5 )
        break;
      dword_806B298 = (int)&loc_804D8C7;
      sub_8061955(v2, v6);
      if ( (unsigned int)++v10 < v12 )
      {
        sub_804B3B5(*v10);
        dword_806B234 = (int)&loc_804D81A;
        sub_8061BAC();
        ++v10;
        goto LABEL_3;
      }
      while ( (unsigned int)v10 < v12 )
      {
        v9 = (char)*v10;
        if ( !((unsigned __int8)byte_806BBD0[(unsigned __int8)sub_804B3B5(v9)] ^ 1) )
          break;
        ++v10;
      }
    }
  }
  else
  {
    while ( (unsigned int)v10 < v12 )
    {
      v4 = v11--;
      if ( !v4 )
        break;
LABEL_3:
      if ( (unsigned int)v10 < v12 )
      {
        v3 = &loc_804D879;
        if ( (char)*v10 != dword_806B3D4 )
          v3 = &loc_804D8F7;
        dword_806B234 = (int)v3;
        sub_8061BAC();
      }
      if ( (unsigned int)v10 < v12 )
        ++v10;
    }
  }
  v7 = &loc_804D999;
  if ( !*(_BYTE *)(a2 + 24) )
    v7 = &loc_804D9C6;
  dword_806B2CC = (int)v7;
  sub_80617DA();
  while ( (unsigned int)v10 < v12 )
  {
    v9 = (char)*v10;
    if ( !byte_806BBD0[(unsigned __int8)sub_804B3B5(v9)] )
      break;
    ++v10;
  }
  result = (unsigned __int8 *)v12;
  if ( (unsigned int)&v10[v13] <= v12 )
    result = &v10[v13];
  return result;
}
// 804D7D1: could not find valid save-restore pair for ebx
// 80617DA: using guessed type int sub_80617DA(void);
// 8061BAC: using guessed type int sub_8061BAC(void);
// 806B234: using guessed type int dword_806B234;
// 806B298: using guessed type int dword_806B298;
// 806B2CC: using guessed type int dword_806B2CC;
// 806B3D4: using guessed type int dword_806B3D4;

//----- (0804D9DE) --------------------------------------------------------
int __cdecl sub_804D9DE(char **a1, int a2)
{
  int v2; // ecx
  int v3; // edx
  int v4; // eax
  bool v5; // zf
  void *v6; // eax
  int v7; // eax
  int v8; // eax
  void *v9; // eax
  int result; // eax
  int v11; // [esp+0h] [ebp-14h]
  char *v12; // [esp+4h] [ebp-10h]
  int v13; // [esp+8h] [ebp-Ch]
  unsigned int v14; // [esp+Ch] [ebp-8h]
  int v15; // [esp+10h] [ebp-4h]

  v12 = *a1;
  v3 = (int)(a1[1] - 1);
  v14 = (unsigned int)&v12[v3];
  v13 = *(_DWORD *)(a2 + 8);
  v4 = *(_DWORD *)(a2 + 12);
  v15 = v4;
  v5 = v4 == 0;
  v6 = &loc_804DA2E;
  if ( !v5 )
    v6 = &loc_804DA32;
  dword_806B31C = (int)v6;
  sub_8061576(v2, v3);
  ++v13;
  if ( dword_806B3D4 == 128 )
  {
    dword_806B2F4 = (int)&loc_804DB1F;
    sub_80616BF();
    do
    {
      while ( (unsigned int)v12 < v14 )
      {
        v11 = *v12;
        if ( !byte_806BBD0[(unsigned __int8)sub_804B3B5(v11)] )
          break;
        ++v12;
      }
      while ( (unsigned int)v12 < v14 )
      {
        v11 = *v12;
        if ( !((unsigned __int8)byte_806BBD0[(unsigned __int8)sub_804B3B5(v11)] ^ 1) )
          break;
        ++v12;
      }
      if ( (unsigned int)v12 >= v14 )
        break;
      v8 = v13--;
    }
    while ( v8 );
  }
  else
  {
    dword_806B2B8 = (int)&loc_804DA8D;
    sub_8061881();
    do
    {
      while ( (unsigned int)v12 < v14 && *v12 != dword_806B3D4 )
        ++v12;
      if ( (unsigned int)v12 < v14 && (v13 || v15) )
        ++v12;
      if ( (unsigned int)v12 >= v14 )
        break;
      v7 = v13--;
    }
    while ( v7 );
  }
  v9 = &loc_804DB53;
  if ( !v15 )
    v9 = &loc_804DB9E;
  dword_806B308 = (int)v9;
  sub_806160F();
  if ( *(_BYTE *)(a2 + 25) )
  {
    while ( (unsigned int)v12 < v14 )
    {
      v11 = *v12;
      if ( !byte_806BBD0[(unsigned __int8)sub_804B3B5(v11)] )
        break;
      ++v12;
    }
  }
  result = v14;
  if ( (unsigned int)&v12[v15] <= v14 )
    result = (int)&v12[v15];
  return result;
}
// 804D9DE: could not find valid save-restore pair for ebx
// 8061576: using guessed type int __fastcall sub_8061576(_DWORD, _DWORD);
// 806160F: using guessed type int sub_806160F(void);
// 8061881: using guessed type int sub_8061881(void);
// 806B2B8: using guessed type int dword_806B2B8;
// 806B2F4: using guessed type int dword_806B2F4;
// 806B308: using guessed type int dword_806B308;
// 806B31C: using guessed type int dword_806B31C;
// 806B3D4: using guessed type int dword_806B3D4;

//----- (0804DBA3) --------------------------------------------------------
int __cdecl sub_804DBA3(int a2, FILE *stream, int a4)
{
  int v4; // edx
  int v5; // eax
  int v6; // ecx
  char *v7; // eax
  char *v8; // eax
  size_t v9; // eax
  void *v10; // eax
  int v11; // eax
  unsigned __int8 *v12; // eax
  int v13; // eax
  int v14; // edx
  int v15; // ecx
  int v16; // [esp+0h] [ebp-58h]
  unsigned int v17; // [esp+8h] [ebp-50h]
  char v18; // [esp+1Bh] [ebp-3Dh]
  int v19; // [esp+1Ch] [ebp-3Ch]
  size_t v20; // [esp+20h] [ebp-38h]
  void *ptr; // [esp+24h] [ebp-34h]
  int v22; // [esp+28h] [ebp-30h]
  unsigned int v23; // [esp+2Ch] [ebp-2Ch]
  char *v24; // [esp+30h] [ebp-28h]
  char *v25; // [esp+34h] [ebp-24h]
  int v26; // [esp+38h] [ebp-20h]
  int v27; // [esp+3Ch] [ebp-1Ch]
  int v28; // [esp+40h] [ebp-18h]
  size_t n; // [esp+44h] [ebp-14h]
  size_t v30; // [esp+48h] [ebp-10h]
  _BYTE *v31; // [esp+4Ch] [ebp-Ch]

  v26 = dword_806BFE4;
  v18 = byte_806B350;
  v27 = *(_DWORD *)(a2 + 20);
  v20 = dword_806B3D0 - 18;
  if ( *(_BYTE *)(a2 + 24) )
    return 0;
  if ( *(_DWORD *)(a2 + 4) == *(_DWORD *)(a2 + 16) )
    goto LABEL_8;
  memmove(
    *(void **)a2,
    (const void *)(*(_DWORD *)(a2 + 4) - *(_DWORD *)(a2 + 16) + *(_DWORD *)a2),
    *(_DWORD *)(a2 + 16));
  while ( 1 )
  {
    *(_DWORD *)(a2 + 4) = *(_DWORD *)(a2 + 16);
    *(_DWORD *)(a2 + 8) = 0;
LABEL_8:
    ptr = (void *)(*(_DWORD *)a2 + *(_DWORD *)(a2 + 4));
    v5 = sub_804D7B6((_DWORD *)a2);
    v28 = v5;
    v22 = -16 * *(_DWORD *)(a2 + 8) + v5;
    v4 = v5 - v27 * *(_DWORD *)(a2 + 8) - (_DWORD)ptr;
    v23 = v5 - v27 * *(_DWORD *)(a2 + 8) - (_DWORD)ptr;
    if ( !*(_DWORD *)(a2 + 8) )
      break;
    dword_806B298 = (int)&loc_804DCE1;
    sub_8061955(v6, v4);
  }
  v24 = *(char **)a2;
  do
  {
    if ( v27 + 1 >= v23 )
      break;
    n = (v23 - 1) / (v27 + 1);
    v17 = (v23 - 1) / (v27 + 1);
    v30 = fread_unlocked(ptr, 1u, v17, stream);
    v25 = (char *)ptr + v30;
    v23 -= v30;
    if ( v30 != n )
    {
      if ( ferror_unlocked(stream) )
      {
        v7 = gettext("read failed");
        sub_804B777((int)v7, (char *)a4);
      }
      if ( feof_unlocked(stream) )
      {
        *(_BYTE *)(a2 + 24) = 1;
        if ( *(char **)a2 == v25 )
          return 0;
        if ( v24 != v25 && *(v25 - 1) != v18 )
        {
          v8 = v25++;
          *v8 = v18;
          dword_806B248 = (int)&loc_804DEDB;
          sub_8061B34();
        }
      }
    }
    while ( 1 )
    {
      v31 = memchr(ptr, v18, v25 - (_BYTE *)ptr);
      if ( !v31 )
        break;
      *v31 = 0;
      ptr = v31 + 1;
      v22 -= 16;
      *(_DWORD *)v22 = v24;
      *(_DWORD *)(v22 + 4) = (_BYTE *)ptr - v24;
      v9 = v20;
      if ( *(_DWORD *)(v22 + 4) >= v20 )
        v9 = *(_DWORD *)(v22 + 4);
      v20 = v9;
      v23 -= v27;
      if ( v26 )
      {
        v10 = &loc_804DE5B;
        if ( *(_DWORD *)(v26 + 8) == -1 )
          v10 = &loc_804DE6F;
        dword_806B2B8 = (int)v10;
        sub_8061881();
        v11 = sub_804D9DE((char **)v22, v26);
        *(_DWORD *)(v22 + 12) = v11;
        if ( *(_DWORD *)v26 == -1 )
        {
          if ( *(_BYTE *)(v26 + 24) )
          {
            while ( 1 )
            {
              v16 = *v24;
              if ( !byte_806BBD0[(unsigned __int8)sub_804B3B5(v16)] )
                break;
              ++v24;
            }
          }
          *(_DWORD *)(v22 + 8) = v24;
        }
        else
        {
          v12 = sub_804D7D1(v22, v26);
          *(_DWORD *)(v22 + 8) = v12;
        }
      }
      v24 = (char *)ptr;
    }
    ptr = v25;
  }
  while ( !*(_BYTE *)(a2 + 24) );
  *(_DWORD *)(a2 + 4) = (char *)ptr - *(_DWORD *)a2;
  v13 = sub_804D7B6((_DWORD *)a2);
  *(_DWORD *)(a2 + 8) = (v13 - v22) >> 4;
  if ( *(_DWORD *)(a2 + 8) )
  {
    *(_DWORD *)(a2 + 16) = (_BYTE *)ptr - v24;
    dword_806B3D0 = v20 + 18;
    dword_806B2CC = (int)&loc_804DFF5;
    sub_80617DA();
  }
  v19 = *(_DWORD *)(a2 + 12) >> 4;
  *(_DWORD *)a2 = sub_805E34A(*(_DWORD *)a2, (unsigned int *)&v19, 0x10u);
  v14 = 16 * v19;
  *(_DWORD *)(a2 + 12) = 16 * v19;
  dword_806B220 = (int)&loc_804DC6D;
  return sub_8061C20(v15, v14);
}
// 80617DA: using guessed type int sub_80617DA(void);
// 8061881: using guessed type int sub_8061881(void);
// 8061B34: using guessed type int sub_8061B34(void);
// 8061C20: using guessed type int __fastcall sub_8061C20(_DWORD, _DWORD);
// 806B220: using guessed type int dword_806B220;
// 806B248: using guessed type int dword_806B248;
// 806B298: using guessed type int dword_806B298;
// 806B2B8: using guessed type int dword_806B2B8;
// 806B2CC: using guessed type int dword_806B2CC;
// 806B350: using guessed type char byte_806B350;
// 806BFE4: using guessed type int dword_806BFE4;

//----- (0804DFFC) --------------------------------------------------------
void __usercall sub_804DFFC(double a1@<st0>, char **a2)
{
  int v2; // edx
  char *v3; // eax
  void *v4; // eax
  int v5; // ecx
  char *v6; // eax
  int v7; // edx
  unsigned __int8 v8; // [esp+9h] [ebp-7h]
  bool v9; // [esp+Ah] [ebp-6h]
  unsigned __int8 v10; // [esp+Bh] [ebp-5h]
  char *v11; // [esp+Ch] [ebp-4h]

  v11 = *a2;
  v8 = 0;
  v9 = 0;
  while ( 1 )
  {
    v3 = v11++;
    v10 = *v3;
    if ( (unsigned int)(unsigned __int8)*v3 - 48 > 9 )
      break;
    if ( v8 < v10 )
      v8 = *v3;
    v2 = *v11;
    v9 = v2 == dword_806BBB4;
    if ( v2 == dword_806BBB4 )
      ++v11;
  }
  if ( v9 )
  {
    *a2 = v11 - 2;
  }
  else
  {
    v4 = &loc_804E09C;
    if ( v10 != dword_806BBB0 )
      v4 = &loc_804E0E5;
    dword_806B20C = (int)v4;
    sub_8061C98(a1);
    while ( 1 )
    {
      v6 = v11;
      v7 = (int)(v11++ + 1);
      if ( (unsigned int)(unsigned __int8)*v6 - 48 > 9 )
        break;
      if ( v8 < (unsigned __int8)*v6 )
      {
        dword_806B284 = (int)&loc_804E0F6;
        sub_80619DA(v5, v7);
        return;
      }
    }
    dword_806B25C = (int)&loc_804E0E5;
    sub_8061AC4(v5, v7);
    sub_804E128(a1, a2);
  }
}
// 80619DA: using guessed type double __fastcall sub_80619DA(_DWORD, _DWORD);
// 8061AC4: using guessed type int __fastcall sub_8061AC4(_DWORD, _DWORD);
// 8061C98: using guessed type int __usercall sub_8061C98@<eax>(double@<st0>);
// 806B20C: using guessed type int dword_806B20C;
// 806B25C: using guessed type int dword_806B25C;
// 806B284: using guessed type int dword_806B284;
// 806BBB0: using guessed type int dword_806BBB0;
// 806BBB4: using guessed type int dword_806BBB4;

//----- (0804E128) --------------------------------------------------------
int __usercall sub_804E128@<eax>(double a1@<st0>, _BYTE *a2)
{
  unsigned __int8 v2; // al
  int result; // eax
  bool v4; // [esp+9h] [ebp-Bh]
  unsigned __int8 *v5; // [esp+Ch] [ebp-8h]
  int v6; // [esp+10h] [ebp-4h]

  v4 = *a2 == 45;
  v5 = &a2[v4];
  sub_804DFFC(a1, (char **)&v5);
  if ( v2 <= 0x30u )
    return 0;
  v6 = byte_8063568[*v5];
  if ( v4 )
    result = -v6;
  else
    result = v6;
  return result;
}

//----- (0804E18F) --------------------------------------------------------
int __usercall sub_804E18F@<eax>(double a1@<st0>, unsigned __int8 *a2, unsigned __int8 *a3)
{
  bool v3; // zf
  void *v4; // eax
  int v5; // ebx
  void *v6; // eax
  int v7; // ecx
  unsigned __int8 v9; // al

  while ( 1 )
  {
    v9 = sub_804B3B5(*a2);
    if ( !byte_806BBD0[v9] )
      break;
    ++a2;
  }
  v3 = byte_806BBD0[(unsigned __int8)sub_804B3B5(*a3)] == 0;
  v4 = &loc_804E20A;
  if ( !v3 )
    v4 = &loc_804E1CE;
  dword_806B248 = (int)v4;
  sub_8061B34();
  v5 = sub_804E128(a1, a2);
  v3 = v5 == sub_804E128(a1, a3);
  v6 = &loc_804E248;
  if ( !v3 )
    v6 = &loc_804E288;
  dword_806B20C = (int)v6;
  sub_8061C98(a1);
  return sub_805DAFB(dword_806BBB4, v7, a2, a3, dword_806BBB0, dword_806BBB4);
}
// 8061B34: using guessed type int sub_8061B34(void);
// 8061C98: using guessed type int __usercall sub_8061C98@<eax>(double@<st0>);
// 806B20C: using guessed type int dword_806B20C;
// 806B248: using guessed type int dword_806B248;
// 806BBB0: using guessed type int dword_806BBB0;
// 806BBB4: using guessed type int dword_806BBB4;

//----- (0804E291) --------------------------------------------------------
int __usercall sub_804E291@<eax>(double a1@<st0>, _BYTE *a2, unsigned __int8 *a3)
{
  bool v3; // zf
  void *v4; // eax
  int v5; // ecx
  int v7; // [esp+0h] [ebp-18h]

  dword_806B2B8 = (int)&loc_804E2B2;
  sub_8061881();
  do
    v7 = (char)*++a2;
  while ( byte_806BBD0[(unsigned __int8)sub_804B3B5(v7)] );
  v7 = (char)*a3;
  v3 = byte_806BBD0[(unsigned __int8)sub_804B3B5(v7)] == 0;
  v4 = &loc_804E2FA;
  if ( !v3 )
    v4 = &loc_804E2FC;
  dword_806B20C = (int)v4;
  sub_8061C98(a1);
  return sub_805DAFB(dword_806BBB4, v5, a2, a3, dword_806BBB0, dword_806BBB4);
}
// 8061881: using guessed type int sub_8061881(void);
// 8061C98: using guessed type int __usercall sub_8061C98@<eax>(double@<st0>);
// 806B20C: using guessed type int dword_806B20C;
// 806B2B8: using guessed type int dword_806B2B8;
// 806BBB0: using guessed type int dword_806BBB0;
// 806BBB4: using guessed type int dword_806BBB4;

//----- (0804E34A) --------------------------------------------------------
int __cdecl sub_804E34A(int a1, int a2)
{
  _TBYTE s; // [esp+10h] [ebp-28h]
  _TBYTE s2; // [esp+20h] [ebp-18h]

  memset(&s, 0, 0xCu);
  *(long double *)&s = strtold(a1, 0);
  memset(&s2, 0, 0xCu);
  *(long double *)&s2 = strtold(a2, 0);
  return memcmp(&s, &s2, 0xCu);
}
// 80498F0: using guessed type double __cdecl strtold(_DWORD, _DWORD);

//----- (0804E3CE) --------------------------------------------------------
signed int __cdecl sub_804E3CE(int a1, int a2)
{
  int v2; // edx
  int v3; // ecx
  signed int result; // eax
  int v5; // [esp+18h] [ebp-30h]
  int v6; // [esp+1Ch] [ebp-2Ch]
  long double v7; // [esp+20h] [ebp-28h]
  long double v8; // [esp+30h] [ebp-18h]

  v7 = strtold(a1, &v5);
  v8 = strtold(a2, &v6);
  if ( a1 == v5 )
  {
    if ( a2 == v6 )
      result = 0;
    else
      result = -1;
  }
  else if ( a2 == v6 )
  {
    result = 1;
  }
  else if ( v8 <= v7 )
  {
    if ( v7 > v8 )
    {
      dword_806B31C = (int)&locret_804E4F7;
      sub_8061576(v3, v2);
    }
    if ( v8 == v7 )
      result = 0;
    else
      result = -1;
  }
  else
  {
    result = -1;
  }
  return result;
}
// 80498F0: using guessed type double __cdecl strtold(_DWORD, _DWORD);
// 8061576: using guessed type int __fastcall sub_8061576(_DWORD, _DWORD);
// 8061A4C: using guessed type int __fastcall sub_8061A4C(_DWORD, _DWORD);
// 806B270: using guessed type int dword_806B270;
// 806B31C: using guessed type int dword_806B31C;

//----- (0804E4F9) --------------------------------------------------------
int __usercall sub_804E4F9@<eax>(unsigned __int8 a1@<bl>, unsigned __int8 *a2, unsigned __int8 **a3)
{
  bool v3; // zf
  int v4; // edx
  int v5; // ecx
  void *v6; // eax
  unsigned __int8 v8; // al
  int v9; // edx
  int v10; // ecx
  int v11; // edx
  int v12; // ecx
  int v13; // [esp+0h] [ebp-28h]
  unsigned int v14; // [esp+10h] [ebp-18h]
  unsigned int v15; // [esp+14h] [ebp-14h]
  unsigned __int8 *v16; // [esp+18h] [ebp-10h]
  char *i; // [esp+1Ch] [ebp-Ch]
  unsigned int v18; // [esp+20h] [ebp-8h]

  v14 = 0;
  v15 = 12;
  v3 = byte_806BBD0[(unsigned __int8)sub_804B3B5(*a2)] == 0;
  v6 = &loc_804E54C;
  if ( !v3 )
    v6 = &loc_804E510;
  dword_806B2E0 = (int)v6;
  sub_806174E(v5, v4);
  v18 = (v14 + v15) >> 1;
  v16 = a2;
  for ( i = (&off_806B370)[2 * v18]; *i; ++i )
  {
    v8 = sub_804B3B5(*v16);
    sub_804B3B5(byte_806BED0[v8]);
    dword_806B270 = (int)&loc_804E5EA;
    if ( a1 < (unsigned __int8)sub_8061A4C(v10, v9) )
    {
      v15 = v18;
      dword_806B298 = (int)&loc_804E69D;
      sub_8061955(v12, v11);
    }
    v13 = (char)*v16;
    v13 = byte_806BED0[(unsigned __int8)sub_804B3B5(v13)];
    a1 = sub_804B3B5(v13);
    v13 = *i;
    if ( a1 > (unsigned __int8)sub_804B3B5(v13) )
    {
      v14 = v18 + 1;
      dword_806B308 = (int)&loc_804E69D;
      sub_806160F();
    }
    ++v16;
  }
  if ( a3 )
    *a3 = v16;
  return dword_806B374[2 * v18];
}
// 806160F: using guessed type int sub_806160F(void);
// 806174E: using guessed type int __fastcall sub_806174E(_DWORD, _DWORD);
// 8061A4C: using guessed type int __fastcall sub_8061A4C(_DWORD, _DWORD);
// 806B270: using guessed type int dword_806B270;
// 806B298: using guessed type int dword_806B298;
// 806B2E0: using guessed type int dword_806B2E0;
// 806B308: using guessed type int dword_806B308;
// 806B370: using guessed type char *off_806B370;
// 806B374: using guessed type int dword_806B374[];

//----- (0804E6B4) --------------------------------------------------------
unsigned int __usercall sub_804E6B4@<eax>(double a1@<st0>, char *a2)
{
  char *v2; // eax
  char *v3; // eax
  int v4; // edx
  int v5; // ecx
  int v6; // edx
  int v7; // ecx
  unsigned int result; // eax
  unsigned int v9; // et1
  char *v10; // [esp+18h] [ebp-20h]
  char ptr; // [esp+1Ch] [ebp-1Ch]
  unsigned int v12; // [esp+2Ch] [ebp-Ch]

  v12 = __readgsdword(0x14u);
  v10 = sub_805BFD4(a1, (int)a2, 0x10u);
  if ( !v10 )
  {
    v2 = gettext("open failed");
    sub_804B777((int)v2, a2);
  }
  sub_805C2BC((int)v10, &ptr, 0x10u);
  if ( sub_805C304(a1, v10) )
  {
    v3 = gettext("close failed");
    goto LABEL_7;
  }
  sub_8055D6A(&unk_806C090);
  sub_805612C(v4, v5, &ptr, 0x10u, (int)&unk_806C090);
  v9 = __readgsdword(0x14u);
  result = v9 ^ v12;
  if ( v9 != v12 )
  {
    dword_806B25C = (int)&loc_804E739;
    v3 = (char *)sub_8061AC4(v7, v6);
LABEL_7:
    sub_804B777((int)v3, a2);
  }
  return result;
}
// 8061AC4: using guessed type int __fastcall sub_8061AC4(_DWORD, _DWORD);
// 806B25C: using guessed type int dword_806B25C;

//----- (0804E7A9) --------------------------------------------------------
size_t __cdecl sub_804E7A9(char *dest, char *src, size_t n)
{
  char *v4; // ebx
  int *v5; // eax
  char *v6; // eax
  void *v7; // ebx
  char *v8; // eax
  size_t v10; // [esp+1Ch] [ebp-Ch]

  *__errno_location() = 0;
  v10 = strxfrm(dest, src, n);
  if ( *__errno_location() )
  {
    v4 = gettext("string transformation failed");
    v5 = __errno_location();
    error(0, *v5, v4);
    v6 = gettext("set LC_ALL='C' to work around the problem");
    error(0, 0, v6);
    v7 = sub_805B839(0, 8, src);
    v8 = gettext("the untransformed string was %s");
    error(2, 0, v8, v7);
  }
  return v10;
}

//----- (0804E881) --------------------------------------------------------
int __usercall sub_804E881@<eax>(double a1@<st0>, int a2, size_t a3, int a4, size_t a5)
{
  unsigned int v5; // eax
  size_t v6; // eax
  size_t v7; // edx
  char *v8; // eax
  size_t v9; // eax
  void *v10; // eax
  int v11; // ecx
  int v12; // edx
  int v13; // ecx
  int v14; // edx
  int v15; // ecx
  void *v16; // eax
  size_t v17; // eax
  int v18; // edx
  int v19; // ecx
  size_t v20; // eax
  char *s; // [esp+18h] [ebp-1150h]
  char *src; // [esp+1Ch] [ebp-114Ch]
  bool v24; // [esp+2Bh] [ebp-113Dh]
  int v25; // [esp+2Ch] [ebp-113Ch]
  char *dest; // [esp+30h] [ebp-1138h]
  unsigned int size; // [esp+34h] [ebp-1134h]
  void *ptr; // [esp+38h] [ebp-1130h]
  int v29; // [esp+3Ch] [ebp-112Ch]
  size_t v30; // [esp+40h] [ebp-1128h]
  size_t v31; // [esp+44h] [ebp-1124h]
  unsigned int v32; // [esp+48h] [ebp-1120h]
  size_t n; // [esp+4Ch] [ebp-111Ch]
  size_t v34; // [esp+50h] [ebp-1118h]
  char s1; // [esp+54h] [ebp-1114h]
  int v36; // [esp+64h] [ebp-1104h]
  int v37; // [esp+74h] [ebp-10F4h]
  char v38; // [esp+110h] [ebp-1058h]
  char v39; // [esp+1ACh] [ebp-FBCh]
  unsigned int v40; // [esp+114Ch] [ebp-1Ch]

  src = (char *)a2;
  s = (char *)a4;
  v40 = __readgsdword(0x14u);
  v25 = 0;
  dest = &v39;
  size = 4000;
  ptr = 0;
  qmemcpy(&v38, &unk_806C090, 0x9Cu);
  qmemcpy(&v37, &v38, 0x9Cu);
  if ( byte_806BBB8 )
  {
    v30 = a2 + a3;
    v31 = a4 + a5;
    while ( 1 )
    {
      v32 = 3 * (a5 + a3) + 2;
      if ( size < v32 )
      {
        v5 = 3 * (a5 + a3) + 2;
        if ( 3 * size >> 1 >= v32 )
          v5 = 3 * size >> 1;
        size = v5;
        free(ptr);
        ptr = malloc(size);
        dest = (char *)ptr;
        if ( !ptr )
        {
          dest = &v39;
          size = 4000;
        }
      }
      if ( (unsigned int)src >= v30 )
        v6 = 0;
      else
        v6 = sub_804E7A9(dest, src, size) + 1;
      n = v6;
      v24 = v6 <= size;
      if ( (unsigned int)s >= v31 )
      {
        v9 = 0;
      }
      else
      {
        if ( v24 )
          v7 = size - v6;
        else
          v7 = 0;
        if ( v24 )
          v8 = &dest[v6];
        else
          v8 = 0;
        v9 = sub_804E7A9(v8, s, v7) + 1;
      }
      v34 = v9;
      v10 = &loc_804EAB5;
      if ( v24 != 1 )
        v10 = &loc_804EACF;
      dword_806B2B8 = (int)v10;
      sub_8061881();
      v12 = n;
      if ( n + v34 > size )
      {
        size = n + v34;
        if ( n + v34 <= 0x55555554 )
          size = 3 * size >> 1;
        free(ptr);
        ptr = sub_805E3F4(size);
        dest = (char *)ptr;
        if ( (unsigned int)src < v30 )
          strxfrm((char *)ptr, src, n);
        if ( (unsigned int)s < v31 )
          strxfrm((char *)ptr + n, s, v34);
      }
      if ( (unsigned int)src < v30 )
        src += strlen(src) + 1;
      if ( (unsigned int)s < v31 )
        s += strlen(s) + 1;
      if ( (unsigned int)src >= v30 && (unsigned int)s >= v31 )
        break;
      sub_805612C(v12, v11, dest, n, (int)&v37);
      sub_805612C((int)&dest[n], v13, &dest[n], v34, (int)&v38);
      v16 = &loc_804ECA9;
      if ( v25 )
        v16 = &loc_804ED22;
      dword_806B298 = (int)v16;
      sub_8061955(v15, v14);
      v17 = n;
      if ( v34 <= n )
        v17 = v34;
      v25 = memcmp(dest, &dest[n], v17);
      if ( !v25 )
        v25 = (n > v34) - (n < v34);
    }
    a3 = n;
    src = dest;
    a5 = v34;
    s = &dest[n];
    sub_805612C((int)dest, v11, dest, n, (int)&v37);
  }
  else
  {
    sub_805612C((int)&v37, 0, (void *)a2, a3, (int)&v37);
  }
  sub_8055E5D(a1, &v37, &s1);
  sub_805612C(v18, v19, s, a5, (int)&v38);
  sub_8055E5D(a1, (int *)&v38, &v36);
  v29 = memcmp(&s1, &v36, 0x10u);
  if ( !v29 )
  {
    if ( !v25 )
    {
      v20 = a3;
      if ( a5 <= a3 )
        v20 = a5;
      v25 = memcmp(src, s, v20);
      if ( !v25 )
        v25 = (a3 > a5) - (a3 < a5);
    }
    v29 = v25;
  }
  free(ptr);
  return v29;
}
// 8061881: using guessed type int sub_8061881(void);
// 806B298: using guessed type int dword_806B298;
// 806B2B8: using guessed type int dword_806B2B8;
// 806BBB8: using guessed type char byte_806BBB8;

//----- (0804EE70) --------------------------------------------------------
int __cdecl sub_804EE70(char *a1, unsigned int a2)
{
  char *v2; // eax
  int v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_8059467(a1, a2 - (_DWORD)a1, 0);
  while ( (unsigned int)a1 < a2 )
  {
    v2 = a1++;
    v4 += *v2 == 9;
  }
  return v4;
}

//----- (0804EECC) --------------------------------------------------------
int __cdecl sub_804EECC(int a1, int a2)
{
  int v2; // eax
  void *v3; // eax

  while ( 1 )
  {
    v2 = a1--;
    if ( !v2 )
      break;
    putchar_unlocked(32);
  }
  dword_806B234 = (int)&loc_804EEFC;
  sub_8061BAC();
  v3 = &loc_804EF76;
  if ( a2 != 1 )
    v3 = &loc_804EEE2;
  dword_806B234 = (int)v3;
  sub_8061BAC();
  return putchar_unlocked(10);
}
// 8061BAC: using guessed type int sub_8061BAC(void);
// 806B234: using guessed type int dword_806B234;

//----- (0804EF84) --------------------------------------------------------
_BOOL4 __cdecl sub_804EF84(_BYTE *a1)
{
  void *v1; // eax
  int v2; // edx
  int v3; // ecx
  void *v4; // eax

  v1 = &loc_804EFAB;
  if ( a1[26] )
    v1 = &loc_804EFDA;
  dword_806B2F4 = (int)v1;
  sub_80616BF();
  v4 = &loc_804EFCF;
  if ( a1[28] )
    v4 = &loc_804EFDA;
  dword_806B2E0 = (int)v4;
  sub_806174E(v3, v2);
  return a1[29] != 0;
}
// 804EF84: could not find valid save-restore pair for ebx
// 806174E: using guessed type int __fastcall sub_806174E(_DWORD, _DWORD);
// 806B2E0: using guessed type int dword_806B2E0;
// 806B2F4: using guessed type int dword_806B2F4;

//----- (0804EFEB) --------------------------------------------------------
int __usercall sub_804EFEB@<eax>(int a1@<ecx>, unsigned __int8 a2@<bl>, double a3@<st0>, int a4, int a5)
{
  int v5; // edx
  void *v6; // eax
  int v7; // edx
  int v8; // ecx
  void *v9; // eax
  long double v10; // fst7
  void *v11; // eax
  _BOOL4 v12; // eax
  unsigned __int8 v13; // al
  _BOOL4 v14; // eax
  unsigned __int8 v16; // [esp+11h] [ebp-37h]
  unsigned __int8 *v17; // [esp+14h] [ebp-34h]
  unsigned __int8 *v18; // [esp+18h] [ebp-30h]
  unsigned __int8 *v19; // [esp+1Ch] [ebp-2Ch]
  unsigned __int8 *v20; // [esp+20h] [ebp-28h]
  char *v21; // [esp+24h] [ebp-24h]
  int v22; // [esp+28h] [ebp-20h]
  int v23; // [esp+2Ch] [ebp-1Ch]

  v21 = *(char **)a4;
  v19 = (unsigned __int8 *)v21;
  v5 = *(_DWORD *)(a4 + 4) - 1;
  v20 = (unsigned __int8 *)&v21[v5];
  if ( a5 )
  {
    if ( *(_DWORD *)a5 != -1 )
      v19 = sub_804D7D1(a4, a5);
    if ( *(_DWORD *)(a5 + 8) != -1 )
      v20 = (unsigned __int8 *)sub_804D9DE((char **)a4, a5);
    v6 = &loc_804F07D;
    if ( !*(_BYTE *)(a5 + 24) )
      v6 = &loc_804F0A0;
    dword_806B270 = (int)v6;
    sub_8061A4C(a1, v5);
    v9 = &loc_804F0A0;
    if ( *(_DWORD *)a5 == -1 )
      v9 = &loc_804F0D7;
    dword_806B284 = (int)v9;
    v10 = sub_80619DA(v8, v7);
    v11 = &loc_804F0C4;
    if ( *(_BYTE *)(a5 + 30) )
      v11 = &loc_804F0D7;
    dword_806B248 = (int)v11;
    sub_8061B34();
    if ( (unsigned __int8)sub_804EF84((_BYTE *)a5) )
    {
      v16 = *v20;
      *v20 = 0;
      while ( byte_806BBD0[(unsigned __int8)sub_804B3B5(*v19)] )
        ++v19;
      v17 = v19;
      if ( v20 >= v19 )
      {
        if ( *(_BYTE *)(a5 + 30) )
        {
          sub_804E4F9(a2, v19, &v17);
        }
        else if ( *(_BYTE *)(a5 + 28) )
        {
          strtold(v19, &v17);
          __asm { fstp    tbyte ptr [ebp+var_18] }
        }
        else if ( *(_BYTE *)(a5 + 26) || *(_BYTE *)(a5 + 29) )
        {
          v12 = v19 < v20 && *v19 == 45;
          v18 = &v19[v12];
          sub_804DFFC(*(double *)&v10, (char **)&v18);
          if ( v13 > 0x2Fu )
          {
            v14 = *(_BYTE *)(a5 + 29) && byte_8063568[*v18];
            v17 = &v18[v14];
          }
        }
        else
        {
          v17 = v20;
        }
      }
      else
      {
        v17 = v20;
      }
      *v20 = v16;
      v20 = v17;
    }
  }
  v22 = sub_804EE70(v21, (unsigned int)v19);
  v23 = sub_804EE70((char *)v19, (unsigned int)v20);
  return sub_804EECC(v22, v23);
}
// 804F163: inconsistent fpu stack
// 804EFEB: could not find valid save-restore pair for ebx
// 80498F0: using guessed type double __cdecl strtold(_DWORD, _DWORD);
// 80619DA: using guessed type double __fastcall sub_80619DA(_DWORD, _DWORD);
// 8061A4C: using guessed type int __fastcall sub_8061A4C(_DWORD, _DWORD);
// 8061B34: using guessed type int sub_8061B34(void);
// 806B248: using guessed type int dword_806B248;
// 806B270: using guessed type int dword_806B270;
// 806B284: using guessed type int dword_806B284;

//----- (0804F24B) --------------------------------------------------------
int __usercall sub_804F24B@<eax>(int a1@<ecx>, unsigned __int8 a2@<bl>, double a3@<st0>, int a4)
{
  int result; // eax
  int v5; // eax
  bool v6; // zf
  void *v7; // eax
  int v8; // [esp+1Ch] [ebp-Ch]

  v8 = dword_806BFE4;
  do
  {
    result = sub_804EFEB(a1, a2, a3, a4, v8);
    if ( !v8 )
      break;
    v5 = *(_DWORD *)(v8 + 36);
    v8 = v5;
    v6 = v5 == 0;
    v7 = &loc_804F299;
    if ( !v6 )
      v7 = &loc_804F259;
    dword_806B20C = (int)v7;
    sub_8061C98(a3);
    result = (unsigned __int8)byte_806BFE2 ^ 1;
    if ( byte_806BFE2 == 1 )
      break;
    result = (unsigned __int8)byte_806BFE1 ^ 1;
  }
  while ( byte_806BFE1 != 1 );
  return result;
}
// 8061C98: using guessed type int __usercall sub_8061C98@<eax>(double@<st0>);
// 806B20C: using guessed type int dword_806B20C;
// 806BFE1: using guessed type char byte_806BFE1;
// 806BFE2: using guessed type char byte_806BFE2;
// 806BFE4: using guessed type int dword_806BFE4;

//----- (0804F2BF) --------------------------------------------------------
int __usercall sub_804F2BF@<eax>(double a1@<st0>, int a2)
{
  void *v2; // eax
  bool v3; // zf
  void *v4; // eax
  void *v5; // eax
  char v6; // al

  if ( *(_DWORD *)(a2 + 16) || *(_DWORD *)(a2 + 20) || *(_BYTE *)(a2 + 24) == 1 )
    goto LABEL_19;
  v2 = &loc_804F31A;
  if ( *(_BYTE *)(a2 + 25) == 1 )
    v2 = &loc_804F3B7;
  dword_806B20C = (int)v2;
  sub_8061C98(a1);
  v3 = (unsigned __int8)sub_804EF84((_BYTE *)a2) == 1;
  v4 = &loc_804F345;
  if ( v3 )
    v4 = &loc_804F3B7;
  dword_806B248 = (int)v4;
  sub_8061B34();
  if ( *(_BYTE *)(a2 + 30) == 1 || *(_BYTE *)(a2 + 32) == 1 )
  {
LABEL_19:
    v6 = 0;
  }
  else
  {
    v5 = &loc_804F3B0;
    if ( *(_BYTE *)(a2 + 27) == 1 )
      v5 = &loc_804F3B7;
    dword_806B2B8 = (int)v5;
    sub_8061881();
    v6 = 1;
  }
  return v6 & 1;
}
// 804F2BF: could not find valid save-restore pair for ebx
// 8061881: using guessed type int sub_8061881(void);
// 8061B34: using guessed type int sub_8061B34(void);
// 8061C98: using guessed type int __usercall sub_8061C98@<eax>(double@<st0>);
// 806B20C: using guessed type int dword_806B20C;
// 806B248: using guessed type int dword_806B248;
// 806B2B8: using guessed type int dword_806B2B8;

//----- (0804F3C1) --------------------------------------------------------
_BYTE *__usercall sub_804F3C1@<eax>(int a1@<edx>, int a2@<ecx>, int a3, _BYTE *a4)
{
  _BYTE *v4; // eax
  _BYTE *v5; // eax
  _BYTE *v6; // eax
  _BYTE *v7; // eax
  _BYTE *v8; // eax
  _BYTE *v9; // eax
  _BYTE *v10; // eax
  _BYTE *v11; // eax
  _BYTE *v12; // eax
  _BYTE *v13; // eax
  _BYTE *v14; // eax
  _BYTE *result; // eax
  int v16; // [esp+Ch] [ebp+Ch]

  if ( *(_BYTE *)(a3 + 24) || *(_BYTE *)(a3 + 25) )
  {
    v4 = a4;
    a1 = (int)(a4++ + 1);
    *v4 = 98;
  }
  if ( *(_UNKNOWN **)(a3 + 16) == &unk_806BDD0 )
  {
    v5 = a4;
    a1 = (int)(a4++ + 1);
    *v5 = 100;
  }
  if ( *(_DWORD *)(a3 + 20) )
  {
    v6 = a4;
    a1 = (int)(a4++ + 1);
    *v6 = 102;
  }
  if ( *(_BYTE *)(a3 + 28) )
  {
    v7 = a4;
    a1 = (int)(a4++ + 1);
    *v7 = 103;
  }
  if ( *(_BYTE *)(a3 + 29) )
  {
    v8 = a4;
    a1 = (int)(a4++ + 1);
    *v8 = 104;
  }
  if ( *(_UNKNOWN **)(a3 + 16) == &unk_806BCD0 )
  {
    v9 = a4;
    a1 = (int)(a4++ + 1);
    *v9 = 105;
  }
  if ( *(_BYTE *)(a3 + 30) )
  {
    dword_806B270 = (int)&loc_804F481;
    sub_8061A4C(a2, a1);
  }
  else
  {
    while ( 1 )
    {
      if ( *(_BYTE *)(a3 + 26) )
      {
        v12 = a4++;
        *v12 = 110;
      }
      if ( *(_BYTE *)(a3 + 27) )
      {
        v13 = a4++;
        *v13 = 82;
      }
      if ( !*(_BYTE *)(a3 + 31) )
        break;
      v10 = a4;
      v16 = (int)(a4 + 1);
      *v10 = 114;
      dword_806B25C = (int)&loc_804F4EA;
      sub_8061AC4(a2, v16);
      v11 = (_BYTE *)v16;
      a4 = (_BYTE *)(v16 + 1);
      *v11 = 77;
    }
  }
  if ( *(_BYTE *)(a3 + 32) )
  {
    v14 = a4++;
    *v14 = 86;
  }
  result = a4;
  *a4 = 0;
  return result;
}
// 8061A4C: using guessed type int __fastcall sub_8061A4C(_DWORD, _DWORD);
// 8061AC4: using guessed type int __fastcall sub_8061AC4(_DWORD, _DWORD);
// 806B25C: using guessed type int dword_806B25C;
// 806B270: using guessed type int dword_806B270;

//----- (0804F509) --------------------------------------------------------
unsigned int __usercall sub_804F509@<eax>(double a1@<st0>, int *a2)
{
  void *v2; // eax
  bool v3; // zf
  void *v4; // eax
  void *v5; // eax
  int v6; // edx
  int v7; // ecx
  size_t v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char v13; // [esp+23h] [ebp-A5h]
  int v14; // [esp+44h] [ebp-84h]
  int v15; // [esp+48h] [ebp-80h]
  int v16; // [esp+4Ch] [ebp-7Ch]
  int v17; // [esp+50h] [ebp-78h]
  int v18; // [esp+54h] [ebp-74h]
  int v19; // [esp+58h] [ebp-70h]
  int v20; // [esp+5Ch] [ebp-6Ch]
  int v21; // [esp+60h] [ebp-68h]
  int v22; // [esp+64h] [ebp-64h]
  int v23; // [esp+68h] [ebp-60h]
  char s; // [esp+9Dh] [ebp-2Bh]
  unsigned int v25; // [esp+BCh] [ebp-Ch]

  v25 = __readgsdword(0x14u);
  v14 = *a2;
  v15 = a2[1];
  v16 = a2[2];
  v17 = a2[3];
  v18 = a2[4];
  v19 = a2[5];
  v20 = a2[6];
  v21 = a2[7];
  v22 = a2[8];
  v23 = a2[9];
  v2 = &loc_804FBEC;
  if ( dword_806BFE4 )
    v2 = &loc_804F58F;
  dword_806B308 = (int)v2;
  sub_806160F();
  v3 = (unsigned __int8)sub_804F2BF(a1, (int)&v14) == 1;
  v4 = &loc_804FC1A;
  if ( !v3 )
    v4 = &loc_804FC66;
  dword_806B20C = (int)v4;
  sub_8061C98(a1);
  if ( HIBYTE(v21) )
  {
    v5 = &loc_804FC4A;
    if ( byte_806BFE1 )
      v5 = &loc_804FC59;
    dword_806B234 = (int)v5;
    sub_8061BAC();
    if ( byte_806BFE2 && dword_806BFE4 )
    {
      v13 = HIBYTE(v21);
      if ( byte_806BFE1 != 1 && byte_806BFE2 != 1 )
        HIBYTE(v21) = 0;
      sub_804F3C1(v6, v7, (int)&v14, &s);
      v8 = strlen(&s);
      v9 = sub_804B427(v8);
      v10 = ngettext("option '-%s' is ignored", "options '-%s' are ignored", (unsigned int)v9);
      error(0, 0, v10, &s);
      HIBYTE(v21) = v13;
    }
  }
  if ( HIBYTE(v21) && byte_806BFE1 != 1 && byte_806BFE2 != 1 && dword_806BFE4 )
  {
    v11 = gettext("option '-r' only applies to last-resort comparison");
    error(0, 0, v11);
  }
  return __readgsdword(0x14u) ^ v25;
}
// 806160F: using guessed type int sub_806160F(void);
// 8061BAC: using guessed type int sub_8061BAC(void);
// 8061C98: using guessed type int __usercall sub_8061C98@<eax>(double@<st0>);
// 806B20C: using guessed type int dword_806B20C;
// 806B234: using guessed type int dword_806B234;
// 806B308: using guessed type int dword_806B308;
// 806BFE1: using guessed type char byte_806BFE1;
// 806BFE2: using guessed type char byte_806BFE2;
// 806BFE4: using guessed type int dword_806BFE4;

//----- (0804FD6E) --------------------------------------------------------
int __usercall sub_804FD6E@<eax>(int a1@<ecx>, double a2@<st0>, char **a3, char **a4)
{
  char *v4; // eax
  char *v5; // eax
  int v6; // edx
  void *v7; // eax
  void *v8; // eax
  unsigned __int8 v9; // al
  size_t v10; // eax
  char *v11; // ebx
  unsigned __int8 v12; // al
  char v13; // al
  unsigned __int8 v14; // al
  size_t v15; // eax
  char *v16; // ebx
  unsigned __int8 v17; // al
  char v18; // al
  void *v19; // eax
  void *v20; // eax
  int v21; // ecx
  char *v22; // edx
  int result; // eax
  void *v24; // eax
  void *v25; // eax
  int v26; // edx
  int v27; // ecx
  bool v28; // zf
  int v29; // edx
  int v30; // ecx
  void *v31; // eax
  void *v32; // eax
  int v33; // [esp+0h] [ebp-1018h]
  char **v34; // [esp+18h] [ebp-1000h]
  char **v35; // [esp+1Ch] [ebp-FFCh]
  char v36; // [esp+26h] [ebp-FF2h]
  char v37; // [esp+27h] [ebp-FF1h]
  int v38; // [esp+28h] [ebp-FF0h]
  void *s1; // [esp+2Ch] [ebp-FECh]
  void *s2; // [esp+30h] [ebp-FE8h]
  char *v41; // [esp+34h] [ebp-FE4h]
  char *v42; // [esp+38h] [ebp-FE0h]
  int v43; // [esp+3Ch] [ebp-FDCh]
  char *v44; // [esp+40h] [ebp-FD8h]
  char *v45; // [esp+44h] [ebp-FD4h]
  size_t v46; // [esp+48h] [ebp-FD0h]
  size_t v47; // [esp+4Ch] [ebp-FCCh]
  void *ptr; // [esp+50h] [ebp-FC8h]
  size_t v49; // [esp+54h] [ebp-FC4h]
  int v50; // [esp+58h] [ebp-FC0h]
  int v51; // [esp+5Ch] [ebp-FBCh]
  size_t v52; // [esp+60h] [ebp-FB8h]
  size_t n; // [esp+64h] [ebp-FB4h]
  size_t size; // [esp+68h] [ebp-FB0h]
  char v55; // [esp+6Ch] [ebp-FACh]
  unsigned int v56; // [esp+100Ch] [ebp-Ch]

  v35 = a3;
  v34 = a4;
  v56 = __readgsdword(0x14u);
  v38 = dword_806BFE4;
  s1 = a3[2];
  s2 = a4[2];
  v41 = a3[3];
  v42 = a4[3];
  v50 = *(_DWORD *)(dword_806BFE4 + 20);
  v51 = *(_DWORD *)(dword_806BFE4 + 16);
  v4 = (char *)s1;
  if ( v41 >= s1 )
    v4 = v41;
  v41 = v4;
  v5 = (char *)s2;
  if ( v42 >= s2 )
    v5 = v42;
  v42 = v5;
  v52 = v41 - (_BYTE *)s1;
  n = v5 - (_BYTE *)s2;
  if ( !byte_806BBB8 && !(unsigned __int8)sub_804EF84((_BYTE *)v38) && !*(_BYTE *)(v38 + 30) && !*(_BYTE *)(v38 + 27) )
  {
    v7 = &loc_804FEB8;
    if ( !*(_BYTE *)(v38 + 32) )
      v7 = &loc_8050423;
    dword_806B298 = (int)v7;
    sub_8061955(a1, v6);
  }
  if ( v51 || v50 )
  {
    size = v52 + n + 2;
    if ( size <= 0xFA0 )
    {
      v44 = &v55;
      ptr = 0;
      dword_806B2E0 = (int)&loc_804FF3E;
      sub_806174E(a1, v52);
    }
    ptr = sub_805E3F4(size);
    v44 = (char *)ptr;
    v45 = (char *)ptr + v52 + 1;
    v49 = 0;
    v46 = 0;
    while ( v49 < v52 )
    {
      v8 = &loc_804FF92;
      if ( !v51 )
        v8 = &loc_804FFC3;
      dword_806B20C = (int)v8;
      sub_8061C98(a2);
      v33 = *((char *)s1 + v49);
      v9 = sub_804B3B5(v33);
      if ( *(_BYTE *)(v9 + v51) ^ 1 )
      {
        v10 = v46++;
        v11 = &v44[v10];
        if ( v50 )
        {
          v33 = *((char *)s1 + v49);
          v12 = sub_804B3B5(v33);
          v13 = *(_BYTE *)(v12 + v50);
        }
        else
        {
          v13 = *((_BYTE *)s1 + v49);
        }
        *v11 = v13;
      }
      ++v49;
    }
    v44[v46] = 0;
    v49 = 0;
    v47 = 0;
    while ( v49 < n )
    {
      if ( !v51 || (v33 = *((char *)s2 + v49), v14 = sub_804B3B5(v33), *(_BYTE *)(v14 + v51) ^ 1) )
      {
        v15 = v47++;
        v16 = &v45[v15];
        if ( v50 )
        {
          v33 = *((char *)s2 + v49);
          v17 = sub_804B3B5(v33);
          v18 = *(_BYTE *)(v17 + v50);
        }
        else
        {
          v18 = *((_BYTE *)s2 + v49);
        }
        *v16 = v18;
      }
      ++v49;
    }
    v45[v47] = 0;
  }
  else
  {
    v44 = (char *)s1;
    v46 = v52;
    v36 = *((_BYTE *)s1 + v52);
    *((_BYTE *)s1 + v52) = 0;
    v45 = (char *)s2;
    v47 = n;
    v37 = *((_BYTE *)s2 + n);
    *((_BYTE *)s2 + n) = 0;
  }
  if ( *(_BYTE *)(v38 + 26) )
  {
    v43 = sub_804E291(a2, v44, (unsigned __int8 *)v45);
  }
  else if ( *(_BYTE *)(v38 + 28) )
  {
    v43 = sub_804E3CE((int)v44, (int)v45);
  }
  else
  {
    v19 = &loc_805023A;
    if ( !*(_BYTE *)(v38 + 29) )
      v19 = &loc_805025D;
    dword_806B2B8 = (int)v19;
    sub_8061881();
    v43 = sub_804E18F(a2, (unsigned __int8 *)v44, (unsigned __int8 *)v45);
  }
  v20 = &loc_80503D4;
  if ( v51 )
    v20 = &loc_80503DD;
  dword_806B20C = (int)v20;
  sub_8061C98(a2);
  if ( v50 )
  {
    free(ptr);
  }
  else
  {
    v44[v46] = v36;
    v22 = &v45[v47];
    v45[v47] = v37;
  }
  if ( !v43 )
  {
    v38 = *(_DWORD *)(v38 + 36);
    if ( !v38 )
      return 0;
    v24 = &loc_8050894;
    if ( *(_DWORD *)(v38 + 8) == -1 )
      v24 = &loc_80508D2;
    dword_806B298 = (int)v24;
    sub_8061955(v21, v22);
    v41 = (char *)sub_804D9DE(v35, v38);
    v42 = (char *)sub_804D9DE(v34, v38);
    if ( *(_DWORD *)v38 == -1 )
    {
      s1 = *v35;
      s2 = *v34;
      v25 = &loc_805099B;
      if ( !*(_BYTE *)(v38 + 24) )
        v25 = &loc_8050A54;
      dword_806B234 = (int)v25;
      sub_8061BAC();
      if ( s1 < v41 )
      {
        v33 = *(char *)s1;
        v28 = byte_806BBD0[(unsigned __int8)sub_804B3B5(v33)] == 0;
        v31 = &loc_80509ED;
        if ( !v28 )
          v31 = &loc_805099D;
        dword_806B270 = (int)v31;
        sub_8061A4C(v30, v29);
      }
      dword_806B270 = (int)&loc_8050A0B;
      sub_8061A4C(v27, v26);
      s2 = (char *)s2 + 1;
      if ( s2 < v42 )
      {
        v33 = *(char *)s2;
        v28 = byte_806BBD0[(unsigned __int8)sub_804B3B5(v33)] == 0;
        v32 = &loc_8050A54;
        if ( !v28 )
          v32 = &loc_8050A04;
        dword_806B20C = (int)v32;
        sub_8061C98(a2);
      }
    }
    else
    {
      s1 = sub_804D7D1((int)v35, v38);
      s2 = sub_804D7D1((int)v34, v38);
    }
    dword_806B234 = (int)&loc_804FDDC;
    sub_8061BAC();
  }
  if ( *(_BYTE *)(v38 + 31) )
    result = -v43;
  else
    result = v43;
  return result;
}
// 806174E: using guessed type int __fastcall sub_806174E(_DWORD, _DWORD);
// 8061881: using guessed type int sub_8061881(void);
// 8061A4C: using guessed type int __fastcall sub_8061A4C(_DWORD, _DWORD);
// 8061BAC: using guessed type int sub_8061BAC(void);
// 8061C98: using guessed type int __usercall sub_8061C98@<eax>(double@<st0>);
// 806B20C: using guessed type int dword_806B20C;
// 806B234: using guessed type int dword_806B234;
// 806B270: using guessed type int dword_806B270;
// 806B298: using guessed type int dword_806B298;
// 806B2B8: using guessed type int dword_806B2B8;
// 806B2E0: using guessed type int dword_806B2E0;
// 806BBB8: using guessed type char byte_806BBB8;
// 806BFE4: using guessed type int dword_806BFE4;

//----- (08050AA3) --------------------------------------------------------
int __usercall sub_8050AA3@<eax>(int a1@<edx>, int a2@<ecx>, double a3@<st0>, int a4, int a5)
{
  void *v6; // eax
  void *v7; // eax
  int v8; // [esp+14h] [ebp-14h]
  int v9; // [esp+14h] [ebp-14h]

  if ( dword_806BFE4 )
  {
    v8 = sub_804FD6E(a2, a3, (char **)a4, (char **)a5);
    if ( v8 || byte_806BFE2 || byte_806BFE1 )
      return v8;
  }
  if ( *(_DWORD *)(a4 + 4) == 1 )
  {
    v9 = -(*(_DWORD *)(a5 + 4) != 1);
  }
  else
  {
    v6 = &loc_8050B3D;
    if ( *(_DWORD *)(a5 + 4) != 1 )
      v6 = &loc_8050B49;
    dword_806B31C = (int)v6;
    sub_8061576(a2, a1);
    v9 = 1;
  }
  v7 = &loc_8050C19;
  if ( !byte_806BFE0 )
    v7 = &loc_8050C20;
  dword_806B234 = (int)v7;
  sub_8061BAC();
  return -v9;
}
// 8061576: using guessed type int __fastcall sub_8061576(_DWORD, _DWORD);
// 8061BAC: using guessed type int sub_8061BAC(void);
// 806B234: using guessed type int dword_806B234;
// 806B31C: using guessed type int dword_806B31C;
// 806BFE0: using guessed type char byte_806BFE0;
// 806BFE1: using guessed type char byte_806BFE1;
// 806BFE2: using guessed type char byte_806BFE2;
// 806BFE4: using guessed type int dword_806BFE4;

//----- (08050C29) --------------------------------------------------------
int __usercall sub_8050C29@<eax>(int a1@<ecx>, unsigned __int8 a2@<bl>, double a3@<st0>, int a4, FILE *stream, int a6)
{
  _BYTE *v6; // eax
  bool v7; // zf
  void *v8; // eax
  char *v9; // eax
  int result; // eax
  char *v11; // eax
  _BYTE *v12; // [esp+20h] [ebp-18h]
  _BYTE *ptr; // [esp+24h] [ebp-14h]
  size_t n; // [esp+28h] [ebp-10h]
  unsigned int v15; // [esp+2Ch] [ebp-Ch]

  ptr = *(_BYTE **)a4;
  n = *(_DWORD *)(a4 + 4);
  v15 = *(_DWORD *)a4 + n;
  if ( a6 || !byte_806BFEC )
  {
    *(_BYTE *)(v15 - 1) = byte_806B350;
    if ( fwrite_unlocked(ptr, 1u, n, stream) != n )
    {
      v11 = gettext("write failed");
      sub_804B777((int)v11, (char *)a6);
    }
    result = v15 - 1;
    *(_BYTE *)(v15 - 1) = 0;
  }
  else
  {
    v12 = *(_BYTE **)a4;
    while ( (unsigned int)v12 < v15 )
    {
      v6 = v12++;
      v7 = *v6 == 9;
      v8 = &loc_8050C9A;
      if ( !v7 )
        v8 = &loc_8050CA0;
      dword_806B2CC = (int)v8;
      sub_80617DA();
      if ( fputc_unlocked(62, stream) == -1 )
      {
        v9 = gettext("write failed");
        sub_804B777((int)v9, 0);
      }
    }
    result = sub_804F24B(a1, a2, a3, a4);
  }
  return result;
}
// 80617DA: using guessed type int sub_80617DA(void);
// 806B2CC: using guessed type int dword_806B2CC;
// 806B350: using guessed type char byte_806B350;
// 806BFEC: using guessed type char byte_806BFEC;

//----- (08050D4F) --------------------------------------------------------
void __cdecl __noreturn sub_8050D4F(char *a2)
{
  sub_804C285(a2, "r");
}

//----- (08051154) --------------------------------------------------------
unsigned int __usercall sub_8051154@<eax>(double a1@<st0>, int a2, unsigned int a3, void **a4)
{
  FILE **v4; // ebx
  void *v5; // eax
  FILE *v6; // eax
  unsigned int i; // [esp+18h] [ebp-10h]
  _DWORD *v9; // [esp+1Ch] [ebp-Ch]

  *a4 = sub_805E2D3(a3, 4u);
  v9 = *a4;
  for ( i = 0; i < a3; ++i )
  {
    v4 = (FILE **)&v9[i];
    if ( *(_DWORD *)(8 * i + a2 + 4) )
    {
      v5 = &loc_80511E2;
      if ( !*(_BYTE *)(*(_DWORD *)(8 * i + a2 + 4) + 8) )
        v5 = &loc_80511FE;
      dword_806B2B8 = (int)v5;
      v4 = (FILE **)&v9[i];
      sub_8061881();
      v6 = (FILE *)sub_804C707(a1, *(_DWORD *)(8 * i + a2 + 4));
    }
    else
    {
      v6 = sub_804C128(*(char **)(8 * i + a2), "r");
    }
    *v4 = v6;
    if ( !v9[i] )
      break;
  }
  return i;
}
// 8061881: using guessed type int sub_8061881(void);
// 806B2B8: using guessed type int dword_806B2B8;

//----- (08051251) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __usercall sub_8051251(int a1@<ebx>, double a2@<st0>, int a3, int a4, int a5, FILE *stream, int a7, void *a8)
{
  unsigned int *v8; // edx
  int v9; // ecx
  size_t v10; // edx
  int v11; // ecx
  int v12; // eax
  int v13; // edx
  int v14; // ecx
  bool v15; // zf
  bool v16; // sf
  void *v17; // eax
  int v18; // ecx
  int v19; // edx
  void *v20; // eax
  void *v21; // eax
  int v22; // edx
  int v23; // ecx
  int v24; // edx
  int v25; // ecx
  void *v26; // eax
  int v27; // ecx
  int v28; // edx
  int v29; // ecx
  FILE *v30; // edx
  _DWORD *v31; // edx
  int v32; // ecx
  _DWORD *v33; // ecx
  _DWORD *v34; // eax
  int v35; // edx
  _DWORD *v36; // eax
  _DWORD *v37; // edx
  int v38; // eax
  _DWORD *v39; // [esp+0h] [ebp-78h]
  int v40; // [esp+4h] [ebp-74h]
  int v41; // [esp+8h] [ebp-70h]
  void **v42; // [esp+14h] [ebp-64h]
  size_t size; // [esp+18h] [ebp-60h]
  unsigned int i; // [esp+1Ch] [ebp-5Ch]
  unsigned int v45; // [esp+20h] [ebp-58h]
  unsigned int v46; // [esp+24h] [ebp-54h]
  unsigned int v47; // [esp+28h] [ebp-50h]
  unsigned int v48; // [esp+2Ch] [ebp-4Ch]
  void *v49; // [esp+30h] [ebp-48h]
  void *v50; // [esp+34h] [ebp-44h]
  void *v51; // [esp+38h] [ebp-40h]
  void *v52; // [esp+3Ch] [ebp-3Ch]
  int v53; // [esp+40h] [ebp-38h]
  unsigned int v54; // [esp+48h] [ebp-30h]
  int v55; // [esp+4Ch] [ebp-2Ch]
  int v56; // [esp+50h] [ebp-28h]
  __int64 v57; // [esp+54h] [ebp-24h]
  unsigned int v58; // [esp+5Ch] [ebp-1Ch]
  void *ptr; // [esp+60h] [ebp-18h]
  size_t n; // [esp+64h] [ebp-14h]
  char *v61; // [esp+68h] [ebp-10h]
  char *v62; // [esp+6Ch] [ebp-Ch]

  v49 = sub_805E2D3(a5, 0x1Cu);
  v42 = 0;
  size = 0;
  v50 = sub_805E2D3(a5, 4u);
  v51 = sub_805E2D3(a5, 4u);
  v52 = sub_805E2D3(a5, 4u);
  v53 = dword_806BFE4;
  ptr = 0;
  i = 0;
  if ( i < a5 )
  {
    v10 = ::size / a5;
    if ( ::size / a5 < dword_806B3D0 )
      v10 = dword_806B3D0;
    sub_804D6BF((int)v49 + 28 * i, 16, v10);
  }
  for ( i = 0; i < a5; ++i )
  {
    v8 = (unsigned int *)((char *)v52 + 4 * i);
    *v8 = i;
  }
  for ( i = 1; i < a5; i = 1 )
  {
    v11 = 4 * *((_DWORD *)v52 + i + 0x3FFFFFFF);
    v12 = sub_8050AA3(
            *((_DWORD *)v50 + *((_DWORD *)v52 + i)),
            v11,
            a2,
            *(_DWORD *)((char *)v50 + v11),
            *((_DWORD *)v50 + *((_DWORD *)v52 + i)));
    v15 = v12 == 0;
    v16 = v12 < 0;
    v17 = &loc_805155E;
    if ( v16 || v15 )
      v17 = &loc_80515B9;
    dword_806B284 = (int)v17;
    *(long double *)&a2 = sub_80619DA(v14, v13);
    v54 = *((_DWORD *)v52 + i + 0x3FFFFFFF);
    v9 = 4 * i;
    *((_DWORD *)v52 + i + 0x3FFFFFFF) = *((_DWORD *)v52 + i);
    v8 = (unsigned int *)((char *)v52 + 4 * i);
    *v8 = v54;
  }
  dword_806B31C = (int)&loc_8051B9C;
  sub_8061576(v9, v8);
  do
  {
    v19 = 4 * *(_DWORD *)v52;
    v55 = *(_DWORD *)((char *)v50 + v19);
    v20 = &loc_805161A;
    if ( !byte_806BFE2 )
      v20 = &loc_805174E;
    dword_806B25C = (int)v20;
    sub_8061AC4(v18, v19);
    v21 = &loc_8051639;
    if ( !v42 )
      v21 = &loc_8051688;
    dword_806B2CC = (int)v21;
    sub_80617DA();
    v15 = sub_8050AA3(v22, v23, a2, (int)v42, v55) == 0;
    v26 = &loc_8051668;
    if ( v15 )
      v26 = &loc_8051688;
    dword_806B31C = (int)v26;
    sub_8061576(v25, v24);
    v42 = 0;
    sub_8050C29(v27, a1, a2, (int)&ptr, stream, a7);
    if ( !v42 )
    {
      v42 = &ptr;
      if ( *(_DWORD *)(v55 + 4) > size )
      {
        do
        {
          if ( !size )
          {
            size = *(_DWORD *)(v55 + 4);
            dword_806B2E0 = (int)&loc_80516D7;
            sub_806174E(v29, v28);
          }
          size *= 2;
        }
        while ( size < *(_DWORD *)(v55 + 4) );
        free(ptr);
        ptr = sub_805E3F4(size);
      }
      n = *(_DWORD *)(v55 + 4);
      memcpy(ptr, *(const void **)v55, n);
      if ( v53 )
      {
        v61 = (char *)ptr + *(_DWORD *)(v55 + 8) - *(_DWORD *)v55;
        v62 = (char *)ptr + *(_DWORD *)(v55 + 12) - *(_DWORD *)v55;
      }
    }
    if ( *((_DWORD *)v51 + *(_DWORD *)v52) >= (unsigned int)v55 )
    {
      v30 = (FILE *)*((_DWORD *)a8 + *(_DWORD *)v52);
      a1 = 28 * *(_DWORD *)v52;
      v41 = *(_DWORD *)(8 * *(_DWORD *)v52 + a3);
      if ( (unsigned __int8)sub_804DBA3((int)v49 + a1, v30, v41) )
      {
        v39 = (char *)v49 + 28 * *(_DWORD *)v52;
        v56 = sub_804D7B6(v39);
        *((_DWORD *)v50 + *(_DWORD *)v52) = v56 - 16;
        v31 = (char *)v51 + 4 * *(_DWORD *)v52;
        v32 = -16 * *((_DWORD *)v49 + 7 * *(_DWORD *)v52 + 2);
        *v31 = v32 + v56;
        dword_806B2E0 = (int)&loc_8051A88;
        sub_806174E(v32, v31);
      }
      for ( i = 1; i < a5; ++i )
      {
        if ( *((_DWORD *)v52 + i) > *(_DWORD *)v52 )
          --*((_DWORD *)v52 + i);
      }
      --a5;
      sub_804C2DF(a2, *((FILE **)a8 + *(_DWORD *)v52), *(_DWORD *)(8 * *(_DWORD *)v52 + a3));
      if ( *(_DWORD *)v52 < (unsigned int)a4 )
      {
        --a4;
        sub_804C995(a2, *(char **)(8 * *(_DWORD *)v52 + a3));
      }
      free(*((void **)v49 + 7 * *(_DWORD *)v52));
      for ( i = *(_DWORD *)v52; i < a5; ++i )
      {
        *((_DWORD *)a8 + i) = *((_DWORD *)a8 + i + 1);
        v33 = (_DWORD *)(8 * i + a3);
        v34 = (_DWORD *)(8 * (i + 1) + a3);
        v35 = v34[1];
        *v33 = *v34;
        v33[1] = v35;
        v36 = (char *)v49 + 28 * i;
        v37 = (char *)v49 + 28 * (i + 1);
        *v36 = *v37;
        v36[1] = v37[1];
        v36[2] = v37[2];
        v36[3] = v37[3];
        v36[4] = v37[4];
        v36[5] = v37[5];
        v36[6] = v37[6];
        *((_DWORD *)v50 + i) = *((_DWORD *)v50 + i + 1);
        v18 = 4 * (i + 1);
        *((_DWORD *)v51 + i) = *(_DWORD *)((char *)v51 + v18);
      }
      for ( i = 0; i < a5; ++i )
      {
        v18 = 4 * (i + 1);
        *((_DWORD *)v52 + i) = *(_DWORD *)((char *)v52 + v18);
      }
    }
    else
    {
      *((_DWORD *)v50 + *(_DWORD *)v52) = v55 - 16;
      v46 = 1;
      v47 = a5;
      v48 = 1;
      LODWORD(v57) = *(_DWORD *)v52;
      while ( v46 < v47 )
      {
        v38 = *((_DWORD *)v50 + v57);
        v40 = *((_DWORD *)v50 + *((_DWORD *)v52 + v48));
        HIDWORD(v57) = sub_8050AA3(v40, 4 * v57, a2, v38, v40);
        if ( v57 >= *((unsigned int *)v52 + v48) )
          v46 = v48 + 1;
        else
          v47 = v48;
        v48 = (v46 + v47) >> 1;
      }
      v58 = v46 - 1;
      v45 = 0;
      dword_806B308 = (int)&loc_8051B80;
      sub_806160F();
      do
      {
        v18 = 4 * (v45 + 1);
        *((_DWORD *)v52 + v45++) = *(_DWORD *)((char *)v52 + v18);
      }
      while ( v45 < v58 );
      *((_DWORD *)v52 + v58) = v57;
    }
  }
  while ( a5 );
  if ( byte_806BFE2 && v42 )
  {
    sub_8050C29(v18, a1, a2, (int)&ptr, stream, a7);
    free(ptr);
  }
  sub_804C2DF(a2, stream, a7);
  free(a8);
  free(v49);
  free(v52);
  free(v51);
  free(v50);
}
// 8051251: variables would overlap: st7.8 and fst7.12
// 8061576: using guessed type int __fastcall sub_8061576(_DWORD, _DWORD);
// 806160F: using guessed type int sub_806160F(void);
// 806174E: using guessed type int __fastcall sub_806174E(_DWORD, _DWORD);
// 80617DA: using guessed type int sub_80617DA(void);
// 80619DA: using guessed type double __fastcall sub_80619DA(_DWORD, _DWORD);
// 8061AC4: using guessed type int __fastcall sub_8061AC4(_DWORD, _DWORD);
// 806B25C: using guessed type int dword_806B25C;
// 806B284: using guessed type int dword_806B284;
// 806B2CC: using guessed type int dword_806B2CC;
// 806B2E0: using guessed type int dword_806B2E0;
// 806B308: using guessed type int dword_806B308;
// 806B31C: using guessed type int dword_806B31C;
// 806BFE2: using guessed type char byte_806BFE2;
// 806BFE4: using guessed type int dword_806BFE4;

//----- (08051C2A) --------------------------------------------------------
int __usercall sub_8051C2A@<eax>(int a1@<ebx>, double a2@<st0>, int a3, int a4, int a5, FILE *stream, int a7)
{
  char *v8; // ebx
  char *v9; // eax
  void *v10; // [esp+28h] [ebp-10h]
  int v11; // [esp+2Ch] [ebp-Ch]

  v11 = sub_8051154(a2, a3, a5, &v10);
  if ( v11 < (unsigned int)a5 && (unsigned int)v11 <= 1 )
  {
    v8 = *(char **)(8 * v11 + a3);
    v9 = gettext("open failed");
    sub_804B777((int)v9, v8);
  }
  sub_8051251(a1, a2, a3, a4, v11, stream, a7, v10);
  return v11;
}

//----- (08051CCF) --------------------------------------------------------
int __usercall sub_8051CCF@<eax>(int a1@<ecx>, double a2@<st0>, _DWORD *a3, unsigned int a4, _DWORD *a5)
{
  int v5; // ecx
  int v6; // edx
  void *v7; // eax
  int result; // eax
  unsigned int v9; // [esp+14h] [ebp-14h]
  int v10; // [esp+18h] [ebp-10h]
  _DWORD *v11; // [esp+1Ch] [ebp-Ch]
  _DWORD *v12; // [esp+30h] [ebp+8h]
  _DWORD *v13; // [esp+38h] [ebp+10h]

  v9 = a4 >> 1;
  v10 = a4 - (a4 >> 1);
  v11 = &a3[-4 * (a4 >> 1)];
  while ( sub_8050AA3((int)(v11 - 4), a1, a2, (int)(a5 - 4), (int)(v11 - 4)) > 0 )
  {
    a3 -= 4;
    v11 -= 4;
    *a3 = *v11;
    a3[1] = v11[1];
    a1 = v11[2];
    a3[2] = a1;
    a3[3] = v11[3];
    if ( !--v10 )
    {
      do
      {
        a3 -= 4;
        a5 -= 4;
        result = (int)a3;
        *a3 = *a5;
        a3[1] = a5[1];
        a3[2] = a5[2];
        a3[3] = a5[3];
        --v9;
      }
      while ( v9 );
      return result;
    }
  }
  v12 = a3 - 4;
  v13 = a5 - 4;
  *v12 = *v13;
  v12[1] = v13[1];
  v5 = v13[2];
  v12[2] = v5;
  v6 = v13[3];
  v12[3] = v6;
  v7 = &loc_8051D5F;
  if ( v9 != 1 )
    v7 = &loc_8051DBF;
  dword_806B2E0 = (int)v7;
  return sub_806174E(v5, v6);
}
// 806174E: using guessed type int __fastcall sub_806174E(_DWORD, _DWORD);
// 806B2E0: using guessed type int dword_806B2E0;

//----- (08051DC6) --------------------------------------------------------
int __usercall sub_8051DC6@<eax>(int a1@<ecx>, double a2@<st0>, _DWORD *a3, unsigned int a4, _DWORD *a5, unsigned __int8 a6)
{
  int result; // eax
  _DWORD *v7; // eax
  _DWORD *v8; // edx
  int v9; // ecx
  _DWORD *v10; // edx
  _DWORD *v11; // edx
  _DWORD *v12; // edx
  int v13; // eax
  _DWORD *v14; // edx
  void *v15; // eax
  int v16; // ecx
  int v17; // [esp+2Ch] [ebp-1Ch]
  unsigned int v18; // [esp+30h] [ebp-18h]

  if ( a4 == 2 )
  {
    result = sub_8050AA3((int)(a3 - 8), a1, a2, (int)(a3 - 4), (int)(a3 - 8)) > 0;
    v17 = result;
    if ( a6 )
    {
      v7 = a5 - 4;
      v8 = &a3[4 * ~v17];
      *v7 = *v8;
      v7[1] = v8[1];
      v7[2] = v8[2];
      v7[3] = v8[3];
      result = (int)(a5 - 8);
      v9 = 4 * (v17 - 2);
      *(_DWORD *)result = a3[v9];
      *(_DWORD *)(result + 4) = a3[v9 + 1];
      *(_DWORD *)(result + 8) = a3[v9 + 2];
      *(_DWORD *)(result + 12) = a3[v9 + 3];
    }
    else if ( result )
    {
      v10 = a5 - 4;
      *v10 = *(a3 - 4);
      v10[1] = *(a3 - 3);
      v10[2] = *(a3 - 2);
      v10[3] = *(a3 - 1);
      v11 = a3 - 4;
      *v11 = *(a3 - 8);
      v11[1] = *(a3 - 7);
      v11[2] = *(a3 - 6);
      v11[3] = *(a3 - 5);
      v12 = a3 - 8;
      *v12 = *(a5 - 4);
      v12[1] = *(a5 - 3);
      v12[2] = *(a5 - 2);
      result = *(a5 - 1);
      v12[3] = result;
    }
  }
  else
  {
    v18 = a4 >> 1;
    if ( a6 )
      v13 = -4 * v18;
    else
      v13 = 0;
    sub_8051DC6(&a3[-4 * (a4 >> 1)], a4 - (a4 >> 1), &a5[v13], a6);
    if ( v18 <= 1 )
    {
      if ( a6 != 1 )
      {
        v14 = a5 - 4;
        *v14 = *(a3 - 4);
        v14[1] = *(a3 - 3);
        v14[2] = *(a3 - 2);
        v14[3] = *(a3 - 1);
      }
    }
    else
    {
      sub_8051DC6(a3, v18, a5, a6 == 0);
    }
    v15 = &loc_8051FB7;
    if ( !a6 )
      v15 = &loc_8051FC5;
    dword_806B248 = (int)v15;
    sub_8061B34();
    result = sub_8051CCF(v16, a2, a5, a4, a3);
  }
  return result;
}
// 8061B34: using guessed type int sub_8061B34(void);
// 806B248: using guessed type int dword_806B248;

//----- (08051FEC) --------------------------------------------------------
pthread_mutex_t *__cdecl sub_8051FEC(unsigned int a1, int a2, int a3)
{
  pthread_mutex_t *v3; // eax
  pthread_mutex_t *v4; // ST28_4
  pthread_mutex_t *v5; // ST2C_4

  v3 = (pthread_mutex_t *)sub_805E3F4(144 * a1);
  v4 = v3;
  v5 = v3;
  v3->__kind = 0;
  v5->__owner = v5->__kind;
  v5->__count = v5->__owner;
  v5->__lock = v5->__count;
  v3->__nusers = 0;
  v3[1].__lock = a2;
  v3->__spins = v3[1].__lock;
  v3[1].__count = 0;
  v3[1].__nusers = 0;
  v3[1].__size[20] = 0;
  pthread_mutex_init(v3 + 2, 0);
  sub_805211F(v5, v5 + 3, a3, a1, a2, 0);
  return v4;
}

//----- (0805211F) --------------------------------------------------------
int __cdecl sub_805211F(_DWORD *a1, pthread_mutex_t *a2, int a3, unsigned int a4, int a5, char a6)
{
  int v6; // ecx
  unsigned int v7; // eax
  int v8; // edx
  pthread_mutex_t *v9; // eax
  int v10; // eax
  int v12; // [esp+30h] [ebp-28h]
  int v13; // [esp+34h] [ebp-24h]
  int v14; // [esp+38h] [ebp-20h]
  int v15; // [esp+3Ch] [ebp-1Ch]
  pthread_mutex_t *v16; // [esp+44h] [ebp-14h]
  int v17; // [esp+64h] [ebp+Ch]

  if ( a6 )
    v7 = a1[5];
  else
    v7 = a1[6];
  v12 = v7 >> 1;
  v13 = v7 - (v7 >> 1);
  v14 = -16 * a5 + a3;
  v8 = -16 * (v7 >> 1);
  v15 = v8 + v14;
  if ( a6 )
  {
    dword_806B270 = (int)&loc_80521A4;
    sub_8061A4C(v6, v8);
  }
  v9 = a2;
  v17 = (int)&a2[3];
  v16 = v9;
  v9->__owner = v14;
  v16->__lock = v16->__owner;
  v9->__kind = v15;
  v16->__count = v16->__kind;
  v9->__nusers = (unsigned int)(a1 + 3);
  v9->__spins = v12;
  v9[1].__lock = v13;
  v9[1].__count = (unsigned int)a1;
  v9[1].__nusers = a1[10] + 1;
  v9[1].__size[20] = 0;
  pthread_mutex_init(v9 + 2, 0);
  if ( a4 <= 1 )
  {
    v16[1].__owner = 0;
    v16[1].__kind = 0;
  }
  else
  {
    v16[1].__owner = v17;
    v10 = sub_805211F(v16, v17, v14, a4 >> 1, a5, 1);
    v16[1].__kind = v10;
    v17 = sub_805211F(v16, v10, v15, a4 - (a4 >> 1), a5, 0);
  }
  return v17;
}
// 8061A4C: using guessed type int __fastcall sub_8061A4C(_DWORD, _DWORD);
// 806B270: using guessed type int dword_806B270;

//----- (080522DC) --------------------------------------------------------
_BOOL4 __cdecl sub_80522DC(_DWORD *a1, _DWORD *a2)
{
  int v2; // ecx
  int v3; // edx
  int v4; // eax

  if ( a1[10] == a2[10] )
  {
    v2 = a1[5] + a1[6];
    v3 = a2[5];
    v4 = v3 + a2[6];
    dword_806B284 = (int)&locret_805234E;
    sub_80619DA(v2, v3);
  }
  return a1[10] < a2[10];
}
// 80619DA: using guessed type double __fastcall sub_80619DA(_DWORD, _DWORD);
// 806B284: using guessed type int dword_806B284;

//----- (08052350) --------------------------------------------------------
int __cdecl sub_8052350(pthread_mutex_t *a1)
{
  return pthread_mutex_lock(a1 + 2);
}

//----- (08052366) --------------------------------------------------------
int __cdecl sub_8052366(pthread_mutex_t *a1)
{
  return pthread_mutex_unlock(a1 + 2);
}

//----- (080523C1) --------------------------------------------------------
int __cdecl sub_80523C1(int a1, int a2)
{
  *(_DWORD *)a1 = sub_8058E89((int (*)())sub_80522DC, 2 * a2);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 4), 0);
  return pthread_cond_init((pthread_cond_t *)(a1 + 28), 0);
}

//----- (0805240F) --------------------------------------------------------
int __cdecl sub_805240F(int a1, int a2)
{
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 4));
  sub_8058F28(*(_DWORD *)a1, a2);
  *(_BYTE *)(a2 + 44) = 1;
  pthread_cond_signal((pthread_cond_t *)(a1 + 28));
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 4));
}

//----- (0805245C) --------------------------------------------------------
pthread_mutex_t *__cdecl sub_805245C(int a1)
{
  pthread_mutex_t *v2; // [esp+1Ch] [ebp-Ch]

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 4));
  while ( 1 )
  {
    v2 = (pthread_mutex_t *)sub_8058FB1(*(int **)a1);
    if ( v2 )
      break;
    pthread_cond_wait((pthread_cond_t *)(a1 + 28), (pthread_mutex_t *)(a1 + 4));
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 4));
  sub_8052350(v2);
  v2[1].__size[20] = 0;
  return v2;
}

//----- (080524C5) --------------------------------------------------------
int __usercall sub_80524C5@<eax>(int a1@<edx>, int a2@<ecx>, unsigned __int8 a3@<bl>, double a4@<st0>, int a5, FILE *stream, int a7)
{
  bool v7; // zf
  int v8; // edx
  int v9; // ecx
  void *v10; // eax

  if ( !byte_806BFE2 )
    return sub_8050C29(a2, a3, a4, a5, stream, a7);
  if ( !dword_806BBBC )
  {
    dword_806BBBC = *(_DWORD *)a5;
    dword_806BBC0 = *(_DWORD *)(a5 + 4);
    dword_806BBC4 = *(_DWORD *)(a5 + 8);
    dword_806BBC8 = *(_DWORD *)(a5 + 12);
    return sub_8050C29(a2, a3, a4, a5, stream, a7);
  }
  v7 = sub_8050AA3(a1, a2, a4, a5, (int)&dword_806BBBC) == 0;
  v10 = &loc_8052513;
  if ( !v7 )
    v10 = &loc_8052567;
  dword_806B220 = (int)v10;
  return sub_8061C20(v9, v8);
}
// 8061C20: using guessed type int __fastcall sub_8061C20(_DWORD, _DWORD);
// 806B220: using guessed type int dword_806B220;
// 806BBBC: using guessed type int dword_806BBBC;
// 806BBC0: using guessed type int dword_806BBC0;
// 806BBC4: using guessed type int dword_806BBC4;
// 806BBC8: using guessed type int dword_806BBC8;
// 806BFE2: using guessed type char byte_806BFE2;

//----- (0805258E) --------------------------------------------------------
int __usercall sub_805258E@<eax>(double a1@<st0>, unsigned __int8 bl0@<bl>, int a2, int a3, FILE *stream, int a5)
{
  int v6; // ecx
  _DWORD *v7; // edx
  _DWORD *v8; // eax
  int v9; // edx
  void *v10; // eax
  int v11; // ecx
  int v12; // eax
  void *v13; // eax
  int v14; // ecx
  unsigned int v15; // eax
  int v16; // edx
  bool v17; // zf
  void *v18; // eax
  int v19; // edx
  int v20; // ecx
  _DWORD *v21; // edx
  _DWORD *v22; // eax
  int v23; // eax
  int v24; // eax
  int v25; // ecx
  int v26; // eax
  int v27; // edx
  int v28; // ecx
  bool v29; // sf
  void *v30; // eax
  int v31; // ecx
  int v32; // ecx
  int v33; // edx
  void *v34; // eax
  int v35; // ecx
  int v36; // eax
  void *v37; // eax
  int v38; // eax
  int v39; // eax
  void *v40; // eax
  int result; // eax
  int v42; // [esp+4h] [ebp-34h]
  unsigned int v43; // [esp+18h] [ebp-20h]
  _DWORD *v44; // [esp+1Ch] [ebp-1Ch]
  int v45; // [esp+20h] [ebp-18h]
  int v46; // [esp+24h] [ebp-14h]
  int v47; // [esp+28h] [ebp-10h]
  int v48; // [esp+2Ch] [ebp-Ch]

  v45 = *(_DWORD *)a2;
  v46 = *(_DWORD *)(a2 + 4);
  v6 = 2 * (*(_DWORD *)(a2 + 40) + 1);
  v43 = ((unsigned int)a3 >> v6) + 1;
  if ( *(_DWORD *)(a2 + 40) <= 1u )
  {
    dword_806B2F4 = (int)&loc_8052887;
    sub_80616BF();
    v24 = *(_DWORD *)a2 - 16;
    v42 = *(_DWORD *)(a2 + 4) - 16;
    v26 = sub_8050AA3(v42, v25, a1, v24, v42);
    v17 = v26 == 0;
    v29 = v26 < 0;
    v30 = &loc_8052832;
    if ( !v29 && !v17 )
      v30 = &loc_805285C;
    dword_806B31C = (int)v30;
    sub_8061576(v28, v27);
    *(_DWORD *)a2 -= 16;
    sub_80524C5((int)stream, v31, bl0, a1, *(_DWORD *)a2, stream, a5);
    v33 = *(_DWORD *)a2;
    v34 = &loc_80528AF;
    if ( *(_DWORD *)a2 == *(_DWORD *)(a2 + 8) )
      v34 = &loc_8052905;
    dword_806B25C = (int)v34;
    sub_8061AC4(v32, v33);
    if ( *(_DWORD *)(a2 + 4) != *(_DWORD *)(a2 + 12) )
    {
      v36 = v43--;
      v17 = v36 == 0;
      v37 = &loc_8052905;
      if ( !v17 )
        v37 = &loc_80527F8;
      dword_806B2B8 = (int)v37;
      sub_8061881();
    }
    v47 = (v45 - *(_DWORD *)a2) >> 4;
    v48 = (v46 - *(_DWORD *)(a2 + 4)) >> 4;
    if ( *(_DWORD *)(a2 + 24) == v48 )
    {
      while ( *(_DWORD *)a2 != *(_DWORD *)(a2 + 8) )
      {
        v38 = v43--;
        if ( !v38 )
          break;
        *(_DWORD *)a2 -= 16;
        sub_80524C5((int)stream, v35, bl0, a1, *(_DWORD *)a2, stream, a5);
      }
    }
    else if ( *(_DWORD *)(a2 + 20) == v47 && *(_DWORD *)(a2 + 4) != *(_DWORD *)(a2 + 12) )
    {
      v39 = v43--;
      v17 = v39 == 0;
      v40 = &loc_80529EB;
      if ( !v17 )
        v40 = &loc_805298A;
      dword_806B2B8 = (int)v40;
      sub_8061881();
    }
  }
  else
  {
    v44 = **(_DWORD ***)(a2 + 16);
    while ( 1 )
    {
      v9 = *(_DWORD *)a2;
      v10 = &loc_805268A;
      if ( *(_DWORD *)a2 == *(_DWORD *)(a2 + 8) )
        v10 = &loc_80526AB;
      dword_806B31C = (int)v10;
      sub_8061576(v6, v9);
      if ( *(_DWORD *)(a2 + 4) == *(_DWORD *)(a2 + 12) )
        break;
      v12 = v43--;
      if ( !v12 )
        break;
      if ( sub_8050AA3(*(_DWORD *)(a2 + 4) - 16, v11, a1, *(_DWORD *)a2 - 16, *(_DWORD *)(a2 + 4) - 16) > 0 )
      {
        v44 -= 4;
        *(_DWORD *)(a2 + 4) -= 16;
        v7 = *(_DWORD **)(a2 + 4);
        v8 = v44;
        *v44 = *v7;
      }
      else
      {
        v44 -= 4;
        *(_DWORD *)a2 -= 16;
        v7 = *(_DWORD **)a2;
        v8 = v44;
        *v44 = **(_DWORD **)a2;
      }
      v8[1] = v7[1];
      v6 = v7[2];
      v8[2] = v6;
      v8[3] = v7[3];
    }
    v47 = (v45 - *(_DWORD *)a2) >> 4;
    v48 = (v46 - *(_DWORD *)(a2 + 4)) >> 4;
    v13 = &loc_80526F4;
    if ( *(_DWORD *)(a2 + 24) != v48 )
      v13 = &loc_8052775;
    dword_806B234 = (int)v13;
    sub_8061BAC();
    if ( *(_DWORD *)a2 != *(_DWORD *)(a2 + 8) )
    {
      v15 = v43;
      v16 = v43-- - 1;
      v17 = v15 == 0;
      v18 = &loc_805275E;
      if ( !v17 )
        v18 = &loc_80526F6;
      dword_806B2E0 = (int)v18;
      sub_806174E(v14, v16);
      dword_806B284 = (int)&loc_80527D1;
      sub_80619DA(v20, v19);
      if ( *(_DWORD *)(a2 + 20) == v47 )
      {
        while ( *(_DWORD *)(a2 + 4) != *(_DWORD *)(a2 + 12) )
        {
          v23 = v43--;
          if ( !v23 )
            break;
          v44 -= 4;
          *(_DWORD *)(a2 + 4) -= 16;
          v21 = *(_DWORD **)(a2 + 4);
          v22 = v44;
          *v44 = *v21;
          v22[1] = v21[1];
          v22[2] = v21[2];
          v22[3] = v21[3];
        }
      }
    }
    **(_DWORD **)(a2 + 16) = v44;
  }
  v47 = (v45 - *(_DWORD *)a2) >> 4;
  v48 = (v46 - *(_DWORD *)(a2 + 4)) >> 4;
  *(_DWORD *)(a2 + 20) -= v47;
  result = a2;
  *(_DWORD *)(a2 + 24) -= v48;
  return result;
}
// 805258E: could not find valid save-restore pair for ebx
// 8061576: using guessed type int __fastcall sub_8061576(_DWORD, _DWORD);
// 806174E: using guessed type int __fastcall sub_806174E(_DWORD, _DWORD);
// 8061881: using guessed type int sub_8061881(void);
// 80619DA: using guessed type double __fastcall sub_80619DA(_DWORD, _DWORD);
// 8061AC4: using guessed type int __fastcall sub_8061AC4(_DWORD, _DWORD);
// 8061BAC: using guessed type int sub_8061BAC(void);
// 806B234: using guessed type int dword_806B234;
// 806B25C: using guessed type int dword_806B25C;
// 806B284: using guessed type int dword_806B284;
// 806B2B8: using guessed type int dword_806B2B8;
// 806B2E0: using guessed type int dword_806B2E0;
// 806B2F4: using guessed type int dword_806B2F4;
// 806B31C: using guessed type int dword_806B31C;

//----- (08052A34) --------------------------------------------------------
void __cdecl sub_8052A34(int a1, int a2)
{
  void *v2; // eax
  int v3; // ecx
  int v4; // edx
  void *v5; // eax
  bool v6; // [esp+1Fh] [ebp-9h]

  v2 = &loc_8052A61;
  if ( *(_BYTE *)(a2 + 44) == 1 )
    v2 = &locret_8052B68;
  dword_806B2B8 = (int)v2;
  sub_8061881();
  v4 = *(_DWORD *)(a2 + 4) - *(_DWORD *)(a2 + 12);
  v6 = (unsigned int)(v4 + 15) > 0x1E;
  if ( (unsigned int)(*(_DWORD *)a2 - *(_DWORD *)(a2 + 8) + 15) > 0x1E )
  {
    if ( !v6 )
    {
      v5 = &loc_8052ACB;
      if ( *(_DWORD *)(a2 + 24) )
        v5 = &loc_8052AD2;
      dword_806B25C = (int)v5;
      sub_8061AC4(v3, v4);
    }
    dword_806B220 = (int)&loc_8052B21;
    sub_8061C20(v3, v4);
  }
  if ( v6 && !*(_DWORD *)(a2 + 20) )
  {
    dword_806B270 = (int)&loc_8052B0A;
    sub_8061A4C(v3, v4);
  }
  dword_806B284 = (int)&loc_8052B1E;
  sub_80619DA(v3, v4);
}
// 8052A34: could not find valid save-restore pair for ebx
// 8061881: using guessed type int sub_8061881(void);
// 80619DA: using guessed type double __fastcall sub_80619DA(_DWORD, _DWORD);
// 8061A4C: using guessed type int __fastcall sub_8061A4C(_DWORD, _DWORD);
// 8061AC4: using guessed type int __fastcall sub_8061AC4(_DWORD, _DWORD);
// 8061C20: using guessed type int __fastcall sub_8061C20(_DWORD, _DWORD);
// 806B220: using guessed type int dword_806B220;
// 806B25C: using guessed type int dword_806B25C;
// 806B270: using guessed type int dword_806B270;
// 806B284: using guessed type int dword_806B284;
// 806B2B8: using guessed type int dword_806B2B8;

//----- (08052B6A) --------------------------------------------------------
int __cdecl sub_8052B6A(int a1, _DWORD *a2)
{
  int result; // eax
  void *v3; // eax

  if ( a2[10] <= 1u )
  {
    v3 = &loc_8052BF0;
    if ( a2[5] + a2[6] )
      v3 = &locret_8052C0A;
    dword_806B248 = (int)v3;
    sub_8061B34();
    result = sub_805240F(a1, a2[7]);
  }
  else
  {
    sub_8052350((pthread_mutex_t *)a2[7]);
    sub_8052A34(a1, a2[7]);
    result = sub_8052366((pthread_mutex_t *)a2[7]);
  }
  return result;
}
// 8061B34: using guessed type int sub_8061B34(void);
// 806B248: using guessed type int dword_806B248;

//----- (08052C0C) --------------------------------------------------------
int __usercall sub_8052C0C@<eax>(unsigned __int8 a1@<bl>, double a2@<st0>, int a3, int a4, FILE *stream, int a6)
{
  pthread_mutex_t *v6; // eax
  pthread_mutex_t *v8; // [esp+20h] [ebp-Ch]

  while ( 1 )
  {
    v6 = sub_805245C(a3);
    v8 = v6;
    if ( !v6[1].__nusers )
      break;
    sub_805258E(a2, a1, (int)v6, a4, stream, a6);
    sub_8052A34(a3, (int)v8);
    sub_8052B6A(a3, v8);
    sub_8052366(v8);
  }
  sub_8052366(v6);
  return sub_805240F(a3, (int)v8);
}

//----- (08052D90) --------------------------------------------------------
int __usercall sub_8052D90@<eax>(int a1@<ecx>, unsigned __int8 a2@<bl>, double a3@<st0>, int a4, int a5, int a6, int a7, int a8, FILE *stream, int a10)
{
  int result; // eax
  int v11; // eax
  pthread_t th; // [esp+28h] [ebp-40h]
  unsigned int v13; // [esp+2Ch] [ebp-3Ch]
  unsigned int v14; // [esp+30h] [ebp-38h]
  int v15; // [esp+34h] [ebp-34h]
  unsigned int v16; // [esp+38h] [ebp-30h]
  unsigned int v17; // [esp+3Ch] [ebp-2Ch]
  _DWORD *v18; // [esp+40h] [ebp-28h]
  int arg; // [esp+44h] [ebp-24h]
  unsigned int v20; // [esp+48h] [ebp-20h]
  int v21; // [esp+4Ch] [ebp-1Ch]
  int v22; // [esp+50h] [ebp-18h]
  int v23; // [esp+54h] [ebp-14h]
  FILE *v24; // [esp+58h] [ebp-10h]
  int v25; // [esp+5Ch] [ebp-Ch]

  v13 = *(_DWORD *)(a7 + 20) + *(_DWORD *)(a7 + 24);
  v14 = (unsigned int)a5 >> 1;
  v15 = a5 - ((unsigned int)a5 >> 1);
  arg = a4;
  v20 = (unsigned int)a5 >> 1;
  v21 = a6;
  v22 = *(_DWORD *)(a7 + 32);
  v23 = a8;
  v24 = stream;
  v25 = a10;
  if ( (unsigned int)a5 <= 1 || v13 <= 0x1FFFF || (v11 = pthread_create(&th, 0, start_routine, &arg)) != 0 )
  {
    v16 = *(_DWORD *)(a7 + 20);
    v17 = *(_DWORD *)(a7 + 24);
    v18 = (_DWORD *)(-16 * a6 + a4);
    if ( v17 > 1 )
      sub_8051DC6(-16 * v16, a3, (_DWORD *)(-16 * v16 + a4), v17, &v18[-4 * (v16 >> 1)], 0);
    if ( v16 > 1 )
      sub_8051DC6(a1, a3, (_DWORD *)a4, v16, v18, 0);
    *(_DWORD *)a7 = a4;
    *(_DWORD *)(a7 + 4) = a4 - 16 * v16;
    *(_DWORD *)(a7 + 8) = a4 - 16 * v16;
    *(_DWORD *)(a7 + 12) = a4 + -16 * v16 - 16 * v17;
    sub_805240F(a8, a7);
    result = sub_8052C0C(a2, a3, a8, a6, stream, a10);
  }
  else
  {
    sub_8052D90(a4 - 16 * *(_DWORD *)(a7 + 20), v15, a6, *(_DWORD *)(a7 + 36), a8, stream, a10);
    result = pthread_join(th, 0);
  }
  return result;
}

//----- (08052FC4) --------------------------------------------------------
int __usercall sub_8052FC4@<eax>(double a1@<st0>, int a2, int a3, int a4, char *s1)
{
  bool v5; // zf
  int v6; // edx
  int v7; // ecx
  void *v8; // eax
  void *v9; // eax
  int result; // eax
  int v11; // edx
  int v12; // ecx
  void *v13; // eax
  char v14; // al
  const char *v15; // [esp+4h] [ebp-F4h]
  char v16; // [esp+21h] [ebp-D7h]
  char v17; // [esp+22h] [ebp-D6h]
  bool v18; // [esp+23h] [ebp-D5h]
  FILE *stream; // [esp+24h] [ebp-D4h]
  int *v20; // [esp+28h] [ebp-D0h]
  unsigned int i; // [esp+2Ch] [ebp-CCh]
  __int64 v22; // [esp+30h] [ebp-C8h]
  __int64 v23; // [esp+88h] [ebp-70h]
  __int64 v24; // [esp+90h] [ebp-68h]
  __int64 v25; // [esp+E8h] [ebp-10h]

  v16 = 0;
  v20 = 0;
  for ( i = a3; ; ++i )
  {
    result = i;
    if ( i >= a4 )
      break;
    v18 = strcmp(*(const char **)(8 * i + a2), "-") == 0;
    v9 = &loc_80530B5;
    if ( !s1 )
      v9 = &loc_8053014;
    dword_806B248 = (int)v9;
    sub_8061B34();
    v15 = *(const char **)(8 * i + a2);
    v5 = strcmp(s1, v15) == 0;
    v8 = &loc_805306F;
    if ( !v5 )
      v8 = &loc_8053014;
    dword_806B270 = (int)v8;
    sub_8061A4C(v7, v6);
    if ( v18 != 1 )
    {
      v17 = 1;
      goto LABEL_24;
    }
    if ( v16 != 1 )
    {
      result = sub_80614E1(1, (int)&v22);
      if ( result )
        return result;
      v16 = 1;
    }
    if ( !v18 )
      goto LABEL_17;
    if ( sub_80614E1(0, (int)&v24) )
    {
      dword_806B2E0 = (int)&loc_8053193;
      sub_806174E(v12, v11);
LABEL_17:
      if ( sub_806148D(*(_DWORD *)(8 * i + a2), (int)&v24) )
        goto LABEL_22;
    }
    if ( v25 == v23 )
    {
      v13 = &loc_805318C;
      if ( v24 != v22 )
        v13 = &loc_8053193;
      dword_806B25C = (int)v13;
      sub_8061AC4(v24, HIDWORD(v22));
      v14 = 1;
      goto LABEL_23;
    }
LABEL_22:
    v14 = 0;
LABEL_23:
    v17 = v14 & 1;
LABEL_24:
    if ( v17 )
    {
      if ( !v20 )
      {
        v20 = sub_804C6EC(&stream);
        sub_8051C2A(8 * i, a1, 8 * i + a2, 0, 1, stream, (int)v20 + 9);
      }
      *(_DWORD *)(8 * i + a2) = (char *)v20 + 9;
      *(_DWORD *)(a2 + 8 * i + 4) = v20;
    }
  }
  return result;
}
// 806174E: using guessed type int __fastcall sub_806174E(_DWORD, _DWORD);
// 8061A4C: using guessed type int __fastcall sub_8061A4C(_DWORD, _DWORD);
// 8061AC4: using guessed type int __fastcall sub_8061AC4(_DWORD, _DWORD);
// 8061B34: using guessed type int sub_8061B34(void);
// 806B248: using guessed type int dword_806B248;
// 806B25C: using guessed type int dword_806B25C;
// 806B270: using guessed type int dword_806B270;
// 806B2E0: using guessed type int dword_806B2E0;

//----- (08053268) --------------------------------------------------------
unsigned int __cdecl sub_8053268(int a2, unsigned int a3)
{
  bool v2; // zf
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  char *v6; // ebx
  char *v7; // eax
  unsigned int result; // eax
  unsigned int v9; // [esp+1Ch] [ebp-Ch]

  v9 = 0;
  result = v9;
  if ( v9 < a3 )
  {
    if ( !strcmp(*(const char **)(4 * v9 + a2), "-") )
    {
      dword_806B308 = (int)&loc_805331E;
      sub_806160F();
    }
    v2 = euidaccess(*(_DWORD *)(4 * v9 + a2), 4) == 0;
    v5 = &loc_80532F5;
    if ( v2 )
      v5 = &loc_805331E;
    dword_806B298 = (int)v5;
    sub_8061955(v4, v3);
    v6 = *(char **)(4 * v9 + a2);
    v7 = gettext("cannot read");
    sub_804B777((int)v7, v6);
  }
  return result;
}
// 8049E00: using guessed type int __cdecl euidaccess(_DWORD, _DWORD);
// 806160F: using guessed type int sub_806160F(void);
// 806B298: using guessed type int dword_806B298;
// 806B308: using guessed type int dword_806B308;

//----- (0805333C) --------------------------------------------------------
void __cdecl sub_805333C(char *a2)
{
  int v2; // eax
  char *v3; // eax

  if ( a2 )
  {
    v2 = open64(a2, 524353);
    if ( v2 < 0 )
    {
      v3 = gettext("open failed");
      sub_804B777((int)v3, a2);
    }
    sub_804C3A3(v2, 1);
  }
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);

//----- (080533AE) --------------------------------------------------------
void __usercall sub_80533AE(double a1@<st0>, int a2, int a3, int a4, char *s1)
{
  int *v5; // eax
  int v6; // esi
  int v7; // eax
  int v8; // eax
  int *v9; // eax
  int v10; // ebx
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // ebx
  int v15; // eax
  int v16; // edx
  int v17; // ecx
  bool v18; // zf
  void *v19; // eax
  void *v20; // eax
  char *v21; // eax
  int v22; // eax
  int v23; // eax
  int v24; // [esp+0h] [ebp-78h]
  _BOOL4 v25; // [esp+4h] [ebp-74h]
  void *v26; // [esp+28h] [ebp-50h]
  FILE *v27; // [esp+2Ch] [ebp-4Ch]
  int v28; // [esp+30h] [ebp-48h]
  unsigned int v29; // [esp+34h] [ebp-44h]
  int v30; // [esp+38h] [ebp-40h]
  int *v31; // [esp+3Ch] [ebp-3Ch]
  unsigned int v32; // [esp+40h] [ebp-38h]
  int v33; // [esp+44h] [ebp-34h]
  unsigned int v34; // [esp+48h] [ebp-30h]
  int v35; // [esp+4Ch] [ebp-2Ch]
  int *v36; // [esp+50h] [ebp-28h]
  unsigned int v37; // [esp+54h] [ebp-24h]
  FILE *stream; // [esp+58h] [ebp-20h]
  int *v39; // [esp+5Ch] [ebp-1Ch]
  int v40; // [esp+84h] [ebp+Ch]

  dword_806B308 = (int)&loc_80535BA;
  sub_806160F();
  do
  {
    v28 = 0;
    v29 = 0;
    while ( a4 - v28 >= (unsigned int)dword_806B3D8 )
    {
      v5 = sub_804C6EC(&v27);
      v31 = v5;
      v6 = (int)v5 + 9;
      v7 = a3;
      if ( dword_806B3D8 <= (unsigned int)a3 )
        v7 = dword_806B3D8;
      v24 = 8 * v28 + a2;
      v32 = sub_8051C2A((int)v27, a1, v24, v7, dword_806B3D8, v27, v6);
      v8 = a3;
      if ( v32 <= a3 )
        v8 = v32;
      a3 -= v8;
      *(_DWORD *)(8 * v29 + a2) = (char *)v31 + 9;
      *(_DWORD *)(a2 + 8 * v29 + 4) = v31;
      v28 += v32;
      ++v29;
    }
    v33 = a4 - v28;
    v34 = dword_806B3D8 - v29 % dword_806B3D8;
    if ( dword_806B3D8 - v29 % dword_806B3D8 < a4 - v28 )
    {
      v35 = v33 - v34 + 1;
      v9 = sub_804C6EC(&v27);
      v36 = v9;
      v10 = (int)v9 + 9;
      v11 = a3;
      if ( v35 <= (unsigned int)a3 )
        v11 = v35;
      v24 = 8 * v28 + a2;
      v37 = sub_8051C2A(v10, a1, v24, v11, v35, v27, v10);
      v12 = a3;
      if ( v37 <= a3 )
        v12 = v37;
      a3 -= v12;
      *(_DWORD *)(8 * v29 + a2) = (char *)v36 + 9;
      v13 = v29++;
      *(_DWORD *)(a2 + 8 * v13 + 4) = v36;
      v28 += v37;
    }
    v14 = 8 * v29;
    memmove((void *)(8 * v29 + a2), (const void *)(a2 + 8 * v28), 8 * (a4 - v28));
    a3 += v29;
    a4 += v29 - v28;
  }
  while ( dword_806B3D8 < (unsigned int)a4 );
  sub_8052FC4(a1, a2, a3, a4, s1);
  while ( 1 )
  {
    v15 = sub_8051154(a1, a2, a4, &v26);
    v30 = v15;
    v18 = v15 == a4;
    v19 = &loc_8053625;
    if ( !v18 )
      v19 = &loc_80536BC;
    dword_806B298 = (int)v19;
    sub_8061955(v17, v16);
    stream = sub_804C128(s1, "w");
    if ( stream )
      break;
    v18 = *__errno_location() == 24;
    v20 = &loc_8053699;
    if ( !v18 )
      v20 = &loc_805369F;
    dword_806B234 = (int)v20;
    sub_8061BAC();
    if ( (unsigned int)v30 <= 2 )
    {
      v21 = gettext("open failed");
      sub_804B777((int)v21, s1);
    }
    do
    {
      --v30;
      sub_804C2DF(a1, *((FILE **)v26 + v30), *(_DWORD *)(8 * v30 + a2));
      v25 = (unsigned int)v30 > 2;
      v39 = sub_804C5A0(&v27, v25);
    }
    while ( !v39 );
    v14 = (int)v39 + 9;
    v22 = a3;
    if ( v30 <= (unsigned int)a3 )
      v22 = v30;
    sub_8051251(v14, a1, a2, v22, v30, v27, (int)v39 + 9, v26);
    v23 = a3;
    if ( v30 <= (unsigned int)a3 )
      v23 = v30;
    v40 = a3 - v23;
    *(_DWORD *)a2 = (char *)v39 + 9;
    *(_DWORD *)(a2 + 4) = v39;
    memmove((void *)(a2 + 8), (const void *)(a2 + 8 * v30), 8 * (a4 - v30));
    a3 = v40 + 1;
    a4 = a4 - v30 + 1;
  }
  sub_8051251(v14, a1, a2, a3, a4, stream, (int)s1, v26);
}
// 806160F: using guessed type int sub_806160F(void);
// 8061BAC: using guessed type int sub_8061BAC(void);
// 806B234: using guessed type int dword_806B234;
// 806B298: using guessed type int dword_806B298;
// 806B308: using guessed type int dword_806B308;
// 806B3D4: using guessed type int dword_806B3D4;

//----- (080537EB) --------------------------------------------------------
int __usercall __noreturn sub_80537EB@<eax>(double a1@<st0>, char **a2, int a3, char *a4, int a5)
{
  int (*v5)(); // eax
  int v7; // edx
  int v8; // ecx
  _DWORD *v9; // [esp+5Ch] [ebp-8Ch]
  int v10; // [esp+60h] [ebp-88h]
  _DWORD *v11; // [esp+70h] [ebp-78h]
  void *ptr; // [esp+74h] [ebp-74h]
  unsigned int v13; // [esp+DCh] [ebp-Ch]

  v13 = __readgsdword(0x14u);
  if ( a3 )
    sub_804C285(*a2, "r");
  free(ptr);
  v9 = (_DWORD *)dword_806C070;
  v11 = sub_805E2D3(0, 8u);
  v10 = 0;
  while ( v9 )
  {
    v11[2 * v10] = (char *)v9 + 9;
    v11[2 * v10 + 1] = v9;
    v9 = (_DWORD *)*v9;
    ++v10;
  }
  sub_80533AE(a1, (int)v11, 0, 0, a4);
  free(v11);
  sub_804BE85(a1);
  v5 = (int (*)())&loc_8053AEB;
  if ( __readgsdword(0x14u) == v13 )
    v5 = sub_8053C4C;
  dword_806B220 = (int)v5;
  return sub_8061C20(v8, v7);
}
// 8053C4C: using guessed type int sub_8053C4C();
// 8061C20: using guessed type int __fastcall sub_8061C20(_DWORD, _DWORD);
// 806B220: using guessed type int dword_806B220;
// 806C070: using guessed type int dword_806C070;

//----- (08053C4C) --------------------------------------------------------
#error "8053C52: positive sp value has been found (funcsize=0)"

//----- (08053C55) --------------------------------------------------------
_DWORD *__cdecl sub_8053C55(void *src)
{
  _DWORD *result; // eax
  int *i; // [esp+18h] [ebp-10h]
  _DWORD *v3; // [esp+1Ch] [ebp-Ch]

  v3 = sub_805E550(src, 0x28u);
  for ( i = &dword_806BFE4; *i; i = (int *)(*i + 36) )
    ;
  *i = (int)v3;
  result = v3;
  v3[9] = 0;
  return result;
}
// 806BFE4: using guessed type int dword_806BFE4;

//----- (08053CA2) --------------------------------------------------------
unsigned int __cdecl sub_8053CA2(int a1, char *msgid)
{
  void *v2; // esi
  char *v4; // ebx
  char *v5; // eax

  v2 = sub_805BCF1((char *)a1);
  v4 = gettext(msgid);
  v5 = gettext("%s: invalid field specification %s");
  error(2, 0, v5, v4, v2);
  return sub_8053D15(a1);
}

//----- (08053D15) --------------------------------------------------------
unsigned int __cdecl sub_8053D15(int a1)
{
  char *v1; // eax

  v1 = gettext("options '-%s' are incompatible");
  error(2, 0, v1, a1);
  return sub_8053D46();
}

//----- (08053D46) --------------------------------------------------------
unsigned int sub_8053D46()
{
  int v0; // ecx
  int v1; // edx
  int v2; // eax
  bool v3; // zf
  bool v4; // sf
  unsigned __int8 v5; // of
  void *v6; // eax
  int v7; // edx
  int v8; // ecx
  int i; // [esp+18h] [ebp-30h]
  char v11; // [esp+1Dh] [ebp-2Bh]
  unsigned int v12; // [esp+3Ch] [ebp-Ch]

  v12 = __readgsdword(0x14u);
  for ( i = dword_806BFE4; i; i = *(_DWORD *)(i + 36) )
  {
    v0 = *(unsigned __int8 *)(i + 29)
       + *(unsigned __int8 *)(i + 28)
       + *(unsigned __int8 *)(i + 26)
       + *(unsigned __int8 *)(i + 30);
    v1 = *(unsigned __int8 *)(i + 27) | *(unsigned __int8 *)(i + 32);
    v2 = v0 + (v1 | (*(_DWORD *)(i + 16) != 0));
    v5 = __OFSUB__(v2, 1);
    v3 = v2 == 1;
    v4 = v2 - 1 < 0;
    v6 = &loc_8053DD9;
    if ( (unsigned __int8)(v4 ^ v5) | v3 )
      v6 = &loc_8053E17;
    dword_806B298 = (int)v6;
    sub_8061955(v0, v1);
    *(_BYTE *)(i + 31) = 0;
    *(_BYTE *)(i + 25) = *(_BYTE *)(i + 31);
    v7 = *(unsigned __int8 *)(i + 25);
    *(_BYTE *)(i + 24) = v7;
    sub_804F3C1(v7, v8, i, &v11);
    sub_8053D15((int)&v11);
  }
  return __readgsdword(0x14u) ^ v12;
}
// 806B298: using guessed type int dword_806B298;
// 806BFE4: using guessed type int dword_806BFE4;

//----- (08053E3D) --------------------------------------------------------
int __cdecl sub_8053E3D(char *nptr, int a2, char *msgid)
{
  void *v3; // esi
  char *v4; // ebx
  char *v5; // eax
  int result; // eax
  int v7; // [esp+24h] [ebp-14h]
  __int64 v8; // [esp+28h] [ebp-10h]

  switch ( sub_805EF49(nptr, (int)&v7, 10) )
  {
    case 0:
    case 2:
      *(_DWORD *)a2 = v8;
      if ( v8 == *(_DWORD *)a2 )
        goto LABEL_7;
      goto LABEL_3;
    case 1:
    case 3:
LABEL_3:
      *(_DWORD *)a2 = -1;
      goto LABEL_7;
    case 4:
      if ( msgid )
      {
        v3 = sub_805BCF1(nptr);
        v4 = gettext(msgid);
        v5 = gettext("%s: invalid count at start of %s");
        error(2, 0, v5, v4, v3);
      }
      result = 0;
      break;
    default:
LABEL_7:
      result = v7;
      break;
  }
  return result;
}

//----- (08053F15) --------------------------------------------------------
int __cdecl sub_8053F15(int sig)
{
  sub_804BEC9();
  signal(sig, 0);
  return raise(sig);
}

//----- (08053F40) --------------------------------------------------------
_BYTE *__usercall sub_8053F40@<eax>(int a1@<edx>, int a2@<ecx>, double a3@<st0>, _BYTE *a4, int a5, int a6)
{
  void *v6; // eax
  int v7; // edx
  int v8; // ecx
  _BYTE *result; // eax

  while ( 2 )
  {
    if ( !*a4 )
      return a4;
    switch ( *a4 )
    {
      case 77:
        goto LABEL_18;
      case 82:
        *(_BYTE *)(a5 + 27) = 1;
        goto LABEL_25;
      case 86:
        *(_BYTE *)(a5 + 32) = 1;
        goto LABEL_25;
      case 98:
        if ( a6 )
        {
          v6 = &loc_8053F8B;
          if ( a6 != 2 )
            v6 = &loc_8053F92;
          dword_806B20C = (int)v6;
          sub_8061C98(a3);
        }
        *(_BYTE *)(a5 + 24) = 1;
        if ( a6 != 1 && a6 != 2 )
        {
          dword_806B31C = (int)&loc_80540B5;
          sub_8061576(a2, a1);
LABEL_11:
          *(_DWORD *)(a5 + 16) = &unk_806BDD0;
        }
        else
        {
          *(_BYTE *)(a5 + 25) = 1;
        }
        goto LABEL_25;
      case 100:
        goto LABEL_11;
      case 102:
        *(_DWORD *)(a5 + 20) = byte_806BED0;
        goto LABEL_25;
      case 103:
        *(_BYTE *)(a5 + 28) = 1;
        goto LABEL_25;
      case 104:
        *(_BYTE *)(a5 + 29) = 1;
        dword_806B2CC = (int)&loc_80540B5;
        sub_80617DA();
        goto LABEL_15;
      case 105:
LABEL_15:
        if ( *(_DWORD *)(a5 + 16) )
        {
          dword_806B248 = (int)&loc_80540B5;
          sub_8061B34();
LABEL_18:
          *(_BYTE *)(a5 + 30) = 1;
        }
        else
        {
          *(_DWORD *)(a5 + 16) = &unk_806BCD0;
        }
        goto LABEL_25;
      case 110:
        *(_BYTE *)(a5 + 26) = 1;
        dword_806B2B8 = (int)&loc_80540B5;
        sub_8061881();
        dword_806B220 = (int)&loc_8053FC2;
        sub_8061C20(v8, v7);
        goto LABEL_11;
      case 114:
        *(_BYTE *)(a5 + 31) = 1;
LABEL_25:
        ++a4;
        continue;
      default:
        result = a4;
        break;
    }
    return result;
  }
}
// 8061576: using guessed type int __fastcall sub_8061576(_DWORD, _DWORD);
// 80617DA: using guessed type int sub_80617DA(void);
// 8061881: using guessed type int sub_8061881(void);
// 8061B34: using guessed type int sub_8061B34(void);
// 8061C20: using guessed type int __fastcall sub_8061C20(_DWORD, _DWORD);
// 8061C98: using guessed type int __usercall sub_8061C98@<eax>(double@<st0>);
// 806B20C: using guessed type int dword_806B20C;
// 806B220: using guessed type int dword_806B220;
// 806B248: using guessed type int dword_806B248;
// 806B2B8: using guessed type int dword_806B2B8;
// 806B2CC: using guessed type int dword_806B2CC;
// 806B31C: using guessed type int dword_806B31C;

//----- (080540CC) --------------------------------------------------------
void *__cdecl sub_80540CC(void *s)
{
  memset(s, 0, 0x28u);
  *((_DWORD *)s + 2) = -1;
  return s;
}

//----- (080540FC) --------------------------------------------------------
int __cdecl main(int argc, char **argv)
{
  int v2; // eax
  int v3; // edx
  int v4; // ecx
  bool v5; // zf
  bool v6; // sf
  unsigned __int8 v7; // of
  void *v8; // eax
  int v9; // edx
  int v10; // ecx
  unsigned __int8 **v11; // eax
  unsigned __int8 v12; // al
  int v13; // edx
  int v14; // ecx
  void *v15; // eax
  long double v16; // fst7
  int v17; // edx
  _DWORD *v18; // ecx
  void *v19; // eax
  int v20; // eax
  int v21; // eax
  void *v22; // eax
  char v23; // al
  void *v24; // eax
  _DWORD *v25; // eax
  _BYTE *v26; // eax
  void *v27; // eax
  int v28; // edx
  int v29; // ecx
  int v30; // eax
  int v31; // edx
  int v32; // ecx
  int v33; // eax
  int v34; // eax
  int v35; // edx
  int v36; // ecx
  char *v37; // eax
  unsigned __int8 v38; // al
  int v39; // eax
  int v40; // ecx
  int v41; // edx
  int v42; // eax
  int v43; // eax
  int v44; // ecx
  int v45; // edx
  char *v46; // eax
  char *v47; // eax
  int v48; // edx
  int v49; // ecx
  void *v50; // eax
  char *v51; // eax
  char *v52; // ebx
  char *v53; // eax
  void *v54; // eax
  char *v55; // eax
  int v56; // eax
  int v57; // edx
  int v58; // ecx
  void *v59; // eax
  char v60; // al
  char *v61; // eax
  char *v62; // ebx
  char *v63; // eax
  const char *v64; // eax
  int v65; // eax
  const char *v66; // esi
  char *v67; // ebx
  char *v68; // eax
  void *v69; // eax
  char *v70; // eax
  signed int v71; // eax
  int v72; // eax
  char *v73; // eax
  int result; // eax
  int v75; // [esp+4h] [ebp-178h]
  char *v76; // [esp+Ch] [ebp-170h]
  const char *v77; // [esp+10h] [ebp-16Ch]
  const char *v78; // [esp+14h] [ebp-168h]
  int v79; // [esp+18h] [ebp-164h]
  unsigned __int8 v80; // [esp+2Dh] [ebp-14Fh]
  char v81; // [esp+2Eh] [ebp-14Eh]
  char v82; // [esp+2Fh] [ebp-14Dh]
  bool v83; // [esp+30h] [ebp-14Ch]
  bool v84; // [esp+31h] [ebp-14Bh]
  bool v85; // [esp+32h] [ebp-14Ah]
  char v86; // [esp+33h] [ebp-149h]
  bool v87; // [esp+34h] [ebp-148h]
  char v88; // [esp+35h] [ebp-147h]
  char v89; // [esp+36h] [ebp-146h]
  char v90; // [esp+37h] [ebp-145h]
  _DWORD *k; // [esp+38h] [ebp-144h]
  _BYTE *v92; // [esp+3Ch] [ebp-140h]
  int v93; // [esp+40h] [ebp-13Ch]
  char *v94; // [esp+44h] [ebp-138h]
  unsigned int v95; // [esp+48h] [ebp-134h]
  unsigned int v96; // [esp+4Ch] [ebp-130h]
  _DWORD *v97; // [esp+50h] [ebp-12Ch]
  char *v98; // [esp+54h] [ebp-128h]
  char *v99; // [esp+58h] [ebp-124h]
  unsigned int i; // [esp+5Ch] [ebp-120h]
  char *j; // [esp+60h] [ebp-11Ch]
  unsigned int l; // [esp+68h] [ebp-114h]
  int v103; // [esp+6Ch] [ebp-110h]
  unsigned __int8 **v104; // [esp+70h] [ebp-10Ch]
  char *v105; // [esp+74h] [ebp-108h]
  char *v106; // [esp+80h] [ebp-FCh]
  _DWORD *v107; // [esp+84h] [ebp-F8h]
  unsigned int v108; // [esp+88h] [ebp-F4h]
  int v109; // [esp+8Ch] [ebp-F0h]
  char v110; // [esp+90h] [ebp-ECh]
  int s[4]; // [esp+B8h] [ebp-C4h]
  int v112; // [esp+C8h] [ebp-B4h]
  int v113; // [esp+CCh] [ebp-B0h]
  char v114; // [esp+D0h] [ebp-ACh]
  char v115; // [esp+D1h] [ebp-ABh]
  char v116; // [esp+D2h] [ebp-AAh]
  unsigned __int8 v117; // [esp+D3h] [ebp-A9h]
  char v118; // [esp+D4h] [ebp-A8h]
  char v119; // [esp+D5h] [ebp-A7h]
  char v120; // [esp+D6h] [ebp-A6h]
  char v121; // [esp+D7h] [ebp-A5h]
  char v122; // [esp+D8h] [ebp-A4h]
  int longind; // [esp+E0h] [ebp-9Ch]
  __sigset_t v124; // [esp+E4h] [ebp-98h]
  int v125; // [esp+164h] [ebp-18h]

  v80 = 0;
  v93 = 0;
  v81 = 0;
  v82 = 0;
  v94 = 0;
  v83 = 0;
  v95 = 0;
  v96 = 0;
  v87 = getenv("POSIXLY_CORRECT") != 0;
  v2 = sub_8059F1F();
  v103 = v2;
  v7 = __OFSUB__(v2, 200111);
  v5 = v2 == 200111;
  v6 = v2 - 200111 < 0;
  v8 = &loc_8054180;
  if ( (unsigned __int8)(v6 ^ v7) | v5 )
    v8 = &loc_805418A;
  dword_806B298 = (int)v8;
  sub_8061955(v4, v3);
  v84 = v103 > 200808;
  v98 = 0;
  v99 = 0;
  sub_8059F9E(*argv);
  v85 = setlocale(6, &locale) != 0;
  bindtextdomain("coreutils", "/home/hwangdz/coreutils/coreutils-8.28/install_m32/share/locale");
  textdomain("coreutils");
  sub_804B389(v9, v10, 2);
  byte_806BBB8 = sub_8057768(3);
  byte_806BBB9 = sub_8057768(2);
  v11 = (unsigned __int8 **)localeconv();
  v104 = v11;
  v12 = sub_804B3B5(**v11);
  dword_806BBB0 = v12;
  if ( !v12 || (*v104)[1] )
    dword_806BBB0 = 46;
  v38 = sub_804B3B5(*v104[1]);
  dword_806BBB4 = v38;
  if ( !v38 || v104[1][1] )
    dword_806BBB4 = -1;
  byte_806BFE3 = 0;
  sub_804CAF7();
  sigemptyset(&set);
  for ( i = 0; i <= 0xA; ++i )
  {
    sigaction(sig[i], 0, (struct sigaction *)&longind);
    v15 = &loc_8054336;
    if ( longind == 1 )
      v15 = &loc_8054351;
    dword_806B298 = (int)v15;
    sub_8061955(v14, v13);
    sigaddset(&set, sig[i]);
  }
  longind = (int)sub_8053F15;
  qmemcpy(&v124, &set, sizeof(v124));
  v125 = 0;
  i = 0;
  dword_806B284 = (int)&loc_80543F5;
  v16 = sub_80619DA(0, &v124);
  do
  {
    v75 = sig[i];
    if ( sigismember(&set, v75) )
      sigaction(sig[i], (const struct sigaction *)&longind, 0);
    ++i;
  }
  while ( i <= 0xA );
  signal(17, 0);
  sub_8061428((int)sub_804BF01);
  sub_80540CC(s);
  s[0] = -1;
  v97 = sub_805E2D3(argc, 4u);
  while ( 1 )
  {
    while ( 1 )
    {
      longind = -1;
      if ( v93 == -1 )
        break;
      if ( v87 )
      {
        if ( v96 )
        {
          if ( v84 != 1 )
            break;
          if ( v81 )
            break;
          if ( optind == argc )
            break;
          v17 = 4 * optind;
          if ( *argv[optind] != 45 )
            break;
          v17 = 4 * optind;
          if ( argv[optind][1] != 111 )
            break;
          v17 = 4 * optind;
          if ( !argv[optind][2] && optind + 1 == argc )
            break;
        }
      }
      v93 = getopt_long(argc, argv, "-bcCdfghik:mMno:rRsS:t:T:uVy:z", &longopts, &longind);
      if ( v93 == -1 )
        break;
      switch ( v93 )
      {
        case 4294967165:
          v79 = 0;
          v78 = "Paul Eggert";
          v77 = "Mike Haertel";
          sub_805E233(
            off_806B3F0,
            (int)v18,
            stdout,
            (int)"sort",
            (int)"GNU coreutils",
            off_806B3F0,
            "Mike Haertel",
            "Paul Eggert",
            0);
          exit(0);
          return result;
        case 4294967166:
          sub_804B802(0);
          return result;
        case 1:
          k = 0;
          if ( *optarg == 43 )
          {
            if ( optind == argc )
              goto LABEL_204;
            v22 = &loc_8054618;
            if ( *argv[optind] != 45 )
              v22 = &loc_8054643;
            dword_806B2B8 = (int)v22;
            sub_8061881();
            if ( (unsigned int)(argv[optind][1] - 48) > 9 )
LABEL_204:
              v23 = 0;
            else
              v23 = 1;
            v88 = v23 & 1;
            v5 = (v23 & 1) == 0;
            v24 = &loc_8054676;
            if ( v5 )
              v24 = &loc_8054689;
            dword_806B220 = (int)v24;
            sub_8061C20(v18, v84);
            v84 = (v17 | (v87 != 1)) != 0;
            if ( v84 )
            {
              v25 = sub_80540CC(&v110);
              k = v25;
              v26 = (_BYTE *)sub_8053E3D(optarg + 1, (int)v25, 0);
              v92 = v26;
              v5 = v26 == 0;
              v27 = &loc_80546FC;
              if ( v5 )
                v27 = &loc_805472D;
              dword_806B308 = (int)v27;
              sub_806160F();
              if ( *v92 == 46 )
                v92 = (_BYTE *)sub_8053E3D(v92 + 1, (int)(k + 1), 0);
              if ( !*k && !k[1] )
                *k = -1;
              if ( !v92 || *sub_8053F40(v28, v29, *(double *)&v16, v92, (int)k, 0) )
              {
                k = 0;
                dword_806B248 = (int)&loc_80548B4;
                sub_8061B34();
              }
              if ( v88 )
              {
                v30 = optind++;
                v105 = argv[v30];
                v92 = (_BYTE *)sub_8053E3D(v105 + 1, (int)(k + 2), "invalid number after '-'");
                if ( !v92 )
                  __assert_fail("s", "src/sort.c", 0x110Du, "main");
                if ( *v92 == 46 )
                  v92 = (_BYTE *)sub_8053E3D(v92 + 1, (int)(k + 3), "invalid number after '.'");
                if ( !k[3] && k[2] )
                {
                  v31 = k[2] - 1;
                  k[2] = v31;
                }
                if ( *sub_8053F40(v31, v32, *(double *)&v16, v92, (int)k, 1) )
                  sub_8053CA2((int)v105, "stray character in field spec");
              }
              *((_BYTE *)k + 33) = 1;
              sub_8053C55(k);
            }
          }
          if ( !k )
          {
            v33 = v96++;
            v17 = (int)&v97[v33];
            *(_DWORD *)v17 = optarg;
          }
          continue;
        case 67:
        case 99:
          goto LABEL_75;
        case 77:
        case 82:
        case 86:
        case 98:
        case 100:
        case 102:
        case 103:
        case 104:
        case 105:
        case 110:
        case 114:
          goto LABEL_71;
        case 83:
          sub_804CFBD(longind, (char)v93, optarg);
          dword_806B284 = (int)&loc_8054FE4;
          v16 = sub_80619DA(v49, v48);
          goto LABEL_116;
        case 84:
          goto LABEL_127;
        case 107:
          k = sub_80540CC(&v110);
          v92 = (_BYTE *)sub_8053E3D(optarg, (int)k, "invalid number at field start");
          v39 = *k;
          v40 = *k - 1;
          v41 = (int)k;
          *k = v40;
          if ( !v39 )
            sub_8053CA2((int)optarg, "field number is zero");
          if ( *v92 == 46 )
          {
            v92 = (_BYTE *)sub_8053E3D(v92 + 1, (int)(k + 1), "invalid number after '.'");
            v42 = k[1];
            v40 = v42 - 1;
            v41 = (int)k;
            k[1] = v42 - 1;
            if ( !v42 )
              sub_8053CA2((int)optarg, "character offset is zero");
          }
          if ( !*k && !k[1] )
            *k = -1;
          v92 = sub_8053F40(v41, v40, *(double *)&v16, v92, (int)k, 0);
          if ( *v92 == 44 )
          {
            v92 = (_BYTE *)sub_8053E3D(v92 + 1, (int)(k + 2), "invalid number after ','");
            v43 = k[2];
            v44 = v43 - 1;
            v45 = (int)k;
            k[2] = v43 - 1;
            if ( !v43 )
              sub_8053CA2((int)optarg, "field number is zero");
            if ( *v92 == 46 )
              v92 = (_BYTE *)sub_8053E3D(v92 + 1, (int)(k + 3), "invalid number after '.'");
            v92 = sub_8053F40(v45, v44, *(double *)&v16, v92, (int)k, 1);
          }
          else
          {
            k[2] = -1;
            k[3] = 0;
          }
          if ( *v92 )
            sub_8053CA2((int)optarg, "stray character in field spec");
          sub_8053C55(k);
          continue;
        case 109:
          v82 = 1;
          continue;
        case 111:
          if ( v99 && strcmp(v99, optarg) )
          {
            v46 = gettext("multiple output files specified");
            error(2, 0, v46);
          }
          v99 = optarg;
          continue;
        case 115:
          byte_806BFE1 = 1;
          continue;
        case 116:
LABEL_116:
          v86 = *optarg;
          v50 = &loc_8054D9F;
          if ( v86 )
            v50 = &loc_8054DC3;
          dword_806B270 = (int)v50;
          sub_8061A4C(v18, v17);
          v51 = gettext("empty tab");
          error(2, 0, v51);
          if ( optarg[1] )
          {
            if ( !strcmp(optarg, "\\0") )
            {
              v86 = 0;
              dword_806B234 = (int)&loc_8054E3E;
              sub_8061BAC();
            }
            v52 = (char *)sub_805BCF1(optarg);
            v53 = gettext("multi-character tab %s");
            v76 = v52;
            error(2, 0, v53, v52);
          }
          if ( dword_806B3D4 != 128 )
          {
            v54 = &loc_8054E71;
            if ( v86 == dword_806B3D4 )
              v54 = &loc_8054E95;
            dword_806B2CC = (int)v54;
            sub_80617DA();
            v55 = gettext("incompatible tabs");
            error(2, 0, v55);
          }
          dword_806B3D4 = v86;
          dword_806B248 = (int)&loc_8054FE4;
          sub_8061B34();
LABEL_127:
          sub_804C8FC((int)optarg);
          continue;
        case 117:
          goto LABEL_129;
        case 121:
          v17 = (int)argv[optind + 0x3FFFFFFF];
          if ( (char *)v17 == optarg )
          {
            for ( j = optarg; (unsigned int)(*j - 48) <= 9; ++j )
              ;
            v56 = *j != 0;
            v17 = optind - v56;
            optind -= v56;
          }
          break;
        case 122:
          byte_806B350 = 0;
          break;
        case 128:
          if ( optarg )
          {
            v34 = aCccgeneralNume[sub_8055B1B(
                                    "--check",
                                    optarg,
                                    (int)off_8063294,
                                    (size_t)"CCcgeneral-numeric",
                                    1u,
                                    off_806B3F4)];
            dword_806B31C = (int)&loc_80549C0;
            sub_8061576(v36, v35);
          }
          v93 = 99;
LABEL_75:
          if ( v81 && v81 != v93 )
            sub_8053D15((int)"cC");
          v81 = v93;
          break;
        case 129:
          if ( arg && strcmp(arg, optarg) )
          {
            v37 = gettext("multiple compress programs specified");
            error(2, 0, v37);
          }
          arg = optarg;
          break;
        case 130:
          byte_806BFEC = 1;
          break;
        case 131:
          v98 = optarg;
          break;
        case 132:
          sub_804CD24(longind, v93, optarg);
          break;
        case 133:
          if ( v94 && strcmp(v94, optarg) )
          {
            v47 = gettext("multiple random sources specified");
            error(2, 0, v47);
          }
          v94 = optarg;
          break;
        case 134:
          v93 = byte_80632F8[sub_8055B1B("--sort", optarg, (int)&off_80632DC, (size_t)byte_80632F8, 1u, off_806B3F4)];
LABEL_71:
          v89 = v93;
          v90 = 0;
          sub_8053F40(v17, (int)v18, *(double *)&v16, &v89, (int)s, 2);
          break;
        case 135:
          v95 = sub_804D22C((char)v93, (int)optarg, longind, v93, optarg);
          dword_806B2F4 = (int)&loc_8054FE4;
          sub_80616BF();
LABEL_129:
          byte_806BFE2 = 1;
          break;
        default:
          sub_804B802(2);
          return result;
      }
    }
    if ( argc <= optind )
      break;
    v20 = v96++;
    v18 = &v97[v20];
    v21 = optind++;
    v17 = 4 * v21;
    *v18 = argv[v21];
  }
  v19 = &loc_8054565;
  if ( v98 )
    v19 = &loc_8054FE9;
  dword_806B220 = (int)v19;
  sub_8061C20(v18, v17);
  for ( k = (_DWORD *)dword_806BFE4; k; k = (_DWORD *)k[9] )
  {
    if ( (unsigned __int8)sub_804F2BF(*(double *)&v16, (int)k) && *((_BYTE *)k + 31) != 1 )
    {
      k[4] = v112;
      k[5] = v113;
      *((_BYTE *)k + 24) = v114;
      *((_BYTE *)k + 25) = v115;
      *((_BYTE *)k + 30) = v120;
      *((_BYTE *)k + 26) = v116;
      *((_BYTE *)k + 28) = v118;
      *((_BYTE *)k + 29) = v119;
      *((_BYTE *)k + 32) = v122;
      *((_BYTE *)k + 27) = v117;
      *((_BYTE *)k + 31) = v121;
    }
    v83 = (v83 | *((unsigned __int8 *)k + 27)) != 0;
  }
  if ( !dword_806BFE4 && (unsigned __int8)sub_804F2BF(*(double *)&v16, (int)s) ^ 1 )
  {
    v80 = 1;
    sub_8053C55(s);
    v83 = (v83 | v117) != 0;
  }
  sub_8053D46();
  if ( byte_806BFEC )
  {
    if ( !v81 )
    {
      v59 = &loc_805541C;
      if ( !v99 )
        v59 = &loc_8055440;
      dword_806B298 = (int)v59;
      sub_8061955(v58, v57);
    }
    if ( v81 )
      v60 = v81;
    else
      v60 = 111;
    byte_806B3E0 = v60;
    sub_8053D15((int)&byte_806B3E0);
    if ( v85 )
      v85 = setlocale(3, &locale) != 0;
    if ( v85 != 1 )
    {
      v76 = gettext("failed to set locale");
      error(0, 0, "%s", v76);
    }
    if ( byte_806BBB8 )
    {
      v61 = setlocale(3, 0);
      v62 = (char *)sub_805BCF1(v61);
      v63 = gettext("using %s sorting rules");
      v76 = v62;
      error(0, 0, v63, v62);
    }
    else
    {
      v76 = gettext("using simple byte comparison");
      error(0, 0, "%s", v76);
    }
    v75 = v80;
    sub_804F509(*(double *)&v16, s);
  }
  byte_806BFE0 = v121;
  if ( v83 )
    sub_804E6B4(*(double *)&v16, v94);
  if ( !dword_806BFD8 )
  {
    v106 = getenv("TMPDIR");
    if ( v106 )
      v64 = v106;
    else
      v64 = "/tmp";
    sub_804C8FC((int)v64);
  }
  if ( !v96 )
  {
    v96 = 1;
    free(v97);
    v97 = sub_805E3F4(4u);
    *v97 = "-";
  }
  if ( size )
  {
    v57 = 18 * dword_806B3D8;
    v65 = size;
    if ( 18 * dword_806B3D8 >= size )
      v65 = 18 * dword_806B3D8;
    size = v65;
  }
  if ( v81 )
  {
    if ( v96 > 1 )
    {
      v66 = (const char *)v81;
      v75 = v97[1];
      v67 = (char *)sub_805B8B4(4, (char *)v75);
      v68 = gettext("extra operand %s not allowed with -%c");
      v77 = v66;
      v76 = v67;
      error(2, 0, v68, v67, v66);
    }
    v69 = &loc_805566B;
    if ( !v99 )
      v69 = &loc_8055681;
    dword_806B2E0 = (int)v69;
    sub_806174E(v58, v57);
    byte_806B3EA = v81;
    sub_8053D15((int)&byte_806B3EA);
    v70 = (char *)*v97;
    v75 = v81;
    sub_8050D4F(v70);
  }
  sub_8053268((int)v97, v96);
  sub_805333C(v99);
  if ( !v82 )
  {
    if ( !v95 )
    {
      v108 = sub_80599AB(2);
      v71 = 8;
      if ( v108 <= 8 )
        v71 = v108;
      v95 = v71;
    }
    v109 = 29826161;
    v72 = v95;
    if ( v95 >= 0x1C71C71 )
      v72 = v109;
    v95 = v72;
    sub_80537EB(*(double *)&v16, (char **)v97, v96, v99, v72);
  }
  v107 = sub_805E513(v96, 8u);
  for ( l = 0; l < v96; ++l )
    v107[2 * l] = v97[l];
  sub_80533AE(*(double *)&v16, (int)v107, 0, v96, v99);
  if ( byte_806BFE3 && sub_805F3D1(*(double *)&v16, stdin) == -1 )
  {
    v73 = gettext("close failed");
    sub_804B777((int)v73, "-");
  }
  return 0;
}
// 15: found interdependent unknown calls
// 8061576: using guessed type int __fastcall sub_8061576(_DWORD, _DWORD);
// 806160F: using guessed type int sub_806160F(void);
// 806174E: using guessed type int __fastcall sub_806174E(_DWORD, _DWORD);
// 80617DA: using guessed type int sub_80617DA(void);
// 8061881: using guessed type int sub_8061881(void);
// 80619DA: using guessed type double __fastcall sub_80619DA(_DWORD, _DWORD);
// 8061A4C: using guessed type int __fastcall sub_8061A4C(_DWORD, _DWORD);
// 8061B34: using guessed type int sub_8061B34(void);
// 8061BAC: using guessed type int sub_8061BAC(void);
// 8061C20: using guessed type int __fastcall sub_8061C20(_DWORD, _DWORD);
// 8063294: using guessed type char *off_8063294[3];
// 80632DC: using guessed type void *off_80632DC;
// 806B220: using guessed type int dword_806B220;
// 806B234: using guessed type int dword_806B234;
// 806B248: using guessed type int dword_806B248;
// 806B270: using guessed type int dword_806B270;
// 806B284: using guessed type int dword_806B284;
// 806B298: using guessed type int dword_806B298;
// 806B2B8: using guessed type int dword_806B2B8;
// 806B2CC: using guessed type int dword_806B2CC;
// 806B2E0: using guessed type int dword_806B2E0;
// 806B2F4: using guessed type int dword_806B2F4;
// 806B308: using guessed type int dword_806B308;
// 806B31C: using guessed type int dword_806B31C;
// 806B350: using guessed type char byte_806B350;
// 806B3D4: using guessed type int dword_806B3D4;
// 806B3E0: using guessed type char byte_806B3E0;
// 806B3EA: using guessed type char byte_806B3EA;
// 806B4A0: using guessed type int optind;
// 806BBB0: using guessed type int dword_806BBB0;
// 806BBB4: using guessed type int dword_806BBB4;
// 806BBB8: using guessed type char byte_806BBB8;
// 806BBB9: using guessed type char byte_806BBB9;
// 806BFD8: using guessed type int dword_806BFD8;
// 806BFE0: using guessed type char byte_806BFE0;
// 806BFE1: using guessed type char byte_806BFE1;
// 806BFE2: using guessed type char byte_806BFE2;
// 806BFE3: using guessed type char byte_806BFE3;
// 806BFE4: using guessed type int dword_806BFE4;
// 806BFEC: using guessed type char byte_806BFEC;

//----- (08055832) --------------------------------------------------------
void __noreturn sub_8055832()
{
  sub_804B802(1);
}

//----- (08055846) --------------------------------------------------------
int __cdecl sub_8055846(char *s, int a2, int a3, size_t a4)
{
  size_t v4; // eax
  int v5; // edx
  int v6; // ecx
  void *v7; // eax
  int result; // eax
  const char *v9; // [esp+0h] [ebp-28h]
  const void *v10; // [esp+4h] [ebp-24h]
  char v11; // [esp+13h] [ebp-15h]
  int i; // [esp+14h] [ebp-14h]
  int v13; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]

  v13 = -1;
  v11 = 0;
  n = strlen(s);
  for ( i = 0; *(_DWORD *)(4 * i + a2); ++i )
  {
    if ( !strncmp(*(const char **)(4 * i + a2), s, n) )
    {
      v9 = *(const char **)(4 * i + a2);
      v4 = strlen(v9);
      if ( v4 == n )
      {
        dword_806B284 = (int)&locret_805596A;
        sub_80619DA(v6, v5);
      }
      if ( v13 == -1 )
      {
        v13 = i;
      }
      else
      {
        v7 = &loc_8055905;
        if ( !a3 )
          v7 = &loc_8055939;
        dword_806B308 = (int)v7;
        sub_806160F();
        v10 = (const void *)(i * a4 + a3);
        v9 = (const char *)(a3 + a4 * v13);
        if ( memcmp(v9, v10, a4) )
          v11 = 1;
      }
    }
  }
  if ( v11 )
    result = -2;
  else
    result = v13;
  return result;
}
// 806160F: using guessed type int sub_806160F(void);
// 80619DA: using guessed type double __fastcall sub_80619DA(_DWORD, _DWORD);
// 806B284: using guessed type int dword_806B284;
// 806B308: using guessed type int dword_806B308;

//----- (0805596C) --------------------------------------------------------
void __cdecl sub_805596C(char *a1, char *a2, int a3)
{
  char *v3; // eax
  char *format; // ST2C_4
  void *v5; // ebx
  void *v6; // eax

  if ( a3 == -1 )
    v3 = gettext("invalid argument %s for %s");
  else
    v3 = gettext("ambiguous argument %s for %s");
  format = v3;
  v5 = sub_805BCCF(1, a1);
  v6 = sub_805B839(0, 8, a2);
  error(0, 0, format, v6, v5);
}

//----- (080559EF) --------------------------------------------------------
int __cdecl sub_80559EF(int a1)
{
  FILE *v1; // ebx
  char *v2; // eax
  void *v3; // eax

  v1 = stderr;
  v2 = gettext("Valid arguments are:");
  fputs_unlocked(v2, v1);
  v3 = &loc_8055B00;
  if ( *(_DWORD *)a1 )
    v3 = &loc_8055A27;
  dword_806B2B8 = (int)v3;
  sub_8061881();
  return putc_unlocked(10, stderr);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8061881: using guessed type int sub_8061881(void);
// 806B2B8: using guessed type int dword_806B2B8;

//----- (08055B1B) --------------------------------------------------------
int __cdecl sub_8055B1B(void *s1, char *s, int a3, size_t n, size_t a5, int a6)
{
  int v7; // [esp+1Ch] [ebp-Ch]

  v7 = sub_8055846(s, a3, n, a5);
  if ( v7 >= 0 )
    return v7;
  sub_805596C((char *)s1, s, v7);
  sub_80559EF(a3);
  ((void (*)(void))a6)();
  return -1;
}

//----- (08055C45) --------------------------------------------------------
int __cdecl sub_8055C45(unsigned __int8 a1)
{
  int result; // eax

  result = a1;
  byte_806C138 = a1;
  return result;
}
// 806C138: using guessed type char byte_806C138;

//----- (08055C5C) --------------------------------------------------------
int __usercall sub_8055C5C@<eax>(double a1@<st0>)
{
  bool v1; // zf
  void *v2; // eax
  char *v3; // ebx
  int v4; // eax
  int v5; // eax
  int result; // eax
  char *v7; // [esp+Ch] [ebp-2Ch]
  char *v8; // [esp+10h] [ebp-28h]
  char *v9; // [esp+2Ch] [ebp-Ch]

  if ( sub_8060338(a1, stdout) )
  {
    if ( byte_806C138 == 1 )
    {
      v1 = *__errno_location() == 32;
      v2 = &loc_8055CAB;
      if ( v1 )
        v2 = &loc_8055D46;
      dword_806B308 = (int)v2;
      sub_806160F();
    }
    v9 = gettext("write error");
    if ( dword_806C134 )
    {
      v3 = (char *)sub_805BA17((char *)dword_806C134);
      v4 = *__errno_location();
      v8 = v9;
      v7 = v3;
      error(0, v4, "%s: %s", v3, v9);
      dword_806B248 = (int)&loc_8055D39;
      sub_8061B34();
    }
    v5 = *__errno_location();
    v7 = v9;
    error(0, v5, "%s", v9);
    _exit(status);
  }
  result = sub_8060338(a1, stderr);
  if ( result )
    _exit(status);
  return result;
}
// 806160F: using guessed type int sub_806160F(void);
// 8061B34: using guessed type int sub_8061B34(void);
// 806B248: using guessed type int dword_806B248;
// 806B308: using guessed type int dword_806B308;
// 806C134: using guessed type int dword_806C134;
// 806C138: using guessed type char byte_806C138;

//----- (08055D6A) --------------------------------------------------------
_DWORD *__cdecl sub_8055D6A(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 1732584193;
  a1[1] = -271733879;
  a1[2] = -1732584194;
  a1[3] = 271733878;
  a1[5] = 0;
  a1[4] = a1[5];
  result = a1;
  a1[6] = 0;
  return result;
}

//----- (08055DB6) --------------------------------------------------------
_DWORD *__cdecl sub_8055DB6(_DWORD *a1, int a2)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = a2;
  return result;
}

//----- (08055DC3) --------------------------------------------------------
int __usercall sub_8055DC3@<eax>(double a1@<st0>, int *a2, _DWORD *a3)
{
  sub_8055DB6(a3, *a2);
  sub_8055DB6(a3 + 1, a2[1]);
  sub_8055DB6(a3 + 2, a2[2]);
  dword_806B20C = (int)&loc_8055E14;
  sub_8061C98(a1);
  return sub_8055E5D(a1, a2, a3);
}
// 8061C98: using guessed type int __usercall sub_8061C98@<eax>(double@<st0>);
// 806B20C: using guessed type int dword_806B20C;

//----- (08055E5D) --------------------------------------------------------
int __usercall sub_8055E5D@<eax>(double a1@<st0>, int *a2, _DWORD *a3)
{
  signed int v3; // eax
  unsigned int v5; // [esp+18h] [ebp-10h]
  signed int v6; // [esp+1Ch] [ebp-Ch]

  v5 = a2[6];
  if ( v5 > 0x37 )
    v3 = 32;
  else
    v3 = 16;
  v6 = v3;
  a2[4] += v5;
  if ( a2[4] < v5 )
    ++a2[5];
  a2[v3 + 5] = 8 * a2[4];
  a2[v3 + 6] = *((_QWORD *)a2 + 2) >> 29;
  memcpy((char *)a2 + v5 + 28, &unk_80641E8, 4 * (v3 + 1073741822) - v5);
  sub_8056347(a2 + 7, 4 * v6, a2);
  return sub_8055DC3(a1, a2, a3);
}

//----- (0805612C) --------------------------------------------------------
int __usercall sub_805612C@<eax>(int a1@<edx>, int a2@<ecx>, void *src, size_t a4, int a5)
{
  int result; // eax
  int v6; // eax
  int *v7; // eax
  int v8; // edx
  int v9; // ecx
  size_t v10; // ST14_4
  size_t v11; // [esp+14h] [ebp-14h]
  int v12; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]

  result = *(_DWORD *)(a5 + 24);
  if ( result )
  {
    v12 = *(_DWORD *)(a5 + 24);
    v6 = a4;
    if ( 128 - v12 <= a4 )
      v6 = 128 - v12;
    n = v6;
    memcpy((void *)(v12 + a5 + 28), src, v6);
    a1 = n + *(_DWORD *)(a5 + 24);
    *(_DWORD *)(a5 + 24) = a1;
    if ( *(_DWORD *)(a5 + 24) > 0x40u )
    {
      sub_8056347((int *)(a5 + 28), *(_DWORD *)(a5 + 24) & 0xFFFFFFC0, (int *)a5);
      *(_DWORD *)(a5 + 24) &= 0x3Fu;
      memcpy((void *)(a5 + 28), (const void *)(a5 + 28 + ((v12 + n) & 0xFFFFFFC0)), *(_DWORD *)(a5 + 24));
    }
    src = (char *)src + n;
    result = n;
    a4 -= n;
  }
  if ( a4 > 0x3F )
  {
    if ( (unsigned __int8)src & 3 )
    {
      dword_806B298 = (int)&loc_8056274;
      sub_8061955(a2, a1);
      do
      {
        v7 = (int *)memcpy((void *)(a5 + 28), src, 0x40u);
        sub_8056347(v7, 0x40u, (int *)a5);
        src = (char *)src + 64;
        a4 -= 64;
      }
      while ( a4 > 0x40 );
      dword_806B31C = (int)&loc_80562BC;
      sub_8061576(v9, v8);
    }
    sub_8056347((int *)src, a4 & 0xFFFFFFC0, (int *)a5);
    result = a4 & 0xFFFFFFC0;
    src = (char *)src + (a4 & 0xFFFFFFC0);
    a4 &= 0x3Fu;
  }
  if ( a4 )
  {
    v10 = *(_DWORD *)(a5 + 24);
    memcpy((void *)(v10 + a5 + 28), src, a4);
    v11 = a4 + v10;
    if ( v11 > 0x3F )
    {
      sub_8056347((int *)(a5 + 28), 0x40u, (int *)a5);
      v11 -= 64;
      memcpy((void *)(a5 + 28), (const void *)(a5 + 92), v11);
    }
    result = a5;
    *(_DWORD *)(a5 + 24) = v11;
  }
  return result;
}
// 8061576: using guessed type int __fastcall sub_8061576(_DWORD, _DWORD);
// 806B298: using guessed type int dword_806B298;
// 806B31C: using guessed type int dword_806B31C;

//----- (08056347) --------------------------------------------------------
int *__cdecl sub_8056347(int *a1, unsigned int a2, int *a3)
{
  int v3; // ST30_4
  int v4; // ST34_4
  int v5; // ST38_4
  int v6; // ST3C_4
  int v7; // ST40_4
  int v8; // ST10_4
  int *v9; // ST0C_4
  int v10; // ST10_4
  int v11; // ST44_4
  int v12; // ST1C_4
  int v13; // ST48_4
  int v14; // ST18_4
  int v15; // ST4C_4
  int v16; // ST14_4
  int v17; // ST50_4
  int v18; // ST10_4
  int v19; // ST54_4
  int v20; // ST1C_4
  int v21; // ST58_4
  int v22; // ST18_4
  int v23; // ST5C_4
  int v24; // ST14_4
  int v25; // ST60_4
  int v26; // ST10_4
  int v27; // ST64_4
  int v28; // ST1C_4
  int v29; // ST68_4
  int v30; // ST18_4
  int v31; // ST6C_4
  int v32; // ST14_4
  int v33; // ST70_4
  int v34; // ST10_4
  int v35; // ST74_4
  int v36; // ST1C_4
  int v37; // ST78_4
  int v38; // ST18_4
  int v39; // ST7C_4
  int v40; // ST14_4
  int v41; // ST10_4
  int v42; // ST1C_4
  int v43; // ST18_4
  int v44; // ST14_4
  int v45; // ST10_4
  int v46; // ST1C_4
  int v47; // ST18_4
  int v48; // ST14_4
  int v49; // ST10_4
  int v50; // ST1C_4
  int v51; // ST18_4
  int v52; // ST14_4
  int v53; // ST10_4
  int v54; // ST1C_4
  int v55; // ST18_4
  int v56; // ST14_4
  int v57; // ST10_4
  int v58; // ST1C_4
  int v59; // ST18_4
  int v60; // ST14_4
  int v61; // ST10_4
  int v62; // ST1C_4
  int v63; // ST18_4
  int v64; // ST14_4
  int v65; // ST10_4
  int v66; // ST1C_4
  int v67; // ST18_4
  int v68; // ST14_4
  int v69; // ST10_4
  int v70; // ST1C_4
  int v71; // ST18_4
  int v72; // ST14_4
  int v73; // ST10_4
  int v74; // ST1C_4
  int v75; // ST18_4
  int v76; // ST14_4
  int v77; // ST10_4
  int v78; // ST1C_4
  int v79; // ST18_4
  int v80; // ST14_4
  int v81; // ST10_4
  int v82; // ST1C_4
  int v83; // ST18_4
  int v84; // ST14_4
  int v85; // ST10_4
  int v86; // ST1C_4
  int v87; // ST18_4
  int v88; // ST14_4
  int *result; // eax
  int *v90; // [esp+Ch] [ebp-74h]
  int v91; // [esp+10h] [ebp-70h]
  int v92; // [esp+14h] [ebp-6Ch]
  int v93; // [esp+18h] [ebp-68h]
  int v94; // [esp+1Ch] [ebp-64h]

  v90 = a1;
  v91 = *a3;
  v92 = a3[1];
  v93 = a3[2];
  v94 = a3[3];
  a3[4] += a2;
  a3[5] += a3[4] < a2;
  while ( v90 < &a1[a2 >> 2] )
  {
    v3 = v91;
    v4 = v92;
    v5 = v93;
    v6 = v94;
    v7 = *v90;
    v8 = (v94 ^ v92 & (v93 ^ v94)) + *v90 + v91 - 680876936;
    v9 = v90 + 1;
    v10 = v92 + __ROR4__(v8, 25);
    v11 = *v9;
    ++v9;
    v12 = v10 + __ROR4__((v93 ^ v10 & (v92 ^ v93)) + v11 + v94 - 389564586, 20);
    v13 = *v9;
    ++v9;
    v14 = v12 + __ROR4__((v92 ^ v12 & (v10 ^ v92)) + v13 + v93 + 606105819, 15);
    v15 = *v9;
    ++v9;
    v16 = v14 + __ROR4__((v10 ^ v14 & (v12 ^ v10)) + v15 + v92 - 1044525330, 10);
    v17 = *v9;
    ++v9;
    v18 = v16 + __ROR4__((v12 ^ v16 & (v14 ^ v12)) + v17 + v10 - 176418897, 25);
    v19 = *v9;
    ++v9;
    v20 = v18 + __ROR4__((v14 ^ v18 & (v16 ^ v14)) + v19 + v12 + 1200080426, 20);
    v21 = *v9;
    ++v9;
    v22 = v20 + __ROR4__((v16 ^ v20 & (v18 ^ v16)) + v21 + v14 - 1473231341, 15);
    v23 = *v9;
    ++v9;
    v24 = v22 + __ROR4__((v18 ^ v22 & (v20 ^ v18)) + v23 + v16 - 45705983, 10);
    v25 = *v9;
    ++v9;
    v26 = v24 + __ROR4__((v20 ^ v24 & (v22 ^ v20)) + v25 + v18 + 1770035416, 25);
    v27 = *v9;
    ++v9;
    v28 = v26 + __ROR4__((v22 ^ v26 & (v24 ^ v22)) + v27 + v20 - 1958414417, 20);
    v29 = *v9;
    ++v9;
    v30 = v28 + __ROR4__((v24 ^ v28 & (v26 ^ v24)) + v29 + v22 - 42063, 15);
    v31 = *v9;
    ++v9;
    v32 = v30 + __ROR4__((v26 ^ v30 & (v28 ^ v26)) + v31 + v24 - 1990404162, 10);
    v33 = *v9;
    ++v9;
    v34 = v32 + __ROR4__((v28 ^ v32 & (v30 ^ v28)) + v33 + v26 + 1804603682, 25);
    v35 = *v9;
    ++v9;
    v36 = v34 + __ROR4__((v30 ^ v34 & (v32 ^ v30)) + v35 + v28 - 40341101, 20);
    v37 = *v9;
    ++v9;
    v38 = v36 + __ROR4__((v32 ^ v36 & (v34 ^ v32)) + v37 + v30 - 1502002290, 15);
    v39 = *v9;
    v90 = v9 + 1;
    v40 = v38 + __ROR4__((v34 ^ v38 & (v36 ^ v34)) + v39 + v32 + 1236535329, 10);
    v41 = v40 + __ROR4__(v11 + (v38 ^ v36 & (v40 ^ v38)) + v34 - 165796510, 27);
    v42 = v41 + __ROR4__(v21 + (v40 ^ v38 & (v41 ^ v40)) + v36 - 1069501632, 23);
    v43 = v42 + __ROR4__(v31 + (v41 ^ v40 & (v42 ^ v41)) + v38 + 643717713, 18);
    v44 = v43 + __ROR4__(v7 + (v42 ^ v41 & (v43 ^ v42)) + v40 - 373897302, 12);
    v45 = v44 + __ROR4__(v19 + (v43 ^ v42 & (v44 ^ v43)) + v41 - 701558691, 27);
    v46 = v45 + __ROR4__(v29 + (v44 ^ v43 & (v45 ^ v44)) + v42 + 38016083, 23);
    v47 = v46 + __ROR4__(v39 + (v45 ^ v44 & (v46 ^ v45)) + v43 - 660478335, 18);
    v48 = v47 + __ROR4__(v17 + (v46 ^ v45 & (v47 ^ v46)) + v44 - 405537848, 12);
    v49 = v48 + __ROR4__(v27 + (v47 ^ v46 & (v48 ^ v47)) + v45 + 568446438, 27);
    v50 = v49 + __ROR4__(v37 + (v48 ^ v47 & (v49 ^ v48)) + v46 - 1019803690, 23);
    v51 = v50 + __ROR4__(v15 + (v49 ^ v48 & (v50 ^ v49)) + v47 - 187363961, 18);
    v52 = v51 + __ROR4__(v25 + (v50 ^ v49 & (v51 ^ v50)) + v48 + 1163531501, 12);
    v53 = v52 + __ROR4__(v35 + (v51 ^ v50 & (v52 ^ v51)) + v49 - 1444681467, 27);
    v54 = v53 + __ROR4__(v13 + (v52 ^ v51 & (v53 ^ v52)) + v50 - 51403784, 23);
    v55 = v54 + __ROR4__(v23 + (v53 ^ v52 & (v54 ^ v53)) + v51 + 1735328473, 18);
    v56 = v55 + __ROR4__(v33 + (v54 ^ v53 & (v55 ^ v54)) + v52 - 1926607734, 12);
    v57 = v56 + __ROR4__(v19 + (v54 ^ v56 ^ v55) + v53 - 378558, 28);
    v58 = v57 + __ROR4__(v25 + (v55 ^ v57 ^ v56) + v54 - 2022574463, 21);
    v59 = v58 + __ROR4__(v31 + (v56 ^ v58 ^ v57) + v55 + 1839030562, 16);
    v60 = v59 + __ROR4__(v37 + (v57 ^ v59 ^ v58) + v56 - 35309556, 9);
    v61 = v60 + __ROR4__(v11 + (v58 ^ v60 ^ v59) + v57 - 1530992060, 28);
    v62 = v61 + __ROR4__(v17 + (v59 ^ v61 ^ v60) + v58 + 1272893353, 21);
    v63 = v62 + __ROR4__(v23 + (v60 ^ v62 ^ v61) + v59 - 155497632, 16);
    v64 = v63 + __ROR4__(v29 + (v61 ^ v63 ^ v62) + v60 - 1094730640, 9);
    v65 = v64 + __ROR4__(v35 + (v62 ^ v64 ^ v63) + v61 + 681279174, 28);
    v66 = v65 + __ROR4__(v7 + (v63 ^ v65 ^ v64) + v62 - 358537222, 21);
    v67 = v66 + __ROR4__(v15 + (v64 ^ v66 ^ v65) + v63 - 722521979, 16);
    v68 = v67 + __ROR4__(v21 + (v65 ^ v67 ^ v66) + v64 + 76029189, 9);
    v69 = v68 + __ROR4__(v27 + (v66 ^ v68 ^ v67) + v65 - 640364487, 28);
    v70 = v69 + __ROR4__(v33 + (v67 ^ v69 ^ v68) + v66 - 421815835, 21);
    v71 = v70 + __ROR4__(v39 + (v68 ^ v70 ^ v69) + v67 + 530742520, 16);
    v72 = v71 + __ROR4__(v13 + (v69 ^ v71 ^ v70) + v68 - 995338651, 9);
    v73 = v72 + __ROR4__(v7 + (v71 ^ (v72 | ~v70)) + v69 - 198630844, 26);
    v74 = v73 + __ROR4__(v23 + (v72 ^ (v73 | ~v71)) + v70 + 1126891415, 22);
    v75 = v74 + __ROR4__(v37 + (v73 ^ (v74 | ~v72)) + v71 - 1416354905, 17);
    v76 = v75 + __ROR4__(v19 + (v74 ^ (v75 | ~v73)) + v72 - 57434055, 11);
    v77 = v76 + __ROR4__(v33 + (v75 ^ (v76 | ~v74)) + v73 + 1700485571, 26);
    v78 = v77 + __ROR4__(v15 + (v76 ^ (v77 | ~v75)) + v74 - 1894986606, 22);
    v79 = v78 + __ROR4__(v29 + (v77 ^ (v78 | ~v76)) + v75 - 1051523, 17);
    v80 = v79 + __ROR4__(v11 + (v78 ^ (v79 | ~v77)) + v76 - 2054922799, 11);
    v81 = v80 + __ROR4__(v25 + (v79 ^ (v80 | ~v78)) + v77 + 1873313359, 26);
    v82 = v81 + __ROR4__(v39 + (v80 ^ (v81 | ~v79)) + v78 - 30611744, 22);
    v83 = v82 + __ROR4__(v21 + (v81 ^ (v82 | ~v80)) + v79 - 1560198380, 17);
    v84 = v83 + __ROR4__(v35 + (v82 ^ (v83 | ~v81)) + v80 + 1309151649, 11);
    v85 = v84 + __ROR4__(v17 + (v83 ^ (v84 | ~v82)) + v81 - 145523070, 26);
    v86 = v85 + __ROR4__(v31 + (v84 ^ (v85 | ~v83)) + v82 - 1120210379, 22);
    v87 = v86 + __ROR4__(v13 + (v85 ^ (v86 | ~v84)) + v83 + 718787259, 17);
    v88 = v87 + __ROR4__(v27 + (v86 ^ (v87 | ~v85)) + v84 - 343485551, 11);
    v91 = v3 + v85;
    v92 = v4 + v88;
    v93 = v5 + v87;
    v94 = v6 + v86;
  }
  *a3 = v91;
  a3[1] = v92;
  a3[2] = v93;
  result = a3;
  a3[3] = v94;
  return result;
}

//----- (08057041) --------------------------------------------------------
int __cdecl sub_8057041(int a1, int a2, int a3, int a4, int a5, int a6)
{
  return posix_fadvise64(a1, a2, a3, a4, a5, a6);
}
// 8049E60: using guessed type int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (08057092) --------------------------------------------------------
void __cdecl sub_8057092(FILE *stream, int a2)
{
  int v2; // eax

  if ( stream )
  {
    v2 = fileno(stream);
    sub_8057041(v2, 0, 0, 0, 0, a2);
  }
}

//----- (080570DA) --------------------------------------------------------
_BYTE *__cdecl sub_80570DA(_BYTE **a1)
{
  bool v1; // zf
  void *v2; // eax
  char v4; // [esp+1Bh] [ebp-Dh]
  _BYTE *v5; // [esp+1Ch] [ebp-Ch]

  v5 = 0;
  v4 = 0;
  while ( **a1 )
  {
    if ( v4 )
    {
      v4 = 0;
      if ( (unsigned __int8)sub_806002F((char)**a1) ^ 1 && **a1 != 126 )
        v5 = 0;
    }
    else if ( **a1 == 46 )
    {
      v4 = 1;
      if ( !v5 )
        v5 = *a1;
    }
    else
    {
      v1 = (unsigned __int8)sub_805FFE6((char)**a1) == 1;
      v2 = &loc_8057193;
      if ( v1 )
        v2 = &loc_8057160;
      dword_806B308 = (int)v2;
      sub_806160F();
      if ( **a1 != 126 )
        v5 = 0;
    }
    ++*a1;
  }
  return v5;
}
// 806160F: using guessed type int sub_806160F(void);
// 806B308: using guessed type int dword_806B308;

//----- (080571D2) --------------------------------------------------------
int __cdecl sub_80571D2(unsigned __int8 a1)
{
  int result; // eax
  int v2; // edx
  int v3; // ecx
  unsigned __int8 v4; // [esp+Ch] [ebp-Ch]

  v4 = a1;
  if ( (unsigned __int8)sub_80600C8(a1) )
  {
    dword_806B234 = (int)&loc_8057261;
    result = sub_8061BAC();
  }
  else if ( (unsigned __int8)sub_806002F(v4) )
  {
    result = v4;
  }
  else if ( v4 == 126 )
  {
    result = -1;
  }
  else
  {
    dword_806B298 = (int)&locret_8057205;
    sub_8061955(v3, v2);
    result = 0;
  }
  return result;
}
// 8061BAC: using guessed type int sub_8061BAC(void);
// 806B234: using guessed type int dword_806B234;
// 806B298: using guessed type int dword_806B298;

//----- (0805726A) --------------------------------------------------------
int __usercall sub_805726A@<eax>(double a1@<st0>, int a2, unsigned int a3, int a4, unsigned int a5)
{
  int v5; // eax
  int v6; // eax
  bool v8; // zf
  void *v9; // eax
  void *v10; // eax
  int v11; // edx
  int v12; // ecx
  void *v13; // eax
  int v14; // edx
  int v15; // ecx
  unsigned int v16; // [esp+1Ch] [ebp-1Ch]
  unsigned int v17; // [esp+20h] [ebp-18h]
  int v18; // [esp+24h] [ebp-14h]
  int v19; // [esp+28h] [ebp-10h]

  v16 = 0;
  v17 = 0;
  while ( v16 < a3 || v17 < a5 )
  {
    v18 = 0;
    while ( v16 < a3 && (unsigned __int8)sub_80600C8(*(char *)(a2 + v16)) ^ 1 )
    {
      if ( v16 == a3 )
        v5 = 0;
      else
        v5 = sub_80571D2(*(_BYTE *)(a2 + v16));
      v19 = v5;
      if ( v17 == a5 )
        v6 = 0;
      else
        v6 = sub_80571D2(*(_BYTE *)(a4 + v17));
      if ( v19 != v6 )
        return v19 - v6;
      ++v16;
      ++v17;
    }
    if ( v17 < a5 )
    {
      v8 = (unsigned __int8)sub_80600C8(*(char *)(a4 + v17)) == 1;
      v9 = &loc_8057362;
      if ( !v8 )
        v9 = &loc_805728C;
      dword_806B2F4 = (int)v9;
      sub_80616BF();
    }
    while ( *(_BYTE *)(a2 + v16) == 48 )
      ++v16;
    while ( *(_BYTE *)(a4 + v17) == 48 )
      ++v17;
    while ( 1 )
    {
      v8 = (unsigned __int8)sub_80600C8(*(char *)(a2 + v16)) == 0;
      v10 = &loc_80573F2;
      if ( v8 )
        v10 = &loc_805740C;
      dword_806B20C = (int)v10;
      sub_8061C98(a1);
      if ( !(unsigned __int8)sub_80600C8(*(char *)(a4 + v17)) )
        break;
      if ( !v18 )
        v18 = *(char *)(a2 + v16) - *(char *)(a4 + v17);
      ++v16;
      ++v17;
    }
    if ( (unsigned __int8)sub_80600C8(*(char *)(a2 + v16)) )
      return 1;
    v8 = (unsigned __int8)sub_80600C8(*(char *)(a4 + v17)) == 0;
    v13 = &loc_8057463;
    if ( v8 )
      v13 = &loc_805747F;
    dword_806B25C = (int)v13;
    sub_8061AC4(v12, v11);
    dword_806B2F4 = (int)&locret_80574BC;
    sub_80616BF();
    if ( v18 )
    {
      dword_806B220 = (int)&locret_80574BC;
      sub_8061C20(v15, v14);
    }
  }
  return 0;
}
// 805726A: could not find valid save-restore pair for ebx
// 8061AC4: using guessed type int __fastcall sub_8061AC4(_DWORD, _DWORD);
// 8061C20: using guessed type int __fastcall sub_8061C20(_DWORD, _DWORD);
// 8061C98: using guessed type int __usercall sub_8061C98@<eax>(double@<st0>);
// 806B20C: using guessed type int dword_806B20C;
// 806B220: using guessed type int dword_806B220;
// 806B25C: using guessed type int dword_806B25C;
// 806B2F4: using guessed type int dword_806B2F4;

//----- (080574BE) --------------------------------------------------------
int __usercall sub_80574BE@<eax>(double a1@<st0>, char *s1, char *s2)
{
  int v4; // edx
  int v5; // ecx
  void *v6; // eax
  int v7; // edx
  int v8; // ecx
  void *v9; // eax
  char *v10; // eax
  void *v11; // eax
  int v12; // eax
  int v13; // edx
  int v14; // ecx
  bool v15; // zf
  void *v16; // eax
  char *v17; // [esp+10h] [ebp-28h]
  char *v18; // [esp+14h] [ebp-24h]
  size_t n; // [esp+18h] [ebp-20h]
  unsigned int v20; // [esp+1Ch] [ebp-1Ch]
  int v21; // [esp+20h] [ebp-18h]
  char *v22; // [esp+24h] [ebp-14h]
  _BYTE *v23; // [esp+28h] [ebp-10h]
  int v24; // [esp+2Ch] [ebp-Ch]

  v21 = strcmp(s1, s2);
  if ( !v21 )
    return 0;
  if ( !*s1 )
    return -1;
  if ( !*s2 )
    return 1;
  if ( !strcmp(".", s1) )
    return -1;
  if ( !strcmp(".", s2) )
    return 1;
  if ( !strcmp("..", s1) )
    return -1;
  if ( !strcmp("..", s2) )
  {
    dword_806B20C = (int)&locret_8057766;
    sub_8061C98(a1);
  }
  v6 = &loc_80575CA;
  if ( *s1 != 46 )
    v6 = &loc_80575DE;
  dword_806B31C = (int)v6;
  sub_8061576(v5, v4);
  if ( *s2 != 46 )
    return -1;
  if ( *s1 != 46 && *s2 == 46 )
  {
    dword_806B25C = (int)&locret_8057766;
    sub_8061AC4(v8, v7);
  }
  if ( *s1 == 46 )
  {
    v9 = &loc_805763B;
    if ( *s2 != 46 )
      v9 = &loc_8057643;
    dword_806B270 = (int)v9;
    sub_8061A4C(v8, v7);
    ++s1;
    ++s2;
  }
  v17 = s1;
  v18 = s2;
  v22 = sub_80570DA(&v17);
  v23 = sub_80570DA(&v18);
  if ( v22 )
    v10 = v22;
  else
    v10 = v17;
  n = v10 - s1;
  v11 = &loc_80576A4;
  if ( !v23 )
    v11 = &loc_80576BE;
  dword_806B2B8 = (int)v11;
  sub_8061881();
  dword_806B2F4 = (int)&loc_80576C1;
  sub_80616BF();
  v20 = v18 - s2;
  if ( (v22 || v23) && n == v20 && !strncmp(s1, s2, n) )
  {
    n = v17 - s1;
    v20 = v18 - s2;
  }
  v12 = sub_805726A(a1, (int)s1, n, (int)s2, v20);
  v24 = v12;
  v15 = v12 == 0;
  v16 = &loc_805775E;
  if ( !v15 )
    v16 = &loc_8057763;
  dword_806B25C = (int)v16;
  sub_8061AC4(v14, v13);
  return v21;
}
// 80574BE: could not find valid save-restore pair for ebx
// 8061576: using guessed type int __fastcall sub_8061576(_DWORD, _DWORD);
// 8061881: using guessed type int sub_8061881(void);
// 8061A4C: using guessed type int __fastcall sub_8061A4C(_DWORD, _DWORD);
// 8061AC4: using guessed type int __fastcall sub_8061AC4(_DWORD, _DWORD);
// 8061C98: using guessed type int __usercall sub_8061C98@<eax>(double@<st0>);
// 806B20C: using guessed type int dword_806B20C;
// 806B25C: using guessed type int dword_806B25C;
// 806B270: using guessed type int dword_806B270;
// 806B2B8: using guessed type int dword_806B2B8;
// 806B2F4: using guessed type int dword_806B2F4;
// 806B31C: using guessed type int dword_806B31C;

//----- (08057768) --------------------------------------------------------
int __cdecl sub_8057768(int category)
{
  unsigned __int8 v2; // [esp+1Bh] [ebp-Dh]
  const char *s1; // [esp+1Ch] [ebp-Ch]

  v2 = 1;
  s1 = setlocale(category, 0);
  if ( s1 && (!strcmp(s1, "C") || !strcmp(s1, "POSIX")) )
    v2 = 0;
  return v2;
}

//----- (080577C6) --------------------------------------------------------
int __cdecl sub_80577C6(int a1)
{
  return *(_DWORD *)(a1 + 8);
}

//----- (080577D1) --------------------------------------------------------
int __cdecl sub_80577D1(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (080577DC) --------------------------------------------------------
int __cdecl sub_80577DC(int a1)
{
  return *(_DWORD *)(a1 + 16);
}

//----- (080577E7) --------------------------------------------------------
unsigned int __cdecl sub_80577E7(int a1)
{
  void *v1; // eax
  _DWORD *i; // [esp+0h] [ebp-10h]
  unsigned int v4; // [esp+4h] [ebp-Ch]

  v4 = 0;
  for ( i = *(_DWORD **)a1; *(_DWORD *)(a1 + 4) > (unsigned int)i; i += 2 )
  {
    if ( *i )
    {
      v1 = &loc_8057842;
      if ( i[1] )
        v1 = &loc_8057816;
      dword_806B2B8 = (int)v1;
      sub_8061881();
      if ( v4 < 1 )
        v4 = 1;
    }
  }
  return v4;
}
// 8061881: using guessed type int sub_8061881(void);
// 806B2B8: using guessed type int dword_806B2B8;

//----- (080579FD) --------------------------------------------------------
int __cdecl sub_80579FD(int a1, int a2)
{
  unsigned int v3; // [esp+1Ch] [ebp-Ch]

  v3 = (*(int (__cdecl **)(int, _DWORD))(a1 + 24))(a2, *(_DWORD *)(a1 + 8));
  if ( *(_DWORD *)(a1 + 8) <= v3 )
    abort();
  return 8 * v3 + *(_DWORD *)a1;
}

//----- (08057CF6) --------------------------------------------------------
bool __cdecl sub_8057CF6(unsigned int a1)
{
  int v1; // ST08_4
  unsigned int v3; // [esp+8h] [ebp-8h]
  unsigned int v4; // [esp+Ch] [ebp-4h]

  v3 = 3;
  v4 = 9;
  while ( v4 < a1 && a1 % v3 )
  {
    v1 = v3 + 1;
    v4 += 4 * v1;
    v3 = v1 + 1;
  }
  return a1 % v3 != 0;
}

//----- (08057D69) --------------------------------------------------------
int __cdecl sub_8057D69(unsigned int a1)
{
  int i; // [esp+14h] [ebp+8h]

  if ( a1 <= 9 )
    a1 = 10;
  for ( i = a1 | 1; i != -1 && !sub_8057CF6(i); i += 2 )
    ;
  return i;
}

//----- (08057E42) --------------------------------------------------------
signed int __usercall sub_8057E42@<eax>(int edx0@<edx>, int a2@<ecx>, int a1)
{
  void *v3; // eax

  v3 = &loc_8057E73;
  if ( *(_UNKNOWN **)(a1 + 20) != &unk_8064238 )
    v3 = &loc_8057E7D;
  dword_806B220 = (int)v3;
  sub_8061C20(a2, edx0);
  return 1;
}
// 8061C20: using guessed type int __fastcall sub_8061C20(_DWORD, _DWORD);
// 806B220: using guessed type int dword_806B220;

//----- (08057F23) --------------------------------------------------------
unsigned int __cdecl sub_8057F23(unsigned int a1, int a2)
{
  unsigned int result; // eax
  float v3; // [esp+20h] [ebp-4h]
  unsigned int v4; // [esp+2Ch] [ebp+8h]

  if ( *(_BYTE *)(a2 + 16) != 1 )
  {
    v3 = (long double)a1 / *(float *)(a2 + 8);
    if ( v3 >= 4294967300.0 )
    {
      dword_806B2F4 = (int)&locret_8057F82;
      sub_80616BF();
    }
    a1 = (signed __int64)v3;
  }
  v4 = sub_8057D69(a1);
  if ( v4 <= 0x1FFFFFFF )
    result = v4;
  else
    result = 0;
  return result;
}
// 806B2F4: using guessed type int dword_806B2F4;

//----- (08057FF1) --------------------------------------------------------
int sub_8057FF1()
{
  bool v0; // zf
  int v1; // edx
  int v2; // ecx
  void *v3; // eax

  v0 = malloc(0x28u) == 0;
  v3 = &loc_805803F;
  if ( !v0 )
    v3 = &loc_8058049;
  dword_806B270 = (int)v3;
  sub_8061A4C(v2, v1);
  return 0;
}
// 8061A4C: using guessed type int __fastcall sub_8061A4C(_DWORD, _DWORD);
// 806B270: using guessed type int dword_806B270;

//----- (080583EF) --------------------------------------------------------
void *__cdecl sub_80583EF(int a1)
{
  int v2; // [esp+1Ch] [ebp-Ch]

  if ( !*(_DWORD *)(a1 + 36) )
    return malloc(8u);
  v2 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(v2 + 4);
  return (void *)v2;
}

//----- (0805842A) --------------------------------------------------------
int __cdecl sub_805842A(int a1, _DWORD *a2)
{
  int result; // eax

  *a2 = 0;
  a2[1] = *(_DWORD *)(a1 + 36);
  result = a1;
  *(_DWORD *)(a1 + 36) = a2;
  return result;
}

//----- (0805844D) --------------------------------------------------------
int __cdecl sub_805844D(int a1, int a2, _DWORD *a3, char a4)
{
  int v4; // ecx
  _DWORD *v5; // edx
  unsigned __int8 (__cdecl *v6)(int, int); // eax
  int v7; // edx
  int v8; // ecx
  _DWORD *v9; // ecx
  int v10; // edx
  int result; // eax
  unsigned __int8 (__cdecl *v12)(int, int); // eax
  void *v13; // eax
  int v14; // [esp+4h] [ebp-34h]
  char v15; // [esp+Ch] [ebp-2Ch]
  _DWORD *v16; // [esp+18h] [ebp-20h]
  _DWORD *v17; // [esp+1Ch] [ebp-1Ch]
  int v18; // [esp+20h] [ebp-18h]
  _DWORD *v19; // [esp+24h] [ebp-14h]
  int v20; // [esp+28h] [ebp-10h]
  _DWORD *v21; // [esp+2Ch] [ebp-Ch]

  v15 = a4;
  v17 = (_DWORD *)sub_80579FD(a1, a2);
  v5 = v17;
  *a3 = v17;
  if ( !*v17 )
  {
    dword_806B2E0 = (int)&locret_80585D0;
    sub_806174E(v4, v5);
  }
  if ( *v17 == a2 || (v6 = *(unsigned __int8 (__cdecl **)(int, int))(a1 + 28), v14 = *v17, v6(a2, v14)) )
  {
    v20 = *v17;
    if ( v15 )
    {
      if ( v17[1] )
      {
        v21 = (_DWORD *)v17[1];
        v9 = v17;
        v10 = v21[1];
        *v17 = *v21;
        v9[1] = v10;
        sub_805842A(a1, v21);
      }
      else
      {
        *v17 = 0;
      }
    }
    result = v20;
  }
  else
  {
    v16 = v17;
    dword_806B298 = (int)&loc_80585BD;
    sub_8061955(v8, v7);
    while ( *(_DWORD *)v16[1] != a2 )
    {
      v12 = *(unsigned __int8 (__cdecl **)(int, int))(a1 + 28);
      v14 = *(_DWORD *)v16[1];
      if ( v12(a2, v14) )
        break;
      v16 = (_DWORD *)v16[1];
      if ( !v16[1] )
        return 0;
    }
    v18 = *(_DWORD *)v16[1];
    v13 = &loc_8058588;
    if ( !v15 )
      v13 = &loc_80585AF;
    dword_806B2CC = (int)v13;
    sub_80617DA();
    v19 = (_DWORD *)v16[1];
    v16[1] = v19[1];
    sub_805842A(a1, v19);
    result = v18;
  }
  return result;
}
// 806174E: using guessed type int __fastcall sub_806174E(_DWORD, _DWORD);
// 80617DA: using guessed type int sub_80617DA(void);
// 806B298: using guessed type int dword_806B298;
// 806B2CC: using guessed type int dword_806B2CC;
// 806B2E0: using guessed type int dword_806B2E0;

//----- (080585D2) --------------------------------------------------------
signed int __cdecl sub_80585D2(int a1, int a2, char a3)
{
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  void *v6; // eax
  char v8; // [esp+Ch] [ebp-2Ch]
  int *v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]

  v8 = a3;
  v9 = *(int **)a2;
  dword_806B2F4 = (int)&loc_8058798;
  sub_80616BF();
  do
  {
    if ( *v9 )
    {
      v10 = v9[1];
      v5 = &loc_80586A9;
      if ( v10 )
        v5 = &loc_8058615;
      dword_806B270 = (int)v5;
      sub_8061A4C(v4, v3);
      v11 = *v9;
      v9[1] = 0;
      v6 = &loc_80586DA;
      if ( !v8 )
        v6 = &loc_80586DF;
      dword_806B308 = (int)v6;
      sub_806160F();
    }
    v9 += 2;
  }
  while ( *(_DWORD *)(a2 + 4) > (unsigned int)v9 );
  return 1;
}
// 80585D2: could not find valid save-restore pair for ebx
// 806160F: using guessed type int sub_806160F(void);
// 8061A4C: using guessed type int __fastcall sub_8061A4C(_DWORD, _DWORD);
// 806B270: using guessed type int dword_806B270;
// 806B2F4: using guessed type int dword_806B2F4;
// 806B308: using guessed type int dword_806B308;

//----- (080587AE) --------------------------------------------------------
signed int __cdecl sub_80587AE(int a1, unsigned int a2)
{
  void *v3; // eax
  unsigned int nmemb; // [esp+10h] [ebp-38h]

  nmemb = sub_8057F23(a2, *(_DWORD *)(a1 + 20));
  if ( !nmemb )
    return 0;
  v3 = &loc_8058800;
  if ( *(_DWORD *)(a1 + 8) != nmemb )
    v3 = &loc_805880A;
  dword_806B2CC = (int)v3;
  sub_80617DA();
  return 1;
}
// 80617DA: using guessed type int sub_80617DA(void);
// 806B2CC: using guessed type int dword_806B2CC;

//----- (0805897C) --------------------------------------------------------
signed int __cdecl sub_805897C(unsigned int *a1, int a2, _DWORD *a3)
{
  int v3; // ecx
  signed int result; // eax
  long double v5; // fst7
  void *v6; // eax
  bool v7; // zf
  void *v8; // eax
  int *v9; // [esp+2Ch] [ebp-1Ch]
  int v10; // [esp+30h] [ebp-18h]
  unsigned int v11; // [esp+34h] [ebp-14h]
  float v12; // [esp+38h] [ebp-10h]
  void *v13; // [esp+3Ch] [ebp-Ch]

  if ( !a2 )
    abort();
  v10 = sub_805844D((int)a1, a2, &v9, 0);
  if ( v10 )
  {
    if ( a3 )
      *a3 = v10;
    result = 0;
  }
  else
  {
    if ( (long double)a1[3] > *(float *)(a1[5] + 8) * (long double)a1[2] )
    {
      sub_8057E42(0, v3, (int)a1);
      if ( (long double)a1[3] > *(float *)(a1[5] + 8) * (long double)a1[2] )
      {
        v11 = a1[5];
        if ( *(_BYTE *)(v11 + 16) )
          v5 = (long double)a1[2] * *(float *)(v11 + 12);
        else
          v5 = (long double)a1[2] * *(float *)(v11 + 12) * *(float *)(v11 + 8);
        v12 = v5;
        if ( v12 >= 4294967300.0 )
          return -1;
        if ( (unsigned __int8)sub_80587AE((int)a1, (signed __int64)v12) ^ 1 )
          return -1;
        if ( sub_805844D((int)a1, a2, &v9, 0) )
          abort();
      }
    }
    if ( *v9 )
    {
      v6 = sub_80583EF((int)a1);
      v13 = v6;
      v7 = v6 == 0;
      v8 = &loc_8058B6B;
      if ( !v7 )
        v8 = &loc_8058B72;
      dword_806B2B8 = (int)v8;
      sub_8061881();
      result = -1;
    }
    else
    {
      *v9 = a2;
      ++a1[4];
      ++a1[3];
      result = 1;
    }
  }
  return result;
}
// 8061881: using guessed type int sub_8061881(void);
// 806B2B8: using guessed type int dword_806B2B8;

//----- (08058BD2) --------------------------------------------------------
int __cdecl sub_8058BD2(unsigned int *a1, int a2)
{
  int v3; // [esp+18h] [ebp-10h]
  int v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_805897C(a1, a2, &v3);
  if ( v4 == -1 )
    return 0;
  if ( v4 )
    return a2;
  return v3;
}

//----- (08058C47) --------------------------------------------------------
int __usercall sub_8058C47@<eax>(double st7_0@<st0>, int a1, int a2)
{
  int v3; // eax
  bool v4; // zf
  void *v5; // eax
  int v6; // ecx
  long double v7; // fst7
  long double v8; // fst6
  int v9; // edx
  int v10; // ecx
  long double v11; // fst7
  long double v12; // fst6
  long double v13; // fst7
  __int16 v14; // ax
  unsigned int v16; // [esp+4h] [ebp-44h]
  __int16 v17; // [esp+14h] [ebp-34h]
  __int16 v18; // [esp+16h] [ebp-32h]
  __int64 v19; // [esp+18h] [ebp-30h]
  _DWORD *v20; // [esp+28h] [ebp-20h]
  void *ptr; // [esp+2Ch] [ebp-1Ch]
  int v22; // [esp+30h] [ebp-18h]
  int v23; // [esp+34h] [ebp-14h]
  int v24; // [esp+38h] [ebp-10h]
  int v25; // [esp+3Ch] [ebp-Ch]

  v3 = sub_805844D(a1, a2, &v20, 1);
  v22 = v3;
  v4 = v3 == 0;
  v5 = &loc_8058C90;
  if ( !v4 )
    v5 = &loc_8058CAC;
  dword_806B20C = (int)v5;
  sub_8061C98(st7_0);
  dword_806B308 = (int)&locret_8058E87;
  sub_806160F();
  --*(_DWORD *)(a1 + 16);
  if ( !*v20 )
  {
    v19 = (unsigned int)--*(_DWORD *)(a1 + 12);
    v7 = (long double)v19;
    v8 = **(float **)(a1 + 20);
    v19 = *(unsigned int *)(a1 + 8);
    if ( v8 * (long double)v19 > v7 )
    {
      sub_8057E42(0, v6, a1);
      while ( 1 )
      {
        v19 = *(unsigned int *)(a1 + 12);
        v11 = (long double)v19;
        v12 = **(float **)(a1 + 20);
        v19 = *(unsigned int *)(a1 + 8);
        if ( v12 * (long double)v19 <= v11 )
          break;
        v23 = *(_DWORD *)(a1 + 20);
        if ( *(_BYTE *)(v23 + 16) )
        {
          v19 = *(unsigned int *)(a1 + 8);
          v13 = (long double)v19 * *(float *)(v23 + 4);
        }
        else
        {
          v19 = *(unsigned int *)(a1 + 8);
          v13 = (long double)v19 * *(float *)(v23 + 4) * *(float *)(v23 + 8);
        }
        LOBYTE(v14) = v18;
        HIBYTE(v14) = 12;
        v17 = v14;
        v19 = (signed __int64)v13;
        v24 = (signed __int64)v13;
        v16 = (signed __int64)v13;
        if ( !((unsigned __int8)sub_80587AE(a1, v16) ^ 1) )
          break;
        ptr = *(void **)(a1 + 36);
        dword_806B20C = (int)&loc_8058E70;
        sub_8061C98(*(double *)&v13);
        v25 = *((_DWORD *)ptr + 1);
        free(ptr);
        dword_806B284 = (int)&loc_8058E6A;
        sub_80619DA(v10, v9);
      }
    }
  }
  return v22;
}
// 806160F: using guessed type int sub_806160F(void);
// 80619DA: using guessed type double __fastcall sub_80619DA(_DWORD, _DWORD);
// 8061C98: using guessed type int __usercall sub_8061C98@<eax>(double@<st0>);
// 806B20C: using guessed type int dword_806B20C;
// 806B284: using guessed type int dword_806B284;
// 806B308: using guessed type int dword_806B308;

//----- (08058E89) --------------------------------------------------------
_DWORD *__cdecl sub_8058E89(int (*a1)(), unsigned int a2)
{
  int (*v2)(); // eax
  _DWORD *v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_805E3F4(0x10u);
  if ( !a2 )
    a2 = 1;
  *v4 = sub_805E2D3(a2, 4u);
  *(_DWORD *)*v4 = 0;
  v4[1] = a2;
  v4[2] = 0;
  if ( a1 )
    v2 = a1;
  else
    v2 = sub_8058EFE;
  v4[3] = v2;
  return v4;
}

//----- (08058EFE) --------------------------------------------------------
int sub_8058EFE()
{
  return 0;
}

//----- (08058F08) --------------------------------------------------------
void __cdecl sub_8058F08(void *ptr)
{
  free(*(void **)ptr);
  free(ptr);
}

//----- (08058F28) --------------------------------------------------------
int __cdecl sub_8058F28(int a1, int a2)
{
  size_t v2; // edx

  if ( (unsigned int)(*(_DWORD *)(a1 + 4) - 1) <= *(_DWORD *)(a1 + 8) )
    *(_DWORD *)a1 = sub_805E34A(*(_DWORD *)a1, (unsigned int *)(a1 + 4), 4u);
  v2 = *(_DWORD *)a1;
  *(_DWORD *)(4 * ++*(_DWORD *)(a1 + 8) + v2) = a2;
  sub_805911D(*(_DWORD *)a1, *(_DWORD *)(a1 + 8), *(int (__cdecl **)(_DWORD, int))(a1 + 12));
  return 0;
}

//----- (08058FB1) --------------------------------------------------------
int __cdecl sub_8058FB1(int *a1)
{
  int v2; // ST1C_4
  _DWORD *v3; // ebx
  int v4; // esi
  int v5; // eax

  if ( !a1[2] )
    return 0;
  v2 = *(_DWORD *)(*a1 + 4);
  v3 = (_DWORD *)(*a1 + 4);
  v4 = *a1;
  v5 = a1[2];
  a1[2] = v5 - 1;
  *v3 = *(_DWORD *)(v4 + 4 * v5);
  sub_805902D(*a1, a1[2], 1u, (int (__cdecl *)(_DWORD, int))a1[3]);
  return v2;
}

//----- (0805902D) --------------------------------------------------------
unsigned int __cdecl sub_805902D(int a1, unsigned int a2, unsigned int a3, int (__cdecl *a4)(_DWORD, int))
{
  unsigned int i; // [esp+14h] [ebp-14h]
  int v6; // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]

  v7 = *(_DWORD *)(4 * a3 + a1);
  for ( i = a3; a2 >> 1 >= i; i = v6 )
  {
    v6 = 2 * i;
    if ( 2 * i < a2 && a4(*(_DWORD *)(8 * i + a1), *(_DWORD *)(4 * (2 * i + 1) + a1)) < 0 )
      ++v6;
    if ( a4(*(_DWORD *)(4 * v6 + a1), v7) <= 0 )
      break;
    *(_DWORD *)(a1 + 4 * i) = *(_DWORD *)(4 * v6 + a1);
  }
  *(_DWORD *)(a1 + 4 * i) = v7;
  return i;
}

//----- (0805911D) --------------------------------------------------------
int __cdecl sub_805911D(int a1, unsigned int a2, int (__cdecl *a3)(_DWORD, int))
{
  void *v3; // eax
  int result; // eax
  unsigned int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]

  v5 = a2;
  v6 = *(_DWORD *)(4 * a2 + a1);
  while ( 1 )
  {
    v3 = &loc_805918A;
    if ( v5 == 1 )
      v3 = &loc_80591B0;
    dword_806B2CC = (int)v3;
    sub_80617DA();
    if ( a3(*(_DWORD *)(4 * (v5 >> 1) + a1), v6) > 0 )
      break;
    *(_DWORD *)(a1 + 4 * v5) = *(_DWORD *)(4 * (v5 >> 1) + a1);
    v5 >>= 1;
  }
  result = v6;
  *(_DWORD *)(a1 + 4 * v5) = v6;
  return result;
}
// 80617DA: using guessed type int sub_80617DA(void);
// 806B2CC: using guessed type int dword_806B2CC;

//----- (080591C6) --------------------------------------------------------
void __cdecl __noreturn sub_80591C6(int a1, int a2)
{
  int v2; // ecx
  int v3; // edx
  int v4; // [esp+Ch] [ebp-4h]

  v4 = a2 + 11;
  *(_BYTE *)(a2 + 11) = 0;
  if ( a1 >= 0 )
    goto LABEL_4;
  do
  {
    *(_BYTE *)--v4 = 48 - (char)a1 % 10;
    a1 /= 10;
  }
  while ( a1 );
  while ( 1 )
  {
    *(_BYTE *)--v4 = 45;
    dword_806B248 = (int)sub_8059351;
    sub_8061B34();
    do
    {
LABEL_4:
      *(_BYTE *)--v4 = (char)a1 % 10 + 48;
      v2 = a1;
      v3 = a1 / 10;
      a1 /= 10;
    }
    while ( a1 );
    dword_806B220 = (int)sub_8059351;
    sub_8061C20(v2, v3);
  }
}
// 8059351: using guessed type int sub_8059351();
// 8061B34: using guessed type int sub_8061B34(void);
// 8061C20: using guessed type int __fastcall sub_8061C20(_DWORD, _DWORD);
// 806B220: using guessed type int dword_806B220;
// 806B248: using guessed type int dword_806B248;

//----- (08059356) --------------------------------------------------------
int __cdecl sub_8059356(unsigned int a1, int a2)
{
  int v3; // [esp+Ch] [ebp-4h]

  v3 = a2 + 10;
  *(_BYTE *)(a2 + 10) = 0;
  do
  {
    *(_BYTE *)--v3 = a1 % 0xA + 48;
    a1 /= 0xAu;
  }
  while ( a1 );
  return v3;
}

//----- (080593B4) --------------------------------------------------------
int __cdecl sub_80593B4(__int64 a1, int a2)
{
  __int64 v3; // [esp+18h] [ebp-20h]
  int v4; // [esp+2Ch] [ebp-Ch]

  v3 = a1;
  v4 = a2 + 20;
  *(_BYTE *)(a2 + 20) = 0;
  do
  {
    *(_BYTE *)--v4 = sub_806123A(v3, 10LL) + 48;
    v3 = sub_80610C0(v3, HIDWORD(v3), 10, 0);
  }
  while ( v3 );
  return v4;
}

//----- (08059467) --------------------------------------------------------
int __cdecl sub_8059467(char *a1, int a2, char a3)
{
  int v3; // edx
  int v4; // ecx
  signed int v5; // eax
  bool v6; // sf
  unsigned __int8 v7; // of
  void *v8; // eax
  int v10; // edx
  int v11; // ecx
  void *v12; // eax
  void *v13; // eax
  char *v14; // eax
  const unsigned __int16 **v15; // eax
  const unsigned __int16 **v16; // eax
  void *v17; // eax
  int v18; // edx
  int v19; // ecx
  char *v20; // [esp+1Ch] [ebp-3Ch]
  unsigned __int8 v21; // [esp+2Bh] [ebp-2Dh]
  wint_t wc; // [esp+2Ch] [ebp-2Ch]
  char *v23; // [esp+30h] [ebp-28h]
  int v24; // [esp+34h] [ebp-24h]
  int v25; // [esp+38h] [ebp-20h]
  char *v26; // [esp+3Ch] [ebp-1Ch]
  int v27; // [esp+40h] [ebp-18h]
  const mbstate_t s; // [esp+44h] [ebp-14h]
  unsigned int v29; // [esp+4Ch] [ebp-Ch]

  v20 = a1;
  v29 = __readgsdword(0x14u);
  v23 = a1;
  v26 = &a1[a2];
  v24 = 0;
  if ( __ctype_get_mb_cur_max() <= 1 )
  {
    do
    {
      while ( 1 )
      {
        if ( v23 >= v26 )
        {
          dword_806B31C = (int)&loc_805976B;
          sub_8061576(v4, v3 * 2);
          return 0x7FFFFFFF;
        }
        v14 = v23++;
        v21 = *v14;
        v15 = __ctype_b_loc();
        v3 = v21;
        if ( !((*v15)[v3] & 0x4000) )
          break;
        if ( v24 == 0x7FFFFFFF )
          return 0x7FFFFFFF;
        ++v24;
      }
      if ( a3 & 2 )
        return -1;
      v16 = __ctype_b_loc();
      v3 = v21;
    }
    while ( (*v16)[v3] & 2 );
    v17 = &loc_8059707;
    if ( v24 != 0x7FFFFFFF )
      v17 = &loc_805971E;
    dword_806B2F4 = (int)v17;
    sub_80616BF();
    dword_806B2E0 = (int)&loc_8059766;
    sub_806174E(v19, v18);
    ++v24;
    dword_806B308 = (int)&loc_8059740;
    sub_806160F();
    return -1;
  }
  while ( 1 )
  {
LABEL_34:
    if ( v23 >= v26 )
      return v24;
    v5 = *v23;
    if ( v5 <= 63 )
      break;
    if ( v5 < 65 || v5 > 95 && (unsigned int)(v5 - 97) > 0x1D )
      goto LABEL_12;
LABEL_11:
    ++v23;
    ++v24;
  }
  v7 = __OFSUB__(v5, 37);
  v6 = v5 - 37 < 0;
  v8 = &loc_80594D5;
  if ( !(v6 ^ v7) )
    v8 = &loc_80594F1;
  dword_806B220 = (int)v8;
  if ( (unsigned int)(sub_8061C20(v4, v3 * 2) - 32) <= 3 )
    goto LABEL_11;
LABEL_12:
  memset((void *)&s, 0, 8u);
  while ( 1 )
  {
    v25 = sub_805F7FA((wchar_t *)&wc, v23, v26 - v23, (mbstate_t *)&s);
    if ( v25 == -1 )
    {
      if ( !(a3 & 1) )
      {
        ++v23;
        ++v24;
        goto LABEL_34;
      }
      dword_806B2E0 = (int)&loc_805976B;
      sub_806174E(v4, v3 * 2);
    }
    if ( v25 == -2 )
      break;
    if ( !v25 )
      v25 = 1;
    v27 = wcwidth(wc);
    if ( v27 >= 0 )
    {
      v12 = &loc_80595EC;
      if ( 0x7FFFFFFF - v24 >= v27 )
        v12 = &loc_80595F1;
      dword_806B270 = (int)v12;
      sub_8061A4C(v11, v10);
      return 0x7FFFFFFF;
    }
    if ( a3 & 2 )
      return -1;
    if ( !iswcntrl(wc) )
    {
      v13 = &loc_8059634;
      if ( v24 != 0x7FFFFFFF )
        v13 = &loc_8059639;
      dword_806B2F4 = (int)v13;
      sub_80616BF();
      return 0x7FFFFFFF;
    }
    v23 += v25;
    if ( mbsinit(&s) )
      goto LABEL_34;
  }
  if ( !(a3 & 1) )
  {
    v23 = v26;
    ++v24;
    goto LABEL_34;
  }
  return -1;
}
// 8059467: could not find valid save-restore pair for ebx
// 8049800: using guessed type int __cdecl wcwidth(_DWORD);
// 8061576: using guessed type int __fastcall sub_8061576(_DWORD, _DWORD);
// 806160F: using guessed type int sub_806160F(void);
// 806174E: using guessed type int __fastcall sub_806174E(_DWORD, _DWORD);
// 8061A4C: using guessed type int __fastcall sub_8061A4C(_DWORD, _DWORD);
// 8061C20: using guessed type int __fastcall sub_8061C20(_DWORD, _DWORD);
// 806B220: using guessed type int dword_806B220;
// 806B270: using guessed type int dword_806B270;
// 806B2E0: using guessed type int dword_806B2E0;
// 806B2F4: using guessed type int dword_806B2F4;
// 806B308: using guessed type int dword_806B308;
// 806B31C: using guessed type int dword_806B31C;

//----- (0805977E) --------------------------------------------------------
int sub_805977E()
{
  int v0; // eax
  int v1; // edx
  int v2; // ecx
  bool v3; // zf
  void *v4; // eax
  int v6; // [esp+1Ch] [ebp-8Ch]
  char v7; // [esp+20h] [ebp-88h]

  if ( sched_getaffinity(0, 128, &v7) )
    return 0;
  v0 = __sched_cpucount(128, &v7);
  v6 = v0;
  v3 = v0 == 0;
  v4 = &loc_80597E7;
  if ( v3 )
    v4 = &loc_80597EF;
  dword_806B220 = (int)v4;
  sub_8061C20(v2, v1);
  return v6;
}
// 80498D0: using guessed type int __cdecl __sched_cpucount(_DWORD, _DWORD);
// 8049E70: using guessed type int __cdecl sched_getaffinity(_DWORD, _DWORD, _DWORD);
// 8061C20: using guessed type int __fastcall sub_8061C20(_DWORD, _DWORD);
// 806B220: using guessed type int dword_806B220;

//----- (080597F6) --------------------------------------------------------
signed int __cdecl sub_80597F6(int a1)
{
  int v2; // eax
  int v3; // edx
  int v4; // ecx
  int v5; // eax
  bool v6; // zf
  void *v7; // eax
  int v8; // [esp+10h] [ebp-18h]
  int v9; // [esp+14h] [ebp-14h]
  int v10; // [esp+18h] [ebp-10h]
  int v11; // [esp+1Ch] [ebp-Ch]

  if ( a1 == 1 )
  {
    v9 = sub_805977E();
    if ( v9 )
      return v9;
    v2 = sysconf(84);
    v10 = v2;
    if ( v2 > 0 )
    {
      dword_806B25C = (int)&locret_80598BF;
      sub_8061AC4(v4, v3);
    }
  }
  else
  {
    v8 = sysconf(83);
    if ( v8 == 1 )
    {
      v5 = sub_805977E();
      v11 = v5;
      v6 = v5 == 0;
      v7 = &loc_8059894;
      if ( v6 )
        v7 = &loc_805989A;
      dword_806B234 = (int)v7;
      sub_8061BAC();
      v8 = v11;
    }
    if ( v8 > 0 )
    {
      dword_806B248 = (int)&locret_80598BF;
      sub_8061B34();
    }
  }
  return 1;
}
// 8061AC4: using guessed type int __fastcall sub_8061AC4(_DWORD, _DWORD);
// 8061B34: using guessed type int sub_8061B34(void);
// 8061BAC: using guessed type int sub_8061BAC(void);
// 806B234: using guessed type int dword_806B234;
// 806B248: using guessed type int dword_806B248;
// 806B25C: using guessed type int dword_806B25C;

//----- (080598C1) --------------------------------------------------------
int __cdecl sub_80598C1(char *nptr)
{
  int result; // eax
  int v2; // edx
  int v3; // ecx
  void *v4; // eax
  char *endptr; // [esp+14h] [ebp-14h]
  int v6; // [esp+18h] [ebp-10h]
  unsigned int v7; // [esp+1Ch] [ebp-Ch]

  v6 = 0;
  if ( !nptr )
    return v6;
  while ( *nptr && (unsigned __int8)sub_80601B9(*nptr) )
    ++nptr;
  if ( !(unsigned __int8)sub_80600C8(*nptr) )
    goto LABEL_21;
  endptr = 0;
  v7 = strtoul(nptr, &endptr, 10);
  if ( !endptr )
    goto LABEL_21;
  while ( 1 )
  {
    v4 = &loc_8059973;
    if ( !*endptr )
      v4 = &loc_8059988;
    dword_806B298 = (int)v4;
    sub_8061955(v3, v2);
    if ( !(unsigned __int8)sub_80601B9(*endptr) )
      break;
    ++endptr;
  }
  if ( !*endptr )
    return v7;
  if ( *endptr == 44 )
    result = v7;
  else
LABEL_21:
    result = v6;
  return result;
}
// 806B298: using guessed type int dword_806B298;

//----- (080599AB) --------------------------------------------------------
unsigned int __cdecl sub_80599AB(int a1)
{
  char *v1; // eax
  char *v2; // eax
  int v3; // edx
  int v4; // ecx
  unsigned int result; // eax
  unsigned int v6; // [esp+14h] [ebp-14h]
  int v7; // [esp+18h] [ebp-10h]

  v6 = -1;
  if ( a1 == 2 )
  {
    v1 = getenv("OMP_NUM_THREADS");
    v7 = sub_80598C1(v1);
    v2 = getenv("OMP_THREAD_LIMIT");
    v6 = sub_80598C1(v2);
    if ( !v6 )
      v6 = -1;
    if ( v7 )
    {
      dword_806B31C = (int)&locret_8059A5B;
      sub_8061576(v4, v3);
    }
    a1 = 1;
  }
  result = sub_80597F6(a1);
  if ( v6 <= result )
    result = v6;
  return result;
}
// 8061576: using guessed type int __fastcall sub_8061576(_DWORD, _DWORD);
// 806B31C: using guessed type int dword_806B31C;

//----- (08059A5D) --------------------------------------------------------
long double sub_8059A5D()
{
  long double v1; // fst7
  int v2; // [esp+4h] [ebp-74h]
  __int64 v3; // [esp+8h] [ebp-70h]
  double v4; // [esp+18h] [ebp-60h]
  double v5; // [esp+20h] [ebp-58h]
  char v6; // [esp+2Ch] [ebp-4Ch]
  unsigned int v7; // [esp+3Ch] [ebp-3Ch]
  unsigned int v8; // [esp+60h] [ebp-18h]
  unsigned int v9; // [esp+6Ch] [ebp-Ch]

  v9 = __readgsdword(0x14u);
  v4 = (long double)sysconf(85);
  v2 = sysconf(30);
  v5 = (long double)v2;
  if ( v4 >= 0.0 && v5 >= 0.0 )
    return v4 * v5;
  if ( !sysinfo((struct sysinfo *)&v6) )
  {
    v3 = v8;
    v1 = (long double)v7 * (long double)v8;
    dword_806B20C = (int)&loc_8059B0A;
    sub_8061C98(*(double *)&v1);
  }
  return 67108864.0;
}
// 8061C98: using guessed type int __usercall sub_8061C98@<eax>(double@<st0>);
// 806B20C: using guessed type int dword_806B20C;

//----- (08059B1F) --------------------------------------------------------
void __noreturn sub_8059B1F()
{
  double v0; // ST20_8
  int v1; // edx
  int v2; // ecx
  bool v3; // zf
  void *v4; // eax
  int (*v5)(); // eax
  double v6; // [esp+20h] [ebp-58h]
  char v7; // [esp+2Ch] [ebp-4Ch]
  unsigned int v8; // [esp+6Ch] [ebp-Ch]

  v8 = __readgsdword(0x14u);
  v0 = (long double)sysconf(86);
  v6 = (long double)sysconf(30);
  if ( v0 < 0.0 || v6 < 0.0 )
  {
    v3 = sysinfo((struct sysinfo *)&v7) == 0;
    v4 = &loc_8059B81;
    if ( !v3 )
      v4 = &loc_8059C24;
    dword_806B2CC = (int)v4;
    sub_80617DA();
    v1 = 0;
  }
  v5 = (int (*)())&loc_8059C56;
  if ( __readgsdword(0x14u) == v8 )
    v5 = sub_8059C5D;
  dword_806B284 = (int)v5;
  sub_80619DA(v2, v1);
  JUMPOUT(*(_DWORD *)sub_8059C5D);
}
// 8059C5D: using guessed type int sub_8059C5D();
// 80617DA: using guessed type int sub_80617DA(void);
// 80619DA: using guessed type double __fastcall sub_80619DA(_DWORD, _DWORD);
// 806B284: using guessed type int dword_806B284;
// 806B2CC: using guessed type int dword_806B2CC;

//----- (08059C5D) --------------------------------------------------------
#error "8059C5E: positive sp value has been found (funcsize=0)"

//----- (08059C5F) --------------------------------------------------------
int __cdecl sub_8059C5F(int pipedes[2], int a2)
{
  int v2; // edx
  int v3; // ecx
  int *v4; // eax
  int v5; // edx
  int v6; // ecx
  int v8; // edx
  int v9; // ecx
  void *v10; // eax
  int v11; // ST2C_4
  int v12; // [esp+1Ch] [ebp-1Ch]
  int v13; // [esp+20h] [ebp-18h]
  int v14; // [esp+20h] [ebp-18h]
  int v15; // [esp+28h] [ebp-10h]
  int v16; // [esp+2Ch] [ebp-Ch]

  v15 = *pipedes;
  v16 = pipedes[1];
  if ( dword_806C13C >= 0 )
  {
    if ( pipe2(pipedes, a2) >= 0 || *__errno_location() != 38 )
    {
      dword_806C13C = 1;
      dword_806B298 = (int)&locret_8059F1D;
      sub_8061955(v3, v2);
    }
    dword_806C13C = -1;
  }
  if ( a2 & 0xFFF7F7FF )
  {
    v4 = __errno_location();
LABEL_15:
    *v4 = 22;
    return -1;
  }
  if ( pipe(pipedes) < 0 )
    return -1;
  if ( a2 & 0x800 )
  {
    v12 = sub_805F494(pipedes[1], 3, 0);
    if ( v12 >= 0 && sub_805F494(pipedes[1], 4, v12) != -1 && sub_805F494(*pipedes, 3, 0) >= 0 )
    {
      dword_806B25C = (int)&loc_8059CEA;
      v4 = (int *)sub_8061AC4(v9, v8);
      goto LABEL_15;
    }
  }
  else
  {
    v10 = &loc_8059E2F;
    if ( !(a2 & 0x80000) )
      v10 = &loc_8059ECD;
    dword_806B298 = (int)v10;
    sub_8061955(v6, v5);
    v13 = sub_805F494(pipedes[1], 1, 0);
    if ( v13 >= 0 && sub_805F494(pipedes[1], 2, v13 | 1) != -1 )
    {
      v14 = sub_805F494(*pipedes, 1, 0);
      if ( v14 >= 0 && sub_805F494(*pipedes, 2, v14 | 1) != -1 )
        return 0;
    }
  }
  v11 = *__errno_location();
  close(*pipedes);
  close(pipedes[1]);
  *pipedes = v15;
  pipedes[1] = v16;
  *__errno_location() = v11;
  return -1;
}
// 8049DF0: using guessed type int __cdecl pipe2(_DWORD, _DWORD);
// 8061AC4: using guessed type int __fastcall sub_8061AC4(_DWORD, _DWORD);
// 806B25C: using guessed type int dword_806B25C;
// 806B298: using guessed type int dword_806B298;
// 806C13C: using guessed type int dword_806C13C;

//----- (08059F1F) --------------------------------------------------------
int sub_8059F1F()
{
  char *endptr; // [esp+10h] [ebp-18h]
  int v2; // [esp+14h] [ebp-14h]
  char *nptr; // [esp+18h] [ebp-10h]
  int v4; // [esp+1Ch] [ebp-Ch]

  v2 = 200809;
  nptr = getenv("_POSIX2_VERSION");
  if ( nptr )
  {
    while ( *nptr )
    {
      v4 = strtol(nptr, &endptr, 10);
      if ( *endptr )
        break;
      v2 = v4;
      dword_806B248 = (int)&loc_8059F43;
      sub_8061B34();
    }
  }
  return v2;
}
// 8061B34: using guessed type int sub_8061B34(void);
// 806B248: using guessed type int dword_806B248;

//----- (08059F9E) --------------------------------------------------------
char *__cdecl sub_8059F9E(char *s)
{
  char *v1; // eax
  bool v2; // zf
  void *v3; // eax
  char *result; // eax
  char *v5; // [esp+18h] [ebp-10h]
  char *s1; // [esp+1Ch] [ebp-Ch]

  if ( !s )
  {
    fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
    abort();
  }
  v5 = strrchr(s, 47);
  if ( v5 )
    v1 = v5 + 1;
  else
    v1 = s;
  s1 = v1;
  if ( v1 - s > 6 )
  {
    v2 = strncmp(v1 - 7, "/.libs/", 7u) == 0;
    v3 = &loc_805A04C;
    if ( !v2 )
      v3 = &loc_805A0A2;
    dword_806B308 = (int)v3;
    sub_806160F();
    s = s1;
    if ( !strncmp(s1, "lt-", 3u) )
    {
      s = s1 + 3;
      program_invocation_short_name = (int)(s1 + 3);
    }
  }
  dword_806C140 = (int)s;
  result = s;
  program_invocation_name = (int)s;
  return result;
}
// 806160F: using guessed type int sub_806160F(void);
// 806B308: using guessed type int dword_806B308;
// 806B480: using guessed type int program_invocation_short_name;
// 806B490: using guessed type int program_invocation_name;
// 806C140: using guessed type int dword_806C140;

//----- (0805A16B) --------------------------------------------------------
int __cdecl sub_805A16B(int a1, unsigned __int8 a2, char a3)
{
  void *v3; // eax
  int v4; // ST18_4

  v3 = &loc_805A19E;
  if ( !a1 )
    v3 = &loc_805A1A3;
  dword_806B2F4 = (int)v3;
  sub_80616BF();
  v4 = (*(_DWORD *)(4 * (a2 >> 5) + a1 + 8) >> (a2 & 0x1F)) & 1;
  *(_DWORD *)(4 * (a2 >> 5) + a1 + 8) ^= (v4 ^ a3 & 1) << (a2 & 0x1F);
  return v4;
}
// 806B2F4: using guessed type int dword_806B2F4;

//----- (0805A247) --------------------------------------------------------
int *__cdecl sub_805A247(int *a1, int a2, int a3)
{
  int *result; // eax

  if ( !a1 )
    a1 = &dword_806C150;
  *a1 = 10;
  if ( !a2 || !a3 )
    abort();
  a1[10] = a2;
  result = a1;
  a1[11] = a3;
  return result;
}
// 806C150: using guessed type int dword_806C150;

//----- (0805A288) --------------------------------------------------------
_DWORD *__userpurge sub_805A288@<eax>(_DWORD *a1, int a2)
{
  int v3; // [esp+0h] [ebp-38h]
  int v4; // [esp+4h] [ebp-34h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]

  memset(&v3, 0, 0x30u);
  if ( a2 == 10 )
    abort();
  *a1 = a2;
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = v6;
  a1[4] = v7;
  a1[5] = v8;
  a1[6] = v9;
  a1[7] = v10;
  a1[8] = v11;
  a1[9] = v12;
  a1[10] = v13;
  a1[11] = v14;
  return a1;
}

//----- (0805A30A) --------------------------------------------------------
char *__cdecl sub_805A30A(char *msgid)
{
  char *v3; // [esp+18h] [ebp-10h]

  v3 = gettext(msgid);
  if ( v3 == msgid )
    sub_8060CA2();
  return v3;
}

//----- (0805A3CD) --------------------------------------------------------
unsigned int __cdecl sub_805A3CD(int a1, unsigned int a2, char *a3, size_t a4, char *a5, int a6, int a7, char *a8, char *a9)
{
  int v9; // edx
  int v10; // ecx
  void *v11; // eax
  void *v12; // eax
  int v13; // edx
  int v14; // ecx
  void *v15; // eax
  long double v16; // fst7
  size_t v17; // ebx
  size_t v18; // eax
  void *v19; // eax
  char v20; // al
  bool v21; // zf
  bool v22; // sf
  unsigned __int8 v23; // of
  void *v24; // eax
  void *v25; // eax
  void *v26; // eax
  void *v27; // eax
  void *v28; // eax
  void *v29; // eax
  void *v30; // eax
  void *v31; // eax
  const unsigned __int16 **v32; // eax
  int v33; // eax
  int v34; // edx
  int v35; // ecx
  void *v36; // eax
  int v37; // edx
  int v38; // ecx
  int v39; // edx
  void *v40; // eax
  int v41; // edx
  int v42; // ecx
  void *v43; // eax
  void *v44; // eax
  bool v45; // al
  void *v46; // eax
  void *v47; // eax
  unsigned int result; // eax
  void *v49; // eax
  char *v50; // [esp+4h] [ebp-84h]
  size_t v51; // [esp+8h] [ebp-80h]
  char *v52; // [esp+2Ch] [ebp-5Ch]
  char *v53; // [esp+30h] [ebp-58h]
  int v54; // [esp+34h] [ebp-54h]
  char *v55; // [esp+38h] [ebp-50h]
  int v56; // [esp+3Ch] [ebp-4Ch]
  char v57; // [esp+40h] [ebp-48h]
  bool v58; // [esp+41h] [ebp-47h]
  char v59; // [esp+42h] [ebp-46h]
  char v60; // [esp+43h] [ebp-45h]
  char v61; // [esp+44h] [ebp-44h]
  unsigned __int8 v62; // [esp+45h] [ebp-43h]
  char v63; // [esp+46h] [ebp-42h]
  char v64; // [esp+47h] [ebp-41h]
  char v65; // [esp+48h] [ebp-40h]
  bool v66; // [esp+49h] [ebp-3Fh]
  bool v67; // [esp+4Ah] [ebp-3Eh]
  bool v68; // [esp+4Bh] [ebp-3Dh]
  wint_t wc; // [esp+4Ch] [ebp-3Ch]
  int v70; // [esp+50h] [ebp-38h]
  unsigned int v71; // [esp+54h] [ebp-34h]
  unsigned int v72; // [esp+58h] [ebp-30h]
  char *s; // [esp+5Ch] [ebp-2Ch]
  size_t n; // [esp+60h] [ebp-28h]
  unsigned int v75; // [esp+64h] [ebp-24h]
  unsigned int v76; // [esp+68h] [ebp-20h]
  unsigned int v77; // [esp+6Ch] [ebp-1Ch]
  unsigned int v78; // [esp+70h] [ebp-18h]
  mbstate_t ps; // [esp+74h] [ebp-14h]
  unsigned int v80; // [esp+7Ch] [ebp-Ch]

  v56 = a1;
  v55 = a3;
  v54 = a7;
  v53 = a8;
  v52 = a9;
  v80 = __readgsdword(0x14u);
  v71 = 0;
  v72 = 0;
  s = 0;
  n = 0;
  v57 = 0;
  v68 = __ctype_get_mb_cur_max() == 1;
  v58 = (a6 & 2) != 0;
  v59 = 0;
  v60 = 0;
  v61 = 1;
  switch ( (unsigned int)a5 )
  {
    case 0u:
      v58 = 0;
      goto LABEL_27;
    case 1u:
      goto LABEL_17;
    case 2u:
      goto LABEL_20;
    case 3u:
      v57 = 1;
LABEL_17:
      v58 = 1;
      goto LABEL_18;
    case 4u:
LABEL_18:
      if ( v58 != 1 )
        v57 = 1;
LABEL_20:
      a5 = (char *)2;
      v12 = &loc_805A5A6;
      if ( v58 == 1 )
        v12 = &loc_805A5BD;
      dword_806B2B8 = (int)v12;
      sub_8061881();
      if ( v71 < a2 )
      {
        v9 = v56;
        *(_BYTE *)(v56 + v71) = 39;
      }
      ++v71;
      s = "'";
      n = 1;
      goto LABEL_27;
    case 5u:
      goto LABEL_3;
    case 6u:
      a5 = (char *)5;
      v58 = 1;
LABEL_3:
      if ( v58 != 1 )
      {
        if ( v71 < a2 )
        {
          v9 = v56;
          *(_BYTE *)(v56 + v71) = 34;
        }
        ++v71;
      }
      v57 = 1;
      s = (char *)&unk_806444D;
      n = 1;
      goto LABEL_27;
    case 7u:
      v57 = 1;
      v58 = 0;
      dword_806B298 = (int)&loc_805A5D8;
      sub_8061955(v10, v9);
      break;
    case 8u:
    case 9u:
    case 0xAu:
      break;
    default:
      abort();
      return result;
  }
  if ( a5 != (char *)10 )
  {
    v53 = sub_805A30A("`");
    v50 = a5;
    v52 = sub_805A30A("'");
  }
  if ( v58 != 1 )
  {
    s = v53;
    v11 = &loc_805A54A;
    if ( *v53 )
      v11 = &loc_805A507;
    dword_806B2F4 = (int)v11;
    sub_80616BF();
  }
  v57 = 1;
  s = v52;
  n = strlen(v52);
LABEL_27:
  v70 = 0;
  dword_806B31C = (int)&loc_805B0AF;
  sub_8061576(v10, v9);
  while ( 2 )
  {
    v64 = 0;
    v65 = 0;
    v66 = 0;
    v15 = &loc_805A621;
    if ( !v57 )
      v15 = &loc_805A68D;
    dword_806B284 = (int)v15;
    v16 = sub_80619DA(v14, v13);
    if ( a5 != (char *)2 && n )
    {
      v17 = v70 + n;
      if ( a4 != -1 || n <= 1 )
      {
        v18 = a4;
      }
      else
      {
        v18 = strlen(v55);
        a4 = v18;
      }
      if ( v17 <= v18 && !memcmp(&v55[v70], s, n) )
      {
        if ( v58 )
          goto LABEL_244;
        v64 = 1;
      }
    }
    v13 = (int)v55;
    v62 = v55[v70];
    switch ( v62 )
    {
      case 0u:
        if ( v57 )
        {
          if ( v58 )
            goto LABEL_244;
          v65 = 1;
          if ( a5 == (char *)2 )
          {
            v19 = &loc_805A6F4;
            if ( v59 == 1 )
              v19 = &loc_805A73D;
            dword_806B2CC = (int)v19;
            sub_80617DA();
            if ( v71 < a2 )
            {
              v13 = v56;
              *(_BYTE *)(v56 + v71) = 39;
            }
            if ( ++v71 < a2 )
            {
              v13 = v56;
              *(_BYTE *)(v56 + v71) = 36;
            }
            if ( ++v71 < a2 )
            {
              v13 = v56;
              *(_BYTE *)(v56 + v71) = 39;
            }
            ++v71;
            v59 = 1;
          }
          if ( v71 < a2 )
          {
            v13 = v56;
            *(_BYTE *)(v56 + v71) = 92;
          }
          ++v71;
          if ( a5 != (char *)2 && v70 + 1 < a4 )
          {
            v20 = v55[v70 + 1];
            v23 = __OFSUB__(v20, 47);
            v21 = v20 == 47;
            v22 = (char)(v20 - 47) < 0;
            v24 = &loc_805A790;
            if ( (unsigned __int8)(v22 ^ v23) | v21 )
              v24 = &loc_805A7D0;
            dword_806B2F4 = (int)v24;
            sub_80616BF();
            v13 = v70 + 1;
            if ( v55[v70 + 1] <= 57 )
            {
              if ( v71 < a2 )
              {
                v13 = v56;
                *(_BYTE *)(v56 + v71) = 48;
              }
              if ( ++v71 < a2 )
              {
                v13 = v56;
                *(_BYTE *)(v56 + v71) = 48;
              }
              ++v71;
            }
          }
          v62 = 48;
        }
        else if ( a6 & 1 )
        {
          goto LABEL_221;
        }
        goto LABEL_191;
      case 7u:
        v63 = 97;
        dword_806B2CC = (int)&loc_805A9F1;
        sub_80617DA();
        goto LABEL_83;
      case 8u:
LABEL_83:
        v63 = 98;
        goto LABEL_98;
      case 9u:
        goto LABEL_87;
      case 0xAu:
        v63 = 110;
        goto LABEL_96;
      case 0xBu:
        v63 = 118;
        dword_806B270 = (int)&loc_805A9F1;
        sub_8061A4C(v14, v55);
        goto LABEL_89;
      case 0xCu:
        v63 = 102;
        goto LABEL_98;
      case 0xDu:
        v63 = 114;
        dword_806B220 = (int)&loc_805A9E0;
        sub_8061C20(v14, v55);
LABEL_87:
        v63 = 116;
        goto LABEL_96;
      case 0x20u:
        goto LABEL_106;
      case 0x21u:
      case 0x22u:
      case 0x24u:
      case 0x26u:
      case 0x28u:
      case 0x29u:
      case 0x2Au:
      case 0x3Bu:
      case 0x3Cu:
      case 0x3Du:
      case 0x3Eu:
      case 0x5Bu:
      case 0x5Eu:
      case 0x60u:
      case 0x7Cu:
        goto LABEL_107;
      case 0x23u:
      case 0x7Eu:
        goto LABEL_104;
      case 0x25u:
      case 0x2Bu:
      case 0x2Cu:
      case 0x2Du:
      case 0x2Eu:
      case 0x2Fu:
      case 0x30u:
      case 0x31u:
      case 0x32u:
      case 0x33u:
      case 0x34u:
      case 0x35u:
      case 0x36u:
      case 0x37u:
      case 0x38u:
      case 0x39u:
      case 0x3Au:
      case 0x41u:
      case 0x42u:
      case 0x43u:
      case 0x44u:
      case 0x45u:
      case 0x46u:
      case 0x47u:
      case 0x48u:
      case 0x49u:
      case 0x4Au:
      case 0x4Bu:
      case 0x4Cu:
      case 0x4Du:
      case 0x4Eu:
      case 0x4Fu:
      case 0x50u:
      case 0x51u:
      case 0x52u:
      case 0x53u:
      case 0x54u:
      case 0x55u:
      case 0x56u:
      case 0x57u:
      case 0x58u:
      case 0x59u:
      case 0x5Au:
      case 0x5Du:
      case 0x5Fu:
      case 0x61u:
      case 0x62u:
      case 0x63u:
      case 0x64u:
      case 0x65u:
      case 0x66u:
      case 0x67u:
      case 0x68u:
      case 0x69u:
      case 0x6Au:
      case 0x6Bu:
      case 0x6Cu:
      case 0x6Du:
      case 0x6Eu:
      case 0x6Fu:
      case 0x70u:
      case 0x71u:
      case 0x72u:
      case 0x73u:
      case 0x74u:
      case 0x75u:
      case 0x76u:
      case 0x77u:
      case 0x78u:
      case 0x79u:
      case 0x7Au:
        v66 = 1;
        goto LABEL_191;
      case 0x27u:
        v60 = 1;
        v66 = 1;
        v30 = &loc_805AAFB;
        if ( a5 != (char *)2 )
          v30 = &loc_805AB86;
        dword_806B2E0 = (int)v30;
        sub_806174E(v14, v55);
        if ( v58 )
          goto LABEL_244;
        if ( a2 )
        {
          v31 = &loc_805AB2B;
          if ( v72 )
            v31 = &loc_805AB38;
          dword_806B2CC = (int)v31;
          sub_80617DA();
          v72 = a2;
          a2 = 0;
        }
        if ( v71 < a2 )
        {
          v13 = v56;
          *(_BYTE *)(v56 + v71) = 39;
        }
        if ( ++v71 < a2 )
        {
          v13 = v56;
          *(_BYTE *)(v56 + v71) = 92;
        }
        if ( ++v71 < a2 )
        {
          v13 = v56;
          *(_BYTE *)(v56 + v71) = 39;
        }
        ++v71;
        v59 = 0;
        goto LABEL_191;
      case 0x3Fu:
        if ( a5 == (char *)2 )
        {
          if ( v58 )
            goto LABEL_244;
        }
        else if ( a5 == (char *)5 )
        {
          v25 = &loc_805A82F;
          if ( !(a6 & 4) )
            v25 = &loc_805A911;
          dword_806B308 = (int)v25;
          sub_806160F();
          if ( v70 + 2 < a4 )
          {
            v13 = v70 + 1;
            if ( v55[v70 + 1] == 63 )
            {
              v13 = v70 + 2;
              switch ( v55[v70 + 2] )
              {
                case 33:
                case 39:
                case 40:
                case 41:
                case 45:
                case 47:
                case 60:
                case 61:
                case 62:
                  v26 = &loc_805A899;
                  if ( !v58 )
                    v26 = &loc_805A89E;
                  dword_806B2E0 = (int)v26;
                  sub_806174E(v14, v13);
                  goto LABEL_244;
                default:
                  break;
              }
            }
          }
        }
LABEL_191:
        if ( (v57 != 1 || a5 == (char *)2) && v58 != 1
          || !v54
          || (v14 = v62 & 0x1F, v13 = *(_DWORD *)(4 * (v62 >> 5) + v54) >> v14, !(v13 & 1)) )
        {
          if ( v64 != 1 )
            goto LABEL_210;
        }
LABEL_197:
        if ( !v58 )
        {
          v65 = 1;
          if ( a5 == (char *)2 && v59 != 1 )
          {
            if ( v71 < a2 )
            {
              v13 = v56;
              *(_BYTE *)(v56 + v71) = 39;
            }
            if ( ++v71 < a2 )
            {
              v13 = v56;
              *(_BYTE *)(v56 + v71) = 36;
            }
            if ( ++v71 < a2 )
            {
              v13 = v56;
              *(_BYTE *)(v56 + v71) = 39;
            }
            ++v71;
            v59 = 1;
          }
          if ( v71 < a2 )
          {
            v13 = v56;
            *(_BYTE *)(v56 + v71) = 92;
          }
          ++v71;
LABEL_210:
          if ( v59 && v65 != 1 )
          {
            if ( v71 < a2 )
            {
              v13 = v56;
              *(_BYTE *)(v56 + v71) = 39;
            }
            if ( ++v71 < a2 )
            {
              v13 = v56;
              *(_BYTE *)(v56 + v71) = 39;
            }
            ++v71;
            v59 = 0;
          }
          if ( v71 < a2 )
          {
            v13 = v71 + v56;
            *(_BYTE *)(v71 + v56) = v62;
          }
          ++v71;
          if ( v66 != 1 )
            v61 = 0;
LABEL_221:
          ++v70;
          if ( a4 == -1 )
          {
            v13 = (int)v55;
            v45 = v55[v70] != 0;
          }
          else
          {
            v45 = v70 != a4;
          }
          if ( !v45 )
          {
            if ( !v71 )
            {
              v46 = &loc_805B0FD;
              if ( a5 != (char *)2 )
                v46 = &loc_805B11A;
              dword_806B308 = (int)v46;
              sub_806160F();
              if ( v58 )
              {
                dword_806B220 = (int)&loc_805B231;
                sub_8061C20(v14, v13);
              }
            }
            if ( a5 == (char *)2 && v58 != 1 && v60 )
            {
              v47 = &loc_805B15C;
              if ( !v61 )
                v47 = &loc_805B1A5;
              dword_806B220 = (int)v47;
              sub_8061C20(v14, v13);
              result = sub_805A3CD(v56, v72, v55, a4, (char *)5, a6, v54, v53, v52);
            }
            else
            {
              if ( s && v58 != 1 )
              {
                v49 = &loc_805B219;
                if ( *s )
                  v49 = &loc_805B1D6;
                dword_806B2F4 = (int)v49;
                sub_80616BF();
              }
              if ( v71 < a2 )
                *(_BYTE *)(v56 + v71) = 0;
              result = v71;
            }
            return result;
          }
          continue;
        }
LABEL_244:
        if ( a5 == (char *)2 && v57 )
          a5 = (char *)4;
        return sub_805A3CD(v56, a2, v55, a4, a5, a6 & 0xFFFFFFFD, 0, v53, v52);
      case 0x5Cu:
LABEL_89:
        v63 = v62;
        if ( a5 != (char *)2 )
          goto LABEL_92;
        if ( v58 )
          goto LABEL_244;
        dword_806B2B8 = (int)&loc_805B03F;
        sub_8061881();
LABEL_92:
        if ( v57 && v58 && n )
        {
          dword_806B234 = (int)&loc_805B03F;
          sub_8061BAC();
        }
LABEL_96:
        if ( a5 == (char *)2 && v58 )
          goto LABEL_244;
LABEL_98:
        v27 = &loc_805AA10;
        if ( !v57 )
          v27 = &loc_805AA1C;
        dword_806B270 = (int)v27;
        sub_8061A4C(v14, v13);
        v62 = v63;
        goto LABEL_197;
      case 0x7Bu:
      case 0x7Du:
        v28 = &loc_805AA52;
        if ( a4 != -1 )
          v28 = &loc_805AA62;
        dword_806B234 = (int)v28;
        sub_8061BAC();
        if ( !v55[1] )
        {
LABEL_104:
          if ( v70 )
          {
            dword_806B2B8 = (int)&loc_805AF61;
            sub_8061881();
          }
LABEL_106:
          v66 = 1;
LABEL_107:
          v29 = &loc_805AAB2;
          if ( a5 != (char *)2 )
            v29 = &loc_805AACF;
          dword_806B270 = (int)v29;
          sub_8061A4C(v14, v13);
          if ( v58 )
          {
            dword_806B284 = (int)&loc_805B231;
            sub_80619DA(v14, v13);
          }
        }
        goto LABEL_191;
      default:
        if ( v68 )
        {
          v75 = 1;
          v32 = __ctype_b_loc();
          v13 = 2 * v62;
          v67 = (*(const unsigned __int16 *)((char *)*v32 + v13) & 0x4000) != 0;
          goto LABEL_152;
        }
        memset(&ps, 0, 8u);
        v75 = 0;
        v67 = 1;
        if ( a4 == -1 )
          a4 = strlen(v55);
        do
        {
          v51 = a4 - (v75 + v70);
          v50 = &v55[v75 + v70];
          v33 = sub_805F7FA((wchar_t *)&wc, v50, v51, &ps);
          v77 = v33;
          v21 = v33 == 0;
          v36 = &loc_805AC5A;
          if ( !v21 )
            v36 = &loc_805AC71;
          dword_806B220 = (int)v36;
          sub_8061C20(v35, v34);
          dword_806B2E0 = (int)&loc_805AD87;
          sub_806174E(v38, v37);
          if ( v77 == -1 )
          {
            v67 = 0;
            goto LABEL_152;
          }
          if ( v77 == -2 )
          {
            v67 = 0;
            while ( 1 )
            {
              v39 = v70;
              if ( v70 + v75 >= a4 )
                break;
              v39 = v75 + v70;
              if ( !v55[v75 + v70] )
                break;
              ++v75;
            }
            dword_806B220 = (int)&loc_805AD87;
            sub_8061C20(v14, v39);
          }
          if ( v58 )
          {
            v40 = &loc_805ACED;
            if ( a5 != (char *)2 )
              v40 = &loc_805AD2B;
            dword_806B308 = (int)v40;
            sub_806160F();
            v76 = 1;
            while ( v76 < v77 )
            {
              switch ( v55[v76 + v75 + v70] )
              {
                case 91:
                case 92:
                case 94:
                case 96:
                case 124:
                  goto LABEL_244;
                default:
                  ++v76;
                  break;
              }
            }
          }
          v21 = iswprint(wc) == 0;
          v43 = &loc_805AD53;
          if ( !v21 )
            v43 = &loc_805AD57;
          dword_806B2E0 = (int)v43;
          sub_806174E(v42, v41);
          v67 = 0;
          v75 += v77;
        }
        while ( !mbsinit(&ps) );
        dword_806B20C = (int)&loc_805AD87;
        sub_8061C98(*(double *)&v16);
LABEL_152:
        v66 = v67;
        if ( v75 <= 1 && (!v57 || v67 == 1) )
          goto LABEL_191;
        v13 = v70;
        v78 = v70 + v75;
        while ( 1 )
        {
          if ( v57 && v67 != 1 )
          {
            if ( v58 )
              goto LABEL_244;
            v65 = 1;
            v44 = &loc_805ADFF;
            if ( a5 != (char *)2 )
              v44 = &loc_805AE53;
            dword_806B2F4 = (int)v44;
            sub_80616BF();
            if ( v59 != 1 )
            {
              if ( v71 < a2 )
              {
                v13 = v56;
                *(_BYTE *)(v56 + v71) = 39;
              }
              if ( ++v71 < a2 )
              {
                v13 = v56;
                *(_BYTE *)(v56 + v71) = 36;
              }
              if ( ++v71 < a2 )
              {
                v13 = v56;
                *(_BYTE *)(v56 + v71) = 39;
              }
              ++v71;
              v59 = 1;
            }
            if ( v71 < a2 )
            {
              v13 = v56;
              *(_BYTE *)(v56 + v71) = 92;
            }
            if ( ++v71 < a2 )
            {
              v13 = v71 + v56;
              *(_BYTE *)(v71 + v56) = (v62 >> 6) + 48;
            }
            if ( ++v71 < a2 )
            {
              v13 = v71 + v56;
              *(_BYTE *)(v71 + v56) = ((v62 >> 3) & 7) + 48;
            }
            ++v71;
            v62 = (v62 & 7) + 48;
          }
          else if ( v64 )
          {
            if ( v71 < a2 )
            {
              v13 = v56;
              *(_BYTE *)(v56 + v71) = 92;
            }
            ++v71;
            v64 = 0;
          }
          if ( v70 + 1 >= v78 )
            goto LABEL_210;
          if ( v59 && v65 != 1 )
          {
            if ( v71 < a2 )
              *(_BYTE *)(v56 + v71) = 39;
            if ( ++v71 < a2 )
              *(_BYTE *)(v56 + v71) = 39;
            ++v71;
            v59 = 0;
          }
          if ( v71 < a2 )
            *(_BYTE *)(v71 + v56) = v62;
          ++v71;
          ++v70;
          v13 = (int)v55;
          v62 = v55[v70];
        }
    }
  }
}
// 8061576: using guessed type int __fastcall sub_8061576(_DWORD, _DWORD);
// 806160F: using guessed type int sub_806160F(void);
// 806174E: using guessed type int __fastcall sub_806174E(_DWORD, _DWORD);
// 80617DA: using guessed type int sub_80617DA(void);
// 8061881: using guessed type int sub_8061881(void);
// 80619DA: using guessed type double __fastcall sub_80619DA(_DWORD, _DWORD);
// 8061A4C: using guessed type int __fastcall sub_8061A4C(_DWORD, _DWORD);
// 8061BAC: using guessed type int sub_8061BAC(void);
// 8061C20: using guessed type int __fastcall sub_8061C20(_DWORD, _DWORD);
// 8061C98: using guessed type int __usercall sub_8061C98@<eax>(double@<st0>);
// 806B20C: using guessed type int dword_806B20C;
// 806B220: using guessed type int dword_806B220;
// 806B234: using guessed type int dword_806B234;
// 806B270: using guessed type int dword_806B270;
// 806B284: using guessed type int dword_806B284;
// 806B298: using guessed type int dword_806B298;
// 806B2B8: using guessed type int dword_806B2B8;
// 806B2CC: using guessed type int dword_806B2CC;
// 806B2E0: using guessed type int dword_806B2E0;
// 806B2F4: using guessed type int dword_806B2F4;
// 806B308: using guessed type int dword_806B308;
// 806B31C: using guessed type int dword_806B31C;

//----- (0805B35B) --------------------------------------------------------
void *__cdecl sub_805B35B(char *a1, size_t a2, _DWORD *a3, int *a4)
{
  int *v4; // eax
  int *v5; // ST44_4
  int v6; // ST4C_4
  int v7; // ecx
  void *v8; // eax
  int v10; // [esp+40h] [ebp-18h]
  unsigned int size; // [esp+48h] [ebp-10h]
  void *ptr; // [esp+4Ch] [ebp-Ch]

  if ( a4 )
    v4 = a4;
  else
    v4 = &dword_806C150;
  v5 = v4;
  v10 = *__errno_location();
  v6 = v5[1] | (a3 == 0);
  size = sub_805A3CD(0, 0, a1, a2, (char *)*v5, v6, (int)(v5 + 2), (char *)v5[10], (char *)v5[11]) + 1;
  ptr = sub_805E3E1(size);
  sub_805A3CD((int)ptr, size, a1, a2, (char *)*v5, v6, (int)(v5 + 2), (char *)v5[10], (char *)v5[11]);
  *__errno_location() = v10;
  v8 = &loc_805B484;
  if ( !a3 )
    v8 = &loc_805B48F;
  dword_806B25C = (int)v8;
  sub_8061AC4(v7, v10);
  *a3 = size - 1;
  return ptr;
}
// 8061AC4: using guessed type int __fastcall sub_8061AC4(_DWORD, _DWORD);
// 806B25C: using guessed type int dword_806B25C;
// 806C150: using guessed type int dword_806C150;

//----- (0805B53F) --------------------------------------------------------
void *__cdecl sub_805B53F(signed int a1, char *a2, size_t a3, int a4)
{
  int v5; // ecx
  void *v6; // eax
  size_t v7; // edx
  void *v8; // edx
  size_t v9; // ST4C_4
  bool v11; // [esp+37h] [ebp-21h]
  int *v12; // [esp+38h] [ebp-20h]
  void *ptr; // [esp+3Ch] [ebp-1Ch]
  int v14; // [esp+40h] [ebp-18h]
  int size; // [esp+44h] [ebp-14h]
  int v16; // [esp+48h] [ebp-10h]
  unsigned int v17; // [esp+4Ch] [ebp-Ch]

  v14 = *__errno_location();
  v12 = off_806B41C;
  if ( a1 < 0 )
    abort();
  if ( dword_806B410 <= a1 )
  {
    v11 = off_806B41C == &dword_806B414;
    if ( (unsigned int)a1 > 0xFFFFFFE )
      sub_805E5AE();
    v6 = &loc_805B5B9;
    if ( !v11 )
      v6 = &loc_805B5C0;
    dword_806B270 = (int)v6;
    sub_8061A4C(v5, 8 * (a1 + 1));
    v12 = (int *)sub_805E447(0, v7);
    off_806B41C = v12;
    if ( v11 )
    {
      v8 = off_806B418;
      *v12 = dword_806B414;
      v12[1] = (int)v8;
    }
    memset(&v12[2 * dword_806B410], 0, 8 * (a1 + 1 - dword_806B410));
    dword_806B410 = a1 + 1;
  }
  v9 = v12[2 * a1];
  ptr = (void *)v12[2 * a1 + 1];
  v16 = *(_DWORD *)(a4 + 4) | 1;
  v17 = sub_805A3CD(
          v12[2 * a1 + 1],
          v12[2 * a1],
          a2,
          a3,
          *(char **)a4,
          v16,
          a4 + 8,
          *(char **)(a4 + 40),
          *(char **)(a4 + 44));
  if ( v9 <= v17 )
  {
    size = v17 + 1;
    v12[2 * a1] = v17 + 1;
    if ( ptr != &unk_806C190 )
      free(ptr);
    ptr = sub_805E3E1(size);
    v12[2 * a1 + 1] = (int)ptr;
    sub_805A3CD((int)ptr, size, a2, a3, *(char **)a4, v16, a4 + 8, *(char **)(a4 + 40), *(char **)(a4 + 44));
  }
  *__errno_location() = v14;
  return ptr;
}
// 8061A4C: using guessed type int __fastcall sub_8061A4C(_DWORD, _DWORD);
// 806B270: using guessed type int dword_806B270;
// 806B410: using guessed type int dword_806B410;
// 806B414: using guessed type int dword_806B414;
// 806B418: using guessed type void *off_806B418;
// 806B41C: using guessed type int *off_806B41C;

//----- (0805B781) --------------------------------------------------------
void *__cdecl sub_805B781(signed int a1, char *a2)
{
  return sub_805B53F(a1, a2, 0xFFFFFFFF, (int)&dword_806C150);
}
// 806C150: using guessed type int dword_806C150;

//----- (0805B7AB) --------------------------------------------------------
void *__cdecl sub_805B7AB(signed int a1, char *a2, size_t a3)
{
  return sub_805B53F(a1, a2, a3, (int)&dword_806C150);
}
// 806C150: using guessed type int dword_806C150;

//----- (0805B839) --------------------------------------------------------
void *__cdecl sub_805B839(signed int a2, int a3, char *a4)
{
  char v5; // [esp+10h] [ebp-38h]

  sub_805A288(&v5, a3);
  return sub_805B53F(a2, a4, 0xFFFFFFFF, (int)&v5);
}

//----- (0805B877) --------------------------------------------------------
void *__cdecl sub_805B877(signed int a2, int a3, char *a4, size_t a5)
{
  char v6; // [esp+10h] [ebp-38h]

  sub_805A288(&v6, a3);
  return sub_805B53F(a2, a4, a5, (int)&v6);
}

//----- (0805B8B4) --------------------------------------------------------
void *__cdecl sub_805B8B4(int a2, char *a3)
{
  return sub_805B839(0, a2, a3);
}

//----- (0805B919) --------------------------------------------------------
void *__cdecl sub_805B919(int a1, char *a2, size_t a3)
{
  return sub_805B877(0, a1, a2, a3);
}

//----- (0805B944) --------------------------------------------------------
void *__cdecl sub_805B944(char *a1, size_t a2, unsigned __int8 a3)
{
  int v5; // [esp+20h] [ebp-38h]
  int v6; // [esp+24h] [ebp-34h]
  int v7; // [esp+28h] [ebp-30h]
  int v8; // [esp+2Ch] [ebp-2Ch]
  int v9; // [esp+30h] [ebp-28h]
  int v10; // [esp+34h] [ebp-24h]
  int v11; // [esp+38h] [ebp-20h]
  int v12; // [esp+3Ch] [ebp-1Ch]
  int v13; // [esp+40h] [ebp-18h]
  int v14; // [esp+44h] [ebp-14h]
  int v15; // [esp+48h] [ebp-10h]
  int v16; // [esp+4Ch] [ebp-Ch]

  v5 = dword_806C150;
  v6 = dword_806C154;
  v7 = dword_806C158;
  v8 = dword_806C15C;
  v9 = dword_806C160;
  v10 = dword_806C164;
  v11 = dword_806C168;
  v12 = dword_806C16C;
  v13 = dword_806C170;
  v14 = dword_806C174;
  v15 = dword_806C178;
  v16 = dword_806C17C;
  sub_805A16B((int)&v5, a3, 1);
  return sub_805B53F(0, a1, a2, (int)&v5);
}
// 806C150: using guessed type int dword_806C150;
// 806C154: using guessed type int dword_806C154;
// 806C158: using guessed type int dword_806C158;
// 806C15C: using guessed type int dword_806C15C;
// 806C160: using guessed type int dword_806C160;
// 806C164: using guessed type int dword_806C164;
// 806C168: using guessed type int dword_806C168;
// 806C16C: using guessed type int dword_806C16C;
// 806C170: using guessed type int dword_806C170;
// 806C174: using guessed type int dword_806C174;
// 806C178: using guessed type int dword_806C178;
// 806C17C: using guessed type int dword_806C17C;

//----- (0805B9EE) --------------------------------------------------------
void *__cdecl sub_805B9EE(char *a1, unsigned __int8 a2)
{
  return sub_805B944(a1, 0xFFFFFFFF, a2);
}

//----- (0805BA17) --------------------------------------------------------
void *__cdecl sub_805BA17(char *a1)
{
  return sub_805B9EE(a1, 0x3Au);
}

//----- (0805BA91) --------------------------------------------------------
void *__cdecl sub_805BA91(signed int a1, int a2, char *a3)
{
  int v5; // [esp+10h] [ebp-68h]
  int v6; // [esp+14h] [ebp-64h]
  int v7; // [esp+18h] [ebp-60h]
  int v8; // [esp+1Ch] [ebp-5Ch]
  int v9; // [esp+20h] [ebp-58h]
  int v10; // [esp+24h] [ebp-54h]
  int v11; // [esp+28h] [ebp-50h]
  int v12; // [esp+2Ch] [ebp-4Ch]
  int v13; // [esp+30h] [ebp-48h]
  int v14; // [esp+34h] [ebp-44h]
  int v15; // [esp+38h] [ebp-40h]
  int v16; // [esp+3Ch] [ebp-3Ch]
  int v17; // [esp+40h] [ebp-38h]
  int v18; // [esp+44h] [ebp-34h]
  int v19; // [esp+48h] [ebp-30h]
  int v20; // [esp+4Ch] [ebp-2Ch]
  int v21; // [esp+50h] [ebp-28h]
  int v22; // [esp+54h] [ebp-24h]
  int v23; // [esp+58h] [ebp-20h]
  int v24; // [esp+5Ch] [ebp-1Ch]
  int v25; // [esp+60h] [ebp-18h]
  int v26; // [esp+64h] [ebp-14h]
  int v27; // [esp+68h] [ebp-10h]
  int v28; // [esp+6Ch] [ebp-Ch]

  sub_805A288(&v5, a2);
  v17 = v5;
  v18 = v6;
  v19 = v7;
  v20 = v8;
  v21 = v9;
  v22 = v10;
  v23 = v11;
  v24 = v12;
  v25 = v13;
  v26 = v14;
  v27 = v15;
  v28 = v16;
  sub_805A16B((int)&v17, 0x3Au, 1);
  return sub_805B53F(a1, a3, 0xFFFFFFFF, (int)&v17);
}

//----- (0805BB32) --------------------------------------------------------
void *__cdecl sub_805BB32(signed int a1, int a2, int a3, char *a4)
{
  return sub_805BB62(a1, a2, a3, a4, 0xFFFFFFFF);
}

//----- (0805BB62) --------------------------------------------------------
void *__cdecl sub_805BB62(signed int a1, int a2, int a3, char *a4, size_t a5)
{
  int v6; // [esp+10h] [ebp-38h]
  int v7; // [esp+14h] [ebp-34h]
  int v8; // [esp+18h] [ebp-30h]
  int v9; // [esp+1Ch] [ebp-2Ch]
  int v10; // [esp+20h] [ebp-28h]
  int v11; // [esp+24h] [ebp-24h]
  int v12; // [esp+28h] [ebp-20h]
  int v13; // [esp+2Ch] [ebp-1Ch]
  int v14; // [esp+30h] [ebp-18h]
  int v15; // [esp+34h] [ebp-14h]
  int v16; // [esp+38h] [ebp-10h]
  int v17; // [esp+3Ch] [ebp-Ch]

  v6 = dword_806C150;
  v7 = dword_806C154;
  v8 = dword_806C158;
  v9 = dword_806C15C;
  v10 = dword_806C160;
  v11 = dword_806C164;
  v12 = dword_806C168;
  v13 = dword_806C16C;
  v14 = dword_806C170;
  v15 = dword_806C174;
  v16 = dword_806C178;
  v17 = dword_806C17C;
  sub_805A247(&v6, a2, a3);
  return sub_805B53F(a1, a4, a5, (int)&v6);
}
// 806C150: using guessed type int dword_806C150;
// 806C154: using guessed type int dword_806C154;
// 806C158: using guessed type int dword_806C158;
// 806C15C: using guessed type int dword_806C15C;
// 806C160: using guessed type int dword_806C160;
// 806C164: using guessed type int dword_806C164;
// 806C168: using guessed type int dword_806C168;
// 806C16C: using guessed type int dword_806C16C;
// 806C170: using guessed type int dword_806C170;
// 806C174: using guessed type int dword_806C174;
// 806C178: using guessed type int dword_806C178;
// 806C17C: using guessed type int dword_806C17C;

//----- (0805BC5C) --------------------------------------------------------
void *__cdecl sub_805BC5C(signed int a1, char *a2, size_t a3)
{
  return sub_805B53F(a1, a2, a3, (int)&unk_806B430);
}

//----- (0805BCCF) --------------------------------------------------------
void *__cdecl sub_805BCCF(signed int a1, char *a2)
{
  return sub_805BC5C(a1, a2, 0xFFFFFFFF);
}

//----- (0805BCF1) --------------------------------------------------------
void *__cdecl sub_805BCF1(char *a1)
{
  return sub_805BCCF(0, a1);
}

//----- (0805BD0C) --------------------------------------------------------
void __cdecl __noreturn sub_805BD0C(char *a2)
{
  void *v2; // esi
  char *v3; // ebx
  int v4; // edx
  void *v5; // [esp+Ch] [ebp-Ch]

  if ( a2 )
  {
    v2 = sub_805BCF1(a2);
    if ( !*__errno_location() )
    {
      gettext("%s: end of file");
      dword_806B234 = (int)&loc_805BD6D;
      sub_8061BAC();
    }
    v3 = gettext("%s: read error");
    v4 = *__errno_location();
    v5 = v2;
    error(status, v4, v3, v2);
  }
  abort();
}
// 8061BAC: using guessed type int sub_8061BAC(void);
// 806B234: using guessed type int dword_806B234;

//----- (0805BD92) --------------------------------------------------------
_DWORD *__cdecl sub_805BD92(int a1, int a2)
{
  _DWORD *result; // eax

  result = sub_805E3F4(0x81Cu);
  *result = a1;
  result[1] = sub_805BD0C;
  result[2] = a2;
  return result;
}

//----- (0805BDC7) --------------------------------------------------------
unsigned int __cdecl sub_805BDC7(int a1, int a2, size_t nbytes)
{
  size_t v3; // eax
  int v4; // eax
  size_t n; // ST24_4
  int v6; // eax
  size_t v7; // ST28_4
  int v8; // eax
  size_t v9; // ST2C_4
  int v10; // eax
  size_t v11; // ST30_4
  unsigned int result; // eax
  int v13; // eax
  size_t v14; // ST34_4
  unsigned int v15; // [esp+18h] [ebp-30h]
  int fd; // [esp+20h] [ebp-28h]
  struct timeval tv; // [esp+38h] [ebp-10h]

  v15 = 0;
  fd = open64("/dev/urandom", 0);
  if ( fd >= 0 )
  {
    v3 = a2;
    if ( nbytes <= a2 )
      v3 = nbytes;
    v15 = read(fd, (void *)a1, v3);
    if ( (v15 & 0x80000000) != 0 )
      v15 = 0;
    close(fd);
  }
  if ( v15 < a2 )
  {
    v4 = a2 - v15;
    if ( a2 - v15 > 8 )
      v4 = 8;
    n = v4;
    gettimeofday(&tv, 0);
    memcpy((void *)(a1 + v15), &tv, n);
    v15 += n;
  }
  if ( v15 < a2 )
  {
    v6 = a2 - v15;
    if ( a2 - v15 > 4 )
      v6 = 4;
    v7 = v6;
    tv.tv_sec = getpid();
    memcpy((void *)(a1 + v15), &tv, v7);
    v15 += v7;
  }
  if ( v15 < a2 )
  {
    v8 = a2 - v15;
    if ( a2 - v15 > 4 )
      v8 = 4;
    v9 = v8;
    tv.tv_sec = getppid();
    memcpy((void *)(a1 + v15), &tv, v9);
    v15 += v9;
  }
  if ( v15 < a2 )
  {
    v10 = a2 - v15;
    if ( a2 - v15 > 4 )
      v10 = 4;
    v11 = v10;
    tv.tv_sec = getuid();
    memcpy((void *)(a1 + v15), &tv, v11);
    v15 += v11;
  }
  result = v15;
  if ( v15 < a2 )
  {
    v13 = a2 - v15;
    if ( a2 - v15 > 4 )
      v13 = 4;
    v14 = v13;
    tv.tv_sec = getgid();
    memcpy((void *)(a1 + v15), &tv, v14);
    result = v15 + v14;
  }
  return result;
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);

//----- (0805BFD4) --------------------------------------------------------
char *__usercall sub_805BFD4@<eax>(double a1@<st0>, int a2, size_t n)
{
  void *v4; // eax
  size_t v5; // eax
  int v6; // edx
  int v7; // ecx
  FILE *stream; // [esp+18h] [ebp-10h]
  char *v9; // [esp+1Ch] [ebp-Ch]

  if ( !n )
    return (char *)sub_805BD92(0, 0);
  stream = 0;
  v4 = &loc_805C01F;
  if ( !a2 )
    v4 = &loc_805C057;
  dword_806B308 = (int)v4;
  sub_806160F();
  stream = sub_806060A(a1, a2, "rb");
  if ( !stream )
  {
    dword_806B234 = (int)&locret_805C0DD;
    sub_8061BAC();
  }
  v9 = (char *)sub_805BD92((int)stream, a2);
  if ( stream )
  {
    v5 = 2048;
    if ( n <= 0x800 )
      v5 = n;
    setvbuf(stream, v9 + 12, 0, v5);
  }
  else
  {
    *((_DWORD *)v9 + 3) = 0;
    sub_805BDC7((int)(v9 + 16), 1024, n);
    sub_805C895(v6, v7, (_DWORD *)v9 + 4);
  }
  return v9;
}
// 806160F: using guessed type int sub_806160F(void);
// 8061BAC: using guessed type int sub_8061BAC(void);
// 806B234: using guessed type int dword_806B234;
// 806B308: using guessed type int dword_806B308;

//----- (0805C0FB) --------------------------------------------------------
size_t __cdecl sub_805C0FB(int a1, void *ptr, size_t n)
{
  size_t result; // eax
  int *v4; // ebx
  FILE *v5; // [esp+0h] [ebp-28h]
  FILE *v6; // [esp+Ch] [ebp-1Ch]
  size_t v7; // [esp+18h] [ebp-10h]
  int v8; // [esp+1Ch] [ebp-Ch]

  while ( 1 )
  {
    v6 = *(FILE **)a1;
    v7 = fread_unlocked(ptr, 1u, n, v6);
    v8 = *__errno_location();
    ptr = (char *)ptr + v7;
    result = v7;
    n -= v7;
    if ( !n )
      break;
    v4 = __errno_location();
    v5 = *(FILE **)a1;
    if ( ferror_unlocked(v5) )
    {
      dword_806B2F4 = (int)&loc_805C17D;
      sub_80616BF();
    }
    *v4 = 0;
    (*(void (__cdecl **)(_DWORD))(a1 + 4))(*(_DWORD *)(a1 + 8));
  }
  return result;
}
// 806B2F4: using guessed type int dword_806B2F4;

//----- (0805C19B) --------------------------------------------------------
int __cdecl sub_805C19B(int a1, void *dest, size_t n)
{
  int result; // eax
  size_t v4; // [esp+14h] [ebp-14h]
  int *desta; // [esp+34h] [ebp+Ch]
  size_t na; // [esp+38h] [ebp+10h]

  v4 = *(_DWORD *)a1;
  if ( n > *(_DWORD *)a1 )
  {
    memcpy(dest, (const void *)(a1 + 1024 - v4 + 1040), v4);
    na = n - v4;
    if ( ((_BYTE)dest + (_BYTE)v4) & 3 || (desta = (int *)((char *)dest + v4), na <= 0x3FF) )
      sub_805C392((unsigned int *)(a1 + 4), (int *)(a1 + 1040));
    sub_805C392((unsigned int *)(a1 + 4), desta);
  }
  memcpy(dest, (const void *)(a1 + 1024 - v4 + 1040), n);
  result = a1;
  *(_DWORD *)a1 = v4 - n;
  return result;
}

//----- (0805C2BC) --------------------------------------------------------
size_t __cdecl sub_805C2BC(int a1, void *ptr, size_t n)
{
  size_t result; // eax

  if ( *(_DWORD *)a1 )
    result = sub_805C0FB(a1, ptr, n);
  else
    result = sub_805C19B(a1 + 12, ptr, n);
  return result;
}

//----- (0805C304) --------------------------------------------------------
int __usercall sub_805C304@<eax>(double a1@<st0>, void *ptr)
{
  int result; // eax
  FILE *stream; // [esp+1Ch] [ebp-Ch]

  stream = *(FILE **)ptr;
  explicit_bzero(ptr, 2076);
  free(ptr);
  if ( stream )
    result = sub_805F3D1(a1, stream);
  else
    result = 0;
  return result;
}
// 8049DE0: using guessed type int __cdecl explicit_bzero(_DWORD, _DWORD);

//----- (0805C34A) --------------------------------------------------------
int __cdecl sub_805C34A(int a1)
{
  return a1;
}

//----- (0805C361) --------------------------------------------------------
int __cdecl sub_805C361(int a1, __int16 a2)
{
  return *(_DWORD *)((a2 & 0x3FC) + a1);
}

//----- (0805C392) --------------------------------------------------------
void __cdecl __noreturn sub_805C392(unsigned int *a1, int *a2)
{
  unsigned int v2; // edx
  int v3; // ST08_4
  unsigned int v4; // ST18_4
  unsigned int v5; // ST1C_4
  int v6; // eax
  int v7; // eax
  int v8; // ST0C_4
  unsigned int v9; // ST20_4
  int v10; // eax
  int *v11; // ebx
  int v12; // eax
  int v13; // edx
  int v14; // ecx
  int v15; // ST0C_4
  int v16; // ST08_4
  unsigned int v17; // ST28_4
  int v18; // eax
  int v19; // eax
  int v20; // ST0C_4
  unsigned int v21; // ST30_4
  int v22; // eax
  int v23; // eax
  int v24; // ST08_4
  unsigned int v25; // ST38_4
  unsigned int v26; // ST3C_4
  int v27; // eax
  int v28; // eax
  int v29; // ST0C_4
  unsigned int v30; // ST08_4
  unsigned int v31; // ST40_4
  int v32; // eax
  int v33; // eax
  int v34; // eax
  int v35; // ST0C_4
  int v36; // ST08_4
  unsigned int v37; // ST48_4
  int v38; // eax
  int v39; // eax
  int i; // eax
  unsigned int v41; // [esp+8h] [ebp-54h]
  unsigned int v42; // [esp+8h] [ebp-54h]
  int v43; // [esp+Ch] [ebp-50h]
  unsigned int *v44; // [esp+10h] [ebp-4Ch]
  int *v45; // [esp+14h] [ebp-48h]

  v41 = a1[256];
  v2 = a1[257];
  v43 = v2 + ++a1[258];
  v44 = a1;
  v45 = a2;
  while ( 1 )
  {
    v3 = (v41 ^ (v41 << 13)) + v44[128];
    v4 = *v44;
    v5 = sub_805C361((int)a1, *v44) + v3 + v43;
    *v44 = v5;
    v6 = sub_805C361((int)a1, v5 >> 8);
    v7 = sub_805C34A(v4 + v6);
    v8 = v7;
    *v45 = v7;
    v42 = (v3 ^ ((unsigned int)sub_805C34A(v3) >> 6)) + v44[129];
    v9 = v44[1];
    v10 = sub_805C361((int)a1, v9);
    v44[1] = v10 + v42 + v8;
    v11 = v45 + 1;
    v12 = sub_805C361((int)a1, (v10 + v42 + v8) >> 8);
    for ( i = sub_805C34A(v9 + v12); ; i = sub_8061955(v14, v13) )
    {
      v15 = i;
      *v11 = i;
      v16 = (v42 ^ 4 * v42) + v44[130];
      v17 = v44[2];
      v18 = sub_805C361((int)a1, v17);
      v44[2] = v18 + v16 + v15;
      v19 = sub_805C361((int)a1, (unsigned int)(v18 + v16 + v15) >> 8);
      v20 = sub_805C34A(v17 + v19);
      v45[2] = v20;
      v41 = (v16 ^ ((unsigned int)sub_805C34A(v16) >> 16)) + v44[131];
      v21 = v44[3];
      v22 = sub_805C361((int)a1, v21);
      v44[3] = v22 + v41 + v20;
      v23 = sub_805C361((int)a1, (v22 + v41 + v20) >> 8);
      v43 = sub_805C34A(v21 + v23);
      v45[3] = v43;
      v45 += 4;
      v44 += 4;
      if ( v44 < a1 + 128 )
        break;
      v24 = (v41 ^ (v41 << 13)) + *(v44 - 128);
      v25 = *v44;
      v26 = sub_805C361((int)a1, *v44) + v24 + v43;
      *v44 = v26;
      v27 = sub_805C361((int)a1, v26 >> 8);
      v28 = sub_805C34A(v25 + v27);
      v29 = v28;
      *v45 = v28;
      v30 = (v24 ^ ((unsigned int)sub_805C34A(v24) >> 6)) + *(v44 - 127);
      v31 = v44[1];
      v32 = sub_805C361((int)a1, v31);
      v44[1] = v32 + v30 + v29;
      v33 = sub_805C361((int)a1, (v32 + v30 + v29) >> 8);
      v34 = sub_805C34A(v31 + v33);
      v35 = v34;
      v45[1] = v34;
      v36 = (v30 ^ 4 * v30) + *(v44 - 126);
      v37 = v44[2];
      v38 = sub_805C361((int)a1, v37);
      v44[2] = v38 + v36 + v35;
      v39 = sub_805C361((int)a1, (unsigned int)(v38 + v36 + v35) >> 8);
      v45[2] = sub_805C34A(v37 + v39);
      v42 = (v36 ^ ((unsigned int)sub_805C34A(v36) >> 16)) + *(v44 - 125);
      v11 = (int *)(v44 + 3);
      sub_805C361((int)a1, v44[3]);
      dword_806B298 = (int)sub_805C81A;
    }
  }
}
// 805C81A: using guessed type int sub_805C81A();
// 806B298: using guessed type int dword_806B298;

//----- (0805C895) --------------------------------------------------------
_DWORD *__usercall sub_805C895@<eax>(int a1@<edx>, int a2@<ecx>, _DWORD *a3)
{
  int v3; // ST10_4
  int v4; // ST14_4
  int v5; // ST1C_4
  int v6; // ST20_4
  int v7; // ST24_4
  int v8; // ST28_4
  int v9; // ST0C_4
  int v10; // ST18_4
  unsigned int v11; // ST10_4
  int v12; // ST1C_4
  int v13; // ST14_4
  int v14; // ST20_4
  int v15; // ST24_4
  int v16; // ST28_4
  int v17; // ST0C_4
  int v18; // ST10_4
  int v19; // ST14_4
  int v20; // ST1C_4
  int v21; // ST20_4
  int v22; // ST24_4
  int v23; // ST28_4
  int v24; // ST0C_4
  int v25; // ST18_4
  unsigned int v26; // ST10_4
  int v27; // ST1C_4
  int v28; // ST14_4
  int v29; // ST20_4
  int v30; // ST24_4
  int v31; // ST28_4
  int v32; // ST0C_4
  _DWORD *result; // eax
  int v34; // [esp+Ch] [ebp-28h]
  int v35; // [esp+10h] [ebp-24h]
  int v36; // [esp+14h] [ebp-20h]
  unsigned int v37; // [esp+18h] [ebp-1Ch]
  int v38; // [esp+1Ch] [ebp-18h]
  unsigned int v39; // [esp+20h] [ebp-14h]
  int v40; // [esp+24h] [ebp-10h]
  unsigned int v41; // [esp+28h] [ebp-Ch]
  signed int v42; // [esp+2Ch] [ebp-8h]
  signed int i; // [esp+30h] [ebp-4h]

  v34 = 325574490;
  v35 = -1780940711;
  v36 = -1021952437;
  v37 = 255990488;
  v38 = -651539848;
  v39 = -1525007287;
  v40 = -990909925;
  v41 = 811634969;
  v42 = 0;
  dword_806B31C = (int)&loc_805CAA7;
  sub_8061576(a2, a1);
  do
  {
    v3 = a3[v42 + 1] + v35;
    v4 = a3[v42 + 2] + v36;
    v5 = a3[v42 + 4] + v38;
    v6 = a3[v42 + 5] + v39;
    v7 = a3[v42 + 6] + v40;
    v8 = a3[v42 + 7] + v41;
    v9 = (v3 << 11) ^ (a3[v42] + v34);
    v10 = v9 + a3[v42 + 3] + v37;
    v11 = ((unsigned int)sub_805C34A(v4) >> 2) ^ (v4 + v3);
    v12 = v11 + v5;
    v13 = (v10 << 8) ^ (v10 + v4);
    v14 = v13 + v6;
    v37 = ((unsigned int)sub_805C34A(v12) >> 16) ^ (v12 + v10);
    v15 = v37 + v7;
    v38 = (v14 << 10) ^ (v14 + v12);
    v16 = v38 + v8;
    v39 = ((unsigned int)sub_805C34A(v15) >> 4) ^ (v15 + v14);
    v17 = v39 + v9;
    v40 = (v16 << 8) ^ (v16 + v15);
    v35 = v40 + v11;
    v41 = ((unsigned int)sub_805C34A(v17) >> 9) ^ (v17 + v16);
    v36 = v41 + v13;
    v34 = v35 + v17;
    a3[v42] = v34;
    a3[v42 + 1] = v35;
    a3[v42 + 2] = v36;
    a3[v42 + 3] = v37;
    a3[v42 + 4] = v38;
    a3[v42 + 5] = v39;
    a3[v42 + 6] = v40;
    a3[v42 + 7] = v41;
    v42 += 8;
  }
  while ( v42 <= 255 );
  for ( i = 0; i <= 255; i += 8 )
  {
    v18 = a3[i + 1] + v35;
    v19 = a3[i + 2] + v36;
    v20 = a3[i + 4] + v38;
    v21 = a3[i + 5] + v39;
    v22 = a3[i + 6] + v40;
    v23 = a3[i + 7] + v41;
    v24 = (v18 << 11) ^ (a3[i] + v34);
    v25 = v24 + a3[i + 3] + v37;
    v26 = ((unsigned int)sub_805C34A(v19) >> 2) ^ (v19 + v18);
    v27 = v26 + v20;
    v28 = (v25 << 8) ^ (v25 + v19);
    v29 = v28 + v21;
    v37 = ((unsigned int)sub_805C34A(v27) >> 16) ^ (v27 + v25);
    v30 = v37 + v22;
    v38 = (v29 << 10) ^ (v29 + v27);
    v31 = v38 + v23;
    v39 = ((unsigned int)sub_805C34A(v30) >> 4) ^ (v30 + v29);
    v32 = v39 + v24;
    v40 = (v31 << 8) ^ (v31 + v30);
    v35 = v40 + v26;
    v41 = ((unsigned int)sub_805C34A(v32) >> 9) ^ (v32 + v31);
    v36 = v41 + v28;
    v34 = v35 + v32;
    a3[i] = v34;
    a3[i + 1] = v35;
    a3[i + 2] = v36;
    a3[i + 3] = v37;
    a3[i + 4] = v38;
    a3[i + 5] = v39;
    a3[i + 6] = v40;
    a3[i + 7] = v41;
  }
  a3[258] = 0;
  a3[257] = a3[258];
  result = a3;
  a3[256] = a3[257];
  return result;
}
// 8061576: using guessed type int __fastcall sub_8061576(_DWORD, _DWORD);
// 806B31C: using guessed type int dword_806B31C;

//----- (0805CCB6) --------------------------------------------------------
int __cdecl sub_805CCB6(_DWORD *a1)
{
  int v1; // edx
  int v2; // ecx
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int *v7; // [esp-4h] [ebp-2Ch]
  _DWORD *v8; // [esp+8h] [ebp-20h]
  int v9; // [esp+Ch] [ebp-1Ch]
  _DWORD *v10; // [esp+10h] [ebp-18h]
  int v11; // [esp+14h] [ebp-14h]
  _DWORD *v12; // [esp+18h] [ebp-10h]
  int v13; // [esp+1Ch] [ebp-Ch]
  int savedregs; // [esp+28h] [ebp+0h]

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_805FA43((int)(a1 + 3), 0, 0, (int)malloc, (int)free);
  sub_805FA43((int)(a1 + 14), 0, 0, (int)malloc, (int)free);
  dword_806B298 = (int)&loc_805CD73;
  sub_8061955(v2, v1);
  v7 = &savedregs;
  v8 = a1 + 3;
  v9 = 0;
  v3 = a1[4];
  sub_805FCD0((int)(a1 + 3), 0);
  v10 = a1 + 14;
  v11 = 0;
  v4 = a1[15];
  sub_805FCD0((int)(a1 + 14), 0);
  v12 = a1 + 25;
  v13 = 0;
  v5 = a1[26];
  return sub_805FCD0((int)(a1 + 25), 0);
}
// 806160F: using guessed type int sub_806160F(void);
// 806B298: using guessed type int dword_806B298;
// 806B308: using guessed type int dword_806B308;

//----- (0805CE98) --------------------------------------------------------
_DWORD *__cdecl sub_805CE98(_DWORD *a1)
{
  _DWORD *result; // eax
  int src; // [esp+10h] [ebp-38h]
  _DWORD *v3; // [esp+14h] [ebp-34h]
  _DWORD *v4; // [esp+18h] [ebp-30h]
  int v5; // [esp+1Ch] [ebp-2Ch]
  int v6; // [esp+20h] [ebp-28h]
  _DWORD *v7; // [esp+24h] [ebp-24h]
  _DWORD *v8; // [esp+28h] [ebp-20h]
  _DWORD *v9; // [esp+2Ch] [ebp-1Ch]
  _DWORD *v10; // [esp+30h] [ebp-18h]
  _DWORD *v11; // [esp+34h] [ebp-14h]
  size_t n; // [esp+38h] [ebp-10h]
  _DWORD *v13; // [esp+3Ch] [ebp-Ch]

  v3 = a1 + 3;
  src = a1[6] - a1[5] - 1;
  v4 = a1 + 3;
  v5 = a1[5];
  if ( a1[6] == v5 )
    *((_BYTE *)v4 + 40) |= 2u;
  v4[3] = (v4[6] + v4[3]) & ~v4[6];
  if ( v4[3] - v4[1] > (unsigned int)(v4[4] - v4[1]) )
    v4[3] = v4[4];
  v4[2] = v4[3];
  v6 = v5;
  v7 = a1 + 14;
  v8 = a1 + 14;
  if ( (unsigned int)(a1[18] - a1[17]) <= 3 )
    sub_805FACC((int)v7, 4);
  v9 = v7;
  v10 = (_DWORD *)v7[3];
  *v10 = v6;
  v9[3] += 4;
  v11 = a1 + 25;
  n = 4;
  v13 = a1 + 25;
  if ( (unsigned int)(a1[29] - a1[28]) < 4 )
    sub_805FACC((int)v11, n);
  memcpy((void *)v11[3], &src, n);
  v11[3] += n;
  result = a1;
  ++*a1;
  return result;
}

//----- (0805D096) --------------------------------------------------------
bool __cdecl sub_805D096(FILE *stream, int a2)
{
  bool v2; // zf
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  _BYTE *v6; // eax
  void *v7; // eax
  int v9; // [esp+3Ch] [ebp-1Ch]
  int v10; // [esp+44h] [ebp-14h]

  v2 = fgetc(stream) == -1;
  v5 = &loc_805D0C9;
  if ( !v2 )
    v5 = &loc_805D146;
  dword_806B31C = (int)v5;
  sub_8061576(v4, v3);
  if ( *(_DWORD *)(a2 + 24) != *(_DWORD *)(a2 + 20) )
  {
    if ( *(_DWORD *)(a2 + 28) == *(_DWORD *)(a2 + 24) )
      sub_805FACC(a2 + 12, 1);
    v6 = *(_BYTE **)(a2 + 24);
    *(_DWORD *)(a2 + 24) = v6 + 1;
    *v6 = 0;
    sub_805CE98((_DWORD *)a2);
  }
  if ( (unsigned int)(*(_DWORD *)(a2 + 72) - *(_DWORD *)(a2 + 68)) <= 3 )
    sub_805FACC(a2 + 56, 4);
  **(_DWORD **)(a2 + 68) = 0;
  *(_DWORD *)(a2 + 68) += 4;
  v9 = *(_DWORD *)(a2 + 64);
  if ( *(_DWORD *)(a2 + 68) == v9 )
    *(_BYTE *)(a2 + 96) |= 2u;
  *(_DWORD *)(a2 + 68) = (*(_DWORD *)(a2 + 80) + *(_DWORD *)(a2 + 68)) & ~*(_DWORD *)(a2 + 80);
  if ( *(_DWORD *)(a2 + 68) - *(_DWORD *)(a2 + 60) > (unsigned int)(*(_DWORD *)(a2 + 72) - *(_DWORD *)(a2 + 60)) )
    *(_DWORD *)(a2 + 68) = *(_DWORD *)(a2 + 72);
  *(_DWORD *)(a2 + 64) = *(_DWORD *)(a2 + 68);
  *(_DWORD *)(a2 + 4) = v9;
  v10 = *(_DWORD *)(a2 + 108);
  v7 = &loc_805D2DA;
  if ( *(_DWORD *)(a2 + 112) != v10 )
    v7 = &loc_805D2E7;
  dword_806B2CC = (int)v7;
  sub_80617DA();
  *(_BYTE *)(a2 + 140) |= 2u;
  *(_DWORD *)(a2 + 112) = (*(_DWORD *)(a2 + 124) + *(_DWORD *)(a2 + 112)) & ~*(_DWORD *)(a2 + 124);
  if ( *(_DWORD *)(a2 + 112) - *(_DWORD *)(a2 + 104) > (unsigned int)(*(_DWORD *)(a2 + 116) - *(_DWORD *)(a2 + 104)) )
    *(_DWORD *)(a2 + 112) = *(_DWORD *)(a2 + 116);
  *(_DWORD *)(a2 + 108) = *(_DWORD *)(a2 + 112);
  *(_DWORD *)(a2 + 8) = v10;
  return ferror(stream) == 0;
}
// 805D096: could not find valid save-restore pair for ebx
// 8061576: using guessed type int __fastcall sub_8061576(_DWORD, _DWORD);
// 80617DA: using guessed type int sub_80617DA(void);
// 806B2CC: using guessed type int dword_806B2CC;
// 806B31C: using guessed type int dword_806B31C;

//----- (0805D381) --------------------------------------------------------
int __cdecl sub_805D381(int a1, int a2)
{
  int v2; // eax

  v2 = mkostemp64(a1, a2);
  return sub_8060540(v2, a2);
}
// 8049A10: using guessed type int __cdecl mkostemp64(_DWORD, _DWORD);

//----- (0805D3AA) --------------------------------------------------------
int __usercall sub_805D3AA@<eax>(double a1@<st0>, _BYTE *a2, _BYTE *a3, char a4)
{
  _BYTE *v5; // eax
  _BYTE *v6; // eax
  int v7; // eax
  char v8; // [esp+0h] [ebp-4h]

  v8 = a4;
  if ( *a2 == a4 && *a3 == v8 )
  {
    while ( *++a2 == *++a3 )
    {
      if ( (unsigned int)((char)*a2 - 48) > 9 )
      {
        dword_806B2F4 = (int)&locret_805D526;
        sub_80616BF();
      }
    }
    if ( (unsigned int)((char)*a2 - 48) <= 9 && (unsigned int)((char)*a3 - 48) <= 9 )
      return (char)*a2 - (char)*a3;
    if ( (unsigned int)((char)*a2 - 48) <= 9 )
      goto LABEL_16;
    if ( (unsigned int)((char)*a3 - 48) <= 9 )
      goto LABEL_21;
    dword_806B20C = (int)&locret_805D526;
    sub_8061C98(a1);
  }
  v5 = a2++;
  if ( *v5 != v8 )
  {
    v6 = a3++;
    if ( *v6 != v8 )
      return 0;
LABEL_21:
    while ( *a3 == 48 )
      ++a3;
    v7 = -((unsigned int)((char)*a3 - 48) <= 9);
    dword_806B308 = (int)&locret_805D526;
    sub_806160F();
    return 0;
  }
LABEL_16:
  while ( *a2 == 48 )
    ++a2;
  return (unsigned int)((char)*a2 - 48) <= 9;
}
// 806160F: using guessed type int sub_806160F(void);
// 8061C98: using guessed type int __usercall sub_8061C98@<eax>(double@<st0>);
// 806B20C: using guessed type int dword_806B20C;
// 806B2F4: using guessed type int dword_806B2F4;
// 806B308: using guessed type int dword_806B308;

//----- (0805D528) --------------------------------------------------------
int __usercall sub_805D528@<eax>(int edx0@<edx>, int ecx0@<ecx>, _BYTE *a1, unsigned __int8 *a2, int a3, int a4)
{
  void *v6; // eax
  void *v7; // eax
  int v8; // edx
  int v9; // ecx
  void *v10; // eax
  unsigned __int8 v12; // [esp+Eh] [ebp-Eh]
  unsigned __int8 v13; // [esp+Fh] [ebp-Dh]

  v13 = *a2;
  v6 = &loc_805D55F;
  if ( *a1 != 45 )
    v6 = &loc_805D7F5;
  dword_806B220 = (int)v6;
  sub_8061C20(ecx0, edx0);
  do
    v12 = *++a1;
  while ( *a1 == 48 );
  v7 = &loc_805D594;
  if ( v12 == a4 )
    v7 = &loc_805D55F;
  dword_806B2B8 = (int)v7;
  sub_8061881();
  v10 = &loc_805D5B3;
  if ( v13 == 45 )
    v10 = &loc_805D649;
  dword_806B270 = (int)v10;
  sub_8061A4C(v9, v8);
  if ( v12 == a3 )
  {
    do
      v12 = *++a1;
    while ( *a1 == 48 );
  }
  if ( (unsigned int)v12 - 48 <= 9 )
    return -1;
  while ( v13 == 48 || v13 == a4 )
    v13 = *++a2;
  if ( v13 == a3 )
  {
    do
      v13 = *++a2;
    while ( *a2 == 48 );
  }
  return -((unsigned int)v13 - 48 <= 9);
}
// 805D528: could not find valid save-restore pair for ebx
// 8061881: using guessed type int sub_8061881(void);
// 8061A4C: using guessed type int __fastcall sub_8061A4C(_DWORD, _DWORD);
// 8061C20: using guessed type int __fastcall sub_8061C20(_DWORD, _DWORD);
// 806B220: using guessed type int dword_806B220;
// 806B270: using guessed type int dword_806B270;
// 806B2B8: using guessed type int dword_806B2B8;

//----- (0805DAFB) --------------------------------------------------------
int __usercall sub_805DAFB@<eax>(int edx0@<edx>, int ecx0@<ecx>, _BYTE *a1, unsigned __int8 *a2, int a3, int a4)
{
  return sub_805D528(edx0, ecx0, a1, a2, a3, a4);
}

//----- (0805DB23) --------------------------------------------------------
int __usercall sub_805DB23@<eax>(int a1@<edx>, int a2@<ecx>, int fd)
{
  void *v3; // eax
  int v4; // ST20_4
  int v5; // ST24_4

  if ( fd >= 0 )
  {
    v3 = &loc_805DB4E;
    if ( fd > 2 )
      v3 = &loc_805DB78;
    dword_806B284 = (int)v3;
    sub_80619DA(a2, a1);
    v4 = sub_806109B(fd);
    v5 = *__errno_location();
    close(fd);
    *__errno_location() = v5;
    fd = v4;
  }
  return fd;
}
// 80619DA: using guessed type double __fastcall sub_80619DA(_DWORD, _DWORD);
// 806B284: using guessed type int dword_806B284;

//----- (0805DBAB) --------------------------------------------------------
int __cdecl sub_805DBAB(FILE *stream, int a2, int a3, int a4, int a5, int a6)
{
  char *v6; // eax
  char *v7; // ebx
  char *v8; // eax
  int v9; // edx
  int v10; // ecx
  int v11; // esi
  char *v12; // ebx
  char *v13; // eax
  int result; // eax
  int v15; // edi
  int v16; // esi
  char *v17; // ebx
  char *v18; // eax
  int v19; // edi
  int v20; // esi
  char *v21; // ebx
  char *v22; // eax
  int v23; // edi
  int v24; // esi
  char *v25; // ebx
  char *v26; // eax
  int v27; // edi
  int v28; // esi
  char *v29; // ebx
  char *v30; // eax
  int v31; // esi
  int v32; // edi
  char *v33; // ebx
  char *v34; // eax
  int v35; // edi
  int v36; // esi
  char *v37; // ebx
  char *v38; // eax
  int v39; // edi
  int v40; // esi
  char *v41; // ebx
  char *v42; // eax
  int v43; // edx
  int v44; // ecx
  int v45; // edi
  int v46; // esi
  char *v47; // ebx
  char *v48; // eax
  char *v49; // [esp+8h] [ebp-60h]
  int v50; // [esp+Ch] [ebp-5Ch]
  int v51; // [esp+10h] [ebp-58h]
  int v52; // [esp+14h] [ebp-54h]
  int v53; // [esp+18h] [ebp-50h]
  int v54; // [esp+1Ch] [ebp-4Ch]
  int v55; // [esp+20h] [ebp-48h]
  int v56; // [esp+24h] [ebp-44h]
  int v57; // [esp+28h] [ebp-40h]
  int v58; // [esp+38h] [ebp-30h]
  int v59; // [esp+3Ch] [ebp-2Ch]
  int v60; // [esp+40h] [ebp-28h]
  int v61; // [esp+44h] [ebp-24h]
  int v62; // [esp+48h] [ebp-20h]
  int v63; // [esp+4Ch] [ebp-1Ch]

  if ( a2 )
  {
    v51 = a4;
    fprintf(stream, "%s (%s) %s\n", a2, a3, a4);
  }
  else
  {
    fprintf(stream, "%s %s\n", a3, a4);
  }
  v50 = 2017;
  v49 = gettext("(C)");
  fprintf(stream, "Copyright %s %d Free Software Foundation, Inc.", v49, 2017);
  v6 = gettext(
         "\n"
         "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\n"
         "This is free software: you are free to change and redistribute it.\n"
         "There is NO WARRANTY, to the extent permitted by law.\n"
         "\n");
  fputs_unlocked(v6, stream);
  switch ( a6 )
  {
    case 0:
      abort();
      return result;
    case 1:
      v7 = *(char **)a5;
      v8 = gettext("Written by %s.\n");
      v49 = v7;
      fprintf(stream, v8, v7);
      dword_806B270 = (int)&loc_805E130;
      sub_8061A4C(v10, v9);
      goto LABEL_7;
    case 2:
LABEL_7:
      v11 = *(_DWORD *)(a5 + 4);
      v12 = *(char **)a5;
      v13 = gettext("Written by %s and %s.\n");
      v50 = v11;
      v49 = v12;
      return fprintf(stream, v13, v12, v11);
    case 3:
      v15 = *(_DWORD *)(a5 + 8);
      v16 = *(_DWORD *)(a5 + 4);
      v17 = *(char **)a5;
      v18 = gettext("Written by %s, %s, and %s.\n");
      return fprintf(stream, v18, v17, v16, v15);
    case 4:
      v63 = *(_DWORD *)(a5 + 12);
      v19 = *(_DWORD *)(a5 + 8);
      v20 = *(_DWORD *)(a5 + 4);
      v21 = *(char **)a5;
      v22 = gettext("Written by %s, %s, %s,\nand %s.\n");
      return fprintf(stream, v22, v21, v20, v19, v63);
    case 5:
      v63 = *(_DWORD *)(a5 + 16);
      v62 = *(_DWORD *)(a5 + 12);
      v23 = *(_DWORD *)(a5 + 8);
      v24 = *(_DWORD *)(a5 + 4);
      v25 = *(char **)a5;
      v26 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
      return fprintf(stream, v26, v25, v24, v23, v62, v63);
    case 6:
      v63 = *(_DWORD *)(a5 + 20);
      v62 = *(_DWORD *)(a5 + 16);
      v61 = *(_DWORD *)(a5 + 12);
      v27 = *(_DWORD *)(a5 + 8);
      v28 = *(_DWORD *)(a5 + 4);
      v29 = *(char **)a5;
      v30 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
      return fprintf(stream, v30, v29, v28, v27, v61, v62, v63);
    case 7:
      v31 = *(_DWORD *)(a5 + 24);
      v63 = *(_DWORD *)(a5 + 20);
      v62 = *(_DWORD *)(a5 + 16);
      v61 = *(_DWORD *)(a5 + 12);
      v60 = *(_DWORD *)(a5 + 8);
      v32 = *(_DWORD *)(a5 + 4);
      v33 = *(char **)a5;
      v34 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
      return fprintf(stream, v34, v33, v32, v60, v61, v62, v63, v31);
    case 8:
      v35 = *(_DWORD *)(a5 + 28);
      v63 = *(_DWORD *)(a5 + 24);
      v62 = *(_DWORD *)(a5 + 20);
      v61 = *(_DWORD *)(a5 + 16);
      v60 = *(_DWORD *)(a5 + 12);
      v59 = *(_DWORD *)(a5 + 8);
      v36 = *(_DWORD *)(a5 + 4);
      v37 = *(char **)a5;
      v38 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
      return fprintf(stream, v38, v37, v36, v59, v60, v61, v62, v63, v35);
    case 9:
      v39 = *(_DWORD *)(a5 + 32);
      v63 = *(_DWORD *)(a5 + 28);
      v62 = *(_DWORD *)(a5 + 24);
      v61 = *(_DWORD *)(a5 + 20);
      v60 = *(_DWORD *)(a5 + 16);
      v59 = *(_DWORD *)(a5 + 12);
      v58 = *(_DWORD *)(a5 + 8);
      v40 = *(_DWORD *)(a5 + 4);
      v41 = *(char **)a5;
      v42 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
      v57 = v39;
      v56 = v63;
      v55 = v62;
      v54 = v61;
      v53 = v60;
      v52 = v59;
      v51 = v58;
      v50 = v40;
      v49 = v41;
      fprintf(stream, v42, v41, v40, v58, v59, v60, v61, v62, v63, v39);
      dword_806B31C = (int)&loc_805E130;
      sub_8061576(v44, v43);
      break;
    default:
      break;
  }
  v45 = *(_DWORD *)(a5 + 32);
  v63 = *(_DWORD *)(a5 + 28);
  v62 = *(_DWORD *)(a5 + 24);
  v61 = *(_DWORD *)(a5 + 20);
  v60 = *(_DWORD *)(a5 + 16);
  v59 = *(_DWORD *)(a5 + 12);
  v58 = *(_DWORD *)(a5 + 8);
  v46 = *(_DWORD *)(a5 + 4);
  v47 = *(char **)a5;
  v48 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
  v57 = v45;
  v56 = v63;
  v55 = v62;
  v54 = v61;
  v53 = v60;
  v52 = v59;
  v51 = v58;
  v50 = v46;
  v49 = v47;
  return fprintf(stream, v48, v47, v46, v58, v59, v60, v61, v62, v63, v45);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8061576: using guessed type int __fastcall sub_8061576(_DWORD, _DWORD);
// 8061A4C: using guessed type int __fastcall sub_8061A4C(_DWORD, _DWORD);
// 806B270: using guessed type int dword_806B270;
// 806B31C: using guessed type int dword_806B31C;

//----- (0805E190) --------------------------------------------------------
int __usercall sub_805E190@<eax>(int a1@<edx>, int a2@<ecx>, FILE *stream, int a4, int a5, int a6, int a7)
{
  int *v8; // eax
  int v9; // [esp+24h] [ebp-34h]
  int v10[12]; // [esp+28h] [ebp-30h]

  v9 = 0;
  dword_806B298 = (int)&loc_805E1B8;
  sub_8061955(a2, a1);
  do
  {
    if ( (unsigned int)++v9 > 9 )
      break;
    v8 = (int *)a7;
    a7 += 4;
    v10[v9] = *v8;
  }
  while ( v10[v9] );
  return sub_805DBAB(stream, a4, a5, a6, (int)v10, v9);
}
// 806B298: using guessed type int dword_806B298;
// 805E190: using guessed type int var_30[12];

//----- (0805E233) --------------------------------------------------------
int __usercall sub_805E233@<eax>(int a1@<edx>, int a2@<ecx>, FILE *stream, int a4, int a5, int a6, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a6);
  return sub_805E190(a1, a2, stream, a4, a5, a6, (int)va);
}

//----- (0805E2D3) --------------------------------------------------------
void *__cdecl sub_805E2D3(unsigned int a1, unsigned int a2)
{
  if ( 0x7FFFFFFF / a2 < a1 )
    sub_805E5AE();
  return sub_805E3F4(a2 * a1);
}

//----- (0805E315) --------------------------------------------------------
void *__cdecl sub_805E315(size_t n, unsigned int a2, unsigned int a3)
{
  if ( 0x7FFFFFFF / a3 < a2 )
    sub_805E5AE();
  return sub_805E447(n, a3 * a2);
}

//----- (0805E34A) --------------------------------------------------------
void *__cdecl sub_805E34A(size_t n, unsigned int *a2, unsigned int a3)
{
  unsigned int v4; // [esp+1Ch] [ebp-Ch]

  v4 = *a2;
  if ( n )
  {
    if ( 0x55555554 / a3 <= v4 )
      sub_805E5AE();
    v4 += (v4 >> 1) + 1;
  }
  else
  {
    if ( !v4 )
      v4 = (0x40 / a3 == 0) + 0x40 / a3;
    if ( 0x7FFFFFFF / a3 < v4 )
      sub_805E5AE();
  }
  *a2 = v4;
  return sub_805E447(n, a3 * v4);
}

//----- (0805E3E1) --------------------------------------------------------
void *__cdecl sub_805E3E1(size_t size)
{
  return sub_805E3F4(size);
}

//----- (0805E3F4) --------------------------------------------------------
void *__cdecl sub_805E3F4(size_t size)
{
  void *v1; // eax
  bool v2; // zf
  void *v3; // eax
  void *v5; // [esp+1Ch] [ebp-Ch]

  v1 = malloc(size);
  v5 = v1;
  v2 = v1 == 0;
  v3 = &loc_805E438;
  if ( !v2 )
    v3 = &loc_805E442;
  dword_806B308 = (int)v3;
  sub_806160F();
  if ( size )
    sub_805E5AE();
  return v5;
}
// 806160F: using guessed type int sub_806160F(void);
// 806B308: using guessed type int dword_806B308;

//----- (0805E447) --------------------------------------------------------
void *__cdecl sub_805E447(size_t n, size_t size)
{
  int v2; // edx
  int v3; // ecx
  void *na; // [esp+20h] [ebp+8h]

  if ( !size && n )
  {
    free((void *)n);
    dword_806B220 = (int)&locret_805E4BF;
    sub_8061C20(v3, v2);
  }
  na = realloc((void *)n, size);
  if ( !na && size )
    sub_805E5AE();
  return na;
}
// 8061C20: using guessed type int __fastcall sub_8061C20(_DWORD, _DWORD);
// 806B220: using guessed type int dword_806B220;

//----- (0805E513) --------------------------------------------------------
void *__cdecl sub_805E513(size_t nmemb, size_t size)
{
  void *v3; // [esp+1Ch] [ebp-Ch]

  if ( 0x7FFFFFFF / size < nmemb || (v3 = calloc(nmemb, size)) == 0 )
    sub_805E5AE();
  return v3;
}

//----- (0805E550) --------------------------------------------------------
void *__cdecl sub_805E550(void *src, size_t n)
{
  void *v2; // eax

  v2 = sub_805E3F4(n);
  return memcpy(v2, src, n);
}

//----- (0805E5AE) --------------------------------------------------------
void __noreturn sub_805E5AE()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (0805E5E7) --------------------------------------------------------
void __cdecl sub_805E5E7(int errnum, int a3, int a4, int a5, int a6)
{
  char *v6; // eax
  char *v7; // eax
  void *v8; // esi
  void *v9; // ebx
  char *v10; // eax

  v6 = gettext("string comparison failed");
  error(0, errnum, v6);
  v7 = gettext("Set LC_ALL='C' to work around the problem.");
  error(0, 0, v7);
  v8 = sub_805B877(1, 8, (char *)a5, a6);
  v9 = sub_805B877(0, 8, (char *)a3, a4);
  v10 = gettext("The strings compared were %s and %s.");
  error(status, 0, v10, v9, v8);
}

//----- (0805E744) --------------------------------------------------------
int __cdecl sub_805E744(void *s1, size_t n, void *s2, int a5)
{
  int v6; // [esp+28h] [ebp-10h]
  int errnum; // [esp+2Ch] [ebp-Ch]

  v6 = sub_8060F72(s1, n, s2, a5);
  errnum = *__errno_location();
  if ( errnum )
    sub_805E5E7(errnum, (int)s1, n - 1, (int)s2, a5 - 1);
  return v6;
}

//----- (0805E7AF) --------------------------------------------------------
signed int __cdecl sub_805E7AF(double a1)
{
  struct timespec requested_time; // [esp+28h] [ebp-10h]

  sub_80603EB(&requested_time, a1);
  do
  {
    *__errno_location() = 0;
    if ( !nanosleep(&requested_time, 0) )
      return 0;
  }
  while ( *__errno_location() == 4 || !*__errno_location() );
  return -1;
}

//----- (0805E821) --------------------------------------------------------
signed int __cdecl sub_805E821(unsigned int *a1, unsigned int a2)
{
  signed int result; // eax

  if ( 0xFFFFFFFF / a2 >= *a1 )
  {
    *a1 *= a2;
    result = 0;
  }
  else
  {
    *a1 = -1;
    result = 1;
  }
  return result;
}

//----- (0805E865) --------------------------------------------------------
int __cdecl sub_805E865(unsigned int *a1, unsigned int a2, int a3)
{
  int v4; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; i |= sub_805E821(a1, a2) )
  {
    v4 = a3--;
    if ( !v4 )
      break;
  }
  return i;
}

//----- (0805E8AB) --------------------------------------------------------
int __usercall sub_805E8AB@<eax>(int a1@<edx>, int a2@<ecx>, char *nptr, int a3, int base, int a5, char *s)
{
  void *v7; // eax
  long double v8; // fst7
  char **v9; // eax
  const unsigned __int16 **v10; // eax
  int v11; // ecx
  int v12; // edx
  bool v13; // zf
  void *v14; // eax
  int result; // eax
  int v16; // ecx
  unsigned int v17; // edx
  unsigned int v18; // eax
  int v19; // edx
  int v20; // ecx
  int v21; // edx
  int v22; // ecx
  int v23; // [esp+4h] [ebp-44h]
  unsigned __int8 i; // [esp+1Fh] [ebp-29h]
  char v25; // [esp+20h] [ebp-28h]
  unsigned int v26; // [esp+24h] [ebp-24h]
  int v27; // [esp+28h] [ebp-20h]
  char *v28; // [esp+2Ch] [ebp-1Ch]
  unsigned int v29; // [esp+30h] [ebp-18h]
  int v30; // [esp+34h] [ebp-14h]
  int v31; // [esp+38h] [ebp-10h]
  char **endptr; // [esp+3Ch] [ebp-Ch]

  v27 = 0;
  if ( base < 0 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoul");
  v7 = &loc_805E8DD;
  if ( base > 36 )
    v7 = &loc_805E8E5;
  dword_806B284 = (int)v7;
  v8 = sub_80619DA(a2, a1);
  if ( a3 )
    v9 = (char **)a3;
  else
    v9 = (char **)&v25;
  endptr = v9;
  *__errno_location() = 0;
  v28 = nptr;
  for ( i = *nptr; ; i = *v28 )
  {
    v10 = __ctype_b_loc();
    v12 = i;
    if ( !((*v10)[v12] & 0x2000) )
      break;
    ++v28;
  }
  if ( i == 45 )
  {
    dword_806B2E0 = (int)&locret_805ED73;
    sub_806174E(v11, v12 * 2);
  }
  v26 = strtoul(nptr, endptr, base);
  if ( *endptr == nptr )
  {
    if ( s && **endptr )
    {
      v13 = strchr(s, **endptr) == 0;
      v14 = &loc_805E9F8;
      if ( v13 )
        v14 = &loc_805EAF6;
      dword_806B20C = (int)v14;
      sub_8061C98(*(double *)&v8);
      v26 = 1;
      dword_806B20C = (int)&loc_805EA63;
      sub_8061C98(*(double *)&v8);
    }
    result = 4;
  }
  else
  {
    if ( *__errno_location() )
    {
      if ( *__errno_location() != 34 )
      {
        dword_806B2CC = (int)&locret_805ED73;
        sub_80617DA();
      }
      v27 = 1;
    }
    if ( s )
    {
      if ( **endptr )
      {
        v29 = 1024;
        v30 = 1;
        v23 = **endptr;
        if ( !strchr(s, v23) )
        {
          v17 = v26;
          *(_DWORD *)a5 = v26;
          dword_806B298 = (int)&locret_805ED73;
          sub_8061955(v16, v17);
        }
        v18 = **endptr - 69;
        if ( v18 <= 0x2F )
          JUMPOUT(__CS__, *(&off_8064BF4 + v18));
        switch ( **endptr )
        {
          case 66:
            v31 = sub_805E821(&v26, 0x400u);
            goto LABEL_46;
          case 69:
            v31 = sub_805E865(&v26, v29, 6);
            goto LABEL_46;
          case 71:
          case 103:
            v31 = sub_805E865(&v26, v29, 3);
            dword_806B270 = (int)&loc_805ED43;
            sub_8061A4C(v20, v19);
            goto LABEL_38;
          case 75:
          case 107:
LABEL_38:
            v31 = sub_805E865(&v26, v29, 1);
            goto LABEL_46;
          case 77:
          case 109:
            v31 = sub_805E865(&v26, v29, 2);
            goto LABEL_46;
          case 80:
            v31 = sub_805E865(&v26, v29, 5);
            goto LABEL_46;
          case 84:
          case 116:
            v31 = sub_805E865(&v26, v29, 4);
            goto LABEL_46;
          case 89:
            goto LABEL_43;
          case 90:
            v31 = sub_805E865(&v26, v29, 7);
            goto LABEL_46;
          case 98:
            v31 = sub_805E821(&v26, 0x200u);
            goto LABEL_46;
          case 99:
            v31 = 0;
            goto LABEL_46;
          case 119:
            v31 = sub_805E821(&v26, 2u);
            dword_806B25C = (int)&loc_805ED43;
            sub_8061AC4(v22, v21);
LABEL_43:
            v31 = sub_805E865(&v26, v29, 8);
LABEL_46:
            v27 |= v31;
            *endptr += v30;
            if ( **endptr )
              v27 |= 2u;
            goto LABEL_48;
          default:
            *(_DWORD *)a5 = v26;
            result = v27 | 2;
            break;
        }
      }
      else
      {
LABEL_48:
        *(_DWORD *)a5 = v26;
        result = v27;
      }
    }
    else
    {
      *(_DWORD *)a5 = v26;
      result = v27;
    }
  }
  return result;
}
// 805E8AB: could not find valid save-restore pair for ebx
// 806174E: using guessed type int __fastcall sub_806174E(_DWORD, _DWORD);
// 80617DA: using guessed type int sub_80617DA(void);
// 80619DA: using guessed type double __fastcall sub_80619DA(_DWORD, _DWORD);
// 8061A4C: using guessed type int __fastcall sub_8061A4C(_DWORD, _DWORD);
// 8061AC4: using guessed type int __fastcall sub_8061AC4(_DWORD, _DWORD);
// 8061C98: using guessed type int __usercall sub_8061C98@<eax>(double@<st0>);
// 8064BF4: using guessed type void *off_8064BF4;
// 806B20C: using guessed type int dword_806B20C;
// 806B25C: using guessed type int dword_806B25C;
// 806B270: using guessed type int dword_806B270;
// 806B284: using guessed type int dword_806B284;
// 806B298: using guessed type int dword_806B298;
// 806B2CC: using guessed type int dword_806B2CC;
// 806B2E0: using guessed type int dword_806B2E0;

//----- (0805ED75) --------------------------------------------------------
void __usercall sub_805ED75(int edx0@<edx>, int ecx0@<ecx>, int a1, int a2, int a3, int a4, int a5, int status)
{
  void *v8; // eax
  char *v9; // eax
  char v10; // [esp+22h] [ebp-16h]
  char v11; // [esp+23h] [ebp-15h]
  const char *v12; // [esp+24h] [ebp-14h]
  char *msgid; // [esp+28h] [ebp-10h]
  char *v14; // [esp+2Ch] [ebp-Ch]

  v12 = "--";
  if ( (unsigned int)a1 > 3 )
  {
    if ( a1 != 4 )
      goto LABEL_7;
    msgid = "invalid %s%s argument '%s'";
  }
  else
  {
    if ( (unsigned int)a1 < 2 )
    {
      v8 = &loc_805EDB3;
      if ( a1 == 1 )
        v8 = &loc_805EDD1;
      dword_806B25C = (int)v8;
      sub_8061AC4(ecx0, edx0);
LABEL_7:
      abort();
    }
    msgid = "invalid suffix in %s%s argument '%s'";
  }
  if ( a2 >= 0 )
  {
    v14 = *(char **)(16 * a2 + a4);
  }
  else
  {
    v12 -= a2;
    v10 = a3;
    v11 = 0;
    v14 = &v10;
  }
  v9 = gettext(msgid);
  error(status, 0, v9, v12, v14, a5);
}
// 8061AC4: using guessed type int __fastcall sub_8061AC4(_DWORD, _DWORD);
// 806B25C: using guessed type int dword_806B25C;

//----- (0805EE44) --------------------------------------------------------
void __fastcall __noreturn sub_805EE44(int ecx0, int edx0, int a1, int a2, char a3, int a4, int a5)
{
  sub_805ED75(a4, ecx0, a1, a2, a3, a4, a5, status);
  abort();
}

//----- (0805EE87) --------------------------------------------------------
signed int __cdecl sub_805EE87(int a1, int a2)
{
  signed int result; // eax
  int v3; // ebx

  if ( (unsigned __int64)sub_80610C0(0xFFFFFFFF, 0xFFFFFFFF, a2, a2 >> 31) >= *(_QWORD *)a1 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    *(_QWORD *)a1 *= a2;
    result = 0;
  }
  else
  {
    *(_DWORD *)a1 = -1;
    *(_DWORD *)(a1 + 4) = -1;
    result = 1;
  }
  return result;
}

//----- (0805EF13) --------------------------------------------------------
int __cdecl sub_805EF13(int a1, int a2, int a3)
{
  int v3; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; ; i |= sub_805EE87(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}

//----- (0805EF49) --------------------------------------------------------
int __cdecl sub_805EF49(char *nptr, int a2, int base)
{
  char **v3; // eax
  void *v4; // eax
  unsigned __int8 i; // [esp+1Bh] [ebp-2Dh]
  char v7; // [esp+1Ch] [ebp-2Ch]
  int v8; // [esp+20h] [ebp-28h]
  char *v9; // [esp+24h] [ebp-24h]
  char **endptr; // [esp+34h] [ebp-14h]

  v8 = 0;
  if ( base < 0 || base > 36 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoumax");
  if ( a2 )
    v3 = (char **)a2;
  else
    v3 = (char **)&v7;
  endptr = v3;
  *__errno_location() = 0;
  v9 = nptr;
  for ( i = *nptr; (*__ctype_b_loc())[i] & 0x2000; i = *v9 )
    ++v9;
  v4 = &loc_805EFFF;
  if ( i != 45 )
    v4 = &loc_805F009;
  dword_806B234 = (int)v4;
  sub_8061BAC();
  return 4;
}
// 8061BAC: using guessed type int sub_8061BAC(void);
// 806B234: using guessed type int dword_806B234;

//----- (0805F3D1) --------------------------------------------------------
int __usercall sub_805F3D1@<eax>(double a1@<st0>, FILE *stream)
{
  int v3; // eax
  __int64 v4; // rax
  int v5; // [esp+14h] [ebp-14h]
  int v6; // [esp+18h] [ebp-10h]

  v5 = 0;
  if ( fileno(stream) < 0 )
    return fclose(stream);
  if ( !__freading(stream) || (v3 = fileno(stream), LODWORD(v4) = lseek64(v3, 0, 0, 1), v4 != -1) )
  {
    if ( sub_805F67A(a1, stream) )
      v5 = *__errno_location();
  }
  v6 = fclose(stream);
  if ( v5 )
  {
    *__errno_location() = v5;
    v6 = -1;
  }
  return v6;
}
// 8049A90: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0805F494) --------------------------------------------------------
int __cdecl sub_805F494(int fd, int cmd, char a3)
{
  void *v3; // eax
  char *v4; // eax
  int *v5; // eax
  int v7; // [esp+8h] [ebp-30h]
  char *v8; // [esp+18h] [ebp-20h]
  int v9; // [esp+1Ch] [ebp-1Ch]
  char v10[4]; // [esp+20h] [ebp-18h]
  int v11; // [esp+24h] [ebp-14h]
  int v12; // [esp+28h] [ebp-10h]
  int v13; // [esp+2Ch] [ebp-Ch]

  v9 = -1;
  v8 = &a3;
  v3 = &loc_805F4CA;
  if ( cmd != 1030 )
    v3 = &loc_805F612;
  dword_806B234 = (int)v3;
  sub_8061BAC();
  v4 = v8;
  v8 += 4;
  *(_DWORD *)v10 = *(_DWORD *)v4;
  if ( dword_806C290 < 0 )
  {
LABEL_9:
    v9 = sub_805F494(fd, 0, v10[0]);
    goto LABEL_10;
  }
  v7 = *(_DWORD *)v10;
  v9 = fcntl(fd, cmd, *(_DWORD *)v10);
  if ( v9 < 0 && *__errno_location() == 22 )
  {
    v9 = sub_805F494(fd, 0, v10[0]);
    if ( v9 < 0 )
      return v9;
    dword_806C290 = -1;
    dword_806B2F4 = (int)&loc_805F585;
    sub_80616BF();
    goto LABEL_9;
  }
  dword_806C290 = 1;
LABEL_10:
  if ( v9 < 0 || dword_806C290 != -1 || (v11 = fcntl(v9, 1), v11 >= 0) && (v7 = v11 | 1, fcntl(v9, 2, v11 | 1) != -1) )
  {
    dword_806B234 = (int)&loc_805F63C;
    sub_8061BAC();
    v5 = (int *)v8;
    v8 += 4;
    v13 = *v5;
    v7 = v13;
    v9 = fcntl(fd, cmd, v13);
  }
  else
  {
    v12 = *__errno_location();
    close(v9);
    *__errno_location() = v12;
    v9 = -1;
  }
  return v9;
}
// 8061BAC: using guessed type int sub_8061BAC(void);
// 806B234: using guessed type int dword_806B234;
// 806B2F4: using guessed type int dword_806B2F4;
// 806C290: using guessed type int dword_806C290;

//----- (0805F641) --------------------------------------------------------
int __cdecl sub_805F641(FILE *stream)
{
  int result; // eax

  result = stream->_flags & 0x100;
  if ( result )
    result = sub_805F6F0(stream, 0, 0, 1);
  return result;
}

//----- (0805F67A) --------------------------------------------------------
int __usercall sub_805F67A@<eax>(double a1@<st0>, FILE *fp)
{
  void *v2; // eax

  v2 = &loc_805F69F;
  if ( !fp )
    v2 = &loc_805F6C1;
  dword_806B20C = (int)v2;
  sub_8061C98(a1);
  __freading(fp);
  dword_806B234 = (int)&loc_805F6CE;
  sub_8061BAC();
  return fflush(fp);
}
// 8061BAC: using guessed type int sub_8061BAC(void);
// 8061C98: using guessed type int __usercall sub_8061C98@<eax>(double@<st0>);
// 806B20C: using guessed type int dword_806B20C;
// 806B234: using guessed type int dword_806B234;

//----- (0805F6F0) --------------------------------------------------------
int __cdecl sub_805F6F0(FILE *stream, int a2, int a3, int a4)
{
  int v4; // eax
  int v6; // edx
  __off64_t v7; // rax
  int v8; // ecx
  __off64_t v9; // [esp+28h] [ebp-10h]

  if ( stream->_IO_read_end != stream->_IO_read_ptr
    || stream->_IO_write_ptr != stream->_IO_write_base
    || stream->_IO_save_base )
  {
    return fseeko64(stream, a2, a3, a4);
  }
  v4 = fileno(stream);
  LODWORD(v7) = lseek64(v4, a2, a3, a4);
  v9 = v7;
  HIDWORD(v7) = ~HIDWORD(v7);
  if ( !(HIDWORD(v7) | ~(_DWORD)v7) )
  {
    dword_806B270 = (int)&locret_805F7F8;
    sub_8061A4C(v8, v6);
  }
  stream->_flags &= 0xFFFFFFEF;
  stream->_offset = v9;
  return 0;
}
// 80498B0: using guessed type int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8049A90: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8061A4C: using guessed type int __fastcall sub_8061A4C(_DWORD, _DWORD);
// 806B270: using guessed type int dword_806B270;

//----- (0805F7FA) --------------------------------------------------------
int __cdecl sub_805F7FA(wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  int v4; // edx
  int v5; // ecx
  void *v6; // eax
  int v7; // edx
  int v8; // ecx
  int result; // eax
  unsigned __int8 v10; // al
  char v11; // [esp+18h] [ebp-10h]
  size_t v12; // [esp+1Ch] [ebp-Ch]

  if ( !pwc )
    pwc = (wchar_t *)&v11;
  v12 = mbrtowc(pwc, s, n, p);
  if ( v12 <= 0xFFFFFFFD )
  {
    do
    {
      dword_806B284 = (int)&locret_805F86B;
      sub_80619DA(v5, v4);
      v10 = sub_8057768(0);
    }
    while ( !(v10 ^ 1) );
    *pwc = (unsigned __int8)*s;
    result = 1;
  }
  else
  {
    v6 = &loc_805F854;
    if ( !n )
      v6 = &loc_805F88F;
    dword_806B298 = (int)v6;
    sub_8061955(v5, v4);
    dword_806B220 = (int)&loc_805F8A9;
    result = sub_8061C20(v8, v7);
  }
  return result;
}
// 80619DA: using guessed type double __fastcall sub_80619DA(_DWORD, _DWORD);
// 8061C20: using guessed type int __fastcall sub_8061C20(_DWORD, _DWORD);
// 806B220: using guessed type int dword_806B220;
// 806B284: using guessed type int dword_806B284;
// 806B298: using guessed type int dword_806B298;

//----- (0805F8B7) --------------------------------------------------------
int __cdecl sub_805F8B7(int a1, int a2)
{
  int result; // eax

  if ( *(_BYTE *)(a1 + 40) & 1 )
    result = (*(int (__cdecl **)(_DWORD, int))(a1 + 28))(*(_DWORD *)(a1 + 36), a2);
  else
    result = (*(int (__cdecl **)(int))(a1 + 28))(a2);
  return result;
}

//----- (0805F901) --------------------------------------------------------
int __cdecl sub_805F901(int a1, int a2)
{
  int result; // eax

  if ( *(_BYTE *)(a1 + 40) & 1 )
    result = (*(int (__cdecl **)(_DWORD, int))(a1 + 32))(*(_DWORD *)(a1 + 36), a2);
  else
    result = (*(int (__cdecl **)(int))(a1 + 32))(a2);
  return result;
}

//----- (0805F93F) --------------------------------------------------------
signed int __cdecl sub_805F93F(int a1, signed int a2, int a3)
{
  void *v3; // eax
  _DWORD *v5; // [esp+1Ch] [ebp-Ch]

  v3 = &loc_805F964;
  if ( a3 )
    v3 = &loc_805F981;
  dword_806B2B8 = (int)v3;
  sub_8061881();
  if ( !a2 )
    a2 = 4064;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 24) = 7;
  *(_DWORD *)(a1 + 4) = sub_805F8B7(a1, *(_DWORD *)a1);
  v5 = *(_DWORD **)(a1 + 4);
  if ( !v5 )
    obstack_alloc_failed_handler();
  *(_DWORD *)(a1 + 8) = ((unsigned int)v5 + 15) & 0xFFFFFFF8;
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 8);
  *v5 = (char *)v5 + *(_DWORD *)a1;
  *(_DWORD *)(a1 + 16) = *v5;
  v5[1] = 0;
  *(_BYTE *)(a1 + 40) &= 0xFDu;
  *(_BYTE *)(a1 + 40) &= 0xFBu;
  return 1;
}
// 8061881: using guessed type int sub_8061881(void);
// 806B2B8: using guessed type int dword_806B2B8;
// 806B4E0: using guessed type int (*obstack_alloc_failed_handler)(void);

//----- (0805FA43) --------------------------------------------------------
signed int __cdecl sub_805FA43(int a1, signed int a2, int a3, int a4, int a5)
{
  *(_DWORD *)(a1 + 28) = a4;
  *(_DWORD *)(a1 + 32) = a5;
  *(_BYTE *)(a1 + 40) &= 0xFEu;
  return sub_805F93F(a1, a2, a3);
}

//----- (0805FACC) --------------------------------------------------------
int __cdecl sub_805FACC(int a1, int a2)
{
  void *v2; // eax
  int result; // eax
  _DWORD *v4; // [esp+14h] [ebp-24h]
  unsigned int v5; // [esp+18h] [ebp-20h]
  int v6; // [esp+1Ch] [ebp-1Ch]
  size_t n; // [esp+20h] [ebp-18h]
  size_t v8; // [esp+24h] [ebp-14h]
  size_t v9; // [esp+28h] [ebp-10h]
  void *dest; // [esp+2Ch] [ebp-Ch]

  v6 = *(_DWORD *)(a1 + 4);
  v4 = 0;
  n = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 8);
  v8 = n + a2;
  v9 = *(_DWORD *)(a1 + 24) + n + a2;
  v5 = (n >> 3) + v9 + 100;
  if ( v5 < v9 )
    v5 = v9;
  if ( *(_DWORD *)a1 > v5 )
    v5 = *(_DWORD *)a1;
  if ( n <= v8 )
    goto LABEL_8;
  while ( !v4 )
  {
    dword_806B248 = (int)&loc_805FB4D;
    sub_8061B34();
LABEL_8:
    if ( v8 <= v9 )
      v4 = (_DWORD *)sub_805F8B7(a1, v5);
  }
  *(_DWORD *)(a1 + 4) = v4;
  v4[1] = v6;
  *(_DWORD *)(a1 + 16) = (char *)v4 + v5;
  *v4 = *(_DWORD *)(a1 + 16);
  dest = (void *)(((unsigned int)v4 + *(_DWORD *)(a1 + 24) + 8) & ~*(_DWORD *)(a1 + 24));
  memcpy(dest, *(const void **)(a1 + 8), n);
  v2 = &loc_805FC21;
  if ( *(_BYTE *)(a1 + 40) & 2 )
    v2 = &loc_805FC63;
  dword_806B2CC = (int)v2;
  sub_80617DA();
  if ( *(_DWORD *)(a1 + 8) == ((*(_DWORD *)(a1 + 24) + v6 + 8) & ~*(_DWORD *)(a1 + 24)) )
  {
    v4[1] = *(_DWORD *)(v6 + 4);
    sub_805F901(a1, v6);
  }
  *(_DWORD *)(a1 + 8) = dest;
  *(_DWORD *)(a1 + 12) = n + *(_DWORD *)(a1 + 8);
  result = a1;
  *(_BYTE *)(a1 + 40) &= 0xFDu;
  return result;
}
// 80617DA: using guessed type int sub_80617DA(void);
// 8061B34: using guessed type int sub_8061B34(void);
// 806B248: using guessed type int dword_806B248;
// 806B2CC: using guessed type int dword_806B2CC;

//----- (0805FCD0) --------------------------------------------------------
int __cdecl sub_805FCD0(int a1, unsigned int a2)
{
  int result; // eax
  int *v3; // ST1C_4
  int *v4; // [esp+18h] [ebp-10h]

  result = *(_DWORD *)(a1 + 4);
  v4 = *(int **)(a1 + 4);
  while ( v4 )
  {
    if ( (unsigned int)v4 < a2 )
    {
      result = *v4;
      if ( *v4 >= a2 )
        break;
    }
    v3 = (int *)v4[1];
    sub_805F901(a1, (int)v4);
    v4 = v3;
    result = a1;
    *(_BYTE *)(a1 + 40) |= 2u;
  }
  if ( v4 )
  {
    *(_DWORD *)(a1 + 12) = a2;
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 16) = *v4;
    result = a1;
    *(_DWORD *)(a1 + 4) = v4;
  }
  else if ( a2 )
  {
    abort();
  }
  return result;
}

//----- (0805FEFB) --------------------------------------------------------
int __cdecl sub_805FEFB(int a1, char a2)
{
  return __ROR4__(a1, a2);
}

//----- (0805FFE6) --------------------------------------------------------
_BOOL4 __cdecl sub_805FFE6(signed int a1)
{
  void *v1; // eax
  int v2; // eax

  v1 = &loc_806000A;
  if ( a1 > 90 )
    v1 = &loc_8060019;
  dword_806B308 = (int)v1;
  v2 = sub_806160F();
  return v2 >= 65 || (unsigned int)(v2 - 48) <= 9;
}
// 806160F: using guessed type int sub_806160F(void);
// 806B308: using guessed type int dword_806B308;

//----- (0806002F) --------------------------------------------------------
_BOOL4 __cdecl sub_806002F(signed int a1)
{
  return a1 >= 65 && (a1 <= 90 || (unsigned int)(a1 - 97) <= 0x19);
}

//----- (080600C8) --------------------------------------------------------
_BOOL4 __cdecl sub_80600C8(int a1)
{
  return (unsigned int)(a1 - 48) <= 9;
}

//----- (080601B9) --------------------------------------------------------
_BOOL4 __cdecl sub_80601B9(signed int a1)
{
  return a1 >= 9 && (a1 <= 13 || a1 == 32);
}

//----- (0806022C) --------------------------------------------------------
#error "8060239: positive sp value has been found (funcsize=0)"

//----- (0806023A) --------------------------------------------------------
int __cdecl sub_806023A(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 65) > 0x19 )
    result = a1;
  else
    result = a1 + 32;
  return result;
}

//----- (0806028C) --------------------------------------------------------
int __cdecl sub_806028C(unsigned __int8 *a1, unsigned __int8 *a2)
{
  void *v2; // eax
  void *v3; // eax
  int v5; // [esp+0h] [ebp-28h]
  unsigned __int8 v6; // [esp+1Eh] [ebp-Ah]
  unsigned __int8 v7; // [esp+1Fh] [ebp-9h]

  v2 = &loc_80602B7;
  if ( a1 != a2 )
    v2 = &loc_80602D3;
  dword_806B248 = (int)v2;
  sub_8061B34();
  dword_806B2F4 = (int)&loc_8060331;
  sub_80616BF();
  v5 = *a1;
  v6 = sub_806023A(v5);
  v5 = *a2;
  v7 = sub_806023A(v5);
  v3 = &loc_8060314;
  if ( v6 )
    v3 = &loc_8060316;
  dword_806B2B8 = (int)v3;
  sub_8061881();
  return v6 - v7;
}
// 8061881: using guessed type int sub_8061881(void);
// 8061B34: using guessed type int sub_8061B34(void);
// 806B248: using guessed type int dword_806B248;
// 806B2B8: using guessed type int dword_806B2B8;
// 806B2F4: using guessed type int dword_806B2F4;

//----- (08060338) --------------------------------------------------------
int __usercall sub_8060338@<eax>(double a1@<st0>, FILE *fp)
{
  bool v2; // ST26_1
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  void *v6; // eax
  bool v8; // [esp+1Dh] [ebp-Bh]
  bool v9; // [esp+1Fh] [ebp-9h]

  v8 = __fpending(fp) != 0;
  v2 = ferror_unlocked(fp) != 0;
  v9 = sub_805F3D1(a1, fp) != 0;
  if ( !v2 )
  {
    v5 = &loc_806039C;
    if ( !v9 )
      v5 = &loc_80603E4;
    dword_806B2F4 = (int)v5;
    sub_80616BF();
    if ( !v8 && *__errno_location() == 9 )
      return 0;
  }
  v6 = &loc_80603D2;
  if ( v9 == 1 )
    v6 = &loc_80603DD;
  dword_806B31C = (int)v6;
  sub_8061576(v4, v3);
  *__errno_location() = 0;
  return -1;
}
// 8060338: could not find valid save-restore pair for ebx
// 8061576: using guessed type int __fastcall sub_8061576(_DWORD, _DWORD);
// 806B2F4: using guessed type int dword_806B2F4;
// 806B31C: using guessed type int dword_806B31C;

//----- (080603EB) --------------------------------------------------------
_DWORD *__userpurge sub_80603EB@<eax>(_DWORD *a1, double a2)
{
  signed int v2; // ST20_4
  double v3; // ST28_8
  int v4; // ST24_4
  int v6; // [esp+20h] [ebp-18h]
  int v7; // [esp+24h] [ebp-14h]

  if ( a2 <= -2147483648.0 )
  {
    sub_8060FD1(a1, 2147483648, 0);
  }
  else if ( 2147483648.0 <= a2 )
  {
    sub_8060FD1(a1, 0x7FFFFFFF, 999999999);
  }
  else
  {
    v2 = (signed int)a2;
    v3 = (a2 - (long double)v2) * 1000000000.0;
    v4 = (v3 > (long double)(signed int)v3) + (signed int)v3;
    v6 = v4 / 1000000000 + v2;
    v7 = v4 % 1000000000;
    if ( v7 < 0 )
    {
      --v6;
      v7 += 1000000000;
    }
    sub_8060FD1(a1, v6, v7);
  }
  return a1;
}

//----- (08060540) --------------------------------------------------------
int __cdecl sub_8060540(int fd, int a2)
{
  void *v2; // eax
  int v3; // ST20_4
  int v4; // ST24_4

  if ( fd >= 0 )
  {
    v2 = &loc_806056B;
    if ( fd > 2 )
      v2 = &loc_80605A5;
    dword_806B308 = (int)v2;
    sub_806160F();
    v3 = sub_80605AA(fd, a2);
    v4 = *__errno_location();
    close(fd);
    *__errno_location() = v4;
    fd = v3;
  }
  return fd;
}
// 806160F: using guessed type int sub_806160F(void);
// 806B308: using guessed type int dword_806B308;

//----- (080605AA) --------------------------------------------------------
int __cdecl sub_80605AA(int fd, int a2)
{
  int v2; // eax

  if ( a2 & 0x80000 )
  {
    v2 = 1030;
  }
  else
  {
    dword_806B234 = (int)&loc_80605C5;
    v2 = sub_8061BAC();
  }
  return sub_805F494(fd, v2, 3);
}
// 8061BAC: using guessed type int sub_8061BAC(void);
// 806B234: using guessed type int dword_806B234;

//----- (0806060A) --------------------------------------------------------
FILE *__usercall sub_806060A@<eax>(double a1@<st0>, int a2, char *modes)
{
  int v3; // eax
  bool v4; // zf
  void *v5; // eax
  int v6; // edx
  int v7; // ecx
  void *v8; // eax
  int v9; // ST30_4
  FILE *result; // eax
  void *v11; // eax
  int v12; // ST34_4
  FILE *stream; // [esp+1Ch] [ebp-1Ch]
  signed int v14; // [esp+20h] [ebp-18h]
  int fd; // [esp+24h] [ebp-14h]

  v3 = fopen64(a2, modes);
  stream = (FILE *)v3;
  v4 = v3 == 0;
  v5 = &loc_8060644;
  if ( v4 )
    v5 = &loc_8060739;
  dword_806B2CC = (int)v5;
  sub_80617DA();
  v14 = fileno(stream);
  if ( v14 < 0 )
    return stream;
  v8 = &loc_8060725;
  if ( v14 > 2 )
    v8 = &loc_8060739;
  dword_806B2E0 = (int)v8;
  sub_806174E(v7, v6);
  fd = sub_806109B(v14);
  if ( fd >= 0 )
  {
    if ( !sub_805F3D1(a1, stream) )
    {
      v4 = fdopen(fd, modes) == 0;
      v11 = &loc_8060706;
      if ( !v4 )
        v11 = &loc_8060739;
      dword_806B20C = (int)v11;
      sub_8061C98(a1);
    }
    v12 = *__errno_location();
    close(fd);
    *__errno_location() = v12;
    result = 0;
  }
  else
  {
    v9 = *__errno_location();
    sub_805F3D1(a1, stream);
    *__errno_location() = v9;
    result = 0;
  }
  return result;
}
// 806060A: could not find valid save-restore pair for ebx
// 80499F0: using guessed type int __cdecl fopen64(_DWORD, _DWORD);
// 806174E: using guessed type int __fastcall sub_806174E(_DWORD, _DWORD);
// 80617DA: using guessed type int sub_80617DA(void);
// 8061C98: using guessed type int __usercall sub_8061C98@<eax>(double@<st0>);
// 806B20C: using guessed type int dword_806B20C;
// 806B2CC: using guessed type int dword_806B2CC;
// 806B2E0: using guessed type int dword_806B2E0;

//----- (0806073E) --------------------------------------------------------
int __noreturn sub_806073E()
{
  void *v0; // eax
  int v1; // ecx
  void *v2; // eax
  signed int v3; // eax
  int v4; // edx
  int v5; // ecx
  void *v6; // eax
  int v7; // edx
  int v8; // ecx
  int v9; // edx
  int v10; // ecx
  void *v11; // eax
  int v12; // edx
  int v13; // ecx
  long double v14; // fst7
  void *v15; // eax
  int (*v16)(); // eax
  void *ptr; // [esp+14h] [ebp-B4h]
  void *v19; // [esp+18h] [ebp-B0h]
  char *s; // [esp+1Ch] [ebp-ACh]
  void *v21; // [esp+20h] [ebp-A8h]
  int v22; // [esp+24h] [ebp-A4h]
  char *v23; // [esp+28h] [ebp-A0h]
  size_t n; // [esp+2Ch] [ebp-9Ch]
  size_t v25; // [esp+30h] [ebp-98h]
  int v26; // [esp+34h] [ebp-94h]
  void *dest; // [esp+38h] [ebp-90h]
  int fd; // [esp+3Ch] [ebp-8Ch]
  FILE *stream; // [esp+40h] [ebp-88h]
  int c; // [esp+44h] [ebp-84h]
  unsigned int v31; // [esp+BCh] [ebp-Ch]

  v31 = __readgsdword(0x14u);
  v19 = (void *)dword_806C294;
  if ( !dword_806C294 )
  {
    ptr = 0;
    v23 = "charset.alias";
    s = getenv("CHARSETALIASDIR");
    if ( s )
    {
      v0 = &loc_80607C0;
      if ( *s )
        v0 = &loc_80607D4;
      dword_806B2B8 = (int)v0;
      sub_8061881();
    }
    ptr = 0;
    s = "/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib";
    n = strlen("/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib");
    v25 = strlen(v23);
    if ( n )
    {
      v2 = &loc_8060836;
      if ( s[n - 1] == 47 )
        v2 = &loc_806083D;
      dword_806B31C = (int)v2;
      sub_8061576(v1, n - 1);
      v3 = 1;
    }
    else
    {
      v3 = 0;
    }
    v26 = v3;
    dest = malloc(n + v3 + v25 + 1);
    if ( dest )
    {
      memcpy(dest, s, n);
      v6 = &loc_80608C0;
      if ( !v26 )
        v6 = &loc_80608D1;
      dword_806B2E0 = (int)v6;
      sub_806174E(v5, v4);
      *((_BYTE *)dest + n) = 47;
      memcpy((char *)dest + n + v26, v23, v25 + 1);
    }
    free(ptr);
    if ( dest )
    {
      fd = open64(dest, 0x20000);
      if ( fd < 0 )
      {
        v19 = &unk_8065137;
        dword_806B220 = (int)&loc_8060C50;
        sub_8061C20(v8, v7);
      }
      stream = fdopen(fd, "r");
      if ( stream )
      {
        v21 = 0;
        v22 = 0;
        while ( 1 )
        {
          c = getc_unlocked(stream);
          if ( c == -1 )
          {
            dword_806B248 = (int)&loc_8060BF4;
            sub_8061B34();
          }
          if ( c != 10 )
          {
            v11 = &loc_8060A27;
            if ( c == 32 )
              v11 = &loc_8060A30;
            dword_806B284 = (int)v11;
            v14 = sub_80619DA(v10, v9);
            if ( c != 9 )
            {
              v15 = &loc_8060A57;
              if ( c != 35 )
                v15 = &loc_8060A90;
              dword_806B2E0 = (int)v15;
              sub_806174E(v13, v12);
              do
                c = getc_unlocked(stream);
              while ( c != -1 && c != 10 );
              if ( c == -1 )
                break;
            }
          }
        }
        sub_805F3D1(*(double *)&v14, stream);
        if ( !v22 )
        {
          v19 = &unk_8065137;
          dword_806B234 = (int)&loc_8060C50;
          sub_8061BAC();
        }
        *((_BYTE *)v21 + v22) = 0;
        v19 = v21;
      }
      else
      {
        close(fd);
        v19 = &unk_8065137;
      }
      free(dest);
    }
    else
    {
      v19 = &unk_8065137;
    }
    dword_806C294 = (int)v19;
  }
  v16 = (int (*)())&loc_8060C94;
  if ( __readgsdword(0x14u) == v31 )
    v16 = sub_8060C99;
  dword_806B308 = (int)v16;
  return sub_806160F();
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 8060C99: using guessed type int sub_8060C99();
// 8061576: using guessed type int __fastcall sub_8061576(_DWORD, _DWORD);
// 806160F: using guessed type int sub_806160F(void);
// 806174E: using guessed type int __fastcall sub_806174E(_DWORD, _DWORD);
// 8061881: using guessed type int sub_8061881(void);
// 80619DA: using guessed type double __fastcall sub_80619DA(_DWORD, _DWORD);
// 8061B34: using guessed type int sub_8061B34(void);
// 8061BAC: using guessed type int sub_8061BAC(void);
// 8061C20: using guessed type int __fastcall sub_8061C20(_DWORD, _DWORD);
// 806B220: using guessed type int dword_806B220;
// 806B234: using guessed type int dword_806B234;
// 806B248: using guessed type int dword_806B248;
// 806B284: using guessed type int dword_806B284;
// 806B2B8: using guessed type int dword_806B2B8;
// 806B2E0: using guessed type int dword_806B2E0;
// 806B308: using guessed type int dword_806B308;
// 806B31C: using guessed type int dword_806B31C;
// 806C294: using guessed type int dword_806C294;

//----- (08060C99) --------------------------------------------------------
#error "8060C9F: positive sp value has been found (funcsize=0)"

//----- (08060CA2) --------------------------------------------------------
void __noreturn sub_8060CA2()
{
  bool v1; // zf
  int v2; // edx
  int v3; // ecx
  void *v4; // eax

  v1 = nl_langinfo(14) == 0;
  v4 = &loc_8060CD6;
  if ( !v1 )
    v4 = &loc_8060CDD;
  dword_806B31C = (int)v4;
  sub_8061576(v3, v2);
  sub_806073E();
}
// 8061576: using guessed type int __fastcall sub_8061576(_DWORD, _DWORD);
// 806B31C: using guessed type int dword_806B31C;

//----- (08060DB5) --------------------------------------------------------
int __cdecl sub_8060DB5(char *s, int a2, char *s2, int a4)
{
  size_t v4; // ST18_4
  int v5; // edx
  int v6; // ecx
  size_t v7; // ST1C_4
  int v9; // edx
  int v10; // ecx

  do
  {
    *__errno_location() = 0;
    if ( strcoll(s, s2) || *__errno_location() )
    {
      dword_806B220 = (int)&loc_8060E7F;
      sub_8061C20(v10, v9);
    }
    v4 = strlen(s) + 1;
    v7 = strlen(s2) + 1;
    s += v4;
    s2 += v7;
    a2 -= v4;
    a4 -= v7;
    if ( !a2 )
    {
      dword_806B298 = (int)&locret_8060E8A;
      sub_8061955(v6, v5);
    }
  }
  while ( a4 );
  return 1;
}
// 8061C20: using guessed type int __fastcall sub_8061C20(_DWORD, _DWORD);
// 806B220: using guessed type int dword_806B220;
// 806B298: using guessed type int dword_806B298;

//----- (08060E8C) --------------------------------------------------------
int __cdecl sub_8060E8C(void *s1, size_t n, void *s2, int a4)
{
  char v4; // ST1A_1
  char v5; // ST1B_1
  int v7; // [esp+1Ch] [ebp-Ch]

  if ( n == a4 && !memcmp(s1, s2, n) )
  {
    *__errno_location() = 0;
    v7 = 0;
  }
  else
  {
    v4 = *((_BYTE *)s1 + n);
    v5 = *((_BYTE *)s2 + a4);
    *((_BYTE *)s1 + n) = 0;
    *((_BYTE *)s2 + a4) = 0;
    v7 = sub_8060DB5((char *)s1, n + 1, (char *)s2, a4 + 1);
    *((_BYTE *)s1 + n) = v4;
    *((_BYTE *)s2 + a4) = v5;
  }
  return v7;
}

//----- (08060F72) --------------------------------------------------------
int __cdecl sub_8060F72(void *s1, size_t n, void *s2, int a4)
{
  if ( n != a4 || memcmp(s1, s2, n) )
    return sub_8060DB5((char *)s1, n, (char *)s2, a4);
  *__errno_location() = 0;
  return 0;
}

//----- (08060FD1) --------------------------------------------------------
_DWORD *__userpurge sub_8060FD1@<eax>(_DWORD *a1, int a2, int a3)
{
  *a1 = a2;
  a1[1] = a3;
  return a1;
}

//----- (0806109B) --------------------------------------------------------
int __cdecl sub_806109B(int fd)
{
  return sub_805F494(fd, 0, 3);
}

//----- (080610C0) --------------------------------------------------------
__int64 __cdecl sub_80610C0(unsigned int a1, unsigned int a2, int a3, int a4)
{
  void *v4; // eax
  unsigned int v5; // edx
  unsigned int v6; // ecx
  unsigned int v7; // esi
  __int64 result; // rax

  v4 = &loc_80610FC;
  if ( a4 )
    v4 = &loc_806112C;
  dword_806B298 = (int)v4;
  sub_8061955(a3, a2);
  if ( v6 > a2 )
    return (unsigned int)(__PAIR__(v5, a1) / v6);
  v7 = v6;
  if ( !v6 )
    v7 = 1 / 0u;
  LODWORD(result) = __PAIR__(a2 % v7, a1) / v7;
  HIDWORD(result) = a2 / v7;
  return result;
}
// 806B298: using guessed type int dword_806B298;

//----- (0806123A) --------------------------------------------------------
char *__cdecl sub_806123A(unsigned __int64 a1, __int64 a2)
{
  char *v2; // edx
  char *result; // eax
  int v4; // ebp
  int v5; // ebp
  unsigned int v6; // ebp
  unsigned __int64 v7; // rtt
  unsigned __int64 v8; // rax
  unsigned int v9; // edi
  unsigned __int64 v10; // rax
  unsigned int v11; // ecx
  int v12; // ebp
  int v13; // esi
  void *v14; // eax
  void *v15; // [esp-1Ch] [ebp-3Ch]
  const void *v16; // [esp-18h] [ebp-38h]
  size_t v17; // [esp-14h] [ebp-34h]
  unsigned int v18; // [esp+0h] [ebp-20h]
  unsigned int v19; // [esp+4h] [ebp-1Ch]
  unsigned __int64 v20; // [esp+8h] [ebp-18h]
  unsigned int v21; // [esp+10h] [ebp-10h]

  v19 = HIDWORD(a1);
  v21 = a1;
  v18 = a2;
  v20 = a1;
  if ( HIDWORD(a2) )
  {
    if ( HIDWORD(a2) > HIDWORD(a1) )
    {
      result = (char *)a1;
    }
    else
    {
      _BitScanReverse((unsigned int *)&v4, HIDWORD(a2));
      v5 = v4 ^ 0x1F;
      if ( v5 )
      {
        v19 = (HIDWORD(a2) << v5) | (v18 >> (32 - v5));
        LODWORD(v20) = v18 << v5;
        HIDWORD(v8) = HIDWORD(a1) >> (32 - v5);
        LODWORD(v8) = (HIDWORD(a1) << v5) | (v21 >> (32 - v5));
        HIDWORD(v20) = v21 << v5;
        v9 = v8 % v19;
        v10 = (v18 << v5) * (unsigned __int64)(unsigned int)(v8 / v19);
        v18 = HIDWORD(v10);
        v11 = v10;
        if ( v9 < HIDWORD(v10) || HIDWORD(v20) < (unsigned int)v10 && v9 == HIDWORD(v10) )
        {
          HIDWORD(v10) = v18;
          HIDWORD(v10) = (v10 - __PAIR__(v19, (unsigned int)v20)) >> 32;
          v11 = v10 - v20;
        }
        result = (char *)(((__PAIR__(v9, HIDWORD(v20)) - __PAIR__(HIDWORD(v10), v11)) >> 32 << (32 - (unsigned __int8)v5)) | ((HIDWORD(v20) - v11) >> v5));
      }
      else if ( v18 <= (unsigned int)v20 || HIDWORD(a2) < HIDWORD(v20) )
      {
        result = (char *)(a1 - a2);
      }
      else
      {
        dword_806B31C = (int)&loc_80612AB;
        sub_8061576(a1, HIDWORD(a2));
        v12 = HIDWORD(v20);
        memcpy(v15, v16, v17);
        result = (char *)&stru_806AEFC.d_un;
        v13 = ((char *)&stru_806AF04 - (char *)&stru_806AEFC.d_un) >> 2;
        if ( v13 )
        {
          ((void (__cdecl *)(unsigned int, _DWORD, int))stru_806AEFC.d_un.d_val)(v19, v20, v12);
          v14 = &loc_806140F;
          if ( v13 != 1 )
            v14 = &loc_80613D9;
          dword_806B2CC = (int)v14;
          result = (char *)sub_80617DA();
        }
      }
    }
  }
  else
  {
    if ( (unsigned int)a2 <= HIDWORD(a1) )
    {
      v6 = a2;
      if ( !(_DWORD)a2 )
        v6 = 1 / 0u;
      LODWORD(v7) = a1;
      HIDWORD(v7) = v19 % v6;
      v2 = (char *)(v7 % v6);
    }
    else
    {
      v2 = (char *)(a1 % (unsigned int)a2);
    }
    result = v2;
  }
  return result;
}
// 8061576: using guessed type int __fastcall sub_8061576(_DWORD, _DWORD);
// 80617DA: using guessed type int sub_80617DA(void);
// 806AEFC: using guessed type Elf32_Dyn;
// 806AF04: using guessed type Elf32_Dyn stru_806AF04;
// 806B2CC: using guessed type int dword_806B2CC;
// 806B31C: using guessed type int dword_806B31C;

//----- (08061428) --------------------------------------------------------
int __cdecl sub_8061428(int a1)
{
  int v1; // edx
  int v2; // ecx

  __cxa_atexit(a1, 0, dword_806B334);
  dword_806B248 = (int)&loc_8061480;
  sub_8061B34();
  dword_806B270 = (int)sub_806148D;
  return sub_8061A4C(v2, v1);
}
// 8049AC0: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 8061A4C: using guessed type int __fastcall sub_8061A4C(_DWORD, _DWORD);
// 8061B34: using guessed type int sub_8061B34(void);
// 806B248: using guessed type int dword_806B248;
// 806B270: using guessed type int dword_806B270;
// 806B334: using guessed type int dword_806B334;

//----- (0806148D) --------------------------------------------------------
int __cdecl sub_806148D(int a1, int a2)
{
  int v2; // edx
  int v3; // ecx
  int v5; // [esp-Ch] [ebp-10h]
  int v6; // [esp-8h] [ebp-Ch]
  int v7; // [esp-4h] [ebp-8h]
  int v8; // [esp+0h] [ebp-4h]

  __xstat64(3, a1, a2, v5, v6, v7, v8);
  dword_806B284 = (int)sub_80614D0;
  sub_80619DA(v3, v2);
  return sub_80614E1(a1, a2);
}
// 8049EB0: using guessed type int __stdcall __xstat64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80614D0: using guessed type int sub_80614D0();
// 80619DA: using guessed type double __fastcall sub_80619DA(_DWORD, _DWORD);
// 806B284: using guessed type int dword_806B284;

//----- (080614D0) --------------------------------------------------------
#error "80614D3: positive sp value has been found (funcsize=0)"

//----- (080614E1) --------------------------------------------------------
int __cdecl sub_80614E1(int a1, int a2)
{
  return __fxstat64(3, a1, a2);
}
// 8049A30: using guessed type int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD);

//----- (08061576) --------------------------------------------------------
#error "806157C: positive sp value has been found (funcsize=0)"

//----- (080615C0) --------------------------------------------------------
#error "8061607: positive sp value has been found (funcsize=11)"

//----- (0806160F) --------------------------------------------------------
#error "8061615: positive sp value has been found (funcsize=0)"

//----- (0806166E) --------------------------------------------------------
#error "8061695: positive sp value has been found (funcsize=9)"

//----- (080616BF) --------------------------------------------------------
#error "80616C5: positive sp value has been found (funcsize=0)"

//----- (0806170D) --------------------------------------------------------
#error "8061746: positive sp value has been found (funcsize=18)"

//----- (0806174E) --------------------------------------------------------
#error "8061754: positive sp value has been found (funcsize=0)"

//----- (080617DA) --------------------------------------------------------
#error "80617E0: positive sp value has been found (funcsize=0)"

//----- (08061881) --------------------------------------------------------
#error "8061887: positive sp value has been found (funcsize=0)"

//----- (08061955) --------------------------------------------------------
#error "806195B: positive sp value has been found (funcsize=0)"

//----- (080619DA) --------------------------------------------------------
#error "80619E0: positive sp value has been found (funcsize=0)"

//----- (08061A4C) --------------------------------------------------------
#error "8061A52: positive sp value has been found (funcsize=0)"

//----- (08061AC4) --------------------------------------------------------
#error "8061ACA: positive sp value has been found (funcsize=0)"

//----- (08061B34) --------------------------------------------------------
#error "8061B3A: positive sp value has been found (funcsize=0)"

//----- (08061BAC) --------------------------------------------------------
#error "8061BB2: positive sp value has been found (funcsize=0)"

//----- (08061C20) --------------------------------------------------------
#error "8061C26: positive sp value has been found (funcsize=0)"

//----- (08061C98) --------------------------------------------------------
#error "8061C9E: positive sp value has been found (funcsize=0)"

//----- (08061CB0) --------------------------------------------------------
int (**sub_8061CB0())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_806AEC0;
  v1 = &off_806AEC4 - off_806AEC0;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_806AEC0[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 806AEC0: using guessed type int (*off_806AEC0[2])();
// 806AEC4: using guessed type int (*off_806AEC4)();

//----- (08061D14) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 25 decompilation failure(s) on 348 function(s)"
