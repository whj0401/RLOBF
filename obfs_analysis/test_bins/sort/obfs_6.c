/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8049750();
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// int raise(int sig);
// int dup2(int fd, int fd2);
// int strcmp(const char *s1, const char *s2);
// int putc_unlocked(int c, FILE *stream);
// ssize_t read(int fd, void *buf, size_t nbytes);
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void _exit(int status);
// void *memmove(void *dest, const void *src, size_t n);
// void free(void *ptr);
// uintmax_t strtoumax(const char *nptr, char **endptr, int base);
// void *memcpy(void *dest, const void *src, size_t n);
// int ferror(FILE *stream);
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// int fclose(FILE *stream);
// int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
// int getc_unlocked(FILE *stream);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// __sighandler_t signal(int sig, __sighandler_t handler);
// int __cdecl __sched_cpucount(_DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// double __cdecl strtold(_DWORD, _DWORD); weak
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// int fputc_unlocked(int c, FILE *stream);
// int __cdecl getrlimit64(_DWORD, _DWORD); weak
// int __cdecl stpcpy(_DWORD, _DWORD); weak
// int execlp(const char *file, const char *arg, ...);
// int sysconf(int name);
// __uid_t getuid(void);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// int unlink(const char *name);
// int sigismember(const sigset_t *set, int signo);
// int fflush_unlocked(FILE *stream);
// char *textdomain(const char *domainname);
// int __cdecl fopen64(_DWORD, _DWORD); weak
// int ferror_unlocked(FILE *stream);
// int __cdecl mkostemp64(_DWORD, _DWORD); weak
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD); weak
// size_t __ctype_get_mb_cur_max(void);
// __pid_t waitpid(__pid_t pid, int *stat_loc, int options);
// int pthread_sigmask(int how, const __sigset_t *newmask, __sigset_t *oldmask);
// char *strcpy(char *dest, const char *src);
// size_t __fpending(FILE *fp);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// __pid_t getpid(void);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// int pthread_cond_signal(pthread_cond_t *cond);
// void error(int status, int errnum, const char *format, ...);
// size_t fread_unlocked(void *ptr, size_t size, size_t n, FILE *stream);
// int strcoll(const char *s1, const char *s2);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int sysinfo(struct sysinfo *info);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// char *strchr(const char *s, int c);
// int fscanf(FILE *stream, const char *format, ...);
// size_t strlen(const char *s);
// int fprintf(FILE *stream, const char *format, ...);
// ssize_t write(int fd, const void *buf, size_t n);
// int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *cond_attr);
// int __cdecl open64(_DWORD, _DWORD); weak
// int fcntl(int fd, int cmd, ...);
// int sigaddset(sigset_t *set, int signo);
// size_t strxfrm(char *dest, const char *src, size_t n);
// int setvbuf(FILE *stream, char *buf, int modes, size_t n);
// __gid_t getgid(void);
// void *memset(void *s, int c, size_t n);
// int ungetc(int c, FILE *stream);
// int *__errno_location(void);
// int fileno(FILE *stream);
// int fgetc(FILE *stream);
// int pipe(int pipedes[2]);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// __pid_t fork(void);
// int sigemptyset(sigset_t *set);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// int toupper(int c);
// void clearerr_unlocked(FILE *stream);
// char *strrchr(const char *s, int c);
// int pthread_join(pthread_t th, void **thread_return);
// struct lconv *localeconv(void);
// __pid_t getppid(void);
// int __cdecl explicit_bzero(_DWORD); weak
// int __cdecl pipe2(_DWORD, _DWORD); weak
// int euidaccess(void); weak
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int nanosleep(const struct timespec *requested_time, struct timespec *remaining);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// char *bindtextdomain(const char *domainname, const char *dirname);
// int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl sched_getaffinity(_DWORD, _DWORD, _DWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// int feof_unlocked(FILE *stream);
// void abort(void);
// int __cdecl __xstat64(_DWORD, _DWORD, _DWORD); weak
// int strtol(const char *nptr, char **endptr, int base);
// char *ngettext(const char *msgid1, const char *msgid2, unsigned int n);
// int close(int fd);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// void *calloc(size_t nmemb, size_t size);
// int _gmon_start__(void); weak
void sub_8049F73();
void sub_8049F90();
int sub_8049FA0();
int sub_804A010();
int sub_804A030();
void sub_804A08F();
void sub_804A0AA();
int sub_804A0BA();
void sub_804A19C();
void sub_804A1B7();
signed int sub_804A1C7();
void sub_804A2A9();
void sub_804A2C4();
int sub_804A2D4();
void sub_804A3B6();
void sub_804A3D1();
int sub_804A3E1();
void sub_804A4D8();
void sub_804A4F3();
int sub_804A503();
void sub_804A5E5();
void sub_804A600();
int sub_804A610();
void sub_804A6F2();
void sub_804A70D();
int sub_804A71D();
int nullsub_3(void); // weak
int sub_804A77B();
// int __usercall sub_804A7E8@<eax>(void (__cdecl *a1)(int *)@<eax>);
void sub_804A834();
void sub_804A84F();
int sub_804A85F();
// int __usercall sub_804A8C6@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
void sub_804A95D();
void sub_804A978();
int __fastcall sub_804A988(int a1, int a2);
void sub_804AA9B();
void sub_804AAB6();
int sub_804AAC6();
int sub_804AAF3();
// int __usercall sub_804ABA4@<eax>(void (__cdecl *a1)(int *)@<eax>);
void sub_804ABF0();
void sub_804AC0B();
void sub_804AD1C();
void sub_804AD37();
int sub_804AD47();
int __cdecl sub_804ADFD(int a1);
int __cdecl sub_804AE10(unsigned __int8 a1);
int __cdecl sub_804AE22(unsigned __int8 a1);
int __cdecl sub_804AE62(unsigned __int64 a1);
int sub_804AEA8();
int sub_804AED3();
int __cdecl sub_804AEFE(char *s1); // idb
void __cdecl __noreturn sub_804B094(int a1, const char *a2);
void __cdecl __noreturn sub_804B16A(int a1, char *a2);
void __cdecl __noreturn sub_804B1CC(int status); // idb
int __cdecl sub_804B488(int a1);
int __cdecl sub_804B4BD(unsigned __int8 *a1);
int __cdecl sub_804B4ED(int a1, unsigned int a2);
bool __cdecl sub_804B51C(int a1, int a2);
int __cdecl sub_804B551(__pid_t pid); // idb
int __cdecl sub_804B65D(int a1);
signed int __cdecl sub_804B6D1(int a1);
int __cdecl sub_804B73C(__pid_t pid); // idb
int __fastcall sub_804B75E(int a1, int a2);
int sub_804B7AF();
int sub_804B7C8(void); // weak
int sub_804B7FC();
int sub_804B849();
void *__cdecl sub_804B883(_DWORD *a1, char a2);
int __cdecl sub_804BAA0(char *s1, char *modes); // idb
int __cdecl sub_804BC34(char *s1, char *modes); // idb
int __cdecl sub_804BC75(FILE *stream, int); // idb
int __cdecl sub_804BD31(int fd, int fd2); // idb
__pid_t __cdecl sub_804BD5E(int pipedes[2], int a2);
char *__cdecl sub_804BF08(FILE **a1, char a2);
char *__cdecl sub_804C077(FILE **a1);
FILE *__cdecl sub_804C092(int a1);
int __cdecl sub_804C256(int a1);
_DWORD __cdecl sub_804C2AE(_DWORD); // weak
int compar(const void *, const void *); // idb
int sub_804C473(void); // weak
// unsigned int __usercall sub_804C718@<eax>(int a1@<ebx>, int a2, char a3, char *a4);
int __cdecl sub_804C9B1(int, int, char *nptr); // idb
// int __usercall sub_804CC90@<eax>(int a1@<ebx>, int a2, int a3, char *nptr);
int __cdecl sub_804CFB8(FILE **a1, unsigned int a2, int *a3, unsigned int a4, int a5);
void __cdecl __noreturn sub_804D1D2(int, int, size_t size); // idb
int sub_804D230(); // weak
int __cdecl sub_804D27D(_DWORD *a1);
_DWORD __cdecl sub_804D2A8(_DWORD, _DWORD); // weak
_DWORD __cdecl sub_804D44C(_DWORD, _DWORD); // weak
int __cdecl sub_804D5D7(int, FILE *stream, int); // idb
int __cdecl sub_804DA4B(char **a1);
int __cdecl sub_804DB10(_BYTE *a1);
int __cdecl sub_804DB88(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_804DC2E(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_804DCA5(int a1, int a2);
signed int __cdecl sub_804DD29(int a1, unsigned int a2);
_DWORD __cdecl sub_804DE55(_DWORD, _DWORD); // weak
void __cdecl __noreturn sub_804DFAF(char *a1);
int __cdecl sub_804E06A(int, int); // weak
size_t __cdecl sub_804E0A4(char *dest, char *src, size_t n);
int __cdecl sub_804E17C(int, int, int, size_t); // idb
_DWORD __cdecl sub_804E7FB(_DWORD, _DWORD); // weak
int __cdecl sub_804E870(int a1, int a2);
int __cdecl sub_804E903(_BYTE *a1);
int __cdecl sub_804E939(int *a1, int a2);
_DWORD __cdecl sub_804EBAB(_DWORD); // weak
int __cdecl sub_804EC40(int a1);
_BYTE *__cdecl sub_804ECC4(int a1, _BYTE *a2);
// unsigned int __usercall sub_804EDDA@<eax>(char *a1@<ebx>, int *a2, unsigned __int8 a3);
_DWORD __cdecl sub_804F668(_DWORD, _DWORD); // weak
int __cdecl sub_80503C7(int a1, int a2);
int __cdecl sub_8050516(int, FILE *stream, int); // idb
void __cdecl __noreturn sub_8050634(size_t size, size_t n, FILE *stream); // idb
void __cdecl __noreturn sub_805069F(char *a1, int a2);
int __cdecl sub_8050A64(int a1, unsigned int a2, int *a3);
void __cdecl sub_8050B96(int a1, int a2, int a3, FILE *stream, int a5, void *a6);
int __cdecl sub_805162A(int, int, int, FILE *stream, int); // idb
_DWORD __cdecl sub_80516DB(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_8051815(int a1, unsigned int a2, int a3, unsigned __int8 a4);
int __cdecl sub_8051CC9(pthread_mutexattr_t *mutexattr, int, int, int, int); // idb
_BOOL4 __cdecl sub_8051DED(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8051E6C(pthread_mutex_t *a1);
int __cdecl sub_8051E82(pthread_mutex_t *a1);
int __cdecl sub_8051EC9(int a1, int a2);
int __cdecl sub_8051F17(int a1, int a2);
pthread_mutex_t *__cdecl sub_8051F64(int a1);
int __cdecl sub_8051FCD(int, FILE *stream, int); // idb
// int __usercall sub_8052055@<eax>(int a1@<ebx>, int a2, int a3, FILE *stream, int a5);
_DWORD __cdecl sub_805252E(_DWORD, _DWORD); // weak
_DWORD __cdecl sub_8052606(_DWORD, _DWORD); // weak
// int __usercall sub_8052688@<eax>(int a1@<ebx>, int a2, int a3, FILE *stream, int a5);
void *start_routine(void *); // idb
// int __usercall sub_8052799@<eax>(int a1@<ebx>, int a2, int a3, int a4, int a5, int a6, FILE *stream, int a8);
int __cdecl sub_8052A03(int, int, int, char *s1); // idb
unsigned int __cdecl sub_8052C52(int a1, unsigned int a2);
void __cdecl sub_8052D88(int a1, int a2, int a3, char *s1);
unsigned int __cdecl sub_8053238(int a1, int a2, char *a3);
_DWORD *__cdecl sub_80536F0(void *src);
void __cdecl __noreturn sub_805373D(int, char *msgid); // idb
int __cdecl __noreturn sub_805378B(int a1);
int sub_80538FA(); // weak
int __cdecl sub_80538FC(char *nptr, int, char *msgid); // idb
int __cdecl sub_80539F6(int sig); // idb
_DWORD __cdecl sub_8053A21(_DWORD, _DWORD, _DWORD); // weak
void *__cdecl sub_8053B3C(void *s);
int __cdecl main(int, char **, char **); // idb
int __cdecl sub_8054E88(int, int, int, int, int, int, int, int, int, int, char, char, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, char src, int, int, int, int, int, __int16); // idb
void __noreturn sub_80553CC();
int __cdecl sub_80553E0(char *s, int a2);
void __cdecl sub_8055535(int a1, int a2, int a3);
int __cdecl sub_80555B8(int, int, size_t n); // idb
_DWORD __cdecl sub_80556DF(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int sub_8055881();
_DWORD *__cdecl sub_805597E(_DWORD *a1);
_DWORD *__cdecl sub_80559DA(_DWORD *a1, int a2);
_DWORD *__cdecl sub_80559E7(int *a1, _DWORD *a2);
_DWORD *__cdecl sub_8055A64(int *a1, _DWORD *a2);
_DWORD __cdecl sub_8055D2E(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_8055DA7(void *src, size_t n); // idb
int *__cdecl sub_8055F9D(int *a1, unsigned int a2, int *a3);
int __cdecl sub_8056C97(int a1, int a2, int a3, int a4, int a5, int a6);
void __cdecl sub_8056CF8(FILE *stream, int a2);
_BYTE *__cdecl sub_8056D40(_BYTE **a1);
int __cdecl sub_8056E10(unsigned __int8 a1);
int __cdecl sub_8056E62(int a1, unsigned int a2, int a3, unsigned int a4);
int __cdecl sub_80570DE(char *s1, char *s2); // idb
int __cdecl sub_8057327(int category); // idb
int __cdecl sub_8057385(int a1);
int __cdecl sub_8057390(int a1);
int __cdecl sub_805739B(int a1);
unsigned int __cdecl sub_80573A6(int a1);
int __cdecl sub_805758B(_DWORD *a1, int a2);
_DWORD __cdecl sub_80578D5(_DWORD); // weak
int __cdecl sub_8057953(unsigned int a1);
unsigned int __cdecl sub_80579D4(int a1, unsigned int a2);
bool __cdecl sub_8057A00(int a1, int a2);
signed int __cdecl sub_8057A0E(int a1);
_DWORD __cdecl sub_8057ACB(_DWORD, _DWORD); // weak
size_t *__cdecl sub_8057BA9(int a1, void *a2, unsigned int (__cdecl *a3)(int a1, unsigned int a2), bool (__cdecl *a4)(int a1, int a2), size_t a5);
void *__cdecl sub_8057ED4(int a1);
int __cdecl sub_8057F0F(int a1, _DWORD *a2);
int __cdecl sub_8057F42(_DWORD *a1, int a2, int **a3, char a4);
signed int __cdecl sub_80580EE(_DWORD *a1, int a2, char a3);
signed int __cdecl sub_8058299(int a1, int a2);
signed int __cdecl sub_8058471(_DWORD *a1, int a2, _DWORD *a3);
int __cdecl sub_805873E(_DWORD *a1, int a2);
_DWORD __cdecl sub_805877E(_DWORD, _DWORD); // weak
int *__cdecl sub_80589CF(int (*a1)(), unsigned int a2);
int sub_8058A54();
void __cdecl sub_8058A5F(void *ptr);
int __cdecl sub_8058A7F(int a1, int a2);
int __cdecl sub_8058B19(_DWORD *a1);
_DWORD __cdecl sub_8058BA6(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_8058CCE(int a1, unsigned int a2, int (__cdecl *a3)(_DWORD, int));
int __cdecl sub_8058D8E(int a1, int a2);
int __cdecl sub_8058E88(unsigned int a1, int a2);
int __cdecl sub_8058EF6(unsigned __int64 a1, int a2);
int __cdecl sub_8058FC9(char *a1, int a2, char a3);
int sub_8059282();
_DWORD __cdecl sub_80592E2(_DWORD); // weak
int __cdecl sub_80593AA(char *nptr); // idb
long double sub_8059511();
long double sub_80595D0();
int __cdecl sub_80596AA(int pipedes[2], int); // idb
int sub_8059928();
int __cdecl sub_805999F(char *s); // idb
int __cdecl sub_8059B6C(int a1, unsigned __int8 a2, char a3);
int *__cdecl sub_8059C4F(int *a1, int a2, int a3);
int __cdecl sub_8059C90(_DWORD, _DWORD); // weak
char *__cdecl sub_8059D48(char *msgid);
void __cdecl sub_8059E14(int a1, int a2, int a3, int a4, unsigned int a5, int a6, int a7, int a8, int a9);
// void __usercall sub_805A273(int a1@<ebp>);
// void __usercall sub_805A3D7(int a1@<ebp>, int a2, int a3, int a4, int a5, char a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30);
int __cdecl sub_805ACFE(int a1, int a2, _DWORD *a3, int *a4);
void *__cdecl sub_805AEC5(signed int a1, int a2, int a3, unsigned int *a4);
void *__cdecl sub_805B144(signed int a1, int a2);
void *__cdecl sub_805B16E(signed int a1, int a2, int a3);
void *__cdecl sub_805B1E4(signed int a1, int a2, int a3);
void *__cdecl sub_805B222(signed int a1, int a2, int a3, int a4);
void *__cdecl sub_805B25F(int a1, int a2);
void *__cdecl sub_805B2BA(int a1, int a2, unsigned __int8 a3);
_DWORD __cdecl sub_805B374(_DWORD, _DWORD); // weak
int __cdecl sub_805B3C2(int a1);
void *__cdecl sub_805B3FF(signed int a1, int a2, int a3);
void *__cdecl sub_805B4B0(signed int a1, int a2, int a3, int a4);
void *__cdecl sub_805B4F0(signed int a1, int a2, int a3, int a4, int a5);
void *__cdecl sub_805B61A(signed int a1, int a2, int a3);
void *__cdecl sub_805B675(signed int a1, int a2);
void *__cdecl sub_805B697(int a1);
void __cdecl __noreturn sub_805B6B2(int a1);
_DWORD *__cdecl sub_805B71B(int a1, int a2);
unsigned int __cdecl sub_805B760(int a1, int a2, size_t nbytes);
char *__cdecl sub_805B97D(int a1, size_t n);
size_t __cdecl sub_805BA8A(int a1, void *ptr, size_t n);
int __cdecl sub_805BB28(int, void *dest, size_t n); // idb
size_t __cdecl sub_805BC57(int a1, void *ptr, size_t n);
int __cdecl sub_805BC9F(void *ptr); // idb
int __cdecl sub_805BCFB(int a1);
int __cdecl sub_805BD12(int a1, __int16 a2);
_DWORD __cdecl sub_805BD53(_DWORD); // weak
_DWORD __cdecl sub_805C34D(_DWORD); // weak
signed int __cdecl sub_805C85E(_DWORD *a1);
_DWORD *__cdecl sub_805CA22(_DWORD *a1);
bool __cdecl sub_805CC07(FILE *stream, int a2);
int __cdecl sub_805CF75(int a1, int a2);
_DWORD __cdecl sub_805D121(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_805D66F(int a1, int a2, int a3, int a4);
int __cdecl sub_805D6A7(int fd); // idb
int __cdecl sub_805D6F1(FILE *stream, int, int, int, int, int); // idb
int __cdecl sub_805DD36(FILE *stream, int, int, int, int); // idb
int sub_805DDAC(FILE *stream, int a2, int a3, int a4, ...);
int __cdecl sub_805DE5C(unsigned int a1, unsigned int a2);
void *__cdecl sub_805DEC1(void *ptr, int a2, int a3);
int __cdecl sub_805DF5B(size_t size); // idb
int __cdecl sub_805DF6E(size_t size); // idb
void *__cdecl sub_805DFD6(void *ptr, size_t size);
void __cdecl __noreturn sub_805E0A0(size_t nmemb, size_t size); // idb
void *__cdecl sub_805E0F7(void *src, size_t n);
void __noreturn sub_805E145();
void __cdecl sub_805E17E(int errnum, int a2, int a3, int a4, int a5);
int __cdecl sub_805E2CF(void *s1, size_t n, void *s2, int); // idb
int __cdecl sub_805E35A(double a1);
signed int __cdecl sub_805E3F2(unsigned int *a1, signed int a2);
int __cdecl sub_805E448(unsigned int *a1, signed int a2, int a3);
// int __usercall sub_805E47E@<eax>(int a1@<ebx>, char *nptr, int a3, int base, int a5, char *s);
void __cdecl sub_805E944(int a1, int a2, int a3, int a4, int a5, int status);
void __cdecl __noreturn sub_805EA23(int a1, int a2, char a3, int a4, int a5);
int __cdecl sub_805EA7B(void *s1, size_t n, void *s2, int); // idb
int __cdecl sub_805EB87(unsigned int *a1, signed int a2, int a3);
int __cdecl sub_805EBBD(char *nptr, int, int base, int, char *s); // idb
int __cdecl sub_805F079(FILE *stream); // idb
int __cdecl sub_805F13C(int fd, int cmd, char); // idb
int __cdecl sub_805F2B6(FILE *stream); // idb
int __cdecl sub_805F2EF(FILE *fp); // idb
int __cdecl sub_805F32F(FILE *stream, int, int, int); // idb
size_t __cdecl sub_805F443(wchar_t *pwc, char *s, size_t n, mbstate_t *p);
int __cdecl sub_805F4CA(int a1, int a2);
int __cdecl sub_805F508(int a1, int a2);
signed int __cdecl sub_805F546(int a1, signed int a2, signed int a3);
signed int __cdecl sub_805F645(int a1, signed int a2, signed int a3, int a4, int a5);
int __cdecl sub_805F6EE(int a1, int a2);
int __cdecl sub_805F911(int a1, unsigned int a2);
int __cdecl sub_805FB8C(int a1, char a2);
_DWORD __cdecl sub_805FCB7(_DWORD); // weak
signed int __cdecl sub_805FD2A(signed int a1);
signed int __cdecl sub_805FDB2(int a1);
signed int __cdecl sub_805FE76(signed int a1);
int __cdecl sub_805FF1B(int a1);
int __cdecl sub_805FF51(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_805FFCC(FILE *fp); // idb
// _DWORD *__userpurge sub_8060077@<eax>(_DWORD *a1, double a2);
int __cdecl sub_80601F2(int fd, int); // idb
int __cdecl sub_8060243(int fd, int); // idb
FILE *__cdecl sub_806027B(int a1, char *modes);
// void *__usercall sub_8060353@<eax>(int a1@<ebx>);
// const char *__usercall sub_8060835@<eax>(int a1@<ebx>);
int __cdecl sub_806092A(char *s, int, char *s2, int); // idb
signed int __cdecl sub_80609ED(unsigned int *a1, signed int a2);
int __cdecl sub_8060A9F(void *s1, size_t n, void *s2, int); // idb
// _DWORD *__userpurge sub_8060AFF@<eax>(_DWORD *a1, int a2, int a3);
int __cdecl sub_8060BDE(int fd); // idb
_DWORD __cdecl sub_8060C03(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_8060D7D(unsigned __int64 a1, __int64 a2);
int __cdecl sub_8060F70(int a1);
int __cdecl sub_8060F9F(int a1, int a2);
int __cdecl sub_8060FCE(int a1, int a2);
int sub_8061057(void); // weak
int __stdcall sub_80610E1(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_80611DA();
int sub_80612C7(void); // weak
int __stdcall sub_80613AB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __fastcall sub_806143E(_DWORD, _DWORD); // weak
int __stdcall sub_80614AE(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_806151E(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (**sub_8061530())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN locret_804A997; // weak
_UNKNOWN loc_804B77B; // weak
_UNKNOWN locret_804B7AD; // weak
_UNKNOWN loc_804B837; // weak
_UNKNOWN loc_804BD05; // weak
_UNKNOWN locret_804BD2F; // weak
_UNKNOWN loc_804BE21; // weak
_UNKNOWN loc_804BE2C; // weak
_UNKNOWN loc_804C071; // weak
_UNKNOWN loc_804C7A4; // weak
_UNKNOWN loc_804C7AF; // weak
_UNKNOWN loc_804C8DF; // weak
_UNKNOWN loc_804CA58; // weak
_UNKNOWN loc_804CBBE; // weak
_UNKNOWN loc_804D0A8; // weak
_UNKNOWN loc_804D0D1; // weak
_UNKNOWN loc_804DDAC; // weak
_UNKNOWN loc_804DDB6; // weak
_UNKNOWN loc_804E04F; // weak
_UNKNOWN loc_804E30B; // weak
_UNKNOWN loc_804E321; // weak
_UNKNOWN loc_804E758; // weak
_UNKNOWN loc_804E7BF; // weak
_UNKNOWN loc_804E878; // weak
_UNKNOWN loc_804E8AA; // weak
_UNKNOWN loc_804E8C9; // weak
_UNKNOWN loc_804E8DF; // weak
_UNKNOWN loc_804EA7D; // weak
_UNKNOWN loc_804EA97; // weak
_UNKNOWN loc_804F123; // weak
_UNKNOWN loc_804F131; // weak
_UNKNOWN loc_804F18E; // weak
_UNKNOWN loc_804F195; // weak
_UNKNOWN loc_804F244; // weak
_UNKNOWN loc_804F28B; // weak
_UNKNOWN loc_804F2B9; // weak
_UNKNOWN loc_804F2E0; // weak
_UNKNOWN loc_804F36A; // weak
_UNKNOWN loc_804F55F; // weak
_UNKNOWN loc_804F5FC; // weak
_UNKNOWN loc_8050B3B; // weak
_UNKNOWN loc_8050B7B; // weak
_UNKNOWN loc_8050B7D; // weak
_UNKNOWN loc_8050FB9; // weak
_UNKNOWN loc_8051044; // weak
_UNKNOWN loc_80510DB; // weak
_UNKNOWN loc_805151C; // weak
_UNKNOWN loc_805159C; // weak
_UNKNOWN loc_8051A57; // weak
_UNKNOWN loc_8051A65; // weak
_UNKNOWN loc_8052232; // weak
_UNKNOWN loc_80522AD; // weak
_UNKNOWN loc_80522D4; // weak
_UNKNOWN loc_80523BF; // weak
_UNKNOWN loc_80524B8; // weak
_UNKNOWN loc_80524D5; // weak
_UNKNOWN locret_8052A01; // weak
_UNKNOWN loc_8052CCA; // weak
_UNKNOWN loc_8052CF3; // weak
_UNKNOWN loc_8052FF5; // weak
_UNKNOWN loc_805328C; // weak
_UNKNOWN loc_80535EA; // weak
_UNKNOWN loc_805385F; // weak
_UNKNOWN loc_80538AD; // weak
_UNKNOWN loc_80538F5; // weak
_UNKNOWN loc_805540B; // weak
_UNKNOWN loc_805550E; // weak
_UNKNOWN locret_8055533; // weak
_UNKNOWN loc_80558C4; // weak
_UNKNOWN loc_80558D4; // weak
_UNKNOWN loc_8056DFB; // weak
_UNKNOWN loc_8056F49; // weak
_UNKNOWN loc_8056F85; // weak
_UNKNOWN loc_8056F9C; // weak
_UNKNOWN loc_805703F; // weak
_UNKNOWN loc_8057072; // weak
_UNKNOWN loc_8057079; // weak
_UNKNOWN loc_8057FCB; // weak
_UNKNOWN loc_805801B; // weak
_UNKNOWN loc_8058064; // weak
_UNKNOWN loc_8058082; // weak
_UNKNOWN loc_8058219; // weak
_UNKNOWN loc_8058221; // weak
_UNKNOWN loc_8058695; // weak
_UNKNOWN loc_805869A; // weak
_UNKNOWN loc_80590CB; // weak
_UNKNOWN loc_80590EC; // weak
_UNKNOWN loc_805926F; // weak
_UNKNOWN locret_8059926; // weak
_UNKNOWN loc_8059963; // weak
_UNKNOWN loc_805999A; // weak
_UNKNOWN loc_8059BAF; // weak
_UNKNOWN loc_8059BB4; // weak
_UNKNOWN loc_8059D7D; // weak
_UNKNOWN loc_8059D85; // weak
_UNKNOWN loc_805A2E6; // weak
_UNKNOWN loc_805A3E7; // weak
_UNKNOWN loc_805A883; // weak
_UNKNOWN loc_805A889; // weak
_UNKNOWN loc_805A89F; // weak
_UNKNOWN loc_805A8BD; // weak
_UNKNOWN loc_805AF46; // weak
_UNKNOWN loc_805BA91; // weak
_UNKNOWN locret_805BCF9; // weak
_UNKNOWN loc_805CC0D; // weak
_UNKNOWN loc_805CC72; // weak
_UNKNOWN loc_805CCDC; // weak
_UNKNOWN loc_805E044; // weak
_UNKNOWN loc_805E04F; // weak
_UNKNOWN locret_805E052; // weak
_UNKNOWN locret_805E3F0; // weak
_UNKNOWN loc_805E4EA; // weak
_UNKNOWN loc_805E53E; // weak
_UNKNOWN loc_805E5AF; // weak
_UNKNOWN loc_805E5D6; // weak
_UNKNOWN loc_805E620; // weak
_UNKNOWN loc_805E63C; // weak
_UNKNOWN loc_805E74A; // weak
_UNKNOWN loc_805E902; // weak
_UNKNOWN locret_805E942; // weak
_UNKNOWN loc_805E982; // weak
_UNKNOWN loc_805E9A0; // weak
_UNKNOWN loc_805EC17; // weak
_UNKNOWN loc_805EC3E; // weak
_UNKNOWN loc_805EC82; // weak
_UNKNOWN loc_805ECE4; // weak
_UNKNOWN loc_805ED2E; // weak
_UNKNOWN loc_805EE69; // weak
_UNKNOWN loc_805F018; // weak
_UNKNOWN loc_805F062; // weak
_UNKNOWN loc_805F066; // weak
_UNKNOWN loc_805F3E4; // weak
_UNKNOWN loc_805F3EB; // weak
_UNKNOWN locret_805F4C8; // weak
_UNKNOWN loc_805F876; // weak
_UNKNOWN loc_805F894; // weak
_UNKNOWN locret_805F9C9; // weak
_UNKNOWN loc_805FEAA; // weak
_UNKNOWN loc_805FEBB; // weak
_UNKNOWN loc_805FFB9; // weak
_UNKNOWN loc_806003A; // weak
_UNKNOWN loc_8060052; // weak
_UNKNOWN loc_80601EB; // weak
_UNKNOWN loc_80603A5; // weak
_UNKNOWN loc_8060815; // weak
_UNKNOWN loc_8060861; // weak
_UNKNOWN loc_80608EB; // weak
_UNKNOWN loc_806091E; // weak
_UNKNOWN loc_8060925; // weak
char s = '\0'; // idb
struct option longopts = { "ignore-leading-blanks", 0, NULL, 98 }; // idb
char byte_8062DC8[256] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x06',
  '\0',
  '\x03',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0',
  '\x04',
  '\0',
  '\0',
  '\0',
  '\0',
  '\b',
  '\a',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_8063A48; // weak
_UNKNOWN unk_8063A98; // weak
_DWORD off_8063CB4[11] =
{
  134586370,
  134586294,
  134586313,
  134586290,
  134586298,
  134586065,
  134586054,
  134586140,
  134586153,
  134586153,
  134586153
}; // idb
void *off_806426C = &loc_805D7AA; // weak
_UNKNOWN unk_8064997; // weak
int dword_8065F00 = 1460; // weak
_UNKNOWN unk_8066374; // weak
_UNKNOWN unk_8066377; // weak
int dword_8066EF4 = 28; // weak
_UNKNOWN unk_80673A8; // weak
_UNKNOWN unk_80673AB; // weak
int (*off_8069ED0[2])() = { &sub_804A030, &sub_804A010 }; // weak
int (*off_8069ED4)() = &sub_804A010; // weak
int (*dword_806A008)(void) = NULL; // weak
int dword_806A20C = 0; // weak
int dword_806A220 = 0; // weak
int dword_806A234 = 0; // weak
int dword_806A248 = 0; // weak
int dword_806A268 = 0; // weak
int dword_806A288 = 0; // weak
int dword_806A2A8 = 0; // weak
int dword_806A2BC = 0; // weak
int dword_806A2D4 = 0; // weak
size_t dword_806A370 = 262144u; // idb
int dword_806A374 = 128; // weak
int dword_806A378 = 16; // idb
int *off_806A37C = &dword_806AE5C; // weak
int status = 1; // idb
int dword_806A3B0 = 1; // weak
int dword_806A3B4 = 256; // weak
void *off_806A3B8 = &unk_806AF7C; // weak
int *off_806A3BC = &dword_806A3B4; // weak
_UNKNOWN unk_806A3D0; // weak
_UNKNOWN unk_806A3F0; // weak
_UNKNOWN unk_806A3F3; // weak
_UNKNOWN unk_806A3F8; // weak
_UNKNOWN unk_806A3FB; // weak
_UNKNOWN unk_806A404; // weak
_UNKNOWN unk_806A407; // weak
FILE *stderr; // idb
FILE *stdout; // idb
int (*obstack_alloc_failed_handler)(void); // weak
char byte_806A48C; // weak
int dword_806A99C; // weak
int dword_806A9A0; // weak
char byte_806A9A4; // weak
char byte_806A9BC[256]; // idb
_UNKNOWN unk_806AABC; // weak
_UNKNOWN unk_806ABBC; // weak
size_t size; // idb
void *ptr; // idb
int dword_806ADC4; // weak
int dword_806ADC8; // weak
char byte_806ADCC; // weak
char byte_806ADCD; // weak
char byte_806ADCE; // weak
int dword_806ADD0; // weak
char *s1; // idb
__sigset_t set; // idb
int dword_806AE5C; // weak
int dword_806AE60; // weak
int dword_806AE64; // weak
_UNKNOWN unk_806AE7C; // weak
int dword_806AF18; // weak
int dword_806AF20; // weak
char byte_806AF24; // weak
int dword_806AF28; // weak
int dword_806AF2C; // weak
int dword_806AF3C; // weak
int dword_806AF40; // weak
int dword_806AF44; // weak
int dword_806AF48; // weak
int dword_806AF4C; // weak
int dword_806AF50; // weak
int dword_806AF54; // weak
int dword_806AF58; // weak
int dword_806AF5C; // weak
int dword_806AF60; // weak
int dword_806AF64; // weak
int dword_806AF68; // weak
_UNKNOWN unk_806AF7C; // weak
int dword_806B07C; // weak
int dword_806B080; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (0804972C) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 8049F30: using guessed type int _gmon_start__(void);

//----- (08049750) --------------------------------------------------------
int sub_8049750()
{
  return dword_806A008();
}
// 806A008: using guessed type int (*dword_806A008)(void);

//----- (08049F40) --------------------------------------------------------
#error "8049F43: positive sp value has been found (funcsize=2)"

//----- (08049F73) --------------------------------------------------------
void sub_8049F73()
{
  ;
}

//----- (08049F90) --------------------------------------------------------
void sub_8049F90()
{
  ;
}

//----- (08049FA0) --------------------------------------------------------
int sub_8049FA0()
{
  int result; // eax

  result = &unk_806A407 - &unk_806A404;
  if ( (unsigned int)(&unk_806A407 - &unk_806A404) > 6 )
    result = 0;
  return result;
}
// 8049FA0: could not find valid save-restore pair for ebp

//----- (0804A010) --------------------------------------------------------
int sub_804A010()
{
  int result; // eax

  if ( !byte_806A48C )
  {
    result = sub_8049FA0();
    byte_806A48C = 1;
  }
  return result;
}
// 804A010: could not find valid save-restore pair for ebp
// 806A48C: using guessed type char byte_806A48C;

//----- (0804A030) --------------------------------------------------------
int sub_804A030()
{
  return 0;
}
// 804A030: could not find valid save-restore pair for ebp

//----- (0804A08F) --------------------------------------------------------
void sub_804A08F()
{
  ;
}

//----- (0804A0AA) --------------------------------------------------------
void sub_804A0AA()
{
  ;
}

//----- (0804A0BA) --------------------------------------------------------
int sub_804A0BA()
{
  int result; // eax

  result = &unk_806A3F3 - &unk_806A3F0;
  if ( (unsigned int)(&unk_806A3F3 - &unk_806A3F0) > 6 )
    result = 0;
  return result;
}
// 804A0BA: could not find valid save-restore pair for ebp

//----- (0804A19C) --------------------------------------------------------
void sub_804A19C()
{
  ;
}

//----- (0804A1B7) --------------------------------------------------------
void sub_804A1B7()
{
  ;
}

//----- (0804A1C7) --------------------------------------------------------
signed int sub_804A1C7()
{
  return 3;
}
// 804A1C7: could not find valid save-restore pair for ebp

//----- (0804A2A9) --------------------------------------------------------
void sub_804A2A9()
{
  ;
}

//----- (0804A2C4) --------------------------------------------------------
void sub_804A2C4()
{
  ;
}

//----- (0804A2D4) --------------------------------------------------------
int sub_804A2D4()
{
  int result; // eax

  result = &unk_806A3F3 - &unk_806A3F0;
  if ( (unsigned int)(&unk_806A3F3 - &unk_806A3F0) > 6 )
    result = 0;
  return result;
}
// 804A2D4: could not find valid save-restore pair for ebp

//----- (0804A3B6) --------------------------------------------------------
void sub_804A3B6()
{
  ;
}

//----- (0804A3D1) --------------------------------------------------------
void sub_804A3D1()
{
  ;
}

//----- (0804A3E1) --------------------------------------------------------
int sub_804A3E1()
{
  int result; // eax

  result = &unk_806A3F3 - &unk_806A3F0;
  if ( (unsigned int)(&unk_806A3F3 - &unk_806A3F0) > 6 )
    result = 0;
  return result;
}
// 804A3E1: could not find valid save-restore pair for ebp

//----- (0804A4D8) --------------------------------------------------------
void sub_804A4D8()
{
  ;
}

//----- (0804A4F3) --------------------------------------------------------
void sub_804A4F3()
{
  ;
}

//----- (0804A503) --------------------------------------------------------
int sub_804A503()
{
  int result; // eax

  result = &unk_80673AB - &unk_80673A8;
  if ( (unsigned int)(&unk_80673AB - &unk_80673A8) > 6 )
    result = 0;
  return result;
}
// 804A503: could not find valid save-restore pair for ebp

//----- (0804A5E5) --------------------------------------------------------
void sub_804A5E5()
{
  ;
}

//----- (0804A600) --------------------------------------------------------
void sub_804A600()
{
  ;
}

//----- (0804A610) --------------------------------------------------------
int sub_804A610()
{
  int result; // eax

  result = &unk_806A3F3 - &unk_806A3F0;
  if ( (unsigned int)(&unk_806A3F3 - &unk_806A3F0) > 6 )
    result = 0;
  return result;
}
// 804A610: could not find valid save-restore pair for ebp

//----- (0804A6F2) --------------------------------------------------------
void sub_804A6F2()
{
  ;
}

//----- (0804A70D) --------------------------------------------------------
void sub_804A70D()
{
  ;
}

//----- (0804A71D) --------------------------------------------------------
int sub_804A71D()
{
  int result; // eax

  result = &unk_806A3FB - &unk_806A3F8;
  if ( (unsigned int)(&unk_806A3FB - &unk_806A3F8) > 6 )
    result = 0;
  return result;
}
// 804A71D: could not find valid save-restore pair for ebp

//----- (0804A77B) --------------------------------------------------------
int sub_804A77B()
{
  return nullsub_3();
}
// 804A77B: could not find valid save-restore pair for ebp
// 804A77A: using guessed type int nullsub_3(void);

//----- (0804A7E8) --------------------------------------------------------
int __usercall sub_804A7E8@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  int v1; // ecx
  int savedregs; // [esp+18h] [ebp+0h]

  a1(&dword_8066EF4);
  savedregs = 0;
  dword_806A234 = (int)nullsub_3;
  sub_806143E(v1, 0);
  return nullsub_3();
}
// 804A77A: using guessed type int nullsub_3(void);
// 806143E: using guessed type int __fastcall sub_806143E(_DWORD, _DWORD);
// 8066EF4: using guessed type int dword_8066EF4;
// 806A234: using guessed type int dword_806A234;

//----- (0804A834) --------------------------------------------------------
void sub_804A834()
{
  ;
}

//----- (0804A84F) --------------------------------------------------------
void sub_804A84F()
{
  ;
}

//----- (0804A85F) --------------------------------------------------------
int sub_804A85F()
{
  int result; // eax

  result = &unk_8066377 - &unk_8066374;
  if ( (unsigned int)(&unk_8066377 - &unk_8066374) > 6 )
    result = 0;
  return result;
}
// 804A85F: could not find valid save-restore pair for ebp

//----- (0804A8C6) --------------------------------------------------------
int __usercall sub_804A8C6@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_8066374, a1);
}

//----- (0804A95D) --------------------------------------------------------
void sub_804A95D()
{
  ;
}

//----- (0804A978) --------------------------------------------------------
void sub_804A978()
{
  ;
}

//----- (0804A988) --------------------------------------------------------
int __fastcall sub_804A988(int a1, int a2)
{
  int result; // eax
  int (__stdcall *v3)(void *, int, int, int, int, int); // eax
  int v4; // [esp+4h] [ebp-18h]
  int v5; // [esp+8h] [ebp-14h]
  int v6; // [esp+Ch] [ebp-10h]
  int v7; // [esp+10h] [ebp-Ch]
  int v8; // [esp+14h] [ebp-8h]
  int v9; // [esp+18h] [ebp-4h]

  result = &unk_806A3FB - &unk_806A3F8;
  if ( (unsigned int)(&unk_806A3FB - &unk_806A3F8) > 6 )
  {
    v9 = 0;
    dword_806A234 = (int)&locret_804A997;
    v3 = (int (__stdcall *)(void *, int, int, int, int, int))sub_806143E(a1, a2);
    result = v3(&unk_806A3F8, v4, v5, v6, v7, v8);
  }
  return result;
}
// 806143E: using guessed type int __fastcall sub_806143E(_DWORD, _DWORD);
// 806A234: using guessed type int dword_806A234;

//----- (0804AA9B) --------------------------------------------------------
void sub_804AA9B()
{
  ;
}

//----- (0804AAB6) --------------------------------------------------------
void sub_804AAB6()
{
  ;
}

//----- (0804AAC6) --------------------------------------------------------
int sub_804AAC6()
{
  int result; // eax

  result = &unk_806A3F3 - &unk_806A3F0;
  _CF = (unsigned int)(&unk_806A3F3 - &unk_806A3F0) < 6;
  _OF = __OFSUB__(&unk_806A3F3 - &unk_806A3F0, 6);
  _ZF = &unk_806A3F3 - &unk_806A3F0 == 6;
  _SF = &unk_806A3F3 - &unk_806A3F0 - 6 < 0;
  if ( (unsigned int)(&unk_806A3F3 - &unk_806A3F0) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 804AAC6: could not find valid save-restore pair for ebp

//----- (0804AAF3) --------------------------------------------------------
int sub_804AAF3()
{
  return 0;
}
// 804AAF3: could not find valid save-restore pair for ebp

//----- (0804ABA4) --------------------------------------------------------
int __usercall sub_804ABA4@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  a1(&dword_8065F00);
  return sub_804AAF3();
}
// 8065F00: using guessed type int dword_8065F00;

//----- (0804ABF0) --------------------------------------------------------
void sub_804ABF0()
{
  ;
}

//----- (0804AC0B) --------------------------------------------------------
void sub_804AC0B()
{
  ;
}

//----- (0804AC1B) --------------------------------------------------------
#error "804AC49: call analysis failed (funcsize=25)"

//----- (0804AD1C) --------------------------------------------------------
void sub_804AD1C()
{
  ;
}

//----- (0804AD37) --------------------------------------------------------
void sub_804AD37()
{
  ;
}

//----- (0804AD47) --------------------------------------------------------
int sub_804AD47()
{
  int result; // eax

  result = &unk_806A3FB - &unk_806A3F8;
  _CF = (unsigned int)(&unk_806A3FB - &unk_806A3F8) < 6;
  _OF = __OFSUB__(&unk_806A3FB - &unk_806A3F8, 6);
  _ZF = &unk_806A3FB - &unk_806A3F8 == 6;
  _SF = &unk_806A3FB - &unk_806A3F8 - 6 < 0;
  if ( (unsigned int)(&unk_806A3FB - &unk_806A3F8) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 804AD47: could not find valid save-restore pair for ebp

//----- (0804ADFD) --------------------------------------------------------
int __cdecl sub_804ADFD(int a1)
{
  int result; // eax

  if ( a1 != 1 )
  {
    result = a1;
    status = a1;
  }
  return result;
}

//----- (0804AE10) --------------------------------------------------------
int __cdecl sub_804AE10(unsigned __int8 a1)
{
  return a1;
}

//----- (0804AE22) --------------------------------------------------------
int __cdecl sub_804AE22(unsigned __int8 a1)
{
  char v5; // al

  if ( (*__ctype_b_loc())[a1] & 1
    || (_CF = a1 < 0xAu, _OF = __OFSUB__(a1, 10), _ZF = a1 == 10, _SF = (char)(a1 - 10) < 0, a1 == 10) )
  {
    v5 = 1;
  }
  else
  {
    __asm { pushfw }
    v5 = 0;
    __asm { popfw }
  }
  return v5 & 1;
}

//----- (0804AE62) --------------------------------------------------------
int __cdecl sub_804AE62(unsigned __int64 a1)
{
  int result; // eax

  if ( HIDWORD(a1) )
    result = sub_8060D7D(a1, 1000000LL) + 1000000;
  else
    result = a1;
  return result;
}

//----- (0804AEA8) --------------------------------------------------------
int sub_804AEA8()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nWith no FILE, or when FILE is -, read standard input.\n");
  return fputs_unlocked(v1, v0);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804AED3) --------------------------------------------------------
int sub_804AED3()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nMandatory arguments to long options are mandatory for short options too.\n");
  return fputs_unlocked(v1, v0);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804AEFE) --------------------------------------------------------
int __cdecl sub_804AEFE(char *s1)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // ebx
  char *v5; // eax
  int v7; // [esp+0h] [ebp-68h]
  char *v8; // [esp+4h] [ebp-64h]
  char *v9; // [esp+8h] [ebp-60h]
  char *v10; // [esp+1Ch] [ebp-4Ch]
  char **i; // [esp+20h] [ebp-48h]
  char *v12; // [esp+24h] [ebp-44h]
  const char *v13; // [esp+28h] [ebp-40h]
  const char *v14; // [esp+2Ch] [ebp-3Ch]
  const char *v15; // [esp+30h] [ebp-38h]
  const char *v16; // [esp+34h] [ebp-34h]
  const char *v17; // [esp+38h] [ebp-30h]
  const char *v18; // [esp+3Ch] [ebp-2Ch]
  const char *v19; // [esp+40h] [ebp-28h]
  const char *v20; // [esp+44h] [ebp-24h]
  const char *v21; // [esp+48h] [ebp-20h]
  const char *v22; // [esp+4Ch] [ebp-1Ch]
  const char *v23; // [esp+50h] [ebp-18h]
  const char *v24; // [esp+54h] [ebp-14h]
  int v25; // [esp+58h] [ebp-10h]
  int v26; // [esp+5Ch] [ebp-Ch]

  v13 = "[";
  v14 = "test invocation";
  v15 = "coreutils";
  v16 = "Multi-call invocation";
  v17 = "sha224sum";
  v18 = "sha2 utilities";
  v19 = "sha256sum";
  v20 = "sha2 utilities";
  v21 = "sha384sum";
  v22 = "sha2 utilities";
  v23 = "sha512sum";
  v24 = "sha2 utilities";
  v25 = 0;
  v26 = 0;
  v10 = s1;
  for ( i = (char **)(&v7 - 16); *i; i += 2 )
  {
    v8 = *i;
    if ( !strcmp(s1, v8) )
      break;
  }
  if ( i[1] )
    v10 = i[1];
  v1 = gettext("\n%s online help: <%s>\n");
  v9 = "http://www.gnu.org/software/coreutils/";
  v8 = "GNU coreutils";
  printf(v1, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  v12 = setlocale(5, 0);
  if ( v12 && strncmp(v12, "en_", 3u) )
  {
    v2 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
    v8 = s1;
    printf(v2, s1);
  }
  v3 = gettext("Full documentation at: <%s%s>\n");
  v9 = s1;
  v8 = "http://www.gnu.org/software/coreutils/";
  printf(v3, "http://www.gnu.org/software/coreutils/", s1);
  if ( v10 == s1 )
    v4 = " invocation";
  else
    v4 = &s;
  v5 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  v9 = v4;
  v8 = v10;
  return printf(v5, v10, v4);
}

//----- (0804B094) --------------------------------------------------------
void __cdecl __noreturn sub_804B094(int a1, const char *a2)
{
  size_t v2; // eax
  char *v3; // ST20_4
  size_t v4; // eax
  char v5; // [esp+30h] [ebp-18h]
  unsigned int v6; // [esp+3Ch] [ebp-Ch]

  v6 = __readgsdword(0x14u);
  v2 = strlen(a2);
  write(2, a2, v2);
  if ( a1 )
  {
    v3 = (char *)sub_8058D8E(a1, (int)&v5);
    write(2, ": errno ", 8u);
    v4 = strlen(v3);
    write(2, v3, v4);
  }
  write(2, "\n", 1u);
  _exit(2);
}

//----- (0804B16A) --------------------------------------------------------
void __cdecl __noreturn sub_804B16A(int a1, char *a2)
{
  char *v2; // eax
  void *v3; // ebx
  int *v4; // eax

  if ( a2 )
    v2 = a2;
  else
    v2 = gettext("standard output");
  v3 = sub_805B3FF(0, 3, (int)v2);
  v4 = __errno_location();
  error(2, *v4, "%s: %s", a1, v3);
  sub_804B1CC(a1);
}

//----- (0804B1CC) --------------------------------------------------------
void __cdecl __noreturn sub_804B1CC(int status)
{
  int v1; // ebx
  char *v2; // eax
  int v3; // esi
  int v4; // ebx
  char *v5; // eax
  FILE *v6; // ebx
  char *v7; // eax
  FILE *v8; // ebx
  char *v9; // eax
  FILE *v10; // ebx
  char *v11; // eax
  FILE *v12; // ebx
  char *v13; // eax
  FILE *v14; // ebx
  char *v15; // eax
  FILE *v16; // ebx
  char *v17; // eax
  FILE *v18; // ebx
  char *v19; // eax
  FILE *v20; // ebx
  char *v21; // eax
  FILE *v22; // ebx
  char *v23; // eax
  FILE *v24; // ebx
  char *v25; // eax
  FILE *v26; // ebx
  char *v27; // eax
  FILE *v28; // ebx
  char *v29; // eax
  FILE *v30; // ebx
  char *v31; // eax
  char *v32; // eax
  FILE *v33; // ebx
  char *v34; // eax
  FILE *v35; // ebx
  char *v36; // eax
  FILE *v37; // ebx
  char *v38; // eax
  FILE *v39; // ebx
  char *v40; // eax
  FILE *v41; // ebx
  char *v42; // eax

  if ( status )
  {
    v1 = dword_806AF2C;
    v2 = gettext("Try '%s --help' for more information.\n");
    fprintf(stderr, v2, v1);
  }
  else
  {
    v3 = dword_806AF2C;
    v4 = dword_806AF2C;
    v5 = gettext("Usage: %s [OPTION]... [FILE]...\n  or:  %s [OPTION]... --files0-from=F\n");
    printf(v5, v4, v3);
    v6 = stdout;
    v7 = gettext("Write sorted concatenation of all FILE(s) to standard output.\n");
    fputs_unlocked(v7, v6);
    sub_804AEA8();
    sub_804AED3();
    v8 = stdout;
    v9 = gettext("Ordering options:\n\n");
    fputs_unlocked(v9, v8);
    v10 = stdout;
    v11 = gettext(
            "  -b, --ignore-leading-blanks  ignore leading blanks\n"
            "  -d, --dictionary-order      consider only blanks and alphanumeric characters\n"
            "  -f, --ignore-case           fold lower case to upper case characters\n");
    fputs_unlocked(v11, v10);
    v12 = stdout;
    v13 = gettext(
            "  -g, --general-numeric-sort  compare according to general numerical value\n"
            "  -i, --ignore-nonprinting    consider only printable characters\n"
            "  -M, --month-sort            compare (unknown) < 'JAN' < ... < 'DEC'\n");
    fputs_unlocked(v13, v12);
    v14 = stdout;
    v15 = gettext("  -h, --human-numeric-sort    compare human readable numbers (e.g., 2K 1G)\n");
    fputs_unlocked(v15, v14);
    v16 = stdout;
    v17 = gettext(
            "  -n, --numeric-sort          compare according to string numerical value\n"
            "  -R, --random-sort           shuffle, but group identical keys.  See shuf(1)\n"
            "      --random-source=FILE    get random bytes from FILE\n"
            "  -r, --reverse               reverse the result of comparisons\n");
    fputs_unlocked(v17, v16);
    v18 = stdout;
    v19 = gettext(
            "      --sort=WORD             sort according to WORD:\n"
            "                                general-numeric -g, human-numeric -h, month -M,\n"
            "                                numeric -n, random -R, version -V\n"
            "  -V, --version-sort          natural sort of (version) numbers within text\n"
            "\n");
    fputs_unlocked(v19, v18);
    v20 = stdout;
    v21 = gettext("Other options:\n\n");
    fputs_unlocked(v21, v20);
    v22 = stdout;
    v23 = gettext(
            "      --batch-size=NMERGE   merge at most NMERGE inputs at once;\n"
            "                            for more use temp files\n");
    fputs_unlocked(v23, v22);
    v24 = stdout;
    v25 = gettext(
            "  -c, --check, --check=diagnose-first  check for sorted input; do not sort\n"
            "  -C, --check=quiet, --check=silent  like -c, but do not report first bad line\n"
            "      --compress-program=PROG  compress temporaries with PROG;\n"
            "                              decompress them with PROG -d\n");
    fputs_unlocked(v25, v24);
    v26 = stdout;
    v27 = gettext(
            "      --debug               annotate the part of the line used to sort,\n"
            "                              and warn about questionable usage to stderr\n"
            "      --files0-from=F       read input from the files specified by\n"
            "                            NUL-terminated names in file F;\n"
            "                            If F is - then read names from standard input\n");
    fputs_unlocked(v27, v26);
    v28 = stdout;
    v29 = gettext(
            "  -k, --key=KEYDEF          sort via a key; KEYDEF gives location and type\n"
            "  -m, --merge               merge already sorted files; do not sort\n");
    fputs_unlocked(v29, v28);
    v30 = stdout;
    v31 = gettext(
            "  -o, --output=FILE         write result to FILE instead of standard output\n"
            "  -s, --stable              stabilize sort by disabling last-resort comparison\n"
            "  -S, --buffer-size=SIZE    use SIZE for main memory buffer\n");
    fputs_unlocked(v31, v30);
    v32 = gettext(
            "  -t, --field-separator=SEP  use SEP instead of non-blank to blank transition\n"
            "  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or %s;\n"
            "                              multiple options specify multiple directories\n"
            "      --parallel=N          change the number of sorts run concurrently to N\n"
            "  -u, --unique              with -c, check for strict ordering;\n"
            "                              without -c, output only the first of an equal run\n");
    printf(v32, "/tmp");
    v33 = stdout;
    v34 = gettext("  -z, --zero-terminated     line delimiter is NUL, not newline\n");
    fputs_unlocked(v34, v33);
    v35 = stdout;
    v36 = gettext("      --help     display this help and exit\n");
    fputs_unlocked(v36, v35);
    v37 = stdout;
    v38 = gettext("      --version  output version information and exit\n");
    fputs_unlocked(v38, v37);
    v39 = stdout;
    v40 = gettext(
            "\n"
            "KEYDEF is F[.C][OPTS][,F[.C][OPTS]] for start and stop position, where F is a\n"
            "field number and C a character position in the field; both are origin 1, and\n"
            "the stop position defaults to the line's end.  If neither -t nor -b is in\n"
            "effect, characters in a field are counted from the beginning of the preceding\n"
            "whitespace.  OPTS is one or more single-letter ordering options [bdfgiMhnRrV],\n"
            "which override global ordering options for that key.  If no key is given, use\n"
            "the entire line as the key.  Use --debug to diagnose incorrect key usage.\n"
            "\n"
            "SIZE may be followed by the following multiplicative suffixes:\n");
    fputs_unlocked(v40, v39);
    v41 = stdout;
    v42 = gettext(
            "% 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, E, Z, Y.\n"
            "\n"
            "*** WARNING ***\n"
            "The locale specified by the environment affects sort order.\n"
            "Set LC_ALL=C to get the traditional sort order that uses\n"
            "native byte values.\n");
    fputs_unlocked(v42, v41);
    sub_804AEFE("sort");
  }
  exit(status);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 806AF2C: using guessed type int dword_806AF2C;

//----- (0804B488) --------------------------------------------------------
int __cdecl sub_804B488(int a1)
{
  bool v1; // dl
  int result; // eax

  v1 = pthread_sigmask(0, &set, (__sigset_t *)(a1 + 4)) == 0;
  result = a1;
  *(_BYTE *)a1 = v1;
  return result;
}

//----- (0804B4BD) --------------------------------------------------------
int __cdecl sub_804B4BD(unsigned __int8 *a1)
{
  int result; // eax

  result = *a1;
  if ( (_BYTE)result )
    result = pthread_sigmask(2, (const __sigset_t *)(a1 + 4), 0);
  return result;
}

//----- (0804B4ED) --------------------------------------------------------
int __cdecl sub_804B4ED(int a1, unsigned int a2)
{
  return *(_DWORD *)(a1 + 4) % a2;
}

//----- (0804B51C) --------------------------------------------------------
bool __cdecl sub_804B51C(int a1, int a2)
{
  return *(_DWORD *)(a1 + 4) == *(_DWORD *)(a2 + 4);
}

//----- (0804B551) --------------------------------------------------------
int __cdecl sub_804B551(__pid_t pid)
{
  __pid_t v1; // eax
  void *v2; // esi
  char *v3; // ebx
  int *v4; // eax
  void *v5; // ebx
  char *v6; // eax
  int stat_loc; // [esp+18h] [ebp-10h]
  int v9; // [esp+1Ch] [ebp-Ch]

  if ( pid )
    v1 = pid;
  else
    v1 = -1;
  v9 = waitpid(v1, &stat_loc, pid == 0);
  if ( v9 < 0 )
  {
    v2 = sub_805B25F(4, (int)s1);
    v3 = gettext("waiting for %s [-d]");
    v4 = __errno_location();
    error(2, *v4, v3, v2);
  }
  if ( v9 > 0 && (pid > 0 || (unsigned __int8)sub_804B6D1(v9)) )
  {
    if ( stat_loc & 0x7F || (stat_loc & 0xFF00) >> 8 )
    {
      v5 = sub_805B25F(4, (int)s1);
      v6 = gettext("%s [-d] terminated abnormally");
      error(2, 0, v6, v5);
    }
    --dword_806AE64;
  }
  return v9;
}
// 806AE64: using guessed type int dword_806AE64;

//----- (0804B65D) --------------------------------------------------------
int __cdecl sub_804B65D(int a1)
{
  int result; // eax

  if ( !dword_806AE60 )
  {
    dword_806AE60 = (int)sub_8057BA9(47, 0, (unsigned int (__cdecl *)(int, unsigned int))sub_804B4ED, sub_804B51C, 0);
    if ( !dword_806AE60 )
      sub_805E145();
  }
  *(_BYTE *)(a1 + 8) = 1;
  result = sub_805873E((_DWORD *)dword_806AE60, a1);
  if ( !result )
    sub_805E145();
  return result;
}
// 806AE60: using guessed type int dword_806AE60;

//----- (0804B6D1) --------------------------------------------------------
signed int __cdecl sub_804B6D1(int a1)
{
  signed int result; // eax
  int v6; // [esp+0h] [ebp-38h]
  int v7; // [esp+1Ch] [ebp-1Ch]
  int v8; // [esp+24h] [ebp-14h]
  unsigned int v9; // [esp+2Ch] [ebp-Ch]

  v9 = __readgsdword(0x14u);
  v8 = a1;
  v7 = sub_805877E(dword_806AE60, &v6 - 6);
  _CF = 0;
  _OF = 0;
  _ZF = v7 == 0;
  _SF = v7 < 0;
  if ( v7 )
  {
    *(_BYTE *)(v7 + 8) = 2;
    result = 1;
  }
  else
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 805877E: using guessed type _DWORD __cdecl sub_805877E(_DWORD, _DWORD);
// 806AE60: using guessed type int dword_806AE60;

//----- (0804B73C) --------------------------------------------------------
int __cdecl sub_804B73C(__pid_t pid)
{
  int result; // eax

  result = sub_804B6D1(pid);
  if ( (_BYTE)result )
    result = sub_804B551(pid);
  return result;
}

//----- (0804B75E) --------------------------------------------------------
int __fastcall sub_804B75E(int a1, int a2)
{
  int result; // eax
  bool v3; // zf
  int v4; // edx
  int v5; // ecx
  void *v6; // eax

  dword_806A234 = (int)&loc_804B77B;
  sub_806143E(a1, a2);
  result = dword_806AE64;
  if ( dword_806AE64 > 0 )
  {
    v3 = sub_804B551(0) == 0;
    v6 = &locret_804B7AD;
    if ( !v3 )
      v6 = &loc_804B77B;
    dword_806A234 = (int)v6;
    result = sub_806143E(v5, v4);
  }
  return result;
}
// 806143E: using guessed type int __fastcall sub_806143E(_DWORD, _DWORD);
// 806A234: using guessed type int dword_806A234;
// 806AE64: using guessed type int dword_806AE64;

//----- (0804B7AF) --------------------------------------------------------
int sub_804B7AF()
{
  int v0; // edx
  int v1; // ecx

  sub_804B551(-1);
  return sub_804B75E(v1, v0);
}

//----- (0804B7C8) --------------------------------------------------------
#error "804B7DC: call analysis failed (funcsize=16)"

//----- (0804B7FC) --------------------------------------------------------
int sub_804B7FC()
{
  int result; // eax
  int v1; // [esp+1Ch] [ebp-Ch]

  v1 = dword_806AE5C;
  dword_806A268 = (int)&loc_804B837;
  sub_80612C7();
  do
  {
    unlink((const char *)(v1 + 9));
    result = *(_DWORD *)v1;
    v1 = *(_DWORD *)v1;
  }
  while ( v1 );
  dword_806AE5C = 0;
  return result;
}
// 80612C7: using guessed type int sub_80612C7(void);
// 806A268: using guessed type int dword_806A268;
// 806AE5C: using guessed type int dword_806AE5C;

//----- (0804B849) --------------------------------------------------------
int sub_804B849()
{
  char v1; // [esp+1Ch] [ebp-8Ch]

  if ( dword_806AE5C )
  {
    sub_804B488((int)&v1);
    sub_804B7FC();
    sub_804B4BD((unsigned __int8 *)&v1);
  }
  return sub_8055881();
}
// 806AE5C: using guessed type int dword_806AE5C;

//----- (0804B883) --------------------------------------------------------
void *__cdecl sub_804B883(_DWORD *a1, char a2)
{
  _DWORD *v2; // eax
  void *v3; // esi
  char *v4; // ebx
  int v5; // eax
  void *v7; // [esp-10h] [ebp-BCh]
  char v8; // [esp+0h] [ebp-ACh]
  void *ptr; // [esp+8h] [ebp-A4h]
  char *s; // [esp+Ch] [ebp-A0h]
  size_t n; // [esp+10h] [ebp-9Ch]
  void *dest; // [esp+14h] [ebp-98h]
  int v13; // [esp+18h] [ebp-94h]
  int v14; // [esp+1Ch] [ebp-90h]
  char v15; // [esp+20h] [ebp-8Ch]

  v8 = a2;
  s = (char *)*((_DWORD *)::ptr + dword_806AF18);
  n = strlen(s);
  ptr = (void *)sub_805DF6E((n + 24) & 0xFFFFFFFC);
  dest = (char *)ptr + 9;
  memcpy((char *)ptr + 9, s, n);
  v2 = (char *)ptr + n + 9;
  *v2 = 1919906607;
  v2[1] = 1482184820;
  v2[2] = 5789784;
  *(_DWORD *)ptr = 0;
  if ( ++dword_806AF18 == dword_806ADC4 )
    dword_806AF18 = 0;
  sub_804B488((int)&v15);
  v13 = sub_805CF75((int)dest, 0x80000);
  if ( v13 >= 0 )
  {
    *off_806A37C = (int)ptr;
    off_806A37C = (int *)ptr;
  }
  v14 = *__errno_location();
  sub_804B4BD((unsigned __int8 *)&v15);
  *__errno_location() = v14;
  if ( v13 < 0 )
  {
    if ( v8 != 1 || *__errno_location() != 24 )
    {
      v3 = sub_805B25F(4, (int)s);
      v4 = gettext("cannot create temporary file in %s");
      v5 = *__errno_location();
      v7 = v3;
      error(2, v5, v4, v3);
    }
    free(ptr);
    ptr = 0;
  }
  *a1 = v13;
  return ptr;
}
// 806A37C: using guessed type int *off_806A37C;
// 806ADC4: using guessed type int dword_806ADC4;
// 806AF18: using guessed type int dword_806AF18;

//----- (0804BAA0) --------------------------------------------------------
#error "804BAC6: call analysis failed (funcsize=60)"

//----- (0804BC34) --------------------------------------------------------
int __cdecl sub_804BC34(char *s1, char *modes)
{
  char *v2; // eax
  int v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_804BAA0(s1, modes);
  if ( !v4 )
  {
    v2 = gettext("open failed");
    sub_804B16A((int)v2, s1);
  }
  return v4;
}

//----- (0804BC75) --------------------------------------------------------
int __cdecl sub_804BC75(FILE *stream, int a2)
{
  int v2; // eax
  int result; // eax
  char *v4; // eax

  v2 = fileno(stream);
  if ( !v2 )
    goto LABEL_4;
  if ( v2 != 1 )
  {
    dword_806A288 = (int)&loc_804BD05;
    sub_80611DA();
LABEL_4:
    result = feof_unlocked(stream);
    if ( result )
    {
      clearerr_unlocked(stream);
      dword_806A268 = (int)&locret_804BD2F;
      result = sub_80612C7();
    }
    return result;
  }
  result = fflush_unlocked(stream);
  if ( result )
  {
    v4 = gettext("fflush failed");
    sub_804B16A((int)v4, (char *)a2);
  }
  return result;
}
// 80612C7: using guessed type int sub_80612C7(void);
// 806A268: using guessed type int dword_806A268;
// 806A288: using guessed type int dword_806A288;

//----- (0804BD31) --------------------------------------------------------
int __cdecl sub_804BD31(int fd, int fd2)
{
  int result; // eax

  result = fd;
  if ( fd != fd2 )
  {
    dup2(fd, fd2);
    result = close(fd);
  }
  return result;
}

//----- (0804BD5E) --------------------------------------------------------
__pid_t __cdecl sub_804BD5E(int pipedes[2], int a2)
{
  void *v3; // eax
  int v4; // edx
  int v5; // ecx
  int v6; // eax
  int v7; // ST24_4
  __pid_t v8; // [esp+14h] [ebp-A4h]
  int v9; // [esp+18h] [ebp-A0h]
  int v10; // [esp+1Ch] [ebp-9Ch]
  double v11; // [esp+20h] [ebp-98h]
  char v12; // [esp+2Ch] [ebp-8Ch]

  v11 = 0.25;
  if ( sub_80596AA(pipedes, 0x80000) < 0 )
    return -1;
  if ( dword_806A378 + 1 < (unsigned int)dword_806AE64 )
    sub_804B7AF();
  while ( 1 )
  {
    v6 = a2--;
    if ( !v6 )
      break;
    sub_804B488((int)&v12);
    v9 = dword_806AE5C;
    dword_806AE5C = 0;
    v8 = fork();
    v10 = *__errno_location();
    v3 = &loc_804BE21;
    if ( !v8 )
      v3 = &loc_804BE2C;
    dword_806A288 = (int)v3;
    sub_80611DA();
    dword_806AE5C = v9;
    sub_804B4BD((unsigned __int8 *)&v12);
    *__errno_location() = v10;
    if ( v8 >= 0 || *__errno_location() != 11 )
      break;
    sub_805E35A(v11);
    v11 = v11 + v11;
    sub_804B75E(v5, v4);
  }
  if ( v8 >= 0 )
  {
    if ( v8 )
    {
      ++dword_806AE64;
    }
    else
    {
      close(0);
      close(1);
    }
  }
  else
  {
    v7 = *__errno_location();
    close(*pipedes);
    close(pipedes[1]);
    *__errno_location() = v7;
  }
  return v8;
}
// 806A288: using guessed type int dword_806A288;
// 806AE5C: using guessed type int dword_806AE5C;
// 806AE64: using guessed type int dword_806AE64;

//----- (0804BF08) --------------------------------------------------------
char *__cdecl sub_804BF08(FILE **a1, char a2)
{
  __pid_t v2; // eax
  int *v3; // eax
  char *v4; // ebx
  char *v5; // eax
  int v7; // [esp+8h] [ebp-20h]
  char v8; // [esp+Ch] [ebp-1Ch]
  int fd; // [esp+10h] [ebp-18h]
  char *v10; // [esp+14h] [ebp-14h]
  int pipedes[2]; // [esp+18h] [ebp-10h]

  v8 = a2;
  v10 = (char *)sub_804B883(&fd, a2);
  if ( !v10 )
  {
    dword_806A288 = (int)&loc_804C071;
    sub_80611DA();
  }
  v10[8] = 0;
  if ( s1 )
  {
    v2 = sub_804BD5E(pipedes, 4);
    *((_DWORD *)v10 + 1) = v2;
    if ( *((_DWORD *)v10 + 1) <= 0 )
    {
      if ( !*((_DWORD *)v10 + 1) )
      {
        close(pipedes[1]);
        sub_804BD31(fd, 1);
        sub_804BD31(pipedes[0], 0);
        v7 = 0;
        execlp(s1, s1, 0, *(_DWORD *)&v8);
        v3 = __errno_location();
        sub_804B094(*v3, "couldn't execute compress program");
      }
    }
    else
    {
      close(fd);
      close(pipedes[0]);
      fd = pipedes[1];
      sub_804B65D((int)v10);
    }
  }
  *a1 = fdopen(fd, "w");
  if ( !*a1 )
  {
    v4 = v10 + 9;
    v5 = gettext("couldn't create temporary file");
    sub_804B16A((int)v5, v4);
  }
  return v10;
}
// 806A288: using guessed type int dword_806A288;

//----- (0804C077) --------------------------------------------------------
char *__cdecl sub_804C077(FILE **a1)
{
  return sub_804BF08(a1, 0);
}

//----- (0804C092) --------------------------------------------------------
FILE *__cdecl sub_804C092(int a1)
{
  FILE *result; // eax
  __pid_t v6; // eax
  void *v7; // esi
  char *v8; // ebx
  int *v9; // eax
  int *v10; // eax
  FILE *v11; // eax
  int v12; // ST28_4
  FILE *v13; // [esp+18h] [ebp-20h]
  int fd; // [esp+1Ch] [ebp-1Ch]
  int pipedes[2]; // [esp+28h] [ebp-10h]

  v13 = 0;
  if ( *(_BYTE *)(a1 + 8) == 1 )
    sub_804B73C(*(_DWORD *)(a1 + 4));
  fd = open64(a1 + 9, 0);
  _CF = 0;
  _OF = 0;
  _ZF = fd == 0;
  _SF = fd < 0;
  if ( fd >= 0 )
  {
    v6 = sub_804BD5E(pipedes, 9);
    if ( v6 == -1 )
    {
      if ( *__errno_location() != 24 )
      {
        v7 = sub_805B25F(4, (int)s1);
        v8 = gettext("couldn't create process for %s -d");
        v9 = __errno_location();
        error(2, *v9, v8, v7);
      }
      close(fd);
      *__errno_location() = 24;
    }
    else
    {
      if ( !v6 )
      {
        close(pipedes[0]);
        sub_804BD31(fd, 0);
        sub_804BD31(pipedes[1], 1);
        execlp(s1, s1, "-d", 0);
        v10 = __errno_location();
        sub_804B094(*v10, "couldn't execute compress program (with -d)");
      }
      *(_DWORD *)(a1 + 4) = v6;
      sub_804B65D(a1);
      close(fd);
      close(pipedes[1]);
      v11 = fdopen(pipedes[0], "r");
      v13 = v11;
      if ( !v11 )
      {
        v12 = *__errno_location();
        close(pipedes[0]);
        *__errno_location() = v12;
      }
    }
    result = v13;
  }
  else
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);

//----- (0804C256) --------------------------------------------------------
int __cdecl sub_804C256(int a1)
{
  int v1; // eax
  _DWORD *v2; // edx
  int result; // eax

  if ( dword_806ADC4 == dword_806ADC8 )
    ptr = sub_805DEC1(ptr, (int)&dword_806ADC8, 4);
  v1 = dword_806ADC4++;
  v2 = (char *)ptr + 4 * v1;
  result = a1;
  *v2 = a1;
  return result;
}
// 806ADC4: using guessed type int dword_806ADC4;
// 806ADC8: using guessed type int dword_806ADC8;

//----- (0804C2AE) --------------------------------------------------------
#error "804C320: call analysis failed (funcsize=31)"

//----- (0804C325) --------------------------------------------------------
#error "804C33C: positive sp value has been found (funcsize=0)"

//----- (0804C424) --------------------------------------------------------
#error "804C455: call analysis failed (funcsize=18)"

//----- (0804C45A) --------------------------------------------------------
#error "804C472: positive sp value has been found (funcsize=0)"

//----- (0804C473) --------------------------------------------------------
#error "804C616: call analysis failed (funcsize=132)"

//----- (0804C718) --------------------------------------------------------
unsigned int __usercall sub_804C718@<eax>(int a1@<ebx>, int a2, char a3, char *a4)
{
  int v4; // eax
  int v5; // edx
  int v6; // ecx
  bool v7; // zf
  void *v8; // eax
  void *v9; // ebx
  int v10; // esi
  char *v11; // eax
  void *v12; // ebx
  int v13; // esi
  char *v14; // eax
  void *v16; // ebx
  int v17; // esi
  char *v18; // eax
  int v19; // ebx
  int v20; // esi
  char *v21; // eax
  int v22; // [esp-8h] [ebp-60h]
  int v23; // [esp-4h] [ebp-5Ch]
  int v24; // [esp+0h] [ebp-58h]
  int v25; // [esp+4h] [ebp-54h]
  int v26; // [esp+8h] [ebp-50h]
  int v27; // [esp+Ch] [ebp-4Ch]
  int v28; // [esp+10h] [ebp-48h]
  int v29; // [esp+14h] [ebp-44h]
  char *nptr; // [esp+18h] [ebp-40h]
  char v31; // [esp+1Ch] [ebp-3Ch]
  int v32; // [esp+20h] [ebp-38h]
  unsigned int v33; // [esp+24h] [ebp-34h]
  __int64 v34; // [esp+28h] [ebp-30h]
  int v35; // [esp+30h] [ebp-28h]
  char v36; // [esp+41h] [ebp-17h]
  unsigned int v37; // [esp+4Ch] [ebp-Ch]

  v31 = a3;
  nptr = a4;
  v37 = __readgsdword(0x14u);
  v32 = sub_805EBBD(a4, 0, 10, (int)(&v24 - 12), 0);
  v4 = getrlimit64(7, &v35);
  v7 = v4 == 0;
  v23 = v4;
  v22 = a1;
  v8 = &loc_804C7A4;
  if ( !v7 )
    v8 = &loc_804C7AF;
  dword_806A234 = (int)v8;
  sub_806143E(v6, v5);
  v33 = v35 - 3;
  if ( v32 )
  {
LABEL_11:
    if ( v32 == 1 )
    {
      v16 = sub_805B697((int)nptr);
      v17 = *((_DWORD *)&longopts.name + 4 * a2);
      v18 = gettext("--%s argument %s too large");
      v28 = (int)v16;
      v27 = v17;
      error(0, 0, v18, v17, v16);
      v19 = sub_8058E88(v33, (int)&v36);
      v20 = *((_DWORD *)&longopts.name + 4 * a2);
      v21 = gettext("maximum --%s argument with current rlimit is %s");
      v28 = v19;
      v27 = v20;
      error(2, 0, v21, v20, v19);
    }
    sub_805EA23(v32, a2, v31, (int)&longopts, (int)nptr);
  }
  dword_806A378 = v34;
  if ( v34 != (unsigned int)v34 )
  {
    v32 = 1;
    goto LABEL_11;
  }
  if ( (unsigned int)dword_806A378 <= 1 )
  {
    v9 = sub_805B697((int)nptr);
    v10 = *((_DWORD *)&longopts.name + 4 * a2);
    v11 = gettext("invalid --%s argument %s");
    v28 = (int)v9;
    v27 = v10;
    error(0, 0, v11, v10, v9);
    v12 = sub_805B697((int)"2");
    v13 = *((_DWORD *)&longopts.name + 4 * a2);
    v14 = gettext("minimum --%s argument is %s");
    v28 = (int)v12;
    v27 = v13;
    error(2, 0, v14);
  }
  if ( v33 < dword_806A378 )
  {
    dword_806A220 = (int)&loc_804C8DF;
    sub_80614AE(v24, v25, v26, v27, v28, v29, nptr, *(_DWORD *)&v31, 1, v33, v34, HIDWORD(v34));
  }
  return __readgsdword(0x14u) ^ v37;
}
// 8049920: using guessed type int __cdecl getrlimit64(_DWORD, _DWORD);
// 806143E: using guessed type int __fastcall sub_806143E(_DWORD, _DWORD);
// 80614AE: using guessed type int __stdcall sub_80614AE(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806A220: using guessed type int dword_806A220;
// 806A234: using guessed type int dword_806A234;

//----- (0804C9B1) --------------------------------------------------------
int __cdecl sub_804C9B1(int a1, int a2, char *nptr)
{
  int v3; // eax
  long double v4; // fst7
  __int16 v5; // ax
  unsigned __int64 v6; // rax
  __int16 v7; // ax
  int result; // eax
  unsigned __int64 v9; // [esp+18h] [ebp-50h]
  double v10; // [esp+20h] [ebp-48h]
  __int16 v11; // [esp+28h] [ebp-40h]
  __int16 v12; // [esp+2Ah] [ebp-3Eh]
  char v13; // [esp+2Ch] [ebp-3Ch]
  int v14; // [esp+38h] [ebp-30h]
  int v15; // [esp+3Ch] [ebp-2Ch]
  unsigned __int64 v16; // [esp+40h] [ebp-28h]
  double v17; // [esp+48h] [ebp-20h]

  v13 = a2;
  v15 = sub_805EBBD(nptr, (int)&v14, 10, (int)&v16, "EgGkKmMPtTYZ");
  if ( !v15 && (unsigned int)(*(char *)(v14 - 1) - 48) <= 9 )
  {
    if ( HIDWORD(v16) <= 0x3FFFFF )
    {
      v16 <<= 10;
      dword_806A2BC = (int)&loc_804CA58;
      sub_8061057();
    }
    v15 = 1;
  }
  if ( v15 == 2 && (unsigned int)(*(char *)(v14 - 1) - 48) <= 9 && !*(_BYTE *)(v14 + 1) )
  {
    v3 = *(char *)v14;
    if ( v3 == 37 )
    {
      v4 = sub_8059511();
      v9 = v16;
      v10 = (long double)v16;
      v17 = v4 * v10 / 100.0;
      if ( v17 < 1.844674407370955e19 )
      {
        if ( v17 >= 9.223372036854776e18 )
        {
          LOBYTE(v7) = v12;
          HIBYTE(v7) = 12;
          v11 = v7;
          v9 = (signed __int64)(v17 - 9.223372036854776e18);
          v6 = v9 ^ 0x8000000000000000LL;
        }
        else
        {
          LOBYTE(v5) = v12;
          HIBYTE(v5) = 12;
          v11 = v5;
          v9 = (signed __int64)v17;
          v6 = (signed __int64)v17;
        }
        v16 = v6;
        v15 = 0;
        dword_806A2BC = (int)&loc_804CBBE;
        sub_8061057();
      }
      v15 = 1;
    }
    else if ( v3 == 98 )
    {
      v15 = 0;
    }
  }
  if ( v15 )
LABEL_25:
    sub_805EA23(v15, a1, v13, (int)&longopts, (int)nptr);
  result = v16;
  if ( size > v16 )
    return result;
  size = v16;
  if ( v16 != (unsigned int)v16 )
  {
    v15 = 1;
    goto LABEL_25;
  }
  result = size;
  if ( 18 * dword_806A378 >= size )
    result = 18 * dword_806A378;
  size = result;
  return result;
}
// 8061057: using guessed type int sub_8061057(void);
// 806A2BC: using guessed type int dword_806A2BC;

//----- (0804CC90) --------------------------------------------------------
int __usercall sub_804CC90@<eax>(int a1@<ebx>, int a2, int a3, char *nptr)
{
  char *v5; // eax
  int v6; // [esp+0h] [ebp-38h]
  char v7; // [esp+1Ch] [ebp-1Ch]
  int v8; // [esp+28h] [ebp-10h]
  int v9; // [esp+2Ch] [ebp-Ch]

  v7 = a3;
  v9 = sub_805E47E(a1, nptr, 0, 10, (int)(&v6 - 4), &s);
  if ( v9 == 1 )
    return -1;
  if ( v9 )
    sub_805EA23(v9, a2, v7, (int)&longopts, (int)nptr);
  if ( !v8 )
  {
    v5 = gettext("number in parallel must be nonzero");
    error(2, 0, v5);
  }
  return v8;
}

//----- (0804CD45) --------------------------------------------------------
#error "804CEBD: call analysis failed (funcsize=125)"

//----- (0804CEC2) --------------------------------------------------------
#error "804CFB5: positive sp value has been found (funcsize=68)"

//----- (0804CFB8) --------------------------------------------------------
int __cdecl sub_804CFB8(FILE **a1, unsigned int a2, int *a3, unsigned int a4, int a5)
{
  int v5; // eax
  bool v6; // al
  int v7; // eax
  bool v8; // zf
  void *v9; // eax
  char *v10; // ebx
  char *v11; // eax
  int v13; // [esp+0h] [ebp-98h]
  int v14; // [esp+4h] [ebp-94h]
  int v15; // [esp+8h] [ebp-90h]
  int v16; // [esp+Ch] [ebp-8Ch]
  int v17; // [esp+10h] [ebp-88h]
  int v18; // [esp+14h] [ebp-84h]
  char v19; // [esp+30h] [ebp-68h]

  if ( a4 > 0 )
  {
    if ( a2 <= 0 )
    {
      if ( !strcmp((const char *)*a3, "-") )
        v7 = sub_8060FCE(0, (int)&v19);
      else
        v7 = sub_8060F9F(*a3, (int)&v19);
      v6 = v7 != 0;
    }
    else
    {
      v5 = fileno(*a1);
      v6 = sub_8060FCE(v5, (int)&v19) != 0;
    }
    v8 = v6 == 0;
    v9 = &loc_804D0A8;
    if ( v8 )
      v9 = &loc_804D0D1;
    dword_806A248 = (int)v9;
    sub_80613AB(v13, v14, v15, v16, v17, v18, a5 + 2);
    v10 = (char *)*a3;
    v11 = gettext("stat failed");
    sub_804B16A((int)v11, v10);
  }
  return a5 + 2;
}
// 80613AB: using guessed type int __stdcall sub_80613AB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806A248: using guessed type int dword_806A248;

//----- (0804D1D2) --------------------------------------------------------
void __cdecl __noreturn sub_804D1D2(int a1, int a2, size_t size)
{
  void *v3; // edx
  int v4; // ecx
  size_t sizea; // [esp+28h] [ebp+10h]

  while ( 1 )
  {
    sizea = (size & 0xFFFFFFF0) + 16;
    v3 = malloc(sizea);
    *(_DWORD *)a1 = v3;
    if ( *(_DWORD *)a1 )
    {
      dword_806A234 = (int)sub_804D230;
      sub_806143E(v4, v3);
    }
    size = sizea >> 1;
    if ( a2 + 1 >= size )
      sub_805E145();
  }
}
// 804D230: using guessed type int sub_804D230();
// 806143E: using guessed type int __fastcall sub_806143E(_DWORD, _DWORD);
// 806A234: using guessed type int dword_806A234;

//----- (0804D230) --------------------------------------------------------
#error "804D27C: positive sp value has been found (funcsize=22)"

//----- (0804D27D) --------------------------------------------------------
int __cdecl sub_804D27D(_DWORD *a1)
{
  return *a1 + a1[3];
}

//----- (0804D2A8) --------------------------------------------------------
#error "804D343: call analysis failed (funcsize=100)"

//----- (0804D44C) --------------------------------------------------------
#error "804D4B1: call analysis failed (funcsize=129)"

//----- (0804D5D7) --------------------------------------------------------
#error "804D6D0: call analysis failed (funcsize=84)"

//----- (0804DA4B) --------------------------------------------------------
int __cdecl sub_804DA4B(char **a1)
{
  int v1; // edx
  char *v2; // eax
  int result; // eax
  char *v4; // eax
  unsigned __int8 v5; // [esp+9h] [ebp-7h]
  bool v6; // [esp+Ah] [ebp-6h]
  unsigned __int8 v7; // [esp+Bh] [ebp-5h]
  char *v8; // [esp+Ch] [ebp-4h]

  v8 = *a1;
  v5 = 0;
  v6 = 0;
  while ( 1 )
  {
    v2 = v8++;
    v7 = *v2;
    if ( (unsigned int)(unsigned __int8)*v2 - 48 > 9 )
      break;
    if ( v5 < v7 )
      v5 = *v2;
    v1 = *v8;
    v6 = v1 == dword_806A9A0;
    if ( v1 == dword_806A9A0 )
      ++v8;
  }
  if ( v6 )
  {
    *a1 = v8 - 2;
    result = v5;
  }
  else
  {
    if ( v7 == dword_806A99C )
    {
      while ( 1 )
      {
        v4 = v8++;
        if ( (unsigned int)(unsigned __int8)*v4 - 48 > 9 )
          break;
        if ( v5 < (unsigned __int8)*v4 )
          v5 = *v4;
      }
    }
    *a1 = v8 - 1;
    result = v5;
  }
  return result;
}
// 806A99C: using guessed type int dword_806A99C;
// 806A9A0: using guessed type int dword_806A9A0;

//----- (0804DB10) --------------------------------------------------------
int __cdecl sub_804DB10(_BYTE *a1)
{
  int result; // eax
  int v6; // [esp+0h] [ebp-14h]
  bool v7; // [esp+9h] [ebp-Bh]
  unsigned __int8 v8; // [esp+Ah] [ebp-Ah]
  unsigned __int8 v9; // [esp+Bh] [ebp-9h]
  char *v10; // [esp+Ch] [ebp-8h]
  int v11; // [esp+10h] [ebp-4h]

  v7 = *a1 == 45;
  v10 = &a1[v7];
  v8 = sub_804DA4B((char **)&v6 - 2);
  _CF = v8 < 0x30u;
  _OF = __OFSUB__(v8, 48);
  _ZF = v8 == 48;
  _SF = (char)(v8 - 48) < 0;
  if ( v8 <= 0x30u )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  else
  {
    v9 = *v10;
    v11 = byte_8062DC8[v9];
    if ( v7 )
      result = -v11;
    else
      result = v11;
  }
  return result;
}

//----- (0804DB88) --------------------------------------------------------
int __cdecl sub_804DB88(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v2; // ebx
  int v3; // eax
  int result; // eax

  while ( byte_806A9BC[(unsigned __int8)sub_804AE10(*a1)] )
    ++a1;
  while ( byte_806A9BC[(unsigned __int8)sub_804AE10(*a2)] )
    ++a2;
  v2 = sub_804DB10(a1);
  v3 = sub_804DB10(a2);
  if ( v2 == v3 )
    result = sub_805D66F((int)a1, (int)a2, dword_806A99C, dword_806A9A0);
  else
    result = v2 - v3;
  return result;
}
// 806A99C: using guessed type int dword_806A99C;
// 806A9A0: using guessed type int dword_806A9A0;

//----- (0804DC2E) --------------------------------------------------------
int __cdecl sub_804DC2E(unsigned __int8 *a1, unsigned __int8 *a2)
{
  while ( byte_806A9BC[(unsigned __int8)sub_804AE10(*a1)] )
    ++a1;
  while ( byte_806A9BC[(unsigned __int8)sub_804AE10(*a2)] )
    ++a2;
  return sub_805D66F((int)a1, (int)a2, dword_806A99C, dword_806A9A0);
}
// 806A99C: using guessed type int dword_806A99C;
// 806A9A0: using guessed type int dword_806A9A0;

//----- (0804DCA5) --------------------------------------------------------
int __cdecl sub_804DCA5(int a1, int a2)
{
  _TBYTE s; // [esp+10h] [ebp-28h]
  _TBYTE s2; // [esp+20h] [ebp-18h]

  memset(&s, 0, 0xCu);
  *(long double *)&s = strtold(a1, 0);
  memset(&s2, 0, 0xCu);
  *(long double *)&s2 = strtold(a2, 0);
  return memcmp(&s, &s2, 0xCu);
}
// 80498F0: using guessed type double __cdecl strtold(_DWORD, _DWORD);

//----- (0804DD29) --------------------------------------------------------
signed int __cdecl sub_804DD29(int a1, unsigned int a2)
{
  signed int result; // eax
  void *v7; // eax
  unsigned int v8; // [esp-4h] [ebp-4Ch]
  int v9; // [esp+18h] [ebp-30h]
  unsigned int v10; // [esp+1Ch] [ebp-2Ch]
  long double v11; // [esp+20h] [ebp-28h]
  long double v12; // [esp+30h] [ebp-18h]

  v11 = strtold(a1, &v9);
  v12 = strtold(a2, &v10);
  if ( a1 == v9 )
  {
    _CF = a2 < v10;
    _OF = __OFSUB__(a2, v10);
    _ZF = a2 == v10;
    _SF = (signed int)(a2 - v10) < 0;
    if ( a2 == v10 )
    {
      __asm { pushfw }
      result = 0;
      __asm { popfw }
    }
    else
    {
      result = -1;
    }
  }
  else
  {
    v8 = v10;
    v7 = &loc_804DDAC;
    if ( a2 != v10 )
      v7 = &loc_804DDB6;
    dword_806A2BC = (int)v7;
    sub_8061057();
    result = 1;
  }
  return result;
}
// 80498F0: using guessed type double __cdecl strtold(_DWORD, _DWORD);
// 8061057: using guessed type int sub_8061057(void);
// 806A2BC: using guessed type int dword_806A2BC;

//----- (0804DE55) --------------------------------------------------------
#error "804DEDF: call analysis failed (funcsize=105)"

//----- (0804DFAF) --------------------------------------------------------
void __cdecl __noreturn sub_804DFAF(char *a1)
{
  char *v1; // eax
  bool v2; // zf
  int (__cdecl *v3)(int, int); // eax
  char *v4; // eax
  char *v5; // [esp+18h] [ebp-20h]
  char ptr; // [esp+1Ch] [ebp-1Ch]
  unsigned int v7; // [esp+2Ch] [ebp-Ch]

  v7 = __readgsdword(0x14u);
  v5 = sub_805B97D((int)a1, 0x10u);
  if ( !v5 )
  {
    v1 = gettext("open failed");
    sub_804B16A((int)v1, a1);
  }
  sub_805BC57((int)v5, &ptr, 0x10u);
  v2 = sub_805BC9F(v5) == 0;
  v3 = (int (__cdecl *)(int, int))&loc_804E04F;
  if ( v2 )
    v3 = sub_804E06A;
  dword_806A288 = (int)v3;
  sub_80611DA();
  v4 = gettext("close failed");
  sub_804B16A((int)v4, a1);
}
// 804E06A: using guessed type int __cdecl sub_804E06A(int, int);
// 806A288: using guessed type int dword_806A288;

//----- (0804E06A) --------------------------------------------------------
#error "804E0A3: positive sp value has been found (funcsize=0)"

//----- (0804E0A4) --------------------------------------------------------
size_t __cdecl sub_804E0A4(char *dest, char *src, size_t n)
{
  char *v3; // ebx
  int *v4; // eax
  char *v5; // eax
  void *v6; // ebx
  char *v7; // eax
  size_t v9; // [esp+1Ch] [ebp-Ch]

  *__errno_location() = 0;
  v9 = strxfrm(dest, src, n);
  if ( *__errno_location() )
  {
    v3 = gettext("string transformation failed");
    v4 = __errno_location();
    error(0, *v4, v3);
    v5 = gettext("set LC_ALL='C' to work around the problem");
    error(0, 0, v5);
    v6 = sub_805B1E4(0, 8, (int)src);
    v7 = gettext("the untransformed string was %s");
    error(2, 0, v7, v6);
  }
  return v9;
}

//----- (0804E17C) --------------------------------------------------------
int __cdecl sub_804E17C(int a1, int a2, int a3, size_t a4)
{
  size_t v4; // eax
  void *v5; // eax
  void *v6; // eax
  size_t v11; // eax
  size_t v20; // edx
  char *v25; // eax
  size_t v26; // eax
  size_t v27; // eax
  void *v28; // eax
  size_t v29; // eax
  char *s; // [esp+0h] [ebp-1150h]
  char *src; // [esp+4h] [ebp-114Ch]
  bool v33; // [esp+13h] [ebp-113Dh]
  int v34; // [esp+14h] [ebp-113Ch]
  char *dest; // [esp+18h] [ebp-1138h]
  size_t size; // [esp+1Ch] [ebp-1134h]
  void *ptr; // [esp+20h] [ebp-1130h]
  int v38; // [esp+24h] [ebp-112Ch]
  char *v39; // [esp+28h] [ebp-1128h]
  char *v40; // [esp+2Ch] [ebp-1124h]
  size_t v41; // [esp+30h] [ebp-1120h]
  size_t n; // [esp+34h] [ebp-111Ch]
  size_t v43; // [esp+38h] [ebp-1118h]
  char s1; // [esp+3Ch] [ebp-1114h]
  int v45; // [esp+4Ch] [ebp-1104h]
  char v46; // [esp+5Ch] [ebp-10F4h]
  char v47; // [esp+F8h] [ebp-1058h]
  char v48; // [esp+194h] [ebp-FBCh]
  unsigned int v49; // [esp+1134h] [ebp-1Ch]

  src = (char *)a1;
  s = (char *)a3;
  v49 = __readgsdword(0x14u);
  v34 = 0;
  dest = &v48;
  size = 4000;
  ptr = 0;
  qmemcpy(&v47, &unk_806AE7C, 0x9Cu);
  qmemcpy(&v46, &v47, 0x9Cu);
  if ( byte_806A9A4 )
  {
    v39 = &src[a2];
    v40 = &s[a4];
    while ( 1 )
    {
      v41 = 3 * (a4 + a2) + 2;
      if ( size < v41 )
      {
        v4 = v41;
        if ( 3 * size >> 1 >= v41 )
          v4 = 3 * size >> 1;
        size = v4;
        free(ptr);
        v5 = malloc(size);
        ptr = v5;
        dest = (char *)v5;
        _ZF = v5 == 0;
        v6 = &loc_804E30B;
        if ( !_ZF )
          v6 = &loc_804E321;
        dword_806A288 = (int)v6;
        sub_80611DA();
        dest = &v48;
        size = 4000;
      }
      _CF = src < v39;
      _OF = __OFSUB__(src, v39);
      _ZF = src == v39;
      _SF = src - v39 < 0;
      if ( src >= v39 )
      {
        __asm { pushfw }
        v11 = 0;
        __asm { popfw }
      }
      else
      {
        v11 = sub_804E0A4(dest, src, size) + 1;
      }
      n = v11;
      v33 = v11 <= size;
      _CF = s < v40;
      _OF = __OFSUB__(s, v40);
      _ZF = s == v40;
      _SF = s - v40 < 0;
      if ( s >= v40 )
      {
        __asm { pushfw }
        v26 = 0;
        __asm { popfw }
      }
      else
      {
        _CF = 0;
        _OF = 0;
        _ZF = v33 == 0;
        _SF = v33 < 0;
        if ( v33 )
        {
          v20 = size - n;
        }
        else
        {
          __asm { pushfw }
          v20 = 0;
          __asm { popfw }
        }
        _CF = 0;
        _OF = 0;
        _ZF = v33 == 0;
        _SF = v33 < 0;
        if ( v33 )
        {
          v25 = &dest[n];
        }
        else
        {
          __asm { pushfw }
          v25 = 0;
          __asm { popfw }
        }
        v26 = sub_804E0A4(v25, s, v20) + 1;
      }
      v43 = v26;
      if ( v33 != 1 || n + v43 > size )
      {
        size = n + v43;
        if ( n + v43 <= 0x55555554 )
          size = 3 * size >> 1;
        free(ptr);
        ptr = (void *)sub_805DF6E(size);
        dest = (char *)ptr;
        if ( src < v39 )
          strxfrm(dest, src, n);
        if ( s < v40 )
          strxfrm(&dest[n], s, v43);
      }
      if ( src < v39 )
        src += strlen(src) + 1;
      if ( s < v40 )
        s += strlen(s) + 1;
      if ( src >= v39 && s >= v40 )
        break;
      sub_8055D2E(dest, n, &v46);
      sub_8055D2E(&dest[n], v43, &v47);
      if ( !v34 )
      {
        v27 = n;
        if ( v43 <= n )
          v27 = v43;
        v34 = memcmp(dest, &dest[n], v27);
        if ( !v34 )
          v34 = (n > v43) - (n < v43);
      }
    }
    a2 = n;
    src = dest;
    a4 = v43;
    s = &dest[n];
  }
  sub_8055D2E(src, a2, &v46);
  sub_8055A64((int *)&v46, &s1);
  sub_8055D2E(s, a4, &v47);
  sub_8055A64((int *)&v47, &v45);
  v38 = memcmp(&s1, &v45, 0x10u);
  if ( !v38 )
  {
    v28 = &loc_804E758;
    if ( v34 )
      v28 = &loc_804E7BF;
    dword_806A2BC = (int)v28;
    sub_8061057();
    v29 = a2;
    if ( a4 <= a2 )
      v29 = a4;
    v34 = memcmp(src, s, v29);
    if ( !v34 )
      v34 = (a2 > a4) - (a2 < a4);
    v38 = v34;
  }
  free(ptr);
  return v38;
}
// 8055D2E: using guessed type _DWORD __cdecl sub_8055D2E(_DWORD, _DWORD, _DWORD);
// 8061057: using guessed type int sub_8061057(void);
// 806A288: using guessed type int dword_806A288;
// 806A2BC: using guessed type int dword_806A2BC;
// 806A9A4: using guessed type char byte_806A9A4;

//----- (0804E7FB) --------------------------------------------------------
#error "804E812: call analysis failed (funcsize=14)"

//----- (0804E825) --------------------------------------------------------
#error "804E86F: positive sp value has been found (funcsize=0)"

//----- (0804E870) --------------------------------------------------------
int __cdecl sub_804E870(int a1, int a2)
{
  void *v2; // eax
  void *v3; // eax
  char *v4; // eax
  int v6; // [esp+0h] [ebp-18h]
  int v7; // [esp+4h] [ebp-14h]
  int v8; // [esp+8h] [ebp-10h]
  int v9; // [esp+Ch] [ebp-Ch]
  int v10; // [esp+10h] [ebp-8h]
  int v11; // [esp+14h] [ebp-4h]
  int savedregs; // [esp+18h] [ebp+0h]

  v2 = &loc_804E8AA;
  if ( a1 )
    v2 = &loc_804E878;
  dword_806A248 = (int)v2;
  sub_80613AB(v6, v7, v8, v9, v10, v11, savedregs);
  v3 = &loc_804E8C9;
  if ( a2 )
    v3 = &loc_804E8DF;
  dword_806A288 = (int)v3;
  sub_80611DA();
  v4 = gettext("^ no match for key\n");
  return printf(v4);
}
// 804E870: could not find valid save-restore pair for ebx
// 80613AB: using guessed type int __stdcall sub_80613AB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806A248: using guessed type int dword_806A248;
// 806A288: using guessed type int dword_806A288;

//----- (0804E903) --------------------------------------------------------
int __cdecl sub_804E903(_BYTE *a1)
{
  char v1; // al
  char v6; // al

  if ( a1[26] || a1[28] || (v1 = a1[29], _CF = 0, _OF = 0, _ZF = v1 == 0, _SF = v1 < 0, v1) )
  {
    v6 = 1;
  }
  else
  {
    __asm { pushfw }
    v6 = 0;
    __asm { popfw }
  }
  return v6 & 1;
}

//----- (0804E939) --------------------------------------------------------
int __cdecl sub_804E939(int *a1, int a2)
{
  void *v2; // eax
  int v4; // [esp+0h] [ebp-48h]
  int v5; // [esp+4h] [ebp-44h]
  int v6; // [esp+8h] [ebp-40h]
  int v7; // [esp+Ch] [ebp-3Ch]
  int v8; // [esp+10h] [ebp-38h]
  unsigned __int8 *v9; // [esp+14h] [ebp-34h]
  int v10; // [esp+18h] [ebp-30h]
  unsigned __int8 *v11; // [esp+1Ch] [ebp-2Ch]
  unsigned __int8 *v12; // [esp+20h] [ebp-28h]
  unsigned __int8 *v13; // [esp+24h] [ebp-24h]
  int v14; // [esp+28h] [ebp-20h]
  int v15; // [esp+2Ch] [ebp-1Ch]
  _TBYTE v16; // [esp+30h] [ebp-18h]

  v13 = (unsigned __int8 *)*a1;
  v11 = v13;
  v12 = &v13[a1[1] - 1];
  if ( a2 )
  {
    if ( *(_DWORD *)a2 != -1 )
      v11 = (unsigned __int8 *)sub_804D2A8(a1, a2);
    if ( *(_DWORD *)(a2 + 8) != -1 )
      v12 = (unsigned __int8 *)sub_804D44C(a1, a2);
    if ( *(_BYTE *)(a2 + 24) && *(_DWORD *)a2 == -1 || *(_BYTE *)(a2 + 30) || (unsigned __int8)sub_804E903((_BYTE *)a2) )
    {
      BYTE1(v8) = *v12;
      *v12 = 0;
      while ( byte_806A9BC[(unsigned __int8)sub_804AE10(*v11)] )
        ++v11;
      v9 = v11;
      if ( v12 >= v11 )
      {
        if ( *(_BYTE *)(a2 + 30) )
        {
          sub_804DE55(v11, &v9);
        }
        else
        {
          v2 = &loc_804EA7D;
          if ( !*(_BYTE *)(a2 + 28) )
            v2 = &loc_804EA97;
          dword_806A20C = (int)v2;
          sub_806151E(
            v4,
            v5,
            v6,
            v7,
            v8,
            v9,
            v10,
            v11,
            v12,
            v13,
            v14,
            v15,
            LODWORD(v16),
            DWORD1(v16),
            *((_DWORD *)&v16 + 2));
          *(long double *)&v16 = strtold(v11, &v9);
        }
      }
      else
      {
        v9 = v12;
      }
      *v12 = BYTE1(v8);
      v12 = v9;
    }
  }
  v14 = sub_804E7FB(v13, v11);
  v15 = sub_804E7FB(v11, v12);
  return sub_804E870(v14, v15);
}
// 80498F0: using guessed type double __cdecl strtold(_DWORD, _DWORD);
// 804D2A8: using guessed type _DWORD __cdecl sub_804D2A8(_DWORD, _DWORD);
// 804D44C: using guessed type _DWORD __cdecl sub_804D44C(_DWORD, _DWORD);
// 804DE55: using guessed type _DWORD __cdecl sub_804DE55(_DWORD, _DWORD);
// 804E7FB: using guessed type _DWORD __cdecl sub_804E7FB(_DWORD, _DWORD);
// 806151E: using guessed type int __stdcall sub_806151E(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806A20C: using guessed type int dword_806A20C;

//----- (0804EBAB) --------------------------------------------------------
#error "804EC02: call analysis failed (funcsize=46)"

//----- (0804EC40) --------------------------------------------------------
int __cdecl sub_804EC40(int a1)
{
  int v1; // eax
  int v4; // eax
  char v5; // al
  char v6; // al

  v1 = *(_DWORD *)(a1 + 16);
  _ZF = v1 == 0;
  _SF = v1 < 0;
  if ( v1 )
    goto LABEL_14;
  v4 = *(_DWORD *)(a1 + 20);
  _ZF = v4 == 0;
  _SF = v4 < 0;
  if ( v4 )
    goto LABEL_14;
  _ZF = *(_BYTE *)(a1 + 24) == 1;
  _SF = ((*(_BYTE *)(a1 + 24) ^ 1) & 0x80u) != 0;
  if ( *(_BYTE *)(a1 + 24) == 1 )
    goto LABEL_14;
  _ZF = *(_BYTE *)(a1 + 25) == 1;
  _SF = ((*(_BYTE *)(a1 + 25) ^ 1) & 0x80u) != 0;
  if ( *(_BYTE *)(a1 + 25) == 1 )
    goto LABEL_14;
  v5 = sub_804E903((_BYTE *)a1) ^ 1;
  _ZF = v5 == 0;
  _SF = v5 < 0;
  if ( !v5
    || (_ZF = *(_BYTE *)(a1 + 30) == 1, _SF = ((*(_BYTE *)(a1 + 30) ^ 1) & 0x80u) != 0, *(_BYTE *)(a1 + 30) == 1)
    || (_ZF = *(_BYTE *)(a1 + 32) == 1, _SF = ((*(_BYTE *)(a1 + 32) ^ 1) & 0x80u) != 0, *(_BYTE *)(a1 + 32) == 1)
    || (_ZF = *(_BYTE *)(a1 + 27) == 1, _SF = ((*(_BYTE *)(a1 + 27) ^ 1) & 0x80u) != 0, *(_BYTE *)(a1 + 27) == 1) )
  {
LABEL_14:
    __asm { pushfw }
    v6 = 0;
    __asm { popfw }
  }
  else
  {
    v6 = 1;
  }
  return v6 & 1;
}

//----- (0804ECC4) --------------------------------------------------------
_BYTE *__cdecl sub_804ECC4(int a1, _BYTE *a2)
{
  _BYTE *v2; // eax
  _BYTE *v3; // eax
  _BYTE *v4; // eax
  _BYTE *v5; // eax
  _BYTE *v6; // eax
  _BYTE *v7; // eax
  _BYTE *v8; // eax
  _BYTE *v9; // eax
  _BYTE *v10; // eax
  _BYTE *v11; // eax
  _BYTE *v12; // eax
  _BYTE *result; // eax

  if ( *(_BYTE *)(a1 + 24) || *(_BYTE *)(a1 + 25) )
  {
    v2 = a2++;
    *v2 = 98;
  }
  if ( *(_UNKNOWN **)(a1 + 16) == &unk_806ABBC )
  {
    v3 = a2++;
    *v3 = 100;
  }
  if ( *(_DWORD *)(a1 + 20) )
  {
    v4 = a2++;
    *v4 = 102;
  }
  if ( *(_BYTE *)(a1 + 28) )
  {
    v5 = a2++;
    *v5 = 103;
  }
  if ( *(_BYTE *)(a1 + 29) )
  {
    v6 = a2++;
    *v6 = 104;
  }
  if ( *(_UNKNOWN **)(a1 + 16) == &unk_806AABC )
  {
    v7 = a2++;
    *v7 = 105;
  }
  if ( *(_BYTE *)(a1 + 30) )
  {
    v8 = a2++;
    *v8 = 77;
  }
  if ( *(_BYTE *)(a1 + 26) )
  {
    v9 = a2++;
    *v9 = 110;
  }
  if ( *(_BYTE *)(a1 + 27) )
  {
    v10 = a2++;
    *v10 = 82;
  }
  if ( *(_BYTE *)(a1 + 31) )
  {
    v11 = a2++;
    *v11 = 114;
  }
  if ( *(_BYTE *)(a1 + 32) )
  {
    v12 = a2++;
    *v12 = 86;
  }
  result = a2;
  *a2 = 0;
  return result;
}

//----- (0804EDDA) --------------------------------------------------------
unsigned int __usercall sub_804EDDA@<eax>(char *a1@<ebx>, int *a2, unsigned __int8 a3)
{
  int v3; // eax
  int v4; // eax
  const char *v5; // edx
  int v6; // eax
  const char *v7; // eax
  void *v8; // esi
  char *v9; // eax
  unsigned int v14; // edx
  char v15; // al
  char *v16; // eax
  int v17; // eax
  void *v18; // eax
  char *v19; // ebx
  int v20; // edx
  int v21; // ecx
  char v22; // al
  char v27; // al
  signed int v28; // eax
  void *v33; // eax
  char v34; // al
  void *v35; // eax
  void *v36; // eax
  char *v37; // eax
  void *v38; // eax
  char *v39; // eax
  void *v40; // eax
  size_t v41; // eax
  int v42; // eax
  char *v43; // eax
  char *v44; // eax
  char *v46; // [esp-8h] [ebp-D0h]
  int v47; // [esp-4h] [ebp-CCh]
  unsigned __int64 v48; // [esp+0h] [ebp-C8h]
  int v49; // [esp+8h] [ebp-C0h]
  char *v50; // [esp+Ch] [ebp-BCh]
  void *v51; // [esp+10h] [ebp-B8h]
  int v52; // [esp+14h] [ebp-B4h]
  unsigned __int8 v53; // [esp+18h] [ebp-B0h]
  int *v54; // [esp+1Ch] [ebp-ACh]
  char v55; // [esp+20h] [ebp-A8h]
  char v56; // [esp+21h] [ebp-A7h]
  char v57; // [esp+22h] [ebp-A6h]
  char v58; // [esp+23h] [ebp-A5h]
  unsigned int *v59; // [esp+24h] [ebp-A4h]
  char *v60; // [esp+28h] [ebp-A0h]
  unsigned int v61; // [esp+2Ch] [ebp-9Ch]
  unsigned int v62; // [esp+30h] [ebp-98h]
  unsigned int v63; // [esp+34h] [ebp-94h]
  char *v64; // [esp+38h] [ebp-90h]
  char *v65; // [esp+3Ch] [ebp-8Ch]
  unsigned int v66; // [esp+40h] [ebp-88h]
  int v67; // [esp+44h] [ebp-84h]
  int v68; // [esp+48h] [ebp-80h]
  int v69; // [esp+4Ch] [ebp-7Ch]
  int v70; // [esp+50h] [ebp-78h]
  int v71; // [esp+54h] [ebp-74h]
  int v72; // [esp+58h] [ebp-70h]
  int v73; // [esp+5Ch] [ebp-6Ch]
  int v74; // [esp+60h] [ebp-68h]
  int v75; // [esp+64h] [ebp-64h]
  int v76; // [esp+68h] [ebp-60h]
  char v77; // [esp+6Eh] [ebp-5Ah]
  char v78; // [esp+83h] [ebp-45h]
  char s; // [esp+9Dh] [ebp-2Bh]
  unsigned int v80; // [esp+BCh] [ebp-Ch]

  v54 = a2;
  v53 = a3;
  v80 = __readgsdword(0x14u);
  v67 = *a2;
  v68 = a2[1];
  v69 = a2[2];
  v70 = a2[3];
  v71 = a2[4];
  v72 = a2[5];
  v73 = a2[6];
  v74 = a2[7];
  v75 = a2[8];
  v76 = a2[9];
  v60 = (char *)1;
  v59 = (unsigned int *)dword_806ADD0;
  while ( v59 )
  {
    if ( *((_BYTE *)v59 + 33) )
    {
      v61 = *v59;
      v63 = v59[2];
      v64 = &v78;
      v65 = (char *)&v48 - 43;
      if ( v61 == -1 )
        v61 = 0;
      v3 = sub_8058EF6(v61, (int)&v77);
      *(_WORD *)v64 = 43;
      v64 = (char *)stpcpy(v64 + 1, v3);
      v4 = sub_8058EF6(v61 + 1, (int)&v77);
      *(_DWORD *)v65 = 2124589;
      v65 = (char *)stpcpy(v65 + 3, v4);
      if ( v59[2] != -1 )
      {
        v48 = v63 + 1;
        v5 = (const char *)sub_8058EF6(v48, (int)&v77);
        v6 = (int)v64;
        *(_WORD *)v64 = 11552;
        *(_BYTE *)(v6 + 2) = 0;
        strcpy(v64 + 2, v5);
        v7 = (const char *)sub_8058EF6((v59[3] == -1) + v63 + 1, (int)&v48 - 90);
        *(_WORD *)v65 = 44;
        strcpy(v65 + 1, v7);
      }
      v8 = sub_805B675(1, (int)&s);
      a1 = (char *)sub_805B675(0, (int)&v78);
      v9 = gettext("obsolescent key %s used; consider %s instead");
      v51 = v8;
      v50 = a1;
      error(0, 0, v9);
    }
    _CF = *v59 < 0xFFFFFFFF;
    _OF = __OFSUB__(*v59, -1);
    _ZF = *v59 == -1;
    _SF = (signed int)(*v59 + 1) < 0;
    if ( *v59 == -1
      || (v14 = v59[2],
          _CF = v14 < *v59,
          _OF = __OFSUB__(v14, *v59),
          _ZF = v14 == *v59,
          _SF = (signed int)(v14 - *v59) < 0,
          v14 >= *v59) )
    {
      __asm { pushfw }
      v15 = 0;
      __asm { popfw }
    }
    else
    {
      v15 = 1;
    }
    v55 = v15 & 1;
    if ( v15 & 1 )
    {
      v16 = gettext("key %lu has zero width and will be ignored");
      v50 = v60;
      error(0, 0, v16);
    }
    v17 = sub_804E903(v59);
    _ZF = (_BYTE)v17 == 0;
    v47 = v17;
    v46 = a1;
    v18 = &loc_804F123;
    if ( !_ZF )
      v18 = &loc_804F131;
    dword_806A220 = (int)v18;
    v19 = v46;
    sub_80614AE(v48, HIDWORD(v48), v49, v50, v51, v52, *(_DWORD *)&v53, v54, *(_DWORD *)&v55, v59, v60, v61);
    v22 = *((_BYTE *)v59 + 30);
    _CF = 0;
    _OF = 0;
    _ZF = v22 == 0;
    _SF = v22 < 0;
    if ( v22 )
    {
      v27 = 1;
    }
    else
    {
      __asm { pushfw }
      v27 = 0;
      __asm { popfw }
    }
    v56 = v27 & 1;
    v28 = v59[2];
    _CF = 0;
    _OF = 0;
    _ZF = v28 == 0;
    _SF = v28 < 0;
    if ( v28 )
    {
      __asm { pushfw }
      v34 = 0;
      __asm { popfw }
    }
    else
    {
      _ZF = v59[3] == 0;
      v47 = v59[3];
      v46 = v19;
      v33 = &loc_804F18E;
      if ( _ZF )
        v33 = &loc_804F195;
      dword_806A288 = (int)v33;
      v19 = v46;
      sub_80611DA();
      v34 = 1;
    }
    v57 = v34 & 1;
    if ( v55 != 1 && v53 != 1 && dword_806A374 == 128 && v57 != 1 )
    {
      if ( *((_BYTE *)v59 + 24) != 1 && v56 != 1 )
        goto LABEL_38;
      if ( *((_BYTE *)v59 + 24) != 1 )
      {
        _ZF = v59[1] == 0;
        v47 = v59[1];
        v46 = v19;
        v35 = &loc_804F244;
        if ( !_ZF )
          v35 = &loc_804F28B;
        dword_806A220 = (int)v35;
        v19 = v46;
        sub_80614AE(v48, HIDWORD(v48), v49, v50, v51, v52, *(_DWORD *)&v53, v54, *(_DWORD *)&v55, v59, v60, v61);
      }
      if ( *((_BYTE *)v59 + 25) != 1 )
      {
        _ZF = v59[3] == 0;
        v47 = v59[3];
        v46 = v19;
        v36 = &loc_804F28B;
        if ( _ZF )
          v36 = &loc_804F2B9;
        dword_806A2A8 = (int)v36;
        v19 = v46;
        sub_80610E1(
          v48,
          HIDWORD(v48),
          v49,
          v50,
          v51,
          v52,
          *(_DWORD *)&v53,
          v54,
          *(_DWORD *)&v55,
          v59,
          v60,
          v61,
          v62,
          v63,
          v64,
          v65,
          v66,
          v67,
          v68);
LABEL_38:
        v37 = gettext("leading blanks are significant in key %lu; consider also specifying 'b'");
        v50 = v60;
        error(0, 0, v37);
        goto LABEL_39;
      }
    }
LABEL_39:
    v47 = v53 ^ 1;
    v46 = v19;
    v38 = &loc_804F2E0;
    if ( v53 == 1 )
      v38 = &loc_804F36A;
    dword_806A234 = (int)v38;
    a1 = v46;
    sub_806143E(v21, v20);
    if ( (unsigned __int8)sub_804E903(v59) )
    {
      v62 = *v59 + 1;
      v66 = v59[2] + 1;
      if ( !v62 )
        v62 = 1;
      if ( !v66 || v62 < v66 )
      {
        v39 = gettext("key %lu is numeric and spans multiple fields");
        v50 = v60;
        error(0, 0, v39);
      }
    }
    if ( v71 && v71 == v59[4] )
      v71 = 0;
    if ( v72 && v72 == v59[5] )
      v72 = 0;
    LOBYTE(v73) = (unsigned __int8)(v73 & (*((_BYTE *)v59 + 24) ^ 1)) != 0;
    BYTE1(v73) = (BYTE1(v73) & (*((_BYTE *)v59 + 25) ^ 1)) != 0;
    BYTE2(v74) = (BYTE2(v74) & (*((_BYTE *)v59 + 30) ^ 1)) != 0;
    BYTE2(v73) = (BYTE2(v73) & (*((_BYTE *)v59 + 26) ^ 1)) != 0;
    LOBYTE(v74) = (unsigned __int8)(v74 & (*((_BYTE *)v59 + 28) ^ 1)) != 0;
    BYTE1(v74) = (BYTE1(v74) & (*((_BYTE *)v59 + 29) ^ 1)) != 0;
    HIBYTE(v73) = (HIBYTE(v73) & (*((_BYTE *)v59 + 27) ^ 1)) != 0;
    LOBYTE(v75) = (unsigned __int8)(v75 & (*((_BYTE *)v59 + 32) ^ 1)) != 0;
    HIBYTE(v74) = (HIBYTE(v74) & (*((_BYTE *)v59 + 31) ^ 1)) != 0;
    v59 = (unsigned int *)v59[9];
    ++v60;
  }
  if ( (unsigned __int8)sub_804EC40((int)&v67) ^ 1 )
    goto LABEL_62;
  if ( HIBYTE(v74) && (byte_806ADCD || byte_806ADCE) )
  {
    v47 = dword_806ADD0;
    v46 = a1;
    v40 = &loc_804F55F;
    if ( !dword_806ADD0 )
      v40 = &loc_804F5FC;
    dword_806A20C = (int)v40;
    sub_806151E(
      v48,
      HIDWORD(v48),
      v49,
      v50,
      v51,
      v52,
      *(_DWORD *)&v53,
      v54,
      *(_DWORD *)&v55,
      v59,
      v60,
      v61,
      v62,
      v63,
      v64);
LABEL_62:
    v58 = HIBYTE(v74);
    if ( byte_806ADCD != 1 && byte_806ADCE != 1 )
      HIBYTE(v74) = 0;
    sub_804ECC4((int)&v67, &s);
    v41 = strlen(&s);
    v42 = sub_804AE62(v41);
    v43 = ngettext("option '-%s' is ignored", "options '-%s' are ignored", v42);
    v50 = &s;
    error(0, 0, v43, &s);
    HIBYTE(v74) = v58;
  }
  if ( HIBYTE(v74) && byte_806ADCD != 1 && byte_806ADCE != 1 && dword_806ADD0 )
  {
    v44 = gettext("option '-r' only applies to last-resort comparison");
    error(0, 0, v44);
  }
  return __readgsdword(0x14u) ^ v80;
}
// 8049930: using guessed type int __cdecl stpcpy(_DWORD, _DWORD);
// 80610E1: using guessed type int __stdcall sub_80610E1(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806143E: using guessed type int __fastcall sub_806143E(_DWORD, _DWORD);
// 80614AE: using guessed type int __stdcall sub_80614AE(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806151E: using guessed type int __stdcall sub_806151E(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806A20C: using guessed type int dword_806A20C;
// 806A220: using guessed type int dword_806A220;
// 806A234: using guessed type int dword_806A234;
// 806A288: using guessed type int dword_806A288;
// 806A2A8: using guessed type int dword_806A2A8;
// 806A374: using guessed type int dword_806A374;
// 806ADCD: using guessed type char byte_806ADCD;
// 806ADCE: using guessed type char byte_806ADCE;
// 806ADD0: using guessed type int dword_806ADD0;

//----- (0804F668) --------------------------------------------------------
#error "80502F6: call analysis failed (funcsize=598)"

//----- (080503C7) --------------------------------------------------------
int __cdecl sub_80503C7(int a1, int a2)
{
  int result; // eax
  size_t v3; // eax
  signed int v4; // eax
  int v5; // [esp+14h] [ebp-14h]
  int v6; // [esp+14h] [ebp-14h]
  unsigned int v7; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]

  if ( dword_806ADD0 )
  {
    v5 = sub_804F668(a1, a2);
    if ( v5 || byte_806ADCE || byte_806ADCD )
      return v5;
  }
  v7 = *(_DWORD *)(a1 + 4) - 1;
  n = *(_DWORD *)(a2 + 4) - 1;
  if ( *(_DWORD *)(a1 + 4) == 1 )
  {
    v6 = -(*(_DWORD *)(a2 + 4) != 1);
  }
  else if ( *(_DWORD *)(a2 + 4) == 1 )
  {
    v6 = 1;
  }
  else if ( byte_806A9A4 )
  {
    v6 = sub_805E2CF(*(void **)a1, *(_DWORD *)(a1 + 4), *(void **)a2, *(_DWORD *)(a2 + 4));
  }
  else
  {
    v3 = *(_DWORD *)(a1 + 4) - 1;
    if ( n <= v7 )
      v3 = *(_DWORD *)(a2 + 4) - 1;
    v6 = memcmp(*(const void **)a1, *(const void **)a2, v3);
    if ( !v6 )
    {
      if ( v7 < n )
        v4 = -1;
      else
        v4 = v7 != n;
      v6 = v4;
    }
  }
  if ( byte_806ADCC )
    result = -v6;
  else
    result = v6;
  return result;
}
// 804F668: using guessed type _DWORD __cdecl sub_804F668(_DWORD, _DWORD);
// 806A9A4: using guessed type char byte_806A9A4;
// 806ADCC: using guessed type char byte_806ADCC;
// 806ADCD: using guessed type char byte_806ADCD;
// 806ADCE: using guessed type char byte_806ADCE;
// 806ADD0: using guessed type int dword_806ADD0;

//----- (08050516) --------------------------------------------------------
#error "805062F: call analysis failed (funcsize=83)"

//----- (08050634) --------------------------------------------------------
#error "8050656: call analysis failed (funcsize=27)"

//----- (08050694) --------------------------------------------------------
#error "805069E: positive sp value has been found (funcsize=0)"

//----- (0805069F) --------------------------------------------------------
void __cdecl __noreturn sub_805069F(char *a1, int a2)
{
  size_t v2; // eax
  int v3; // [esp+68h] [ebp-50h]
  unsigned int v4; // [esp+9Ch] [ebp-1Ch]

  v4 = __readgsdword(0x14u);
  sub_804BC34(a1, "r");
  v2 = dword_806A370;
  if ( size >= dword_806A370 )
    v2 = size;
  sub_804D1D2((int)&v3, 16, v2);
}
// 806ADCE: using guessed type char byte_806ADCE;
// 806ADD0: using guessed type int dword_806ADD0;

//----- (08050A64) --------------------------------------------------------
int __cdecl sub_8050A64(int a1, unsigned int a2, int *a3)
{
  _DWORD *v3; // ebx
  void *v4; // eax
  _DWORD *v6; // [esp+1Ch] [ebp-Ch]

  *a3 = sub_805DE5C(a2, 4u);
  v6 = (_DWORD *)*a3;
  if ( a2 > 0 )
  {
    v3 = (_DWORD *)*a3;
    if ( *(_DWORD *)(a1 + 4) && *(_BYTE *)(*(_DWORD *)(a1 + 4) + 8) )
    {
      sub_804C092(*(_DWORD *)(a1 + 4));
      dword_806A288 = (int)&loc_8050B3B;
      sub_80611DA();
    }
    *v3 = sub_804BAA0(*(char **)a1, "r");
    v4 = &loc_8050B7B;
    if ( *v6 )
      v4 = &loc_8050B7D;
    dword_806A288 = (int)v4;
    sub_80611DA();
  }
  return 0;
}
// 806A288: using guessed type int dword_806A288;

//----- (08050B96) --------------------------------------------------------
void __cdecl sub_8050B96(int a1, int a2, int a3, FILE *stream, int a5, void *a6)
{
  size_t v6; // edx
  void *v7; // eax
  int v8; // ST58_4
  _DWORD *v9; // ecx
  _DWORD *v10; // eax
  int v11; // edx
  _DWORD *v12; // eax
  _DWORD *v13; // edx
  int v14; // [esp+0h] [ebp-78h]
  int v15; // [esp+0h] [ebp-78h]
  int v16; // [esp+4h] [ebp-74h]
  int v17; // [esp+4h] [ebp-74h]
  int v18; // [esp+8h] [ebp-70h]
  int v19; // [esp+Ch] [ebp-6Ch]
  int v20; // [esp+10h] [ebp-68h]
  void **v21; // [esp+14h] [ebp-64h]
  size_t size; // [esp+18h] [ebp-60h]
  unsigned int i; // [esp+1Ch] [ebp-5Ch]
  unsigned int j; // [esp+1Ch] [ebp-5Ch]
  unsigned int k; // [esp+1Ch] [ebp-5Ch]
  unsigned int l; // [esp+1Ch] [ebp-5Ch]
  unsigned int m; // [esp+20h] [ebp-58h]
  int v28; // [esp+20h] [ebp-58h]
  unsigned int v29; // [esp+24h] [ebp-54h]
  unsigned int v30; // [esp+28h] [ebp-50h]
  unsigned int v31; // [esp+2Ch] [ebp-4Ch]
  _DWORD *v32; // [esp+30h] [ebp-48h]
  _DWORD *v33; // [esp+34h] [ebp-44h]
  _DWORD *v34; // [esp+38h] [ebp-40h]
  unsigned int *v35; // [esp+3Ch] [ebp-3Ch]
  int v36; // [esp+40h] [ebp-38h]
  int v37; // [esp+44h] [ebp-34h]
  unsigned int v38; // [esp+48h] [ebp-30h]
  unsigned int v39; // [esp+4Ch] [ebp-2Ch]
  signed __int64 v40; // [esp+54h] [ebp-24h]
  unsigned int v41; // [esp+5Ch] [ebp-1Ch]
  void *ptr; // [esp+60h] [ebp-18h]
  size_t n; // [esp+64h] [ebp-14h]
  char *v44; // [esp+68h] [ebp-10h]
  char *v45; // [esp+6Ch] [ebp-Ch]

  v32 = (_DWORD *)sub_805DE5C(a3, 0x1Cu);
  v21 = 0;
  size = 0;
  v33 = (_DWORD *)sub_805DE5C(a3, 4u);
  v34 = (_DWORD *)sub_805DE5C(a3, 4u);
  v35 = (unsigned int *)sub_805DE5C(a3, 4u);
  v36 = dword_806ADD0;
  ptr = 0;
  if ( (unsigned int)a3 > 0 )
  {
    v6 = ::size / a3;
    if ( ::size / a3 < dword_806A370 )
      v6 = dword_806A370;
    sub_804D1D2((int)v32, 16, v6);
  }
  for ( i = 0; i < a3; ++i )
    v35[i] = i;
  for ( j = 1; j < a3; ++j )
  {
    if ( sub_80503C7(v33[v35[j + 0x3FFFFFFF]], v33[v35[j]]) > 0 )
    {
      v38 = v35[j + 0x3FFFFFFF];
      v35[j + 0x3FFFFFFF] = v35[j];
      v35[j] = v38;
      j = 0;
    }
  }
  while ( a3 )
  {
    v39 = v33[*v35];
    v7 = &loc_8050FB9;
    if ( !byte_806ADCE )
      v7 = &loc_80510DB;
    dword_806A2A8 = (int)v7;
    sub_80610E1(v14, v16, v18, v19, v20, v21, size, j, m, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38);
    if ( v21 && sub_80503C7((int)v21, v39) )
    {
      v21 = 0;
      sub_8050516((int)&ptr, stream, a5);
    }
    if ( !v21 )
    {
      v21 = &ptr;
      if ( *(_DWORD *)(v39 + 4) > size )
      {
        do
        {
          if ( !size )
          {
            size = *(_DWORD *)(v39 + 4);
            dword_806A288 = (int)&loc_8051044;
            sub_80611DA();
          }
          size *= 2;
        }
        while ( size < *(_DWORD *)(v39 + 4) );
        free(ptr);
        ptr = (void *)sub_805DF6E(size);
      }
      n = *(_DWORD *)(v39 + 4);
      memcpy(ptr, *(const void **)v39, n);
      if ( v36 )
      {
        v44 = (char *)ptr + *(_DWORD *)(v39 + 8) - *(_DWORD *)v39;
        v45 = (char *)ptr + *(_DWORD *)(v39 + 12) - *(_DWORD *)v39;
      }
    }
    if ( v34[*v35] >= v39 )
    {
      if ( (unsigned __int8)sub_804D5D7((int)&v32[7 * *v35], *((FILE **)a6 + *v35), *(_DWORD *)(8 * *v35 + a1)) )
      {
        v8 = sub_804D27D(&v32[7 * *v35]);
        v33[*v35] = v8 - 16;
        v34[*v35] = -16 * v32[7 * *v35 + 2] + v8;
      }
      else
      {
        for ( k = 1; k < a3; ++k )
        {
          if ( v35[k] > *v35 )
            --v35[k];
        }
        --a3;
        sub_804BC75(*((FILE **)a6 + *v35), *(_DWORD *)(8 * *v35 + a1));
        if ( *v35 < a2 )
        {
          --a2;
          sub_804C2AE(*(_DWORD *)(8 * *v35 + a1));
        }
        free((void *)v32[7 * *v35]);
        for ( l = *v35; l < a3; ++l )
        {
          *((_DWORD *)a6 + l) = *((_DWORD *)a6 + l + 1);
          v9 = (_DWORD *)(8 * l + a1);
          v10 = (_DWORD *)(8 * (l + 1) + a1);
          v11 = v10[1];
          *v9 = *v10;
          v9[1] = v11;
          v12 = &v32[7 * l];
          v13 = &v32[7 * (l + 1)];
          *v12 = *v13;
          v12[1] = v13[1];
          v12[2] = v13[2];
          v12[3] = v13[3];
          v12[4] = v13[4];
          v12[5] = v13[5];
          v12[6] = v13[6];
          v33[l] = v33[l + 1];
          v34[l] = v34[l + 1];
        }
        for ( j = 0; j < a3; ++j )
          v35[j] = v35[j + 1];
        dword_806A248 = (int)&loc_805159C;
        sub_80613AB(v15, v17, v18, v19, v20, v21, size);
      }
    }
    else
    {
      v33[*v35] = v39 - 16;
    }
    v29 = 1;
    v30 = a3;
    v31 = 1;
    LODWORD(v40) = *v35;
    while ( v29 < v30 )
    {
      HIDWORD(v40) = sub_80503C7(v33[(_DWORD)v40], v33[v35[v31]]);
      if ( v40 < v35[v31] )
      {
        dword_806A220 = (int)&loc_805151C;
        sub_80614AE(v14, v16, v18, v19, v20, v21, size, j, v28, v29, v31, v31);
      }
      v29 = v31 + 1;
      v31 = (v31 + 1 + v30) >> 1;
    }
    v41 = v29 - 1;
    for ( m = 0; m < v41; ++m )
      v35[m] = v35[m + 1];
    v35[v41] = v40;
  }
  if ( byte_806ADCE && v21 )
  {
    sub_8050516((int)&ptr, stream, a5);
    free(ptr);
  }
  sub_804BC75(stream, a5);
  free(a6);
  free(v32);
  free(v35);
  free(v34);
  free(v33);
}
// 804C2AE: using guessed type _DWORD __cdecl sub_804C2AE(_DWORD);
// 80610E1: using guessed type int __stdcall sub_80610E1(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80613AB: using guessed type int __stdcall sub_80613AB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80614AE: using guessed type int __stdcall sub_80614AE(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806A220: using guessed type int dword_806A220;
// 806A248: using guessed type int dword_806A248;
// 806A288: using guessed type int dword_806A288;
// 806A2A8: using guessed type int dword_806A2A8;
// 806ADCE: using guessed type char byte_806ADCE;
// 806ADD0: using guessed type int dword_806ADD0;

//----- (0805162A) --------------------------------------------------------
int __cdecl sub_805162A(int a1, int a2, int a3, FILE *stream, int a5)
{
  char *v5; // ebx
  char *v6; // eax
  void *v8; // [esp+0h] [ebp-10h]
  int v9; // [esp+4h] [ebp-Ch]

  v9 = sub_8050A64(a1, a3, (int *)&v8);
  if ( v9 < (unsigned int)a3 && (unsigned int)v9 <= 1 )
  {
    v5 = *(char **)(8 * v9 + a1);
    v6 = gettext("open failed");
    sub_804B16A((int)v6, v5);
  }
  sub_8050B96(a1, a2, v9, stream, a5, v8);
  return v9;
}

//----- (080516DB) --------------------------------------------------------
#error "805176E: call analysis failed (funcsize=90)"

//----- (08051815) --------------------------------------------------------
int __cdecl sub_8051815(int a1, unsigned int a2, int a3, unsigned __int8 a4)
{
  int result; // eax
  _DWORD *v5; // eax
  _DWORD *v6; // edx
  int v7; // ecx
  _DWORD *v8; // edx
  _DWORD *v9; // edx
  _DWORD *v10; // edx
  int v15; // eax
  _DWORD *v16; // edx
  void *v17; // eax
  int v18; // [esp+2Ch] [ebp-1Ch]
  unsigned int v19; // [esp+30h] [ebp-18h]

  if ( a2 == 2 )
  {
    result = sub_80503C7(a1 - 16, a1 - 32) > 0;
    v18 = result;
    if ( a4 )
    {
      v5 = (_DWORD *)(a3 - 16);
      v6 = (_DWORD *)(16 * ~v18 + a1);
      *v5 = *v6;
      v5[1] = v6[1];
      v5[2] = v6[2];
      v5[3] = v6[3];
      result = a3 - 32;
      v7 = 16 * (v18 - 2);
      *(_DWORD *)result = *(_DWORD *)(v7 + a1);
      *(_DWORD *)(result + 4) = *(_DWORD *)(v7 + a1 + 4);
      *(_DWORD *)(result + 8) = *(_DWORD *)(v7 + a1 + 8);
      *(_DWORD *)(result + 12) = *(_DWORD *)(v7 + a1 + 12);
    }
    else if ( result )
    {
      v8 = (_DWORD *)(a3 - 16);
      *v8 = *(_DWORD *)(a1 - 16);
      v8[1] = *(_DWORD *)(a1 - 12);
      v8[2] = *(_DWORD *)(a1 - 8);
      v8[3] = *(_DWORD *)(a1 - 4);
      v9 = (_DWORD *)(a1 - 16);
      *v9 = *(_DWORD *)(a1 - 32);
      v9[1] = *(_DWORD *)(a1 - 28);
      v9[2] = *(_DWORD *)(a1 - 24);
      v9[3] = *(_DWORD *)(a1 - 20);
      v10 = (_DWORD *)(a1 - 32);
      *v10 = *(_DWORD *)(a3 - 16);
      v10[1] = *(_DWORD *)(a3 - 12);
      v10[2] = *(_DWORD *)(a3 - 8);
      result = *(_DWORD *)(a3 - 4);
      v10[3] = result;
    }
  }
  else
  {
    v19 = a2 >> 1;
    _CF = 0;
    _OF = 0;
    _ZF = a4 == 0;
    _SF = (a4 & 0x80u) != 0;
    if ( a4 )
    {
      v15 = -16 * v19;
    }
    else
    {
      __asm { pushfw }
      v15 = 0;
      __asm { popfw }
    }
    sub_8051815(-16 * (a2 >> 1) + a1, a2 - (a2 >> 1), a3 + v15, a4);
    if ( v19 <= 1 )
    {
      if ( a4 != 1 )
      {
        v16 = (_DWORD *)(a3 - 16);
        *(_DWORD *)(a3 - 16) = *(_DWORD *)(a1 - 16);
        v16[1] = *(_DWORD *)(a1 - 12);
        v16[2] = *(_DWORD *)(a1 - 8);
        v16[3] = *(_DWORD *)(a1 - 4);
      }
    }
    else
    {
      sub_8051815(a1, v19, a3, a4 == 0);
    }
    v17 = &loc_8051A57;
    if ( !a4 )
      v17 = &loc_8051A65;
    dword_806A288 = (int)v17;
    sub_80611DA();
    result = sub_80516DB(a3, a2, a1);
  }
  return result;
}
// 80516DB: using guessed type _DWORD __cdecl sub_80516DB(_DWORD, _DWORD, _DWORD);
// 806A288: using guessed type int dword_806A288;

//----- (08051A8C) --------------------------------------------------------
#error "8051B7C: call analysis failed (funcsize=69)"

//----- (08051B81) --------------------------------------------------------
#error "8051B98: positive sp value has been found (funcsize=0)"

//----- (08051BF0) --------------------------------------------------------
#error "8051CC4: call analysis failed (funcsize=74)"

//----- (08051CC9) --------------------------------------------------------
#error "8051DEC: positive sp value has been found (funcsize=81)"

//----- (08051DED) --------------------------------------------------------
_BOOL4 __cdecl sub_8051DED(_DWORD *a1, _DWORD *a2)
{
  _BOOL4 result; // eax

  if ( a1[10] == a2[10] )
    result = a1[5] + a1[6] < (unsigned int)(a2[5] + a2[6]);
  else
    result = a1[10] < a2[10];
  return result;
}

//----- (08051E6C) --------------------------------------------------------
int __cdecl sub_8051E6C(pthread_mutex_t *a1)
{
  return pthread_mutex_lock(a1 + 2);
}

//----- (08051E82) --------------------------------------------------------
int __cdecl sub_8051E82(pthread_mutex_t *a1)
{
  return pthread_mutex_unlock(a1 + 2);
}

//----- (08051EC9) --------------------------------------------------------
int __cdecl sub_8051EC9(int a1, int a2)
{
  *(_DWORD *)a1 = sub_80589CF((int (*)())sub_8051DED, 2 * a2);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 4), 0);
  return pthread_cond_init((pthread_cond_t *)(a1 + 28), 0);
}

//----- (08051F17) --------------------------------------------------------
int __cdecl sub_8051F17(int a1, int a2)
{
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 4));
  sub_8058A7F(*(_DWORD *)a1, a2);
  *(_BYTE *)(a2 + 44) = 1;
  pthread_cond_signal((pthread_cond_t *)(a1 + 28));
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 4));
}

//----- (08051F64) --------------------------------------------------------
pthread_mutex_t *__cdecl sub_8051F64(int a1)
{
  pthread_mutex_t *v2; // [esp+1Ch] [ebp-Ch]

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 4));
  while ( 1 )
  {
    v2 = (pthread_mutex_t *)sub_8058B19(*(_DWORD **)a1);
    if ( v2 )
      break;
    pthread_cond_wait((pthread_cond_t *)(a1 + 28), (pthread_mutex_t *)(a1 + 4));
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 4));
  sub_8051E6C(v2);
  v2[1].__size[20] = 0;
  return v2;
}

//----- (08051FCD) --------------------------------------------------------
#error "805200C: call analysis failed (funcsize=39)"

//----- (08052055) --------------------------------------------------------
int __usercall sub_8052055@<eax>(int a1@<ebx>, int a2, int a3, FILE *stream, int a5)
{
  int v5; // ecx
  _DWORD *v6; // edx
  _DWORD *v7; // eax
  int v8; // eax
  _DWORD *v9; // edx
  _DWORD *v10; // eax
  _DWORD *v11; // edx
  bool v12; // zf
  void *v13; // eax
  int v14; // eax
  _DWORD *v15; // edx
  _DWORD *v16; // eax
  int v17; // eax
  int v18; // eax
  void *v19; // eax
  int v20; // eax
  int v21; // eax
  int result; // eax
  int v23; // [esp-8h] [ebp-40h]
  int v24; // [esp-4h] [ebp-3Ch]
  int v25; // [esp+0h] [ebp-38h]
  int v26; // [esp+4h] [ebp-34h]
  int v27; // [esp+8h] [ebp-30h]
  int v28; // [esp+Ch] [ebp-2Ch]
  int v29; // [esp+10h] [ebp-28h]
  int v30; // [esp+14h] [ebp-24h]
  unsigned int v31; // [esp+18h] [ebp-20h]
  _DWORD *v32; // [esp+1Ch] [ebp-1Ch]
  _DWORD *v33; // [esp+20h] [ebp-18h]
  int v34; // [esp+24h] [ebp-14h]
  int v35; // [esp+28h] [ebp-10h]
  int v36; // [esp+2Ch] [ebp-Ch]
  int v37; // [esp+30h] [ebp-8h]
  int v38; // [esp+34h] [ebp-4h]
  int savedregs; // [esp+38h] [ebp+0h]

  v33 = *(_DWORD **)a2;
  v34 = *(_DWORD *)(a2 + 4);
  v5 = 2 * (*(_DWORD *)(a2 + 40) + 1);
  v31 = ((unsigned int)a3 >> v5) + 1;
  if ( *(_DWORD *)(a2 + 40) > 1u )
  {
    v32 = **(_DWORD ***)(a2 + 16);
    while ( *(_DWORD *)a2 != *(_DWORD *)(a2 + 8) )
    {
      if ( *(_DWORD *)(a2 + 4) == *(_DWORD *)(a2 + 12) )
        break;
      v8 = v31--;
      if ( !v8 )
        break;
      if ( sub_80503C7(*(_DWORD *)a2 - 16, *(_DWORD *)(a2 + 4) - 16) > 0 )
      {
        v32 -= 4;
        *(_DWORD *)(a2 + 4) -= 16;
        v6 = *(_DWORD **)(a2 + 4);
        v7 = v32;
        *v32 = *v6;
      }
      else
      {
        v32 -= 4;
        *(_DWORD *)a2 -= 16;
        v6 = *(_DWORD **)a2;
        v7 = v32;
        *v32 = **(_DWORD **)a2;
      }
      v7[1] = v6[1];
      v5 = v6[2];
      v7[2] = v5;
      v7[3] = v6[3];
    }
    v35 = ((signed int)v33 - *(_DWORD *)a2) >> 4;
    v36 = (v34 - *(_DWORD *)(a2 + 4)) >> 4;
    if ( *(_DWORD *)(a2 + 24) == v36 )
    {
      while ( 1 )
      {
        v11 = *(_DWORD **)a2;
        v12 = *(_DWORD *)a2 == *(_DWORD *)(a2 + 8);
        v24 = *(_DWORD *)(a2 + 8);
        v23 = a1;
        v13 = &loc_8052232;
        if ( v12 )
          v13 = &loc_80522AD;
        dword_806A234 = (int)v13;
        a1 = v23;
        sub_806143E(v5, v11);
        v14 = v31--;
        if ( !v14 )
          break;
        v32 -= 4;
        *(_DWORD *)a2 -= 16;
        v9 = *(_DWORD **)a2;
        v10 = v32;
        *v32 = **(_DWORD **)a2;
        v10[1] = v9[1];
        v5 = v9[2];
        v10[2] = v5;
        v10[3] = v9[3];
      }
    }
    else if ( *(_DWORD *)(a2 + 20) == v35 )
    {
      while ( *(_DWORD *)(a2 + 4) != *(_DWORD *)(a2 + 12) )
      {
        v17 = v31--;
        if ( !v17 )
          break;
        v32 -= 4;
        *(_DWORD *)(a2 + 4) -= 16;
        v15 = *(_DWORD **)(a2 + 4);
        v16 = v32;
        *v32 = *v15;
        v16[1] = v15[1];
        v16[2] = v15[2];
        v16[3] = v15[3];
      }
    }
    **(_DWORD **)(a2 + 16) = v32;
    dword_806A2BC = (int)&loc_80524D5;
    sub_8061057();
  }
  if ( *(_DWORD *)a2 != *(_DWORD *)(a2 + 8) && *(_DWORD *)(a2 + 4) != *(_DWORD *)(a2 + 12) )
  {
    v18 = v31--;
    v12 = v18 == 0;
    v24 = v18;
    v23 = a1;
    v19 = &loc_80523BF;
    if ( !v12 )
      v19 = &loc_80522D4;
    dword_806A268 = (int)v19;
    sub_80612C7();
  }
  v35 = ((signed int)v33 - *(_DWORD *)a2) >> 4;
  v36 = (v34 - *(_DWORD *)(a2 + 4)) >> 4;
  if ( *(_DWORD *)(a2 + 24) == v36 )
  {
    while ( *(_DWORD *)a2 != *(_DWORD *)(a2 + 8) )
    {
      v20 = v31--;
      if ( !v20 )
        break;
      *(_DWORD *)a2 -= 16;
      sub_8051FCD(*(_DWORD *)a2, stream, a5);
    }
  }
  else if ( *(_DWORD *)(a2 + 20) == v35 )
  {
    dword_806A20C = (int)&loc_80524B8;
    sub_806151E(v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, savedregs);
    do
    {
      *(_DWORD *)(a2 + 4) -= 16;
      sub_8051FCD(*(_DWORD *)(a2 + 4), stream, a5);
      if ( *(_DWORD *)(a2 + 4) == *(_DWORD *)(a2 + 12) )
        break;
      v21 = v31--;
    }
    while ( v21 );
  }
  v35 = ((signed int)v33 - *(_DWORD *)a2) >> 4;
  v36 = (v34 - *(_DWORD *)(a2 + 4)) >> 4;
  *(_DWORD *)(a2 + 20) -= v35;
  result = a2;
  *(_DWORD *)(a2 + 24) -= v36;
  return result;
}
// 8052055: could not find valid save-restore pair for ebx
// 8061057: using guessed type int sub_8061057(void);
// 80612C7: using guessed type int sub_80612C7(void);
// 806143E: using guessed type int __fastcall sub_806143E(_DWORD, _DWORD);
// 806151E: using guessed type int __stdcall sub_806151E(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806A20C: using guessed type int dword_806A20C;
// 806A234: using guessed type int dword_806A234;
// 806A268: using guessed type int dword_806A268;
// 806A2BC: using guessed type int dword_806A2BC;

//----- (0805252E) --------------------------------------------------------
#error "805256B: call analysis failed (funcsize=29)"

//----- (08052606) --------------------------------------------------------
#error "8052656: call analysis failed (funcsize=42)"

//----- (08052688) --------------------------------------------------------
int __usercall sub_8052688@<eax>(int a1@<ebx>, int a2, int a3, FILE *stream, int a5)
{
  pthread_mutex_t *v6; // [esp+1Ch] [ebp-Ch]

  while ( 1 )
  {
    v6 = sub_8051F64(a2);
    if ( !v6[1].__nusers )
      break;
    sub_8052055(a1, (int)v6, a3, stream, a5);
    sub_805252E(a2, v6);
    sub_8052606(a2, v6);
    sub_8051E82(v6);
  }
  sub_8051E82(v6);
  return sub_8051F17(a2, (int)v6);
}
// 805252E: using guessed type _DWORD __cdecl sub_805252E(_DWORD, _DWORD);
// 8052606: using guessed type _DWORD __cdecl sub_8052606(_DWORD, _DWORD);

//----- (0805271B) --------------------------------------------------------
void *__cdecl start_routine(void *a1)
{
  void *result; // eax

  sub_8052799(
    *((_DWORD *)a1 + 3),
    *(_DWORD *)a1,
    *((_DWORD *)a1 + 1),
    *((_DWORD *)a1 + 2),
    *((_DWORD *)a1 + 3),
    *((_DWORD *)a1 + 4),
    *((FILE **)a1 + 5),
    *((_DWORD *)a1 + 6));
  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}

//----- (08052799) --------------------------------------------------------
int __usercall sub_8052799@<eax>(int a1@<ebx>, int a2, int a3, int a4, int a5, int a6, FILE *stream, int a8)
{
  int v8; // ST00_4
  int v9; // ST04_4
  int v10; // ST08_4
  int v11; // ST0C_4
  int v12; // ST10_4
  int v13; // ST14_4
  int v14; // ST18_4
  int v16; // [esp+1Ch] [ebp-4Ch]
  int v17; // [esp+20h] [ebp-48h]
  int v18; // [esp+24h] [ebp-44h]
  pthread_t newthread; // [esp+28h] [ebp-40h]
  unsigned int v20; // [esp+2Ch] [ebp-3Ch]
  unsigned int v21; // [esp+30h] [ebp-38h]
  int v22; // [esp+34h] [ebp-34h]
  unsigned int v23; // [esp+38h] [ebp-30h]
  unsigned int v24; // [esp+3Ch] [ebp-2Ch]
  int v25; // [esp+40h] [ebp-28h]
  int arg; // [esp+44h] [ebp-24h]
  unsigned int v27; // [esp+48h] [ebp-20h]
  int v28; // [esp+4Ch] [ebp-1Ch]
  int v29; // [esp+50h] [ebp-18h]
  int v30; // [esp+54h] [ebp-14h]
  FILE *v31; // [esp+58h] [ebp-10h]
  int v32; // [esp+5Ch] [ebp-Ch]

  v20 = *(_DWORD *)(a5 + 20) + *(_DWORD *)(a5 + 24);
  v21 = (unsigned int)a3 >> 1;
  v22 = a3 - ((unsigned int)a3 >> 1);
  arg = a2;
  v27 = (unsigned int)a3 >> 1;
  v28 = a4;
  v29 = *(_DWORD *)(a5 + 32);
  v30 = a6;
  v31 = stream;
  v32 = a8;
  if ( (unsigned int)a3 > 1 && v20 > 0x1FFFF && !pthread_create(&newthread, 0, start_routine, &arg) )
  {
    sub_8052799(a2 - 16 * *(_DWORD *)(a5 + 20), v22, a4, *(_DWORD *)(a5 + 36), a6, stream, a8);
    pthread_join(newthread, 0);
    dword_806A220 = (int)&locret_8052A01;
    sub_80614AE(v8, v9, v10, v11, v12, v13, v14, v16, v17, v18, newthread, v20);
  }
  v23 = *(_DWORD *)(a5 + 20);
  v24 = *(_DWORD *)(a5 + 24);
  v25 = -16 * a4 + a2;
  if ( v24 > 1 )
    sub_8051815(-16 * v23 + a2, v24, -16 * (v23 >> 1) + v25, 0);
  if ( v23 > 1 )
    sub_8051815(a2, v23, v25, 0);
  *(_DWORD *)a5 = a2;
  *(_DWORD *)(a5 + 4) = a2 - 16 * v23;
  *(_DWORD *)(a5 + 8) = a2 - 16 * v23;
  *(_DWORD *)(a5 + 12) = a2 + -16 * v23 - 16 * v24;
  sub_8051F17(a6, a5);
  return sub_8052688(a1, a6, a4, stream, a8);
}
// 80614AE: using guessed type int __stdcall sub_80614AE(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806A220: using guessed type int dword_806A220;

//----- (08052A03) --------------------------------------------------------
int __cdecl sub_8052A03(int a1, int a2, int a3, char *s1)
{
  int result; // eax
  int v5; // eax
  int v8; // eax
  char v9; // al
  char v12; // [esp+21h] [ebp-D7h]
  char v13; // [esp+22h] [ebp-D6h]
  bool v14; // [esp+23h] [ebp-D5h]
  FILE *stream; // [esp+24h] [ebp-D4h]
  char *v16; // [esp+28h] [ebp-D0h]
  unsigned int i; // [esp+2Ch] [ebp-CCh]
  __int64 v18; // [esp+30h] [ebp-C8h]
  __int64 v19; // [esp+88h] [ebp-70h]
  __int64 v20; // [esp+90h] [ebp-68h]
  __int64 v21; // [esp+E8h] [ebp-10h]

  v12 = 0;
  v16 = 0;
  for ( i = a2; ; ++i )
  {
    result = i;
    if ( i >= a3 )
      break;
    v14 = strcmp(*(const char **)(8 * i + a1), "-") == 0;
    if ( s1 && !strcmp(s1, *(const char **)(8 * i + a1)) && v14 != 1 )
    {
      v13 = 1;
      goto LABEL_18;
    }
    if ( v12 != 1 )
    {
      result = sub_8060FCE(1, (int)&v18);
      if ( result )
        return result;
      v12 = 1;
    }
    if ( v14 )
    {
      v5 = sub_8060FCE(0, (int)&v20);
      _ZF = v5 == 0;
      _SF = v5 < 0;
      if ( v5 )
        goto LABEL_16;
    }
    else
    {
      v8 = sub_8060F9F(*(_DWORD *)(8 * i + a1), (int)&v20);
      _ZF = v8 == 0;
      _SF = v8 < 0;
      if ( v8 )
        goto LABEL_16;
    }
    _ZF = v21 == v19;
    _SF = (signed int)(HIDWORD(v19) ^ HIDWORD(v21) | v21 ^ v19) < 0;
    if ( v21 != v19 || (_ZF = v20 == v18, _SF = (signed int)(HIDWORD(v18) ^ HIDWORD(v20) | v20 ^ v18) < 0, v20 != v18) )
    {
LABEL_16:
      __asm { pushfw }
      v9 = 0;
      __asm { popfw }
      goto LABEL_17;
    }
    v9 = 1;
LABEL_17:
    v13 = v9 & 1;
LABEL_18:
    if ( v13 )
    {
      if ( !v16 )
      {
        v16 = sub_804C077(&stream);
        sub_805162A(8 * i + a1, 0, 1, stream, (int)(v16 + 9));
      }
      *(_DWORD *)(8 * i + a1) = v16 + 9;
      *(_DWORD *)(a1 + 8 * i + 4) = v16;
    }
  }
  return result;
}

//----- (08052C52) --------------------------------------------------------
unsigned int __cdecl sub_8052C52(int a1, unsigned int a2)
{
  bool v2; // zf
  void *v3; // eax
  char *v4; // ebx
  char *v5; // eax
  unsigned int result; // eax
  int v7; // [esp+0h] [ebp-28h]
  int v8; // [esp+8h] [ebp-20h]
  int v9; // [esp+Ch] [ebp-1Ch]
  int v10; // [esp+10h] [ebp-18h]
  int v11; // [esp+14h] [ebp-14h]
  int v12; // [esp+18h] [ebp-10h]
  unsigned int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a2 )
      break;
    if ( strcmp(*(const char **)(4 * i + a1), "-") )
    {
      v7 = *(_DWORD *)(4 * i + a1);
      v2 = euidaccess() == 0;
      v3 = &loc_8052CCA;
      if ( v2 )
        v3 = &loc_8052CF3;
      dword_806A248 = (int)v3;
      sub_80613AB(v7, 4, v8, v9, v10, v11, v12);
      v4 = *(char **)(4 * i + a1);
      v5 = gettext("cannot read");
      sub_804B16A((int)v5, v4);
    }
  }
  return result;
}
// 8049E00: using guessed type int euidaccess(void);
// 80613AB: using guessed type int __stdcall sub_80613AB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806A248: using guessed type int dword_806A248;

//----- (08052D09) --------------------------------------------------------
#error "8052D29: call analysis failed (funcsize=35)"

//----- (08052D88) --------------------------------------------------------
void __cdecl sub_8052D88(int a1, int a2, int a3, char *s1)
{
  char *v4; // eax
  int v5; // esi
  int v6; // eax
  int v7; // eax
  char *v8; // eax
  int v9; // ebx
  int v10; // eax
  int v11; // eax
  int v12; // eax
  char *v13; // eax
  char *v14; // ebx
  char *v15; // eax
  int v16; // eax
  int v17; // eax
  int v18; // [esp+0h] [ebp-78h]
  _BOOL4 v19; // [esp+4h] [ebp-74h]
  void *v20; // [esp+28h] [ebp-50h]
  FILE *v21; // [esp+2Ch] [ebp-4Ch]
  int v22; // [esp+30h] [ebp-48h]
  unsigned int v23; // [esp+34h] [ebp-44h]
  int v24; // [esp+38h] [ebp-40h]
  char *v25; // [esp+3Ch] [ebp-3Ch]
  unsigned int v26; // [esp+40h] [ebp-38h]
  int v27; // [esp+44h] [ebp-34h]
  unsigned int v28; // [esp+48h] [ebp-30h]
  int v29; // [esp+4Ch] [ebp-2Ch]
  char *v30; // [esp+50h] [ebp-28h]
  unsigned int v31; // [esp+54h] [ebp-24h]
  FILE *stream; // [esp+58h] [ebp-20h]
  char *v33; // [esp+5Ch] [ebp-1Ch]
  int v34; // [esp+84h] [ebp+Ch]

  dword_806A2BC = (int)&loc_8052FF5;
  sub_8061057();
  do
  {
    v22 = 0;
    v23 = 0;
    while ( a3 - v22 >= (unsigned int)dword_806A378 )
    {
      v4 = sub_804C077(&v21);
      v25 = v4;
      v5 = (int)(v4 + 9);
      v6 = a2;
      if ( dword_806A378 <= (unsigned int)a2 )
        v6 = dword_806A378;
      v18 = 8 * v22 + a1;
      v26 = sub_805162A(v18, v6, dword_806A378, v21, v5);
      v7 = a2;
      if ( v26 <= a2 )
        v7 = v26;
      a2 -= v7;
      *(_DWORD *)(8 * v23 + a1) = v25 + 9;
      *(_DWORD *)(a1 + 8 * v23 + 4) = v25;
      v22 += v26;
      ++v23;
    }
    v27 = a3 - v22;
    v28 = dword_806A378 - v23 % dword_806A378;
    if ( dword_806A378 - v23 % dword_806A378 < a3 - v22 )
    {
      v29 = v27 - v28 + 1;
      v8 = sub_804C077(&v21);
      v30 = v8;
      v9 = (int)(v8 + 9);
      v10 = a2;
      if ( v29 <= (unsigned int)a2 )
        v10 = v29;
      v18 = 8 * v22 + a1;
      v31 = sub_805162A(v18, v10, v29, v21, v9);
      v11 = a2;
      if ( v31 <= a2 )
        v11 = v31;
      a2 -= v11;
      *(_DWORD *)(8 * v23 + a1) = v30 + 9;
      v12 = v23++;
      *(_DWORD *)(a1 + 8 * v12 + 4) = v30;
      v22 += v31;
    }
    memmove((void *)(8 * v23 + a1), (const void *)(a1 + 8 * v22), 8 * (a3 - v22));
    a2 += v23;
    a3 += v23 - v22;
  }
  while ( dword_806A378 < (unsigned int)a3 );
  sub_8052A03(a1, a2, a3, s1);
  while ( 1 )
  {
    v24 = sub_8050A64(a1, a3, (int *)&v20);
    if ( v24 == a3 )
      break;
    if ( (unsigned int)v24 <= 2 )
    {
      v14 = *(char **)(8 * v24 + a1);
      v15 = gettext("open failed");
      sub_804B16A((int)v15, v14);
    }
    do
    {
LABEL_27:
      --v24;
      sub_804BC75(*((FILE **)v20 + v24), *(_DWORD *)(8 * v24 + a1));
      v19 = (unsigned int)v24 > 2;
      v33 = sub_804BF08(&v21, v19);
    }
    while ( !v33 );
    v16 = a2;
    if ( v24 <= (unsigned int)a2 )
      v16 = v24;
    sub_8050B96(a1, v16, v24, v21, (int)(v33 + 9), v20);
    v17 = a2;
    if ( v24 <= (unsigned int)a2 )
      v17 = v24;
    v34 = a2 - v17;
    *(_DWORD *)a1 = v33 + 9;
    *(_DWORD *)(a1 + 4) = v33;
    memmove((void *)(a1 + 8), (const void *)(a1 + 8 * v24), 8 * (a3 - v24));
    a2 = v34 + 1;
    a3 = a3 - v24 + 1;
  }
  stream = (FILE *)sub_804BAA0(s1, "w");
  if ( !stream )
  {
    if ( *__errno_location() != 24 || (unsigned int)v24 <= 2 )
    {
      v13 = gettext("open failed");
      sub_804B16A((int)v13, s1);
    }
    goto LABEL_27;
  }
  sub_8050B96(a1, a2, a3, stream, (int)s1, v20);
}
// 8061057: using guessed type int sub_8061057(void);
// 806A2BC: using guessed type int dword_806A2BC;
// 806A374: using guessed type int dword_806A374;

//----- (08053238) --------------------------------------------------------
unsigned int __cdecl sub_8053238(int a1, int a2, char *a3)
{
  void *v3; // eax
  int v5; // [esp+0h] [ebp-E8h]
  int v6; // [esp+4h] [ebp-E4h]
  int v7; // [esp+8h] [ebp-E0h]
  int v8; // [esp+Ch] [ebp-DCh]
  int v9; // [esp+10h] [ebp-D8h]
  int v10; // [esp+14h] [ebp-D4h]
  int v11; // [esp+18h] [ebp-D0h]
  int v12; // [esp+1Ch] [ebp-CCh]
  int v13; // [esp+20h] [ebp-C8h]
  int v14; // [esp+24h] [ebp-C4h]
  char *v15; // [esp+28h] [ebp-C0h]
  int v16; // [esp+2Ch] [ebp-BCh]
  int v17; // [esp+30h] [ebp-B8h]
  int v18; // [esp+34h] [ebp-B4h]
  int v19; // [esp+38h] [ebp-B0h]
  char v20; // [esp+3Fh] [ebp-A9h]
  int v21; // [esp+48h] [ebp-A0h]
  int *v22; // [esp+5Ch] [ebp-8Ch]
  int v23; // [esp+60h] [ebp-88h]
  void *v24; // [esp+70h] [ebp-78h]
  void *ptr; // [esp+74h] [ebp-74h]
  int v26; // [esp+80h] [ebp-68h]
  unsigned int v27; // [esp+DCh] [ebp-Ch]

  v16 = a1;
  v15 = a3;
  v27 = __readgsdword(0x14u);
  v21 = 0;
  v20 = 0;
  v26 = 0;
  v3 = &loc_80535EA;
  if ( a2 )
    v3 = &loc_805328C;
  dword_806A20C = (int)v3;
  sub_806151E(v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19);
  free(ptr);
  if ( v20 != 1 )
  {
    v22 = (int *)dword_806AE5C;
    v24 = (void *)sub_805DE5C(v21, 8u);
    v23 = 0;
    while ( v22 )
    {
      *((_DWORD *)v24 + 2 * v23) = (char *)v22 + 9;
      *((_DWORD *)v24 + 2 * v23 + 1) = v22;
      v22 = (int *)*v22;
      ++v23;
    }
    sub_8052D88((int)v24, v21, v21, v15);
    free(v24);
  }
  sub_804B7C8();
  return __readgsdword(0x14u) ^ v27;
}
// 804B7C8: using guessed type int sub_804B7C8(void);
// 806151E: using guessed type int __stdcall sub_806151E(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806A20C: using guessed type int dword_806A20C;
// 806AE5C: using guessed type int dword_806AE5C;

//----- (080536F0) --------------------------------------------------------
_DWORD *__cdecl sub_80536F0(void *src)
{
  _DWORD *result; // eax
  int *i; // [esp+18h] [ebp-10h]
  _DWORD *v3; // [esp+1Ch] [ebp-Ch]

  v3 = sub_805E0F7(src, 0x28u);
  for ( i = &dword_806ADD0; *i; i = (int *)(*i + 36) )
    ;
  *i = (int)v3;
  result = v3;
  v3[9] = 0;
  return result;
}
// 806ADD0: using guessed type int dword_806ADD0;

//----- (0805373D) --------------------------------------------------------
void __cdecl __noreturn sub_805373D(int a1, char *msgid)
{
  void *v2; // esi
  char *v3; // ebx
  char *v4; // eax

  v2 = sub_805B697(a1);
  v3 = gettext(msgid);
  v4 = gettext("%s: invalid field specification %s");
  error(2, 0, v4, v3, v2);
  sub_805378B(a1);
}

//----- (0805378B) --------------------------------------------------------
int __cdecl __noreturn sub_805378B(int a1)
{
  char *v1; // eax
  int v2; // eax
  bool v3; // zf
  bool v4; // sf
  unsigned __int8 v5; // of
  void *v6; // eax
  int (*v7)(); // eax
  int v9; // [esp-34h] [ebp-64h]
  int v10; // [esp-30h] [ebp-60h]
  int v11; // [esp-2Ch] [ebp-5Ch]
  int v12; // [esp-28h] [ebp-58h]
  int v13; // [esp-24h] [ebp-54h]
  int v14; // [esp-20h] [ebp-50h]
  int v15; // [esp-1Ch] [ebp-4Ch]
  int v16; // [esp-18h] [ebp-48h]
  int v17; // [esp-14h] [ebp-44h]
  int v18; // [esp-10h] [ebp-40h]
  int v19; // [esp-Ch] [ebp-3Ch]
  int v20; // [esp-8h] [ebp-38h]
  int v21; // [esp-4h] [ebp-34h]
  int v22; // [esp+0h] [ebp-30h]
  int v23; // [esp+4h] [ebp-2Ch]
  int v24; // [esp+8h] [ebp-28h]
  int v25; // [esp+Ch] [ebp-24h]
  int v26; // [esp+10h] [ebp-20h]
  int *v27; // [esp+14h] [ebp-1Ch]
  unsigned int v28; // [esp+24h] [ebp-Ch]
  int savedregs; // [esp+30h] [ebp+0h]

  v1 = gettext("options '-%s' are incompatible");
  error(2, 0, v1, a1);
  v27 = &savedregs;
  v28 = __readgsdword(0x14u);
  v22 = dword_806ADD0;
  if ( v22 )
  {
    v2 = *(unsigned __int8 *)(v22 + 29)
       + *(unsigned __int8 *)(v22 + 28)
       + *(unsigned __int8 *)(v22 + 26)
       + *(unsigned __int8 *)(v22 + 30)
       + (*(unsigned __int8 *)(v22 + 27) | *(unsigned __int8 *)(v22 + 32) | (*(_DWORD *)(v22 + 16) != 0));
    v5 = __OFSUB__(v2, 1);
    v3 = v2 == 1;
    v4 = v2 - 1 < 0;
    v6 = &loc_805385F;
    if ( (unsigned __int8)(v4 ^ v5) | v3 )
      v6 = &loc_80538AD;
    dword_806A2A8 = (int)v6;
    sub_80610E1(v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27);
    *(_BYTE *)(v22 + 31) = 0;
    *(_BYTE *)(v22 + 25) = *(_BYTE *)(v22 + 31);
    *(_BYTE *)(v22 + 24) = *(_BYTE *)(v22 + 25);
    sub_804ECC4(v22, (_BYTE *)&v17 + 1);
    sub_805378B((char *)&v23 + 1);
  }
  v7 = (int (*)())&loc_80538F5;
  if ( __readgsdword(0x14u) == v28 )
    v7 = sub_80538FA;
  dword_806A2A8 = (int)v7;
  return sub_80610E1(v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27);
}
// 80538FA: using guessed type int sub_80538FA();
// 80610E1: using guessed type int __stdcall sub_80610E1(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806A2A8: using guessed type int dword_806A2A8;
// 806ADD0: using guessed type int dword_806ADD0;

//----- (080538FA) --------------------------------------------------------
#error "80538FB: positive sp value has been found (funcsize=0)"

//----- (080538FC) --------------------------------------------------------
int __cdecl sub_80538FC(char *nptr, int a2, char *msgid)
{
  void *v7; // esi
  char *v8; // ebx
  char *v9; // eax
  int result; // eax
  int v11; // [esp+0h] [ebp-38h]
  char *v12; // [esp+Ch] [ebp-2Ch]
  void *v13; // [esp+10h] [ebp-28h]
  int v14; // [esp+24h] [ebp-14h]
  __int64 v15; // [esp+28h] [ebp-10h]

  switch ( sub_805EBBD(nptr, (int)(&v11 - 5), 10, (int)(&v11 - 4), &s) )
  {
    case 0:
    case 2:
      *(_DWORD *)a2 = v15;
      if ( v15 == *(_DWORD *)a2 )
        goto LABEL_7;
      goto LABEL_3;
    case 1:
    case 3:
LABEL_3:
      *(_DWORD *)a2 = -1;
      goto LABEL_7;
    case 4:
      _CF = 0;
      _OF = 0;
      _ZF = msgid == 0;
      _SF = (signed int)msgid < 0;
      if ( msgid )
      {
        v7 = sub_805B697((int)nptr);
        v8 = gettext(msgid);
        v9 = gettext("%s: invalid count at start of %s");
        v13 = v7;
        v12 = v8;
        error(2, 0, v9, v8, v7);
      }
      __asm { pushfw }
      result = 0;
      __asm { popfw }
      break;
    default:
LABEL_7:
      result = v14;
      break;
  }
  return result;
}

//----- (080539F6) --------------------------------------------------------
int __cdecl sub_80539F6(int sig)
{
  sub_804B7FC();
  signal(sig, 0);
  return raise(sig);
}

//----- (08053A21) --------------------------------------------------------
#error "8053A32: call analysis failed (funcsize=88)"

//----- (08053B3C) --------------------------------------------------------
void *__cdecl sub_8053B3C(void *s)
{
  memset(s, 0, 0x28u);
  *((_DWORD *)s + 2) = -1;
  return s;
}

//----- (08053B6C) --------------------------------------------------------
#error "8054E83: call analysis failed (funcsize=1117)"

//----- (08054E88) --------------------------------------------------------
#error "8054ED9: call analysis failed (funcsize=40)"

//----- (080553CC) --------------------------------------------------------
void __noreturn sub_80553CC()
{
  sub_804B1CC(1);
}

//----- (080553E0) --------------------------------------------------------
int __cdecl sub_80553E0(char *s, int a2)
{
  bool v2; // zf
  void *v3; // eax
  int v5; // [esp-4h] [ebp-2Ch]
  char v6; // [esp+13h] [ebp-15h]
  int v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]

  v8 = -1;
  v6 = 0;
  n = strlen(s);
  v7 = 0;
  v2 = *(_DWORD *)a2 == 0;
  v5 = *(_DWORD *)a2;
  v3 = &loc_805550E;
  if ( !v2 )
    v3 = &loc_805540B;
  dword_806A2BC = (int)v3;
  sub_8061057();
  if ( v6 )
  {
    dword_806A288 = (int)&locret_8055533;
    sub_80611DA();
  }
  return v8;
}
// 8061057: using guessed type int sub_8061057(void);
// 806A288: using guessed type int dword_806A288;
// 806A2BC: using guessed type int dword_806A2BC;

//----- (08055535) --------------------------------------------------------
void __cdecl sub_8055535(int a1, int a2, int a3)
{
  char *v3; // eax
  char *format; // ST2C_4
  void *v5; // ebx
  void *v6; // eax

  if ( a3 == -1 )
    v3 = gettext("invalid argument %s for %s");
  else
    v3 = gettext("ambiguous argument %s for %s");
  format = v3;
  v5 = sub_805B675(1, a1);
  v6 = sub_805B1E4(0, 8, a2);
  error(0, 0, format, v6, v5);
}

//----- (080555B8) --------------------------------------------------------
int __cdecl sub_80555B8(int a1, int a2, size_t n)
{
  FILE *v3; // ebx
  char *v4; // eax
  void *v6; // [esp+8h] [ebp-20h]
  int i; // [esp+18h] [ebp-10h]
  void *s1; // [esp+1Ch] [ebp-Ch]

  s1 = 0;
  v3 = stderr;
  v4 = gettext("Valid arguments are:");
  fputs_unlocked(v4, v3);
  for ( i = 0; *(_DWORD *)(4 * i + a1); ++i )
  {
    if ( i && !memcmp(s1, (const void *)(a2 + i * n), n) )
    {
      v6 = sub_805B697(*(_DWORD *)(4 * i + a1));
      fprintf(stderr, ", %s", v6);
    }
    else
    {
      v6 = sub_805B697(*(_DWORD *)(4 * i + a1));
      fprintf(stderr, "\n  - %s", v6);
      s1 = (void *)(i * n + a2);
    }
  }
  return putc_unlocked(10, stderr);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (080556DF) --------------------------------------------------------
#error "80556FD: call analysis failed (funcsize=16)"

//----- (08055710) --------------------------------------------------------
#error "805578A: positive sp value has been found (funcsize=0)"

//----- (08055881) --------------------------------------------------------
int sub_8055881()
{
  void *v0; // eax
  int v1; // ebx
  int *v2; // eax
  int *v3; // eax
  int result; // eax
  int v5; // [esp+0h] [ebp-38h]
  int v6; // [esp+4h] [ebp-34h]
  int v7; // [esp+8h] [ebp-30h]
  int v8; // [esp+Ch] [ebp-2Ch]
  int v9; // [esp+10h] [ebp-28h]
  int v10; // [esp+14h] [ebp-24h]
  int v11; // [esp+18h] [ebp-20h]
  char *v12; // [esp+2Ch] [ebp-Ch]

  if ( sub_805FFCC(stdout) )
  {
    v0 = &loc_80558C4;
    if ( byte_806AF24 != 1 )
      v0 = &loc_80558D4;
    dword_806A248 = (int)v0;
    sub_80613AB(v5, v6, v7, v8, v9, v10, v11);
    if ( *__errno_location() != 32 )
    {
      v12 = gettext("write error");
      if ( dword_806AF20 )
      {
        v1 = sub_805B3C2(dword_806AF20);
        v2 = __errno_location();
        error(0, *v2, "%s: %s", v1, v12);
      }
      else
      {
        v3 = __errno_location();
        error(0, *v3, "%s", v12);
      }
      _exit(status);
    }
  }
  result = sub_805FFCC(stderr);
  if ( result )
    _exit(status);
  return result;
}
// 80613AB: using guessed type int __stdcall sub_80613AB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806A248: using guessed type int dword_806A248;
// 806AF20: using guessed type int dword_806AF20;
// 806AF24: using guessed type char byte_806AF24;

//----- (0805597E) --------------------------------------------------------
_DWORD *__cdecl sub_805597E(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 1732584193;
  a1[1] = -271733879;
  a1[2] = -1732584194;
  a1[3] = 271733878;
  a1[5] = 0;
  a1[4] = a1[5];
  result = a1;
  a1[6] = 0;
  return result;
}

//----- (080559DA) --------------------------------------------------------
_DWORD *__cdecl sub_80559DA(_DWORD *a1, int a2)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = a2;
  return result;
}

//----- (080559E7) --------------------------------------------------------
_DWORD *__cdecl sub_80559E7(int *a1, _DWORD *a2)
{
  sub_80559DA(a2, *a1);
  sub_80559DA(a2 + 1, a1[1]);
  sub_80559DA(a2 + 2, a1[2]);
  sub_80559DA(a2 + 3, a1[3]);
  return a2;
}

//----- (08055A64) --------------------------------------------------------
_DWORD *__cdecl sub_8055A64(int *a1, _DWORD *a2)
{
  signed int v2; // eax
  unsigned int v4; // [esp+18h] [ebp-10h]
  signed int v5; // [esp+1Ch] [ebp-Ch]

  v4 = a1[6];
  if ( v4 > 0x37 )
    v2 = 32;
  else
    v2 = 16;
  v5 = v2;
  a1[4] += v4;
  if ( a1[4] < v4 )
    ++a1[5];
  a1[v2 + 5] = 8 * a1[4];
  a1[v2 + 6] = *((_QWORD *)a1 + 2) >> 29;
  memcpy((char *)a1 + v4 + 28, &unk_8063A48, 4 * (v2 + 1073741822) - v4);
  sub_8055F9D(a1 + 7, 4 * v5, a1);
  return sub_80559E7(a1, a2);
}

//----- (08055D2E) --------------------------------------------------------
#error "8055D63: call analysis failed (funcsize=39)"

//----- (08055DA7) --------------------------------------------------------
#error "8055F9A: positive sp value has been found (funcsize=144)"

//----- (08055F9D) --------------------------------------------------------
int *__cdecl sub_8055F9D(int *a1, unsigned int a2, int *a3)
{
  int v3; // ST30_4
  int v4; // ST34_4
  int v5; // ST38_4
  int v6; // ST3C_4
  int v7; // ST40_4
  int v8; // ST10_4
  int *v9; // ST0C_4
  int v10; // ST10_4
  int v11; // ST1C_4
  int v12; // ST18_4
  int v13; // ST14_4
  int v14; // ST10_4
  int v15; // ST1C_4
  int v16; // ST18_4
  int v17; // ST14_4
  int v18; // ST10_4
  int v19; // ST1C_4
  int v20; // ST18_4
  int v21; // ST14_4
  int v22; // ST10_4
  int v23; // ST1C_4
  int v24; // ST18_4
  int v25; // ST14_4
  int v26; // ST10_4
  int v27; // ST1C_4
  int v28; // ST18_4
  int v29; // ST14_4
  int v30; // ST10_4
  int v31; // ST1C_4
  int v32; // ST18_4
  int v33; // ST14_4
  int v34; // ST10_4
  int v35; // ST1C_4
  int v36; // ST18_4
  int v37; // ST14_4
  int v38; // ST10_4
  int v39; // ST1C_4
  int v40; // ST18_4
  int v41; // ST14_4
  int v42; // ST10_4
  int v43; // ST1C_4
  int v44; // ST18_4
  int v45; // ST14_4
  int v46; // ST10_4
  int v47; // ST1C_4
  int v48; // ST18_4
  int v49; // ST14_4
  int v50; // ST10_4
  int v51; // ST1C_4
  int v52; // ST18_4
  int v53; // ST14_4
  int v54; // ST10_4
  int v55; // ST1C_4
  int v56; // ST18_4
  int v57; // ST14_4
  int v58; // ST10_4
  int v59; // ST1C_4
  int v60; // ST18_4
  int v61; // ST14_4
  int v62; // ST10_4
  int v63; // ST1C_4
  int v64; // ST18_4
  int v65; // ST14_4
  int v66; // ST10_4
  int v67; // ST1C_4
  int v68; // ST18_4
  int v69; // ST14_4
  int v70; // ST10_4
  int v71; // ST1C_4
  int v72; // ST18_4
  int v73; // ST14_4
  int *result; // eax
  int *v75; // [esp+Ch] [ebp-74h]
  int v76; // [esp+10h] [ebp-70h]
  int v77; // [esp+14h] [ebp-6Ch]
  int v78; // [esp+18h] [ebp-68h]
  int v79; // [esp+1Ch] [ebp-64h]
  int v80; // [esp+44h] [ebp-3Ch]
  int v81; // [esp+48h] [ebp-38h]
  int v82; // [esp+4Ch] [ebp-34h]
  int v83; // [esp+50h] [ebp-30h]
  int v84; // [esp+54h] [ebp-2Ch]
  int v85; // [esp+58h] [ebp-28h]
  int v86; // [esp+5Ch] [ebp-24h]
  int v87; // [esp+60h] [ebp-20h]
  int v88; // [esp+64h] [ebp-1Ch]
  int v89; // [esp+68h] [ebp-18h]
  int v90; // [esp+6Ch] [ebp-14h]
  int v91; // [esp+70h] [ebp-10h]
  int v92; // [esp+74h] [ebp-Ch]
  int v93; // [esp+78h] [ebp-8h]
  int v94; // [esp+7Ch] [ebp-4h]

  v75 = a1;
  v76 = *a3;
  v77 = a3[1];
  v78 = a3[2];
  v79 = a3[3];
  a3[4] += a2;
  a3[5] += a3[4] < a2;
  while ( v75 < &a1[a2 >> 2] )
  {
    v3 = v76;
    v4 = v77;
    v5 = v78;
    v6 = v79;
    v7 = *v75;
    v8 = (v79 ^ v77 & (v78 ^ v79)) + *v75 + v76 - 680876936;
    v9 = v75 + 1;
    v10 = v77 + __ROR4__(v8, 25);
    v80 = *v9;
    ++v9;
    v11 = v10 + __ROR4__((v78 ^ v10 & (v77 ^ v78)) + v80 + v79 - 389564586, 20);
    v81 = *v9;
    ++v9;
    v12 = v11 + __ROR4__((v77 ^ v11 & (v10 ^ v77)) + v81 + v78 + 606105819, 15);
    v82 = *v9;
    ++v9;
    v13 = v12 + __ROR4__((v10 ^ v12 & (v11 ^ v10)) + v82 + v77 - 1044525330, 10);
    v83 = *v9;
    ++v9;
    v14 = v13 + __ROR4__((v11 ^ v13 & (v12 ^ v11)) + v83 + v10 - 176418897, 25);
    v84 = *v9;
    ++v9;
    v15 = v14 + __ROR4__((v12 ^ v14 & (v13 ^ v12)) + v84 + v11 + 1200080426, 20);
    v85 = *v9;
    ++v9;
    v16 = v15 + __ROR4__((v13 ^ v15 & (v14 ^ v13)) + v85 + v12 - 1473231341, 15);
    v86 = *v9;
    ++v9;
    v17 = v16 + __ROR4__((v14 ^ v16 & (v15 ^ v14)) + v86 + v13 - 45705983, 10);
    v87 = *v9;
    ++v9;
    v18 = v17 + __ROR4__((v15 ^ v17 & (v16 ^ v15)) + v87 + v14 + 1770035416, 25);
    v88 = *v9;
    ++v9;
    v19 = v18 + __ROR4__((v16 ^ v18 & (v17 ^ v16)) + v88 + v15 - 1958414417, 20);
    v89 = *v9;
    ++v9;
    v20 = v19 + __ROR4__((v17 ^ v19 & (v18 ^ v17)) + v89 + v16 - 42063, 15);
    v90 = *v9;
    ++v9;
    v21 = v20 + __ROR4__((v18 ^ v20 & (v19 ^ v18)) + v90 + v17 - 1990404162, 10);
    v91 = *v9;
    ++v9;
    v22 = v21 + __ROR4__((v19 ^ v21 & (v20 ^ v19)) + v91 + v18 + 1804603682, 25);
    v92 = *v9;
    ++v9;
    v23 = v22 + __ROR4__((v20 ^ v22 & (v21 ^ v20)) + v92 + v19 - 40341101, 20);
    v93 = *v9;
    ++v9;
    v24 = v23 + __ROR4__((v21 ^ v23 & (v22 ^ v21)) + v93 + v20 - 1502002290, 15);
    v94 = *v9;
    v75 = v9 + 1;
    v25 = v24 + __ROR4__((v22 ^ v24 & (v23 ^ v22)) + v94 + v21 + 1236535329, 10);
    v26 = v25 + __ROR4__(v80 + (v24 ^ v23 & (v25 ^ v24)) + v22 - 165796510, 27);
    v27 = v26 + __ROR4__(v85 + (v25 ^ v24 & (v26 ^ v25)) + v23 - 1069501632, 23);
    v28 = v27 + __ROR4__(v90 + (v26 ^ v25 & (v27 ^ v26)) + v24 + 643717713, 18);
    v29 = v28 + __ROR4__(v7 + (v27 ^ v26 & (v28 ^ v27)) + v25 - 373897302, 12);
    v30 = v29 + __ROR4__(v84 + (v28 ^ v27 & (v29 ^ v28)) + v26 - 701558691, 27);
    v31 = v30 + __ROR4__(v89 + (v29 ^ v28 & (v30 ^ v29)) + v27 + 38016083, 23);
    v32 = v31 + __ROR4__(v94 + (v30 ^ v29 & (v31 ^ v30)) + v28 - 660478335, 18);
    v33 = v32 + __ROR4__(v83 + (v31 ^ v30 & (v32 ^ v31)) + v29 - 405537848, 12);
    v34 = v33 + __ROR4__(v88 + (v32 ^ v31 & (v33 ^ v32)) + v30 + 568446438, 27);
    v35 = v34 + __ROR4__(v93 + (v33 ^ v32 & (v34 ^ v33)) + v31 - 1019803690, 23);
    v36 = v35 + __ROR4__(v82 + (v34 ^ v33 & (v35 ^ v34)) + v32 - 187363961, 18);
    v37 = v36 + __ROR4__(v87 + (v35 ^ v34 & (v36 ^ v35)) + v33 + 1163531501, 12);
    v38 = v37 + __ROR4__(v92 + (v36 ^ v35 & (v37 ^ v36)) + v34 - 1444681467, 27);
    v39 = v38 + __ROR4__(v81 + (v37 ^ v36 & (v38 ^ v37)) + v35 - 51403784, 23);
    v40 = v39 + __ROR4__(v86 + (v38 ^ v37 & (v39 ^ v38)) + v36 + 1735328473, 18);
    v41 = v40 + __ROR4__(v91 + (v39 ^ v38 & (v40 ^ v39)) + v37 - 1926607734, 12);
    v42 = v41 + __ROR4__(v84 + (v39 ^ v41 ^ v40) + v38 - 378558, 28);
    v43 = v42 + __ROR4__(v87 + (v40 ^ v42 ^ v41) + v39 - 2022574463, 21);
    v44 = v43 + __ROR4__(v90 + (v41 ^ v43 ^ v42) + v40 + 1839030562, 16);
    v45 = v44 + __ROR4__(v93 + (v42 ^ v44 ^ v43) + v41 - 35309556, 9);
    v46 = v45 + __ROR4__(v80 + (v43 ^ v45 ^ v44) + v42 - 1530992060, 28);
    v47 = v46 + __ROR4__(v83 + (v44 ^ v46 ^ v45) + v43 + 1272893353, 21);
    v48 = v47 + __ROR4__(v86 + (v45 ^ v47 ^ v46) + v44 - 155497632, 16);
    v49 = v48 + __ROR4__(v89 + (v46 ^ v48 ^ v47) + v45 - 1094730640, 9);
    v50 = v49 + __ROR4__(v92 + (v47 ^ v49 ^ v48) + v46 + 681279174, 28);
    v51 = v50 + __ROR4__(v7 + (v48 ^ v50 ^ v49) + v47 - 358537222, 21);
    v52 = v51 + __ROR4__(v82 + (v49 ^ v51 ^ v50) + v48 - 722521979, 16);
    v53 = v52 + __ROR4__(v85 + (v50 ^ v52 ^ v51) + v49 + 76029189, 9);
    v54 = v53 + __ROR4__(v88 + (v51 ^ v53 ^ v52) + v50 - 640364487, 28);
    v55 = v54 + __ROR4__(v91 + (v52 ^ v54 ^ v53) + v51 - 421815835, 21);
    v56 = v55 + __ROR4__(v94 + (v53 ^ v55 ^ v54) + v52 + 530742520, 16);
    v57 = v56 + __ROR4__(v81 + (v54 ^ v56 ^ v55) + v53 - 995338651, 9);
    v58 = v57 + __ROR4__(v7 + (v56 ^ (v57 | ~v55)) + v54 - 198630844, 26);
    v59 = v58 + __ROR4__(v86 + (v57 ^ (v58 | ~v56)) + v55 + 1126891415, 22);
    v60 = v59 + __ROR4__(v93 + (v58 ^ (v59 | ~v57)) + v56 - 1416354905, 17);
    v61 = v60 + __ROR4__(v84 + (v59 ^ (v60 | ~v58)) + v57 - 57434055, 11);
    v62 = v61 + __ROR4__(v91 + (v60 ^ (v61 | ~v59)) + v58 + 1700485571, 26);
    v63 = v62 + __ROR4__(v82 + (v61 ^ (v62 | ~v60)) + v59 - 1894986606, 22);
    v64 = v63 + __ROR4__(v89 + (v62 ^ (v63 | ~v61)) + v60 - 1051523, 17);
    v65 = v64 + __ROR4__(v80 + (v63 ^ (v64 | ~v62)) + v61 - 2054922799, 11);
    v66 = v65 + __ROR4__(v87 + (v64 ^ (v65 | ~v63)) + v62 + 1873313359, 26);
    v67 = v66 + __ROR4__(v94 + (v65 ^ (v66 | ~v64)) + v63 - 30611744, 22);
    v68 = v67 + __ROR4__(v85 + (v66 ^ (v67 | ~v65)) + v64 - 1560198380, 17);
    v69 = v68 + __ROR4__(v92 + (v67 ^ (v68 | ~v66)) + v65 + 1309151649, 11);
    v70 = v69 + __ROR4__(v83 + (v68 ^ (v69 | ~v67)) + v66 - 145523070, 26);
    v71 = v70 + __ROR4__(v90 + (v69 ^ (v70 | ~v68)) + v67 - 1120210379, 22);
    v72 = v71 + __ROR4__(v81 + (v70 ^ (v71 | ~v69)) + v68 + 718787259, 17);
    v73 = v72 + __ROR4__(v88 + (v71 ^ (v72 | ~v70)) + v69 - 343485551, 11);
    v76 = v3 + v70;
    v77 = v4 + v73;
    v78 = v5 + v72;
    v79 = v6 + v71;
  }
  *a3 = v76;
  a3[1] = v77;
  a3[2] = v78;
  result = a3;
  a3[3] = v79;
  return result;
}

//----- (08056C97) --------------------------------------------------------
int __cdecl sub_8056C97(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // [esp+20h] [ebp-28h]
  int v8; // [esp+24h] [ebp-24h]

  v7 = a4;
  v8 = a5;
  return posix_fadvise64(a1, a2, a3, a4, a5, a6);
}
// 8049E60: using guessed type int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (08056CF8) --------------------------------------------------------
void __cdecl sub_8056CF8(FILE *stream, int a2)
{
  int v2; // eax

  if ( stream )
  {
    v2 = fileno(stream);
    sub_8056C97(v2, 0, 0, 0, 0, a2);
  }
}

//----- (08056D40) --------------------------------------------------------
_BYTE *__cdecl sub_8056D40(_BYTE **a1)
{
  char v2; // [esp+1Bh] [ebp-Dh]
  _BYTE *v3; // [esp+1Ch] [ebp-Ch]

  v3 = 0;
  v2 = 0;
  dword_806A288 = (int)&loc_8056DFB;
  sub_80611DA();
  do
  {
    if ( v2 )
    {
      v2 = 0;
      if ( (unsigned __int8)sub_805FD2A((char)**a1) ^ 1 && **a1 != 126 )
        v3 = 0;
    }
    else if ( **a1 == 46 )
    {
      v2 = 1;
      if ( !v3 )
        v3 = *a1;
    }
    else if ( (unsigned __int8)sub_805FCB7((char)**a1) ^ 1 && **a1 != 126 )
    {
      v3 = 0;
    }
    ++*a1;
  }
  while ( **a1 );
  return v3;
}
// 805FCB7: using guessed type _DWORD __cdecl sub_805FCB7(_DWORD);
// 806A288: using guessed type int dword_806A288;

//----- (08056E10) --------------------------------------------------------
int __cdecl sub_8056E10(unsigned __int8 a1)
{
  char v1; // al
  int result; // eax

  v1 = sub_805FDB2(a1);
  _CF = 0;
  _OF = 0;
  _ZF = v1 == 0;
  _SF = v1 < 0;
  if ( v1 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  else if ( (unsigned __int8)sub_805FD2A(a1) )
  {
    result = a1;
  }
  else if ( a1 == 126 )
  {
    result = -1;
  }
  else
  {
    result = a1 + 256;
  }
  return result;
}

//----- (08056E62) --------------------------------------------------------
int __cdecl sub_8056E62(int a1, unsigned int a2, int a3, unsigned int a4)
{
  int v8; // eax
  int v13; // eax
  int result; // eax
  void *v15; // eax
  void *v16; // eax
  void *v17; // eax
  int v22; // [esp+0h] [ebp-38h]
  unsigned int v23; // [esp+1Ch] [ebp-1Ch]
  unsigned int v24; // [esp+20h] [ebp-18h]
  int v25; // [esp+24h] [ebp-14h]
  int v26; // [esp+28h] [ebp-10h]
  int v27; // [esp+2Ch] [ebp-Ch]

  v23 = 0;
  v24 = 0;
  if ( v23 < a2
    || (_CF = v24 < a4, _OF = __OFSUB__(v24, a4), _ZF = v24 == a4, _SF = (signed int)(v24 - a4) < 0, v24 < a4) )
  {
    v25 = 0;
    while ( v23 < a2 && (unsigned __int8)sub_805FDB2(*(char *)(a1 + v23)) ^ 1
         || v24 < a4 && (unsigned __int8)sub_805FDB2(*(char *)(a3 + v24)) ^ 1 )
    {
      _CF = v23 < a2;
      _OF = __OFSUB__(v23, a2);
      _ZF = v23 == a2;
      _SF = (signed int)(v23 - a2) < 0;
      if ( v23 == a2 )
      {
        __asm { pushfw }
        v8 = 0;
        __asm { popfw }
      }
      else
      {
        v8 = sub_8056E10(*(_BYTE *)(a1 + v23));
      }
      v26 = v8;
      _CF = v24 < a4;
      _OF = __OFSUB__(v24, a4);
      _ZF = v24 == a4;
      _SF = (signed int)(v24 - a4) < 0;
      if ( v24 == a4 )
      {
        __asm { pushfw }
        v13 = 0;
        __asm { popfw }
      }
      else
      {
        v13 = sub_8056E10(*(_BYTE *)(a3 + v24));
      }
      v27 = v13;
      if ( v26 != v13 )
        return v26 - v27;
      ++v23;
      ++v24;
    }
    v15 = &loc_8056F85;
    if ( *(_BYTE *)(a1 + v23) == 48 )
      v15 = &loc_8056F49;
    dword_806A288 = (int)v15;
    sub_80611DA();
    while ( *(_BYTE *)(a3 + v24) == 48 )
      ++v24;
    v22 = *(char *)(a1 + v23);
    if ( (unsigned __int8)sub_805FDB2(v22) )
    {
      v22 = *(char *)(a3 + v24);
      _ZF = (unsigned __int8)sub_805FDB2(v22) == 0;
      v16 = &loc_805703F;
      if ( !_ZF )
        v16 = &loc_8056F9C;
      dword_806A268 = (int)v16;
      sub_80612C7();
    }
    v22 = *(char *)(a1 + v23);
    _ZF = (unsigned __int8)sub_805FDB2(v22) == 0;
    v17 = &loc_8057072;
    if ( _ZF )
      v17 = &loc_8057079;
    dword_806A288 = (int)v17;
    sub_80611DA();
    result = 1;
  }
  else
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 8056E62: could not find valid save-restore pair for ebx
// 80612C7: using guessed type int sub_80612C7(void);
// 806A268: using guessed type int dword_806A268;
// 806A288: using guessed type int dword_806A288;

//----- (080570DE) --------------------------------------------------------
#error "8057190: call analysis failed (funcsize=58)"

//----- (08057327) --------------------------------------------------------
int __cdecl sub_8057327(int category)
{
  unsigned __int8 v2; // [esp+1Bh] [ebp-Dh]
  const char *s1; // [esp+1Ch] [ebp-Ch]

  v2 = 1;
  s1 = setlocale(category, 0);
  if ( s1 && (!strcmp(s1, "C") || !strcmp(s1, "POSIX")) )
    v2 = 0;
  return v2;
}

//----- (08057385) --------------------------------------------------------
int __cdecl sub_8057385(int a1)
{
  return *(_DWORD *)(a1 + 8);
}

//----- (08057390) --------------------------------------------------------
int __cdecl sub_8057390(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (0805739B) --------------------------------------------------------
int __cdecl sub_805739B(int a1)
{
  return *(_DWORD *)(a1 + 16);
}

//----- (080573A6) --------------------------------------------------------
unsigned int __cdecl sub_80573A6(int a1)
{
  _DWORD *i; // [esp+0h] [ebp-10h]
  unsigned int v3; // [esp+4h] [ebp-Ch]
  _DWORD *v4; // [esp+8h] [ebp-8h]
  unsigned int j; // [esp+Ch] [ebp-4h]

  v3 = 0;
  for ( i = *(_DWORD **)a1; *(_DWORD *)(a1 + 4) > (unsigned int)i; i += 2 )
  {
    if ( *i )
    {
      v4 = i;
      for ( j = 1; ; ++j )
      {
        v4 = (_DWORD *)v4[1];
        if ( !v4 )
          break;
      }
      if ( j > v3 )
        v3 = j;
    }
  }
  return v3;
}

//----- (0805758B) --------------------------------------------------------
int __cdecl sub_805758B(_DWORD *a1, int a2)
{
  int (__cdecl *v2)(int, int); // eax
  int v4; // [esp+4h] [ebp-24h]
  unsigned int v5; // [esp+1Ch] [ebp-Ch]

  v2 = (int (__cdecl *)(int, int))a1[6];
  v4 = a1[2];
  v5 = v2(a2, v4);
  if ( a1[2] <= v5 )
    abort();
  return 8 * v5 + *a1;
}

//----- (080578D5) --------------------------------------------------------
#error "805790A: call analysis failed (funcsize=42)"

//----- (08057953) --------------------------------------------------------
int __cdecl sub_8057953(unsigned int a1)
{
  int i; // [esp+Ch] [ebp+8h]

  if ( a1 <= 9 )
    a1 = 10;
  for ( i = a1 | 1; i != -1 && (unsigned __int8)sub_80578D5(i) ^ 1; i += 2 )
    ;
  return i;
}
// 80578D5: using guessed type _DWORD __cdecl sub_80578D5(_DWORD);

//----- (080579D4) --------------------------------------------------------
unsigned int __cdecl sub_80579D4(int a1, unsigned int a2)
{
  return sub_805FB8C(a1, 3) % a2;
}

//----- (08057A00) --------------------------------------------------------
bool __cdecl sub_8057A00(int a1, int a2)
{
  return a1 == a2;
}

//----- (08057A0E) --------------------------------------------------------
signed int __cdecl sub_8057A0E(int a1)
{
  signed int result; // eax
  long double v4; // fst6
  long double v7; // fst7
  long double v8; // fst6
  long double v9; // fst6
  long double v10; // fst7
  long double v11; // fst6
  long double v12; // fst7
  long double v13; // fst7
  long double v14; // fst6
  int v15; // [esp+8h] [ebp-8h]

  v15 = *(_DWORD *)(a1 + 20);
  _OF = __OFSUB__(v15, &unk_8063A98);
  _SF = v15 - (signed int)&unk_8063A98 < 0;
  if ( (_UNKNOWN *)v15 == &unk_8063A98 )
    return 1;
  v4 = *(float *)(v15 + 8);
  _CF = v4 < 0.1;
  _ZF = v4 == 0.1;
  if ( v4 > 0.1 )
  {
    v7 = *(float *)(v15 + 8);
    _CF = 1.0 - 0.1 < v7;
    _ZF = 1.0 - 0.1 == v7;
    if ( 1.0 - 0.1 > v7 )
    {
      v8 = *(float *)(v15 + 12);
      _CF = v8 < 0.1 + 1.0;
      _ZF = v8 == 0.1 + 1.0;
      if ( v8 > 0.1 + 1.0 )
      {
        v9 = *(float *)v15;
        _CF = v9 < 0.0;
        _ZF = v9 == 0.0;
        if ( v9 >= 0.0 )
        {
          v10 = *(float *)v15 + 0.1;
          v11 = *(float *)(v15 + 4);
          _CF = v11 < v10;
          _ZF = v11 == v10;
          if ( v11 > v10 )
          {
            v12 = *(float *)(v15 + 4);
            _CF = 1.0 < v12;
            _ZF = 1.0 == v12;
            if ( v12 <= 1.0 )
            {
              v13 = *(float *)v15 + 0.1;
              v14 = *(float *)(v15 + 8);
              _CF = v14 < v13;
              _ZF = v14 == v13;
              if ( v14 > v13 )
                return 1;
            }
          }
        }
      }
    }
  }
  *(_DWORD *)(a1 + 20) = &unk_8063A98;
  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}

//----- (08057ACB) --------------------------------------------------------
#error "8057AF3: call analysis failed (funcsize=55)"

//----- (08057BA9) --------------------------------------------------------
size_t *__cdecl sub_8057BA9(int a1, void *a2, unsigned int (__cdecl *a3)(int a1, unsigned int a2), bool (__cdecl *a4)(int a1, int a2), size_t a5)
{
  size_t *result; // eax
  size_t *ptr; // [esp+1Ch] [ebp-Ch]

  if ( !a3 )
    a3 = sub_80579D4;
  if ( !a4 )
    a4 = sub_8057A00;
  ptr = (size_t *)malloc(0x28u);
  _CF = 0;
  _OF = 0;
  _ZF = ptr == 0;
  _SF = (signed int)ptr < 0;
  if ( ptr )
  {
    if ( !a2 )
      a2 = &unk_8063A98;
    ptr[5] = (size_t)a2;
    if ( !((unsigned __int8)sub_8057A0E((int)ptr) ^ 1)
      && (ptr[2] = sub_8057ACB(a1, a2)) != 0
      && (*ptr = (size_t)calloc(ptr[2], 8u)) != 0 )
    {
      ptr[1] = 8 * ptr[2] + *ptr;
      ptr[3] = 0;
      ptr[4] = 0;
      ptr[6] = (size_t)a3;
      ptr[7] = (size_t)a4;
      ptr[8] = a5;
      ptr[9] = 0;
      result = ptr;
    }
    else
    {
      free(ptr);
      __asm { pushfw }
      result = 0;
      __asm { popfw }
    }
  }
  else
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 8057ACB: using guessed type _DWORD __cdecl sub_8057ACB(_DWORD, _DWORD);

//----- (08057ED4) --------------------------------------------------------
void *__cdecl sub_8057ED4(int a1)
{
  int v2; // [esp+1Ch] [ebp-Ch]

  if ( !*(_DWORD *)(a1 + 36) )
    return malloc(8u);
  v2 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(v2 + 4);
  return (void *)v2;
}

//----- (08057F0F) --------------------------------------------------------
int __cdecl sub_8057F0F(int a1, _DWORD *a2)
{
  int result; // eax

  *a2 = 0;
  a2[1] = *(_DWORD *)(a1 + 36);
  result = a1;
  *(_DWORD *)(a1 + 36) = a2;
  return result;
}

//----- (08057F42) --------------------------------------------------------
int __cdecl sub_8057F42(_DWORD *a1, int a2, int **a3, char a4)
{
  int result; // eax
  unsigned __int8 (*v9)(void); // eax
  int v10; // eax
  void *v11; // eax
  int *v12; // ecx
  int v13; // edx
  void *v14; // eax
  unsigned __int8 (__cdecl *v15)(int, int); // eax
  int v16; // eax
  int v21; // [esp-4h] [ebp-3Ch]
  int v22; // [esp+0h] [ebp-38h]
  int v23; // [esp+4h] [ebp-34h]
  int v24; // [esp+8h] [ebp-30h]
  char v25; // [esp+Ch] [ebp-2Ch]
  int v26; // [esp+10h] [ebp-28h]
  int v27; // [esp+14h] [ebp-24h]
  int *i; // [esp+18h] [ebp-20h]
  int *v29; // [esp+1Ch] [ebp-1Ch]
  int v30; // [esp+20h] [ebp-18h]
  _DWORD *v31; // [esp+24h] [ebp-14h]
  int v32; // [esp+28h] [ebp-10h]
  int *v33; // [esp+2Ch] [ebp-Ch]
  int v34; // [esp+30h] [ebp-8h]
  int v35; // [esp+34h] [ebp-4h]
  int savedregs; // [esp+38h] [ebp+0h]

  v25 = a4;
  v29 = (int *)sub_805758B(a1, a2);
  *a3 = v29;
  _CF = 0;
  _OF = 0;
  _ZF = *v29 == 0;
  _SF = *v29 < 0;
  if ( *v29 )
  {
    if ( *v29 == a2 || (v9 = (unsigned __int8 (*)(void))a1[7], v23 = *v29, v22 = a2, v9()) )
    {
      v10 = *v29;
      v32 = v10;
      v21 = v10;
      v11 = &loc_8057FCB;
      if ( !v25 )
        v11 = &loc_805801B;
      dword_806A20C = (int)v11;
      sub_806151E(v22, v23, v24, *(_DWORD *)&v25, v26, v27, i, v29, v30, v31, v32, v33, v34, v35, savedregs);
      if ( v29[1] )
      {
        v33 = (int *)v29[1];
        v12 = v29;
        v13 = v33[1];
        *v29 = *v33;
        v12[1] = v13;
        sub_8057F0F((int)a1, v33);
      }
      else
      {
        *v29 = 0;
      }
      result = v32;
    }
    else
    {
      for ( i = v29; ; i = (int *)i[1] )
      {
        v16 = i[1];
        _CF = 0;
        _OF = 0;
        _ZF = v16 == 0;
        _SF = v16 < 0;
        if ( !v16 )
        {
          __asm { pushfw }
          result = 0;
          __asm { popfw }
          return result;
        }
        _ZF = *(_DWORD *)i[1] == a2;
        v21 = *(_DWORD *)i[1];
        v14 = &loc_8058064;
        if ( _ZF )
          v14 = &loc_8058082;
        dword_806A268 = (int)v14;
        sub_80612C7();
        v15 = (unsigned __int8 (__cdecl *)(int, int))a1[7];
        v23 = *(_DWORD *)i[1];
        if ( v15(a2, v23) )
          break;
      }
      v30 = *(_DWORD *)i[1];
      if ( v25 )
      {
        v31 = (_DWORD *)i[1];
        i[1] = v31[1];
        sub_8057F0F((int)a1, v31);
      }
      result = v30;
    }
  }
  else
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 80612C7: using guessed type int sub_80612C7(void);
// 806151E: using guessed type int __stdcall sub_806151E(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806A20C: using guessed type int dword_806A20C;
// 806A268: using guessed type int dword_806A268;

//----- (080580EE) --------------------------------------------------------
signed int __cdecl sub_80580EE(_DWORD *a1, int a2, char a3)
{
  void *v3; // eax
  void *v5; // eax
  signed int result; // eax
  int v10; // [esp+0h] [ebp-38h]
  int v11; // [esp+4h] [ebp-34h]
  int v12; // [esp+8h] [ebp-30h]
  _DWORD v13[3]; // [esp+Ch] [ebp-2Ch]
  int v14; // [esp+10h] [ebp-28h]
  int v15; // [esp+14h] [ebp-24h]
  int *i; // [esp+18h] [ebp-20h]
  int *j; // [esp+1Ch] [ebp-1Ch]
  int v18; // [esp+20h] [ebp-18h]
  int v19; // [esp+20h] [ebp-18h]
  int *v20; // [esp+24h] [ebp-14h]
  int *v21; // [esp+24h] [ebp-14h]
  int *v22; // [esp+28h] [ebp-10h]
  void *v23; // [esp+2Ch] [ebp-Ch]

  LOBYTE(v13[0]) = a3;
  for ( i = *(int **)a2; ; i += 2 )
  {
    if ( *(_DWORD *)(a2 + 4) <= (unsigned int)i )
      return 1;
    if ( *i )
    {
      for ( j = (int *)i[1]; j; j = v22 )
      {
        v18 = *j;
        v20 = (int *)sub_805758B(a1, *j);
        v22 = (int *)j[1];
        if ( *v20 )
        {
          j[1] = v20[1];
          v20[1] = (int)j;
        }
        else
        {
          *v20 = v18;
          ++a1[3];
          sub_8057F0F((int)a1, j);
        }
      }
      v19 = *i;
      i[1] = 0;
      if ( !a3 )
        break;
    }
LABEL_15:
    ;
  }
  v21 = (int *)sub_805758B(a1, v19);
  if ( !*v21 )
  {
    *v21 = v19;
    ++a1[3];
    *i = 0;
    --*(_DWORD *)(a2 + 12);
    goto LABEL_15;
  }
  v3 = sub_8057ED4((int)a1);
  v23 = v3;
  _ZF = v3 == 0;
  v5 = &loc_8058219;
  if ( !_ZF )
    v5 = &loc_8058221;
  dword_806A220 = (int)v5;
  sub_80614AE(v10, v11, v12, v13[0], v14, v15, i, 0, v19, v21, v22, v23);
  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}
// 80614AE: using guessed type int __stdcall sub_80614AE(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806A220: using guessed type int dword_806A220;

//----- (08058299) --------------------------------------------------------
signed int __cdecl sub_8058299(int a1, int a2)
{
  signed int result; // eax
  int nmemb; // [esp+10h] [ebp-38h]
  char *v12; // [esp+18h] [ebp-30h]
  char *v13; // [esp+1Ch] [ebp-2Ch]
  int v14; // [esp+20h] [ebp-28h]
  int v15; // [esp+24h] [ebp-24h]
  int v16; // [esp+28h] [ebp-20h]
  int v17; // [esp+2Ch] [ebp-1Ch]
  int v18; // [esp+30h] [ebp-18h]
  int v19; // [esp+34h] [ebp-14h]
  int v20; // [esp+38h] [ebp-10h]
  int v21; // [esp+3Ch] [ebp-Ch]

  nmemb = sub_8057ACB(a2, *(_DWORD *)(a1 + 20));
  _CF = 0;
  _OF = 0;
  _ZF = nmemb == 0;
  _SF = nmemb < 0;
  if ( nmemb )
  {
    if ( *(_DWORD *)(a1 + 8) == nmemb )
    {
      result = 1;
    }
    else
    {
      v12 = (char *)calloc(nmemb, 8u);
      _CF = 0;
      _OF = 0;
      _ZF = v12 == 0;
      _SF = (signed int)v12 < 0;
      if ( v12 )
      {
        v14 = nmemb;
        v13 = &v12[8 * nmemb];
        v15 = 0;
        v16 = 0;
        v17 = *(_DWORD *)(a1 + 20);
        v18 = *(_DWORD *)(a1 + 24);
        v19 = *(_DWORD *)(a1 + 28);
        v20 = *(_DWORD *)(a1 + 32);
        v21 = *(_DWORD *)(a1 + 36);
        if ( (unsigned __int8)sub_80580EE(&v12, a1, 0) )
        {
          free(*(void **)a1);
          *(_DWORD *)a1 = v12;
          *(_DWORD *)(a1 + 4) = v13;
          *(_DWORD *)(a1 + 8) = v14;
          *(_DWORD *)(a1 + 12) = v15;
          *(_DWORD *)(a1 + 36) = v21;
          result = 1;
        }
        else
        {
          *(_DWORD *)(a1 + 36) = v21;
          if ( (unsigned __int8)sub_80580EE((_DWORD *)a1, (int)&v12, 1) ^ 1
            || (unsigned __int8)sub_80580EE((_DWORD *)a1, (int)&v12, 0) ^ 1 )
          {
            abort();
          }
          free(v12);
          __asm { pushfw }
          result = 0;
          __asm { popfw }
        }
      }
      else
      {
        __asm { pushfw }
        result = 0;
        __asm { popfw }
      }
    }
  }
  else
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 8057ACB: using guessed type _DWORD __cdecl sub_8057ACB(_DWORD, _DWORD);

//----- (08058471) --------------------------------------------------------
signed int __cdecl sub_8058471(_DWORD *a1, int a2, _DWORD *a3)
{
  signed int result; // eax
  long double v8; // fst7
  __int16 v9; // ax
  void *v10; // eax
  int v11; // [esp+0h] [ebp-48h]
  int v12; // [esp+4h] [ebp-44h]
  int v13; // [esp+8h] [ebp-40h]
  int v14; // [esp+Ch] [ebp-3Ch]
  signed __int64 v15; // [esp+10h] [ebp-38h]
  int v16; // [esp+18h] [ebp-30h]
  int v17; // [esp+1Ch] [ebp-2Ch]
  int v18; // [esp+20h] [ebp-28h]
  int v19; // [esp+24h] [ebp-24h]
  int v20; // [esp+28h] [ebp-20h]
  int *v21; // [esp+2Ch] [ebp-1Ch]
  int v22; // [esp+30h] [ebp-18h]
  int v23; // [esp+34h] [ebp-14h]
  float v24; // [esp+38h] [ebp-10h]
  _DWORD *v25; // [esp+3Ch] [ebp-Ch]

  if ( !a2 )
    abort();
  v22 = sub_8057F42(a1, a2, &v21, 0);
  if ( v22 )
  {
    _CF = 0;
    _OF = 0;
    _ZF = a3 == 0;
    _SF = (signed int)a3 < 0;
    if ( a3 )
      *a3 = v22;
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  else if ( (long double)(unsigned int)a1[3] <= *(float *)(a1[5] + 8) * (long double)(unsigned int)a1[2]
         || (sub_8057A0E((int)a1),
             (long double)(unsigned int)a1[3] <= *(float *)(a1[5] + 8) * (long double)(unsigned int)a1[2]) )
  {
    if ( *v21 )
    {
      v25 = sub_8057ED4((int)a1);
      if ( v25 )
      {
        *v25 = a2;
        v25[1] = v21[1];
        v21[1] = (int)v25;
        ++a1[4];
        result = 1;
      }
      else
      {
        result = -1;
      }
    }
    else
    {
      *v21 = a2;
      ++a1[4];
      ++a1[3];
      result = 1;
    }
  }
  else
  {
    v23 = a1[5];
    if ( *(_BYTE *)(v23 + 16) )
      v8 = (long double)(unsigned int)a1[2] * *(float *)(v23 + 12);
    else
      v8 = (long double)(unsigned int)a1[2] * *(float *)(v23 + 12) * *(float *)(v23 + 8);
    v24 = v8;
    if ( v24 < 4294967300.0 )
    {
      LOBYTE(v9) = BYTE2(v17);
      HIBYTE(v9) = 12;
      LOWORD(v17) = v9;
      v15 = (signed __int64)v24;
      if ( !((unsigned __int8)sub_8058299((int)a1, v15) ^ 1) )
      {
        _ZF = sub_8057F42(a1, a2, &v21, 0) == 0;
        v10 = &loc_8058695;
        if ( _ZF )
          v10 = &loc_805869A;
        dword_806A20C = (int)v10;
        sub_806151E(v11, v12, v13, v14, v15, HIDWORD(v15), v16, v17, v18, v19, v20, v21, v22, v23, LODWORD(v24));
        abort();
      }
      result = -1;
    }
    else
    {
      result = -1;
    }
  }
  return result;
}
// 806151E: using guessed type int __stdcall sub_806151E(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806A20C: using guessed type int dword_806A20C;

//----- (0805873E) --------------------------------------------------------
int __cdecl sub_805873E(_DWORD *a1, int a2)
{
  int result; // eax
  int v7; // [esp+18h] [ebp-10h]
  unsigned int v8; // [esp+1Ch] [ebp-Ch]

  v8 = sub_8058471(a1, a2, &v7);
  _CF = v8 < 0xFFFFFFFF;
  _OF = __OFSUB__(v8, -1);
  _ZF = v8 == -1;
  _SF = (signed int)(v8 + 1) < 0;
  if ( v8 == -1 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  else if ( v8 )
  {
    result = a2;
  }
  else
  {
    result = v7;
  }
  return result;
}

//----- (0805877E) --------------------------------------------------------
#error "8058835: call analysis failed (funcsize=62)"

//----- (080589CF) --------------------------------------------------------
int *__cdecl sub_80589CF(int (*a1)(), unsigned int a2)
{
  int (*v2)(); // eax
  int *v4; // [esp+1Ch] [ebp-Ch]

  v4 = (int *)sub_805DF6E(0x10u);
  if ( !a2 )
    a2 = 1;
  *v4 = sub_805DE5C(a2, 4u);
  *(_DWORD *)*v4 = 0;
  v4[1] = a2;
  v4[2] = 0;
  if ( a1 )
    v2 = a1;
  else
    v2 = sub_8058A54;
  v4[3] = (int)v2;
  return v4;
}

//----- (08058A54) --------------------------------------------------------
int sub_8058A54()
{
  int result; // eax

  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}

//----- (08058A5F) --------------------------------------------------------
void __cdecl sub_8058A5F(void *ptr)
{
  free(*(void **)ptr);
  free(ptr);
}

//----- (08058A7F) --------------------------------------------------------
int __cdecl sub_8058A7F(int a1, int a2)
{
  _DWORD *v2; // edx
  int result; // eax

  if ( (unsigned int)(*(_DWORD *)(a1 + 4) - 1) <= *(_DWORD *)(a1 + 8) )
    *(_DWORD *)a1 = sub_805DEC1(*(void **)a1, a1 + 4, 4);
  v2 = *(_DWORD **)a1;
  v2[++*(_DWORD *)(a1 + 8)] = a2;
  sub_8058CCE(*(_DWORD *)a1, *(_DWORD *)(a1 + 8), *(int (__cdecl **)(_DWORD, int))(a1 + 12));
  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}

//----- (08058B19) --------------------------------------------------------
int __cdecl sub_8058B19(_DWORD *a1)
{
  int v1; // eax
  int result; // eax
  int v7; // ST20_4
  _DWORD *v8; // ebx
  int v9; // esi
  int v10; // eax

  v1 = a1[2];
  _CF = 0;
  _OF = 0;
  _ZF = v1 == 0;
  _SF = v1 < 0;
  if ( v1 )
  {
    v7 = *(_DWORD *)(*a1 + 4);
    v8 = (_DWORD *)(*a1 + 4);
    v9 = *a1;
    v10 = a1[2];
    a1[2] = v10 - 1;
    *v8 = *(_DWORD *)(v9 + 4 * v10);
    sub_8058BA6(*a1, a1[2], 1, a1[3]);
    result = v7;
  }
  else
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 8058BA6: using guessed type _DWORD __cdecl sub_8058BA6(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08058BA6) --------------------------------------------------------
#error "8058C98: call analysis failed (funcsize=88)"

//----- (08058CCE) --------------------------------------------------------
int __cdecl sub_8058CCE(int a1, unsigned int a2, int (__cdecl *a3)(_DWORD, int))
{
  int result; // eax
  unsigned int v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]

  v4 = a2;
  v5 = *(_DWORD *)(4 * a2 + a1);
  while ( v4 != 1 && a3(*(_DWORD *)(4 * (v4 >> 1) + a1), v5) <= 0 )
  {
    *(_DWORD *)(a1 + 4 * v4) = *(_DWORD *)(4 * (v4 >> 1) + a1);
    v4 >>= 1;
  }
  result = v5;
  *(_DWORD *)(a1 + 4 * v4) = v5;
  return result;
}

//----- (08058D8E) --------------------------------------------------------
int __cdecl sub_8058D8E(int a1, int a2)
{
  int v3; // [esp+Ch] [ebp-4h]

  v3 = a2 + 11;
  *(_BYTE *)(a2 + 11) = 0;
  if ( a1 >= 0 )
  {
    do
    {
      *(_BYTE *)--v3 = (char)a1 % 10 + 48;
      a1 /= 10;
    }
    while ( a1 );
  }
  else
  {
    do
    {
      *(_BYTE *)--v3 = 48 - a1 % 10;
      a1 /= 10;
    }
    while ( a1 );
    *(_BYTE *)--v3 = 45;
  }
  return v3;
}

//----- (08058E88) --------------------------------------------------------
int __cdecl sub_8058E88(unsigned int a1, int a2)
{
  int v3; // [esp+Ch] [ebp-4h]

  v3 = a2 + 10;
  *(_BYTE *)(a2 + 10) = 0;
  do
  {
    *(_BYTE *)--v3 = a1 % 0xA + 48;
    a1 /= 0xAu;
  }
  while ( a1 );
  return v3;
}

//----- (08058EF6) --------------------------------------------------------
int __cdecl sub_8058EF6(unsigned __int64 a1, int a2)
{
  unsigned __int64 v2; // rax
  unsigned __int64 v4; // [esp+18h] [ebp-20h]
  int v5; // [esp+2Ch] [ebp-Ch]

  v4 = a1;
  v5 = a2 + 20;
  *(_BYTE *)(a2 + 20) = 0;
  do
  {
    *(_BYTE *)--v5 = sub_8060D7D(v4, 10LL) + 48;
    LODWORD(v2) = sub_8060C03(v4, HIDWORD(v4), 10, 0);
    v4 = v2;
  }
  while ( v2 );
  return v5;
}
// 8060C03: using guessed type _DWORD __cdecl sub_8060C03(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08058FC9) --------------------------------------------------------
int __cdecl sub_8058FC9(char *a1, int a2, char a3)
{
  signed int v3; // eax
  size_t v4; // eax
  bool v5; // zf
  void *v6; // eax
  char *v8; // eax
  size_t v9; // [esp-4h] [ebp-5Ch]
  int v10; // [esp+0h] [ebp-58h]
  int v11; // [esp+4h] [ebp-54h]
  int v12; // [esp+8h] [ebp-50h]
  int v13; // [esp+Ch] [ebp-4Ch]
  int v14; // [esp+10h] [ebp-48h]
  int v15; // [esp+14h] [ebp-44h]
  int v16; // [esp+18h] [ebp-40h]
  char *v17; // [esp+1Ch] [ebp-3Ch]
  int v18; // [esp+20h] [ebp-38h]
  int v19; // [esp+24h] [ebp-34h]
  int v20; // [esp+28h] [ebp-30h]
  wint_t wc; // [esp+2Ch] [ebp-2Ch]
  char *v22; // [esp+30h] [ebp-28h]
  int v23; // [esp+34h] [ebp-24h]
  size_t v24; // [esp+38h] [ebp-20h]
  unsigned int v25; // [esp+3Ch] [ebp-1Ch]
  char s; // [esp+44h] [ebp-14h]
  unsigned int v27; // [esp+4Ch] [ebp-Ch]

  v17 = a1;
  v27 = __readgsdword(0x14u);
  v22 = a1;
  v25 = (unsigned int)&a1[a2];
  v23 = 0;
  if ( __ctype_get_mb_cur_max() > 1 )
  {
    while ( 1 )
    {
      if ( (unsigned int)v22 >= v25 )
        return v23;
      v3 = *v22;
      if ( v3 > 63 )
      {
        if ( v3 < 65 || v3 > 95 && (unsigned int)(v3 - 97) > 0x1D )
          goto LABEL_11;
LABEL_10:
        ++v22;
        ++v23;
      }
      else
      {
        if ( v3 >= 37 || (unsigned int)(v3 - 32) <= 3 )
          goto LABEL_10;
LABEL_11:
        memset(&s, 0, 8u);
        v4 = sub_805F443(&v10 - 11, v22, v25 - (_DWORD)v22, (mbstate_t *)&s);
        v24 = v4;
        v5 = v4 == -1;
        v9 = v4;
        v6 = &loc_80590CB;
        if ( !v5 )
          v6 = &loc_80590EC;
        dword_806A20C = (int)v6;
        sub_806151E(v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, wc, v22, v23, v24);
        if ( a3 & 1 )
          return -1;
        ++v22;
        ++v23;
      }
    }
  }
  while ( (unsigned int)v22 < v25 )
  {
    v8 = v22++;
    HIBYTE(v20) = *v8;
    if ( (*__ctype_b_loc())[HIBYTE(v20)] & 0x4000 )
    {
      if ( v23 == 0x7FFFFFFF )
        return 0x7FFFFFFF;
      ++v23;
    }
    else
    {
      if ( a3 & 2 )
        return -1;
      if ( !((*__ctype_b_loc())[HIBYTE(v20)] & 2) )
      {
        if ( v23 == 0x7FFFFFFF )
          return 0x7FFFFFFF;
        ++v23;
      }
    }
  }
  dword_806A220 = (int)&loc_805926F;
  sub_80614AE(v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, wc);
  return 0x7FFFFFFF;
}
// 80614AE: using guessed type int __stdcall sub_80614AE(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806151E: using guessed type int __stdcall sub_806151E(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806A20C: using guessed type int dword_806A20C;
// 806A220: using guessed type int dword_806A220;

//----- (08059282) --------------------------------------------------------
int sub_8059282()
{
  int v0; // eax
  int result; // eax
  int v6; // [esp+1Ch] [ebp-8Ch]
  char v7; // [esp+20h] [ebp-88h]

  v0 = sched_getaffinity(0, 128, &v7);
  _ZF = v0 == 0;
  _SF = v0 < 0;
  if ( !v0 )
  {
    v6 = __sched_cpucount(128, &v7);
    _ZF = v6 == 0;
    _SF = v6 < 0;
    if ( v6 )
      return v6;
  }
  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}
// 80498D0: using guessed type int __cdecl __sched_cpucount(_DWORD, _DWORD);
// 8049E70: using guessed type int __cdecl sched_getaffinity(_DWORD, _DWORD, _DWORD);

//----- (080592E2) --------------------------------------------------------
#error "8059312: call analysis failed (funcsize=33)"

//----- (080593AA) --------------------------------------------------------
int __cdecl sub_80593AA(char *nptr)
{
  int result; // eax
  char *endptr; // [esp+14h] [ebp-14h]
  int v3; // [esp+18h] [ebp-10h]
  unsigned int v4; // [esp+1Ch] [ebp-Ch]

  v3 = 0;
  if ( !nptr )
    return v3;
  while ( *nptr && (unsigned __int8)sub_805FE76(*nptr) )
    ++nptr;
  if ( !(unsigned __int8)sub_805FDB2(*nptr) )
    goto LABEL_20;
  endptr = 0;
  v4 = strtoul(nptr, &endptr, 10);
  if ( !endptr )
    goto LABEL_20;
  while ( *endptr && (unsigned __int8)sub_805FE76(*endptr) )
    ++endptr;
  if ( !*endptr )
    return v4;
  if ( *endptr == 44 )
    result = v4;
  else
LABEL_20:
    result = v3;
  return result;
}

//----- (08059477) --------------------------------------------------------
#error "80594D2: call analysis failed (funcsize=43)"

//----- (08059511) --------------------------------------------------------
long double sub_8059511()
{
  double v1; // [esp+18h] [ebp-60h]
  double v2; // [esp+20h] [ebp-58h]
  char v3; // [esp+2Ch] [ebp-4Ch]
  unsigned int v4; // [esp+3Ch] [ebp-3Ch]
  unsigned int v5; // [esp+60h] [ebp-18h]
  unsigned int v6; // [esp+6Ch] [ebp-Ch]

  v6 = __readgsdword(0x14u);
  v1 = (long double)sysconf(85);
  v2 = (long double)sysconf(30);
  if ( v1 >= 0.0 && v2 >= 0.0 )
    return v1 * v2;
  if ( sysinfo((struct sysinfo *)&v3) )
    return 67108864.0;
  return (long double)v4 * (long double)v5;
}

//----- (080595D0) --------------------------------------------------------
long double sub_80595D0()
{
  double v1; // [esp+18h] [ebp-60h]
  double v2; // [esp+20h] [ebp-58h]
  char v3; // [esp+2Ch] [ebp-4Ch]
  unsigned int v4; // [esp+40h] [ebp-38h]
  unsigned int v5; // [esp+48h] [ebp-30h]
  unsigned int v6; // [esp+60h] [ebp-18h]
  unsigned int v7; // [esp+6Ch] [ebp-Ch]

  v7 = __readgsdword(0x14u);
  v1 = (long double)sysconf(86);
  v2 = (long double)sysconf(30);
  if ( v1 >= 0.0 && v2 >= 0.0 )
    return v1 * v2;
  if ( sysinfo((struct sysinfo *)&v3) )
    return sub_8059511() / 4.0;
  return ((long double)v4 + (long double)v5) * (long double)v6;
}

//----- (080596AA) --------------------------------------------------------
int __cdecl sub_80596AA(int pipedes[2], int a2)
{
  int result; // eax
  unsigned int v7; // eax
  int v8; // ST28_4
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+1Ch] [ebp-1Ch]
  int v12; // [esp+20h] [ebp-18h]
  int v13; // [esp+20h] [ebp-18h]
  int v14; // [esp+28h] [ebp-10h]
  int v15; // [esp+2Ch] [ebp-Ch]

  v14 = *pipedes;
  v15 = pipedes[1];
  if ( dword_806AF28 >= 0 )
  {
    v9 = pipe2(pipedes, a2);
    if ( v9 >= 0 || *__errno_location() != 38 )
    {
      dword_806AF28 = 1;
      return v9;
    }
    dword_806AF28 = -1;
  }
  if ( a2 & 0xFFF7F7FF )
  {
    *__errno_location() = 22;
    result = -1;
  }
  else
  {
    if ( pipe(pipedes) < 0 )
    {
      dword_806A288 = (int)&locret_8059926;
      sub_80611DA();
    }
    if ( a2 & 0x800 )
    {
      v10 = sub_805F13C(pipedes[1], 3, 0);
      if ( v10 < 0 )
        goto LABEL_24;
      if ( sub_805F13C(pipedes[1], 4, v10) == -1 )
        goto LABEL_24;
      v11 = sub_805F13C(*pipedes, 3, 0);
      if ( v11 < 0 || sub_805F13C(*pipedes, 4, v11) == -1 )
        goto LABEL_24;
    }
    _CF = 0;
    _OF = 0;
    _ZF = (a2 & 0x80000) == 0;
    _SF = (a2 & 0x80000) < 0;
    if ( !(a2 & 0x80000) )
      goto LABEL_25;
    v12 = sub_805F13C(pipedes[1], 1, 0);
    if ( v12 < 0
      || sub_805F13C(pipedes[1], 2, v12 | 1) == -1
      || (v13 = sub_805F13C(*pipedes, 1, 0), v13 < 0)
      || (v7 = sub_805F13C(*pipedes, 2, v13 | 1),
          _CF = v7 < 0xFFFFFFFF,
          _OF = __OFSUB__(v7, -1),
          _ZF = v7 == -1,
          _SF = (signed int)(v7 + 1) < 0,
          v7 == -1) )
    {
LABEL_24:
      v8 = *__errno_location();
      close(*pipedes);
      close(pipedes[1]);
      *pipedes = v14;
      pipedes[1] = v15;
      *__errno_location() = v8;
      result = -1;
    }
    else
    {
LABEL_25:
      __asm { pushfw }
      result = 0;
      __asm { popfw }
    }
  }
  return result;
}
// 8049DF0: using guessed type int __cdecl pipe2(_DWORD, _DWORD);
// 806A288: using guessed type int dword_806A288;
// 806AF28: using guessed type int dword_806AF28;

//----- (08059928) --------------------------------------------------------
int sub_8059928()
{
  char *v0; // eax
  int v1; // edx
  int v2; // ecx
  bool v3; // zf
  void *v4; // eax
  char *endptr; // [esp+10h] [ebp-18h]
  int v7; // [esp+14h] [ebp-14h]
  char *nptr; // [esp+18h] [ebp-10h]
  int v9; // [esp+1Ch] [ebp-Ch]

  v7 = 200809;
  v0 = getenv("_POSIX2_VERSION");
  nptr = v0;
  v3 = v0 == 0;
  v4 = &loc_8059963;
  if ( v3 )
    v4 = &loc_805999A;
  dword_806A234 = (int)v4;
  sub_806143E(v2, v1);
  if ( *nptr )
  {
    v9 = strtol(nptr, &endptr, 10);
    if ( !*endptr )
      v7 = v9;
  }
  return v7;
}
// 806143E: using guessed type int __fastcall sub_806143E(_DWORD, _DWORD);
// 806A234: using guessed type int dword_806A234;

//----- (0805999F) --------------------------------------------------------
#error "8059A05: call analysis failed (funcsize=71)"

//----- (08059B6C) --------------------------------------------------------
int __cdecl sub_8059B6C(int a1, unsigned __int8 a2, char a3)
{
  void *v3; // eax
  int v4; // ST18_4

  v3 = &loc_8059BAF;
  if ( !a1 )
    v3 = &loc_8059BB4;
  dword_806A288 = (int)v3;
  sub_80611DA();
  v4 = (*(_DWORD *)(4 * (a2 >> 5) + a1 + 8) >> (a2 & 0x1F)) & 1;
  *(_DWORD *)(4 * (a2 >> 5) + a1 + 8) ^= (v4 ^ a3 & 1) << (a2 & 0x1F);
  return v4;
}
// 806A288: using guessed type int dword_806A288;

//----- (08059C4F) --------------------------------------------------------
int *__cdecl sub_8059C4F(int *a1, int a2, int a3)
{
  int *result; // eax

  if ( !a1 )
    a1 = &dword_806AF3C;
  *a1 = 10;
  if ( !a2 || !a3 )
    abort();
  a1[10] = a2;
  result = a1;
  a1[11] = a3;
  return result;
}
// 806AF3C: using guessed type int dword_806AF3C;

//----- (08059C90) --------------------------------------------------------
#error "8059CB9: call analysis failed (funcsize=17)"

//----- (08059CBE) --------------------------------------------------------
#error "8059CC6: positive sp value has been found (funcsize=4)"

//----- (08059D48) --------------------------------------------------------
#error "8059D78: call analysis failed (funcsize=22)"

//----- (08059E14) --------------------------------------------------------
void __cdecl sub_8059E14(int a1, int a2, int a3, int a4, unsigned int a5, int a6, int a7, int a8, int a9)
{
  bool v9; // ST53_1

  v9 = __ctype_get_mb_cur_max() == 1;
  if ( a5 <= 0xA )
    JUMPOUT(__CS__, off_8063CB4[a5]);
  abort();
}

//----- (0805A273) --------------------------------------------------------
void __usercall sub_805A273(int a1@<ebp>)
{
  *(_BYTE *)(a1 - 67) = *(_BYTE *)(*(_DWORD *)(a1 - 56) + 2 + *(_DWORD *)(a1 - 80));
  *(_DWORD *)(a1 - 56) += 2;
  if ( *(_DWORD *)(a1 - 52) < *(_DWORD *)(a1 + 12) )
    *(_BYTE *)(*(_DWORD *)(a1 - 76) + *(_DWORD *)(a1 - 52)) = 63;
  if ( ++*(_DWORD *)(a1 - 52) < *(_DWORD *)(a1 + 12) )
    *(_BYTE *)(*(_DWORD *)(a1 - 76) + *(_DWORD *)(a1 - 52)) = 34;
  if ( ++*(_DWORD *)(a1 - 52) < *(_DWORD *)(a1 + 12) )
    *(_BYTE *)(*(_DWORD *)(a1 - 76) + *(_DWORD *)(a1 - 52)) = 34;
  if ( ++*(_DWORD *)(a1 - 52) < *(_DWORD *)(a1 + 12) )
    *(_BYTE *)(*(_DWORD *)(a1 - 76) + *(_DWORD *)(a1 - 52)) = 63;
  ++*(_DWORD *)(a1 - 52);
  JUMPOUT(&loc_805A2E6);
}

//----- (0805A3D7) --------------------------------------------------------
void __usercall sub_805A3D7(int a1@<ebp>, int a2, int a3, int a4, int a5, char a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30)
{
  void *v30; // eax
  int v31; // [esp-8Ch] [ebp-8Ch]
  int v32; // [esp-88h] [ebp-88h]
  int v33; // [esp-84h] [ebp-84h]
  int v34; // [esp-80h] [ebp-80h]
  int v35; // [esp-7Ch] [ebp-7Ch]
  int v36; // [esp-78h] [ebp-78h]
  int v37; // [esp-74h] [ebp-74h]
  int v38; // [esp-70h] [ebp-70h]
  int v39; // [esp-6Ch] [ebp-6Ch]
  int v40; // [esp-68h] [ebp-68h]
  int v41; // [esp-64h] [ebp-64h]
  int v42; // [esp-60h] [ebp-60h]

  JUMPOUT(*(_DWORD *)(a1 + 20) != 1, 0, &loc_805A3E7);
  v30 = &loc_805A883;
  if ( a6 != 1 )
    v30 = &loc_805A889;
  dword_806A220 = (int)v30;
  sub_80614AE(v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42);
  JUMPOUT(a30, 2, &loc_805A8BD);
  JUMPOUT(&loc_805A89F);
}
// 80614AE: using guessed type int __stdcall sub_80614AE(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806A220: using guessed type int dword_806A220;

//----- (0805AB56) --------------------------------------------------------
#error "805AB5B: positive sp value has been found (funcsize=0)"

//----- (0805ACFE) --------------------------------------------------------
int __cdecl sub_805ACFE(int a1, int a2, _DWORD *a3, int *a4)
{
  int *v4; // eax
  int *v5; // ST3C_4
  int v6; // ST40_4
  int v7; // ST44_4
  int v8; // eax
  int size; // [esp+48h] [ebp-10h]
  int v11; // [esp+4Ch] [ebp-Ch]

  if ( a4 )
    v4 = a4;
  else
    v4 = &dword_806AF3C;
  v5 = v4;
  v6 = *__errno_location();
  v7 = v5[1] | (a3 == 0);
  sub_8059E14(0, 0, a1, a2, *v5, v7, (int)(v5 + 2), v5[10], v5[11]);
  size = v8 + 1;
  v11 = sub_805DF5B(v8 + 1);
  sub_8059E14(v11, size, a1, a2, *v5, v7, (int)(v5 + 2), v5[10], v5[11]);
  *__errno_location() = v6;
  if ( a3 )
    *a3 = size - 1;
  return v11;
}
// 806AF3C: using guessed type int dword_806AF3C;

//----- (0805AEC5) --------------------------------------------------------
void *__cdecl sub_805AEC5(signed int a1, int a2, int a3, unsigned int *a4)
{
  int v4; // ecx
  size_t v5; // edx
  _DWORD *v6; // ecx
  void *v7; // edx
  size_t v8; // eax
  char *v9; // ebx
  bool v11; // [esp+37h] [ebp-21h]
  void *v12; // [esp+38h] [ebp-20h]
  void *ptr; // [esp+3Ch] [ebp-1Ch]
  int v14; // [esp+40h] [ebp-18h]
  size_t size; // [esp+44h] [ebp-14h]
  int v16; // [esp+48h] [ebp-10h]
  size_t v17; // [esp+4Ch] [ebp-Ch]

  v14 = *__errno_location();
  v12 = off_806A3BC;
  if ( a1 < 0 )
    abort();
  if ( dword_806A3B0 <= a1 )
  {
    v11 = v12 == &dword_806A3B4;
    if ( (unsigned int)a1 > 0xFFFFFFE )
      sub_805E145();
    v5 = 8 * (a1 + 1);
    if ( v11 )
    {
      dword_806A234 = (int)&loc_805AF46;
      sub_806143E(v4, v5);
    }
    v12 = sub_805DFD6(v12, v5);
    off_806A3BC = (int *)v12;
    if ( v11 )
    {
      v6 = v12;
      v7 = off_806A3B8;
      *(_DWORD *)v12 = dword_806A3B4;
      v6[1] = v7;
    }
    memset((char *)v12 + 8 * dword_806A3B0, 0, 8 * (a1 + 1 - dword_806A3B0));
    dword_806A3B0 = a1 + 1;
  }
  size = *((_DWORD *)v12 + 2 * a1);
  ptr = (void *)*((_DWORD *)v12 + 2 * a1 + 1);
  v16 = a4[1] | 1;
  sub_8059E14((int)ptr, size, a2, a3, *a4, v16, (int)(a4 + 2), a4[10], a4[11]);
  v17 = v8;
  if ( size <= v8 )
  {
    size = v17 + 1;
    *((_DWORD *)v12 + 2 * a1) = v17 + 1;
    if ( ptr != &unk_806AF7C )
      free(ptr);
    v9 = (char *)v12 + 8 * a1;
    ptr = (void *)sub_805DF5B(size);
    *((_DWORD *)v9 + 1) = ptr;
    sub_8059E14((int)ptr, size, a2, a3, *a4, v16, (int)(a4 + 2), a4[10], a4[11]);
  }
  *__errno_location() = v14;
  return ptr;
}
// 806143E: using guessed type int __fastcall sub_806143E(_DWORD, _DWORD);
// 806A234: using guessed type int dword_806A234;
// 806A3B0: using guessed type int dword_806A3B0;
// 806A3B4: using guessed type int dword_806A3B4;
// 806A3B8: using guessed type void *off_806A3B8;
// 806A3BC: using guessed type int *off_806A3BC;

//----- (0805B144) --------------------------------------------------------
void *__cdecl sub_805B144(signed int a1, int a2)
{
  return sub_805AEC5(a1, a2, -1, (unsigned int *)&dword_806AF3C);
}
// 806AF3C: using guessed type int dword_806AF3C;

//----- (0805B16E) --------------------------------------------------------
void *__cdecl sub_805B16E(signed int a1, int a2, int a3)
{
  return sub_805AEC5(a1, a2, a3, (unsigned int *)&dword_806AF3C);
}
// 806AF3C: using guessed type int dword_806AF3C;

//----- (0805B1E4) --------------------------------------------------------
void *__cdecl sub_805B1E4(signed int a1, int a2, int a3)
{
  char v4; // [esp+10h] [ebp-38h]

  sub_8059C90(&v4, a2);
  return sub_805AEC5(a1, a3, -1, (unsigned int *)&v4);
}
// 8059C90: using guessed type int __cdecl sub_8059C90(_DWORD, _DWORD);

//----- (0805B222) --------------------------------------------------------
void *__cdecl sub_805B222(signed int a1, int a2, int a3, int a4)
{
  char v5; // [esp+10h] [ebp-38h]

  sub_8059C90(&v5, a2);
  return sub_805AEC5(a1, a3, a4, (unsigned int *)&v5);
}
// 8059C90: using guessed type int __cdecl sub_8059C90(_DWORD, _DWORD);

//----- (0805B25F) --------------------------------------------------------
void *__cdecl sub_805B25F(int a1, int a2)
{
  return sub_805B1E4(0, a1, a2);
}

//----- (0805B2BA) --------------------------------------------------------
void *__cdecl sub_805B2BA(int a1, int a2, unsigned __int8 a3)
{
  int v4; // [esp+0h] [ebp-58h]
  unsigned __int8 v5; // [esp+1Ch] [ebp-3Ch]
  int v6; // [esp+20h] [ebp-38h]
  int v7; // [esp+24h] [ebp-34h]
  int v8; // [esp+28h] [ebp-30h]
  int v9; // [esp+2Ch] [ebp-2Ch]
  int v10; // [esp+30h] [ebp-28h]
  int v11; // [esp+34h] [ebp-24h]
  int v12; // [esp+38h] [ebp-20h]
  int v13; // [esp+3Ch] [ebp-1Ch]
  int v14; // [esp+40h] [ebp-18h]
  int v15; // [esp+44h] [ebp-14h]
  int v16; // [esp+48h] [ebp-10h]
  int v17; // [esp+4Ch] [ebp-Ch]

  v5 = a3;
  v6 = dword_806AF3C;
  v7 = dword_806AF40;
  v8 = dword_806AF44;
  v9 = dword_806AF48;
  v10 = dword_806AF4C;
  v11 = dword_806AF50;
  v12 = dword_806AF54;
  v13 = dword_806AF58;
  v14 = dword_806AF5C;
  v15 = dword_806AF60;
  v16 = dword_806AF64;
  v17 = dword_806AF68;
  sub_8059B6C((int)(&v4 - 14), a3, 1);
  return sub_805AEC5(0, a1, a2, (unsigned int *)&v6);
}
// 806AF3C: using guessed type int dword_806AF3C;
// 806AF40: using guessed type int dword_806AF40;
// 806AF44: using guessed type int dword_806AF44;
// 806AF48: using guessed type int dword_806AF48;
// 806AF4C: using guessed type int dword_806AF4C;
// 806AF50: using guessed type int dword_806AF50;
// 806AF54: using guessed type int dword_806AF54;
// 806AF58: using guessed type int dword_806AF58;
// 806AF5C: using guessed type int dword_806AF5C;
// 806AF60: using guessed type int dword_806AF60;
// 806AF64: using guessed type int dword_806AF64;
// 806AF68: using guessed type int dword_806AF68;

//----- (0805B374) --------------------------------------------------------
#error "805B3A4: call analysis failed (funcsize=17)"

//----- (0805B3A9) --------------------------------------------------------
#error "805B3C1: positive sp value has been found (funcsize=0)"

//----- (0805B3C2) --------------------------------------------------------
int __cdecl sub_805B3C2(int a1)
{
  return sub_805B374(a1, 58);
}
// 805B374: using guessed type _DWORD __cdecl sub_805B374(_DWORD, _DWORD);

//----- (0805B3FF) --------------------------------------------------------
void *__cdecl sub_805B3FF(signed int a1, int a2, int a3)
{
  int v4; // [esp-4h] [ebp-7Ch]
  int v5; // [esp+10h] [ebp-68h]
  int v6; // [esp+14h] [ebp-64h]
  int v7; // [esp+18h] [ebp-60h]
  int v8; // [esp+1Ch] [ebp-5Ch]
  int v9; // [esp+20h] [ebp-58h]
  int v10; // [esp+24h] [ebp-54h]
  int v11; // [esp+28h] [ebp-50h]
  int v12; // [esp+2Ch] [ebp-4Ch]
  int v13; // [esp+30h] [ebp-48h]
  int v14; // [esp+34h] [ebp-44h]
  int v15; // [esp+38h] [ebp-40h]
  int v16; // [esp+3Ch] [ebp-3Ch]
  int v17; // [esp+40h] [ebp-38h]
  int v18; // [esp+44h] [ebp-34h]
  int v19; // [esp+48h] [ebp-30h]
  int v20; // [esp+4Ch] [ebp-2Ch]
  int v21; // [esp+50h] [ebp-28h]
  int v22; // [esp+54h] [ebp-24h]
  int v23; // [esp+58h] [ebp-20h]
  int v24; // [esp+5Ch] [ebp-1Ch]
  int v25; // [esp+60h] [ebp-18h]
  int v26; // [esp+64h] [ebp-14h]
  int v27; // [esp+68h] [ebp-10h]
  int v28; // [esp+6Ch] [ebp-Ch]

  sub_8059C90(&v5, a2);
  v17 = v5;
  v18 = v6;
  v19 = v7;
  v20 = v8;
  v21 = v9;
  v22 = v10;
  v23 = v11;
  v24 = v12;
  v25 = v13;
  v26 = v14;
  v27 = v15;
  v28 = v16;
  sub_8059B6C((int)(&v4 - 14), 0x3Au, 1);
  return sub_805AEC5(a1, a3, -1, (unsigned int *)&v17);
}
// 8059C90: using guessed type int __cdecl sub_8059C90(_DWORD, _DWORD);

//----- (0805B4B0) --------------------------------------------------------
void *__cdecl sub_805B4B0(signed int a1, int a2, int a3, int a4)
{
  return sub_805B4F0(a1, a2, a3, a4, -1);
}

//----- (0805B4F0) --------------------------------------------------------
void *__cdecl sub_805B4F0(signed int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [esp+0h] [ebp-48h]
  int v7; // [esp+10h] [ebp-38h]
  int v8; // [esp+14h] [ebp-34h]
  int v9; // [esp+18h] [ebp-30h]
  int v10; // [esp+1Ch] [ebp-2Ch]
  int v11; // [esp+20h] [ebp-28h]
  int v12; // [esp+24h] [ebp-24h]
  int v13; // [esp+28h] [ebp-20h]
  int v14; // [esp+2Ch] [ebp-1Ch]
  int v15; // [esp+30h] [ebp-18h]
  int v16; // [esp+34h] [ebp-14h]
  int v17; // [esp+38h] [ebp-10h]
  int v18; // [esp+3Ch] [ebp-Ch]

  v7 = dword_806AF3C;
  v8 = dword_806AF40;
  v9 = dword_806AF44;
  v10 = dword_806AF48;
  v11 = dword_806AF4C;
  v12 = dword_806AF50;
  v13 = dword_806AF54;
  v14 = dword_806AF58;
  v15 = dword_806AF5C;
  v16 = dword_806AF60;
  v17 = dword_806AF64;
  v18 = dword_806AF68;
  sub_8059C4F(&v6 - 14, a2, a3);
  return sub_805AEC5(a1, a4, a5, (unsigned int *)&v7);
}
// 806AF3C: using guessed type int dword_806AF3C;
// 806AF40: using guessed type int dword_806AF40;
// 806AF44: using guessed type int dword_806AF44;
// 806AF48: using guessed type int dword_806AF48;
// 806AF4C: using guessed type int dword_806AF4C;
// 806AF50: using guessed type int dword_806AF50;
// 806AF54: using guessed type int dword_806AF54;
// 806AF58: using guessed type int dword_806AF58;
// 806AF5C: using guessed type int dword_806AF5C;
// 806AF60: using guessed type int dword_806AF60;
// 806AF64: using guessed type int dword_806AF64;
// 806AF68: using guessed type int dword_806AF68;

//----- (0805B61A) --------------------------------------------------------
void *__cdecl sub_805B61A(signed int a1, int a2, int a3)
{
  return sub_805AEC5(a1, a2, a3, (unsigned int *)&unk_806A3D0);
}

//----- (0805B675) --------------------------------------------------------
void *__cdecl sub_805B675(signed int a1, int a2)
{
  return sub_805B61A(a1, a2, -1);
}

//----- (0805B697) --------------------------------------------------------
void *__cdecl sub_805B697(int a1)
{
  return sub_805B675(0, a1);
}

//----- (0805B6B2) --------------------------------------------------------
void __cdecl __noreturn sub_805B6B2(int a1)
{
  void *v1; // esi
  char *v2; // ebx
  int *v3; // eax

  if ( a1 )
  {
    v1 = sub_805B697(a1);
    if ( *__errno_location() )
      v2 = gettext("%s: read error");
    else
      v2 = gettext("%s: end of file");
    v3 = __errno_location();
    error(status, *v3, v2, v1);
  }
  abort();
}

//----- (0805B71B) --------------------------------------------------------
_DWORD *__cdecl sub_805B71B(int a1, int a2)
{
  _DWORD *result; // eax

  result = (_DWORD *)sub_805DF6E(0x81Cu);
  *result = a1;
  result[1] = sub_805B6B2;
  result[2] = a2;
  return result;
}

//----- (0805B760) --------------------------------------------------------
unsigned int __cdecl sub_805B760(int a1, int a2, size_t nbytes)
{
  size_t v3; // eax
  int v4; // eax
  size_t n; // ST24_4
  int v6; // eax
  size_t v7; // ST28_4
  int v8; // eax
  size_t v9; // ST2C_4
  int v10; // eax
  size_t v11; // ST30_4
  unsigned int result; // eax
  int v13; // eax
  size_t v14; // ST34_4
  unsigned int v15; // [esp+18h] [ebp-30h]
  int fd; // [esp+20h] [ebp-28h]
  struct timeval tv; // [esp+38h] [ebp-10h]

  v15 = 0;
  fd = open64("/dev/urandom", 0);
  if ( fd >= 0 )
  {
    v3 = a2;
    if ( nbytes <= a2 )
      v3 = nbytes;
    v15 = read(fd, (void *)a1, v3);
    if ( (v15 & 0x80000000) != 0 )
      v15 = 0;
    close(fd);
  }
  if ( v15 < a2 )
  {
    v4 = a2 - v15;
    if ( a2 - v15 > 8 )
      v4 = 8;
    n = v4;
    gettimeofday(&tv, 0);
    memcpy((void *)(a1 + v15), &tv, n);
    v15 += n;
  }
  if ( v15 < a2 )
  {
    v6 = a2 - v15;
    if ( a2 - v15 > 4 )
      v6 = 4;
    v7 = v6;
    tv.tv_sec = getpid();
    memcpy((void *)(a1 + v15), &tv, v7);
    v15 += v7;
  }
  if ( v15 < a2 )
  {
    v8 = a2 - v15;
    if ( a2 - v15 > 4 )
      v8 = 4;
    v9 = v8;
    tv.tv_sec = getppid();
    memcpy((void *)(a1 + v15), &tv, v9);
    v15 += v9;
  }
  if ( v15 < a2 )
  {
    v10 = a2 - v15;
    if ( a2 - v15 > 4 )
      v10 = 4;
    v11 = v10;
    tv.tv_sec = getuid();
    memcpy((void *)(a1 + v15), &tv, v11);
    v15 += v11;
  }
  result = v15;
  if ( v15 < a2 )
  {
    v13 = a2 - v15;
    if ( a2 - v15 > 4 )
      v13 = 4;
    v14 = v13;
    tv.tv_sec = getgid();
    memcpy((void *)(a1 + v15), &tv, v14);
    result = v15 + v14;
  }
  return result;
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);

//----- (0805B97D) --------------------------------------------------------
char *__cdecl sub_805B97D(int a1, size_t n)
{
  char *result; // eax
  size_t v7; // eax
  FILE *stream; // [esp+18h] [ebp-10h]
  char *v9; // [esp+1Ch] [ebp-Ch]

  if ( !n )
    return (char *)sub_805B71B(0, 0);
  stream = 0;
  if ( !a1
    || (stream = sub_806027B(a1, "rb"), _CF = 0, _OF = 0, _ZF = stream == 0, _SF = (signed int)stream < 0, stream) )
  {
    v9 = (char *)sub_805B71B((int)stream, a1);
    if ( stream )
    {
      v7 = 2048;
      if ( n <= 0x800 )
        v7 = n;
      setvbuf(stream, v9 + 12, 0, v7);
    }
    else
    {
      *((_DWORD *)v9 + 3) = 0;
      sub_805B760((int)(v9 + 16), 1024, n);
      sub_805C34D(v9 + 16);
    }
    result = v9;
  }
  else
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 805C34D: using guessed type _DWORD __cdecl sub_805C34D(_DWORD);

//----- (0805BA8A) --------------------------------------------------------
size_t __cdecl sub_805BA8A(int a1, void *ptr, size_t n)
{
  size_t result; // eax
  int *v4; // ebx
  int v5; // eax
  int v10; // eax
  size_t v11; // [esp+18h] [ebp-10h]
  int v12; // [esp+1Ch] [ebp-Ch]

  v11 = fread_unlocked(ptr, 1u, n, *(FILE **)a1);
  v12 = *__errno_location();
  result = v11;
  if ( n != v11 )
  {
    v4 = __errno_location();
    v5 = ferror_unlocked(*(FILE **)a1);
    _CF = 0;
    _OF = 0;
    _ZF = v5 == 0;
    _SF = v5 < 0;
    if ( v5 )
    {
      v10 = v12;
    }
    else
    {
      __asm { pushfw }
      v10 = 0;
      __asm { popfw }
    }
    *v4 = v10;
    (*(void (__cdecl **)(_DWORD))(a1 + 4))(*(_DWORD *)(a1 + 8));
    dword_806A268 = (int)&loc_805BA91;
    result = sub_80612C7();
  }
  return result;
}
// 80612C7: using guessed type int sub_80612C7(void);
// 806A268: using guessed type int dword_806A268;

//----- (0805BB28) --------------------------------------------------------
int __cdecl sub_805BB28(int a1, void *dest, size_t n)
{
  int result; // eax
  size_t i; // [esp+14h] [ebp-14h]
  char *v5; // [esp+18h] [ebp-10h]
  char v6; // [esp+1Ch] [ebp-Ch]

  for ( i = *(_DWORD *)a1; ; i = 1024 )
  {
    v6 = (char)dest;
    if ( n <= i )
      break;
    memcpy(dest, (const void *)(a1 + 1024 - i + 1040), i);
    dest = (char *)dest + i;
    n -= i;
    if ( !((v6 + (_BYTE)i) & 3) )
    {
      v5 = (char *)dest;
      while ( n > 0x3FF )
      {
        sub_805BD53(a1 + 4);
        v5 += 1024;
        n -= 1024;
        if ( !n )
        {
          result = a1;
          *(_DWORD *)a1 = 0;
          return result;
        }
      }
      dest = v5;
    }
    sub_805BD53(a1 + 4);
  }
  memcpy(dest, (const void *)(a1 + 1024 - i + 1040), n);
  result = a1;
  *(_DWORD *)a1 = i - n;
  return result;
}
// 805BD53: using guessed type _DWORD __cdecl sub_805BD53(_DWORD);

//----- (0805BC57) --------------------------------------------------------
size_t __cdecl sub_805BC57(int a1, void *ptr, size_t n)
{
  size_t result; // eax

  if ( *(_DWORD *)a1 )
    result = sub_805BA8A(a1, ptr, n);
  else
    result = sub_805BB28(a1 + 12, ptr, n);
  return result;
}

//----- (0805BC9F) --------------------------------------------------------
int __cdecl sub_805BC9F(void *ptr)
{
  int v5; // ST04_4
  int result; // eax
  int v7; // [esp+8h] [ebp-20h]
  int v8; // [esp+Ch] [ebp-1Ch]
  int v9; // [esp+10h] [ebp-18h]
  int v10; // [esp+14h] [ebp-14h]
  int v11; // [esp+18h] [ebp-10h]
  FILE *stream; // [esp+1Ch] [ebp-Ch]

  stream = *(FILE **)ptr;
  explicit_bzero(ptr);
  free(ptr);
  _CF = 0;
  _OF = 0;
  _ZF = stream == 0;
  _SF = (signed int)stream < 0;
  if ( stream )
  {
    sub_805F079(stream);
    dword_806A248 = (int)&locret_805BCF9;
    sub_80613AB(v5, 2076, v7, v8, v9, v10, v11);
  }
  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}
// 8049DE0: using guessed type int __cdecl explicit_bzero(_DWORD);
// 80613AB: using guessed type int __stdcall sub_80613AB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806A248: using guessed type int dword_806A248;

//----- (0805BCFB) --------------------------------------------------------
int __cdecl sub_805BCFB(int a1)
{
  return a1;
}

//----- (0805BD12) --------------------------------------------------------
int __cdecl sub_805BD12(int a1, __int16 a2)
{
  return *(_DWORD *)((a2 & 0x3FC) + a1);
}

//----- (0805BD53) --------------------------------------------------------
#error "805BDAB: call analysis failed (funcsize=27)"

//----- (0805BDB0) --------------------------------------------------------
#error "805BE05: call analysis failed (funcsize=220)"

//----- (0805C091) --------------------------------------------------------
#error "805C0BB: call analysis failed (funcsize=126)"

//----- (0805C22C) --------------------------------------------------------
#error "805C34A: positive sp value has been found (funcsize=86)"

//----- (0805C34D) --------------------------------------------------------
#error "805C4D7: call analysis failed (funcsize=221)"

//----- (0805C85E) --------------------------------------------------------
signed int __cdecl sub_805C85E(_DWORD *a1)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_805F645((int)(a1 + 3), 0, 0, (int)malloc, (int)free);
  sub_805F645((int)(a1 + 14), 0, 0, (int)malloc, (int)free);
  return sub_805F645((int)(a1 + 25), 0, 0, (int)malloc, (int)free);
}

//----- (0805CA22) --------------------------------------------------------
_DWORD *__cdecl sub_805CA22(_DWORD *a1)
{
  _DWORD *result; // eax
  int src; // [esp+10h] [ebp-38h]
  _DWORD *v3; // [esp+14h] [ebp-34h]
  _DWORD *v4; // [esp+18h] [ebp-30h]
  int v5; // [esp+1Ch] [ebp-2Ch]
  int v6; // [esp+20h] [ebp-28h]
  _DWORD *v7; // [esp+24h] [ebp-24h]
  _DWORD *v8; // [esp+28h] [ebp-20h]
  _DWORD *v9; // [esp+2Ch] [ebp-1Ch]
  _DWORD *v10; // [esp+30h] [ebp-18h]
  _DWORD *v11; // [esp+34h] [ebp-14h]
  size_t n; // [esp+38h] [ebp-10h]
  _DWORD *v13; // [esp+3Ch] [ebp-Ch]

  v3 = a1 + 3;
  src = a1[6] - a1[5] - 1;
  v4 = a1 + 3;
  v5 = a1[5];
  if ( a1[6] == v5 )
    *((_BYTE *)v4 + 40) |= 2u;
  v4[3] = (v4[6] + v4[3]) & ~v4[6];
  if ( v4[3] - v4[1] > (unsigned int)(v4[4] - v4[1]) )
    v4[3] = v4[4];
  v4[2] = v4[3];
  v6 = v5;
  v7 = a1 + 14;
  v8 = a1 + 14;
  if ( (unsigned int)(a1[18] - a1[17]) <= 3 )
    sub_805F6EE((int)v7, 4);
  v9 = v7;
  v10 = (_DWORD *)v7[3];
  *v10 = v6;
  v9[3] += 4;
  v11 = a1 + 25;
  n = 4;
  v13 = a1 + 25;
  if ( (unsigned int)(a1[29] - a1[28]) < 4 )
    sub_805F6EE((int)v11, n);
  memcpy((void *)v11[3], &src, n);
  v11[3] += n;
  result = a1;
  ++*a1;
  return result;
}

//----- (0805CC07) --------------------------------------------------------
bool __cdecl sub_805CC07(FILE *stream, int a2)
{
  int v2; // eax
  bool v3; // zf
  void *v4; // eax
  _BYTE *v5; // eax
  _BYTE *v6; // eax
  int v8; // [esp+0h] [ebp-58h]
  int v9; // [esp+4h] [ebp-54h]
  int v10; // [esp+8h] [ebp-50h]
  int v11; // [esp+Ch] [ebp-4Ch]
  int v12; // [esp+10h] [ebp-48h]
  int v13; // [esp+14h] [ebp-44h]
  int v14; // [esp+18h] [ebp-40h]
  int v15; // [esp+1Ch] [ebp-3Ch]
  int v16; // [esp+20h] [ebp-38h]
  int v17; // [esp+24h] [ebp-34h]
  int v18; // [esp+28h] [ebp-30h]
  int v19; // [esp+2Ch] [ebp-2Ch]
  int v20; // [esp+30h] [ebp-28h]
  _DWORD *v21; // [esp+34h] [ebp-24h]
  int v22; // [esp+38h] [ebp-20h]
  int v23; // [esp+3Ch] [ebp-1Ch]
  int v24; // [esp+40h] [ebp-18h]
  int v25; // [esp+44h] [ebp-14h]
  int v26; // [esp+48h] [ebp-10h]
  int v27; // [esp+4Ch] [ebp-Ch]

  while ( 1 )
  {
    v13 = fgetc(stream);
    if ( v13 == -1 )
      break;
    v26 = a2 + 12;
    v27 = a2 + 12;
    if ( *(_DWORD *)(a2 + 28) == *(_DWORD *)(a2 + 24) )
      sub_805F6EE(v26, 1);
    v6 = *(_BYTE **)(v26 + 12);
    *(_DWORD *)(v26 + 12) = v6 + 1;
    *v6 = v13;
    if ( !v13 )
    {
      sub_805CA22((_DWORD *)a2);
      dword_806A268 = (int)&loc_805CC0D;
      sub_80612C7();
    }
  }
  v14 = a2 + 12;
  v2 = *(_DWORD *)(a2 + 24) - *(_DWORD *)(a2 + 20);
  v15 = v2;
  v3 = v2 == 0;
  v4 = &loc_805CC72;
  if ( v3 )
    v4 = &loc_805CCDC;
  dword_806A248 = (int)v4;
  sub_80613AB(v8, v9, v10, v11, v12, v13, v14);
  v16 = a2 + 12;
  v17 = a2 + 12;
  if ( *(_DWORD *)(a2 + 28) == *(_DWORD *)(a2 + 24) )
    sub_805F6EE(v16, 1);
  v5 = *(_BYTE **)(v16 + 12);
  *(_DWORD *)(v16 + 12) = v5 + 1;
  *v5 = 0;
  sub_805CA22((_DWORD *)a2);
  v18 = a2 + 56;
  v19 = a2 + 56;
  if ( (unsigned int)(*(_DWORD *)(a2 + 72) - *(_DWORD *)(v19 + 12)) <= 3 )
    sub_805F6EE(v18, 4);
  v20 = v18;
  v21 = *(_DWORD **)(v18 + 12);
  *v21 = 0;
  *(_DWORD *)(v20 + 12) += 4;
  v22 = a2 + 56;
  v23 = *(_DWORD *)(a2 + 64);
  if ( *(_DWORD *)(a2 + 68) == v23 )
    *(_BYTE *)(v22 + 40) |= 2u;
  *(_DWORD *)(v22 + 12) = (*(_DWORD *)(v22 + 24) + *(_DWORD *)(v22 + 12)) & ~*(_DWORD *)(v22 + 24);
  if ( *(_DWORD *)(v22 + 12) - *(_DWORD *)(v22 + 4) > (unsigned int)(*(_DWORD *)(v22 + 16) - *(_DWORD *)(v22 + 4)) )
    *(_DWORD *)(v22 + 12) = *(_DWORD *)(v22 + 16);
  *(_DWORD *)(v22 + 8) = *(_DWORD *)(v22 + 12);
  *(_DWORD *)(a2 + 4) = v23;
  v24 = a2 + 100;
  v25 = *(_DWORD *)(a2 + 108);
  if ( *(_DWORD *)(a2 + 112) == v25 )
    *(_BYTE *)(v24 + 40) |= 2u;
  *(_DWORD *)(v24 + 12) = (*(_DWORD *)(v24 + 24) + *(_DWORD *)(v24 + 12)) & ~*(_DWORD *)(v24 + 24);
  if ( *(_DWORD *)(v24 + 12) - *(_DWORD *)(v24 + 4) > (unsigned int)(*(_DWORD *)(v24 + 16) - *(_DWORD *)(v24 + 4)) )
    *(_DWORD *)(v24 + 12) = *(_DWORD *)(v24 + 16);
  *(_DWORD *)(v24 + 8) = *(_DWORD *)(v24 + 12);
  *(_DWORD *)(a2 + 8) = v25;
  return ferror(stream) == 0;
}
// 80612C7: using guessed type int sub_80612C7(void);
// 80613AB: using guessed type int __stdcall sub_80613AB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806A248: using guessed type int dword_806A248;
// 806A268: using guessed type int dword_806A268;

//----- (0805CF75) --------------------------------------------------------
int __cdecl sub_805CF75(int a1, int a2)
{
  int v2; // eax

  v2 = mkostemp64(a1, a2);
  return sub_80601F2(v2, a2);
}
// 8049A10: using guessed type int __cdecl mkostemp64(_DWORD, _DWORD);

//----- (0805CF9E) --------------------------------------------------------
#error "805D0C3: call analysis failed (funcsize=132)"

//----- (0805D121) --------------------------------------------------------
#error "805D189: call analysis failed (funcsize=143)"

//----- (0805D66F) --------------------------------------------------------
int __cdecl sub_805D66F(int a1, int a2, int a3, int a4)
{
  return sub_805D121(a1, a2, a3, a4);
}
// 805D121: using guessed type _DWORD __cdecl sub_805D121(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0805D6A7) --------------------------------------------------------
int __cdecl sub_805D6A7(int fd)
{
  int v1; // ST18_4
  int v2; // ST1C_4

  if ( fd >= 0 && fd <= 2 )
  {
    v1 = sub_8060BDE(fd);
    v2 = *__errno_location();
    close(fd);
    *__errno_location() = v2;
    fd = v1;
  }
  return fd;
}

//----- (0805D6F1) --------------------------------------------------------
int __cdecl sub_805D6F1(FILE *stream, int a2, int a3, int a4, int a5, int a6)
{
  char *v6; // eax
  int v7; // edi
  int v8; // esi
  char *v9; // ebx
  char *v10; // eax
  char *v12; // [esp+8h] [ebp-60h]
  int v13; // [esp+Ch] [ebp-5Ch]
  int v14; // [esp+10h] [ebp-58h]
  int v15; // [esp+14h] [ebp-54h]
  int v16; // [esp+18h] [ebp-50h]
  int v17; // [esp+1Ch] [ebp-4Ch]
  int v18; // [esp+20h] [ebp-48h]
  int v19; // [esp+24h] [ebp-44h]
  int v20; // [esp+28h] [ebp-40h]
  int v21; // [esp+38h] [ebp-30h]
  int v22; // [esp+3Ch] [ebp-2Ch]
  int v23; // [esp+40h] [ebp-28h]
  int v24; // [esp+44h] [ebp-24h]
  int v25; // [esp+48h] [ebp-20h]
  int v26; // [esp+4Ch] [ebp-1Ch]

  if ( a2 )
  {
    v14 = a4;
    fprintf(stream, "%s (%s) %s\n", a2, a3, a4);
  }
  else
  {
    fprintf(stream, "%s %s\n", a3, a4);
  }
  v13 = 2017;
  v12 = gettext("(C)");
  fprintf(stream, "Copyright %s %d Free Software Foundation, Inc.", v12, 2017);
  v6 = gettext(
         "\n"
         "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\n"
         "This is free software: you are free to change and redistribute it.\n"
         "There is NO WARRANTY, to the extent permitted by law.\n"
         "\n");
  fputs_unlocked(v6, stream);
  if ( (unsigned int)a6 <= 9 )
    JUMPOUT(__CS__, *(&off_806426C + a6));
  v7 = *(_DWORD *)(a5 + 32);
  v26 = *(_DWORD *)(a5 + 28);
  v25 = *(_DWORD *)(a5 + 24);
  v24 = *(_DWORD *)(a5 + 20);
  v23 = *(_DWORD *)(a5 + 16);
  v22 = *(_DWORD *)(a5 + 12);
  v21 = *(_DWORD *)(a5 + 8);
  v8 = *(_DWORD *)(a5 + 4);
  v9 = *(char **)a5;
  v10 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
  v20 = v7;
  v19 = v26;
  v18 = v25;
  v17 = v24;
  v16 = v23;
  v15 = v22;
  v14 = v21;
  v13 = v8;
  v12 = v9;
  return fprintf(stream, v10, v9, v8, v21, v22, v23, v24, v25, v26, v7);
}
// 8049BA0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 806426C: using guessed type void *;

//----- (0805DD36) --------------------------------------------------------
int __cdecl sub_805DD36(FILE *stream, int a2, int a3, int a4, int a5)
{
  int *v5; // eax
  unsigned int i; // [esp+24h] [ebp-34h]
  int v8[12]; // [esp+28h] [ebp-30h]

  for ( i = 0; i <= 9; ++i )
  {
    v5 = (int *)a5;
    a5 += 4;
    v8[i] = *v5;
    if ( !v8[i] )
      break;
  }
  return sub_805D6F1(stream, a2, a3, a4, (int)v8, i);
}
// 805DD36: using guessed type int var_30[12];

//----- (0805DDAC) --------------------------------------------------------
int sub_805DDAC(FILE *stream, int a2, int a3, int a4, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a4);
  return sub_805DD36(stream, a2, a3, a4, (int)va);
}

//----- (0805DE5C) --------------------------------------------------------
int __cdecl sub_805DE5C(unsigned int a1, unsigned int a2)
{
  if ( 0x7FFFFFFF / a2 < a1 )
    sub_805E145();
  return sub_805DF6E(a2 * a1);
}

//----- (0805DEC1) --------------------------------------------------------
void *__cdecl sub_805DEC1(void *ptr, int a2, int a3)
{
  unsigned int v4; // [esp+1Ch] [ebp-Ch]

  v4 = *(_DWORD *)a2;
  if ( ptr )
  {
    if ( 0x55555554u / a3 <= v4 )
      sub_805E145();
    v4 += (v4 >> 1) + 1;
  }
  else
  {
    if ( !v4 )
      v4 = (0x40u / a3 == 0) + 0x40u / a3;
    if ( 0x7FFFFFFFu / a3 < v4 )
      sub_805E145();
  }
  *(_DWORD *)a2 = v4;
  return sub_805DFD6(ptr, a3 * v4);
}

//----- (0805DF5B) --------------------------------------------------------
int __cdecl sub_805DF5B(size_t size)
{
  return sub_805DF6E(size);
}

//----- (0805DF6E) --------------------------------------------------------
#error "805DFA3: call analysis failed (funcsize=19)"

//----- (0805DFA8) --------------------------------------------------------
#error "805DFC1: positive sp value has been found (funcsize=9)"

//----- (0805DFD6) --------------------------------------------------------
void *__cdecl sub_805DFD6(void *ptr, size_t size)
{
  void *v2; // eax
  int v3; // edx
  int v4; // ecx
  bool v5; // zf
  void *v6; // eax
  void *ptra; // [esp+20h] [ebp+8h]

  if ( !size && ptr )
  {
    free(ptr);
    dword_806A288 = (int)&locret_805E052;
    sub_80611DA();
  }
  v2 = realloc(ptr, size);
  ptra = v2;
  v5 = v2 == 0;
  v6 = &loc_805E044;
  if ( !v5 )
    v6 = &loc_805E04F;
  dword_806A234 = (int)v6;
  sub_806143E(v4, v3);
  if ( size )
    sub_805E145();
  return ptra;
}
// 806143E: using guessed type int __fastcall sub_806143E(_DWORD, _DWORD);
// 806A234: using guessed type int dword_806A234;
// 806A288: using guessed type int dword_806A288;

//----- (0805E0A0) --------------------------------------------------------
#error "805E0E8: call analysis failed (funcsize=27)"

//----- (0805E0F2) --------------------------------------------------------
#error "805E0F6: positive sp value has been found (funcsize=0)"

//----- (0805E0F7) --------------------------------------------------------
void *__cdecl sub_805E0F7(void *src, size_t n)
{
  void *v2; // eax

  v2 = (void *)sub_805DF6E(n);
  return memcpy(v2, src, n);
}

//----- (0805E145) --------------------------------------------------------
void __noreturn sub_805E145()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (0805E17E) --------------------------------------------------------
void __cdecl sub_805E17E(int errnum, int a2, int a3, int a4, int a5)
{
  char *v5; // eax
  char *v6; // eax
  void *v7; // esi
  void *v8; // ebx
  char *v9; // eax

  v5 = gettext("string comparison failed");
  error(0, errnum, v5);
  v6 = gettext("Set LC_ALL='C' to work around the problem.");
  error(0, 0, v6);
  v7 = sub_805B222(1, 8, a4, a5);
  v8 = sub_805B222(0, 8, a2, a3);
  v9 = gettext("The strings compared were %s and %s.");
  error(status, 0, v9, v8, v7);
}

//----- (0805E2CF) --------------------------------------------------------
int __cdecl sub_805E2CF(void *s1, size_t n, void *s2, int a4)
{
  int v5; // [esp+0h] [ebp-10h]
  int errnum; // [esp+4h] [ebp-Ch]

  v5 = sub_8060A9F(s1, n, s2, a4);
  errnum = *__errno_location();
  if ( errnum )
    sub_805E17E(errnum, (int)s1, n - 1, (int)s2, a4 - 1);
  return v5;
}

//----- (0805E35A) --------------------------------------------------------
int __cdecl sub_805E35A(double a1)
{
  int v1; // eax
  int result; // eax
  int v7; // edx
  int v8; // ecx
  int v9; // [esp+0h] [ebp-38h]
  double v10; // [esp+18h] [ebp-20h]
  struct timespec requested_time; // [esp+28h] [ebp-10h]

  v10 = a1;
  sub_8060077(&v9 - 4, a1);
  while ( 1 )
  {
    *__errno_location() = 0;
    v1 = nanosleep(&requested_time, 0);
    _CF = 0;
    _OF = 0;
    _ZF = v1 == 0;
    _SF = v1 < 0;
    if ( !v1 )
      break;
    if ( *__errno_location() != 4 && *__errno_location() )
    {
      dword_806A234 = (int)&locret_805E3F0;
      sub_806143E(v8, v7);
    }
  }
  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}
// 806143E: using guessed type int __fastcall sub_806143E(_DWORD, _DWORD);
// 806A234: using guessed type int dword_806A234;

//----- (0805E3F2) --------------------------------------------------------
signed int __cdecl sub_805E3F2(unsigned int *a1, signed int a2)
{
  signed int result; // eax

  if ( 0xFFFFFFFF / a2 >= *a1 )
  {
    _CF = (unsigned __int64)(a2 * (signed __int64)(signed int)*a1) >> 32 != 0;
    _OF = (unsigned __int64)(a2 * (signed __int64)(signed int)*a1) >> 32 != 0;
    *a1 *= a2;
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  else
  {
    *a1 = -1;
    result = 1;
  }
  return result;
}

//----- (0805E448) --------------------------------------------------------
int __cdecl sub_805E448(unsigned int *a1, signed int a2, int a3)
{
  int v3; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; i |= sub_805E3F2(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}

//----- (0805E47E) --------------------------------------------------------
int __usercall sub_805E47E@<eax>(int a1@<ebx>, char *nptr, int a3, int base, int a5, char *s)
{
  char **v6; // eax
  int v7; // eax
  bool v8; // zf
  void *v9; // eax
  int result; // eax
  void *v11; // eax
  int v12; // eax
  void *v13; // eax
  int v14; // eax
  signed int v15; // eax
  int v16; // [esp-8h] [ebp-50h]
  int v17; // [esp-4h] [ebp-4Ch]
  int v18; // [esp+0h] [ebp-48h]
  int v19; // [esp+4h] [ebp-44h]
  int v20; // [esp+8h] [ebp-40h]
  int v21; // [esp+Ch] [ebp-3Ch]
  int v22; // [esp+10h] [ebp-38h]
  int v23; // [esp+14h] [ebp-34h]
  int v24; // [esp+18h] [ebp-30h]
  int v25; // [esp+1Ch] [ebp-2Ch]
  char v26; // [esp+20h] [ebp-28h]
  unsigned int v27; // [esp+24h] [ebp-24h]
  int v28; // [esp+28h] [ebp-20h]
  char *v29; // [esp+2Ch] [ebp-1Ch]
  int v30; // [esp+30h] [ebp-18h]
  int v31; // [esp+34h] [ebp-14h]
  int v32; // [esp+38h] [ebp-10h]
  char **endptr; // [esp+3Ch] [ebp-Ch]
  int v34; // [esp+40h] [ebp-8h]
  int v35; // [esp+44h] [ebp-4h]
  int savedregs; // [esp+48h] [ebp+0h]

  v28 = 0;
  if ( base < 0 || base > 36 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoul");
  if ( a3 )
    v6 = (char **)a3;
  else
    v6 = (char **)&v26;
  endptr = v6;
  *__errno_location() = 0;
  v29 = nptr;
  HIBYTE(v25) = *nptr;
  v7 = (*__ctype_b_loc())[HIBYTE(v25)] & 0x2000;
  v8 = v7 == 0;
  v17 = v7;
  v16 = a1;
  v9 = &loc_805E53E;
  if ( !v8 )
    v9 = &loc_805E4EA;
  dword_806A2A8 = (int)v9;
  sub_80610E1(
    v18,
    v19,
    v20,
    v21,
    v22,
    v23,
    v24,
    v25,
    *(_DWORD *)&v26,
    v27,
    v28,
    v29,
    v30,
    v31,
    v32,
    endptr,
    v34,
    v35,
    savedregs);
  if ( HIBYTE(v25) == 45 )
    return 4;
  v27 = strtoul(nptr, endptr, base);
  if ( *endptr == nptr )
  {
    if ( !s )
      return 4;
    v8 = **endptr == 0;
    v17 = (unsigned __int8)**endptr;
    v11 = &loc_805E5AF;
    if ( v8 )
      v11 = &loc_805E5D6;
    dword_806A288 = (int)v11;
    sub_80611DA();
    if ( !strchr(s, **endptr) )
      return 4;
    v27 = 1;
  }
  else if ( *__errno_location() )
  {
    v12 = *__errno_location();
    v8 = v12 == 34;
    v17 = v12;
    v13 = &loc_805E620;
    if ( v8 )
      v13 = &loc_805E63C;
    dword_806A2BC = (int)v13;
    sub_8061057();
    dword_806A20C = (int)&locret_805E942;
    sub_806151E(v18, v19, v20, v21, v22, v23, v24, v25, *(_DWORD *)&v26, v27, v28, v29, v30, v31, v32);
    v28 = 1;
  }
  if ( !s )
  {
    *(_DWORD *)a5 = v27;
    return v28;
  }
  if ( !**endptr )
  {
LABEL_53:
    *(_DWORD *)a5 = v27;
    return v28;
  }
  v30 = 1024;
  v31 = 1;
  v19 = **endptr;
  if ( !strchr(s, v19) )
  {
    *(_DWORD *)a5 = v27;
    return v28 | 2;
  }
  switch ( **endptr )
  {
    case 69:
    case 71:
    case 75:
    case 77:
    case 80:
    case 84:
    case 89:
    case 90:
    case 103:
    case 107:
    case 109:
    case 116:
      if ( !strchr(s, 48) )
        goto LABEL_37;
      v14 = (*endptr)[1];
      switch ( v14 )
      {
        case 68:
          goto LABEL_36;
        case 105:
          if ( (*endptr)[2] == 66 )
          {
            v31 += 2;
            dword_806A288 = (int)&loc_805E74A;
            sub_80611DA();
          }
          dword_806A220 = (int)&loc_805E74A;
          sub_80614AE(v18, v19, v20, v21, v22, v23, v24, v25, *(_DWORD *)&v26, v27, v28, v29);
          goto LABEL_36;
        case 66:
LABEL_36:
          v30 = 1000;
          ++v31;
          break;
      }
LABEL_37:
      switch ( **endptr )
      {
        case 66:
          goto LABEL_39;
        case 69:
          v32 = sub_805E448(&v27, v30, 6);
          goto LABEL_51;
        case 71:
        case 103:
          v32 = sub_805E448(&v27, v30, 3);
          goto LABEL_51;
        case 75:
        case 107:
          v32 = sub_805E448(&v27, v30, 1);
          goto LABEL_51;
        case 77:
        case 109:
          v32 = sub_805E448(&v27, v30, 2);
          goto LABEL_51;
        case 80:
          v32 = sub_805E448(&v27, v30, 5);
          goto LABEL_51;
        case 84:
        case 116:
          v32 = sub_805E448(&v27, v30, 4);
          dword_806A248 = (int)&loc_805E902;
          sub_80613AB(v18, v19, v20, v21, v22, v23, v24);
          goto LABEL_47;
        case 89:
          v32 = sub_805E448(&v27, v30, 8);
          goto LABEL_51;
        case 90:
          v32 = sub_805E448(&v27, v30, 7);
          goto LABEL_51;
        case 98:
          v15 = sub_805E3F2(&v27, 512);
          dword_806A2A8 = (int)&loc_805E902;
          sub_80610E1(
            v18,
            v19,
            v20,
            v21,
            v22,
            v23,
            v24,
            v25,
            *(_DWORD *)&v26,
            v27,
            v28,
            v29,
            v30,
            v31,
            v15,
            endptr,
            v34,
            v35,
            savedregs);
LABEL_39:
          v32 = sub_805E3F2(&v27, 1024);
          goto LABEL_51;
        case 99:
          v32 = 0;
          goto LABEL_51;
        case 119:
LABEL_47:
          v32 = sub_805E3F2(&v27, 2);
LABEL_51:
          v28 |= v32;
          *endptr += v31;
          if ( **endptr )
            v28 |= 2u;
          goto LABEL_53;
        default:
          *(_DWORD *)a5 = v27;
          result = v28 | 2;
          break;
      }
      return result;
    default:
      goto LABEL_37;
  }
}
// 805E47E: could not find valid save-restore pair for ebx
// 8061057: using guessed type int sub_8061057(void);
// 80610E1: using guessed type int __stdcall sub_80610E1(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80613AB: using guessed type int __stdcall sub_80613AB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80614AE: using guessed type int __stdcall sub_80614AE(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806151E: using guessed type int __stdcall sub_806151E(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806A20C: using guessed type int dword_806A20C;
// 806A220: using guessed type int dword_806A220;
// 806A248: using guessed type int dword_806A248;
// 806A288: using guessed type int dword_806A288;
// 806A2A8: using guessed type int dword_806A2A8;
// 806A2BC: using guessed type int dword_806A2BC;

//----- (0805E944) --------------------------------------------------------
void __cdecl sub_805E944(int a1, int a2, int a3, int a4, int a5, int status)
{
  void *v6; // eax
  char *v7; // eax
  const char *v8; // [esp+Ch] [ebp-2Ch]
  char *v9; // [esp+10h] [ebp-28h]
  int v10; // [esp+14h] [ebp-24h]
  char v11; // [esp+1Ch] [ebp-1Ch]
  char v12; // [esp+22h] [ebp-16h]
  char v13; // [esp+23h] [ebp-15h]
  const char *v14; // [esp+24h] [ebp-14h]
  char *msgid; // [esp+28h] [ebp-10h]
  char *v16; // [esp+2Ch] [ebp-Ch]

  v11 = a3;
  v14 = "--";
  if ( (unsigned int)a1 > 3 )
  {
    if ( a1 != 4 )
      goto LABEL_7;
    msgid = "invalid %s%s argument '%s'";
  }
  else
  {
    if ( (unsigned int)a1 < 2 )
    {
      v6 = &loc_805E982;
      if ( a1 == 1 )
        v6 = &loc_805E9A0;
      dword_806A268 = (int)v6;
      sub_80612C7();
LABEL_7:
      abort();
    }
    msgid = "invalid suffix in %s%s argument '%s'";
  }
  if ( a2 >= 0 )
  {
    v16 = *(char **)(16 * a2 + a4);
  }
  else
  {
    v14 -= a2;
    v12 = v11;
    v13 = 0;
    v16 = &v12;
  }
  v7 = gettext(msgid);
  v10 = a5;
  v9 = v16;
  v8 = v14;
  error(status, 0, v7, v14, v16, a5);
}
// 80612C7: using guessed type int sub_80612C7(void);
// 806A268: using guessed type int dword_806A268;

//----- (0805EA23) --------------------------------------------------------
void __cdecl __noreturn sub_805EA23(int a1, int a2, char a3, int a4, int a5)
{
  sub_805E944(a1, a2, a3, a4, a5, status);
  abort();
}

//----- (0805EA7B) --------------------------------------------------------
#error "805EAAD: call analysis failed (funcsize=79)"

//----- (0805EB87) --------------------------------------------------------
int __cdecl sub_805EB87(unsigned int *a1, signed int a2, int a3)
{
  int v3; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; ; i |= sub_80609ED(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}

//----- (0805EBBD) --------------------------------------------------------
int __cdecl sub_805EBBD(char *nptr, int a2, int base, int a4, char *s)
{
  bool v5; // zf
  void *v6; // eax
  int result; // eax
  void *v8; // eax
  int v9; // edx
  int v10; // ecx
  int v11; // edx
  int v12; // eax
  signed int v13; // eax
  int v14; // ST08_4
  int v15; // ST0C_4
  int v16; // edx
  int v17; // edx
  void *v18; // eax
  int v19; // edx
  int v20; // [esp+0h] [ebp-48h]
  int v21; // [esp+0h] [ebp-48h]
  int v22; // [esp+4h] [ebp-44h]
  int v23; // [esp+4h] [ebp-44h]
  int v24; // [esp+8h] [ebp-40h]
  int v25; // [esp+8h] [ebp-40h]
  int v26; // [esp+Ch] [ebp-3Ch]
  int v27; // [esp+Ch] [ebp-3Ch]
  int v28; // [esp+10h] [ebp-38h]
  int v29; // [esp+10h] [ebp-38h]
  int v30; // [esp+14h] [ebp-34h]
  int v31; // [esp+14h] [ebp-34h]
  int v32; // [esp+18h] [ebp-30h]
  int v33; // [esp+18h] [ebp-30h]
  int v34; // [esp+1Ch] [ebp-2Ch]
  int v35; // [esp+20h] [ebp-28h]
  int v36; // [esp+20h] [ebp-28h]
  int v37; // [esp+24h] [ebp-24h]
  char *v38; // [esp+24h] [ebp-24h]
  int v39; // [esp+28h] [ebp-20h]
  signed int v40; // [esp+28h] [ebp-20h]
  int v41; // [esp+2Ch] [ebp-1Ch]
  signed int v42; // [esp+2Ch] [ebp-1Ch]
  signed int v43; // [esp+30h] [ebp-18h]
  char **endptr; // [esp+34h] [ebp-14h]
  uintmax_t v45; // [esp+38h] [ebp-10h]

  v35 = 0;
  if ( base < 0 || base > 36 )
LABEL_5:
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoumax");
  if ( !a2 )
  {
    dword_806A220 = (int)&loc_805EC17;
    sub_80614AE(v20, v22, v24, v26, v28, v30, v32, v34, 0, v37, v39, v41);
    goto LABEL_5;
  }
  endptr = (char **)a2;
  *__errno_location() = 0;
  v38 = nptr;
  HIBYTE(v32) = *nptr;
  v5 = ((*__ctype_b_loc())[HIBYTE(v32)] & 0x2000) == 0;
  v6 = &loc_805EC82;
  if ( !v5 )
    v6 = &loc_805EC3E;
  dword_806A248 = (int)v6;
  sub_80613AB(v20, v22, v24, v26, v28, v30, v32);
  if ( HIBYTE(v33) == 45 )
    return 4;
  v45 = strtoumax(nptr, (char **)a2, base);
  v8 = &loc_805ECE4;
  if ( *(char **)a2 != nptr )
    v8 = &loc_805ED2E;
  dword_806A288 = (int)v8;
  sub_80611DA();
  if ( !s || !**(_BYTE **)a2 || !strchr(s, **(char **)a2) )
    return 4;
  v45 = 1LL;
  if ( !s )
  {
    v9 = HIDWORD(v45);
    *(_DWORD *)a4 = v45;
    *(_DWORD *)(a4 + 4) = v9;
    return 0;
  }
  if ( !**(_BYTE **)a2 )
  {
LABEL_49:
    v19 = HIDWORD(v45);
    *(_DWORD *)a4 = v45;
    *(_DWORD *)(a4 + 4) = v19;
    return v35;
  }
  v40 = 1024;
  v42 = 1;
  if ( !strchr(s, **(char **)a2) )
  {
    v11 = HIDWORD(v45);
    *(_DWORD *)a4 = v45;
    *(_DWORD *)(a4 + 4) = v11;
    return 2;
  }
  switch ( **(char **)a2 )
  {
    case 69:
    case 71:
    case 75:
    case 77:
    case 80:
    case 84:
    case 89:
    case 90:
    case 103:
    case 107:
    case 109:
    case 116:
      if ( !strchr(s, 48) )
        break;
      v12 = *(char *)(*(_DWORD *)a2 + 1);
      if ( v12 == 68 )
        goto LABEL_31;
      if ( v12 == 105 )
        goto LABEL_28;
      if ( v12 != 66 )
      {
        dword_806A220 = (int)&loc_805EE69;
        sub_80614AE(v21, v23, v25, v27, v29, v31, v33, v34, 0, nptr, 1024, 1);
LABEL_28:
        if ( *(_BYTE *)(*(_DWORD *)a2 + 2) == 66 )
          v42 += 2;
        break;
      }
LABEL_31:
      v40 = 1000;
      v42 = 2;
      break;
    default:
      break;
  }
  switch ( **(char **)a2 )
  {
    case 66:
      v43 = sub_80609ED((unsigned int *)&v45, 1024);
      goto LABEL_46;
    case 69:
      v43 = sub_805EB87((unsigned int *)&v45, v40, 6);
      goto LABEL_46;
    case 71:
    case 103:
      v43 = sub_805EB87((unsigned int *)&v45, v40, 3);
      goto LABEL_46;
    case 75:
    case 107:
      v43 = sub_805EB87((unsigned int *)&v45, v40, 1);
      goto LABEL_46;
    case 77:
    case 109:
      v43 = sub_805EB87((unsigned int *)&v45, v40, 2);
      goto LABEL_46;
    case 80:
      v43 = sub_805EB87((unsigned int *)&v45, v40, 5);
      goto LABEL_46;
    case 84:
    case 116:
      v43 = sub_805EB87((unsigned int *)&v45, v40, 4);
      goto LABEL_46;
    case 89:
      goto LABEL_43;
    case 90:
      v43 = sub_805EB87((unsigned int *)&v45, v40, 7);
      goto LABEL_46;
    case 98:
      v43 = sub_80609ED((unsigned int *)&v45, 512);
      goto LABEL_46;
    case 99:
      v43 = 0;
      goto LABEL_46;
    case 119:
      v13 = sub_80609ED((unsigned int *)&v45, 2);
      dword_806A20C = (int)&loc_805F018;
      sub_806151E(v14, v15, v25, v27, v29, v31, v33, v34, v35, v38, v40, v42, v13, a2, v45);
LABEL_43:
      v43 = sub_805EB87((unsigned int *)&v45, v40, 8);
LABEL_46:
      v36 = v43 | v35;
      v17 = (int)&(*endptr)[v42];
      *endptr = (char *)v17;
      v18 = &loc_805F062;
      if ( !**endptr )
        v18 = &loc_805F066;
      dword_806A234 = (int)v18;
      sub_806143E(v10, v17);
      v35 = v36 | 2;
      goto LABEL_49;
    default:
      v16 = HIDWORD(v45);
      *(_DWORD *)a4 = v45;
      *(_DWORD *)(a4 + 4) = v16;
      result = v35 | 2;
      break;
  }
  return result;
}
// 805EBBD: could not find valid save-restore pair for ebx
// 80613AB: using guessed type int __stdcall sub_80613AB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806143E: using guessed type int __fastcall sub_806143E(_DWORD, _DWORD);
// 80614AE: using guessed type int __stdcall sub_80614AE(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806151E: using guessed type int __stdcall sub_806151E(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806A20C: using guessed type int dword_806A20C;
// 806A220: using guessed type int dword_806A220;
// 806A234: using guessed type int dword_806A234;
// 806A248: using guessed type int dword_806A248;
// 806A288: using guessed type int dword_806A288;

//----- (0805F079) --------------------------------------------------------
int __cdecl sub_805F079(FILE *stream)
{
  int v2; // eax
  __int64 v3; // rax
  int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]

  v4 = 0;
  if ( fileno(stream) < 0 )
    return fclose(stream);
  if ( !__freading(stream) || (v2 = fileno(stream), LODWORD(v3) = lseek64(v2, 0, 0, 1), v3 != -1) )
  {
    if ( sub_805F2EF(stream) )
      v4 = *__errno_location();
  }
  v5 = fclose(stream);
  if ( v4 )
  {
    *__errno_location() = v4;
    v5 = -1;
  }
  return v5;
}
// 8049A90: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0805F13C) --------------------------------------------------------
int __cdecl sub_805F13C(int fd, int cmd, char a3)
{
  char *v3; // eax
  int *v4; // eax
  int v6; // [esp+8h] [ebp-30h]
  char *v7; // [esp+18h] [ebp-20h]
  int v8; // [esp+1Ch] [ebp-1Ch]
  char v9[4]; // [esp+20h] [ebp-18h]
  int v10; // [esp+24h] [ebp-14h]
  int v11; // [esp+28h] [ebp-10h]
  int v12; // [esp+2Ch] [ebp-Ch]

  v8 = -1;
  v7 = &a3;
  if ( cmd != 1030 )
  {
    v4 = (int *)v7;
    v7 += 4;
    v12 = *v4;
    v6 = v12;
    return fcntl(fd, cmd, v12);
  }
  v3 = v7;
  v7 += 4;
  *(_DWORD *)v9 = *(_DWORD *)v3;
  if ( dword_806B07C < 0 )
  {
    v8 = sub_805F13C(fd, 0, v9[0]);
  }
  else
  {
    v6 = *(_DWORD *)v9;
    v8 = fcntl(fd, 1030, *(_DWORD *)v9);
    if ( v8 < 0 && *__errno_location() == 22 )
    {
      v8 = sub_805F13C(fd, 0, v9[0]);
      if ( v8 < 0 )
        return v8;
      dword_806B07C = -1;
    }
    else
    {
      dword_806B07C = 1;
    }
  }
  if ( v8 >= 0 && dword_806B07C == -1 )
  {
    v10 = fcntl(v8, 1);
    if ( v10 < 0 || (v6 = v10 | 1, fcntl(v8, 2, v10 | 1) == -1) )
    {
      v11 = *__errno_location();
      close(v8);
      *__errno_location() = v11;
      v8 = -1;
    }
  }
  return v8;
}
// 806B07C: using guessed type int dword_806B07C;

//----- (0805F2B6) --------------------------------------------------------
int __cdecl sub_805F2B6(FILE *stream)
{
  int result; // eax

  result = stream->_flags & 0x100;
  if ( result )
    result = sub_805F32F(stream, 0, 0, 1);
  return result;
}

//----- (0805F2EF) --------------------------------------------------------
int __cdecl sub_805F2EF(FILE *fp)
{
  if ( !fp || !__freading(fp) )
    return fflush(fp);
  sub_805F2B6(fp);
  return fflush(fp);
}

//----- (0805F32F) --------------------------------------------------------
int __cdecl sub_805F32F(FILE *stream, int a2, int a3, int a4)
{
  int v4; // eax
  __int64 v5; // rax
  bool v6; // zf
  void *v7; // eax
  int v9; // [esp+0h] [ebp-38h]
  int v10; // [esp+4h] [ebp-34h]
  int v11; // [esp+8h] [ebp-30h]
  int v12; // [esp+Ch] [ebp-2Ch]
  int v13; // [esp+10h] [ebp-28h]
  int v14; // [esp+14h] [ebp-24h]
  int v15; // [esp+20h] [ebp-18h]
  int v16; // [esp+24h] [ebp-14h]
  __int64 v17; // [esp+28h] [ebp-10h]
  int v18; // [esp+30h] [ebp-8h]
  int v19; // [esp+34h] [ebp-4h]
  int savedregs; // [esp+38h] [ebp+0h]

  if ( stream->_IO_read_end != stream->_IO_read_ptr
    || stream->_IO_write_ptr != stream->_IO_write_base
    || stream->_IO_save_base )
  {
    return fseeko64(stream, a2, a3, a4);
  }
  v4 = fileno(stream);
  LODWORD(v5) = lseek64(v4, a2, a3, a4);
  v17 = v5;
  v6 = v5 == -1;
  v7 = &loc_805F3E4;
  if ( !v6 )
    v7 = &loc_805F3EB;
  dword_806A20C = (int)v7;
  sub_806151E(v9, v10, v11, v12, v13, v14, a2, a3, v15, v16, v17, HIDWORD(v17), v18, v19, savedregs);
  return -1;
}
// 80498B0: using guessed type int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8049A90: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 806151E: using guessed type int __stdcall sub_806151E(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806A20C: using guessed type int dword_806A20C;

//----- (0805F443) --------------------------------------------------------
#error "805F4BC: call analysis failed (funcsize=42)"

//----- (0805F4CA) --------------------------------------------------------
int __cdecl sub_805F4CA(int a1, int a2)
{
  int result; // eax

  if ( *(_BYTE *)(a1 + 40) & 1 )
    result = (*(int (__cdecl **)(_DWORD, int))(a1 + 28))(*(_DWORD *)(a1 + 36), a2);
  else
    result = (*(int (__cdecl **)(int))(a1 + 28))(a2);
  return result;
}

//----- (0805F508) --------------------------------------------------------
int __cdecl sub_805F508(int a1, int a2)
{
  int result; // eax

  if ( *(_BYTE *)(a1 + 40) & 1 )
    result = (*(int (__cdecl **)(_DWORD, int))(a1 + 32))(*(_DWORD *)(a1 + 36), a2);
  else
    result = (*(int (__cdecl **)(int))(a1 + 32))(a2);
  return result;
}

//----- (0805F546) --------------------------------------------------------
signed int __cdecl sub_805F546(int a1, signed int a2, signed int a3)
{
  int v4; // [esp+4h] [ebp-24h]
  int v5; // [esp+18h] [ebp-10h]
  _DWORD *v6; // [esp+1Ch] [ebp-Ch]

  if ( !a3 )
    a3 = 8;
  if ( !a2 )
  {
    v5 = 32;
    a2 = 4064;
  }
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 24) = a3 - 1;
  v4 = *(_DWORD *)a1;
  *(_DWORD *)(a1 + 4) = sub_805F4CA(a1, v4);
  v6 = *(_DWORD **)(a1 + 4);
  if ( !v6 )
    obstack_alloc_failed_handler();
  *(_DWORD *)(a1 + 8) = ((unsigned int)&v6[a3 / 4u + 1] + 3) & -a3;
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 8);
  *v6 = (char *)v6 + *(_DWORD *)a1;
  *(_DWORD *)(a1 + 16) = *v6;
  v6[1] = 0;
  *(_BYTE *)(a1 + 40) &= 0xFDu;
  *(_BYTE *)(a1 + 40) &= 0xFBu;
  return 1;
}
// 806A480: using guessed type int (*obstack_alloc_failed_handler)(void);

//----- (0805F645) --------------------------------------------------------
signed int __cdecl sub_805F645(int a1, signed int a2, signed int a3, int a4, int a5)
{
  *(_DWORD *)(a1 + 28) = a4;
  *(_DWORD *)(a1 + 32) = a5;
  *(_BYTE *)(a1 + 40) &= 0xFEu;
  return sub_805F546(a1, a2, a3);
}

//----- (0805F6EE) --------------------------------------------------------
int __cdecl sub_805F6EE(int a1, int a2)
{
  void *v2; // eax
  int result; // eax
  _DWORD *v4; // [esp+14h] [ebp-24h]
  unsigned int v5; // [esp+18h] [ebp-20h]
  int v6; // [esp+1Ch] [ebp-1Ch]
  size_t n; // [esp+20h] [ebp-18h]
  size_t v8; // [esp+24h] [ebp-14h]
  size_t v9; // [esp+28h] [ebp-10h]
  void *dest; // [esp+2Ch] [ebp-Ch]

  v6 = *(_DWORD *)(a1 + 4);
  v4 = 0;
  n = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 8);
  v8 = n + a2;
  v9 = *(_DWORD *)(a1 + 24) + n + a2;
  v5 = (n >> 3) + v9 + 100;
  if ( v5 < v9 )
    v5 = v9;
  if ( *(_DWORD *)a1 > v5 )
    v5 = *(_DWORD *)a1;
  if ( n <= v8 && v8 <= v9 )
    v4 = (_DWORD *)sub_805F4CA(a1, v5);
  if ( !v4 )
    obstack_alloc_failed_handler();
  *(_DWORD *)(a1 + 4) = v4;
  v4[1] = v6;
  *(_DWORD *)(a1 + 16) = (char *)v4 + v5;
  *v4 = *(_DWORD *)(a1 + 16);
  dest = (void *)(((unsigned int)v4 + *(_DWORD *)(a1 + 24) + 8) & ~*(_DWORD *)(a1 + 24));
  memcpy(dest, *(const void **)(a1 + 8), n);
  if ( !(*(_BYTE *)(a1 + 40) & 2) )
  {
    v2 = &loc_805F876;
    if ( *(_DWORD *)(a1 + 8) != ((*(_DWORD *)(a1 + 24) + v6 + 8) & ~*(_DWORD *)(a1 + 24)) )
      v2 = &loc_805F894;
    dword_806A288 = (int)v2;
    sub_80611DA();
    v4[1] = *(_DWORD *)(v6 + 4);
    sub_805F508(a1, v6);
  }
  *(_DWORD *)(a1 + 8) = dest;
  *(_DWORD *)(a1 + 12) = n + *(_DWORD *)(a1 + 8);
  result = a1;
  *(_BYTE *)(a1 + 40) &= 0xFDu;
  return result;
}
// 806A288: using guessed type int dword_806A288;
// 806A480: using guessed type int (*obstack_alloc_failed_handler)(void);

//----- (0805F911) --------------------------------------------------------
int __cdecl sub_805F911(int a1, unsigned int a2)
{
  int result; // eax
  int *v3; // [esp+18h] [ebp-10h]
  int *v4; // [esp+1Ch] [ebp-Ch]

  result = *(_DWORD *)(a1 + 4);
  v3 = *(int **)(a1 + 4);
  while ( v3 )
  {
    if ( (unsigned int)v3 < a2 )
    {
      result = *v3;
      if ( *v3 >= a2 )
        break;
    }
    v4 = (int *)v3[1];
    sub_805F508(a1, (int)v3);
    v3 = v4;
    result = a1;
    *(_BYTE *)(a1 + 40) |= 2u;
  }
  if ( v3 )
  {
    *(_DWORD *)(a1 + 12) = a2;
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 16) = *v3;
    *(_DWORD *)(a1 + 4) = v3;
    dword_806A268 = (int)&locret_805F9C9;
    result = sub_80612C7();
  }
  if ( a2 )
    abort();
  return result;
}
// 80612C7: using guessed type int sub_80612C7(void);
// 806A268: using guessed type int dword_806A268;

//----- (0805FB8C) --------------------------------------------------------
int __cdecl sub_805FB8C(int a1, char a2)
{
  return __ROR4__(a1, a2);
}

//----- (0805FCB7) --------------------------------------------------------
#error "805FD04: call analysis failed (funcsize=37)"

//----- (0805FD2A) --------------------------------------------------------
signed int __cdecl sub_805FD2A(signed int a1)
{
  signed int result; // eax

  _CF = (unsigned int)a1 < 0x41;
  _OF = __OFSUB__(a1, 65);
  _ZF = a1 == 65;
  _SF = a1 - 65 < 0;
  if ( a1 >= 65 )
  {
    if ( a1 <= 90 )
      return 1;
    _CF = (unsigned int)(a1 - 97) < 0x19;
    _OF = __OFSUB__(a1 - 97, 25);
    _ZF = a1 == 122;
    _SF = a1 - 122 < 0;
    if ( (unsigned int)(a1 - 97) <= 0x19 )
      return 1;
  }
  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}

//----- (0805FDB2) --------------------------------------------------------
signed int __cdecl sub_805FDB2(int a1)
{
  signed int result; // eax

  _CF = (unsigned int)(a1 - 48) < 9;
  _OF = __OFSUB__(a1 - 48, 9);
  _ZF = a1 == 57;
  _SF = a1 - 57 < 0;
  if ( (unsigned int)(a1 - 48) <= 9 )
    return 1;
  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}

//----- (0805FE76) --------------------------------------------------------
signed int __cdecl sub_805FE76(signed int a1)
{
  void *v1; // eax
  int v2; // eax
  signed int result; // eax

  v1 = &loc_805FEAA;
  if ( a1 < 9 )
    v1 = &loc_805FEBB;
  dword_806A2BC = (int)v1;
  v2 = sub_8061057();
  if ( v2 <= 13 )
    return 1;
  _CF = (unsigned int)v2 < 0x20;
  _OF = __OFSUB__(v2, 32);
  _ZF = v2 == 32;
  _SF = v2 - 32 < 0;
  if ( v2 == 32 )
    return 1;
  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}
// 8061057: using guessed type int sub_8061057(void);
// 806A2BC: using guessed type int dword_806A2BC;

//----- (0805FF1B) --------------------------------------------------------
int __cdecl sub_805FF1B(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 65) > 0x19 )
    result = a1;
  else
    result = a1 + 32;
  return result;
}

//----- (0805FF51) --------------------------------------------------------
int __cdecl sub_805FF51(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // esi
  unsigned __int8 *v3; // ebx
  int result; // eax
  int v9; // [esp+0h] [ebp-28h]
  unsigned __int8 v10; // [esp+1Eh] [ebp-Ah]
  unsigned __int8 v11; // [esp+1Fh] [ebp-9h]

  v2 = a1;
  v3 = a2;
  _CF = a1 < a2;
  _OF = __OFSUB__(a1, a2);
  _ZF = a1 == a2;
  _SF = a1 - a2 < 0;
  if ( a1 == a2 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  else
  {
    do
    {
      v9 = *v2;
      v10 = sub_805FF1B(v9);
      v9 = *v3;
      v11 = sub_805FF1B(v9);
      if ( !v10 )
      {
        dword_806A2BC = (int)&loc_805FFB9;
        sub_8061057();
      }
      ++v2;
      ++v3;
    }
    while ( v10 == v11 );
    result = v10 - v11;
  }
  return result;
}
// 8061057: using guessed type int sub_8061057(void);
// 806A2BC: using guessed type int dword_806A2BC;

//----- (0805FFCC) --------------------------------------------------------
int __cdecl sub_805FFCC(FILE *fp)
{
  int v1; // eax
  void *v2; // eax
  unsigned int v7; // eax
  int result; // eax
  int v9; // [esp-4h] [ebp-2Ch]
  bool v10; // [esp+1Dh] [ebp-Bh]
  bool v11; // [esp+1Eh] [ebp-Ah]
  char v12; // [esp+1Fh] [ebp-9h]

  v10 = __fpending(fp) != 0;
  v11 = ferror_unlocked(fp) != 0;
  v1 = sub_805F079(fp);
  LOBYTE(v1) = v1 != 0;
  v12 = v1;
  v9 = v1;
  v2 = &loc_806003A;
  if ( v11 )
    v2 = &loc_8060052;
  dword_806A268 = (int)v2;
  sub_80612C7();
  _CF = 0;
  _OF = 0;
  _ZF = v12 == 0;
  _SF = v12 < 0;
  if ( v12
    && (v10
     || (v7 = *__errno_location(),
         _CF = v7 < 9,
         _OF = __OFSUB__(v7, 9),
         _ZF = v7 == 9,
         _SF = (signed int)(v7 - 9) < 0,
         v7 != 9)) )
  {
    if ( v12 != 1 )
      *__errno_location() = 0;
    result = -1;
  }
  else
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 80612C7: using guessed type int sub_80612C7(void);
// 806A268: using guessed type int dword_806A268;

//----- (08060077) --------------------------------------------------------
_DWORD *__userpurge sub_8060077@<eax>(_DWORD *a1, double a2)
{
  int v2; // ST00_4
  int v3; // ST04_4
  int v4; // ST08_4
  signed int v5; // ST20_4
  double v6; // ST28_8
  int v7; // ST24_4
  int v9; // [esp+Ch] [ebp-2Ch]
  int v10; // [esp+10h] [ebp-28h]
  int v11; // [esp+14h] [ebp-24h]
  double v12; // [esp+18h] [ebp-20h]
  int v13; // [esp+20h] [ebp-18h]
  int v14; // [esp+20h] [ebp-18h]
  int v15; // [esp+24h] [ebp-14h]
  int v16; // [esp+24h] [ebp-14h]
  int v17; // [esp+28h] [ebp-10h]
  int v18; // [esp+2Ch] [ebp-Ch]

  v12 = a2;
  if ( a2 <= -2147483648.0 )
  {
    sub_8060AFF(a1, 2147483648, 0);
  }
  else
  {
    if ( 2147483648.0 <= a2 )
    {
      sub_8060AFF(a1, 0x7FFFFFFF, 999999999);
      dword_806A220 = (int)&loc_80601EB;
      sub_80614AE(v2, v3, v4, v9, v10, v11, LODWORD(a2), HIDWORD(a2), v13, v15, v17, v18);
    }
    v5 = (signed int)v12;
    v6 = (v12 - (long double)v5) * 1000000000.0;
    v7 = (v6 > (long double)(signed int)v6) + (signed int)v6;
    v14 = v7 / 1000000000 + v5;
    v16 = v7 % 1000000000;
    if ( v16 < 0 )
    {
      --v14;
      v16 += 1000000000;
    }
    sub_8060AFF(a1, v14, v16);
  }
  return a1;
}
// 80614AE: using guessed type int __stdcall sub_80614AE(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806A220: using guessed type int dword_806A220;

//----- (080601F2) --------------------------------------------------------
int __cdecl sub_80601F2(int fd, int a2)
{
  int v2; // ST18_4
  int v3; // ST1C_4

  if ( fd >= 0 && fd <= 2 )
  {
    v2 = sub_8060243(fd, a2);
    v3 = *__errno_location();
    close(fd);
    *__errno_location() = v3;
    fd = v2;
  }
  return fd;
}

//----- (08060243) --------------------------------------------------------
int __cdecl sub_8060243(int fd, int a2)
{
  int v6; // eax

  _CF = 0;
  _OF = 0;
  _ZF = (a2 & 0x80000) == 0;
  _SF = (a2 & 0x80000) < 0;
  if ( a2 & 0x80000 )
  {
    v6 = 1030;
  }
  else
  {
    __asm { pushfw }
    v6 = 0;
    __asm { popfw }
  }
  return sub_805F13C(fd, v6, 3);
}

//----- (0806027B) --------------------------------------------------------
FILE *__cdecl sub_806027B(int a1, char *modes)
{
  int v2; // ST2C_4
  FILE *result; // eax
  int v8; // ST30_4
  FILE *stream; // [esp+1Ch] [ebp-1Ch]
  signed int v10; // [esp+20h] [ebp-18h]
  int fd; // [esp+24h] [ebp-14h]

  stream = (FILE *)fopen64(a1, modes);
  if ( !stream )
    return stream;
  v10 = fileno(stream);
  if ( v10 < 0 || v10 > 2 )
    return stream;
  fd = sub_8060BDE(v10);
  if ( fd < 0 )
  {
    v2 = *__errno_location();
    sub_805F079(stream);
    *__errno_location() = v2;
    __asm { pushfw }
    result = 0;
    __asm { popfw }
    return result;
  }
  if ( !sub_805F079(stream) )
  {
    stream = fdopen(fd, modes);
    if ( stream )
      return stream;
  }
  v8 = *__errno_location();
  close(fd);
  *__errno_location() = v8;
  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}
// 80499F0: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (08060353) --------------------------------------------------------
void *__usercall sub_8060353@<eax>(int a1@<ebx>)
{
  void *v1; // eax
  char v6; // al
  signed int v7; // eax
  int v8; // eax
  int v10; // [esp-8h] [ebp-D0h]
  int v11; // [esp-4h] [ebp-CCh]
  size_t v12; // [esp+0h] [ebp-C8h]
  char *v13; // [esp+8h] [ebp-C0h]
  char *v14; // [esp+Ch] [ebp-BCh]
  void *ptr; // [esp+14h] [ebp-B4h]
  void *v16; // [esp+18h] [ebp-B0h]
  char *s; // [esp+1Ch] [ebp-ACh]
  void *v18; // [esp+20h] [ebp-A8h]
  int v19; // [esp+24h] [ebp-A4h]
  char *v20; // [esp+28h] [ebp-A0h]
  size_t n; // [esp+2Ch] [ebp-9Ch]
  size_t v22; // [esp+30h] [ebp-98h]
  int v23; // [esp+34h] [ebp-94h]
  void *dest; // [esp+38h] [ebp-90h]
  int fd; // [esp+3Ch] [ebp-8Ch]
  FILE *stream; // [esp+40h] [ebp-88h]
  int c; // [esp+44h] [ebp-84h]
  size_t v28; // [esp+48h] [ebp-80h]
  size_t v29; // [esp+4Ch] [ebp-7Ch]
  void *v30; // [esp+50h] [ebp-78h]
  char src; // [esp+56h] [ebp-72h]
  char v32; // [esp+89h] [ebp-3Fh]
  unsigned int v33; // [esp+BCh] [ebp-Ch]

  v33 = __readgsdword(0x14u);
  v16 = (void *)dword_806B080;
  v11 = dword_806B080;
  v10 = a1;
  v1 = &loc_80603A5;
  if ( dword_806B080 )
    v1 = &loc_8060815;
  dword_806A2BC = (int)v1;
  sub_8061057();
  ptr = 0;
  v20 = "charset.alias";
  s = getenv("CHARSETALIASDIR");
  if ( !s || !*s )
  {
    ptr = 0;
    s = "/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib";
  }
  n = strlen(s);
  v22 = strlen(v20);
  _CF = 0;
  _OF = 0;
  _ZF = n == 0;
  _SF = (n & 0x80000000) != 0;
  if ( n
    && (v6 = s[n - 1],
        _CF = (unsigned __int8)v6 < 0x2Fu,
        _OF = __OFSUB__(v6, 47),
        _ZF = v6 == 47,
        _SF = (char)(v6 - 47) < 0,
        v6 != 47) )
  {
    v7 = 1;
  }
  else
  {
    __asm { pushfw }
    v7 = 0;
    __asm { popfw }
  }
  v23 = v7;
  v12 = n + v7 + v22 + 1;
  dest = malloc(v12);
  if ( dest )
  {
    memcpy(dest, s, n);
    if ( v23 )
      *((_BYTE *)dest + n) = 47;
    memcpy((char *)dest + n + v23, v20, v22 + 1);
  }
  free(ptr);
  if ( dest )
  {
    fd = open64(dest, 0x20000);
    if ( fd >= 0 )
    {
      stream = fdopen(fd, "r");
      if ( stream )
      {
        v18 = 0;
        v19 = 0;
        while ( 1 )
        {
          c = getc_unlocked(stream);
          if ( c == -1 )
            break;
          if ( c != 10 && c != 32 && c != 9 )
          {
            if ( c == 35 )
            {
              do
                c = getc_unlocked(stream);
              while ( c != -1 && c != 10 );
              if ( c == -1 )
                break;
            }
            else
            {
              ungetc(c, stream);
              v14 = &v32;
              v13 = &src;
              if ( fscanf(stream, "%50s %50s", &src, &v32) <= 1 )
                break;
              v28 = strlen(&src);
              v29 = strlen(&v32);
              v30 = v18;
              if ( v19 )
              {
                v8 = v29 + v28 + v19;
                v19 = v8 + 2;
                v18 = realloc(v18, v8 + 3);
              }
              else
              {
                v19 = v28 + v29 + 2;
                v12 = v28 + v29 + 3;
                v18 = malloc(v12);
              }
              if ( !v18 )
              {
                v19 = 0;
                free(v30);
                break;
              }
              strcpy((char *)v18 + v19 - v29 - v28 - 2, (const char *)&v12 - 114);
              strcpy((char *)v18 + v19 - v29 - 1, (const char *)&v12 - 63);
            }
          }
        }
        sub_805F079(stream);
        if ( v19 )
        {
          *((_BYTE *)v18 + v19) = 0;
          v16 = v18;
        }
        else
        {
          v16 = &unk_8064997;
        }
      }
      else
      {
        close(fd);
        v16 = &unk_8064997;
      }
    }
    else
    {
      v16 = &unk_8064997;
    }
    free(dest);
  }
  else
  {
    v16 = &unk_8064997;
  }
  dword_806B080 = (int)v16;
  return v16;
}
// 8049C40: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 8061057: using guessed type int sub_8061057(void);
// 806A2BC: using guessed type int dword_806A2BC;
// 806B080: using guessed type int dword_806B080;

//----- (08060835) --------------------------------------------------------
const char *__usercall sub_8060835@<eax>(int a1@<ebx>)
{
  int v1; // edx
  int v2; // ecx
  bool v3; // zf
  void *v4; // eax
  void *v5; // eax
  int v7; // [esp-8h] [ebp-30h]
  int v8; // [esp-4h] [ebp-2Ch]
  char *s1; // [esp+18h] [ebp-10h]
  char *s2; // [esp+1Ch] [ebp-Ch]

  s1 = nl_langinfo(14);
  if ( !s1 )
    s1 = (char *)&unk_8064997;
  s2 = (char *)sub_8060353(a1);
  v3 = *s2 == 0;
  v8 = (unsigned __int8)*s2;
  v7 = a1;
  v4 = &loc_80608EB;
  if ( !v3 )
    v4 = &loc_8060861;
  dword_806A234 = (int)v4;
  sub_806143E(v2, v1);
  v3 = *s1 == 0;
  v8 = (unsigned __int8)*s1;
  v5 = &loc_806091E;
  if ( !v3 )
    v5 = &loc_8060925;
  dword_806A2BC = (int)v5;
  sub_8061057();
  return "ASCII";
}
// 8061057: using guessed type int sub_8061057(void);
// 806143E: using guessed type int __fastcall sub_806143E(_DWORD, _DWORD);
// 806A234: using guessed type int dword_806A234;
// 806A2BC: using guessed type int dword_806A2BC;

//----- (0806092A) --------------------------------------------------------
int __cdecl sub_806092A(char *s, int a2, char *s2, int a4)
{
  size_t v4; // ST1C_4
  size_t v5; // ST20_4
  int v7; // eax
  signed int v12; // eax
  int v13; // [esp+14h] [ebp-14h]

  while ( 1 )
  {
    *__errno_location() = 0;
    v13 = strcoll(s, s2);
    if ( v13 || (v7 = *__errno_location(), _CF = 0, _OF = 0, _ZF = v7 == 0, _SF = v7 < 0, v7) )
    {
      v12 = 1;
    }
    else
    {
      __asm { pushfw }
      v12 = 0;
      __asm { popfw }
    }
    if ( v12 )
      break;
    v4 = strlen(s) + 1;
    v5 = strlen(s2) + 1;
    s += v4;
    s2 += v5;
    a2 -= v4;
    a4 -= v5;
    if ( !a2 )
      return -(a4 != 0);
    if ( !a4 )
      return 1;
  }
  return v13;
}

//----- (080609ED) --------------------------------------------------------
signed int __cdecl sub_80609ED(unsigned int *a1, signed int a2)
{
  unsigned __int64 v2; // rcx
  int v3; // edx
  signed int result; // eax

  LODWORD(v2) = sub_8060C03(-1, -1, a2, a2 >> 31);
  HIDWORD(v2) = v3;
  if ( v2 >= *(_QWORD *)a1 )
  {
    _CF = *a1 * (unsigned __int64)(unsigned int)a2 >> 32 != 0;
    _OF = *a1 * (unsigned __int64)(unsigned int)a2 >> 32 != 0;
    *(_QWORD *)a1 *= a2;
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  else
  {
    *a1 = -1;
    a1[1] = -1;
    result = 1;
  }
  return result;
}
// 8060C03: using guessed type _DWORD __cdecl sub_8060C03(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08060A9F) --------------------------------------------------------
int __cdecl sub_8060A9F(void *s1, size_t n, void *s2, int a4)
{
  int result; // eax

  if ( n != a4 || memcmp(s1, s2, n) )
    return sub_806092A((char *)s1, n, (char *)s2, a4);
  *__errno_location() = 0;
  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}

//----- (08060AFF) --------------------------------------------------------
_DWORD *__userpurge sub_8060AFF@<eax>(_DWORD *a1, int a2, int a3)
{
  *a1 = a2;
  a1[1] = a3;
  return a1;
}

//----- (08060BDE) --------------------------------------------------------
int __cdecl sub_8060BDE(int fd)
{
  return sub_805F13C(fd, 0, 3);
}

//----- (08060C03) --------------------------------------------------------
#error "8060C27: call analysis failed (funcsize=18)"

//----- (08060C3A) --------------------------------------------------------
#error "8060C71: positive sp value has been found (funcsize=24)"

//----- (08060D7D) --------------------------------------------------------
int __cdecl sub_8060D7D(unsigned __int64 a1, __int64 a2)
{
  int v2; // edx
  int result; // eax
  int v4; // ebp
  int v5; // ebp
  unsigned int v6; // ebp
  unsigned __int64 v7; // rtt
  unsigned __int64 v8; // rax
  unsigned int v9; // edi
  unsigned __int64 v10; // rax
  unsigned int v11; // ecx
  unsigned int v12; // [esp+0h] [ebp-20h]
  unsigned int v13; // [esp+4h] [ebp-1Ch]
  unsigned __int64 v14; // [esp+8h] [ebp-18h]
  unsigned int v15; // [esp+10h] [ebp-10h]

  v13 = HIDWORD(a1);
  v15 = a1;
  v12 = a2;
  v14 = a1;
  if ( HIDWORD(a2) )
  {
    if ( HIDWORD(a2) > HIDWORD(a1) )
    {
      result = a1;
    }
    else
    {
      _BitScanReverse((unsigned int *)&v4, HIDWORD(a2));
      v5 = v4 ^ 0x1F;
      if ( v5 )
      {
        v13 = (HIDWORD(a2) << v5) | (v12 >> (32 - v5));
        LODWORD(v14) = v12 << v5;
        HIDWORD(v8) = HIDWORD(a1) >> (32 - v5);
        LODWORD(v8) = (HIDWORD(a1) << (char)&v12) | (v15 >> (32 - v5));
        HIDWORD(v14) = v15 << (char)&v12;
        v9 = v8 % v13;
        v10 = (v12 << v5) * (unsigned __int64)(unsigned int)(v8 / v13);
        v12 = HIDWORD(v10);
        v11 = v10;
        if ( v9 < HIDWORD(v10) || HIDWORD(v14) < (unsigned int)v10 && v9 == HIDWORD(v10) )
        {
          HIDWORD(v10) = v12;
          HIDWORD(v10) = (v10 - __PAIR__(v13, (unsigned int)v14)) >> 32;
          v11 = v10 - v14;
        }
        result = ((__PAIR__(v9, HIDWORD(v14)) - __PAIR__(HIDWORD(v10), v11)) >> 32 << (32 - (unsigned __int8)v5)) | ((HIDWORD(v14) - v11) >> (char)&v12);
      }
      else
      {
        if ( v12 <= (unsigned int)v14 || HIDWORD(a2) < HIDWORD(v14) )
          v14 = __PAIR__(v13, (unsigned int)a1) - a2;
        result = v14;
      }
    }
  }
  else
  {
    if ( (unsigned int)a2 <= HIDWORD(a1) )
    {
      v6 = a2;
      if ( !(_DWORD)a2 )
        v6 = 1 / 0u;
      LODWORD(v7) = a1;
      HIDWORD(v7) = v13 % v6;
      v2 = v7 % v6;
    }
    else
    {
      v2 = a1 % (unsigned int)a2;
    }
    result = v2;
  }
  return result;
}

//----- (08060F70) --------------------------------------------------------
int __cdecl sub_8060F70(int a1)
{
  return __cxa_atexit(a1, 0, dword_806A2D4);
}
// 8049AC0: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 806A2D4: using guessed type int dword_806A2D4;

//----- (08060F9F) --------------------------------------------------------
int __cdecl sub_8060F9F(int a1, int a2)
{
  return __xstat64(3, a1, a2);
}
// 8049EB0: using guessed type int __cdecl __xstat64(_DWORD, _DWORD, _DWORD);

//----- (08060FCE) --------------------------------------------------------
int __cdecl sub_8060FCE(int a1, int a2)
{
  return __fxstat64(3, a1, a2);
}
// 8049A30: using guessed type int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD);

//----- (08061057) --------------------------------------------------------
#error "806105D: positive sp value has been found (funcsize=0)"

//----- (080610E1) --------------------------------------------------------
#error "80610E7: positive sp value has been found (funcsize=0)"

//----- (080611DA) --------------------------------------------------------
#error "80611E0: positive sp value has been found (funcsize=0)"

//----- (080612C7) --------------------------------------------------------
#error "80612CD: positive sp value has been found (funcsize=0)"

//----- (080613AB) --------------------------------------------------------
#error "80613B1: positive sp value has been found (funcsize=0)"

//----- (080613FD) --------------------------------------------------------
#error "8061436: positive sp value has been found (funcsize=18)"

//----- (0806143E) --------------------------------------------------------
#error "8061444: positive sp value has been found (funcsize=0)"

//----- (080614AE) --------------------------------------------------------
#error "80614B4: positive sp value has been found (funcsize=0)"

//----- (0806151E) --------------------------------------------------------
#error "8061524: positive sp value has been found (funcsize=0)"

//----- (08061530) --------------------------------------------------------
int (**sub_8061530())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_8069ED0;
  v1 = &off_8069ED4 - off_8069ED0;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_8069ED0[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 8069ED0: using guessed type int (*off_8069ED0[2])();
// 8069ED4: using guessed type int (*off_8069ED4)();

//----- (08061594) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 80 decompilation failure(s) on 344 function(s)"
