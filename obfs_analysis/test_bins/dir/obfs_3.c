/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8049480();
// int unsetenv(const char *name);
// int raise(int sig);
// int strcmp(const char *s1, const char *s2);
// int putc_unlocked(int c, FILE *stream);
// struct passwd *getpwuid(__uid_t uid);
// int printf(const char *format, ...);
// void longjmp(struct __jmp_buf_tag env[1], int val);
// int fflush(FILE *stream);
// void _exit(int status);
// int sigprocmask(int how, const sigset_t *set, sigset_t *oset);
// int __cdecl wcwidth(_DWORD); weak
// void *memmove(void *dest, const void *src, size_t n);
// int _setjmp(struct __jmp_buf_tag env[1]);
// void free(void *ptr);
// uintmax_t strtoumax(const char *nptr, char **endptr, int base);
// void *memcpy(void *dest, const void *src, size_t n);
// int mbsinit(const mbstate_t *ps);
// int clock_gettime(clockid_t clock_id, struct timespec *tp);
// int tolower(int c);
// int fclose(FILE *stream);
// int getc_unlocked(FILE *stream);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// __sighandler_t signal(int sig, __sighandler_t handler);
// int memcmp(const void *s1, const void *s2, size_t n);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// char *dcgettext(const char *domainname, const char *msgid, int category);
// time_t mktime(struct tm *tp);
// struct tm *localtime_r(const time_t *timer, struct tm *tp);
// int sigismember(const sigset_t *set, int signo);
// int fflush_unlocked(FILE *stream);
// char *textdomain(const char *domainname);
// ssize_t readlink(const char *path, char *buf, size_t len);
// int fnmatch(const char *pattern, const char *name, int flags);
// int iswprint(wint_t wc);
// int ioctl(int fd, unsigned int request, ...);
// int ferror_unlocked(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD); weak
// void tzset(void);
// size_t __ctype_get_mb_cur_max(void);
// char *strcpy(char *dest, const char *src);
// size_t __fpending(FILE *fp);
// size_t wcstombs(char *s, const wchar_t *pwcs, size_t n);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int gethostname(char *name, size_t len);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// void error(int status, int errnum, const char *format, ...);
// int strcoll(const char *s1, const char *s2);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// time_t timegm(struct tm *tp);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// size_t strftime(char *s, size_t maxsize, const char *format, const struct tm *tp);
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// char *strchr(const char *s, int c);
// char *getcwd(char *buf, size_t size);
// int fscanf(FILE *stream, const char *format, ...);
// size_t strlen(const char *s);
// int setenv(const char *name, const char *value, int replace);
// int fprintf(FILE *stream, const char *format, ...);
// int sigaddset(sigset_t *set, int signo);
// void *memset(void *s, int c, size_t n);
// int ungetc(int c, FILE *stream);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// int *__errno_location(void);
// __pid_t tcgetpgrp(int fd);
// int fileno(FILE *stream);
// int __cdecl stpncpy(_DWORD, _DWORD, _DWORD); weak
// unsigned int gnu_dev_major(unsigned __int64 dev);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// int __cdecl mempcpy(_DWORD, _DWORD, _DWORD); weak
// int __cdecl wcswidth(_DWORD, _DWORD); weak
// int sigemptyset(sigset_t *set);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// int toupper(int c);
// char *strrchr(const char *s, int c);
// size_t mbstowcs(wchar_t *pwcs, const char *s, size_t n);
// struct tm *gmtime_r(const time_t *timer, struct tm *tp);
// unsigned int gnu_dev_minor(unsigned __int64 dev);
// int sprintf(char *s, const char *format, ...);
// struct lconv *localeconv(void);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// char *bindtextdomain(const char *domainname, const char *dirname);
// int strncmp(const char *s1, const char *s2, size_t n);
// int isatty(int fd);
// void abort(void);
// int __cdecl __xstat64(_DWORD, _DWORD, _DWORD); weak
// int __cdecl __lxstat64(_DWORD, _DWORD, _DWORD); weak
// int close(int fd);
// size_t strspn(const char *s, const char *accept);
// DIR *opendir(const char *name);
// struct group *getgrgid(__gid_t gid);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// void *calloc(size_t nmemb, size_t size);
// int putchar_unlocked(int c);
// int _gmon_start__(void); weak
void sub_8049BE3();
void sub_8049C00();
int sub_8049C10();
int sub_8049C80();
int sub_8049CA0();
void sub_8049CFF();
void sub_8049D1A();
int sub_8049D2A();
void sub_8049E0C();
void sub_8049E27();
int sub_8049E37();
void sub_8049F19();
void sub_8049F34();
signed int sub_8049F44();
void sub_804A026();
void sub_804A041();
int sub_804A051();
void sub_804A161();
void sub_804A17C();
int sub_804A18C();
void sub_804A26E();
void sub_804A289();
int sub_804A299();
void sub_804A37B();
void sub_804A396();
int sub_804A3A6();
int nullsub_3(void); // weak
int sub_804A404();
void sub_804A4B6();
void sub_804A4D1();
int sub_804A4E1();
void sub_804A5C3();
void sub_804A5DE();
int sub_804A5EE();
void sub_804A6D0();
void sub_804A6EB();
int sub_804A6FB();
// int __usercall sub_804A762@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
void sub_804A80B();
void sub_804A826();
int sub_804A836(void); // weak
int nullsub_5(void); // weak
int sub_804A8AD();
int sub_804A8F2();
void sub_804A986();
void sub_804A9A5();
int sub_804A9B5();
void sub_804AAC6();
void sub_804AB14();
int sub_804AB44();
int __cdecl sub_804ABF8(int a1);
int __cdecl sub_804AC34(unsigned __int8 a1);
int __cdecl sub_804AC46(_DWORD); // weak
int sub_804ACEE();
int sub_804AD19(void); // weak
// int __usercall sub_804AD7F@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, char *s1);
int __cdecl sub_804AF32(int a1, int a2);
int __cdecl sub_804AF5F(int a1);
bool __cdecl sub_804AF67(int a1);
int sub_804AF95();
int __cdecl sub_804AFBD(int a1);
_DWORD *__stdcall sub_804B090(int a1);
int __cdecl sub_804B153(int a1, int a2);
_BYTE *__cdecl sub_804B2E6(_BYTE *a1);
void sub_804B362();
signed int __cdecl sub_804B3D4(int a1);
char *__fastcall sub_804B4C2(int a1, int a2);
int __cdecl sub_804B6FD(unsigned __int64 *a1, unsigned int a2);
int __cdecl sub_804B744(_QWORD *a1, _QWORD *a2);
void __cdecl sub_804B7C8(void *ptr);
void __cdecl sub_804B8BF(void *ptr);
// int __usercall sub_804B90D@<eax>(int a1@<ebx>, int edx0@<edx>, int a3@<ecx>, int a2);
size_t sub_804BA11();
// size_t __usercall sub_804BA31@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>);
int __cdecl sub_804BA95(int a1);
int sub_804BAAB();
int sub_804BAC6();
__sighandler_t __cdecl sub_804BBCA(void (*a1)(int));
__sighandler_t sub_804BD75();
__sighandler_t sub_804BD8D();
int __cdecl main(int, char **, char **); // idb
int __cdecl sub_804BDD1(char *, int); // idb
int __cdecl sub_804C584(char *nptr); // idb
int sub_804C614(void); // weak
_DWORD __cdecl sub_804D81A(_DWORD, _DWORD, _DWORD, _DWORD); // weak
signed int sub_804DC10();
// int __usercall sub_804DCDC@<eax>(int a1@<ebx>);
void sub_804E106();
int __cdecl sub_804E1B3(int a1);
int __cdecl sub_804E1E6(int, char *format, int); // idb
int __cdecl sub_804E27A(char *, char *s, int); // idb
unsigned int __cdecl sub_804E300(const char *a1, int a2, unsigned __int8 a3);
_DWORD *__cdecl sub_804EAE3(int a1);
// int __usercall sub_804EB2A@<eax>(int a1@<edx>, int a2@<ecx>, int a3);
int __cdecl sub_804EB92(char *name); // idb
__int64 __cdecl sub_804EC7A(__int64 a1);
int sub_804ECA4();
void __cdecl sub_804ECE0(void **a1);
int sub_804ED49();
int __cdecl sub_804EE15(int a1);
signed int __cdecl sub_804EE4B(int a1, int a2, char a3);
int __cdecl sub_804EF33(int a1, int a2);
int __cdecl sub_804EFF4(int a1, int a2);
int __cdecl sub_804F099(_BYTE *a1);
_DWORD __cdecl sub_804F12C(_DWORD, _DWORD, __int64, _DWORD, _DWORD); // weak
int __cdecl sub_804F2D0(char *s2, char *format, int, int, int, int, int, char); // idb
_DWORD __cdecl sub_8050135(_DWORD); // weak
int __cdecl sub_8050178(char *path, int, int); // idb
void *__cdecl sub_80501FE(int a1, char *s);
int __cdecl sub_80502DE(int a1, int a2);
int __cdecl sub_8050321(char *s, int); // idb
int __cdecl sub_80504E5(char *s1, char *s2); // idb
int __cdecl sub_80505A3(int a1, int a2);
int __cdecl sub_8050641(int a1, int a2);
int __cdecl sub_80506DF(int a1, int a2);
int __cdecl sub_805077D(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_8050849(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_805086B(int a1, _DWORD *a2, _DWORD *a3, int (__stdcall *a4)(_DWORD, _DWORD, int, int, int));
int __cdecl sub_805089A(const char **a1, const char **a2, int (__cdecl *a3)(char *, char *));
int __cdecl sub_8050922(int a1, int a2);
int __cdecl sub_8050944(int a1, int a2);
int __cdecl sub_8050966(int a1, int a2);
int __cdecl sub_8050988(int a1, int a2);
int __cdecl sub_8050A4A(int a1, int a2);
int __cdecl sub_8050B58(int a1, int a2);
int __cdecl sub_8050BDB(int a1, int a2);
int __cdecl sub_8050BFD(int a1, int a2);
int __cdecl sub_8050C1F(int a1, int a2);
int __cdecl sub_8050C41(int a1, int a2);
int __cdecl sub_8050C63(int a1, int a2);
int __cdecl sub_8050CEA(int a1, int a2);
int __cdecl sub_8050D58(int a1, int a2);
int __cdecl sub_8050DF4(int a1, int a2);
int __cdecl sub_8050E62(int a1, int a2);
int __cdecl sub_8050E84(int a1, int a2);
int __cdecl sub_8050EA6(int a1, int a2);
int __cdecl sub_8050EC8(int a1, int a2);
int __cdecl sub_8050F8A(int a1, int a2);
int __cdecl sub_805100D(int a1, int a2);
int __cdecl sub_805107B(int a1, int a2);
int __cdecl sub_80510FE(int a1, int a2);
int __cdecl sub_8051120(int a1, int a2);
int __cdecl sub_8051142(int a1, int a2);
int __cdecl sub_8051164(int a1, int a2);
int __cdecl sub_8051186(int a1, int a2);
int __cdecl sub_80511F4(int a1, int a2);
int __cdecl sub_8051317(int a1, int a2);
int __cdecl sub_8051385(int a1, int a2);
int __cdecl sub_80513A7(int a1, int a2);
int __cdecl sub_80513C9(int a1, int a2);
int __cdecl sub_80513EB(int a1, int a2);
int __cdecl sub_805140D(int a1, int a2);
int __cdecl sub_805151B(int a1, int a2);
int __cdecl sub_805163E(const char **a1, const char **a2);
int __cdecl sub_8051660(const char **a1, const char **a2);
int __cdecl sub_8051682(const char **a1, const char **a2);
int __cdecl sub_80516A4(const char **a1, const char **a2);
int __cdecl sub_80516C6(const char **a1, const char **a2);
int __cdecl sub_805174D(const char **a1, const char **a2);
int __cdecl sub_80517D4(const char **a1, const char **a2);
int __cdecl sub_8051842(const char **a1, const char **a2);
int __cdecl sub_80518B0(char **a1, char **a2);
int __cdecl sub_80518CE(char **a1, char **a2);
int __cdecl sub_80518E8(char **a1, char **a2);
int __cdecl sub_8051902(int a1, int a2);
int __cdecl sub_80519A1(char **a1, char **a2);
int sub_8051A07();
_DWORD sub_8051A63(); // weak
int __cdecl sub_8051A9B(char *file, unsigned int line, char *function); // idb
_DWORD sub_8051BF3(); // weak
int __cdecl sub_8051D47(int a1, int a2, unsigned __int8 a3, int a4);
int sub_8051DEB();
int __cdecl sub_8051ED7(char *s, int, int); // idb
int __cdecl sub_8051FC6(__uid_t uid, int, int); // idb
int __cdecl sub_8052039(__gid_t gid, int, int); // idb
int __cdecl __noreturn sub_80520BA(char *a1, int a2);
int sub_805214F(); // weak
void __cdecl __noreturn sub_8052151(__uid_t uid); // idb
void __cdecl __noreturn sub_8052191(__gid_t gid); // idb
const char *__cdecl sub_80521D3(int a1, unsigned int a2, int a3);
// int __usercall __noreturn sub_8052274@<eax>(const char *a1@<ebx>, int a2);
void sub_8052EC8();
_DWORD __cdecl sub_8052ED0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_80533F5(void *a1, int a2, int a3);
char *__cdecl sub_80534D9(char *s, int a2);
// int __usercall sub_80535D9@<eax>(int a1@<ebx>, void *a2, int a3, int a4, int a5, char a6, int a7, int a8);
_DWORD __cdecl sub_8053A9F(_DWORD, _DWORD, _DWORD, _DWORD); // weak
size_t sub_8053C36();
// int __usercall sub_8053C7D@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, int a4, int a5);
// int __usercall sub_8053EE5@<eax>(int a1@<edx>, int a2@<ecx>, char a3, __int16 a4, int a5);
bool __cdecl sub_8054050(char a1);
// bool __usercall sub_80540D3@<al>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, int a4);
_DWORD __cdecl sub_8054124(_DWORD, _DWORD); // weak
size_t __cdecl sub_80545A6(int a1);
// int __usercall sub_805460A@<eax>(int a1@<ebx>, int a2);
// unsigned int __usercall sub_805486A@<eax>(int a1@<ebx>);
_DWORD sub_80549B6(); // weak
// int __usercall sub_8054B31@<eax>(int a1@<ecx>, int a2@<ebx>, char a3);
unsigned int __cdecl sub_8054C47(unsigned int a1, unsigned int a2);
_BYTE *__cdecl sub_8054CF4(_BYTE *a1, _BYTE *a2, _BYTE *a3);
int sub_8054D8C(void); // weak
_DWORD __cdecl sub_8054FCE(_DWORD); // weak
void __cdecl __noreturn sub_805526C(int status); // idb
char *__cdecl sub_80555DC(char *path, int a2);
void __noreturn sub_805570D();
int __cdecl sub_8055721(char *s, int, int, size_t); // idb
void __cdecl sub_8055855(int a1, int a2, int a3);
int __cdecl sub_80558DC(int a1);
int __cdecl sub_8055A4F(int a1, char *s, int a3, int a4, size_t n);
_BOOL4 __cdecl sub_8055B7E(signed int a1);
_DWORD __cdecl sub_8055BCB(_DWORD); // weak
_BOOL4 __cdecl sub_8055CB7(int a1);
int __cdecl sub_8055DF7(int a1);
int __cdecl sub_8055E31(int, char *s, int); // idb
int __cdecl sub_8055EDF(void *src, int); // idb
int sub_8056957();
unsigned int __cdecl sub_8056A3B(_BYTE *a1);
int __cdecl sub_8056AB0(void *src); // idb
_DWORD __cdecl sub_8056B4F(_DWORD); // weak
size_t __cdecl sub_8056BCD(char *s);
int sub_8056C24();
void __cdecl sub_8056C2E(int a1, char *s, int a3);
bool __cdecl sub_8056D07(_DWORD *a1, int a2, int *a3);
_DWORD __cdecl sub_8056D66(_DWORD); // weak
_DWORD __cdecl sub_8056E2D(_DWORD, _DWORD); // weak
int __cdecl sub_8057068(int a1, int a2);
int __cdecl sub_8057085(int a1);
_DWORD __cdecl sub_80570E5(_DWORD); // weak
int __cdecl sub_8057122(int a1);
_DWORD __cdecl sub_8057362(_DWORD); // weak
int __cdecl sub_80573E1(int a1, unsigned int a2, int a3, unsigned int a4);
int __cdecl sub_805765F(char *s1, char *s2); // idb
struct timespec *__cdecl sub_80578EF(struct timespec *tp);
int __cdecl sub_805793E(int category); // idb
int __cdecl sub_80579B9(int a1);
void sub_80579F1();
int __cdecl sub_8057A06(int a1);
int __cdecl sub_8057CA4(_DWORD *a1, int a2);
int __cdecl sub_8057CF4(_DWORD *a1, int a2);
bool __cdecl sub_8057FF8(unsigned int a1);
int __fastcall sub_805804F(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_8058071(int a1, unsigned int a2);
unsigned int __cdecl sub_8058109(int a1, unsigned int a2);
bool __cdecl sub_8058134(int a1, int a2);
signed int __cdecl sub_8058142(int a1);
int __cdecl sub_8058202(int a1, int a2);
size_t *__cdecl sub_80582EA(int a1, int a2, unsigned int (__cdecl *a3)(int a1, unsigned int a2), bool (__cdecl *a4)(int a1, int a2), size_t a5);
int __cdecl sub_8058549(void *); // idb
void *__cdecl sub_8058681(int a1);
int __cdecl sub_80586CC(int a1, _DWORD *a2);
int __cdecl sub_80586FF(int a1, int a2, int a3, char a4);
int __cdecl sub_8058A8B(int a1, int a2);
signed int __cdecl sub_8058C92(int a1, int a2, _DWORD *a3);
int __cdecl sub_8058F5F(int a1, int a2);
_DWORD __cdecl sub_8058FD9(_DWORD, _DWORD); // weak
int sub_805920E(); // weak
int __cdecl sub_80593E5(int a1, int a2);
void __cdecl sub_805949E(void **a1);
int __cdecl sub_80594C8(int, _TBYTE); // idb
_DWORD __cdecl sub_8059624(_DWORD, _DWORD, _DWORD); // weak
void __cdecl __noreturn sub_8059658(void *src, size_t n); // idb
int __cdecl sub_8059775(int, int, char *s, int, int, int, int, int); // idb
__int64 sub_805A556();
int __cdecl sub_805A588(char *s, int, int); // idb
int __cdecl sub_805A776(char *s, int, int); // idb
int __cdecl sub_805A7BF(__uid_t uid); // idb
int __cdecl sub_805AA24(__gid_t gid); // idb
_DWORD __cdecl sub_805AC4D(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_805ADA7(unsigned __int64 a1, int a2);
_DWORD __cdecl sub_805AE51(_DWORD); // weak
int __cdecl sub_805AECD(int *a1, unsigned int a2);
_BYTE *__cdecl sub_805AF3D(_BYTE *a1, unsigned int a2, int a3);
int __cdecl sub_805AF72(char *s, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_805B3E5(char *s);
_DWORD __cdecl sub_805B412(_DWORD); // weak
int __cdecl sub_805B44A(int c, size_t n, mbstate_t *p); // idb
_DWORD __cdecl sub_805B93F(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_805BBF3(int a1, int a2, int a3);
int __cdecl sub_805BC3B(int a1, int a2, int a3);
int __cdecl sub_805BC8F(int a1, int a2, int a3);
int __cdecl sub_805BCCF(int a1, int a2);
int __cdecl sub_805BD30(int a1, int a2, int a3, int a4, int a5, int a6);
_DWORD __cdecl sub_805BD99(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
char *__cdecl sub_805EB55(char *s);
void *__cdecl sub_805EC47(void *src);
// int __usercall sub_805EC8D@<eax>(int edx0@<edx>, int a2@<ecx>, int a1);
int *__cdecl sub_805ECC9(int *a1, int a2);
_DWORD __cdecl sub_805ECE3(_DWORD, _DWORD); // weak
int *__cdecl sub_805EDF7(int *a1, int a2, int a3);
// _DWORD *__userpurge sub_805EE38@<eax>(_DWORD *a1, int a2);
char *__cdecl sub_805EEE2(char *msgid);
_DWORD __cdecl sub_805EFA1(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_805FDD9(int a1, int a2, int a3, int a4, int *a5);
int __cdecl sub_805FEB3(int a1, int a2, int a3, int *a4);
_DWORD __cdecl sub_806008C(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_806030E(int a1, int a2);
int __cdecl sub_806033C(int a1, int a2, int a3);
int __cdecl sub_80603B6(int a1, int a2, int a3);
int __cdecl sub_80603F8(int a1, int a2, int a3, int a4);
int __cdecl sub_8060445(int a1, int a2);
int __cdecl sub_80604A4(int a1, int a2, char a3);
int __cdecl sub_8060562(int a1, char a2);
int __cdecl sub_80605A9(int a1);
int __cdecl sub_80605EA(int a1, int a2, int a3);
int __cdecl sub_806069B(int a1, int a2, int a3, int a4);
int __cdecl sub_80606DF(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_8060811(int a1, int a2, int a3);
_DWORD __cdecl sub_806086C(_DWORD, _DWORD); // weak
int __cdecl sub_80608B4(int a1);
int sub_80608CF();
void sub_8060B25();
signed int sub_8060B72();
signed int sub_8060B92();
// _DWORD *__userpurge sub_8060CD0@<eax>(_DWORD *a1, int a2);
// _DWORD *__userpurge sub_8060CFB@<eax>(_DWORD *a1, int a2);
// _DWORD *__userpurge sub_8060D3C@<eax>(_DWORD *a1, int a2);
int __cdecl sub_8060DD7(int a1, int a2, int a3, int a4);
int __cdecl sub_8060E71(FILE *stream, int, int, int, int, int); // idb
_DWORD __cdecl sub_806152F(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int sub_80615BA(int a1, int a2, int a3, int a4, ...);
int __cdecl sub_806169A(unsigned int a1, unsigned int a2);
void *__cdecl sub_80616CC(void *ptr, int a2, int a3);
void *__cdecl sub_8061711(void *ptr, int a2, int a3);
int __cdecl sub_80617AC(size_t a1);
int __cdecl sub_80617BF(size_t a1);
void *__cdecl sub_806182A(void *ptr, size_t size);
void *__cdecl sub_8061879(void *ptr, int a2);
void *__cdecl sub_8061928(void *src, size_t n);
void *__cdecl sub_8061955(char *s);
void __noreturn sub_8061996();
unsigned __int64 __cdecl sub_80619F1(char *nptr, int base, int a3, int a4, int a5, int a6, char *s, int a8, int status);
char *sub_8061BE1();
char *sub_8061C45();
_DWORD __cdecl sub_8061D44(_DWORD, _DWORD); // weak
int __cdecl sub_8061DB1(int a1, int a2, int a3);
int __cdecl sub_8061DEB(char *nptr, int, int base, int, char *s); // idb
_DWORD __cdecl sub_8062253(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
void __cdecl __noreturn sub_8062364(int a1, int a2, char a3, int a4, int a5);
signed int __cdecl sub_80623BB(int a1);
int __cdecl sub_8062489(int a1, int a2, int a3);
int __cdecl sub_80624C3(char *nptr, int, int base, int, char *s); // idb
int __cdecl sub_806293C(wchar_t *pwc, char *s, size_t n, mbstate_t *p); // idb
int __cdecl sub_80629D0(int a1, int a2);
int __cdecl sub_8062A12(int a1, int a2);
_DWORD __cdecl sub_8062A54(_DWORD, _DWORD, _DWORD); // weak
// signed int __usercall sub_8062B0C@<eax>(int a1@<eax>, int a2, int a3, int a4, int a5);
int __cdecl sub_8062B8F(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_8062C3C(int a1);
int __cdecl sub_8062F9F(int a1, int a2);
_BOOL4 __cdecl sub_8062FF0(_DWORD *a1, _DWORD *a2);
char *__cdecl sub_80630A6(void *dest, void *src, size_t n);
int __cdecl sub_80630D6(char *s); // idb
_DWORD __cdecl sub_806319D(_DWORD, _DWORD); // weak
void *__cdecl sub_80633B9(void *ptr);
char *sub_80633EC();
int __cdecl sub_806341E(char *value); // idb
signed int __cdecl sub_8063485(int a1);
_DWORD __cdecl sub_80634D2(_DWORD); // weak
int __cdecl sub_80635CF();
struct tm *__cdecl sub_8063673(int a1, time_t *timer, struct tm *tp);
int __cdecl sub_8063727(int, struct tm *tp); // idb
int __cdecl sub_8063997(int a1, char a2);
// int __usercall sub_8063AE3@<eax>(int a1@<edx>, int a2@<ecx>, unsigned __int8 *a3, unsigned __int8 *a4);
int __cdecl sub_8063BA8(FILE *fp); // idb
int __cdecl sub_8063C52(void *src); // idb
int __cdecl sub_8063C86(_BYTE *a1, unsigned int a2);
int sub_8063CCC(void); // weak
int __cdecl sub_8063D01(void *src, size_t n, int); // idb
const char *sub_806427F();
int __cdecl sub_8064362(FILE *stream); // idb
int __cdecl sub_8064447(FILE *stream); // idb
// int __usercall sub_806448E@<eax>(int a1@<edx>, int a2@<ecx>, FILE *fp);
int __cdecl sub_80644F3(FILE *stream, int, int, int); // idb
_DWORD __cdecl sub_80645F5(__int64, _DWORD, _DWORD); // weak
_DWORD __cdecl sub_80647CE(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl sub_8064A4F(__int64, _DWORD, _DWORD); // weak
int __cdecl sub_8064BD9(unsigned __int64 a1, unsigned int a2, unsigned int a3);
int __cdecl sub_8064DE5(int a1);
int __cdecl sub_8064E18(int a1, int a2);
int __cdecl sub_8064E4B(int a1, int a2);
int __cdecl sub_8064E9A(int a1, int a2);
int __fastcall sub_8064FFD(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __fastcall sub_806506B(_DWORD, _DWORD); // weak
int __fastcall sub_80650DF(_DWORD, _DWORD, _DWORD); // weak
int __fastcall sub_806514F(_DWORD, _DWORD); // weak
int __fastcall sub_80651D4(_DWORD, _DWORD, _DWORD, _DWORD);
int __stdcall sub_8065244(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_80652BA(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_806532A(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_80653A0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __fastcall sub_806540E(_DWORD, _DWORD);
int (**sub_8065420())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_804AC1A; // weak
_UNKNOWN loc_804AC22; // weak
_UNKNOWN loc_804AE4E; // weak
_UNKNOWN loc_804AE57; // weak
_UNKNOWN loc_804B1A6; // weak
_UNKNOWN loc_804B1D9; // weak
_UNKNOWN loc_804B204; // weak
_UNKNOWN locret_804B2E4; // weak
_UNKNOWN loc_804B344; // weak
_UNKNOWN loc_804B34D; // weak
_UNKNOWN loc_804B53A; // weak
_UNKNOWN loc_804B53F; // weak
_UNKNOWN loc_804B95C; // weak
_UNKNOWN loc_804B97B; // weak
_UNKNOWN loc_804B9AD; // weak
_UNKNOWN loc_804B9EB; // weak
_UNKNOWN loc_804BA07; // weak
_UNKNOWN loc_804BA0C; // weak
_UNKNOWN loc_804BA6F; // weak
_UNKNOWN locret_804BA93; // weak
_UNKNOWN locret_804DCDA; // weak
_UNKNOWN loc_804DDB8; // weak
_UNKNOWN loc_804DE5B; // weak
_UNKNOWN loc_804DE7D; // weak
_UNKNOWN loc_804DEE7; // weak
_UNKNOWN loc_804DFBE; // weak
_UNKNOWN loc_804E035; // weak
_UNKNOWN loc_804E08E; // weak
_UNKNOWN loc_804E0C7; // weak
_UNKNOWN loc_804E3A5; // weak
_UNKNOWN loc_804E3D3; // weak
_UNKNOWN loc_804EB38; // weak
_UNKNOWN loc_804EB87; // weak
_UNKNOWN loc_804EFBF; // weak
_UNKNOWN loc_804EFEA; // weak
_UNKNOWN loc_805025B; // weak
_UNKNOWN loc_805027D; // weak
_UNKNOWN locret_80502DC; // weak
_UNKNOWN loc_8050A96; // weak
_UNKNOWN loc_8050A9D; // weak
_UNKNOWN locret_8050BD9; // weak
_UNKNOWN loc_8050CA4; // weak
_UNKNOWN loc_8050CB6; // weak
_UNKNOWN loc_8050DBC; // weak
_UNKNOWN loc_8050DD8; // weak
_UNKNOWN locret_8050DF2; // weak
_UNKNOWN locret_805100B; // weak
_UNKNOWN locret_80510FC; // weak
_UNKNOWN locret_805148E; // weak
_UNKNOWN loc_805155C; // weak
_UNKNOWN loc_805156E; // weak
_UNKNOWN locret_80515B5; // weak
_UNKNOWN loc_8051724; // weak
_UNKNOWN loc_8051731; // weak
_UNKNOWN loc_8051799; // weak
_UNKNOWN loc_80517A0; // weak
_UNKNOWN loc_8051963; // weak
_UNKNOWN loc_8051975; // weak
_UNKNOWN loc_8051F4B; // weak
_UNKNOWN loc_8051F7D; // weak
_UNKNOWN loc_805214A; // weak
_UNKNOWN loc_805222B; // weak
_UNKNOWN loc_805226D; // weak
_UNKNOWN locret_8052272; // weak
_UNKNOWN loc_8052322; // weak
_UNKNOWN loc_805237A; // weak
_UNKNOWN loc_80523A7; // weak
_UNKNOWN loc_805241C; // weak
_UNKNOWN loc_80524EC; // weak
_UNKNOWN loc_80525C0; // weak
_UNKNOWN loc_8052611; // weak
_UNKNOWN loc_805280A; // weak
_UNKNOWN loc_805282D; // weak
_UNKNOWN loc_8052A4D; // weak
_UNKNOWN loc_8052A68; // weak
_UNKNOWN loc_8052ABB; // weak
_UNKNOWN loc_8052C6A; // weak
_UNKNOWN loc_8052C77; // weak
_UNKNOWN loc_8052EC3; // weak
_UNKNOWN loc_8053534; // weak
_UNKNOWN loc_8053550; // weak
_UNKNOWN loc_80536D9; // weak
_UNKNOWN loc_80536E7; // weak
_UNKNOWN loc_805371F; // weak
_UNKNOWN loc_8053753; // weak
_UNKNOWN loc_8053A64; // weak
_UNKNOWN loc_8053A72; // weak
_UNKNOWN loc_8053D45; // weak
_UNKNOWN loc_8053D4C; // weak
_UNKNOWN loc_8053DFC; // weak
_UNKNOWN loc_8053E2F; // weak
_UNKNOWN loc_8053E7C; // weak
_UNKNOWN loc_8053EC4; // weak
_UNKNOWN loc_8053F5F; // weak
_UNKNOWN loc_8053F71; // weak
_UNKNOWN loc_8054667; // weak
_UNKNOWN loc_80546AE; // weak
_UNKNOWN loc_8054758; // weak
_UNKNOWN loc_8054B84; // weak
_UNKNOWN loc_8054BA6; // weak
_UNKNOWN loc_8054BAB; // weak
_UNKNOWN loc_8055687; // weak
_UNKNOWN loc_80556AD; // weak
_UNKNOWN loc_8055826; // weak
_UNKNOWN loc_8055914; // weak
_UNKNOWN loc_8055A34; // weak
_UNKNOWN loc_8055BA2; // weak
_UNKNOWN loc_8055BB1; // weak
_UNKNOWN loc_8056B04; // weak
_UNKNOWN loc_8056B0F; // weak
_UNKNOWN loc_8056C07; // weak
_UNKNOWN loc_8056CE9; // weak
_UNKNOWN loc_8056CEE; // weak
_UNKNOWN loc_8057418; // weak
_UNKNOWN loc_8057452; // weak
_UNKNOWN loc_80574A0; // weak
_UNKNOWN loc_8057507; // weak
_UNKNOWN loc_8057533; // weak
_UNKNOWN loc_8057537; // weak
_UNKNOWN loc_805755F; // weak
_UNKNOWN loc_80575D5; // weak
_UNKNOWN loc_80575F3; // weak
_UNKNOWN loc_8057715; // weak
_UNKNOWN loc_805771F; // weak
_UNKNOWN locret_80578ED; // weak
_UNKNOWN loc_805822F; // weak
_UNKNOWN loc_80582A5; // weak
_UNKNOWN loc_8058348; // weak
_UNKNOWN loc_805834F; // weak
_UNKNOWN loc_8058AC8; // weak
_UNKNOWN loc_8058AD2; // weak
_UNKNOWN locret_8058F5D; // weak
_UNKNOWN loc_8058FC2; // weak
_UNKNOWN loc_8058FD2; // weak
_UNKNOWN loc_8059488; // weak
_UNKNOWN loc_805948F; // weak
_UNKNOWN loc_805A5FE; // weak
_UNKNOWN loc_805A610; // weak
_UNKNOWN loc_805A6BB; // weak
_UNKNOWN loc_805A6CC; // weak
_UNKNOWN loc_805B181; // weak
_UNKNOWN loc_805EBCB; // weak
_UNKNOWN loc_805ECC5; // weak
_UNKNOWN locret_805EF9F; // weak
_UNKNOWN loc_8060A4B; // weak
_UNKNOWN loc_8060A74; // weak
_UNKNOWN loc_8060AA5; // weak
_UNKNOWN loc_8060ACA; // weak
_UNKNOWN loc_8061810; // weak
_UNKNOWN loc_8061825; // weak
_UNKNOWN loc_8061AEC; // weak
_UNKNOWN loc_8061C1D; // weak
_UNKNOWN loc_8061C40; // weak
_UNKNOWN loc_8061CD1; // weak
_UNKNOWN loc_8061D3D; // weak
_UNKNOWN loc_8061E23; // weak
_UNKNOWN loc_8061E63; // weak
_UNKNOWN loc_8061E66; // weak
_UNKNOWN loc_8061EA7; // weak
_UNKNOWN loc_80621F8; // weak
_UNKNOWN loc_8062242; // weak
_UNKNOWN loc_8062246; // weak
_UNKNOWN loc_80624FB; // weak
_UNKNOWN loc_8062526; // weak
_UNKNOWN loc_80625D7; // weak
_UNKNOWN loc_8062605; // weak
_UNKNOWN loc_8062645; // weak
_UNKNOWN loc_8062662; // weak
_UNKNOWN loc_80628F4; // weak
_UNKNOWN locret_806293A; // weak
_UNKNOWN loc_8062FCF; // weak
_UNKNOWN loc_8062FE6; // weak
_UNKNOWN loc_8063147; // weak
_UNKNOWN loc_8063198; // weak
_UNKNOWN loc_8063616; // weak
_UNKNOWN loc_806361D; // weak
_UNKNOWN loc_806371B; // weak
_UNKNOWN loc_8063720; // weak
_UNKNOWN loc_806379B; // weak
_UNKNOWN loc_80637E0; // weak
_UNKNOWN loc_80637FF; // weak
_UNKNOWN loc_8063B11; // weak
_UNKNOWN loc_8063B52; // weak
_UNKNOWN loc_8063B69; // weak
_UNKNOWN loc_8063B95; // weak
_UNKNOWN loc_8063BA1; // weak
_UNKNOWN loc_8063C06; // weak
_UNKNOWN loc_8063C1E; // weak
_UNKNOWN loc_80642ED; // weak
_UNKNOWN loc_8064304; // weak
_UNKNOWN loc_80644B3; // weak
_UNKNOWN loc_80644C2; // weak
_UNKNOWN loc_8064D08; // weak
char msgid[8] = "\nMandato"; // idb
char s = '\0'; // idb
char byte_80667CD[] = { '?' }; // weak
char *off_80668C0 = &unk_8066860; // idb
_UNKNOWN unk_8066929; // weak
int sig[12] = { 20, 14, 1, 2, 13, 3, 15, 29, 27, 26, 24, 25 }; // idb
_UNKNOWN unk_8069CA8; // weak
char *off_8069D7C[2] = { "human-readable", "si" }; // weak
int dword_8069D88[2] = { 176, 144 }; // idb
_UNKNOWN unk_8069E0C; // weak
char *off_806A0E0[10] =
{
  "literal",
  "shell",
  "shell-always",
  "shell-escape",
  "shell-escape-always",
  "c",
  "c-maybe",
  "escape",
  "locale",
  "clocale"
}; // weak
int dword_806A120[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; // idb
_UNKNOWN unk_806A14E; // weak
_UNKNOWN unk_806A152; // weak
_UNKNOWN unk_806A165; // weak
_UNKNOWN unk_806ACBB; // weak
_UNKNOWN unk_806D3A8; // weak
_UNKNOWN unk_806D3AB; // weak
_UNKNOWN unk_806E3D0; // weak
_UNKNOWN unk_806E3D3; // weak
_UNKNOWN unk_806F40C; // weak
_UNKNOWN unk_806F40F; // weak
int (*off_8070ED4[2])() = { &sub_8049CA0, &sub_8049C80 }; // weak
int (*off_8070ED8)() = &sub_8049C80; // weak
int (*dword_8071008)(void) = NULL; // weak
int dword_80711DC = 0; // weak
int dword_80711F0 = 0; // weak
int dword_8071204 = 0; // weak
int dword_8071218 = 0; // weak
int dword_807122C = 0; // weak
int dword_8071240 = 0; // weak
int dword_8071254 = 0; // weak
int dword_8071268 = 0; // weak
int dword_807127C = 0; // weak
int dword_8071290 = 0; // weak
int dword_80712C0 = 0; // weak
_UNKNOWN unk_80712DC; // weak
char byte_80712DE = '\x01'; // weak
char byte_80712DF = '\x01'; // weak
int dword_80712E4 = 1; // idb
int dword_80712E8 = 0; // idb
int dword_80712FC[] = { 2 }; // weak
void *s1 = &unk_8066924; // idb
int dword_8071304 = 1; // weak
_UNKNOWN unk_807130C; // weak
int dword_8071310 = 0; // weak
_UNKNOWN unk_8071314; // weak
_UNKNOWN unk_807131C; // weak
int dword_8071334 = 5; // weak
char *off_8071338 = "01;36"; // idb
char *off_80713BC = "%b %e  %Y"; // idb
int dword_80713C8 = 4294967295; // weak
int dword_8071404 = 2; // weak
int status = 1; // idb
_UNKNOWN unk_807143C; // weak
_UNKNOWN unk_807145C; // weak
_UNKNOWN unk_807145F; // weak
_UNKNOWN unk_8071464; // weak
_UNKNOWN unk_8071467; // weak
_UNKNOWN unk_8071468; // weak
_UNKNOWN unk_807146B; // weak
_UNKNOWN unk_8071470; // weak
_UNKNOWN unk_8071473; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int program_invocation_name; // weak
FILE *stdout; // idb
int (*obstack_alloc_failed_handler)(void); // weak
char byte_80714CC; // weak
_UNKNOWN unk_80715B7; // weak
char byte_807181B; // weak
void *dword_80718A9; // idb
void *dword_80718AD; // idb
int dword_80718B5; // weak
char byte_80718B9; // weak
char byte_80718BA; // weak
void *dword_80718BD; // idb
char byte_80718C5; // weak
char *dword_80718C9; // idb
int dword_80718CD; // weak
struct timespec tp; // idb
char byte_80718D9; // weak
char byte_80718DA; // weak
int dword_80718DD; // weak
int dword_80718E1; // weak
int dword_80718E5; // weak
int dword_80718E9; // idb
int dword_80718ED; // idb
int dword_80718F1; // idb
int dword_80718F5; // idb
int dword_80718F9; // weak
int dword_80718FD; // weak
int dword_8071901; // weak
int dword_8071905; // weak
int dword_8071909; // weak
char byte_8071912; // weak
char byte_8071913; // weak
char byte_8071914; // weak
int dword_8071915; // idb
int dword_8071919; // idb
int dword_807191D; // idb
int dword_8071921; // idb
char byte_8071925; // weak
int dword_8071929; // weak
char byte_807192D; // weak
char byte_807192F; // weak
int dword_8071931; // weak
void *ptr; // idb
char byte_807193A; // weak
int dword_8071949; // idb
int dword_8071955; // weak
int dword_807195D; // weak
int dword_8071965; // weak
int dword_8071969; // idb
sigset_t set; // idb
int dword_8071A09; // weak
int dword_8071A0D; // weak
int dword_8071A11; // weak
void *dword_8071A15; // idb
int dword_8071A1D; // weak
_UNKNOWN unk_8071A29; // weak
_UNKNOWN unk_8071AA9; // weak
int dword_8071AB5; // weak
char byte_8071AE9[3328]; // idb
char byte_80727E9; // weak
struct __jmp_buf_tag env[1]; // idb
__int64 qword_80728A9; // weak
int dword_80728B1; // weak
int dword_80728B5; // weak
__int64 qword_80728B9; // weak
int dword_80728C5; // weak
char byte_80728C9; // weak
int dword_80728D5; // weak
int dword_80728DD; // weak
int dword_80728E9; // weak
int dword_80728ED; // weak
int dword_80728F1; // weak
int dword_80728F5; // weak
int dword_80728F9; // weak
int dword_80728FD; // weak
int dword_8072901; // weak
int dword_8072905; // weak
int dword_8072909; // weak
int dword_807290D; // weak
int dword_8072911; // weak
int dword_8072915; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (0804945C) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 8049BA0: using guessed type int _gmon_start__(void);

//----- (08049480) --------------------------------------------------------
int sub_8049480()
{
  return dword_8071008();
}
// 8071008: using guessed type int (*dword_8071008)(void);

//----- (08049BB0) --------------------------------------------------------
#error "8049BB3: positive sp value has been found (funcsize=2)"

//----- (08049BE3) --------------------------------------------------------
void sub_8049BE3()
{
  ;
}

//----- (08049C00) --------------------------------------------------------
void sub_8049C00()
{
  ;
}

//----- (08049C10) --------------------------------------------------------
int sub_8049C10()
{
  int result; // eax

  result = &unk_8071473 - &unk_8071470;
  if ( (unsigned int)(&unk_8071473 - &unk_8071470) > 6 )
    result = 0;
  return result;
}
// 8049C10: could not find valid save-restore pair for ebp

//----- (08049C80) --------------------------------------------------------
int sub_8049C80()
{
  int result; // eax

  if ( !byte_80714CC )
  {
    result = sub_8049C10();
    byte_80714CC = 1;
  }
  return result;
}
// 8049C80: could not find valid save-restore pair for ebp
// 80714CC: using guessed type char byte_80714CC;

//----- (08049CA0) --------------------------------------------------------
int sub_8049CA0()
{
  return 0;
}
// 8049CA0: could not find valid save-restore pair for ebp

//----- (08049CFF) --------------------------------------------------------
void sub_8049CFF()
{
  ;
}

//----- (08049D1A) --------------------------------------------------------
void sub_8049D1A()
{
  ;
}

//----- (08049D2A) --------------------------------------------------------
int sub_8049D2A()
{
  int result; // eax

  result = &unk_807145F - &unk_807145C;
  if ( (unsigned int)(&unk_807145F - &unk_807145C) > 6 )
    result = 0;
  return result;
}
// 8049D2A: could not find valid save-restore pair for ebp

//----- (08049E0C) --------------------------------------------------------
void sub_8049E0C()
{
  ;
}

//----- (08049E27) --------------------------------------------------------
void sub_8049E27()
{
  ;
}

//----- (08049E37) --------------------------------------------------------
int sub_8049E37()
{
  int result; // eax

  result = &unk_807145F - &unk_807145C;
  if ( (unsigned int)(&unk_807145F - &unk_807145C) > 6 )
    result = 0;
  return result;
}
// 8049E37: could not find valid save-restore pair for ebp

//----- (08049F19) --------------------------------------------------------
void sub_8049F19()
{
  ;
}

//----- (08049F34) --------------------------------------------------------
void sub_8049F34()
{
  ;
}

//----- (08049F44) --------------------------------------------------------
signed int sub_8049F44()
{
  return 3;
}
// 8049F44: could not find valid save-restore pair for ebp

//----- (0804A026) --------------------------------------------------------
void sub_804A026()
{
  ;
}

//----- (0804A041) --------------------------------------------------------
void sub_804A041()
{
  ;
}

//----- (0804A051) --------------------------------------------------------
int sub_804A051()
{
  int result; // eax

  result = &unk_80715B7 - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_80715B7 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 804A051: could not find valid save-restore pair for ebp
// 8071480: using guessed type int program_invocation_short_name;

//----- (0804A161) --------------------------------------------------------
void sub_804A161()
{
  ;
}

//----- (0804A17C) --------------------------------------------------------
void sub_804A17C()
{
  ;
}

//----- (0804A18C) --------------------------------------------------------
int sub_804A18C()
{
  int result; // eax

  result = &unk_806F40F - &unk_806F40C;
  if ( (unsigned int)(&unk_806F40F - &unk_806F40C) > 6 )
    result = 0;
  return result;
}
// 804A18C: could not find valid save-restore pair for ebp

//----- (0804A26E) --------------------------------------------------------
void sub_804A26E()
{
  ;
}

//----- (0804A289) --------------------------------------------------------
void sub_804A289()
{
  ;
}

//----- (0804A299) --------------------------------------------------------
int sub_804A299()
{
  int result; // eax

  result = &unk_807145F - &unk_807145C;
  if ( (unsigned int)(&unk_807145F - &unk_807145C) > 6 )
    result = 0;
  return result;
}
// 804A299: could not find valid save-restore pair for ebp

//----- (0804A37B) --------------------------------------------------------
void sub_804A37B()
{
  ;
}

//----- (0804A396) --------------------------------------------------------
void sub_804A396()
{
  ;
}

//----- (0804A3A6) --------------------------------------------------------
int sub_804A3A6()
{
  int result; // eax

  result = &unk_807145F - &unk_807145C;
  if ( (unsigned int)(&unk_807145F - &unk_807145C) > 6 )
    result = 0;
  return result;
}
// 804A3A6: could not find valid save-restore pair for ebp

//----- (0804A404) --------------------------------------------------------
int sub_804A404()
{
  return nullsub_3();
}
// 804A404: could not find valid save-restore pair for ebp
// 804A403: using guessed type int nullsub_3(void);

//----- (0804A4B6) --------------------------------------------------------
void sub_804A4B6()
{
  ;
}

//----- (0804A4D1) --------------------------------------------------------
void sub_804A4D1()
{
  ;
}

//----- (0804A4E1) --------------------------------------------------------
int sub_804A4E1()
{
  int result; // eax

  result = &unk_806E3D3 - &unk_806E3D0;
  if ( (unsigned int)(&unk_806E3D3 - &unk_806E3D0) > 6 )
    result = 0;
  return result;
}
// 804A4E1: could not find valid save-restore pair for ebp

//----- (0804A5C3) --------------------------------------------------------
void sub_804A5C3()
{
  ;
}

//----- (0804A5DE) --------------------------------------------------------
void sub_804A5DE()
{
  ;
}

//----- (0804A5EE) --------------------------------------------------------
int sub_804A5EE()
{
  int result; // eax

  result = &unk_807145F - &unk_807145C;
  if ( (unsigned int)(&unk_807145F - &unk_807145C) > 6 )
    result = 0;
  return result;
}
// 804A5EE: could not find valid save-restore pair for ebp

//----- (0804A6D0) --------------------------------------------------------
void sub_804A6D0()
{
  ;
}

//----- (0804A6EB) --------------------------------------------------------
void sub_804A6EB()
{
  ;
}

//----- (0804A6FB) --------------------------------------------------------
int sub_804A6FB()
{
  int result; // eax

  result = &unk_806D3AB - &unk_806D3A8;
  if ( (unsigned int)(&unk_806D3AB - &unk_806D3A8) > 6 )
    result = 0;
  return result;
}
// 804A6FB: could not find valid save-restore pair for ebp

//----- (0804A762) --------------------------------------------------------
int __usercall sub_804A762@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_806D3A8, a1);
}

//----- (0804A80B) --------------------------------------------------------
void sub_804A80B()
{
  ;
}

//----- (0804A826) --------------------------------------------------------
void sub_804A826()
{
  ;
}

//----- (0804A836) --------------------------------------------------------
#error "804A863: call analysis failed (funcsize=23)"

//----- (0804A8AD) --------------------------------------------------------
int sub_804A8AD()
{
  return nullsub_5();
}
// 804A8AD: could not find valid save-restore pair for ebp
// 804A8AC: using guessed type int nullsub_5(void);

//----- (0804A8F2) --------------------------------------------------------
int sub_804A8F2()
{
  int result; // eax

  result = sub_804A836();
  byte_807181B = 1;
  return result;
}
// 804A836: using guessed type int sub_804A836(void);
// 807181B: using guessed type char byte_807181B;

//----- (0804A986) --------------------------------------------------------
void sub_804A986()
{
  ;
}

//----- (0804A9A5) --------------------------------------------------------
void sub_804A9A5()
{
  ;
}

//----- (0804A9B5) --------------------------------------------------------
int sub_804A9B5()
{
  int result; // eax

  result = &unk_8071467 - &unk_8071464;
  if ( (unsigned int)(&unk_8071467 - &unk_8071464) > 6 )
    result = 0;
  return result;
}

//----- (0804AAC6) --------------------------------------------------------
void sub_804AAC6()
{
  ;
}

//----- (0804AB14) --------------------------------------------------------
void sub_804AB14()
{
  ;
}

//----- (0804AB44) --------------------------------------------------------
int sub_804AB44()
{
  int result; // eax

  result = &unk_807146B - &unk_8071468;
  if ( (unsigned int)(&unk_807146B - &unk_8071468) > 6 )
    result = 0;
  return result;
}

//----- (0804ABF8) --------------------------------------------------------
#error "804AC15: call analysis failed (funcsize=16)"

//----- (0804AC34) --------------------------------------------------------
int __cdecl sub_804AC34(unsigned __int8 a1)
{
  return a1;
}

//----- (0804AC46) --------------------------------------------------------
#error "804ACBC: call analysis failed (funcsize=55)"

//----- (0804ACEE) --------------------------------------------------------
int sub_804ACEE()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext(msgid);
  return fputs_unlocked(v1, v0);
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804AD19) --------------------------------------------------------
#error "804AD42: call analysis failed (funcsize=15)"

//----- (0804AD47) --------------------------------------------------------
#error "804AD7C: positive sp value has been found (funcsize=0)"

//----- (0804AD7F) --------------------------------------------------------
int __usercall sub_804AD7F@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, char *s1)
{
  bool v4; // zf
  void *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // ebx
  char *v10; // eax
  int v12; // [esp-8h] [ebp-70h]
  char *v13; // [esp-4h] [ebp-6Ch]
  int v14; // [esp+0h] [ebp-68h]
  char *v15; // [esp+4h] [ebp-64h]
  char *v16; // [esp+8h] [ebp-60h]
  char *v17; // [esp+1Ch] [ebp-4Ch]
  char **i; // [esp+20h] [ebp-48h]
  char *v19; // [esp+24h] [ebp-44h]
  const char *v20; // [esp+28h] [ebp-40h]
  const char *v21; // [esp+2Ch] [ebp-3Ch]
  const char *v22; // [esp+30h] [ebp-38h]
  const char *v23; // [esp+34h] [ebp-34h]
  const char *v24; // [esp+38h] [ebp-30h]
  const char *v25; // [esp+3Ch] [ebp-2Ch]
  const char *v26; // [esp+40h] [ebp-28h]
  const char *v27; // [esp+44h] [ebp-24h]
  const char *v28; // [esp+48h] [ebp-20h]
  const char *v29; // [esp+4Ch] [ebp-1Ch]
  const char *v30; // [esp+50h] [ebp-18h]
  const char *v31; // [esp+54h] [ebp-14h]
  int v32; // [esp+58h] [ebp-10h]
  int v33; // [esp+5Ch] [ebp-Ch]

  v20 = "[";
  v21 = "test invocation";
  v22 = "coreutils";
  v23 = "Multi-call invocation";
  v24 = "sha224sum";
  v25 = "sha2 utilities";
  v26 = "sha256sum";
  v27 = "sha2 utilities";
  v28 = "sha384sum";
  v29 = "sha2 utilities";
  v30 = "sha512sum";
  v31 = "sha2 utilities";
  v32 = 0;
  v33 = 0;
  v17 = s1;
  for ( i = (char **)(&v14 - 16); *i; i += 2 )
  {
    v15 = *i;
    if ( !strcmp(s1, v15) )
      break;
  }
  v4 = i[1] == 0;
  v13 = i[1];
  v12 = a3;
  v5 = &loc_804AE4E;
  if ( v4 )
    v5 = &loc_804AE57;
  dword_8071254 = (int)v5;
  sub_806514F(a2, a1);
  v17 = i[1];
  v6 = gettext("\n%s online help: <%s>\n");
  v16 = "http://www.gnu.org/software/coreutils/";
  v15 = "GNU coreutils";
  printf(v6, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  v19 = setlocale(5, 0);
  if ( v19 && strncmp(v19, "en_", 3u) )
  {
    v7 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
    v15 = s1;
    printf(v7, s1);
  }
  v8 = gettext("Full documentation at: <%s%s>\n");
  v16 = s1;
  v15 = "http://www.gnu.org/software/coreutils/";
  printf(v8, "http://www.gnu.org/software/coreutils/", s1);
  if ( v17 == s1 )
    v9 = " invocation";
  else
    v9 = &s;
  v10 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  v16 = v9;
  v15 = v17;
  return printf(v10, v17, v9);
}
// 806514F: using guessed type int __fastcall sub_806514F(_DWORD, _DWORD);
// 8071254: using guessed type int dword_8071254;

//----- (0804AF32) --------------------------------------------------------
int __cdecl sub_804AF32(int a1, int a2)
{
  return sub_805AC4D(a1, a1 >> 31, a2);
}
// 805AC4D: using guessed type _DWORD __cdecl sub_805AC4D(_DWORD, _DWORD, _DWORD);

//----- (0804AF5F) --------------------------------------------------------
int __cdecl sub_804AF5F(int a1)
{
  return a1;
}

//----- (0804AF67) --------------------------------------------------------
bool __cdecl sub_804AF67(int a1)
{
  return a1 == 95;
}

//----- (0804AF95) --------------------------------------------------------
int sub_804AF95()
{
  return 0;
}

//----- (0804AFBD) --------------------------------------------------------
int __cdecl sub_804AFBD(int a1)
{
  int *v1; // ebp
  int *v2; // ebp
  int v3; // ecx
  int v4; // edx
  _DWORD *v5; // ecx
  int result; // eax
  int v7; // edx
  int v8; // [esp+0h] [ebp-48h]
  int v9; // [esp+4h] [ebp-44h]
  int v10; // [esp+Ch] [ebp-3Ch]
  int v11; // [esp+10h] [ebp-38h]
  int v12; // [esp+14h] [ebp-34h]

  v1 = &v8;
  *(&v8 - 12) = a1;
  *(&v8 - 11) = v10;
  *(&v8 - 14) = v11;
  *(&v8 - 13) = v12;
  *(&v8 - 8) = 16;
  *(&v8 - 7) = (int)&unk_8071AA9;
  *(v1 - 6) = *(v1 - 8);
  *(v1 - 5) = *(v1 - 7);
  if ( *(_DWORD *)(*(v1 - 5) + 16) - *(_DWORD *)(*(v1 - 5) + 12) < (unsigned int)*(&v8 - 6) )
  {
    v9 = *(&v8 - 6);
    sub_8062C3C(*(&v8 - 7));
  }
  *(_DWORD *)(*(&v8 - 7) + 12) += *(&v8 - 6);
  v2 = &v8;
  *(&v8 - 4) = dword_8071AB5;
  *(v2 - 3) = *(v2 - 4);
  *(v2 - 3) -= 16;
  v3 = *(&v8 - 3);
  v4 = *(&v8 - 11);
  *(_DWORD *)(v3 + 8) = *(&v8 - 12);
  *(_DWORD *)(v3 + 12) = v4;
  v5 = (_DWORD *)*(&v8 - 3);
  result = *(&v8 - 14);
  v7 = *(&v8 - 13);
  *v5 = result;
  v5[1] = v7;
  return result;
}
// 8071AB5: using guessed type int dword_8071AB5;

//----- (0804B090) --------------------------------------------------------
_DWORD *__stdcall sub_804B090(int a1)
{
  _DWORD *v1; // eax
  _DWORD *v2; // edx
  int v4; // [esp+0h] [ebp-28h]
  _DWORD *v5; // [esp+8h] [ebp-20h]
  int v6; // [esp+10h] [ebp-18h]
  void *v7; // [esp+14h] [ebp-14h]

  v6 = 16;
  v7 = &unk_8071AA9;
  if ( (unsigned int)(*((_DWORD *)&unk_8071AA9 + 3) - *(_DWORD *)(*(&v4 - 5) + 8)) < 0x10 )
    __assert_fail("dev_ino_size <= obstack_object_size (&dev_ino_obstack)", "src/ls.c", 0x402u, "dev_ino_pop");
  dword_8071AB5 -= *(&v4 - 6);
  *(&v4 - 4) = dword_8071AB5;
  *(&v4 - 3) = *(&v4 - 4);
  v1 = v5;
  v2 = (_DWORD *)*(&v4 - 3);
  *v5 = *v2;
  v1[1] = v2[1];
  v1[2] = v2[2];
  v1[3] = v2[3];
  return v5;
}
// 8071AB5: using guessed type int dword_8071AB5;

//----- (0804B153) --------------------------------------------------------
int __cdecl sub_804B153(int a1, int a2)
{
  int v2; // ecx
  unsigned int v3; // edx
  unsigned int v4; // eax
  bool v5; // zf
  void *v6; // eax
  void *v7; // eax
  int v9; // [esp+0h] [ebp-38h]
  int v10; // [esp+4h] [ebp-34h]
  int v11; // [esp+8h] [ebp-30h]
  int v12; // [esp+Ch] [ebp-2Ch]
  int v13; // [esp+10h] [ebp-28h]
  int v14; // [esp+14h] [ebp-24h]
  unsigned int i; // [esp+18h] [ebp-20h]
  int v16; // [esp+1Ch] [ebp-1Ch]
  unsigned int v17; // [esp+20h] [ebp-18h]
  int v18; // [esp+24h] [ebp-14h]
  int v19; // [esp+28h] [ebp-10h]
  int v20; // [esp+2Ch] [ebp-Ch]
  int v21; // [esp+30h] [ebp-8h]
  int v22; // [esp+34h] [ebp-4h]
  int savedregs; // [esp+38h] [ebp+0h]

  v16 = a2;
  v3 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 8);
  v4 = v3 >> 2;
  v17 = v4;
  v5 = v4 == 0;
  v6 = &loc_804B1A6;
  if ( v5 )
    v6 = &locret_804B2E4;
  dword_8071240 = (int)v6;
  sub_80651D4(v2, v3, v9, v10);
  v18 = a2;
  v19 = *(_DWORD *)(a2 + 8);
  v7 = &loc_804B1D9;
  if ( *(_DWORD *)(a2 + 12) != v19 )
    v7 = &loc_804B204;
  dword_80711F0 = (int)v7;
  sub_80653A0(v9, v10, v11, v12, v13, v14, i, v16, v17, v18, v19, v20, v21, v22, savedregs);
  *(_BYTE *)(v18 + 40) |= 2u;
  *(_DWORD *)(v18 + 12) = (*(_DWORD *)(v18 + 24) + *(_DWORD *)(v18 + 12)) & ~*(_DWORD *)(v18 + 24);
  if ( *(_DWORD *)(v18 + 12) - *(_DWORD *)(v18 + 4) > (unsigned int)(*(_DWORD *)(v18 + 16) - *(_DWORD *)(v18 + 4)) )
    *(_DWORD *)(v18 + 12) = *(_DWORD *)(v18 + 16);
  *(_DWORD *)(v18 + 8) = *(_DWORD *)(v18 + 12);
  v20 = v19;
  fputs_unlocked(a1, stdout);
  for ( i = 0; i < v17; ++i )
  {
    v10 = *(_DWORD *)(4 * i + v20);
    printf(" %lu", v10);
  }
  return putchar_unlocked(10);
}
// 804B153: could not find valid save-restore pair for ebx
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 80653A0: using guessed type int __stdcall sub_80653A0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80711F0: using guessed type int dword_80711F0;
// 8071240: using guessed type int dword_8071240;

//----- (0804B2E6) --------------------------------------------------------
#error "804B33F: call analysis failed (funcsize=45)"

//----- (0804B362) --------------------------------------------------------
void sub_804B362()
{
  char v0; // bl
  bool v1; // al
  signed int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; i <= 255; ++i )
  {
    v0 = *(_BYTE *)(i + 134683369);
    v1 = (unsigned __int8)sub_8055B7E(i) || i == 126 || i == 45 || i == 46 || i == 95;
    *(_BYTE *)(i + 134683369) = v0 | v1;
  }
}

//----- (0804B3D4) --------------------------------------------------------
signed int __cdecl sub_804B3D4(int a1)
{
  int v2; // eax
  int v3; // [esp+28h] [ebp-20h]
  unsigned int v4; // [esp+2Ch] [ebp-1Ch]
  int i; // [esp+30h] [ebp-18h]
  unsigned int v6; // [esp+34h] [ebp-14h]
  char *s; // [esp+38h] [ebp-10h]
  unsigned int v8; // [esp+3Ch] [ebp-Ch]

  v4 = 5;
  do
  {
    v6 = v4;
    v4 = 0;
    for ( i = 0; i <= 11; ++i )
    {
      v3 = v6;
      s = nl_langinfo(i + 131086);
      if ( strchr(s, 37) )
        return 0;
      v8 = sub_805AF72(s, a1 + (i << 7), 128, (int)&v3, 0, 0);
      if ( v8 > 0x7F )
        return 0;
      v2 = v4;
      if ( v3 >= v4 )
        v2 = v3;
      v4 = v2;
    }
  }
  while ( v6 > v4 );
  return 1;
}

//----- (0804B4C2) --------------------------------------------------------
char *__fastcall sub_804B4C2(int a1, int a2)
{
  _BYTE *v2; // eax
  void *v3; // eax
  char *result; // eax
  int v5; // eax
  int v6; // [esp-4h] [ebp-65Ch]
  int v7[3]; // [esp+0h] [ebp-658h]
  char *v8; // [esp+Ch] [ebp-64Ch]
  char *v9; // [esp+10h] [ebp-648h]
  int *v10; // [esp+14h] [ebp-644h]
  int v11; // [esp+18h] [ebp-640h]
  int i; // [esp+2Ch] [ebp-62Ch]
  int j; // [esp+30h] [ebp-628h]
  int k; // [esp+34h] [ebp-624h]
  char *v15; // [esp+38h] [ebp-620h]
  char *v16; // [esp+3Ch] [ebp-61Ch]
  char *s; // [esp+40h] [ebp-618h]
  int v18; // [esp+44h] [ebp-614h]
  int v19; // [esp+48h] [ebp-610h]
  int v20; // [esp+4Ch] [ebp-60Ch]
  char v21; // [esp+50h] [ebp-608h]

  for ( i = 0; i <= 1; ++i )
  {
    v2 = sub_804B2E6((&off_80713BC)[i]);
    a2 = i;
    *(&v19 + i) = (int)v2;
  }
  if ( v19 )
  {
    result = (char *)(sub_804B3D4((int)&v21) ^ 1);
    if ( !(_BYTE)result )
    {
      for ( j = 0; j <= 1; ++j )
      {
        result = (&off_80713BC)[j];
        v16 = (&off_80713BC)[j];
        for ( k = 0; k <= 11; ++k )
        {
          s = (char *)(((k + 12 * j) << 7) + 134683625);
          if ( *(&v19 + j) )
          {
            result = (char *)(*(&v19 + j) - (_DWORD)v16);
            if ( (signed int)result > 128 )
              return result;
            v5 = *(&v19 + j);
            v18 = v5 - (_DWORD)v16;
            v11 = *(&v19 + j) + 2;
            v10 = &v7[32 * k - 386];
            v9 = v16;
            v8 = (char *)(v5 - (_DWORD)v16);
            result = (char *)snprintf(s, 0x80u, "%.*s%s%s", v5 - (_DWORD)v16, v16, v10, v11);
            v15 = result;
          }
          else
          {
            v8 = v16;
            result = (char *)snprintf(s, 0x80u, "%s", v16);
            v15 = result;
          }
          if ( (signed int)v15 < 0 || (signed int)v15 > 127 )
            return result;
        }
      }
      byte_80727E9 = 1;
    }
  }
  else
  {
    v6 = v20;
    v3 = &loc_804B53A;
    if ( v20 )
      v3 = &loc_804B53F;
    dword_807127C = (int)v3;
    result = (char *)sub_806506B(a1, a2);
  }
  return result;
}
// 806506B: using guessed type int __fastcall sub_806506B(_DWORD, _DWORD);
// 807127C: using guessed type int dword_807127C;
// 80727E9: using guessed type char byte_80727E9;
// 804B4C2: using guessed type int anonymous_0[3];

//----- (0804B6FD) --------------------------------------------------------
int __cdecl sub_804B6FD(unsigned __int64 *a1, unsigned int a2)
{
  return sub_8064BD9(*a1, a2, 0);
}

//----- (0804B744) --------------------------------------------------------
int __cdecl sub_804B744(_QWORD *a1, _QWORD *a2)
{
  return *a2 == *a1 && a2[1] == a1[1];
}

//----- (0804B7C8) --------------------------------------------------------
void __cdecl sub_804B7C8(void *ptr)
{
  free(ptr);
}

//----- (0804B7EB) --------------------------------------------------------
#error "804B852: call analysis failed (funcsize=32)"

//----- (0804B857) --------------------------------------------------------
#error "804B8BE: positive sp value has been found (funcsize=0)"

//----- (0804B8BF) --------------------------------------------------------
void __cdecl sub_804B8BF(void *ptr)
{
  void *v1; // [esp+8h] [ebp-10h]

  free(*(void **)ptr);
  free(*((void **)ptr + 1));
  free(v1);
}

//----- (0804B90D) --------------------------------------------------------
int __usercall sub_804B90D@<eax>(int a1@<ebx>, int edx0@<edx>, int a3@<ecx>, int a2)
{
  const char *v4; // eax
  bool v5; // zf
  void *v6; // eax
  int v7; // ebx
  int v8; // eax
  int v9; // edx
  int v10; // ecx
  void *v11; // eax
  int v12; // ebx
  int v13; // ecx
  int v14; // edx
  int v15; // eax
  void *v16; // eax
  int v18; // [esp-8h] [ebp-30h]
  int v19; // [esp-4h] [ebp-2Ch]
  const char *v20; // [esp+0h] [ebp-28h]
  const char *v21; // [esp+4h] [ebp-24h]
  int v22; // [esp+8h] [ebp-20h]
  int v23; // [esp+Ch] [ebp-1Ch]

  *(&v20 - 4) = (const char *)dword_80712FC[2 * a2];
  v4 = (const char *)*(&s1 + 2 * v22);
  *(&v20 - 3) = v4;
  v5 = *(&v20 - 4) == 0;
  v19 = (int)v4;
  v18 = a1;
  v6 = &loc_804B95C;
  if ( v5 )
    v6 = &loc_804BA07;
  dword_80711DC = (int)v6;
  v7 = v18;
  v8 = sub_806540E(a3, edx0);
  v5 = *(&v20 - 4) == (const char *)1;
  v19 = v8;
  v18 = v7;
  v11 = &loc_804B97B;
  if ( !v5 )
    v11 = &loc_804B9AD;
  dword_807127C = (int)v11;
  v12 = v18;
  sub_806506B(v10, v9);
  v14 = *(unsigned __int8 *)*(&v20 - 3);
  if ( (_BYTE)v14 != unk_8066929 )
  {
    if ( *(&v20 - 4) == (const char *)2 )
    {
      v22 = 2;
      v21 = "00";
      v20 = *(&v20 - 3);
      v15 = strncmp(v20, "00", 2u);
      v5 = v15 == 0;
      v19 = v15;
      v18 = v12;
      v16 = &loc_804B9EB;
      if ( v5 )
        v16 = &loc_804BA07;
      dword_807122C = (int)v16;
      sub_8065244(v20, v21, v22, v23);
    }
    dword_807127C = (int)&loc_804BA0C;
    sub_806506B(v13, v14);
  }
  return 0;
}
// 804B90D: could not find valid save-restore pair for ebx
// 806506B: using guessed type int __fastcall sub_806506B(_DWORD, _DWORD);
// 8065244: using guessed type int __stdcall sub_8065244(_DWORD, _DWORD, _DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;
// 807122C: using guessed type int dword_807122C;
// 807127C: using guessed type int dword_807127C;
// 80712FC: using guessed type int dword_80712FC[];

//----- (0804BA11) --------------------------------------------------------
size_t sub_804BA11()
{
  sub_80545A6((int)dword_80712FC);
  return sub_80545A6((int)&dword_8071304);
}
// 80712FC: using guessed type int dword_80712FC[];
// 8071304: using guessed type int dword_8071304;

//----- (0804BA31) --------------------------------------------------------
size_t __usercall sub_804BA31@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>)
{
  size_t result; // eax
  bool v4; // zf
  int v5; // edx
  int v6; // ecx
  void *v7; // eax

  result = (unsigned __int8)byte_807192D;
  if ( byte_807192D )
  {
    v4 = (unsigned __int8)sub_804B90D(a3, a1, a2, 4) == 0;
    v7 = &loc_804BA6F;
    if ( v4 )
      v7 = &locret_804BA93;
    dword_80711DC = (int)v7;
    sub_806540E(v6, v5);
    sub_80545A6((int)dword_80712FC);
    sub_80545A6((int)&unk_807131C);
    result = sub_80545A6((int)&dword_8071304);
  }
  return result;
}
// 80711DC: using guessed type int dword_80711DC;
// 80712FC: using guessed type int dword_80712FC[];
// 8071304: using guessed type int dword_8071304;
// 807192D: using guessed type char byte_807192D;

//----- (0804BA95) --------------------------------------------------------
int __cdecl sub_804BA95(int a1)
{
  int result; // eax

  result = dword_8071A09;
  if ( !dword_8071A09 )
  {
    result = a1;
    dword_8071A09 = a1;
  }
  return result;
}
// 8071A09: using guessed type int dword_8071A09;

//----- (0804BAAB) --------------------------------------------------------
int sub_804BAAB()
{
  int result; // eax

  result = dword_8071A09;
  if ( !dword_8071A09 )
    result = dword_8071A0D++ + 1;
  return result;
}
// 8071A09: using guessed type int dword_8071A09;
// 8071A0D: using guessed type int dword_8071A0D;

//----- (0804BAC6) --------------------------------------------------------
int sub_804BAC6()
{
  int result; // eax
  int v1; // [esp+0h] [ebp-A8h]
  int v2; // [esp+4h] [ebp-A4h]

  while ( 1 )
  {
    if ( !dword_8071A09 )
    {
      result = dword_8071A0D;
      if ( !dword_8071A0D )
        break;
    }
    if ( byte_807192F )
      sub_804BA11();
    fflush_unlocked(stdout);
    sigprocmask(0, &set, (sigset_t *)(&v1 - 34));
    *(&v1 - 36) = dword_8071A09;
    *(&v1 - 35) = dword_8071A0D;
    if ( *(&v1 - 35) )
    {
      dword_8071A0D = *(&v1 - 35) - 1;
      *(&v1 - 36) = 19;
    }
    else
    {
      v2 = 0;
      signal(*(&v1 - 36), 0);
    }
    raise(*(&v1 - 36));
    sigprocmask(2, (const sigset_t *)(&v1 - 34), 0);
  }
  return result;
}
// 807192F: using guessed type char byte_807192F;
// 8071A09: using guessed type int dword_8071A09;
// 8071A0D: using guessed type int dword_8071A0D;

//----- (0804BBCA) --------------------------------------------------------
__sighandler_t __cdecl sub_804BBCA(void (*a1)(int))
{
  __sighandler_t result; // eax
  void *v2; // eax
  signed int i; // [esp+10h] [ebp-A8h]
  signed int j; // [esp+10h] [ebp-A8h]
  signed int k; // [esp+10h] [ebp-A8h]
  void *v6; // [esp+14h] [ebp-A4h]
  char v7; // [esp+18h] [ebp-A0h]
  int v8; // [esp+98h] [ebp-20h]

  result = a1;
  if ( (_BYTE)a1 )
  {
    sigemptyset(&set);
    for ( i = 0; i <= 11; ++i )
    {
      sigaction(sig[i], 0, (struct sigaction *)&v6);
      if ( v6 != (void *)1 )
        sigaddset(&set, sig[i]);
    }
    result = (__sighandler_t)32;
    qmemcpy(&v7, &set, 0x80u);
    v8 = 0x10000000;
    for ( j = 0; j <= 11; ++j )
    {
      result = (__sighandler_t)sigismember(&set, sig[j]);
      if ( result )
      {
        if ( sig[j] == 20 )
          v2 = sub_804BAAB;
        else
          v2 = sub_804BA95;
        v6 = v2;
        result = (__sighandler_t)sigaction(sig[j], (const struct sigaction *)&v6, 0);
      }
    }
  }
  else
  {
    for ( k = 0; k <= 11; ++k )
    {
      result = (__sighandler_t)sigismember(&set, sig[k]);
      if ( result )
        result = signal(sig[k], 0);
    }
  }
  return result;
}

//----- (0804BD75) --------------------------------------------------------
__sighandler_t sub_804BD75()
{
  return sub_804BBCA((void (*)(int))1);
}

//----- (0804BD8D) --------------------------------------------------------
__sighandler_t sub_804BD8D()
{
  return sub_804BBCA(0);
}

//----- (0804BDA1) --------------------------------------------------------
#error "804BDBE: call analysis failed (funcsize=17)"

//----- (0804BDD1) --------------------------------------------------------
#error "804C0EB: call analysis failed (funcsize=464)"

//----- (0804C584) --------------------------------------------------------
int __cdecl sub_804C584(char *nptr)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  int v4; // [esp+28h] [ebp-10h]
  int v5; // [esp+2Ch] [ebp-Ch]

  v1 = sub_80624C3(nptr, 0, 0, (int)&v4, &s);
  if ( v1 )
  {
    if ( v1 == 1 )
    {
      dword_8071965 = -1;
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    v2 = v4;
    if ( v5 )
      v2 = -1;
    dword_8071965 = v2;
    result = 1;
  }
  return result;
}
// 8071965: using guessed type int dword_8071965;

//----- (0804C614) --------------------------------------------------------
#error "804C631: call analysis failed (funcsize=11)"

//----- (0804C636) --------------------------------------------------------
#error "804D819: positive sp value has been found (funcsize=500)"

//----- (0804D81A) --------------------------------------------------------
#error "804DB74: call analysis failed (funcsize=297)"

//----- (0804DC10) --------------------------------------------------------
#error "804DC48: call analysis failed (funcsize=61)"

//----- (0804DCDC) --------------------------------------------------------
int __usercall sub_804DCDC@<eax>(int a1@<ebx>)
{
  int result; // eax
  char *v2; // edx
  int v3; // ecx
  int v4; // eax
  bool v5; // zf
  void *v6; // eax
  int v7; // edx
  int v8; // ecx
  signed int v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  char *v13; // edx
  int v14; // eax
  void *v15; // eax
  signed int v16; // eax
  char *v17; // eax
  char *v18; // eax
  char *v19; // eax
  void *v20; // eax
  int v21; // [esp-8h] [ebp-50h]
  int v22; // [esp-4h] [ebp-4Ch]
  int v23; // [esp+0h] [ebp-48h]
  const char *v24; // [esp+4h] [ebp-44h]
  int v25; // [esp+8h] [ebp-40h]
  int v26; // [esp+Ch] [ebp-3Ch]
  char s1[2]; // [esp+1Dh] [ebp-2Bh]
  char *s; // [esp+20h] [ebp-28h]
  void *v29; // [esp+24h] [ebp-24h]
  int v30; // [esp+28h] [ebp-20h]
  _DWORD *v31; // [esp+2Ch] [ebp-1Ch]
  int v32; // [esp+30h] [ebp-18h]
  int v33; // [esp+34h] [ebp-14h]
  char *v34; // [esp+3Ch] [ebp-Ch]

  s = getenv("LS_COLORS");
  if ( !s || !*s )
  {
    v34 = getenv("COLORTERM");
    if ( !v34 || (result = (unsigned __int8)*v34, !(_BYTE)result) )
    {
      result = sub_804DC10() ^ 1;
      if ( (_BYTE)result )
        byte_807192D = 0;
    }
    return result;
  }
  v31 = 0;
  strcpy(s1, "??");
  ptr = sub_8061955(s);
  v29 = ptr;
  v32 = 1;
  while ( 2 )
  {
    switch ( v32 )
    {
      case 1:
        v4 = *s;
        if ( v4 != 42 )
        {
          if ( v4 == 58 )
          {
            ++s;
          }
          else
          {
            v5 = v4 == 0;
            v22 = *s;
            v21 = a1;
            v6 = &loc_804DDB8;
            if ( v5 )
              v6 = &loc_804DE5B;
            dword_8071268 = (int)v6;
            a1 = v21;
            sub_80650DF(v3, v2, v23);
            v10 = s;
            v2 = s++ + 1;
            s1[0] = *v10;
            v32 = 2;
          }
          continue;
        }
        v31 = (_DWORD *)sub_80617BF(0x14u);
        v31[4] = dword_8071931;
        dword_8071931 = (int)v31;
        ++s;
        v31[1] = v29;
        if ( (unsigned __int8)sub_804D81A(&v23 - 9, &v23 - 10, 1, v31) )
          v9 = 4;
        else
          v9 = 6;
        v32 = v9;
        dword_8071254 = (int)&loc_804DE7D;
        sub_806514F(v8, v7);
        v32 = 5;
LABEL_44:
        if ( v32 == 6 )
        {
          v19 = gettext("unparsable value for LS_COLORS environment variable");
          error(0, 0, v19);
          free(ptr);
          v33 = dword_8071931;
          v22 = dword_8071931;
          v21 = a1;
          v20 = &loc_804E0C7;
          if ( dword_8071931 )
            v20 = &loc_804E08E;
          dword_807122C = (int)v20;
          sub_8065244(v23, v24, v25, v26);
          byte_807192D = 0;
        }
        result = dword_8071334;
        if ( dword_8071334 == 6 )
        {
          result = strncmp(off_8071338, "target", 6u);
          if ( !result )
            byte_80718C5 = 1;
        }
        return result;
      case 2:
        if ( *s )
        {
          v11 = s;
          v2 = s++ + 1;
          s1[1] = *v11;
          v32 = 3;
        }
        else
        {
          v32 = 6;
        }
        continue;
      case 3:
        v32 = 6;
        v12 = s;
        v13 = s++ + 1;
        v14 = (unsigned __int8)*v12;
        v5 = (_BYTE)v14 == 61;
        v22 = v14;
        v21 = a1;
        v15 = &loc_804DEE7;
        if ( !v5 )
          v15 = &loc_804DFBE;
        dword_8071254 = (int)v15;
        a1 = v21;
        sub_806514F(v3, v13);
        v30 = 0;
        while ( 2 )
        {
          if ( (&off_80668C0)[v30] )
          {
            v24 = (&off_80668C0)[v30];
            if ( strcmp(s1, v24) )
            {
              ++v30;
              continue;
            }
            *(&::s1 + 2 * v30) = v29;
            v26 = 8 * v30 + 134681340;
            if ( (unsigned __int8)sub_804D81A(&v23 - 9, &s, 0, v26) )
              v16 = 1;
            else
              v16 = 6;
            v32 = v16;
          }
          break;
        }
        if ( v32 == 6 )
        {
          a1 = sub_80608B4((int)s1);
          v17 = gettext("unrecognized prefix: %s");
          v26 = a1;
          error(0, 0, v17);
        }
        continue;
      case 4:
        v18 = s;
        v2 = s++ + 1;
        if ( *v18 == 61 )
        {
          v31[3] = v29;
          if ( (unsigned __int8)sub_804D81A(&v23 - 9, &s, 0, v31 + 2) )
          {
            dword_8071254 = (int)&loc_804E035;
            sub_806514F(v3, v2);
          }
          v32 = 6;
        }
        else
        {
          v32 = 6;
        }
        continue;
      case 6:
        goto LABEL_44;
      default:
        abort();
        return result;
    }
  }
}
// 804D81A: using guessed type _DWORD __cdecl sub_804D81A(_DWORD, _DWORD, _DWORD, _DWORD);
// 80650DF: using guessed type int __fastcall sub_80650DF(_DWORD, _DWORD, _DWORD);
// 806514F: using guessed type int __fastcall sub_806514F(_DWORD, _DWORD);
// 8065244: using guessed type int __stdcall sub_8065244(_DWORD, _DWORD, _DWORD, _DWORD);
// 807122C: using guessed type int dword_807122C;
// 8071254: using guessed type int dword_8071254;
// 8071268: using guessed type int dword_8071268;
// 8071334: using guessed type int dword_8071334;
// 80718C5: using guessed type char byte_80718C5;
// 807192D: using guessed type char byte_807192D;
// 8071931: using guessed type int dword_8071931;

//----- (0804E106) --------------------------------------------------------
void sub_804E106()
{
  int v0; // ebx
  char *v1; // eax
  char *s; // [esp+18h] [ebp-10h]
  int v3; // [esp+1Ch] [ebp-Ch]

  s = getenv("QUOTING_STYLE");
  if ( s )
  {
    v3 = sub_8055721(s, (int)off_806A0E0, (int)dword_806A120, 4u);
    if ( v3 < 0 )
    {
      v0 = sub_80608B4((int)s);
      v1 = gettext("ignoring invalid value of environment variable QUOTING_STYLE: %s");
      error(0, 0, v1, v0);
    }
    else
    {
      sub_805ECC9(0, dword_806A120[v3]);
    }
  }
}
// 806A0E0: using guessed type char *off_806A0E0[10];

//----- (0804E1B3) --------------------------------------------------------
int __cdecl sub_804E1B3(int a1)
{
  int result; // eax

  result = a1;
  if ( (_BYTE)a1 )
  {
    dword_8071A11 = 2;
  }
  else
  {
    result = dword_8071A11;
    if ( !dword_8071A11 )
      dword_8071A11 = 1;
  }
  return result;
}
// 8071A11: using guessed type int dword_8071A11;

//----- (0804E1E6) --------------------------------------------------------
int __cdecl sub_804E1E6(int a1, char *format, int a3)
{
  const char *v3; // ebx
  int v4; // eax
  int v6; // [esp+0h] [ebp-28h]
  const char *v7; // [esp+Ch] [ebp-1Ch]
  char v8; // [esp+1Ch] [ebp-Ch]

  v8 = a1;
  v3 = (const char *)sub_8060445(4, a3);
  v4 = *__errno_location();
  v7 = v3;
  error(0, v4, v3, v3);
  return sub_804E1B3(*((unsigned __int8 *)&v6 - 12));
}

//----- (0804E27A) --------------------------------------------------------
int __cdecl sub_804E27A(char *a1, char *s, int a3)
{
  void *v3; // eax
  void *v4; // eax
  int result; // eax
  int v6; // [esp+1Ch] [ebp-Ch]

  v6 = sub_80617BF(0x10u);
  if ( s )
    v3 = sub_8061955(s);
  else
    v3 = 0;
  *(_DWORD *)(v6 + 4) = v3;
  if ( a1 )
    v4 = sub_8061955(a1);
  else
    v4 = 0;
  *(_DWORD *)v6 = v4;
  *(_BYTE *)(v6 + 8) = a3;
  *(_DWORD *)(v6 + 12) = dword_80718CD;
  result = v6;
  dword_80718CD = v6;
  return result;
}
// 80718CD: using guessed type int dword_80718CD;

//----- (0804E300) --------------------------------------------------------
unsigned int __cdecl sub_804E300(const char *a1, int a2, unsigned __int8 a3)
{
  bool v3; // zf
  int v4; // edx
  int v5; // ecx
  void *v6; // eax
  char *v7; // eax
  int v9; // [esp+0h] [ebp-348h]
  unsigned int v10; // [esp+33Ch] [ebp-Ch]

  v10 = __readgsdword(0x14u);
  *__errno_location() = 0;
  v3 = opendir(a1) == 0;
  v6 = &loc_804E3A5;
  if ( !v3 )
    v6 = &loc_804E3D3;
  dword_8071268 = (int)v6;
  sub_80650DF(v5, v4, v9);
  v7 = gettext("cannot open directory %s");
  sub_804E1E6(a3, v7, (int)a1);
  return __readgsdword(0x14u) ^ v10;
}
// 80650DF: using guessed type int __fastcall sub_80650DF(_DWORD, _DWORD, _DWORD);
// 8071268: using guessed type int dword_8071268;

//----- (0804EAE3) --------------------------------------------------------
_DWORD *__cdecl sub_804EAE3(int a1)
{
  _DWORD *result; // eax

  result = (_DWORD *)sub_80617BF(8u);
  *result = a1;
  result[1] = dword_8071949;
  dword_8071949 = (int)result;
  return result;
}

//----- (0804EB2A) --------------------------------------------------------
int __usercall sub_804EB2A@<eax>(int a1@<edx>, int a2@<ecx>, int a3)
{
  void *v3; // eax

  v3 = &loc_804EB87;
  if ( a3 )
    v3 = &loc_804EB38;
  dword_8071254 = (int)v3;
  sub_806514F(a2, a1);
  return 0;
}
// 806514F: using guessed type int __fastcall sub_806514F(_DWORD, _DWORD);
// 8071254: using guessed type int dword_8071254;

//----- (0804EB92) --------------------------------------------------------
#error "804EC4C: call analysis failed (funcsize=76)"

//----- (0804EC7A) --------------------------------------------------------
__int64 __cdecl sub_804EC7A(__int64 a1)
{
  return a1;
}

//----- (0804ECA4) --------------------------------------------------------
int sub_804ECA4()
{
  *__errno_location() = 95;
  return 0;
}

//----- (0804ECE0) --------------------------------------------------------
void __cdecl sub_804ECE0(void **a1)
{
  void *v1; // ST00_4

  free(*a1);
  free(a1[1]);
  free(a1[2]);
  if ( a1[29] != &unk_80712DC )
  {
    if ( (unsigned __int8)sub_804AF95() )
    {
      free(a1[29]);
    }
    else
    {
      v1 = a1[29];
      sub_8060B25();
    }
  }
}

//----- (0804ED49) --------------------------------------------------------
int sub_804ED49()
{
  int result; // eax
  unsigned int i; // [esp+18h] [ebp-10h]

  for ( i = 0; ; ++i )
  {
    result = dword_80718B5;
    if ( i >= dword_80718B5 )
      break;
    sub_804ECE0(*((void ***)dword_80718BD + i));
  }
  dword_80718B5 = 0;
  byte_80718B9 = 0;
  byte_80718DA = 0;
  dword_80718DD = 0;
  dword_80718E1 = 0;
  dword_80718E5 = 0;
  dword_80718ED = 0;
  dword_80718F1 = 0;
  dword_80718F5 = 0;
  dword_80718E9 = 0;
  dword_80718F9 = 0;
  dword_80718FD = 0;
  dword_8071901 = 0;
  return result;
}
// 80718B5: using guessed type int dword_80718B5;
// 80718B9: using guessed type char byte_80718B9;
// 80718DA: using guessed type char byte_80718DA;
// 80718DD: using guessed type int dword_80718DD;
// 80718E1: using guessed type int dword_80718E1;
// 80718E5: using guessed type int dword_80718E5;
// 80718F9: using guessed type int dword_80718F9;
// 80718FD: using guessed type int dword_80718FD;
// 8071901: using guessed type int dword_8071901;

//----- (0804EE15) --------------------------------------------------------
int __cdecl sub_804EE15(int a1)
{
  return a1 == 22 || a1 == 38 || sub_804AF67(a1);
}

//----- (0804EE4B) --------------------------------------------------------
signed int __cdecl sub_804EE4B(int a1, int a2, char a3)
{
  signed int result; // eax
  signed int v4; // eax
  int *v5; // eax
  int v6; // edx
  signed int v7; // [esp+1Ch] [ebp-Ch]

  if ( *(_QWORD *)(a2 + 12) == qword_80728A9 )
  {
    *__errno_location() = 95;
    result = -1;
  }
  else
  {
    if ( a3 )
      v4 = sub_8060B72();
    else
      v4 = sub_8060B92();
    v7 = v4;
    if ( v4 < 0 )
    {
      v5 = __errno_location();
      if ( (unsigned __int8)sub_804EE15(*v5) )
      {
        v6 = *(_DWORD *)(a2 + 16);
        LODWORD(qword_80728A9) = *(_DWORD *)(a2 + 12);
        HIDWORD(qword_80728A9) = v6;
      }
    }
    result = v7;
  }
  return result;
}
// 80728A9: using guessed type __int64 qword_80728A9;

//----- (0804EF33) --------------------------------------------------------
int __cdecl sub_804EF33(int a1, int a2)
{
  int v2; // ebx
  int result; // eax
  int v4; // eax
  bool v5; // zf
  bool v6; // sf
  void *v7; // eax
  int *v8; // eax
  int v9; // edx
  int v10; // [esp+8h] [ebp-20h]
  int v11; // [esp+Ch] [ebp-1Ch]
  int v12; // [esp+1Ch] [ebp-Ch]

  v2 = *(_DWORD *)(a2 + 16);
  if ( *(_QWORD *)(a2 + 12) == *(_QWORD *)&dword_80728B1 )
  {
    *__errno_location() = 95;
    result = 0;
  }
  else
  {
    *__errno_location() = 0;
    v4 = sub_8056C24();
    v12 = v4;
    v5 = v4 == 0;
    v6 = v4 < 0;
    v7 = &loc_804EFBF;
    if ( !v6 && !v5 )
      v7 = &loc_804EFEA;
    dword_807122C = (int)v7;
    sub_8065244(a1, a2 + 12, v10, v11);
    v8 = __errno_location();
    if ( (unsigned __int8)sub_804EE15(*v8) )
    {
      v9 = *(_DWORD *)(a2 + 16);
      dword_80728B1 = *(_DWORD *)(a2 + 12);
      dword_80728B5 = v9;
    }
    result = v12;
  }
  return result;
}
// 8065244: using guessed type int __stdcall sub_8065244(_DWORD, _DWORD, _DWORD, _DWORD);
// 807122C: using guessed type int dword_807122C;
// 80728A9: using guessed type __int64 qword_80728A9;
// 80728B1: using guessed type int dword_80728B1;
// 80728B5: using guessed type int dword_80728B5;

//----- (0804EFF4) --------------------------------------------------------
int __cdecl sub_804EFF4(int a1, int a2)
{
  int result; // eax
  int *v3; // eax
  int v4; // edx
  unsigned __int8 v5; // [esp+1Fh] [ebp-9h]

  if ( *(_QWORD *)(a2 + 12) == qword_80728B9 )
  {
    *__errno_location() = 95;
    result = 0;
  }
  else
  {
    v5 = sub_804ECA4();
    if ( v5 ^ 1 )
    {
      v3 = __errno_location();
      if ( (unsigned __int8)sub_804EE15(*v3) )
      {
        v4 = *(_DWORD *)(a2 + 16);
        LODWORD(qword_80728B9) = *(_DWORD *)(a2 + 12);
        HIDWORD(qword_80728B9) = v4;
      }
    }
    result = v5;
  }
  return result;
}
// 80728B5: using guessed type int dword_80728B5;
// 80728B9: using guessed type __int64 qword_80728B9;

//----- (0804F099) --------------------------------------------------------
int __cdecl sub_804F099(_BYTE *a1)
{
  int v3; // [esp+0h] [ebp-3Ch]
  const char *s; // [esp+8h] [ebp-34h]
  __int16 v5; // [esp+2Ah] [ebp-12h]
  int v6; // [esp+2Ch] [ebp-10h]

  v6 = sub_805FDD9((int)&v5, 2, (int)a1, -1, (int *)dword_8071955);
  return *a1 != *((_BYTE *)&v3 - 14) || strlen(s) != *(&v3 - 3);
}
// 8071955: using guessed type int dword_8071955;

//----- (0804F12C) --------------------------------------------------------
#error "804F2CB: call analysis failed (funcsize=96)"

//----- (0804F2D0) --------------------------------------------------------
#error "804F2F6: call analysis failed (funcsize=824)"

//----- (08050135) --------------------------------------------------------
#error "8050161: call analysis failed (funcsize=23)"

//----- (08050178) --------------------------------------------------------
#error "80501F7: call analysis failed (funcsize=41)"

//----- (080501FE) --------------------------------------------------------
void *__cdecl sub_80501FE(int a1, char *s)
{
  unsigned int v3; // eax
  int v4; // edx
  int v5; // ecx
  bool v6; // zf
  void *v7; // eax
  size_t v8; // eax
  char *v9; // eax
  size_t v10; // [esp+0h] [ebp-28h]
  int v11; // [esp+4h] [ebp-24h]
  int v12; // [esp+8h] [ebp-20h]
  int v13; // [esp+Ch] [ebp-1Ch]
  int v14; // [esp+10h] [ebp-18h]
  int v15; // [esp+14h] [ebp-14h]
  unsigned int v16; // [esp+18h] [ebp-10h]
  int v17; // [esp+1Ch] [ebp-Ch]
  int v18; // [esp+20h] [ebp-8h]
  int v19; // [esp+24h] [ebp-4h]

  if ( !s )
    return 0;
  if ( *s == 47 )
    return sub_8061955(s);
  v3 = sub_8056A3B((_BYTE *)a1);
  v16 = v3;
  v6 = v3 == 0;
  v7 = &loc_805025B;
  if ( !v6 )
    v7 = &loc_805027D;
  dword_8071268 = (int)v7;
  sub_80650DF(v5, v4, v10);
  sub_8061955(s);
  dword_8071218 = (int)&locret_80502DC;
  sub_80652BA(v10, v11, v12, v13, v14, v15, v16, v17, v18, v19);
  v8 = strlen(s);
  v10 = v16 + v8 + 2;
  v17 = sub_80617BF(v10);
  if ( *(_BYTE *)(v16 - 1 + a1) != 47 )
    ++v16;
  v9 = (char *)stpncpy(v17, a1, v16);
  strcpy(v9, s);
  return (void *)v17;
}
// 8049980: using guessed type int __cdecl stpncpy(_DWORD, _DWORD, _DWORD);
// 80650DF: using guessed type int __fastcall sub_80650DF(_DWORD, _DWORD, _DWORD);
// 80652BA: using guessed type int __stdcall sub_80652BA(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8071218: using guessed type int dword_8071218;
// 8071268: using guessed type int dword_8071268;

//----- (080502DE) --------------------------------------------------------
int __cdecl sub_80502DE(int a1, int a2)
{
  int v2; // ST1C_4

  v2 = sub_8056B4F(a2);
  return sub_804AC46(v2);
}
// 804AC46: using guessed type int __cdecl sub_804AC46(_DWORD);
// 8056B4F: using guessed type _DWORD __cdecl sub_8056B4F(_DWORD);

//----- (08050321) --------------------------------------------------------
int __cdecl sub_8050321(char *s, int a2)
{
  char *v2; // ST04_4
  char *ptr; // ST28_4
  int v4; // eax
  int v5; // ST2C_4
  int result; // eax
  int v7; // [esp+4h] [ebp-34h]
  int v8; // [esp+1Ch] [ebp-1Ch]
  unsigned int v9; // [esp+1Ch] [ebp-1Ch]
  int v10; // [esp+20h] [ebp-18h]
  int v11; // [esp+24h] [ebp-14h]

  if ( s && dword_80718A9 )
    sub_804E27A(0, s, 0);
  v8 = dword_80718B5;
  while ( 1 )
  {
    v4 = v8--;
    if ( !v4 )
      break;
    v11 = *((_DWORD *)dword_80718BD + v8);
    if ( (unsigned __int8)sub_8050135(v11) && ((s != 0) != 1 || (unsigned __int8)sub_80502DE(*(_DWORD *)v11, v7) ^ 1) )
    {
      if ( s && **(_BYTE **)v11 != 47 )
      {
        v2 = *(char **)v11;
        ptr = (char *)sub_8057085((int)s);
        sub_804E27A(ptr, *(char **)(v11 + 4), (unsigned __int8)a2);
        free(ptr);
      }
      else
      {
        sub_804E27A(*(char **)v11, *(char **)(v11 + 4), (unsigned __int8)a2);
      }
      if ( *(_DWORD *)(v11 + 108) == 9 )
        sub_804ECE0((void **)v11);
    }
  }
  v9 = 0;
  v10 = 0;
  while ( v9 < dword_80718B5 )
  {
    v5 = *((_DWORD *)dword_80718BD + v9);
    *((_DWORD *)dword_80718BD + v10) = *((_DWORD *)dword_80718BD + v9);
    v10 += *(_DWORD *)(v5 + 108) != 9;
    ++v9;
  }
  result = v10;
  dword_80718B5 = v10;
  return result;
}
// 8050135: using guessed type _DWORD __cdecl sub_8050135(_DWORD);
// 80718B5: using guessed type int dword_80718B5;

//----- (080504E5) --------------------------------------------------------
int __cdecl sub_80504E5(char *s1, char *s2)
{
  int v2; // edi
  int v3; // esi
  char *v4; // ebx
  int *v5; // eax
  int v7; // [esp+2Ch] [ebp-1Ch]

  *__errno_location() = 0;
  v7 = strcoll(s1, s2);
  if ( *__errno_location() )
  {
    v2 = sub_806086C(1, s2);
    v3 = sub_806086C(0, s1);
    v4 = gettext("cannot compare file names %s and %s");
    v5 = __errno_location();
    error(0, *v5, v4, v3, v2);
    sub_804E1B3(0);
    longjmp(env, 1);
  }
  return v7;
}
// 806086C: using guessed type _DWORD __cdecl sub_806086C(_DWORD, _DWORD);

//----- (080505A3) --------------------------------------------------------
int __cdecl sub_80505A3(int a1, int a2)
{
  int v2; // edx
  int result; // eax
  int v4; // [esp+0h] [ebp-38h]
  _DWORD *v5; // [esp+8h] [ebp-30h]
  _DWORD *v6; // [esp+Ch] [ebp-2Ch]
  int (__cdecl *v7)(_DWORD, _DWORD); // [esp+10h] [ebp-28h]
  _DWORD *v8; // [esp+20h] [ebp-18h]
  _DWORD *v9; // [esp+24h] [ebp-14h]
  int v10; // [esp+28h] [ebp-10h]

  sub_8060CFB(&v8, a1 + 12);
  sub_8060CFB(&v10, a2 + 12);
  v5 = v8;
  v6 = v9;
  v2 = *(&v4 - 3);
  v4 = *(&v4 - 4);
  *(&v4 - 7) = sub_8060DD7(v4, v2, (int)v8, (int)v9);
  if ( *(&v4 - 7) )
    result = *(&v4 - 7);
  else
    result = v7(*v5, *v6);
  return result;
}

//----- (08050641) --------------------------------------------------------
int __cdecl sub_8050641(int a1, int a2)
{
  _DWORD *v2; // edx
  int v3; // edx
  int result; // eax
  int v5; // [esp+0h] [ebp-38h]
  int v6; // [esp+4h] [ebp-34h]
  int v7; // [esp+8h] [ebp-30h]
  _DWORD *v8; // [esp+Ch] [ebp-2Ch]
  _DWORD *v9; // [esp+10h] [ebp-28h]
  int (__cdecl *v10)(_DWORD, _DWORD); // [esp+14h] [ebp-24h]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+28h] [ebp-10h]

  sub_8060D3C(&v11, a1 + 12);
  sub_8060D3C(&v12, a2 + 12);
  v2 = (_DWORD *)*(&v6 - 5);
  v7 = *(&v6 - 6);
  v8 = v2;
  v3 = *(&v6 - 3);
  v5 = *(&v6 - 4);
  *(&v6 - 7) = sub_8060DD7(v5, v3, v7, (int)v8);
  if ( *(&v6 - 7) )
    result = *(&v6 - 7);
  else
    result = v10(*v8, *v9);
  return result;
}

//----- (080506DF) --------------------------------------------------------
int __cdecl sub_80506DF(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+0h] [ebp-38h]
  _DWORD *v4; // [esp+8h] [ebp-30h]
  _DWORD *v5; // [esp+Ch] [ebp-2Ch]
  int (__cdecl *v6)(_DWORD, _DWORD); // [esp+10h] [ebp-28h]
  int v7; // [esp+1Ch] [ebp-1Ch]
  int v8; // [esp+20h] [ebp-18h]
  int v9; // [esp+24h] [ebp-14h]
  int v10; // [esp+28h] [ebp-10h]
  int v11; // [esp+2Ch] [ebp-Ch]

  sub_8060CD0(&v8, a1 + 12);
  sub_8060CD0(&v10, a2 + 12);
  v7 = sub_8060DD7(v10, v11, v8, v9);
  if ( *(&v3 - 7) )
    result = *(&v3 - 7);
  else
    result = v6(*v4, *v5);
  return result;
}

//----- (0805077D) --------------------------------------------------------
#error "805078C: call analysis failed (funcsize=11)"

//----- (0805079F) --------------------------------------------------------
#error "8050848: positive sp value has been found (funcsize=65)"

//----- (08050849) --------------------------------------------------------
#error "8050866: call analysis failed (funcsize=11)"

//----- (0805086B) --------------------------------------------------------
int __cdecl sub_805086B(int a1, _DWORD *a2, _DWORD *a3, int (__stdcall *a4)(_DWORD, _DWORD, int, int, int))
{
  int v5; // [esp+8h] [ebp-10h]
  int v6; // [esp+Ch] [ebp-Ch]
  int v7; // [esp+10h] [ebp-8h]

  return a4(*a2, *a3, v5, v6, v7);
}
// 805086B: could not find valid save-restore pair for ebp

//----- (0805089A) --------------------------------------------------------
int __cdecl sub_805089A(const char **a1, const char **a2, int (__cdecl *a3)(char *, char *))
{
  char *v3; // edx
  char *v4; // eax
  int result; // eax
  char *v6; // [esp+14h] [ebp-14h]
  char *v7; // [esp+18h] [ebp-10h]
  int v8; // [esp+1Ch] [ebp-Ch]

  v6 = strrchr(*a1, 46);
  v7 = strrchr(*a2, 46);
  if ( v7 )
    v3 = v7;
  else
    v3 = &s;
  if ( v6 )
    v4 = v6;
  else
    v4 = &s;
  v8 = a3(v4, v3);
  if ( v8 )
    result = v8;
  else
    result = a3((char *)*a1, (char *)*a2);
  return result;
}

//----- (08050922) --------------------------------------------------------
int __cdecl sub_8050922(int a1, int a2)
{
  return sub_80505A3(a1, a2);
}

//----- (08050944) --------------------------------------------------------
int __cdecl sub_8050944(int a1, int a2)
{
  return sub_80505A3(a1, a2);
}

//----- (08050966) --------------------------------------------------------
int __cdecl sub_8050966(int a1, int a2)
{
  return sub_80505A3(a2, a1);
}

//----- (08050988) --------------------------------------------------------
int __cdecl sub_8050988(int a1, int a2)
{
  return sub_80505A3(a2, a1);
}

//----- (080509AA) --------------------------------------------------------
#error "80509E6: call analysis failed (funcsize=51)"

//----- (08050A4A) --------------------------------------------------------
int __cdecl sub_8050A4A(int a1, int a2)
{
  char v2; // ST26_1
  void *v3; // eax
  int result; // eax
  int v5; // [esp+0h] [ebp-28h]
  int v6; // [esp+4h] [ebp-24h]
  int v7; // [esp+8h] [ebp-20h]
  int v8; // [esp+Ch] [ebp-1Ch]
  char v9; // [esp+1Fh] [ebp-9h]

  v2 = sub_8050135(a1);
  v9 = sub_8050135(a2);
  if ( v2 )
  {
    v3 = &loc_8050A96;
    if ( v9 == 1 )
      v3 = &loc_8050A9D;
    dword_807122C = (int)v3;
    sub_8065244(v5, v6, v7, v8);
    result = -1;
  }
  else if ( v9 )
  {
    result = 1;
  }
  else
  {
    result = sub_80505A3(a1, a2);
  }
  return result;
}
// 8050135: using guessed type _DWORD __cdecl sub_8050135(_DWORD);
// 8065244: using guessed type int __stdcall sub_8065244(_DWORD, _DWORD, _DWORD, _DWORD);
// 807122C: using guessed type int dword_807122C;

//----- (08050AD1) --------------------------------------------------------
#error "8050B18: call analysis failed (funcsize=43)"

//----- (08050B58) --------------------------------------------------------
int __cdecl sub_8050B58(int a1, int a2)
{
  int v2; // edx
  int v3; // ecx
  int result; // eax
  char v5; // [esp+1Eh] [ebp-Ah]
  char v6; // [esp+1Fh] [ebp-9h]

  v5 = sub_8050135(a1);
  v6 = sub_8050135(a2);
  if ( v5 && v6 != 1 )
  {
    dword_807127C = (int)&locret_8050BD9;
    sub_806506B(v3, v2);
  }
  if ( v5 != 1 && v6 )
    result = 1;
  else
    result = sub_80505A3(a2, a1);
  return result;
}
// 8050135: using guessed type _DWORD __cdecl sub_8050135(_DWORD);
// 806506B: using guessed type int __fastcall sub_806506B(_DWORD, _DWORD);
// 807127C: using guessed type int dword_807127C;

//----- (08050BDB) --------------------------------------------------------
int __cdecl sub_8050BDB(int a1, int a2)
{
  return sub_8050641(a1, a2);
}

//----- (08050BFD) --------------------------------------------------------
int __cdecl sub_8050BFD(int a1, int a2)
{
  return sub_8050641(a1, a2);
}

//----- (08050C1F) --------------------------------------------------------
int __cdecl sub_8050C1F(int a1, int a2)
{
  return sub_8050641(a2, a1);
}

//----- (08050C41) --------------------------------------------------------
int __cdecl sub_8050C41(int a1, int a2)
{
  return sub_8050641(a2, a1);
}

//----- (08050C63) --------------------------------------------------------
int __cdecl sub_8050C63(int a1, int a2)
{
  int v2; // edx
  int v3; // ecx
  void *v4; // eax
  char v6; // [esp+1Eh] [ebp-Ah]
  char v7; // [esp+1Fh] [ebp-9h]

  v6 = sub_8050135(a1);
  v7 = sub_8050135(a2);
  v4 = &loc_8050CA4;
  if ( !v6 )
    v4 = &loc_8050CB6;
  dword_80711DC = (int)v4;
  sub_806540E(v3, v2);
  if ( v7 != 1 )
    return -1;
  if ( v6 == 1 )
    return sub_8050641(a1, a2);
  return 1;
}
// 8050135: using guessed type _DWORD __cdecl sub_8050135(_DWORD);
// 80711DC: using guessed type int dword_80711DC;

//----- (08050CEA) --------------------------------------------------------
int __cdecl sub_8050CEA(int a1, int a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_8050135(a1);
  v4 = sub_8050135(a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_8050641(a1, a2);
}
// 8050135: using guessed type _DWORD __cdecl sub_8050135(_DWORD);

//----- (08050D58) --------------------------------------------------------
int __cdecl sub_8050D58(int a1, int a2)
{
  void *v3; // eax
  int v4; // edx
  int v5; // ecx
  int v6; // [esp+0h] [ebp-28h]
  int v7; // [esp+4h] [ebp-24h]
  int v8; // [esp+8h] [ebp-20h]
  int v9; // [esp+Ch] [ebp-1Ch]
  int v10; // [esp+10h] [ebp-18h]
  int v11; // [esp+14h] [ebp-14h]
  int v12; // [esp+18h] [ebp-10h]
  int v13; // [esp+1Ch] [ebp-Ch]
  int v14; // [esp+20h] [ebp-8h]
  int v15; // [esp+24h] [ebp-4h]

  BYTE2(v13) = sub_8050135(a1);
  HIBYTE(v13) = sub_8050135(a2);
  if ( BYTE2(v13) && HIBYTE(v13) != 1 )
    return -1;
  if ( BYTE2(v13) != 1 )
  {
    v3 = &loc_8050DBC;
    if ( !HIBYTE(v13) )
      v3 = &loc_8050DD8;
    dword_8071218 = (int)v3;
    sub_80652BA(v6, v7, v8, v9, v10, v11, v12, v13, v14, v15);
    dword_8071254 = (int)&locret_8050DF2;
    sub_806514F(v5, v4);
  }
  return sub_8050641(a2, a1);
}
// 8050135: using guessed type _DWORD __cdecl sub_8050135(_DWORD);
// 806514F: using guessed type int __fastcall sub_806514F(_DWORD, _DWORD);
// 80652BA: using guessed type int __stdcall sub_80652BA(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8071218: using guessed type int dword_8071218;
// 8071254: using guessed type int dword_8071254;

//----- (08050DF4) --------------------------------------------------------
int __cdecl sub_8050DF4(int a1, int a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_8050135(a1);
  v4 = sub_8050135(a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_8050641(a2, a1);
}
// 8050135: using guessed type _DWORD __cdecl sub_8050135(_DWORD);

//----- (08050E62) --------------------------------------------------------
int __cdecl sub_8050E62(int a1, int a2)
{
  return sub_80506DF(a1, a2);
}

//----- (08050E84) --------------------------------------------------------
int __cdecl sub_8050E84(int a1, int a2)
{
  return sub_80506DF(a1, a2);
}

//----- (08050EA6) --------------------------------------------------------
int __cdecl sub_8050EA6(int a1, int a2)
{
  return sub_80506DF(a2, a1);
}

//----- (08050EC8) --------------------------------------------------------
int __cdecl sub_8050EC8(int a1, int a2)
{
  return sub_80506DF(a2, a1);
}

//----- (08050EEA) --------------------------------------------------------
#error "8050F31: call analysis failed (funcsize=51)"

//----- (08050F8A) --------------------------------------------------------
int __cdecl sub_8050F8A(int a1, int a2)
{
  int v2; // edx
  int v3; // ecx
  int v5; // [esp+0h] [ebp-28h]
  char v6; // [esp+1Eh] [ebp-Ah]
  char v7; // [esp+1Fh] [ebp-9h]

  v6 = sub_8050135(a1);
  v7 = sub_8050135(a2);
  if ( v6 && v7 != 1 )
    return -1;
  if ( v6 != 1 )
  {
    if ( v7 )
    {
      dword_8071268 = (int)&locret_805100B;
      sub_80650DF(v3, v2, v5);
    }
  }
  return sub_80506DF(a1, a2);
}
// 8050135: using guessed type _DWORD __cdecl sub_8050135(_DWORD);
// 80650DF: using guessed type int __fastcall sub_80650DF(_DWORD, _DWORD, _DWORD);
// 8071268: using guessed type int dword_8071268;

//----- (0805100D) --------------------------------------------------------
int __cdecl sub_805100D(int a1, int a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_8050135(a1);
  v4 = sub_8050135(a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_80506DF(a2, a1);
}
// 8050135: using guessed type _DWORD __cdecl sub_8050135(_DWORD);

//----- (0805107B) --------------------------------------------------------
int __cdecl sub_805107B(int a1, int a2)
{
  int v2; // edx
  int v3; // ecx
  int result; // eax
  char v5; // [esp+1Eh] [ebp-Ah]
  char v6; // [esp+1Fh] [ebp-9h]

  v5 = sub_8050135(a1);
  v6 = sub_8050135(a2);
  if ( v5 && v6 != 1 )
  {
    dword_8071254 = (int)&locret_80510FC;
    sub_806514F(v3, v2);
  }
  if ( v5 != 1 && v6 )
    result = 1;
  else
    result = sub_80506DF(a2, a1);
  return result;
}
// 8050135: using guessed type _DWORD __cdecl sub_8050135(_DWORD);
// 806514F: using guessed type int __fastcall sub_806514F(_DWORD, _DWORD);
// 8071254: using guessed type int dword_8071254;

//----- (080510FE) --------------------------------------------------------
int __cdecl sub_80510FE(int a1, int a2)
{
  return sub_805077D(a1, a2, sub_80504E5);
}
// 805077D: using guessed type int __cdecl sub_805077D(_DWORD, _DWORD, _DWORD);

//----- (08051120) --------------------------------------------------------
int __cdecl sub_8051120(int a1, int a2)
{
  return sub_805077D(a1, a2, strcmp);
}
// 805077D: using guessed type int __cdecl sub_805077D(_DWORD, _DWORD, _DWORD);

//----- (08051142) --------------------------------------------------------
int __cdecl sub_8051142(int a1, int a2)
{
  return sub_805077D(a2, a1, sub_80504E5);
}
// 805077D: using guessed type int __cdecl sub_805077D(_DWORD, _DWORD, _DWORD);

//----- (08051164) --------------------------------------------------------
int __cdecl sub_8051164(int a1, int a2)
{
  return sub_805077D(a2, a1, strcmp);
}
// 805077D: using guessed type int __cdecl sub_805077D(_DWORD, _DWORD, _DWORD);

//----- (08051186) --------------------------------------------------------
int __cdecl sub_8051186(int a1, int a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_8050135(a1);
  v4 = sub_8050135(a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_805077D(a1, a2, sub_80504E5);
}
// 8050135: using guessed type _DWORD __cdecl sub_8050135(_DWORD);
// 805077D: using guessed type int __cdecl sub_805077D(_DWORD, _DWORD, _DWORD);

//----- (080511F4) --------------------------------------------------------
int __cdecl sub_80511F4(int a1, int a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_8050135(a1);
  v4 = sub_8050135(a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_805077D(a1, a2, strcmp);
}
// 8050135: using guessed type _DWORD __cdecl sub_8050135(_DWORD);
// 805077D: using guessed type int __cdecl sub_805077D(_DWORD, _DWORD, _DWORD);

//----- (08051262) --------------------------------------------------------
#error "80512C2: call analysis failed (funcsize=37)"

//----- (08051317) --------------------------------------------------------
int __cdecl sub_8051317(int a1, int a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_8050135(a1);
  v4 = sub_8050135(a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_805077D(a2, a1, strcmp);
}
// 8050135: using guessed type _DWORD __cdecl sub_8050135(_DWORD);
// 805077D: using guessed type int __cdecl sub_805077D(_DWORD, _DWORD, _DWORD);

//----- (08051385) --------------------------------------------------------
int __cdecl sub_8051385(int a1, int a2)
{
  return sub_8050849(a1, a2, sub_80504E5);
}
// 8050849: using guessed type int __cdecl sub_8050849(_DWORD, _DWORD, _DWORD);

//----- (080513A7) --------------------------------------------------------
int __cdecl sub_80513A7(int a1, int a2)
{
  return sub_8050849(a1, a2, strcmp);
}
// 8050849: using guessed type int __cdecl sub_8050849(_DWORD, _DWORD, _DWORD);

//----- (080513C9) --------------------------------------------------------
int __cdecl sub_80513C9(int a1, int a2)
{
  return sub_8050849(a2, a1, sub_80504E5);
}
// 8050849: using guessed type int __cdecl sub_8050849(_DWORD, _DWORD, _DWORD);

//----- (080513EB) --------------------------------------------------------
int __cdecl sub_80513EB(int a1, int a2)
{
  return sub_8050849(a2, a1, strcmp);
}
// 8050849: using guessed type int __cdecl sub_8050849(_DWORD, _DWORD, _DWORD);

//----- (0805140D) --------------------------------------------------------
int __cdecl sub_805140D(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-28h]
  int v4; // [esp+4h] [ebp-24h]
  int v5; // [esp+8h] [ebp-20h]
  int v6; // [esp+Ch] [ebp-1Ch]
  char v7; // [esp+1Eh] [ebp-Ah]
  char v8; // [esp+1Fh] [ebp-9h]

  v7 = sub_8050135(a1);
  v8 = sub_8050135(a2);
  if ( v7 && v8 != 1 )
    return -1;
  if ( v7 != 1 )
  {
    if ( v8 )
    {
      dword_807122C = (int)&locret_805148E;
      sub_8065244(v3, v4, v5, v6);
    }
  }
  return sub_8050849(a1, a2, sub_80504E5);
}
// 8050135: using guessed type _DWORD __cdecl sub_8050135(_DWORD);
// 8050849: using guessed type int __cdecl sub_8050849(_DWORD, _DWORD, _DWORD);
// 8065244: using guessed type int __stdcall sub_8065244(_DWORD, _DWORD, _DWORD, _DWORD);
// 807122C: using guessed type int dword_807122C;

//----- (08051490) --------------------------------------------------------
#error "80514D7: call analysis failed (funcsize=45)"

//----- (0805151B) --------------------------------------------------------
int __cdecl sub_805151B(int a1, int a2)
{
  int v2; // edx
  int v3; // ecx
  void *v4; // eax
  int v6; // [esp+0h] [ebp-28h]
  int v7; // [esp+0h] [ebp-28h]
  int v8; // [esp+4h] [ebp-24h]
  int v9; // [esp+4h] [ebp-24h]
  int v10; // [esp+8h] [ebp-20h]
  int v11; // [esp+Ch] [ebp-1Ch]
  char v12; // [esp+1Eh] [ebp-Ah]
  char v13; // [esp+1Fh] [ebp-9h]

  v12 = sub_8050135(a1);
  v13 = sub_8050135(a2);
  v4 = &loc_805155C;
  if ( !v12 )
    v4 = &loc_805156E;
  dword_8071240 = (int)v4;
  sub_80651D4(v3, v2, v6, v8);
  if ( v13 != 1 )
    return -1;
  if ( v12 != 1 )
  {
    dword_807122C = (int)&locret_80515B5;
    sub_8065244(v7, v9, v10, v11);
  }
  return sub_8050849(a2, a1, sub_80504E5);
}
// 8050135: using guessed type _DWORD __cdecl sub_8050135(_DWORD);
// 8050849: using guessed type int __cdecl sub_8050849(_DWORD, _DWORD, _DWORD);
// 8065244: using guessed type int __stdcall sub_8065244(_DWORD, _DWORD, _DWORD, _DWORD);
// 807122C: using guessed type int dword_807122C;
// 8071240: using guessed type int dword_8071240;

//----- (080515B7) --------------------------------------------------------
#error "80515FE: call analysis failed (funcsize=43)"

//----- (0805163E) --------------------------------------------------------
int __cdecl sub_805163E(const char **a1, const char **a2)
{
  return sub_805089A(a1, a2, sub_80504E5);
}

//----- (08051660) --------------------------------------------------------
int __cdecl sub_8051660(const char **a1, const char **a2)
{
  return sub_805089A(a1, a2, (int (__cdecl *)(char *, char *))strcmp);
}

//----- (08051682) --------------------------------------------------------
int __cdecl sub_8051682(const char **a1, const char **a2)
{
  return sub_805089A(a2, a1, sub_80504E5);
}

//----- (080516A4) --------------------------------------------------------
int __cdecl sub_80516A4(const char **a1, const char **a2)
{
  return sub_805089A(a2, a1, (int (__cdecl *)(char *, char *))strcmp);
}

//----- (080516C6) --------------------------------------------------------
int __cdecl sub_80516C6(const char **a1, const char **a2)
{
  int v2; // edx
  int v3; // ecx
  int result; // eax
  void *v5; // eax
  char v6; // [esp+1Eh] [ebp-Ah]
  char v7; // [esp+1Fh] [ebp-9h]

  v6 = sub_8050135(a1);
  v7 = sub_8050135(a2);
  if ( v6 && v7 != 1 )
    return -1;
  v5 = &loc_8051724;
  if ( v6 == 1 )
    v5 = &loc_8051731;
  dword_807127C = (int)v5;
  sub_806506B(v3, v2);
  if ( v7 )
    result = 1;
  else
    result = sub_805089A(a1, a2, sub_80504E5);
  return result;
}
// 8050135: using guessed type _DWORD __cdecl sub_8050135(_DWORD);
// 806506B: using guessed type int __fastcall sub_806506B(_DWORD, _DWORD);
// 807127C: using guessed type int dword_807127C;

//----- (0805174D) --------------------------------------------------------
int __cdecl sub_805174D(const char **a1, const char **a2)
{
  void *v2; // eax
  int result; // eax
  int v4; // [esp+0h] [ebp-28h]
  int v5; // [esp+4h] [ebp-24h]
  int v6; // [esp+8h] [ebp-20h]
  int v7; // [esp+Ch] [ebp-1Ch]
  int v8; // [esp+10h] [ebp-18h]
  int v9; // [esp+14h] [ebp-14h]
  int v10; // [esp+18h] [ebp-10h]
  int v11; // [esp+1Ch] [ebp-Ch]
  int v12; // [esp+20h] [ebp-8h]
  int v13; // [esp+24h] [ebp-4h]

  BYTE2(v11) = sub_8050135(a1);
  HIBYTE(v11) = sub_8050135(a2);
  if ( BYTE2(v11) )
  {
    v2 = &loc_8051799;
    if ( HIBYTE(v11) == 1 )
      v2 = &loc_80517A0;
    dword_8071218 = (int)v2;
    sub_80652BA(v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);
    result = -1;
  }
  else if ( HIBYTE(v11) )
  {
    result = 1;
  }
  else
  {
    result = sub_805089A(a1, a2, (int (__cdecl *)(char *, char *))strcmp);
  }
  return result;
}
// 8050135: using guessed type _DWORD __cdecl sub_8050135(_DWORD);
// 80652BA: using guessed type int __stdcall sub_80652BA(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8071218: using guessed type int dword_8071218;

//----- (080517D4) --------------------------------------------------------
int __cdecl sub_80517D4(const char **a1, const char **a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_8050135(a1);
  v4 = sub_8050135(a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_805089A(a2, a1, sub_80504E5);
}
// 8050135: using guessed type _DWORD __cdecl sub_8050135(_DWORD);

//----- (08051842) --------------------------------------------------------
int __cdecl sub_8051842(const char **a1, const char **a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_8050135(a1);
  v4 = sub_8050135(a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_805089A(a2, a1, (int (__cdecl *)(char *, char *))strcmp);
}
// 8050135: using guessed type _DWORD __cdecl sub_8050135(_DWORD);

//----- (080518B0) --------------------------------------------------------
int __cdecl sub_80518B0(char **a1, char **a2)
{
  return sub_805765F(*a1, *a2);
}

//----- (080518CE) --------------------------------------------------------
int __cdecl sub_80518CE(char **a1, char **a2)
{
  return sub_80518B0(a1, a2);
}

//----- (080518E8) --------------------------------------------------------
int __cdecl sub_80518E8(char **a1, char **a2)
{
  return sub_80518B0(a2, a1);
}

//----- (08051902) --------------------------------------------------------
int __cdecl sub_8051902(int a1, int a2)
{
  int v2; // eax
  int v3; // edx
  int v4; // ecx
  bool v5; // zf
  void *v6; // eax
  int v8; // [esp-4h] [ebp-2Ch]
  int v9; // [esp+0h] [ebp-28h]
  char **v10; // [esp+8h] [ebp-20h]
  char **v11; // [esp+Ch] [ebp-1Ch]
  char v12; // [esp+1Eh] [ebp-Ah]
  char v13; // [esp+1Fh] [ebp-9h]

  v12 = sub_8050135(a1);
  v2 = sub_8050135(a2);
  v13 = v2;
  v5 = *((_BYTE *)&v9 - 10) == 0;
  v8 = v2;
  v6 = &loc_8051963;
  if ( v5 )
    v6 = &loc_8051975;
  dword_807127C = (int)v6;
  sub_806506B(v4, v3);
  if ( *((_BYTE *)&v9 - 9) != 1 )
    return -1;
  if ( *((_BYTE *)&v9 - 10) != 1 && *((_BYTE *)&v9 - 9) )
    return 1;
  return sub_80518B0(v10, v11);
}
// 8050135: using guessed type _DWORD __cdecl sub_8050135(_DWORD);
// 806506B: using guessed type int __fastcall sub_806506B(_DWORD, _DWORD);
// 807127C: using guessed type int dword_807127C;

//----- (080519A1) --------------------------------------------------------
int __cdecl sub_80519A1(char **a1, char **a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_8050135(a1);
  v4 = sub_8050135(a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_80518B0(a2, a1);
}
// 8050135: using guessed type _DWORD __cdecl sub_8050135(_DWORD);

//----- (08051A07) --------------------------------------------------------
int sub_8051A07()
{
  int result; // eax
  unsigned int i; // [esp+Ch] [ebp-8h]

  for ( i = 0; ; ++i )
  {
    result = dword_80718B5;
    if ( i >= dword_80718B5 )
      break;
    *((_DWORD *)dword_80718BD + i) = (char *)dword_80718AD + 136 * i;
  }
  return result;
}
// 80718B5: using guessed type int dword_80718B5;

//----- (08051A63) --------------------------------------------------------
#error "8051A96: call analysis failed (funcsize=19)"

//----- (08051A9B) --------------------------------------------------------
#error "8051BF0: positive sp value has been found (funcsize=69)"

//----- (08051BF3) --------------------------------------------------------
#error "8051CBC: call analysis failed (funcsize=86)"

//----- (08051D47) --------------------------------------------------------
int __cdecl sub_8051D47(int a1, int a2, unsigned __int8 a3, int a4)
{
  int *v4; // ebp
  char *v5; // eax
  int v7; // [esp+0h] [ebp-38h]
  int v8; // [esp+Ch] [ebp-2Ch]
  int v9; // [esp+10h] [ebp-28h]
  int v10; // [esp+14h] [ebp-24h]
  unsigned __int8 v11; // [esp+1Ch] [ebp-1Ch]
  int savedregs; // [esp+38h] [ebp+0h]

  v4 = &savedregs;
  v11 = a3;
  if ( byte_80727E9 )
  {
    v4 = &v7;
    v5 = (char *)(((*(_DWORD *)(a4 + 16) + 12 * v11) << 7) + 134683625);
  }
  else
  {
    v5 = (&off_80713BC)[v11];
  }
  *(v4 - 3) = (int)v5;
  v10 = v4[7];
  v9 = v4[6];
  v8 = v10;
  return sub_805BD30(*(&v7 - 3), v10, *(&v7 - 3), v10, v9, v10);
}
// 80727E9: using guessed type char byte_80727E9;

//----- (08051DEB) --------------------------------------------------------
int sub_8051DEB()
{
  time_t timer; // [esp+2Ch] [ebp-42Ch]
  int v2; // [esp+30h] [ebp-428h]
  struct tm tp; // [esp+34h] [ebp-424h]
  char v4; // [esp+63h] [ebp-3F5h]
  unsigned int v5; // [esp+44Ch] [ebp-Ch]

  v5 = __readgsdword(0x14u);
  if ( dword_80713C8 < 0 )
  {
    timer = 0;
    if ( sub_8063673(dword_8071969, &timer, &tp) )
    {
      v2 = sub_8051D47((int)&v4, 1001, 0, (int)&tp);
      if ( v2 )
        dword_80713C8 = sub_805B412(&v4);
    }
    if ( dword_80713C8 < 0 )
      dword_80713C8 = 0;
  }
  return dword_80713C8;
}
// 805B412: using guessed type _DWORD __cdecl sub_805B412(_DWORD);
// 80713C8: using guessed type int dword_80713C8;

//----- (08051ED7) --------------------------------------------------------
int __cdecl sub_8051ED7(char *s, int a2, int a3)
{
  int *v3; // ebp
  int v4; // eax
  int v5; // ecx
  int v6; // eax
  int v7; // edx
  bool v8; // zf
  void *v9; // eax
  int result; // eax
  int v11; // [esp-4h] [ebp-2Ch]
  int v12; // [esp+0h] [ebp-28h]
  int v13; // [esp+4h] [ebp-24h]
  const char *v14; // [esp+8h] [ebp-20h]
  int v15; // [esp+14h] [ebp-14h]
  int v16; // [esp+1Ch] [ebp-Ch]
  int savedregs; // [esp+28h] [ebp+0h]

  v3 = &savedregs;
  if ( s )
  {
    v13 = 0;
    v16 = a3 - sub_805B3E5(s);
    v4 = 0;
    v3 = &v12;
    if ( *(&v12 - 3) >= 0 )
      v4 = *(&v12 - 3);
    *(&v12 - 4) = v4;
    fputs_unlocked(v14, stdout);
    *(&v12 - 5) = *(&v12 - 4) + strlen(v14);
    putchar_unlocked(32);
    v6 = *(&v12 - 4);
    v7 = v6 - 1;
    *(&v12 - 4) = v6 - 1;
    v8 = v6 == 0;
    v11 = v6;
    v9 = &loc_8051F7D;
    if ( !v8 )
      v9 = &loc_8051F4B;
    dword_807127C = (int)v9;
    sub_806506B(v5, v7);
  }
  else
  {
    v14 = (const char *)a2;
    v13 = a3;
    printf("%*lu ", a3, a2);
    v15 = a3;
  }
  result = dword_8071A1D + *(v3 - 5) + 1;
  dword_8071A1D += *(v3 - 5) + 1;
  return result;
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 806506B: using guessed type int __fastcall sub_806506B(_DWORD, _DWORD);
// 807127C: using guessed type int dword_807127C;
// 8071A1D: using guessed type int dword_8071A1D;

//----- (08051FC6) --------------------------------------------------------
int __cdecl sub_8051FC6(__uid_t uid, int a2, int a3)
{
  int *v3; // ebp
  char *v4; // eax
  int v6; // [esp+0h] [ebp-18h]
  char v7; // [esp+Ch] [ebp-Ch]
  int savedregs; // [esp+18h] [ebp+0h]

  v3 = &savedregs;
  v7 = a3;
  if ( (_BYTE)a3 == 1 )
  {
    if ( byte_8071913 )
    {
      v4 = 0;
    }
    else
    {
      v3 = &v6;
      v4 = (char *)sub_805A7BF(uid);
    }
  }
  else
  {
    v4 = "?";
  }
  return sub_8051ED7(v4, v3[2], v3[3]);
}
// 8071913: using guessed type char byte_8071913;

//----- (08052039) --------------------------------------------------------
#error "8052063: call analysis failed (funcsize=39)"

//----- (080520BA) --------------------------------------------------------
int __cdecl __noreturn sub_80520BA(char *a1, int a2)
{
  int v2; // ecx
  int v3; // edx
  unsigned int v4; // et1
  int (*v5)(); // eax
  int v7; // [esp+0h] [ebp-38h]
  int v8; // [esp+4h] [ebp-34h]
  int v9; // [esp+8h] [ebp-30h]
  char *v10; // [esp+Ch] [ebp-2Ch]
  int v11; // [esp+1Ch] [ebp-1Ch]
  char s; // [esp+21h] [ebp-17h]
  unsigned int v13; // [esp+2Ch] [ebp-Ch]

  v10 = a1;
  v13 = __readgsdword(0x14u);
  if ( a1 )
  {
    v8 = 0;
    v11 = sub_805B3E5(v10);
  }
  else
  {
    v9 = a2;
    sprintf((char *)&v7 - 23, "%lu", a2, v10);
    strlen(&s);
  }
  v4 = __readgsdword(0x14u);
  v3 = v4 ^ v13;
  v5 = (int (*)())&loc_805214A;
  if ( v4 == v13 )
    v5 = sub_805214F;
  dword_8071254 = (int)v5;
  return sub_806514F(v2, v3);
}
// 805214F: using guessed type int sub_805214F();
// 806514F: using guessed type int __fastcall sub_806514F(_DWORD, _DWORD);
// 8071254: using guessed type int dword_8071254;

//----- (0805214F) --------------------------------------------------------
#error "8052150: positive sp value has been found (funcsize=0)"

//----- (08052151) --------------------------------------------------------
void __cdecl __noreturn sub_8052151(__uid_t uid)
{
  char *v1; // eax

  if ( byte_8071913 )
    v1 = 0;
  else
    v1 = (char *)sub_805A7BF(uid);
  sub_80520BA(v1, uid);
}
// 8071913: using guessed type char byte_8071913;

//----- (08052191) --------------------------------------------------------
void __cdecl __noreturn sub_8052191(__gid_t gid)
{
  char *v1; // eax

  if ( byte_8071913 )
    v1 = 0;
  else
    v1 = (char *)sub_805AA24(gid);
  sub_80520BA(v1, gid);
}
// 8071913: using guessed type char byte_8071913;

//----- (080521D3) --------------------------------------------------------
const char *__cdecl sub_80521D3(int a1, unsigned int a2, int a3)
{
  void *v3; // eax
  int v4; // edx
  int v5; // ecx
  int v7; // [esp+0h] [ebp-18h]
  int v8; // [esp+4h] [ebp-14h]
  int v9; // [esp+8h] [ebp-10h]
  int v10; // [esp+Ch] [ebp-Ch]

  if ( a2 <= 0x14 )
    __assert_fail("INT_BUFSIZE_BOUND (uintmax_t) <= buflen", "src/ls.c", 0xFA7u, "format_inode");
  v3 = &loc_805222B;
  if ( !*(_BYTE *)(a3 + 120) )
    v3 = &loc_805226D;
  dword_807122C = (int)v3;
  sub_8065244(v7, v8, v9, v10);
  if ( *(_QWORD *)(a3 + 100) )
  {
    sub_805ADA7(*(_QWORD *)(a3 + 100), a1);
    dword_80711DC = (int)&locret_8052272;
    sub_806540E(v5, v4);
  }
  return "?";
}
// 8065244: using guessed type int __stdcall sub_8065244(_DWORD, _DWORD, _DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;
// 807122C: using guessed type int dword_807122C;

//----- (08052274) --------------------------------------------------------
int __usercall __noreturn sub_8052274@<eax>(const char *a1@<ebx>, int a2)
{
  int v2; // edx
  int v3; // ecx
  int v4; // edx
  int v5; // ecx
  void *v6; // eax
  int v7; // ecx
  int v8; // edx
  size_t v9; // eax
  void *v10; // eax
  char *v11; // eax
  int v12; // ebx
  int v13; // ebx
  int v14; // edx
  int v15; // ecx
  char *v16; // eax
  char *v17; // eax
  char *v18; // edx
  const char *v19; // eax
  size_t v20; // eax
  int v21; // ecx
  int v22; // edx
  void *v23; // eax
  int v24; // edx
  unsigned int v25; // eax
  int v26; // ebx
  int v27; // esi
  int v28; // edx
  unsigned int v29; // eax
  int v30; // eax
  int v31; // ecx
  int v32; // edx
  int v33; // ecx
  char *v34; // eax
  int v35; // ebx
  int v36; // esi
  int v37; // edi
  int v38; // edx
  __int64 v39; // rax
  int v40; // ebx
  int v41; // ebx
  int v42; // edx
  int v43; // ecx
  char *v44; // eax
  char *v45; // eax
  char *v46; // edx
  char *v47; // ecx
  int v48; // edx
  int v49; // eax
  bool v50; // zf
  void *v51; // eax
  struct tm *v52; // eax
  bool v53; // al
  void *v54; // eax
  const char *v55; // ebx
  char *v56; // eax
  size_t v57; // eax
  int v58; // eax
  unsigned __int64 v59; // rax
  unsigned int v60; // et1
  void (*v61)(); // eax
  const char *v63; // [esp-8h] [ebp-11A0h]
  int v64; // [esp-4h] [ebp-119Ch]
  unsigned __int64 v65; // [esp+0h] [ebp-1198h]
  unsigned __int64 v66; // [esp+8h] [ebp-1190h]
  const char *v67; // [esp+10h] [ebp-1188h]
  int v68; // [esp+14h] [ebp-1184h]
  int v69; // [esp+18h] [ebp-1180h]
  int v70; // [esp+1Ch] [ebp-117Ch]
  __int64 v71; // [esp+20h] [ebp-1178h]
  int v72; // [esp+28h] [ebp-1170h]
  int v73; // [esp+2Ch] [ebp-116Ch]
  int v74; // [esp+30h] [ebp-1168h]
  int v75; // [esp+34h] [ebp-1164h]
  struct tm *v76; // [esp+38h] [ebp-1160h]
  char *s; // [esp+3Ch] [ebp-115Ch]
  char *v78; // [esp+40h] [ebp-1158h]
  int v79; // [esp+44h] [ebp-1154h]
  char *v80; // [esp+48h] [ebp-1150h]
  int v81; // [esp+4Ch] [ebp-114Ch]
  int v82; // [esp+50h] [ebp-1148h]
  int v83; // [esp+54h] [ebp-1144h]
  __int64 timer; // [esp+58h] [ebp-1140h]
  int v85; // [esp+60h] [ebp-1138h]
  int v86; // [esp+64h] [ebp-1134h]
  struct tm tp; // [esp+68h] [ebp-1130h]
  char v88; // [esp+94h] [ebp-1104h]
  _BYTE v89[3]; // [esp+95h] [ebp-1103h]
  int v90; // [esp+98h] [ebp-1100h]
  int v91; // [esp+9Ch] [ebp-10FCh]
  int v92; // [esp+A0h] [ebp-10F8h]
  int v93; // [esp+A4h] [ebp-10F4h]
  int v94; // [esp+A8h] [ebp-10F0h]
  int v95; // [esp+ACh] [ebp-10ECh]
  int v96; // [esp+B0h] [ebp-10E8h]
  int v97; // [esp+B4h] [ebp-10E4h]
  int v98; // [esp+B8h] [ebp-10E0h]
  int v99; // [esp+BCh] [ebp-10DCh]
  int v100; // [esp+C0h] [ebp-10D8h]
  int v101; // [esp+C4h] [ebp-10D4h]
  int v102; // [esp+C8h] [ebp-10D0h]
  char v103; // [esp+341h] [ebp-E57h]
  unsigned int v104; // [esp+117Ch] [ebp-1Ch]

  v73 = a2;
  v104 = __readgsdword(0x14u);
  if ( *(_BYTE *)(a2 + 120) )
  {
    sub_8057068(v73 + 12, (int)&v88);
    dword_80711DC = (int)&loc_8052322;
    sub_806540E(v3, v2);
  }
  v88 = byte_80667CD[*(_DWORD *)(v73 + 108)];
  memset(v89, 63, 0xAu);
  HIBYTE(v91) = 0;
  if ( byte_80718DA != 1 )
  {
    BYTE2(v91) = 0;
    dword_80711DC = (int)&loc_805237A;
    sub_806540E(v5, v4);
  }
  if ( *(_DWORD *)(v73 + 124) == 1 )
  {
    BYTE2(v91) = 46;
  }
  else if ( *(_DWORD *)(v73 + 124) == 2 )
  {
    BYTE2(v91) = 43;
  }
  if ( dword_8071909 == 1 )
  {
    sub_8060CFB(&v71, v73 + 12);
    v8 = HIDWORD(v71);
    timer = v71;
  }
  else
  {
    if ( (unsigned int)dword_8071909 >= 1 )
    {
      v64 = dword_8071909;
      v63 = a1;
      v6 = &loc_80523A7;
      if ( dword_8071909 == 2 )
        v6 = &loc_805241C;
      dword_8071254 = (int)v6;
      sub_806514F(v5, v4);
      abort();
    }
    sub_8060D3C(&v71, v73 + 12);
    v8 = HIDWORD(v71);
    timer = v71;
  }
  s = &v103;
  if ( byte_807193A )
  {
    HIDWORD(v66) = sub_80521D3((int)&v97 + 1, 0x15u, v73);
    LODWORD(v66) = dword_80718DD;
    sprintf(s, "%*s ");
    v9 = strlen(s);
    s += v9;
  }
  v64 = (unsigned __int8)byte_8071914;
  v63 = a1;
  v10 = &loc_80524EC;
  if ( !byte_8071914 )
    v10 = &loc_8052611;
  dword_807127C = (int)v10;
  sub_806506B(v7, v8);
  if ( *(_BYTE *)(v73 + 120) == 1 )
    v11 = (char *)sub_8059775(
                    *(_DWORD *)(v73 + 68),
                    *(_DWORD *)(v73 + 72),
                    (char *)&v65 - 4323,
                    dword_8071915,
                    512,
                    0,
                    dword_8071919,
                    dword_807191D);
  else
    v11 = "?";
  v78 = v11;
  v12 = dword_80718E1;
  v65 = (unsigned int)v11;
  v13 = v12 - sub_805B3E5(v11);
  dword_8071290 = (int)&loc_80525C0;
  sub_8064FFD(
    v15,
    v14,
    v65,
    HIDWORD(v65),
    v66,
    HIDWORD(v66),
    v67,
    v68,
    v69,
    v70,
    v71,
    HIDWORD(v71),
    v72,
    v73,
    v74,
    v75,
    v76,
    s,
    v78,
    v13,
    v80,
    v81,
    v82,
    v83,
    timer,
    HIDWORD(timer),
    v85,
    v86,
    tp.tm_sec,
    tp.tm_min,
    tp.tm_hour,
    tp.tm_mday,
    tp.tm_mon,
    tp.tm_year,
    tp.tm_wday,
    tp.tm_yday,
    tp.tm_isdst,
    tp.tm_gmtoff,
    tp.tm_zone,
    *(_DWORD *)&v88,
    v90,
    v91,
    v92,
    v93,
    v94,
    v95,
    v96,
    v97,
    v98,
    v99,
    v100,
    v101,
    v102);
  do
  {
    v16 = s++;
    *v16 = 32;
    --v79;
  }
  while ( v79 > 0 );
  do
  {
    v17 = s++;
    v18 = v78++;
    *v17 = *v18;
  }
  while ( *v17 );
  *(s - 1) = 32;
  if ( *(_BYTE *)(v73 + 120) == 1 )
    v19 = (const char *)sub_805ADA7(*(unsigned int *)(v73 + 32), (int)&v97 + 1);
  else
    v19 = "?";
  v67 = v19;
  HIDWORD(v66) = dword_80718E5;
  LODWORD(v66) = &v88;
  sprintf(s, "%s %*s ");
  v20 = strlen(s);
  s += v20;
  if ( byte_8071925 )
  {
    fwrite_unlocked("  ", 1u, 2u, stdout);
    dword_8071A1D += 2;
  }
  if ( byte_80712DE || byte_80712DF || byte_8071912 || byte_80718D9 )
  {
    fputs_unlocked(&v103, stdout);
    v22 = s - &v103;
    dword_8071A1D += s - &v103;
    if ( byte_80712DE )
      sub_8051FC6(*(_DWORD *)(v73 + 36), dword_80718ED, *(unsigned __int8 *)(v73 + 120));
    if ( byte_80712DF )
      sub_8052039(*(_DWORD *)(v73 + 40), dword_80718F1, *(unsigned __int8 *)(v73 + 120));
    if ( byte_8071912 )
      sub_8051FC6(*(_DWORD *)(v73 + 36), dword_80718F5, *(unsigned __int8 *)(v73 + 120));
    v64 = (unsigned __int8)byte_80718D9;
    v63 = (const char *)v13;
    v23 = &loc_805280A;
    if ( !byte_80718D9 )
      v23 = &loc_805282D;
    dword_8071290 = (int)v23;
    sub_8064FFD(
      v21,
      v22,
      v65,
      HIDWORD(v65),
      v66,
      HIDWORD(v66),
      v67,
      v68,
      v69,
      v70,
      v71,
      HIDWORD(v71),
      v72,
      v73,
      v74,
      v75,
      v76,
      s,
      v78,
      v79,
      v80,
      v81,
      v82,
      v83,
      timer,
      HIDWORD(timer),
      v85,
      v86,
      tp.tm_sec,
      tp.tm_min,
      tp.tm_hour,
      tp.tm_mday,
      tp.tm_mon,
      tp.tm_year,
      tp.tm_wday,
      tp.tm_yday,
      tp.tm_isdst,
      tp.tm_gmtoff,
      tp.tm_zone,
      *(_DWORD *)&v88,
      v90,
      v91,
      v92,
      v93,
      v94,
      v95,
      v96,
      v97,
      v98,
      v99,
      v100,
      v101,
      v102);
    sub_8051ED7(*(char **)(v73 + 116), 0, dword_80718E9);
    s = &v103;
  }
  if ( *(_BYTE *)(v73 + 120)
    && ((*(_DWORD *)(v73 + 28) & 0xF000) == 0x2000 || (*(_DWORD *)(v73 + 28) & 0xF000) == 24576) )
  {
    v82 = -2 - dword_80718F9 - dword_80718FD + dword_8071901;
    v24 = *(_DWORD *)(v73 + 48);
    LODWORD(v65) = *(_DWORD *)(v73 + 44);
    HIDWORD(v65) = v24;
    v25 = gnu_dev_minor(v65);
    v26 = sub_805ADA7(v25, (int)&v97 + 1);
    v27 = dword_80718FD;
    v28 = *(_DWORD *)(v73 + 48);
    LODWORD(v65) = *(_DWORD *)(v73 + 44);
    HIDWORD(v65) = v28;
    v29 = gnu_dev_major(v65);
    v30 = sub_805ADA7(v29, (int)&v92);
    v31 = 0;
    if ( v82 >= 0 )
      v31 = v82;
    v68 = v26;
    v67 = (const char *)v27;
    HIDWORD(v66) = v30;
    LODWORD(v66) = v31 + dword_80718F9;
    sprintf(s, "%*s, %*s ");
    s += dword_8071901 + 1;
  }
  else
  {
    if ( *(_BYTE *)(v73 + 120) == 1 )
    {
      v35 = dword_80712E4;
      v36 = dword_80712E8;
      v37 = dword_8071921;
      v38 = *(_DWORD *)(v73 + 60);
      LODWORD(v65) = *(_DWORD *)(v73 + 56);
      HIDWORD(v65) = v38;
      v39 = sub_804EC7A(v65);
      v34 = (char *)sub_8059775(v39, SHIDWORD(v39), (char *)&v97 + 1, v37, 1, 0, v35, v36);
    }
    else
    {
      v34 = "?";
    }
    v80 = v34;
    v40 = dword_8071901;
    v65 = (unsigned int)v34;
    v41 = v40 - sub_805B3E5(v34);
    v81 = v41;
    dword_8071240 = (int)&loc_8052A4D;
    sub_80651D4(v43, v42, v65, HIDWORD(v65));
    do
    {
      v44 = s++;
      *v44 = 32;
      --v81;
    }
    while ( v81 > 0 );
    v45 = s++;
    v46 = v80;
    v47 = v80++ + 1;
    v48 = (unsigned __int8)*v46;
    *v45 = v48;
    v49 = (unsigned __int8)*v45;
    v50 = (_BYTE)v49 == 0;
    v64 = v49;
    v63 = (const char *)v41;
    v51 = &loc_8052ABB;
    if ( !v50 )
      v51 = &loc_8052A68;
    dword_8071268 = (int)v51;
    v26 = (int)v63;
    sub_80650DF(v47, v48, v65);
    *(s - 1) = 32;
  }
  v76 = 0;
  *s = 1;
  v52 = (struct tm *)*(unsigned __int8 *)(v73 + 120);
  if ( (_BYTE)v52 )
  {
    v52 = sub_8063673(dword_8071969, (time_t *)&timer, &tp);
    if ( v52 )
    {
      if ( sub_8060DD7(::tp.tv_sec, ::tp.tv_nsec, timer, SHIDWORD(timer)) < 0 )
        sub_80578EF(&::tp);
      v85 = ::tp.tv_sec - 15778476;
      v86 = ::tp.tv_nsec;
      v53 = sub_8060DD7(::tp.tv_sec - 15778476, ::tp.tv_nsec, timer, SHIDWORD(timer)) < 0
         && sub_8060DD7(timer, SHIDWORD(timer), ::tp.tv_sec, ::tp.tv_nsec) < 0;
      HIBYTE(v75) = v53;
      v68 = HIDWORD(timer);
      v67 = (const char *)dword_8071969;
      v52 = (struct tm *)sub_8051D47((int)s, 1001, v53, (int)(&v65 - 550));
      v76 = v52;
    }
  }
  v64 = (int)v52;
  v63 = (const char *)v26;
  v54 = &loc_8052C6A;
  if ( v76 )
    v54 = &loc_8052C77;
  dword_8071240 = (int)v54;
  v55 = v63;
  sub_80651D4(v33, v32, v65, HIDWORD(v65));
  if ( *s )
  {
    if ( *(_BYTE *)(v73 + 120) == 1 )
      v55 = (const char *)sub_804AF32(timer, (int)&v97 + 1);
    else
      v55 = "?";
    v66 = __PAIR__((unsigned int)v55, sub_8051DEB());
    sprintf(s, "%*s ");
    v57 = strlen(s);
    s += v57;
  }
  else
  {
    s = &s[(_DWORD)v76];
    v56 = s++;
    *v56 = 32;
    *s = 0;
  }
  fputs_unlocked(&v103, stdout);
  dword_8071A1D += s - &v103;
  v83 = sub_8053A9F(v73, 0, &unk_8071A29, s - &v103);
  if ( *(_DWORD *)(v73 + 108) == 6 )
  {
    if ( *(_DWORD *)(v73 + 4) )
    {
      fwrite_unlocked(" -> ", 1u, 4u, stdout);
      dword_8071A1D += 4;
      sub_8053A9F(v73, 1, 0, s - ((char *)&v65 - 3671) + v83 + 4);
      if ( dword_8071929 )
      {
        v58 = *(_DWORD *)(v73 + 112);
        LODWORD(v66) = 0;
        HIDWORD(v65) = v58;
        sub_8054050(1);
      }
    }
  }
  else if ( dword_8071929 )
  {
    HIDWORD(v59) = *(_DWORD *)(v73 + 28);
    LODWORD(v59) = *(unsigned __int8 *)(v73 + 120);
    LODWORD(v66) = *(_DWORD *)(v73 + 108);
    v65 = v59;
    sub_8054050(v59);
  }
  v60 = __readgsdword(0x14u);
  v64 = v60 ^ v104;
  v63 = v55;
  v61 = (void (*)())&loc_8052EC3;
  if ( v60 == v104 )
    v61 = sub_8052EC8;
  dword_8071204 = (int)v61;
  return sub_806532A(
           v65,
           HIDWORD(v65),
           v66,
           HIDWORD(v66),
           v67,
           v68,
           v69,
           v70,
           v71,
           HIDWORD(v71),
           v72,
           v73,
           v74,
           v75,
           v76,
           s,
           v78,
           v79,
           v80,
           v81,
           v82,
           v83,
           timer,
           HIDWORD(timer),
           v85,
           v86,
           tp.tm_sec);
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8053A9F: using guessed type _DWORD __cdecl sub_8053A9F(_DWORD, _DWORD, _DWORD, _DWORD);
// 8064FFD: using guessed type int __fastcall sub_8064FFD(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806506B: using guessed type int __fastcall sub_806506B(_DWORD, _DWORD);
// 80650DF: using guessed type int __fastcall sub_80650DF(_DWORD, _DWORD, _DWORD);
// 806514F: using guessed type int __fastcall sub_806514F(_DWORD, _DWORD);
// 806532A: using guessed type int __stdcall sub_806532A(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;
// 8071204: using guessed type int dword_8071204;
// 8071240: using guessed type int dword_8071240;
// 8071254: using guessed type int dword_8071254;
// 8071268: using guessed type int dword_8071268;
// 807127C: using guessed type int dword_807127C;
// 8071290: using guessed type int dword_8071290;
// 80712DE: using guessed type char byte_80712DE;
// 80712DF: using guessed type char byte_80712DF;
// 80718D9: using guessed type char byte_80718D9;
// 80718DA: using guessed type char byte_80718DA;
// 80718DD: using guessed type int dword_80718DD;
// 80718E1: using guessed type int dword_80718E1;
// 80718E5: using guessed type int dword_80718E5;
// 80718F9: using guessed type int dword_80718F9;
// 80718FD: using guessed type int dword_80718FD;
// 8071901: using guessed type int dword_8071901;
// 8071909: using guessed type int dword_8071909;
// 8071912: using guessed type char byte_8071912;
// 8071914: using guessed type char byte_8071914;
// 8071925: using guessed type char byte_8071925;
// 8071929: using guessed type int dword_8071929;
// 807193A: using guessed type char byte_807193A;
// 8071A1D: using guessed type int dword_8071A1D;

//----- (08052EC8) --------------------------------------------------------
void sub_8052EC8()
{
  ;
}

//----- (08052ED0) --------------------------------------------------------
#error "80531B1: call analysis failed (funcsize=357)"

//----- (080533F5) --------------------------------------------------------
int __cdecl sub_80533F5(void *a1, int a2, int a3)
{
  int v4; // [esp+0h] [ebp-2048h]
  int v5; // [esp+28h] [ebp-2020h]
  void *v6; // [esp+2Ch] [ebp-201Ch]
  unsigned __int8 v7; // [esp+33h] [ebp-2015h]
  void *ptr; // [esp+34h] [ebp-2014h]
  int v9; // [esp+38h] [ebp-2010h]
  char v10; // [esp+3Ch] [ebp-200Ch]
  unsigned int v11; // [esp+203Ch] [ebp-Ch]

  v6 = a1;
  v5 = a2;
  v11 = __readgsdword(0x14u);
  ptr = &v4 - 2051;
  sub_8052ED0(&v4 - 2053, 0x2000, a1, a2, a3, &v4 - 2052, (char *)&v4 - 8213);
  if ( ptr != &v10 && ptr != v6 )
    free(ptr);
  return v7 + v9;
}
// 8052ED0: using guessed type _DWORD __cdecl sub_8052ED0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (080534D9) --------------------------------------------------------
char *__cdecl sub_80534D9(char *s, int a2)
{
  size_t v2; // eax
  char *v3; // edx
  char *v4; // ecx
  void *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // edx
  char *v9; // eax
  unsigned __int8 v10; // al
  int v11; // eax
  int v13; // [esp-Ch] [ebp-28h]
  int v14; // [esp-4h] [ebp-20h]
  char v15; // [esp+0h] [ebp-1Ch]
  char *v16; // [esp+Ch] [ebp-10h]
  char *v17; // [esp+10h] [ebp-Ch]

  v15 = a2;
  v2 = strlen(s);
  v17 = (char *)sub_806169A(3u, v2 + 1);
  v16 = v17;
  while ( *s )
  {
    v5 = &loc_8053534;
    if ( !v15 )
      v5 = &loc_8053550;
    dword_8071254 = (int)v5;
    sub_806514F(v4, v3);
    if ( *s == 47 )
    {
      v6 = v16;
      v3 = v16++ + 1;
      *v6 = 47;
      ++s;
    }
    else
    {
      v13 = *s;
      if ( byte_8071AE9[(unsigned __int8)sub_804AC34(v13)] )
      {
        v7 = v16++;
        v8 = s;
        v4 = s++ + 1;
        v3 = (char *)(unsigned __int8)*v8;
        *v7 = (char)v3;
      }
      else
      {
        v9 = s++;
        v13 = *v9;
        v10 = sub_804AC34(v13);
        v14 = v10;
        v11 = sprintf(v16, "%%%02x", v10);
        v16 += v11;
      }
    }
  }
  *v16 = 0;
  return v17;
}
// 806514F: using guessed type int __fastcall sub_806514F(_DWORD, _DWORD);
// 8071254: using guessed type int dword_8071254;

//----- (080535D9) --------------------------------------------------------
int __usercall sub_80535D9@<eax>(int a1@<ebx>, void *a2, int a3, int a4, int a5, char a6, int a7, int a8)
{
  void *v8; // eax
  int v9; // edx
  int v10; // ecx
  int v11; // ST3C_4
  void *v12; // eax
  char *v13; // eax
  int v14; // ecx
  void *v15; // eax
  int v17; // [esp-28h] [ebp-2078h]
  int v18; // [esp-28h] [ebp-2078h]
  int v19; // [esp-24h] [ebp-2074h]
  int v20; // [esp-24h] [ebp-2074h]
  int v21; // [esp-20h] [ebp-2070h]
  int v22; // [esp-20h] [ebp-2070h]
  int v23; // [esp-1Ch] [ebp-206Ch]
  int v24; // [esp-1Ch] [ebp-206Ch]
  int v25; // [esp-18h] [ebp-2068h]
  int v26; // [esp-18h] [ebp-2068h]
  int v27; // [esp-14h] [ebp-2064h]
  int v28; // [esp-14h] [ebp-2064h]
  int v29; // [esp-10h] [ebp-2060h]
  int v30; // [esp-10h] [ebp-2060h]
  int v31; // [esp-Ch] [ebp-205Ch]
  int v32; // [esp-Ch] [ebp-205Ch]
  int v33; // [esp-8h] [ebp-2058h]
  int v34; // [esp-8h] [ebp-2058h]
  int v35; // [esp-4h] [ebp-2054h]
  int v36; // [esp-4h] [ebp-2054h]
  char *s; // [esp+0h] [ebp-2050h]
  int v38; // [esp+4h] [ebp-204Ch]
  int v39; // [esp+8h] [ebp-2048h]
  unsigned __int8 v40; // [esp+1Ah] [ebp-2036h]
  unsigned __int8 v41; // [esp+1Bh] [ebp-2035h]
  void *v42; // [esp+1Ch] [ebp-2034h]
  int v43; // [esp+20h] [ebp-2030h]
  void *ptr; // [esp+24h] [ebp-202Ch]
  void *v45; // [esp+28h] [ebp-2028h]
  int v46; // [esp+2Ch] [ebp-2024h]
  size_t n; // [esp+30h] [ebp-2020h]
  int v48; // [esp+34h] [ebp-201Ch]
  int v49; // [esp+38h] [ebp-2018h]
  size_t v50; // [esp+3Ch] [ebp-2014h]
  int v51; // [esp+40h] [ebp-2010h]
  char v52; // [esp+44h] [ebp-200Ch]
  unsigned int v53; // [esp+2044h] [ebp-Ch]

  LOBYTE(v39) = a6;
  v53 = __readgsdword(0x14u);
  v42 = &v52;
  v43 = sub_8052ED0(&v42, 0x2000, a2, a3, a4, 0, &v40);
  if ( v40 && a6 )
  {
    putchar_unlocked(32);
    ++dword_8071A1D;
  }
  v8 = &loc_80536D9;
  if ( !a5 )
    v8 = &loc_80536E7;
  dword_80711F0 = (int)v8;
  sub_80653A0(v17, v19, v21, v23, v25, v27, v29, v31, v33, v35, a8, a7, v39, a5, a3);
  sub_80540D3(v9, v10, a1, v11);
  v41 = 0;
  if ( s )
  {
    v12 = &loc_805371F;
    if ( !byte_80718BA )
      v12 = &loc_8053753;
    dword_8071218 = (int)v12;
    sub_80652BA(v18, v20, v22, v24, v26, v28, v30, v32, v34, v36);
    if ( byte_80718B9 && v40 != 1 )
    {
      v41 = 1;
      putchar_unlocked(*(char *)v42);
    }
    ptr = sub_80534D9(dword_80718C9, 0);
    v45 = sub_80534D9(s, 1);
    if ( *(_BYTE *)v45 == 47 )
      v13 = &::s;
    else
      v13 = "/";
    printf("\x1B]8;;file://%s%s%s\a", ptr, v13, v45);
    free(ptr);
    free(v45);
  }
  if ( v38 && byte_8071925 )
  {
    v46 = v38;
    n = 4;
    v48 = v38;
    if ( (unsigned int)(*(_DWORD *)(v38 + 16) - *(_DWORD *)(v38 + 12)) < 4 )
      sub_8062C3C(v46);
    memcpy(*(void **)(v46 + 12), &dword_8071A1D, n);
    *(_DWORD *)(v46 + 12) += n;
  }
  fwrite_unlocked((char *)v42 + v41, 1u, v43 - 2 * v41, stdout);
  dword_8071A1D += v43;
  if ( v38 && byte_8071925 )
  {
    v49 = v38;
    v50 = 4;
    v51 = v38;
    if ( (unsigned int)(*(_DWORD *)(v49 + 16) - *(_DWORD *)(v49 + 12)) < 4 )
      sub_8062C3C(v49);
    memcpy(*(void **)(v49 + 12), &dword_8071A1D, v50);
    *(_DWORD *)(v49 + 12) += v50;
  }
  if ( s )
  {
    fwrite_unlocked("\x1B]8;;\a", 1u, 6u, stdout);
    if ( v41 )
      putchar_unlocked(*((char *)v42 + v43 - 1));
  }
  if ( v42 != &v52 )
  {
    v15 = &loc_8053A64;
    if ( v42 == a2 )
      v15 = &loc_8053A72;
    dword_80711DC = (int)v15;
    sub_806540E(v14, v42);
    free(v42);
  }
  return v40 + v43;
}
// 8052ED0: using guessed type _DWORD __cdecl sub_8052ED0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80652BA: using guessed type int __stdcall sub_80652BA(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80653A0: using guessed type int __stdcall sub_80653A0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;
// 80711F0: using guessed type int dword_80711F0;
// 8071218: using guessed type int dword_8071218;
// 80718B9: using guessed type char byte_80718B9;
// 80718BA: using guessed type char byte_80718BA;
// 8071925: using guessed type char byte_8071925;
// 8071A1D: using guessed type int dword_8071A1D;

//----- (08053A9F) --------------------------------------------------------
#error "8053BF6: call analysis failed (funcsize=107)"

//----- (08053C36) --------------------------------------------------------
size_t sub_8053C36()
{
  if ( dword_8071310 )
    return sub_80545A6((int)&unk_807130C);
  sub_80545A6((int)dword_80712FC);
  sub_80545A6((int)&unk_8071314);
  return sub_80545A6((int)&dword_8071304);
}
// 80712FC: using guessed type int dword_80712FC[];
// 8071304: using guessed type int dword_8071304;
// 8071310: using guessed type int dword_8071310;

//----- (08053C7D) --------------------------------------------------------
int __usercall sub_8053C7D@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, int a4, int a5)
{
  int v5; // edx
  int v6; // ecx
  const char *v7; // edx
  int v8; // eax
  void *v9; // eax
  int v10; // edx
  void *v11; // eax
  int v12; // eax
  int v13; // edx
  int v14; // ecx
  void *v15; // eax
  int v16; // edx
  char v17; // al
  bool v18; // al
  int v20; // [esp+0h] [ebp-2D8h]
  int v21; // [esp+4h] [ebp-2D4h]
  const char *v22; // [esp+8h] [ebp-2D0h]
  int v23; // [esp+Ch] [ebp-2CCh]
  int v24; // [esp+10h] [ebp-2C8h]
  int v25; // [esp+14h] [ebp-2C4h]
  int v26; // [esp+18h] [ebp-2C0h]
  int v27; // [esp+1Ch] [ebp-2BCh]
  int v28; // [esp+20h] [ebp-2B8h]
  int v29; // [esp+24h] [ebp-2B4h]
  int v30; // [esp+28h] [ebp-2B0h]
  int v31; // [esp+2Ch] [ebp-2ACh]
  int v32; // [esp+30h] [ebp-2A8h]
  int v33; // [esp+34h] [ebp-2A4h]
  int v34; // [esp+38h] [ebp-2A0h]
  int v35; // [esp+3Ch] [ebp-29Ch]
  char s; // [esp+40h] [ebp-298h]
  int v37; // [esp+44h] [ebp-294h]
  int v38; // [esp+48h] [ebp-290h]
  int v39; // [esp+4Ch] [ebp-28Ch]
  int v40; // [esp+50h] [ebp-288h]
  int v41; // [esp+54h] [ebp-284h]
  int v42; // [esp+58h] [ebp-280h]
  int v43; // [esp+5Ch] [ebp-27Ch]
  int v44; // [esp+60h] [ebp-278h]
  int v45; // [esp+64h] [ebp-274h]
  int v46; // [esp+68h] [ebp-270h]
  int v47; // [esp+6Ch] [ebp-26Ch]
  int v48; // [esp+70h] [ebp-268h]
  int v49; // [esp+74h] [ebp-264h]
  int v50; // [esp+78h] [ebp-260h]
  int v51; // [esp+7Ch] [ebp-25Ch]
  int v52; // [esp+80h] [ebp-258h]
  int v53; // [esp+84h] [ebp-254h]
  int v54; // [esp+88h] [ebp-250h]
  int v55; // [esp+8Ch] [ebp-24Ch]
  int v56; // [esp+90h] [ebp-248h]
  int v57; // [esp+94h] [ebp-244h]
  int v58; // [esp+98h] [ebp-240h]
  int v59; // [esp+9Ch] [ebp-23Ch]
  int v60; // [esp+A0h] [ebp-238h]
  int v61; // [esp+A4h] [ebp-234h]
  int v62; // [esp+A8h] [ebp-230h]
  int v63; // [esp+ACh] [ebp-22Ch]
  int v64; // [esp+B0h] [ebp-228h]
  int v65; // [esp+B4h] [ebp-224h]
  int v66; // [esp+B8h] [ebp-220h]
  int v67; // [esp+BCh] [ebp-21Ch]
  int v68; // [esp+C0h] [ebp-218h]
  int v69; // [esp+C4h] [ebp-214h]
  int v70; // [esp+C8h] [ebp-210h]
  unsigned int v71; // [esp+2CCh] [ebp-Ch]

  v31 = a4;
  v71 = __readgsdword(0x14u);
  sub_804BA31(a1, a2, a3);
  if ( byte_807193A )
  {
    v7 = sub_80521D3((int)&s, 0x28Cu, v31);
    if ( dword_8071905 == 4 )
      v8 = 0;
    else
      v8 = dword_80718DD;
    v22 = v7;
    v21 = v8;
    printf("%*s ");
  }
  if ( byte_8071914 )
  {
    v9 = &loc_8053D45;
    if ( *(_BYTE *)(v31 + 120) == 1 )
      v9 = &loc_8053D4C;
    dword_807127C = (int)v9;
    sub_806506B(v6, v5);
    if ( dword_8071905 == 4 )
      v10 = 0;
    else
      v10 = dword_80718E1;
    v22 = "?";
    v21 = v10;
    printf("%*s ");
  }
  v11 = &loc_8053DFC;
  if ( !byte_80718D9 )
    v11 = &loc_8053E2F;
  dword_8071290 = (int)v11;
  sub_8064FFD(
    v6,
    v5,
    v20,
    v21,
    v22,
    v23,
    v24,
    v25,
    v26,
    v27,
    v28,
    v29,
    v30,
    v31,
    v32,
    v33,
    v34,
    v35,
    *(_DWORD *)&s,
    v37,
    v38,
    v39,
    v40,
    v41,
    v42,
    v43,
    v44,
    v45,
    v46,
    v47,
    v48,
    v49,
    v50,
    v51,
    v52,
    v53,
    v54,
    v55,
    v56,
    v57,
    v58,
    v59,
    v60,
    v61,
    v62,
    v63,
    v64,
    v65,
    v66,
    v67,
    v68,
    v69,
    v70);
  if ( dword_8071905 == 4 )
    v12 = 0;
  else
    v12 = dword_80718E9;
  v22 = *(const char **)(v31 + 116);
  v21 = v12;
  printf("%*s ", v12, v22);
  v35 = sub_8053A9F(v31, 0, 0, a5);
  v15 = &loc_8053E7C;
  if ( !dword_8071929 )
    v15 = &loc_8053EC4;
  dword_8071254 = (int)v15;
  sub_806514F(v14, v13);
  v16 = *(_DWORD *)(v31 + 28);
  v17 = *(_BYTE *)(v31 + 120);
  v22 = *(const char **)(v31 + 108);
  v21 = v16;
  v18 = sub_8054050(v17);
  return v18 + v35;
}
// 8053A9F: using guessed type _DWORD __cdecl sub_8053A9F(_DWORD, _DWORD, _DWORD, _DWORD);
// 8064FFD: using guessed type int __fastcall sub_8064FFD(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806506B: using guessed type int __fastcall sub_806506B(_DWORD, _DWORD);
// 806514F: using guessed type int __fastcall sub_806514F(_DWORD, _DWORD);
// 8071254: using guessed type int dword_8071254;
// 807127C: using guessed type int dword_807127C;
// 8071290: using guessed type int dword_8071290;
// 80718D9: using guessed type char byte_80718D9;
// 80718DD: using guessed type int dword_80718DD;
// 80718E1: using guessed type int dword_80718E1;
// 8071905: using guessed type int dword_8071905;
// 8071914: using guessed type char byte_8071914;
// 8071929: using guessed type int dword_8071929;
// 807193A: using guessed type char byte_807193A;

//----- (08053EE5) --------------------------------------------------------
int __usercall sub_8053EE5@<eax>(int a1@<edx>, int a2@<ecx>, char a3, __int16 a4, int a5)
{
  bool v5; // al
  void *v6; // eax
  bool v7; // al
  bool v8; // al
  bool v9; // al
  unsigned __int8 v11; // [esp+13h] [ebp-1h]

  if ( a3 )
    v5 = (unsigned __int16)(a4 & 0xF000) == 0x8000;
  else
    v5 = a5 == 5;
  if ( v5 )
  {
    if ( a3 && dword_8071929 == 3 && a4 & 0x49 )
      v11 = 42;
    else
      v11 = 0;
  }
  else
  {
    v6 = &loc_8053F5F;
    if ( !a3 )
      v6 = &loc_8053F71;
    dword_807127C = (int)v6;
    sub_806506B(a2, a1);
    if ( (a4 & 0xF000) == 0x4000 )
    {
      v11 = 47;
    }
    else if ( dword_8071929 == 1 )
    {
      v11 = 0;
    }
    else
    {
      if ( a3 )
        v7 = (unsigned __int16)(a4 & 0xF000) == 40960;
      else
        v7 = a5 == 6;
      if ( v7 )
      {
        v11 = 64;
      }
      else
      {
        if ( a3 )
          v8 = (unsigned __int16)(a4 & 0xF000) == 4096;
        else
          v8 = a5 == 1;
        if ( v8 )
        {
          v11 = 124;
        }
        else
        {
          if ( a3 )
            v9 = (unsigned __int16)(a4 & 0xF000) == 49152;
          else
            v9 = a5 == 7;
          if ( v9 )
            v11 = 61;
          else
            v11 = 0;
        }
      }
    }
  }
  return v11;
}
// 806506B: using guessed type int __fastcall sub_806506B(_DWORD, _DWORD);
// 807127C: using guessed type int dword_807127C;
// 8071929: using guessed type int dword_8071929;

//----- (08054050) --------------------------------------------------------
bool __cdecl sub_8054050(char a1)
{
  int v1; // ecx
  int v3; // [esp+0h] [ebp-28h]
  int v4; // [esp+Ch] [ebp-1Ch]
  int v5; // [esp+10h] [ebp-18h]

  *((_BYTE *)&v3 - 28) = a1;
  *((_BYTE *)&v3 - 9) = sub_8053EE5(v4, v1, *((_BYTE *)&v3 - 28), v4, v5);
  if ( *((_BYTE *)&v3 - 9) )
  {
    putchar_unlocked(*((char *)&v3 - 9));
    ++dword_8071A1D;
  }
  return *((_BYTE *)&v3 - 9) != 0;
}
// 8071A1D: using guessed type int dword_8071A1D;

//----- (080540D3) --------------------------------------------------------
bool __usercall sub_80540D3@<al>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, int a4)
{
  if ( a4 )
  {
    if ( (unsigned __int8)sub_804B90D(a3, a1, a2, 4) )
      sub_804BA11();
    sub_80545A6((int)dword_80712FC);
    sub_80545A6(a4);
    sub_80545A6((int)&dword_8071304);
  }
  return a4 != 0;
}
// 80712FC: using guessed type int dword_80712FC[];
// 8071304: using guessed type int dword_8071304;

//----- (08054124) --------------------------------------------------------
#error "8054359: call analysis failed (funcsize=302)"

//----- (080545A6) --------------------------------------------------------
size_t __cdecl sub_80545A6(int a1)
{
  if ( byte_807192F != 1 )
  {
    byte_807192F = 1;
    if ( tcgetpgrp(1) >= 0 )
      sub_804BD75();
    sub_8053C36();
  }
  return fwrite_unlocked(*(const void **)(a1 + 4), *(_DWORD *)a1, 1u, stdout);
}
// 807192F: using guessed type char byte_807192F;

//----- (0805460A) --------------------------------------------------------
int __usercall sub_805460A@<eax>(int a1@<ebx>, int a2)
{
  const char **v2; // ebp
  void *v3; // eax
  int v4; // edx
  int v5; // ecx
  int v6; // edx
  const char *v7; // eax
  int v8; // eax
  int v9; // eax
  const char *v10; // eax
  int v11; // eax
  int v12; // eax
  void *v13; // eax
  int v14; // ecx
  int v15; // edx
  int result; // eax
  unsigned int v17; // ebx
  int v18; // [esp-34h] [ebp-2E0h]
  int v19; // [esp-30h] [ebp-2DCh]
  const char *v20; // [esp-2Ch] [ebp-2D8h]
  int v21; // [esp-28h] [ebp-2D4h]
  int v22; // [esp-24h] [ebp-2D0h]
  int v23; // [esp-20h] [ebp-2CCh]
  int v24; // [esp-1Ch] [ebp-2C8h]
  int v25; // [esp-18h] [ebp-2C4h]
  int v26; // [esp-14h] [ebp-2C0h]
  int v27; // [esp-10h] [ebp-2BCh]
  int v28; // [esp-Ch] [ebp-2B8h]
  int v29; // [esp-8h] [ebp-2B4h]
  int v30; // [esp+0h] [ebp-2ACh]
  int v31; // [esp+10h] [ebp-29Ch]
  char s; // [esp+14h] [ebp-298h]
  unsigned int v33; // [esp+2A0h] [ebp-Ch]
  int savedregs; // [esp+2ACh] [ebp+0h]

  v2 = (const char **)&savedregs;
  v30 = a2;
  v33 = __readgsdword(0x14u);
  v31 = 0;
  v19 = (unsigned __int8)byte_807193A;
  v18 = a1;
  v3 = &loc_8054667;
  if ( !byte_807193A )
    v3 = &loc_80546AE;
  dword_8071218 = (int)v3;
  sub_80652BA(v20, v21, v22, v23, v24, v25, v26, v27, v28, v29);
  if ( dword_8071905 == 4 )
  {
    v6 = *(_DWORD *)(v30 + 104);
    v20 = *(const char **)(v30 + 100);
    v21 = v6;
    v7 = (const char *)sub_805ADA7(*(unsigned __int64 *)&v20, (int)&s);
    v8 = strlen(v7) + 1;
  }
  else
  {
    v8 = dword_80718DD + 1;
  }
  v31 += v8;
  if ( byte_8071914 )
  {
    if ( dword_8071905 == 4 )
    {
      if ( *(_BYTE *)(v30 + 120) != 1 )
      {
        dword_8071240 = (int)&loc_8054758;
        sub_80651D4(v5, v4, v20, v21);
        v2 = &v20;
      }
      v9 = (int)*(v2 - 171);
      v2 = &v20;
      v10 = (const char *)sub_8059775(
                            *(_DWORD *)(v9 + 68),
                            *(_DWORD *)(v9 + 72),
                            (char *)&v20 - 664,
                            dword_8071915,
                            512,
                            0,
                            dword_8071919,
                            dword_807191D);
      v11 = strlen(v10) + 1;
    }
    else
    {
      v11 = dword_80718E1 + 1;
    }
    *(v2 - 167) += v11;
  }
  if ( byte_80718D9 )
  {
    if ( dword_8071905 == 4 )
    {
      v20 = (const char *)*((_DWORD *)*(v2 - 171) + 29);
      v12 = strlen(v20) + 1;
    }
    else
    {
      v12 = dword_80718E9 + 1;
    }
    *(v2 - 167) += v12;
  }
  v13 = *(void **)*(v2 - 171);
  v22 = *((_DWORD *)*(v2 - 171) + 33);
  *(v2 - 167) += sub_80533F5(v13, dword_8071955, v22);
  if ( dword_8071929 )
  {
    v14 = *((_DWORD *)*(v2 - 171) + 27);
    v15 = *((_DWORD *)*(v2 - 171) + 7);
    v2 = &v20;
    *((_BYTE *)&v20 - 669) = sub_8053EE5(v15, v14, (*(&v20 - 171))[120], v15, v14);
    *(&v20 - 167) += *((_BYTE *)&v20 - 669) != 0;
  }
  result = (int)*(v2 - 167);
  v17 = __readgsdword(0x14u) ^ (unsigned int)*(v2 - 3);
  return result;
}
// 80652BA: using guessed type int __stdcall sub_80652BA(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8071218: using guessed type int dword_8071218;
// 8071240: using guessed type int dword_8071240;
// 80718D9: using guessed type char byte_80718D9;
// 80718DD: using guessed type int dword_80718DD;
// 80718E1: using guessed type int dword_80718E1;
// 8071905: using guessed type int dword_8071905;
// 8071914: using guessed type char byte_8071914;
// 8071929: using guessed type int dword_8071929;
// 807193A: using guessed type char byte_807193A;
// 8071955: using guessed type int dword_8071955;

//----- (0805486A) --------------------------------------------------------
unsigned int __usercall sub_805486A@<eax>(int a1@<ebx>)
{
  unsigned int v1; // ST28_4
  int v2; // ST34_4
  int v3; // ecx
  int v4; // eax
  unsigned int result; // eax
  unsigned int i; // [esp+18h] [ebp-30h]
  int v7; // [esp+1Ch] [ebp-2Ch]
  unsigned int v8; // [esp+20h] [ebp-28h]
  int j; // [esp+24h] [ebp-24h]
  char *v10; // [esp+2Ch] [ebp-1Ch]
  unsigned int v11; // [esp+30h] [ebp-18h]
  int v12; // [esp+38h] [ebp-10h]
  int v13; // [esp+3Ch] [ebp-Ch]

  v1 = sub_8054FCE(1);
  v10 = (char *)dword_8071A15 + 12 * v1 - 12;
  v11 = dword_80718B5 / v1 + (dword_80718B5 % v1 != 0);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v11 )
      break;
    v7 = 0;
    v8 = i;
    for ( j = 0; ; j += v13 )
    {
      v2 = *((_DWORD *)dword_80718BD + v8);
      v12 = sub_805460A(a1, v2);
      v3 = *((_DWORD *)v10 + 2);
      v4 = v7++;
      v13 = *(_DWORD *)(v3 + 4 * v4);
      sub_8053C7D(v7, v3, a1, v2, j);
      v8 += v11;
      if ( v8 >= dword_80718B5 )
        break;
      sub_8054C47(j + v12, v13 + j);
    }
    putchar_unlocked(10);
  }
  return result;
}
// 8054FCE: using guessed type _DWORD __cdecl sub_8054FCE(_DWORD);
// 80718B5: using guessed type int dword_80718B5;

//----- (080549B6) --------------------------------------------------------
#error "8054A73: call analysis failed (funcsize=105)"

//----- (08054B31) --------------------------------------------------------
int __usercall sub_8054B31@<eax>(int a1@<ecx>, int a2@<ebx>, char a3)
{
  void *v3; // eax
  int v4; // edx
  int v5; // ecx
  int v6; // ST08_4
  int v7; // edx
  int v8; // ecx
  char v10; // [esp+1Fh] [ebp-19h]
  unsigned int i; // [esp+20h] [ebp-18h]
  unsigned int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]

  v12 = 0;
  for ( i = 0; i < dword_80718B5; ++i )
  {
    v13 = *((_DWORD *)dword_80718BD + i);
    v3 = &loc_8054B84;
    if ( !dword_8071965 )
      v3 = &loc_8054BA6;
    dword_80711DC = (int)v3;
    sub_806540E(a1, 4 * i);
    sub_805460A(a2, v13);
    dword_8071268 = (int)&loc_8054BAB;
    sub_80650DF(v5, v4, v6);
    if ( i )
    {
      if ( dword_8071965 && (v12 + 2 >= dword_8071965 || v12 > 0xFFFFFFFD) )
      {
        v12 = 0;
        v10 = 10;
      }
      else
      {
        v12 += 2;
        v10 = 32;
      }
      putchar_unlocked(a3);
      putchar_unlocked(v10);
    }
    sub_8053C7D(v7, v8, a2, v13, v12);
  }
  return putchar_unlocked(10);
}
// 80650DF: using guessed type int __fastcall sub_80650DF(_DWORD, _DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;
// 8071268: using guessed type int dword_8071268;
// 80718B5: using guessed type int dword_80718B5;
// 8071965: using guessed type int dword_8071965;

//----- (08054C47) --------------------------------------------------------
unsigned int __cdecl sub_8054C47(unsigned int a1, unsigned int a2)
{
  unsigned int result; // eax

  while ( 1 )
  {
    result = a1;
    if ( a1 >= a2 )
      break;
    if ( dword_807195D && a2 / dword_807195D > (a1 + 1) / dword_807195D )
    {
      putchar_unlocked(9);
      a1 += dword_807195D - a1 % dword_807195D;
    }
    else
    {
      putchar_unlocked(32);
      ++a1;
    }
  }
  return result;
}
// 807195D: using guessed type int dword_807195D;

//----- (08054CF4) --------------------------------------------------------
_BYTE *__cdecl sub_8054CF4(_BYTE *a1, _BYTE *a2, _BYTE *a3)
{
  _BYTE *v3; // eax
  _BYTE *v4; // edx
  _BYTE *v5; // eax
  _BYTE *v6; // eax
  _BYTE *v7; // edx
  _BYTE *result; // eax
  _BYTE *v9; // [esp+Ch] [ebp-4h]

  v9 = a2;
  if ( *a2 != 46 || a2[1] )
  {
    while ( *v9 )
    {
      v3 = a1++;
      v4 = v9++;
      *v3 = *v4;
    }
    if ( v9 > a2 && *(v9 - 1) != 47 )
    {
      v5 = a1++;
      *v5 = 47;
    }
  }
  while ( *a3 )
  {
    v6 = a1++;
    v7 = a3++;
    *v6 = *v7;
  }
  result = a1;
  *a1 = 0;
  return result;
}

//----- (08054D8C) --------------------------------------------------------
#error "8054F8B: call analysis failed (funcsize=120)"

//----- (08054FCE) --------------------------------------------------------
#error "8055248: call analysis failed (funcsize=209)"

//----- (0805526C) --------------------------------------------------------
void __cdecl __noreturn sub_805526C(int status)
{
  int v1; // ebx
  char *v2; // eax
  int v3; // ebx
  char *v4; // eax
  FILE *v5; // ebx
  char *v6; // eax
  FILE *v7; // ebx
  char *v8; // eax
  FILE *v9; // ebx
  char *v10; // eax
  FILE *v11; // ebx
  char *v12; // eax
  FILE *v13; // ebx
  char *v14; // eax
  FILE *v15; // ebx
  char *v16; // eax
  FILE *v17; // ebx
  char *v18; // eax
  FILE *v19; // ebx
  char *v20; // eax
  FILE *v21; // ebx
  char *v22; // eax
  FILE *v23; // ebx
  char *v24; // eax
  FILE *v25; // ebx
  char *v26; // eax
  FILE *v27; // ebx
  char *v28; // eax
  FILE *v29; // ebx
  char *v30; // eax
  FILE *v31; // ebx
  char *v32; // eax
  FILE *v33; // ebx
  char *v34; // eax
  FILE *v35; // ebx
  char *v36; // eax
  FILE *v37; // ebx
  char *v38; // eax
  FILE *v39; // ebx
  char *v40; // eax
  FILE *v41; // ebx
  char *v42; // eax
  FILE *v43; // ebx
  char *v44; // eax
  FILE *v45; // ebx
  char *v46; // eax
  FILE *v47; // ebx
  char *v48; // eax
  FILE *v49; // ebx
  char *v50; // eax
  FILE *v51; // ebx
  char *v52; // eax
  int v53; // edx
  int v54; // ecx
  char *v55; // eax
  int v56; // [esp+8h] [ebp-10h]

  if ( status )
  {
    v1 = dword_80728DD;
    v2 = gettext("Try '%s --help' for more information.\n");
    v56 = v1;
    fprintf(stderr, v2, v1);
  }
  else
  {
    v3 = dword_80728DD;
    v4 = gettext("Usage: %s [OPTION]... [FILE]...\n");
    printf(v4, v3);
    v5 = stdout;
    v6 = gettext(
           "List information about the FILEs (the current directory by default).\n"
           "Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.\n");
    fputs_unlocked(v6, v5);
    sub_804ACEE();
    v7 = stdout;
    v8 = gettext(
           "  -a, --all                  do not ignore entries starting with .\n"
           "  -A, --almost-all           do not list implied . and ..\n"
           "      --author               with -l, print the author of each file\n"
           "  -b, --escape               print C-style escapes for nongraphic characters\n");
    fputs_unlocked(v8, v7);
    v9 = stdout;
    v10 = gettext(
            "      --block-size=SIZE      scale sizes by SIZE before printing them; e.g.,\n"
            "                               '--block-size=M' prints sizes in units of\n"
            "                               1,048,576 bytes; see SIZE format below\n"
            "  -B, --ignore-backups       do not list implied entries ending with ~\n"
            "  -c                         with -lt: sort by, and show, ctime (time of last\n"
            "                               modification of file status information);\n"
            "                               with -l: show ctime and sort by name;\n"
            "                               otherwise: sort by ctime, newest first\n");
    fputs_unlocked(v10, v9);
    v11 = stdout;
    v12 = gettext(
            "  -C                         list entries by columns\n"
            "      --color[=WHEN]         colorize the output; WHEN can be 'always' (default\n"
            "                               if omitted), 'auto', or 'never'; more info below\n"
            "  -d, --directory            list directories themselves, not their contents\n"
            "  -D, --dired                generate output designed for Emacs' dired mode\n");
    fputs_unlocked(v12, v11);
    v13 = stdout;
    v14 = gettext(
            "  -f                         do not sort, enable -aU, disable -ls --color\n"
            "  -F, --classify             append indicator (one of */=>@|) to entries\n"
            "      --file-type            likewise, except do not append '*'\n"
            "      --format=WORD          across -x, commas -m, horizontal -x, long -l,\n"
            "                               single-column -1, verbose -l, vertical -C\n"
            "      --full-time            like -l --time-style=full-iso\n");
    fputs_unlocked(v14, v13);
    v15 = stdout;
    v16 = gettext("  -g                         like -l, but do not list owner\n");
    fputs_unlocked(v16, v15);
    v17 = stdout;
    v18 = gettext(
            "      --group-directories-first\n"
            "                             group directories before files;\n"
            "                               can be augmented with a --sort option, but any\n"
            "                               use of --sort=none (-U) disables grouping\n");
    fputs_unlocked(v18, v17);
    v19 = stdout;
    v20 = gettext(
            "  -G, --no-group             in a long listing, don't print group names\n"
            "  -h, --human-readable       with -l and/or -s, print human readable sizes\n"
            "                               (e.g., 1K 234M 2G)\n"
            "      --si                   likewise, but use powers of 1000 not 1024\n");
    fputs_unlocked(v20, v19);
    v21 = stdout;
    v22 = gettext(
            "  -H, --dereference-command-line\n"
            "                             follow symbolic links listed on the command line\n"
            "      --dereference-command-line-symlink-to-dir\n"
            "                             follow each command line symbolic link\n"
            "                               that points to a directory\n"
            "      --hide=PATTERN         do not list implied entries matching shell PATTERN\n"
            "                               (overridden by -a or -A)\n");
    fputs_unlocked(v22, v21);
    v23 = stdout;
    v24 = gettext(
            "      --hyperlink[=WHEN]     hyperlink file names; WHEN can be 'always'\n"
            "                               (default if omitted), 'auto', or 'never'\n");
    fputs_unlocked(v24, v23);
    v25 = stdout;
    v26 = gettext(
            "      --indicator-style=WORD  append indicator with style WORD to entry names:\n"
            "                               none (default), slash (-p),\n"
            "                               file-type (--file-type), classify (-F)\n"
            "  -i, --inode                print the index number of each file\n"
            "  -I, --ignore=PATTERN       do not list implied entries matching shell PATTERN\n"
            "  -k, --kibibytes            default to 1024-byte blocks for disk usage\n");
    fputs_unlocked(v26, v25);
    v27 = stdout;
    v28 = gettext(
            "  -l                         use a long listing format\n"
            "  -L, --dereference          when showing file information for a symbolic\n"
            "                               link, show information for the file the link\n"
            "                               references rather than for the link itself\n"
            "  -m                         fill width with a comma separated list of entries\n");
    fputs_unlocked(v28, v27);
    v29 = stdout;
    v30 = gettext(
            "  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs\n"
            "  -N, --literal              print entry names without quoting\n"
            "  -o                         like -l, but do not list group information\n"
            "  -p, --indicator-style=slash\n"
            "                             append / indicator to directories\n");
    fputs_unlocked(v30, v29);
    v31 = stdout;
    v32 = gettext(
            "  -q, --hide-control-chars   print ? instead of nongraphic characters\n"
            "      --show-control-chars   show nongraphic characters as-is (the default,\n"
            "                               unless program is 'ls' and output is a terminal)\n"
            "  -Q, --quote-name           enclose entry names in double quotes\n"
            "      --quoting-style=WORD   use quoting style WORD for entry names:\n"
            "                               literal, locale, shell, shell-always,\n"
            "                               shell-escape, shell-escape-always, c, escape\n");
    fputs_unlocked(v32, v31);
    v33 = stdout;
    v34 = gettext(
            "  -r, --reverse              reverse order while sorting\n"
            "  -R, --recursive            list subdirectories recursively\n"
            "  -s, --size                 print the allocated size of each file, in blocks\n");
    fputs_unlocked(v34, v33);
    v35 = stdout;
    v36 = gettext(
            "  -S                         sort by file size, largest first\n"
            "      --sort=WORD            sort by WORD instead of name: none (-U), size (-S),\n"
            "                               time (-t), version (-v), extension (-X)\n"
            "      --time=WORD            with -l, show time as WORD instead of default\n"
            "                               modification time: atime or access or use (-u);\n"
            "                               ctime or status (-c); also use specified time\n"
            "                               as sort key if --sort=time (newest first)\n");
    fputs_unlocked(v36, v35);
    v37 = stdout;
    v38 = gettext(
            "      --time-style=STYLE     with -l, show times using style STYLE:\n"
            "                               full-iso, long-iso, iso, locale, or +FORMAT;\n"
            "                               FORMAT is interpreted like in 'date'; if FORMAT\n"
            "                               is FORMAT1<newline>FORMAT2, then FORMAT1 applies\n"
            "                               to non-recent files and FORMAT2 to recent files;\n"
            "                               if STYLE is prefixed with 'posix-', STYLE\n"
            "                               takes effect only outside the POSIX locale\n");
    fputs_unlocked(v38, v37);
    v39 = stdout;
    v40 = gettext(
            "  -t                         sort by modification time, newest first\n"
            "  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8\n");
    fputs_unlocked(v40, v39);
    v41 = stdout;
    v42 = gettext(
            "  -u                         with -lt: sort by, and show, access time;\n"
            "                               with -l: show access time and sort by name;\n"
            "                               otherwise: sort by access time, newest first\n"
            "  -U                         do not sort; list entries in directory order\n"
            "  -v                         natural sort of (version) numbers within text\n");
    fputs_unlocked(v42, v41);
    v43 = stdout;
    v44 = gettext(
            "  -w, --width=COLS           set output width to COLS.  0 means no limit\n"
            "  -x                         list entries by lines instead of by columns\n"
            "  -X                         sort alphabetically by entry extension\n"
            "  -Z, --context              print any security context of each file\n"
            "  -1                         list one file per line.  Avoid '\\n' with -q or -b\n");
    fputs_unlocked(v44, v43);
    v45 = stdout;
    v46 = gettext("      --help     display this help and exit\n");
    fputs_unlocked(v46, v45);
    v47 = stdout;
    v48 = gettext("      --version  output version information and exit\n");
    fputs_unlocked(v48, v47);
    sub_804AD19();
    v49 = stdout;
    v50 = gettext(
            "\n"
            "Using color to distinguish file types is disabled both by default and\n"
            "with --color=never.  With --color=auto, ls emits color codes only when\n"
            "standard output is connected to a terminal.  The LS_COLORS environment\n"
            "variable can change the settings.  Use the dircolors command to set it.\n");
    fputs_unlocked(v50, v49);
    v51 = stdout;
    v52 = gettext(
            "\n"
            "Exit status:\n"
            " 0  if OK,\n"
            " 1  if minor problems (e.g., cannot access subdirectory),\n"
            " 2  if serious trouble (e.g., cannot access command-line argument).\n");
    fputs_unlocked(v52, v51);
    if ( dword_8071404 == 1 )
    {
      v55 = "ls";
    }
    else if ( dword_8071404 == 2 )
    {
      v55 = "dir";
    }
    else
    {
      v55 = "vdir";
    }
    sub_804AD7F(v53, v54, (int)v51, v55);
  }
  exit(status);
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 804AD19: using guessed type int sub_804AD19(void);
// 8071404: using guessed type int dword_8071404;
// 80728DD: using guessed type int dword_80728DD;

//----- (080555DC) --------------------------------------------------------
char *__cdecl sub_80555DC(char *path, int a2)
{
  int v2; // eax
  bool v4; // zf
  void *v5; // eax
  int v6; // ST34_4
  char *v7; // ST28_4
  int v8; // [esp+0h] [ebp-38h]
  int v9; // [esp+4h] [ebp-34h]
  int v10; // [esp+8h] [ebp-30h]
  int v11; // [esp+Ch] [ebp-2Ch]
  size_t size; // [esp+10h] [ebp-28h]
  char *buf; // [esp+20h] [ebp-18h]
  ssize_t v14; // [esp+24h] [ebp-14h]

  if ( (unsigned int)a2 >= 0x401 )
    v2 = 1025;
  else
    v2 = a2 + 1;
  size = v2;
  while ( 1 )
  {
    buf = (char *)malloc(size);
    if ( !buf )
      return 0;
    v14 = readlink(path, buf, size);
    if ( v14 < 0 )
      break;
    if ( v14 < size )
    {
      buf[v14] = 0;
      return buf;
    }
    free(buf);
    if ( size > 0x3FFFFFFF )
    {
      if ( size > 0x7FFFFFFE )
      {
        *__errno_location() = 12;
        return 0;
      }
      size = 0x7FFFFFFF;
    }
    else
    {
      size *= 2;
    }
  }
  v4 = *__errno_location() == 34;
  v5 = &loc_8055687;
  if ( v4 )
    v5 = &loc_80556AD;
  dword_8071218 = (int)v5;
  sub_80652BA(v8, v9, v10, v11, size, 1024, 0x2000, 1025, buf, v14);
  v6 = *__errno_location();
  free(v7);
  *__errno_location() = v6;
  return 0;
}
// 80652BA: using guessed type int __stdcall sub_80652BA(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8071218: using guessed type int dword_8071218;

//----- (0805570D) --------------------------------------------------------
void __noreturn sub_805570D()
{
  sub_805526C(1);
}

//----- (08055721) --------------------------------------------------------
int __cdecl sub_8055721(char *s, int a2, int a3, size_t a4)
{
  int result; // eax
  int v5; // [esp+0h] [ebp-28h]
  int v6; // [esp+4h] [ebp-24h]
  int v7; // [esp+8h] [ebp-20h]
  int v8; // [esp+Ch] [ebp-1Ch]
  int v9; // [esp+10h] [ebp-18h]
  int i; // [esp+14h] [ebp-14h]
  signed int v11; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]
  int v13; // [esp+20h] [ebp-8h]
  int v14; // [esp+24h] [ebp-4h]

  v11 = -1;
  HIBYTE(v9) = 0;
  n = strlen(s);
  for ( i = 0; *(_DWORD *)(4 * i + a2); ++i )
  {
    if ( !strncmp(*(const char **)(4 * i + a2), s, n) )
    {
      if ( strlen(*(const char **)(4 * i + a2)) == n )
        return i;
      if ( v11 == -1 )
      {
        dword_8071218 = (int)&loc_8055826;
        sub_80652BA(v5, v6, v7, v8, v9, i, i, n, v13, v14);
      }
      if ( !a3 || memcmp((const void *)(a3 + a4 * v11), (const void *)(i * a4 + a3), a4) )
        HIBYTE(v9) = 1;
    }
  }
  if ( HIBYTE(v9) )
    result = -2;
  else
    result = v11;
  return result;
}
// 80652BA: using guessed type int __stdcall sub_80652BA(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8071218: using guessed type int dword_8071218;

//----- (08055855) --------------------------------------------------------
void __cdecl sub_8055855(int a1, int a2, int a3)
{
  char *v3; // eax
  int v4; // ebx
  int v5; // eax
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+10h] [ebp-28h]
  char *format; // [esp+2Ch] [ebp-Ch]

  if ( a3 == -1 )
    v3 = gettext("invalid argument %s for %s");
  else
    v3 = gettext("ambiguous argument %s for %s");
  format = v3;
  v4 = sub_806086C(1, a1);
  v5 = sub_80603B6(0, 8, a2);
  v7 = v4;
  v6 = v5;
  error(0, 0, format, v5, v4);
}
// 806086C: using guessed type _DWORD __cdecl sub_806086C(_DWORD, _DWORD);

//----- (080558DC) --------------------------------------------------------
int __cdecl sub_80558DC(int a1)
{
  FILE *v1; // ebx
  char *v2; // eax
  void *v3; // eax
  int v5; // [esp+0h] [ebp-28h]
  int v6; // [esp+4h] [ebp-24h]
  int v7; // [esp+8h] [ebp-20h]
  int v8; // [esp+Ch] [ebp-1Ch]

  v1 = stderr;
  v2 = gettext("Valid arguments are:");
  fputs_unlocked(v2, v1);
  v3 = &loc_8055A34;
  if ( *(_DWORD *)a1 )
    v3 = &loc_8055914;
  dword_807122C = (int)v3;
  sub_8065244(v5, v6, v7, v8);
  return putc_unlocked(10, stderr);
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8065244: using guessed type int __stdcall sub_8065244(_DWORD, _DWORD, _DWORD, _DWORD);
// 807122C: using guessed type int dword_807122C;

//----- (08055A4F) --------------------------------------------------------
int __cdecl sub_8055A4F(int a1, char *s, int a3, int a4, size_t n)
{
  int v6; // [esp+0h] [ebp-28h]
  int v7; // [esp+4h] [ebp-24h]
  int v8; // [esp+8h] [ebp-20h]
  char *v9; // [esp+Ch] [ebp-1Ch]
  int v10; // [esp+10h] [ebp-18h]
  int v11; // [esp+14h] [ebp-14h]
  int v12; // [esp+18h] [ebp-10h]
  void (*v13)(void); // [esp+1Ch] [ebp-Ch]

  v9 = (char *)n;
  *(&v6 - 3) = sub_8055721(v9, a3, a4, (size_t)v9);
  if ( *(&v6 - 3) >= 0 )
    return *(&v6 - 3);
  sub_8055855(*(&v6 - 3), (int)v9, *(&v6 - 3));
  v8 = v12;
  v7 = v11;
  sub_80558DC(v10);
  v13();
  return -1;
}

//----- (08055B7E) --------------------------------------------------------
#error "8055B9D: call analysis failed (funcsize=26)"

//----- (08055BCB) --------------------------------------------------------
#error "8055C0F: call analysis failed (funcsize=28)"

//----- (08055CB7) --------------------------------------------------------
_BOOL4 __cdecl sub_8055CB7(int a1)
{
  return (unsigned int)(a1 - 48) <= 9;
}

//----- (08055DF7) --------------------------------------------------------
int __cdecl sub_8055DF7(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 65) > 0x19 )
    result = a1;
  else
    result = a1 + 32;
  return result;
}

//----- (08055E31) --------------------------------------------------------
int __cdecl sub_8055E31(int a1, char *s, int a3)
{
  if ( !*(_DWORD *)a1 )
  {
    *(_DWORD *)a1 = sub_80582EA(
                      7,
                      0,
                      (unsigned int (__cdecl *)(int, unsigned int))sub_805920E,
                      (bool (__cdecl *)(int, int))sub_80593E5,
                      (size_t)sub_805949E);
    if ( !*(_DWORD *)a1 )
      sub_8061996();
  }
  if ( sub_8056D07(*(_DWORD **)a1, (int)s, (int *)a3) )
    return 1;
  sub_8056C2E(*(_DWORD *)a1, s, a3);
  return 0;
}
// 805920E: using guessed type int sub_805920E();

//----- (08055EDF) --------------------------------------------------------
#error "80564FC: call analysis failed (funcsize=586)"

//----- (08056957) --------------------------------------------------------
int sub_8056957()
{
  int v0; // ebx
  int *v1; // eax
  int *v2; // eax
  int result; // eax
  char *v4; // [esp+2Ch] [ebp-Ch]

  if ( sub_8063BA8(stdout) && (byte_80728C9 != 1 || *__errno_location() != 32) )
  {
    v4 = gettext("write error");
    if ( dword_80728C5 )
    {
      v0 = sub_80605A9(dword_80728C5);
      v1 = __errno_location();
      error(0, *v1, "%s: %s", v0, v4);
    }
    else
    {
      v2 = __errno_location();
      error(0, *v2, "%s", v4);
    }
    _exit(status);
  }
  result = sub_8063BA8(stderr);
  if ( result )
    _exit(status);
  return result;
}
// 80728C5: using guessed type int dword_80728C5;
// 80728C9: using guessed type char byte_80728C9;

//----- (08056A3B) --------------------------------------------------------
unsigned int __cdecl sub_8056A3B(_BYTE *a1)
{
  unsigned int i; // [esp+18h] [ebp-10h]
  _BOOL4 v3; // [esp+1Ch] [ebp-Ch]

  v3 = *a1 == 47;
  for ( i = sub_8056B4F(a1) - (_DWORD)a1; v3 < i && a1[i - 1] == 47; --i )
    ;
  return i;
}
// 8056B4F: using guessed type _DWORD __cdecl sub_8056B4F(_DWORD);

//----- (08056AB0) --------------------------------------------------------
int __cdecl sub_8056AB0(void *src)
{
  unsigned int v1; // eax
  bool v2; // zf
  int v3; // edx
  int v4; // ecx
  void *v5; // eax

  v1 = sub_8056A3B(src);
  v2 = malloc((v1 == 0) + v1 + 1) == 0;
  v5 = &loc_8056B04;
  if ( !v2 )
    v5 = &loc_8056B0F;
  dword_80711DC = (int)v5;
  sub_806540E(v4, v3);
  return 0;
}
// 80711DC: using guessed type int dword_80711DC;

//----- (08056B4F) --------------------------------------------------------
#error "8056B93: call analysis failed (funcsize=46)"

//----- (08056BCD) --------------------------------------------------------
size_t __cdecl sub_8056BCD(char *s)
{
  int v1; // edx
  int v2; // ecx
  size_t v4; // [esp+18h] [ebp-10h]

  v4 = strlen(s);
  dword_80711DC = (int)&loc_8056C07;
  sub_806540E(v2, v1);
  do
    --v4;
  while ( v4 > 1 && s[v4 - 1] == 47 );
  return v4;
}
// 80711DC: using guessed type int dword_80711DC;

//----- (08056C24) --------------------------------------------------------
int sub_8056C24()
{
  return 0;
}

//----- (08056C2E) --------------------------------------------------------
void __cdecl sub_8056C2E(int a1, char *s, int a3)
{
  void **v3; // ST20_4
  void *v4; // edx
  void *v5; // edx
  bool v6; // zf
  int v7; // edx
  int v8; // ecx
  void *v9; // eax
  int v10; // [esp+0h] [ebp-28h]

  if ( a1 )
  {
    v3 = (void **)sub_80617BF(0x14u);
    *v3 = sub_8061955(s);
    v4 = *(void **)(a3 + 92);
    v3[1] = *(void **)(a3 + 88);
    v3[2] = v4;
    v5 = *(void **)(a3 + 4);
    v3[3] = *(void **)a3;
    v3[4] = v5;
    v6 = sub_8058F5F(a1, (int)v3) == 0;
    v9 = &loc_8056CE9;
    if ( !v6 )
      v9 = &loc_8056CEE;
    dword_8071268 = (int)v9;
    sub_80650DF(v8, v7, v10);
    sub_8061996();
  }
}
// 80650DF: using guessed type int __fastcall sub_80650DF(_DWORD, _DWORD, _DWORD);
// 8071268: using guessed type int dword_8071268;

//----- (08056D07) --------------------------------------------------------
bool __cdecl sub_8056D07(_DWORD *a1, int a2, int *a3)
{
  int v4; // edx
  int v5; // edx
  int v6; // [esp+0h] [ebp-38h]
  int v7; // [esp+1Ch] [ebp-1Ch]
  int v8; // [esp+20h] [ebp-18h]
  int v9; // [esp+24h] [ebp-14h]
  int v10; // [esp+28h] [ebp-10h]
  int v11; // [esp+2Ch] [ebp-Ch]

  if ( !a1 )
    return 0;
  v7 = a2;
  v4 = a3[23];
  v8 = a3[22];
  v9 = v4;
  v5 = a3[1];
  v10 = *a3;
  v11 = v5;
  return sub_8057CF4(a1, (int)(&v6 - 7)) != 0;
}

//----- (08056D66) --------------------------------------------------------
#error "8056E03: call analysis failed (funcsize=56)"

//----- (08056E2D) --------------------------------------------------------
#error "8056F23: call analysis failed (funcsize=164)"

//----- (08057068) --------------------------------------------------------
int __cdecl sub_8057068(int a1, int a2)
{
  return sub_8056E2D(*(_DWORD *)(a1 + 16), a2);
}
// 8056E2D: using guessed type _DWORD __cdecl sub_8056E2D(_DWORD, _DWORD);

//----- (08057085) --------------------------------------------------------
int __cdecl sub_8057085(int a1)
{
  int v2; // [esp+0h] [ebp-Ch]

  v2 = sub_8057122(a1);
  if ( !v2 )
    sub_8061996();
  return v2;
}

//----- (080570E5) --------------------------------------------------------
#error "805710C: call analysis failed (funcsize=24)"

//----- (08057122) --------------------------------------------------------
int __cdecl sub_8057122(int a1)
{
  _BOOL4 v1; // eax
  signed int v3; // eax
  const char *v4; // [esp+0h] [ebp-38h]
  int v5; // [esp+4h] [ebp-34h]
  int v6; // [esp+8h] [ebp-30h]
  _BYTE *v7; // [esp+Ch] [ebp-2Ch]
  char *v8; // [esp+10h] [ebp-28h]
  size_t v9; // [esp+14h] [ebp-24h]
  char *v10; // [esp+18h] [ebp-20h]

  v8 = (char *)sub_8056B4F(a1);
  v9 = sub_8056BCD(v8);
  v10 = &v8[v9 - a1];
  v1 = *(&v4 - 9) && (*(&v4 - 10))[(_DWORD)(*(&v4 - 9) - 1)] != 47;
  *(&v4 - 7) = (const char *)v1;
  *(&v4 - 6) = (const char *)sub_80570E5(v7);
  v4 = *(&v4 - 6);
  *(&v4 - 5) = (const char *)strlen(v4);
  v4 = &(*(&v4 - 8))[(_DWORD)*(&v4 - 7) + 1 + (unsigned int)*(&v4 - 5)];
  *(&v4 - 4) = (const char *)malloc((size_t)v4);
  if ( !*(&v4 - 4) )
    return 0;
  v6 = (int)*(&v4 - 8);
  v5 = v6;
  v4 = *(&v4 - 4);
  *(&v4 - 3) = (const char *)mempcpy(v4, v6, v6);
  **(&v4 - 3) = 47;
  *(&v4 - 3) = &(*(&v4 - 3))[(_DWORD)*(&v4 - 7)];
  if ( v8 )
  {
    if ( *v7 == 47 )
      v3 = -1;
    else
      v3 = 0;
    *(_DWORD *)v8 = &(*(&v4 - 3))[v3];
  }
  v6 = (int)*(&v4 - 5);
  v5 = (int)*(&v4 - 6);
  v4 = *(&v4 - 3);
  *(&v4 - 3) = (const char *)mempcpy(v4, v5, v6);
  **(&v4 - 3) = 0;
  return (int)*(&v4 - 4);
}
// 80499B0: using guessed type int __cdecl mempcpy(_DWORD, _DWORD, _DWORD);
// 8056B4F: using guessed type _DWORD __cdecl sub_8056B4F(_DWORD);
// 80570E5: using guessed type _DWORD __cdecl sub_80570E5(_DWORD);

//----- (0805726D) --------------------------------------------------------
#error "8057325: call analysis failed (funcsize=76)"

//----- (08057362) --------------------------------------------------------
#error "8057391: call analysis failed (funcsize=39)"

//----- (080573E1) --------------------------------------------------------
int __cdecl sub_80573E1(int a1, unsigned int a2, int a3, unsigned int a4)
{
  int v4; // ecx
  int v5; // ST08_4
  int v6; // eax
  bool v8; // zf
  void *v9; // eax
  int v10; // ecx
  void *v11; // eax
  int v12; // edx
  int v13; // ecx
  void *v14; // eax
  int v15; // [esp+0h] [ebp-38h]
  int v16; // [esp+0h] [ebp-38h]
  int v17; // [esp+0h] [ebp-38h]
  int v18; // [esp+4h] [ebp-34h]
  int v19; // [esp+4h] [ebp-34h]
  int v20; // [esp+8h] [ebp-30h]
  int v21; // [esp+Ch] [ebp-2Ch]
  int v22; // [esp+10h] [ebp-28h]
  int v23; // [esp+14h] [ebp-24h]
  int v24; // [esp+18h] [ebp-20h]
  unsigned int v25; // [esp+1Ch] [ebp-1Ch]
  unsigned int v26; // [esp+20h] [ebp-18h]
  unsigned int v27; // [esp+20h] [ebp-18h]
  int v28; // [esp+24h] [ebp-14h]

  v25 = 0;
  v26 = 0;
  while ( v25 < a2 || v26 < a4 )
  {
    dword_8071218 = (int)&loc_80574A0;
    sub_80652BA(v15, v18, v20, v21, v22, v23, v24, v25, v26, 0);
    do
    {
      if ( v25 != a2 )
      {
        sub_8057362(*(unsigned __int8 *)(a1 + v25));
        dword_8071218 = (int)&loc_8057452;
        sub_80652BA(v5, v19, v20, v21, v22, v23, v24, v25, v27, v28);
      }
      if ( v27 == a4 )
        v6 = 0;
      else
        v6 = sub_8057362(*(unsigned __int8 *)(a3 + v27));
      if ( 0 != v6 )
        return -v6;
      ++v25;
      ++v27;
    }
    while ( v25 < a2 && (unsigned __int8)sub_8055CB7(*(char *)(a1 + v25)) ^ 1 );
    if ( v27 < a4 )
    {
      v8 = (unsigned __int8)sub_8055CB7(*(char *)(a3 + v27)) == 1;
      v9 = &loc_8057507;
      if ( !v8 )
        v9 = &loc_8057418;
      dword_8071218 = (int)v9;
      sub_80652BA(v17, v19, v20, v21, v22, v23, v24, v25, v27, v28);
    }
    while ( *(_BYTE *)(a1 + v25) == 48 )
      ++v25;
    dword_8071240 = (int)&loc_8057537;
    sub_80651D4(v4, a1, v16, v19);
    v26 = v27 + 1;
    v11 = &loc_805755F;
    if ( *(_BYTE *)(a3 + v26) == 48 )
      v11 = &loc_8057533;
    dword_8071254 = (int)v11;
    sub_806514F(v10, a3);
    while ( 1 )
    {
      v8 = (unsigned __int8)sub_8055CB7(*(char *)(a1 + v25)) == 0;
      v14 = &loc_80575D5;
      if ( v8 )
        v14 = &loc_80575F3;
      dword_8071254 = (int)v14;
      sub_806514F(v13, v12);
      if ( !(unsigned __int8)sub_8055CB7(*(char *)(a3 + v26)) )
        break;
      if ( !v28 )
        v28 = *(char *)(a1 + v25) - *(char *)(a3 + v26);
      ++v25;
      ++v26;
    }
    if ( (unsigned __int8)sub_8055CB7(*(char *)(a1 + v25)) )
      return 1;
    if ( (unsigned __int8)sub_8055CB7(*(char *)(a3 + v26)) )
      return -1;
    if ( v28 )
      return v28;
  }
  return 0;
}
// 80573E1: could not find valid save-restore pair for ebx
// 8057362: using guessed type _DWORD __cdecl sub_8057362(_DWORD);
// 806514F: using guessed type int __fastcall sub_806514F(_DWORD, _DWORD);
// 80652BA: using guessed type int __stdcall sub_80652BA(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8071218: using guessed type int dword_8071218;
// 8071240: using guessed type int dword_8071240;
// 8071254: using guessed type int dword_8071254;

//----- (0805765F) --------------------------------------------------------
int __cdecl sub_805765F(char *s1, char *s2)
{
  int v2; // edx
  int v3; // ecx
  bool v5; // zf
  void *v6; // eax
  int v7; // [esp+0h] [ebp-38h]
  int v8; // [esp+4h] [ebp-34h]
  int v9; // [esp+8h] [ebp-30h]
  int v10; // [esp+Ch] [ebp-2Ch]
  int v11; // [esp+10h] [ebp-28h]
  int v12; // [esp+14h] [ebp-24h]
  size_t n; // [esp+18h] [ebp-20h]
  int v14; // [esp+1Ch] [ebp-1Ch]
  int v15; // [esp+20h] [ebp-18h]
  int v16; // [esp+24h] [ebp-14h]
  int v17; // [esp+28h] [ebp-10h]
  int v18; // [esp+2Ch] [ebp-Ch]
  int v19; // [esp+30h] [ebp-8h]
  int v20; // [esp+34h] [ebp-4h]
  int savedregs; // [esp+38h] [ebp+0h]

  v15 = strcmp(s1, s2);
  if ( !v15 )
    return 0;
  if ( !*s1 )
  {
    dword_80711DC = (int)&locret_80578ED;
    sub_806540E(v3, v2);
  }
  if ( !*s2 )
    return 1;
  if ( !strcmp(".", s1) )
    return -1;
  v5 = strcmp(".", s2) == 0;
  v6 = &loc_8057715;
  if ( !v5 )
    v6 = &loc_805771F;
  dword_80711F0 = (int)v6;
  sub_80653A0(v7, v8, v9, v10, v11, v12, n, v14, v15, v16, v17, v18, v19, v20, savedregs);
  return 1;
}
// 80653A0: using guessed type int __stdcall sub_80653A0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;
// 80711F0: using guessed type int dword_80711F0;

//----- (080578EF) --------------------------------------------------------
struct timespec *__cdecl sub_80578EF(struct timespec *tp)
{
  struct timespec *result; // eax
  struct timeval tv; // [esp+18h] [ebp-10h]

  result = (struct timespec *)clock_gettime(0, tp);
  if ( result )
  {
    gettimeofday(&tv, 0);
    tp->tv_sec = tv.tv_sec;
    result = tp;
    tp->tv_nsec = 1000 * tv.tv_usec;
  }
  return result;
}

//----- (0805793E) --------------------------------------------------------
#error "80579AA: call analysis failed (funcsize=37)"

//----- (080579B9) --------------------------------------------------------
int __cdecl sub_80579B9(int a1)
{
  return *(_DWORD *)(a1 + 8);
}

//----- (080579C4) --------------------------------------------------------
#error "80579DE: call analysis failed (funcsize=16)"

//----- (080579F1) --------------------------------------------------------
void sub_80579F1()
{
  ;
}

//----- (08057A06) --------------------------------------------------------
int __cdecl sub_8057A06(int a1)
{
  return *(_DWORD *)(a1 + 16);
}

//----- (08057A2F) --------------------------------------------------------
#error "8057A56: call analysis failed (funcsize=55)"

//----- (08057CA4) --------------------------------------------------------
int __cdecl sub_8057CA4(_DWORD *a1, int a2)
{
  int (__cdecl *v2)(int, int); // eax
  int v4; // [esp+4h] [ebp-24h]
  unsigned int v5; // [esp+1Ch] [ebp-Ch]

  v2 = (int (__cdecl *)(int, int))a1[6];
  v4 = a1[2];
  v5 = v2(a2, v4);
  if ( a1[2] <= v5 )
    abort();
  return 8 * v5 + *a1;
}

//----- (08057CF4) --------------------------------------------------------
int __cdecl sub_8057CF4(_DWORD *a1, int a2)
{
  unsigned __int8 (__cdecl *v3)(int, int); // eax
  int v4; // [esp+4h] [ebp-24h]
  _DWORD *i; // [esp+18h] [ebp-10h]
  _DWORD *v6; // [esp+1Ch] [ebp-Ch]

  v6 = (_DWORD *)sub_8057CA4(a1, a2);
  if ( !*v6 )
    return 0;
  for ( i = v6; i; i = (_DWORD *)i[1] )
  {
    if ( *i != a2 )
    {
      v3 = (unsigned __int8 (__cdecl *)(int, int))a1[7];
      v4 = *i;
      if ( !v3(a2, v4) )
        continue;
    }
    return *i;
  }
  return 0;
}

//----- (08057FF8) --------------------------------------------------------
bool __cdecl sub_8057FF8(unsigned int a1)
{
  int v1; // ST08_4
  unsigned int v3; // [esp+8h] [ebp-8h]
  unsigned int v4; // [esp+Ch] [ebp-4h]

  v3 = 3;
  v4 = 9;
  while ( v4 < a1 && a1 % v3 )
  {
    v1 = v3 + 1;
    v4 += 4 * v1;
    v3 = v1 + 1;
  }
  return a1 % v3 != 0;
}

//----- (0805804F) --------------------------------------------------------
#error "805806C: call analysis failed (funcsize=11)"

//----- (08058071) --------------------------------------------------------
int __cdecl sub_8058071(int a1, unsigned int a2)
{
  int i; // [esp+Ch] [ebp+8h]

  if ( a2 <= 9 )
    a2 = 10;
  for ( i = a2 | 1; i != -1 && !sub_8057FF8(i); i += 2 )
    ;
  return i;
}

//----- (08058109) --------------------------------------------------------
unsigned int __cdecl sub_8058109(int a1, unsigned int a2)
{
  return sub_8063997(a1, 3) % a2;
}

//----- (08058134) --------------------------------------------------------
bool __cdecl sub_8058134(int a1, int a2)
{
  return a1 == a2;
}

//----- (08058142) --------------------------------------------------------
signed int __cdecl sub_8058142(int a1)
{
  int v2; // [esp+8h] [ebp-8h]

  v2 = *(_DWORD *)(a1 + 20);
  if ( (_UNKNOWN *)v2 == &unk_8069CA8 )
    return 1;
  if ( *(float *)(v2 + 8) > 0.1
    && 1.0 - 0.1 > *(float *)(v2 + 8)
    && *(float *)(v2 + 12) > 0.1 + 1.0
    && *(float *)v2 >= 0.0
    && *(float *)(v2 + 4) > *(float *)v2 + 0.1
    && *(float *)(v2 + 4) <= 1.0
    && *(float *)(v2 + 8) > *(float *)v2 + 0.1 )
  {
    return 1;
  }
  *(_DWORD *)(a1 + 20) = &unk_8069CA8;
  return 0;
}

//----- (08058202) --------------------------------------------------------
int __cdecl sub_8058202(int a1, int a2)
{
  bool v2; // zf
  void *v3; // eax
  int v4; // ecx
  int result; // eax
  long double v6; // fst7
  __int16 v7; // ax
  int v8; // edx
  int v9; // [esp-4h] [ebp-28h]
  int v10; // [esp+0h] [ebp-24h]
  __int64 v11; // [esp+4h] [ebp-20h]
  int v12; // [esp+Ch] [ebp-18h]

  v2 = *(_BYTE *)(a2 + 16) == 1;
  v9 = *(unsigned __int8 *)(a2 + 16) ^ 1;
  v3 = &loc_805822F;
  if ( v2 )
    v3 = &loc_80582A5;
  dword_807122C = (int)v3;
  sub_8065244(v10, v11, HIDWORD(v11), v12);
  *(&v10 - 8) = a1;
  *(&v10 - 7) = 0;
  *(float *)&v9 = (long double)*((signed __int64 *)&v10 - 4) / *(float *)(v12 + 8);
  if ( *(float *)&v9 >= 4294967300.0 )
    return 0;
  v6 = *(float *)&v9;
  v7 = *((_WORD *)&v10 - 9);
  HIBYTE(v7) = 12;
  *((_WORD *)&v10 - 10) = v7;
  *((_QWORD *)&v10 - 4) = (signed __int64)v6;
  v8 = *(&v10 - 7);
  HIDWORD(v11) = *(&v10 - 8);
  HIDWORD(v11) = sub_805804F(v4, v8, HIDWORD(v11));
  if ( HIDWORD(v11) <= 0x1FFFFFFF )
    result = HIDWORD(v11);
  else
    result = 0;
  return result;
}
// 805804F: using guessed type int __fastcall sub_805804F(_DWORD, _DWORD, _DWORD);
// 8065244: using guessed type int __stdcall sub_8065244(_DWORD, _DWORD, _DWORD, _DWORD);
// 807122C: using guessed type int dword_807122C;

//----- (080582EA) --------------------------------------------------------
size_t *__cdecl sub_80582EA(int a1, int a2, unsigned int (__cdecl *a3)(int a1, unsigned int a2), bool (__cdecl *a4)(int a1, int a2), size_t a5)
{
  int v5; // edx
  int v6; // ecx
  size_t *result; // eax
  void *v8; // eax
  size_t *ptr; // [esp+1Ch] [ebp-Ch]

  if ( !a3 )
    a3 = sub_8058109;
  if ( !a4 )
    a4 = sub_8058134;
  ptr = (size_t *)malloc(0x28u);
  if ( !ptr )
    return 0;
  v8 = &loc_8058348;
  if ( a2 )
    v8 = &loc_805834F;
  dword_80711DC = (int)v8;
  sub_806540E(v6, v5);
  ptr[5] = (size_t)&unk_8069CA8;
  if ( !((unsigned __int8)sub_8058142((int)ptr) ^ 1)
    && (ptr[2] = sub_8058202(a1, (int)&unk_8069CA8)) != 0
    && (*ptr = (size_t)calloc(ptr[2], 8u)) != 0 )
  {
    ptr[1] = 8 * ptr[2] + *ptr;
    ptr[3] = 0;
    ptr[4] = 0;
    ptr[6] = (size_t)a3;
    ptr[7] = (size_t)a4;
    ptr[8] = a5;
    ptr[9] = 0;
    result = ptr;
  }
  else
  {
    free(ptr);
    result = 0;
  }
  return result;
}
// 80711DC: using guessed type int dword_80711DC;

//----- (08058549) --------------------------------------------------------
#error "80585DF: call analysis failed (funcsize=86)"

//----- (08058681) --------------------------------------------------------
void *__cdecl sub_8058681(int a1)
{
  int v2; // [esp+1Ch] [ebp-Ch]

  if ( !*(_DWORD *)(a1 + 36) )
    return malloc(8u);
  v2 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(v2 + 4);
  return (void *)v2;
}

//----- (080586CC) --------------------------------------------------------
int __cdecl sub_80586CC(int a1, _DWORD *a2)
{
  int result; // eax

  *a2 = 0;
  a2[1] = *(_DWORD *)(a1 + 36);
  result = a1;
  *(_DWORD *)(a1 + 36) = a2;
  return result;
}

//----- (080586FF) --------------------------------------------------------
int __cdecl sub_80586FF(int a1, int a2, int a3, char a4)
{
  int result; // eax
  unsigned __int8 (__cdecl *v5)(int, int); // eax
  _DWORD *v6; // ecx
  _DWORD *v7; // eax
  int v8; // edx
  unsigned __int8 (__cdecl *v9)(int, int); // eax
  int v10; // [esp+0h] [ebp-38h]
  int v11; // [esp+4h] [ebp-34h]
  _DWORD *v12; // [esp+8h] [ebp-30h]
  int v13; // [esp+Ch] [ebp-2Ch]
  _DWORD *v14; // [esp+10h] [ebp-28h]

  *((_BYTE *)&v10 - 44) = a4;
  *(&v10 - 7) = sub_8057CA4(v12, v13);
  *v14 = *(&v10 - 7);
  if ( !*(_DWORD *)*(&v10 - 7) )
    return 0;
  if ( *(_DWORD *)*(&v10 - 7) == v13
    || (v5 = (unsigned __int8 (__cdecl *)(int, int))v12[7], v11 = *(_DWORD *)*(&v10 - 7), v5(v13, v11)) )
  {
    *(&v10 - 4) = *(_DWORD *)*(&v10 - 7);
    if ( *((_BYTE *)&v10 - 44) )
    {
      if ( *(_DWORD *)(*(&v10 - 7) + 4) )
      {
        *(&v10 - 3) = *(_DWORD *)(*(&v10 - 7) + 4);
        v6 = (_DWORD *)*(&v10 - 7);
        v7 = (_DWORD *)*(&v10 - 3);
        v8 = v7[1];
        *v6 = *v7;
        v6[1] = v8;
        sub_80586CC((int)v12, (_DWORD *)*(&v10 - 3));
      }
      else
      {
        *(_DWORD *)*(&v10 - 7) = 0;
      }
    }
    result = *(&v10 - 4);
  }
  else
  {
    for ( *(&v10 - 8) = *(&v10 - 7); ; *(&v10 - 8) = *(_DWORD *)(*(&v10 - 8) + 4) )
    {
      if ( !*(_DWORD *)(*(&v10 - 8) + 4) )
        return 0;
      if ( **(_DWORD **)(*(&v10 - 8) + 4) == v13 )
        break;
      v9 = (unsigned __int8 (__cdecl *)(int, int))v12[7];
      v11 = **(_DWORD **)(*(&v10 - 8) + 4);
      if ( v9(v13, v11) )
        break;
    }
    *(&v10 - 6) = **(_DWORD **)(*(&v10 - 8) + 4);
    if ( *((_BYTE *)&v10 - 44) )
    {
      *(&v10 - 5) = *(_DWORD *)(*(&v10 - 8) + 4);
      *(_DWORD *)(*(&v10 - 8) + 4) = *(_DWORD *)(*(&v10 - 5) + 4);
      sub_80586CC((int)v12, (_DWORD *)*(&v10 - 5));
    }
    result = *(&v10 - 6);
  }
  return result;
}

//----- (0805889D) --------------------------------------------------------
#error "80589B3: call analysis failed (funcsize=56)"

//----- (08058A8B) --------------------------------------------------------
int __cdecl sub_8058A8B(int a1, int a2)
{
  bool v2; // zf
  int v3; // edx
  int v4; // ecx
  void *v5; // eax

  v2 = sub_8058202(a2, *(_DWORD *)(a1 + 20)) == 0;
  v5 = &loc_8058AC8;
  if ( !v2 )
    v5 = &loc_8058AD2;
  dword_80711DC = (int)v5;
  sub_806540E(v4, v3);
  return 0;
}
// 80711DC: using guessed type int dword_80711DC;

//----- (08058C92) --------------------------------------------------------
signed int __cdecl sub_8058C92(int a1, int a2, _DWORD *a3)
{
  signed int result; // eax
  long double v4; // fst7
  long double v5; // fst6
  long double v6; // fst7
  long double v7; // fst6
  long double v8; // fst7
  long double v9; // fst7
  __int16 v10; // ax
  int v11; // edx
  int v12; // edx
  int v13; // ecx
  int *v14; // ebp
  int v15; // [esp+0h] [ebp-48h]
  int v16; // [esp+4h] [ebp-44h]
  _DWORD *v17; // [esp+8h] [ebp-40h]
  int v18; // [esp+Ch] [ebp-3Ch]
  __int64 v19; // [esp+10h] [ebp-38h]
  int v20; // [esp+2Ch] [ebp-1Ch]
  int v21; // [esp+30h] [ebp-18h]

  if ( !a2 )
    abort();
  v21 = sub_80586FF(a1, a2, (int)&v20, 0);
  if ( v21 )
  {
    if ( a3 )
      *a3 = v21;
    result = 0;
  }
  else
  {
    v19 = *(unsigned int *)(a1 + 12);
    v4 = (long double)*((signed __int64 *)&v15 - 7);
    v5 = *(float *)(v17[5] + 8);
    *(&v15 - 14) = v17[2];
    *(&v15 - 13) = 0;
    if ( v4 > v5 * (long double)*((signed __int64 *)&v15 - 7) )
    {
      sub_8058142((int)v17);
      *(&v15 - 14) = v17[3];
      *(&v15 - 13) = 0;
      v6 = (long double)*((signed __int64 *)&v15 - 7);
      v7 = *(float *)(v17[5] + 8);
      *(&v15 - 14) = v17[2];
      *(&v15 - 13) = 0;
      if ( v6 > v7 * (long double)*((signed __int64 *)&v15 - 7) )
      {
        *(&v15 - 5) = v17[5];
        if ( *(_BYTE *)(*(&v15 - 5) + 16) )
        {
          *(&v15 - 14) = v17[2];
          *(&v15 - 13) = 0;
          v8 = (long double)*((signed __int64 *)&v15 - 7) * *(float *)(*(&v15 - 5) + 12);
        }
        else
        {
          *(&v15 - 14) = v17[2];
          *(&v15 - 13) = 0;
          v8 = (long double)*((signed __int64 *)&v15 - 7) * *(float *)(*(&v15 - 5) + 12) * *(float *)(*(&v15 - 5) + 8);
        }
        *((float *)&v15 - 4) = v8;
        if ( *((float *)&v15 - 4) >= 4294967300.0 )
          return -1;
        v9 = *((float *)&v15 - 4);
        v10 = *((_WORD *)&v15 - 21);
        HIBYTE(v10) = 12;
        *((_WORD *)&v15 - 22) = v10;
        *((_QWORD *)&v15 - 7) = (signed __int64)v9;
        v11 = *(&v15 - 13);
        v16 = *(&v15 - 14);
        if ( (unsigned __int8)sub_8058A8B((int)v17, v16) ^ 1 )
        {
          dword_8071268 = (int)&locret_8058F5D;
          sub_80650DF(v13, v12, v15);
        }
        if ( sub_80586FF((int)(&v15 - 7), 0, (int)(&v15 - 7), 0) )
          abort();
      }
    }
    if ( *(_DWORD *)*(&v15 - 7) )
    {
      *(&v15 - 3) = (int)sub_8058681((int)v17);
      if ( *(&v15 - 3) )
      {
        v14 = &v15;
        *(_DWORD *)*(&v15 - 3) = v18;
        *(_DWORD *)(*(v14 - 3) + 4) = *(_DWORD *)(*(v14 - 7) + 4);
        *(_DWORD *)(*(v14 - 7) + 4) = *(v14 - 3);
        ++v17[4];
        result = 1;
      }
      else
      {
        result = -1;
      }
    }
    else
    {
      *(_DWORD *)*(&v15 - 7) = v18;
      ++v17[4];
      ++v17[3];
      result = 1;
    }
  }
  return result;
}
// 80650DF: using guessed type int __fastcall sub_80650DF(_DWORD, _DWORD, _DWORD);
// 8071268: using guessed type int dword_8071268;

//----- (08058F5F) --------------------------------------------------------
int __cdecl sub_8058F5F(int a1, int a2)
{
  signed int v2; // eax
  int v3; // edx
  int v4; // ecx
  bool v5; // zf
  void *v6; // eax
  int result; // eax
  signed int v8; // [esp-4h] [ebp-2Ch]
  int v9; // [esp+0h] [ebp-28h]
  int v10; // [esp+Ch] [ebp-1Ch]
  int v11; // [esp+18h] [ebp-10h]
  int v12; // [esp+1Ch] [ebp-Ch]

  v2 = sub_8058C92(a1, a2, &v11);
  v12 = v2;
  v5 = v2 == -1;
  v8 = v2;
  v6 = &loc_8058FC2;
  if ( v5 )
    v6 = &loc_8058FD2;
  dword_8071268 = (int)v6;
  sub_80650DF(v4, v3, v9);
  if ( *(&v9 - 3) )
    result = v10;
  else
    result = *(&v9 - 4);
  return result;
}
// 80650DF: using guessed type int __fastcall sub_80650DF(_DWORD, _DWORD, _DWORD);
// 8071268: using guessed type int dword_8071268;

//----- (08058FD9) --------------------------------------------------------
#error "80590D8: call analysis failed (funcsize=78)"

//----- (0805920E) --------------------------------------------------------
#error "8059230: call analysis failed (funcsize=15)"

//----- (08059235) --------------------------------------------------------
#error "80592AE: positive sp value has been found (funcsize=37)"

//----- (080593E5) --------------------------------------------------------
int __cdecl sub_80593E5(int a1, int a2)
{
  int v2; // ebx
  bool v3; // zf
  void *v4; // eax
  char v5; // al
  int v7; // [esp+0h] [ebp-28h]
  int v8; // [esp+4h] [ebp-24h]
  int v9; // [esp+8h] [ebp-20h]
  int v10; // [esp+Ch] [ebp-1Ch]

  v2 = *(_DWORD *)(a1 + 8);
  if ( *(_QWORD *)(a1 + 4) != *(_QWORD *)(a2 + 4)
    || __PAIR__(*(_DWORD *)(a1 + 12), *(_DWORD *)(a2 + 16)) != __PAIR__(*(_DWORD *)(a2 + 12), *(_DWORD *)(a1 + 16)) )
  {
    v5 = 0;
  }
  else
  {
    v3 = strcmp(*(const char **)a1, *(const char **)a2) == 0;
    v4 = &loc_8059488;
    if ( !v3 )
      v4 = &loc_805948F;
    dword_807122C = (int)v4;
    sub_8065244(v7, v8, v9, v10);
    v5 = 1;
  }
  return v5 & 1;
}
// 8065244: using guessed type int __stdcall sub_8065244(_DWORD, _DWORD, _DWORD, _DWORD);
// 807122C: using guessed type int dword_807122C;

//----- (0805949E) --------------------------------------------------------
void __cdecl sub_805949E(void **a1)
{
  free(*a1);
  free(a1);
}

//----- (080594C8) --------------------------------------------------------
#error "80595C9: call analysis failed (funcsize=98)"

//----- (08059624) --------------------------------------------------------
#error "8059645: call analysis failed (funcsize=18)"

//----- (08059658) --------------------------------------------------------
#error "805967A: call analysis failed (funcsize=85)"

//----- (0805976F) --------------------------------------------------------
#error "8059772: positive sp value has been found (funcsize=0)"

//----- (08059775) --------------------------------------------------------
#error "8059980: call analysis failed (funcsize=547)"

//----- (0805A556) --------------------------------------------------------
__int64 sub_805A556()
{
  __int64 result; // rax

  if ( getenv("POSIXLY_CORRECT") )
    LODWORD(result) = 512;
  else
    LODWORD(result) = 1024;
  HIDWORD(result) = 0;
  return result;
}

//----- (0805A588) --------------------------------------------------------
int __cdecl sub_805A588(char *s, int a2, int a3)
{
  bool v3; // zf
  void *v4; // eax
  int v5; // eax
  void *v6; // eax
  int v8; // [esp+0h] [ebp-38h]
  int v9; // [esp+0h] [ebp-38h]
  int v10; // [esp+4h] [ebp-34h]
  int v11; // [esp+4h] [ebp-34h]
  int v12; // [esp+8h] [ebp-30h]
  int v13; // [esp+8h] [ebp-30h]
  int v14; // [esp+Ch] [ebp-2Ch]
  int v15; // [esp+Ch] [ebp-2Ch]
  int v16; // [esp+10h] [ebp-28h]
  int v17; // [esp+14h] [ebp-24h]
  int v18; // [esp+18h] [ebp-20h]
  int v19; // [esp+1Ch] [ebp-1Ch]
  int v20; // [esp+20h] [ebp-18h]
  int v21; // [esp+24h] [ebp-14h]
  int v22; // [esp+28h] [ebp-10h]
  int v23; // [esp+2Ch] [ebp-Ch]
  int v24; // [esp+30h] [ebp-8h]
  int v25; // [esp+34h] [ebp-4h]
  int savedregs; // [esp+38h] [ebp+0h]

  v21 = 0;
  if ( !s )
  {
    s = getenv("BLOCK_SIZE");
    if ( !s )
    {
      v3 = getenv("BLOCKSIZE") == 0;
      v4 = &loc_805A5FE;
      if ( !v3 )
        v4 = &loc_805A610;
      dword_80711F0 = (int)v4;
      sub_80653A0(v8, v10, v12, v14, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, savedregs);
      *(_QWORD *)a2 = sub_805A556();
      goto LABEL_13;
    }
  }
  if ( *s == 39 )
  {
    v21 |= 4u;
    ++s;
  }
  v22 = sub_8055721(s, (int)off_8069D7C, (int)dword_8069D88, 4u);
  if ( v22 >= 0 )
  {
    v21 |= dword_8069D88[v22];
    *(_DWORD *)a2 = 1;
    *(_DWORD *)(a2 + 4) = 0;
LABEL_13:
    *(_DWORD *)a3 = v21;
    return 0;
  }
  v5 = sub_80624C3(s, (int)&v20, 0, a2, "eEgGkKmMpPtTyYzZ0");
  v23 = v5;
  v3 = v5 == 0;
  v6 = &loc_805A6BB;
  if ( v3 )
    v6 = &loc_805A6CC;
  dword_807122C = (int)v6;
  sub_8065244(v9, v11, v13, v15);
  *(_DWORD *)a3 = 0;
  return v23;
}
// 8065244: using guessed type int __stdcall sub_8065244(_DWORD, _DWORD, _DWORD, _DWORD);
// 80653A0: using guessed type int __stdcall sub_80653A0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8069D7C: using guessed type char *off_8069D7C[2];
// 80711F0: using guessed type int dword_80711F0;
// 807122C: using guessed type int dword_807122C;

//----- (0805A776) --------------------------------------------------------
int __cdecl sub_805A776(char *s, int a2, int a3)
{
  int v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_805A588(s, a3, a2);
  if ( !*(_QWORD *)a3 )
  {
    *(_QWORD *)a3 = sub_805A556();
    v4 = 4;
  }
  return v4;
}

//----- (0805A7BF) --------------------------------------------------------
#error "805A8AC: call analysis failed (funcsize=80)"

//----- (0805AA24) --------------------------------------------------------
int __cdecl sub_805AA24(__gid_t gid)
{
  const char *v1; // eax
  char *s; // ST1C_4
  size_t v3; // eax
  int result; // eax
  _DWORD *i; // [esp+10h] [ebp-18h]
  int v6; // [esp+14h] [ebp-14h]
  struct group *v7; // [esp+18h] [ebp-10h]

  v6 = 0;
  for ( i = (_DWORD *)dword_80728D5; i; i = (_DWORD *)i[1] )
  {
    if ( *i == gid )
    {
      v6 = (int)i;
      break;
    }
  }
  if ( !v6 )
  {
    v7 = getgrgid(gid);
    if ( v7 )
      v1 = v7->gr_name;
    else
      v1 = (const char *)&unk_8069E0C;
    s = (char *)v1;
    v3 = strlen(v1);
    v6 = sub_80617BF((v3 + 16) & 0xFFFFFFF8);
    *(_DWORD *)v6 = gid;
    strcpy((char *)(v6 + 8), s);
    *(_DWORD *)(v6 + 4) = dword_80728D5;
    dword_80728D5 = v6;
  }
  if ( *(_BYTE *)(v6 + 8) )
    result = v6 + 8;
  else
    result = 0;
  return result;
}
// 80728D5: using guessed type int dword_80728D5;

//----- (0805AC4D) --------------------------------------------------------
#error "805AD5D: call analysis failed (funcsize=77)"

//----- (0805ADA7) --------------------------------------------------------
int __cdecl sub_805ADA7(unsigned __int64 a1, int a2)
{
  unsigned __int64 v2; // rax
  unsigned __int64 v4; // [esp+18h] [ebp-20h]
  int v5; // [esp+2Ch] [ebp-Ch]

  v4 = a1;
  v5 = a2 + 20;
  *(_BYTE *)(a2 + 20) = 0;
  do
  {
    *(_BYTE *)--v5 = sub_8064BD9(v4, 0xAu, 0) + 48;
    LODWORD(v2) = sub_8064A4F(v4, 10, 0);
    v4 = v2;
  }
  while ( v2 );
  return v5;
}
// 8064A4F: using guessed type _DWORD __cdecl sub_8064A4F(__int64, _DWORD, _DWORD);

//----- (0805AE51) --------------------------------------------------------
#error "805AE98: call analysis failed (funcsize=36)"

//----- (0805AECD) --------------------------------------------------------
int __cdecl sub_805AECD(int *a1, unsigned int a2)
{
  int v3; // [esp+0h] [ebp-28h]
  int v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]

  v4 = 0;
  v5 = 0;
  while ( *a1 )
  {
    v3 = *a1;
    v5 = wcwidth(v3);
    if ( v5 == -1 )
    {
      *a1 = 65533;
      v5 = 1;
    }
    if ( v5 + v4 > a2 )
      break;
    v4 += v5;
    ++a1;
  }
  *a1 = 0;
  return v4;
}
// 8049560: using guessed type int __cdecl wcwidth(_DWORD);

//----- (0805AF3D) --------------------------------------------------------
_BYTE *__cdecl sub_805AF3D(_BYTE *a1, unsigned int a2, int a3)
{
  _BYTE *v3; // eax
  int v4; // eax

  while ( 1 )
  {
    v4 = a3--;
    if ( !v4 || (unsigned int)a1 >= a2 )
      break;
    v3 = a1++;
    *v3 = 32;
  }
  *a1 = 0;
  return a1;
}

//----- (0805AF72) --------------------------------------------------------
#error "805B02E: call analysis failed (funcsize=255)"

//----- (0805B3E5) --------------------------------------------------------
int __cdecl sub_805B3E5(char *s)
{
  strlen(s);
  return sub_805B412(s);
}
// 805B412: using guessed type _DWORD __cdecl sub_805B412(_DWORD);

//----- (0805B412) --------------------------------------------------------
#error "805B445: call analysis failed (funcsize=18)"

//----- (0805B44A) --------------------------------------------------------
#error "805B766: positive sp value has been found (funcsize=157)"

//----- (0805B767) --------------------------------------------------------
#error "805B90B: call analysis failed (funcsize=129)"

//----- (0805B910) --------------------------------------------------------
#error "805B93E: positive sp value has been found (funcsize=0)"

//----- (0805B93F) --------------------------------------------------------
#error "805BA12: call analysis failed (funcsize=75)"

//----- (0805BBF3) --------------------------------------------------------
int __cdecl sub_805BBF3(int a1, int a2, int a3)
{
  return sub_805B93F(a1, a2, a1 + 4 * a2, a3);
}
// 805B93F: using guessed type _DWORD __cdecl sub_805B93F(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0805BC3B) --------------------------------------------------------
int __cdecl sub_805BC3B(int a1, int a2, int a3)
{
  int v3; // eax

  while ( 1 )
  {
    v3 = a3--;
    if ( !v3 )
      break;
    *(_BYTE *)(a1 + a3) = tolower(*(unsigned __int8 *)(a2 + a3));
  }
  return a1;
}

//----- (0805BC8F) --------------------------------------------------------
int __cdecl sub_805BC8F(int a1, int a2, int a3)
{
  int v3; // eax

  while ( 1 )
  {
    v3 = a3--;
    if ( !v3 )
      break;
    *(_BYTE *)(a1 + a3) = toupper(*(unsigned __int8 *)(a2 + a3));
  }
  return a1;
}

//----- (0805BCCF) --------------------------------------------------------
int __cdecl sub_805BCCF(int a1, int a2)
{
  return a1 - (a1 - a2 + 382) % 7 + 3;
}

//----- (0805BD30) --------------------------------------------------------
int __cdecl sub_805BD30(int a1, int a2, int a3, int a4, int a5, int a6)
{
  char v7; // [esp+2Fh] [ebp-9h]

  v7 = 0;
  return sub_805BD99(0, a4, 0, a4, 0, &v7, a5, a6);
}
// 805BD99: using guessed type _DWORD __cdecl sub_805BD99(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0805BD99) --------------------------------------------------------
#error "805E204: call analysis failed (funcsize=1908)"

//----- (0805EB55) --------------------------------------------------------
char *__cdecl sub_805EB55(char *s)
{
  int v1; // edx
  int v2; // ecx
  char *result; // eax
  int v4; // [esp+0h] [ebp-28h]
  int v5; // [esp+4h] [ebp-24h]

  if ( !s )
  {
    fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
    abort();
  }
  if ( strrchr(s, 47) )
  {
    dword_8071240 = (int)&loc_805EBCB;
    sub_80651D4(v2, v1, v4, v5);
  }
  dword_80728DD = (int)s;
  result = s;
  program_invocation_name = (int)s;
  return result;
}
// 8071240: using guessed type int dword_8071240;
// 8071480: using guessed type int program_invocation_short_name;
// 8071490: using guessed type int program_invocation_name;
// 80728DD: using guessed type int dword_80728DD;

//----- (0805EC47) --------------------------------------------------------
void *__cdecl sub_805EC47(void *src)
{
  int *v1; // eax
  void *v2; // ST1C_4
  int v4; // [esp+18h] [ebp-10h]

  v4 = *__errno_location();
  if ( src )
    v1 = (int *)src;
  else
    v1 = &dword_80728E9;
  v2 = sub_8061928(v1, 0x30u);
  *__errno_location() = v4;
  return v2;
}
// 80728E9: using guessed type int dword_80728E9;

//----- (0805EC8D) --------------------------------------------------------
int __usercall sub_805EC8D@<eax>(int edx0@<edx>, int a2@<ecx>, int a1)
{
  if ( a1 )
  {
    dword_80711DC = (int)&loc_805ECC5;
    sub_806540E(a2, edx0);
  }
  return dword_80728E9;
}
// 80711DC: using guessed type int dword_80711DC;
// 80728E9: using guessed type int dword_80728E9;

//----- (0805ECC9) --------------------------------------------------------
int *__cdecl sub_805ECC9(int *a1, int a2)
{
  int *result; // eax

  if ( a1 )
    result = a1;
  else
    result = &dword_80728E9;
  *result = a2;
  return result;
}
// 80728E9: using guessed type int dword_80728E9;

//----- (0805ECE3) --------------------------------------------------------
#error "805ED18: call analysis failed (funcsize=22)"

//----- (0805ED1D) --------------------------------------------------------
#error "805ED67: call analysis failed (funcsize=26)"

//----- (0805ED6C) --------------------------------------------------------
#error "805EDBA: positive sp value has been found (funcsize=0)"

//----- (0805EDF7) --------------------------------------------------------
int *__cdecl sub_805EDF7(int *a1, int a2, int a3)
{
  int *result; // eax

  if ( !a1 )
    a1 = &dword_80728E9;
  *a1 = 10;
  if ( !a2 || !a3 )
    abort();
  a1[10] = a2;
  result = a1;
  a1[11] = a3;
  return result;
}
// 80728E9: using guessed type int dword_80728E9;

//----- (0805EE38) --------------------------------------------------------
_DWORD *__userpurge sub_805EE38@<eax>(_DWORD *a1, int a2)
{
  int v3; // [esp+0h] [ebp-38h]
  int v4; // [esp+4h] [ebp-34h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]

  memset(&v3, 0, 0x30u);
  if ( a2 == 10 )
    abort();
  *a1 = a2;
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = v6;
  a1[4] = v7;
  a1[5] = v8;
  a1[6] = v9;
  a1[7] = v10;
  a1[8] = v11;
  a1[9] = v12;
  a1[10] = v13;
  a1[11] = v14;
  return a1;
}

//----- (0805EEE2) --------------------------------------------------------
char *__cdecl sub_805EEE2(char *msgid)
{
  int *v1; // ebp
  char *result; // eax
  int v3; // edx
  int v4; // ecx
  int v5; // edx
  int v6; // ecx
  int v7; // edx
  int v8; // ecx
  int v9; // [esp+0h] [ebp-28h]
  int v10; // [esp+4h] [ebp-24h]
  char *v11; // [esp+18h] [ebp-10h]
  unsigned __int8 *v12; // [esp+1Ch] [ebp-Ch]
  int savedregs; // [esp+28h] [ebp+0h]

  v1 = &savedregs;
  v11 = gettext(msgid);
  if ( v11 != msgid )
    return v11;
  v12 = (unsigned __int8 *)sub_806427F();
  if ( sub_8063AE3(v3, v4, v12, "UTF-8") )
  {
    if ( !sub_8063AE3(v5, v6, v12, "GB18030") )
    {
      *msgid;
      dword_8071240 = (int)&locret_805EF9F;
      sub_80651D4(v8, v7, v9, v10);
      v1 = &v9;
    }
    if ( v1[3] == 9 )
      result = (char *)&unk_806A165;
    else
      result = "'";
  }
  else if ( *msgid == 96 )
  {
    result = (char *)&unk_806A14E;
  }
  else
  {
    result = (char *)&unk_806A152;
  }
  return result;
}
// 8071240: using guessed type int dword_8071240;

//----- (0805EFA1) --------------------------------------------------------
#error "805FBFE: call analysis failed (funcsize=1109)"

//----- (0805FDD9) --------------------------------------------------------
int __cdecl sub_805FDD9(int a1, int a2, int a3, int a4, int *a5)
{
  int *v5; // eax
  int *v6; // ST34_4
  int v7; // ST38_4
  int v8; // ST3C_4

  if ( a5 )
    v5 = a5;
  else
    v5 = &dword_80728E9;
  v6 = v5;
  v7 = *__errno_location();
  v8 = sub_805EFA1(a1, a2, a3, a4, *v6, v6[1], v6 + 2, v6[10], v6[11]);
  *__errno_location() = v7;
  return v8;
}
// 805EFA1: using guessed type _DWORD __cdecl sub_805EFA1(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80728E9: using guessed type int dword_80728E9;

//----- (0805FEB3) --------------------------------------------------------
int __cdecl sub_805FEB3(int a1, int a2, int a3, int *a4)
{
  int *v4; // eax
  int v5; // edx
  int v6; // ebx
  int v7; // eax
  int v8; // edx
  int v9; // ebx
  _DWORD *v10; // eax
  size_t v12; // [esp+0h] [ebp-58h]
  int v13; // [esp+8h] [ebp-50h]
  int v14; // [esp+Ch] [ebp-4Ch]
  _DWORD *v15; // [esp+10h] [ebp-48h]
  int v16; // [esp+14h] [ebp-44h]
  int v17; // [esp+18h] [ebp-40h]
  int v18; // [esp+1Ch] [ebp-3Ch]
  int v19; // [esp+20h] [ebp-38h]
  int *v20; // [esp+3Ch] [ebp-1Ch]
  int v21; // [esp+40h] [ebp-18h]

  if ( a4 )
    v4 = a4;
  else
    v4 = &dword_80728E9;
  v20 = v4;
  v21 = *__errno_location();
  *(&v12 - 5) = v20[1] | (a3 == 0);
  v5 = *(_DWORD *)(*(&v12 - 7) + 40);
  v6 = *(&v12 - 7) + 8;
  v7 = *(_DWORD *)*(&v12 - 7);
  v19 = *(_DWORD *)(*(&v12 - 7) + 44);
  v18 = v5;
  v17 = v6;
  v16 = *(&v12 - 5);
  *(&v12 - 4) = sub_805EFA1(0, 0, v13, v14, v7, v16, v6, v5, v19) + 1;
  v12 = *(&v12 - 4);
  *(&v12 - 3) = sub_80617AC(v12);
  v8 = *(_DWORD *)(*(&v12 - 7) + 40);
  v9 = *(&v12 - 7) + 8;
  v10 = *(_DWORD **)*(&v12 - 7);
  v19 = *(_DWORD *)(*(&v12 - 7) + 44);
  v18 = v8;
  v17 = v9;
  v16 = *(&v12 - 5);
  v15 = v10;
  sub_805EFA1(*(&v12 - 3), *(&v12 - 4), v13, v14, v10, v16, v9, v8, v19);
  *__errno_location() = *(&v12 - 6);
  if ( v15 )
    *v15 = *(&v12 - 4) - 1;
  return *(&v12 - 3);
}
// 805EFA1: using guessed type _DWORD __cdecl sub_805EFA1(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80728E9: using guessed type int dword_80728E9;

//----- (0806008C) --------------------------------------------------------
#error "806015A: call analysis failed (funcsize=171)"

//----- (0806030E) --------------------------------------------------------
int __cdecl sub_806030E(int a1, int a2)
{
  return sub_806008C(a1, a2, -1, &dword_80728E9);
}
// 806008C: using guessed type _DWORD __cdecl sub_806008C(_DWORD, _DWORD, _DWORD, _DWORD);
// 80728E9: using guessed type int dword_80728E9;

//----- (0806033C) --------------------------------------------------------
int __cdecl sub_806033C(int a1, int a2, int a3)
{
  return sub_806008C(a1, a2, a3, &dword_80728E9);
}
// 806008C: using guessed type _DWORD __cdecl sub_806008C(_DWORD, _DWORD, _DWORD, _DWORD);
// 80728E9: using guessed type int dword_80728E9;

//----- (080603B6) --------------------------------------------------------
int __cdecl sub_80603B6(int a1, int a2, int a3)
{
  char v4; // [esp+10h] [ebp-38h]

  sub_805EE38(&v4, a2);
  return sub_806008C(a1, a3, -1, &v4);
}
// 806008C: using guessed type _DWORD __cdecl sub_806008C(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (080603F8) --------------------------------------------------------
int __cdecl sub_80603F8(int a1, int a2, int a3, int a4)
{
  char v5; // [esp+10h] [ebp-38h]

  sub_805EE38(&v5, a2);
  return sub_806008C(a1, a3, a4, &v5);
}
// 806008C: using guessed type _DWORD __cdecl sub_806008C(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08060445) --------------------------------------------------------
int __cdecl sub_8060445(int a1, int a2)
{
  return sub_80603B6(0, a1, a2);
}

//----- (080604A4) --------------------------------------------------------
int __cdecl sub_80604A4(int a1, int a2, char a3)
{
  int v4; // [esp+0h] [ebp-58h]
  int v5; // [esp+8h] [ebp-50h]
  char v6; // [esp+1Ch] [ebp-3Ch]
  int v7; // [esp+20h] [ebp-38h]
  int v8; // [esp+24h] [ebp-34h]
  int v9; // [esp+28h] [ebp-30h]
  int v10; // [esp+2Ch] [ebp-2Ch]
  int v11; // [esp+30h] [ebp-28h]
  int v12; // [esp+34h] [ebp-24h]
  int v13; // [esp+38h] [ebp-20h]
  int v14; // [esp+3Ch] [ebp-1Ch]
  int v15; // [esp+40h] [ebp-18h]
  int v16; // [esp+44h] [ebp-14h]
  int v17; // [esp+48h] [ebp-10h]
  int v18; // [esp+4Ch] [ebp-Ch]

  v6 = a3;
  v7 = dword_80728E9;
  v8 = dword_80728ED;
  v9 = dword_80728F1;
  v10 = dword_80728F5;
  v11 = dword_80728F9;
  v12 = dword_80728FD;
  v13 = dword_8072901;
  v14 = dword_8072905;
  v15 = dword_8072909;
  v16 = dword_807290D;
  v17 = dword_8072911;
  v18 = dword_8072915;
  v5 = 1;
  sub_805ECE3(&v4 - 14, a3);
  return sub_806008C(0, a1, a2, &v7);
}
// 805ECE3: using guessed type _DWORD __cdecl sub_805ECE3(_DWORD, _DWORD);
// 806008C: using guessed type _DWORD __cdecl sub_806008C(_DWORD, _DWORD, _DWORD, _DWORD);
// 80728E9: using guessed type int dword_80728E9;
// 80728ED: using guessed type int dword_80728ED;
// 80728F1: using guessed type int dword_80728F1;
// 80728F5: using guessed type int dword_80728F5;
// 80728F9: using guessed type int dword_80728F9;
// 80728FD: using guessed type int dword_80728FD;
// 8072901: using guessed type int dword_8072901;
// 8072905: using guessed type int dword_8072905;
// 8072909: using guessed type int dword_8072909;
// 807290D: using guessed type int dword_807290D;
// 8072911: using guessed type int dword_8072911;
// 8072915: using guessed type int dword_8072915;

//----- (08060562) --------------------------------------------------------
int __cdecl sub_8060562(int a1, char a2)
{
  return sub_80604A4(a1, -1, a2);
}

//----- (080605A9) --------------------------------------------------------
int __cdecl sub_80605A9(int a1)
{
  return sub_8060562(a1, 58);
}

//----- (080605EA) --------------------------------------------------------
int __cdecl sub_80605EA(int a1, int a2, int a3)
{
  int v4; // [esp+0h] [ebp-78h]
  int v5; // [esp+8h] [ebp-70h]
  int v6; // [esp+10h] [ebp-68h]
  int v7; // [esp+14h] [ebp-64h]
  int v8; // [esp+18h] [ebp-60h]
  int v9; // [esp+1Ch] [ebp-5Ch]
  int v10; // [esp+20h] [ebp-58h]
  int v11; // [esp+24h] [ebp-54h]
  int v12; // [esp+28h] [ebp-50h]
  int v13; // [esp+2Ch] [ebp-4Ch]
  int v14; // [esp+30h] [ebp-48h]
  int v15; // [esp+34h] [ebp-44h]
  int v16; // [esp+38h] [ebp-40h]
  int v17; // [esp+3Ch] [ebp-3Ch]
  int v18; // [esp+40h] [ebp-38h]
  int v19; // [esp+44h] [ebp-34h]
  int v20; // [esp+48h] [ebp-30h]
  int v21; // [esp+4Ch] [ebp-2Ch]
  int v22; // [esp+50h] [ebp-28h]
  int v23; // [esp+54h] [ebp-24h]
  int v24; // [esp+58h] [ebp-20h]
  int v25; // [esp+5Ch] [ebp-1Ch]
  int v26; // [esp+60h] [ebp-18h]
  int v27; // [esp+64h] [ebp-14h]
  int v28; // [esp+68h] [ebp-10h]
  int v29; // [esp+6Ch] [ebp-Ch]

  sub_805EE38(&v6, a2);
  v18 = v6;
  v19 = v7;
  v20 = v8;
  v21 = v9;
  v22 = v10;
  v23 = v11;
  v24 = v12;
  v25 = v13;
  v26 = v14;
  v27 = v15;
  v28 = v16;
  v29 = v17;
  v5 = 1;
  sub_805ECE3(&v4 - 14, 58);
  return sub_806008C(a1, a3, -1, &v18);
}
// 805ECE3: using guessed type _DWORD __cdecl sub_805ECE3(_DWORD, _DWORD);
// 806008C: using guessed type _DWORD __cdecl sub_806008C(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0806069B) --------------------------------------------------------
int __cdecl sub_806069B(int a1, int a2, int a3, int a4)
{
  return sub_80606DF(a3, a2, a3, a4, -1);
}

//----- (080606DF) --------------------------------------------------------
int __cdecl sub_80606DF(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [esp+0h] [ebp-48h]
  int v7; // [esp+10h] [ebp-38h]
  int v8; // [esp+14h] [ebp-34h]
  int v9; // [esp+18h] [ebp-30h]
  int v10; // [esp+1Ch] [ebp-2Ch]
  int v11; // [esp+20h] [ebp-28h]
  int v12; // [esp+24h] [ebp-24h]
  int v13; // [esp+28h] [ebp-20h]
  int v14; // [esp+2Ch] [ebp-1Ch]
  int v15; // [esp+30h] [ebp-18h]
  int v16; // [esp+34h] [ebp-14h]
  int v17; // [esp+38h] [ebp-10h]
  int v18; // [esp+3Ch] [ebp-Ch]

  v7 = dword_80728E9;
  v8 = dword_80728ED;
  v9 = dword_80728F1;
  v10 = dword_80728F5;
  v11 = dword_80728F9;
  v12 = dword_80728FD;
  v13 = dword_8072901;
  v14 = dword_8072905;
  v15 = dword_8072909;
  v16 = dword_807290D;
  v17 = dword_8072911;
  v18 = dword_8072915;
  sub_805EDF7(&v6 - 14, a2, a3);
  return sub_806008C(a1, a4, a5, &v7);
}
// 806008C: using guessed type _DWORD __cdecl sub_806008C(_DWORD, _DWORD, _DWORD, _DWORD);
// 80728E9: using guessed type int dword_80728E9;
// 80728ED: using guessed type int dword_80728ED;
// 80728F1: using guessed type int dword_80728F1;
// 80728F5: using guessed type int dword_80728F5;
// 80728F9: using guessed type int dword_80728F9;
// 80728FD: using guessed type int dword_80728FD;
// 8072901: using guessed type int dword_8072901;
// 8072905: using guessed type int dword_8072905;
// 8072909: using guessed type int dword_8072909;
// 807290D: using guessed type int dword_807290D;
// 8072911: using guessed type int dword_8072911;
// 8072915: using guessed type int dword_8072915;

//----- (08060811) --------------------------------------------------------
int __cdecl sub_8060811(int a1, int a2, int a3)
{
  return sub_806008C(a1, a2, a3, &unk_807143C);
}
// 806008C: using guessed type _DWORD __cdecl sub_806008C(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0806086C) --------------------------------------------------------
#error "80608A9: call analysis failed (funcsize=25)"

//----- (080608B4) --------------------------------------------------------
int __cdecl sub_80608B4(int a1)
{
  return sub_806086C(0, a1);
}
// 806086C: using guessed type _DWORD __cdecl sub_806086C(_DWORD, _DWORD);

//----- (080608CF) --------------------------------------------------------
int sub_80608CF()
{
  bool v0; // al
  int *v1; // eax
  bool v2; // zf
  void *v3; // eax
  int *v4; // eax
  void *v5; // eax
  void *v6; // ST28_4
  void *v7; // ST2C_4
  void *s1; // [esp+0h] [ebp-FCh]
  void *s1a; // [esp+0h] [ebp-FCh]
  void *s2; // [esp+4h] [ebp-F8h]
  void *s2a; // [esp+4h] [ebp-F8h]
  size_t n; // [esp+8h] [ebp-F4h]
  size_t na; // [esp+8h] [ebp-F4h]
  int v15; // [esp+Ch] [ebp-F0h]
  char *v16; // [esp+10h] [ebp-ECh]
  int v17; // [esp+10h] [ebp-ECh]
  char *v18; // [esp+14h] [ebp-E8h]
  int v19; // [esp+14h] [ebp-E8h]
  size_t v20; // [esp+18h] [ebp-E4h]
  int v21; // [esp+18h] [ebp-E4h]
  size_t v22; // [esp+1Ch] [ebp-E0h]
  int v23; // [esp+1Ch] [ebp-E0h]
  int v24; // [esp+20h] [ebp-DCh]
  int v25; // [esp+20h] [ebp-DCh]
  int v26; // [esp+24h] [ebp-D8h]
  int v27; // [esp+24h] [ebp-D8h]
  __int64 v28; // [esp+28h] [ebp-D4h]
  int v29; // [esp+30h] [ebp-CCh]
  int v30; // [esp+34h] [ebp-C8h]
  int v31; // [esp+38h] [ebp-C4h]
  int v32; // [esp+3Ch] [ebp-C0h]
  int v33; // [esp+40h] [ebp-BCh]
  int v34; // [esp+44h] [ebp-B8h]
  int v35; // [esp+48h] [ebp-B4h]
  int v36; // [esp+4Ch] [ebp-B0h]
  int v37; // [esp+50h] [ebp-ACh]
  int v38; // [esp+54h] [ebp-A8h]
  int v39; // [esp+58h] [ebp-A4h]
  int v40; // [esp+5Ch] [ebp-A0h]
  int v41; // [esp+60h] [ebp-9Ch]
  int v42; // [esp+64h] [ebp-98h]
  int v43; // [esp+68h] [ebp-94h]
  __int64 v44; // [esp+80h] [ebp-7Ch]
  __int64 v45; // [esp+88h] [ebp-74h]
  __int64 v46; // [esp+E0h] [ebp-1Ch]
  void *v47; // [esp+F8h] [ebp-4h]
  void *retaddr; // [esp+FCh] [ebp+0h]

  v16 = (char *)sub_8056B4F(v47);
  v18 = (char *)sub_8056B4F(retaddr);
  v20 = sub_8056BCD(v16);
  v22 = sub_8056BCD(v18);
  v0 = v20 == v22 && !memcmp(v16, v18, v22);
  BYTE2(v15) = v0;
  HIBYTE(v15) = v0;
  BYTE1(v15) = 0;
  if ( v0 )
  {
    v24 = sub_8063C52(v47);
    v26 = sub_8063C52(retaddr);
    if ( sub_8064E18(v24, (int)&v28) )
    {
      v1 = __errno_location();
      v15 = v24;
      error(1, *v1, "%s");
    }
    v2 = sub_8064E18(v26, (int)&v45) == 0;
    v3 = &loc_8060A4B;
    if ( v2 )
      v3 = &loc_8060A74;
    dword_8071204 = (int)v3;
    sub_806532A(
      s1,
      s2,
      n,
      v15,
      v16,
      v18,
      v20,
      v22,
      v24,
      v26,
      v28,
      HIDWORD(v28),
      v29,
      v30,
      v31,
      v32,
      v33,
      v34,
      v35,
      v36,
      v37,
      v38,
      v39,
      v40,
      v41,
      v42,
      v43);
    v4 = __errno_location();
    error(1, *v4, "%s");
    v5 = &loc_8060AA5;
    if ( v44 != v46 )
      v5 = &loc_8060ACA;
    dword_80711F0 = (int)v5;
    sub_80653A0(s1a, s2a, na, v27, v17, v19, v21, v23, v25, v27, v28, HIDWORD(v28), v29, v30, v31);
    BYTE1(v15) = v28 == v45;
    free(v6);
    free(v7);
  }
  return BYTE1(v15);
}
// 8056B4F: using guessed type _DWORD __cdecl sub_8056B4F(_DWORD);
// 806532A: using guessed type int __stdcall sub_806532A(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80653A0: using guessed type int __stdcall sub_80653A0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80711F0: using guessed type int dword_80711F0;
// 8071204: using guessed type int dword_8071204;

//----- (08060B25) --------------------------------------------------------
void sub_8060B25()
{
  ;
}

//----- (08060B72) --------------------------------------------------------
signed int sub_8060B72()
{
  *__errno_location() = 95;
  return -1;
}

//----- (08060B92) --------------------------------------------------------
signed int sub_8060B92()
{
  *__errno_location() = 95;
  return -1;
}

//----- (08060CD0) --------------------------------------------------------
_DWORD *__userpurge sub_8060CD0@<eax>(_DWORD *a1, int a2)
{
  int v2; // edx

  v2 = *(_DWORD *)(a2 + 68);
  *a1 = *(_DWORD *)(a2 + 64);
  a1[1] = v2;
  return a1;
}

//----- (08060CFB) --------------------------------------------------------
_DWORD *__userpurge sub_8060CFB@<eax>(_DWORD *a1, int a2)
{
  int v2; // edx

  v2 = *(_DWORD *)(a2 + 84);
  *a1 = *(_DWORD *)(a2 + 80);
  a1[1] = v2;
  return a1;
}

//----- (08060D3C) --------------------------------------------------------
_DWORD *__userpurge sub_8060D3C@<eax>(_DWORD *a1, int a2)
{
  int v2; // edx

  v2 = *(_DWORD *)(a2 + 76);
  *a1 = *(_DWORD *)(a2 + 72);
  a1[1] = v2;
  return a1;
}

//----- (08060DD7) --------------------------------------------------------
int __cdecl sub_8060DD7(int a1, int a2, int a3, int a4)
{
  if ( a1 < a3 )
    return -1;
  if ( a1 > a3 )
    return 1;
  return a2 - a4;
}

//----- (08060E71) --------------------------------------------------------
#error "8061353: call analysis failed (funcsize=412)"

//----- (0806152F) --------------------------------------------------------
#error "8061596: call analysis failed (funcsize=34)"

//----- (0806159B) --------------------------------------------------------
#error "80615B9: positive sp value has been found (funcsize=0)"

//----- (080615BA) --------------------------------------------------------
int sub_80615BA(int a1, int a2, int a3, int a4, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a4);
  return sub_806152F(a3, a4, a3, a4, (char *)va);
}
// 806152F: using guessed type _DWORD __cdecl sub_806152F(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0806169A) --------------------------------------------------------
int __cdecl sub_806169A(unsigned int a1, unsigned int a2)
{
  if ( 0x7FFFFFFF / a2 < a1 )
    sub_8061996();
  return sub_80617BF(a2 * a1);
}

//----- (080616CC) --------------------------------------------------------
void *__cdecl sub_80616CC(void *ptr, int a2, int a3)
{
  if ( 0x7FFFFFFFu / a3 < a2 )
    sub_8061996();
  return sub_806182A(ptr, a3 * a2);
}

//----- (08061711) --------------------------------------------------------
void *__cdecl sub_8061711(void *ptr, int a2, int a3)
{
  unsigned int v4; // [esp+1Ch] [ebp-Ch]

  v4 = *(_DWORD *)a2;
  if ( ptr )
  {
    if ( 0x55555554u / a3 <= v4 )
      sub_8061996();
    v4 += (v4 >> 1) + 1;
  }
  else
  {
    if ( !v4 )
      v4 = (0x40u / a3 == 0) + 0x40u / a3;
    if ( 0x7FFFFFFFu / a3 < v4 )
      sub_8061996();
  }
  *(_DWORD *)a2 = v4;
  return sub_806182A(ptr, a3 * v4);
}

//----- (080617AC) --------------------------------------------------------
int __cdecl sub_80617AC(size_t a1)
{
  return sub_80617BF(a1);
}

//----- (080617BF) --------------------------------------------------------
int __cdecl sub_80617BF(size_t a1)
{
  void *v1; // eax
  bool v2; // zf
  void *v3; // eax
  size_t size; // [esp+0h] [ebp-2Ch]
  int v6; // [esp+4h] [ebp-28h]
  int v7; // [esp+8h] [ebp-24h]
  int v8; // [esp+Ch] [ebp-20h]
  int v9; // [esp+10h] [ebp-1Ch]
  int v10; // [esp+14h] [ebp-18h]
  int v11; // [esp+18h] [ebp-14h]
  void *v12; // [esp+1Ch] [ebp-10h]
  int v13; // [esp+1Ch] [ebp-10h]
  int v14; // [esp+20h] [ebp-Ch]
  int v15; // [esp+24h] [ebp-8h]

  v1 = malloc(a1);
  v12 = v1;
  v2 = v1 == 0;
  v3 = &loc_8061810;
  if ( !v2 )
    v3 = &loc_8061825;
  dword_8071218 = (int)v3;
  sub_80652BA(size, v6, v7, v8, v9, v10, v11, v12, v14, v15);
  if ( a1 )
    sub_8061996();
  return v13;
}
// 80652BA: using guessed type int __stdcall sub_80652BA(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8071218: using guessed type int dword_8071218;

//----- (0806182A) --------------------------------------------------------
void *__cdecl sub_806182A(void *ptr, size_t size)
{
  void *result; // eax
  void *ptra; // [esp+20h] [ebp+8h]

  if ( size || !ptr )
  {
    ptra = realloc(ptr, size);
    if ( !ptra )
    {
      if ( size )
        sub_8061996();
    }
    result = ptra;
  }
  else
  {
    free(ptr);
    result = 0;
  }
  return result;
}

//----- (08061879) --------------------------------------------------------
void *__cdecl sub_8061879(void *ptr, int a2)
{
  return sub_8061711(ptr, a2, 1);
}

//----- (08061928) --------------------------------------------------------
void *__cdecl sub_8061928(void *src, size_t n)
{
  void *v2; // eax

  v2 = (void *)sub_80617BF(n);
  return memcpy(v2, src, n);
}

//----- (08061955) --------------------------------------------------------
void *__cdecl sub_8061955(char *s)
{
  size_t v1; // ST04_4

  v1 = strlen(s) + 1;
  return sub_8061928(s, v1);
}

//----- (08061996) --------------------------------------------------------
void __noreturn sub_8061996()
{
  char *v0; // [esp+Ch] [ebp-Ch]

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (080619F1) --------------------------------------------------------
unsigned __int64 __cdecl sub_80619F1(char *nptr, int base, int a3, int a4, int a5, int a6, char *s, int a8, int status)
{
  int v9; // edx
  int v10; // ecx
  int v11; // ebx
  int v12; // edx
  signed int v13; // eax
  int v15; // [esp+0h] [ebp-48h]
  int v16; // [esp+Ch] [ebp-3Ch]
  int v17; // [esp+10h] [ebp-38h]
  unsigned __int64 v18; // [esp+20h] [ebp-28h]
  unsigned __int64 v19; // [esp+28h] [ebp-20h]
  int v20; // [esp+34h] [ebp-14h]
  unsigned __int64 v21; // [esp+38h] [ebp-10h]

  v19 = __PAIR__(a4, a3);
  v18 = __PAIR__(a6, a5);
  v20 = sub_80624C3(nptr, 0, base, (int)&v21, s);
  if ( v20 )
  {
    if ( v20 == 1 )
    {
      *__errno_location() = 75;
      dword_8071268 = (int)&loc_8061AEC;
      sub_80650DF(v10, v9, v15);
    }
    if ( v20 == 3 )
      *__errno_location() = 0;
  }
  else if ( v21 < v19 || v18 < v21 )
  {
    v20 = 1;
    if ( v21 <= 0x3FFFFFFF )
      *__errno_location() = 34;
    else
      *__errno_location() = 75;
  }
  if ( v20 )
  {
    v11 = sub_80608B4((int)nptr);
    if ( *__errno_location() == 22 )
      v12 = 0;
    else
      v12 = *__errno_location();
    if ( status )
      v13 = status;
    else
      v13 = 1;
    v17 = v11;
    v16 = a8;
    error(v13, v12, "%s: %s", a8, v11);
  }
  return v21;
}
// 80650DF: using guessed type int __fastcall sub_80650DF(_DWORD, _DWORD, _DWORD);
// 8071268: using guessed type int dword_8071268;

//----- (08061BE1) --------------------------------------------------------
char *sub_8061BE1()
{
  char *v0; // eax
  int v1; // edx
  int v2; // ecx
  bool v3; // zf
  void *v4; // eax
  int v6; // [esp+0h] [ebp-28h]
  char *v7; // [esp+1Ch] [ebp-Ch]

  v0 = getcwd(0, 0);
  v7 = v0;
  v3 = v0 == 0;
  v4 = &loc_8061C1D;
  if ( !v3 )
    v4 = &loc_8061C40;
  dword_8071268 = (int)v4;
  sub_80650DF(v2, v1, v6);
  if ( *__errno_location() == 12 )
    sub_8061996();
  return v7;
}
// 80650DF: using guessed type int __fastcall sub_80650DF(_DWORD, _DWORD, _DWORD);
// 8071268: using guessed type int dword_8071268;

//----- (08061C45) --------------------------------------------------------
char *sub_8061C45()
{
  void *v0; // eax
  int v2; // [esp+0h] [ebp-28h]
  int v3; // [esp+4h] [ebp-24h]
  int v4; // [esp+8h] [ebp-20h]
  int v5; // [esp+Ch] [ebp-1Ch]
  int v6; // [esp+10h] [ebp-18h]
  char *name; // [esp+14h] [ebp-14h]
  size_t len; // [esp+18h] [ebp-10h]
  int v9; // [esp+1Ch] [ebp-Ch]

  name = 0;
  v6 = 34;
  while ( 1 )
  {
    name = (char *)sub_8061879(name, (int)&v6);
    len = v6 - 1;
    name[v6 - 2] = 0;
    *__errno_location() = 0;
    if ( !gethostname(name, len) )
      break;
    if ( *__errno_location() && *__errno_location() != 36 && *__errno_location() != 22 && *__errno_location() != 12 )
    {
      v9 = *__errno_location();
      free(name);
      *__errno_location() = v9;
      return 0;
    }
  }
  v0 = &loc_8061CD1;
  if ( name[len - 1] )
    v0 = &loc_8061D3D;
  dword_807122C = (int)v0;
  sub_8065244(v2, v3, v4, v5);
  return name;
}
// 8065244: using guessed type int __stdcall sub_8065244(_DWORD, _DWORD, _DWORD, _DWORD);
// 807122C: using guessed type int dword_807122C;

//----- (08061D44) --------------------------------------------------------
#error "8061D79: call analysis failed (funcsize=19)"

//----- (08061D7E) --------------------------------------------------------
#error "8061DB0: positive sp value has been found (funcsize=0)"

//----- (08061DB1) --------------------------------------------------------
int __cdecl sub_8061DB1(int a1, int a2, int a3)
{
  int v3; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; i |= sub_8061D44(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}
// 8061D44: using guessed type _DWORD __cdecl sub_8061D44(_DWORD, _DWORD);

//----- (08061DEB) --------------------------------------------------------
int __cdecl sub_8061DEB(char *nptr, int a2, int base, int a4, char *s)
{
  void *v5; // eax
  int v6; // edx
  int v7; // ecx
  char v8; // ST27_1
  int v9; // edx
  int v10; // ecx
  int v11; // ST08_4
  int result; // eax
  int v13; // ecx
  int v14; // eax
  int v15; // ST08_4
  int v16; // ST0C_4
  int v17; // edx
  int v18; // ecx
  char *v19; // edx
  void *v20; // eax
  int v21; // [esp+0h] [ebp-48h]
  int v22; // [esp+0h] [ebp-48h]
  int v23; // [esp+4h] [ebp-44h]
  int v24; // [esp+4h] [ebp-44h]
  int v25; // [esp+8h] [ebp-40h]
  int v26; // [esp+8h] [ebp-40h]
  int v27; // [esp+Ch] [ebp-3Ch]
  int v28; // [esp+Ch] [ebp-3Ch]
  int v29; // [esp+10h] [ebp-38h]
  int v30; // [esp+14h] [ebp-34h]
  int v31; // [esp+18h] [ebp-30h]
  int v32; // [esp+1Ch] [ebp-2Ch]
  unsigned __int8 v33; // [esp+1Fh] [ebp-29h]
  int v34; // [esp+20h] [ebp-28h]
  unsigned int v35; // [esp+24h] [ebp-24h]
  int v36; // [esp+28h] [ebp-20h]
  char *v37; // [esp+2Ch] [ebp-1Ch]
  int v38; // [esp+30h] [ebp-18h]
  int v39; // [esp+34h] [ebp-14h]
  int v40; // [esp+38h] [ebp-10h]
  char **endptr; // [esp+3Ch] [ebp-Ch]

  v36 = 0;
  if ( base < 0 || base > 36 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoul");
  v5 = &loc_8061E23;
  if ( a2 )
    v5 = &loc_8061E63;
  dword_8071218 = (int)v5;
  sub_80652BA(v21, v23, v25, v27, v29, v30, v31, v32, v34, v35);
  dword_8071254 = (int)&loc_8061E66;
  sub_806514F(v7, v6);
  endptr = (char **)a2;
  *__errno_location() = 0;
  v37 = nptr;
  v8 = *nptr;
  dword_8071268 = (int)&loc_8061EA7;
  sub_80650DF(v10, v9, v11);
  do
    v33 = *++v37;
  while ( (*__ctype_b_loc())[v33] & 0x2000 );
  if ( v33 == 45 )
    return 4;
  v35 = strtoul(nptr, endptr, base);
  if ( *endptr == nptr )
  {
    if ( !s || !**endptr || !strchr(s, **endptr) )
      return 4;
    v35 = 1;
  }
  else if ( *__errno_location() )
  {
    if ( *__errno_location() != 34 )
      return 4;
    v36 = 1;
  }
  if ( !s )
  {
    *(_DWORD *)a4 = v35;
    return v36;
  }
  if ( !**endptr )
  {
LABEL_52:
    *(_DWORD *)a4 = v35;
    return v36;
  }
  v38 = 1024;
  v39 = 1;
  if ( !strchr(s, **endptr) )
  {
    *(_DWORD *)a4 = v35;
    return v36 | 2;
  }
  switch ( **endptr )
  {
    case 69:
    case 71:
    case 75:
    case 77:
    case 80:
    case 84:
    case 89:
    case 90:
    case 103:
    case 107:
    case 109:
    case 116:
      if ( strchr(s, 48) )
      {
        v14 = (*endptr)[1];
        switch ( v14 )
        {
          case 68:
            goto LABEL_55;
          case 105:
            if ( (*endptr)[2] == 66 )
              v39 += 2;
            goto LABEL_35;
          case 66:
LABEL_55:
            v38 = 1000;
            ++v39;
            break;
        }
      }
      break;
    default:
      break;
  }
LABEL_35:
  switch ( **endptr )
  {
    case 66:
      goto LABEL_37;
    case 69:
      v40 = sub_8061DB1((int)&v35, v38, 6);
      goto LABEL_49;
    case 71:
    case 103:
      v40 = sub_8061DB1((int)&v35, v38, 3);
      goto LABEL_49;
    case 75:
    case 107:
      v40 = sub_8061DB1((int)&v35, v38, 1);
      goto LABEL_49;
    case 77:
    case 109:
      v40 = sub_8061DB1((int)&v35, v38, 2);
      goto LABEL_49;
    case 80:
      v40 = sub_8061DB1((int)&v35, v38, 5);
      goto LABEL_49;
    case 84:
    case 116:
      v40 = sub_8061DB1((int)&v35, v38, 4);
      goto LABEL_49;
    case 89:
      v40 = sub_8061DB1((int)&v35, v38, 8);
      goto LABEL_49;
    case 90:
      v40 = sub_8061DB1((int)&v35, v38, 7);
      goto LABEL_49;
    case 98:
      v40 = sub_8061D44(&v35, 512);
      dword_807122C = (int)&loc_80621F8;
      sub_8065244(v15, v16, v26, v28);
LABEL_37:
      v40 = sub_8061D44(&v35, 1024);
      dword_807127C = (int)&loc_80621F8;
      sub_806506B(v18, v17);
      goto LABEL_38;
    case 99:
LABEL_38:
      v40 = 0;
      goto LABEL_49;
    case 119:
      v40 = sub_8061D44(&v35, 2);
LABEL_49:
      v36 |= v40;
      v19 = &(*endptr)[v39];
      *endptr = v19;
      v20 = &loc_8062242;
      if ( !**endptr )
        v20 = &loc_8062246;
      dword_8071240 = (int)v20;
      sub_80651D4(v13, v19, v22, v24);
      v36 |= 2u;
      goto LABEL_52;
    default:
      *(_DWORD *)a4 = v35;
      result = v36 | 2;
      break;
  }
  return result;
}
// 8061DEB: could not find valid save-restore pair for ebx
// 8061D44: using guessed type _DWORD __cdecl sub_8061D44(_DWORD, _DWORD);
// 806506B: using guessed type int __fastcall sub_806506B(_DWORD, _DWORD);
// 80650DF: using guessed type int __fastcall sub_80650DF(_DWORD, _DWORD, _DWORD);
// 806514F: using guessed type int __fastcall sub_806514F(_DWORD, _DWORD);
// 8065244: using guessed type int __stdcall sub_8065244(_DWORD, _DWORD, _DWORD, _DWORD);
// 80652BA: using guessed type int __stdcall sub_80652BA(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8071218: using guessed type int dword_8071218;
// 807122C: using guessed type int dword_807122C;
// 8071240: using guessed type int dword_8071240;
// 8071254: using guessed type int dword_8071254;
// 8071268: using guessed type int dword_8071268;
// 807127C: using guessed type int dword_807127C;

//----- (08062253) --------------------------------------------------------
#error "8062330: call analysis failed (funcsize=73)"

//----- (08062343) --------------------------------------------------------
#error "8062363: positive sp value has been found (funcsize=0)"

//----- (08062364) --------------------------------------------------------
void __cdecl __noreturn sub_8062364(int a1, int a2, char a3, int a4, int a5)
{
  sub_8062253(a1, a2, a3, a4, a5);
  abort();
}
// 8062253: using guessed type _DWORD __cdecl sub_8062253(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (080623BB) --------------------------------------------------------
signed int __cdecl sub_80623BB(int a1)
{
  int *v1; // ebp
  unsigned int v2; // ecx
  unsigned int v3; // edx
  unsigned int v4; // ebx
  unsigned int v5; // edx
  _DWORD *v6; // eax
  signed int result; // eax
  __int64 v8; // rax
  _DWORD *v9; // ecx
  int v10; // [esp-24h] [ebp-28h]
  _DWORD *v11; // [esp-1Ch] [ebp-20h]
  int v12; // [esp-18h] [ebp-1Ch]
  int v13; // [esp+0h] [ebp-4h]
  unsigned int *retaddr; // [esp+8h] [ebp+4h]

  v1 = &v13;
  v2 = sub_8064A4F(-1LL, a1, a1 >> 31);
  v4 = v3;
  v5 = retaddr[1];
  if ( v4 > v5 || v4 >= v5 && (v1 = &v10, v2 >= *retaddr) )
  {
    v8 = v12 * *(_QWORD *)v1[2];
    v9 = v11;
    *v11 = v8;
    v9[1] = HIDWORD(v8);
    result = 0;
  }
  else
  {
    v6 = (_DWORD *)v1[2];
    *v6 = -1;
    v6[1] = -1;
    result = 1;
  }
  return result;
}
// 8064A4F: using guessed type _DWORD __cdecl sub_8064A4F(__int64, _DWORD, _DWORD);

//----- (08062489) --------------------------------------------------------
int __cdecl sub_8062489(int a1, int a2, int a3)
{
  int v3; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; ; i |= sub_80623BB(a1) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}

//----- (080624C3) --------------------------------------------------------
int __cdecl sub_80624C3(char *nptr, int a2, int base, int a4, char *s)
{
  void *v5; // eax
  int result; // eax
  uintmax_t v7; // rax
  int v8; // ecx
  void *v9; // eax
  bool v10; // zf
  int v11; // edx
  int v12; // ecx
  void *v13; // eax
  int v14; // edx
  int v15; // edx
  int v16; // eax
  int v17; // edx
  int v18; // ecx
  int v19; // ST08_4
  int v20; // edx
  int v21; // edx
  int v22; // [esp+0h] [ebp-48h]
  int v23; // [esp+0h] [ebp-48h]
  int v24; // [esp+4h] [ebp-44h]
  int v25; // [esp+4h] [ebp-44h]
  int v26; // [esp+8h] [ebp-40h]
  int v27; // [esp+8h] [ebp-40h]
  int v28; // [esp+Ch] [ebp-3Ch]
  int v29; // [esp+Ch] [ebp-3Ch]
  int v30; // [esp+10h] [ebp-38h]
  int v31; // [esp+14h] [ebp-34h]
  int v32; // [esp+18h] [ebp-30h]
  unsigned __int8 i; // [esp+1Bh] [ebp-2Dh]
  int v34; // [esp+1Ch] [ebp-2Ch]
  int v35; // [esp+20h] [ebp-28h]
  char *v36; // [esp+24h] [ebp-24h]
  int v37; // [esp+28h] [ebp-20h]
  int v38; // [esp+2Ch] [ebp-1Ch]
  int v39; // [esp+30h] [ebp-18h]
  char **endptr; // [esp+34h] [ebp-14h]
  uintmax_t v41; // [esp+38h] [ebp-10h]

  v35 = 0;
  if ( base < 0 || base > 36 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoumax");
  v5 = &loc_80624FB;
  if ( a2 )
    v5 = &loc_8062526;
  dword_80711F0 = (int)v5;
  sub_80653A0(v22, v24, v26, v28, v30, v31, v32, v34, v35, v36, v37, v38, v39, endptr, v41);
  endptr = (char **)&v34;
  *__errno_location() = 0;
  v36 = nptr;
  for ( i = *nptr; (*__ctype_b_loc())[i] & 0x2000; i = *v36 )
    ++v36;
  if ( i == 45 )
    return 4;
  v7 = strtoumax(nptr, endptr, base);
  v41 = v7;
  if ( *endptr != nptr )
    goto LABEL_18;
  if ( !s )
    goto LABEL_57;
  v9 = &loc_80625D7;
  if ( !**endptr )
    v9 = &loc_8062605;
  dword_807122C = (int)v9;
  sub_8065244(v23, v25, v27, v29);
  if ( !strchr(s, **endptr) )
  {
LABEL_57:
    dword_8071254 = (int)&locret_806293A;
    sub_806514F(v8, HIDWORD(v7));
LABEL_18:
    v10 = *__errno_location() == 0;
    v13 = &loc_8062645;
    if ( v10 )
      v13 = &loc_8062662;
    dword_8071268 = (int)v13;
    sub_80650DF(v12, v11, v23);
    if ( *__errno_location() != 34 )
      return 4;
    v35 = 1;
    goto LABEL_23;
  }
  v41 = 1LL;
LABEL_23:
  if ( !s )
  {
    v14 = HIDWORD(v41);
    *(_DWORD *)a4 = v41;
    *(_DWORD *)(a4 + 4) = v14;
    return v35;
  }
  if ( !**endptr )
  {
LABEL_54:
    v21 = HIDWORD(v41);
    *(_DWORD *)a4 = v41;
    *(_DWORD *)(a4 + 4) = v21;
    return v35;
  }
  v37 = 1024;
  v38 = 1;
  if ( !strchr(s, **endptr) )
  {
    v15 = HIDWORD(v41);
    *(_DWORD *)a4 = v41;
    *(_DWORD *)(a4 + 4) = v15;
    return v35 | 2;
  }
  switch ( **endptr )
  {
    case 69:
    case 71:
    case 75:
    case 77:
    case 80:
    case 84:
    case 89:
    case 90:
    case 103:
    case 107:
    case 109:
    case 116:
      if ( strchr(s, 48) )
      {
        v16 = (*endptr)[1];
        switch ( v16 )
        {
          case 68:
            goto LABEL_58;
          case 105:
            if ( (*endptr)[2] == 66 )
              v38 += 2;
            goto LABEL_38;
          case 66:
LABEL_58:
            v37 = 1000;
            ++v38;
            break;
        }
      }
      break;
    default:
      break;
  }
LABEL_38:
  switch ( **endptr )
  {
    case 66:
      v39 = sub_80623BB((int)&v41);
      goto LABEL_52;
    case 69:
      v39 = sub_8062489((int)&v41, v37, 6);
      goto LABEL_52;
    case 71:
    case 103:
      v39 = sub_8062489((int)&v41, v37, 3);
      goto LABEL_52;
    case 75:
    case 107:
      v39 = sub_8062489((int)&v41, v37, 1);
      dword_8071268 = (int)&loc_80628F4;
      sub_80650DF(v18, v17, v19);
      goto LABEL_45;
    case 77:
    case 109:
LABEL_45:
      v39 = sub_8062489((int)&v41, v37, 2);
      goto LABEL_52;
    case 80:
      v39 = sub_8062489((int)&v41, v37, 5);
      goto LABEL_52;
    case 84:
    case 116:
      v39 = sub_8062489((int)&v41, v37, 4);
      goto LABEL_52;
    case 89:
      v39 = sub_8062489((int)&v41, v37, 8);
      goto LABEL_52;
    case 90:
      v39 = sub_8062489((int)&v41, v37, 7);
      goto LABEL_52;
    case 98:
      v39 = sub_80623BB((int)&v41);
      goto LABEL_52;
    case 99:
      v39 = 0;
      goto LABEL_52;
    case 119:
      v39 = sub_80623BB((int)&v41);
LABEL_52:
      v35 |= v39;
      *endptr += v38;
      if ( **endptr )
        v35 |= 2u;
      goto LABEL_54;
    default:
      v20 = HIDWORD(v41);
      *(_DWORD *)a4 = v41;
      *(_DWORD *)(a4 + 4) = v20;
      result = v35 | 2;
      break;
  }
  return result;
}
// 80624C3: could not find valid save-restore pair for ebx
// 80650DF: using guessed type int __fastcall sub_80650DF(_DWORD, _DWORD, _DWORD);
// 806514F: using guessed type int __fastcall sub_806514F(_DWORD, _DWORD);
// 8065244: using guessed type int __stdcall sub_8065244(_DWORD, _DWORD, _DWORD, _DWORD);
// 80653A0: using guessed type int __stdcall sub_80653A0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80711F0: using guessed type int dword_80711F0;
// 807122C: using guessed type int dword_807122C;
// 8071254: using guessed type int dword_8071254;
// 8071268: using guessed type int dword_8071268;

//----- (0806293C) --------------------------------------------------------
int __cdecl sub_806293C(wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  int *v4; // ebp
  int v6; // [esp+0h] [ebp-28h]
  _DWORD *v7; // [esp+8h] [ebp-20h]
  _BYTE *v8; // [esp+Ch] [ebp-1Ch]
  char v9; // [esp+18h] [ebp-10h]
  size_t v10; // [esp+1Ch] [ebp-Ch]
  int savedregs; // [esp+28h] [ebp+0h]

  v4 = &savedregs;
  if ( !pwc )
    pwc = (wchar_t *)&v9;
  v10 = mbrtowc(pwc, s, n, p);
  if ( v10 <= 0xFFFFFFFD )
    return *(v4 - 3);
  if ( !n )
    return *(v4 - 3);
  v4 = &v6;
  if ( !((unsigned __int8)sub_805793E(0) ^ 1) )
    return *(v4 - 3);
  *((_BYTE *)&v6 - 17) = *v8;
  *v7 = *((unsigned __int8 *)&v6 - 17);
  return 1;
}

//----- (080629D0) --------------------------------------------------------
int __cdecl sub_80629D0(int a1, int a2)
{
  int result; // eax

  if ( *(_BYTE *)(a1 + 40) & 1 )
    result = (*(int (__cdecl **)(_DWORD, int))(a1 + 28))(*(_DWORD *)(a1 + 36), a2);
  else
    result = (*(int (__cdecl **)(int))(a1 + 28))(a2);
  return result;
}

//----- (08062A12) --------------------------------------------------------
int __cdecl sub_8062A12(int a1, int a2)
{
  int result; // eax

  if ( *(_BYTE *)(a1 + 40) & 1 )
    result = (*(int (__cdecl **)(_DWORD, int))(a1 + 32))(*(_DWORD *)(a1 + 36), a2);
  else
    result = (*(int (__cdecl **)(int))(a1 + 32))(a2);
  return result;
}

//----- (08062A54) --------------------------------------------------------
#error "8062AA9: call analysis failed (funcsize=27)"

//----- (08062AAE) --------------------------------------------------------
#error "8062AC7: call analysis failed (funcsize=30)"

//----- (08062B0C) --------------------------------------------------------
signed int __usercall sub_8062B0C@<eax>(int a1@<eax>, int a2, int a3, int a4, int a5)
{
  void *retaddr; // [esp+0h] [ebp+0h]

  *(_DWORD *)(a3 + 8) = (a1 + 8 + a5 - 1) & -a5;
  *(_DWORD *)(a3 + 12) = *(_DWORD *)(a3 + 8);
  *(_DWORD *)*(&retaddr - 3) = (char *)*(&retaddr - 3) + *(_DWORD *)a3;
  *(_DWORD *)(a3 + 16) = *(_DWORD *)*(&retaddr - 3);
  *((_DWORD *)*(&retaddr - 3) + 1) = 0;
  *(_BYTE *)(a3 + 40) &= 0xFDu;
  *(_BYTE *)(a3 + 40) &= 0xFBu;
  return 1;
}
// 8062B0C: could not find valid save-restore pair for ebp

//----- (08062B8F) --------------------------------------------------------
int __cdecl sub_8062B8F(int a1, int a2, int a3, int a4, int a5)
{
  *(_DWORD *)(a1 + 28) = a4;
  *(_DWORD *)(a1 + 32) = a5;
  *(_BYTE *)(a1 + 40) &= 0xFEu;
  return sub_8062A54(a1, a2, a3);
}
// 8062A54: using guessed type _DWORD __cdecl sub_8062A54(_DWORD, _DWORD, _DWORD);

//----- (08062C3C) --------------------------------------------------------
int __cdecl sub_8062C3C(int a1)
{
  int result; // eax
  int v2; // [esp+0h] [ebp-38h]
  int v3; // [esp+4h] [ebp-34h]
  int v4; // [esp+8h] [ebp-30h]
  int v5; // [esp+Ch] [ebp-2Ch]
  int v6; // [esp+14h] [ebp-24h]
  int v7; // [esp+1Ch] [ebp-1Ch]

  v7 = *(_DWORD *)(a1 + 4);
  v6 = 0;
  *(&v2 - 6) = *(_DWORD *)(a1 + 12) - *(_DWORD *)(v4 + 8);
  *(&v2 - 5) = *(&v2 - 6) + v5;
  *(&v2 - 4) = *(_DWORD *)(v4 + 24) + *(&v2 - 5);
  *(&v2 - 8) = ((unsigned int)*(&v2 - 6) >> 3) + *(&v2 - 4) + 100;
  if ( *(&v2 - 8) < (unsigned int)*(&v2 - 4) )
    *(&v2 - 8) = *(&v2 - 4);
  if ( *(_DWORD *)v4 > (unsigned int)*(&v2 - 8) )
    *(&v2 - 8) = *(_DWORD *)v4;
  if ( *(&v2 - 6) <= (unsigned int)*(&v2 - 5) && *(&v2 - 5) <= (unsigned int)*(&v2 - 4) )
  {
    v3 = *(&v2 - 8);
    *(&v2 - 9) = sub_80629D0(v4, v3);
  }
  if ( !*(&v2 - 9) )
    obstack_alloc_failed_handler();
  *(_DWORD *)(v4 + 4) = *(&v2 - 9);
  *(_DWORD *)(*(&v2 - 9) + 4) = *(&v2 - 7);
  *(_DWORD *)(v4 + 16) = *(&v2 - 8) + *(&v2 - 9);
  *(_DWORD *)*(&v2 - 9) = *(_DWORD *)(v4 + 16);
  *(&v2 - 3) = (*(_DWORD *)(v4 + 24) + *(&v2 - 9) + 8) & ~*(_DWORD *)(v4 + 24);
  memcpy((void *)*(&v2 - 3), *(const void **)(v4 + 8), *(&v2 - 6));
  if ( !(*(_BYTE *)(v4 + 40) & 2)
    && *(_DWORD *)(v4 + 8) == ((*(_DWORD *)(v4 + 24) + *(&v2 - 7) + 8) & ~*(_DWORD *)(v4 + 24)) )
  {
    *(_DWORD *)(*(&v2 - 9) + 4) = *(_DWORD *)(*(&v2 - 7) + 4);
    sub_8062A12(v4, *(&v2 - 7));
  }
  *(_DWORD *)(v4 + 8) = *(&v2 - 3);
  *(_DWORD *)(v4 + 12) = *(&v2 - 6) + *(_DWORD *)(v4 + 8);
  result = v4;
  *(_BYTE *)(v4 + 40) &= 0xFDu;
  return result;
}
// 80714C0: using guessed type int (*obstack_alloc_failed_handler)(void);

//----- (08062F9F) --------------------------------------------------------
int __cdecl sub_8062F9F(int a1, int a2)
{
  int v2; // ecx
  void *v3; // eax

  v3 = &loc_8062FCF;
  if ( (a1 == 0) == (a2 == 0) )
    v3 = &loc_8062FE6;
  dword_8071254 = (int)v3;
  sub_806514F(v2, a1 == 0);
  return a1 >= 0 && a2 >= 0;
}
// 806514F: using guessed type int __fastcall sub_806514F(_DWORD, _DWORD);
// 8071254: using guessed type int dword_8071254;

//----- (08062FF0) --------------------------------------------------------
_BOOL4 __cdecl sub_8062FF0(_DWORD *a1, _DWORD *a2)
{
  int v2; // ebx

  v2 = a1[5] ^ a2[5] | a1[4] ^ a2[4] | a1[3] ^ a2[3] | a1[2] ^ a2[2] | a1[1] ^ a2[1] | *a2 ^ *a1;
  return (v2 | (unsigned __int8)sub_8062F9F(a1[8], a2[8])) == 0;
}

//----- (080630A6) --------------------------------------------------------
char *__cdecl sub_80630A6(void *dest, void *src, size_t n)
{
  char *result; // eax

  memcpy(dest, src, n);
  result = (char *)dest + n;
  *((_BYTE *)dest + n) = 0;
  return result;
}

//----- (080630D6) --------------------------------------------------------
int __cdecl sub_80630D6(char *s)
{
  size_t v1; // eax
  int v2; // eax
  void *v3; // eax
  bool v4; // zf
  void *v5; // eax
  int v7; // [esp+0h] [ebp-28h]
  int v8; // [esp+4h] [ebp-24h]
  int v9; // [esp+8h] [ebp-20h]
  int v10; // [esp+Ch] [ebp-1Ch]
  int v11; // [esp+10h] [ebp-18h]
  size_t n; // [esp+14h] [ebp-14h]
  size_t na; // [esp+14h] [ebp-14h]
  int v14; // [esp+18h] [ebp-10h]
  void *v15; // [esp+1Ch] [ebp-Ch]
  int v16; // [esp+1Ch] [ebp-Ch]
  int v17; // [esp+20h] [ebp-8h]
  int v18; // [esp+24h] [ebp-4h]

  if ( s )
    v1 = strlen(s) + 1;
  else
    v1 = 0;
  n = v1;
  if ( v1 <= 0x3A )
    v2 = 59;
  else
    v2 = v1 + 1;
  v14 = v2;
  v3 = malloc((v2 + 12) & 0xFFFFFFF8);
  v15 = v3;
  v4 = v3 == 0;
  v5 = &loc_8063147;
  if ( v4 )
    v5 = &loc_8063198;
  dword_8071218 = (int)v5;
  sub_80652BA(v7, v8, v9, v10, v11, n, v14, v15, v17, v18);
  *(_DWORD *)v16 = 0;
  *(_BYTE *)(v16 + 4) = s != 0;
  *(_BYTE *)(v16 + 5) = 0;
  if ( s )
    sub_80630A6((void *)(v16 + 5), s, na);
  return v16;
}
// 80652BA: using guessed type int __stdcall sub_80652BA(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8071218: using guessed type int dword_8071218;

//----- (0806319D) --------------------------------------------------------
#error "8063226: call analysis failed (funcsize=165)"

//----- (080633B9) --------------------------------------------------------
void *__cdecl sub_80633B9(void *ptr)
{
  void *result; // eax
  void *v2; // ST1C_4

  result = (void *)1;
  if ( ptr != (void *)1 )
  {
    while ( ptr )
    {
      v2 = *(void **)ptr;
      free(ptr);
      result = v2;
      ptr = v2;
    }
  }
  return result;
}

//----- (080633EC) --------------------------------------------------------
char *sub_80633EC()
{
  return getenv("TZ");
}

//----- (0806341E) --------------------------------------------------------
int __cdecl sub_806341E(char *value)
{
  int result; // eax

  if ( value )
    result = setenv("TZ", (const char *)1, 1);
  else
    result = unsetenv("TZ");
  return result;
}

//----- (08063485) --------------------------------------------------------
signed int __cdecl sub_8063485(int a1)
{
  char *v1; // eax

  if ( *(_BYTE *)(a1 + 4) )
    v1 = (char *)(a1 + 5);
  else
    v1 = 0;
  if ( sub_806341E(v1) )
    return 0;
  tzset();
  return 1;
}

//----- (080634D2) --------------------------------------------------------
#error "806351E: call analysis failed (funcsize=55)"

//----- (080635CF) --------------------------------------------------------
int __cdecl sub_80635CF()
{
  void *v0; // eax
  int v2; // [esp+0h] [ebp-28h]
  int v3; // [esp+4h] [ebp-24h]
  int v4; // [esp+8h] [ebp-20h]
  int v5; // [esp+Ch] [ebp-1Ch]

  v0 = &loc_8063616;
  if ( v4 != 1 )
    v0 = &loc_806361D;
  dword_807122C = (int)v0;
  sub_8065244(v2, v3, v4, v5);
  return 1;
}
// 8065244: using guessed type int __stdcall sub_8065244(_DWORD, _DWORD, _DWORD, _DWORD);
// 807122C: using guessed type int dword_807122C;

//----- (08063673) --------------------------------------------------------
struct tm *__cdecl sub_8063673(int a1, time_t *timer, struct tm *tp)
{
  char v4; // al
  int v5; // edx
  int v6; // ecx
  void *v7; // eax
  char v8; // [esp+1Bh] [ebp-Dh]

  if ( !a1 )
    return gmtime_r(timer, tp);
  if ( !sub_80634D2(a1) )
    return 0;
  v4 = localtime_r(timer, tp) && (unsigned __int8)sub_806319D(a1, tp) ? 1 : 0;
  v8 = v4 & 1;
  if ( !(unsigned __int8)sub_80635CF() )
    return 0;
  v7 = &loc_806371B;
  if ( !v8 )
    v7 = &loc_8063720;
  dword_8071254 = (int)v7;
  sub_806514F(v6, v5);
  return tp;
}
// 806319D: using guessed type _DWORD __cdecl sub_806319D(_DWORD, _DWORD);
// 80634D2: using guessed type _DWORD __cdecl sub_80634D2(_DWORD);
// 806514F: using guessed type int __fastcall sub_806514F(_DWORD, _DWORD);
// 8071254: using guessed type int dword_8071254;

//----- (08063727) --------------------------------------------------------
int __cdecl sub_8063727(int a1, struct tm *tp)
{
  int result; // eax
  time_t v3; // eax
  bool v4; // zf
  void *v5; // eax
  int v6; // edx
  int v7; // ecx
  void *v8; // eax
  int v9; // [esp+0h] [ebp-58h]
  int v10; // [esp+4h] [ebp-54h]
  int v11; // [esp+8h] [ebp-50h]
  int v12; // [esp+Ch] [ebp-4Ch]
  int v13; // [esp+10h] [ebp-48h]
  int v14; // [esp+14h] [ebp-44h]
  time_t timer; // [esp+18h] [ebp-40h]
  void *ptr; // [esp+1Ch] [ebp-3Ch]
  time_t v17; // [esp+20h] [ebp-38h]
  struct tm v18; // [esp+24h] [ebp-34h]

  if ( !a1 )
    return timegm(tp);
  ptr = (void *)sub_80634D2(a1);
  if ( !ptr )
    goto LABEL_16;
  v3 = mktime(tp);
  timer = v3;
  v17 = -1;
  v4 = v3 == -1;
  v5 = &loc_806379B;
  if ( !v4 )
    v5 = &loc_80637E0;
  dword_80711F0 = (int)v5;
  sub_80653A0(
    v9,
    v10,
    v11,
    v12,
    v13,
    v14,
    timer,
    ptr,
    v17,
    v18.tm_sec,
    v18.tm_min,
    v18.tm_hour,
    v18.tm_mday,
    v18.tm_mon,
    v18.tm_year);
  if ( localtime_r(&timer, &v18) )
  {
    v4 = sub_8062FF0(tp, &v18) == 0;
    v8 = &loc_80637E0;
    if ( v4 )
      v8 = &loc_80637FF;
    dword_807127C = (int)v8;
    sub_806506B(v7, v6);
    if ( (unsigned __int8)sub_806319D(a1, tp) ^ 1 )
      timer = v17;
  }
  if ( (unsigned __int8)sub_80635CF() )
    result = timer;
  else
LABEL_16:
    result = -1;
  return result;
}
// 8063727: could not find valid save-restore pair for ebx
// 806319D: using guessed type _DWORD __cdecl sub_806319D(_DWORD, _DWORD);
// 80634D2: using guessed type _DWORD __cdecl sub_80634D2(_DWORD);
// 806506B: using guessed type int __fastcall sub_806506B(_DWORD, _DWORD);
// 80653A0: using guessed type int __stdcall sub_80653A0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80711F0: using guessed type int dword_80711F0;
// 807127C: using guessed type int dword_807127C;

//----- (08063997) --------------------------------------------------------
int __cdecl sub_8063997(int a1, char a2)
{
  return __ROR4__(a1, a2);
}

//----- (08063AE3) --------------------------------------------------------
#error "8063B60: call analysis failed (funcsize=66)"

//----- (08063BA8) --------------------------------------------------------
int __cdecl sub_8063BA8(FILE *fp)
{
  bool v1; // ST26_1
  int v2; // edx
  int v3; // ecx
  void *v4; // eax
  bool v6; // [esp+1Dh] [ebp-Bh]
  bool v7; // [esp+1Fh] [ebp-9h]

  v6 = __fpending(fp) != 0;
  v1 = ferror_unlocked(fp) != 0;
  v7 = sub_8064362(fp) != 0;
  v4 = &loc_8063C06;
  if ( v1 )
    v4 = &loc_8063C1E;
  dword_8071254 = (int)v4;
  sub_806514F(v3, v2);
  if ( !v7 || !v6 && *__errno_location() == 9 )
    return 0;
  if ( v7 != 1 )
    *__errno_location() = 0;
  return -1;
}
// 806514F: using guessed type int __fastcall sub_806514F(_DWORD, _DWORD);
// 8071254: using guessed type int dword_8071254;

//----- (08063C52) --------------------------------------------------------
int __cdecl sub_8063C52(void *src)
{
  int v2; // [esp+1Ch] [ebp-Ch]

  v2 = sub_8056AB0(src);
  if ( !v2 )
    sub_8061996();
  return v2;
}

//----- (08063C86) --------------------------------------------------------
int __cdecl sub_8063C86(_BYTE *a1, unsigned int a2)
{
  _BYTE *i; // [esp+8h] [ebp-8h]
  unsigned int v4; // [esp+Ch] [ebp-4h]

  v4 = 0;
  for ( i = a1; *i; ++i )
    v4 = __ROR4__(v4, 23) + (char)*i;
  return v4 % a2;
}

//----- (08063CCC) --------------------------------------------------------
#error "8063CFC: call analysis failed (funcsize=17)"

//----- (08063D01) --------------------------------------------------------
#error "806427C: positive sp value has been found (funcsize=229)"

//----- (0806427F) --------------------------------------------------------
const char *sub_806427F()
{
  bool v0; // zf
  int v1; // edx
  int v2; // ecx
  void *v3; // eax
  char *v4; // ST24_4
  const char *s1; // [esp+18h] [ebp-10h]
  char *s2; // [esp+1Ch] [ebp-Ch]

  s1 = nl_langinfo(14);
  if ( !s1 )
    s1 = (const char *)&unk_806ACBB;
  for ( s2 = (char *)sub_8063CCC(); *s2; s2 = &v4[strlen(v4) + 1] )
  {
    v0 = strcmp(s1, s2) == 0;
    v3 = &loc_80642ED;
    if ( v0 )
      v3 = &loc_8064304;
    dword_807127C = (int)v3;
    sub_806506B(v2, v1);
    if ( *s2 == 42 && !s2[1] )
    {
      s1 = &s2[strlen(s2) + 1];
      break;
    }
    v4 = &s2[strlen(s2) + 1];
  }
  if ( !*s1 )
    s1 = "ASCII";
  return s1;
}
// 8063CCC: using guessed type int sub_8063CCC(void);
// 806506B: using guessed type int __fastcall sub_806506B(_DWORD, _DWORD);
// 807127C: using guessed type int dword_807127C;

//----- (08064362) --------------------------------------------------------
int __cdecl sub_8064362(FILE *stream)
{
  __int64 v2; // rax
  int v3; // ecx
  int v4; // eax
  int v5; // [esp+0h] [ebp-28h]
  int v6; // [esp+14h] [ebp-14h]
  int v7; // [esp+18h] [ebp-10h]
  int v8; // [esp+1Ch] [ebp-Ch]

  v6 = 0;
  v7 = 0;
  v8 = fileno(stream);
  if ( v8 < 0 )
    return fclose(stream);
  if ( !__freading(stream) || (v4 = fileno(stream), LODWORD(v2) = lseek64(v4, 0, 0, 1), v3 = ~HIDWORD(v2), v2 != -1) )
  {
    if ( sub_806448E(SHIDWORD(v2), v3, stream) )
      v6 = *__errno_location();
  }
  *(&v5 - 4) = fclose(stream);
  if ( *(&v5 - 5) )
  {
    *__errno_location() = *(&v5 - 5);
    *(&v5 - 4) = -1;
  }
  return *(&v5 - 4);
}
// 8049A70: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08064447) --------------------------------------------------------
int __cdecl sub_8064447(FILE *stream)
{
  int result; // eax

  result = stream->_flags & 0x100;
  if ( result )
    result = sub_80644F3(stream, 0, 0, 1);
  return result;
}

//----- (0806448E) --------------------------------------------------------
int __usercall sub_806448E@<eax>(int a1@<edx>, int a2@<ecx>, FILE *fp)
{
  void *v3; // eax

  v3 = &loc_80644B3;
  if ( !fp )
    v3 = &loc_80644C2;
  dword_807127C = (int)v3;
  sub_806506B(a2, a1);
  if ( __freading(fp) )
    sub_8064447(fp);
  return fflush(fp);
}
// 806506B: using guessed type int __fastcall sub_806506B(_DWORD, _DWORD);
// 807127C: using guessed type int dword_807127C;

//----- (080644F3) --------------------------------------------------------
int __cdecl sub_80644F3(FILE *stream, int a2, int a3, int a4)
{
  int v4; // eax
  __int64 v5; // rax
  int v7; // edx
  int v8; // [esp+18h] [ebp-20h]
  int v9; // [esp+1Ch] [ebp-1Ch]
  __int64 v10; // [esp+28h] [ebp-10h]

  v8 = a2;
  v9 = a3;
  if ( stream->_IO_read_end != stream->_IO_read_ptr
    || stream->_IO_write_ptr != stream->_IO_write_base
    || stream->_IO_save_base )
  {
    return fseeko64(stream, v8, v9, a4);
  }
  v4 = fileno(stream);
  LODWORD(v5) = lseek64(v4, v8, v9, a4);
  v10 = v5;
  if ( v5 == -1 )
    return -1;
  stream->_flags &= 0xFFFFFFEF;
  v7 = HIDWORD(v10);
  LODWORD(stream->_offset) = v10;
  HIDWORD(stream->_offset) = v7;
  return 0;
}
// 8049610: using guessed type int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8049A70: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (080645F5) --------------------------------------------------------
#error "8064666: call analysis failed (funcsize=92)"

//----- (080647CE) --------------------------------------------------------
#error "8064934: call analysis failed (funcsize=200)"

//----- (08064A4F) --------------------------------------------------------
#error "8064AC6: call analysis failed (funcsize=140)"

//----- (08064BD9) --------------------------------------------------------
int __cdecl sub_8064BD9(unsigned __int64 a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // ecx
  unsigned int v4; // esi
  unsigned int v5; // eax
  int v8; // ebp
  int v9; // ebp
  unsigned int v10; // ebp
  unsigned __int64 v11; // rtt
  unsigned __int64 v12; // rax
  unsigned int v13; // edi
  unsigned __int64 v14; // rax
  unsigned int v15; // [esp+0h] [ebp-20h]
  unsigned int v16; // [esp+4h] [ebp-1Ch]
  unsigned __int64 v17; // [esp+8h] [ebp-18h]
  unsigned int v18; // [esp+10h] [ebp-10h]

  v3 = a1;
  v4 = a2;
  v16 = HIDWORD(a1);
  v5 = a3;
  v18 = a1;
  v15 = a2;
  v17 = a1;
  if ( a3 )
  {
    if ( a3 > HIDWORD(a1) )
      return a1;
    _BitScanReverse((unsigned int *)&v8, a3);
    v9 = v8 ^ 0x1F;
    if ( v9 )
    {
      v4 = 32 - v9;
      v16 = (a3 << v9) | (v15 >> (32 - v9));
      LODWORD(v17) = v15 << (char)&v15;
      HIDWORD(v12) = HIDWORD(a1) >> (32 - v9);
      LODWORD(v12) = (HIDWORD(a1) << (char)&v15) | (v18 >> (32 - v9));
      HIDWORD(v17) = v18 << (char)&v15;
      v13 = v12 % v16;
      v14 = (v15 << (char)&v15) * (unsigned __int64)(unsigned int)(v12 / v16);
      v15 = HIDWORD(v14);
      if ( v13 >= HIDWORD(v14) && (HIDWORD(v17) >= (unsigned int)v14 || v13 != HIDWORD(v14)) )
        return ((__PAIR__(v13, HIDWORD(v17)) - v14) >> 32 << v4) | ((unsigned int)(HIDWORD(v17) - v14) >> (char)&v15);
      dword_8071254 = (int)&loc_8064D08;
      v5 = sub_806514F(v14 - v17, (v14 - __PAIR__(v16, (unsigned int)v17)) >> 32);
    }
    else if ( v15 <= (unsigned int)v17 )
    {
      return __PAIR__(v16, v3) - __PAIR__(v5, v4);
    }
    if ( v5 >= HIDWORD(v17) )
      return v17;
    return __PAIR__(v16, v3) - __PAIR__(v5, v4);
  }
  if ( a2 > HIDWORD(a1) )
    return a1 % a2;
  v10 = a2;
  if ( !a2 )
    v10 = (unsigned int)&v15;
  LODWORD(v11) = a1;
  HIDWORD(v11) = v16 % v10;
  return v11 % v10;
}
// 806514F: using guessed type int __fastcall sub_806514F(_DWORD, _DWORD);
// 8071254: using guessed type int dword_8071254;

//----- (08064DE5) --------------------------------------------------------
int __cdecl sub_8064DE5(int a1)
{
  return __cxa_atexit(a1, 0, dword_80712C0);
}
// 80497B0: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 80712C0: using guessed type int dword_80712C0;

//----- (08064E18) --------------------------------------------------------
int __cdecl sub_8064E18(int a1, int a2)
{
  return __xstat64(3, a1, a2);
}
// 8049AE0: using guessed type int __cdecl __xstat64(_DWORD, _DWORD, _DWORD);

//----- (08064E4B) --------------------------------------------------------
int __cdecl sub_8064E4B(int a1, int a2)
{
  return __fxstat64(3, a1, a2);
}
// 8049730: using guessed type int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD);

//----- (08064E9A) --------------------------------------------------------
int __cdecl sub_8064E9A(int a1, int a2)
{
  return __lxstat64(3, a1, a2);
}
// 8049AF0: using guessed type int __cdecl __lxstat64(_DWORD, _DWORD, _DWORD);

//----- (08064FFD) --------------------------------------------------------
#error "8065003: positive sp value has been found (funcsize=0)"

//----- (0806506B) --------------------------------------------------------
#error "8065071: positive sp value has been found (funcsize=0)"

//----- (080650DF) --------------------------------------------------------
#error "80650E5: positive sp value has been found (funcsize=0)"

//----- (0806514F) --------------------------------------------------------
#error "8065155: positive sp value has been found (funcsize=0)"

//----- (080651D4) --------------------------------------------------------
#error "80651DA: positive sp value has been found (funcsize=0)"

//----- (08065244) --------------------------------------------------------
#error "806524A: positive sp value has been found (funcsize=0)"

//----- (080652BA) --------------------------------------------------------
#error "80652C0: positive sp value has been found (funcsize=0)"

//----- (0806532A) --------------------------------------------------------
#error "8065330: positive sp value has been found (funcsize=0)"

//----- (080653A0) --------------------------------------------------------
#error "80653A6: positive sp value has been found (funcsize=0)"

//----- (0806540E) --------------------------------------------------------
#error "8065414: positive sp value has been found (funcsize=0)"

//----- (08065420) --------------------------------------------------------
int (**sub_8065420())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_8070ED4;
  v1 = &off_8070ED8 - off_8070ED4;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_8070ED4[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 8070ED4: using guessed type int (*off_8070ED4[2])();
// 8070ED8: using guessed type int (*off_8070ED8)();

//----- (08065484) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 106 decompilation failure(s) on 419 function(s)"
