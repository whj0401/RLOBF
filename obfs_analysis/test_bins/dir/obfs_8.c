/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8049480();
// int unsetenv(const char *name);
// int raise(int sig);
// int strcmp(const char *s1, const char *s2);
// int __cdecl open64(_DWORD, _DWORD); weak
// int putc_unlocked(int c, FILE *stream);
// struct passwd *getpwuid(__uid_t uid);
// int printf(const char *format, ...);
// void longjmp(struct __jmp_buf_tag env[1], int val);
// int fflush(FILE *stream);
// void _exit(int status);
// int sigprocmask(int how, const sigset_t *set, sigset_t *oset);
// int dirfd(DIR *dirp);
// int __cdecl wcwidth(_DWORD); weak
// void *memmove(void *dest, const void *src, size_t n);
// int _setjmp(struct __jmp_buf_tag env[1]);
// void free(void *ptr);
// uintmax_t strtoumax(const char *nptr, char **endptr, int base);
// void *memcpy(void *dest, const void *src, size_t n);
// int mbsinit(const mbstate_t *ps);
// int clock_gettime(clockid_t clock_id, struct timespec *tp);
// int tolower(int c);
// int fclose(FILE *stream);
// int getc_unlocked(FILE *stream);
// int __cdecl fseeko64(_DWORD); weak
// __sighandler_t signal(int sig, __sighandler_t handler);
// int memcmp(const void *s1, const void *s2, size_t n);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// time_t mktime(struct tm *tp);
// struct tm *localtime_r(const time_t *timer, struct tm *tp);
// int sigismember(const sigset_t *set, int signo);
// int fflush_unlocked(FILE *stream);
// char *textdomain(const char *domainname);
// ssize_t readlink(const char *path, char *buf, size_t len);
// int fnmatch(const char *pattern, const char *name, int flags);
// int iswprint(wint_t wc);
// int ioctl(int fd, unsigned int request, ...);
// int ferror_unlocked(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD); weak
// void tzset(void);
// size_t __ctype_get_mb_cur_max(void);
// char *strcpy(char *dest, const char *src);
// size_t __fpending(FILE *fp);
// size_t wcstombs(char *s, const wchar_t *pwcs, size_t n);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int gethostname(char *name, size_t len);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// void error(int status, int errnum, const char *format, ...);
// int strcoll(const char *s1, const char *s2);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// time_t timegm(struct tm *tp);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// size_t strftime(char *s, size_t maxsize, const char *format, const struct tm *tp);
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// char *strchr(const char *s, int c);
// char *getcwd(char *buf, size_t size);
// int fscanf(FILE *stream, const char *format, ...);
// size_t strlen(const char *s);
// int setenv(const char *name, const char *value, int replace);
// int fprintf(FILE *stream, const char *format, ...);
// int sigaddset(sigset_t *set, int signo);
// void *memset(void *s, int c, size_t n);
// int ungetc(int c, FILE *stream);
// int *__errno_location(void);
// __pid_t tcgetpgrp(int fd);
// int fileno(FILE *stream);
// unsigned int gnu_dev_major(unsigned __int64 dev);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// int __cdecl mempcpy(_DWORD, _DWORD, _DWORD); weak
// int __cdecl wcswidth(_DWORD, _DWORD); weak
// int sigemptyset(sigset_t *set);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// int toupper(int c);
// char *strrchr(const char *s, int c);
// size_t mbstowcs(wchar_t *pwcs, const char *s, size_t n);
// struct tm *gmtime_r(const time_t *timer, struct tm *tp);
// unsigned int gnu_dev_minor(unsigned __int64 dev);
// int sprintf(char *s, const char *format, ...);
// struct lconv *localeconv(void);
// int __cdecl lseek64(_DWORD); weak
// int __cdecl readdir64(_DWORD); weak
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// char *bindtextdomain(const char *domainname, const char *dirname);
// int strncmp(const char *s1, const char *s2, size_t n);
// int isatty(int fd);
// void abort(void);
// int __cdecl __xstat64(_DWORD, _DWORD, _DWORD); weak
// int __cdecl __lxstat64(_DWORD, _DWORD, _DWORD); weak
// int close(int fd);
// int closedir(DIR *dirp);
// DIR *opendir(const char *name);
// struct group *getgrgid(__gid_t gid);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// void *calloc(size_t nmemb, size_t size);
// int putchar_unlocked(int c);
// int _gmon_start__(void); weak
void sub_8049BE3();
void sub_8049C00();
int sub_8049C10();
int sub_8049C80();
int sub_8049CA0();
void sub_8049CFF();
void sub_8049D1A();
signed int sub_8049D2A();
void sub_8049E0C();
void sub_8049E27();
int sub_8049E37();
void sub_8049F19();
void sub_8049F34();
int sub_8049F44();
void sub_804A042();
void sub_804A05D();
int sub_804A06D();
// int __usercall sub_804A11F@<eax>(void (__cdecl *a1)(int *)@<eax>);
void sub_804A16B();
void sub_804A186();
int sub_804A196();
void sub_804A294();
void sub_804A2AF();
int sub_804A2BF();
void sub_804A3A1();
void sub_804A3BC();
int sub_804A3CC();
void sub_804A4CA();
void sub_804A4E5();
int __fastcall sub_804A4F5(int a1, int a2);
int nullsub_3(void); // weak
int sub_804A56C();
void sub_804A60C();
void sub_804A627();
int sub_804A637();
void sub_804A719();
void sub_804A734();
int sub_804A744();
int sub_804A7CE();
void sub_804A864();
void sub_804A87F();
int sub_804A893();
void sub_804A99E();
void sub_804A9DB();
int sub_804A9EF();
int sub_804AA79();
int __cdecl sub_804AABF(int a1);
int __cdecl sub_804AAE2(unsigned __int8 a1);
int __cdecl sub_804AAF4(_BYTE *a1);
int sub_804AB85();
int sub_804ABB4();
int __cdecl sub_804ABE3(char *s1); // idb
int __cdecl sub_804AD7D(int a1);
int __cdecl sub_804AD9C(int a1);
bool __cdecl sub_804ADD2(int a1);
int sub_804ADE2();
int __cdecl sub_804ADEC(int a1, int a2, int a3, int a4);
_DWORD *__stdcall sub_804AED3(_DWORD *a1);
unsigned int __cdecl sub_804AF86(int a1, int a2);
_BYTE *__cdecl sub_804B0D5(_BYTE *a1);
int sub_804B131();
signed int sub_804B1C4();
_DWORD sub_804B2BE(); // weak
int __cdecl sub_804B521(unsigned __int64 *a1, unsigned int a2);
int __cdecl sub_804B568(_QWORD *a1, _QWORD *a2);
void __cdecl sub_804B61A(void *ptr);
void __cdecl __noreturn sub_804B64F(int a1, int a2, int a3, int a4);
void __cdecl sub_804B702(void *ptr);
// int __usercall sub_804B752@<eax>(int a1@<edx>, int a2@<ecx>, int a3);
int sub_804B7F3(void); // weak
size_t __fastcall sub_804B835(int a1, int a2);
int __cdecl sub_804B87C(int a1);
int sub_804B892();
int sub_804B8CF();
__sighandler_t __cdecl sub_804B9C8(void (*a1)(int));
__sighandler_t sub_804BB73();
__sighandler_t sub_804BB95();
int __cdecl main(int, char **, char **); // idb
signed int __cdecl sub_804C350(char *nptr);
int __cdecl sub_804C3D8(int argc, char **argv); // idb
_DWORD __cdecl sub_804D6B3(_DWORD, _DWORD, char); // weak
_DWORD sub_804DA67(); // weak
int sub_804DB4B(void); // weak
// void __usercall sub_804DFCB(int a1@<ebx>);
int __cdecl sub_804E087(int a1);
int __cdecl sub_804E0CA(int a1, char *format);
int __cdecl sub_804E124(char *, char *s, int); // idb
// unsigned int __usercall sub_804E1CC@<eax>(unsigned __int8 *a1@<ebx>, char *a2, int a3, char a4);
_DWORD *__cdecl sub_804E96B(int a1);
int __cdecl sub_804E9AE(int, char *name); // idb
int __cdecl sub_804EA01(char *name); // idb
__int64 __cdecl sub_804EAD1(__int64 a1);
int sub_804EAFB();
void __cdecl sub_804EB33(void **a1);
int sub_804EBBC(void); // weak
int __cdecl sub_804ECA7(int a1);
signed int __cdecl sub_804ED02(int a1, int a2, char a3);
_DWORD __cdecl sub_804EDD1(_DWORD, _DWORD); // weak
int __cdecl sub_804EEA7(int a1, int a2);
int __cdecl sub_804EF6E(char *s); // idb
_DWORD __cdecl sub_804F00A(_DWORD, _DWORD, __int64, _DWORD, _DWORD); // weak
int __cdecl sub_804FFDA(int a1);
int __cdecl sub_8050008(char *path, int, int); // idb
// int __usercall sub_8050075@<eax>(int a1@<edx>, int a2@<ecx>, int a3, char *s);
// int __usercall sub_805014E@<eax>(int a1@<edx>, int a2@<ecx>, unsigned __int8 *a3@<ebx>, int a4);
// int __usercall sub_8050173@<eax>(unsigned __int8 *a1@<ebx>, char *s, int a3);
void __cdecl __noreturn sub_8050349(char *s1, char *s2); // idb
int sub_8050415(); // weak
int __cdecl sub_8050420(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD));
int __cdecl sub_8050549(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD));
int __cdecl sub_80505D1(int *a1, int *a2, int (__fastcall *a3)(_DWORD));
int __cdecl sub_805066A(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD));
int __cdecl sub_8050698(const char **a1, const char **a2, int (__stdcall *a3)(char *, char *, int, int, int, char *, char *, int, int, int));
int __cdecl sub_8050E59(int *a1, int *a2);
int __cdecl sub_8050E7B(int *a1, int *a2);
int __cdecl sub_8050E9D(int *a1, int *a2);
int __cdecl sub_8050EBF(int *a1, int *a2);
int __cdecl sub_8050EE1(int *a1, int *a2);
int __cdecl sub_8051004(int *a1, int *a2);
int __cdecl sub_8051072(int *a1, int *a2);
int __cdecl sub_80510F9(_DWORD *a1, _DWORD *a2);
int __cdecl sub_805111B(_DWORD *a1, _DWORD *a2);
int __cdecl sub_805113D(_DWORD *a1, _DWORD *a2);
int __cdecl sub_805115F(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8051181(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80511EF(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80512E0(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8051363(const char **a1, const char **a2);
int __cdecl sub_8051399(const char **a1, const char **a2);
int __cdecl sub_80513BB(const char **a1, const char **a2);
int __cdecl sub_80513DD(const char **a1, const char **a2);
int __cdecl sub_80513FF(const char **a1, const char **a2);
int __cdecl sub_805146D(const char **a1, const char **a2);
int __cdecl sub_80514DB(const char **a1, const char **a2);
int __cdecl sub_8051549(const char **a1, const char **a2);
int __cdecl sub_80515B7(char **a1, char **a2);
int __cdecl sub_80515D5(char **a1, char **a2);
int __cdecl sub_80515EF(char **a1, char **a2);
int sub_8051707();
int sub_8051781(void); // weak
int __fastcall sub_8051903(int a1, int a2);
_DWORD __cdecl sub_8051A18(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int sub_8051AC5();
int __cdecl sub_8051BB1(char *s, int, int); // idb
int __cdecl sub_8051CC5(__uid_t uid, int, int); // idb
int __cdecl sub_8051D36(__gid_t gid, int, int); // idb
_DWORD __cdecl sub_8051D89(_DWORD); // weak
void __cdecl __noreturn sub_8051DB3(char *format, int); // idb
int __cdecl sub_8051E53(__uid_t uid); // idb
int __cdecl sub_8051E8B(__gid_t gid); // idb
const char *__cdecl sub_8051ECF(int a1, unsigned int a2, int a3);
_DWORD __cdecl sub_8051F42(_DWORD); // weak
void __cdecl __noreturn sub_8052BB0(size_t, mbstate_t *p); // idb
_DWORD __cdecl sub_80530DD(_DWORD, _DWORD, _DWORD); // weak
void __cdecl __noreturn sub_8053147(mbstate_t *p, int, int, int); // idb
char *__cdecl sub_80531F3(char *s, int a2);
void __cdecl __noreturn sub_80532D6(int a1, int a2, int a3, int a4, char a5, int a6, int a7);
// void __usercall __noreturn sub_805379B(int a1@<edx>, int a2@<ecx>, int *a3, unsigned __int8 a4, int a5);
size_t sub_805390C();
_DWORD __cdecl sub_8053953(_DWORD); // weak
void __cdecl __noreturn sub_8053A2D(int, char *s, int, int, int, int, int); // idb
_DWORD __cdecl sub_8053BBA(_DWORD, _DWORD, _DWORD); // weak
bool __cdecl sub_8053D0F(unsigned __int8 a1, int a2, int a3);
// bool __usercall sub_8053D92@<al>(int a1@<edx>, int a2@<ecx>, int a3);
_DWORD __cdecl sub_8053DE3(_DWORD, _DWORD); // weak
size_t __cdecl sub_8054226(int a1);
int __cdecl sub_8054294(int a1);
unsigned int sub_80544DF();
int sub_805464B();
int __cdecl sub_80547D5(char a1);
unsigned int __cdecl sub_80548CF(unsigned int a1, unsigned int a2);
_DWORD __cdecl sub_8054974(_DWORD, _DWORD, _DWORD); // weak
unsigned int sub_8054A3B();
unsigned int __cdecl sub_8054C8F(char a1);
void __cdecl __noreturn sub_8054F0C(int status); // idb
int __cdecl sub_80552AD(char *path, int); // idb
void __noreturn sub_8055420();
// int __usercall sub_8055434@<eax>(int a1@<ebx>, char *s);
void __cdecl sub_805559F(int a1, int a2, int a3);
int __cdecl sub_8055637();
// int __usercall sub_8055799@<eax>(int a1@<ebx>, int a2, char *s, int a4, int a5, size_t n);
int __cdecl sub_80558B6(signed int a1);
_BOOL4 __cdecl sub_8055918(signed int a1);
_BOOL4 __cdecl sub_80559C7(int a1);
int __cdecl sub_8055B3A(int a1);
int __cdecl sub_8055B82(int, char *s, int); // idb
int __cdecl sub_8055C30(void *src, int); // idb
void __noreturn sub_805669A();
int sub_80567AA(); // weak
// unsigned __int8 *__usercall sub_80567B0@<eax>(int a1@<edx>, int a2@<ecx>, unsigned __int8 *a3@<ebx>, int a4);
// int __usercall sub_8056825@<eax>(int a1@<edx>, int a2@<ecx>, unsigned __int8 *a3@<ebx>, void *src);
// unsigned __int8 *__usercall sub_80568C9@<eax>(int a1@<edx>, int a2@<ecx>, unsigned __int8 *a3@<ebx>, int a4);
size_t __cdecl sub_805698D(char *s);
int sub_80569CF();
void __cdecl __noreturn sub_80569D9(int, char *s, int); // idb
_DWORD __cdecl sub_8056AA9(_DWORD, _DWORD, _DWORD); // weak
signed int __cdecl sub_8056B1D(__int16 a1);
int __cdecl sub_8056BE9(__int16 a1, _BYTE *a2);
int __cdecl sub_8056DC3(int a1, _BYTE *a2);
// int __usercall sub_8056DF0@<eax>(int a1@<edx>, int a2@<ecx>, unsigned __int8 *a3@<ebx>, int a4, _BYTE *a5);
_BYTE *__cdecl sub_8056E34(_BYTE *a1);
// int __usercall sub_8056E50@<eax>(int a1@<edx>, int a2@<ecx>, unsigned __int8 *a3@<ebx>, int a4, _BYTE *a5);
int __cdecl sub_80570AF(unsigned __int8 a1);
int __cdecl sub_8057350(char *s1, char *s2); // idb
struct timespec *__cdecl sub_80575CA(struct timespec *tp);
int __cdecl sub_8057619(int category); // idb
int __cdecl sub_80576B0(int a1);
int __cdecl sub_80576BB(int a1);
int __cdecl sub_80576CA(int a1);
int __cdecl sub_8057935(_DWORD *a1, int a2);
bool __cdecl sub_8057C59(unsigned int a1);
int __cdecl sub_8057CB4(unsigned int a1);
unsigned int __cdecl sub_8057D39(int a1, unsigned int a2);
bool __cdecl sub_8057D64(int a1, int a2);
signed int __cdecl sub_8057D72(int a1);
unsigned int __cdecl sub_8057E69(unsigned int a1, int a2);
_DWORD __cdecl sub_8057F1A(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
void __cdecl sub_805819B(void *a1);
void *__cdecl sub_805828B(int a1);
int __cdecl sub_80582DF(int a1, _DWORD *a2);
_DWORD __cdecl sub_8058312(_DWORD, _DWORD, _DWORD, _DWORD); // weak
signed int __cdecl sub_80584BC(int a1, int *a2, char a3);
signed int __cdecl sub_805866D(int a1, unsigned int a2);
void __fastcall __noreturn sub_805887F(int a1, int a2, int a3, int a4);
int __cdecl sub_80588A9(int, int, int); // weak
// void __usercall __noreturn sub_8058B7C(int a1@<edx>, int a2@<ecx>, int a3, int a4);
_DWORD __cdecl sub_8058BCB(_DWORD, _DWORD); // weak
int __cdecl sub_8058E15(int a1, unsigned int a2);
int __cdecl sub_8058F8C(int a1, int a2);
void __cdecl sub_805903C(void **a1);
long double __cdecl sub_8059066(int a1, long double a2);
void *__cdecl sub_80591B9(int a1, size_t n, int a3, int a4);
void *__cdecl sub_805930F(int a1, int a2, char *s, int a4, int a5, int a6, int a7, int a8);
__int64 sub_805A100();
int __cdecl sub_805A13E(char *s, int, int); // idb
int __cdecl sub_805A2BD(char *s, int, int); // idb
size_t __cdecl sub_805A318(__uid_t uid);
int __cdecl sub_805A54D(__gid_t gid); // idb
_DWORD __cdecl sub_805A7AF(_DWORD, _DWORD); // weak
int __cdecl sub_805A943(unsigned __int64 a1, int a2);
int __cdecl sub_805A9F1(int a1);
int __cdecl sub_805AA54(_DWORD *a1, unsigned int a2);
_BYTE *__cdecl sub_805AAC4(_BYTE *a1, unsigned int a2, int a3);
int __cdecl sub_805AAF9(char *s, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_805AF8D(char *s, int); // idb
_DWORD __cdecl sub_805AFD8(_DWORD, _DWORD, _DWORD); // weak
void *__cdecl sub_805B2E6(int a1, int a2, void *dest, int a4);
int __cdecl sub_805B495(int, int, void *dest, int); // idb
int __cdecl sub_805B74F(int a1, int a2, int a3);
_DWORD __cdecl sub_805B797(_DWORD, _DWORD, _DWORD); // weak
void sub_805B7F7();
int __cdecl sub_805B808(int a1, int a2, int a3);
int __cdecl sub_805B84C(int a1, int a2);
int __cdecl sub_805B8A9(int a1, int a2, int a3, int a4, int a5, int a6);
_DWORD __cdecl sub_805B928(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
char *__cdecl sub_805E5D8(char *s);
int __cdecl sub_805E6CA(void *src); // idb
int __cdecl sub_805E747(int *a1);
int *__cdecl sub_805E762(int *a1, int a2);
int __cdecl sub_805E780(int *a1, unsigned __int8 a2, char a3);
int *__cdecl sub_805E84A(int *a1, int a2, int a3);
// _DWORD *__userpurge sub_805E89B@<eax>(_DWORD *a1, int a2);
int __cdecl sub_805E93D(char *msgid, int); // idb
_DWORD __cdecl sub_805E9F4(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_805F844(int a1, int a2, int a3, int a4, int *a5);
void *__cdecl sub_805F91E(int a1, int a2, _DWORD *a3, int *a4);
int __cdecl sub_805FB33(signed int a1);
int __cdecl sub_805FDAE(signed int a1);
int __cdecl sub_805FDDC(signed int a1);
int __cdecl sub_805FE52(signed int a1, int a2);
int __cdecl sub_805FE94(signed int a1, int a2, int a3, int a4);
int __cdecl sub_805FED5(int a1);
_DWORD __cdecl sub_805FF54(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_8060045(int a1, char a2);
int __cdecl sub_806007E(int a1, int a2);
int __cdecl sub_8060104(signed int a1, int a2, int a3);
int sub_80601B9();
int __cdecl sub_8060207(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_806036B(signed int a1);
int __cdecl sub_80603C6(signed int a1);
int sub_806040C();
// int __usercall sub_8060437@<eax>(int a1@<edx>, int a2@<ecx>, unsigned __int8 *a3@<ebx>, void *src, void *a5);
void sub_8060670();
signed int sub_80606C1();
signed int sub_80606F7();
// _DWORD *__userpurge sub_8060851@<eax>(_DWORD *a1, int a2);
_DWORD __cdecl sub_806087C(_DWORD, _DWORD); // weak
// _DWORD *__userpurge sub_80608D2@<eax>(_DWORD *a1, int a2);
_DWORD __cdecl sub_806097D(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_8060A67(FILE *stream, int, int, int, int, int); // idb
int __cdecl sub_8061109(FILE *stream, int, int, int, int); // idb
int sub_8061194(FILE *stream, int a2, int a3, int a4, ...);
void *__cdecl sub_806126A(unsigned int a1, unsigned int a2);
void *__cdecl sub_80612AA(void *ptr, int a2, int a3);
// void *__usercall sub_80612DF@<eax>(int a1@<edx>, int a2@<ecx>, void *ptr, int a4);
void *__cdecl sub_80613C3(size_t size);
void *__cdecl sub_80613E6(size_t size);
void *__cdecl sub_8061414(void *ptr, size_t size);
// void *__usercall sub_8061467@<eax>(int a1@<edx>, int a2@<ecx>, void *ptr, int a4);
void *__cdecl sub_8061512(void *src, size_t n);
void *__cdecl sub_806153B(char *s);
void __noreturn sub_8061564();
int __cdecl sub_80615C1(char *nptr, int base, int, int, int, int, char *s, int, int status); // idb
char *sub_80617A0();
char *__fastcall sub_80617DD(int a1, int a2);
signed int __cdecl sub_80618B5(unsigned int *a1, unsigned int a2);
_DWORD sub_8061909(); // weak
int __cdecl sub_8061930(int a1, int a2, int a3, int a4);
int __cdecl sub_80619AF(char *nptr, int, int base, int, char *s); // idb
void __cdecl sub_8061E43(int a1, int a2, int a3, int a4, int a5, int status);
_DWORD __cdecl sub_8061F1B(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
signed int __cdecl sub_8061F83(signed int a1);
int __cdecl sub_8062037(signed int a1, int a2, int a3);
unsigned int __cdecl sub_8062071(char *nptr, int a2, int base, int a4, char *s);
int __cdecl sub_80624D2(wchar_t *pwc, char *s, size_t n, mbstate_t *p); // idb
int __cdecl sub_8062561(int a1, int a2);
int __cdecl sub_80625A3(int a1, int a2);
signed int __cdecl sub_80625F3(signed int *a1, signed int a2, signed int a3);
signed int __cdecl sub_806271D(int a1, signed int a2, signed int a3, int a4, int a5);
int __cdecl sub_80627CA(int a1, int a2);
int __cdecl sub_8062AF3(int a1, int a2);
_DWORD __cdecl sub_8062B2B(_DWORD, _DWORD); // weak
int __cdecl sub_8062BF6(void *dest, void *src, size_t n); // idb
int __cdecl sub_8062C3E(char *s); // idb
signed int __cdecl sub_8062D08(int a1, unsigned int a2);
int __cdecl sub_8062EBE(void *ptr); // idb
char *sub_8062F0E();
int __cdecl sub_8062F34(char *value); // idb
signed int __cdecl sub_8062F6F(int a1);
_DWORD __cdecl sub_8062FBC(_DWORD); // weak
int __cdecl sub_80630E0(void *ptr); // idb
int __cdecl sub_806314F(int, time_t *timer, struct tm *tp); // idb
int __cdecl sub_8063221(int, struct tm *tp); // idb
int __cdecl sub_8063463(int a1, char a2);
int __cdecl sub_806359E(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_8063607(FILE *fp); // idb
// int __usercall sub_80636BF@<eax>(int a1@<edx>, int a2@<ecx>, unsigned __int8 *a3@<ebx>, void *src);
int __cdecl sub_80636E3(_BYTE *a1, unsigned int a2);
int sub_806374D(void); // weak
int sub_8063CBA(void); // weak
int __cdecl sub_8063DBF(FILE *stream); // idb
int __cdecl sub_8063EA0(FILE *a1);
int __cdecl sub_8063F02(FILE *fp); // idb
int __cdecl sub_8063F46(FILE *stream, int a2, int a3);
signed __int64 __cdecl sub_806408E(__int64 a1, unsigned int a2, signed int a3);
int __cdecl sub_8064237(__int64 a1, __int64 a2);
int __cdecl sub_8064458(unsigned int a1, int a2, unsigned int a3, unsigned int a4);
int __cdecl sub_80645C1(unsigned __int64 a1, unsigned int a2, unsigned int a3);
int __cdecl sub_80647EC(int a1);
int __cdecl sub_806481F(int a1, int a2);
int __cdecl sub_8064852(int a1, int a2);
int __cdecl sub_8064885(int a1, int a2);
int __fastcall sub_80649CA(_DWORD, _DWORD); // weak
int __fastcall sub_8064A3C(_DWORD, _DWORD); // weak
int __cdecl sub_8064AB4();
int __stdcall sub_8064B22(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_8064BB5(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_8064C2F(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_8064CB8(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __fastcall sub_8064D28(_DWORD, _DWORD);
int sub_8064D9E(void); // weak
int (**sub_8064DB0())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN locret_804A504; // weak
_UNKNOWN loc_804AB75; // weak
_UNKNOWN loc_804B120; // weak
_UNKNOWN loc_804B1B5; // weak
_UNKNOWN loc_804B5EF; // weak
_UNKNOWN loc_804B60B; // weak
_UNKNOWN loc_804B610; // weak
_UNKNOWN loc_804B7A7; // weak
_UNKNOWN loc_804B7BD; // weak
_UNKNOWN loc_804B97C; // weak
_UNKNOWN loc_804E081; // weak
_UNKNOWN loc_804E2F5; // weak
_UNKNOWN loc_804E331; // weak
_UNKNOWN loc_804E4AC; // weak
_UNKNOWN loc_804E4FA; // weak
_UNKNOWN loc_804E6E4; // weak
_UNKNOWN loc_804E71B; // weak
_UNKNOWN loc_804E780; // weak
_UNKNOWN loc_804ECCC; // weak
_UNKNOWN loc_804ECE1; // weak
_UNKNOWN loc_804EF4F; // weak
_UNKNOWN loc_804EF63; // weak
_UNKNOWN loc_804EF67; // weak
_UNKNOWN loc_804EFE9; // weak
_UNKNOWN loc_804F000; // weak
_UNKNOWN loc_805009A; // weak
_UNKNOWN loc_80500A4; // weak
_UNKNOWN loc_80501B1; // weak
_UNKNOWN loc_80501CC; // weak
_UNKNOWN loc_80502BF; // weak
_UNKNOWN loc_80502CA; // weak
_UNKNOWN loc_8050396; // weak
_UNKNOWN locret_8050F62; // weak
_UNKNOWN loc_80510BE; // weak
_UNKNOWN loc_80510C5; // weak
_UNKNOWN locret_8051361; // weak
_UNKNOWN locret_8051A16; // weak
_UNKNOWN loc_80543C9; // weak
_UNKNOWN loc_805463D; // weak
_UNKNOWN loc_8054714; // weak
_UNKNOWN loc_805473E; // weak
_UNKNOWN loc_8054760; // weak
_UNKNOWN loc_80548B3; // weak
_UNKNOWN loc_8054B40; // weak
_UNKNOWN loc_8054B45; // weak
_UNKNOWN loc_8054C81; // weak
_UNKNOWN loc_8054EA1; // weak
_UNKNOWN loc_80554B3; // weak
_UNKNOWN loc_805554A; // weak
_UNKNOWN loc_805554E; // weak
_UNKNOWN loc_80555DB; // weak
_UNKNOWN loc_8055761; // weak
_UNKNOWN loc_80558DF; // weak
_UNKNOWN loc_80558F1; // weak
_UNKNOWN loc_8055912; // weak
_UNKNOWN loc_8055CFD; // weak
_UNKNOWN loc_8055D12; // weak
_UNKNOWN locret_8056674; // weak
_UNKNOWN loc_8056705; // weak
_UNKNOWN loc_8056740; // weak
_UNKNOWN loc_805679D; // weak
_UNKNOWN loc_80568F0; // weak
_UNKNOWN loc_80568F4; // weak
_UNKNOWN loc_8056917; // weak
_UNKNOWN loc_8056970; // weak
_UNKNOWN loc_805697A; // weak
_UNKNOWN loc_8056CEC; // weak
_UNKNOWN loc_8056D04; // weak
_UNKNOWN loc_8056D6B; // weak
_UNKNOWN loc_8056F17; // weak
_UNKNOWN loc_8056F21; // weak
_UNKNOWN loc_80573F4; // weak
_UNKNOWN loc_80573FE; // weak
_UNKNOWN loc_8057DA3; // weak
_UNKNOWN loc_8057DAD; // weak
_UNKNOWN loc_80582DA; // weak
_UNKNOWN loc_8058704; // weak
_UNKNOWN loc_805870E; // weak
_UNKNOWN locret_805887D; // weak
_UNKNOWN loc_80588A4; // weak
_UNKNOWN loc_805925D; // weak
_UNKNOWN loc_8059781; // weak
_UNKNOWN loc_8059A64; // weak
_UNKNOWN loc_8059C34; // weak
_UNKNOWN loc_8059C3B; // weak
_UNKNOWN loc_8059DA0; // weak
_UNKNOWN loc_8059DA7; // weak
_UNKNOWN loc_8059DCC; // weak
_UNKNOWN loc_8059E78; // weak
_UNKNOWN loc_8059F04; // weak
_UNKNOWN loc_8059FFB; // weak
_UNKNOWN loc_805A069; // weak
_UNKNOWN loc_805A0A3; // weak
_UNKNOWN loc_805AC8D; // weak
_UNKNOWN loc_805ACAE; // weak
_UNKNOWN loc_805AD0C; // weak
_UNKNOWN loc_805ADAA; // weak
_UNKNOWN loc_805ADB1; // weak
_UNKNOWN loc_805B450; // weak
_UNKNOWN loc_805E64A; // weak
_UNKNOWN loc_805E6F9; // weak
_UNKNOWN loc_805E6FE; // weak
_UNKNOWN loc_805FA52; // weak
_UNKNOWN loc_805FA5D; // weak
_UNKNOWN loc_80604B3; // weak
_UNKNOWN loc_80604E0; // weak
_UNKNOWN loc_806132C; // weak
_UNKNOWN loc_8061366; // weak
_UNKNOWN loc_806194F; // weak
_UNKNOWN loc_80619AA; // weak
_UNKNOWN loc_806248A; // weak
_UNKNOWN locret_80624D0; // weak
_UNKNOWN loc_8062696; // weak
_UNKNOWN loc_806269D; // weak
_UNKNOWN locret_8062EBC; // weak
_UNKNOWN loc_806368F; // weak
_UNKNOWN loc_806369B; // weak
_UNKNOWN loc_8063ECD; // weak
_UNKNOWN locret_8063F00; // weak
_UNKNOWN loc_8063F91; // weak
_UNKNOWN loc_8064068; // weak
_UNKNOWN locret_8064088; // weak
_UNKNOWN loc_8064326; // weak
_UNKNOWN loc_8064331; // weak
_UNKNOWN loc_80644F3; // weak
_UNKNOWN loc_806470F; // weak
char s = '\0'; // idb
_UNKNOWN unk_80662B1; // weak
int sig[12] = { 20, 14, 1, 2, 13, 3, 15, 29, 27, 26, 24, 25 }; // idb
_UNKNOWN unk_8069630; // weak
_UNKNOWN unk_80696E1; // weak
_UNKNOWN unk_80696E3; // weak
_UNKNOWN unk_8069794; // weak
char *off_8069A68[10] =
{
  "literal",
  "shell",
  "shell-always",
  "shell-escape",
  "shell-escape-always",
  "c",
  "c-maybe",
  "escape",
  "locale",
  "clocale"
}; // weak
int dword_8069AA8[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; // idb
_UNKNOWN unk_806A5E8; // weak
_UNKNOWN unk_806B39C; // weak
_UNKNOWN unk_806B39F; // weak
_UNKNOWN unk_806D3A8; // weak
_UNKNOWN unk_806D3AB; // weak
_UNKNOWN unk_806E3E4; // weak
_UNKNOWN unk_806E3E7; // weak
int dword_806EEF0 = 403588628; // weak
_UNKNOWN unk_806F40C; // weak
_UNKNOWN unk_806F40F; // weak
int (*off_8070ED8[2])() = { &sub_8049CA0, &sub_8049C80 }; // weak
int (*off_8070EDC)() = &sub_8049C80; // weak
int (*dword_8071008)(void) = NULL; // weak
int dword_80711DC = 0; // weak
int dword_80711F0 = 0; // weak
int dword_8071204 = 0; // weak
int dword_8071218 = 0; // weak
int dword_8071240 = 0; // weak
int dword_8071254 = 0; // weak
int dword_8071268 = 0; // weak
int dword_807127C = 0; // weak
int dword_80712AC = 0; // weak
_UNKNOWN unk_80712C8; // weak
int dword_80712E8[] = { 2 }; // weak
void *s1 = &unk_80662AC; // idb
int dword_80712F0 = 1; // weak
_UNKNOWN unk_80712F8; // weak
int dword_80712FC = 0; // weak
_UNKNOWN unk_8071300; // weak
_UNKNOWN unk_8071308; // weak
char byte_80713B0 = '\x01'; // weak
int dword_80713B4 = 4294967295; // weak
int status = 1; // idb
int dword_8071408 = 1; // weak
int dword_807140C = 256; // weak
void *off_8071410 = &unk_80728BC; // weak
int *off_8071414 = &dword_807140C; // weak
_UNKNOWN unk_8071448; // weak
_UNKNOWN unk_807144B; // weak
_UNKNOWN unk_8071450; // weak
_UNKNOWN unk_8071453; // weak
_UNKNOWN unk_8071454; // weak
_UNKNOWN unk_8071457; // weak
_UNKNOWN unk_807145C; // weak
_UNKNOWN unk_807145F; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int program_invocation_name; // weak
FILE *stdout; // idb
int (*obstack_alloc_failed_handler)(void); // weak
char byte_80714AC; // weak
_UNKNOWN unk_807154A; // weak
char byte_80717AE; // weak
char byte_8071828; // weak
void *dword_807183C; // idb
void *dword_8071840; // idb
int dword_8071848; // weak
void *dword_8071850; // idb
int dword_8071860; // weak
char byte_807186C; // weak
int dword_8071870; // weak
int dword_8071874; // weak
int dword_807187C; // idb
int dword_8071898; // weak
int dword_80718A0; // weak
char byte_80718A6; // weak
char byte_80718A7; // weak
int dword_80718A8; // idb
int qword_80718AC; // idb
char byte_80718B8; // weak
int dword_80718BC; // weak
char byte_80718C0; // weak
char byte_80718C1; // weak
char byte_80718C2; // weak
char byte_80718CD; // weak
char byte_80718D4; // weak
int dword_80718DC; // idb
int dword_80718E8; // weak
int dword_80718EC; // weak
int dword_80718F0; // weak
char byte_80718F4; // weak
int dword_80718F8; // weak
int dword_80718FC; // idb
sigset_t set; // idb
int dword_807199C; // weak
int dword_80719A0; // weak
int dword_80719A4; // weak
void *dword_80719A8; // idb
int dword_80719AC; // idb
int dword_80719B0; // weak
_UNKNOWN unk_80719FC; // weak
_UNKNOWN unk_8071A3C; // weak
int dword_8071A48; // weak
char byte_8071A7C[3328]; // idb
struct __jmp_buf_tag env[1]; // idb
__int64 qword_807283C; // weak
__int64 qword_807284C; // weak
int dword_8072854; // weak
int dword_8072858; // weak
char byte_807285C; // weak
int dword_8072860; // weak
int dword_8072868; // weak
int dword_8072870; // weak
int dword_807287C; // weak
_UNKNOWN unk_80728BC; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (0804945C) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 8049BA0: using guessed type int _gmon_start__(void);

//----- (08049480) --------------------------------------------------------
int sub_8049480()
{
  return dword_8071008();
}
// 8071008: using guessed type int (*dword_8071008)(void);

//----- (08049BB0) --------------------------------------------------------
#error "8049BB3: positive sp value has been found (funcsize=2)"

//----- (08049BE3) --------------------------------------------------------
void sub_8049BE3()
{
  ;
}

//----- (08049C00) --------------------------------------------------------
void sub_8049C00()
{
  ;
}

//----- (08049C10) --------------------------------------------------------
int sub_8049C10()
{
  int result; // eax

  result = &unk_807145F - &unk_807145C;
  if ( (unsigned int)(&unk_807145F - &unk_807145C) > 6 )
    result = 0;
  return result;
}
// 8049C10: could not find valid save-restore pair for ebp

//----- (08049C80) --------------------------------------------------------
int sub_8049C80()
{
  int result; // eax

  if ( !byte_80714AC )
  {
    result = sub_8049C10();
    byte_80714AC = 1;
  }
  return result;
}
// 8049C80: could not find valid save-restore pair for ebp
// 80714AC: using guessed type char byte_80714AC;

//----- (08049CA0) --------------------------------------------------------
int sub_8049CA0()
{
  return 0;
}
// 8049CA0: could not find valid save-restore pair for ebp

//----- (08049CFF) --------------------------------------------------------
void sub_8049CFF()
{
  ;
}

//----- (08049D1A) --------------------------------------------------------
void sub_8049D1A()
{
  ;
}

//----- (08049D2A) --------------------------------------------------------
signed int sub_8049D2A()
{
  return 3;
}
// 8049D2A: could not find valid save-restore pair for ebp

//----- (08049E0C) --------------------------------------------------------
void sub_8049E0C()
{
  ;
}

//----- (08049E27) --------------------------------------------------------
void sub_8049E27()
{
  ;
}

//----- (08049E37) --------------------------------------------------------
int sub_8049E37()
{
  int result; // eax

  result = &unk_807144B - &unk_8071448;
  if ( (unsigned int)(&unk_807144B - &unk_8071448) > 6 )
    result = 0;
  return result;
}
// 8049E37: could not find valid save-restore pair for ebp

//----- (08049F19) --------------------------------------------------------
void sub_8049F19()
{
  ;
}

//----- (08049F34) --------------------------------------------------------
void sub_8049F34()
{
  ;
}

//----- (08049F44) --------------------------------------------------------
int sub_8049F44()
{
  int result; // eax

  result = &unk_807154A - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_807154A - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 8049F44: could not find valid save-restore pair for ebp
// 8071460: using guessed type int program_invocation_short_name;

//----- (0804A042) --------------------------------------------------------
void sub_804A042()
{
  ;
}

//----- (0804A05D) --------------------------------------------------------
void sub_804A05D()
{
  ;
}

//----- (0804A06D) --------------------------------------------------------
int sub_804A06D()
{
  int result; // eax

  result = &unk_806F40F - &unk_806F40C;
  if ( (unsigned int)(&unk_806F40F - &unk_806F40C) > 6 )
    result = 0;
  return result;
}
// 804A06D: could not find valid save-restore pair for ebp

//----- (0804A11F) --------------------------------------------------------
int __usercall sub_804A11F@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  a1(&dword_806EEF0);
  return 0;
}
// 806EEF0: using guessed type int dword_806EEF0;

//----- (0804A16B) --------------------------------------------------------
void sub_804A16B()
{
  ;
}

//----- (0804A186) --------------------------------------------------------
void sub_804A186()
{
  ;
}

//----- (0804A196) --------------------------------------------------------
int sub_804A196()
{
  int result; // eax

  result = &unk_807144B - &unk_8071448;
  if ( (unsigned int)(&unk_807144B - &unk_8071448) > 6 )
    result = 0;
  return result;
}
// 804A196: could not find valid save-restore pair for ebp

//----- (0804A294) --------------------------------------------------------
void sub_804A294()
{
  ;
}

//----- (0804A2AF) --------------------------------------------------------
void sub_804A2AF()
{
  ;
}

//----- (0804A2BF) --------------------------------------------------------
int sub_804A2BF()
{
  int result; // eax

  result = &unk_806E3E7 - &unk_806E3E4;
  if ( (unsigned int)(&unk_806E3E7 - &unk_806E3E4) > 6 )
    result = 0;
  return result;
}
// 804A2BF: could not find valid save-restore pair for ebp

//----- (0804A3A1) --------------------------------------------------------
void sub_804A3A1()
{
  ;
}

//----- (0804A3BC) --------------------------------------------------------
void sub_804A3BC()
{
  ;
}

//----- (0804A3CC) --------------------------------------------------------
int sub_804A3CC()
{
  int result; // eax

  result = &unk_807144B - &unk_8071448;
  if ( (unsigned int)(&unk_807144B - &unk_8071448) > 6 )
    result = 0;
  return result;
}
// 804A3CC: could not find valid save-restore pair for ebp

//----- (0804A4CA) --------------------------------------------------------
void sub_804A4CA()
{
  ;
}

//----- (0804A4E5) --------------------------------------------------------
void sub_804A4E5()
{
  ;
}

//----- (0804A4F5) --------------------------------------------------------
int __fastcall sub_804A4F5(int a1, int a2)
{
  int result; // eax
  int (__stdcall *v3)(void *, int, int, int, int, int); // eax
  int v4; // [esp+4h] [ebp-18h]
  int v5; // [esp+8h] [ebp-14h]
  int v6; // [esp+Ch] [ebp-10h]
  int v7; // [esp+10h] [ebp-Ch]
  int v8; // [esp+14h] [ebp-8h]
  int v9; // [esp+18h] [ebp-4h]

  result = &unk_807144B - &unk_8071448;
  if ( (unsigned int)(&unk_807144B - &unk_8071448) > 6 )
  {
    v9 = 0;
    dword_80711F0 = (int)&locret_804A504;
    v3 = (int (__stdcall *)(void *, int, int, int, int, int))sub_8064D28(a1, a2);
    result = v3(&unk_8071448, v4, v5, v6, v7, v8);
  }
  return result;
}
// 80711F0: using guessed type int dword_80711F0;

//----- (0804A56C) --------------------------------------------------------
int sub_804A56C()
{
  return nullsub_3();
}
// 804A56C: could not find valid save-restore pair for ebp
// 804A56B: using guessed type int nullsub_3(void);

//----- (0804A60C) --------------------------------------------------------
void sub_804A60C()
{
  ;
}

//----- (0804A627) --------------------------------------------------------
void sub_804A627()
{
  ;
}

//----- (0804A637) --------------------------------------------------------
int sub_804A637()
{
  int result; // eax

  result = &unk_806D3AB - &unk_806D3A8;
  if ( (unsigned int)(&unk_806D3AB - &unk_806D3A8) > 6 )
    result = 0;
  return result;
}
// 804A637: could not find valid save-restore pair for ebp

//----- (0804A719) --------------------------------------------------------
void sub_804A719()
{
  ;
}

//----- (0804A734) --------------------------------------------------------
void sub_804A734()
{
  ;
}

//----- (0804A744) --------------------------------------------------------
int sub_804A744()
{
  int result; // eax

  result = &unk_806B39F - &unk_806B39C;
  if ( (unsigned int)(&unk_806B39F - &unk_806B39C) > 6 )
    result = 0;
  return result;
}
// 804A744: could not find valid save-restore pair for ebp

//----- (0804A7CE) --------------------------------------------------------
int sub_804A7CE()
{
  int result; // eax

  result = sub_804A744();
  byte_80717AE = 1;
  return result;
}
// 80717AE: using guessed type char byte_80717AE;

//----- (0804A864) --------------------------------------------------------
void sub_804A864()
{
  ;
}

//----- (0804A87F) --------------------------------------------------------
void sub_804A87F()
{
  ;
}

//----- (0804A893) --------------------------------------------------------
int sub_804A893()
{
  int result; // eax

  result = &unk_8071453 - &unk_8071450;
  if ( (unsigned int)(&unk_8071453 - &unk_8071450) > 6 )
    result = 0;
  return result;
}

//----- (0804A99E) --------------------------------------------------------
void sub_804A99E()
{
  ;
}

//----- (0804A9DB) --------------------------------------------------------
void sub_804A9DB()
{
  ;
}

//----- (0804A9EF) --------------------------------------------------------
int sub_804A9EF()
{
  int result; // eax

  result = &unk_8071457 - &unk_8071454;
  if ( (unsigned int)(&unk_8071457 - &unk_8071454) > 6 )
    result = 0;
  return result;
}
// 804A9EF: could not find valid save-restore pair for ebp

//----- (0804AA79) --------------------------------------------------------
int sub_804AA79()
{
  int result; // eax

  result = sub_804A9EF();
  byte_8071828 = 1;
  return result;
}
// 8071828: using guessed type char byte_8071828;

//----- (0804AABF) --------------------------------------------------------
int __cdecl sub_804AABF(int a1)
{
  int result; // eax

  if ( a1 != 1 )
  {
    result = a1;
    status = a1;
  }
  return result;
}

//----- (0804AAE2) --------------------------------------------------------
int __cdecl sub_804AAE2(unsigned __int8 a1)
{
  return a1;
}

//----- (0804AAF4) --------------------------------------------------------
int __cdecl sub_804AAF4(_BYTE *a1)
{
  signed int v1; // eax
  char v3; // [esp-1h] [ebp-5h]

  if ( *a1 != 46 )
    return 0;
  if ( a1[1] == 46 )
    v1 = 2;
  else
    v1 = 1;
  v3 = a1[v1];
  if ( !v3 || v3 == 47 )
  {
    dword_8071254 = (int)&loc_804AB75;
    sub_8064AB4();
  }
  return 0;
}
// 8071254: using guessed type int dword_8071254;

//----- (0804AB85) --------------------------------------------------------
int sub_804AB85()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nMandatory arguments to long options are mandatory for short options too.\n");
  return fputs_unlocked(v1, v0);
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804ABB4) --------------------------------------------------------
int sub_804ABB4()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext(
         "\n"
         "The SIZE argument is an integer and optional unit (example: 10K is 10*1024).\n"
         "Units are K,M,G,T,P,E,Z,Y (powers of 1024) or KB,MB,... (powers of 1000).\n");
  return fputs_unlocked(v1, v0);
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804ABE3) --------------------------------------------------------
int __cdecl sub_804ABE3(char *s1)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // ebx
  char *v5; // eax
  int v7; // [esp+0h] [ebp-68h]
  char *v8; // [esp+4h] [ebp-64h]
  char *v9; // [esp+8h] [ebp-60h]
  char *v10; // [esp+1Ch] [ebp-4Ch]
  char **i; // [esp+20h] [ebp-48h]
  char *v12; // [esp+24h] [ebp-44h]
  const char *v13; // [esp+28h] [ebp-40h]
  const char *v14; // [esp+2Ch] [ebp-3Ch]
  const char *v15; // [esp+30h] [ebp-38h]
  const char *v16; // [esp+34h] [ebp-34h]
  const char *v17; // [esp+38h] [ebp-30h]
  const char *v18; // [esp+3Ch] [ebp-2Ch]
  const char *v19; // [esp+40h] [ebp-28h]
  const char *v20; // [esp+44h] [ebp-24h]
  const char *v21; // [esp+48h] [ebp-20h]
  const char *v22; // [esp+4Ch] [ebp-1Ch]
  const char *v23; // [esp+50h] [ebp-18h]
  const char *v24; // [esp+54h] [ebp-14h]
  int v25; // [esp+58h] [ebp-10h]
  int v26; // [esp+5Ch] [ebp-Ch]

  v13 = "[";
  v14 = "test invocation";
  v15 = "coreutils";
  v16 = "Multi-call invocation";
  v17 = "sha224sum";
  v18 = "sha2 utilities";
  v19 = "sha256sum";
  v20 = "sha2 utilities";
  v21 = "sha384sum";
  v22 = "sha2 utilities";
  v23 = "sha512sum";
  v24 = "sha2 utilities";
  v25 = 0;
  v26 = 0;
  v10 = s1;
  for ( i = (char **)(&v7 - 16); *i; i += 2 )
  {
    v8 = *i;
    if ( !strcmp(s1, v8) )
      break;
  }
  if ( i[1] )
    v10 = i[1];
  v1 = gettext("\n%s online help: <%s>\n");
  v9 = "http://www.gnu.org/software/coreutils/";
  v8 = "GNU coreutils";
  printf(v1, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  v12 = setlocale(5, 0);
  if ( v12 && strncmp(v12, "en_", 3u) )
  {
    v2 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
    v8 = s1;
    printf(v2, s1);
  }
  v3 = gettext("Full documentation at: <%s%s>\n");
  v9 = s1;
  v8 = "http://www.gnu.org/software/coreutils/";
  printf(v3, "http://www.gnu.org/software/coreutils/", s1);
  if ( v10 == s1 )
    v4 = " invocation";
  else
    v4 = &s;
  v5 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  v9 = v4;
  v8 = v10;
  return printf(v5, v10, v4);
}

//----- (0804AD7D) --------------------------------------------------------
int __cdecl sub_804AD7D(int a1)
{
  return sub_805A7AF(a1, a1 >> 31);
}
// 805A7AF: using guessed type _DWORD __cdecl sub_805A7AF(_DWORD, _DWORD);

//----- (0804AD9C) --------------------------------------------------------
int __cdecl sub_804AD9C(int a1)
{
  return a1;
}

//----- (0804ADD2) --------------------------------------------------------
bool __cdecl sub_804ADD2(int a1)
{
  return a1 == 95;
}

//----- (0804ADE2) --------------------------------------------------------
int sub_804ADE2()
{
  return 0;
}

//----- (0804ADEC) --------------------------------------------------------
int __cdecl sub_804ADEC(int a1, int a2, int a3, int a4)
{
  _DWORD *v4; // ST3C_4
  int v5; // ecx
  int result; // eax

  if ( (unsigned int)(*((_DWORD *)&unk_8071A3C + 4) - *((_DWORD *)&unk_8071A3C + 3)) < 0x10 )
    sub_80627CA((int)&unk_8071A3C, 16);
  *((_DWORD *)&unk_8071A3C + 3) += 16;
  v4 = (_DWORD *)(dword_8071A48 - 16);
  v5 = dword_8071A48 - 16;
  *(_DWORD *)(v5 + 8) = a1;
  *(_DWORD *)(v5 + 12) = a2;
  result = a3;
  *v4 = a3;
  v4[1] = a4;
  return result;
}
// 8071A48: using guessed type int dword_8071A48;

//----- (0804AED3) --------------------------------------------------------
_DWORD *__stdcall sub_804AED3(_DWORD *a1)
{
  _DWORD *v1; // edx

  if ( (unsigned int)(*((_DWORD *)&unk_8071A3C + 3) - *((_DWORD *)&unk_8071A3C + 2)) < 0x10 )
    __assert_fail("dev_ino_size <= obstack_object_size (&dev_ino_obstack)", "src/ls.c", 0x402u, "dev_ino_pop");
  dword_8071A48 -= 16;
  v1 = (_DWORD *)dword_8071A48;
  *a1 = *(_DWORD *)dword_8071A48;
  a1[1] = v1[1];
  a1[2] = v1[2];
  a1[3] = v1[3];
  return a1;
}
// 8071A48: using guessed type int dword_8071A48;

//----- (0804AF86) --------------------------------------------------------
unsigned int __cdecl sub_804AF86(int a1, int a2)
{
  unsigned int result; // eax
  int v3; // [esp+4h] [ebp-34h]
  unsigned int i; // [esp+18h] [ebp-20h]
  int v5; // [esp+1Ch] [ebp-1Ch]
  unsigned int v6; // [esp+20h] [ebp-18h]
  int v7; // [esp+24h] [ebp-14h]
  int v8; // [esp+28h] [ebp-10h]
  int v9; // [esp+2Ch] [ebp-Ch]

  v5 = a2;
  result = (unsigned int)(*(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 8)) >> 2;
  v6 = (unsigned int)(*(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 8)) >> 2;
  if ( v6 )
  {
    v7 = a2;
    v8 = *(_DWORD *)(a2 + 8);
    if ( *(_DWORD *)(a2 + 12) == v8 )
      *(_BYTE *)(v7 + 40) |= 2u;
    *(_DWORD *)(v7 + 12) = (*(_DWORD *)(v7 + 24) + *(_DWORD *)(v7 + 12)) & ~*(_DWORD *)(v7 + 24);
    if ( *(_DWORD *)(v7 + 12) - *(_DWORD *)(v7 + 4) > (unsigned int)(*(_DWORD *)(v7 + 16) - *(_DWORD *)(v7 + 4)) )
      *(_DWORD *)(v7 + 12) = *(_DWORD *)(v7 + 16);
    *(_DWORD *)(v7 + 8) = *(_DWORD *)(v7 + 12);
    v9 = v8;
    fputs_unlocked(a1, stdout);
    for ( i = 0; i < v6; ++i )
    {
      v3 = *(_DWORD *)(4 * i + v9);
      printf(" %lu", v3);
    }
    result = putchar_unlocked(10);
  }
  return result;
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804B0D5) --------------------------------------------------------
#error "804B0E6: call analysis failed (funcsize=33)"

//----- (0804B131) --------------------------------------------------------
#error "804B14D: call analysis failed (funcsize=49)"

//----- (0804B1C4) --------------------------------------------------------
signed int sub_804B1C4()
{
  char **v0; // ebp
  int v2; // edx
  unsigned int v3; // eax
  char *v4; // [esp+0h] [ebp-48h]
  int v5; // [esp+4h] [ebp-44h]
  int v6; // [esp+8h] [ebp-40h]
  int *v7; // [esp+Ch] [ebp-3Ch]
  int v8; // [esp+10h] [ebp-38h]
  int v9; // [esp+14h] [ebp-34h]
  int v10; // [esp+2Ch] [ebp-1Ch]
  int savedregs; // [esp+48h] [ebp+0h]

  v0 = (char **)&savedregs;
  v10 = 5;
  do
  {
    *(v0 - 5) = *(v0 - 7);
    *(v0 - 7) = 0;
    *(v0 - 6) = 0;
    while ( (signed int)*(v0 - 6) <= 11 )
    {
      *(v0 - 8) = *(v0 - 5);
      v4 = *(v0 - 6) + 131086;
      *(v0 - 4) = nl_langinfo((nl_item)v4);
      v5 = 37;
      v4 = *(v0 - 4);
      if ( strchr(v4, 37) )
        return 0;
      v2 = (int)&v0[2][128 * (_DWORD)*(v0 - 6)];
      v9 = 0;
      v8 = 0;
      v0 = &v4;
      v7 = (int *)(&v4 - 8);
      v6 = 128;
      v5 = v2;
      v4 = *(&v4 - 4);
      *(&v4 - 3) = (char *)sub_805AAF9(v4, v2, 128, (int)(&v4 - 8), 0, 0);
      if ( (unsigned int)*(&v4 - 3) > 0x7F )
        return 0;
      v3 = (unsigned int)*(&v4 - 7);
      if ( (unsigned int)*(&v4 - 8) >= v3 )
        v3 = (unsigned int)*(&v4 - 8);
      *(&v4 - 7) = (char *)v3;
      ++*(&v4 - 6);
    }
  }
  while ( *(v0 - 5) > *(v0 - 7) );
  return 1;
}

//----- (0804B2BE) --------------------------------------------------------
#error "804B3B4: call analysis failed (funcsize=75)"

//----- (0804B521) --------------------------------------------------------
int __cdecl sub_804B521(unsigned __int64 *a1, unsigned int a2)
{
  return sub_80645C1(*a1, a2, 0);
}

//----- (0804B568) --------------------------------------------------------
int __cdecl sub_804B568(_QWORD *a1, _QWORD *a2)
{
  void *v2; // eax

  if ( *a1 == *a2 )
  {
    v2 = &loc_804B5EF;
    if ( __PAIR__(*((_DWORD *)a1 + 2), *((_DWORD *)a2 + 3)) != __PAIR__(*((_DWORD *)a2 + 2), *((_DWORD *)a1 + 3)) )
      v2 = &loc_804B60B;
    dword_8071254 = (int)v2;
    sub_8064AB4();
    dword_8071254 = (int)&loc_804B610;
    sub_8064AB4();
  }
  return 0;
}
// 8071254: using guessed type int dword_8071254;

//----- (0804B61A) --------------------------------------------------------
void __cdecl sub_804B61A(void *ptr)
{
  free(ptr);
}

//----- (0804B64F) --------------------------------------------------------
void __cdecl __noreturn sub_804B64F(int a1, int a2, int a3, int a4)
{
  _DWORD *v4; // [esp+28h] [ebp-10h]

  v4 = sub_80613E6(0x10u);
  *v4 = a3;
  v4[1] = a4;
  v4[2] = a1;
  v4[3] = a2;
  sub_8058B7C((int)v4, (int)v4, (int)dword_807183C, (int)v4);
}

//----- (0804B702) --------------------------------------------------------
void __cdecl sub_804B702(void *ptr)
{
  free(*(void **)ptr);
  free(*((void **)ptr + 1));
  free(ptr);
}

//----- (0804B752) --------------------------------------------------------
int __usercall sub_804B752@<eax>(int a1@<edx>, int a2@<ecx>, int a3)
{
  void *v3; // eax
  char v4; // al
  int v6; // [esp+18h] [ebp-10h]
  char *s1; // [esp+1Ch] [ebp-Ch]

  v6 = dword_80712E8[2 * a3];
  s1 = (char *)*(&::s1 + 2 * a3);
  if ( !v6 )
    goto LABEL_12;
  v3 = &loc_804B7A7;
  if ( v6 != 1 )
    v3 = &loc_804B7BD;
  dword_807127C = (int)v3;
  sub_80649CA(a2, a1);
  if ( *s1 == unk_80662B1 || v6 == 2 && !strncmp(s1, "00", 2u) )
LABEL_12:
    v4 = 0;
  else
    v4 = 1;
  return v4 & 1;
}
// 80649CA: using guessed type int __fastcall sub_80649CA(_DWORD, _DWORD);
// 807127C: using guessed type int dword_807127C;
// 80712E8: using guessed type int dword_80712E8[];

//----- (0804B7F3) --------------------------------------------------------
#error "804B82E: call analysis failed (funcsize=21)"

//----- (0804B835) --------------------------------------------------------
size_t __fastcall sub_804B835(int a1, int a2)
{
  size_t result; // eax

  result = (unsigned __int8)byte_80718C0;
  if ( byte_80718C0 )
  {
    result = sub_804B752(a2, a1, 4);
    if ( (_BYTE)result )
    {
      sub_8054226((int)dword_80712E8);
      sub_8054226((int)&unk_8071308);
      result = sub_8054226((int)&dword_80712F0);
    }
  }
  return result;
}
// 80712E8: using guessed type int dword_80712E8[];
// 80712F0: using guessed type int dword_80712F0;
// 80718C0: using guessed type char byte_80718C0;

//----- (0804B87C) --------------------------------------------------------
int __cdecl sub_804B87C(int a1)
{
  int result; // eax

  result = dword_807199C;
  if ( !dword_807199C )
  {
    result = a1;
    dword_807199C = a1;
  }
  return result;
}
// 807199C: using guessed type int dword_807199C;

//----- (0804B892) --------------------------------------------------------
int sub_804B892()
{
  int result; // eax

  result = dword_807199C;
  if ( !dword_807199C )
    result = dword_80719A0++ + 1;
  return result;
}
// 807199C: using guessed type int dword_807199C;
// 80719A0: using guessed type int dword_80719A0;

//----- (0804B8CF) --------------------------------------------------------
int sub_804B8CF()
{
  int result; // eax
  int sig; // [esp+18h] [ebp-90h]
  int v2; // [esp+1Ch] [ebp-8Ch]
  sigset_t oset; // [esp+20h] [ebp-88h]

  while ( 1 )
  {
    if ( !dword_807199C )
    {
      result = dword_80719A0;
      if ( !dword_80719A0 )
        break;
    }
    if ( byte_80718C2 )
      sub_804B7F3();
    fflush_unlocked(stdout);
    sigprocmask(0, &set, &oset);
    sig = dword_807199C;
    v2 = dword_80719A0;
    if ( dword_80719A0 )
    {
      dword_80719A0 = v2 - 1;
      sig = 19;
      dword_8071254 = (int)&loc_804B97C;
      sub_8064AB4();
    }
    signal(sig, 0);
    raise(sig);
    sigprocmask(2, &oset, 0);
  }
  return result;
}
// 804B7F3: using guessed type int sub_804B7F3(void);
// 8071254: using guessed type int dword_8071254;
// 80718C2: using guessed type char byte_80718C2;
// 807199C: using guessed type int dword_807199C;
// 80719A0: using guessed type int dword_80719A0;

//----- (0804B9C8) --------------------------------------------------------
__sighandler_t __cdecl sub_804B9C8(void (*a1)(int))
{
  __sighandler_t result; // eax
  void *v2; // eax
  signed int i; // [esp+10h] [ebp-A8h]
  signed int j; // [esp+10h] [ebp-A8h]
  signed int k; // [esp+10h] [ebp-A8h]
  void *v6; // [esp+14h] [ebp-A4h]
  char v7; // [esp+18h] [ebp-A0h]
  int v8; // [esp+98h] [ebp-20h]

  result = a1;
  if ( (_BYTE)a1 )
  {
    sigemptyset(&set);
    for ( i = 0; i <= 11; ++i )
    {
      sigaction(sig[i], 0, (struct sigaction *)&v6);
      if ( v6 != (void *)1 )
        sigaddset(&set, sig[i]);
    }
    result = (__sighandler_t)32;
    qmemcpy(&v7, &set, 0x80u);
    v8 = 0x10000000;
    for ( j = 0; j <= 11; ++j )
    {
      result = (__sighandler_t)sigismember(&set, sig[j]);
      if ( result )
      {
        if ( sig[j] == 20 )
          v2 = sub_804B892;
        else
          v2 = sub_804B87C;
        v6 = v2;
        result = (__sighandler_t)sigaction(sig[j], (const struct sigaction *)&v6, 0);
      }
    }
  }
  else
  {
    for ( k = 0; k <= 11; ++k )
    {
      result = (__sighandler_t)sigismember(&set, sig[k]);
      if ( result )
        result = signal(sig[k], 0);
    }
  }
  return result;
}

//----- (0804BB73) --------------------------------------------------------
__sighandler_t sub_804BB73()
{
  return sub_804B9C8((void (*)(int))1);
}

//----- (0804BB95) --------------------------------------------------------
__sighandler_t sub_804BB95()
{
  return sub_804B9C8(0);
}

//----- (0804BBA9) --------------------------------------------------------
#error "804BBD3: call analysis failed (funcsize=16)"

//----- (0804BBD8) --------------------------------------------------------
#error "804BCF5: call analysis failed (funcsize=445)"

//----- (0804C350) --------------------------------------------------------
signed int __cdecl sub_804C350(char *nptr)
{
  unsigned int v1; // eax
  signed int v2; // eax
  signed int result; // eax
  signed int v4; // [esp+28h] [ebp-14h]
  int v5; // [esp+2Ch] [ebp-10h]

  v1 = sub_8062071(nptr, 0, 0, (int)&v4, &s);
  if ( v1 )
  {
    if ( v1 == 1 )
    {
      dword_80718F8 = -1;
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    v2 = v4;
    if ( v5 )
      v2 = -1;
    dword_80718F8 = v2;
    result = 1;
  }
  return result;
}
// 80718F8: using guessed type int dword_80718F8;

//----- (0804C3D8) --------------------------------------------------------
#error "804C426: call analysis failed (funcsize=1002)"

//----- (0804D6B3) --------------------------------------------------------
#error "804D91D: call analysis failed (funcsize=280)"

//----- (0804DA67) --------------------------------------------------------
#error "804DA96: call analysis failed (funcsize=66)"

//----- (0804DB4B) --------------------------------------------------------
#error "804DE97: call analysis failed (funcsize=276)"

//----- (0804DFCB) --------------------------------------------------------
void __usercall sub_804DFCB(int a1@<ebx>)
{
  int v1; // edx
  int v2; // ecx
  int v3; // ebx
  char *v4; // eax
  char *v5; // [esp+0h] [ebp-28h]
  char **v6; // [esp+4h] [ebp-24h]
  int *v7; // [esp+8h] [ebp-20h]
  int v8; // [esp+Ch] [ebp-1Ch]
  char *s; // [esp+18h] [ebp-10h]
  int v10; // [esp+1Ch] [ebp-Ch]

  s = getenv("QUOTING_STYLE");
  if ( s )
  {
    v8 = 4;
    v7 = dword_8069AA8;
    v6 = off_8069A68;
    v10 = sub_8055434(a1, s);
    if ( v10 >= 0 )
    {
      sub_805E762(0, dword_8069AA8[v10]);
      dword_807127C = (int)&loc_804E081;
      sub_80649CA(v2, v1);
    }
    v5 = s;
    v3 = sub_806040C();
    v4 = gettext("ignoring invalid value of environment variable QUOTING_STYLE: %s");
    v8 = v3;
    error(0, 0, v4, v3);
  }
}
// 80649CA: using guessed type int __fastcall sub_80649CA(_DWORD, _DWORD);
// 8069A68: using guessed type char *off_8069A68[10];
// 807127C: using guessed type int dword_807127C;

//----- (0804E087) --------------------------------------------------------
int __cdecl sub_804E087(int a1)
{
  int result; // eax

  result = a1;
  if ( (_BYTE)a1 )
  {
    dword_80719A4 = 2;
  }
  else
  {
    result = dword_80719A4;
    if ( !dword_80719A4 )
      dword_80719A4 = 1;
  }
  return result;
}
// 80719A4: using guessed type int dword_80719A4;

//----- (0804E0CA) --------------------------------------------------------
int __cdecl sub_804E0CA(int a1, char *format)
{
  int v2; // ebx
  int *v3; // eax

  v2 = sub_805FED5(4);
  v3 = __errno_location();
  error(0, *v3, format, v2);
  return sub_804E087((unsigned __int8)a1);
}

//----- (0804E124) --------------------------------------------------------
int __cdecl sub_804E124(char *a1, char *s, int a3)
{
  void *v3; // eax
  void *v4; // eax
  int result; // eax
  int v6; // [esp+0h] [ebp-28h]
  char *v7; // [esp+8h] [ebp-20h]
  char v8; // [esp+Ch] [ebp-1Ch]
  _DWORD *v9; // [esp+1Ch] [ebp-Ch]

  v8 = a3;
  v9 = sub_80613E6(0x10u);
  if ( s )
    v3 = sub_806153B(s);
  else
    v3 = 0;
  v9[1] = v3;
  if ( v7 )
    v4 = sub_806153B(v7);
  else
    v4 = 0;
  *(_DWORD *)*(&v6 - 3) = v4;
  *(_BYTE *)(*(&v6 - 3) + 8) = *((_BYTE *)&v6 - 28);
  *(_DWORD *)(*(&v6 - 3) + 12) = dword_8071860;
  result = *(&v6 - 3);
  dword_8071860 = *(&v6 - 3);
  return result;
}
// 8071860: using guessed type int dword_8071860;

//----- (0804E1CC) --------------------------------------------------------
unsigned int __usercall sub_804E1CC@<eax>(unsigned __int8 *a1@<ebx>, char *a2, int a3, char a4)
{
  char *v4; // eax
  int v5; // edx
  unsigned int v6; // eax
  bool v7; // zf
  void *v8; // eax
  char *v9; // eax
  int v10; // edx
  void *v11; // eax
  char *v12; // eax
  int v13; // edx
  int v14; // eax
  int v15; // edx
  int v16; // ecx
  __int64 v17; // rax
  int v18; // edx
  int v19; // ecx
  char *v20; // eax
  int v21; // edx
  char *v22; // eax
  int v23; // edx
  int v24; // edx
  int v25; // ecx
  int v26; // edx
  unsigned __int8 *v28; // [esp-8h] [ebp-350h]
  int v29; // [esp-4h] [ebp-34Ch]
  char *v30; // [esp+0h] [ebp-348h]
  __int64 v31; // [esp+4h] [ebp-344h]
  int v32; // [esp+Ch] [ebp-33Ch]
  int v33; // [esp+10h] [ebp-338h]
  int v34; // [esp+14h] [ebp-334h]
  __int64 v35; // [esp+18h] [ebp-330h]
  int v36; // [esp+20h] [ebp-328h]
  char v37; // [esp+24h] [ebp-324h]
  int v38; // [esp+28h] [ebp-320h]
  char *name; // [esp+2Ch] [ebp-31Ch]
  void *ptr; // [esp+30h] [ebp-318h]
  int v41; // [esp+34h] [ebp-314h]
  unsigned int v42; // [esp+33Ch] [ebp-Ch]

  name = a2;
  v38 = a3;
  v37 = a4;
  v42 = __readgsdword(0x14u);
  *(&v30 - 192) = 0;
  *(&v30 - 191) = 0;
  *__errno_location() = 0;
  v30 = *(&v30 - 199);
  *(&v30 - 196) = (char *)opendir(v30);
  if ( !*(&v30 - 196) )
  {
    v4 = gettext("cannot open directory %s");
    v5 = *((unsigned __int8 *)&v30 - 804);
    HIDWORD(v31) = *(&v30 - 199);
    sub_804E0CA(v5, v4);
    return __readgsdword(0x14u) ^ (unsigned int)*(&v30 - 3);
  }
  if ( dword_807183C )
  {
    v30 = *(&v30 - 196);
    *(&v30 - 195) = (char *)dirfd((DIR *)v30);
    if ( (signed int)*(&v30 - 195) < 0 )
    {
      LODWORD(v31) = &v30 - 190;
      v30 = *(&v30 - 199);
      v6 = (unsigned int)sub_806481F((int)v30, (int)(&v30 - 190)) >> 31;
    }
    else
    {
      LODWORD(v31) = &v30 - 190;
      v30 = *(&v30 - 195);
      v6 = (unsigned int)sub_8064852((int)v30, (int)(&v30 - 190)) >> 31;
    }
    v7 = (_BYTE)v6 == 0;
    v29 = v6;
    v28 = a1;
    v8 = &loc_804E2F5;
    if ( v7 )
      v8 = &loc_804E331;
    dword_8071240 = (int)v8;
    sub_8064B22(v30, v31, HIDWORD(v31), v32, v33, v34, v35, HIDWORD(v35), v36, *(_DWORD *)&v37, v38, name, ptr, v41);
    v9 = gettext("cannot determine device and inode of %s");
    v10 = *((unsigned __int8 *)&v30 - 804);
    HIDWORD(v31) = *(&v30 - 199);
    sub_804E0CA(v10, v9);
    closedir((DIR *)*(&v30 - 196));
    return __readgsdword(0x14u) ^ (unsigned int)*(&v30 - 3);
  }
  sub_804EBBC();
  if ( byte_80718D4 || byte_80718F4 )
  {
    if ( byte_80713B0 != 1 )
    {
      putchar_unlocked(10);
      ++dword_80719B0;
    }
    byte_80713B0 = 0;
    if ( byte_80718B8 )
    {
      fwrite_unlocked("  ", 1u, 2u, stdout);
      dword_80719B0 += 2;
    }
    *(&v30 - 198) = 0;
    v29 = (unsigned __int8)byte_80718C1;
    v28 = a1;
    v11 = &loc_804E4AC;
    if ( !byte_80718C1 )
      v11 = &loc_804E4FA;
    dword_8071218 = (int)v11;
    sub_8064C2F(v30, v31, HIDWORD(v31), v32, v33, v34, v35, HIDWORD(v35), v36, *(_DWORD *)&v37, v38);
    LODWORD(v31) = 2;
    v30 = *(&v30 - 199);
    *(&v30 - 198) = (char *)sub_8055C30(v30, 2);
    if ( !*(&v30 - 198) )
    {
      v12 = gettext("error canonicalizing %s");
      v13 = *((unsigned __int8 *)&v30 - 804);
      HIDWORD(v31) = *(&v30 - 199);
      sub_804E0CA(v13, v12);
    }
    if ( *(&v30 - 200) )
      v14 = (int)*(&v30 - 200);
    else
      v14 = (int)*(&v30 - 199);
    sub_80532D6(v14, dword_80718EC, -1, 0, 1, (int)&unk_80719FC, (int)*(&v30 - 198));
  }
  while ( 1 )
  {
    *__errno_location() = 0;
    v30 = *(&v30 - 196);
    *(&v30 - 194) = (char *)readdir64(v30);
    if ( *(&v30 - 194) )
    {
      v30 = *(&v30 - 194) + 19;
      if ( (unsigned __int8)sub_804EA01(v30) ^ 1 )
      {
        *(&v30 - 197) = 0;
        switch ( (*(&v30 - 194))[18] )
        {
          case 1:
            *(&v30 - 197) = (char *)1;
            break;
          case 2:
            *(&v30 - 197) = (char *)2;
            break;
          case 4:
            *(&v30 - 197) = (char *)3;
            break;
          case 6:
            *(&v30 - 197) = (char *)4;
            break;
          case 8:
            *(&v30 - 197) = (char *)5;
            break;
          case 0xA:
            *(&v30 - 197) = (char *)6;
            break;
          case 0xC:
            *(&v30 - 197) = (char *)7;
            break;
          case 0xE:
            *(&v30 - 197) = (char *)8;
            break;
          default:
            break;
        }
        v15 = (int)(*(&v30 - 194) + 19);
        v34 = (int)*(&v30 - 199);
        v33 = 0;
        *(__int64 *)((char *)&v31 + 4) = 0LL;
        v31 = (unsigned int)*(&v30 - 197);
        LODWORD(v17) = sub_804F00A(v15, v31, BYTE4(v31), 0, v34);
        *((_QWORD *)&v30 - 96) += v17;
        v29 = dword_8071898;
        v28 = a1;
        LODWORD(v17) = &loc_804E6E4;
        if ( dword_8071898 != 1 )
          LODWORD(v17) = &loc_804E71B;
        dword_8071268 = v17;
        a1 = v28;
        sub_8064A3C(v16, HIDWORD(v17));
        if ( dword_80718A0 == -1 && byte_80718A7 != 1 && byte_80718D4 != 1 )
        {
          sub_8051781();
          sub_8051903(v19, v18);
          sub_804EBBC();
        }
      }
      goto LABEL_46;
    }
    if ( !*__errno_location() )
      goto LABEL_45;
    v20 = gettext("reading directory %s");
    v21 = *((unsigned __int8 *)&v30 - 804);
    HIDWORD(v31) = *(&v30 - 199);
    sub_804E0CA(v21, v20);
    if ( *__errno_location() != 75 )
      break;
LABEL_46:
    sub_804B8CF();
  }
  dword_8071254 = (int)&loc_804E780;
  sub_8064AB4();
LABEL_45:
  v30 = *(&v30 - 196);
  if ( closedir((DIR *)v30) )
  {
    v22 = gettext("closing directory %s");
    v23 = *((unsigned __int8 *)&v30 - 804);
    HIDWORD(v31) = *(&v30 - 199);
    sub_804E0CA(v23, v22);
  }
  sub_8051781();
  if ( byte_80718D4 )
  {
    LODWORD(v31) = 0;
    sub_8050173(a1, *(&v30 - 199), 0);
  }
  if ( !dword_8071898 || byte_80718A7 )
  {
    if ( byte_80718B8 )
    {
      fwrite_unlocked("  ", 1u, 2u, stdout);
      dword_80719B0 += 2;
    }
    *(&v30 - 193) = gettext("total");
    LODWORD(v31) = stdout;
    fputs_unlocked(*(&v30 - 193), stdout);
    dword_80719B0 += strlen(*(&v30 - 193));
    putchar_unlocked(32);
    ++dword_80719B0;
    v35 = *(_QWORD *)&qword_80718AC;
    v33 = 512;
    v34 = 0;
    v32 = dword_80718A8;
    HIDWORD(v31) = &v30 - 166;
    v26 = (int)*(&v30 - 191);
    v30 = *(&v30 - 192);
    *(&v30 - 193) = (char *)sub_805930F(
                              (int)v30,
                              v26,
                              (char *)&v30 - 664,
                              dword_80718A8,
                              512,
                              0,
                              qword_80718AC,
                              *(&qword_80718AC + 1));
    LODWORD(v31) = stdout;
    fputs_unlocked(*(&v30 - 193), stdout);
    dword_80719B0 += strlen(*(&v30 - 193));
    putchar_unlocked(10);
    ++dword_80719B0;
  }
  if ( dword_8071848 )
    sub_8051903(v25, v24);
  return __readgsdword(0x14u) ^ (unsigned int)*(&v30 - 3);
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8049A80: using guessed type int __cdecl readdir64(_DWORD);
// 804EBBC: using guessed type int sub_804EBBC(void);
// 804F00A: using guessed type _DWORD __cdecl sub_804F00A(_DWORD, _DWORD, __int64, _DWORD, _DWORD);
// 8051781: using guessed type int sub_8051781(void);
// 8064A3C: using guessed type int __fastcall sub_8064A3C(_DWORD, _DWORD);
// 8064B22: using guessed type int __stdcall sub_8064B22(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8064C2F: using guessed type int __stdcall sub_8064C2F(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8071218: using guessed type int dword_8071218;
// 8071240: using guessed type int dword_8071240;
// 8071254: using guessed type int dword_8071254;
// 8071268: using guessed type int dword_8071268;
// 80713B0: using guessed type char byte_80713B0;
// 8071848: using guessed type int dword_8071848;
// 8071898: using guessed type int dword_8071898;
// 80718A0: using guessed type int dword_80718A0;
// 80718A7: using guessed type char byte_80718A7;
// 80718B8: using guessed type char byte_80718B8;
// 80718C1: using guessed type char byte_80718C1;
// 80718D4: using guessed type char byte_80718D4;
// 80718EC: using guessed type int dword_80718EC;
// 80718F4: using guessed type char byte_80718F4;
// 80719B0: using guessed type int dword_80719B0;

//----- (0804E96B) --------------------------------------------------------
_DWORD *__cdecl sub_804E96B(int a1)
{
  _DWORD *result; // eax

  result = sub_80613E6(8u);
  *result = a1;
  result[1] = dword_80718DC;
  dword_80718DC = (int)result;
  return result;
}

//----- (0804E9AE) --------------------------------------------------------
int __cdecl sub_804E9AE(int a1, char *name)
{
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = a1; i; i = *(_DWORD *)(i + 4) )
  {
    if ( !fnmatch(*(const char **)i, name, 4) )
      return 1;
  }
  return 0;
}

//----- (0804EA01) --------------------------------------------------------
#error "804EABE: call analysis failed (funcsize=70)"

//----- (0804EAD1) --------------------------------------------------------
__int64 __cdecl sub_804EAD1(__int64 a1)
{
  return a1;
}

//----- (0804EAFB) --------------------------------------------------------
int sub_804EAFB()
{
  *__errno_location() = 95;
  return 0;
}

//----- (0804EB33) --------------------------------------------------------
void __cdecl sub_804EB33(void **a1)
{
  void *v1; // ST00_4

  free(*a1);
  free(a1[1]);
  free(a1[2]);
  if ( a1[29] != &unk_80712C8 )
  {
    if ( (unsigned __int8)sub_804ADE2() )
    {
      free(a1[29]);
    }
    else
    {
      v1 = a1[29];
      sub_8060670();
    }
  }
}

//----- (0804EBBC) --------------------------------------------------------
#error "804EC70: call analysis failed (funcsize=41)"

//----- (0804EC83) --------------------------------------------------------
#error "804ECA6: positive sp value has been found (funcsize=0)"

//----- (0804ECA7) --------------------------------------------------------
#error "804ECC7: call analysis failed (funcsize=26)"

//----- (0804ED02) --------------------------------------------------------
signed int __cdecl sub_804ED02(int a1, int a2, char a3)
{
  signed int result; // eax
  signed int v4; // eax
  int v5; // [esp+0h] [ebp-28h]
  int v6; // [esp+4h] [ebp-24h]
  int v7; // [esp+8h] [ebp-20h]
  char v8; // [esp+Ch] [ebp-1Ch]

  v8 = a3;
  if ( *(_QWORD *)(a2 + 12) == qword_807283C )
  {
    *__errno_location() = 95;
    result = -1;
  }
  else
  {
    *(&v5 - 3) = 0;
    if ( *((_BYTE *)&v5 - 28) )
    {
      v6 = *(_DWORD *)&v8 + 116;
      v5 = v7;
      v4 = sub_80606C1();
    }
    else
    {
      v6 = *(_DWORD *)&v8 + 116;
      v5 = v7;
      v4 = sub_80606F7();
    }
    *(&v5 - 3) = v4;
    if ( *(&v5 - 3) < 0 )
    {
      v5 = *__errno_location();
      if ( (unsigned __int8)sub_804ECA7(v5) )
        qword_807283C = *(_QWORD *)(*(_DWORD *)&v8 + 12);
    }
    result = *(&v5 - 3);
  }
  return result;
}
// 807283C: using guessed type __int64 qword_807283C;

//----- (0804EDD1) --------------------------------------------------------
#error "804EDF8: call analysis failed (funcsize=16)"

//----- (0804EDFD) --------------------------------------------------------
#error "804EEA3: positive sp value has been found (funcsize=50)"

//----- (0804EEA7) --------------------------------------------------------
#error "804EEFD: call analysis failed (funcsize=63)"

//----- (0804EF6E) --------------------------------------------------------
int __cdecl sub_804EF6E(char *s)
{
  size_t v1; // eax
  bool v2; // zf
  void *v3; // eax
  size_t v5; // [esp-4h] [ebp-3Ch]
  int v6; // [esp+0h] [ebp-38h]
  int v7; // [esp+4h] [ebp-34h]
  int v8; // [esp+8h] [ebp-30h]
  int v9; // [esp+Ch] [ebp-2Ch]
  int v10; // [esp+10h] [ebp-28h]
  int v11; // [esp+14h] [ebp-24h]
  int v12; // [esp+18h] [ebp-20h]
  int v13; // [esp+1Ch] [ebp-1Ch]
  int v14; // [esp+20h] [ebp-18h]
  int v15; // [esp+24h] [ebp-14h]
  int v16; // [esp+28h] [ebp-10h]
  int v17; // [esp+2Ch] [ebp-Ch]
  int v18; // [esp+30h] [ebp-8h]
  int v19; // [esp+34h] [ebp-4h]
  int savedregs; // [esp+38h] [ebp+0h]

  v17 = sub_805F844((int)&v6 - 14, 2, (int)s, -1, (int *)dword_80718E8);
  if ( *s == BYTE2(v16) )
  {
    v1 = strlen(s);
    v2 = v1 == v17;
    v5 = v1;
    v3 = &loc_804EFE9;
    if ( v2 )
      v3 = &loc_804F000;
    dword_8071204 = (int)v3;
    sub_8064CB8(v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, savedregs);
  }
  return 1;
}
// 8064CB8: using guessed type int __stdcall sub_8064CB8(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8071204: using guessed type int dword_8071204;
// 80718E8: using guessed type int dword_80718E8;

//----- (0804F00A) --------------------------------------------------------
#error "804FEEA: call analysis failed (funcsize=922)"

//----- (0804FFDA) --------------------------------------------------------
int __cdecl sub_804FFDA(int a1)
{
  return *(_DWORD *)(a1 + 108) == 3 || *(_DWORD *)(a1 + 108) == 9;
}

//----- (08050008) --------------------------------------------------------
int __cdecl sub_8050008(char *path, int a2, int a3)
{
  int v3; // edx
  int result; // eax
  char *v5; // eax

  v3 = *(_DWORD *)(a2 + 60);
  *(_DWORD *)(a2 + 4) = sub_80552AD(path, *(_DWORD *)(a2 + 56));
  result = *(_DWORD *)(a2 + 4);
  if ( !result )
  {
    v5 = gettext("cannot read symbolic link %s");
    result = sub_804E0CA((unsigned __int8)a3, v5);
  }
  return result;
}

//----- (08050075) --------------------------------------------------------
int __usercall sub_8050075@<eax>(int a1@<edx>, int a2@<ecx>, int a3, char *s)
{
  void *v4; // eax

  v4 = &loc_805009A;
  if ( s )
    v4 = &loc_80500A4;
  dword_807127C = (int)v4;
  sub_80649CA(a2, a1);
  return 0;
}
// 80649CA: using guessed type int __fastcall sub_80649CA(_DWORD, _DWORD);
// 807127C: using guessed type int dword_807127C;

//----- (0805014E) --------------------------------------------------------
int __usercall sub_805014E@<eax>(int a1@<edx>, int a2@<ecx>, unsigned __int8 *a3@<ebx>, int a4)
{
  unsigned __int8 *v4; // ST1C_4

  v4 = sub_80568C9(a1, a2, a3, a4);
  return sub_804AAF4(v4);
}

//----- (08050173) --------------------------------------------------------
int __usercall sub_8050173@<eax>(unsigned __int8 *a1@<ebx>, char *s, int a3)
{
  void *v3; // eax
  int v4; // edx
  int v5; // ecx
  void *v6; // eax
  void **v7; // ST2C_4
  int v8; // eax
  int v9; // ST34_4
  int result; // eax
  int v11; // [esp+0h] [ebp-38h]
  int v12; // [esp+4h] [ebp-34h]
  int v13; // [esp+8h] [ebp-30h]
  _DWORD v14[3]; // [esp+Ch] [ebp-2Ch]
  int v15; // [esp+10h] [ebp-28h]
  int v16; // [esp+14h] [ebp-24h]
  int v17; // [esp+18h] [ebp-20h]
  int v18; // [esp+1Ch] [ebp-1Ch]
  unsigned int v19; // [esp+1Ch] [ebp-1Ch]
  int v20; // [esp+20h] [ebp-18h]
  int v21; // [esp+20h] [ebp-18h]
  char **v22; // [esp+24h] [ebp-14h]
  char *ptr; // [esp+28h] [ebp-10h]
  int v24; // [esp+2Ch] [ebp-Ch]
  int v25; // [esp+30h] [ebp-8h]
  int v26; // [esp+34h] [ebp-4h]

  LOBYTE(v14[0]) = a3;
  HIBYTE(v17) = s != 0;
  if ( s )
  {
    v3 = &loc_80501B1;
    if ( !dword_807183C )
      v3 = &loc_80501CC;
    dword_8071254 = (int)v3;
    sub_8064AB4();
    sub_804E124(0, s, 0);
  }
  v18 = dword_8071848;
  while ( 1 )
  {
    v8 = v18--;
    if ( !v8 )
      break;
    v22 = (char **)*((_DWORD *)dword_8071850 + v18);
    if ( (unsigned __int8)sub_804FFDA((int)v22)
      && (HIBYTE(v17) != 1 || (unsigned __int8)sub_805014E(v4, v5, a1, (int)*v22) ^ 1) )
    {
      if ( s && **v22 != 47 )
      {
        ptr = (char *)sub_8056DF0(v4, v5, a1, (int)s, *v22);
        sub_804E124(ptr, v22[1], LOBYTE(v14[0]));
        free(ptr);
      }
      else
      {
        sub_804E124(*v22, v22[1], LOBYTE(v14[0]));
      }
      v6 = &loc_80502BF;
      if ( v22[27] != (char *)9 )
        v6 = &loc_80502CA;
      dword_8071240 = (int)v6;
      sub_8064B22(v11, v12, v13, v14[0], v15, v16, v17, v18, v20, v22, ptr, v24, v25, v26);
      sub_804EB33(v7);
    }
  }
  v19 = 0;
  v21 = 0;
  while ( v19 < dword_8071848 )
  {
    v9 = *((_DWORD *)dword_8071850 + v19);
    *((_DWORD *)dword_8071850 + v21) = v9;
    v21 += *(_DWORD *)(v9 + 108) != 9;
    ++v19;
  }
  result = v21;
  dword_8071848 = v21;
  return result;
}
// 8064B22: using guessed type int __stdcall sub_8064B22(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8071240: using guessed type int dword_8071240;
// 8071254: using guessed type int dword_8071254;
// 8071848: using guessed type int dword_8071848;

//----- (08050349) --------------------------------------------------------
void __cdecl __noreturn sub_8050349(char *s1, char *s2)
{
  bool v2; // zf
  int (*v3)(); // eax
  int v4; // edi
  int v5; // esi
  char *v6; // ebx
  int *v7; // eax
  int v8; // [esp+0h] [ebp-48h]
  int v9; // [esp+4h] [ebp-44h]
  int v10; // [esp+8h] [ebp-40h]
  int v11; // [esp+Ch] [ebp-3Ch]
  int v12; // [esp+10h] [ebp-38h]
  int v13; // [esp+14h] [ebp-34h]
  int v14; // [esp+18h] [ebp-30h]
  int v15; // [esp+1Ch] [ebp-2Ch]
  int v16; // [esp+20h] [ebp-28h]
  int v17; // [esp+24h] [ebp-24h]
  int v18; // [esp+28h] [ebp-20h]

  *__errno_location() = 0;
  strcoll(s1, s2);
  v2 = *__errno_location() == 0;
  v3 = (int (*)())&loc_8050396;
  if ( v2 )
    v3 = sub_8050415;
  dword_8071218 = (int)v3;
  sub_8064C2F(v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18);
  v4 = sub_80603C6(1);
  v5 = sub_80603C6(0);
  v6 = gettext("cannot compare file names %s and %s");
  v7 = __errno_location();
  error(0, *v7, v6, v5, v4);
  sub_804E087(0);
  longjmp(env, 1);
}
// 8050415: using guessed type int sub_8050415();
// 8064C2F: using guessed type int __stdcall sub_8064C2F(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8071218: using guessed type int dword_8071218;

//----- (08050415) --------------------------------------------------------
#error "805041B: positive sp value has been found (funcsize=0)"

//----- (08050420) --------------------------------------------------------
int __cdecl sub_8050420(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD))
{
  int result; // eax
  int v4; // [esp+1Ch] [ebp-1Ch]
  int v5; // [esp+20h] [ebp-18h]
  int v6; // [esp+24h] [ebp-14h]
  int v7; // [esp+28h] [ebp-10h]
  int v8; // [esp+2Ch] [ebp-Ch]

  sub_806087C(&v5, a1 + 3);
  sub_806087C(&v7, a2 + 3);
  v4 = sub_806097D(v7, v8, v5, v6);
  if ( v4 )
    result = v4;
  else
    result = a3(*a1, *a2);
  return result;
}
// 806087C: using guessed type _DWORD __cdecl sub_806087C(_DWORD, _DWORD);
// 806097D: using guessed type _DWORD __cdecl sub_806097D(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (080504B0) --------------------------------------------------------
#error "8050527: call analysis failed (funcsize=50)"

//----- (08050549) --------------------------------------------------------
int __cdecl sub_8050549(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD))
{
  int result; // eax
  int v4; // [esp+1Ch] [ebp-1Ch]
  int v5; // [esp+20h] [ebp-18h]
  int v6; // [esp+24h] [ebp-14h]
  int v7; // [esp+28h] [ebp-10h]
  int v8; // [esp+2Ch] [ebp-Ch]

  sub_8060851(&v5, (int)(a1 + 3));
  sub_8060851(&v7, (int)(a2 + 3));
  v4 = sub_806097D(v7, v8, v5, v6);
  if ( v4 )
    result = v4;
  else
    result = a3(*a1, *a2);
  return result;
}
// 806097D: using guessed type _DWORD __cdecl sub_806097D(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (080505D1) --------------------------------------------------------
int __cdecl sub_80505D1(int *a1, int *a2, int (__fastcall *a3)(_DWORD))
{
  __int64 v3; // rcx
  __int64 v4; // rax
  __int64 v5; // rax
  unsigned __int8 v6; // si
  signed int v7; // eax
  int v8; // eax
  int v10; // [esp+0h] [ebp-28h]
  int v11; // [esp+4h] [ebp-24h]
  int v12; // [esp+1Ch] [ebp-Ch]

  LODWORD(v3) = a2[14];
  LODWORD(v4) = a1[14];
  HIDWORD(v3) = a2[15];
  HIDWORD(v4) = a1[15];
  if ( v3 < v4 )
  {
    v7 = -1;
  }
  else
  {
    LODWORD(v3) = a2[14];
    v6 = 1;
    LODWORD(v5) = a1[14];
    HIDWORD(v3) = a2[15];
    HIDWORD(v5) = a1[15];
    if ( v3 <= v5 )
      v6 = 0;
    v7 = v6;
  }
  v12 = v7;
  if ( v7 )
    return v12;
  v8 = *a1;
  v11 = *a2;
  v10 = v8;
  return a3(v3);
}

//----- (0805066A) --------------------------------------------------------
int __cdecl sub_805066A(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD))
{
  return a3(*a1, *a2);
}

//----- (08050698) --------------------------------------------------------
int __cdecl sub_8050698(const char **a1, const char **a2, int (__stdcall *a3)(char *, char *, int, int, int, char *, char *, int, int, int))
{
  char *v3; // edx
  char *v4; // eax
  int v6; // [esp+8h] [ebp-24h]
  int v7; // [esp+Ch] [ebp-20h]
  int v8; // [esp+10h] [ebp-1Ch]
  char *v9; // [esp+14h] [ebp-18h]
  char *v10; // [esp+18h] [ebp-14h]
  int v11; // [esp+1Ch] [ebp-10h]
  int v12; // [esp+1Ch] [ebp-10h]
  int v13; // [esp+20h] [ebp-Ch]
  int v14; // [esp+24h] [ebp-8h]
  const char *retaddr; // [esp+2Ch] [ebp+0h]

  v9 = strrchr(*a1, 46);
  v10 = strrchr(*a2, 46);
  if ( v10 )
    v3 = v10;
  else
    v3 = &s;
  if ( v9 )
    v4 = v9;
  else
    v4 = &s;
  v12 = a3(v4, v3, v6, v7, v8, v9, v10, v11, v13, v14);
  if ( v12 )
    return v12;
  retaddr = *a2;
  return ((int (__cdecl *)(const char *))a3)(*a1);
}

//----- (08050E59) --------------------------------------------------------
int __cdecl sub_8050E59(int *a1, int *a2)
{
  return sub_80505D1(a1, a2, (int (__fastcall *)(_DWORD))sub_8050349);
}

//----- (08050E7B) --------------------------------------------------------
int __cdecl sub_8050E7B(int *a1, int *a2)
{
  return sub_80505D1(a1, a2, (int (__fastcall *)(_DWORD))strcmp);
}

//----- (08050E9D) --------------------------------------------------------
int __cdecl sub_8050E9D(int *a1, int *a2)
{
  return sub_80505D1(a2, a1, (int (__fastcall *)(_DWORD))sub_8050349);
}

//----- (08050EBF) --------------------------------------------------------
int __cdecl sub_8050EBF(int *a1, int *a2)
{
  return sub_80505D1(a2, a1, (int (__fastcall *)(_DWORD))strcmp);
}

//----- (08050EE1) --------------------------------------------------------
int __cdecl sub_8050EE1(int *a1, int *a2)
{
  int v2; // edx
  int v3; // ecx
  int result; // eax
  char v5; // [esp+1Eh] [ebp-Ah]
  char v6; // [esp+1Fh] [ebp-9h]

  v5 = sub_804FFDA((int)a1);
  v6 = sub_804FFDA((int)a2);
  if ( v5 && v6 != 1 )
  {
    dword_807127C = (int)&locret_8050F62;
    sub_80649CA(v3, v2);
  }
  if ( v5 != 1 && v6 )
    result = 1;
  else
    result = sub_80505D1(a1, a2, (int (__fastcall *)(_DWORD))sub_8050349);
  return result;
}
// 80649CA: using guessed type int __fastcall sub_80649CA(_DWORD, _DWORD);
// 807127C: using guessed type int dword_807127C;

//----- (08050F64) --------------------------------------------------------
#error "8050FDC: call analysis failed (funcsize=51)"

//----- (08051004) --------------------------------------------------------
int __cdecl sub_8051004(int *a1, int *a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_804FFDA((int)a1);
  v4 = sub_804FFDA((int)a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_80505D1(a2, a1, (int (__fastcall *)(_DWORD))sub_8050349);
}

//----- (08051072) --------------------------------------------------------
int __cdecl sub_8051072(int *a1, int *a2)
{
  char v2; // ST26_1
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  int result; // eax
  char v7; // [esp+1Fh] [ebp-9h]

  v2 = sub_804FFDA((int)a1);
  v7 = sub_804FFDA((int)a2);
  if ( v2 )
  {
    v5 = &loc_80510BE;
    if ( v7 == 1 )
      v5 = &loc_80510C5;
    dword_807127C = (int)v5;
    sub_80649CA(v4, v3);
    result = -1;
  }
  else if ( v7 )
  {
    result = 1;
  }
  else
  {
    result = sub_80505D1(a2, a1, (int (__fastcall *)(_DWORD))strcmp);
  }
  return result;
}
// 80649CA: using guessed type int __fastcall sub_80649CA(_DWORD, _DWORD);
// 807127C: using guessed type int dword_807127C;

//----- (080510F9) --------------------------------------------------------
int __cdecl sub_80510F9(_DWORD *a1, _DWORD *a2)
{
  return sub_805066A(a1, a2, (int (__cdecl *)(_DWORD, _DWORD))sub_8050349);
}

//----- (0805111B) --------------------------------------------------------
int __cdecl sub_805111B(_DWORD *a1, _DWORD *a2)
{
  return sub_805066A(a1, a2, (int (__cdecl *)(_DWORD, _DWORD))strcmp);
}

//----- (0805113D) --------------------------------------------------------
int __cdecl sub_805113D(_DWORD *a1, _DWORD *a2)
{
  return sub_805066A(a2, a1, (int (__cdecl *)(_DWORD, _DWORD))sub_8050349);
}

//----- (0805115F) --------------------------------------------------------
int __cdecl sub_805115F(_DWORD *a1, _DWORD *a2)
{
  return sub_805066A(a2, a1, (int (__cdecl *)(_DWORD, _DWORD))strcmp);
}

//----- (08051181) --------------------------------------------------------
int __cdecl sub_8051181(_DWORD *a1, _DWORD *a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_804FFDA((int)a1);
  v4 = sub_804FFDA((int)a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_805066A(a1, a2, (int (__cdecl *)(_DWORD, _DWORD))sub_8050349);
}

//----- (080511EF) --------------------------------------------------------
int __cdecl sub_80511EF(_DWORD *a1, _DWORD *a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_804FFDA((int)a1);
  v4 = sub_804FFDA((int)a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_805066A(a1, a2, (int (__cdecl *)(_DWORD, _DWORD))strcmp);
}

//----- (0805125D) --------------------------------------------------------
#error "80512BB: call analysis failed (funcsize=40)"

//----- (080512E0) --------------------------------------------------------
int __cdecl sub_80512E0(_DWORD *a1, _DWORD *a2)
{
  int v3; // [esp+0h] [ebp-28h]
  int v4; // [esp+4h] [ebp-24h]
  int v5; // [esp+8h] [ebp-20h]
  int v6; // [esp+Ch] [ebp-1Ch]
  int v7; // [esp+10h] [ebp-18h]
  int v8; // [esp+14h] [ebp-14h]
  int v9; // [esp+18h] [ebp-10h]
  int v10; // [esp+1Ch] [ebp-Ch]
  int v11; // [esp+20h] [ebp-8h]
  int v12; // [esp+24h] [ebp-4h]
  int savedregs; // [esp+28h] [ebp+0h]

  BYTE2(v10) = sub_804FFDA((int)a1);
  HIBYTE(v10) = sub_804FFDA((int)a2);
  if ( BYTE2(v10) && HIBYTE(v10) != 1 )
    return -1;
  if ( BYTE2(v10) != 1 )
  {
    if ( HIBYTE(v10) )
    {
      dword_8071218 = (int)&locret_8051361;
      sub_8064C2F(v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, savedregs);
    }
  }
  return sub_805066A(a2, a1, (int (__cdecl *)(_DWORD, _DWORD))strcmp);
}
// 8064C2F: using guessed type int __stdcall sub_8064C2F(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8071218: using guessed type int dword_8071218;

//----- (08051363) --------------------------------------------------------
int __cdecl sub_8051363(const char **a1, const char **a2)
{
  return sub_8050698(
           a1,
           a2,
           (int (__stdcall *)(char *, char *, int, int, int, char *, char *, int, int, int))sub_8050349);
}

//----- (08051399) --------------------------------------------------------
int __cdecl sub_8051399(const char **a1, const char **a2)
{
  return sub_8050698(a1, a2, (int (__stdcall *)(char *, char *, int, int, int, char *, char *, int, int, int))strcmp);
}

//----- (080513BB) --------------------------------------------------------
int __cdecl sub_80513BB(const char **a1, const char **a2)
{
  return sub_8050698(
           a2,
           a1,
           (int (__stdcall *)(char *, char *, int, int, int, char *, char *, int, int, int))sub_8050349);
}

//----- (080513DD) --------------------------------------------------------
int __cdecl sub_80513DD(const char **a1, const char **a2)
{
  return sub_8050698(a2, a1, (int (__stdcall *)(char *, char *, int, int, int, char *, char *, int, int, int))strcmp);
}

//----- (080513FF) --------------------------------------------------------
int __cdecl sub_80513FF(const char **a1, const char **a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_804FFDA((int)a1);
  v4 = sub_804FFDA((int)a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_8050698(
           a1,
           a2,
           (int (__stdcall *)(char *, char *, int, int, int, char *, char *, int, int, int))sub_8050349);
}

//----- (0805146D) --------------------------------------------------------
int __cdecl sub_805146D(const char **a1, const char **a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_804FFDA((int)a1);
  v4 = sub_804FFDA((int)a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_8050698(a1, a2, (int (__stdcall *)(char *, char *, int, int, int, char *, char *, int, int, int))strcmp);
}

//----- (080514DB) --------------------------------------------------------
int __cdecl sub_80514DB(const char **a1, const char **a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_804FFDA((int)a1);
  v4 = sub_804FFDA((int)a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_8050698(
           a2,
           a1,
           (int (__stdcall *)(char *, char *, int, int, int, char *, char *, int, int, int))sub_8050349);
}

//----- (08051549) --------------------------------------------------------
int __cdecl sub_8051549(const char **a1, const char **a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_804FFDA((int)a1);
  v4 = sub_804FFDA((int)a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_8050698(a2, a1, (int (__stdcall *)(char *, char *, int, int, int, char *, char *, int, int, int))strcmp);
}

//----- (080515B7) --------------------------------------------------------
int __cdecl sub_80515B7(char **a1, char **a2)
{
  return sub_8057350(*a1, *a2);
}

//----- (080515D5) --------------------------------------------------------
int __cdecl sub_80515D5(char **a1, char **a2)
{
  return sub_80515B7(a1, a2);
}

//----- (080515EF) --------------------------------------------------------
int __cdecl sub_80515EF(char **a1, char **a2)
{
  return sub_80515B7(a2, a1);
}

//----- (0805160D) --------------------------------------------------------
#error "8051666: call analysis failed (funcsize=42)"

//----- (0805168C) --------------------------------------------------------
#error "80516EA: call analysis failed (funcsize=39)"

//----- (08051707) --------------------------------------------------------
int sub_8051707()
{
  int result; // eax
  unsigned int i; // [esp+Ch] [ebp-8h]

  for ( i = 0; ; ++i )
  {
    result = dword_8071848;
    if ( i >= dword_8071848 )
      break;
    *((_DWORD *)dword_8071850 + i) = (char *)dword_8071840 + 136 * i;
  }
  return result;
}
// 8071848: using guessed type int dword_8071848;

//----- (08051781) --------------------------------------------------------
#error "805181F: call analysis failed (funcsize=65)"

//----- (08051903) --------------------------------------------------------
int __fastcall sub_8051903(int a1, int a2)
{
  int result; // eax
  int v3; // edx
  int v4; // ecx
  unsigned int j; // [esp+1Ch] [ebp-Ch]
  unsigned int i; // [esp+1Ch] [ebp-Ch]

  result = dword_8071898;
  switch ( dword_8071898 )
  {
    case 0:
      for ( i = 0; ; ++i )
      {
        result = dword_8071848;
        if ( i >= dword_8071848 )
          break;
        sub_804B835(a1, a2);
        sub_8051F42(*((_DWORD *)dword_8071850 + i));
        putchar_unlocked(10);
        ++dword_80719B0;
      }
      break;
    case 1:
      for ( j = 0; ; ++j )
      {
        result = dword_8071848;
        if ( j >= dword_8071848 )
          break;
        sub_8053953(*((_DWORD *)dword_8071850 + j));
        putchar_unlocked(10);
      }
      break;
    case 2:
      if ( !dword_80718F8 )
      {
        sub_80547D5(32);
        dword_80711F0 = (int)&locret_8051A16;
        sub_8064D28(v4, v3);
      }
      result = sub_80544DF();
      break;
    case 3:
      if ( dword_80718F8 )
        result = sub_805464B();
      else
        result = sub_80547D5(32);
      break;
    case 4:
      result = sub_80547D5(44);
      break;
    default:
      return result;
  }
  return result;
}
// 8051F42: using guessed type _DWORD __cdecl sub_8051F42(_DWORD);
// 8053953: using guessed type _DWORD __cdecl sub_8053953(_DWORD);
// 80711F0: using guessed type int dword_80711F0;
// 8071848: using guessed type int dword_8071848;
// 8071898: using guessed type int dword_8071898;
// 80718F8: using guessed type int dword_80718F8;
// 80719B0: using guessed type int dword_80719B0;

//----- (08051A18) --------------------------------------------------------
#error "8051AAE: call analysis failed (funcsize=46)"

//----- (08051AB3) --------------------------------------------------------
#error "8051AC4: positive sp value has been found (funcsize=0)"

//----- (08051AC5) --------------------------------------------------------
int sub_8051AC5()
{
  int result; // eax
  time_t timer; // [esp+2Ch] [ebp-42Ch]
  int v2; // [esp+30h] [ebp-428h]
  struct tm tp; // [esp+34h] [ebp-424h]
  char v4; // [esp+63h] [ebp-3F5h]
  unsigned int v5; // [esp+44Ch] [ebp-Ch]

  v5 = __readgsdword(0x14u);
  if ( dword_80713B4 < 0 )
  {
    timer = 0;
    if ( sub_806314F(dword_80718FC, &timer, &tp) )
    {
      v2 = sub_8051A18(&v4, 1001, 0, &tp, dword_80718FC, 0);
      if ( v2 )
        dword_80713B4 = sub_805AFD8(&v4, v2, 0);
    }
    if ( dword_80713B4 < 0 )
      dword_80713B4 = 0;
  }
  result = dword_80713B4;
  __readgsdword(0x14u);
  return result;
}
// 8051A18: using guessed type _DWORD __cdecl sub_8051A18(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 805AFD8: using guessed type _DWORD __cdecl sub_805AFD8(_DWORD, _DWORD, _DWORD);
// 80713B4: using guessed type int dword_80713B4;

//----- (08051BB1) --------------------------------------------------------
#error "8051BD1: call analysis failed (funcsize=74)"

//----- (08051CC5) --------------------------------------------------------
int __cdecl sub_8051CC5(__uid_t uid, int a2, int a3)
{
  char *v3; // eax

  if ( (_BYTE)a3 == 1 )
  {
    if ( byte_80718A6 )
      v3 = 0;
    else
      v3 = (char *)sub_805A318(uid);
  }
  else
  {
    v3 = "?";
  }
  return sub_8051BB1(v3, uid, a2);
}
// 80718A6: using guessed type char byte_80718A6;

//----- (08051D36) --------------------------------------------------------
int __cdecl sub_8051D36(__gid_t gid, int a2, int a3)
{
  char *v3; // eax

  if ( (_BYTE)a3 == 1 )
  {
    if ( byte_80718A6 )
      v3 = 0;
    else
      v3 = (char *)sub_805A54D(gid);
  }
  else
  {
    v3 = "?";
  }
  return sub_8051BB1(v3, gid, a2);
}
// 80718A6: using guessed type char byte_80718A6;

//----- (08051D89) --------------------------------------------------------
#error "8051DAE: call analysis failed (funcsize=14)"

//----- (08051DB3) --------------------------------------------------------
#error "8051E09: call analysis failed (funcsize=47)"

//----- (08051E51) --------------------------------------------------------
#error "8051E52: positive sp value has been found (funcsize=0)"

//----- (08051E53) --------------------------------------------------------
int __cdecl sub_8051E53(__uid_t uid)
{
  size_t v1; // eax

  if ( byte_80718A6 )
    v1 = 0;
  else
    v1 = sub_805A318(uid);
  return sub_8051D89(v1);
}
// 8051D89: using guessed type _DWORD __cdecl sub_8051D89(_DWORD);
// 80718A6: using guessed type char byte_80718A6;

//----- (08051E8B) --------------------------------------------------------
int __cdecl sub_8051E8B(__gid_t gid)
{
  int v1; // eax

  if ( byte_80718A6 )
    v1 = 0;
  else
    v1 = sub_805A54D(gid);
  return sub_8051D89(v1);
}
// 8051D89: using guessed type _DWORD __cdecl sub_8051D89(_DWORD);
// 80718A6: using guessed type char byte_80718A6;

//----- (08051ECF) --------------------------------------------------------
const char *__cdecl sub_8051ECF(int a1, unsigned int a2, int a3)
{
  const char *result; // eax

  if ( a2 <= 0x14 )
    __assert_fail("INT_BUFSIZE_BOUND (uintmax_t) <= buflen", "src/ls.c", 0xFA7u, "format_inode");
  if ( *(_BYTE *)(a3 + 120) && *(_QWORD *)(a3 + 100) )
    result = (const char *)sub_805A943(*(_QWORD *)(a3 + 100), a1);
  else
    result = "?";
  return result;
}

//----- (08051F42) --------------------------------------------------------
#error "8052842: call analysis failed (funcsize=559)"

//----- (08052BB0) --------------------------------------------------------
#error "8052DEA: call analysis failed (funcsize=348)"

//----- (080530D6) --------------------------------------------------------
#error "80530D9: positive sp value has been found (funcsize=0)"

//----- (080530DD) --------------------------------------------------------
#error "8053142: call analysis failed (funcsize=27)"

//----- (08053147) --------------------------------------------------------
#error "8053174: call analysis failed (funcsize=11)"

//----- (080531F3) --------------------------------------------------------
char *__cdecl sub_80531F3(char *s, int a2)
{
  size_t v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // edx
  char *v6; // eax
  unsigned __int8 v7; // al
  int v8; // eax
  int v10; // [esp+0h] [ebp-28h]
  int v11; // [esp+8h] [ebp-20h]
  char v12; // [esp+Ch] [ebp-1Ch]
  char *v13; // [esp+18h] [ebp-10h]
  char *v14; // [esp+1Ch] [ebp-Ch]

  v12 = a2;
  v2 = strlen(s);
  v14 = (char *)sub_806126A(3u, v2 + 1);
  v13 = v14;
  while ( *s )
  {
    if ( v12 && *s == 47 )
    {
      v3 = v13++;
      *v3 = 47;
      ++s;
    }
    else
    {
      v10 = *s;
      if ( byte_8071A7C[(unsigned __int8)sub_804AAE2(v10)] )
      {
        v4 = v13++;
        v5 = s++;
        *v4 = *v5;
      }
      else
      {
        v6 = s++;
        v10 = *v6;
        v7 = sub_804AAE2(v10);
        v11 = v7;
        v8 = sprintf(v13, "%%%02x", v7);
        v13 += v8;
      }
    }
  }
  *v13 = 0;
  return v14;
}

//----- (080532D6) --------------------------------------------------------
void __cdecl __noreturn sub_80532D6(int a1, int a2, int a3, int a4, char a5, int a6, int a7)
{
  int v7; // [esp+0h] [ebp-2078h]
  mbstate_t *v8; // [esp+4h] [ebp-2074h]
  int v9; // [esp+8h] [ebp-2070h]
  int v10; // [esp+Ch] [ebp-206Ch]
  int v11; // [esp+10h] [ebp-2068h]
  int v12; // [esp+14h] [ebp-2064h]
  char *v13; // [esp+18h] [ebp-2060h]
  int v14; // [esp+28h] [ebp-2050h]
  int v15; // [esp+2Ch] [ebp-204Ch]
  char v16; // [esp+30h] [ebp-2048h]
  int v17; // [esp+34h] [ebp-2044h]
  int v18; // [esp+38h] [ebp-2040h]
  int v19; // [esp+3Ch] [ebp-203Ch]
  char v20; // [esp+42h] [ebp-2036h]
  size_t v21; // [esp+44h] [ebp-2034h]
  char v22; // [esp+6Ch] [ebp-200Ch]
  unsigned int v23; // [esp+206Ch] [ebp-Ch]

  v19 = a1;
  v18 = a2;
  v17 = a4;
  v16 = a5;
  v15 = a6;
  v14 = a7;
  v23 = __readgsdword(0x14u);
  v21 = (size_t)&v22;
  v13 = &v20;
  v12 = 0;
  v11 = a3;
  v10 = a2;
  v9 = a1;
  v8 = (mbstate_t *)0x2000;
  sub_8052BB0((size_t)(&v7 - 2061), v8);
}

//----- (0805379B) --------------------------------------------------------
void __usercall __noreturn sub_805379B(int a1@<edx>, int a2@<ecx>, int *a3, unsigned __int8 a4, int a5)
{
  int v5; // eax
  int v6; // eax
  int v7; // [esp+24h] [ebp-24h]
  int v8; // [esp+28h] [ebp-20h]

  if ( a4 )
    v5 = a3[1];
  else
    v5 = *a3;
  v7 = v5;
  if ( byte_80718C0 )
    v6 = sub_8053DE3(a3, a4);
  else
    v6 = 0;
  v8 = v6;
  if ( byte_80718C0 )
  {
    if ( !v6 )
      sub_804B752(a1, a2, 4);
  }
  sub_80532D6(v7, dword_80718E8, a3[33], v8, a4 == 0, a5, a3[2]);
}
// 8053DE3: using guessed type _DWORD __cdecl sub_8053DE3(_DWORD, _DWORD);
// 80718C0: using guessed type char byte_80718C0;
// 80718E8: using guessed type int dword_80718E8;

//----- (0805390C) --------------------------------------------------------
size_t sub_805390C()
{
  if ( dword_80712FC )
    return sub_8054226((int)&unk_80712F8);
  sub_8054226((int)dword_80712E8);
  sub_8054226((int)&unk_8071300);
  return sub_8054226((int)&dword_80712F0);
}
// 80712E8: using guessed type int dword_80712E8[];
// 80712F0: using guessed type int dword_80712F0;
// 80712FC: using guessed type int dword_80712FC;

//----- (08053953) --------------------------------------------------------
#error "8053A1A: call analysis failed (funcsize=60)"

//----- (08053A2D) --------------------------------------------------------
#error "8053AAE: call analysis failed (funcsize=63)"

//----- (08053BBA) --------------------------------------------------------
#error "8053C5E: call analysis failed (funcsize=109)"

//----- (08053D0F) --------------------------------------------------------
bool __cdecl sub_8053D0F(unsigned __int8 a1, int a2, int a3)
{
  int v4; // [esp+0h] [ebp-28h]
  unsigned __int8 v5; // [esp+Ch] [ebp-1Ch]

  v5 = a1;
  *((_BYTE *)&v4 - 9) = sub_8053BBA(a1, a2, a3);
  if ( *((_BYTE *)&v4 - 9) )
  {
    putchar_unlocked(*((char *)&v4 - 9));
    ++dword_80719B0;
  }
  return *((_BYTE *)&v4 - 9) != 0;
}
// 8053BBA: using guessed type _DWORD __cdecl sub_8053BBA(_DWORD, _DWORD, _DWORD);
// 80719B0: using guessed type int dword_80719B0;

//----- (08053D92) --------------------------------------------------------
bool __usercall sub_8053D92@<al>(int a1@<edx>, int a2@<ecx>, int a3)
{
  if ( a3 )
  {
    if ( (unsigned __int8)sub_804B752(a1, a2, 4) )
      sub_804B7F3();
    sub_8054226((int)dword_80712E8);
    sub_8054226(a3);
    sub_8054226((int)&dword_80712F0);
  }
  return a3 != 0;
}
// 804B7F3: using guessed type int sub_804B7F3(void);
// 80712E8: using guessed type int dword_80712E8[];
// 80712F0: using guessed type int dword_80712F0;

//----- (08053DE3) --------------------------------------------------------
#error "8053FDB: call analysis failed (funcsize=267)"

//----- (08054226) --------------------------------------------------------
size_t __cdecl sub_8054226(int a1)
{
  if ( byte_80718C2 != 1 )
  {
    byte_80718C2 = 1;
    if ( tcgetpgrp(1) >= 0 )
      sub_804BB73();
    sub_805390C();
  }
  return fwrite_unlocked(*(const void **)(a1 + 4), *(_DWORD *)a1, 1u, stdout);
}
// 80718C2: using guessed type char byte_80718C2;

//----- (08054294) --------------------------------------------------------
int __cdecl sub_8054294(int a1)
{
  int v1; // edx
  const char *v2; // eax
  int v3; // eax
  const char *v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // edx
  int v10; // eax
  const char *v12; // [esp+0h] [ebp-2D8h]
  int v13; // [esp+4h] [ebp-2D4h]
  int v14; // [esp+8h] [ebp-2D0h]
  int v15; // [esp+Ch] [ebp-2CCh]
  int v16; // [esp+10h] [ebp-2C8h]
  int v17; // [esp+14h] [ebp-2C4h]
  int v18; // [esp+18h] [ebp-2C0h]
  int v19; // [esp+1Ch] [ebp-2BCh]
  int v20; // [esp+20h] [ebp-2B8h]
  int v21; // [esp+24h] [ebp-2B4h]
  int v22; // [esp+28h] [ebp-2B0h]
  int *v23; // [esp+2Ch] [ebp-2ACh]
  int v24; // [esp+30h] [ebp-2A8h]
  int v25; // [esp+34h] [ebp-2A4h]
  char v26; // [esp+3Bh] [ebp-29Dh]
  int v27; // [esp+3Ch] [ebp-29Ch]
  char s; // [esp+40h] [ebp-298h]
  unsigned int v29; // [esp+2CCh] [ebp-Ch]

  v23 = (int *)a1;
  v29 = __readgsdword(0x14u);
  v27 = 0;
  if ( byte_80718CD )
  {
    if ( dword_8071898 == 4 )
    {
      v1 = v23[26];
      v12 = (const char *)v23[25];
      v13 = v1;
      v2 = (const char *)sub_805A943(*(unsigned __int64 *)&v12, (int)&s);
      v3 = strlen(v2) + 1;
    }
    else
    {
      v3 = dword_8071870 + 1;
    }
    v27 += v3;
  }
  if ( byte_80718A7 )
  {
    if ( dword_8071898 == 4 )
    {
      if ( *((_BYTE *)v23 + 120) != 1 )
      {
        dword_8071240 = (int)&loc_80543C9;
        sub_8064B22(v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25);
      }
      v4 = (const char *)sub_805930F(
                           v23[17],
                           v23[18],
                           (char *)&v12 - 664,
                           dword_80718A8,
                           512,
                           0,
                           qword_80718AC,
                           *(&qword_80718AC + 1));
      v5 = strlen(v4) + 1;
    }
    else
    {
      v5 = dword_8071874 + 1;
    }
    v27 += v5;
  }
  if ( byte_807186C )
  {
    if ( dword_8071898 == 4 )
    {
      v12 = (const char *)v23[29];
      v6 = strlen(v12) + 1;
    }
    else
    {
      v6 = dword_807187C + 1;
    }
    v27 += v6;
  }
  v7 = *v23;
  v14 = v23[33];
  v8 = sub_80530DD(v7, dword_80718E8, v14);
  v27 += v8;
  if ( dword_80718BC )
  {
    v9 = v23[7];
    v10 = *((unsigned __int8 *)v23 + 120);
    v14 = v23[27];
    v26 = sub_8053BBA(v10, v9, v14);
    v27 += v26 != 0;
  }
  return v27;
}
// 80530DD: using guessed type _DWORD __cdecl sub_80530DD(_DWORD, _DWORD, _DWORD);
// 8053BBA: using guessed type _DWORD __cdecl sub_8053BBA(_DWORD, _DWORD, _DWORD);
// 8064B22: using guessed type int __stdcall sub_8064B22(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8071240: using guessed type int dword_8071240;
// 807186C: using guessed type char byte_807186C;
// 8071870: using guessed type int dword_8071870;
// 8071874: using guessed type int dword_8071874;
// 8071898: using guessed type int dword_8071898;
// 80718A7: using guessed type char byte_80718A7;
// 80718BC: using guessed type int dword_80718BC;
// 80718CD: using guessed type char byte_80718CD;
// 80718E8: using guessed type int dword_80718E8;

//----- (080544DF) --------------------------------------------------------
unsigned int sub_80544DF()
{
  int v0; // ecx
  int v1; // eax
  unsigned int result; // eax
  int v3; // [esp+0h] [ebp-48h]
  int v4; // [esp+4h] [ebp-44h]
  int v5; // [esp+8h] [ebp-40h]
  int v6; // [esp+Ch] [ebp-3Ch]
  int v7; // [esp+10h] [ebp-38h]
  int v8; // [esp+14h] [ebp-34h]
  int v9; // [esp+18h] [ebp-30h]
  int v10; // [esp+1Ch] [ebp-2Ch]
  int v11; // [esp+20h] [ebp-28h]
  int v12; // [esp+24h] [ebp-24h]
  unsigned int v13; // [esp+28h] [ebp-20h]
  char *v14; // [esp+2Ch] [ebp-1Ch]
  int v15; // [esp+30h] [ebp-18h]
  int v16; // [esp+34h] [ebp-14h]

  v13 = sub_8054C8F(1);
  v14 = (char *)dword_80719A8 + 12 * v13 - 12;
  *(&v3 - 6) = dword_8071848 / (unsigned int)*(&v3 - 8) + (dword_8071848 % (unsigned int)*(&v3 - 8) != 0);
  *(&v3 - 12) = 0;
  dword_8071240 = (int)&loc_805463D;
  sub_8064B22(v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16);
  do
  {
    *(&v3 - 11) = 0;
    *(&v3 - 10) = *(&v3 - 12);
    for ( *(&v3 - 9) = 0; ; *(&v3 - 9) += *(&v3 - 3) )
    {
      *(&v3 - 5) = *((_DWORD *)dword_8071850 + *(&v3 - 10));
      v3 = *(&v3 - 5);
      *(&v3 - 4) = sub_8054294(v3);
      v0 = *(_DWORD *)(*(&v3 - 7) + 8);
      v1 = *(&v3 - 11);
      *(&v3 - 11) = v1 + 1;
      *(&v3 - 3) = *(_DWORD *)(v0 + 4 * v1);
      v4 = *(&v3 - 9);
      sub_8053953(*(&v3 - 5));
      *(&v3 - 10) += *(&v3 - 6);
      if ( *(&v3 - 10) >= (unsigned int)dword_8071848 )
        break;
      sub_80548CF(*(&v3 - 9) + *(&v3 - 4), *(&v3 - 3) + *(&v3 - 9));
    }
    putchar_unlocked(10);
    result = ++*(&v3 - 12);
  }
  while ( result < *(&v3 - 6) );
  return result;
}
// 8053953: using guessed type _DWORD __cdecl sub_8053953(_DWORD);
// 8064B22: using guessed type int __stdcall sub_8064B22(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8071240: using guessed type int dword_8071240;
// 8071848: using guessed type int dword_8071848;

//----- (0805464B) --------------------------------------------------------
int sub_805464B()
{
  void *v0; // eax
  int v1; // edx
  int v2; // ecx
  int v4; // [esp+4h] [ebp-34h]
  unsigned int i; // [esp+10h] [ebp-28h]
  int v6; // [esp+14h] [ebp-24h]
  int v7; // [esp+18h] [ebp-20h]
  int v8; // [esp+1Ch] [ebp-1Ch]
  unsigned int v9; // [esp+20h] [ebp-18h]
  char *v10; // [esp+24h] [ebp-14h]
  int v11; // [esp+28h] [ebp-10h]
  unsigned int v12; // [esp+2Ch] [ebp-Ch]

  v6 = 0;
  v9 = sub_8054C8F(0);
  v10 = (char *)dword_80719A8 + 12 * v9 - 12;
  v11 = *(_DWORD *)dword_8071850;
  v7 = sub_8054294(v11);
  v8 = **((_DWORD **)v10 + 2);
  v4 = 0;
  sub_8053953(v11);
  for ( i = 1; i < dword_8071848; ++i )
  {
    v12 = i % v9;
    v0 = &loc_8054714;
    if ( i % v9 )
      v0 = &loc_805473E;
    dword_80711DC = (int)v0;
    sub_8064D9E();
    putchar_unlocked(10);
    v6 = 0;
    dword_8071268 = (int)&loc_8054760;
    sub_8064A3C(v2, v1);
    sub_80548CF(v6 + v7, v8 + v6);
    v6 += v8;
    v11 = *((_DWORD *)dword_8071850 + i);
    v4 = v6;
    sub_8053953(v11);
    v7 = sub_8054294(v11);
    v8 = *(_DWORD *)(4 * v12 + *((_DWORD *)v10 + 2));
  }
  return putchar_unlocked(10);
}
// 8053953: using guessed type _DWORD __cdecl sub_8053953(_DWORD);
// 8064A3C: using guessed type int __fastcall sub_8064A3C(_DWORD, _DWORD);
// 8064D9E: using guessed type int sub_8064D9E(void);
// 80711DC: using guessed type int dword_80711DC;
// 8071268: using guessed type int dword_8071268;
// 8071848: using guessed type int dword_8071848;

//----- (080547D5) --------------------------------------------------------
int __cdecl sub_80547D5(char a1)
{
  int v1; // eax
  int v3; // [esp+0h] [ebp-38h]
  int v4; // [esp+4h] [ebp-34h]
  int v5; // [esp+8h] [ebp-30h]
  _DWORD v6[4]; // [esp+Ch] [ebp-2Ch]
  char v7; // [esp+Ch] [ebp-2Ch]
  int v8; // [esp+10h] [ebp-28h]
  int v9; // [esp+14h] [ebp-24h]
  int v10; // [esp+18h] [ebp-20h]
  int v11; // [esp+1Ch] [ebp-1Ch]
  char v12; // [esp+1Fh] [ebp-19h]
  unsigned int v13; // [esp+20h] [ebp-18h]
  unsigned int v14; // [esp+24h] [ebp-14h]
  int v15; // [esp+28h] [ebp-10h]
  int v16; // [esp+28h] [ebp-10h]
  int v17; // [esp+2Ch] [ebp-Ch]
  int v18; // [esp+2Ch] [ebp-Ch]
  int v19; // [esp+30h] [ebp-8h]
  int v20; // [esp+34h] [ebp-4h]
  int savedregs; // [esp+38h] [ebp+0h]

  LOBYTE(v6[0]) = a1;
  dword_8071204 = (int)&loc_80548B3;
  sub_8064CB8(v3, v4, v5, v6[0], v8, v9, v10, v11, 0, 0, v15, v17, v19, v20, savedregs);
  do
  {
    v16 = *((_DWORD *)dword_8071850 + v13);
    if ( dword_80718F8 )
      v1 = sub_8054294(v16);
    else
      v1 = 0;
    v18 = v1;
    if ( v13 )
    {
      if ( dword_80718F8 && (v14 + v1 + 2 >= dword_80718F8 || -3 - v1 < v14) )
      {
        v14 = 0;
        v12 = 10;
      }
      else
      {
        v14 += 2;
        v12 = 32;
      }
      putchar_unlocked(v7);
      putchar_unlocked(v12);
    }
    sub_8053953(v16);
    v14 += v18;
    ++v13;
  }
  while ( v13 < dword_8071848 );
  return putchar_unlocked(10);
}
// 8053953: using guessed type _DWORD __cdecl sub_8053953(_DWORD);
// 8064CB8: using guessed type int __stdcall sub_8064CB8(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8071204: using guessed type int dword_8071204;
// 8071848: using guessed type int dword_8071848;
// 80718F8: using guessed type int dword_80718F8;

//----- (080548CF) --------------------------------------------------------
unsigned int __cdecl sub_80548CF(unsigned int a1, unsigned int a2)
{
  unsigned int result; // eax

  while ( 1 )
  {
    result = a1;
    if ( a1 >= a2 )
      break;
    if ( dword_80718F0 && a2 / dword_80718F0 > (a1 + 1) / dword_80718F0 )
    {
      putchar_unlocked(9);
      a1 += dword_80718F0 - a1 % dword_80718F0;
    }
    else
    {
      putchar_unlocked(32);
      ++a1;
    }
  }
  return result;
}
// 80718F0: using guessed type int dword_80718F0;

//----- (08054974) --------------------------------------------------------
#error "80549EB: call analysis failed (funcsize=72)"

//----- (08054A3B) --------------------------------------------------------
unsigned int sub_8054A3B()
{
  unsigned int v0; // eax
  int v1; // ecx
  void *v2; // eax
  unsigned int result; // eax
  int v4; // [esp+0h] [ebp-38h]
  int v5; // [esp+4h] [ebp-34h]
  int v6; // [esp+8h] [ebp-30h]
  int v7; // [esp+Ch] [ebp-2Ch]
  unsigned int v8; // [esp+10h] [ebp-28h]
  int v9; // [esp+14h] [ebp-24h]
  unsigned int v10; // [esp+14h] [ebp-24h]
  int v11; // [esp+18h] [ebp-20h]
  int v12; // [esp+1Ch] [ebp-1Ch]
  unsigned int i; // [esp+1Ch] [ebp-1Ch]
  int v14; // [esp+20h] [ebp-18h]
  unsigned int v15; // [esp+20h] [ebp-18h]
  int v16; // [esp+24h] [ebp-14h]
  unsigned int v17; // [esp+24h] [ebp-14h]
  int v18; // [esp+28h] [ebp-10h]
  unsigned int v19; // [esp+28h] [ebp-10h]
  unsigned int v20; // [esp+2Ch] [ebp-Ch]

  v0 = dword_80719AC;
  if ( dword_8071848 <= (unsigned int)dword_80719AC )
    v0 = dword_8071848;
  v14 = v0;
  if ( dword_8072854 < v0 )
  {
    if ( (unsigned int)dword_80719AC >> 1 <= v0 )
    {
      dword_80719A8 = sub_80612AA(dword_80719A8, dword_80719AC, 12);
      v10 = dword_80719AC;
    }
    else
    {
      dword_80719A8 = sub_80612AA(dword_80719A8, v0, 24);
      v10 = 2 * v14;
    }
    v17 = v10 - dword_8072854;
    v19 = dword_8072854 + v10 + 1;
    v20 = (v10 - dword_8072854) * v19;
    if ( v19 >= v10 )
    {
      v2 = &loc_8054B40;
      if ( v20 / v17 == v19 )
        v2 = &loc_8054B45;
      dword_8071268 = (int)v2;
      sub_8064A3C(v1, v20 % v17);
    }
    sub_8061564();
  }
  dword_8071218 = (int)&loc_8054C81;
  sub_8064C2F(v4, v5, v6, v7, 0, v9, v11, v12, v0, v16, v18);
  do
  {
    *((_BYTE *)dword_80719A8 + 12 * v8) = 1;
    *((_DWORD *)dword_80719A8 + 3 * v8 + 1) = 3 * (v8 + 1);
    for ( i = 0; i <= v8; ++i )
      *(_DWORD *)(4 * i + *((_DWORD *)dword_80719A8 + 3 * v8 + 2)) = 3;
    result = ++v8;
  }
  while ( v8 < v15 );
  return result;
}
// 8064A3C: using guessed type int __fastcall sub_8064A3C(_DWORD, _DWORD);
// 8064C2F: using guessed type int __stdcall sub_8064C2F(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8071218: using guessed type int dword_8071218;
// 8071268: using guessed type int dword_8071268;
// 8071848: using guessed type int dword_8071848;
// 8072854: using guessed type int dword_8072854;

//----- (08054C8F) --------------------------------------------------------
unsigned int __cdecl sub_8054C8F(char a1)
{
  int v1; // eax
  unsigned int v2; // eax
  signed int v3; // eax
  char v5; // [esp+Ch] [ebp-3Ch]
  unsigned int i; // [esp+10h] [ebp-38h]
  unsigned int j; // [esp+14h] [ebp-34h]
  unsigned int v8; // [esp+18h] [ebp-30h]
  unsigned int v9; // [esp+1Ch] [ebp-2Ch]
  int v10; // [esp+20h] [ebp-28h]
  int v11; // [esp+24h] [ebp-24h]
  unsigned int v12; // [esp+28h] [ebp-20h]
  int v13; // [esp+2Ch] [ebp-1Ch]

  v5 = a1;
  v1 = dword_80719AC;
  if ( dword_8071848 <= (unsigned int)dword_80719AC )
    v1 = dword_8071848;
  v9 = v1;
  sub_8054A3B();
  for ( i = 0; i < dword_8071848; ++i )
  {
    v10 = *((_DWORD *)dword_8071850 + i);
    v11 = sub_8054294(v10);
    v8 = 0;
    dword_80711DC = (int)&loc_8054EA1;
    sub_8064D9E();
    do
    {
      if ( *((_BYTE *)dword_80719A8 + 12 * v8) )
      {
        v2 = v5 ? i / ((dword_8071848 + v8) / (v8 + 1)) : i % (v8 + 1);
        v12 = v2;
        v3 = v2 == v8 ? 0 : 2;
        v13 = v11 + v3;
        if ( *(_DWORD *)(4 * v12 + *((_DWORD *)dword_80719A8 + 3 * v8 + 2)) < (unsigned int)(v11 + v3) )
        {
          *((_DWORD *)dword_80719A8 + 3 * v8 + 1) += v13
                                                   - *(_DWORD *)(4 * v12 + *((_DWORD *)dword_80719A8 + 3 * v8 + 2));
          *(_DWORD *)(*((_DWORD *)dword_80719A8 + 3 * v8 + 2) + 4 * v12) = v13;
          *((_BYTE *)dword_80719A8 + 12 * v8) = *((_DWORD *)dword_80719A8 + 3 * v8 + 1) < (unsigned int)dword_80718F8;
        }
      }
      ++v8;
    }
    while ( v8 < v9 );
  }
  for ( j = v9; j > 1 && !*((_BYTE *)dword_80719A8 + 12 * j - 12); --j )
    ;
  return j;
}
// 8064D9E: using guessed type int sub_8064D9E(void);
// 80711DC: using guessed type int dword_80711DC;
// 8071848: using guessed type int dword_8071848;
// 80718F8: using guessed type int dword_80718F8;

//----- (08054F0C) --------------------------------------------------------
#error "805528C: call analysis failed (funcsize=199)"

//----- (080552AD) --------------------------------------------------------
#error "8055410: call analysis failed (funcsize=109)"

//----- (08055420) --------------------------------------------------------
void __noreturn sub_8055420()
{
  sub_8054F0C(1);
}

//----- (08055434) --------------------------------------------------------
#error "80554AE: call analysis failed (funcsize=109)"

//----- (0805559F) --------------------------------------------------------
void __cdecl sub_805559F(int a1, int a2, int a3)
{
  int v3; // ebx
  int v4; // eax
  int v5; // [esp+4h] [ebp-34h]
  int v6; // [esp+8h] [ebp-30h]
  int v7; // [esp+Ch] [ebp-2Ch]
  int v8; // [esp+10h] [ebp-28h]
  char *format; // [esp+2Ch] [ebp-Ch]

  if ( a3 == -1 )
  {
    gettext("invalid argument %s for %s");
    dword_8071254 = (int)&loc_80555DB;
    sub_8064AB4();
  }
  format = gettext("ambiguous argument %s for %s");
  v5 = a1;
  v3 = sub_80603C6(1);
  v6 = a2;
  v4 = sub_805FE52(0, 8);
  v8 = v3;
  v7 = v4;
  error(0, 0, format, v4, v3);
}
// 8071254: using guessed type int dword_8071254;

//----- (08055637) --------------------------------------------------------
#error "8055725: call analysis failed (funcsize=97)"

//----- (08055799) --------------------------------------------------------
int __usercall sub_8055799@<eax>(int a1@<ebx>, int a2, char *s, int a4, int a5, size_t n)
{
  int v7; // [esp+0h] [ebp-28h]
  int v8; // [esp+4h] [ebp-24h]
  int v9; // [esp+8h] [ebp-20h]
  int v10; // [esp+Ch] [ebp-1Ch]
  int v11; // [esp+10h] [ebp-18h]
  int v12; // [esp+14h] [ebp-14h]
  int v13; // [esp+18h] [ebp-10h]
  void (*v14)(void); // [esp+1Ch] [ebp-Ch]

  v10 = n;
  v9 = a5;
  v8 = a4;
  *(&v7 - 3) = sub_8055434(a1, s);
  if ( *(&v7 - 3) >= 0 )
    return *(&v7 - 3);
  sub_805559F(*(&v7 - 3), v10, *(&v7 - 3));
  v9 = v13;
  v8 = v12;
  v7 = v11;
  sub_8055637();
  v14();
  return -1;
}

//----- (080558B6) --------------------------------------------------------
int __cdecl sub_80558B6(signed int a1)
{
  void *v1; // eax

  if ( a1 > 90 )
  {
    if ( (unsigned int)(a1 - 97) <= 0x19 )
    {
LABEL_7:
      dword_8071254 = (int)&loc_8055912;
      sub_8064AB4();
      return 0;
    }
  }
  else
  {
    v1 = &loc_80558DF;
    if ( a1 >= 65 )
      v1 = &loc_80558F1;
    dword_80711DC = (int)v1;
    if ( (unsigned int)(sub_8064D9E() - 48) <= 9 )
      goto LABEL_7;
  }
  return 0;
}
// 8064D9E: using guessed type int sub_8064D9E(void);
// 80711DC: using guessed type int dword_80711DC;
// 8071254: using guessed type int dword_8071254;

//----- (08055918) --------------------------------------------------------
_BOOL4 __cdecl sub_8055918(signed int a1)
{
  return a1 >= 65 && (a1 <= 90 || (unsigned int)(a1 - 97) <= 0x19);
}

//----- (080559C7) --------------------------------------------------------
_BOOL4 __cdecl sub_80559C7(int a1)
{
  return (unsigned int)(a1 - 48) <= 9;
}

//----- (08055B3A) --------------------------------------------------------
int __cdecl sub_8055B3A(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 65) > 0x19 )
    result = a1;
  else
    result = a1 + 32;
  return result;
}

//----- (08055B82) --------------------------------------------------------
int __cdecl sub_8055B82(int a1, char *s, int a3)
{
  if ( !*(_DWORD *)a1 )
  {
    *(_DWORD *)a1 = sub_8057F1A(7, 0, sub_8058E15, sub_8058F8C, sub_805903C);
    if ( !*(_DWORD *)a1 )
      sub_8061564();
  }
  if ( !(unsigned __int8)sub_8056AA9(*(_DWORD *)a1, s, a3) )
    sub_80569D9(*(_DWORD *)a1, s, a3);
  return 1;
}
// 8056AA9: using guessed type _DWORD __cdecl sub_8056AA9(_DWORD, _DWORD, _DWORD);
// 8057F1A: using guessed type _DWORD __cdecl sub_8057F1A(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (08055C30) --------------------------------------------------------
int __cdecl sub_8055C30(void *src, int a2)
{
  int v2; // edx
  int v3; // ecx
  int result; // eax
  void *v5; // eax
  int v6; // [esp+0h] [ebp-C8h]
  int v7; // [esp+4h] [ebp-C4h]
  int v8; // [esp+8h] [ebp-C0h]
  int v9; // [esp+Ch] [ebp-BCh]
  int v10; // [esp+10h] [ebp-B8h]
  __int64 v11; // [esp+14h] [ebp-B4h]
  char *s; // [esp+1Ch] [ebp-ACh]
  void *dest; // [esp+20h] [ebp-A8h]
  void *v14; // [esp+28h] [ebp-A0h]
  char *v15; // [esp+2Ch] [ebp-9Ch]
  int v16; // [esp+30h] [ebp-98h]

  HIBYTE(v11) = 0;
  *(_DWORD *)((char *)&v11 + 3) = (a2 & 4) != 0;
  if ( a2 & 3 & ((a2 & 3) - 1) )
  {
    *__errno_location() = 22;
    dword_80711F0 = (int)&locret_8056674;
    sub_8064D28(v3, v2);
  }
  if ( src )
  {
    v5 = &loc_8055CFD;
    if ( *(_BYTE *)src )
      v5 = &loc_8055D12;
    dword_8071240 = (int)v5;
    sub_8064B22(v6, v7, v8, v9, v10, v11, HIDWORD(v11), s, dest, 0, v14, v15, v16, 0);
    *__errno_location() = 2;
    result = 0;
  }
  else
  {
    *__errno_location() = 22;
    result = 0;
  }
  return result;
}
// 8064B22: using guessed type int __stdcall sub_8064B22(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80711F0: using guessed type int dword_80711F0;
// 8071240: using guessed type int dword_8071240;

//----- (0805669A) --------------------------------------------------------
void __noreturn sub_805669A()
{
  void *v0; // eax
  int v1; // ebx
  int *v2; // eax
  bool v3; // zf
  int (*v4)(); // eax
  int v5; // [esp+0h] [ebp-38h]
  int v6; // [esp+4h] [ebp-34h]
  int v7; // [esp+8h] [ebp-30h]
  int v8; // [esp+Ch] [ebp-2Ch]
  int v9; // [esp+10h] [ebp-28h]
  int v10; // [esp+14h] [ebp-24h]
  int v11; // [esp+18h] [ebp-20h]
  int v12; // [esp+1Ch] [ebp-1Ch]
  int v13; // [esp+20h] [ebp-18h]
  int v14; // [esp+24h] [ebp-14h]
  int v15; // [esp+28h] [ebp-10h]
  int v16; // [esp+2Ch] [ebp-Ch]
  char *v17; // [esp+2Ch] [ebp-Ch]
  int v18; // [esp+30h] [ebp-8h]
  int v19; // [esp+34h] [ebp-4h]

  if ( sub_8063607(stdout) && (byte_807285C != 1 || *__errno_location() != 32) )
  {
    v17 = gettext("write error");
    v0 = &loc_8056705;
    if ( !dword_8072858 )
      v0 = &loc_8056740;
    dword_8071254 = (int)v0;
    sub_8064AB4();
    v1 = sub_806007E(dword_8072858, v6);
    v2 = __errno_location();
    error(0, *v2, "%s: %s", v1, v17);
    _exit(status);
  }
  v3 = sub_8063607(stderr) == 0;
  v4 = (int (*)())&loc_805679D;
  if ( v3 )
    v4 = sub_80567AA;
  dword_8071240 = (int)v4;
  sub_8064B22(v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v18, v19);
  _exit(status);
}
// 80567AA: using guessed type int sub_80567AA();
// 8064B22: using guessed type int __stdcall sub_8064B22(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8071240: using guessed type int dword_8071240;
// 8071254: using guessed type int dword_8071254;
// 8072858: using guessed type int dword_8072858;
// 807285C: using guessed type char byte_807285C;

//----- (080567AA) --------------------------------------------------------
#error "80567AD: positive sp value has been found (funcsize=0)"

//----- (080567B0) --------------------------------------------------------
unsigned __int8 *__usercall sub_80567B0@<eax>(int a1@<edx>, int a2@<ecx>, unsigned __int8 *a3@<ebx>, int a4)
{
  unsigned __int8 *i; // [esp+18h] [ebp-10h]
  _BOOL4 v6; // [esp+1Ch] [ebp-Ch]

  v6 = *(_BYTE *)a4 == 47;
  for ( i = &sub_80568C9(a1, a2, a3, a4)[-a4]; v6 < (unsigned int)i && i[a4 - 1] == 47; --i )
    ;
  return i;
}

//----- (08056825) --------------------------------------------------------
int __usercall sub_8056825@<eax>(int a1@<edx>, int a2@<ecx>, unsigned __int8 *a3@<ebx>, void *src)
{
  int v5; // eax
  int v6; // [esp+0h] [ebp-28h]
  size_t v7; // [esp+8h] [ebp-20h]
  bool v8; // [esp+17h] [ebp-11h]
  size_t n; // [esp+18h] [ebp-10h]
  void *dest; // [esp+1Ch] [ebp-Ch]

  n = (size_t)sub_80567B0(a1, a2, a3, (int)src);
  v8 = n == 0;
  dest = malloc((n == 0) + n + 1);
  if ( !dest )
    return 0;
  v7 = n;
  memcpy((void *)*(&v6 - 3), (const void *)n, n);
  if ( *((_BYTE *)&v6 - 17) )
  {
    v5 = *(&v6 - 4);
    *(&v6 - 4) = v5 + 1;
    *(_BYTE *)(*(&v6 - 3) + v5) = 46;
  }
  *(_BYTE *)(*(&v6 - 3) + *(&v6 - 4)) = 0;
  return *(&v6 - 3);
}

//----- (080568C9) --------------------------------------------------------
unsigned __int8 *__usercall sub_80568C9@<eax>(int a1@<edx>, int a2@<ecx>, unsigned __int8 *a3@<ebx>, int a4)
{
  int v4; // edx
  int v5; // ecx
  bool v6; // zf
  void *v7; // eax
  unsigned __int8 *v8; // ebx
  int v9; // edx
  int v10; // ecx
  void *v11; // eax
  unsigned __int8 *v13; // [esp-8h] [ebp-18h]
  unsigned __int8 *i; // [esp-4h] [ebp-14h]
  int v15; // [esp+0h] [ebp-10h]
  char v16; // [esp+7h] [ebp-9h]
  int v17; // [esp+8h] [ebp-8h]

  v17 = a4;
  v16 = 0;
  dword_807127C = (int)&loc_80568F4;
  sub_80649CA(a2, a1);
  v6 = *++v13 == 47;
  i = (unsigned __int8 *)*v13;
  v13 = a3;
  v7 = &loc_8056917;
  if ( v6 )
    v7 = &loc_80568F0;
  dword_8071268 = (int)v7;
  v8 = v13;
  sub_8064A3C(v5, v4);
  for ( i = v13; *i; ++i )
  {
    if ( *i == 47 )
    {
      *((_BYTE *)&v15 - 9) = 1;
    }
    else
    {
      v6 = *((_BYTE *)&v15 - 9) == 0;
      i = (unsigned __int8 *)*i;
      v13 = v8;
      v11 = &loc_8056970;
      if ( v6 )
        v11 = &loc_805697A;
      dword_807127C = (int)v11;
      v8 = v13;
      sub_80649CA(v10, v9);
      v13 = i;
      *((_BYTE *)&v15 - 9) = 0;
    }
  }
  return v13;
}
// 80568C9: could not find valid save-restore pair for ebx
// 80649CA: using guessed type int __fastcall sub_80649CA(_DWORD, _DWORD);
// 8064A3C: using guessed type int __fastcall sub_8064A3C(_DWORD, _DWORD);
// 8071268: using guessed type int dword_8071268;
// 807127C: using guessed type int dword_807127C;

//----- (0805698D) --------------------------------------------------------
size_t __cdecl sub_805698D(char *s)
{
  size_t i; // [esp+18h] [ebp-10h]

  for ( i = strlen(s); i > 1 && s[i - 1] == 47; --i )
    ;
  return i;
}

//----- (080569CF) --------------------------------------------------------
int sub_80569CF()
{
  return 0;
}

//----- (080569D9) --------------------------------------------------------
#error "8056A35: call analysis failed (funcsize=53)"

//----- (08056AA9) --------------------------------------------------------
#error "8056AEA: call analysis failed (funcsize=25)"

//----- (08056B1D) --------------------------------------------------------
signed int __cdecl sub_8056B1D(__int16 a1)
{
  switch ( a1 & 0xF000 )
  {
    case 32768:
      return 45;
    case 16384:
      return 100;
    case 24576:
      return 98;
    case 8192:
      return 99;
    case 40960:
      return 108;
    case 4096:
      return 112;
    case 49152:
      return 115;
  }
  return 63;
}

//----- (08056BE9) --------------------------------------------------------
int __cdecl sub_8056BE9(__int16 a1, _BYTE *a2)
{
  int v2; // ecx
  char v3; // al
  char v4; // al
  char v5; // al
  char v6; // al
  char v7; // al
  void *v8; // eax
  char *v9; // edx
  int v10; // ecx
  char v11; // al
  char v12; // al
  _BYTE *v13; // edx
  char v14; // al
  int result; // eax

  *a2 = sub_8056B1D(a1);
  if ( a1 & 0x100 )
    v3 = 114;
  else
    v3 = 45;
  a2[1] = v3;
  if ( a1 & 0x80 )
    v4 = 119;
  else
    v4 = 45;
  a2[2] = v4;
  if ( a1 & 0x800 )
  {
    if ( a1 & 0x40 )
      v5 = 115;
    else
      v5 = 83;
  }
  else if ( a1 & 0x40 )
  {
    v5 = 120;
  }
  else
  {
    v5 = 45;
  }
  a2[3] = v5;
  if ( a1 & 0x20 )
    v6 = 114;
  else
    v6 = 45;
  a2[4] = v6;
  if ( a1 & 0x10 )
    v7 = 119;
  else
    v7 = 45;
  a2[5] = v7;
  v8 = &loc_8056CEC;
  if ( !(a1 & 0x400) )
    v8 = &loc_8056D04;
  dword_807127C = (int)v8;
  sub_80649CA(v2, a2 + 6);
  if ( a1 & 8 )
    v11 = 115;
  else
    v11 = 83;
  *v9 = v11;
  if ( a1 & 4 )
    v12 = 114;
  else
    v12 = 45;
  a2[7] = v12;
  v13 = a2 + 8;
  if ( a1 & 2 )
  {
    dword_807127C = (int)&loc_8056D6B;
    sub_80649CA(v10, v13);
  }
  *v13 = 45;
  if ( a1 & 0x200 )
  {
    if ( a1 & 1 )
      v14 = 116;
    else
      v14 = 84;
  }
  else if ( a1 & 1 )
  {
    v14 = 120;
  }
  else
  {
    v14 = 45;
  }
  a2[9] = v14;
  a2[10] = 32;
  result = (int)(a2 + 11);
  a2[11] = 0;
  return result;
}
// 80649CA: using guessed type int __fastcall sub_80649CA(_DWORD, _DWORD);
// 807127C: using guessed type int dword_807127C;

//----- (08056DC3) --------------------------------------------------------
int __cdecl sub_8056DC3(int a1, _BYTE *a2)
{
  return sub_8056BE9(*(_DWORD *)(a1 + 16), a2);
}

//----- (08056DF0) --------------------------------------------------------
int __usercall sub_8056DF0@<eax>(int a1@<edx>, int a2@<ecx>, unsigned __int8 *a3@<ebx>, int a4, _BYTE *a5)
{
  int v6; // [esp+1Ch] [ebp-Ch]

  v6 = sub_8056E50(a1, a2, a3, a4, a5);
  if ( !v6 )
    sub_8061564();
  return v6;
}

//----- (08056E34) --------------------------------------------------------
_BYTE *__cdecl sub_8056E34(_BYTE *a1)
{
  while ( *a1 == 47 )
    ++a1;
  return a1;
}

//----- (08056E50) --------------------------------------------------------
int __usercall sub_8056E50@<eax>(int a1@<edx>, int a2@<ecx>, unsigned __int8 *a3@<ebx>, int a4, _BYTE *a5)
{
  _BOOL4 v5; // eax
  const char *v6; // eax
  size_t v7; // eax
  void *v8; // eax
  bool v9; // zf
  void *v10; // eax
  int v12; // [esp+0h] [ebp-38h]
  int v13; // [esp+4h] [ebp-34h]
  int v14; // [esp+8h] [ebp-30h]
  int v15; // [esp+Ch] [ebp-2Ch]
  char *v16; // [esp+10h] [ebp-28h]
  size_t v17; // [esp+14h] [ebp-24h]
  int v18; // [esp+18h] [ebp-20h]
  _BOOL4 v19; // [esp+1Ch] [ebp-1Ch]
  char *s; // [esp+20h] [ebp-18h]
  size_t v21; // [esp+24h] [ebp-14h]
  void *v22; // [esp+28h] [ebp-10h]

  v16 = (char *)sub_80568C9(a1, a2, a3, a4);
  v17 = sub_805698D(v16);
  v18 = (int)&v16[v17 - a4];
  v5 = v17 && v16[v17 - 1] != 47;
  v19 = v5;
  v6 = sub_8056E34(a5);
  s = (char *)v6;
  v7 = strlen(v6);
  v21 = v7;
  v8 = malloc(v19 + v18 + v7 + 1);
  v22 = v8;
  v9 = v8 == 0;
  v10 = &loc_8056F17;
  if ( !v9 )
    v10 = &loc_8056F21;
  dword_8071218 = (int)v10;
  sub_8064C2F(v12, v13, v14, v15, v16, v17, v18, v19, s, v21, v22);
  return 0;
}
// 8064C2F: using guessed type int __stdcall sub_8064C2F(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8071218: using guessed type int dword_8071218;

//----- (08056FAF) --------------------------------------------------------
#error "8057043: call analysis failed (funcsize=74)"

//----- (080570AF) --------------------------------------------------------
int __cdecl sub_80570AF(unsigned __int8 a1)
{
  if ( (unsigned __int8)sub_80559C7(a1) )
    return 0;
  if ( (unsigned __int8)sub_8055918(a1) )
    return a1;
  if ( a1 == 126 )
    return -1;
  return a1 + 256;
}

//----- (08057104) --------------------------------------------------------
#error "8057193: call analysis failed (funcsize=185)"

//----- (08057350) --------------------------------------------------------
int __cdecl sub_8057350(char *s1, char *s2)
{
  bool v3; // zf
  void *v4; // eax

  if ( !strcmp(s1, s2) )
    return 0;
  if ( !*s1 )
    return -1;
  if ( !*s2 )
    return 1;
  if ( !strcmp(".", s1) )
    return -1;
  v3 = strcmp(".", s2) == 0;
  v4 = &loc_80573F4;
  if ( !v3 )
    v4 = &loc_80573FE;
  dword_8071254 = (int)v4;
  sub_8064AB4();
  return 1;
}
// 8071254: using guessed type int dword_8071254;

//----- (080575CA) --------------------------------------------------------
struct timespec *__cdecl sub_80575CA(struct timespec *tp)
{
  struct timespec *result; // eax
  struct timeval tv; // [esp+18h] [ebp-10h]

  result = (struct timespec *)clock_gettime(0, tp);
  if ( result )
  {
    gettimeofday(&tv, 0);
    tp->tv_sec = tv.tv_sec;
    result = tp;
    tp->tv_nsec = 1000 * tv.tv_usec;
  }
  return result;
}

//----- (08057619) --------------------------------------------------------
#error "8057681: call analysis failed (funcsize=46)"

//----- (080576B0) --------------------------------------------------------
int __cdecl sub_80576B0(int a1)
{
  return *(_DWORD *)(a1 + 8);
}

//----- (080576BB) --------------------------------------------------------
int __cdecl sub_80576BB(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (080576CA) --------------------------------------------------------
int __cdecl sub_80576CA(int a1)
{
  return *(_DWORD *)(a1 + 16);
}

//----- (080576F7) --------------------------------------------------------
#error "805771D: call analysis failed (funcsize=19)"

//----- (08057730) --------------------------------------------------------
#error "8057791: positive sp value has been found (funcsize=0)"

//----- (08057935) --------------------------------------------------------
int __cdecl sub_8057935(_DWORD *a1, int a2)
{
  int (__cdecl *v2)(int, int); // eax
  int v4; // [esp+4h] [ebp-24h]
  unsigned int v5; // [esp+1Ch] [ebp-Ch]

  v2 = (int (__cdecl *)(int, int))a1[6];
  v4 = a1[2];
  v5 = v2(a2, v4);
  if ( a1[2] <= v5 )
    abort();
  return 8 * v5 + *a1;
}

//----- (08057989) --------------------------------------------------------
#error "8057A0B: call analysis failed (funcsize=31)"

//----- (08057C59) --------------------------------------------------------
bool __cdecl sub_8057C59(unsigned int a1)
{
  int v1; // ST08_4
  unsigned int v3; // [esp+8h] [ebp-8h]
  unsigned int v4; // [esp+Ch] [ebp-4h]

  v3 = 3;
  v4 = 9;
  while ( v4 < a1 && a1 % v3 )
  {
    v1 = v3 + 1;
    v4 += 4 * v1;
    v3 = v1 + 1;
  }
  return a1 % v3 != 0;
}

//----- (08057CB4) --------------------------------------------------------
int __cdecl sub_8057CB4(unsigned int a1)
{
  int i; // [esp+Ch] [ebp+8h]

  if ( a1 <= 9 )
    a1 = 10;
  for ( i = a1 | 1; i != -1 && !sub_8057C59(i); i += 2 )
    ;
  return i;
}

//----- (08057D39) --------------------------------------------------------
unsigned int __cdecl sub_8057D39(int a1, unsigned int a2)
{
  return sub_8063463(a1, 3) % a2;
}

//----- (08057D64) --------------------------------------------------------
bool __cdecl sub_8057D64(int a1, int a2)
{
  return a1 == a2;
}

//----- (08057D72) --------------------------------------------------------
#error "8057D9E: call analysis failed (funcsize=20)"

//----- (08057E69) --------------------------------------------------------
unsigned int __cdecl sub_8057E69(unsigned int a1, int a2)
{
  unsigned int result; // eax
  float v3; // [esp+20h] [ebp-4h]
  unsigned int v4; // [esp+2Ch] [ebp+8h]

  if ( *(_BYTE *)(a2 + 16) != 1 )
  {
    v3 = (long double)a1 / *(float *)(a2 + 8);
    if ( v3 >= 4294967300.0 )
      return 0;
    a1 = (signed __int64)v3;
  }
  v4 = sub_8057CB4(a1);
  if ( v4 <= 0x1FFFFFFF )
    result = v4;
  else
    result = 0;
  return result;
}

//----- (08057F1A) --------------------------------------------------------
#error "8057F63: call analysis failed (funcsize=26)"

//----- (0805819B) --------------------------------------------------------
void __cdecl sub_805819B(void *a1)
{
  _DWORD *v1; // ST1C_4
  _DWORD *v2; // ST1C_4
  _DWORD *i; // [esp+14h] [ebp-14h]
  _DWORD *j; // [esp+14h] [ebp-14h]
  _DWORD *ptr; // [esp+18h] [ebp-10h]
  _DWORD *ptra; // [esp+18h] [ebp-10h]
  _DWORD *ptrb; // [esp+18h] [ebp-10h]

  if ( *((_DWORD *)a1 + 8) && *((_DWORD *)a1 + 4) )
  {
    for ( i = *(_DWORD **)a1; *((_DWORD *)a1 + 1) > (unsigned int)i; i += 2 )
    {
      if ( *i )
      {
        for ( ptr = i; ptr; ptr = (_DWORD *)ptr[1] )
          (*((void (__cdecl **)(_DWORD))a1 + 8))(*ptr);
      }
    }
  }
  for ( j = *(_DWORD **)a1; *((_DWORD *)a1 + 1) > (unsigned int)j; j += 2 )
  {
    for ( ptra = (_DWORD *)j[1]; ptra; ptra = v1 )
    {
      v1 = (_DWORD *)ptra[1];
      free(ptra);
    }
  }
  for ( ptrb = (_DWORD *)*((_DWORD *)a1 + 9); ptrb; ptrb = v2 )
  {
    v2 = (_DWORD *)ptrb[1];
    free(ptrb);
  }
  free(*(void **)a1);
  free(a1);
}

//----- (0805828B) --------------------------------------------------------
void *__cdecl sub_805828B(int a1)
{
  if ( *(_DWORD *)(a1 + 36) )
  {
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(*(_DWORD *)(a1 + 36) + 4);
    dword_8071254 = (int)&loc_80582DA;
    sub_8064AB4();
  }
  return malloc(8u);
}
// 8071254: using guessed type int dword_8071254;

//----- (080582DF) --------------------------------------------------------
int __cdecl sub_80582DF(int a1, _DWORD *a2)
{
  int result; // eax

  *a2 = 0;
  a2[1] = *(_DWORD *)(a1 + 36);
  result = a1;
  *(_DWORD *)(a1 + 36) = a2;
  return result;
}

//----- (08058312) --------------------------------------------------------
#error "8058337: call analysis failed (funcsize=19)"

//----- (0805834A) --------------------------------------------------------
#error "80584BB: positive sp value has been found (funcsize=113)"

//----- (080584BC) --------------------------------------------------------
signed int __cdecl sub_80584BC(int a1, int *a2, char a3)
{
  int *v3; // ebp
  _DWORD *v4; // eax
  int v5; // edx
  _DWORD *v7; // [esp+0h] [ebp-38h]
  int v8; // [esp+4h] [ebp-34h]
  _DWORD *v9; // [esp+8h] [ebp-30h]
  char v10; // [esp+Ch] [ebp-2Ch]
  int v11; // [esp+18h] [ebp-20h]
  int savedregs; // [esp+38h] [ebp+0h]

  v3 = &savedregs;
  v10 = a3;
  v11 = *a2;
  while ( *(_DWORD *)(v3[3] + 4) > (unsigned int)*(v3 - 8) )
  {
    if ( *(_DWORD *)*(v3 - 8) )
    {
      for ( *(v3 - 7) = *(_DWORD *)(*(v3 - 8) + 4); *(v3 - 7); *(v3 - 7) = *(v3 - 4) )
      {
        *(v3 - 6) = *(_DWORD *)*(v3 - 7);
        v8 = *(v3 - 6);
        v7 = (_DWORD *)v3[2];
        *(v3 - 5) = sub_8057935(v7, v8);
        *(v3 - 4) = *(_DWORD *)(*(v3 - 7) + 4);
        if ( *(_DWORD *)*(v3 - 5) )
        {
          *(_DWORD *)(*(v3 - 7) + 4) = *(_DWORD *)(*(v3 - 5) + 4);
          *(_DWORD *)(*(v3 - 5) + 4) = *(v3 - 7);
        }
        else
        {
          v4 = (_DWORD *)*(v3 - 5);
          v5 = *(v3 - 6);
          v3 = (int *)&v7;
          *v4 = v5;
          ++v9[3];
          sub_80582DF((int)v9, *(&v7 - 7));
        }
      }
      *(v3 - 6) = *(_DWORD *)*(v3 - 8);
      *(_DWORD *)(*(v3 - 8) + 4) = 0;
      v3 = (int *)&v7;
      if ( !*((_BYTE *)&v7 - 44) )
      {
        v8 = (int)*(&v7 - 6);
        *(&v7 - 5) = (_DWORD *)sub_8057935(v9, v8);
        if ( **(&v7 - 5) )
        {
          *(&v7 - 3) = sub_805828B((int)v9);
          if ( !*(&v7 - 3) )
            return 0;
          **(&v7 - 3) = *(&v7 - 6);
          v3 = (int *)&v7;
          *(_DWORD *)(*(v3 - 3) + 4) = *(_DWORD *)(*(v3 - 5) + 4);
          (*(&v7 - 5))[1] = *(&v7 - 3);
        }
        else
        {
          **(&v7 - 5) = *(&v7 - 6);
          ++v9[3];
        }
        **(&v7 - 8) = 0;
        --*(_DWORD *)(*(_DWORD *)&v10 + 12);
      }
    }
    *(v3 - 8) += 8;
  }
  return 1;
}

//----- (0805866D) --------------------------------------------------------
signed int __cdecl sub_805866D(int a1, unsigned int a2)
{
  void *v3; // eax
  int v4; // ecx
  void *v5; // edx
  void *v6; // eax
  size_t nmemb; // [esp+10h] [ebp-38h]
  char *v8; // [esp+14h] [ebp-34h]
  char v9; // [esp+18h] [ebp-30h]

  nmemb = sub_8057E69(a2, *(_DWORD *)(a1 + 20));
  if ( !nmemb )
  {
    dword_80711DC = (int)&locret_805887D;
    sub_8064D9E();
  }
  if ( *(_DWORD *)(a1 + 8) == nmemb )
    return 1;
  v8 = &v9;
  v3 = calloc(nmemb, 8u);
  v5 = v3;
  *(_DWORD *)v8 = v3;
  v6 = &loc_8058704;
  if ( *(_DWORD *)v8 )
    v6 = &loc_805870E;
  dword_8071268 = (int)v6;
  sub_8064A3C(v4, v5);
  return 0;
}
// 8064A3C: using guessed type int __fastcall sub_8064A3C(_DWORD, _DWORD);
// 8064D9E: using guessed type int sub_8064D9E(void);
// 80711DC: using guessed type int dword_80711DC;
// 8071268: using guessed type int dword_8071268;

//----- (0805887F) --------------------------------------------------------
void __fastcall __noreturn sub_805887F(int a1, int a2, int a3, int a4)
{
  int (__cdecl *v4)(int, int, int); // eax

  v4 = (int (__cdecl *)(int, int, int))&loc_80588A4;
  if ( a4 )
    v4 = sub_80588A9;
  dword_8071268 = (int)v4;
  sub_8064A3C(a1, a2);
  abort();
}
// 80588A9: using guessed type int __cdecl sub_80588A9(int, int, int);
// 8064A3C: using guessed type int __fastcall sub_8064A3C(_DWORD, _DWORD);
// 8071268: using guessed type int dword_8071268;

//----- (080588A9) --------------------------------------------------------
#error "80588C5: call analysis failed (funcsize=42)"

//----- (0805893B) --------------------------------------------------------
#error "8058B7B: positive sp value has been found (funcsize=173)"

//----- (08058B7C) --------------------------------------------------------
void __usercall __noreturn sub_8058B7C(int a1@<edx>, int a2@<ecx>, int a3, int a4)
{
  sub_805887F(a2, a1, a3, a4);
}

//----- (08058BCB) --------------------------------------------------------
#error "8058C7B: call analysis failed (funcsize=56)"

//----- (08058E15) --------------------------------------------------------
int __cdecl sub_8058E15(int a1, unsigned int a2)
{
  unsigned __int64 v2; // ST00_8

  LODWORD(v2) = *(_DWORD *)(a1 + 4) ^ sub_80636E3(*(_BYTE **)a1, a2);
  HIDWORD(v2) = *(_DWORD *)(a1 + 8);
  return sub_80645C1(v2, a2, 0);
}

//----- (08058F8C) --------------------------------------------------------
int __cdecl sub_8058F8C(int a1, int a2)
{
  const char *v2; // eax
  bool v3; // al
  int v5; // [esp+0h] [ebp-28h]
  const char *v6; // [esp+4h] [ebp-24h]
  int v7; // [esp+18h] [ebp-10h]

  v7 = a1;
  *(&v5 - 3) = a2;
  v3 = 0;
  if ( __PAIR__(*(_DWORD *)(*(&v5 - 4) + 4), *(_DWORD *)(*(&v5 - 3) + 8)) == __PAIR__(
                                                                               *(_DWORD *)(*(&v5 - 3) + 4),
                                                                               *(_DWORD *)(*(&v5 - 4) + 8))
    && __PAIR__(*(_DWORD *)(*(&v5 - 4) + 12), *(_DWORD *)(*(&v5 - 3) + 16)) == __PAIR__(
                                                                                 *(_DWORD *)(*(&v5 - 3) + 12),
                                                                                 *(_DWORD *)(*(&v5 - 4) + 16)) )
  {
    v2 = *(const char **)*(&v5 - 4);
    v6 = *(const char **)*(&v5 - 3);
    if ( !strcmp(v2, v6) )
      v3 = 1;
  }
  return v3;
}

//----- (0805903C) --------------------------------------------------------
void __cdecl sub_805903C(void **a1)
{
  free(*a1);
  free(a1);
}

//----- (08059066) --------------------------------------------------------
long double __cdecl sub_8059066(int a1, long double a2)
{
  unsigned __int64 v2; // rax
  _BOOL4 v3; // eax
  unsigned __int64 v5; // [esp+28h] [ebp-10h]

  if ( a1 != 1 && a2 < 1.8446744073709551615e19 )
  {
    if ( a2 >= 9.223372036854775808e18 )
    {
      HIDWORD(v2) = ((unsigned __int64)(signed __int64)(a2 - 9.223372036854775808e18) >> 32) ^ 0x80000000;
      LODWORD(v2) = (signed __int64)(a2 - 9.223372036854775808e18);
      v5 = v2;
    }
    else
    {
      v5 = (signed __int64)a2;
    }
    v3 = !a1 && a2 != (long double)v5;
    a2 = (long double)(v3 + v5);
  }
  return a2;
}

//----- (080591B9) --------------------------------------------------------
void *__cdecl sub_80591B9(int a1, size_t n, int a3, int a4)
{
  int v4; // ecx
  int v5; // edx
  void *i; // ebx
  int v7; // eax
  void *v8; // ebx
  const char *v10; // [esp+0h] [ebp-68h]
  size_t v11; // [esp+8h] [ebp-60h]
  size_t v12; // [esp+Ch] [ebp-5Ch]
  char *s; // [esp+14h] [ebp-54h]
  int v14; // [esp+18h] [ebp-50h]
  void *src; // [esp+1Ch] [ebp-4Ch]
  size_t v16; // [esp+24h] [ebp-44h]
  unsigned int v17; // [esp+5Ch] [ebp-Ch]

  src = (void *)a1;
  v14 = a3;
  s = (char *)a4;
  v17 = __readgsdword(0x14u);
  v16 = -1;
  v10 = *(&v10 - 21);
  *(&v10 - 15) = (const char *)strlen(v10);
  *(&v10 - 16) = (const char *)v12;
  v11 = v12;
  memcpy((char *)&v10 - 53, *(&v10 - 19), v12);
  v5 = (int)*(&v10 - 19);
  for ( i = (void *)(v5 + v12); ; memcpy(i, *(&v10 - 21), (size_t)*(&v10 - 15)) )
  {
    *((_BYTE *)&v10 - 69) = **(&v10 - 20);
    if ( *((_BYTE *)&v10 - 69) )
    {
      if ( *((_BYTE *)&v10 - 69) <= 0x7Eu )
      {
        v7 = *((unsigned __int8 *)&v10 - 69);
        dword_807127C = (int)&loc_805925D;
        sub_80649CA(v4, v5);
      }
      *(&v10 - 17) = *(&v10 - 16);
      ++*(&v10 - 20);
    }
    if ( *(&v10 - 16) < *(&v10 - 17) )
      *(&v10 - 17) = *(&v10 - 16);
    v8 = (void *)((_BYTE *)i - *(&v10 - 17));
    *(&v10 - 16) -= (signed int)*(&v10 - 17);
    memcpy(v8, (char *)&v10 + (_DWORD)*(&v10 - 16) - 53, (size_t)*(&v10 - 17));
    if ( !*(&v10 - 16) )
      break;
    i = (void *)((_BYTE *)v8 - *(&v10 - 15));
  }
  return v8;
}
// 80649CA: using guessed type int __fastcall sub_80649CA(_DWORD, _DWORD);
// 807127C: using guessed type int dword_807127C;

//----- (0805930F) --------------------------------------------------------
void *__cdecl sub_805930F(int a1, int a2, char *s, int a4, int a5, int a6, int a7, int a8)
{
  signed int v8; // eax
  __int64 v9; // rax
  int v10; // ecx
  __int64 v11; // rax
  int v12; // ecx
  unsigned __int64 v13; // rax
  __int64 v14; // rax
  unsigned __int64 v15; // rax
  int v16; // eax
  int v17; // edx
  int v18; // ebx
  unsigned __int64 v19; // rax
  __int64 v20; // rax
  unsigned __int64 v21; // rax
  signed int v22; // eax
  int v23; // eax
  unsigned __int64 v24; // rax
  signed int v25; // eax
  char v26; // al
  void *v27; // eax
  char v28; // al
  char v29; // al
  void *v30; // eax
  char v31; // al
  bool v32; // zf
  void *v33; // eax
  unsigned __int64 v34; // rax
  char *v35; // eax
  void *v36; // eax
  char *v37; // eax
  char v38; // dl
  char *v39; // eax
  char *v40; // eax
  char v42[12]; // [esp+0h] [ebp-108h]
  int v43; // [esp+Ch] [ebp-FCh]
  int v44; // [esp+10h] [ebp-F8h]
  int v45; // [esp+14h] [ebp-F4h]
  int v46; // [esp+18h] [ebp-F0h]
  int v47; // [esp+1Ch] [ebp-ECh]
  __int64 v48; // [esp+20h] [ebp-E8h]
  unsigned __int64 v49; // [esp+28h] [ebp-E0h]
  unsigned __int64 v50; // [esp+30h] [ebp-D8h]
  unsigned __int64 v51; // [esp+38h] [ebp-D0h]
  unsigned int v52; // [esp+40h] [ebp-C8h]
  int v53; // [esp+44h] [ebp-C4h]
  void *dest; // [esp+48h] [ebp-C0h]
  char *v55; // [esp+4Ch] [ebp-BCh]
  char *v56; // [esp+50h] [ebp-B8h]
  int v57; // [esp+54h] [ebp-B4h]
  void *src; // [esp+58h] [ebp-B0h]
  size_t v59; // [esp+5Ch] [ebp-ACh]
  int v60; // [esp+60h] [ebp-A8h]
  size_t n; // [esp+64h] [ebp-A4h]
  size_t v62; // [esp+68h] [ebp-A0h]
  int v63; // [esp+6Ch] [ebp-9Ch]
  unsigned int v64; // [esp+70h] [ebp-98h]
  int v65; // [esp+74h] [ebp-94h]
  int v66; // [esp+78h] [ebp-90h]
  struct lconv *v67; // [esp+7Ch] [ebp-8Ch]
  unsigned int v68; // [esp+80h] [ebp-88h]
  unsigned int v69; // [esp+84h] [ebp-84h]
  unsigned int v70; // [esp+88h] [ebp-80h]
  int v71; // [esp+8Ch] [ebp-7Ch]
  unsigned __int64 v72; // [esp+90h] [ebp-78h]
  unsigned __int64 v73; // [esp+98h] [ebp-70h]
  __int64 v74; // [esp+A0h] [ebp-68h]
  unsigned __int64 v75; // [esp+A8h] [ebp-60h]
  __int64 v76; // [esp+B0h] [ebp-58h]
  unsigned __int64 v77; // [esp+B8h] [ebp-50h]
  long double v78; // [esp+C0h] [ebp-48h]
  long double v79; // [esp+D0h] [ebp-38h]
  long double v80; // [esp+E0h] [ebp-28h]

  v51 = __PAIR__(a2, a1);
  v50 = __PAIR__(a6, a5);
  v49 = __PAIR__(a8, a7);
  v63 = a4 & 3;
  if ( a4 & 0x20 )
    v8 = 1024;
  else
    v8 = 1000;
  v64 = v8;
  v53 = -1;
  v65 = 8;
  src = &unk_80696E1;
  v59 = 1;
  v66 = (int)&unk_80696E3;
  v60 = (int)&unk_80696E3;
  v67 = localeconv();
  *(_DWORD *)v42 = v67->decimal_point;
  v68 = strlen(*(const char **)v42);
  if ( v68 && v68 <= 0x10 )
  {
    src = v67->decimal_point;
    v59 = v68;
  }
  v66 = (int)v67->grouping;
  *(_DWORD *)v42 = v67->thousands_sep;
  if ( strlen(*(const char **)v42) <= 0x10 )
    v60 = (int)v67->thousands_sep;
  v55 = s + 647;
  dest = s + 647;
  if ( v49 <= v50 )
  {
    LODWORD(v9) = sub_80645C1(v50, v49, HIDWORD(v49));
    if ( !v9 )
    {
      LODWORD(v11) = sub_8064458(v50, SHIDWORD(v50), v49, HIDWORD(v49));
      v74 = v11;
      v12 = v11 * HIDWORD(v51) + v51 * HIDWORD(v11);
      v13 = (unsigned int)v51 * (unsigned __int64)(unsigned int)v11;
      LODWORD(v72) = v13;
      HIDWORD(v72) = HIDWORD(v13) + v12;
      LODWORD(v9) = sub_8064458(v13, HIDWORD(v13) + v12, v74, HIDWORD(v74));
      v10 = HIDWORD(v51) ^ HIDWORD(v9);
      if ( v51 == v9 )
      {
        v52 = 0;
        v57 = 0;
        dword_8071240 = (int)&loc_8059A64;
        sub_8064B22(
          *(_DWORD *)v42,
          *(_DWORD *)&v42[4],
          *(_DWORD *)&v42[8],
          v43,
          v44,
          v45,
          v46,
          v47,
          v48,
          HIDWORD(v48),
          v49,
          HIDWORD(v49),
          v50,
          HIDWORD(v50));
      }
    }
    dword_8071268 = (int)&loc_8059781;
    sub_8064A3C(v10, HIDWORD(v9));
  }
  if ( !v50 || (LODWORD(v14) = sub_80645C1(v49, v50, HIDWORD(v50)), v14) )
  {
    v79 = (long double)v49;
    v80 = (long double)v51 * ((long double)v50 / v79);
    if ( a4 & 0x10 )
    {
      v78 = 1.0;
      v53 = 0;
      do
      {
        v78 = (long double)v64 * v78;
        ++v53;
        v48 = v64;
      }
      while ( v80 >= v78 && v53 < v65 );
      v80 = v80 / v78;
      *(_QWORD *)&v42[4] = *(_QWORD *)&v80;
      v43 = HIDWORD(v80);
      *(long double *)&v42[8] = sub_8059066(v63, *(long double *)&v42[4]);
      sprintf(s, "%.1Lf");
      n = strlen(s);
      v62 = v59 + 1;
      if ( ((a4 & 0x20) == 0) + v59 + 1 + 1 < n || a4 & 8 && s[n - 1] == 48 )
      {
        *(long double *)&v42[4] = v80 * 10.0;
        *(long double *)&v42[8] = sub_8059066(v63, *(long double *)&v42[4]) / 10.0;
        sprintf(s, "%.0Lf");
        n = strlen(s);
        v62 = 0;
      }
    }
    else
    {
      *(_DWORD *)&v42[4] = LODWORD(v80);
      *(_QWORD *)&v42[8] = *(_QWORD *)((char *)&v80 + 4);
      *(long double *)&v42[8] = sub_8059066(v63, *(long double *)&v42[4]);
      sprintf(s, "%.0Lf");
      n = strlen(s);
      v62 = 0;
    }
    dest = &v55[-n];
    memmove(&v55[-n], s, n);
    v56 = (char *)dest + n - v62;
    dword_8071240 = (int)&loc_8059F04;
    sub_8064B22(
      *(_DWORD *)v42,
      *(_DWORD *)&v42[4],
      *(_DWORD *)&v42[8],
      v43,
      v44,
      v45,
      v46,
      v47,
      v48,
      HIDWORD(v48),
      v49,
      HIDWORD(v49),
      v50,
      HIDWORD(v50));
  }
  else
  {
    LODWORD(v15) = sub_8064458(v49, SHIDWORD(v49), v50, HIDWORD(v50));
    v75 = v15;
    v16 = sub_80645C1(v51, v15, HIDWORD(v15));
    v18 = 10 * v17;
    v19 = 10LL * (unsigned int)v16;
    LODWORD(v76) = v19;
    HIDWORD(v76) = v18 + HIDWORD(v19);
    HIDWORD(v19) += v18;
    LODWORD(v20) = sub_80645C1(v19, v75, HIDWORD(v75));
    v77 = 2 * v20;
    LODWORD(v21) = sub_8064458(v51, SHIDWORD(v51), v75, HIDWORD(v75));
    v72 = v21;
    v52 = sub_8064458(v76, SHIDWORD(v76), v75, HIDWORD(v75));
    if ( v77 >= v75 )
    {
      if ( v75 >= v77 )
        v22 = 2;
      else
        v22 = 3;
    }
    else
    {
      v22 = v77 != 0;
    }
    v57 = v22;
  }
  if ( a4 & 0x10 )
  {
    v53 = 0;
    if ( v64 <= v72 )
    {
      do
      {
        v23 = sub_80645C1(v72, v64, 0);
        v69 = 10 * v23 + v52;
        v70 = 2 * (v69 % v64) + (v57 >> 1);
        LODWORD(v24) = sub_8064458(v72, SHIDWORD(v72), v64, 0);
        v72 = v24;
        v52 = v69 / v64;
        if ( v70 >= v64 )
        {
          if ( v57 + v70 <= v64 )
            v25 = 2;
          else
            v25 = 3;
        }
        else
        {
          v25 = v57 + v70 != 0;
        }
        v57 = v25;
        ++v53;
      }
      while ( v64 <= v72 && v53 < v65 );
      if ( v72 <= 9 )
      {
        if ( v63 == 1 )
        {
          v26 = (signed int)((v52 & 1) + v57) > 2;
        }
        else
        {
          if ( v63 )
          {
            v28 = 0;
          }
          else
          {
            v27 = &loc_8059C34;
            if ( v57 <= 0 )
              v27 = &loc_8059C3B;
            dword_8071240 = (int)v27;
            sub_8064B22(
              *(_DWORD *)v42,
              *(_DWORD *)&v42[4],
              *(_DWORD *)&v42[8],
              v43,
              v44,
              v45,
              v46,
              v47,
              v48,
              HIDWORD(v48),
              v49,
              HIDWORD(v49),
              v50,
              HIDWORD(v50));
            v28 = 1;
          }
          v26 = v28 & 1;
        }
        if ( v26 )
        {
          ++v52;
          v57 = 0;
          if ( v52 == 10 )
          {
            ++v72;
            v52 = 0;
          }
        }
        if ( v72 <= 9 && (v52 || !(a4 & 8)) )
        {
          dest = (char *)dest - 1;
          *(_BYTE *)dest = v52 + 48;
          dest = (char *)dest - v59;
          memcpy(dest, src, v59);
          v57 = 0;
          v52 = 0;
        }
      }
    }
  }
  if ( v63 == 1 )
  {
    v29 = (signed int)(((v72 & 1) + v57 != 0) + v52) > 5;
  }
  else
  {
    if ( v63 )
    {
      v31 = 0;
    }
    else
    {
      v30 = &loc_8059DA0;
      if ( (signed int)(v52 + v57) <= 0 )
        v30 = &loc_8059DA7;
      dword_8071218 = (int)v30;
      sub_8064C2F(
        *(_DWORD *)v42,
        *(_DWORD *)&v42[4],
        *(_DWORD *)&v42[8],
        v43,
        v44,
        v45,
        v46,
        v47,
        v48,
        HIDWORD(v48),
        v49);
      v31 = 1;
    }
    v29 = v31 & 1;
  }
  v32 = v29 == 0;
  v33 = &loc_8059DCC;
  if ( v32 )
    v33 = &loc_8059E78;
  dword_8071240 = (int)v33;
  sub_8064B22(
    *(_DWORD *)v42,
    *(_DWORD *)&v42[4],
    *(_DWORD *)&v42[8],
    v43,
    v44,
    v45,
    v46,
    v47,
    v48,
    HIDWORD(v48),
    v49,
    HIDWORD(v49),
    v50,
    HIDWORD(v50));
  ++v72;
  if ( a4 & 0x10 && v72 == v64 && v53 < v65 )
  {
    ++v53;
    if ( !(a4 & 8) )
    {
      dest = (char *)dest - 1;
      *(_BYTE *)dest = 48;
      dest = (char *)dest - v59;
      memcpy(dest, src, v59);
    }
    v72 = 1LL;
  }
  v56 = (char *)dest;
  do
  {
    v71 = sub_80645C1(v72, 0xAu, 0);
    dest = (char *)dest - 1;
    *(_BYTE *)dest = v71 + 48;
    LODWORD(v34) = sub_8064458(v72, SHIDWORD(v72), 0xAu, 0);
    v72 = v34;
  }
  while ( v34 );
  if ( a4 & 4 )
    dest = sub_80591B9((int)dest, v56 - (_BYTE *)dest, v66, v60);
  if ( a4 & 0x80 )
  {
    if ( v53 < 0 )
    {
      v53 = 0;
      v73 = 1LL;
      dword_8071240 = (int)&loc_8059FFB;
      sub_8064B22(
        *(_DWORD *)v42,
        *(_DWORD *)&v42[4],
        *(_DWORD *)&v42[8],
        v43,
        v44,
        v45,
        v46,
        v47,
        v48,
        HIDWORD(v48),
        v49,
        HIDWORD(v49),
        v50,
        HIDWORD(v50));
      do
      {
        if ( ++v53 == v65 )
          break;
        v73 *= v64;
      }
      while ( v73 < v49 );
    }
    if ( v53 | a4 & 0x100 && a4 & 0x40 )
    {
      v35 = v55++;
      *v35 = 32;
    }
    v36 = &loc_805A069;
    if ( !v53 )
      v36 = &loc_805A0A3;
    dword_8071254 = (int)v36;
    sub_8064AB4();
    v37 = v55++;
    if ( a4 & 0x20 || v53 != 1 )
      v38 = *(_BYTE *)(v53 + 134649560);
    else
      v38 = 107;
    *v37 = v38;
    if ( a4 & 0x100 )
    {
      if ( a4 & 0x20 && v53 )
      {
        v39 = v55++;
        *v39 = 105;
      }
      v40 = v55++;
      *v40 = 66;
    }
  }
  *v55 = 0;
  return dest;
}
// 8064A3C: using guessed type int __fastcall sub_8064A3C(_DWORD, _DWORD);
// 8064B22: using guessed type int __stdcall sub_8064B22(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8064C2F: using guessed type int __stdcall sub_8064C2F(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8071218: using guessed type int dword_8071218;
// 8071240: using guessed type int dword_8071240;
// 8071254: using guessed type int dword_8071254;
// 8071268: using guessed type int dword_8071268;

//----- (0805A100) --------------------------------------------------------
__int64 sub_805A100()
{
  __int64 result; // rax

  if ( getenv("POSIXLY_CORRECT") )
    LODWORD(result) = 512;
  else
    LODWORD(result) = 1024;
  HIDWORD(result) = 0;
  return result;
}

//----- (0805A13E) --------------------------------------------------------
#error "805A262: call analysis failed (funcsize=107)"

//----- (0805A2BD) --------------------------------------------------------
int __cdecl sub_805A2BD(char *s, int a2, int a3)
{
  int v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_805A13E(s, a3, a2);
  if ( !*(_QWORD *)a3 )
  {
    *(_QWORD *)a3 = sub_805A100();
    v4 = 4;
  }
  return v4;
}

//----- (0805A318) --------------------------------------------------------
size_t __cdecl sub_805A318(__uid_t uid)
{
  size_t *v1; // ebp
  char *v2; // eax
  size_t result; // eax
  size_t v4; // [esp+0h] [ebp-28h]
  int v5; // [esp+8h] [ebp-20h]
  _DWORD *i; // [esp+10h] [ebp-18h]
  _DWORD *v7; // [esp+14h] [ebp-14h]
  struct passwd *v8; // [esp+18h] [ebp-10h]
  char *s; // [esp+1Ch] [ebp-Ch]
  int savedregs; // [esp+28h] [ebp+0h]

  v1 = (size_t *)&savedregs;
  v7 = 0;
  for ( i = (_DWORD *)dword_8072860; i; i = (_DWORD *)i[1] )
  {
    if ( *i == uid )
    {
      v7 = i;
      break;
    }
  }
  if ( !v7 )
  {
    v8 = getpwuid(uid);
    if ( v8 )
      v2 = v8->pw_name;
    else
      v2 = (char *)&unk_8069794;
    s = v2;
    v1 = &v4;
    v4 = (strlen(v2) + 16) & 0xFFFFFFF8;
    *(&v4 - 5) = (size_t)sub_80613E6(v4);
    *(_DWORD *)*(&v4 - 5) = v5;
    strcpy((char *)(*(&v4 - 5) + 8), (const char *)*(&v4 - 3));
    *(_DWORD *)(*(&v4 - 5) + 4) = dword_8072860;
    dword_8072860 = *(&v4 - 5);
  }
  if ( *(_BYTE *)(*(v1 - 5) + 8) )
    result = *(v1 - 5) + 8;
  else
    result = 0;
  return result;
}
// 8072860: using guessed type int dword_8072860;

//----- (0805A54D) --------------------------------------------------------
int __cdecl sub_805A54D(__gid_t gid)
{
  int *v1; // ebp
  char *v2; // eax
  size_t v3; // eax
  int result; // eax
  int v5; // [esp+0h] [ebp-28h]
  char *i; // [esp+10h] [ebp-18h]
  char *v7; // [esp+14h] [ebp-14h]
  struct group *v8; // [esp+18h] [ebp-10h]
  char *s; // [esp+1Ch] [ebp-Ch]
  int savedregs; // [esp+28h] [ebp+0h]

  v1 = &savedregs;
  v7 = 0;
  for ( i = (char *)dword_8072868; i; i = (char *)*((_DWORD *)i + 1) )
  {
    if ( *(_DWORD *)i == gid )
    {
      v7 = i;
      break;
    }
  }
  if ( !v7 )
  {
    v8 = getgrgid(gid);
    if ( v8 )
      v2 = v8->gr_name;
    else
      v2 = (char *)&unk_8069794;
    s = v2;
    v3 = strlen(v2);
    v7 = (char *)sub_80613E6((v3 + 16) & 0xFFFFFFF8);
    *(_DWORD *)v7 = gid;
    v1 = &v5;
    strcpy(v7 + 8, s);
    *(_DWORD *)(*(&v5 - 5) + 4) = dword_8072868;
    dword_8072868 = *(&v5 - 5);
  }
  if ( *(_BYTE *)(*(v1 - 5) + 8) )
    result = *(v1 - 5) + 8;
  else
    result = 0;
  return result;
}
// 8072868: using guessed type int dword_8072868;

//----- (0805A7AF) --------------------------------------------------------
#error "805A7DD: call analysis failed (funcsize=17)"

//----- (0805A7E2) --------------------------------------------------------
#error "805A8D7: call analysis failed (funcsize=73)"

//----- (0805A943) --------------------------------------------------------
int __cdecl sub_805A943(unsigned __int64 a1, int a2)
{
  unsigned __int64 v2; // rax
  unsigned __int64 v4; // [esp+18h] [ebp-20h]
  int v5; // [esp+2Ch] [ebp-Ch]

  v4 = a1;
  v5 = a2 + 20;
  *(_BYTE *)(a2 + 20) = 0;
  do
  {
    *(_BYTE *)--v5 = sub_80645C1(v4, 0xAu, 0) + 48;
    LODWORD(v2) = sub_8064458(v4, SHIDWORD(v4), 0xAu, 0);
    v4 = v2;
  }
  while ( v2 );
  return v5;
}

//----- (0805A9F1) --------------------------------------------------------
int __cdecl sub_805A9F1(int a1)
{
  wint_t *v1; // ebp
  wint_t v3; // [esp+0h] [ebp-28h]
  char v4; // [esp+1Bh] [ebp-Dh]
  int v5; // [esp+1Ch] [ebp-Ch]
  int savedregs; // [esp+28h] [ebp+0h]

  v1 = (wint_t *)&savedregs;
  v4 = 0;
  v5 = a1;
  while ( *(_DWORD *)*(v1 - 3) )
  {
    v3 = *(_DWORD *)*(v1 - 3);
    v1 = &v3;
    if ( !iswprint(v3) )
    {
      *(_DWORD *)*(&v3 - 3) = 65533;
      *((_BYTE *)&v3 - 13) = 1;
    }
    *(&v3 - 3) += 4;
  }
  return *((unsigned __int8 *)v1 - 13);
}

//----- (0805AA54) --------------------------------------------------------
int __cdecl sub_805AA54(_DWORD *a1, unsigned int a2)
{
  int v3; // [esp+18h] [ebp-10h]
  int v4; // [esp+1Ch] [ebp-Ch]

  v3 = 0;
  while ( *a1 )
  {
    v4 = wcwidth(*a1);
    if ( v4 == -1 )
    {
      *a1 = 65533;
      v4 = 1;
    }
    if ( v4 + v3 > a2 )
      break;
    v3 += v4;
    ++a1;
  }
  *a1 = 0;
  return v3;
}
// 8049560: using guessed type int __cdecl wcwidth(_DWORD);

//----- (0805AAC4) --------------------------------------------------------
_BYTE *__cdecl sub_805AAC4(_BYTE *a1, unsigned int a2, int a3)
{
  _BYTE *v3; // eax
  int v4; // eax

  while ( 1 )
  {
    v4 = a3--;
    if ( !v4 || (unsigned int)a1 >= a2 )
      break;
    v3 = a1++;
    *v3 = 32;
  }
  *a1 = 0;
  return a1;
}

//----- (0805AAF9) --------------------------------------------------------
int __cdecl sub_805AAF9(char *s, int a2, int a3, int a4, int a5, int a6)
{
  size_t v6; // eax
  int v7; // edx
  int v8; // ecx
  void *v9; // eax
  void *v10; // eax
  _BYTE *v11; // eax
  unsigned int v12; // eax
  int v14; // [esp+0h] [ebp-58h]
  unsigned int v15; // [esp+4h] [ebp-54h]
  int v16; // [esp+8h] [ebp-50h]
  int v17; // [esp+Ch] [ebp-4Ch]
  int v18; // [esp+10h] [ebp-48h]
  int v19; // [esp+14h] [ebp-44h]
  int v20; // [esp+18h] [ebp-40h]
  size_t v21; // [esp+1Ch] [ebp-3Ch]
  size_t size; // [esp+20h] [ebp-38h]
  char *v23; // [esp+24h] [ebp-34h]
  wchar_t *pwcs; // [esp+28h] [ebp-30h]
  char *v25; // [esp+2Ch] [ebp-2Ch]
  unsigned int v26; // [esp+30h] [ebp-28h]
  size_t v27; // [esp+34h] [ebp-24h]
  unsigned int v28; // [esp+38h] [ebp-20h]
  int v29; // [esp+3Ch] [ebp-1Ch]
  int v30; // [esp+40h] [ebp-18h]
  size_t n; // [esp+44h] [ebp-14h]
  unsigned int v32; // [esp+48h] [ebp-10h]
  unsigned int v33; // [esp+4Ch] [ebp-Ch]
  int v34; // [esp+64h] [ebp+Ch]
  _BYTE *v35; // [esp+64h] [ebp+Ch]

  v21 = -1;
  v6 = strlen(s);
  size = v6 + 1;
  v23 = 0;
  pwcs = 0;
  v25 = s;
  v26 = v6;
  v27 = v6;
  v28 = 0;
  HIWORD(v20) = 0;
  if ( a6 & 2 || __ctype_get_mb_cur_max() <= 1 )
    goto LABEL_12;
  n = mbstowcs(0, s, 0);
  if ( n == -1 )
  {
    if ( !(a6 & 1) )
      goto LABEL_39;
    goto LABEL_21;
  }
  pwcs = (wchar_t *)malloc(4 * ++n);
  if ( pwcs )
  {
    if ( mbstowcs(pwcs, s, n) )
    {
      pwcs[n + 0x3FFFFFFF] = 0;
      HIBYTE(v20) = 1;
      BYTE2(v20) = sub_805A9F1((int)pwcs);
      v26 = wcswidth(pwcs, n);
    }
LABEL_12:
    if ( HIBYTE(v20) && (BYTE2(v20) || *(_DWORD *)a4 < v26) )
    {
      v9 = &loc_805AC8D;
      if ( !BYTE2(v20) )
        v9 = &loc_805ACAE;
      dword_807127C = (int)v9;
      sub_80649CA(v8, v7);
      size = wcstombs(0, pwcs, 0) + 1;
      v23 = (char *)malloc(size);
      if ( v23 )
      {
        v25 = v23;
        v15 = *(_DWORD *)a4;
        v26 = sub_805AA54(pwcs, v15);
        v27 = wcstombs(v23, pwcs, size);
      }
      else if ( !(a6 & 1) )
      {
        goto LABEL_39;
      }
    }
LABEL_21:
    if ( *(_DWORD *)a4 < v26 )
    {
      v26 = *(_DWORD *)a4;
      v27 = v26;
    }
    if ( *(_DWORD *)a4 > v26 )
      v28 = *(_DWORD *)a4 - v26;
    *(_DWORD *)a4 = v26;
    if ( a5 )
    {
      if ( a5 == 1 )
      {
        v29 = v28;
        v30 = 0;
      }
      else
      {
        v29 = (v28 >> 1) + (v28 & 1);
        v30 = v28 >> 1;
      }
    }
    else
    {
      v29 = 0;
      v30 = v28;
    }
    v10 = &loc_805ADAA;
    if ( !(a6 & 4) )
      v10 = &loc_805ADB1;
    dword_80711DC = (int)v10;
    sub_8064D9E();
    v29 = 0;
    if ( a6 & 8 )
      v30 = 0;
    if ( a3 )
    {
      v32 = a3 - 1 + a2;
      v15 = a3 - 1 + a2;
      v11 = sub_805AAC4((_BYTE *)a2, v15, v29);
      v34 = (int)v11;
      v33 = v32 - (_DWORD)v11;
      v12 = v27;
      if ( v33 <= v27 )
        v12 = v33;
      v35 = (_BYTE *)mempcpy(v34, v25, v12);
      sub_805AAC4(v35, v32, v30);
    }
    v21 = v30 + v29 + v27;
    goto LABEL_39;
  }
  if ( a6 & 1 )
  {
    dword_8071204 = (int)&loc_805AD0C;
    sub_8064CB8(v14, v15, v16, v17, v18, v19, v20, v21, size, v23, pwcs, v25, v26, v27, v28);
  }
LABEL_39:
  free(pwcs);
  free(v23);
  return v21;
}
// 805AAF9: could not find valid save-restore pair for ebx
// 80499B0: using guessed type int __cdecl mempcpy(_DWORD, _DWORD, _DWORD);
// 80499C0: using guessed type int __cdecl wcswidth(_DWORD, _DWORD);
// 80649CA: using guessed type int __fastcall sub_80649CA(_DWORD, _DWORD);
// 8064CB8: using guessed type int __stdcall sub_8064CB8(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8064D9E: using guessed type int sub_8064D9E(void);
// 80711DC: using guessed type int dword_80711DC;
// 8071204: using guessed type int dword_8071204;
// 807127C: using guessed type int dword_807127C;

//----- (0805AF8D) --------------------------------------------------------
int __cdecl sub_805AF8D(char *s, int a2)
{
  size_t v2; // eax

  v2 = strlen(s);
  return sub_805AFD8(s, v2, a2);
}
// 805AFD8: using guessed type _DWORD __cdecl sub_805AFD8(_DWORD, _DWORD, _DWORD);

//----- (0805AFD8) --------------------------------------------------------
#error "805B294: call analysis failed (funcsize=161)"

//----- (0805B2E6) --------------------------------------------------------
void *__cdecl sub_805B2E6(int a1, int a2, void *dest, int a4)
{
  _DWORD *v4; // eax
  _DWORD *v5; // eax
  int v7; // [esp+0h] [ebp-38h]
  int v8; // [esp+4h] [ebp-34h]
  int v9; // [esp+8h] [ebp-30h]
  int v10; // [esp+Ch] [ebp-2Ch]
  int v11; // [esp+10h] [ebp-28h]
  unsigned int v12; // [esp+14h] [ebp-24h]
  unsigned int v13; // [esp+18h] [ebp-20h]
  int v14; // [esp+1Ch] [ebp-1Ch]
  int v15; // [esp+20h] [ebp-18h]
  int v16; // [esp+24h] [ebp-14h]
  int v17; // [esp+28h] [ebp-10h]
  int v18; // [esp+2Ch] [ebp-Ch]
  int v19; // [esp+30h] [ebp-8h]
  int v20; // [esp+34h] [ebp-4h]

  v16 = (unsigned int)a2 >> 1;
  v17 = a2 - ((unsigned int)a2 >> 1);
  v11 = 0;
  v12 = (unsigned int)a2 >> 1;
  v13 = (unsigned int)a2 >> 1;
  v18 = a2;
  sub_805B495(a1 + 4 * ((unsigned int)a2 >> 1), v17, dest, a4);
  sub_805B495(a1, (unsigned int)a2 >> 1, dest, a4);
  v14 = *(_DWORD *)a1;
  v15 = *(_DWORD *)(4 * ((unsigned int)a2 >> 1) + a1);
  while ( 1 )
  {
    while ( 1 )
    {
      v8 = v15;
      v7 = v14;
      if ( ((int (*)(void))a4)() <= 0 )
        break;
      v5 = dest;
      dest = (char *)dest + 4;
      *v5 = v15;
      if ( ++v13 == v18 )
      {
        dword_8071240 = (int)&loc_805B450;
        sub_8064B22(v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20);
      }
      v15 = *(_DWORD *)(4 * v13 + a1);
    }
    v4 = dest;
    dest = (char *)dest + 4;
    *v4 = v14;
    if ( ++v11 == v12 )
      break;
    v14 = *(_DWORD *)(4 * v11 + a1);
  }
  return memcpy(dest, (const void *)(4 * v13 + a1), 4 * (v18 - v13));
}
// 8064B22: using guessed type int __stdcall sub_8064B22(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8071240: using guessed type int dword_8071240;

//----- (0805B495) --------------------------------------------------------
#error "805B687: call analysis failed (funcsize=206)"

//----- (0805B74F) --------------------------------------------------------
int __cdecl sub_805B74F(int a1, int a2, int a3)
{
  return sub_805B495(a1, a2, (void *)(a1 + 4 * a2), a3);
}

//----- (0805B797) --------------------------------------------------------
#error "805B7E4: call analysis failed (funcsize=35)"

//----- (0805B7F7) --------------------------------------------------------
void sub_805B7F7()
{
  ;
}

//----- (0805B808) --------------------------------------------------------
int __cdecl sub_805B808(int a1, int a2, int a3)
{
  int v3; // eax

  while ( 1 )
  {
    v3 = a3--;
    if ( !v3 )
      break;
    *(_BYTE *)(a1 + a3) = toupper(*(unsigned __int8 *)(a2 + a3));
  }
  return a1;
}

//----- (0805B84C) --------------------------------------------------------
int __cdecl sub_805B84C(int a1, int a2)
{
  return a1 - (a1 - a2 + 382) % 7 + 3;
}

//----- (0805B8A9) --------------------------------------------------------
int __cdecl sub_805B8A9(int a1, int a2, int a3, int a4, int a5, int a6)
{
  char v7; // [esp+2Fh] [ebp-9h]

  v7 = 0;
  return sub_805B928(0, &v7, 0, &v7, 0, &v7, a5, a6);
}
// 805B928: using guessed type _DWORD __cdecl sub_805B928(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0805B928) --------------------------------------------------------
#error "805DCAF: call analysis failed (funcsize=2294)"

//----- (0805E5D8) --------------------------------------------------------
char *__cdecl sub_805E5D8(char *s)
{
  char *result; // eax

  if ( !s )
  {
    fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
    abort();
  }
  if ( strrchr(s, 47) )
  {
    dword_8071254 = (int)&loc_805E64A;
    sub_8064AB4();
  }
  dword_8072870 = (int)s;
  result = s;
  program_invocation_name = (int)s;
  return result;
}
// 8071254: using guessed type int dword_8071254;
// 8071460: using guessed type int program_invocation_short_name;
// 8071470: using guessed type int program_invocation_name;
// 8072870: using guessed type int dword_8072870;

//----- (0805E6CA) --------------------------------------------------------
int __cdecl sub_805E6CA(void *src)
{
  int v1; // eax
  int v2; // edx
  int v3; // ecx
  void *v4; // eax
  int v6; // [esp-4h] [ebp-2Ch]
  int v7; // [esp+0h] [ebp-28h]
  int v8; // [esp+18h] [ebp-10h]

  v1 = *__errno_location();
  v8 = v1;
  v6 = v1;
  v4 = &loc_805E6F9;
  if ( !src )
    v4 = &loc_805E6FE;
  dword_8071268 = (int)v4;
  sub_8064A3C(v3, v2);
  *(&v7 - 3) = (int)sub_8061512(src, 0x30u);
  *__errno_location() = *(&v7 - 4);
  return *(&v7 - 3);
}
// 8064A3C: using guessed type int __fastcall sub_8064A3C(_DWORD, _DWORD);
// 8071268: using guessed type int dword_8071268;

//----- (0805E747) --------------------------------------------------------
int __cdecl sub_805E747(int *a1)
{
  int *v1; // eax

  if ( a1 )
    v1 = a1;
  else
    v1 = &dword_807287C;
  return *v1;
}
// 807287C: using guessed type int dword_807287C;

//----- (0805E762) --------------------------------------------------------
int *__cdecl sub_805E762(int *a1, int a2)
{
  int *result; // eax

  if ( a1 )
    result = a1;
  else
    result = &dword_807287C;
  *result = a2;
  return result;
}
// 807287C: using guessed type int dword_807287C;

//----- (0805E780) --------------------------------------------------------
int __cdecl sub_805E780(int *a1, unsigned __int8 a2, char a3)
{
  int *v3; // eax
  int v4; // ST10_4

  if ( a1 )
    v3 = a1;
  else
    v3 = &dword_807287C;
  v4 = ((unsigned int)v3[(a2 >> 5) + 2] >> (a2 & 0x1F)) & 1;
  v3[(a2 >> 5) + 2] ^= (v4 ^ a3 & 1) << (a2 & 0x1F);
  return v4;
}
// 807287C: using guessed type int dword_807287C;

//----- (0805E84A) --------------------------------------------------------
int *__cdecl sub_805E84A(int *a1, int a2, int a3)
{
  int *result; // eax

  if ( !a1 )
    a1 = &dword_807287C;
  *a1 = 10;
  if ( !a2 || !a3 )
    abort();
  a1[10] = a2;
  result = a1;
  a1[11] = a3;
  return result;
}
// 807287C: using guessed type int dword_807287C;

//----- (0805E89B) --------------------------------------------------------
_DWORD *__userpurge sub_805E89B@<eax>(_DWORD *a1, int a2)
{
  int v3; // [esp+0h] [ebp-38h]
  int v4; // [esp+4h] [ebp-34h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]

  memset(&v3, 0, 0x30u);
  if ( a2 == 10 )
    abort();
  *a1 = a2;
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = v6;
  a1[4] = v7;
  a1[5] = v8;
  a1[6] = v9;
  a1[7] = v10;
  a1[8] = v11;
  a1[9] = v12;
  a1[10] = v13;
  a1[11] = v14;
  return a1;
}

//----- (0805E93D) --------------------------------------------------------
#error "805E9E4: call analysis failed (funcsize=56)"

//----- (0805E9F4) --------------------------------------------------------
#error "805F520: call analysis failed (funcsize=1114)"

//----- (0805F83D) --------------------------------------------------------
#error "805F840: positive sp value has been found (funcsize=0)"

//----- (0805F844) --------------------------------------------------------
int __cdecl sub_805F844(int a1, int a2, int a3, int a4, int *a5)
{
  int *v5; // eax
  int *v6; // ST34_4
  int v7; // ST38_4
  int v8; // ST3C_4

  if ( a5 )
    v5 = a5;
  else
    v5 = &dword_807287C;
  v6 = v5;
  v7 = *__errno_location();
  v8 = sub_805E9F4(a1, a2, a3, a4, *v6, v6[1], v6 + 2, v6[10], v6[11]);
  *__errno_location() = v7;
  return v8;
}
// 805E9F4: using guessed type _DWORD __cdecl sub_805E9F4(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 807287C: using guessed type int dword_807287C;

//----- (0805F91E) --------------------------------------------------------
void *__cdecl sub_805F91E(int a1, int a2, _DWORD *a3, int *a4)
{
  int *v4; // eax
  int *v5; // ST44_4
  int v6; // ST48_4
  int v7; // ST4C_4
  void *v8; // eax
  int v10; // [esp+0h] [ebp-58h]
  int v11; // [esp+4h] [ebp-54h]
  int v12; // [esp+8h] [ebp-50h]
  int v13; // [esp+Ch] [ebp-4Ch]
  int v14; // [esp+10h] [ebp-48h]
  int v15; // [esp+14h] [ebp-44h]
  int v16; // [esp+18h] [ebp-40h]
  int v17; // [esp+1Ch] [ebp-3Ch]
  int v18; // [esp+20h] [ebp-38h]
  int v19; // [esp+24h] [ebp-34h]
  int v20; // [esp+28h] [ebp-30h]
  int size; // [esp+48h] [ebp-10h]
  void *v22; // [esp+4Ch] [ebp-Ch]

  if ( a4 )
    v4 = a4;
  else
    v4 = &dword_807287C;
  v5 = v4;
  v6 = *__errno_location();
  v7 = v5[1] | (a3 == 0);
  size = sub_805E9F4(0, 0, a1, a2, *v5, v7, v5 + 2, v5[10], v5[11]) + 1;
  v22 = sub_80613C3(size);
  sub_805E9F4(v22, size, a1, a2, *v5, v7, v5 + 2, v5[10], v5[11]);
  *__errno_location() = v6;
  v8 = &loc_805FA52;
  if ( !a3 )
    v8 = &loc_805FA5D;
  dword_8071218 = (int)v8;
  sub_8064C2F(v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20);
  *a3 = size - 1;
  return v22;
}
// 805E9F4: using guessed type _DWORD __cdecl sub_805E9F4(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8064C2F: using guessed type int __stdcall sub_8064C2F(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8071218: using guessed type int dword_8071218;
// 807287C: using guessed type int dword_807287C;

//----- (0805FB33) --------------------------------------------------------
int __cdecl sub_805FB33(signed int a1)
{
  size_t *v1; // ebp
  int *v2; // eax
  int *v3; // ecx
  void *v4; // edx
  int v5; // edx
  int v6; // ebx
  int v7; // eax
  _DWORD *v8; // edx
  int v9; // ebx
  int v10; // edx
  int v11; // eax
  size_t v13; // [esp+0h] [ebp-58h]
  int v14; // [esp+4h] [ebp-54h]
  int v15; // [esp+8h] [ebp-50h]
  int v16; // [esp+Ch] [ebp-4Ch]
  int v17; // [esp+10h] [ebp-48h]
  int *v18; // [esp+14h] [ebp-44h]
  _DWORD *v19; // [esp+18h] [ebp-40h]
  int v20; // [esp+1Ch] [ebp-3Ch]
  int v21; // [esp+20h] [ebp-38h]
  bool v22; // [esp+37h] [ebp-21h]
  int *v23; // [esp+38h] [ebp-20h]
  int v24; // [esp+40h] [ebp-18h]
  int savedregs; // [esp+58h] [ebp+0h]

  v1 = (size_t *)&savedregs;
  v24 = *__errno_location();
  v23 = off_8071414;
  if ( a1 < 0 )
    abort();
  if ( dword_8071408 <= a1 )
  {
    v22 = v23 == &dword_807140C;
    if ( (unsigned int)a1 > 0xFFFFFFE )
      sub_8061564();
    if ( v22 )
      v2 = 0;
    else
      v2 = v23;
    v23 = (int *)sub_8061414(v2, 8 * (a1 + 1));
    off_8071414 = v23;
    if ( v22 )
    {
      v3 = v23;
      v4 = off_8071410;
      *v23 = dword_807140C;
      v3[1] = (int)v4;
    }
    v1 = &v13;
    memset((void *)(8 * dword_8071408 + *(&v13 - 8)), 0, 8 * (a1 + 1 - dword_8071408));
    dword_8071408 = v15 + 1;
  }
  *(v1 - 5) = *(_DWORD *)(8 * v1[2] + *(v1 - 8));
  *(v1 - 7) = *(_DWORD *)(8 * v1[2] + *(v1 - 8) + 4);
  *(v1 - 4) = *(_DWORD *)(v1[5] + 4) | 1;
  v5 = *(_DWORD *)(v1[5] + 40);
  v6 = v1[5] + 8;
  v7 = *v18;
  v21 = *(_DWORD *)(v1[5] + 44);
  v20 = v5;
  v19 = (_DWORD *)v6;
  v18 = (int *)*(&v13 - 4);
  v17 = v7;
  v16 = v7;
  v15 = v7;
  v14 = *(&v13 - 5);
  v13 = *(&v13 - 7);
  *(&v13 - 3) = sub_805E9F4(v13, v14, v7, v7, v7, v18, v6, v5, v21);
  if ( *(&v13 - 5) <= *(&v13 - 3) )
  {
    v8 = (_DWORD *)(*(&v13 - 8) + 8 * v15);
    *(&v13 - 5) = *(&v13 - 3) + 1;
    *v8 = *(&v13 - 5);
    if ( (_UNKNOWN *)*(&v13 - 7) != &unk_80728BC )
      free((void *)*(&v13 - 7));
    v9 = 8 * v15 + *(&v13 - 8);
    v13 = *(&v13 - 5);
    *(&v13 - 7) = (size_t)sub_80613C3(v13);
    *(_DWORD *)(v9 + 4) = *(&v13 - 7);
    v10 = v18[10];
    v11 = *v18;
    v21 = v18[11];
    v20 = v10;
    v19 = v18 + 2;
    v18 = (int *)*(&v13 - 4);
    v15 = v11;
    sub_805E9F4(*(&v13 - 7), *(&v13 - 5), v11, v11, v11, v18, v19, v10, v21);
  }
  *__errno_location() = *(&v13 - 6);
  return *(&v13 - 7);
}
// 805E9F4: using guessed type _DWORD __cdecl sub_805E9F4(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8071408: using guessed type int dword_8071408;
// 807140C: using guessed type int dword_807140C;
// 8071410: using guessed type void *off_8071410;
// 8071414: using guessed type int *off_8071414;

//----- (0805FDAE) --------------------------------------------------------
int __cdecl sub_805FDAE(signed int a1)
{
  return sub_805FB33(a1);
}

//----- (0805FDDC) --------------------------------------------------------
int __cdecl sub_805FDDC(signed int a1)
{
  return sub_805FB33(a1);
}

//----- (0805FE52) --------------------------------------------------------
int __cdecl sub_805FE52(signed int a1, int a2)
{
  char v3; // [esp+10h] [ebp-38h]

  sub_805E89B(&v3, a2);
  return sub_805FB33(a1);
}

//----- (0805FE94) --------------------------------------------------------
int __cdecl sub_805FE94(signed int a1, int a2, int a3, int a4)
{
  int v5; // [esp+0h] [ebp-48h]
  int v6; // [esp+4h] [ebp-44h]
  int v7; // [esp+8h] [ebp-40h]
  char *v8; // [esp+Ch] [ebp-3Ch]
  char v9; // [esp+10h] [ebp-38h]

  sub_805E89B(&v5 - 14, a2);
  v8 = &v9;
  v7 = a4;
  v6 = a3;
  return sub_805FB33(a1);
}

//----- (0805FED5) --------------------------------------------------------
int __cdecl sub_805FED5(int a1)
{
  return sub_805FE52(0, a1);
}

//----- (0805FF54) --------------------------------------------------------
#error "805FFA9: call analysis failed (funcsize=26)"

//----- (0805FFAE) --------------------------------------------------------
#error "8060044: positive sp value has been found (funcsize=42)"

//----- (08060045) --------------------------------------------------------
int __cdecl sub_8060045(int a1, char a2)
{
  return sub_805FF54(a1, -1, a2);
}
// 805FF54: using guessed type _DWORD __cdecl sub_805FF54(_DWORD, _DWORD, _DWORD);

//----- (0806007E) --------------------------------------------------------
int __cdecl sub_806007E(int a1, int a2)
{
  return sub_8060045(a2, 58);
}

//----- (08060104) --------------------------------------------------------
int __cdecl sub_8060104(signed int a1, int a2, int a3)
{
  int v4; // [esp+0h] [ebp-78h]
  int v5; // [esp+4h] [ebp-74h]
  int v6; // [esp+8h] [ebp-70h]
  int *v7; // [esp+Ch] [ebp-6Ch]
  int v8; // [esp+10h] [ebp-68h]
  int v9; // [esp+14h] [ebp-64h]
  int v10; // [esp+18h] [ebp-60h]
  int v11; // [esp+1Ch] [ebp-5Ch]
  int v12; // [esp+20h] [ebp-58h]
  int v13; // [esp+24h] [ebp-54h]
  int v14; // [esp+28h] [ebp-50h]
  int v15; // [esp+2Ch] [ebp-4Ch]
  int v16; // [esp+30h] [ebp-48h]
  int v17; // [esp+34h] [ebp-44h]
  int v18; // [esp+38h] [ebp-40h]
  int v19; // [esp+3Ch] [ebp-3Ch]
  int v20; // [esp+40h] [ebp-38h]
  int v21; // [esp+44h] [ebp-34h]
  int v22; // [esp+48h] [ebp-30h]
  int v23; // [esp+4Ch] [ebp-2Ch]
  int v24; // [esp+50h] [ebp-28h]
  int v25; // [esp+54h] [ebp-24h]
  int v26; // [esp+58h] [ebp-20h]
  int v27; // [esp+5Ch] [ebp-1Ch]
  int v28; // [esp+60h] [ebp-18h]
  int v29; // [esp+64h] [ebp-14h]
  int v30; // [esp+68h] [ebp-10h]
  int v31; // [esp+6Ch] [ebp-Ch]

  sub_805E89B(&v8, a2);
  v20 = v8;
  v21 = v9;
  v22 = v10;
  v23 = v11;
  v24 = v12;
  v25 = v13;
  v26 = v14;
  v27 = v15;
  v28 = v16;
  v29 = v17;
  v30 = v18;
  v31 = v19;
  sub_805E780(&v4 - 14, 0x3Au, 1);
  v7 = &v4 - 14;
  v6 = -1;
  v5 = a3;
  return sub_805FB33(a1);
}

//----- (080601B9) --------------------------------------------------------
int sub_80601B9()
{
  int v1; // [esp+14h] [ebp-14h]

  return sub_8060207(-1, v1, -1, v1, -1);
}
// 8060207: using guessed type int __cdecl sub_8060207(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (08060207) --------------------------------------------------------
#error "8060246: call analysis failed (funcsize=20)"

//----- (0806024B) --------------------------------------------------------
#error "80602CC: positive sp value has been found (funcsize=0)"

//----- (0806036B) --------------------------------------------------------
int __cdecl sub_806036B(signed int a1)
{
  return sub_805FB33(a1);
}

//----- (080603C6) --------------------------------------------------------
int __cdecl sub_80603C6(signed int a1)
{
  return sub_806036B(a1);
}

//----- (0806040C) --------------------------------------------------------
int sub_806040C()
{
  return sub_80603C6(0);
}

//----- (08060437) --------------------------------------------------------
int __usercall sub_8060437@<eax>(int a1@<edx>, int a2@<ecx>, unsigned __int8 *a3@<ebx>, void *src, void *a5)
{
  int *v5; // ebp
  int v6; // edx
  int v7; // ecx
  int v8; // edx
  int v9; // ecx
  void *v10; // eax
  bool v11; // al
  int v12; // edx
  int v13; // ecx
  int v14; // edx
  int v15; // ecx
  int v16; // eax
  int v17; // eax
  bool v18; // al
  unsigned __int8 *v20; // [esp-8h] [ebp-100h]
  size_t v21; // [esp-4h] [ebp-FCh]
  int v22; // [esp+0h] [ebp-F8h]
  void *v23; // [esp+Ch] [ebp-ECh]
  bool v24; // [esp+15h] [ebp-E3h]
  bool v25; // [esp+16h] [ebp-E2h]
  bool v26; // [esp+17h] [ebp-E1h]
  void *s1; // [esp+18h] [ebp-E0h]
  void *s2; // [esp+1Ch] [ebp-DCh]
  size_t v29; // [esp+20h] [ebp-D8h]
  size_t n; // [esp+24h] [ebp-D4h]
  void *ptr; // [esp+28h] [ebp-D0h]
  void *v32; // [esp+2Ch] [ebp-CCh]
  __int64 v33; // [esp+30h] [ebp-C8h]
  __int64 v34; // [esp+88h] [ebp-70h]
  __int64 v35; // [esp+90h] [ebp-68h]
  __int64 v36; // [esp+E8h] [ebp-10h]
  int savedregs; // [esp+F8h] [ebp+0h]

  v5 = &savedregs;
  s1 = sub_80568C9(a1, a2, a3, (int)src);
  s2 = sub_80568C9(v6, v7, a3, (int)a5);
  v29 = sub_805698D((char *)s1);
  n = sub_805698D((char *)s2);
  v21 = v29;
  v20 = a3;
  v10 = &loc_80604B3;
  if ( v29 != n )
    v10 = &loc_80604E0;
  dword_80711F0 = (int)v10;
  sub_8064D28(v9, v8);
  v11 = memcmp(s1, s2, n) == 0;
  v25 = v11;
  v26 = v11;
  v24 = 0;
  if ( v11 )
  {
    ptr = (void *)sub_80636BF(v12, v13, v20, src);
    v32 = (void *)sub_80636BF(v14, v15, v20, a5);
    if ( sub_806481F((int)ptr, (int)&v33) )
    {
      v16 = *__errno_location();
      v23 = ptr;
      error(1, v16, "%s", ptr);
    }
    if ( sub_806481F((int)v32, (int)&v35) )
    {
      v17 = *__errno_location();
      v23 = v32;
      error(1, v17, "%s", v32);
    }
    v18 = v34 == v36 && v33 == v35;
    v24 = v18;
    v5 = &v22;
    free((void *)*(&v22 - 52));
    free((void *)*(&v22 - 51));
  }
  return *((unsigned __int8 *)v5 - 227);
}
// 80711F0: using guessed type int dword_80711F0;

//----- (08060670) --------------------------------------------------------
void sub_8060670()
{
  ;
}

//----- (080606C1) --------------------------------------------------------
signed int sub_80606C1()
{
  *__errno_location() = 95;
  return -1;
}

//----- (080606F7) --------------------------------------------------------
signed int sub_80606F7()
{
  *__errno_location() = 95;
  return -1;
}

//----- (08060851) --------------------------------------------------------
_DWORD *__userpurge sub_8060851@<eax>(_DWORD *a1, int a2)
{
  int v2; // edx

  v2 = *(_DWORD *)(a2 + 68);
  *a1 = *(_DWORD *)(a2 + 64);
  a1[1] = v2;
  return a1;
}

//----- (0806087C) --------------------------------------------------------
#error "8060899: call analysis failed (funcsize=16)"

//----- (080608AC) --------------------------------------------------------
#error "80608CB: positive sp value has been found (funcsize=0)"

//----- (080608D2) --------------------------------------------------------
_DWORD *__userpurge sub_80608D2@<eax>(_DWORD *a1, int a2)
{
  int v2; // edx

  v2 = *(_DWORD *)(a2 + 76);
  *a1 = *(_DWORD *)(a2 + 72);
  a1[1] = v2;
  return a1;
}

//----- (0806097D) --------------------------------------------------------
#error "80609AC: call analysis failed (funcsize=30)"

//----- (08060A67) --------------------------------------------------------
#error "8060ED1: call analysis failed (funcsize=442)"

//----- (08061109) --------------------------------------------------------
#error "8061124: call analysis failed (funcsize=41)"

//----- (08061194) --------------------------------------------------------
int sub_8061194(FILE *stream, int a2, int a3, int a4, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a4);
  return sub_8061109(stream, a2, a3, a4, (int)va);
}

//----- (0806126A) --------------------------------------------------------
void *__cdecl sub_806126A(unsigned int a1, unsigned int a2)
{
  if ( 0x7FFFFFFF / a2 < a1 )
    sub_8061564();
  return sub_80613E6(a2 * a1);
}

//----- (080612AA) --------------------------------------------------------
void *__cdecl sub_80612AA(void *ptr, int a2, int a3)
{
  if ( 0x7FFFFFFFu / a3 < a2 )
    sub_8061564();
  return sub_8061414(ptr, a3 * a2);
}

//----- (080612DF) --------------------------------------------------------
void *__usercall sub_80612DF@<eax>(int a1@<edx>, int a2@<ecx>, void *ptr, int a4)
{
  int v4; // eax
  void *v5; // eax
  int v7; // [esp-4h] [ebp-2Ch]
  int v8; // [esp+0h] [ebp-28h]
  void *v9; // [esp+8h] [ebp-20h]
  _DWORD *v10; // [esp+Ch] [ebp-1Ch]
  unsigned int v11; // [esp+10h] [ebp-18h]

  v4 = *(_DWORD *)a4;
  *(&v8 - 3) = *(_DWORD *)a4;
  v7 = v4;
  v5 = &loc_806132C;
  if ( v9 )
    v5 = &loc_8061366;
  dword_8071268 = (int)v5;
  sub_8064A3C(a2, a1);
  if ( !*(&v8 - 3) )
  {
    *(&v8 - 3) = 0x40 / v11;
    *(&v8 - 3) += *(&v8 - 3) == 0;
  }
  if ( 0x7FFFFFFF / v11 < *(&v8 - 3) )
    sub_8061564();
  *v10 = *(&v8 - 3);
  return sub_8061414(v9, v11 * *(&v8 - 3));
}
// 8064A3C: using guessed type int __fastcall sub_8064A3C(_DWORD, _DWORD);
// 8071268: using guessed type int dword_8071268;

//----- (080613C3) --------------------------------------------------------
void *__cdecl sub_80613C3(size_t size)
{
  return sub_80613E6(size);
}

//----- (080613E6) --------------------------------------------------------
void *__cdecl sub_80613E6(size_t size)
{
  void *v2; // [esp+1Ch] [ebp-Ch]

  v2 = malloc(size);
  if ( !v2 && size )
    sub_8061564();
  return v2;
}

//----- (08061414) --------------------------------------------------------
void *__cdecl sub_8061414(void *ptr, size_t size)
{
  void *result; // eax
  void *ptra; // [esp+20h] [ebp+8h]

  if ( size || !ptr )
  {
    ptra = realloc(ptr, size);
    if ( !ptra )
    {
      if ( size )
        sub_8061564();
    }
    result = ptra;
  }
  else
  {
    free(ptr);
    result = 0;
  }
  return result;
}

//----- (08061467) --------------------------------------------------------
void *__usercall sub_8061467@<eax>(int a1@<edx>, int a2@<ecx>, void *ptr, int a4)
{
  return sub_80612DF(a1, a2, ptr, a4);
}

//----- (08061512) --------------------------------------------------------
void *__cdecl sub_8061512(void *src, size_t n)
{
  void *v2; // eax

  v2 = sub_80613E6(n);
  return memcpy(v2, src, n);
}

//----- (0806153B) --------------------------------------------------------
void *__cdecl sub_806153B(char *s)
{
  size_t v1; // eax

  v1 = strlen(s);
  return sub_8061512(s, v1 + 1);
}

//----- (08061564) --------------------------------------------------------
void __noreturn sub_8061564()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (080615C1) --------------------------------------------------------
#error "8061635: call analysis failed (funcsize=99)"

//----- (080617A0) --------------------------------------------------------
char *sub_80617A0()
{
  char *v1; // [esp+1Ch] [ebp-Ch]

  v1 = getcwd(0, 0);
  if ( !v1 && *__errno_location() == 12 )
    sub_8061564();
  return v1;
}

//----- (080617DD) --------------------------------------------------------
char *__fastcall sub_80617DD(int a1, int a2)
{
  int v3; // [esp+10h] [ebp-18h]
  char *name; // [esp+14h] [ebp-14h]
  size_t len; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]

  name = 0;
  v3 = 34;
  do
  {
    while ( 1 )
    {
      name = (char *)sub_8061467(a2, a1, name, (int)&v3);
      len = v3 - 1;
      name[v3 - 2] = 0;
      *__errno_location() = 0;
      if ( gethostname(name, len) )
        break;
      a2 = len - 1;
      if ( !name[len - 1] )
        return name;
    }
  }
  while ( !*__errno_location() || *__errno_location() == 36 || *__errno_location() == 22 || *__errno_location() == 12 );
  v6 = *__errno_location();
  free(name);
  *__errno_location() = v6;
  return 0;
}

//----- (080618B5) --------------------------------------------------------
signed int __cdecl sub_80618B5(unsigned int *a1, unsigned int a2)
{
  signed int result; // eax

  if ( 0xFFFFFFFF / a2 >= *a1 )
  {
    *a1 *= a2;
    result = 0;
  }
  else
  {
    *a1 = -1;
    result = 1;
  }
  return result;
}

//----- (08061909) --------------------------------------------------------
#error "806192B: call analysis failed (funcsize=13)"

//----- (08061930) --------------------------------------------------------
int __cdecl sub_8061930(int a1, int a2, int a3, int a4)
{
  void *v4; // eax

  v4 = &loc_80619AA;
  if ( a4 )
    v4 = &loc_806194F;
  dword_8071254 = (int)v4;
  sub_8064AB4();
  return a4;
}
// 8061930: could not find valid save-restore pair for ebp
// 8071254: using guessed type int dword_8071254;

//----- (080619AF) --------------------------------------------------------
#error "8061BDF: call analysis failed (funcsize=318)"

//----- (08061E43) --------------------------------------------------------
void __cdecl sub_8061E43(int a1, int a2, int a3, int a4, int a5, int status)
{
  char *v6; // eax
  const char *v7; // [esp+Ch] [ebp-2Ch]
  char *v8; // [esp+10h] [ebp-28h]
  int v9; // [esp+14h] [ebp-24h]
  char v10; // [esp+1Ch] [ebp-1Ch]
  char v11; // [esp+22h] [ebp-16h]
  char v12; // [esp+23h] [ebp-15h]
  const char *v13; // [esp+24h] [ebp-14h]
  char *msgid; // [esp+28h] [ebp-10h]
  char *v15; // [esp+2Ch] [ebp-Ch]

  v10 = a3;
  v13 = "--";
  if ( (unsigned int)a1 > 3 )
  {
    if ( a1 != 4 )
      goto LABEL_6;
    msgid = "invalid %s%s argument '%s'";
  }
  else if ( (unsigned int)a1 >= 2 )
  {
    msgid = "invalid suffix in %s%s argument '%s'";
  }
  else
  {
    if ( a1 != 1 )
LABEL_6:
      abort();
    msgid = "%s%s argument '%s' too large";
  }
  if ( a2 >= 0 )
  {
    v15 = *(char **)(16 * a2 + a4);
  }
  else
  {
    v13 -= a2;
    v11 = v10;
    v12 = 0;
    v15 = &v11;
  }
  v6 = gettext(msgid);
  v9 = a5;
  v8 = v15;
  v7 = v13;
  error(status, 0, v6, v13, v15, a5);
}

//----- (08061F1B) --------------------------------------------------------
#error "8061F5B: call analysis failed (funcsize=21)"

//----- (08061F60) --------------------------------------------------------
#error "8061F79: call analysis failed (funcsize=10)"

//----- (08061F83) --------------------------------------------------------
signed int __cdecl sub_8061F83(signed int a1)
{
  int *v1; // ebp
  unsigned int v2; // ecx
  unsigned int v3; // edx
  unsigned int v4; // ebx
  unsigned int v5; // edx
  int v6; // eax
  signed int result; // eax
  unsigned int *v8; // eax
  unsigned int v9; // ecx
  unsigned int v10; // ebx
  int v11; // eax
  int v12; // edi
  unsigned __int64 v13; // rax
  int v14; // ecx
  int v15; // [esp+0h] [ebp-2Ch]
  __int64 v16; // [esp+8h] [ebp-24h]
  int v17; // [esp+24h] [ebp-8h]
  unsigned int *retaddr; // [esp+2Ch] [ebp+0h]

  v1 = &v17;
  v2 = sub_8064458(0xFFFFFFFF, -1, a1, a1 >> 31);
  v4 = v3;
  v5 = retaddr[1];
  if ( v4 > v5 || (v1 = &v15, v4 >= v5) && v2 >= *retaddr )
  {
    v8 = (unsigned int *)v1[2];
    v9 = *v8;
    v10 = v8[1];
    v11 = v1[3];
    v12 = v11 * v10;
    v13 = v9 * (unsigned __int64)(unsigned int)v11;
    HIDWORD(v13) += v12 + v9 * (v1[3] >> 31);
    v14 = v16;
    *(_DWORD *)v16 = v13;
    *(_DWORD *)(v14 + 4) = HIDWORD(v13);
    result = 0;
  }
  else
  {
    v6 = v16;
    *(_DWORD *)v16 = -1;
    *(_DWORD *)(v6 + 4) = -1;
    result = 1;
  }
  return result;
}

//----- (08062037) --------------------------------------------------------
int __cdecl sub_8062037(signed int a1, int a2, int a3)
{
  int v3; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; ; i |= sub_8061F83(a1) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}

//----- (08062071) --------------------------------------------------------
unsigned int __cdecl sub_8062071(char *nptr, int a2, int base, int a4, char *s)
{
  const char **v5; // ebp
  char **v6; // eax
  unsigned int result; // eax
  int v8; // edx
  int v9; // edx
  int v10; // eax
  int v11; // edx
  char *v12; // ecx
  int v13; // edx
  int v14; // eax
  int v15; // edx
  char *v16; // ecx
  const char *v17; // [esp+0h] [ebp-48h]
  int v18; // [esp+4h] [ebp-44h]
  int v19; // [esp+8h] [ebp-40h]
  int v20; // [esp+Ch] [ebp-3Ch]
  int v21; // [esp+10h] [ebp-38h]
  int v22; // [esp+14h] [ebp-34h]
  int v23; // [esp+18h] [ebp-30h]
  char v24; // [esp+1Ch] [ebp-2Ch]
  int v25; // [esp+20h] [ebp-28h]
  char *v26; // [esp+24h] [ebp-24h]
  int v27; // [esp+28h] [ebp-20h]
  int v28; // [esp+2Ch] [ebp-1Ch]
  int v29; // [esp+30h] [ebp-18h]
  char **endptr; // [esp+34h] [ebp-14h]
  uintmax_t v31; // [esp+38h] [ebp-10h]
  int savedregs; // [esp+48h] [ebp+0h]

  v5 = (const char **)&savedregs;
  v25 = 0;
  if ( base < 0 || base > 36 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoumax");
  if ( a2 )
    v6 = (char **)a2;
  else
    v6 = (char **)&v24;
  endptr = v6;
  *__errno_location() = 0;
  v26 = nptr;
  HIBYTE(v23) = *nptr;
  while ( (*__ctype_b_loc())[HIBYTE(v23)] & 0x2000 )
    HIBYTE(v23) = *++v26;
  if ( HIBYTE(v23) == 45 )
    return 4;
  v31 = strtoumax(nptr, endptr, base);
  if ( *endptr == nptr )
  {
    if ( !s || !**endptr || !strchr(s, **endptr) )
      return 4;
    v31 = 1LL;
  }
  else if ( *__errno_location() )
  {
    if ( *__errno_location() != 34 )
      return 4;
    v25 = 1;
  }
  if ( !s )
  {
    v8 = HIDWORD(v31);
    *(_DWORD *)a4 = v31;
    *(_DWORD *)(a4 + 4) = v8;
    return v25;
  }
  if ( !**endptr )
  {
LABEL_53:
    v15 = (int)*(v5 - 3);
    v16 = (char *)v5[5];
    *(_DWORD *)v16 = *(v5 - 4);
    *((_DWORD *)v16 + 1) = v15;
    return (unsigned int)*(v5 - 10);
  }
  v27 = 1024;
  v28 = 1;
  if ( !strchr(s, **endptr) )
  {
    v9 = HIDWORD(v31);
    *(_DWORD *)a4 = v31;
    *(_DWORD *)(a4 + 4) = v9;
    dword_8071218 = (int)&locret_80624D0;
    sub_8064C2F(v17, v18, v19, v20, v21, v22, v23, *(_DWORD *)&v24, v25, v26, v27);
    v5 = &v17;
  }
  switch ( **(char **)*(v5 - 5) )
  {
    case 69:
    case 71:
    case 75:
    case 77:
    case 80:
    case 84:
    case 89:
    case 90:
    case 103:
    case 107:
    case 109:
    case 116:
      v18 = 48;
      v17 = v5[6];
      if ( strchr(v17, 48) )
      {
        v10 = *(char *)(*(_DWORD *)*(v5 - 5) + 1);
        switch ( v10 )
        {
          case 68:
            goto LABEL_56;
          case 105:
            if ( *(_BYTE *)(*(_DWORD *)*(v5 - 5) + 2) == 66 )
              *(v5 - 7) += 2;
            goto LABEL_37;
          case 66:
LABEL_56:
            *(v5 - 8) = (const char *)1000;
            ++*(v5 - 7);
            break;
        }
      }
      break;
    default:
      break;
  }
LABEL_37:
  switch ( **(char **)*(v5 - 5) )
  {
    case 66:
      v18 = 1024;
      *(v5 - 6) = (const char *)sub_8061F83((signed int)(v5 - 4));
      goto LABEL_51;
    case 69:
      v19 = 6;
      v18 = (int)*(v5 - 8);
      *(v5 - 6) = (const char *)sub_8062037((signed int)(v5 - 4), v18, 6);
      goto LABEL_51;
    case 71:
    case 103:
      v19 = 3;
      v18 = (int)*(v5 - 8);
      *(v5 - 6) = (const char *)sub_8062037((signed int)(v5 - 4), v18, 3);
      goto LABEL_51;
    case 75:
    case 107:
      v19 = 1;
      v18 = (int)*(v5 - 8);
      *(v5 - 6) = (const char *)sub_8062037((signed int)(v5 - 4), v18, 1);
      dword_80711DC = (int)&loc_806248A;
      sub_8064D9E();
      v5 = &v17;
      goto LABEL_44;
    case 77:
    case 109:
LABEL_44:
      v19 = 2;
      *(v5 - 6) = (const char *)sub_8062037((signed int)(v5 - 4), (int)*(v5 - 8), 2);
      dword_8071218 = (int)&loc_806248A;
      sub_8064C2F(v17, v18, v19, v20, v21, v22, v23, *(_DWORD *)&v24, v25, v26, v27);
      v5 = &v17;
      goto LABEL_45;
    case 80:
LABEL_45:
      v19 = 5;
      v18 = (int)*(v5 - 8);
      *(v5 - 6) = (const char *)sub_8062037((signed int)(v5 - 4), v18, 5);
      goto LABEL_51;
    case 84:
    case 116:
      v19 = 4;
      *(v5 - 6) = (const char *)sub_8062037((signed int)(v5 - 4), (int)*(v5 - 8), 4);
      dword_8071204 = (int)&loc_806248A;
      sub_8064CB8(v17, v18, v19, v20, v21, v22, v23, *(_DWORD *)&v24, v25, v26, v27, v28, v29, endptr, v31);
      v5 = &v17;
      goto LABEL_47;
    case 89:
      v19 = 8;
      v18 = (int)*(v5 - 8);
      *(v5 - 6) = (const char *)sub_8062037((signed int)(v5 - 4), v18, 8);
      goto LABEL_51;
    case 90:
      v19 = 7;
      v18 = (int)*(v5 - 8);
      *(v5 - 6) = (const char *)sub_8062037((signed int)(v5 - 4), v18, 7);
      goto LABEL_51;
    case 98:
      v18 = 512;
      *(v5 - 6) = (const char *)sub_8061F83((signed int)(v5 - 4));
      goto LABEL_51;
    case 99:
      *(v5 - 6) = 0;
      goto LABEL_51;
    case 119:
LABEL_47:
      v18 = 2;
      *(v5 - 6) = (const char *)sub_8061F83((signed int)(v5 - 4));
LABEL_51:
      *(v5 - 10) = (const char *)((unsigned int)*(v5 - 6) | (unsigned int)*(v5 - 10));
      v13 = *(_DWORD *)*(v5 - 5);
      v14 = (int)*(v5 - 7);
      v5 = &v17;
      *(_DWORD *)*(&v17 - 5) = v14 + v13;
      if ( **(_BYTE **)*(&v17 - 5) )
        *(&v17 - 10) = (const char *)((unsigned int)*(&v17 - 10) | 2);
      goto LABEL_53;
    default:
      v11 = (int)*(v5 - 3);
      v12 = (char *)v5[5];
      *(_DWORD *)v12 = *(v5 - 4);
      *((_DWORD *)v12 + 1) = v11;
      result = (unsigned int)*(v5 - 10) | 2;
      break;
  }
  return result;
}
// 8064C2F: using guessed type int __stdcall sub_8064C2F(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8064CB8: using guessed type int __stdcall sub_8064CB8(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8064D9E: using guessed type int sub_8064D9E(void);
// 80711DC: using guessed type int dword_80711DC;
// 8071204: using guessed type int dword_8071204;
// 8071218: using guessed type int dword_8071218;

//----- (080624D2) --------------------------------------------------------
#error "80624F2: call analysis failed (funcsize=45)"

//----- (08062561) --------------------------------------------------------
int __cdecl sub_8062561(int a1, int a2)
{
  int result; // eax

  if ( *(_BYTE *)(a1 + 40) & 1 )
    result = (*(int (__cdecl **)(_DWORD, int))(a1 + 28))(*(_DWORD *)(a1 + 36), a2);
  else
    result = (*(int (__cdecl **)(int))(a1 + 28))(a2);
  return result;
}

//----- (080625A3) --------------------------------------------------------
int __cdecl sub_80625A3(int a1, int a2)
{
  int result; // eax

  if ( *(_BYTE *)(a1 + 40) & 1 )
    result = (*(int (__cdecl **)(_DWORD, int))(a1 + 32))(*(_DWORD *)(a1 + 36), a2);
  else
    result = (*(int (__cdecl **)(int))(a1 + 32))(a2);
  return result;
}

//----- (080625F3) --------------------------------------------------------
signed int __cdecl sub_80625F3(signed int *a1, signed int a2, signed int a3)
{
  int v3; // eax
  int v4; // ecx
  int v5; // edx
  int v6; // eax
  bool v7; // zf
  void *v8; // eax
  int v10; // [esp-4h] [ebp-2Ch]
  int v11; // [esp+0h] [ebp-28h]
  int v12; // [esp+4h] [ebp-24h]
  int v13; // [esp+8h] [ebp-20h]
  int v14; // [esp+10h] [ebp-18h]
  int v15; // [esp+18h] [ebp-10h]

  if ( !a3 )
    a3 = 8;
  if ( !a2 )
  {
    v15 = 32;
    a2 = 4064;
  }
  *a1 = a2;
  a1[6] = a3 - 1;
  v12 = *a1;
  v3 = sub_8062561(v13, v12);
  v5 = v13;
  *(_DWORD *)(v13 + 4) = v3;
  v6 = *(_DWORD *)(v13 + 4);
  *(&v11 - 3) = v6;
  v7 = *(&v11 - 3) == 0;
  v10 = v6;
  v8 = &loc_8062696;
  if ( !v7 )
    v8 = &loc_806269D;
  dword_807127C = (int)v8;
  sub_80649CA(v4, v5);
  obstack_alloc_failed_handler();
  *(_DWORD *)(v13 + 8) = (*(&v11 - 3) + 8 + v14 - 1) & -v14;
  *(_DWORD *)(v13 + 12) = *(_DWORD *)(v13 + 8);
  *(_DWORD *)*(&v11 - 3) = *(&v11 - 3) + *(_DWORD *)v13;
  *(_DWORD *)(v13 + 16) = *(_DWORD *)*(&v11 - 3);
  *(_DWORD *)(*(&v11 - 3) + 4) = 0;
  *(_BYTE *)(v13 + 40) &= 0xFDu;
  *(_BYTE *)(v13 + 40) &= 0xFBu;
  return 1;
}
// 80649CA: using guessed type int __fastcall sub_80649CA(_DWORD, _DWORD);
// 807127C: using guessed type int dword_807127C;
// 80714A0: using guessed type int (*obstack_alloc_failed_handler)(void);

//----- (0806271D) --------------------------------------------------------
signed int __cdecl sub_806271D(int a1, signed int a2, signed int a3, int a4, int a5)
{
  *(_DWORD *)(a1 + 28) = a4;
  *(_DWORD *)(a1 + 32) = a5;
  *(_BYTE *)(a1 + 40) &= 0xFEu;
  return sub_80625F3((signed int *)a1, a2, a3);
}

//----- (080627CA) --------------------------------------------------------
int __cdecl sub_80627CA(int a1, int a2)
{
  int result; // eax
  _DWORD *v3; // [esp+14h] [ebp-24h]
  unsigned int v4; // [esp+18h] [ebp-20h]
  int v5; // [esp+1Ch] [ebp-1Ch]
  size_t n; // [esp+20h] [ebp-18h]
  size_t v7; // [esp+24h] [ebp-14h]
  size_t v8; // [esp+28h] [ebp-10h]
  void *dest; // [esp+2Ch] [ebp-Ch]

  v5 = *(_DWORD *)(a1 + 4);
  v3 = 0;
  n = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 8);
  v7 = n + a2;
  v8 = *(_DWORD *)(a1 + 24) + n + a2;
  v4 = (n >> 3) + v8 + 100;
  if ( v4 < v8 )
    v4 = v8;
  if ( *(_DWORD *)a1 > v4 )
    v4 = *(_DWORD *)a1;
  if ( n <= v7 && v7 <= v8 )
    v3 = (_DWORD *)sub_8062561(a1, v4);
  if ( !v3 )
    obstack_alloc_failed_handler();
  *(_DWORD *)(a1 + 4) = v3;
  v3[1] = v5;
  *(_DWORD *)(a1 + 16) = (char *)v3 + v4;
  *v3 = *(_DWORD *)(a1 + 16);
  dest = (void *)(((unsigned int)v3 + *(_DWORD *)(a1 + 24) + 8) & ~*(_DWORD *)(a1 + 24));
  memcpy(dest, *(const void **)(a1 + 8), n);
  if ( !(*(_BYTE *)(a1 + 40) & 2) && *(_DWORD *)(a1 + 8) == ((*(_DWORD *)(a1 + 24) + v5 + 8) & ~*(_DWORD *)(a1 + 24)) )
  {
    v3[1] = *(_DWORD *)(v5 + 4);
    sub_80625A3(a1, v5);
  }
  *(_DWORD *)(a1 + 8) = dest;
  *(_DWORD *)(a1 + 12) = n + *(_DWORD *)(a1 + 8);
  result = a1;
  *(_BYTE *)(a1 + 40) &= 0xFDu;
  return result;
}
// 80714A0: using guessed type int (*obstack_alloc_failed_handler)(void);

//----- (08062AF3) --------------------------------------------------------
int __cdecl sub_8062AF3(int a1, int a2)
{
  return (a1 == 0) ^ (a2 == 0) && a1 >= 0 && a2 >= 0;
}

//----- (08062B2B) --------------------------------------------------------
#error "8062B6E: call analysis failed (funcsize=32)"

//----- (08062B81) --------------------------------------------------------
#error "8062BF3: positive sp value has been found (funcsize=39)"

//----- (08062BF6) --------------------------------------------------------
int __cdecl sub_8062BF6(void *dest, void *src, size_t n)
{
  int v3; // ST08_4
  int result; // eax
  int v5; // [esp+10h] [ebp-8h]

  memcpy(dest, src, n);
  result = v3 + v5;
  *(_BYTE *)(v3 + v5) = 0;
  return result;
}

//----- (08062C3E) --------------------------------------------------------
int __cdecl sub_8062C3E(char *s)
{
  int *v1; // ebp
  size_t v2; // eax
  size_t v3; // eax
  int v5; // [esp+0h] [ebp-28h]
  int v6; // [esp+8h] [ebp-20h]
  size_t n; // [esp+14h] [ebp-14h]
  size_t v8; // [esp+18h] [ebp-10h]
  _DWORD *v9; // [esp+1Ch] [ebp-Ch]
  int savedregs; // [esp+28h] [ebp+0h]

  v1 = &savedregs;
  if ( s )
    v2 = strlen(s) + 1;
  else
    v2 = 0;
  n = v2;
  if ( v2 <= 0x3A )
    v3 = 59;
  else
    v3 = n + 1;
  v8 = v3;
  v9 = malloc((v3 + 12) & 0xFFFFFFF8);
  if ( v9 )
  {
    *v9 = 0;
    v1 = &v5;
    *(_BYTE *)(*(&v5 - 3) + 4) = s != 0;
    *(_BYTE *)(*(&v5 - 3) + 5) = 0;
    if ( v6 )
      sub_8062BF6((void *)(*(&v5 - 3) + 5), (void *)*(&v5 - 5), *(&v5 - 5));
  }
  return *(v1 - 3);
}

//----- (08062D08) --------------------------------------------------------
signed int __cdecl sub_8062D08(int a1, unsigned int a2)
{
  int i; // eax
  int v4; // [esp+0h] [ebp-28h]
  int v5; // [esp+4h] [ebp-24h]
  int v6; // [esp+8h] [ebp-20h]
  int v7; // [esp+Ch] [ebp-1Ch]
  char *s1; // [esp+10h] [ebp-18h]
  char *s; // [esp+14h] [ebp-14h]
  size_t n; // [esp+18h] [ebp-10h]
  int v11; // [esp+1Ch] [ebp-Ch]
  int v12; // [esp+20h] [ebp-8h]
  int v13; // [esp+24h] [ebp-4h]
  int savedregs; // [esp+28h] [ebp+0h]
  int v15; // [esp+30h] [ebp+8h]

  s1 = (char *)&unk_806A5E8;
  s = *(char **)(a2 + 40);
  if ( !s || a2 <= (unsigned int)s && a2 + 44 > (unsigned int)s )
    return 1;
  if ( *s )
  {
    s1 = (char *)(a1 + 5);
    for ( i = strcmp((const char *)(a1 + 5), s); i; i = strcmp(s1, s) )
    {
      if ( !*s1 && ((char *)(a1 + 5) != s1 || !*(_BYTE *)(a1 + 4)) )
      {
        n = strlen(s) + 1;
        v11 = (int)&s1[-a1 - 5];
        if ( ~v11 < n )
        {
          *__errno_location() = 12;
          return 0;
        }
        if ( v11 + n > 0x3A )
        {
          *(_DWORD *)a1 = sub_8062C3E(s);
          v15 = *(_DWORD *)a1;
          if ( !v15 )
          {
            dword_8071218 = (int)&locret_8062EBC;
            sub_8064C2F(v4, v5, v6, v7, s1, s, n, v11, v12, v13, savedregs);
          }
          *(_BYTE *)(v15 + 4) = 0;
          s1 = (char *)(v15 + 5);
        }
        else
        {
          sub_8062BF6(s1, s, n);
        }
        break;
      }
      s1 += strlen(s1) + 1;
      if ( !*s1 && *(_DWORD *)a1 )
      {
        a1 = *(_DWORD *)a1;
        s1 = (char *)(a1 + 5);
      }
    }
  }
  *(_DWORD *)(a2 + 40) = s1;
  return 1;
}
// 8064C2F: using guessed type int __stdcall sub_8064C2F(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8071218: using guessed type int dword_8071218;

//----- (08062EBE) --------------------------------------------------------
#error "8062EE2: call analysis failed (funcsize=29)"

//----- (08062F0E) --------------------------------------------------------
char *sub_8062F0E()
{
  return getenv("TZ");
}

//----- (08062F34) --------------------------------------------------------
int __cdecl sub_8062F34(char *value)
{
  int result; // eax

  if ( value )
    result = setenv("TZ", value, 1);
  else
    result = unsetenv("TZ");
  return result;
}

//----- (08062F6F) --------------------------------------------------------
signed int __cdecl sub_8062F6F(int a1)
{
  char *v1; // eax

  if ( *(_BYTE *)(a1 + 4) )
    v1 = (char *)(a1 + 5);
  else
    v1 = 0;
  if ( sub_8062F34(v1) )
    return 0;
  tzset();
  return 1;
}

//----- (08062FBC) --------------------------------------------------------
#error "8062FF3: call analysis failed (funcsize=92)"

//----- (080630E0) --------------------------------------------------------
int __cdecl sub_80630E0(void *ptr)
{
  unsigned __int8 v2; // [esp+1Bh] [ebp-Dh]
  int v3; // [esp+1Ch] [ebp-Ch]

  if ( ptr == (void *)1 )
    return 1;
  v3 = *__errno_location();
  v2 = sub_8062F6F((int)ptr);
  if ( v2 != 1 )
    v3 = *__errno_location();
  sub_8062EBE(ptr);
  *__errno_location() = v3;
  return v2;
}

//----- (0806314F) --------------------------------------------------------
#error "80631EB: call analysis failed (funcsize=65)"

//----- (08063221) --------------------------------------------------------
int __cdecl sub_8063221(int a1, struct tm *tp)
{
  int result; // eax
  time_t timer; // [esp+18h] [ebp-40h]
  void *ptr; // [esp+1Ch] [ebp-3Ch]
  time_t v5; // [esp+20h] [ebp-38h]
  struct tm v6; // [esp+24h] [ebp-34h]

  if ( !a1 )
    return timegm(tp);
  ptr = (void *)sub_8062FBC(a1);
  if ( !ptr )
    goto LABEL_14;
  timer = mktime(tp);
  v5 = -1;
  if ( timer != -1 || localtime_r(&timer, &v6) && sub_8062B2B(tp, &v6) )
  {
    if ( (unsigned __int8)sub_8062D08(a1, (unsigned int)tp) ^ 1 )
      timer = v5;
  }
  if ( (unsigned __int8)sub_80630E0(ptr) )
    result = timer;
  else
LABEL_14:
    result = -1;
  return result;
}
// 8062B2B: using guessed type _DWORD __cdecl sub_8062B2B(_DWORD, _DWORD);
// 8062FBC: using guessed type _DWORD __cdecl sub_8062FBC(_DWORD);

//----- (08063463) --------------------------------------------------------
int __cdecl sub_8063463(int a1, char a2)
{
  return __ROR4__(a1, a2);
}

//----- (0806359E) --------------------------------------------------------
int __cdecl sub_806359E(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // esi
  unsigned __int8 *v3; // ebx
  unsigned __int8 v5; // [esp+1Eh] [ebp-Ah]
  unsigned __int8 v6; // [esp+1Fh] [ebp-9h]

  v2 = a1;
  v3 = a2;
  if ( a1 == a2 )
    return 0;
  do
  {
    v5 = sub_8055B3A(*v2);
    v6 = sub_8055B3A(*v3);
    if ( !v5 )
      break;
    ++v2;
    ++v3;
  }
  while ( v5 == v6 );
  return v5 - v6;
}

//----- (08063607) --------------------------------------------------------
int __cdecl sub_8063607(FILE *fp)
{
  int v1; // eax
  bool v2; // zf
  void *v3; // eax
  int v5; // [esp-4h] [ebp-2Ch]
  int v6; // [esp+0h] [ebp-28h]
  int v7; // [esp+4h] [ebp-24h]
  FILE *v8; // [esp+8h] [ebp-20h]
  int v9; // [esp+Ch] [ebp-1Ch]
  int v10; // [esp+10h] [ebp-18h]
  int v11; // [esp+14h] [ebp-14h]
  int v12; // [esp+18h] [ebp-10h]
  int v13; // [esp+1Ch] [ebp-Ch]
  int v14; // [esp+20h] [ebp-8h]
  int v15; // [esp+24h] [ebp-4h]
  int savedregs; // [esp+28h] [ebp+0h]

  BYTE1(v13) = __fpending(fp) != 0;
  *((_BYTE *)&v6 - 10) = ferror_unlocked(fp) != 0;
  v1 = sub_8063DBF(v8);
  LOBYTE(v1) = v1 != 0;
  *((_BYTE *)&v6 - 9) = v1;
  if ( !*((_BYTE *)&v6 - 10) )
  {
    if ( !*((_BYTE *)&v6 - 9) )
      return 0;
    v2 = *((_BYTE *)&v6 - 11) == 0;
    v5 = v1;
    v3 = &loc_806368F;
    if ( !v2 )
      v3 = &loc_806369B;
    dword_8071218 = (int)v3;
    sub_8064C2F(v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, savedregs);
    if ( *__errno_location() == 9 )
      return 0;
  }
  if ( *((_BYTE *)&v6 - 9) != 1 )
    *__errno_location() = 0;
  return -1;
}
// 8064C2F: using guessed type int __stdcall sub_8064C2F(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8071218: using guessed type int dword_8071218;

//----- (080636BF) --------------------------------------------------------
int __usercall sub_80636BF@<eax>(int a1@<edx>, int a2@<ecx>, unsigned __int8 *a3@<ebx>, void *src)
{
  int v5; // [esp+1Ch] [ebp-Ch]

  v5 = sub_8056825(a1, a2, a3, src);
  if ( !v5 )
    sub_8061564();
  return v5;
}

//----- (080636E3) --------------------------------------------------------
int __cdecl sub_80636E3(_BYTE *a1, unsigned int a2)
{
  _BYTE *i; // [esp+0h] [ebp-8h]
  unsigned int v4; // [esp+4h] [ebp-4h]

  v4 = 0;
  for ( i = a1; *i; ++i )
    v4 = __ROR4__(v4, 23) + (char)*i;
  return v4 % a2;
}

//----- (0806374D) --------------------------------------------------------
#error "8063C0A: call analysis failed (funcsize=309)"

//----- (08063CBA) --------------------------------------------------------
#error "8063DAE: call analysis failed (funcsize=81)"

//----- (08063DBF) --------------------------------------------------------
int __cdecl sub_8063DBF(FILE *stream)
{
  FILE **v1; // ebp
  int v3; // eax
  __int64 v4; // rax
  FILE *v5; // [esp+0h] [ebp-28h]
  int v6; // [esp+4h] [ebp-24h]
  int v7; // [esp+8h] [ebp-20h]
  int v8; // [esp+Ch] [ebp-1Ch]
  int v9; // [esp+14h] [ebp-14h]
  int v10; // [esp+18h] [ebp-10h]
  int v11; // [esp+1Ch] [ebp-Ch]
  int savedregs; // [esp+28h] [ebp+0h]

  v1 = (FILE **)&savedregs;
  v9 = 0;
  v10 = 0;
  v11 = fileno(stream);
  if ( v11 < 0 )
    return fclose(stream);
  if ( !__freading(stream)
    || (v3 = fileno(stream), v1 = &v5, v8 = 1, v6 = 0, v7 = 0, LODWORD(v4) = lseek64(v3), v4 != -1) )
  {
    v5 = v1[2];
    if ( sub_8063F02(v5) )
      *(v1 - 5) = (FILE *)*__errno_location();
  }
  v5 = v1[2];
  *(v1 - 4) = (FILE *)fclose(v5);
  if ( *(v1 - 5) )
  {
    *__errno_location() = (int)*(v1 - 5);
    *(v1 - 4) = (FILE *)-1;
  }
  return (int)*(v1 - 4);
}
// 8049A70: using guessed type int __cdecl lseek64(_DWORD);

//----- (08063EA0) --------------------------------------------------------
#error "8063EC8: call analysis failed (funcsize=32)"

//----- (08063F02) --------------------------------------------------------
int __cdecl sub_8063F02(FILE *fp)
{
  if ( !fp || !__freading(fp) )
    return fflush(fp);
  sub_8063EA0(fp);
  return fflush(fp);
}

//----- (08063F46) --------------------------------------------------------
int __cdecl sub_8063F46(FILE *stream, int a2, int a3)
{
  void *v3; // eax
  int v4; // eax
  __int64 v5; // rax
  int v7; // [esp+0h] [ebp-3Ch]
  int v8; // [esp+4h] [ebp-38h]
  int v9; // [esp+8h] [ebp-34h]
  int v10; // [esp+Ch] [ebp-30h]
  int v11; // [esp+10h] [ebp-2Ch]
  int v12; // [esp+14h] [ebp-28h]
  int v13; // [esp+18h] [ebp-24h]
  int v14; // [esp+1Ch] [ebp-20h]
  int v15; // [esp+20h] [ebp-1Ch]
  int v16; // [esp+24h] [ebp-18h]
  int v17; // [esp+28h] [ebp-14h]
  int v18; // [esp+2Ch] [ebp-10h]
  int v19; // [esp+30h] [ebp-Ch]
  int v20; // [esp+34h] [ebp-8h]
  int retaddr; // [esp+3Ch] [ebp+0h]

  v3 = &loc_8063F91;
  if ( stream->_IO_read_end != stream->_IO_read_ptr )
    v3 = &loc_8064068;
  dword_8071240 = (int)v3;
  sub_8064B22(v7, v8, v9, v10, v11, v12, a2, a3, v15, v16, v17, v18, v19, v20);
  if ( stream->_IO_write_ptr == stream->_IO_write_base && !stream->_IO_save_base )
  {
    v4 = fileno(stream);
    retaddr = v13;
    LODWORD(v5) = lseek64(v4);
    if ( v5 == -1 )
      return -1;
    *(_DWORD *)v14 &= 0xFFFFFFEF;
    *(_QWORD *)(v14 + 76) = v5;
    dword_807127C = (int)&locret_8064088;
    sub_80649CA(v14, HIDWORD(v5));
  }
  retaddr = v13;
  return fseeko64(v14);
}
// 8049610: using guessed type int __cdecl fseeko64(_DWORD);
// 8049A70: using guessed type int __cdecl lseek64(_DWORD);
// 80649CA: using guessed type int __fastcall sub_80649CA(_DWORD, _DWORD);
// 8064B22: using guessed type int __stdcall sub_8064B22(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8071240: using guessed type int dword_8071240;
// 807127C: using guessed type int dword_807127C;

//----- (0806408E) --------------------------------------------------------
signed __int64 __cdecl sub_806408E(__int64 a1, unsigned int a2, signed int a3)
{
  int v3; // edx
  unsigned int v4; // ecx
  unsigned int v5; // esi
  unsigned int v6; // edi
  unsigned int v7; // ebp
  unsigned int v8; // eax
  int v9; // ecx
  unsigned int v10; // edx
  int v11; // ebp
  int v12; // ecx
  signed __int64 result; // rax
  int v14; // edx
  int v15; // edi
  unsigned __int64 v16; // rtt
  unsigned int v17; // ebp
  int v18; // esi
  unsigned __int64 v19; // rax
  int v20; // [esp+0h] [ebp-1Ch]
  unsigned int v21; // [esp+4h] [ebp-18h]
  unsigned int v22; // [esp+8h] [ebp-14h]
  unsigned int v23; // [esp+Ch] [ebp-10h]

  v3 = a1;
  v20 = 0;
  v21 = a2;
  v4 = HIDWORD(a1);
  if ( a1 < 0 )
  {
    v3 = -(signed int)a1;
    v5 = v21;
    v6 = a3;
    v4 = (unsigned __int64)-a1 >> 32;
    v20 = -1;
    if ( a3 >= 0 )
      goto LABEL_3;
  }
  else
  {
    v5 = v21;
    v6 = a3;
    if ( a3 >= 0 )
      goto LABEL_3;
  }
  v5 = -v5;
  v20 = ~v20;
  v6 = (unsigned __int64)-(signed __int64)__PAIR__(v6, v5) >> 32;
LABEL_3:
  v7 = v4;
  v22 = v3;
  v8 = v6;
  v9 = v3;
  v21 = v5;
  if ( v6 )
  {
    if ( v6 <= v7 )
    {
      _BitScanReverse(&v6, v6);
      v15 = v6 ^ 0x1F;
      if ( v15 )
      {
        v23 = (v8 << v15) | (v21 >> (32 - v15));
        v21 <<= v15;
        LODWORD(v16) = ((_DWORD)&v20 << v15) | (v22 >> (32 - v15));
        HIDWORD(v16) = (unsigned int)&v20 >> (32 - v15);
        v17 = v16 % v23;
        v18 = v16 / v23;
        v19 = v21 * (unsigned __int64)(unsigned int)v18;
        v21 = HIDWORD(v19);
        if ( v17 < HIDWORD(v19) || v22 << v15 < (unsigned int)v19 && v17 == v21 )
        {
          v12 = v18 - 1;
          v11 = 0;
        }
        else
        {
          v12 = v18;
          v11 = 0;
        }
        goto LABEL_8;
      }
      if ( v21 <= v22 || v8 < v7 )
      {
        v11 = 0;
        v12 = 1;
        goto LABEL_8;
      }
    }
    v11 = 0;
    v12 = 0;
    goto LABEL_8;
  }
  if ( v5 <= v7 )
  {
    if ( !v5 )
      v5 = 1 / 0u;
    v14 = v7 % v5;
    v11 = v7 / v5;
    v12 = __PAIR__((unsigned int)v14, v9) / v5;
  }
  else
  {
    v10 = v7;
    v11 = 0;
    v12 = __PAIR__(v10, v9) / v5;
  }
LABEL_8:
  result = __PAIR__(v11, v12);
  if ( v20 )
    result = -__PAIR__(v11, v12);
  return result;
}

//----- (08064237) --------------------------------------------------------
int __cdecl sub_8064237(__int64 a1, __int64 a2)
{
  unsigned int v2; // edx
  unsigned int v3; // ecx
  unsigned int v4; // eax
  unsigned int v5; // ecx
  __int64 *v6; // ebp
  unsigned __int64 v7; // rdi
  unsigned int v8; // esi
  unsigned __int64 v9; // rax
  int v10; // edx
  void *v11; // eax
  unsigned int v12; // ecx
  unsigned __int64 v13; // rtt
  unsigned __int64 v14; // rax
  __int64 v15; // rdi
  unsigned int v16; // ebp
  unsigned __int64 v17; // rax
  unsigned int v18; // ecx
  unsigned __int64 v19; // rdi
  __int64 v21; // [esp+0h] [ebp-2Ch]
  int v22; // [esp+Ch] [ebp-20h]
  unsigned int v23; // [esp+10h] [ebp-1Ch]
  unsigned int v24; // [esp+14h] [ebp-18h]
  int v25; // [esp+18h] [ebp-14h]
  unsigned int v26; // [esp+1Ch] [ebp-10h]

  v21 = a1;
  v22 = 0;
  if ( a1 < 0 )
  {
    v21 = -v21;
    v22 = -1;
  }
  v3 = HIDWORD(a2);
  v2 = a2;
  if ( a2 < 0 )
  {
    v2 = -(signed int)a2;
    v3 = (unsigned __int64)-a2 >> 32;
  }
  v4 = v3;
  v5 = v2;
  v23 = v2;
  v24 = v21;
  v6 = &v21;
  v7 = __PAIR__(&v21, (unsigned int)v21);
  if ( v4 )
  {
    if ( v4 <= (unsigned int)&v21 )
    {
      _BitScanReverse((unsigned int *)&v10, v4);
      LODWORD(v21) = v10 ^ 0x1F;
      if ( v10 ^ 0x1F )
      {
        v25 = 32 - v21;
        LODWORD(v7) = (v4 << v21) | (v23 >> (32 - v21));
        v26 = v23 << v21;
        HIDWORD(v14) = HIDWORD(v7) >> (32 - v21);
        LODWORD(v14) = (HIDWORD(v7) << v21) | (v24 >> (32 - v21));
        v24 <<= v21;
        HIDWORD(v7) = v14 % (unsigned int)v7;
        v17 = (unsigned int)&v21 * (unsigned __int64)(unsigned int)(v14 / (unsigned int)v7);
        v23 = HIDWORD(v17);
        v16 = HIDWORD(v17);
        HIDWORD(v17) = v17;
        v18 = v16;
        if ( HIDWORD(v7) < v16 || v24 < (unsigned int)v17 && HIDWORD(v15) == v16 )
        {
          v18 = (__PAIR__(v23, (unsigned int)v17) - __PAIR__(v15, v26)) >> 32;
          HIDWORD(v17) = v17 - v26;
        }
        LODWORD(v15) = v24;
        v19 = v15 - __PAIR__(v18, HIDWORD(v17));
        LODWORD(v9) = (HIDWORD(v19) << v25) | ((unsigned int)v19 >> (char)&v21);
        HIDWORD(v9) = HIDWORD(v19) >> (char)&v21;
      }
      else
      {
        if ( v5 <= (unsigned int)v7 || v4 < HIDWORD(v7) )
        {
          v7 -= __PAIR__(v4, v5);
          v6 = (__int64 *)HIDWORD(v7);
        }
        v9 = __PAIR__((unsigned int)v6, (unsigned int)v7);
      }
    }
    else
    {
      v9 = __PAIR__(&v21, (unsigned int)v21);
    }
  }
  else
  {
    if ( v2 <= (unsigned int)&v21 )
    {
      v11 = &loc_8064326;
      if ( v2 )
        v11 = &loc_8064331;
      dword_8071254 = (int)v11;
      sub_8064AB4();
      v12 = 1 / v12;
      LODWORD(v13) = v7;
      HIDWORD(v13) = (unsigned int)&v21 % v12;
      v8 = v13 % v12;
    }
    else
    {
      v8 = __PAIR__(&v21, v24) % v2;
    }
    v9 = v8;
  }
  if ( v22 )
    v9 = -(signed __int64)v9;
  return v9;
}
// 8071254: using guessed type int dword_8071254;

//----- (08064458) --------------------------------------------------------
int __cdecl sub_8064458(unsigned int a1, int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4; // esi
  int v6; // ebp
  int v7; // ebp
  unsigned __int64 v8; // rtt
  unsigned int v9; // esi
  unsigned int v10; // edi
  unsigned __int64 v11; // rax
  unsigned int v12; // [esp+0h] [ebp-18h]
  unsigned int v13; // [esp+4h] [ebp-14h]
  unsigned int v14; // [esp+8h] [ebp-10h]

  v13 = a1;
  v12 = a3;
  if ( a4 )
  {
    if ( a4 <= (unsigned int)&v12 )
    {
      _BitScanReverse((unsigned int *)&v6, a4);
      v7 = v6 ^ 0x1F;
      if ( v7 )
      {
        v14 = v12 >> (32 - v7);
        v14 |= a4 << v7;
        v12 <<= v7;
        LODWORD(v8) = ((_DWORD)&v12 << v7) | (v13 >> (32 - v7));
        HIDWORD(v8) = (unsigned int)&v12 >> (32 - v7);
        v9 = v8 % v14;
        v10 = v8 / v14;
        v11 = v12 * (unsigned __int64)v10;
        v12 = HIDWORD(v11);
        if ( v9 < HIDWORD(v11) || v13 << (char)&v12 < (unsigned int)v11 && v9 == v12 )
          return v10 - 1;
        dword_8071268 = (int)&loc_80644F3;
        sub_8064A3C(&v12, 0);
      }
      else if ( v12 > v13 && a4 >= (unsigned int)&v12 )
      {
        return 0;
      }
      return 1;
    }
    return 0;
  }
  if ( a3 > (unsigned int)&v12 )
    return __PAIR__(&v12, a1) / a3;
  v4 = a3;
  if ( !a3 )
    v4 = 1 / 0u;
  return __PAIR__((unsigned int)&v12 % v4, a1) / v4;
}
// 8064A3C: using guessed type int __fastcall sub_8064A3C(_DWORD, _DWORD);
// 8071268: using guessed type int dword_8071268;

//----- (080645C1) --------------------------------------------------------
int __cdecl sub_80645C1(unsigned __int64 a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // ecx
  int v4; // esi
  unsigned int v5; // eax
  unsigned int v8; // ebp
  unsigned int v9; // ebp
  unsigned __int64 v10; // rtt
  unsigned __int64 v11; // rax
  unsigned int v12; // edi
  unsigned __int64 v13; // rax
  unsigned int v14; // [esp+0h] [ebp-20h]
  unsigned int v15; // [esp+4h] [ebp-1Ch]
  unsigned __int64 v16; // [esp+8h] [ebp-18h]
  unsigned int v17; // [esp+10h] [ebp-10h]

  v3 = a1;
  v4 = a2;
  v15 = HIDWORD(a1);
  v5 = a3;
  v17 = a1;
  v14 = a2;
  v16 = a1;
  if ( a3 )
  {
    if ( a3 > HIDWORD(a1) )
      return a1;
    v8 = (unsigned int)&v14 ^ 0x1F;
    if ( &v14 == (unsigned int *)31 )
    {
      if ( v14 <= (unsigned int)v16 )
        return __PAIR__(v15, v3) - __PAIR__(v5, v4);
    }
    else
    {
      v4 = 32 - v8;
      v15 = v14 >> (32 - v8);
      v15 |= a3 << v8;
      LODWORD(v16) = v14 << v8;
      HIDWORD(v11) = HIDWORD(a1) >> (32 - v8);
      LODWORD(v11) = (HIDWORD(a1) << v8) | (v17 >> (32 - v8));
      HIDWORD(v16) = v17 << (char)&v14;
      v12 = v11 % v15;
      v13 = (v14 << v8) * (unsigned __int64)(unsigned int)(v11 / v15);
      v14 = HIDWORD(v13);
      if ( v12 >= HIDWORD(v13) && (HIDWORD(v16) >= (unsigned int)v13 || v12 != HIDWORD(v13)) )
        return ((__PAIR__(v12, HIDWORD(v16)) - v13) >> 32 << v4) | ((unsigned int)(HIDWORD(v16) - v13) >> (char)&v14);
      dword_807127C = (int)&loc_806470F;
      v5 = sub_80649CA(v13 - v16, (v13 - __PAIR__(v15, (unsigned int)v16)) >> 32);
    }
    if ( v5 >= HIDWORD(v16) )
      return v16;
    return __PAIR__(v15, v3) - __PAIR__(v5, v4);
  }
  if ( a2 > HIDWORD(a1) )
    return a1 % a2;
  v9 = a2;
  if ( !a2 )
    v9 = 1 / 0u;
  LODWORD(v10) = a1;
  HIDWORD(v10) = v15 % v9;
  return v10 % v9;
}
// 80649CA: using guessed type int __fastcall sub_80649CA(_DWORD, _DWORD);
// 807127C: using guessed type int dword_807127C;

//----- (080647EC) --------------------------------------------------------
int __cdecl sub_80647EC(int a1)
{
  return __cxa_atexit(a1, 0, dword_80712AC);
}
// 80497B0: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 80712AC: using guessed type int dword_80712AC;

//----- (0806481F) --------------------------------------------------------
int __cdecl sub_806481F(int a1, int a2)
{
  return __xstat64(3, a1, a2);
}
// 8049AE0: using guessed type int __cdecl __xstat64(_DWORD, _DWORD, _DWORD);

//----- (08064852) --------------------------------------------------------
int __cdecl sub_8064852(int a1, int a2)
{
  return __fxstat64(3, a1, a2);
}
// 8049730: using guessed type int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD);

//----- (08064885) --------------------------------------------------------
int __cdecl sub_8064885(int a1, int a2)
{
  return __lxstat64(3, a1, a2);
}
// 8049AF0: using guessed type int __cdecl __lxstat64(_DWORD, _DWORD, _DWORD);

//----- (080649CA) --------------------------------------------------------
#error "80649D0: positive sp value has been found (funcsize=0)"

//----- (08064A3C) --------------------------------------------------------
#error "8064A42: positive sp value has been found (funcsize=0)"

//----- (08064AB4) --------------------------------------------------------
#error "8064ABA: positive sp value has been found (funcsize=0)"

//----- (08064B22) --------------------------------------------------------
#error "8064B28: positive sp value has been found (funcsize=0)"

//----- (08064B74) --------------------------------------------------------
#error "8064BAD: positive sp value has been found (funcsize=18)"

//----- (08064BB5) --------------------------------------------------------
#error "8064BBB: positive sp value has been found (funcsize=0)"

//----- (08064C2F) --------------------------------------------------------
#error "8064C35: positive sp value has been found (funcsize=0)"

//----- (08064CB8) --------------------------------------------------------
#error "8064CBE: positive sp value has been found (funcsize=0)"

//----- (08064D28) --------------------------------------------------------
#error "8064D2E: positive sp value has been found (funcsize=0)"

//----- (08064D9E) --------------------------------------------------------
#error "8064DA4: positive sp value has been found (funcsize=0)"

//----- (08064DB0) --------------------------------------------------------
int (**sub_8064DB0())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_8070ED8;
  v1 = &off_8070EDC - off_8070ED8;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_8070ED8[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 8070ED8: using guessed type int (*off_8070ED8[2])();
// 8070EDC: using guessed type int (*off_8070EDC)();

//----- (08064E14) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 105 decompilation failure(s) on 391 function(s)"
