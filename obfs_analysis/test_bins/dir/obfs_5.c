/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8049480();
// int unsetenv(const char *name);
// int raise(int sig);
// int strcmp(const char *s1, const char *s2);
// int open64(void); weak
// int putc_unlocked(int c, FILE *stream);
// struct passwd *getpwuid(__uid_t uid);
// int printf(const char *format, ...);
// void longjmp(struct __jmp_buf_tag env[1], int val);
// int fflush(FILE *stream);
// void _exit(int status);
// int sigprocmask(int how, const sigset_t *set, sigset_t *oset);
// int dirfd(DIR *dirp);
// int __cdecl wcwidth(_DWORD); weak
// void *memmove(void *dest, const void *src, size_t n);
// int _setjmp(struct __jmp_buf_tag env[1]);
// void free(void *ptr);
// uintmax_t strtoumax(const char *nptr, char **endptr, int base);
// void *memcpy(void *dest, const void *src, size_t n);
// int mbsinit(const mbstate_t *ps);
// int clock_gettime(clockid_t clock_id, struct timespec *tp);
// int tolower(int c);
// int fclose(FILE *stream);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// __sighandler_t signal(int sig, __sighandler_t handler);
// int memcmp(const void *s1, const void *s2, size_t n);
// char *dcgettext(const char *domainname, const char *msgid, int category);
// time_t mktime(struct tm *tp);
// struct tm *localtime_r(const time_t *timer, struct tm *tp);
// int sigismember(const sigset_t *set, int signo);
// int fflush_unlocked(FILE *stream);
// int iswcntrl(wint_t wc);
// char *textdomain(const char *domainname);
// ssize_t readlink(const char *path, char *buf, size_t len);
// int fnmatch(const char *pattern, const char *name, int flags);
// int iswprint(wint_t wc);
// int ioctl(int fd, unsigned int request, ...);
// int ferror_unlocked(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD); weak
// void tzset(void);
// size_t __ctype_get_mb_cur_max(void);
// char *strcpy(char *dest, const char *src);
// size_t __fpending(FILE *fp);
// size_t wcstombs(char *s, const wchar_t *pwcs, size_t n);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int gethostname(char *name, size_t len);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// void error(int status, int errnum, const char *format, ...);
// int strcoll(const char *s1, const char *s2);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// time_t timegm(struct tm *tp);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// size_t strftime(char *s, size_t maxsize, const char *format, const struct tm *tp);
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// char *strchr(const char *s, int c);
// char *getcwd(char *buf, size_t size);
// size_t strlen(const char *s);
// int setenv(const char *name, const char *value, int replace);
// int fprintf(FILE *stream, const char *format, ...);
// int sigaddset(sigset_t *set, int signo);
// void *memset(void *s, int c, size_t n);
// int *__errno_location(void);
// __pid_t tcgetpgrp(int fd);
// int fileno(FILE *stream);
// int __cdecl stpncpy(_DWORD, _DWORD, _DWORD); weak
// unsigned int gnu_dev_major(unsigned __int64 dev);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// int __cdecl mempcpy(_DWORD, _DWORD, _DWORD); weak
// int __cdecl wcswidth(_DWORD, _DWORD); weak
// int sigemptyset(sigset_t *set);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// int toupper(int c);
// char *strrchr(const char *s, int c);
// size_t mbstowcs(wchar_t *pwcs, const char *s, size_t n);
// struct tm *gmtime_r(const time_t *timer, struct tm *tp);
// unsigned int gnu_dev_minor(unsigned __int64 dev);
// int sprintf(char *s, const char *format, ...);
// struct lconv *localeconv(void);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int readdir64(void); weak
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// char *bindtextdomain(const char *domainname, const char *dirname);
// int strncmp(const char *s1, const char *s2, size_t n);
// int isatty(int fd);
// void abort(void);
// int __cdecl __xstat64(_DWORD, _DWORD, _DWORD); weak
// int __cdecl __lxstat64(_DWORD, _DWORD, _DWORD); weak
// int close(int fd);
// int closedir(DIR *dirp);
// size_t strspn(const char *s, const char *accept);
// DIR *opendir(const char *name);
// struct group *getgrgid(__gid_t gid);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// void *calloc(size_t nmemb, size_t size);
// int putchar_unlocked(int c);
// int _gmon_start__(void); weak
void sub_8049BE3();
void sub_8049C00();
int sub_8049C10();
int sub_8049C80();
int sub_8049CA0();
void sub_8049CFF();
void sub_8049D1A();
int sub_8049D2A();
int nullsub_3(void); // weak
int sub_8049D88();
void sub_8049E28();
void sub_8049E43();
signed int sub_8049E53();
void sub_8049F35();
void sub_8049F50();
int sub_8049F60();
void sub_804A042();
void sub_804A05D();
int sub_804A06D();
void sub_804A14F();
void sub_804A16A();
int sub_804A17A();
void sub_804A26E();
void sub_804A289();
int sub_804A299();
void sub_804A37B();
void sub_804A396();
int sub_804A3A6();
int nullsub_4(void); // weak
int sub_804A404();
void sub_804A4A4();
void sub_804A4BF();
int sub_804A4CF();
void sub_804A5B1();
void sub_804A5CC();
int sub_804A5DC();
void sub_804A6BE();
void sub_804A6D9();
int sub_804A6E9();
int sub_804A715();
// int __usercall sub_804A7B4@<eax>(void (__cdecl *a1)(int *)@<eax>);
void sub_804A800();
void sub_804A81B();
void sub_804A926();
void sub_804A973();
int sub_804A983();
// int __usercall sub_804AA0A@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
void sub_804AAAD();
void sub_804AAE6();
int sub_804AB18();
int __cdecl sub_804ABEB(int a1);
int __cdecl sub_804ABFE(char a1);
int __cdecl sub_804AC32(_BYTE *a1);
int sub_804ACD7();
int sub_804AD0C();
int __cdecl sub_804AD37(char *s1); // idb
int __cdecl sub_804AED5(int a1, int a2);
int __cdecl sub_804AEF4(int a1);
bool __cdecl sub_804AF00(int a1);
int sub_804AF10();
_DWORD __cdecl sub_804AF1E(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl sub_804AFFE(_DWORD); // weak
unsigned int __cdecl sub_804B0E2(int a1, int a2);
_BYTE *__cdecl sub_804B22D(_BYTE *a1);
void sub_804B274();
signed int sub_804B2E6();
int sub_804B41E();
int __cdecl sub_804B6AE(unsigned __int64 *a1, unsigned int a2);
int __cdecl sub_804B6F5(int a1, _QWORD *a2);
void __cdecl sub_804B779(void *ptr);
_DWORD __cdecl sub_804B78C(_DWORD, _DWORD, _DWORD); // weak
void __cdecl sub_804B8C7(void *ptr);
// int __usercall sub_804B915@<eax>(int a1@<ebx>, int a2);
size_t sub_804B9DF();
// size_t __usercall sub_804B9FF@<eax>(int a1@<ebx>);
int __cdecl sub_804BA68(int a1);
int sub_804BA7E();
int sub_804BA99(void); // weak
__sighandler_t __cdecl sub_804BB96(void (*a1)(int));
__sighandler_t sub_804BD69();
__sighandler_t sub_804BD7D();
int __cdecl main(int, char **, char **); // idb
signed int __cdecl sub_804C52A(char *a1);
_DWORD __cdecl sub_804C5B2(_DWORD); // weak
_DWORD __cdecl sub_804D7BD(_DWORD, _DWORD, _DWORD); // weak
signed int sub_804DBE4();
int sub_804DCA0(void); // weak
_DWORD sub_804E113(); // weak
int __cdecl sub_804E1CF(int a1);
int __cdecl sub_804E212(int, char *format, int); // idb
int __cdecl sub_804E26C(char *, char *s, int); // idb
_DWORD __cdecl sub_804E330(_DWORD, _DWORD, _DWORD); // weak
_DWORD *__cdecl sub_804EAD2(int a1);
int __cdecl sub_804EB15(int, char *name); // idb
int __cdecl sub_804EB80(_BYTE *a1);
_DWORD sub_804EC4F(); // weak
int sub_804EC8E();
void __cdecl sub_804ECE6(void **a1);
int sub_804ED76();
int __cdecl sub_804EE60(int a1);
_DWORD __cdecl sub_804EE96(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl sub_804EF92(_DWORD, _DWORD); // weak
_DWORD sub_804F074(); // weak
_DWORD sub_804F13B(); // weak
int __cdecl sub_804F15D(int a1, const char *s);
_DWORD __cdecl sub_804F1D3(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_804F20C(char *file, unsigned int line, char *function, int, int, int, int, char); // idb
_DWORD __cdecl sub_80501EC(_DWORD); // weak
int __cdecl sub_8050233(char *path, int, int); // idb
int __cdecl sub_805029C(int, char *s); // idb
int __cdecl sub_8050372(int a1);
int __cdecl sub_8050397(char *s, int); // idb
int __cdecl sub_8050564(char *s1, char *s2); // idb
int __cdecl sub_805061E(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD));
_DWORD __cdecl sub_80506AC(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_805075A(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD));
_DWORD __cdecl sub_80507DA(_DWORD, _DWORD, _DWORD); // weak
int sub_805089D();
int __cdecl sub_80508CF(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_805098A(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80509AC(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80509CE(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80509F0(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8050A12(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8050A80(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8050B9F(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8050C0D(int a1, int a2);
int __cdecl sub_8050C2F(int a1, int a2);
int __cdecl sub_8050C51(int a1, int a2);
int __cdecl sub_8050C73(int a1, int a2);
signed int __cdecl sub_8050C95(int a1, int a2);
signed int __cdecl sub_8050E3B(int a1, int a2);
int __cdecl sub_8050EBE(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8050EE0(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8050F02(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8050F24(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8050F46(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8050FCD(_DWORD *a1, _DWORD *a2);
int __cdecl sub_805103B(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8051145(int a1, int a2);
int __cdecl sub_8051167(int a1, int a2);
int __cdecl sub_8051189(int a1, int a2);
int __cdecl sub_80511AB(int a1, int a2);
signed int __cdecl sub_8051265(int a1, int a2);
signed int __cdecl sub_80512EC(int a1, int a2);
signed int __cdecl sub_805136F(int a1, int a2);
int sub_80513DD();
int sub_80513FF();
int sub_8051421();
int sub_8051447();
int __cdecl sub_805159D(int a1, int a2);
int __cdecl sub_8051624(int a1, int a2);
int __cdecl sub_8051692(int a1, int a2);
int __cdecl sub_80516B4(int a1, int a2);
int __cdecl sub_80516D6(int a1, int a2);
int __cdecl sub_80516F8(int a1, int a2);
int __cdecl sub_80517B6(int a1, int a2);
int __cdecl sub_8051824(int a1, int a2);
int __cdecl sub_8051947(char **a1, char **a2);
int __cdecl sub_8051965(char **a1, char **a2);
int __cdecl sub_805197F(char **a1, char **a2);
int __cdecl sub_8051999(char **a1, char **a2);
signed int __cdecl sub_8051A31(int a1, int a2);
int sub_8051AD9();
int sub_8051B35();
int sub_8051C96();
int __cdecl sub_8051DCC(int a1, int a2, unsigned __int8 a3, int a4, int a5, int a6);
// int __usercall sub_8051E64@<eax>(int a1@<ebx>);
int __cdecl sub_8051F4C(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_8052069(__uid_t uid, int, int); // idb
int __cdecl sub_80520C0(__gid_t gid, int, int); // idb
// size_t __usercall sub_8052117@<eax>(int a1@<ebx>, char *a2, int a3);
// size_t __usercall sub_8052195@<eax>(int a1@<ebx>, __uid_t uid);
int __cdecl sub_80521CD(__gid_t gid); // idb
_DWORD __cdecl sub_805223C(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_80522FA(int c, size_t n, FILE *stream, FILE *, int, int, int); // idb
_DWORD __cdecl sub_8052F38(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_805344F(void *a1, int a2, int a3);
int __cdecl sub_8053533(char *s, int); // idb
// int __usercall sub_8053665@<eax>(int a1@<ebx>, void *a2, int a3, int a4, int a5, char a6, int a7, char *a8);
// int __usercall sub_8053B1C@<eax>(int a1@<ebx>, void **a2, unsigned __int8 a3, int a4, unsigned int a5);
size_t sub_8053C7E();
// int __usercall sub_8053CD1@<eax>(int a1@<ebx>, int a2, unsigned int a3);
_DWORD __cdecl sub_8053EEE(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_80540BC(_DWORD, _DWORD, _DWORD); // weak
// bool __usercall sub_8054136@<al>(int a1@<ebx>, int a2);
_DWORD __cdecl sub_8054187(_DWORD, _DWORD); // weak
size_t __cdecl sub_805459D(int a1);
// int __usercall sub_8054601@<eax>(int a1@<ebx>, int a2);
// unsigned int __usercall sub_805485E@<eax>(int a1@<ebx>);
// int __usercall sub_80549BC@<eax>(int a1@<ebx>);
// int __usercall sub_8054B08@<eax>(int a1@<ebx>, char a2);
unsigned int sub_8054C0A();
_BYTE *__cdecl sub_8054CBB(_BYTE *a1, _BYTE *a2, _BYTE *a3);
int __cdecl sub_8054F9B(_DWORD); // weak
void __cdecl __noreturn sub_8055242(int status); // idb
int __cdecl sub_80555C4(char *path, int); // idb
void __noreturn sub_8055716();
int __cdecl sub_805572A(char *s, int, int, size_t); // idb
void __cdecl sub_805585A(int a1, int a2, int a3);
int __cdecl sub_8055901(int, int, size_t n); // idb
int __cdecl sub_8055A2C(int, char *s, int, int, size_t n, int); // idb
int __cdecl sub_8055B6A(signed int a1);
_DWORD __cdecl sub_8055BEA(_DWORD); // weak
_BOOL4 __cdecl sub_8055CC2(int a1);
int __cdecl sub_8055DF9(int a1);
int __cdecl sub_8055E2F();
_DWORD __cdecl sub_8055EFB(_DWORD, _DWORD); // weak
int __cdecl sub_8055F49(int c, size_t n); // idb
int sub_8056903();
_DWORD __cdecl sub_80569FC(_DWORD); // weak
int __cdecl sub_8056ABC(void *src); // idb
_DWORD __cdecl sub_8056B5B(_DWORD); // weak
int __cdecl sub_8056C06(char *s); // idb
int sub_8056C66();
void __cdecl sub_8056C70();
bool __cdecl sub_8056D33(int a1, int a2, int *a3);
_DWORD __cdecl sub_8056D96(_DWORD); // weak
_DWORD __cdecl sub_8056E9B(_DWORD, _DWORD); // weak
int __cdecl sub_8057096(int a1, int a2);
int __cdecl sub_80570B7(int a1);
_BYTE *__cdecl sub_80570E9(_BYTE *a1);
_DWORD __cdecl sub_8057109(_DWORD); // weak
// int __usercall sub_805728B@<eax>(int a1@<edx>, int a2@<ecx>, int *a3);
_DWORD __cdecl sub_80573B9(_DWORD); // weak
_DWORD __cdecl sub_8057423(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_8057665(char *s1, char *s2); // idb
int __cdecl sub_80578FC(struct timespec *tp); // idb
int __cdecl sub_8057964(int category); // idb
int __cdecl sub_80579ED(int a1);
int __cdecl sub_80579F8(int a1);
int __cdecl sub_8057A07(int a1);
int __cdecl sub_8057C7C(_DWORD *a1, int a2);
_DWORD __cdecl sub_8057CCC(_DWORD, _DWORD); // weak
bool __cdecl sub_8058012(unsigned int a1);
int __cdecl sub_805806D(unsigned int a1);
unsigned int __cdecl sub_80580EE(int a1, unsigned int a2);
bool __cdecl sub_805811D(int a1, int a2);
signed int __cdecl sub_805812B(int a1);
unsigned int __cdecl sub_80581F1(unsigned int a1, int a2);
int __cdecl sub_80582A2(unsigned int a1, void *a2, unsigned int (__cdecl *a3)(int a1, unsigned int a2), bool (__cdecl *a4)(int a1, int a2), int a5);
void __cdecl sub_8058507(void *a1);
void *__cdecl sub_805860C(int a1);
int __cdecl sub_8058657(int a1, _DWORD *a2);
_DWORD __cdecl sub_805868A(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl sub_805888B(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl sub_8058A80(_DWORD, _DWORD); // weak
_DWORD __cdecl sub_8058C91(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_8058F7E(int a1, int a2);
_DWORD __cdecl sub_8058FBD(_DWORD, _DWORD); // weak
int __cdecl sub_8059223(int *a1, unsigned int a2);
int __cdecl sub_80593E5(int a1, int a2);
void __cdecl sub_8059485(void **a1);
int __cdecl sub_80594AF(int, _TBYTE); // idb
char *__cdecl sub_8059624(int a1, size_t n, int a3, int a4);
int __cdecl sub_8059747(int, int, char *s, int, int, int, int, int); // idb
int sub_805A4E8(void); // weak
int __cdecl sub_805A53D(char *s, int, int); // idb
int __cdecl sub_805A6B8(char *s, int, int); // idb
int __cdecl sub_805A701(__uid_t uid); // idb
char *__cdecl sub_805A964(__gid_t gid);
_DWORD __cdecl sub_805AB62(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_805ACBC(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_805ACE0(int a1, int a2, int a3, int a4);
int __cdecl sub_805AD8F(wint_t *a1);
int __cdecl sub_805ADD6(_DWORD *a1, unsigned int a2);
_BYTE *__cdecl sub_805AE54(_BYTE *a1, unsigned int a2, int a3);
int __cdecl sub_805AEA7(char *s, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_805B34F@<eax>(int a1@<ebx>, char *s, int a3);
// int __usercall sub_805B378@<eax>(int a1@<ebx>, char *a2, int a3, char a4);
void *__cdecl sub_805B671();
int __cdecl sub_805B829(int, int, void *dest, int); // idb
int __cdecl sub_805BA9D(int a1, int a2, int a3);
int __cdecl sub_805BAED(int a1, int a2, int a3);
int __cdecl sub_805BB31(int a1, int a2, int a3);
int __cdecl sub_805BB9A(int a1, int a2);
int __cdecl sub_805BBF7(int a1, int a2, int a3, int a4, int a5, int a6);
_DWORD __cdecl sub_805BC58(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_805E961(char *s); // idb
_DWORD __cdecl sub_805EA75(_DWORD); // weak
_DWORD __cdecl sub_805EAD0(_DWORD); // weak
int *__cdecl sub_805EB19(int *a1, int a2);
int __cdecl sub_805EB43(int *a1, unsigned __int8 a2, char a3);
int *__cdecl sub_805EC24(int *a1, int a2, int a3);
_DWORD *__stdcall sub_805EC65(int a1);
const char *__cdecl sub_805ED2B(char *msgid, int a2);
_DWORD __cdecl sub_805EDEB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_805EE83(void *s2, size_t n, mbstate_t *p, int, int, int, int, int); // idb
int __cdecl sub_805FC0C(int a1, int a2, int a3, int a4, int *a5);
void *__cdecl sub_805FCF0(int a1, int a2, _DWORD *a3, int *a4);
_DWORD __cdecl sub_805FED4(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_8060172(int a1, int a2);
int __cdecl sub_80601BE(int a1, int a2, int a3);
int __cdecl sub_8060238(int a1, int a2, int a3);
int __cdecl sub_8060286(int a1, int a2, int a3, int a4);
int __cdecl sub_80602C7(int a1, int a2);
int __cdecl sub_8060326(int a1, int a2, unsigned __int8 a3);
_DWORD __cdecl sub_80603E0(_DWORD, _DWORD); // weak
int __cdecl sub_8060442(int a1);
int __cdecl sub_8060483(int a1, int a2, int a3);
int sub_8060538();
int sub_806057C();
int __cdecl sub_80606C6(int a1, int a2, int a3);
int __cdecl sub_806072F(int a1, int a2);
int __cdecl sub_8060751(int a1);
int __cdecl sub_806079C(void *src, void *); // idb
void sub_80609CE();
_DWORD sub_8060A1F(); // weak
signed int sub_8060A6C();
// _DWORD *__userpurge sub_8060BC8@<eax>(_DWORD *a1, int a2);
// _DWORD *__userpurge sub_8060BF3@<eax>(_DWORD *a1, int a2);
// _DWORD *__userpurge sub_8060C22@<eax>(_DWORD *a1, int a2);
int __cdecl sub_8060CD3(int a1, int a2, int a3, int a4);
int __cdecl sub_8060D8C(FILE *stream, int, int, int, int, int); // idb
int __cdecl sub_806144D(FILE *stream, int, int, int, int); // idb
int sub_80614C7(FILE *stream, int a2, int a3, int a4, ...);
void *__cdecl sub_8061577(unsigned int a1, unsigned int a2);
void *__cdecl sub_80615E7(void *ptr, int a2, int a3);
// void *__usercall sub_806162C@<eax>(int a1@<edx>, int a2@<ecx>, void *ptr, int a4, int a5);
void *__cdecl sub_80616E0(size_t size);
void *__cdecl sub_80616F7(size_t size);
void *__cdecl sub_8061746(void *ptr, size_t size);
// void *__usercall sub_80617AE@<eax>(int a1@<edx>, int a2@<ecx>, void *ptr, int a4);
int __cdecl sub_8061857(int, size_t size); // idb
int __cdecl sub_80618B5(char *s); // idb
void __noreturn sub_80618DE();
int __cdecl sub_8061927(char *nptr, int base, int, int, int, int, char *s, int, int status); // idb
char *sub_8061B40();
int sub_8061B7D(void); // weak
signed int __cdecl sub_8061CBE(unsigned int *a1, unsigned int a2);
int __cdecl sub_8061D16(int a1, int a2, int a3);
int __cdecl sub_8061D87(char *nptr, int a2, int base);
_DWORD __cdecl sub_8062226(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
void __cdecl __noreturn sub_806233F(int a1, int a2, char a3, int a4, int a5);
_DWORD __cdecl sub_8062396(_DWORD, _DWORD); // weak
int __cdecl sub_8062470(int a1, int a2, int a3);
int __cdecl sub_80624A6();
size_t __cdecl sub_8062921(wchar_t *pwc, char *s, size_t n, mbstate_t *p);
int __cdecl sub_8062997(int a1, int a2);
int __cdecl sub_80629EE(int a1, int a2);
signed int __cdecl sub_8062A30(int a1, signed int a2, signed int a3);
signed int __cdecl sub_8062B33(int a1, signed int a2, signed int a3, int a4, int a5);
_DWORD __cdecl sub_8062BDC(_DWORD, _DWORD); // weak
int __cdecl sub_8062F70(int a1, int a2);
_BOOL4 __cdecl sub_8062FA8(_DWORD *a1, _DWORD *a2);
char *__cdecl sub_806306A(void *dest, void *src, size_t n);
int __cdecl sub_8063096(_DWORD); // weak
signed int __cdecl sub_8063192(int a1, unsigned int a2);
void *__cdecl sub_8063366(void *ptr);
char *sub_806339D();
int __cdecl sub_80633B1(char *value); // idb
_DWORD __cdecl sub_80633FA(_DWORD); // weak
signed int __cdecl sub_8063450(int a1);
int __cdecl sub_8063523(void *ptr); // idb
int __cdecl sub_8063586(int, time_t *timer, struct tm *tp); // idb
int __cdecl sub_8063671(int, struct tm *tp); // idb
int __cdecl sub_80638A9(int a1, char a2);
int __cdecl sub_80639E9(int a1, int a2);
int __cdecl sub_8063A8D(FILE *fp); // idb
int __cdecl sub_8063B2B(void *src); // idb
int __cdecl sub_8063B53(int a1);
int sub_8063BB3(void); // weak
const char *sub_806413E();
int __cdecl sub_80641F5(FILE *stream); // idb
int __cdecl sub_80642DD(FILE *stream); // idb
int __cdecl sub_806431A(FILE *fp); // idb
int __cdecl sub_806435E(FILE *stream, int, int, int); // idb
// int __usercall sub_8064496@<eax>(int a1@<esi>, __int64 a2, unsigned int a3, signed int a4);
_DWORD __cdecl sub_806465D(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl sub_806489E(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_8064A2C(unsigned __int64 a1, __int64 a2);
int __cdecl sub_8064C41(int a1);
int __cdecl sub_8064C92(int a1, int a2);
int __cdecl sub_8064CE1(int a1, int a2);
int __cdecl sub_8064D30(int a1, int a2);
int __fastcall sub_8064E79(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int sub_8064EEB(void); // weak
int __stdcall sub_8064F57(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __fastcall sub_8064FC3(_DWORD, _DWORD, _DWORD);
int __stdcall sub_8065037(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_80650A5();
int __stdcall sub_8065115(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_8065187(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_80651FD(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __fastcall sub_806526B(_DWORD, _DWORD, _DWORD);
int (**sub_8065280())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_804AC7D; // weak
_UNKNOWN loc_804ACD0; // weak
_UNKNOWN loc_804B32C; // weak
_UNKNOWN loc_804B40B; // weak
_UNKNOWN loc_804B471; // weak
_UNKNOWN loc_804B49D; // weak
_UNKNOWN loc_804B4C0; // weak
_UNKNOWN loc_804B4C5; // weak
_UNKNOWN loc_804B96E; // weak
_UNKNOWN loc_804B980; // weak
_UNKNOWN loc_804B9CE; // weak
_UNKNOWN loc_804B9D5; // weak
_UNKNOWN loc_804BD31; // weak
_UNKNOWN loc_804BD4E; // weak
_UNKNOWN locret_804DC9E; // weak
_UNKNOWN loc_804EBC0; // weak
_UNKNOWN loc_804EC3E; // weak
_UNKNOWN loc_804ED44; // weak
_UNKNOWN loc_804ED66; // weak
_UNKNOWN locret_8050370; // weak
_UNKNOWN loc_80504CA; // weak
_UNKNOWN loc_80504D5; // weak
_UNKNOWN locret_8050B01; // weak
_UNKNOWN locret_8050EBC; // weak
_UNKNOWN loc_8050FAA; // weak
_UNKNOWN loc_8050FB1; // weak
_UNKNOWN loc_80512B1; // weak
_UNKNOWN loc_80512B8; // weak
_UNKNOWN locret_805136D; // weak
_UNKNOWN loc_8051601; // weak
_UNKNOWN loc_8051608; // weak
_UNKNOWN loc_8051897; // weak
_UNKNOWN loc_80518A4; // weak
_UNKNOWN locret_80518BE; // weak
_UNKNOWN loc_80519DA; // weak
_UNKNOWN loc_80519EC; // weak
_UNKNOWN loc_8051A10; // weak
_UNKNOWN loc_8051A1D; // weak
_UNKNOWN loc_8051A9F; // weak
_UNKNOWN loc_8051ABE; // weak
_UNKNOWN loc_8051AC5; // weak
_UNKNOWN loc_8051BDE; // weak
_UNKNOWN loc_8051BE4; // weak
_UNKNOWN loc_805373A; // weak
_UNKNOWN loc_805375C; // weak
_UNKNOWN loc_805382B; // weak
_UNKNOWN loc_80546B0; // weak
_UNKNOWN loc_8054751; // weak
_UNKNOWN loc_80549AE; // weak
_UNKNOWN loc_80555B9; // weak
_UNKNOWN loc_805567F; // weak
_UNKNOWN loc_80556A5; // weak
_UNKNOWN loc_805570F; // weak
_UNKNOWN loc_805582B; // weak
_UNKNOWN loc_8055B8E; // weak
_UNKNOWN loc_8055BBF; // weak
_UNKNOWN loc_8055BE8; // weak
_UNKNOWN loc_80569CB; // weak
_UNKNOWN loc_8056D26; // weak
_UNKNOWN locret_8056D31; // weak
_UNKNOWN loc_8057307; // weak
_UNKNOWN loc_8057313; // weak
_UNKNOWN loc_8057397; // weak
_UNKNOWN loc_80579BA; // weak
_UNKNOWN loc_80579D1; // weak
_UNKNOWN loc_80583EC; // weak
_UNKNOWN locret_80583FC; // weak
_UNKNOWN loc_80585B2; // weak
_UNKNOWN loc_805A6A9; // weak
_UNKNOWN loc_805AFD2; // weak
_UNKNOWN loc_805B013; // weak
_UNKNOWN loc_805B130; // weak
_UNKNOWN loc_805B16D; // weak
_UNKNOWN loc_805B174; // weak
_UNKNOWN loc_805B232; // weak
_UNKNOWN loc_805B409; // weak
_UNKNOWN loc_805B423; // weak
_UNKNOWN loc_805B4C8; // weak
_UNKNOWN loc_805B4D7; // weak
_UNKNOWN loc_805B568; // weak
_UNKNOWN loc_805B5E4; // weak
_UNKNOWN loc_805B5F5; // weak
_UNKNOWN loc_805BB84; // weak
_UNKNOWN loc_8060846; // weak
_UNKNOWN loc_8060CF9; // weak
_UNKNOWN loc_8060D24; // weak
_UNKNOWN loc_8061659; // weak
_UNKNOWN loc_8061693; // weak
_UNKNOWN loc_806173C; // weak
_UNKNOWN loc_8061741; // weak
_UNKNOWN locret_80617AC; // weak
_UNKNOWN loc_8061D25; // weak
_UNKNOWN loc_8061D82; // weak
_UNKNOWN loc_8061E15; // weak
_UNKNOWN loc_8061E52; // weak
_UNKNOWN loc_8061E5C; // weak
_UNKNOWN loc_80625C9; // weak
_UNKNOWN loc_8062603; // weak
_UNKNOWN locret_806291F; // weak
_UNKNOWN locret_80629EC; // weak
_UNKNOWN loc_80631EE; // weak
_UNKNOWN loc_8063356; // weak
_UNKNOWN loc_806347D; // weak
_UNKNOWN loc_80634B2; // weak
_UNKNOWN loc_8063A36; // weak
_UNKNOWN loc_8063A3D; // weak
_UNKNOWN loc_8063AF1; // weak
_UNKNOWN loc_8063B20; // weak
_UNKNOWN loc_8064255; // weak
_UNKNOWN loc_806428E; // weak
_UNKNOWN loc_80643A9; // weak
_UNKNOWN loc_80643D2; // weak
_UNKNOWN loc_8064460; // weak
_UNKNOWN loc_806450D; // weak
char locale = '\0'; // idb
_UNKNOWN unk_8066789; // weak
int (__cdecl *off_8067B20[28])(int, int) =
{
  &sub_80513DD,
  &sub_8051469,
  &sub_8051421,
  &sub_805159D,
  &sub_80513FF,
  &sub_805151A,
  &sub_8051447,
  &sub_8051624,
  &sub_8051692,
  &sub_805171A,
  &sub_80516D6,
  &sub_8051824,
  &sub_80516B4,
  &sub_80517B6,
  &sub_80516F8,
  &sub_80518C0,
  &sub_8051145,
  &sub_80511CD,
  &sub_8051189,
  &sub_80512EC,
  &sub_8051167,
  &sub_8051265,
  &sub_80511AB,
  &sub_805136F,
  &sub_8051965,
  &sub_8051999,
  &sub_805197F,
  &sub_8051A31
}; // weak
void *off_8067C1C = &loc_8051D7E; // weak
int sig[12] = { 20, 14, 1, 2, 13, 3, 15, 29, 27, 26, 24, 25 }; // idb
_UNKNOWN unk_8069B08; // weak
char *off_8069BDC[2] = { "human-readable", "si" }; // weak
int dword_8069BE8[2] = { 176, 144 }; // idb
_UNKNOWN unk_8069C6C; // weak
_UNKNOWN unk_8069FAE; // weak
_UNKNOWN unk_8069FB2; // weak
_UNKNOWN unk_8069FBE; // weak
_UNKNOWN unk_8069FC2; // weak
_UNKNOWN unk_8069FC5; // weak
_UNKNOWN unk_806AAC0; // weak
_UNKNOWN unk_806AB1B; // weak
int dword_806CF04 = 1765474303; // weak
_UNKNOWN unk_806D3A8; // weak
_UNKNOWN unk_806D3AB; // weak
_UNKNOWN unk_806E3E4; // weak
_UNKNOWN unk_806E3E7; // weak
_UNKNOWN unk_806F40C; // weak
_UNKNOWN unk_806F40F; // weak
int (*off_8070ED4[2])() = { &sub_8049CA0, &sub_8049C80 }; // weak
int (*off_8070ED8)() = &sub_8049C80; // weak
int (*dword_8071008)(void) = NULL; // weak
int dword_80711DC = 0; // weak
int dword_80711F0 = 0; // weak
int dword_8071204 = 0; // weak
int dword_8071218 = 0; // weak
int dword_807122C = 0; // weak
int dword_8071240 = 0; // weak
int dword_8071254 = 0; // weak
int dword_8071268 = 0; // weak
int dword_807127C = 0; // weak
int dword_8071290 = 0; // weak
int dword_80712C0 = 0; // weak
_UNKNOWN unk_80712DC; // weak
int dword_80712FC[] = { 2 }; // weak
void *s1 = &unk_8066784; // idb
int dword_8071304 = 1; // weak
_UNKNOWN unk_807130C; // weak
int dword_8071310 = 0; // weak
_UNKNOWN unk_8071314; // weak
_UNKNOWN unk_807131C; // weak
_UNKNOWN unk_80713B4; // weak
char *off_80713BC = "%b %e  %Y"; // idb
int dword_80713C8 = 4294967295; // weak
int dword_8071404 = 2; // weak
int status = 1; // idb
_UNKNOWN unk_807143C; // weak
_UNKNOWN unk_807145C; // weak
_UNKNOWN unk_807145F; // weak
_UNKNOWN unk_8071464; // weak
_UNKNOWN unk_8071467; // weak
_UNKNOWN unk_8071468; // weak
_UNKNOWN unk_807146B; // weak
_UNKNOWN unk_8071470; // weak
_UNKNOWN unk_8071473; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
FILE *stdout; // idb
int (*obstack_alloc_failed_handler)(void); // weak
char byte_80714CC; // weak
_UNKNOWN unk_80715B7; // weak
void *dword_80718A9; // idb
void *dword_80718AD; // idb
int dword_80718B5; // weak
char byte_80718B9; // weak
char byte_80718BA; // weak
void *dword_80718BD; // idb
int dword_80718C1; // weak
char *dword_80718C9; // idb
char byte_80718D9; // weak
char byte_80718DA; // weak
int dword_80718DD; // weak
int dword_80718E1; // weak
int dword_80718E5; // weak
int dword_80718E9; // weak
int dword_80718ED; // idb
int dword_80718F1; // idb
int dword_80718F5; // idb
int dword_80718F9; // weak
int dword_80718FD; // weak
int dword_8071901; // weak
int dword_8071905; // weak
int dword_8071909; // weak
int dword_807190D; // weak
char byte_8071911; // weak
char byte_8071913; // weak
char byte_8071914; // weak
int dword_8071915; // idb
int qword_8071919; // idb
char byte_8071925; // weak
int dword_8071929; // weak
char byte_807192D; // weak
char byte_807192F; // weak
char byte_807193A; // weak
char byte_8071943; // weak
int dword_8071945; // weak
int dword_8071949; // idb
int dword_807194D; // idb
int dword_8071955; // weak
int dword_807195D; // weak
int dword_8071965; // weak
int dword_8071969; // idb
sigset_t set; // idb
int dword_8071A09; // weak
int dword_8071A0D; // weak
int dword_8071A11; // weak
void *dword_8071A15; // idb
int dword_8071A1D; // weak
char byte_80727E9; // weak
struct __jmp_buf_tag env[1]; // idb
int dword_80728C5; // weak
char byte_80728C9; // weak
int dword_80728D5; // weak
int dword_80728DD; // weak
int dword_80728E9; // weak
int dword_80728ED; // weak
int dword_80728F1; // weak
int dword_80728F5; // weak
int dword_80728F9; // weak
int dword_80728FD; // weak
int dword_8072901; // weak
int dword_8072905; // weak
int dword_8072909; // weak
int dword_807290D; // weak
int dword_8072911; // weak
int dword_8072915; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (0804945C) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 8049BA0: using guessed type int _gmon_start__(void);

//----- (08049480) --------------------------------------------------------
int sub_8049480()
{
  return dword_8071008();
}
// 8071008: using guessed type int (*dword_8071008)(void);

//----- (08049BB0) --------------------------------------------------------
#error "8049BB3: positive sp value has been found (funcsize=2)"

//----- (08049BE3) --------------------------------------------------------
void sub_8049BE3()
{
  ;
}

//----- (08049C00) --------------------------------------------------------
void sub_8049C00()
{
  ;
}

//----- (08049C10) --------------------------------------------------------
int sub_8049C10()
{
  int result; // eax

  result = &unk_8071473 - &unk_8071470;
  if ( (unsigned int)(&unk_8071473 - &unk_8071470) > 6 )
    result = 0;
  return result;
}
// 8049C10: could not find valid save-restore pair for ebp

//----- (08049C80) --------------------------------------------------------
int sub_8049C80()
{
  int result; // eax

  if ( !byte_80714CC )
  {
    result = sub_8049C10();
    byte_80714CC = 1;
  }
  return result;
}
// 8049C80: could not find valid save-restore pair for ebp
// 80714CC: using guessed type char byte_80714CC;

//----- (08049CA0) --------------------------------------------------------
int sub_8049CA0()
{
  return 0;
}
// 8049CA0: could not find valid save-restore pair for ebp

//----- (08049CFF) --------------------------------------------------------
void sub_8049CFF()
{
  ;
}

//----- (08049D1A) --------------------------------------------------------
void sub_8049D1A()
{
  ;
}

//----- (08049D2A) --------------------------------------------------------
int sub_8049D2A()
{
  int result; // eax

  result = &unk_807145F - &unk_807145C;
  if ( (unsigned int)(&unk_807145F - &unk_807145C) > 6 )
    result = 0;
  return result;
}
// 8049D2A: could not find valid save-restore pair for ebp

//----- (08049D88) --------------------------------------------------------
int sub_8049D88()
{
  return nullsub_3();
}
// 8049D88: could not find valid save-restore pair for ebp
// 8049D87: using guessed type int nullsub_3(void);

//----- (08049E28) --------------------------------------------------------
void sub_8049E28()
{
  ;
}

//----- (08049E43) --------------------------------------------------------
void sub_8049E43()
{
  ;
}

//----- (08049E53) --------------------------------------------------------
signed int sub_8049E53()
{
  return 3;
}
// 8049E53: could not find valid save-restore pair for ebp

//----- (08049F35) --------------------------------------------------------
void sub_8049F35()
{
  ;
}

//----- (08049F50) --------------------------------------------------------
void sub_8049F50()
{
  ;
}

//----- (08049F60) --------------------------------------------------------
int sub_8049F60()
{
  int result; // eax

  result = &unk_807145F - &unk_807145C;
  if ( (unsigned int)(&unk_807145F - &unk_807145C) > 6 )
    result = 0;
  return result;
}
// 8049F60: could not find valid save-restore pair for ebp

//----- (0804A042) --------------------------------------------------------
void sub_804A042()
{
  ;
}

//----- (0804A05D) --------------------------------------------------------
void sub_804A05D()
{
  ;
}

//----- (0804A06D) --------------------------------------------------------
int sub_804A06D()
{
  int result; // eax

  result = &unk_80715B7 - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_80715B7 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 804A06D: could not find valid save-restore pair for ebp
// 8071480: using guessed type int program_invocation_short_name;

//----- (0804A14F) --------------------------------------------------------
void sub_804A14F()
{
  ;
}

//----- (0804A16A) --------------------------------------------------------
void sub_804A16A()
{
  ;
}

//----- (0804A17A) --------------------------------------------------------
int sub_804A17A()
{
  int result; // eax

  result = &unk_806F40F - &unk_806F40C;
  if ( (unsigned int)(&unk_806F40F - &unk_806F40C) > 6 )
    result = 0;
  return result;
}
// 804A17A: could not find valid save-restore pair for ebp

//----- (0804A26E) --------------------------------------------------------
void sub_804A26E()
{
  ;
}

//----- (0804A289) --------------------------------------------------------
void sub_804A289()
{
  ;
}

//----- (0804A299) --------------------------------------------------------
int sub_804A299()
{
  int result; // eax

  result = &unk_807145F - &unk_807145C;
  if ( (unsigned int)(&unk_807145F - &unk_807145C) > 6 )
    result = 0;
  return result;
}
// 804A299: could not find valid save-restore pair for ebp

//----- (0804A37B) --------------------------------------------------------
void sub_804A37B()
{
  ;
}

//----- (0804A396) --------------------------------------------------------
void sub_804A396()
{
  ;
}

//----- (0804A3A6) --------------------------------------------------------
int sub_804A3A6()
{
  int result; // eax

  result = &unk_806E3E7 - &unk_806E3E4;
  if ( (unsigned int)(&unk_806E3E7 - &unk_806E3E4) > 6 )
    result = 0;
  return result;
}
// 804A3A6: could not find valid save-restore pair for ebp

//----- (0804A404) --------------------------------------------------------
int sub_804A404()
{
  return nullsub_4();
}
// 804A404: could not find valid save-restore pair for ebp
// 804A403: using guessed type int nullsub_4(void);

//----- (0804A4A4) --------------------------------------------------------
void sub_804A4A4()
{
  ;
}

//----- (0804A4BF) --------------------------------------------------------
void sub_804A4BF()
{
  ;
}

//----- (0804A4CF) --------------------------------------------------------
int sub_804A4CF()
{
  int result; // eax

  result = &unk_807145F - &unk_807145C;
  if ( (unsigned int)(&unk_807145F - &unk_807145C) > 6 )
    result = 0;
  return result;
}
// 804A4CF: could not find valid save-restore pair for ebp

//----- (0804A5B1) --------------------------------------------------------
void sub_804A5B1()
{
  ;
}

//----- (0804A5CC) --------------------------------------------------------
void sub_804A5CC()
{
  ;
}

//----- (0804A5DC) --------------------------------------------------------
int sub_804A5DC()
{
  int result; // eax

  result = &unk_807145F - &unk_807145C;
  if ( (unsigned int)(&unk_807145F - &unk_807145C) > 6 )
    result = 0;
  return result;
}
// 804A5DC: could not find valid save-restore pair for ebp

//----- (0804A6BE) --------------------------------------------------------
void sub_804A6BE()
{
  ;
}

//----- (0804A6D9) --------------------------------------------------------
void sub_804A6D9()
{
  ;
}

//----- (0804A6E9) --------------------------------------------------------
int sub_804A6E9()
{
  int result; // eax

  result = &unk_806D3AB - &unk_806D3A8;
  if ( (unsigned int)(&unk_806D3AB - &unk_806D3A8) > 6 )
    result = 0;
  return result;
}
// 804A6E9: could not find valid save-restore pair for ebp

//----- (0804A715) --------------------------------------------------------
int sub_804A715()
{
  return 0;
}
// 804A715: could not find valid save-restore pair for ebp

//----- (0804A7B4) --------------------------------------------------------
int __usercall sub_804A7B4@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  a1(&dword_806CF04);
  return sub_804A715();
}
// 806CF04: using guessed type int dword_806CF04;

//----- (0804A800) --------------------------------------------------------
void sub_804A800()
{
  ;
}

//----- (0804A81B) --------------------------------------------------------
void sub_804A81B()
{
  ;
}

//----- (0804A82B) --------------------------------------------------------
#error "804A858: call analysis failed (funcsize=23)"

//----- (0804A926) --------------------------------------------------------
void sub_804A926()
{
  ;
}

//----- (0804A973) --------------------------------------------------------
void sub_804A973()
{
  ;
}

//----- (0804A983) --------------------------------------------------------
int sub_804A983()
{
  int result; // eax

  result = &unk_8071467 - &unk_8071464;
  if ( (unsigned int)(&unk_8071467 - &unk_8071464) > 6 )
    result = 0;
  return result;
}

//----- (0804AA0A) --------------------------------------------------------
int __usercall sub_804AA0A@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_8071464, a1);
}

//----- (0804AAAD) --------------------------------------------------------
void sub_804AAAD()
{
  ;
}

//----- (0804AAE6) --------------------------------------------------------
void sub_804AAE6()
{
  ;
}

//----- (0804AB18) --------------------------------------------------------
int sub_804AB18()
{
  int result; // eax

  result = &unk_807146B - &unk_8071468;
  if ( (unsigned int)(&unk_807146B - &unk_8071468) > 6 )
    result = 0;
  return result;
}
// 804AB18: could not find valid save-restore pair for ebp

//----- (0804ABEB) --------------------------------------------------------
int __cdecl sub_804ABEB(int a1)
{
  int result; // eax

  if ( a1 != 1 )
  {
    result = a1;
    status = a1;
  }
  return result;
}

//----- (0804ABFE) --------------------------------------------------------
int __cdecl sub_804ABFE(char a1)
{
  char v2; // [esp+0h] [ebp-4h]

  v2 = a1;
  return (unsigned __int8)*(&v2 - 4);
}

//----- (0804AC32) --------------------------------------------------------
int __cdecl sub_804AC32(_BYTE *a1)
{
  void *v1; // eax
  signed int v2; // eax
  int v5; // [esp-Eh] [ebp-10h]
  int v6; // [esp-Ah] [ebp-Ch]
  int v7; // [esp-6h] [ebp-8h]
  int v8; // [esp-2h] [ebp-4h]
  char v9; // [esp+1h] [ebp-1h]

  v1 = &loc_804AC7D;
  if ( *a1 != 46 )
    v1 = &loc_804ACD0;
  dword_8071268 = (int)v1;
  sub_8064F57(v5, v6, v7, v8);
  if ( a1[1] == 46 )
    v2 = 2;
  else
    v2 = 1;
  v9 = a1[v2];
  return !v9 || v9 == 47;
}
// 8064F57: using guessed type int __stdcall sub_8064F57(_DWORD, _DWORD, _DWORD, _DWORD);
// 8071268: using guessed type int dword_8071268;

//----- (0804ACD7) --------------------------------------------------------
int sub_804ACD7()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nMandatory arguments to long options are mandatory for short options too.\n");
  return fputs_unlocked(v1, v0);
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804AD0C) --------------------------------------------------------
int sub_804AD0C()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext(
         "\n"
         "The SIZE argument is an integer and optional unit (example: 10K is 10*1024).\n"
         "Units are K,M,G,T,P,E,Z,Y (powers of 1024) or KB,MB,... (powers of 1000).\n");
  return fputs_unlocked(v1, v0);
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804AD37) --------------------------------------------------------
int __cdecl sub_804AD37(char *s1)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // ebx
  char *v5; // eax
  int v7; // [esp+0h] [ebp-68h]
  char *v8; // [esp+4h] [ebp-64h]
  char *v9; // [esp+8h] [ebp-60h]
  char *v10; // [esp+1Ch] [ebp-4Ch]
  char **i; // [esp+20h] [ebp-48h]
  char *v12; // [esp+24h] [ebp-44h]
  const char *v13; // [esp+28h] [ebp-40h]
  const char *v14; // [esp+2Ch] [ebp-3Ch]
  const char *v15; // [esp+30h] [ebp-38h]
  const char *v16; // [esp+34h] [ebp-34h]
  const char *v17; // [esp+38h] [ebp-30h]
  const char *v18; // [esp+3Ch] [ebp-2Ch]
  const char *v19; // [esp+40h] [ebp-28h]
  const char *v20; // [esp+44h] [ebp-24h]
  const char *v21; // [esp+48h] [ebp-20h]
  const char *v22; // [esp+4Ch] [ebp-1Ch]
  const char *v23; // [esp+50h] [ebp-18h]
  const char *v24; // [esp+54h] [ebp-14h]
  int v25; // [esp+58h] [ebp-10h]
  int v26; // [esp+5Ch] [ebp-Ch]

  v13 = "[";
  v14 = "test invocation";
  v15 = "coreutils";
  v16 = "Multi-call invocation";
  v17 = "sha224sum";
  v18 = "sha2 utilities";
  v19 = "sha256sum";
  v20 = "sha2 utilities";
  v21 = "sha384sum";
  v22 = "sha2 utilities";
  v23 = "sha512sum";
  v24 = "sha2 utilities";
  v25 = 0;
  v26 = 0;
  v10 = s1;
  for ( i = (char **)(&v7 - 16); *i; i += 2 )
  {
    v8 = *i;
    if ( !strcmp(s1, v8) )
      break;
  }
  if ( i[1] )
    v10 = i[1];
  v1 = gettext("\n%s online help: <%s>\n");
  v9 = "http://www.gnu.org/software/coreutils/";
  v8 = "GNU coreutils";
  printf(v1, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  v12 = setlocale(5, 0);
  if ( v12 && strncmp(v12, "en_", 3u) )
  {
    v2 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
    v8 = s1;
    printf(v2, s1);
  }
  v3 = gettext("Full documentation at: <%s%s>\n");
  v9 = s1;
  v8 = "http://www.gnu.org/software/coreutils/";
  printf(v3, "http://www.gnu.org/software/coreutils/", s1);
  if ( v10 == s1 )
    v4 = " invocation";
  else
    v4 = &locale;
  v5 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  v9 = v4;
  v8 = v10;
  return printf(v5, v10, v4);
}

//----- (0804AED5) --------------------------------------------------------
int __cdecl sub_804AED5(int a1, int a2)
{
  return sub_805AB62(a1, a1 >> 31, a2);
}
// 805AB62: using guessed type _DWORD __cdecl sub_805AB62(_DWORD, _DWORD, _DWORD);

//----- (0804AEF4) --------------------------------------------------------
int __cdecl sub_804AEF4(int a1)
{
  return a1;
}

//----- (0804AF00) --------------------------------------------------------
bool __cdecl sub_804AF00(int a1)
{
  return a1 == 95;
}

//----- (0804AF10) --------------------------------------------------------
int sub_804AF10()
{
  return 0;
}

//----- (0804AF1E) --------------------------------------------------------
#error "804AFE8: call analysis failed (funcsize=65)"

//----- (0804AFED) --------------------------------------------------------
#error "804AFFD: positive sp value has been found (funcsize=0)"

//----- (0804AFFE) --------------------------------------------------------
#error "804B0C6: call analysis failed (funcsize=57)"

//----- (0804B0CB) --------------------------------------------------------
#error "804B0DF: positive sp value has been found (funcsize=0)"

//----- (0804B0E2) --------------------------------------------------------
unsigned int __cdecl sub_804B0E2(int a1, int a2)
{
  unsigned int result; // eax
  int v3; // [esp-14h] [ebp-34h]
  unsigned int i; // [esp+0h] [ebp-20h]
  int v5; // [esp+4h] [ebp-1Ch]
  unsigned int v6; // [esp+8h] [ebp-18h]
  int v7; // [esp+Ch] [ebp-14h]
  int v8; // [esp+10h] [ebp-10h]
  int v9; // [esp+14h] [ebp-Ch]

  v5 = a2;
  result = (unsigned int)(*(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 8)) >> 2;
  v6 = (unsigned int)(*(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 8)) >> 2;
  if ( v6 )
  {
    v7 = a2;
    v8 = *(_DWORD *)(a2 + 8);
    if ( *(_DWORD *)(a2 + 12) == v8 )
      *(_BYTE *)(v7 + 40) |= 2u;
    *(_DWORD *)(v7 + 12) = (*(_DWORD *)(v7 + 24) + *(_DWORD *)(v7 + 12)) & ~*(_DWORD *)(v7 + 24);
    if ( *(_DWORD *)(v7 + 12) - *(_DWORD *)(v7 + 4) > (unsigned int)(*(_DWORD *)(v7 + 16) - *(_DWORD *)(v7 + 4)) )
      *(_DWORD *)(v7 + 12) = *(_DWORD *)(v7 + 16);
    *(_DWORD *)(v7 + 8) = *(_DWORD *)(v7 + 12);
    v9 = v8;
    fputs_unlocked(a1, stdout);
    for ( i = 0; i < v6; ++i )
    {
      v3 = *(_DWORD *)(4 * i + v9);
      printf(" %lu", v3);
    }
    result = putchar_unlocked(10);
  }
  return result;
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804B22D) --------------------------------------------------------
_BYTE *__cdecl sub_804B22D(_BYTE *a1)
{
  int v1; // eax

  while ( *a1 )
  {
    if ( *a1 == 37 )
    {
      v1 = (char)a1[1];
      if ( v1 == 37 )
      {
        ++a1;
      }
      else if ( v1 == 98 )
      {
        return a1;
      }
    }
    ++a1;
  }
  return 0;
}

//----- (0804B274) --------------------------------------------------------
void sub_804B274()
{
  char v0; // bl
  bool v1; // al
  signed int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; i <= 255; ++i )
  {
    v0 = *(_BYTE *)(i + 134683369);
    v1 = (unsigned __int8)sub_8055B6A(i) || i == 126 || i == 45 || i == 46 || i == 95;
    *(_BYTE *)(i + 134683369) = v0 | v1;
  }
}

//----- (0804B2E6) --------------------------------------------------------
signed int sub_804B2E6()
{
  int *v0; // ebp
  int v1; // eax
  bool v2; // zf
  bool v3; // sf
  unsigned __int8 v4; // of
  void *v5; // eax
  int v7; // [esp-4h] [ebp-4Ch]
  int v8; // [esp+0h] [ebp-48h]
  int v9; // [esp+4h] [ebp-44h]
  int v10; // [esp+8h] [ebp-40h]
  int v11; // [esp+Ch] [ebp-3Ch]
  int v12; // [esp+2Ch] [ebp-1Ch]
  int savedregs; // [esp+48h] [ebp+0h]

  v0 = &savedregs;
  v12 = 5;
  do
  {
    v1 = *(v0 - 7);
    *(v0 - 5) = v1;
    v0 = &v8;
    *(&v8 - 7) = 0;
    *(&v8 - 6) = 0;
    v4 = __OFSUB__(*(&v8 - 6), 11);
    v2 = *(&v8 - 6) == 11;
    v3 = *(&v8 - 6) - 11 < 0;
    v7 = v1;
    v5 = &loc_804B40B;
    if ( (unsigned __int8)(v3 ^ v4) | v2 )
      v5 = &loc_804B32C;
    dword_8071268 = (int)v5;
    sub_8064F57(v8, v9, v10, v11);
  }
  while ( *(&v8 - 5) > (unsigned int)*(&v8 - 7) );
  return 1;
}
// 8064F57: using guessed type int __stdcall sub_8064F57(_DWORD, _DWORD, _DWORD, _DWORD);
// 8071268: using guessed type int dword_8071268;

//----- (0804B41E) --------------------------------------------------------
int sub_804B41E()
{
  _BYTE *v0; // eax
  int v1; // ecx
  signed int v2; // edx
  void *v3; // eax
  void *v4; // eax
  int v6; // [esp+0h] [ebp-658h]
  int v7; // [esp+0h] [ebp-658h]
  int v8; // [esp+0h] [ebp-658h]
  int v9; // [esp+4h] [ebp-654h]
  int v10; // [esp+4h] [ebp-654h]
  int v11; // [esp+8h] [ebp-650h]
  int v12; // [esp+8h] [ebp-650h]
  int v13; // [esp+Ch] [ebp-64Ch]
  int v14; // [esp+Ch] [ebp-64Ch]
  int v15; // [esp+10h] [ebp-648h]
  int v16; // [esp+10h] [ebp-648h]
  int v17; // [esp+14h] [ebp-644h]
  int v18; // [esp+14h] [ebp-644h]
  int v19; // [esp+18h] [ebp-640h]
  int v20; // [esp+18h] [ebp-640h]
  int v21; // [esp+1Ch] [ebp-63Ch]
  int v22; // [esp+1Ch] [ebp-63Ch]
  int v23; // [esp+20h] [ebp-638h]
  int v24; // [esp+20h] [ebp-638h]
  int v25; // [esp+24h] [ebp-634h]
  int v26; // [esp+24h] [ebp-634h]
  int v27; // [esp+28h] [ebp-630h]
  int v28; // [esp+28h] [ebp-630h]
  signed int v29; // [esp+2Ch] [ebp-62Ch]
  int v30; // [esp+30h] [ebp-628h]
  int v31; // [esp+34h] [ebp-624h]
  int v32; // [esp+38h] [ebp-620h]
  int v33; // [esp+3Ch] [ebp-61Ch]
  char *s; // [esp+40h] [ebp-618h]
  int v35; // [esp+44h] [ebp-614h]
  int v36; // [esp+48h] [ebp-610h]
  int v37; // [esp+4Ch] [ebp-60Ch]
  int v38; // [esp+50h] [ebp-608h]
  int v39; // [esp+54h] [ebp-604h]
  int v40; // [esp+58h] [ebp-600h]
  int v41; // [esp+5Ch] [ebp-5FCh]
  int v42; // [esp+60h] [ebp-5F8h]
  int v43; // [esp+64h] [ebp-5F4h]
  int v44; // [esp+68h] [ebp-5F0h]
  int v45; // [esp+6Ch] [ebp-5ECh]
  int v46; // [esp+70h] [ebp-5E8h]
  int v47; // [esp+74h] [ebp-5E4h]
  int v48; // [esp+78h] [ebp-5E0h]
  int v49; // [esp+7Ch] [ebp-5DCh]
  int v50; // [esp+80h] [ebp-5D8h]
  int v51; // [esp+84h] [ebp-5D4h]
  int v52; // [esp+88h] [ebp-5D0h]
  int v53; // [esp+8Ch] [ebp-5CCh]
  int v54; // [esp+90h] [ebp-5C8h]
  int v55; // [esp+94h] [ebp-5C4h]
  int v56; // [esp+98h] [ebp-5C0h]
  int v57; // [esp+9Ch] [ebp-5BCh]
  int v58; // [esp+A0h] [ebp-5B8h]
  int v59; // [esp+A4h] [ebp-5B4h]
  int v60; // [esp+A8h] [ebp-5B0h]
  int v61; // [esp+ACh] [ebp-5ACh]
  int v62; // [esp+B0h] [ebp-5A8h]
  int v63; // [esp+B4h] [ebp-5A4h]
  int v64; // [esp+B8h] [ebp-5A0h]
  int v65; // [esp+BCh] [ebp-59Ch]
  int v66; // [esp+C0h] [ebp-598h]
  int v67; // [esp+C4h] [ebp-594h]
  int v68; // [esp+C8h] [ebp-590h]

  v29 = 0;
  dword_80711F0 = (int)&loc_804B471;
  sub_80651FD(v6, v9, v11, v13, v15, v17, v19, v21, v23, v25, v27);
  do
  {
    v0 = sub_804B22D((&off_80713BC)[v29]);
    v2 = v29;
    *(&v36 + v29++) = (int)v0;
  }
  while ( v29 <= 1 );
  v3 = &loc_804B49D;
  if ( v36 )
    v3 = &loc_804B4C5;
  dword_80711DC = (int)v3;
  sub_806526B(v1, v2, v7);
  v4 = &loc_804B4C0;
  if ( v37 )
    v4 = &loc_804B4C5;
  dword_8071240 = (int)v4;
  return sub_8065037(
           v8,
           v10,
           v12,
           v14,
           v16,
           v18,
           v20,
           v22,
           v24,
           v26,
           v28,
           v29,
           v30,
           v31,
           v32,
           v33,
           s,
           v35,
           v36,
           v37,
           v38,
           v39,
           v40,
           v41,
           v42,
           v43,
           v44,
           v45,
           v46,
           v47,
           v48,
           v49,
           v50,
           v51,
           v52,
           v53,
           v54,
           v55,
           v56,
           v57,
           v58,
           v59,
           v60,
           v61,
           v62,
           v63,
           v64,
           v65,
           v66,
           v67,
           v68);
}
// 804B41E: could not find valid save-restore pair for ebx
// 8065037: using guessed type int __stdcall sub_8065037(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80651FD: using guessed type int __stdcall sub_80651FD(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;
// 80711F0: using guessed type int dword_80711F0;
// 8071240: using guessed type int dword_8071240;

//----- (0804B6AE) --------------------------------------------------------
int __cdecl sub_804B6AE(unsigned __int64 *a1, unsigned int a2)
{
  return sub_8064A2C(*a1, a2);
}

//----- (0804B6F5) --------------------------------------------------------
int __cdecl sub_804B6F5(int a1, _QWORD *a2)
{
  int v2; // ebx
  bool v3; // al

  v3 = 0;
  if ( *a2 == *(_QWORD *)a1 )
  {
    v2 = *(_DWORD *)(a1 + 12);
    if ( *(_QWORD *)(a1 + 8) == a2[1] )
      v3 = 1;
  }
  return v3;
}

//----- (0804B779) --------------------------------------------------------
void __cdecl sub_804B779(void *ptr)
{
  free(ptr);
}

//----- (0804B78C) --------------------------------------------------------
#error "804B7BB: call analysis failed (funcsize=24)"

//----- (0804B7CE) --------------------------------------------------------
#error "804B7E4: call analysis failed (funcsize=23)"

//----- (0804B818) --------------------------------------------------------
#error "804B83D: call analysis failed (funcsize=25)"

//----- (0804B869) --------------------------------------------------------
#error "804B88F: call analysis failed (funcsize=32)"

//----- (0804B8C7) --------------------------------------------------------
void __cdecl sub_804B8C7(void *ptr)
{
  void *v1; // [esp+8h] [ebp-10h]

  free(*(void **)ptr);
  free(*((void **)ptr + 1));
  free(v1);
}

//----- (0804B915) --------------------------------------------------------
#error "804B969: call analysis failed (funcsize=61)"

//----- (0804B9DF) --------------------------------------------------------
size_t sub_804B9DF()
{
  sub_805459D((int)dword_80712FC);
  return sub_805459D((int)&dword_8071304);
}
// 80712FC: using guessed type int dword_80712FC[];
// 8071304: using guessed type int dword_8071304;

//----- (0804B9FF) --------------------------------------------------------
size_t __usercall sub_804B9FF@<eax>(int a1@<ebx>)
{
  size_t result; // eax

  result = (unsigned __int8)byte_807192D;
  if ( byte_807192D )
  {
    result = sub_804B915(a1, 4);
    if ( (_BYTE)result )
    {
      sub_805459D((int)dword_80712FC);
      sub_805459D((int)&unk_807131C);
      result = sub_805459D((int)&dword_8071304);
    }
  }
  return result;
}
// 80712FC: using guessed type int dword_80712FC[];
// 8071304: using guessed type int dword_8071304;
// 807192D: using guessed type char byte_807192D;

//----- (0804BA68) --------------------------------------------------------
int __cdecl sub_804BA68(int a1)
{
  int result; // eax

  result = dword_8071A09;
  if ( !dword_8071A09 )
  {
    result = a1;
    dword_8071A09 = a1;
  }
  return result;
}
// 8071A09: using guessed type int dword_8071A09;

//----- (0804BA7E) --------------------------------------------------------
int sub_804BA7E()
{
  int result; // eax

  result = dword_8071A09;
  if ( !dword_8071A09 )
    result = dword_8071A0D++ + 1;
  return result;
}
// 8071A09: using guessed type int dword_8071A09;
// 8071A0D: using guessed type int dword_8071A0D;

//----- (0804BA99) --------------------------------------------------------
#error "804BB8F: call analysis failed (funcsize=59)"

//----- (0804BB96) --------------------------------------------------------
__sighandler_t __cdecl sub_804BB96(void (*a1)(int))
{
  __sighandler_t result; // eax
  void *v2; // eax
  bool v3; // zf
  void *v4; // eax
  signed int i; // [esp+10h] [ebp-A8h]
  signed int j; // [esp+10h] [ebp-A8h]
  signed int k; // [esp+10h] [ebp-A8h]
  void *v8; // [esp+14h] [ebp-A4h]
  char v9; // [esp+18h] [ebp-A0h]
  int v10; // [esp+98h] [ebp-20h]

  result = a1;
  if ( (_BYTE)a1 )
  {
    sigemptyset(&set);
    for ( i = 0; i <= 11; ++i )
    {
      sigaction(sig[i], 0, (struct sigaction *)&v8);
      if ( v8 != (void *)1 )
        sigaddset(&set, sig[i]);
    }
    result = (__sighandler_t)32;
    qmemcpy(&v9, &set, 0x80u);
    v10 = 0x10000000;
    for ( j = 0; j <= 11; ++j )
    {
      result = (__sighandler_t)sigismember(&set, sig[j]);
      if ( result )
      {
        if ( sig[j] == 20 )
          v2 = sub_804BA7E;
        else
          v2 = sub_804BA68;
        v8 = v2;
        result = (__sighandler_t)sigaction(sig[j], (const struct sigaction *)&v8, 0);
      }
    }
  }
  else
  {
    for ( k = 0; k <= 11; ++k )
    {
      v3 = sigismember(&set, sig[k]) == 0;
      v4 = &loc_804BD31;
      if ( v3 )
        v4 = &loc_804BD4E;
      dword_807127C = (int)v4;
      sub_8064EEB();
      result = signal(sig[k], 0);
    }
  }
  return result;
}
// 8064EEB: using guessed type int sub_8064EEB(void);
// 807127C: using guessed type int dword_807127C;

//----- (0804BD69) --------------------------------------------------------
__sighandler_t sub_804BD69()
{
  return sub_804BB96((void (*)(int))1);
}

//----- (0804BD7D) --------------------------------------------------------
__sighandler_t sub_804BD7D()
{
  return sub_804BB96(0);
}

//----- (0804BD95) --------------------------------------------------------
#error "804C217: call analysis failed (funcsize=453)"

//----- (0804C52A) --------------------------------------------------------
signed int __cdecl sub_804C52A(char *a1)
{
  int v1; // eax
  signed int v2; // eax
  signed int result; // eax
  char *nptr; // [esp+0h] [ebp-3Ch]
  int v5; // [esp+4h] [ebp-38h]
  int base; // [esp+8h] [ebp-34h]
  int v7; // [esp+Ch] [ebp-30h]
  char *s; // [esp+10h] [ebp-2Ch]
  int v9; // [esp+28h] [ebp-14h]

  s = &locale;
  v7 = (int)&v9;
  base = 0;
  v5 = 0;
  nptr = a1;
  v1 = sub_80624A6();
  if ( v1 )
  {
    if ( v1 == 1 )
    {
      dword_8071965 = -1;
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    v2 = (signed int)*(&nptr - 4);
    if ( *(&nptr - 3) )
      v2 = -1;
    dword_8071965 = v2;
    result = 1;
  }
  return result;
}
// 8071965: using guessed type int dword_8071965;

//----- (0804C5B2) --------------------------------------------------------
#error "804C662: call analysis failed (funcsize=954)"

//----- (0804D7BD) --------------------------------------------------------
#error "804D809: call analysis failed (funcsize=285)"

//----- (0804DBCF) --------------------------------------------------------
#error "804DBE3: positive sp value has been found (funcsize=0)"

//----- (0804DBE4) --------------------------------------------------------
signed int sub_804DBE4()
{
  int v0; // edx
  int v1; // ecx
  int v3; // [esp+0h] [ebp-28h]
  char *s1; // [esp+18h] [ebp-10h]
  char *name; // [esp+1Ch] [ebp-Ch]

  name = getenv("TERM");
  if ( !name || !*name )
  {
    dword_80711DC = (int)&locret_804DC9E;
    sub_806526B(v1, v0, v3);
  }
  for ( s1 = "# Configuration file for dircolors, a utility to help you set the";
        (unsigned int)(s1 - "# Configuration file for dircolors, a utility to help you set the") <= 0x104C;
        s1 += strlen(s1) + 1 )
  {
    if ( !strncmp(s1, "TERM ", 5u) && !fnmatch(s1 + 5, name, 0) )
      return 1;
  }
  return 0;
}
// 80711DC: using guessed type int dword_80711DC;

//----- (0804DCA0) --------------------------------------------------------
#error "804DD24: call analysis failed (funcsize=282)"

//----- (0804E113) --------------------------------------------------------
#error "804E18B: call analysis failed (funcsize=46)"

//----- (0804E1CF) --------------------------------------------------------
int __cdecl sub_804E1CF(int a1)
{
  int result; // eax

  result = a1;
  if ( (_BYTE)a1 )
  {
    dword_8071A11 = 2;
  }
  else
  {
    result = dword_8071A11;
    if ( !dword_8071A11 )
      dword_8071A11 = 1;
  }
  return result;
}
// 8071A11: using guessed type int dword_8071A11;

//----- (0804E212) --------------------------------------------------------
int __cdecl sub_804E212(int a1, char *format, int a3)
{
  int v3; // ebx
  int *v4; // eax

  v3 = sub_80602C7(4, a3);
  v4 = __errno_location();
  error(0, *v4, format, v3);
  return sub_804E1CF((unsigned __int8)a1);
}

//----- (0804E26C) --------------------------------------------------------
#error "804E2B6: call analysis failed (funcsize=59)"

//----- (0804E330) --------------------------------------------------------
#error "804EA5B: call analysis failed (funcsize=400)"

//----- (0804EAD2) --------------------------------------------------------
_DWORD *__cdecl sub_804EAD2(int a1)
{
  _DWORD *result; // eax

  result = sub_80616F7(8u);
  *result = a1;
  result[1] = dword_8071949;
  dword_8071949 = (int)result;
  return result;
}

//----- (0804EB15) --------------------------------------------------------
#error "804EB32: positive sp value has been found (funcsize=10)"

//----- (0804EB80) --------------------------------------------------------
int __cdecl sub_804EB80(_BYTE *a1)
{
  int *v1; // ebp
  void *v2; // eax
  signed int v3; // eax
  char v4; // al
  int v6; // [esp+0h] [ebp-1Ch]
  char *name; // [esp+4h] [ebp-18h]
  int v8; // [esp+18h] [ebp-4h]

  v1 = &v8;
  if ( dword_8071945 != 2 && *a1 == 46 )
  {
    v2 = &loc_804EBC0;
    if ( !dword_8071945 )
      v2 = &loc_804EC3E;
    dword_807127C = (int)v2;
    sub_8064EEB();
    v3 = a1[1] == 46 ? 2 : 1;
    v1 = &v6;
    if ( !a1[v3] )
      goto LABEL_17;
  }
  if ( (dword_8071945 || (name = (char *)v1[2], !(unsigned __int8)sub_804EB15(dword_807194D, name)))
    && (name = (char *)v1[2], !(unsigned __int8)sub_804EB15(dword_8071949, name)) )
  {
    v4 = 0;
  }
  else
  {
LABEL_17:
    v4 = 1;
  }
  return v4 & 1;
}
// 8064EEB: using guessed type int sub_8064EEB(void);
// 807127C: using guessed type int dword_807127C;
// 8071945: using guessed type int dword_8071945;

//----- (0804EC4F) --------------------------------------------------------
#error "804EC63: call analysis failed (funcsize=13)"

//----- (0804EC76) --------------------------------------------------------
#error "804EC8D: positive sp value has been found (funcsize=0)"

//----- (0804EC8E) --------------------------------------------------------
int sub_804EC8E()
{
  *__errno_location() = 95;
  return 0;
}

//----- (0804ECE6) --------------------------------------------------------
void __cdecl sub_804ECE6(void **a1)
{
  bool v1; // zf
  void *v2; // eax

  free(*a1);
  free(a1[1]);
  free(a1[2]);
  if ( a1[29] != &unk_80712DC )
  {
    v1 = (unsigned __int8)sub_804AF10() == 0;
    v2 = &loc_804ED44;
    if ( v1 )
      v2 = &loc_804ED66;
    dword_807127C = (int)v2;
    sub_8064EEB();
    free(a1[29]);
  }
}
// 8064EEB: using guessed type int sub_8064EEB(void);
// 807127C: using guessed type int dword_807127C;

//----- (0804ED76) --------------------------------------------------------
int sub_804ED76()
{
  int *v0; // ebp
  int v1; // edx
  int result; // eax
  int v3; // [esp+0h] [ebp-28h]
  int v4; // [esp+18h] [ebp-10h]
  int savedregs; // [esp+28h] [ebp+0h]

  v0 = &savedregs;
  v4 = 0;
  while ( 1 )
  {
    result = dword_80718B5;
    if ( *(v0 - 4) >= (unsigned int)dword_80718B5 )
      break;
    v1 = *(v0 - 4);
    v0 = &v3;
    *(&v3 - 3) = *((_DWORD *)dword_80718BD + v1);
    sub_804ECE6((void **)*(&v3 - 3));
    ++*(&v3 - 4);
  }
  dword_80718B5 = 0;
  byte_80718B9 = 0;
  byte_80718DA = 0;
  dword_80718DD = 0;
  dword_80718E1 = 0;
  dword_80718E5 = 0;
  dword_80718ED = 0;
  dword_80718F1 = 0;
  dword_80718F5 = 0;
  dword_80718E9 = 0;
  dword_80718F9 = 0;
  dword_80718FD = 0;
  dword_8071901 = 0;
  return result;
}
// 80718B5: using guessed type int dword_80718B5;
// 80718B9: using guessed type char byte_80718B9;
// 80718DA: using guessed type char byte_80718DA;
// 80718DD: using guessed type int dword_80718DD;
// 80718E1: using guessed type int dword_80718E1;
// 80718E5: using guessed type int dword_80718E5;
// 80718E9: using guessed type int dword_80718E9;
// 80718F9: using guessed type int dword_80718F9;
// 80718FD: using guessed type int dword_80718FD;
// 8071901: using guessed type int dword_8071901;

//----- (0804EE60) --------------------------------------------------------
int __cdecl sub_804EE60(int a1)
{
  return a1 == 22 || a1 == 38 || sub_804AF00(a1);
}

//----- (0804EE96) --------------------------------------------------------
#error "804EF0A: call analysis failed (funcsize=73)"

//----- (0804EF92) --------------------------------------------------------
#error "804F02F: call analysis failed (funcsize=71)"

//----- (0804F074) --------------------------------------------------------
#error "804F085: call analysis failed (funcsize=12)"

//----- (0804F098) --------------------------------------------------------
#error "804F13A: positive sp value has been found (funcsize=54)"

//----- (0804F13B) --------------------------------------------------------
#error "804F158: call analysis failed (funcsize=11)"

//----- (0804F15D) --------------------------------------------------------
int __cdecl sub_804F15D(int a1, const char *s)
{
  size_t v2; // eax
  bool v3; // al
  __int16 v5; // [esp+2Ah] [ebp-Eh]
  int v6; // [esp+2Ch] [ebp-Ch]

  v6 = sub_805FC0C((int)&v5, 2, (int)s, -1, (int *)dword_8071955);
  v3 = 1;
  if ( *s == (_BYTE)v5 )
  {
    v2 = strlen(s);
    if ( v2 == v6 )
      v3 = 0;
  }
  return v3;
}
// 804F15D: could not find valid save-restore pair for ebp
// 8071955: using guessed type int dword_8071955;

//----- (0804F1D3) --------------------------------------------------------
#error "804F207: call analysis failed (funcsize=19)"

//----- (0804F20C) --------------------------------------------------------
#error "804F2BD: call analysis failed (funcsize=951)"

//----- (080501EC) --------------------------------------------------------
#error "805020E: call analysis failed (funcsize=26)"

//----- (08050233) --------------------------------------------------------
int __cdecl sub_8050233(char *path, int a2, int a3)
{
  int v3; // edx
  int result; // eax
  char *v5; // eax

  v3 = *(_DWORD *)(a2 + 60);
  *(_DWORD *)(a2 + 4) = sub_80555C4(path, *(_DWORD *)(a2 + 56));
  result = *(_DWORD *)(a2 + 4);
  if ( !result )
  {
    v5 = gettext("cannot read symbolic link %s");
    result = sub_804E212((unsigned __int8)a3, v5, (int)path);
  }
  return result;
}

//----- (0805029C) --------------------------------------------------------
int __cdecl sub_805029C(int a1, char *s)
{
  const char **v2; // ebp
  char *v4; // eax
  const char *v5; // [esp-18h] [ebp-28h]
  int v6; // [esp-10h] [ebp-20h]
  int savedregs; // [esp+10h] [ebp+0h]

  v2 = (const char **)&savedregs;
  if ( !s )
    return 0;
  if ( *s == 47 )
  {
    sub_80618B5(s);
    dword_807127C = (int)&locret_8050370;
    sub_8064EEB();
    v2 = &v5;
  }
  v5 = v2[2];
  *(v2 - 4) = (const char *)sub_80569FC(v5);
  if ( !*(v2 - 4) )
    return sub_80618B5((char *)v2[3]);
  v5 = v2[3];
  v5 = &(*(v2 - 4))[strlen(v5) + 2];
  *(v2 - 3) = (const char *)sub_80616F7((size_t)v5);
  if ( v2[2][(_DWORD)(*(v2 - 4) - 1)] != 47 )
    ++*(v2 - 4);
  v6 = (int)*(v2 - 4);
  v4 = (char *)stpncpy(*(v2 - 3), v2[2], v6);
  strcpy(v4, v2[3]);
  return (int)*(v2 - 3);
}
// 8049980: using guessed type int __cdecl stpncpy(_DWORD, _DWORD, _DWORD);
// 80569FC: using guessed type _DWORD __cdecl sub_80569FC(_DWORD);
// 8064EEB: using guessed type int sub_8064EEB(void);
// 807127C: using guessed type int dword_807127C;

//----- (08050372) --------------------------------------------------------
int __cdecl sub_8050372(int a1)
{
  _BYTE *v1; // ST1C_4

  v1 = (_BYTE *)sub_8056B5B(a1);
  return sub_804AC32(v1);
}
// 8056B5B: using guessed type _DWORD __cdecl sub_8056B5B(_DWORD);

//----- (08050397) --------------------------------------------------------
int __cdecl sub_8050397(char *s, int a2)
{
  int *v2; // ebp
  int v3; // edx
  int v4; // ecx
  char *v5; // eax
  bool v6; // zf
  void *v7; // eax
  int v8; // eax
  int v9; // eax
  int result; // eax
  int v11; // [esp-4h] [ebp-3Ch]
  int v12; // [esp+0h] [ebp-38h]
  char *v13; // [esp+4h] [ebp-34h]
  int v14; // [esp+8h] [ebp-30h]
  unsigned __int8 v15; // [esp+Ch] [ebp-2Ch]
  bool v16; // [esp+1Bh] [ebp-1Dh]
  int v17; // [esp+1Ch] [ebp-1Ch]
  int v18; // [esp+20h] [ebp-18h]
  int v19; // [esp+24h] [ebp-14h]
  void *ptr; // [esp+28h] [ebp-10h]
  int savedregs; // [esp+38h] [ebp+0h]

  v2 = &savedregs;
  v15 = a2;
  v16 = s != 0;
  if ( s && dword_80718A9 )
    sub_804E26C(0, s, 0);
  v17 = dword_80718B5;
  while ( 1 )
  {
    v8 = v17--;
    if ( !v8 )
      break;
    v19 = *((_DWORD *)dword_80718BD + v17);
    if ( (unsigned __int8)sub_80501EC(v19) && (v16 != 1 || (unsigned __int8)sub_8050372(*(_DWORD *)v19) ^ 1) )
    {
      if ( s && **(_BYTE **)v19 != 47 )
      {
        v5 = *(char **)v19;
        v14 = 0;
        v13 = v5;
        ptr = (void *)sub_80570B7((int)s);
        sub_804E26C((char *)ptr, *(char **)(v19 + 4), v15);
        free(ptr);
      }
      else
      {
        sub_804E26C(*(char **)v19, *(char **)(v19 + 4), v15);
      }
      v6 = *(_DWORD *)(v19 + 108) == 9;
      v11 = *(_DWORD *)(v19 + 108);
      v7 = &loc_80504CA;
      if ( !v6 )
        v7 = &loc_80504D5;
      dword_80711DC = (int)v7;
      sub_806526B(v4, v3, v12);
      sub_804ECE6((void **)v19);
    }
  }
  v17 = 0;
  v18 = 0;
  while ( *(v2 - 7) < (unsigned int)dword_80718B5 )
  {
    *(v2 - 3) = *((_DWORD *)dword_80718BD + *(v2 - 7));
    *((_DWORD *)dword_80718BD + *(v2 - 6)) = *(v2 - 3);
    v9 = *(_DWORD *)(*(v2 - 3) + 108);
    v2 = &v12;
    *(v2 - 6) += v9 != 9;
    ++*(v2 - 7);
  }
  result = *(v2 - 6);
  dword_80718B5 = *(v2 - 6);
  return result;
}
// 80501EC: using guessed type _DWORD __cdecl sub_80501EC(_DWORD);
// 80711DC: using guessed type int dword_80711DC;
// 80718B5: using guessed type int dword_80718B5;

//----- (08050564) --------------------------------------------------------
int __cdecl sub_8050564(char *s1, char *s2)
{
  int v2; // edi
  int v3; // esi
  char *v4; // ebx
  int *v5; // eax
  int v7; // [esp+2Ch] [ebp-1Ch]

  *__errno_location() = 0;
  v7 = strcoll(s1, s2);
  if ( *__errno_location() )
  {
    v2 = sub_806072F(1, (int)s2);
    v3 = sub_806072F(0, (int)s1);
    v4 = gettext("cannot compare file names %s and %s");
    v5 = __errno_location();
    error(0, *v5, v4, v3, v2);
    sub_804E1CF(0);
    longjmp(env, 1);
  }
  return v7;
}

//----- (0805061E) --------------------------------------------------------
int __cdecl sub_805061E(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD))
{
  int result; // eax
  int v4; // [esp+1Ch] [ebp-1Ch]
  int v5; // [esp+20h] [ebp-18h]
  int v6; // [esp+24h] [ebp-14h]
  int v7; // [esp+28h] [ebp-10h]
  int v8; // [esp+2Ch] [ebp-Ch]

  sub_8060BF3(&v5, (int)(a1 + 3));
  sub_8060BF3(&v7, (int)(a2 + 3));
  v4 = sub_8060CD3(v7, v8, v5, v6);
  if ( v4 )
    result = v4;
  else
    result = a3(*a1, *a2);
  return result;
}

//----- (080506AC) --------------------------------------------------------
#error "8050723: call analysis failed (funcsize=56)"

//----- (0805075A) --------------------------------------------------------
int __cdecl sub_805075A(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD))
{
  int result; // eax
  int v4; // [esp+1Ch] [ebp-1Ch]
  int v5; // [esp+20h] [ebp-18h]
  int v6; // [esp+24h] [ebp-14h]
  int v7; // [esp+28h] [ebp-10h]
  int v8; // [esp+2Ch] [ebp-Ch]

  sub_8060BC8(&v5, (int)(a1 + 3));
  sub_8060BC8(&v7, (int)(a2 + 3));
  v4 = sub_8060CD3(v7, v8, v5, v6);
  if ( v4 )
    result = v4;
  else
    result = a3(*a1, *a2);
  return result;
}

//----- (080507DA) --------------------------------------------------------
#error "8050820: call analysis failed (funcsize=69)"

//----- (0805089D) --------------------------------------------------------
int sub_805089D()
{
  _DWORD *v1; // [esp+8h] [ebp-14h]
  _DWORD *v2; // [esp+Ch] [ebp-10h]
  int (__stdcall *v3)(_DWORD, _DWORD, _DWORD *, _DWORD *, _DWORD, int); // [esp+10h] [ebp-Ch]
  int v4; // [esp+14h] [ebp-8h]

  return v3(*v1, *v2, v1, v2, v3, v4);
}

//----- (080508CF) --------------------------------------------------------
#error "805097C: call analysis failed (funcsize=59)"

//----- (0805098A) --------------------------------------------------------
int __cdecl sub_805098A(_DWORD *a1, _DWORD *a2)
{
  return sub_805061E(a1, a2, (int (__cdecl *)(_DWORD, _DWORD))sub_8050564);
}

//----- (080509AC) --------------------------------------------------------
int __cdecl sub_80509AC(_DWORD *a1, _DWORD *a2)
{
  return sub_805061E(a1, a2, (int (__cdecl *)(_DWORD, _DWORD))strcmp);
}

//----- (080509CE) --------------------------------------------------------
int __cdecl sub_80509CE(_DWORD *a1, _DWORD *a2)
{
  return sub_805061E(a2, a1, (int (__cdecl *)(_DWORD, _DWORD))sub_8050564);
}

//----- (080509F0) --------------------------------------------------------
int __cdecl sub_80509F0(_DWORD *a1, _DWORD *a2)
{
  return sub_805061E(a2, a1, (int (__cdecl *)(_DWORD, _DWORD))strcmp);
}

//----- (08050A12) --------------------------------------------------------
int __cdecl sub_8050A12(_DWORD *a1, _DWORD *a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_80501EC(a1);
  v4 = sub_80501EC(a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_805061E(a1, a2, (int (__cdecl *)(_DWORD, _DWORD))sub_8050564);
}
// 80501EC: using guessed type _DWORD __cdecl sub_80501EC(_DWORD);

//----- (08050A80) --------------------------------------------------------
int __cdecl sub_8050A80(_DWORD *a1, _DWORD *a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_80501EC(a1);
  v4 = sub_80501EC(a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 )
  {
    if ( v4 )
    {
      dword_807122C = (int)&locret_8050B01;
      sub_80650A5();
    }
  }
  return sub_805061E(a1, a2, (int (__cdecl *)(_DWORD, _DWORD))strcmp);
}
// 80501EC: using guessed type _DWORD __cdecl sub_80501EC(_DWORD);
// 807122C: using guessed type int dword_807122C;

//----- (08050B03) --------------------------------------------------------
#error "8050B5C: call analysis failed (funcsize=48)"

//----- (08050B9F) --------------------------------------------------------
int __cdecl sub_8050B9F(_DWORD *a1, _DWORD *a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_80501EC(a1);
  v4 = sub_80501EC(a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_805061E(a2, a1, (int (__cdecl *)(_DWORD, _DWORD))strcmp);
}
// 80501EC: using guessed type _DWORD __cdecl sub_80501EC(_DWORD);

//----- (08050C0D) --------------------------------------------------------
int __cdecl sub_8050C0D(int a1, int a2)
{
  return sub_80506AC(a1, a2, sub_8050564);
}
// 80506AC: using guessed type _DWORD __cdecl sub_80506AC(_DWORD, _DWORD, _DWORD);

//----- (08050C2F) --------------------------------------------------------
int __cdecl sub_8050C2F(int a1, int a2)
{
  return sub_80506AC(a1, a2, strcmp);
}
// 80506AC: using guessed type _DWORD __cdecl sub_80506AC(_DWORD, _DWORD, _DWORD);

//----- (08050C51) --------------------------------------------------------
int __cdecl sub_8050C51(int a1, int a2)
{
  return sub_80506AC(a2, a1, sub_8050564);
}
// 80506AC: using guessed type _DWORD __cdecl sub_80506AC(_DWORD, _DWORD, _DWORD);

//----- (08050C73) --------------------------------------------------------
int __cdecl sub_8050C73(int a1, int a2)
{
  return sub_80506AC(a2, a1, strcmp);
}
// 80506AC: using guessed type _DWORD __cdecl sub_80506AC(_DWORD, _DWORD, _DWORD);

//----- (08050C95) --------------------------------------------------------
signed int __cdecl sub_8050C95(int a1, int a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_80501EC(a1);
  v4 = sub_80501EC(a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_80506AC(a1, a2, sub_8050564);
}
// 80501EC: using guessed type _DWORD __cdecl sub_80501EC(_DWORD);
// 80506AC: using guessed type _DWORD __cdecl sub_80506AC(_DWORD, _DWORD, _DWORD);

//----- (08050D03) --------------------------------------------------------
#error "8050D7A: call analysis failed (funcsize=48)"

//----- (08050D9F) --------------------------------------------------------
#error "8050DFE: call analysis failed (funcsize=48)"

//----- (08050E3B) --------------------------------------------------------
signed int __cdecl sub_8050E3B(int a1, int a2)
{
  signed int result; // eax
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_80501EC(a1);
  v4 = sub_80501EC(a2);
  if ( v3 && v4 != 1 )
  {
    dword_807122C = (int)&locret_8050EBC;
    sub_80650A5();
  }
  if ( v3 != 1 && v4 )
    result = 1;
  else
    result = sub_80506AC(a2, a1, strcmp);
  return result;
}
// 80501EC: using guessed type _DWORD __cdecl sub_80501EC(_DWORD);
// 80506AC: using guessed type _DWORD __cdecl sub_80506AC(_DWORD, _DWORD, _DWORD);
// 807122C: using guessed type int dword_807122C;

//----- (08050EBE) --------------------------------------------------------
int __cdecl sub_8050EBE(_DWORD *a1, _DWORD *a2)
{
  return sub_805075A(a1, a2, (int (__cdecl *)(_DWORD, _DWORD))sub_8050564);
}

//----- (08050EE0) --------------------------------------------------------
int __cdecl sub_8050EE0(_DWORD *a1, _DWORD *a2)
{
  return sub_805075A(a1, a2, (int (__cdecl *)(_DWORD, _DWORD))strcmp);
}

//----- (08050F02) --------------------------------------------------------
int __cdecl sub_8050F02(_DWORD *a1, _DWORD *a2)
{
  return sub_805075A(a2, a1, (int (__cdecl *)(_DWORD, _DWORD))sub_8050564);
}

//----- (08050F24) --------------------------------------------------------
int __cdecl sub_8050F24(_DWORD *a1, _DWORD *a2)
{
  return sub_805075A(a2, a1, (int (__cdecl *)(_DWORD, _DWORD))strcmp);
}

//----- (08050F46) --------------------------------------------------------
int __cdecl sub_8050F46(_DWORD *a1, _DWORD *a2)
{
  void *v3; // eax
  char v4; // [esp+1Eh] [ebp-Ah]
  char v5; // [esp+1Fh] [ebp-9h]

  v4 = sub_80501EC(a1);
  v5 = sub_80501EC(a2);
  if ( v4 && v5 != 1 )
    return -1;
  if ( v4 == 1 )
    return sub_805075A(a1, a2, (int (__cdecl *)(_DWORD, _DWORD))sub_8050564);
  v3 = &loc_8050FAA;
  if ( !v5 )
    v3 = &loc_8050FB1;
  dword_807122C = (int)v3;
  sub_80650A5();
  return 1;
}
// 80501EC: using guessed type _DWORD __cdecl sub_80501EC(_DWORD);
// 807122C: using guessed type int dword_807122C;

//----- (08050FCD) --------------------------------------------------------
int __cdecl sub_8050FCD(_DWORD *a1, _DWORD *a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_80501EC(a1);
  v4 = sub_80501EC(a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_805075A(a1, a2, (int (__cdecl *)(_DWORD, _DWORD))strcmp);
}
// 80501EC: using guessed type _DWORD __cdecl sub_80501EC(_DWORD);

//----- (0805103B) --------------------------------------------------------
int __cdecl sub_805103B(_DWORD *a1, _DWORD *a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_80501EC(a1);
  v4 = sub_80501EC(a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_805075A(a2, a1, (int (__cdecl *)(_DWORD, _DWORD))sub_8050564);
}
// 80501EC: using guessed type _DWORD __cdecl sub_80501EC(_DWORD);

//----- (080510A9) --------------------------------------------------------
#error "8051108: call analysis failed (funcsize=48)"

//----- (08051145) --------------------------------------------------------
int __cdecl sub_8051145(int a1, int a2)
{
  return sub_80507DA(a1, a2, sub_8050564);
}
// 80507DA: using guessed type _DWORD __cdecl sub_80507DA(_DWORD, _DWORD, _DWORD);

//----- (08051167) --------------------------------------------------------
int __cdecl sub_8051167(int a1, int a2)
{
  return sub_80507DA(a1, a2, strcmp);
}
// 80507DA: using guessed type _DWORD __cdecl sub_80507DA(_DWORD, _DWORD, _DWORD);

//----- (08051189) --------------------------------------------------------
int __cdecl sub_8051189(int a1, int a2)
{
  return sub_80507DA(a2, a1, sub_8050564);
}
// 80507DA: using guessed type _DWORD __cdecl sub_80507DA(_DWORD, _DWORD, _DWORD);

//----- (080511AB) --------------------------------------------------------
int __cdecl sub_80511AB(int a1, int a2)
{
  return sub_80507DA(a2, a1, strcmp);
}
// 80507DA: using guessed type _DWORD __cdecl sub_80507DA(_DWORD, _DWORD, _DWORD);

//----- (080511CD) --------------------------------------------------------
#error "8051240: call analysis failed (funcsize=45)"

//----- (08051265) --------------------------------------------------------
signed int __cdecl sub_8051265(int a1, int a2)
{
  char v2; // ST26_1
  void *v3; // eax
  signed int result; // eax
  char v5; // [esp+1Fh] [ebp-9h]

  v2 = sub_80501EC(a1);
  v5 = sub_80501EC(a2);
  if ( v2 )
  {
    v3 = &loc_80512B1;
    if ( v5 == 1 )
      v3 = &loc_80512B8;
    dword_807122C = (int)v3;
    sub_80650A5();
    result = -1;
  }
  else if ( v5 )
  {
    result = 1;
  }
  else
  {
    result = sub_80507DA(a1, a2, strcmp);
  }
  return result;
}
// 80501EC: using guessed type _DWORD __cdecl sub_80501EC(_DWORD);
// 80507DA: using guessed type _DWORD __cdecl sub_80507DA(_DWORD, _DWORD, _DWORD);
// 807122C: using guessed type int dword_807122C;

//----- (080512EC) --------------------------------------------------------
signed int __cdecl sub_80512EC(int a1, int a2)
{
  int v2; // edx
  int v3; // ecx
  int v5; // [esp+0h] [ebp-28h]
  char v6; // [esp+1Eh] [ebp-Ah]
  char v7; // [esp+1Fh] [ebp-9h]

  v6 = sub_80501EC(a1);
  v7 = sub_80501EC(a2);
  if ( v6 && v7 != 1 )
    return -1;
  if ( v6 != 1 )
  {
    if ( v7 )
    {
      dword_80711DC = (int)&locret_805136D;
      sub_806526B(v3, v2, v5);
    }
  }
  return sub_80507DA(a2, a1, sub_8050564);
}
// 80501EC: using guessed type _DWORD __cdecl sub_80501EC(_DWORD);
// 80507DA: using guessed type _DWORD __cdecl sub_80507DA(_DWORD, _DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;

//----- (0805136F) --------------------------------------------------------
signed int __cdecl sub_805136F(int a1, int a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_80501EC(a1);
  v4 = sub_80501EC(a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_80507DA(a2, a1, strcmp);
}
// 80501EC: using guessed type _DWORD __cdecl sub_80501EC(_DWORD);
// 80507DA: using guessed type _DWORD __cdecl sub_80507DA(_DWORD, _DWORD, _DWORD);

//----- (080513DD) --------------------------------------------------------
int sub_80513DD()
{
  return sub_805089D();
}

//----- (080513FF) --------------------------------------------------------
int sub_80513FF()
{
  return sub_805089D();
}

//----- (08051421) --------------------------------------------------------
int sub_8051421()
{
  return sub_805089D();
}

//----- (08051447) --------------------------------------------------------
int sub_8051447()
{
  return sub_805089D();
}

//----- (08051469) --------------------------------------------------------
#error "80514AF: call analysis failed (funcsize=53)"

//----- (0805151A) --------------------------------------------------------
#error "8051578: call analysis failed (funcsize=40)"

//----- (0805159D) --------------------------------------------------------
int __cdecl sub_805159D(int a1, int a2)
{
  int v2; // edx
  int v3; // ecx
  void *v5; // eax
  int v6; // [esp+0h] [ebp-28h]
  char v7; // [esp+1Eh] [ebp-Ah]
  char v8; // [esp+1Fh] [ebp-9h]

  v7 = sub_80501EC(a1);
  v8 = sub_80501EC(a2);
  if ( v7 && v8 != 1 )
    return -1;
  if ( v7 == 1 )
    return sub_805089D();
  v5 = &loc_8051601;
  if ( !v8 )
    v5 = &loc_8051608;
  dword_8071254 = (int)v5;
  sub_8064FC3(v3, v2, v6);
  return 1;
}
// 80501EC: using guessed type _DWORD __cdecl sub_80501EC(_DWORD);
// 8071254: using guessed type int dword_8071254;

//----- (08051624) --------------------------------------------------------
int __cdecl sub_8051624(int a1, int a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_80501EC(a1);
  v4 = sub_80501EC(a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_805089D();
}
// 80501EC: using guessed type _DWORD __cdecl sub_80501EC(_DWORD);

//----- (08051692) --------------------------------------------------------
int __cdecl sub_8051692(int a1, int a2)
{
  return sub_80508CF(a1, a2, sub_8050564);
}
// 80508CF: using guessed type int __cdecl sub_80508CF(_DWORD, _DWORD, _DWORD);

//----- (080516B4) --------------------------------------------------------
int __cdecl sub_80516B4(int a1, int a2)
{
  return sub_80508CF(a1, a2, strcmp);
}
// 80508CF: using guessed type int __cdecl sub_80508CF(_DWORD, _DWORD, _DWORD);

//----- (080516D6) --------------------------------------------------------
int __cdecl sub_80516D6(int a1, int a2)
{
  return sub_80508CF(a2, a1, sub_8050564);
}
// 80508CF: using guessed type int __cdecl sub_80508CF(_DWORD, _DWORD, _DWORD);

//----- (080516F8) --------------------------------------------------------
int __cdecl sub_80516F8(int a1, int a2)
{
  return sub_80508CF(a2, a1, strcmp);
}
// 80508CF: using guessed type int __cdecl sub_80508CF(_DWORD, _DWORD, _DWORD);

//----- (0805171A) --------------------------------------------------------
#error "8051760: call analysis failed (funcsize=48)"

//----- (080517B6) --------------------------------------------------------
int __cdecl sub_80517B6(int a1, int a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_80501EC(a1);
  v4 = sub_80501EC(a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_80508CF(a1, a2, strcmp);
}
// 80501EC: using guessed type _DWORD __cdecl sub_80501EC(_DWORD);
// 80508CF: using guessed type int __cdecl sub_80508CF(_DWORD, _DWORD, _DWORD);

//----- (08051824) --------------------------------------------------------
int __cdecl sub_8051824(int a1, int a2)
{
  void *v2; // eax
  int result; // eax
  int v4; // [esp+0h] [ebp-28h]
  int v5; // [esp+4h] [ebp-24h]
  int v6; // [esp+8h] [ebp-20h]
  int v7; // [esp+Ch] [ebp-1Ch]
  int v8; // [esp+10h] [ebp-18h]
  int v9; // [esp+14h] [ebp-14h]
  int v10; // [esp+18h] [ebp-10h]
  int v11; // [esp+1Ch] [ebp-Ch]
  int v12; // [esp+20h] [ebp-8h]
  int v13; // [esp+24h] [ebp-4h]
  int savedregs; // [esp+28h] [ebp+0h]

  BYTE2(v11) = sub_80501EC(a1);
  HIBYTE(v11) = sub_80501EC(a2);
  if ( BYTE2(v11) && HIBYTE(v11) != 1 )
  {
    dword_80711F0 = (int)&locret_80518BE;
    sub_80651FD(v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, savedregs);
  }
  v2 = &loc_8051897;
  if ( BYTE2(v11) == 1 )
    v2 = &loc_80518A4;
  dword_807127C = (int)v2;
  sub_8064EEB();
  if ( HIBYTE(v11) )
    result = 1;
  else
    result = sub_80508CF(a2, a1, sub_8050564);
  return result;
}
// 80501EC: using guessed type _DWORD __cdecl sub_80501EC(_DWORD);
// 80508CF: using guessed type int __cdecl sub_80508CF(_DWORD, _DWORD, _DWORD);
// 8064EEB: using guessed type int sub_8064EEB(void);
// 80651FD: using guessed type int __stdcall sub_80651FD(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80711F0: using guessed type int dword_80711F0;
// 807127C: using guessed type int dword_807127C;

//----- (080518C0) --------------------------------------------------------
#error "80518FC: call analysis failed (funcsize=43)"

//----- (08051947) --------------------------------------------------------
int __cdecl sub_8051947(char **a1, char **a2)
{
  return sub_8057665(*a1, *a2);
}

//----- (08051965) --------------------------------------------------------
int __cdecl sub_8051965(char **a1, char **a2)
{
  return sub_8051947(a1, a2);
}

//----- (0805197F) --------------------------------------------------------
int __cdecl sub_805197F(char **a1, char **a2)
{
  return sub_8051947(a2, a1);
}

//----- (08051999) --------------------------------------------------------
int __cdecl sub_8051999(char **a1, char **a2)
{
  int v2; // edx
  int v3; // ecx
  void *v4; // eax
  int result; // eax
  void *v6; // eax
  char v7; // ST27_1
  int v8; // [esp+0h] [ebp-28h]
  int v9; // [esp+0h] [ebp-28h]
  int v10; // [esp+4h] [ebp-24h]
  int v11; // [esp+8h] [ebp-20h]
  int v12; // [esp+Ch] [ebp-1Ch]
  int v13; // [esp+10h] [ebp-18h]
  int v14; // [esp+14h] [ebp-14h]
  int v15; // [esp+18h] [ebp-10h]
  int v16; // [esp+1Ch] [ebp-Ch]
  int v17; // [esp+20h] [ebp-8h]
  int v18; // [esp+24h] [ebp-4h]
  int savedregs; // [esp+28h] [ebp+0h]

  BYTE2(v16) = sub_80501EC(a1);
  HIBYTE(v16) = sub_80501EC(a2);
  v4 = &loc_80519DA;
  if ( !BYTE2(v16) )
    v4 = &loc_80519EC;
  dword_80711DC = (int)v4;
  sub_806526B(v3, v2, v8);
  if ( HIBYTE(v16) != 1 )
    return -1;
  v6 = &loc_8051A10;
  if ( BYTE2(v16) == 1 )
    v6 = &loc_8051A1D;
  dword_80711F0 = (int)v6;
  sub_80651FD(v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, savedregs);
  if ( v7 )
    result = 1;
  else
    result = sub_8051947(a1, a2);
  return result;
}
// 8051999: could not find valid save-restore pair for ebx
// 80501EC: using guessed type _DWORD __cdecl sub_80501EC(_DWORD);
// 80651FD: using guessed type int __stdcall sub_80651FD(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;
// 80711F0: using guessed type int dword_80711F0;

//----- (08051A31) --------------------------------------------------------
signed int __cdecl sub_8051A31(int a1, int a2)
{
  void *v3; // eax
  void *v4; // eax
  int v5; // [esp+0h] [ebp-28h]
  int v6; // [esp+4h] [ebp-24h]
  int v7; // [esp+8h] [ebp-20h]
  int v8; // [esp+Ch] [ebp-1Ch]
  int v9; // [esp+10h] [ebp-18h]
  int v10; // [esp+14h] [ebp-14h]
  int v11; // [esp+18h] [ebp-10h]
  int v12; // [esp+1Ch] [ebp-Ch]
  int v13; // [esp+20h] [ebp-8h]
  int v14; // [esp+24h] [ebp-4h]
  int savedregs; // [esp+28h] [ebp+0h]

  BYTE2(v12) = sub_80501EC(a1);
  HIBYTE(v12) = sub_80501EC(a2);
  if ( BYTE2(v12) && HIBYTE(v12) != 1 )
    return -1;
  v3 = &loc_8051A9F;
  if ( BYTE2(v12) == 1 )
    v3 = &loc_8051AC5;
  dword_807122C = (int)v3;
  sub_80650A5();
  v4 = &loc_8051ABE;
  if ( !HIBYTE(v12) )
    v4 = &loc_8051AC5;
  dword_80711F0 = (int)v4;
  sub_80651FD(v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, savedregs);
  return 1;
}
// 8051A31: could not find valid save-restore pair for ebx
// 80501EC: using guessed type _DWORD __cdecl sub_80501EC(_DWORD);
// 80651FD: using guessed type int __stdcall sub_80651FD(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80711F0: using guessed type int dword_80711F0;
// 807122C: using guessed type int dword_807122C;

//----- (08051AD9) --------------------------------------------------------
int sub_8051AD9()
{
  int result; // eax
  unsigned int i; // [esp+Ch] [ebp-8h]

  for ( i = 0; ; ++i )
  {
    result = dword_80718B5;
    if ( i >= dword_80718B5 )
      break;
    *((_DWORD *)dword_80718BD + i) = (char *)dword_80718AD + 136 * i;
  }
  return result;
}
// 80718B5: using guessed type int dword_80718B5;

//----- (08051B35) --------------------------------------------------------
int sub_8051B35()
{
  int result; // eax
  bool v1; // zf
  void *v2; // eax
  int v3; // eax
  int v4; // [esp+0h] [ebp-28h]
  int v5; // [esp+4h] [ebp-24h]
  int v6; // [esp+8h] [ebp-20h]
  int v7; // [esp+Ch] [ebp-1Ch]

  if ( dword_80718B5 + ((unsigned int)dword_80718B5 >> 1) > dword_80718C1 )
  {
    free(dword_80718BD);
    dword_80718BD = sub_8061577(dword_80718B5, 0xCu);
    dword_80718C1 = 3 * dword_80718B5;
  }
  sub_8051AD9();
  result = dword_807190D;
  if ( dword_807190D != -1 )
  {
    v1 = _setjmp(env) == 0;
    v2 = &loc_8051BDE;
    if ( !v1 )
      v2 = &loc_8051BE4;
    dword_8071268 = (int)v2;
    sub_8064F57(v4, v5, v6, v7);
    if ( dword_807190D == 4 )
      v3 = dword_8071909;
    else
      v3 = 0;
    result = sub_805BA9D(
               (int)dword_80718BD,
               dword_80718B5,
               (int)off_8067B20[2 * (4 * (v3 + dword_807190D) + (unsigned __int8)byte_8071911)
                              + (unsigned __int8)byte_8071943]);
  }
  return result;
}
// 8064F57: using guessed type int __stdcall sub_8064F57(_DWORD, _DWORD, _DWORD, _DWORD);
// 8067B20: using guessed type int (__cdecl *off_8067B20[28])(int, int);
// 8071268: using guessed type int dword_8071268;
// 80718B5: using guessed type int dword_80718B5;
// 80718C1: using guessed type int dword_80718C1;
// 8071909: using guessed type int dword_8071909;
// 807190D: using guessed type int dword_807190D;
// 8071911: using guessed type char byte_8071911;
// 8071943: using guessed type char byte_8071943;

//----- (08051C96) --------------------------------------------------------
int sub_8051C96()
{
  int result; // eax

  result = dword_8071905;
  if ( (unsigned int)dword_8071905 <= 4 )
    JUMPOUT(__CS__, *(&off_8067C1C + dword_8071905));
  return result;
}
// 8067C1C: using guessed type void *off_8067C1C;
// 8071905: using guessed type int dword_8071905;

//----- (08051DCC) --------------------------------------------------------
int __cdecl sub_8051DCC(int a1, int a2, unsigned __int8 a3, int a4, int a5, int a6)
{
  char *v6; // eax

  if ( byte_80727E9 )
    v6 = (char *)(((*(_DWORD *)(a4 + 16) + 12 * a3) << 7) + 134683625);
  else
    v6 = (&off_80713BC)[a3];
  return sub_805BBF7(a1, a2, (int)v6, a4, a5, a6);
}
// 80727E9: using guessed type char byte_80727E9;

//----- (08051E64) --------------------------------------------------------
int __usercall sub_8051E64@<eax>(int a1@<ebx>)
{
  time_t timer; // [esp+2Ch] [ebp-42Ch]
  int v3; // [esp+30h] [ebp-428h]
  struct tm tp; // [esp+34h] [ebp-424h]
  char v5; // [esp+63h] [ebp-3F5h]
  unsigned int v6; // [esp+44Ch] [ebp-Ch]

  v6 = __readgsdword(0x14u);
  if ( dword_80713C8 < 0 )
  {
    timer = 0;
    if ( sub_8063586(dword_8071969, &timer, &tp) )
    {
      v3 = sub_8051DCC((int)&v5, 1001, 0, (int)&tp, dword_8071969, 0);
      if ( v3 )
        dword_80713C8 = sub_805B378(a1, &v5, v3, 0);
    }
    if ( dword_80713C8 < 0 )
      dword_80713C8 = 0;
  }
  return dword_80713C8;
}
// 80713C8: using guessed type int dword_80713C8;

//----- (08051F4C) --------------------------------------------------------
#error "8051FB6: call analysis failed (funcsize=65)"

//----- (08052069) --------------------------------------------------------
int __cdecl sub_8052069(__uid_t uid, int a2, int a3)
{
  const char *v3; // eax
  char v5; // [esp+Ch] [ebp-Ch]

  v5 = a3;
  if ( (_BYTE)a3 == 1 )
  {
    if ( byte_8071913 )
      v3 = 0;
    else
      v3 = (const char *)sub_805A701(uid);
  }
  else
  {
    v3 = "?";
  }
  return sub_8051F4C(v3, uid, a2, *(_DWORD *)&v5);
}
// 8051F4C: using guessed type int __cdecl sub_8051F4C(_DWORD, _DWORD, _DWORD, _DWORD);
// 8071913: using guessed type char byte_8071913;

//----- (080520C0) --------------------------------------------------------
int __cdecl sub_80520C0(__gid_t gid, int a2, int a3)
{
  char *v3; // eax

  if ( (_BYTE)a3 == 1 )
  {
    if ( byte_8071913 )
      v3 = 0;
    else
      v3 = sub_805A964(gid);
  }
  else
  {
    v3 = "?";
  }
  return sub_8051F4C(v3, gid, a2, (_BYTE)a3);
}
// 8051F4C: using guessed type int __cdecl sub_8051F4C(_DWORD, _DWORD, _DWORD, _DWORD);
// 8071913: using guessed type char byte_8071913;

//----- (08052117) --------------------------------------------------------
size_t __usercall sub_8052117@<eax>(int a1@<ebx>, char *a2, int a3)
{
  size_t result; // eax
  int v4; // [esp+0h] [ebp-38h]
  int v5; // [esp+8h] [ebp-30h]
  char *v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+1Ch] [ebp-1Ch]
  char s; // [esp+21h] [ebp-17h]
  unsigned int v9; // [esp+2Ch] [ebp-Ch]

  v6 = a2;
  v9 = __readgsdword(0x14u);
  if ( a2 )
  {
    v7 = sub_805B34F(a1, v6, 0);
    result = 0;
    if ( v7 >= 0 )
      result = v7;
  }
  else
  {
    v5 = a3;
    sprintf(&s, "%lu", a3, v6);
    result = strlen((const char *)&v4 - 23);
  }
  return result;
}

//----- (08052195) --------------------------------------------------------
size_t __usercall sub_8052195@<eax>(int a1@<ebx>, __uid_t uid)
{
  char *v2; // eax

  if ( byte_8071913 )
    v2 = 0;
  else
    v2 = (char *)sub_805A701(uid);
  return sub_8052117(a1, v2, uid);
}
// 8071913: using guessed type char byte_8071913;

//----- (080521CD) --------------------------------------------------------
#error "80521F2: call analysis failed (funcsize=34)"

//----- (0805223C) --------------------------------------------------------
#error "8052289: call analysis failed (funcsize=44)"

//----- (080522CD) --------------------------------------------------------
#error "80522E7: call analysis failed (funcsize=16)"

//----- (080522FA) --------------------------------------------------------
#error "8052420: positive sp value has been found (funcsize=73)"

//----- (08052F38) --------------------------------------------------------
#error "80531B0: call analysis failed (funcsize=316)"

//----- (08053448) --------------------------------------------------------
#error "805344B: positive sp value has been found (funcsize=0)"

//----- (0805344F) --------------------------------------------------------
int __cdecl sub_805344F(void *a1, int a2, int a3)
{
  int v4; // [esp+0h] [ebp-2048h]
  int v5; // [esp+28h] [ebp-2020h]
  void *v6; // [esp+2Ch] [ebp-201Ch]
  unsigned __int8 v7; // [esp+33h] [ebp-2015h]
  void *ptr; // [esp+34h] [ebp-2014h]
  int v9; // [esp+38h] [ebp-2010h]
  char v10; // [esp+3Ch] [ebp-200Ch]
  unsigned int v11; // [esp+203Ch] [ebp-Ch]

  v6 = a1;
  v5 = a2;
  v11 = __readgsdword(0x14u);
  ptr = &v10;
  sub_8052F38(&v4 - 2053, 0x2000, a1, a2, a3, &v9, &v7);
  if ( ptr != &v10 && ptr != v6 )
    free(ptr);
  return v7 + v9;
}
// 8052F38: using guessed type _DWORD __cdecl sub_8052F38(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (08053533) --------------------------------------------------------
#error "8053651: call analysis failed (funcsize=47)"

//----- (08053665) --------------------------------------------------------
int __usercall sub_8053665@<eax>(int a1@<ebx>, void *a2, int a3, int a4, int a5, char a6, int a7, char *a8)
{
  int v8; // edx
  int v9; // ecx
  void *v10; // eax
  int v11; // ebx
  int v12; // edx
  int v13; // ecx
  int v15; // [esp-8h] [ebp-2080h]
  int v16; // [esp-4h] [ebp-207Ch]
  int v17; // [esp+0h] [ebp-2078h]
  void *v18; // [esp+4h] [ebp-2074h]
  const char *v19; // [esp+8h] [ebp-2070h]
  void *v20; // [esp+Ch] [ebp-206Ch]
  int v21; // [esp+10h] [ebp-2068h]
  int v22; // [esp+14h] [ebp-2064h]
  int v23; // [esp+18h] [ebp-2060h]
  int v24; // [esp+1Ch] [ebp-205Ch]
  int v25; // [esp+20h] [ebp-2058h]
  int v26; // [esp+24h] [ebp-2054h]
  char *s; // [esp+28h] [ebp-2050h]
  int v28; // [esp+2Ch] [ebp-204Ch]
  char v29; // [esp+30h] [ebp-2048h]
  int v30; // [esp+34h] [ebp-2044h]
  int v31; // [esp+38h] [ebp-2040h]
  void *v32; // [esp+3Ch] [ebp-203Ch]
  int v33; // [esp+40h] [ebp-2038h]
  void *v34; // [esp+44h] [ebp-2034h]
  int v35; // [esp+48h] [ebp-2030h]
  void *ptr; // [esp+4Ch] [ebp-202Ch]
  void *v37; // [esp+50h] [ebp-2028h]
  int v38; // [esp+54h] [ebp-2024h]
  size_t n; // [esp+58h] [ebp-2020h]
  int v40; // [esp+5Ch] [ebp-201Ch]
  int v41; // [esp+60h] [ebp-2018h]
  size_t v42; // [esp+64h] [ebp-2014h]
  int v43; // [esp+68h] [ebp-2010h]
  char v44; // [esp+6Ch] [ebp-200Ch]
  int v45; // [esp+70h] [ebp-2008h]
  int v46; // [esp+74h] [ebp-2004h]
  int v47; // [esp+78h] [ebp-2000h]
  int v48; // [esp+7Ch] [ebp-1FFCh]
  int v49; // [esp+80h] [ebp-1FF8h]
  int v50; // [esp+84h] [ebp-1FF4h]
  int v51; // [esp+88h] [ebp-1FF0h]
  int v52; // [esp+8Ch] [ebp-1FECh]
  int v53; // [esp+90h] [ebp-1FE8h]
  int v54; // [esp+94h] [ebp-1FE4h]
  int v55; // [esp+98h] [ebp-1FE0h]
  int v56; // [esp+9Ch] [ebp-1FDCh]
  int v57; // [esp+A0h] [ebp-1FD8h]
  int v58; // [esp+A4h] [ebp-1FD4h]
  int v59; // [esp+A8h] [ebp-1FD0h]
  int v60; // [esp+ACh] [ebp-1FCCh]
  int v61; // [esp+B0h] [ebp-1FC8h]
  int v62; // [esp+B4h] [ebp-1FC4h]
  int v63; // [esp+B8h] [ebp-1FC0h]
  int v64; // [esp+BCh] [ebp-1FBCh]
  int v65; // [esp+C0h] [ebp-1FB8h]
  int v66; // [esp+C4h] [ebp-1FB4h]
  unsigned int v67; // [esp+206Ch] [ebp-Ch]

  v32 = a2;
  v31 = a3;
  v30 = a5;
  v29 = a6;
  v28 = a7;
  s = a8;
  v67 = __readgsdword(0x14u);
  v34 = &v44;
  v35 = sub_8052F38(&v17 - 2061, 0x2000, a2, a3, a4, 0, (char *)&v33 + 2);
  v16 = BYTE2(v33);
  v15 = a1;
  v10 = &loc_805373A;
  if ( !BYTE2(v33) )
    v10 = &loc_805375C;
  dword_8071290 = (int)v10;
  v11 = v15;
  sub_8064E79(
    v9,
    v8,
    v17,
    v18,
    v19,
    v20,
    v21,
    v22,
    v23,
    v24,
    v25,
    v26,
    s,
    v28,
    *(_DWORD *)&v29,
    v30,
    v31,
    v32,
    v33,
    v34,
    v35,
    ptr,
    v37,
    v38,
    n,
    v40,
    v41,
    v42,
    v43,
    *(_DWORD *)&v44,
    v45,
    v46,
    v47,
    v48,
    v49,
    v50,
    v51,
    v52,
    v53,
    v54,
    v55,
    v56,
    v57,
    v58,
    v59,
    v60,
    v61,
    v62,
    v63,
    v64,
    v65,
    v66);
  if ( v29 )
  {
    putchar_unlocked(32);
    ++dword_8071A1D;
  }
  if ( v30 )
    sub_8054136(v11, v30);
  HIBYTE(v33) = 0;
  if ( s )
  {
    if ( byte_80718BA && byte_80718B9 && BYTE2(v33) != 1 )
    {
      HIBYTE(v33) = 1;
      putchar_unlocked(*(char *)v34);
    }
    ptr = (void *)sub_8053533(dword_80718C9, 0);
    v37 = (void *)sub_8053533(s, 1);
    if ( *(_BYTE *)v37 == 47 )
    {
      dword_8071290 = (int)&loc_805382B;
      sub_8064E79(
        v13,
        v12,
        v17,
        v18,
        v19,
        v20,
        v21,
        v22,
        v23,
        v24,
        v25,
        v26,
        s,
        v28,
        *(_DWORD *)&v29,
        v30,
        v31,
        v32,
        v33,
        v34,
        v35,
        ptr,
        v37,
        v38,
        n,
        v40,
        v41,
        v42,
        v43,
        *(_DWORD *)&v44,
        v45,
        v46,
        v47,
        v48,
        v49,
        v50,
        v51,
        v52,
        v53,
        v54,
        v55,
        v56,
        v57,
        v58,
        v59,
        v60,
        v61,
        v62,
        v63,
        v64,
        v65,
        v66);
    }
    v20 = v37;
    v19 = "/";
    v18 = ptr;
    printf("\x1B]8;;file://%s%s%s\a", ptr, "/", v37);
    free(ptr);
    free(v37);
  }
  if ( v28 && byte_8071925 )
  {
    v38 = v28;
    n = 4;
    v40 = v28;
    if ( (unsigned int)(*(_DWORD *)(v40 + 16) - *(_DWORD *)(v40 + 12)) < 4 )
      sub_8062BDC(v38, n);
    memcpy(*(void **)(v38 + 12), &dword_8071A1D, n);
    *(_DWORD *)(v38 + 12) += n;
  }
  fwrite_unlocked((char *)v34 + HIBYTE(v33), 1u, v35 - 2 * HIBYTE(v33), stdout);
  dword_8071A1D += v35;
  if ( v28 && byte_8071925 )
  {
    v41 = v28;
    v42 = 4;
    v43 = v28;
    if ( (unsigned int)(*(_DWORD *)(v41 + 16) - *(_DWORD *)(v41 + 12)) < 4 )
      sub_8062BDC(v41, v42);
    memcpy(*(void **)(v41 + 12), &dword_8071A1D, v42);
    *(_DWORD *)(v41 + 12) += v42;
  }
  if ( s )
  {
    fwrite_unlocked("\x1B]8;;\a", 1u, 6u, stdout);
    if ( HIBYTE(v33) )
      putchar_unlocked(*((char *)v34 + v35 - 1));
  }
  if ( v34 != &v44 && v34 != v32 )
    free(v34);
  return BYTE2(v33) + v35;
}
// 8052F38: using guessed type _DWORD __cdecl sub_8052F38(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8062BDC: using guessed type _DWORD __cdecl sub_8062BDC(_DWORD, _DWORD);
// 8064E79: using guessed type int __fastcall sub_8064E79(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8071290: using guessed type int dword_8071290;
// 80718B9: using guessed type char byte_80718B9;
// 80718BA: using guessed type char byte_80718BA;
// 8071925: using guessed type char byte_8071925;
// 8071A1D: using guessed type int dword_8071A1D;

//----- (08053B1C) --------------------------------------------------------
int __usercall sub_8053B1C@<eax>(int a1@<ebx>, void **a2, unsigned __int8 a3, int a4, unsigned int a5)
{
  void *v5; // eax
  int v6; // eax
  bool v7; // al
  int v8; // edx
  char *v10; // [esp+18h] [ebp-30h]
  unsigned __int8 v11; // [esp+1Ch] [ebp-2Ch]
  bool v12; // [esp+23h] [ebp-25h]
  void *v13; // [esp+24h] [ebp-24h]
  int v14; // [esp+28h] [ebp-20h]
  int v15; // [esp+2Ch] [ebp-1Ch]

  v11 = a3;
  if ( a3 )
    v5 = a2[1];
  else
    v5 = *a2;
  v13 = v5;
  if ( byte_807192D )
    v6 = sub_8054187(a2, v11);
  else
    v6 = 0;
  v14 = v6;
  v7 = byte_807192D && (v14 || (unsigned __int8)sub_804B915(a1, 4));
  v12 = v7;
  v8 = (int)a2[33];
  v10 = (char *)a2[2];
  v15 = sub_8053665(a4, v13, dword_8071955, v8, v14, v11 == 0, a4, v10);
  sub_804BA99();
  if ( v12 )
  {
    sub_8053C7E();
    if ( dword_8071965 )
    {
      if ( a5 / dword_8071965 != (a5 + v15 - 1) / dword_8071965 )
        sub_805459D((int)&unk_80713B4);
    }
  }
  return v15;
}
// 804BA99: using guessed type int sub_804BA99(void);
// 8054187: using guessed type _DWORD __cdecl sub_8054187(_DWORD, _DWORD);
// 807192D: using guessed type char byte_807192D;
// 8071955: using guessed type int dword_8071955;
// 8071965: using guessed type int dword_8071965;

//----- (08053C7E) --------------------------------------------------------
size_t sub_8053C7E()
{
  if ( dword_8071310 )
    return sub_805459D((int)&unk_807130C);
  sub_805459D((int)dword_80712FC);
  sub_805459D((int)&unk_8071314);
  return sub_805459D((int)&dword_8071304);
}
// 80712FC: using guessed type int dword_80712FC[];
// 8071304: using guessed type int dword_8071304;
// 8071310: using guessed type int dword_8071310;

//----- (08053CD1) --------------------------------------------------------
int __usercall sub_8053CD1@<eax>(int a1@<ebx>, int a2, unsigned int a3)
{
  const char *v3; // edx
  int v4; // eax
  const char *v5; // eax
  int v6; // edx
  int v7; // eax
  int v8; // edx
  int v9; // eax
  unsigned __int8 v10; // al
  int v12; // [esp-2Ch] [ebp-2D8h]
  int v13; // [esp-28h] [ebp-2D4h]
  const char *v14; // [esp-24h] [ebp-2D0h]
  int v15; // [esp+0h] [ebp-2ACh]
  int v16; // [esp+10h] [ebp-29Ch]
  char s; // [esp+14h] [ebp-298h]
  unsigned int v18; // [esp+2A0h] [ebp-Ch]
  int v19; // [esp+2A4h] [ebp-8h]

  v19 = a1;
  v15 = a2;
  v18 = __readgsdword(0x14u);
  sub_804B9FF(a1);
  if ( byte_807193A )
  {
    v3 = (const char *)sub_805223C(&s, 652, v15);
    if ( dword_8071905 == 4 )
      v4 = 0;
    else
      v4 = dword_80718DD;
    v14 = v3;
    v13 = v4;
    printf("%*s ", v4, v3);
  }
  if ( byte_8071914 )
  {
    if ( *(_BYTE *)(v15 + 120) == 1 )
    {
      a1 = *(&qword_8071919 + 1);
      v5 = (const char *)sub_8059747(
                           *(_DWORD *)(v15 + 68),
                           *(_DWORD *)(v15 + 72),
                           (char *)&v12 - 664,
                           dword_8071915,
                           512,
                           0,
                           qword_8071919,
                           *(&qword_8071919 + 1));
    }
    else
    {
      v5 = "?";
    }
    if ( dword_8071905 == 4 )
      v6 = 0;
    else
      v6 = dword_80718E1;
    v14 = v5;
    v13 = v6;
    printf("%*s ", v6, v5);
  }
  if ( byte_80718D9 )
  {
    if ( dword_8071905 == 4 )
      v7 = 0;
    else
      v7 = dword_80718E9;
    v14 = *(const char **)(v15 + 116);
    v13 = v7;
    printf("%*s ", v7, v14);
  }
  v16 = sub_8053B1C(a1, (void **)v15, 0, 0, a3);
  if ( dword_8071929 )
  {
    v8 = *(_DWORD *)(v15 + 28);
    v9 = *(unsigned __int8 *)(v15 + 120);
    v14 = *(const char **)(v15 + 108);
    v10 = sub_80540BC(v9, v8, v14);
    v16 += v10;
  }
  return v16;
}
// 805223C: using guessed type _DWORD __cdecl sub_805223C(_DWORD, _DWORD, _DWORD);
// 80540BC: using guessed type int __cdecl sub_80540BC(_DWORD, _DWORD, _DWORD);
// 80718D9: using guessed type char byte_80718D9;
// 80718DD: using guessed type int dword_80718DD;
// 80718E1: using guessed type int dword_80718E1;
// 80718E9: using guessed type int dword_80718E9;
// 8071905: using guessed type int dword_8071905;
// 8071914: using guessed type char byte_8071914;
// 8071929: using guessed type int dword_8071929;
// 807193A: using guessed type char byte_807193A;

//----- (08053EEE) --------------------------------------------------------
#error "8053F37: call analysis failed (funcsize=90)"

//----- (080540BC) --------------------------------------------------------
#error "80540DE: call analysis failed (funcsize=13)"

//----- (080540E3) --------------------------------------------------------
#error "8054131: positive sp value has been found (funcsize=0)"

//----- (08054136) --------------------------------------------------------
bool __usercall sub_8054136@<al>(int a1@<ebx>, int a2)
{
  if ( a2 )
  {
    if ( (unsigned __int8)sub_804B915(a1, 4) )
      sub_804B9DF();
    sub_805459D((int)dword_80712FC);
    sub_805459D(a2);
    sub_805459D((int)&dword_8071304);
  }
  return a2 != 0;
}
// 80712FC: using guessed type int dword_80712FC[];
// 8071304: using guessed type int dword_8071304;

//----- (08054187) --------------------------------------------------------
#error "8054354: call analysis failed (funcsize=291)"

//----- (0805459D) --------------------------------------------------------
size_t __cdecl sub_805459D(int a1)
{
  if ( byte_807192F != 1 )
  {
    byte_807192F = 1;
    if ( tcgetpgrp(1) >= 0 )
      sub_804BD69();
    sub_8053C7E();
  }
  return fwrite_unlocked(*(const void **)(a1 + 4), *(_DWORD *)a1, 1u, stdout);
}
// 807192F: using guessed type char byte_807192F;

//----- (08054601) --------------------------------------------------------
int __usercall sub_8054601@<eax>(int a1@<ebx>, int a2)
{
  const char *v2; // eax
  int v3; // eax
  void *v4; // eax
  const char *v5; // eax
  int v6; // eax
  int v7; // eax
  void *v8; // eax
  int result; // eax
  unsigned int v10; // ebx
  int v11; // [esp-8h] [ebp-2E0h]
  int v12; // [esp-4h] [ebp-2DCh]
  const char *v13; // [esp+0h] [ebp-2D8h]
  int v14; // [esp+8h] [ebp-2D0h]
  int v15; // [esp+2Ch] [ebp-2ACh]
  unsigned int v16; // [esp+2CCh] [ebp-Ch]

  v15 = a2;
  v16 = __readgsdword(0x14u);
  *(&v13 - 167) = 0;
  if ( byte_807193A )
  {
    if ( dword_8071905 == 4 )
    {
      v2 = (const char *)sub_805ACBC(*((_DWORD *)*(&v13 - 171) + 25), *((_DWORD *)*(&v13 - 171) + 26), &v13 - 166);
      v3 = strlen(v2) + 1;
    }
    else
    {
      v3 = dword_80718DD + 1;
    }
    *(&v13 - 167) += v3;
  }
  v12 = (unsigned __int8)byte_8071914;
  v11 = a1;
  v4 = &loc_80546B0;
  if ( !byte_8071914 )
    v4 = &loc_8054751;
  dword_807127C = (int)v4;
  sub_8064EEB();
  if ( dword_8071905 == 4 )
  {
    if ( (*(&v13 - 171))[120] == 1 )
      v5 = (const char *)sub_8059747(
                           *((_DWORD *)*(&v13 - 171) + 17),
                           *((_DWORD *)*(&v13 - 171) + 18),
                           (char *)&v13 - 664,
                           dword_8071915,
                           512,
                           0,
                           qword_8071919,
                           *(&qword_8071919 + 1));
    else
      v5 = "?";
    v6 = strlen(v5) + 1;
  }
  else
  {
    v6 = dword_80718E1 + 1;
  }
  *(&v13 - 167) += v6;
  if ( byte_80718D9 )
  {
    if ( dword_8071905 == 4 )
    {
      v13 = (const char *)*((_DWORD *)*(&v13 - 171) + 29);
      v7 = strlen(v13) + 1;
    }
    else
    {
      v7 = dword_80718E9 + 1;
    }
    *(&v13 - 167) += v7;
  }
  v8 = *(void **)*(&v13 - 171);
  v14 = *((_DWORD *)*(&v13 - 171) + 33);
  *(&v13 - 167) += sub_805344F(v8, dword_8071955, v14);
  if ( dword_8071929 )
  {
    *((_BYTE *)&v13 - 669) = sub_8053EEE(
                               *((unsigned __int8 *)*(&v13 - 171) + 120),
                               *((_DWORD *)*(&v13 - 171) + 7),
                               *((_DWORD *)*(&v13 - 171) + 27));
    *(&v13 - 167) += *((_BYTE *)&v13 - 669) != 0;
  }
  result = (int)*(&v13 - 167);
  v10 = __readgsdword(0x14u) ^ (unsigned int)*(&v13 - 3);
  return result;
}
// 8053EEE: using guessed type _DWORD __cdecl sub_8053EEE(_DWORD, _DWORD, _DWORD);
// 805ACBC: using guessed type int __cdecl sub_805ACBC(_DWORD, _DWORD, _DWORD);
// 8064EEB: using guessed type int sub_8064EEB(void);
// 807127C: using guessed type int dword_807127C;
// 80718D9: using guessed type char byte_80718D9;
// 80718DD: using guessed type int dword_80718DD;
// 80718E1: using guessed type int dword_80718E1;
// 80718E9: using guessed type int dword_80718E9;
// 8071905: using guessed type int dword_8071905;
// 8071914: using guessed type char byte_8071914;
// 8071929: using guessed type int dword_8071929;
// 807193A: using guessed type char byte_807193A;
// 8071955: using guessed type int dword_8071955;

//----- (0805485E) --------------------------------------------------------
unsigned int __usercall sub_805485E@<eax>(int a1@<ebx>)
{
  int v1; // ecx
  int v2; // eax
  int v3; // eax
  unsigned int result; // eax
  int v5; // [esp+0h] [ebp-48h]
  int v6; // [esp+4h] [ebp-44h]
  int v7; // [esp+28h] [ebp-20h]

  v7 = sub_8054F9B(1);
  *(&v5 - 7) = (int)dword_8071A15 + 12 * v7 - 12;
  *(&v5 - 6) = dword_80718B5 / (unsigned int)*(&v5 - 8) + (dword_80718B5 % (unsigned int)*(&v5 - 8) != 0);
  *(&v5 - 12) = 0;
  dword_807122C = (int)&loc_80549AE;
  sub_80650A5();
  do
  {
    *(&v5 - 11) = 0;
    *(&v5 - 10) = *(&v5 - 12);
    for ( *(&v5 - 9) = 0; ; *(&v5 - 9) += *(&v5 - 3) )
    {
      *(&v5 - 5) = *((_DWORD *)dword_80718BD + *(&v5 - 10));
      v5 = *(&v5 - 5);
      *(&v5 - 4) = sub_8054601(a1, v5);
      v1 = *(_DWORD *)(*(&v5 - 7) + 8);
      v2 = *(&v5 - 11);
      *(&v5 - 11) = v2 + 1;
      *(&v5 - 3) = *(_DWORD *)(v1 + 4 * v2);
      sub_8053CD1(a1, *(&v5 - 5), *(&v5 - 9));
      *(&v5 - 10) += *(&v5 - 6);
      if ( *(&v5 - 10) >= (unsigned int)dword_80718B5 )
        break;
      v3 = *(&v5 - 9) + *(&v5 - 4);
      v6 = *(&v5 - 3) + *(&v5 - 9);
      v5 = v3;
      sub_8054C0A();
    }
    putchar_unlocked(10);
    result = ++*(&v5 - 12);
  }
  while ( result < *(&v5 - 6) );
  return result;
}
// 8054F9B: using guessed type int __cdecl sub_8054F9B(_DWORD);
// 807122C: using guessed type int dword_807122C;
// 80718B5: using guessed type int dword_80718B5;

//----- (080549BC) --------------------------------------------------------
int __usercall sub_80549BC@<eax>(int a1@<ebx>)
{
  int v1; // ST28_4
  int v2; // ST28_4
  unsigned int i; // [esp+10h] [ebp-28h]
  unsigned int v5; // [esp+14h] [ebp-24h]
  int v6; // [esp+1Ch] [ebp-1Ch]
  unsigned int v7; // [esp+20h] [ebp-18h]
  char *v8; // [esp+24h] [ebp-14h]

  v5 = 0;
  v7 = sub_8054F9B(0);
  v8 = (char *)dword_8071A15 + 12 * v7 - 12;
  v1 = *(_DWORD *)dword_80718BD;
  sub_8054601(a1, *(_DWORD *)dword_80718BD);
  v6 = **((_DWORD **)v8 + 2);
  sub_8053CD1(a1, v1, 0);
  for ( i = 1; i < dword_80718B5; ++i )
  {
    if ( i % v7 )
    {
      sub_8054C0A();
      v5 += v6;
    }
    else
    {
      putchar_unlocked(10);
      v5 = 0;
    }
    v2 = *((_DWORD *)dword_80718BD + i);
    sub_8053CD1(a1, *((_DWORD *)dword_80718BD + i), v5);
    sub_8054601(a1, v2);
    v6 = *(_DWORD *)(4 * (i % v7) + *((_DWORD *)v8 + 2));
  }
  return putchar_unlocked(10);
}
// 8054F9B: using guessed type int __cdecl sub_8054F9B(_DWORD);
// 80718B5: using guessed type int dword_80718B5;

//----- (08054B08) --------------------------------------------------------
int __usercall sub_8054B08@<eax>(int a1@<ebx>, char a2)
{
  int *v2; // ebp
  int v3; // eax
  int v5; // [esp+0h] [ebp-38h]
  char v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+20h] [ebp-18h]
  int v8; // [esp+24h] [ebp-14h]
  int savedregs; // [esp+38h] [ebp+0h]

  v2 = &savedregs;
  v6 = a2;
  v8 = 0;
  v7 = 0;
  while ( *(v2 - 6) < (unsigned int)dword_80718B5 )
  {
    *(v2 - 4) = *((_DWORD *)dword_80718BD + *(v2 - 6));
    if ( dword_8071965 )
    {
      v5 = *(v2 - 4);
      v3 = sub_8054601(a1, v5);
    }
    else
    {
      v3 = 0;
    }
    *(v2 - 3) = v3;
    if ( *(v2 - 6) )
    {
      if ( dword_8071965
        && (*(v2 - 5) + *(v2 - 3) + 2 >= (unsigned int)dword_8071965
         || (v2 = &v5, -3 - *(&v5 - 3) < (unsigned int)*(&v5 - 5))) )
      {
        *(v2 - 5) = 0;
        *((_BYTE *)v2 - 25) = 10;
      }
      else
      {
        *(v2 - 5) += 2;
        *((_BYTE *)v2 - 25) = 32;
      }
      putchar_unlocked(*((char *)v2 - 44));
      putchar_unlocked(*((char *)v2 - 25));
    }
    sub_8053CD1(a1, *(v2 - 4), *(v2 - 5));
    *(v2 - 5) += *(v2 - 3);
    ++*(v2 - 6);
  }
  return putchar_unlocked(10);
}
// 80718B5: using guessed type int dword_80718B5;
// 8071965: using guessed type int dword_8071965;

//----- (08054C0A) --------------------------------------------------------
unsigned int sub_8054C0A()
{
  int *v0; // ebp
  unsigned int v1; // ecx
  unsigned int v2; // eax
  unsigned int result; // eax
  int v4; // [esp+0h] [ebp-28h]
  unsigned int v5; // [esp+8h] [ebp-20h]
  int savedregs; // [esp+28h] [ebp+0h]

  v0 = &savedregs;
  while ( 1 )
  {
    result = v0[2];
    if ( result >= v0[3] )
      break;
    if ( dword_807195D && (v1 = v0[3] / (unsigned int)dword_807195D, v2 = v0[2] + 1, v0 = &v4, v1 > v2 / dword_807195D) )
    {
      putchar_unlocked(9);
      v5 += dword_807195D - v5 % dword_807195D;
    }
    else
    {
      putchar_unlocked(32);
      ++v0[2];
    }
  }
  return result;
}
// 807195D: using guessed type int dword_807195D;

//----- (08054CBB) --------------------------------------------------------
_BYTE *__cdecl sub_8054CBB(_BYTE *a1, _BYTE *a2, _BYTE *a3)
{
  _BYTE *v3; // eax
  _BYTE *v4; // edx
  _BYTE *v5; // eax
  _BYTE *v6; // eax
  _BYTE *v7; // edx
  _BYTE *result; // eax
  _BYTE *v9; // [esp+Ch] [ebp-4h]

  v9 = a2;
  if ( *a2 != 46 || a2[1] )
  {
    while ( *v9 )
    {
      v3 = a1++;
      v4 = v9++;
      *v3 = *v4;
    }
    if ( v9 > a2 && *(v9 - 1) != 47 )
    {
      v5 = a1++;
      *v5 = 47;
    }
  }
  while ( *a3 )
  {
    v6 = a1++;
    v7 = a3++;
    *v6 = *v7;
  }
  result = a1;
  *a1 = 0;
  return result;
}

//----- (08054D5D) --------------------------------------------------------
#error "8054DD7: call analysis failed (funcsize=159)"

//----- (08054F9B) --------------------------------------------------------
#error "8054FAD: call analysis failed (funcsize=13)"

//----- (08054FC0) --------------------------------------------------------
#error "8055240: positive sp value has been found (funcsize=121)"

//----- (08055242) --------------------------------------------------------
void __cdecl __noreturn sub_8055242(int status)
{
  int v1; // ebx
  char *v2; // eax
  int v3; // ebx
  char *v4; // eax
  FILE *v5; // ebx
  char *v6; // eax
  FILE *v7; // ebx
  char *v8; // eax
  FILE *v9; // ebx
  char *v10; // eax
  FILE *v11; // ebx
  char *v12; // eax
  FILE *v13; // ebx
  char *v14; // eax
  FILE *v15; // ebx
  char *v16; // eax
  FILE *v17; // ebx
  char *v18; // eax
  FILE *v19; // ebx
  char *v20; // eax
  FILE *v21; // ebx
  char *v22; // eax
  FILE *v23; // ebx
  char *v24; // eax
  FILE *v25; // ebx
  char *v26; // eax
  FILE *v27; // ebx
  char *v28; // eax
  FILE *v29; // ebx
  char *v30; // eax
  FILE *v31; // ebx
  char *v32; // eax
  FILE *v33; // ebx
  char *v34; // eax
  FILE *v35; // ebx
  char *v36; // eax
  FILE *v37; // ebx
  char *v38; // eax
  FILE *v39; // ebx
  char *v40; // eax
  FILE *v41; // ebx
  char *v42; // eax
  FILE *v43; // ebx
  char *v44; // eax
  FILE *v45; // ebx
  char *v46; // eax
  FILE *v47; // ebx
  char *v48; // eax
  FILE *v49; // ebx
  char *v50; // eax
  FILE *v51; // ebx
  char *v52; // eax
  char *v53; // eax
  int v54; // [esp+4h] [ebp-14h]
  int v55; // [esp+8h] [ebp-10h]

  if ( status )
  {
    v1 = dword_80728DD;
    v2 = gettext("Try '%s --help' for more information.\n");
    v55 = v1;
    fprintf(stderr, v2, v1);
    dword_807122C = (int)&loc_80555B9;
    sub_80650A5();
  }
  v3 = dword_80728DD;
  v4 = gettext("Usage: %s [OPTION]... [FILE]...\n");
  v54 = v3;
  printf(v4, v3);
  v5 = stdout;
  v6 = gettext(
         "List information about the FILEs (the current directory by default).\n"
         "Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.\n");
  fputs_unlocked(v6, v5);
  sub_804ACD7();
  v7 = stdout;
  v8 = gettext(
         "  -a, --all                  do not ignore entries starting with .\n"
         "  -A, --almost-all           do not list implied . and ..\n"
         "      --author               with -l, print the author of each file\n"
         "  -b, --escape               print C-style escapes for nongraphic characters\n");
  fputs_unlocked(v8, v7);
  v9 = stdout;
  v10 = gettext(
          "      --block-size=SIZE      scale sizes by SIZE before printing them; e.g.,\n"
          "                               '--block-size=M' prints sizes in units of\n"
          "                               1,048,576 bytes; see SIZE format below\n"
          "  -B, --ignore-backups       do not list implied entries ending with ~\n"
          "  -c                         with -lt: sort by, and show, ctime (time of last\n"
          "                               modification of file status information);\n"
          "                               with -l: show ctime and sort by name;\n"
          "                               otherwise: sort by ctime, newest first\n");
  fputs_unlocked(v10, v9);
  v11 = stdout;
  v12 = gettext(
          "  -C                         list entries by columns\n"
          "      --color[=WHEN]         colorize the output; WHEN can be 'always' (default\n"
          "                               if omitted), 'auto', or 'never'; more info below\n"
          "  -d, --directory            list directories themselves, not their contents\n"
          "  -D, --dired                generate output designed for Emacs' dired mode\n");
  fputs_unlocked(v12, v11);
  v13 = stdout;
  v14 = gettext(
          "  -f                         do not sort, enable -aU, disable -ls --color\n"
          "  -F, --classify             append indicator (one of */=>@|) to entries\n"
          "      --file-type            likewise, except do not append '*'\n"
          "      --format=WORD          across -x, commas -m, horizontal -x, long -l,\n"
          "                               single-column -1, verbose -l, vertical -C\n"
          "      --full-time            like -l --time-style=full-iso\n");
  fputs_unlocked(v14, v13);
  v15 = stdout;
  v16 = gettext("  -g                         like -l, but do not list owner\n");
  fputs_unlocked(v16, v15);
  v17 = stdout;
  v18 = gettext(
          "      --group-directories-first\n"
          "                             group directories before files;\n"
          "                               can be augmented with a --sort option, but any\n"
          "                               use of --sort=none (-U) disables grouping\n");
  fputs_unlocked(v18, v17);
  v19 = stdout;
  v20 = gettext(
          "  -G, --no-group             in a long listing, don't print group names\n"
          "  -h, --human-readable       with -l and/or -s, print human readable sizes\n"
          "                               (e.g., 1K 234M 2G)\n"
          "      --si                   likewise, but use powers of 1000 not 1024\n");
  fputs_unlocked(v20, v19);
  v21 = stdout;
  v22 = gettext(
          "  -H, --dereference-command-line\n"
          "                             follow symbolic links listed on the command line\n"
          "      --dereference-command-line-symlink-to-dir\n"
          "                             follow each command line symbolic link\n"
          "                               that points to a directory\n"
          "      --hide=PATTERN         do not list implied entries matching shell PATTERN\n"
          "                               (overridden by -a or -A)\n");
  fputs_unlocked(v22, v21);
  v23 = stdout;
  v24 = gettext(
          "      --hyperlink[=WHEN]     hyperlink file names; WHEN can be 'always'\n"
          "                               (default if omitted), 'auto', or 'never'\n");
  fputs_unlocked(v24, v23);
  v25 = stdout;
  v26 = gettext(
          "      --indicator-style=WORD  append indicator with style WORD to entry names:\n"
          "                               none (default), slash (-p),\n"
          "                               file-type (--file-type), classify (-F)\n"
          "  -i, --inode                print the index number of each file\n"
          "  -I, --ignore=PATTERN       do not list implied entries matching shell PATTERN\n"
          "  -k, --kibibytes            default to 1024-byte blocks for disk usage\n");
  fputs_unlocked(v26, v25);
  v27 = stdout;
  v28 = gettext(
          "  -l                         use a long listing format\n"
          "  -L, --dereference          when showing file information for a symbolic\n"
          "                               link, show information for the file the link\n"
          "                               references rather than for the link itself\n"
          "  -m                         fill width with a comma separated list of entries\n");
  fputs_unlocked(v28, v27);
  v29 = stdout;
  v30 = gettext(
          "  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs\n"
          "  -N, --literal              print entry names without quoting\n"
          "  -o                         like -l, but do not list group information\n"
          "  -p, --indicator-style=slash\n"
          "                             append / indicator to directories\n");
  fputs_unlocked(v30, v29);
  v31 = stdout;
  v32 = gettext(
          "  -q, --hide-control-chars   print ? instead of nongraphic characters\n"
          "      --show-control-chars   show nongraphic characters as-is (the default,\n"
          "                               unless program is 'ls' and output is a terminal)\n"
          "  -Q, --quote-name           enclose entry names in double quotes\n"
          "      --quoting-style=WORD   use quoting style WORD for entry names:\n"
          "                               literal, locale, shell, shell-always,\n"
          "                               shell-escape, shell-escape-always, c, escape\n");
  fputs_unlocked(v32, v31);
  v33 = stdout;
  v34 = gettext(
          "  -r, --reverse              reverse order while sorting\n"
          "  -R, --recursive            list subdirectories recursively\n"
          "  -s, --size                 print the allocated size of each file, in blocks\n");
  fputs_unlocked(v34, v33);
  v35 = stdout;
  v36 = gettext(
          "  -S                         sort by file size, largest first\n"
          "      --sort=WORD            sort by WORD instead of name: none (-U), size (-S),\n"
          "                               time (-t), version (-v), extension (-X)\n"
          "      --time=WORD            with -l, show time as WORD instead of default\n"
          "                               modification time: atime or access or use (-u);\n"
          "                               ctime or status (-c); also use specified time\n"
          "                               as sort key if --sort=time (newest first)\n");
  fputs_unlocked(v36, v35);
  v37 = stdout;
  v38 = gettext(
          "      --time-style=STYLE     with -l, show times using style STYLE:\n"
          "                               full-iso, long-iso, iso, locale, or +FORMAT;\n"
          "                               FORMAT is interpreted like in 'date'; if FORMAT\n"
          "                               is FORMAT1<newline>FORMAT2, then FORMAT1 applies\n"
          "                               to non-recent files and FORMAT2 to recent files;\n"
          "                               if STYLE is prefixed with 'posix-', STYLE\n"
          "                               takes effect only outside the POSIX locale\n");
  fputs_unlocked(v38, v37);
  v39 = stdout;
  v40 = gettext(
          "  -t                         sort by modification time, newest first\n"
          "  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8\n");
  fputs_unlocked(v40, v39);
  v41 = stdout;
  v42 = gettext(
          "  -u                         with -lt: sort by, and show, access time;\n"
          "                               with -l: show access time and sort by name;\n"
          "                               otherwise: sort by access time, newest first\n"
          "  -U                         do not sort; list entries in directory order\n"
          "  -v                         natural sort of (version) numbers within text\n");
  fputs_unlocked(v42, v41);
  v43 = stdout;
  v44 = gettext(
          "  -w, --width=COLS           set output width to COLS.  0 means no limit\n"
          "  -x                         list entries by lines instead of by columns\n"
          "  -X                         sort alphabetically by entry extension\n"
          "  -Z, --context              print any security context of each file\n"
          "  -1                         list one file per line.  Avoid '\\n' with -q or -b\n");
  fputs_unlocked(v44, v43);
  v45 = stdout;
  v46 = gettext("      --help     display this help and exit\n");
  fputs_unlocked(v46, v45);
  v47 = stdout;
  v48 = gettext("      --version  output version information and exit\n");
  fputs_unlocked(v48, v47);
  sub_804AD0C();
  v49 = stdout;
  v50 = gettext(
          "\n"
          "Using color to distinguish file types is disabled both by default and\n"
          "with --color=never.  With --color=auto, ls emits color codes only when\n"
          "standard output is connected to a terminal.  The LS_COLORS environment\n"
          "variable can change the settings.  Use the dircolors command to set it.\n");
  fputs_unlocked(v50, v49);
  v51 = stdout;
  v52 = gettext(
          "\n"
          "Exit status:\n"
          " 0  if OK,\n"
          " 1  if minor problems (e.g., cannot access subdirectory),\n"
          " 2  if serious trouble (e.g., cannot access command-line argument).\n");
  fputs_unlocked(v52, v51);
  if ( dword_8071404 == 1 )
  {
    v53 = "ls";
  }
  else if ( dword_8071404 == 2 )
  {
    v53 = "dir";
  }
  else
  {
    v53 = "vdir";
  }
  sub_804AD37(v53);
  exit(status);
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 807122C: using guessed type int dword_807122C;
// 8071404: using guessed type int dword_8071404;
// 80728DD: using guessed type int dword_80728DD;

//----- (080555C4) --------------------------------------------------------
#error "805567A: call analysis failed (funcsize=104)"

//----- (08055716) --------------------------------------------------------
void __noreturn sub_8055716()
{
  sub_8055242(1);
}

//----- (0805572A) --------------------------------------------------------
int __cdecl sub_805572A(char *s, int a2, int a3, size_t a4)
{
  int v4; // edx
  int v5; // ecx
  int result; // eax
  int v7; // [esp+0h] [ebp-28h]
  char v8; // [esp+13h] [ebp-15h]
  signed int i; // [esp+14h] [ebp-14h]
  signed int v10; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]

  v10 = -1;
  v8 = 0;
  n = strlen(s);
  for ( i = 0; *(_DWORD *)(4 * i + a2); ++i )
  {
    if ( !strncmp(*(const char **)(4 * i + a2), s, n) )
    {
      if ( strlen(*(const char **)(4 * i + a2)) == n )
        return i;
      if ( v10 == -1 )
      {
        v10 = i;
        dword_80711DC = (int)&loc_805582B;
        sub_806526B(v5, v4, v7);
      }
      if ( !a3 || memcmp((const void *)(a3 + a4 * v10), (const void *)(i * a4 + a3), a4) )
        v8 = 1;
    }
  }
  if ( v8 )
    result = -2;
  else
    result = v10;
  return result;
}
// 80711DC: using guessed type int dword_80711DC;

//----- (0805585A) --------------------------------------------------------
void __cdecl sub_805585A(int a1, int a2, int a3)
{
  char *v3; // eax
  int v4; // ebx
  int v5; // eax
  char *msgid; // [esp+0h] [ebp-3Ch]
  char *format; // [esp+8h] [ebp-34h]
  int v8; // [esp+Ch] [ebp-30h]
  int v9; // [esp+10h] [ebp-2Ch]
  char *v10; // [esp+2Ch] [ebp-10h]

  if ( a3 == -1 )
    v3 = gettext("invalid argument %s for %s");
  else
    v3 = gettext("ambiguous argument %s for %s");
  v10 = v3;
  v4 = sub_806072F(1, (int)format);
  v5 = sub_8060238(0, 8, v8);
  v9 = v4;
  v8 = v5;
  error(0, 0, *(&msgid - 3), v5, v4);
}

//----- (08055901) --------------------------------------------------------
int __cdecl sub_8055901(int a1, int a2, size_t n)
{
  FILE *v3; // ebx
  char *v4; // eax
  const void *v6; // [esp+4h] [ebp-24h]
  int v7; // [esp+8h] [ebp-20h]
  int i; // [esp+18h] [ebp-10h]
  void *s1; // [esp+1Ch] [ebp-Ch]

  s1 = 0;
  v3 = stderr;
  v4 = gettext("Valid arguments are:");
  fputs_unlocked(v4, v3);
  for ( i = 0; *(_DWORD *)(4 * i + a1); ++i )
  {
    if ( i && (v6 = (const void *)(a2 + i * n), !memcmp(s1, v6, n)) )
    {
      v7 = sub_8060751(*(_DWORD *)(4 * i + a1));
      fprintf(stderr, ", %s", v7);
    }
    else
    {
      v7 = sub_8060751(*(_DWORD *)(4 * i + a1));
      fprintf(stderr, "\n  - %s", v7);
      s1 = (void *)(i * n + a2);
    }
  }
  return putc_unlocked(10, stderr);
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (08055A2C) --------------------------------------------------------
int __cdecl sub_8055A2C(int a1, char *s, int a3, int a4, size_t n, int a6)
{
  int v7; // [esp+0h] [ebp-Ch]

  v7 = sub_805572A(s, a3, a4, n);
  if ( v7 >= 0 )
    return v7;
  sub_805585A(a1, (int)s, v7);
  sub_8055901(a3, a4, n);
  ((void (*)(void))a6)();
  return -1;
}

//----- (08055B6A) --------------------------------------------------------
int __cdecl sub_8055B6A(signed int a1)
{
  void *v1; // eax
  int v2; // eax
  int v3; // edx
  int v4; // ecx
  int savedregs; // [esp+0h] [ebp+0h]

  v1 = &loc_8055B8E;
  if ( a1 > 90 )
    v1 = &loc_8055BBF;
  dword_807122C = (int)v1;
  v2 = sub_80650A5();
  if ( v2 >= 65 || (unsigned int)(v2 - 48) <= 9 )
  {
    dword_8071254 = (int)&loc_8055BE8;
    sub_8064FC3(v4, v3, savedregs);
  }
  return 0;
}
// 807122C: using guessed type int dword_807122C;
// 8071254: using guessed type int dword_8071254;

//----- (08055BEA) --------------------------------------------------------
#error "8055C09: call analysis failed (funcsize=23)"

//----- (08055CC2) --------------------------------------------------------
_BOOL4 __cdecl sub_8055CC2(int a1)
{
  return (unsigned int)(a1 - 48) <= 9;
}

//----- (08055DF9) --------------------------------------------------------
int __cdecl sub_8055DF9(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 65) > 0x19 )
    result = a1;
  else
    result = a1 + 32;
  return result;
}

//----- (08055E2F) --------------------------------------------------------
int __cdecl sub_8055E2F()
{
  int v0; // eax
  int v2; // eax
  unsigned int v3; // [esp+0h] [ebp-38h]
  int (__cdecl *v4)(int, int); // [esp+4h] [ebp-34h]
  int *v5; // [esp+8h] [ebp-30h]
  int (__cdecl *v6)(int, int); // [esp+Ch] [ebp-2Ch]
  int *v7; // [esp+10h] [ebp-28h]

  if ( !*v5 )
  {
    *(&v3 - 3) = 7;
    v7 = (int *)sub_8059485;
    v6 = sub_80593E5;
    v5 = (int *)sub_8059223;
    v4 = 0;
    v3 = *(&v3 - 3);
    v0 = sub_80582A2(
           v3,
           0,
           (unsigned int (__cdecl *)(int, unsigned int))sub_8059223,
           (bool (__cdecl *)(int, int))sub_80593E5,
           (int)sub_8059485);
    *v5 = v0;
    if ( !*v5 )
      sub_80618DE();
  }
  if ( sub_8056D33(*v5, (int)v6, v7) )
    return 1;
  v2 = *v5;
  v5 = v7;
  v4 = v6;
  v3 = v2;
  sub_8056C70();
  return 0;
}

//----- (08055EFB) --------------------------------------------------------
#error "8055F44: call analysis failed (funcsize=18)"

//----- (08055F49) --------------------------------------------------------
#error "80568DE: positive sp value has been found (funcsize=580)"

//----- (08056903) --------------------------------------------------------
int sub_8056903()
{
  char *v0; // ebx
  int v1; // eax
  int v2; // eax
  int result; // eax
  char *v4; // [esp+Ch] [ebp-2Ch]
  char *v5; // [esp+10h] [ebp-28h]
  char *v6; // [esp+2Ch] [ebp-Ch]

  if ( sub_8063A8D(stdout) && (byte_80728C9 != 1 || *__errno_location() != 32) )
  {
    v6 = gettext("write error");
    if ( dword_80728C5 )
    {
      v0 = (char *)sub_8060442(dword_80728C5);
      v1 = *__errno_location();
      v5 = v6;
      v4 = v0;
      error(0, v1, "%s: %s", v0, v6);
      dword_807127C = (int)&loc_80569CB;
      sub_8064EEB();
    }
    v2 = *__errno_location();
    v4 = v6;
    error(0, v2, "%s", v6);
    _exit(status);
  }
  result = sub_8063A8D(stderr);
  if ( result )
    _exit(status);
  return result;
}
// 8064EEB: using guessed type int sub_8064EEB(void);
// 807127C: using guessed type int dword_807127C;
// 80728C5: using guessed type int dword_80728C5;
// 80728C9: using guessed type char byte_80728C9;

//----- (080569FC) --------------------------------------------------------
#error "8056A23: call analysis failed (funcsize=60)"

//----- (08056ABC) --------------------------------------------------------
#error "8056B0B: call analysis failed (funcsize=31)"

//----- (08056B5B) --------------------------------------------------------
#error "8056B8F: call analysis failed (funcsize=58)"

//----- (08056C06) --------------------------------------------------------
int __cdecl sub_8056C06(char *s)
{
  int *v1; // ebp
  char v2; // al
  int v4; // [esp+0h] [ebp-28h]
  size_t v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int savedregs; // [esp+28h] [ebp+0h]

  v1 = &savedregs;
  v6 = 0;
  v5 = strlen(s);
  while ( (unsigned int)*(v1 - 4) > 1 )
  {
    v2 = *(_BYTE *)(*(v1 - 4) - 1 + v1[2]);
    v1 = &v4;
    if ( v2 != 47 )
      break;
    --*(&v4 - 4);
  }
  return *(v1 - 4);
}

//----- (08056C66) --------------------------------------------------------
int sub_8056C66()
{
  return 0;
}

//----- (08056C70) --------------------------------------------------------
void __cdecl sub_8056C70()
{
  int v0; // edx
  int v1; // ecx
  int v2; // edx
  int v3; // ecx
  bool v4; // zf
  void *v5; // eax
  int v6; // [esp-4h] [ebp-2Ch]
  int v7; // [esp+0h] [ebp-28h]
  int v8; // [esp+4h] [ebp-24h]
  int v9; // [esp+8h] [ebp-20h]
  char *v10; // [esp+Ch] [ebp-1Ch]
  _DWORD *v11; // [esp+10h] [ebp-18h]

  if ( v9 )
  {
    *(&v7 - 4) = (int)sub_80616F7(0x14u);
    *(_DWORD *)*(&v7 - 4) = sub_80618B5(v10);
    v0 = v11[23];
    v1 = *(&v7 - 4);
    *(_DWORD *)(v1 + 4) = v11[22];
    *(_DWORD *)(v1 + 8) = v0;
    v2 = v11[1];
    v3 = *(&v7 - 4);
    *(_DWORD *)(v3 + 12) = *v11;
    *(_DWORD *)(v3 + 16) = v2;
    v8 = *(&v7 - 4);
    *(&v7 - 3) = sub_8058F7E(v9, v8);
    if ( !*(&v7 - 3) )
      sub_80618DE();
    v4 = *(&v7 - 3) == *(&v7 - 4);
    v6 = *(&v7 - 3);
    v5 = &loc_8056D26;
    if ( v4 )
      v5 = &locret_8056D31;
    dword_807122C = (int)v5;
    sub_80650A5();
    sub_8059485((void **)*(&v7 - 4));
  }
}
// 807122C: using guessed type int dword_807122C;

//----- (08056D33) --------------------------------------------------------
bool __cdecl sub_8056D33(int a1, int a2, int *a3)
{
  int v4; // edx
  int v5; // edx
  int v6; // [esp+0h] [ebp-38h]
  int v7; // [esp+1Ch] [ebp-1Ch]
  int v8; // [esp+20h] [ebp-18h]
  int v9; // [esp+24h] [ebp-14h]
  int v10; // [esp+28h] [ebp-10h]
  int v11; // [esp+2Ch] [ebp-Ch]

  if ( !a1 )
    return 0;
  v7 = a2;
  v4 = a3[23];
  v8 = a3[22];
  v9 = v4;
  v5 = a3[1];
  v10 = *a3;
  v11 = v5;
  return sub_8057CCC(a1, &v6 - 7) != 0;
}
// 8057CCC: using guessed type _DWORD __cdecl sub_8057CCC(_DWORD, _DWORD);

//----- (08056D96) --------------------------------------------------------
#error "8056E8B: call analysis failed (funcsize=65)"

//----- (08056E9B) --------------------------------------------------------
#error "8056F37: call analysis failed (funcsize=161)"

//----- (08057096) --------------------------------------------------------
int __cdecl sub_8057096(int a1, int a2)
{
  return sub_8056E9B(*(_DWORD *)(a1 + 16), a2);
}
// 8056E9B: using guessed type _DWORD __cdecl sub_8056E9B(_DWORD, _DWORD);

//----- (080570B7) --------------------------------------------------------
int __cdecl sub_80570B7(int a1)
{
  int v2; // [esp+1Ch] [ebp-Ch]

  v2 = sub_8057109(a1);
  if ( !v2 )
    sub_80618DE();
  return v2;
}
// 8057109: using guessed type _DWORD __cdecl sub_8057109(_DWORD);

//----- (080570E9) --------------------------------------------------------
_BYTE *__cdecl sub_80570E9(_BYTE *a1)
{
  while ( *a1 == 47 )
    ++a1;
  return a1;
}

//----- (08057109) --------------------------------------------------------
#error "805713C: call analysis failed (funcsize=22)"

//----- (0805714F) --------------------------------------------------------
#error "805728A: positive sp value has been found (funcsize=100)"

//----- (0805728B) --------------------------------------------------------
int __usercall sub_805728B@<eax>(int a1@<edx>, int a2@<ecx>, int *a3)
{
  void *v3; // eax
  int v5; // [esp+0h] [ebp-28h]

  while ( *(_BYTE *)*a3 )
  {
    dword_80711DC = (int)&loc_8057313;
    sub_806526B(a2, a1, v5);
    if ( (unsigned __int8)sub_8055BEA(*(char *)*a3) ^ 1 )
    {
      v3 = &loc_8057307;
      if ( *(_BYTE *)*a3 == 126 )
        v3 = &loc_8057397;
      dword_807122C = (int)v3;
      sub_80650A5();
    }
    a1 = *a3 + 1;
    *a3 = a1;
  }
  return 0;
}
// 805728B: could not find valid save-restore pair for ebx
// 8055BEA: using guessed type _DWORD __cdecl sub_8055BEA(_DWORD);
// 80711DC: using guessed type int dword_80711DC;
// 807122C: using guessed type int dword_807122C;

//----- (080573B9) --------------------------------------------------------
#error "8057402: call analysis failed (funcsize=34)"

//----- (08057423) --------------------------------------------------------
#error "805748C: call analysis failed (funcsize=165)"

//----- (08057665) --------------------------------------------------------
#error "8057805: call analysis failed (funcsize=204)"

//----- (080578FC) --------------------------------------------------------
#error "805792D: call analysis failed (funcsize=20)"

//----- (08057964) --------------------------------------------------------
#error "80579B5: call analysis failed (funcsize=44)"

//----- (080579ED) --------------------------------------------------------
int __cdecl sub_80579ED(int a1)
{
  return *(_DWORD *)(a1 + 8);
}

//----- (080579F8) --------------------------------------------------------
int __cdecl sub_80579F8(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (08057A07) --------------------------------------------------------
int __cdecl sub_8057A07(int a1)
{
  return *(_DWORD *)(a1 + 16);
}

//----- (08057A32) --------------------------------------------------------
#error "8057AC6: call analysis failed (funcsize=63)"

//----- (08057C7C) --------------------------------------------------------
int __cdecl sub_8057C7C(_DWORD *a1, int a2)
{
  int (__cdecl *v2)(int, int); // eax
  int v4; // [esp+4h] [ebp-24h]
  unsigned int v5; // [esp+1Ch] [ebp-Ch]

  v2 = (int (__cdecl *)(int, int))a1[6];
  v4 = a1[2];
  v5 = v2(a2, v4);
  if ( a1[2] <= v5 )
    abort();
  return 8 * v5 + *a1;
}

//----- (08057CCC) --------------------------------------------------------
#error "8057CF5: call analysis failed (funcsize=22)"

//----- (08057D08) --------------------------------------------------------
#error "8057D88: positive sp value has been found (funcsize=0)"

//----- (08058012) --------------------------------------------------------
bool __cdecl sub_8058012(unsigned int a1)
{
  int v1; // ST08_4
  unsigned int v3; // [esp+8h] [ebp-8h]
  unsigned int v4; // [esp+Ch] [ebp-4h]

  v3 = 3;
  v4 = 9;
  while ( v4 < a1 && a1 % v3 )
  {
    v1 = v3 + 1;
    v4 += 4 * v1;
    v3 = v1 + 1;
  }
  return a1 % v3 != 0;
}

//----- (0805806D) --------------------------------------------------------
int __cdecl sub_805806D(unsigned int a1)
{
  int i; // [esp+Ch] [ebp+8h]

  if ( a1 <= 9 )
    a1 = 10;
  for ( i = a1 | 1; i != -1 && !sub_8058012(i); i += 2 )
    ;
  return i;
}

//----- (080580EE) --------------------------------------------------------
unsigned int __cdecl sub_80580EE(int a1, unsigned int a2)
{
  return sub_80638A9(a1, 3) % a2;
}

//----- (0805811D) --------------------------------------------------------
bool __cdecl sub_805811D(int a1, int a2)
{
  return a1 == a2;
}

//----- (0805812B) --------------------------------------------------------
signed int __cdecl sub_805812B(int a1)
{
  int v2; // [esp+8h] [ebp-8h]

  v2 = *(_DWORD *)(a1 + 20);
  if ( (_UNKNOWN *)v2 == &unk_8069B08 )
    return 1;
  if ( *(float *)(v2 + 8) > 0.1
    && 1.0 - 0.1 > *(float *)(v2 + 8)
    && *(float *)(v2 + 12) > 0.1 + 1.0
    && *(float *)v2 >= 0.0
    && *(float *)(v2 + 4) > *(float *)v2 + 0.1
    && *(float *)(v2 + 4) <= 1.0
    && *(float *)(v2 + 8) > *(float *)v2 + 0.1 )
  {
    return 1;
  }
  *(_DWORD *)(a1 + 20) = &unk_8069B08;
  return 0;
}

//----- (080581F1) --------------------------------------------------------
unsigned int __cdecl sub_80581F1(unsigned int a1, int a2)
{
  unsigned int result; // eax
  float v3; // [esp+20h] [ebp-4h]
  unsigned int v4; // [esp+2Ch] [ebp+8h]

  if ( *(_BYTE *)(a2 + 16) != 1 )
  {
    v3 = (long double)a1 / *(float *)(a2 + 8);
    if ( v3 >= 4294967300.0 )
      return 0;
    a1 = (signed __int64)v3;
  }
  v4 = sub_805806D(a1);
  if ( v4 <= 0x1FFFFFFF )
    result = v4;
  else
    result = 0;
  return result;
}

//----- (080582A2) --------------------------------------------------------
int __cdecl sub_80582A2(unsigned int a1, void *a2, unsigned int (__cdecl *a3)(int a1, unsigned int a2), bool (__cdecl *a4)(int a1, int a2), int a5)
{
  int v6; // ecx
  int v7; // [esp+0h] [ebp-28h]
  int v8; // [esp+0h] [ebp-28h]
  int v9; // [esp+4h] [ebp-24h]
  int v10; // [esp+8h] [ebp-20h]
  int v11; // [esp+Ch] [ebp-1Ch]
  int v12; // [esp+10h] [ebp-18h]
  int v13; // [esp+14h] [ebp-14h]
  int v14; // [esp+18h] [ebp-10h]
  _DWORD *ptr; // [esp+1Ch] [ebp-Ch]
  int v16; // [esp+20h] [ebp-8h]
  int v17; // [esp+24h] [ebp-4h]
  int savedregs; // [esp+28h] [ebp+0h]

  if ( !a3 )
    a3 = sub_80580EE;
  if ( !a4 )
    a4 = sub_805811D;
  ptr = malloc(0x28u);
  if ( !ptr )
    return 0;
  if ( !a2 )
    a2 = &unk_8069B08;
  ptr[5] = a2;
  if ( (unsigned __int8)sub_805812B((int)ptr) ^ 1 )
  {
    dword_80711F0 = (int)&loc_80583EC;
    sub_80651FD(v7, v9, v10, v11, v12, v13, v14, ptr, v16, v17, savedregs);
  }
  ptr[2] = sub_80581F1(a1, (int)a2);
  if ( ptr[2] )
  {
    *ptr = calloc(ptr[2], 8u);
    if ( *ptr )
    {
      ptr[1] = 8 * ptr[2] + *ptr;
      ptr[3] = 0;
      ptr[4] = 0;
      ptr[6] = a3;
      ptr[7] = a4;
      ptr[8] = a5;
      ptr[9] = 0;
      dword_80711DC = (int)&locret_80583FC;
      sub_806526B(v6, a5, v8);
    }
  }
  free(ptr);
  return 0;
}
// 80651FD: using guessed type int __stdcall sub_80651FD(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;
// 80711F0: using guessed type int dword_80711F0;

//----- (08058507) --------------------------------------------------------
void __cdecl sub_8058507(void *a1)
{
  void **i; // [esp+14h] [ebp-14h]
  void *ptr; // [esp+18h] [ebp-10h]
  void *v3; // [esp+1Ch] [ebp-Ch]

  if ( *((_DWORD *)a1 + 8) && *((_DWORD *)a1 + 4) )
  {
    for ( i = *(void ***)a1; *((_DWORD *)a1 + 1) > (unsigned int)i; i += 2 )
    {
      if ( *i )
      {
        for ( ptr = i; ptr; ptr = (void *)*((_DWORD *)ptr + 1) )
          (*((void (__cdecl **)(_DWORD))a1 + 8))(*(_DWORD *)ptr);
      }
    }
  }
  for ( i = *(void ***)a1; *((_DWORD *)a1 + 1) > (unsigned int)i; i += 2 )
  {
    ptr = i[1];
    dword_807122C = (int)&loc_80585B2;
    sub_80650A5();
    do
    {
      v3 = (void *)*((_DWORD *)ptr + 1);
      free(ptr);
      ptr = v3;
    }
    while ( v3 );
  }
  for ( ptr = (void *)*((_DWORD *)a1 + 9); ptr; ptr = v3 )
  {
    v3 = (void *)*((_DWORD *)ptr + 1);
    free(ptr);
  }
  free(*(void **)a1);
  free(a1);
}
// 807122C: using guessed type int dword_807122C;

//----- (0805860C) --------------------------------------------------------
void *__cdecl sub_805860C(int a1)
{
  int v2; // [esp+1Ch] [ebp-Ch]

  if ( !*(_DWORD *)(a1 + 36) )
    return malloc(8u);
  v2 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(v2 + 4);
  return (void *)v2;
}

//----- (08058657) --------------------------------------------------------
int __cdecl sub_8058657(int a1, _DWORD *a2)
{
  int result; // eax

  *a2 = 0;
  a2[1] = *(_DWORD *)(a1 + 36);
  result = a1;
  *(_DWORD *)(a1 + 36) = a2;
  return result;
}

//----- (0805868A) --------------------------------------------------------
#error "80586C2: call analysis failed (funcsize=23)"

//----- (080586C7) --------------------------------------------------------
#error "805888A: positive sp value has been found (funcsize=146)"

//----- (0805888B) --------------------------------------------------------
#error "80588C8: call analysis failed (funcsize=101)"

//----- (08058A80) --------------------------------------------------------
#error "8058C17: call analysis failed (funcsize=130)"

//----- (08058C91) --------------------------------------------------------
#error "8058ED0: call analysis failed (funcsize=211)"

//----- (08058F7E) --------------------------------------------------------
int __cdecl sub_8058F7E(int a1, int a2)
{
  int v3; // [esp+18h] [ebp-10h]
  int v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_8058C91(a1, a2, &v3);
  if ( v4 == -1 )
    return 0;
  if ( v4 )
    return a2;
  return v3;
}
// 8058C91: using guessed type _DWORD __cdecl sub_8058C91(_DWORD, _DWORD, _DWORD);

//----- (08058FBD) --------------------------------------------------------
#error "80590F1: call analysis failed (funcsize=98)"

//----- (08059223) --------------------------------------------------------
int __cdecl sub_8059223(int *a1, unsigned int a2)
{
  unsigned __int64 v2; // ST00_8

  LODWORD(v2) = a1[1] ^ sub_8063B53(*a1);
  HIDWORD(v2) = a1[2];
  return sub_8064A2C(v2, a2);
}

//----- (080593E5) --------------------------------------------------------
int __cdecl sub_80593E5(int a1, int a2)
{
  return *(_QWORD *)(a2 + 4) == *(_QWORD *)(a1 + 4)
      && *(_QWORD *)(a1 + 12) == *(_QWORD *)(a2 + 12)
      && !strcmp(*(const char **)a1, *(const char **)a2);
}

//----- (08059485) --------------------------------------------------------
void __cdecl sub_8059485(void **a1)
{
  free(*a1);
  free(a1);
}

//----- (080594AF) --------------------------------------------------------
#error "80595C8: call analysis failed (funcsize=111)"

//----- (08059624) --------------------------------------------------------
char *__cdecl sub_8059624(int a1, size_t n, int a3, int a4)
{
  char *i; // ebx
  size_t v5; // eax
  char *v6; // ebx
  unsigned __int8 *v8; // [esp+4h] [ebp-50h]
  unsigned __int8 v9; // [esp+Fh] [ebp-45h]
  size_t v10; // [esp+10h] [ebp-44h]
  size_t v11; // [esp+14h] [ebp-40h]
  size_t v12; // [esp+18h] [ebp-3Ch]
  char dest[41]; // [esp+1Fh] [ebp-35h]
  unsigned int v14; // [esp+48h] [ebp-Ch]

  v8 = (unsigned __int8 *)a3;
  v14 = __readgsdword(0x14u);
  v10 = -1;
  v12 = strlen((const char *)a4);
  v11 = n;
  memcpy(dest, (const void *)a1, n);
  for ( i = (char *)(a1 + n); ; memcpy(i, (const void *)a4, v12) )
  {
    v9 = *v8;
    if ( *v8 )
    {
      if ( v9 > 0x7Eu )
        v5 = v11;
      else
        v5 = v9;
      v10 = v5;
      ++v8;
    }
    if ( v11 < v10 )
      v10 = v11;
    v6 = &i[-v10];
    v11 -= v10;
    memcpy(v6, &dest[v11], v10);
    if ( !v11 )
      break;
    i = &v6[-v12];
  }
  return v6;
}
// 8059624: using guessed type char dest[41];

//----- (08059747) --------------------------------------------------------
#error "8059E77: call analysis failed (funcsize=836)"

//----- (0805A4E8) --------------------------------------------------------
#error "805A512: call analysis failed (funcsize=20)"

//----- (0805A53D) --------------------------------------------------------
int __cdecl sub_805A53D(char *s, int a2, int a3)
{
  int v3; // edx
  int v5; // [esp+20h] [ebp-18h]
  int v6; // [esp+24h] [ebp-14h]
  int v7; // [esp+28h] [ebp-10h]
  int v8; // [esp+2Ch] [ebp-Ch]

  v6 = 0;
  if ( s || (s = getenv("BLOCK_SIZE")) != 0 || (s = getenv("BLOCKSIZE")) != 0 )
  {
    if ( *s == 39 )
    {
      v6 |= 4u;
      ++s;
    }
    v7 = sub_805572A(s, (int)off_8069BDC, (int)dword_8069BE8, 4u);
    if ( v7 < 0 )
    {
      v8 = sub_80624A6();
      if ( v8 )
      {
        *(_DWORD *)a3 = 0;
        return v8;
      }
      while ( 1 )
      {
        if ( *s > 47 && *s <= 57 )
        {
          dword_807122C = (int)&loc_805A6A9;
          sub_80650A5();
          goto LABEL_23;
        }
        if ( s == (char *)v5 )
          break;
        ++s;
      }
      v6 |= 0x80u;
      if ( *(_BYTE *)(v5 - 1) == 66 )
        v6 |= 0x100u;
      if ( *(_BYTE *)(v5 - 1) != 66 || *(_BYTE *)(v5 - 2) == 105 )
        v6 |= 0x20u;
    }
    else
    {
      v6 |= dword_8069BE8[v7];
      *(_DWORD *)a2 = 1;
      *(_DWORD *)(a2 + 4) = 0;
    }
  }
  else
  {
    *(_DWORD *)a2 = sub_805A4E8();
    *(_DWORD *)(a2 + 4) = v3;
  }
LABEL_23:
  *(_DWORD *)a3 = v6;
  return 0;
}
// 805A4E8: using guessed type int sub_805A4E8(void);
// 8069BDC: using guessed type char *off_8069BDC[2];
// 807122C: using guessed type int dword_807122C;

//----- (0805A6B8) --------------------------------------------------------
int __cdecl sub_805A6B8(char *s, int a2, int a3)
{
  int v3; // edx
  int v5; // [esp+1Ch] [ebp-Ch]

  v5 = sub_805A53D(s, a3, a2);
  if ( !*(_QWORD *)a3 )
  {
    *(_DWORD *)a3 = sub_805A4E8();
    *(_DWORD *)(a3 + 4) = v3;
    v5 = 4;
  }
  return v5;
}
// 805A4E8: using guessed type int sub_805A4E8(void);

//----- (0805A701) --------------------------------------------------------
#error "805A758: call analysis failed (funcsize=81)"

//----- (0805A964) --------------------------------------------------------
char *__cdecl sub_805A964(__gid_t gid)
{
  const char *v1; // eax
  char *s; // ST1C_4
  size_t v3; // eax
  char *result; // eax
  char *i; // [esp+10h] [ebp-18h]
  char *v6; // [esp+14h] [ebp-14h]
  struct group *v7; // [esp+18h] [ebp-10h]

  v6 = 0;
  for ( i = (char *)dword_80728D5; i; i = (char *)*((_DWORD *)i + 1) )
  {
    if ( *(_DWORD *)i == gid )
    {
      v6 = i;
      break;
    }
  }
  if ( !v6 )
  {
    v7 = getgrgid(gid);
    if ( v7 )
      v1 = v7->gr_name;
    else
      v1 = (const char *)&unk_8069C6C;
    s = (char *)v1;
    v3 = strlen(v1);
    v6 = (char *)sub_80616F7((v3 + 16) & 0xFFFFFFF8);
    *(_DWORD *)v6 = gid;
    strcpy(v6 + 8, s);
    *((_DWORD *)v6 + 1) = dword_80728D5;
    dword_80728D5 = (int)v6;
  }
  if ( v6[8] )
    result = v6 + 8;
  else
    result = 0;
  return result;
}
// 80728D5: using guessed type int dword_80728D5;

//----- (0805AB62) --------------------------------------------------------
#error "805AC80: call analysis failed (funcsize=80)"

//----- (0805ACBC) --------------------------------------------------------
#error "805ACCD: call analysis failed (funcsize=12)"

//----- (0805ACE0) --------------------------------------------------------
int __cdecl sub_805ACE0(int a1, int a2, int a3, int a4)
{
  __int64 *v4; // ebp
  int v5; // eax
  int v6; // edx
  int v7; // edx
  __int64 v9; // [esp+0h] [ebp-38h]
  int v10; // [esp+18h] [ebp-20h]
  int v11; // [esp+1Ch] [ebp-1Ch]
  int v12; // [esp+2Ch] [ebp-Ch]
  void *retaddr; // [esp+38h] [ebp+0h]

  v4 = (__int64 *)&retaddr;
  v10 = a2;
  v11 = a3;
  v12 = a4 + 20;
  *(_BYTE *)(a4 + 20) = 0;
  do
  {
    *(_BYTE *)--*((_DWORD *)v4 - 3) = sub_8064A2C(*(v4 - 4), 10LL) + 48;
    v5 = *((_DWORD *)v4 - 8);
    v6 = *((_DWORD *)v4 - 7);
    v4 = &v9;
    *((_DWORD *)&v9 - 8) = sub_806489E(v5, v6, 10, 0);
    *((_DWORD *)&v9 - 7) = v7;
  }
  while ( *(&v9 - 4) );
  return *((_DWORD *)&v9 - 3);
}
// 805ACE0: could not find valid save-restore pair for ebp
// 806489E: using guessed type _DWORD __cdecl sub_806489E(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0805AD8F) --------------------------------------------------------
int __cdecl sub_805AD8F(wint_t *a1)
{
  unsigned __int8 v2; // [esp+1Bh] [ebp-Dh]
  wint_t *i; // [esp+1Ch] [ebp-Ch]

  v2 = 0;
  for ( i = a1; *i; ++i )
  {
    if ( !iswprint(*i) )
    {
      *i = 65533;
      v2 = 1;
    }
  }
  return v2;
}

//----- (0805ADD6) --------------------------------------------------------
int __cdecl sub_805ADD6(_DWORD *a1, unsigned int a2)
{
  int v3; // [esp+18h] [ebp-10h]
  int v4; // [esp+1Ch] [ebp-Ch]

  v3 = 0;
  while ( *a1 )
  {
    v4 = wcwidth(*a1);
    if ( v4 == -1 )
    {
      *a1 = 65533;
      v4 = 1;
    }
    if ( v4 + v3 > a2 )
      break;
    v3 += v4;
    ++a1;
  }
  *a1 = 0;
  return v3;
}
// 8049560: using guessed type int __cdecl wcwidth(_DWORD);

//----- (0805AE54) --------------------------------------------------------
_BYTE *__cdecl sub_805AE54(_BYTE *a1, unsigned int a2, int a3)
{
  _BYTE *v3; // eax
  int v4; // eax

  while ( 1 )
  {
    v4 = a3--;
    if ( !v4 || (unsigned int)a1 >= a2 )
      break;
    v3 = a1++;
    *v3 = 32;
  }
  *a1 = 0;
  return a1;
}

//----- (0805AEA7) --------------------------------------------------------
int __cdecl sub_805AEA7(char *s, int a2, int a3, int a4, int a5, int a6)
{
  size_t v6; // eax
  int v7; // ecx
  bool v8; // zf
  void *v9; // eax
  unsigned int v10; // edx
  void *v11; // eax
  _BYTE *v12; // eax
  size_t v13; // eax
  int v15; // [esp+0h] [ebp-58h]
  int v16; // [esp+4h] [ebp-54h]
  int v17; // [esp+8h] [ebp-50h]
  int v18; // [esp+Ch] [ebp-4Ch]
  int v19; // [esp+10h] [ebp-48h]
  int v20; // [esp+14h] [ebp-44h]
  int v21; // [esp+18h] [ebp-40h]
  int v22; // [esp+1Ch] [ebp-3Ch]
  int size; // [esp+20h] [ebp-38h]
  char *v24; // [esp+24h] [ebp-34h]
  wchar_t *pwcs; // [esp+28h] [ebp-30h]
  char *v26; // [esp+2Ch] [ebp-2Ch]
  unsigned int v27; // [esp+30h] [ebp-28h]
  size_t v28; // [esp+34h] [ebp-24h]
  int v29; // [esp+38h] [ebp-20h]
  int v30; // [esp+3Ch] [ebp-1Ch]
  int v31; // [esp+40h] [ebp-18h]
  int v32; // [esp+40h] [ebp-18h]
  size_t n; // [esp+44h] [ebp-14h]
  int na; // [esp+44h] [ebp-14h]
  int v35; // [esp+48h] [ebp-10h]
  unsigned int v36; // [esp+48h] [ebp-10h]
  int v37; // [esp+4Ch] [ebp-Ch]
  unsigned int v38; // [esp+4Ch] [ebp-Ch]
  int v39; // [esp+50h] [ebp-8h]
  int v40; // [esp+54h] [ebp-4h]
  int savedregs; // [esp+58h] [ebp+0h]
  int v42; // [esp+64h] [ebp+Ch]
  _BYTE *v43; // [esp+64h] [ebp+Ch]

  v22 = -1;
  v6 = strlen(s);
  size = v6 + 1;
  v24 = 0;
  pwcs = 0;
  v26 = s;
  v27 = v6;
  v28 = v6;
  v29 = 0;
  HIWORD(v21) = 0;
  if ( a6 & 2 || __ctype_get_mb_cur_max() <= 1 )
    goto LABEL_12;
  n = mbstowcs(0, s, 0);
  if ( n == -1 )
  {
    if ( a6 & 1 )
      goto LABEL_21;
    dword_8071204 = (int)&loc_805B232;
    sub_8065187(
      v15,
      v16,
      v17,
      v18,
      v19,
      v20,
      v21,
      -1,
      size,
      0,
      0,
      s,
      v27,
      v28,
      0,
      v30,
      v31,
      -1,
      v35,
      v37,
      v39,
      v40,
      savedregs);
  }
  na = n + 1;
  pwcs = (wchar_t *)malloc(4 * na);
  if ( pwcs )
  {
    v8 = mbstowcs(pwcs, s, na) == 0;
    v9 = &loc_805AFD2;
    if ( v8 )
      v9 = &loc_805B013;
    dword_807122C = (int)v9;
    sub_80650A5();
    pwcs[na + 0x3FFFFFFF] = 0;
    HIBYTE(v21) = 1;
    BYTE2(v21) = sub_805AD8F((wint_t *)pwcs);
    v27 = wcswidth(pwcs, na);
LABEL_12:
    if ( HIBYTE(v21) && (BYTE2(v21) || *(_DWORD *)a4 < v27) )
    {
      if ( BYTE2(v21) )
        size = wcstombs(0, pwcs, 0) + 1;
      v24 = (char *)malloc(size);
      if ( v24 )
      {
        v26 = v24;
        v27 = sub_805ADD6(pwcs, *(_DWORD *)a4);
        v28 = wcstombs(v24, pwcs, size);
      }
      else if ( !(a6 & 1) )
      {
        goto LABEL_39;
      }
    }
    goto LABEL_21;
  }
  if ( !(a6 & 1) )
    goto LABEL_39;
LABEL_21:
  if ( *(_DWORD *)a4 < v27 )
  {
    v27 = *(_DWORD *)a4;
    v28 = *(_DWORD *)a4;
  }
  if ( *(_DWORD *)a4 > v27 )
    v29 = *(_DWORD *)a4 - v27;
  v10 = v27;
  *(_DWORD *)a4 = v27;
  if ( a5 )
  {
    if ( a5 == 1 )
    {
      v32 = 0;
      goto LABEL_30;
    }
    dword_8071254 = (int)&loc_805B130;
    sub_8064FC3(v7, v27, v15);
  }
  v32 = v29;
LABEL_30:
  v11 = &loc_805B16D;
  if ( !(a6 & 4) )
    v11 = &loc_805B174;
  dword_80711DC = (int)v11;
  sub_806526B(v7, v10, v15);
  if ( a6 & 8 )
    v32 = 0;
  if ( a3 )
  {
    v36 = a3 - 1 + a2;
    v12 = sub_805AE54((_BYTE *)a2, v36, 0);
    v42 = (int)v12;
    v38 = v36 - (_DWORD)v12;
    v13 = v28;
    if ( v38 <= v28 )
      v13 = v38;
    v43 = (_BYTE *)mempcpy(v42, v26, v13);
    sub_805AE54(v43, v36, v32);
  }
  v22 = v32 + v28;
LABEL_39:
  free(pwcs);
  free(v24);
  return v22;
}
// 805AEA7: could not find valid save-restore pair for ebx
// 80499B0: using guessed type int __cdecl mempcpy(_DWORD, _DWORD, _DWORD);
// 80499C0: using guessed type int __cdecl wcswidth(_DWORD, _DWORD);
// 8065187: using guessed type int __stdcall sub_8065187(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;
// 8071204: using guessed type int dword_8071204;
// 807122C: using guessed type int dword_807122C;
// 8071254: using guessed type int dword_8071254;

//----- (0805B34F) --------------------------------------------------------
int __usercall sub_805B34F@<eax>(int a1@<ebx>, char *s, int a3)
{
  int v3; // eax

  v3 = strlen(s);
  return sub_805B378(a1, s, v3, a3);
}

//----- (0805B378) --------------------------------------------------------
int __usercall sub_805B378@<eax>(int a1@<ebx>, char *a2, int a3, char a4)
{
  signed int v4; // eax
  bool v5; // sf
  unsigned __int8 v6; // of
  void *v7; // eax
  int v8; // eax
  int v9; // edx
  int v10; // ecx
  void *v12; // eax
  int v13; // edx
  int v14; // ecx
  char *v15; // eax
  int v16; // eax
  bool v17; // zf
  void *v18; // eax
  int v19; // [esp-8h] [ebp-60h]
  int v20; // [esp-4h] [ebp-5Ch]
  int v21; // [esp+0h] [ebp-58h]
  int v22; // [esp+4h] [ebp-54h]
  int v23; // [esp+8h] [ebp-50h]
  int v24; // [esp+Ch] [ebp-4Ch]
  char *v25; // [esp+1Ch] [ebp-3Ch]
  unsigned __int8 v26; // [esp+2Bh] [ebp-2Dh]
  wint_t wc; // [esp+2Ch] [ebp-2Ch]
  char *v28; // [esp+30h] [ebp-28h]
  int v29; // [esp+34h] [ebp-24h]
  size_t v30; // [esp+38h] [ebp-20h]
  char *v31; // [esp+3Ch] [ebp-1Ch]
  int v32; // [esp+40h] [ebp-18h]
  char s; // [esp+44h] [ebp-14h]
  unsigned int v34; // [esp+4Ch] [ebp-Ch]

  v25 = a2;
  v34 = __readgsdword(0x14u);
  v28 = a2;
  v31 = &a2[a3];
  v29 = 0;
  if ( __ctype_get_mb_cur_max() > 1 )
  {
    while ( 1 )
    {
LABEL_32:
      if ( v28 >= v31 )
        return v29;
      v4 = *v28;
      if ( v4 > 63 )
      {
        v6 = __OFSUB__(v4, 65);
        v5 = v4 - 65 < 0;
        v20 = *v28;
        v19 = a1;
        v7 = &loc_805B409;
        if ( v5 ^ v6 )
          v7 = &loc_805B423;
        dword_8071268 = (int)v7;
        a1 = v19;
        v8 = sub_8064F57(v21, v22, v23, v24);
        if ( v8 > 95 && (unsigned int)(v8 - 97) > 0x1D )
        {
LABEL_12:
          memset(&s, 0, 8u);
          while ( 1 )
          {
            v30 = sub_8062921(&v21 - 11, v28, v31 - v28, (mbstate_t *)(&v21 - 5));
            if ( v30 == -1 )
              break;
            if ( v30 == -2 )
            {
              v20 = a4 & 1;
              v19 = a1;
              v12 = &loc_805B4C8;
              if ( a4 & 1 )
                v12 = &loc_805B4D7;
              dword_80711DC = (int)v12;
              a1 = v19;
              sub_806526B(v10, v9, v21);
              v28 = v31;
              ++v29;
              goto LABEL_32;
            }
            if ( !v30 )
              v30 = 1;
            v32 = wcwidth(wc);
            if ( v32 >= 0 )
            {
              if ( 0x7FFFFFFF - v29 < v32 )
                return 0x7FFFFFFF;
              v29 += v32;
              dword_8071254 = (int)&loc_805B568;
              sub_8064FC3(v14, v13, v21);
            }
            if ( a4 & 2 )
              return -1;
            if ( !iswcntrl(wc) )
            {
              if ( v29 == 0x7FFFFFFF )
                return 0x7FFFFFFF;
              ++v29;
            }
            v28 += v30;
            if ( mbsinit((const mbstate_t *)&s) )
              goto LABEL_32;
          }
          if ( !(a4 & 1) )
          {
            ++v28;
            ++v29;
            continue;
          }
          return -1;
        }
      }
      else if ( v4 < 37 && (unsigned int)(v4 - 32) > 3 )
      {
        goto LABEL_12;
      }
      ++v28;
      ++v29;
    }
  }
  while ( 1 )
  {
    if ( v28 >= v31 )
      return v29;
    v15 = v28++;
    v26 = *v15;
    v16 = (*__ctype_b_loc())[v26] & 0x4000;
    v17 = v16 == 0;
    v20 = v16;
    v19 = a1;
    v18 = &loc_805B5E4;
    if ( v17 )
      v18 = &loc_805B5F5;
    dword_8071268 = (int)v18;
    a1 = v19;
    sub_8064F57(v21, v22, v23, v24);
    if ( v29 == 0x7FFFFFFF )
      break;
    ++v29;
  }
  return 0x7FFFFFFF;
}
// 805B378: could not find valid save-restore pair for ebx
// 8049560: using guessed type int __cdecl wcwidth(_DWORD);
// 8064F57: using guessed type int __stdcall sub_8064F57(_DWORD, _DWORD, _DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;
// 8071254: using guessed type int dword_8071254;
// 8071268: using guessed type int dword_8071268;

//----- (0805B671) --------------------------------------------------------
void *__cdecl sub_805B671()
{
  int *v0; // ebp
  int v1; // edx
  _DWORD *v2; // eax
  _DWORD *v3; // eax
  int v5; // [esp+0h] [ebp-38h]
  int v6; // [esp+4h] [ebp-34h]
  _DWORD *v7; // [esp+8h] [ebp-30h]
  unsigned int v8; // [esp+Ch] [ebp-2Ch]
  char *v9; // [esp+10h] [ebp-28h]
  int (__cdecl *v10)(int, int); // [esp+14h] [ebp-24h]

  v0 = &v5;
  *(&v5 - 5) = v8 >> 1;
  *(&v5 - 4) = v8 - *(&v5 - 5);
  *(&v5 - 10) = 0;
  *(v0 - 9) = *(v0 - 5);
  *(v0 - 8) = *(v0 - 5);
  *(&v5 - 3) = v8;
  v1 = (int)&v7[*(&v5 - 5)];
  v8 = (unsigned int)v10;
  v7 = v9;
  sub_805B829(v1, *(&v5 - 4), v9, (int)v10);
  v8 = (unsigned int)v10;
  v7 = v9;
  sub_805B829((int)v9, *(&v5 - 5), v9, (int)v10);
  *(&v5 - 7) = v7[*(&v5 - 10)];
  *(&v5 - 6) = v7[*(&v5 - 8)];
  while ( 1 )
  {
    while ( 1 )
    {
      v6 = *(&v5 - 6);
      v5 = *(&v5 - 7);
      if ( v10(v5, v6) <= 0 )
        break;
      v3 = v9;
      v9 += 4;
      *v3 = *(&v5 - 6);
      if ( ++*(&v5 - 8) == *(&v5 - 3) )
        return memcpy(v9, &v7[*(&v5 - 10)], 4 * (*(&v5 - 9) - *(&v5 - 10)));
      *(&v5 - 6) = v7[*(&v5 - 8)];
    }
    v2 = v9;
    v9 += 4;
    *v2 = *(&v5 - 7);
    if ( ++*(&v5 - 10) == *(&v5 - 9) )
      break;
    *(&v5 - 7) = v7[*(&v5 - 10)];
  }
  *(&v5 - 10) = *(&v5 - 8);
  *(&v5 - 9) = *(&v5 - 3);
  return memcpy(v9, &v7[*(&v5 - 10)], 4 * (*(&v5 - 9) - *(&v5 - 10)));
}

//----- (0805B829) --------------------------------------------------------
#error "805B9CB: call analysis failed (funcsize=178)"

//----- (0805BA9D) --------------------------------------------------------
int __cdecl sub_805BA9D(int a1, int a2, int a3)
{
  return sub_805B829(a1, a2, (void *)(a1 + 4 * a2), a3);
}

//----- (0805BAED) --------------------------------------------------------
int __cdecl sub_805BAED(int a1, int a2, int a3)
{
  int v3; // eax

  while ( 1 )
  {
    v3 = a3--;
    if ( !v3 )
      break;
    *(_BYTE *)(a1 + a3) = tolower(*(unsigned __int8 *)(a2 + a3));
  }
  return a1;
}

//----- (0805BB31) --------------------------------------------------------
int __cdecl sub_805BB31(int a1, int a2, int a3)
{
  int v3; // eax

  dword_807122C = (int)&loc_805BB84;
  sub_80650A5();
  do
  {
    *(_BYTE *)(a1 + a3) = toupper(*(unsigned __int8 *)(a2 + a3));
    v3 = a3--;
  }
  while ( v3 );
  return a1;
}
// 807122C: using guessed type int dword_807122C;

//----- (0805BB9A) --------------------------------------------------------
int __cdecl sub_805BB9A(int a1, int a2)
{
  return a1 - (a1 - a2 + 382) % 7 + 3;
}

//----- (0805BBF7) --------------------------------------------------------
int __cdecl sub_805BBF7(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // [esp+0h] [ebp-38h]
  char v8; // [esp+2Fh] [ebp-9h]

  v8 = 0;
  return sub_805BC58(a1, a2, a3, a4, 0, (char *)&v7 - 9, a5, a6);
}
// 805BC58: using guessed type _DWORD __cdecl sub_805BC58(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0805BC58) --------------------------------------------------------
#error "805E523: call analysis failed (funcsize=1663)"

//----- (0805E961) --------------------------------------------------------
#error "805EA06: call analysis failed (funcsize=78)"

//----- (0805EA75) --------------------------------------------------------
#error "805EA9C: call analysis failed (funcsize=28)"

//----- (0805EAD0) --------------------------------------------------------
#error "805EAED: call analysis failed (funcsize=25)"

//----- (0805EB19) --------------------------------------------------------
int *__cdecl sub_805EB19(int *a1, int a2)
{
  int *result; // eax

  if ( a1 )
    result = a1;
  else
    result = &dword_80728E9;
  *result = a2;
  return result;
}
// 80728E9: using guessed type int dword_80728E9;

//----- (0805EB43) --------------------------------------------------------
int __cdecl sub_805EB43(int *a1, unsigned __int8 a2, char a3)
{
  int *v3; // eax
  int v4; // ST10_4

  if ( a1 )
    v3 = a1;
  else
    v3 = &dword_80728E9;
  v4 = ((unsigned int)v3[(a2 >> 5) + 2] >> (a2 & 0x1F)) & 1;
  v3[(a2 >> 5) + 2] ^= (v4 ^ a3 & 1) << (a2 & 0x1F);
  return v4;
}
// 80728E9: using guessed type int dword_80728E9;

//----- (0805EC24) --------------------------------------------------------
int *__cdecl sub_805EC24(int *a1, int a2, int a3)
{
  int *result; // eax

  if ( !a1 )
    a1 = &dword_80728E9;
  *a1 = 10;
  if ( !a2 || !a3 )
    abort();
  a1[10] = a2;
  result = a1;
  a1[11] = a3;
  return result;
}
// 80728E9: using guessed type int dword_80728E9;

//----- (0805EC65) --------------------------------------------------------
_DWORD *__stdcall sub_805EC65(int a1)
{
  _DWORD *v1; // eax
  int v3; // [esp+0h] [ebp-38h]
  _DWORD *v4; // [esp+8h] [ebp-30h]
  int v5; // [esp+Ch] [ebp-2Ch]

  memset(&v3, 0, 0x30u);
  if ( v5 == 10 )
    abort();
  *(&v3 - 14) = v5;
  v1 = v4;
  *v4 = *(&v3 - 14);
  v1[1] = *(&v3 - 13);
  v1[2] = *(&v3 - 12);
  v1[3] = *(&v3 - 11);
  v1[4] = *(&v3 - 10);
  v1[5] = *(&v3 - 9);
  v1[6] = *(&v3 - 8);
  v1[7] = *(&v3 - 7);
  v1[8] = *(&v3 - 6);
  v1[9] = *(&v3 - 5);
  v1[10] = *(&v3 - 4);
  v1[11] = *(&v3 - 3);
  return v4;
}

//----- (0805ED2B) --------------------------------------------------------
const char *__cdecl sub_805ED2B(char *msgid, int a2)
{
  const char *result; // eax
  char *v3; // [esp+18h] [ebp-10h]
  const char *v4; // [esp+1Ch] [ebp-Ch]

  v3 = gettext(msgid);
  if ( v3 != msgid )
    return v3;
  v4 = sub_806413E();
  if ( sub_80639E9((int)v4, (int)"UTF-8") )
  {
    if ( sub_80639E9((int)v4, (int)"GB18030") )
    {
      if ( a2 == 9 )
        result = (const char *)&unk_8069FC5;
      else
        result = "'";
    }
    else if ( *msgid == 96 )
    {
      result = (const char *)&unk_8069FBE;
    }
    else
    {
      result = (const char *)&unk_8069FC2;
    }
  }
  else if ( *msgid == 96 )
  {
    result = (const char *)&unk_8069FAE;
  }
  else
  {
    result = (const char *)&unk_8069FB2;
  }
  return result;
}

//----- (0805EDEB) --------------------------------------------------------
#error "805EE7E: call analysis failed (funcsize=43)"

//----- (0805EE83) --------------------------------------------------------
#error "805F6F8: positive sp value has been found (funcsize=482)"

//----- (0805FC0C) --------------------------------------------------------
int __cdecl sub_805FC0C(int a1, int a2, int a3, int a4, int *a5)
{
  int *v5; // eax
  int *v6; // ST34_4
  int v7; // ST38_4
  int v8; // ST3C_4

  if ( a5 )
    v5 = a5;
  else
    v5 = &dword_80728E9;
  v6 = v5;
  v7 = *__errno_location();
  v8 = sub_805EDEB(a1, a2, a3, a4, *v6, v6[1], v6 + 2, v6[10], v6[11]);
  *__errno_location() = v7;
  return v8;
}
// 805EDEB: using guessed type _DWORD __cdecl sub_805EDEB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80728E9: using guessed type int dword_80728E9;

//----- (0805FCF0) --------------------------------------------------------
void *__cdecl sub_805FCF0(int a1, int a2, _DWORD *a3, int *a4)
{
  int *v4; // eax
  int *v5; // ST3C_4
  int v6; // ST40_4
  int v7; // ST44_4
  int size; // [esp+48h] [ebp-10h]
  void *v10; // [esp+4Ch] [ebp-Ch]

  if ( a4 )
    v4 = a4;
  else
    v4 = &dword_80728E9;
  v5 = v4;
  v6 = *__errno_location();
  v7 = v5[1] | (a3 == 0);
  size = sub_805EDEB(0, 0, a1, a2, *v5, v7, v5 + 2, v5[10], v5[11]) + 1;
  v10 = sub_80616E0(size);
  sub_805EDEB(v10, size, a1, a2, *v5, v7, v5 + 2, v5[10], v5[11]);
  *__errno_location() = v6;
  if ( a3 )
    *a3 = size - 1;
  return v10;
}
// 805EDEB: using guessed type _DWORD __cdecl sub_805EDEB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80728E9: using guessed type int dword_80728E9;

//----- (0805FED4) --------------------------------------------------------
#error "806012B: call analysis failed (funcsize=176)"

//----- (08060172) --------------------------------------------------------
int __cdecl sub_8060172(int a1, int a2)
{
  return sub_805FED4(a1, a2, -1, &dword_80728E9);
}
// 805FED4: using guessed type _DWORD __cdecl sub_805FED4(_DWORD, _DWORD, _DWORD, _DWORD);
// 80728E9: using guessed type int dword_80728E9;

//----- (080601BE) --------------------------------------------------------
int __cdecl sub_80601BE(int a1, int a2, int a3)
{
  return sub_805FED4(a1, a2, a3, &dword_80728E9);
}
// 805FED4: using guessed type _DWORD __cdecl sub_805FED4(_DWORD, _DWORD, _DWORD, _DWORD);
// 80728E9: using guessed type int dword_80728E9;

//----- (08060238) --------------------------------------------------------
int __cdecl sub_8060238(int a1, int a2, int a3)
{
  char v4; // [esp+10h] [ebp-38h]

  sub_805EC65((int)&v4);
  return sub_805FED4(a1, a3, -1, &v4);
}
// 805FED4: using guessed type _DWORD __cdecl sub_805FED4(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08060286) --------------------------------------------------------
int __cdecl sub_8060286(int a1, int a2, int a3, int a4)
{
  char v5; // [esp+10h] [ebp-38h]

  sub_805EC65((int)&v5);
  return sub_805FED4(a1, a3, a4, &v5);
}
// 805FED4: using guessed type _DWORD __cdecl sub_805FED4(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (080602C7) --------------------------------------------------------
int __cdecl sub_80602C7(int a1, int a2)
{
  return sub_8060238(0, a1, a2);
}

//----- (08060326) --------------------------------------------------------
int __cdecl sub_8060326(int a1, int a2, unsigned __int8 a3)
{
  int v4; // [esp+0h] [ebp-58h]
  unsigned __int8 v5; // [esp+1Ch] [ebp-3Ch]
  int v6; // [esp+20h] [ebp-38h]
  int v7; // [esp+24h] [ebp-34h]
  int v8; // [esp+28h] [ebp-30h]
  int v9; // [esp+2Ch] [ebp-2Ch]
  int v10; // [esp+30h] [ebp-28h]
  int v11; // [esp+34h] [ebp-24h]
  int v12; // [esp+38h] [ebp-20h]
  int v13; // [esp+3Ch] [ebp-1Ch]
  int v14; // [esp+40h] [ebp-18h]
  int v15; // [esp+44h] [ebp-14h]
  int v16; // [esp+48h] [ebp-10h]
  int v17; // [esp+4Ch] [ebp-Ch]

  v5 = a3;
  v6 = dword_80728E9;
  v7 = dword_80728ED;
  v8 = dword_80728F1;
  v9 = dword_80728F5;
  v10 = dword_80728F9;
  v11 = dword_80728FD;
  v12 = dword_8072901;
  v13 = dword_8072905;
  v14 = dword_8072909;
  v15 = dword_807290D;
  v16 = dword_8072911;
  v17 = dword_8072915;
  sub_805EB43(&v4 - 14, a3, 1);
  return sub_805FED4(0, a1, a2, &v6);
}
// 805FED4: using guessed type _DWORD __cdecl sub_805FED4(_DWORD, _DWORD, _DWORD, _DWORD);
// 80728E9: using guessed type int dword_80728E9;
// 80728ED: using guessed type int dword_80728ED;
// 80728F1: using guessed type int dword_80728F1;
// 80728F5: using guessed type int dword_80728F5;
// 80728F9: using guessed type int dword_80728F9;
// 80728FD: using guessed type int dword_80728FD;
// 8072901: using guessed type int dword_8072901;
// 8072905: using guessed type int dword_8072905;
// 8072909: using guessed type int dword_8072909;
// 807290D: using guessed type int dword_807290D;
// 8072911: using guessed type int dword_8072911;
// 8072915: using guessed type int dword_8072915;

//----- (080603E0) --------------------------------------------------------
#error "806040A: call analysis failed (funcsize=23)"

//----- (0806041D) --------------------------------------------------------
#error "8060441: positive sp value has been found (funcsize=0)"

//----- (08060442) --------------------------------------------------------
int __cdecl sub_8060442(int a1)
{
  return sub_80603E0(a1, 58);
}
// 80603E0: using guessed type _DWORD __cdecl sub_80603E0(_DWORD, _DWORD);

//----- (08060483) --------------------------------------------------------
int __cdecl sub_8060483(int a1, int a2, int a3)
{
  int v4; // [esp+0h] [ebp-78h]
  int v5; // [esp+10h] [ebp-68h]
  int v6; // [esp+14h] [ebp-64h]
  int v7; // [esp+18h] [ebp-60h]
  int v8; // [esp+1Ch] [ebp-5Ch]
  int v9; // [esp+20h] [ebp-58h]
  int v10; // [esp+24h] [ebp-54h]
  int v11; // [esp+28h] [ebp-50h]
  int v12; // [esp+2Ch] [ebp-4Ch]
  int v13; // [esp+30h] [ebp-48h]
  int v14; // [esp+34h] [ebp-44h]
  int v15; // [esp+38h] [ebp-40h]
  int v16; // [esp+3Ch] [ebp-3Ch]
  int v17; // [esp+40h] [ebp-38h]
  int v18; // [esp+44h] [ebp-34h]
  int v19; // [esp+48h] [ebp-30h]
  int v20; // [esp+4Ch] [ebp-2Ch]
  int v21; // [esp+50h] [ebp-28h]
  int v22; // [esp+54h] [ebp-24h]
  int v23; // [esp+58h] [ebp-20h]
  int v24; // [esp+5Ch] [ebp-1Ch]
  int v25; // [esp+60h] [ebp-18h]
  int v26; // [esp+64h] [ebp-14h]
  int v27; // [esp+68h] [ebp-10h]
  int v28; // [esp+6Ch] [ebp-Ch]

  sub_805EC65((int)&v5);
  v17 = v5;
  v18 = v6;
  v19 = v7;
  v20 = v8;
  v21 = v9;
  v22 = v10;
  v23 = v11;
  v24 = v12;
  v25 = v13;
  v26 = v14;
  v27 = v15;
  v28 = v16;
  sub_805EB43(&v4 - 14, 0x3Au, 1);
  return sub_805FED4(a1, a3, -1, &v4 - 14);
}
// 805FED4: using guessed type _DWORD __cdecl sub_805FED4(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08060538) --------------------------------------------------------
int sub_8060538()
{
  return sub_806057C();
}

//----- (0806057C) --------------------------------------------------------
int sub_806057C()
{
  int v1; // [esp+0h] [ebp-48h]
  int v2; // [esp+Ch] [ebp-3Ch]
  int v3; // [esp+10h] [ebp-38h]
  int v4; // [esp+14h] [ebp-34h]
  int v5; // [esp+18h] [ebp-30h]

  v3 = dword_80728E9;
  *(&v1 - 13) = dword_80728ED;
  *(&v1 - 12) = dword_80728F1;
  *(&v1 - 11) = dword_80728F5;
  *(&v1 - 10) = dword_80728F9;
  *(&v1 - 9) = dword_80728FD;
  *(&v1 - 8) = dword_8072901;
  *(&v1 - 7) = dword_8072905;
  *(&v1 - 6) = dword_8072909;
  *(&v1 - 5) = dword_807290D;
  *(&v1 - 4) = dword_8072911;
  *(&v1 - 3) = dword_8072915;
  sub_805EC24(&v1 - 14, v2, v3);
  return sub_805FED4(v5, v4, v5, &v1 - 14);
}
// 805FED4: using guessed type _DWORD __cdecl sub_805FED4(_DWORD, _DWORD, _DWORD, _DWORD);
// 80728E9: using guessed type int dword_80728E9;
// 80728ED: using guessed type int dword_80728ED;
// 80728F1: using guessed type int dword_80728F1;
// 80728F5: using guessed type int dword_80728F5;
// 80728F9: using guessed type int dword_80728F9;
// 80728FD: using guessed type int dword_80728FD;
// 8072901: using guessed type int dword_8072901;
// 8072905: using guessed type int dword_8072905;
// 8072909: using guessed type int dword_8072909;
// 807290D: using guessed type int dword_807290D;
// 8072911: using guessed type int dword_8072911;
// 8072915: using guessed type int dword_8072915;

//----- (080606C6) --------------------------------------------------------
int __cdecl sub_80606C6(int a1, int a2, int a3)
{
  return sub_805FED4(a1, a2, a3, &unk_807143C);
}
// 805FED4: using guessed type _DWORD __cdecl sub_805FED4(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0806072F) --------------------------------------------------------
int __cdecl sub_806072F(int a1, int a2)
{
  return sub_80606C6(a1, a2, -1);
}

//----- (08060751) --------------------------------------------------------
int __cdecl sub_8060751(int a1)
{
  return sub_806072F(0, a1);
}

//----- (0806079C) --------------------------------------------------------
int __cdecl sub_806079C(void *src, void *a2)
{
  int v3; // [esp+0h] [ebp-F8h]
  int v4; // [esp+4h] [ebp-F4h]
  int v5; // [esp+8h] [ebp-F0h]
  int v6; // [esp+Ch] [ebp-ECh]
  int v7; // [esp+10h] [ebp-E8h]
  int v8; // [esp+14h] [ebp-E4h]
  void *s1; // [esp+18h] [ebp-E0h]
  void *s2; // [esp+1Ch] [ebp-DCh]
  int v11; // [esp+20h] [ebp-D8h]
  size_t n; // [esp+24h] [ebp-D4h]
  void *ptr; // [esp+28h] [ebp-D0h]

  s1 = (void *)sub_8056B5B(src);
  s2 = (void *)sub_8056B5B(a2);
  v11 = sub_8056C06((char *)s1);
  n = sub_8056C06((char *)s2);
  if ( v11 == n && !memcmp(s1, s2, n) )
  {
    dword_80711F0 = (int)&loc_8060846;
    sub_80651FD(v3, v4, v5, v6, v7, v8, s1, s2, v11, n, ptr);
  }
  return 0;
}
// 8056B5B: using guessed type _DWORD __cdecl sub_8056B5B(_DWORD);
// 8065115: using guessed type int __stdcall sub_8065115(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80651FD: using guessed type int __stdcall sub_80651FD(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80711F0: using guessed type int dword_80711F0;
// 8071218: using guessed type int dword_8071218;

//----- (080609CE) --------------------------------------------------------
void sub_80609CE()
{
  ;
}

//----- (08060A1F) --------------------------------------------------------
#error "8060A44: call analysis failed (funcsize=20)"

//----- (08060A57) --------------------------------------------------------
#error "8060A6B: positive sp value has been found (funcsize=0)"

//----- (08060A6C) --------------------------------------------------------
signed int sub_8060A6C()
{
  *__errno_location() = 95;
  return -1;
}

//----- (08060BC8) --------------------------------------------------------
_DWORD *__userpurge sub_8060BC8@<eax>(_DWORD *a1, int a2)
{
  int v2; // edx

  v2 = *(_DWORD *)(a2 + 68);
  *a1 = *(_DWORD *)(a2 + 64);
  a1[1] = v2;
  return a1;
}

//----- (08060BF3) --------------------------------------------------------
_DWORD *__userpurge sub_8060BF3@<eax>(_DWORD *a1, int a2)
{
  int v2; // edx

  v2 = *(_DWORD *)(a2 + 84);
  *a1 = *(_DWORD *)(a2 + 80);
  a1[1] = v2;
  return a1;
}

//----- (08060C22) --------------------------------------------------------
_DWORD *__userpurge sub_8060C22@<eax>(_DWORD *a1, int a2)
{
  int v2; // edx

  v2 = *(_DWORD *)(a2 + 76);
  *a1 = *(_DWORD *)(a2 + 72);
  a1[1] = v2;
  return a1;
}

//----- (08060CD3) --------------------------------------------------------
int __cdecl sub_8060CD3(int a1, int a2, int a3, int a4)
{
  int v4; // ecx
  void *v5; // eax
  int result; // eax
  int savedregs; // [esp+0h] [ebp+0h]

  v5 = &loc_8060CF9;
  if ( a1 < a3 )
    v5 = &loc_8060D24;
  dword_8071254 = (int)v5;
  sub_8064FC3(v4, a1, savedregs);
  if ( a1 > a3 )
    result = 1;
  else
    result = a2 - a4;
  return result;
}
// 8071254: using guessed type int dword_8071254;

//----- (08060D8C) --------------------------------------------------------
#error "80611DC: call analysis failed (funcsize=430)"

//----- (0806144D) --------------------------------------------------------
int __cdecl sub_806144D(FILE *stream, int a2, int a3, int a4, int a5)
{
  int *v5; // eax
  unsigned int i; // [esp+24h] [ebp-34h]
  int v8[12]; // [esp+28h] [ebp-30h]

  for ( i = 0; i <= 9; ++i )
  {
    v5 = (int *)a5;
    a5 += 4;
    v8[i] = *v5;
    if ( !v8[i] )
      break;
  }
  return sub_8060D8C(stream, a2, a3, a4, (int)v8, i);
}
// 806144D: using guessed type int var_30[12];

//----- (080614C7) --------------------------------------------------------
int sub_80614C7(FILE *stream, int a2, int a3, int a4, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a4);
  return sub_806144D(stream, a2, a3, a4, (int)va);
}

//----- (08061577) --------------------------------------------------------
void *__cdecl sub_8061577(unsigned int a1, unsigned int a2)
{
  if ( 0x7FFFFFFF / a2 < a1 )
    sub_80618DE();
  return sub_80616F7(a2 * a1);
}

//----- (080615E7) --------------------------------------------------------
void *__cdecl sub_80615E7(void *ptr, int a2, int a3)
{
  if ( 0x7FFFFFFFu / a3 < a2 )
    sub_80618DE();
  return sub_8061746(ptr, a3 * a2);
}

//----- (0806162C) --------------------------------------------------------
void *__usercall sub_806162C@<eax>(int a1@<edx>, int a2@<ecx>, void *ptr, int a4, int a5)
{
  void *v5; // eax
  int v7; // [esp+0h] [ebp-28h]
  unsigned int v8; // [esp+1Ch] [ebp-Ch]

  v8 = *(_DWORD *)a4;
  v5 = &loc_8061659;
  if ( ptr )
    v5 = &loc_8061693;
  dword_80711DC = (int)v5;
  sub_806526B(a2, a1, v7);
  if ( !v8 )
    v8 = (0x40u / a5 == 0) + 0x40u / a5;
  if ( 0x7FFFFFFFu / a5 < v8 )
    sub_80618DE();
  *(_DWORD *)a4 = v8;
  return sub_8061746(ptr, a5 * v8);
}
// 80711DC: using guessed type int dword_80711DC;

//----- (080616E0) --------------------------------------------------------
void *__cdecl sub_80616E0(size_t size)
{
  return sub_80616F7(size);
}

//----- (080616F7) --------------------------------------------------------
void *__cdecl sub_80616F7(size_t size)
{
  int v1; // edx
  int v2; // ecx
  void *v3; // eax
  int v5; // [esp+0h] [ebp-28h]
  void *v6; // [esp+1Ch] [ebp-Ch]

  v6 = malloc(size);
  if ( !v6 )
  {
    v3 = &loc_806173C;
    if ( !size )
      v3 = &loc_8061741;
    dword_80711DC = (int)v3;
    sub_806526B(v2, v1, v5);
    sub_80618DE();
  }
  return v6;
}
// 80711DC: using guessed type int dword_80711DC;

//----- (08061746) --------------------------------------------------------
void *__cdecl sub_8061746(void *ptr, size_t size)
{
  int v2; // ST00_4
  int v4; // [esp+4h] [ebp-14h]
  int v5; // [esp+8h] [ebp-10h]
  int v6; // [esp+Ch] [ebp-Ch]
  void *ptra; // [esp+20h] [ebp+8h]

  if ( !size && ptr )
  {
    free(ptr);
    dword_8071268 = (int)&locret_80617AC;
    sub_8064F57(v2, v4, v5, v6);
  }
  ptra = realloc(ptr, size);
  if ( !ptra && size )
    sub_80618DE();
  return ptra;
}
// 8064F57: using guessed type int __stdcall sub_8064F57(_DWORD, _DWORD, _DWORD, _DWORD);
// 8071268: using guessed type int dword_8071268;

//----- (080617AE) --------------------------------------------------------
void *__usercall sub_80617AE@<eax>(int a1@<edx>, int a2@<ecx>, void *ptr, int a4)
{
  return sub_806162C(a1, a2, ptr, a4, 1);
}

//----- (08061857) --------------------------------------------------------
#error "80618A2: call analysis failed (funcsize=28)"

//----- (080618A7) --------------------------------------------------------
#error "80618B4: positive sp value has been found (funcsize=0)"

//----- (080618B5) --------------------------------------------------------
int __cdecl sub_80618B5(char *s)
{
  size_t v1; // eax

  v1 = strlen(s);
  return sub_8061857((int)s, v1 + 1);
}

//----- (080618DE) --------------------------------------------------------
void __noreturn sub_80618DE()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (08061927) --------------------------------------------------------
#error "806199B: call analysis failed (funcsize=112)"

//----- (08061B40) --------------------------------------------------------
char *sub_8061B40()
{
  char *v1; // [esp+1Ch] [ebp-Ch]

  v1 = getcwd(0, 0);
  if ( !v1 && *__errno_location() == 12 )
    sub_80618DE();
  return v1;
}

//----- (08061B7D) --------------------------------------------------------
#error "8061CB3: call analysis failed (funcsize=100)"

//----- (08061CBE) --------------------------------------------------------
signed int __cdecl sub_8061CBE(unsigned int *a1, unsigned int a2)
{
  signed int result; // eax

  if ( 0xFFFFFFFF / a2 >= *a1 )
  {
    *a1 *= a2;
    result = 0;
  }
  else
  {
    *a1 = -1;
    result = 1;
  }
  return result;
}

//----- (08061D16) --------------------------------------------------------
int __cdecl sub_8061D16(int a1, int a2, int a3)
{
  void *v3; // eax
  int v5; // [esp+0h] [ebp-18h]
  int v6; // [esp+4h] [ebp-14h]
  int v7; // [esp+8h] [ebp-10h]
  int v8; // [esp+Ch] [ebp-Ch]

  v3 = &loc_8061D82;
  if ( a3 )
    v3 = &loc_8061D25;
  dword_8071268 = (int)v3;
  sub_8064F57(v5, v6, v7, v8);
  return a3;
}
// 8064F57: using guessed type int __stdcall sub_8064F57(_DWORD, _DWORD, _DWORD, _DWORD);
// 8071268: using guessed type int dword_8071268;

//----- (08061D87) --------------------------------------------------------
int __cdecl sub_8061D87(char *nptr, int a2, int base)
{
  char **v3; // eax
  char v4; // ST27_1
  void *v5; // eax
  int v7; // [esp+0h] [ebp-48h]
  int v8; // [esp+4h] [ebp-44h]
  int v9; // [esp+8h] [ebp-40h]
  int v10; // [esp+Ch] [ebp-3Ch]
  unsigned __int8 v11; // [esp+1Fh] [ebp-29h]
  char v12; // [esp+20h] [ebp-28h]
  int v13; // [esp+28h] [ebp-20h]
  char *v14; // [esp+2Ch] [ebp-1Ch]
  char **endptr; // [esp+3Ch] [ebp-Ch]

  v13 = 0;
  if ( base < 0 || base > 36 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoul");
  if ( a2 )
    v3 = (char **)a2;
  else
    v3 = (char **)&v12;
  endptr = v3;
  *__errno_location() = 0;
  v14 = nptr;
  v4 = *nptr;
  dword_807122C = (int)&loc_8061E15;
  sub_80650A5();
  do
    v11 = *++v14;
  while ( (*__ctype_b_loc())[v11] & 0x2000 );
  v5 = &loc_8061E52;
  if ( v11 != 45 )
    v5 = &loc_8061E5C;
  dword_8071268 = (int)v5;
  sub_8064F57(v7, v8, v9, v10);
  return 4;
}
// 8064F57: using guessed type int __stdcall sub_8064F57(_DWORD, _DWORD, _DWORD, _DWORD);
// 807122C: using guessed type int dword_807122C;
// 8071268: using guessed type int dword_8071268;

//----- (08062226) --------------------------------------------------------
#error "8062319: call analysis failed (funcsize=73)"

//----- (0806231E) --------------------------------------------------------
#error "806233E: positive sp value has been found (funcsize=0)"

//----- (0806233F) --------------------------------------------------------
void __cdecl __noreturn sub_806233F(int a1, int a2, char a3, int a4, int a5)
{
  sub_8062226(a1, a2, a3, a4, a5);
  abort();
}
// 8062226: using guessed type _DWORD __cdecl sub_8062226(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (08062396) --------------------------------------------------------
#error "80623C7: call analysis failed (funcsize=20)"

//----- (080623CC) --------------------------------------------------------
#error "8062467: positive sp value has been found (funcsize=44)"

//----- (08062470) --------------------------------------------------------
int __cdecl sub_8062470(int a1, int a2, int a3)
{
  int v3; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; ; i |= sub_8062396(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}
// 8062396: using guessed type _DWORD __cdecl sub_8062396(_DWORD, _DWORD);

//----- (080624A6) --------------------------------------------------------
int __cdecl sub_80624A6()
{
  int *v0; // eax
  const unsigned __int16 **v1; // eax
  int v2; // ecx
  int v3; // edx
  void *v4; // eax
  int v6; // edx
  _DWORD *v7; // ecx
  int v8; // edx
  _DWORD *v9; // ecx
  int v10; // eax
  int v11; // edx
  _DWORD *v12; // ecx
  int v13; // eax
  int v14; // edx
  _DWORD *v15; // ecx
  int v16; // [esp-4h] [ebp-4Ch]
  int v17; // [esp+0h] [ebp-48h]
  int v18; // [esp+4h] [ebp-44h]
  const char *v19; // [esp+8h] [ebp-40h]
  int *v20; // [esp+Ch] [ebp-3Ch]
  const char *v21; // [esp+10h] [ebp-38h]
  _DWORD *v22; // [esp+14h] [ebp-34h]
  const char *v23; // [esp+18h] [ebp-30h]
  int v24; // [esp+1Ch] [ebp-2Ch]
  int v25; // [esp+20h] [ebp-28h]
  int v26; // [esp+24h] [ebp-24h]
  int v27; // [esp+28h] [ebp-20h]

  v25 = 0;
  if ( (signed int)v21 < 0 || (signed int)v21 > 36 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoumax");
  if ( v20 )
    v0 = v20;
  else
    v0 = &v17 - 11;
  *(&v17 - 5) = (int)v0;
  *__errno_location() = 0;
  *(&v17 - 9) = (int)v19;
  for ( *((_BYTE *)&v17 - 45) = *(_BYTE *)*(&v17 - 9); ; *((_BYTE *)&v17 - 45) = *(_BYTE *)*(&v17 - 9) )
  {
    v1 = __ctype_b_loc();
    v3 = *((unsigned __int8 *)&v17 - 45);
    if ( !((*v1)[v3] & 0x2000) )
      break;
    ++*(&v17 - 9);
  }
  if ( *((_BYTE *)&v17 - 45) == 45 )
  {
    dword_8071254 = (int)&locret_806291F;
    sub_8064FC3(v2, v3 * 2, v17);
  }
  v19 = v21;
  v18 = *(&v17 - 5);
  *((_QWORD *)&v17 - 2) = strtoumax(v21, (char **)v18, (int)v21);
  if ( *(const char **)*(&v17 - 5) == v19 )
  {
    v16 = *(_DWORD *)*(&v17 - 5);
    v4 = &loc_80625C9;
    if ( !v23 )
      v4 = &loc_8062603;
    dword_80711F0 = (int)v4;
    sub_80651FD(v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27);
    if ( !**(_BYTE **)*(&v17 - 5) )
      return 4;
    v18 = **(char **)*(&v17 - 5);
    if ( !strchr(v23, v18) )
      return 4;
    *(&v17 - 4) = 1;
    *(&v17 - 3) = 0;
  }
  else if ( *__errno_location() )
  {
    if ( *__errno_location() != 34 )
      return 4;
    *(&v17 - 10) = 1;
  }
  if ( !v23 )
  {
    v6 = *(&v17 - 3);
    v7 = v22;
    *v22 = *(&v17 - 4);
    v7[1] = v6;
    return *(&v17 - 10);
  }
  if ( !**(_BYTE **)*(&v17 - 5) )
    goto LABEL_54;
  *(&v17 - 8) = 1024;
  *(&v17 - 7) = 1;
  v18 = **(char **)*(&v17 - 5);
  if ( !strchr(v23, v18) )
  {
    v8 = *(&v17 - 3);
    v9 = v22;
    *v22 = *(&v17 - 4);
    v9[1] = v8;
    return *(&v17 - 10) | 2;
  }
  switch ( **(char **)*(&v17 - 5) )
  {
    case 69:
    case 71:
    case 75:
    case 77:
    case 80:
    case 84:
    case 89:
    case 90:
    case 103:
    case 107:
    case 109:
    case 116:
      if ( strchr(v23, 48) )
      {
        v10 = *(char *)(*(_DWORD *)*(&v17 - 5) + 1);
        switch ( v10 )
        {
          case 68:
            goto LABEL_57;
          case 105:
            if ( *(_BYTE *)(*(_DWORD *)*(&v17 - 5) + 2) == 66 )
              *(&v17 - 7) += 2;
            goto LABEL_38;
          case 66:
LABEL_57:
            *(&v17 - 8) = 1000;
            ++*(&v17 - 7);
            break;
        }
      }
      break;
    default:
      break;
  }
LABEL_38:
  switch ( **(char **)*(&v17 - 5) )
  {
    case 66:
      *(&v17 - 6) = sub_8062396(&v17 - 4, 1024);
      break;
    case 69:
      v19 = (const char *)6;
      v18 = *(&v17 - 8);
      *(&v17 - 6) = sub_8062470((int)(&v17 - 4), v18, 6);
      break;
    case 71:
    case 103:
      v19 = (const char *)3;
      v18 = *(&v17 - 8);
      *(&v17 - 6) = sub_8062470((int)(&v17 - 4), v18, 3);
      break;
    case 75:
    case 107:
      v19 = (const char *)1;
      v18 = *(&v17 - 8);
      *(&v17 - 6) = sub_8062470((int)(&v17 - 4), v18, 1);
      break;
    case 77:
    case 109:
      v19 = (const char *)2;
      v18 = *(&v17 - 8);
      *(&v17 - 6) = sub_8062470((int)(&v17 - 4), v18, 2);
      break;
    case 80:
      v19 = (const char *)5;
      v18 = *(&v17 - 8);
      *(&v17 - 6) = sub_8062470((int)(&v17 - 4), v18, 5);
      break;
    case 84:
    case 116:
      v19 = (const char *)4;
      v18 = *(&v17 - 8);
      *(&v17 - 6) = sub_8062470((int)(&v17 - 4), v18, 4);
      break;
    case 89:
      v19 = (const char *)8;
      v18 = *(&v17 - 8);
      *(&v17 - 6) = sub_8062470((int)(&v17 - 4), v18, 8);
      break;
    case 90:
      v19 = (const char *)7;
      v18 = *(&v17 - 8);
      *(&v17 - 6) = sub_8062470((int)(&v17 - 4), v18, 7);
      break;
    case 98:
      *(&v17 - 6) = sub_8062396(&v17 - 4, 512);
      break;
    case 99:
      *(&v17 - 6) = 0;
      break;
    case 119:
      *(&v17 - 6) = sub_8062396(&v17 - 4, 2);
      break;
    default:
      v11 = *(&v17 - 3);
      v12 = v22;
      *v22 = *(&v17 - 4);
      v12[1] = v11;
      v13 = *(&v17 - 10) | 2;
      dword_80711DC = (int)&locret_806291F;
      sub_806526B(v12, v11, v17);
      break;
  }
  *(&v17 - 10) |= *(&v17 - 6);
  *(_DWORD *)*(&v17 - 5) += *(&v17 - 7);
  if ( **(_BYTE **)*(&v17 - 5) )
    *(&v17 - 10) |= 2u;
LABEL_54:
  v14 = *(&v17 - 3);
  v15 = v22;
  *v22 = *(&v17 - 4);
  v15[1] = v14;
  return *(&v17 - 10);
}
// 8062396: using guessed type _DWORD __cdecl sub_8062396(_DWORD, _DWORD);
// 80651FD: using guessed type int __stdcall sub_80651FD(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;
// 80711F0: using guessed type int dword_80711F0;
// 8071254: using guessed type int dword_8071254;

//----- (08062921) --------------------------------------------------------
size_t __cdecl sub_8062921(wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  char v5; // [esp+18h] [ebp-10h]
  size_t v6; // [esp+1Ch] [ebp-Ch]

  if ( !pwc )
    pwc = (wchar_t *)&v5;
  v6 = mbrtowc(pwc, s, n, p);
  if ( v6 <= 0xFFFFFFFD || !n || !((unsigned __int8)sub_8057964(0) ^ 1) )
    return v6;
  *pwc = (unsigned __int8)*s;
  return 1;
}

//----- (08062997) --------------------------------------------------------
#error "80629D5: call analysis failed (funcsize=31)"

//----- (080629EE) --------------------------------------------------------
int __cdecl sub_80629EE(int a1, int a2)
{
  int result; // eax

  if ( *(_BYTE *)(a1 + 40) & 1 )
    result = (*(int (__cdecl **)(_DWORD, int))(a1 + 32))(*(_DWORD *)(a1 + 36), a2);
  else
    result = (*(int (__cdecl **)(int))(a1 + 32))(a2);
  return result;
}

//----- (08062A30) --------------------------------------------------------
signed int __cdecl sub_8062A30(int a1, signed int a2, signed int a3)
{
  int v4; // [esp+18h] [ebp-10h]
  _DWORD *v5; // [esp+1Ch] [ebp-Ch]

  if ( !a3 )
    a3 = 8;
  if ( !a2 )
  {
    v4 = 32;
    a2 = 4064;
  }
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 24) = a3 - 1;
  *(_DWORD *)(a1 + 4) = sub_8062997(a1, *(_DWORD *)a1);
  v5 = *(_DWORD **)(a1 + 4);
  if ( !v5 )
    obstack_alloc_failed_handler();
  *(_DWORD *)(a1 + 8) = ((unsigned int)&v5[a3 / 4u + 1] + 3) & -a3;
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 8);
  *v5 = (char *)v5 + *(_DWORD *)a1;
  *(_DWORD *)(a1 + 16) = *v5;
  v5[1] = 0;
  *(_BYTE *)(a1 + 40) &= 0xFDu;
  *(_BYTE *)(a1 + 40) &= 0xFBu;
  return 1;
}
// 80714C0: using guessed type int (*obstack_alloc_failed_handler)(void);

//----- (08062B33) --------------------------------------------------------
signed int __cdecl sub_8062B33(int a1, signed int a2, signed int a3, int a4, int a5)
{
  *(_DWORD *)(a1 + 28) = a4;
  *(_DWORD *)(a1 + 32) = a5;
  *(_BYTE *)(a1 + 40) &= 0xFEu;
  return sub_8062A30(a1, a2, a3);
}

//----- (08062BDC) --------------------------------------------------------
#error "8062D9C: call analysis failed (funcsize=153)"

//----- (08062DAF) --------------------------------------------------------
#error "8062DBA: positive sp value has been found (funcsize=0)"

//----- (08062F70) --------------------------------------------------------
int __cdecl sub_8062F70(int a1, int a2)
{
  return (a1 == 0) ^ (a2 == 0) && a1 >= 0 && a2 >= 0;
}

//----- (08062FA8) --------------------------------------------------------
_BOOL4 __cdecl sub_8062FA8(_DWORD *a1, _DWORD *a2)
{
  int v2; // ebx

  v2 = a1[5] ^ a2[5] | a1[4] ^ a2[4] | a1[3] ^ a2[3] | a1[2] ^ a2[2] | a1[1] ^ a2[1] | *a2 ^ *a1;
  return (v2 | (unsigned __int8)sub_8062F70(a1[8], a2[8])) == 0;
}

//----- (0806306A) --------------------------------------------------------
char *__cdecl sub_806306A(void *dest, void *src, size_t n)
{
  char *result; // eax

  memcpy(dest, src, n);
  result = (char *)dest + n;
  *((_BYTE *)dest + n) = 0;
  return result;
}

//----- (08063096) --------------------------------------------------------
#error "8063133: call analysis failed (funcsize=55)"

//----- (08063192) --------------------------------------------------------
signed int __cdecl sub_8063192(int a1, unsigned int a2)
{
  bool v3; // zf
  int v4; // edx
  int v5; // ecx
  void *v6; // eax
  int v7; // [esp+0h] [ebp-28h]
  char *s1; // [esp+10h] [ebp-18h]
  char *s2; // [esp+14h] [ebp-14h]

  s1 = (char *)&unk_806AAC0;
  s2 = *(char **)(a2 + 40);
  if ( !s2 || a2 <= (unsigned int)s2 && a2 + 44 > (unsigned int)s2 )
    return 1;
  if ( *s2 )
  {
    s1 = (char *)(a1 + 5);
    v3 = strcmp((const char *)(a1 + 5), s2) == 0;
    v6 = &loc_8063356;
    if ( !v3 )
      v6 = &loc_80631EE;
    dword_80711DC = (int)v6;
    sub_806526B(v5, v4, v7);
  }
  *(_DWORD *)(a2 + 40) = s1;
  return 1;
}
// 80711DC: using guessed type int dword_80711DC;

//----- (08063366) --------------------------------------------------------
void *__cdecl sub_8063366(void *ptr)
{
  void *result; // eax
  void *v2; // ST1C_4

  result = (void *)1;
  if ( ptr != (void *)1 )
  {
    while ( ptr )
    {
      v2 = *(void **)ptr;
      free(ptr);
      result = v2;
      ptr = v2;
    }
  }
  return result;
}

//----- (0806339D) --------------------------------------------------------
char *sub_806339D()
{
  return getenv("TZ");
}

//----- (080633B1) --------------------------------------------------------
int __cdecl sub_80633B1(char *value)
{
  int result; // eax

  if ( value )
    result = setenv("TZ", (const char *)1, 1);
  else
    result = unsetenv("TZ");
  return result;
}

//----- (080633FA) --------------------------------------------------------
#error "806341F: call analysis failed (funcsize=28)"

//----- (08063450) --------------------------------------------------------
signed int __cdecl sub_8063450(int a1)
{
  char *v1; // eax
  int v2; // edx
  int v3; // ecx
  bool v4; // zf
  void *v5; // eax
  bool v6; // al
  int v8; // ST24_4
  int v9; // [esp+0h] [ebp-28h]
  char *s2; // [esp+14h] [ebp-14h]
  void *ptr; // [esp+18h] [ebp-10h]

  v1 = sub_806339D();
  s2 = v1;
  v4 = v1 == 0;
  v5 = &loc_806347D;
  if ( v4 )
    v5 = &loc_80634B2;
  dword_8071254 = (int)v5;
  sub_8064FC3(v3, v2, v9);
  v6 = *(_BYTE *)(a1 + 4) && !strcmp((const char *)(a1 + 5), s2);
  if ( v6 )
    return 1;
  ptr = (void *)sub_8063096(s2);
  if ( !ptr )
    return 0;
  if ( !((unsigned __int8)sub_80633FA(a1) ^ 1) )
    return (signed int)ptr;
  v8 = *__errno_location();
  sub_8063366(ptr);
  *__errno_location() = v8;
  return 0;
}
// 8063096: using guessed type int __cdecl sub_8063096(_DWORD);
// 80633FA: using guessed type _DWORD __cdecl sub_80633FA(_DWORD);
// 8071254: using guessed type int dword_8071254;

//----- (08063523) --------------------------------------------------------
int __cdecl sub_8063523(void *ptr)
{
  unsigned __int8 v2; // [esp+1Bh] [ebp-Dh]
  int v3; // [esp+1Ch] [ebp-Ch]

  if ( ptr == (void *)1 )
    return 1;
  v3 = *__errno_location();
  v2 = sub_80633FA(ptr);
  if ( v2 ^ 1 )
    v3 = *__errno_location();
  sub_8063366(ptr);
  *__errno_location() = v3;
  return v2;
}
// 80633FA: using guessed type _DWORD __cdecl sub_80633FA(_DWORD);

//----- (08063586) --------------------------------------------------------
#error "80635A6: call analysis failed (funcsize=21)"

//----- (08063671) --------------------------------------------------------
#error "806371B: call analysis failed (funcsize=67)"

//----- (080638A9) --------------------------------------------------------
int __cdecl sub_80638A9(int a1, char a2)
{
  return __ROR4__(a1, a2);
}

//----- (080639E9) --------------------------------------------------------
#error "8063A31: call analysis failed (funcsize=36)"

//----- (08063A8D) --------------------------------------------------------
int __cdecl sub_8063A8D(FILE *fp)
{
  bool v1; // ST26_1
  void *v2; // eax
  int v4; // [esp+0h] [ebp-28h]
  int v5; // [esp+4h] [ebp-24h]
  int v6; // [esp+8h] [ebp-20h]
  int v7; // [esp+Ch] [ebp-1Ch]
  bool v8; // [esp+1Dh] [ebp-Bh]
  bool v9; // [esp+1Fh] [ebp-9h]

  v8 = __fpending(fp) != 0;
  v1 = ferror_unlocked(fp) != 0;
  v9 = sub_80641F5(fp) != 0;
  if ( !v1 )
  {
    v2 = &loc_8063AF1;
    if ( !v9 )
      v2 = &loc_8063B20;
    dword_8071268 = (int)v2;
    sub_8064F57(v4, v5, v6, v7);
    if ( !v8 && *__errno_location() == 9 )
      return 0;
  }
  if ( v9 != 1 )
    *__errno_location() = 0;
  return -1;
}
// 8064F57: using guessed type int __stdcall sub_8064F57(_DWORD, _DWORD, _DWORD, _DWORD);
// 8071268: using guessed type int dword_8071268;

//----- (08063B2B) --------------------------------------------------------
int __cdecl sub_8063B2B(void *src)
{
  int v2; // [esp+1Ch] [ebp-Ch]

  v2 = sub_8056ABC(src);
  if ( !v2 )
    sub_80618DE();
  return v2;
}

//----- (08063B53) --------------------------------------------------------
int __cdecl sub_8063B53(int a1)
{
  int *v1; // ebp
  int v3; // [esp+0h] [ebp-10h]
  int v4; // [esp+8h] [ebp-8h]
  int v5; // [esp+Ch] [ebp-4h]
  int savedregs; // [esp+10h] [ebp+0h]

  v1 = &savedregs;
  v5 = 0;
  v4 = a1;
  while ( *(_BYTE *)*(v1 - 2) )
  {
    *(v1 - 1) = __ROR4__(*(v1 - 1), 23) + *(char *)*(v1 - 2);
    v1 = &v3;
    ++*(v1 - 2);
  }
  return *(v1 - 1) % (unsigned int)v1[3];
}

//----- (08063BB3) --------------------------------------------------------
#error "8063D3E: call analysis failed (funcsize=137)"

//----- (0806413E) --------------------------------------------------------
const char *sub_806413E()
{
  char *v0; // ST1C_4
  const char *s1; // [esp+18h] [ebp-10h]
  char *s2; // [esp+1Ch] [ebp-Ch]

  s1 = nl_langinfo(14);
  if ( !s1 )
    s1 = (const char *)&unk_806AB1B;
  for ( s2 = (char *)sub_8063BB3(); *s2; s2 = &v0[strlen(v0) + 1] )
  {
    if ( !strcmp(s1, s2) || *s2 == 42 && !s2[1] )
    {
      s1 = &s2[strlen(s2) + 1];
      break;
    }
    v0 = &s2[strlen(s2) + 1];
  }
  if ( !*s1 )
    s1 = "ASCII";
  return s1;
}
// 8063BB3: using guessed type int sub_8063BB3(void);

//----- (080641F5) --------------------------------------------------------
int __cdecl sub_80641F5(FILE *stream)
{
  bool v2; // zf
  void *v3; // eax
  int v4; // eax
  __int64 v5; // rax
  int v6; // [esp+0h] [ebp-28h]
  int v7; // [esp+4h] [ebp-24h]
  int v8; // [esp+8h] [ebp-20h]
  int v9; // [esp+Ch] [ebp-1Ch]
  int v10; // [esp+14h] [ebp-14h]
  int v11; // [esp+18h] [ebp-10h]

  v10 = 0;
  if ( fileno(stream) < 0 )
    return fclose(stream);
  v2 = __freading(stream) == 0;
  v3 = &loc_8064255;
  if ( v2 )
    v3 = &loc_806428E;
  dword_8071268 = (int)v3;
  sub_8064F57(v6, v7, v8, v9);
  v4 = fileno(stream);
  LODWORD(v5) = lseek64(v4, 0, 0, 1);
  if ( v5 != -1 && sub_806431A(stream) )
    v10 = *__errno_location();
  v11 = fclose(stream);
  if ( v10 )
  {
    *__errno_location() = v10;
    v11 = -1;
  }
  return v11;
}
// 8049A70: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8064F57: using guessed type int __stdcall sub_8064F57(_DWORD, _DWORD, _DWORD, _DWORD);
// 8071268: using guessed type int dword_8071268;

//----- (080642DD) --------------------------------------------------------
int __cdecl sub_80642DD(FILE *stream)
{
  int result; // eax

  result = stream->_flags & 0x100;
  if ( result )
    result = sub_806435E(stream, 0, 0, 1);
  return result;
}

//----- (0806431A) --------------------------------------------------------
int __cdecl sub_806431A(FILE *fp)
{
  if ( !fp || !__freading(fp) )
    return fflush(fp);
  sub_80642DD(fp);
  return fflush(fp);
}

//----- (0806435E) --------------------------------------------------------
int __cdecl sub_806435E(FILE *stream, int a2, int a3, int a4)
{
  int v4; // ecx
  char *v5; // edx
  void *v6; // eax
  int v7; // ecx
  char *v8; // edx
  void *v9; // eax
  int v10; // eax
  __off64_t v11; // rax
  int v13; // [esp+0h] [ebp-38h]
  int v14; // [esp+0h] [ebp-38h]

  v5 = stream->_IO_read_end;
  v6 = &loc_80643A9;
  if ( v5 != stream->_IO_read_ptr )
    v6 = &loc_8064460;
  dword_80711DC = (int)v6;
  sub_806526B(v4, v5, v13);
  v8 = stream->_IO_write_ptr;
  v9 = &loc_80643D2;
  if ( v8 != stream->_IO_write_base )
    v9 = &loc_8064460;
  dword_8071254 = (int)v9;
  sub_8064FC3(v7, v8, v14);
  if ( stream->_IO_save_base )
    return fseeko64(stream, a2, a3, a4);
  v10 = fileno(stream);
  LODWORD(v11) = lseek64(v10, a2, a3, a4);
  if ( v11 == -1 )
    return -1;
  stream->_flags &= 0xFFFFFFEF;
  stream->_offset = v11;
  return 0;
}
// 806435E: could not find valid save-restore pair for ebx
// 8049610: using guessed type int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8049A70: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;
// 8071254: using guessed type int dword_8071254;

//----- (08064496) --------------------------------------------------------
int __usercall sub_8064496@<eax>(int a1@<esi>, __int64 a2, unsigned int a3, signed int a4)
{
  int v4; // edx
  unsigned int v5; // ecx
  unsigned int v6; // esi
  unsigned int v7; // edi
  unsigned int v8; // ebp
  unsigned int v9; // eax
  int v10; // ecx
  unsigned int v11; // edx
  int v12; // ebp
  signed int v13; // ecx
  signed __int64 v14; // rax
  int v15; // edx
  int v16; // edi
  unsigned __int64 v17; // rtt
  unsigned int v18; // ebp
  signed int v19; // esi
  unsigned __int64 v20; // rax
  int v22; // [esp+0h] [ebp-1Ch]
  unsigned int v23; // [esp+4h] [ebp-18h]
  unsigned int v24; // [esp+8h] [ebp-14h]
  unsigned int v25; // [esp+Ch] [ebp-10h]
  int v26; // [esp+10h] [ebp-Ch]

  v26 = a1;
  v4 = a2;
  v22 = 0;
  v23 = a3;
  v5 = HIDWORD(a2);
  if ( a2 < 0 )
  {
    v4 = -(signed int)a2;
    v6 = v23;
    v7 = a4;
    v5 = (unsigned __int64)-a2 >> 32;
    v22 = -1;
    if ( a4 >= 0 )
      goto LABEL_3;
  }
  else
  {
    v6 = v23;
    v7 = a4;
    if ( a4 >= 0 )
      goto LABEL_3;
  }
  v6 = -v6;
  v22 = ~v22;
  v7 = (unsigned __int64)-(signed __int64)__PAIR__(v7, v6) >> 32;
LABEL_3:
  v8 = v5;
  v24 = v4;
  v9 = v7;
  v10 = v4;
  v23 = v6;
  if ( !v7 )
  {
    if ( v6 <= v8 )
    {
      if ( !v6 )
        v6 = 1 / 0u;
      v15 = v8 % v6;
      v12 = v8 / v6;
      v13 = __PAIR__((unsigned int)v15, v10) / v6;
    }
    else
    {
      v11 = v8;
      v12 = 0;
      v13 = __PAIR__(v11, v10) / v6;
    }
    goto LABEL_8;
  }
  if ( v7 > v8 )
    goto LABEL_7;
  _BitScanReverse(&v7, v7);
  v16 = v7 ^ 0x1F;
  if ( v16 )
  {
    v25 = (v9 << v16) | (v23 >> (32 - v16));
    v23 <<= v16;
    LODWORD(v17) = ((_DWORD)&v22 << v16) | (v24 >> (32 - v16));
    HIDWORD(v17) = (unsigned int)&v22 >> (32 - v16);
    v18 = v17 % v25;
    v19 = v17 / v25;
    v20 = v23 * (unsigned __int64)(unsigned int)v19;
    v23 = HIDWORD(v20);
    if ( v18 < HIDWORD(v20) || (HIDWORD(v20) = v24 << v16, v24 << v16 < (unsigned int)v20) && v18 == v23 )
    {
      dword_8071254 = (int)&loc_806450D;
      sub_8064FC3(v19 - 1, HIDWORD(v20), v22);
      LODWORD(v14) = sub_806465D(a2, HIDWORD(a2), a3, a4);
      return v14;
    }
    v13 = v19;
    v12 = 0;
  }
  else
  {
    if ( v23 > v24 && v9 >= v8 )
    {
LABEL_7:
      v12 = 0;
      v13 = 0;
      goto LABEL_8;
    }
    v12 = 0;
    v13 = 1;
  }
LABEL_8:
  LODWORD(v14) = v13;
  if ( v22 )
    v14 = -__PAIR__(v12, v13);
  return v14;
}
// 806465D: using guessed type _DWORD __cdecl sub_806465D(_DWORD, _DWORD, _DWORD, _DWORD);
// 8071254: using guessed type int dword_8071254;

//----- (0806465D) --------------------------------------------------------
#error "8064683: call analysis failed (funcsize=19)"

//----- (08064696) --------------------------------------------------------
#error "806471C: positive sp value has been found (funcsize=45)"

//----- (0806489E) --------------------------------------------------------
#error "8064918: call analysis failed (funcsize=137)"

//----- (08064A2C) --------------------------------------------------------
int __cdecl sub_8064A2C(unsigned __int64 a1, __int64 a2)
{
  int v2; // edx
  int result; // eax
  int v4; // ebp
  int v5; // ebp
  unsigned int v6; // ebp
  unsigned __int64 v7; // rtt
  unsigned __int64 v8; // rax
  unsigned int v9; // edi
  unsigned __int64 v10; // rax
  unsigned int v11; // ecx
  unsigned int v12; // [esp+0h] [ebp-20h]
  unsigned int v13; // [esp+4h] [ebp-1Ch]
  unsigned __int64 v14; // [esp+8h] [ebp-18h]
  unsigned int v15; // [esp+10h] [ebp-10h]

  v13 = HIDWORD(a1);
  v15 = a1;
  v12 = a2;
  v14 = a1;
  if ( HIDWORD(a2) )
  {
    if ( HIDWORD(a2) > HIDWORD(a1) )
    {
      result = a1;
    }
    else
    {
      _BitScanReverse((unsigned int *)&v4, HIDWORD(a2));
      v5 = v4 ^ 0x1F;
      if ( v5 )
      {
        v13 = v12 >> (32 - v5);
        v13 |= HIDWORD(a2) << v5;
        LODWORD(v14) = v12 << v5;
        HIDWORD(v8) = HIDWORD(a1) >> (32 - v5);
        LODWORD(v8) = (HIDWORD(a1) << (char)&v12) | (v15 >> (32 - v5));
        HIDWORD(v14) = v15 << (char)&v12;
        v9 = v8 % v13;
        v10 = (v12 << v5) * (unsigned __int64)(unsigned int)(v8 / v13);
        v12 = HIDWORD(v10);
        v11 = v10;
        if ( v9 < HIDWORD(v10) || HIDWORD(v14) < (unsigned int)v10 && v9 == HIDWORD(v10) )
        {
          HIDWORD(v10) = v12;
          HIDWORD(v10) = (v10 - __PAIR__(v13, (unsigned int)v14)) >> 32;
          v11 = v10 - v14;
        }
        result = ((__PAIR__(v9, HIDWORD(v14)) - __PAIR__(HIDWORD(v10), v11)) >> 32 << (32 - (unsigned __int8)v5)) | ((HIDWORD(v14) - v11) >> (char)&v12);
      }
      else
      {
        if ( v12 <= (unsigned int)v14 || HIDWORD(a2) < HIDWORD(v14) )
          v14 = __PAIR__(v13, (unsigned int)a1) - a2;
        result = v14;
      }
    }
  }
  else
  {
    if ( (unsigned int)a2 <= HIDWORD(a1) )
    {
      v6 = a2;
      if ( !(_DWORD)a2 )
        v6 = 1 / 0u;
      LODWORD(v7) = a1;
      HIDWORD(v7) = v13 % v6;
      v2 = v7 % v6;
    }
    else
    {
      v2 = a1 % (unsigned int)a2;
    }
    result = v2;
  }
  return result;
}

//----- (08064C41) --------------------------------------------------------
int __cdecl sub_8064C41(int a1)
{
  return __cxa_atexit(a1, 0, dword_80712C0);
}
// 80497B0: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 80712C0: using guessed type int dword_80712C0;

//----- (08064C92) --------------------------------------------------------
int __cdecl sub_8064C92(int a1, int a2)
{
  return __xstat64(3, a1, a2);
}
// 8049AE0: using guessed type int __cdecl __xstat64(_DWORD, _DWORD, _DWORD);

//----- (08064CE1) --------------------------------------------------------
int __cdecl sub_8064CE1(int a1, int a2)
{
  return __fxstat64(3, a1, a2);
}
// 8049730: using guessed type int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD);

//----- (08064D30) --------------------------------------------------------
int __cdecl sub_8064D30(int a1, int a2)
{
  return __lxstat64(3, a1, a2);
}
// 8049AF0: using guessed type int __cdecl __lxstat64(_DWORD, _DWORD, _DWORD);

//----- (08064E79) --------------------------------------------------------
#error "8064E7F: positive sp value has been found (funcsize=0)"

//----- (08064EEB) --------------------------------------------------------
#error "8064EF1: positive sp value has been found (funcsize=0)"

//----- (08064F57) --------------------------------------------------------
#error "8064F5D: positive sp value has been found (funcsize=0)"

//----- (08064FC3) --------------------------------------------------------
#error "8064FC9: positive sp value has been found (funcsize=0)"

//----- (08065037) --------------------------------------------------------
#error "806503D: positive sp value has been found (funcsize=0)"

//----- (080650A5) --------------------------------------------------------
#error "80650AB: positive sp value has been found (funcsize=0)"

//----- (08065115) --------------------------------------------------------
#error "806511B: positive sp value has been found (funcsize=0)"

//----- (08065187) --------------------------------------------------------
#error "806518D: positive sp value has been found (funcsize=0)"

//----- (080651FD) --------------------------------------------------------
#error "8065203: positive sp value has been found (funcsize=0)"

//----- (0806526B) --------------------------------------------------------
#error "8065271: positive sp value has been found (funcsize=0)"

//----- (08065280) --------------------------------------------------------
int (**sub_8065280())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_8070ED4;
  v1 = &off_8070ED8 - off_8070ED4;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_8070ED4[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 8070ED4: using guessed type int (*off_8070ED4[2])();
// 8070ED8: using guessed type int (*off_8070ED8)();

//----- (080652E4) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 132 decompilation failure(s) on 422 function(s)"
