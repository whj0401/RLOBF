/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8049480();
// int unsetenv(const char *name);
// int raise(int sig);
// int strcmp(const char *s1, const char *s2);
// int putc_unlocked(int c, FILE *stream);
// struct passwd *getpwuid(__uid_t uid);
// int printf(const char *format, ...);
// void longjmp(struct __jmp_buf_tag env[1], int val);
// void _exit(int status);
// int sigprocmask(int how, const sigset_t *set, sigset_t *oset);
// int dirfd(DIR *dirp);
// int __cdecl wcwidth(_DWORD); weak
// void free(void *ptr);
// uintmax_t strtoumax(const char *nptr, char **endptr, int base);
// void *memcpy(void *dest, const void *src, size_t n);
// int mbsinit(const mbstate_t *ps);
// int clock_gettime(clockid_t clock_id, struct timespec *tp);
// int tolower(int c);
// int fclose(FILE *stream);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// __sighandler_t signal(int sig, __sighandler_t handler);
// int memcmp(const void *s1, const void *s2, size_t n);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// time_t mktime(struct tm *tp);
// struct tm *localtime_r(const time_t *timer, struct tm *tp);
// int sigismember(const sigset_t *set, int signo);
// int fflush_unlocked(FILE *stream);
// int iswcntrl(wint_t wc);
// char *textdomain(const char *domainname);
// ssize_t readlink(const char *path, char *buf, size_t len);
// int fnmatch(const char *pattern, const char *name, int flags);
// int iswprint(wint_t wc);
// int ioctl(int fd, unsigned int request, ...);
// int ferror_unlocked(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD); weak
// size_t __ctype_get_mb_cur_max(void);
// char *strcpy(char *dest, const char *src);
// size_t __fpending(FILE *fp);
// size_t wcstombs(char *s, const wchar_t *pwcs, size_t n);
// int gethostname(char *name, size_t len);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// void error(int status, int errnum, const char *format, ...);
// int strcoll(const char *s1, const char *s2);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// time_t timegm(struct tm *tp);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// size_t strftime(char *s, size_t maxsize, const char *format, const struct tm *tp);
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// char *strchr(const char *s, int c);
// char *getcwd(char *buf, size_t size);
// size_t strlen(const char *s);
// int setenv(const char *name, const char *value, int replace);
// int fprintf(FILE *stream, const char *format, ...);
// int sigaddset(sigset_t *set, int signo);
// void *memset(void *s, int c, size_t n);
// int *__errno_location(void);
// __pid_t tcgetpgrp(int fd);
// int fileno(FILE *stream);
// unsigned int gnu_dev_major(unsigned __int64 dev);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// int __cdecl mempcpy(_DWORD, _DWORD, _DWORD); weak
// int sigemptyset(sigset_t *set);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// int toupper(int c);
// char *strrchr(const char *s, int c);
// size_t mbstowcs(wchar_t *pwcs, const char *s, size_t n);
// struct tm *gmtime_r(const time_t *timer, struct tm *tp);
// unsigned int gnu_dev_minor(unsigned __int64 dev);
// int sprintf(char *s, const char *format, ...);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int readdir64(void); weak
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// char *bindtextdomain(const char *domainname, const char *dirname);
// int strncmp(const char *s1, const char *s2, size_t n);
// int isatty(int fd);
// void abort(void);
// int __cdecl __xstat64(_DWORD, _DWORD, _DWORD); weak
// int __cdecl __lxstat64(_DWORD, _DWORD, _DWORD); weak
// int closedir(DIR *dirp);
// DIR *opendir(const char *name);
// struct group *getgrgid(__gid_t gid);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// void *calloc(size_t nmemb, size_t size);
// int putchar_unlocked(int c);
// int _gmon_start__(void); weak
void sub_8049BE3();
void sub_8049C00();
int sub_8049C10();
int sub_8049C80();
int sub_8049CA0();
void sub_8049CFF();
void sub_8049D1A();
int sub_8049D2A();
void sub_8049E0C();
void sub_8049E27();
signed int sub_8049E37();
void sub_8049F19();
void sub_8049F34();
int sub_8049F44();
void sub_804A026();
void sub_804A041();
int sub_804A051();
void sub_804A133();
void sub_804A14E();
int sub_804A15E();
void sub_804A240();
void sub_804A25B();
int sub_804A26B();
void sub_804A34D();
void sub_804A368();
int sub_804A378();
void sub_804A45A();
void sub_804A475();
int sub_804A485();
void sub_804A567();
void sub_804A582();
int sub_804A592();
void sub_804A710();
void sub_804A72B();
int sub_804A780();
// int __usercall sub_804A81F@<eax>(void (__cdecl *a1)(int *)@<eax>);
void sub_804A86B();
void sub_804A886();
int sub_804A896(void); // weak
int sub_804A939();
void sub_804A9C6();
void sub_804A9E1();
int sub_804A9F1();
int nullsub_3(void); // weak
int sub_804AA4F();
void sub_804AB08();
void sub_804AB23();
signed int sub_804AB33();
// int __usercall sub_804ABE5@<eax>(int (__cdecl *a1)(signed int)@<eax>);
// int __usercall sub_804AC33@<eax>(int a1@<eax>, int (__cdecl *a2)(signed int, int)@<edx>);
void sub_804ACCA();
void sub_804ACE5();
int sub_804ACF5();
void sub_804AE90();
void sub_804AEC9();
int sub_804AEF9();
void sub_804AFE9();
void sub_804B03B();
int sub_804B06D();
int __cdecl sub_804B121(int a1);
int __cdecl sub_804B134(unsigned __int8 a1);
_DWORD __cdecl sub_804B178(_DWORD); // weak
int sub_804B209();
int sub_804B238();
int __cdecl sub_804B285(_DWORD); // weak
int __cdecl sub_804B4CD(int a1, int a2);
int __cdecl sub_804B50A(int a1);
bool __cdecl sub_804B534(int a1);
int sub_804B544();
int __cdecl sub_804B552(int a1, int a2, int a3, int a4);
_DWORD sub_804B619(); // weak
int __stdcall sub_804B654(char *file); // idb
_DWORD sub_804B6E9(); // weak
_BYTE *__cdecl sub_804B851(_BYTE *a1);
void sub_804B8A4();
signed int __cdecl sub_804B954(int a1);
int sub_804BA54();
int __cdecl sub_804BCE7(int a1, _QWORD *a2);
void __cdecl sub_804BD84(void *ptr);
int __cdecl sub_804BD97(int a1);
void __cdecl sub_804BE6A(void *ptr);
// int __usercall sub_804BE9C@<eax>(int edx0@<edx>, int a2@<ecx>, int a1);
int sub_804BF3D();
int __fastcall sub_804BF5D(int a1, int a2);
int sub_804C00B(); // weak
int __cdecl sub_804C063(int a1);
int sub_804C079();
int sub_804C094(void); // weak
int __cdecl sub_804C1A9(char a1);
int sub_804C3B1();
int sub_804C3C9();
int __cdecl main(int, char **, char **); // idb
_DWORD sub_804CD5A(); // weak
int __cdecl sub_804CDF7(_DWORD); // weak
int __cdecl sub_804CF12(int errnum, char *format, struct option *longopts, int *longind, int, char *s, int, int status); // idb
int __cdecl sub_804DD1C(char *s2, size_t n, char *msgid, int category); // idb
int __fastcall sub_804E2E8(int ecx0, int edx0, int *a1, int *a2, char a3);
int sub_804E3B9(); // weak
int sub_804EA8D(); // weak
int sub_804EAC8(void); // weak
// int __usercall sub_804EB95@<eax>(int a1@<ebx>);
void sub_804F07A();
int __cdecl sub_804F13B(int a1);
int __cdecl sub_804F17A(int, char *format, int); // idb
int __cdecl sub_804F1F2(char *a1, char *a2, char a3);
// unsigned int __usercall sub_804F29F@<eax>(int a1@<ebx>, char *a2, char *a3, char a4);
int __cdecl sub_804FA25(int a1);
int __cdecl sub_804FA7A(int, char *name); // idb
int __cdecl sub_804FAC9(char *name); // idb
int __cdecl sub_804FB78(int a1);
int sub_804FBB0();
_DWORD __cdecl sub_804FBE8(_DWORD); // weak
int sub_804FCB2(void); // weak
int __cdecl sub_804FDAF(int a1);
signed int __cdecl sub_804FDE5(int a1, int a2, char a3);
_DWORD __cdecl sub_804FEC8(_DWORD, _DWORD); // weak
int __cdecl sub_804FFA3(int a1, int a2);
_BOOL4 __cdecl sub_805003C(char *s);
_DWORD __cdecl sub_80500AF(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl sub_805113F(_DWORD); // weak
int __cdecl sub_805119E(char *path, int, int); // idb
_DWORD __cdecl sub_8051207(_DWORD); // weak
// int __usercall sub_8051308@<eax>(int a1@<edx>, int a2@<ecx>, _BYTE *a3);
int __cdecl sub_805132D(char *a1, char a2);
int __cdecl sub_8051511(char *s1, char *s2); // idb
int __cdecl sub_80515CF(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD));
int __cdecl sub_805164F(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD));
int __cdecl sub_80516CF(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD));
int __cdecl sub_8051757(int a1, int a2, int (__cdecl *a3)(_DWORD, _DWORD));
int __cdecl sub_805182E(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD));
int __cdecl sub_805185C(const char **a1, const char **a2, int (__cdecl *a3)(char *));
int __cdecl sub_8052147(int a1, int a2);
int __cdecl sub_8052169(int a1, int a2);
int __cdecl sub_805218B(int a1, int a2);
int __cdecl sub_80521AD(int a1, int a2);
int __cdecl sub_80523E7(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8052409(_DWORD *a1, _DWORD *a2);
int __cdecl sub_805242B(_DWORD *a1, _DWORD *a2);
int __cdecl sub_805244D(_DWORD *a1, _DWORD *a2);
int __cdecl sub_805246F(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8052560(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8052655(const char **a1, const char **a2);
int __cdecl sub_8052677(const char **a1, const char **a2);
int __cdecl sub_8052699(const char **a1, const char **a2);
int __cdecl sub_80526BB(const char **a1, const char **a2);
int __cdecl sub_80526DD(const char **a1, const char **a2);
int __cdecl sub_805274B(const char **a1, const char **a2);
int __cdecl sub_80527CE(const char **a1, const char **a2);
int __cdecl sub_805283C(const char **a1, const char **a2);
int __cdecl sub_80528D8(char **a1, char **a2);
int __cdecl sub_80528F6(char **a1, char **a2);
int __cdecl sub_8052910(char **a1, char **a2);
int __cdecl sub_805292A(char **a1, char **a2);
int sub_8052A31();
int sub_8052A9B();
// int __usercall sub_8052C06@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>);
int __cdecl sub_8052D06(int a1, int a2, unsigned __int8 a3, int a4, int a5, int a6);
// int __usercall sub_8052D9A@<eax>(int a1@<ebx>);
int __cdecl sub_8052EAE(char *s, int, int); // idb
// int __usercall sub_8052F8B@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, unsigned __int8 a5);
// size_t __usercall sub_8053095@<eax>(int a1@<ebx>, char *a2, int a3);
// size_t __usercall sub_8053113@<eax>(int a1@<ebx>, int a2@<edx>, int a3@<ecx>, __uid_t uid);
// size_t __usercall sub_8053157@<eax>(int a1@<ebx>, __gid_t gid);
const char *__cdecl sub_805318B(int a1, unsigned int a2, int a3);
_DWORD __cdecl sub_805320E(_DWORD); // weak
void sub_8053FEA();
// int __usercall sub_8053FF2@<eax>(int a1@<ebx>, void **a2, unsigned int a3, char *a4, int a5, int a6, unsigned int *a7, _BYTE *a8);
_DWORD __cdecl sub_80545BF(_DWORD, _DWORD, _DWORD); // weak
char *__cdecl sub_80546D5(char *s, int a2);
// int __usercall sub_80547F0@<eax>(int a1@<ebx>, char *a2, int a3, int a4, int a5, char a6, int a7, char *a8);
// int __usercall sub_8054CC7@<eax>(int a1@<edx>, int a2@<ecx>, char **a3, char a4, int a5, unsigned int a6);
int sub_8054E34(void); // weak
// int __usercall sub_8054E94@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, int a4, unsigned int a5);
_DWORD __cdecl sub_80550FE(_DWORD, _DWORD, _DWORD); // weak
bool __cdecl sub_8055279(unsigned __int8 a1, int a2, int a3);
_DWORD __cdecl sub_80552DE(_DWORD); // weak
// int __usercall sub_8055344@<eax>(int a1@<edx>, int a2@<ecx>, int a3, char a4);
_DWORD __cdecl sub_80558EB(_DWORD); // weak
int __cdecl sub_8055982(_DWORD); // weak
// unsigned int __usercall sub_8055BF6@<eax>(int a1@<ebx>);
int sub_8055D3E(void); // weak
// int __usercall sub_8055EB8@<eax>(int a1@<ecx>, int a2@<ebx>, char a3);
_DWORD __cdecl sub_8055FC5(_DWORD, _DWORD); // weak
_DWORD __cdecl sub_805608D(_DWORD, _DWORD, _DWORD); // weak
unsigned int sub_8056175();
_DWORD __cdecl sub_8056397(_DWORD); // weak
void __cdecl __noreturn sub_8056638(int status); // idb
char *__cdecl sub_80569C7(char *path, int a2);
void __noreturn sub_8056BA0();
int __cdecl sub_8056BB4(char *s, int a2);
void __cdecl sub_8056D68(int a1, int a2, int a3);
int __cdecl sub_8056DFD(int a1);
int __cdecl sub_8056F3D(int a1, char *s, int a3, int a4, size_t n);
signed int __cdecl sub_8057089(signed int a1);
_BOOL4 __cdecl sub_80570CB(signed int a1);
_BOOL4 __cdecl sub_8057153(int a1);
_DWORD __cdecl sub_805729C(_DWORD); // weak
signed int __cdecl sub_80572F7(int *a1, int a2, int *a3);
// char *__usercall sub_80573B5@<eax>(int a1@<edx>, int a2@<ecx>, void *src, int a4);
int sub_8057DB6();
int sub_8057F6D(); // weak
_DWORD __cdecl sub_8057F73(_DWORD); // weak
int __cdecl sub_805802F(void *src); // idb
// _BYTE *__usercall sub_80580E7@<eax>(int edx0@<edx>, int a2@<ecx>, _BYTE *a1);
size_t __cdecl sub_805815B(char *s);
int sub_8058199();
_DWORD __cdecl sub_80581C3(_DWORD, _DWORD, _DWORD); // weak
bool __cdecl sub_805829F(int a1, int a2, int *a3);
_DWORD __cdecl sub_8058302(_DWORD); // weak
_DWORD __cdecl sub_8058477(_DWORD, _DWORD); // weak
int __cdecl sub_805871C(int a1, int a2);
_BYTE *__cdecl sub_8058796(_BYTE *a1);
int __fastcall sub_80587AE(int a1, int a2);
_BYTE *__cdecl sub_805890F(_BYTE **a1);
_DWORD __cdecl sub_8058A0D(_DWORD); // weak
signed int __cdecl sub_8058B2E(int a1, unsigned int a2, int a3, unsigned int a4);
int __cdecl sub_8058DA7(char *s1, char *s2); // idb
struct timespec *__cdecl sub_805909A(struct timespec *tp);
int __cdecl sub_80590E5(int category); // idb
int __cdecl sub_8059185(int a1);
int __cdecl sub_80591CE(int a1);
unsigned int __cdecl sub_80591DD(int a1);
int __cdecl sub_80593D4(_DWORD *a1, int a2);
_DWORD __cdecl sub_8059428(_DWORD, _DWORD); // weak
// bool __usercall sub_80597CC@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3);
_DWORD __cdecl sub_805983C(_DWORD); // weak
unsigned int __cdecl sub_80598EB(int a1, unsigned int a2);
bool __cdecl sub_8059916(int a1, int a2);
// signed int __usercall sub_8059924@<eax>(int a1@<edx>, int a2@<ecx>, int a3);
_DWORD __cdecl sub_80599FA(_DWORD, _DWORD); // weak
int sub_8059AC4();
void __cdecl sub_8059DB7(void *a1);
void *__cdecl sub_8059EE7(int a1);
int __cdecl sub_8059F22(int a1, _DWORD *a2);
int __cdecl sub_8059F65(int a1, int a2, int a3, char a4);
int __cdecl sub_805A186(_DWORD *a1, int *a2, char a3);
signed int __cdecl sub_805A3FC(int *a1, int a2);
_DWORD __cdecl sub_805A624(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_805A957(int a1, int a2);
_DWORD sub_805A9AF(); // weak
int __cdecl sub_805A9D3(int a1, int a2, int a3);
int __fastcall sub_805AC15(int ecx0, int a2, int a1);
int sub_805ACBA(); // weak
int sub_805ACC8(); // weak
void __cdecl sub_805AEDA(void **a1);
int __cdecl sub_805AF20(int, _TBYTE); // idb
int __cdecl sub_805B0AA(int, size_t n, int, int); // idb
_DWORD __cdecl sub_805B1E2(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_805BE5B(size_t n, int, int); // idb
__int64 sub_805C007();
// int __usercall sub_805C041@<eax>(int a1@<ebx>, char *s, int a3, int a4);
// int __usercall sub_805C1AE@<eax>(int a1@<ebx>, char *s, int a3, int a4);
// int __usercall sub_805C219@<eax>(int a1@<edx>, int a2@<ecx>, __uid_t uid);
int __cdecl sub_805C462(__gid_t gid); // idb
_DWORD __cdecl sub_805C6C8(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_805C81F(__int64 a1, int a2);
int __cdecl sub_805C8CD(wint_t *a1);
int __cdecl sub_805C914(_DWORD *a1, unsigned int a2);
_BYTE *__cdecl sub_805C984(_BYTE *a1, unsigned int a2, int a3);
int __cdecl sub_805C9B9(char *s, int, int, int, int, int); // idb
// int __usercall sub_805CF15@<eax>(int a1@<ebx>, char *s, int a3);
// int __usercall sub_805CF3E@<eax>(int a1@<ebx>, char *a2, int a3, char a4);
void *__cdecl sub_805D254(int a1, int a2, void *dest, int a4);
int __cdecl sub_805D3EE(int, int, void *dest, int); // idb
int __cdecl sub_805D687(int a1, int a2, int a3);
int __cdecl sub_805D6CF(int a1, int a2, int a3);
int __cdecl sub_805D72D(int a1, int a2, int a3);
int __cdecl sub_805D76D(int a1, int a2);
int __cdecl sub_805D7D8(int a1, int a2, int a3, int a4, int a5, int a6);
_DWORD __cdecl sub_805D847(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_8060944(char *s); // idb
void *__cdecl sub_8060A56(void *src);
_DWORD __cdecl sub_8060A9C(_DWORD); // weak
_DWORD __cdecl sub_8060AE5(_DWORD, _DWORD); // weak
int __cdecl sub_8060B3A(int *a1, unsigned __int8 a2, char a3);
_DWORD *__stdcall sub_8060CAE(int a1);
// const char *__usercall sub_8060D62@<eax>(int a1@<ebx>, char *msgid, int a3);
_DWORD __cdecl sub_8060ECE(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_8061EBA(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_8061FA9(int a1, int a2, _DWORD *a3, int *a4);
_DWORD __cdecl sub_8062180(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_806241B(int a1, int a2);
int __cdecl sub_8062449(int a1, int a2, int a3);
int __cdecl sub_80624F2(int a1, int a2, int a3);
int __cdecl sub_8062544(int a1, int a2, int a3, int a4);
int __cdecl sub_8062581(_DWORD, _DWORD); // weak
int __cdecl sub_80625A5(int a1, int a2, int a3);
int __cdecl sub_8062609(int a1, int a2, unsigned __int8 a3);
int __cdecl sub_80626C7(int a1, unsigned __int8 a2);
int __cdecl sub_8062700(int a1);
int __cdecl sub_8062745(int a1, int a2, int a3);
int __cdecl sub_80627FA(int a1, int a2, int a3, int a4);
int __cdecl sub_806284A(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_806298D(int a1, int a2, int a3);
int __cdecl sub_80629EC(int a1, int a2);
int __cdecl sub_8062A30(int a1);
// int __usercall sub_8062A4F@<eax>(int a1@<edx>, int a2@<ecx>, void *src, void *a4);
void sub_8062C85();
signed int sub_8062CF4();
signed int sub_8062D16();
// _DWORD *__userpurge sub_8062E50@<eax>(_DWORD *a1, int a2);
// _DWORD *__userpurge sub_8062E8B@<eax>(_DWORD *a1, int a2);
// _DWORD *__userpurge sub_8062EC8@<eax>(_DWORD *a1, int a2);
int __cdecl sub_8062F71(int a1, int a2, int a3, int a4);
int __cdecl sub_80630AC(FILE *stream, int, int, int, int, int); // idb
int __cdecl sub_806371F(FILE *stream, int, int, int, int); // idb
int sub_8063799(FILE *stream, int a2, int a3, int a4, ...);
int __cdecl sub_806384D(unsigned int a1, unsigned int a2);
void *__cdecl sub_806388B(void *ptr, int a2, int a3);
void *__cdecl sub_80638D0(void *ptr, int a2, int a3);
int __cdecl sub_8063987(size_t size); // idb
int __cdecl sub_806399E(size_t size); // idb
void *__cdecl sub_80639FF(void *ptr, size_t size);
void *__cdecl sub_8063A4E(void *ptr, int a2);
void *__cdecl sub_8063B08(void *src, size_t n);
void *__cdecl sub_8063B31(char *s);
void __noreturn sub_8063B5E();
// int __usercall sub_8063BA5@<eax>(int a1@<ebx>, char *nptr, int base, int a4, int a5, int a6, int a7, char *s, int a9, int status);
char *sub_8063E3D();
char *sub_8063E7A();
signed int __cdecl sub_8063FB2(unsigned int *a1, unsigned int a2);
int __cdecl sub_806400A(unsigned int *a1, unsigned int a2, int a3);
int __cdecl sub_8064055(char *nptr, int, int base, int, char *s); // idb
_DWORD __cdecl sub_80644EB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
void __cdecl __noreturn sub_80645FE(int a1, int a2, char a3, int a4, int a5);
int __cdecl sub_8064651(int, char *); // idb
int __cdecl sub_8064701(int, char *, int); // idb
// int __usercall sub_8064797@<eax>(char *a1@<eax>, int a2@<ebx>, char *nptr, int a4, int base, int a6, char *s);
int __fastcall sub_8064D1A(int ecx0, int a2, int a1);
int sub_8064DBF(); // weak
int __cdecl sub_8064E3E(int a1, int a2);
int __cdecl sub_8064E7C(int a1, int a2);
int __fastcall sub_8064EFE(int a1, int a2, int *a3, int a4, signed int a5);
int sub_806502C(); // weak
_DWORD __cdecl sub_80650B3(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl sub_8065193(_DWORD, _DWORD); // weak
int __cdecl sub_806554E(int a1, int a2);
_BOOL4 __cdecl sub_8065586(_DWORD *a1, _DWORD *a2);
char *__cdecl sub_806564A(void *dest, void *src, size_t n);
int __cdecl sub_8065676(char *s); // idb
_DWORD __cdecl sub_806573D(_DWORD, _DWORD); // weak
int __cdecl sub_8065940(void *ptr); // idb
char *sub_806599A();
int __cdecl sub_80659AE(char *value); // idb
_DWORD __cdecl sub_8065A13(_DWORD); // weak
signed int sub_8065A6D();
int __cdecl sub_8065B5C(void *ptr); // idb
struct tm *__cdecl sub_8065C0B(int a1, time_t *timer, struct tm *tp);
int __cdecl sub_8065CB8(int, struct tm *tp); // idb
int __cdecl sub_8065F03(int a1, char a2);
int __cdecl sub_806603E(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_80660DA(FILE *fp); // idb
void __cdecl __noreturn sub_8066184(void *src); // idb
unsigned int sub_80661C1();
// int __usercall sub_806622B@<eax>(int a1@<ebx>);
// const char *__usercall sub_806691A@<eax>(int a1@<ebx>);
int __cdecl sub_80669D1(FILE *stream); // idb
int __cdecl sub_8066A98(FILE *stream); // idb
int __cdecl sub_8066AD1(_DWORD); // weak
int __cdecl sub_8066B48(FILE *stream, int, int, int); // idb
int __cdecl sub_8066C8F(int a1, int a2, int a3, int a4);
int sub_8066D60(); // weak
int sub_8066D6E(); // weak
_DWORD __cdecl sub_8066FB5(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_806721A(int, int, char *, int); // idb
_DWORD __cdecl sub_806739B(__int64, _DWORD, _DWORD); // weak
int __cdecl sub_80675B7(int a1);
int __cdecl sub_80675EA(int a1, int a2);
int __cdecl sub_806761D(int a1, int a2);
int __cdecl sub_806766C(int a1, int a2);
int __stdcall sub_8067813(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __fastcall sub_806787F(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
int __stdcall sub_806790C(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __fastcall sub_8067999(_DWORD, _DWORD, _DWORD);
int __fastcall sub_8067A7F(_DWORD, _DWORD); // weak
int __stdcall sub_8067B12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_8067B80(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_8067BEE(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __fastcall sub_8067C60(_DWORD, _DWORD, _DWORD);
int __stdcall sub_8067D38(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_8067DA4(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (**sub_8067DC0())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_804B90C; // weak
_UNKNOWN loc_804B924; // weak
_UNKNOWN locret_804BA4E; // weak
_UNKNOWN loc_804BAFF; // weak
_UNKNOWN loc_804BD6E; // weak
_UNKNOWN loc_804BD75; // weak
_UNKNOWN loc_804BEF1; // weak
_UNKNOWN loc_804BF03; // weak
_UNKNOWN locret_804C061; // weak
_UNKNOWN loc_804C1E0; // weak
_UNKNOWN loc_804C2D1; // weak
_UNKNOWN loc_804C2D8; // weak
_UNKNOWN loc_804C323; // weak
_UNKNOWN loc_804EBCB; // weak
_UNKNOWN loc_804EBD5; // weak
_UNKNOWN loc_804ED01; // weak
_UNKNOWN loc_804ED21; // weak
_UNKNOWN loc_804EDE6; // weak
_UNKNOWN loc_804EE01; // weak
_UNKNOWN loc_804EF43; // weak
_UNKNOWN loc_804EF95; // weak
_UNKNOWN loc_804EFA3; // weak
_UNKNOWN loc_804EFE9; // weak
_UNKNOWN loc_804F022; // weak
_UNKNOWN loc_804F06D; // weak
_UNKNOWN loc_804F074; // weak
_UNKNOWN loc_804F258; // weak
_UNKNOWN loc_804F265; // weak
_UNKNOWN loc_804F722; // weak
_UNKNOWN loc_804F7C4; // weak
_UNKNOWN loc_804F7D5; // weak
_UNKNOWN loc_804F83A; // weak
_UNKNOWN loc_804FB4B; // weak
_UNKNOWN loc_804FB67; // weak
_UNKNOWN loc_80513FF; // weak
_UNKNOWN loc_8051420; // weak
_UNKNOWN loc_805147D; // weak
_UNKNOWN loc_80514FD; // weak
_UNKNOWN loc_80517C5; // weak
_UNKNOWN loc_80517C9; // weak
_UNKNOWN loc_805180C; // weak
_UNKNOWN loc_8051824; // weak
_UNKNOWN loc_80518D1; // weak
_UNKNOWN loc_80518D6; // weak
_UNKNOWN loc_80518FA; // weak
_UNKNOWN loc_80518FF; // weak
_UNKNOWN locret_80527CC; // weak
_UNKNOWN loc_80528B5; // weak
_UNKNOWN loc_80528BC; // weak
_UNKNOWN locret_80528D6; // weak
_UNKNOWN loc_8052B2B; // weak
_UNKNOWN loc_8052B30; // weak
_UNKNOWN loc_805407A; // weak
_UNKNOWN loc_8054086; // weak
_UNKNOWN loc_8054163; // weak
_UNKNOWN loc_80541F2; // weak
_UNKNOWN loc_805425C; // weak
_UNKNOWN loc_805426B; // weak
_UNKNOWN loc_805439C; // weak
_UNKNOWN loc_80543B1; // weak
_UNKNOWN loc_805442D; // weak
_UNKNOWN loc_805456B; // weak
_UNKNOWN loc_805457D; // weak
_UNKNOWN loc_8054736; // weak
_UNKNOWN loc_805474B; // weak
_UNKNOWN loc_805490E; // weak
_UNKNOWN loc_8054932; // weak
_UNKNOWN loc_8054966; // weak
_UNKNOWN loc_80549FA; // weak
_UNKNOWN loc_8054A1C; // weak
_UNKNOWN loc_8054AD2; // weak
_UNKNOWN loc_8054C7E; // weak
_UNKNOWN loc_8054C9A; // weak
_UNKNOWN loc_8054D3E; // weak
_UNKNOWN loc_8054D4E; // weak
_UNKNOWN loc_8054F43; // weak
_UNKNOWN loc_8054FD0; // weak
_UNKNOWN loc_805500E; // weak
_UNKNOWN loc_805504D; // weak
_UNKNOWN loc_80553C0; // weak
_UNKNOWN loc_80553C8; // weak
_UNKNOWN loc_80554CE; // weak
_UNKNOWN loc_8055565; // weak
_UNKNOWN loc_805557C; // weak
_UNKNOWN loc_80555AF; // weak
_UNKNOWN loc_80555B8; // weak
_UNKNOWN loc_80556CD; // weak
_UNKNOWN loc_80556D6; // weak
_UNKNOWN loc_8055732; // weak
_UNKNOWN loc_80557D2; // weak
_UNKNOWN loc_805586E; // weak
_UNKNOWN loc_805588D; // weak
_UNKNOWN loc_80558B5; // weak
_UNKNOWN loc_8055F3F; // weak
_UNKNOWN loc_8055F60; // weak
_UNKNOWN loc_80569B4; // weak
_UNKNOWN loc_8056A07; // weak
_UNKNOWN loc_8056ABB; // weak
_UNKNOWN loc_8056B0C; // weak
_UNKNOWN loc_8056B32; // weak
_UNKNOWN locret_8056B9E; // weak
_UNKNOWN loc_8056CB3; // weak
_UNKNOWN loc_8056D39; // weak
_UNKNOWN loc_8056E35; // weak
_UNKNOWN loc_8056F22; // weak
_UNKNOWN loc_8057499; // weak
_UNKNOWN loc_8057570; // weak
_UNKNOWN loc_8057619; // weak
_UNKNOWN loc_805767E; // weak
_UNKNOWN loc_8057683; // weak
_UNKNOWN loc_8057D34; // weak
_UNKNOWN loc_8057D42; // weak
_UNKNOWN loc_8057DE7; // weak
_UNKNOWN loc_8057EFF; // weak
_UNKNOWN loc_8057F29; // weak
_UNKNOWN loc_8057F36; // weak
_UNKNOWN loc_8057F60; // weak
_UNKNOWN loc_805814C; // weak
_UNKNOWN loc_8058853; // weak
_UNKNOWN loc_8058962; // weak
_UNKNOWN loc_8058987; // weak
_UNKNOWN loc_80589DD; // weak
_UNKNOWN loc_8058BB9; // weak
_UNKNOWN loc_8058C6F; // weak
_UNKNOWN loc_8058D4C; // weak
_UNKNOWN loc_8058D68; // weak
_UNKNOWN locret_8058DA5; // weak
_UNKNOWN loc_8058EBB; // weak
_UNKNOWN loc_8058F31; // weak
_UNKNOWN loc_8058F3B; // weak
_UNKNOWN locret_8059098; // weak
_UNKNOWN loc_805980F; // weak
_UNKNOWN locret_80599F8; // weak
_UNKNOWN loc_8059B12; // weak
_UNKNOWN loc_8059B1C; // weak
_UNKNOWN loc_8059DEE; // weak
_UNKNOWN loc_8059E1A; // weak
_UNKNOWN loc_8059E41; // weak
_UNKNOWN loc_8059E50; // weak
_UNKNOWN loc_8059FD0; // weak
_UNKNOWN loc_8059FDA; // weak
_UNKNOWN loc_805A30C; // weak
_UNKNOWN loc_805A311; // weak
_UNKNOWN loc_805A3E6; // weak
_UNKNOWN loc_805A525; // weak
_UNKNOWN loc_805A586; // weak
_UNKNOWN locret_805A9AD; // weak
_UNKNOWN loc_805AA3F; // weak
_UNKNOWN loc_805AC10; // weak
_UNKNOWN loc_805C230; // weak
_UNKNOWN loc_805C26E; // weak
_UNKNOWN loc_805C308; // weak
_UNKNOWN loc_805C310; // weak
_UNKNOWN loc_805C4D1; // weak
_UNKNOWN loc_805C4D8; // weak
_UNKNOWN loc_805CFE6; // weak
_UNKNOWN loc_805CFEE; // weak
_UNKNOWN loc_805D0FD; // weak
_UNKNOWN loc_805D102; // weak
_UNKNOWN loc_805D16C; // weak
_UNKNOWN loc_805D216; // weak
_UNKNOWN loc_805D241; // weak
_UNKNOWN loc_80609CC; // weak
_UNKNOWN loc_8060A44; // weak
_UNKNOWN loc_8060DD4; // weak
_UNKNOWN loc_8060E97; // weak
_UNKNOWN loc_8060E9E; // weak
_UNKNOWN loc_8061EE7; // weak
_UNKNOWN loc_8063D07; // weak
_UNKNOWN loc_8063D2F; // weak
_UNKNOWN loc_8063D4E; // weak
_UNKNOWN loc_8063D8E; // weak
_UNKNOWN loc_8063DBD; // weak
_UNKNOWN loc_8063E8E; // weak
_UNKNOWN loc_8063EF8; // weak
_UNKNOWN loc_8063F16; // weak
_UNKNOWN loc_8064043; // weak
_UNKNOWN loc_80640E7; // weak
_UNKNOWN loc_8064285; // weak
_UNKNOWN loc_806428C; // weak
_UNKNOWN loc_80644A9; // weak
_UNKNOWN locret_80644E9; // weak
_UNKNOWN loc_80647CF; // weak
_UNKNOWN loc_80647FA; // weak
_UNKNOWN loc_806481C; // weak
_UNKNOWN loc_8064860; // weak
_UNKNOWN loc_80648B2; // weak
_UNKNOWN loc_806490E; // weak
_UNKNOWN loc_8064989; // weak
_UNKNOWN loc_80649CE; // weak
_UNKNOWN loc_8064A05; // weak
_UNKNOWN loc_8064D07; // weak
_UNKNOWN locret_8064D18; // weak
_UNKNOWN loc_8064DC5; // weak
_UNKNOWN loc_8064F30; // weak
_UNKNOWN loc_8064F46; // weak
_UNKNOWN loc_8065033; // weak
_UNKNOWN loc_8065AFF; // weak
_UNKNOWN loc_8065B06; // weak
_UNKNOWN locret_8065CB6; // weak
_UNKNOWN locret_8065D94; // weak
_UNKNOWN loc_80660A5; // weak
_UNKNOWN loc_806613E; // weak
_UNKNOWN loc_806617D; // weak
_UNKNOWN loc_8066322; // weak
_UNKNOWN loc_8066356; // weak
_UNKNOWN loc_806635B; // weak
_UNKNOWN loc_80663AA; // weak
_UNKNOWN loc_806642B; // weak
_UNKNOWN loc_806645B; // weak
_UNKNOWN loc_806646A; // weak
_UNKNOWN locret_8066C89; // weak
char locale = '\0'; // idb
char *off_8069278 = &unk_8069218; // idb
_UNKNOWN unk_80692E1; // weak
char aQHideControlCh[444] = "  -q, --hide-control-chars   print ? instead of nongraphic characters\n      --show-control-chars   show nongraphic characters as-is (the default,\n                               unless program is 'ls' and output is a terminal)\n  -Q, --quote-name           enclose entry names in double quotes\n      --quoting-style=WORD   use quoting style WORD for entry names:\n                               literal, locale, shell, shell-always,\n              "; // idb
char aTimeStyleStyle[391] = "      --time-style=STYLE     with -l, show times using style STYLE:\n                               full-iso, long-iso, iso, locale, or +FORMAT;\n                               FORMAT is interpreted like in 'date'; if FORMAT\n                               is FORMAT1<newline>FORMAT2, then FORMAT1 applies\n                               to non-recent files and FORMAT2 to recent files;\n        "; // idb
int sig[12] = { 20, 14, 1, 2, 13, 3, 15, 29, 27, 26, 24, 25 }; // idb
_UNKNOWN unk_806C660; // weak
char *off_806C734[2] = { "human-readable", "si" }; // weak
int dword_806C740[2] = { 176, 144 }; // idb
_UNKNOWN unk_806C7C4; // weak
char *off_806CA98[10] =
{
  "literal",
  "shell",
  "shell-always",
  "shell-escape",
  "shell-escape-always",
  "c",
  "c-maybe",
  "escape",
  "locale",
  "clocale"
}; // weak
int dword_806CAD8[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; // idb
_UNKNOWN unk_806CB0A; // weak
_UNKNOWN unk_806CB1D; // weak
_UNKNOWN unk_806D673; // weak
int dword_806DEF8 = 12028; // weak
_UNKNOWN unk_806F40C; // weak
_UNKNOWN unk_806F40F; // weak
_UNKNOWN unk_8070434; // weak
_UNKNOWN unk_8070437; // weak
_UNKNOWN unk_8071470; // weak
_UNKNOWN unk_8071473; // weak
int (*off_8073EC8[2])() = { &sub_8049CA0, &sub_8049C80 }; // weak
int (*off_8073ECC)() = &sub_8049C80; // weak
int (*dword_8074008)(void) = NULL; // weak
int dword_80741DC = 0; // weak
int dword_80741F0 = 0; // weak
int dword_8074210 = 0; // weak
int dword_8074224 = 0; // weak
int dword_8074238 = 0; // weak
int dword_807424C = 0; // weak
int dword_8074260 = 0; // weak
int dword_8074270 = 0; // weak
int (__fastcall *dword_8074274)(_DWORD, _DWORD) = NULL; // weak
int dword_8074288 = 0; // weak
int dword_807429C = 0; // weak
int dword_80742B0 = 0; // weak
int dword_80742C4 = 0; // weak
int dword_80742F4 = 0; // weak
int dword_8074330[] = { 2 }; // weak
void *s1 = &unk_80692DC; // idb
int dword_8074338 = 1; // weak
int dword_8074368 = 5; // weak
char *off_807436C = "01;36"; // idb
_UNKNOWN unk_80743E8; // weak
char *off_80743F0 = "%b %e  %Y"; // idb
char byte_80743F8 = '\x01'; // weak
int dword_80743FC = 4294967295; // weak
int dword_8074410[10] = { 13, 8, 11, 6, 10, 5, 7, 9, 5, 6 }; // idb
int dword_8074438 = 2; // weak
int status = 1; // idb
_UNKNOWN unk_8074470; // weak
_UNKNOWN unk_8074490; // weak
_UNKNOWN unk_8074493; // weak
_UNKNOWN unk_8074498; // weak
_UNKNOWN unk_807449B; // weak
_UNKNOWN unk_807449C; // weak
_UNKNOWN unk_807449F; // weak
_UNKNOWN unk_80744A4; // weak
_UNKNOWN unk_80744A7; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int program_invocation_name; // weak
FILE *stdout; // idb
char byte_807450C; // weak
_UNKNOWN unk_80746DE; // weak
char byte_807485B; // weak
void *dword_80749D0; // idb
void *dword_80749D4; // idb
int dword_80749DC; // weak
char byte_80749E0; // weak
char byte_80749E1; // weak
void *dword_80749E4; // idb
int dword_80749E8; // weak
char byte_80749EC; // weak
char *dword_80749F0; // idb
int dword_80749F4; // weak
char byte_8074A00; // weak
int dword_8074A04; // weak
int dword_8074A08; // weak
int dword_8074A2C; // weak
int dword_8074A34; // weak
char byte_8074A3A; // weak
char byte_8074A3B; // weak
int dword_8074A3C; // weak
__int64 qword_8074A40; // weak
char byte_8074A4C; // weak
int dword_8074A50; // weak
char byte_8074A54; // weak
char byte_8074A55; // weak
int dword_8074A58; // weak
void *ptr; // idb
char byte_8074A61; // weak
char byte_8074A68; // weak
int dword_8074A6C; // weak
int dword_8074A70; // idb
int dword_8074A74; // idb
char byte_8074A78; // weak
int dword_8074A7C; // weak
int dword_8074A80; // weak
char byte_8074A88; // weak
int dword_8074A8C; // weak
int dword_8074A90; // idb
sigset_t set; // idb
int dword_8074B30; // weak
int dword_8074B34; // weak
int dword_8074B38; // weak
void *dword_8074B3C; // idb
int dword_8074B40; // idb
int dword_8074B44; // weak
_UNKNOWN unk_8074B90; // weak
_UNKNOWN unk_8074BD0; // weak
int dword_8074BDC; // weak
char byte_8074C10[3328]; // idb
char byte_8075910; // weak
struct __jmp_buf_tag env[1]; // idb
__int64 qword_80759D0; // weak
__int64 qword_80759E0; // weak
int dword_80759E8; // weak
int dword_80759EC; // weak
char byte_80759F0; // weak
int dword_80759F4; // weak
int dword_80759FC; // weak
int dword_8075A04; // weak
int dword_8075A10; // weak
int dword_8075A14; // weak
int dword_8075A18; // weak
int dword_8075A1C; // weak
int dword_8075A20; // weak
int dword_8075A24; // weak
int dword_8075A28; // weak
int dword_8075A2C; // weak
int dword_8075A30; // weak
int dword_8075A34; // weak
int dword_8075A38; // weak
int dword_8075A3C; // weak
int dword_8075B50; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (0804945C) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 8049BA0: using guessed type int _gmon_start__(void);

//----- (08049480) --------------------------------------------------------
int sub_8049480()
{
  return dword_8074008();
}
// 8074008: using guessed type int (*dword_8074008)(void);

//----- (08049BB0) --------------------------------------------------------
#error "8049BB3: positive sp value has been found (funcsize=2)"

//----- (08049BE3) --------------------------------------------------------
void sub_8049BE3()
{
  ;
}

//----- (08049C00) --------------------------------------------------------
void sub_8049C00()
{
  ;
}

//----- (08049C10) --------------------------------------------------------
int sub_8049C10()
{
  int result; // eax

  result = &unk_80744A7 - &unk_80744A4;
  if ( (unsigned int)(&unk_80744A7 - &unk_80744A4) > 6 )
    result = 0;
  return result;
}
// 8049C10: could not find valid save-restore pair for ebp

//----- (08049C80) --------------------------------------------------------
int sub_8049C80()
{
  int result; // eax

  if ( !byte_807450C )
  {
    result = sub_8049C10();
    byte_807450C = 1;
  }
  return result;
}
// 8049C80: could not find valid save-restore pair for ebp
// 807450C: using guessed type char byte_807450C;

//----- (08049CA0) --------------------------------------------------------
int sub_8049CA0()
{
  return 0;
}
// 8049CA0: could not find valid save-restore pair for ebp

//----- (08049CFF) --------------------------------------------------------
void sub_8049CFF()
{
  ;
}

//----- (08049D1A) --------------------------------------------------------
void sub_8049D1A()
{
  ;
}

//----- (08049D2A) --------------------------------------------------------
int sub_8049D2A()
{
  int result; // eax

  result = &unk_8074493 - &unk_8074490;
  if ( (unsigned int)(&unk_8074493 - &unk_8074490) > 6 )
    result = 0;
  return result;
}
// 8049D2A: could not find valid save-restore pair for ebp

//----- (08049E0C) --------------------------------------------------------
void sub_8049E0C()
{
  ;
}

//----- (08049E27) --------------------------------------------------------
void sub_8049E27()
{
  ;
}

//----- (08049E37) --------------------------------------------------------
signed int sub_8049E37()
{
  return 3;
}
// 8049E37: could not find valid save-restore pair for ebp

//----- (08049F19) --------------------------------------------------------
void sub_8049F19()
{
  ;
}

//----- (08049F34) --------------------------------------------------------
void sub_8049F34()
{
  ;
}

//----- (08049F44) --------------------------------------------------------
int sub_8049F44()
{
  int result; // eax

  result = &unk_8071473 - &unk_8071470;
  if ( (unsigned int)(&unk_8071473 - &unk_8071470) > 6 )
    result = 0;
  return result;
}
// 8049F44: could not find valid save-restore pair for ebp

//----- (0804A026) --------------------------------------------------------
void sub_804A026()
{
  ;
}

//----- (0804A041) --------------------------------------------------------
void sub_804A041()
{
  ;
}

//----- (0804A051) --------------------------------------------------------
int sub_804A051()
{
  int result; // eax

  result = &unk_8074493 - &unk_8074490;
  if ( (unsigned int)(&unk_8074493 - &unk_8074490) > 6 )
    result = 0;
  return result;
}
// 804A051: could not find valid save-restore pair for ebp

//----- (0804A133) --------------------------------------------------------
void sub_804A133()
{
  ;
}

//----- (0804A14E) --------------------------------------------------------
void sub_804A14E()
{
  ;
}

//----- (0804A15E) --------------------------------------------------------
int sub_804A15E()
{
  int result; // eax

  result = &unk_8074493 - &unk_8074490;
  if ( (unsigned int)(&unk_8074493 - &unk_8074490) > 6 )
    result = 0;
  return result;
}
// 804A15E: could not find valid save-restore pair for ebp

//----- (0804A240) --------------------------------------------------------
void sub_804A240()
{
  ;
}

//----- (0804A25B) --------------------------------------------------------
void sub_804A25B()
{
  ;
}

//----- (0804A26B) --------------------------------------------------------
int sub_804A26B()
{
  int result; // eax

  result = &unk_8070437 - &unk_8070434;
  if ( (unsigned int)(&unk_8070437 - &unk_8070434) > 6 )
    result = 0;
  return result;
}
// 804A26B: could not find valid save-restore pair for ebp

//----- (0804A34D) --------------------------------------------------------
void sub_804A34D()
{
  ;
}

//----- (0804A368) --------------------------------------------------------
void sub_804A368()
{
  ;
}

//----- (0804A378) --------------------------------------------------------
int sub_804A378()
{
  int result; // eax

  result = &unk_80746DE - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_80746DE - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 804A378: could not find valid save-restore pair for ebp
// 80744C0: using guessed type int program_invocation_short_name;

//----- (0804A45A) --------------------------------------------------------
void sub_804A45A()
{
  ;
}

//----- (0804A475) --------------------------------------------------------
void sub_804A475()
{
  ;
}

//----- (0804A485) --------------------------------------------------------
int sub_804A485()
{
  int result; // eax

  result = &unk_806F40F - &unk_806F40C;
  if ( (unsigned int)(&unk_806F40F - &unk_806F40C) > 6 )
    result = 0;
  return result;
}
// 804A485: could not find valid save-restore pair for ebp

//----- (0804A567) --------------------------------------------------------
void sub_804A567()
{
  ;
}

//----- (0804A582) --------------------------------------------------------
void sub_804A582()
{
  ;
}

//----- (0804A592) --------------------------------------------------------
int sub_804A592()
{
  int result; // eax

  result = &unk_8074493 - &unk_8074490;
  if ( (unsigned int)(&unk_8074493 - &unk_8074490) > 6 )
    result = 0;
  return result;
}
// 804A592: could not find valid save-restore pair for ebp

//----- (0804A710) --------------------------------------------------------
void sub_804A710()
{
  ;
}

//----- (0804A72B) --------------------------------------------------------
void sub_804A72B()
{
  ;
}

//----- (0804A73B) --------------------------------------------------------
#error "804A768: call analysis failed (funcsize=23)"

//----- (0804A780) --------------------------------------------------------
int sub_804A780()
{
  return 0;
}
// 804A780: could not find valid save-restore pair for ebp

//----- (0804A81F) --------------------------------------------------------
int __usercall sub_804A81F@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  a1(&dword_806DEF8);
  return sub_804A780();
}
// 806DEF8: using guessed type int dword_806DEF8;

//----- (0804A86B) --------------------------------------------------------
void sub_804A86B()
{
  ;
}

//----- (0804A886) --------------------------------------------------------
void sub_804A886()
{
  ;
}

//----- (0804A896) --------------------------------------------------------
#error "804A8C3: call analysis failed (funcsize=23)"

//----- (0804A939) --------------------------------------------------------
int sub_804A939()
{
  int result; // eax

  result = sub_804A896();
  byte_807485B = 1;
  return result;
}
// 804A896: using guessed type int sub_804A896(void);
// 807485B: using guessed type char byte_807485B;

//----- (0804A9C6) --------------------------------------------------------
void sub_804A9C6()
{
  ;
}

//----- (0804A9E1) --------------------------------------------------------
void sub_804A9E1()
{
  ;
}

//----- (0804A9F1) --------------------------------------------------------
int sub_804A9F1()
{
  int result; // eax

  result = &unk_8074493 - &unk_8074490;
  if ( (unsigned int)(&unk_8074493 - &unk_8074490) > 6 )
    result = 0;
  return result;
}
// 804A9F1: could not find valid save-restore pair for ebp

//----- (0804AA4F) --------------------------------------------------------
int sub_804AA4F()
{
  return nullsub_3();
}
// 804AA4F: could not find valid save-restore pair for ebp
// 804AA4E: using guessed type int nullsub_3(void);

//----- (0804AABC) --------------------------------------------------------
#error "804AA49: call analysis failed (funcsize=23)"

//----- (0804AB08) --------------------------------------------------------
void sub_804AB08()
{
  ;
}

//----- (0804AB23) --------------------------------------------------------
void sub_804AB23()
{
  ;
}

//----- (0804AB33) --------------------------------------------------------
signed int sub_804AB33()
{
  return 3;
}
// 804AB33: could not find valid save-restore pair for ebx
// 8074270: using guessed type int dword_8074270;
// 8074274: using guessed type int (__fastcall *dword_8074274)(_DWORD, _DWORD);

//----- (0804ABE5) --------------------------------------------------------
int __usercall sub_804ABE5@<eax>(int (__cdecl *a1)(signed int)@<eax>)
{
  return a1(134665128);
}

//----- (0804AC33) --------------------------------------------------------
int __usercall sub_804AC33@<eax>(int a1@<eax>, int (__cdecl *a2)(signed int, int)@<edx>)
{
  return a2(134665128, a1);
}

//----- (0804ACCA) --------------------------------------------------------
void sub_804ACCA()
{
  ;
}

//----- (0804ACE5) --------------------------------------------------------
void sub_804ACE5()
{
  ;
}

//----- (0804ACF5) --------------------------------------------------------
int sub_804ACF5()
{
  int result; // eax

  result = "                       if STYLE is prefixed with 'posix-', STYLE\n"
           "                               takes effect only outside the POSIX locale\n"
         - &aTimeStyleStyle[388];
  if ( (unsigned int)("                       if STYLE is prefixed with 'posix-', STYLE\n"
                      "                               takes effect only outside the POSIX locale\n"
                    - &aTimeStyleStyle[388]) > 6 )
    result = 0;
  return result;
}
// 804ACF5: could not find valid save-restore pair for ebp

//----- (0804ADD3) --------------------------------------------------------
#error "804ADF0: call analysis failed (funcsize=19)"

//----- (0804AE90) --------------------------------------------------------
void sub_804AE90()
{
  ;
}

//----- (0804AEC9) --------------------------------------------------------
void sub_804AEC9()
{
  ;
}

//----- (0804AEF9) --------------------------------------------------------
int sub_804AEF9()
{
  int result; // eax

  result = &unk_807449B - &unk_8074498;
  if ( (unsigned int)(&unk_807449B - &unk_8074498) > 6 )
    result = 0;
  return result;
}
// 804AEF9: could not find valid save-restore pair for ebp

//----- (0804AFE9) --------------------------------------------------------
void sub_804AFE9()
{
  ;
}

//----- (0804B03B) --------------------------------------------------------
void sub_804B03B()
{
  ;
}

//----- (0804B06D) --------------------------------------------------------
int sub_804B06D()
{
  int result; // eax

  result = &unk_807449F - &unk_807449C;
  if ( (unsigned int)(&unk_807449F - &unk_807449C) > 6 )
    result = 0;
  return result;
}
// 804B06D: could not find valid save-restore pair for ebp

//----- (0804B121) --------------------------------------------------------
int __cdecl sub_804B121(int a1)
{
  int result; // eax

  if ( a1 != 1 )
  {
    result = a1;
    status = a1;
  }
  return result;
}

//----- (0804B134) --------------------------------------------------------
int __cdecl sub_804B134(unsigned __int8 a1)
{
  return a1;
}

//----- (0804B178) --------------------------------------------------------
#error "804B1EC: call analysis failed (funcsize=49)"

//----- (0804B209) --------------------------------------------------------
int sub_804B209()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nMandatory arguments to long options are mandatory for short options too.\n");
  return fputs_unlocked(v1, v0);
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804B238) --------------------------------------------------------
int sub_804B238()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext(
         "\n"
         "The SIZE argument is an integer and optional unit (example: 10K is 10*1024).\n"
         "Units are K,M,G,T,P,E,Z,Y (powers of 1024) or KB,MB,... (powers of 1000).\n");
  return fputs_unlocked(v1, v0);
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804B285) --------------------------------------------------------
#error "804B341: call analysis failed (funcsize=59)"

//----- (0804B4CD) --------------------------------------------------------
int __cdecl sub_804B4CD(int a1, int a2)
{
  return sub_805C6C8(a1, a1 >> 31, a2);
}
// 805C6C8: using guessed type _DWORD __cdecl sub_805C6C8(_DWORD, _DWORD, _DWORD);

//----- (0804B50A) --------------------------------------------------------
int __cdecl sub_804B50A(int a1)
{
  return a1;
}

//----- (0804B534) --------------------------------------------------------
bool __cdecl sub_804B534(int a1)
{
  return a1 == 95;
}

//----- (0804B544) --------------------------------------------------------
int sub_804B544()
{
  return 0;
}

//----- (0804B552) --------------------------------------------------------
int __cdecl sub_804B552(int a1, int a2, int a3, int a4)
{
  _DWORD *v4; // ST3C_4
  int v5; // ecx
  int result; // eax

  if ( (unsigned int)(*((_DWORD *)&unk_8074BD0 + 4) - *((_DWORD *)&unk_8074BD0 + 3)) < 0x10 )
    sub_8065193(&unk_8074BD0, 16);
  *((_DWORD *)&unk_8074BD0 + 3) += 16;
  v4 = (_DWORD *)(dword_8074BDC - 16);
  v5 = dword_8074BDC - 16;
  *(_DWORD *)(v5 + 8) = a1;
  *(_DWORD *)(v5 + 12) = a2;
  result = a3;
  *v4 = a3;
  v4[1] = a4;
  return result;
}
// 8065193: using guessed type _DWORD __cdecl sub_8065193(_DWORD, _DWORD);
// 8074BDC: using guessed type int dword_8074BDC;

//----- (0804B619) --------------------------------------------------------
#error "804B64F: call analysis failed (funcsize=17)"

//----- (0804B654) --------------------------------------------------------
#error "804B6E2: positive sp value has been found (funcsize=41)"

//----- (0804B6E9) --------------------------------------------------------
#error "804B7E9: call analysis failed (funcsize=88)"

//----- (0804B851) --------------------------------------------------------
_BYTE *__cdecl sub_804B851(_BYTE *a1)
{
  int v1; // eax

  while ( *a1 )
  {
    if ( *a1 == 37 )
    {
      v1 = (char)a1[1];
      if ( v1 == 37 )
      {
        ++a1;
      }
      else if ( v1 == 98 )
      {
        return a1;
      }
    }
    ++a1;
  }
  return 0;
}

//----- (0804B8A4) --------------------------------------------------------
void sub_804B8A4()
{
  int *v0; // ebp
  int v1; // ebx
  signed int v2; // eax
  bool v3; // zf
  void *v4; // eax
  char v5; // bl
  bool v6; // al
  int v7; // [esp-8h] [ebp-30h]
  signed int v8; // [esp-4h] [ebp-2Ch]
  int v9; // [esp+0h] [ebp-28h]
  int v10; // [esp+4h] [ebp-24h]
  int v11; // [esp+8h] [ebp-20h]
  int v12; // [esp+Ch] [ebp-1Ch]
  int v13; // [esp+10h] [ebp-18h]
  int v14; // [esp+14h] [ebp-14h]
  int v15; // [esp+18h] [ebp-10h]
  int v16; // [esp+1Ch] [ebp-Ch]
  int savedregs; // [esp+28h] [ebp+0h]

  v0 = &savedregs;
  v16 = 0;
  while ( *(v0 - 3) <= 255 )
  {
    v1 = *(unsigned __int8 *)(*(v0 - 3) + 134695952);
    v9 = *(v0 - 3);
    v2 = sub_8057089(v9);
    v0 = &v9;
    v3 = (_BYTE)v2 == 0;
    v8 = v2;
    v7 = v1;
    v4 = &loc_804B90C;
    if ( !v3 )
      v4 = &loc_804B924;
    dword_8074238 = (int)v4;
    v5 = v7;
    sub_8067B80(v9, v10, v11, v12, v13, v14, v15);
    v6 = *(&v9 - 3) == 126 || *(&v9 - 3) == 45 || *(&v9 - 3) == 46 || *(&v9 - 3) == 95;
    *(_BYTE *)((*(&v9 - 3))++ + 134695952) = v5 | v6;
  }
}
// 8067B80: using guessed type int __stdcall sub_8067B80(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8074238: using guessed type int dword_8074238;

//----- (0804B954) --------------------------------------------------------
signed int __cdecl sub_804B954(int a1)
{
  int v2; // eax
  int v3; // [esp+0h] [ebp-48h]
  int v4; // [esp+4h] [ebp-44h]
  int v5; // [esp+8h] [ebp-40h]
  int v6; // [esp+Ch] [ebp-3Ch]
  int v7; // [esp+10h] [ebp-38h]
  int v8; // [esp+14h] [ebp-34h]
  int v9; // [esp+18h] [ebp-30h]
  int v10; // [esp+1Ch] [ebp-2Ch]
  int v11; // [esp+20h] [ebp-28h]
  int v12; // [esp+24h] [ebp-24h]
  int v13; // [esp+28h] [ebp-20h]
  unsigned int v14; // [esp+2Ch] [ebp-1Ch]
  int i; // [esp+30h] [ebp-18h]
  unsigned int v16; // [esp+34h] [ebp-14h]
  char *s; // [esp+38h] [ebp-10h]
  unsigned int v18; // [esp+3Ch] [ebp-Ch]

  v14 = 5;
  do
  {
    v16 = v14;
    v14 = 0;
    for ( i = 0; i <= 11; ++i )
    {
      v13 = v16;
      s = nl_langinfo(i + 131086);
      if ( strchr(s, 37) )
      {
        dword_8074224 = (int)&locret_804BA4E;
        sub_8067BEE(v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, i, v16, s);
      }
      v18 = sub_805C9B9(s, a1 + (i << 7), 128, (int)(&v3 - 8), 0, 0);
      if ( v18 > 0x7F )
        return 0;
      v2 = v14;
      if ( v13 >= v14 )
        v2 = v13;
      v14 = v2;
    }
  }
  while ( v16 > v14 );
  return 1;
}
// 8067BEE: using guessed type int __stdcall sub_8067BEE(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8074224: using guessed type int dword_8074224;

//----- (0804BA54) --------------------------------------------------------
int sub_804BA54()
{
  int result; // eax
  char *v1; // ST44_4
  int v2; // ST38_4
  int v3; // [esp+0h] [ebp-658h]
  int v4; // [esp+4h] [ebp-654h]
  int v5; // [esp+8h] [ebp-650h]
  int v6; // [esp+Ch] [ebp-64Ch]
  int v7; // [esp+10h] [ebp-648h]
  int v8; // [esp+14h] [ebp-644h]
  int v9; // [esp+18h] [ebp-640h]
  int v10; // [esp+1Ch] [ebp-63Ch]
  int v11; // [esp+20h] [ebp-638h]
  int v12; // [esp+24h] [ebp-634h]
  int v13; // [esp+28h] [ebp-630h]
  signed int i; // [esp+2Ch] [ebp-62Ch]
  int j; // [esp+30h] [ebp-628h]
  int v16; // [esp+38h] [ebp-620h]
  char *s; // [esp+40h] [ebp-618h]
  int v18; // [esp+44h] [ebp-614h]
  int v19; // [esp+48h] [ebp-610h]
  int v20; // [esp+4Ch] [ebp-60Ch]
  char v21; // [esp+50h] [ebp-608h]
  int v22; // [esp+54h] [ebp-604h]
  int v23; // [esp+58h] [ebp-600h]
  int v24; // [esp+5Ch] [ebp-5FCh]
  int v25; // [esp+60h] [ebp-5F8h]
  int v26; // [esp+64h] [ebp-5F4h]

  for ( i = 0; i <= 1; ++i )
    *(&v19 + i) = (int)sub_804B851((&off_80743F0)[i]);
  if ( v19 || (result = v20) != 0 )
  {
    result = sub_804B954((int)&v21) ^ 1;
    if ( !(_BYTE)result )
    {
      for ( j = 0; j <= 1; j = v2 + 1 )
      {
        v1 = (&off_80743F0)[j];
        dword_807424C = (int)&loc_804BAFF;
        result = sub_8067B12(
                   v3,
                   v4,
                   v5,
                   v6,
                   v7,
                   v8,
                   v9,
                   v10,
                   v11,
                   v12,
                   v13,
                   i,
                   j,
                   0,
                   v16,
                   v1,
                   s,
                   v18,
                   v19,
                   v20,
                   *(_DWORD *)&v21,
                   v22,
                   v23,
                   v24,
                   v25,
                   v26);
      }
      byte_8075910 = 1;
    }
  }
  return result;
}
// 8067B12: using guessed type int __stdcall sub_8067B12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 807424C: using guessed type int dword_807424C;
// 8075910: using guessed type char byte_8075910;

//----- (0804BC87) --------------------------------------------------------
#error "804BCCB: call analysis failed (funcsize=24)"

//----- (0804BCD0) --------------------------------------------------------
#error "804BCE4: positive sp value has been found (funcsize=0)"

//----- (0804BCE7) --------------------------------------------------------
#error "804BD69: call analysis failed (funcsize=56)"

//----- (0804BD84) --------------------------------------------------------
void __cdecl sub_804BD84(void *ptr)
{
  free(ptr);
}

//----- (0804BD97) --------------------------------------------------------
int __cdecl sub_804BD97(int a1)
{
  _DWORD *v1; // ecx
  int v2; // edx
  int v3; // ecx
  int v4; // edx
  int v6; // [esp+0h] [ebp-38h]
  int v7; // [esp+4h] [ebp-34h]
  int v8; // [esp+Ch] [ebp-2Ch]
  int v9; // [esp+10h] [ebp-28h]
  int v10; // [esp+14h] [ebp-24h]

  *(&v6 - 8) = a1;
  *(&v6 - 7) = v8;
  *(&v6 - 10) = v9;
  *(&v6 - 9) = v10;
  *(&v6 - 4) = sub_806399E(0x10u);
  v1 = (_DWORD *)*(&v6 - 4);
  v2 = *(&v6 - 9);
  *v1 = *(&v6 - 10);
  v1[1] = v2;
  v3 = *(&v6 - 4);
  v4 = *(&v6 - 7);
  *(_DWORD *)(v3 + 8) = *(&v6 - 8);
  *(_DWORD *)(v3 + 12) = v4;
  v7 = *(&v6 - 4);
  *(&v6 - 3) = sub_805A957((int)dword_80749D0, v7);
  if ( !*(&v6 - 3) )
    sub_8063B5E();
  *((_BYTE *)&v6 - 17) = *(&v6 - 3) != *(&v6 - 4);
  if ( *((_BYTE *)&v6 - 17) )
    free((void *)*(&v6 - 4));
  return *((unsigned __int8 *)&v6 - 17);
}

//----- (0804BE6A) --------------------------------------------------------
void __cdecl sub_804BE6A(void *ptr)
{
  free(*(void **)ptr);
  free(*((void **)ptr + 1));
  free(ptr);
}

//----- (0804BE9C) --------------------------------------------------------
int __usercall sub_804BE9C@<eax>(int edx0@<edx>, int a2@<ecx>, int a1)
{
  void *v3; // eax
  char v4; // al
  int v6; // [esp+18h] [ebp-10h]
  char *s1; // [esp+1Ch] [ebp-Ch]

  v6 = dword_8074330[2 * a1];
  s1 = (char *)*(&::s1 + 2 * a1);
  if ( !v6 )
    goto LABEL_12;
  v3 = &loc_804BEF1;
  if ( v6 != 1 )
    v3 = &loc_804BF03;
  dword_8074260 = (int)v3;
  sub_8067A7F(a2, edx0);
  if ( *s1 == unk_80692E1 || v6 == 2 && !strncmp(s1, "00", 2u) )
LABEL_12:
    v4 = 0;
  else
    v4 = 1;
  return v4 & 1;
}
// 8067A7F: using guessed type int __fastcall sub_8067A7F(_DWORD, _DWORD);
// 8074260: using guessed type int dword_8074260;
// 8074330: using guessed type int dword_8074330[];

//----- (0804BF3D) --------------------------------------------------------
int sub_804BF3D()
{
  sub_80558EB(dword_8074330);
  return sub_80558EB(&dword_8074338);
}
// 80558EB: using guessed type _DWORD __cdecl sub_80558EB(_DWORD);
// 8074330: using guessed type int dword_8074330[];
// 8074338: using guessed type int dword_8074338;

//----- (0804BF5D) --------------------------------------------------------
int __fastcall sub_804BF5D(int a1, int a2)
{
  int (*v2)(); // eax

  v2 = sub_804C00B;
  if ( !byte_8074A54 )
    v2 = (int (*)())&locret_804C061;
  dword_8074274 = (int (__fastcall *)(_DWORD, _DWORD))v2;
  dword_8074270 = (int)sub_804C00B;
  return ((int (__fastcall *)(int, int))v2)(a1, a2);
}
// 804C00B: using guessed type int sub_804C00B();
// 8074270: using guessed type int dword_8074270;
// 8074274: using guessed type int (__fastcall *dword_8074274)(_DWORD, _DWORD);
// 8074A54: using guessed type char byte_8074A54;

//----- (0804C063) --------------------------------------------------------
int __cdecl sub_804C063(int a1)
{
  int result; // eax

  result = dword_8074B30;
  if ( !dword_8074B30 )
  {
    result = a1;
    dword_8074B30 = a1;
  }
  return result;
}
// 8074B30: using guessed type int dword_8074B30;

//----- (0804C079) --------------------------------------------------------
int sub_804C079()
{
  int result; // eax

  result = dword_8074B30;
  if ( !dword_8074B30 )
    result = dword_8074B34++ + 1;
  return result;
}
// 8074B30: using guessed type int dword_8074B30;
// 8074B34: using guessed type int dword_8074B34;

//----- (0804C094) --------------------------------------------------------
#error "804C175: call analysis failed (funcsize=53)"

//----- (0804C188) --------------------------------------------------------
#error "804C1A8: positive sp value has been found (funcsize=0)"

//----- (0804C1A9) --------------------------------------------------------
int __cdecl sub_804C1A9(char a1)
{
  void *v1; // eax
  int result; // eax
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  int v6; // [esp+0h] [ebp-B8h]
  int v7; // [esp+0h] [ebp-B8h]
  int v8; // [esp+4h] [ebp-B4h]
  int v9; // [esp+8h] [ebp-B0h]
  int v10; // [esp+Ch] [ebp-ACh]
  int v11; // [esp+10h] [ebp-A8h]
  signed int i; // [esp+10h] [ebp-A8h]
  signed int j; // [esp+10h] [ebp-A8h]
  int (*v14)(); // [esp+14h] [ebp-A4h]
  int v15; // [esp+18h] [ebp-A0h]
  int v16; // [esp+1Ch] [ebp-9Ch]
  int v17; // [esp+20h] [ebp-98h]
  int v18; // [esp+24h] [ebp-94h]
  int v19; // [esp+28h] [ebp-90h]
  int v20; // [esp+2Ch] [ebp-8Ch]
  int v21; // [esp+30h] [ebp-88h]
  int v22; // [esp+34h] [ebp-84h]
  int v23; // [esp+38h] [ebp-80h]
  int v24; // [esp+98h] [ebp-20h]

  LOBYTE(v10) = a1;
  v1 = &loc_804C1E0;
  if ( !a1 )
    v1 = &loc_804C323;
  dword_80741F0 = (int)v1;
  sub_8067D38(v6, v8, v9, v10, v11, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23);
  sigemptyset(&set);
  for ( i = 0; i <= 11; ++i )
  {
    sigaction(sig[i], 0, (struct sigaction *)&v14);
    if ( v14 != (int (*)())1 )
      sigaddset(&set, sig[i]);
  }
  result = 32;
  qmemcpy(&v15, &set, 0x80u);
  v24 = 0x10000000;
  for ( j = 0; j <= 11; ++j )
  {
    result = sigismember(&set, sig[j]);
    if ( result )
    {
      v5 = &loc_804C2D1;
      if ( sig[j] != 20 )
        v5 = &loc_804C2D8;
      dword_8074210 = (int)v5;
      sub_8067C60(v4, v3, v7);
      v14 = sub_804C079;
      result = sigaction(sig[j], (const struct sigaction *)&v14, 0);
    }
  }
  return result;
}
// 8067D38: using guessed type int __stdcall sub_8067D38(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80741F0: using guessed type int dword_80741F0;
// 8074210: using guessed type int dword_8074210;

//----- (0804C3B1) --------------------------------------------------------
int sub_804C3B1()
{
  return sub_804C1A9(1);
}

//----- (0804C3C9) --------------------------------------------------------
int sub_804C3C9()
{
  return sub_804C1A9(0);
}

//----- (0804C3DD) --------------------------------------------------------
#error "804C4E0: call analysis failed (funcsize=470)"

//----- (0804CD5A) --------------------------------------------------------
#error "804CD8B: call analysis failed (funcsize=16)"

//----- (0804CD90) --------------------------------------------------------
#error "804CDF6: positive sp value has been found (funcsize=0)"

//----- (0804CDF7) --------------------------------------------------------
#error "804CF0D: call analysis failed (funcsize=57)"

//----- (0804CF12) --------------------------------------------------------
#error "804CF81: call analysis failed (funcsize=648)"

//----- (0804DD1C) --------------------------------------------------------
#error "804E2E5: positive sp value has been found (funcsize=278)"

//----- (0804E2E8) --------------------------------------------------------
int __fastcall sub_804E2E8(int ecx0, int edx0, int *a1, int *a2, char a3)
{
  int v5; // ST2C_4
  int v6; // ST30_4

  v5 = *a2;
  v6 = *a1;
  dword_8074274 = (int (__fastcall *)(_DWORD, _DWORD))sub_804EA8D;
  dword_8074270 = (int)sub_804E3B9;
  return ((int (__fastcall *)(int, int))sub_804EA8D)(ecx0, edx0);
}
// 804E3B9: using guessed type int sub_804E3B9();
// 804EA8D: using guessed type int sub_804EA8D();
// 8074270: using guessed type int dword_8074270;
// 8074274: using guessed type int (__fastcall *dword_8074274)(_DWORD, _DWORD);

//----- (0804E87A) --------------------------------------------------------
#error "804E8B3: positive sp value has been found (funcsize=18)"

//----- (0804EAC8) --------------------------------------------------------
#error "804EB53: call analysis failed (funcsize=60)"

//----- (0804EB95) --------------------------------------------------------
int __usercall sub_804EB95@<eax>(int a1@<ebx>)
{
  char *v1; // eax
  int v2; // edx
  int v3; // ecx
  bool v4; // zf
  void *v5; // eax
  int v6; // ebx
  int result; // eax
  int v8; // edx
  int v9; // ecx
  void *v10; // eax
  void *v11; // eax
  char *v12; // eax
  char *v13; // eax
  int v14; // edx
  signed int v15; // eax
  char *v16; // eax
  char *v17; // eax
  int v18; // eax
  void *v19; // eax
  int v20; // edx
  int v21; // ecx
  signed int v22; // eax
  char *v23; // eax
  void *v24; // eax
  int v25; // eax
  int v26; // edx
  int v27; // ecx
  void *v28; // eax
  int v29; // [esp-8h] [ebp-50h]
  int v30; // [esp-4h] [ebp-4Ch]
  int v31; // [esp+0h] [ebp-48h]
  const char *v32; // [esp+4h] [ebp-44h]
  int v33; // [esp+8h] [ebp-40h]
  int v34; // [esp+Ch] [ebp-3Ch]
  int v35; // [esp+10h] [ebp-38h]
  int v36; // [esp+14h] [ebp-34h]
  int v37; // [esp+18h] [ebp-30h]
  int v38; // [esp+1Ch] [ebp-2Ch]
  char *v39; // [esp+20h] [ebp-28h]
  void *v40; // [esp+24h] [ebp-24h]
  int v41; // [esp+28h] [ebp-20h]
  int v42; // [esp+2Ch] [ebp-1Ch]
  int v43; // [esp+30h] [ebp-18h]
  int v44; // [esp+34h] [ebp-14h]
  char *v45; // [esp+3Ch] [ebp-Ch]

  v1 = getenv("LS_COLORS");
  v39 = v1;
  v4 = v1 == 0;
  v30 = (int)v1;
  v29 = a1;
  v5 = &loc_804EBCB;
  if ( v4 )
    v5 = &loc_804EBD5;
  dword_8074210 = (int)v5;
  v6 = v29;
  sub_8067C60(v3, v2, v31);
  if ( *v39 )
  {
    v42 = 0;
    *(_WORD *)((char *)&v38 + 1) = 16191;
    HIBYTE(v38) = 0;
    ptr = sub_8063B31(v39);
    v40 = ptr;
    v43 = 1;
    while ( 1 )
    {
      switch ( v43 )
      {
        case 1:
          v4 = *v39 == 42;
          v30 = *v39;
          v29 = v6;
          v10 = &loc_804ED01;
          if ( v4 )
            v10 = &loc_804ED21;
          dword_8074274 = (int (__fastcall *)(_DWORD, _DWORD))v10;
          v30 = (int)&loc_804ED01;
          dword_8074270 = (int)&loc_804ED01;
          return ((int (__fastcall *)(int, int))v10)(v9, v8);
        case 2:
          v30 = (unsigned __int8)*v39;
          v29 = v6;
          v11 = &loc_804EDE6;
          if ( !*v39 )
            v11 = &loc_804EE01;
          dword_8074288 = (int)v11;
          v6 = v29;
          sub_8067999(v9, v8, v31);
          v12 = v39;
          v8 = (int)(v39++ + 1);
          BYTE2(v38) = *v12;
          v43 = 3;
          continue;
        case 3:
          v43 = 6;
          v13 = v39;
          v8 = (int)(v39++ + 1);
          if ( *v13 != 61 )
            continue;
          v41 = 0;
          break;
        case 4:
          v17 = v39++;
          v18 = (unsigned __int8)*v17;
          v4 = (_BYTE)v18 == 61;
          v30 = v18;
          v29 = v6;
          v19 = &loc_804EF43;
          if ( !v4 )
            v19 = &loc_804EF95;
          dword_80741DC = (int)v19;
          v6 = v29;
          sub_8067DA4(v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41);
          v20 = (int)v40;
          *(_DWORD *)(v42 + 12) = v40;
          v34 = v42 + 8;
          if ( (unsigned __int8)sub_804E2E8(v21, v20, &v31 - 9, (int *)&v39, 0) )
            v22 = 1;
          else
            v22 = 6;
          v43 = v22;
          continue;
        case 6:
          if ( v43 == 6 )
          {
            v23 = gettext("unparsable value for LS_COLORS environment variable");
            error(0, 0, v23);
            free(ptr);
            v44 = dword_8074A58;
            v30 = dword_8074A58;
            v29 = v6;
            v24 = &loc_804F022;
            if ( dword_8074A58 )
              v24 = &loc_804EFE9;
            dword_8074238 = (int)v24;
            v6 = v29;
            sub_8067B80(v31, v32, v33, v34, v35, v36, v37);
            byte_8074A54 = 0;
          }
          result = dword_8074368;
          if ( dword_8074368 == 6 )
          {
            v25 = strncmp(off_807436C, "target", 6u);
            v4 = v25 == 0;
            v30 = v25;
            v29 = v6;
            v28 = &loc_804F06D;
            if ( !v4 )
              v28 = &loc_804F074;
            dword_8074288 = (int)v28;
            result = sub_8067999(v27, v26, v31);
            byte_80749EC = 1;
          }
          return result;
        default:
          abort();
          return result;
      }
      while ( 1 )
      {
        if ( !(&off_8069278)[v41] )
          goto LABEL_26;
        v32 = (&off_8069278)[v41];
        if ( !strcmp((const char *)&v38 + 1, v32) )
          break;
        ++v41;
      }
      v14 = (int)v40;
      *(&s1 + 2 * v41) = v40;
      v34 = 8 * v41 + 134693680;
      if ( (unsigned __int8)sub_804E2E8(v9, v14, &v31 - 9, (int *)&v39, 0) )
        v15 = 1;
      else
        v15 = 6;
      v43 = v15;
LABEL_26:
      if ( v43 == 6 )
      {
        v6 = sub_8062A30((int)&v38 + 1);
        v16 = gettext("unrecognized prefix: %s");
        v34 = v6;
        error(0, 0, v16);
        dword_807429C = (int)&loc_804EFA3;
        sub_806790C(v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41);
      }
    }
  }
  v45 = getenv("COLORTERM");
  if ( !v45 || (result = (unsigned __int8)*v45, !(_BYTE)result) )
  {
    result = sub_804EAC8() ^ 1;
    if ( (_BYTE)result )
      byte_8074A54 = 0;
  }
  return result;
}
// 804EAC8: using guessed type int sub_804EAC8(void);
// 806790C: using guessed type int __stdcall sub_806790C(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8067B80: using guessed type int __stdcall sub_8067B80(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8067DA4: using guessed type int __stdcall sub_8067DA4(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80741DC: using guessed type int dword_80741DC;
// 8074210: using guessed type int dword_8074210;
// 8074238: using guessed type int dword_8074238;
// 8074270: using guessed type int dword_8074270;
// 8074274: using guessed type int (__fastcall *dword_8074274)(_DWORD, _DWORD);
// 8074288: using guessed type int dword_8074288;
// 807429C: using guessed type int dword_807429C;
// 8074368: using guessed type int dword_8074368;
// 80749EC: using guessed type char byte_80749EC;
// 8074A54: using guessed type char byte_8074A54;
// 8074A58: using guessed type int dword_8074A58;

//----- (0804F07A) --------------------------------------------------------
void sub_804F07A()
{
  int v0; // ebx
  char *v1; // eax
  char *s; // [esp+18h] [ebp-10h]
  int v3; // [esp+1Ch] [ebp-Ch]

  s = getenv("QUOTING_STYLE");
  if ( s )
  {
    v3 = sub_8056BB4(s, (int)off_806CA98);
    if ( v3 < 0 )
    {
      v0 = sub_8062A30((int)s);
      v1 = gettext("ignoring invalid value of environment variable QUOTING_STYLE: %s");
      error(0, 0, v1, v0);
    }
    else
    {
      sub_8060AE5(0, dword_806CAD8[v3]);
    }
  }
}
// 8060AE5: using guessed type _DWORD __cdecl sub_8060AE5(_DWORD, _DWORD);
// 806CA98: using guessed type char *off_806CA98[10];

//----- (0804F13B) --------------------------------------------------------
int __cdecl sub_804F13B(int a1)
{
  int result; // eax

  result = a1;
  if ( (_BYTE)a1 )
  {
    dword_8074B38 = 2;
  }
  else
  {
    result = dword_8074B38;
    if ( !dword_8074B38 )
      dword_8074B38 = 1;
  }
  return result;
}
// 8074B38: using guessed type int dword_8074B38;

//----- (0804F17A) --------------------------------------------------------
int __cdecl sub_804F17A(int a1, char *format, int a3)
{
  const char *v3; // ebx
  int v4; // eax
  int v6; // [esp+0h] [ebp-28h]
  const char *v7; // [esp+Ch] [ebp-1Ch]
  char v8; // [esp+1Ch] [ebp-Ch]

  v8 = a1;
  v3 = (const char *)sub_8062581(4, a3);
  v4 = *__errno_location();
  v7 = v3;
  error(0, v4, v3, v3);
  return sub_804F13B(*((unsigned __int8 *)&v6 - 12));
}
// 8062581: using guessed type int __cdecl sub_8062581(_DWORD, _DWORD);

//----- (0804F1F2) --------------------------------------------------------
int __cdecl sub_804F1F2(char *a1, char *a2, char a3)
{
  void *v3; // eax
  void *v4; // eax
  int v5; // ST24_4
  char v6; // ST14_1
  int result; // eax
  int v8; // [esp+0h] [ebp-28h]
  int v9; // [esp+4h] [ebp-24h]
  int v10; // [esp+8h] [ebp-20h]
  _DWORD v11[4]; // [esp+Ch] [ebp-1Ch]
  int v12; // [esp+10h] [ebp-18h]
  int v13; // [esp+14h] [ebp-14h]
  int v14; // [esp+18h] [ebp-10h]
  int v15; // [esp+1Ch] [ebp-Ch]
  int v16; // [esp+20h] [ebp-8h]
  int v17; // [esp+24h] [ebp-4h]
  int savedregs; // [esp+28h] [ebp+0h]

  LOBYTE(v11[0]) = a3;
  v15 = sub_806399E(0x10u);
  if ( a2 )
    v3 = sub_8063B31(a2);
  else
    v3 = 0;
  *(_DWORD *)(v15 + 4) = v3;
  v4 = &loc_804F258;
  if ( !a1 )
    v4 = &loc_804F265;
  dword_807429C = (int)v4;
  sub_806790C(v8, v9, v10, v11[0], v12, v13, v14, v15, v16, v17, savedregs);
  *(_DWORD *)v5 = sub_8063B31(a1);
  *(_BYTE *)(v5 + 8) = v6;
  *(_DWORD *)(v5 + 12) = dword_80749F4;
  result = v5;
  dword_80749F4 = v5;
  return result;
}
// 806790C: using guessed type int __stdcall sub_806790C(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 807429C: using guessed type int dword_807429C;
// 80749F4: using guessed type int dword_80749F4;

//----- (0804F29F) --------------------------------------------------------
unsigned int __usercall sub_804F29F@<eax>(int a1@<ebx>, char *a2, char *a3, char a4)
{
  char *v4; // eax
  unsigned int v5; // eax
  char *v6; // eax
  int v7; // ebx
  int v8; // eax
  FILE *v9; // edx
  int v10; // ebx
  char *v11; // eax
  int v12; // edx
  int v13; // ecx
  char *v14; // eax
  char *v15; // eax
  int v16; // edx
  int v17; // ecx
  int v18; // edx
  __int64 v19; // rax
  void *v20; // eax
  int v21; // edx
  int v22; // ecx
  int v23; // edx
  int v24; // ecx
  char *v25; // eax
  char *v26; // eax
  int v27; // edx
  int v28; // ecx
  int v29; // edx
  int v31; // [esp-8h] [ebp-350h]
  int v32; // [esp-4h] [ebp-34Ch]
  char *v33; // [esp+0h] [ebp-348h]
  FILE *v34; // [esp+4h] [ebp-344h]
  char **v35; // [esp+8h] [ebp-340h]
  int v36; // [esp+Ch] [ebp-33Ch]
  int v37; // [esp+10h] [ebp-338h]
  int v38; // [esp+14h] [ebp-334h]
  __int64 v39; // [esp+18h] [ebp-330h]
  int v40; // [esp+20h] [ebp-328h]
  int v41; // [esp+24h] [ebp-324h]
  int v42; // [esp+28h] [ebp-320h]
  char *name; // [esp+2Ch] [ebp-31Ch]

  name = a2;
  *(&v33 - 200) = a3;
  *((_BYTE *)&v33 - 804) = a4;
  *(&v33 - 3) = (char *)__readgsdword(0x14u);
  *(&v33 - 192) = 0;
  *(&v33 - 191) = 0;
  *__errno_location() = 0;
  v33 = *(&v33 - 199);
  *(&v33 - 196) = (char *)opendir(v33);
  if ( !*(&v33 - 196) )
  {
    v4 = gettext("cannot open directory %s");
    sub_804F17A(*((unsigned __int8 *)&v33 - 804), v4, (int)*(&v33 - 199));
    return __readgsdword(0x14u) ^ (unsigned int)*(&v33 - 3);
  }
  if ( dword_80749D0 )
  {
    v33 = *(&v33 - 196);
    *(&v33 - 195) = (char *)dirfd((DIR *)v33);
    if ( (signed int)*(&v33 - 195) < 0 )
    {
      v34 = (FILE *)(&v33 - 190);
      v33 = *(&v33 - 199);
      v5 = (unsigned int)sub_80675EA((int)v33, (int)(&v33 - 190)) >> 31;
    }
    else
    {
      v34 = (FILE *)(&v33 - 190);
      v33 = *(&v33 - 195);
      v5 = (unsigned int)sub_806761D((int)v33, (int)(&v33 - 190)) >> 31;
    }
    if ( (_BYTE)v5 )
    {
      v6 = gettext("cannot determine device and inode of %s");
      sub_804F17A(*((unsigned __int8 *)&v33 - 804), v6, (int)*(&v33 - 199));
      closedir((DIR *)*(&v33 - 196));
      return __readgsdword(0x14u) ^ (unsigned int)*(&v33 - 3);
    }
    v7 = (int)*(&v33 - 167);
    v8 = (int)*(&v33 - 190);
    v9 = (FILE *)*(&v33 - 189);
    v35 = (char **)*(&v33 - 168);
    v36 = v7;
    v34 = v9;
    if ( (unsigned __int8)sub_804BD97(v8) )
    {
      v35 = (char **)*(&v33 - 199);
      v10 = sub_8062745(0, 3, (int)v35);
      v11 = gettext("%s: not listing already-listed directory");
      v36 = v10;
      error(0, 0, v11, v10);
      closedir((DIR *)*(&v33 - 196));
      sub_804F13B(1);
      return __readgsdword(0x14u) ^ (unsigned int)*(&v33 - 3);
    }
    a1 = (int)*(&v33 - 167);
    sub_804B552((int)*(&v33 - 190), (int)*(&v33 - 189), (int)*(&v33 - 168), a1);
  }
  sub_804FCB2();
  if ( byte_8074A68 || byte_8074A88 )
  {
    if ( byte_80743F8 != 1 )
    {
      putchar_unlocked(10);
      ++dword_8074B44;
    }
    byte_80743F8 = 0;
    if ( byte_8074A4C )
    {
      fwrite_unlocked("  ", 1u, 2u, stdout);
      dword_8074B44 += 2;
    }
    *(&v33 - 198) = 0;
    if ( byte_8074A55 )
    {
      v34 = (FILE *)2;
      v33 = *(&v33 - 199);
      *(&v33 - 198) = sub_80573B5(v12, v13, v33, 2);
      if ( !*(&v33 - 198) )
      {
        v14 = gettext("error canonicalizing %s");
        sub_804F17A(*((unsigned __int8 *)&v33 - 804), v14, (int)*(&v33 - 199));
      }
    }
    if ( *(&v33 - 200) )
      v15 = *(&v33 - 200);
    else
      v15 = *(&v33 - 199);
    sub_80547F0(a1, v15, dword_8074A80, -1, 0, 1, (int)&unk_8074B90, *(&v33 - 198));
    free(*(&v33 - 198));
    fwrite_unlocked(":\n", 1u, 2u, stdout);
    dword_8074B44 += 2;
  }
  while ( 1 )
  {
    *__errno_location() = 0;
    v33 = *(&v33 - 196);
    *(&v33 - 194) = (char *)readdir64();
    if ( !*(&v33 - 194) )
      break;
    v33 = *(&v33 - 194) + 19;
    if ( (unsigned __int8)sub_804FAC9(v33) ^ 1 )
    {
      *(&v33 - 197) = 0;
      switch ( (*(&v33 - 194))[18] )
      {
        case 1:
          goto LABEL_31;
        case 2:
          *(&v33 - 197) = (char *)2;
          break;
        case 4:
          *(&v33 - 197) = (char *)3;
          dword_8074260 = (int)&loc_804F722;
          sub_8067A7F(v17, v16);
LABEL_31:
          *(&v33 - 197) = (char *)1;
          break;
        case 6:
          *(&v33 - 197) = (char *)4;
          break;
        case 8:
          *(&v33 - 197) = (char *)5;
          break;
        case 0xA:
          *(&v33 - 197) = (char *)6;
          break;
        case 0xC:
          *(&v33 - 197) = (char *)7;
          break;
        case 0xE:
          *(&v33 - 197) = (char *)8;
          break;
        default:
          break;
      }
      v18 = (int)(*(&v33 - 194) + 19);
      v38 = (int)*(&v33 - 199);
      v37 = 0;
      v35 = 0;
      v36 = 0;
      v34 = (FILE *)*(&v33 - 197);
      LODWORD(v19) = sub_80500AF(v18, v34, 0, 0, 0, v38);
      *((_QWORD *)&v33 - 96) += v19;
      if ( dword_8074A2C == 1 && dword_8074A34 == -1 && byte_8074A3B != 1 )
      {
        v32 = (unsigned __int8)byte_8074A68 ^ 1;
        v31 = a1;
        v20 = &loc_804F7C4;
        if ( byte_8074A68 == 1 )
          v20 = &loc_804F7D5;
        dword_807429C = (int)v20;
        a1 = v31;
        sub_806790C(v33, v34, v35, v36, v37, v38, v39, HIDWORD(v39), v40, v41, v42);
        sub_8052A9B();
        sub_8052C06(v21, v22, a1);
        sub_804FCB2();
      }
    }
LABEL_47:
    sub_804C094();
  }
  if ( !*__errno_location() )
  {
    dword_8074288 = (int)&loc_804F83A;
    sub_8067999(v24, v23, v33);
    goto LABEL_47;
  }
  v25 = gettext("reading directory %s");
  sub_804F17A(*((unsigned __int8 *)&v33 - 804), v25, (int)*(&v33 - 199));
  if ( *__errno_location() == 75 )
    goto LABEL_47;
  v33 = *(&v33 - 196);
  if ( closedir((DIR *)v33) )
  {
    v26 = gettext("closing directory %s");
    sub_804F17A(*((unsigned __int8 *)&v33 - 804), v26, (int)*(&v33 - 199));
  }
  sub_8052A9B();
  if ( byte_8074A68 )
  {
    v34 = 0;
    sub_805132D(*(&v33 - 199), 0);
  }
  if ( !dword_8074A2C || byte_8074A3B )
  {
    if ( byte_8074A4C )
    {
      fwrite_unlocked("  ", 1u, 2u, stdout);
      dword_8074B44 += 2;
    }
    *(&v33 - 193) = gettext("total");
    v34 = stdout;
    fputs_unlocked(*(&v33 - 193), stdout);
    dword_8074B44 += strlen(*(&v33 - 193));
    putchar_unlocked(32);
    ++dword_8074B44;
    v39 = qword_8074A40;
    v37 = 512;
    v38 = 0;
    v36 = dword_8074A3C;
    v35 = &v33 - 166;
    v29 = (int)*(&v33 - 191);
    v33 = *(&v33 - 192);
    *(&v33 - 193) = (char *)sub_805B1E2(
                              v33,
                              v29,
                              &v33 - 166,
                              dword_8074A3C,
                              512,
                              0,
                              qword_8074A40,
                              HIDWORD(qword_8074A40));
    v34 = stdout;
    fputs_unlocked(*(&v33 - 193), stdout);
    dword_8074B44 += strlen(*(&v33 - 193));
    putchar_unlocked(10);
    ++dword_8074B44;
  }
  if ( dword_80749DC )
    sub_8052C06(v27, v28, a1);
  return __readgsdword(0x14u) ^ (unsigned int)*(&v33 - 3);
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8049A80: using guessed type int readdir64(void);
// 804C094: using guessed type int sub_804C094(void);
// 804FCB2: using guessed type int sub_804FCB2(void);
// 80500AF: using guessed type _DWORD __cdecl sub_80500AF(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 805B1E2: using guessed type _DWORD __cdecl sub_805B1E2(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806790C: using guessed type int __stdcall sub_806790C(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8067A7F: using guessed type int __fastcall sub_8067A7F(_DWORD, _DWORD);
// 8074260: using guessed type int dword_8074260;
// 8074288: using guessed type int dword_8074288;
// 807429C: using guessed type int dword_807429C;
// 80743F8: using guessed type char byte_80743F8;
// 80749DC: using guessed type int dword_80749DC;
// 8074A2C: using guessed type int dword_8074A2C;
// 8074A34: using guessed type int dword_8074A34;
// 8074A3B: using guessed type char byte_8074A3B;
// 8074A3C: using guessed type int dword_8074A3C;
// 8074A40: using guessed type __int64 qword_8074A40;
// 8074A4C: using guessed type char byte_8074A4C;
// 8074A55: using guessed type char byte_8074A55;
// 8074A68: using guessed type char byte_8074A68;
// 8074A80: using guessed type int dword_8074A80;
// 8074A88: using guessed type char byte_8074A88;
// 8074B44: using guessed type int dword_8074B44;

//----- (0804FA25) --------------------------------------------------------
int __cdecl sub_804FA25(int a1)
{
  _DWORD *v1; // eax
  int result; // eax
  int v3; // [esp+0h] [ebp-28h]
  _DWORD *v4; // [esp+1Ch] [ebp-Ch]

  v1 = (_DWORD *)sub_806399E(8u);
  v4 = v1;
  *v1 = a1;
  v4[1] = dword_8074A70;
  result = *(&v3 - 3);
  dword_8074A70 = *(&v3 - 3);
  return result;
}

//----- (0804FA7A) --------------------------------------------------------
int __cdecl sub_804FA7A(int a1, char *name)
{
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = a1; i; i = *(_DWORD *)(i + 4) )
  {
    if ( !fnmatch(*(const char **)i, name, 4) )
      return 1;
  }
  return 0;
}

//----- (0804FAC9) --------------------------------------------------------
int __cdecl sub_804FAC9(char *name)
{
  signed int v1; // eax
  bool v2; // zf
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  char v6; // al
  int v8; // [esp+0h] [ebp-18h]
  int v9; // [esp+4h] [ebp-14h]
  int v10; // [esp+8h] [ebp-10h]
  int v11; // [esp+Ch] [ebp-Ch]

  if ( dword_8074A6C != 2 && *name == 46 )
  {
    if ( !dword_8074A6C )
      goto LABEL_18;
    v1 = name[1] == 46 ? 2 : 1;
    if ( !name[v1] )
      goto LABEL_18;
  }
  if ( !dword_8074A6C )
  {
    v2 = (unsigned __int8)sub_804FA7A(dword_8074A74, name) == 0;
    v5 = &loc_804FB4B;
    if ( !v2 )
      v5 = &loc_804FB67;
    dword_80742B0 = (int)v5;
    sub_806787F(v4, v3, v8, v9, v10, v11);
  }
  if ( !(unsigned __int8)sub_804FA7A(dword_8074A70, name) )
    v6 = 0;
  else
LABEL_18:
    v6 = 1;
  return v6 & 1;
}
// 80742B0: using guessed type int dword_80742B0;
// 8074A6C: using guessed type int dword_8074A6C;

//----- (0804FB78) --------------------------------------------------------
int __cdecl sub_804FB78(int a1)
{
  return a1;
}

//----- (0804FBB0) --------------------------------------------------------
int sub_804FBB0()
{
  *__errno_location() = 95;
  return 0;
}

//----- (0804FBE8) --------------------------------------------------------
#error "804FC38: call analysis failed (funcsize=56)"

//----- (0804FCB2) --------------------------------------------------------
#error "804FD54: call analysis failed (funcsize=44)"

//----- (0804FD59) --------------------------------------------------------
#error "804FDAE: positive sp value has been found (funcsize=0)"

//----- (0804FDAF) --------------------------------------------------------
int __cdecl sub_804FDAF(int a1)
{
  return a1 == 22 || a1 == 38 || sub_804B534(a1);
}

//----- (0804FDE5) --------------------------------------------------------
signed int __cdecl sub_804FDE5(int a1, int a2, char a3)
{
  signed int result; // eax
  signed int v4; // eax
  int v5; // edx
  int v6; // [esp+0h] [ebp-28h]
  int v7; // [esp+4h] [ebp-24h]
  int v8; // [esp+8h] [ebp-20h]
  char v9; // [esp+Ch] [ebp-1Ch]

  v9 = a3;
  if ( *(_QWORD *)(a2 + 12) == qword_80759D0 )
  {
    *__errno_location() = 95;
    result = -1;
  }
  else
  {
    *(&v6 - 3) = 0;
    if ( *((_BYTE *)&v6 - 28) )
    {
      v7 = *(_DWORD *)&v9 + 116;
      v6 = v8;
      v4 = sub_8062CF4();
    }
    else
    {
      v7 = *(_DWORD *)&v9 + 116;
      v6 = v8;
      v4 = sub_8062D16();
    }
    *(&v6 - 3) = v4;
    if ( *(&v6 - 3) < 0 )
    {
      v6 = *__errno_location();
      if ( (unsigned __int8)sub_804FDAF(v6) )
      {
        v5 = *(_DWORD *)(*(_DWORD *)&v9 + 16);
        LODWORD(qword_80759D0) = *(_DWORD *)(*(_DWORD *)&v9 + 12);
        HIDWORD(qword_80759D0) = v5;
      }
    }
    result = *(&v6 - 3);
  }
  return result;
}
// 80759D0: using guessed type __int64 qword_80759D0;

//----- (0804FEC8) --------------------------------------------------------
#error "804FF04: call analysis failed (funcsize=22)"

//----- (0804FF09) --------------------------------------------------------
#error "804FF9F: positive sp value has been found (funcsize=46)"

//----- (0804FFA3) --------------------------------------------------------
int __cdecl sub_804FFA3(int a1, int a2)
{
  int result; // eax
  int *v3; // eax
  int v4; // edx
  unsigned __int8 v5; // [esp+1Fh] [ebp-9h]

  if ( *(_QWORD *)(a2 + 12) == qword_80759E0 )
  {
    *__errno_location() = 95;
    result = 0;
  }
  else
  {
    v5 = sub_804FBB0();
    if ( v5 ^ 1 )
    {
      v3 = __errno_location();
      if ( (unsigned __int8)sub_804FDAF(*v3) )
      {
        v4 = *(_DWORD *)(a2 + 16);
        LODWORD(qword_80759E0) = *(_DWORD *)(a2 + 12);
        HIDWORD(qword_80759E0) = v4;
      }
    }
    result = v5;
  }
  return result;
}
// 80759E0: using guessed type __int64 qword_80759E0;

//----- (0805003C) --------------------------------------------------------
_BOOL4 __cdecl sub_805003C(char *s)
{
  size_t v1; // eax
  bool v2; // al
  char v4; // [esp+2Ah] [ebp-Eh]
  int v5; // [esp+2Ch] [ebp-Ch]

  v5 = sub_8061EBA((int)&v4, 2, (int)s, -1, dword_8074A7C);
  v2 = 1;
  if ( *s == v4 )
  {
    v1 = strlen(s);
    if ( v1 == v5 )
      v2 = 0;
  }
  return v2;
}
// 8074A7C: using guessed type int dword_8074A7C;

//----- (080500AF) --------------------------------------------------------
#error "8050CD9: call analysis failed (funcsize=976)"

//----- (0805113F) --------------------------------------------------------
#error "8051169: call analysis failed (funcsize=27)"

//----- (0805119E) --------------------------------------------------------
int __cdecl sub_805119E(char *path, int a2, int a3)
{
  int v3; // edx
  int result; // eax
  char *v5; // eax

  v3 = *(_DWORD *)(a2 + 60);
  *(_DWORD *)(a2 + 4) = sub_80569C7(path, *(_DWORD *)(a2 + 56));
  result = *(_DWORD *)(a2 + 4);
  if ( !result )
  {
    v5 = gettext("cannot read symbolic link %s");
    result = sub_804F17A((unsigned __int8)a3, v5, (int)path);
  }
  return result;
}

//----- (08051207) --------------------------------------------------------
#error "8051247: call analysis failed (funcsize=28)"

//----- (08051308) --------------------------------------------------------
int __usercall sub_8051308@<eax>(int a1@<edx>, int a2@<ecx>, _BYTE *a3)
{
  _BYTE *v3; // ST1C_4

  v3 = sub_80580E7(a1, a2, a3);
  return sub_804B178(v3);
}
// 804B178: using guessed type _DWORD __cdecl sub_804B178(_DWORD);

//----- (0805132D) --------------------------------------------------------
int __cdecl sub_805132D(char *a1, char a2)
{
  int v2; // edx
  int v3; // ecx
  void *v4; // eax
  int v5; // eax
  int v6; // ST34_4
  int result; // eax
  int v8; // [esp+0h] [ebp-38h]
  int v9; // [esp+0h] [ebp-38h]
  int v10; // [esp+4h] [ebp-34h]
  int v11; // [esp+4h] [ebp-34h]
  int v12; // [esp+8h] [ebp-30h]
  int v13; // [esp+8h] [ebp-30h]
  _DWORD v14[3]; // [esp+Ch] [ebp-2Ch]
  int v15; // [esp+Ch] [ebp-2Ch]
  int v16; // [esp+10h] [ebp-28h]
  int v17; // [esp+10h] [ebp-28h]
  int v18; // [esp+14h] [ebp-24h]
  int v19; // [esp+14h] [ebp-24h]
  int v20; // [esp+18h] [ebp-20h]
  int v21; // [esp+18h] [ebp-20h]
  int v22; // [esp+1Ch] [ebp-1Ch]
  unsigned int v23; // [esp+1Ch] [ebp-1Ch]
  int v24; // [esp+20h] [ebp-18h]
  int v25; // [esp+20h] [ebp-18h]
  int v26; // [esp+20h] [ebp-18h]
  int v27; // [esp+24h] [ebp-14h]
  char **v28; // [esp+24h] [ebp-14h]
  void *ptr; // [esp+28h] [ebp-10h]
  void *ptra; // [esp+28h] [ebp-10h]
  int v31; // [esp+2Ch] [ebp-Ch]
  int v32; // [esp+30h] [ebp-8h]
  int v33; // [esp+34h] [ebp-4h]
  int savedregs; // [esp+38h] [ebp+0h]

  LOBYTE(v14[0]) = a2;
  if ( a1 && dword_80749D0 )
    sub_804F1F2(0, a1, 0);
  dword_80741DC = (int)&loc_805147D;
  HIBYTE(v20) = a1 != 0;
  sub_8067DA4(v8, v10, v12, v14[0], v16, v18, v20, dword_80749DC, v24, v27, ptr);
  do
  {
    v28 = (char **)*((_DWORD *)dword_80749E4 + v22);
    if ( (unsigned __int8)sub_805113F(v28) && (HIBYTE(v21) != 1 || (unsigned __int8)sub_8051308(v2, v3, *v28) ^ 1) )
    {
      if ( a1 )
      {
        v4 = &loc_80513FF;
        if ( **v28 != 47 )
          v4 = &loc_8051420;
        dword_807429C = (int)v4;
        sub_806790C(v9, v11, v13, v15, v17, v19, v21, v22, v25, v28, ptra);
      }
      sub_804F1F2(*v28, v28[1], v15);
      if ( v28[27] == (char *)9 )
        sub_804FBE8(v28);
    }
    v5 = v22--;
  }
  while ( v5 );
  dword_80742C4 = (int)&loc_80514FD;
  sub_8067813(v9, v11, v13, v15, v17, v19, v21, 0, 0, v28, ptra, v31, v32, v33, savedregs);
  do
  {
    v6 = *((_DWORD *)dword_80749E4 + v23);
    *((_DWORD *)dword_80749E4 + v26) = v6;
    v26 += *(_DWORD *)(v6 + 108) != 9;
    ++v23;
  }
  while ( v23 < dword_80749DC );
  result = v26;
  dword_80749DC = v26;
  return result;
}
// 804FBE8: using guessed type _DWORD __cdecl sub_804FBE8(_DWORD);
// 805113F: using guessed type _DWORD __cdecl sub_805113F(_DWORD);
// 8067813: using guessed type int __stdcall sub_8067813(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806790C: using guessed type int __stdcall sub_806790C(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8067DA4: using guessed type int __stdcall sub_8067DA4(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80741DC: using guessed type int dword_80741DC;
// 807429C: using guessed type int dword_807429C;
// 80742C4: using guessed type int dword_80742C4;
// 80749DC: using guessed type int dword_80749DC;

//----- (08051511) --------------------------------------------------------
int __cdecl sub_8051511(char *s1, char *s2)
{
  int v2; // edi
  int v3; // esi
  char *v4; // ebx
  int *v5; // eax
  int v7; // [esp+0h] [ebp-1Ch]

  *__errno_location() = 0;
  v7 = strcoll(s1, s2);
  if ( *__errno_location() )
  {
    v2 = sub_80629EC(1, (int)s2);
    v3 = sub_80629EC(0, (int)s1);
    v4 = gettext("cannot compare file names %s and %s");
    v5 = __errno_location();
    error(0, *v5, v4, v3, v2);
    sub_804F13B(0);
    longjmp(env, 1);
  }
  return v7;
}

//----- (080515CF) --------------------------------------------------------
int __cdecl sub_80515CF(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD))
{
  int result; // eax
  int v4; // [esp+1Ch] [ebp-1Ch]
  int v5; // [esp+20h] [ebp-18h]
  int v6; // [esp+24h] [ebp-14h]
  int v7; // [esp+28h] [ebp-10h]
  int v8; // [esp+2Ch] [ebp-Ch]

  sub_8062E8B(&v5, (int)(a1 + 3));
  sub_8062E8B(&v7, (int)(a2 + 3));
  v4 = sub_8062F71(v7, v8, v5, v6);
  if ( v4 )
    result = v4;
  else
    result = a3(*a1, *a2);
  return result;
}

//----- (0805164F) --------------------------------------------------------
int __cdecl sub_805164F(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD))
{
  int result; // eax
  int v4; // [esp+1Ch] [ebp-1Ch]
  int v5; // [esp+20h] [ebp-18h]
  int v6; // [esp+24h] [ebp-14h]
  int v7; // [esp+28h] [ebp-10h]
  int v8; // [esp+2Ch] [ebp-Ch]

  sub_8062EC8(&v5, (int)(a1 + 3));
  sub_8062EC8(&v7, (int)(a2 + 3));
  v4 = sub_8062F71(v7, v8, v5, v6);
  if ( v4 )
    result = v4;
  else
    result = a3(*a1, *a2);
  return result;
}

//----- (080516CF) --------------------------------------------------------
int __cdecl sub_80516CF(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD))
{
  int result; // eax
  int v4; // [esp+1Ch] [ebp-1Ch]
  int v5; // [esp+20h] [ebp-18h]
  int v6; // [esp+24h] [ebp-14h]
  int v7; // [esp+28h] [ebp-10h]
  int v8; // [esp+2Ch] [ebp-Ch]

  sub_8062E50(&v5, (int)(a1 + 3));
  sub_8062E50(&v7, (int)(a2 + 3));
  v4 = sub_8062F71(v7, v8, v5, v6);
  if ( v4 )
    result = v4;
  else
    result = a3(*a1, *a2);
  return result;
}

//----- (08051757) --------------------------------------------------------
int __cdecl sub_8051757(int a1, int a2, int (__cdecl *a3)(_DWORD, _DWORD))
{
  __int64 v3; // rcx
  __int64 v4; // rax
  unsigned __int8 v5; // si
  int v6; // ST04_4
  signed int v7; // eax
  bool v8; // zf
  int v10; // [esp-1Ch] [ebp-28h]
  int v11; // [esp-18h] [ebp-24h]
  int v12; // [esp-14h] [ebp-20h]
  int v13; // [esp-10h] [ebp-1Ch]

  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(_QWORD *)(a1 + 56);
  if ( v3 < v4 )
  {
    v7 = -1;
  }
  else
  {
    v3 = *(_QWORD *)(a2 + 56);
    HIDWORD(v4) = *(_DWORD *)(a1 + 60);
    v5 = 1;
    if ( SHIDWORD(v3) <= SHIDWORD(v4) )
    {
      v6 = *(_DWORD *)(a1 + 56);
      LODWORD(v4) = &loc_80517C5;
      if ( SHIDWORD(v3) < SHIDWORD(v4) )
        LODWORD(v4) = &loc_80517C9;
      dword_8074288 = v4;
      if ( (unsigned int)v3 <= sub_8067999(v3, HIDWORD(v4), v10) )
        v5 = 0;
    }
    v7 = v5;
  }
  v8 = v7 == 0;
  LODWORD(v4) = &loc_805180C;
  if ( !v8 )
    LODWORD(v4) = &loc_8051824;
  dword_80742B0 = v4;
  sub_806787F(v3, HIDWORD(v4), v10, v11, v12, v13);
  return a3(*(_DWORD *)a1, *(_DWORD *)a2);
}
// 8074288: using guessed type int dword_8074288;
// 80742B0: using guessed type int dword_80742B0;

//----- (0805182E) --------------------------------------------------------
int __cdecl sub_805182E(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD))
{
  return a3(*a1, *a2);
}

//----- (0805185C) --------------------------------------------------------
int __cdecl sub_805185C(const char **a1, const char **a2, int (__cdecl *a3)(char *))
{
  char *v3; // eax
  int v4; // edx
  int v5; // ecx
  bool v6; // zf
  void *v7; // eax
  int v8; // ecx
  void *v9; // eax
  const char *v10; // edx
  int v12; // [esp-14h] [ebp-28h]
  char *v13; // [esp+0h] [ebp-14h]
  char *v14; // [esp+4h] [ebp-10h]
  int v15; // [esp+8h] [ebp-Ch]
  int savedregs; // [esp+14h] [ebp+0h]
  const char *retaddr; // [esp+18h] [ebp+4h]

  v13 = strrchr(*a1, 46);
  v3 = strrchr(*a2, 46);
  v14 = v3;
  v6 = v3 == 0;
  v7 = &loc_80518D1;
  if ( v6 )
    v7 = &loc_80518D6;
  dword_8074210 = (int)v7;
  sub_8067C60(v5, v4, v12);
  v9 = &loc_80518FA;
  if ( !v13 )
    v9 = &loc_80518FF;
  dword_8074288 = (int)v9;
  sub_8067999(v8, v14, savedregs);
  retaddr = v10;
  v15 = a3(v13);
  if ( v15 )
    return v15;
  retaddr = *a2;
  return a3((char *)*a1);
}
// 805185C: could not find valid save-restore pair for ebx
// 8074210: using guessed type int dword_8074210;
// 8074288: using guessed type int dword_8074288;

//----- (08052147) --------------------------------------------------------
int __cdecl sub_8052147(int a1, int a2)
{
  return sub_8051757(a1, a2, (int (__cdecl *)(_DWORD, _DWORD))sub_8051511);
}

//----- (08052169) --------------------------------------------------------
int __cdecl sub_8052169(int a1, int a2)
{
  return sub_8051757(a1, a2, (int (__cdecl *)(_DWORD, _DWORD))strcmp);
}

//----- (0805218B) --------------------------------------------------------
int __cdecl sub_805218B(int a1, int a2)
{
  return sub_8051757(a2, a1, (int (__cdecl *)(_DWORD, _DWORD))sub_8051511);
}

//----- (080521AD) --------------------------------------------------------
int __cdecl sub_80521AD(int a1, int a2)
{
  return sub_8051757(a2, a1, (int (__cdecl *)(_DWORD, _DWORD))strcmp);
}

//----- (080521CF) --------------------------------------------------------
#error "8052228: call analysis failed (funcsize=43)"

//----- (08052256) --------------------------------------------------------
#error "80522B5: call analysis failed (funcsize=43)"

//----- (080522DD) --------------------------------------------------------
#error "805233C: call analysis failed (funcsize=43)"

//----- (08052364) --------------------------------------------------------
#error "80523AA: call analysis failed (funcsize=40)"

//----- (080523E7) --------------------------------------------------------
int __cdecl sub_80523E7(_DWORD *a1, _DWORD *a2)
{
  return sub_805182E(a1, a2, (int (__cdecl *)(_DWORD, _DWORD))sub_8051511);
}

//----- (08052409) --------------------------------------------------------
int __cdecl sub_8052409(_DWORD *a1, _DWORD *a2)
{
  return sub_805182E(a1, a2, (int (__cdecl *)(_DWORD, _DWORD))strcmp);
}

//----- (0805242B) --------------------------------------------------------
int __cdecl sub_805242B(_DWORD *a1, _DWORD *a2)
{
  return sub_805182E(a2, a1, (int (__cdecl *)(_DWORD, _DWORD))sub_8051511);
}

//----- (0805244D) --------------------------------------------------------
int __cdecl sub_805244D(_DWORD *a1, _DWORD *a2)
{
  return sub_805182E(a2, a1, (int (__cdecl *)(_DWORD, _DWORD))strcmp);
}

//----- (0805246F) --------------------------------------------------------
int __cdecl sub_805246F(_DWORD *a1, _DWORD *a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_805113F(a1);
  v4 = sub_805113F(a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_805182E(a1, a2, (int (__cdecl *)(_DWORD, _DWORD))sub_8051511);
}
// 805113F: using guessed type _DWORD __cdecl sub_805113F(_DWORD);

//----- (080524DD) --------------------------------------------------------
#error "805253B: call analysis failed (funcsize=40)"

//----- (08052560) --------------------------------------------------------
int __cdecl sub_8052560(_DWORD *a1, _DWORD *a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_805113F(a1);
  v4 = sub_805113F(a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_805182E(a2, a1, (int (__cdecl *)(_DWORD, _DWORD))sub_8051511);
}
// 805113F: using guessed type _DWORD __cdecl sub_805113F(_DWORD);

//----- (080525CE) --------------------------------------------------------
#error "805260A: call analysis failed (funcsize=43)"

//----- (08052655) --------------------------------------------------------
int __cdecl sub_8052655(const char **a1, const char **a2)
{
  return sub_805185C(a1, a2, (int (__cdecl *)(char *))sub_8051511);
}

//----- (08052677) --------------------------------------------------------
int __cdecl sub_8052677(const char **a1, const char **a2)
{
  return sub_805185C(a1, a2, (int (__cdecl *)(char *))strcmp);
}

//----- (08052699) --------------------------------------------------------
int __cdecl sub_8052699(const char **a1, const char **a2)
{
  return sub_805185C(a2, a1, (int (__cdecl *)(char *))sub_8051511);
}

//----- (080526BB) --------------------------------------------------------
int __cdecl sub_80526BB(const char **a1, const char **a2)
{
  return sub_805185C(a2, a1, (int (__cdecl *)(char *))strcmp);
}

//----- (080526DD) --------------------------------------------------------
int __cdecl sub_80526DD(const char **a1, const char **a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_805113F(a1);
  v4 = sub_805113F(a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_805185C(a1, a2, (int (__cdecl *)(char *))sub_8051511);
}
// 805113F: using guessed type _DWORD __cdecl sub_805113F(_DWORD);

//----- (0805274B) --------------------------------------------------------
int __cdecl sub_805274B(const char **a1, const char **a2)
{
  int v2; // edx
  int v3; // ecx
  char v5; // [esp+1Eh] [ebp-Ah]
  char v6; // [esp+1Fh] [ebp-9h]

  v5 = sub_805113F(a1);
  v6 = sub_805113F(a2);
  if ( v5 && v6 != 1 )
    return -1;
  if ( v5 != 1 )
  {
    if ( v6 )
    {
      dword_8074260 = (int)&locret_80527CC;
      sub_8067A7F(v3, v2);
    }
  }
  return sub_805185C(a1, a2, (int (__cdecl *)(char *))strcmp);
}
// 805113F: using guessed type _DWORD __cdecl sub_805113F(_DWORD);
// 8067A7F: using guessed type int __fastcall sub_8067A7F(_DWORD, _DWORD);
// 8074260: using guessed type int dword_8074260;

//----- (080527CE) --------------------------------------------------------
int __cdecl sub_80527CE(const char **a1, const char **a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_805113F(a1);
  v4 = sub_805113F(a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_805185C(a2, a1, (int (__cdecl *)(char *))sub_8051511);
}
// 805113F: using guessed type _DWORD __cdecl sub_805113F(_DWORD);

//----- (0805283C) --------------------------------------------------------
int __cdecl sub_805283C(const char **a1, const char **a2)
{
  void *v2; // eax
  int v4; // [esp+0h] [ebp-28h]
  int v5; // [esp+4h] [ebp-24h]
  int v6; // [esp+8h] [ebp-20h]
  int v7; // [esp+Ch] [ebp-1Ch]
  int v8; // [esp+10h] [ebp-18h]
  int v9; // [esp+14h] [ebp-14h]
  int v10; // [esp+18h] [ebp-10h]
  int v11; // [esp+1Ch] [ebp-Ch]
  int v12; // [esp+20h] [ebp-8h]
  int v13; // [esp+24h] [ebp-4h]
  int savedregs; // [esp+28h] [ebp+0h]

  BYTE2(v11) = sub_805113F(a1);
  HIBYTE(v11) = sub_805113F(a2);
  if ( BYTE2(v11) && HIBYTE(v11) != 1 )
  {
    dword_80741DC = (int)&locret_80528D6;
    sub_8067DA4(v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, savedregs);
  }
  if ( BYTE2(v11) == 1 )
    return sub_805185C(a2, a1, (int (__cdecl *)(char *))strcmp);
  v2 = &loc_80528B5;
  if ( !HIBYTE(v11) )
    v2 = &loc_80528BC;
  dword_807429C = (int)v2;
  sub_806790C(v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, savedregs);
  return 1;
}
// 805113F: using guessed type _DWORD __cdecl sub_805113F(_DWORD);
// 806790C: using guessed type int __stdcall sub_806790C(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8067DA4: using guessed type int __stdcall sub_8067DA4(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80741DC: using guessed type int dword_80741DC;
// 807429C: using guessed type int dword_807429C;

//----- (080528D8) --------------------------------------------------------
int __cdecl sub_80528D8(char **a1, char **a2)
{
  return sub_8058DA7(*a1, *a2);
}

//----- (080528F6) --------------------------------------------------------
int __cdecl sub_80528F6(char **a1, char **a2)
{
  return sub_80528D8(a1, a2);
}

//----- (08052910) --------------------------------------------------------
int __cdecl sub_8052910(char **a1, char **a2)
{
  return sub_80528D8(a2, a1);
}

//----- (0805292A) --------------------------------------------------------
int __cdecl sub_805292A(char **a1, char **a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_805113F(a1);
  v4 = sub_805113F(a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_80528D8(a1, a2);
}
// 805113F: using guessed type _DWORD __cdecl sub_805113F(_DWORD);

//----- (08052990) --------------------------------------------------------
#error "80529EF: call analysis failed (funcsize=54)"

//----- (08052A31) --------------------------------------------------------
int sub_8052A31()
{
  int result; // eax
  unsigned int i; // [esp+Ch] [ebp-8h]

  for ( i = 0; ; ++i )
  {
    result = dword_80749DC;
    if ( i >= dword_80749DC )
      break;
    *((_DWORD *)dword_80749E4 + i) = (char *)dword_80749D4 + 136 * i;
  }
  return result;
}
// 80749DC: using guessed type int dword_80749DC;

//----- (08052A9B) --------------------------------------------------------
int sub_8052A9B()
{
  void *v0; // eax
  int v2; // [esp+0h] [ebp-28h]
  int v3; // [esp+4h] [ebp-24h]
  int v4; // [esp+8h] [ebp-20h]
  int v5; // [esp+Ch] [ebp-1Ch]
  int v6; // [esp+10h] [ebp-18h]
  int v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+18h] [ebp-10h]

  if ( dword_80749DC + ((unsigned int)dword_80749DC >> 1) > dword_80749E8 )
  {
    free(dword_80749E4);
    dword_80749E4 = (void *)sub_806384D(dword_80749DC, 0xCu);
    dword_80749E8 = 3 * dword_80749DC;
  }
  sub_8052A31();
  v0 = &loc_8052B2B;
  if ( dword_8074A34 != -1 )
    v0 = &loc_8052B30;
  dword_8074238 = (int)v0;
  return sub_8067B80(v2, v3, v4, v5, v6, v7, v8);
}
// 8067B80: using guessed type int __stdcall sub_8067B80(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8074238: using guessed type int dword_8074238;
// 80749DC: using guessed type int dword_80749DC;
// 80749E8: using guessed type int dword_80749E8;
// 8074A34: using guessed type int dword_8074A34;

//----- (08052C06) --------------------------------------------------------
int __usercall sub_8052C06@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>)
{
  int result; // eax
  unsigned int j; // [esp+1Ch] [ebp-Ch]
  unsigned int i; // [esp+1Ch] [ebp-Ch]

  result = dword_8074A2C;
  switch ( dword_8074A2C )
  {
    case 0:
      for ( i = 0; ; ++i )
      {
        result = dword_80749DC;
        if ( i >= dword_80749DC )
          break;
        sub_804BF5D(a2, a1);
        sub_805320E(*((_DWORD *)dword_80749E4 + i));
        putchar_unlocked(10);
        ++dword_8074B44;
      }
      break;
    case 1:
      for ( j = 0; ; ++j )
      {
        result = dword_80749DC;
        if ( j >= dword_80749DC )
          break;
        sub_8054E94(4 * j, a2, a3, *((_DWORD *)dword_80749E4 + j), 0);
        putchar_unlocked(10);
      }
      break;
    case 2:
      if ( dword_8074A8C )
        result = sub_8055BF6(a3);
      else
        result = sub_8055EB8(a2, a3, 32);
      break;
    case 3:
      if ( dword_8074A8C )
        result = sub_8055D3E();
      else
        result = sub_8055EB8(a2, a3, 32);
      break;
    case 4:
      result = sub_8055EB8(a2, a3, 44);
      break;
    default:
      return result;
  }
  return result;
}
// 805320E: using guessed type _DWORD __cdecl sub_805320E(_DWORD);
// 8055D3E: using guessed type int sub_8055D3E(void);
// 80749DC: using guessed type int dword_80749DC;
// 8074A2C: using guessed type int dword_8074A2C;
// 8074A8C: using guessed type int dword_8074A8C;
// 8074B44: using guessed type int dword_8074B44;

//----- (08052D06) --------------------------------------------------------
int __cdecl sub_8052D06(int a1, int a2, unsigned __int8 a3, int a4, int a5, int a6)
{
  char *v6; // eax

  if ( byte_8075910 )
    v6 = (char *)(((*(_DWORD *)(a4 + 16) + 12 * a3) << 7) + 134696208);
  else
    v6 = (&off_80743F0)[a3];
  return sub_805D7D8(a1, a2, (int)v6, a4, a5, a6);
}
// 8075910: using guessed type char byte_8075910;

//----- (08052D9A) --------------------------------------------------------
int __usercall sub_8052D9A@<eax>(int a1@<ebx>)
{
  int result; // eax
  unsigned int v2; // ecx
  int v3; // [esp+0h] [ebp-458h]
  int v4; // [esp+4h] [ebp-454h]
  int v5; // [esp+8h] [ebp-450h]

  *(&v3 - 3) = __readgsdword(0x14u);
  if ( dword_80743FC < 0 )
  {
    *(&v3 - 267) = 0;
    if ( sub_8065C0B(dword_8074A90, &v3 - 267, (struct tm *)(&v3 - 265)) )
    {
      *(&v3 - 266) = sub_8052D06((int)&v3 - 1013, 1001, 0, (int)(&v3 - 265), dword_8074A90, 0);
      if ( *(&v3 - 266) )
      {
        v5 = 0;
        v4 = *(&v3 - 266);
        dword_80743FC = sub_805CF3E(a1, (char *)&v3 - 1013, v4, 0);
      }
    }
    if ( dword_80743FC < 0 )
      dword_80743FC = 0;
  }
  result = dword_80743FC;
  v2 = __readgsdword(0x14u) ^ *(&v3 - 3);
  return result;
}
// 80743FC: using guessed type int dword_80743FC;

//----- (08052EAE) --------------------------------------------------------
#error "8052F4F: call analysis failed (funcsize=62)"

//----- (08052F8B) --------------------------------------------------------
int __usercall sub_8052F8B@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, unsigned __int8 a5)
{
  char *v5; // eax
  int uid; // [esp+8h] [ebp-14h]
  int v8; // [esp+Ch] [ebp-10h]

  LOBYTE(v8) = a5;
  if ( a5 ^ 1 )
  {
    v5 = "?";
  }
  else if ( byte_8074A3A )
  {
    v5 = 0;
  }
  else
  {
    v5 = (char *)sub_805C219(a1, a2, uid);
  }
  return sub_8052EAE(v5, v8, v8);
}
// 8074A3A: using guessed type char byte_8074A3A;

//----- (08052FF6) --------------------------------------------------------
#error "805304E: call analysis failed (funcsize=35)"

//----- (08053061) --------------------------------------------------------
#error "8053078: call analysis failed (funcsize=18)"

//----- (08053095) --------------------------------------------------------
size_t __usercall sub_8053095@<eax>(int a1@<ebx>, char *a2, int a3)
{
  size_t result; // eax
  int v4; // [esp+1Ch] [ebp-1Ch]
  char s; // [esp+21h] [ebp-17h]
  unsigned int v6; // [esp+2Ch] [ebp-Ch]

  v6 = __readgsdword(0x14u);
  if ( a2 )
  {
    v4 = sub_805CF15(a1, a2, 0);
    result = 0;
    if ( v4 >= 0 )
      result = v4;
  }
  else
  {
    sprintf(&s, "%lu", a3);
    result = strlen(&s);
  }
  return result;
}

//----- (08053113) --------------------------------------------------------
size_t __usercall sub_8053113@<eax>(int a1@<ebx>, int a2@<edx>, int a3@<ecx>, __uid_t uid)
{
  char *v4; // eax

  if ( byte_8074A3A )
    v4 = 0;
  else
    v4 = (char *)sub_805C219(a2, a3, uid);
  return sub_8053095(a1, v4, uid);
}
// 8074A3A: using guessed type char byte_8074A3A;

//----- (08053157) --------------------------------------------------------
size_t __usercall sub_8053157@<eax>(int a1@<ebx>, __gid_t gid)
{
  char *v2; // eax

  if ( byte_8074A3A )
    v2 = 0;
  else
    v2 = (char *)sub_805C462(gid);
  return sub_8053095(a1, v2, gid);
}
// 8074A3A: using guessed type char byte_8074A3A;

//----- (0805318B) --------------------------------------------------------
const char *__cdecl sub_805318B(int a1, unsigned int a2, int a3)
{
  const char *result; // eax

  if ( a2 <= 0x14 )
    __assert_fail("INT_BUFSIZE_BOUND (uintmax_t) <= buflen", "src/ls.c", 0xFA7u, "format_inode");
  if ( *(_BYTE *)(a3 + 120) && *(_QWORD *)(a3 + 100) )
    result = (const char *)sub_805C81F(*(_QWORD *)(a3 + 100), a1);
  else
    result = "?";
  return result;
}

//----- (0805320E) --------------------------------------------------------
#error "8053EBD: call analysis failed (funcsize=650)"

//----- (08053FEA) --------------------------------------------------------
void sub_8053FEA()
{
  ;
}

//----- (08053FF2) --------------------------------------------------------
int __usercall sub_8053FF2@<eax>(int a1@<ebx>, void **a2, unsigned int a3, char *a4, int a5, int a6, unsigned int *a7, _BYTE *a8)
{
  int v8; // edx
  int v9; // ecx
  void *v10; // eax
  char v11; // al
  void *v12; // eax
  void *v13; // eax
  const unsigned __int16 *v14; // ebx
  int v15; // ecx
  int v16; // eax
  bool v17; // zf
  bool v18; // sf
  unsigned __int8 v19; // of
  void *v20; // eax
  int v21; // eax
  char *v22; // eax
  char *v23; // edx
  char *v24; // eax
  char *v25; // eax
  int v26; // edx
  int v27; // ecx
  char *v28; // eax
  unsigned __int8 *v29; // edx
  char *v30; // eax
  void *v31; // edx
  void *v32; // eax
  int result; // eax
  const unsigned __int16 *v34; // [esp-24h] [ebp-90h]
  void *v35; // [esp-20h] [ebp-8Ch]
  int v36; // [esp-1Ch] [ebp-88h]
  char *v37; // [esp-18h] [ebp-84h]
  int v38; // [esp-14h] [ebp-80h]
  int *v39; // [esp-10h] [ebp-7Ch]
  int v40; // [esp-Ch] [ebp-78h]
  int v41; // [esp-8h] [ebp-74h]
  int v42; // [esp-4h] [ebp-70h]
  _BYTE *v43; // [esp+0h] [ebp-6Ch]
  unsigned int *v44; // [esp+4h] [ebp-68h]
  int v45; // [esp+8h] [ebp-64h]
  char *s; // [esp+Ch] [ebp-60h]
  void **v47; // [esp+10h] [ebp-5Ch]
  int v48; // [esp+14h] [ebp-58h]
  int v49; // [esp+18h] [ebp-54h]
  int v50; // [esp+1Ch] [ebp-50h]
  int v51; // [esp+20h] [ebp-4Ch]
  void *dest; // [esp+24h] [ebp-48h]
  unsigned int v53; // [esp+28h] [ebp-44h]
  unsigned int v54; // [esp+2Ch] [ebp-40h]
  char *v55; // [esp+30h] [ebp-3Ch]
  char *v56; // [esp+34h] [ebp-38h]
  int v57; // [esp+38h] [ebp-34h]
  unsigned __int8 *v58; // [esp+3Ch] [ebp-30h]
  int v59; // [esp+44h] [ebp-28h]
  char *v60; // [esp+48h] [ebp-24h]
  int v61; // [esp+4Ch] [ebp-20h]
  unsigned __int8 *v62; // [esp+50h] [ebp-1Ch]
  mbstate_t ps; // [esp+58h] [ebp-14h]
  unsigned int v64; // [esp+60h] [ebp-Ch]
  int v65; // [esp+64h] [ebp-8h]

  v65 = a1;
  v47 = a2;
  s = a4;
  v45 = a5;
  v44 = a7;
  v43 = a8;
  v64 = __readgsdword(0x14u);
  dest = *a2;
  v54 = 0;
  v59 = sub_8060A9C(a5);
  if ( !byte_8074A78 )
    goto LABEL_59;
  v35 = (void *)(unsigned __int8)byte_8074A78;
  v34 = (const unsigned __int16 *)a1;
  v10 = &loc_805407A;
  if ( v59 == 1 )
    v10 = &loc_8054086;
  dword_8074210 = (int)v10;
  a1 = (int)v34;
  sub_8067C60(v9, v8, v36);
  if ( v59 != 2 && v59 )
LABEL_59:
    v11 = 0;
  else
    v11 = 1;
  HIBYTE(v50) = v11 & 1;
  if ( a6 )
  {
    v54 = sub_8061EBA((int)dest, a3, (int)s, -1, v45);
    if ( a3 <= v54 )
    {
      dest = (void *)sub_806399E(v54 + 1);
      sub_8061EBA((int)dest, v54 + 1, (int)s, -1, v45);
    }
    if ( *s != *(_BYTE *)dest || strlen(s) != v54 )
    {
      dword_8074238 = (int)&loc_8054163;
      sub_8067B80(v36, v37, v38, v39, v40, v41, v42);
    }
    v12 = 0;
    BYTE2(v50) = 0;
  }
  else if ( HIBYTE(v50) )
  {
    v54 = strlen(s);
    if ( a3 <= v54 )
      dest = (void *)sub_806399E(v54 + 1);
    v12 = memcpy(dest, s, v54 + 1);
    BYTE2(v50) = 0;
  }
  else
  {
    v54 = strlen(s);
    v12 = s;
    dest = s;
    BYTE2(v50) = 0;
  }
  v35 = v12;
  v34 = (const unsigned __int16 *)a1;
  v13 = &loc_80541F2;
  if ( !HIBYTE(v50) )
    v13 = &loc_805442D;
  dword_8074238 = (int)v13;
  v14 = v34;
  sub_8067B80(v36, v37, v38, v39, v40, v41, v42);
  if ( __ctype_get_mb_cur_max() <= 1 )
  {
    v58 = (unsigned __int8 *)dest;
    v31 = dest;
    v62 = (unsigned __int8 *)dest + v54;
    while ( v58 < v62 )
    {
      v14 = *__ctype_b_loc();
      if ( !(v14[(unsigned __int8)sub_804B134(*v58)] & 0x4000) )
        *v58 = 63;
      ++v58;
    }
    v53 = v54;
  }
  else
  {
    v55 = (char *)dest;
    v60 = (char *)dest + v54;
    v56 = (char *)dest;
    v53 = 0;
    dword_8074224 = (int)&loc_80543B1;
    sub_8067BEE(v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, s, v47, v48, v49, v50);
    do
    {
      v16 = *v55;
      v19 = __OFSUB__(v16, 63);
      v17 = v16 == 63;
      v18 = v16 - 63 < 0;
      v35 = (void *)*v55;
      v34 = v14;
      v20 = &loc_805425C;
      if ( !((unsigned __int8)(v18 ^ v19) | v17) )
        v20 = &loc_805426B;
      dword_8074238 = (int)v20;
      v14 = v34;
      v21 = sub_8067B80(v36, v37, v38, v39, v40, v41, v42);
      if ( v21 < 37 && (unsigned int)(v21 - 32) > 3 )
      {
        ps.__count = 0;
        ps.__wch = 0;
        while ( 1 )
        {
          v39 = &v36 - 5;
          v38 = v60 - v55;
          v37 = v55;
          v57 = sub_8064D1A(v15, (int)(&v36 - 5), (int)(&v36 - 19));
          if ( v57 == -1 )
          {
            ++v55;
            v24 = v56++;
            *v24 = 63;
            ++v53;
            goto LABEL_42;
          }
          if ( v57 == -2 )
            break;
          if ( !v57 )
            v57 = 1;
          v61 = wcwidth(v51);
          if ( v61 >= 0 )
          {
            while ( v57 )
            {
              v28 = v56++;
              v29 = (unsigned __int8 *)v55;
              v27 = (int)(v55++ + 1);
              v26 = *v29;
              *v28 = v26;
              --v57;
            }
            v53 += v61;
            dword_8074210 = (int)&loc_805439C;
            sub_8067C60(v27, v26, v36);
          }
          v55 += v57;
          v30 = v56++;
          *v30 = 63;
          ++v53;
          if ( mbsinit(&ps) )
            goto LABEL_42;
        }
        v55 = v60;
        v25 = v56++;
        *v25 = 63;
        ++v53;
      }
      else
      {
        v22 = v56++;
        v23 = v55;
        v15 = (int)(v55++ + 1);
        *v22 = *v23;
        ++v53;
      }
LABEL_42:
      ;
    }
    while ( v55 < v60 );
    v31 = (void *)(v56 - (_BYTE *)dest);
    v54 = v56 - (_BYTE *)dest;
  }
  if ( byte_80749E1 )
  {
    v35 = (void *)(unsigned __int8)byte_80749E0;
    v34 = v14;
    v32 = &loc_805456B;
    if ( !byte_80749E0 )
      v32 = &loc_805457D;
    dword_8074274 = (int (__fastcall *)(_DWORD, _DWORD))v32;
    v35 = &loc_805456B;
    dword_8074270 = (int)&loc_805456B;
    result = ((int (__fastcall *)(int, void *))v32)(v15, v31);
  }
  else
  {
    *v43 = 0;
    if ( v44 )
      *v44 = v53;
    *v47 = dest;
    result = v54;
  }
  return result;
}
// 8053FF2: could not find valid save-restore pair for ebx
// 8049560: using guessed type int __cdecl wcwidth(_DWORD);
// 8060A9C: using guessed type _DWORD __cdecl sub_8060A9C(_DWORD);
// 8067B80: using guessed type int __stdcall sub_8067B80(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8067BEE: using guessed type int __stdcall sub_8067BEE(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8074210: using guessed type int dword_8074210;
// 8074224: using guessed type int dword_8074224;
// 8074238: using guessed type int dword_8074238;
// 8074270: using guessed type int dword_8074270;
// 8074274: using guessed type int (__fastcall *dword_8074274)(_DWORD, _DWORD);
// 80749E0: using guessed type char byte_80749E0;
// 80749E1: using guessed type char byte_80749E1;
// 8074A78: using guessed type char byte_8074A78;

//----- (080545BF) --------------------------------------------------------
#error "8054638: call analysis failed (funcsize=31)"

//----- (0805463D) --------------------------------------------------------
#error "80546D4: positive sp value has been found (funcsize=38)"

//----- (080546D5) --------------------------------------------------------
char *__cdecl sub_80546D5(char *s, int a2)
{
  size_t v2; // eax
  char *v3; // edx
  char *v4; // ecx
  void *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // edx
  char *v9; // eax
  int v10; // eax
  int v11; // eax
  int v13; // [esp+0h] [ebp-28h]
  int v14; // [esp+8h] [ebp-20h]
  char v15; // [esp+Ch] [ebp-1Ch]
  char *v16; // [esp+18h] [ebp-10h]
  char *v17; // [esp+1Ch] [ebp-Ch]

  v15 = a2;
  v2 = strlen(s);
  v17 = (char *)sub_806384D(3u, v2 + 1);
  v16 = v17;
  while ( *s )
  {
    if ( v15 )
    {
      v5 = &loc_8054736;
      if ( *s != 47 )
        v5 = &loc_805474B;
      dword_8074210 = (int)v5;
      sub_8067C60(v4, v3, v13);
      v6 = v16;
      v3 = v16++ + 1;
      *v6 = 47;
      ++s;
    }
    else
    {
      v13 = *s;
      if ( byte_8074C10[(unsigned __int8)sub_804B134(v13)] )
      {
        v7 = v16++;
        v8 = s;
        v4 = s++ + 1;
        v3 = (char *)(unsigned __int8)*v8;
        *v7 = (char)v3;
      }
      else
      {
        v9 = s++;
        v13 = *v9;
        v10 = (unsigned __int8)sub_804B134(v13);
        v14 = v10;
        v11 = sprintf(v16, "%%%02x", v10);
        v16 += v11;
      }
    }
  }
  *v16 = 0;
  return v17;
}
// 8074210: using guessed type int dword_8074210;

//----- (080547F0) --------------------------------------------------------
int __usercall sub_80547F0@<eax>(int a1@<ebx>, char *a2, int a3, int a4, int a5, char a6, int a7, char *a8)
{
  int *v8; // ebp
  int v9; // eax
  void *v10; // eax
  void *v11; // eax
  int v12; // ebx
  char *v13; // eax
  int v14; // edx
  int v15; // ecx
  bool v16; // zf
  int *v17; // eax
  void *v18; // eax
  int v19; // edx
  int v20; // eax
  int v21; // ebx
  int *v22; // edx
  void *v23; // eax
  int result; // eax
  unsigned int v25; // esi
  int v26; // [esp-8h] [ebp-2084h]
  int v27; // [esp-4h] [ebp-2080h]
  int c; // [esp+0h] [ebp-207Ch]
  void *src; // [esp+4h] [ebp-2078h]
  size_t n; // [esp+8h] [ebp-2074h]
  FILE *stream; // [esp+Ch] [ebp-2070h]
  int v32; // [esp+10h] [ebp-206Ch]
  int v33; // [esp+14h] [ebp-2068h]
  int v34; // [esp+18h] [ebp-2064h]
  int v35; // [esp+1Ch] [ebp-2060h]
  int v36; // [esp+20h] [ebp-205Ch]
  int v37; // [esp+24h] [ebp-2058h]
  char *v38; // [esp+28h] [ebp-2054h]
  int v39; // [esp+2Ch] [ebp-2050h]
  char v40; // [esp+30h] [ebp-204Ch]
  int v41; // [esp+34h] [ebp-2048h]
  int v42; // [esp+38h] [ebp-2044h]
  char *v43; // [esp+3Ch] [ebp-2040h]
  __int16 v44; // [esp+42h] [ebp-203Ah]
  char *v45; // [esp+44h] [ebp-2038h]
  int v46; // [esp+48h] [ebp-2034h]
  char *v47; // [esp+4Ch] [ebp-2030h]
  char *v48; // [esp+50h] [ebp-202Ch]
  int v49; // [esp+6Ch] [ebp-2010h]
  unsigned int v50; // [esp+206Ch] [ebp-10h]
  int v51; // [esp+2078h] [ebp-4h]

  v8 = &v51;
  v43 = a2;
  v42 = a3;
  v41 = a5;
  v40 = a6;
  v39 = a7;
  v38 = a8;
  v50 = __readgsdword(0x14u);
  v45 = (char *)&v49;
  v46 = sub_8053FF2(a1, (void **)&v45, 0x2000u, a2, a3, a4, 0, &v44);
  v9 = (unsigned __int8)v44;
  if ( (_BYTE)v44 && v40 )
  {
    putchar_unlocked(32);
    v9 = dword_8074B44++ + 1;
  }
  if ( v41 )
    v9 = sub_80552DE(v41);
  HIBYTE(v44) = 0;
  v27 = v9;
  v26 = a1;
  v10 = &loc_805490E;
  if ( !v38 )
    v10 = &loc_80549FA;
  dword_807429C = (int)v10;
  sub_806790C(c, src, n, stream, v32, v33, v34, v35, v36, v37, v38);
  v27 = (unsigned __int8)byte_80749E1;
  v11 = &loc_8054932;
  if ( !byte_80749E1 )
    v11 = &loc_8054966;
  dword_8074238 = (int)v11;
  v12 = v26;
  sub_8067B80(c, src, n, stream, v32, v33, v34);
  if ( byte_80749E0 && (_BYTE)v44 != 1 )
  {
    HIBYTE(v44) = 1;
    putchar_unlocked(*v45);
  }
  v47 = sub_80546D5(dword_80749F0, 0);
  v48 = sub_80546D5(v38, 1);
  if ( *v48 == 47 )
  {
    v13 = &locale;
    v8 = &c;
  }
  else
  {
    v13 = "/";
  }
  stream = (FILE *)*(v8 - 2058);
  n = (size_t)v13;
  src = (void *)*(v8 - 2059);
  printf("\x1B]8;;file://%s%s%s\a");
  free((void *)*(v8 - 2059));
  free((void *)*(v8 - 2058));
  v16 = *(v8 - 2067) == 0;
  v27 = (int)v17;
  v26 = v12;
  v18 = &loc_8054A1C;
  if ( v16 )
    v18 = &loc_8054AD2;
  dword_80742B0 = (int)v18;
  sub_806787F(v15, v14, c, src, n, stream);
  if ( byte_8074A4C )
  {
    *(v8 - 2057) = *(v8 - 2067);
    *(v8 - 2056) = 4;
    *(v8 - 2055) = *(v8 - 2057);
    v19 = *(_DWORD *)(*(v8 - 2055) + 16);
    v20 = *(_DWORD *)(*(v8 - 2055) + 12);
    v8 = &c;
    if ( v19 - v20 < (unsigned int)*(&c - 2056) )
      sub_8065193(*(&c - 2057), *(&c - 2056));
    memcpy(*(void **)(*(&c - 2057) + 12), &dword_8074B44, *(&c - 2056));
    *(_DWORD *)(*(&c - 2057) + 12) += *(&c - 2056);
  }
  v21 = *(v8 - 2061);
  fwrite_unlocked(
    (const void *)(v21 + *((unsigned __int8 *)v8 - 8245)),
    1u,
    *(v8 - 2060) - 2 * *((unsigned __int8 *)v8 - 8245),
    stdout);
  dword_8074B44 += *(&c - 2060);
  if ( *(&c - 2067) && byte_8074A4C )
  {
    *(&c - 2054) = *(&c - 2067);
    *(&c - 2053) = 4;
    *(&c - 2052) = *(&c - 2054);
    if ( *(_DWORD *)(*(&c - 2052) + 16) - *(_DWORD *)(*(&c - 2052) + 12) < (unsigned int)*(&c - 2053) )
      sub_8065193(*(&c - 2054), *(&c - 2053));
    memcpy(*(void **)(*(&c - 2054) + 12), &dword_8074B44, *(&c - 2053));
    *(_DWORD *)(*(&c - 2054) + 12) += *(&c - 2053);
  }
  if ( *(&c - 2068) )
  {
    fwrite_unlocked("\x1B]8;;\a", 1u, 6u, stdout);
    if ( *((_BYTE *)&c - 8245) )
      putchar_unlocked(*(char *)(*(&c - 2060) - 1 + *(&c - 2061)));
  }
  v22 = (int *)*(&c - 2061);
  v27 = (int)(&c - 2051);
  v26 = v21;
  v23 = &loc_8054C7E;
  if ( v22 == &c - 2051 )
    v23 = &loc_8054C9A;
  dword_8074238 = (int)v23;
  sub_8067B80(c, src, n, stream, v32, v33, v34);
  if ( *(&c - 2061) != *(&c - 2063) )
    free((void *)*(&c - 2061));
  result = *((unsigned __int8 *)&c - 8246) + *(&c - 2060);
  v25 = __readgsdword(0x14u) ^ *(&c - 3);
  return result;
}
// 80552DE: using guessed type _DWORD __cdecl sub_80552DE(_DWORD);
// 8065193: using guessed type _DWORD __cdecl sub_8065193(_DWORD, _DWORD);
// 806790C: using guessed type int __stdcall sub_806790C(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8067B80: using guessed type int __stdcall sub_8067B80(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8074238: using guessed type int dword_8074238;
// 807429C: using guessed type int dword_807429C;
// 80742B0: using guessed type int dword_80742B0;
// 80749E0: using guessed type char byte_80749E0;
// 80749E1: using guessed type char byte_80749E1;
// 8074A4C: using guessed type char byte_8074A4C;
// 8074B44: using guessed type int dword_8074B44;

//----- (08054CC7) --------------------------------------------------------
int __usercall sub_8054CC7@<eax>(int a1@<edx>, int a2@<ecx>, char **a3, char a4, int a5, unsigned int a6)
{
  char *v6; // eax
  int v7; // eax
  void *v8; // eax
  int v9; // edx
  int v10; // ecx
  char v11; // al
  char *v12; // edx
  int v14; // [esp+0h] [ebp-48h]
  _BOOL4 v15; // [esp+10h] [ebp-38h]
  char *v16; // [esp+18h] [ebp-30h]
  char v17; // [esp+1Ch] [ebp-2Ch]
  int v18; // [esp+20h] [ebp-28h]
  char *v19; // [esp+24h] [ebp-24h]
  int v20; // [esp+28h] [ebp-20h]
  int v21; // [esp+2Ch] [ebp-1Ch]

  v17 = a4;
  if ( a4 )
    v6 = a3[1];
  else
    v6 = *a3;
  v19 = v6;
  if ( byte_8074A54 )
    v7 = sub_8055344(a1, a2, (int)a3, v17);
  else
    v7 = 0;
  v20 = v7;
  if ( !byte_8074A54 )
    goto LABEL_20;
  v8 = &loc_8054D3E;
  if ( v20 )
    v8 = &loc_8054D4E;
  dword_8074288 = (int)v8;
  sub_8067999(a2, a1, v14);
  if ( (unsigned __int8)sub_804BE9C(v9, v10, 4) )
    v11 = 1;
  else
LABEL_20:
    v11 = 0;
  HIBYTE(v18) = v11 & 1;
  v12 = a3[33];
  v16 = a3[2];
  v15 = v17 == 0;
  v21 = sub_80547F0(a5, v19, dword_8074A7C, (int)v12, v20, v15, a5, v16);
  sub_804C094();
  if ( HIBYTE(v18) )
  {
    sub_8054E34();
    if ( dword_8074A8C )
    {
      if ( a6 / dword_8074A8C != (a6 + v21 - 1) / dword_8074A8C )
        sub_80558EB(&unk_80743E8);
    }
  }
  return v21;
}
// 804C094: using guessed type int sub_804C094(void);
// 8054E34: using guessed type int sub_8054E34(void);
// 80558EB: using guessed type _DWORD __cdecl sub_80558EB(_DWORD);
// 8074288: using guessed type int dword_8074288;
// 8074A54: using guessed type char byte_8074A54;
// 8074A7C: using guessed type int dword_8074A7C;
// 8074A8C: using guessed type int dword_8074A8C;

//----- (08054E34) --------------------------------------------------------
#error "8054E61: call analysis failed (funcsize=26)"

//----- (08054E94) --------------------------------------------------------
int __usercall sub_8054E94@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, int a4, unsigned int a5)
{
  const char *v5; // edx
  int v6; // eax
  void *v7; // eax
  int v8; // eax
  int v9; // edx
  int v10; // edx
  int v11; // ecx
  int v12; // edx
  int v13; // edx
  unsigned __int8 v14; // al
  bool v15; // al
  int v17; // [esp-8h] [ebp-2E0h]
  int v18; // [esp-4h] [ebp-2DCh]
  int v19; // [esp+0h] [ebp-2D8h]
  int v20; // [esp+4h] [ebp-2D4h]
  const char *v21; // [esp+8h] [ebp-2D0h]
  int v22; // [esp+Ch] [ebp-2CCh]
  int v23; // [esp+10h] [ebp-2C8h]
  int v24; // [esp+14h] [ebp-2C4h]
  __int64 v25; // [esp+18h] [ebp-2C0h]
  int v26; // [esp+20h] [ebp-2B8h]
  int v27; // [esp+24h] [ebp-2B4h]
  int v28; // [esp+28h] [ebp-2B0h]
  int v29; // [esp+2Ch] [ebp-2ACh]
  int v30; // [esp+30h] [ebp-2A8h]
  int v31; // [esp+34h] [ebp-2A4h]
  int v32; // [esp+38h] [ebp-2A0h]
  int v33; // [esp+3Ch] [ebp-29Ch]
  char v34; // [esp+40h] [ebp-298h]
  int v35; // [esp+44h] [ebp-294h]
  int v36; // [esp+48h] [ebp-290h]
  int v37; // [esp+4Ch] [ebp-28Ch]
  int v38; // [esp+50h] [ebp-288h]
  int v39; // [esp+54h] [ebp-284h]
  int v40; // [esp+58h] [ebp-280h]
  int v41; // [esp+5Ch] [ebp-27Ch]
  int v42; // [esp+60h] [ebp-278h]
  int v43; // [esp+64h] [ebp-274h]
  unsigned int v44; // [esp+2CCh] [ebp-Ch]

  v29 = a4;
  v44 = __readgsdword(0x14u);
  sub_804BF5D(a2, a1);
  if ( byte_8074A61 )
  {
    v5 = sub_805318B((int)&v34, 0x28Cu, v29);
    if ( dword_8074A2C == 4 )
      v6 = 0;
    else
      v6 = dword_8074A04;
    v21 = v5;
    v20 = v6;
    printf("%*s ", v6);
  }
  v18 = (unsigned __int8)byte_8074A3B;
  v17 = a3;
  v7 = &loc_8054F43;
  if ( !byte_8074A3B )
    v7 = &loc_805500E;
  dword_80741DC = (int)v7;
  sub_8067DA4(v19, v20, v21, v22, v23, v24, v25, HIDWORD(v25), v26, v27, v28);
  if ( *(_BYTE *)(v29 + 120) != 1 )
  {
    dword_807424C = (int)&loc_8054FD0;
    sub_8067B12(
      v19,
      v20,
      v21,
      v22,
      v23,
      v24,
      v25,
      HIDWORD(v25),
      v26,
      v27,
      v28,
      v29,
      v30,
      v31,
      v32,
      v33,
      *(_DWORD *)&v34,
      v35,
      v36,
      v37,
      v38,
      v39,
      v40,
      v41,
      v42,
      v43);
  }
  v8 = sub_805B1E2(
         *(_DWORD *)(v29 + 68),
         *(_DWORD *)(v29 + 72),
         &v19 - 166,
         dword_8074A3C,
         512,
         0,
         qword_8074A40,
         HIDWORD(qword_8074A40));
  if ( dword_8074A2C == 4 )
    v9 = 0;
  else
    v9 = dword_8074A08;
  v21 = (const char *)v8;
  v20 = v9;
  printf("%*s ", v9);
  if ( byte_8074A00 )
  {
    v12 = *(_DWORD *)(v29 + 116);
    if ( dword_8074A2C != 4 )
    {
      dword_8074224 = (int)&loc_805504D;
      sub_8067BEE(v19, v20, v21, v22, v23, v24, v25, HIDWORD(v25), v26, v27, v28, v29, v30, v31, v32);
    }
    v21 = (const char *)v12;
    v20 = 0;
    printf("%*s ", 0, v12);
  }
  v33 = sub_8054CC7(v10, v11, (char **)v29, 0, 0, a5);
  if ( dword_8074A50 )
  {
    v13 = *(_DWORD *)(v29 + 28);
    v14 = *(_BYTE *)(v29 + 120);
    v21 = *(const char **)(v29 + 108);
    v15 = sub_8055279(v14, v13, (int)v21);
    v33 += v15;
  }
  return v33;
}
// 805B1E2: using guessed type _DWORD __cdecl sub_805B1E2(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8067B12: using guessed type int __stdcall sub_8067B12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8067BEE: using guessed type int __stdcall sub_8067BEE(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8067DA4: using guessed type int __stdcall sub_8067DA4(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80741DC: using guessed type int dword_80741DC;
// 8074224: using guessed type int dword_8074224;
// 807424C: using guessed type int dword_807424C;
// 8074A00: using guessed type char byte_8074A00;
// 8074A04: using guessed type int dword_8074A04;
// 8074A08: using guessed type int dword_8074A08;
// 8074A2C: using guessed type int dword_8074A2C;
// 8074A3B: using guessed type char byte_8074A3B;
// 8074A3C: using guessed type int dword_8074A3C;
// 8074A40: using guessed type __int64 qword_8074A40;
// 8074A50: using guessed type int dword_8074A50;
// 8074A61: using guessed type char byte_8074A61;

//----- (080550FE) --------------------------------------------------------
#error "8055195: call analysis failed (funcsize=118)"

//----- (08055279) --------------------------------------------------------
bool __cdecl sub_8055279(unsigned __int8 a1, int a2, int a3)
{
  char v4; // [esp+1Fh] [ebp-9h]

  v4 = sub_80550FE(a1, a2, a3);
  if ( v4 )
  {
    putchar_unlocked(v4);
    ++dword_8074B44;
  }
  return v4 != 0;
}
// 80550FE: using guessed type _DWORD __cdecl sub_80550FE(_DWORD, _DWORD, _DWORD);
// 8074B44: using guessed type int dword_8074B44;

//----- (080552DE) --------------------------------------------------------
#error "805530E: call analysis failed (funcsize=29)"

//----- (08055344) --------------------------------------------------------
int __usercall sub_8055344@<eax>(int a1@<edx>, int a2@<ecx>, int a3, char a4)
{
  signed int v4; // eax
  void *v5; // eax
  int v6; // eax
  int v7; // ST24_4
  int result; // eax
  bool v9; // zf
  void *v10; // eax
  int v11; // edx
  int v12; // ecx
  void *v13; // eax
  int v14; // edx
  int v15; // ecx
  void *v16; // eax
  void *v17; // eax
  void *v18; // eax
  int v19; // edx
  int v20; // ecx
  int v21; // [esp+0h] [ebp-38h]
  int v22; // [esp+0h] [ebp-38h]
  int v23; // [esp+0h] [ebp-38h]
  int v24; // [esp+0h] [ebp-38h]
  int v25; // [esp+4h] [ebp-34h]
  int v26; // [esp+4h] [ebp-34h]
  int v27; // [esp+8h] [ebp-30h]
  int v28; // [esp+8h] [ebp-30h]
  int v29[2]; // [esp+Ch] [ebp-2Ch]
  int v30; // [esp+10h] [ebp-28h]
  int v31; // [esp+14h] [ebp-24h]
  signed int v32; // [esp+14h] [ebp-24h]
  int v33; // [esp+18h] [ebp-20h]
  int i; // [esp+18h] [ebp-20h]
  char *s; // [esp+1Ch] [ebp-1Ch]
  char *sa; // [esp+1Ch] [ebp-1Ch]
  int v37; // [esp+20h] [ebp-18h]
  int v38; // [esp+20h] [ebp-18h]
  char v39; // [esp+20h] [ebp-18h]
  int v40; // [esp+24h] [ebp-14h]
  signed int v41; // [esp+24h] [ebp-14h]
  int v42; // [esp+28h] [ebp-10h]
  size_t v43; // [esp+28h] [ebp-10h]
  int v44; // [esp+2Ch] [ebp-Ch]
  int v45; // [esp+30h] [ebp-8h]
  int v46; // [esp+34h] [ebp-4h]
  int savedregs; // [esp+38h] [ebp+0h]

  LOBYTE(v29[0]) = a4;
  if ( a4 )
  {
    s = *(char **)(a3 + 4);
    v38 = *(_DWORD *)(a3 + 112);
    if ( *(_BYTE *)(a3 + 121) )
      v4 = 0;
    else
      v4 = -1;
    v41 = v4;
  }
  else
  {
    s = *(char **)a3;
    if ( byte_80749EC )
    {
      v5 = &loc_80553C0;
      if ( !*(_BYTE *)(a3 + 121) )
        v5 = &loc_80553C8;
      dword_80741DC = (int)v5;
      sub_8067DA4(v21, v25, v27, v29[0], v30, v31, v33, s, v37, v40, v42);
      v6 = *(_DWORD *)(a3 + 112);
    }
    else
    {
      v6 = *(_DWORD *)(a3 + 28);
    }
    v38 = v6;
    v41 = *(unsigned __int8 *)(a3 + 121);
  }
  if ( v41 == -1 && (unsigned __int8)sub_804BE9C(a1, a2, 12) )
  {
    v32 = 12;
LABEL_60:
    i = 0;
    if ( v32 == 5 )
    {
      v43 = strlen(s);
      sa = &s[v43];
      for ( i = dword_8074A58; i; i = *(_DWORD *)(i + 16) )
      {
        if ( *(_DWORD *)i <= v43 && !strncmp(&sa[-*(_DWORD *)i], *(const char **)(i + 4), *(_DWORD *)i) )
        {
          dword_8074238 = (int)&loc_805586E;
          sub_8067B80(v24, v26, v28, v29[0], v30, v32, i);
        }
      }
    }
    v18 = &loc_805588D;
    if ( v32 != 7 )
      v18 = &loc_80558B5;
    dword_8074260 = (int)v18;
    sub_8067A7F(a2, a1);
    if ( !v41 && (byte_80749EC || (unsigned __int8)sub_804BE9C(v19, v20, 13)) )
      v32 = 13;
    if ( i )
      result = i + 8;
    else
      result = 8 * v32 + 134693680;
    if ( !*(_DWORD *)(result + 4) )
      result = 0;
    return result;
  }
  if ( *(_BYTE *)(a3 + 120) != 1 )
  {
    v7 = dword_8074410[*(_DWORD *)(a3 + 108)];
    dword_8074274 = (int (__fastcall *)(_DWORD, _DWORD))&loc_80557D2;
    dword_8074270 = (int)&loc_80554CE;
    return ((int (__fastcall *)(int, int))loc_80557D2)(a2, a1);
  }
  if ( (v38 & 0xF000) == 0x8000 )
  {
    if ( v38 & 0x800 && (unsigned __int8)sub_804BE9C(a1, a2, 16) )
    {
      v32 = 16;
    }
    else if ( v38 & 0x400 && (unsigned __int8)sub_804BE9C(a1, a2, 17) )
    {
      v32 = 17;
    }
    else
    {
      v9 = (unsigned __int8)sub_804BE9C(a1, a2, 21) == 0;
      v10 = &loc_8055565;
      if ( v9 )
        v10 = &loc_805557C;
      dword_80742C4 = (int)v10;
      sub_8067813(v22, v25, v27, v29[0], v30, 5, v33, s, v38, v41, v42, v44, v45, v46, savedregs);
      if ( *(_BYTE *)(a3 + 128) )
      {
        v32 = 21;
      }
      else if ( v39 & 0x49 )
      {
        v9 = (unsigned __int8)sub_804BE9C(a1, a2, 14) == 0;
        v13 = &loc_80555AF;
        if ( v9 )
          v13 = &loc_80555B8;
        dword_8074260 = (int)v13;
        sub_8067A7F(v12, v11);
        v32 = 14;
      }
      else if ( *(_DWORD *)(a3 + 32) > 1u && (unsigned __int8)sub_804BE9C(a1, a2, 22) )
      {
        v32 = 22;
      }
    }
    goto LABEL_60;
  }
  if ( (v38 & 0xF000) != 0x4000 )
  {
    switch ( v38 & 0xF000 )
    {
      case 40960:
        v32 = 7;
        break;
      case 4096:
        v32 = 8;
        break;
      case 49152:
        v32 = 9;
        break;
      case 24576:
        v32 = 10;
        break;
      case 8192:
        v32 = 11;
        break;
      default:
        v32 = 13;
        break;
    }
    goto LABEL_60;
  }
  v32 = 6;
  if ( !(v38 & 0x200) || !(v38 & 2) )
  {
    if ( v38 & 2 && (unsigned __int8)sub_804BE9C(a1, a2, 19) )
    {
      v32 = 19;
    }
    else if ( v38 & 0x200 )
    {
      v9 = (unsigned __int8)sub_804BE9C(a1, a2, 18) == 0;
      v17 = &loc_8055732;
      if ( v9 )
        v17 = &loc_80557D2;
      dword_80742C4 = (int)v17;
      sub_8067813(v23, v25, v27, v29[0], v30, 6, v33, s, v38, v41, v42, v44, v45, v46, savedregs);
      v32 = 18;
    }
    goto LABEL_60;
  }
  v9 = (unsigned __int8)sub_804BE9C(a1, a2, 20) == 0;
  v16 = &loc_80556CD;
  if ( v9 )
    v16 = &loc_80556D6;
  dword_8074274 = (int (__fastcall *)(_DWORD, _DWORD))v16;
  dword_8074270 = (int)&loc_80556CD;
  return ((int (__fastcall *)(int, int))v16)(v15, v14);
}
// 8067813: using guessed type int __stdcall sub_8067813(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8067A7F: using guessed type int __fastcall sub_8067A7F(_DWORD, _DWORD);
// 8067B80: using guessed type int __stdcall sub_8067B80(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8067DA4: using guessed type int __stdcall sub_8067DA4(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80741DC: using guessed type int dword_80741DC;
// 8074238: using guessed type int dword_8074238;
// 8074260: using guessed type int dword_8074260;
// 8074270: using guessed type int dword_8074270;
// 8074274: using guessed type int (__fastcall *dword_8074274)(_DWORD, _DWORD);
// 80742C4: using guessed type int dword_80742C4;
// 80749EC: using guessed type char byte_80749EC;
// 8074A58: using guessed type int dword_8074A58;

//----- (080558EB) --------------------------------------------------------
#error "805593C: call analysis failed (funcsize=39)"

//----- (08055982) --------------------------------------------------------
#error "8055A8A: call analysis failed (funcsize=141)"

//----- (08055BF6) --------------------------------------------------------
unsigned int __usercall sub_8055BF6@<eax>(int a1@<ebx>)
{
  int v1; // ecx
  int v2; // eax
  unsigned int result; // eax
  unsigned int i; // [esp+18h] [ebp-30h]
  int v5; // [esp+1Ch] [ebp-2Ch]
  unsigned int v6; // [esp+20h] [ebp-28h]
  unsigned int j; // [esp+24h] [ebp-24h]
  unsigned int v8; // [esp+28h] [ebp-20h]
  char *v9; // [esp+2Ch] [ebp-1Ch]
  unsigned int v10; // [esp+30h] [ebp-18h]
  int v11; // [esp+34h] [ebp-14h]
  int v12; // [esp+38h] [ebp-10h]
  int v13; // [esp+3Ch] [ebp-Ch]

  v8 = sub_8056397(1);
  v9 = (char *)dword_8074B3C + 12 * v8 - 12;
  v10 = dword_80749DC / v8 + (dword_80749DC % v8 != 0);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v10 )
      break;
    v5 = 0;
    v6 = i;
    for ( j = 0; ; j += v13 )
    {
      v11 = *((_DWORD *)dword_80749E4 + v6);
      v12 = sub_8055982(v11);
      v1 = *((_DWORD *)v9 + 2);
      v2 = v5++;
      v13 = *(_DWORD *)(v1 + 4 * v2);
      sub_8054E94(v5, v1, a1, v11, j);
      v6 += v10;
      if ( v6 >= dword_80749DC )
        break;
      sub_8055FC5(j + v12, v13 + j);
    }
    putchar_unlocked(10);
  }
  return result;
}
// 8055982: using guessed type int __cdecl sub_8055982(_DWORD);
// 8055FC5: using guessed type _DWORD __cdecl sub_8055FC5(_DWORD, _DWORD);
// 8056397: using guessed type _DWORD __cdecl sub_8056397(_DWORD);
// 80749DC: using guessed type int dword_80749DC;

//----- (08055D3E) --------------------------------------------------------
#error "8055D7F: call analysis failed (funcsize=19)"

//----- (08055D84) --------------------------------------------------------
#error "8055EB7: positive sp value has been found (funcsize=78)"

//----- (08055EB8) --------------------------------------------------------
int __usercall sub_8055EB8@<eax>(int a1@<ecx>, int a2@<ebx>, char a3)
{
  int v3; // edx
  int v4; // eax
  void *v5; // eax
  int v7; // [esp+0h] [ebp-38h]
  int v8; // [esp+4h] [ebp-34h]
  int v9; // [esp+8h] [ebp-30h]
  _DWORD v10[4]; // [esp+Ch] [ebp-2Ch]
  int v11; // [esp+10h] [ebp-28h]
  int v12; // [esp+14h] [ebp-24h]
  int v13; // [esp+18h] [ebp-20h]
  int v14; // [esp+1Ch] [ebp-1Ch]
  unsigned int i; // [esp+20h] [ebp-18h]
  unsigned int v16; // [esp+24h] [ebp-14h]
  unsigned int v17; // [esp+24h] [ebp-14h]
  int v18; // [esp+28h] [ebp-10h]
  int v19; // [esp+2Ch] [ebp-Ch]
  int v20; // [esp+30h] [ebp-8h]
  int v21; // [esp+34h] [ebp-4h]
  int savedregs; // [esp+38h] [ebp+0h]

  LOBYTE(v10[0]) = a3;
  v16 = 0;
  for ( i = 0; i < dword_80749DC; ++i )
  {
    v3 = 4 * i;
    v18 = *((_DWORD *)dword_80749E4 + i);
    if ( dword_8074A8C )
      v4 = sub_8055982(v18);
    else
      v4 = 0;
    v19 = v4;
    if ( i )
    {
      v5 = &loc_8055F3F;
      if ( !dword_8074A8C )
        v5 = &loc_8055F60;
      dword_8074224 = (int)v5;
      sub_8067BEE(v7, v8, v9, v10[0], v11, v12, v13, v14, i, v16, v18, v19, v20, v21, savedregs);
      if ( v17 + v19 + 2 >= dword_8074A8C || -3 - v19 < v17 )
      {
        v16 = 0;
        HIBYTE(v14) = 10;
      }
      else
      {
        v16 = v17 + 2;
        HIBYTE(v14) = 32;
      }
      putchar_unlocked(SLOBYTE(v10[0]));
      putchar_unlocked(SHIBYTE(v14));
    }
    sub_8054E94(v3, a1, a2, v18, v16);
    v16 += v19;
  }
  return putchar_unlocked(10);
}
// 8055982: using guessed type int __cdecl sub_8055982(_DWORD);
// 8067BEE: using guessed type int __stdcall sub_8067BEE(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8074224: using guessed type int dword_8074224;
// 80749DC: using guessed type int dword_80749DC;
// 8074A8C: using guessed type int dword_8074A8C;

//----- (08055FC5) --------------------------------------------------------
#error "8056002: call analysis failed (funcsize=38)"

//----- (0805608D) --------------------------------------------------------
#error "80560D5: call analysis failed (funcsize=77)"

//----- (08056175) --------------------------------------------------------
unsigned int sub_8056175()
{
  unsigned int v0; // eax
  unsigned int result; // eax
  unsigned int i; // [esp+10h] [ebp-28h]
  unsigned int j; // [esp+10h] [ebp-28h]
  unsigned int v4; // [esp+14h] [ebp-24h]
  int v5; // [esp+18h] [ebp-20h]
  unsigned int k; // [esp+1Ch] [ebp-1Ch]
  unsigned int v7; // [esp+20h] [ebp-18h]
  unsigned int v8; // [esp+2Ch] [ebp-Ch]

  v0 = dword_8074B40;
  if ( dword_80749DC <= (unsigned int)dword_8074B40 )
    v0 = dword_80749DC;
  v7 = v0;
  if ( dword_80759E8 < v0 )
  {
    if ( (unsigned int)dword_8074B40 >> 1 <= v0 )
    {
      dword_8074B3C = sub_806388B(dword_8074B3C, dword_8074B40, 12);
      v4 = dword_8074B40;
    }
    else
    {
      dword_8074B3C = sub_806388B(dword_8074B3C, v0, 24);
      v4 = 2 * v7;
    }
    v8 = (v4 - dword_80759E8) * (dword_80759E8 + v4 + 1);
    if ( dword_80759E8 + v4 + 1 < v4 || v8 / (v4 - dword_80759E8) != dword_80759E8 + v4 + 1 )
      sub_8063B5E();
    v5 = sub_806384D(v8 >> 1, 4u);
    for ( i = dword_80759E8; i < v4; ++i )
    {
      *((_DWORD *)dword_8074B3C + 3 * i + 2) = v5;
      v5 += 4 * (i + 1);
    }
    dword_80759E8 = v4;
  }
  for ( j = 0; ; ++j )
  {
    result = j;
    if ( j >= v7 )
      break;
    *((_BYTE *)dword_8074B3C + 12 * j) = 1;
    *((_DWORD *)dword_8074B3C + 3 * j + 1) = 3 * (j + 1);
    for ( k = 0; k <= j; ++k )
      *(_DWORD *)(4 * k + *((_DWORD *)dword_8074B3C + 3 * j + 2)) = 3;
  }
  return result;
}
// 80749DC: using guessed type int dword_80749DC;
// 80759E8: using guessed type int dword_80759E8;

//----- (08056397) --------------------------------------------------------
#error "80564C0: call analysis failed (funcsize=124)"

//----- (08056638) --------------------------------------------------------
void __cdecl __noreturn sub_8056638(int status)
{
  int v1; // ebx
  char *v2; // eax
  int v3; // ebx
  char *v4; // eax
  FILE *v5; // ebx
  char *v6; // eax
  FILE *v7; // ebx
  char *v8; // eax
  FILE *v9; // ebx
  char *v10; // eax
  FILE *v11; // ebx
  char *v12; // eax
  FILE *v13; // ebx
  char *v14; // eax
  FILE *v15; // ebx
  char *v16; // eax
  FILE *v17; // ebx
  char *v18; // eax
  FILE *v19; // ebx
  char *v20; // eax
  FILE *v21; // ebx
  char *v22; // eax
  FILE *v23; // ebx
  char *v24; // eax
  FILE *v25; // ebx
  char *v26; // eax
  FILE *v27; // ebx
  char *v28; // eax
  FILE *v29; // ebx
  char *v30; // eax
  FILE *v31; // ebx
  char *v32; // eax
  FILE *v33; // ebx
  char *v34; // eax
  FILE *v35; // ebx
  char *v36; // eax
  FILE *v37; // ebx
  char *v38; // eax
  FILE *v39; // ebx
  char *v40; // eax
  FILE *v41; // ebx
  char *v42; // eax
  FILE *v43; // ebx
  char *v44; // eax
  FILE *v45; // ebx
  char *v46; // eax
  FILE *v47; // ebx
  char *v48; // eax
  FILE *v49; // ebx
  char *v50; // eax
  FILE *v51; // ebx
  char *v52; // eax
  int v53; // edx
  int v54; // ecx
  const char *v55; // eax
  int v56; // [esp+0h] [ebp-18h]

  if ( status )
  {
    v1 = dword_8075A04;
    v2 = gettext("Try '%s --help' for more information.\n");
    fprintf(stderr, v2, v1);
  }
  else
  {
    v3 = dword_8075A04;
    v4 = gettext("Usage: %s [OPTION]... [FILE]...\n");
    printf(v4, v3);
    v5 = stdout;
    v6 = gettext(
           "List information about the FILEs (the current directory by default).\n"
           "Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.\n");
    fputs_unlocked(v6, v5);
    sub_804B209();
    v7 = stdout;
    v8 = gettext(
           "  -a, --all                  do not ignore entries starting with .\n"
           "  -A, --almost-all           do not list implied . and ..\n"
           "      --author               with -l, print the author of each file\n"
           "  -b, --escape               print C-style escapes for nongraphic characters\n");
    fputs_unlocked(v8, v7);
    v9 = stdout;
    v10 = gettext(
            "      --block-size=SIZE      scale sizes by SIZE before printing them; e.g.,\n"
            "                               '--block-size=M' prints sizes in units of\n"
            "                               1,048,576 bytes; see SIZE format below\n"
            "  -B, --ignore-backups       do not list implied entries ending with ~\n"
            "  -c                         with -lt: sort by, and show, ctime (time of last\n"
            "                               modification of file status information);\n"
            "                               with -l: show ctime and sort by name;\n"
            "                               otherwise: sort by ctime, newest first\n");
    fputs_unlocked(v10, v9);
    v11 = stdout;
    v12 = gettext(
            "  -C                         list entries by columns\n"
            "      --color[=WHEN]         colorize the output; WHEN can be 'always' (default\n"
            "                               if omitted), 'auto', or 'never'; more info below\n"
            "  -d, --directory            list directories themselves, not their contents\n"
            "  -D, --dired                generate output designed for Emacs' dired mode\n");
    fputs_unlocked(v12, v11);
    v13 = stdout;
    v14 = gettext(
            "  -f                         do not sort, enable -aU, disable -ls --color\n"
            "  -F, --classify             append indicator (one of */=>@|) to entries\n"
            "      --file-type            likewise, except do not append '*'\n"
            "      --format=WORD          across -x, commas -m, horizontal -x, long -l,\n"
            "                               single-column -1, verbose -l, vertical -C\n"
            "      --full-time            like -l --time-style=full-iso\n");
    fputs_unlocked(v14, v13);
    v15 = stdout;
    v16 = gettext("  -g                         like -l, but do not list owner\n");
    fputs_unlocked(v16, v15);
    v17 = stdout;
    v18 = gettext(
            "      --group-directories-first\n"
            "                             group directories before files;\n"
            "                               can be augmented with a --sort option, but any\n"
            "                               use of --sort=none (-U) disables grouping\n");
    fputs_unlocked(v18, v17);
    v19 = stdout;
    v20 = gettext(
            "  -G, --no-group             in a long listing, don't print group names\n"
            "  -h, --human-readable       with -l and/or -s, print human readable sizes\n"
            "                               (e.g., 1K 234M 2G)\n"
            "      --si                   likewise, but use powers of 1000 not 1024\n");
    fputs_unlocked(v20, v19);
    v21 = stdout;
    v22 = gettext(
            "  -H, --dereference-command-line\n"
            "                             follow symbolic links listed on the command line\n"
            "      --dereference-command-line-symlink-to-dir\n"
            "                             follow each command line symbolic link\n"
            "                               that points to a directory\n"
            "      --hide=PATTERN         do not list implied entries matching shell PATTERN\n"
            "                               (overridden by -a or -A)\n");
    fputs_unlocked(v22, v21);
    v23 = stdout;
    v24 = gettext(
            "      --hyperlink[=WHEN]     hyperlink file names; WHEN can be 'always'\n"
            "                               (default if omitted), 'auto', or 'never'\n");
    fputs_unlocked(v24, v23);
    v25 = stdout;
    v26 = gettext(
            "      --indicator-style=WORD  append indicator with style WORD to entry names:\n"
            "                               none (default), slash (-p),\n"
            "                               file-type (--file-type), classify (-F)\n"
            "  -i, --inode                print the index number of each file\n"
            "  -I, --ignore=PATTERN       do not list implied entries matching shell PATTERN\n"
            "  -k, --kibibytes            default to 1024-byte blocks for disk usage\n");
    fputs_unlocked(v26, v25);
    v27 = stdout;
    v28 = gettext(
            "  -l                         use a long listing format\n"
            "  -L, --dereference          when showing file information for a symbolic\n"
            "                               link, show information for the file the link\n"
            "                               references rather than for the link itself\n"
            "  -m                         fill width with a comma separated list of entries\n");
    fputs_unlocked(v28, v27);
    v29 = stdout;
    v30 = gettext(
            "  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs\n"
            "  -N, --literal              print entry names without quoting\n"
            "  -o                         like -l, but do not list group information\n"
            "  -p, --indicator-style=slash\n"
            "                             append / indicator to directories\n");
    fputs_unlocked(v30, v29);
    v31 = stdout;
    v32 = gettext(aQHideControlCh);
    fputs_unlocked(v32, v31);
    v33 = stdout;
    v34 = gettext(
            "  -r, --reverse              reverse order while sorting\n"
            "  -R, --recursive            list subdirectories recursively\n"
            "  -s, --size                 print the allocated size of each file, in blocks\n");
    fputs_unlocked(v34, v33);
    v35 = stdout;
    v36 = gettext(
            "  -S                         sort by file size, largest first\n"
            "      --sort=WORD            sort by WORD instead of name: none (-U), size (-S),\n"
            "                               time (-t), version (-v), extension (-X)\n"
            "      --time=WORD            with -l, show time as WORD instead of default\n"
            "                               modification time: atime or access or use (-u);\n"
            "                               ctime or status (-c); also use specified time\n"
            "                               as sort key if --sort=time (newest first)\n");
    fputs_unlocked(v36, v35);
    v37 = stdout;
    v38 = gettext(aTimeStyleStyle);
    fputs_unlocked(v38, v37);
    v39 = stdout;
    v40 = gettext(
            "  -t                         sort by modification time, newest first\n"
            "  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8\n");
    fputs_unlocked(v40, v39);
    v41 = stdout;
    v42 = gettext(
            "  -u                         with -lt: sort by, and show, access time;\n"
            "                               with -l: show access time and sort by name;\n"
            "                               otherwise: sort by access time, newest first\n"
            "  -U                         do not sort; list entries in directory order\n"
            "  -v                         natural sort of (version) numbers within text\n");
    fputs_unlocked(v42, v41);
    v43 = stdout;
    v44 = gettext(
            "  -w, --width=COLS           set output width to COLS.  0 means no limit\n"
            "  -x                         list entries by lines instead of by columns\n"
            "  -X                         sort alphabetically by entry extension\n"
            "  -Z, --context              print any security context of each file\n"
            "  -1                         list one file per line.  Avoid '\\n' with -q or -b\n");
    fputs_unlocked(v44, v43);
    v45 = stdout;
    v46 = gettext("      --help     display this help and exit\n");
    fputs_unlocked(v46, v45);
    v47 = stdout;
    v48 = gettext("      --version  output version information and exit\n");
    fputs_unlocked(v48, v47);
    sub_804B238();
    v49 = stdout;
    v50 = gettext(
            "\n"
            "Using color to distinguish file types is disabled both by default and\n"
            "with --color=never.  With --color=auto, ls emits color codes only when\n"
            "standard output is connected to a terminal.  The LS_COLORS environment\n"
            "variable can change the settings.  Use the dircolors command to set it.\n");
    fputs_unlocked(v50, v49);
    v51 = stdout;
    v52 = gettext(
            "\n"
            "Exit status:\n"
            " 0  if OK,\n"
            " 1  if minor problems (e.g., cannot access subdirectory),\n"
            " 2  if serious trouble (e.g., cannot access command-line argument).\n");
    fputs_unlocked(v52, v51);
    if ( dword_8074438 == 1 )
    {
      v55 = "ls";
    }
    else
    {
      if ( dword_8074438 == 2 )
      {
        dword_8074210 = (int)&loc_80569B4;
        sub_8067C60(v54, v53, v56);
      }
      v55 = "vdir";
    }
    sub_804B285(v55);
  }
  exit(status);
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 804B285: using guessed type int __cdecl sub_804B285(_DWORD);
// 8074210: using guessed type int dword_8074210;
// 8074438: using guessed type int dword_8074438;
// 8075A04: using guessed type int dword_8075A04;

//----- (080569C7) --------------------------------------------------------
char *__cdecl sub_80569C7(char *path, int a2)
{
  size_t v2; // eax
  int v3; // edx
  int v4; // ecx
  char *result; // eax
  bool v6; // zf
  int v7; // edx
  int v8; // ecx
  void *v9; // eax
  int v10; // ST3C_4
  int v11; // [esp+0h] [ebp-38h]
  int v12; // [esp+0h] [ebp-38h]
  int v13; // [esp+4h] [ebp-34h]
  int v14; // [esp+8h] [ebp-30h]
  int v15; // [esp+Ch] [ebp-2Ch]
  size_t size; // [esp+10h] [ebp-28h]
  size_t sizea; // [esp+10h] [ebp-28h]
  char *buf; // [esp+20h] [ebp-18h]
  ssize_t v19; // [esp+24h] [ebp-14h]
  int v20; // [esp+2Ch] [ebp-Ch]
  int v21; // [esp+30h] [ebp-8h]
  int v22; // [esp+34h] [ebp-4h]
  int savedregs; // [esp+38h] [ebp+0h]

  if ( (unsigned int)a2 >= 0x401 )
    v2 = 1025;
  else
    v2 = a2 + 1;
  size = v2;
  buf = (char *)malloc(v2);
  if ( !buf )
  {
    dword_8074274 = (int (__fastcall *)(_DWORD, _DWORD))&locret_8056B9E;
    dword_8074270 = (int)&loc_8056ABB;
    return (char *)((int (__fastcall *)(int, int))locret_8056B9E)(v4, v3);
  }
  v19 = readlink(path, buf, size);
  if ( v19 >= 0 )
  {
    if ( v19 < size )
    {
      buf[v19] = 0;
      return buf;
    }
    free(buf);
    if ( size > 0x3FFFFFFF )
    {
      if ( size > 0x7FFFFFFE )
      {
        *__errno_location() = 12;
        return 0;
      }
      sizea = 0x7FFFFFFF;
    }
    else
    {
      sizea = 2 * size;
    }
    dword_80742C4 = (int)&loc_8056A07;
    result = (char *)sub_8067813(v12, v13, v14, v15, sizea, 1024, 0x2000, 1025, buf, v19, v19, v20, v21, v22, savedregs);
  }
  else
  {
    v6 = *__errno_location() == 34;
    v9 = &loc_8056B0C;
    if ( v6 )
      v9 = &loc_8056B32;
    dword_80742B0 = (int)v9;
    sub_806787F(v8, v7, v11, v13, v14, v15);
    v10 = *__errno_location();
    free(buf);
    *__errno_location() = v10;
    result = 0;
  }
  return result;
}
// 8067813: using guessed type int __stdcall sub_8067813(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8074270: using guessed type int dword_8074270;
// 8074274: using guessed type int (__fastcall *dword_8074274)(_DWORD, _DWORD);
// 80742B0: using guessed type int dword_80742B0;
// 80742C4: using guessed type int dword_80742C4;

//----- (08056BA0) --------------------------------------------------------
void __noreturn sub_8056BA0()
{
  sub_8056638(1);
}

//----- (08056BB4) --------------------------------------------------------
int __cdecl sub_8056BB4(char *s, int a2)
{
  bool v2; // zf
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  size_t n; // [esp+1Ch] [ebp-Ch]

  n = strlen(s);
  if ( !*(_DWORD *)a2 )
    return -1;
  v2 = strncmp(*(const char **)a2, s, n) == 0;
  v5 = &loc_8056CB3;
  if ( !v2 )
    v5 = &loc_8056D39;
  dword_8074274 = (int (__fastcall *)(_DWORD, _DWORD))v5;
  dword_8074270 = (int)&loc_8056CB3;
  return ((int (__fastcall *)(int, int))v5)(v4, v3);
}
// 8074270: using guessed type int dword_8074270;
// 8074274: using guessed type int (__fastcall *dword_8074274)(_DWORD, _DWORD);

//----- (08056D68) --------------------------------------------------------
void __cdecl sub_8056D68(int a1, int a2, int a3)
{
  char *v3; // eax
  char *format; // ST2C_4
  int v5; // ebx
  int v6; // eax

  if ( a3 == -1 )
    v3 = gettext("invalid argument %s for %s");
  else
    v3 = gettext("ambiguous argument %s for %s");
  format = v3;
  v5 = sub_80629EC(1, a1);
  v6 = sub_80624F2(0, 8, a2);
  error(0, 0, format, v6, v5);
}

//----- (08056DFD) --------------------------------------------------------
int __cdecl sub_8056DFD(int a1)
{
  FILE *v1; // ebx
  char *v2; // eax
  void *v3; // eax
  int v5; // [esp+0h] [ebp-28h]
  int v6; // [esp+4h] [ebp-24h]
  int v7; // [esp+8h] [ebp-20h]
  int v8; // [esp+Ch] [ebp-1Ch]
  int v9; // [esp+10h] [ebp-18h]
  int v10; // [esp+14h] [ebp-14h]
  int v11; // [esp+20h] [ebp-8h]
  int v12; // [esp+24h] [ebp-4h]
  int savedregs; // [esp+28h] [ebp+0h]

  v1 = stderr;
  v2 = gettext("Valid arguments are:");
  fputs_unlocked(v2, v1);
  v3 = &loc_8056F22;
  if ( *(_DWORD *)a1 )
    v3 = &loc_8056E35;
  dword_80741DC = (int)v3;
  sub_8067DA4(v5, v6, v7, v8, v9, v10, 0, 0, v11, v12, savedregs);
  return putc_unlocked(10, stderr);
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8067DA4: using guessed type int __stdcall sub_8067DA4(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80741DC: using guessed type int dword_80741DC;

//----- (08056F3D) --------------------------------------------------------
int __cdecl sub_8056F3D(int a1, char *s, int a3, int a4, size_t n)
{
  int v6; // [esp+0h] [ebp-28h]
  int v7; // [esp+4h] [ebp-24h]
  int v8; // [esp+8h] [ebp-20h]
  int v9; // [esp+Ch] [ebp-1Ch]
  int v10; // [esp+10h] [ebp-18h]
  int v11; // [esp+14h] [ebp-14h]
  int v12; // [esp+18h] [ebp-10h]
  void (*v13)(void); // [esp+1Ch] [ebp-Ch]

  v9 = n;
  v8 = v11;
  *(&v6 - 3) = sub_8056BB4((char *)n, v10);
  if ( *(&v6 - 3) >= 0 )
    return *(&v6 - 3);
  sub_8056D68(*(&v6 - 3), v9, *(&v6 - 3));
  v8 = v12;
  v7 = v11;
  sub_8056DFD(v10);
  v13();
  return -1;
}

//----- (08057089) --------------------------------------------------------
signed int __cdecl sub_8057089(signed int a1)
{
  if ( a1 > 90 )
  {
    if ( (unsigned int)(a1 - 97) <= 0x19 )
      return 1;
  }
  else if ( a1 >= 65 || (unsigned int)(a1 - 48) <= 9 )
  {
    return 1;
  }
  return 0;
}

//----- (080570CB) --------------------------------------------------------
_BOOL4 __cdecl sub_80570CB(signed int a1)
{
  return a1 >= 65 && (a1 <= 90 || (unsigned int)(a1 - 97) <= 0x19);
}

//----- (08057153) --------------------------------------------------------
_BOOL4 __cdecl sub_8057153(int a1)
{
  return (unsigned int)(a1 - 48) <= 9;
}

//----- (0805729C) --------------------------------------------------------
#error "80572BE: call analysis failed (funcsize=25)"

//----- (080572F7) --------------------------------------------------------
signed int __cdecl sub_80572F7(int *a1, int a2, int *a3)
{
  if ( !*a1 )
  {
    *a1 = sub_8059AC4();
    if ( !*a1 )
      sub_8063B5E();
  }
  if ( sub_805829F(*a1, a2, a3) )
    return 1;
  sub_80581C3(*a1, a2, a3);
  return 0;
}
// 80581C3: using guessed type _DWORD __cdecl sub_80581C3(_DWORD, _DWORD, _DWORD);

//----- (080573B5) --------------------------------------------------------
char *__usercall sub_80573B5@<eax>(int a1@<edx>, int a2@<ecx>, void *src, int a4)
{
  char *result; // eax
  void *v5; // eax
  int v6; // ecx
  int v7; // edx
  char *v8; // eax
  void *v9; // eax
  int v10; // edx
  int v11; // ecx
  void *v12; // eax
  int v13; // [esp+0h] [ebp-C8h]
  int v14; // [esp+0h] [ebp-C8h]
  int v15; // [esp+4h] [ebp-C4h]
  int v16; // [esp+8h] [ebp-C0h]
  int v17; // [esp+Ch] [ebp-BCh]
  int v18; // [esp+10h] [ebp-B8h]
  __int64 v19; // [esp+14h] [ebp-B4h]
  char *s; // [esp+1Ch] [ebp-ACh]
  char *dest; // [esp+20h] [ebp-A8h]
  char *v22; // [esp+28h] [ebp-A0h]
  char *i; // [esp+2Ch] [ebp-9Ch]
  int v24; // [esp+30h] [ebp-98h]

  HIBYTE(v19) = 0;
  *(_DWORD *)((char *)&v19 + 3) = (a4 & 4) != 0;
  if ( a4 & 3 & ((a4 & 3) - 1) )
  {
    *__errno_location() = 22;
    result = 0;
  }
  else if ( src )
  {
    if ( *(_BYTE *)src )
    {
      v5 = &loc_8057499;
      if ( *(_BYTE *)src == 47 )
        v5 = &loc_8057570;
      dword_8074260 = (int)v5;
      sub_8067A7F(a2, a1);
      s = sub_8063E3D();
      if ( s )
      {
        dest = strchr(s, 0);
        v7 = dest - s;
        if ( dest - s > 4095 )
        {
          v24 = (int)dest;
        }
        else
        {
          v8 = (char *)sub_80639FF(s, 0x1000u);
          v7 = dest - s;
          dest = &v8[dest - s];
          s = v8;
          v24 = (int)(v8 + 4096);
        }
        v22 = (char *)src;
        if ( *(_BYTE *)src )
        {
          dword_8074260 = (int)&loc_8057619;
          sub_8067A7F(v6, v7);
          do
            ++v22;
          while ( *v22 == 47 );
          for ( i = v22; *i && *i != 47; ++i )
            ;
          v9 = &loc_805767E;
          if ( i != v22 )
            v9 = &loc_8057683;
          dword_8074238 = (int)v9;
          sub_8067B80(v13, v15, v16, v17, v18, v19, HIDWORD(v19));
        }
        if ( s + 1 < dest && *(dest - 1) == 47 )
          --dest;
        *dest = 0;
        if ( dest + 1 != (char *)v24 )
          s = (char *)sub_80639FF(s, dest - s + 1);
        free(0);
        v12 = &loc_8057D34;
        if ( !HIDWORD(v19) )
          v12 = &loc_8057D42;
        dword_8074210 = (int)v12;
        sub_8067C60(v11, v10, v14);
        sub_8059DB7((void *)HIDWORD(v19));
        result = s;
      }
      else
      {
        result = 0;
      }
    }
    else
    {
      *__errno_location() = 2;
      result = 0;
    }
  }
  else
  {
    *__errno_location() = 22;
    result = 0;
  }
  return result;
}
// 80573B5: could not find valid save-restore pair for ebx
// 8067A7F: using guessed type int __fastcall sub_8067A7F(_DWORD, _DWORD);
// 8067B80: using guessed type int __stdcall sub_8067B80(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8074210: using guessed type int dword_8074210;
// 8074238: using guessed type int dword_8074238;
// 8074260: using guessed type int dword_8074260;

//----- (08057DB6) --------------------------------------------------------
int sub_8057DB6()
{
  bool v0; // zf
  int v1; // edx
  int v2; // ecx
  void *v3; // eax
  int v4; // ebx
  int *v5; // eax
  int v6; // edx
  int v7; // ecx
  int *v9; // eax
  int v10; // edx
  int v11; // ecx
  int (*v12)(); // eax
  int v13; // [esp+0h] [ebp-38h]
  char *v14; // [esp+2Ch] [ebp-Ch]
  void *savedregs; // [esp+38h] [ebp+0h]

  v0 = sub_80660DA(stdout) == 0;
  v3 = &loc_8057DE7;
  if ( v0 )
    v3 = &loc_8057F36;
  dword_8074260 = (int)v3;
  sub_8067A7F(v2, v1);
  if ( byte_80759F0 == 1 && *__errno_location() == 32 )
  {
    v0 = sub_80660DA(stderr) == 0;
    v12 = (int (*)())&loc_8057F60;
    if ( v0 )
      v12 = sub_8057F6D;
    dword_8074288 = (int)v12;
    sub_8067999(v11, v10, v13);
    _exit(status);
  }
  v14 = gettext("write error");
  if ( !dword_80759EC )
  {
    v9 = __errno_location();
    error(0, *v9, "%s", v14);
    _exit(status);
  }
  v4 = sub_8062700(dword_80759EC);
  v5 = __errno_location();
  error(0, *v5, "%s: %s", v4, v14);
  dword_8074274 = (int (__fastcall *)(_DWORD, _DWORD))&loc_8057F29;
  savedregs = &loc_8057EFF;
  dword_8074270 = (int)&loc_8057EFF;
  return ((int (__fastcall *)(int, int))loc_8057F29)(v7, v6);
}
// 8057F6D: using guessed type int sub_8057F6D();
// 8067A7F: using guessed type int __fastcall sub_8067A7F(_DWORD, _DWORD);
// 8074260: using guessed type int dword_8074260;
// 8074270: using guessed type int dword_8074270;
// 8074274: using guessed type int (__fastcall *dword_8074274)(_DWORD, _DWORD);
// 8074288: using guessed type int dword_8074288;
// 80759EC: using guessed type int dword_80759EC;
// 80759F0: using guessed type char byte_80759F0;

//----- (08057F6D) --------------------------------------------------------
#error "8057F70: positive sp value has been found (funcsize=0)"

//----- (08057F73) --------------------------------------------------------
#error "8057F9A: call analysis failed (funcsize=60)"

//----- (0805802F) --------------------------------------------------------
#error "805807E: call analysis failed (funcsize=31)"

//----- (080580E7) --------------------------------------------------------
_BYTE *__usercall sub_80580E7@<eax>(int edx0@<edx>, int a2@<ecx>, _BYTE *a1)
{
  int v4; // [esp+0h] [ebp-10h]
  char v5; // [esp+7h] [ebp-9h]
  _BYTE *v6; // [esp+8h] [ebp-8h]
  _BYTE *v7; // [esp+Ch] [ebp-4h]

  v6 = a1;
  v5 = 0;
  while ( *v6 == 47 )
    ++v6;
  v7 = v6;
  dword_8074210 = (int)&loc_805814C;
  sub_8067C60(a2, edx0, v4);
  do
  {
    if ( *v7 == 47 )
    {
      v5 = 1;
    }
    else if ( v5 )
    {
      v6 = v7;
      v5 = 0;
    }
    ++v7;
  }
  while ( *v7 );
  return v6;
}
// 8074210: using guessed type int dword_8074210;

//----- (0805815B) --------------------------------------------------------
size_t __cdecl sub_805815B(char *s)
{
  size_t i; // [esp+18h] [ebp-10h]

  for ( i = strlen(s); i > 1 && s[i - 1] == 47; --i )
    ;
  return i;
}

//----- (08058199) --------------------------------------------------------
int sub_8058199()
{
  return 0;
}

//----- (080581C3) --------------------------------------------------------
#error "805823F: call analysis failed (funcsize=46)"

//----- (0805829F) --------------------------------------------------------
bool __cdecl sub_805829F(int a1, int a2, int *a3)
{
  int v4; // edx
  int v5; // edx
  int v6; // [esp+0h] [ebp-38h]
  int v7; // [esp+1Ch] [ebp-1Ch]
  int v8; // [esp+20h] [ebp-18h]
  int v9; // [esp+24h] [ebp-14h]
  int v10; // [esp+28h] [ebp-10h]
  int v11; // [esp+2Ch] [ebp-Ch]

  if ( !a1 )
    return 0;
  v7 = a2;
  v4 = a3[23];
  v8 = a3[22];
  v9 = v4;
  v5 = a3[1];
  v10 = *a3;
  v11 = v5;
  return sub_8059428(a1, &v6 - 7) != 0;
}
// 8059428: using guessed type _DWORD __cdecl sub_8059428(_DWORD, _DWORD);

//----- (08058302) --------------------------------------------------------
#error "8058438: call analysis failed (funcsize=55)"

//----- (08058477) --------------------------------------------------------
#error "80584FC: call analysis failed (funcsize=74)"

//----- (0805871C) --------------------------------------------------------
int __cdecl sub_805871C(int a1, int a2)
{
  return sub_8058477(*(_DWORD *)(a1 + 16), a2);
}
// 8058477: using guessed type _DWORD __cdecl sub_8058477(_DWORD, _DWORD);

//----- (08058747) --------------------------------------------------------
#error "8058783: call analysis failed (funcsize=24)"

//----- (08058791) --------------------------------------------------------
#error "8058795: positive sp value has been found (funcsize=0)"

//----- (08058796) --------------------------------------------------------
_BYTE *__cdecl sub_8058796(_BYTE *a1)
{
  while ( *a1 == 47 )
    ++a1;
  return a1;
}

//----- (080587AE) --------------------------------------------------------
int __fastcall sub_80587AE(int a1, int a2)
{
  signed int v3; // eax
  char *v4; // [esp+0h] [ebp-38h]
  _BYTE *v5; // [esp+4h] [ebp-34h]
  _BYTE *v6; // [esp+8h] [ebp-30h]
  _BYTE *v7; // [esp+Ch] [ebp-2Ch]
  char *v8; // [esp+10h] [ebp-28h]
  int v9; // [esp+14h] [ebp-24h]
  int v10; // [esp+18h] [ebp-20h]
  int v11; // [esp+1Ch] [ebp-1Ch]
  char *s; // [esp+20h] [ebp-18h]
  int v13; // [esp+24h] [ebp-14h]
  int v14; // [esp+28h] [ebp-10h]
  int v15; // [esp+2Ch] [ebp-Ch]
  int v16; // [esp+30h] [ebp-8h]
  int v17; // [esp+34h] [ebp-4h]
  int savedregs; // [esp+38h] [ebp+0h]

  *(&v4 - 10) = sub_80580E7(a2, a1, v6);
  v4 = *(&v4 - 10);
  *(&v4 - 9) = (char *)sub_805815B(v4);
  *(&v4 - 8) = &(*(&v4 - 9))[*(&v4 - 10) - v6];
  if ( *(&v4 - 9) && (*(&v4 - 10))[(_DWORD)(*(&v4 - 9) - 1)] != 47 )
  {
    dword_80741F0 = (int)&loc_8058853;
    sub_8067D38(v4, v5, v6, v7, v8, v9, v10, v11, s, v13, v14, v15, v16, v17, savedregs);
  }
  *(&v4 - 7) = 0;
  *(&v4 - 6) = sub_8058796(v7);
  v4 = *(&v4 - 6);
  *(&v4 - 5) = (char *)strlen(v4);
  v4 = &(*(&v4 - 8))[(_DWORD)*(&v4 - 7) + 1 + (unsigned int)*(&v4 - 5)];
  *(&v4 - 4) = (char *)malloc((size_t)v4);
  if ( !*(&v4 - 4) )
    return 0;
  v6 = *(&v4 - 8);
  v5 = v6;
  v4 = *(&v4 - 4);
  *(&v4 - 3) = (char *)mempcpy(v4, v6, v6);
  **(&v4 - 3) = 47;
  *(&v4 - 3) = &(*(&v4 - 3))[(_DWORD)*(&v4 - 7)];
  if ( v8 )
  {
    if ( *v7 == 47 )
      v3 = -1;
    else
      v3 = 0;
    *(_DWORD *)v8 = &(*(&v4 - 3))[v3];
  }
  v6 = *(&v4 - 5);
  v5 = *(&v4 - 6);
  v4 = *(&v4 - 3);
  *(&v4 - 3) = (char *)mempcpy(v4, v5, v6);
  **(&v4 - 3) = 0;
  return (int)*(&v4 - 4);
}
// 80499B0: using guessed type int __cdecl mempcpy(_DWORD, _DWORD, _DWORD);
// 8067D38: using guessed type int __stdcall sub_8067D38(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80741F0: using guessed type int dword_80741F0;

//----- (0805890F) --------------------------------------------------------
_BYTE *__cdecl sub_805890F(_BYTE **a1)
{
  bool v1; // zf
  void *v2; // eax
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  int v7; // [esp+0h] [ebp-28h]
  int v8; // [esp+0h] [ebp-28h]
  int v9; // [esp+4h] [ebp-24h]
  int v10; // [esp+8h] [ebp-20h]
  int v11; // [esp+Ch] [ebp-1Ch]
  int v12; // [esp+10h] [ebp-18h]
  int v13; // [esp+14h] [ebp-14h]
  int v14; // [esp+18h] [ebp-10h]
  _BYTE *v15; // [esp+1Ch] [ebp-Ch]

  v15 = 0;
  HIBYTE(v14) = 0;
  while ( **a1 )
  {
    if ( HIBYTE(v14) )
    {
      HIBYTE(v14) = 0;
      v1 = (unsigned __int8)sub_80570CB((char)**a1) == 1;
      v2 = &loc_8058962;
      if ( v1 )
        v2 = &loc_80589DD;
      dword_8074238 = (int)v2;
      sub_8067B80(v7, v9, v10, v11, v12, v13, v14);
      v5 = &loc_8058987;
      if ( **a1 == 126 )
        v5 = &loc_80589DD;
      dword_8074210 = (int)v5;
      sub_8067C60(v4, v3, v8);
      v15 = 0;
    }
    else if ( **a1 == 46 )
    {
      HIBYTE(v14) = 1;
      if ( !v15 )
        v15 = *a1;
    }
    else if ( (unsigned __int8)sub_8057089((char)**a1) ^ 1 && **a1 != 126 )
    {
      v15 = 0;
    }
    ++*a1;
  }
  return v15;
}
// 805890F: could not find valid save-restore pair for ebx
// 8067B80: using guessed type int __stdcall sub_8067B80(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8074210: using guessed type int dword_8074210;
// 8074238: using guessed type int dword_8074238;

//----- (08058A0D) --------------------------------------------------------
#error "8058B1A: call analysis failed (funcsize=52)"

//----- (08058B2E) --------------------------------------------------------
signed int __cdecl sub_8058B2E(int a1, unsigned int a2, int a3, unsigned int a4)
{
  int v4; // eax
  int v5; // edx
  int v6; // ecx
  int v7; // ST08_4
  bool v9; // zf
  void *v10; // eax
  int v11; // edx
  int v12; // ecx
  int v13; // ST08_4
  int v14; // [esp+0h] [ebp-38h]
  int v15; // [esp+0h] [ebp-38h]
  int v16; // [esp+4h] [ebp-34h]
  int v17; // [esp+4h] [ebp-34h]
  int v18; // [esp+8h] [ebp-30h]
  int v19; // [esp+8h] [ebp-30h]
  int v20; // [esp+Ch] [ebp-2Ch]
  int v21; // [esp+Ch] [ebp-2Ch]
  int v22; // [esp+10h] [ebp-28h]
  int v23; // [esp+10h] [ebp-28h]
  int v24; // [esp+14h] [ebp-24h]
  int v25; // [esp+14h] [ebp-24h]
  int v26; // [esp+18h] [ebp-20h]
  int v27; // [esp+18h] [ebp-20h]
  unsigned int v28; // [esp+1Ch] [ebp-1Ch]
  unsigned int v29; // [esp+20h] [ebp-18h]
  int v30; // [esp+24h] [ebp-14h]
  int v31; // [esp+24h] [ebp-14h]
  int v32; // [esp+28h] [ebp-10h]

  v28 = 0;
  v29 = 0;
  while ( v28 < a2 || v29 < a4 )
  {
    v30 = 0;
    while ( v28 < a2 && (unsigned __int8)sub_8057153(*(char *)(a1 + v28)) ^ 1
         || v29 < a4 && (unsigned __int8)sub_8057153(*(char *)(a3 + v29)) ^ 1 )
    {
      if ( v28 == a2 )
        v4 = 0;
      else
        v4 = sub_8058A0D(*(unsigned __int8 *)(a1 + v28));
      v32 = v4;
      if ( v29 != a4 )
      {
        sub_8058A0D(*(unsigned __int8 *)(a3 + v29));
        dword_8074210 = (int)&loc_8058BB9;
        sub_8067C60(v6, v5, v7);
      }
      if ( v32 )
      {
        dword_80741DC = (int)&locret_8058DA5;
        sub_8067DA4(v14, v16, v18, v20, v22, v24, v26, v28, v29, v30, v32);
      }
      ++v28;
      ++v29;
    }
    while ( *(_BYTE *)(a1 + v28) == 48 )
      ++v28;
    dword_8074238 = (int)&loc_8058C6F;
    sub_8067B80(v14, v16, v18, v20, v22, v24, v26);
    do
      ++v29;
    while ( *(_BYTE *)(a3 + v29) == 48 );
    while ( (unsigned __int8)sub_8057153(*(char *)(a1 + v28)) && (unsigned __int8)sub_8057153(*(char *)(a3 + v29)) )
    {
      if ( !v30 )
        v30 = *(char *)(a1 + v28) - *(char *)(a3 + v29);
      ++v28;
      ++v29;
    }
    if ( (unsigned __int8)sub_8057153(*(char *)(a1 + v28)) )
      return 1;
    v9 = (unsigned __int8)sub_8057153(*(char *)(a3 + v29)) == 0;
    v10 = &loc_8058D4C;
    if ( v9 )
      v10 = &loc_8058D68;
    dword_807429C = (int)v10;
    sub_806790C(v15, v17, v19, v21, v23, v25, v27, v28, v29, v30, v32);
    dword_8074288 = (int)&locret_8058DA5;
    sub_8067999(v12, v11, v13);
    if ( v31 )
    {
      dword_807429C = (int)&locret_8058DA5;
      sub_806790C(v14, v16, v18, v20, v22, v24, v26, v28, v29, v31, v32);
    }
  }
  return 0;
}
// 8058A0D: using guessed type _DWORD __cdecl sub_8058A0D(_DWORD);
// 806790C: using guessed type int __stdcall sub_806790C(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8067B80: using guessed type int __stdcall sub_8067B80(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8067DA4: using guessed type int __stdcall sub_8067DA4(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80741DC: using guessed type int dword_80741DC;
// 8074210: using guessed type int dword_8074210;
// 8074238: using guessed type int dword_8074238;
// 8074288: using guessed type int dword_8074288;
// 807429C: using guessed type int dword_807429C;

//----- (08058DA7) --------------------------------------------------------
int __cdecl sub_8058DA7(char *s1, char *s2)
{
  int result; // eax
  int v3; // edx
  int v4; // ecx
  bool v5; // zf
  void *v6; // eax
  int v7; // [esp+0h] [ebp-38h]
  int v8; // [esp+4h] [ebp-34h]
  int v9; // [esp+8h] [ebp-30h]
  int v10; // [esp+Ch] [ebp-2Ch]
  int v11; // [esp+10h] [ebp-28h]
  int v12; // [esp+14h] [ebp-24h]
  size_t n; // [esp+18h] [ebp-20h]
  int v14; // [esp+1Ch] [ebp-1Ch]
  int v15; // [esp+20h] [ebp-18h]
  int v16; // [esp+24h] [ebp-14h]
  int v17; // [esp+28h] [ebp-10h]
  int v18; // [esp+2Ch] [ebp-Ch]
  int v19; // [esp+30h] [ebp-8h]
  int v20; // [esp+34h] [ebp-4h]
  int savedregs; // [esp+38h] [ebp+0h]

  v15 = strcmp(s1, s2);
  if ( !v15 )
    return 0;
  if ( !*s1 )
    return -1;
  if ( !*s2 )
    return 1;
  if ( !strcmp(".", s1) )
  {
    dword_8074274 = (int (__fastcall *)(_DWORD, _DWORD))&locret_8059098;
    dword_8074270 = (int)&loc_8058EBB;
    result = ((int (__fastcall *)(int, int))locret_8059098)(v4, v3);
  }
  else if ( !strcmp(".", s2) )
  {
    result = 1;
  }
  else if ( !strcmp("..", s1) )
  {
    result = -1;
  }
  else
  {
    v5 = strcmp("..", s2) == 0;
    v6 = &loc_8058F31;
    if ( !v5 )
      v6 = &loc_8058F3B;
    dword_80742C4 = (int)v6;
    sub_8067813(v7, v8, v9, v10, v11, v12, n, v14, v15, v16, v17, v18, v19, v20, savedregs);
    result = 1;
  }
  return result;
}
// 8067813: using guessed type int __stdcall sub_8067813(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8074270: using guessed type int dword_8074270;
// 8074274: using guessed type int (__fastcall *dword_8074274)(_DWORD, _DWORD);
// 80742C4: using guessed type int dword_80742C4;

//----- (0805909A) --------------------------------------------------------
struct timespec *__cdecl sub_805909A(struct timespec *tp)
{
  struct timespec *result; // eax
  struct timeval tv; // [esp+18h] [ebp-10h]

  result = (struct timespec *)clock_gettime(0, tp);
  if ( result )
  {
    gettimeofday(&tv, 0);
    tp->tv_sec = tv.tv_sec;
    result = tp;
    tp->tv_nsec = 1000 * tv.tv_usec;
  }
  return result;
}

//----- (080590E5) --------------------------------------------------------
#error "8059108: positive sp value has been found (funcsize=13)"

//----- (08059185) --------------------------------------------------------
int __cdecl sub_8059185(int a1)
{
  return *(_DWORD *)(a1 + 8);
}

//----- (08059190) --------------------------------------------------------
#error "805919F: call analysis failed (funcsize=11)"

//----- (080591B2) --------------------------------------------------------
#error "80591CD: positive sp value has been found (funcsize=0)"

//----- (080591CE) --------------------------------------------------------
int __cdecl sub_80591CE(int a1)
{
  return *(_DWORD *)(a1 + 16);
}

//----- (080591DD) --------------------------------------------------------
unsigned int __cdecl sub_80591DD(int a1)
{
  _DWORD *i; // [esp+0h] [ebp-10h]
  unsigned int v3; // [esp+4h] [ebp-Ch]
  _DWORD *v4; // [esp+8h] [ebp-8h]
  unsigned int j; // [esp+Ch] [ebp-4h]

  v3 = 0;
  for ( i = *(_DWORD **)a1; *(_DWORD *)(a1 + 4) > (unsigned int)i; i += 2 )
  {
    if ( *i )
    {
      v4 = i;
      for ( j = 1; ; ++j )
      {
        v4 = (_DWORD *)v4[1];
        if ( !v4 )
          break;
      }
      if ( j > v3 )
        v3 = j;
    }
  }
  return v3;
}

//----- (080593D4) --------------------------------------------------------
int __cdecl sub_80593D4(_DWORD *a1, int a2)
{
  int (__cdecl *v2)(int, int); // eax
  int v4; // [esp+4h] [ebp-24h]
  unsigned int v5; // [esp+1Ch] [ebp-Ch]

  v2 = (int (__cdecl *)(int, int))a1[6];
  v4 = a1[2];
  v5 = v2(a2, v4);
  if ( a1[2] <= v5 )
    abort();
  return 8 * v5 + *a1;
}

//----- (08059428) --------------------------------------------------------
#error "8059460: call analysis failed (funcsize=25)"

//----- (080597CC) --------------------------------------------------------
bool __usercall sub_80597CC@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3)
{
  int v3; // ST08_4
  int v5; // [esp+0h] [ebp-10h]
  int v6; // [esp+4h] [ebp-Ch]
  unsigned int v7; // [esp+8h] [ebp-8h]
  unsigned int v8; // [esp+Ch] [ebp-4h]

  dword_80742B0 = (int)&loc_805980F;
  sub_806787F(a2, a1, v5, v6, 3, 9);
  do
  {
    v3 = v7 + 1;
    v8 += 4 * v3;
    v7 = v3 + 1;
  }
  while ( v8 < a3 && a3 % v7 );
  return a3 % v7 != 0;
}
// 80742B0: using guessed type int dword_80742B0;

//----- (0805983C) --------------------------------------------------------
#error "8059885: call analysis failed (funcsize=27)"

//----- (080598EB) --------------------------------------------------------
unsigned int __cdecl sub_80598EB(int a1, unsigned int a2)
{
  return sub_8065F03(a1, 3) % a2;
}

//----- (08059916) --------------------------------------------------------
bool __cdecl sub_8059916(int a1, int a2)
{
  return a1 == a2;
}

//----- (08059924) --------------------------------------------------------
signed int __usercall sub_8059924@<eax>(int a1@<edx>, int a2@<ecx>, int a3)
{
  int v4; // [esp+8h] [ebp-8h]

  v4 = *(_DWORD *)(a3 + 20);
  if ( (_UNKNOWN *)v4 == &unk_806C660 )
  {
    dword_8074260 = (int)&locret_80599F8;
    sub_8067A7F(a2, a1);
  }
  if ( *(float *)(v4 + 8) > 0.1
    && 1.0 - 0.1 > *(float *)(v4 + 8)
    && *(float *)(v4 + 12) > 0.1 + 1.0
    && *(float *)v4 >= 0.0
    && *(float *)(v4 + 4) > *(float *)v4 + 0.1
    && *(float *)(v4 + 4) <= 1.0
    && *(float *)(v4 + 8) > *(float *)v4 + 0.1 )
  {
    return 1;
  }
  *(_DWORD *)(a3 + 20) = &unk_806C660;
  return 0;
}
// 8067A7F: using guessed type int __fastcall sub_8067A7F(_DWORD, _DWORD);
// 8074260: using guessed type int dword_8074260;

//----- (080599FA) --------------------------------------------------------
#error "8059A22: call analysis failed (funcsize=63)"

//----- (08059AC4) --------------------------------------------------------
int sub_8059AC4()
{
  bool v0; // zf
  int v1; // edx
  int v2; // ecx
  void *v3; // eax
  int v5; // [esp+0h] [ebp-28h]
  int v6; // [esp+4h] [ebp-24h]
  int v7; // [esp+8h] [ebp-20h]
  int v8; // [esp+Ch] [ebp-1Ch]

  v0 = malloc(0x28u) == 0;
  v3 = &loc_8059B12;
  if ( !v0 )
    v3 = &loc_8059B1C;
  dword_80742B0 = (int)v3;
  sub_806787F(v2, v1, v5, v6, v7, v8);
  return 0;
}
// 80742B0: using guessed type int dword_80742B0;

//----- (08059DB7) --------------------------------------------------------
void __cdecl sub_8059DB7(void *a1)
{
  void *v1; // eax
  int v2; // edx
  int v3; // ecx
  void *v4; // eax
  _DWORD *v5; // ST24_4
  _DWORD *v6; // ST24_4
  int v7; // [esp+0h] [ebp-28h]
  int v8; // [esp+0h] [ebp-28h]
  int v9; // [esp+4h] [ebp-24h]
  int v10; // [esp+8h] [ebp-20h]
  int v11; // [esp+Ch] [ebp-1Ch]
  int v12; // [esp+10h] [ebp-18h]
  int v13; // [esp+14h] [ebp-14h]
  int *i; // [esp+14h] [ebp-14h]
  int *j; // [esp+14h] [ebp-14h]
  void *ptr; // [esp+18h] [ebp-10h]
  int *ptra; // [esp+18h] [ebp-10h]
  _DWORD *ptrb; // [esp+18h] [ebp-10h]
  _DWORD *ptrc; // [esp+18h] [ebp-10h]
  int v20; // [esp+1Ch] [ebp-Ch]
  int v21; // [esp+20h] [ebp-8h]
  int v22; // [esp+24h] [ebp-4h]
  int savedregs; // [esp+28h] [ebp+0h]

  if ( *((_DWORD *)a1 + 8) )
  {
    v1 = &loc_8059DEE;
    if ( !*((_DWORD *)a1 + 4) )
      v1 = &loc_8059E50;
    dword_807429C = (int)v1;
    sub_806790C(v7, v9, v10, v11, v12, v13, ptr, v20, v21, v22, savedregs);
    for ( i = *(int **)a1; *((_DWORD *)a1 + 1) > (unsigned int)i; i += 2 )
    {
      v4 = &loc_8059E1A;
      if ( !*i )
        v4 = &loc_8059E41;
      dword_8074210 = (int)v4;
      sub_8067C60(v3, v2, v8);
      for ( ptra = i; ptra; ptra = (int *)ptra[1] )
      {
        v8 = *ptra;
        (*((void (**)(void))a1 + 8))();
      }
    }
  }
  for ( j = *(int **)a1; *((_DWORD *)a1 + 1) > (unsigned int)j; j += 2 )
  {
    for ( ptrb = (_DWORD *)j[1]; ptrb; ptrb = v5 )
    {
      v5 = (_DWORD *)ptrb[1];
      free(ptrb);
    }
  }
  for ( ptrc = (_DWORD *)*((_DWORD *)a1 + 9); ptrc; ptrc = v6 )
  {
    v6 = (_DWORD *)ptrc[1];
    free(ptrc);
  }
  free(*(void **)a1);
  free(a1);
}
// 8059DB7: could not find valid save-restore pair for ebx
// 806790C: using guessed type int __stdcall sub_806790C(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8074210: using guessed type int dword_8074210;
// 807429C: using guessed type int dword_807429C;

//----- (08059EE7) --------------------------------------------------------
void *__cdecl sub_8059EE7(int a1)
{
  int v2; // [esp+1Ch] [ebp-Ch]

  if ( !*(_DWORD *)(a1 + 36) )
    return malloc(8u);
  v2 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(v2 + 4);
  return (void *)v2;
}

//----- (08059F22) --------------------------------------------------------
int __cdecl sub_8059F22(int a1, _DWORD *a2)
{
  int result; // eax

  *a2 = 0;
  a2[1] = *(_DWORD *)(a1 + 36);
  result = a1;
  *(_DWORD *)(a1 + 36) = a2;
  return result;
}

//----- (08059F65) --------------------------------------------------------
int __cdecl sub_8059F65(int a1, int a2, int a3, char a4)
{
  int v4; // ecx
  int v5; // edx
  bool v6; // zf
  void *v7; // eax
  int v9; // [esp-4h] [ebp-3Ch]
  int v10; // [esp+0h] [ebp-38h]
  int v11; // [esp+4h] [ebp-34h]
  _DWORD *v12; // [esp+8h] [ebp-30h]
  char v13; // [esp+Ch] [ebp-2Ch]
  _DWORD *v14; // [esp+10h] [ebp-28h]

  v13 = a4;
  *(&v10 - 7) = sub_80593D4(v12, a2);
  v5 = *(&v10 - 7);
  *v14 = v5;
  v6 = *(_DWORD *)*(&v10 - 7) == 0;
  v9 = *(_DWORD *)*(&v10 - 7);
  v7 = &loc_8059FD0;
  if ( !v6 )
    v7 = &loc_8059FDA;
  dword_80742B0 = (int)v7;
  sub_806787F(v4, v5, v10, v11, v12, *(_DWORD *)&v13);
  return 0;
}
// 80742B0: using guessed type int dword_80742B0;

//----- (0805A186) --------------------------------------------------------
int __cdecl sub_805A186(_DWORD *a1, int *a2, char a3)
{
  int v3; // ST28_4
  int *v4; // edx
  int v5; // ecx
  int v6; // ST30_4
  void *v7; // eax
  int v9; // [esp+0h] [ebp-38h]
  int v10; // [esp+4h] [ebp-34h]
  int v11; // [esp+8h] [ebp-30h]
  _DWORD v12[3]; // [esp+Ch] [ebp-2Ch]
  char v13; // [esp+Ch] [ebp-2Ch]
  int v14; // [esp+10h] [ebp-28h]
  int v15; // [esp+14h] [ebp-24h]
  int *v16; // [esp+18h] [ebp-20h]
  int v17; // [esp+1Ch] [ebp-1Ch]
  int *i; // [esp+1Ch] [ebp-1Ch]
  int v19; // [esp+20h] [ebp-18h]
  int v20; // [esp+20h] [ebp-18h]
  int v21; // [esp+24h] [ebp-14h]
  int *v22; // [esp+24h] [ebp-14h]
  int v23; // [esp+28h] [ebp-10h]
  int *v24; // [esp+28h] [ebp-10h]

  LOBYTE(v12[0]) = a3;
  v3 = *a2;
  dword_807429C = (int)&loc_805A3E6;
  sub_806790C(v9, v10, v11, v12[0], v14, v15, v3, v17, v19, v21, v23);
  while ( !*v16 )
  {
    v16 += 2;
    if ( a2[1] <= (unsigned int)v16 )
      return 1;
  }
  for ( i = (int *)v16[1]; i; i = v24 )
  {
    v20 = *i;
    v22 = (int *)sub_80593D4(a1, *i);
    v24 = (int *)i[1];
    if ( *v22 )
    {
      i[1] = v22[1];
      v4 = i;
      v22[1] = (int)i;
    }
    else
    {
      *v22 = v20;
      ++a1[3];
      sub_8059F22((int)a1, i);
    }
  }
  v6 = *v16;
  v16[1] = 0;
  v7 = &loc_805A30C;
  if ( !v13 )
    v7 = &loc_805A311;
  dword_8074274 = (int (__fastcall *)(_DWORD, _DWORD))v7;
  dword_8074270 = (int)&loc_805A30C;
  return ((int (__fastcall *)(int, int *))v7)(v5, v4);
}
// 806790C: using guessed type int __stdcall sub_806790C(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8074270: using guessed type int dword_8074270;
// 8074274: using guessed type int (__fastcall *dword_8074274)(_DWORD, _DWORD);
// 807429C: using guessed type int dword_807429C;

//----- (0805A3FC) --------------------------------------------------------
signed int __cdecl sub_805A3FC(int *a1, int a2)
{
  bool v3; // zf
  void *v4; // eax
  int *v5; // ST1C_4
  int v6; // [esp+0h] [ebp-48h]
  int v7; // [esp+4h] [ebp-44h]
  int v8; // [esp+8h] [ebp-40h]
  int v9; // [esp+Ch] [ebp-3Ch]
  int nmemb; // [esp+10h] [ebp-38h]
  char *v11; // [esp+18h] [ebp-30h]
  char *v12; // [esp+1Ch] [ebp-2Ch]
  int v13; // [esp+20h] [ebp-28h]
  int v14; // [esp+24h] [ebp-24h]
  int v15; // [esp+28h] [ebp-20h]
  int v16; // [esp+2Ch] [ebp-1Ch]
  int v17; // [esp+30h] [ebp-18h]
  int v18; // [esp+34h] [ebp-14h]
  int v19; // [esp+38h] [ebp-10h]
  int v20; // [esp+3Ch] [ebp-Ch]

  nmemb = sub_80599FA(a2, a1[5]);
  if ( !nmemb )
    return 0;
  if ( a1[2] == nmemb )
    return 1;
  v11 = (char *)calloc(nmemb, 8u);
  if ( !v11 )
    return 0;
  v13 = nmemb;
  v12 = &v11[8 * nmemb];
  v14 = 0;
  v15 = 0;
  v16 = a1[5];
  v17 = a1[6];
  v18 = a1[7];
  v19 = a1[8];
  v20 = a1[9];
  v3 = (unsigned __int8)sub_805A186(&v11, a1, 0) == 0;
  v4 = &loc_805A525;
  if ( v3 )
    v4 = &loc_805A586;
  dword_80741DC = (int)v4;
  sub_8067DA4(v6, v7, v8, v9, nmemb, &v11, v11, v12, v13, v14, v15);
  free((void *)*a1);
  *a1 = *v5;
  a1[1] = v5[1];
  a1[2] = v5[2];
  a1[3] = v5[3];
  a1[9] = v5[9];
  return 1;
}
// 80599FA: using guessed type _DWORD __cdecl sub_80599FA(_DWORD, _DWORD);
// 8067DA4: using guessed type int __stdcall sub_8067DA4(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80741DC: using guessed type int dword_80741DC;

//----- (0805A624) --------------------------------------------------------
#error "805A673: call analysis failed (funcsize=202)"

//----- (0805A957) --------------------------------------------------------
int __cdecl sub_805A957(int a1, int a2)
{
  int v2; // edx
  int v3; // ecx
  int v5; // [esp+0h] [ebp-28h]
  int v6; // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]

  v7 = sub_805A624(a1, a2, &v6);
  if ( v7 != -1 )
  {
    if ( !v7 )
      return v6;
    dword_8074210 = (int)&locret_805A9AD;
    sub_8067C60(v3, v2, v5);
  }
  return 0;
}
// 805A624: using guessed type _DWORD __cdecl sub_805A624(_DWORD, _DWORD, _DWORD);
// 8074210: using guessed type int dword_8074210;

//----- (0805A9AF) --------------------------------------------------------
#error "805A9C0: call analysis failed (funcsize=12)"

//----- (0805A9D3) --------------------------------------------------------
int __cdecl sub_805A9D3(int a1, int a2, int a3)
{
  bool v4; // zf
  void *v5; // eax
  int v6; // ecx
  long double v7; // fst7
  long double v8; // fst6
  long double v9; // fst7
  long double v10; // fst6
  long double v11; // fst7
  __int16 v12; // ax
  int v13; // edx
  int v14; // [esp-4h] [ebp-4Ch]
  void *ptr; // [esp+0h] [ebp-48h]
  int v16; // [esp+4h] [ebp-44h]
  int v17; // [esp+8h] [ebp-40h]
  int v18; // [esp+Ch] [ebp-3Ch]
  int v19; // [esp+10h] [ebp-38h]
  int v20; // [esp+14h] [ebp-34h]
  __int64 v21; // [esp+18h] [ebp-30h]
  int v22; // [esp+20h] [ebp-28h]
  int v23; // [esp+24h] [ebp-24h]
  int *v24; // [esp+28h] [ebp-20h]
  int v25; // [esp+2Ch] [ebp-1Ch]
  int v26; // [esp+30h] [ebp-18h]
  int v27; // [esp+34h] [ebp-14h]
  int v28; // [esp+38h] [ebp-10h]

  v26 = sub_8059F65(a2, a3, (int)&v24, 1);
  if ( !v26 )
    return 0;
  --*(_DWORD *)(a2 + 16);
  v4 = *v24 == 0;
  v14 = *v24;
  v5 = &loc_805AA3F;
  if ( !v4 )
    v5 = &loc_805AC10;
  dword_8074224 = (int)v5;
  sub_8067BEE(ptr, v16, v17, v18, v19, v20, v21, HIDWORD(v21), v22, v23, v24, v25, v26, v27, v28);
  v21 = (unsigned int)--*(_DWORD *)(a2 + 12);
  v7 = (long double)v21;
  v8 = **(float **)(a2 + 20);
  *(&ptr - 12) = *(void **)(a2 + 8);
  *(&ptr - 11) = 0;
  if ( v8 * (long double)*((signed __int64 *)&ptr - 6) > v7 )
  {
    sub_8059924(0, v6, v17);
    *(&ptr - 12) = *(void **)(v17 + 12);
    *(&ptr - 11) = 0;
    v9 = (long double)*((signed __int64 *)&ptr - 6);
    v10 = **(float **)(v17 + 20);
    *(&ptr - 12) = *(void **)(v17 + 8);
    *(&ptr - 11) = 0;
    if ( v10 * (long double)*((signed __int64 *)&ptr - 6) > v9 )
    {
      *(&ptr - 5) = *(void **)(v17 + 20);
      if ( *((_BYTE *)*(&ptr - 5) + 16) )
      {
        *(&ptr - 12) = *(void **)(v17 + 8);
        *(&ptr - 11) = 0;
        v11 = (long double)*((signed __int64 *)&ptr - 6) * *((float *)*(&ptr - 5) + 1);
      }
      else
      {
        *(&ptr - 12) = *(void **)(v17 + 8);
        *(&ptr - 11) = 0;
        v11 = (long double)*((signed __int64 *)&ptr - 6) * *((float *)*(&ptr - 5) + 1) * *((float *)*(&ptr - 5) + 2);
      }
      v12 = *((_WORD *)&ptr - 25);
      HIBYTE(v12) = 12;
      *((_WORD *)&ptr - 26) = v12;
      *((_QWORD *)&ptr - 6) = (signed __int64)v11;
      v13 = (int)*(&ptr - 11);
      *(&ptr - 4) = *(&ptr - 12);
      v16 = (int)*(&ptr - 4);
      if ( (unsigned __int8)sub_805A3FC((int *)v17, v16) ^ 1 )
      {
        for ( *(&ptr - 7) = *(void **)(v17 + 36); *(&ptr - 7); *(&ptr - 7) = *(&ptr - 3) )
        {
          *(&ptr - 3) = (void *)*((_DWORD *)*(&ptr - 7) + 1);
          free(*(&ptr - 7));
        }
        *(_DWORD *)(v17 + 36) = 0;
      }
    }
  }
  return (int)*(&ptr - 6);
}
// 805A9D3: could not find valid save-restore pair for ebp
// 8067BEE: using guessed type int __stdcall sub_8067BEE(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8074224: using guessed type int dword_8074224;

//----- (0805AC15) --------------------------------------------------------
int __fastcall sub_805AC15(int ecx0, int a2, int a1)
{
  dword_8074274 = (int (__fastcall *)(_DWORD, _DWORD))sub_805ACC8;
  dword_8074270 = (int)sub_805ACBA;
  return ((int (__fastcall *)(int, int))sub_805ACC8)(ecx0, a2);
}
// 805ACBA: using guessed type int sub_805ACBA();
// 805ACC8: using guessed type int sub_805ACC8();
// 8074270: using guessed type int dword_8074270;
// 8074274: using guessed type int (__fastcall *dword_8074274)(_DWORD, _DWORD);

//----- (0805AE21) --------------------------------------------------------
#error "805AEA5: call analysis failed (funcsize=65)"

//----- (0805AEDA) --------------------------------------------------------
void __cdecl sub_805AEDA(void **a1)
{
  free(*a1);
  free(a1);
}

//----- (0805AF20) --------------------------------------------------------
#error "805B092: call analysis failed (funcsize=118)"

//----- (0805B097) --------------------------------------------------------
#error "805B0A7: positive sp value has been found (funcsize=0)"

//----- (0805B0AA) --------------------------------------------------------
#error "805B181: call analysis failed (funcsize=69)"

//----- (0805B186) --------------------------------------------------------
#error "805B1DF: positive sp value has been found (funcsize=0)"

//----- (0805B1E2) --------------------------------------------------------
#error "805B246: call analysis failed (funcsize=30)"

//----- (0805B24B) --------------------------------------------------------
#error "805B24B: function frame is wrong (funcsize=0)"

//----- (0805BE5B) --------------------------------------------------------
#error "805C002: positive sp value has been found (funcsize=106)"

//----- (0805C007) --------------------------------------------------------
__int64 sub_805C007()
{
  __int64 result; // rax

  if ( getenv("POSIXLY_CORRECT") )
    LODWORD(result) = 512;
  else
    LODWORD(result) = 1024;
  HIDWORD(result) = 0;
  return result;
}

//----- (0805C041) --------------------------------------------------------
int __usercall sub_805C041@<eax>(int a1@<ebx>, char *s, int a3, int a4)
{
  int v5; // [esp+20h] [ebp-18h]
  int v6; // [esp+24h] [ebp-14h]
  int v7; // [esp+28h] [ebp-10h]
  int v8; // [esp+2Ch] [ebp-Ch]

  v6 = 0;
  if ( s || (s = getenv("BLOCK_SIZE")) != 0 || (s = getenv("BLOCKSIZE")) != 0 )
  {
    if ( *s == 39 )
    {
      v6 |= 4u;
      ++s;
    }
    v7 = sub_8056BB4(s, (int)off_806C734);
    if ( v7 < 0 )
    {
      v8 = sub_8064797(s, a1, s, (int)&v5, 0, a3, "eEgGkKmMpPtTyYzZ0");
      if ( v8 )
      {
        *(_DWORD *)a4 = 0;
        return v8;
      }
      while ( *s <= 47 || *s > 57 )
      {
        if ( s == (char *)v5 )
        {
          v6 |= 0x80u;
          if ( *(_BYTE *)(v5 - 1) == 66 )
            v6 |= 0x100u;
          if ( *(_BYTE *)(v5 - 1) != 66 || *(_BYTE *)(v5 - 2) == 105 )
            v6 |= 0x20u;
          break;
        }
        ++s;
      }
    }
    else
    {
      v6 |= dword_806C740[v7];
      *(_DWORD *)a3 = 1;
      *(_DWORD *)(a3 + 4) = 0;
    }
  }
  else
  {
    *(_QWORD *)a3 = sub_805C007();
  }
  *(_DWORD *)a4 = v6;
  return 0;
}
// 806C734: using guessed type char *off_806C734[2];

//----- (0805C1AE) --------------------------------------------------------
int __usercall sub_805C1AE@<eax>(int a1@<ebx>, char *s, int a3, int a4)
{
  int v5; // [esp+1Ch] [ebp-Ch]

  v5 = sub_805C041(a1, s, a4, a3);
  if ( !*(_QWORD *)a4 )
  {
    *(_QWORD *)a4 = sub_805C007();
    v5 = 4;
  }
  return v5;
}

//----- (0805C219) --------------------------------------------------------
int __usercall sub_805C219@<eax>(int a1@<edx>, int a2@<ecx>, __uid_t uid)
{
  void *v3; // eax
  const char *v4; // eax
  size_t v5; // eax
  void *v6; // eax
  int v7; // ST1C_4
  int v9; // [esp+0h] [ebp-28h]
  int v10; // [esp+0h] [ebp-28h]
  int v11; // [esp+4h] [ebp-24h]
  int v12; // [esp+8h] [ebp-20h]
  int v13; // [esp+Ch] [ebp-1Ch]
  int v14; // [esp+10h] [ebp-18h]
  int v15; // [esp+14h] [ebp-14h]
  struct passwd *v16; // [esp+18h] [ebp-10h]
  char *s; // [esp+1Ch] [ebp-Ch]
  int v18; // [esp+20h] [ebp-8h]
  int v19; // [esp+24h] [ebp-4h]
  int savedregs; // [esp+28h] [ebp+0h]

  v14 = dword_80759F4;
  v3 = &loc_805C26E;
  if ( dword_80759F4 )
    v3 = &loc_805C230;
  dword_8074210 = (int)v3;
  sub_8067C60(a2, a1, v9);
  v16 = getpwuid(uid);
  if ( v16 )
    v4 = v16->pw_name;
  else
    v4 = (const char *)&unk_806C7C4;
  s = (char *)v4;
  v5 = strlen(v4);
  v15 = sub_806399E((v5 + 16) & 0xFFFFFFF8);
  *(_DWORD *)v15 = uid;
  strcpy((char *)(v15 + 8), s);
  *(_DWORD *)(v15 + 4) = dword_80759F4;
  dword_80759F4 = v15;
  v6 = &loc_805C308;
  if ( !*(_BYTE *)(v15 + 8) )
    v6 = &loc_805C310;
  dword_807429C = (int)v6;
  sub_806790C(v10, v11, v12, v13, v14, v15, v16, s, v18, v19, savedregs);
  return v7 + 8;
}
// 805C219: could not find valid save-restore pair for ebx
// 806790C: using guessed type int __stdcall sub_806790C(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8074210: using guessed type int dword_8074210;
// 807429C: using guessed type int dword_807429C;
// 80759F4: using guessed type int dword_80759F4;

//----- (0805C462) --------------------------------------------------------
int __cdecl sub_805C462(__gid_t gid)
{
  struct group *v1; // eax
  int v2; // edx
  int v3; // ecx
  bool v4; // zf
  void *v5; // eax
  char *s; // ST24_4
  size_t v7; // eax
  int result; // eax
  int v9; // [esp+0h] [ebp-28h]
  _DWORD *i; // [esp+10h] [ebp-18h]
  int v11; // [esp+14h] [ebp-14h]
  const char **v12; // [esp+18h] [ebp-10h]

  v11 = 0;
  for ( i = (_DWORD *)dword_80759FC; i; i = (_DWORD *)i[1] )
  {
    if ( *i == gid )
    {
      v11 = (int)i;
      break;
    }
  }
  if ( !v11 )
  {
    v1 = getgrgid(gid);
    v12 = (const char **)&v1->gr_name;
    v4 = v1 == 0;
    v5 = &loc_805C4D1;
    if ( v4 )
      v5 = &loc_805C4D8;
    dword_8074210 = (int)v5;
    sub_8067C60(v3, v2, v9);
    s = (char *)*v12;
    v7 = strlen(*v12);
    v11 = sub_806399E((v7 + 16) & 0xFFFFFFF8);
    *(_DWORD *)v11 = gid;
    strcpy((char *)(v11 + 8), s);
    *(_DWORD *)(v11 + 4) = dword_80759FC;
    dword_80759FC = v11;
  }
  if ( *(_BYTE *)(v11 + 8) )
    result = v11 + 8;
  else
    result = 0;
  return result;
}
// 8074210: using guessed type int dword_8074210;
// 80759FC: using guessed type int dword_80759FC;

//----- (0805C6C8) --------------------------------------------------------
#error "805C74E: call analysis failed (funcsize=70)"

//----- (0805C81F) --------------------------------------------------------
int __cdecl sub_805C81F(__int64 a1, int a2)
{
  __int64 v2; // rax
  __int64 v4; // [esp+18h] [ebp-20h]
  int v5; // [esp+2Ch] [ebp-Ch]

  v4 = a1;
  v5 = a2 + 20;
  *(_BYTE *)(a2 + 20) = 0;
  do
  {
    *(_BYTE *)--v5 = sub_806739B(v4, 10, 0) + 48;
    LODWORD(v2) = sub_806721A(v4, SHIDWORD(v4), (char *)0xA, 0);
    v4 = v2;
  }
  while ( v2 );
  return v5;
}
// 806739B: using guessed type _DWORD __cdecl sub_806739B(__int64, _DWORD, _DWORD);

//----- (0805C8CD) --------------------------------------------------------
int __cdecl sub_805C8CD(wint_t *a1)
{
  unsigned __int8 v2; // [esp+1Bh] [ebp-Dh]
  wint_t *i; // [esp+1Ch] [ebp-Ch]

  v2 = 0;
  for ( i = a1; *i; ++i )
  {
    if ( !iswprint(*i) )
    {
      *i = 65533;
      v2 = 1;
    }
  }
  return v2;
}

//----- (0805C914) --------------------------------------------------------
int __cdecl sub_805C914(_DWORD *a1, unsigned int a2)
{
  int v3; // [esp+18h] [ebp-10h]
  int v4; // [esp+1Ch] [ebp-Ch]

  v3 = 0;
  while ( *a1 )
  {
    v4 = wcwidth(*a1);
    if ( v4 == -1 )
    {
      *a1 = 65533;
      v4 = 1;
    }
    if ( v4 + v3 > a2 )
      break;
    v3 += v4;
    ++a1;
  }
  *a1 = 0;
  return v3;
}
// 8049560: using guessed type int __cdecl wcwidth(_DWORD);

//----- (0805C984) --------------------------------------------------------
_BYTE *__cdecl sub_805C984(_BYTE *a1, unsigned int a2, int a3)
{
  _BYTE *v3; // eax
  int v4; // eax

  while ( 1 )
  {
    v4 = a3--;
    if ( !v4 || (unsigned int)a1 >= a2 )
      break;
    v3 = a1++;
    *v3 = 32;
  }
  *a1 = 0;
  return a1;
}

//----- (0805C9B9) --------------------------------------------------------
#error "805CD44: call analysis failed (funcsize=176)"

//----- (0805CF15) --------------------------------------------------------
int __usercall sub_805CF15@<eax>(int a1@<ebx>, char *s, int a3)
{
  int v3; // eax

  v3 = strlen(s);
  return sub_805CF3E(a1, s, v3, a3);
}

//----- (0805CF3E) --------------------------------------------------------
int __usercall sub_805CF3E@<eax>(int a1@<ebx>, char *a2, int a3, char a4)
{
  int v4; // edx
  int v5; // ecx
  signed int v6; // eax
  bool v7; // zf
  bool v8; // sf
  unsigned __int8 v9; // of
  void *v10; // eax
  int v11; // ecx
  int v13; // edx
  int v14; // ecx
  void *v15; // eax
  char *v16; // eax
  const unsigned __int16 **v17; // eax
  const unsigned __int16 **v18; // eax
  int v19; // [esp-8h] [ebp-60h]
  int v20; // [esp-4h] [ebp-5Ch]
  int v21; // [esp+0h] [ebp-58h]
  char *v22; // [esp+4h] [ebp-54h]
  int v23; // [esp+8h] [ebp-50h]
  int *v24; // [esp+Ch] [ebp-4Ch]
  int v25; // [esp+10h] [ebp-48h]
  int v26; // [esp+14h] [ebp-44h]
  int v27; // [esp+18h] [ebp-40h]
  char *v28; // [esp+1Ch] [ebp-3Ch]
  int v29; // [esp+20h] [ebp-38h]
  int v30; // [esp+24h] [ebp-34h]
  int v31; // [esp+28h] [ebp-30h]
  wint_t wc; // [esp+2Ch] [ebp-2Ch]
  char *v33; // [esp+30h] [ebp-28h]
  int v34; // [esp+34h] [ebp-24h]
  int v35; // [esp+38h] [ebp-20h]
  char *v36; // [esp+3Ch] [ebp-1Ch]
  int v37; // [esp+40h] [ebp-18h]
  char s; // [esp+44h] [ebp-14h]
  unsigned int v39; // [esp+4Ch] [ebp-Ch]

  v28 = a2;
  v39 = __readgsdword(0x14u);
  v33 = a2;
  v36 = &a2[a3];
  v34 = 0;
  if ( __ctype_get_mb_cur_max() <= 1 )
  {
    while ( v33 < v36 )
    {
      v16 = v33++;
      HIBYTE(v31) = *v16;
      v17 = __ctype_b_loc();
      v4 = HIBYTE(v31);
      if ( (*v17)[v4] & 0x4000 )
      {
        if ( v34 == 0x7FFFFFFF )
          return 0x7FFFFFFF;
        ++v34;
      }
      else
      {
        if ( a4 & 2 )
          return -1;
        v18 = __ctype_b_loc();
        v4 = HIBYTE(v31);
        if ( !((*v18)[v4] & 2) )
        {
          if ( v34 != 0x7FFFFFFF )
          {
            ++v34;
            dword_807429C = (int)&loc_805D216;
            sub_806790C(v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31);
            return -1;
          }
          return 0x7FFFFFFF;
        }
      }
    }
    dword_8074260 = (int)&loc_805D241;
    sub_8067A7F(v5, v4 * 2);
    return 0x7FFFFFFF;
  }
  dword_8074210 = (int)&loc_805D16C;
  sub_8067C60(v5, v4 * 2, v21);
  while ( 1 )
  {
    v6 = *v33;
    if ( v6 > 63 )
      break;
    if ( v6 < 37 && (unsigned int)(v6 - 32) > 3 )
      goto LABEL_12;
LABEL_11:
    ++v33;
    ++v34;
LABEL_33:
    if ( v33 >= v36 )
      return v34;
  }
  if ( v6 >= 65 )
  {
    v9 = __OFSUB__(v6, 95);
    v7 = v6 == 95;
    v8 = v6 - 95 < 0;
    v20 = *v33;
    v19 = a1;
    v10 = &loc_805CFE6;
    if ( (unsigned __int8)(v8 ^ v9) | v7 )
      v10 = &loc_805CFEE;
    dword_807429C = (int)v10;
    a1 = v19;
    if ( (unsigned int)(sub_806790C(v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31) - 97) <= 0x1D )
      goto LABEL_11;
  }
LABEL_12:
  memset(&s, 0, 8u);
  while ( 1 )
  {
    v24 = &v21 - 5;
    v23 = v36 - v33;
    v22 = v33;
    v35 = sub_8064D1A(v11, (int)(&v21 - 5), (int)(&v21 - 11));
    if ( v35 == -1 )
    {
      if ( !(a4 & 1) )
      {
        ++v33;
        ++v34;
        dword_8074238 = (int)&loc_805D16C;
        sub_8067B80(v21, v22, v23, v24, v25, v26, v27);
      }
      return -1;
    }
    if ( v35 == -2 )
      break;
    if ( !v35 )
      v35 = 1;
    v37 = wcwidth(wc);
    if ( v37 >= 0 )
    {
      v20 = 0x7FFFFFFF - v34;
      v19 = a1;
      v15 = &loc_805D0FD;
      if ( 0x7FFFFFFF - v34 >= v37 )
        v15 = &loc_805D102;
      dword_8074260 = (int)v15;
      sub_8067A7F(v14, v13);
      return 0x7FFFFFFF;
    }
    if ( a4 & 2 )
    {
      dword_80741F0 = (int)&loc_805D241;
      sub_8067D38(v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, wc, v33, v34, v35);
    }
    else if ( !iswcntrl(wc) )
    {
      if ( v34 == 0x7FFFFFFF )
        return 0x7FFFFFFF;
      ++v34;
    }
    v33 += v35;
    if ( mbsinit((const mbstate_t *)&s) )
      goto LABEL_33;
  }
  if ( !(a4 & 1) )
  {
    v33 = v36;
    ++v34;
    goto LABEL_33;
  }
  return -1;
}
// 805CF3E: could not find valid save-restore pair for ebx
// 8049560: using guessed type int __cdecl wcwidth(_DWORD);
// 806790C: using guessed type int __stdcall sub_806790C(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8067A7F: using guessed type int __fastcall sub_8067A7F(_DWORD, _DWORD);
// 8067B80: using guessed type int __stdcall sub_8067B80(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8067D38: using guessed type int __stdcall sub_8067D38(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80741F0: using guessed type int dword_80741F0;
// 8074210: using guessed type int dword_8074210;
// 8074238: using guessed type int dword_8074238;
// 8074260: using guessed type int dword_8074260;
// 807429C: using guessed type int dword_807429C;

//----- (0805D254) --------------------------------------------------------
void *__cdecl sub_805D254(int a1, int a2, void *dest, int a4)
{
  _DWORD *v4; // eax
  _DWORD *v5; // eax
  unsigned int v7; // [esp+10h] [ebp-28h]
  unsigned int v8; // [esp+14h] [ebp-24h]
  unsigned int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]

  v12 = (unsigned int)a2 >> 1;
  v13 = a2 - ((unsigned int)a2 >> 1);
  v7 = 0;
  v8 = (unsigned int)a2 >> 1;
  v9 = (unsigned int)a2 >> 1;
  v14 = a2;
  sub_805D3EE(a1 + 4 * ((unsigned int)a2 >> 1), v13, dest, a4);
  sub_805D3EE(a1, (unsigned int)a2 >> 1, dest, a4);
  v10 = *(_DWORD *)a1;
  v11 = *(_DWORD *)(4 * ((unsigned int)a2 >> 1) + a1);
  while ( 1 )
  {
    while ( ((int (__cdecl *)(int, int))a4)(v10, v11) > 0 )
    {
      v5 = dest;
      dest = (char *)dest + 4;
      *v5 = v11;
      if ( ++v9 == v14 )
        return memcpy(dest, (const void *)(4 * v7 + a1), 4 * (v8 - v7));
      v11 = *(_DWORD *)(4 * v9 + a1);
    }
    v4 = dest;
    dest = (char *)dest + 4;
    *v4 = v10;
    if ( ++v7 == v8 )
      break;
    v10 = *(_DWORD *)(4 * v7 + a1);
  }
  v7 = v9;
  v8 = v14;
  return memcpy(dest, (const void *)(4 * v7 + a1), 4 * (v8 - v7));
}

//----- (0805D3EE) --------------------------------------------------------
#error "805D602: call analysis failed (funcsize=154)"

//----- (0805D687) --------------------------------------------------------
int __cdecl sub_805D687(int a1, int a2, int a3)
{
  return sub_805D3EE(a1, a2, (void *)(a1 + 4 * a2), a3);
}

//----- (0805D6CF) --------------------------------------------------------
int __cdecl sub_805D6CF(int a1, int a2, int a3)
{
  int v3; // eax

  while ( 1 )
  {
    v3 = a3--;
    if ( !v3 )
      break;
    *(_BYTE *)(a1 + a3) = tolower(*(unsigned __int8 *)(a2 + a3));
  }
  return a1;
}

//----- (0805D72D) --------------------------------------------------------
int __cdecl sub_805D72D(int a1, int a2, int a3)
{
  int v3; // eax

  while ( 1 )
  {
    v3 = a3--;
    if ( !v3 )
      break;
    *(_BYTE *)(a1 + a3) = toupper(*(unsigned __int8 *)(a2 + a3));
  }
  return a1;
}

//----- (0805D76D) --------------------------------------------------------
int __cdecl sub_805D76D(int a1, int a2)
{
  return a1 - (a1 - a2 + 382) % 7 + 3;
}

//----- (0805D7D8) --------------------------------------------------------
int __cdecl sub_805D7D8(int a1, int a2, int a3, int a4, int a5, int a6)
{
  char v7; // [esp+1h] [ebp-9h]

  v7 = 0;
  return sub_805D847(a1, a2, a3, a4, 0, &v7, a5, a6);
}
// 805D847: using guessed type _DWORD __cdecl sub_805D847(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0805D847) --------------------------------------------------------
#error "8060260: call analysis failed (funcsize=1880)"

//----- (08060944) --------------------------------------------------------
int __cdecl sub_8060944(char *s)
{
  int *v1; // ebp
  int v2; // ecx
  char *v3; // eax
  int v4; // edx
  int v5; // eax
  bool v6; // zf
  bool v7; // sf
  unsigned __int8 v8; // of
  void *v9; // eax
  int result; // eax
  int v11; // [esp+0h] [ebp-28h]
  char *v12; // [esp+8h] [ebp-20h]
  char *v13; // [esp+18h] [ebp-10h]
  char *s1; // [esp+1Ch] [ebp-Ch]
  int savedregs; // [esp+28h] [ebp+0h]

  v1 = &savedregs;
  if ( !s )
  {
    fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
    abort();
  }
  v13 = strrchr(s, 47);
  if ( v13 )
    v3 = v13 + 1;
  else
    v3 = s;
  s1 = v3;
  v4 = v3 - s;
  v5 = v3 - s;
  v8 = __OFSUB__(v5, 6);
  v6 = v5 == 6;
  v7 = v5 - 6 < 0;
  v9 = &loc_80609CC;
  if ( (unsigned __int8)(v7 ^ v8) | v6 )
    v9 = &loc_8060A44;
  dword_8074288 = (int)v9;
  sub_8067999(v2, v4, v11);
  if ( !strncmp(s1 - 7, "/.libs/", 7u) && !strncmp(s1, "lt-", 3u) )
  {
    v1 = &v11;
    v12 = s1 + 3;
    program_invocation_short_name = (int)(s1 + 3);
  }
  dword_8075A04 = v1[2];
  result = v1[2];
  program_invocation_name = v1[2];
  return result;
}
// 8074288: using guessed type int dword_8074288;
// 80744C0: using guessed type int program_invocation_short_name;
// 80744D0: using guessed type int program_invocation_name;
// 8075A04: using guessed type int dword_8075A04;

//----- (08060A56) --------------------------------------------------------
void *__cdecl sub_8060A56(void *src)
{
  int *v1; // eax
  void *v2; // ST1C_4
  int v4; // [esp+18h] [ebp-10h]

  v4 = *__errno_location();
  if ( src )
    v1 = (int *)src;
  else
    v1 = &dword_8075A10;
  v2 = sub_8063B08(v1, 0x30u);
  *__errno_location() = v4;
  return v2;
}
// 8075A10: using guessed type int dword_8075A10;

//----- (08060A9C) --------------------------------------------------------
#error "8060ACF: call analysis failed (funcsize=23)"

//----- (08060AE5) --------------------------------------------------------
#error "8060B02: call analysis failed (funcsize=30)"

//----- (08060B3A) --------------------------------------------------------
int __cdecl sub_8060B3A(int *a1, unsigned __int8 a2, char a3)
{
  int *v3; // eax
  int *v4; // ST08_4
  unsigned int v5; // edx

  if ( a1 )
    v3 = a1;
  else
    v3 = &dword_8075A10;
  v4 = &v3[(a2 >> 5) + 2];
  v5 = (unsigned int)*v4 >> (a2 & 0x1F);
  *v4 ^= (v5 & 1 ^ a3 & 1) << (a2 & 0x1F);
  return v5 & 1;
}
// 8075A10: using guessed type int dword_8075A10;

//----- (08060C1D) --------------------------------------------------------
#error "8060C3D: call analysis failed (funcsize=36)"

//----- (08060CAE) --------------------------------------------------------
_DWORD *__stdcall sub_8060CAE(int a1)
{
  _DWORD *v1; // eax
  int v3; // [esp+0h] [ebp-38h]
  _DWORD *v4; // [esp+8h] [ebp-30h]
  int v5; // [esp+Ch] [ebp-2Ch]

  memset(&v3, 0, 0x30u);
  if ( v5 == 10 )
    abort();
  *(&v3 - 14) = v5;
  v1 = v4;
  *v4 = *(&v3 - 14);
  v1[1] = *(&v3 - 13);
  v1[2] = *(&v3 - 12);
  v1[3] = *(&v3 - 11);
  v1[4] = *(&v3 - 10);
  v1[5] = *(&v3 - 9);
  v1[6] = *(&v3 - 8);
  v1[7] = *(&v3 - 7);
  v1[8] = *(&v3 - 6);
  v1[9] = *(&v3 - 5);
  v1[10] = *(&v3 - 4);
  v1[11] = *(&v3 - 3);
  return v4;
}

//----- (08060D62) --------------------------------------------------------
const char *__usercall sub_8060D62@<eax>(int a1@<ebx>, char *msgid, int a3)
{
  const char *result; // eax
  int v4; // edx
  int v5; // ecx
  int v6; // edx
  int v7; // ecx
  void *v8; // eax
  int v9; // [esp+0h] [ebp-28h]
  int v10; // [esp+4h] [ebp-24h]
  int v11; // [esp+8h] [ebp-20h]
  int v12; // [esp+Ch] [ebp-1Ch]
  char *v13; // [esp+18h] [ebp-10h]
  unsigned __int8 *v14; // [esp+1Ch] [ebp-Ch]

  v13 = gettext(msgid);
  if ( v13 != msgid )
    return v13;
  v14 = (unsigned __int8 *)sub_806691A(a1);
  if ( sub_806603E(v14, "UTF-8") )
  {
    if ( sub_806603E(v14, "GB18030") )
    {
      if ( a3 == 9 )
        result = (const char *)&unk_806CB1D;
      else
        result = "'";
    }
    else
    {
      v8 = &loc_8060E97;
      if ( *msgid != 96 )
        v8 = &loc_8060E9E;
      dword_8074274 = (int (__fastcall *)(_DWORD, _DWORD))v8;
      dword_8074270 = (int)&loc_8060E97;
      result = (const char *)((int (__fastcall *)(int, int))v8)(v7, v6);
    }
  }
  else
  {
    if ( *msgid == 96 )
    {
      dword_80742B0 = (int)&loc_8060DD4;
      sub_806787F(v5, v4, v9, v10, v11, v12);
    }
    result = (const char *)&unk_806CB0A;
  }
  return result;
}
// 8074270: using guessed type int dword_8074270;
// 8074274: using guessed type int (__fastcall *dword_8074274)(_DWORD, _DWORD);
// 80742B0: using guessed type int dword_80742B0;

//----- (08060ECE) --------------------------------------------------------
#error "80617E9: call analysis failed (funcsize=1094)"

//----- (08061EBA) --------------------------------------------------------
int __cdecl sub_8061EBA(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // ST38_4
  int v6; // ST3C_4
  int v8; // [esp+0h] [ebp-48h]
  int v9; // [esp+4h] [ebp-44h]
  int v10; // [esp+8h] [ebp-40h]
  int v11; // [esp+Ch] [ebp-3Ch]
  int v12; // [esp+10h] [ebp-38h]
  int v13; // [esp+14h] [ebp-34h]
  int v14; // [esp+18h] [ebp-30h]
  int v15; // [esp+1Ch] [ebp-2Ch]
  int v16; // [esp+20h] [ebp-28h]
  int v17; // [esp+24h] [ebp-24h]
  int v18; // [esp+28h] [ebp-20h]
  int v19; // [esp+2Ch] [ebp-1Ch]
  int v20; // [esp+30h] [ebp-18h]
  int v21; // [esp+34h] [ebp-14h]
  int v22; // [esp+38h] [ebp-10h]

  if ( a5 )
  {
    dword_80742C4 = (int)&loc_8061EE7;
    sub_8067813(v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22);
  }
  v5 = *__errno_location();
  v6 = sub_8060ECE(
         a1,
         a2,
         a3,
         a4,
         dword_8075A10,
         *(&dword_8075A10 + 1),
         &dword_8075A10 + 2,
         *(&dword_8075A10 + 10),
         *(&dword_8075A10 + 11));
  *__errno_location() = v5;
  return v6;
}
// 8060ECE: using guessed type _DWORD __cdecl sub_8060ECE(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8067813: using guessed type int __stdcall sub_8067813(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80742C4: using guessed type int dword_80742C4;
// 8075A10: using guessed type int dword_8075A10;

//----- (08061FA9) --------------------------------------------------------
int __cdecl sub_8061FA9(int a1, int a2, _DWORD *a3, int *a4)
{
  int *v4; // eax
  int *v5; // ST3C_4
  int v6; // ST40_4
  int v7; // ST44_4
  int size; // [esp+48h] [ebp-10h]
  int v10; // [esp+4Ch] [ebp-Ch]

  if ( a4 )
    v4 = a4;
  else
    v4 = &dword_8075A10;
  v5 = v4;
  v6 = *__errno_location();
  v7 = v5[1] | (a3 == 0);
  size = sub_8060ECE(0, 0, a1, a2, *v5, v7, v5 + 2, v5[10], v5[11]) + 1;
  v10 = sub_8063987(size);
  sub_8060ECE(v10, size, a1, a2, *v5, v7, v5 + 2, v5[10], v5[11]);
  *__errno_location() = v6;
  if ( a3 )
    *a3 = size - 1;
  return v10;
}
// 8060ECE: using guessed type _DWORD __cdecl sub_8060ECE(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8075A10: using guessed type int dword_8075A10;

//----- (08062180) --------------------------------------------------------
#error "80622F0: call analysis failed (funcsize=103)"

//----- (080622F5) --------------------------------------------------------
#error "8062418: positive sp value has been found (funcsize=83)"

//----- (0806241B) --------------------------------------------------------
int __cdecl sub_806241B(int a1, int a2)
{
  return sub_8062180(a1, a2, -1, &dword_8075A10);
}
// 8062180: using guessed type _DWORD __cdecl sub_8062180(_DWORD, _DWORD, _DWORD, _DWORD);
// 8075A10: using guessed type int dword_8075A10;

//----- (08062449) --------------------------------------------------------
int __cdecl sub_8062449(int a1, int a2, int a3)
{
  return sub_8062180(a1, a2, a3, &dword_8075A10);
}
// 8062180: using guessed type _DWORD __cdecl sub_8062180(_DWORD, _DWORD, _DWORD, _DWORD);
// 8075A10: using guessed type int dword_8075A10;

//----- (080624F2) --------------------------------------------------------
int __cdecl sub_80624F2(int a1, int a2, int a3)
{
  char v4; // [esp+10h] [ebp-38h]

  sub_8060CAE((int)&v4);
  return sub_8062180(a1, a3, -1, &v4);
}
// 8062180: using guessed type _DWORD __cdecl sub_8062180(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08062544) --------------------------------------------------------
int __cdecl sub_8062544(int a1, int a2, int a3, int a4)
{
  char v5; // [esp+10h] [ebp-38h]

  sub_8060CAE((int)&v5);
  return sub_8062180(a1, a3, a4, &v5);
}
// 8062180: using guessed type _DWORD __cdecl sub_8062180(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08062581) --------------------------------------------------------
#error "8062592: call analysis failed (funcsize=12)"

//----- (080625A5) --------------------------------------------------------
int __cdecl sub_80625A5(int a1, int a2, int a3)
{
  return sub_80624F2(0, a2, a3);
}

//----- (08062609) --------------------------------------------------------
int __cdecl sub_8062609(int a1, int a2, unsigned __int8 a3)
{
  int v4; // [esp+0h] [ebp-58h]
  unsigned __int8 v5; // [esp+1Ch] [ebp-3Ch]
  int v6; // [esp+20h] [ebp-38h]
  int v7; // [esp+24h] [ebp-34h]
  int v8; // [esp+28h] [ebp-30h]
  int v9; // [esp+2Ch] [ebp-2Ch]
  int v10; // [esp+30h] [ebp-28h]
  int v11; // [esp+34h] [ebp-24h]
  int v12; // [esp+38h] [ebp-20h]
  int v13; // [esp+3Ch] [ebp-1Ch]
  int v14; // [esp+40h] [ebp-18h]
  int v15; // [esp+44h] [ebp-14h]
  int v16; // [esp+48h] [ebp-10h]
  int v17; // [esp+4Ch] [ebp-Ch]

  v5 = a3;
  v6 = dword_8075A10;
  v7 = dword_8075A14;
  v8 = dword_8075A18;
  v9 = dword_8075A1C;
  v10 = dword_8075A20;
  v11 = dword_8075A24;
  v12 = dword_8075A28;
  v13 = dword_8075A2C;
  v14 = dword_8075A30;
  v15 = dword_8075A34;
  v16 = dword_8075A38;
  v17 = dword_8075A3C;
  sub_8060B3A(&v4 - 14, a3, 1);
  return sub_8062180(0, a1, a2, &v6);
}
// 8062180: using guessed type _DWORD __cdecl sub_8062180(_DWORD, _DWORD, _DWORD, _DWORD);
// 8075A10: using guessed type int dword_8075A10;
// 8075A14: using guessed type int dword_8075A14;
// 8075A18: using guessed type int dword_8075A18;
// 8075A1C: using guessed type int dword_8075A1C;
// 8075A20: using guessed type int dword_8075A20;
// 8075A24: using guessed type int dword_8075A24;
// 8075A28: using guessed type int dword_8075A28;
// 8075A2C: using guessed type int dword_8075A2C;
// 8075A30: using guessed type int dword_8075A30;
// 8075A34: using guessed type int dword_8075A34;
// 8075A38: using guessed type int dword_8075A38;
// 8075A3C: using guessed type int dword_8075A3C;

//----- (080626C7) --------------------------------------------------------
int __cdecl sub_80626C7(int a1, unsigned __int8 a2)
{
  return sub_8062609(a1, -1, a2);
}

//----- (08062700) --------------------------------------------------------
int __cdecl sub_8062700(int a1)
{
  return sub_80626C7(a1, 0x3Au);
}

//----- (08062745) --------------------------------------------------------
int __cdecl sub_8062745(int a1, int a2, int a3)
{
  int v4; // [esp+0h] [ebp-78h]
  int v5; // [esp+10h] [ebp-68h]
  int v6; // [esp+14h] [ebp-64h]
  int v7; // [esp+18h] [ebp-60h]
  int v8; // [esp+1Ch] [ebp-5Ch]
  int v9; // [esp+20h] [ebp-58h]
  int v10; // [esp+24h] [ebp-54h]
  int v11; // [esp+28h] [ebp-50h]
  int v12; // [esp+2Ch] [ebp-4Ch]
  int v13; // [esp+30h] [ebp-48h]
  int v14; // [esp+34h] [ebp-44h]
  int v15; // [esp+38h] [ebp-40h]
  int v16; // [esp+3Ch] [ebp-3Ch]
  int v17; // [esp+40h] [ebp-38h]
  int v18; // [esp+44h] [ebp-34h]
  int v19; // [esp+48h] [ebp-30h]
  int v20; // [esp+4Ch] [ebp-2Ch]
  int v21; // [esp+50h] [ebp-28h]
  int v22; // [esp+54h] [ebp-24h]
  int v23; // [esp+58h] [ebp-20h]
  int v24; // [esp+5Ch] [ebp-1Ch]
  int v25; // [esp+60h] [ebp-18h]
  int v26; // [esp+64h] [ebp-14h]
  int v27; // [esp+68h] [ebp-10h]
  int v28; // [esp+6Ch] [ebp-Ch]

  sub_8060CAE((int)&v5);
  v17 = v5;
  v18 = v6;
  v19 = v7;
  v20 = v8;
  v21 = v9;
  v22 = v10;
  v23 = v11;
  v24 = v12;
  v25 = v13;
  v26 = v14;
  v27 = v15;
  v28 = v16;
  sub_8060B3A(&v4 - 14, 0x3Au, 1);
  return sub_8062180(a1, a3, -1, &v17);
}
// 8062180: using guessed type _DWORD __cdecl sub_8062180(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (080627FA) --------------------------------------------------------
int __cdecl sub_80627FA(int a1, int a2, int a3, int a4)
{
  return sub_806284A(a1, a2, a3, a4, -1);
}
// 806284A: using guessed type int __cdecl sub_806284A(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0806284A) --------------------------------------------------------
#error "80628B4: call analysis failed (funcsize=31)"

//----- (080628B9) --------------------------------------------------------
#error "806290F: positive sp value has been found (funcsize=0)"

//----- (0806298D) --------------------------------------------------------
int __cdecl sub_806298D(int a1, int a2, int a3)
{
  return sub_8062180(a1, a2, a3, &unk_8074470);
}
// 8062180: using guessed type _DWORD __cdecl sub_8062180(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (080629EC) --------------------------------------------------------
int __cdecl sub_80629EC(int a1, int a2)
{
  return sub_806298D(a1, a2, -1);
}

//----- (08062A30) --------------------------------------------------------
int __cdecl sub_8062A30(int a1)
{
  return sub_80629EC(0, a1);
}

//----- (08062A4F) --------------------------------------------------------
int __usercall sub_8062A4F@<eax>(int a1@<edx>, int a2@<ecx>, void *src, void *a4)
{
  int v4; // edx
  int v5; // ecx
  size_t v6; // ST20_4
  bool v7; // al
  char *s1; // [esp+18h] [ebp-E0h]
  char *s2; // [esp+1Ch] [ebp-DCh]
  size_t n; // [esp+24h] [ebp-D4h]

  s1 = sub_80580E7(a1, a2, src);
  s2 = sub_80580E7(v4, v5, a4);
  v6 = sub_805815B(s1);
  n = sub_805815B(s2);
  v7 = v6 == n && !memcmp(s1, s2, n);
  if ( v7 )
    sub_8066184(src);
  return 0;
}

//----- (08062C85) --------------------------------------------------------
void sub_8062C85()
{
  ;
}

//----- (08062CF4) --------------------------------------------------------
signed int sub_8062CF4()
{
  *__errno_location() = 95;
  return -1;
}

//----- (08062D16) --------------------------------------------------------
signed int sub_8062D16()
{
  *__errno_location() = 95;
  return -1;
}

//----- (08062E50) --------------------------------------------------------
_DWORD *__userpurge sub_8062E50@<eax>(_DWORD *a1, int a2)
{
  int v2; // edx

  v2 = *(_DWORD *)(a2 + 68);
  *a1 = *(_DWORD *)(a2 + 64);
  a1[1] = v2;
  return a1;
}

//----- (08062E8B) --------------------------------------------------------
_DWORD *__userpurge sub_8062E8B@<eax>(_DWORD *a1, int a2)
{
  int v2; // edx

  v2 = *(_DWORD *)(a2 + 84);
  *a1 = *(_DWORD *)(a2 + 80);
  a1[1] = v2;
  return a1;
}

//----- (08062EC8) --------------------------------------------------------
_DWORD *__userpurge sub_8062EC8@<eax>(_DWORD *a1, int a2)
{
  int v2; // edx

  v2 = *(_DWORD *)(a2 + 76);
  *a1 = *(_DWORD *)(a2 + 72);
  a1[1] = v2;
  return a1;
}

//----- (08062F71) --------------------------------------------------------
int __cdecl sub_8062F71(int a1, int a2, int a3, int a4)
{
  if ( a1 < a3 )
    return -1;
  if ( a1 > a3 )
    return 1;
  return a2 - a4;
}

//----- (080630AC) --------------------------------------------------------
#error "80632AE: call analysis failed (funcsize=413)"

//----- (0806371F) --------------------------------------------------------
int __cdecl sub_806371F(FILE *stream, int a2, int a3, int a4, int a5)
{
  int *v5; // eax
  int v7; // [esp+0h] [ebp-58h]
  int i; // [esp+24h] [ebp-34h]
  int v9[12]; // [esp+28h] [ebp-30h]

  for ( i = 0; (unsigned int)i <= 9; ++i )
  {
    v5 = (int *)a5;
    a5 += 4;
    v9[i] = *v5;
    if ( !v9[i] )
      break;
  }
  return sub_80630AC(stream, a2, a3, a4, (int)(&v7 - 12), i);
}
// 806371F: using guessed type int var_30[12];

//----- (08063799) --------------------------------------------------------
int sub_8063799(FILE *stream, int a2, int a3, int a4, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a4);
  return sub_806371F(stream, a2, a3, a4, (int)va);
}

//----- (0806384D) --------------------------------------------------------
int __cdecl sub_806384D(unsigned int a1, unsigned int a2)
{
  if ( 0x7FFFFFFF / a2 < a1 )
    sub_8063B5E();
  return sub_806399E(a2 * a1);
}

//----- (0806388B) --------------------------------------------------------
void *__cdecl sub_806388B(void *ptr, int a2, int a3)
{
  if ( 0x7FFFFFFFu / a3 < a2 )
    sub_8063B5E();
  return sub_80639FF(ptr, a3 * a2);
}

//----- (080638D0) --------------------------------------------------------
void *__cdecl sub_80638D0(void *ptr, int a2, int a3)
{
  void *v4; // [esp+8h] [ebp-20h]
  unsigned int v5; // [esp+1Ch] [ebp-Ch]

  v5 = *(_DWORD *)a2;
  if ( ptr )
  {
    if ( 0x55555554u / a3 <= v5 )
      sub_8063B5E();
    v5 += (v5 >> 1) + 1;
  }
  else
  {
    if ( !v5 )
      v5 = (0x40u / a3 == 0) + 0x40u / a3;
    if ( 0x7FFFFFFFu / a3 < v5 )
      sub_8063B5E();
  }
  *(_DWORD *)a2 = v5;
  return sub_80639FF(v4, a3 * v5);
}

//----- (08063987) --------------------------------------------------------
int __cdecl sub_8063987(size_t size)
{
  return sub_806399E(size);
}

//----- (0806399E) --------------------------------------------------------
#error "80639D8: call analysis failed (funcsize=24)"

//----- (080639FF) --------------------------------------------------------
void *__cdecl sub_80639FF(void *ptr, size_t size)
{
  void *result; // eax
  void *ptra; // [esp+20h] [ebp+8h]

  if ( size || !ptr )
  {
    ptra = realloc(ptr, size);
    if ( !ptra )
    {
      if ( size )
        sub_8063B5E();
    }
    result = ptra;
  }
  else
  {
    free(ptr);
    result = 0;
  }
  return result;
}

//----- (08063A4E) --------------------------------------------------------
void *__cdecl sub_8063A4E(void *ptr, int a2)
{
  return sub_80638D0(ptr, a2, 1);
}

//----- (08063B08) --------------------------------------------------------
void *__cdecl sub_8063B08(void *src, size_t n)
{
  void *v2; // eax

  v2 = (void *)sub_806399E(n);
  return memcpy(v2, src, n);
}

//----- (08063B31) --------------------------------------------------------
void *__cdecl sub_8063B31(char *s)
{
  size_t v1; // eax

  v1 = strlen(s);
  return sub_8063B08(s, v1 + 1);
}

//----- (08063B5E) --------------------------------------------------------
void __noreturn sub_8063B5E()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (08063BA5) --------------------------------------------------------
int __usercall sub_8063BA5@<eax>(int a1@<ebx>, char *nptr, int base, int a4, int a5, int a6, int a7, char *s, int a9, int status)
{
  int *v10; // eax
  int v11; // edx
  int v12; // ecx
  void *v14; // eax
  int v15; // ebx
  int v16; // edx
  signed int v17; // eax
  int v18; // [esp-10h] [ebp-58h]
  int v19; // [esp-8h] [ebp-50h]
  int *v20; // [esp-4h] [ebp-4Ch]
  int v21; // [esp+0h] [ebp-48h]
  int v22; // [esp+4h] [ebp-44h]
  int v23; // [esp+8h] [ebp-40h]
  int v24; // [esp+Ch] [ebp-3Ch]
  int v25; // [esp+10h] [ebp-38h]
  int v26; // [esp+14h] [ebp-34h]
  int v27; // [esp+18h] [ebp-30h]
  int v28; // [esp+1Ch] [ebp-2Ch]
  unsigned __int64 v29; // [esp+20h] [ebp-28h]
  unsigned __int64 v30; // [esp+28h] [ebp-20h]
  int v31; // [esp+30h] [ebp-18h]
  int *v32; // [esp+34h] [ebp-14h]
  unsigned __int64 v33; // [esp+38h] [ebp-10h]

  v30 = __PAIR__(a5, a4);
  v29 = __PAIR__(a7, a6);
  v10 = (int *)sub_8064797(nptr, a1, nptr, 0, base, (int)&v18, s);
  v32 = v10;
  if ( v10 )
  {
    if ( v32 == (int *)1 )
    {
      v10 = __errno_location();
      *v10 = 75;
    }
    else if ( v32 == (int *)3 )
    {
      v10 = __errno_location();
      *v10 = 0;
    }
  }
  else if ( v33 < v30 || (v10 = (int *)v33, v29 < v33) )
  {
    v32 = (int *)1;
    if ( v33 <= 0x3FFFFFFF )
    {
      *__errno_location() = 34;
      dword_8074274 = (int (__fastcall *)(_DWORD, _DWORD))&loc_8063D2F;
      v20 = (int *)&loc_8063D07;
      dword_8074270 = (int)&loc_8063D07;
      return ((int (__fastcall *)(int, int))loc_8063D2F)(v12, v11);
    }
    v10 = __errno_location();
    *v10 = 75;
  }
  v20 = v10;
  v19 = a1;
  v14 = &loc_8063D4E;
  if ( !v32 )
    v14 = &loc_8063DBD;
  dword_80741DC = (int)v14;
  sub_8067DA4(v21, v22, v23, v24, v25, v26, v27, v28, v29, HIDWORD(v29), v30);
  v15 = sub_8062A30((int)nptr);
  if ( *__errno_location() != 22 )
  {
    v16 = *__errno_location();
    dword_80741F0 = (int)&loc_8063D8E;
    sub_8067D38(v21, v22, v23, v24, v25, v26, v27, v28, v29, HIDWORD(v29), v30, HIDWORD(v30), v31, v32, v33);
  }
  if ( status )
    v17 = status;
  else
    v17 = 1;
  v25 = v15;
  v24 = a9;
  error(v17, 0, "%s: %s", a9, v15);
  return v33;
}
// 8067D38: using guessed type int __stdcall sub_8067D38(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8067DA4: using guessed type int __stdcall sub_8067DA4(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80741DC: using guessed type int dword_80741DC;
// 80741F0: using guessed type int dword_80741F0;
// 8074270: using guessed type int dword_8074270;
// 8074274: using guessed type int (__fastcall *dword_8074274)(_DWORD, _DWORD);

//----- (08063E3D) --------------------------------------------------------
char *sub_8063E3D()
{
  char *v1; // [esp+1Ch] [ebp-Ch]

  v1 = getcwd(0, 0);
  if ( !v1 && *__errno_location() == 12 )
    sub_8063B5E();
  return v1;
}

//----- (08063E7A) --------------------------------------------------------
char *sub_8063E7A()
{
  char *v0; // eax
  bool v1; // zf
  int v2; // edx
  int v3; // ecx
  void *v4; // eax
  int v6; // [esp+0h] [ebp-28h]
  int v7; // [esp+0h] [ebp-28h]
  int v8; // [esp+4h] [ebp-24h]
  int v9; // [esp+8h] [ebp-20h]
  int v10; // [esp+Ch] [ebp-1Ch]
  int v11; // [esp+10h] [ebp-18h]
  char *name; // [esp+14h] [ebp-14h]
  size_t len; // [esp+18h] [ebp-10h]
  int v14; // [esp+1Ch] [ebp-Ch]
  int v15; // [esp+20h] [ebp-8h]
  int v16; // [esp+24h] [ebp-4h]
  int savedregs; // [esp+28h] [ebp+0h]

  name = 0;
  v11 = 34;
  v0 = (char *)sub_8063A4E(0, (int)&v11);
  name = v0;
  len = v11 - 1;
  v0[v11 - 2] = 0;
  *__errno_location() = 0;
  v1 = gethostname(name, len) == 0;
  v4 = &loc_8063EF8;
  if ( !v1 )
    v4 = &loc_8063F16;
  dword_8074210 = (int)v4;
  sub_8067C60(v3, v2, v6);
  if ( !name[len - 1] )
    return name;
  dword_807429C = (int)&loc_8063E8E;
  return (char *)sub_806790C(v7, v8, v9, v10, v11, name, len, v14, v15, v16, savedregs);
}
// 806790C: using guessed type int __stdcall sub_806790C(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8074210: using guessed type int dword_8074210;
// 807429C: using guessed type int dword_807429C;

//----- (08063FB2) --------------------------------------------------------
signed int __cdecl sub_8063FB2(unsigned int *a1, unsigned int a2)
{
  signed int result; // eax

  if ( 0xFFFFFFFF / a2 >= *a1 )
  {
    *a1 *= a2;
    result = 0;
  }
  else
  {
    *a1 = -1;
    result = 1;
  }
  return result;
}

//----- (0806400A) --------------------------------------------------------
#error "8064025: call analysis failed (funcsize=24)"

//----- (08064055) --------------------------------------------------------
int __cdecl sub_8064055(char *nptr, int a2, int base, int a4, char *s)
{
  char **v5; // eax
  int result; // eax
  int v7; // eax
  bool v8; // zf
  void *v9; // eax
  int v10; // ST08_4
  int v11; // ST0C_4
  int v12; // ST10_4
  int v13; // ST08_4
  int v14; // ST0C_4
  int v15; // ST10_4
  int v16; // eax
  int v17; // ST08_4
  int v18; // ST0C_4
  int v19; // ST10_4
  int v20; // [esp+0h] [ebp-48h]
  int v21; // [esp+0h] [ebp-48h]
  int v22; // [esp+4h] [ebp-44h]
  int v23; // [esp+4h] [ebp-44h]
  int v24; // [esp+8h] [ebp-40h]
  int v25; // [esp+8h] [ebp-40h]
  int v26; // [esp+Ch] [ebp-3Ch]
  int v27; // [esp+Ch] [ebp-3Ch]
  int v28; // [esp+10h] [ebp-38h]
  int v29; // [esp+10h] [ebp-38h]
  int v30; // [esp+14h] [ebp-34h]
  int v31; // [esp+14h] [ebp-34h]
  int v32; // [esp+18h] [ebp-30h]
  int v33; // [esp+18h] [ebp-30h]
  int v34; // [esp+1Ch] [ebp-2Ch]
  int v35; // [esp+1Ch] [ebp-2Ch]
  char v36; // [esp+20h] [ebp-28h]
  unsigned int v37; // [esp+24h] [ebp-24h]
  int v38; // [esp+28h] [ebp-20h]
  char *v39; // [esp+2Ch] [ebp-1Ch]
  unsigned int v40; // [esp+30h] [ebp-18h]
  int v41; // [esp+34h] [ebp-14h]
  int v42; // [esp+38h] [ebp-10h]
  char **endptr; // [esp+3Ch] [ebp-Ch]

  v38 = 0;
  if ( base < 0 || base > 36 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoul");
  if ( a2 )
    v5 = (char **)a2;
  else
    v5 = (char **)&v36;
  endptr = v5;
  *__errno_location() = 0;
  v39 = nptr;
  HIBYTE(v34) = *nptr;
  dword_80742C4 = (int)&loc_80640E7;
  sub_8067813(v20, v22, v24, v26, v28, v30, v32, v34, *(_DWORD *)&v36, v37, v38, nptr, v40, v41, v42);
  do
    HIBYTE(v35) = *++v39;
  while ( (*__ctype_b_loc())[HIBYTE(v35)] & 0x2000 );
  if ( HIBYTE(v35) == 45 )
    return 4;
  v37 = strtoul(nptr, endptr, base);
  if ( *endptr == nptr )
  {
    if ( !s || !**endptr || !strchr(s, **endptr) )
      return 4;
    v37 = 1;
  }
  else if ( *__errno_location() )
  {
    if ( *__errno_location() != 34 )
      return 4;
    v38 = 1;
  }
  if ( s )
  {
    if ( **endptr )
    {
      v40 = 1024;
      v41 = 1;
      if ( !strchr(s, **endptr) )
      {
        *(_DWORD *)a4 = v37;
        dword_807429C = (int)&locret_80644E9;
        sub_806790C(v21, v23, v25, v27, v29, v31, v33, v35, *(_DWORD *)&v36, v37, v38);
      }
      switch ( **endptr )
      {
        case 69:
        case 71:
        case 75:
        case 77:
        case 80:
        case 84:
        case 89:
        case 90:
        case 103:
        case 107:
        case 109:
        case 116:
          if ( strchr(s, 48) )
          {
            v7 = (*endptr)[1];
            if ( v7 == 68 )
              goto LABEL_52;
            v8 = v7 == 105;
            v9 = &loc_8064285;
            if ( v8 )
              v9 = &loc_806428C;
            dword_807429C = (int)v9;
            if ( sub_806790C(v21, v23, v25, v27, v29, v31, v33, v35, *(_DWORD *)&v36, v37, v38) == 66 )
            {
LABEL_52:
              v40 = 1000;
              ++v41;
            }
          }
          break;
        default:
          break;
      }
      switch ( **endptr )
      {
        case 66:
          v42 = sub_8063FB2(&v37, 0x400u);
          break;
        case 69:
          v42 = sub_806400A(&v37, v40, 6);
          dword_80741DC = (int)&loc_80644A9;
          sub_8067DA4(v10, v11, v12, v27, v29, v31, v33, v35, *(_DWORD *)&v36, v37, v38);
          goto LABEL_38;
        case 71:
        case 103:
LABEL_38:
          v42 = sub_806400A(&v37, v40, 3);
          break;
        case 75:
        case 107:
          v42 = sub_806400A(&v37, v40, 1);
          break;
        case 77:
        case 109:
          v42 = sub_806400A(&v37, v40, 2);
          break;
        case 80:
          v42 = sub_806400A(&v37, v40, 5);
          break;
        case 84:
        case 116:
          v42 = sub_806400A(&v37, v40, 4);
          dword_80741DC = (int)&loc_80644A9;
          sub_8067DA4(v13, v14, v15, v27, v29, v31, v33, v35, *(_DWORD *)&v36, v37, v38);
          goto LABEL_43;
        case 89:
          v42 = sub_806400A(&v37, v40, 8);
          break;
        case 90:
          v16 = sub_806400A(&v37, v40, 7);
          dword_8074224 = (int)&loc_80644A9;
          sub_8067BEE(v17, v18, v19, v27, v29, v31, v33, v35, *(_DWORD *)&v36, v37, v38, v39, v40, v41, v16);
          goto LABEL_46;
        case 98:
          v42 = sub_8063FB2(&v37, 0x200u);
          break;
        case 99:
          v42 = 0;
          break;
        case 119:
LABEL_43:
          v42 = sub_8063FB2(&v37, 2u);
          break;
        default:
LABEL_46:
          *(_DWORD *)a4 = v37;
          dword_80741F0 = (int)&locret_80644E9;
          sub_8067D38(v21, v23, v25, v27, v29, v31, v33, v35, *(_DWORD *)&v36, v37, v38, v39, v40, v41, v42);
          break;
      }
      v38 |= v42;
      *endptr += v41;
      if ( **endptr )
        v38 |= 2u;
    }
    *(_DWORD *)a4 = v37;
    result = v38;
  }
  else
  {
    *(_DWORD *)a4 = v37;
    result = v38;
  }
  return result;
}
// 8067813: using guessed type int __stdcall sub_8067813(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806790C: using guessed type int __stdcall sub_806790C(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8067BEE: using guessed type int __stdcall sub_8067BEE(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8067D38: using guessed type int __stdcall sub_8067D38(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8067DA4: using guessed type int __stdcall sub_8067DA4(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80741DC: using guessed type int dword_80741DC;
// 80741F0: using guessed type int dword_80741F0;
// 8074224: using guessed type int dword_8074224;
// 807429C: using guessed type int dword_807429C;
// 80742C4: using guessed type int dword_80742C4;

//----- (080644EB) --------------------------------------------------------
#error "80645DC: call analysis failed (funcsize=75)"

//----- (080645E1) --------------------------------------------------------
#error "80645FD: positive sp value has been found (funcsize=0)"

//----- (080645FE) --------------------------------------------------------
void __cdecl __noreturn sub_80645FE(int a1, int a2, char a3, int a4, int a5)
{
  sub_80644EB(a1, a2, a3, a4, a5);
  abort();
}
// 80644EB: using guessed type _DWORD __cdecl sub_80644EB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (08064651) --------------------------------------------------------
int __cdecl sub_8064651(int a1, char *a2)
{
  unsigned __int64 v2; // rcx
  int v3; // edx
  int result; // eax

  LODWORD(v2) = sub_806721A(-1, -1, a2, (signed int)a2 >> 31);
  HIDWORD(v2) = v3;
  if ( v2 >= *(_QWORD *)a1 )
  {
    *(_QWORD *)a1 *= (signed int)a2;
    result = 0;
  }
  else
  {
    *(_DWORD *)a1 = -1;
    *(_DWORD *)(a1 + 4) = -1;
    result = 1;
  }
  return result;
}

//----- (08064701) --------------------------------------------------------
#error "8064752: call analysis failed (funcsize=43)"

//----- (08064797) --------------------------------------------------------
int __usercall sub_8064797@<eax>(char *a1@<eax>, int a2@<ebx>, char *nptr, int a4, int base, int a6, char *s)
{
  const char **v7; // ebp
  void *v8; // eax
  int v9; // ebx
  int v10; // eax
  bool v11; // zf
  void *v12; // eax
  int result; // eax
  void *v14; // eax
  int v15; // ebx
  int v16; // edx
  char *v17; // ecx
  void *v18; // eax
  int v19; // ebx
  char *v20; // eax
  void *v21; // eax
  int v22; // edx
  char *v23; // ecx
  int v24; // [esp-8h] [ebp-50h]
  char *v25; // [esp-4h] [ebp-4Ch]
  const char *v26; // [esp+0h] [ebp-48h]
  int v27; // [esp+4h] [ebp-44h]
  int v28; // [esp+8h] [ebp-40h]
  int v29; // [esp+Ch] [ebp-3Ch]
  int v30; // [esp+10h] [ebp-38h]
  int v31; // [esp+14h] [ebp-34h]
  int v32; // [esp+18h] [ebp-30h]
  int v33; // [esp+1Ch] [ebp-2Ch]
  int v34; // [esp+20h] [ebp-28h]
  char *v35; // [esp+24h] [ebp-24h]
  char *v36; // [esp+28h] [ebp-20h]
  int v37; // [esp+2Ch] [ebp-1Ch]
  int v38; // [esp+30h] [ebp-18h]
  char **endptr; // [esp+34h] [ebp-14h]
  uintmax_t v40; // [esp+38h] [ebp-10h]
  int savedregs; // [esp+48h] [ebp+0h]

  v7 = (const char **)&savedregs;
  v34 = 0;
  if ( base < 0 || base > 36 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoumax");
  v25 = a1;
  v24 = a2;
  v8 = &loc_80647CF;
  if ( a4 )
    v8 = &loc_80647FA;
  dword_8074224 = (int)v8;
  v9 = v24;
  sub_8067BEE(v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, endptr, v40);
  endptr = (char **)&v33;
  *__errno_location() = 0;
  v35 = nptr;
  HIBYTE(v32) = *nptr;
  v10 = (*__ctype_b_loc())[HIBYTE(v32)] & 0x2000;
  v11 = v10 == 0;
  v25 = (char *)v10;
  v24 = v9;
  v12 = &loc_8064860;
  if ( !v11 )
    v12 = &loc_806481C;
  dword_8074224 = (int)v12;
  sub_8067BEE(v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, endptr, v40);
  if ( HIBYTE(v32) == 45 )
    return 4;
  v40 = strtoumax(nptr, endptr, base);
  v11 = *endptr == nptr;
  v25 = *endptr;
  v14 = &loc_80648B2;
  if ( !v11 )
    v14 = &loc_806490E;
  dword_807429C = (int)v14;
  v15 = v24;
  sub_806790C(v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36);
  if ( s && **endptr && strchr(s, **endptr) )
  {
    v40 = 1LL;
  }
  else
  {
    dword_80742C4 = (int)&locret_8064D18;
    sub_8067813(v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, endptr, v40);
    v7 = &v26;
    if ( *__errno_location() )
    {
      if ( *__errno_location() != 34 )
      {
        dword_80742C4 = (int)&locret_8064D18;
        sub_8067813(v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, endptr, v40);
        v7 = &v26;
      }
      *(&v26 - 10) = (const char *)1;
    }
  }
  if ( v7[6] )
  {
    v11 = **(_BYTE **)*(v7 - 5) == 0;
    v25 = (char *)**(unsigned __int8 **)*(v7 - 5);
    v24 = v15;
    v18 = &loc_8064989;
    if ( v11 )
      v18 = &loc_8064D07;
    dword_80742C4 = (int)v18;
    v19 = v24;
    sub_8067813(v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, endptr, v40);
    *(v7 - 8) = (const char *)1024;
    *(v7 - 7) = (const char *)1;
    v27 = **(char **)*(v7 - 5);
    v26 = v7[6];
    v20 = strchr(v26, v27);
    v11 = v20 == 0;
    v25 = v20;
    v24 = v19;
    v21 = &loc_80649CE;
    if ( !v11 )
      v21 = &loc_8064A05;
    dword_80741F0 = (int)v21;
    sub_8067D38(v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, endptr, v40);
    v22 = (int)*(v7 - 3);
    v23 = (char *)v7[5];
    *(_DWORD *)v23 = *(v7 - 4);
    *((_DWORD *)v23 + 1) = v22;
    result = (unsigned int)*(v7 - 10) | 2;
  }
  else
  {
    v16 = (int)*(v7 - 3);
    v17 = (char *)v7[5];
    *(_DWORD *)v17 = *(v7 - 4);
    *((_DWORD *)v17 + 1) = v16;
    result = (int)*(v7 - 10);
  }
  return result;
}
// 8064797: could not find valid save-restore pair for ebx
// 8067813: using guessed type int __stdcall sub_8067813(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806790C: using guessed type int __stdcall sub_806790C(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8067BEE: using guessed type int __stdcall sub_8067BEE(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8067D38: using guessed type int __stdcall sub_8067D38(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80741F0: using guessed type int dword_80741F0;
// 8074224: using guessed type int dword_8074224;
// 807429C: using guessed type int dword_807429C;
// 80742C4: using guessed type int dword_80742C4;

//----- (08064D1A) --------------------------------------------------------
int __fastcall sub_8064D1A(int ecx0, int a2, int a1)
{
  int (*v3)(); // eax

  v3 = sub_8064DBF;
  if ( a1 )
    v3 = (int (*)())&loc_8064DC5;
  dword_8074274 = (int (__fastcall *)(_DWORD, _DWORD))v3;
  dword_8074270 = (int)sub_8064DBF;
  return ((int (__fastcall *)(int, int))v3)(ecx0, a2);
}
// 8064DBF: using guessed type int sub_8064DBF();
// 8074270: using guessed type int dword_8074270;
// 8074274: using guessed type int (__fastcall *dword_8074274)(_DWORD, _DWORD);

//----- (08064E3E) --------------------------------------------------------
int __cdecl sub_8064E3E(int a1, int a2)
{
  int result; // eax

  if ( *(_BYTE *)(a1 + 40) & 1 )
    result = (*(int (__cdecl **)(_DWORD, int))(a1 + 28))(*(_DWORD *)(a1 + 36), a2);
  else
    result = (*(int (__cdecl **)(int))(a1 + 28))(a2);
  return result;
}

//----- (08064E7C) --------------------------------------------------------
int __cdecl sub_8064E7C(int a1, int a2)
{
  int v3; // [esp+8h] [ebp-14h]
  int v4; // [esp+Ch] [ebp-10h]
  int v5; // [esp+10h] [ebp-Ch]
  int v6; // [esp+14h] [ebp-8h]
  int retaddr; // [esp+1Ch] [ebp+0h]

  if ( !(*(_BYTE *)(a1 + 40) & 1) )
    return (*(int (__stdcall **)(int, int, int, int, int))(a1 + 32))(a2, v3, v4, v5, v6);
  retaddr = v5;
  return (*(int (__cdecl **)(_DWORD))(a1 + 32))(*(_DWORD *)(v4 + 36));
}

//----- (08064EFE) --------------------------------------------------------
int __fastcall sub_8064EFE(int a1, int a2, int *a3, int a4, signed int a5)
{
  void *v5; // eax
  int v6; // ecx
  int (*v7)(); // eax
  int v9; // [esp+0h] [ebp-28h]

  if ( !a5 )
    a5 = 8;
  v5 = &loc_8064F30;
  if ( a4 )
    v5 = &loc_8064F46;
  dword_8074288 = (int)v5;
  sub_8067999(a1, a2, v9);
  *a3 = 4064;
  a3[6] = a5 - 1;
  a3[1] = sub_8064E3E((int)a3, *a3);
  v7 = sub_806502C;
  if ( a3[1] )
    v7 = (int (*)())&loc_8065033;
  dword_8074274 = (int (__fastcall *)(_DWORD, _DWORD))v7;
  dword_8074270 = (int)sub_806502C;
  return ((int (__fastcall *)(int, int *))v7)(v6, a3);
}
// 8064EFE: could not find valid save-restore pair for ebx
// 806502C: using guessed type int sub_806502C();
// 8074270: using guessed type int dword_8074270;
// 8074274: using guessed type int (__fastcall *dword_8074274)(_DWORD, _DWORD);
// 8074288: using guessed type int dword_8074288;

//----- (080650B3) --------------------------------------------------------
#error "80650F4: call analysis failed (funcsize=23)"

//----- (080650F9) --------------------------------------------------------
#error "8065111: call analysis failed (funcsize=23)"

//----- (08065193) --------------------------------------------------------
#error "8065259: call analysis failed (funcsize=174)"

//----- (0806554E) --------------------------------------------------------
int __cdecl sub_806554E(int a1, int a2)
{
  return (a1 == 0) ^ (a2 == 0) && a1 >= 0 && a2 >= 0;
}

//----- (08065586) --------------------------------------------------------
_BOOL4 __cdecl sub_8065586(_DWORD *a1, _DWORD *a2)
{
  int v2; // ebx
  _DWORD *v4; // [esp+8h] [ebp-4h]
  _DWORD *savedregs; // [esp+Ch] [ebp+0h]

  v2 = v4[5] ^ savedregs[5] | v4[4] ^ savedregs[4] | a1[3] ^ savedregs[3] | a1[2] ^ a2[2] | a1[1] ^ a2[1] | *a2 ^ *a1;
  return (v2 | (unsigned __int8)sub_806554E(v4[8], savedregs[8])) == 0;
}

//----- (0806564A) --------------------------------------------------------
char *__cdecl sub_806564A(void *dest, void *src, size_t n)
{
  char *result; // eax

  memcpy(dest, src, n);
  result = (char *)dest + n;
  *((_BYTE *)dest + n) = 0;
  return result;
}

//----- (08065676) --------------------------------------------------------
#error "80656B8: call analysis failed (funcsize=61)"

//----- (0806573D) --------------------------------------------------------
#error "8065786: call analysis failed (funcsize=114)"

//----- (08065940) --------------------------------------------------------
#error "8065964: call analysis failed (funcsize=27)"

//----- (0806599A) --------------------------------------------------------
char *sub_806599A()
{
  return getenv("TZ");
}

//----- (080659AE) --------------------------------------------------------
#error "80659EE: call analysis failed (funcsize=33)"

//----- (08065A13) --------------------------------------------------------
#error "8065A55: call analysis failed (funcsize=29)"

//----- (08065A6D) --------------------------------------------------------
signed int sub_8065A6D()
{
  int v0; // edx
  int v1; // ecx
  bool v2; // al
  int v3; // eax
  bool v4; // zf
  void *v5; // eax
  int v7; // [esp-4h] [ebp-2Ch]
  int v8; // [esp+0h] [ebp-28h]
  const char *v9; // [esp+4h] [ebp-24h]
  int v10; // [esp+8h] [ebp-20h]
  int v11; // [esp+Ch] [ebp-1Ch]

  *(&v8 - 5) = (int)sub_806599A();
  if ( *(&v8 - 5) )
  {
    v2 = 0;
    if ( *(_BYTE *)(v10 + 4) )
    {
      v9 = (const char *)*(&v8 - 5);
      if ( !strcmp((const char *)(v10 + 5), v9) )
        v2 = 1;
    }
    v3 = v2;
  }
  else
  {
    v3 = *(unsigned __int8 *)(v10 + 4);
    LOBYTE(v3) = (_BYTE)v3 == 0;
  }
  v4 = (_BYTE)v3 == 0;
  v7 = v3;
  v5 = &loc_8065AFF;
  if ( v4 )
    v5 = &loc_8065B06;
  dword_80742B0 = (int)v5;
  sub_806787F(v1, v0, v8, v9, v10, v11);
  return 1;
}
// 80742B0: using guessed type int dword_80742B0;

//----- (08065B5C) --------------------------------------------------------
#error "8065B80: call analysis failed (funcsize=56)"

//----- (08065C0B) --------------------------------------------------------
struct tm *__cdecl sub_8065C0B(int a1, time_t *timer, struct tm *tp)
{
  int v3; // ST00_4
  int v4; // ST04_4
  char v5; // al
  struct tm *result; // eax
  int v7; // [esp+8h] [ebp-20h]
  int v8; // [esp+Ch] [ebp-1Ch]
  int v9; // [esp+10h] [ebp-18h]
  int v10; // [esp+14h] [ebp-14h]
  int v11; // [esp+18h] [ebp-10h]
  char v12; // [esp+1Bh] [ebp-Dh]
  void *ptr; // [esp+1Ch] [ebp-Ch]

  if ( !a1 )
  {
    gmtime_r(timer, tp);
    dword_8074238 = (int)&locret_8065CB6;
    sub_8067B80(v3, v4, v7, v8, v9, v10, v11);
  }
  ptr = (void *)sub_8065A6D();
  if ( ptr
    && (!localtime_r(timer, tp) || !(unsigned __int8)sub_806573D(a1, tp) ? (v5 = 0) : (v5 = 1),
        (v12 = v5 & 1, (unsigned __int8)sub_8065B5C(ptr)) && v12) )
  {
    result = tp;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 806573D: using guessed type _DWORD __cdecl sub_806573D(_DWORD, _DWORD);
// 8067B80: using guessed type int __stdcall sub_8067B80(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8074238: using guessed type int dword_8074238;

//----- (08065CB8) --------------------------------------------------------
int __cdecl sub_8065CB8(int a1, struct tm *tp)
{
  int v2; // edx
  int v3; // ecx
  int v4; // ST00_4
  int v5; // edx
  int v6; // ecx
  int v8; // [esp+0h] [ebp-58h]
  int v9; // [esp+4h] [ebp-54h]
  int v10; // [esp+8h] [ebp-50h]
  int v11; // [esp+Ch] [ebp-4Ch]
  time_t timer; // [esp+18h] [ebp-40h]
  void *ptr; // [esp+1Ch] [ebp-3Ch]
  time_t v14; // [esp+20h] [ebp-38h]
  struct tm v15; // [esp+24h] [ebp-34h]

  if ( !a1 )
  {
    timegm(tp);
    dword_8074210 = (int)&locret_8065D94;
    sub_8067C60(v3, v2, v4);
  }
  ptr = (void *)sub_8065A6D();
  if ( ptr )
  {
    timer = mktime(tp);
    v14 = -1;
    if ( (timer != -1 || localtime_r(&timer, &v15) && sub_8065586(tp, &v15)) && (unsigned __int8)sub_806573D(a1, tp) ^ 1 )
      timer = v14;
    if ( (unsigned __int8)sub_8065B5C(ptr) )
    {
      dword_80742B0 = (int)&locret_8065D94;
      sub_806787F(v6, v5, v8, v9, v10, v11);
    }
  }
  return -1;
}
// 806573D: using guessed type _DWORD __cdecl sub_806573D(_DWORD, _DWORD);
// 8074210: using guessed type int dword_8074210;
// 80742B0: using guessed type int dword_80742B0;

//----- (08065F03) --------------------------------------------------------
int __cdecl sub_8065F03(int a1, char a2)
{
  return __ROR4__(a1, a2);
}

//----- (0806603E) --------------------------------------------------------
int __cdecl sub_806603E(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int *v2; // ebp
  unsigned __int8 *v3; // esi
  unsigned __int8 *v4; // ebx
  int v6; // [esp+0h] [ebp-28h]
  int v7; // [esp+4h] [ebp-24h]
  int v8; // [esp+8h] [ebp-20h]
  int v9; // [esp+Ch] [ebp-1Ch]
  int v10; // [esp+10h] [ebp-18h]
  int v11; // [esp+14h] [ebp-14h]
  int v12; // [esp+18h] [ebp-10h]
  int savedregs; // [esp+28h] [ebp+0h]

  v2 = &savedregs;
  v3 = a1;
  v4 = a2;
  if ( a1 == a2 )
    return 0;
  do
  {
    v6 = *v3;
    *((_BYTE *)v2 - 10) = sub_805729C(v6);
    v6 = *v4;
    *((_BYTE *)v2 - 9) = sub_805729C(v6);
    if ( !*((_BYTE *)v2 - 10) )
    {
      dword_8074238 = (int)&loc_80660A5;
      sub_8067B80(v6, v7, v8, v9, v10, v11, v12);
      v2 = &v6;
    }
    ++v3;
    ++v4;
  }
  while ( *((_BYTE *)v2 - 10) == *((_BYTE *)v2 - 9) );
  return *((unsigned __int8 *)v2 - 10) - *((unsigned __int8 *)v2 - 9);
}
// 805729C: using guessed type _DWORD __cdecl sub_805729C(_DWORD);
// 8067B80: using guessed type int __stdcall sub_8067B80(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8074238: using guessed type int dword_8074238;

//----- (080660DA) --------------------------------------------------------
int __cdecl sub_80660DA(FILE *fp)
{
  bool v1; // ST26_1
  void *v2; // eax
  int v4; // [esp+0h] [ebp-28h]
  int v5; // [esp+4h] [ebp-24h]
  int v6; // [esp+8h] [ebp-20h]
  int v7; // [esp+Ch] [ebp-1Ch]
  int v8; // [esp+10h] [ebp-18h]
  int v9; // [esp+14h] [ebp-14h]
  int v10; // [esp+18h] [ebp-10h]
  bool v11; // [esp+1Dh] [ebp-Bh]
  bool v12; // [esp+1Fh] [ebp-9h]

  v11 = __fpending(fp) != 0;
  v1 = ferror_unlocked(fp) != 0;
  v12 = sub_80669D1(fp) != 0;
  if ( !v1 )
  {
    v2 = &loc_806613E;
    if ( !v12 )
      v2 = &loc_806617D;
    dword_8074238 = (int)v2;
    sub_8067B80(v4, v5, v6, v7, v8, v9, v10);
    if ( !v11 && *__errno_location() == 9 )
      return 0;
  }
  if ( v12 != 1 )
    *__errno_location() = 0;
  return -1;
}
// 8067B80: using guessed type int __stdcall sub_8067B80(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8074238: using guessed type int dword_8074238;

//----- (08066184) --------------------------------------------------------
#error "80661B2: call analysis failed (funcsize=18)"

//----- (080661BC) --------------------------------------------------------
#error "80661C0: positive sp value has been found (funcsize=0)"

//----- (080661C1) --------------------------------------------------------
unsigned int sub_80661C1()
{
  int v1; // [esp+0h] [ebp-10h]
  int v2; // [esp+8h] [ebp-8h]
  unsigned int v3; // [esp+Ch] [ebp-4h]

  v3 = 0;
  for ( *(&v1 - 2) = v2; *(_BYTE *)*(&v1 - 2); ++*(&v1 - 2) )
    *(&v1 - 1) = __ROR4__(*(&v1 - 1), 23) + *(char *)*(&v1 - 2);
  return *(&v1 - 1) % v3;
}

//----- (0806622B) --------------------------------------------------------
int __usercall sub_806622B@<eax>(int a1@<ebx>)
{
  size_t v1; // eax
  int v2; // edx
  int v3; // ecx
  bool v4; // zf
  void *v5; // eax
  int v6; // ebx
  int v7; // ecx
  int v8; // edx
  const char *v9; // eax
  void *v10; // eax
  int v11; // ebx
  const char *v12; // eax
  void *v13; // eax
  int v15; // [esp-8h] [ebp-D0h]
  const char *v16; // [esp-4h] [ebp-CCh]
  const char *v17; // [esp+0h] [ebp-C8h]
  int v18; // [esp+4h] [ebp-C4h]
  int v19; // [esp+8h] [ebp-C0h]
  int v20; // [esp+Ch] [ebp-BCh]
  int v21; // [esp+10h] [ebp-B8h]
  void *ptr; // [esp+14h] [ebp-B4h]
  int v23; // [esp+18h] [ebp-B0h]
  char *s; // [esp+1Ch] [ebp-ACh]
  void *v25; // [esp+20h] [ebp-A8h]
  int v26; // [esp+24h] [ebp-A4h]
  char *v27; // [esp+28h] [ebp-A0h]
  size_t n; // [esp+2Ch] [ebp-9Ch]
  int v29; // [esp+30h] [ebp-98h]
  int v30; // [esp+34h] [ebp-94h]
  void *dest; // [esp+38h] [ebp-90h]
  unsigned int v32; // [esp+BCh] [ebp-Ch]

  v32 = __readgsdword(0x14u);
  *(&v17 - 44) = (const char *)dword_8075B50;
  if ( !*(&v17 - 44) )
  {
    *(&v17 - 45) = 0;
    *(&v17 - 40) = "charset.alias";
    *(&v17 - 43) = getenv("CHARSETALIASDIR");
    if ( !*(&v17 - 43) || !**(&v17 - 43) )
    {
      *(&v17 - 45) = 0;
      *(&v17 - 43) = "/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib";
    }
    v17 = *(&v17 - 43);
    *(&v17 - 39) = (const char *)strlen(v17);
    v17 = *(&v17 - 40);
    v1 = strlen(v17);
    *(&v17 - 38) = (const char *)v1;
    v4 = *(&v17 - 39) == 0;
    v16 = (const char *)v1;
    v15 = a1;
    v5 = &loc_8066322;
    if ( v4 )
      v5 = &loc_8066356;
    dword_8074288 = (int)v5;
    v6 = v15;
    sub_8067999(v3, v2, v17);
    v8 = (int)(*(&v17 - 39) - 1);
    if ( (*(&v17 - 43))[v8] != 47 )
    {
      dword_8074210 = (int)&loc_806635B;
      sub_8067C60(v7, v8, v17);
    }
    *(&v17 - 37) = 0;
    v17 = &(*(&v17 - 37))[(_DWORD)*(&v17 - 39) + 1 + (unsigned int)*(&v17 - 38)];
    v9 = (const char *)malloc((size_t)v17);
    *(&v17 - 36) = v9;
    v4 = *(&v17 - 36) == 0;
    v16 = v9;
    v15 = v6;
    v10 = &loc_80663AA;
    if ( v4 )
      v10 = &loc_806642B;
    dword_80741F0 = (int)v10;
    v11 = v15;
    sub_8067D38(v17, v18, v19, v20, v21, ptr, v23, s, v25, v26, v27, n, v29, v30, dest);
    memcpy((void *)*(&v17 - 36), *(&v17 - 43), (size_t)*(&v17 - 39));
    if ( *(&v17 - 37) )
      (*(&v17 - 39))[(_DWORD)*(&v17 - 36)] = 47;
    memcpy(
      (void *)&(*(&v17 - 37))[(_DWORD)*(&v17 - 39) + (unsigned int)*(&v17 - 36)],
      *(&v17 - 40),
      (size_t)(*(&v17 - 38) + 1));
    free((void *)*(&v17 - 45));
    v4 = *(&v17 - 36) == 0;
    v16 = v12;
    v15 = v11;
    v13 = &loc_806645B;
    if ( !v4 )
      v13 = &loc_806646A;
    dword_80742C4 = (int)v13;
    sub_8067813(v17, v18, v19, v20, v21, ptr, v23, s, v25, v26, v27, n, v29, v30, dest);
    *(&v17 - 44) = (const char *)&unk_806D673;
    dword_8075B50 = (int)*(&v17 - 44);
  }
  return (int)*(&v17 - 44);
}
// 8067813: using guessed type int __stdcall sub_8067813(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8067D38: using guessed type int __stdcall sub_8067D38(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80741F0: using guessed type int dword_80741F0;
// 8074210: using guessed type int dword_8074210;
// 8074288: using guessed type int dword_8074288;
// 80742C4: using guessed type int dword_80742C4;
// 8075B50: using guessed type int dword_8075B50;

//----- (0806691A) --------------------------------------------------------
const char *__usercall sub_806691A@<eax>(int a1@<ebx>)
{
  char *v1; // ST1C_4
  const char *s1; // [esp+18h] [ebp-10h]
  char *s2; // [esp+1Ch] [ebp-Ch]

  s1 = nl_langinfo(14);
  if ( !s1 )
    s1 = (const char *)&unk_806D673;
  for ( s2 = (char *)sub_806622B(a1); *s2; s2 = &v1[strlen(v1) + 1] )
  {
    if ( !strcmp(s1, s2) || *s2 == 42 && !s2[1] )
    {
      s1 = &s2[strlen(s2) + 1];
      break;
    }
    v1 = &s2[strlen(s2) + 1];
  }
  if ( !*s1 )
    s1 = "ASCII";
  return s1;
}

//----- (080669D1) --------------------------------------------------------
int __cdecl sub_80669D1(FILE *stream)
{
  int v2; // eax
  __int64 v3; // rax
  int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]

  v4 = 0;
  v5 = 0;
  v6 = fileno(stream);
  if ( v6 < 0 )
    return fclose(stream);
  if ( !__freading(stream) || (v2 = fileno(stream), LODWORD(v3) = lseek64(v2, 0, 0, 1), v3 != -1) )
  {
    if ( sub_8066AD1(stream) )
      v4 = *__errno_location();
  }
  v5 = fclose(stream);
  if ( v4 )
  {
    *__errno_location() = v4;
    v5 = -1;
  }
  return v5;
}
// 8049A70: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8066AD1: using guessed type int __cdecl sub_8066AD1(_DWORD);

//----- (08066A98) --------------------------------------------------------
int __cdecl sub_8066A98(FILE *stream)
{
  int result; // eax

  result = stream->_flags & 0x100;
  if ( result )
    result = sub_8066B48(stream, 0, 0, 1);
  return result;
}

//----- (08066AD1) --------------------------------------------------------
#error "8066AF6: call analysis failed (funcsize=15)"

//----- (08066AFB) --------------------------------------------------------
#error "8066B0B: positive sp value has been found (funcsize=8)"

//----- (08066B48) --------------------------------------------------------
int __cdecl sub_8066B48(FILE *stream, int a2, int a3, int a4)
{
  int v4; // eax
  __off64_t v5; // rax
  int v7; // [esp+0h] [ebp-38h]
  int v8; // [esp+4h] [ebp-34h]
  int v9; // [esp+8h] [ebp-30h]
  int v10; // [esp+Ch] [ebp-2Ch]

  if ( stream->_IO_read_end == stream->_IO_read_ptr
    && stream->_IO_write_ptr == stream->_IO_write_base
    && !stream->_IO_save_base )
  {
    v4 = fileno(stream);
    LODWORD(v5) = lseek64(v4, a2, a3, a4);
    if ( v5 == -1 )
      return -1;
    stream->_flags &= 0xFFFFFFEF;
    stream->_offset = v5;
    dword_80742B0 = (int)&locret_8066C89;
    sub_806787F(stream, HIDWORD(v5), v7, v8, v9, v10);
  }
  return fseeko64(stream, a2, a3, a4);
}
// 8049610: using guessed type int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8049A70: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 80742B0: using guessed type int dword_80742B0;

//----- (08066C8F) --------------------------------------------------------
int __cdecl sub_8066C8F(int a1, int a2, int a3, int a4)
{
  int v5; // [esp+4h] [ebp-18h]

  v5 = a3;
  dword_8074274 = (int (__fastcall *)(_DWORD, _DWORD))sub_8066D6E;
  dword_8074270 = (int)sub_8066D60;
  return ((int (__fastcall *)(int, int))sub_8066D6E)(a2, a1);
}
// 8066D60: using guessed type int sub_8066D60();
// 8066D6E: using guessed type int sub_8066D6E();
// 8074270: using guessed type int dword_8074270;
// 8074274: using guessed type int (__fastcall *dword_8074274)(_DWORD, _DWORD);

//----- (08066D1B) --------------------------------------------------------
#error "8066D54: positive sp value has been found (funcsize=18)"

//----- (08066FB5) --------------------------------------------------------
#error "8067041: call analysis failed (funcsize=93)"

//----- (0806721A) --------------------------------------------------------
#error "80672EF: call analysis failed (funcsize=83)"

//----- (0806739B) --------------------------------------------------------
#error "806752A: call analysis failed (funcsize=156)"

//----- (080675B7) --------------------------------------------------------
int __cdecl sub_80675B7(int a1)
{
  return __cxa_atexit(a1, 0, dword_80742F4);
}
// 80497B0: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 80742F4: using guessed type int dword_80742F4;

//----- (080675EA) --------------------------------------------------------
int __cdecl sub_80675EA(int a1, int a2)
{
  return __xstat64(3, a1, a2);
}
// 8049AE0: using guessed type int __cdecl __xstat64(_DWORD, _DWORD, _DWORD);

//----- (0806761D) --------------------------------------------------------
int __cdecl sub_806761D(int a1, int a2)
{
  return __fxstat64(3, a1, a2);
}
// 8049730: using guessed type int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD);

//----- (0806766C) --------------------------------------------------------
int __cdecl sub_806766C(int a1, int a2)
{
  return __lxstat64(3, a1, a2);
}
// 8049AF0: using guessed type int __cdecl __lxstat64(_DWORD, _DWORD, _DWORD);

//----- (08067813) --------------------------------------------------------
#error "8067819: positive sp value has been found (funcsize=0)"

//----- (0806787F) --------------------------------------------------------
#error "8067885: positive sp value has been found (funcsize=0)"

//----- (080678CB) --------------------------------------------------------
#error "8067904: positive sp value has been found (funcsize=18)"

//----- (0806790C) --------------------------------------------------------
#error "8067912: positive sp value has been found (funcsize=0)"

//----- (08067999) --------------------------------------------------------
#error "806799F: positive sp value has been found (funcsize=0)"

//----- (08067A7F) --------------------------------------------------------
#error "8067A85: positive sp value has been found (funcsize=0)"

//----- (08067AD1) --------------------------------------------------------
#error "8067B0A: positive sp value has been found (funcsize=18)"

//----- (08067B12) --------------------------------------------------------
#error "8067B18: positive sp value has been found (funcsize=0)"

//----- (08067B80) --------------------------------------------------------
#error "8067B86: positive sp value has been found (funcsize=0)"

//----- (08067BEE) --------------------------------------------------------
#error "8067BF4: positive sp value has been found (funcsize=0)"

//----- (08067C60) --------------------------------------------------------
#error "8067C66: positive sp value has been found (funcsize=0)"

//----- (08067D38) --------------------------------------------------------
#error "8067D3E: positive sp value has been found (funcsize=0)"

//----- (08067DA4) --------------------------------------------------------
#error "8067DAA: positive sp value has been found (funcsize=0)"

//----- (08067DC0) --------------------------------------------------------
int (**sub_8067DC0())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_8073EC8;
  v1 = &off_8073ECC - off_8073EC8;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_8073EC8[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 8073EC8: using guessed type int (*off_8073EC8[2])();
// 8073ECC: using guessed type int (*off_8073ECC)();

//----- (08067E24) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 129 decompilation failure(s) on 415 function(s)"
