/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8049480();
// int unsetenv(const char *name);
// int raise(int sig);
// int strcmp(const char *s1, const char *s2);
// int __cdecl open64(_DWORD, _DWORD); weak
// int putc_unlocked(int c, FILE *stream);
// struct passwd *getpwuid(__uid_t uid);
// int printf(const char *format, ...);
// void longjmp(struct __jmp_buf_tag env[1], int val);
// int fflush(FILE *stream);
// void _exit(int status);
// int sigprocmask(int how, const sigset_t *set, sigset_t *oset);
// int dirfd(DIR *dirp);
// int __cdecl wcwidth(_DWORD); weak
// void *memmove(void *dest, const void *src, size_t n);
// int _setjmp(struct __jmp_buf_tag env[1]);
// void free(void *ptr);
// uintmax_t strtoumax(const char *nptr, char **endptr, int base);
// void *memcpy(void *dest, const void *src, size_t n);
// int mbsinit(const mbstate_t *ps);
// int clock_gettime(clockid_t clock_id, struct timespec *tp);
// int tolower(int c);
// int fclose(FILE *stream);
// int getc_unlocked(FILE *stream);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// __sighandler_t signal(int sig, __sighandler_t handler);
// int memcmp(const void *s1, const void *s2, size_t n);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// time_t mktime(struct tm *tp);
// struct tm *localtime_r(const time_t *timer, struct tm *tp);
// int sigismember(const sigset_t *set, int signo);
// int fflush_unlocked(FILE *stream);
// int iswcntrl(wint_t wc);
// char *textdomain(const char *domainname);
// ssize_t readlink(const char *path, char *buf, size_t len);
// int fnmatch(const char *pattern, const char *name, int flags);
// int iswprint(wint_t wc);
// int ioctl(int fd, unsigned int request, ...);
// int ferror_unlocked(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD); weak
// void tzset(void);
// size_t __ctype_get_mb_cur_max(void);
// char *strcpy(char *dest, const char *src);
// size_t __fpending(FILE *fp);
// size_t wcstombs(char *s, const wchar_t *pwcs, size_t n);
// int gethostname(char *name, size_t len);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// void error(int status, int errnum, const char *format, ...);
// int strcoll(const char *s1, const char *s2);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// time_t timegm(struct tm *tp);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// size_t strftime(char *s, size_t maxsize, const char *format, const struct tm *tp);
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// char *strchr(const char *s, int c);
// char *getcwd(char *buf, size_t size);
// int fscanf(FILE *stream, const char *format, ...);
// size_t strlen(const char *s);
// int setenv(const char *name, const char *value, int replace);
// int fprintf(FILE *stream, const char *format, ...);
// int sigaddset(sigset_t *set, int signo);
// void *memset(void *s, int c, size_t n);
// int ungetc(int c, FILE *stream);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// int *__errno_location(void);
// __pid_t tcgetpgrp(int fd);
// int fileno(FILE *stream);
// int __cdecl stpncpy(_DWORD, _DWORD, _DWORD); weak
// unsigned int gnu_dev_major(unsigned __int64 dev);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// int __cdecl mempcpy(_DWORD, _DWORD, _DWORD); weak
// int sigemptyset(sigset_t *set);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// int toupper(int c);
// char *strrchr(const char *s, int c);
// size_t mbstowcs(wchar_t *pwcs, const char *s, size_t n);
// struct tm *gmtime_r(const time_t *timer, struct tm *tp);
// unsigned int gnu_dev_minor(unsigned __int64 dev);
// int sprintf(char *s, const char *format, ...);
// struct lconv *localeconv(void);
// int __cdecl lseek64(_DWORD, _DWORD); weak
// int readdir64(void); weak
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// char *bindtextdomain(const char *domainname, const char *dirname);
// int strncmp(const char *s1, const char *s2, size_t n);
// int isatty(int fd);
// void abort(void);
// int __cdecl __xstat64(_DWORD, _DWORD, _DWORD); weak
// int __cdecl __lxstat64(_DWORD, _DWORD, _DWORD); weak
// int close(int fd);
// int closedir(DIR *dirp);
// size_t strspn(const char *s, const char *accept);
// DIR *opendir(const char *name);
// struct group *getgrgid(__gid_t gid);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// void *calloc(size_t nmemb, size_t size);
// int putchar_unlocked(int c);
// int _gmon_start__(void); weak
void sub_8049BE3();
void sub_8049C00();
int sub_8049C10();
int sub_8049C80();
int sub_8049CA0();
void sub_8049CFF();
void sub_8049D1A();
signed int sub_8049D2A();
void sub_8049E0C();
void sub_8049E27();
int sub_8049E37();
void sub_8049F19();
void sub_8049F34();
int sub_8049F44();
void sub_804A026();
void sub_804A041();
int sub_804A051();
void sub_804A133();
void sub_804A14E();
void sub_804A269();
void sub_804A284();
int sub_804A294();
int nullsub_3(void); // weak
int sub_804A302();
void sub_804A3A2();
void sub_804A3BD();
int sub_804A3CD();
void sub_804A4CB();
void sub_804A4E6();
int sub_804A4F6();
void sub_804A5ED();
void sub_804A608();
int sub_804A618();
void sub_804A741();
void sub_804A760();
int sub_804A770();
// int __usercall sub_804A836@<eax>(void (__fastcall *a1)(int, int, signed int)@<eax>, int a2@<edx>, int a3@<ecx>);
void sub_804A8A2();
void sub_804A8C1();
int sub_804A8D5();
int __cdecl sub_804A989(int a1);
int __cdecl sub_804A9A0(unsigned __int8 a1);
_DWORD __cdecl sub_804A9B2(_DWORD); // weak
int sub_804AA27();
int sub_804AA56();
_DWORD __cdecl sub_804AA9F(_DWORD); // weak
int __cdecl sub_804AB57(char *s2, size_t n); // idb
int __cdecl sub_804ACA4(int a1, int a2);
int __cdecl sub_804ACD3(int a1);
bool __cdecl sub_804ACDB(int a1);
int sub_804AD11();
_DWORD __cdecl sub_804AD3D(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD *__stdcall sub_804AE3D(_DWORD *a1);
unsigned int __cdecl sub_804AF10(int a1, int a2);
_BYTE *__cdecl sub_804B07B(_BYTE *a1);
void sub_804B0D0();
signed int sub_804B142();
char *sub_804B259();
int sub_804B4B9();
int __cdecl sub_804B510(_QWORD *a1, _QWORD *a2);
void __cdecl sub_804B5A4(void *ptr);
int __cdecl sub_804B5BB(int a1, int a2, int a3);
void __cdecl sub_804B6AA(void *ptr);
int __cdecl sub_804B6E4(int a1);
size_t sub_804B7AA();
size_t sub_804B7DA();
int __cdecl sub_804B821(int a1);
int sub_804B837();
int sub_804B860();
__sighandler_t __cdecl sub_804B96D(void (*a1)(int));
__sighandler_t sub_804BB18();
__sighandler_t sub_804BB30();
int __cdecl main(int, char **, char **); // idb
int __cdecl sub_804BB87(char *locale, unsigned int line, char *function, int, int); // idb
// int __usercall sub_804C328@<eax>(double a1@<st0>, char *nptr);
_DWORD sub_804C3D9(); // weak
int __cdecl sub_804C413(int errnum, char *format, struct option *longopts, int *longind, int, char *s, int, int status); // idb
signed int sub_804DAF9();
_DWORD sub_804DBA4(); // weak
int __cdecl sub_804E138(int a1);
int __cdecl sub_804E16F(int, char *format, int); // idb
_DWORD *__cdecl sub_804E1C9(char *a1, char *s, int a3);
// unsigned int __usercall sub_804E253@<eax>(const unsigned __int16 *a1@<ebx>, long double a2@<st0>, char *a3, int a4, unsigned __int8 a5);
_DWORD *__cdecl sub_804EA25(int a1);
int __cdecl sub_804EA7C(int, char *name); // idb
int sub_804EAE0(void); // weak
int __cdecl sub_804EBF4(int a1);
int sub_804EC1E();
_DWORD __cdecl sub_804EC6C(_DWORD); // weak
int sub_804ED1C();
int __cdecl sub_804EDF8(int a1);
signed int sub_804EE2E();
int __cdecl sub_804EFF4(int a1, int a2);
// _BOOL4 __usercall sub_804F0AB@<eax>(int a1@<edx>, int a2@<ecx>, char *s);
_DWORD __cdecl sub_804F12E(_DWORD, _DWORD, __int64, _DWORD, _DWORD); // weak
int __cdecl sub_804F2C3(char *s2, int, int, int, int, int, int, char); // idb
int __cdecl sub_8050148(int a1);
int __cdecl sub_8050176(char *path, int, int); // idb
void *__cdecl sub_80501E3(int a1, char *s);
int __cdecl sub_80502EA(int a1);
int __cdecl sub_805032D(char *s, int); // idb
int __cdecl sub_805056C(char *s1, char *s2); // idb
int __cdecl sub_8050626(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD));
int __cdecl sub_80506A6(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD));
int __cdecl sub_8050726(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD));
int __cdecl sub_80507B4(_DWORD *a1, int *a2, int (__fastcall *a3)(_DWORD));
int __cdecl sub_805085D(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD));
int __cdecl sub_805088F(const char **a1, const char **a2, int (__cdecl *a3)(char *, char *));
int __cdecl sub_805106B(_DWORD *a1, int *a2);
int __cdecl sub_805108D(_DWORD *a1, int *a2);
int __cdecl sub_80510AF(int *a1, _DWORD *a2);
int __cdecl sub_80510D1(int *a1, _DWORD *a2);
int __cdecl sub_80510F3(_DWORD *a1, int *a2);
int __cdecl sub_8051161(_DWORD *a1, int *a2);
int __cdecl sub_8051302(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8051324(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8051346(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8051368(_DWORD *a1, _DWORD *a2);
int __cdecl sub_805138A(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80513F8(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8051466(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80514E9(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8051557(const char **a1, const char **a2);
int __cdecl sub_8051579(const char **a1, const char **a2);
int __cdecl sub_805159B(const char **a1, const char **a2);
int __cdecl sub_80515BD(const char **a1, const char **a2);
int __cdecl sub_80515DF(const char **a1, const char **a2);
int __cdecl sub_805164D(const char **a1, const char **a2);
int __cdecl sub_80516BB(const char **a1, const char **a2);
int __cdecl sub_8051742(const char **a1, const char **a2);
int __cdecl sub_80517C5(char **a1, char **a2);
int __cdecl sub_80517E3(char **a1, char **a2);
int __cdecl sub_80517FD(char **a1, char **a2);
int __cdecl sub_8051817(char **a1, char **a2);
int __cdecl sub_8051896(char **a1, char **a2);
int sub_80518FC();
// void __usercall sub_8051968(long double a1@<st0>);
int sub_8051ADE(void); // weak
// int __usercall sub_8051C60@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, unsigned __int8 a5, int a6, int a7, int a8);
int sub_8051D18();
int __cdecl sub_8051E04(char *s, int, int); // idb
// int __usercall sub_8051EF1@<eax>(int a1@<edx>, int a2@<ecx>, __uid_t uid, int a4, int a5);
int __cdecl sub_8051F44(__gid_t gid, int, int); // idb
size_t __cdecl sub_8051FD8(char *a1, int a2);
int __cdecl sub_805206B(__uid_t uid); // idb
const char *__cdecl sub_805214B(int a1, unsigned int a2, int a3);
_DWORD __cdecl sub_80521EA(_DWORD); // weak
int __cdecl sub_8052CAE(size_t size, size_t n, FILE *stream); // idb
// unsigned int __usercall sub_8052E60@<eax>(const unsigned __int16 *a1@<ebx>, double a2@<st0>, void **a3, unsigned int a4, char *a5, int *a6, int a7, unsigned int *a8, _BYTE *a9);
// int __usercall sub_80533DD@<eax>(const unsigned __int16 *a1@<ebx>, double a2@<st0>, char *a3, int *a4, int a5);
char *__cdecl sub_80534E5(char *s, int a2);
// int __usercall sub_8053622@<eax>(const unsigned __int16 *a1@<ebx>, double a2@<st0>, int a3, char *a4, int a5, int a6, char a7);
_DWORD __cdecl sub_8053B14(_DWORD, _DWORD, _DWORD, _DWORD); // weak
size_t sub_8053CE3();
// int __usercall sub_8053D2A@<eax>(int a1@<ebx>, int a2);
// int __usercall sub_8053FBE@<eax>(int a1@<edx>, int a2@<ecx>, char a3, __int16 a4, int a5);
int __cdecl sub_805413B(_DWORD, _DWORD, _DWORD); // weak
bool __cdecl sub_805415D(int a1, char a2);
bool __cdecl sub_80541E1(int a1);
_DWORD __cdecl sub_805423E(_DWORD, _DWORD); // weak
size_t __cdecl sub_80546B2(int a1);
// int __usercall sub_8054720@<eax>(const unsigned __int16 *a1@<ebx>, double a2@<st0>);
// unsigned int __usercall sub_805497A@<eax>(const unsigned __int16 *a1@<ebx>, double a2@<st0>);
// int __usercall sub_8054B0A@<eax>(const unsigned __int16 *a1@<ebx>, double a2@<st0>);
// int __usercall sub_8054C84@<eax>(const unsigned __int16 *a1@<ebx>, double a2@<st0>, char a3);
_DWORD __cdecl sub_8054D6C(_DWORD, _DWORD); // weak
_BYTE *__cdecl sub_8054E54(_BYTE *a1, _BYTE *a2, _BYTE *a3);
int __fastcall sub_8054F1A(_DWORD, _DWORD); // weak
_DWORD __cdecl sub_8055196(_DWORD); // weak
void __cdecl __noreturn sub_8055468(int status); // idb
char *__cdecl sub_80557E2(char *path, int a2);
void __noreturn sub_80558FA();
int __cdecl sub_805590E(char *s, int, int, size_t); // idb
void __cdecl sub_8055A3D(int a1, int a2, int a3);
int __cdecl sub_8055AC0(int, int, size_t n); // idb
int __cdecl sub_8055C0B(int, char *s, int, int, size_t n, int); // idb
_BOOL4 __cdecl sub_8055D17(signed int a1);
_BOOL4 __cdecl sub_8055D70(signed int a1);
_BOOL4 __cdecl sub_8055E1D(int a1);
int __cdecl sub_8055F44(int a1);
int __cdecl sub_8055FA1(int, char *s, int); // idb
// char *__usercall sub_805606B@<eax>(long double a1@<st0>, void *src, int a3);
int sub_8056A3C();
_DWORD __cdecl sub_8056B35(_DWORD); // weak
void *__cdecl sub_8056BDD(void *src);
int __cdecl sub_8056C5F(_DWORD); // weak
size_t __cdecl sub_8056D24(char *s);
int sub_8056D62();
void __cdecl sub_8056D70(int a1, char *s, int a3);
bool __cdecl sub_8056E22(int a1, int a2, int *a3);
_DWORD __cdecl sub_8056EAA(_DWORD); // weak
_DWORD __cdecl sub_8056F8E(_DWORD, _DWORD); // weak
int __cdecl sub_8057179(int a1, int a2);
_DWORD __cdecl sub_8057196(_DWORD, _DWORD, _DWORD); // weak
_BYTE *__cdecl sub_8057205(_BYTE *a1);
void *__cdecl sub_8057221(int a1, _BYTE *a2, _DWORD *a3);
int __cdecl sub_8057497(unsigned __int8 a1);
signed int __cdecl sub_80574EC(int a1, unsigned int a2, int a3, unsigned int a4);
int __cdecl sub_805770A(char *s1, char *s2); // idb
struct timespec *__cdecl sub_80579D1(struct timespec *tp);
int __cdecl sub_8057A4E(int category); // idb
int __cdecl sub_8057AC5(int a1);
int __cdecl sub_8057AF0(int a1);
_DWORD sub_8057B1B(); // weak
int __cdecl sub_8057DAB(_DWORD *a1, int a2);
_DWORD __cdecl sub_8057DFF(_DWORD, _DWORD); // weak
_DWORD __cdecl sub_80580CA(_DWORD); // weak
int __cdecl sub_8058146(unsigned int a1);
unsigned int __cdecl sub_80581DF(int a1, unsigned int a2);
bool __cdecl sub_805820A(int a1, int a2);
double __cdecl sub_8058218(_DWORD); // weak
unsigned int __cdecl sub_80582D8(unsigned int a1, int a2);
size_t *__cdecl sub_80583AD(unsigned int a1, void *a2, unsigned int (__cdecl *a3)(int a1, unsigned int a2), bool (__cdecl *a4)(int a1, int a2), size_t a5);
// void __usercall sub_80585E0(int a1@<edx>, int a2@<ecx>, void *a3);
double __cdecl sub_80586E5(_DWORD); // weak
__int64 __cdecl sub_805874D(__int64 a1);
double __cdecl sub_8058790(_DWORD, _DWORD, _DWORD, _DWORD); // weak
signed int __cdecl sub_80589CD(_DWORD *a1, int a2, char a3);
double __cdecl sub_8058B72(_DWORD, _DWORD); // weak
double __cdecl sub_8058D90(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_805910D(int a1, int a2);
int __cdecl sub_8059150(int a1, int a2);
int __cdecl sub_80593CC(int a1, unsigned int a2);
int __cdecl sub_80595B3(int a1, int a2);
void __cdecl sub_8059673(void **a1);
int __cdecl sub_805969D(int, _TBYTE); // idb
void *__cdecl sub_8059819(int a1, size_t n, int a3, int a4);
int __cdecl sub_8059958(int, int, char *s, int, int, int, int, int); // idb
signed __int64 sub_805A897();
// int __usercall sub_805A8E5@<eax>(long double a1@<st0>, char *s, int a3, int a4);
// int __usercall sub_805AA8D@<eax>(long double a1@<st0>, char *s, int a3, int a4);
// int __usercall sub_805AAF6@<eax>(int a1@<edx>, int a2@<ecx>, __uid_t uid);
char *__cdecl sub_805AD6B(__gid_t gid);
int __cdecl sub_805AF7B(__int64 a1, int a2);
_DWORD __cdecl sub_805B0E9(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_805B1B0(wint_t *a1);
int __cdecl sub_805B203(_DWORD *a1, unsigned int a2);
_BYTE *__cdecl sub_805B281(_BYTE *a1, unsigned int a2, int a3);
// int __usercall sub_805B2D5@<eax>(long double a1@<st0>, char *s, int a3, int a4, int a5, int a6, int a7);
int __cdecl sub_805B80E(char *s, int); // idb
int __cdecl sub_805B867(char *a1, int a2, char a3);
// void *__usercall sub_805BB47@<eax>(long double fst7_0@<st0>, int a1, int a2, void *dest, int a4);
// void __usercall sub_805BD11(long double a1@<st0>, int a2, int a3, void *dest, int a5);
// void __usercall sub_805BFE9(long double a1@<st0>, int a2, int a3);
int sub_805C03D();
int __cdecl sub_805C0B3(int a1, int a2, int a3);
int __cdecl sub_805C117(int a1, int a2);
int __fastcall sub_805C184(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl sub_805C20A(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
char *__cdecl sub_805F078(char *s);
void *__cdecl sub_805F15F(void *src);
int __cdecl sub_805F1A5(int *a1);
int *__cdecl sub_805F1CC(int *a1, int a2);
_DWORD __cdecl sub_805F1F4(_DWORD, _DWORD, _DWORD); // weak
int *__cdecl sub_805F30A(int *a1, int a2, int a3);
_DWORD __cdecl sub_805F34F(_DWORD, _DWORD); // weak
const char *__cdecl sub_805F43A(char *msgid, int a2);
_DWORD __cdecl sub_805F4E8(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
// int __usercall sub_80603D4@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, int a6, _DWORD *a7);
void *__cdecl sub_8060507(int a1, int a2, _DWORD *a3, int *a4);
_DWORD __cdecl sub_8060720();
int __cdecl sub_80609E0();
int sub_8060A0A();
int __cdecl sub_8060AA6(int a1, int a2);
int __cdecl sub_8060AF4(int a1, int a2);
int __cdecl sub_8060B63(int a1);
int __cdecl sub_8060BC2(int a1, int a2, char a3);
int __cdecl sub_8060CBE(int a1, char a2);
int __cdecl sub_8060D07(int a1);
int __cdecl sub_8060D82(int a1, int a2, int a3);
int __cdecl sub_8060E57(int a1, int a2, int a3);
_DWORD __cdecl sub_8060EA7(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_8061036();
int __cdecl sub_80610C3();
int __cdecl sub_80610F3();
int __cdecl sub_8061120(void *src, void *); // idb
void sub_8061324();
signed int sub_8061375();
signed int sub_8061391();
// _DWORD *__userpurge sub_80614CF@<eax>(_DWORD *a1, int a2);
// _DWORD *__userpurge sub_806150A@<eax>(_DWORD *a1, int a2);
// _DWORD *__userpurge sub_8061547@<eax>(_DWORD *a1, int a2);
int __cdecl sub_80615F2(int a1, int a2, int a3, int a4);
int __cdecl sub_80616D0(FILE *stream, int, int, int, int, int); // idb
int __cdecl sub_8061E35(FILE *stream, int, int, int, int); // idb
int sub_8061ECB(FILE *stream, int a2, int a3, int a4, ...);
void *__cdecl sub_8061FAD(unsigned int a1, unsigned int a2);
void *__cdecl sub_8061FDF(void *ptr, int a2, int a3);
int __cdecl sub_8062014(void *ptr, int, int); // idb
void *__cdecl sub_80620FA(size_t size);
void *__cdecl sub_806210D(size_t size);
void *__cdecl sub_8062158(void *ptr, size_t size);
int __cdecl sub_80621CC(void *ptr, int); // idb
void *__cdecl sub_8062259(void *src, size_t n);
void *__cdecl sub_8062286(char *s);
void __noreturn sub_80622AF();
// __int64 __usercall sub_80622E8@<edx:eax>(int a1@<ebx>, double a2@<st0>, char *nptr, int base, int a4);
char *sub_80624F9();
_DWORD sub_8062536(); // weak
signed int __cdecl sub_8062653(unsigned int *a1, unsigned int a2);
int __cdecl sub_8062754(char *nptr, int, int base, int, char *s); // idb
int __cdecl sub_8062BB3(int, int, int, int, int, int status); // idb
void __cdecl __noreturn sub_8062CA6(int a1, int a2, char a3, int a4, int a5);
_DWORD __cdecl sub_8062D09(_DWORD, _DWORD); // weak
int __cdecl sub_8062DEE(int a1, int a2, int a3);
// int __usercall sub_8062E4A@<eax>(double a1@<st0>, char *nptr, int a3, int base, int a5, char *s);
_DWORD __cdecl sub_806330A(_DWORD); // weak
int __cdecl sub_80633F3(int a1, int a2);
int __cdecl sub_8063441(int a1, int a2);
signed int __cdecl sub_80634C6(int a1, signed int a2, signed int a3);
signed int __cdecl sub_80635E5(int a1, int a2, int a3, int a4);
_DWORD __cdecl sub_80636C0(_DWORD, _DWORD); // weak
int __cdecl sub_8063A4E(int a1, int a2);
_BOOL4 __cdecl sub_8063A92(_DWORD *a1, _DWORD *a2);
_DWORD __cdecl sub_8063B44(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_8063BD9(char *s); // idb
signed int __cdecl sub_8063CCC(int a1, unsigned int a2);
void *__cdecl sub_8063EA1(void *ptr);
char *sub_8063ED4();
int __cdecl sub_8063F0C(char *value); // idb
signed int __cdecl sub_8063F43(int a1);
signed int __cdecl sub_8063FB6(int a1);
int __cdecl sub_8064070(void *ptr); // idb
struct tm *__cdecl sub_80640F2(int a1, time_t *timer, struct tm *tp);
int __cdecl sub_80641A2(int, struct tm *tp); // idb
int __cdecl sub_806444A(int a1, char a2);
int __cdecl sub_80645DE(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_8064647(FILE *fp); // idb
void __cdecl __noreturn sub_80646CC(void *src); // idb
int sub_8064726(); // weak
int __cdecl sub_806472B(_BYTE *a1, unsigned int a2);
int sub_8064771(void); // weak
char *sub_8064CF6();
int __cdecl sub_8064DDB(FILE *stream); // idb
int __cdecl sub_8064EA2(FILE *stream); // idb
int __cdecl sub_8064EDF(FILE *fp); // idb
int __cdecl sub_8064F23(FILE *stream, int a2, int a3);
_DWORD __cdecl sub_8065051(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_8065237(__int64 a1, __int64 a2);
_DWORD __cdecl sub_8065498(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_80654DB(int, int, int, int, int, int, int, int, char *format); // idb
int __cdecl sub_8065666(unsigned __int64 a1, __int64 a2);
int __cdecl sub_80658A6(int a1);
int __cdecl sub_80658D5(int a1, int a2);
int __cdecl sub_8065934(int a1, int a2);
int __cdecl sub_8065967(int a1, int a2);
double __fastcall sub_8065ABA(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __fastcall sub_8065B5D(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
int __stdcall sub_8065BD3(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_8065C47(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
// double __userpurge sub_8065CCF@<st0>(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, double@<st0>); weak
int __fastcall sub_8065D3B(_DWORD, _DWORD, _DWORD, _DWORD);
int __fastcall sub_8065E0F(_DWORD); // weak
int (**sub_8065E20())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_804B1B5; // weak
_UNKNOWN loc_804B1BF; // weak
_UNKNOWN loc_804B8F1; // weak
_UNKNOWN loc_804B90B; // weak
_UNKNOWN loc_804C399; // weak
_UNKNOWN loc_804C3A0; // weak
_UNKNOWN loc_804E5F2; // weak
_UNKNOWN loc_804E6D2; // weak
_UNKNOWN loc_804E7DC; // weak
_UNKNOWN loc_804E7F8; // weak
_UNKNOWN loc_804EAC3; // weak
_UNKNOWN loc_804EACA; // weak
_UNKNOWN locret_80502E8; // weak
_UNKNOWN locret_80514E7; // weak
_UNKNOWN loc_805171F; // weak
_UNKNOWN loc_8051726; // weak
_UNKNOWN locret_80517C3; // weak
_UNKNOWN locret_8051894; // weak
_UNKNOWN loc_8052058; // weak
_UNKNOWN loc_805329B; // weak
_UNKNOWN loc_80532CD; // weak
_UNKNOWN loc_805334E; // weak
_UNKNOWN loc_8053398; // weak
_UNKNOWN loc_805339F; // weak
_UNKNOWN loc_805354E; // weak
_UNKNOWN loc_805356D; // weak
_UNKNOWN loc_8053609; // weak
_UNKNOWN loc_8053710; // weak
_UNKNOWN loc_8053729; // weak
_UNKNOWN loc_8053DF0; // weak
_UNKNOWN loc_8053DF7; // weak
_UNKNOWN loc_80540D0; // weak
_UNKNOWN loc_80540F9; // weak
_UNKNOWN loc_805410B; // weak
_UNKNOWN loc_8054135; // weak
_UNKNOWN loc_8054E83; // weak
_UNKNOWN loc_8054E90; // weak
_UNKNOWN loc_8054F08; // weak
_UNKNOWN loc_8055D4B; // weak
_UNKNOWN loc_8055D5A; // weak
_UNKNOWN loc_8056631; // weak
_UNKNOWN loc_80566C7; // weak
_UNKNOWN loc_80566F0; // weak
_UNKNOWN loc_80568DF; // weak
_UNKNOWN loc_80569D0; // weak
_UNKNOWN loc_8056A6D; // weak
_UNKNOWN loc_8056B11; // weak
_UNKNOWN locret_8056EA8; // weak
_UNKNOWN locret_8057708; // weak
_UNKNOWN loc_8057ABB; // weak
_UNKNOWN loc_8057ABF; // weak
_UNKNOWN loc_805868B; // weak
_UNKNOWN loc_805881B; // weak
_UNKNOWN loc_8058825; // weak
_UNKNOWN loc_805AA01; // weak
_UNKNOWN loc_805AA1D; // weak
_UNKNOWN loc_805AA7E; // weak
_UNKNOWN loc_805ABEC; // weak
_UNKNOWN loc_805AC09; // weak
_UNKNOWN locret_805AC0E; // weak
_UNKNOWN loc_805B2A7; // weak
_UNKNOWN loc_805B3B8; // weak
_UNKNOWN loc_805B3BD; // weak
_UNKNOWN loc_805B406; // weak
_UNKNOWN loc_805B41A; // weak
_UNKNOWN loc_805B513; // weak
_UNKNOWN loc_805B536; // weak
_UNKNOWN loc_805B5D4; // weak
_UNKNOWN loc_805B5DB; // weak
_UNKNOWN loc_805B6F6; // weak
_UNKNOWN loc_805B9BA; // weak
_UNKNOWN loc_805B9C9; // weak
_UNKNOWN loc_805BAC6; // weak
_UNKNOWN loc_805BAC8; // weak
_UNKNOWN loc_805BFE3; // weak
_UNKNOWN loc_806040B; // weak
_UNKNOWN loc_8060410; // weak
_UNKNOWN loc_806214A; // weak
_UNKNOWN loc_806214F; // weak
_UNKNOWN locret_80621CA; // weak
_UNKNOWN loc_8062413; // weak
_UNKNOWN loc_8062469; // weak
_UNKNOWN loc_8062F55; // weak
_UNKNOWN loc_8062F83; // weak
_UNKNOWN loc_8063088; // weak
_UNKNOWN loc_80630BE; // weak
_UNKNOWN loc_80630EC; // weak
_UNKNOWN loc_80630F7; // weak
_UNKNOWN loc_80632B2; // weak
_UNKNOWN locret_8063308; // weak
_UNKNOWN locret_80634C4; // weak
_UNKNOWN loc_8063C56; // weak
_UNKNOWN loc_8063CA7; // weak
_UNKNOWN loc_8063E66; // weak
_UNKNOWN loc_8063E77; // weak
_UNKNOWN locret_80640E2; // weak
_UNKNOWN locret_80641A0; // weak
_UNKNOWN loc_8064222; // weak
_UNKNOWN loc_806426A; // weak
_UNKNOWN loc_8064270; // weak
_UNKNOWN loc_8064721; // weak
_UNKNOWN loc_8064DB3; // weak
_UNKNOWN loc_8064DC1; // weak
_UNKNOWN loc_8065336; // weak
_UNKNOWN loc_8065341; // weak
_UNKNOWN loc_80657B5; // weak
_UNKNOWN loc_8065813; // weak
char locale = '\0'; // idb
_UNKNOWN unk_8067319; // weak
int (__cdecl *off_80686B0[28])(int, int) =
{
  &sub_8051302,
  &sub_805138A,
  &sub_8051346,
  &sub_8051466,
  &sub_8051324,
  &sub_80513F8,
  &sub_8051368,
  &sub_80514E9,
  &sub_8051557,
  &sub_80515DF,
  &sub_805159B,
  &sub_80516BB,
  &sub_8051579,
  &sub_805164D,
  &sub_80515BD,
  &sub_8051742,
  &sub_805106B,
  &sub_80510F3,
  &sub_80510AF,
  &sub_80511CF,
  &sub_805108D,
  &sub_8051161,
  &sub_80510D1,
  &sub_805127F,
  &sub_80517E3,
  &sub_8051817,
  &sub_80517FD,
  &sub_8051896
}; // weak
int sig[12] = { 20, 14, 1, 2, 13, 3, 15, 29, 27, 26, 24, 25 }; // idb
_UNKNOWN unk_806A698; // weak
char *off_806A76C[2] = { "human-readable", "si" }; // weak
int dword_806A778[2] = { 176, 144 }; // idb
_UNKNOWN unk_806A7FC; // weak
_UNKNOWN unk_806AB3E; // weak
_UNKNOWN unk_806AB42; // weak
_UNKNOWN unk_806AB4E; // weak
_UNKNOWN unk_806AB52; // weak
_UNKNOWN unk_806AB55; // weak
void *off_806B314[54] =
{
  &loc_80629F9,
  &loc_8062B51,
  &loc_8062B51,
  &loc_8062A20,
  &loc_8062B51,
  &loc_8062A42,
  &loc_8062B51,
  &loc_8062B51,
  &loc_8062B51,
  &loc_8062A76,
  &loc_8062B51,
  &loc_8062A98,
  &loc_8062B51,
  &loc_8062B51,
  &loc_8062ABA,
  &loc_8062B51,
  &loc_8062B51,
  &loc_8062B51,
  &loc_8062ADC,
  &loc_8062B51,
  &loc_8062B51,
  &loc_8062B51,
  &loc_8062B51,
  &loc_8062B13,
  &loc_8062B32,
  &loc_8062B51,
  &loc_8062B51,
  &loc_8062B51,
  &loc_8062B51,
  &loc_8062B51,
  &loc_8062B51,
  &loc_8062B51,
  &loc_80629DE,
  &loc_8062A14,
  &loc_8062B51,
  &loc_8062B51,
  &loc_8062B51,
  &loc_8062A42,
  &loc_8062B51,
  &loc_8062B51,
  &loc_8062B51,
  &loc_8062A76,
  &loc_8062B51,
  &loc_8062A98,
  &loc_8062B51,
  &loc_8062B51,
  &loc_8062B51,
  &loc_8062B51,
  &loc_8062B51,
  &loc_8062B51,
  &loc_8062ADC,
  &loc_8062B51,
  &loc_8062B51,
  &loc_8062AFB
}; // weak
_UNKNOWN unk_806B650; // weak
_UNKNOWN unk_806B6AB; // weak
_UNKNOWN unk_806D3A8; // weak
_UNKNOWN unk_806D3AB; // weak
_UNKNOWN unk_806F40C; // weak
_UNKNOWN unk_806F40F; // weak
int (*off_8071EDC[2])() = { &sub_8049CA0, &sub_8049C80 }; // weak
int (*off_8071EE0)() = &sub_8049C80; // weak
int (*dword_8072008)(void) = NULL; // weak
int dword_80721DC = 0; // weak
int dword_80721FC = 0; // weak
int dword_8072210 = 0; // weak
int dword_8072224 = 0; // weak
int dword_8072238 = 0; // weak
int dword_807224C = 0; // weak
int dword_8072260 = 0; // weak
int dword_8072290 = 0; // weak
int dword_80722CC[] = { 2 }; // weak
void *s1 = &unk_8067314; // idb
int dword_80722D4 = 1; // weak
_UNKNOWN unk_80722DC; // weak
int dword_80722E0 = 0; // weak
_UNKNOWN unk_80722E4; // weak
_UNKNOWN unk_80722EC; // weak
char *off_807238C = "%b %e  %Y"; // idb
char byte_8072394 = '\x01'; // weak
int dword_8072398 = 4294967295; // weak
int dword_80723D4 = 2; // weak
int status = 1; // idb
_UNKNOWN unk_807240C; // weak
_UNKNOWN unk_807242C; // weak
_UNKNOWN unk_807242F; // weak
_UNKNOWN unk_8072434; // weak
_UNKNOWN unk_8072437; // weak
_UNKNOWN unk_8072438; // weak
_UNKNOWN unk_807243B; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int program_invocation_name; // weak
FILE *stdout; // idb
int (*obstack_alloc_failed_handler)(void); // weak
char byte_807248C; // weak
_UNKNOWN unk_80724DD; // weak
void *dword_80727CF; // idb
void *dword_80727D3; // idb
int dword_80727DB; // weak
char byte_80727DF; // weak
char byte_80727E0; // weak
void *ptr; // idb
int dword_80727E7; // weak
char *dword_80727EF; // idb
int dword_80727F3; // weak
char byte_80727FF; // weak
char byte_8072800; // weak
int dword_8072803; // weak
int dword_8072807; // weak
int dword_807280B; // weak
int dword_807280F; // idb
int dword_8072813; // idb
int dword_8072817; // idb
int dword_807281B; // idb
int dword_807281F; // weak
int dword_8072823; // weak
int dword_8072827; // weak
int dword_807282B; // weak
int dword_807282F; // weak
int dword_8072833; // weak
char byte_8072837; // weak
char byte_8072839; // weak
char byte_807283A; // weak
int dword_807283B; // idb
int dword_807283F; // idb
int dword_8072843; // idb
char byte_807284B; // weak
int dword_807284F; // weak
char byte_8072853; // weak
char byte_8072854; // weak
char byte_8072855; // weak
char byte_8072860; // weak
char byte_8072867; // weak
char byte_8072869; // weak
int dword_807286F; // idb
char byte_8072877; // weak
int dword_807287B; // weak
int dword_807287F; // weak
char byte_8072887; // weak
int dword_807288B; // weak
int dword_807288F; // idb
sigset_t set; // idb
int dword_807292F; // weak
int dword_8072933; // weak
int dword_8072937; // weak
void *dword_807293B; // idb
int dword_8072943; // weak
_UNKNOWN unk_807298F; // weak
_UNKNOWN unk_80729CF; // weak
int dword_80729DB; // weak
char byte_8072A0F[3328]; // idb
char byte_807370F; // weak
struct __jmp_buf_tag env[1]; // idb
__int64 qword_80737CF; // weak
__int64 qword_80737DF; // weak
int dword_80737EB; // weak
char byte_80737EF; // weak
int dword_80737F3; // weak
int dword_80737FB; // weak
int dword_8073803; // weak
int dword_807380F; // weak
int dword_8073813; // weak
int dword_8073817; // weak
int dword_807381B; // weak
int dword_807381F; // weak
int dword_8073823; // weak
int dword_8073827; // weak
int dword_807382B; // weak
int dword_807382F; // weak
int dword_8073833; // weak
int dword_8073837; // weak
int dword_807383B; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (0804945C) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 8049BA0: using guessed type int _gmon_start__(void);

//----- (08049480) --------------------------------------------------------
int sub_8049480()
{
  return dword_8072008();
}
// 8072008: using guessed type int (*dword_8072008)(void);

//----- (08049BB0) --------------------------------------------------------
#error "8049BB3: positive sp value has been found (funcsize=2)"

//----- (08049BE3) --------------------------------------------------------
void sub_8049BE3()
{
  ;
}

//----- (08049C00) --------------------------------------------------------
void sub_8049C00()
{
  ;
}

//----- (08049C10) --------------------------------------------------------
int sub_8049C10()
{
  int result; // eax

  result = 134685763 - (_DWORD)&program_invocation_short_name;
  if ( (unsigned int)(134685763 - (_DWORD)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 8049C10: could not find valid save-restore pair for ebp
// 8072440: using guessed type int program_invocation_short_name;

//----- (08049C80) --------------------------------------------------------
int sub_8049C80()
{
  int result; // eax

  if ( !byte_807248C )
  {
    result = sub_8049C10();
    byte_807248C = 1;
  }
  return result;
}
// 8049C80: could not find valid save-restore pair for ebp
// 807248C: using guessed type char byte_807248C;

//----- (08049CA0) --------------------------------------------------------
int sub_8049CA0()
{
  return 0;
}
// 8049CA0: could not find valid save-restore pair for ebp

//----- (08049CFF) --------------------------------------------------------
void sub_8049CFF()
{
  ;
}

//----- (08049D1A) --------------------------------------------------------
void sub_8049D1A()
{
  ;
}

//----- (08049D2A) --------------------------------------------------------
signed int sub_8049D2A()
{
  return 3;
}
// 8049D2A: could not find valid save-restore pair for ebp

//----- (08049E0C) --------------------------------------------------------
void sub_8049E0C()
{
  ;
}

//----- (08049E27) --------------------------------------------------------
void sub_8049E27()
{
  ;
}

//----- (08049E37) --------------------------------------------------------
int sub_8049E37()
{
  int result; // eax

  result = &unk_80724DD - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_80724DD - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 8049E37: could not find valid save-restore pair for ebp
// 8072440: using guessed type int program_invocation_short_name;

//----- (08049F19) --------------------------------------------------------
void sub_8049F19()
{
  ;
}

//----- (08049F34) --------------------------------------------------------
void sub_8049F34()
{
  ;
}

//----- (08049F44) --------------------------------------------------------
int sub_8049F44()
{
  int result; // eax

  result = &unk_806F40F - &unk_806F40C;
  if ( (unsigned int)(&unk_806F40F - &unk_806F40C) > 6 )
    result = 0;
  return result;
}
// 8049F44: could not find valid save-restore pair for ebp

//----- (0804A026) --------------------------------------------------------
void sub_804A026()
{
  ;
}

//----- (0804A041) --------------------------------------------------------
void sub_804A041()
{
  ;
}

//----- (0804A051) --------------------------------------------------------
int sub_804A051()
{
  int result; // eax

  result = &unk_807242F - &unk_807242C;
  if ( (unsigned int)(&unk_807242F - &unk_807242C) > 6 )
    result = 0;
  return result;
}
// 804A051: could not find valid save-restore pair for ebp

//----- (0804A133) --------------------------------------------------------
void sub_804A133()
{
  ;
}

//----- (0804A14E) --------------------------------------------------------
void sub_804A14E()
{
  ;
}

//----- (0804A15E) --------------------------------------------------------
#error "804A19B: call analysis failed (funcsize=26)"

//----- (0804A269) --------------------------------------------------------
void sub_804A269()
{
  ;
}

//----- (0804A284) --------------------------------------------------------
void sub_804A284()
{
  ;
}

//----- (0804A294) --------------------------------------------------------
int sub_804A294()
{
  int result; // eax

  result = &unk_807242F - &unk_807242C;
  if ( (unsigned int)(&unk_807242F - &unk_807242C) > 6 )
    result = 0;
  return result;
}
// 804A294: could not find valid save-restore pair for ebp

//----- (0804A302) --------------------------------------------------------
int sub_804A302()
{
  return nullsub_3();
}
// 804A302: could not find valid save-restore pair for ebp
// 804A301: using guessed type int nullsub_3(void);

//----- (0804A3A2) --------------------------------------------------------
void sub_804A3A2()
{
  ;
}

//----- (0804A3BD) --------------------------------------------------------
void sub_804A3BD()
{
  ;
}

//----- (0804A3CD) --------------------------------------------------------
int sub_804A3CD()
{
  int result; // eax

  result = &unk_807242F - &unk_807242C;
  if ( (unsigned int)(&unk_807242F - &unk_807242C) > 6 )
    result = 0;
  return result;
}
// 804A3CD: could not find valid save-restore pair for ebp

//----- (0804A4CB) --------------------------------------------------------
void sub_804A4CB()
{
  ;
}

//----- (0804A4E6) --------------------------------------------------------
void sub_804A4E6()
{
  ;
}

//----- (0804A4F6) --------------------------------------------------------
int sub_804A4F6()
{
  int result; // eax

  result = &unk_806D3AB - &unk_806D3A8;
  if ( (unsigned int)(&unk_806D3AB - &unk_806D3A8) > 6 )
    result = 0;
  return result;
}
// 804A4F6: could not find valid save-restore pair for ebp

//----- (0804A5ED) --------------------------------------------------------
void sub_804A5ED()
{
  ;
}

//----- (0804A608) --------------------------------------------------------
void sub_804A608()
{
  ;
}

//----- (0804A618) --------------------------------------------------------
int sub_804A618()
{
  int result; // eax

  result = (char *)&off_806B314[34] + 3 - (char *)&off_806B314[34];
  if ( (unsigned int)((char *)&off_806B314[34] + 3 - (char *)&off_806B314[34]) > 6 )
    result = 0;
  return result;
}
// 804A618: could not find valid save-restore pair for ebp
// 806B314: using guessed type void *off_806B314[54];

//----- (0804A741) --------------------------------------------------------
void sub_804A741()
{
  ;
}

//----- (0804A760) --------------------------------------------------------
void sub_804A760()
{
  ;
}

//----- (0804A770) --------------------------------------------------------
int sub_804A770()
{
  int result; // eax

  result = &unk_8072437 - &unk_8072434;
  if ( (unsigned int)(&unk_8072437 - &unk_8072434) > 6 )
    result = 0;
  return result;
}

//----- (0804A836) --------------------------------------------------------
int __usercall sub_804A836@<eax>(void (__fastcall *a1)(int, int, signed int)@<eax>, int a2@<edx>, int a3@<ecx>)
{
  a1(a3, a2, 134657444);
  return 0;
}

//----- (0804A8A2) --------------------------------------------------------
void sub_804A8A2()
{
  ;
}

//----- (0804A8C1) --------------------------------------------------------
void sub_804A8C1()
{
  ;
}

//----- (0804A8D5) --------------------------------------------------------
int sub_804A8D5()
{
  int result; // eax

  result = &unk_807243B - &unk_8072438;
  if ( (unsigned int)(&unk_807243B - &unk_8072438) > 6 )
    result = 0;
  return result;
}
// 804A8D5: could not find valid save-restore pair for ebp

//----- (0804A989) --------------------------------------------------------
int __cdecl sub_804A989(int a1)
{
  int result; // eax

  if ( a1 != 1 )
  {
    result = a1;
    status = a1;
  }
  return result;
}

//----- (0804A9A0) --------------------------------------------------------
int __cdecl sub_804A9A0(unsigned __int8 a1)
{
  return a1;
}

//----- (0804A9B2) --------------------------------------------------------
#error "804AA17: call analysis failed (funcsize=40)"

//----- (0804AA27) --------------------------------------------------------
int sub_804AA27()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nMandatory arguments to long options are mandatory for short options too.\n");
  return fputs_unlocked(v1, v0);
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804AA56) --------------------------------------------------------
int sub_804AA56()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext(
         "\n"
         "The SIZE argument is an integer and optional unit (example: 10K is 10*1024).\n"
         "Units are K,M,G,T,P,E,Z,Y (powers of 1024) or KB,MB,... (powers of 1000).\n");
  return fputs_unlocked(v1, v0);
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804AA9F) --------------------------------------------------------
#error "804AB2D: call analysis failed (funcsize=31)"

//----- (0804AB32) --------------------------------------------------------
#error "804AB52: call analysis failed (funcsize=12)"

//----- (0804AB57) --------------------------------------------------------
#error "804ACA1: positive sp value has been found (funcsize=87)"

//----- (0804ACA4) --------------------------------------------------------
int __cdecl sub_804ACA4(int a1, int a2)
{
  return sub_805AF7B(a1, a2);
}

//----- (0804ACD3) --------------------------------------------------------
int __cdecl sub_804ACD3(int a1)
{
  return a1;
}

//----- (0804ACDB) --------------------------------------------------------
bool __cdecl sub_804ACDB(int a1)
{
  return a1 == 95;
}

//----- (0804AD11) --------------------------------------------------------
int sub_804AD11()
{
  return 0;
}

//----- (0804AD3D) --------------------------------------------------------
#error "804AD77: call analysis failed (funcsize=21)"

//----- (0804AD7C) --------------------------------------------------------
#error "804AE3C: positive sp value has been found (funcsize=57)"

//----- (0804AE3D) --------------------------------------------------------
_DWORD *__stdcall sub_804AE3D(_DWORD *a1)
{
  int v1; // eax

  if ( (unsigned int)(*((_DWORD *)&unk_80729CF + 3) - *((_DWORD *)&unk_80729CF + 2)) < 0x10 )
    __assert_fail("dev_ino_size <= obstack_object_size (&dev_ino_obstack)", "src/ls.c", 0x402u, "dev_ino_pop");
  v1 = dword_80729DB;
  dword_80729DB -= 16;
  *a1 = *(_DWORD *)(v1 - 16);
  a1[1] = *(_DWORD *)(v1 - 16 + 4);
  a1[2] = *(_DWORD *)(v1 - 16 + 8);
  a1[3] = *(_DWORD *)(v1 - 16 + 12);
  return a1;
}
// 80729DB: using guessed type int dword_80729DB;

//----- (0804AF10) --------------------------------------------------------
unsigned int __cdecl sub_804AF10(int a1, int a2)
{
  unsigned int result; // eax
  int v3; // [esp+4h] [ebp-34h]
  unsigned int i; // [esp+18h] [ebp-20h]
  int v5; // [esp+1Ch] [ebp-1Ch]
  unsigned int v6; // [esp+20h] [ebp-18h]
  int v7; // [esp+24h] [ebp-14h]
  int v8; // [esp+28h] [ebp-10h]
  int v9; // [esp+2Ch] [ebp-Ch]

  v5 = a2;
  result = (unsigned int)(*(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 8)) >> 2;
  v6 = result;
  if ( result )
  {
    v7 = a2;
    v8 = *(_DWORD *)(a2 + 8);
    if ( *(_DWORD *)(a2 + 12) == v8 )
      *(_BYTE *)(v7 + 40) |= 2u;
    *(_DWORD *)(v7 + 12) = (*(_DWORD *)(v7 + 24) + *(_DWORD *)(v7 + 12)) & ~*(_DWORD *)(v7 + 24);
    if ( *(_DWORD *)(v7 + 12) - *(_DWORD *)(v7 + 4) > (unsigned int)(*(_DWORD *)(v7 + 16) - *(_DWORD *)(v7 + 4)) )
      *(_DWORD *)(v7 + 12) = *(_DWORD *)(v7 + 16);
    *(_DWORD *)(v7 + 8) = *(_DWORD *)(v7 + 12);
    v9 = v8;
    fputs_unlocked(a1, stdout);
    for ( i = 0; i < v6; ++i )
    {
      v3 = *(_DWORD *)(4 * i + v9);
      printf(" %lu", v3);
    }
    result = putchar_unlocked(10);
  }
  return result;
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804B07B) --------------------------------------------------------
_BYTE *__cdecl sub_804B07B(_BYTE *a1)
{
  int v1; // eax

  while ( *a1 )
  {
    if ( *a1 == 37 )
    {
      v1 = (char)a1[1];
      if ( v1 == 37 )
      {
        ++a1;
      }
      else if ( v1 == 98 )
      {
        return a1;
      }
    }
    ++a1;
  }
  return 0;
}

//----- (0804B0D0) --------------------------------------------------------
void sub_804B0D0()
{
  char v0; // bl
  bool v1; // al
  signed int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; i <= 255; ++i )
  {
    v0 = *(_BYTE *)(i + 134687247);
    v1 = (unsigned __int8)sub_8055D17(i) || i == 126 || i == 45 || i == 46 || i == 95;
    *(_BYTE *)(i + 134687247) = v0 | v1;
  }
}

//----- (0804B142) --------------------------------------------------------
signed int sub_804B142()
{
  char *v0; // eax
  bool v1; // zf
  int v2; // edx
  int v3; // ecx
  void *v4; // eax
  int v6; // [esp+0h] [ebp-48h]
  int v7; // [esp+4h] [ebp-44h]

  v0 = nl_langinfo(131086);
  v1 = strchr(v0, 37) == 0;
  v4 = &loc_804B1B5;
  if ( v1 )
    v4 = &loc_804B1BF;
  dword_80721FC = (int)v4;
  sub_8065D3B(v3, v2, v6, v7);
  return 0;
}
// 80721FC: using guessed type int dword_80721FC;

//----- (0804B259) --------------------------------------------------------
char *sub_804B259()
{
  char *result; // eax
  char *v1; // [esp+0h] [ebp-658h]
  char *v2; // [esp+Ch] [ebp-64Ch]
  char *v3; // [esp+10h] [ebp-648h]
  char *v4; // [esp+14h] [ebp-644h]
  int v5; // [esp+18h] [ebp-640h]
  int i; // [esp+2Ch] [ebp-62Ch]
  int j; // [esp+30h] [ebp-628h]
  int k; // [esp+34h] [ebp-624h]
  char *v9; // [esp+38h] [ebp-620h]
  char *v10; // [esp+3Ch] [ebp-61Ch]
  char *s; // [esp+40h] [ebp-618h]
  char *v12; // [esp+44h] [ebp-614h]
  int v13; // [esp+48h] [ebp-610h]
  char *v14; // [esp+4Ch] [ebp-60Ch]
  char v15[1544]; // [esp+50h] [ebp-608h]

  for ( i = 0; i <= 1; ++i )
    *(&v13 + i) = (int)sub_804B07B((&off_807238C)[i]);
  if ( v13 || (result = v14) != 0 )
  {
    v1 = v15;
    result = (char *)(sub_804B142() ^ 1);
    if ( !(_BYTE)result )
    {
      for ( j = 0; j <= 1; ++j )
      {
        result = (&off_807238C)[j];
        v10 = (&off_807238C)[j];
        for ( k = 0; k <= 11; ++k )
        {
          s = (char *)(((k + 12 * j) << 7) + 134687503);
          if ( *(&v13 + j) )
          {
            result = (char *)(*(&v13 + j) - (_DWORD)v10);
            if ( (signed int)result > 128 )
              return result;
            v12 = (char *)(*(&v13 + j) - (_DWORD)v10);
            v5 = *(&v13 + j) + 2;
            v4 = &v15[128 * k];
            v3 = v10;
            v2 = v12;
            result = (char *)snprintf(s, 0x80u, "%.*s%s%s", v12, v10, v4, v5);
            v9 = result;
          }
          else
          {
            v2 = v10;
            result = (char *)snprintf(s, 0x80u, "%s", v10);
            v9 = result;
          }
          if ( (signed int)v9 < 0 || (signed int)v9 > 127 )
            return result;
        }
      }
      byte_807370F = 1;
    }
  }
  return result;
}
// 807370F: using guessed type char byte_807370F;
// 804B259: using guessed type char var_608[1544];

//----- (0804B4B9) --------------------------------------------------------
int sub_804B4B9()
{
  __int64 v1; // [esp+0h] [ebp-2Ch]
  __int64 v2; // [esp+8h] [ebp-24h]

  *((_DWORD *)&v1 - 3) = v2;
  return sub_8065666(*(_QWORD *)*((_DWORD *)&v1 - 3), HIDWORD(v2));
}

//----- (0804B510) --------------------------------------------------------
int __cdecl sub_804B510(_QWORD *a1, _QWORD *a2)
{
  return *a2 == *a1 && a2[1] == a1[1];
}

//----- (0804B5A4) --------------------------------------------------------
void __cdecl sub_804B5A4(void *ptr)
{
  free(ptr);
}

//----- (0804B5BB) --------------------------------------------------------
int __cdecl sub_804B5BB(int a1, int a2, int a3)
{
  _DWORD *v3; // ecx
  int v4; // edx
  int v5; // ecx
  int v6; // edx
  int v8; // [esp+0h] [ebp-38h]
  int v9; // [esp+4h] [ebp-34h]
  int v10; // [esp+10h] [ebp-28h]
  int v11; // [esp+14h] [ebp-24h]
  int v12; // [esp+18h] [ebp-20h]
  int v13; // [esp+1Ch] [ebp-1Ch]

  v12 = a1;
  v13 = a2;
  v10 = a3;
  *(&v8 - 9) = v11;
  *(&v8 - 4) = (int)sub_806210D(0x10u);
  v3 = (_DWORD *)*(&v8 - 4);
  v4 = *(&v8 - 9);
  *v3 = *(&v8 - 10);
  v3[1] = v4;
  v5 = *(&v8 - 4);
  v6 = *(&v8 - 7);
  *(_DWORD *)(v5 + 8) = *(&v8 - 8);
  *(_DWORD *)(v5 + 12) = v6;
  v9 = *(&v8 - 4);
  *(&v8 - 3) = sub_805910D((int)dword_80727CF, v9);
  if ( !*(&v8 - 3) )
    sub_80622AF();
  *((_BYTE *)&v8 - 17) = *(&v8 - 3) != *(&v8 - 4);
  if ( *((_BYTE *)&v8 - 17) )
    free((void *)*(&v8 - 4));
  return *((unsigned __int8 *)&v8 - 17);
}

//----- (0804B6AA) --------------------------------------------------------
void __cdecl sub_804B6AA(void *ptr)
{
  free(*(void **)ptr);
  free(*((void **)ptr + 1));
  free(ptr);
}

//----- (0804B6E4) --------------------------------------------------------
int __cdecl sub_804B6E4(int a1)
{
  bool v1; // al
  char *s1; // [esp+0h] [ebp-2Ch]
  char *s2; // [esp+4h] [ebp-28h]
  size_t n; // [esp+8h] [ebp-24h]
  int v6; // [esp+18h] [ebp-14h]

  v6 = dword_80722CC[2 * a1];
  *(&s1 - 3) = (char *)*(&::s1 + 2 * a1);
  v1 = 0;
  if ( *(&s1 - 4) && (*(&s1 - 4) != (char *)1 || **(&s1 - 3) != unk_8067319) )
  {
    if ( *(&s1 - 4) != (char *)2 || (n = 2, s2 = "00", s1 = *(&s1 - 3), strncmp(s1, "00", 2u)) )
      v1 = 1;
  }
  return v1;
}
// 80722CC: using guessed type int dword_80722CC[];

//----- (0804B7AA) --------------------------------------------------------
size_t sub_804B7AA()
{
  sub_80546B2((int)dword_80722CC);
  return sub_80546B2((int)&dword_80722D4);
}
// 80722CC: using guessed type int dword_80722CC[];
// 80722D4: using guessed type int dword_80722D4;

//----- (0804B7DA) --------------------------------------------------------
size_t sub_804B7DA()
{
  size_t result; // eax

  result = (unsigned __int8)byte_8072853;
  if ( byte_8072853 )
  {
    result = sub_804B6E4(4);
    if ( (_BYTE)result )
    {
      sub_80546B2((int)dword_80722CC);
      sub_80546B2((int)&unk_80722EC);
      result = sub_80546B2((int)&dword_80722D4);
    }
  }
  return result;
}
// 80722CC: using guessed type int dword_80722CC[];
// 80722D4: using guessed type int dword_80722D4;
// 8072853: using guessed type char byte_8072853;

//----- (0804B821) --------------------------------------------------------
int __cdecl sub_804B821(int a1)
{
  int result; // eax

  result = dword_807292F;
  if ( !dword_807292F )
  {
    result = a1;
    dword_807292F = a1;
  }
  return result;
}
// 807292F: using guessed type int dword_807292F;

//----- (0804B837) --------------------------------------------------------
int sub_804B837()
{
  int result; // eax

  result = dword_807292F;
  if ( !dword_807292F )
    result = dword_8072933++ + 1;
  return result;
}
// 807292F: using guessed type int dword_807292F;
// 8072933: using guessed type int dword_8072933;

//----- (0804B860) --------------------------------------------------------
int sub_804B860()
{
  void *v0; // eax
  int result; // eax
  int v2; // [esp+0h] [ebp-A8h]
  int v3; // [esp+4h] [ebp-A4h]
  int v4; // [esp+8h] [ebp-A0h]
  int v5; // [esp+Ch] [ebp-9Ch]
  int v6; // [esp+10h] [ebp-98h]
  int v7; // [esp+14h] [ebp-94h]
  int v8; // [esp+1Ch] [ebp-8Ch]
  sigset_t oset; // [esp+20h] [ebp-88h]

  while ( 1 )
  {
    if ( !dword_807292F )
    {
      result = dword_8072933;
      if ( !dword_8072933 )
        break;
    }
    if ( byte_8072855 )
      sub_804B7AA();
    fflush_unlocked(stdout);
    sigprocmask(0, &set, &oset);
    v8 = dword_8072933;
    v0 = &loc_804B8F1;
    if ( !dword_8072933 )
      v0 = &loc_804B90B;
    dword_8072238 = (int)v0;
    sub_8065BD3(v2, v3, v4, v5, v6, v7);
    dword_8072933 = v8 - 1;
    raise(19);
    sigprocmask(2, &oset, 0);
  }
  return result;
}
// 8065BD3: using guessed type int __stdcall sub_8065BD3(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8072238: using guessed type int dword_8072238;
// 8072855: using guessed type char byte_8072855;
// 807292F: using guessed type int dword_807292F;
// 8072933: using guessed type int dword_8072933;

//----- (0804B96D) --------------------------------------------------------
__sighandler_t __cdecl sub_804B96D(void (*a1)(int))
{
  __sighandler_t result; // eax
  void *v2; // eax
  signed int i; // [esp+10h] [ebp-A8h]
  signed int j; // [esp+10h] [ebp-A8h]
  signed int k; // [esp+10h] [ebp-A8h]
  void *v6; // [esp+14h] [ebp-A4h]
  char v7; // [esp+18h] [ebp-A0h]
  int v8; // [esp+98h] [ebp-20h]

  result = a1;
  if ( (_BYTE)a1 )
  {
    sigemptyset(&set);
    for ( i = 0; i <= 11; ++i )
    {
      sigaction(sig[i], 0, (struct sigaction *)&v6);
      if ( v6 != (void *)1 )
        sigaddset(&set, sig[i]);
    }
    result = (__sighandler_t)32;
    qmemcpy(&v7, &set, 0x80u);
    v8 = 0x10000000;
    for ( j = 0; j <= 11; ++j )
    {
      result = (__sighandler_t)sigismember(&set, sig[j]);
      if ( result )
      {
        if ( sig[j] == 20 )
          v2 = sub_804B837;
        else
          v2 = sub_804B821;
        v6 = v2;
        result = (__sighandler_t)sigaction(sig[j], (const struct sigaction *)&v6, 0);
      }
    }
  }
  else
  {
    for ( k = 0; k <= 11; ++k )
    {
      result = (__sighandler_t)sigismember(&set, sig[k]);
      if ( result )
        result = signal(sig[k], 0);
    }
  }
  return result;
}

//----- (0804BB18) --------------------------------------------------------
__sighandler_t sub_804BB18()
{
  return sub_804B96D((void (*)(int))1);
}

//----- (0804BB30) --------------------------------------------------------
__sighandler_t sub_804BB30()
{
  return sub_804B96D(0);
}

//----- (0804BB44) --------------------------------------------------------
#error "804BB82: call analysis failed (funcsize=21)"

//----- (0804BB87) --------------------------------------------------------
#error "804BB95: call analysis failed (funcsize=408)"

//----- (0804C328) --------------------------------------------------------
int __usercall sub_804C328@<eax>(double a1@<st0>, char *nptr)
{
  bool v2; // zf
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  int v7; // [esp+0h] [ebp-38h]
  int v8; // [esp+4h] [ebp-34h]
  int v9; // [esp+28h] [ebp-10h]

  v2 = sub_8062E4A(a1, nptr, 0, 0, (int)&v9, &locale) == 0;
  v5 = &loc_804C399;
  if ( v2 )
    v5 = &loc_804C3A0;
  dword_80721FC = (int)v5;
  if ( sub_8065D3B(v4, v3, v7, v8) != 1 )
    return 0;
  dword_807288B = -1;
  return 1;
}
// 80721FC: using guessed type int dword_80721FC;
// 807288B: using guessed type int dword_807288B;

//----- (0804C3D9) --------------------------------------------------------
#error "804C40E: call analysis failed (funcsize=17)"

//----- (0804C413) --------------------------------------------------------
#error "804D69C: positive sp value has been found (funcsize=870)"

//----- (0804D69F) --------------------------------------------------------
#error "804D964: call analysis failed (funcsize=310)"

//----- (0804DAF9) --------------------------------------------------------
signed int sub_804DAF9()
{
  char *s1; // [esp+18h] [ebp-10h]
  char *name; // [esp+1Ch] [ebp-Ch]

  name = getenv("TERM");
  if ( !name || !*name )
    return 0;
  for ( s1 = "# Configuration file for dircolors, a utility to help you set the";
        (unsigned int)(s1 - "# Configuration file for dircolors, a utility to help you set the") <= 0x104C;
        s1 += strlen(s1) + 1 )
  {
    if ( !strncmp(s1, "TERM ", 5u) && !fnmatch(s1 + 5, name, 0) )
      return 1;
  }
  return 0;
}

//----- (0804DBA4) --------------------------------------------------------
#error "804DBEF: call analysis failed (funcsize=56)"

//----- (0804E066) --------------------------------------------------------
#error "804E125: call analysis failed (funcsize=50)"

//----- (0804E12A) --------------------------------------------------------
#error "804E137: positive sp value has been found (funcsize=0)"

//----- (0804E138) --------------------------------------------------------
int __cdecl sub_804E138(int a1)
{
  int result; // eax

  result = a1;
  if ( (_BYTE)a1 )
  {
    dword_8072937 = 2;
  }
  else
  {
    result = dword_8072937;
    if ( !dword_8072937 )
      dword_8072937 = 1;
  }
  return result;
}
// 8072937: using guessed type int dword_8072937;

//----- (0804E16F) --------------------------------------------------------
int __cdecl sub_804E16F(int a1, char *format, int a3)
{
  int v3; // ebx
  int v4; // eax
  int v6; // [esp+4h] [ebp-24h]
  int v7; // [esp+Ch] [ebp-1Ch]
  unsigned __int8 v8; // [esp+1Ch] [ebp-Ch]

  v8 = a1;
  v6 = a3;
  v3 = sub_8060B63(4);
  v4 = *__errno_location();
  v7 = v3;
  error(0, v4, format, v3);
  return sub_804E138(v8);
}

//----- (0804E1C9) --------------------------------------------------------
_DWORD *__cdecl sub_804E1C9(char *a1, char *s, int a3)
{
  void *v3; // eax
  void *v4; // eax
  _DWORD *result; // eax
  _DWORD *v6; // [esp+1Ch] [ebp-Ch]

  v6 = sub_806210D(0x10u);
  if ( s )
    v3 = sub_8062286(s);
  else
    v3 = 0;
  v6[1] = v3;
  if ( a1 )
    v4 = sub_8062286(a1);
  else
    v4 = 0;
  *v6 = v4;
  *((_BYTE *)v6 + 8) = a3;
  v6[3] = dword_80727F3;
  result = v6;
  dword_80727F3 = (int)v6;
  return result;
}
// 80727F3: using guessed type int dword_80727F3;

//----- (0804E253) --------------------------------------------------------
unsigned int __usercall sub_804E253@<eax>(const unsigned __int16 *a1@<ebx>, long double a2@<st0>, char *a3, int a4, unsigned __int8 a5)
{
  char *v5; // eax
  unsigned int v6; // eax
  char *v7; // eax
  int v8; // ebx
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  int v12; // edx
  int v13; // ecx
  __int64 v14; // rax
  char *v15; // eax
  char *v16; // eax
  __int64 v18; // [esp+0h] [ebp-348h]
  __int64 v19; // [esp+8h] [ebp-340h]
  int v20; // [esp+10h] [ebp-338h]
  void *v21; // [esp+14h] [ebp-334h]
  void *v22; // [esp+18h] [ebp-330h]
  int v23; // [esp+1Ch] [ebp-32Ch]
  int v24; // [esp+20h] [ebp-328h]
  unsigned __int8 v25; // [esp+24h] [ebp-324h]
  char *v26; // [esp+28h] [ebp-320h]
  char *name; // [esp+2Ch] [ebp-31Ch]
  void *ptr; // [esp+30h] [ebp-318h]
  int v29; // [esp+34h] [ebp-314h]
  DIR *dirp; // [esp+38h] [ebp-310h]
  int v31; // [esp+3Ch] [ebp-30Ch]
  int v32; // [esp+40h] [ebp-308h]
  char *s; // [esp+44h] [ebp-304h]
  __int64 v34; // [esp+48h] [ebp-300h]
  int v35; // [esp+50h] [ebp-2F8h]
  int v36; // [esp+54h] [ebp-2F4h]
  int v37; // [esp+58h] [ebp-2F0h]
  int v38; // [esp+A8h] [ebp-2A0h]
  const unsigned __int16 *v39; // [esp+ACh] [ebp-29Ch]
  char v40; // [esp+B0h] [ebp-298h]
  unsigned int v41; // [esp+33Ch] [ebp-Ch]

  name = a3;
  v26 = (char *)a4;
  v25 = a5;
  v41 = __readgsdword(0x14u);
  v34 = 0LL;
  *__errno_location() = 0;
  dirp = opendir(name);
  if ( !dirp )
  {
    v5 = gettext("cannot open directory %s");
    sub_804E16F(v25, v5, (int)name);
    return __readgsdword(0x14u) ^ v41;
  }
  if ( dword_80727CF )
  {
    v31 = dirfd(dirp);
    if ( v31 < 0 )
      v6 = (unsigned int)sub_80658D5((int)name, (int)&v35) >> 31;
    else
      v6 = (unsigned int)sub_8065934(v31, (int)&v35) >> 31;
    if ( (_BYTE)v6 )
    {
      v7 = gettext("cannot determine device and inode of %s");
      sub_804E16F(v25, v7, (int)name);
      closedir(dirp);
      return __readgsdword(0x14u) ^ v41;
    }
    HIDWORD(v19) = v39;
    if ( (unsigned __int8)sub_804B5BB(v35, v36, v38) )
    {
      v8 = sub_8060D82(0, 3, (int)name);
      v9 = gettext("%s: not listing already-listed directory");
      HIDWORD(v19) = v8;
      error(0, 0, v9, v8);
      closedir(dirp);
      sub_804E138(1);
      return __readgsdword(0x14u) ^ v41;
    }
    a1 = v39;
    sub_804AD3D(v35, v36, v38, v39);
  }
  sub_804ED1C();
  if ( byte_8072867 || byte_8072887 )
  {
    if ( byte_8072394 != 1 )
    {
      putchar_unlocked(10);
      ++dword_8072943;
    }
    byte_8072394 = 0;
    if ( byte_807284B )
    {
      fwrite_unlocked("  ", 1u, 2u, stdout);
      dword_8072943 += 2;
    }
    ptr = 0;
    if ( byte_8072854 )
    {
      ptr = sub_805606B(a2, name, 2);
      if ( !ptr )
      {
        v10 = gettext("error canonicalizing %s");
        sub_804E16F(v25, v10, (int)name);
      }
    }
    if ( v26 )
      v11 = v26;
    else
      v11 = name;
    v22 = ptr;
    v21 = &unk_807298F;
    sub_8053622(a1, *(double *)&a2, (int)v11, (char *)dword_807287F, -1, 0, 1);
    free(ptr);
    fwrite_unlocked(":\n", 1u, 2u, stdout);
    dword_8072943 += 2;
  }
  *__errno_location() = 0;
  LODWORD(v18) = dirp;
  v32 = readdir64();
  if ( v32 )
  {
    LODWORD(v18) = v32 + 19;
    if ( (unsigned __int8)sub_804EAE0() ^ 1 )
    {
      v29 = 0;
      switch ( *(unsigned __int8 *)(v32 + 18) )
      {
        case 1u:
          v29 = 1;
          break;
        case 2u:
          goto LABEL_29;
        case 4u:
          v29 = 3;
          break;
        case 6u:
          dword_8072260 = (int)&loc_804E6D2;
          a2 = sub_8065ABA(
                 v13,
                 v12,
                 v18,
                 HIDWORD(v18),
                 v19,
                 HIDWORD(v19),
                 v20,
                 v21,
                 v22,
                 v23,
                 v24,
                 *(_DWORD *)&v25,
                 v26,
                 name,
                 ptr,
                 4,
                 dirp,
                 v31,
                 v32,
                 s,
                 v34);
LABEL_29:
          v29 = 2;
          break;
        case 8u:
          v29 = 5;
          break;
        case 0xAu:
          v29 = 6;
          break;
        case 0xCu:
          v29 = 7;
          break;
        case 0xEu:
          v29 = 8;
          break;
        default:
          break;
      }
      LODWORD(v14) = sub_804F12E(v32 + 19, v29, 0LL, 0, name);
      v34 += v14;
      if ( dword_807282B == 1 && dword_8072833 == -1 && byte_807283A != 1 && byte_8072867 != 1 )
      {
        sub_8051968(a2);
        sub_8051ADE();
        sub_804ED1C();
        goto LABEL_46;
      }
    }
    dword_8072224 = (int)&loc_804E7DC;
    sub_8065C47(
      v18,
      HIDWORD(v18),
      v19,
      HIDWORD(v19),
      v20,
      v21,
      v22,
      v23,
      v24,
      *(_DWORD *)&v25,
      v26,
      name,
      ptr,
      v29,
      dirp,
      v31,
      v32,
      s,
      v34,
      HIDWORD(v34),
      v35,
      v36,
      v37);
  }
  if ( !*__errno_location() )
    goto LABEL_47;
  v15 = gettext("reading directory %s");
  sub_804E16F(v25, v15, (int)name);
  if ( *__errno_location() != 75 )
  {
    dword_8072210 = (int)&loc_804E7F8;
    a2 = sub_8065CCF(
           v18,
           HIDWORD(v18),
           v19,
           HIDWORD(v19),
           v20,
           v21,
           v22,
           v23,
           v24,
           *(_DWORD *)&v25,
           v26,
           name,
           ptr,
           v29,
           dirp,
           v31,
           v32,
           s,
           v34,
           *(double *)&a2);
    goto LABEL_47;
  }
LABEL_46:
  sub_804B860();
  dword_8072224 = (int)&loc_804E5F2;
  sub_8065C47(
    v18,
    HIDWORD(v18),
    v19,
    HIDWORD(v19),
    v20,
    v21,
    v22,
    v23,
    v24,
    *(_DWORD *)&v25,
    v26,
    name,
    ptr,
    v29,
    dirp,
    v31,
    v32,
    s,
    v34,
    HIDWORD(v34),
    v35,
    v36,
    v37);
LABEL_47:
  if ( closedir(dirp) )
  {
    v16 = gettext("closing directory %s");
    sub_804E16F(v25, v16, (int)name);
  }
  sub_8051968(a2);
  if ( byte_8072867 )
    sub_805032D(name, 0);
  if ( !dword_807282B || byte_807283A )
  {
    if ( byte_807284B )
    {
      fwrite_unlocked("  ", 1u, 2u, stdout);
      dword_8072943 += 2;
    }
    s = gettext("total");
    fputs_unlocked(s, stdout);
    dword_8072943 += strlen(s);
    putchar_unlocked(32);
    ++dword_8072943;
    s = (char *)sub_8059958(v34, SHIDWORD(v34), &v40, dword_807283B, 512, 0, dword_807283F, dword_8072843);
    fputs_unlocked(s, stdout);
    dword_8072943 += strlen(s);
    putchar_unlocked(10);
    ++dword_8072943;
  }
  if ( dword_80727DB )
    sub_8051ADE();
  return __readgsdword(0x14u) ^ v41;
}
// 804E7D1: inconsistent fpu stack
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8049A80: using guessed type int readdir64(void);
// 804AD3D: using guessed type _DWORD __cdecl sub_804AD3D(_DWORD, _DWORD, _DWORD, _DWORD);
// 804EAE0: using guessed type int sub_804EAE0(void);
// 804F12E: using guessed type _DWORD __cdecl sub_804F12E(_DWORD, _DWORD, __int64, _DWORD, _DWORD);
// 8051ADE: using guessed type int sub_8051ADE(void);
// 8065ABA: using guessed type double __fastcall sub_8065ABA(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8065C47: using guessed type int __stdcall sub_8065C47(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8065CCF: using guessed type double __userpurge sub_8065CCF@<st0>(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, double@<st0>);
// 8072210: using guessed type int dword_8072210;
// 8072224: using guessed type int dword_8072224;
// 8072260: using guessed type int dword_8072260;
// 8072394: using guessed type char byte_8072394;
// 80727DB: using guessed type int dword_80727DB;
// 807282B: using guessed type int dword_807282B;
// 8072833: using guessed type int dword_8072833;
// 807283A: using guessed type char byte_807283A;
// 807284B: using guessed type char byte_807284B;
// 8072854: using guessed type char byte_8072854;
// 8072867: using guessed type char byte_8072867;
// 807287F: using guessed type int dword_807287F;
// 8072887: using guessed type char byte_8072887;
// 8072943: using guessed type int dword_8072943;

//----- (0804EA25) --------------------------------------------------------
_DWORD *__cdecl sub_804EA25(int a1)
{
  _DWORD *v1; // ST1C_4
  _DWORD *result; // eax

  v1 = sub_806210D(8u);
  *v1 = a1;
  v1[1] = dword_807286F;
  result = v1;
  dword_807286F = (int)v1;
  return result;
}

//----- (0804EA7C) --------------------------------------------------------
int __cdecl sub_804EA7C(int a1, char *name)
{
  bool v2; // zf
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  int v7; // [esp+0h] [ebp-28h]
  int v8; // [esp+4h] [ebp-24h]

  if ( !a1 )
    return 0;
  v2 = fnmatch(*(const char **)a1, name, 4) == 0;
  v5 = &loc_804EAC3;
  if ( !v2 )
    v5 = &loc_804EACA;
  dword_80721FC = (int)v5;
  sub_8065D3B(v4, v3, v7, v8);
  return 1;
}
// 80721FC: using guessed type int dword_80721FC;

//----- (0804EAE0) --------------------------------------------------------
#error "804EB12: call analysis failed (funcsize=21)"

//----- (0804EB25) --------------------------------------------------------
#error "804EBAD: call analysis failed (funcsize=69)"

//----- (0804EBF4) --------------------------------------------------------
int __cdecl sub_804EBF4(int a1)
{
  return a1;
}

//----- (0804EC1E) --------------------------------------------------------
int sub_804EC1E()
{
  *__errno_location() = 95;
  return 0;
}

//----- (0804EC6C) --------------------------------------------------------
#error "804ECCC: call analysis failed (funcsize=56)"

//----- (0804ED1C) --------------------------------------------------------
int sub_804ED1C()
{
  int result; // eax
  unsigned int i; // [esp+18h] [ebp-10h]

  for ( i = 0; ; ++i )
  {
    result = dword_80727DB;
    if ( i >= dword_80727DB )
      break;
    sub_804EC6C(*((_DWORD *)ptr + i));
  }
  dword_80727DB = 0;
  byte_80727DF = 0;
  byte_8072800 = 0;
  dword_8072803 = 0;
  dword_8072807 = 0;
  dword_807280B = 0;
  dword_8072813 = 0;
  dword_8072817 = 0;
  dword_807281B = 0;
  dword_807280F = 0;
  dword_807281F = 0;
  dword_8072823 = 0;
  dword_8072827 = 0;
  return result;
}
// 804EC6C: using guessed type _DWORD __cdecl sub_804EC6C(_DWORD);
// 80727DB: using guessed type int dword_80727DB;
// 80727DF: using guessed type char byte_80727DF;
// 8072800: using guessed type char byte_8072800;
// 8072803: using guessed type int dword_8072803;
// 8072807: using guessed type int dword_8072807;
// 807280B: using guessed type int dword_807280B;
// 807281F: using guessed type int dword_807281F;
// 8072823: using guessed type int dword_8072823;
// 8072827: using guessed type int dword_8072827;

//----- (0804EDF8) --------------------------------------------------------
int __cdecl sub_804EDF8(int a1)
{
  return a1 == 22 || a1 == 38 || sub_804ACDB(a1);
}

//----- (0804EE2E) --------------------------------------------------------
signed int sub_804EE2E()
{
  signed int result; // eax
  signed int v1; // eax
  int v2; // [esp+0h] [ebp-2Ch]
  int v3; // [esp+4h] [ebp-28h]
  int v4; // [esp+8h] [ebp-24h]
  int v5; // [esp+Ch] [ebp-20h]
  char v6; // [esp+10h] [ebp-1Ch]

  *((_BYTE *)&v2 - 28) = v6;
  if ( *(_QWORD *)(v5 + 12) == qword_80737CF )
  {
    *__errno_location() = 95;
    result = -1;
  }
  else
  {
    *(&v2 - 3) = 0;
    if ( *((_BYTE *)&v2 - 28) )
    {
      v3 = v5 + 116;
      v2 = v4;
      v1 = sub_8061375();
    }
    else
    {
      v3 = v5 + 116;
      v2 = v4;
      v1 = sub_8061391();
    }
    *(&v2 - 3) = v1;
    if ( *(&v2 - 3) < 0 )
    {
      v2 = *__errno_location();
      if ( (unsigned __int8)sub_804EDF8(v2) )
        qword_80737CF = *(_QWORD *)(v5 + 12);
    }
    result = *(&v2 - 3);
  }
  return result;
}
// 80737CF: using guessed type __int64 qword_80737CF;

//----- (0804EF05) --------------------------------------------------------
#error "804EF61: call analysis failed (funcsize=39)"

//----- (0804EFF4) --------------------------------------------------------
int __cdecl sub_804EFF4(int a1, int a2)
{
  int result; // eax
  int *v3; // eax
  int v4; // edx
  unsigned __int8 v5; // [esp+1Fh] [ebp-9h]

  if ( *(_QWORD *)(a2 + 12) == qword_80737DF )
  {
    *__errno_location() = 95;
    result = 0;
  }
  else
  {
    v5 = sub_804EC1E();
    if ( v5 ^ 1 )
    {
      v3 = __errno_location();
      if ( (unsigned __int8)sub_804EDF8(*v3) )
      {
        v4 = *(_DWORD *)(a2 + 16);
        LODWORD(qword_80737DF) = *(_DWORD *)(a2 + 12);
        HIDWORD(qword_80737DF) = v4;
      }
    }
    result = v5;
  }
  return result;
}
// 80737D7: using guessed type __int64 qword_80737D7;
// 80737DF: using guessed type __int64 qword_80737DF;

//----- (0804F0AB) --------------------------------------------------------
_BOOL4 __usercall sub_804F0AB@<eax>(int a1@<edx>, int a2@<ecx>, char *s)
{
  size_t v3; // eax
  bool v4; // al
  int v6; // [esp+0h] [ebp-38h]
  char v7; // [esp+2Ah] [ebp-Eh]
  int v8; // [esp+2Ch] [ebp-Ch]

  v8 = sub_80603D4(a1, a2, (int)&v6 - 14, 2, (int)s, -1, (_DWORD *)dword_807287B);
  v4 = 1;
  if ( *s == v7 )
  {
    v3 = strlen(s);
    if ( v3 == v8 )
      v4 = 0;
  }
  return v4;
}
// 807287B: using guessed type int dword_807287B;

//----- (0804F12E) --------------------------------------------------------
#error "804F2BE: call analysis failed (funcsize=90)"

//----- (0804F2C3) --------------------------------------------------------
#error "804F2FF: call analysis failed (funcsize=359)"

//----- (08050148) --------------------------------------------------------
int __cdecl sub_8050148(int a1)
{
  return *(_DWORD *)(a1 + 108) == 3 || *(_DWORD *)(a1 + 108) == 9;
}

//----- (08050176) --------------------------------------------------------
int __cdecl sub_8050176(char *path, int a2, int a3)
{
  int v3; // edx
  int result; // eax
  char *v5; // eax

  v3 = *(_DWORD *)(a2 + 60);
  *(_DWORD *)(a2 + 4) = sub_80557E2(path, *(_DWORD *)(a2 + 56));
  result = *(_DWORD *)(a2 + 4);
  if ( !result )
  {
    v5 = gettext("cannot read symbolic link %s");
    result = sub_804E16F((unsigned __int8)a3, v5, (int)path);
  }
  return result;
}

//----- (080501E3) --------------------------------------------------------
#error "805022E: call analysis failed (funcsize=79)"

//----- (080502EA) --------------------------------------------------------
int __cdecl sub_80502EA(int a1)
{
  int v1; // ST1C_4

  v1 = sub_8056C5F(a1);
  return sub_804A9B2(v1);
}
// 804A9B2: using guessed type _DWORD __cdecl sub_804A9B2(_DWORD);
// 8056C5F: using guessed type int __cdecl sub_8056C5F(_DWORD);

//----- (0805032D) --------------------------------------------------------
#error "805044E: call analysis failed (funcsize=167)"

//----- (0805056C) --------------------------------------------------------
int __cdecl sub_805056C(char *s1, char *s2)
{
  int v2; // edi
  int v3; // esi
  char *v4; // ebx
  int *v5; // eax
  int v7; // [esp+2Ch] [ebp-1Ch]

  *__errno_location() = 0;
  v7 = strcoll(s1, s2);
  if ( *__errno_location() )
  {
    v2 = sub_80610C3();
    v3 = sub_80610C3();
    v4 = gettext("cannot compare file names %s and %s");
    v5 = __errno_location();
    error(0, *v5, v4, v3, v2);
    sub_804E138(0);
    longjmp(env, 1);
  }
  return v7;
}

//----- (08050626) --------------------------------------------------------
int __cdecl sub_8050626(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD))
{
  int result; // eax
  int v4; // [esp+1Ch] [ebp-1Ch]
  int v5; // [esp+20h] [ebp-18h]
  int v6; // [esp+24h] [ebp-14h]
  int v7; // [esp+28h] [ebp-10h]
  int v8; // [esp+2Ch] [ebp-Ch]

  sub_806150A(&v5, (int)(a1 + 3));
  sub_806150A(&v7, (int)(a2 + 3));
  v4 = sub_80615F2(v7, v8, v5, v6);
  if ( v4 )
    result = v4;
  else
    result = a3(*a1, *a2);
  return result;
}

//----- (080506A6) --------------------------------------------------------
int __cdecl sub_80506A6(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD))
{
  int result; // eax
  int v4; // [esp+1Ch] [ebp-1Ch]
  int v5; // [esp+20h] [ebp-18h]
  int v6; // [esp+24h] [ebp-14h]
  int v7; // [esp+28h] [ebp-10h]
  int v8; // [esp+2Ch] [ebp-Ch]

  sub_8061547(&v5, (int)(a1 + 3));
  sub_8061547(&v7, (int)(a2 + 3));
  v4 = sub_80615F2(v7, v8, v5, v6);
  if ( v4 )
    result = v4;
  else
    result = a3(*a1, *a2);
  return result;
}

//----- (08050726) --------------------------------------------------------
int __cdecl sub_8050726(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD))
{
  int result; // eax
  int v4; // [esp+1Ch] [ebp-1Ch]
  int v5; // [esp+20h] [ebp-18h]
  int v6; // [esp+24h] [ebp-14h]
  int v7; // [esp+28h] [ebp-10h]
  int v8; // [esp+2Ch] [ebp-Ch]

  sub_80614CF(&v5, (int)(a1 + 3));
  sub_80614CF(&v7, (int)(a2 + 3));
  v4 = sub_80615F2(v7, v8, v5, v6);
  if ( v4 )
    result = v4;
  else
    result = a3(*a1, *a2);
  return result;
}

//----- (080507B4) --------------------------------------------------------
int __cdecl sub_80507B4(_DWORD *a1, int *a2, int (__fastcall *a3)(_DWORD))
{
  __int64 v3; // rcx
  __int64 v4; // rax
  unsigned __int8 v5; // si
  signed int v6; // eax
  int v7; // eax
  int v9; // [esp-1Ch] [ebp-28h]
  int v10; // [esp-18h] [ebp-24h]
  int v11; // [esp+0h] [ebp-Ch]

  v3 = *((_QWORD *)a2 + 7);
  if ( v3 < *((_QWORD *)a1 + 7) )
  {
    v6 = -1;
  }
  else
  {
    LODWORD(v3) = a2[14];
    v5 = 1;
    LODWORD(v4) = a1[14];
    HIDWORD(v3) = a2[15];
    HIDWORD(v4) = a1[15];
    if ( v3 <= v4 )
      v5 = 0;
    v6 = v5;
  }
  v11 = v6;
  if ( v6 )
    return v11;
  v7 = *a1;
  v10 = *a2;
  v9 = v7;
  return a3(v3);
}

//----- (0805085D) --------------------------------------------------------
int __cdecl sub_805085D(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD))
{
  return a3(*a1, *a2);
}

//----- (0805088F) --------------------------------------------------------
int __cdecl sub_805088F(const char **a1, const char **a2, int (__cdecl *a3)(char *, char *))
{
  char *v3; // edx
  char *v4; // eax
  int result; // eax
  char *v6; // [esp+14h] [ebp-14h]
  char *v7; // [esp+18h] [ebp-10h]
  int v8; // [esp+1Ch] [ebp-Ch]

  v6 = strrchr(*a1, 46);
  v7 = strrchr(*a2, 46);
  if ( v7 )
    v3 = v7;
  else
    v3 = &locale;
  if ( v6 )
    v4 = v6;
  else
    v4 = &locale;
  v8 = a3(v4, v3);
  if ( v8 )
    result = v8;
  else
    result = a3((char *)*a1, (char *)*a2);
  return result;
}

//----- (0805106B) --------------------------------------------------------
int __cdecl sub_805106B(_DWORD *a1, int *a2)
{
  return sub_80507B4(a1, a2, (int (__fastcall *)(_DWORD))sub_805056C);
}

//----- (0805108D) --------------------------------------------------------
int __cdecl sub_805108D(_DWORD *a1, int *a2)
{
  return sub_80507B4(a1, a2, (int (__fastcall *)(_DWORD))strcmp);
}

//----- (080510AF) --------------------------------------------------------
int __cdecl sub_80510AF(int *a1, _DWORD *a2)
{
  return sub_80507B4(a2, a1, (int (__fastcall *)(_DWORD))sub_805056C);
}

//----- (080510D1) --------------------------------------------------------
int __cdecl sub_80510D1(int *a1, _DWORD *a2)
{
  return sub_80507B4(a2, a1, (int (__fastcall *)(_DWORD))strcmp);
}

//----- (080510F3) --------------------------------------------------------
int __cdecl sub_80510F3(_DWORD *a1, int *a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_8050148((int)a1);
  v4 = sub_8050148((int)a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_80507B4(a1, a2, (int (__fastcall *)(_DWORD))sub_805056C);
}

//----- (08051161) --------------------------------------------------------
int __cdecl sub_8051161(_DWORD *a1, int *a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_8050148((int)a1);
  v4 = sub_8050148((int)a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_80507B4(a1, a2, (int (__fastcall *)(_DWORD))strcmp);
}

//----- (080511CF) --------------------------------------------------------
#error "8051238: call analysis failed (funcsize=48)"

//----- (0805127F) --------------------------------------------------------
#error "80512C5: call analysis failed (funcsize=40)"

//----- (08051302) --------------------------------------------------------
int __cdecl sub_8051302(_DWORD *a1, _DWORD *a2)
{
  return sub_805085D(a1, a2, (int (__cdecl *)(_DWORD, _DWORD))sub_805056C);
}

//----- (08051324) --------------------------------------------------------
int __cdecl sub_8051324(_DWORD *a1, _DWORD *a2)
{
  return sub_805085D(a1, a2, (int (__cdecl *)(_DWORD, _DWORD))strcmp);
}

//----- (08051346) --------------------------------------------------------
int __cdecl sub_8051346(_DWORD *a1, _DWORD *a2)
{
  return sub_805085D(a2, a1, (int (__cdecl *)(_DWORD, _DWORD))sub_805056C);
}

//----- (08051368) --------------------------------------------------------
int __cdecl sub_8051368(_DWORD *a1, _DWORD *a2)
{
  return sub_805085D(a2, a1, (int (__cdecl *)(_DWORD, _DWORD))strcmp);
}

//----- (0805138A) --------------------------------------------------------
int __cdecl sub_805138A(_DWORD *a1, _DWORD *a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_8050148((int)a1);
  v4 = sub_8050148((int)a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_805085D(a1, a2, (int (__cdecl *)(_DWORD, _DWORD))sub_805056C);
}

//----- (080513F8) --------------------------------------------------------
int __cdecl sub_80513F8(_DWORD *a1, _DWORD *a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_8050148((int)a1);
  v4 = sub_8050148((int)a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_805085D(a1, a2, (int (__cdecl *)(_DWORD, _DWORD))strcmp);
}

//----- (08051466) --------------------------------------------------------
int __cdecl sub_8051466(_DWORD *a1, _DWORD *a2)
{
  int v3; // [esp+0h] [ebp-28h]
  int v4; // [esp+4h] [ebp-24h]
  int v5; // [esp+8h] [ebp-20h]
  int v6; // [esp+Ch] [ebp-1Ch]
  int v7; // [esp+10h] [ebp-18h]
  int v8; // [esp+14h] [ebp-14h]
  char v9; // [esp+1Eh] [ebp-Ah]
  char v10; // [esp+1Fh] [ebp-9h]

  v9 = sub_8050148((int)a1);
  v10 = sub_8050148((int)a2);
  if ( v9 && v10 != 1 )
    return -1;
  if ( v9 != 1 )
  {
    if ( v10 )
    {
      dword_8072238 = (int)&locret_80514E7;
      sub_8065BD3(v3, v4, v5, v6, v7, v8);
    }
  }
  return sub_805085D(a2, a1, (int (__cdecl *)(_DWORD, _DWORD))sub_805056C);
}
// 8065BD3: using guessed type int __stdcall sub_8065BD3(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8072238: using guessed type int dword_8072238;

//----- (080514E9) --------------------------------------------------------
int __cdecl sub_80514E9(_DWORD *a1, _DWORD *a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_8050148((int)a1);
  v4 = sub_8050148((int)a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_805085D(a2, a1, (int (__cdecl *)(_DWORD, _DWORD))strcmp);
}

//----- (08051557) --------------------------------------------------------
int __cdecl sub_8051557(const char **a1, const char **a2)
{
  return sub_805088F(a1, a2, sub_805056C);
}

//----- (08051579) --------------------------------------------------------
int __cdecl sub_8051579(const char **a1, const char **a2)
{
  return sub_805088F(a1, a2, (int (__cdecl *)(char *, char *))strcmp);
}

//----- (0805159B) --------------------------------------------------------
int __cdecl sub_805159B(const char **a1, const char **a2)
{
  return sub_805088F(a2, a1, sub_805056C);
}

//----- (080515BD) --------------------------------------------------------
int __cdecl sub_80515BD(const char **a1, const char **a2)
{
  return sub_805088F(a2, a1, (int (__cdecl *)(char *, char *))strcmp);
}

//----- (080515DF) --------------------------------------------------------
int __cdecl sub_80515DF(const char **a1, const char **a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_8050148((int)a1);
  v4 = sub_8050148((int)a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_805088F(a1, a2, sub_805056C);
}

//----- (0805164D) --------------------------------------------------------
int __cdecl sub_805164D(const char **a1, const char **a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_8050148((int)a1);
  v4 = sub_8050148((int)a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_805088F(a1, a2, (int (__cdecl *)(char *, char *))strcmp);
}

//----- (080516BB) --------------------------------------------------------
int __cdecl sub_80516BB(const char **a1, const char **a2)
{
  int v2; // ecx
  void *v4; // eax
  char v5; // [esp+1Eh] [ebp-Ah]
  char v6; // [esp+1Fh] [ebp-9h]

  v5 = sub_8050148((int)a1);
  v6 = sub_8050148((int)a2);
  if ( v5 && v6 != 1 )
    return -1;
  if ( v5 == 1 )
    return sub_805088F(a2, a1, sub_805056C);
  v4 = &loc_805171F;
  if ( !v6 )
    v4 = &loc_8051726;
  dword_80721DC = (int)v4;
  sub_8065E0F(v2);
  return 1;
}
// 8065E0F: using guessed type int __fastcall sub_8065E0F(_DWORD);
// 80721DC: using guessed type int dword_80721DC;

//----- (08051742) --------------------------------------------------------
int __cdecl sub_8051742(const char **a1, const char **a2)
{
  int v2; // edx
  int v3; // ecx
  int result; // eax
  int v5; // [esp+0h] [ebp-28h]
  int v6; // [esp+4h] [ebp-24h]
  char v7; // [esp+1Eh] [ebp-Ah]
  char v8; // [esp+1Fh] [ebp-9h]

  v7 = sub_8050148((int)a1);
  v8 = sub_8050148((int)a2);
  if ( v7 && v8 != 1 )
  {
    dword_80721FC = (int)&locret_80517C3;
    sub_8065D3B(v3, v2, v5, v6);
  }
  if ( v7 != 1 && v8 )
    result = 1;
  else
    result = sub_805088F(a2, a1, (int (__cdecl *)(char *, char *))strcmp);
  return result;
}
// 80721FC: using guessed type int dword_80721FC;

//----- (080517C5) --------------------------------------------------------
int __cdecl sub_80517C5(char **a1, char **a2)
{
  return sub_805770A(*a1, *a2);
}

//----- (080517E3) --------------------------------------------------------
int __cdecl sub_80517E3(char **a1, char **a2)
{
  return sub_80517C5(a1, a2);
}

//----- (080517FD) --------------------------------------------------------
int __cdecl sub_80517FD(char **a1, char **a2)
{
  return sub_80517C5(a2, a1);
}

//----- (08051817) --------------------------------------------------------
int __cdecl sub_8051817(char **a1, char **a2)
{
  int v3; // [esp+0h] [ebp-28h]
  int v4; // [esp+4h] [ebp-24h]
  int v5; // [esp+8h] [ebp-20h]
  int v6; // [esp+Ch] [ebp-1Ch]
  int v7; // [esp+10h] [ebp-18h]
  int v8; // [esp+14h] [ebp-14h]
  char v9; // [esp+1Eh] [ebp-Ah]
  char v10; // [esp+1Fh] [ebp-9h]

  v9 = sub_8050148((int)a1);
  v10 = sub_8050148((int)a2);
  if ( v9 && v10 != 1 )
    return -1;
  if ( v9 != 1 )
  {
    if ( v10 )
    {
      dword_8072238 = (int)&locret_8051894;
      sub_8065BD3(v3, v4, v5, v6, v7, v8);
    }
  }
  return sub_80517C5(a1, a2);
}
// 8065BD3: using guessed type int __stdcall sub_8065BD3(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8072238: using guessed type int dword_8072238;

//----- (08051896) --------------------------------------------------------
int __cdecl sub_8051896(char **a1, char **a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_8050148((int)a1);
  v4 = sub_8050148((int)a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_80517C5(a2, a1);
}

//----- (080518FC) --------------------------------------------------------
int sub_80518FC()
{
  int result; // eax
  unsigned int i; // [esp+Ch] [ebp-8h]

  for ( i = 0; ; ++i )
  {
    result = dword_80727DB;
    if ( i >= dword_80727DB )
      break;
    *((_DWORD *)ptr + i) = (char *)dword_80727D3 + 136 * i;
  }
  return result;
}
// 80727DB: using guessed type int dword_80727DB;

//----- (08051968) --------------------------------------------------------
void __usercall sub_8051968(long double a1@<st0>)
{
  int v1; // eax
  int v2; // [esp+0h] [ebp-28h]
  int (__cdecl *v3)(int, int); // [esp+8h] [ebp-20h]

  if ( dword_80727DB + ((unsigned int)dword_80727DB >> 1) > dword_80727E7 )
  {
    free(ptr);
    ptr = sub_8061FAD(dword_80727DB, 0xCu);
    dword_80727E7 = 3 * dword_80727DB;
  }
  sub_80518FC();
  if ( dword_8072833 != -1 )
  {
    if ( _setjmp(env) )
    {
      *((_BYTE *)&v2 - 9) = 1;
      if ( dword_8072833 == 3 )
        __assert_fail("sort_type != sort_version", "src/ls.c", 0xEE5u, "sort_files");
      sub_80518FC();
    }
    else
    {
      *((_BYTE *)&v2 - 9) = 0;
    }
    if ( dword_8072833 == 4 )
      v1 = dword_807282F;
    else
      v1 = 0;
    v3 = off_80686B0[2
                   * (2 * (2 * (v1 + dword_8072833) + *((unsigned __int8 *)&v2 - 9)) + (unsigned __int8)byte_8072837)
                   + (unsigned __int8)byte_8072869];
    sub_805BFE9(a1, (int)ptr, dword_80727DB);
  }
}
// 80686B0: using guessed type int (__cdecl *off_80686B0[28])(int, int);
// 80727DB: using guessed type int dword_80727DB;
// 80727E7: using guessed type int dword_80727E7;
// 807282F: using guessed type int dword_807282F;
// 8072833: using guessed type int dword_8072833;
// 8072837: using guessed type char byte_8072837;
// 8072869: using guessed type char byte_8072869;

//----- (08051ADE) --------------------------------------------------------
#error "8051BC0: call analysis failed (funcsize=97)"

//----- (08051C60) --------------------------------------------------------
int __usercall sub_8051C60@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, unsigned __int8 a5, int a6, int a7, int a8)
{
  char *v8; // eax
  unsigned __int8 v10; // [esp+1Ch] [ebp-1Ch]
  char *v11; // [esp+2Ch] [ebp-Ch]

  v10 = a5;
  if ( byte_807370F )
  {
    a1 = v10;
    a2 = *(_DWORD *)(a6 + 16);
    v8 = (char *)(((a2 + 12 * v10) << 7) + 134687503);
  }
  else
  {
    v8 = (&off_807238C)[v10];
  }
  v11 = v8;
  return sub_805C184(a2, a1, a3, a4, v8, a6, a7, a8);
}
// 805C184: using guessed type int __fastcall sub_805C184(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 807370F: using guessed type char byte_807370F;

//----- (08051D18) --------------------------------------------------------
int sub_8051D18()
{
  int v0; // edx
  int v1; // ecx
  time_t timer; // [esp+2Ch] [ebp-42Ch]
  int v4; // [esp+30h] [ebp-428h]
  struct tm tp; // [esp+34h] [ebp-424h]
  char v6; // [esp+63h] [ebp-3F5h]
  unsigned int v7; // [esp+44Ch] [ebp-Ch]

  v7 = __readgsdword(0x14u);
  if ( dword_8072398 < 0 )
  {
    timer = 0;
    if ( sub_80640F2(dword_807288F, &timer, &tp) )
    {
      v4 = sub_8051C60(v0, v1, (int)&v6, 1001, 0, (int)&tp, dword_807288F, 0);
      if ( v4 )
        dword_8072398 = sub_805B867(&v6, v4, 0);
    }
    if ( dword_8072398 < 0 )
      dword_8072398 = 0;
  }
  return dword_8072398;
}
// 8072398: using guessed type int dword_8072398;

//----- (08051E04) --------------------------------------------------------
#error "8051E48: call analysis failed (funcsize=36)"

//----- (08051EF1) --------------------------------------------------------
int __usercall sub_8051EF1@<eax>(int a1@<edx>, int a2@<ecx>, __uid_t uid, int a4, int a5)
{
  char *v5; // eax

  if ( (_BYTE)a5 == 1 )
  {
    if ( byte_8072839 )
      v5 = 0;
    else
      v5 = (char *)sub_805AAF6(a1, a2, uid);
  }
  else
  {
    v5 = "?";
  }
  return sub_8051E04(v5, uid, a4);
}
// 8072839: using guessed type char byte_8072839;

//----- (08051F44) --------------------------------------------------------
#error "8051FA5: call analysis failed (funcsize=42)"

//----- (08051FD8) --------------------------------------------------------
size_t __cdecl sub_8051FD8(char *a1, int a2)
{
  int v2; // edx
  int v3; // ecx
  int v5; // [esp+0h] [ebp-38h]
  int v6; // [esp+4h] [ebp-34h]
  int v7; // [esp+8h] [ebp-30h]
  char *v8; // [esp+Ch] [ebp-2Ch]
  int v9; // [esp+1Ch] [ebp-1Ch]
  char s; // [esp+21h] [ebp-17h]
  unsigned int v11; // [esp+2Ch] [ebp-Ch]

  v8 = a1;
  v11 = __readgsdword(0x14u);
  if ( a1 )
  {
    v9 = sub_805B80E(v8, 0);
    dword_80721FC = (int)&loc_8052058;
    sub_8065D3B(v3, v2, v5, v6);
  }
  v7 = a2;
  sprintf(&s, "%lu", a2, v8);
  return strlen(&s);
}
// 80721FC: using guessed type int dword_80721FC;

//----- (0805206B) --------------------------------------------------------
#error "80520A0: call analysis failed (funcsize=25)"

//----- (080520C8) --------------------------------------------------------
#error "8052144: call analysis failed (funcsize=39)"

//----- (0805214B) --------------------------------------------------------
const char *__cdecl sub_805214B(int a1, unsigned int a2, int a3)
{
  const char *result; // eax

  if ( a2 <= 0x14 )
    __assert_fail("INT_BUFSIZE_BOUND (uintmax_t) <= buflen", "src/ls.c", 0xFA7u, "format_inode");
  if ( *(_BYTE *)(a3 + 120) && *(_QWORD *)(a3 + 100) )
    result = (const char *)sub_805B0E9(*(_DWORD *)(a3 + 100), *(_DWORD *)(a3 + 104), a1);
  else
    result = "?";
  return result;
}
// 805B0E9: using guessed type _DWORD __cdecl sub_805B0E9(_DWORD, _DWORD, _DWORD);

//----- (080521EA) --------------------------------------------------------
#error "8052CA9: call analysis failed (funcsize=620)"

//----- (08052CAE) --------------------------------------------------------
#error "8052CEF: call analysis failed (funcsize=77)"

//----- (08052E60) --------------------------------------------------------
unsigned int __usercall sub_8052E60@<eax>(const unsigned __int16 *a1@<ebx>, double a2@<st0>, void **a3, unsigned int a4, char *a5, int *a6, int a7, unsigned int *a8, _BYTE *a9)
{
  int v9; // edx
  int v10; // ecx
  bool v11; // al
  int v12; // ecx
  int v13; // eax
  int v14; // ecx
  signed int v15; // eax
  char *v16; // eax
  char *v17; // edx
  char *v18; // eax
  char *v19; // eax
  char *v20; // eax
  char *v21; // edx
  char *v22; // eax
  const unsigned __int16 *v23; // ebx
  void *v24; // edx
  int v25; // ecx
  void *v26; // eax
  void *v27; // eax
  char v28; // al
  const unsigned __int16 *v30; // [esp-24h] [ebp-90h]
  int v31; // [esp-20h] [ebp-8Ch]
  unsigned __int8 v32; // [esp-1Ch] [ebp-88h]
  char *v33; // [esp-18h] [ebp-84h]
  int v34; // [esp-14h] [ebp-80h]
  unsigned __int8 *v35; // [esp-10h] [ebp-7Ch]
  int v36; // [esp-Ch] [ebp-78h]
  int v37; // [esp-8h] [ebp-74h]
  int v38; // [esp-4h] [ebp-70h]
  _BYTE *v39; // [esp+0h] [ebp-6Ch]
  unsigned int *v40; // [esp+4h] [ebp-68h]
  int *v41; // [esp+8h] [ebp-64h]
  char *s; // [esp+Ch] [ebp-60h]
  void **v43; // [esp+10h] [ebp-5Ch]
  int v44; // [esp+14h] [ebp-58h]
  int v45; // [esp+18h] [ebp-54h]
  int v46; // [esp+1Ch] [ebp-50h]
  int v47; // [esp+20h] [ebp-4Ch]
  void *dest; // [esp+24h] [ebp-48h]
  unsigned int v49; // [esp+28h] [ebp-44h]
  unsigned int v50; // [esp+2Ch] [ebp-40h]
  char *v51; // [esp+30h] [ebp-3Ch]
  char *v52; // [esp+34h] [ebp-38h]
  int v53; // [esp+38h] [ebp-34h]
  char *v54; // [esp+3Ch] [ebp-30h]
  unsigned __int8 *v55; // [esp+40h] [ebp-2Ch]
  int v56; // [esp+44h] [ebp-28h]
  char *v57; // [esp+48h] [ebp-24h]
  int v58; // [esp+4Ch] [ebp-20h]
  char *v59; // [esp+50h] [ebp-1Ch]
  unsigned __int8 *v60; // [esp+54h] [ebp-18h]
  mbstate_t ps; // [esp+58h] [ebp-14h]
  unsigned int v62; // [esp+60h] [ebp-Ch]

  v43 = a3;
  s = a5;
  v41 = a6;
  v40 = a8;
  v39 = a9;
  v62 = __readgsdword(0x14u);
  dest = *a3;
  v50 = 0;
  v56 = sub_805F1A5(a6);
  v11 = byte_8072877 && (v56 == 1 || v56 == 2 || !v56);
  HIBYTE(v46) = v11;
  if ( a7 )
  {
    v50 = sub_80603D4(v9, v10, (int)dest, a4, (int)s, -1, v41);
    if ( a4 <= v50 )
    {
      dest = sub_806210D(v50 + 1);
      sub_80603D4(v50 + 1, v12, (int)dest, v50 + 1, (int)s, -1, v41);
    }
    v13 = *s != *(_BYTE *)dest || strlen(s) != v50;
    BYTE2(v46) = v13 & 1;
  }
  else if ( HIBYTE(v46) )
  {
    v50 = strlen(s);
    if ( a4 <= v50 )
      dest = sub_806210D(v50 + 1);
    v13 = (int)memcpy(dest, s, v50 + 1);
    BYTE2(v46) = 0;
  }
  else
  {
    v50 = strlen(s);
    v13 = (int)s;
    dest = s;
    BYTE2(v46) = 0;
  }
  if ( HIBYTE(v46) )
  {
    if ( __ctype_get_mb_cur_max() > 1 )
    {
      v51 = (char *)dest;
      v57 = (char *)dest + v50;
      v52 = (char *)dest;
      v49 = 0;
      while ( 1 )
      {
LABEL_45:
        if ( v51 >= v57 )
        {
          dword_8072224 = (int)&loc_805334E;
          sub_8065C47(
            *(_DWORD *)&v32,
            v33,
            v34,
            v35,
            v36,
            v37,
            v38,
            v39,
            v40,
            v41,
            s,
            v43,
            v44,
            v45,
            v46,
            v47,
            dest,
            v49,
            v52 - (_BYTE *)dest,
            v51,
            v52,
            v53,
            v54);
          break;
        }
        v15 = *v51;
        if ( v15 > 63 )
        {
          if ( v15 < 65 || v15 > 95 && (unsigned int)(v15 - 97) > 0x1D )
            goto LABEL_31;
LABEL_30:
          v16 = v52++;
          v17 = v51++;
          *v16 = *v17;
          ++v49;
        }
        else
        {
          if ( v15 >= 37 || (unsigned int)(v15 - 32) <= 3 )
            goto LABEL_30;
LABEL_31:
          ps.__count = 0;
          ps.__wch = 0;
          while ( 1 )
          {
            v35 = &v32 - 20;
            v34 = v57 - v51;
            v33 = v51;
            v53 = sub_806330A(&v32 - 76);
            if ( v53 == -1 )
            {
              ++v51;
              v18 = v52++;
              *v18 = 63;
              ++v49;
              goto LABEL_45;
            }
            if ( v53 == -2 )
              break;
            if ( !v53 )
              v53 = 1;
            v58 = wcwidth(v47);
            if ( v58 < 0 )
            {
              v51 += v53;
              v22 = v52++;
              *v22 = 63;
              ++v49;
            }
            else
            {
              while ( v53 )
              {
                v20 = v52++;
                v21 = v51++;
                *v20 = *v21;
                --v53;
              }
              v49 += v58;
            }
            if ( mbsinit(&ps) )
              goto LABEL_45;
          }
          v51 = v57;
          v19 = v52++;
          *v19 = 63;
          ++v49;
        }
      }
    }
    v54 = (char *)dest;
    v59 = (char *)dest + v50;
    dword_807224C = (int)&loc_805329B;
    sub_8065B5D(v14, dest, *(_DWORD *)&v32, v33, v34, v35, v36, v37);
    do
    {
      v23 = *__ctype_b_loc();
      *(_DWORD *)&v32 = *v54;
      if ( !(v23[(unsigned __int8)sub_804A9A0(v32)] & 0x4000) )
        *v54 = 63;
      ++v54;
    }
    while ( v54 < v59 );
    v49 = v50;
  }
  else
  {
    v31 = v13;
    v30 = a1;
    v26 = &loc_80532CD;
    if ( !v40 )
      v26 = &loc_805334E;
    dword_8072210 = (int)v26;
    v23 = v30;
    sub_8065CCF(
      *(_DWORD *)&v32,
      v33,
      v34,
      v35,
      v36,
      v37,
      v38,
      v39,
      v40,
      v41,
      s,
      v43,
      v44,
      v45,
      v46,
      v47,
      dest,
      v49,
      v50,
      a2);
    if ( __ctype_get_mb_cur_max() <= 1 )
    {
      v55 = (unsigned __int8 *)dest;
      v24 = dest;
      v60 = (unsigned __int8 *)dest + v50;
      v49 = 0;
      while ( v55 < v60 )
      {
        v23 = *__ctype_b_loc();
        if ( v23[(unsigned __int8)sub_804A9A0(*v55)] & 0x4000 )
          ++v49;
        ++v55;
      }
    }
    else
    {
      v49 = sub_805B867((char *)dest, v50, 0);
    }
  }
  if ( byte_80727E0 && byte_80727DF )
  {
    v31 = BYTE2(v46) ^ 1;
    v30 = v23;
    v27 = &loc_8053398;
    if ( BYTE2(v46) == 1 )
      v27 = &loc_805339F;
    dword_80721FC = (int)v27;
    sub_8065D3B(v25, v24, *(_DWORD *)&v32, v33);
    v28 = 1;
  }
  else
  {
    v28 = 0;
  }
  *v39 = v28 & 1;
  if ( v40 )
    *v40 = v49;
  *v43 = dest;
  return v50;
}
// 80532C8: inconsistent fpu stack
// 8049560: using guessed type int __cdecl wcwidth(_DWORD);
// 806330A: using guessed type _DWORD __cdecl sub_806330A(_DWORD);
// 8065C47: using guessed type int __stdcall sub_8065C47(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8065CCF: using guessed type double __userpurge sub_8065CCF@<st0>(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, double@<st0>);
// 80721FC: using guessed type int dword_80721FC;
// 8072210: using guessed type int dword_8072210;
// 8072224: using guessed type int dword_8072224;
// 807224C: using guessed type int dword_807224C;
// 80727DF: using guessed type char byte_80727DF;
// 80727E0: using guessed type char byte_80727E0;
// 8072877: using guessed type char byte_8072877;

//----- (080533DD) --------------------------------------------------------
int __usercall sub_80533DD@<eax>(const unsigned __int16 *a1@<ebx>, double a2@<st0>, char *a3, int *a4, int a5)
{
  int v6; // [esp+0h] [ebp-2048h]
  int *v7; // [esp+28h] [ebp-2020h]
  char *v8; // [esp+2Ch] [ebp-201Ch]
  unsigned __int8 v9; // [esp+33h] [ebp-2015h]
  void *ptr; // [esp+34h] [ebp-2014h]
  int v11; // [esp+38h] [ebp-2010h]
  char v12; // [esp+3Ch] [ebp-200Ch]
  unsigned int v13; // [esp+203Ch] [ebp-Ch]

  v8 = a3;
  v7 = a4;
  v13 = __readgsdword(0x14u);
  ptr = &v6 - 2051;
  sub_8052E60(a1, a2, (void **)&v6 - 2053, 0x2000u, a3, a4, a5, (unsigned int *)&v6 - 2052, (_BYTE *)&v6 - 8213);
  if ( ptr != &v12 && ptr != v8 )
    free(ptr);
  return v9 + v11;
}

//----- (080534E5) --------------------------------------------------------
#error "8053549: call analysis failed (funcsize=96)"

//----- (08053622) --------------------------------------------------------
int __usercall sub_8053622@<eax>(const unsigned __int16 *a1@<ebx>, double a2@<st0>, int a3, char *a4, int a5, int a6, char a7)
{
  int v7; // ecx
  bool v8; // zf
  void *v9; // eax
  char *v10; // eax
  int result; // eax
  unsigned int v12; // esi
  const unsigned __int16 *v13; // [esp-8h] [ebp-2080h]
  int v14; // [esp-4h] [ebp-207Ch]
  char *v15; // [esp+0h] [ebp-2078h]
  int v16; // [esp+4h] [ebp-2074h]
  char *v17; // [esp+8h] [ebp-2070h]
  int *v18; // [esp+Ch] [ebp-206Ch]
  int v19; // [esp+10h] [ebp-2068h]
  char *v20; // [esp+14h] [ebp-2064h]
  char **v21; // [esp+18h] [ebp-2060h]
  char *v22; // [esp+1Ch] [ebp-205Ch]
  char *v23; // [esp+20h] [ebp-2058h]
  int v24; // [esp+3Ch] [ebp-203Ch]

  v24 = a3;
  *(&v15 - 2064) = a4;
  *(&v15 - 2065) = v20;
  *((_BYTE *)&v15 - 8264) = a7;
  *(&v15 - 2067) = v22;
  *(&v15 - 2068) = v23;
  *(&v15 - 3) = (char *)__readgsdword(0x14u);
  *(&v15 - 2061) = (char *)(&v15 - 2051);
  v21 = (char **)((char *)&v15 - 8246);
  v20 = 0;
  v18 = (int *)*(&v15 - 2064);
  v17 = *(&v15 - 2063);
  *(&v15 - 2060) = (char *)sub_8052E60(a1, a2, (void **)&v15 - 2061, 0x2000u, v17, v18, v19, 0, (_BYTE *)&v15 - 8246);
  if ( *((_BYTE *)&v15 - 8246) )
  {
    v8 = *((_BYTE *)&v15 - 8264) == 0;
    v14 = *((unsigned __int8 *)&v15 - 8246);
    v13 = a1;
    v9 = &loc_8053710;
    if ( v8 )
      v9 = &loc_8053729;
    dword_80721DC = (int)v9;
    sub_8065E0F(v7);
    putchar_unlocked(32);
    ++dword_8072943;
  }
  if ( *(&v15 - 2065) )
    sub_80541E1((int)*(&v15 - 2065));
  *((_BYTE *)&v15 - 8245) = 0;
  if ( *(&v15 - 2068) )
  {
    if ( byte_80727E0 && byte_80727DF && *((_BYTE *)&v15 - 8246) != 1 )
    {
      *((_BYTE *)&v15 - 8245) = 1;
      putchar_unlocked(**(&v15 - 2061));
    }
    *(&v15 - 2059) = sub_80534E5(dword_80727EF, 0);
    v16 = 1;
    v15 = *(&v15 - 2068);
    *(&v15 - 2058) = sub_80534E5(v15, 1);
    if ( **(&v15 - 2058) == 47 )
      v10 = &locale;
    else
      v10 = "/";
    v18 = (int *)*(&v15 - 2058);
    v17 = v10;
    v16 = (int)*(&v15 - 2059);
    printf("\x1B]8;;file://%s%s%s\a", v16, v10, v18);
    free(*(&v15 - 2059));
    free(*(&v15 - 2058));
  }
  if ( *(&v15 - 2067) && byte_807284B )
  {
    *(&v15 - 2057) = *(&v15 - 2067);
    *(&v15 - 2056) = (char *)4;
    *(&v15 - 2055) = *(&v15 - 2057);
    if ( *((_DWORD *)*(&v15 - 2055) + 4) - *((_DWORD *)*(&v15 - 2055) + 3) < (unsigned int)*(&v15 - 2056) )
      sub_80636C0(*(&v15 - 2057), *(&v15 - 2056));
    memcpy(*((void **)*(&v15 - 2057) + 3), &dword_8072943, (size_t)*(&v15 - 2056));
    *((_DWORD *)*(&v15 - 2057) + 3) += *(&v15 - 2056);
  }
  fwrite_unlocked(
    &(*(&v15 - 2061))[*((unsigned __int8 *)&v15 - 8245)],
    1u,
    (size_t)&(*(&v15 - 2060))[-2 * *((unsigned __int8 *)&v15 - 8245)],
    stdout);
  dword_8072943 += (int)*(&v15 - 2060);
  if ( *(&v15 - 2067) && byte_807284B )
  {
    *(&v15 - 2054) = *(&v15 - 2067);
    *(&v15 - 2053) = (char *)4;
    *(&v15 - 2052) = *(&v15 - 2054);
    if ( *((_DWORD *)*(&v15 - 2052) + 4) - *((_DWORD *)*(&v15 - 2052) + 3) < (unsigned int)*(&v15 - 2053) )
      sub_80636C0(*(&v15 - 2054), *(&v15 - 2053));
    memcpy(*((void **)*(&v15 - 2054) + 3), &dword_8072943, (size_t)*(&v15 - 2053));
    *((_DWORD *)*(&v15 - 2054) + 3) += *(&v15 - 2053);
  }
  if ( *(&v15 - 2068) )
  {
    fwrite_unlocked("\x1B]8;;\a", 1u, 6u, stdout);
    if ( *((_BYTE *)&v15 - 8245) )
      putchar_unlocked((*(&v15 - 2061))[(_DWORD)(*(&v15 - 2060) - 1)]);
  }
  if ( *(&v15 - 2061) != (char *)(&v15 - 2051) && *(&v15 - 2061) != *(&v15 - 2063) )
    free(*(&v15 - 2061));
  result = (int)&(*(&v15 - 2060))[*((unsigned __int8 *)&v15 - 8246)];
  v12 = __readgsdword(0x14u) ^ (unsigned int)*(&v15 - 3);
  return result;
}
// 80636C0: using guessed type _DWORD __cdecl sub_80636C0(_DWORD, _DWORD);
// 8065E0F: using guessed type int __fastcall sub_8065E0F(_DWORD);
// 80721DC: using guessed type int dword_80721DC;
// 80727DF: using guessed type char byte_80727DF;
// 80727E0: using guessed type char byte_80727E0;
// 807284B: using guessed type char byte_807284B;
// 8072943: using guessed type int dword_8072943;

//----- (08053B14) --------------------------------------------------------
#error "8053C91: call analysis failed (funcsize=113)"

//----- (08053CE3) --------------------------------------------------------
size_t sub_8053CE3()
{
  if ( dword_80722E0 )
    return sub_80546B2((int)&unk_80722DC);
  sub_80546B2((int)dword_80722CC);
  sub_80546B2((int)&unk_80722E4);
  return sub_80546B2((int)&dword_80722D4);
}
// 80722CC: using guessed type int dword_80722CC[];
// 80722D4: using guessed type int dword_80722D4;
// 80722E0: using guessed type int dword_80722E0;

//----- (08053D2A) --------------------------------------------------------
int __usercall sub_8053D2A@<eax>(int a1@<ebx>, int a2)
{
  char **v2; // ebp
  const char *v3; // edx
  int v4; // ecx
  void *v5; // eax
  char *v6; // edx
  char *v7; // eax
  int v8; // edx
  int v9; // eax
  int v10; // edx
  int v11; // eax
  int result; // eax
  unsigned int v13; // ebx
  int v14; // [esp-8h] [ebp-2E4h]
  int v15; // [esp-4h] [ebp-2E0h]
  char *format; // [esp+0h] [ebp-2DCh]
  int v17; // [esp+4h] [ebp-2D8h]
  char *s; // [esp+8h] [ebp-2D4h]
  int v19; // [esp+Ch] [ebp-2D0h]
  int v20; // [esp+2Ch] [ebp-2B0h]

  v20 = a2;
  *(&format - 3) = (char *)__readgsdword(0x14u);
  sub_804B7DA();
  v2 = &format;
  if ( byte_8072860 )
  {
    s = *(&format - 171);
    v3 = sub_805214B((int)(&format - 166), 0x28Cu, (int)s);
    v15 = dword_807282B;
    v14 = a1;
    v5 = &loc_8053DF0;
    if ( dword_807282B == 4 )
      v5 = &loc_8053DF7;
    v2 = (char **)&v14;
    dword_80721FC = (int)v5;
    sub_8065D3B(v4, v3, format, v17);
    s = v6;
    v17 = dword_8072803;
    printf("%*s ", dword_8072803, v6);
  }
  if ( byte_807283A )
  {
    if ( (*(v2 - 171))[120] == 1 )
    {
      v2 = &format;
      v7 = (char *)sub_8059958(
                     *((_DWORD *)*(&format - 171) + 17),
                     *((_DWORD *)*(&format - 171) + 18),
                     (char *)&format - 664,
                     dword_807283B,
                     512,
                     0,
                     dword_807283F,
                     dword_8072843);
    }
    else
    {
      v7 = "?";
    }
    if ( dword_807282B == 4 )
      v8 = 0;
    else
      v8 = dword_8072807;
    s = v7;
    v17 = v8;
    printf("%*s ", v8, v7);
  }
  if ( byte_80727FF )
  {
    if ( dword_807282B == 4 )
      v9 = 0;
    else
      v9 = dword_807280F;
    s = (char *)*((_DWORD *)*(v2 - 171) + 29);
    v17 = v9;
    printf("%*s ", v9, s);
  }
  v19 = (int)v2[3];
  s = 0;
  v17 = 0;
  format = *(v2 - 171);
  *(v2 - 167) = (char *)sub_8053B14(format, 0, 0, v19);
  if ( dword_807284F )
  {
    v10 = *((_DWORD *)*(&format - 171) + 7);
    v11 = (unsigned __int8)(*(&format - 171))[120];
    s = (char *)*((_DWORD *)*(v2 - 171) + 27);
    v2 = &format;
    *(&format - 167) += (unsigned __int8)sub_805413B(v11, v10, s);
  }
  result = (int)*(v2 - 167);
  v13 = __readgsdword(0x14u) ^ (unsigned int)*(v2 - 3);
  return result;
}
// 8053B14: using guessed type _DWORD __cdecl sub_8053B14(_DWORD, _DWORD, _DWORD, _DWORD);
// 805413B: using guessed type int __cdecl sub_805413B(_DWORD, _DWORD, _DWORD);
// 80721FC: using guessed type int dword_80721FC;
// 80727FF: using guessed type char byte_80727FF;
// 8072803: using guessed type int dword_8072803;
// 8072807: using guessed type int dword_8072807;
// 807282B: using guessed type int dword_807282B;
// 807283A: using guessed type char byte_807283A;
// 807284F: using guessed type int dword_807284F;
// 8072860: using guessed type char byte_8072860;

//----- (08053FBE) --------------------------------------------------------
int __usercall sub_8053FBE@<eax>(int a1@<edx>, int a2@<ecx>, char a3, __int16 a4, int a5)
{
  bool v5; // al
  bool v6; // al
  bool v7; // al
  bool v8; // al
  void *v9; // eax
  _DWORD v11[4]; // [esp+0h] [ebp-14h]
  int v12; // [esp+0h] [ebp-14h]
  int v13; // [esp+4h] [ebp-10h]
  int v14; // [esp+4h] [ebp-10h]
  int v15; // [esp+8h] [ebp-Ch]
  int v16; // [esp+8h] [ebp-Ch]
  int v17; // [esp+Ch] [ebp-8h]
  int v18; // [esp+Ch] [ebp-8h]
  int v19; // [esp+10h] [ebp-4h]
  int v20; // [esp+10h] [ebp-4h]
  unsigned __int8 v21; // [esp+13h] [ebp-1h]
  int savedregs; // [esp+14h] [ebp+0h]
  int savedregsa; // [esp+14h] [ebp+0h]

  LOBYTE(v11[0]) = a3;
  if ( a3 )
    v5 = (unsigned __int16)(a4 & 0xF000) == 0x8000;
  else
    v5 = a5 == 5;
  if ( v5 )
  {
    if ( a3 && dword_807284F == 3 && a4 & 0x49 )
      v21 = 42;
    else
      v21 = 0;
  }
  else
  {
    if ( a3 )
    {
      v6 = (unsigned __int16)(a4 & 0xF000) == 0x4000;
    }
    else
    {
      v7 = a5 == 3 || a5 == 9;
      v6 = v7;
    }
    if ( v6 )
    {
      v21 = 47;
    }
    else if ( dword_807284F == 1 )
    {
      v21 = 0;
    }
    else
    {
      if ( a3 )
        v8 = (unsigned __int16)(a4 & 0xF000) == 40960;
      else
        v8 = a5 == 6;
      if ( v8 )
      {
        v21 = 64;
      }
      else
      {
        if ( a3 )
        {
          dword_807224C = (int)&loc_80540D0;
          sub_8065B5D(a2, a1, v11[0], v13, v15, v17, v19, savedregs);
        }
        if ( a5 == 1 )
        {
          v21 = 124;
        }
        else
        {
          v9 = &loc_80540F9;
          if ( !LOBYTE(v11[0]) )
            v9 = &loc_805410B;
          dword_807224C = (int)v9;
          sub_8065B5D(a2, a1, v11[0], v13, v15, v17, v19, savedregs);
          if ( (a4 & 0xF000) == 49152 )
          {
            HIBYTE(v20) = 61;
            dword_8072238 = (int)&loc_8054135;
            sub_8065BD3(v12, v14, v16, v18, v20, savedregsa);
          }
          v21 = 0;
        }
      }
    }
  }
  return v21;
}
// 8065BD3: using guessed type int __stdcall sub_8065BD3(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8072238: using guessed type int dword_8072238;
// 807224C: using guessed type int dword_807224C;
// 807284F: using guessed type int dword_807284F;

//----- (0805413B) --------------------------------------------------------
#error "805414A: call analysis failed (funcsize=11)"

//----- (0805415D) --------------------------------------------------------
bool __cdecl sub_805415D(int a1, char a2)
{
  int v2; // ecx
  int v4; // [esp+0h] [ebp-28h]
  int v5; // [esp+Ch] [ebp-1Ch]
  int v6; // [esp+10h] [ebp-18h]
  char v7; // [esp+1Bh] [ebp-Dh]

  *((_BYTE *)&v4 - 28) = a2;
  *((_BYTE *)&v4 - 9) = sub_8053FBE(v5, v2, *((_BYTE *)&v4 - 28), v5, v6);
  if ( v7 )
  {
    putchar_unlocked(v7);
    ++dword_8072943;
  }
  return v7 != 0;
}
// 805415D: could not find valid save-restore pair for ebp
// 8072943: using guessed type int dword_8072943;

//----- (080541E1) --------------------------------------------------------
bool __cdecl sub_80541E1(int a1)
{
  if ( a1 )
  {
    if ( (unsigned __int8)sub_804B6E4(4) )
      sub_804B7AA();
    sub_80546B2((int)dword_80722CC);
    sub_80546B2(a1);
    sub_80546B2((int)&dword_80722D4);
  }
  return a1 != 0;
}
// 80722CC: using guessed type int dword_80722CC[];
// 80722D4: using guessed type int dword_80722D4;

//----- (0805423E) --------------------------------------------------------
#error "805453E: call analysis failed (funcsize=300)"

//----- (080546B2) --------------------------------------------------------
size_t __cdecl sub_80546B2(int a1)
{
  if ( byte_8072855 != 1 )
  {
    byte_8072855 = 1;
    if ( tcgetpgrp(1) >= 0 )
      sub_804BB18();
    sub_8053CE3();
  }
  return fwrite_unlocked(*(const void **)(a1 + 4), *(_DWORD *)a1, 1u, stdout);
}
// 8072855: using guessed type char byte_8072855;

//----- (08054720) --------------------------------------------------------
int __usercall sub_8054720@<eax>(const unsigned __int16 *a1@<ebx>, double a2@<st0>)
{
  const char *v2; // eax
  int v3; // eax
  const char *v4; // eax
  int v5; // eax
  int v6; // eax
  char *v7; // eax
  int v8; // edx
  char v9; // al
  int result; // eax
  unsigned int v11; // ebx
  char *s; // [esp+0h] [ebp-2DCh]
  char *v13; // [esp+8h] [ebp-2D4h]
  const unsigned __int16 *v14; // [esp+2D0h] [ebp-Ch]

  v14 = a1;
  *(&s - 171) = v13;
  *(&s - 3) = (char *)__readgsdword(0x14u);
  *(&s - 167) = 0;
  if ( byte_8072860 )
  {
    if ( dword_807282B == 4 )
    {
      v2 = (const char *)sub_805B0E9(*((_DWORD *)*(&s - 171) + 25), *((_DWORD *)*(&s - 171) + 26), &s - 166);
      v3 = strlen(v2) + 1;
    }
    else
    {
      v3 = dword_8072803 + 1;
    }
    *(&s - 167) += v3;
  }
  if ( byte_807283A )
  {
    if ( dword_807282B == 4 )
    {
      if ( (*(&s - 171))[120] == 1 )
      {
        a1 = (const unsigned __int16 *)dword_8072843;
        v4 = (const char *)sub_8059958(
                             *((_DWORD *)*(&s - 171) + 17),
                             *((_DWORD *)*(&s - 171) + 18),
                             (char *)&s - 664,
                             dword_807283B,
                             512,
                             0,
                             dword_807283F,
                             dword_8072843);
      }
      else
      {
        v4 = "?";
      }
      v5 = strlen(v4) + 1;
    }
    else
    {
      v5 = dword_8072807 + 1;
    }
    *(&s - 167) += v5;
  }
  if ( byte_80727FF )
  {
    if ( dword_807282B == 4 )
    {
      s = (char *)*((_DWORD *)*(&s - 171) + 29);
      v6 = strlen(s) + 1;
    }
    else
    {
      v6 = dword_807280F + 1;
    }
    *(&s - 167) += v6;
  }
  v7 = *(char **)*(&s - 171);
  v13 = (char *)*((_DWORD *)*(&s - 171) + 33);
  *(&s - 167) += sub_80533DD(a1, a2, v7, (int *)dword_807287B, (int)v13);
  if ( dword_807284F )
  {
    v8 = *((_DWORD *)*(&s - 171) + 7);
    v9 = (*(&s - 171))[120];
    v13 = (char *)*((_DWORD *)*(&s - 171) + 27);
    *((_BYTE *)&s - 669) = sub_8053FBE(v8, (int)v13, v9, v8, (int)v13);
    *(&s - 167) += *((_BYTE *)&s - 669) != 0;
  }
  result = (int)*(&s - 167);
  v11 = __readgsdword(0x14u) ^ (unsigned int)*(&s - 3);
  return result;
}
// 805B0E9: using guessed type _DWORD __cdecl sub_805B0E9(_DWORD, _DWORD, _DWORD);
// 80727FF: using guessed type char byte_80727FF;
// 8072803: using guessed type int dword_8072803;
// 8072807: using guessed type int dword_8072807;
// 807282B: using guessed type int dword_807282B;
// 807283A: using guessed type char byte_807283A;
// 807284F: using guessed type int dword_807284F;
// 8072860: using guessed type char byte_8072860;
// 807287B: using guessed type int dword_807287B;

//----- (0805497A) --------------------------------------------------------
unsigned int __usercall sub_805497A@<eax>(const unsigned __int16 *a1@<ebx>, double a2@<st0>)
{
  unsigned int v2; // eax
  int v3; // ST34_4
  int v4; // eax
  unsigned int result; // eax
  unsigned int i; // [esp+18h] [ebp-30h]
  int v7; // [esp+1Ch] [ebp-2Ch]
  unsigned int v8; // [esp+20h] [ebp-28h]
  int j; // [esp+24h] [ebp-24h]
  char *v10; // [esp+2Ch] [ebp-1Ch]
  unsigned int v11; // [esp+30h] [ebp-18h]
  int v12; // [esp+38h] [ebp-10h]
  int v13; // [esp+3Ch] [ebp-Ch]

  v2 = sub_8055196(1);
  v10 = (char *)dword_807293B + 12 * v2 - 12;
  v11 = dword_80727DB / v2 + (dword_80727DB % v2 != 0);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v11 )
      break;
    v7 = 0;
    v8 = i;
    for ( j = 0; ; j += v13 )
    {
      v3 = *((_DWORD *)ptr + v8);
      v12 = sub_8054720(a1, a2);
      v4 = v7++;
      v13 = *(_DWORD *)(*((_DWORD *)v10 + 2) + 4 * v4);
      sub_8053D2A((int)a1, v3);
      v8 += v11;
      if ( v8 >= dword_80727DB )
        break;
      sub_8054D6C(j + v12, v13 + j);
    }
    putchar_unlocked(10);
  }
  return result;
}
// 8054D6C: using guessed type _DWORD __cdecl sub_8054D6C(_DWORD, _DWORD);
// 8055196: using guessed type _DWORD __cdecl sub_8055196(_DWORD);
// 80727DB: using guessed type int dword_80727DB;

//----- (08054B0A) --------------------------------------------------------
int __usercall sub_8054B0A@<eax>(const unsigned __int16 *a1@<ebx>, double a2@<st0>)
{
  int v3; // [esp+0h] [ebp-38h]
  int v4; // [esp+4h] [ebp-34h]
  int v5; // [esp+14h] [ebp-24h]
  int v6; // [esp+20h] [ebp-18h]

  v5 = 0;
  v6 = sub_8055196(0);
  *(&v3 - 5) = (int)dword_807293B + 12 * v6 - 12;
  *(&v3 - 4) = *(_DWORD *)ptr;
  v3 = *(&v3 - 4);
  *(&v3 - 8) = sub_8054720(a1, a2);
  *(&v3 - 7) = **(_DWORD **)(*(&v3 - 5) + 8);
  v4 = 0;
  sub_8053D2A((int)a1, *(&v3 - 4));
  for ( *(&v3 - 10) = 1; *(&v3 - 10) < (unsigned int)dword_80727DB; ++*(&v3 - 10) )
  {
    *(&v3 - 3) = *(&v3 - 10) % (unsigned int)*(&v3 - 6);
    if ( *(&v3 - 3) )
    {
      sub_8054D6C(*(&v3 - 9) + *(&v3 - 8), *(&v3 - 7) + *(&v3 - 9));
      *(&v3 - 9) += *(&v3 - 7);
    }
    else
    {
      putchar_unlocked(10);
      *(&v3 - 9) = 0;
    }
    *(&v3 - 4) = *((_DWORD *)ptr + *(&v3 - 10));
    v4 = *(&v3 - 9);
    sub_8053D2A((int)a1, *(&v3 - 4));
    v3 = *(&v3 - 4);
    *(&v3 - 8) = sub_8054720(a1, a2);
    *(&v3 - 7) = *(_DWORD *)(4 * *(&v3 - 3) + *(_DWORD *)(*(&v3 - 5) + 8));
  }
  return putchar_unlocked(10);
}
// 8054D6C: using guessed type _DWORD __cdecl sub_8054D6C(_DWORD, _DWORD);
// 8055196: using guessed type _DWORD __cdecl sub_8055196(_DWORD);
// 80727DB: using guessed type int dword_80727DB;

//----- (08054C84) --------------------------------------------------------
int __usercall sub_8054C84@<eax>(const unsigned __int16 *a1@<ebx>, double a2@<st0>, char a3)
{
  int v3; // eax
  char v5; // [esp+1Fh] [ebp-19h]
  unsigned int i; // [esp+20h] [ebp-18h]
  unsigned int v7; // [esp+24h] [ebp-14h]
  int v8; // [esp+28h] [ebp-10h]
  int v9; // [esp+2Ch] [ebp-Ch]

  v7 = 0;
  for ( i = 0; i < dword_80727DB; ++i )
  {
    v8 = *((_DWORD *)ptr + i);
    if ( dword_807288B )
      v3 = sub_8054720(a1, a2);
    else
      v3 = 0;
    v9 = v3;
    if ( i )
    {
      if ( dword_807288B && (v7 + v3 + 2 >= dword_807288B || -3 - v3 < v7) )
      {
        v7 = 0;
        v5 = 10;
      }
      else
      {
        v7 += 2;
        v5 = 32;
      }
      putchar_unlocked(a3);
      putchar_unlocked(v5);
    }
    sub_8053D2A((int)a1, v8);
    v7 += v9;
  }
  return putchar_unlocked(10);
}
// 80727DB: using guessed type int dword_80727DB;
// 807288B: using guessed type int dword_807288B;

//----- (08054D6C) --------------------------------------------------------
#error "8054DA7: call analysis failed (funcsize=70)"

//----- (08054E54) --------------------------------------------------------
_BYTE *__cdecl sub_8054E54(_BYTE *a1, _BYTE *a2, _BYTE *a3)
{
  int v3; // ecx
  void *v4; // eax
  int v5; // ecx
  _BYTE *v6; // eax
  _BYTE *v7; // edx
  _BYTE *v8; // eax
  _BYTE *v9; // eax
  _BYTE *v10; // edx
  _BYTE *result; // eax
  _BYTE *v12; // [esp+Ch] [ebp-4h]

  v12 = a2;
  v4 = &loc_8054E83;
  if ( *a2 != 46 )
    v4 = &loc_8054E90;
  dword_80721DC = (int)v4;
  sub_8065E0F(v3);
  if ( !a2[1] )
    goto LABEL_16;
  while ( *v12 )
  {
    v6 = a1++;
    v7 = v12;
    v5 = (int)(v12++ + 1);
    *v6 = *v7;
  }
  if ( v12 <= a2 || *(v12 - 1) == 47 )
  {
LABEL_16:
    dword_80721DC = (int)&loc_8054F08;
    sub_8065E0F(v5);
    goto LABEL_11;
  }
  v8 = a1++;
  *v8 = 47;
  while ( *a3 )
  {
LABEL_11:
    v9 = a1++;
    v10 = a3++;
    *v9 = *v10;
  }
  result = a1;
  *a1 = 0;
  return result;
}
// 8065E0F: using guessed type int __fastcall sub_8065E0F(_DWORD);
// 80721DC: using guessed type int dword_80721DC;

//----- (08054F1A) --------------------------------------------------------
#error "8055044: call analysis failed (funcsize=124)"

//----- (0805510F) --------------------------------------------------------
#error "8055195: positive sp value has been found (funcsize=37)"

//----- (08055196) --------------------------------------------------------
#error "80553C3: call analysis failed (funcsize=210)"

//----- (08055468) --------------------------------------------------------
void __cdecl __noreturn sub_8055468(int status)
{
  int v1; // ebx
  char *v2; // eax
  int v3; // ebx
  char *v4; // eax
  FILE *v5; // ebx
  char *v6; // eax
  FILE *v7; // ebx
  char *v8; // eax
  FILE *v9; // ebx
  char *v10; // eax
  FILE *v11; // ebx
  char *v12; // eax
  FILE *v13; // ebx
  char *v14; // eax
  FILE *v15; // ebx
  char *v16; // eax
  FILE *v17; // ebx
  char *v18; // eax
  FILE *v19; // ebx
  char *v20; // eax
  FILE *v21; // ebx
  char *v22; // eax
  FILE *v23; // ebx
  char *v24; // eax
  FILE *v25; // ebx
  char *v26; // eax
  FILE *v27; // ebx
  char *v28; // eax
  FILE *v29; // ebx
  char *v30; // eax
  FILE *v31; // ebx
  char *v32; // eax
  FILE *v33; // ebx
  char *v34; // eax
  FILE *v35; // ebx
  char *v36; // eax
  FILE *v37; // ebx
  char *v38; // eax
  FILE *v39; // ebx
  char *v40; // eax
  FILE *v41; // ebx
  char *v42; // eax
  FILE *v43; // ebx
  char *v44; // eax
  FILE *v45; // ebx
  char *v46; // eax
  FILE *v47; // ebx
  char *v48; // eax
  FILE *v49; // ebx
  char *v50; // eax
  FILE *v51; // ebx
  char *v52; // eax
  const char *v53; // eax

  if ( status )
  {
    v1 = dword_8073803;
    v2 = gettext("Try '%s --help' for more information.\n");
    fprintf(stderr, v2, v1);
  }
  else
  {
    v3 = dword_8073803;
    v4 = gettext("Usage: %s [OPTION]... [FILE]...\n");
    printf(v4, v3);
    v5 = stdout;
    v6 = gettext(
           "List information about the FILEs (the current directory by default).\n"
           "Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.\n");
    fputs_unlocked(v6, v5);
    sub_804AA27();
    v7 = stdout;
    v8 = gettext(
           "  -a, --all                  do not ignore entries starting with .\n"
           "  -A, --almost-all           do not list implied . and ..\n"
           "      --author               with -l, print the author of each file\n"
           "  -b, --escape               print C-style escapes for nongraphic characters\n");
    fputs_unlocked(v8, v7);
    v9 = stdout;
    v10 = gettext(
            "      --block-size=SIZE      scale sizes by SIZE before printing them; e.g.,\n"
            "                               '--block-size=M' prints sizes in units of\n"
            "                               1,048,576 bytes; see SIZE format below\n"
            "  -B, --ignore-backups       do not list implied entries ending with ~\n"
            "  -c                         with -lt: sort by, and show, ctime (time of last\n"
            "                               modification of file status information);\n"
            "                               with -l: show ctime and sort by name;\n"
            "                               otherwise: sort by ctime, newest first\n");
    fputs_unlocked(v10, v9);
    v11 = stdout;
    v12 = gettext(
            "  -C                         list entries by columns\n"
            "      --color[=WHEN]         colorize the output; WHEN can be 'always' (default\n"
            "                               if omitted), 'auto', or 'never'; more info below\n"
            "  -d, --directory            list directories themselves, not their contents\n"
            "  -D, --dired                generate output designed for Emacs' dired mode\n");
    fputs_unlocked(v12, v11);
    v13 = stdout;
    v14 = gettext(
            "  -f                         do not sort, enable -aU, disable -ls --color\n"
            "  -F, --classify             append indicator (one of */=>@|) to entries\n"
            "      --file-type            likewise, except do not append '*'\n"
            "      --format=WORD          across -x, commas -m, horizontal -x, long -l,\n"
            "                               single-column -1, verbose -l, vertical -C\n"
            "      --full-time            like -l --time-style=full-iso\n");
    fputs_unlocked(v14, v13);
    v15 = stdout;
    v16 = gettext("  -g                         like -l, but do not list owner\n");
    fputs_unlocked(v16, v15);
    v17 = stdout;
    v18 = gettext(
            "      --group-directories-first\n"
            "                             group directories before files;\n"
            "                               can be augmented with a --sort option, but any\n"
            "                               use of --sort=none (-U) disables grouping\n");
    fputs_unlocked(v18, v17);
    v19 = stdout;
    v20 = gettext(
            "  -G, --no-group             in a long listing, don't print group names\n"
            "  -h, --human-readable       with -l and/or -s, print human readable sizes\n"
            "                               (e.g., 1K 234M 2G)\n"
            "      --si                   likewise, but use powers of 1000 not 1024\n");
    fputs_unlocked(v20, v19);
    v21 = stdout;
    v22 = gettext(
            "  -H, --dereference-command-line\n"
            "                             follow symbolic links listed on the command line\n"
            "      --dereference-command-line-symlink-to-dir\n"
            "                             follow each command line symbolic link\n"
            "                               that points to a directory\n"
            "      --hide=PATTERN         do not list implied entries matching shell PATTERN\n"
            "                               (overridden by -a or -A)\n");
    fputs_unlocked(v22, v21);
    v23 = stdout;
    v24 = gettext(
            "      --hyperlink[=WHEN]     hyperlink file names; WHEN can be 'always'\n"
            "                               (default if omitted), 'auto', or 'never'\n");
    fputs_unlocked(v24, v23);
    v25 = stdout;
    v26 = gettext(
            "      --indicator-style=WORD  append indicator with style WORD to entry names:\n"
            "                               none (default), slash (-p),\n"
            "                               file-type (--file-type), classify (-F)\n"
            "  -i, --inode                print the index number of each file\n"
            "  -I, --ignore=PATTERN       do not list implied entries matching shell PATTERN\n"
            "  -k, --kibibytes            default to 1024-byte blocks for disk usage\n");
    fputs_unlocked(v26, v25);
    v27 = stdout;
    v28 = gettext(
            "  -l                         use a long listing format\n"
            "  -L, --dereference          when showing file information for a symbolic\n"
            "                               link, show information for the file the link\n"
            "                               references rather than for the link itself\n"
            "  -m                         fill width with a comma separated list of entries\n");
    fputs_unlocked(v28, v27);
    v29 = stdout;
    v30 = gettext(
            "  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs\n"
            "  -N, --literal              print entry names without quoting\n"
            "  -o                         like -l, but do not list group information\n"
            "  -p, --indicator-style=slash\n"
            "                             append / indicator to directories\n");
    fputs_unlocked(v30, v29);
    v31 = stdout;
    v32 = gettext(
            "  -q, --hide-control-chars   print ? instead of nongraphic characters\n"
            "      --show-control-chars   show nongraphic characters as-is (the default,\n"
            "                               unless program is 'ls' and output is a terminal)\n"
            "  -Q, --quote-name           enclose entry names in double quotes\n"
            "      --quoting-style=WORD   use quoting style WORD for entry names:\n"
            "                               literal, locale, shell, shell-always,\n"
            "                               shell-escape, shell-escape-always, c, escape\n");
    fputs_unlocked(v32, v31);
    v33 = stdout;
    v34 = gettext(
            "  -r, --reverse              reverse order while sorting\n"
            "  -R, --recursive            list subdirectories recursively\n"
            "  -s, --size                 print the allocated size of each file, in blocks\n");
    fputs_unlocked(v34, v33);
    v35 = stdout;
    v36 = gettext(
            "  -S                         sort by file size, largest first\n"
            "      --sort=WORD            sort by WORD instead of name: none (-U), size (-S),\n"
            "                               time (-t), version (-v), extension (-X)\n"
            "      --time=WORD            with -l, show time as WORD instead of default\n"
            "                               modification time: atime or access or use (-u);\n"
            "                               ctime or status (-c); also use specified time\n"
            "                               as sort key if --sort=time (newest first)\n");
    fputs_unlocked(v36, v35);
    v37 = stdout;
    v38 = gettext(
            "      --time-style=STYLE     with -l, show times using style STYLE:\n"
            "                               full-iso, long-iso, iso, locale, or +FORMAT;\n"
            "                               FORMAT is interpreted like in 'date'; if FORMAT\n"
            "                               is FORMAT1<newline>FORMAT2, then FORMAT1 applies\n"
            "                               to non-recent files and FORMAT2 to recent files;\n"
            "                               if STYLE is prefixed with 'posix-', STYLE\n"
            "                               takes effect only outside the POSIX locale\n");
    fputs_unlocked(v38, v37);
    v39 = stdout;
    v40 = gettext(
            "  -t                         sort by modification time, newest first\n"
            "  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8\n");
    fputs_unlocked(v40, v39);
    v41 = stdout;
    v42 = gettext(
            "  -u                         with -lt: sort by, and show, access time;\n"
            "                               with -l: show access time and sort by name;\n"
            "                               otherwise: sort by access time, newest first\n"
            "  -U                         do not sort; list entries in directory order\n"
            "  -v                         natural sort of (version) numbers within text\n");
    fputs_unlocked(v42, v41);
    v43 = stdout;
    v44 = gettext(
            "  -w, --width=COLS           set output width to COLS.  0 means no limit\n"
            "  -x                         list entries by lines instead of by columns\n"
            "  -X                         sort alphabetically by entry extension\n"
            "  -Z, --context              print any security context of each file\n"
            "  -1                         list one file per line.  Avoid '\\n' with -q or -b\n");
    fputs_unlocked(v44, v43);
    v45 = stdout;
    v46 = gettext("      --help     display this help and exit\n");
    fputs_unlocked(v46, v45);
    v47 = stdout;
    v48 = gettext("      --version  output version information and exit\n");
    fputs_unlocked(v48, v47);
    sub_804AA56();
    v49 = stdout;
    v50 = gettext(
            "\n"
            "Using color to distinguish file types is disabled both by default and\n"
            "with --color=never.  With --color=auto, ls emits color codes only when\n"
            "standard output is connected to a terminal.  The LS_COLORS environment\n"
            "variable can change the settings.  Use the dircolors command to set it.\n");
    fputs_unlocked(v50, v49);
    v51 = stdout;
    v52 = gettext(
            "\n"
            "Exit status:\n"
            " 0  if OK,\n"
            " 1  if minor problems (e.g., cannot access subdirectory),\n"
            " 2  if serious trouble (e.g., cannot access command-line argument).\n");
    fputs_unlocked(v52, v51);
    if ( dword_80723D4 == 1 )
    {
      v53 = "ls";
    }
    else if ( dword_80723D4 == 2 )
    {
      v53 = "dir";
    }
    else
    {
      v53 = "vdir";
    }
    sub_804AA9F(v53);
  }
  exit(status);
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 804AA9F: using guessed type _DWORD __cdecl sub_804AA9F(_DWORD);
// 80723D4: using guessed type int dword_80723D4;
// 8073803: using guessed type int dword_8073803;

//----- (080557E2) --------------------------------------------------------
char *__cdecl sub_80557E2(char *path, int a2)
{
  int v2; // eax
  int v4; // ST2C_4
  size_t size; // [esp+10h] [ebp-28h]
  char *buf; // [esp+20h] [ebp-18h]
  ssize_t v7; // [esp+28h] [ebp-10h]

  if ( (unsigned int)a2 >= 0x401 )
    v2 = 1025;
  else
    v2 = a2 + 1;
  for ( size = v2; ; size = 0x7FFFFFFF )
  {
    while ( 1 )
    {
      buf = (char *)malloc(size);
      if ( !buf )
        return 0;
      v7 = readlink(path, buf, size);
      if ( v7 < 0 && *__errno_location() != 34 )
      {
        v4 = *__errno_location();
        free(buf);
        *__errno_location() = v4;
        return 0;
      }
      if ( v7 < size )
      {
        buf[v7] = 0;
        return buf;
      }
      free(buf);
      if ( size > 0x3FFFFFFF )
        break;
      size *= 2;
    }
    if ( size > 0x7FFFFFFE )
      break;
  }
  *__errno_location() = 12;
  return 0;
}

//----- (080558FA) --------------------------------------------------------
void __noreturn sub_80558FA()
{
  sub_8055468(1);
}

//----- (0805590E) --------------------------------------------------------
int __cdecl sub_805590E(char *s, int a2, int a3, size_t a4)
{
  int result; // eax
  char v5; // [esp+13h] [ebp-15h]
  signed int i; // [esp+14h] [ebp-14h]
  signed int v7; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]

  v7 = -1;
  v5 = 0;
  n = strlen(s);
  for ( i = 0; *(_DWORD *)(4 * i + a2); ++i )
  {
    if ( !strncmp(*(const char **)(4 * i + a2), s, n) )
    {
      if ( strlen(*(const char **)(4 * i + a2)) == n )
        return i;
      if ( v7 == -1 )
      {
        v7 = i;
      }
      else if ( !a3 || memcmp((const void *)(a3 + a4 * v7), (const void *)(i * a4 + a3), a4) )
      {
        v5 = 1;
      }
    }
  }
  if ( v5 )
    result = -2;
  else
    result = v7;
  return result;
}

//----- (08055A3D) --------------------------------------------------------
void __cdecl sub_8055A3D(int a1, int a2, int a3)
{
  char *v3; // eax
  char *format; // ST2C_4
  int v5; // ebx
  int v6; // eax

  if ( a3 == -1 )
    v3 = gettext("invalid argument %s for %s");
  else
    v3 = gettext("ambiguous argument %s for %s");
  format = v3;
  v5 = sub_80610C3();
  v6 = sub_8060AA6(0, 8);
  error(0, 0, format, v6, v5);
}

//----- (08055AC0) --------------------------------------------------------
int __cdecl sub_8055AC0(int a1, int a2, size_t n)
{
  FILE *v3; // ebx
  char *v4; // eax
  int v6; // [esp-18h] [ebp-28h]
  int v7; // [esp-10h] [ebp-20h]
  int i; // [esp+0h] [ebp-10h]
  void *s1; // [esp+4h] [ebp-Ch]

  s1 = 0;
  v3 = stderr;
  v4 = gettext("Valid arguments are:");
  fputs_unlocked(v4, v3);
  for ( i = 0; *(_DWORD *)(4 * i + a1); ++i )
  {
    if ( i && !memcmp(s1, (const void *)(a2 + i * n), n) )
    {
      v6 = *(_DWORD *)(4 * i + a1);
      v7 = sub_80610F3();
      fprintf(stderr, ", %s", v7);
    }
    else
    {
      v6 = *(_DWORD *)(4 * i + a1);
      v7 = sub_80610F3();
      fprintf(stderr, "\n  - %s", v7);
      s1 = (void *)(i * n + a2);
    }
  }
  return putc_unlocked(10, stderr);
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (08055C0B) --------------------------------------------------------
int __cdecl sub_8055C0B(int a1, char *s, int a3, int a4, size_t n, int a6)
{
  int v7; // [esp+1Ch] [ebp-Ch]

  v7 = sub_805590E(s, a3, a4, n);
  if ( v7 >= 0 )
    return v7;
  sub_8055A3D(a1, (int)s, v7);
  sub_8055AC0(a3, a4, n);
  ((void (*)(void))a6)();
  return -1;
}

//----- (08055D17) --------------------------------------------------------
#error "8055D46: call analysis failed (funcsize=27)"

//----- (08055D70) --------------------------------------------------------
_BOOL4 __cdecl sub_8055D70(signed int a1)
{
  return a1 >= 65 && (a1 <= 90 || (unsigned int)(a1 - 97) <= 0x19);
}

//----- (08055E1D) --------------------------------------------------------
_BOOL4 __cdecl sub_8055E1D(int a1)
{
  return (unsigned int)(a1 - 48) <= 9;
}

//----- (08055F44) --------------------------------------------------------
int __cdecl sub_8055F44(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 65) > 0x19 )
    result = a1;
  else
    result = a1 + 32;
  return result;
}

//----- (08055FA1) --------------------------------------------------------
int __cdecl sub_8055FA1(int a1, char *s, int a3)
{
  if ( !*(_DWORD *)a1 )
  {
    *(_DWORD *)a1 = sub_80583AD(
                      7u,
                      0,
                      (unsigned int (__cdecl *)(int, unsigned int))sub_80593CC,
                      (bool (__cdecl *)(int, int))sub_80595B3,
                      (size_t)sub_8059673);
    if ( !*(_DWORD *)a1 )
      sub_80622AF();
  }
  if ( sub_8056E22(*(_DWORD *)a1, (int)s, (int *)a3) )
    return 1;
  sub_8056D70(*(_DWORD *)a1, s, a3);
  return 0;
}

//----- (0805606B) --------------------------------------------------------
char *__usercall sub_805606B@<eax>(long double a1@<st0>, void *src, int a3)
{
  _BYTE *v4; // eax
  _BYTE *v5; // eax
  char *v6; // eax
  bool v7; // al
  size_t v8; // eax
  void *v9; // eax
  int v10; // edx
  int v11; // ecx
  char *v12; // eax
  bool v13; // zf
  void *v14; // eax
  int v15; // edx
  int v16; // ecx
  int v17; // edx
  int v18; // ecx
  int v19; // [esp+0h] [ebp-C8h]
  int v20; // [esp+0h] [ebp-C8h]
  int v21; // [esp+0h] [ebp-C8h]
  int v22; // [esp+4h] [ebp-C4h]
  int v23; // [esp+4h] [ebp-C4h]
  int v24; // [esp+4h] [ebp-C4h]
  int v25; // [esp+8h] [ebp-C0h]
  int v26; // [esp+8h] [ebp-C0h]
  int v27; // [esp+Ch] [ebp-BCh]
  int v28; // [esp+10h] [ebp-B8h]
  __int64 v29; // [esp+14h] [ebp-B4h]
  char *s; // [esp+1Ch] [ebp-ACh]
  void *dest; // [esp+20h] [ebp-A8h]
  void *ptr; // [esp+24h] [ebp-A4h]
  void *i; // [esp+28h] [ebp-A0h]
  char *j; // [esp+2Ch] [ebp-9Ch]
  char *v35; // [esp+30h] [ebp-98h]
  size_t size; // [esp+34h] [ebp-94h]
  int v37; // [esp+38h] [ebp-90h]
  size_t n; // [esp+3Ch] [ebp-8Ch]
  size_t v39; // [esp+40h] [ebp-88h]
  unsigned int v40; // [esp+44h] [ebp-84h]
  char *v41; // [esp+48h] [ebp-80h]
  int v42; // [esp+4Ch] [ebp-7Ch]
  char *v43; // [esp+50h] [ebp-78h]
  size_t v44; // [esp+54h] [ebp-74h]
  int v45; // [esp+58h] [ebp-70h]
  int v46; // [esp+60h] [ebp-68h]
  int v47; // [esp+70h] [ebp-58h]
  int v48; // [esp+8Ch] [ebp-3Ch]
  int v49; // [esp+D4h] [ebp+Ch]

  ptr = 0;
  size = 0;
  HIDWORD(v29) = 0;
  v40 = a3 & 0xFFFFFFFC;
  *(_DWORD *)((char *)&v29 + 3) = (a3 & 4) != 0;
  v49 = a3 & 3;
  if ( v49 & (v49 - 1) )
  {
    *__errno_location() = 22;
    return 0;
  }
  if ( !src )
  {
    *__errno_location() = 22;
    return 0;
  }
  if ( !*(_BYTE *)src )
  {
    *__errno_location() = 2;
    return 0;
  }
  n = 0;
  if ( *(_BYTE *)src == 47 )
  {
    s = (char *)sub_806210D(0x1000u);
    v35 = s + 4096;
    dest = s;
    if ( n )
    {
      memcpy(s, src, n);
      dest = (char *)dest + n;
    }
    v4 = dest;
    dest = (char *)dest + 1;
    *v4 = 47;
    for ( i = (char *)src + n; ; i = j )
    {
LABEL_67:
      if ( !*(_BYTE *)i )
        goto LABEL_81;
      while ( *(_BYTE *)i == 47 )
        i = (char *)i + 1;
      for ( j = (char *)i; *j && *j != 47; ++j )
        ;
      if ( j == i )
      {
LABEL_81:
        if ( &s[n + 1] < dest && *((char *)dest - 1) == 47 )
          dest = (char *)dest - 1;
        *(_BYTE *)dest = 0;
        if ( (char *)dest + 1 != v35 )
          s = (char *)sub_8062158(s, (_BYTE *)dest - s + 1);
        free(ptr);
        if ( HIDWORD(v29) )
          sub_80585E0(v15, v16, (void *)HIDWORD(v29));
        return s;
      }
      if ( j - (_BYTE *)i != 1 || *(_BYTE *)i != 46 )
      {
        if ( j - (_BYTE *)i == 2 && *(_BYTE *)i == 46 && *((_BYTE *)i + 1) == 46 )
        {
          if ( &s[n + 1] < dest )
          {
            for ( dest = (char *)dest - 1; dest > s && *((char *)dest - 1) != 47; dest = (char *)dest - 1 )
              ;
          }
          continue;
        }
        if ( *((char *)dest - 1) != 47 )
        {
          v5 = dest;
          dest = (char *)dest + 1;
          *v5 = 47;
        }
        if ( (char *)dest + j - (_BYTE *)i >= v35 )
        {
          v42 = (_BYTE *)dest - s;
          v39 = v35 - s;
          if ( j - (_BYTE *)i + 1 <= 4096 )
            v39 += 4096;
          else
            v39 += j - (_BYTE *)i + 1;
          s = (char *)sub_8062158(s, v39);
          v35 = &s[v39];
          dest = &s[v42];
        }
        v6 = (char *)memcpy(dest, i, j - (_BYTE *)i);
        dest = &v6[j - (_BYTE *)i];
        *(_BYTE *)dest = 0;
        if ( BYTE3(v29) && v49 == 2 )
        {
          v47 = 0;
        }
        else
        {
          if ( BYTE3(v29) )
            v7 = sub_80658D5((int)s, (int)&v46) != 0;
          else
            v7 = sub_8065967((int)s, (int)&v46) != 0;
          if ( v7 )
          {
            v37 = *__errno_location();
            if ( !v49 )
              goto LABEL_76;
            if ( v49 == 1 )
            {
              v8 = strspn(j, "/");
              if ( j[v8] || v37 != 2 )
                goto LABEL_76;
              continue;
            }
            v47 = 0;
          }
        }
        v9 = &loc_8056631;
        if ( (v47 & 0xF000) != 40960 )
          v9 = &loc_80568DF;
        dword_8072224 = (int)v9;
        sub_8065C47(
          v19,
          v22,
          v25,
          v27,
          v28,
          v29,
          HIDWORD(v29),
          s,
          dest,
          ptr,
          i,
          j,
          v35,
          size,
          v37,
          n,
          v39,
          v40,
          v41,
          v42,
          v43,
          v44,
          v45);
        if ( (unsigned __int8)sub_8055FA1((int)&v29 + 4, (char *)src, (int)&v46) )
        {
          if ( v49 == 2 )
            continue;
          dword_8072260 = (int)&loc_80569D0;
          a1 = sub_8065ABA(
                 v11,
                 v10,
                 v20,
                 v23,
                 v26,
                 v27,
                 v28,
                 v29,
                 HIDWORD(v29),
                 s,
                 dest,
                 ptr,
                 i,
                 j,
                 v35,
                 size,
                 40,
                 n,
                 v39,
                 v40,
                 v41);
        }
        v12 = sub_80557E2(s, v48);
        v43 = v12;
        v13 = v12 == 0;
        v14 = &loc_80566C7;
        if ( !v13 )
          v14 = &loc_80566F0;
        dword_8072210 = (int)v14;
        a1 = sub_8065CCF(
               v21,
               v24,
               v26,
               v27,
               v28,
               v29,
               HIDWORD(v29),
               s,
               dest,
               ptr,
               i,
               j,
               v35,
               size,
               v37,
               n,
               v39,
               v40,
               v41,
               *(double *)&a1);
        if ( v49 != 2 || *__errno_location() == 12 )
        {
          v37 = *__errno_location();
LABEL_76:
          free(ptr);
          free(s);
          if ( HIDWORD(v29) )
            sub_80585E0(v17, v18, (void *)HIDWORD(v29));
          *__errno_location() = v37;
          return 0;
        }
      }
    }
  }
  s = sub_80624F9();
  if ( s )
  {
    dest = strchr(s, 0);
    if ( (_BYTE *)dest - s > 4095 )
    {
      v35 = (char *)dest;
    }
    else
    {
      v41 = (char *)sub_8062158(s, 0x1000u);
      dest = &v41[(_BYTE *)dest - s];
      s = v41;
      v35 = v41 + 4096;
    }
    i = src;
    n = 0;
    goto LABEL_67;
  }
  return 0;
}
// 80566C2: inconsistent fpu stack
// 805606B: could not find valid save-restore pair for ebx
// 8065ABA: using guessed type double __fastcall sub_8065ABA(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8065C47: using guessed type int __stdcall sub_8065C47(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8065CCF: using guessed type double __userpurge sub_8065CCF@<st0>(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, double@<st0>);
// 8072210: using guessed type int dword_8072210;
// 8072224: using guessed type int dword_8072224;
// 8072260: using guessed type int dword_8072260;

//----- (08056A3C) --------------------------------------------------------
int sub_8056A3C()
{
  bool v0; // zf
  int v1; // ecx
  void *v2; // eax
  int v3; // ebx
  int *v4; // eax
  int *v5; // eax
  int result; // eax
  char *v7; // [esp+2Ch] [ebp-Ch]

  v0 = sub_8064647(stdout) == 0;
  v2 = &loc_8056A6D;
  if ( v0 )
    v2 = &loc_8056B11;
  dword_80721DC = (int)v2;
  sub_8065E0F(v1);
  if ( byte_80737EF != 1 || *__errno_location() != 32 )
  {
    v7 = gettext("write error");
    if ( dword_80737EB )
    {
      v3 = sub_8060D07(dword_80737EB);
      v4 = __errno_location();
      error(0, *v4, "%s: %s", v3, v7);
    }
    else
    {
      v5 = __errno_location();
      error(0, *v5, "%s", v7);
    }
    _exit(status);
  }
  result = sub_8064647(stderr);
  if ( result )
    _exit(status);
  return result;
}
// 8065E0F: using guessed type int __fastcall sub_8065E0F(_DWORD);
// 80721DC: using guessed type int dword_80721DC;
// 80737EB: using guessed type int dword_80737EB;
// 80737EF: using guessed type char byte_80737EF;

//----- (08056B35) --------------------------------------------------------
#error "8056BC5: call analysis failed (funcsize=50)"

//----- (08056BDD) --------------------------------------------------------
void *__cdecl sub_8056BDD(void *src)
{
  size_t v2; // eax
  size_t n; // [esp+18h] [ebp-10h]
  void *dest; // [esp+1Ch] [ebp-Ch]

  n = sub_8056B35(src);
  dest = malloc((n == 0) + n + 1);
  if ( !dest )
    return 0;
  memcpy(dest, src, n);
  if ( n == 0 )
  {
    v2 = n++;
    *((_BYTE *)dest + v2) = 46;
  }
  *((_BYTE *)dest + n) = 0;
  return dest;
}
// 8056B35: using guessed type _DWORD __cdecl sub_8056B35(_DWORD);

//----- (08056C5F) --------------------------------------------------------
#error "8056C73: call analysis failed (funcsize=13)"

//----- (08056C86) --------------------------------------------------------
#error "8056CEA: call analysis failed (funcsize=57)"

//----- (08056D24) --------------------------------------------------------
size_t __cdecl sub_8056D24(char *s)
{
  size_t i; // [esp+18h] [ebp-10h]

  for ( i = strlen(s); i > 1 && s[i - 1] == 47; --i )
    ;
  return i;
}

//----- (08056D62) --------------------------------------------------------
int sub_8056D62()
{
  return 0;
}

//----- (08056D70) --------------------------------------------------------
void __cdecl sub_8056D70(int a1, char *s, int a3)
{
  void *v3; // edx
  void *v4; // edx
  void **v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]

  if ( a1 )
  {
    v5 = (void **)sub_806210D(0x14u);
    *v5 = sub_8062286(s);
    v3 = *(void **)(a3 + 92);
    v5[1] = *(void **)(a3 + 88);
    v5[2] = v3;
    v4 = *(void **)(a3 + 4);
    v5[3] = *(void **)a3;
    v5[4] = v4;
    v6 = sub_805910D(a1, (int)v5);
    if ( !v6 )
      sub_80622AF();
    if ( (void **)v6 != v5 )
      sub_8059673(v5);
  }
}

//----- (08056E22) --------------------------------------------------------
bool __cdecl sub_8056E22(int a1, int a2, int *a3)
{
  int v3; // ecx
  int v4; // edx
  int v5; // edx
  int v7; // [esp+0h] [ebp-38h]
  int v8; // [esp+1Ch] [ebp-1Ch]
  int v9; // [esp+20h] [ebp-18h]
  int v10; // [esp+24h] [ebp-14h]
  int v11; // [esp+28h] [ebp-10h]
  int v12; // [esp+2Ch] [ebp-Ch]

  if ( !a1 )
  {
    dword_80721DC = (int)&locret_8056EA8;
    sub_8065E0F(v3);
  }
  v8 = a2;
  v4 = a3[23];
  v9 = a3[22];
  v10 = v4;
  v5 = a3[1];
  v11 = *a3;
  v12 = v5;
  return sub_8057DFF(a1, &v7 - 7) != 0;
}
// 8057DFF: using guessed type _DWORD __cdecl sub_8057DFF(_DWORD, _DWORD);
// 8065E0F: using guessed type int __fastcall sub_8065E0F(_DWORD);
// 80721DC: using guessed type int dword_80721DC;

//----- (08056EAA) --------------------------------------------------------
#error "8056F65: call analysis failed (funcsize=58)"

//----- (08056F8E) --------------------------------------------------------
#error "805704D: call analysis failed (funcsize=159)"

//----- (08057179) --------------------------------------------------------
int __cdecl sub_8057179(int a1, int a2)
{
  return sub_8056F8E(*(_DWORD *)(a1 + 16), a2);
}
// 8056F8E: using guessed type _DWORD __cdecl sub_8056F8E(_DWORD, _DWORD);

//----- (08057196) --------------------------------------------------------
#error "80571DD: call analysis failed (funcsize=23)"

//----- (080571E2) --------------------------------------------------------
#error "8057204: positive sp value has been found (funcsize=0)"

//----- (08057205) --------------------------------------------------------
_BYTE *__cdecl sub_8057205(_BYTE *a1)
{
  while ( *a1 == 47 )
    ++a1;
  return a1;
}

//----- (08057221) --------------------------------------------------------
void *__cdecl sub_8057221(int a1, _BYTE *a2, _DWORD *a3)
{
  _BOOL4 v3; // eax
  _BYTE *v5; // eax
  signed int v6; // eax
  char *v7; // [esp+10h] [ebp-28h]
  size_t v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  _BOOL4 v10; // [esp+1Ch] [ebp-1Ch]
  char *s; // [esp+20h] [ebp-18h]
  size_t v12; // [esp+24h] [ebp-14h]
  void *v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]

  v7 = (char *)sub_8056C5F(a1);
  v8 = sub_8056D24(v7);
  v9 = (int)&v7[v8 - a1];
  v3 = v8 && v7[v8 - 1] != 47;
  v10 = v3;
  s = sub_8057205(a2);
  v12 = strlen(s);
  v13 = malloc(v10 + v9 + v12 + 1);
  if ( !v13 )
    return 0;
  v5 = (_BYTE *)mempcpy(v13, a1, v9);
  *v5 = 47;
  v14 = (int)&v5[v10];
  if ( a3 )
  {
    if ( *a2 == 47 )
      v6 = -1;
    else
      v6 = 0;
    *a3 = v6 + v14;
  }
  *(_BYTE *)mempcpy(v14, s, v12) = 0;
  return v13;
}
// 80499B0: using guessed type int __cdecl mempcpy(_DWORD, _DWORD, _DWORD);
// 8056C5F: using guessed type int __cdecl sub_8056C5F(_DWORD);

//----- (0805734B) --------------------------------------------------------
#error "8057407: call analysis failed (funcsize=85)"

//----- (08057497) --------------------------------------------------------
int __cdecl sub_8057497(unsigned __int8 a1)
{
  if ( (unsigned __int8)sub_8055E1D(a1) )
    return 0;
  if ( (unsigned __int8)sub_8055D70(a1) )
    return a1;
  if ( a1 == 126 )
    return -1;
  return a1 + 256;
}

//----- (080574EC) --------------------------------------------------------
signed int __cdecl sub_80574EC(int a1, unsigned int a2, int a3, unsigned int a4)
{
  int v4; // eax
  int v5; // ecx
  int v6; // eax
  int v8; // [esp+0h] [ebp-38h]
  int v9; // [esp+0h] [ebp-38h]
  int v10; // [esp+4h] [ebp-34h]
  int v11; // [esp+8h] [ebp-30h]
  int v12; // [esp+Ch] [ebp-2Ch]
  int v13; // [esp+10h] [ebp-28h]
  int v14; // [esp+14h] [ebp-24h]
  unsigned int v15; // [esp+1Ch] [ebp-1Ch]
  unsigned int v16; // [esp+20h] [ebp-18h]
  int v17; // [esp+24h] [ebp-14h]
  int v18; // [esp+28h] [ebp-10h]

  v15 = 0;
  v16 = 0;
  while ( v15 < a2 || v16 < a4 )
  {
    v17 = 0;
    while ( v15 < a2 && (unsigned __int8)sub_8055E1D(*(char *)(a1 + v15)) ^ 1
         || v16 < a4 && (unsigned __int8)sub_8055E1D(*(char *)(a3 + v16)) ^ 1 )
    {
      if ( v15 == a2 )
        v4 = 0;
      else
        v4 = sub_8057497(*(_BYTE *)(a1 + v15));
      v18 = v4;
      if ( v16 == a4 )
        v6 = 0;
      else
        v6 = sub_8057497(*(_BYTE *)(a3 + v16));
      if ( v18 != v6 )
      {
        dword_807224C = (int)&locret_8057708;
        sub_8065B5D(v5, v18 - v6, v8, v10, v11, v12, v13, v14);
      }
      ++v15;
      ++v16;
    }
    while ( *(_BYTE *)(a1 + v15) == 48 )
      ++v15;
    while ( *(_BYTE *)(a3 + v16) == 48 )
      ++v16;
    while ( (unsigned __int8)sub_8055E1D(*(char *)(a1 + v15)) && (unsigned __int8)sub_8055E1D(*(char *)(a3 + v16)) )
    {
      if ( !v17 )
        v17 = *(char *)(a1 + v15) - *(char *)(a3 + v16);
      ++v15;
      ++v16;
    }
    if ( (unsigned __int8)sub_8055E1D(*(char *)(a1 + v15)) )
    {
      dword_8072238 = (int)&locret_8057708;
      sub_8065BD3(v9, v10, v11, v12, v13, v14);
    }
    if ( (unsigned __int8)sub_8055E1D(*(char *)(a3 + v16)) )
      return -1;
    if ( v17 )
      return v17;
  }
  return 0;
}
// 8065BD3: using guessed type int __stdcall sub_8065BD3(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8072238: using guessed type int dword_8072238;
// 807224C: using guessed type int dword_807224C;

//----- (0805770A) --------------------------------------------------------
#error "8057763: call analysis failed (funcsize=32)"

//----- (080579D1) --------------------------------------------------------
struct timespec *__cdecl sub_80579D1(struct timespec *tp)
{
  struct timespec *result; // eax
  int v2; // [esp+0h] [ebp-28h]
  struct timeval tv; // [esp+18h] [ebp-10h]

  result = (struct timespec *)clock_gettime(0, tp);
  if ( result )
  {
    gettimeofday((struct timeval *)&v2 - 2, 0);
    tp->tv_sec = tv.tv_sec;
    result = tp;
    tp->tv_nsec = 1000 * tv.tv_usec;
  }
  return result;
}

//----- (08057A4E) --------------------------------------------------------
#error "8057AB6: call analysis failed (funcsize=35)"

//----- (08057AC5) --------------------------------------------------------
int __cdecl sub_8057AC5(int a1)
{
  return *(_DWORD *)(a1 + 8);
}

//----- (08057AF0) --------------------------------------------------------
int __cdecl sub_8057AF0(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (08057B1B) --------------------------------------------------------
#error "8057B34: call analysis failed (funcsize=16)"

//----- (08057B47) --------------------------------------------------------
#error "8057B58: positive sp value has been found (funcsize=0)"

//----- (08057B67) --------------------------------------------------------
#error "8057BAB: call analysis failed (funcsize=46)"

//----- (08057DAB) --------------------------------------------------------
int __cdecl sub_8057DAB(_DWORD *a1, int a2)
{
  int (__cdecl *v2)(int, int); // eax
  int v4; // [esp+4h] [ebp-24h]
  unsigned int v5; // [esp+1Ch] [ebp-Ch]

  v2 = (int (__cdecl *)(int, int))a1[6];
  v4 = a1[2];
  v5 = v2(a2, v4);
  if ( a1[2] <= v5 )
    abort();
  return 8 * v5 + *a1;
}

//----- (08057DFF) --------------------------------------------------------
#error "8057E47: call analysis failed (funcsize=28)"

//----- (080580CA) --------------------------------------------------------
#error "80580FF: call analysis failed (funcsize=38)"

//----- (08058146) --------------------------------------------------------
int __cdecl sub_8058146(unsigned int a1)
{
  int i; // [esp+Ch] [ebp+8h]

  if ( a1 <= 9 )
    a1 = 10;
  for ( i = a1 | 1; i != -1 && (unsigned __int8)sub_80580CA(i) ^ 1; i += 2 )
    ;
  return i;
}
// 80580CA: using guessed type _DWORD __cdecl sub_80580CA(_DWORD);

//----- (080581DF) --------------------------------------------------------
unsigned int __cdecl sub_80581DF(int a1, unsigned int a2)
{
  return sub_806444A(a1, 3) % a2;
}

//----- (0805820A) --------------------------------------------------------
bool __cdecl sub_805820A(int a1, int a2)
{
  return a1 == a2;
}

//----- (08058218) --------------------------------------------------------
signed int __cdecl sub_8058218(int a1)
{
  int v2; // [esp+8h] [ebp-8h]

  v2 = *(_DWORD *)(a1 + 20);
  if ( (_UNKNOWN *)v2 == &unk_806A698 )
    return 1;
  if ( *(float *)(v2 + 8) > 0.1
    && 1.0 - 0.1 > *(float *)(v2 + 8)
    && *(float *)(v2 + 12) > 0.1 + 1.0
    && *(float *)v2 >= 0.0
    && *(float *)(v2 + 4) > *(float *)v2 + 0.1
    && *(float *)(v2 + 4) <= 1.0
    && *(float *)(v2 + 8) > *(float *)v2 + 0.1 )
  {
    return 1;
  }
  *(_DWORD *)(a1 + 20) = &unk_806A698;
  return 0;
}

//----- (080582D8) --------------------------------------------------------
unsigned int __cdecl sub_80582D8(unsigned int a1, int a2)
{
  unsigned int result; // eax
  float v3; // [esp+20h] [ebp-4h]
  unsigned int v4; // [esp+2Ch] [ebp+8h]

  if ( *(_BYTE *)(a2 + 16) != 1 )
  {
    v3 = (long double)a1 / *(float *)(a2 + 8);
    if ( v3 >= 4294967300.0 )
      return 0;
    a1 = (signed __int64)v3;
  }
  v4 = sub_8058146(a1);
  if ( v4 <= 0x1FFFFFFF )
    result = v4;
  else
    result = 0;
  return result;
}

//----- (080583AD) --------------------------------------------------------
size_t *__cdecl sub_80583AD(unsigned int a1, void *a2, unsigned int (__cdecl *a3)(int a1, unsigned int a2), bool (__cdecl *a4)(int a1, int a2), size_t a5)
{
  size_t *result; // eax
  unsigned __int8 v6; // al
  size_t *ptr; // [esp+1Ch] [ebp-Ch]

  if ( !a3 )
    a3 = sub_80581DF;
  if ( !a4 )
    a4 = sub_805820A;
  ptr = (size_t *)malloc(0x28u);
  if ( !ptr )
    return 0;
  if ( !a2 )
    a2 = &unk_806A698;
  ptr[5] = (size_t)a2;
  sub_8058218(ptr);
  if ( !(v6 ^ 1) && (ptr[2] = sub_80582D8(a1, (int)a2)) != 0 && (*ptr = (size_t)calloc(ptr[2], 8u)) != 0 )
  {
    ptr[1] = 8 * ptr[2] + *ptr;
    ptr[3] = 0;
    ptr[4] = 0;
    ptr[6] = (size_t)a3;
    ptr[7] = (size_t)a4;
    ptr[8] = a5;
    ptr[9] = 0;
    result = ptr;
  }
  else
  {
    free(ptr);
    result = 0;
  }
  return result;
}
// 8058218: using guessed type double __cdecl sub_8058218(_DWORD);

//----- (080585E0) --------------------------------------------------------
void __usercall sub_80585E0(int a1@<edx>, int a2@<ecx>, void *a3)
{
  void (*v3)(void); // eax
  int v4; // [esp+0h] [ebp-28h]
  int v5; // [esp+4h] [ebp-24h]
  int v6; // [esp+8h] [ebp-20h]
  int v7; // [esp+Ch] [ebp-1Ch]
  int v8; // [esp+10h] [ebp-18h]
  void **i; // [esp+14h] [ebp-14h]
  void *ptr; // [esp+18h] [ebp-10h]
  void *v11; // [esp+1Ch] [ebp-Ch]

  if ( *((_DWORD *)a3 + 8) && *((_DWORD *)a3 + 4) )
  {
    for ( i = *(void ***)a3; *((_DWORD *)a3 + 1) > (unsigned int)i; i += 2 )
    {
      if ( *i )
      {
        for ( ptr = i; ptr; ptr = (void *)*((_DWORD *)ptr + 1) )
        {
          v3 = (void (*)(void))*((_DWORD *)a3 + 8);
          v4 = *(_DWORD *)ptr;
          v3();
        }
      }
    }
  }
  for ( i = *(void ***)a3; *((_DWORD *)a3 + 1) > (unsigned int)i; i += 2 )
  {
    ptr = i[1];
    dword_807224C = (int)&loc_805868B;
    sub_8065B5D(a2, a1, v4, v5, v6, v7, v8, i);
    do
    {
      v11 = (void *)*((_DWORD *)ptr + 1);
      free(ptr);
      ptr = v11;
    }
    while ( v11 );
  }
  for ( ptr = (void *)*((_DWORD *)a3 + 9); ptr; ptr = v11 )
  {
    v11 = (void *)*((_DWORD *)ptr + 1);
    free(ptr);
  }
  free(*(void **)a3);
  free(a3);
}
// 807224C: using guessed type int dword_807224C;

//----- (080586E5) --------------------------------------------------------
#error "8058719: call analysis failed (funcsize=31)"

//----- (0805874D) --------------------------------------------------------
__int64 __cdecl sub_805874D(__int64 a1)
{
  __int64 result; // rax

  *(_DWORD *)HIDWORD(a1) = 0;
  *(_DWORD *)(HIDWORD(a1) + 4) = *(_DWORD *)(a1 + 36);
  result = a1;
  *(_DWORD *)(a1 + 36) = HIDWORD(a1);
  return result;
}

//----- (08058790) --------------------------------------------------------
int __cdecl sub_8058790(_DWORD *a1, int a2, _DWORD *a3, char a4)
{
  _DWORD *v4; // eax
  int v5; // ecx
  _DWORD *v6; // edx
  bool v7; // zf
  void *v8; // eax
  int v10; // [esp+0h] [ebp-38h]
  int v11; // [esp+4h] [ebp-34h]
  int v12; // [esp+8h] [ebp-30h]
  _DWORD v13[3]; // [esp+Ch] [ebp-2Ch]
  int v14; // [esp+10h] [ebp-28h]
  int v15; // [esp+14h] [ebp-24h]

  LOBYTE(v13[0]) = a4;
  v4 = (_DWORD *)sub_8057DAB(a1, a2);
  v6 = v4;
  *a3 = v4;
  v7 = *v4 == 0;
  v8 = &loc_805881B;
  if ( !v7 )
    v8 = &loc_8058825;
  dword_807224C = (int)v8;
  sub_8065B5D(v5, v6, v10, v11, v12, v13[0], v14, v15);
  return 0;
}
// 807224C: using guessed type int dword_807224C;

//----- (080589CD) --------------------------------------------------------
signed int __cdecl sub_80589CD(_DWORD *a1, int a2, char a3)
{
  int *i; // [esp+18h] [ebp-20h]
  int *j; // [esp+1Ch] [ebp-1Ch]
  int v6; // [esp+20h] [ebp-18h]
  int v7; // [esp+20h] [ebp-18h]
  int *v8; // [esp+24h] [ebp-14h]
  int *v9; // [esp+24h] [ebp-14h]
  int *v10; // [esp+28h] [ebp-10h]
  int *v11; // [esp+2Ch] [ebp-Ch]

  for ( i = *(int **)a2; *(_DWORD *)(a2 + 4) > (unsigned int)i; i += 2 )
  {
    if ( *i )
    {
      for ( j = (int *)i[1]; j; j = v10 )
      {
        v6 = *j;
        v8 = (int *)sub_8057DAB(a1, *j);
        v10 = (int *)j[1];
        if ( *v8 )
        {
          j[1] = v8[1];
          v8[1] = (int)j;
        }
        else
        {
          *v8 = v6;
          ++a1[3];
          sub_805874D(__PAIR__((unsigned int)j, (unsigned int)a1));
        }
      }
      v7 = *i;
      i[1] = 0;
      if ( !a3 )
      {
        v9 = (int *)sub_8057DAB(a1, v7);
        if ( *v9 )
        {
          v11 = (int *)sub_80586E5(a1);
          if ( !v11 )
            return 0;
          *v11 = v7;
          v11[1] = v9[1];
          v9[1] = (int)v11;
        }
        else
        {
          *v9 = v7;
          ++a1[3];
        }
        *i = 0;
        --*(_DWORD *)(a2 + 12);
      }
    }
  }
  return 1;
}
// 80586E5: using guessed type _DWORD __cdecl sub_80586E5(_DWORD);

//----- (08058B72) --------------------------------------------------------
#error "8058C7B: call analysis failed (funcsize=80)"

//----- (08058D90) --------------------------------------------------------
#error "805907F: call analysis failed (funcsize=233)"

//----- (0805910D) --------------------------------------------------------
int __cdecl sub_805910D(int a1, int a2)
{
  int v2; // eax
  int v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]

  sub_8058D90(a1, a2, &v4);
  v5 = v2;
  if ( v2 == -1 )
    return 0;
  if ( v5 )
    return a2;
  return v4;
}
// 8058D90: using guessed type double __cdecl sub_8058D90(_DWORD, _DWORD, _DWORD);

//----- (08059150) --------------------------------------------------------
int __cdecl sub_8059150(int a1, int a2)
{
  void *v2; // eax
  long double v4; // fst7
  long double v5; // fst6
  long double v6; // fst7
  long double v7; // fst6
  long double v8; // fst7
  __int16 v9; // ax
  int v10; // edx
  unsigned __int8 v11; // al
  void *ptr; // [esp+0h] [ebp-4Ch]
  int v13; // [esp+8h] [ebp-44h]
  int v14; // [esp+28h] [ebp-24h]

  sub_8058790(&v14, a2, &v14, 1);
  *(&ptr - 6) = v2;
  if ( !*(&ptr - 6) )
    return 0;
  --*(_DWORD *)(v13 + 16);
  if ( !*(_DWORD *)*(&ptr - 8) )
  {
    *(&ptr - 12) = (void *)--*(_DWORD *)(v13 + 12);
    *(&ptr - 11) = 0;
    v4 = (long double)*((signed __int64 *)&ptr - 6);
    v5 = **(float **)(v13 + 20);
    *(&ptr - 12) = *(void **)(v13 + 8);
    *(&ptr - 11) = 0;
    if ( v5 * (long double)*((signed __int64 *)&ptr - 6) > v4 )
    {
      sub_8058218(v13);
      *(&ptr - 12) = *(void **)(v13 + 12);
      *(&ptr - 11) = 0;
      v6 = (long double)*((signed __int64 *)&ptr - 6);
      v7 = **(float **)(v13 + 20);
      *(&ptr - 12) = *(void **)(v13 + 8);
      *(&ptr - 11) = 0;
      if ( v7 * (long double)*((signed __int64 *)&ptr - 6) > v6 )
      {
        *(&ptr - 5) = *(void **)(v13 + 20);
        if ( *((_BYTE *)*(&ptr - 5) + 16) )
        {
          *(&ptr - 12) = *(void **)(v13 + 8);
          *(&ptr - 11) = 0;
          v8 = (long double)*((signed __int64 *)&ptr - 6) * *((float *)*(&ptr - 5) + 1);
        }
        else
        {
          *(&ptr - 12) = *(void **)(v13 + 8);
          *(&ptr - 11) = 0;
          v8 = (long double)*((signed __int64 *)&ptr - 6) * *((float *)*(&ptr - 5) + 1) * *((float *)*(&ptr - 5) + 2);
        }
        v9 = *((_WORD *)&ptr - 25);
        HIBYTE(v9) = 12;
        *((_WORD *)&ptr - 26) = v9;
        *((_QWORD *)&ptr - 6) = (signed __int64)v8;
        v10 = (int)*(&ptr - 11);
        *(&ptr - 4) = *(&ptr - 12);
        sub_8058B72(v13, *(&ptr - 4));
        if ( v11 ^ 1 )
        {
          for ( *(&ptr - 7) = *(void **)(v13 + 36); *(&ptr - 7); *(&ptr - 7) = *(&ptr - 3) )
          {
            *(&ptr - 3) = (void *)*((_DWORD *)*(&ptr - 7) + 1);
            free(*(&ptr - 7));
          }
          *(_DWORD *)(v13 + 36) = 0;
        }
      }
    }
  }
  return (int)*(&ptr - 6);
}
// 8058218: using guessed type double __cdecl sub_8058218(_DWORD);
// 8058790: using guessed type double __cdecl sub_8058790(_DWORD, _DWORD, _DWORD, _DWORD);
// 8058B72: using guessed type double __cdecl sub_8058B72(_DWORD, _DWORD);

//----- (080593CC) --------------------------------------------------------
int __cdecl sub_80593CC(int a1, unsigned int a2)
{
  int v2; // eax

  v2 = sub_806472B(*(_BYTE **)a1, a2);
  return sub_8065666(__PAIR__(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 4) ^ (unsigned int)v2), a2);
}

//----- (080595B3) --------------------------------------------------------
int __cdecl sub_80595B3(int a1, int a2)
{
  int v2; // ebx

  v2 = *(_DWORD *)(a1 + 8);
  return *(_QWORD *)(a1 + 4) == *(_QWORD *)(a2 + 4)
      && __PAIR__(*(_DWORD *)(a1 + 12), *(_DWORD *)(a2 + 16)) == __PAIR__(*(_DWORD *)(a2 + 12), *(_DWORD *)(a1 + 16))
      && !strcmp(*(const char **)a1, *(const char **)a2);
}

//----- (08059673) --------------------------------------------------------
void __cdecl sub_8059673(void **a1)
{
  free(*a1);
  free(a1);
}

//----- (0805969D) --------------------------------------------------------
#error "8059793: call analysis failed (funcsize=116)"

//----- (08059819) --------------------------------------------------------
void *__cdecl sub_8059819(int a1, size_t n, int a3, int a4)
{
  char *i; // ebx
  const char *v5; // eax
  void *v6; // ebx
  const char *v8; // [esp+0h] [ebp-68h]
  size_t v9; // [esp+8h] [ebp-60h]
  size_t v10; // [esp+Ch] [ebp-5Ch]
  char *s; // [esp+14h] [ebp-54h]
  int v12; // [esp+18h] [ebp-50h]
  void *src; // [esp+1Ch] [ebp-4Ch]

  src = (void *)a1;
  v12 = a3;
  s = (char *)a4;
  *(&v8 - 3) = (const char *)__readgsdword(0x14u);
  *(&v8 - 17) = (const char *)-1;
  v8 = *(&v8 - 21);
  *(&v8 - 15) = (const char *)strlen(v8);
  *(&v8 - 16) = (const char *)v10;
  v9 = v10;
  memcpy((char *)&v8 - 53, *(&v8 - 19), v10);
  for ( i = (char *)&(*(&v8 - 19))[v10]; ; memcpy(i, *(&v8 - 21), (size_t)*(&v8 - 15)) )
  {
    *((_BYTE *)&v8 - 69) = **(&v8 - 20);
    if ( *((_BYTE *)&v8 - 69) )
    {
      if ( *((_BYTE *)&v8 - 69) > 0x7Eu )
        v5 = *(&v8 - 16);
      else
        v5 = (const char *)*((unsigned __int8 *)&v8 - 69);
      *(&v8 - 17) = v5;
      ++*(&v8 - 20);
    }
    if ( *(&v8 - 16) < *(&v8 - 17) )
      *(&v8 - 17) = *(&v8 - 16);
    v6 = (void *)(i - *(&v8 - 17));
    *(&v8 - 16) -= (signed int)*(&v8 - 17);
    memcpy(v6, (char *)&v8 + (_DWORD)*(&v8 - 16) - 53, (size_t)*(&v8 - 17));
    if ( !*(&v8 - 16) )
      break;
    i = (char *)((_BYTE *)v6 - *(&v8 - 15));
  }
  return v6;
}

//----- (08059958) --------------------------------------------------------
#error "805A63C: call analysis failed (funcsize=765)"

//----- (0805A897) --------------------------------------------------------
signed __int64 sub_805A897()
{
  signed __int64 result; // rax

  if ( getenv("POSIXLY_CORRECT") )
    result = 512LL;
  else
    result = 1024LL;
  return result;
}

//----- (0805A8E5) --------------------------------------------------------
#error "805A93D: call analysis failed (funcsize=81)"

//----- (0805AA8D) --------------------------------------------------------
int __usercall sub_805AA8D@<eax>(long double a1@<st0>, char *s, int a3, int a4)
{
  signed __int64 v4; // rax
  _DWORD *v5; // ecx
  int v7; // [esp+0h] [ebp-28h]
  _DWORD *v8; // [esp+10h] [ebp-18h]
  int v9; // [esp+1Ch] [ebp-Ch]

  v9 = sub_805A8E5(a1, s, a4, a3);
  if ( !*(_QWORD *)a4 )
  {
    v4 = sub_805A897();
    v5 = v8;
    *v8 = v4;
    v5[1] = HIDWORD(v4);
    *(&v7 - 3) = 4;
  }
  return *(&v7 - 3);
}

//----- (0805AAF6) --------------------------------------------------------
#error "805AC00: call analysis failed (funcsize=80)"

//----- (0805AD6B) --------------------------------------------------------
char *__cdecl sub_805AD6B(__gid_t gid)
{
  const char *v1; // eax
  char *s; // ST1C_4
  size_t v3; // eax
  char *result; // eax
  char *i; // [esp+10h] [ebp-18h]
  char *v6; // [esp+14h] [ebp-14h]
  struct group *v7; // [esp+18h] [ebp-10h]

  v6 = 0;
  for ( i = (char *)dword_80737FB; i; i = (char *)*((_DWORD *)i + 1) )
  {
    if ( *(_DWORD *)i == gid )
    {
      v6 = i;
      break;
    }
  }
  if ( !v6 )
  {
    v7 = getgrgid(gid);
    if ( v7 )
      v1 = v7->gr_name;
    else
      v1 = (const char *)&unk_806A7FC;
    s = (char *)v1;
    v3 = strlen(v1);
    v6 = (char *)sub_806210D((v3 + 16) & 0xFFFFFFF8);
    *(_DWORD *)v6 = gid;
    strcpy(v6 + 8, s);
    *((_DWORD *)v6 + 1) = dword_80737FB;
    dword_80737FB = (int)v6;
  }
  if ( v6[8] )
    result = v6 + 8;
  else
    result = 0;
  return result;
}
// 80737FB: using guessed type int dword_80737FB;

//----- (0805AF7B) --------------------------------------------------------
int __cdecl sub_805AF7B(__int64 a1, int a2)
{
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 v5; // [esp+18h] [ebp-20h]
  int v6; // [esp+2Ch] [ebp-Ch]

  v5 = a1;
  v6 = a2 + 20;
  *(_BYTE *)(a2 + 20) = 0;
  if ( a1 >= 0 )
  {
    do
    {
      *(_BYTE *)--v6 = sub_8065237(v5, 10LL) + 48;
      LODWORD(v3) = sub_8065051(v5, HIDWORD(v5), 10, 0);
      v5 = v3;
    }
    while ( v3 );
  }
  else
  {
    do
    {
      *(_BYTE *)--v6 = 48 - sub_8065237(v5, 10LL);
      LODWORD(v2) = sub_8065051(v5, HIDWORD(v5), 10, 0);
      v5 = v2;
    }
    while ( v2 );
    *(_BYTE *)--v6 = 45;
  }
  return v6;
}
// 8065051: using guessed type _DWORD __cdecl sub_8065051(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0805B0E9) --------------------------------------------------------
#error "805B178: call analysis failed (funcsize=42)"

//----- (0805B17D) --------------------------------------------------------
#error "805B1AF: positive sp value has been found (funcsize=0)"

//----- (0805B1B0) --------------------------------------------------------
int __cdecl sub_805B1B0(wint_t *a1)
{
  unsigned __int8 v2; // [esp+1Bh] [ebp-Dh]
  wint_t *i; // [esp+1Ch] [ebp-Ch]

  v2 = 0;
  for ( i = a1; *i; ++i )
  {
    if ( !iswprint(*i) )
    {
      *i = 65533;
      v2 = 1;
    }
  }
  return v2;
}

//----- (0805B203) --------------------------------------------------------
int __cdecl sub_805B203(_DWORD *a1, unsigned int a2)
{
  int v3; // [esp+18h] [ebp-10h]
  int v4; // [esp+1Ch] [ebp-Ch]

  v3 = 0;
  while ( *a1 )
  {
    v4 = wcwidth(*a1);
    if ( v4 == -1 )
    {
      *a1 = 65533;
      v4 = 1;
    }
    if ( v4 + v3 > a2 )
      break;
    v3 += v4;
    ++a1;
  }
  *a1 = 0;
  return v3;
}
// 8049560: using guessed type int __cdecl wcwidth(_DWORD);

//----- (0805B281) --------------------------------------------------------
#error "805B292: call analysis failed (funcsize=32)"

//----- (0805B2D5) --------------------------------------------------------
int __usercall sub_805B2D5@<eax>(long double a1@<st0>, char *s, int a3, int a4, int a5, int a6, int a7)
{
  void *v7; // eax
  wchar_t *v8; // eax
  bool v9; // zf
  void *v10; // eax
  void *v11; // eax
  int v12; // eax
  _BYTE *v13; // eax
  unsigned int v14; // eax
  int v16; // [esp+0h] [ebp-58h]
  int v17; // [esp+0h] [ebp-58h]
  int v18; // [esp+0h] [ebp-58h]
  int v19; // [esp+4h] [ebp-54h]
  int v20; // [esp+4h] [ebp-54h]
  int v21; // [esp+8h] [ebp-50h]
  int v22; // [esp+8h] [ebp-50h]
  int v23; // [esp+Ch] [ebp-4Ch]
  int v24; // [esp+10h] [ebp-48h]
  int v25; // [esp+14h] [ebp-44h]
  int v26; // [esp+18h] [ebp-40h]
  int v27; // [esp+1Ch] [ebp-3Ch]
  size_t size; // [esp+20h] [ebp-38h]
  char *v29; // [esp+24h] [ebp-34h]
  wchar_t *pwcs; // [esp+28h] [ebp-30h]
  char *v31; // [esp+2Ch] [ebp-2Ch]
  int v32; // [esp+2Ch] [ebp-2Ch]
  unsigned int v33; // [esp+30h] [ebp-28h]
  int v34; // [esp+34h] [ebp-24h]
  unsigned int v35; // [esp+34h] [ebp-24h]
  int v36; // [esp+38h] [ebp-20h]
  unsigned int v37; // [esp+38h] [ebp-20h]
  int v38; // [esp+3Ch] [ebp-1Ch]
  int v39; // [esp+3Ch] [ebp-1Ch]
  int v40; // [esp+40h] [ebp-18h]
  int v41; // [esp+40h] [ebp-18h]
  size_t n; // [esp+44h] [ebp-14h]
  size_t na; // [esp+44h] [ebp-14h]
  int v44; // [esp+48h] [ebp-10h]
  unsigned int v45; // [esp+48h] [ebp-10h]
  unsigned int v46; // [esp+4Ch] [ebp-Ch]
  int v47; // [esp+64h] [ebp+Ch]
  _BYTE *v48; // [esp+64h] [ebp+Ch]

  v27 = -1;
  size = strlen(s) + 1;
  v29 = 0;
  pwcs = 0;
  v31 = s;
  v33 = size - 1;
  v34 = size - 1;
  v36 = 0;
  HIWORD(v26) = 0;
  if ( a7 & 2 || __ctype_get_mb_cur_max() <= 1 )
  {
LABEL_10:
    if ( *(_DWORD *)a5 < v33 )
    {
      v33 = *(_DWORD *)a5;
      v34 = *(_DWORD *)a5;
    }
    if ( *(_DWORD *)a5 > v33 )
      v36 = *(_DWORD *)a5 - v33;
    *(_DWORD *)a5 = v33;
    v11 = &loc_805B5D4;
    if ( !a6 )
      v11 = &loc_805B5DB;
    dword_8072210 = (int)v11;
    sub_8065CCF(
      v16,
      v19,
      v21,
      v23,
      v24,
      v25,
      v26,
      v27,
      size,
      v29,
      pwcs,
      v31,
      v33,
      v34,
      v36,
      v38,
      v40,
      n,
      v44,
      *(double *)&a1);
    if ( v12 == 1 )
    {
      v39 = v37;
      v41 = 0;
    }
    else
    {
      v39 = (v37 >> 1) + (v37 & 1);
      v41 = v37 >> 1;
    }
    if ( a7 & 4 )
      v39 = 0;
    if ( a7 & 8 )
      v41 = 0;
    if ( a4 )
    {
      v45 = a4 - 1 + a3;
      v13 = sub_805B281((_BYTE *)a3, v45, v39);
      v47 = (int)v13;
      v46 = v45 - (_DWORD)v13;
      v14 = v35;
      if ( v46 <= v35 )
        v14 = v46;
      v48 = (_BYTE *)mempcpy(v47, v32, v14);
      sub_805B281(v48, v45, v41);
    }
    v27 = v41 + v39 + v35;
    goto LABEL_28;
  }
  na = mbstowcs(0, s, 0);
  if ( na == -1 )
  {
    v7 = &loc_805B3B8;
    if ( !(a7 & 1) )
      v7 = &loc_805B3BD;
    dword_8072210 = (int)v7;
    a1 = sub_8065CCF(
           v17,
           v20,
           v22,
           v23,
           v24,
           v25,
           v26,
           -1,
           size,
           0,
           0,
           s,
           v33,
           v34,
           0,
           v38,
           v40,
           -1,
           v44,
           *(double *)&a1);
    goto LABEL_10;
  }
  n = na + 1;
  v8 = (wchar_t *)malloc(4 * n);
  pwcs = v8;
  v9 = v8 == 0;
  v10 = &loc_805B406;
  if ( !v9 )
    v10 = &loc_805B41A;
  dword_8072238 = (int)v10;
  sub_8065BD3(v18, v20, v22, v23, v24, v25);
  if ( a7 & 1 )
    goto LABEL_10;
LABEL_28:
  free(pwcs);
  free(v29);
  return v27;
}
// 805B3B3: inconsistent fpu stack
// 805B5CF: inconsistent fpu stack
// 805B2D5: could not find valid save-restore pair for ebx
// 80499B0: using guessed type int __cdecl mempcpy(_DWORD, _DWORD, _DWORD);
// 8065BD3: using guessed type int __stdcall sub_8065BD3(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8065CCF: using guessed type double __userpurge sub_8065CCF@<st0>(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, double@<st0>);
// 8072210: using guessed type int dword_8072210;
// 8072238: using guessed type int dword_8072238;
// 807224C: using guessed type int dword_807224C;

//----- (0805B80E) --------------------------------------------------------
int __cdecl sub_805B80E(char *s, int a2)
{
  int v2; // ST04_4

  v2 = strlen(s);
  return sub_805B867((char *)a2, v2, a2);
}

//----- (0805B867) --------------------------------------------------------
int __cdecl sub_805B867(char *a1, int a2, char a3)
{
  signed int v3; // eax
  void *v5; // eax
  char *v6; // eax
  int v7; // eax
  void *v8; // eax
  int v9; // [esp-4h] [ebp-5Ch]
  int v10; // [esp+0h] [ebp-58h]
  char *v11; // [esp+4h] [ebp-54h]
  int v12; // [esp+8h] [ebp-50h]
  int *v13; // [esp+Ch] [ebp-4Ch]
  int v14; // [esp+10h] [ebp-48h]
  int v15; // [esp+14h] [ebp-44h]
  int v16; // [esp+18h] [ebp-40h]
  char *v17; // [esp+1Ch] [ebp-3Ch]
  int v18; // [esp+20h] [ebp-38h]
  int v19; // [esp+24h] [ebp-34h]
  int v20; // [esp+28h] [ebp-30h]
  wint_t wc; // [esp+2Ch] [ebp-2Ch]
  char *v22; // [esp+30h] [ebp-28h]
  int v23; // [esp+34h] [ebp-24h]
  int v24; // [esp+38h] [ebp-20h]
  char *v25; // [esp+3Ch] [ebp-1Ch]
  int v26; // [esp+40h] [ebp-18h]
  char s; // [esp+44h] [ebp-14h]
  int v28; // [esp+48h] [ebp-10h]
  unsigned int v29; // [esp+4Ch] [ebp-Ch]
  int v30; // [esp+50h] [ebp-8h]
  int v31; // [esp+54h] [ebp-4h]
  int savedregs; // [esp+58h] [ebp+0h]

  v17 = a1;
  v29 = __readgsdword(0x14u);
  v22 = a1;
  v25 = &a1[a2];
  v23 = 0;
  if ( __ctype_get_mb_cur_max() <= 1 )
  {
    while ( 1 )
    {
      if ( v22 >= v25 )
        return v23;
      v6 = v22++;
      HIBYTE(v20) = *v6;
      v7 = (*__ctype_b_loc())[HIBYTE(v20)] & 0x4000;
      if ( v7 )
        break;
      if ( a3 & 2 )
        return -1;
      if ( !((*__ctype_b_loc())[HIBYTE(v20)] & 2) )
      {
        if ( v23 == 0x7FFFFFFF )
          return 0x7FFFFFFF;
        ++v23;
      }
    }
    v9 = v7;
    v8 = &loc_805BAC6;
    if ( v23 != 0x7FFFFFFF )
      v8 = &loc_805BAC8;
    dword_8072224 = (int)v8;
    sub_8065C47(
      v10,
      v11,
      v12,
      v13,
      v14,
      v15,
      v16,
      v17,
      v18,
      v19,
      v20,
      wc,
      v22,
      v23,
      v24,
      v25,
      v26,
      *(_DWORD *)&s,
      v28,
      v29,
      v30,
      v31,
      savedregs);
    return 0x7FFFFFFF;
  }
  while ( 1 )
  {
LABEL_31:
    if ( v22 >= v25 )
      return v23;
    v3 = *v22;
    if ( v3 > 63 )
      break;
    if ( v3 < 37 && (unsigned int)(v3 - 32) > 3 )
      goto LABEL_11;
LABEL_10:
    ++v22;
    ++v23;
  }
  if ( v3 >= 65 && (v3 <= 95 || (unsigned int)(v3 - 97) <= 0x1D) )
    goto LABEL_10;
LABEL_11:
  memset(&s, 0, 8u);
  while ( 1 )
  {
    v13 = &v10 - 5;
    v12 = v25 - v22;
    v11 = v22;
    v24 = sub_806330A(&v10 - 11);
    if ( v24 == -1 )
      break;
    if ( v24 == -2 )
    {
      v9 = a3 & 1;
      v5 = &loc_805B9BA;
      if ( a3 & 1 )
        v5 = &loc_805B9C9;
      dword_8072238 = (int)v5;
      sub_8065BD3(v10, v11, v12, v13, v14, v15);
      v22 = v25;
      ++v23;
      goto LABEL_31;
    }
    if ( !v24 )
      v24 = 1;
    v26 = wcwidth(wc);
    if ( v26 < 0 )
    {
      if ( a3 & 2 )
        return -1;
      if ( !iswcntrl(wc) )
      {
        if ( v23 == 0x7FFFFFFF )
          return 0x7FFFFFFF;
        ++v23;
      }
    }
    else
    {
      if ( 0x7FFFFFFF - v23 < v26 )
        return 0x7FFFFFFF;
      v23 += v26;
    }
    v22 += v24;
    if ( mbsinit((const mbstate_t *)&s) )
      goto LABEL_31;
  }
  if ( !(a3 & 1) )
  {
    ++v22;
    ++v23;
    goto LABEL_31;
  }
  return -1;
}
// 8049560: using guessed type int __cdecl wcwidth(_DWORD);
// 806330A: using guessed type _DWORD __cdecl sub_806330A(_DWORD);
// 8065BD3: using guessed type int __stdcall sub_8065BD3(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8065C47: using guessed type int __stdcall sub_8065C47(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8072224: using guessed type int dword_8072224;
// 8072238: using guessed type int dword_8072238;

//----- (0805BB47) --------------------------------------------------------
void *__usercall sub_805BB47@<eax>(long double fst7_0@<st0>, int a1, int a2, void *dest, int a4)
{
  _DWORD *v5; // eax
  _DWORD *v6; // eax
  unsigned int v8; // [esp+10h] [ebp-28h]
  unsigned int v9; // [esp+14h] [ebp-24h]
  unsigned int v10; // [esp+18h] [ebp-20h]
  int v11; // [esp+1Ch] [ebp-1Ch]
  int v12; // [esp+20h] [ebp-18h]
  int v13; // [esp+24h] [ebp-14h]
  int v14; // [esp+28h] [ebp-10h]
  int v15; // [esp+2Ch] [ebp-Ch]

  v13 = (unsigned int)a2 >> 1;
  v14 = a2 - ((unsigned int)a2 >> 1);
  v8 = 0;
  v9 = (unsigned int)a2 >> 1;
  v10 = (unsigned int)a2 >> 1;
  v15 = a2;
  sub_805BD11(fst7_0, a1 + 4 * ((unsigned int)a2 >> 1), v14, dest, a4);
  sub_805BD11(fst7_0, a1, (unsigned int)a2 >> 1, dest, a4);
  v11 = *(_DWORD *)a1;
  v12 = *(_DWORD *)(4 * ((unsigned int)a2 >> 1) + a1);
  while ( 1 )
  {
    while ( ((int (__cdecl *)(int, int))a4)(v11, v12) > 0 )
    {
      v6 = dest;
      dest = (char *)dest + 4;
      *v6 = v12;
      if ( ++v10 == v15 )
        return memcpy(dest, (const void *)(4 * v8 + a1), 4 * (v9 - v8));
      v12 = *(_DWORD *)(4 * v10 + a1);
    }
    v5 = dest;
    dest = (char *)dest + 4;
    *v5 = v11;
    if ( ++v8 == v9 )
      break;
    v11 = *(_DWORD *)(4 * v8 + a1);
  }
  v8 = v10;
  v9 = v15;
  return memcpy(dest, (const void *)(4 * v8 + a1), 4 * (v9 - v8));
}

//----- (0805BD11) --------------------------------------------------------
void __usercall sub_805BD11(long double a1@<st0>, int a2, int a3, void *dest, int a5)
{
  int v5; // ecx
  int v6; // eax
  int v7; // eax
  int v8; // [esp+0h] [ebp-48h]
  int v9; // [esp+4h] [ebp-44h]
  int v10; // [esp+8h] [ebp-40h]
  int v11; // [esp+Ch] [ebp-3Ch]
  int v12; // [esp+10h] [ebp-38h]
  int v13; // [esp+14h] [ebp-34h]
  int v14; // [esp+18h] [ebp-30h]
  unsigned int v15; // [esp+1Ch] [ebp-2Ch]
  int v16; // [esp+20h] [ebp-28h]
  int v17; // [esp+24h] [ebp-24h]
  int v18; // [esp+28h] [ebp-20h]
  int v19; // [esp+2Ch] [ebp-1Ch]
  int v20; // [esp+30h] [ebp-18h]
  int v21; // [esp+34h] [ebp-14h]
  unsigned int v22; // [esp+38h] [ebp-10h]
  int v23; // [esp+3Ch] [ebp-Ch]
  int v24; // [esp+40h] [ebp-8h]
  int v25; // [esp+44h] [ebp-4h]
  int savedregs; // [esp+48h] [ebp+0h]

  if ( (unsigned int)a3 > 2 )
  {
    v20 = (unsigned int)a3 >> 1;
    v21 = a3 - ((unsigned int)a3 >> 1);
    v14 = 0;
    v22 = (unsigned int)a3 >> 1;
    v15 = (unsigned int)a3 >> 1;
    v23 = a3;
    sub_805BD11(a1, a2 + 4 * ((unsigned int)a3 >> 1), v21, dest, a5);
    if ( (unsigned int)a3 >> 1 > 1 )
      sub_805BB47(a1, a2, v20, dest, a5);
    else
      *(_DWORD *)dest = *(_DWORD *)a2;
    v17 = *((_DWORD *)dest + v14);
    v16 = *(_DWORD *)(4 * v15 + a2);
    v13 = 0;
    while ( 1 )
    {
      while ( ((int (__cdecl *)(int, int))a5)(v17, v16) > 0 )
      {
        v7 = v13++;
        *(_DWORD *)(a2 + 4 * v7) = v16;
        if ( ++v15 == v23 )
        {
          memcpy((void *)(4 * v13 + a2), (char *)dest + 4 * v14, 4 * (v22 - v14));
          dword_8072210 = (int)&loc_805BFE3;
          a1 = sub_8065CCF(
                 v8,
                 v9,
                 v10,
                 v11,
                 v12,
                 v13,
                 v14,
                 v15,
                 v16,
                 v17,
                 v18,
                 v19,
                 v20,
                 v21,
                 v22,
                 v23,
                 v24,
                 v25,
                 savedregs,
                 *(double *)&a1);
        }
        v16 = *(_DWORD *)(4 * v15 + a2);
      }
      v6 = v13++;
      *(_DWORD *)(a2 + 4 * v6) = v17;
      if ( ++v14 == v22 )
        break;
      v17 = *((_DWORD *)dest + v14);
    }
  }
  else if ( a3 == 2 )
  {
    v18 = *(_DWORD *)a2;
    v19 = *(_DWORD *)(a2 + 4);
    if ( ((int (__cdecl *)(int, int))a5)(v18, v19) > 0 )
    {
      *(_DWORD *)a2 = v19;
      *(_DWORD *)(a2 + 4) = v18;
      dword_80721DC = (int)&loc_805BFE3;
      sub_8065E0F(v5);
    }
  }
}
// 805BFC1: inconsistent fpu stack
// 8065CCF: using guessed type double __userpurge sub_8065CCF@<st0>(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, double@<st0>);
// 8065E0F: using guessed type int __fastcall sub_8065E0F(_DWORD);
// 80721DC: using guessed type int dword_80721DC;
// 8072210: using guessed type int dword_8072210;

//----- (0805BFE9) --------------------------------------------------------
void __usercall sub_805BFE9(long double a1@<st0>, int a2, int a3)
{
  int v3; // [esp+10h] [ebp-Ch]

  sub_805BD11(a1, a2 + 4 * a3, v3, (void *)(a2 + 4 * a3), v3);
}

//----- (0805C03D) --------------------------------------------------------
int sub_805C03D()
{
  int *v0; // ebp
  _BYTE *v1; // ebx
  int v2; // eax
  int v4; // [esp-18h] [ebp-18h]
  int v5; // [esp-Ch] [ebp-Ch]
  int v6; // [esp-8h] [ebp-8h]
  int savedregs; // [esp+0h] [ebp+0h]

  v0 = &savedregs;
  while ( 1 )
  {
    v2 = v0[4];
    v0[4] = v2 - 1;
    if ( !v2 )
      break;
    v1 = (_BYTE *)(v0[2] + v0[4]);
    v0 = &v4;
    v4 = *(unsigned __int8 *)(v5 + v6);
    *v1 = tolower(v4);
  }
  return v0[2];
}

//----- (0805C0B3) --------------------------------------------------------
int __cdecl sub_805C0B3(int a1, int a2, int a3)
{
  int v3; // eax

  while ( 1 )
  {
    v3 = a3--;
    if ( !v3 )
      break;
    *(_BYTE *)(a1 + a3) = toupper(*(unsigned __int8 *)(a2 + a3));
  }
  return a1;
}

//----- (0805C117) --------------------------------------------------------
int __cdecl sub_805C117(int a1, int a2)
{
  return a1 - (a1 - a2 + 382) % 7 + 3;
}

//----- (0805C184) --------------------------------------------------------
#error "805C198: call analysis failed (funcsize=13)"

//----- (0805C1AB) --------------------------------------------------------
#error "805C209: positive sp value has been found (funcsize=27)"

//----- (0805C20A) --------------------------------------------------------
#error "805E6C0: call analysis failed (funcsize=2395)"

//----- (0805F078) --------------------------------------------------------
char *__cdecl sub_805F078(char *s)
{
  char *v1; // eax
  char *result; // eax
  char *v3; // [esp+18h] [ebp-10h]
  char *s1; // [esp+1Ch] [ebp-Ch]

  if ( !s )
  {
    fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
    abort();
  }
  v3 = strrchr(s, 47);
  if ( v3 )
    v1 = v3 + 1;
  else
    v1 = s;
  s1 = v1;
  if ( v1 - s > 6 && !strncmp(v1 - 7, "/.libs/", 7u) )
  {
    s = s1;
    if ( !strncmp(s1, "lt-", 3u) )
    {
      s = s1 + 3;
      program_invocation_short_name = (int)(s1 + 3);
    }
  }
  dword_8073803 = (int)s;
  result = s;
  program_invocation_name = (int)s;
  return result;
}
// 8072440: using guessed type int program_invocation_short_name;
// 8072450: using guessed type int program_invocation_name;
// 8073803: using guessed type int dword_8073803;

//----- (0805F15F) --------------------------------------------------------
void *__cdecl sub_805F15F(void *src)
{
  int *v1; // eax
  void *v2; // ST1C_4
  int v4; // [esp+18h] [ebp-10h]

  v4 = *__errno_location();
  if ( src )
    v1 = (int *)src;
  else
    v1 = &dword_807380F;
  v2 = sub_8062259(v1, 0x30u);
  *__errno_location() = v4;
  return v2;
}
// 807380F: using guessed type int dword_807380F;

//----- (0805F1A5) --------------------------------------------------------
int __cdecl sub_805F1A5(int *a1)
{
  int *v1; // eax

  if ( a1 )
    v1 = a1;
  else
    v1 = &dword_807380F;
  return *v1;
}
// 807380F: using guessed type int dword_807380F;

//----- (0805F1CC) --------------------------------------------------------
int *__cdecl sub_805F1CC(int *a1, int a2)
{
  int *result; // eax

  if ( a1 )
    result = a1;
  else
    result = &dword_807380F;
  *result = a2;
  return result;
}
// 807380F: using guessed type int dword_807380F;

//----- (0805F1F4) --------------------------------------------------------
#error "805F232: call analysis failed (funcsize=74)"

//----- (0805F2D3) --------------------------------------------------------
#error "805F2DD: positive sp value has been found (funcsize=0)"

//----- (0805F30A) --------------------------------------------------------
int *__cdecl sub_805F30A(int *a1, int a2, int a3)
{
  int *result; // eax

  if ( !a1 )
    a1 = &dword_807380F;
  *a1 = 10;
  if ( !a2 || !a3 )
    abort();
  a1[10] = a2;
  result = a1;
  a1[11] = a3;
  return result;
}
// 807380F: using guessed type int dword_807380F;

//----- (0805F34F) --------------------------------------------------------
#error "805F3F4: call analysis failed (funcsize=51)"

//----- (0805F3F9) --------------------------------------------------------
#error "805F434: positive sp value has been found (funcsize=18)"

//----- (0805F43A) --------------------------------------------------------
const char *__cdecl sub_805F43A(char *msgid, int a2)
{
  const char *result; // eax
  char *v3; // [esp+18h] [ebp-10h]
  unsigned __int8 *v4; // [esp+1Ch] [ebp-Ch]

  v3 = gettext(msgid);
  if ( v3 != msgid )
    return v3;
  v4 = (unsigned __int8 *)sub_8064CF6();
  if ( sub_80645DE(v4, "UTF-8") )
  {
    if ( sub_80645DE(v4, "GB18030") )
    {
      if ( a2 == 9 )
        result = (const char *)&unk_806AB55;
      else
        result = "'";
    }
    else if ( *msgid == 96 )
    {
      result = (const char *)&unk_806AB4E;
    }
    else
    {
      result = (const char *)&unk_806AB52;
    }
  }
  else if ( *msgid == 96 )
  {
    result = (const char *)&unk_806AB3E;
  }
  else
  {
    result = (const char *)&unk_806AB42;
  }
  return result;
}

//----- (0805F4E8) --------------------------------------------------------
#error "806037C: call analysis failed (funcsize=987)"

//----- (080603D4) --------------------------------------------------------
int __usercall sub_80603D4@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, int a6, _DWORD *a7)
{
  void *v7; // eax
  int v8; // ST40_4
  int v9; // ST44_4
  int v11; // [esp+0h] [ebp-48h]
  int v12; // [esp+4h] [ebp-44h]

  v7 = &loc_806040B;
  if ( !a7 )
    v7 = &loc_8060410;
  dword_80721FC = (int)v7;
  sub_8065D3B(a2, a1, v11, v12);
  v8 = *__errno_location();
  v9 = sub_805F4E8(a3, a4, a5, a6, *a7, a7[1], a7 + 2, a7[10], a7[11]);
  *__errno_location() = v8;
  return v9;
}
// 805F4E8: using guessed type _DWORD __cdecl sub_805F4E8(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80721FC: using guessed type int dword_80721FC;

//----- (08060507) --------------------------------------------------------
void *__cdecl sub_8060507(int a1, int a2, _DWORD *a3, int *a4)
{
  int *v4; // eax
  int *v5; // ST3C_4
  int v6; // ST40_4
  int v7; // ST44_4
  int size; // [esp+48h] [ebp-10h]
  void *v10; // [esp+4Ch] [ebp-Ch]

  if ( a4 )
    v4 = a4;
  else
    v4 = &dword_807380F;
  v5 = v4;
  v6 = *__errno_location();
  v7 = v5[1] | (a3 == 0);
  size = sub_805F4E8(0, 0, a1, a2, *v5, v7, v5 + 2, v5[10], v5[11]) + 1;
  v10 = sub_80620FA(size);
  sub_805F4E8(v10, size, a1, a2, *v5, v7, v5 + 2, v5[10], v5[11]);
  *__errno_location() = v6;
  if ( a3 )
    *a3 = size - 1;
  return v10;
}
// 805F4E8: using guessed type _DWORD __cdecl sub_805F4E8(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 807380F: using guessed type int dword_807380F;

//----- (08060720) --------------------------------------------------------
#error "80609AB: call analysis failed (funcsize=188)"

//----- (080609E0) --------------------------------------------------------
int __cdecl sub_80609E0()
{
  return sub_8060720();
}

//----- (08060A0A) --------------------------------------------------------
int sub_8060A0A()
{
  return sub_8060720();
}

//----- (08060AA6) --------------------------------------------------------
int __cdecl sub_8060AA6(int a1, int a2)
{
  char v3; // [esp+10h] [ebp-38h]

  sub_805F34F(&v3, a2);
  return sub_8060720();
}
// 805F34F: using guessed type _DWORD __cdecl sub_805F34F(_DWORD, _DWORD);

//----- (08060AF4) --------------------------------------------------------
int __cdecl sub_8060AF4(int a1, int a2)
{
  char v3; // [esp+10h] [ebp-38h]

  sub_805F34F(&v3, a2);
  return sub_8060720();
}
// 805F34F: using guessed type _DWORD __cdecl sub_805F34F(_DWORD, _DWORD);

//----- (08060B63) --------------------------------------------------------
int __cdecl sub_8060B63(int a1)
{
  return sub_8060AA6(0, a1);
}

//----- (08060BC2) --------------------------------------------------------
int __cdecl sub_8060BC2(int a1, int a2, char a3)
{
  int v4; // [esp-1Ch] [ebp-58h]
  int *v5; // [esp-18h] [ebp-54h]
  int *v6; // [esp-14h] [ebp-50h]
  int *v7; // [esp-10h] [ebp-4Ch]
  char v8; // [esp+0h] [ebp-3Ch]
  int v9; // [esp+4h] [ebp-38h]
  int v10; // [esp+8h] [ebp-34h]
  int v11; // [esp+Ch] [ebp-30h]
  int v12; // [esp+10h] [ebp-2Ch]

  v8 = a3;
  v9 = dword_807380F;
  v10 = dword_8073813;
  v11 = dword_8073817;
  v12 = dword_807381B;
  *(&v4 - 10) = dword_807381F;
  *(&v4 - 9) = dword_8073823;
  *(&v4 - 8) = dword_8073827;
  *(&v4 - 7) = dword_807382B;
  *(&v4 - 6) = dword_807382F;
  *(&v4 - 5) = dword_8073833;
  *(&v4 - 4) = dword_8073837;
  *(&v4 - 3) = dword_807383B;
  sub_805F1F4(&v4 - 14, *((char *)&v4 - 60), 1);
  v7 = &v4 - 14;
  v6 = &v4 - 14;
  v5 = &v4 - 14;
  v4 = 0;
  return sub_8060720();
}
// 805F1F4: using guessed type _DWORD __cdecl sub_805F1F4(_DWORD, _DWORD, _DWORD);
// 807380F: using guessed type int dword_807380F;
// 8073813: using guessed type int dword_8073813;
// 8073817: using guessed type int dword_8073817;
// 807381B: using guessed type int dword_807381B;
// 807381F: using guessed type int dword_807381F;
// 8073823: using guessed type int dword_8073823;
// 8073827: using guessed type int dword_8073827;
// 807382B: using guessed type int dword_807382B;
// 807382F: using guessed type int dword_807382F;
// 8073833: using guessed type int dword_8073833;
// 8073837: using guessed type int dword_8073837;
// 807383B: using guessed type int dword_807383B;

//----- (08060CBE) --------------------------------------------------------
int __cdecl sub_8060CBE(int a1, char a2)
{
  return sub_8060BC2(a1, -1, a2);
}

//----- (08060D07) --------------------------------------------------------
int __cdecl sub_8060D07(int a1)
{
  return sub_8060CBE(a1, 58);
}

//----- (08060D82) --------------------------------------------------------
int __cdecl sub_8060D82(int a1, int a2, int a3)
{
  int v4; // [esp-4h] [ebp-7Ch]
  int v5; // [esp+0h] [ebp-78h]
  int v6; // [esp+4h] [ebp-74h]
  int *v7; // [esp+8h] [ebp-70h]
  int v8; // [esp+10h] [ebp-68h]
  int v9; // [esp+14h] [ebp-64h]
  int v10; // [esp+18h] [ebp-60h]
  int v11; // [esp+1Ch] [ebp-5Ch]
  int v12; // [esp+20h] [ebp-58h]
  int v13; // [esp+24h] [ebp-54h]
  int v14; // [esp+28h] [ebp-50h]
  int v15; // [esp+2Ch] [ebp-4Ch]
  int v16; // [esp+30h] [ebp-48h]
  int v17; // [esp+34h] [ebp-44h]
  int v18; // [esp+38h] [ebp-40h]
  int v19; // [esp+3Ch] [ebp-3Ch]
  int v20; // [esp+40h] [ebp-38h]
  int v21; // [esp+44h] [ebp-34h]
  int v22; // [esp+48h] [ebp-30h]
  int v23; // [esp+4Ch] [ebp-2Ch]
  int v24; // [esp+50h] [ebp-28h]
  int v25; // [esp+54h] [ebp-24h]
  int v26; // [esp+58h] [ebp-20h]
  int v27; // [esp+5Ch] [ebp-1Ch]
  int v28; // [esp+60h] [ebp-18h]
  int v29; // [esp+64h] [ebp-14h]
  int v30; // [esp+68h] [ebp-10h]
  int v31; // [esp+6Ch] [ebp-Ch]

  sub_805F34F(&v8, a2);
  v20 = v8;
  v21 = v9;
  v22 = v10;
  v23 = v11;
  v24 = v12;
  v25 = v13;
  v26 = v14;
  v27 = v15;
  v28 = v16;
  v29 = v17;
  v30 = v18;
  v31 = v19;
  sub_805F1F4(&v4 - 14, 58, 1);
  v7 = &v20;
  v6 = -1;
  v5 = a3;
  v4 = a1;
  return sub_8060720();
}
// 805F1F4: using guessed type _DWORD __cdecl sub_805F1F4(_DWORD, _DWORD, _DWORD);
// 805F34F: using guessed type _DWORD __cdecl sub_805F34F(_DWORD, _DWORD);

//----- (08060E57) --------------------------------------------------------
int __cdecl sub_8060E57(int a1, int a2, int a3)
{
  return sub_8060EA7(a1, a2, a3);
}
// 8060EA7: using guessed type _DWORD __cdecl sub_8060EA7(_DWORD, _DWORD, _DWORD);

//----- (08060EA7) --------------------------------------------------------
#error "8060F4B: call analysis failed (funcsize=46)"

//----- (08060F50) --------------------------------------------------------
#error "8060F8A: positive sp value has been found (funcsize=0)"

//----- (08061036) --------------------------------------------------------
int __cdecl sub_8061036()
{
  return sub_8060720();
}

//----- (080610C3) --------------------------------------------------------
int __cdecl sub_80610C3()
{
  return sub_8061036();
}

//----- (080610F3) --------------------------------------------------------
int __cdecl sub_80610F3()
{
  return sub_80610C3();
}

//----- (08061120) --------------------------------------------------------
int __cdecl sub_8061120(void *src, void *a2)
{
  size_t v2; // ST20_4
  bool v3; // al
  char *s1; // [esp+18h] [ebp-E0h]
  char *s2; // [esp+1Ch] [ebp-DCh]
  size_t n; // [esp+24h] [ebp-D4h]

  s1 = (char *)sub_8056C5F(src);
  s2 = (char *)sub_8056C5F(a2);
  v2 = sub_8056D24(s1);
  n = sub_8056D24(s2);
  v3 = v2 == n && !memcmp(s1, s2, n);
  if ( v3 )
    sub_80646CC(src);
  return 0;
}
// 8056C5F: using guessed type int __cdecl sub_8056C5F(_DWORD);

//----- (08061324) --------------------------------------------------------
void sub_8061324()
{
  ;
}

//----- (08061375) --------------------------------------------------------
signed int sub_8061375()
{
  *__errno_location() = 95;
  return -1;
}

//----- (08061391) --------------------------------------------------------
signed int sub_8061391()
{
  *__errno_location() = 95;
  return -1;
}

//----- (080614CF) --------------------------------------------------------
_DWORD *__userpurge sub_80614CF@<eax>(_DWORD *a1, int a2)
{
  int v2; // edx

  v2 = *(_DWORD *)(a2 + 68);
  *a1 = *(_DWORD *)(a2 + 64);
  a1[1] = v2;
  return a1;
}

//----- (0806150A) --------------------------------------------------------
_DWORD *__userpurge sub_806150A@<eax>(_DWORD *a1, int a2)
{
  int v2; // edx

  v2 = *(_DWORD *)(a2 + 84);
  *a1 = *(_DWORD *)(a2 + 80);
  a1[1] = v2;
  return a1;
}

//----- (08061547) --------------------------------------------------------
_DWORD *__userpurge sub_8061547@<eax>(_DWORD *a1, int a2)
{
  int v2; // edx

  v2 = *(_DWORD *)(a2 + 76);
  *a1 = *(_DWORD *)(a2 + 72);
  a1[1] = v2;
  return a1;
}

//----- (080615F2) --------------------------------------------------------
int __cdecl sub_80615F2(int a1, int a2, int a3, int a4)
{
  if ( a1 < a3 )
    return -1;
  if ( a1 > a3 )
    return 1;
  return a2 - a4;
}

//----- (080616D0) --------------------------------------------------------
#error "8061A6B: call analysis failed (funcsize=407)"

//----- (08061E35) --------------------------------------------------------
int __cdecl sub_8061E35(FILE *stream, int a2, int a3, int a4, int a5)
{
  int *v5; // eax
  int v7; // [esp+0h] [ebp-58h]
  int i; // [esp+24h] [ebp-34h]
  int v9[12]; // [esp+28h] [ebp-30h]

  for ( i = 0; (unsigned int)i <= 9; ++i )
  {
    v5 = (int *)a5;
    a5 += 4;
    v9[i] = *v5;
    if ( !v9[i] )
      break;
  }
  return sub_80616D0(stream, a2, a3, a4, (int)(&v7 - 12), i);
}
// 8061E35: using guessed type int var_30[12];

//----- (08061ECB) --------------------------------------------------------
int sub_8061ECB(FILE *stream, int a2, int a3, int a4, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a4);
  return sub_8061E35(stream, a2, a3, a4, (int)va);
}

//----- (08061FAD) --------------------------------------------------------
void *__cdecl sub_8061FAD(unsigned int a1, unsigned int a2)
{
  if ( 0x7FFFFFFF / a2 < a1 )
    sub_80622AF();
  return sub_806210D(a2 * a1);
}

//----- (08061FDF) --------------------------------------------------------
void *__cdecl sub_8061FDF(void *ptr, int a2, int a3)
{
  if ( 0x7FFFFFFFu / a3 < a2 )
    sub_80622AF();
  return sub_8062158(ptr, a3 * a2);
}

//----- (08062014) --------------------------------------------------------
#error "806206E: call analysis failed (funcsize=60)"

//----- (080620FA) --------------------------------------------------------
void *__cdecl sub_80620FA(size_t size)
{
  return sub_806210D(size);
}

//----- (0806210D) --------------------------------------------------------
void *__cdecl sub_806210D(size_t size)
{
  int v1; // edx
  int v2; // ecx
  void *v3; // eax
  int v5; // [esp+0h] [ebp-28h]
  int v6; // [esp+4h] [ebp-24h]
  int v7; // [esp+8h] [ebp-20h]
  int v8; // [esp+Ch] [ebp-1Ch]
  int v9; // [esp+10h] [ebp-18h]
  int v10; // [esp+14h] [ebp-14h]
  void *v11; // [esp+1Ch] [ebp-Ch]

  v11 = malloc(size);
  if ( !v11 )
  {
    v3 = &loc_806214A;
    if ( !size )
      v3 = &loc_806214F;
    dword_807224C = (int)v3;
    sub_8065B5D(v2, v1, v5, v6, v7, v8, v9, v10);
    sub_80622AF();
  }
  return v11;
}
// 807224C: using guessed type int dword_807224C;

//----- (08062158) --------------------------------------------------------
void *__cdecl sub_8062158(void *ptr, size_t size)
{
  void **v2; // ebp
  int v3; // edx
  int v4; // ecx
  void *v6; // [esp+0h] [ebp-18h]
  size_t v7; // [esp+4h] [ebp-14h]
  int savedregs; // [esp+18h] [ebp+0h]

  v2 = (void **)&savedregs;
  if ( !size && ptr )
  {
    free(ptr);
    dword_80721FC = (int)&locret_80621CA;
    sub_8065D3B(v4, v3, v6, v7);
    v2 = &v6;
  }
  v7 = (size_t)v2[3];
  v6 = v2[2];
  v2[2] = realloc(v6, v7);
  if ( !v2[2] && v2[3] )
    sub_80622AF();
  return v2[2];
}
// 80721FC: using guessed type int dword_80721FC;

//----- (080621CC) --------------------------------------------------------
int __cdecl sub_80621CC(void *ptr, int a2)
{
  return sub_8062014(ptr, a2, 1);
}

//----- (08062259) --------------------------------------------------------
void *__cdecl sub_8062259(void *src, size_t n)
{
  void *v2; // eax

  v2 = sub_806210D(n);
  return memcpy(v2, src, n);
}

//----- (08062286) --------------------------------------------------------
void *__cdecl sub_8062286(char *s)
{
  size_t v1; // eax

  v1 = strlen(s);
  return sub_8062259(s, v1 + 1);
}

//----- (080622AF) --------------------------------------------------------
void __noreturn sub_80622AF()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (080622E8) --------------------------------------------------------
__int64 __usercall sub_80622E8@<edx:eax>(int a1@<ebx>, double a2@<st0>, char *nptr, int base, int a4)
{
  unsigned __int64 v5; // rax
  int v6; // ecx
  bool v7; // zf
  int v8; // ebx
  int v9; // edx
  int v10; // eax
  int v12; // [esp-8h] [ebp-50h]
  int v13; // [esp-4h] [ebp-4Ch]
  int v14; // [esp+0h] [ebp-48h]
  int v15; // [esp+4h] [ebp-44h]
  int v16; // [esp+8h] [ebp-40h]
  char *v17; // [esp+Ch] [ebp-3Ch]
  int v18; // [esp+10h] [ebp-38h]
  int v19; // [esp+14h] [ebp-34h]
  int v20; // [esp+18h] [ebp-30h]
  int v21; // [esp+1Ch] [ebp-2Ch]
  char *v22; // [esp+20h] [ebp-28h]
  char *v23; // [esp+24h] [ebp-24h]
  int v24; // [esp+28h] [ebp-20h]

  *(&v14 - 8) = a4;
  *(&v14 - 7) = v19;
  *(&v14 - 10) = v20;
  *(&v14 - 9) = v21;
  v17 = (char *)(&v14 - 4);
  LODWORD(v5) = sub_8062E4A(a2, v17, 0, (int)v17, (int)v17, v22);
  *(&v14 - 5) = v5;
  if ( *(&v14 - 5) )
  {
    if ( *(&v14 - 5) == 1 )
    {
      LODWORD(v5) = __errno_location();
      *(_DWORD *)v5 = 75;
    }
    else if ( *(&v14 - 5) == 3 )
    {
      LODWORD(v5) = __errno_location();
      *(_DWORD *)v5 = 0;
    }
  }
  else if ( *((_QWORD *)&v14 - 2) < *((_QWORD *)&v14 - 4) || (v5 = *((_QWORD *)&v14 - 2), *((_QWORD *)&v14 - 5) < v5) )
  {
    *(&v14 - 5) = 1;
    if ( *((_QWORD *)&v14 - 2) <= 0x3FFFFFFFuLL )
    {
      LODWORD(v5) = __errno_location();
      *(_DWORD *)v5 = 34;
    }
    else
    {
      LODWORD(v5) = __errno_location();
      *(_DWORD *)v5 = 75;
    }
  }
  v7 = *(&v14 - 5) == 0;
  v13 = v5;
  v12 = a1;
  LODWORD(v5) = &loc_8062413;
  if ( v7 )
    LODWORD(v5) = &loc_8062469;
  dword_807224C = v5;
  sub_8065B5D(v6, HIDWORD(v5), v14, v15, v16, v17, v18, v19);
  v14 = v16;
  v8 = sub_80610F3();
  if ( *__errno_location() == 22 )
    v9 = 0;
  else
    v9 = *__errno_location();
  if ( v24 )
    v10 = v24;
  else
    v10 = 1;
  v18 = v8;
  v17 = v23;
  error(v10, v9, "%s: %s", v23, v8);
  return *((_QWORD *)&v14 - 2);
}
// 807224C: using guessed type int dword_807224C;

//----- (080624F9) --------------------------------------------------------
char *sub_80624F9()
{
  char *v1; // [esp+1Ch] [ebp-Ch]

  v1 = getcwd(0, 0);
  if ( !v1 && *__errno_location() == 12 )
    sub_80622AF();
  return v1;
}

//----- (08062536) --------------------------------------------------------
#error "8062615: call analysis failed (funcsize=88)"

//----- (08062653) --------------------------------------------------------
signed int __cdecl sub_8062653(unsigned int *a1, unsigned int a2)
{
  signed int result; // eax

  if ( 0xFFFFFFFF / a2 >= *a1 )
  {
    *a1 *= a2;
    result = 0;
  }
  else
  {
    *a1 = -1;
    result = 1;
  }
  return result;
}

//----- (080626D7) --------------------------------------------------------
#error "806272D: call analysis failed (funcsize=37)"

//----- (08062754) --------------------------------------------------------
#error "8062781: call analysis failed (funcsize=117)"

//----- (08062BB3) --------------------------------------------------------
#error "8062BEC: call analysis failed (funcsize=71)"

//----- (08062CA6) --------------------------------------------------------
void __cdecl __noreturn sub_8062CA6(int a1, int a2, char a3, int a4, int a5)
{
  sub_8062BB3(a1, a2, a3, a4, a5, status);
  abort();
}

//----- (08062D09) --------------------------------------------------------
#error "8062D4A: call analysis failed (funcsize=24)"

//----- (08062D4F) --------------------------------------------------------
#error "8062DE9: positive sp value has been found (funcsize=46)"

//----- (08062DEE) --------------------------------------------------------
int __cdecl sub_8062DEE(int a1, int a2, int a3)
{
  int v3; // eax
  int i; // [esp+1Ch] [ebp-10h]

  for ( i = 0; ; i |= sub_8062D09(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}
// 8062D09: using guessed type _DWORD __cdecl sub_8062D09(_DWORD, _DWORD);

//----- (08062E4A) --------------------------------------------------------
int __usercall sub_8062E4A@<eax>(double a1@<st0>, char *nptr, int a3, int base, int a5, char *s)
{
  char **v6; // eax
  int result; // eax
  void *v8; // eax
  int v9; // edx
  int v10; // edx
  bool v11; // zf
  void *v12; // eax
  int v13; // edx
  int v14; // ecx
  int v15; // eax
  void *v16; // eax
  int v17; // edx
  int v18; // ecx
  int v19; // ST08_4
  int v20; // ST0C_4
  int v21; // ST10_4
  int v22; // edx
  int v23; // edx
  int v24; // [esp+0h] [ebp-48h]
  int v25; // [esp+0h] [ebp-48h]
  int v26; // [esp+0h] [ebp-48h]
  int v27; // [esp+4h] [ebp-44h]
  int v28; // [esp+4h] [ebp-44h]
  int v29; // [esp+4h] [ebp-44h]
  int v30; // [esp+8h] [ebp-40h]
  int v31; // [esp+8h] [ebp-40h]
  int v32; // [esp+Ch] [ebp-3Ch]
  int v33; // [esp+10h] [ebp-38h]
  int v34; // [esp+14h] [ebp-34h]
  int v35; // [esp+18h] [ebp-30h]
  char v36; // [esp+1Ch] [ebp-2Ch]
  int v37; // [esp+20h] [ebp-28h]
  char *v38; // [esp+24h] [ebp-24h]
  int v39; // [esp+28h] [ebp-20h]
  int v40; // [esp+2Ch] [ebp-1Ch]
  int v41; // [esp+30h] [ebp-18h]
  char **endptr; // [esp+34h] [ebp-14h]
  uintmax_t v43; // [esp+38h] [ebp-10h]
  int v44; // [esp+40h] [ebp-8h]
  int v45; // [esp+44h] [ebp-4h]
  int savedregs; // [esp+48h] [ebp+0h]

  v37 = 0;
  if ( base < 0 || base > 36 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoumax");
  if ( a3 )
    v6 = (char **)a3;
  else
    v6 = (char **)&v36;
  endptr = v6;
  *__errno_location() = 0;
  v38 = nptr;
  HIBYTE(v35) = *nptr;
  while ( (*__ctype_b_loc())[HIBYTE(v35)] & 0x2000 )
    HIBYTE(v35) = *++v38;
  if ( HIBYTE(v35) == 45 )
    return 4;
  v43 = strtoumax(nptr, endptr, base);
  if ( *endptr == nptr )
  {
    if ( !s )
      return 4;
    v8 = &loc_8062F55;
    if ( !**endptr )
      v8 = &loc_8062F83;
    dword_8072210 = (int)v8;
    sub_8065CCF(
      v24,
      v27,
      v30,
      v32,
      v33,
      v34,
      v35,
      *(_DWORD *)&v36,
      v37,
      v38,
      v39,
      v40,
      v41,
      endptr,
      v43,
      HIDWORD(v43),
      v44,
      v45,
      savedregs,
      a1);
    if ( !strchr(s, **endptr) )
      return 4;
    v43 = 1LL;
  }
  else if ( *__errno_location() )
  {
    if ( *__errno_location() != 34 )
    {
      dword_8072210 = (int)&locret_8063308;
      sub_8065CCF(
        v24,
        v27,
        v30,
        v32,
        v33,
        v34,
        v35,
        *(_DWORD *)&v36,
        v37,
        v38,
        v39,
        v40,
        v41,
        endptr,
        v43,
        HIDWORD(v43),
        v44,
        v45,
        savedregs,
        a1);
    }
    v37 = 1;
  }
  if ( s )
  {
    if ( **endptr )
    {
      v39 = 1024;
      v40 = 1;
      if ( strchr(s, **endptr) )
      {
        switch ( **endptr )
        {
          case 69:
          case 71:
          case 75:
          case 77:
          case 80:
          case 84:
          case 89:
          case 90:
          case 103:
          case 107:
          case 109:
          case 116:
            v11 = strchr(s, 48) == 0;
            v12 = &loc_8063088;
            if ( v11 )
              v12 = &loc_80630F7;
            dword_8072238 = (int)v12;
            sub_8065BD3(v25, v28, v30, v32, v33, v34);
            v15 = (*endptr)[1];
            if ( v15 == 68 )
            {
              v39 = 1000;
              ++v40;
            }
            else if ( v15 == 105 )
            {
              if ( (*endptr)[2] == 66 )
              {
                v40 += 2;
                dword_80721FC = (int)&loc_80630F7;
                sub_8065D3B(v14, v13, v26, v29);
              }
            }
            else
            {
              v11 = v15 == 66;
              v16 = &loc_80630BE;
              if ( v11 )
                v16 = &loc_80630EC;
              dword_807224C = (int)v16;
              sub_8065B5D(v14, v13, v26, v29, v31, v32, v33, v34);
            }
            break;
          default:
            break;
        }
        switch ( **endptr )
        {
          case 66:
            v41 = sub_8062D09(&v43, 1024);
            goto LABEL_54;
          case 69:
            v41 = sub_8062DEE((int)&v43, v39, 6);
            goto LABEL_54;
          case 71:
          case 103:
            v41 = sub_8062DEE((int)&v43, v39, 3);
            goto LABEL_54;
          case 75:
          case 107:
            v41 = sub_8062DEE((int)&v43, v39, 1);
            goto LABEL_54;
          case 77:
          case 109:
            v41 = sub_8062DEE((int)&v43, v39, 2);
            goto LABEL_54;
          case 80:
            v41 = sub_8062DEE((int)&v43, v39, 5);
            goto LABEL_54;
          case 84:
          case 116:
            v41 = sub_8062DEE((int)&v43, v39, 4);
            goto LABEL_54;
          case 89:
            v41 = sub_8062DEE((int)&v43, v39, 8);
            dword_807224C = (int)&loc_80632B2;
            sub_8065B5D(v18, v17, v19, v20, v21, v32, v33, v34);
            goto LABEL_52;
          case 90:
LABEL_52:
            v41 = sub_8062DEE((int)&v43, v39, 7);
            goto LABEL_54;
          case 98:
            v41 = sub_8062D09(&v43, 512);
            goto LABEL_54;
          case 99:
            v41 = 0;
            goto LABEL_54;
          case 119:
            v41 = sub_8062D09(&v43, 2);
LABEL_54:
            v37 |= v41;
            *endptr += v40;
            if ( **endptr )
              v37 |= 2u;
            goto LABEL_56;
          default:
            v22 = HIDWORD(v43);
            *(_DWORD *)a5 = v43;
            *(_DWORD *)(a5 + 4) = v22;
            result = v37 | 2;
            break;
        }
      }
      else
      {
        v10 = HIDWORD(v43);
        *(_DWORD *)a5 = v43;
        *(_DWORD *)(a5 + 4) = v10;
        result = v37 | 2;
      }
    }
    else
    {
LABEL_56:
      v23 = HIDWORD(v43);
      *(_DWORD *)a5 = v43;
      *(_DWORD *)(a5 + 4) = v23;
      result = v37;
    }
  }
  else
  {
    v9 = HIDWORD(v43);
    *(_DWORD *)a5 = v43;
    *(_DWORD *)(a5 + 4) = v9;
    result = v37;
  }
  return result;
}
// 8062F50: inconsistent fpu stack
// 8062FB7: inconsistent fpu stack
// 8062E4A: could not find valid save-restore pair for ebx
// 8062D09: using guessed type _DWORD __cdecl sub_8062D09(_DWORD, _DWORD);
// 8065BD3: using guessed type int __stdcall sub_8065BD3(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8065CCF: using guessed type double __userpurge sub_8065CCF@<st0>(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, double@<st0>);
// 80721FC: using guessed type int dword_80721FC;
// 8072210: using guessed type int dword_8072210;
// 8072238: using guessed type int dword_8072238;
// 807224C: using guessed type int dword_807224C;

//----- (0806330A) --------------------------------------------------------
#error "8063331: call analysis failed (funcsize=15)"

//----- (08063336) --------------------------------------------------------
#error "806334F: positive sp value has been found (funcsize=9)"

//----- (080633A7) --------------------------------------------------------
#error "80633F2: positive sp value has been found (funcsize=0)"

//----- (080633F3) --------------------------------------------------------
int __cdecl sub_80633F3(int a1, int a2)
{
  int result; // eax

  if ( *(_BYTE *)(a1 + 40) & 1 )
    result = (*(int (__cdecl **)(_DWORD, int))(a1 + 28))(*(_DWORD *)(a1 + 36), a2);
  else
    result = (*(int (__cdecl **)(int))(a1 + 28))(a2);
  return result;
}

//----- (08063441) --------------------------------------------------------
#error "806347B: call analysis failed (funcsize=44)"

//----- (080634C6) --------------------------------------------------------
signed int __cdecl sub_80634C6(int a1, signed int a2, signed int a3)
{
  int v4; // [esp+4h] [ebp-24h]
  int v5; // [esp+18h] [ebp-10h]
  _DWORD *v6; // [esp+1Ch] [ebp-Ch]

  if ( !a3 )
    a3 = 8;
  if ( !a2 )
  {
    v5 = 32;
    a2 = 4064;
  }
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 24) = a3 - 1;
  v4 = *(_DWORD *)a1;
  *(_DWORD *)(a1 + 4) = sub_80633F3(a1, v4);
  v6 = *(_DWORD **)(a1 + 4);
  if ( !v6 )
    obstack_alloc_failed_handler();
  *(_DWORD *)(a1 + 8) = ((unsigned int)&v6[a3 / 4u + 1] + 3) & -a3;
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 8);
  *v6 = (char *)v6 + *(_DWORD *)a1;
  *(_DWORD *)(a1 + 16) = *v6;
  v6[1] = 0;
  *(_BYTE *)(a1 + 40) &= 0xFDu;
  *(_BYTE *)(a1 + 40) &= 0xFBu;
  return 1;
}
// 8072480: using guessed type int (*obstack_alloc_failed_handler)(void);

//----- (080635E5) --------------------------------------------------------
signed int __cdecl sub_80635E5(int a1, int a2, int a3, int a4)
{
  int v5; // [esp+8h] [ebp-10h]
  signed int v6; // [esp+Ch] [ebp-Ch]
  int v7; // [esp+10h] [ebp-8h]
  int savedregs; // [esp+18h] [ebp+0h]

  *(_DWORD *)(a1 + 28) = a4;
  *(_DWORD *)(v5 + 32) = savedregs;
  *(_BYTE *)(v5 + 40) &= 0xFEu;
  return sub_80634C6(v7, v6, v7);
}

//----- (080636C0) --------------------------------------------------------
#error "8063851: call analysis failed (funcsize=153)"

//----- (08063A4E) --------------------------------------------------------
int __cdecl sub_8063A4E(int a1, int a2)
{
  return (a1 == 0) ^ (a2 == 0) && a1 >= 0 && a2 >= 0;
}

//----- (08063A92) --------------------------------------------------------
_BOOL4 __cdecl sub_8063A92(_DWORD *a1, _DWORD *a2)
{
  int v2; // ebx

  v2 = a1[5] ^ a2[5] | a1[4] ^ a2[4] | a1[3] ^ a2[3] | a1[2] ^ a2[2] | a1[1] ^ a2[1] | *a2 ^ *a1;
  return (v2 | (unsigned __int8)sub_8063A4E(a1[8], a2[8])) == 0;
}

//----- (08063B44) --------------------------------------------------------
#error "8063B82: call analysis failed (funcsize=20)"

//----- (08063B87) --------------------------------------------------------
#error "8063B97: call analysis failed (funcsize=27)"

//----- (08063BD9) --------------------------------------------------------
int __cdecl sub_8063BD9(char *s)
{
  size_t v1; // eax
  int v2; // eax
  void *v3; // eax
  bool v4; // zf
  void *v5; // eax
  int v7; // [esp-8h] [ebp-30h]
  void *v8; // [esp-4h] [ebp-2Ch]
  int v9; // [esp+0h] [ebp-28h]
  int v10; // [esp+4h] [ebp-24h]
  int v11; // [esp+8h] [ebp-20h]
  int v12; // [esp+Ch] [ebp-1Ch]
  int v13; // [esp+10h] [ebp-18h]
  size_t v14; // [esp+14h] [ebp-14h]
  int v15; // [esp+18h] [ebp-10h]
  void *v16; // [esp+1Ch] [ebp-Ch]

  if ( s )
    v1 = strlen(s) + 1;
  else
    v1 = 0;
  v14 = v1;
  if ( v1 <= 0x3A )
    v2 = 59;
  else
    v2 = v14 + 1;
  v15 = v2;
  v3 = malloc((v2 + 12) & 0xFFFFFFF8);
  v16 = v3;
  v4 = v3 == 0;
  v8 = v3;
  v5 = &loc_8063C56;
  if ( v4 )
    v5 = &loc_8063CA7;
  dword_8072238 = (int)v5;
  sub_8065BD3(v9, v10, v11, v12, v13, v14);
  *(_DWORD *)*(&v7 - 3) = 0;
  *(_WORD *)(*(&v9 - 3) + 4) = v9 != 0;
  if ( v11 )
    sub_8063B44(*(&v9 - 3) + 5, *(&v9 - 5), *(&v9 - 5));
  return *(&v9 - 3);
}
// 8063B44: using guessed type _DWORD __cdecl sub_8063B44(_DWORD, _DWORD, _DWORD);
// 8065BD3: using guessed type int __stdcall sub_8065BD3(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8072238: using guessed type int dword_8072238;

//----- (08063CCC) --------------------------------------------------------
#error "8063E61: call analysis failed (funcsize=140)"

//----- (08063EA1) --------------------------------------------------------
void *__cdecl sub_8063EA1(void *ptr)
{
  void *result; // eax
  void *v2; // ST1C_4

  result = (void *)1;
  if ( ptr != (void *)1 )
  {
    while ( ptr )
    {
      v2 = *(void **)ptr;
      free(ptr);
      result = v2;
      ptr = v2;
    }
  }
  return result;
}

//----- (08063ED4) --------------------------------------------------------
char *sub_8063ED4()
{
  return getenv("TZ");
}

//----- (08063F0C) --------------------------------------------------------
int __cdecl sub_8063F0C(char *value)
{
  int result; // eax

  if ( value )
    result = setenv("TZ", value, 1);
  else
    result = unsetenv("TZ");
  return result;
}

//----- (08063F43) --------------------------------------------------------
signed int __cdecl sub_8063F43(int a1)
{
  char *value; // eax

  if ( *(_BYTE *)(a1 + 4) )
    value = (char *)(a1 + 5);
  else
    value = 0;
  if ( sub_8063F0C(value) )
    return 0;
  tzset();
  return 1;
}

//----- (08063FB6) --------------------------------------------------------
signed int __cdecl sub_8063FB6(int a1)
{
  bool v1; // al
  bool v2; // al
  int v4; // ST1C_4
  char *s2; // [esp+14h] [ebp-14h]
  void *ptr; // [esp+18h] [ebp-10h]

  s2 = sub_8063ED4();
  if ( s2 )
  {
    v1 = *(_BYTE *)(a1 + 4) && !strcmp((const char *)(a1 + 5), s2);
    v2 = v1;
  }
  else
  {
    v2 = *(_BYTE *)(a1 + 4) == 0;
  }
  if ( v2 )
    return 1;
  ptr = (void *)sub_8063BD9(s2);
  if ( !ptr )
    return 0;
  if ( !((unsigned __int8)sub_8063F43(a1) ^ 1) )
    return (signed int)ptr;
  v4 = *__errno_location();
  sub_8063EA1(ptr);
  *__errno_location() = v4;
  return 0;
}

//----- (08064070) --------------------------------------------------------
#error "8064093: call analysis failed (funcsize=43)"

//----- (080640F2) --------------------------------------------------------
struct tm *__cdecl sub_80640F2(int a1, time_t *timer, struct tm *tp)
{
  bool v4; // al
  int v5; // [esp+0h] [ebp-28h]
  int v6; // [esp+4h] [ebp-24h]
  int v7; // [esp+8h] [ebp-20h]
  int v8; // [esp+Ch] [ebp-1Ch]
  int v9; // [esp+10h] [ebp-18h]
  int v10; // [esp+14h] [ebp-14h]
  bool v11; // [esp+1Bh] [ebp-Dh]
  void *ptr; // [esp+1Ch] [ebp-Ch]

  if ( !a1 )
    return gmtime_r(timer, tp);
  ptr = (void *)sub_8063FB6(a1);
  if ( ptr )
  {
    v4 = localtime_r(timer, tp) && (unsigned __int8)sub_8063CCC(a1, (unsigned int)tp);
    v11 = v4;
    if ( (unsigned __int8)sub_8064070(ptr) )
    {
      if ( v11 )
      {
        dword_8072238 = (int)&locret_80641A0;
        sub_8065BD3(v5, v6, v7, v8, v9, v10);
      }
    }
  }
  return 0;
}
// 8065BD3: using guessed type int __stdcall sub_8065BD3(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8072238: using guessed type int dword_8072238;

//----- (080641A2) --------------------------------------------------------
int __cdecl sub_80641A2(int a1, struct tm *tp)
{
  int result; // eax
  bool v3; // zf
  int v4; // edx
  int v5; // ecx
  void *v6; // eax
  int v7; // ecx
  void *v8; // eax
  int v9; // [esp+0h] [ebp-58h]
  int v10; // [esp+4h] [ebp-54h]
  int v11; // [esp+8h] [ebp-50h]
  int v12; // [esp+Ch] [ebp-4Ch]
  int v13; // [esp+10h] [ebp-48h]
  int v14; // [esp+14h] [ebp-44h]
  time_t timer; // [esp+18h] [ebp-40h]
  void *ptr; // [esp+1Ch] [ebp-3Ch]
  time_t v17; // [esp+20h] [ebp-38h]
  struct tm v18; // [esp+24h] [ebp-34h]

  if ( !a1 )
    return timegm(tp);
  ptr = (void *)sub_8063FB6(a1);
  if ( !ptr )
    goto LABEL_16;
  timer = mktime(tp);
  v17 = -1;
  if ( timer != -1 )
    goto LABEL_17;
  v3 = localtime_r(&timer, &v18) == 0;
  v6 = &loc_8064222;
  if ( v3 )
    v6 = &loc_8064270;
  dword_807224C = (int)v6;
  sub_8065B5D(v5, v4, v9, v10, v11, v12, v13, v14);
  if ( sub_8063A92(tp, &v18) )
  {
LABEL_17:
    v3 = (unsigned __int8)sub_8063CCC(a1, (unsigned int)tp) == 1;
    v8 = &loc_806426A;
    if ( v3 )
      v8 = &loc_8064270;
    dword_80721DC = (int)v8;
    sub_8065E0F(v7);
    timer = v17;
  }
  if ( (unsigned __int8)sub_8064070(ptr) )
    result = timer;
  else
LABEL_16:
    result = -1;
  return result;
}
// 80641A2: could not find valid save-restore pair for ebx
// 8065E0F: using guessed type int __fastcall sub_8065E0F(_DWORD);
// 80721DC: using guessed type int dword_80721DC;
// 807224C: using guessed type int dword_807224C;

//----- (0806444A) --------------------------------------------------------
int __cdecl sub_806444A(int a1, char a2)
{
  return __ROR4__(a1, a2);
}

//----- (080645DE) --------------------------------------------------------
int __cdecl sub_80645DE(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // esi
  unsigned __int8 *v3; // ebx
  unsigned __int8 v5; // [esp+1Eh] [ebp-Ah]
  unsigned __int8 v6; // [esp+1Fh] [ebp-9h]

  v2 = a1;
  v3 = a2;
  if ( a1 == a2 )
    return 0;
  do
  {
    v5 = sub_8055F44(*v2);
    v6 = sub_8055F44(*v3);
    if ( !v5 )
      break;
    ++v2;
    ++v3;
  }
  while ( v5 == v6 );
  return v5 - v6;
}

//----- (08064647) --------------------------------------------------------
int __cdecl sub_8064647(FILE *fp)
{
  bool v1; // ST1E_1
  bool v3; // [esp+1Dh] [ebp-Bh]
  bool v4; // [esp+1Fh] [ebp-9h]

  v3 = __fpending(fp) != 0;
  v1 = ferror_unlocked(fp) != 0;
  v4 = sub_8064DDB(fp) != 0;
  if ( !v1 && (!v4 || !v3 && *__errno_location() == 9) )
    return 0;
  if ( v4 != 1 )
    *__errno_location() = 0;
  return -1;
}

//----- (080646CC) --------------------------------------------------------
void __cdecl __noreturn sub_80646CC(void *src)
{
  void *v1; // eax
  int v2; // ecx
  void *v3; // ST20_4
  void *savedregs; // ST28_4
  int (*v5)(); // eax

  v1 = sub_8056BDD(src);
  v3 = v1;
  savedregs = v1;
  v5 = (int (*)())&loc_8064721;
  if ( v3 )
    v5 = sub_8064726;
  dword_80721DC = (int)v5;
  sub_8065E0F(v2);
  sub_80622AF();
}
// 8064726: using guessed type int sub_8064726();
// 8065E0F: using guessed type int __fastcall sub_8065E0F(_DWORD);
// 80721DC: using guessed type int dword_80721DC;

//----- (08064726) --------------------------------------------------------
#error "806472A: positive sp value has been found (funcsize=0)"

//----- (0806472B) --------------------------------------------------------
int __cdecl sub_806472B(_BYTE *a1, unsigned int a2)
{
  _BYTE *i; // [esp+8h] [ebp-8h]
  unsigned int v4; // [esp+Ch] [ebp-4h]

  v4 = 0;
  for ( i = a1; *i; ++i )
    v4 = __ROR4__(v4, 23) + (char)*i;
  return v4 % a2;
}

//----- (08064771) --------------------------------------------------------
#error "8064989: call analysis failed (funcsize=314)"

//----- (08064CF6) --------------------------------------------------------
char *sub_8064CF6()
{
  size_t v0; // eax
  int v1; // ecx
  int v2; // ST00_4
  char *v3; // ST1C_4
  int v5; // [esp+0h] [ebp-28h]
  int v6; // [esp+4h] [ebp-24h]
  int v7; // [esp+4h] [ebp-24h]
  int v8; // [esp+8h] [ebp-20h]
  int v9; // [esp+8h] [ebp-20h]
  int v10; // [esp+Ch] [ebp-1Ch]
  int v11; // [esp+Ch] [ebp-1Ch]
  int v12; // [esp+10h] [ebp-18h]
  int v13; // [esp+10h] [ebp-18h]
  int v14; // [esp+14h] [ebp-14h]
  int v15; // [esp+14h] [ebp-14h]
  const char *s1; // [esp+18h] [ebp-10h]
  char *s2; // [esp+1Ch] [ebp-Ch]

  s1 = nl_langinfo(14);
  if ( !s1 )
    s1 = (const char *)&unk_806B6AB;
  s2 = (char *)sub_8064771();
  dword_8072238 = (int)&loc_8064DB3;
  sub_8065BD3(v5, v6, v8, v10, v12, v14);
  do
  {
    if ( !strcmp(s1, s2) || *s2 == 42 && !s2[1] )
    {
      v0 = strlen(s2);
      s1 = &s2[v0 + 1];
      dword_807224C = (int)&loc_8064DC1;
      sub_8065B5D(v1, v0 + 1, v2, v7, v9, v11, v13, v15);
    }
    v3 = &s2[strlen(s2) + 1];
    s2 = &v3[strlen(v3) + 1];
  }
  while ( *s2 );
  if ( !*s1 )
    s1 = "ASCII";
  return (char *)s1;
}
// 8064771: using guessed type int sub_8064771(void);
// 8065BD3: using guessed type int __stdcall sub_8065BD3(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8072238: using guessed type int dword_8072238;
// 807224C: using guessed type int dword_807224C;

//----- (08064DDB) --------------------------------------------------------
int __cdecl sub_8064DDB(FILE *stream)
{
  int v2; // eax
  __int64 v3; // rax
  int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]

  v4 = 0;
  if ( fileno(stream) < 0 )
    return fclose(stream);
  if ( !__freading(stream) || (v2 = fileno(stream), LODWORD(v3) = lseek64(v2, 0), v3 != -1) )
  {
    if ( sub_8064EDF(stream) )
      v4 = *__errno_location();
  }
  v5 = fclose(stream);
  if ( v4 )
  {
    *__errno_location() = v4;
    v5 = -1;
  }
  return v5;
}
// 8049A70: using guessed type int __cdecl lseek64(_DWORD, _DWORD);

//----- (08064EA2) --------------------------------------------------------
int __cdecl sub_8064EA2(FILE *stream)
{
  int result; // eax

  result = stream->_flags & 0x100;
  if ( result )
    result = sub_8064F23(stream, 0, 0);
  return result;
}

//----- (08064EDF) --------------------------------------------------------
int __cdecl sub_8064EDF(FILE *fp)
{
  if ( !fp || !__freading(fp) )
    return fflush(fp);
  sub_8064EA2(fp);
  return fflush(fp);
}

//----- (08064F23) --------------------------------------------------------
int __cdecl sub_8064F23(FILE *stream, int a2, int a3)
{
  int v3; // eax
  int v4; // edx
  int v5; // edx
  int result; // eax
  int v7; // ecx
  int v8; // edx
  int v9; // [esp+0h] [ebp-38h]
  int v10; // [esp+4h] [ebp-34h]
  int v11; // [esp+8h] [ebp-30h]
  int v12; // [esp+Ch] [ebp-2Ch]
  int v13; // [esp+14h] [ebp-24h]
  int v14; // [esp+18h] [ebp-20h]

  v14 = a2;
  *(&v9 - 7) = a3;
  if ( *(_DWORD *)(v11 + 8) != *(_DWORD *)(v11 + 4)
    || *(_DWORD *)(v11 + 20) != *(_DWORD *)(v11 + 16)
    || *(_DWORD *)(v11 + 36) )
  {
    v12 = v13;
    result = fseeko64(*(&v9 - 7), *(&v9 - 8), *(&v9 - 7), v13);
  }
  else
  {
    v3 = fileno((FILE *)v11);
    v12 = v13;
    v4 = *(&v9 - 7);
    v10 = *(&v9 - 8);
    v11 = v4;
    *(&v9 - 4) = lseek64(v3, v10);
    *(&v9 - 3) = v5;
    if ( *((_QWORD *)&v9 - 2) == -1LL )
    {
      result = -1;
    }
    else
    {
      *(_DWORD *)v11 &= 0xFFFFFFEF;
      v7 = v11;
      v8 = *(&v9 - 3);
      *(_DWORD *)(v11 + 76) = *(&v9 - 4);
      *(_DWORD *)(v7 + 80) = v8;
      result = 0;
    }
  }
  return result;
}
// 8049610: using guessed type int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8049A70: using guessed type int __cdecl lseek64(_DWORD, _DWORD);

//----- (08065051) --------------------------------------------------------
#error "80651F9: call analysis failed (funcsize=160)"

//----- (08065237) --------------------------------------------------------
int __cdecl sub_8065237(__int64 a1, __int64 a2)
{
  unsigned int v2; // edx
  unsigned int v3; // ecx
  unsigned int v4; // eax
  unsigned int v5; // ecx
  unsigned int v6; // ebp
  __int64 v7; // rdi
  unsigned int v8; // esi
  unsigned __int64 v9; // rax
  int v10; // edx
  void *v11; // eax
  unsigned int v12; // ecx
  unsigned __int64 v13; // rtt
  unsigned __int64 v14; // rax
  __int64 v15; // rdi
  unsigned int v16; // ebp
  unsigned __int64 v17; // rax
  unsigned int v18; // ecx
  unsigned __int64 v19; // rdi
  __int64 v21; // [esp+0h] [ebp-2Ch]
  int v22; // [esp+8h] [ebp-24h]
  int v23; // [esp+Ch] [ebp-20h]
  unsigned int v24; // [esp+10h] [ebp-1Ch]
  unsigned int v25; // [esp+14h] [ebp-18h]
  int v26; // [esp+18h] [ebp-14h]
  unsigned int v27; // [esp+1Ch] [ebp-10h]

  v21 = a1;
  v23 = 0;
  if ( a1 < 0 )
  {
    v21 = -v21;
    v23 = -1;
  }
  v3 = HIDWORD(a2);
  v2 = a2;
  if ( a2 < 0 )
  {
    v2 = -(signed int)a2;
    v3 = (unsigned __int64)-a2 >> 32;
  }
  v4 = v3;
  v5 = v2;
  v24 = v2;
  v6 = HIDWORD(v21);
  v25 = v21;
  v7 = v21;
  if ( v4 )
  {
    if ( v4 <= HIDWORD(v21) )
    {
      _BitScanReverse((unsigned int *)&v10, v4);
      LODWORD(v21) = v10 ^ 0x1F;
      if ( v10 ^ 0x1F )
      {
        v26 = 32 - v21;
        LODWORD(v7) = (v4 << v21) | (v24 >> (32 - v21));
        v27 = v24 << v21;
        HIDWORD(v14) = HIDWORD(v7) >> (32 - v21);
        LODWORD(v14) = (HIDWORD(v7) << v21) | (v25 >> (32 - v21));
        v25 <<= v21;
        HIDWORD(v7) = v14 % (unsigned int)v7;
        v17 = (unsigned int)&v21 * (unsigned __int64)(unsigned int)(v14 / (unsigned int)v7);
        v24 = HIDWORD(v17);
        v16 = HIDWORD(v17);
        HIDWORD(v17) = v17;
        v18 = v16;
        if ( HIDWORD(v7) < v16 || v25 < (unsigned int)v17 && HIDWORD(v15) == v16 )
        {
          v18 = (__PAIR__(v24, (unsigned int)v17) - __PAIR__(v15, v27)) >> 32;
          HIDWORD(v17) = v17 - v27;
        }
        LODWORD(v15) = v25;
        v19 = v15 - __PAIR__(v18, HIDWORD(v17));
        LODWORD(v9) = (HIDWORD(v19) << v26) | ((unsigned int)v19 >> v21);
        HIDWORD(v9) = HIDWORD(v19) >> (char)&v21;
      }
      else
      {
        if ( v5 <= (unsigned int)v7 || v4 < HIDWORD(v7) )
        {
          v7 -= __PAIR__(v4, v5);
          v6 = HIDWORD(v7);
        }
        v9 = __PAIR__(v6, (unsigned int)v7);
      }
    }
    else
    {
      v9 = v21;
    }
  }
  else
  {
    if ( v2 <= HIDWORD(v21) )
    {
      v11 = &loc_8065336;
      if ( v2 )
        v11 = &loc_8065341;
      dword_807224C = (int)v11;
      sub_8065B5D(v2, v2, v21, HIDWORD(v21), v22, v23, v24, v25);
      v12 = 1 / v12;
      LODWORD(v13) = v7;
      HIDWORD(v13) = v6 % v12;
      v8 = v13 % v12;
    }
    else
    {
      v8 = __PAIR__(HIDWORD(v21), v25) % v2;
    }
    v9 = v8;
  }
  if ( v23 )
    v9 = -(signed __int64)v9;
  return v9;
}
// 807224C: using guessed type int dword_807224C;

//----- (08065498) --------------------------------------------------------
#error "80654D6: call analysis failed (funcsize=20)"

//----- (080654DB) --------------------------------------------------------
#error "8065543: positive sp value has been found (funcsize=36)"

//----- (08065666) --------------------------------------------------------
int __cdecl sub_8065666(unsigned __int64 a1, __int64 a2)
{
  int v4; // ebp
  int v5; // ebp
  unsigned int v6; // ebp
  unsigned __int64 v7; // rtt
  unsigned __int64 v8; // rax
  unsigned int v9; // edi
  unsigned __int64 v10; // rax
  unsigned int v11; // ecx
  void *v12; // eax
  unsigned int v13; // [esp+0h] [ebp-20h]
  unsigned int v14; // [esp+4h] [ebp-1Ch]
  unsigned __int64 v15; // [esp+8h] [ebp-18h]
  unsigned int v16; // [esp+10h] [ebp-10h]

  v14 = HIDWORD(a1);
  v16 = a1;
  v13 = a2;
  v15 = a1;
  if ( !HIDWORD(a2) )
  {
    if ( (unsigned int)a2 > HIDWORD(a1) )
      return a1 % (unsigned int)a2;
    v6 = a2;
    if ( !(_DWORD)a2 )
      v6 = 1 / 0u;
    LODWORD(v7) = a1;
    HIDWORD(v7) = v14 % v6;
    return v7 % v6;
  }
  if ( HIDWORD(a2) > HIDWORD(a1) )
    return a1;
  _BitScanReverse((unsigned int *)&v4, HIDWORD(a2));
  v5 = v4 ^ 0x1F;
  if ( v5 )
  {
    v14 = v13 >> (32 - v5);
    v14 |= HIDWORD(a2) << v5;
    LODWORD(v15) = v13 << v5;
    HIDWORD(v8) = HIDWORD(a1) >> (32 - v5);
    LODWORD(v8) = (HIDWORD(a1) << (char)&v13) | (v16 >> (32 - v5));
    HIDWORD(v15) = v16 << (char)&v13;
    v9 = v8 % v14;
    v10 = (v13 << v5) * (unsigned __int64)(unsigned int)(v8 / v14);
    v13 = HIDWORD(v10);
    v11 = v10;
    if ( v9 >= HIDWORD(v10) )
    {
      if ( HIDWORD(v15) >= (unsigned int)v10 )
        return ((__PAIR__(v9, HIDWORD(v15)) - __PAIR__(HIDWORD(v10), v11)) >> 32 << (32 - (unsigned __int8)v5)) | ((HIDWORD(v15) - v11) >> (char)&v13);
      LODWORD(v10) = &loc_8065813;
      if ( v9 != HIDWORD(v10) )
        v12 = &loc_80657B5;
      dword_80721DC = (int)v12;
      LODWORD(v10) = sub_8065E0F(v11);
    }
    HIDWORD(v10) = v13;
    HIDWORD(v10) = (v10 - __PAIR__(v14, (unsigned int)v15)) >> 32;
    v11 = v10 - v15;
    return ((__PAIR__(v9, HIDWORD(v15)) - __PAIR__(HIDWORD(v10), v11)) >> 32 << (32 - (unsigned __int8)v5)) | ((HIDWORD(v15) - v11) >> (char)&v13);
  }
  if ( v13 <= (unsigned int)v15 || HIDWORD(a2) < HIDWORD(v15) )
    v15 = __PAIR__(v14, (unsigned int)a1) - a2;
  return v15;
}
// 8065E0F: using guessed type int __fastcall sub_8065E0F(_DWORD);
// 80721DC: using guessed type int dword_80721DC;

//----- (080658A6) --------------------------------------------------------
int __cdecl sub_80658A6(int a1)
{
  return __cxa_atexit(a1, 0, dword_8072290);
}
// 80497B0: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 8072290: using guessed type int dword_8072290;

//----- (080658D5) --------------------------------------------------------
int __cdecl sub_80658D5(int a1, int a2)
{
  return __xstat64(3, a1, a2);
}
// 8049AE0: using guessed type int __cdecl __xstat64(_DWORD, _DWORD, _DWORD);

//----- (08065934) --------------------------------------------------------
int __cdecl sub_8065934(int a1, int a2)
{
  return __fxstat64(3, a1, a2);
}
// 8049730: using guessed type int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD);

//----- (08065967) --------------------------------------------------------
int __cdecl sub_8065967(int a1, int a2)
{
  return __lxstat64(3, a1, a2);
}
// 8049AF0: using guessed type int __cdecl __lxstat64(_DWORD, _DWORD, _DWORD);

//----- (08065ABA) --------------------------------------------------------
#error "8065AC0: positive sp value has been found (funcsize=0)"

//----- (08065B5D) --------------------------------------------------------
#error "8065B63: positive sp value has been found (funcsize=0)"

//----- (08065BD3) --------------------------------------------------------
#error "8065BD9: positive sp value has been found (funcsize=0)"

//----- (08065C47) --------------------------------------------------------
#error "8065C4D: positive sp value has been found (funcsize=0)"

//----- (08065CCF) --------------------------------------------------------
#error "8065CD5: positive sp value has been found (funcsize=0)"

//----- (08065D3B) --------------------------------------------------------
#error "8065D41: positive sp value has been found (funcsize=0)"

//----- (08065E0F) --------------------------------------------------------
#error "8065E15: positive sp value has been found (funcsize=0)"

//----- (08065E20) --------------------------------------------------------
int (**sub_8065E20())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_8071EDC;
  v1 = &off_8071EE0 - off_8071EDC;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_8071EDC[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 8071EDC: using guessed type int (*off_8071EDC[2])();
// 8071EE0: using guessed type int (*off_8071EE0)();

//----- (08065E84) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 107 decompilation failure(s) on 384 function(s)"
