/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8048F10();
// int __cdecl freopen64(_DWORD, _DWORD, _DWORD); weak
// int dup2(int fd, int fd2);
// int strcmp(const char *s1, const char *s2);
// int __cdecl open64(_DWORD, _DWORD); weak
// ssize_t read(int fd, void *buf, size_t nbytes);
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void _exit(int status);
// void free(void *ptr);
// void *memcpy(void *dest, const void *src, size_t n);
// int ferror(FILE *stream);
// int fclose(FILE *stream);
// int getc_unlocked(FILE *stream);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// __uid_t getuid(void);
// char *textdomain(const char *domainname);
// int __cdecl fopen64(_DWORD, _DWORD); weak
// int ferror_unlocked(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD); weak
// size_t __ctype_get_mb_cur_max(void);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// size_t __fpending(FILE *fp);
// __pid_t getpid(void);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// void error(int status, int errnum, const char *format, ...);
// size_t fread_unlocked(void *ptr, size_t size, size_t n, FILE *stream);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int __freading(FILE *fp);
// void exit(int status);
// int __cdecl ftello64(_DWORD); weak
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// char *strchr(const char *s, int c);
// size_t strlen(const char *s);
// int fprintf(FILE *stream, const char *format, ...);
// int fcntl(int fd, int cmd, ...);
// int setvbuf(FILE *stream, char *buf, int modes, size_t n);
// __gid_t getgid(void);
// void *memset(void *s, int c, size_t n);
// int *__errno_location(void);
// void *memchr(const void *s, int c, size_t n);
// int fileno(FILE *stream);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// char *strrchr(const char *s, int c);
// __pid_t getppid(void);
// int __cdecl explicit_bzero(_DWORD, _DWORD); weak
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// char *bindtextdomain(const char *domainname, const char *dirname);
// int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// int feof_unlocked(FILE *stream);
// void abort(void);
// int close(int fd);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// void *calloc(size_t nmemb, size_t size);
// int _gmon_start__(void); weak
void sub_8049423();
void sub_8049440();
int sub_8049450();
int sub_80494C0();
int sub_80494E0();
void sub_804953F();
void sub_804955A();
int sub_804956A();
void sub_804964C();
void sub_8049667();
int sub_8049677();
void sub_8049759();
void sub_8049774();
signed int sub_8049784();
signed int sub_804980E();
void sub_8049882();
void sub_804989D();
int sub_80498AD();
// int __usercall sub_8049914@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
void sub_80499AB();
void sub_80499C6();
int sub_80499D6();
int sub_8049A60();
void sub_8049AD4();
void sub_8049AEF();
int sub_8049AFF();
void sub_8049BE1();
void sub_8049BFC();
int sub_8049C0C();
// int __usercall sub_8049C73@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
void sub_8049D0A();
void sub_8049D25();
int sub_8049D35();
void sub_8049E2C();
void sub_8049E47();
int sub_8049E57();
void sub_8049F39();
void sub_8049F54();
int sub_8049F64();
void sub_804A046();
void sub_804A061();
int sub_804A071();
void sub_804A17A();
void sub_804A195();
int sub_804A1A5();
void sub_804A2BC();
void sub_804A2D7();
int sub_804A2E7();
int sub_804A371();
void sub_804A3F7();
void sub_804A412();
int sub_804A422();
void sub_804A504();
void sub_804A51F();
int sub_804A52F();
// int __usercall sub_804A596@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
int sub_804A5D2();
void sub_804A658();
void sub_804A673();
int sub_804A683();
void sub_804A77A();
void sub_804A795();
int sub_804A7A5();
int nullsub_6(void); // weak
int sub_804A803();
int sub_804A848();
void sub_804A8E7();
void sub_804A902();
int sub_804A912();
int sub_804A99C();
void sub_804AA22();
void sub_804AA3D();
int sub_804AA4D();
void sub_804AB44();
void sub_804AB5F();
int sub_804AB6F();
int sub_804AC4D();
int sub_804AC78();
int __cdecl sub_804ACA3(char *s1); // idb
int __cdecl sub_804AE70(int a1);
void __cdecl __noreturn sub_804AEA8(int *a1, __int64 a2);
int __fastcall sub_804AEDB(int ecx0, int a2, int a1);
void __cdecl __noreturn sub_804AF37(int, int, int); // weak
int __cdecl sub_804B020(int a1, signed int a2);
char *__cdecl sub_804B101(void *s, int a2, size_t n);
__int64 sub_804B132();
int __cdecl sub_804B201(FILE *stream, int, int, int, int); // idb
int __fastcall sub_804B46C(int a1, int a2);
int __cdecl sub_804B48C(size_t size, size_t n, FILE *stream); // idb
unsigned int __cdecl sub_804B545(FILE *stream, int a2, int a3);
signed int __cdecl sub_804B6CD(unsigned int a1, int a2, int a3);
signed int __cdecl sub_804B757(unsigned int a1, int a2, int a3, char a4);
void __cdecl __noreturn sub_804B7BE(int *a1, int a2, int a3, int a4, char a5);
int sub_804B84C(); // weak
void __cdecl __noreturn sub_804B85B(int *a1, int a2, int a3, unsigned int a4);
int sub_804B917(); // weak
int __cdecl main(int argc, char **argv);
int sub_804C487();
int __cdecl sub_804C56B(int a1, int a2, int a3, int a4, int a5, int a6);
void __cdecl sub_804C5BC(FILE *stream, int a2);
signed int __cdecl sub_804C604(int a1);
FILE *__cdecl sub_804C653(int a1, int a2, FILE *stream);
void *__cdecl sub_804C82D(void *s);
int __cdecl sub_804C872(int, FILE *stream, int); // idb
void __cdecl sub_804C9BE(int a1);
char *__cdecl sub_804C9D4(char *s);
int __cdecl sub_804CB52(int *a1, unsigned __int8 a2, char a3);
int __fastcall sub_804CC15(int a1, int a2, int a3, int a4, int a5);
int sub_804CC78(); // weak
// _DWORD *__userpurge sub_804CC8C@<eax>(_DWORD *a1, int a2);
const char *__cdecl sub_804CD0E(char *msgid, int a2);
int __cdecl sub_804CDA9(int a1, unsigned int a2, char *a3, size_t a4, signed int a5, int a6, int a7, char *a8, char *a9);
int __cdecl sub_804DDE4(char *a1, size_t a2, _DWORD *a3, int *a4);
int __cdecl sub_804DF8B(int a1);
// int __usercall sub_804DFC1@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebp>, int a4, unsigned int a5);
// int __usercall sub_804E00B@<eax>(int a1@<ecx>, int a2@<ebp>);
int __cdecl sub_804E23B(int a1);
int __cdecl sub_804E265(int a1);
int __cdecl sub_804E2CB(int a1, int a2);
int __cdecl sub_804E309(int a1, int a2);
int __cdecl sub_804E391(int a1, int a2, unsigned __int8 a3);
int __cdecl sub_804E43B(int a1, unsigned __int8 a2);
int __cdecl sub_804E464(int a1);
int __cdecl sub_804E4A1(int a1, int a2);
// int __usercall sub_804E542@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5);
// int __usercall sub_804E572@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5);
int __cdecl sub_804E66C(int a1);
int __cdecl sub_804E6B7(int a1);
int sub_804E6D9();
_DWORD *__cdecl sub_804E6F4(int a1);
int __cdecl sub_804E739(int, size_t n); // idb
__int64 __cdecl sub_804E78D(__int64 a1);
int __cdecl __noreturn sub_804E7AE(int *a1, unsigned __int64 a2);
int sub_804EABD(); // weak
void __cdecl sub_804EAC8(void *ptr);
void __cdecl __noreturn sub_804EB28(int *a1, __int64 a2);
int __cdecl sub_804EB5B(int a1);
unsigned int __cdecl sub_804EB85(int a1, int a2);
int __cdecl sub_804EBB4(int a1, int a2, int a3);
int __cdecl sub_804EC06(_DWORD *a1, unsigned int a2);
bool __cdecl sub_804EC23(_DWORD *a1, _DWORD *a2);
void *__cdecl sub_804EC46(unsigned int a1);
int __cdecl sub_804EC79(unsigned int *a1, int a2, int a3, int a4);
void __cdecl sub_804ED82(void *a1);
void *__cdecl sub_804ED95(int *a1, unsigned int a2, unsigned int a3);
void __cdecl __noreturn sub_804EF8D(int a1);
_DWORD *__cdecl sub_804F00F(int a1, int a2);
unsigned int __cdecl sub_804F044(int a1, int a2, size_t nbytes);
char *__cdecl sub_804F251(int a1, size_t n);
size_t __cdecl sub_804F366(int a1, void *ptr, size_t n);
int __cdecl sub_804F3EE(int, void *dest, size_t n); // idb
// size_t __usercall sub_804F50F@<eax>(int edx0@<edx>, int a2@<ecx>, int a1, void *ptr, size_t n);
int __cdecl sub_804F575(unsigned int *a1, unsigned int a2, int a3);
int __cdecl sub_804F5B0(int a1);
int __cdecl sub_804F5C7(int a1, __int16 a2);
unsigned int *__cdecl sub_804F5F8(unsigned int *a1, int *a2);
_DWORD *__cdecl sub_804FA9D(_DWORD *a1);
void *__cdecl sub_804FEC1(FILE *stream, int a2);
int __cdecl sub_805017D(int a1, int a2, int a3);
int __cdecl sub_80501DD(int); // weak
int __cdecl sub_80502C7(FILE *stream, int, int, int, int, int); // idb
int __cdecl sub_8050857(FILE *stream, int, int, int, int); // idb
int sub_80508D2(FILE *stream, int a2, int a3, int a4, ...);
int __cdecl sub_8050972(unsigned int a1, unsigned int a2);
void *__cdecl sub_80509A0(void *ptr, int a2, int a3);
void *__cdecl sub_80509D5(void *ptr, int a2, int a3);
int __cdecl sub_8050A85(size_t size); // idb
int __cdecl sub_8050A98(size_t size); // idb
int sub_8050AF6(); // weak
void *__cdecl sub_8050AFB(void *ptr, size_t size);
void *__cdecl sub_8050B63(void *ptr, int a2);
void *__cdecl sub_8050BAF(size_t nmemb, size_t size);
void *__cdecl sub_8050BEC(void *src, size_t n);
void __noreturn sub_8050C3A();
unsigned __int64 __cdecl sub_8050C73(char *nptr, int base, int a3, int a4, int a5, int a6, char *s, int a8, int status);
unsigned __int64 __cdecl sub_8050DCA(char *nptr, int a2, int a3, int a4, int a5, char *s, int a7, int status);
int __cdecl sub_8050E2E(unsigned int *a1, unsigned int a2);
int __cdecl sub_8050E9E(void *ptr); // idb
// int __usercall sub_8050EE9@<eax>(int a1@<edx>, int a2@<ecx>, char *nptr, int a4, int base, int a6, char *s);
signed int __cdecl sub_80513C9(int a1, int a2);
int __cdecl sub_8051455(int a1, int a2, int a3);
int __cdecl sub_805148B(char *nptr, int a2, int base);
int __cdecl sub_8051990(FILE *stream); // idb
int __cdecl sub_8051A97(FILE *stream); // idb
int __cdecl sub_8051AE9(FILE *fp); // idb
int __cdecl sub_8051B29(FILE *stream, int, int, int); // idb
size_t __cdecl sub_8051C2D(wchar_t *pwc, char *s, size_t n, mbstate_t *p);
int __cdecl sub_8051C9F(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_8051D1D(FILE *fp); // idb
FILE *__cdecl sub_8051DB7(int a1, char *modes);
int __cdecl sub_8051E8D(int category); // idb
int __cdecl sub_8051F04(int a1);
int __cdecl sub_8051F0F(int a1);
int __cdecl sub_8051F1A(int a1);
unsigned int __cdecl sub_8051F25(int a1);
int __cdecl sub_80520F3(int a1, int a2);
int __fastcall sub_8052492(int a1, int a2);
// int __usercall sub_805251E@<eax>(int a1@<edx>, int a2@<ecx>, unsigned int a3);
unsigned int __cdecl sub_805258F(int a1, unsigned int a2);
bool __cdecl sub_80525BA(int a1, int a2);
signed int __cdecl sub_80525C8(int a1);
// unsigned int __usercall sub_8052684@<eax>(signed __int64 a1@<edx:eax>, int a2@<ecx>, unsigned int a3, int a4);
void *__cdecl sub_8052711(unsigned int a1, void *a2, unsigned int (__cdecl *a3)(int a1, unsigned int a2), bool (__cdecl *a4)(int a1, int a2), int a5);
void __cdecl sub_8052912(void *a1);
void *__cdecl sub_8052A34(int a1);
int __cdecl sub_8052A6F(int a1, _DWORD *a2);
int __cdecl sub_8052A92(int a1, int a2, _DWORD *a3, char a4);
int __fastcall sub_8052C0C(int ecx0, int edx0, int a1, int *a2, char a3);
// int __usercall sub_8052E01@<eax>(int a1@<ebp>, int a2@<ecx>);
int sub_8052E48(); // weak
int sub_8052E64(); // weak
// signed int __usercall sub_8052E88@<eax>(signed __int64 a1@<edx:eax>, int a2@<ecx>, int a3, unsigned int a4);
signed int __cdecl sub_805303D(unsigned int *a1, int a2, _DWORD *a3);
int __cdecl sub_805328C(unsigned int *a1, int a2);
// int __usercall sub_80532F4@<eax>(int a1@<ebp>, int a2@<edx>, int a3@<ecx>);
int sub_805330A(); // weak
int sub_805330F(); // weak
int __cdecl sub_8053311(int a1, int a2);
void *sub_805350B();
const char *sub_8053A47();
int __cdecl sub_8053B13(int fd); // idb
int __cdecl sub_8053B36(int fd, int cmd, char); // idb
int __cdecl sub_8053DB5(int a1, char a2);
int __cdecl sub_80540EC(int a1);
__int64 __cdecl sub_805412C(unsigned int a1, unsigned int a2, int a3, int a4);
int __cdecl sub_8054265(unsigned __int64 a1, __int64 a2);
int __cdecl sub_8054428(int a1);
int __cdecl sub_8054457(int a1, int a2);
int __fastcall sub_80545C3(_DWORD, _DWORD);
int __fastcall sub_8054652(_DWORD, _DWORD); // weak
int sub_80546C8(void); // weak
int sub_8054736(void); // weak
int sub_80547B0(void); // weak
int sub_8054854(void); // weak
int sub_80548CA(void); // weak
int sub_805495D(void); // weak
int sub_80549D7(void); // weak
int sub_8054A4D(void); // weak
int sub_8054AE0(void); // weak
int __fastcall sub_8054B5A(_DWORD, _DWORD); // weak
int sub_8054BCA(void); // weak
int sub_8054C3E(void); // weak
int sub_8054CB6(void); // weak
int __fastcall sub_8054D26(_DWORD, _DWORD); // weak
int __fastcall sub_8054D9E(_DWORD, _DWORD); // weak
int (**sub_8054DB0())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN locret_804A1B4; // weak
_UNKNOWN loc_804AD1A; // weak
_UNKNOWN loc_804AD58; // weak
_UNKNOWN loc_804ADE4; // weak
_UNKNOWN loc_804ADFF; // weak
_UNKNOWN loc_804AE4B; // weak
_UNKNOWN loc_804B015; // weak
_UNKNOWN loc_804B07A; // weak
_UNKNOWN loc_804B0EB; // weak
_UNKNOWN locret_804B1FF; // weak
_UNKNOWN loc_804B524; // weak
_UNKNOWN loc_804B58D; // weak
_UNKNOWN loc_804B5B6; // weak
_UNKNOWN loc_804B6BC; // weak
_UNKNOWN loc_804BCC5; // weak
_UNKNOWN loc_804BDD4; // weak
_UNKNOWN loc_804BFAF; // weak
_UNKNOWN loc_804C01D; // weak
_UNKNOWN loc_804C057; // weak
_UNKNOWN loc_804C088; // weak
_UNKNOWN loc_804C0B2; // weak
_UNKNOWN loc_804C117; // weak
_UNKNOWN loc_804C1E5; // weak
_UNKNOWN loc_804C21F; // weak
_UNKNOWN loc_804C2DF; // weak
_UNKNOWN loc_804C2EC; // weak
_UNKNOWN loc_804C3B3; // weak
_UNKNOWN loc_804C3D5; // weak
_UNKNOWN loc_804C693; // weak
_UNKNOWN loc_804C6B4; // weak
_UNKNOWN loc_804C721; // weak
_UNKNOWN loc_804C72D; // weak
_UNKNOWN loc_804C74C; // weak
_UNKNOWN loc_804C768; // weak
_UNKNOWN loc_804C79A; // weak
_UNKNOWN loc_804C7A3; // weak
_UNKNOWN loc_804C81E; // weak
_UNKNOWN loc_804C828; // weak
_UNKNOWN loc_804C8F5; // weak
_UNKNOWN loc_804C916; // weak
_UNKNOWN loc_804C925; // weak
_UNKNOWN loc_804C946; // weak
_UNKNOWN locret_804C9BC; // weak
_UNKNOWN loc_804CA5C; // weak
_UNKNOWN loc_804CABC; // weak
_UNKNOWN loc_804CACD; // weak
_UNKNOWN loc_804CC3A; // weak
_UNKNOWN loc_804CC73; // weak
_UNKNOWN loc_804CF85; // weak
_UNKNOWN loc_804CFA3; // weak
_UNKNOWN loc_804CFCE; // weak
_UNKNOWN loc_804CFED; // weak
_UNKNOWN loc_804D037; // weak
_UNKNOWN loc_804D07E; // weak
_UNKNOWN loc_804D0CB; // weak
_UNKNOWN loc_804D0E2; // weak
_UNKNOWN loc_804D1FA; // weak
_UNKNOWN loc_804D21E; // weak
_UNKNOWN loc_804D223; // weak
_UNKNOWN loc_804D228; // weak
_UNKNOWN loc_804D397; // weak
_UNKNOWN loc_804D3A8; // weak
_UNKNOWN loc_804D3CB; // weak
_UNKNOWN loc_804D3EA; // weak
_UNKNOWN loc_804D408; // weak
_UNKNOWN loc_804D43F; // weak
_UNKNOWN loc_804D467; // weak
_UNKNOWN loc_804D46C; // weak
_UNKNOWN loc_804D48F; // weak
_UNKNOWN loc_804D49A; // weak
_UNKNOWN loc_804D5CA; // weak
_UNKNOWN loc_804D5D8; // weak
_UNKNOWN loc_804D63B; // weak
_UNKNOWN loc_804D644; // weak
_UNKNOWN loc_804D730; // weak
_UNKNOWN loc_804D754; // weak
_UNKNOWN loc_804D75F; // weak
_UNKNOWN loc_804D7A6; // weak
_UNKNOWN loc_804D7FA; // weak
_UNKNOWN loc_804D92C; // weak
_UNKNOWN loc_804D99C; // weak
_UNKNOWN loc_804DA2E; // weak
_UNKNOWN loc_804DAAF; // weak
_UNKNOWN loc_804DAB3; // weak
_UNKNOWN loc_804DAB7; // weak
_UNKNOWN loc_804DAED; // weak
_UNKNOWN loc_804DB0A; // weak
_UNKNOWN loc_804DB35; // weak
_UNKNOWN loc_804DB3A; // weak
_UNKNOWN loc_804DB59; // weak
_UNKNOWN loc_804DBD7; // weak
_UNKNOWN loc_804DBF6; // weak
_UNKNOWN loc_804DC1A; // weak
_UNKNOWN loc_804DC46; // weak
_UNKNOWN loc_804DC73; // weak
_UNKNOWN loc_804DC98; // weak
_UNKNOWN loc_804DC9F; // weak
_UNKNOWN loc_804DCE8; // weak
_UNKNOWN sub_804E048; // weak
_UNKNOWN loc_804E04B; // weak
_UNKNOWN loc_804E0D3; // weak
_UNKNOWN locret_804E781; // weak
_UNKNOWN loc_804EA93; // weak
_UNKNOWN loc_804EAB8; // weak
_UNKNOWN loc_804EF49; // weak
_UNKNOWN loc_804EF6B; // weak
_UNKNOWN loc_804EF88; // weak
_UNKNOWN loc_804EFB4; // weak
_UNKNOWN loc_804F00A; // weak
_UNKNOWN loc_804F2DD; // weak
_UNKNOWN loc_804F310; // weak
_UNKNOWN loc_804F3FC; // weak
_UNKNOWN loc_804F537; // weak
_UNKNOWN loc_804F552; // weak
_UNKNOWN loc_804FAE7; // weak
_UNKNOWN loc_804FFC3; // weak
_UNKNOWN loc_805010B; // weak
_UNKNOWN locret_805017B; // weak
_UNKNOWN loc_80501C5; // weak
_UNKNOWN locret_8050281; // weak
_UNKNOWN loc_80507DE; // weak
_UNKNOWN loc_805087F; // weak
_UNKNOWN loc_8050A08; // weak
_UNKNOWN loc_8050A25; // weak
_UNKNOWN loc_8050AF1; // weak
_UNKNOWN loc_8050B20; // weak
_UNKNOWN loc_8050B38; // weak
_UNKNOWN loc_8050D44; // weak
_UNKNOWN loc_8050D51; // weak
_UNKNOWN loc_8050E85; // weak
_UNKNOWN loc_8050F1B; // weak
_UNKNOWN loc_8050F3A; // weak
_UNKNOWN loc_8050F3C; // weak
_UNKNOWN loc_8050F7A; // weak
_UNKNOWN loc_8050F7D; // weak
_UNKNOWN loc_805104A; // weak
_UNKNOWN loc_8051068; // weak
_UNKNOWN loc_80510BE; // weak
_UNKNOWN loc_805113B; // weak
_UNKNOWN loc_805114E; // weak
_UNKNOWN locret_80513C7; // weak
_UNKNOWN loc_80514BD; // weak
_UNKNOWN loc_80514C5; // weak
_UNKNOWN loc_805155A; // weak
_UNKNOWN loc_8051564; // weak
_UNKNOWN loc_8051A3B; // weak
_UNKNOWN loc_8051A54; // weak
_UNKNOWN loc_8051A81; // weak
_UNKNOWN loc_8051A92; // weak
_UNKNOWN locret_8051A95; // weak
_UNKNOWN loc_8051AC4; // weak
_UNKNOWN locret_8051AE7; // weak
_UNKNOWN loc_8051B78; // weak
_UNKNOWN loc_8051C0B; // weak
_UNKNOWN locret_8051C2B; // weak
_UNKNOWN loc_8051CF9; // weak
_UNKNOWN loc_8051CFB; // weak
_UNKNOWN loc_8051D7B; // weak
_UNKNOWN loc_8051D93; // weak
_UNKNOWN loc_8051EE3; // weak
_UNKNOWN loc_8051EFA; // weak
_UNKNOWN loc_80524CD; // weak
_UNKNOWN loc_8052832; // weak
_UNKNOWN loc_805295C; // weak
_UNKNOWN loc_8052964; // weak
_UNKNOWN loc_805299C; // weak
_UNKNOWN loc_8052AF1; // weak
_UNKNOWN loc_8052B0C; // weak
_UNKNOWN loc_8052B93; // weak
_UNKNOWN loc_8052BB1; // weak
_UNKNOWN locret_805328A; // weak
_UNKNOWN loc_805337C; // weak
_UNKNOWN loc_80534C3; // weak
_UNKNOWN loc_80534FC; // weak
_UNKNOWN loc_8053506; // weak
_UNKNOWN loc_8053580; // weak
_UNKNOWN loc_805358D; // weak
_UNKNOWN loc_805360B; // weak
_UNKNOWN loc_805374A; // weak
_UNKNOWN loc_8053767; // weak
_UNKNOWN loc_8053B07; // weak
_UNKNOWN loc_8053B0E; // weak
_UNKNOWN loc_8053D9A; // weak
_UNKNOWN loc_8054168; // weak
_UNKNOWN loc_8054194; // weak
char s = '\0'; // idb
struct option longopts = { "echo", 0, NULL, 101 }; // idb
_UNKNOWN unk_8055776; // weak
_UNKNOWN unk_805577A; // weak
_UNKNOWN unk_8055786; // weak
_UNKNOWN unk_805578A; // weak
_UNKNOWN unk_805578D; // weak
char aLicenseGplv3Gn[128] = "\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\nThis is free software: you are free to change an"; // idb
char aWritt[5] = "Writt"; // idb
_UNKNOWN unk_8056258; // weak
_UNKNOWN unk_805634F; // weak
_UNKNOWN unk_80571E8; // weak
_UNKNOWN unk_80571EB; // weak
_UNKNOWN unk_8058238; // weak
_UNKNOWN unk_805823B; // weak
_UNKNOWN unk_805929C; // weak
_UNKNOWN unk_805929F; // weak
int (*off_805AEB8[2])() = { &sub_80494E0, &sub_80494C0 }; // weak
int (*off_805AEBC)() = &sub_80494C0; // weak
int (*dword_805B008)(void) = NULL; // weak
int dword_805B148 = 0; // weak
int dword_805B15C = 0; // weak
int dword_805B170 = 0; // weak
int dword_805B184 = 0; // weak
int dword_805B198 = 0; // weak
int dword_805B1AC = 0; // weak
int dword_805B1C0 = 0; // weak
int dword_805B1D4 = 0; // weak
int dword_805B1E8 = 0; // weak
int dword_805B1FC = 0; // weak
int dword_805B210 = 0; // weak
int dword_805B224 = 0; // weak
int dword_805B238 = 0; // weak
int dword_805B24C = 0; // weak
int dword_805B260 = 0; // weak
int dword_805B274 = 0; // weak
int dword_805B288 = 0; // weak
int (__fastcall *dword_805B2A4)(_DWORD, _DWORD) = NULL; // weak
int dword_805B2BC = 0; // weak
int off_805B2C0 = 134567474; // idb
int status = 1; // idb
int dword_805B2D8 = 1; // weak
_UNKNOWN unk_805B314; // weak
_UNKNOWN unk_805B317; // weak
_UNKNOWN unk_805B318; // weak
_UNKNOWN unk_805B31B; // weak
_UNKNOWN unk_805B31C; // weak
_UNKNOWN unk_805B31F; // weak
_UNKNOWN unk_805B320; // weak
_UNKNOWN unk_805B323; // weak
_UNKNOWN unk_805B328; // weak
_UNKNOWN unk_805B32B; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int program_invocation_name; // weak
int optind; // weak
FILE *stdin; // idb
FILE *stdout; // idb
char *optarg; // idb
char byte_805B38C; // weak
_UNKNOWN unk_805B3DD; // weak
char byte_805B473; // weak
char byte_805B50D; // weak
_UNKNOWN unk_805B645; // weak
char byte_805B775; // weak
char byte_805B80F; // weak
char byte_805B8A9; // weak
char byte_805B8F6; // weak
int dword_805B994; // weak
char byte_805B998; // weak
int dword_805B99C; // weak
int dword_805B9A4; // weak
int dword_805B9A8; // weak
int dword_805B9AC; // weak
int dword_805B9B0; // weak
int dword_805B9B4; // weak
int dword_805B9B8; // weak
int dword_805B9BC; // weak
int dword_805B9C0; // weak
int dword_805B9C4; // weak
int dword_805B9C8; // weak
int dword_805B9CC; // weak
int dword_805B9D0; // weak
int dword_805BAE4; // weak
int dword_805BAE8; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (08048EEC) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 80493E0: using guessed type int _gmon_start__(void);

//----- (08048F10) --------------------------------------------------------
int sub_8048F10()
{
  return dword_805B008();
}
// 805B008: using guessed type int (*dword_805B008)(void);

//----- (080493F0) --------------------------------------------------------
#error "80493F3: positive sp value has been found (funcsize=2)"

//----- (08049423) --------------------------------------------------------
void sub_8049423()
{
  ;
}

//----- (08049440) --------------------------------------------------------
void sub_8049440()
{
  ;
}

//----- (08049450) --------------------------------------------------------
int sub_8049450()
{
  int result; // eax

  result = &unk_805B32B - &unk_805B328;
  if ( (unsigned int)(&unk_805B32B - &unk_805B328) > 6 )
    result = 0;
  return result;
}
// 8049450: could not find valid save-restore pair for ebp

//----- (080494C0) --------------------------------------------------------
int sub_80494C0()
{
  int result; // eax

  if ( !byte_805B38C )
  {
    result = sub_8049450();
    byte_805B38C = 1;
  }
  return result;
}
// 80494C0: could not find valid save-restore pair for ebp
// 805B38C: using guessed type char byte_805B38C;

//----- (080494E0) --------------------------------------------------------
int sub_80494E0()
{
  return 0;
}
// 80494E0: could not find valid save-restore pair for ebp

//----- (0804953F) --------------------------------------------------------
void sub_804953F()
{
  ;
}

//----- (0804955A) --------------------------------------------------------
void sub_804955A()
{
  ;
}

//----- (0804956A) --------------------------------------------------------
int sub_804956A()
{
  int result; // eax

  result = &unk_805B317 - &unk_805B314;
  if ( (unsigned int)(&unk_805B317 - &unk_805B314) > 6 )
    result = 0;
  return result;
}
// 804956A: could not find valid save-restore pair for ebp

//----- (0804964C) --------------------------------------------------------
void sub_804964C()
{
  ;
}

//----- (08049667) --------------------------------------------------------
void sub_8049667()
{
  ;
}

//----- (08049677) --------------------------------------------------------
int sub_8049677()
{
  int result; // eax

  result = &unk_805B3DD - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_805B3DD - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 8049677: could not find valid save-restore pair for ebp
// 805B340: using guessed type int program_invocation_short_name;

//----- (08049759) --------------------------------------------------------
void sub_8049759()
{
  ;
}

//----- (08049774) --------------------------------------------------------
void sub_8049774()
{
  ;
}

//----- (08049784) --------------------------------------------------------
signed int sub_8049784()
{
  return 3;
}
// 8049784: could not find valid save-restore pair for ebp

//----- (0804980E) --------------------------------------------------------
signed int sub_804980E()
{
  signed int result; // eax

  result = sub_8049784();
  byte_805B473 = 1;
  return result;
}
// 805B473: using guessed type char byte_805B473;

//----- (08049882) --------------------------------------------------------
void sub_8049882()
{
  ;
}

//----- (0804989D) --------------------------------------------------------
void sub_804989D()
{
  ;
}

//----- (080498AD) --------------------------------------------------------
int sub_80498AD()
{
  int result; // eax

  result = &unk_805B317 - &unk_805B314;
  if ( (unsigned int)(&unk_805B317 - &unk_805B314) > 6 )
    result = 0;
  return result;
}
// 80498AD: could not find valid save-restore pair for ebp

//----- (08049914) --------------------------------------------------------
int __usercall sub_8049914@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_805B314, a1);
}

//----- (080499AB) --------------------------------------------------------
void sub_80499AB()
{
  ;
}

//----- (080499C6) --------------------------------------------------------
void sub_80499C6()
{
  ;
}

//----- (080499D6) --------------------------------------------------------
int sub_80499D6()
{
  int result; // eax

  result = &unk_805B317 - &unk_805B314;
  if ( (unsigned int)(&unk_805B317 - &unk_805B314) > 6 )
    result = 0;
  return result;
}
// 80499D6: could not find valid save-restore pair for ebp

//----- (08049A60) --------------------------------------------------------
int sub_8049A60()
{
  int result; // eax

  result = sub_80499D6();
  byte_805B50D = 1;
  return result;
}
// 805B50D: using guessed type char byte_805B50D;

//----- (08049AD4) --------------------------------------------------------
void sub_8049AD4()
{
  ;
}

//----- (08049AEF) --------------------------------------------------------
void sub_8049AEF()
{
  ;
}

//----- (08049AFF) --------------------------------------------------------
int sub_8049AFF()
{
  int result; // eax

  result = &unk_805B317 - &unk_805B314;
  if ( (unsigned int)(&unk_805B317 - &unk_805B314) > 6 )
    result = 0;
  return result;
}
// 8049AFF: could not find valid save-restore pair for ebp

//----- (08049BE1) --------------------------------------------------------
void sub_8049BE1()
{
  ;
}

//----- (08049BFC) --------------------------------------------------------
void sub_8049BFC()
{
  ;
}

//----- (08049C0C) --------------------------------------------------------
int sub_8049C0C()
{
  int result; // eax

  result = &unk_805929F - &unk_805929C;
  if ( (unsigned int)(&unk_805929F - &unk_805929C) > 6 )
    result = 0;
  return result;
}
// 8049C0C: could not find valid save-restore pair for ebp

//----- (08049C73) --------------------------------------------------------
int __usercall sub_8049C73@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_805929C, a1);
}

//----- (08049D0A) --------------------------------------------------------
void sub_8049D0A()
{
  ;
}

//----- (08049D25) --------------------------------------------------------
void sub_8049D25()
{
  ;
}

//----- (08049D35) --------------------------------------------------------
int sub_8049D35()
{
  int result; // eax

  result = &unk_805B317 - &unk_805B314;
  if ( (unsigned int)(&unk_805B317 - &unk_805B314) > 6 )
    result = 0;
  return result;
}
// 8049D35: could not find valid save-restore pair for ebp

//----- (08049E2C) --------------------------------------------------------
void sub_8049E2C()
{
  ;
}

//----- (08049E47) --------------------------------------------------------
void sub_8049E47()
{
  ;
}

//----- (08049E57) --------------------------------------------------------
int sub_8049E57()
{
  int result; // eax

  result = &unk_805B317 - &unk_805B314;
  if ( (unsigned int)(&unk_805B317 - &unk_805B314) > 6 )
    result = 0;
  return result;
}
// 8049E57: could not find valid save-restore pair for ebp

//----- (08049F39) --------------------------------------------------------
void sub_8049F39()
{
  ;
}

//----- (08049F54) --------------------------------------------------------
void sub_8049F54()
{
  ;
}

//----- (08049F64) --------------------------------------------------------
int sub_8049F64()
{
  int result; // eax

  result = &unk_805B645 - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_805B645 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 8049F64: could not find valid save-restore pair for ebp
// 805B340: using guessed type int program_invocation_short_name;

//----- (0804A046) --------------------------------------------------------
void sub_804A046()
{
  ;
}

//----- (0804A061) --------------------------------------------------------
void sub_804A061()
{
  ;
}

//----- (0804A071) --------------------------------------------------------
int sub_804A071()
{
  int result; // eax

  result = &unk_805B317 - &unk_805B314;
  if ( (unsigned int)(&unk_805B317 - &unk_805B314) > 6 )
    result = 0;
  return result;
}
// 804A071: could not find valid save-restore pair for ebp

//----- (0804A17A) --------------------------------------------------------
void sub_804A17A()
{
  ;
}

//----- (0804A195) --------------------------------------------------------
void sub_804A195()
{
  ;
}

//----- (0804A1A5) --------------------------------------------------------
int sub_804A1A5()
{
  int result; // eax
  int (__stdcall *v1)(void *, int, int, int, int, int); // eax
  int v2; // [esp+4h] [ebp-18h]
  int v3; // [esp+8h] [ebp-14h]
  int v4; // [esp+Ch] [ebp-10h]
  int v5; // [esp+10h] [ebp-Ch]
  int v6; // [esp+14h] [ebp-8h]
  int v7; // [esp+18h] [ebp-4h]

  result = &unk_805823B - &unk_8058238;
  if ( (unsigned int)(&unk_805823B - &unk_8058238) > 6 )
  {
    v7 = 0;
    dword_805B1C0 = (int)&locret_804A1B4;
    v1 = (int (__stdcall *)(void *, int, int, int, int, int))sub_8054AE0();
    result = v1(&unk_8058238, v2, v3, v4, v5, v6);
  }
  return result;
}
// 8054AE0: using guessed type int sub_8054AE0(void);
// 805B1C0: using guessed type int dword_805B1C0;

//----- (0804A2BC) --------------------------------------------------------
void sub_804A2BC()
{
  ;
}

//----- (0804A2D7) --------------------------------------------------------
void sub_804A2D7()
{
  ;
}

//----- (0804A2E7) --------------------------------------------------------
int sub_804A2E7()
{
  int result; // eax

  result = &unk_805B317 - &unk_805B314;
  if ( (unsigned int)(&unk_805B317 - &unk_805B314) > 6 )
    result = 0;
  return result;
}
// 804A2E7: could not find valid save-restore pair for ebp

//----- (0804A371) --------------------------------------------------------
int sub_804A371()
{
  int result; // eax

  result = sub_804A2E7();
  byte_805B775 = 1;
  return result;
}
// 805B775: using guessed type char byte_805B775;

//----- (0804A3F7) --------------------------------------------------------
void sub_804A3F7()
{
  ;
}

//----- (0804A412) --------------------------------------------------------
void sub_804A412()
{
  ;
}

//----- (0804A422) --------------------------------------------------------
int sub_804A422()
{
  int result; // eax

  result = &unk_805B317 - &unk_805B314;
  if ( (unsigned int)(&unk_805B317 - &unk_805B314) > 6 )
    result = 0;
  return result;
}
// 804A422: could not find valid save-restore pair for ebp

//----- (0804A504) --------------------------------------------------------
void sub_804A504()
{
  ;
}

//----- (0804A51F) --------------------------------------------------------
void sub_804A51F()
{
  ;
}

//----- (0804A52F) --------------------------------------------------------
int sub_804A52F()
{
  int result; // eax

  result = &unk_805B317 - &unk_805B314;
  if ( (unsigned int)(&unk_805B317 - &unk_805B314) > 6 )
    result = 0;
  return result;
}
// 804A52F: could not find valid save-restore pair for ebp

//----- (0804A596) --------------------------------------------------------
int __usercall sub_804A596@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_805B314, a1);
}

//----- (0804A5D2) --------------------------------------------------------
int sub_804A5D2()
{
  int result; // eax

  result = sub_804A52F();
  byte_805B80F = 1;
  return result;
}
// 805B80F: using guessed type char byte_805B80F;

//----- (0804A658) --------------------------------------------------------
void sub_804A658()
{
  ;
}

//----- (0804A673) --------------------------------------------------------
void sub_804A673()
{
  ;
}

//----- (0804A683) --------------------------------------------------------
int sub_804A683()
{
  int result; // eax

  result = &unk_80571EB - &unk_80571E8;
  if ( (unsigned int)(&unk_80571EB - &unk_80571E8) > 6 )
    result = 0;
  return result;
}
// 804A683: could not find valid save-restore pair for ebp

//----- (0804A77A) --------------------------------------------------------
void sub_804A77A()
{
  ;
}

//----- (0804A795) --------------------------------------------------------
void sub_804A795()
{
  ;
}

//----- (0804A7A5) --------------------------------------------------------
int sub_804A7A5()
{
  int result; // eax

  result = &unk_805B317 - &unk_805B314;
  if ( (unsigned int)(&unk_805B317 - &unk_805B314) > 6 )
    result = 0;
  return result;
}
// 804A7A5: could not find valid save-restore pair for ebp

//----- (0804A803) --------------------------------------------------------
int sub_804A803()
{
  return nullsub_6();
}
// 804A803: could not find valid save-restore pair for ebp
// 804A802: using guessed type int nullsub_6(void);

//----- (0804A848) --------------------------------------------------------
int sub_804A848()
{
  int result; // eax

  result = sub_804A7A5();
  byte_805B8A9 = 1;
  return result;
}
// 805B8A9: using guessed type char byte_805B8A9;

//----- (0804A8E7) --------------------------------------------------------
void sub_804A8E7()
{
  ;
}

//----- (0804A902) --------------------------------------------------------
void sub_804A902()
{
  ;
}

//----- (0804A912) --------------------------------------------------------
int sub_804A912()
{
  int result; // eax

  result = &unk_805B31F - &unk_805B31C;
  if ( (unsigned int)(&unk_805B31F - &unk_805B31C) > 6 )
    result = 0;
  return result;
}
// 804A912: could not find valid save-restore pair for ebp

//----- (0804A99C) --------------------------------------------------------
int sub_804A99C()
{
  int result; // eax

  result = sub_804A912();
  byte_805B8F6 = 1;
  return result;
}
// 805B8F6: using guessed type char byte_805B8F6;

//----- (0804AA22) --------------------------------------------------------
void sub_804AA22()
{
  ;
}

//----- (0804AA3D) --------------------------------------------------------
void sub_804AA3D()
{
  ;
}

//----- (0804AA4D) --------------------------------------------------------
int sub_804AA4D()
{
  int result; // eax

  result = &unk_805B31B - &unk_805B318;
  if ( (unsigned int)(&unk_805B31B - &unk_805B318) > 6 )
    result = 0;
  return result;
}
// 804AA4D: could not find valid save-restore pair for ebp

//----- (0804AB44) --------------------------------------------------------
void sub_804AB44()
{
  ;
}

//----- (0804AB5F) --------------------------------------------------------
void sub_804AB5F()
{
  ;
}

//----- (0804AB6F) --------------------------------------------------------
int sub_804AB6F()
{
  int result; // eax

  result = &unk_805B323 - &unk_805B320;
  if ( (unsigned int)(&unk_805B323 - &unk_805B320) > 6 )
    result = 0;
  return result;
}
// 804AB6F: could not find valid save-restore pair for ebp

//----- (0804AC4D) --------------------------------------------------------
int sub_804AC4D()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nWith no FILE, or when FILE is -, read standard input.\n");
  return fputs_unlocked(v1, v0);
}
// 80491E0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804AC78) --------------------------------------------------------
int sub_804AC78()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nMandatory arguments to long options are mandatory for short options too.\n");
  return fputs_unlocked(v1, v0);
}
// 80491E0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804ACA3) --------------------------------------------------------
int __cdecl sub_804ACA3(char *s1)
{
  bool v1; // zf
  void *v2; // eax
  char *v3; // eax
  void *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  const char *v9; // [esp+4h] [ebp-64h]
  char *v10; // [esp+8h] [ebp-60h]
  const char *v11; // [esp+1Ch] [ebp-4Ch]
  const char **v12; // [esp+20h] [ebp-48h]
  char *v13; // [esp+24h] [ebp-44h]
  const char *v14; // [esp+28h] [ebp-40h]
  const char *v15; // [esp+2Ch] [ebp-3Ch]
  const char *v16; // [esp+30h] [ebp-38h]
  const char *v17; // [esp+34h] [ebp-34h]
  const char *v18; // [esp+38h] [ebp-30h]
  const char *v19; // [esp+3Ch] [ebp-2Ch]
  const char *v20; // [esp+40h] [ebp-28h]
  const char *v21; // [esp+44h] [ebp-24h]
  const char *v22; // [esp+48h] [ebp-20h]
  const char *v23; // [esp+4Ch] [ebp-1Ch]
  const char *v24; // [esp+50h] [ebp-18h]
  const char *v25; // [esp+54h] [ebp-14h]
  int v26; // [esp+58h] [ebp-10h]
  int v27; // [esp+5Ch] [ebp-Ch]

  v14 = "[";
  v15 = "test invocation";
  v16 = "coreutils";
  v17 = "Multi-call invocation";
  v18 = "sha224sum";
  v19 = "sha2 utilities";
  v20 = "sha256sum";
  v21 = "sha2 utilities";
  v22 = "sha384sum";
  v23 = "sha2 utilities";
  v24 = "sha512sum";
  v25 = "sha2 utilities";
  v26 = 0;
  v27 = 0;
  v11 = s1;
  v12 = &v14;
  if ( "[" )
  {
    v1 = strcmp(s1, *v12) == 0;
    v2 = &loc_804AD58;
    if ( !v1 )
      v2 = &loc_804AD1A;
    dword_805B198 = (int)v2;
    sub_8054BCA();
  }
  if ( v12[1] )
    v11 = v12[1];
  v3 = gettext("\n%s online help: <%s>\n");
  v10 = "http://www.gnu.org/software/coreutils/";
  printf(v3, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  v13 = setlocale(5, 0);
  if ( v13 )
  {
    v1 = strncmp(v13, "en_", 3u) == 0;
    v4 = &loc_804ADE4;
    if ( v1 )
      v4 = &loc_804ADFF;
    dword_805B210 = (int)v4;
    sub_80548CA();
    v5 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
    printf(v5, s1);
  }
  v6 = gettext("Full documentation at: <%s%s>\n");
  v10 = s1;
  v9 = "http://www.gnu.org/software/coreutils/";
  printf(v6, "http://www.gnu.org/software/coreutils/", s1);
  if ( v11 == s1 )
  {
    dword_805B1FC = (int)&loc_804AE4B;
    sub_805495D();
  }
  v7 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  v10 = &s;
  v9 = v11;
  return printf(v7, v11, &s);
}
// 80548CA: using guessed type int sub_80548CA(void);
// 805495D: using guessed type int sub_805495D(void);
// 8054BCA: using guessed type int sub_8054BCA(void);
// 805B198: using guessed type int dword_805B198;
// 805B1FC: using guessed type int dword_805B1FC;
// 805B210: using guessed type int dword_805B210;

//----- (0804AE70) --------------------------------------------------------
int __cdecl sub_804AE70(int a1)
{
  return (*(_DWORD *)(a1 + 16) & 0xF000) == 0x8000 || (*(_DWORD *)(a1 + 16) & 0xF000) == 40960;
}

//----- (0804AEA8) --------------------------------------------------------
void __cdecl __noreturn sub_804AEA8(int *a1, __int64 a2)
{
  sub_804E7AE(a1, a2 - 1);
}

//----- (0804AEDB) --------------------------------------------------------
int __fastcall sub_804AEDB(int ecx0, int a2, int a1)
{
  int v3; // ebx
  char *v4; // eax
  int v6; // [esp+8h] [ebp-20h]

  dword_805B2A4 = (int (__fastcall *)(_DWORD, _DWORD))sub_804AF37;
  if ( a1 )
  {
    v3 = dword_805B99C;
    v4 = gettext("Try '%s --help' for more information.\n");
    v6 = v3;
    fprintf(stderr, v4, v3);
    dword_805B2A4 = (int (__fastcall *)(_DWORD, _DWORD))&loc_804B015;
  }
  return dword_805B2A4(ecx0, a2);
}
// 804AF37: using guessed type void __cdecl __noreturn sub_804AF37(int, int, int);
// 805B2A4: using guessed type int (__fastcall *dword_805B2A4)(_DWORD, _DWORD);
// 805B99C: using guessed type int dword_805B99C;

//----- (0804AF37) --------------------------------------------------------
#error "804AF50: call analysis failed (funcsize=47)"

//----- (0804B020) --------------------------------------------------------
int __cdecl sub_804B020(int a1, signed int a2)
{
  void *v2; // eax
  int result; // eax
  int v4; // [esp+10h] [ebp-18h]
  size_t size; // [esp+14h] [ebp-14h]
  signed int i; // [esp+18h] [ebp-10h]

  size = a2;
  for ( i = 0; i < a2; ++i )
    size += strlen(*(const char **)(4 * i + a1));
  v4 = sub_8050A98(size);
  v2 = &loc_804B0EB;
  if ( a2 > 0 )
    v2 = &loc_804B07A;
  dword_805B1FC = (int)v2;
  sub_805495D();
  result = v4;
  *(_DWORD *)(a1 + 4 * a2) = v4;
  return result;
}
// 805495D: using guessed type int sub_805495D(void);
// 805B1FC: using guessed type int dword_805B1FC;

//----- (0804B101) --------------------------------------------------------
char *__cdecl sub_804B101(void *s, int a2, size_t n)
{
  return (char *)memchr(s, (char)a2, n) + 1;
}

//----- (0804B132) --------------------------------------------------------
__int64 sub_804B132()
{
  int v0; // ecx
  int v1; // ecx
  __int64 v2; // rax
  __int64 v4; // [esp+10h] [ebp-78h]
  __int64 v5; // [esp+18h] [ebp-70h]
  char v6; // [esp+20h] [ebp-68h]
  __int64 v7; // [esp+4Ch] [ebp-3Ch]

  if ( sub_8054457(0, (int)&v6) )
  {
    dword_805B148 = (int)&locret_804B1FF;
    sub_8054D9E(v0, 0x7FFFFFFF);
  }
  if ( !(unsigned __int8)sub_804AE70((int)&v6) )
  {
    dword_805B1AC = (int)&locret_804B1FF;
    sub_8054B5A(v1, 0x7FFFFFFF);
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  v4 = v7;
  LODWORD(v2) = lseek64(0, 0, 0, 1);
  v5 = v2;
  if ( v2 < 0 )
    return 0x7FFFFFFFFFFFFFFFLL;
  return v4 - v5;
}
// 8049340: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8054B5A: using guessed type int __fastcall sub_8054B5A(_DWORD, _DWORD);
// 8054D9E: using guessed type int __fastcall sub_8054D9E(_DWORD, _DWORD);
// 805B148: using guessed type int dword_805B148;
// 805B1AC: using guessed type int dword_805B1AC;

//----- (0804B201) --------------------------------------------------------
int __cdecl sub_804B201(FILE *stream, int a2, int a3, int a4, int a5)
{
  int v5; // eax
  char *v6; // ebx
  int *v7; // eax
  int result; // eax
  _DWORD v9[2]; // [esp+Ch] [ebp-3Ch]
  int nmemb; // [esp+14h] [ebp-34h]
  int v11; // [esp+18h] [ebp-30h]
  char *ptr; // [esp+1Ch] [ebp-2Ch]
  unsigned __int64 v13; // [esp+20h] [ebp-28h]
  char s; // [esp+34h] [ebp-14h]

  LOBYTE(v9[0]) = a2;
  v13 = 0LL;
  v5 = 1024;
  if ( (unsigned int)a3 <= 0x400 )
    v5 = a3;
  nmemb = v5;
  v11 = 0;
  ptr = (char *)sub_8050BAF(v5, 0xCu);
  while ( (unsigned int)a3 > v13 )
  {
    v11 = sub_804C872((int)&ptr[12 * v13], stream, (char)a2);
    if ( !v11 )
      break;
    if ( (unsigned int)nmemb <= ++v13 )
    {
      nmemb += 1024;
      ptr = (char *)sub_80509A0(ptr, nmemb, 12);
      memset(&ptr[12 * v13], 0, 0x3000u);
    }
  }
  if ( v11 )
  {
    sub_804C82D(&s);
    sub_804AEA8((int *)a4, v13 + 1);
  }
  if ( ferror_unlocked(stream) )
  {
    v6 = gettext("read error");
    v7 = __errno_location();
    error(1, *v7, v6, v9[0]);
  }
  *(_DWORD *)a5 = ptr;
  result = a3;
  if ( (unsigned int)a3 > v13 )
    result = v13;
  return result;
}

//----- (0804B46C) --------------------------------------------------------
int __fastcall sub_804B46C(int a1, int a2)
{
  dword_805B2A4 = (int (__fastcall *)(_DWORD, _DWORD))&loc_804B524;
  return ((int (__fastcall *)(int, int))loc_804B524)(a1, a2);
}
// 805B2A4: using guessed type int (__fastcall *dword_805B2A4)(_DWORD, _DWORD);

//----- (0804B48C) --------------------------------------------------------
#error "804B544: positive sp value has been found (funcsize=49)"

//----- (0804B545) --------------------------------------------------------
unsigned int __cdecl sub_804B545(FILE *stream, int a2, int a3)
{
  _BYTE *v3; // eax
  bool v4; // zf
  void *v5; // eax
  char *v6; // ebx
  int *v7; // eax
  int v8; // eax
  void **v9; // ebx
  char v11; // [esp+Ch] [ebp-2Ch]
  int v12; // [esp+14h] [ebp-24h]
  void *s; // [esp+18h] [ebp-20h]
  unsigned int v14; // [esp+1Ch] [ebp-1Ch]
  unsigned int v15; // [esp+20h] [ebp-18h]
  _BYTE *v16; // [esp+24h] [ebp-14h]
  unsigned int v17; // [esp+28h] [ebp-10h]
  _DWORD *v18; // [esp+2Ch] [ebp-Ch]

  v11 = a2;
  v16 = 0;
  v3 = sub_804FEC1(stream, (int)&v12);
  v16 = v3;
  v4 = v3 == 0;
  v5 = &loc_804B58D;
  if ( !v4 )
    v5 = &loc_804B5B6;
  dword_805B238 = (int)v5;
  sub_80547B0();
  v6 = gettext("read error");
  v7 = __errno_location();
  error(1, *v7, v6);
  if ( v12 && v16[v12 - 1] != v11 )
  {
    v8 = v12++;
    v16[v8] = v11;
  }
  v17 = (unsigned int)&v16[v12];
  v14 = 0;
  for ( s = v16; (unsigned int)s < v17; s = sub_804B101(s, v11, v17 - (_DWORD)s) )
    ++v14;
  v18 = (_DWORD *)sub_8050972(v14 + 1, 4u);
  *(_DWORD *)a3 = v18;
  s = v16;
  *v18 = v16;
  v15 = 1;
  dword_805B198 = (int)&loc_804B6BC;
  sub_8054BCA();
  do
  {
    v9 = (void **)&v18[v15];
    s = sub_804B101(s, v11, v17 - (_DWORD)s);
    *v9 = s;
    ++v15;
  }
  while ( v15 <= v14 );
  return v14;
}
// 80547B0: using guessed type int sub_80547B0(void);
// 8054BCA: using guessed type int sub_8054BCA(void);
// 805B198: using guessed type int dword_805B198;
// 805B238: using guessed type int dword_805B238;

//----- (0804B6CD) --------------------------------------------------------
signed int __cdecl sub_804B6CD(unsigned int a1, int a2, int a3)
{
  int v3; // ST18_4
  int n; // ST1C_4
  unsigned int i; // [esp+14h] [ebp-14h]

  for ( i = 0; i < a1; ++i )
  {
    v3 = 4 * *(_DWORD *)(4 * i + a3) + a2;
    n = *(_DWORD *)(v3 + 4) - *(_DWORD *)v3;
    if ( fwrite_unlocked(*(const void **)v3, 1u, n, stdout) != n )
      return -1;
  }
  return 0;
}

//----- (0804B757) --------------------------------------------------------
signed int __cdecl sub_804B757(unsigned int a1, int a2, int a3, char a4)
{
  unsigned int i; // [esp+18h] [ebp-10h]

  for ( i = 0; i < a1; ++i )
  {
    if ( printf("%lu%c", *(_DWORD *)(4 * i + a3) + a2, a4) < 0 )
      return -1;
  }
  return 0;
}

//----- (0804B7BE) --------------------------------------------------------
void __cdecl __noreturn sub_804B7BE(int *a1, int a2, int a3, int a4, char a5)
{
  char v5; // [esp+Ch] [ebp-1Ch]
  int v6; // [esp+10h] [ebp-18h]
  __int64 v7; // [esp+18h] [ebp-10h]

  v5 = a5;
  v7 = (unsigned int)(a4 - a3 + 1);
  v6 = 0;
  dword_805B224 = (int)sub_804B84C;
  sub_8054854();
  sub_804AEA8(a1, v7);
}
// 804B84C: using guessed type int sub_804B84C();
// 8054854: using guessed type int sub_8054854(void);
// 805B224: using guessed type int dword_805B224;

//----- (0804B85B) --------------------------------------------------------
void __cdecl __noreturn sub_804B85B(int *a1, int a2, int a3, unsigned int a4)
{
  int v4; // [esp+1Ch] [ebp-1Ch]

  v4 = 0;
  dword_805B24C = (int)sub_804B917;
  sub_8054736();
  sub_804AEA8(a1, a4);
}
// 804B917: using guessed type int sub_804B917();
// 8054736: using guessed type int sub_8054736(void);
// 805B24C: using guessed type int dword_805B24C;

//----- (0804B92A) --------------------------------------------------------
int __cdecl main(int argc, char **argv)
{
  int v2; // edx
  int v3; // ecx
  int v4; // edx
  int v5; // ecx
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  const char *v9; // esi
  char *v10; // ebx
  int v11; // eax
  int v12; // ecx
  int v13; // eax
  int v14; // ebx
  char *v15; // eax
  char *v16; // eax
  char *v17; // eax
  char *v18; // eax
  int v19; // edx
  int v20; // ecx
  bool v21; // al
  bool v22; // al
  int v23; // ebx
  char *v24; // eax
  int v25; // edx
  int v26; // ecx
  bool v27; // zf
  void *v28; // eax
  int v29; // ebx
  int v30; // eax
  void *v31; // eax
  unsigned int v32; // eax
  int v33; // ebx
  int v34; // eax
  void *v35; // eax
  char *v36; // ebx
  int *v37; // eax
  int v38; // ebx
  int v39; // eax
  void *v40; // eax
  void *v41; // eax
  int v42; // ecx
  char *v43; // ebx
  int *v44; // eax
  char *v46; // [esp+0h] [ebp-88h]
  int v47; // [esp+4h] [ebp-84h]
  const char *v48; // [esp+8h] [ebp-80h]
  char *v49; // [esp+Ch] [ebp-7Ch]
  const char *v50; // [esp+10h] [ebp-78h]
  int v51; // [esp+14h] [ebp-74h]
  char v52; // [esp+2Eh] [ebp-5Ah]
  char v53; // [esp+2Fh] [ebp-59h]
  char v54; // [esp+30h] [ebp-58h]
  char v55; // [esp+31h] [ebp-57h]
  char v56; // [esp+32h] [ebp-56h]
  bool v57; // [esp+33h] [ebp-55h]
  int v58; // [esp+34h] [ebp-54h]
  int v59; // [esp+38h] [ebp-50h]
  int v60; // [esp+3Ch] [ebp-4Ch]
  unsigned int v61; // [esp+40h] [ebp-48h]
  unsigned int v62; // [esp+44h] [ebp-44h]
  unsigned int v63; // [esp+48h] [ebp-40h]
  const char *v64; // [esp+4Ch] [ebp-3Ch]
  const char *v65; // [esp+50h] [ebp-38h]
  unsigned int v66; // [esp+54h] [ebp-34h]
  const char **v67; // [esp+58h] [ebp-30h]
  const char *v68; // [esp+5Ch] [ebp-2Ch]
  int v69; // [esp+60h] [ebp-28h]
  char *v70; // [esp+64h] [ebp-24h]
  int v71; // [esp+68h] [ebp-20h]
  char *v72; // [esp+6Ch] [ebp-1Ch]
  int v73; // [esp+70h] [ebp-18h]
  int v74; // [esp+74h] [ebp-14h]
  const char **v75; // [esp+78h] [ebp-10h]
  int *v76; // [esp+7Ch] [ebp-Ch]

  v52 = 0;
  v53 = 0;
  v61 = -1;
  v62 = 0;
  v63 = -1;
  v64 = 0;
  v65 = 0;
  v54 = 10;
  v58 = 0;
  v55 = 0;
  v56 = 0;
  v67 = 0;
  v59 = 0;
  v68 = 0;
  sub_804C9D4(*argv);
  setlocale(6, &s);
  bindtextdomain("coreutils", "/home/hwangdz/coreutils/coreutils-8.28/install_m32/share/locale");
  textdomain("coreutils");
  sub_8054428((int)sub_804C487);
  dword_805B15C = (int)&loc_804BDD4;
  sub_8054D26(v3, v2);
  do
  {
    if ( v71 == 110 )
    {
      v73 = sub_8050EE9((int)&v60, v5, optarg, 0, 10, (int)&v60, 0);
      if ( !v73 )
      {
        v13 = v63;
        if ( v60 <= v63 )
          v13 = v60;
        v63 = v13;
        dword_805B274 = (int)&loc_804BCC5;
        sub_8054652(v12, v60);
      }
      if ( v73 != 1 )
      {
        v46 = optarg;
        v14 = sub_804E6D9();
        v15 = gettext("invalid line count: %s");
        v49 = (char *)v14;
        error(1, 0, v15, v14);
      }
    }
    else if ( v71 > 110 )
    {
      if ( v71 == 114 )
      {
        v56 = 1;
        goto LABEL_47;
      }
      if ( v71 > 114 )
      {
        if ( v71 == 122 )
        {
          v54 = 0;
          goto LABEL_47;
        }
        if ( v71 != 128 )
          goto LABEL_46;
        if ( v65 && strcmp(v65, optarg) )
        {
          v17 = gettext("multiple random sources specified");
          error(1, 0, v17);
        }
        v65 = optarg;
      }
      else
      {
        if ( v71 != 111 )
          goto LABEL_46;
        if ( v64 && strcmp(v64, optarg) )
        {
          v16 = gettext("multiple output files specified");
          error(1, 0, v16);
        }
        v64 = optarg;
      }
    }
    else
    {
      if ( v71 == -130 )
      {
        sub_804AEDB(v5, v4, 0);
LABEL_44:
        v51 = 0;
        v50 = "Paul Eggert";
        sub_80508D2(stdout, (int)"shuf", (int)"GNU coreutils", off_805B2C0, "Paul Eggert", 0);
        exit(0);
      }
      if ( v71 <= -130 )
      {
        if ( v71 == -131 )
          goto LABEL_44;
LABEL_46:
        sub_804AEDB(v5, v4, 1);
        goto LABEL_47;
      }
      if ( v71 == 101 )
      {
        v52 = 1;
        goto LABEL_47;
      }
      if ( v71 != 105 )
        goto LABEL_46;
      v72 = strchr(optarg, 45);
      v70 = optarg;
      v57 = v72 == 0;
      if ( v53 )
      {
        v6 = gettext("multiple -i options specified");
        error(1, 0, v6);
      }
      v53 = 1;
      if ( v72 )
      {
        *v72 = 0;
        v7 = gettext("invalid input range");
        v61 = sub_8050DCA(optarg, 0, 0, -1, 0, &s, (int)v7, 0);
        *v72 = 45;
        v70 = v72 + 1;
      }
      v8 = gettext("invalid input range");
      v62 = sub_8050DCA(v70, 0, 0, -1, 0, &s, (int)v8, 0);
      v66 = v62 - v61 + 1;
      v57 = (v57 | (unsigned __int8)((v61 > v62) ^ (v66 == 0))) != 0;
      if ( v57 )
      {
        v46 = optarg;
        v9 = (const char *)sub_804E6D9();
        v10 = gettext("invalid input range");
        v11 = *__errno_location();
        v50 = v9;
        v49 = v10;
        error(1, v11, "%s: %s", v10, v9);
      }
    }
LABEL_47:
    v71 = getopt_long(argc, argv, "ei:n:o:rz", &longopts, 0);
  }
  while ( v71 != -1 );
  v74 = argc - optind;
  v75 = (const char **)&argv[optind];
  if ( v52 && v53 )
  {
    v18 = gettext("cannot combine -e and -i options");
    error(0, 0, v18);
    sub_804AEDB(v20, v19, 1);
  }
  if ( v53 )
  {
    v21 = v74 > 0;
  }
  else
  {
    v22 = v52 != 1 && v74 > 1;
    v21 = v22;
  }
  if ( v21 )
  {
    v46 = (char *)v75[(unsigned __int8)(v53 ^ 1)];
    v23 = sub_804E6D9();
    v24 = gettext("extra operand %s");
    v49 = (char *)v23;
    error(0, 0, v24, v23);
    sub_804AEDB(v26, v25, 1);
  }
  if ( v52 )
  {
    v48 = (const char *)v54;
    sub_804B020((int)v75, v74);
    v66 = v74;
    v67 = v75;
  }
  else
  {
    if ( v53 )
    {
      v66 = v62 - v61 + 1;
      v67 = 0;
      dword_805B198 = (int)&loc_804C0B2;
      sub_8054BCA();
    }
    if ( v74 == 1 )
    {
      v27 = strcmp(*v75, "-") == 0;
      v28 = &loc_804BFAF;
      if ( v27 )
        v28 = &loc_804C01D;
      dword_805B210 = (int)v28;
      sub_80548CA();
      if ( v63 && !sub_804C653((int)*v75, (int)"r", stdin) )
      {
        v48 = *v75;
        v29 = sub_804E4A1(0, 3);
        v30 = *__errno_location();
        v49 = (char *)v29;
        error(1, v30, "%s", v29);
      }
    }
    sub_804C5BC(stdin, 2);
    v31 = &loc_804C057;
    if ( v56 == 1 )
      v31 = &loc_804C088;
    dword_805B260 = (int)v31;
    sub_80546C8();
    if ( v63 == -1 || v63 && sub_804B132() <= 0x800000 )
    {
      v66 = sub_804B545(stdin, v54, (int)&v58);
      v67 = (const char **)v58;
    }
    else
    {
      v55 = 1;
      v66 = -1;
    }
  }
  if ( v56 != 1 )
  {
    v32 = v63;
    if ( v66 <= v63 )
      v32 = v66;
    v63 = v32;
  }
  if ( v55 != 1 && v56 != 1 )
  {
    sub_804EB85(v63, v66);
    dword_805B210 = (int)&loc_804C117;
    sub_80548CA();
  }
  v76 = (int *)sub_804E739((int)v65, 0xFFFFFFFF);
  if ( !v76 )
  {
    v48 = v65;
    v33 = sub_804E4A1(0, 3);
    v34 = *__errno_location();
    v49 = (char *)v33;
    error(1, v34, "%s", v33);
  }
  if ( v55 )
  {
    v66 = sub_804B201(stdin, v54, v63, (int)v76, (int)&v59);
    v63 = v66;
  }
  if ( v52 != 1 )
  {
    v35 = &loc_804C1E5;
    if ( v53 == 1 )
      v35 = &loc_804C21F;
    dword_805B260 = (int)v35;
    sub_80546C8();
    if ( sub_8051990(stdin) )
    {
      v36 = gettext("read error");
      v37 = __errno_location();
      error(1, *v37, v36);
    }
  }
  if ( v56 != 1 )
    v68 = (const char *)sub_804ED95(v76, v63, v66);
  if ( v64 && !sub_804C653((int)v64, (int)"w", stdout) )
  {
    v48 = v64;
    v38 = sub_804E4A1(0, 3);
    v39 = *__errno_location();
    v49 = (char *)v38;
    error(1, v39, "%s", v38);
  }
  if ( v56 )
  {
    v40 = &loc_804C2DF;
    if ( v63 )
      v40 = &loc_804C2EC;
    dword_805B198 = (int)v40;
    sub_8054BCA();
    v69 = 0;
  }
  else
  {
    v41 = &loc_804C3B3;
    if ( !v55 )
      v41 = &loc_804C3D5;
    dword_805B238 = (int)v41;
    sub_80547B0();
    v48 = v68;
    v47 = v59;
    v46 = (char *)v66;
    v69 = sub_804B46C(v42, (int)v68);
  }
  if ( v69 )
  {
    v43 = gettext("write error");
    v44 = __errno_location();
    error(1, *v44, v43);
  }
  return 0;
}
// 8054652: using guessed type int __fastcall sub_8054652(_DWORD, _DWORD);
// 80546C8: using guessed type int sub_80546C8(void);
// 80547B0: using guessed type int sub_80547B0(void);
// 80548CA: using guessed type int sub_80548CA(void);
// 8054BCA: using guessed type int sub_8054BCA(void);
// 8054D26: using guessed type int __fastcall sub_8054D26(_DWORD, _DWORD);
// 805B15C: using guessed type int dword_805B15C;
// 805B198: using guessed type int dword_805B198;
// 805B210: using guessed type int dword_805B210;
// 805B238: using guessed type int dword_805B238;
// 805B260: using guessed type int dword_805B260;
// 805B274: using guessed type int dword_805B274;
// 805B360: using guessed type int optind;

//----- (0804C487) --------------------------------------------------------
int sub_804C487()
{
  int v0; // ebx
  int *v1; // eax
  int *v2; // eax
  int result; // eax
  char *v4; // [esp+2Ch] [ebp-Ch]

  if ( sub_8051D1D(stdout) && (byte_805B998 != 1 || *__errno_location() != 32) )
  {
    v4 = gettext("write error");
    if ( dword_805B994 )
    {
      v0 = sub_804E464(dword_805B994);
      v1 = __errno_location();
      error(0, *v1, "%s: %s", v0, v4);
    }
    else
    {
      v2 = __errno_location();
      error(0, *v2, "%s", v4);
    }
    _exit(status);
  }
  result = sub_8051D1D(stderr);
  if ( result )
    _exit(status);
  return result;
}
// 805B994: using guessed type int dword_805B994;
// 805B998: using guessed type char byte_805B998;

//----- (0804C56B) --------------------------------------------------------
int __cdecl sub_804C56B(int a1, int a2, int a3, int a4, int a5, int a6)
{
  return posix_fadvise64(a1, a2, a3, a4, a5, a6);
}
// 8049360: using guessed type int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804C5BC) --------------------------------------------------------
void __cdecl sub_804C5BC(FILE *stream, int a2)
{
  int v2; // eax

  if ( stream )
  {
    v2 = fileno(stream);
    sub_804C56B(v2, 0, 0, 0, 0, a2);
  }
}

//----- (0804C604) --------------------------------------------------------
signed int __cdecl sub_804C604(int a1)
{
  int fd; // [esp+1Ch] [ebp-Ch]

  fd = open64("/dev/null", 0);
  if ( fd == a1 )
    return 1;
  if ( fd >= 0 )
  {
    close(fd);
    *__errno_location() = 9;
  }
  return 0;
}
// 8048F50: using guessed type int __cdecl open64(_DWORD, _DWORD);

//----- (0804C653) --------------------------------------------------------
FILE *__cdecl sub_804C653(int a1, int a2, FILE *stream)
{
  int v3; // eax
  bool v4; // zf
  void *v5; // eax
  void *v6; // eax
  void *v7; // eax
  void *v8; // eax
  int v9; // edx
  int v10; // ecx
  void *v11; // eax
  char v13; // [esp+19h] [ebp-Fh]
  char v14; // [esp+1Ah] [ebp-Eh]
  char v15; // [esp+1Bh] [ebp-Dh]
  int v16; // [esp+1Ch] [ebp-Ch]
  FILE *streama; // [esp+38h] [ebp+10h]

  v13 = 0;
  v14 = 0;
  v15 = 0;
  v3 = fileno(stream);
  if ( v3 == 1 )
  {
LABEL_9:
    if ( dup2(0, 0) )
      v13 = 1;
    goto LABEL_11;
  }
  v4 = v3 == 2;
  v5 = &loc_804C693;
  if ( v4 )
    v5 = &loc_804C6B4;
  dword_805B238 = (int)v5;
  if ( sub_80547B0() )
  {
    if ( dup2(2, 2) != 2 )
      v15 = 1;
    if ( dup2(1, 1) != 1 )
      v14 = 1;
    goto LABEL_9;
  }
LABEL_11:
  if ( v13 )
  {
    v4 = (unsigned __int8)sub_804C604(0) == 1;
    v6 = &loc_804C721;
    if ( v4 )
      v6 = &loc_804C72D;
    dword_805B210 = (int)v6;
    sub_80548CA();
    streama = 0;
  }
  else
  {
    v7 = &loc_804C74C;
    if ( !v14 )
      v7 = &loc_804C768;
    dword_805B1D4 = (int)v7;
    sub_8054A4D();
    if ( (unsigned __int8)sub_804C604(1) ^ 1 )
    {
      streama = 0;
    }
    else if ( v15 )
    {
      v4 = (unsigned __int8)sub_804C604(2) == 1;
      v8 = &loc_804C79A;
      if ( v4 )
        v8 = &loc_804C7A3;
      dword_805B170 = (int)v8;
      sub_8054CB6();
      streama = 0;
    }
    else
    {
      streama = (FILE *)freopen64(a1, a2, stream);
    }
  }
  v16 = *__errno_location();
  if ( v15 )
    close(2);
  if ( v14 )
    close(1);
  if ( v13 )
    close(0);
  v11 = &loc_804C81E;
  if ( streama )
    v11 = &loc_804C828;
  dword_805B15C = (int)v11;
  sub_8054D26(v10, v9);
  *__errno_location() = v16;
  return streama;
}
// 804C653: could not find valid save-restore pair for ebx
// 8048F20: using guessed type int __cdecl freopen64(_DWORD, _DWORD, _DWORD);
// 80547B0: using guessed type int sub_80547B0(void);
// 80548CA: using guessed type int sub_80548CA(void);
// 8054A4D: using guessed type int sub_8054A4D(void);
// 8054CB6: using guessed type int sub_8054CB6(void);
// 8054D26: using guessed type int __fastcall sub_8054D26(_DWORD, _DWORD);
// 805B15C: using guessed type int dword_805B15C;
// 805B170: using guessed type int dword_805B170;
// 805B1D4: using guessed type int dword_805B1D4;
// 805B210: using guessed type int dword_805B210;
// 805B238: using guessed type int dword_805B238;

//----- (0804C82D) --------------------------------------------------------
void *__cdecl sub_804C82D(void *s)
{
  return memset(s, 0, 0xCu);
}

//----- (0804C872) --------------------------------------------------------
int __cdecl sub_804C872(int a1, FILE *stream, int a3)
{
  int v3; // eax
  bool v4; // zf
  void *v5; // eax
  void *v6; // eax
  char *v8; // eax
  char v9; // [esp+Ch] [ebp-2Ch]
  int v10; // [esp+1Ch] [ebp-1Ch]
  void *ptr; // [esp+20h] [ebp-18h]
  char *v12; // [esp+24h] [ebp-14h]
  char *v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]

  v9 = a3;
  ptr = *(void **)(a1 + 8);
  v12 = *(char **)(a1 + 8);
  v13 = (char *)ptr + *(_DWORD *)a1;
  if ( feof_unlocked(stream) )
  {
    dword_805B198 = (int)&locret_804C9BC;
    sub_8054BCA();
  }
  do
  {
    v3 = getc_unlocked(stream);
    v10 = v3;
    v4 = v3 == -1;
    v5 = &loc_804C8F5;
    if ( !v4 )
      v5 = &loc_804C946;
    dword_805B1FC = (int)v5;
    sub_805495D();
    v6 = &loc_804C916;
    if ( v12 == ptr )
      v6 = &loc_804C925;
    dword_805B1D4 = (int)v6;
    sub_8054A4D();
    if ( ferror_unlocked(stream) )
      return 0;
    if ( *(v12 - 1) == v9 )
      break;
    v10 = v9;
    if ( v12 == v13 )
    {
      v14 = *(_DWORD *)a1;
      ptr = sub_8050B63(ptr, a1);
      v12 = (char *)ptr + v14;
      *(_DWORD *)(a1 + 8) = ptr;
      v13 = (char *)ptr + *(_DWORD *)a1;
    }
    v8 = v12++;
    *v8 = v10;
  }
  while ( v9 != v10 );
  *(_DWORD *)(a1 + 4) = v12 - (_BYTE *)ptr;
  return a1;
}
// 804C872: could not find valid save-restore pair for ebx
// 805495D: using guessed type int sub_805495D(void);
// 8054A4D: using guessed type int sub_8054A4D(void);
// 8054BCA: using guessed type int sub_8054BCA(void);
// 805B198: using guessed type int dword_805B198;
// 805B1D4: using guessed type int dword_805B1D4;
// 805B1FC: using guessed type int dword_805B1FC;

//----- (0804C9BE) --------------------------------------------------------
void __cdecl sub_804C9BE(int a1)
{
  free(*(void **)(a1 + 8));
}

//----- (0804C9D4) --------------------------------------------------------
char *__cdecl sub_804C9D4(char *s)
{
  char *v1; // eax
  int v2; // eax
  bool v3; // zf
  bool v4; // sf
  unsigned __int8 v5; // of
  void *v6; // eax
  void *v7; // eax
  char *result; // eax
  char *v9; // [esp+18h] [ebp-10h]
  char *s1; // [esp+1Ch] [ebp-Ch]

  if ( !s )
  {
    fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
    abort();
  }
  v9 = strrchr(s, 47);
  if ( v9 )
    v1 = v9 + 1;
  else
    v1 = s;
  s1 = v1;
  v2 = v1 - s;
  v5 = __OFSUB__(v2, 6);
  v3 = v2 == 6;
  v4 = v2 - 6 < 0;
  v6 = &loc_804CA5C;
  if ( (unsigned __int8)(v4 ^ v5) | v3 )
    v6 = &loc_804CACD;
  dword_805B1FC = (int)v6;
  sub_805495D();
  if ( !strncmp(s1 - 7, "/.libs/", 7u) )
  {
    v3 = strncmp(s1, "lt-", 3u) == 0;
    v7 = &loc_804CABC;
    if ( !v3 )
      v7 = &loc_804CACD;
    dword_805B198 = (int)v7;
    sub_8054BCA();
    s = s1 + 3;
    program_invocation_short_name = (int)(s1 + 3);
  }
  dword_805B99C = (int)s;
  result = s;
  program_invocation_name = (int)s;
  return result;
}
// 804C9D4: could not find valid save-restore pair for ebx
// 805495D: using guessed type int sub_805495D(void);
// 8054BCA: using guessed type int sub_8054BCA(void);
// 805B198: using guessed type int dword_805B198;
// 805B1FC: using guessed type int dword_805B1FC;
// 805B340: using guessed type int program_invocation_short_name;
// 805B350: using guessed type int program_invocation_name;
// 805B99C: using guessed type int dword_805B99C;

//----- (0804CB52) --------------------------------------------------------
int __cdecl sub_804CB52(int *a1, unsigned __int8 a2, char a3)
{
  int *v3; // eax
  int v4; // ST10_4

  if ( a1 )
    v3 = a1;
  else
    v3 = &dword_805B9A4;
  v4 = ((unsigned int)v3[(a2 >> 5) + 2] >> (a2 & 0x1F)) & 1;
  v3[(a2 >> 5) + 2] ^= (v4 ^ a3 & 1) << (a2 & 0x1F);
  return v4;
}
// 805B9A4: using guessed type int dword_805B9A4;

//----- (0804CC15) --------------------------------------------------------
int __fastcall sub_804CC15(int a1, int a2, int a3, int a4, int a5)
{
  dword_805B2A4 = (int (__fastcall *)(_DWORD, _DWORD))&loc_804CC3A;
  if ( !a3 )
  {
    dword_805B9A4 = 10;
    dword_805B2A4 = (int (__fastcall *)(_DWORD, _DWORD))&loc_804CC73;
    if ( a4 )
    {
      dword_805B2A4 = (int (__fastcall *)(_DWORD, _DWORD))sub_804CC78;
      if ( !a5 )
        abort();
    }
  }
  return dword_805B2A4(a1, a2);
}
// 804CC78: using guessed type int sub_804CC78();
// 805B2A4: using guessed type int (__fastcall *dword_805B2A4)(_DWORD, _DWORD);
// 805B9A4: using guessed type int dword_805B9A4;

//----- (0804CC78) --------------------------------------------------------
#error "804CC8B: positive sp value has been found (funcsize=0)"

//----- (0804CC8C) --------------------------------------------------------
_DWORD *__userpurge sub_804CC8C@<eax>(_DWORD *a1, int a2)
{
  int v3; // [esp+0h] [ebp-38h]
  int v4; // [esp+4h] [ebp-34h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]

  memset(&v3, 0, 0x30u);
  if ( a2 == 10 )
    abort();
  *a1 = a2;
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = v6;
  a1[4] = v7;
  a1[5] = v8;
  a1[6] = v9;
  a1[7] = v10;
  a1[8] = v11;
  a1[9] = v12;
  a1[10] = v13;
  a1[11] = v14;
  return a1;
}

//----- (0804CD0E) --------------------------------------------------------
const char *__cdecl sub_804CD0E(char *msgid, int a2)
{
  const char *result; // eax
  char *v3; // [esp+18h] [ebp-10h]
  unsigned __int8 *v4; // [esp+1Ch] [ebp-Ch]

  v3 = gettext(msgid);
  if ( v3 != msgid )
    return v3;
  v4 = (unsigned __int8 *)sub_8053A47();
  if ( sub_8051C9F(v4, "UTF-8") )
  {
    if ( sub_8051C9F(v4, "GB18030") )
    {
      if ( a2 == 9 )
        result = (const char *)&unk_805578D;
      else
        result = "'";
    }
    else if ( *msgid == 96 )
    {
      result = (const char *)&unk_8055786;
    }
    else
    {
      result = (const char *)&unk_805578A;
    }
  }
  else if ( *msgid == 96 )
  {
    result = (const char *)&unk_8055776;
  }
  else
  {
    result = (const char *)&unk_805577A;
  }
  return result;
}

//----- (0804CDA9) --------------------------------------------------------
int __cdecl sub_804CDA9(int a1, unsigned int a2, char *a3, size_t a4, signed int a5, int a6, int a7, char *a8, char *a9)
{
  int v9; // edx
  int v10; // ecx
  void *v11; // eax
  void *v12; // eax
  int v13; // ecx
  size_t v14; // ebx
  int v15; // edx
  void *v16; // eax
  void *v17; // eax
  void *v18; // eax
  void *v19; // eax
  void *v20; // eax
  char v21; // al
  void *v22; // eax
  void *v23; // eax
  int v24; // ecx
  int v25; // edx
  int v26; // ecx
  void *v27; // eax
  void *v28; // eax
  void *v29; // eax
  void *v30; // eax
  void *v31; // eax
  void *v32; // eax
  char v33; // al
  void *v34; // eax
  void *v35; // eax
  void *v36; // eax
  int result; // eax
  void *v38; // eax
  int v39; // edx
  int v40; // ecx
  void *v41; // eax
  int v42; // edx
  int v43; // ecx
  void *v44; // eax
  char *v45; // [esp+4h] [ebp-84h]
  size_t v46; // [esp+8h] [ebp-80h]
  char *v47; // [esp+2Ch] [ebp-5Ch]
  char *v48; // [esp+30h] [ebp-58h]
  int v49; // [esp+34h] [ebp-54h]
  char *v50; // [esp+38h] [ebp-50h]
  int v51; // [esp+3Ch] [ebp-4Ch]
  char v52; // [esp+40h] [ebp-48h]
  bool v53; // [esp+41h] [ebp-47h]
  char v54; // [esp+42h] [ebp-46h]
  char v55; // [esp+43h] [ebp-45h]
  char v56; // [esp+44h] [ebp-44h]
  unsigned __int8 v57; // [esp+45h] [ebp-43h]
  char v58; // [esp+46h] [ebp-42h]
  char v59; // [esp+47h] [ebp-41h]
  char v60; // [esp+48h] [ebp-40h]
  bool v61; // [esp+49h] [ebp-3Fh]
  bool v62; // [esp+4Ah] [ebp-3Eh]
  bool v63; // [esp+4Bh] [ebp-3Dh]
  wint_t wc; // [esp+4Ch] [ebp-3Ch]
  int v65; // [esp+50h] [ebp-38h]
  unsigned int v66; // [esp+54h] [ebp-34h]
  unsigned int v67; // [esp+58h] [ebp-30h]
  char *s; // [esp+5Ch] [ebp-2Ch]
  size_t n; // [esp+60h] [ebp-28h]
  unsigned int v70; // [esp+64h] [ebp-24h]
  size_t v71; // [esp+6Ch] [ebp-1Ch]
  unsigned int v72; // [esp+70h] [ebp-18h]
  mbstate_t ps; // [esp+74h] [ebp-14h]
  unsigned int v74; // [esp+7Ch] [ebp-Ch]

  v51 = a1;
  v50 = a3;
  v49 = a7;
  v48 = a8;
  v47 = a9;
  v74 = __readgsdword(0x14u);
  v66 = 0;
  v67 = 0;
  s = 0;
  n = 0;
  v52 = 0;
  v63 = __ctype_get_mb_cur_max() == 1;
  v53 = (a6 & 2) != 0;
  v54 = 0;
  v55 = 0;
  v56 = 1;
  while ( 2 )
  {
    switch ( a5 )
    {
      case 0:
        v53 = 0;
        break;
      case 1:
        goto LABEL_20;
      case 2:
        goto LABEL_23;
      case 3:
        goto LABEL_19;
      case 4:
        goto LABEL_21;
      case 5:
        goto LABEL_4;
      case 6:
        a5 = 5;
        v53 = 1;
LABEL_4:
        if ( v53 != 1 )
        {
          if ( v66 < a2 )
          {
            v9 = v51;
            *(_BYTE *)(v51 + v66) = 34;
          }
          ++v66;
        }
        v52 = 1;
        s = (char *)&unk_805578D;
        n = 1;
        break;
      case 7:
        v52 = 1;
        v53 = 0;
        break;
      case 8:
      case 9:
      case 10:
        if ( a5 != 10 )
        {
          v48 = (char *)sub_804CD0E("`", a5);
          v47 = (char *)sub_804CD0E("'", a5);
        }
        if ( v53 != 1 )
        {
          for ( s = v48; *s; ++s )
          {
            if ( v66 < a2 )
              *(_BYTE *)(v66 + v51) = *s;
            ++v66;
          }
        }
        v52 = 1;
        s = v47;
        n = strlen(v47);
        dword_805B1D4 = (int)&loc_804CF85;
        sub_8054A4D();
LABEL_19:
        v52 = 1;
LABEL_20:
        v53 = 1;
LABEL_21:
        if ( v53 != 1 )
          v52 = 1;
LABEL_23:
        a5 = 2;
        if ( v53 != 1 )
        {
          if ( v66 < a2 )
          {
            v9 = v51;
            *(_BYTE *)(v51 + v66) = 39;
          }
          ++v66;
        }
        s = "'";
        n = 1;
        break;
      default:
        abort();
        return result;
    }
    v65 = 0;
    dword_805B288 = (int)&loc_804DAB7;
    sub_80545C3(v10, v9);
    v59 = 0;
    v60 = 0;
    v61 = 0;
    v11 = &loc_804CFCE;
    if ( !v52 )
      v11 = &loc_804D07E;
    dword_805B1D4 = (int)v11;
    sub_8054A4D();
    v12 = &loc_804CFED;
    if ( a5 == 2 )
      v12 = &loc_804D07E;
    dword_805B1C0 = (int)v12;
    sub_8054AE0();
    if ( n )
    {
      v14 = v65 + n;
      if ( a4 == -1 && n > 1 )
      {
        a4 = strlen(v50);
        dword_805B198 = (int)&loc_804D037;
        sub_8054BCA();
      }
      if ( v14 <= a4 && !memcmp(&v50[v65], s, n) )
      {
        if ( v53 )
        {
          dword_805B170 = (int)&loc_804DC73;
          sub_8054CB6();
        }
        v59 = 1;
      }
    }
    v15 = (int)v50;
    v57 = v50[v65];
    switch ( v57 )
    {
      case 0u:
        if ( v52 )
        {
          v16 = &loc_804D0CB;
          if ( !v53 )
            v16 = &loc_804D0E2;
          dword_805B224 = (int)v16;
          sub_8054854();
          dword_805B1E8 = (int)&loc_804DC73;
          sub_80549D7();
          v60 = 1;
          if ( a5 == 2 && v54 != 1 )
          {
            if ( v66 < a2 )
            {
              v15 = v51;
              *(_BYTE *)(v51 + v66) = 39;
            }
            if ( ++v66 < a2 )
            {
              v15 = v51;
              *(_BYTE *)(v51 + v66) = 36;
            }
            if ( ++v66 < a2 )
            {
              v15 = v51;
              *(_BYTE *)(v51 + v66) = 39;
            }
            ++v66;
            v54 = 1;
          }
          if ( v66 < a2 )
          {
            v15 = v51;
            *(_BYTE *)(v51 + v66) = 92;
          }
          ++v66;
          if ( a5 != 2 && v65 + 1 < a4 )
          {
            v15 = v65 + 1;
            if ( v50[v65 + 1] > 47 )
            {
              v15 = v65 + 1;
              if ( v50[v65 + 1] <= 57 )
              {
                if ( v66 < a2 )
                {
                  v15 = v51;
                  *(_BYTE *)(v51 + v66) = 48;
                }
                if ( ++v66 < a2 )
                {
                  v15 = v51;
                  *(_BYTE *)(v51 + v66) = 48;
                }
                ++v66;
              }
            }
          }
          v57 = 48;
        }
        else if ( a6 & 1 )
        {
          goto LABEL_205;
        }
        goto LABEL_172;
      case 7u:
        goto LABEL_77;
      case 8u:
        v58 = 98;
        dword_805B1E8 = (int)&loc_804D3CB;
        sub_80549D7();
        goto LABEL_79;
      case 9u:
        v58 = 116;
        goto LABEL_91;
      case 0xAu:
        v58 = 110;
        goto LABEL_91;
      case 0xBu:
        v58 = 118;
        goto LABEL_94;
      case 0xCu:
LABEL_79:
        v58 = 102;
        goto LABEL_94;
      case 0xDu:
        v58 = 114;
        goto LABEL_91;
      case 0x20u:
        v61 = 1;
        goto LABEL_104;
      case 0x21u:
      case 0x22u:
      case 0x24u:
      case 0x26u:
      case 0x28u:
      case 0x29u:
      case 0x2Au:
      case 0x3Bu:
      case 0x3Cu:
      case 0x3Du:
      case 0x3Eu:
      case 0x5Bu:
      case 0x5Eu:
      case 0x60u:
      case 0x7Cu:
LABEL_104:
        v23 = &loc_804D48F;
        if ( a5 != 2 )
          v23 = &loc_804D49A;
        dword_805B170 = (int)v23;
        sub_8054CB6();
        if ( v53 )
          goto LABEL_235;
        dword_805B1E8 = (int)&loc_804D92C;
        sub_80549D7();
        goto LABEL_108;
      case 0x23u:
      case 0x7Eu:
        goto LABEL_100;
      case 0x25u:
      case 0x2Bu:
      case 0x2Cu:
      case 0x2Du:
      case 0x2Eu:
      case 0x2Fu:
      case 0x30u:
      case 0x31u:
      case 0x32u:
      case 0x33u:
      case 0x34u:
      case 0x35u:
      case 0x36u:
      case 0x37u:
      case 0x38u:
      case 0x39u:
      case 0x3Au:
      case 0x41u:
      case 0x42u:
      case 0x43u:
      case 0x44u:
      case 0x45u:
      case 0x46u:
      case 0x47u:
      case 0x48u:
      case 0x49u:
      case 0x4Au:
      case 0x4Bu:
      case 0x4Cu:
      case 0x4Du:
      case 0x4Eu:
      case 0x4Fu:
      case 0x50u:
      case 0x51u:
      case 0x52u:
      case 0x53u:
      case 0x54u:
      case 0x55u:
      case 0x56u:
      case 0x57u:
      case 0x58u:
      case 0x59u:
      case 0x5Au:
      case 0x5Du:
      case 0x5Fu:
      case 0x61u:
      case 0x62u:
      case 0x63u:
      case 0x64u:
      case 0x65u:
      case 0x66u:
      case 0x67u:
      case 0x68u:
      case 0x69u:
      case 0x6Au:
      case 0x6Bu:
      case 0x6Cu:
      case 0x6Du:
      case 0x6Eu:
      case 0x6Fu:
      case 0x70u:
      case 0x71u:
      case 0x72u:
      case 0x73u:
      case 0x74u:
      case 0x75u:
      case 0x76u:
      case 0x77u:
      case 0x78u:
      case 0x79u:
      case 0x7Au:
        goto LABEL_121;
      case 0x27u:
LABEL_108:
        v55 = 1;
        v61 = 1;
        if ( a5 == 2 )
        {
          if ( v53 )
            goto LABEL_235;
          if ( a2 && !v67 )
          {
            v67 = a2;
            a2 = 0;
          }
          if ( v66 < a2 )
          {
            v15 = v51;
            *(_BYTE *)(v51 + v66) = 39;
          }
          if ( ++v66 < a2 )
          {
            v15 = v51;
            *(_BYTE *)(v51 + v66) = 92;
          }
          if ( ++v66 < a2 )
          {
            v15 = v51;
            *(_BYTE *)(v51 + v66) = 39;
          }
          ++v66;
          v54 = 0;
        }
        else
        {
          dword_805B148 = (int)&loc_804D92C;
          sub_8054D9E(v13, v15);
LABEL_121:
          v61 = 1;
        }
        goto LABEL_172;
      case 0x3Fu:
        if ( a5 != 2 )
        {
          v17 = &loc_804D1FA;
          if ( a5 == 5 )
            v17 = &loc_804D228;
          dword_805B238 = (int)v17;
          sub_80547B0();
          dword_805B210 = (int)&loc_804D92C;
          sub_80548CA();
LABEL_77:
          v58 = 97;
LABEL_94:
          v20 = &loc_804D3EA;
          if ( !v52 )
            v20 = &loc_804D408;
          dword_805B1D4 = (int)v20;
          sub_8054A4D();
          v57 = v58;
          dword_805B1FC = (int)&loc_804D99C;
          sub_805495D();
LABEL_172:
          if ( (v52 != 1 || a5 == 2) && v53 != 1
            || !v49
            || (v13 = v57 & 0x1F, v15 = *(_DWORD *)(4 * (v57 >> 5) + v49) >> v13, !(v15 & 1)) )
          {
            if ( v59 != 1 )
            {
              dword_805B274 = (int)&loc_804DA2E;
              sub_8054652(v13, v15);
            }
          }
          if ( v53 )
          {
            dword_805B260 = (int)&loc_804DC73;
            sub_80546C8();
          }
          v60 = 1;
          if ( a5 == 2 && v54 != 1 )
          {
            if ( v66 < a2 )
            {
              v15 = v51;
              *(_BYTE *)(v51 + v66) = 39;
            }
            if ( ++v66 < a2 )
            {
              v15 = v51;
              *(_BYTE *)(v51 + v66) = 36;
            }
            if ( ++v66 < a2 )
            {
              v15 = v51;
              *(_BYTE *)(v51 + v66) = 39;
            }
            ++v66;
            v54 = 1;
          }
          if ( v66 < a2 )
          {
            v15 = v51;
            *(_BYTE *)(v51 + v66) = 92;
          }
          ++v66;
LABEL_193:
          if ( v54 && v60 != 1 )
          {
            if ( v66 < a2 )
            {
              v15 = v51;
              *(_BYTE *)(v51 + v66) = 39;
            }
            if ( ++v66 < a2 )
            {
              v15 = v51;
              *(_BYTE *)(v51 + v66) = 39;
            }
            ++v66;
            v54 = 0;
          }
          if ( v66 < a2 )
          {
            v15 = v66 + v51;
            *(_BYTE *)(v66 + v51) = v57;
          }
          ++v66;
          v32 = &loc_804DAAF;
          if ( v61 == 1 )
            v32 = &loc_804DAB3;
          dword_805B148 = (int)v32;
          sub_8054D9E(v13, v15);
          v56 = 0;
LABEL_205:
          ++v65;
          if ( a4 == -1 )
          {
            v33 = v50[v65];
            dword_805B260 = (int)&loc_804DAED;
            sub_80546C8();
          }
          v34 = &loc_804DB0A;
          if ( v65 != a4 )
            v34 = &loc_804CFA3;
          dword_805B170 = (int)v34;
          sub_8054CB6();
          if ( !v66 && a5 == 2 )
          {
            v35 = &loc_804DB35;
            if ( !v53 )
              v35 = &loc_804DB3A;
            dword_805B260 = (int)v35;
            sub_80546C8();
            goto LABEL_235;
          }
          v36 = &loc_804DB59;
          if ( a5 != 2 )
            v36 = &loc_804DBD7;
          dword_805B1FC = (int)v36;
          sub_805495D();
          if ( v53 == 1 || !v55 )
          {
LABEL_223:
            v38 = &loc_804DBF6;
            if ( !s )
              v38 = &loc_804DC46;
            dword_805B24C = (int)v38;
            sub_8054736();
            v41 = &loc_804DC1A;
            if ( v53 == 1 )
              v41 = &loc_804DC46;
            dword_805B288 = (int)v41;
            sub_80545C3(v40, v39);
            while ( *s )
            {
              if ( v66 < a2 )
              {
                v42 = v66 + v51;
                *(_BYTE *)(v66 + v51) = *s;
              }
              ++v66;
              ++s;
            }
            if ( v66 < a2 )
            {
              v42 = v51;
              *(_BYTE *)(v51 + v66) = 0;
            }
            dword_805B15C = (int)&loc_804DCE8;
            sub_8054D26(v43, v42);
            goto LABEL_235;
          }
          if ( v56 )
            return sub_804CDA9(v51, v67, v50, a4, 5, a6, v49, v48, v47);
          if ( a2 || !v67 )
            goto LABEL_223;
          a2 = v67;
          v66 = 0;
          continue;
        }
        v18 = &loc_804D21E;
        if ( !v53 )
          v18 = &loc_804D223;
        dword_805B1D4 = (int)v18;
        sub_8054A4D();
LABEL_235:
        if ( a5 == 2 )
        {
          v44 = &loc_804DC98;
          if ( !v52 )
            v44 = &loc_804DC9F;
          dword_805B210 = (int)v44;
          sub_80548CA();
          a5 = 4;
        }
        return sub_804CDA9(v51, a2, v50, a4, a5, a6 & 0xFFFFFFFD, 0, v48, v47);
      case 0x5Cu:
        v58 = v57;
        if ( a5 == 2 )
        {
          if ( v53 )
            goto LABEL_235;
        }
        else
        {
          v19 = &loc_804D397;
          if ( !v52 )
            v19 = &loc_804D3A8;
          dword_805B148 = (int)v19;
          sub_8054D9E(v13, v50);
          if ( !v53 || !n )
          {
LABEL_91:
            if ( a5 == 2 && v53 )
            {
              dword_805B198 = (int)&loc_804DC73;
              sub_8054BCA();
            }
            goto LABEL_94;
          }
        }
        goto LABEL_193;
      case 0x7Bu:
      case 0x7Du:
        if ( a4 == -1 )
        {
          v21 = v50[1];
          dword_805B1C0 = (int)&loc_804D43F;
          sub_8054AE0();
        }
        if ( a4 == 1 )
        {
LABEL_100:
          v22 = &loc_804D467;
          if ( !v65 )
            v22 = &loc_804D46C;
          dword_805B238 = (int)v22;
          sub_80547B0();
        }
        goto LABEL_172;
      default:
        if ( v63 )
        {
          v70 = 1;
          v62 = ((*__ctype_b_loc())[v57] & 0x4000) != 0;
        }
        else
        {
          memset(&ps, 0, 8u);
          v70 = 0;
          v62 = 1;
          v27 = &loc_804D5CA;
          if ( a4 != -1 )
            v27 = &loc_804D5D8;
          dword_805B288 = (int)v27;
          sub_80545C3(v26, v25);
          a4 = strlen(v50);
          v46 = a4 - (v70 + v65);
          v45 = &v50[v70 + v65];
          v71 = sub_8051C2D((wchar_t *)&wc, v45, v46, &ps);
          if ( v71 )
          {
            v28 = &loc_804D63B;
            if ( v71 != -1 )
              v28 = &loc_804D644;
            dword_805B1E8 = (int)v28;
            sub_80549D7();
            v62 = 0;
          }
        }
        v61 = v62;
        if ( v70 <= 1 )
        {
          v29 = &loc_804D730;
          if ( !v52 )
            v29 = &loc_804D92C;
          dword_805B210 = (int)v29;
          sub_80548CA();
          v30 = &loc_804D754;
          if ( v62 == 1 )
            v30 = &loc_804D92C;
          dword_805B24C = (int)v30;
          sub_8054736();
        }
        v72 = v65 + v70;
        if ( v52 && v62 != 1 )
        {
          if ( v53 )
            goto LABEL_235;
          v60 = 1;
          v31 = &loc_804D7A6;
          if ( a5 != 2 )
            v31 = &loc_804D7FA;
          dword_805B210 = (int)v31;
          sub_80548CA();
          if ( v54 != 1 )
          {
            if ( v66 < a2 )
              *(_BYTE *)(v51 + v66) = 39;
            if ( ++v66 < a2 )
              *(_BYTE *)(v51 + v66) = 36;
            if ( ++v66 < a2 )
              *(_BYTE *)(v51 + v66) = 39;
            ++v66;
            v54 = 1;
          }
          if ( v66 < a2 )
            *(_BYTE *)(v51 + v66) = 92;
          if ( ++v66 < a2 )
            *(_BYTE *)(v66 + v51) = (v57 >> 6) + 48;
          if ( ++v66 < a2 )
            *(_BYTE *)(v66 + v51) = ((v57 >> 3) & 7) + 48;
          ++v66;
          v57 = (v57 & 7) + 48;
        }
        else if ( v59 )
        {
          if ( v66 < a2 )
            *(_BYTE *)(v51 + v66) = 92;
          ++v66;
          v59 = 0;
        }
        if ( v65 + 1 >= v72 )
        {
          dword_805B1C0 = (int)&loc_804DA2E;
          sub_8054AE0();
        }
        if ( v54 && v60 != 1 )
        {
          if ( v66 < a2 )
            *(_BYTE *)(v51 + v66) = 39;
          if ( ++v66 < a2 )
            *(_BYTE *)(v51 + v66) = 39;
          ++v66;
          v54 = 0;
        }
        if ( v66 < a2 )
          *(_BYTE *)(v66 + v51) = v57;
        ++v66;
        v57 = v50[++v65];
        dword_805B288 = (int)&loc_804D75F;
        sub_80545C3(v24, v50);
        goto LABEL_172;
    }
  }
}
// 8054652: using guessed type int __fastcall sub_8054652(_DWORD, _DWORD);
// 80546C8: using guessed type int sub_80546C8(void);
// 8054736: using guessed type int sub_8054736(void);
// 80547B0: using guessed type int sub_80547B0(void);
// 8054854: using guessed type int sub_8054854(void);
// 80548CA: using guessed type int sub_80548CA(void);
// 805495D: using guessed type int sub_805495D(void);
// 80549D7: using guessed type int sub_80549D7(void);
// 8054A4D: using guessed type int sub_8054A4D(void);
// 8054AE0: using guessed type int sub_8054AE0(void);
// 8054BCA: using guessed type int sub_8054BCA(void);
// 8054CB6: using guessed type int sub_8054CB6(void);
// 8054D26: using guessed type int __fastcall sub_8054D26(_DWORD, _DWORD);
// 8054D9E: using guessed type int __fastcall sub_8054D9E(_DWORD, _DWORD);
// 805B148: using guessed type int dword_805B148;
// 805B15C: using guessed type int dword_805B15C;
// 805B170: using guessed type int dword_805B170;
// 805B198: using guessed type int dword_805B198;
// 805B1C0: using guessed type int dword_805B1C0;
// 805B1D4: using guessed type int dword_805B1D4;
// 805B1E8: using guessed type int dword_805B1E8;
// 805B1FC: using guessed type int dword_805B1FC;
// 805B210: using guessed type int dword_805B210;
// 805B224: using guessed type int dword_805B224;
// 805B238: using guessed type int dword_805B238;
// 805B24C: using guessed type int dword_805B24C;
// 805B260: using guessed type int dword_805B260;
// 805B274: using guessed type int dword_805B274;
// 805B288: using guessed type int dword_805B288;

//----- (0804DDE4) --------------------------------------------------------
int __cdecl sub_804DDE4(char *a1, size_t a2, _DWORD *a3, int *a4)
{
  int *v4; // eax
  int *v5; // ST3C_4
  int v6; // ST40_4
  int v7; // ST44_4
  int size; // [esp+48h] [ebp-10h]
  int v10; // [esp+4Ch] [ebp-Ch]

  if ( a4 )
    v4 = a4;
  else
    v4 = &dword_805B9A4;
  v5 = v4;
  v6 = *__errno_location();
  v7 = v5[1] | (a3 == 0);
  size = sub_804CDA9(0, 0, a1, a2, *v5, v7, (int)(v5 + 2), (char *)v5[10], (char *)v5[11]) + 1;
  v10 = sub_8050A85(size);
  sub_804CDA9(v10, size, a1, a2, *v5, v7, (int)(v5 + 2), (char *)v5[10], (char *)v5[11]);
  *__errno_location() = v6;
  if ( a3 )
    *a3 = size - 1;
  return v10;
}
// 805B9A4: using guessed type int dword_805B9A4;

//----- (0804DF8B) --------------------------------------------------------
int __cdecl sub_804DF8B(int a1)
{
  int v1; // edx
  int v2; // ecx
  int v3; // ST40_4

  v3 = *__errno_location();
  dword_805B2A4 = (int (__fastcall *)(_DWORD, _DWORD))sub_804DFC1;
  if ( a1 < 0 )
    abort();
  return dword_805B2A4(v2, v1);
}
// 805B2A4: using guessed type int (__fastcall *dword_805B2A4)(_DWORD, _DWORD);

//----- (0804DFC1) --------------------------------------------------------
int __usercall sub_804DFC1@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebp>, int a4, unsigned int a5)
{
  bool v5; // zf
  bool v6; // sf
  unsigned __int8 v7; // of

  v7 = __OFSUB__(dword_805B2D8, *(_DWORD *)(a3 + 8));
  v5 = dword_805B2D8 == *(_DWORD *)(a3 + 8);
  v6 = dword_805B2D8 - *(_DWORD *)(a3 + 8) < 0;
  dword_805B2A4 = (int (__fastcall *)(_DWORD, _DWORD))&loc_804E0D3;
  if ( (unsigned __int8)(v6 ^ v7) | v5 )
  {
    dword_805B2A4 = (int (__fastcall *)(_DWORD, _DWORD))sub_804E00B;
    if ( a5 > 0xFFFFFFE )
      sub_8050C3A();
  }
  return dword_805B2A4(a2, a1);
}
// 805B2A4: using guessed type int (__fastcall *dword_805B2A4)(_DWORD, _DWORD);
// 805B2D8: using guessed type int dword_805B2D8;

//----- (0804E00B) --------------------------------------------------------
int __usercall sub_804E00B@<eax>(int a1@<ecx>, int a2@<ebp>)
{
  int v2; // edx
  bool v3; // zf

  v2 = 8 * (*(_DWORD *)(a2 + 8) + 1);
  v3 = *(_BYTE *)(a2 - 33) == 0;
  dword_805B2A4 = (int (__fastcall *)(_DWORD, _DWORD))&sub_804E048;
  if ( !v3 )
    dword_805B2A4 = (int (__fastcall *)(_DWORD, _DWORD))&loc_804E04B;
  return dword_805B2A4(a1, v2);
}
// 805B2A4: using guessed type int (__fastcall *dword_805B2A4)(_DWORD, _DWORD);

//----- (0804E048) --------------------------------------------------------
#error "804E238: positive sp value has been found (funcsize=135)"

//----- (0804E23B) --------------------------------------------------------
int __cdecl sub_804E23B(int a1)
{
  return sub_804DF8B(a1);
}

//----- (0804E265) --------------------------------------------------------
int __cdecl sub_804E265(int a1)
{
  return sub_804DF8B(a1);
}

//----- (0804E2CB) --------------------------------------------------------
int __cdecl sub_804E2CB(int a1, int a2)
{
  char v3; // [esp+10h] [ebp-38h]

  sub_804CC8C(&v3, a2);
  return sub_804DF8B(a1);
}

//----- (0804E309) --------------------------------------------------------
int __cdecl sub_804E309(int a1, int a2)
{
  char v3; // [esp+10h] [ebp-38h]

  sub_804CC8C(&v3, a2);
  return sub_804DF8B(a1);
}

//----- (0804E391) --------------------------------------------------------
int __cdecl sub_804E391(int a1, int a2, unsigned __int8 a3)
{
  int v4; // [esp+20h] [ebp-38h]
  int v5; // [esp+24h] [ebp-34h]
  int v6; // [esp+28h] [ebp-30h]
  int v7; // [esp+2Ch] [ebp-2Ch]
  int v8; // [esp+30h] [ebp-28h]
  int v9; // [esp+34h] [ebp-24h]
  int v10; // [esp+38h] [ebp-20h]
  int v11; // [esp+3Ch] [ebp-1Ch]
  int v12; // [esp+40h] [ebp-18h]
  int v13; // [esp+44h] [ebp-14h]
  int v14; // [esp+48h] [ebp-10h]
  int v15; // [esp+4Ch] [ebp-Ch]

  v4 = dword_805B9A4;
  v5 = dword_805B9A8;
  v6 = dword_805B9AC;
  v7 = dword_805B9B0;
  v8 = dword_805B9B4;
  v9 = dword_805B9B8;
  v10 = dword_805B9BC;
  v11 = dword_805B9C0;
  v12 = dword_805B9C4;
  v13 = dword_805B9C8;
  v14 = dword_805B9CC;
  v15 = dword_805B9D0;
  sub_804CB52(&v4, a3, 1);
  return sub_804DF8B(0);
}
// 805B9A4: using guessed type int dword_805B9A4;
// 805B9A8: using guessed type int dword_805B9A8;
// 805B9AC: using guessed type int dword_805B9AC;
// 805B9B0: using guessed type int dword_805B9B0;
// 805B9B4: using guessed type int dword_805B9B4;
// 805B9B8: using guessed type int dword_805B9B8;
// 805B9BC: using guessed type int dword_805B9BC;
// 805B9C0: using guessed type int dword_805B9C0;
// 805B9C4: using guessed type int dword_805B9C4;
// 805B9C8: using guessed type int dword_805B9C8;
// 805B9CC: using guessed type int dword_805B9CC;
// 805B9D0: using guessed type int dword_805B9D0;

//----- (0804E43B) --------------------------------------------------------
int __cdecl sub_804E43B(int a1, unsigned __int8 a2)
{
  return sub_804E391(a1, -1, a2);
}

//----- (0804E464) --------------------------------------------------------
int __cdecl sub_804E464(int a1)
{
  return sub_804E43B(a1, 0x3Au);
}

//----- (0804E4A1) --------------------------------------------------------
int __cdecl sub_804E4A1(int a1, int a2)
{
  int v3; // [esp+10h] [ebp-68h]
  int v4; // [esp+14h] [ebp-64h]
  int v5; // [esp+18h] [ebp-60h]
  int v6; // [esp+1Ch] [ebp-5Ch]
  int v7; // [esp+20h] [ebp-58h]
  int v8; // [esp+24h] [ebp-54h]
  int v9; // [esp+28h] [ebp-50h]
  int v10; // [esp+2Ch] [ebp-4Ch]
  int v11; // [esp+30h] [ebp-48h]
  int v12; // [esp+34h] [ebp-44h]
  int v13; // [esp+38h] [ebp-40h]
  int v14; // [esp+3Ch] [ebp-3Ch]
  int v15; // [esp+40h] [ebp-38h]
  int v16; // [esp+44h] [ebp-34h]
  int v17; // [esp+48h] [ebp-30h]
  int v18; // [esp+4Ch] [ebp-2Ch]
  int v19; // [esp+50h] [ebp-28h]
  int v20; // [esp+54h] [ebp-24h]
  int v21; // [esp+58h] [ebp-20h]
  int v22; // [esp+5Ch] [ebp-1Ch]
  int v23; // [esp+60h] [ebp-18h]
  int v24; // [esp+64h] [ebp-14h]
  int v25; // [esp+68h] [ebp-10h]
  int v26; // [esp+6Ch] [ebp-Ch]

  sub_804CC8C(&v3, a2);
  v15 = v3;
  v16 = v4;
  v17 = v5;
  v18 = v6;
  v19 = v7;
  v20 = v8;
  v21 = v9;
  v22 = v10;
  v23 = v11;
  v24 = v12;
  v25 = v13;
  v26 = v14;
  sub_804CB52(&v15, 0x3Au, 1);
  return sub_804DF8B(a1);
}

//----- (0804E542) --------------------------------------------------------
int __usercall sub_804E542@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5)
{
  return sub_804E572(a1, a2, a3, a4, a5);
}

//----- (0804E572) --------------------------------------------------------
int __usercall sub_804E572@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5)
{
  int v6; // [esp+10h] [ebp-38h]
  int v7; // [esp+14h] [ebp-34h]
  int v8; // [esp+18h] [ebp-30h]
  int v9; // [esp+1Ch] [ebp-2Ch]
  int v10; // [esp+20h] [ebp-28h]
  int v11; // [esp+24h] [ebp-24h]
  int v12; // [esp+28h] [ebp-20h]
  int v13; // [esp+2Ch] [ebp-1Ch]
  int v14; // [esp+30h] [ebp-18h]
  int v15; // [esp+34h] [ebp-14h]
  int v16; // [esp+38h] [ebp-10h]
  int v17; // [esp+3Ch] [ebp-Ch]

  v6 = dword_805B9A4;
  v7 = dword_805B9A8;
  v8 = dword_805B9AC;
  v9 = dword_805B9B0;
  v10 = dword_805B9B4;
  v11 = dword_805B9B8;
  v12 = dword_805B9BC;
  v13 = dword_805B9C0;
  v14 = dword_805B9C4;
  v15 = dword_805B9C8;
  v16 = dword_805B9CC;
  v17 = dword_805B9D0;
  sub_804CC15(a2, a1, (int)&v6, a4, a5);
  return sub_804DF8B(a3);
}
// 805B9A4: using guessed type int dword_805B9A4;
// 805B9A8: using guessed type int dword_805B9A8;
// 805B9AC: using guessed type int dword_805B9AC;
// 805B9B0: using guessed type int dword_805B9B0;
// 805B9B4: using guessed type int dword_805B9B4;
// 805B9B8: using guessed type int dword_805B9B8;
// 805B9BC: using guessed type int dword_805B9BC;
// 805B9C0: using guessed type int dword_805B9C0;
// 805B9C4: using guessed type int dword_805B9C4;
// 805B9C8: using guessed type int dword_805B9C8;
// 805B9CC: using guessed type int dword_805B9CC;
// 805B9D0: using guessed type int dword_805B9D0;

//----- (0804E66C) --------------------------------------------------------
int __cdecl sub_804E66C(int a1)
{
  return sub_804DF8B(a1);
}

//----- (0804E6B7) --------------------------------------------------------
int __cdecl sub_804E6B7(int a1)
{
  return sub_804E66C(a1);
}

//----- (0804E6D9) --------------------------------------------------------
int sub_804E6D9()
{
  return sub_804E6B7(0);
}

//----- (0804E6F4) --------------------------------------------------------
_DWORD *__cdecl sub_804E6F4(int a1)
{
  _DWORD *result; // eax
  int v2; // edx

  result = (_DWORD *)sub_8050A98(0x14u);
  *result = a1;
  result[3] = 0;
  result[4] = 0;
  v2 = result[4];
  result[1] = result[3];
  result[2] = v2;
  return result;
}

//----- (0804E739) --------------------------------------------------------
int __cdecl sub_804E739(int a1, size_t n)
{
  char *v3; // [esp+1Ch] [ebp-Ch]

  v3 = sub_804F251(a1, n);
  if ( v3 )
  {
    sub_804E6F4((int)v3);
    dword_805B1D4 = (int)&locret_804E781;
    sub_8054A4D();
  }
  return 0;
}
// 8054A4D: using guessed type int sub_8054A4D(void);
// 805B1D4: using guessed type int dword_805B1D4;

//----- (0804E78D) --------------------------------------------------------
__int64 __cdecl sub_804E78D(__int64 a1)
{
  return a1 << 8;
}

//----- (0804E7AE) --------------------------------------------------------
int __cdecl __noreturn sub_804E7AE(int *a1, unsigned __int64 a2)
{
  int v2; // edx
  int v3; // edx
  __int64 v4; // rax
  int v5; // ecx
  unsigned __int64 v6; // rax
  __int64 v7; // rax
  int *v8; // eax
  int v9; // edx
  int *v10; // ecx
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // rax
  int *v14; // ecx
  __int64 v15; // rax
  int *v16; // ecx
  int (*v17)(); // eax
  unsigned __int64 v19; // [esp+10h] [ebp-88h]
  int *v20; // [esp+1Ch] [ebp-7Ch]
  size_t n; // [esp+28h] [ebp-70h]
  int v22; // [esp+2Ch] [ebp-6Ch]
  unsigned __int64 v23; // [esp+30h] [ebp-68h]
  unsigned __int64 v24; // [esp+38h] [ebp-60h]
  __int64 v25; // [esp+40h] [ebp-58h]
  unsigned __int64 v26; // [esp+48h] [ebp-50h]
  unsigned __int64 v27; // [esp+50h] [ebp-48h]
  __int64 v28; // [esp+58h] [ebp-40h]
  unsigned __int64 v29; // [esp+60h] [ebp-38h]
  unsigned __int64 v30; // [esp+68h] [ebp-30h]
  char ptr[8]; // [esp+74h] [ebp-24h]
  unsigned int v32; // [esp+7Ch] [ebp-1Ch]

  v20 = a1;
  v19 = a2;
  v32 = __readgsdword(0x14u);
  v22 = *a1;
  v2 = a1[2];
  LODWORD(v23) = a1[1];
  HIDWORD(v23) = v2;
  v3 = a1[4];
  LODWORD(v24) = a1[3];
  HIDWORD(v24) = v3;
  v26 = a2 + 1;
  while ( 1 )
  {
    if ( v24 < v19 )
    {
      n = 0;
      v25 = v24;
      do
      {
        v4 = sub_804E78D(v25);
        v25 = v4 + 255;
        ++n;
        v6 = v4 + 255;
      }
      while ( v6 < v19 );
      sub_804F50F(SHIDWORD(v6), v5, v22, ptr, n);
      n = 0;
      do
      {
        v7 = sub_804E78D(v23);
        v23 = (unsigned __int8)ptr[n] + v7;
        v24 = sub_804E78D(v24) + 255;
        ++n;
      }
      while ( v24 < v19 );
    }
    if ( v19 == v24 )
    {
      v8 = v20;
      v20[3] = 0;
      v8[4] = 0;
      v9 = v20[4];
      v10 = v20;
      v20[1] = v20[3];
      v10[2] = v9;
      dword_805B15C = (int)&loc_804EA93;
      sub_8054D26(v10, HIDWORD(v23));
    }
    v27 = v24 - v19;
    LODWORD(v11) = sub_8054265(v24 - v19, v26);
    v28 = v11;
    v29 = v24 - v11;
    LODWORD(v12) = sub_8054265(v23, v26);
    v30 = v12;
    if ( v23 <= v29 )
      break;
    v23 = v30;
    v24 = v28 - 1;
  }
  v13 = sub_805412C(v23, HIDWORD(v23), v26, SHIDWORD(v26));
  v14 = v20;
  v20[1] = v13;
  v14[2] = HIDWORD(v13);
  v15 = sub_805412C(v27, HIDWORD(v27), v26, SHIDWORD(v26));
  v16 = v20;
  v20[3] = v15;
  v16[4] = HIDWORD(v15);
  v17 = (int (*)())&loc_804EAB8;
  if ( __readgsdword(0x14u) == v32 )
    v17 = sub_804EABD;
  dword_805B274 = (int)v17;
  return sub_8054652(v16, HIDWORD(v30));
}
// 804EABD: using guessed type int sub_804EABD();
// 8054652: using guessed type int __fastcall sub_8054652(_DWORD, _DWORD);
// 8054D26: using guessed type int __fastcall sub_8054D26(_DWORD, _DWORD);
// 805B15C: using guessed type int dword_805B15C;
// 805B274: using guessed type int dword_805B274;
// 804E7AE: using guessed type char ptr[8];

//----- (0804EABD) --------------------------------------------------------
#error "804EAC3: positive sp value has been found (funcsize=0)"

//----- (0804EAC8) --------------------------------------------------------
void __cdecl sub_804EAC8(void *ptr)
{
  explicit_bzero(ptr, 20);
  free(ptr);
}
// 8049330: using guessed type int __cdecl explicit_bzero(_DWORD, _DWORD);

//----- (0804EB28) --------------------------------------------------------
void __cdecl __noreturn sub_804EB28(int *a1, __int64 a2)
{
  sub_804E7AE(a1, a2 - 1);
}

//----- (0804EB5B) --------------------------------------------------------
int __cdecl sub_804EB5B(int a1)
{
  int v2; // [esp+Ch] [ebp-4h]
  unsigned int i; // [esp+18h] [ebp+8h]

  v2 = 0;
  for ( i = a1 - 1; i; i >>= 1 )
    ++v2;
  return v2;
}

//----- (0804EB85) --------------------------------------------------------
unsigned int __cdecl sub_804EB85(int a1, int a2)
{
  return (unsigned int)(a1 * sub_804EB5B(a2) + 7) >> 3;
}

//----- (0804EBB4) --------------------------------------------------------
int __cdecl sub_804EBB4(int a1, int a2, int a3)
{
  int v3; // ST0C_4
  int result; // eax

  v3 = *(_DWORD *)(4 * a2 + a1);
  *(_DWORD *)(a1 + 4 * a2) = *(_DWORD *)(4 * a3 + a1);
  result = v3;
  *(_DWORD *)(a1 + 4 * a3) = v3;
  return result;
}

//----- (0804EC06) --------------------------------------------------------
int __cdecl sub_804EC06(_DWORD *a1, unsigned int a2)
{
  return *a1 % a2;
}

//----- (0804EC23) --------------------------------------------------------
bool __cdecl sub_804EC23(_DWORD *a1, _DWORD *a2)
{
  return *a1 == *a2;
}

//----- (0804EC46) --------------------------------------------------------
void *__cdecl sub_804EC46(unsigned int a1)
{
  return sub_8052711(
           a1,
           0,
           (unsigned int (__cdecl *)(int, unsigned int))sub_804EC06,
           (bool (__cdecl *)(int, int))sub_804EC23,
           (int)free);
}

//----- (0804EC79) --------------------------------------------------------
int __cdecl sub_804EC79(unsigned int *a1, int a2, int a3, int a4)
{
  int v4; // ST1C_4
  int result; // eax
  _DWORD *v6; // [esp+14h] [ebp-24h]
  _DWORD *v7; // [esp+18h] [ebp-20h]
  int v8; // [esp+20h] [ebp-18h]
  int v9; // [esp+24h] [ebp-14h]
  int v10; // [esp+28h] [ebp-10h]
  int v11; // [esp+2Ch] [ebp-Ch]

  v8 = a3;
  v9 = 0;
  v6 = (_DWORD *)sub_8053311((int)a1, (int)&v8);
  v10 = a4;
  v11 = 0;
  v7 = (_DWORD *)sub_8053311((int)a1, (int)&v10);
  if ( !v6 )
  {
    v6 = (_DWORD *)sub_8050A98(8u);
    v6[1] = a3;
    *v6 = v6[1];
  }
  if ( !v7 )
  {
    v7 = (_DWORD *)sub_8050A98(8u);
    v7[1] = a4;
    *v7 = v7[1];
  }
  v4 = v6[1];
  v6[1] = v7[1];
  v7[1] = v4;
  if ( !sub_805328C(a1, (int)v6) )
    sub_8050C3A();
  if ( !sub_805328C(a1, (int)v7) )
    sub_8050C3A();
  result = v6[1];
  *(_DWORD *)(a2 + 4 * a3) = result;
  return result;
}

//----- (0804ED82) --------------------------------------------------------
void __cdecl sub_804ED82(void *a1)
{
  sub_8052912(a1);
}

//----- (0804ED95) --------------------------------------------------------
void *__cdecl sub_804ED95(int *a1, unsigned int a2, unsigned int a3)
{
  bool v3; // al
  void *v4; // eax
  bool v6; // [esp+1Fh] [ebp-19h]
  void *ptr; // [esp+20h] [ebp-18h]
  unsigned int i; // [esp+24h] [ebp-14h]
  void *v9; // [esp+28h] [ebp-10h]

  if ( !a2 )
    return 0;
  if ( a2 == 1 )
  {
    ptr = (void *)sub_8050A98(4u);
    sub_804EB28(a1, a3);
  }
  v3 = a3 > 0x1FFFF && a3 / a2 > 0x1F;
  v6 = v3;
  if ( v3 )
  {
    v9 = sub_804EC46(2 * a2);
    if ( !v9 )
      sub_8050C3A();
    ptr = (void *)sub_8050972(a2, 4u);
  }
  else
  {
    v9 = 0;
    ptr = (void *)sub_8050972(a3, 4u);
    for ( i = 0; i < a3; ++i )
      *((_DWORD *)ptr + i) = i;
  }
  i = 0;
  if ( i < a2 )
    sub_804EB28(a1, a3 - i);
  v4 = &loc_804EF49;
  if ( !v6 )
    v4 = &loc_804EF6B;
  dword_805B238 = (int)v4;
  sub_80547B0();
  sub_804ED82(v9);
  dword_805B1C0 = (int)&loc_804EF88;
  sub_8054AE0();
  return sub_80509A0(ptr, a2, 4);
}
// 80547B0: using guessed type int sub_80547B0(void);
// 8054AE0: using guessed type int sub_8054AE0(void);
// 805B1C0: using guessed type int dword_805B1C0;
// 805B238: using guessed type int dword_805B238;

//----- (0804EF8D) --------------------------------------------------------
void __cdecl __noreturn sub_804EF8D(int a1)
{
  void *v1; // eax
  int v2; // esi
  char *v3; // ebx
  int *v4; // eax

  v1 = &loc_804EFB4;
  if ( !a1 )
    v1 = &loc_804F00A;
  dword_805B1C0 = (int)v1;
  sub_8054AE0();
  v2 = sub_804E6D9();
  if ( *__errno_location() )
    v3 = gettext("%s: read error");
  else
    v3 = gettext("%s: end of file");
  v4 = __errno_location();
  error(status, *v4, v3, v2);
  abort();
}
// 8054AE0: using guessed type int sub_8054AE0(void);
// 805B1C0: using guessed type int dword_805B1C0;

//----- (0804F00F) --------------------------------------------------------
_DWORD *__cdecl sub_804F00F(int a1, int a2)
{
  _DWORD *result; // eax

  result = (_DWORD *)sub_8050A98(0x81Cu);
  *result = a1;
  result[1] = sub_804EF8D;
  result[2] = a2;
  return result;
}

//----- (0804F044) --------------------------------------------------------
unsigned int __cdecl sub_804F044(int a1, int a2, size_t nbytes)
{
  size_t v3; // eax
  int v4; // eax
  size_t n; // ST24_4
  int v6; // eax
  size_t v7; // ST28_4
  int v8; // eax
  size_t v9; // ST2C_4
  int v10; // eax
  size_t v11; // ST30_4
  unsigned int result; // eax
  int v13; // eax
  size_t v14; // ST34_4
  unsigned int v15; // [esp+18h] [ebp-30h]
  int fd; // [esp+20h] [ebp-28h]
  struct timeval tv; // [esp+38h] [ebp-10h]

  v15 = 0;
  fd = open64("/dev/urandom", 0);
  if ( fd >= 0 )
  {
    v3 = a2;
    if ( nbytes <= a2 )
      v3 = nbytes;
    v15 = read(fd, (void *)a1, v3);
    if ( (v15 & 0x80000000) != 0 )
      v15 = 0;
    close(fd);
  }
  if ( v15 < a2 )
  {
    v4 = a2 - v15;
    if ( a2 - v15 > 8 )
      v4 = 8;
    n = v4;
    gettimeofday(&tv, 0);
    memcpy((void *)(a1 + v15), &tv, n);
    v15 += n;
  }
  if ( v15 < a2 )
  {
    v6 = a2 - v15;
    if ( a2 - v15 > 4 )
      v6 = 4;
    v7 = v6;
    tv.tv_sec = getpid();
    memcpy((void *)(a1 + v15), &tv, v7);
    v15 += v7;
  }
  if ( v15 < a2 )
  {
    v8 = a2 - v15;
    if ( a2 - v15 > 4 )
      v8 = 4;
    v9 = v8;
    tv.tv_sec = getppid();
    memcpy((void *)(a1 + v15), &tv, v9);
    v15 += v9;
  }
  if ( v15 < a2 )
  {
    v10 = a2 - v15;
    if ( a2 - v15 > 4 )
      v10 = 4;
    v11 = v10;
    tv.tv_sec = getuid();
    memcpy((void *)(a1 + v15), &tv, v11);
    v15 += v11;
  }
  result = v15;
  if ( v15 < a2 )
  {
    v13 = a2 - v15;
    if ( a2 - v15 > 4 )
      v13 = 4;
    v14 = v13;
    tv.tv_sec = getgid();
    memcpy((void *)(a1 + v15), &tv, v14);
    result = v15 + v14;
  }
  return result;
}
// 8048F50: using guessed type int __cdecl open64(_DWORD, _DWORD);

//----- (0804F251) --------------------------------------------------------
char *__cdecl sub_804F251(int a1, size_t n)
{
  void *v3; // eax
  size_t v4; // eax
  FILE *stream; // [esp+18h] [ebp-10h]
  char *v6; // [esp+1Ch] [ebp-Ch]

  if ( !n )
    return (char *)sub_804F00F(0, 0);
  stream = 0;
  if ( a1 )
  {
    stream = sub_8051DB7(a1, "rb");
    if ( !stream )
      return 0;
  }
  v6 = (char *)sub_804F00F((int)stream, a1);
  v3 = &loc_804F2DD;
  if ( !stream )
    v3 = &loc_804F310;
  dword_805B1D4 = (int)v3;
  sub_8054A4D();
  v4 = 2048;
  if ( n <= 0x800 )
    v4 = n;
  setvbuf(stream, v6 + 12, 0, v4);
  return v6;
}
// 8054A4D: using guessed type int sub_8054A4D(void);
// 805B1D4: using guessed type int dword_805B1D4;

//----- (0804F366) --------------------------------------------------------
size_t __cdecl sub_804F366(int a1, void *ptr, size_t n)
{
  size_t v3; // ST18_4
  size_t result; // eax
  int *v5; // ebx
  int v6; // eax
  int v7; // [esp+1Ch] [ebp-Ch]

  while ( 1 )
  {
    v3 = fread_unlocked(ptr, 1u, n, *(FILE **)a1);
    v7 = *__errno_location();
    ptr = (char *)ptr + v3;
    result = v3;
    n -= v3;
    if ( !n )
      break;
    v5 = __errno_location();
    if ( ferror_unlocked(*(FILE **)a1) )
      v6 = v7;
    else
      v6 = 0;
    *v5 = v6;
    (*(void (__cdecl **)(_DWORD))(a1 + 4))(*(_DWORD *)(a1 + 8));
  }
  return result;
}

//----- (0804F3EE) --------------------------------------------------------
int __cdecl sub_804F3EE(int a1, void *dest, size_t n)
{
  int result; // eax
  size_t v4; // [esp+14h] [ebp-14h]
  int *v5; // [esp+18h] [ebp-10h]
  char *v6; // [esp+1Ch] [ebp-Ch]
  size_t na; // [esp+38h] [ebp+10h]

  v4 = *(_DWORD *)a1;
  v6 = (char *)dest;
  if ( n > v4 )
  {
    memcpy(dest, (const void *)(a1 + 1024 - v4 + 1040), v4);
    na = n - v4;
    if ( !(((_BYTE)v6 + (_BYTE)v4) & 3) )
    {
      v5 = (int *)&v6[v4];
      while ( na > 0x3FF )
      {
        sub_804F5F8((unsigned int *)(a1 + 4), v5);
        v5 += 256;
        na -= 1024;
        if ( !na )
        {
          result = a1;
          *(_DWORD *)a1 = 0;
          return result;
        }
      }
    }
    sub_804F5F8((unsigned int *)(a1 + 4), (int *)(a1 + 1040));
    v4 = 1024;
    dword_805B238 = (int)&loc_804F3FC;
    result = sub_80547B0();
  }
  else
  {
    memcpy(dest, (const void *)(a1 + 1024 - v4 + 1040), n);
    result = a1;
    *(_DWORD *)a1 = v4 - n;
  }
  return result;
}
// 80547B0: using guessed type int sub_80547B0(void);
// 805B238: using guessed type int dword_805B238;

//----- (0804F50F) --------------------------------------------------------
size_t __usercall sub_804F50F@<eax>(int edx0@<edx>, int a2@<ecx>, int a1, void *ptr, size_t n)
{
  void *v5; // eax

  v5 = &loc_804F537;
  if ( !*(_DWORD *)a1 )
    v5 = &loc_804F552;
  dword_805B288 = (int)v5;
  sub_80545C3(a2, edx0);
  return sub_804F366(a1, ptr, n);
}
// 805B288: using guessed type int dword_805B288;

//----- (0804F575) --------------------------------------------------------
int __cdecl sub_804F575(unsigned int *a1, unsigned int a2, int a3)
{
  int v3; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; i |= sub_8050E2E(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}

//----- (0804F5B0) --------------------------------------------------------
int __cdecl sub_804F5B0(int a1)
{
  return a1;
}

//----- (0804F5C7) --------------------------------------------------------
int __cdecl sub_804F5C7(int a1, __int16 a2)
{
  return *(_DWORD *)((a2 & 0x3FC) + a1);
}

//----- (0804F5F8) --------------------------------------------------------
unsigned int *__cdecl sub_804F5F8(unsigned int *a1, int *a2)
{
  unsigned int v2; // edx
  int v3; // ST08_4
  unsigned int v4; // ST18_4
  unsigned int v5; // ST1C_4
  int v6; // eax
  int v7; // ST0C_4
  unsigned int v8; // ST08_4
  unsigned int v9; // ST20_4
  int v10; // eax
  int v11; // eax
  int v12; // ST0C_4
  int v13; // ST08_4
  unsigned int v14; // ST28_4
  int v15; // eax
  int v16; // eax
  int v17; // ST0C_4
  unsigned int v18; // ST30_4
  int v19; // eax
  int v20; // eax
  int v21; // ST08_4
  unsigned int v22; // ST38_4
  unsigned int v23; // ST3C_4
  int v24; // eax
  int v25; // ST0C_4
  unsigned int v26; // ST08_4
  unsigned int v27; // ST40_4
  int v28; // eax
  int v29; // eax
  int v30; // ST0C_4
  int v31; // ST08_4
  unsigned int v32; // ST48_4
  int v33; // eax
  int v34; // eax
  int v35; // ST0C_4
  unsigned int v36; // ST50_4
  int v37; // eax
  int v38; // eax
  unsigned int *result; // eax
  unsigned int v40; // [esp+8h] [ebp-54h]
  int v41; // [esp+Ch] [ebp-50h]
  unsigned int *v42; // [esp+10h] [ebp-4Ch]
  int *v43; // [esp+14h] [ebp-48h]

  v40 = a1[256];
  v2 = a1[257];
  v41 = v2 + ++a1[258];
  v42 = a1;
  v43 = a2;
  do
  {
    v3 = (v40 ^ (v40 << 13)) + v42[128];
    v4 = *v42;
    v5 = sub_804F5C7((int)a1, *v42) + v3 + v41;
    *v42 = v5;
    v6 = sub_804F5C7((int)a1, v5 >> 8);
    v7 = sub_804F5B0(v4 + v6);
    *v43 = v7;
    v8 = (v3 ^ ((unsigned int)sub_804F5B0(v3) >> 6)) + v42[129];
    v9 = v42[1];
    v10 = sub_804F5C7((int)a1, v42[1]);
    v42[1] = v10 + v8 + v7;
    v11 = sub_804F5C7((int)a1, (v10 + v8 + v7) >> 8);
    v12 = sub_804F5B0(v9 + v11);
    v43[1] = v12;
    v13 = (v8 ^ 4 * v8) + v42[130];
    v14 = v42[2];
    v15 = sub_804F5C7((int)a1, v42[2]);
    v42[2] = v15 + v13 + v12;
    v16 = sub_804F5C7((int)a1, (unsigned int)(v15 + v13 + v12) >> 8);
    v17 = sub_804F5B0(v14 + v16);
    v43[2] = v17;
    v40 = (v13 ^ ((unsigned int)sub_804F5B0(v13) >> 16)) + v42[131];
    v18 = v42[3];
    v19 = sub_804F5C7((int)a1, v42[3]);
    v42[3] = v19 + v40 + v17;
    v20 = sub_804F5C7((int)a1, (v19 + v40 + v17) >> 8);
    v41 = sub_804F5B0(v18 + v20);
    v43[3] = v41;
    v43 += 4;
    v42 += 4;
  }
  while ( v42 < a1 + 128 );
  do
  {
    v21 = (v40 ^ (v40 << 13)) + *(v42 - 128);
    v22 = *v42;
    v23 = sub_804F5C7((int)a1, *v42) + v21 + v41;
    *v42 = v23;
    v24 = sub_804F5C7((int)a1, v23 >> 8);
    v25 = sub_804F5B0(v22 + v24);
    *v43 = v25;
    v26 = (v21 ^ ((unsigned int)sub_804F5B0(v21) >> 6)) + *(v42 - 127);
    v27 = v42[1];
    v28 = sub_804F5C7((int)a1, v42[1]);
    v42[1] = v28 + v26 + v25;
    v29 = sub_804F5C7((int)a1, (v28 + v26 + v25) >> 8);
    v30 = sub_804F5B0(v27 + v29);
    v43[1] = v30;
    v31 = (v26 ^ 4 * v26) + *(v42 - 126);
    v32 = v42[2];
    v33 = sub_804F5C7((int)a1, v42[2]);
    v42[2] = v33 + v31 + v30;
    v34 = sub_804F5C7((int)a1, (unsigned int)(v33 + v31 + v30) >> 8);
    v35 = sub_804F5B0(v32 + v34);
    v43[2] = v35;
    v40 = (v31 ^ ((unsigned int)sub_804F5B0(v31) >> 16)) + *(v42 - 125);
    v36 = v42[3];
    v37 = sub_804F5C7((int)a1, v42[3]);
    v42[3] = v37 + v40 + v35;
    v38 = sub_804F5C7((int)a1, (v37 + v40 + v35) >> 8);
    v41 = sub_804F5B0(v36 + v38);
    v43[3] = v41;
    v43 += 4;
    v42 += 4;
  }
  while ( v42 < a1 + 256 );
  a1[256] = v40;
  result = a1;
  a1[257] = v41;
  return result;
}

//----- (0804FA9D) --------------------------------------------------------
_DWORD *__cdecl sub_804FA9D(_DWORD *a1)
{
  int v1; // ST18_4
  int v2; // ST1C_4
  int v3; // ST24_4
  int v4; // ST28_4
  int v5; // ST2C_4
  int v6; // ST30_4
  int v7; // ST14_4
  int v8; // ST20_4
  unsigned int v9; // ST18_4
  int v10; // ST24_4
  int v11; // ST1C_4
  int v12; // ST28_4
  int v13; // ST2C_4
  int v14; // ST30_4
  int v15; // ST14_4
  _DWORD *result; // eax
  int v17; // [esp+Ch] [ebp-28h]
  int v18; // [esp+10h] [ebp-24h]
  int v19; // [esp+14h] [ebp-20h]
  unsigned int v20; // [esp+18h] [ebp-1Ch]
  int v21; // [esp+1Ch] [ebp-18h]
  unsigned int v22; // [esp+20h] [ebp-14h]
  int v23; // [esp+24h] [ebp-10h]
  unsigned int v24; // [esp+28h] [ebp-Ch]
  signed int i; // [esp+30h] [ebp-4h]

  v17 = 325574490;
  v18 = -1780940711;
  v19 = -1021952437;
  v20 = 255990488;
  v21 = -651539848;
  v22 = -1525007287;
  v23 = -990909925;
  v24 = 811634969;
  dword_805B170 = (int)&loc_804FAE7;
  sub_8054CB6();
  for ( i = 0; i <= 255; i += 8 )
  {
    v1 = a1[i + 1] + v18;
    v2 = a1[i + 2] + v19;
    v3 = a1[i + 4] + v21;
    v4 = a1[i + 5] + v22;
    v5 = a1[i + 6] + v23;
    v6 = a1[i + 7] + v24;
    v7 = (v1 << 11) ^ (a1[i] + v17);
    v8 = v7 + a1[i + 3] + v20;
    v9 = ((unsigned int)sub_804F5B0(v2) >> 2) ^ (v2 + v1);
    v10 = v9 + v3;
    v11 = (v8 << 8) ^ (v8 + v2);
    v12 = v11 + v4;
    v20 = ((unsigned int)sub_804F5B0(v10) >> 16) ^ (v10 + v8);
    v13 = v20 + v5;
    v21 = (v12 << 10) ^ (v12 + v10);
    v14 = v21 + v6;
    v22 = ((unsigned int)sub_804F5B0(v13) >> 4) ^ (v13 + v12);
    v15 = v22 + v7;
    v23 = (v14 << 8) ^ (v14 + v13);
    v18 = v23 + v9;
    v24 = ((unsigned int)sub_804F5B0(v15) >> 9) ^ (v15 + v14);
    v19 = v24 + v11;
    v17 = v18 + v15;
    a1[i] = v17;
    a1[i + 1] = v18;
    a1[i + 2] = v19;
    a1[i + 3] = v20;
    a1[i + 4] = v21;
    a1[i + 5] = v22;
    a1[i + 6] = v23;
    a1[i + 7] = v24;
  }
  a1[258] = 0;
  a1[257] = a1[258];
  result = a1;
  a1[256] = a1[257];
  return result;
}
// 8054CB6: using guessed type int sub_8054CB6(void);
// 805B170: using guessed type int dword_805B170;

//----- (0804FEC1) --------------------------------------------------------
void *__cdecl sub_804FEC1(FILE *stream, int a2)
{
  int v2; // eax
  __int64 v3; // rax
  int v5; // edx
  int v6; // ecx
  void *ptr; // [esp+10h] [ebp-98h]
  size_t size; // [esp+14h] [ebp-94h]
  size_t v9; // [esp+18h] [ebp-90h]
  int v10; // [esp+1Ch] [ebp-8Ch]
  size_t n; // [esp+20h] [ebp-88h]
  size_t v12; // [esp+24h] [ebp-84h]
  void *v13; // [esp+28h] [ebp-80h]
  void *v14; // [esp+2Ch] [ebp-7Ch]
  __int64 v15; // [esp+30h] [ebp-78h]
  __int64 v16; // [esp+38h] [ebp-70h]
  char v17; // [esp+40h] [ebp-68h]
  int v18; // [esp+50h] [ebp-58h]
  __int64 v19; // [esp+6Ch] [ebp-3Ch]

  ptr = 0;
  size = 0x2000;
  v2 = fileno(stream);
  if ( sub_8054457(v2, (int)&v17) >= 0 && (v18 & 0xF000) == 0x8000 )
  {
    LODWORD(v3) = ftello64(stream);
    v15 = v3;
    if ( v3 >= 0 && v19 > v15 )
    {
      v16 = v19 - v15;
      if ( v19 - v15 > 4294967294LL )
      {
        *__errno_location() = 12;
        return 0;
      }
      size = v16 + 1;
    }
  }
  ptr = malloc(size);
  if ( !ptr )
  {
    dword_805B1D4 = (int)&locret_805017B;
    sub_8054A4D();
  }
  v9 = 0;
  n = size;
  v12 = fread(ptr, 1u, size, stream);
  v9 += v12;
  if ( v12 == n )
  {
    if ( size == -1 )
    {
      v10 = 12;
    }
    else
    {
      if ( ~(size >> 1) > size )
      {
        size += size >> 1;
        dword_805B210 = (int)&loc_805010B;
        sub_80548CA();
      }
      size = -1;
      v14 = realloc(ptr, 0xFFFFFFFF);
      if ( v14 )
      {
        ptr = v14;
        dword_805B1AC = (int)&loc_804FFC3;
        sub_8054B5A(v6, v5);
      }
      else
      {
        v10 = *__errno_location();
      }
    }
    goto LABEL_23;
  }
  v10 = *__errno_location();
  if ( ferror(stream) )
  {
LABEL_23:
    free(ptr);
    *__errno_location() = v10;
    return 0;
  }
  if ( size - 1 > v9 )
  {
    v13 = realloc(ptr, v9 + 1);
    if ( v13 )
      ptr = v13;
  }
  *((_BYTE *)ptr + v9) = 0;
  *(_DWORD *)a2 = v9;
  return ptr;
}
// 80491B0: using guessed type int __cdecl ftello64(_DWORD);
// 80548CA: using guessed type int sub_80548CA(void);
// 8054A4D: using guessed type int sub_8054A4D(void);
// 8054B5A: using guessed type int __fastcall sub_8054B5A(_DWORD, _DWORD);
// 805B1AC: using guessed type int dword_805B1AC;
// 805B1D4: using guessed type int dword_805B1D4;
// 805B210: using guessed type int dword_805B210;

//----- (0805017D) --------------------------------------------------------
int __cdecl sub_805017D(int a1, int a2, int a3)
{
  int v3; // eax
  bool v4; // zf
  void *v5; // eax
  int v6; // edx
  int v7; // ecx
  int v9; // [esp+18h] [ebp-10h]

  v3 = fopen64(a1, a3);
  v9 = v3;
  v4 = v3 == 0;
  dword_805B2A4 = (int (__fastcall *)(_DWORD, _DWORD))sub_80501DD;
  v5 = &loc_80501C5;
  if ( !v4 )
    v5 = &loc_8053D9A;
  dword_805B1C0 = (int)v5;
  sub_8054AE0();
  dword_805B2A4 = (int (__fastcall *)(_DWORD, _DWORD))&locret_8050281;
  return ((int (__fastcall *)(int, int))locret_8050281)(v7, v6);
}
// 8049090: using guessed type int __cdecl fopen64(_DWORD, _DWORD);
// 80501DD: using guessed type int __cdecl sub_80501DD(int);
// 8054AE0: using guessed type int sub_8054AE0(void);
// 805B1C0: using guessed type int dword_805B1C0;
// 805B2A4: using guessed type int (__fastcall *dword_805B2A4)(_DWORD, _DWORD);

//----- (080501DD) --------------------------------------------------------
#error "8050282: positive sp value has been found (funcsize=43)"

//----- (080502C7) --------------------------------------------------------
int __cdecl sub_80502C7(FILE *stream, int a2, int a3, int a4, int a5, int a6)
{
  char *v6; // eax
  char *v7; // ebx
  char *v8; // eax
  int v9; // edx
  int v10; // ecx
  int v11; // esi
  char *v12; // ebx
  char *v13; // eax
  int result; // eax
  int v15; // edi
  int v16; // esi
  char *v17; // ebx
  char *v18; // eax
  int v19; // edi
  int v20; // esi
  char *v21; // ebx
  char *v22; // eax
  int v23; // edi
  int v24; // esi
  char *v25; // ebx
  char *v26; // eax
  int v27; // edi
  int v28; // esi
  char *v29; // ebx
  char *v30; // eax
  int v31; // esi
  int v32; // edi
  char *v33; // ebx
  char *v34; // eax
  int v35; // edi
  int v36; // esi
  char *v37; // ebx
  char *v38; // eax
  int v39; // edi
  int v40; // esi
  char *v41; // ebx
  char *v42; // eax
  int v43; // edi
  int v44; // esi
  char *v45; // ebx
  char *v46; // eax
  char *v47; // [esp+8h] [ebp-60h]
  int v48; // [esp+Ch] [ebp-5Ch]
  int v49; // [esp+10h] [ebp-58h]
  int v50; // [esp+38h] [ebp-30h]
  int v51; // [esp+3Ch] [ebp-2Ch]
  int v52; // [esp+40h] [ebp-28h]
  int v53; // [esp+44h] [ebp-24h]
  int v54; // [esp+48h] [ebp-20h]
  int v55; // [esp+4Ch] [ebp-1Ch]

  if ( a2 )
  {
    v49 = a4;
    fprintf(stream, "%s (%s) %s\n", a2, a3, a4);
  }
  else
  {
    fprintf(stream, "%s %s\n", a3, a4);
  }
  v48 = 2017;
  v47 = gettext("(C)");
  fprintf(stream, "Copyright %s %d Free Software Foundation, Inc.", v47, 2017);
  v6 = gettext(aLicenseGplv3Gn);
  fputs_unlocked(v6, stream);
  switch ( a6 )
  {
    case 0:
      abort();
      return result;
    case 1:
      v7 = *(char **)a5;
      v8 = gettext("Written by %s.\n");
      v47 = v7;
      fprintf(stream, v8, v7);
      dword_805B1AC = (int)&loc_80507DE;
      sub_8054B5A(v10, v9);
      goto LABEL_7;
    case 2:
LABEL_7:
      v11 = *(_DWORD *)(a5 + 4);
      v12 = *(char **)a5;
      v13 = gettext(aWritt);
      v48 = v11;
      v47 = v12;
      result = fprintf(stream, v13, v12, v11);
      break;
    case 3:
      v15 = *(_DWORD *)(a5 + 8);
      v16 = *(_DWORD *)(a5 + 4);
      v17 = *(char **)a5;
      v18 = gettext("Written by %s, %s, and %s.\n");
      result = fprintf(stream, v18, v17, v16, v15);
      break;
    case 4:
      v55 = *(_DWORD *)(a5 + 12);
      v19 = *(_DWORD *)(a5 + 8);
      v20 = *(_DWORD *)(a5 + 4);
      v21 = *(char **)a5;
      v22 = gettext("Written by %s, %s, %s,\nand %s.\n");
      result = fprintf(stream, v22, v21, v20, v19, v55);
      break;
    case 5:
      v55 = *(_DWORD *)(a5 + 16);
      v54 = *(_DWORD *)(a5 + 12);
      v23 = *(_DWORD *)(a5 + 8);
      v24 = *(_DWORD *)(a5 + 4);
      v25 = *(char **)a5;
      v26 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
      result = fprintf(stream, v26, v25, v24, v23, v54, v55);
      break;
    case 6:
      v55 = *(_DWORD *)(a5 + 20);
      v54 = *(_DWORD *)(a5 + 16);
      v53 = *(_DWORD *)(a5 + 12);
      v27 = *(_DWORD *)(a5 + 8);
      v28 = *(_DWORD *)(a5 + 4);
      v29 = *(char **)a5;
      v30 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
      result = fprintf(stream, v30, v29, v28, v27, v53, v54, v55);
      break;
    case 7:
      v31 = *(_DWORD *)(a5 + 24);
      v55 = *(_DWORD *)(a5 + 20);
      v54 = *(_DWORD *)(a5 + 16);
      v53 = *(_DWORD *)(a5 + 12);
      v52 = *(_DWORD *)(a5 + 8);
      v32 = *(_DWORD *)(a5 + 4);
      v33 = *(char **)a5;
      v34 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
      result = fprintf(stream, v34, v33, v32, v52, v53, v54, v55, v31);
      break;
    case 8:
      v35 = *(_DWORD *)(a5 + 28);
      v55 = *(_DWORD *)(a5 + 24);
      v54 = *(_DWORD *)(a5 + 20);
      v53 = *(_DWORD *)(a5 + 16);
      v52 = *(_DWORD *)(a5 + 12);
      v51 = *(_DWORD *)(a5 + 8);
      v36 = *(_DWORD *)(a5 + 4);
      v37 = *(char **)a5;
      v38 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
      result = fprintf(stream, v38, v37, v36, v51, v52, v53, v54, v55, v35);
      break;
    case 9:
      v39 = *(_DWORD *)(a5 + 32);
      v55 = *(_DWORD *)(a5 + 28);
      v54 = *(_DWORD *)(a5 + 24);
      v53 = *(_DWORD *)(a5 + 20);
      v52 = *(_DWORD *)(a5 + 16);
      v51 = *(_DWORD *)(a5 + 12);
      v50 = *(_DWORD *)(a5 + 8);
      v40 = *(_DWORD *)(a5 + 4);
      v41 = *(char **)a5;
      v42 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
      result = fprintf(stream, v42, v41, v40, v50, v51, v52, v53, v54, v55, v39);
      break;
    default:
      v43 = *(_DWORD *)(a5 + 32);
      v55 = *(_DWORD *)(a5 + 28);
      v54 = *(_DWORD *)(a5 + 24);
      v53 = *(_DWORD *)(a5 + 20);
      v52 = *(_DWORD *)(a5 + 16);
      v51 = *(_DWORD *)(a5 + 12);
      v50 = *(_DWORD *)(a5 + 8);
      v44 = *(_DWORD *)(a5 + 4);
      v45 = *(char **)a5;
      v46 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
      result = fprintf(stream, v46, v45, v44, v50, v51, v52, v53, v54, v55, v43);
      break;
  }
  return result;
}
// 80491E0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8054B5A: using guessed type int __fastcall sub_8054B5A(_DWORD, _DWORD);
// 805B1AC: using guessed type int dword_805B1AC;

//----- (08050857) --------------------------------------------------------
int __cdecl sub_8050857(FILE *stream, int a2, int a3, int a4, int a5)
{
  int *v5; // eax
  int v7; // [esp+24h] [ebp-34h]
  int v8[12]; // [esp+28h] [ebp-30h]

  v7 = 0;
  dword_805B198 = (int)&loc_805087F;
  sub_8054BCA();
  do
  {
    if ( (unsigned int)++v7 > 9 )
      break;
    v5 = (int *)a5;
    a5 += 4;
    v8[v7] = *v5;
  }
  while ( v8[v7] );
  return sub_80502C7(stream, a2, a3, a4, (int)v8, v7);
}
// 8054BCA: using guessed type int sub_8054BCA(void);
// 805B198: using guessed type int dword_805B198;
// 8050857: using guessed type int var_30[12];

//----- (080508D2) --------------------------------------------------------
int sub_80508D2(FILE *stream, int a2, int a3, int a4, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a4);
  return sub_8050857(stream, a2, a3, a4, (int)va);
}

//----- (08050972) --------------------------------------------------------
int __cdecl sub_8050972(unsigned int a1, unsigned int a2)
{
  if ( 0x7FFFFFFF / a2 < a1 )
    sub_8050C3A();
  return sub_8050A98(a2 * a1);
}

//----- (080509A0) --------------------------------------------------------
void *__cdecl sub_80509A0(void *ptr, int a2, int a3)
{
  if ( 0x7FFFFFFFu / a3 < a2 )
    sub_8050C3A();
  return sub_8050AFB(ptr, a3 * a2);
}

//----- (080509D5) --------------------------------------------------------
void *__cdecl sub_80509D5(void *ptr, int a2, int a3)
{
  void *v3; // eax
  unsigned int v5; // [esp+1Ch] [ebp-Ch]
  unsigned int v6; // [esp+1Ch] [ebp-Ch]

  v5 = *(_DWORD *)a2;
  if ( ptr )
  {
    if ( 0x55555554u / a3 <= v5 )
      sub_8050C3A();
    v6 = (v5 >> 1) + v5 + 1;
  }
  else
  {
    v3 = &loc_8050A08;
    if ( v5 )
      v3 = &loc_8050A25;
    dword_805B224 = (int)v3;
    sub_8054854();
    v6 = (0x40u / a3 == 0) + 0x40u / a3;
    if ( 0x7FFFFFFFu / a3 < v6 )
      sub_8050C3A();
  }
  *(_DWORD *)a2 = v6;
  return sub_8050AFB(ptr, a3 * v6);
}
// 8054854: using guessed type int sub_8054854(void);
// 805B224: using guessed type int dword_805B224;

//----- (08050A85) --------------------------------------------------------
int __cdecl sub_8050A85(size_t size)
{
  return sub_8050A98(size);
}

//----- (08050A98) --------------------------------------------------------
int __cdecl sub_8050A98(size_t size)
{
  int v1; // edx
  int v2; // ecx
  void *v3; // ST24_4
  void *v4; // eax
  _DWORD *savedregs; // [esp+28h] [ebp+0h]

  savedregs = &savedregs;
  v3 = malloc(size);
  dword_805B2A4 = (int (__fastcall *)(_DWORD, _DWORD))sub_8050AF6;
  if ( !v3 )
  {
    dword_805B2A4 = (int (__fastcall *)(_DWORD, _DWORD))sub_8050AF6;
    v4 = &loc_8050AF1;
    if ( !size )
      v4 = &loc_8053D9A;
    dword_805B274 = (int)v4;
    sub_8054652(v2, v1);
    sub_8050C3A();
  }
  return dword_805B2A4(v2, v1);
}
// 8050AF6: using guessed type int sub_8050AF6();
// 8054652: using guessed type int __fastcall sub_8054652(_DWORD, _DWORD);
// 805B274: using guessed type int dword_805B274;
// 805B2A4: using guessed type int (__fastcall *dword_805B2A4)(_DWORD, _DWORD);

//----- (08050AF6) --------------------------------------------------------
#error "8050AFA: positive sp value has been found (funcsize=0)"

//----- (08050AFB) --------------------------------------------------------
void *__cdecl sub_8050AFB(void *ptr, size_t size)
{
  void *v2; // eax
  void *result; // eax
  void *ptra; // [esp+20h] [ebp+8h]

  v2 = &loc_8050B20;
  if ( size )
    v2 = &loc_8050B38;
  dword_805B224 = (int)v2;
  sub_8054854();
  if ( ptr )
  {
    free(ptr);
    result = 0;
  }
  else
  {
    ptra = realloc(0, size);
    if ( !ptra )
    {
      if ( size )
        sub_8050C3A();
    }
    result = ptra;
  }
  return result;
}
// 8054854: using guessed type int sub_8054854(void);
// 805B224: using guessed type int dword_805B224;

//----- (08050B63) --------------------------------------------------------
void *__cdecl sub_8050B63(void *ptr, int a2)
{
  return sub_80509D5(ptr, a2, 1);
}

//----- (08050BAF) --------------------------------------------------------
void *__cdecl sub_8050BAF(size_t nmemb, size_t size)
{
  void *v3; // [esp+1Ch] [ebp-Ch]

  if ( 0x7FFFFFFF / size < nmemb || (v3 = calloc(nmemb, size)) == 0 )
    sub_8050C3A();
  return v3;
}

//----- (08050BEC) --------------------------------------------------------
void *__cdecl sub_8050BEC(void *src, size_t n)
{
  void *v2; // eax

  v2 = (void *)sub_8050A98(n);
  return memcpy(v2, src, n);
}

//----- (08050C3A) --------------------------------------------------------
void __noreturn sub_8050C3A()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (08050C73) --------------------------------------------------------
unsigned __int64 __cdecl sub_8050C73(char *nptr, int base, int a3, int a4, int a5, int a6, char *s, int a8, int status)
{
  void *v9; // eax
  int v10; // ebx
  int v11; // edx
  signed int v12; // eax
  int v14; // [esp+34h] [ebp-14h]
  unsigned __int64 v15; // [esp+38h] [ebp-10h]

  v14 = sub_805148B(nptr, 0, base);
  if ( v14 )
  {
    v9 = &loc_8050D44;
    if ( v14 != 1 )
      v9 = &loc_8050D51;
    dword_805B198 = (int)v9;
    sub_8054BCA();
    *__errno_location() = 75;
  }
  else if ( v15 < __PAIR__((unsigned int)a4, a3) || __PAIR__((unsigned int)a6, a5) < v15 )
  {
    v14 = 1;
    if ( v15 <= 0x3FFFFFFF )
      *__errno_location() = 34;
    else
      *__errno_location() = 75;
  }
  if ( v14 )
  {
    v10 = sub_804E6D9();
    if ( *__errno_location() == 22 )
      v11 = 0;
    else
      v11 = *__errno_location();
    if ( status )
      v12 = status;
    else
      v12 = 1;
    error(v12, v11, "%s: %s", a8, v10);
  }
  return v15;
}
// 8054BCA: using guessed type int sub_8054BCA(void);
// 805B198: using guessed type int dword_805B198;

//----- (08050DCA) --------------------------------------------------------
unsigned __int64 __cdecl sub_8050DCA(char *nptr, int a2, int a3, int a4, int a5, char *s, int a7, int status)
{
  return sub_8050C73(nptr, 10, a2, a3, a4, a5, s, a7, status);
}

//----- (08050E2E) --------------------------------------------------------
int __cdecl sub_8050E2E(unsigned int *a1, unsigned int a2)
{
  if ( 0xFFFFFFFF / a2 < *a1 )
  {
    *a1 = -1;
    dword_805B1FC = (int)&loc_8050E85;
    sub_805495D();
  }
  *a1 *= a2;
  return 0;
}
// 805495D: using guessed type int sub_805495D(void);
// 805B1FC: using guessed type int dword_805B1FC;

//----- (08050E9E) --------------------------------------------------------
int __cdecl sub_8050E9E(void *ptr)
{
  int result; // eax
  FILE *stream; // [esp+1Ch] [ebp-Ch]

  stream = *(FILE **)ptr;
  explicit_bzero(ptr, 2076);
  free(ptr);
  if ( stream )
    result = sub_8051990(stream);
  else
    result = 0;
  return result;
}
// 8049330: using guessed type int __cdecl explicit_bzero(_DWORD, _DWORD);

//----- (08050EE9) --------------------------------------------------------
int __usercall sub_8050EE9@<eax>(int a1@<edx>, int a2@<ecx>, char *nptr, int a4, int base, int a6, char *s)
{
  void *v7; // eax
  void *v8; // eax
  int v9; // edx
  int v10; // ecx
  int result; // eax
  bool v12; // zf
  void *v13; // eax
  void *v14; // eax
  int v15; // [esp+4h] [ebp-44h]
  unsigned __int8 i; // [esp+1Fh] [ebp-29h]
  unsigned int v17; // [esp+24h] [ebp-24h]
  int v18; // [esp+28h] [ebp-20h]
  char *v19; // [esp+2Ch] [ebp-1Ch]
  int v20; // [esp+30h] [ebp-18h]
  int v21; // [esp+34h] [ebp-14h]
  char **endptr; // [esp+3Ch] [ebp-Ch]

  v18 = 0;
  if ( base < 0 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoul");
  v7 = &loc_8050F1B;
  if ( base > 36 )
    v7 = &loc_8050F3C;
  dword_805B15C = (int)v7;
  sub_8054D26(a2, a1);
  v8 = &loc_8050F3A;
  if ( a4 )
    v8 = &loc_8050F7A;
  dword_805B1C0 = (int)v8;
  sub_8054AE0();
  dword_805B148 = (int)&loc_8050F7D;
  sub_8054D9E(v10, v9);
  endptr = (char **)a4;
  *__errno_location() = 0;
  v19 = nptr;
  for ( i = *nptr; (*__ctype_b_loc())[i] & 0x2000; i = *v19 )
    ++v19;
  if ( i == 45 )
    return 4;
  v17 = strtoul(nptr, endptr, base);
  if ( *endptr == nptr )
  {
    if ( s && **endptr )
    {
      v15 = **endptr;
      v12 = strchr(s, v15) == 0;
      v13 = &loc_805104A;
      if ( v12 )
        v13 = &loc_8051068;
      dword_805B224 = (int)v13;
      sub_8054854();
      v17 = 1;
      dword_805B1C0 = (int)&loc_80510BE;
      sub_8054AE0();
    }
    dword_805B238 = (int)&locret_80513C7;
    sub_80547B0();
  }
  if ( *__errno_location() )
  {
    if ( *__errno_location() != 34 )
    {
      dword_805B1D4 = (int)&locret_80513C7;
      sub_8054A4D();
    }
    v18 = 1;
  }
  if ( !s )
  {
    *(_DWORD *)a6 = v17;
    dword_805B24C = (int)&locret_80513C7;
    sub_8054736();
  }
  if ( **endptr )
  {
    v20 = 1024;
    v21 = 1;
    v15 = **endptr;
    v12 = strchr(s, v15) == 0;
    v14 = &loc_805113B;
    if ( !v12 )
      v14 = &loc_805114E;
    dword_805B1D4 = (int)v14;
    sub_8054A4D();
    *(_DWORD *)a6 = v17;
    result = v18 | 2;
  }
  else
  {
    *(_DWORD *)a6 = v17;
    result = v18;
  }
  return result;
}
// 8050EE9: could not find valid save-restore pair for ebx
// 8054736: using guessed type int sub_8054736(void);
// 80547B0: using guessed type int sub_80547B0(void);
// 8054854: using guessed type int sub_8054854(void);
// 8054A4D: using guessed type int sub_8054A4D(void);
// 8054AE0: using guessed type int sub_8054AE0(void);
// 8054D26: using guessed type int __fastcall sub_8054D26(_DWORD, _DWORD);
// 8054D9E: using guessed type int __fastcall sub_8054D9E(_DWORD, _DWORD);
// 805B148: using guessed type int dword_805B148;
// 805B15C: using guessed type int dword_805B15C;
// 805B1C0: using guessed type int dword_805B1C0;
// 805B1D4: using guessed type int dword_805B1D4;
// 805B224: using guessed type int dword_805B224;
// 805B238: using guessed type int dword_805B238;
// 805B24C: using guessed type int dword_805B24C;

//----- (080513C9) --------------------------------------------------------
signed int __cdecl sub_80513C9(int a1, int a2)
{
  signed int result; // eax
  int v3; // ebx

  if ( (unsigned __int64)sub_805412C(0xFFFFFFFF, 0xFFFFFFFF, a2, a2 >> 31) >= *(_QWORD *)a1 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    *(_QWORD *)a1 *= a2;
    result = 0;
  }
  else
  {
    *(_DWORD *)a1 = -1;
    *(_DWORD *)(a1 + 4) = -1;
    result = 1;
  }
  return result;
}

//----- (08051455) --------------------------------------------------------
int __cdecl sub_8051455(int a1, int a2, int a3)
{
  int v3; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; ; i |= sub_80513C9(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}

//----- (0805148B) --------------------------------------------------------
int __cdecl sub_805148B(char *nptr, int a2, int base)
{
  void *v3; // eax
  char **v4; // eax
  void *v5; // eax
  unsigned __int8 i; // [esp+1Bh] [ebp-2Dh]
  char v8; // [esp+1Ch] [ebp-2Ch]
  int v9; // [esp+20h] [ebp-28h]
  char *v10; // [esp+24h] [ebp-24h]
  char **endptr; // [esp+34h] [ebp-14h]

  v9 = 0;
  if ( base < 0 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoumax");
  v3 = &loc_80514BD;
  if ( base > 36 )
    v3 = &loc_80514C5;
  dword_805B210 = (int)v3;
  sub_80548CA();
  if ( a2 )
    v4 = (char **)a2;
  else
    v4 = (char **)&v8;
  endptr = v4;
  *__errno_location() = 0;
  v10 = nptr;
  for ( i = *nptr; (*__ctype_b_loc())[i] & 0x2000; i = *v10 )
    ++v10;
  v5 = &loc_805155A;
  if ( i != 45 )
    v5 = &loc_8051564;
  dword_805B24C = (int)v5;
  sub_8054736();
  return 4;
}
// 805148B: could not find valid save-restore pair for ebx
// 8054736: using guessed type int sub_8054736(void);
// 80548CA: using guessed type int sub_80548CA(void);
// 805B210: using guessed type int dword_805B210;
// 805B24C: using guessed type int dword_805B24C;

//----- (08051990) --------------------------------------------------------
int __cdecl sub_8051990(FILE *stream)
{
  int v1; // edx
  int v2; // ecx
  int v3; // eax
  __int64 v4; // rax
  bool v5; // zf
  void *v6; // eax
  int v7; // edx
  int v8; // ecx
  void *v9; // eax
  int v11; // [esp+14h] [ebp-14h]
  int v12; // [esp+18h] [ebp-10h]
  int v13; // [esp+1Ch] [ebp-Ch]

  v11 = 0;
  v12 = 0;
  v13 = fileno(stream);
  if ( v13 < 0 )
  {
    fclose(stream);
    dword_805B148 = (int)&locret_8051A95;
    sub_8054D9E(v2, v1);
  }
  if ( __freading(stream) )
  {
    v3 = fileno(stream);
    LODWORD(v4) = lseek64(v3, 0, 0, 1);
    v5 = v4 == -1;
    v6 = &loc_8051A3B;
    if ( v5 )
      v6 = &loc_8051A54;
    dword_805B260 = (int)v6;
    sub_80546C8();
  }
  if ( sub_8051AE9(stream) )
    v11 = *__errno_location();
  v12 = fclose(stream);
  v9 = &loc_8051A81;
  if ( !v11 )
    v9 = &loc_8051A92;
  dword_805B288 = (int)v9;
  sub_80545C3(v8, v7);
  *__errno_location() = v11;
  return -1;
}
// 8051990: could not find valid save-restore pair for ebx
// 8049340: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 80546C8: using guessed type int sub_80546C8(void);
// 8054D9E: using guessed type int __fastcall sub_8054D9E(_DWORD, _DWORD);
// 805B148: using guessed type int dword_805B148;
// 805B260: using guessed type int dword_805B260;
// 805B288: using guessed type int dword_805B288;

//----- (08051A97) --------------------------------------------------------
int __cdecl sub_8051A97(FILE *stream)
{
  void *v1; // eax

  v1 = &loc_8051AC4;
  if ( !(stream->_flags & 0x100) )
    v1 = &locret_8051AE7;
  dword_805B238 = (int)v1;
  sub_80547B0();
  return sub_8051B29(stream, 0, 0, 1);
}
// 80547B0: using guessed type int sub_80547B0(void);
// 805B238: using guessed type int dword_805B238;

//----- (08051AE9) --------------------------------------------------------
int __cdecl sub_8051AE9(FILE *fp)
{
  if ( !fp || !__freading(fp) )
    return fflush(fp);
  sub_8051A97(fp);
  return fflush(fp);
}

//----- (08051B29) --------------------------------------------------------
int __cdecl sub_8051B29(FILE *stream, int a2, int a3, int a4)
{
  int v4; // ecx
  char *v5; // edx
  void *v6; // eax
  int v7; // eax
  __int64 v8; // rax
  int v10; // edx
  int v11; // [esp+18h] [ebp-20h]
  int v12; // [esp+1Ch] [ebp-1Ch]
  __int64 v13; // [esp+28h] [ebp-10h]

  v11 = a2;
  v12 = a3;
  if ( stream->_IO_read_end == stream->_IO_read_ptr )
  {
    v5 = stream->_IO_write_ptr;
    v6 = &loc_8051B78;
    if ( v5 != stream->_IO_write_base )
      v6 = &loc_8051C0B;
    dword_805B274 = (int)v6;
    sub_8054652(v4, v5);
    if ( !stream->_IO_save_base )
    {
      v7 = fileno(stream);
      LODWORD(v8) = lseek64(v7, v11, v12, a4);
      v13 = v8;
      if ( v8 == -1 )
        return -1;
      stream->_flags &= 0xFFFFFFEF;
      v10 = HIDWORD(v13);
      LODWORD(stream->_offset) = v13;
      HIDWORD(stream->_offset) = v10;
      dword_805B260 = (int)&locret_8051C2B;
      sub_80546C8();
    }
  }
  return fseeko64(stream, v11, v12, a4);
}
// 8049010: using guessed type int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8049340: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8054652: using guessed type int __fastcall sub_8054652(_DWORD, _DWORD);
// 80546C8: using guessed type int sub_80546C8(void);
// 805B260: using guessed type int dword_805B260;
// 805B274: using guessed type int dword_805B274;

//----- (08051C2D) --------------------------------------------------------
size_t __cdecl sub_8051C2D(wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  char v5; // [esp+18h] [ebp-10h]
  size_t v6; // [esp+1Ch] [ebp-Ch]

  if ( !pwc )
    pwc = (wchar_t *)&v5;
  v6 = mbrtowc(pwc, s, n, p);
  if ( v6 <= 0xFFFFFFFD || !n || !((unsigned __int8)sub_8051E8D(0) ^ 1) )
    return v6;
  *pwc = (unsigned __int8)*s;
  return 1;
}

//----- (08051C9F) --------------------------------------------------------
int __cdecl sub_8051C9F(unsigned __int8 *a1, unsigned __int8 *a2)
{
  void *v3; // eax
  unsigned __int8 v4; // [esp+1Eh] [ebp-Ah]
  unsigned __int8 v5; // [esp+1Fh] [ebp-9h]

  if ( a1 == a2 )
    return 0;
  v4 = sub_80540EC(*a1);
  v5 = sub_80540EC(*a2);
  v3 = &loc_8051CF9;
  if ( v4 )
    v3 = &loc_8051CFB;
  dword_805B238 = (int)v3;
  sub_80547B0();
  return v4 - v5;
}
// 80547B0: using guessed type int sub_80547B0(void);
// 805B238: using guessed type int dword_805B238;

//----- (08051D1D) --------------------------------------------------------
int __cdecl sub_8051D1D(FILE *fp)
{
  bool v1; // ST26_1
  void *v2; // eax
  bool v4; // [esp+1Dh] [ebp-Bh]
  bool v5; // [esp+1Fh] [ebp-9h]

  v4 = __fpending(fp) != 0;
  v1 = ferror_unlocked(fp) != 0;
  v5 = sub_8051990(fp) != 0;
  v2 = &loc_8051D7B;
  if ( v1 )
    v2 = &loc_8051D93;
  dword_805B210 = (int)v2;
  sub_80548CA();
  if ( !v5 || !v4 && *__errno_location() == 9 )
    return 0;
  if ( v5 != 1 )
    *__errno_location() = 0;
  return -1;
}
// 80548CA: using guessed type int sub_80548CA(void);
// 805B210: using guessed type int dword_805B210;

//----- (08051DB7) --------------------------------------------------------
FILE *__cdecl sub_8051DB7(int a1, char *modes)
{
  int v2; // ST28_4
  int v4; // ST2C_4
  FILE *stream; // [esp+1Ch] [ebp-1Ch]
  signed int v6; // [esp+20h] [ebp-18h]
  int fd; // [esp+24h] [ebp-14h]

  stream = (FILE *)fopen64(a1, modes);
  if ( !stream )
    return stream;
  v6 = fileno(stream);
  if ( v6 < 0 || v6 > 2 )
    return stream;
  fd = sub_8053B13(v6);
  if ( fd < 0 )
  {
    v2 = *__errno_location();
    sub_8051990(stream);
    *__errno_location() = v2;
    return 0;
  }
  if ( !sub_8051990(stream) )
  {
    stream = fdopen(fd, modes);
    if ( stream )
      return stream;
  }
  v4 = *__errno_location();
  close(fd);
  *__errno_location() = v4;
  return 0;
}
// 8049090: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (08051E8D) --------------------------------------------------------
int __cdecl sub_8051E8D(int category)
{
  bool v1; // zf
  void *v2; // eax
  unsigned __int8 v4; // [esp+1Bh] [ebp-Dh]
  const char *s1; // [esp+1Ch] [ebp-Ch]

  v4 = 1;
  s1 = setlocale(category, 0);
  if ( s1 )
  {
    v1 = strcmp(s1, "C") == 0;
    v2 = &loc_8051EE3;
    if ( v1 )
      v2 = &loc_8051EFA;
    dword_805B198 = (int)v2;
    sub_8054BCA();
    if ( !strcmp(s1, "POSIX") )
      v4 = 0;
  }
  return v4;
}
// 8054BCA: using guessed type int sub_8054BCA(void);
// 805B198: using guessed type int dword_805B198;

//----- (08051F04) --------------------------------------------------------
int __cdecl sub_8051F04(int a1)
{
  return *(_DWORD *)(a1 + 8);
}

//----- (08051F0F) --------------------------------------------------------
int __cdecl sub_8051F0F(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (08051F1A) --------------------------------------------------------
int __cdecl sub_8051F1A(int a1)
{
  return *(_DWORD *)(a1 + 16);
}

//----- (08051F25) --------------------------------------------------------
unsigned int __cdecl sub_8051F25(int a1)
{
  _DWORD *i; // [esp+0h] [ebp-10h]
  unsigned int v3; // [esp+4h] [ebp-Ch]
  _DWORD *v4; // [esp+8h] [ebp-8h]
  unsigned int j; // [esp+Ch] [ebp-4h]

  v3 = 0;
  for ( i = *(_DWORD **)a1; *(_DWORD *)(a1 + 4) > (unsigned int)i; i += 2 )
  {
    if ( *i )
    {
      v4 = i;
      for ( j = 1; ; ++j )
      {
        v4 = (_DWORD *)v4[1];
        if ( !v4 )
          break;
      }
      if ( j > v3 )
        v3 = j;
    }
  }
  return v3;
}

//----- (080520F3) --------------------------------------------------------
int __cdecl sub_80520F3(int a1, int a2)
{
  unsigned int v3; // [esp+1Ch] [ebp-Ch]

  v3 = (*(int (__cdecl **)(int, _DWORD))(a1 + 24))(a2, *(_DWORD *)(a1 + 8));
  if ( *(_DWORD *)(a1 + 8) <= v3 )
    abort();
  return 8 * v3 + *(_DWORD *)a1;
}

//----- (08052492) --------------------------------------------------------
int __fastcall sub_8052492(int a1, int a2)
{
  dword_805B2A4 = (int (__fastcall *)(_DWORD, _DWORD))&loc_80524CD;
  return ((int (__fastcall *)(int, int))loc_80524CD)(a1, a2);
}
// 805B2A4: using guessed type int (__fastcall *dword_805B2A4)(_DWORD, _DWORD);

//----- (080524BC) --------------------------------------------------------
#error "805251D: positive sp value has been found (funcsize=27)"

//----- (0805251E) --------------------------------------------------------
int __usercall sub_805251E@<eax>(int a1@<edx>, int a2@<ecx>, unsigned int a3)
{
  int i; // [esp+Ch] [ebp+8h]

  if ( a3 <= 9 )
    a3 = 10;
  for ( i = a3 | 1; i != -1 && (unsigned __int8)sub_8052492(a2, a1) ^ 1; i += 2 )
    ;
  return i;
}

//----- (0805258F) --------------------------------------------------------
unsigned int __cdecl sub_805258F(int a1, unsigned int a2)
{
  return sub_8053DB5(a1, 3) % a2;
}

//----- (080525BA) --------------------------------------------------------
bool __cdecl sub_80525BA(int a1, int a2)
{
  return a1 == a2;
}

//----- (080525C8) --------------------------------------------------------
signed int __cdecl sub_80525C8(int a1)
{
  int v2; // [esp+8h] [ebp-8h]

  v2 = *(_DWORD *)(a1 + 20);
  if ( (_UNKNOWN *)v2 == &unk_8056258 )
    return 1;
  if ( *(float *)(v2 + 8) > 0.1
    && 1.0 - 0.1 > *(float *)(v2 + 8)
    && *(float *)(v2 + 12) > 0.1 + 1.0
    && *(float *)v2 >= 0.0
    && *(float *)(v2 + 4) > *(float *)v2 + 0.1
    && *(float *)(v2 + 4) <= 1.0
    && *(float *)(v2 + 8) > *(float *)v2 + 0.1 )
  {
    return 1;
  }
  *(_DWORD *)(a1 + 20) = &unk_8056258;
  return 0;
}

//----- (08052684) --------------------------------------------------------
unsigned int __usercall sub_8052684@<eax>(signed __int64 a1@<edx:eax>, int a2@<ecx>, unsigned int a3, int a4)
{
  unsigned int result; // eax
  float v5; // [esp+20h] [ebp-4h]
  unsigned int v6; // [esp+2Ch] [ebp+8h]

  if ( *(_BYTE *)(a4 + 16) != 1 )
  {
    v5 = (long double)a3 / *(float *)(a4 + 8);
    if ( v5 >= 4294967300.0 )
      return 0;
    a1 = (signed __int64)v5;
    a3 = a1;
  }
  v6 = sub_805251E(SHIDWORD(a1), a2, a3);
  if ( v6 <= 0x1FFFFFFF )
    result = v6;
  else
    result = 0;
  return result;
}

//----- (08052711) --------------------------------------------------------
void *__cdecl sub_8052711(unsigned int a1, void *a2, unsigned int (__cdecl *a3)(int a1, unsigned int a2), bool (__cdecl *a4)(int a1, int a2), int a5)
{
  void *result; // eax
  signed __int64 v6; // rax
  int v7; // ecx
  void *v8; // eax
  void *ptr; // [esp+1Ch] [ebp-Ch]

  if ( !a3 )
    a3 = sub_805258F;
  if ( !a4 )
    a4 = sub_80525BA;
  ptr = malloc(0x28u);
  if ( !ptr )
    return 0;
  if ( !a2 )
    a2 = &unk_8056258;
  *((_DWORD *)ptr + 5) = a2;
  if ( (unsigned __int8)sub_80525C8((int)ptr) ^ 1 )
    goto LABEL_17;
  LODWORD(v6) = a1;
  *((_DWORD *)ptr + 2) = sub_8052684(v6, v7, a1, (int)a2);
  if ( !*((_DWORD *)ptr + 2) )
  {
    dword_805B184 = (int)&loc_8052832;
    sub_8054C3E();
  }
  v8 = calloc(*((_DWORD *)ptr + 2), 8u);
  *(_DWORD *)ptr = v8;
  if ( !*(_DWORD *)ptr )
  {
LABEL_17:
    free(ptr);
    result = 0;
  }
  else
  {
    *((_DWORD *)ptr + 1) = 8 * *((_DWORD *)ptr + 2) + *(_DWORD *)ptr;
    *((_DWORD *)ptr + 3) = 0;
    *((_DWORD *)ptr + 4) = 0;
    *((_DWORD *)ptr + 6) = a3;
    *((_DWORD *)ptr + 7) = a4;
    *((_DWORD *)ptr + 8) = a5;
    *((_DWORD *)ptr + 9) = 0;
    result = ptr;
  }
  return result;
}
// 8054C3E: using guessed type int sub_8054C3E(void);
// 805B184: using guessed type int dword_805B184;

//----- (08052912) --------------------------------------------------------
void __cdecl sub_8052912(void *a1)
{
  void *v1; // eax
  void *v2; // eax
  _DWORD *v3; // ST24_4
  _DWORD *v4; // ST24_4
  _DWORD *i; // [esp+14h] [ebp-14h]
  _DWORD *j; // [esp+14h] [ebp-14h]
  _DWORD *ptr; // [esp+18h] [ebp-10h]
  _DWORD *ptra; // [esp+18h] [ebp-10h]

  if ( *((_DWORD *)a1 + 8) && *((_DWORD *)a1 + 4) )
  {
    for ( i = *(_DWORD **)a1; *((_DWORD *)a1 + 1) > (unsigned int)i; i += 2 )
    {
      v1 = &loc_805295C;
      if ( !*i )
        v1 = &loc_805299C;
      dword_805B1C0 = (int)v1;
      sub_8054AE0();
      v2 = &loc_805299C;
      if ( i )
        v2 = &loc_8052964;
      dword_805B1C0 = (int)v2;
      sub_8054AE0();
    }
  }
  for ( j = *(_DWORD **)a1; *((_DWORD *)a1 + 1) > (unsigned int)j; j += 2 )
  {
    for ( ptr = (_DWORD *)j[1]; ptr; ptr = v3 )
    {
      v3 = (_DWORD *)ptr[1];
      free(ptr);
    }
  }
  for ( ptra = (_DWORD *)*((_DWORD *)a1 + 9); ptra; ptra = v4 )
  {
    v4 = (_DWORD *)ptra[1];
    free(ptra);
  }
  free(*(void **)a1);
  free(a1);
}
// 8052912: could not find valid save-restore pair for ebx
// 8054AE0: using guessed type int sub_8054AE0(void);
// 805B1C0: using guessed type int dword_805B1C0;

//----- (08052A34) --------------------------------------------------------
void *__cdecl sub_8052A34(int a1)
{
  int v2; // [esp+1Ch] [ebp-Ch]

  if ( !*(_DWORD *)(a1 + 36) )
    return malloc(8u);
  v2 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(v2 + 4);
  return (void *)v2;
}

//----- (08052A6F) --------------------------------------------------------
int __cdecl sub_8052A6F(int a1, _DWORD *a2)
{
  int result; // eax

  *a2 = 0;
  a2[1] = *(_DWORD *)(a1 + 36);
  result = a1;
  *(_DWORD *)(a1 + 36) = a2;
  return result;
}

//----- (08052A92) --------------------------------------------------------
int __cdecl sub_8052A92(int a1, int a2, _DWORD *a3, char a4)
{
  int v4; // ecx
  int result; // eax
  void *v6; // eax
  _DWORD *v7; // ST34_4
  int v8; // edx
  void *v9; // eax
  _DWORD *v10; // ST2C_4
  _DWORD *i; // [esp+18h] [ebp-20h]
  _DWORD *v12; // [esp+1Ch] [ebp-1Ch]
  int v13; // [esp+20h] [ebp-18h]
  int v14; // [esp+28h] [ebp-10h]

  v12 = (_DWORD *)sub_80520F3(a1, a2);
  *a3 = v12;
  if ( !*v12 )
    return 0;
  v6 = &loc_8052AF1;
  if ( *v12 == a2 )
    v6 = &loc_8052B0C;
  dword_805B148 = (int)v6;
  sub_8054D9E(v4, v12);
  if ( (*(unsigned __int8 (__cdecl **)(int, _DWORD))(a1 + 28))(a2, *v12) )
  {
    v14 = *v12;
    if ( a4 )
    {
      if ( v12[1] )
      {
        v7 = (_DWORD *)v12[1];
        v8 = v7[1];
        *v12 = *v7;
        v12[1] = v8;
        sub_8052A6F(a1, v7);
      }
      else
      {
        *v12 = 0;
      }
    }
    result = v14;
  }
  else
  {
    for ( i = v12; ; i = (_DWORD *)i[1] )
    {
      if ( !i[1] )
        return 0;
      v9 = &loc_8052B93;
      if ( *(_DWORD *)i[1] == a2 )
        v9 = &loc_8052BB1;
      dword_805B198 = (int)v9;
      sub_8054BCA();
      if ( (*(unsigned __int8 (__cdecl **)(int, _DWORD))(a1 + 28))(a2, *(_DWORD *)i[1]) )
        break;
    }
    v13 = *(_DWORD *)i[1];
    if ( a4 )
    {
      v10 = (_DWORD *)i[1];
      i[1] = v10[1];
      sub_8052A6F(a1, v10);
    }
    result = v13;
  }
  return result;
}
// 8052A92: could not find valid save-restore pair for ebx
// 8054BCA: using guessed type int sub_8054BCA(void);
// 8054D9E: using guessed type int __fastcall sub_8054D9E(_DWORD, _DWORD);
// 805B148: using guessed type int dword_805B148;
// 805B198: using guessed type int dword_805B198;

//----- (08052C0C) --------------------------------------------------------
int __fastcall sub_8052C0C(int ecx0, int edx0, int a1, int *a2, char a3)
{
  int v5; // ST18_4

  v5 = *a2;
  dword_805B2A4 = (int (__fastcall *)(_DWORD, _DWORD))sub_8052E64;
  return ((int (__fastcall *)(int, int))sub_8052E64)(ecx0, edx0);
}
// 8052E64: using guessed type int sub_8052E64();
// 805B2A4: using guessed type int (__fastcall *dword_805B2A4)(_DWORD, _DWORD);

//----- (08052C33) --------------------------------------------------------
#error "8052CA6: call analysis failed (funcsize=60)"

//----- (08052CFA) --------------------------------------------------------
#error "8052D1E: call analysis failed (funcsize=37)"

//----- (08052D7E) --------------------------------------------------------
#error "8052D8B: call analysis failed (funcsize=38)"

//----- (08052E01) --------------------------------------------------------
int __usercall sub_8052E01@<eax>(int a1@<ebp>, int a2@<ecx>)
{
  int v2; // edx

  **(_DWORD **)(a1 - 12) = *(_DWORD *)(a1 - 24);
  *(_DWORD *)(*(_DWORD *)(a1 - 12) + 4) = *(_DWORD *)(*(_DWORD *)(a1 - 20) + 4);
  v2 = *(_DWORD *)(a1 - 12);
  *(_DWORD *)(*(_DWORD *)(a1 - 20) + 4) = v2;
  dword_805B2A4 = (int (__fastcall *)(_DWORD, _DWORD))sub_8052E48;
  return ((int (__fastcall *)(int, int))sub_8052E48)(a2, v2);
}
// 8052E48: using guessed type int sub_8052E48();
// 805B2A4: using guessed type int (__fastcall *dword_805B2A4)(_DWORD, _DWORD);

//----- (08052E88) --------------------------------------------------------
signed int __usercall sub_8052E88@<eax>(signed __int64 a1@<edx:eax>, int a2@<ecx>, int a3, unsigned int a4)
{
  signed int result; // eax
  int v5; // ecx
  int v6; // ecx
  int v7; // edx
  int v8; // edx
  int v9; // ecx
  unsigned int nmemb; // [esp+10h] [ebp-38h]
  char *v11; // [esp+18h] [ebp-30h]
  char *v12; // [esp+1Ch] [ebp-2Ch]
  unsigned int v13; // [esp+20h] [ebp-28h]
  int v14; // [esp+24h] [ebp-24h]
  int v15; // [esp+28h] [ebp-20h]
  int v16; // [esp+2Ch] [ebp-1Ch]
  int v17; // [esp+30h] [ebp-18h]
  int v18; // [esp+34h] [ebp-14h]
  int v19; // [esp+38h] [ebp-10h]
  int v20; // [esp+3Ch] [ebp-Ch]

  LODWORD(a1) = a4;
  nmemb = sub_8052684(a1, a2, a4, *(_DWORD *)(a3 + 20));
  if ( !nmemb )
    return 0;
  if ( *(_DWORD *)(a3 + 8) == nmemb )
    return 1;
  v11 = (char *)calloc(nmemb, 8u);
  if ( !v11 )
    return 0;
  v13 = nmemb;
  v12 = &v11[8 * nmemb];
  v14 = 0;
  v15 = 0;
  v16 = *(_DWORD *)(a3 + 20);
  v17 = *(_DWORD *)(a3 + 24);
  v18 = *(_DWORD *)(a3 + 28);
  v19 = *(_DWORD *)(a3 + 32);
  v20 = *(_DWORD *)(a3 + 36);
  if ( (unsigned __int8)sub_8052C0C(v5, v20, (int)&v11, (int *)a3, 0) )
  {
    free(*(void **)a3);
    *(_DWORD *)a3 = v11;
    *(_DWORD *)(a3 + 4) = v12;
    *(_DWORD *)(a3 + 8) = v13;
    *(_DWORD *)(a3 + 12) = v14;
    *(_DWORD *)(a3 + 36) = v20;
    result = 1;
  }
  else
  {
    v7 = v20;
    *(_DWORD *)(a3 + 36) = v20;
    if ( (unsigned __int8)sub_8052C0C(v6, v7, a3, (int *)&v11, 1) ^ 1
      || (unsigned __int8)sub_8052C0C(v9, v8, a3, (int *)&v11, 0) ^ 1 )
    {
      abort();
    }
    free(v11);
    result = 0;
  }
  return result;
}

//----- (0805303D) --------------------------------------------------------
signed int __cdecl sub_805303D(unsigned int *a1, int a2, _DWORD *a3)
{
  signed int result; // eax
  long double v4; // fst7
  long double v5; // fst6
  int v6; // ecx
  long double v7; // fst7
  long double v8; // fst6
  long double v9; // fst7
  __int16 v10; // ax
  signed __int64 v11; // rax
  __int64 v12; // [esp+10h] [ebp-38h]
  __int16 v13; // [esp+1Ch] [ebp-2Ch]
  __int16 v14; // [esp+1Eh] [ebp-2Ah]
  int *v15; // [esp+2Ch] [ebp-1Ch]
  int v16; // [esp+30h] [ebp-18h]
  unsigned int v17; // [esp+34h] [ebp-14h]
  float v18; // [esp+38h] [ebp-10h]
  _DWORD *v19; // [esp+3Ch] [ebp-Ch]

  if ( !a2 )
    abort();
  v16 = sub_8052A92((int)a1, a2, &v15, 0);
  if ( v16 )
  {
    if ( a3 )
      *a3 = v16;
    result = 0;
  }
  else
  {
    v12 = a1[3];
    v4 = (long double)v12;
    v5 = *(float *)(a1[5] + 8);
    v12 = a1[2];
    if ( v4 > v5 * (long double)v12 )
    {
      sub_80525C8((int)a1);
      v12 = a1[3];
      v7 = (long double)v12;
      v8 = *(float *)(a1[5] + 8);
      v12 = a1[2];
      if ( v7 > v8 * (long double)v12 )
      {
        v17 = a1[5];
        if ( *(_BYTE *)(v17 + 16) )
          v9 = (long double)a1[2] * *(float *)(v17 + 12);
        else
          v9 = (long double)a1[2] * *(float *)(v17 + 12) * *(float *)(v17 + 8);
        v18 = v9;
        if ( v18 >= 4294967300.0 )
          return -1;
        LOBYTE(v10) = v14;
        HIBYTE(v10) = 12;
        v13 = v10;
        v12 = (signed __int64)v18;
        v11 = (signed __int64)v18;
        LODWORD(v11) = a1;
        if ( (unsigned __int8)sub_8052E88(v11, v6, (int)a1, v12) ^ 1 )
        {
          dword_805B170 = (int)&locret_805328A;
          sub_8054CB6();
        }
        if ( sub_8052A92((int)a1, a2, &v15, 0) )
          abort();
      }
    }
    if ( *v15 )
    {
      v19 = sub_8052A34((int)a1);
      if ( v19 )
      {
        *v19 = a2;
        v19[1] = v15[1];
        v15[1] = (int)v19;
        ++a1[4];
        result = 1;
      }
      else
      {
        result = -1;
      }
    }
    else
    {
      *v15 = a2;
      ++a1[4];
      ++a1[3];
      result = 1;
    }
  }
  return result;
}
// 8054CB6: using guessed type int sub_8054CB6(void);
// 805B170: using guessed type int dword_805B170;

//----- (0805328C) --------------------------------------------------------
int __cdecl sub_805328C(unsigned int *a1, int a2)
{
  int v2; // edx
  int v3; // ecx
  int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]

  v6 = sub_805303D(a1, a2, &v5);
  dword_805B2A4 = (int (__fastcall *)(_DWORD, _DWORD))sub_805330A;
  if ( v6 != -1 )
  {
    dword_805B2A4 = (int (__fastcall *)(_DWORD, _DWORD))sub_80532F4;
    if ( !v6 )
      dword_805B2A4 = (int (__fastcall *)(_DWORD, _DWORD))sub_805330F;
  }
  return dword_805B2A4(v3, v2);
}
// 805330A: using guessed type int sub_805330A();
// 805330F: using guessed type int sub_805330F();
// 805B2A4: using guessed type int (__fastcall *dword_805B2A4)(_DWORD, _DWORD);

//----- (080532F4) --------------------------------------------------------
int __usercall sub_80532F4@<eax>(int a1@<ebp>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // eax

  v3 = *(_DWORD *)(a1 + 12);
  dword_805B2A4 = (int (__fastcall *)(_DWORD, _DWORD))sub_805330F;
  return ((int (__fastcall *)(int, int))sub_805330F)(a3, a2);
}
// 805330F: using guessed type int sub_805330F();
// 805B2A4: using guessed type int (__fastcall *dword_805B2A4)(_DWORD, _DWORD);

//----- (08053311) --------------------------------------------------------
int __cdecl sub_8053311(int a1, int a2)
{
  int v2; // ecx
  int v4; // edx
  void *v5; // eax
  int v6; // ecx
  long double v7; // fst7
  signed __int64 v8; // rax
  void *v9; // eax
  _DWORD *v10; // [esp+28h] [ebp-20h]
  void *ptr; // [esp+2Ch] [ebp-1Ch]
  int v12; // [esp+30h] [ebp-18h]
  int v13; // [esp+34h] [ebp-14h]
  unsigned int v14; // [esp+38h] [ebp-10h]

  v12 = sub_8052A92(a1, a2, &v10, 1);
  if ( !v12 )
    return 0;
  v4 = *(_DWORD *)(a1 + 16) - 1;
  *(_DWORD *)(a1 + 16) = v4;
  v5 = &loc_805337C;
  if ( *v10 )
    v5 = &loc_8053506;
  dword_805B15C = (int)v5;
  sub_8054D26(v2, v4);
  if ( **(float **)(a1 + 20) * (long double)*(unsigned int *)(a1 + 8) > (long double)(unsigned int)--*(_DWORD *)(a1 + 12) )
  {
    sub_80525C8(a1);
    if ( **(float **)(a1 + 20) * (long double)*(unsigned int *)(a1 + 8) > (long double)*(unsigned int *)(a1 + 12) )
    {
      v13 = *(_DWORD *)(a1 + 20);
      v7 = *(_BYTE *)(v13 + 16) ? (long double)*(unsigned int *)(a1 + 8) * *(float *)(v13 + 4) : (long double)*(unsigned int *)(a1 + 8)
                                                                                               * *(float *)(v13 + 4)
                                                                                               * *(float *)(v13 + 8);
      v8 = (signed __int64)v7;
      v14 = (signed __int64)v7;
      LODWORD(v8) = a1;
      if ( (unsigned __int8)sub_8052E88(v8, v6, a1, v14) ^ 1 )
      {
        ptr = *(void **)(a1 + 36);
        v9 = &loc_80534FC;
        if ( ptr )
          v9 = &loc_80534C3;
        dword_805B1FC = (int)v9;
        sub_805495D();
        *(_DWORD *)(a1 + 36) = 0;
      }
    }
  }
  return v12;
}
// 8053311: could not find valid save-restore pair for ebx
// 805495D: using guessed type int sub_805495D(void);
// 8054D26: using guessed type int __fastcall sub_8054D26(_DWORD, _DWORD);
// 805B15C: using guessed type int dword_805B15C;
// 805B1FC: using guessed type int dword_805B1FC;

//----- (0805350B) --------------------------------------------------------
void *sub_805350B()
{
  char *v0; // eax
  bool v1; // zf
  void *v2; // eax
  FILE *v3; // eax
  void *v4; // eax
  size_t v6; // [esp+0h] [ebp-C8h]
  void *ptr; // [esp+14h] [ebp-B4h]
  void *v8; // [esp+18h] [ebp-B0h]
  char *s; // [esp+1Ch] [ebp-ACh]
  char *v10; // [esp+28h] [ebp-A0h]
  size_t n; // [esp+2Ch] [ebp-9Ch]
  size_t v12; // [esp+30h] [ebp-98h]
  int v13; // [esp+34h] [ebp-94h]
  void *dest; // [esp+38h] [ebp-90h]
  int fd; // [esp+3Ch] [ebp-8Ch]
  FILE *stream; // [esp+40h] [ebp-88h]
  unsigned int v17; // [esp+BCh] [ebp-Ch]

  v17 = __readgsdword(0x14u);
  v8 = (void *)dword_805BAE4;
  if ( !dword_805BAE4 )
  {
    ptr = 0;
    v10 = "charset.alias";
    v0 = getenv("CHARSETALIASDIR");
    s = v0;
    v1 = v0 == 0;
    v2 = &loc_8053580;
    if ( v1 )
      v2 = &loc_805358D;
    dword_805B184 = (int)v2;
    sub_8054C3E();
    if ( !*s )
    {
      ptr = 0;
      s = "/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib";
    }
    n = strlen(s);
    v12 = strlen(v10);
    if ( n && s[n - 1] != 47 )
    {
      dword_805B1C0 = (int)&loc_805360B;
      sub_8054AE0();
    }
    v13 = 0;
    v6 = n + v12 + 1;
    dest = malloc(v6);
    if ( dest )
    {
      memcpy(dest, s, n);
      if ( v13 )
        *((_BYTE *)dest + n) = 47;
      memcpy((char *)dest + n + v13, v10, v12 + 1);
    }
    free(ptr);
    if ( dest )
    {
      fd = open64(dest, 0x20000);
      if ( fd >= 0 )
      {
        v3 = fdopen(fd, "r");
        stream = v3;
        v1 = v3 == 0;
        v4 = &loc_805374A;
        if ( !v1 )
          v4 = &loc_8053767;
        dword_805B170 = (int)v4;
        sub_8054CB6();
        close(fd);
        v8 = &unk_805634F;
      }
      else
      {
        v8 = &unk_805634F;
      }
      free(dest);
    }
    else
    {
      v8 = &unk_805634F;
    }
    dword_805BAE4 = (int)v8;
  }
  return v8;
}
// 8048F50: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 8054AE0: using guessed type int sub_8054AE0(void);
// 8054C3E: using guessed type int sub_8054C3E(void);
// 8054CB6: using guessed type int sub_8054CB6(void);
// 805B170: using guessed type int dword_805B170;
// 805B184: using guessed type int dword_805B184;
// 805B1C0: using guessed type int dword_805B1C0;
// 805BAE4: using guessed type int dword_805BAE4;

//----- (08053A47) --------------------------------------------------------
const char *sub_8053A47()
{
  size_t v0; // edx
  int v1; // ecx
  char *v2; // ST24_4
  void *v3; // eax
  const char *s1; // [esp+18h] [ebp-10h]
  char *s2; // [esp+1Ch] [ebp-Ch]

  s1 = nl_langinfo(14);
  if ( !s1 )
    s1 = (const char *)&unk_805634F;
  for ( s2 = (char *)sub_805350B(); *s2; s2 = &v2[strlen(v2) + 1] )
  {
    if ( !strcmp(s1, s2) || *s2 == 42 && !s2[1] )
    {
      v0 = strlen(s2) + 1;
      s1 = &s2[v0];
      break;
    }
    v2 = &s2[strlen(s2) + 1];
  }
  v3 = &loc_8053B07;
  if ( *s1 )
    v3 = &loc_8053B0E;
  dword_805B148 = (int)v3;
  sub_8054D9E(v1, v0);
  return "ASCII";
}
// 8054D9E: using guessed type int __fastcall sub_8054D9E(_DWORD, _DWORD);
// 805B148: using guessed type int dword_805B148;

//----- (08053B13) --------------------------------------------------------
int __cdecl sub_8053B13(int fd)
{
  return sub_8053B36(fd, 0, 3);
}

//----- (08053B36) --------------------------------------------------------
int __cdecl sub_8053B36(int fd, int cmd, char a3)
{
  int v3; // ST28_4
  int v5; // [esp+1Ch] [ebp-1Ch]
  char v6; // [esp+20h] [ebp-18h]
  int v7; // [esp+24h] [ebp-14h]

  if ( cmd != 1030 )
    return fcntl(fd, cmd, a3);
  v6 = a3;
  if ( dword_805BAE8 < 0 )
  {
    v5 = sub_8053B36(fd, 0, a3);
  }
  else
  {
    v5 = fcntl(fd, 1030, a3);
    if ( v5 < 0 && *__errno_location() == 22 )
    {
      v5 = sub_8053B36(fd, 0, v6);
      if ( v5 < 0 )
        return v5;
      dword_805BAE8 = -1;
    }
    else
    {
      dword_805BAE8 = 1;
    }
  }
  if ( v5 >= 0 && dword_805BAE8 == -1 )
  {
    v7 = fcntl(v5, 1);
    if ( v7 < 0 || fcntl(v5, 2, v7 | 1) == -1 )
    {
      v3 = *__errno_location();
      close(v5);
      *__errno_location() = v3;
      v5 = -1;
    }
  }
  return v5;
}
// 805BAE8: using guessed type int dword_805BAE8;

//----- (08053DB5) --------------------------------------------------------
int __cdecl sub_8053DB5(int a1, char a2)
{
  return __ROR4__(a1, a2);
}

//----- (080540EC) --------------------------------------------------------
int __cdecl sub_80540EC(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 65) > 0x19 )
    result = a1;
  else
    result = a1 + 32;
  return result;
}

//----- (0805412C) --------------------------------------------------------
__int64 __cdecl sub_805412C(unsigned int a1, unsigned int a2, int a3, int a4)
{
  void *v4; // eax
  unsigned int v5; // edx
  unsigned int v6; // ecx
  unsigned int v7; // esi
  __int64 result; // rax

  v4 = &loc_8054168;
  if ( a4 )
    v4 = &loc_8054194;
  dword_805B288 = (int)v4;
  sub_80545C3(a3, a2);
  if ( v6 > a2 )
    return (unsigned int)(__PAIR__(v5, a1) / v6);
  v7 = v6;
  if ( !v6 )
    v7 = 1 / 0u;
  LODWORD(result) = __PAIR__(a2 % v7, a1) / v7;
  HIDWORD(result) = a2 / v7;
  return result;
}
// 805B288: using guessed type int dword_805B288;

//----- (08054265) --------------------------------------------------------
int __cdecl sub_8054265(unsigned __int64 a1, __int64 a2)
{
  int v2; // edx
  int result; // eax
  int v4; // ebp
  int v5; // ebp
  unsigned int v6; // ebp
  unsigned __int64 v7; // rtt
  unsigned __int64 v8; // rax
  unsigned int v9; // edi
  unsigned __int64 v10; // rax
  unsigned int v11; // ecx
  unsigned int v12; // [esp+4h] [ebp-1Ch]
  __int64 v13; // [esp+8h] [ebp-18h]
  unsigned int v14; // [esp+Ch] [ebp-14h]

  LODWORD(v13) = a1;
  if ( HIDWORD(a2) )
  {
    if ( HIDWORD(a2) > HIDWORD(a1) )
    {
      result = a1;
    }
    else
    {
      _BitScanReverse((unsigned int *)&v4, HIDWORD(a2));
      v5 = v4 ^ 0x1F;
      if ( v5 )
      {
        v12 = (HIDWORD(a2) << v5) | ((unsigned int)a2 >> (32 - v5));
        HIDWORD(v8) = HIDWORD(a1) >> (32 - v5);
        LODWORD(v8) = (HIDWORD(a1) << v5) | ((unsigned int)a1 >> (32 - v5));
        v14 = (_DWORD)a1 << v5;
        v9 = v8 % v12;
        v10 = (unsigned int)((_DWORD)a2 << v5) * (unsigned __int64)(unsigned int)(v8 / v12);
        v11 = v10;
        if ( v9 < HIDWORD(v10) || v14 < (unsigned int)v10 && v9 == HIDWORD(v10) )
        {
          HIDWORD(v10) = (v10 - __PAIR__(v12, (_DWORD)a2 << v5)) >> 32;
          v11 = v10 - ((_DWORD)a2 << v5);
        }
        result = ((__PAIR__(v9, v14) - __PAIR__(HIDWORD(v10), v11)) >> 32 << (32 - (unsigned __int8)v5)) | ((v14 - v11) >> v5);
      }
      else
      {
        if ( (unsigned int)a2 <= (unsigned int)a1 || HIDWORD(a2) < HIDWORD(a1) )
          LODWORD(v13) = a1 - a2;
        result = v13;
      }
    }
  }
  else
  {
    if ( (unsigned int)a2 <= HIDWORD(a1) )
    {
      v6 = a2;
      if ( !(_DWORD)a2 )
        v6 = 1 / 0u;
      LODWORD(v7) = a1;
      HIDWORD(v7) = HIDWORD(a1) % v6;
      v2 = v7 % v6;
    }
    else
    {
      v2 = a1 % (unsigned int)a2;
    }
    result = v2;
  }
  return result;
}

//----- (08054428) --------------------------------------------------------
int __cdecl sub_8054428(int a1)
{
  return __cxa_atexit(a1, 0, dword_805B2BC);
}
// 8049130: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 805B2BC: using guessed type int dword_805B2BC;

//----- (08054457) --------------------------------------------------------
int __cdecl sub_8054457(int a1, int a2)
{
  return __fxstat64(3, a1, a2);
}
// 80490C0: using guessed type int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD);

//----- (08054582) --------------------------------------------------------
#error "80545BB: positive sp value has been found (funcsize=18)"

//----- (080545C3) --------------------------------------------------------
#error "80545C9: positive sp value has been found (funcsize=0)"

//----- (08054611) --------------------------------------------------------
#error "805464A: positive sp value has been found (funcsize=18)"

//----- (08054652) --------------------------------------------------------
#error "8054658: positive sp value has been found (funcsize=0)"

//----- (080546C8) --------------------------------------------------------
#error "80546CE: positive sp value has been found (funcsize=0)"

//----- (08054736) --------------------------------------------------------
#error "805473C: positive sp value has been found (funcsize=0)"

//----- (080547B0) --------------------------------------------------------
#error "80547B6: positive sp value has been found (funcsize=0)"

//----- (08054813) --------------------------------------------------------
#error "805484C: positive sp value has been found (funcsize=18)"

//----- (08054854) --------------------------------------------------------
#error "805485A: positive sp value has been found (funcsize=0)"

//----- (080548CA) --------------------------------------------------------
#error "80548D0: positive sp value has been found (funcsize=0)"

//----- (0805491C) --------------------------------------------------------
#error "8054955: positive sp value has been found (funcsize=18)"

//----- (0805495D) --------------------------------------------------------
#error "8054963: positive sp value has been found (funcsize=0)"

//----- (080549D7) --------------------------------------------------------
#error "80549DD: positive sp value has been found (funcsize=0)"

//----- (08054A4D) --------------------------------------------------------
#error "8054A53: positive sp value has been found (funcsize=0)"

//----- (08054AE0) --------------------------------------------------------
#error "8054AE6: positive sp value has been found (funcsize=0)"

//----- (08054B5A) --------------------------------------------------------
#error "8054B60: positive sp value has been found (funcsize=0)"

//----- (08054BCA) --------------------------------------------------------
#error "8054BD0: positive sp value has been found (funcsize=0)"

//----- (08054C3E) --------------------------------------------------------
#error "8054C44: positive sp value has been found (funcsize=0)"

//----- (08054CB6) --------------------------------------------------------
#error "8054CBC: positive sp value has been found (funcsize=0)"

//----- (08054D26) --------------------------------------------------------
#error "8054D2C: positive sp value has been found (funcsize=0)"

//----- (08054D9E) --------------------------------------------------------
#error "8054DA4: positive sp value has been found (funcsize=0)"

//----- (08054DB0) --------------------------------------------------------
int (**sub_8054DB0())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_805AEB8;
  v1 = &off_805AEBC - off_805AEB8;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_805AEB8[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 805AEB8: using guessed type int (*off_805AEB8[2])();
// 805AEBC: using guessed type int (*off_805AEBC)();

//----- (08054E14) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 33 decompilation failure(s) on 252 function(s)"
