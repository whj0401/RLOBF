/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8048F10();
// int __cdecl freopen64(_DWORD, _DWORD, _DWORD); weak
// int dup2(int fd, int fd2);
// int strcmp(const char *s1, const char *s2);
// int __cdecl open64(_DWORD, _DWORD); weak
// ssize_t read(int fd, void *buf, size_t nbytes);
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void _exit(int status);
// void free(void *ptr);
// void *memcpy(void *dest, const void *src, size_t n);
// int ferror(FILE *stream);
// int fclose(FILE *stream);
// int getc_unlocked(FILE *stream);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// int __cdecl stpcpy(_DWORD, _DWORD); weak
// __uid_t getuid(void);
// int __cdecl fopen64(_DWORD, _DWORD); weak
// int ferror_unlocked(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD); weak
// size_t __ctype_get_mb_cur_max(void);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// size_t __fpending(FILE *fp);
// __pid_t getpid(void);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// void error(int status, int errnum, const char *format, ...);
// size_t fread_unlocked(void *ptr, size_t size, size_t n, FILE *stream);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int __freading(FILE *fp);
// void exit(int status);
// int __cdecl ftello64(_DWORD); weak
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// char *strchr(const char *s, int c);
// size_t strlen(const char *s);
// int fprintf(FILE *stream, const char *format, ...);
// int fcntl(int fd, int cmd, ...);
// int setvbuf(FILE *stream, char *buf, int modes, size_t n);
// __gid_t getgid(void);
// void *memset(void *s, int c, size_t n);
// int *__errno_location(void);
// void *memchr(const void *s, int c, size_t n);
// int fileno(FILE *stream);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// char *strrchr(const char *s, int c);
// __pid_t getppid(void);
// int __cdecl explicit_bzero(_DWORD, _DWORD); weak
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// int feof_unlocked(FILE *stream);
// void abort(void);
// int close(int fd);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// void *calloc(size_t nmemb, size_t size);
// int _gmon_start__(void); weak
void sub_8049423();
void sub_8049440();
int sub_8049450();
int sub_80494C0();
int sub_80494E0();
void sub_804953F();
void sub_804955A();
int sub_804956A();
void sub_804964C();
void sub_8049667();
int sub_8049677();
void sub_8049759();
void sub_8049774();
int sub_8049784();
void sub_8049866();
void sub_8049881();
int sub_8049891();
int sub_804991B();
void sub_804998F();
void sub_80499AA();
int sub_80499BA();
// int __usercall sub_8049A21@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
void sub_8049AB8();
void sub_8049AD3();
int sub_8049AE3();
// int __usercall sub_8049B4A@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
void sub_8049BE1();
void sub_8049BFC();
int sub_8049C0C();
void sub_8049D07();
void sub_8049D22();
int sub_8049D32();
// int __usercall sub_8049DE4@<eax>(void (__cdecl *a1)(int *)@<eax>);
void sub_8049E30();
void sub_8049E4B();
int sub_8049E5B();
int sub_8049EE5();
void sub_8049F6B();
void sub_8049F86();
int sub_8049F96();
int sub_804A020();
// int __usercall sub_804A061@<eax>(void (__cdecl *a1)(int *)@<eax>);
void sub_804A0AD();
void sub_804A0C8();
int sub_804A0D8();
int sub_804A17B();
// int __usercall sub_804A1BC@<eax>(void (__cdecl *a1)(int *)@<eax>);
void sub_804A208();
void sub_804A223();
int sub_804A233();
void sub_804A34A();
void sub_804A365();
int sub_804A375();
void sub_804A457();
void sub_804A472();
int sub_804A482();
void sub_804A564();
void sub_804A57F();
int sub_804A58F();
int nullsub_6(void); // weak
int sub_804A5ED();
int sub_804A632();
void sub_804A6BF();
void sub_804A6DA();
int sub_804A6EA();
// int __usercall sub_804A79C@<eax>(void (__cdecl *a1)(int *)@<eax>);
void sub_804A7E8();
void sub_804A803();
int sub_804A813();
void sub_804A920();
void sub_804A93B();
void sub_804AA46();
void sub_804AA61();
int sub_804AA71();
int nullsub_7(void); // weak
int sub_804AACF();
int sub_804AB4F();
int sub_804AB7A();
int __cdecl sub_804ABA5(char *s1); // idb
_BOOL4 __cdecl sub_804AD72(int a1);
int __cdecl sub_804ADC3(int *a1, __int64 a2);
void __cdecl __noreturn sub_804ADF6(int status); // idb
void *__cdecl sub_804AF34(int a1, signed int a2, char a3);
char *__cdecl sub_804B011(void *s, int a2, size_t n);
signed __int64 sub_804B042();
int __cdecl sub_804B0E7(FILE *stream, int, int, int, int); // idb
int __cdecl sub_804B36B(unsigned int a1, int a2, int a3);
unsigned int __cdecl sub_804B401(FILE *stream, int a2, int a3);
signed int __cdecl sub_804B585(unsigned int a1, int a2, int a3);
int __cdecl sub_804B60F(int a1, int a2, int a3, char a4);
int __cdecl sub_804B6BC(int a1, int a2, int a3, int a4, char a5);
signed int __cdecl sub_804B78A(int *a1, unsigned int a2, int a3, unsigned int a4);
void __cdecl __noreturn main(int argc, char **argv);
int sub_804C424();
int __cdecl sub_804C521(int a1, int a2, int a3, int a4, int a5, int a6);
void __cdecl sub_804C572(FILE *stream, int a2);
signed int __cdecl sub_804C5BA(int a1);
FILE *__cdecl sub_804C609(int a1, int a2, FILE *stream);
void *__cdecl sub_804C7F1(void *s);
int __cdecl sub_804C836(int a1, FILE *stream);
void __cdecl sub_804C982(int a1);
void __cdecl __noreturn sub_804C998(int a1);
int __cdecl sub_804C9E7(int c, size_t n); // idb
int __cdecl sub_804CBA0(int *a1, unsigned __int8 a2, char a3);
void __cdecl __noreturn sub_804CC4A(int *a1, int a2, int a3);
int sub_804CC90(); // weak
// _DWORD *__userpurge sub_804CCA4@<eax>(_DWORD *a1, int a2);
const char *__cdecl sub_804CD26(char *msgid, int a2);
int __cdecl sub_804CDF2(int a1, unsigned int a2, char *a3, size_t a4, signed int a5, int a6, int a7, char *a8, char *a9);
void *__cdecl sub_804DE3A(char *a1, size_t a2, _DWORD *a3, int *a4);
void *__cdecl sub_804DFF6(signed int a1, char *a2, size_t a3, int a4);
void *__cdecl sub_804E234(signed int a1, char *a2);
void *__cdecl sub_804E25E(signed int a1, char *a2, size_t a3);
void *__cdecl sub_804E2C4(signed int a1, int a2, char *a3);
void *__cdecl sub_804E302(signed int a1, int a2, char *a3, size_t a4);
void *__cdecl sub_804E38A(char *a1, size_t a2, unsigned __int8 a3);
void *__cdecl sub_804E434(char *a1, unsigned __int8 a2);
void *__cdecl sub_804E45D(char *a1);
void *__cdecl sub_804E49A(signed int a1, int a2, char *a3);
void __cdecl __noreturn sub_804E53B(int a1, int a2, int a3);
void __cdecl __noreturn sub_804E56B(int a1, int a2, int a3);
void *__cdecl sub_804E665(signed int a1, char *a2, size_t a3);
void *__cdecl sub_804E6B0(signed int a1, char *a2);
void *__cdecl sub_804E6D2(char *a1);
_DWORD *__cdecl sub_804E6ED(int a1);
_DWORD *__cdecl sub_804E732(int a1, int a2);
__int64 __cdecl sub_804E771(__int64 a1);
int __cdecl sub_804E792(int *a1, unsigned __int64 a2);
void __cdecl sub_804EA93(void *ptr);
int __cdecl sub_804EAF3(int *a1, __int64 a2);
int __cdecl sub_804EB26(int a1);
unsigned int __cdecl sub_804EB50(int a1, int a2);
int __cdecl sub_804EB7F(int a1, int a2, int a3);
int __cdecl sub_804EBD1(_DWORD *a1, unsigned int a2);
bool __cdecl sub_804EBEE(_DWORD *a1, _DWORD *a2);
size_t *__cdecl sub_804EC11(unsigned int a1);
void __cdecl __noreturn sub_804EC44(int a1, int a2, int a3, int a4);
void __cdecl sub_804ED66(void *a1);
// int __usercall sub_804ED79@<eax>(int a1@<edx>, int a2@<ecx>, int *a3, unsigned int a4, unsigned int a5);
void __cdecl __noreturn sub_804EF95(char *a1);
_DWORD *__cdecl sub_804F017(int a1, int a2);
unsigned int __cdecl sub_804F04C(int a1, int a2, size_t nbytes);
int __cdecl sub_804F259(int a1, int a2);
int __cdecl sub_804F29E(char *buf, int modes, size_t n); // idb
void __cdecl __noreturn sub_804F406(int, void *ptr, size_t n); // idb
int sub_804F4B9(); // weak
int __cdecl sub_804F4BF(int, void *dest, size_t n); // idb
// void __usercall __noreturn sub_804F5E0(int a1@<edx>, int a2@<ecx>, int a3, void *ptr, size_t n);
int sub_804F623(); // weak
int __cdecl sub_804F641(void *ptr); // idb
int __cdecl sub_804F6A0(int a1);
int __cdecl sub_804F6B7(int a1, __int16 a2);
unsigned int *__cdecl sub_804F6E8(unsigned int *a1, int *a2);
_DWORD *__cdecl sub_804FB8D(_DWORD *a1);
void *__cdecl sub_804FFAE(FILE *stream, int a2);
void *__cdecl sub_805028D(int a1, int a2, int a3);
int __cdecl sub_8050362(FILE *stream, int, int, int, int, int); // idb
int __cdecl sub_80508D9(FILE *stream, int, int, int, int); // idb
int sub_805093F(FILE *stream, int a2, int a3, int a4, ...);
void *__cdecl sub_80509DF(unsigned int a1, unsigned int a2);
void *__cdecl sub_8050A0D(void *ptr, int a2, int a3);
void *__cdecl sub_8050A42(void *ptr, int a2, int a3);
void *__cdecl sub_8050AD9(size_t size);
void *__cdecl sub_8050AEC(size_t size);
void *__cdecl sub_8050B16(void *ptr, size_t size);
void *__cdecl sub_8050B65(void *ptr, int a2);
void *__cdecl sub_8050BB1(size_t nmemb, size_t size);
void *__cdecl sub_8050BEE(void *src, size_t n);
void __noreturn sub_8050C3C();
unsigned __int64 __cdecl sub_8050C75(char *nptr, int base, int a3, int a4, int a5, int a6, char *s, int a8, int status);
unsigned __int64 __cdecl sub_8050DCC(char *nptr, int a2, int a3, int a4, int a5, char *s, int a7, int status);
signed int __cdecl sub_8050E30(unsigned int *a1, unsigned int a2);
int __cdecl sub_8050E74(int a1, int a2, int a3);
int __cdecl sub_8050EC3(char *nptr, int, int base, int, char *s); // idb
signed int __cdecl sub_805132D(int a1, signed int a2);
int sub_80513B9();
int sub_80513EE(); // weak
int __cdecl sub_8051412(char *nptr, int a2, int base);
int __cdecl sub_80518D3(FILE *stream); // idb
int __cdecl sub_80519AF(FILE *stream); // idb
int __cdecl sub_80519E8(FILE *fp); // idb
int __cdecl sub_8051A28(FILE *stream, int, int, int); // idb
size_t __cdecl sub_8051B13(wchar_t *pwc, char *s, size_t n, mbstate_t *p);
int __cdecl sub_8051B9E(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_8051C03(FILE *fp); // idb
FILE *__cdecl sub_8051CB6(int a1, char *modes);
int __cdecl sub_8051D8C(int category); // idb
int __cdecl sub_8051DEA(int a1);
int __cdecl sub_8051DF5(int a1);
int __cdecl sub_8051E00(int a1);
unsigned int __cdecl sub_8051E0B(int a1);
int __cdecl sub_805200B(int a1, int a2);
bool __cdecl sub_8052367(unsigned int a1);
int __cdecl sub_80523BE(unsigned int a1);
unsigned int __cdecl sub_8052448(int a1, unsigned int a2);
bool __cdecl sub_8052473(int a1, int a2);
signed int __cdecl sub_8052481(int a1);
unsigned int __cdecl sub_8052556(unsigned int a1, int a2);
size_t *__cdecl sub_805260D(unsigned int a1, void *a2, int a3, bool (__cdecl *a4)(int a1, int a2), size_t a5);
void __cdecl sub_805284F(void *a1);
void *__cdecl sub_805297E(int a1);
int __cdecl sub_80529B9(int a1, _DWORD *a2);
int __cdecl sub_80529DC(int a1, int a2, _DWORD *a3, char a4);
signed int __cdecl sub_8052B6B(int a1, int a2, char a3);
signed int __cdecl sub_8052CEA(int a1, unsigned int a2);
void __cdecl __noreturn sub_8052EDC(int a1, int a2);
int __cdecl sub_8052F06(int, int, int); // weak
void __cdecl __noreturn sub_8053164(int a1, int a2);
int __cdecl sub_80531B8(int a1, int a2);
int sub_80533B6();
int __cdecl sub_80534FF(void *src, size_t n); // idb
int sub_805388D();
int sub_8053AC2(); // weak
int sub_8053B28(); // weak
char *sub_8053B5A();
int __cdecl sub_8053C5F(int fd); // idb
int __cdecl sub_8053C82(int fd, int cmd, char); // idb
int __cdecl sub_8053D49(int cmd, char); // idb
int sub_8053D91();
int sub_8053DAE(); // weak
int sub_8053DCB(); // weak
int __cdecl sub_805407D(int a1, char a2);
int __cdecl sub_805436D(int a1);
__int64 __cdecl sub_80543C2(unsigned __int64 a1, unsigned int a2, unsigned int a3);
__int64 __cdecl sub_8054529(int a1, unsigned int a2, unsigned int a3, int a4);
int __cdecl sub_8054705(int a1);
int __cdecl sub_8054734(int a1, int a2);
int sub_8054836(void); // weak
int __fastcall sub_80548A4(_DWORD, _DWORD); // weak
int sub_805492F(void); // weak
int sub_80549A1(void); // weak
int sub_8054A0F(void); // weak
int __fastcall sub_8054A83(_DWORD, _DWORD, _DWORD); // weak
int __fastcall sub_8054AF3(_DWORD, _DWORD); // weak
int sub_8054B67(void); // weak
int sub_8054BD7(void); // weak
int sub_8054C6A(void); // weak
int sub_8054CDA(void); // weak
int sub_8054D67(void); // weak
int sub_8054DDB(void); // weak
int sub_8054E51(void); // weak
int sub_8054EBD(void); // weak
int sub_8054F2B(void); // weak
int __fastcall sub_8054FB6(_DWORD, _DWORD); // weak
int (**sub_8054FD0())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN locret_8049C1B; // weak
_UNKNOWN locret_804A0E7; // weak
_UNKNOWN locret_804A822; // weak
_UNKNOWN loc_804AC35; // weak
_UNKNOWN loc_804AC79; // weak
_UNKNOWN loc_804AC82; // weak
_UNKNOWN loc_804AD41; // weak
_UNKNOWN loc_804AD48; // weak
_UNKNOWN loc_804ADA0; // weak
_UNKNOWN loc_804ADB2; // weak
_UNKNOWN loc_804AE1E; // weak
_UNKNOWN loc_804AE4B; // weak
_UNKNOWN loc_804AFF3; // weak
_UNKNOWN loc_804B293; // weak
_UNKNOWN loc_804B2B3; // weak
_UNKNOWN loc_804B316; // weak
_UNKNOWN loc_804B33F; // weak
_UNKNOWN locret_804B3FF; // weak
_UNKNOWN loc_804B4E0; // weak
_UNKNOWN loc_804B574; // weak
_UNKNOWN loc_804B69B; // weak
_UNKNOWN loc_804B769; // weak
_UNKNOWN loc_804C48F; // weak
_UNKNOWN loc_804C4CA; // weak
_UNKNOWN loc_804C69F; // weak
_UNKNOWN loc_804C6A5; // weak
_UNKNOWN loc_804C732; // weak
_UNKNOWN loc_804C74E; // weak
_UNKNOWN loc_804C76A; // weak
_UNKNOWN loc_804C7A5; // weak
_UNKNOWN loc_804C7B1; // weak
_UNKNOWN loc_804C7E2; // weak
_UNKNOWN loc_804C7EC; // weak
_UNKNOWN loc_804C889; // weak
_UNKNOWN loc_804C893; // weak
_UNKNOWN loc_804C9BD; // weak
_UNKNOWN loc_804CC8B; // weak
_UNKNOWN loc_804CDCF; // weak
_UNKNOWN loc_804CDEB; // weak
_UNKNOWN locret_804CDF0; // weak
_UNKNOWN loc_804CE6B; // weak
_UNKNOWN loc_804CEF4; // weak
_UNKNOWN loc_804CF20; // weak
_UNKNOWN loc_804CFB8; // weak
_UNKNOWN loc_804CFBC; // weak
_UNKNOWN loc_804D000; // weak
_UNKNOWN loc_804D037; // weak
_UNKNOWN loc_804D06B; // weak
_UNKNOWN loc_804D084; // weak
_UNKNOWN loc_804D0BC; // weak
_UNKNOWN loc_804D123; // weak
_UNKNOWN loc_804D16C; // weak
_UNKNOWN loc_804D224; // weak
_UNKNOWN loc_804D229; // weak
_UNKNOWN loc_804D34B; // weak
_UNKNOWN loc_804D3DD; // weak
_UNKNOWN loc_804D3FC; // weak
_UNKNOWN loc_804D41B; // weak
_UNKNOWN loc_804D420; // weak
_UNKNOWN loc_804D479; // weak
_UNKNOWN loc_804D489; // weak
_UNKNOWN loc_804D4B8; // weak
_UNKNOWN loc_804D4BD; // weak
_UNKNOWN loc_804D4E0; // weak
_UNKNOWN loc_804D4EB; // weak
_UNKNOWN loc_804D521; // weak
_UNKNOWN loc_804D526; // weak
_UNKNOWN loc_804D5D3; // weak
_UNKNOWN loc_804D613; // weak
_UNKNOWN loc_804D6A5; // weak
_UNKNOWN loc_804D6AA; // weak
_UNKNOWN loc_804D795; // weak
_UNKNOWN loc_804D7FE; // weak
_UNKNOWN loc_804D803; // weak
_UNKNOWN loc_804D9CB; // weak
_UNKNOWN loc_804D9D6; // weak
_UNKNOWN loc_804DA18; // weak
_UNKNOWN loc_804DA37; // weak
_UNKNOWN loc_804DA3C; // weak
_UNKNOWN loc_804DAB1; // weak
_UNKNOWN loc_804DAD0; // weak
_UNKNOWN loc_804DB0D; // weak
_UNKNOWN loc_804DB82; // weak
_UNKNOWN loc_804DBA7; // weak
_UNKNOWN loc_804DBAC; // weak
_UNKNOWN loc_804DBCB; // weak
_UNKNOWN loc_804DC5F; // weak
_UNKNOWN loc_804DCA7; // weak
_UNKNOWN loc_804DCFD; // weak
_UNKNOWN loc_804DD0A; // weak
_UNKNOWN loc_804DD53; // weak
_UNKNOWN loc_804E03D; // weak
_UNKNOWN loc_804E0EC; // weak
_UNKNOWN loc_804E7FF; // weak
_UNKNOWN loc_804EE2C; // weak
_UNKNOWN loc_804EE5B; // weak
_UNKNOWN loc_804EE60; // weak
_UNKNOWN loc_804EE78; // weak
_UNKNOWN loc_804EF90; // weak
_UNKNOWN loc_804EFD4; // weak
_UNKNOWN loc_804EFE4; // weak
_UNKNOWN locret_804F3E8; // weak
_UNKNOWN loc_804F468; // weak
_UNKNOWN loc_804F47F; // weak
_UNKNOWN loc_804F4CD; // weak
_UNKNOWN loc_804F608; // weak
_UNKNOWN loc_804F68C; // weak
_UNKNOWN loc_804F699; // weak
_UNKNOWN loc_804FF6E; // weak
_UNKNOWN loc_8050015; // weak
_UNKNOWN loc_8050086; // weak
_UNKNOWN loc_805018F; // weak
_UNKNOWN loc_8050198; // weak
_UNKNOWN loc_8050218; // weak
_UNKNOWN loc_805026B; // weak
_UNKNOWN loc_8050314; // weak
_UNKNOWN loc_8050879; // weak
_UNKNOWN loc_8050D59; // weak
_UNKNOWN loc_8050D64; // weak
_UNKNOWN loc_8050E83; // weak
_UNKNOWN loc_8050EBE; // weak
_UNKNOWN loc_8050EF5; // weak
_UNKNOWN loc_8050F12; // weak
_UNKNOWN loc_8050F36; // weak
_UNKNOWN loc_8051055; // weak
_UNKNOWN loc_805105F; // weak
_UNKNOWN loc_805112F; // weak
_UNKNOWN loc_8051136; // weak
_UNKNOWN loc_80512FB; // weak
_UNKNOWN locret_805132B; // weak
_UNKNOWN loc_8051444; // weak
_UNKNOWN loc_805144C; // weak
_UNKNOWN loc_805148D; // weak
_UNKNOWN loc_80514F6; // weak
_UNKNOWN loc_8051500; // weak
_UNKNOWN loc_8051933; // weak
_UNKNOWN loc_805196C; // weak
_UNKNOWN loc_8051A77; // weak
_UNKNOWN loc_8051AF1; // weak
_UNKNOWN loc_8051B6D; // weak
_UNKNOWN loc_8051B99; // weak
_UNKNOWN loc_8051C61; // weak
_UNKNOWN loc_8051C86; // weak
_UNKNOWN loc_8051C92; // weak
_UNKNOWN loc_80523FA; // weak
_UNKNOWN loc_805240C; // weak
_UNKNOWN locret_8052554; // weak
_UNKNOWN locret_805260B; // weak
_UNKNOWN loc_8052632; // weak
_UNKNOWN loc_8052639; // weak
_UNKNOWN loc_8052674; // weak
_UNKNOWN loc_8052690; // weak
_UNKNOWN locret_805276D; // weak
_UNKNOWN loc_80528BC; // weak
_UNKNOWN loc_80528F1; // weak
_UNKNOWN loc_805290B; // weak
_UNKNOWN loc_805292A; // weak
_UNKNOWN loc_8052A56; // weak
_UNKNOWN loc_8052AAC; // weak
_UNKNOWN loc_8052CB8; // weak
_UNKNOWN loc_8052D4E; // weak
_UNKNOWN loc_8052D6A; // weak
_UNKNOWN locret_8052EDA; // weak
_UNKNOWN loc_8052F01; // weak
_UNKNOWN loc_8053201; // weak
_UNKNOWN loc_805320B; // weak
_UNKNOWN loc_8053466; // weak
_UNKNOWN loc_805347A; // weak
_UNKNOWN loc_8053504; // weak
_UNKNOWN loc_8053B8E; // weak
_UNKNOWN loc_8053B95; // weak
_UNKNOWN loc_8053BD1; // weak
_UNKNOWN loc_8053BF4; // weak
_UNKNOWN loc_8053C01; // weak
_UNKNOWN loc_8053C19; // weak
_UNKNOWN loc_8053D2C; // weak
_UNKNOWN loc_8053EE6; // weak
_UNKNOWN loc_8054408; // weak
_UNKNOWN loc_8054413; // weak
_UNKNOWN loc_8054452; // weak
_UNKNOWN loc_80544E5; // weak
_UNKNOWN loc_8054511; // weak
_UNKNOWN loc_8054573; // weak
_UNKNOWN loc_805458A; // weak
_UNKNOWN unk_805598E; // weak
_UNKNOWN unk_8055992; // weak
_UNKNOWN unk_805599E; // weak
_UNKNOWN unk_80559A2; // weak
_UNKNOWN unk_80559A5; // weak
_UNKNOWN unk_8056470; // weak
_UNKNOWN unk_8056567; // weak
int dword_8056F04 = 0; // weak
_UNKNOWN unk_80571DC; // weak
_UNKNOWN unk_80571DF; // weak
_UNKNOWN unk_805822C; // weak
_UNKNOWN unk_805822F; // weak
int dword_8058EE4 = 2231517709; // weak
int dword_8058EEC = 2248212480; // weak
int dword_8058EF0 = 3143499775; // weak
_UNKNOWN unk_805927C; // weak
_UNKNOWN unk_805927F; // weak
int (*off_805AEBC[2])() = { &sub_80494E0, &sub_80494C0 }; // weak
int (*off_805AEC0)() = &sub_80494C0; // weak
int (*dword_805B008)(void) = NULL; // weak
int dword_805B148 = 0; // weak
int dword_805B15C = 0; // weak
int dword_805B170 = 0; // weak
int dword_805B184 = 0; // weak
int dword_805B198 = 0; // weak
int dword_805B1AC = 0; // weak
int dword_805B1C0 = 0; // weak
int dword_805B1D4 = 0; // weak
int dword_805B1E8 = 0; // weak
int dword_805B1FC = 0; // weak
int dword_805B210 = 0; // weak
int dword_805B224 = 0; // weak
int dword_805B238 = 0; // weak
int dword_805B24C = 0; // weak
int dword_805B260 = 0; // weak
int dword_805B274 = 0; // weak
int dword_805B288 = 0; // weak
int (*dword_805B298)(void) = NULL; // weak
int dword_805B2B0 = 0; // weak
int status = 1; // idb
int dword_805B2CC = 1; // weak
int dword_805B2D0 = 256; // weak
void *off_805B2D4 = &unk_805B977; // weak
int *off_805B2D8 = &dword_805B2D0; // weak
_UNKNOWN unk_805B2EC; // weak
_UNKNOWN unk_805B308; // weak
_UNKNOWN unk_805B30B; // weak
_UNKNOWN unk_805B314; // weak
_UNKNOWN unk_805B317; // weak
_UNKNOWN unk_805B31C; // weak
_UNKNOWN unk_805B31F; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
FILE *stdout; // idb
char byte_805B36C; // weak
_UNKNOWN unk_805B40A; // weak
char byte_805B4A0; // weak
char byte_805B621; // weak
char byte_805B66E; // weak
_UNKNOWN unk_805B672; // weak
char byte_805B6BB; // weak
char byte_805B7EF; // weak
int dword_805B927; // weak
char byte_805B92B; // weak
int dword_805B92F; // weak
int dword_805B937; // weak
int dword_805B93B; // weak
int dword_805B93F; // weak
int dword_805B943; // weak
int dword_805B947; // weak
int dword_805B94B; // weak
int dword_805B94F; // weak
int dword_805B953; // weak
int dword_805B957; // weak
int dword_805B95B; // weak
int dword_805B95F; // weak
int dword_805B963; // weak
_UNKNOWN unk_805B977; // weak
int dword_805BA77; // weak
int dword_805BA7B; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (08048EEC) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 80493E0: using guessed type int _gmon_start__(void);

//----- (08048F10) --------------------------------------------------------
int sub_8048F10()
{
  return dword_805B008();
}
// 805B008: using guessed type int (*dword_805B008)(void);

//----- (080493F0) --------------------------------------------------------
#error "80493F3: positive sp value has been found (funcsize=2)"

//----- (08049423) --------------------------------------------------------
void sub_8049423()
{
  ;
}

//----- (08049440) --------------------------------------------------------
void sub_8049440()
{
  ;
}

//----- (08049450) --------------------------------------------------------
int sub_8049450()
{
  int result; // eax

  result = &unk_805B31F - &unk_805B31C;
  if ( (unsigned int)(&unk_805B31F - &unk_805B31C) > 6 )
    result = 0;
  return result;
}
// 8049450: could not find valid save-restore pair for ebp

//----- (080494C0) --------------------------------------------------------
int sub_80494C0()
{
  int result; // eax

  if ( !byte_805B36C )
  {
    result = sub_8049450();
    byte_805B36C = 1;
  }
  return result;
}
// 80494C0: could not find valid save-restore pair for ebp
// 805B36C: using guessed type char byte_805B36C;

//----- (080494E0) --------------------------------------------------------
int sub_80494E0()
{
  return 0;
}
// 80494E0: could not find valid save-restore pair for ebp

//----- (0804953F) --------------------------------------------------------
void sub_804953F()
{
  ;
}

//----- (0804955A) --------------------------------------------------------
void sub_804955A()
{
  ;
}

//----- (0804956A) --------------------------------------------------------
int sub_804956A()
{
  int result; // eax

  result = &unk_805B30B - &unk_805B308;
  if ( (unsigned int)(&unk_805B30B - &unk_805B308) > 6 )
    result = 0;
  return result;
}
// 804956A: could not find valid save-restore pair for ebp

//----- (0804964C) --------------------------------------------------------
void sub_804964C()
{
  ;
}

//----- (08049667) --------------------------------------------------------
void sub_8049667()
{
  ;
}

//----- (08049677) --------------------------------------------------------
int sub_8049677()
{
  int result; // eax

  result = &unk_805B30B - &unk_805B308;
  if ( (unsigned int)(&unk_805B30B - &unk_805B308) > 6 )
    result = 0;
  return result;
}
// 8049677: could not find valid save-restore pair for ebp

//----- (08049759) --------------------------------------------------------
void sub_8049759()
{
  ;
}

//----- (08049774) --------------------------------------------------------
void sub_8049774()
{
  ;
}

//----- (08049784) --------------------------------------------------------
int sub_8049784()
{
  int result; // eax

  result = &unk_805B40A - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_805B40A - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 8049784: could not find valid save-restore pair for ebp
// 805B320: using guessed type int program_invocation_short_name;

//----- (08049866) --------------------------------------------------------
void sub_8049866()
{
  ;
}

//----- (08049881) --------------------------------------------------------
void sub_8049881()
{
  ;
}

//----- (08049891) --------------------------------------------------------
int sub_8049891()
{
  int result; // eax

  result = &unk_805B30B - &unk_805B308;
  if ( (unsigned int)(&unk_805B30B - &unk_805B308) > 6 )
    result = 0;
  return result;
}
// 8049891: could not find valid save-restore pair for ebp

//----- (0804991B) --------------------------------------------------------
int sub_804991B()
{
  int result; // eax

  result = sub_8049891();
  byte_805B4A0 = 1;
  return result;
}
// 805B4A0: using guessed type char byte_805B4A0;

//----- (0804998F) --------------------------------------------------------
void sub_804998F()
{
  ;
}

//----- (080499AA) --------------------------------------------------------
void sub_80499AA()
{
  ;
}

//----- (080499BA) --------------------------------------------------------
int sub_80499BA()
{
  int result; // eax

  result = &unk_805B30B - &unk_805B308;
  if ( (unsigned int)(&unk_805B30B - &unk_805B308) > 6 )
    result = 0;
  return result;
}
// 80499BA: could not find valid save-restore pair for ebp

//----- (08049A21) --------------------------------------------------------
int __usercall sub_8049A21@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_805B308, a1);
}

//----- (08049AB8) --------------------------------------------------------
void sub_8049AB8()
{
  ;
}

//----- (08049AD3) --------------------------------------------------------
void sub_8049AD3()
{
  ;
}

//----- (08049AE3) --------------------------------------------------------
int sub_8049AE3()
{
  int result; // eax

  result = &unk_805B30B - &unk_805B308;
  if ( (unsigned int)(&unk_805B30B - &unk_805B308) > 6 )
    result = 0;
  return result;
}
// 8049AE3: could not find valid save-restore pair for ebp

//----- (08049B4A) --------------------------------------------------------
int __usercall sub_8049B4A@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_805B308, a1);
}

//----- (08049BE1) --------------------------------------------------------
void sub_8049BE1()
{
  ;
}

//----- (08049BFC) --------------------------------------------------------
void sub_8049BFC()
{
  ;
}

//----- (08049C0C) --------------------------------------------------------
int sub_8049C0C()
{
  int result; // eax
  int (__stdcall *v1)(void *, int, int, int, int, int); // eax
  int v2; // [esp+4h] [ebp-18h]
  int v3; // [esp+8h] [ebp-14h]
  int v4; // [esp+Ch] [ebp-10h]
  int v5; // [esp+10h] [ebp-Ch]
  int v6; // [esp+14h] [ebp-8h]
  int v7; // [esp+18h] [ebp-4h]

  result = &unk_805B30B - &unk_805B308;
  if ( (unsigned int)(&unk_805B30B - &unk_805B308) > 6 )
  {
    v7 = 0;
    dword_805B1AC = (int)&locret_8049C1B;
    v1 = (int (__stdcall *)(void *, int, int, int, int, int))sub_8054D67();
    result = v1(&unk_805B308, v2, v3, v4, v5, v6);
  }
  return result;
}
// 8054D67: using guessed type int sub_8054D67(void);
// 805B1AC: using guessed type int dword_805B1AC;

//----- (08049D07) --------------------------------------------------------
void sub_8049D07()
{
  ;
}

//----- (08049D22) --------------------------------------------------------
void sub_8049D22()
{
  ;
}

//----- (08049D32) --------------------------------------------------------
int sub_8049D32()
{
  int result; // eax

  result = &unk_805927F - &unk_805927C;
  if ( (unsigned int)(&unk_805927F - &unk_805927C) > 6 )
    result = 0;
  return result;
}
// 8049D32: could not find valid save-restore pair for ebp

//----- (08049DE4) --------------------------------------------------------
int __usercall sub_8049DE4@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  a1(&dword_8058EE4);
  return 0;
}
// 8058EE4: using guessed type int dword_8058EE4;

//----- (08049E30) --------------------------------------------------------
void sub_8049E30()
{
  ;
}

//----- (08049E4B) --------------------------------------------------------
void sub_8049E4B()
{
  ;
}

//----- (08049E5B) --------------------------------------------------------
int sub_8049E5B()
{
  int result; // eax

  result = &unk_805B30B - &unk_805B308;
  if ( (unsigned int)(&unk_805B30B - &unk_805B308) > 6 )
    result = 0;
  return result;
}
// 8049E5B: could not find valid save-restore pair for ebp

//----- (08049EE5) --------------------------------------------------------
int sub_8049EE5()
{
  int result; // eax

  result = sub_8049E5B();
  byte_805B621 = 1;
  return result;
}
// 805B621: using guessed type char byte_805B621;

//----- (08049F6B) --------------------------------------------------------
void sub_8049F6B()
{
  ;
}

//----- (08049F86) --------------------------------------------------------
void sub_8049F86()
{
  ;
}

//----- (08049F96) --------------------------------------------------------
int sub_8049F96()
{
  int result; // eax

  result = &unk_805B30B - &unk_805B308;
  if ( (unsigned int)(&unk_805B30B - &unk_805B308) > 6 )
    result = 0;
  return result;
}
// 8049F96: could not find valid save-restore pair for ebp

//----- (0804A020) --------------------------------------------------------
int sub_804A020()
{
  int result; // eax

  result = sub_8049F96();
  byte_805B66E = 1;
  return result;
}
// 805B66E: using guessed type char byte_805B66E;

//----- (0804A061) --------------------------------------------------------
int __usercall sub_804A061@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  a1(&dword_8058EEC);
  return 0;
}
// 8058EEC: using guessed type int dword_8058EEC;

//----- (0804A0AD) --------------------------------------------------------
void sub_804A0AD()
{
  ;
}

//----- (0804A0C8) --------------------------------------------------------
void sub_804A0C8()
{
  ;
}

//----- (0804A0D8) --------------------------------------------------------
int sub_804A0D8()
{
  int result; // eax
  int (__stdcall *v1)(int *, int, int, int, int, int); // eax
  int v2; // [esp+4h] [ebp-18h]
  int v3; // [esp+8h] [ebp-14h]
  int v4; // [esp+Ch] [ebp-10h]
  int v5; // [esp+10h] [ebp-Ch]
  int v6; // [esp+14h] [ebp-8h]
  int v7; // [esp+18h] [ebp-4h]

  result = &unk_805B672 - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_805B672 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
  {
    v7 = 0;
    dword_805B1D4 = (int)&locret_804A0E7;
    v1 = (int (__stdcall *)(int *, int, int, int, int, int))sub_8054C6A();
    result = v1(&program_invocation_short_name, v2, v3, v4, v5, v6);
  }
  return result;
}
// 8054C6A: using guessed type int sub_8054C6A(void);
// 805B1D4: using guessed type int dword_805B1D4;
// 805B320: using guessed type int program_invocation_short_name;

//----- (0804A17B) --------------------------------------------------------
int sub_804A17B()
{
  int result; // eax

  result = sub_804A0D8();
  byte_805B6BB = 1;
  return result;
}
// 805B6BB: using guessed type char byte_805B6BB;

//----- (0804A1BC) --------------------------------------------------------
int __usercall sub_804A1BC@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  a1(&dword_8058EF0);
  return 0;
}
// 8058EF0: using guessed type int dword_8058EF0;

//----- (0804A208) --------------------------------------------------------
void sub_804A208()
{
  ;
}

//----- (0804A223) --------------------------------------------------------
void sub_804A223()
{
  ;
}

//----- (0804A233) --------------------------------------------------------
int sub_804A233()
{
  int result; // eax

  result = &unk_805822F - &unk_805822C;
  if ( (unsigned int)(&unk_805822F - &unk_805822C) > 6 )
    result = 0;
  return result;
}
// 804A233: could not find valid save-restore pair for ebp

//----- (0804A291) --------------------------------------------------------
#error "804A2AE: call analysis failed (funcsize=19)"

//----- (0804A34A) --------------------------------------------------------
void sub_804A34A()
{
  ;
}

//----- (0804A365) --------------------------------------------------------
void sub_804A365()
{
  ;
}

//----- (0804A375) --------------------------------------------------------
int sub_804A375()
{
  int result; // eax

  result = &unk_805B30B - &unk_805B308;
  if ( (unsigned int)(&unk_805B30B - &unk_805B308) > 6 )
    result = 0;
  return result;
}
// 804A375: could not find valid save-restore pair for ebp

//----- (0804A457) --------------------------------------------------------
void sub_804A457()
{
  ;
}

//----- (0804A472) --------------------------------------------------------
void sub_804A472()
{
  ;
}

//----- (0804A482) --------------------------------------------------------
int sub_804A482()
{
  int result; // eax

  result = &unk_805B30B - &unk_805B308;
  if ( (unsigned int)(&unk_805B30B - &unk_805B308) > 6 )
    result = 0;
  return result;
}
// 804A482: could not find valid save-restore pair for ebp

//----- (0804A564) --------------------------------------------------------
void sub_804A564()
{
  ;
}

//----- (0804A57F) --------------------------------------------------------
void sub_804A57F()
{
  ;
}

//----- (0804A58F) --------------------------------------------------------
int sub_804A58F()
{
  int result; // eax

  result = &unk_805B30B - &unk_805B308;
  if ( (unsigned int)(&unk_805B30B - &unk_805B308) > 6 )
    result = 0;
  return result;
}
// 804A58F: could not find valid save-restore pair for ebp

//----- (0804A5ED) --------------------------------------------------------
int sub_804A5ED()
{
  return nullsub_6();
}
// 804A5ED: could not find valid save-restore pair for ebp
// 804A5EC: using guessed type int nullsub_6(void);

//----- (0804A632) --------------------------------------------------------
int sub_804A632()
{
  int result; // eax

  result = sub_804A58F();
  byte_805B7EF = 1;
  return result;
}
// 805B7EF: using guessed type char byte_805B7EF;

//----- (0804A6BF) --------------------------------------------------------
void sub_804A6BF()
{
  ;
}

//----- (0804A6DA) --------------------------------------------------------
void sub_804A6DA()
{
  ;
}

//----- (0804A6EA) --------------------------------------------------------
int sub_804A6EA()
{
  int result; // eax

  result = &unk_80571DF - &unk_80571DC;
  if ( (unsigned int)(&unk_80571DF - &unk_80571DC) > 6 )
    result = 0;
  return result;
}
// 804A6EA: could not find valid save-restore pair for ebp

//----- (0804A79C) --------------------------------------------------------
int __usercall sub_804A79C@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  a1(&dword_8056F04);
  return 0;
}
// 8056F04: using guessed type int dword_8056F04;

//----- (0804A7E8) --------------------------------------------------------
void sub_804A7E8()
{
  ;
}

//----- (0804A803) --------------------------------------------------------
void sub_804A803()
{
  ;
}

//----- (0804A813) --------------------------------------------------------
int sub_804A813()
{
  int result; // eax
  int (__stdcall *v1)(void *, int, int, int, int, int); // eax
  int v2; // [esp+4h] [ebp-18h]
  int v3; // [esp+8h] [ebp-14h]
  int v4; // [esp+Ch] [ebp-10h]
  int v5; // [esp+10h] [ebp-Ch]
  int v6; // [esp+14h] [ebp-8h]
  int v7; // [esp+18h] [ebp-4h]

  result = &unk_805B30B - &unk_805B308;
  if ( (unsigned int)(&unk_805B30B - &unk_805B308) > 6 )
  {
    v7 = 0;
    dword_805B1D4 = (int)&locret_804A822;
    v1 = (int (__stdcall *)(void *, int, int, int, int, int))sub_8054C6A();
    result = v1(&unk_805B308, v2, v3, v4, v5, v6);
  }
  return result;
}
// 8054C6A: using guessed type int sub_8054C6A(void);
// 805B1D4: using guessed type int dword_805B1D4;

//----- (0804A920) --------------------------------------------------------
void sub_804A920()
{
  ;
}

//----- (0804A93B) --------------------------------------------------------
void sub_804A93B()
{
  ;
}

//----- (0804A94B) --------------------------------------------------------
#error "804A978: call analysis failed (funcsize=23)"

//----- (0804AA46) --------------------------------------------------------
void sub_804AA46()
{
  ;
}

//----- (0804AA61) --------------------------------------------------------
void sub_804AA61()
{
  ;
}

//----- (0804AA71) --------------------------------------------------------
int sub_804AA71()
{
  int result; // eax

  result = &unk_805B317 - &unk_805B314;
  if ( (unsigned int)(&unk_805B317 - &unk_805B314) > 6 )
    result = 0;
  return result;
}
// 804AA71: could not find valid save-restore pair for ebp

//----- (0804AACF) --------------------------------------------------------
int sub_804AACF()
{
  return nullsub_7();
}
// 804AACF: could not find valid save-restore pair for ebp
// 804AACE: using guessed type int nullsub_7(void);

//----- (0804AB4F) --------------------------------------------------------
int sub_804AB4F()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nWith no FILE, or when FILE is -, read standard input.\n");
  return fputs_unlocked(v1, v0);
}
// 80491E0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804AB7A) --------------------------------------------------------
int sub_804AB7A()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nMandatory arguments to long options are mandatory for short options too.\n");
  return fputs_unlocked(v1, v0);
}
// 80491E0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804ABA5) --------------------------------------------------------
int __cdecl sub_804ABA5(char *s1)
{
  void *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  void *v5; // eax
  char *v6; // eax
  char *v8; // [esp+4h] [ebp-64h]
  char *v9; // [esp+8h] [ebp-60h]
  char *v10; // [esp+1Ch] [ebp-4Ch]
  const char **v11; // [esp+20h] [ebp-48h]
  char *v12; // [esp+24h] [ebp-44h]
  const char *v13; // [esp+28h] [ebp-40h]
  const char *v14; // [esp+2Ch] [ebp-3Ch]
  const char *v15; // [esp+30h] [ebp-38h]
  const char *v16; // [esp+34h] [ebp-34h]
  const char *v17; // [esp+38h] [ebp-30h]
  const char *v18; // [esp+3Ch] [ebp-2Ch]
  const char *v19; // [esp+40h] [ebp-28h]
  const char *v20; // [esp+44h] [ebp-24h]
  const char *v21; // [esp+48h] [ebp-20h]
  const char *v22; // [esp+4Ch] [ebp-1Ch]
  const char *v23; // [esp+50h] [ebp-18h]
  const char *v24; // [esp+54h] [ebp-14h]
  int v25; // [esp+58h] [ebp-10h]
  int v26; // [esp+5Ch] [ebp-Ch]

  v13 = "[";
  v14 = "test invocation";
  v15 = "coreutils";
  v16 = "Multi-call invocation";
  v17 = "sha224sum";
  v18 = "sha2 utilities";
  v19 = "sha256sum";
  v20 = "sha2 utilities";
  v21 = "sha384sum";
  v22 = "sha2 utilities";
  v23 = "sha512sum";
  v24 = "sha2 utilities";
  v25 = 0;
  v26 = 0;
  v10 = s1;
  v11 = &v13;
  dword_805B1AC = (int)&loc_804AC35;
  sub_8054D67();
  do
  {
    v11 += 2;
    if ( !*v11 )
      break;
    v8 = (char *)*v11;
  }
  while ( strcmp(s1, v8) );
  v1 = &loc_804AC79;
  if ( !v11[1] )
    v1 = &loc_804AC82;
  dword_805B238 = (int)v1;
  sub_8054A0F();
  v10 = (char *)v11[1];
  v2 = gettext("\n%s online help: <%s>\n");
  v9 = "http://www.gnu.org/software/coreutils/";
  v8 = "GNU coreutils";
  printf(v2, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  v12 = setlocale(5, 0);
  if ( v12 && strncmp(v12, "en_", 3u) )
  {
    v3 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
    v8 = s1;
    printf(v3, s1);
  }
  v4 = gettext("Full documentation at: <%s%s>\n");
  v9 = s1;
  v8 = "http://www.gnu.org/software/coreutils/";
  printf(v4, "http://www.gnu.org/software/coreutils/", s1);
  v5 = &loc_804AD41;
  if ( v10 != s1 )
    v5 = &loc_804AD48;
  dword_805B288 = (int)v5;
  sub_8054836();
  v6 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  v9 = " invocation";
  v8 = v10;
  return printf(v6, v10, " invocation");
}
// 8054836: using guessed type int sub_8054836(void);
// 8054A0F: using guessed type int sub_8054A0F(void);
// 8054D67: using guessed type int sub_8054D67(void);
// 805B1AC: using guessed type int dword_805B1AC;
// 805B238: using guessed type int dword_805B238;
// 805B288: using guessed type int dword_805B288;

//----- (0804AD72) --------------------------------------------------------
_BOOL4 __cdecl sub_804AD72(int a1)
{
  void *v1; // eax

  v1 = &loc_804ADA0;
  if ( (*(_DWORD *)(a1 + 16) & 0xF000) == 0x8000 )
    v1 = &loc_804ADB2;
  dword_805B238 = (int)v1;
  sub_8054A0F();
  return (*(_DWORD *)(a1 + 16) & 0xF000) == 40960;
}
// 8054A0F: using guessed type int sub_8054A0F(void);
// 805B238: using guessed type int dword_805B238;

//----- (0804ADC3) --------------------------------------------------------
int __cdecl sub_804ADC3(int *a1, __int64 a2)
{
  return sub_804E792(a1, a2 - 1);
}

//----- (0804ADF6) --------------------------------------------------------
void __cdecl __noreturn sub_804ADF6(int status)
{
  void *v1; // eax
  int v2; // ebx
  char *v3; // eax

  v1 = &loc_804AE1E;
  if ( !status )
    v1 = &loc_804AE4B;
  dword_805B1D4 = (int)v1;
  sub_8054C6A();
  v2 = dword_805B92F;
  v3 = gettext("Try '%s --help' for more information.\n");
  fprintf(stderr, v3, v2);
  exit(status);
}
// 8054C6A: using guessed type int sub_8054C6A(void);
// 805B1D4: using guessed type int dword_805B1D4;
// 805B92F: using guessed type int dword_805B92F;

//----- (0804AF34) --------------------------------------------------------
void *__cdecl sub_804AF34(int a1, signed int a2, char a3)
{
  void *result; // eax
  int v4; // [esp+4h] [ebp-24h]
  char v5; // [esp+Ch] [ebp-1Ch]
  void *v6; // [esp+10h] [ebp-18h]
  size_t size; // [esp+14h] [ebp-14h]
  int i; // [esp+18h] [ebp-10h]
  _BYTE *v9; // [esp+1Ch] [ebp-Ch]

  v5 = a3;
  size = a2;
  for ( i = 0; i < a2; ++i )
    size += strlen(*(const char **)(4 * i + a1));
  v6 = sub_8050AEC(size);
  i = 0;
  dword_805B1FC = (int)&loc_804AFF3;
  sub_8054B67();
  do
  {
    v4 = *(_DWORD *)(4 * i + a1);
    v9 = (_BYTE *)stpcpy(v6, v4);
    *(_DWORD *)(a1 + 4 * i) = v6;
    v6 = v9 + 1;
    *v9 = v5;
    ++i;
  }
  while ( i < a2 );
  result = v6;
  *(_DWORD *)(a1 + 4 * a2) = v6;
  return result;
}
// 8049040: using guessed type int __cdecl stpcpy(_DWORD, _DWORD);
// 8054B67: using guessed type int sub_8054B67(void);
// 805B1FC: using guessed type int dword_805B1FC;

//----- (0804B011) --------------------------------------------------------
char *__cdecl sub_804B011(void *s, int a2, size_t n)
{
  return (char *)memchr(s, (char)a2, n) + 1;
}

//----- (0804B042) --------------------------------------------------------
signed __int64 sub_804B042()
{
  signed __int64 result; // rax
  __int64 v1; // rax
  __int64 v2; // [esp+10h] [ebp-78h]
  char v3; // [esp+20h] [ebp-68h]
  __int64 v4; // [esp+4Ch] [ebp-3Ch]

  if ( sub_8054734(0, (int)&v3) )
    return 0x7FFFFFFFFFFFFFFFLL;
  if ( !(unsigned __int8)sub_804AD72((int)&v3) )
    return 0x7FFFFFFFFFFFFFFFLL;
  v2 = v4;
  LODWORD(v1) = lseek64(0, 0, 0, 1);
  if ( v1 >= 0 )
    result = v2 - v1;
  else
    result = 0x7FFFFFFFFFFFFFFFLL;
  return result;
}
// 8049340: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804B0E7) --------------------------------------------------------
int __cdecl sub_804B0E7(FILE *stream, int a2, int a3, int a4, int a5)
{
  int v5; // eax
  unsigned int v6; // edx
  char *v7; // eax
  bool v8; // zf
  void *v9; // eax
  unsigned __int64 v10; // rax
  char *v11; // eax
  void *v12; // eax
  char *v13; // ebx
  int *v14; // eax
  int result; // eax
  int nmemb; // [esp+14h] [ebp-34h]
  int v17; // [esp+18h] [ebp-30h]
  char *ptr; // [esp+1Ch] [ebp-2Ch]
  unsigned __int64 v19; // [esp+20h] [ebp-28h]
  unsigned int v20; // [esp+28h] [ebp-20h]
  char s; // [esp+34h] [ebp-14h]

  v19 = 0LL;
  v5 = 1024;
  if ( (unsigned int)a3 <= 0x400 )
    v5 = a3;
  nmemb = v5;
  v17 = 0;
  ptr = (char *)sub_8050BB1(v5, 0xCu);
  while ( (unsigned int)a3 > v19 )
  {
    v17 = sub_804C836((int)&ptr[12 * v19], stream);
    if ( !v17 )
      break;
    if ( (unsigned int)nmemb <= ++v19 )
    {
      nmemb += 1024;
      ptr = (char *)sub_8050A0D(ptr, nmemb, 12);
      memset(&ptr[12 * v19], 0, 0x3000u);
    }
  }
  if ( v17 )
  {
    sub_804C7F1(&s);
    do
    {
      v20 = sub_804ADC3((int *)a4, v19 + 1);
      if ( v6 > 0 || a3 <= v20 )
        v7 = &s;
      else
        v7 = &ptr[12 * v20];
      v8 = sub_804C836((int)v7, stream) == 0;
      v9 = &loc_804B293;
      if ( v8 )
        v9 = &loc_804B2B3;
      dword_805B1FC = (int)v9;
      sub_8054B67();
      v10 = v19++;
    }
    while ( v10 );
    if ( !v19 )
    {
      v11 = gettext("too many input lines");
      error(1, 75, v11);
    }
    sub_804C982((int)&s);
  }
  v8 = ferror_unlocked(stream) == 0;
  v12 = &loc_804B316;
  if ( v8 )
    v12 = &loc_804B33F;
  dword_805B260 = (int)v12;
  sub_805492F();
  v13 = gettext("read error");
  v14 = __errno_location();
  error(1, *v14, v13);
  *(_DWORD *)a5 = ptr;
  result = a3;
  if ( (unsigned int)a3 > v19 )
    result = v19;
  return result;
}
// 805492F: using guessed type int sub_805492F(void);
// 8054B67: using guessed type int sub_8054B67(void);
// 805B1FC: using guessed type int dword_805B1FC;
// 805B260: using guessed type int dword_805B260;

//----- (0804B36B) --------------------------------------------------------
int __cdecl sub_804B36B(unsigned int a1, int a2, int a3)
{
  size_t v3; // eax
  unsigned int i; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; i < a1; ++i )
  {
    v6 = 12 * *(_DWORD *)(4 * i + a3) + a2;
    v3 = fwrite_unlocked(*(const void **)(v6 + 8), 1u, *(_DWORD *)(v6 + 4), stdout);
    if ( v3 != *(_DWORD *)(v6 + 4) )
    {
      dword_805B238 = (int)&locret_804B3FF;
      sub_8054A0F();
    }
  }
  return 0;
}
// 8054A0F: using guessed type int sub_8054A0F(void);
// 805B238: using guessed type int dword_805B238;

//----- (0804B401) --------------------------------------------------------
unsigned int __cdecl sub_804B401(FILE *stream, int a2, int a3)
{
  char *v3; // ebx
  int *v4; // eax
  int v5; // eax
  void **v6; // ebx
  char v8; // [esp+Ch] [ebp-2Ch]
  int v9; // [esp+14h] [ebp-24h]
  void *s; // [esp+18h] [ebp-20h]
  unsigned int v11; // [esp+1Ch] [ebp-1Ch]
  unsigned int v12; // [esp+20h] [ebp-18h]
  _BYTE *v13; // [esp+24h] [ebp-14h]
  unsigned int v14; // [esp+28h] [ebp-10h]
  _DWORD *v15; // [esp+2Ch] [ebp-Ch]

  v8 = a2;
  v13 = 0;
  v13 = sub_804FFAE(stream, (int)&v9);
  if ( !v13 )
  {
    v3 = gettext("read error");
    v4 = __errno_location();
    error(1, *v4, v3);
  }
  if ( v9 && v13[v9 - 1] != v8 )
  {
    v5 = v9++;
    v13[v5] = v8;
  }
  v14 = (unsigned int)&v13[v9];
  v11 = 0;
  s = v13;
  dword_805B1D4 = (int)&loc_804B4E0;
  sub_8054C6A();
  do
  {
    ++v11;
    s = sub_804B011(s, v8, v14 - (_DWORD)s);
  }
  while ( (unsigned int)s < v14 );
  v15 = sub_80509DF(v11 + 1, 4u);
  *(_DWORD *)a3 = v15;
  s = v13;
  *v15 = v13;
  v12 = 1;
  dword_805B1E8 = (int)&loc_804B574;
  sub_8054BD7();
  do
  {
    v6 = (void **)&v15[v12];
    s = sub_804B011(s, v8, v14 - (_DWORD)s);
    *v6 = s;
    ++v12;
  }
  while ( v12 <= v11 );
  return v11;
}
// 8054BD7: using guessed type int sub_8054BD7(void);
// 8054C6A: using guessed type int sub_8054C6A(void);
// 805B1D4: using guessed type int dword_805B1D4;
// 805B1E8: using guessed type int dword_805B1E8;

//----- (0804B585) --------------------------------------------------------
signed int __cdecl sub_804B585(unsigned int a1, int a2, int a3)
{
  int v3; // ST18_4
  int n; // ST1C_4
  unsigned int i; // [esp+14h] [ebp-14h]

  for ( i = 0; i < a1; ++i )
  {
    v3 = 4 * *(_DWORD *)(4 * i + a3) + a2;
    n = *(_DWORD *)(v3 + 4) - *(_DWORD *)v3;
    if ( fwrite_unlocked(*(const void **)v3, 1u, n, stdout) != n )
      return -1;
  }
  return 0;
}

//----- (0804B60F) --------------------------------------------------------
int __cdecl sub_804B60F(int a1, int a2, int a3, char a4)
{
  char v5; // [esp+Ch] [ebp-1Ch]
  int v6; // [esp+18h] [ebp-10h]

  v5 = a4;
  v6 = 0;
  dword_805B298 = (int (*)(void))&loc_804B69B;
  return ((int (*)(void))loc_804B69B)();
}
// 805B298: using guessed type int (*dword_805B298)(void);

//----- (0804B635) --------------------------------------------------------
#error "804B664: call analysis failed (funcsize=27)"

//----- (0804B697) --------------------------------------------------------
#error "804B6BB: positive sp value has been found (funcsize=9)"

//----- (0804B6BC) --------------------------------------------------------
int __cdecl sub_804B6BC(int a1, int a2, int a3, int a4, char a5)
{
  char v6; // [esp+Ch] [ebp-1Ch]
  int v7; // [esp+10h] [ebp-18h]
  int v8; // [esp+18h] [ebp-10h]
  int v9; // [esp+1Ch] [ebp-Ch]

  v6 = a5;
  v8 = a4 - a3 + 1;
  v9 = 0;
  v7 = 0;
  dword_805B298 = (int (*)(void))&loc_804B769;
  return ((int (*)(void))loc_804B769)();
}
// 805B298: using guessed type int (*dword_805B298)(void);

//----- (0804B6F9) --------------------------------------------------------
#error "804B70D: call analysis failed (funcsize=30)"

//----- (0804B765) --------------------------------------------------------
#error "804B789: positive sp value has been found (funcsize=9)"

//----- (0804B78A) --------------------------------------------------------
signed int __cdecl sub_804B78A(int *a1, unsigned int a2, int a3, unsigned int a4)
{
  int v4; // ST28_4
  int n; // ST24_4
  unsigned int i; // [esp+1Ch] [ebp-1Ch]

  for ( i = 0; i < a2; ++i )
  {
    v4 = sub_804ADC3(a1, a4);
    n = *(_DWORD *)(4 * v4 + a3 + 4) - *(_DWORD *)(4 * v4 + a3);
    if ( fwrite_unlocked(*(const void **)(4 * v4 + a3), 1u, n, stdout) != n )
      return -1;
  }
  return 0;
}

//----- (0804B82B) --------------------------------------------------------
void __cdecl __noreturn main(int argc, char **argv)
{
  sub_804C998((int)*argv);
}

//----- (0804C424) --------------------------------------------------------
int sub_804C424()
{
  void *v0; // eax
  void *v1; // ebx
  int *v2; // eax
  int result; // eax
  char *v4; // [esp+2Ch] [ebp-Ch]

  if ( sub_8051C03(stdout) && (byte_805B92B != 1 || *__errno_location() != 32) )
  {
    v4 = gettext("write error");
    v0 = &loc_804C48F;
    if ( !dword_805B927 )
      v0 = &loc_804C4CA;
    dword_805B1FC = (int)v0;
    sub_8054B67();
    v1 = sub_804E45D((char *)dword_805B927);
    v2 = __errno_location();
    error(0, *v2, "%s: %s", v1, v4);
    _exit(status);
  }
  result = sub_8051C03(stderr);
  if ( result )
    _exit(status);
  return result;
}
// 8054B67: using guessed type int sub_8054B67(void);
// 805B1FC: using guessed type int dword_805B1FC;
// 805B927: using guessed type int dword_805B927;
// 805B92B: using guessed type char byte_805B92B;

//----- (0804C521) --------------------------------------------------------
int __cdecl sub_804C521(int a1, int a2, int a3, int a4, int a5, int a6)
{
  return posix_fadvise64(a1, a2, a3, a4, a5, a6);
}
// 8049360: using guessed type int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804C572) --------------------------------------------------------
void __cdecl sub_804C572(FILE *stream, int a2)
{
  int v2; // eax

  if ( stream )
  {
    v2 = fileno(stream);
    sub_804C521(v2, 0, 0, 0, 0, a2);
  }
}

//----- (0804C5BA) --------------------------------------------------------
signed int __cdecl sub_804C5BA(int a1)
{
  int fd; // [esp+1Ch] [ebp-Ch]

  fd = open64("/dev/null", 0);
  if ( fd == a1 )
    return 1;
  if ( fd >= 0 )
  {
    close(fd);
    *__errno_location() = 9;
  }
  return 0;
}
// 8048F50: using guessed type int __cdecl open64(_DWORD, _DWORD);

//----- (0804C609) --------------------------------------------------------
FILE *__cdecl sub_804C609(int a1, int a2, FILE *stream)
{
  int v3; // eax
  bool v4; // zf
  void *v5; // eax
  int v6; // edx
  int v7; // ecx
  int v8; // edx
  int v9; // ecx
  void *v10; // eax
  void *v11; // eax
  void *v12; // eax
  char v14; // [esp+19h] [ebp-Fh]
  char v15; // [esp+1Ah] [ebp-Eh]
  char v16; // [esp+1Bh] [ebp-Dh]
  int v17; // [esp+1Ch] [ebp-Ch]
  FILE *streama; // [esp+38h] [ebp+10h]

  v14 = 0;
  v15 = 0;
  v16 = 0;
  v3 = fileno(stream);
  if ( v3 != 1 )
  {
    if ( v3 != 2 )
    {
      if ( !v3 )
        goto LABEL_11;
      if ( dup2(2, 2) != 2 )
        v16 = 1;
    }
    if ( dup2(1, 1) != 1 )
      v15 = 1;
  }
  v4 = dup2(0, 0) == 0;
  v5 = &loc_804C69F;
  if ( v4 )
    v5 = &loc_804C6A5;
  dword_805B260 = (int)v5;
  sub_805492F();
  v14 = 1;
LABEL_11:
  if ( v14 && (unsigned __int8)sub_804C5BA(0) ^ 1 )
  {
    stream = 0;
    dword_805B274 = (int)&loc_804C76A;
    sub_80548A4(v7, v6);
  }
  if ( v15 && (unsigned __int8)sub_804C5BA(1) ^ 1 )
  {
    stream = 0;
    dword_805B148 = (int)&loc_804C76A;
    sub_8054FB6(v9, v8);
  }
  v10 = &loc_804C732;
  if ( !v16 )
    v10 = &loc_804C74E;
  dword_805B15C = (int)v10;
  sub_8054F2B();
  if ( (unsigned __int8)sub_804C5BA(2) ^ 1 )
    streama = 0;
  else
    streama = (FILE *)freopen64(a1, a2, stream);
  v17 = *__errno_location();
  if ( v16 )
    close(2);
  v11 = &loc_804C7A5;
  if ( !v15 )
    v11 = &loc_804C7B1;
  dword_805B1D4 = (int)v11;
  sub_8054C6A();
  close(1);
  if ( v14 )
    close(0);
  v12 = &loc_804C7E2;
  if ( streama )
    v12 = &loc_804C7EC;
  dword_805B1C0 = (int)v12;
  sub_8054CDA();
  *__errno_location() = v17;
  return streama;
}
// 804C609: could not find valid save-restore pair for ebx
// 8048F20: using guessed type int __cdecl freopen64(_DWORD, _DWORD, _DWORD);
// 80548A4: using guessed type int __fastcall sub_80548A4(_DWORD, _DWORD);
// 805492F: using guessed type int sub_805492F(void);
// 8054C6A: using guessed type int sub_8054C6A(void);
// 8054CDA: using guessed type int sub_8054CDA(void);
// 8054F2B: using guessed type int sub_8054F2B(void);
// 8054FB6: using guessed type int __fastcall sub_8054FB6(_DWORD, _DWORD);
// 805B148: using guessed type int dword_805B148;
// 805B15C: using guessed type int dword_805B15C;
// 805B1C0: using guessed type int dword_805B1C0;
// 805B1D4: using guessed type int dword_805B1D4;
// 805B260: using guessed type int dword_805B260;
// 805B274: using guessed type int dword_805B274;

//----- (0804C7F1) --------------------------------------------------------
void *__cdecl sub_804C7F1(void *s)
{
  return memset(s, 0, 0xCu);
}

//----- (0804C836) --------------------------------------------------------
int __cdecl sub_804C836(int a1, FILE *stream)
{
  int v2; // ST2C_4
  int v3; // ST30_4
  bool v4; // zf
  void *v5; // eax

  v2 = *(_DWORD *)(a1 + 8);
  v3 = *(_DWORD *)a1 + *(_DWORD *)(a1 + 8);
  v4 = feof_unlocked(stream) == 0;
  v5 = &loc_804C889;
  if ( v4 )
    v5 = &loc_804C893;
  dword_805B260 = (int)v5;
  sub_805492F();
  return 0;
}
// 805492F: using guessed type int sub_805492F(void);
// 805B260: using guessed type int dword_805B260;

//----- (0804C982) --------------------------------------------------------
void __cdecl sub_804C982(int a1)
{
  free(*(void **)(a1 + 8));
}

//----- (0804C998) --------------------------------------------------------
void __cdecl __noreturn sub_804C998(int a1)
{
  int (__cdecl *v1)(int, size_t); // eax

  v1 = (int (__cdecl *)(int, size_t))&loc_804C9BD;
  if ( a1 )
    v1 = sub_804C9E7;
  dword_805B260 = (int)v1;
  sub_805492F();
  fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
  abort();
}
// 805492F: using guessed type int sub_805492F(void);
// 805B260: using guessed type int dword_805B260;

//----- (0804C9E7) --------------------------------------------------------
#error "804CAD0: positive sp value has been found (funcsize=66)"

//----- (0804CBA0) --------------------------------------------------------
int __cdecl sub_804CBA0(int *a1, unsigned __int8 a2, char a3)
{
  int *v3; // eax
  int v4; // ST10_4

  if ( a1 )
    v3 = a1;
  else
    v3 = &dword_805B937;
  v4 = ((unsigned int)v3[(a2 >> 5) + 2] >> (a2 & 0x1F)) & 1;
  v3[(a2 >> 5) + 2] ^= (v4 ^ a3 & 1) << (a2 & 0x1F);
  return v4;
}
// 805B937: using guessed type int dword_805B937;

//----- (0804CC4A) --------------------------------------------------------
void __cdecl __noreturn sub_804CC4A(int *a1, int a2, int a3)
{
  int (*v3)(); // eax

  if ( !a1 )
    a1 = &dword_805B937;
  *a1 = 10;
  if ( a2 )
  {
    v3 = (int (*)())&loc_804CC8B;
    if ( a3 )
      v3 = sub_804CC90;
    dword_805B1FC = (int)v3;
    sub_8054B67();
  }
  abort();
}
// 804CC90: using guessed type int sub_804CC90();
// 8054B67: using guessed type int sub_8054B67(void);
// 805B1FC: using guessed type int dword_805B1FC;
// 805B937: using guessed type int dword_805B937;

//----- (0804CC90) --------------------------------------------------------
#error "804CCA3: positive sp value has been found (funcsize=0)"

//----- (0804CCA4) --------------------------------------------------------
_DWORD *__userpurge sub_804CCA4@<eax>(_DWORD *a1, int a2)
{
  int v3; // [esp+0h] [ebp-38h]
  int v4; // [esp+4h] [ebp-34h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]

  memset(&v3, 0, 0x30u);
  if ( a2 == 10 )
    abort();
  *a1 = a2;
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = v6;
  a1[4] = v7;
  a1[5] = v8;
  a1[6] = v9;
  a1[7] = v10;
  a1[8] = v11;
  a1[9] = v12;
  a1[10] = v13;
  a1[11] = v14;
  return a1;
}

//----- (0804CD26) --------------------------------------------------------
const char *__cdecl sub_804CD26(char *msgid, int a2)
{
  const char *result; // eax
  void *v3; // eax
  int v4; // edx
  int v5; // ecx
  char *v6; // [esp+18h] [ebp-10h]
  unsigned __int8 *v7; // [esp+1Ch] [ebp-Ch]

  v6 = gettext(msgid);
  if ( v6 != msgid )
    return v6;
  v7 = (unsigned __int8 *)sub_8053B5A();
  if ( sub_8051B9E(v7, "UTF-8") )
  {
    if ( sub_8051B9E(v7, "GB18030") )
    {
      v3 = &loc_804CDCF;
      if ( a2 != 9 )
        v3 = &loc_804CDEB;
      dword_805B1FC = (int)v3;
      sub_8054B67();
      dword_805B210 = (int)&locret_804CDF0;
      sub_8054AF3(v5, v4);
      result = "'";
    }
    else if ( *msgid == 96 )
    {
      result = (const char *)&unk_805599E;
    }
    else
    {
      result = (const char *)&unk_80559A2;
    }
  }
  else if ( *msgid == 96 )
  {
    result = (const char *)&unk_805598E;
  }
  else
  {
    result = (const char *)&unk_8055992;
  }
  return result;
}
// 8054AF3: using guessed type int __fastcall sub_8054AF3(_DWORD, _DWORD);
// 8054B67: using guessed type int sub_8054B67(void);
// 805B1FC: using guessed type int dword_805B1FC;
// 805B210: using guessed type int dword_805B210;

//----- (0804CDF2) --------------------------------------------------------
int __cdecl sub_804CDF2(int a1, unsigned int a2, char *a3, size_t a4, signed int a5, int a6, int a7, char *a8, char *a9)
{
  void *v9; // eax
  int v10; // edx
  int v11; // ecx
  void *v12; // eax
  void *v13; // eax
  int v14; // ecx
  void *v15; // eax
  size_t v16; // eax
  int v17; // edx
  void *v18; // eax
  void *v19; // eax
  void *v20; // eax
  void *v21; // eax
  int v22; // edx
  int v23; // ecx
  void *v24; // eax
  void *v25; // eax
  void *v26; // eax
  void *v27; // eax
  void *v28; // eax
  void *v29; // eax
  size_t v30; // eax
  bool v31; // zf
  void *v32; // eax
  void *v33; // eax
  void *v34; // eax
  void *v35; // eax
  void *v36; // eax
  bool v37; // al
  void *v38; // eax
  int v39; // edx
  int v40; // ecx
  void *v41; // eax
  void *v42; // eax
  int result; // eax
  void *v44; // eax
  size_t v45; // [esp-8h] [ebp-90h]
  char *v46; // [esp+4h] [ebp-84h]
  size_t v47; // [esp+8h] [ebp-80h]
  char *v48; // [esp+2Ch] [ebp-5Ch]
  char *v49; // [esp+30h] [ebp-58h]
  int v50; // [esp+34h] [ebp-54h]
  char *v51; // [esp+38h] [ebp-50h]
  int v52; // [esp+3Ch] [ebp-4Ch]
  char v53; // [esp+40h] [ebp-48h]
  bool v54; // [esp+41h] [ebp-47h]
  char v55; // [esp+42h] [ebp-46h]
  char v56; // [esp+43h] [ebp-45h]
  char v57; // [esp+44h] [ebp-44h]
  unsigned __int8 v58; // [esp+45h] [ebp-43h]
  char v59; // [esp+46h] [ebp-42h]
  char v60; // [esp+47h] [ebp-41h]
  char v61; // [esp+48h] [ebp-40h]
  bool v62; // [esp+49h] [ebp-3Fh]
  bool v63; // [esp+4Ah] [ebp-3Eh]
  bool v64; // [esp+4Bh] [ebp-3Dh]
  wint_t wc; // [esp+4Ch] [ebp-3Ch]
  int v66; // [esp+50h] [ebp-38h]
  unsigned int v67; // [esp+54h] [ebp-34h]
  unsigned int v68; // [esp+58h] [ebp-30h]
  char *s; // [esp+5Ch] [ebp-2Ch]
  size_t n; // [esp+60h] [ebp-28h]
  unsigned int v71; // [esp+64h] [ebp-24h]
  size_t v72; // [esp+6Ch] [ebp-1Ch]
  unsigned int v73; // [esp+70h] [ebp-18h]
  mbstate_t ps; // [esp+74h] [ebp-14h]
  unsigned int v75; // [esp+7Ch] [ebp-Ch]

  v52 = a1;
  v51 = a3;
  v50 = a7;
  v49 = a8;
  v48 = a9;
  v75 = __readgsdword(0x14u);
  v67 = 0;
  v68 = 0;
  s = 0;
  n = 0;
  v53 = 0;
  v64 = __ctype_get_mb_cur_max() == 1;
  v54 = (a6 & 2) != 0;
  v55 = 0;
  v56 = 0;
  v57 = 1;
  switch ( a5 )
  {
    case 0:
      v54 = 0;
      break;
    case 1:
      goto LABEL_19;
    case 2:
      goto LABEL_23;
    case 3:
      goto LABEL_18;
    case 4:
      goto LABEL_20;
    case 5:
      goto LABEL_3;
    case 6:
      a5 = 5;
      v54 = 1;
LABEL_3:
      if ( v54 != 1 )
      {
        if ( v67 < a2 )
          *(_BYTE *)(v52 + v67) = 34;
        ++v67;
      }
      v53 = 1;
      s = (char *)&unk_80559A5;
      n = 1;
      break;
    case 7:
      v53 = 1;
      v54 = 0;
      break;
    case 8:
    case 9:
    case 10:
      v9 = &loc_804CEF4;
      if ( a5 == 10 )
        v9 = &loc_804CF20;
      dword_805B198 = (int)v9;
      sub_8054DDB();
      v49 = (char *)sub_804CD26("`", a5);
      v48 = (char *)sub_804CD26("'", a5);
      if ( v54 != 1 )
      {
        for ( s = v49; *s; ++s )
        {
          if ( v67 < a2 )
            *(_BYTE *)(v67 + v52) = *s;
          ++v67;
        }
      }
      v53 = 1;
      s = v48;
      n = strlen(v48);
      dword_805B148 = (int)&loc_804D000;
      sub_8054FB6(v11, v10);
LABEL_18:
      v53 = 1;
LABEL_19:
      v54 = 1;
LABEL_20:
      v12 = &loc_804CFB8;
      if ( v54 == 1 )
        v12 = &loc_804CFBC;
      dword_805B1E8 = (int)v12;
      sub_8054BD7();
      v53 = 1;
LABEL_23:
      a5 = 2;
      if ( v54 != 1 )
      {
        if ( v67 < a2 )
          *(_BYTE *)(v52 + v67) = 39;
        ++v67;
      }
      s = "'";
      n = 1;
      break;
    default:
      abort();
      return result;
  }
  v66 = 0;
LABEL_185:
  if ( a4 == -1 )
    v37 = v51[v66] != 0;
  else
    v37 = v66 != a4;
  if ( !v37 )
  {
    v38 = &loc_804DB82;
    if ( v67 )
      v38 = &loc_804DBAC;
    dword_805B24C = (int)v38;
    sub_80549A1();
    if ( a5 == 2 )
    {
      v41 = &loc_804DBA7;
      if ( !v54 )
        v41 = &loc_804DBAC;
      dword_805B1AC = (int)v41;
      sub_8054D67();
      goto LABEL_213;
    }
    v42 = &loc_804DBCB;
    if ( a5 != 2 )
      v42 = &loc_804DC5F;
    dword_805B210 = (int)v42;
    sub_8054AF3(v40, v39);
    if ( v54 != 1 && v56 )
    {
      if ( v57 )
        return sub_804CDF2(v52, v68, v51, a4, 5, a6, v50, v49, v48);
      if ( !a2 && v68 )
      {
        a2 = v68;
        v67 = 0;
        dword_805B198 = (int)&loc_804CE6B;
        sub_8054DDB();
      }
    }
    if ( s && v54 != 1 )
    {
      dword_805B184 = (int)&loc_804DCA7;
      sub_8054E51();
      do
      {
        if ( v67 < a2 )
          *(_BYTE *)(v67 + v52) = *s;
        ++v67;
        ++s;
      }
      while ( *s );
    }
    if ( v67 < a2 )
      *(_BYTE *)(v52 + v67) = 0;
    dword_805B238 = (int)&loc_804DD53;
    sub_8054A0F();
    goto LABEL_213;
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  v13 = &loc_804D037;
  if ( !v53 )
    v13 = &loc_804D0BC;
  dword_805B238 = (int)v13;
  sub_8054A0F();
  if ( a5 != 2 && n )
  {
    v45 = v66 + n;
    v15 = &loc_804D06B;
    if ( a4 != -1 )
      v15 = &loc_804D084;
    dword_805B210 = (int)v15;
    sub_8054AF3(v14, v66);
    if ( n <= 1 )
    {
      v16 = a4;
    }
    else
    {
      v16 = strlen(v51);
      a4 = v16;
    }
    if ( v45 <= v16 && !memcmp(&v51[v66], s, n) )
    {
      if ( v54 )
        goto LABEL_213;
      v60 = 1;
    }
  }
  v17 = (int)v51;
  v58 = v51[v66];
  switch ( v58 )
  {
    case 0u:
      if ( v53 )
      {
        if ( v54 )
          goto LABEL_213;
        v61 = 1;
        if ( a5 == 2 )
        {
          v18 = &loc_804D123;
          if ( v55 == 1 )
            v18 = &loc_804D16C;
          dword_805B288 = (int)v18;
          sub_8054836();
          if ( v67 < a2 )
            *(_BYTE *)(v52 + v67) = 39;
          if ( ++v67 < a2 )
            *(_BYTE *)(v52 + v67) = 36;
          if ( ++v67 < a2 )
            *(_BYTE *)(v52 + v67) = 39;
          ++v67;
          v55 = 1;
        }
        if ( v67 < a2 )
          *(_BYTE *)(v52 + v67) = 92;
        ++v67;
        if ( a5 != 2 && v66 + 1 < a4 && v51[v66 + 1] > 47 && v51[v66 + 1] <= 57 )
        {
          if ( v67 < a2 )
            *(_BYTE *)(v52 + v67) = 48;
          if ( ++v67 < a2 )
            *(_BYTE *)(v52 + v67) = 48;
          ++v67;
        }
        v58 = 48;
        dword_805B1FC = (int)&loc_804D229;
        sub_8054B67();
      }
      v19 = &loc_804D224;
      if ( !(a6 & 1) )
        v19 = &loc_804D229;
      dword_805B1FC = (int)v19;
      sub_8054B67();
      goto LABEL_184;
    case 7u:
      v59 = 97;
      goto LABEL_111;
    case 8u:
      v59 = 98;
      goto LABEL_111;
    case 9u:
      v59 = 116;
      goto LABEL_109;
    case 0xAu:
      v59 = 110;
      goto LABEL_109;
    case 0xBu:
      v59 = 118;
      goto LABEL_111;
    case 0xCu:
      v59 = 102;
      goto LABEL_111;
    case 0xDu:
      v59 = 114;
LABEL_109:
      if ( a5 == 2 && v54 )
        goto LABEL_213;
LABEL_111:
      if ( v53 )
      {
        v58 = v59;
        dword_805B1FC = (int)&loc_804DA18;
        sub_8054B67();
      }
      goto LABEL_161;
    case 0x20u:
      v62 = 1;
      goto LABEL_121;
    case 0x21u:
    case 0x22u:
    case 0x24u:
    case 0x26u:
    case 0x28u:
    case 0x29u:
    case 0x2Au:
    case 0x3Bu:
    case 0x3Cu:
    case 0x3Du:
    case 0x3Eu:
    case 0x5Bu:
    case 0x5Eu:
    case 0x60u:
    case 0x7Cu:
LABEL_121:
      v27 = &loc_804D4E0;
      if ( a5 != 2 )
        v27 = &loc_804D4EB;
      dword_805B288 = (int)v27;
      sub_8054836();
      if ( !v54 )
        goto LABEL_161;
      goto LABEL_213;
    case 0x23u:
    case 0x7Eu:
      goto LABEL_117;
    case 0x25u:
    case 0x2Bu:
    case 0x2Cu:
    case 0x2Du:
    case 0x2Eu:
    case 0x2Fu:
    case 0x30u:
    case 0x31u:
    case 0x32u:
    case 0x33u:
    case 0x34u:
    case 0x35u:
    case 0x36u:
    case 0x37u:
    case 0x38u:
    case 0x39u:
    case 0x3Au:
    case 0x41u:
    case 0x42u:
    case 0x43u:
    case 0x44u:
    case 0x45u:
    case 0x46u:
    case 0x47u:
    case 0x48u:
    case 0x49u:
    case 0x4Au:
    case 0x4Bu:
    case 0x4Cu:
    case 0x4Du:
    case 0x4Eu:
    case 0x4Fu:
    case 0x50u:
    case 0x51u:
    case 0x52u:
    case 0x53u:
    case 0x54u:
    case 0x55u:
    case 0x56u:
    case 0x57u:
    case 0x58u:
    case 0x59u:
    case 0x5Au:
    case 0x5Du:
    case 0x5Fu:
    case 0x61u:
    case 0x62u:
    case 0x63u:
    case 0x64u:
    case 0x65u:
    case 0x66u:
    case 0x67u:
    case 0x68u:
    case 0x69u:
    case 0x6Au:
    case 0x6Bu:
    case 0x6Cu:
    case 0x6Du:
    case 0x6Eu:
    case 0x6Fu:
    case 0x70u:
    case 0x71u:
    case 0x72u:
    case 0x73u:
    case 0x74u:
    case 0x75u:
    case 0x76u:
    case 0x77u:
    case 0x78u:
    case 0x79u:
    case 0x7Au:
      v62 = 1;
      goto LABEL_161;
    case 0x27u:
      v56 = 1;
      v62 = 1;
      if ( a5 != 2 )
        goto LABEL_161;
      v28 = &loc_804D521;
      if ( !v54 )
        v28 = &loc_804D526;
      dword_805B288 = (int)v28;
      sub_8054836();
      goto LABEL_213;
    case 0x3Fu:
      if ( a5 == 2 )
      {
        if ( v54 )
          goto LABEL_213;
        dword_805B184 = (int)&loc_804D34B;
        sub_8054E51();
      }
      else if ( a5 != 5 )
      {
        goto LABEL_161;
      }
      if ( a6 & 4 )
      {
        if ( v66 + 2 < a4 )
        {
          v17 = v66 + 1;
          if ( v51[v66 + 1] == 63 )
          {
            v17 = v66 + 2;
            switch ( v51[v66 + 2] )
            {
              case 33:
              case 39:
              case 40:
              case 41:
              case 45:
              case 47:
              case 60:
              case 61:
              case 62:
                if ( v54 )
                  goto LABEL_213;
                v17 = v66 + 2;
                v58 = v51[v66 + 2];
                v66 += 2;
                if ( v67 < a2 )
                {
                  v17 = v52;
                  *(_BYTE *)(v52 + v67) = 63;
                }
                if ( ++v67 < a2 )
                {
                  v17 = v52;
                  *(_BYTE *)(v52 + v67) = 34;
                }
                if ( ++v67 < a2 )
                {
                  v17 = v52;
                  *(_BYTE *)(v52 + v67) = 34;
                }
                if ( ++v67 < a2 )
                {
                  v17 = v52;
                  *(_BYTE *)(v52 + v67) = 63;
                }
                ++v67;
                break;
              default:
                break;
            }
          }
        }
      }
LABEL_161:
      if ( v53 == 1 )
      {
        v34 = &loc_804D9CB;
        if ( a5 != 2 )
          v34 = &loc_804D9D6;
        dword_805B238 = (int)v34;
        sub_8054A0F();
      }
      if ( v54 != 1 || !v50 || (v14 = v58 & 0x1F, v17 = *(_DWORD *)(4 * (v58 >> 5) + v50) >> v14, !(v17 & 1)) )
      {
        if ( v60 != 1 )
          goto LABEL_172;
      }
      v35 = &loc_804DA37;
      if ( !v54 )
        v35 = &loc_804DA3C;
      dword_805B210 = (int)v35;
      sub_8054AF3(v14, v17);
      goto LABEL_213;
    case 0x5Cu:
      v59 = v58;
      if ( a5 != 2 )
        goto LABEL_102;
      if ( v54 )
        goto LABEL_213;
      dword_805B238 = (int)&loc_804DAB1;
      sub_8054A0F();
LABEL_102:
      v20 = &loc_804D3DD;
      if ( !v53 )
        v20 = &loc_804D420;
      dword_805B260 = (int)v20;
      sub_805492F();
      v21 = &loc_804D3FC;
      if ( !v54 )
        v21 = &loc_804D420;
      dword_805B1C0 = (int)v21;
      sub_8054CDA();
      v24 = &loc_804D41B;
      if ( !n )
        v24 = &loc_804D420;
      dword_805B148 = (int)v24;
      sub_8054FB6(v23, v22);
      goto LABEL_172;
    case 0x7Bu:
    case 0x7Du:
      v25 = &loc_804D479;
      if ( a4 != -1 )
        v25 = &loc_804D489;
      dword_805B1AC = (int)v25;
      sub_8054D67();
      if ( !v51[1] )
      {
LABEL_117:
        v26 = &loc_804D4B8;
        if ( !v66 )
          v26 = &loc_804D4BD;
        dword_805B210 = (int)v26;
        sub_8054AF3(v14, v17);
      }
      goto LABEL_161;
    default:
      v29 = &loc_804D5D3;
      if ( !v64 )
        v29 = &loc_804D613;
      dword_805B1D4 = (int)v29;
      sub_8054C6A();
      v71 = 1;
      v63 = ((*__ctype_b_loc())[v58] & 0x4000) != 0;
      dword_805B1E8 = (int)&loc_804D795;
      sub_8054BD7();
      memset(&ps, 0, 8u);
      v71 = 0;
      v63 = 1;
      if ( a4 == -1 )
        a4 = strlen(v51);
      v47 = a4 - (v71 + v66);
      v46 = &v51[v71 + v66];
      v30 = sub_8051B13((wchar_t *)&wc, v46, v47, &ps);
      v72 = v30;
      v31 = v30 == 0;
      v32 = &loc_804D6A5;
      if ( !v31 )
        v32 = &loc_804D6AA;
      dword_805B170 = (int)v32;
      sub_8054EBD();
      v62 = v63;
      if ( v71 <= 1 && (!v53 || v63 == 1) )
        goto LABEL_161;
      v73 = v66 + v71;
      while ( 2 )
      {
        if ( !v53 || v63 == 1 )
        {
          if ( v60 )
          {
            if ( v67 < a2 )
              *(_BYTE *)(v52 + v67) = 92;
            ++v67;
            v60 = 0;
          }
          if ( v66 + 1 < v73 )
          {
            if ( v55 && v61 != 1 )
            {
              if ( v67 < a2 )
                *(_BYTE *)(v52 + v67) = 39;
              if ( ++v67 < a2 )
                *(_BYTE *)(v52 + v67) = 39;
              ++v67;
              v55 = 0;
            }
            if ( v67 < a2 )
              *(_BYTE *)(v67 + v52) = v58;
            ++v67;
            v58 = v51[++v66];
            continue;
          }
LABEL_172:
          v36 = &loc_804DAD0;
          if ( !v55 )
            v36 = &loc_804DB0D;
          dword_805B238 = (int)v36;
          sub_8054A0F();
          if ( v61 != 1 )
          {
            if ( v67 < a2 )
              *(_BYTE *)(v52 + v67) = 39;
            if ( ++v67 < a2 )
              *(_BYTE *)(v52 + v67) = 39;
            ++v67;
            v55 = 0;
          }
          if ( v67 < a2 )
            *(_BYTE *)(v67 + v52) = v58;
          ++v67;
          if ( v62 != 1 )
            v57 = 0;
LABEL_184:
          ++v66;
          goto LABEL_185;
        }
        break;
      }
      v33 = &loc_804D7FE;
      if ( !v54 )
        v33 = &loc_804D803;
      dword_805B288 = (int)v33;
      sub_8054836();
LABEL_213:
      v44 = &loc_804DCFD;
      if ( a5 != 2 )
        v44 = &loc_804DD0A;
      dword_805B1E8 = (int)v44;
      sub_8054BD7();
      if ( v53 )
        a5 = 4;
      return sub_804CDF2(v52, a2, v51, a4, a5, a6 & 0xFFFFFFFD, 0, v49, v48);
  }
}
// 8054836: using guessed type int sub_8054836(void);
// 805492F: using guessed type int sub_805492F(void);
// 80549A1: using guessed type int sub_80549A1(void);
// 8054A0F: using guessed type int sub_8054A0F(void);
// 8054AF3: using guessed type int __fastcall sub_8054AF3(_DWORD, _DWORD);
// 8054B67: using guessed type int sub_8054B67(void);
// 8054BD7: using guessed type int sub_8054BD7(void);
// 8054C6A: using guessed type int sub_8054C6A(void);
// 8054CDA: using guessed type int sub_8054CDA(void);
// 8054D67: using guessed type int sub_8054D67(void);
// 8054DDB: using guessed type int sub_8054DDB(void);
// 8054E51: using guessed type int sub_8054E51(void);
// 8054EBD: using guessed type int sub_8054EBD(void);
// 8054FB6: using guessed type int __fastcall sub_8054FB6(_DWORD, _DWORD);
// 805B148: using guessed type int dword_805B148;
// 805B170: using guessed type int dword_805B170;
// 805B184: using guessed type int dword_805B184;
// 805B198: using guessed type int dword_805B198;
// 805B1AC: using guessed type int dword_805B1AC;
// 805B1C0: using guessed type int dword_805B1C0;
// 805B1D4: using guessed type int dword_805B1D4;
// 805B1E8: using guessed type int dword_805B1E8;
// 805B1FC: using guessed type int dword_805B1FC;
// 805B210: using guessed type int dword_805B210;
// 805B238: using guessed type int dword_805B238;
// 805B24C: using guessed type int dword_805B24C;
// 805B260: using guessed type int dword_805B260;
// 805B288: using guessed type int dword_805B288;

//----- (0804DE3A) --------------------------------------------------------
void *__cdecl sub_804DE3A(char *a1, size_t a2, _DWORD *a3, int *a4)
{
  int *v4; // eax
  int *v5; // ST3C_4
  int v6; // ST40_4
  int v7; // ST44_4
  int size; // [esp+48h] [ebp-10h]
  void *v10; // [esp+4Ch] [ebp-Ch]

  if ( a4 )
    v4 = a4;
  else
    v4 = &dword_805B937;
  v5 = v4;
  v6 = *__errno_location();
  v7 = v5[1] | (a3 == 0);
  size = sub_804CDF2(0, 0, a1, a2, *v5, v7, (int)(v5 + 2), (char *)v5[10], (char *)v5[11]) + 1;
  v10 = sub_8050AD9(size);
  sub_804CDF2((int)v10, size, a1, a2, *v5, v7, (int)(v5 + 2), (char *)v5[10], (char *)v5[11]);
  *__errno_location() = v6;
  if ( a3 )
    *a3 = size - 1;
  return v10;
}
// 805B937: using guessed type int dword_805B937;

//----- (0804DFF6) --------------------------------------------------------
void *__cdecl sub_804DFF6(signed int a1, char *a2, size_t a3, int a4)
{
  void *v4; // eax
  int *v5; // eax
  void *v6; // edx
  size_t v7; // ST4C_4
  bool v9; // [esp+37h] [ebp-21h]
  int *v10; // [esp+38h] [ebp-20h]
  int *v11; // [esp+38h] [ebp-20h]
  void *ptr; // [esp+3Ch] [ebp-1Ch]
  int v13; // [esp+40h] [ebp-18h]
  int size; // [esp+44h] [ebp-14h]
  int v15; // [esp+48h] [ebp-10h]
  unsigned int v16; // [esp+4Ch] [ebp-Ch]

  v13 = *__errno_location();
  v10 = off_805B2D8;
  if ( a1 < 0 )
    abort();
  v4 = &loc_804E03D;
  if ( dword_805B2CC > a1 )
    v4 = &loc_804E0EC;
  dword_805B24C = (int)v4;
  sub_80549A1();
  v9 = v10 == &dword_805B2D0;
  if ( (unsigned int)a1 > 0xFFFFFFE )
    sub_8050C3C();
  if ( v9 )
    v5 = 0;
  else
    v5 = v10;
  v11 = (int *)sub_8050B16(v5, 8 * (a1 + 1));
  off_805B2D8 = v11;
  if ( v9 )
  {
    v6 = off_805B2D4;
    *v11 = dword_805B2D0;
    v11[1] = (int)v6;
  }
  memset(&v11[2 * dword_805B2CC], 0, 8 * (a1 + 1 - dword_805B2CC));
  dword_805B2CC = a1 + 1;
  v7 = v11[2 * a1];
  ptr = (void *)v11[2 * a1 + 1];
  v15 = *(_DWORD *)(a4 + 4) | 1;
  v16 = sub_804CDF2(
          v11[2 * a1 + 1],
          v11[2 * a1],
          a2,
          a3,
          *(_DWORD *)a4,
          v15,
          a4 + 8,
          *(char **)(a4 + 40),
          *(char **)(a4 + 44));
  if ( v7 <= v16 )
  {
    size = v16 + 1;
    v11[2 * a1] = v16 + 1;
    if ( ptr != &unk_805B977 )
      free(ptr);
    ptr = sub_8050AD9(size);
    v11[2 * a1 + 1] = (int)ptr;
    sub_804CDF2((int)ptr, size, a2, a3, *(_DWORD *)a4, v15, a4 + 8, *(char **)(a4 + 40), *(char **)(a4 + 44));
  }
  *__errno_location() = v13;
  return ptr;
}
// 80549A1: using guessed type int sub_80549A1(void);
// 805B24C: using guessed type int dword_805B24C;
// 805B2CC: using guessed type int dword_805B2CC;
// 805B2D0: using guessed type int dword_805B2D0;
// 805B2D4: using guessed type void *off_805B2D4;
// 805B2D8: using guessed type int *off_805B2D8;

//----- (0804E234) --------------------------------------------------------
void *__cdecl sub_804E234(signed int a1, char *a2)
{
  return sub_804DFF6(a1, a2, 0xFFFFFFFF, (int)&dword_805B937);
}
// 805B937: using guessed type int dword_805B937;

//----- (0804E25E) --------------------------------------------------------
void *__cdecl sub_804E25E(signed int a1, char *a2, size_t a3)
{
  return sub_804DFF6(a1, a2, a3, (int)&dword_805B937);
}
// 805B937: using guessed type int dword_805B937;

//----- (0804E2C4) --------------------------------------------------------
void *__cdecl sub_804E2C4(signed int a1, int a2, char *a3)
{
  char v4; // [esp+10h] [ebp-38h]

  sub_804CCA4(&v4, a2);
  return sub_804DFF6(a1, a3, 0xFFFFFFFF, (int)&v4);
}

//----- (0804E302) --------------------------------------------------------
void *__cdecl sub_804E302(signed int a1, int a2, char *a3, size_t a4)
{
  char v5; // [esp+10h] [ebp-38h]

  sub_804CCA4(&v5, a2);
  return sub_804DFF6(a1, a3, a4, (int)&v5);
}

//----- (0804E38A) --------------------------------------------------------
void *__cdecl sub_804E38A(char *a1, size_t a2, unsigned __int8 a3)
{
  int v4; // [esp+20h] [ebp-38h]
  int v5; // [esp+24h] [ebp-34h]
  int v6; // [esp+28h] [ebp-30h]
  int v7; // [esp+2Ch] [ebp-2Ch]
  int v8; // [esp+30h] [ebp-28h]
  int v9; // [esp+34h] [ebp-24h]
  int v10; // [esp+38h] [ebp-20h]
  int v11; // [esp+3Ch] [ebp-1Ch]
  int v12; // [esp+40h] [ebp-18h]
  int v13; // [esp+44h] [ebp-14h]
  int v14; // [esp+48h] [ebp-10h]
  int v15; // [esp+4Ch] [ebp-Ch]

  v4 = dword_805B937;
  v5 = dword_805B93B;
  v6 = dword_805B93F;
  v7 = dword_805B943;
  v8 = dword_805B947;
  v9 = dword_805B94B;
  v10 = dword_805B94F;
  v11 = dword_805B953;
  v12 = dword_805B957;
  v13 = dword_805B95B;
  v14 = dword_805B95F;
  v15 = dword_805B963;
  sub_804CBA0(&v4, a3, 1);
  return sub_804DFF6(0, a1, a2, (int)&v4);
}
// 805B937: using guessed type int dword_805B937;
// 805B93B: using guessed type int dword_805B93B;
// 805B93F: using guessed type int dword_805B93F;
// 805B943: using guessed type int dword_805B943;
// 805B947: using guessed type int dword_805B947;
// 805B94B: using guessed type int dword_805B94B;
// 805B94F: using guessed type int dword_805B94F;
// 805B953: using guessed type int dword_805B953;
// 805B957: using guessed type int dword_805B957;
// 805B95B: using guessed type int dword_805B95B;
// 805B95F: using guessed type int dword_805B95F;
// 805B963: using guessed type int dword_805B963;

//----- (0804E434) --------------------------------------------------------
void *__cdecl sub_804E434(char *a1, unsigned __int8 a2)
{
  return sub_804E38A(a1, 0xFFFFFFFF, a2);
}

//----- (0804E45D) --------------------------------------------------------
void *__cdecl sub_804E45D(char *a1)
{
  return sub_804E434(a1, 0x3Au);
}

//----- (0804E49A) --------------------------------------------------------
void *__cdecl sub_804E49A(signed int a1, int a2, char *a3)
{
  int v4; // [esp+10h] [ebp-68h]
  int v5; // [esp+14h] [ebp-64h]
  int v6; // [esp+18h] [ebp-60h]
  int v7; // [esp+1Ch] [ebp-5Ch]
  int v8; // [esp+20h] [ebp-58h]
  int v9; // [esp+24h] [ebp-54h]
  int v10; // [esp+28h] [ebp-50h]
  int v11; // [esp+2Ch] [ebp-4Ch]
  int v12; // [esp+30h] [ebp-48h]
  int v13; // [esp+34h] [ebp-44h]
  int v14; // [esp+38h] [ebp-40h]
  int v15; // [esp+3Ch] [ebp-3Ch]
  int v16; // [esp+40h] [ebp-38h]
  int v17; // [esp+44h] [ebp-34h]
  int v18; // [esp+48h] [ebp-30h]
  int v19; // [esp+4Ch] [ebp-2Ch]
  int v20; // [esp+50h] [ebp-28h]
  int v21; // [esp+54h] [ebp-24h]
  int v22; // [esp+58h] [ebp-20h]
  int v23; // [esp+5Ch] [ebp-1Ch]
  int v24; // [esp+60h] [ebp-18h]
  int v25; // [esp+64h] [ebp-14h]
  int v26; // [esp+68h] [ebp-10h]
  int v27; // [esp+6Ch] [ebp-Ch]

  sub_804CCA4(&v4, a2);
  v16 = v4;
  v17 = v5;
  v18 = v6;
  v19 = v7;
  v20 = v8;
  v21 = v9;
  v22 = v10;
  v23 = v11;
  v24 = v12;
  v25 = v13;
  v26 = v14;
  v27 = v15;
  sub_804CBA0(&v16, 0x3Au, 1);
  return sub_804DFF6(a1, a3, 0xFFFFFFFF, (int)&v16);
}

//----- (0804E53B) --------------------------------------------------------
void __cdecl __noreturn sub_804E53B(int a1, int a2, int a3)
{
  sub_804E56B(a1, a2, a3);
}

//----- (0804E56B) --------------------------------------------------------
void __cdecl __noreturn sub_804E56B(int a1, int a2, int a3)
{
  int v3; // [esp+10h] [ebp-38h]
  int v4; // [esp+14h] [ebp-34h]
  int v5; // [esp+18h] [ebp-30h]
  int v6; // [esp+1Ch] [ebp-2Ch]
  int v7; // [esp+20h] [ebp-28h]
  int v8; // [esp+24h] [ebp-24h]
  int v9; // [esp+28h] [ebp-20h]
  int v10; // [esp+2Ch] [ebp-1Ch]
  int v11; // [esp+30h] [ebp-18h]
  int v12; // [esp+34h] [ebp-14h]
  int v13; // [esp+38h] [ebp-10h]
  int v14; // [esp+3Ch] [ebp-Ch]

  v3 = dword_805B937;
  v4 = dword_805B93B;
  v5 = dword_805B93F;
  v6 = dword_805B943;
  v7 = dword_805B947;
  v8 = dword_805B94B;
  v9 = dword_805B94F;
  v10 = dword_805B953;
  v11 = dword_805B957;
  v12 = dword_805B95B;
  v13 = dword_805B95F;
  v14 = dword_805B963;
  sub_804CC4A(&v3, a2, a3);
}
// 805B937: using guessed type int dword_805B937;
// 805B93B: using guessed type int dword_805B93B;
// 805B93F: using guessed type int dword_805B93F;
// 805B943: using guessed type int dword_805B943;
// 805B947: using guessed type int dword_805B947;
// 805B94B: using guessed type int dword_805B94B;
// 805B94F: using guessed type int dword_805B94F;
// 805B953: using guessed type int dword_805B953;
// 805B957: using guessed type int dword_805B957;
// 805B95B: using guessed type int dword_805B95B;
// 805B95F: using guessed type int dword_805B95F;
// 805B963: using guessed type int dword_805B963;

//----- (0804E665) --------------------------------------------------------
void *__cdecl sub_804E665(signed int a1, char *a2, size_t a3)
{
  return sub_804DFF6(a1, a2, a3, (int)&unk_805B2EC);
}

//----- (0804E6B0) --------------------------------------------------------
void *__cdecl sub_804E6B0(signed int a1, char *a2)
{
  return sub_804E665(a1, a2, 0xFFFFFFFF);
}

//----- (0804E6D2) --------------------------------------------------------
void *__cdecl sub_804E6D2(char *a1)
{
  return sub_804E6B0(0, a1);
}

//----- (0804E6ED) --------------------------------------------------------
_DWORD *__cdecl sub_804E6ED(int a1)
{
  _DWORD *result; // eax
  int v2; // edx

  result = sub_8050AEC(0x14u);
  *result = a1;
  result[3] = 0;
  result[4] = 0;
  v2 = result[4];
  result[1] = result[3];
  result[2] = v2;
  return result;
}

//----- (0804E732) --------------------------------------------------------
_DWORD *__cdecl sub_804E732(int a1, int a2)
{
  _DWORD *result; // eax
  int v3; // [esp+1Ch] [ebp-Ch]

  v3 = sub_804F259(a1, a2);
  if ( v3 )
    result = sub_804E6ED(v3);
  else
    result = 0;
  return result;
}

//----- (0804E771) --------------------------------------------------------
__int64 __cdecl sub_804E771(__int64 a1)
{
  return a1 << 8;
}

//----- (0804E792) --------------------------------------------------------
int __cdecl sub_804E792(int *a1, unsigned __int64 a2)
{
  int v2; // edx
  int v3; // edx
  __int64 v4; // rax
  int v5; // ecx
  unsigned __int64 v6; // rax
  int *v7; // eax
  int v8; // edx
  int *v9; // ecx
  int result; // eax
  __int64 v11; // rax
  int *v12; // ecx
  __int64 v13; // rax
  int *v14; // ecx
  unsigned __int64 v15; // [esp+10h] [ebp-88h]
  int *v16; // [esp+1Ch] [ebp-7Ch]
  size_t n; // [esp+28h] [ebp-70h]
  int v18; // [esp+2Ch] [ebp-6Ch]
  unsigned __int64 v19; // [esp+30h] [ebp-68h]
  unsigned __int64 v20; // [esp+38h] [ebp-60h]
  __int64 v21; // [esp+40h] [ebp-58h]
  unsigned __int64 v22; // [esp+48h] [ebp-50h]
  unsigned __int64 v23; // [esp+50h] [ebp-48h]
  __int64 v24; // [esp+58h] [ebp-40h]
  unsigned __int64 v25; // [esp+60h] [ebp-38h]
  __int64 v26; // [esp+68h] [ebp-30h]
  char ptr; // [esp+74h] [ebp-24h]
  unsigned int v28; // [esp+7Ch] [ebp-1Ch]

  v16 = a1;
  v15 = a2;
  v28 = __readgsdword(0x14u);
  v18 = *a1;
  v2 = a1[2];
  LODWORD(v19) = a1[1];
  HIDWORD(v19) = v2;
  v3 = a1[4];
  LODWORD(v20) = a1[3];
  HIDWORD(v20) = v3;
  v22 = a2 + 1;
  if ( v20 < a2 )
  {
    n = 0;
    v21 = v20;
    do
    {
      v4 = sub_804E771(v21);
      v21 = v4 + 255;
      ++n;
      v6 = v4 + 255;
    }
    while ( v6 < v15 );
    sub_804F5E0(SHIDWORD(v6), v5, v18, &ptr, n);
  }
  if ( v15 == v20 )
  {
    v7 = v16;
    v16[3] = 0;
    v7[4] = 0;
    v8 = v16[4];
    v9 = v16;
    v16[1] = v16[3];
    v9[2] = v8;
    result = v19;
  }
  else
  {
    v23 = v20 - v15;
    v24 = sub_8054529((signed int)v20 - (signed int)v15, (v20 - v15) >> 32, v22, SHIDWORD(v22));
    v25 = v20 - v24;
    v26 = sub_8054529(v19, HIDWORD(v19), v22, SHIDWORD(v22));
    if ( v19 > v20 - v24 )
    {
      v19 = v26;
      v20 = v24 - 1;
      dword_805B198 = (int)&loc_804E7FF;
      result = sub_8054DDB();
    }
    else
    {
      v11 = sub_80543C2(v19, v22, HIDWORD(v22));
      v12 = v16;
      v16[1] = v11;
      v12[2] = HIDWORD(v11);
      v13 = sub_80543C2(v23, v22, HIDWORD(v22));
      v14 = v16;
      v16[3] = v13;
      v14[4] = HIDWORD(v13);
      result = v26;
    }
  }
  return result;
}
// 8054DDB: using guessed type int sub_8054DDB(void);
// 805B198: using guessed type int dword_805B198;

//----- (0804EA93) --------------------------------------------------------
void __cdecl sub_804EA93(void *ptr)
{
  explicit_bzero(ptr, 20);
  free(ptr);
}
// 8049330: using guessed type int __cdecl explicit_bzero(_DWORD, _DWORD);

//----- (0804EAF3) --------------------------------------------------------
int __cdecl sub_804EAF3(int *a1, __int64 a2)
{
  return sub_804E792(a1, a2 - 1);
}

//----- (0804EB26) --------------------------------------------------------
int __cdecl sub_804EB26(int a1)
{
  int v2; // [esp+Ch] [ebp-4h]
  unsigned int i; // [esp+18h] [ebp+8h]

  v2 = 0;
  for ( i = a1 - 1; i; i >>= 1 )
    ++v2;
  return v2;
}

//----- (0804EB50) --------------------------------------------------------
unsigned int __cdecl sub_804EB50(int a1, int a2)
{
  return (unsigned int)(a1 * sub_804EB26(a2) + 7) >> 3;
}

//----- (0804EB7F) --------------------------------------------------------
int __cdecl sub_804EB7F(int a1, int a2, int a3)
{
  int v3; // ST0C_4
  int result; // eax

  v3 = *(_DWORD *)(4 * a2 + a1);
  *(_DWORD *)(a1 + 4 * a2) = *(_DWORD *)(4 * a3 + a1);
  result = v3;
  *(_DWORD *)(a1 + 4 * a3) = v3;
  return result;
}

//----- (0804EBD1) --------------------------------------------------------
int __cdecl sub_804EBD1(_DWORD *a1, unsigned int a2)
{
  return *a1 % a2;
}

//----- (0804EBEE) --------------------------------------------------------
bool __cdecl sub_804EBEE(_DWORD *a1, _DWORD *a2)
{
  return *a1 == *a2;
}

//----- (0804EC11) --------------------------------------------------------
size_t *__cdecl sub_804EC11(unsigned int a1)
{
  return sub_805260D(a1, 0, (int)sub_804EBD1, (bool (__cdecl *)(int, int))sub_804EBEE, (size_t)free);
}

//----- (0804EC44) --------------------------------------------------------
void __cdecl __noreturn sub_804EC44(int a1, int a2, int a3, int a4)
{
  int v4; // ST1C_4
  _DWORD *v5; // [esp+14h] [ebp-24h]
  _DWORD *v6; // [esp+18h] [ebp-20h]
  int v7; // [esp+20h] [ebp-18h]
  int v8; // [esp+24h] [ebp-14h]
  int v9; // [esp+28h] [ebp-10h]
  int v10; // [esp+2Ch] [ebp-Ch]

  v7 = a3;
  v8 = 0;
  v5 = (_DWORD *)sub_80531B8(a1, (int)&v7);
  v9 = a4;
  v10 = 0;
  v6 = (_DWORD *)sub_80531B8(a1, (int)&v9);
  if ( !v5 )
  {
    v5 = sub_8050AEC(8u);
    v5[1] = a3;
    *v5 = v5[1];
  }
  if ( !v6 )
  {
    v6 = sub_8050AEC(8u);
    v6[1] = a4;
    *v6 = v6[1];
  }
  v4 = v5[1];
  v5[1] = v6[1];
  v6[1] = v4;
  sub_8053164(a1, (int)v5);
}

//----- (0804ED32) --------------------------------------------------------
#error "804ED3F: call analysis failed (funcsize=5)"

//----- (0804ED66) --------------------------------------------------------
void __cdecl sub_804ED66(void *a1)
{
  sub_805284F(a1);
}

//----- (0804ED79) --------------------------------------------------------
int __usercall sub_804ED79@<eax>(int a1@<edx>, int a2@<ecx>, int *a3, unsigned int a4, unsigned int a5)
{
  int v5; // eax
  int v6; // ecx
  bool v7; // al
  bool v8; // zf
  void *v9; // eax
  size_t *v10; // eax
  void *v11; // eax
  int v13; // [esp+0h] [ebp-38h]
  bool v14; // [esp+1Fh] [ebp-19h]
  void *ptr; // [esp+20h] [ebp-18h]
  void *v16; // [esp+28h] [ebp-10h]

  if ( a4 )
  {
    if ( a4 == 1 )
    {
      ptr = sub_8050AEC(4u);
      v5 = sub_804EAF3(a3, a5);
      *(_DWORD *)ptr = v5;
      dword_805B224 = (int)&loc_804EF90;
      sub_8054A83(v6, v5, v13);
    }
    v7 = 0;
    if ( a5 > 0x1FFFF )
    {
      a1 = a5 % a4;
      if ( a5 / a4 > 0x1F )
        v7 = 1;
    }
    v14 = v7;
    v8 = v7 == 0;
    v9 = &loc_804EE2C;
    if ( v8 )
      v9 = &loc_804EE78;
    dword_805B148 = (int)v9;
    sub_8054FB6(a2, a1);
    v10 = sub_804EC11(2 * a4);
    v16 = v10;
    v8 = v10 == 0;
    v11 = &loc_804EE5B;
    if ( !v8 )
      v11 = &loc_804EE60;
    dword_805B288 = (int)v11;
    sub_8054836();
    sub_8050C3C();
  }
  return 0;
}
// 8054836: using guessed type int sub_8054836(void);
// 8054A83: using guessed type int __fastcall sub_8054A83(_DWORD, _DWORD, _DWORD);
// 8054FB6: using guessed type int __fastcall sub_8054FB6(_DWORD, _DWORD);
// 805B148: using guessed type int dword_805B148;
// 805B224: using guessed type int dword_805B224;
// 805B288: using guessed type int dword_805B288;

//----- (0804EF95) --------------------------------------------------------
void __cdecl __noreturn sub_804EF95(char *a1)
{
  void *v1; // esi
  bool v2; // zf
  void *v3; // eax
  char *v4; // ebx
  int *v5; // eax

  if ( a1 )
  {
    v1 = sub_804E6D2(a1);
    v2 = *__errno_location() == 0;
    v3 = &loc_804EFD4;
    if ( !v2 )
      v3 = &loc_804EFE4;
    dword_805B198 = (int)v3;
    sub_8054DDB();
    v4 = gettext("%s: end of file");
    v5 = __errno_location();
    error(status, *v5, v4, v1);
  }
  abort();
}
// 8054DDB: using guessed type int sub_8054DDB(void);
// 805B198: using guessed type int dword_805B198;

//----- (0804F017) --------------------------------------------------------
_DWORD *__cdecl sub_804F017(int a1, int a2)
{
  _DWORD *result; // eax

  result = sub_8050AEC(0x81Cu);
  *result = a1;
  result[1] = sub_804EF95;
  result[2] = a2;
  return result;
}

//----- (0804F04C) --------------------------------------------------------
unsigned int __cdecl sub_804F04C(int a1, int a2, size_t nbytes)
{
  size_t v3; // eax
  int v4; // eax
  size_t n; // ST24_4
  int v6; // eax
  size_t v7; // ST28_4
  int v8; // eax
  size_t v9; // ST2C_4
  int v10; // eax
  size_t v11; // ST30_4
  unsigned int result; // eax
  int v13; // eax
  size_t v14; // ST34_4
  unsigned int v15; // [esp+18h] [ebp-30h]
  int fd; // [esp+20h] [ebp-28h]
  struct timeval tv; // [esp+38h] [ebp-10h]

  v15 = 0;
  fd = open64("/dev/urandom", 0);
  if ( fd >= 0 )
  {
    v3 = a2;
    if ( nbytes <= a2 )
      v3 = nbytes;
    v15 = read(fd, (void *)a1, v3);
    if ( (v15 & 0x80000000) != 0 )
      v15 = 0;
    close(fd);
  }
  if ( v15 < a2 )
  {
    v4 = a2 - v15;
    if ( a2 - v15 > 8 )
      v4 = 8;
    n = v4;
    gettimeofday(&tv, 0);
    memcpy((void *)(a1 + v15), &tv, n);
    v15 += n;
  }
  if ( v15 < a2 )
  {
    v6 = a2 - v15;
    if ( a2 - v15 > 4 )
      v6 = 4;
    v7 = v6;
    tv.tv_sec = getpid();
    memcpy((void *)(a1 + v15), &tv, v7);
    v15 += v7;
  }
  if ( v15 < a2 )
  {
    v8 = a2 - v15;
    if ( a2 - v15 > 4 )
      v8 = 4;
    v9 = v8;
    tv.tv_sec = getppid();
    memcpy((void *)(a1 + v15), &tv, v9);
    v15 += v9;
  }
  if ( v15 < a2 )
  {
    v10 = a2 - v15;
    if ( a2 - v15 > 4 )
      v10 = 4;
    v11 = v10;
    tv.tv_sec = getuid();
    memcpy((void *)(a1 + v15), &tv, v11);
    v15 += v11;
  }
  result = v15;
  if ( v15 < a2 )
  {
    v13 = a2 - v15;
    if ( a2 - v15 > 4 )
      v13 = 4;
    v14 = v13;
    tv.tv_sec = getgid();
    memcpy((void *)(a1 + v15), &tv, v14);
    result = v15 + v14;
  }
  return result;
}
// 8048F50: using guessed type int __cdecl open64(_DWORD, _DWORD);

//----- (0804F259) --------------------------------------------------------
int __cdecl sub_804F259(int a1, int a2)
{
  dword_805B298 = (int (*)(void))sub_804F29E;
  if ( !a2 )
  {
    sub_804F017(0, 0);
    dword_805B298 = (int (*)(void))&locret_804F3E8;
  }
  return dword_805B298();
}
// 805B298: using guessed type int (*dword_805B298)(void);

//----- (0804F29E) --------------------------------------------------------
#error "804F2E0: call analysis failed (funcsize=71)"

//----- (0804F3B0) --------------------------------------------------------
#error "804F3E9: positive sp value has been found (funcsize=0)"

//----- (0804F406) --------------------------------------------------------
void __cdecl __noreturn sub_804F406(int a1, void *ptr, size_t n)
{
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  int *v6; // ebx
  int v7; // eax
  FILE *v8; // [esp+0h] [ebp-28h]
  FILE *v9; // [esp+Ch] [ebp-1Ch]
  size_t v10; // [esp+18h] [ebp-10h]
  int v11; // [esp+1Ch] [ebp-Ch]

  while ( 1 )
  {
    v9 = *(FILE **)a1;
    v10 = fread_unlocked(ptr, 1u, n, v9);
    v11 = *__errno_location();
    ptr = (char *)ptr + v10;
    n -= v10;
    v5 = &loc_804F468;
    if ( n )
      v5 = &loc_804F47F;
    dword_805B210 = (int)v5;
    sub_8054AF3(v4, v3);
    dword_805B15C = (int)sub_804F4B9;
    sub_8054F2B();
    v6 = __errno_location();
    v8 = *(FILE **)a1;
    if ( ferror_unlocked(v8) )
      v7 = v11;
    else
      v7 = 0;
    *v6 = v7;
    (*(void (__cdecl **)(_DWORD))(a1 + 4))(*(_DWORD *)(a1 + 8));
  }
}
// 804F4B9: using guessed type int sub_804F4B9();
// 8054AF3: using guessed type int __fastcall sub_8054AF3(_DWORD, _DWORD);
// 8054F2B: using guessed type int sub_8054F2B(void);
// 805B15C: using guessed type int dword_805B15C;
// 805B210: using guessed type int dword_805B210;

//----- (0804F4B9) --------------------------------------------------------
#error "804F4BC: positive sp value has been found (funcsize=0)"

//----- (0804F4BF) --------------------------------------------------------
int __cdecl sub_804F4BF(int a1, void *dest, size_t n)
{
  int result; // eax
  size_t v4; // [esp+14h] [ebp-14h]
  int *v5; // [esp+18h] [ebp-10h]
  char *v6; // [esp+1Ch] [ebp-Ch]
  size_t na; // [esp+38h] [ebp+10h]

  v4 = *(_DWORD *)a1;
  v6 = (char *)dest;
  if ( n > v4 )
  {
    memcpy(dest, (const void *)(a1 + 1024 - v4 + 1040), v4);
    na = n - v4;
    if ( !(((_BYTE)v6 + (_BYTE)v4) & 3) )
    {
      v5 = (int *)&v6[v4];
      while ( na > 0x3FF )
      {
        sub_804F6E8((unsigned int *)(a1 + 4), v5);
        v5 += 256;
        na -= 1024;
        if ( !na )
        {
          result = a1;
          *(_DWORD *)a1 = 0;
          return result;
        }
      }
    }
    sub_804F6E8((unsigned int *)(a1 + 4), (int *)(a1 + 1040));
    v4 = 1024;
    dword_805B15C = (int)&loc_804F4CD;
    result = sub_8054F2B();
  }
  else
  {
    memcpy(dest, (const void *)(a1 + 1024 - v4 + 1040), n);
    result = a1;
    *(_DWORD *)a1 = v4 - n;
  }
  return result;
}
// 8054F2B: using guessed type int sub_8054F2B(void);
// 805B15C: using guessed type int dword_805B15C;

//----- (0804F5E0) --------------------------------------------------------
void __usercall __noreturn sub_804F5E0(int a1@<edx>, int a2@<ecx>, int a3, void *ptr, size_t n)
{
  int (*v5)(); // eax

  v5 = (int (*)())&loc_804F608;
  if ( !*(_DWORD *)a3 )
    v5 = sub_804F623;
  dword_805B210 = (int)v5;
  sub_8054AF3(a2, a1);
  sub_804F406(a3, ptr, n);
}
// 804F623: using guessed type int sub_804F623();
// 8054AF3: using guessed type int __fastcall sub_8054AF3(_DWORD, _DWORD);
// 805B210: using guessed type int dword_805B210;

//----- (0804F641) --------------------------------------------------------
int __cdecl sub_804F641(void *ptr)
{
  void *v1; // eax
  FILE *stream; // [esp+1Ch] [ebp-Ch]

  stream = *(FILE **)ptr;
  explicit_bzero(ptr, 2076);
  free(ptr);
  v1 = &loc_804F68C;
  if ( !stream )
    v1 = &loc_804F699;
  dword_805B1FC = (int)v1;
  sub_8054B67();
  return sub_80518D3(stream);
}
// 8049330: using guessed type int __cdecl explicit_bzero(_DWORD, _DWORD);
// 8054B67: using guessed type int sub_8054B67(void);
// 805B1FC: using guessed type int dword_805B1FC;

//----- (0804F6A0) --------------------------------------------------------
int __cdecl sub_804F6A0(int a1)
{
  return a1;
}

//----- (0804F6B7) --------------------------------------------------------
int __cdecl sub_804F6B7(int a1, __int16 a2)
{
  return *(_DWORD *)((a2 & 0x3FC) + a1);
}

//----- (0804F6E8) --------------------------------------------------------
unsigned int *__cdecl sub_804F6E8(unsigned int *a1, int *a2)
{
  unsigned int v2; // edx
  int v3; // ST08_4
  unsigned int v4; // ST18_4
  unsigned int v5; // ST1C_4
  int v6; // eax
  int v7; // ST0C_4
  unsigned int v8; // ST08_4
  unsigned int v9; // ST20_4
  int v10; // eax
  int v11; // eax
  int v12; // ST0C_4
  int v13; // ST08_4
  unsigned int v14; // ST28_4
  int v15; // eax
  int v16; // eax
  int v17; // ST0C_4
  unsigned int v18; // ST30_4
  int v19; // eax
  int v20; // eax
  int v21; // ST08_4
  unsigned int v22; // ST38_4
  unsigned int v23; // ST3C_4
  int v24; // eax
  int v25; // ST0C_4
  unsigned int v26; // ST08_4
  unsigned int v27; // ST40_4
  int v28; // eax
  int v29; // eax
  int v30; // ST0C_4
  int v31; // ST08_4
  unsigned int v32; // ST48_4
  int v33; // eax
  int v34; // eax
  int v35; // ST0C_4
  unsigned int v36; // ST50_4
  int v37; // eax
  int v38; // eax
  unsigned int *result; // eax
  unsigned int v40; // [esp+8h] [ebp-54h]
  int v41; // [esp+Ch] [ebp-50h]
  unsigned int *v42; // [esp+10h] [ebp-4Ch]
  int *v43; // [esp+14h] [ebp-48h]

  v40 = a1[256];
  v2 = a1[257];
  v41 = v2 + ++a1[258];
  v42 = a1;
  v43 = a2;
  do
  {
    v3 = (v40 ^ (v40 << 13)) + v42[128];
    v4 = *v42;
    v5 = sub_804F6B7((int)a1, *v42) + v3 + v41;
    *v42 = v5;
    v6 = sub_804F6B7((int)a1, v5 >> 8);
    v7 = sub_804F6A0(v4 + v6);
    *v43 = v7;
    v8 = (v3 ^ ((unsigned int)sub_804F6A0(v3) >> 6)) + v42[129];
    v9 = v42[1];
    v10 = sub_804F6B7((int)a1, v42[1]);
    v42[1] = v10 + v8 + v7;
    v11 = sub_804F6B7((int)a1, (v10 + v8 + v7) >> 8);
    v12 = sub_804F6A0(v9 + v11);
    v43[1] = v12;
    v13 = (v8 ^ 4 * v8) + v42[130];
    v14 = v42[2];
    v15 = sub_804F6B7((int)a1, v42[2]);
    v42[2] = v15 + v13 + v12;
    v16 = sub_804F6B7((int)a1, (unsigned int)(v15 + v13 + v12) >> 8);
    v17 = sub_804F6A0(v14 + v16);
    v43[2] = v17;
    v40 = (v13 ^ ((unsigned int)sub_804F6A0(v13) >> 16)) + v42[131];
    v18 = v42[3];
    v19 = sub_804F6B7((int)a1, v42[3]);
    v42[3] = v19 + v40 + v17;
    v20 = sub_804F6B7((int)a1, (v19 + v40 + v17) >> 8);
    v41 = sub_804F6A0(v18 + v20);
    v43[3] = v41;
    v43 += 4;
    v42 += 4;
  }
  while ( v42 < a1 + 128 );
  do
  {
    v21 = (v40 ^ (v40 << 13)) + *(v42 - 128);
    v22 = *v42;
    v23 = sub_804F6B7((int)a1, *v42) + v21 + v41;
    *v42 = v23;
    v24 = sub_804F6B7((int)a1, v23 >> 8);
    v25 = sub_804F6A0(v22 + v24);
    *v43 = v25;
    v26 = (v21 ^ ((unsigned int)sub_804F6A0(v21) >> 6)) + *(v42 - 127);
    v27 = v42[1];
    v28 = sub_804F6B7((int)a1, v42[1]);
    v42[1] = v28 + v26 + v25;
    v29 = sub_804F6B7((int)a1, (v28 + v26 + v25) >> 8);
    v30 = sub_804F6A0(v27 + v29);
    v43[1] = v30;
    v31 = (v26 ^ 4 * v26) + *(v42 - 126);
    v32 = v42[2];
    v33 = sub_804F6B7((int)a1, v42[2]);
    v42[2] = v33 + v31 + v30;
    v34 = sub_804F6B7((int)a1, (unsigned int)(v33 + v31 + v30) >> 8);
    v35 = sub_804F6A0(v32 + v34);
    v43[2] = v35;
    v40 = (v31 ^ ((unsigned int)sub_804F6A0(v31) >> 16)) + *(v42 - 125);
    v36 = v42[3];
    v37 = sub_804F6B7((int)a1, v42[3]);
    v42[3] = v37 + v40 + v35;
    v38 = sub_804F6B7((int)a1, (v37 + v40 + v35) >> 8);
    v41 = sub_804F6A0(v36 + v38);
    v43[3] = v41;
    v43 += 4;
    v42 += 4;
  }
  while ( v42 < a1 + 256 );
  a1[256] = v40;
  result = a1;
  a1[257] = v41;
  return result;
}

//----- (0804FB8D) --------------------------------------------------------
_DWORD *__cdecl sub_804FB8D(_DWORD *a1)
{
  unsigned int v1; // eax
  unsigned int v2; // eax
  unsigned int v3; // eax
  unsigned int v4; // eax
  _DWORD *result; // eax
  int v6; // [esp+Ch] [ebp-28h]
  unsigned int v7; // [esp+10h] [ebp-24h]
  int v8; // [esp+14h] [ebp-20h]
  unsigned int v9; // [esp+18h] [ebp-1Ch]
  int v10; // [esp+1Ch] [ebp-18h]
  unsigned int v11; // [esp+20h] [ebp-14h]
  int v12; // [esp+24h] [ebp-10h]
  unsigned int v13; // [esp+28h] [ebp-Ch]
  int i; // [esp+2Ch] [ebp-8h]
  int v15; // [esp+30h] [ebp-4h]

  v6 = 325574490;
  v7 = -1780940711;
  v8 = -1021952437;
  v9 = 255990488;
  v10 = -651539848;
  v11 = -1525007287;
  v12 = -990909925;
  v13 = 811634969;
  for ( i = 0; i <= 255; i += 8 )
  {
    v6 += a1[i];
    v7 += a1[i + 1];
    v8 += a1[i + 2];
    v9 += a1[i + 3];
    v10 += a1[i + 4];
    v11 += a1[i + 5];
    v12 += a1[i + 6];
    v13 += a1[i + 7];
    v6 ^= v7 << 11;
    v9 += v6;
    v7 = ((unsigned int)sub_804F6A0(v8) >> 2) ^ (v8 + v7);
    v10 += v7;
    v8 = (v9 << 8) ^ (v9 + v8);
    v11 += v8;
    v9 = ((unsigned int)sub_804F6A0(v10) >> 16) ^ (v10 + v9);
    v12 += v9;
    v10 = (v11 << 10) ^ (v11 + v10);
    v13 += v10;
    v11 = ((unsigned int)sub_804F6A0(v12) >> 4) ^ (v12 + v11);
    v6 += v11;
    v12 = (v13 << 8) ^ (v13 + v12);
    v7 += v12;
    v13 = ((unsigned int)sub_804F6A0(v6) >> 9) ^ (v6 + v13);
    v8 += v13;
    v6 += v7;
    a1[i] = v6;
    a1[i + 1] = v7;
    a1[i + 2] = v8;
    a1[i + 3] = v9;
    a1[i + 4] = v10;
    a1[i + 5] = v11;
    a1[i + 6] = v12;
    a1[i + 7] = v13;
  }
  v15 = 0;
  dword_805B24C = (int)&loc_804FF6E;
  sub_80549A1();
  do
  {
    v6 += a1[v15];
    v7 += a1[v15 + 1];
    v8 += a1[v15 + 2];
    v9 += a1[v15 + 3];
    v10 += a1[v15 + 4];
    v11 += a1[v15 + 5];
    v12 += a1[v15 + 6];
    v13 += a1[v15 + 7];
    v6 ^= v7 << 11;
    v9 += v6;
    v7 += v8;
    v1 = sub_804F6A0(v8);
    v7 ^= v1 >> 2;
    v10 += v7;
    v8 += v9;
    v8 ^= v9 << 8;
    v11 += v8;
    v9 += v10;
    v2 = sub_804F6A0(v10);
    v9 ^= v2 >> 16;
    v12 += v9;
    v10 += v11;
    v10 ^= v11 << 10;
    v13 += v10;
    v11 += v12;
    v3 = sub_804F6A0(v12);
    v11 ^= v3 >> 4;
    v6 += v11;
    v12 += v13;
    v12 ^= v13 << 8;
    v7 += v12;
    v13 += v6;
    v4 = sub_804F6A0(v6);
    v13 ^= v4 >> 9;
    v8 += v13;
    v6 += v7;
    a1[v15] = v6;
    a1[v15 + 1] = v7;
    a1[v15 + 2] = v8;
    a1[v15 + 3] = v9;
    a1[v15 + 4] = v10;
    a1[v15 + 5] = v11;
    a1[v15 + 6] = v12;
    a1[v15 + 7] = v13;
    v15 += 8;
  }
  while ( v15 <= 255 );
  a1[258] = 0;
  a1[257] = a1[258];
  result = a1;
  a1[256] = a1[257];
  return result;
}
// 80549A1: using guessed type int sub_80549A1(void);
// 805B24C: using guessed type int dword_805B24C;

//----- (0804FFAE) --------------------------------------------------------
void *__cdecl sub_804FFAE(FILE *stream, int a2)
{
  int v2; // eax
  void *v3; // eax
  __int64 v4; // rax
  void *v6; // eax
  bool v7; // zf
  void *v8; // eax
  void *ptr; // [esp+10h] [ebp-98h]
  size_t size; // [esp+14h] [ebp-94h]
  size_t v11; // [esp+18h] [ebp-90h]
  int v12; // [esp+1Ch] [ebp-8Ch]
  size_t n; // [esp+20h] [ebp-88h]
  size_t v14; // [esp+24h] [ebp-84h]
  void *v15; // [esp+28h] [ebp-80h]
  void *v16; // [esp+2Ch] [ebp-7Ch]
  __int64 v17; // [esp+30h] [ebp-78h]
  __int64 v18; // [esp+38h] [ebp-70h]
  char v19; // [esp+40h] [ebp-68h]
  int v20; // [esp+50h] [ebp-58h]
  __int64 v21; // [esp+6Ch] [ebp-3Ch]

  ptr = 0;
  size = 0x2000;
  v2 = fileno(stream);
  if ( sub_8054734(v2, (int)&v19) >= 0 )
  {
    v3 = &loc_8050015;
    if ( (v20 & 0xF000) != 0x8000 )
      v3 = &loc_8050086;
    dword_805B198 = (int)v3;
    sub_8054DDB();
    LODWORD(v4) = ftello64(stream);
    v17 = v4;
    if ( v4 >= 0 && v21 > v17 )
    {
      v18 = v21 - v17;
      if ( v21 - v17 > 4294967294LL )
      {
        *__errno_location() = 12;
        return 0;
      }
      size = v18 + 1;
    }
  }
  ptr = malloc(size);
  if ( !ptr )
    return 0;
  v11 = 0;
  while ( 1 )
  {
    n = size - v11;
    v14 = fread((char *)ptr + v11, 1u, size - v11, stream);
    v11 += v14;
    if ( v14 != n )
      break;
    if ( size == -1 )
    {
      v12 = 12;
      goto LABEL_26;
    }
    if ( ~(size >> 1) > size )
    {
      size += size >> 1;
      dword_805B1AC = (int)&loc_8050218;
      sub_8054D67();
    }
    size = -1;
    v16 = realloc(ptr, 0xFFFFFFFF);
    if ( !v16 )
    {
      v12 = *__errno_location();
      dword_805B170 = (int)&loc_805026B;
      sub_8054EBD();
    }
    ptr = v16;
  }
  v12 = *__errno_location();
  if ( ferror(stream) )
  {
LABEL_26:
    free(ptr);
    *__errno_location() = v12;
    return 0;
  }
  if ( size - 1 > v11 )
  {
    v6 = realloc(ptr, v11 + 1);
    v15 = v6;
    v7 = v6 == 0;
    v8 = &loc_805018F;
    if ( v7 )
      v8 = &loc_8050198;
    dword_805B1FC = (int)v8;
    sub_8054B67();
    ptr = v15;
  }
  *((_BYTE *)ptr + v11) = 0;
  *(_DWORD *)a2 = v11;
  return ptr;
}
// 804FFAE: could not find valid save-restore pair for ebx
// 80491B0: using guessed type int __cdecl ftello64(_DWORD);
// 8054B67: using guessed type int sub_8054B67(void);
// 8054D67: using guessed type int sub_8054D67(void);
// 8054DDB: using guessed type int sub_8054DDB(void);
// 8054EBD: using guessed type int sub_8054EBD(void);
// 805B170: using guessed type int dword_805B170;
// 805B198: using guessed type int dword_805B198;
// 805B1AC: using guessed type int dword_805B1AC;
// 805B1FC: using guessed type int dword_805B1FC;

//----- (0805028D) --------------------------------------------------------
void *__cdecl sub_805028D(int a1, int a2, int a3)
{
  int v4; // [esp+14h] [ebp-14h]
  FILE *stream; // [esp+18h] [ebp-10h]
  void *ptr; // [esp+1Ch] [ebp-Ch]

  stream = (FILE *)fopen64(a1, a3);
  if ( !stream )
    return 0;
  ptr = sub_804FFAE(stream, a2);
  v4 = *__errno_location();
  if ( !sub_80518D3(stream) )
    return ptr;
  if ( ptr )
  {
    v4 = *__errno_location();
    free(ptr);
  }
  *__errno_location() = v4;
  return 0;
}
// 8049090: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (08050362) --------------------------------------------------------
int __cdecl sub_8050362(FILE *stream, int a2, int a3, int a4, int a5, int a6)
{
  char *v6; // eax
  char *v7; // ebx
  char *v8; // eax
  int result; // eax
  int v10; // esi
  char *v11; // ebx
  char *v12; // eax
  int v13; // edi
  int v14; // esi
  char *v15; // ebx
  char *v16; // eax
  int v17; // edi
  int v18; // esi
  char *v19; // ebx
  char *v20; // eax
  int v21; // edi
  int v22; // esi
  char *v23; // ebx
  char *v24; // eax
  int v25; // edi
  int v26; // esi
  char *v27; // ebx
  char *v28; // eax
  int v29; // esi
  int v30; // edi
  char *v31; // ebx
  char *v32; // eax
  int v33; // edi
  int v34; // esi
  char *v35; // ebx
  char *v36; // eax
  int v37; // edi
  int v38; // esi
  char *v39; // ebx
  char *v40; // eax
  int v41; // edi
  int v42; // esi
  char *v43; // ebx
  char *v44; // eax
  char *v45; // [esp+8h] [ebp-60h]
  int v46; // [esp+Ch] [ebp-5Ch]
  int v47; // [esp+10h] [ebp-58h]
  int v48; // [esp+14h] [ebp-54h]
  int v49; // [esp+18h] [ebp-50h]
  int v50; // [esp+1Ch] [ebp-4Ch]
  int v51; // [esp+20h] [ebp-48h]
  int v52; // [esp+24h] [ebp-44h]
  int v53; // [esp+38h] [ebp-30h]
  int v54; // [esp+3Ch] [ebp-2Ch]
  int v55; // [esp+40h] [ebp-28h]
  int v56; // [esp+44h] [ebp-24h]
  int v57; // [esp+48h] [ebp-20h]
  int v58; // [esp+4Ch] [ebp-1Ch]

  if ( a2 )
  {
    v47 = a4;
    fprintf(stream, "%s (%s) %s\n", a2, a3, a4);
  }
  else
  {
    fprintf(stream, "%s %s\n", a3, a4);
  }
  v46 = 2017;
  v45 = gettext("(C)");
  fprintf(stream, "Copyright %s %d Free Software Foundation, Inc.", v45, 2017);
  v6 = gettext(
         "\n"
         "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\n"
         "This is free software: you are free to change and redistribute it.\n"
         "There is NO WARRANTY, to the extent permitted by law.\n"
         "\n");
  fputs_unlocked(v6, stream);
  switch ( a6 )
  {
    case 0:
      abort();
      return result;
    case 1:
      v7 = *(char **)a5;
      v8 = gettext("Written by %s.\n");
      return fprintf(stream, v8, v7);
    case 2:
      v10 = *(_DWORD *)(a5 + 4);
      v11 = *(char **)a5;
      v12 = gettext("Written by %s and %s.\n");
      return fprintf(stream, v12, v11, v10);
    case 3:
      v13 = *(_DWORD *)(a5 + 8);
      v14 = *(_DWORD *)(a5 + 4);
      v15 = *(char **)a5;
      v16 = gettext("Written by %s, %s, and %s.\n");
      return fprintf(stream, v16, v15, v14, v13);
    case 4:
      v58 = *(_DWORD *)(a5 + 12);
      v17 = *(_DWORD *)(a5 + 8);
      v18 = *(_DWORD *)(a5 + 4);
      v19 = *(char **)a5;
      v20 = gettext("Written by %s, %s, %s,\nand %s.\n");
      return fprintf(stream, v20, v19, v18, v17, v58);
    case 5:
      v58 = *(_DWORD *)(a5 + 16);
      v57 = *(_DWORD *)(a5 + 12);
      v21 = *(_DWORD *)(a5 + 8);
      v22 = *(_DWORD *)(a5 + 4);
      v23 = *(char **)a5;
      v24 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
      return fprintf(stream, v24, v23, v22, v21, v57, v58);
    case 6:
      v58 = *(_DWORD *)(a5 + 20);
      v57 = *(_DWORD *)(a5 + 16);
      v56 = *(_DWORD *)(a5 + 12);
      v25 = *(_DWORD *)(a5 + 8);
      v26 = *(_DWORD *)(a5 + 4);
      v27 = *(char **)a5;
      v28 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
      return fprintf(stream, v28, v27, v26, v25, v56, v57, v58);
    case 7:
      v29 = *(_DWORD *)(a5 + 24);
      v58 = *(_DWORD *)(a5 + 20);
      v57 = *(_DWORD *)(a5 + 16);
      v56 = *(_DWORD *)(a5 + 12);
      v55 = *(_DWORD *)(a5 + 8);
      v30 = *(_DWORD *)(a5 + 4);
      v31 = *(char **)a5;
      v32 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
      v51 = v29;
      v50 = v58;
      v49 = v57;
      v48 = v56;
      v47 = v55;
      v46 = v30;
      v45 = v31;
      fprintf(stream, v32, v31, v30, v55, v56, v57, v58, v29);
      dword_805B1E8 = (int)&loc_8050879;
      sub_8054BD7();
      goto LABEL_13;
    case 8:
LABEL_13:
      v33 = *(_DWORD *)(a5 + 28);
      v58 = *(_DWORD *)(a5 + 24);
      v57 = *(_DWORD *)(a5 + 20);
      v56 = *(_DWORD *)(a5 + 16);
      v55 = *(_DWORD *)(a5 + 12);
      v54 = *(_DWORD *)(a5 + 8);
      v34 = *(_DWORD *)(a5 + 4);
      v35 = *(char **)a5;
      v36 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
      v52 = v33;
      v51 = v58;
      v50 = v57;
      v49 = v56;
      v48 = v55;
      v47 = v54;
      v46 = v34;
      v45 = v35;
      result = fprintf(stream, v36, v35, v34, v54, v55, v56, v57, v58, v33);
      break;
    case 9:
      v37 = *(_DWORD *)(a5 + 32);
      v58 = *(_DWORD *)(a5 + 28);
      v57 = *(_DWORD *)(a5 + 24);
      v56 = *(_DWORD *)(a5 + 20);
      v55 = *(_DWORD *)(a5 + 16);
      v54 = *(_DWORD *)(a5 + 12);
      v53 = *(_DWORD *)(a5 + 8);
      v38 = *(_DWORD *)(a5 + 4);
      v39 = *(char **)a5;
      v40 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
      result = fprintf(stream, v40, v39, v38, v53, v54, v55, v56, v57, v58, v37);
      break;
    default:
      v41 = *(_DWORD *)(a5 + 32);
      v58 = *(_DWORD *)(a5 + 28);
      v57 = *(_DWORD *)(a5 + 24);
      v56 = *(_DWORD *)(a5 + 20);
      v55 = *(_DWORD *)(a5 + 16);
      v54 = *(_DWORD *)(a5 + 12);
      v53 = *(_DWORD *)(a5 + 8);
      v42 = *(_DWORD *)(a5 + 4);
      v43 = *(char **)a5;
      v44 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
      result = fprintf(stream, v44, v43, v42, v53, v54, v55, v56, v57, v58, v41);
      break;
  }
  return result;
}
// 80491E0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8054BD7: using guessed type int sub_8054BD7(void);
// 805B1E8: using guessed type int dword_805B1E8;

//----- (080508D9) --------------------------------------------------------
int __cdecl sub_80508D9(FILE *stream, int a2, int a3, int a4, int a5)
{
  int *v5; // eax
  unsigned int i; // [esp+24h] [ebp-34h]
  int v8[12]; // [esp+28h] [ebp-30h]

  for ( i = 0; i <= 9; ++i )
  {
    v5 = (int *)a5;
    a5 += 4;
    v8[i] = *v5;
    if ( !v8[i] )
      break;
  }
  return sub_8050362(stream, a2, a3, a4, (int)v8, i);
}
// 80508D9: using guessed type int var_30[12];

//----- (0805093F) --------------------------------------------------------
int sub_805093F(FILE *stream, int a2, int a3, int a4, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a4);
  return sub_80508D9(stream, a2, a3, a4, (int)va);
}

//----- (080509DF) --------------------------------------------------------
void *__cdecl sub_80509DF(unsigned int a1, unsigned int a2)
{
  if ( 0x7FFFFFFF / a2 < a1 )
    sub_8050C3C();
  return sub_8050AEC(a2 * a1);
}

//----- (08050A0D) --------------------------------------------------------
void *__cdecl sub_8050A0D(void *ptr, int a2, int a3)
{
  if ( 0x7FFFFFFFu / a3 < a2 )
    sub_8050C3C();
  return sub_8050B16(ptr, a3 * a2);
}

//----- (08050A42) --------------------------------------------------------
void *__cdecl sub_8050A42(void *ptr, int a2, int a3)
{
  unsigned int v4; // [esp+1Ch] [ebp-Ch]

  v4 = *(_DWORD *)a2;
  if ( ptr )
  {
    if ( 0x55555554u / a3 <= v4 )
      sub_8050C3C();
    v4 += (v4 >> 1) + 1;
  }
  else
  {
    if ( !v4 )
      v4 = (0x40u / a3 == 0) + 0x40u / a3;
    if ( 0x7FFFFFFFu / a3 < v4 )
      sub_8050C3C();
  }
  *(_DWORD *)a2 = v4;
  return sub_8050B16(ptr, a3 * v4);
}

//----- (08050AD9) --------------------------------------------------------
void *__cdecl sub_8050AD9(size_t size)
{
  return sub_8050AEC(size);
}

//----- (08050AEC) --------------------------------------------------------
void *__cdecl sub_8050AEC(size_t size)
{
  void *v2; // [esp+1Ch] [ebp-Ch]

  v2 = malloc(size);
  if ( !v2 && size )
    sub_8050C3C();
  return v2;
}

//----- (08050B16) --------------------------------------------------------
void *__cdecl sub_8050B16(void *ptr, size_t size)
{
  void *result; // eax
  void *ptra; // [esp+20h] [ebp+8h]

  if ( size || !ptr )
  {
    ptra = realloc(ptr, size);
    if ( !ptra )
    {
      if ( size )
        sub_8050C3C();
    }
    result = ptra;
  }
  else
  {
    free(ptr);
    result = 0;
  }
  return result;
}

//----- (08050B65) --------------------------------------------------------
void *__cdecl sub_8050B65(void *ptr, int a2)
{
  return sub_8050A42(ptr, a2, 1);
}

//----- (08050BB1) --------------------------------------------------------
void *__cdecl sub_8050BB1(size_t nmemb, size_t size)
{
  void *v3; // [esp+1Ch] [ebp-Ch]

  if ( 0x7FFFFFFF / size < nmemb || (v3 = calloc(nmemb, size)) == 0 )
    sub_8050C3C();
  return v3;
}

//----- (08050BEE) --------------------------------------------------------
void *__cdecl sub_8050BEE(void *src, size_t n)
{
  void *v2; // eax

  v2 = sub_8050AEC(n);
  return memcpy(v2, src, n);
}

//----- (08050C3C) --------------------------------------------------------
void __noreturn sub_8050C3C()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (08050C75) --------------------------------------------------------
unsigned __int64 __cdecl sub_8050C75(char *nptr, int base, int a3, int a4, int a5, int a6, char *s, int a8, int status)
{
  int v9; // eax
  void *v10; // eax
  void *v11; // ebx
  int v12; // edx
  signed int v13; // eax
  signed int v15; // [esp+34h] [ebp-14h]
  unsigned __int64 v16; // [esp+38h] [ebp-10h]

  v9 = sub_8051412(nptr, 0, base);
  v15 = v9;
  if ( v9 )
  {
    if ( v9 == 1 )
    {
      *__errno_location() = 75;
    }
    else
    {
      v10 = &loc_8050D59;
      if ( v15 != 3 )
        v10 = &loc_8050D64;
      dword_805B15C = (int)v10;
      sub_8054F2B();
      *__errno_location() = 0;
    }
  }
  else if ( v16 < __PAIR__((unsigned int)a4, a3) || __PAIR__((unsigned int)a6, a5) < v16 )
  {
    v15 = 1;
    if ( v16 <= 0x3FFFFFFF )
      *__errno_location() = 34;
    else
      *__errno_location() = 75;
  }
  if ( v15 )
  {
    v11 = sub_804E6D2(nptr);
    if ( *__errno_location() == 22 )
      v12 = 0;
    else
      v12 = *__errno_location();
    if ( status )
      v13 = status;
    else
      v13 = 1;
    error(v13, v12, "%s: %s", a8, v11);
  }
  return v16;
}
// 8054F2B: using guessed type int sub_8054F2B(void);
// 805B15C: using guessed type int dword_805B15C;

//----- (08050DCC) --------------------------------------------------------
unsigned __int64 __cdecl sub_8050DCC(char *nptr, int a2, int a3, int a4, int a5, char *s, int a7, int status)
{
  return sub_8050C75(nptr, 10, a2, a3, a4, a5, s, a7, status);
}

//----- (08050E30) --------------------------------------------------------
signed int __cdecl sub_8050E30(unsigned int *a1, unsigned int a2)
{
  signed int result; // eax

  if ( 0xFFFFFFFF / a2 >= *a1 )
  {
    *a1 *= a2;
    result = 0;
  }
  else
  {
    *a1 = -1;
    result = 1;
  }
  return result;
}

//----- (08050E74) --------------------------------------------------------
int __cdecl sub_8050E74(int a1, int a2, int a3)
{
  void *v3; // eax

  v3 = &loc_8050EBE;
  if ( a3 )
    v3 = &loc_8050E83;
  dword_805B24C = (int)v3;
  sub_80549A1();
  return 0;
}
// 80549A1: using guessed type int sub_80549A1(void);
// 805B24C: using guessed type int dword_805B24C;

//----- (08050EC3) --------------------------------------------------------
int __cdecl sub_8050EC3(char *nptr, int a2, int base, int a4, char *s)
{
  void *v5; // eax
  bool v6; // zf
  void *v7; // eax
  int result; // eax
  int v9; // eax
  void *v10; // eax
  int v11; // edx
  int v12; // ecx
  int v13; // [esp+4h] [ebp-44h]
  unsigned __int8 i; // [esp+1Fh] [ebp-29h]
  unsigned int v15; // [esp+24h] [ebp-24h]
  int v16; // [esp+28h] [ebp-20h]
  char *v17; // [esp+2Ch] [ebp-1Ch]
  int v18; // [esp+30h] [ebp-18h]
  int v19; // [esp+34h] [ebp-14h]
  int v20; // [esp+38h] [ebp-10h]
  char **endptr; // [esp+3Ch] [ebp-Ch]

  v16 = 0;
  if ( base < 0 )
LABEL_6:
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoul");
  v5 = &loc_8050EF5;
  if ( base > 36 )
    v5 = &loc_8050F12;
  dword_805B24C = (int)v5;
  sub_80549A1();
  if ( !a2 )
  {
    dword_805B24C = (int)&loc_8050F36;
    sub_80549A1();
    goto LABEL_6;
  }
  endptr = (char **)a2;
  *__errno_location() = 0;
  v17 = nptr;
  for ( i = *nptr; (*__ctype_b_loc())[i] & 0x2000; i = *v17 )
    ++v17;
  if ( i == 45 )
  {
    dword_805B238 = (int)&locret_805132B;
    sub_8054A0F();
  }
  v15 = strtoul(nptr, endptr, base);
  if ( *endptr == nptr )
  {
    if ( s )
    {
      if ( **endptr )
      {
        v13 = **endptr;
        if ( strchr(s, v13) )
        {
          v15 = 1;
          goto LABEL_22;
        }
      }
    }
    dword_805B1FC = (int)&locret_805132B;
    sub_8054B67();
  }
  if ( !*__errno_location() )
  {
LABEL_22:
    if ( s )
    {
      if ( **endptr )
      {
        v18 = 1024;
        v19 = 1;
        v13 = **endptr;
        if ( strchr(s, v13) )
        {
          switch ( **endptr )
          {
            case 69:
            case 71:
            case 75:
            case 77:
            case 80:
            case 84:
            case 89:
            case 90:
            case 103:
            case 107:
            case 109:
            case 116:
              if ( strchr(s, 48) )
              {
                v9 = (*endptr)[1];
                if ( v9 == 68 )
                  goto LABEL_53;
                v6 = v9 == 105;
                v10 = &loc_805112F;
                if ( v6 )
                  v10 = &loc_8051136;
                dword_805B1FC = (int)v10;
                if ( sub_8054B67() == 66 )
                {
LABEL_53:
                  v18 = 1000;
                  ++v19;
                }
              }
              break;
            default:
              break;
          }
          switch ( **endptr )
          {
            case 66:
              v20 = sub_8050E30(&v15, 0x400u);
              goto LABEL_48;
            case 69:
              v20 = sub_8050E74((int)&v15, v18, 6);
              goto LABEL_48;
            case 71:
            case 103:
              v20 = sub_8050E74((int)&v15, v18, 3);
              goto LABEL_48;
            case 75:
            case 107:
              v20 = sub_8050E74((int)&v15, v18, 1);
              dword_805B210 = (int)&loc_80512FB;
              sub_8054AF3(v12, v11);
              goto LABEL_41;
            case 77:
            case 109:
LABEL_41:
              v20 = sub_8050E74((int)&v15, v18, 2);
              goto LABEL_48;
            case 80:
              v20 = sub_8050E74((int)&v15, v18, 5);
              goto LABEL_48;
            case 84:
            case 116:
              v20 = sub_8050E74((int)&v15, v18, 4);
              goto LABEL_48;
            case 89:
              v20 = sub_8050E74((int)&v15, v18, 8);
              goto LABEL_48;
            case 90:
              v20 = sub_8050E74((int)&v15, v18, 7);
              goto LABEL_48;
            case 98:
              v20 = sub_8050E30(&v15, 0x200u);
              goto LABEL_48;
            case 99:
              v20 = 0;
              goto LABEL_48;
            case 119:
              v20 = sub_8050E30(&v15, 2u);
LABEL_48:
              v16 |= v20;
              *endptr += v19;
              if ( **endptr )
                v16 |= 2u;
              goto LABEL_50;
            default:
              *(_DWORD *)a4 = v15;
              result = v16 | 2;
              break;
          }
        }
        else
        {
          *(_DWORD *)a4 = v15;
          result = v16 | 2;
        }
      }
      else
      {
LABEL_50:
        *(_DWORD *)a4 = v15;
        result = v16;
      }
    }
    else
    {
      *(_DWORD *)a4 = v15;
      result = v16;
    }
    return result;
  }
  v6 = *__errno_location() == 34;
  v7 = &loc_8051055;
  if ( v6 )
    v7 = &loc_805105F;
  dword_805B1FC = (int)v7;
  sub_8054B67();
  return 4;
}
// 8050EC3: could not find valid save-restore pair for ebx
// 80549A1: using guessed type int sub_80549A1(void);
// 8054A0F: using guessed type int sub_8054A0F(void);
// 8054AF3: using guessed type int __fastcall sub_8054AF3(_DWORD, _DWORD);
// 8054B67: using guessed type int sub_8054B67(void);
// 805B1FC: using guessed type int dword_805B1FC;
// 805B210: using guessed type int dword_805B210;
// 805B238: using guessed type int dword_805B238;
// 805B24C: using guessed type int dword_805B24C;

//----- (0805132D) --------------------------------------------------------
signed int __cdecl sub_805132D(int a1, signed int a2)
{
  signed int result; // eax
  int v3; // ebx

  if ( (unsigned __int64)sub_80543C2(0xFFFFFFFFFFFFFFFFLL, a2, a2 >> 31) >= *(_QWORD *)a1 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    *(_QWORD *)a1 *= a2;
    result = 0;
  }
  else
  {
    *(_DWORD *)a1 = -1;
    *(_DWORD *)(a1 + 4) = -1;
    result = 1;
  }
  return result;
}

//----- (080513B9) --------------------------------------------------------
int sub_80513B9()
{
  int v1; // [esp+1Ch] [ebp-Ch]

  v1 = 0;
  dword_805B298 = (int (*)(void))sub_80513EE;
  return sub_80513EE();
}
// 80513EE: using guessed type int sub_80513EE();
// 805B298: using guessed type int (*dword_805B298)(void);

//----- (08051412) --------------------------------------------------------
int __cdecl sub_8051412(char *nptr, int a2, int base)
{
  void *v3; // eax
  const unsigned __int16 **v4; // eax
  int v5; // ecx
  int v6; // edx
  void *v7; // eax
  unsigned __int8 i; // [esp+1Bh] [ebp-2Dh]
  int v10; // [esp+20h] [ebp-28h]
  char *v11; // [esp+24h] [ebp-24h]
  char **endptr; // [esp+34h] [ebp-14h]

  v10 = 0;
  if ( base < 0 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoumax");
  v3 = &loc_8051444;
  if ( base > 36 )
    v3 = &loc_805144C;
  dword_805B24C = (int)v3;
  sub_80549A1();
  if ( !a2 )
  {
    dword_805B198 = (int)&loc_805148D;
    sub_8054DDB();
  }
  endptr = (char **)a2;
  *__errno_location() = 0;
  v11 = nptr;
  for ( i = *nptr; ; i = *v11 )
  {
    v4 = __ctype_b_loc();
    v6 = i;
    if ( !((*v4)[v6] & 0x2000) )
      break;
    ++v11;
  }
  v7 = &loc_80514F6;
  if ( i != 45 )
    v7 = &loc_8051500;
  dword_805B274 = (int)v7;
  sub_80548A4(v5, v6 * 2);
  return 4;
}
// 8051412: could not find valid save-restore pair for ebx
// 80548A4: using guessed type int __fastcall sub_80548A4(_DWORD, _DWORD);
// 80549A1: using guessed type int sub_80549A1(void);
// 8054DDB: using guessed type int sub_8054DDB(void);
// 805B198: using guessed type int dword_805B198;
// 805B24C: using guessed type int dword_805B24C;
// 805B274: using guessed type int dword_805B274;

//----- (080518D3) --------------------------------------------------------
int __cdecl sub_80518D3(FILE *stream)
{
  bool v2; // zf
  void *v3; // eax
  int v4; // eax
  __int64 v5; // rax
  int v6; // [esp+14h] [ebp-14h]
  int v7; // [esp+18h] [ebp-10h]

  v6 = 0;
  if ( fileno(stream) < 0 )
    return fclose(stream);
  v2 = __freading(stream) == 0;
  v3 = &loc_8051933;
  if ( v2 )
    v3 = &loc_805196C;
  dword_805B1E8 = (int)v3;
  sub_8054BD7();
  v4 = fileno(stream);
  LODWORD(v5) = lseek64(v4, 0, 0, 1);
  if ( v5 != -1 && sub_80519E8(stream) )
    v6 = *__errno_location();
  v7 = fclose(stream);
  if ( v6 )
  {
    *__errno_location() = v6;
    v7 = -1;
  }
  return v7;
}
// 8049340: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8054BD7: using guessed type int sub_8054BD7(void);
// 805B1E8: using guessed type int dword_805B1E8;

//----- (080519AF) --------------------------------------------------------
int __cdecl sub_80519AF(FILE *stream)
{
  int result; // eax

  result = stream->_flags & 0x100;
  if ( result )
    result = sub_8051A28(stream, 0, 0, 1);
  return result;
}

//----- (080519E8) --------------------------------------------------------
int __cdecl sub_80519E8(FILE *fp)
{
  if ( !fp || !__freading(fp) )
    return fflush(fp);
  sub_80519AF(fp);
  return fflush(fp);
}

//----- (08051A28) --------------------------------------------------------
int __cdecl sub_8051A28(FILE *stream, int a2, int a3, int a4)
{
  void *v4; // eax
  int v5; // eax
  __off64_t v6; // rax

  if ( stream->_IO_read_end != stream->_IO_read_ptr )
    return fseeko64(stream, a2, a3, a4);
  v4 = &loc_8051A77;
  if ( stream->_IO_write_ptr != stream->_IO_write_base )
    v4 = &loc_8051AF1;
  dword_805B1E8 = (int)v4;
  sub_8054BD7();
  if ( stream->_IO_save_base )
    return fseeko64(stream, a2, a3, a4);
  v5 = fileno(stream);
  LODWORD(v6) = lseek64(v5, a2, a3, a4);
  if ( v6 == -1 )
    return -1;
  stream->_flags &= 0xFFFFFFEF;
  stream->_offset = v6;
  return 0;
}
// 8049010: using guessed type int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8049340: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8054BD7: using guessed type int sub_8054BD7(void);
// 805B1E8: using guessed type int dword_805B1E8;

//----- (08051B13) --------------------------------------------------------
size_t __cdecl sub_8051B13(wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  void *v4; // eax
  char v6; // [esp+18h] [ebp-10h]
  size_t v7; // [esp+1Ch] [ebp-Ch]

  if ( !pwc )
    pwc = (wchar_t *)&v6;
  v7 = mbrtowc(pwc, s, n, p);
  if ( v7 <= 0xFFFFFFFD )
    return v7;
  v4 = &loc_8051B6D;
  if ( !n )
    v4 = &loc_8051B99;
  dword_805B198 = (int)v4;
  sub_8054DDB();
  if ( !((unsigned __int8)sub_8051D8C(0) ^ 1) )
    return v7;
  *pwc = (unsigned __int8)*s;
  return 1;
}
// 8054DDB: using guessed type int sub_8054DDB(void);
// 805B198: using guessed type int dword_805B198;

//----- (08051B9E) --------------------------------------------------------
int __cdecl sub_8051B9E(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // esi
  unsigned __int8 *v3; // ebx
  unsigned __int8 v5; // [esp+1Eh] [ebp-Ah]
  unsigned __int8 v6; // [esp+1Fh] [ebp-9h]

  v2 = a1;
  v3 = a2;
  if ( a1 == a2 )
    return 0;
  do
  {
    v5 = sub_805436D(*v2);
    v6 = sub_805436D(*v3);
    if ( !v5 )
      break;
    ++v2;
    ++v3;
  }
  while ( v5 == v6 );
  return v5 - v6;
}

//----- (08051C03) --------------------------------------------------------
int __cdecl sub_8051C03(FILE *fp)
{
  bool v1; // ST26_1
  void *v2; // eax
  void *v3; // eax
  bool v5; // [esp+1Dh] [ebp-Bh]
  bool v6; // [esp+1Fh] [ebp-9h]

  v5 = __fpending(fp) != 0;
  v1 = ferror_unlocked(fp) != 0;
  v6 = sub_80518D3(fp) != 0;
  v2 = &loc_8051C61;
  if ( v1 )
    v2 = &loc_8051C92;
  dword_805B1FC = (int)v2;
  sub_8054B67();
  if ( !v6 )
    return 0;
  v3 = &loc_8051C86;
  if ( v5 )
    v3 = &loc_8051C92;
  dword_805B170 = (int)v3;
  sub_8054EBD();
  if ( *__errno_location() == 9 )
    return 0;
  if ( v6 != 1 )
    *__errno_location() = 0;
  return -1;
}
// 8051C03: could not find valid save-restore pair for ebx
// 8054B67: using guessed type int sub_8054B67(void);
// 8054EBD: using guessed type int sub_8054EBD(void);
// 805B170: using guessed type int dword_805B170;
// 805B1FC: using guessed type int dword_805B1FC;

//----- (08051CB6) --------------------------------------------------------
FILE *__cdecl sub_8051CB6(int a1, char *modes)
{
  int v2; // ST28_4
  int v4; // ST2C_4
  FILE *stream; // [esp+1Ch] [ebp-1Ch]
  signed int v6; // [esp+20h] [ebp-18h]
  int fd; // [esp+24h] [ebp-14h]

  stream = (FILE *)fopen64(a1, modes);
  if ( !stream )
    return stream;
  v6 = fileno(stream);
  if ( v6 < 0 || v6 > 2 )
    return stream;
  fd = sub_8053C5F(v6);
  if ( fd < 0 )
  {
    v2 = *__errno_location();
    sub_80518D3(stream);
    *__errno_location() = v2;
    return 0;
  }
  if ( !sub_80518D3(stream) )
  {
    stream = fdopen(fd, modes);
    if ( stream )
      return stream;
  }
  v4 = *__errno_location();
  close(fd);
  *__errno_location() = v4;
  return 0;
}
// 8049090: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (08051D8C) --------------------------------------------------------
int __cdecl sub_8051D8C(int category)
{
  unsigned __int8 v2; // [esp+1Bh] [ebp-Dh]
  const char *s1; // [esp+1Ch] [ebp-Ch]

  v2 = 1;
  s1 = setlocale(category, 0);
  if ( s1 && (!strcmp(s1, "C") || !strcmp(s1, "POSIX")) )
    v2 = 0;
  return v2;
}

//----- (08051DEA) --------------------------------------------------------
int __cdecl sub_8051DEA(int a1)
{
  return *(_DWORD *)(a1 + 8);
}

//----- (08051DF5) --------------------------------------------------------
int __cdecl sub_8051DF5(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (08051E00) --------------------------------------------------------
int __cdecl sub_8051E00(int a1)
{
  return *(_DWORD *)(a1 + 16);
}

//----- (08051E0B) --------------------------------------------------------
unsigned int __cdecl sub_8051E0B(int a1)
{
  _DWORD *i; // [esp+0h] [ebp-10h]
  unsigned int v3; // [esp+4h] [ebp-Ch]
  _DWORD *v4; // [esp+8h] [ebp-8h]
  unsigned int j; // [esp+Ch] [ebp-4h]

  v3 = 0;
  for ( i = *(_DWORD **)a1; *(_DWORD *)(a1 + 4) > (unsigned int)i; i += 2 )
  {
    if ( *i )
    {
      v4 = i;
      for ( j = 1; ; ++j )
      {
        v4 = (_DWORD *)v4[1];
        if ( !v4 )
          break;
      }
      if ( j > v3 )
        v3 = j;
    }
  }
  return v3;
}

//----- (0805200B) --------------------------------------------------------
int __cdecl sub_805200B(int a1, int a2)
{
  unsigned int v3; // [esp+1Ch] [ebp-Ch]

  v3 = (*(int (__cdecl **)(int, _DWORD))(a1 + 24))(a2, *(_DWORD *)(a1 + 8));
  if ( *(_DWORD *)(a1 + 8) <= v3 )
    abort();
  return 8 * v3 + *(_DWORD *)a1;
}

//----- (08052367) --------------------------------------------------------
bool __cdecl sub_8052367(unsigned int a1)
{
  int v1; // ST08_4
  unsigned int v3; // [esp+8h] [ebp-8h]
  unsigned int v4; // [esp+Ch] [ebp-4h]

  v3 = 3;
  v4 = 9;
  while ( v4 < a1 && a1 % v3 )
  {
    v1 = v3 + 1;
    v4 += 4 * v1;
    v3 = v1 + 1;
  }
  return a1 % v3 != 0;
}

//----- (080523BE) --------------------------------------------------------
int __cdecl sub_80523BE(unsigned int a1)
{
  void *v1; // eax
  int i; // [esp+Ch] [ebp+8h]

  if ( a1 <= 9 )
    a1 = 10;
  for ( i = a1 | 1; ; i += 2 )
  {
    v1 = &loc_80523FA;
    if ( i == -1 )
      v1 = &loc_805240C;
    dword_805B15C = (int)v1;
    sub_8054F2B();
    if ( sub_8052367(i) )
      break;
  }
  return i;
}
// 8054F2B: using guessed type int sub_8054F2B(void);
// 805B15C: using guessed type int dword_805B15C;

//----- (08052448) --------------------------------------------------------
unsigned int __cdecl sub_8052448(int a1, unsigned int a2)
{
  return sub_805407D(a1, 3) % a2;
}

//----- (08052473) --------------------------------------------------------
bool __cdecl sub_8052473(int a1, int a2)
{
  return a1 == a2;
}

//----- (08052481) --------------------------------------------------------
signed int __cdecl sub_8052481(int a1)
{
  int v2; // [esp+8h] [ebp-8h]
  float v3; // [esp+Ch] [ebp-4h]

  v2 = *(_DWORD *)(a1 + 20);
  if ( (_UNKNOWN *)v2 == &unk_8056470 )
    return 1;
  v3 = 0.1;
  if ( *(float *)(v2 + 8) > 0.1
    && 1.0 - v3 > *(float *)(v2 + 8)
    && *(float *)(v2 + 12) > v3 + 1.0
    && *(float *)v2 >= 0.0
    && *(float *)(v2 + 4) > *(float *)v2 + v3
    && *(float *)(v2 + 4) <= 1.0
    && *(float *)(v2 + 8) > *(float *)v2 + v3 )
  {
    dword_805B1FC = (int)&locret_8052554;
    sub_8054B67();
  }
  *(_DWORD *)(a1 + 20) = &unk_8056470;
  return 0;
}
// 8054B67: using guessed type int sub_8054B67(void);
// 805B1FC: using guessed type int dword_805B1FC;

//----- (08052556) --------------------------------------------------------
unsigned int __cdecl sub_8052556(unsigned int a1, int a2)
{
  __int16 v2; // ax
  __int64 v4; // [esp+4h] [ebp-20h]
  __int16 v5; // [esp+10h] [ebp-14h]
  __int16 v6; // [esp+12h] [ebp-12h]
  float v7; // [esp+20h] [ebp-4h]
  unsigned int v8; // [esp+2Ch] [ebp+8h]

  if ( *(_BYTE *)(a2 + 16) != 1 )
  {
    v4 = a1;
    v7 = (long double)a1 / *(float *)(a2 + 8);
    if ( v7 >= 4294967300.0 )
    {
      dword_805B1AC = (int)&locret_805260B;
      sub_8054D67();
    }
    LOBYTE(v2) = v6;
    HIBYTE(v2) = 12;
    v5 = v2;
    v4 = (signed __int64)v7;
    a1 = v4;
  }
  v8 = sub_80523BE(a1);
  if ( v8 > 0x1FFFFFFF )
  {
    dword_805B288 = (int)&locret_805260B;
    sub_8054836();
  }
  return v8;
}
// 8054836: using guessed type int sub_8054836(void);
// 8054D67: using guessed type int sub_8054D67(void);
// 805B1AC: using guessed type int dword_805B1AC;
// 805B288: using guessed type int dword_805B288;

//----- (0805260D) --------------------------------------------------------
size_t *__cdecl sub_805260D(unsigned int a1, void *a2, int a3, bool (__cdecl *a4)(int a1, int a2), size_t a5)
{
  void *v5; // eax
  size_t *v6; // eax
  bool v7; // zf
  void *v8; // eax
  int v9; // edx
  int v10; // ecx
  size_t *result; // eax
  size_t *ptr; // [esp+1Ch] [ebp-Ch]

  v5 = &loc_8052632;
  if ( a3 )
    v5 = &loc_8052639;
  dword_805B15C = (int)v5;
  sub_8054F2B();
  if ( !a4 )
    a4 = sub_8052473;
  v6 = (size_t *)malloc(0x28u);
  ptr = v6;
  v7 = v6 == 0;
  v8 = &loc_8052674;
  if ( !v7 )
    v8 = &loc_8052690;
  dword_805B1D4 = (int)v8;
  sub_8054C6A();
  dword_805B210 = (int)&locret_805276D;
  sub_8054AF3(v10, v9);
  if ( !a2 )
    a2 = &unk_8056470;
  ptr[5] = (size_t)a2;
  if ( !((unsigned __int8)sub_8052481((int)ptr) ^ 1)
    && (ptr[2] = sub_8052556(a1, (int)a2)) != 0
    && (*ptr = (size_t)calloc(ptr[2], 8u)) != 0 )
  {
    ptr[1] = 8 * ptr[2] + *ptr;
    ptr[3] = 0;
    ptr[4] = 0;
    ptr[6] = (size_t)sub_8052448;
    ptr[7] = (size_t)a4;
    ptr[8] = a5;
    ptr[9] = 0;
    result = ptr;
  }
  else
  {
    free(ptr);
    result = 0;
  }
  return result;
}
// 805260D: could not find valid save-restore pair for ebx
// 8054AF3: using guessed type int __fastcall sub_8054AF3(_DWORD, _DWORD);
// 8054C6A: using guessed type int sub_8054C6A(void);
// 8054F2B: using guessed type int sub_8054F2B(void);
// 805B15C: using guessed type int dword_805B15C;
// 805B1D4: using guessed type int dword_805B1D4;
// 805B210: using guessed type int dword_805B210;

//----- (0805284F) --------------------------------------------------------
void __cdecl sub_805284F(void *a1)
{
  void *v1; // eax
  void **i; // [esp+14h] [ebp-14h]
  void *ptr; // [esp+18h] [ebp-10h]
  void *v4; // [esp+1Ch] [ebp-Ch]

  if ( *((_DWORD *)a1 + 8) && *((_DWORD *)a1 + 4) )
  {
    i = *(void ***)a1;
    dword_805B15C = (int)&loc_80528BC;
    sub_8054F2B();
    do
    {
      if ( *i )
      {
        for ( ptr = i; ptr; ptr = (void *)*((_DWORD *)ptr + 1) )
          (*((void (__cdecl **)(_DWORD))a1 + 8))(*(_DWORD *)ptr);
      }
      i += 2;
    }
    while ( *((_DWORD *)a1 + 1) > (unsigned int)i );
  }
  for ( i = *(void ***)a1; *((_DWORD *)a1 + 1) > (unsigned int)i; i += 2 )
  {
    ptr = i[1];
    dword_805B170 = (int)&loc_805290B;
    sub_8054EBD();
    v4 = (void *)*((_DWORD *)ptr + 1);
    free(ptr);
    ptr = v4;
    v1 = &loc_805292A;
    if ( v4 )
      v1 = &loc_80528F1;
    dword_805B1FC = (int)v1;
    sub_8054B67();
  }
  for ( ptr = (void *)*((_DWORD *)a1 + 9); ptr; ptr = v4 )
  {
    v4 = (void *)*((_DWORD *)ptr + 1);
    free(ptr);
  }
  free(*(void **)a1);
  free(a1);
}
// 8054B67: using guessed type int sub_8054B67(void);
// 8054EBD: using guessed type int sub_8054EBD(void);
// 8054F2B: using guessed type int sub_8054F2B(void);
// 805B15C: using guessed type int dword_805B15C;
// 805B170: using guessed type int dword_805B170;
// 805B1FC: using guessed type int dword_805B1FC;

//----- (0805297E) --------------------------------------------------------
void *__cdecl sub_805297E(int a1)
{
  int v2; // [esp+1Ch] [ebp-Ch]

  if ( !*(_DWORD *)(a1 + 36) )
    return malloc(8u);
  v2 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(v2 + 4);
  return (void *)v2;
}

//----- (080529B9) --------------------------------------------------------
int __cdecl sub_80529B9(int a1, _DWORD *a2)
{
  int result; // eax

  *a2 = 0;
  a2[1] = *(_DWORD *)(a1 + 36);
  result = a1;
  *(_DWORD *)(a1 + 36) = a2;
  return result;
}

//----- (080529DC) --------------------------------------------------------
int __cdecl sub_80529DC(int a1, int a2, _DWORD *a3, char a4)
{
  bool v5; // zf
  int v6; // edx
  int v7; // ecx
  void *v8; // eax
  _DWORD *v9; // ST34_4
  int v10; // edx
  _DWORD *v11; // [esp+1Ch] [ebp-1Ch]
  int v12; // [esp+28h] [ebp-10h]

  v11 = (_DWORD *)sub_805200B(a1, a2);
  *a3 = v11;
  if ( !*v11 )
    return 0;
  if ( *v11 != a2 )
  {
    v5 = (*(unsigned __int8 (__cdecl **)(int, _DWORD))(a1 + 28))(a2, *v11) == 0;
    v8 = &loc_8052A56;
    if ( v5 )
      v8 = &loc_8052AAC;
    dword_805B210 = (int)v8;
    sub_8054AF3(v7, v6);
  }
  v12 = *v11;
  if ( a4 )
  {
    if ( v11[1] )
    {
      v9 = (_DWORD *)v11[1];
      v10 = v9[1];
      *v11 = *v9;
      v11[1] = v10;
      sub_80529B9(a1, v9);
    }
    else
    {
      *v11 = 0;
    }
  }
  return v12;
}
// 8054AF3: using guessed type int __fastcall sub_8054AF3(_DWORD, _DWORD);
// 805B210: using guessed type int dword_805B210;

//----- (08052B6B) --------------------------------------------------------
signed int __cdecl sub_8052B6B(int a1, int a2, char a3)
{
  char v4; // [esp+Ch] [ebp-2Ch]
  int *i; // [esp+18h] [ebp-20h]
  int *j; // [esp+1Ch] [ebp-1Ch]
  int v7; // [esp+20h] [ebp-18h]
  _DWORD *v8; // [esp+24h] [ebp-14h]
  int *v9; // [esp+28h] [ebp-10h]
  _DWORD *v10; // [esp+2Ch] [ebp-Ch]

  v4 = a3;
  for ( i = *(int **)a2; *(_DWORD *)(a2 + 4) > (unsigned int)i; i += 2 )
  {
    if ( *i )
    {
      for ( j = (int *)i[1]; j; j = v9 )
      {
        v7 = *j;
        v8 = (_DWORD *)sub_805200B(a1, v7);
        v9 = (int *)j[1];
        if ( *v8 )
        {
          j[1] = v8[1];
          v8[1] = j;
        }
        else
        {
          *v8 = v7;
          ++*(_DWORD *)(a1 + 12);
          sub_80529B9(a1, j);
        }
      }
      v7 = *i;
      i[1] = 0;
      if ( !v4 )
      {
        v8 = (_DWORD *)sub_805200B(a1, v7);
        if ( *v8 )
        {
          v10 = sub_805297E(a1);
          if ( !v10 )
            return 0;
          *v10 = v7;
          v10[1] = v8[1];
          v8[1] = v10;
          dword_805B238 = (int)&loc_8052CB8;
          sub_8054A0F();
        }
        *v8 = v7;
        ++*(_DWORD *)(a1 + 12);
        *i = 0;
        --*(_DWORD *)(a2 + 12);
      }
    }
  }
  return 1;
}
// 8054A0F: using guessed type int sub_8054A0F(void);
// 805B238: using guessed type int dword_805B238;

//----- (08052CEA) --------------------------------------------------------
signed int __cdecl sub_8052CEA(int a1, unsigned int a2)
{
  int v2; // edx
  int v3; // ecx
  void *v4; // eax
  void *v5; // edx
  signed int result; // eax
  int v7; // [esp+0h] [ebp-48h]
  size_t nmemb; // [esp+10h] [ebp-38h]
  char *v9; // [esp+14h] [ebp-34h]
  char v10; // [esp+18h] [ebp-30h]

  nmemb = sub_8052556(a2, *(_DWORD *)(a1 + 20));
  if ( !nmemb )
  {
    dword_805B170 = (int)&locret_8052EDA;
    sub_8054EBD();
  }
  v4 = &loc_8052D4E;
  if ( *(_DWORD *)(a1 + 8) != nmemb )
    v4 = &loc_8052D6A;
  dword_805B224 = (int)v4;
  sub_8054A83(v3, v2, v7);
  dword_805B170 = (int)&locret_8052EDA;
  sub_8054EBD();
  v9 = &v10;
  v5 = calloc(nmemb, 8u);
  *(_DWORD *)v9 = v5;
  if ( !*(_DWORD *)v9 )
    return 0;
  *((_DWORD *)v9 + 2) = nmemb;
  *((_DWORD *)v9 + 1) = *(_DWORD *)v9 + 8 * nmemb;
  *((_DWORD *)v9 + 3) = 0;
  *((_DWORD *)v9 + 4) = 0;
  *((_DWORD *)v9 + 5) = *(_DWORD *)(a1 + 20);
  *((_DWORD *)v9 + 6) = *(_DWORD *)(a1 + 24);
  *((_DWORD *)v9 + 7) = *(_DWORD *)(a1 + 28);
  *((_DWORD *)v9 + 8) = *(_DWORD *)(a1 + 32);
  *((_DWORD *)v9 + 9) = *(_DWORD *)(a1 + 36);
  if ( (unsigned __int8)sub_8052B6B((int)v9, a1, 0) )
  {
    free(*(void **)a1);
    *(_DWORD *)a1 = *(_DWORD *)v9;
    *(_DWORD *)(a1 + 4) = *((_DWORD *)v9 + 1);
    *(_DWORD *)(a1 + 8) = *((_DWORD *)v9 + 2);
    *(_DWORD *)(a1 + 12) = *((_DWORD *)v9 + 3);
    *(_DWORD *)(a1 + 36) = *((_DWORD *)v9 + 9);
    result = 1;
  }
  else
  {
    *(_DWORD *)(a1 + 36) = *((_DWORD *)v9 + 9);
    if ( (unsigned __int8)sub_8052B6B(a1, (int)v9, 1) ^ 1 || (unsigned __int8)sub_8052B6B(a1, (int)v9, 0) ^ 1 )
      abort();
    free(*(void **)v9);
    result = 0;
  }
  return result;
}
// 8054A83: using guessed type int __fastcall sub_8054A83(_DWORD, _DWORD, _DWORD);
// 8054EBD: using guessed type int sub_8054EBD(void);
// 805B170: using guessed type int dword_805B170;
// 805B224: using guessed type int dword_805B224;

//----- (08052EDC) --------------------------------------------------------
void __cdecl __noreturn sub_8052EDC(int a1, int a2)
{
  int (__cdecl *v2)(int, int, int); // eax

  v2 = (int (__cdecl *)(int, int, int))&loc_8052F01;
  if ( a2 )
    v2 = sub_8052F06;
  dword_805B1AC = (int)v2;
  sub_8054D67();
  abort();
}
// 8052F06: using guessed type int __cdecl sub_8052F06(int, int, int);
// 8054D67: using guessed type int sub_8054D67(void);
// 805B1AC: using guessed type int dword_805B1AC;

//----- (08052F06) --------------------------------------------------------
#error "8053163: positive sp value has been found (funcsize=160)"

//----- (08053164) --------------------------------------------------------
void __cdecl __noreturn sub_8053164(int a1, int a2)
{
  sub_8052EDC(a1, a2);
}

//----- (080531B8) --------------------------------------------------------
int __cdecl sub_80531B8(int a1, int a2)
{
  int v2; // eax
  int v3; // edx
  int v4; // ecx
  bool v5; // zf
  void *v6; // eax
  int v8; // [esp+28h] [ebp-20h]
  int v9; // [esp+30h] [ebp-18h]

  v2 = sub_80529DC(a1, a2, &v8, 1);
  v9 = v2;
  v5 = v2 == 0;
  v6 = &loc_8053201;
  if ( !v5 )
    v6 = &loc_805320B;
  dword_805B210 = (int)v6;
  sub_8054AF3(v4, v3);
  return 0;
}
// 8054AF3: using guessed type int __fastcall sub_8054AF3(_DWORD, _DWORD);
// 805B210: using guessed type int dword_805B210;

//----- (080533B6) --------------------------------------------------------
int sub_80533B6()
{
  int v1; // edx
  int v2; // ecx
  bool v3; // zf
  void *v4; // eax
  char v5; // al
  int v6; // [esp+14h] [ebp-B4h]
  int v7; // [esp+18h] [ebp-B0h]
  char *s; // [esp+1Ch] [ebp-ACh]
  char *v9; // [esp+28h] [ebp-A0h]
  size_t v10; // [esp+2Ch] [ebp-9Ch]
  size_t v11; // [esp+30h] [ebp-98h]
  unsigned int v12; // [esp+BCh] [ebp-Ch]

  v12 = __readgsdword(0x14u);
  v7 = dword_805BA77;
  dword_805B298 = (int (*)(void))sub_8053B28;
  if ( !dword_805BA77 )
  {
    v6 = 0;
    v9 = "charset.alias";
    s = getenv("CHARSETALIASDIR");
    dword_805B298 = (int (*)(void))&loc_8053466;
    if ( s )
    {
      v3 = *s == 0;
      dword_805B298 = (int (*)(void))&loc_805347A;
      v4 = &loc_8053466;
      if ( !v3 )
        v4 = &loc_8050314;
      dword_805B210 = (int)v4;
      sub_8054AF3(v2, v1);
      v6 = 0;
      s = "/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib";
      v10 = strlen("/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib");
      v11 = strlen(v9);
      dword_805B298 = (int (*)(void))sub_80534FF;
      if ( v10 )
      {
        v5 = s[v10 - 1];
        dword_805B298 = (int (*)(void))sub_80534FF;
        if ( v5 != 47 )
          dword_805B298 = (int (*)(void))&loc_8053504;
      }
    }
  }
  return dword_805B298();
}
// 8053B28: using guessed type int sub_8053B28();
// 8054AF3: using guessed type int __fastcall sub_8054AF3(_DWORD, _DWORD);
// 805B210: using guessed type int dword_805B210;
// 805B298: using guessed type int (*dword_805B298)(void);
// 805BA77: using guessed type int dword_805BA77;

//----- (080534FF) --------------------------------------------------------
#error "8053526: call analysis failed (funcsize=103)"

//----- (080536EF) --------------------------------------------------------
#error "805370C: call analysis failed (funcsize=58)"

//----- (080537E5) --------------------------------------------------------
#error "8053809: call analysis failed (funcsize=39)"

//----- (0805388D) --------------------------------------------------------
int sub_805388D()
{
  dword_805B298 = (int (*)(void))sub_8053AC2;
  return sub_8053AC2();
}
// 8053AC2: using guessed type int sub_8053AC2();
// 805B298: using guessed type int (*dword_805B298)(void);

//----- (08053B5A) --------------------------------------------------------
char *sub_8053B5A()
{
  bool v0; // zf
  void *v1; // eax
  void *v2; // eax
  void *v3; // eax
  char *v4; // ST24_4
  char *s1; // [esp+18h] [ebp-10h]
  char *s2; // [esp+1Ch] [ebp-Ch]

  v0 = nl_langinfo(14) == 0;
  v1 = &loc_8053B8E;
  if ( !v0 )
    v1 = &loc_8053B95;
  dword_805B238 = (int)v1;
  sub_8054A0F();
  s1 = (char *)&unk_8056567;
  for ( s2 = (char *)sub_80533B6(); *s2; s2 = &v4[strlen(v4) + 1] )
  {
    v0 = strcmp((const char *)&unk_8056567, s2) == 0;
    v2 = &loc_8053BD1;
    if ( v0 )
      v2 = &loc_8053C01;
    dword_805B170 = (int)v2;
    sub_8054EBD();
    v3 = &loc_8053BF4;
    if ( *s2 != 42 )
      v3 = &loc_8053C19;
    dword_805B198 = (int)v3;
    sub_8054DDB();
    if ( !s2[1] )
    {
      s1 = &s2[strlen(s2) + 1];
      break;
    }
    v4 = &s2[strlen(s2) + 1];
  }
  if ( !*s1 )
    s1 = "ASCII";
  return s1;
}
// 8053B5A: could not find valid save-restore pair for ebx
// 8054A0F: using guessed type int sub_8054A0F(void);
// 8054DDB: using guessed type int sub_8054DDB(void);
// 8054EBD: using guessed type int sub_8054EBD(void);
// 805B170: using guessed type int dword_805B170;
// 805B198: using guessed type int dword_805B198;
// 805B238: using guessed type int dword_805B238;

//----- (08053C5F) --------------------------------------------------------
int __cdecl sub_8053C5F(int fd)
{
  return sub_8053C82(fd, 0, 3);
}

//----- (08053C82) --------------------------------------------------------
int __cdecl sub_8053C82(int fd, int cmd, char a3)
{
  int *v4; // eax
  int v5; // eax
  int v6; // [esp+8h] [ebp-30h]
  char *v7; // [esp+18h] [ebp-20h]
  int v8; // [esp+1Ch] [ebp-1Ch]
  int v9; // [esp+20h] [ebp-18h]

  v8 = -1;
  v7 = &a3;
  dword_805B298 = (int (*)(void))&loc_8053EE6;
  if ( cmd == 1030 )
  {
    v4 = (int *)v7;
    v7 += 4;
    v9 = *v4;
    dword_805B298 = (int (*)(void))sub_8053DAE;
    if ( dword_805BA7B >= 0 )
    {
      v6 = v9;
      v8 = fcntl(fd, 1030, v9);
      dword_805B298 = (int (*)(void))&loc_8053D2C;
      if ( v8 < 0 )
      {
        v5 = *__errno_location();
        dword_805B298 = (int (*)(void))sub_8053D49;
        if ( v5 != 22 )
        {
          dword_805BA7B = 1;
          dword_805B298 = (int (*)(void))sub_8053DCB;
        }
      }
    }
  }
  return dword_805B298();
}
// 8053DAE: using guessed type int sub_8053DAE();
// 8053DCB: using guessed type int sub_8053DCB();
// 805B298: using guessed type int (*dword_805B298)(void);
// 805BA7B: using guessed type int dword_805BA7B;

//----- (08053D49) --------------------------------------------------------
#error "8053D5E: call analysis failed (funcsize=19)"

//----- (08053D91) --------------------------------------------------------
int sub_8053D91()
{
  dword_805BA7B = -1;
  dword_805B298 = (int (*)(void))sub_8053DCB;
  return sub_8053DCB();
}
// 8053DCB: using guessed type int sub_8053DCB();
// 805B298: using guessed type int (*dword_805B298)(void);
// 805BA7B: using guessed type int dword_805BA7B;

//----- (0805407D) --------------------------------------------------------
int __cdecl sub_805407D(int a1, char a2)
{
  return __ROR4__(a1, a2);
}

//----- (0805436D) --------------------------------------------------------
int __cdecl sub_805436D(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 65) > 0x19 )
    result = a1;
  else
    result = a1 + 32;
  return result;
}

//----- (080543C2) --------------------------------------------------------
__int64 __cdecl sub_80543C2(unsigned __int64 a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // edi
  void *v4; // eax
  unsigned int v5; // ecx
  __int64 result; // rax
  int v7; // ebp
  int v8; // ebp
  unsigned __int64 v9; // rtt
  unsigned int v10; // esi
  unsigned __int64 v11; // rax
  void *v12; // eax
  unsigned int v13; // [esp+0h] [ebp-18h]
  unsigned int v14; // [esp+4h] [ebp-14h]
  unsigned int v15; // [esp+8h] [ebp-10h]

  v3 = a1;
  v14 = a1;
  v13 = a2;
  if ( !a3 )
  {
    if ( a2 > HIDWORD(a1) )
      return (unsigned int)(a1 / a2);
    v4 = &loc_8054408;
    if ( a2 )
      v4 = &loc_8054413;
    dword_805B210 = (int)v4;
    sub_8054AF3(a2, HIDWORD(a1));
    LODWORD(result) = __PAIR__(HIDWORD(a1) % (1 / v5), (unsigned int)a1) / (1 / v5);
    HIDWORD(result) = HIDWORD(a1) / (1 / v5);
    return result;
  }
  if ( a3 > HIDWORD(a1) )
    return 0LL;
  _BitScanReverse((unsigned int *)&v7, a3);
  v8 = v7 ^ 0x1F;
  if ( !v8 )
  {
    if ( v13 > v14 && a3 >= HIDWORD(a1) )
      return 0LL;
    dword_805B274 = (int)&loc_8054452;
    sub_80548A4(a2, 0);
    return v3 - 1;
  }
  v15 = (a3 << v8) | (v13 >> (32 - v8));
  LODWORD(v9) = (HIDWORD(a1) << v8) | (v14 >> (32 - v8));
  HIDWORD(v9) = HIDWORD(a1) >> (32 - v8);
  v10 = v9 % v15;
  v3 = v9 / v15;
  v11 = (v13 << v8) * (unsigned __int64)v3;
  v13 = HIDWORD(v11);
  if ( v10 < HIDWORD(v11) )
    return v3 - 1;
  if ( v14 << v8 < (unsigned int)v11 )
  {
    v12 = &loc_80544E5;
    if ( v10 == v13 )
      v12 = &loc_8054511;
    dword_805B184 = (int)v12;
    sub_8054E51();
  }
  return v3;
}
// 80548A4: using guessed type int __fastcall sub_80548A4(_DWORD, _DWORD);
// 8054AF3: using guessed type int __fastcall sub_8054AF3(_DWORD, _DWORD);
// 8054E51: using guessed type int sub_8054E51(void);
// 805B184: using guessed type int dword_805B184;
// 805B210: using guessed type int dword_805B210;
// 805B274: using guessed type int dword_805B274;

//----- (08054529) --------------------------------------------------------
__int64 __cdecl sub_8054529(int a1, unsigned int a2, unsigned int a3, int a4)
{
  void *v4; // eax
  unsigned int v5; // ecx
  unsigned int v6; // edx
  unsigned int v8; // ebp
  unsigned __int64 v9; // rtt

  v4 = &loc_8054573;
  if ( a4 )
    v4 = &loc_805458A;
  dword_805B224 = (int)v4;
  sub_8054A83(a1, a4, a3);
  if ( a3 <= a2 )
  {
    v8 = a3;
    if ( !a3 )
      v8 = 1 / 0u;
    LODWORD(v9) = v5;
    HIDWORD(v9) = a2 % v8;
    v6 = v9 % v8;
  }
  else
  {
    v6 = __PAIR__(a2, v5) % a3;
  }
  return v6;
}
// 8054A83: using guessed type int __fastcall sub_8054A83(_DWORD, _DWORD, _DWORD);
// 805B224: using guessed type int dword_805B224;

//----- (08054705) --------------------------------------------------------
int __cdecl sub_8054705(int a1)
{
  return __cxa_atexit(a1, 0, dword_805B2B0);
}
// 8049130: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 805B2B0: using guessed type int dword_805B2B0;

//----- (08054734) --------------------------------------------------------
int __cdecl sub_8054734(int a1, int a2)
{
  return __fxstat64(3, a1, a2);
}
// 80490C0: using guessed type int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD);

//----- (08054797) --------------------------------------------------------
#error "80547D0: positive sp value has been found (funcsize=18)"

//----- (08054836) --------------------------------------------------------
#error "805483C: positive sp value has been found (funcsize=0)"

//----- (080548A4) --------------------------------------------------------
#error "80548AA: positive sp value has been found (funcsize=0)"

//----- (080548EE) --------------------------------------------------------
#error "8054927: positive sp value has been found (funcsize=18)"

//----- (0805492F) --------------------------------------------------------
#error "8054935: positive sp value has been found (funcsize=0)"

//----- (080549A1) --------------------------------------------------------
#error "80549A7: positive sp value has been found (funcsize=0)"

//----- (08054A0F) --------------------------------------------------------
#error "8054A15: positive sp value has been found (funcsize=0)"

//----- (08054A83) --------------------------------------------------------
#error "8054A89: positive sp value has been found (funcsize=0)"

//----- (08054AF3) --------------------------------------------------------
#error "8054AF9: positive sp value has been found (funcsize=0)"

//----- (08054B67) --------------------------------------------------------
#error "8054B6D: positive sp value has been found (funcsize=0)"

//----- (08054BD7) --------------------------------------------------------
#error "8054BDD: positive sp value has been found (funcsize=0)"

//----- (08054C29) --------------------------------------------------------
#error "8054C62: positive sp value has been found (funcsize=18)"

//----- (08054C6A) --------------------------------------------------------
#error "8054C70: positive sp value has been found (funcsize=0)"

//----- (08054CDA) --------------------------------------------------------
#error "8054CE0: positive sp value has been found (funcsize=0)"

//----- (08054D67) --------------------------------------------------------
#error "8054D6D: positive sp value has been found (funcsize=0)"

//----- (08054DDB) --------------------------------------------------------
#error "8054DE1: positive sp value has been found (funcsize=0)"

//----- (08054E51) --------------------------------------------------------
#error "8054E57: positive sp value has been found (funcsize=0)"

//----- (08054EBD) --------------------------------------------------------
#error "8054EC3: positive sp value has been found (funcsize=0)"

//----- (08054F2B) --------------------------------------------------------
#error "8054F31: positive sp value has been found (funcsize=0)"

//----- (08054FB6) --------------------------------------------------------
#error "8054FBC: positive sp value has been found (funcsize=0)"

//----- (08054FD0) --------------------------------------------------------
int (**sub_8054FD0())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_805AEBC;
  v1 = &off_805AEC0 - off_805AEBC;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_805AEBC[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 805AEBC: using guessed type int (*off_805AEBC[2])();
// 805AEC0: using guessed type int (*off_805AEC0)();

//----- (08055034) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 38 decompilation failure(s) on 254 function(s)"
