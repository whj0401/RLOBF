/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8048F10();
// int __cdecl freopen64(_DWORD, _DWORD, _DWORD); weak
// int dup2(int fd, int fd2);
// int strcmp(const char *s1, const char *s2);
// int __cdecl open64(_DWORD, _DWORD); weak
// ssize_t read(int fd, void *buf, size_t nbytes);
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void _exit(int status);
// void free(void *ptr);
// uintmax_t strtoumax(const char *nptr, char **endptr, int base);
// void *memcpy(void *dest, const void *src, size_t n);
// int ferror(FILE *stream);
// int fclose(FILE *stream);
// int getc_unlocked(FILE *stream);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// int __cdecl stpcpy(_DWORD, _DWORD); weak
// __uid_t getuid(void);
// char *textdomain(const char *domainname);
// int __cdecl fopen64(_DWORD, _DWORD); weak
// int ferror_unlocked(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD); weak
// size_t __ctype_get_mb_cur_max(void);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// size_t __fpending(FILE *fp);
// __pid_t getpid(void);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// void error(int status, int errnum, const char *format, ...);
// size_t fread_unlocked(void *ptr, size_t size, size_t n, FILE *stream);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int __freading(FILE *fp);
// void exit(int status);
// int __cdecl ftello64(_DWORD); weak
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// char *strchr(const char *s, int c);
// size_t strlen(const char *s);
// int fprintf(FILE *stream, const char *format, ...);
// int fcntl(int fd, int cmd, ...);
// __gid_t getgid(void);
// void *memset(void *s, int c, size_t n);
// int *__errno_location(void);
// void *memchr(const void *s, int c, size_t n);
// int fileno(FILE *stream);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// char *strrchr(const char *s, int c);
// __pid_t getppid(void);
// int __cdecl explicit_bzero(_DWORD, _DWORD); weak
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// char *bindtextdomain(const char *domainname, const char *dirname);
// int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// int feof_unlocked(FILE *stream);
// void abort(void);
// int close(int fd);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// void *calloc(size_t nmemb, size_t size);
// int _gmon_start__(void); weak
void sub_8049423();
void sub_8049440();
int sub_8049450();
int sub_80494C0();
int sub_80494E0();
void sub_804953F();
void sub_804955A();
signed int sub_804956A();
void sub_804964C();
void sub_8049667();
int sub_8049677();
void sub_8049759();
void sub_8049774();
int sub_8049784();
void sub_8049866();
void sub_8049881();
int sub_8049891();
void sub_8049973();
void sub_804998E();
int sub_804999E();
int sub_8049A28();
void sub_8049A9C();
void sub_8049AB7();
signed int sub_8049AC7();
void sub_8049BBE();
void sub_8049BD9();
int sub_8049BE9();
void sub_8049CCB();
void sub_8049CE6();
int sub_8049CF6();
// int __usercall sub_8049DA8@<eax>(void (__cdecl *a1)(int *)@<eax>);
void sub_8049E06();
void sub_8049E21();
int sub_8049E31();
void sub_8049F25();
void sub_8049F40();
int sub_8049F50();
void sub_804A044();
void sub_804A05F();
int sub_804A06F();
void sub_804A17F();
void sub_804A19A();
int __fastcall sub_804A1AA(int a1, int a2);
// int __usercall sub_804A275@<eax>(void (__cdecl *a1)(int *)@<eax>);
void sub_804A2C1();
void sub_804A2DC();
int sub_804A2EC();
int sub_804A376();
void sub_804A3FC();
void sub_804A417();
int sub_804A427();
int sub_804A4B1();
void sub_804A525();
void sub_804A540();
int sub_804A550();
// int __usercall sub_804A5D0@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
int sub_804A60C();
void sub_804A680();
void sub_804A69B();
int sub_804A6AB();
int nullsub_4(void); // weak
int sub_804A709();
void sub_804A7BB();
void sub_804A7D6();
int sub_804A7E6();
// int __usercall sub_804A866@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
void sub_804A8FD();
void sub_804A918();
int sub_804A928();
int nullsub_6(void); // weak
int sub_804A986();
int sub_804A9CB();
int sub_804AA0D();
int sub_804AA38();
int __cdecl sub_804AA63(char *s1); // idb
_BOOL4 __cdecl sub_804AC1B(int a1);
void __cdecl sub_804AC6C(int a1, __int64 a2);
void __cdecl __noreturn sub_804AC9F(int status); // idb
void *__cdecl sub_804ADD6(int a1, signed int a2, char a3);
char *__cdecl sub_804AE9E(void *s, int a2, size_t n);
signed __int64 sub_804AECF();
void __cdecl __noreturn sub_804AFA5(FILE *stream, int a2, int a3);
signed int __cdecl sub_804B1F7(unsigned int a1, int a2, int a3);
unsigned int __cdecl sub_804B278(FILE *stream, int a2, int a3);
int __cdecl sub_804B3D2(unsigned int a1, int a2, int a3);
signed int __cdecl sub_804B478(unsigned int a1, int a2, int a3, char a4);
signed int __cdecl sub_804B4DF(int a1, unsigned int a2, int a3, int a4, char a5);
signed int __cdecl sub_804B567(int a1, int a2, int a3, unsigned int a4);
void __cdecl __noreturn main(int argc, char **argv);
int sub_804C0A1(); // weak
int sub_804C2A2();
int __cdecl sub_804C3B4(int a1, int a2, int a3, int a4, int a5, int a6);
void __cdecl sub_804C405(FILE *stream, int a2);
int __cdecl sub_804C44D(int a1);
FILE *__cdecl sub_804C4B5(int a1, int a2, FILE *stream);
void *__cdecl sub_804C641(void *s);
int __cdecl sub_804C686(int, FILE *stream, int); // idb
void __cdecl sub_804C7A7(int a1);
char *__cdecl sub_804C7BD(char *s);
// int __usercall sub_804C93B@<eax>(int a1@<edx>, int a2@<ecx>, int a3, unsigned __int8 a4, char a5);
void __cdecl sub_804C9FE(int a1, int a2, int a3);
int sub_804CA61(); // weak
void __cdecl __noreturn sub_804CA75(int a1, int a2);
int __stdcall sub_804CAB4(int); // weak
const char *__cdecl sub_804CB10(char *msgid, int a2);
int __cdecl sub_804CBC0(int a1, unsigned int a2, char *a3, int a4, signed int a5, int a6, int a7, char *a8, char *a9);
void *__cdecl sub_804DC85(char *a1, int a2, _DWORD *a3, int *a4);
void *__cdecl sub_804DE45(signed int a1, char *a2, int a3, int a4);
void *__cdecl sub_804E06E(signed int a1, char *a2);
void *__cdecl sub_804E098(signed int a1, char *a2, int a3);
void __cdecl __noreturn sub_804E0FE(int a1, int a2);
void __cdecl __noreturn sub_804E13C(int a1, int a2);
// void *__usercall sub_804E1C4@<eax>(int a1@<edx>, int a2@<ecx>, char *a3, int a4, unsigned __int8 a5);
// void *__usercall sub_804E26E@<eax>(int a1@<edx>, int a2@<ecx>, char *a3, unsigned __int8 a4);
// void *__usercall sub_804E297@<eax>(int a1@<edx>, int a2@<ecx>, char *a3);
void __cdecl __noreturn sub_804E2D4(int a1, int a2);
void *__cdecl sub_804E375(signed int a1, int a2, int a3, char *a4);
void *__cdecl sub_804E3A5(signed int a1, int a2, int a3, char *a4, int a5);
void *__cdecl sub_804E49F(signed int a1, char *a2, int a3);
void *__cdecl sub_804E4EA(signed int a1, char *a2);
void *__cdecl sub_804E50C(char *a1);
_DWORD *__cdecl sub_804E527(int a1);
_DWORD *__cdecl sub_804E56C(int a1, size_t n);
__int64 __cdecl sub_804E5AB(__int64 a1);
void __cdecl sub_804E5CC(int a1, __int64 a2);
int __cdecl sub_804E849(int, int, int); // weak
// void __usercall sub_804E97D(int a1@<ebp>);
// void __usercall sub_804E9AE(int a1@<ebp>);
int sub_804E9D1(); // weak
void __cdecl sub_804E9DC(void *ptr);
void __cdecl sub_804EA3C(int a1, __int64 a2);
int __cdecl sub_804EA6F(int a1);
unsigned int __cdecl sub_804EA99(int a1, int a2);
int __cdecl sub_804EAC8(int a1, int a2, int a3);
int __cdecl sub_804EB1A(_DWORD *a1, unsigned int a2);
bool __cdecl sub_804EB37(_DWORD *a1, _DWORD *a2);
int __cdecl sub_804EB5A(unsigned int a1);
int __cdecl sub_804EB8D(unsigned int *a1, int a2, int a3, int a4);
// void __usercall sub_804EC96(int a1@<edx>, int a2@<ecx>, void *a3);
void *__cdecl sub_804ECA9(int a1, unsigned int a2, unsigned int a3);
void __cdecl __noreturn sub_804EE8C(char *a1);
_DWORD *__cdecl sub_804EEF5(int a1, int a2);
int __cdecl sub_804EF2A(int a1, int a2, size_t nbytes);
int __cdecl sub_804F1B5(int, size_t n); // idb
int __cdecl sub_804F369(int, void *ptr, size_t n); // idb
int __cdecl sub_804F41F(int, void *dest, size_t n); // idb
int __cdecl sub_804F52E(int, void *ptr, size_t n); // idb
int __cdecl sub_804F576(void *ptr); // idb
int __cdecl sub_804F5BC(int a1);
int __cdecl sub_804F5D3(int a1, __int16 a2);
unsigned int *__cdecl sub_804F604(unsigned int *a1, int *a2);
// _DWORD *__usercall sub_804FAA9@<eax>(int a1@<edx>, int a2@<ecx>, _DWORD *a3);
void *__cdecl sub_804FECA(FILE *stream, int a2);
void *__cdecl sub_80501BF(int a1, int a2, int a3);
int __cdecl sub_80502A3(FILE *stream, int, int, int, int, int); // idb
int __cdecl sub_8050853(FILE *stream, int, int, int, int); // idb
int sub_80508CE(FILE *stream, int a2, int a3, int a4, ...);
void __cdecl sub_805096E(int a1, unsigned int a2);
int sub_805099D(); // weak
void *__cdecl sub_80509AE(void *ptr, int a2, int a3);
void *__cdecl sub_80509E3(void *ptr, int a2, int a3);
void *__cdecl sub_8050A93(size_t size);
void *__cdecl sub_8050AA6(size_t size);
void *__cdecl sub_8050AD0(void *ptr, size_t size);
void *__cdecl sub_8050B66(void *ptr, int a2);
void __cdecl __noreturn sub_8050BB2(size_t nmemb, size_t size); // idb
int sub_8050C03(); // weak
void *__cdecl sub_8050C08(void *src, size_t n);
void __noreturn sub_8050C56();
unsigned __int64 __cdecl sub_8050C8F(char *nptr, int base, int a3, int a4, int a5, int a6, char *s, int a8, int a9);
unsigned __int64 __cdecl sub_8050DFB(char *nptr, int a2, int a3, int a4, int a5, char *s, int a7, int a8);
signed int __cdecl sub_8050E5F(unsigned int *a1, unsigned int a2);
int __cdecl sub_8050EA3(unsigned int *a1, unsigned int a2, int a3);
int __cdecl sub_8050EEE(char *nptr, int, int base, int, char *s); // idb
int __cdecl sub_80513A2(_DWORD *a1, signed int a2);
int __cdecl sub_8051443(_DWORD *a1, signed int a2, int a3);
int __cdecl sub_80514A7(char *nptr, int, int base, int, char *s); // idb
int __cdecl sub_805194F(FILE *stream); // idb
int __cdecl sub_8051A12(FILE *stream); // idb
int __cdecl sub_8051A4B(FILE *fp); // idb
int __cdecl sub_8051A8B(FILE *stream, int, int, int); // idb
size_t __cdecl sub_8051B5D(wchar_t *pwc, char *s, size_t n, mbstate_t *p);
int __cdecl sub_8051BCF(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_8051C34(FILE *fp); // idb
FILE *__cdecl sub_8051CE3(int a1, char *modes);
int __cdecl sub_8051DE3(int category); // idb
int __cdecl sub_8051E41(int a1);
int __cdecl sub_8051E4C(int a1);
int __cdecl sub_8051E57(int a1);
unsigned int __cdecl sub_8051E62(int a1);
int __cdecl sub_8052049(int a1, int a2);
bool __cdecl sub_80522FB(unsigned int a1);
// unsigned int __usercall sub_8052352@<eax>(int a1@<edx>, int a2@<ecx>, unsigned int a3);
unsigned int __cdecl sub_80523F1(int a1, unsigned int a2);
bool __cdecl sub_805241C(int a1, int a2);
signed int __cdecl sub_805242A(int a1);
// unsigned int __usercall sub_80524E6@<eax>(signed __int64 a1@<edx:eax>, int a2@<ecx>, unsigned int a3, int a4);
int __cdecl sub_8052573(unsigned int a1, void *a2, unsigned int (__cdecl *a3)(int a1, unsigned int a2), bool (__cdecl *a4)(int a1, int a2), int a5);
// void __usercall sub_8052777(int a1@<edx>, int a2@<ecx>, void *a3);
void *__cdecl sub_80528D8(int a1);
int __cdecl sub_8052913(int a1, _DWORD *a2);
int __cdecl sub_8052936(int a1, int a2, _DWORD *a3);
signed int __cdecl sub_8052ADE(int a1, int a2, char a3);
// signed int __usercall sub_8052C8C@<eax>(signed __int64 a1@<edx:eax>, int a2@<ecx>, int a3, unsigned int a4);
signed int __cdecl sub_8052E5A(unsigned int *a1, int a2, _DWORD *a3);
int __cdecl sub_80530B0(unsigned int *a1, int a2);
int __cdecl sub_805311D(int a1, int a2);
void *sub_8053302();
const char *sub_80537F7();
int __cdecl sub_80538C3(int fd); // idb
int __cdecl sub_80538E6(int fd, int cmd, char); // idb
int __cdecl sub_8053B8D(int a1, char a2);
int __cdecl sub_8053F0B(int a1);
signed __int64 __cdecl sub_8053F60(unsigned __int64 a1, unsigned int a2, unsigned int a3);
char *__cdecl sub_80540AE(unsigned __int64 a1, __int64 a2);
int __cdecl sub_80542B1(int a1);
int __cdecl sub_80542E0(int a1, int a2);
int __fastcall sub_80543E8(_DWORD, _DWORD); // weak
int sub_8054473(void); // weak
int sub_8054506(void); // weak
int __fastcall sub_8054576(_DWORD, _DWORD); // weak
int sub_80545E2(void); // weak
int __fastcall sub_805465C(_DWORD, _DWORD); // weak
int sub_80546E7(void); // weak
int sub_805475B(void); // weak
int sub_80547EC(void); // weak
int __fastcall sub_805487F(_DWORD, _DWORD); // weak
int sub_805490C(void); // weak
int __fastcall sub_8054980(_DWORD, _DWORD); // weak
int sub_80549F2(void); // weak
int sub_8054A66(void); // weak
int __fastcall sub_8054AE0(_DWORD); // weak
int sub_8054B6D(void); // weak
int (**sub_8054B80())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN locret_804A1B9; // weak
_UNKNOWN locret_804A55F; // weak
_UNKNOWN locret_804A7F5; // weak
_UNKNOWN loc_804AADA; // weak
_UNKNOWN loc_804AB18; // weak
_UNKNOWN loc_804ABA4; // weak
_UNKNOWN loc_804ABBF; // weak
_UNKNOWN loc_804AC49; // weak
_UNKNOWN loc_804AC5B; // weak
_UNKNOWN loc_804ADCB; // weak
_UNKNOWN loc_804AF08; // weak
_UNKNOWN loc_804AF17; // weak
_UNKNOWN locret_804B476; // weak
_UNKNOWN loc_804B618; // weak
_UNKNOWN loc_804B61F; // weak
_UNKNOWN loc_804B623; // weak
_UNKNOWN loc_804B731; // weak
_UNKNOWN loc_804B741; // weak
_UNKNOWN loc_804B78B; // weak
_UNKNOWN loc_804B7BC; // weak
_UNKNOWN loc_804BB02; // weak
_UNKNOWN loc_804BB09; // weak
_UNKNOWN loc_804BB6B; // weak
_UNKNOWN loc_804BBF0; // weak
_UNKNOWN loc_804BC20; // weak
_UNKNOWN loc_804BC5D; // weak
_UNKNOWN loc_804BC64; // weak
_UNKNOWN loc_804BD66; // weak
_UNKNOWN loc_804BD86; // weak
_UNKNOWN loc_804BDED; // weak
_UNKNOWN loc_804BE35; // weak
_UNKNOWN loc_804BE5B; // weak
_UNKNOWN loc_804BE62; // weak
_UNKNOWN loc_804C026; // weak
_UNKNOWN loc_804C060; // weak
_UNKNOWN loc_804C2E5; // weak
_UNKNOWN loc_804C30A; // weak
_UNKNOWN loc_804C390; // weak
_UNKNOWN loc_804C48B; // weak
_UNKNOWN loc_804C4AE; // weak
_UNKNOWN loc_804C56A; // weak
_UNKNOWN loc_804C573; // weak
_UNKNOWN loc_804C5B4; // weak
_UNKNOWN loc_804C5D0; // weak
_UNKNOWN loc_804C726; // weak
_UNKNOWN loc_804C728; // weak
_UNKNOWN loc_804C828; // weak
_UNKNOWN loc_804C830; // weak
_UNKNOWN loc_804C96E; // weak
_UNKNOWN loc_804C973; // weak
_UNKNOWN loc_804CAAF; // weak
_UNKNOWN locret_804CBBE; // weak
_UNKNOWN loc_804CC39; // weak
_UNKNOWN loc_804CCE6; // weak
_UNKNOWN loc_804CD12; // weak
_UNKNOWN loc_804CD25; // weak
_UNKNOWN loc_804CD68; // weak
_UNKNOWN loc_804CDC3; // weak
_UNKNOWN loc_804CDC7; // weak
_UNKNOWN loc_804CDF2; // weak
_UNKNOWN loc_804CE09; // weak
_UNKNOWN loc_804CE24; // weak
_UNKNOWN loc_804CE30; // weak
_UNKNOWN loc_804D9D8; // weak
_UNKNOWN loc_804DA03; // weak
_UNKNOWN loc_804DA08; // weak
_UNKNOWN loc_804DAC5; // weak
_UNKNOWN loc_804DAFC; // weak
_UNKNOWN loc_804DB4E; // weak
_UNKNOWN loc_804DB55; // weak
_UNKNOWN loc_804DB9E; // weak
_UNKNOWN loc_804E639; // weak
_UNKNOWN loc_804E6A0; // weak
_UNKNOWN loc_804E7E1; // weak
_UNKNOWN loc_804ECCF; // weak
_UNKNOWN loc_804ECD6; // weak
_UNKNOWN loc_804EE87; // weak
_UNKNOWN loc_804EFAE; // weak
_UNKNOWN loc_804EFB9; // weak
_UNKNOWN loc_804F027; // weak
_UNKNOWN loc_804F08A; // weak
_UNKNOWN loc_804F0ED; // weak
_UNKNOWN loc_804F150; // weak
_UNKNOWN locret_804F1B3; // weak
_UNKNOWN loc_804F1FA; // weak
_UNKNOWN locret_804F341; // weak
_UNKNOWN loc_804F343; // weak
_UNKNOWN loc_804F3CB; // weak
_UNKNOWN loc_804F3CD; // weak
_UNKNOWN loc_804FCBB; // weak
_UNKNOWN loc_804FF5C; // weak
_UNKNOWN loc_804FF61; // weak
_UNKNOWN loc_804FFDC; // weak
_UNKNOWN loc_804FFF8; // weak
_UNKNOWN loc_805014A; // weak
_UNKNOWN loc_805019D; // weak
_UNKNOWN locret_80501BD; // weak
_UNKNOWN loc_8050234; // weak
_UNKNOWN loc_8050249; // weak
_UNKNOWN loc_8050312; // weak
_UNKNOWN loc_80507F3; // weak
_UNKNOWN loc_805087B; // weak
_UNKNOWN loc_8050A10; // weak
_UNKNOWN loc_8050A4A; // weak
_UNKNOWN loc_8050AF5; // weak
_UNKNOWN loc_8050B22; // weak
_UNKNOWN loc_8050B56; // weak
_UNKNOWN loc_8050B61; // weak
_UNKNOWN locret_8050B64; // weak
_UNKNOWN loc_8050BFE; // weak
_UNKNOWN loc_8050D73; // weak
_UNKNOWN loc_8050D7E; // weak
_UNKNOWN loc_8050DD0; // weak
_UNKNOWN loc_8050EDC; // weak
_UNKNOWN loc_8050F6F; // weak
_UNKNOWN loc_8050F7C; // weak
_UNKNOWN loc_8050FB3; // weak
_UNKNOWN loc_8051008; // weak
_UNKNOWN loc_8051050; // weak
_UNKNOWN loc_805108A; // weak
_UNKNOWN loc_8051094; // weak
_UNKNOWN loc_805109B; // weak
_UNKNOWN loc_805117E; // weak
_UNKNOWN loc_8051199; // weak
_UNKNOWN loc_80511A6; // weak
_UNKNOWN loc_8051370; // weak
_UNKNOWN locret_80513A0; // weak
_UNKNOWN loc_805143B; // weak
_UNKNOWN loc_8051467; // weak
_UNKNOWN loc_805147C; // weak
_UNKNOWN loc_80514A2; // weak
_UNKNOWN loc_80514DF; // weak
_UNKNOWN loc_805150A; // weak
_UNKNOWN loc_8051617; // weak
_UNKNOWN loc_8051688; // weak
_UNKNOWN loc_80516A1; // weak
_UNKNOWN loc_8051CAA; // weak
_UNKNOWN loc_8051CDC; // weak
_UNKNOWN locret_8051CE1; // weak
_UNKNOWN loc_8051D1D; // weak
_UNKNOWN loc_8051DDE; // weak
_UNKNOWN locret_8051DE1; // weak
_UNKNOWN loc_8052380; // weak
_UNKNOWN loc_8052384; // weak
_UNKNOWN loc_80523B5; // weak
_UNKNOWN locret_80526A7; // weak
_UNKNOWN loc_80527D6; // weak
_UNKNOWN loc_80527FD; // weak
_UNKNOWN loc_8052801; // weak
_UNKNOWN loc_8052836; // weak
_UNKNOWN loc_8052850; // weak
_UNKNOWN loc_805286F; // weak
_UNKNOWN loc_80528B8; // weak
_UNKNOWN loc_8052981; // weak
_UNKNOWN loc_805298B; // weak
_UNKNOWN loc_8052B21; // weak
_UNKNOWN loc_8052BB5; // weak
_UNKNOWN loc_8052BE6; // weak
_UNKNOWN loc_8052BEB; // weak
_UNKNOWN loc_8052C76; // weak
_UNKNOWN loc_8052E41; // weak
_UNKNOWN loc_8052E46; // weak
_UNKNOWN loc_8052FF8; // weak
_UNKNOWN loc_8053002; // weak
_UNKNOWN loc_80530F7; // weak
_UNKNOWN loc_80530FC; // weak
_UNKNOWN loc_8053232; // weak
_UNKNOWN loc_805326C; // weak
_UNKNOWN loc_8053573; // weak
_UNKNOWN loc_8053578; // weak
_UNKNOWN loc_80537BE; // weak
_UNKNOWN loc_8053823; // weak
_UNKNOWN loc_80538AD; // weak
_UNKNOWN loc_80539C2; // weak
_UNKNOWN loc_8053FA6; // weak
_UNKNOWN loc_8053FB1; // weak
_UNKNOWN loc_8053FF0; // weak
_UNKNOWN loc_80540E9; // weak
_UNKNOWN loc_805411F; // weak
_UNKNOWN loc_8054262; // weak
_UNKNOWN loc_8054298; // weak
char s = '\0'; // idb
struct option longopts = { "echo", 0, NULL, 101 }; // idb
_UNKNOWN unk_8055536; // weak
_UNKNOWN unk_805553A; // weak
_UNKNOWN unk_8055546; // weak
_UNKNOWN unk_805554A; // weak
_UNKNOWN unk_805554D; // weak
_UNKNOWN unk_8056018; // weak
_UNKNOWN unk_805610F; // weak
_UNKNOWN unk_80571DC; // weak
_UNKNOWN unk_80571DF; // weak
int dword_8057EF8 = 135151872; // weak
int dword_8058EE8 = 192152696; // weak
int (*off_805AEC0[2])() = { &sub_80494E0, &sub_80494C0 }; // weak
int (*off_805AEC4)() = &sub_80494C0; // weak
Elf32_Dyn stru_805AF04 = { 1879047925, { 134513068u } }; // weak
Elf32_Dyn stru_805AF0C = { 5, { 134514556u } }; // weak
int (*dword_805B008)(void) = NULL; // weak
int dword_805B148 = 0; // weak
int dword_805B15C = 0; // weak
int dword_805B170 = 0; // weak
int dword_805B184 = 0; // weak
int dword_805B198 = 0; // weak
int dword_805B1AC = 0; // weak
int dword_805B1C0 = 0; // weak
int dword_805B1D4 = 0; // weak
int dword_805B1E8 = 0; // weak
int dword_805B1FC = 0; // weak
int dword_805B210 = 0; // weak
int dword_805B224 = 0; // weak
int dword_805B238 = 0; // weak
int dword_805B24C = 0; // weak
int dword_805B260 = 0; // weak
int dword_805B274 = 0; // weak
int (*dword_805B284)(void) = NULL; // weak
int dword_805B29C = 0; // weak
int off_805B2A0 = 134566898; // idb
int status = 1; // idb
int dword_805B2B8 = 1; // weak
int dword_805B2BC = 256; // weak
void *off_805B2C0 = &unk_805B92A; // weak
int *off_805B2C4 = &dword_805B2BC; // weak
_UNKNOWN unk_805B2D8; // weak
_UNKNOWN unk_805B2F4; // weak
_UNKNOWN unk_805B2F7; // weak
_UNKNOWN unk_805B2F8; // weak
_UNKNOWN unk_805B2FB; // weak
_UNKNOWN unk_805B300; // weak
_UNKNOWN unk_805B303; // weak
_UNKNOWN unk_805B308; // weak
_UNKNOWN unk_805B30B; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int program_invocation_name; // weak
int optind; // weak
FILE *stdin; // idb
FILE *stdout; // idb
char *optarg; // idb
char byte_805B36C; // weak
_UNKNOWN unk_805B3BD; // weak
char byte_805B4ED; // weak
_UNKNOWN unk_805B625; // weak
char byte_805B755; // weak
char byte_805B7A2; // weak
char byte_805B7EF; // weak
char byte_805B8D6; // weak
int dword_805B8DA; // weak
char byte_805B8DE; // weak
int dword_805B8E2; // weak
int dword_805B8EA; // weak
int dword_805B8EE; // weak
int dword_805B8F2; // weak
int dword_805B8F6; // weak
int dword_805B8FA; // weak
int dword_805B8FE; // weak
int dword_805B902; // weak
int dword_805B906; // weak
int dword_805B90A; // weak
int dword_805B90E; // weak
int dword_805B912; // weak
int dword_805B916; // weak
_UNKNOWN unk_805B92A; // weak
int dword_805BA2A; // weak
int dword_805BA2E; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (08048EEC) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 80493E0: using guessed type int _gmon_start__(void);

//----- (08048F10) --------------------------------------------------------
int sub_8048F10()
{
  return dword_805B008();
}
// 805B008: using guessed type int (*dword_805B008)(void);

//----- (080493F0) --------------------------------------------------------
#error "80493F3: positive sp value has been found (funcsize=2)"

//----- (08049423) --------------------------------------------------------
void sub_8049423()
{
  ;
}

//----- (08049440) --------------------------------------------------------
void sub_8049440()
{
  ;
}

//----- (08049450) --------------------------------------------------------
int sub_8049450()
{
  int result; // eax

  result = &unk_805B30B - &unk_805B308;
  if ( (unsigned int)(&unk_805B30B - &unk_805B308) > 6 )
    result = 0;
  return result;
}
// 8049450: could not find valid save-restore pair for ebp

//----- (080494C0) --------------------------------------------------------
int sub_80494C0()
{
  int result; // eax

  if ( !byte_805B36C )
  {
    result = sub_8049450();
    byte_805B36C = 1;
  }
  return result;
}
// 80494C0: could not find valid save-restore pair for ebp
// 805B36C: using guessed type char byte_805B36C;

//----- (080494E0) --------------------------------------------------------
int sub_80494E0()
{
  return 0;
}
// 80494E0: could not find valid save-restore pair for ebp

//----- (0804953F) --------------------------------------------------------
void sub_804953F()
{
  ;
}

//----- (0804955A) --------------------------------------------------------
void sub_804955A()
{
  ;
}

//----- (0804956A) --------------------------------------------------------
signed int sub_804956A()
{
  return 3;
}
// 804956A: could not find valid save-restore pair for ebp

//----- (0804964C) --------------------------------------------------------
void sub_804964C()
{
  ;
}

//----- (08049667) --------------------------------------------------------
void sub_8049667()
{
  ;
}

//----- (08049677) --------------------------------------------------------
int sub_8049677()
{
  int result; // eax

  result = &unk_805B3BD - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_805B3BD - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 8049677: could not find valid save-restore pair for ebp
// 805B320: using guessed type int program_invocation_short_name;

//----- (08049759) --------------------------------------------------------
void sub_8049759()
{
  ;
}

//----- (08049774) --------------------------------------------------------
void sub_8049774()
{
  ;
}

//----- (08049784) --------------------------------------------------------
int sub_8049784()
{
  int result; // eax

  result = &unk_805B2F7 - &unk_805B2F4;
  if ( (unsigned int)(&unk_805B2F7 - &unk_805B2F4) > 6 )
    result = 0;
  return result;
}
// 8049784: could not find valid save-restore pair for ebp

//----- (08049866) --------------------------------------------------------
void sub_8049866()
{
  ;
}

//----- (08049881) --------------------------------------------------------
void sub_8049881()
{
  ;
}

//----- (08049891) --------------------------------------------------------
int sub_8049891()
{
  int result; // eax

  result = &unk_805B2F7 - &unk_805B2F4;
  if ( (unsigned int)(&unk_805B2F7 - &unk_805B2F4) > 6 )
    result = 0;
  return result;
}
// 8049891: could not find valid save-restore pair for ebp

//----- (08049973) --------------------------------------------------------
void sub_8049973()
{
  ;
}

//----- (0804998E) --------------------------------------------------------
void sub_804998E()
{
  ;
}

//----- (0804999E) --------------------------------------------------------
int sub_804999E()
{
  int result; // eax

  result = &unk_805B2F7 - &unk_805B2F4;
  if ( (unsigned int)(&unk_805B2F7 - &unk_805B2F4) > 6 )
    result = 0;
  return result;
}
// 804999E: could not find valid save-restore pair for ebp

//----- (08049A28) --------------------------------------------------------
int sub_8049A28()
{
  int result; // eax

  result = sub_804999E();
  byte_805B4ED = 1;
  return result;
}
// 805B4ED: using guessed type char byte_805B4ED;

//----- (08049A9C) --------------------------------------------------------
void sub_8049A9C()
{
  ;
}

//----- (08049AB7) --------------------------------------------------------
void sub_8049AB7()
{
  ;
}

//----- (08049AC7) --------------------------------------------------------
signed int sub_8049AC7()
{
  return 3;
}
// 8049AC7: could not find valid save-restore pair for ebp

//----- (08049BBE) --------------------------------------------------------
void sub_8049BBE()
{
  ;
}

//----- (08049BD9) --------------------------------------------------------
void sub_8049BD9()
{
  ;
}

//----- (08049BE9) --------------------------------------------------------
int sub_8049BE9()
{
  int result; // eax

  result = &unk_805B2F7 - &unk_805B2F4;
  if ( (unsigned int)(&unk_805B2F7 - &unk_805B2F4) > 6 )
    result = 0;
  return result;
}
// 8049BE9: could not find valid save-restore pair for ebp

//----- (08049CCB) --------------------------------------------------------
void sub_8049CCB()
{
  ;
}

//----- (08049CE6) --------------------------------------------------------
void sub_8049CE6()
{
  ;
}

//----- (08049CF6) --------------------------------------------------------
int sub_8049CF6()
{
  int result; // eax

  result = &unk_805B2F7 - &unk_805B2F4;
  if ( (unsigned int)(&unk_805B2F7 - &unk_805B2F4) > 6 )
    result = 0;
  return result;
}
// 8049CF6: could not find valid save-restore pair for ebp

//----- (08049DA8) --------------------------------------------------------
int __usercall sub_8049DA8@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  a1(&dword_8058EE8);
  return 0;
}
// 8058EE8: using guessed type int dword_8058EE8;

//----- (08049E06) --------------------------------------------------------
void sub_8049E06()
{
  ;
}

//----- (08049E21) --------------------------------------------------------
void sub_8049E21()
{
  ;
}

//----- (08049E31) --------------------------------------------------------
int sub_8049E31()
{
  int result; // eax

  result = &unk_805B2F7 - &unk_805B2F4;
  if ( (unsigned int)(&unk_805B2F7 - &unk_805B2F4) > 6 )
    result = 0;
  return result;
}
// 8049E31: could not find valid save-restore pair for ebp

//----- (08049F25) --------------------------------------------------------
void sub_8049F25()
{
  ;
}

//----- (08049F40) --------------------------------------------------------
void sub_8049F40()
{
  ;
}

//----- (08049F50) --------------------------------------------------------
int sub_8049F50()
{
  int result; // eax

  result = &unk_805B625 - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_805B625 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 8049F50: could not find valid save-restore pair for ebp
// 805B320: using guessed type int program_invocation_short_name;

//----- (0804A044) --------------------------------------------------------
void sub_804A044()
{
  ;
}

//----- (0804A05F) --------------------------------------------------------
void sub_804A05F()
{
  ;
}

//----- (0804A06F) --------------------------------------------------------
int sub_804A06F()
{
  int result; // eax

  result = &unk_805B2F7 - &unk_805B2F4;
  if ( (unsigned int)(&unk_805B2F7 - &unk_805B2F4) > 6 )
    result = 0;
  return result;
}
// 804A06F: could not find valid save-restore pair for ebp

//----- (0804A17F) --------------------------------------------------------
void sub_804A17F()
{
  ;
}

//----- (0804A19A) --------------------------------------------------------
void sub_804A19A()
{
  ;
}

//----- (0804A1AA) --------------------------------------------------------
int __fastcall sub_804A1AA(int a1, int a2)
{
  int result; // eax
  int (__stdcall *v3)(void *, int, int, int, int, int); // eax
  int v4; // [esp+4h] [ebp-18h]
  int v5; // [esp+8h] [ebp-14h]
  int v6; // [esp+Ch] [ebp-10h]
  int v7; // [esp+10h] [ebp-Ch]
  int v8; // [esp+14h] [ebp-8h]
  int v9; // [esp+18h] [ebp-4h]

  result = &unk_805B2F7 - &unk_805B2F4;
  if ( (unsigned int)(&unk_805B2F7 - &unk_805B2F4) > 6 )
  {
    v9 = 0;
    dword_805B198 = (int)&locret_804A1B9;
    v3 = (int (__stdcall *)(void *, int, int, int, int, int))sub_8054980(a1, a2);
    result = v3(&unk_805B2F4, v4, v5, v6, v7, v8);
  }
  return result;
}
// 8054980: using guessed type int __fastcall sub_8054980(_DWORD, _DWORD);
// 805B198: using guessed type int dword_805B198;

//----- (0804A275) --------------------------------------------------------
int __usercall sub_804A275@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  a1(&dword_8057EF8);
  return 0;
}
// 8057EF8: using guessed type int dword_8057EF8;

//----- (0804A2C1) --------------------------------------------------------
void sub_804A2C1()
{
  ;
}

//----- (0804A2DC) --------------------------------------------------------
void sub_804A2DC()
{
  ;
}

//----- (0804A2EC) --------------------------------------------------------
int sub_804A2EC()
{
  int result; // eax

  result = &unk_805B2F7 - &unk_805B2F4;
  if ( (unsigned int)(&unk_805B2F7 - &unk_805B2F4) > 6 )
    result = 0;
  return result;
}
// 804A2EC: could not find valid save-restore pair for ebp

//----- (0804A376) --------------------------------------------------------
int sub_804A376()
{
  int result; // eax

  result = sub_804A2EC();
  byte_805B755 = 1;
  return result;
}
// 805B755: using guessed type char byte_805B755;

//----- (0804A3FC) --------------------------------------------------------
void sub_804A3FC()
{
  ;
}

//----- (0804A417) --------------------------------------------------------
void sub_804A417()
{
  ;
}

//----- (0804A427) --------------------------------------------------------
int sub_804A427()
{
  int result; // eax

  result = &unk_805B2F7 - &unk_805B2F4;
  if ( (unsigned int)(&unk_805B2F7 - &unk_805B2F4) > 6 )
    result = 0;
  return result;
}
// 804A427: could not find valid save-restore pair for ebp

//----- (0804A4B1) --------------------------------------------------------
int sub_804A4B1()
{
  int result; // eax

  result = sub_804A427();
  byte_805B7A2 = 1;
  return result;
}
// 805B7A2: using guessed type char byte_805B7A2;

//----- (0804A525) --------------------------------------------------------
void sub_804A525()
{
  ;
}

//----- (0804A540) --------------------------------------------------------
void sub_804A540()
{
  ;
}

//----- (0804A550) --------------------------------------------------------
int sub_804A550()
{
  int result; // eax
  int (__stdcall *v1)(void *, int, int, int, int, int); // eax
  int v2; // [esp+4h] [ebp-18h]
  int v3; // [esp+8h] [ebp-14h]
  int v4; // [esp+Ch] [ebp-10h]
  int v5; // [esp+10h] [ebp-Ch]
  int v6; // [esp+14h] [ebp-8h]
  int v7; // [esp+18h] [ebp-4h]

  result = &unk_80571DF - &unk_80571DC;
  if ( (unsigned int)(&unk_80571DF - &unk_80571DC) > 6 )
  {
    v7 = 0;
    dword_805B1E8 = (int)&locret_804A55F;
    v1 = (int (__stdcall *)(void *, int, int, int, int, int))sub_805475B();
    result = v1(&unk_80571DC, v2, v3, v4, v5, v6);
  }
  return result;
}
// 805475B: using guessed type int sub_805475B(void);
// 805B1E8: using guessed type int dword_805B1E8;

//----- (0804A5D0) --------------------------------------------------------
int __usercall sub_804A5D0@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_80571DC, a1);
}

//----- (0804A60C) --------------------------------------------------------
int sub_804A60C()
{
  int result; // eax

  result = sub_804A550();
  byte_805B7EF = 1;
  return result;
}
// 805B7EF: using guessed type char byte_805B7EF;

//----- (0804A680) --------------------------------------------------------
void sub_804A680()
{
  ;
}

//----- (0804A69B) --------------------------------------------------------
void sub_804A69B()
{
  ;
}

//----- (0804A6AB) --------------------------------------------------------
int sub_804A6AB()
{
  int result; // eax

  result = &unk_805B2F7 - &unk_805B2F4;
  if ( (unsigned int)(&unk_805B2F7 - &unk_805B2F4) > 6 )
    result = 0;
  return result;
}
// 804A6AB: could not find valid save-restore pair for ebp

//----- (0804A709) --------------------------------------------------------
int sub_804A709()
{
  return nullsub_4();
}
// 804A709: could not find valid save-restore pair for ebp
// 804A708: using guessed type int nullsub_4(void);

//----- (0804A7BB) --------------------------------------------------------
void sub_804A7BB()
{
  ;
}

//----- (0804A7D6) --------------------------------------------------------
void sub_804A7D6()
{
  ;
}

//----- (0804A7E6) --------------------------------------------------------
int sub_804A7E6()
{
  int result; // eax
  int (__stdcall *v1)(void *, int, int, int, int, int); // eax
  int v2; // [esp+4h] [ebp-18h]
  int v3; // [esp+8h] [ebp-14h]
  int v4; // [esp+Ch] [ebp-10h]
  int v5; // [esp+10h] [ebp-Ch]
  int v6; // [esp+14h] [ebp-8h]
  int v7; // [esp+18h] [ebp-4h]

  result = &unk_805B2FB - &unk_805B2F8;
  if ( (unsigned int)(&unk_805B2FB - &unk_805B2F8) > 6 )
  {
    v7 = 0;
    dword_805B1E8 = (int)&locret_804A7F5;
    v1 = (int (__stdcall *)(void *, int, int, int, int, int))sub_805475B();
    result = v1(&unk_805B2F8, v2, v3, v4, v5, v6);
  }
  return result;
}
// 805475B: using guessed type int sub_805475B(void);
// 805B1E8: using guessed type int dword_805B1E8;

//----- (0804A866) --------------------------------------------------------
int __usercall sub_804A866@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_805B2F8, a1);
}

//----- (0804A8FD) --------------------------------------------------------
void sub_804A8FD()
{
  ;
}

//----- (0804A918) --------------------------------------------------------
void sub_804A918()
{
  ;
}

//----- (0804A928) --------------------------------------------------------
int sub_804A928()
{
  int result; // eax

  result = &unk_805B303 - &unk_805B300;
  if ( (unsigned int)(&unk_805B303 - &unk_805B300) > 6 )
    result = 0;
  return result;
}
// 804A928: could not find valid save-restore pair for ebp

//----- (0804A986) --------------------------------------------------------
int sub_804A986()
{
  return nullsub_6();
}
// 804A986: could not find valid save-restore pair for ebp
// 804A985: using guessed type int nullsub_6(void);

//----- (0804A9CB) --------------------------------------------------------
int sub_804A9CB()
{
  int result; // eax

  result = sub_804A928();
  byte_805B8D6 = 1;
  return result;
}
// 805B8D6: using guessed type char byte_805B8D6;

//----- (0804AA0D) --------------------------------------------------------
int sub_804AA0D()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nWith no FILE, or when FILE is -, read standard input.\n");
  return fputs_unlocked(v1, v0);
}
// 80491E0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804AA38) --------------------------------------------------------
int sub_804AA38()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nMandatory arguments to long options are mandatory for short options too.\n");
  return fputs_unlocked(v1, v0);
}
// 80491E0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804AA63) --------------------------------------------------------
int __cdecl sub_804AA63(char *s1)
{
  bool v1; // zf
  int v2; // edx
  int v3; // ecx
  void *v4; // eax
  char *v5; // eax
  void *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // ebx
  char *v10; // eax
  const char *v12; // [esp+1Ch] [ebp-4Ch]
  const char *v13; // [esp+24h] [ebp-44h]
  const char *v14; // [esp+28h] [ebp-40h]
  const char *v15; // [esp+2Ch] [ebp-3Ch]
  const char *v16; // [esp+30h] [ebp-38h]
  const char *v17; // [esp+34h] [ebp-34h]
  const char *v18; // [esp+38h] [ebp-30h]
  const char *v19; // [esp+3Ch] [ebp-2Ch]
  const char *v20; // [esp+40h] [ebp-28h]
  const char *v21; // [esp+44h] [ebp-24h]
  const char *v22; // [esp+48h] [ebp-20h]
  const char *v23; // [esp+4Ch] [ebp-1Ch]
  const char *v24; // [esp+50h] [ebp-18h]
  const char *v25; // [esp+54h] [ebp-14h]
  int v26; // [esp+58h] [ebp-10h]
  int v27; // [esp+5Ch] [ebp-Ch]

  v14 = "[";
  v15 = "test invocation";
  v16 = "coreutils";
  v17 = "Multi-call invocation";
  v18 = "sha224sum";
  v19 = "sha2 utilities";
  v20 = "sha256sum";
  v21 = "sha2 utilities";
  v22 = "sha384sum";
  v23 = "sha2 utilities";
  v24 = "sha512sum";
  v25 = "sha2 utilities";
  v26 = 0;
  v27 = 0;
  v12 = s1;
  if ( "[" )
  {
    v1 = strcmp(s1, v14) == 0;
    v4 = &loc_804AB18;
    if ( !v1 )
      v4 = &loc_804AADA;
    dword_805B1C0 = (int)v4;
    sub_805487F(v3, v2);
  }
  if ( v15 )
    v12 = v15;
  v5 = gettext("\n%s online help: <%s>\n");
  printf(v5, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  v13 = setlocale(5, 0);
  if ( v13 )
  {
    v1 = strncmp(v13, "en_", 3u) == 0;
    v6 = &loc_804ABA4;
    if ( v1 )
      v6 = &loc_804ABBF;
    dword_805B1FC = (int)v6;
    sub_80546E7();
    v7 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
    printf(v7, s1);
  }
  v8 = gettext("Full documentation at: <%s%s>\n");
  printf(v8, "http://www.gnu.org/software/coreutils/", s1);
  if ( v12 == s1 )
    v9 = " invocation";
  else
    v9 = &s;
  v10 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  return printf(v10, v12, v9);
}
// 80546E7: using guessed type int sub_80546E7(void);
// 805487F: using guessed type int __fastcall sub_805487F(_DWORD, _DWORD);
// 805B1C0: using guessed type int dword_805B1C0;
// 805B1FC: using guessed type int dword_805B1FC;

//----- (0804AC1B) --------------------------------------------------------
_BOOL4 __cdecl sub_804AC1B(int a1)
{
  void *v1; // eax

  v1 = &loc_804AC49;
  if ( (*(_DWORD *)(a1 + 16) & 0xF000) == 0x8000 )
    v1 = &loc_804AC5B;
  dword_805B148 = (int)v1;
  sub_8054B6D();
  return (*(_DWORD *)(a1 + 16) & 0xF000) == 40960;
}
// 8054B6D: using guessed type int sub_8054B6D(void);
// 805B148: using guessed type int dword_805B148;

//----- (0804AC6C) --------------------------------------------------------
void __cdecl sub_804AC6C(int a1, __int64 a2)
{
  sub_804E5CC(a1, a2 - 1);
}

//----- (0804AC9F) --------------------------------------------------------
void __cdecl __noreturn sub_804AC9F(int status)
{
  int v1; // ebx
  char *v2; // eax
  int v3; // edx
  int v4; // ecx
  int v5; // edi
  int v6; // esi
  int v7; // ebx
  char *v8; // eax
  FILE *v9; // ebx
  char *v10; // eax
  FILE *v11; // ebx
  char *v12; // eax
  FILE *v13; // ebx
  char *v14; // eax
  FILE *v15; // ebx
  char *v16; // eax
  FILE *v17; // ebx
  char *v18; // eax
  int v19; // [esp+4h] [ebp-24h]
  int v20; // [esp+8h] [ebp-20h]
  int v21; // [esp+Ch] [ebp-1Ch]

  if ( status )
  {
    v1 = dword_805B8E2;
    v2 = gettext("Try '%s --help' for more information.\n");
    v20 = v1;
    fprintf(stderr, v2, v1);
    dword_805B210 = (int)&loc_804ADCB;
    sub_805465C(v4, v3);
  }
  v5 = dword_805B8E2;
  v6 = dword_805B8E2;
  v7 = dword_805B8E2;
  v8 = gettext("Usage: %s [OPTION]... [FILE]\n  or:  %s -e [OPTION]... [ARG]...\n  or:  %s -i LO-HI [OPTION]...\n");
  v21 = v5;
  v20 = v6;
  v19 = v7;
  printf(v8, v7, v6, v5);
  v9 = stdout;
  v10 = gettext("Write a random permutation of the input lines to standard output.\n");
  fputs_unlocked(v10, v9);
  sub_804AA0D();
  sub_804AA38();
  v11 = stdout;
  v12 = gettext(
          "  -e, --echo                treat each ARG as an input line\n"
          "  -i, --input-range=LO-HI   treat each number LO through HI as an input line\n"
          "  -n, --head-count=COUNT    output at most COUNT lines\n"
          "  -o, --output=FILE         write result to FILE instead of standard output\n"
          "      --random-source=FILE  get random bytes from FILE\n"
          "  -r, --repeat              output lines can be repeated\n");
  fputs_unlocked(v12, v11);
  v13 = stdout;
  v14 = gettext("  -z, --zero-terminated     line delimiter is NUL, not newline\n");
  fputs_unlocked(v14, v13);
  v15 = stdout;
  v16 = gettext("      --help     display this help and exit\n");
  fputs_unlocked(v16, v15);
  v17 = stdout;
  v18 = gettext("      --version  output version information and exit\n");
  fputs_unlocked(v18, v17);
  sub_804AA63("shuf");
  exit(status);
}
// 80491E0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 805465C: using guessed type int __fastcall sub_805465C(_DWORD, _DWORD);
// 805B210: using guessed type int dword_805B210;
// 805B8E2: using guessed type int dword_805B8E2;

//----- (0804ADD6) --------------------------------------------------------
void *__cdecl sub_804ADD6(int a1, signed int a2, char a3)
{
  _BYTE *v3; // ST1C_4
  void *result; // eax
  void *v5; // [esp+10h] [ebp-18h]
  size_t size; // [esp+14h] [ebp-14h]
  signed int i; // [esp+18h] [ebp-10h]
  signed int j; // [esp+18h] [ebp-10h]

  size = a2;
  for ( i = 0; i < a2; ++i )
    size += strlen(*(const char **)(4 * i + a1));
  v5 = sub_8050AA6(size);
  for ( j = 0; j < a2; ++j )
  {
    v3 = (_BYTE *)stpcpy(v5, *(_DWORD *)(4 * j + a1));
    *(_DWORD *)(a1 + 4 * j) = v5;
    v5 = v3 + 1;
    *v3 = a3;
  }
  result = v5;
  *(_DWORD *)(a1 + 4 * a2) = v5;
  return result;
}
// 8049040: using guessed type int __cdecl stpcpy(_DWORD, _DWORD);

//----- (0804AE9E) --------------------------------------------------------
char *__cdecl sub_804AE9E(void *s, int a2, size_t n)
{
  return (char *)memchr(s, (char)a2, n) + 1;
}

//----- (0804AECF) --------------------------------------------------------
signed __int64 sub_804AECF()
{
  bool v0; // zf
  void *v1; // eax
  char v3; // [esp+20h] [ebp-68h]

  v0 = sub_80542E0(0, (int)&v3) == 0;
  v1 = &loc_804AF08;
  if ( v0 )
    v1 = &loc_804AF17;
  dword_805B260 = (int)v1;
  sub_8054473();
  return 0x7FFFFFFFFFFFFFFFLL;
}
// 8054473: using guessed type int sub_8054473(void);
// 805B260: using guessed type int dword_805B260;

//----- (0804AFA5) --------------------------------------------------------
void __cdecl __noreturn sub_804AFA5(FILE *stream, int a2, int a3)
{
  int v3; // eax

  v3 = 1024;
  if ( (unsigned int)a3 <= 0x400 )
    v3 = a3;
  sub_8050BB2(v3, 0xCu);
}

//----- (0804B1F7) --------------------------------------------------------
signed int __cdecl sub_804B1F7(unsigned int a1, int a2, int a3)
{
  int v3; // ST1C_4
  unsigned int i; // [esp+18h] [ebp-10h]

  for ( i = 0; i < a1; ++i )
  {
    v3 = 12 * *(_DWORD *)(4 * i + a3) + a2;
    if ( fwrite_unlocked(*(const void **)(v3 + 8), 1u, *(_DWORD *)(v3 + 4), stdout) != *(_DWORD *)(v3 + 4) )
      return -1;
  }
  return 0;
}

//----- (0804B278) --------------------------------------------------------
unsigned int __cdecl sub_804B278(FILE *stream, int a2, int a3)
{
  char *v3; // ebx
  int *v4; // eax
  int v5; // eax
  _DWORD *v6; // eax
  void **v7; // ebx
  int v9; // [esp+14h] [ebp-24h]
  void *s; // [esp+18h] [ebp-20h]
  unsigned int v11; // [esp+1Ch] [ebp-1Ch]
  unsigned int i; // [esp+20h] [ebp-18h]
  _BYTE *v13; // [esp+24h] [ebp-14h]
  unsigned int v14; // [esp+28h] [ebp-10h]
  _DWORD *v15; // [esp+2Ch] [ebp-Ch]

  v13 = 0;
  v13 = sub_804FECA(stream, (int)&v9);
  if ( !v13 )
  {
    v3 = gettext("read error");
    v4 = __errno_location();
    error(1, *v4, v3);
  }
  if ( v9 && v13[v9 - 1] != (_BYTE)a2 )
  {
    v5 = v9++;
    v13[v5] = a2;
  }
  v14 = (unsigned int)&v13[v9];
  v11 = 0;
  for ( s = v13; (unsigned int)s < v14; s = sub_804AE9E(s, (char)a2, v14 - (_DWORD)s) )
    ++v11;
  sub_805096E(v11 + 1, 4u);
  v15 = v6;
  *(_DWORD *)a3 = v6;
  s = v13;
  *v15 = v13;
  for ( i = 1; i <= v11; ++i )
  {
    v7 = (void **)&v15[i];
    s = sub_804AE9E(s, (char)a2, v14 - (_DWORD)s);
    *v7 = s;
  }
  return v11;
}

//----- (0804B3D2) --------------------------------------------------------
int __cdecl sub_804B3D2(unsigned int a1, int a2, int a3)
{
  int v3; // ST18_4
  int n; // ST1C_4
  int v5; // edx
  int v6; // ecx
  unsigned int i; // [esp+14h] [ebp-14h]

  for ( i = 0; i < a1; ++i )
  {
    v3 = 4 * *(_DWORD *)(4 * i + a3) + a2;
    n = *(_DWORD *)(v3 + 4) - *(_DWORD *)v3;
    if ( fwrite_unlocked(*(const void **)v3, 1u, n, stdout) != n )
    {
      dword_805B238 = (int)&locret_804B476;
      sub_8054576(v6, v5);
    }
  }
  return 0;
}
// 8054576: using guessed type int __fastcall sub_8054576(_DWORD, _DWORD);
// 805B238: using guessed type int dword_805B238;

//----- (0804B478) --------------------------------------------------------
signed int __cdecl sub_804B478(unsigned int a1, int a2, int a3, char a4)
{
  unsigned int i; // [esp+18h] [ebp-10h]

  for ( i = 0; i < a1; ++i )
  {
    if ( printf("%lu%c", *(_DWORD *)(4 * i + a3) + a2, a4) < 0 )
      return -1;
  }
  return 0;
}

//----- (0804B4DF) --------------------------------------------------------
signed int __cdecl sub_804B4DF(int a1, unsigned int a2, int a3, int a4, char a5)
{
  int v5; // eax
  unsigned int i; // [esp+10h] [ebp-18h]
  __int64 v8; // [esp+18h] [ebp-10h]

  v8 = (unsigned int)(a4 - a3 + 1);
  for ( i = 0; i < a2; ++i )
  {
    sub_804AC6C(a1, (unsigned int)v8);
    if ( printf("%lu%c", v5 + a3, a5) < 0 )
      return -1;
  }
  return 0;
}

//----- (0804B567) --------------------------------------------------------
signed int __cdecl sub_804B567(int a1, int a2, int a3, unsigned int a4)
{
  int v4; // eax
  int v5; // edx
  size_t v6; // eax
  bool v7; // zf
  void *v8; // eax
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  size_t n; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]

  v10 = 0;
  dword_805B1AC = (int)&loc_804B623;
  sub_805490C();
  sub_804AC6C(a1, a4);
  v13 = v4;
  v14 = v5;
  v11 = 4 * v4 + a3;
  n = *(_DWORD *)(v11 + 4) - *(_DWORD *)v11;
  v6 = fwrite_unlocked(*(const void **)v11, 1u, n, stdout);
  v7 = v6 == n;
  v8 = &loc_804B618;
  if ( v7 )
    v8 = &loc_804B61F;
  dword_805B1E8 = (int)v8;
  sub_805475B();
  return -1;
}
// 805475B: using guessed type int sub_805475B(void);
// 805490C: using guessed type int sub_805490C(void);
// 805B1AC: using guessed type int dword_805B1AC;
// 805B1E8: using guessed type int dword_805B1E8;

//----- (0804B636) --------------------------------------------------------
void __cdecl __noreturn main(int argc, char **argv)
{
  void *v2; // eax
  void *v3; // eax
  int v4; // eax
  bool v5; // zf
  void *v6; // eax
  int v7; // edx
  int v8; // ecx
  int v9; // eax
  _DWORD *v10; // ebx
  char *v11; // eax
  char *v12; // eax
  char *v13; // eax
  int v14; // ecx
  int v15; // edx
  void *v16; // eax
  char *v17; // eax
  char v18; // al
  void *v19; // eax
  char v20; // al
  _DWORD *v21; // ebx
  char *v22; // eax
  void *v23; // eax
  int v24; // ecx
  void *v25; // eax
  void *v26; // eax
  signed __int64 v27; // rax
  void *v28; // eax
  unsigned int v29; // eax
  unsigned int v30; // eax
  char *v31; // ebx
  int *v32; // eax
  int (*v33)(); // eax
  int v34; // ecx
  int (*v35)(); // eax
  char *v36; // [esp+0h] [ebp-88h]
  const char *v37; // [esp+8h] [ebp-80h]
  _DWORD *v38; // [esp+Ch] [ebp-7Ch]
  int *v39; // [esp+10h] [ebp-78h]
  int v40; // [esp+14h] [ebp-74h]
  char v41; // [esp+2Eh] [ebp-5Ah]
  char v42; // [esp+2Fh] [ebp-59h]
  char v43; // [esp+30h] [ebp-58h]
  char v44; // [esp+31h] [ebp-57h]
  char v45; // [esp+32h] [ebp-56h]
  int v46; // [esp+34h] [ebp-54h]
  int v47; // [esp+38h] [ebp-50h]
  int v48; // [esp+3Ch] [ebp-4Ch]
  int v49; // [esp+40h] [ebp-48h]
  int v50; // [esp+44h] [ebp-44h]
  unsigned int v51; // [esp+48h] [ebp-40h]
  const char *v52; // [esp+4Ch] [ebp-3Ch]
  const char *v53; // [esp+50h] [ebp-38h]
  unsigned int v54; // [esp+54h] [ebp-34h]
  const char **v55; // [esp+58h] [ebp-30h]
  void *v56; // [esp+5Ch] [ebp-2Ch]
  int v57; // [esp+68h] [ebp-20h]
  int v58; // [esp+70h] [ebp-18h]
  int v59; // [esp+74h] [ebp-14h]
  const char **v60; // [esp+78h] [ebp-10h]
  _DWORD *v61; // [esp+7Ch] [ebp-Ch]

  v41 = 0;
  v42 = 0;
  v49 = -1;
  v50 = 0;
  v51 = -1;
  v52 = 0;
  v53 = 0;
  v43 = 10;
  v46 = 0;
  v44 = 0;
  v45 = 0;
  v55 = 0;
  v47 = 0;
  v56 = 0;
  sub_804C7BD(*argv);
  setlocale(6, &s);
  bindtextdomain("coreutils", "/home/hwangdz/coreutils/coreutils-8.28/install_m32/share/locale");
  textdomain("coreutils");
  sub_80542B1((int)sub_804C2A2);
  while ( 1 )
  {
    while ( 1 )
    {
      v57 = getopt_long(argc, argv, "ei:n:o:rz", &longopts, 0);
      if ( v57 == -1 )
      {
        v59 = argc - optind;
        v15 = 4 * optind;
        v60 = (const char **)&argv[optind];
        if ( v41 )
        {
          v16 = &loc_804BBF0;
          if ( !v42 )
            v16 = &loc_804BC20;
          dword_805B198 = (int)v16;
          sub_8054980(v14, v15);
          v17 = gettext("cannot combine -e and -i options");
          error(0, 0, v17);
          sub_804AC9F(1);
        }
        if ( v42 )
        {
          v18 = v59 > 0;
        }
        else
        {
          if ( v41 == 1 )
          {
            v20 = 0;
          }
          else
          {
            v19 = &loc_804BC5D;
            if ( v59 <= 1 )
              v19 = &loc_804BC64;
            dword_805B198 = (int)v19;
            sub_8054980(v14, v15);
            v20 = 1;
          }
          v18 = v20 & 1;
        }
        if ( v18 )
        {
          v36 = (char *)v60[(unsigned __int8)(v42 ^ 1)];
          v21 = sub_804E50C(v36);
          v22 = gettext("extra operand %s");
          v38 = v21;
          error(0, 0, v22, v21);
          sub_804AC9F(1);
        }
        if ( v41 )
        {
          sub_804ADD6((int)v60, v59, v43);
          v54 = v59;
          v55 = v60;
        }
        else if ( v42 )
        {
          v54 = v50 - v49 + 1;
          v55 = 0;
        }
        else
        {
          if ( v59 == 1 )
          {
            v5 = strcmp(*v60, "-") == 0;
            v23 = &loc_804BD66;
            if ( v5 )
              v23 = &loc_804BDED;
            dword_805B1E8 = (int)v23;
            sub_805475B();
            v25 = &loc_804BD86;
            if ( !v51 )
              v25 = &loc_804BDED;
            dword_805B15C = (int)v25;
            sub_8054AE0(v24);
            if ( !sub_804C4B5((int)*v60, (int)"r", stdin) )
            {
              v37 = *v60;
              sub_804E2D4(0, 3);
            }
          }
          sub_804C405(stdin, 2);
          if ( v45 == 1 || v51 == -1 )
            goto LABEL_101;
          v26 = &loc_804BE35;
          if ( !v51 )
            v26 = &loc_804BE62;
          dword_805B1FC = (int)v26;
          sub_80546E7();
          v27 = sub_804AECF();
          if ( v27 < 0 )
            goto LABEL_101;
          LODWORD(v27) = &loc_804BE5B;
          if ( SHIDWORD(v27) > 0 )
            v28 = &loc_804BE62;
          dword_805B224 = (int)v28;
          if ( (unsigned int)sub_80545E2() <= 0x800000 )
          {
LABEL_101:
            v54 = sub_804B278(stdin, v43, (int)&v46);
            v55 = (const char **)v46;
          }
          else
          {
            v44 = 1;
            v54 = -1;
          }
        }
        if ( v45 != 1 )
        {
          v29 = v51;
          if ( v54 <= v51 )
            v29 = v54;
          v51 = v29;
        }
        if ( v44 == 1 || v45 == 1 )
          v30 = -1;
        else
          v30 = sub_804EA99(v51, v54);
        v61 = sub_804E56C((int)v53, v30);
        if ( !v61 )
        {
          v37 = v53;
          sub_804E2D4(0, 3);
        }
        if ( v44 )
        {
          v39 = &v47;
          v38 = v61;
          sub_804AFA5(stdin, v43, v51);
        }
        if ( v41 != 1 && v42 != 1 && sub_805194F(stdin) )
        {
          v31 = gettext("read error");
          v32 = __errno_location();
          error(1, *v32, v31);
        }
        if ( v45 != 1 )
          v56 = sub_804ECA9((int)v61, v51, v54);
        v33 = (int (*)())&loc_804C026;
        if ( !v52 )
          v33 = sub_804C0A1;
        dword_805B1D4 = (int)v33;
        sub_80547EC();
        v5 = sub_804C4B5((int)v52, (int)"w", stdout) == 0;
        v35 = (int (*)())&loc_804C060;
        if ( !v5 )
          v35 = sub_804C0A1;
        dword_805B15C = (int)v35;
        sub_8054AE0(v34);
        v37 = v52;
        sub_804E2D4(0, 3);
      }
      if ( v57 != 110 )
        break;
      v58 = sub_8050EEE(optarg, 0, 10, (int)&v48, 0);
      if ( v58 )
      {
        if ( v58 != 1 )
        {
          v10 = sub_804E50C(optarg);
          v11 = gettext("invalid line count: %s");
          v38 = v10;
          error(1, 0, v11, v10);
        }
      }
      else
      {
        v9 = v51;
        if ( v48 <= v51 )
          v9 = v48;
        v51 = v9;
      }
    }
    if ( v57 <= 110 )
      break;
    v3 = &loc_804B78B;
    if ( v57 == 114 )
      v3 = &loc_804BB02;
    dword_805B15C = (int)v3;
    v4 = sub_8054AE0(v14);
    if ( v4 > 114 )
    {
      v5 = v4 == 122;
      v6 = &loc_804B7BC;
      if ( v5 )
        v6 = &loc_804BB09;
      dword_805B1D4 = (int)v6;
      if ( sub_80547EC() != 128 )
        goto LABEL_36;
      if ( v53 && strcmp(v53, optarg) )
      {
        v13 = gettext("multiple random sources specified");
        error(1, 0, v13);
      }
      v53 = optarg;
      dword_805B198 = (int)&loc_804BB6B;
      sub_8054980(v8, v7);
      v45 = 1;
    }
    else
    {
      if ( v4 != 111 )
        goto LABEL_36;
      if ( v52 && strcmp(v52, optarg) )
      {
        v12 = gettext("multiple output files specified");
        error(1, 0, v12);
      }
      v52 = optarg;
    }
  }
  if ( v57 == -130 )
    sub_804AC9F(0);
  v2 = &loc_804B731;
  if ( v57 > -130 )
    v2 = &loc_804B741;
  dword_805B1AC = (int)v2;
  if ( sub_805490C() == -131 )
  {
    v40 = 0;
    v39 = (int *)"Paul Eggert";
    sub_80508CE(stdout, (int)"shuf", (int)"GNU coreutils", off_805B2A0, "Paul Eggert", 0);
    exit(0);
  }
LABEL_36:
  sub_804AC9F(1);
}
// 804C0A1: using guessed type int sub_804C0A1();
// 80545E2: using guessed type int sub_80545E2(void);
// 80546E7: using guessed type int sub_80546E7(void);
// 805475B: using guessed type int sub_805475B(void);
// 80547EC: using guessed type int sub_80547EC(void);
// 805490C: using guessed type int sub_805490C(void);
// 8054980: using guessed type int __fastcall sub_8054980(_DWORD, _DWORD);
// 8054AE0: using guessed type int __fastcall sub_8054AE0(_DWORD);
// 805B15C: using guessed type int dword_805B15C;
// 805B198: using guessed type int dword_805B198;
// 805B1AC: using guessed type int dword_805B1AC;
// 805B1D4: using guessed type int dword_805B1D4;
// 805B1E8: using guessed type int dword_805B1E8;
// 805B1FC: using guessed type int dword_805B1FC;
// 805B224: using guessed type int dword_805B224;
// 805B340: using guessed type int optind;

//----- (0804C2A2) --------------------------------------------------------
int sub_804C2A2()
{
  int v0; // edx
  int v1; // ecx
  void *v2; // eax
  bool v3; // zf
  void *v4; // eax
  int v5; // edx
  int v6; // ecx
  void *v7; // ebx
  int *v8; // eax
  int *v9; // eax
  int result; // eax
  char *v11; // [esp+2Ch] [ebp-Ch]

  if ( sub_8051C34(stdout) )
  {
    v2 = &loc_804C2E5;
    if ( byte_805B8DE != 1 )
      v2 = &loc_804C30A;
    dword_805B1C0 = (int)v2;
    sub_805487F(v1, v0);
    v3 = *__errno_location() == 32;
    v4 = &loc_804C30A;
    if ( v3 )
      v4 = &loc_804C390;
    dword_805B1D4 = (int)v4;
    sub_80547EC();
    v11 = gettext("write error");
    if ( dword_805B8DA )
    {
      v7 = sub_804E297(v5, v6, (char *)dword_805B8DA);
      v8 = __errno_location();
      error(0, *v8, "%s: %s", v7, v11);
    }
    else
    {
      v9 = __errno_location();
      error(0, *v9, "%s", v11);
    }
    _exit(status);
  }
  result = sub_8051C34(stderr);
  if ( result )
    _exit(status);
  return result;
}
// 80547EC: using guessed type int sub_80547EC(void);
// 805487F: using guessed type int __fastcall sub_805487F(_DWORD, _DWORD);
// 805B1C0: using guessed type int dword_805B1C0;
// 805B1D4: using guessed type int dword_805B1D4;
// 805B8DA: using guessed type int dword_805B8DA;
// 805B8DE: using guessed type char byte_805B8DE;

//----- (0804C3B4) --------------------------------------------------------
int __cdecl sub_804C3B4(int a1, int a2, int a3, int a4, int a5, int a6)
{
  return posix_fadvise64(a1, a2, a3, a4, a5, a6);
}
// 8049360: using guessed type int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804C405) --------------------------------------------------------
void __cdecl sub_804C405(FILE *stream, int a2)
{
  int v2; // eax

  if ( stream )
  {
    v2 = fileno(stream);
    sub_804C3B4(v2, 0, 0, 0, 0, a2);
  }
}

//----- (0804C44D) --------------------------------------------------------
int __cdecl sub_804C44D(int a1)
{
  int v1; // eax
  bool v2; // zf
  void *v3; // eax
  int fd; // [esp+1Ch] [ebp-Ch]

  v1 = open64("/dev/null", 0);
  fd = v1;
  v2 = v1 == a1;
  v3 = &loc_804C48B;
  if ( v2 )
    v3 = &loc_804C4AE;
  dword_805B184 = (int)v3;
  sub_80549F2();
  if ( fd >= 0 )
  {
    close(fd);
    *__errno_location() = 9;
  }
  return 0;
}
// 8048F50: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 80549F2: using guessed type int sub_80549F2(void);
// 805B184: using guessed type int dword_805B184;

//----- (0804C4B5) --------------------------------------------------------
FILE *__cdecl sub_804C4B5(int a1, int a2, FILE *stream)
{
  int v3; // eax
  bool v4; // zf
  void *v5; // eax
  void *v6; // eax
  char v8; // [esp+19h] [ebp-Fh]
  char v9; // [esp+1Ah] [ebp-Eh]
  char v10; // [esp+1Bh] [ebp-Dh]
  int v11; // [esp+1Ch] [ebp-Ch]
  FILE *streama; // [esp+38h] [ebp+10h]

  v8 = 0;
  v9 = 0;
  v10 = 0;
  v3 = fileno(stream);
  if ( v3 != 1 )
  {
    if ( v3 != 2 )
    {
      if ( !v3 )
        goto LABEL_10;
      if ( dup2(2, 2) != 2 )
        v10 = 1;
    }
    if ( dup2(1, 1) != 1 )
      v9 = 1;
  }
  if ( dup2(0, 0) )
    v8 = 1;
LABEL_10:
  if ( v8 )
  {
    v4 = (unsigned __int8)sub_804C44D(0) == 1;
    v5 = &loc_804C56A;
    if ( v4 )
      v5 = &loc_804C573;
    dword_805B224 = (int)v5;
    sub_80545E2();
    streama = 0;
  }
  else if ( v9 && (unsigned __int8)sub_804C44D(1) ^ 1 )
  {
    streama = 0;
  }
  else
  {
    v6 = &loc_804C5B4;
    if ( !v10 )
      v6 = &loc_804C5D0;
    dword_805B1D4 = (int)v6;
    sub_80547EC();
    if ( (unsigned __int8)sub_804C44D(2) ^ 1 )
      streama = 0;
    else
      streama = (FILE *)freopen64(a1, a2, stream);
  }
  v11 = *__errno_location();
  if ( v10 )
    close(2);
  if ( v9 )
    close(1);
  if ( v8 )
    close(0);
  if ( !streama )
    *__errno_location() = v11;
  return streama;
}
// 8048F20: using guessed type int __cdecl freopen64(_DWORD, _DWORD, _DWORD);
// 80545E2: using guessed type int sub_80545E2(void);
// 80547EC: using guessed type int sub_80547EC(void);
// 805B1D4: using guessed type int dword_805B1D4;
// 805B224: using guessed type int dword_805B224;

//----- (0804C641) --------------------------------------------------------
void *__cdecl sub_804C641(void *s)
{
  return memset(s, 0, 0xCu);
}

//----- (0804C686) --------------------------------------------------------
int __cdecl sub_804C686(int a1, FILE *stream, int a3)
{
  int v4; // ecx
  void *v5; // eax
  int v6; // ST34_4
  _BYTE *v7; // eax
  int v8; // [esp+1Ch] [ebp-1Ch]
  char *ptr; // [esp+20h] [ebp-18h]
  int v10; // [esp+24h] [ebp-14h]
  int v11; // [esp+28h] [ebp-10h]

  ptr = *(char **)(a1 + 8);
  v10 = *(_DWORD *)(a1 + 8);
  v11 = (int)&ptr[*(_DWORD *)a1];
  if ( feof_unlocked(stream) )
    return 0;
  while ( 1 )
  {
    v8 = getc_unlocked(stream);
    if ( v8 == -1 )
      break;
    if ( v10 == v11 )
    {
      v6 = *(_DWORD *)a1;
      ptr = (char *)sub_8050B66(ptr, a1);
      v10 = (int)&ptr[v6];
      *(_DWORD *)(a1 + 8) = ptr;
      v11 = (int)&ptr[*(_DWORD *)a1];
    }
    v7 = (_BYTE *)v10++;
    *v7 = v8;
    if ( (char)a3 == v8 )
      goto LABEL_13;
  }
  if ( (char *)v10 == ptr || ferror_unlocked(stream) )
    return 0;
  v5 = &loc_804C726;
  if ( *(_BYTE *)(v10 - 1) != (_BYTE)a3 )
    v5 = &loc_804C728;
  dword_805B15C = (int)v5;
  sub_8054AE0(v4);
LABEL_13:
  *(_DWORD *)(a1 + 4) = v10 - (_DWORD)ptr;
  return a1;
}
// 8054AE0: using guessed type int __fastcall sub_8054AE0(_DWORD);
// 805B15C: using guessed type int dword_805B15C;

//----- (0804C7A7) --------------------------------------------------------
void __cdecl sub_804C7A7(int a1)
{
  free(*(void **)(a1 + 8));
}

//----- (0804C7BD) --------------------------------------------------------
char *__cdecl sub_804C7BD(char *s)
{
  char *v1; // eax
  int v2; // edx
  int v3; // ecx
  bool v4; // zf
  void *v5; // eax
  char *result; // eax
  char *v7; // [esp+18h] [ebp-10h]

  if ( !s )
  {
    fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
    abort();
  }
  v1 = strrchr(s, 47);
  v7 = v1;
  v4 = v1 == 0;
  v5 = &loc_804C828;
  if ( v4 )
    v5 = &loc_804C830;
  dword_805B238 = (int)v5;
  sub_8054576(v3, v2);
  if ( v7 + 1 - s > 6 && !strncmp(v7 - 6, "/.libs/", 7u) )
  {
    s = v7 + 1;
    if ( !strncmp(v7 + 1, "lt-", 3u) )
    {
      s = v7 + 4;
      program_invocation_short_name = (int)(v7 + 4);
    }
  }
  dword_805B8E2 = (int)s;
  result = s;
  program_invocation_name = (int)s;
  return result;
}
// 8054576: using guessed type int __fastcall sub_8054576(_DWORD, _DWORD);
// 805B238: using guessed type int dword_805B238;
// 805B320: using guessed type int program_invocation_short_name;
// 805B330: using guessed type int program_invocation_name;
// 805B8E2: using guessed type int dword_805B8E2;

//----- (0804C93B) --------------------------------------------------------
int __usercall sub_804C93B@<eax>(int a1@<edx>, int a2@<ecx>, int a3, unsigned __int8 a4, char a5)
{
  void *v5; // eax
  int v6; // ST18_4

  v5 = &loc_804C96E;
  if ( !a3 )
    v5 = &loc_804C973;
  dword_805B210 = (int)v5;
  sub_805465C(a2, a1);
  v6 = (*(_DWORD *)(4 * (a4 >> 5) + a3 + 8) >> (a4 & 0x1F)) & 1;
  *(_DWORD *)(4 * (a4 >> 5) + a3 + 8) ^= (v6 ^ a5 & 1) << (a4 & 0x1F);
  return v6;
}
// 805465C: using guessed type int __fastcall sub_805465C(_DWORD, _DWORD);
// 805B210: using guessed type int dword_805B210;

//----- (0804C9FE) --------------------------------------------------------
void __cdecl sub_804C9FE(int a1, int a2, int a3)
{
  JUMPOUT(a1, 0, &loc_804F343);
  dword_805B8EA = 10;
  JUMPOUT(a2, 0, &loc_804F343);
  dword_805B284 = (int (*)(void))sub_804CA61;
  JUMPOUT(a3, 0, &loc_804F343);
  abort();
}
// 804CA61: using guessed type int sub_804CA61();
// 805B284: using guessed type int (*dword_805B284)(void);
// 805B8EA: using guessed type int dword_805B8EA;

//----- (0804CA61) --------------------------------------------------------
#error "804CA74: positive sp value has been found (funcsize=0)"

//----- (0804CA75) --------------------------------------------------------
void __cdecl __noreturn sub_804CA75(int a1, int a2)
{
  int (__stdcall *v2)(int); // eax
  char v3; // [esp+0h] [ebp-38h]

  memset(&v3, 0, 0x30u);
  v2 = (int (__stdcall *)(int))&loc_804CAAF;
  if ( a2 != 10 )
    v2 = sub_804CAB4;
  dword_805B238 = (int)v2;
  sub_8054576(0, 12);
  abort();
}
// 804CAB4: using guessed type int __stdcall sub_804CAB4(int);
// 8054576: using guessed type int __fastcall sub_8054576(_DWORD, _DWORD);
// 805B238: using guessed type int dword_805B238;

//----- (0804CAB4) --------------------------------------------------------
#error "804CB0A: positive sp value has been found (funcsize=0)"

//----- (0804CB10) --------------------------------------------------------
const char *__cdecl sub_804CB10(char *msgid, int a2)
{
  const char *result; // eax
  char *v3; // [esp+18h] [ebp-10h]
  unsigned __int8 *v4; // [esp+1Ch] [ebp-Ch]

  v3 = gettext(msgid);
  if ( v3 != msgid )
  {
    dword_805B1AC = (int)&locret_804CBBE;
    sub_805490C();
  }
  v4 = (unsigned __int8 *)sub_80537F7();
  if ( sub_8051BCF(v4, "UTF-8") )
  {
    if ( sub_8051BCF(v4, "GB18030") )
    {
      if ( a2 == 9 )
        result = (const char *)&unk_805554D;
      else
        result = "'";
    }
    else if ( *msgid == 96 )
    {
      result = (const char *)&unk_8055546;
    }
    else
    {
      result = (const char *)&unk_805554A;
    }
  }
  else if ( *msgid == 96 )
  {
    result = (const char *)&unk_8055536;
  }
  else
  {
    result = (const char *)&unk_805553A;
  }
  return result;
}
// 805490C: using guessed type int sub_805490C(void);
// 805B1AC: using guessed type int dword_805B1AC;

//----- (0804CBC0) --------------------------------------------------------
int __cdecl sub_804CBC0(int a1, unsigned int a2, char *a3, int a4, signed int a5, int a6, int a7, char *a8, char *a9)
{
  char *v9; // edx
  int v10; // ecx
  void *v11; // eax
  void *v12; // eax
  int v13; // edx
  int v14; // ecx
  void *v15; // eax
  void *v16; // eax
  bool v17; // al
  bool v18; // zf
  void *v19; // eax
  void *v20; // eax
  int v21; // edx
  int v22; // ecx
  int result; // eax
  void *v24; // eax
  void *v25; // eax
  char *v26; // [esp+2Ch] [ebp-5Ch]
  char *v27; // [esp+30h] [ebp-58h]
  int v28; // [esp+34h] [ebp-54h]
  char *v29; // [esp+38h] [ebp-50h]
  char *v30; // [esp+3Ch] [ebp-4Ch]
  char v31; // [esp+40h] [ebp-48h]
  bool v32; // [esp+41h] [ebp-47h]
  char v33; // [esp+42h] [ebp-46h]
  char v34; // [esp+43h] [ebp-45h]
  char v35; // [esp+44h] [ebp-44h]
  bool v36; // [esp+4Bh] [ebp-3Dh]
  int v37; // [esp+50h] [ebp-38h]
  unsigned int v38; // [esp+54h] [ebp-34h]
  unsigned int v39; // [esp+58h] [ebp-30h]
  char *s; // [esp+5Ch] [ebp-2Ch]
  size_t n; // [esp+60h] [ebp-28h]
  unsigned int v42; // [esp+7Ch] [ebp-Ch]

  v30 = (char *)a1;
  v29 = a3;
  v28 = a7;
  v27 = a8;
  v26 = a9;
  v42 = __readgsdword(0x14u);
  v38 = 0;
  v39 = 0;
  s = 0;
  n = 0;
  v31 = 0;
  v36 = __ctype_get_mb_cur_max() == 1;
  v32 = (a6 & 2) != 0;
  v33 = 0;
  v34 = 0;
  v35 = 1;
  switch ( a5 )
  {
    case 0:
      v32 = 0;
      goto LABEL_28;
    case 1:
      goto LABEL_17;
    case 2:
      goto LABEL_21;
    case 3:
      goto LABEL_16;
    case 4:
      goto LABEL_18;
    case 5:
      goto LABEL_3;
    case 6:
      a5 = 5;
      v32 = 1;
LABEL_3:
      if ( v32 != 1 )
      {
        if ( v38 < a2 )
        {
          v9 = v30;
          v30[v38] = 34;
        }
        ++v38;
      }
      v31 = 1;
      s = (char *)&unk_805554D;
      n = 1;
      dword_805B198 = (int)&loc_804CE24;
      sub_8054980(v10, v9);
      goto LABEL_8;
    case 7:
LABEL_8:
      v31 = 1;
      v32 = 0;
      dword_805B1D4 = (int)&loc_804CE24;
      sub_80547EC();
      break;
    case 8:
    case 9:
    case 10:
      break;
    default:
      abort();
      return result;
  }
  v11 = &loc_804CCE6;
  if ( a5 == 10 )
    v11 = &loc_804CD12;
  dword_805B1FC = (int)v11;
  sub_80546E7();
  v27 = (char *)sub_804CB10("`", a5);
  v26 = (char *)sub_804CB10("'", a5);
  if ( v32 != 1 )
  {
    s = v27;
    v12 = &loc_804CD68;
    if ( *v27 )
      v12 = &loc_804CD25;
    dword_805B224 = (int)v12;
    sub_80545E2();
  }
  v31 = 1;
  s = v26;
  n = strlen(v26);
  dword_805B238 = (int)&loc_804CE24;
  sub_8054576(v14, v13);
LABEL_16:
  v31 = 1;
LABEL_17:
  v32 = 1;
LABEL_18:
  v15 = &loc_804CDC3;
  if ( v32 == 1 )
    v15 = &loc_804CDC7;
  dword_805B1D4 = (int)v15;
  sub_80547EC();
  v31 = 1;
LABEL_21:
  a5 = 2;
  v16 = &loc_804CDF2;
  if ( v32 == 1 )
    v16 = &loc_804CE09;
  dword_805B274 = (int)v16;
  sub_80543E8(v10, v9);
  if ( v38 < a2 )
  {
    v9 = v30;
    v30[v38] = 39;
  }
  ++v38;
  s = "'";
  n = 1;
LABEL_28:
  v37 = 0;
  if ( a4 == -1 )
  {
    v9 = v29;
    v17 = v29[v37] != 0;
  }
  else
  {
    v17 = v37 != a4;
  }
  v18 = v17 == 0;
  v19 = &loc_804D9D8;
  if ( !v18 )
    v19 = &loc_804CE30;
  dword_805B274 = (int)v19;
  sub_80543E8(v10, v9);
  if ( v38 || a5 != 2 )
  {
    if ( a5 == 2 && v32 != 1 && v34 )
    {
      if ( v35 )
        return sub_804CBC0((int)v30, v39, v29, a4, 5, a6, v28, v27, v26);
      if ( !a2 && v39 )
      {
        a2 = v39;
        v38 = 0;
        dword_805B170 = (int)&loc_804CC39;
        sub_8054A66();
      }
    }
    v24 = &loc_804DAC5;
    if ( !s )
      v24 = &loc_804DAFC;
    dword_805B224 = (int)v24;
    sub_80545E2();
    if ( v32 != 1 )
    {
      while ( *s )
      {
        if ( v38 < a2 )
          v30[v38] = *s;
        ++v38;
        ++s;
      }
    }
    if ( v38 < a2 )
      v30[v38] = 0;
    dword_805B1D4 = (int)&loc_804DB9E;
    sub_80547EC();
  }
  else
  {
    v20 = &loc_804DA03;
    if ( !v32 )
      v20 = &loc_804DA08;
    dword_805B1D4 = (int)v20;
    sub_80547EC();
  }
  if ( a5 == 2 )
  {
    v25 = &loc_804DB4E;
    if ( !v31 )
      v25 = &loc_804DB55;
    dword_805B238 = (int)v25;
    sub_8054576(v22, v21);
    a5 = 4;
  }
  return sub_804CBC0((int)v30, a2, v29, a4, a5, a6 & 0xFFFFFFFD, 0, v27, v26);
}
// 80543E8: using guessed type int __fastcall sub_80543E8(_DWORD, _DWORD);
// 8054576: using guessed type int __fastcall sub_8054576(_DWORD, _DWORD);
// 80545E2: using guessed type int sub_80545E2(void);
// 80546E7: using guessed type int sub_80546E7(void);
// 80547EC: using guessed type int sub_80547EC(void);
// 8054980: using guessed type int __fastcall sub_8054980(_DWORD, _DWORD);
// 8054A66: using guessed type int sub_8054A66(void);
// 805B170: using guessed type int dword_805B170;
// 805B198: using guessed type int dword_805B198;
// 805B1D4: using guessed type int dword_805B1D4;
// 805B1FC: using guessed type int dword_805B1FC;
// 805B224: using guessed type int dword_805B224;
// 805B238: using guessed type int dword_805B238;
// 805B274: using guessed type int dword_805B274;

//----- (0804DC85) --------------------------------------------------------
void *__cdecl sub_804DC85(char *a1, int a2, _DWORD *a3, int *a4)
{
  int *v4; // eax
  int *v5; // ST3C_4
  int v6; // ST40_4
  int v7; // ST44_4
  int size; // [esp+48h] [ebp-10h]
  void *v10; // [esp+4Ch] [ebp-Ch]

  if ( a4 )
    v4 = a4;
  else
    v4 = &dword_805B8EA;
  v5 = v4;
  v6 = *__errno_location();
  v7 = v5[1] | (a3 == 0);
  size = sub_804CBC0(0, 0, a1, a2, *v5, v7, (int)(v5 + 2), (char *)v5[10], (char *)v5[11]) + 1;
  v10 = sub_8050A93(size);
  sub_804CBC0((int)v10, size, a1, a2, *v5, v7, (int)(v5 + 2), (char *)v5[10], (char *)v5[11]);
  *__errno_location() = v6;
  if ( a3 )
    *a3 = size - 1;
  return v10;
}
// 805B8EA: using guessed type int dword_805B8EA;

//----- (0804DE45) --------------------------------------------------------
void *__cdecl sub_804DE45(signed int a1, char *a2, int a3, int a4)
{
  int *v4; // eax
  void *v5; // edx
  size_t v6; // ST44_4
  bool v8; // [esp+37h] [ebp-21h]
  int *v9; // [esp+38h] [ebp-20h]
  void *ptr; // [esp+3Ch] [ebp-1Ch]
  int v11; // [esp+40h] [ebp-18h]
  int size; // [esp+44h] [ebp-14h]
  int v13; // [esp+48h] [ebp-10h]
  unsigned int v14; // [esp+4Ch] [ebp-Ch]

  v11 = *__errno_location();
  v9 = off_805B2C4;
  if ( a1 < 0 )
    abort();
  if ( dword_805B2B8 <= a1 )
  {
    v8 = off_805B2C4 == &dword_805B2BC;
    if ( (unsigned int)a1 > 0xFFFFFFE )
      sub_8050C56();
    if ( v8 )
      v4 = 0;
    else
      v4 = off_805B2C4;
    v9 = (int *)sub_8050AD0(v4, 8 * (a1 + 1));
    off_805B2C4 = v9;
    if ( v8 )
    {
      v5 = off_805B2C0;
      *v9 = dword_805B2BC;
      v9[1] = (int)v5;
    }
    memset(&v9[2 * dword_805B2B8], 0, 8 * (a1 + 1 - dword_805B2B8));
    dword_805B2B8 = a1 + 1;
  }
  v6 = v9[2 * a1];
  ptr = (void *)v9[2 * a1 + 1];
  v13 = *(_DWORD *)(a4 + 4) | 1;
  v14 = sub_804CBC0(
          v9[2 * a1 + 1],
          v9[2 * a1],
          a2,
          a3,
          *(_DWORD *)a4,
          v13,
          a4 + 8,
          *(char **)(a4 + 40),
          *(char **)(a4 + 44));
  if ( v6 <= v14 )
  {
    size = v14 + 1;
    v9[2 * a1] = v14 + 1;
    if ( ptr != &unk_805B92A )
      free(ptr);
    ptr = sub_8050A93(size);
    v9[2 * a1 + 1] = (int)ptr;
    sub_804CBC0((int)ptr, size, a2, a3, *(_DWORD *)a4, v13, a4 + 8, *(char **)(a4 + 40), *(char **)(a4 + 44));
  }
  *__errno_location() = v11;
  return ptr;
}
// 805B2B8: using guessed type int dword_805B2B8;
// 805B2BC: using guessed type int dword_805B2BC;
// 805B2C0: using guessed type void *off_805B2C0;
// 805B2C4: using guessed type int *off_805B2C4;

//----- (0804E06E) --------------------------------------------------------
void *__cdecl sub_804E06E(signed int a1, char *a2)
{
  return sub_804DE45(a1, a2, -1, (int)&dword_805B8EA);
}
// 805B8EA: using guessed type int dword_805B8EA;

//----- (0804E098) --------------------------------------------------------
void *__cdecl sub_804E098(signed int a1, char *a2, int a3)
{
  return sub_804DE45(a1, a2, a3, (int)&dword_805B8EA);
}
// 805B8EA: using guessed type int dword_805B8EA;

//----- (0804E0FE) --------------------------------------------------------
void __cdecl __noreturn sub_804E0FE(int a1, int a2)
{
  char v2; // [esp+10h] [ebp-38h]

  sub_804CA75((int)&v2, a2);
}

//----- (0804E13C) --------------------------------------------------------
void __cdecl __noreturn sub_804E13C(int a1, int a2)
{
  char v2; // [esp+10h] [ebp-38h]

  sub_804CA75((int)&v2, a2);
}

//----- (0804E1C4) --------------------------------------------------------
void *__usercall sub_804E1C4@<eax>(int a1@<edx>, int a2@<ecx>, char *a3, int a4, unsigned __int8 a5)
{
  int v6; // [esp+20h] [ebp-38h]
  int v7; // [esp+24h] [ebp-34h]
  int v8; // [esp+28h] [ebp-30h]
  int v9; // [esp+2Ch] [ebp-2Ch]
  int v10; // [esp+30h] [ebp-28h]
  int v11; // [esp+34h] [ebp-24h]
  int v12; // [esp+38h] [ebp-20h]
  int v13; // [esp+3Ch] [ebp-1Ch]
  int v14; // [esp+40h] [ebp-18h]
  int v15; // [esp+44h] [ebp-14h]
  int v16; // [esp+48h] [ebp-10h]
  int v17; // [esp+4Ch] [ebp-Ch]

  v6 = dword_805B8EA;
  v7 = dword_805B8EE;
  v8 = dword_805B8F2;
  v9 = dword_805B8F6;
  v10 = dword_805B8FA;
  v11 = dword_805B8FE;
  v12 = dword_805B902;
  v13 = dword_805B906;
  v14 = dword_805B90A;
  v15 = dword_805B90E;
  v16 = dword_805B912;
  v17 = dword_805B916;
  sub_804C93B(a1, a2, (int)&v6, a5, 1);
  return sub_804DE45(0, a3, a4, (int)&v6);
}
// 805B8EA: using guessed type int dword_805B8EA;
// 805B8EE: using guessed type int dword_805B8EE;
// 805B8F2: using guessed type int dword_805B8F2;
// 805B8F6: using guessed type int dword_805B8F6;
// 805B8FA: using guessed type int dword_805B8FA;
// 805B8FE: using guessed type int dword_805B8FE;
// 805B902: using guessed type int dword_805B902;
// 805B906: using guessed type int dword_805B906;
// 805B90A: using guessed type int dword_805B90A;
// 805B90E: using guessed type int dword_805B90E;
// 805B912: using guessed type int dword_805B912;
// 805B916: using guessed type int dword_805B916;

//----- (0804E26E) --------------------------------------------------------
void *__usercall sub_804E26E@<eax>(int a1@<edx>, int a2@<ecx>, char *a3, unsigned __int8 a4)
{
  return sub_804E1C4(a1, a2, a3, -1, a4);
}

//----- (0804E297) --------------------------------------------------------
void *__usercall sub_804E297@<eax>(int a1@<edx>, int a2@<ecx>, char *a3)
{
  return sub_804E26E(a1, a2, a3, 0x3Au);
}

//----- (0804E2D4) --------------------------------------------------------
void __cdecl __noreturn sub_804E2D4(int a1, int a2)
{
  char v2; // [esp+10h] [ebp-68h]

  sub_804CA75((int)&v2, a2);
}

//----- (0804E375) --------------------------------------------------------
void *__cdecl sub_804E375(signed int a1, int a2, int a3, char *a4)
{
  return sub_804E3A5(a1, a2, a3, a4, -1);
}

//----- (0804E3A5) --------------------------------------------------------
void *__cdecl sub_804E3A5(signed int a1, int a2, int a3, char *a4, int a5)
{
  int v6; // [esp+10h] [ebp-38h]
  int v7; // [esp+14h] [ebp-34h]
  int v8; // [esp+18h] [ebp-30h]
  int v9; // [esp+1Ch] [ebp-2Ch]
  int v10; // [esp+20h] [ebp-28h]
  int v11; // [esp+24h] [ebp-24h]
  int v12; // [esp+28h] [ebp-20h]
  int v13; // [esp+2Ch] [ebp-1Ch]
  int v14; // [esp+30h] [ebp-18h]
  int v15; // [esp+34h] [ebp-14h]
  int v16; // [esp+38h] [ebp-10h]
  int v17; // [esp+3Ch] [ebp-Ch]

  v6 = dword_805B8EA;
  v7 = dword_805B8EE;
  v8 = dword_805B8F2;
  v9 = dword_805B8F6;
  v10 = dword_805B8FA;
  v11 = dword_805B8FE;
  v12 = dword_805B902;
  v13 = dword_805B906;
  v14 = dword_805B90A;
  v15 = dword_805B90E;
  v16 = dword_805B912;
  v17 = dword_805B916;
  sub_804C9FE((int)&v6, a2, a3);
  return sub_804DE45(a1, a4, a5, (int)&v6);
}
// 805B8EA: using guessed type int dword_805B8EA;
// 805B8EE: using guessed type int dword_805B8EE;
// 805B8F2: using guessed type int dword_805B8F2;
// 805B8F6: using guessed type int dword_805B8F6;
// 805B8FA: using guessed type int dword_805B8FA;
// 805B8FE: using guessed type int dword_805B8FE;
// 805B902: using guessed type int dword_805B902;
// 805B906: using guessed type int dword_805B906;
// 805B90A: using guessed type int dword_805B90A;
// 805B90E: using guessed type int dword_805B90E;
// 805B912: using guessed type int dword_805B912;
// 805B916: using guessed type int dword_805B916;

//----- (0804E49F) --------------------------------------------------------
void *__cdecl sub_804E49F(signed int a1, char *a2, int a3)
{
  return sub_804DE45(a1, a2, a3, (int)&unk_805B2D8);
}

//----- (0804E4EA) --------------------------------------------------------
void *__cdecl sub_804E4EA(signed int a1, char *a2)
{
  return sub_804E49F(a1, a2, -1);
}

//----- (0804E50C) --------------------------------------------------------
void *__cdecl sub_804E50C(char *a1)
{
  return sub_804E4EA(0, a1);
}

//----- (0804E527) --------------------------------------------------------
_DWORD *__cdecl sub_804E527(int a1)
{
  _DWORD *result; // eax
  int v2; // edx

  result = sub_8050AA6(0x14u);
  *result = a1;
  result[3] = 0;
  result[4] = 0;
  v2 = result[4];
  result[1] = result[3];
  result[2] = v2;
  return result;
}

//----- (0804E56C) --------------------------------------------------------
_DWORD *__cdecl sub_804E56C(int a1, size_t n)
{
  _DWORD *result; // eax
  int v3; // [esp+1Ch] [ebp-Ch]

  v3 = sub_804F1B5(a1, n);
  if ( v3 )
    result = sub_804E527(v3);
  else
    result = 0;
  return result;
}

//----- (0804E5AB) --------------------------------------------------------
__int64 __cdecl sub_804E5AB(__int64 a1)
{
  return a1 << 8;
}

//----- (0804E5CC) --------------------------------------------------------
void __cdecl sub_804E5CC(int a1, __int64 a2)
{
  int v2; // ST2C_4
  __int64 v3; // ST30_8
  __int64 v4; // ST38_8
  __int64 v5; // rax
  __int64 v6; // ST30_8
  __int64 v7; // rax
  int v8; // edx
  unsigned __int8 ptr; // [esp+74h] [ebp-24h]
  unsigned int v10; // [esp+7Ch] [ebp-1Ch]

  v10 = __readgsdword(0x14u);
  v2 = *(_DWORD *)a1;
  v3 = *(_QWORD *)(a1 + 4);
  v4 = *(_QWORD *)(a1 + 12);
  JUMPOUT(HIDWORD(v4), HIDWORD(a2), &loc_804F343);
  JUMPOUT(HIDWORD(v4), HIDWORD(a2), &loc_804F343);
  dword_805B284 = (int (*)(void))&loc_804E7E1;
  JUMPOUT(v4, a2, &loc_804F343);
  v5 = sub_804E5AB(v4) + 255;
  JUMPOUT(HIDWORD(v5), HIDWORD(a2), &loc_804F343);
  JUMPOUT(HIDWORD(v5), HIDWORD(a2), &loc_804F343);
  dword_805B284 = (int (*)(void))&loc_804E6A0;
  JUMPOUT(v5, a2, &loc_804F343);
  sub_804F52E(v2, &ptr, 1u);
  v6 = ptr + sub_804E5AB(v3);
  v7 = sub_804E5AB(v4) + 255;
  JUMPOUT(HIDWORD(v7), HIDWORD(a2), &loc_804F343);
  JUMPOUT(HIDWORD(v7), HIDWORD(a2), &loc_804F343);
  JUMPOUT(v7, a2, &loc_804F343);
  dword_805B284 = (int (*)(void))sub_804E849;
  JUMPOUT(a2, v7, &loc_804F343);
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  v8 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 8) = v8;
  dword_805B284 = (int (*)(void))sub_804E9AE;
  JUMPOUT(&loc_804F343);
}
// 804E849: using guessed type int __cdecl sub_804E849(int, int, int);
// 805B284: using guessed type int (*dword_805B284)(void);

//----- (0804E849) --------------------------------------------------------
#error "804E880: call analysis failed (funcsize=85)"

//----- (0804E97D) --------------------------------------------------------
void __usercall sub_804E97D(int a1@<ebp>)
{
  int v1; // edx

  v1 = *(_DWORD *)(a1 - 44);
  *(_DWORD *)(a1 - 104) = *(_DWORD *)(a1 - 48);
  *(_DWORD *)(a1 - 100) = v1;
  *(_QWORD *)(a1 - 96) = *(_QWORD *)(a1 - 64) - 1LL;
  dword_805B284 = (int (*)(void))&loc_804E639;
  JUMPOUT(&loc_804F343);
}
// 805B284: using guessed type int (*dword_805B284)(void);

//----- (0804E9AE) --------------------------------------------------------
void __usercall sub_804E9AE(int a1@<ebp>)
{
  bool v1; // zf

  v1 = __readgsdword(0x14u) == *(_DWORD *)(a1 - 28);
  dword_805B284 = (int (*)(void))sub_804E9D1;
  JUMPOUT(v1, &loc_804F343);
}
// 804E9D1: using guessed type int sub_804E9D1();
// 805B284: using guessed type int (*dword_805B284)(void);

//----- (0804E9D1) --------------------------------------------------------
#error "804E9D7: positive sp value has been found (funcsize=0)"

//----- (0804E9DC) --------------------------------------------------------
void __cdecl sub_804E9DC(void *ptr)
{
  explicit_bzero(ptr, 20);
  free(ptr);
}
// 8049330: using guessed type int __cdecl explicit_bzero(_DWORD, _DWORD);

//----- (0804EA3C) --------------------------------------------------------
void __cdecl sub_804EA3C(int a1, __int64 a2)
{
  sub_804E5CC(a1, a2 - 1);
}

//----- (0804EA6F) --------------------------------------------------------
int __cdecl sub_804EA6F(int a1)
{
  int v2; // [esp+Ch] [ebp-4h]
  unsigned int i; // [esp+18h] [ebp+8h]

  v2 = 0;
  for ( i = a1 - 1; i; i >>= 1 )
    ++v2;
  return v2;
}

//----- (0804EA99) --------------------------------------------------------
unsigned int __cdecl sub_804EA99(int a1, int a2)
{
  return (unsigned int)(a1 * sub_804EA6F(a2) + 7) >> 3;
}

//----- (0804EAC8) --------------------------------------------------------
int __cdecl sub_804EAC8(int a1, int a2, int a3)
{
  int v3; // ST0C_4
  int result; // eax

  v3 = *(_DWORD *)(4 * a2 + a1);
  *(_DWORD *)(a1 + 4 * a2) = *(_DWORD *)(4 * a3 + a1);
  result = v3;
  *(_DWORD *)(a1 + 4 * a3) = v3;
  return result;
}

//----- (0804EB1A) --------------------------------------------------------
int __cdecl sub_804EB1A(_DWORD *a1, unsigned int a2)
{
  return *a1 % a2;
}

//----- (0804EB37) --------------------------------------------------------
bool __cdecl sub_804EB37(_DWORD *a1, _DWORD *a2)
{
  return *a1 == *a2;
}

//----- (0804EB5A) --------------------------------------------------------
int __cdecl sub_804EB5A(unsigned int a1)
{
  return sub_8052573(
           a1,
           0,
           (unsigned int (__cdecl *)(int, unsigned int))sub_804EB1A,
           (bool (__cdecl *)(int, int))sub_804EB37,
           (int)free);
}

//----- (0804EB8D) --------------------------------------------------------
int __cdecl sub_804EB8D(unsigned int *a1, int a2, int a3, int a4)
{
  int v4; // ST1C_4
  int result; // eax
  _DWORD *v6; // [esp+14h] [ebp-24h]
  _DWORD *v7; // [esp+18h] [ebp-20h]
  int v8; // [esp+20h] [ebp-18h]
  int v9; // [esp+24h] [ebp-14h]
  int v10; // [esp+28h] [ebp-10h]
  int v11; // [esp+2Ch] [ebp-Ch]

  v8 = a3;
  v9 = 0;
  v6 = (_DWORD *)sub_805311D((int)a1, (int)&v8);
  v10 = a4;
  v11 = 0;
  v7 = (_DWORD *)sub_805311D((int)a1, (int)&v10);
  if ( !v6 )
  {
    v6 = sub_8050AA6(8u);
    v6[1] = a3;
    *v6 = v6[1];
  }
  if ( !v7 )
  {
    v7 = sub_8050AA6(8u);
    v7[1] = a4;
    *v7 = v7[1];
  }
  v4 = v6[1];
  v6[1] = v7[1];
  v7[1] = v4;
  if ( !sub_80530B0(a1, (int)v6) )
    sub_8050C56();
  if ( !sub_80530B0(a1, (int)v7) )
    sub_8050C56();
  result = v6[1];
  *(_DWORD *)(a2 + 4 * a3) = result;
  return result;
}

//----- (0804EC96) --------------------------------------------------------
void __usercall sub_804EC96(int a1@<edx>, int a2@<ecx>, void *a3)
{
  sub_8052777(a1, a2, a3);
}

//----- (0804ECA9) --------------------------------------------------------
void *__cdecl sub_804ECA9(int a1, unsigned int a2, unsigned int a3)
{
  void *v3; // eax
  int v4; // eax
  bool v5; // al
  unsigned int *v6; // edx
  int v7; // ecx
  void *v8; // eax
  void *v9; // eax
  int v10; // eax
  bool v12; // [esp+1Fh] [ebp-19h]
  void *ptr; // [esp+20h] [ebp-18h]
  unsigned int i; // [esp+24h] [ebp-14h]
  void *v15; // [esp+28h] [ebp-10h]
  int v16; // [esp+2Ch] [ebp-Ch]

  v3 = &loc_804ECCF;
  if ( !a2 )
    v3 = &loc_804ECD6;
  dword_805B1E8 = (int)v3;
  if ( sub_805475B() == 1 )
  {
    ptr = sub_8050AA6(4u);
    sub_804EA3C(a1, a3);
    *(_DWORD *)ptr = v4;
    dword_805B24C = (int)&loc_804EE87;
    sub_8054506();
  }
  v5 = a3 > 0x1FFFF && a3 / a2 > 0x1F;
  v12 = v5;
  if ( v5 )
  {
    v15 = (void *)sub_804EB5A(2 * a2);
    if ( !v15 )
      sub_8050C56();
    sub_805096E(a2, 4u);
    ptr = v8;
  }
  else
  {
    v15 = 0;
    sub_805096E(a3, 4u);
    ptr = v9;
    for ( i = 0; i < a3; ++i )
    {
      v6 = (unsigned int *)((char *)ptr + 4 * i);
      *v6 = i;
    }
  }
  for ( i = 0; i < a2; ++i )
  {
    sub_804EA3C(a1, a3 - i);
    v16 = v10 + i;
    if ( v12 )
      sub_804EB8D((unsigned int *)v15, (int)ptr, i, v16);
    else
      sub_804EAC8((int)ptr, i, v16);
  }
  if ( !v12 )
    return sub_80509AE(ptr, a2, 4);
  sub_804EC96((int)v6, v7, v15);
  return ptr;
}
// 8054506: using guessed type int sub_8054506(void);
// 805475B: using guessed type int sub_805475B(void);
// 805B1E8: using guessed type int dword_805B1E8;
// 805B24C: using guessed type int dword_805B24C;

//----- (0804EE8C) --------------------------------------------------------
void __cdecl __noreturn sub_804EE8C(char *a1)
{
  void *v1; // esi
  char *v2; // ebx
  int *v3; // eax

  if ( a1 )
  {
    v1 = sub_804E50C(a1);
    if ( *__errno_location() )
      v2 = gettext("%s: read error");
    else
      v2 = gettext("%s: end of file");
    v3 = __errno_location();
    error(status, *v3, v2, v1);
  }
  abort();
}

//----- (0804EEF5) --------------------------------------------------------
_DWORD *__cdecl sub_804EEF5(int a1, int a2)
{
  _DWORD *result; // eax

  result = sub_8050AA6(0x81Cu);
  *result = a1;
  result[1] = sub_804EE8C;
  result[2] = a2;
  return result;
}

//----- (0804EF2A) --------------------------------------------------------
int __cdecl sub_804EF2A(int a1, int a2, size_t nbytes)
{
  int v3; // eax
  size_t v4; // eax
  ssize_t v5; // eax
  int v6; // eax
  int v7; // eax
  size_t v8; // ST28_4
  int v9; // eax
  size_t v10; // ST2C_4
  int v11; // eax
  size_t v12; // ST30_4
  int v13; // eax
  size_t v14; // ST34_4
  int v16; // [esp+18h] [ebp-30h]
  int v17; // [esp+18h] [ebp-30h]
  int v18; // [esp+18h] [ebp-30h]
  int fd; // [esp+20h] [ebp-28h]
  size_t n; // [esp+24h] [ebp-24h]
  struct timeval tv; // [esp+38h] [ebp-10h]

  v3 = open64("/dev/urandom", 0);
  fd = v3;
  dword_805B284 = (int (*)(void))&loc_804EFB9;
  JUMPOUT(v3, 0, &loc_804F343);
  v4 = a2;
  if ( nbytes <= a2 )
    v4 = nbytes;
  v5 = read(fd, (void *)a1, v4);
  dword_805B284 = (int (*)(void))&loc_804EFAE;
  JUMPOUT(v5 >= 0, &loc_804F343);
  close(fd);
  dword_805B284 = (int (*)(void))&loc_804F027;
  JUMPOUT(0, a2, &loc_804F343);
  v6 = a2;
  if ( (unsigned int)a2 > 8 )
    v6 = 8;
  n = v6;
  gettimeofday(&tv, 0);
  memcpy((void *)a1, &tv, n);
  dword_805B284 = (int (*)(void))&loc_804F08A;
  JUMPOUT(n, a2, &loc_804F343);
  v7 = a2 - n;
  if ( a2 - n > 4 )
    v7 = 4;
  v8 = v7;
  tv.tv_sec = getpid();
  memcpy((void *)(a1 + n), &tv, v8);
  v16 = n + v8;
  dword_805B284 = (int (*)(void))&loc_804F0ED;
  JUMPOUT(n + v8, a2, &loc_804F343);
  v9 = a2 - (n + v8);
  if ( a2 - (n + v8) > 4 )
    v9 = 4;
  v10 = v9;
  tv.tv_sec = getppid();
  memcpy((void *)(a1 + v16), &tv, v10);
  v17 = v16 + v10;
  dword_805B284 = (int (*)(void))&loc_804F150;
  JUMPOUT(v17, a2, &loc_804F343);
  v11 = a2 - v17;
  if ( (unsigned int)(a2 - v17) > 4 )
    v11 = 4;
  v12 = v11;
  tv.tv_sec = getuid();
  memcpy((void *)(a1 + v17), &tv, v12);
  v18 = v17 + v12;
  dword_805B284 = (int (*)(void))&locret_804F1B3;
  JUMPOUT(v18, a2, &loc_804F343);
  v13 = a2 - v18;
  if ( (unsigned int)(a2 - v18) > 4 )
    v13 = 4;
  v14 = v13;
  tv.tv_sec = getgid();
  memcpy((void *)(a1 + v18), &tv, v14);
  return v18 + v14;
}
// 8048F50: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 805B284: using guessed type int (*dword_805B284)(void);

//----- (0804F1B5) --------------------------------------------------------
int __cdecl sub_804F1B5(int a1, size_t n)
{
  dword_805B284 = (int (*)(void))&loc_804F1FA;
  if ( !n )
  {
    sub_804EEF5(0, 0);
    dword_805B284 = (int (*)(void))&locret_804F341;
  }
  return dword_805B284();
}
// 805B284: invalid function type has been ignored
// 805B284: using guessed type int (*dword_805B284)(void);

//----- (0804F369) --------------------------------------------------------
int __cdecl sub_804F369(int a1, void *ptr, size_t n)
{
  size_t v3; // ST20_4
  int v4; // ST24_4
  void *v5; // eax

  v3 = fread_unlocked(ptr, 1u, n, *(FILE **)a1);
  v4 = *__errno_location();
  v5 = &loc_804F3CB;
  if ( n != v3 )
    v5 = &loc_804F3CD;
  dword_805B184 = (int)v5;
  return sub_80549F2();
}
// 80549F2: using guessed type int sub_80549F2(void);
// 805B184: using guessed type int dword_805B184;

//----- (0804F41F) --------------------------------------------------------
int __cdecl sub_804F41F(int a1, void *dest, size_t n)
{
  int result; // eax
  size_t i; // [esp+14h] [ebp-14h]
  int *v5; // [esp+18h] [ebp-10h]
  char v6; // [esp+1Ch] [ebp-Ch]

  for ( i = *(_DWORD *)a1; ; i = 1024 )
  {
    v6 = (char)dest;
    if ( n <= i )
      break;
    memcpy(dest, (const void *)(a1 + 1024 - i + 1040), i);
    dest = (char *)dest + i;
    n -= i;
    if ( !((v6 + (_BYTE)i) & 3) )
    {
      v5 = (int *)dest;
      while ( n > 0x3FF )
      {
        sub_804F604((unsigned int *)(a1 + 4), v5);
        v5 += 256;
        n -= 1024;
        if ( !n )
        {
          result = a1;
          *(_DWORD *)a1 = 0;
          return result;
        }
      }
      dest = v5;
    }
    sub_804F604((unsigned int *)(a1 + 4), (int *)(a1 + 1040));
  }
  memcpy(dest, (const void *)(a1 + 1024 - i + 1040), n);
  result = a1;
  *(_DWORD *)a1 = i - n;
  return result;
}

//----- (0804F52E) --------------------------------------------------------
int __cdecl sub_804F52E(int a1, void *ptr, size_t n)
{
  int result; // eax

  if ( *(_DWORD *)a1 )
    result = sub_804F369(a1, ptr, n);
  else
    result = sub_804F41F(a1 + 12, ptr, n);
  return result;
}

//----- (0804F576) --------------------------------------------------------
int __cdecl sub_804F576(void *ptr)
{
  int result; // eax
  FILE *stream; // [esp+1Ch] [ebp-Ch]

  stream = *(FILE **)ptr;
  explicit_bzero(ptr, 2076);
  free(ptr);
  if ( stream )
    result = sub_805194F(stream);
  else
    result = 0;
  return result;
}
// 8049330: using guessed type int __cdecl explicit_bzero(_DWORD, _DWORD);

//----- (0804F5BC) --------------------------------------------------------
int __cdecl sub_804F5BC(int a1)
{
  return a1;
}

//----- (0804F5D3) --------------------------------------------------------
int __cdecl sub_804F5D3(int a1, __int16 a2)
{
  return *(_DWORD *)((a2 & 0x3FC) + a1);
}

//----- (0804F604) --------------------------------------------------------
unsigned int *__cdecl sub_804F604(unsigned int *a1, int *a2)
{
  unsigned int v2; // edx
  int v3; // ST08_4
  unsigned int v4; // ST18_4
  unsigned int v5; // ST1C_4
  int v6; // eax
  int v7; // ST0C_4
  unsigned int v8; // ST08_4
  unsigned int v9; // ST20_4
  int v10; // eax
  int v11; // eax
  int v12; // ST0C_4
  int v13; // ST08_4
  unsigned int v14; // ST28_4
  int v15; // eax
  int v16; // eax
  int v17; // ST0C_4
  unsigned int v18; // ST30_4
  int v19; // eax
  int v20; // eax
  int v21; // ST08_4
  unsigned int v22; // ST38_4
  unsigned int v23; // ST3C_4
  int v24; // eax
  int v25; // ST0C_4
  unsigned int v26; // ST08_4
  unsigned int v27; // ST40_4
  int v28; // eax
  int v29; // eax
  int v30; // ST0C_4
  int v31; // ST08_4
  unsigned int v32; // ST48_4
  int v33; // eax
  int v34; // eax
  int v35; // ST0C_4
  unsigned int v36; // ST50_4
  int v37; // eax
  int v38; // eax
  unsigned int *result; // eax
  unsigned int v40; // [esp+8h] [ebp-54h]
  int v41; // [esp+Ch] [ebp-50h]
  unsigned int *v42; // [esp+10h] [ebp-4Ch]
  int *v43; // [esp+14h] [ebp-48h]

  v40 = a1[256];
  v2 = a1[257];
  v41 = v2 + ++a1[258];
  v42 = a1;
  v43 = a2;
  do
  {
    v3 = (v40 ^ (v40 << 13)) + v42[128];
    v4 = *v42;
    v5 = sub_804F5D3((int)a1, *v42) + v3 + v41;
    *v42 = v5;
    v6 = sub_804F5D3((int)a1, v5 >> 8);
    v7 = sub_804F5BC(v4 + v6);
    *v43 = v7;
    v8 = (v3 ^ ((unsigned int)sub_804F5BC(v3) >> 6)) + v42[129];
    v9 = v42[1];
    v10 = sub_804F5D3((int)a1, v42[1]);
    v42[1] = v10 + v8 + v7;
    v11 = sub_804F5D3((int)a1, (v10 + v8 + v7) >> 8);
    v12 = sub_804F5BC(v9 + v11);
    v43[1] = v12;
    v13 = (v8 ^ 4 * v8) + v42[130];
    v14 = v42[2];
    v15 = sub_804F5D3((int)a1, v42[2]);
    v42[2] = v15 + v13 + v12;
    v16 = sub_804F5D3((int)a1, (unsigned int)(v15 + v13 + v12) >> 8);
    v17 = sub_804F5BC(v14 + v16);
    v43[2] = v17;
    v40 = (v13 ^ ((unsigned int)sub_804F5BC(v13) >> 16)) + v42[131];
    v18 = v42[3];
    v19 = sub_804F5D3((int)a1, v42[3]);
    v42[3] = v19 + v40 + v17;
    v20 = sub_804F5D3((int)a1, (v19 + v40 + v17) >> 8);
    v41 = sub_804F5BC(v18 + v20);
    v43[3] = v41;
    v43 += 4;
    v42 += 4;
  }
  while ( v42 < a1 + 128 );
  do
  {
    v21 = (v40 ^ (v40 << 13)) + *(v42 - 128);
    v22 = *v42;
    v23 = sub_804F5D3((int)a1, *v42) + v21 + v41;
    *v42 = v23;
    v24 = sub_804F5D3((int)a1, v23 >> 8);
    v25 = sub_804F5BC(v22 + v24);
    *v43 = v25;
    v26 = (v21 ^ ((unsigned int)sub_804F5BC(v21) >> 6)) + *(v42 - 127);
    v27 = v42[1];
    v28 = sub_804F5D3((int)a1, v42[1]);
    v42[1] = v28 + v26 + v25;
    v29 = sub_804F5D3((int)a1, (v28 + v26 + v25) >> 8);
    v30 = sub_804F5BC(v27 + v29);
    v43[1] = v30;
    v31 = (v26 ^ 4 * v26) + *(v42 - 126);
    v32 = v42[2];
    v33 = sub_804F5D3((int)a1, v42[2]);
    v42[2] = v33 + v31 + v30;
    v34 = sub_804F5D3((int)a1, (unsigned int)(v33 + v31 + v30) >> 8);
    v35 = sub_804F5BC(v32 + v34);
    v43[2] = v35;
    v40 = (v31 ^ ((unsigned int)sub_804F5BC(v31) >> 16)) + *(v42 - 125);
    v36 = v42[3];
    v37 = sub_804F5D3((int)a1, v42[3]);
    v42[3] = v37 + v40 + v35;
    v38 = sub_804F5D3((int)a1, (v37 + v40 + v35) >> 8);
    v41 = sub_804F5BC(v36 + v38);
    v43[3] = v41;
    v43 += 4;
    v42 += 4;
  }
  while ( v42 < a1 + 256 );
  a1[256] = v40;
  result = a1;
  a1[257] = v41;
  return result;
}

//----- (0804FAA9) --------------------------------------------------------
_DWORD *__usercall sub_804FAA9@<eax>(int a1@<edx>, int a2@<ecx>, _DWORD *a3)
{
  int v3; // ST10_4
  int v4; // ST14_4
  int v5; // ST1C_4
  int v6; // ST20_4
  int v7; // ST24_4
  int v8; // ST28_4
  int v9; // ST0C_4
  int v10; // ST18_4
  unsigned int v11; // ST10_4
  int v12; // ST1C_4
  int v13; // ST14_4
  int v14; // ST20_4
  int v15; // ST24_4
  int v16; // ST28_4
  int v17; // ST0C_4
  int v18; // ST10_4
  int v19; // ST14_4
  int v20; // ST1C_4
  int v21; // ST20_4
  int v22; // ST24_4
  int v23; // ST28_4
  int v24; // ST0C_4
  int v25; // ST18_4
  unsigned int v26; // ST10_4
  int v27; // ST1C_4
  int v28; // ST14_4
  int v29; // ST20_4
  int v30; // ST24_4
  int v31; // ST28_4
  int v32; // ST0C_4
  _DWORD *result; // eax
  int v34; // [esp+Ch] [ebp-28h]
  int v35; // [esp+10h] [ebp-24h]
  int v36; // [esp+14h] [ebp-20h]
  unsigned int v37; // [esp+18h] [ebp-1Ch]
  int v38; // [esp+1Ch] [ebp-18h]
  unsigned int v39; // [esp+20h] [ebp-14h]
  int v40; // [esp+24h] [ebp-10h]
  unsigned int v41; // [esp+28h] [ebp-Ch]
  signed int v42; // [esp+2Ch] [ebp-8h]
  signed int i; // [esp+30h] [ebp-4h]

  v34 = 325574490;
  v35 = -1780940711;
  v36 = -1021952437;
  v37 = 255990488;
  v38 = -651539848;
  v39 = -1525007287;
  v40 = -990909925;
  v41 = 811634969;
  v42 = 0;
  dword_805B238 = (int)&loc_804FCBB;
  sub_8054576(a2, a1);
  do
  {
    v3 = a3[v42 + 1] + v35;
    v4 = a3[v42 + 2] + v36;
    v5 = a3[v42 + 4] + v38;
    v6 = a3[v42 + 5] + v39;
    v7 = a3[v42 + 6] + v40;
    v8 = a3[v42 + 7] + v41;
    v9 = (v3 << 11) ^ (a3[v42] + v34);
    v10 = v9 + a3[v42 + 3] + v37;
    v11 = ((unsigned int)sub_804F5BC(v4) >> 2) ^ (v4 + v3);
    v12 = v11 + v5;
    v13 = (v10 << 8) ^ (v10 + v4);
    v14 = v13 + v6;
    v37 = ((unsigned int)sub_804F5BC(v12) >> 16) ^ (v12 + v10);
    v15 = v37 + v7;
    v38 = (v14 << 10) ^ (v14 + v12);
    v16 = v38 + v8;
    v39 = ((unsigned int)sub_804F5BC(v15) >> 4) ^ (v15 + v14);
    v17 = v39 + v9;
    v40 = (v16 << 8) ^ (v16 + v15);
    v35 = v40 + v11;
    v41 = ((unsigned int)sub_804F5BC(v17) >> 9) ^ (v17 + v16);
    v36 = v41 + v13;
    v34 = v35 + v17;
    a3[v42] = v34;
    a3[v42 + 1] = v35;
    a3[v42 + 2] = v36;
    a3[v42 + 3] = v37;
    a3[v42 + 4] = v38;
    a3[v42 + 5] = v39;
    a3[v42 + 6] = v40;
    a3[v42 + 7] = v41;
    v42 += 8;
  }
  while ( v42 <= 255 );
  for ( i = 0; i <= 255; i += 8 )
  {
    v18 = a3[i + 1] + v35;
    v19 = a3[i + 2] + v36;
    v20 = a3[i + 4] + v38;
    v21 = a3[i + 5] + v39;
    v22 = a3[i + 6] + v40;
    v23 = a3[i + 7] + v41;
    v24 = (v18 << 11) ^ (a3[i] + v34);
    v25 = v24 + a3[i + 3] + v37;
    v26 = ((unsigned int)sub_804F5BC(v19) >> 2) ^ (v19 + v18);
    v27 = v26 + v20;
    v28 = (v25 << 8) ^ (v25 + v19);
    v29 = v28 + v21;
    v37 = ((unsigned int)sub_804F5BC(v27) >> 16) ^ (v27 + v25);
    v30 = v37 + v22;
    v38 = (v29 << 10) ^ (v29 + v27);
    v31 = v38 + v23;
    v39 = ((unsigned int)sub_804F5BC(v30) >> 4) ^ (v30 + v29);
    v32 = v39 + v24;
    v40 = (v31 << 8) ^ (v31 + v30);
    v35 = v40 + v26;
    v41 = ((unsigned int)sub_804F5BC(v32) >> 9) ^ (v32 + v31);
    v36 = v41 + v28;
    v34 = v35 + v32;
    a3[i] = v34;
    a3[i + 1] = v35;
    a3[i + 2] = v36;
    a3[i + 3] = v37;
    a3[i + 4] = v38;
    a3[i + 5] = v39;
    a3[i + 6] = v40;
    a3[i + 7] = v41;
  }
  a3[258] = 0;
  a3[257] = a3[258];
  result = a3;
  a3[256] = a3[257];
  return result;
}
// 8054576: using guessed type int __fastcall sub_8054576(_DWORD, _DWORD);
// 805B238: using guessed type int dword_805B238;

//----- (0804FECA) --------------------------------------------------------
void *__cdecl sub_804FECA(FILE *stream, int a2)
{
  int v2; // eax
  __int64 v3; // rax
  void *v4; // eax
  void *v6; // eax
  bool v7; // zf
  void *v8; // eax
  int v9; // edx
  int v10; // ecx
  void *ptr; // [esp+10h] [ebp-98h]
  size_t size; // [esp+14h] [ebp-94h]
  size_t v13; // [esp+18h] [ebp-90h]
  int v14; // [esp+1Ch] [ebp-8Ch]
  size_t n; // [esp+20h] [ebp-88h]
  size_t v16; // [esp+24h] [ebp-84h]
  void *v17; // [esp+28h] [ebp-80h]
  void *v18; // [esp+2Ch] [ebp-7Ch]
  __int64 v19; // [esp+30h] [ebp-78h]
  __int64 v20; // [esp+38h] [ebp-70h]
  char v21; // [esp+40h] [ebp-68h]
  int v22; // [esp+50h] [ebp-58h]
  __int64 v23; // [esp+6Ch] [ebp-3Ch]

  ptr = 0;
  size = 0x2000;
  v2 = fileno(stream);
  if ( sub_80542E0(v2, (int)&v21) >= 0 && (v22 & 0xF000) == 0x8000 )
  {
    LODWORD(v3) = ftello64(stream);
    v19 = v3;
    if ( v3 >= 0 && SHIDWORD(v23) >= SHIDWORD(v19) )
    {
      v4 = &loc_804FF5C;
      if ( SHIDWORD(v23) > SHIDWORD(v19) )
        v4 = &loc_804FF61;
      dword_805B224 = (int)v4;
      if ( sub_80545E2() > (unsigned int)v19 )
      {
        v20 = v23 - v19;
        if ( v23 - v19 > 4294967294LL )
        {
          *__errno_location() = 12;
          return 0;
        }
        size = v20 + 1;
      }
    }
  }
  v6 = malloc(size);
  ptr = v6;
  v7 = v6 == 0;
  v8 = &loc_804FFDC;
  if ( !v7 )
    v8 = &loc_804FFF8;
  dword_805B1FC = (int)v8;
  sub_80546E7();
  dword_805B224 = (int)&locret_80501BD;
  sub_80545E2();
  v13 = 0;
  while ( 1 )
  {
    n = size - v13;
    v16 = fread((char *)ptr + v13, 1u, size - v13, stream);
    v13 += v16;
    if ( v16 != n )
      break;
    if ( size == -1 )
    {
      v14 = 12;
      goto LABEL_27;
    }
    if ( ~(size >> 1) > size )
    {
      size += size >> 1;
      dword_805B24C = (int)&loc_805014A;
      sub_8054506();
    }
    size = -1;
    v18 = realloc(ptr, 0xFFFFFFFF);
    if ( !v18 )
    {
      v14 = *__errno_location();
      dword_805B210 = (int)&loc_805019D;
      sub_805465C(v10, v9);
    }
    ptr = v18;
  }
  v14 = *__errno_location();
  if ( ferror(stream) )
  {
LABEL_27:
    free(ptr);
    *__errno_location() = v14;
    return 0;
  }
  if ( size - 1 > v13 )
  {
    v17 = realloc(ptr, v13 + 1);
    if ( v17 )
      ptr = v17;
  }
  *((_BYTE *)ptr + v13) = 0;
  *(_DWORD *)a2 = v13;
  return ptr;
}
// 804FECA: could not find valid save-restore pair for ebx
// 80491B0: using guessed type int __cdecl ftello64(_DWORD);
// 8054506: using guessed type int sub_8054506(void);
// 80545E2: using guessed type int sub_80545E2(void);
// 805465C: using guessed type int __fastcall sub_805465C(_DWORD, _DWORD);
// 80546E7: using guessed type int sub_80546E7(void);
// 805B1FC: using guessed type int dword_805B1FC;
// 805B210: using guessed type int dword_805B210;
// 805B224: using guessed type int dword_805B224;
// 805B24C: using guessed type int dword_805B24C;

//----- (080501BF) --------------------------------------------------------
void *__cdecl sub_80501BF(int a1, int a2, int a3)
{
  int v4; // ST1C_4
  void *v5; // eax
  int v6; // ST1C_4
  FILE *stream; // [esp+18h] [ebp-10h]
  void *ptr; // [esp+1Ch] [ebp-Ch]

  stream = (FILE *)fopen64(a1, a3);
  if ( !stream )
    return 0;
  ptr = sub_804FECA(stream, a2);
  v4 = *__errno_location();
  if ( !sub_805194F(stream) )
    return ptr;
  v5 = &loc_8050234;
  if ( !ptr )
    v5 = &loc_8050249;
  dword_805B1D4 = (int)v5;
  sub_80547EC();
  v6 = *__errno_location();
  free(ptr);
  *__errno_location() = v6;
  return 0;
}
// 8049090: using guessed type int __cdecl fopen64(_DWORD, _DWORD);
// 80547EC: using guessed type int sub_80547EC(void);
// 805B1D4: using guessed type int dword_805B1D4;

//----- (080502A3) --------------------------------------------------------
int __cdecl sub_80502A3(FILE *stream, int a2, int a3, int a4, int a5, int a6)
{
  char *v6; // eax
  char *v7; // eax
  int v8; // ebx
  char *v9; // eax
  int result; // eax
  int v11; // esi
  int v12; // ebx
  char *v13; // eax
  int v14; // edi
  int v15; // esi
  int v16; // ebx
  char *v17; // eax
  int v18; // edi
  int v19; // esi
  int v20; // ebx
  char *v21; // eax
  int v22; // edi
  int v23; // esi
  int v24; // ebx
  char *v25; // eax
  int v26; // edi
  int v27; // esi
  int v28; // ebx
  char *v29; // eax
  int v30; // esi
  int v31; // edi
  int v32; // ebx
  char *v33; // eax
  int v34; // edx
  int v35; // ecx
  int v36; // edi
  int v37; // esi
  int v38; // ebx
  char *v39; // eax
  int v40; // edi
  int v41; // esi
  int v42; // ebx
  char *v43; // eax
  int v44; // edi
  int v45; // esi
  int v46; // ebx
  char *v47; // eax
  char *v48; // [esp+8h] [ebp-60h]
  int v49; // [esp+Ch] [ebp-5Ch]
  int v50; // [esp+10h] [ebp-58h]
  int v51; // [esp+14h] [ebp-54h]
  int v52; // [esp+18h] [ebp-50h]
  int v53; // [esp+1Ch] [ebp-4Ch]
  int v54; // [esp+20h] [ebp-48h]
  int v55; // [esp+24h] [ebp-44h]
  int v56; // [esp+28h] [ebp-40h]
  int v57; // [esp+38h] [ebp-30h]
  int v58; // [esp+3Ch] [ebp-2Ch]
  int v59; // [esp+40h] [ebp-28h]
  int v60; // [esp+44h] [ebp-24h]
  int v61; // [esp+48h] [ebp-20h]
  int v62; // [esp+4Ch] [ebp-1Ch]

  if ( a2 )
  {
    v50 = a4;
    v49 = a3;
    v48 = (char *)a2;
    fprintf(stream, "%s (%s) %s\n", a2, a3, a4);
    dword_805B1AC = (int)&loc_8050312;
    sub_805490C();
  }
  v49 = a4;
  v48 = (char *)a3;
  fprintf(stream, "%s %s\n", a3, a4);
  v6 = gettext("(C)");
  v49 = 2017;
  v48 = v6;
  fprintf(stream, "Copyright %s %d Free Software Foundation, Inc.", v6, 2017);
  v7 = gettext(
         "\n"
         "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\n"
         "This is free software: you are free to change and redistribute it.\n"
         "There is NO WARRANTY, to the extent permitted by law.\n"
         "\n");
  fputs_unlocked(v7, stream);
  switch ( a6 )
  {
    case 0:
      abort();
      return result;
    case 1:
      v8 = *(_DWORD *)a5;
      v9 = gettext("Written by %s.\n");
      v48 = (char *)v8;
      return fprintf(stream, v9, v8);
    case 2:
      v11 = *(_DWORD *)(a5 + 4);
      v12 = *(_DWORD *)a5;
      v13 = gettext("Written by %s and %s.\n");
      v49 = v11;
      v48 = (char *)v12;
      return fprintf(stream, v13, v12, v11);
    case 3:
      v14 = *(_DWORD *)(a5 + 8);
      v15 = *(_DWORD *)(a5 + 4);
      v16 = *(_DWORD *)a5;
      v17 = gettext("Written by %s, %s, and %s.\n");
      v50 = v14;
      v49 = v15;
      v48 = (char *)v16;
      return fprintf(stream, v17, v16, v15, v14);
    case 4:
      v62 = *(_DWORD *)(a5 + 12);
      v18 = *(_DWORD *)(a5 + 8);
      v19 = *(_DWORD *)(a5 + 4);
      v20 = *(_DWORD *)a5;
      v21 = gettext("Written by %s, %s, %s,\nand %s.\n");
      v51 = v62;
      v50 = v18;
      v49 = v19;
      v48 = (char *)v20;
      return fprintf(stream, v21, v20, v19, v18, v62);
    case 5:
      v62 = *(_DWORD *)(a5 + 16);
      v61 = *(_DWORD *)(a5 + 12);
      v22 = *(_DWORD *)(a5 + 8);
      v23 = *(_DWORD *)(a5 + 4);
      v24 = *(_DWORD *)a5;
      v25 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
      v52 = v62;
      v51 = v61;
      v50 = v22;
      v49 = v23;
      v48 = (char *)v24;
      return fprintf(stream, v25, v24, v23, v22, v61, v62);
    case 6:
      v62 = *(_DWORD *)(a5 + 20);
      v61 = *(_DWORD *)(a5 + 16);
      v60 = *(_DWORD *)(a5 + 12);
      v26 = *(_DWORD *)(a5 + 8);
      v27 = *(_DWORD *)(a5 + 4);
      v28 = *(_DWORD *)a5;
      v29 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
      v53 = v62;
      v52 = v61;
      v51 = v60;
      v50 = v26;
      v49 = v27;
      v48 = (char *)v28;
      fprintf(stream, v29, v28, v27, v26, v60, v61, v62);
      dword_805B1FC = (int)&loc_80507F3;
      sub_80546E7();
      goto LABEL_11;
    case 7:
LABEL_11:
      v30 = *(_DWORD *)(a5 + 24);
      v62 = *(_DWORD *)(a5 + 20);
      v61 = *(_DWORD *)(a5 + 16);
      v60 = *(_DWORD *)(a5 + 12);
      v59 = *(_DWORD *)(a5 + 8);
      v31 = *(_DWORD *)(a5 + 4);
      v32 = *(_DWORD *)a5;
      v33 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
      v54 = v30;
      v53 = v62;
      v52 = v61;
      v51 = v60;
      v50 = v59;
      v49 = v31;
      v48 = (char *)v32;
      fprintf(stream, v33, v32, v31, v59, v60, v61, v62, v30);
      dword_805B238 = (int)&loc_80507F3;
      sub_8054576(v35, v34);
      goto LABEL_12;
    case 8:
LABEL_12:
      v36 = *(_DWORD *)(a5 + 28);
      v62 = *(_DWORD *)(a5 + 24);
      v61 = *(_DWORD *)(a5 + 20);
      v60 = *(_DWORD *)(a5 + 16);
      v59 = *(_DWORD *)(a5 + 12);
      v58 = *(_DWORD *)(a5 + 8);
      v37 = *(_DWORD *)(a5 + 4);
      v38 = *(_DWORD *)a5;
      v39 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
      v55 = v36;
      v54 = v62;
      v53 = v61;
      v52 = v60;
      v51 = v59;
      v50 = v58;
      v49 = v37;
      v48 = (char *)v38;
      return fprintf(stream, v39, v38, v37, v58, v59, v60, v61, v62, v36);
    case 9:
      v40 = *(_DWORD *)(a5 + 32);
      v62 = *(_DWORD *)(a5 + 28);
      v61 = *(_DWORD *)(a5 + 24);
      v60 = *(_DWORD *)(a5 + 20);
      v59 = *(_DWORD *)(a5 + 16);
      v58 = *(_DWORD *)(a5 + 12);
      v57 = *(_DWORD *)(a5 + 8);
      v41 = *(_DWORD *)(a5 + 4);
      v42 = *(_DWORD *)a5;
      v43 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
      v56 = v40;
      v55 = v62;
      v54 = v61;
      v53 = v60;
      v52 = v59;
      v51 = v58;
      v50 = v57;
      v49 = v41;
      v48 = (char *)v42;
      fprintf(stream, v43, v42, v41, v57, v58, v59, v60, v61, v62, v40);
      dword_805B224 = (int)&loc_80507F3;
      sub_80545E2();
      break;
    default:
      break;
  }
  v44 = *(_DWORD *)(a5 + 32);
  v62 = *(_DWORD *)(a5 + 28);
  v61 = *(_DWORD *)(a5 + 24);
  v60 = *(_DWORD *)(a5 + 20);
  v59 = *(_DWORD *)(a5 + 16);
  v58 = *(_DWORD *)(a5 + 12);
  v57 = *(_DWORD *)(a5 + 8);
  v45 = *(_DWORD *)(a5 + 4);
  v46 = *(_DWORD *)a5;
  v47 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
  v56 = v44;
  v55 = v62;
  v54 = v61;
  v53 = v60;
  v52 = v59;
  v51 = v58;
  v50 = v57;
  v49 = v45;
  v48 = (char *)v46;
  return fprintf(stream, v47, v46, v45, v57, v58, v59, v60, v61, v62, v44);
}
// 80491E0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8054576: using guessed type int __fastcall sub_8054576(_DWORD, _DWORD);
// 80545E2: using guessed type int sub_80545E2(void);
// 80546E7: using guessed type int sub_80546E7(void);
// 805490C: using guessed type int sub_805490C(void);
// 805B1AC: using guessed type int dword_805B1AC;
// 805B1FC: using guessed type int dword_805B1FC;
// 805B224: using guessed type int dword_805B224;
// 805B238: using guessed type int dword_805B238;

//----- (08050853) --------------------------------------------------------
int __cdecl sub_8050853(FILE *stream, int a2, int a3, int a4, int a5)
{
  int *v5; // eax
  int v7; // [esp+24h] [ebp-34h]
  int v8[12]; // [esp+28h] [ebp-30h]

  v7 = 0;
  dword_805B1FC = (int)&loc_805087B;
  sub_80546E7();
  do
  {
    if ( (unsigned int)++v7 > 9 )
      break;
    v5 = (int *)a5;
    a5 += 4;
    v8[v7] = *v5;
  }
  while ( v8[v7] );
  return sub_80502A3(stream, a2, a3, a4, (int)v8, v7);
}
// 80546E7: using guessed type int sub_80546E7(void);
// 805B1FC: using guessed type int dword_805B1FC;
// 8050853: using guessed type int var_30[12];

//----- (080508CE) --------------------------------------------------------
int sub_80508CE(FILE *stream, int a2, int a3, int a4, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a4);
  return sub_8050853(stream, a2, a3, a4, (int)va);
}

//----- (0805096E) --------------------------------------------------------
void __cdecl sub_805096E(int a1, unsigned int a2)
{
  dword_805B284 = (int (*)(void))sub_805099D;
  JUMPOUT(0x7FFFFFFF / a2, a1, &loc_804F343);
  sub_8050C56();
}
// 805099D: using guessed type int sub_805099D();
// 805B284: using guessed type int (*dword_805B284)(void);

//----- (0805099D) --------------------------------------------------------
#error "80509AD: positive sp value has been found (funcsize=0)"

//----- (080509AE) --------------------------------------------------------
void *__cdecl sub_80509AE(void *ptr, int a2, int a3)
{
  if ( 0x7FFFFFFFu / a3 < a2 )
    sub_8050C56();
  return sub_8050AD0(ptr, a3 * a2);
}

//----- (080509E3) --------------------------------------------------------
void *__cdecl sub_80509E3(void *ptr, int a2, int a3)
{
  int v3; // ecx
  void *v4; // eax
  unsigned int v6; // [esp+1Ch] [ebp-Ch]

  v6 = *(_DWORD *)a2;
  v4 = &loc_8050A10;
  if ( ptr )
    v4 = &loc_8050A4A;
  dword_805B15C = (int)v4;
  sub_8054AE0(v3);
  if ( !v6 )
    v6 = (0x40u / a3 == 0) + 0x40u / a3;
  if ( 0x7FFFFFFFu / a3 < v6 )
    sub_8050C56();
  *(_DWORD *)a2 = v6;
  return sub_8050AD0(ptr, a3 * v6);
}
// 8054AE0: using guessed type int __fastcall sub_8054AE0(_DWORD);
// 805B15C: using guessed type int dword_805B15C;

//----- (08050A93) --------------------------------------------------------
void *__cdecl sub_8050A93(size_t size)
{
  return sub_8050AA6(size);
}

//----- (08050AA6) --------------------------------------------------------
void *__cdecl sub_8050AA6(size_t size)
{
  void *v2; // [esp+1Ch] [ebp-Ch]

  v2 = malloc(size);
  if ( !v2 && size )
    sub_8050C56();
  return v2;
}

//----- (08050AD0) --------------------------------------------------------
void *__cdecl sub_8050AD0(void *ptr, size_t size)
{
  void *v2; // eax
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  bool v6; // zf
  void *v7; // eax
  void *ptra; // [esp+20h] [ebp+8h]

  v2 = &loc_8050AF5;
  if ( size )
    v2 = &loc_8050B22;
  dword_805B224 = (int)v2;
  sub_80545E2();
  if ( ptr )
  {
    free(ptr);
    dword_805B1C0 = (int)&locret_8050B64;
    sub_805487F(v4, v3);
  }
  v5 = realloc(ptr, size);
  ptra = v5;
  v6 = v5 == 0;
  v7 = &loc_8050B56;
  if ( !v6 )
    v7 = &loc_8050B61;
  dword_805B24C = (int)v7;
  sub_8054506();
  if ( size )
    sub_8050C56();
  return ptra;
}
// 8050AD0: could not find valid save-restore pair for ebx
// 8054506: using guessed type int sub_8054506(void);
// 80545E2: using guessed type int sub_80545E2(void);
// 805487F: using guessed type int __fastcall sub_805487F(_DWORD, _DWORD);
// 805B1C0: using guessed type int dword_805B1C0;
// 805B224: using guessed type int dword_805B224;
// 805B24C: using guessed type int dword_805B24C;

//----- (08050B66) --------------------------------------------------------
void *__cdecl sub_8050B66(void *ptr, int a2)
{
  return sub_80509E3(ptr, a2, 1);
}

//----- (08050BB2) --------------------------------------------------------
void __cdecl __noreturn sub_8050BB2(size_t nmemb, size_t size)
{
  bool v2; // zf
  int v3; // edx
  int v4; // ecx
  int (*v5)(); // eax

  if ( 0x7FFFFFFF / size >= nmemb )
  {
    v2 = calloc(nmemb, size) == 0;
    v5 = (int (*)())&loc_8050BFE;
    if ( !v2 )
      v5 = sub_8050C03;
    dword_805B1C0 = (int)v5;
    sub_805487F(v4, v3);
  }
  sub_8050C56();
}
// 8050C03: using guessed type int sub_8050C03();
// 805487F: using guessed type int __fastcall sub_805487F(_DWORD, _DWORD);
// 805B1C0: using guessed type int dword_805B1C0;

//----- (08050C03) --------------------------------------------------------
#error "8050C07: positive sp value has been found (funcsize=0)"

//----- (08050C08) --------------------------------------------------------
void *__cdecl sub_8050C08(void *src, size_t n)
{
  void *v2; // eax

  v2 = sub_8050AA6(n);
  return memcpy(v2, src, n);
}

//----- (08050C56) --------------------------------------------------------
void __noreturn sub_8050C56()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (08050C8F) --------------------------------------------------------
unsigned __int64 __cdecl sub_8050C8F(char *nptr, int base, int a3, int a4, int a5, int a6, char *s, int a8, int a9)
{
  int v9; // ecx
  void *v10; // eax
  void *v11; // ebx
  int v12; // ecx
  int v13; // edx
  int v15; // [esp+Ch] [ebp-3Ch]
  void *v16; // [esp+10h] [ebp-38h]
  unsigned __int64 v17; // [esp+20h] [ebp-28h]
  unsigned __int64 v18; // [esp+28h] [ebp-20h]
  int v19; // [esp+34h] [ebp-14h]
  unsigned __int64 v20; // [esp+38h] [ebp-10h]

  v18 = __PAIR__(a4, a3);
  v17 = __PAIR__(a6, a5);
  v19 = sub_80514A7(nptr, 0, base, (int)&v20, s);
  if ( v19 )
  {
    if ( v19 == 1 )
    {
      *__errno_location() = 75;
    }
    else
    {
      v10 = &loc_8050D73;
      if ( v19 != 3 )
        v10 = &loc_8050D7E;
      dword_805B15C = (int)v10;
      sub_8054AE0(v9);
      *__errno_location() = 0;
    }
  }
  else if ( v20 < v18 || v17 < v20 )
  {
    v19 = 1;
    if ( v20 <= 0x3FFFFFFF )
      *__errno_location() = 34;
    else
      *__errno_location() = 75;
  }
  if ( v19 )
  {
    v11 = sub_804E50C(nptr);
    if ( *__errno_location() == 22 )
      v13 = 0;
    else
      v13 = *__errno_location();
    if ( a9 )
    {
      dword_805B274 = (int)&loc_8050DD0;
      sub_80543E8(v12, v13);
    }
    v16 = v11;
    v15 = a8;
    error(1, v13, "%s: %s", a8, v11);
  }
  return v20;
}
// 80543E8: using guessed type int __fastcall sub_80543E8(_DWORD, _DWORD);
// 8054AE0: using guessed type int __fastcall sub_8054AE0(_DWORD);
// 805B15C: using guessed type int dword_805B15C;
// 805B274: using guessed type int dword_805B274;

//----- (08050DFB) --------------------------------------------------------
unsigned __int64 __cdecl sub_8050DFB(char *nptr, int a2, int a3, int a4, int a5, char *s, int a7, int a8)
{
  return sub_8050C8F(nptr, 10, a2, a3, a4, a5, s, a7, a8);
}

//----- (08050E5F) --------------------------------------------------------
signed int __cdecl sub_8050E5F(unsigned int *a1, unsigned int a2)
{
  signed int result; // eax

  if ( 0xFFFFFFFF / a2 >= *a1 )
  {
    *a1 *= a2;
    result = 0;
  }
  else
  {
    *a1 = -1;
    result = 1;
  }
  return result;
}

//----- (08050EA3) --------------------------------------------------------
int __cdecl sub_8050EA3(unsigned int *a1, unsigned int a2, int a3)
{
  signed int v3; // eax
  int v4; // eax
  int v6; // [esp+14h] [ebp-4h]

  v6 = 0;
  dword_805B1AC = (int)&loc_8050EDC;
  sub_805490C();
  do
  {
    v3 = sub_8050E5F(a1, a2);
    v6 |= v3;
    v4 = a3--;
  }
  while ( v4 );
  return v6;
}
// 805490C: using guessed type int sub_805490C(void);
// 805B1AC: using guessed type int dword_805B1AC;

//----- (08050EEE) --------------------------------------------------------
int __cdecl sub_8050EEE(char *nptr, int a2, int base, int a4, char *s)
{
  char **v5; // eax
  const unsigned __int16 **v6; // eax
  int v7; // ecx
  int v8; // edx
  bool v9; // zf
  void *v10; // eax
  int result; // eax
  void *v12; // eax
  int v13; // edx
  int v14; // ecx
  void *v15; // eax
  int v16; // edx
  int v17; // ecx
  int v18; // eax
  void *v19; // eax
  int v20; // edx
  int v21; // ecx
  int v22; // [esp+4h] [ebp-44h]
  unsigned __int8 v23; // [esp+1Fh] [ebp-29h]
  char v24; // [esp+20h] [ebp-28h]
  unsigned int v25; // [esp+24h] [ebp-24h]
  int v26; // [esp+28h] [ebp-20h]
  char *v27; // [esp+2Ch] [ebp-1Ch]
  unsigned int v28; // [esp+30h] [ebp-18h]
  int v29; // [esp+34h] [ebp-14h]
  int v30; // [esp+38h] [ebp-10h]
  char **endptr; // [esp+3Ch] [ebp-Ch]

  v26 = 0;
  if ( base < 0 || base > 36 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoul");
  if ( a2 )
    v5 = (char **)a2;
  else
    v5 = (char **)&v24;
  endptr = v5;
  *__errno_location() = 0;
  v27 = nptr;
  v23 = *nptr;
  dword_805B184 = (int)&loc_8050F7C;
  sub_80549F2();
  v23 = *++v27;
  v6 = __ctype_b_loc();
  v8 = v23;
  v9 = ((*v6)[v8] & 0x2000) == 0;
  v10 = &loc_8050FB3;
  if ( !v9 )
    v10 = &loc_8050F6F;
  dword_805B210 = (int)v10;
  sub_805465C(v7, v8 * 2);
  if ( v23 == 45 )
    return 4;
  v25 = strtoul(nptr, endptr, base);
  if ( *endptr == nptr )
  {
    v12 = &loc_8051008;
    if ( !s )
      v12 = &loc_8051050;
    dword_805B24C = (int)v12;
    sub_8054506();
    if ( **endptr )
    {
      v22 = **endptr;
      if ( strchr(s, v22) )
      {
        v25 = 1;
        dword_805B198 = (int)&loc_805109B;
        sub_8054980(v14, v13);
      }
    }
    result = 4;
  }
  else
  {
    if ( !*__errno_location() )
    {
      if ( !s )
      {
        *(_DWORD *)a4 = v25;
        return v26;
      }
      if ( **endptr )
      {
        v28 = 1024;
        v29 = 1;
        v22 = **endptr;
        if ( !strchr(s, v22) )
        {
          *(_DWORD *)a4 = v25;
          return v26 | 2;
        }
        switch ( **endptr )
        {
          case 69:
          case 71:
          case 75:
          case 77:
          case 80:
          case 84:
          case 89:
          case 90:
          case 103:
          case 107:
          case 109:
          case 116:
            if ( !strchr(s, 48) )
              break;
            v18 = (*endptr)[1];
            switch ( v18 )
            {
              case 68:
                goto LABEL_36;
              case 105:
                v19 = &loc_805117E;
                if ( (*endptr)[2] != 66 )
                  v19 = &loc_8051199;
                dword_805B274 = (int)v19;
                sub_80543E8(v17, v16);
                v29 += 2;
                dword_805B274 = (int)&loc_80511A6;
                sub_80543E8(v21, v20);
                break;
              case 66:
LABEL_36:
                v28 = 1000;
                ++v29;
                break;
            }
            break;
          default:
            break;
        }
        switch ( **endptr )
        {
          case 66:
            goto LABEL_39;
          case 69:
            v30 = sub_8050EA3(&v25, v28, 6);
            break;
          case 71:
          case 103:
            v30 = sub_8050EA3(&v25, v28, 3);
            break;
          case 75:
          case 107:
            v30 = sub_8050EA3(&v25, v28, 1);
            break;
          case 77:
          case 109:
            v30 = sub_8050EA3(&v25, v28, 2);
            break;
          case 80:
            v30 = sub_8050EA3(&v25, v28, 5);
            dword_805B24C = (int)&loc_8051370;
            sub_8054506();
            goto LABEL_46;
          case 84:
          case 116:
LABEL_46:
            v30 = sub_8050EA3(&v25, v28, 4);
            break;
          case 89:
            v30 = sub_8050EA3(&v25, v28, 8);
            break;
          case 90:
            v30 = sub_8050EA3(&v25, v28, 7);
            break;
          case 98:
            v30 = sub_8050E5F(&v25, 0x200u);
            dword_805B260 = (int)&loc_8051370;
            sub_8054473();
LABEL_39:
            v30 = sub_8050E5F(&v25, 0x400u);
            break;
          case 99:
            v30 = 0;
            break;
          case 119:
            v30 = sub_8050E5F(&v25, 2u);
            break;
          default:
            *(_DWORD *)a4 = v25;
            dword_805B260 = (int)&locret_80513A0;
            sub_8054473();
            break;
        }
        v26 |= v30;
        *endptr += v29;
        if ( **endptr )
          v26 |= 2u;
      }
      *(_DWORD *)a4 = v25;
      return v26;
    }
    v9 = *__errno_location() == 34;
    v15 = &loc_805108A;
    if ( v9 )
      v15 = &loc_8051094;
    dword_805B260 = (int)v15;
    sub_8054473();
    result = 4;
  }
  return result;
}
// 8050EEE: could not find valid save-restore pair for ebx
// 80543E8: using guessed type int __fastcall sub_80543E8(_DWORD, _DWORD);
// 8054473: using guessed type int sub_8054473(void);
// 8054506: using guessed type int sub_8054506(void);
// 805465C: using guessed type int __fastcall sub_805465C(_DWORD, _DWORD);
// 8054980: using guessed type int __fastcall sub_8054980(_DWORD, _DWORD);
// 80549F2: using guessed type int sub_80549F2(void);
// 805B184: using guessed type int dword_805B184;
// 805B198: using guessed type int dword_805B198;
// 805B210: using guessed type int dword_805B210;
// 805B24C: using guessed type int dword_805B24C;
// 805B260: using guessed type int dword_805B260;
// 805B274: using guessed type int dword_805B274;

//----- (080513A2) --------------------------------------------------------
int __cdecl sub_80513A2(_DWORD *a1, signed int a2)
{
  unsigned __int64 v2; // rcx
  int v3; // ebx

  v2 = sub_8053F60(0xFFFFFFFFFFFFFFFFLL, a2, a2 >> 31);
  if ( v2 < *(_QWORD *)a1 )
  {
    *a1 = -1;
    a1[1] = -1;
    dword_805B15C = (int)&loc_805143B;
    sub_8054AE0(v2);
  }
  v3 = a1[1];
  *(_QWORD *)a1 *= a2;
  return 0;
}
// 8054AE0: using guessed type int __fastcall sub_8054AE0(_DWORD);
// 805B15C: using guessed type int dword_805B15C;

//----- (08051443) --------------------------------------------------------
int __cdecl sub_8051443(_DWORD *a1, signed int a2, int a3)
{
  int v3; // eax
  void *v4; // eax
  int v6; // [esp+1Ch] [ebp-Ch]

  v6 = 0;
  dword_805B1AC = (int)&loc_805147C;
  sub_805490C();
  v3 = sub_80513A2(a1, a2);
  v6 |= v3;
  v4 = &loc_80514A2;
  if ( a3 )
    v4 = &loc_8051467;
  dword_805B260 = (int)v4;
  sub_8054473();
  return v6;
}
// 8054473: using guessed type int sub_8054473(void);
// 805490C: using guessed type int sub_805490C(void);
// 805B1AC: using guessed type int dword_805B1AC;
// 805B260: using guessed type int dword_805B260;

//----- (080514A7) --------------------------------------------------------
int __cdecl sub_80514A7(char *nptr, int a2, int base, int a4, char *s)
{
  void *v5; // eax
  int result; // eax
  int v7; // edx
  bool v8; // zf
  void *v9; // eax
  int v10; // edx
  int v11; // edx
  unsigned __int8 i; // [esp+1Bh] [ebp-2Dh]
  char v13; // [esp+1Ch] [ebp-2Ch]
  int v14; // [esp+20h] [ebp-28h]
  char *v15; // [esp+24h] [ebp-24h]
  int v16; // [esp+28h] [ebp-20h]
  int v17; // [esp+2Ch] [ebp-1Ch]
  char **endptr; // [esp+34h] [ebp-14h]
  uintmax_t v19; // [esp+38h] [ebp-10h]

  v14 = 0;
  if ( base < 0 || base > 36 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoumax");
  v5 = &loc_80514DF;
  if ( a2 )
    v5 = &loc_805150A;
  dword_805B148 = (int)v5;
  sub_8054B6D();
  endptr = (char **)&v13;
  *__errno_location() = 0;
  v15 = nptr;
  for ( i = *nptr; (*__ctype_b_loc())[i] & 0x2000; i = *v15 )
    ++v15;
  if ( i == 45 )
    return 4;
  v19 = strtoumax(nptr, endptr, base);
  if ( *endptr == nptr )
  {
    if ( s && **endptr )
    {
      if ( strchr(s, **endptr) )
      {
        v19 = 1LL;
        dword_805B170 = (int)&loc_8051617;
        sub_8054A66();
      }
    }
    result = 4;
  }
  else
  {
    if ( *__errno_location() )
    {
      if ( *__errno_location() != 34 )
        return 4;
      v14 = 1;
    }
    if ( s )
    {
      if ( **endptr )
      {
        v16 = 1024;
        v17 = 1;
        v8 = strchr(s, **endptr) == 0;
        v9 = &loc_8051688;
        if ( !v8 )
          v9 = &loc_80516A1;
        dword_805B170 = (int)v9;
        sub_8054A66();
        v10 = HIDWORD(v19);
        *(_DWORD *)a4 = v19;
        *(_DWORD *)(a4 + 4) = v10;
        result = v14 | 2;
      }
      else
      {
        v11 = HIDWORD(v19);
        *(_DWORD *)a4 = v19;
        *(_DWORD *)(a4 + 4) = v11;
        result = v14;
      }
    }
    else
    {
      v7 = HIDWORD(v19);
      *(_DWORD *)a4 = v19;
      *(_DWORD *)(a4 + 4) = v7;
      result = v14;
    }
  }
  return result;
}
// 80514A7: could not find valid save-restore pair for ebx
// 8054A66: using guessed type int sub_8054A66(void);
// 8054B6D: using guessed type int sub_8054B6D(void);
// 805B148: using guessed type int dword_805B148;
// 805B170: using guessed type int dword_805B170;

//----- (0805194F) --------------------------------------------------------
int __cdecl sub_805194F(FILE *stream)
{
  int v2; // eax
  __int64 v3; // rax
  int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]

  v4 = 0;
  if ( fileno(stream) < 0 )
    return fclose(stream);
  if ( !__freading(stream) || (v2 = fileno(stream), LODWORD(v3) = lseek64(v2, 0, 0, 1), v3 != -1) )
  {
    if ( sub_8051A4B(stream) )
      v4 = *__errno_location();
  }
  v5 = fclose(stream);
  if ( v4 )
  {
    *__errno_location() = v4;
    v5 = -1;
  }
  return v5;
}
// 8049340: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08051A12) --------------------------------------------------------
int __cdecl sub_8051A12(FILE *stream)
{
  int result; // eax

  result = stream->_flags & 0x100;
  if ( result )
    result = sub_8051A8B(stream, 0, 0, 1);
  return result;
}

//----- (08051A4B) --------------------------------------------------------
int __cdecl sub_8051A4B(FILE *fp)
{
  if ( !fp || !__freading(fp) )
    return fflush(fp);
  sub_8051A12(fp);
  return fflush(fp);
}

//----- (08051A8B) --------------------------------------------------------
int __cdecl sub_8051A8B(FILE *stream, int a2, int a3, int a4)
{
  int v4; // eax
  __off64_t v5; // rax

  if ( stream->_IO_read_end != stream->_IO_read_ptr
    || stream->_IO_write_ptr != stream->_IO_write_base
    || stream->_IO_save_base )
  {
    return fseeko64(stream, a2, a3, a4);
  }
  v4 = fileno(stream);
  LODWORD(v5) = lseek64(v4, a2, a3, a4);
  if ( v5 == -1 )
    return -1;
  stream->_flags &= 0xFFFFFFEF;
  stream->_offset = v5;
  return 0;
}
// 8049010: using guessed type int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8049340: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08051B5D) --------------------------------------------------------
size_t __cdecl sub_8051B5D(wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  char v5; // [esp+18h] [ebp-10h]
  size_t v6; // [esp+1Ch] [ebp-Ch]

  if ( !pwc )
    pwc = (wchar_t *)&v5;
  v6 = mbrtowc(pwc, s, n, p);
  if ( v6 <= 0xFFFFFFFD || !n || !((unsigned __int8)sub_8051DE3(0) ^ 1) )
    return v6;
  *pwc = (unsigned __int8)*s;
  return 1;
}

//----- (08051BCF) --------------------------------------------------------
int __cdecl sub_8051BCF(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // esi
  unsigned __int8 *v3; // ebx
  unsigned __int8 v5; // [esp+1Eh] [ebp-Ah]
  unsigned __int8 v6; // [esp+1Fh] [ebp-9h]

  v2 = a1;
  v3 = a2;
  if ( a1 == a2 )
    return 0;
  do
  {
    v5 = sub_8053F0B(*v2);
    v6 = sub_8053F0B(*v3);
    if ( !v5 )
      break;
    ++v2;
    ++v3;
  }
  while ( v5 == v6 );
  return v5 - v6;
}

//----- (08051C34) --------------------------------------------------------
int __cdecl sub_8051C34(FILE *fp)
{
  bool v1; // ST26_1
  int v2; // edx
  int v3; // ecx
  bool v4; // zf
  int v5; // edx
  int v6; // ecx
  void *v7; // eax
  bool v9; // [esp+1Dh] [ebp-Bh]
  bool v10; // [esp+1Fh] [ebp-9h]

  v9 = __fpending(fp) != 0;
  v1 = ferror_unlocked(fp) != 0;
  v10 = sub_805194F(fp) != 0;
  if ( !v1 )
  {
    if ( !v10 )
      return 0;
    if ( !v9 )
    {
      v4 = *__errno_location() == 9;
      v7 = &loc_8051CAA;
      if ( v4 )
        v7 = &loc_8051CDC;
      dword_805B274 = (int)v7;
      sub_80543E8(v6, v5);
    }
  }
  if ( v10 != 1 )
    *__errno_location() = 0;
  dword_805B238 = (int)&locret_8051CE1;
  sub_8054576(v3, v2);
  return 0;
}
// 80543E8: using guessed type int __fastcall sub_80543E8(_DWORD, _DWORD);
// 8054576: using guessed type int __fastcall sub_8054576(_DWORD, _DWORD);
// 805B238: using guessed type int dword_805B238;
// 805B274: using guessed type int dword_805B274;

//----- (08051CE3) --------------------------------------------------------
FILE *__cdecl sub_8051CE3(int a1, char *modes)
{
  int v2; // eax
  bool v3; // zf
  void *v4; // eax
  int v5; // ST30_4
  int v7; // ST34_4
  int v8; // ecx
  FILE *stream; // [esp+1Ch] [ebp-1Ch]
  signed int v10; // [esp+20h] [ebp-18h]
  int fd; // [esp+24h] [ebp-14h]

  v2 = fopen64(a1, modes);
  stream = (FILE *)v2;
  v3 = v2 == 0;
  v4 = &loc_8051D1D;
  if ( v3 )
    v4 = &loc_8051DDE;
  dword_805B1D4 = (int)v4;
  sub_80547EC();
  v10 = fileno(stream);
  if ( v10 >= 0 && v10 <= 2 )
  {
    fd = sub_80538C3(v10);
    if ( fd < 0 )
    {
      v5 = *__errno_location();
      sub_805194F(stream);
      *__errno_location() = v5;
      return 0;
    }
    if ( sub_805194F(stream) || (stream = fdopen(fd, modes)) == 0 )
    {
      v7 = *__errno_location();
      close(fd);
      *__errno_location() = v7;
      dword_805B210 = (int)&locret_8051DE1;
      sub_805465C(v8, v7);
    }
  }
  return stream;
}
// 8049090: using guessed type int __cdecl fopen64(_DWORD, _DWORD);
// 805465C: using guessed type int __fastcall sub_805465C(_DWORD, _DWORD);
// 80547EC: using guessed type int sub_80547EC(void);
// 805B1D4: using guessed type int dword_805B1D4;
// 805B210: using guessed type int dword_805B210;

//----- (08051DE3) --------------------------------------------------------
int __cdecl sub_8051DE3(int category)
{
  unsigned __int8 v2; // [esp+1Bh] [ebp-Dh]
  const char *s1; // [esp+1Ch] [ebp-Ch]

  v2 = 1;
  s1 = setlocale(category, 0);
  if ( s1 && (!strcmp(s1, "C") || !strcmp(s1, "POSIX")) )
    v2 = 0;
  return v2;
}

//----- (08051E41) --------------------------------------------------------
int __cdecl sub_8051E41(int a1)
{
  return *(_DWORD *)(a1 + 8);
}

//----- (08051E4C) --------------------------------------------------------
int __cdecl sub_8051E4C(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (08051E57) --------------------------------------------------------
int __cdecl sub_8051E57(int a1)
{
  return *(_DWORD *)(a1 + 16);
}

//----- (08051E62) --------------------------------------------------------
unsigned int __cdecl sub_8051E62(int a1)
{
  _DWORD *i; // [esp+0h] [ebp-10h]
  unsigned int v3; // [esp+4h] [ebp-Ch]
  _DWORD *v4; // [esp+8h] [ebp-8h]
  unsigned int j; // [esp+Ch] [ebp-4h]

  v3 = 0;
  for ( i = *(_DWORD **)a1; *(_DWORD *)(a1 + 4) > (unsigned int)i; i += 2 )
  {
    if ( *i )
    {
      v4 = i;
      for ( j = 1; ; ++j )
      {
        v4 = (_DWORD *)v4[1];
        if ( !v4 )
          break;
      }
      if ( j > v3 )
        v3 = j;
    }
  }
  return v3;
}

//----- (08052049) --------------------------------------------------------
int __cdecl sub_8052049(int a1, int a2)
{
  unsigned int v3; // [esp+1Ch] [ebp-Ch]

  v3 = (*(int (__cdecl **)(int, _DWORD))(a1 + 24))(a2, *(_DWORD *)(a1 + 8));
  if ( *(_DWORD *)(a1 + 8) <= v3 )
    abort();
  return 8 * v3 + *(_DWORD *)a1;
}

//----- (080522FB) --------------------------------------------------------
bool __cdecl sub_80522FB(unsigned int a1)
{
  int v1; // ST08_4
  unsigned int v3; // [esp+8h] [ebp-8h]
  unsigned int v4; // [esp+Ch] [ebp-4h]

  v3 = 3;
  v4 = 9;
  while ( v4 < a1 && a1 % v3 )
  {
    v1 = v3 + 1;
    v4 += 4 * v1;
    v3 = v1 + 1;
  }
  return a1 % v3 != 0;
}

//----- (08052352) --------------------------------------------------------
unsigned int __usercall sub_8052352@<eax>(int a1@<edx>, int a2@<ecx>, unsigned int a3)
{
  bool v3; // zf
  void *v4; // eax
  unsigned int v6; // [esp+Ch] [ebp+8h]

  if ( a3 <= 9 )
    a3 = 10;
  dword_805B210 = (int)&loc_8052384;
  sub_805465C(a2, a1);
  v6 = (a3 | 1) + 2;
  if ( v6 != -1 )
  {
    v3 = sub_80522FB(v6) == 1;
    v4 = &loc_80523B5;
    if ( !v3 )
      v4 = &loc_8052380;
    dword_805B260 = (int)v4;
    sub_8054473();
  }
  return v6;
}
// 8054473: using guessed type int sub_8054473(void);
// 805465C: using guessed type int __fastcall sub_805465C(_DWORD, _DWORD);
// 805B210: using guessed type int dword_805B210;
// 805B260: using guessed type int dword_805B260;

//----- (080523F1) --------------------------------------------------------
unsigned int __cdecl sub_80523F1(int a1, unsigned int a2)
{
  return sub_8053B8D(a1, 3) % a2;
}

//----- (0805241C) --------------------------------------------------------
bool __cdecl sub_805241C(int a1, int a2)
{
  return a1 == a2;
}

//----- (0805242A) --------------------------------------------------------
signed int __cdecl sub_805242A(int a1)
{
  int v2; // [esp+8h] [ebp-8h]

  v2 = *(_DWORD *)(a1 + 20);
  if ( (_UNKNOWN *)v2 == &unk_8056018 )
    return 1;
  if ( *(float *)(v2 + 8) > 0.1
    && 1.0 - 0.1 > *(float *)(v2 + 8)
    && *(float *)(v2 + 12) > 0.1 + 1.0
    && *(float *)v2 >= 0.0
    && *(float *)(v2 + 4) > *(float *)v2 + 0.1
    && *(float *)(v2 + 4) <= 1.0
    && *(float *)(v2 + 8) > *(float *)v2 + 0.1 )
  {
    return 1;
  }
  *(_DWORD *)(a1 + 20) = &unk_8056018;
  return 0;
}

//----- (080524E6) --------------------------------------------------------
unsigned int __usercall sub_80524E6@<eax>(signed __int64 a1@<edx:eax>, int a2@<ecx>, unsigned int a3, int a4)
{
  unsigned int result; // eax
  float v5; // [esp+20h] [ebp-4h]
  unsigned int v6; // [esp+2Ch] [ebp+8h]

  if ( *(_BYTE *)(a4 + 16) != 1 )
  {
    v5 = (long double)a3 / *(float *)(a4 + 8);
    if ( v5 >= 4294967300.0 )
      return 0;
    a1 = (signed __int64)v5;
    a3 = a1;
  }
  v6 = sub_8052352(SHIDWORD(a1), a2, a3);
  if ( v6 <= 0x1FFFFFFF )
    result = v6;
  else
    result = 0;
  return result;
}

//----- (08052573) --------------------------------------------------------
int __cdecl sub_8052573(unsigned int a1, void *a2, unsigned int (__cdecl *a3)(int a1, unsigned int a2), bool (__cdecl *a4)(int a1, int a2), int a5)
{
  signed __int64 v6; // rax
  int v7; // ecx
  void *ptr; // [esp+1Ch] [ebp-Ch]

  if ( !a3 )
    a3 = sub_80523F1;
  if ( !a4 )
    a4 = sub_805241C;
  ptr = malloc(0x28u);
  if ( !ptr )
    return 0;
  if ( !a2 )
    a2 = &unk_8056018;
  *((_DWORD *)ptr + 5) = a2;
  if ( !((unsigned __int8)sub_805242A((int)ptr) ^ 1) )
  {
    LODWORD(v6) = a1;
    *((_DWORD *)ptr + 2) = sub_80524E6(v6, v7, a1, (int)a2);
    if ( *((_DWORD *)ptr + 2) )
    {
      *(_DWORD *)ptr = calloc(*((_DWORD *)ptr + 2), 8u);
      if ( *(_DWORD *)ptr )
      {
        *((_DWORD *)ptr + 1) = 8 * *((_DWORD *)ptr + 2) + *(_DWORD *)ptr;
        *((_DWORD *)ptr + 3) = 0;
        *((_DWORD *)ptr + 4) = 0;
        *((_DWORD *)ptr + 6) = a3;
        *((_DWORD *)ptr + 7) = a4;
        *((_DWORD *)ptr + 8) = a5;
        *((_DWORD *)ptr + 9) = 0;
        dword_805B260 = (int)&locret_80526A7;
        sub_8054473();
      }
    }
  }
  free(ptr);
  return 0;
}
// 8054473: using guessed type int sub_8054473(void);
// 805B260: using guessed type int dword_805B260;

//----- (08052777) --------------------------------------------------------
void __usercall sub_8052777(int a1@<edx>, int a2@<ecx>, void *a3)
{
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  int v6; // edx
  int v7; // ecx
  void *v8; // eax
  void **i; // [esp+14h] [ebp-14h]
  void *ptr; // [esp+18h] [ebp-10h]
  void *v11; // [esp+1Ch] [ebp-Ch]

  if ( *((_DWORD *)a3 + 8) && *((_DWORD *)a3 + 4) )
  {
    i = *(void ***)a3;
    dword_805B1C0 = (int)&loc_8052801;
    sub_805487F(a2, a1);
    do
    {
      v5 = &loc_80527D6;
      if ( !*i )
        v5 = &loc_80527FD;
      dword_805B238 = (int)v5;
      sub_8054576(v4, v3);
      for ( ptr = i; ptr; ptr = (void *)*((_DWORD *)ptr + 1) )
        (*((void (__cdecl **)(_DWORD))a3 + 8))(*(_DWORD *)ptr);
      i += 2;
    }
    while ( *((_DWORD *)a3 + 1) > (unsigned int)i );
  }
  for ( i = *(void ***)a3; *((_DWORD *)a3 + 1) > (unsigned int)i; i += 2 )
  {
    ptr = i[1];
    dword_805B260 = (int)&loc_8052850;
    sub_8054473();
    v11 = (void *)*((_DWORD *)ptr + 1);
    free(ptr);
    ptr = v11;
    v8 = &loc_805286F;
    if ( v11 )
      v8 = &loc_8052836;
    dword_805B238 = (int)v8;
    sub_8054576(v7, v6);
  }
  ptr = (void *)*((_DWORD *)a3 + 9);
  dword_805B1D4 = (int)&loc_80528B8;
  sub_80547EC();
  do
  {
    v11 = (void *)*((_DWORD *)ptr + 1);
    free(ptr);
    ptr = v11;
  }
  while ( v11 );
  free(*(void **)a3);
  free(a3);
}
// 8052777: could not find valid save-restore pair for ebx
// 8054473: using guessed type int sub_8054473(void);
// 8054576: using guessed type int __fastcall sub_8054576(_DWORD, _DWORD);
// 80547EC: using guessed type int sub_80547EC(void);
// 805487F: using guessed type int __fastcall sub_805487F(_DWORD, _DWORD);
// 805B1C0: using guessed type int dword_805B1C0;
// 805B1D4: using guessed type int dword_805B1D4;
// 805B238: using guessed type int dword_805B238;
// 805B260: using guessed type int dword_805B260;

//----- (080528D8) --------------------------------------------------------
void *__cdecl sub_80528D8(int a1)
{
  int v2; // [esp+1Ch] [ebp-Ch]

  if ( !*(_DWORD *)(a1 + 36) )
    return malloc(8u);
  v2 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(v2 + 4);
  return (void *)v2;
}

//----- (08052913) --------------------------------------------------------
int __cdecl sub_8052913(int a1, _DWORD *a2)
{
  int result; // eax

  *a2 = 0;
  a2[1] = *(_DWORD *)(a1 + 36);
  result = a1;
  *(_DWORD *)(a1 + 36) = a2;
  return result;
}

//----- (08052936) --------------------------------------------------------
int __cdecl sub_8052936(int a1, int a2, _DWORD *a3)
{
  _DWORD *v3; // eax
  bool v4; // zf
  void *v5; // eax

  v3 = (_DWORD *)sub_8052049(a1, a2);
  *a3 = v3;
  v4 = *v3 == 0;
  v5 = &loc_8052981;
  if ( !v4 )
    v5 = &loc_805298B;
  dword_805B260 = (int)v5;
  sub_8054473();
  return 0;
}
// 8054473: using guessed type int sub_8054473(void);
// 805B260: using guessed type int dword_805B260;

//----- (08052ADE) --------------------------------------------------------
signed int __cdecl sub_8052ADE(int a1, int a2, char a3)
{
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  void *v6; // eax
  char v8; // [esp+Ch] [ebp-2Ch]
  int *v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]

  v8 = a3;
  v9 = *(int **)a2;
  dword_805B1E8 = (int)&loc_8052C76;
  sub_805475B();
  do
  {
    if ( *v9 )
    {
      v10 = v9[1];
      v5 = &loc_8052BB5;
      if ( v10 )
        v5 = &loc_8052B21;
      dword_805B238 = (int)v5;
      sub_8054576(v4, v3);
      v11 = *v9;
      v9[1] = 0;
      v6 = &loc_8052BE6;
      if ( !v8 )
        v6 = &loc_8052BEB;
      dword_805B1D4 = (int)v6;
      sub_80547EC();
    }
    v9 += 2;
  }
  while ( *(_DWORD *)(a2 + 4) > (unsigned int)v9 );
  return 1;
}
// 8052ADE: could not find valid save-restore pair for ebx
// 8054576: using guessed type int __fastcall sub_8054576(_DWORD, _DWORD);
// 805475B: using guessed type int sub_805475B(void);
// 80547EC: using guessed type int sub_80547EC(void);
// 805B1D4: using guessed type int dword_805B1D4;
// 805B1E8: using guessed type int dword_805B1E8;
// 805B238: using guessed type int dword_805B238;

//----- (08052C8C) --------------------------------------------------------
signed int __usercall sub_8052C8C@<eax>(signed __int64 a1@<edx:eax>, int a2@<ecx>, int a3, unsigned int a4)
{
  bool v5; // zf
  void *v6; // eax
  unsigned int nmemb; // [esp+10h] [ebp-38h]
  char *v8; // [esp+18h] [ebp-30h]
  char *v9; // [esp+1Ch] [ebp-2Ch]
  unsigned int v10; // [esp+20h] [ebp-28h]
  int v11; // [esp+24h] [ebp-24h]
  int v12; // [esp+28h] [ebp-20h]
  int v13; // [esp+2Ch] [ebp-1Ch]
  int v14; // [esp+30h] [ebp-18h]
  int v15; // [esp+34h] [ebp-14h]
  int v16; // [esp+38h] [ebp-10h]
  int v17; // [esp+3Ch] [ebp-Ch]

  LODWORD(a1) = a4;
  nmemb = sub_80524E6(a1, a2, a4, *(_DWORD *)(a3 + 20));
  if ( !nmemb )
    return 0;
  if ( *(_DWORD *)(a3 + 8) == nmemb )
    return 1;
  v8 = (char *)calloc(nmemb, 8u);
  if ( !v8 )
    return 0;
  v10 = nmemb;
  v9 = &v8[8 * nmemb];
  v11 = 0;
  v12 = 0;
  v13 = *(_DWORD *)(a3 + 20);
  v14 = *(_DWORD *)(a3 + 24);
  v15 = *(_DWORD *)(a3 + 28);
  v16 = *(_DWORD *)(a3 + 32);
  v17 = *(_DWORD *)(a3 + 36);
  if ( !(unsigned __int8)sub_8052ADE((int)&v8, a3, 0) )
  {
    *(_DWORD *)(a3 + 36) = v17;
    if ( !((unsigned __int8)sub_8052ADE(a3, (int)&v8, 1) ^ 1) )
    {
      v5 = (unsigned __int8)sub_8052ADE(a3, (int)&v8, 0) == 1;
      v6 = &loc_8052E41;
      if ( v5 )
        v6 = &loc_8052E46;
      dword_805B260 = (int)v6;
      sub_8054473();
    }
    abort();
  }
  free(*(void **)a3);
  *(_DWORD *)a3 = v8;
  *(_DWORD *)(a3 + 4) = v9;
  *(_DWORD *)(a3 + 8) = v10;
  *(_DWORD *)(a3 + 12) = v11;
  *(_DWORD *)(a3 + 36) = v17;
  return 1;
}
// 8054473: using guessed type int sub_8054473(void);
// 805B260: using guessed type int dword_805B260;

//----- (08052E5A) --------------------------------------------------------
signed int __cdecl sub_8052E5A(unsigned int *a1, int a2, _DWORD *a3)
{
  signed int result; // eax
  int v4; // ecx
  long double v5; // fst7
  signed __int64 v6; // rax
  bool v7; // zf
  int v8; // edx
  int v9; // ecx
  void *v10; // eax
  int *v11; // [esp+2Ch] [ebp-1Ch]
  int v12; // [esp+30h] [ebp-18h]
  unsigned int v13; // [esp+34h] [ebp-14h]
  float v14; // [esp+38h] [ebp-10h]
  _DWORD *v15; // [esp+3Ch] [ebp-Ch]

  if ( !a2 )
    abort();
  v12 = sub_8052936((int)a1, a2, &v11);
  if ( v12 )
  {
    if ( a3 )
      *a3 = v12;
    result = 0;
  }
  else if ( (long double)a1[3] <= *(float *)(a1[5] + 8) * (long double)a1[2]
         || (sub_805242A((int)a1), (long double)a1[3] <= *(float *)(a1[5] + 8) * (long double)a1[2]) )
  {
    if ( *v11 )
    {
      v15 = sub_80528D8((int)a1);
      if ( v15 )
      {
        *v15 = a2;
        v15[1] = v11[1];
        v11[1] = (int)v15;
        ++a1[4];
        result = 1;
      }
      else
      {
        result = -1;
      }
    }
    else
    {
      *v11 = a2;
      ++a1[4];
      ++a1[3];
      result = 1;
    }
  }
  else
  {
    v13 = a1[5];
    if ( *(_BYTE *)(v13 + 16) )
      v5 = (long double)a1[2] * *(float *)(v13 + 12);
    else
      v5 = (long double)a1[2] * *(float *)(v13 + 12) * *(float *)(v13 + 8);
    v14 = v5;
    if ( v14 < 4294967300.0 )
    {
      v6 = (signed __int64)v14;
      LODWORD(v6) = a1;
      v7 = (unsigned __int8)sub_8052C8C(v6, v4, (int)a1, (signed __int64)v14) == 1;
      v10 = &loc_8052FF8;
      if ( v7 )
        v10 = &loc_8053002;
      dword_805B198 = (int)v10;
      sub_8054980(v9, v8);
      result = -1;
    }
    else
    {
      result = -1;
    }
  }
  return result;
}
// 8054980: using guessed type int __fastcall sub_8054980(_DWORD, _DWORD);
// 805B198: using guessed type int dword_805B198;

//----- (080530B0) --------------------------------------------------------
int __cdecl sub_80530B0(unsigned int *a1, int a2)
{
  void *v2; // eax
  int v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]

  v5 = sub_8052E5A(a1, a2, &v4);
  if ( v5 == -1 )
    return 0;
  v2 = &loc_80530F7;
  if ( v5 )
    v2 = &loc_80530FC;
  dword_805B170 = (int)v2;
  sub_8054A66();
  return v4;
}
// 8054A66: using guessed type int sub_8054A66(void);
// 805B170: using guessed type int dword_805B170;

//----- (0805311D) --------------------------------------------------------
int __cdecl sub_805311D(int a1, int a2)
{
  int v3; // ecx
  void *v4; // eax
  signed __int64 v5; // rax
  int v6; // ecx
  _DWORD *v7; // [esp+28h] [ebp-20h]
  void *ptr; // [esp+2Ch] [ebp-1Ch]
  int v9; // [esp+30h] [ebp-18h]
  int v10; // [esp+34h] [ebp-14h]
  unsigned int v11; // [esp+38h] [ebp-10h]
  void *v12; // [esp+3Ch] [ebp-Ch]

  v9 = sub_8052936(a1, a2, &v7);
  if ( !v9 )
    return 0;
  --*(_DWORD *)(a1 + 16);
  if ( !*v7
    && **(float **)(a1 + 20) * (long double)*(unsigned int *)(a1 + 8) > (long double)(unsigned int)--*(_DWORD *)(a1 + 12) )
  {
    sub_805242A(a1);
    if ( **(float **)(a1 + 20) * (long double)*(unsigned int *)(a1 + 8) > (long double)*(unsigned int *)(a1 + 12) )
    {
      v10 = *(_DWORD *)(a1 + 20);
      v4 = &loc_8053232;
      if ( !*(_BYTE *)(v10 + 16) )
        v4 = &loc_805326C;
      dword_805B198 = (int)v4;
      sub_8054980(v3, 0);
      v5 = (signed __int64)((long double)*(unsigned int *)(a1 + 8) * *(float *)(v10 + 4));
      v11 = v5;
      LODWORD(v5) = a1;
      if ( (unsigned __int8)sub_8052C8C(v5, v6, a1, v11) ^ 1 )
      {
        for ( ptr = *(void **)(a1 + 36); ptr; ptr = v12 )
        {
          v12 = (void *)*((_DWORD *)ptr + 1);
          free(ptr);
        }
        *(_DWORD *)(a1 + 36) = 0;
      }
    }
  }
  return v9;
}
// 8054980: using guessed type int __fastcall sub_8054980(_DWORD, _DWORD);
// 805B198: using guessed type int dword_805B198;

//----- (08053302) --------------------------------------------------------
void *sub_8053302()
{
  _BOOL4 v0; // eax
  int v1; // eax
  bool v2; // zf
  void *v3; // eax
  void *ptr; // [esp+14h] [ebp-B4h]
  void *v6; // [esp+18h] [ebp-B0h]
  char *s; // [esp+1Ch] [ebp-ACh]
  void *v8; // [esp+20h] [ebp-A8h]
  int v9; // [esp+24h] [ebp-A4h]
  char *v10; // [esp+28h] [ebp-A0h]
  size_t n; // [esp+2Ch] [ebp-9Ch]
  size_t v12; // [esp+30h] [ebp-98h]
  _BOOL4 v13; // [esp+34h] [ebp-94h]
  void *dest; // [esp+38h] [ebp-90h]
  int fd; // [esp+3Ch] [ebp-8Ch]
  FILE *stream; // [esp+40h] [ebp-88h]
  int c; // [esp+44h] [ebp-84h]
  unsigned int v18; // [esp+BCh] [ebp-Ch]

  v18 = __readgsdword(0x14u);
  v6 = (void *)dword_805BA2A;
  if ( !dword_805BA2A )
  {
    ptr = 0;
    v10 = "charset.alias";
    s = getenv("CHARSETALIASDIR");
    if ( !s || !*s )
    {
      ptr = 0;
      s = "/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib";
    }
    n = strlen(s);
    v12 = strlen(v10);
    v0 = n && s[n - 1] != 47;
    v13 = v0;
    dest = malloc(n + v0 + v12 + 1);
    if ( dest )
    {
      memcpy(dest, s, n);
      if ( v13 )
        *((_BYTE *)dest + n) = 47;
      memcpy((char *)dest + n + v13, v10, v12 + 1);
    }
    free(ptr);
    if ( dest )
    {
      fd = open64(dest, 0x20000);
      if ( fd >= 0 )
      {
        stream = fdopen(fd, "r");
        if ( !stream )
        {
          close(fd);
          v6 = &unk_805610F;
          dword_805B184 = (int)&loc_80537BE;
          sub_80549F2();
        }
        v8 = 0;
        v9 = 0;
        v1 = getc_unlocked(stream);
        c = v1;
        v2 = v1 == -1;
        v3 = &loc_8053573;
        if ( !v2 )
          v3 = &loc_8053578;
        dword_805B224 = (int)v3;
        sub_80545E2();
        sub_805194F(stream);
        if ( v9 )
        {
          *((_BYTE *)v8 + v9) = 0;
          v6 = v8;
        }
        else
        {
          v6 = &unk_805610F;
        }
      }
      else
      {
        v6 = &unk_805610F;
      }
      free(dest);
    }
    else
    {
      v6 = &unk_805610F;
    }
    dword_805BA2A = (int)v6;
  }
  return v6;
}
// 8048F50: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 80545E2: using guessed type int sub_80545E2(void);
// 80549F2: using guessed type int sub_80549F2(void);
// 805B184: using guessed type int dword_805B184;
// 805B224: using guessed type int dword_805B224;
// 805BA2A: using guessed type int dword_805BA2A;

//----- (080537F7) --------------------------------------------------------
const char *sub_80537F7()
{
  char *s2; // ST24_4
  void *v1; // eax
  const char *s1; // [esp+18h] [ebp-10h]

  s1 = nl_langinfo(14);
  if ( !s1 )
    s1 = (const char *)&unk_805610F;
  s2 = (char *)sub_8053302();
  v1 = &loc_80538AD;
  if ( *s2 )
    v1 = &loc_8053823;
  dword_805B170 = (int)v1;
  sub_8054A66();
  if ( !*s1 )
    s1 = "ASCII";
  return s1;
}
// 8054A66: using guessed type int sub_8054A66(void);
// 805B170: using guessed type int dword_805B170;

//----- (080538C3) --------------------------------------------------------
int __cdecl sub_80538C3(int fd)
{
  return sub_80538E6(fd, 0, 3);
}

//----- (080538E6) --------------------------------------------------------
int __cdecl sub_80538E6(int fd, int cmd, char a3)
{
  char *v3; // eax
  char *v4; // eax
  int v6; // [esp+8h] [ebp-30h]
  char *v7; // [esp+18h] [ebp-20h]
  int v8; // [esp+1Ch] [ebp-1Ch]
  char v9[4]; // [esp+20h] [ebp-18h]
  int v10; // [esp+24h] [ebp-14h]
  int v11; // [esp+28h] [ebp-10h]

  v8 = -1;
  v7 = &a3;
  if ( cmd != 1030 )
  {
    v4 = v7;
    v7 += 4;
    return fcntl(fd, cmd, *(_DWORD *)v4);
  }
  v3 = v7;
  v7 += 4;
  *(_DWORD *)v9 = *(_DWORD *)v3;
  if ( dword_805BA2E < 0 )
  {
    v8 = sub_80538E6(fd, 0, v9[0]);
    goto LABEL_9;
  }
  v6 = *(_DWORD *)v9;
  v8 = fcntl(fd, 1030, *(_DWORD *)v9);
  if ( v8 >= 0 || *__errno_location() != 22 )
  {
    dword_805BA2E = 1;
    dword_805B1E8 = (int)&loc_80539C2;
    sub_805475B();
  }
  v8 = sub_80538E6(fd, 0, v9[0]);
  if ( v8 >= 0 )
  {
    dword_805BA2E = -1;
LABEL_9:
    if ( v8 >= 0 && dword_805BA2E == -1 )
    {
      v10 = fcntl(v8, 1);
      if ( v10 < 0 || (v6 = v10 | 1, fcntl(v8, 2, v10 | 1) == -1) )
      {
        v11 = *__errno_location();
        close(v8);
        *__errno_location() = v11;
        v8 = -1;
      }
    }
  }
  return v8;
}
// 805475B: using guessed type int sub_805475B(void);
// 805B1E8: using guessed type int dword_805B1E8;
// 805BA2E: using guessed type int dword_805BA2E;

//----- (08053B8D) --------------------------------------------------------
int __cdecl sub_8053B8D(int a1, char a2)
{
  return __ROR4__(a1, a2);
}

//----- (08053F0B) --------------------------------------------------------
int __cdecl sub_8053F0B(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 65) > 0x19 )
    result = a1;
  else
    result = a1 + 32;
  return result;
}

//----- (08053F60) --------------------------------------------------------
signed __int64 __cdecl sub_8053F60(unsigned __int64 a1, unsigned int a2, unsigned int a3)
{
  void *v3; // eax
  unsigned int v4; // ecx
  signed __int64 result; // rax
  int v6; // ebp
  int v7; // ebp
  unsigned __int64 v8; // rtt
  unsigned int v9; // esi
  unsigned int v10; // edi
  unsigned __int64 v11; // rax
  unsigned int v12; // [esp+0h] [ebp-18h]
  unsigned int v13; // [esp+4h] [ebp-14h]
  unsigned int v14; // [esp+8h] [ebp-10h]

  v13 = a1;
  v12 = a2;
  if ( a3 )
  {
    if ( a3 <= HIDWORD(a1) )
    {
      _BitScanReverse((unsigned int *)&v6, a3);
      v7 = v6 ^ 0x1F;
      if ( v7 )
      {
        v14 = (a3 << v7) | (v12 >> (32 - v7));
        LODWORD(v8) = (HIDWORD(a1) << v7) | (v13 >> (32 - v7));
        HIDWORD(v8) = HIDWORD(a1) >> (32 - v7);
        v9 = v8 % v14;
        v10 = v8 / v14;
        v11 = (v12 << v7) * (unsigned __int64)v10;
        v12 = HIDWORD(v11);
        if ( v9 < HIDWORD(v11) || v13 << v7 < (unsigned int)v11 && v9 == v12 )
          return v10 - 1;
        dword_805B210 = (int)&loc_8053FF0;
        sub_805465C(v7, 0);
      }
      else if ( v12 > v13 && a3 >= HIDWORD(a1) )
      {
        return 0LL;
      }
      return 1LL;
    }
    return 0LL;
  }
  if ( a2 > HIDWORD(a1) )
    return (unsigned int)(a1 / a2);
  v3 = &loc_8053FA6;
  if ( a2 )
    v3 = &loc_8053FB1;
  dword_805B1C0 = (int)v3;
  sub_805487F(a2, HIDWORD(a1));
  LODWORD(result) = __PAIR__(HIDWORD(a1) % (1 / v4), (unsigned int)a1) / (1 / v4);
  HIDWORD(result) = HIDWORD(a1) / (1 / v4);
  return result;
}
// 805465C: using guessed type int __fastcall sub_805465C(_DWORD, _DWORD);
// 805487F: using guessed type int __fastcall sub_805487F(_DWORD, _DWORD);
// 805B1C0: using guessed type int dword_805B1C0;
// 805B210: using guessed type int dword_805B210;

//----- (080540AE) --------------------------------------------------------
char *__cdecl sub_80540AE(unsigned __int64 a1, __int64 a2)
{
  int v2; // ecx
  char *result; // eax
  int v4; // ebp
  int v5; // ebp
  unsigned int v6; // ebp
  unsigned __int64 v7; // rtt
  unsigned __int64 v8; // rax
  unsigned int v9; // edi
  unsigned __int64 v10; // rax
  unsigned int v11; // ecx
  int v12; // ebp
  int v13; // esi
  int v14; // ecx
  void *v15; // eax
  unsigned int v16; // [esp+0h] [ebp-20h]
  unsigned int v17; // [esp+4h] [ebp-1Ch]
  unsigned __int64 v18; // [esp+8h] [ebp-18h]
  unsigned int v19; // [esp+10h] [ebp-10h]

  v17 = HIDWORD(a1);
  v2 = a1;
  v19 = a1;
  v16 = a2;
  v18 = a1;
  if ( !HIDWORD(a2) )
  {
    if ( (unsigned int)a2 > HIDWORD(a1) )
      return (char *)(a1 % (unsigned int)a2);
    v6 = a2;
    if ( !(_DWORD)a2 )
      v6 = 1 / 0u;
    LODWORD(v7) = a1;
    HIDWORD(v7) = v17 % v6;
    dword_805B198 = (int)&loc_80540E9;
    sub_8054980(a1, v7 % v6);
    return (char *)v2;
  }
  if ( HIDWORD(a2) > HIDWORD(a1) )
    return (char *)v2;
  _BitScanReverse((unsigned int *)&v4, HIDWORD(a2));
  v5 = v4 ^ 0x1F;
  if ( v5 )
  {
    v17 = (HIDWORD(a2) << v5) | (v16 >> (32 - v5));
    LODWORD(v18) = v16 << v5;
    HIDWORD(v8) = HIDWORD(a1) >> (32 - v5);
    LODWORD(v8) = (HIDWORD(a1) << v5) | (v19 >> (32 - v5));
    HIDWORD(v18) = v19 << v5;
    v9 = v8 % v17;
    v10 = (v16 << v5) * (unsigned __int64)(unsigned int)(v8 / v17);
    v16 = HIDWORD(v10);
    v11 = v10;
    if ( v9 < HIDWORD(v10) || HIDWORD(v18) < (unsigned int)v10 && v9 == HIDWORD(v10) )
    {
      HIDWORD(v10) = v16;
      HIDWORD(v10) = (v10 - __PAIR__(v17, (unsigned int)v18)) >> 32;
      v11 = v10 - v18;
    }
    result = (char *)(((__PAIR__(v9, HIDWORD(v18)) - __PAIR__(HIDWORD(v10), v11)) >> 32 << (32 - (unsigned __int8)v5)) | ((HIDWORD(v18) - v11) >> v5));
  }
  else if ( v16 <= (unsigned int)v18 || HIDWORD(a2) < HIDWORD(v18) )
  {
    result = (char *)(a1 - a2);
  }
  else
  {
    dword_805B210 = (int)&loc_805411F;
    sub_805465C(a1, HIDWORD(a2));
    v12 = HIDWORD(v18);
    init_proc();
    result = (char *)&stru_805AF04.d_un;
    v13 = ((char *)&stru_805AF0C - (char *)&stru_805AF04.d_un) >> 2;
    if ( v13 )
    {
      ((void (__cdecl *)(unsigned int, _DWORD, int))stru_805AF04.d_un.d_val)(v17, v18, v12);
      v15 = &loc_8054298;
      if ( v13 != 1 )
        v15 = &loc_8054262;
      dword_805B15C = (int)v15;
      result = (char *)sub_8054AE0(v14);
    }
  }
  return result;
}
// 805465C: using guessed type int __fastcall sub_805465C(_DWORD, _DWORD);
// 8054980: using guessed type int __fastcall sub_8054980(_DWORD, _DWORD);
// 8054AE0: using guessed type int __fastcall sub_8054AE0(_DWORD);
// 805AF04: using guessed type Elf32_Dyn stru_805AF04;
// 805AF0C: using guessed type Elf32_Dyn stru_805AF0C;
// 805B15C: using guessed type int dword_805B15C;
// 805B198: using guessed type int dword_805B198;
// 805B210: using guessed type int dword_805B210;

//----- (080542B1) --------------------------------------------------------
int __cdecl sub_80542B1(int a1)
{
  return __cxa_atexit(a1, 0, dword_805B29C);
}
// 8049130: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 805B29C: using guessed type int dword_805B29C;

//----- (080542E0) --------------------------------------------------------
int __cdecl sub_80542E0(int a1, int a2)
{
  return __fxstat64(3, a1, a2);
}
// 80490C0: using guessed type int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD);

//----- (080543A7) --------------------------------------------------------
#error "80543E0: positive sp value has been found (funcsize=18)"

//----- (080543E8) --------------------------------------------------------
#error "80543EE: positive sp value has been found (funcsize=0)"

//----- (08054432) --------------------------------------------------------
#error "805446B: positive sp value has been found (funcsize=18)"

//----- (08054473) --------------------------------------------------------
#error "8054479: positive sp value has been found (funcsize=0)"

//----- (080544C5) --------------------------------------------------------
#error "80544FE: positive sp value has been found (funcsize=18)"

//----- (08054506) --------------------------------------------------------
#error "805450C: positive sp value has been found (funcsize=0)"

//----- (08054576) --------------------------------------------------------
#error "805457C: positive sp value has been found (funcsize=0)"

//----- (080545E2) --------------------------------------------------------
#error "80545E8: positive sp value has been found (funcsize=0)"

//----- (0805465C) --------------------------------------------------------
#error "8054662: positive sp value has been found (funcsize=0)"

//----- (080546A6) --------------------------------------------------------
#error "80546DF: positive sp value has been found (funcsize=18)"

//----- (080546E7) --------------------------------------------------------
#error "80546ED: positive sp value has been found (funcsize=0)"

//----- (0805475B) --------------------------------------------------------
#error "8054761: positive sp value has been found (funcsize=0)"

//----- (080547AB) --------------------------------------------------------
#error "80547E4: positive sp value has been found (funcsize=18)"

//----- (080547EC) --------------------------------------------------------
#error "80547F2: positive sp value has been found (funcsize=0)"

//----- (0805483E) --------------------------------------------------------
#error "8054877: positive sp value has been found (funcsize=18)"

//----- (0805487F) --------------------------------------------------------
#error "8054885: positive sp value has been found (funcsize=0)"

//----- (0805490C) --------------------------------------------------------
#error "8054912: positive sp value has been found (funcsize=0)"

//----- (08054980) --------------------------------------------------------
#error "8054986: positive sp value has been found (funcsize=0)"

//----- (080549F2) --------------------------------------------------------
#error "80549F8: positive sp value has been found (funcsize=0)"

//----- (08054A66) --------------------------------------------------------
#error "8054A6C: positive sp value has been found (funcsize=0)"

//----- (08054AE0) --------------------------------------------------------
#error "8054AE6: positive sp value has been found (funcsize=0)"

//----- (08054B6D) --------------------------------------------------------
#error "8054B73: positive sp value has been found (funcsize=0)"

//----- (08054B80) --------------------------------------------------------
int (**sub_8054B80())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_805AEC0;
  v1 = &off_805AEC4 - off_805AEC0;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_805AEC0[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 805AEC0: using guessed type int (*off_805AEC0[2])();
// 805AEC4: using guessed type int (*off_805AEC4)();

//----- (08054BE4) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 29 decompilation failure(s) on 241 function(s)"
