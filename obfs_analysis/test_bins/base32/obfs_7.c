/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8048D10();
// int strcmp(const char *s1, const char *s2);
// int open64(void); weak
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void *memmove(void *dest, const void *src, size_t n);
// void free(void *ptr);
// uintmax_t strtoumax(const char *nptr, char **endptr, int base);
// void *memcpy(void *dest, const void *src, size_t n);
// int fclose(FILE *stream);
// int getc_unlocked(FILE *stream);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// int fputc_unlocked(int c, FILE *stream);
// char *textdomain(const char *domainname);
// int ferror_unlocked(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// size_t __ctype_get_mb_cur_max(void);
// size_t __fpending(FILE *fp);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// void error(int status, int errnum, const char *format, ...);
// size_t fread_unlocked(void *ptr, size_t size, size_t n, FILE *stream);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// char *strchr(const char *s, int c);
// size_t strlen(const char *s);
// int fprintf(FILE *stream, const char *format, ...);
// void *memset(void *s, int c, size_t n);
// int *__errno_location(void);
// void *memchr(const void *s, int c, size_t n);
// int fileno(FILE *stream);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// char *strrchr(const char *s, int c);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// char *bindtextdomain(const char *domainname, const char *dirname);
// int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// int feof_unlocked(FILE *stream);
// void abort(void);
// int close(int fd);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// int _gmon_start__(void); weak
void sub_8049133();
void sub_8049150();
int sub_8049160();
int sub_80491D0();
int sub_80491F0();
void sub_804924F();
void sub_804926A();
int sub_804927A();
void sub_804935C();
void sub_8049377();
int sub_8049387();
void sub_8049485();
void sub_80494A0();
signed int sub_80494B0();
void sub_80495B9();
void sub_80495D4();
int sub_80495E4();
void sub_80496C6();
void sub_80496E1();
int sub_80496F1();
void sub_80497D3();
void sub_80497EE();
int sub_80497FE();
void sub_804990E();
void sub_8049929();
int sub_8049939();
void sub_8049A2D();
void sub_8049A48();
int sub_8049A58();
void sub_8049B56();
void sub_8049B71();
int sub_8049B81();
void sub_8049C63();
void sub_8049C7E();
int sub_8049C8E();
// int __usercall sub_8049D59@<eax>(void (__cdecl *a1)(int *)@<eax>);
void sub_8049DB7();
void sub_8049DD2();
int sub_8049DE2();
int sub_8049E6C();
void sub_8049F0B();
void sub_8049F26();
int sub_8049F36();
// int __usercall sub_8049FE8@<eax>(void (__cdecl *a1)(int *)@<eax>);
void sub_804A046();
void sub_804A061();
int sub_804A071();
void sub_804A153();
void sub_804A16E();
int sub_804A17E();
void sub_804A272();
void sub_804A28D();
int sub_804A29D();
int __fastcall sub_804A2C9(int a1);
int nullsub_3(void); // weak
int sub_804A2FB();
// int __usercall sub_804A381@<eax>(void (__cdecl *a1)(int *)@<eax>);
void sub_804A3CD();
void sub_804A3E8();
// signed int __usercall sub_804A3F8@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>);
// signed int __usercall sub_804A4A1@<eax>(int a1@<eax>);
void __spoils<edx,ecx> sub_804A540();
void sub_804A57A();
int sub_804A58A();
int sub_804A614();
int sub_804A656();
int sub_804A6BF();
int __cdecl sub_804A6EA(char *s1); // idb
void __cdecl __noreturn sub_804A880(int status); // idb
size_t __cdecl sub_804A97F(void *ptr, size_t n, int a3, int a4, int a5, FILE *stream);
void __cdecl __noreturn main(int argc, char **argv);
int __cdecl sub_804B4C8(char *s2, char *format, int, int, int, int, int, int, int, __int16, FILE *stream, char *s1, int, int, int); // idb
int __cdecl sub_804B68C(unsigned __int8 a1);
void __cdecl sub_804B69E(unsigned __int8 *a1, int a2, _BYTE *a3, int a4);
char __cdecl sub_804BAFA(unsigned __int8 a1);
_DWORD *__cdecl sub_804BB23(_DWORD *a1);
_DWORD __cdecl sub_804BB31(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_804BCDF(unsigned __int8 *a1, unsigned int a2, int *a3);
bool __cdecl sub_804C2D3(int *a1, unsigned __int8 *a2, unsigned int a3, int a4, int *a5);
void __noreturn sub_804C614();
int __cdecl sub_804C73B(int a1, int a2, int a3, int a4, int a5, int a6);
// int *__usercall sub_804C79C@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>, FILE *stream, int a8);
char *__cdecl sub_804C822(char *s);
int __cdecl sub_804C987(int a1, unsigned __int8 a2, char a3);
signed int sub_804CA56();
int sub_804CA60(void); // weak
int *__cdecl sub_804CA61(int *a1, int a2, int a3);
int __cdecl sub_804CAA2(_DWORD, _DWORD); // weak
char *__cdecl sub_804CB59(char *msgid);
int __cdecl sub_804CC66(int a1, unsigned int a2, char *a3, size_t a4, int a5, int a6, int a7, char *a8, char *a9);
int sub_804DBAC(); // weak
// void *__usercall sub_804DC9E@<eax>(int a1@<edx>, int a2@<ecx>, char *a3, size_t a4, _DWORD *a5, int a6);
_DWORD __cdecl sub_804DECB(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_804E177(int a1, int a2);
// int __usercall sub_804E1A1@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>, __int16 *a7@<ebp>, int a8, int a9, int a10);
int __cdecl sub_804E23C(int a1, int a2, int a3);
int __cdecl sub_804E27A(int a1, int a2, int a3, int a4);
_DWORD __cdecl sub_804E331(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_804E400(int a1, char a2);
int __cdecl sub_804E439(int a1);
int __cdecl sub_804E476(int a1, int a2, int a3);
int __cdecl sub_804E527(int a1, int a2, int a3, int a4);
int __cdecl sub_804E567(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_804E6A6(int a1, int a2, int a3);
int __cdecl sub_804E701(int a1, int a2);
int __cdecl sub_804E723(int a1);
int __cdecl sub_804E75D(FILE *stream, int, int, int, int, int); // idb
int __cdecl sub_804EE1D(FILE *stream, int, int, int, int); // idb
_DWORD __cdecl sub_804EE93(_DWORD, _DWORD, _DWORD, _DWORD, char); // weak
// void *__usercall sub_804EFBB@<eax>(signed int a1@<ebx>, void *ptr, int a3, int a4);
// void *__usercall sub_804F06B@<eax>(signed int a1@<ebx>, size_t size);
// void *__usercall sub_804F07E@<eax>(signed int a1@<ebx>, size_t size);
// void *__usercall sub_804F0A8@<eax>(signed int a1@<ebx>, void *ptr, size_t size);
// void *__usercall sub_804F199@<eax>(signed int a1@<ebx>, void *src, size_t n);
// void __usercall __noreturn sub_804F1E7(signed int a1@<ebx>);
void sub_804F245();
void __cdecl sub_804F24A(int a1);
unsigned __int64 __cdecl sub_804F26D(char *nptr, int base, int a3, int a4, int a5, int a6, char *s, int a8, int a9);
unsigned __int64 __cdecl sub_804F402(char *nptr, int a2, int a3, int a4, int a5, char *s, int a7, int a8);
signed int __cdecl sub_804F476(unsigned int *a1, int a2);
int __cdecl sub_804F522(unsigned int *a1, int a2, int a3);
int __cdecl sub_804F558(char *nptr, int, int base, int, char *s); // idb
int __cdecl sub_804FA1F(FILE *stream); // idb
int __cdecl sub_804FAFB(FILE *stream); // idb
// int __usercall sub_804FB34@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, FILE *fp);
int __cdecl sub_804FB93(FILE *stream, int, int, int); // idb
// size_t __usercall sub_804FCD6@<eax>(int a1@<edx>, int a2@<ecx>, wchar_t *pwc, char *s, size_t n, mbstate_t *p);
int sub_804FD61();
int sub_804FD6B();
int __cdecl sub_804FD75(int a1);
int __cdecl sub_804FDE0(unsigned __int8 *a1, unsigned __int8 *a2);
void __cdecl __noreturn sub_804FE45(FILE *fp); // idb
int __cdecl sub_804FF4B(int category); // idb
int sub_804FFDB(void); // weak
char *sub_8050555();
int __cdecl sub_8050880(int a1);
int __cdecl sub_80508B8(unsigned int a1, unsigned int a2, int a3, int a4);
int __cdecl sub_8050ACC(int a1);
int __fastcall sub_8050C98(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_8050D25(_DWORD); // weak
int sub_8050DB2(void); // weak
int sub_8050E22(void); // weak
int sub_8050E9C(void); // weak
int __cdecl sub_8050F25(_DWORD); // weak
int __fastcall sub_8050F97(_DWORD, _DWORD);
int __stdcall sub_8051005(_DWORD, _DWORD); // weak
int sub_8051071(void); // weak
int __stdcall sub_80510E7(_DWORD); // weak
int sub_805115B(void); // weak
int __stdcall sub_80511CF(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int sub_805123D(void); // weak
int __fastcall sub_80512AB(_DWORD, _DWORD, _DWORD);
int (**sub_80512C0())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN locret_804980D; // weak
_UNKNOWN loc_8049F62; // weak
_UNKNOWN loc_804A6B0; // weak
_UNKNOWN loc_804A6B5; // weak
_UNKNOWN loc_804B2E9; // weak
_UNKNOWN loc_804B394; // weak
_UNKNOWN loc_804B408; // weak
_UNKNOWN loc_804B477; // weak
_UNKNOWN loc_804B6FA; // weak
_UNKNOWN loc_804B6FF; // weak
_UNKNOWN loc_804BD4B; // weak
_UNKNOWN loc_804BD55; // weak
_UNKNOWN loc_804C3A9; // weak
_UNKNOWN loc_804C3B9; // weak
_UNKNOWN loc_804C3E9; // weak
_UNKNOWN loc_804C400; // weak
_UNKNOWN loc_804C4D9; // weak
_UNKNOWN loc_804C7BE; // weak
_UNKNOWN loc_804C7D6; // weak
_UNKNOWN loc_804C8F1; // weak
_UNKNOWN loc_804C902; // weak
_UNKNOWN loc_804C9C0; // weak
_UNKNOWN loc_804CBB5; // weak
_UNKNOWN loc_804CBD0; // weak
_UNKNOWN loc_804CD88; // weak
_UNKNOWN loc_804CDB4; // weak
_UNKNOWN loc_804CDC7; // weak
_UNKNOWN loc_804CE0A; // weak
_UNKNOWN loc_804CE94; // weak
_UNKNOWN loc_804CF1C; // weak
_UNKNOWN loc_804CFA6; // weak
_UNKNOWN loc_804D08F; // weak
_UNKNOWN loc_804D264; // weak
_UNKNOWN loc_804D269; // weak
_UNKNOWN loc_804D285; // weak
_UNKNOWN loc_804D319; // weak
_UNKNOWN loc_804D31E; // weak
_UNKNOWN loc_804D3D0; // weak
_UNKNOWN loc_804D40E; // weak
_UNKNOWN loc_804D5DC; // weak
_UNKNOWN loc_804D786; // weak
_UNKNOWN loc_804D7B0; // weak
_UNKNOWN loc_804D7BB; // weak
_UNKNOWN loc_804D816; // weak
_UNKNOWN loc_804D838; // weak
_UNKNOWN loc_804D857; // weak
_UNKNOWN loc_804D85C; // weak
_UNKNOWN loc_804D8EA; // weak
_UNKNOWN loc_804D95A; // weak
_UNKNOWN loc_804D9A8; // weak
_UNKNOWN loc_804D9B3; // weak
_UNKNOWN loc_804D9F5; // weak
_UNKNOWN loc_804DA60; // weak
_UNKNOWN loc_804DAC6; // weak
_UNKNOWN loc_804DAFD; // weak
_UNKNOWN loc_804DB1C; // weak
_UNKNOWN loc_804DB29; // weak
_UNKNOWN loc_804DB82; // weak
_UNKNOWN loc_804DBA7; // weak
_UNKNOWN loc_804DCCA; // weak
_UNKNOWN loc_804EFEE; // weak
_UNKNOWN loc_804F00B; // weak
_UNKNOWN loc_804F100; // weak
_UNKNOWN loc_804F10B; // weak
_UNKNOWN loc_804F368; // weak
_UNKNOWN loc_804F3A4; // weak
_UNKNOWN loc_804F3AD; // weak
_UNKNOWN loc_804F3D7; // weak
_UNKNOWN loc_804FA7F; // weak
_UNKNOWN loc_804FAB8; // weak
_UNKNOWN loc_804FCFB; // weak
_UNKNOWN loc_804FD01; // weak
_UNKNOWN loc_804FDA8; // weak
_UNKNOWN loc_804FDBC; // weak
_UNKNOWN loc_80505B3; // weak
_UNKNOWN loc_80505E3; // weak
_UNKNOWN loc_8050610; // weak
_UNKNOWN loc_8050640; // weak
_UNKNOWN loc_8050904; // weak
_UNKNOWN loc_8050940; // weak
char s = '\0'; // idb
struct option longopts = { "decode", 0, NULL, 100 }; // idb
char byte_8051A20[256] =
{
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\x1A',
  '\x1B',
  '\x1C',
  '\x1D',
  '\x1E',
  '\x1F',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\x01',
  '\x02',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\n',
  '\v',
  '\f',
  '\r',
  '\x0E',
  '\x0F',
  '\x10',
  '\x11',
  '\x12',
  '\x13',
  '\x14',
  '\x15',
  '\x16',
  '\x17',
  '\x18',
  '\x19',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF'
}; // idb
char byte_8051B20[32] =
{
  'A',
  'B',
  'C',
  'D',
  'E',
  'F',
  'G',
  'H',
  'I',
  'J',
  'K',
  'L',
  'M',
  'N',
  'O',
  'P',
  'Q',
  'R',
  'S',
  'T',
  'U',
  'V',
  'W',
  'X',
  'Y',
  'Z',
  '2',
  '3',
  '4',
  '5',
  '6',
  '7'
}; // idb
_UNKNOWN unk_8051C6E; // weak
_UNKNOWN unk_8051C72; // weak
_UNKNOWN unk_8051C85; // weak
_UNKNOWN unk_8052587; // weak
int dword_8052EFC = 0; // weak
int dword_8052F08 = 33554432; // weak
_UNKNOWN unk_80531BC; // weak
_UNKNOWN unk_80531BF; // weak
int dword_8053EF4 = 4263432; // weak
_UNKNOWN unk_805420C; // weak
_UNKNOWN unk_805420F; // weak
int (*off_8055EC4[2])() = { &sub_80491F0, &sub_80491D0 }; // weak
int (*off_8055EC8)() = &sub_80491D0; // weak
int (*dword_8056008)(void) = NULL; // weak
int dword_805610C = 0; // weak
int dword_8056120 = 0; // weak
int dword_8056134 = 0; // weak
int dword_8056148 = 0; // weak
int dword_805615C = 0; // weak
int dword_8056170 = 0; // weak
int dword_8056184 = 0; // weak
int dword_8056198 = 0; // weak
int dword_80561AC = 0; // weak
int dword_80561C0 = 0; // weak
int dword_80561D4 = 0; // weak
int dword_80561E8 = 0; // weak
int dword_80561FC = 0; // weak
int dword_8056210 = 0; // weak
int dword_8056240 = 0; // weak
char *off_8056244 = "8.28"; // weak
int status = 1; // idb
_UNKNOWN unk_805627C; // weak
_UNKNOWN unk_8056298; // weak
_UNKNOWN unk_805629B; // weak
_UNKNOWN unk_80562A0; // weak
_UNKNOWN unk_80562A3; // weak
_UNKNOWN unk_80562AC; // weak
_UNKNOWN unk_80562AF; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int program_invocation_name; // weak
int optind; // weak
FILE *stdout; // idb
char *optarg; // idb
char byte_805630C; // weak
_UNKNOWN unk_80564DE; // weak
char byte_805665B; // weak
char byte_80567DC; // weak
char byte_8056829; // weak
int dword_8056835; // weak
int dword_805683D[]; // weak
int dword_8056841; // weak
int dword_8056845; // weak
int dword_8056849; // weak
int dword_805684D; // weak
int dword_8056851; // weak
int dword_8056855; // weak
int dword_8056859; // weak
int dword_805685D; // weak
int dword_8056861; // weak
int dword_8056865; // weak
int dword_8056869; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (08048CE0) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 80490F0: using guessed type int _gmon_start__(void);

//----- (08048D10) --------------------------------------------------------
int sub_8048D10()
{
  return dword_8056008();
}
// 8056008: using guessed type int (*dword_8056008)(void);

//----- (08049100) --------------------------------------------------------
#error "8049103: positive sp value has been found (funcsize=2)"

//----- (08049133) --------------------------------------------------------
void sub_8049133()
{
  ;
}

//----- (08049150) --------------------------------------------------------
void sub_8049150()
{
  ;
}

//----- (08049160) --------------------------------------------------------
int sub_8049160()
{
  int result; // eax

  result = &unk_80562AF - &unk_80562AC;
  if ( (unsigned int)(&unk_80562AF - &unk_80562AC) > 6 )
    result = 0;
  return result;
}
// 8049160: could not find valid save-restore pair for ebp

//----- (080491D0) --------------------------------------------------------
int sub_80491D0()
{
  int result; // eax

  if ( !byte_805630C )
  {
    result = sub_8049160();
    byte_805630C = 1;
  }
  return result;
}
// 80491D0: could not find valid save-restore pair for ebp
// 805630C: using guessed type char byte_805630C;

//----- (080491F0) --------------------------------------------------------
int sub_80491F0()
{
  return 0;
}
// 80491F0: could not find valid save-restore pair for ebp

//----- (0804924F) --------------------------------------------------------
void sub_804924F()
{
  ;
}

//----- (0804926A) --------------------------------------------------------
void sub_804926A()
{
  ;
}

//----- (0804927A) --------------------------------------------------------
int sub_804927A()
{
  int result; // eax

  result = &unk_805629B - &unk_8056298;
  if ( (unsigned int)(&unk_805629B - &unk_8056298) > 6 )
    result = 0;
  return result;
}
// 804927A: could not find valid save-restore pair for ebp

//----- (0804935C) --------------------------------------------------------
void sub_804935C()
{
  ;
}

//----- (08049377) --------------------------------------------------------
void sub_8049377()
{
  ;
}

//----- (08049387) --------------------------------------------------------
int sub_8049387()
{
  int result; // eax

  result = &unk_805629B - &unk_8056298;
  if ( (unsigned int)(&unk_805629B - &unk_8056298) > 6 )
    result = 0;
  return result;
}
// 8049387: could not find valid save-restore pair for ebp

//----- (08049485) --------------------------------------------------------
void sub_8049485()
{
  ;
}

//----- (080494A0) --------------------------------------------------------
void sub_80494A0()
{
  ;
}

//----- (080494B0) --------------------------------------------------------
signed int sub_80494B0()
{
  return 3;
}
// 80494B0: could not find valid save-restore pair for ebp

//----- (080495B9) --------------------------------------------------------
void sub_80495B9()
{
  ;
}

//----- (080495D4) --------------------------------------------------------
void sub_80495D4()
{
  ;
}

//----- (080495E4) --------------------------------------------------------
int sub_80495E4()
{
  int result; // eax

  result = &unk_805629B - &unk_8056298;
  if ( (unsigned int)(&unk_805629B - &unk_8056298) > 6 )
    result = 0;
  return result;
}
// 80495E4: could not find valid save-restore pair for ebp

//----- (080496C6) --------------------------------------------------------
void sub_80496C6()
{
  ;
}

//----- (080496E1) --------------------------------------------------------
void sub_80496E1()
{
  ;
}

//----- (080496F1) --------------------------------------------------------
int sub_80496F1()
{
  int result; // eax

  result = &unk_805629B - &unk_8056298;
  if ( (unsigned int)(&unk_805629B - &unk_8056298) > 6 )
    result = 0;
  return result;
}
// 80496F1: could not find valid save-restore pair for ebp

//----- (080497D3) --------------------------------------------------------
void sub_80497D3()
{
  ;
}

//----- (080497EE) --------------------------------------------------------
void sub_80497EE()
{
  ;
}

//----- (080497FE) --------------------------------------------------------
int sub_80497FE()
{
  int result; // eax
  int (__stdcall *v1)(void *, int, int, int, int, int); // eax
  int v2; // [esp+4h] [ebp-18h]
  int v3; // [esp+8h] [ebp-14h]
  int v4; // [esp+Ch] [ebp-10h]
  int v5; // [esp+10h] [ebp-Ch]
  int v6; // [esp+14h] [ebp-8h]
  int v7; // [esp+18h] [ebp-4h]

  result = &unk_805629B - &unk_8056298;
  if ( (unsigned int)(&unk_805629B - &unk_8056298) > 6 )
  {
    v7 = 0;
    dword_8056148 = (int)&locret_804980D;
    v1 = (int (__stdcall *)(void *, int, int, int, int, int))sub_805115B();
    result = v1(&unk_8056298, v2, v3, v4, v5, v6);
  }
  return result;
}
// 805115B: using guessed type int sub_805115B(void);
// 8056148: using guessed type int dword_8056148;

//----- (0804990E) --------------------------------------------------------
void sub_804990E()
{
  ;
}

//----- (08049929) --------------------------------------------------------
void sub_8049929()
{
  ;
}

//----- (08049939) --------------------------------------------------------
int sub_8049939()
{
  int result; // eax

  result = &unk_80564DE - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_80564DE - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 8049939: could not find valid save-restore pair for ebp
// 80562C0: using guessed type int program_invocation_short_name;

//----- (08049A2D) --------------------------------------------------------
void sub_8049A2D()
{
  ;
}

//----- (08049A48) --------------------------------------------------------
void sub_8049A48()
{
  ;
}

//----- (08049A58) --------------------------------------------------------
int sub_8049A58()
{
  int result; // eax

  result = &unk_805420F - &unk_805420C;
  if ( (unsigned int)(&unk_805420F - &unk_805420C) > 6 )
    result = 0;
  return result;
}
// 8049A58: could not find valid save-restore pair for ebp

//----- (08049B56) --------------------------------------------------------
void sub_8049B56()
{
  ;
}

//----- (08049B71) --------------------------------------------------------
void sub_8049B71()
{
  ;
}

//----- (08049B81) --------------------------------------------------------
int sub_8049B81()
{
  int result; // eax

  result = &unk_805629B - &unk_8056298;
  if ( (unsigned int)(&unk_805629B - &unk_8056298) > 6 )
    result = 0;
  return result;
}
// 8049B81: could not find valid save-restore pair for ebp

//----- (08049C63) --------------------------------------------------------
void sub_8049C63()
{
  ;
}

//----- (08049C7E) --------------------------------------------------------
void sub_8049C7E()
{
  ;
}

//----- (08049C8E) --------------------------------------------------------
int sub_8049C8E()
{
  int result; // eax

  result = &unk_805629B - &unk_8056298;
  if ( (unsigned int)(&unk_805629B - &unk_8056298) > 6 )
    result = 0;
  return result;
}
// 8049C8E: could not find valid save-restore pair for ebp

//----- (08049D59) --------------------------------------------------------
int __usercall sub_8049D59@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  a1(&dword_8053EF4);
  return 0;
}
// 8053EF4: using guessed type int dword_8053EF4;

//----- (08049DB7) --------------------------------------------------------
void sub_8049DB7()
{
  ;
}

//----- (08049DD2) --------------------------------------------------------
void sub_8049DD2()
{
  ;
}

//----- (08049DE2) --------------------------------------------------------
int sub_8049DE2()
{
  int result; // eax

  result = &unk_805629B - &unk_8056298;
  if ( (unsigned int)(&unk_805629B - &unk_8056298) > 6 )
    result = 0;
  return result;
}
// 8049DE2: could not find valid save-restore pair for ebp

//----- (08049E6C) --------------------------------------------------------
int sub_8049E6C()
{
  int result; // eax

  result = sub_8049DE2();
  byte_805665B = 1;
  return result;
}
// 805665B: using guessed type char byte_805665B;

//----- (08049F0B) --------------------------------------------------------
void sub_8049F0B()
{
  ;
}

//----- (08049F26) --------------------------------------------------------
void sub_8049F26()
{
  ;
}

//----- (08049F36) --------------------------------------------------------
int sub_8049F36()
{
  int result; // eax

  result = &unk_80531BF - &unk_80531BC;
  if ( (unsigned int)(&unk_80531BF - &unk_80531BC) > 6 )
    result = 0;
  return result;
}
// 8049F36: could not find valid save-restore pair for ebp

//----- (08049FE8) --------------------------------------------------------
int __usercall sub_8049FE8@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  int v2; // edx
  int v3; // ecx

  a1(&dword_8052EFC);
  dword_8056198 = (int)&loc_8049F62;
  sub_8050F97(v3, v2);
  return 0;
}
// 8052EFC: using guessed type int dword_8052EFC;
// 8056198: using guessed type int dword_8056198;

//----- (0804A046) --------------------------------------------------------
void sub_804A046()
{
  ;
}

//----- (0804A061) --------------------------------------------------------
void sub_804A061()
{
  ;
}

//----- (0804A071) --------------------------------------------------------
int sub_804A071()
{
  int result; // eax

  result = &unk_805629B - &unk_8056298;
  if ( (unsigned int)(&unk_805629B - &unk_8056298) > 6 )
    result = 0;
  return result;
}
// 804A071: could not find valid save-restore pair for ebp

//----- (0804A153) --------------------------------------------------------
void sub_804A153()
{
  ;
}

//----- (0804A16E) --------------------------------------------------------
void sub_804A16E()
{
  ;
}

//----- (0804A17E) --------------------------------------------------------
int sub_804A17E()
{
  int result; // eax

  result = &unk_805629B - &unk_8056298;
  if ( (unsigned int)(&unk_805629B - &unk_8056298) > 6 )
    result = 0;
  return result;
}
// 804A17E: could not find valid save-restore pair for ebp

//----- (0804A272) --------------------------------------------------------
void sub_804A272()
{
  ;
}

//----- (0804A28D) --------------------------------------------------------
void sub_804A28D()
{
  ;
}

//----- (0804A29D) --------------------------------------------------------
int sub_804A29D()
{
  int result; // eax

  result = &unk_80562A3 - &unk_80562A0;
  if ( (unsigned int)(&unk_80562A3 - &unk_80562A0) > 6 )
    result = 0;
  return result;
}
// 804A29D: could not find valid save-restore pair for ebp

//----- (0804A2C9) --------------------------------------------------------
int __fastcall sub_804A2C9(int a1)
{
  dword_8056198 = (int)nullsub_3;
  sub_8050F97(a1, 0);
  return nullsub_3();
}
// 804A2FA: using guessed type int nullsub_3(void);
// 8056198: using guessed type int dword_8056198;

//----- (0804A2FB) --------------------------------------------------------
int sub_804A2FB()
{
  return nullsub_3();
}
// 804A2FB: could not find valid save-restore pair for ebp
// 804A2FA: using guessed type int nullsub_3(void);

//----- (0804A381) --------------------------------------------------------
int __usercall sub_804A381@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  int v1; // ecx

  a1(&dword_8052F08);
  return sub_804A2C9(v1);
}
// 8052F08: using guessed type int dword_8052F08;

//----- (0804A3CD) --------------------------------------------------------
void sub_804A3CD()
{
  ;
}

//----- (0804A3E8) --------------------------------------------------------
void sub_804A3E8()
{
  ;
}

//----- (0804A3F8) --------------------------------------------------------
signed int __usercall sub_804A3F8@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>)
{
  int v6; // [esp+18h] [ebp-4h]

  v6 = a5;
  __asm { pushfw }
  if ( sub_804CA56() != 732 )
    sub_804CA60();
  __asm { popfw }
  return 4;
}
// 804CA60: using guessed type int sub_804CA60(void);

//----- (0804A4A1) --------------------------------------------------------
signed int __usercall sub_804A4A1@<eax>(int a1@<eax>)
{
  char v1; // sf
  signed int result; // eax

  result = sub_804A3F8(0, 0, v1, 0, a1);
  byte_80567DC = 1;
  return result;
}
// 80567DC: using guessed type char byte_80567DC;

//----- (0804A540) --------------------------------------------------------
void __spoils<edx,ecx> sub_804A540()
{
  __asm { pushfw }
  if ( sub_804CA56() != 732 )
    sub_804CA60();
  __asm { popfw }
}
// 804CA60: using guessed type int sub_804CA60(void);

//----- (0804A57A) --------------------------------------------------------
void sub_804A57A()
{
  ;
}

//----- (0804A58A) --------------------------------------------------------
int sub_804A58A()
{
  int result; // eax

  result = &unk_80562A3 - &unk_80562A0;
  if ( (unsigned int)(&unk_80562A3 - &unk_80562A0) > 6 )
    result = 0;
  return result;
}
// 804A58A: could not find valid save-restore pair for ebp

//----- (0804A614) --------------------------------------------------------
int sub_804A614()
{
  int result; // eax

  result = sub_804A58A();
  byte_8056829 = 1;
  return result;
}
// 8056829: using guessed type char byte_8056829;

//----- (0804A656) --------------------------------------------------------
int sub_804A656()
{
  FILE *v0; // ebx
  char *v1; // eax
  void *v6; // eax
  FILE *v8; // [esp-Ah] [ebp-22h]
  int v9; // [esp-6h] [ebp-1Eh]
  int v10; // [esp-4h] [ebp-1Ch]

  v0 = stdout;
  v1 = gettext("\nWith no FILE, or when FILE is -, read standard input.\n");
  v10 = fputs_unlocked(v1, v0);
  __asm { pushfw }
  v8 = v0;
  if ( (signed int)v0 >= 10 )
  {
    v6 = &loc_804A6B0;
    if ( !(((_BYTE)v0 - 1) * (_BYTE)v0 & 1) )
      v6 = &loc_804A6B5;
    dword_8056184 = (int)v6;
    sub_8051005(v8, v9);
    abort();
  }
  __asm { popfw }
  return v10;
}
// 8048F50: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8051005: using guessed type int __stdcall sub_8051005(_DWORD, _DWORD);
// 8056184: using guessed type int dword_8056184;

//----- (0804A6BF) --------------------------------------------------------
int sub_804A6BF()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nMandatory arguments to long options are mandatory for short options too.\n");
  return fputs_unlocked(v1, v0);
}
// 8048F50: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804A6EA) --------------------------------------------------------
int __cdecl sub_804A6EA(char *s1)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // ebx
  char *v5; // eax
  int v7; // [esp+0h] [ebp-68h]
  char *v8; // [esp+4h] [ebp-64h]
  char *v9; // [esp+8h] [ebp-60h]
  char *v10; // [esp+1Ch] [ebp-4Ch]
  char **i; // [esp+20h] [ebp-48h]
  char *v12; // [esp+24h] [ebp-44h]
  const char *v13; // [esp+28h] [ebp-40h]
  const char *v14; // [esp+2Ch] [ebp-3Ch]
  const char *v15; // [esp+30h] [ebp-38h]
  const char *v16; // [esp+34h] [ebp-34h]
  const char *v17; // [esp+38h] [ebp-30h]
  const char *v18; // [esp+3Ch] [ebp-2Ch]
  const char *v19; // [esp+40h] [ebp-28h]
  const char *v20; // [esp+44h] [ebp-24h]
  const char *v21; // [esp+48h] [ebp-20h]
  const char *v22; // [esp+4Ch] [ebp-1Ch]
  const char *v23; // [esp+50h] [ebp-18h]
  const char *v24; // [esp+54h] [ebp-14h]
  int v25; // [esp+58h] [ebp-10h]
  int v26; // [esp+5Ch] [ebp-Ch]

  v13 = "[";
  v14 = "test invocation";
  v15 = "coreutils";
  v16 = "Multi-call invocation";
  v17 = "sha224sum";
  v18 = "sha2 utilities";
  v19 = "sha256sum";
  v20 = "sha2 utilities";
  v21 = "sha384sum";
  v22 = "sha2 utilities";
  v23 = "sha512sum";
  v24 = "sha2 utilities";
  v25 = 0;
  v26 = 0;
  v10 = s1;
  for ( i = (char **)(&v7 - 16); *i; i += 2 )
  {
    v8 = *i;
    if ( !strcmp(s1, v8) )
      break;
  }
  if ( i[1] )
    v10 = i[1];
  v1 = gettext("\n%s online help: <%s>\n");
  v9 = "http://www.gnu.org/software/coreutils/";
  v8 = "GNU coreutils";
  printf(v1, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  v12 = setlocale(5, 0);
  if ( v12 && strncmp(v12, "en_", 3u) )
  {
    v2 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
    v8 = s1;
    printf(v2, s1);
  }
  v3 = gettext("Full documentation at: <%s%s>\n");
  v9 = s1;
  v8 = "http://www.gnu.org/software/coreutils/";
  printf(v3, "http://www.gnu.org/software/coreutils/", s1);
  if ( v10 == s1 )
    v4 = " invocation";
  else
    v4 = &s;
  v5 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  v9 = v4;
  v8 = v10;
  return printf(v5, v10, v4);
}

//----- (0804A880) --------------------------------------------------------
void __cdecl __noreturn sub_804A880(int status)
{
  int v1; // ebx
  char *v2; // eax
  int v3; // ebx
  char *v4; // eax
  FILE *v5; // ebx
  char *v6; // eax
  FILE *v7; // ebx
  char *v8; // eax
  FILE *v9; // ebx
  char *v10; // eax
  char *v11; // eax

  if ( status )
  {
    v1 = dword_8056835;
    v2 = gettext("Try '%s --help' for more information.\n");
    fprintf(stderr, v2, v1);
  }
  else
  {
    v3 = dword_8056835;
    v4 = gettext("Usage: %s [OPTION]... [FILE]\nBase%d encode or decode FILE, or standard input, to standard output.\n");
    printf(v4, v3, 32);
    sub_804A656();
    sub_804A6BF();
    v5 = stdout;
    v6 = gettext(
           "  -d, --decode          decode data\n"
           "  -i, --ignore-garbage  when decoding, ignore non-alphabet characters\n"
           "  -w, --wrap=COLS       wrap encoded lines after COLS character (default 76).\n"
           "                          Use 0 to disable line wrapping\n"
           "\n");
    fputs_unlocked(v6, v5);
    v7 = stdout;
    v8 = gettext("      --help     display this help and exit\n");
    fputs_unlocked(v8, v7);
    v9 = stdout;
    v10 = gettext("      --version  output version information and exit\n");
    fputs_unlocked(v10, v9);
    v11 = gettext(
            "\n"
            "The data are encoded as described for the %s alphabet in RFC 4648.\n"
            "When decoding, the input may contain newlines in addition to the bytes of\n"
            "the formal %s alphabet.  Use --ignore-garbage to attempt to recover\n"
            "from any other non-alphabet bytes in the encoded stream.\n");
    printf(v11, "base32", "base32");
    sub_804A6EA("base32");
  }
  exit(status);
}
// 8048F50: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8056835: using guessed type int dword_8056835;

//----- (0804A97F) --------------------------------------------------------
size_t __cdecl sub_804A97F(void *ptr, size_t n, int a3, int a4, int a5, FILE *stream)
{
  size_t result; // eax
  char *v7; // ebx
  int *v8; // eax
  __int64 v9; // rcx
  size_t v10; // eax
  char *v11; // ebx
  int *v12; // eax
  size_t v13; // eax
  char *v14; // ebx
  int *v15; // eax
  __int64 v16; // [esp+18h] [ebp-20h]
  size_t v17; // [esp+20h] [ebp-18h]
  size_t v18; // [esp+24h] [ebp-14h]
  __int64 v19; // [esp+28h] [ebp-10h]

  v16 = __PAIR__(a4, a3);
  if ( !__PAIR__(a4, a3) )
  {
    result = fwrite_unlocked(ptr, 1u, n, stdout);
    if ( result >= n )
      return result;
    v7 = gettext("write error");
    v8 = __errno_location();
    error(1, *v8, v7);
  }
  v17 = 0;
  while ( 1 )
  {
    result = v17;
    if ( v17 >= n )
      break;
    v9 = *(unsigned int *)a5;
    v19 = v16 - v9;
    v10 = v16 - v9;
    if ( (unsigned __int64)(v16 - v9) >> 32 )
      v10 = -1;
    v18 = v10;
    if ( n - v17 <= v10 )
      v10 = n - v17;
    v18 = v10;
    if ( v10 )
    {
      v13 = fwrite_unlocked((char *)ptr + v17, 1u, v18, stdout);
      if ( v13 < v18 )
      {
        v14 = gettext("write error");
        v15 = __errno_location();
        error(1, *v15, v14);
      }
      *(_DWORD *)a5 += v18;
      v17 += v18;
    }
    else
    {
      if ( fputc_unlocked(10, stream) == -1 )
      {
        v11 = gettext("write error");
        v12 = __errno_location();
        error(1, *v12, v11);
      }
      *(_DWORD *)a5 = 0;
    }
  }
  return result;
}

//----- (0804AB35) --------------------------------------------------------
#error "804AB52: call analysis failed (funcsize=11)"

//----- (0804AB57) --------------------------------------------------------
#error "804AE3D: positive sp value has been found (funcsize=177)"

//----- (0804AE3E) --------------------------------------------------------
#error "804AEC3: call analysis failed (funcsize=33)"

//----- (0804AEC8) --------------------------------------------------------
#error "804B227: positive sp value has been found (funcsize=197)"

//----- (0804B22A) --------------------------------------------------------
void __cdecl __noreturn main(int argc, char **argv)
{
  int v2; // eax
  void *v3; // eax
  char *v4; // eax
  int v5; // ecx
  int (__cdecl *v6)(char *, char *, int, int, int, int, int, int, int, __int16, FILE *, char *, int, int, int); // eax
  int v7; // ebx
  char *v8; // eax
  char *v9; // [esp+0h] [ebp-44h]
  int v10; // [esp+Ch] [ebp-38h]
  int v11; // [esp+14h] [ebp-30h]
  char v12; // [esp+2Ah] [ebp-1Ah]
  char v13; // [esp+2Bh] [ebp-19h]
  int v14; // [esp+34h] [ebp-10h]
  unsigned __int64 v15; // [esp+38h] [ebp-Ch]

  v12 = 0;
  v13 = 0;
  v15 = 76LL;
  sub_804C822(*argv);
  setlocale(6, &s);
  bindtextdomain("coreutils", "/home/hwangdz/coreutils/coreutils-8.28/install_m32/share/locale");
  textdomain("coreutils");
  sub_8050ACC((int)sub_804C614);
  while ( 1 )
  {
    while ( 1 )
    {
      v14 = getopt_long(argc, argv, "diw:", &longopts, 0);
      if ( v14 == -1 )
      {
        v6 = (int (__cdecl *)(char *, char *, int, int, int, int, int, int, int, __int16, FILE *, char *, int, int, int))&loc_804B477;
        if ( argc - optind <= 1 )
          v6 = sub_804B4C8;
        dword_8056198 = (int)v6;
        sub_8050F97(v5, argc - optind);
        v9 = argv[optind];
        v7 = sub_804E723((int)v9);
        v8 = gettext("extra operand %s");
        v10 = v7;
        error(0, 0, v8, v7);
        sub_804A880(1);
      }
      v2 = v14;
      if ( v14 != 100 )
        break;
LABEL_11:
      v12 = 1;
    }
    if ( v14 <= 100 )
    {
      if ( v14 == -131 )
      {
        v11 = 0;
        sub_804EE93(stdout, "base32", "GNU coreutils", off_8056244, (unsigned int)"Simon Josefsson");
        exit(0);
      }
      v3 = &loc_804B2E9;
      if ( v14 == -130 )
        v3 = &loc_804B394;
      dword_80561E8 = (int)v3;
      sub_8050DB2();
      dword_80561E8 = (int)&loc_804B408;
      v2 = sub_8050DB2();
    }
    if ( v2 == 105 )
    {
      v13 = 1;
    }
    else
    {
      if ( v2 != 119 )
      {
        dword_805615C = (int)&loc_804B408;
        sub_80510E7(v9);
        goto LABEL_11;
      }
      v4 = gettext("invalid wrap size");
      v15 = sub_804F402(optarg, 0, 0, -1, -1, &s, (int)v4, 0);
    }
  }
}
// 804EE93: using guessed type _DWORD __cdecl sub_804EE93(_DWORD, _DWORD, _DWORD, _DWORD, char);
// 8050DB2: using guessed type int sub_8050DB2(void);
// 80510E7: using guessed type int __stdcall sub_80510E7(_DWORD);
// 805615C: using guessed type int dword_805615C;
// 8056198: using guessed type int dword_8056198;
// 80561E8: using guessed type int dword_80561E8;
// 8056244: using guessed type char *off_8056244;
// 80562E0: using guessed type int optind;

//----- (0804B4C8) --------------------------------------------------------
#error "804B68B: positive sp value has been found (funcsize=0)"

//----- (0804B68C) --------------------------------------------------------
int __cdecl sub_804B68C(unsigned __int8 a1)
{
  return a1;
}

//----- (0804B69E) --------------------------------------------------------
void __cdecl sub_804B69E(unsigned __int8 *a1, int a2, _BYTE *a3, int a4)
{
  _BYTE *v4; // ebx
  int v5; // edx
  int v6; // ecx
  void *v7; // eax
  int v8; // [esp+0h] [ebp-Ch]

  if ( a2 && a4 )
  {
    v4 = a3++;
    *v4 = byte_8051B20[(unsigned __int8)sub_804B68C(*a1) >> 3];
    --a4;
    v7 = &loc_804B6FA;
    if ( a4 )
      v7 = &loc_804B6FF;
    dword_805610C = (int)v7;
    sub_80512AB(v6, v5, v8);
  }
  if ( a4 )
    *a3 = 0;
}
// 805610C: using guessed type int dword_805610C;

//----- (0804BAFA) --------------------------------------------------------
char __cdecl sub_804BAFA(unsigned __int8 a1)
{
  return (unsigned __int8)~byte_8051A20[(unsigned __int8)sub_804B68C(a1)] >> 7;
}

//----- (0804BB23) --------------------------------------------------------
_DWORD *__cdecl sub_804BB23(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = 0;
  return result;
}

//----- (0804BB31) --------------------------------------------------------
#error "804BC82: call analysis failed (funcsize=110)"

//----- (0804BCDF) --------------------------------------------------------
#error "804BD46: call analysis failed (funcsize=44)"

//----- (0804C2D3) --------------------------------------------------------
bool __cdecl sub_804C2D3(int *a1, unsigned __int8 *a2, unsigned int a3, int a4, int *a5)
{
  void *v5; // eax
  int v6; // edx
  int v7; // ecx
  void *v8; // eax
  int v10; // [esp+0h] [ebp-38h]
  int v11; // [esp+4h] [ebp-34h]
  int *v12; // [esp+Ch] [ebp-2Ch]
  int v13; // [esp+14h] [ebp-24h]
  int v14; // [esp+18h] [ebp-20h]
  int v15; // [esp+1Ch] [ebp-1Ch]
  int v16; // [esp+20h] [ebp-18h]
  int v17; // [esp+24h] [ebp-14h]
  unsigned __int8 *v18; // [esp+28h] [ebp-10h]
  unsigned __int8 *v19; // [esp+2Ch] [ebp-Ch]

  v15 = *a5;
  HIBYTE(v14) = a1 != 0;
  BYTE2(v14) = 0;
  v16 = 0;
  if ( a1 != 0 )
  {
    v16 = *a1;
    BYTE2(v14) = a3 == 0;
  }
  while ( 1 )
  {
    v17 = v15;
    if ( !v16 && BYTE2(v14) != 1 )
    {
      while ( 1 )
      {
        v17 = v15;
        v12 = &v15;
        if ( (unsigned __int8)sub_804BCDF(a2, a3, &v13) ^ 1 )
          break;
        a2 += 8;
        a3 -= 8;
      }
    }
    v5 = &loc_804C3A9;
    if ( a3 )
      v5 = &loc_804C3B9;
    dword_8056120 = (int)v5;
    sub_805123D();
    if ( BYTE2(v14) != 1 )
      break;
    if ( a3 && *a2 == 10 )
    {
      v8 = &loc_804C3E9;
      if ( !HIBYTE(v14) )
        v8 = &loc_804C400;
      dword_8056198 = (int)v8;
      sub_8050F97(v7, v6);
      ++a2;
      --a3;
    }
    else
    {
      a4 += v15 - v17;
      v15 = v17;
      v19 = &a2[a3];
      if ( HIBYTE(v14) )
        v18 = (unsigned __int8 *)sub_804BB31(a1, &a2, v19, &a3);
      else
        v18 = a2;
      if ( !a3 || a3 <= 7 && BYTE2(v14) != 1 && HIBYTE(v14) )
      {
        a3 = 0;
        break;
      }
      v12 = &v15;
      if ( (unsigned __int8)sub_804BCDF(v18, a3, &a4) ^ 1 )
      {
        dword_8056184 = (int)&loc_804C4D9;
        sub_8051005(v10, v11);
      }
      a3 = v19 - a2;
    }
  }
  *a5 -= v15;
  return a3 == 0;
}
// 804BB31: using guessed type _DWORD __cdecl sub_804BB31(_DWORD, _DWORD, _DWORD, _DWORD);
// 8051005: using guessed type int __stdcall sub_8051005(_DWORD, _DWORD);
// 805123D: using guessed type int sub_805123D(void);
// 8056120: using guessed type int dword_8056120;
// 8056184: using guessed type int dword_8056184;
// 8056198: using guessed type int dword_8056198;

//----- (0804C614) --------------------------------------------------------
void __noreturn sub_804C614()
{
  sub_804FE45(stdout);
}

//----- (0804C73B) --------------------------------------------------------
int __cdecl sub_804C73B(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // [esp+20h] [ebp-28h]
  int v8; // [esp+24h] [ebp-24h]

  v7 = a4;
  v8 = a5;
  return posix_fadvise64(a1, a2, a3, a4, a5, a6);
}
// 8049070: using guessed type int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804C79C) --------------------------------------------------------
int *__usercall sub_804C79C@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>, FILE *stream, int a8)
{
  void *v8; // eax
  int *result; // eax
  int v10; // eax
  int v11; // [esp+22h] [ebp-Ah]
  int *v12; // [esp+28h] [ebp-4h]

  v12 = (int *)a5;
  __asm { pushfw }
  v11 = a6;
  v8 = &loc_804C7BE;
  if ( a6 < 10 )
    v8 = &loc_804C7D6;
  dword_80561FC = (int)v8;
  sub_8050D25(v11);
  if ( ((_BYTE)a6 - 1) * (_BYTE)a6 & 1 )
    abort();
  __asm { popfw }
  result = v12;
  v12 = &v11;
  if ( stream )
  {
    v10 = fileno(stream);
    result = (int *)sub_804C73B(v10, 0, 0, 0, 0, a8);
  }
  return result;
}
// 804C79C: could not find valid save-restore pair for ebx
// 804C79C: could not find valid save-restore pair for ebp
// 8050D25: using guessed type int __cdecl sub_8050D25(_DWORD);
// 80561FC: using guessed type int dword_80561FC;

//----- (0804C822) --------------------------------------------------------
char *__cdecl sub_804C822(char *s)
{
  char *v1; // eax
  bool v2; // zf
  void *v3; // eax
  char *result; // eax
  char *v5; // [esp+18h] [ebp-10h]
  char *s1; // [esp+1Ch] [ebp-Ch]

  if ( !s )
  {
    fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
    abort();
  }
  v5 = strrchr(s, 47);
  if ( v5 )
    v1 = v5 + 1;
  else
    v1 = s;
  s1 = v1;
  if ( v1 - s > 6 && !strncmp(v1 - 7, "/.libs/", 7u) )
  {
    v2 = strncmp(s1, "lt-", 3u) == 0;
    v3 = &loc_804C8F1;
    if ( !v2 )
      v3 = &loc_804C902;
    dword_80561E8 = (int)v3;
    sub_8050DB2();
    s = s1 + 3;
    program_invocation_short_name = (int)(s1 + 3);
  }
  dword_8056835 = (int)s;
  result = s;
  program_invocation_name = (int)s;
  return result;
}
// 8050DB2: using guessed type int sub_8050DB2(void);
// 80561E8: using guessed type int dword_80561E8;
// 80562C0: using guessed type int program_invocation_short_name;
// 80562D0: using guessed type int program_invocation_name;
// 8056835: using guessed type int dword_8056835;

//----- (0804C987) --------------------------------------------------------
int __cdecl sub_804C987(int a1, unsigned __int8 a2, char a3)
{
  unsigned __int8 v4; // [esp+0h] [ebp-18h]
  unsigned __int8 v5; // [esp+7h] [ebp-11h]
  int *v6; // [esp+8h] [ebp-10h]
  int v7; // [esp+Ch] [ebp-Ch]
  unsigned int v8; // [esp+10h] [ebp-8h]

  v4 = a2;
  v5 = a2;
  if ( a1 )
  {
    dword_80561FC = (int)&loc_804C9C0;
    sub_8050D25(*(_DWORD *)&v4);
  }
  v6 = &dword_805683D[(v5 >> 5) + 2];
  v7 = v5 & 0x1F;
  v8 = ((unsigned int)*v6 >> (v5 & 0x1F)) & 1;
  *v6 ^= (v8 ^ a3 & 1) << v7;
  return v8;
}
// 8050D25: using guessed type int __cdecl sub_8050D25(_DWORD);
// 80561FC: using guessed type int dword_80561FC;
// 805683D: using guessed type int dword_805683D[];

//----- (0804CA56) --------------------------------------------------------
signed int sub_804CA56()
{
  return 732;
}

//----- (0804CA61) --------------------------------------------------------
int *__cdecl sub_804CA61(int *a1, int a2, int a3)
{
  int *result; // eax

  if ( !a1 )
    a1 = dword_805683D;
  *a1 = 10;
  if ( !a2 || !a3 )
    abort();
  a1[10] = a2;
  result = a1;
  a1[11] = a3;
  return result;
}
// 805683D: using guessed type int dword_805683D[];

//----- (0804CAA2) --------------------------------------------------------
#error "804CB08: call analysis failed (funcsize=34)"

//----- (0804CB0D) --------------------------------------------------------
#error "804CB53: positive sp value has been found (funcsize=0)"

//----- (0804CB59) --------------------------------------------------------
char *__cdecl sub_804CB59(char *msgid)
{
  char *result; // eax
  unsigned __int8 *v2; // eax
  bool v3; // zf
  void *v4; // eax
  int v5; // [esp+0h] [ebp-28h]
  char *v6; // [esp+18h] [ebp-10h]

  v6 = gettext(msgid);
  if ( v6 != msgid )
    return v6;
  v2 = (unsigned __int8 *)sub_8050555();
  v3 = sub_804FDE0(v2, "UTF-8") == 0;
  v4 = &loc_804CBB5;
  if ( !v3 )
    v4 = &loc_804CBD0;
  dword_805615C = (int)v4;
  sub_80510E7(v5);
  if ( *msgid == 96 )
    result = (char *)&unk_8051C6E;
  else
    result = (char *)&unk_8051C72;
  return result;
}
// 80510E7: using guessed type int __stdcall sub_80510E7(_DWORD);
// 805615C: using guessed type int dword_805615C;

//----- (0804CC66) --------------------------------------------------------
int __cdecl sub_804CC66(int a1, unsigned int a2, char *a3, size_t a4, int a5, int a6, int a7, char *a8, char *a9)
{
  char *v9; // edx
  int v10; // ecx
  void *v11; // eax
  void *v12; // eax
  size_t v13; // ebx
  int v14; // edx
  void *v15; // eax
  void *v16; // eax
  bool v17; // al
  void *v18; // eax
  void *v19; // eax
  void *v20; // eax
  void *v21; // eax
  int v22; // ecx
  int v23; // edx
  void *v24; // eax
  void *v25; // eax
  bool v26; // al
  void *v27; // eax
  void *v28; // eax
  void *v29; // eax
  int (*v30)(); // eax
  int result; // eax
  int v32; // [esp+0h] [ebp-88h]
  int v33; // [esp+4h] [ebp-84h]
  int v34; // [esp+8h] [ebp-80h]
  int v35; // [esp+Ch] [ebp-7Ch]
  int v36; // [esp+10h] [ebp-78h]
  int v37; // [esp+14h] [ebp-74h]
  int v38; // [esp+18h] [ebp-70h]
  int v39; // [esp+1Ch] [ebp-6Ch]
  int v40; // [esp+20h] [ebp-68h]
  int v41; // [esp+24h] [ebp-64h]
  int v42; // [esp+28h] [ebp-60h]
  char *v43; // [esp+2Ch] [ebp-5Ch]
  char *v44; // [esp+30h] [ebp-58h]
  int v45; // [esp+34h] [ebp-54h]
  char *v46; // [esp+38h] [ebp-50h]
  char *v47; // [esp+3Ch] [ebp-4Ch]
  char v48; // [esp+40h] [ebp-48h]
  bool v49; // [esp+41h] [ebp-47h]
  char v50; // [esp+42h] [ebp-46h]
  char v51; // [esp+43h] [ebp-45h]
  char v52; // [esp+44h] [ebp-44h]
  unsigned __int8 v53; // [esp+45h] [ebp-43h]
  char v54; // [esp+46h] [ebp-42h]
  char v55; // [esp+47h] [ebp-41h]
  char v56; // [esp+48h] [ebp-40h]
  bool v57; // [esp+49h] [ebp-3Fh]
  bool v58; // [esp+4Ah] [ebp-3Eh]
  bool v59; // [esp+4Bh] [ebp-3Dh]
  char *v60; // [esp+50h] [ebp-38h]
  unsigned int v61; // [esp+54h] [ebp-34h]
  unsigned int v62; // [esp+58h] [ebp-30h]
  char *s; // [esp+5Ch] [ebp-2Ch]
  size_t n; // [esp+60h] [ebp-28h]
  unsigned int v65; // [esp+64h] [ebp-24h]
  unsigned int v66; // [esp+70h] [ebp-18h]
  unsigned int v67; // [esp+7Ch] [ebp-Ch]

  v47 = (char *)a1;
  v46 = a3;
  v45 = a7;
  v44 = a8;
  v43 = a9;
  v67 = __readgsdword(0x14u);
  v61 = 0;
  v62 = 0;
  s = 0;
  n = 0;
  v48 = 0;
  v59 = __ctype_get_mb_cur_max() == 1;
  v49 = (a6 & 2) != 0;
  v50 = 0;
  v51 = 0;
  v52 = 1;
LABEL_2:
  switch ( a5 )
  {
    case 0:
      v49 = 0;
      dword_8056170 = (int)&loc_804CE94;
      sub_8051071();
      goto LABEL_27;
    case 1:
      goto LABEL_18;
    case 2:
      goto LABEL_21;
    case 3:
      v48 = 1;
LABEL_18:
      v49 = 1;
      goto LABEL_19;
    case 4:
LABEL_19:
      if ( v49 != 1 )
        v48 = 1;
LABEL_21:
      a5 = 2;
      if ( v49 != 1 )
      {
        if ( v61 < a2 )
        {
          v9 = v47;
          v47[v61] = 39;
        }
        ++v61;
      }
      s = "'";
      n = 1;
      break;
    case 5:
      goto LABEL_4;
    case 6:
      a5 = 5;
      v49 = 1;
LABEL_4:
      if ( v49 != 1 )
      {
        if ( v61 < a2 )
        {
          v9 = v47;
          v47[v61] = 34;
        }
        ++v61;
      }
      v48 = 1;
      s = (char *)&unk_8051C85;
      n = 1;
      break;
    case 7:
      v48 = 1;
      v49 = 0;
      break;
    case 8:
    case 9:
    case 10:
      v11 = &loc_804CD88;
      if ( a5 == 10 )
        v11 = &loc_804CDB4;
      dword_8056148 = (int)v11;
      sub_805115B();
      v33 = a5;
      v44 = sub_804CB59("`");
      v33 = a5;
      v43 = sub_804CB59("'");
      if ( v49 != 1 )
      {
        s = v44;
        v12 = &loc_804CE0A;
        if ( *v44 )
          v12 = &loc_804CDC7;
        dword_8056148 = (int)v12;
        sub_805115B();
      }
      v48 = 1;
      s = v43;
      n = strlen(v43);
      break;
    default:
LABEL_27:
      abort();
      return result;
  }
  v60 = 0;
  dword_8056198 = (int)&loc_804D95A;
  sub_8050F97(v10, v9);
  while ( 2 )
  {
    v55 = 0;
    v56 = 0;
    v57 = 0;
    if ( v48 && a5 != 2 && n )
    {
      v13 = (size_t)&v60[n];
      if ( a4 == -1 && n > 1 )
      {
        a4 = strlen(v46);
        dword_8056134 = (int)&loc_804CF1C;
        sub_80511CF(v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46);
      }
      if ( v13 <= a4 && !memcmp(&v46[(_DWORD)v60], s, n) )
      {
        if ( v49 )
        {
          dword_805610C = (int)&loc_804DAFD;
          sub_80512AB(v10, v14, v32);
        }
        v55 = 1;
      }
    }
    v9 = v46;
    v53 = v60[(_DWORD)v46];
    switch ( v53 )
    {
      case 0u:
        v15 = &loc_804CFA6;
        if ( !v48 )
          v15 = &loc_804D08F;
        dword_8056184 = (int)v15;
        sub_8051005(v32, v33);
        if ( v49 )
          goto LABEL_222;
        v56 = 1;
        if ( a5 == 2 && v50 != 1 )
        {
          if ( v61 < a2 )
          {
            v9 = v47;
            v47[v61] = 39;
          }
          if ( ++v61 < a2 )
          {
            v9 = v47;
            v47[v61] = 36;
          }
          if ( ++v61 < a2 )
          {
            v9 = v47;
            v47[v61] = 39;
          }
          ++v61;
          v50 = 1;
        }
        if ( v61 < a2 )
        {
          v9 = v47;
          v47[v61] = 92;
        }
        ++v61;
        if ( a5 != 2 && (unsigned int)(v60 + 1) < a4 )
        {
          v9 = v60 + 1;
          if ( v46[(_DWORD)(v60 + 1)] > 47 )
          {
            v9 = v60 + 1;
            if ( v46[(_DWORD)(v60 + 1)] <= 57 )
            {
              if ( v61 < a2 )
              {
                v9 = v47;
                v47[v61] = 48;
              }
              if ( ++v61 < a2 )
              {
                v9 = v47;
                v47[v61] = 48;
              }
              ++v61;
            }
          }
        }
        v53 = 48;
        dword_8056198 = (int)&loc_804D786;
        sub_8050F97(v10, v9);
        goto LABEL_65;
      case 7u:
        v54 = 97;
        goto LABEL_103;
      case 8u:
        v54 = 98;
        goto LABEL_103;
      case 9u:
        goto LABEL_91;
      case 0xAu:
        v54 = 110;
        goto LABEL_100;
      case 0xBu:
        v54 = 118;
        goto LABEL_103;
      case 0xCu:
        v54 = 102;
        goto LABEL_103;
      case 0xDu:
        v54 = 114;
        dword_8056120 = (int)&loc_804D285;
        sub_805123D();
LABEL_91:
        v54 = 116;
        goto LABEL_100;
      case 0x20u:
        goto LABEL_111;
      case 0x21u:
      case 0x22u:
      case 0x24u:
      case 0x26u:
      case 0x28u:
      case 0x29u:
      case 0x2Au:
      case 0x3Bu:
      case 0x3Cu:
      case 0x3Du:
      case 0x3Eu:
      case 0x5Bu:
      case 0x5Eu:
      case 0x60u:
      case 0x7Cu:
        goto LABEL_112;
      case 0x23u:
      case 0x7Eu:
        goto LABEL_110;
      case 0x25u:
      case 0x2Bu:
      case 0x2Cu:
      case 0x2Du:
      case 0x2Eu:
      case 0x2Fu:
      case 0x30u:
      case 0x31u:
      case 0x32u:
      case 0x33u:
      case 0x34u:
      case 0x35u:
      case 0x36u:
      case 0x37u:
      case 0x38u:
      case 0x39u:
      case 0x3Au:
      case 0x41u:
      case 0x42u:
      case 0x43u:
      case 0x44u:
      case 0x45u:
      case 0x46u:
      case 0x47u:
      case 0x48u:
      case 0x49u:
      case 0x4Au:
      case 0x4Bu:
      case 0x4Cu:
      case 0x4Du:
      case 0x4Eu:
      case 0x4Fu:
      case 0x50u:
      case 0x51u:
      case 0x52u:
      case 0x53u:
      case 0x54u:
      case 0x55u:
      case 0x56u:
      case 0x57u:
      case 0x58u:
      case 0x59u:
      case 0x5Au:
      case 0x5Du:
      case 0x5Fu:
      case 0x61u:
      case 0x62u:
      case 0x63u:
      case 0x64u:
      case 0x65u:
      case 0x66u:
      case 0x67u:
      case 0x68u:
      case 0x69u:
      case 0x6Au:
      case 0x6Bu:
      case 0x6Cu:
      case 0x6Du:
      case 0x6Eu:
      case 0x6Fu:
      case 0x70u:
      case 0x71u:
      case 0x72u:
      case 0x73u:
      case 0x74u:
      case 0x75u:
      case 0x76u:
      case 0x77u:
      case 0x78u:
      case 0x79u:
      case 0x7Au:
        v57 = 1;
        goto LABEL_172;
      case 0x27u:
        v51 = 1;
        v57 = 1;
        if ( a5 != 2 )
          goto LABEL_172;
        if ( v49 )
          goto LABEL_222;
        if ( a2 && !v62 )
        {
          v62 = a2;
          a2 = 0;
        }
        if ( v61 < a2 )
          v47[v61] = 39;
        if ( ++v61 < a2 )
          v47[v61] = 92;
        if ( ++v61 < a2 )
          v47[v61] = 39;
        ++v61;
        v50 = 0;
        goto LABEL_172;
      case 0x3Fu:
LABEL_65:
        if ( a5 == 2 )
        {
          if ( v49 )
            goto LABEL_222;
        }
        else if ( a5 == 5 && a6 & 4 && (unsigned int)(v60 + 2) < a4 && v46[(_DWORD)(v60 + 1)] == 63 )
        {
          switch ( v46[(_DWORD)(v60 + 2)] )
          {
            case 33:
            case 39:
            case 40:
            case 41:
            case 45:
            case 47:
            case 60:
            case 61:
            case 62:
              if ( v49 )
              {
                dword_80561FC = (int)&loc_804DAFD;
                sub_8050D25(v32);
              }
              v53 = v46[(_DWORD)(v60 + 2)];
              v60 += 2;
              if ( v61 < a2 )
                v47[v61] = 63;
              if ( ++v61 < a2 )
                v47[v61] = 34;
              if ( ++v61 < a2 )
                v47[v61] = 34;
              if ( ++v61 < a2 )
                v47[v61] = 63;
              ++v61;
              break;
            default:
              goto LABEL_172;
          }
        }
        goto LABEL_172;
      case 0x5Cu:
        v54 = v53;
        if ( a5 == 2 )
        {
          v16 = &loc_804D264;
          if ( !v49 )
            v16 = &loc_804D269;
          dword_8056184 = (int)v16;
          sub_8051005(v32, v33);
          goto LABEL_222;
        }
        if ( !v48 || !v49 || !n )
        {
LABEL_100:
          if ( a5 == 2 && v49 )
          {
            dword_80561C0 = (int)&loc_804DAFD;
            sub_8050E9C();
          }
LABEL_103:
          if ( v48 )
          {
            v53 = v54;
          }
          else
          {
LABEL_172:
            if ( v48 == 1 )
            {
              v21 = &loc_804D7B0;
              if ( a5 != 2 )
                v21 = &loc_804D7BB;
              dword_805615C = (int)v21;
              sub_80510E7(v32);
            }
            if ( v49 == 1 && v45 )
            {
              v22 = v53 & 0x1F;
              v23 = *(_DWORD *)(4 * (v53 >> 5) + v45) >> v22;
              v24 = &loc_804D816;
              if ( v23 & 1 )
                v24 = &loc_804D838;
              dword_8056198 = (int)v24;
              sub_8050F97(v22, v23);
            }
            if ( v55 != 1 )
            {
              dword_8056134 = (int)&loc_804D8EA;
              sub_80511CF(v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46);
            }
          }
          v25 = &loc_804D857;
          if ( !v49 )
            v25 = &loc_804D85C;
          dword_8056148 = (int)v25;
          sub_805115B();
          goto LABEL_222;
        }
LABEL_186:
        if ( v50 && v56 != 1 )
        {
          if ( v61 < a2 )
          {
            v9 = v47;
            v47[v61] = 39;
          }
          if ( ++v61 < a2 )
          {
            v9 = v47;
            v47[v61] = 39;
          }
          ++v61;
          v50 = 0;
        }
        if ( v61 < a2 )
        {
          v9 = &v47[v61];
          v47[v61] = v53;
        }
        ++v61;
        if ( v57 != 1 )
          v52 = 0;
        ++v60;
        if ( a4 == -1 )
        {
          v9 = v46;
          v26 = v60[(_DWORD)v46] != 0;
        }
        else
        {
          v26 = v60 != (char *)a4;
        }
        if ( v26 )
          continue;
        if ( v61 )
          goto LABEL_231;
        v27 = &loc_804D9A8;
        if ( a5 != 2 )
          v27 = &loc_804D9B3;
        dword_8056170 = (int)v27;
        sub_8051071();
        if ( !v49 )
        {
LABEL_231:
          if ( a5 == 2 && v49 != 1 && v51 )
          {
            v28 = &loc_804D9F5;
            if ( !v52 )
              v28 = &loc_804DA60;
            dword_80561C0 = (int)v28;
            sub_8050E9C();
            sub_804CC66((int)v47, v62, v46, a4, 5, a6, v45, v44, v43);
            dword_8056120 = (int)&loc_804DB82;
            sub_805123D();
            if ( !a2 )
            {
              if ( v62 )
              {
                a2 = v62;
                v61 = 0;
                goto LABEL_2;
              }
            }
          }
          if ( s && v49 != 1 )
          {
            dword_8056198 = (int)&loc_804DAC6;
            sub_8050F97(v10, v9);
            do
            {
              if ( v61 < a2 )
                v47[v61] = *s;
              ++v61;
              ++s;
            }
            while ( *s );
          }
          if ( v61 < a2 )
            v47[v61] = 0;
          dword_805615C = (int)&loc_804DB82;
          sub_80510E7(v32);
        }
LABEL_222:
        v29 = &loc_804DB1C;
        if ( a5 != 2 )
          v29 = &loc_804DB29;
        dword_8056198 = (int)v29;
        sub_8050F97(v10, v9);
        if ( v48 )
          a5 = 4;
        sub_804CC66((int)v47, a2, v46, a4, a5, a6 & 0xFFFFFFFD, 0, v44, v43);
        v30 = (int (*)())&loc_804DBA7;
        if ( __readgsdword(0x14u) == v67 )
          v30 = sub_804DBAC;
        dword_8056148 = (int)v30;
        return sub_805115B();
      case 0x7Bu:
      case 0x7Du:
        if ( a4 == -1 )
          v17 = v46[1] != 0;
        else
          v17 = a4 != 1;
        if ( v17 )
          goto LABEL_172;
LABEL_110:
        if ( v60 )
          goto LABEL_172;
LABEL_111:
        v57 = 1;
LABEL_112:
        if ( a5 != 2 )
          goto LABEL_172;
        v18 = &loc_804D319;
        if ( !v49 )
          v18 = &loc_804D31E;
        dword_80561E8 = (int)v18;
        sub_8050DB2();
        goto LABEL_222;
      default:
        v19 = &loc_804D3D0;
        if ( !v59 )
          v19 = &loc_804D40E;
        dword_805610C = (int)v19;
        sub_80512AB(v10, v46, v32);
        v65 = 1;
        v58 = ((*__ctype_b_loc())[v53] & 0x4000) != 0;
        v57 = v58;
        if ( v65 <= 1 )
        {
          v20 = &loc_804D5DC;
          if ( !v48 )
            v20 = &loc_804D786;
          dword_80561D4 = (int)v20;
          sub_8050E22();
          if ( v58 == 1 )
            goto LABEL_172;
        }
        v9 = v60;
        v66 = (unsigned int)&v60[v65];
        while ( 2 )
        {
          if ( v48 && v58 != 1 )
          {
            if ( v49 )
              goto LABEL_222;
            v56 = 1;
            if ( a5 == 2 && v50 != 1 )
            {
              if ( v61 < a2 )
              {
                v9 = v47;
                v47[v61] = 39;
              }
              if ( ++v61 < a2 )
              {
                v9 = v47;
                v47[v61] = 36;
              }
              if ( ++v61 < a2 )
              {
                v9 = v47;
                v47[v61] = 39;
              }
              ++v61;
              v50 = 1;
            }
            if ( v61 < a2 )
            {
              v9 = v47;
              v47[v61] = 92;
            }
            if ( ++v61 < a2 )
            {
              v9 = &v47[v61];
              v47[v61] = (v53 >> 6) + 48;
            }
            if ( ++v61 < a2 )
            {
              v9 = &v47[v61];
              v47[v61] = ((v53 >> 3) & 7) + 48;
            }
            ++v61;
            v53 = (v53 & 7) + 48;
          }
          else if ( v55 )
          {
            if ( v61 < a2 )
            {
              v9 = v47;
              v47[v61] = 92;
            }
            ++v61;
            v55 = 0;
          }
          if ( (unsigned int)(v60 + 1) < v66 )
          {
            if ( v50 && v56 != 1 )
            {
              if ( v61 < a2 )
                v47[v61] = 39;
              if ( ++v61 < a2 )
                v47[v61] = 39;
              ++v61;
              v50 = 0;
            }
            if ( v61 < a2 )
              v47[v61] = v53;
            ++v61;
            ++v60;
            v9 = v46;
            v53 = v60[(_DWORD)v46];
            continue;
          }
          goto LABEL_186;
        }
    }
  }
}
// 804DBAC: using guessed type int sub_804DBAC();
// 8050D25: using guessed type int __cdecl sub_8050D25(_DWORD);
// 8050DB2: using guessed type int sub_8050DB2(void);
// 8050E22: using guessed type int sub_8050E22(void);
// 8050E9C: using guessed type int sub_8050E9C(void);
// 8051005: using guessed type int __stdcall sub_8051005(_DWORD, _DWORD);
// 8051071: using guessed type int sub_8051071(void);
// 80510E7: using guessed type int __stdcall sub_80510E7(_DWORD);
// 805115B: using guessed type int sub_805115B(void);
// 80511CF: using guessed type int __stdcall sub_80511CF(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 805123D: using guessed type int sub_805123D(void);
// 805610C: using guessed type int dword_805610C;
// 8056120: using guessed type int dword_8056120;
// 8056134: using guessed type int dword_8056134;
// 8056148: using guessed type int dword_8056148;
// 805615C: using guessed type int dword_805615C;
// 8056170: using guessed type int dword_8056170;
// 8056184: using guessed type int dword_8056184;
// 8056198: using guessed type int dword_8056198;
// 80561C0: using guessed type int dword_80561C0;
// 80561D4: using guessed type int dword_80561D4;
// 80561E8: using guessed type int dword_80561E8;
// 80561FC: using guessed type int dword_80561FC;

//----- (0804DBAC) --------------------------------------------------------
#error "804DBAF: positive sp value has been found (funcsize=0)"

//----- (0804DC9E) --------------------------------------------------------
void *__usercall sub_804DC9E@<eax>(int a1@<edx>, int a2@<ecx>, char *a3, size_t a4, _DWORD *a5, int a6)
{
  int v6; // ST40_4
  int v7; // ST44_4
  int v9; // [esp+0h] [ebp-58h]
  int size; // [esp+48h] [ebp-10h]
  void *v11; // [esp+4Ch] [ebp-Ch]

  if ( a6 )
  {
    dword_805610C = (int)&loc_804DCCA;
    sub_80512AB(a2, a1, v9);
  }
  v6 = *__errno_location();
  v7 = dword_805683D[1] | (a5 == 0);
  size = sub_804CC66(
           0,
           0,
           a3,
           a4,
           dword_805683D[0],
           v7,
           (int)&dword_805683D[2],
           (char *)dword_805683D[10],
           (char *)dword_805683D[11])
       + 1;
  v11 = sub_804F06B((signed int)&dword_805683D[2], size);
  sub_804CC66(
    (int)v11,
    size,
    a3,
    a4,
    dword_805683D[0],
    v7,
    (int)&dword_805683D[2],
    (char *)dword_805683D[10],
    (char *)dword_805683D[11]);
  *__errno_location() = v6;
  if ( a5 )
    *a5 = size - 1;
  return v11;
}
// 805610C: using guessed type int dword_805610C;
// 805683D: using guessed type int dword_805683D[];

//----- (0804DECB) --------------------------------------------------------
#error "804E039: call analysis failed (funcsize=105)"

//----- (0804E03E) --------------------------------------------------------
#error "804E174: positive sp value has been found (funcsize=87)"

//----- (0804E177) --------------------------------------------------------
int __cdecl sub_804E177(int a1, int a2)
{
  return sub_804DECB(a1, a2, -1, dword_805683D);
}
// 804DECB: using guessed type _DWORD __cdecl sub_804DECB(_DWORD, _DWORD, _DWORD, _DWORD);
// 805683D: using guessed type int dword_805683D[];

//----- (0804E1A1) --------------------------------------------------------
int __usercall sub_804E1A1@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>, __int16 *a7@<ebp>, int a8, int a9, int a10)
{
  __int16 v11; // [esp+12h] [ebp-Ah]
  __int16 *v12; // [esp+18h] [ebp-4h]

  v12 = (__int16 *)a5;
  __asm { pushfw }
  if ( a6 >= 10 )
  {
    a7 = &v11;
    if ( ((_BYTE)a6 - 1) * (_BYTE)a6 & 1 )
      abort();
  }
  __asm { popfw }
  v12 = a7;
  return sub_804DECB(a8, a9, a10, dword_805683D);
}
// 804E1A1: could not find valid save-restore pair for ebp
// 804DECB: using guessed type _DWORD __cdecl sub_804DECB(_DWORD, _DWORD, _DWORD, _DWORD);
// 805683D: using guessed type int dword_805683D[];

//----- (0804E23C) --------------------------------------------------------
int __cdecl sub_804E23C(int a1, int a2, int a3)
{
  char v4; // [esp+10h] [ebp-38h]

  sub_804CAA2(&v4, a2);
  return sub_804DECB(a1, a3, -1, &v4);
}
// 804CAA2: using guessed type int __cdecl sub_804CAA2(_DWORD, _DWORD);
// 804DECB: using guessed type _DWORD __cdecl sub_804DECB(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804E27A) --------------------------------------------------------
int __cdecl sub_804E27A(int a1, int a2, int a3, int a4)
{
  char v5; // [esp+10h] [ebp-38h]

  sub_804CAA2(&v5, a2);
  return sub_804DECB(a1, a3, a4, &v5);
}
// 804CAA2: using guessed type int __cdecl sub_804CAA2(_DWORD, _DWORD);
// 804DECB: using guessed type _DWORD __cdecl sub_804DECB(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804E331) --------------------------------------------------------
#error "804E3A1: call analysis failed (funcsize=33)"

//----- (0804E3A6) --------------------------------------------------------
#error "804E3FF: positive sp value has been found (funcsize=0)"

//----- (0804E400) --------------------------------------------------------
int __cdecl sub_804E400(int a1, char a2)
{
  return sub_804E331(a1, -1, a2);
}
// 804E331: using guessed type _DWORD __cdecl sub_804E331(_DWORD, _DWORD, _DWORD);

//----- (0804E439) --------------------------------------------------------
int __cdecl sub_804E439(int a1)
{
  return sub_804E400(a1, 58);
}

//----- (0804E476) --------------------------------------------------------
int __cdecl sub_804E476(int a1, int a2, int a3)
{
  int v4; // [esp-4h] [ebp-7Ch]
  int v5; // [esp+10h] [ebp-68h]
  int v6; // [esp+14h] [ebp-64h]
  int v7; // [esp+18h] [ebp-60h]
  int v8; // [esp+1Ch] [ebp-5Ch]
  int v9; // [esp+20h] [ebp-58h]
  int v10; // [esp+24h] [ebp-54h]
  int v11; // [esp+28h] [ebp-50h]
  int v12; // [esp+2Ch] [ebp-4Ch]
  int v13; // [esp+30h] [ebp-48h]
  int v14; // [esp+34h] [ebp-44h]
  int v15; // [esp+38h] [ebp-40h]
  int v16; // [esp+3Ch] [ebp-3Ch]
  int v17; // [esp+40h] [ebp-38h]
  int v18; // [esp+44h] [ebp-34h]
  int v19; // [esp+48h] [ebp-30h]
  int v20; // [esp+4Ch] [ebp-2Ch]
  int v21; // [esp+50h] [ebp-28h]
  int v22; // [esp+54h] [ebp-24h]
  int v23; // [esp+58h] [ebp-20h]
  int v24; // [esp+5Ch] [ebp-1Ch]
  int v25; // [esp+60h] [ebp-18h]
  int v26; // [esp+64h] [ebp-14h]
  int v27; // [esp+68h] [ebp-10h]
  int v28; // [esp+6Ch] [ebp-Ch]

  sub_804CAA2(&v5, a2);
  v17 = v5;
  v18 = v6;
  v19 = v7;
  v20 = v8;
  v21 = v9;
  v22 = v10;
  v23 = v11;
  v24 = v12;
  v25 = v13;
  v26 = v14;
  v27 = v15;
  v28 = v16;
  sub_804C987((int)(&v4 - 14), 0x3Au, 1);
  return sub_804DECB(a1, a3, -1, &v17);
}
// 804CAA2: using guessed type int __cdecl sub_804CAA2(_DWORD, _DWORD);
// 804DECB: using guessed type _DWORD __cdecl sub_804DECB(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804E527) --------------------------------------------------------
int __cdecl sub_804E527(int a1, int a2, int a3, int a4)
{
  return sub_804E567(a1, a2, a3, a4, -1);
}

//----- (0804E567) --------------------------------------------------------
int __cdecl sub_804E567(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [esp+0h] [ebp-48h]
  int v7; // [esp+10h] [ebp-38h]
  int v8; // [esp+14h] [ebp-34h]
  int v9; // [esp+18h] [ebp-30h]
  int v10; // [esp+1Ch] [ebp-2Ch]
  int v11; // [esp+20h] [ebp-28h]
  int v12; // [esp+24h] [ebp-24h]
  int v13; // [esp+28h] [ebp-20h]
  int v14; // [esp+2Ch] [ebp-1Ch]
  int v15; // [esp+30h] [ebp-18h]
  int v16; // [esp+34h] [ebp-14h]
  int v17; // [esp+38h] [ebp-10h]
  int v18; // [esp+3Ch] [ebp-Ch]

  v7 = dword_805683D[0];
  v8 = dword_8056841;
  v9 = dword_8056845;
  v10 = dword_8056849;
  v11 = dword_805684D;
  v12 = dword_8056851;
  v13 = dword_8056855;
  v14 = dword_8056859;
  v15 = dword_805685D;
  v16 = dword_8056861;
  v17 = dword_8056865;
  v18 = dword_8056869;
  sub_804CA61(&v6 - 14, a2, a3);
  return sub_804DECB(a1, a4, a5, &v7);
}
// 804DECB: using guessed type _DWORD __cdecl sub_804DECB(_DWORD, _DWORD, _DWORD, _DWORD);
// 805683D: using guessed type int dword_805683D[];
// 8056841: using guessed type int dword_8056841;
// 8056845: using guessed type int dword_8056845;
// 8056849: using guessed type int dword_8056849;
// 805684D: using guessed type int dword_805684D;
// 8056851: using guessed type int dword_8056851;
// 8056855: using guessed type int dword_8056855;
// 8056859: using guessed type int dword_8056859;
// 805685D: using guessed type int dword_805685D;
// 8056861: using guessed type int dword_8056861;
// 8056865: using guessed type int dword_8056865;
// 8056869: using guessed type int dword_8056869;

//----- (0804E6A6) --------------------------------------------------------
int __cdecl sub_804E6A6(int a1, int a2, int a3)
{
  return sub_804DECB(a1, a2, a3, &unk_805627C);
}
// 804DECB: using guessed type _DWORD __cdecl sub_804DECB(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804E701) --------------------------------------------------------
int __cdecl sub_804E701(int a1, int a2)
{
  return sub_804E6A6(a1, a2, -1);
}

//----- (0804E723) --------------------------------------------------------
int __cdecl sub_804E723(int a1)
{
  int v6; // [esp-4h] [ebp-1Ch]

  v6 = sub_804E701(0, a1);
  __asm { pushfw }
  if ( sub_804CA56() != 732 )
    sub_804CA60();
  __asm { popfw }
  return v6;
}
// 804CA60: using guessed type int sub_804CA60(void);

//----- (0804E75D) --------------------------------------------------------
#error "804ED43: call analysis failed (funcsize=395)"

//----- (0804EE1D) --------------------------------------------------------
int __cdecl sub_804EE1D(FILE *stream, int a2, int a3, int a4, int a5)
{
  int *v5; // eax
  unsigned int i; // [esp+24h] [ebp-34h]
  int v8[12]; // [esp+28h] [ebp-30h]

  for ( i = 0; i <= 9; ++i )
  {
    v5 = (int *)a5;
    a5 += 4;
    v8[i] = *v5;
    if ( !v8[i] )
      break;
  }
  return sub_804E75D(stream, a2, a3, a4, (int)v8, i);
}
// 804EE1D: using guessed type int var_30[12];

//----- (0804EE93) --------------------------------------------------------
#error "804EED3: call analysis failed (funcsize=22)"

//----- (0804EED8) --------------------------------------------------------
#error "804EEEC: positive sp value has been found (funcsize=0)"

//----- (0804EFBB) --------------------------------------------------------
void *__usercall sub_804EFBB@<eax>(signed int a1@<ebx>, void *ptr, int a3, int a4)
{
  void *v4; // eax
  int v6; // [esp+0h] [ebp-28h]
  int v7; // [esp+4h] [ebp-24h]
  unsigned int v8; // [esp+1Ch] [ebp-Ch]
  unsigned int v9; // [esp+1Ch] [ebp-Ch]

  v8 = *(_DWORD *)a3;
  if ( ptr )
  {
    if ( 0x55555554u / a4 <= v8 )
      sub_804F1E7(a1);
    v9 = (v8 >> 1) + v8 + 1;
  }
  else
  {
    v4 = &loc_804EFEE;
    if ( v8 )
      v4 = &loc_804F00B;
    dword_8056184 = (int)v4;
    sub_8051005(v6, v7);
    v9 = (0x40u / a4 == 0) + 0x40u / a4;
    if ( 0x7FFFFFFFu / a4 < v9 )
      sub_804F1E7(a1);
  }
  *(_DWORD *)a3 = v9;
  return sub_804F0A8(a1, ptr, a4 * v9);
}
// 8051005: using guessed type int __stdcall sub_8051005(_DWORD, _DWORD);
// 8056184: using guessed type int dword_8056184;

//----- (0804F06B) --------------------------------------------------------
void *__usercall sub_804F06B@<eax>(signed int a1@<ebx>, size_t size)
{
  return sub_804F07E(a1, size);
}

//----- (0804F07E) --------------------------------------------------------
void *__usercall sub_804F07E@<eax>(signed int a1@<ebx>, size_t size)
{
  void *v3; // [esp+1Ch] [ebp-Ch]

  v3 = malloc(size);
  if ( !v3 && size )
    sub_804F1E7(a1);
  return v3;
}

//----- (0804F0A8) --------------------------------------------------------
void *__usercall sub_804F0A8@<eax>(signed int a1@<ebx>, void *ptr, size_t size)
{
  void *result; // eax
  void *v4; // eax
  bool v5; // zf
  void *v6; // eax
  void *ptra; // [esp+20h] [ebp+8h]

  if ( size || !ptr )
  {
    v4 = realloc(ptr, size);
    ptra = v4;
    v5 = v4 == 0;
    v6 = &loc_804F100;
    if ( !v5 )
      v6 = &loc_804F10B;
    dword_80561E8 = (int)v6;
    sub_8050DB2();
    if ( size )
      sub_804F1E7(a1);
    result = ptra;
  }
  else
  {
    free(ptr);
    result = 0;
  }
  return result;
}
// 8050DB2: using guessed type int sub_8050DB2(void);
// 80561E8: using guessed type int dword_80561E8;

//----- (0804F199) --------------------------------------------------------
void *__usercall sub_804F199@<eax>(signed int a1@<ebx>, void *src, size_t n)
{
  void *v3; // eax

  v3 = sub_804F07E(a1, n);
  return memcpy(v3, src, n);
}

//----- (0804F1E7) --------------------------------------------------------
void __usercall __noreturn sub_804F1E7(signed int a1@<ebx>)
{
  signed int v5; // [esp-Ah] [ebp-22h]
  char *v6; // [esp-4h] [ebp-1Ch]
  char *v7; // [esp+Ch] [ebp-Ch]

  v6 = gettext("memory exhausted");
  __asm { pushfw }
  v5 = a1;
  if ( a1 >= 10 && ((_BYTE)a1 - 1) * (_BYTE)a1 & 1 )
    abort();
  __asm { popfw }
  v7 = v6;
  error(status, 0, "%s", v6);
  abort();
}

//----- (0804F245) --------------------------------------------------------
void sub_804F245()
{
  ;
}

//----- (0804F24A) --------------------------------------------------------
void __cdecl sub_804F24A(int a1)
{
  if ( sub_804FD75(a1) < 0 )
    sub_804F245();
}

//----- (0804F26D) --------------------------------------------------------
unsigned __int64 __cdecl sub_804F26D(char *nptr, int base, int a3, int a4, int a5, int a6, char *s, int a8, int a9)
{
  int v9; // ebx
  bool v10; // zf
  void *v11; // eax
  int v12; // edx
  int v14; // [esp+0h] [ebp-48h]
  int v15; // [esp+4h] [ebp-44h]
  int v16; // [esp+8h] [ebp-40h]
  int v17; // [esp+Ch] [ebp-3Ch]
  int v18; // [esp+10h] [ebp-38h]
  int v19; // [esp+14h] [ebp-34h]
  int v20; // [esp+18h] [ebp-30h]
  int v21; // [esp+1Ch] [ebp-2Ch]
  unsigned __int64 v22; // [esp+20h] [ebp-28h]
  unsigned __int64 v23; // [esp+28h] [ebp-20h]
  int v24; // [esp+30h] [ebp-18h]
  int v25; // [esp+34h] [ebp-14h]
  unsigned __int64 v26; // [esp+38h] [ebp-10h]

  v23 = __PAIR__(a4, a3);
  v22 = __PAIR__(a6, a5);
  v25 = sub_804F558(nptr, 0, base, (int)&v26, s);
  if ( !v25 )
  {
    if ( v26 >= v23 && v22 >= v26 )
      goto LABEL_11;
    v25 = 1;
    if ( v26 > 0x3FFFFFFF )
    {
      *__errno_location() = 75;
      goto LABEL_11;
    }
    *__errno_location() = 34;
    dword_8056134 = (int)&loc_804F368;
    sub_80511CF(v14, v15, v16, v17, v18, v19, v20, v21, v22, HIDWORD(v22), v23, HIDWORD(v23), v24, v25, v26);
  }
  if ( v25 == 1 )
  {
    *__errno_location() = 75;
  }
  else if ( v25 == 3 )
  {
    *__errno_location() = 0;
  }
LABEL_11:
  if ( v25 )
  {
    v9 = sub_804E723((int)nptr);
    v10 = *__errno_location() == 22;
    v11 = &loc_804F3A4;
    if ( v10 )
      v11 = &loc_804F3AD;
    dword_80561FC = (int)v11;
    sub_8050D25(v14);
    v12 = *__errno_location();
    if ( a9 )
    {
      dword_80561FC = (int)&loc_804F3D7;
      sub_8050D25(v14);
    }
    v18 = v9;
    v17 = a8;
    error(1, v12, "%s: %s", a8, v9);
  }
  return v26;
}
// 8050D25: using guessed type int __cdecl sub_8050D25(_DWORD);
// 80511CF: using guessed type int __stdcall sub_80511CF(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8056134: using guessed type int dword_8056134;
// 80561FC: using guessed type int dword_80561FC;

//----- (0804F402) --------------------------------------------------------
unsigned __int64 __cdecl sub_804F402(char *nptr, int a2, int a3, int a4, int a5, char *s, int a7, int a8)
{
  return sub_804F26D(nptr, 10, a2, a3, a4, a5, s, a7, a8);
}

//----- (0804F476) --------------------------------------------------------
signed int __cdecl sub_804F476(unsigned int *a1, int a2)
{
  unsigned __int64 v2; // rcx
  int v3; // edx
  signed int result; // eax
  int v5; // esi
  unsigned __int64 v6; // rax
  __int64 v7; // [esp+8h] [ebp-24h]

  LODWORD(v2) = sub_80508B8(0xFFFFFFFF, 0xFFFFFFFF, a2, a2 >> 31);
  HIDWORD(v2) = v3;
  if ( v2 >= *(_QWORD *)a1 )
  {
    v5 = a2 * a1[1] + *a1 * (a2 >> 31);
    v6 = *a1 * (unsigned __int64)(unsigned int)a2;
    *(_DWORD *)v7 = v6;
    *(_DWORD *)(v7 + 4) = v5 + HIDWORD(v6);
    result = 0;
  }
  else
  {
    *a1 = -1;
    a1[1] = -1;
    result = 1;
  }
  return result;
}

//----- (0804F522) --------------------------------------------------------
int __cdecl sub_804F522(unsigned int *a1, int a2, int a3)
{
  int v3; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; ; i |= sub_804F476(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}

//----- (0804F558) --------------------------------------------------------
#error "804F7AA: call analysis failed (funcsize=327)"

//----- (0804FA1F) --------------------------------------------------------
int __cdecl sub_804FA1F(FILE *stream)
{
  bool v2; // zf
  void *v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // edx
  int v7; // eax
  int v8; // [esp+0h] [ebp-28h]
  int v9; // [esp+14h] [ebp-14h]
  int v10; // [esp+18h] [ebp-10h]

  v9 = 0;
  if ( fileno(stream) < 0 )
    return fclose(stream);
  v2 = __freading(stream) == 0;
  v3 = &loc_804FA7F;
  if ( v2 )
    v3 = &loc_804FAB8;
  dword_80561AC = (int)v3;
  sub_8050F25(v8);
  v4 = fileno(stream);
  v5 = lseek64(v4, 0, 0, 1);
  v7 = ~v6 | ~v5;
  if ( v7 && sub_804FB34(0, v7 == 0, v7 < 0, 0, (int)stream, stream) )
    v9 = *__errno_location();
  v10 = fclose(stream);
  if ( v9 )
  {
    *__errno_location() = v9;
    v10 = -1;
  }
  return v10;
}
// 8049050: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8050F25: using guessed type int __cdecl sub_8050F25(_DWORD);
// 80561AC: using guessed type int dword_80561AC;

//----- (0804FAFB) --------------------------------------------------------
int __cdecl sub_804FAFB(FILE *stream)
{
  int result; // eax

  result = stream->_flags & 0x100;
  if ( result )
    result = sub_804FB93(stream, 0, 0, 1);
  return result;
}

//----- (0804FB34) --------------------------------------------------------
int __usercall sub_804FB34@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, FILE *fp)
{
  __int16 v7; // [esp+16h] [ebp-6h]
  __int16 *v8; // [esp+18h] [ebp-4h]

  v8 = (__int16 *)a5;
  __asm { pushfw }
  if ( sub_804CA56() != 732 )
    sub_804CA60();
  __asm { popfw }
  v8 = &v7;
  if ( !fp || !__freading(fp) )
    return fflush(fp);
  sub_804FAFB(fp);
  return fflush(fp);
}
// 804CA60: using guessed type int sub_804CA60(void);

//----- (0804FB93) --------------------------------------------------------
#error "804FC82: call analysis failed (funcsize=101)"

//----- (0804FCD6) --------------------------------------------------------
size_t __usercall sub_804FCD6@<eax>(int a1@<edx>, int a2@<ecx>, wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  void *v6; // eax
  wchar_t v8; // [esp+18h] [ebp-10h]
  size_t v9; // [esp+1Ch] [ebp-Ch]

  v6 = &loc_804FCFB;
  if ( pwc )
    v6 = &loc_804FD01;
  dword_8056198 = (int)v6;
  sub_8050F97(a2, a1);
  v9 = mbrtowc(&v8, s, n, p);
  if ( v9 <= 0xFFFFFFFD || !n || !((unsigned __int8)sub_804FF4B(0) ^ 1) )
    return v9;
  v8 = (unsigned __int8)*s;
  return 1;
}
// 8056198: using guessed type int dword_8056198;

//----- (0804FD61) --------------------------------------------------------
int sub_804FD61()
{
  return 0;
}

//----- (0804FD6B) --------------------------------------------------------
int sub_804FD6B()
{
  return 0;
}

//----- (0804FD75) --------------------------------------------------------
int __cdecl sub_804FD75(int a1)
{
  bool v1; // zf
  void *v2; // eax

  v1 = sub_804FD6B() == 0;
  v2 = &loc_804FDA8;
  if ( !v1 )
    v2 = &loc_804FDBC;
  dword_80561AC = (int)v2;
  sub_8050F25(a1);
  return sub_804FD61();
}
// 8050F25: using guessed type int __cdecl sub_8050F25(_DWORD);
// 80561AC: using guessed type int dword_80561AC;

//----- (0804FDE0) --------------------------------------------------------
int __cdecl sub_804FDE0(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // esi
  unsigned __int8 *v3; // ebx
  unsigned __int8 v5; // [esp+1Eh] [ebp-Ah]
  unsigned __int8 v6; // [esp+1Fh] [ebp-9h]

  v2 = a1;
  v3 = a2;
  if ( a1 == a2 )
    return 0;
  do
  {
    v5 = sub_8050880(*v2);
    v6 = sub_8050880(*v3);
    if ( !v5 )
      break;
    ++v2;
    ++v3;
  }
  while ( v5 == v6 );
  return v5 - v6;
}

//----- (0804FE45) --------------------------------------------------------
#error "804FEE4: call analysis failed (funcsize=82)"

//----- (0804FF40) --------------------------------------------------------
#error "804FF41: positive sp value has been found (funcsize=0)"

//----- (0804FF4B) --------------------------------------------------------
#error "804FF9C: call analysis failed (funcsize=43)"

//----- (0804FFDB) --------------------------------------------------------
#error "805015E: call analysis failed (funcsize=168)"

//----- (08050555) --------------------------------------------------------
char *sub_8050555()
{
  bool v0; // zf
  void *v1; // eax
  void *v2; // eax
  size_t v3; // eax
  int v4; // ecx
  int v5; // ST08_4
  char *v6; // ST24_4
  int v8; // [esp+0h] [ebp-28h]
  int v9; // [esp+0h] [ebp-28h]
  const char *s1; // [esp+18h] [ebp-10h]
  char *s2; // [esp+1Ch] [ebp-Ch]

  s1 = nl_langinfo(14);
  if ( !s1 )
    s1 = (const char *)&unk_8052587;
  for ( s2 = (char *)sub_804FFDB(); *s2; s2 = &v6[strlen(v6) + 1] )
  {
    v0 = strcmp(s1, s2) == 0;
    v1 = &loc_80505B3;
    if ( v0 )
      v1 = &loc_80505E3;
    dword_80561FC = (int)v1;
    sub_8050D25(v8);
    if ( *s2 == 42 )
    {
      v2 = &loc_80505E3;
      if ( s2[1] )
        v2 = &loc_8050610;
      dword_80561FC = (int)v2;
      sub_8050D25(v9);
      v3 = strlen(s2);
      s1 = &s2[v3 + 1];
      dword_805610C = (int)&loc_8050640;
      sub_80512AB(v4, v3 + 1, v5);
    }
    v6 = &s2[strlen(s2) + 1];
  }
  if ( !*s1 )
    s1 = "ASCII";
  return (char *)s1;
}
// 8050555: could not find valid save-restore pair for ebx
// 804FFDB: using guessed type int sub_804FFDB(void);
// 8050D25: using guessed type int __cdecl sub_8050D25(_DWORD);
// 805610C: using guessed type int dword_805610C;
// 80561FC: using guessed type int dword_80561FC;

//----- (08050880) --------------------------------------------------------
int __cdecl sub_8050880(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 65) > 0x19 )
    result = a1;
  else
    result = a1 + 32;
  return result;
}

//----- (080508B8) --------------------------------------------------------
int __cdecl sub_80508B8(unsigned int a1, unsigned int a2, int a3, int a4)
{
  void *v4; // eax
  unsigned int v5; // edx
  unsigned int v6; // ecx
  unsigned int v7; // esi

  v4 = &loc_8050904;
  if ( a4 )
    v4 = &loc_8050940;
  dword_805610C = (int)v4;
  sub_80512AB(a3, a2, a3);
  if ( v6 > a2 )
    return __PAIR__(v5, a1) / v6;
  v7 = v6;
  if ( !v6 )
    v7 = 1 / 0u;
  return __PAIR__(a2 % v7, a1) / v7;
}
// 805610C: using guessed type int dword_805610C;

//----- (080509ED) --------------------------------------------------------
#error "8050A42: positive sp value has been found (funcsize=25)"

//----- (08050ACC) --------------------------------------------------------
int __cdecl sub_8050ACC(int a1)
{
  return __cxa_atexit(a1, 0, dword_8056240);
}
// 8048EB0: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 8056240: using guessed type int dword_8056240;

//----- (08050C57) --------------------------------------------------------
#error "8050C90: positive sp value has been found (funcsize=18)"

//----- (08050C98) --------------------------------------------------------
#error "8050C9E: positive sp value has been found (funcsize=0)"

//----- (08050CE4) --------------------------------------------------------
#error "8050D1D: positive sp value has been found (funcsize=18)"

//----- (08050D25) --------------------------------------------------------
#error "8050D2B: positive sp value has been found (funcsize=0)"

//----- (08050D71) --------------------------------------------------------
#error "8050DAA: positive sp value has been found (funcsize=18)"

//----- (08050DB2) --------------------------------------------------------
#error "8050DB8: positive sp value has been found (funcsize=0)"

//----- (08050E22) --------------------------------------------------------
#error "8050E28: positive sp value has been found (funcsize=0)"

//----- (08050E9C) --------------------------------------------------------
#error "8050EA2: positive sp value has been found (funcsize=0)"

//----- (08050EE4) --------------------------------------------------------
#error "8050F1D: positive sp value has been found (funcsize=18)"

//----- (08050F25) --------------------------------------------------------
#error "8050F2B: positive sp value has been found (funcsize=0)"

//----- (08050F97) --------------------------------------------------------
#error "8050F9D: positive sp value has been found (funcsize=0)"

//----- (08051005) --------------------------------------------------------
#error "805100B: positive sp value has been found (funcsize=0)"

//----- (08051071) --------------------------------------------------------
#error "8051077: positive sp value has been found (funcsize=0)"

//----- (080510E7) --------------------------------------------------------
#error "80510ED: positive sp value has been found (funcsize=0)"

//----- (0805115B) --------------------------------------------------------
#error "8051161: positive sp value has been found (funcsize=0)"

//----- (080511CF) --------------------------------------------------------
#error "80511D5: positive sp value has been found (funcsize=0)"

//----- (0805123D) --------------------------------------------------------
#error "8051243: positive sp value has been found (funcsize=0)"

//----- (080512AB) --------------------------------------------------------
#error "80512B1: positive sp value has been found (funcsize=0)"

//----- (080512C0) --------------------------------------------------------
int (**sub_80512C0())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_8055EC4;
  v1 = &off_8055EC8 - off_8055EC4;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_8055EC4[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 8055EC4: using guessed type int (*off_8055EC4[2])();
// 8055EC8: using guessed type int (*off_8055EC8)();

//----- (08051324) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 43 decompilation failure(s) on 169 function(s)"
