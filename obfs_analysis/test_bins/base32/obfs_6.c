/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8048D10();
// int strcmp(const char *s1, const char *s2);
// int __cdecl open64(_DWORD, _DWORD); weak
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void _exit(int status);
// void free(void *ptr);
// uintmax_t strtoumax(const char *nptr, char **endptr, int base);
// void *memcpy(void *dest, const void *src, size_t n);
// int fclose(FILE *stream);
// int getc_unlocked(FILE *stream);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// int fputc_unlocked(int c, FILE *stream);
// char *textdomain(const char *domainname);
// int ferror_unlocked(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// size_t __ctype_get_mb_cur_max(void);
// size_t __fpending(FILE *fp);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// void error(int status, int errnum, const char *format, ...);
// size_t fread_unlocked(void *ptr, size_t size, size_t n, FILE *stream);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// char *strchr(const char *s, int c);
// int fscanf(FILE *stream, const char *format, ...);
// size_t strlen(const char *s);
// int fprintf(FILE *stream, const char *format, ...);
// void *memset(void *s, int c, size_t n);
// int ungetc(int c, FILE *stream);
// int *__errno_location(void);
// void *memchr(const void *s, int c, size_t n);
// int fileno(FILE *stream);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// char *strrchr(const char *s, int c);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// char *bindtextdomain(const char *domainname, const char *dirname);
// int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// int feof_unlocked(FILE *stream);
// void abort(void);
// int close(int fd);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// int _gmon_start__(void); weak
void sub_8049133();
void sub_8049150();
int sub_8049160();
int sub_80491D0();
int sub_80491F0();
void sub_804924F();
void sub_804926A();
int sub_804927A();
void sub_804935C();
void sub_8049377();
int sub_8049387();
// int __usercall sub_80493EE@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
void sub_8049485();
void sub_80494A0();
int sub_80494B0();
void sub_80495A7();
void sub_80495C2();
signed int sub_80495D2();
void sub_80496B4();
void sub_80496CF();
int sub_80496DF();
int sub_8049769();
void sub_80497DD();
void sub_80497F8();
int sub_8049808();
void sub_80498EA();
void sub_8049905();
int sub_8049915();
void sub_80499F7();
void sub_8049A12();
int sub_8049A22();
// int __usercall sub_8049A89@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
void sub_8049B20();
void sub_8049B3B();
int sub_8049B4B();
void sub_8049C2D();
void sub_8049C48();
int sub_8049C58();
void sub_8049D4F();
void sub_8049D6A();
int sub_8049D7A();
int sub_8049E04();
void sub_8049EC6();
void sub_8049EE1();
int sub_8049EF1();
int nullsub_5(void); // weak
int sub_8049F4F();
void sub_8049FEF();
void sub_804A00A();
int sub_804A01A();
int nullsub_6(void); // weak
int sub_804A078();
// int __usercall sub_804A102@<eax>(void (__cdecl *a1)(int *)@<eax>);
int sub_804A12E();
int sub_804A176();
// int __usercall sub_804A1A1@<eax>(char _CF@<cf>, bool _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>, char *a7);
void __cdecl __noreturn sub_804A38A(int status); // idb
int __cdecl sub_804A489(void *ptr, size_t n, int, int, int, FILE *stream); // idb
// unsigned int __usercall sub_804A678@<eax>(int a1@<ebx>, FILE *a2, FILE *a3, __int64 a4);
// int __usercall __noreturn sub_804A925@<eax>(char *a1@<ebx>, FILE *a2, FILE *a3, char a4);
int sub_804ACCC(); // weak
int __cdecl main(int, char **, char **); // idb
int __cdecl sub_804B148(unsigned __int8 a1);
void __cdecl sub_804B15A(unsigned __int8 *a1, int a2, _BYTE *a3, int a4);
char __cdecl sub_804B5C7(unsigned __int8 a1);
_DWORD *__cdecl sub_804B5F0(_DWORD *a1);
// const void *__usercall sub_804B5FE@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, _DWORD *a6, int *a7, int a8, _DWORD *a9);
signed int __cdecl sub_804B705(unsigned __int8 *a1, unsigned int a2, int *a3, _DWORD *a4);
// bool __usercall sub_804BCB6@<al>(int a1@<ebx>, int *a2, int a3, int a4, int a5, int *a6);
int __cdecl sub_804C0F0(int a1, int a2, int a3, int a4, int a5, int a6);
void __cdecl sub_804C151(FILE *stream, int a2);
int __cdecl sub_804C199(char *s); // idb
int __cdecl sub_804C313(int *a1, unsigned __int8 a2, char a3);
// __int16 *__usercall sub_804C3CD@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, __int16 *a5@<eax>, signed int a6@<ebx>, int *a7, int a8, int a9);
// _DWORD *__userpurge sub_804C460@<eax>(_DWORD *a1, int a2);
const char *__cdecl sub_804C502(char *msgid, int a2);
_DWORD __cdecl sub_804C5B5(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
void *__cdecl sub_804D52E(int a1, int a2, _DWORD *a3, int *a4);
_DWORD __cdecl sub_804D6F5(_DWORD, _DWORD, _DWORD, _DWORD); // weak
// int __usercall sub_804D973@<eax>(signed int a1@<ebx>, int a2, int a3);
int __cdecl sub_804D9C2(int a1, int a2, int a3);
int __cdecl sub_804DA55(int a1, int a2, int a3);
// int __usercall sub_804DA93@<eax>(signed int a1@<ebx>, int a2, int a3, int a4, int a5);
int __cdecl sub_804DB60(int a1, int a2, unsigned __int8 a3);
int __cdecl sub_804DC1A(int a1, unsigned __int8 a2);
int __cdecl sub_804DC53(int a1);
// int __usercall sub_804DC90@<eax>(signed int a1@<ebx>, int a2, int a3, int a4);
// int __usercall sub_804DD66@<eax>(signed int a1@<ebx>, int a2, int a3, int a4, int a5);
// int __usercall sub_804DDA6@<eax>(signed int a1@<ebx>, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_804DED0(int a1, int a2, int a3);
int __cdecl sub_804DF2B(int a1, int a2);
int __cdecl sub_804DF4D(int a1);
int __cdecl sub_804DF68(FILE *stream, int, int, int, int, int); // idb
int __cdecl sub_804E5FB(FILE *stream, int, int, int, int); // idb
int sub_804E68E(FILE *stream, int a2, int a3, int a4, ...);
void *__cdecl sub_804E7A1(void *ptr, int a2, int a3);
void *__cdecl sub_804E838(size_t size);
void *__cdecl sub_804E84B(size_t size);
void *__cdecl sub_804E875(void *ptr, size_t size);
void *__cdecl sub_804E97F(void *src, size_t n);
void __noreturn sub_804E9F2();
void sub_804EA2B();
// void __usercall sub_804EA30(signed int a1@<ebx>);
_DWORD __cdecl sub_804EA78(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_804EC09(int a1, int a2, int a3, int a4, int a5, int a6);
signed int __cdecl sub_804EC7D(unsigned int *a1, signed int a2);
int __cdecl sub_804ED46(unsigned int *a1, signed int a2, int a3);
int __cdecl sub_804ED91(char *nptr, int, int base, int, char *s); // idb
int __cdecl sub_804F26D(FILE *stream); // idb
int __cdecl sub_804F330(FILE *stream); // idb
// int __usercall sub_804F369@<eax>(int a1@<eax>, FILE *fp);
int __cdecl sub_804F3C6(FILE *stream, int, int, int); // idb
size_t __cdecl sub_804F4D5(wchar_t *pwc, char *s, size_t n, mbstate_t *p);
int sub_804F560();
int sub_804F56A();
int sub_804F574();
int __cdecl sub_804F5A7(unsigned __int8 *a1, unsigned __int8 *a2);
signed int sub_804F63A();
int sub_804F644(void); // weak
int __cdecl sub_804F645(FILE *fp); // idb
int __cdecl sub_804F6FC(int category); // idb
int sub_804F75A(void); // weak
const char *sub_804FD26();
int __cdecl sub_8050006(int a1);
signed __int64 __cdecl sub_805003E(unsigned __int64 a1, unsigned int a2, unsigned int a3);
int __cdecl sub_805023D(int a1);
int sub_80503CA(void); // weak
int __stdcall sub_8050442(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int sub_80504B4(void); // weak
int sub_805052E(void); // weak
int __stdcall sub_80505C1(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_8050631(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_805069D(_DWORD); // weak
int __stdcall sub_8050724(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int sub_805079E(void); // weak
int __fastcall sub_8050814(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (**sub_8050830())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_804A046; // weak
_UNKNOWN loc_804A262; // weak
_UNKNOWN loc_804A266; // weak
_UNKNOWN loc_804A2A0; // weak
_UNKNOWN loc_804A76B; // weak
_UNKNOWN loc_804A77B; // weak
_UNKNOWN loc_804AA3E; // weak
_UNKNOWN loc_804AA47; // weak
_UNKNOWN loc_804AB71; // weak
_UNKNOWN loc_804AB76; // weak
_UNKNOWN loc_804ACC7; // weak
_UNKNOWN loc_804B206; // weak
_UNKNOWN loc_804B281; // weak
_UNKNOWN loc_804B286; // weak
_UNKNOWN loc_804B771; // weak
_UNKNOWN loc_804B78D; // weak
_UNKNOWN loc_804B83B; // weak
_UNKNOWN loc_804B87B; // weak
_UNKNOWN loc_804B88C; // weak
_UNKNOWN loc_804BC19; // weak
_UNKNOWN loc_804BC2B; // weak
_UNKNOWN loc_804BCAF; // weak
_UNKNOWN loc_804BD27; // weak
_UNKNOWN loc_804BD85; // weak
_UNKNOWN loc_804BDB0; // weak
_UNKNOWN loc_804BDB5; // weak
_UNKNOWN loc_804BE58; // weak
_UNKNOWN loc_804C570; // weak
_UNKNOWN locret_804E8D7; // weak
_UNKNOWN loc_804ED7F; // weak
_UNKNOWN locret_804F4D3; // weak
_UNKNOWN loc_804F4FA; // weak
_UNKNOWN loc_804F500; // weak
_UNKNOWN loc_804F5D2; // weak
_UNKNOWN loc_804F5EE; // weak
_UNKNOWN loc_804F633; // weak
_UNKNOWN loc_804F6C6; // weak
_UNKNOWN loc_804F6D1; // weak
_UNKNOWN loc_804FD9B; // weak
_UNKNOWN loc_804FDB3; // weak
_UNKNOWN loc_8050178; // weak
_UNKNOWN loc_8050192; // weak
char locale = '\0'; // idb
char byte_8050F70[256] =
{
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\x1A',
  '\x1B',
  '\x1C',
  '\x1D',
  '\x1E',
  '\x1F',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\x01',
  '\x02',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\n',
  '\v',
  '\f',
  '\r',
  '\x0E',
  '\x0F',
  '\x10',
  '\x11',
  '\x12',
  '\x13',
  '\x14',
  '\x15',
  '\x16',
  '\x17',
  '\x18',
  '\x19',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF'
}; // idb
char byte_8051070[32] =
{
  'A',
  'B',
  'C',
  'D',
  'E',
  'F',
  'G',
  'H',
  'I',
  'J',
  'K',
  'L',
  'M',
  'N',
  'O',
  'P',
  'Q',
  'R',
  'S',
  'T',
  'U',
  'V',
  'W',
  'X',
  'Y',
  'Z',
  '2',
  '3',
  '4',
  '5',
  '6',
  '7'
}; // idb
_UNKNOWN unk_80511C2; // weak
_UNKNOWN unk_80511CE; // weak
_UNKNOWN unk_80511D2; // weak
_UNKNOWN unk_80511D5; // weak
_UNKNOWN unk_8051AD7; // weak
int dword_8051F10 = 939917312; // weak
_UNKNOWN unk_805217C; // weak
_UNKNOWN unk_805217F; // weak
_UNKNOWN unk_80531BC; // weak
_UNKNOWN unk_80531BF; // weak
int (*off_8054ED4[2])() = { &sub_80491F0, &sub_80491D0 }; // weak
int (*off_8054ED8)() = &sub_80491D0; // weak
int (*dword_8055008)(void) = NULL; // weak
int dword_805510C = 0; // weak
int dword_8055120 = 0; // weak
int dword_8055134 = 0; // weak
int dword_8055148 = 0; // weak
int dword_805515C = 0; // weak
int dword_8055170 = 0; // weak
int dword_8055184 = 0; // weak
int dword_8055198 = 0; // weak
int dword_80551AC = 0; // weak
int dword_80551C0 = 0; // weak
int dword_80551F0 = 0; // weak
int status = 1; // idb
_UNKNOWN unk_805522C; // weak
_UNKNOWN unk_8055248; // weak
_UNKNOWN unk_805524B; // weak
_UNKNOWN unk_8055250; // weak
_UNKNOWN unk_8055253; // weak
_UNKNOWN unk_805525C; // weak
_UNKNOWN unk_805525F; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
FILE *stdout; // idb
char byte_80552AC; // weak
_UNKNOWN unk_805534A; // weak
char byte_805542D; // weak
char byte_80555FB; // weak
int dword_80556A1; // weak
int dword_80556A9; // weak
int dword_80556AD; // weak
int dword_80556B1; // weak
int dword_80556B5; // weak
int dword_80556B9; // weak
int dword_80556BD; // weak
int dword_80556C1; // weak
int dword_80556C5; // weak
int dword_80556C9; // weak
int dword_80556CD; // weak
int dword_80556D1; // weak
int dword_80556D5; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (08048CE0) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 80490F0: using guessed type int _gmon_start__(void);

//----- (08048D10) --------------------------------------------------------
int sub_8048D10()
{
  return dword_8055008();
}
// 8055008: using guessed type int (*dword_8055008)(void);

//----- (08049100) --------------------------------------------------------
#error "8049103: positive sp value has been found (funcsize=2)"

//----- (08049133) --------------------------------------------------------
void sub_8049133()
{
  ;
}

//----- (08049150) --------------------------------------------------------
void sub_8049150()
{
  ;
}

//----- (08049160) --------------------------------------------------------
int sub_8049160()
{
  int result; // eax

  result = &unk_805525F - &unk_805525C;
  if ( (unsigned int)(&unk_805525F - &unk_805525C) > 6 )
    result = 0;
  return result;
}
// 8049160: could not find valid save-restore pair for ebp

//----- (080491D0) --------------------------------------------------------
int sub_80491D0()
{
  int result; // eax

  if ( !byte_80552AC )
  {
    result = sub_8049160();
    byte_80552AC = 1;
  }
  return result;
}
// 80491D0: could not find valid save-restore pair for ebp
// 80552AC: using guessed type char byte_80552AC;

//----- (080491F0) --------------------------------------------------------
int sub_80491F0()
{
  return 0;
}
// 80491F0: could not find valid save-restore pair for ebp

//----- (0804924F) --------------------------------------------------------
void sub_804924F()
{
  ;
}

//----- (0804926A) --------------------------------------------------------
void sub_804926A()
{
  ;
}

//----- (0804927A) --------------------------------------------------------
int sub_804927A()
{
  int result; // eax

  result = &unk_805524B - &unk_8055248;
  if ( (unsigned int)(&unk_805524B - &unk_8055248) > 6 )
    result = 0;
  return result;
}
// 804927A: could not find valid save-restore pair for ebp

//----- (0804935C) --------------------------------------------------------
void sub_804935C()
{
  ;
}

//----- (08049377) --------------------------------------------------------
void sub_8049377()
{
  ;
}

//----- (08049387) --------------------------------------------------------
int sub_8049387()
{
  int result; // eax

  result = &unk_805524B - &unk_8055248;
  if ( (unsigned int)(&unk_805524B - &unk_8055248) > 6 )
    result = 0;
  return result;
}
// 8049387: could not find valid save-restore pair for ebp

//----- (080493EE) --------------------------------------------------------
int __usercall sub_80493EE@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_8055248, a1);
}

//----- (08049485) --------------------------------------------------------
void sub_8049485()
{
  ;
}

//----- (080494A0) --------------------------------------------------------
void sub_80494A0()
{
  ;
}

//----- (080494B0) --------------------------------------------------------
int sub_80494B0()
{
  int result; // eax

  result = &unk_805534A - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_805534A - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 80494B0: could not find valid save-restore pair for ebp
// 8055260: using guessed type int program_invocation_short_name;

//----- (080495A7) --------------------------------------------------------
void sub_80495A7()
{
  ;
}

//----- (080495C2) --------------------------------------------------------
void sub_80495C2()
{
  ;
}

//----- (080495D2) --------------------------------------------------------
signed int sub_80495D2()
{
  return 3;
}
// 80495D2: could not find valid save-restore pair for ebp

//----- (080496B4) --------------------------------------------------------
void sub_80496B4()
{
  ;
}

//----- (080496CF) --------------------------------------------------------
void sub_80496CF()
{
  ;
}

//----- (080496DF) --------------------------------------------------------
int sub_80496DF()
{
  int result; // eax

  result = &unk_805524B - &unk_8055248;
  if ( (unsigned int)(&unk_805524B - &unk_8055248) > 6 )
    result = 0;
  return result;
}
// 80496DF: could not find valid save-restore pair for ebp

//----- (08049769) --------------------------------------------------------
int sub_8049769()
{
  int result; // eax

  result = sub_80496DF();
  byte_805542D = 1;
  return result;
}
// 805542D: using guessed type char byte_805542D;

//----- (080497DD) --------------------------------------------------------
void sub_80497DD()
{
  ;
}

//----- (080497F8) --------------------------------------------------------
void sub_80497F8()
{
  ;
}

//----- (08049808) --------------------------------------------------------
int sub_8049808()
{
  int result; // eax

  result = &unk_805524B - &unk_8055248;
  if ( (unsigned int)(&unk_805524B - &unk_8055248) > 6 )
    result = 0;
  return result;
}
// 8049808: could not find valid save-restore pair for ebp

//----- (080498EA) --------------------------------------------------------
void sub_80498EA()
{
  ;
}

//----- (08049905) --------------------------------------------------------
void sub_8049905()
{
  ;
}

//----- (08049915) --------------------------------------------------------
int sub_8049915()
{
  int result; // eax

  result = &unk_805524B - &unk_8055248;
  if ( (unsigned int)(&unk_805524B - &unk_8055248) > 6 )
    result = 0;
  return result;
}
// 8049915: could not find valid save-restore pair for ebp

//----- (080499F7) --------------------------------------------------------
void sub_80499F7()
{
  ;
}

//----- (08049A12) --------------------------------------------------------
void sub_8049A12()
{
  ;
}

//----- (08049A22) --------------------------------------------------------
int sub_8049A22()
{
  int result; // eax

  result = &unk_80531BF - &unk_80531BC;
  if ( (unsigned int)(&unk_80531BF - &unk_80531BC) > 6 )
    result = 0;
  return result;
}
// 8049A22: could not find valid save-restore pair for ebp

//----- (08049A89) --------------------------------------------------------
int __usercall sub_8049A89@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_80531BC, a1);
}

//----- (08049B20) --------------------------------------------------------
void sub_8049B20()
{
  ;
}

//----- (08049B3B) --------------------------------------------------------
void sub_8049B3B()
{
  ;
}

//----- (08049B4B) --------------------------------------------------------
int sub_8049B4B()
{
  int result; // eax

  result = &unk_805524B - &unk_8055248;
  if ( (unsigned int)(&unk_805524B - &unk_8055248) > 6 )
    result = 0;
  return result;
}
// 8049B4B: could not find valid save-restore pair for ebp

//----- (08049C2D) --------------------------------------------------------
void sub_8049C2D()
{
  ;
}

//----- (08049C48) --------------------------------------------------------
void sub_8049C48()
{
  ;
}

//----- (08049C58) --------------------------------------------------------
int sub_8049C58()
{
  int result; // eax

  result = &unk_805524B - &unk_8055248;
  if ( (unsigned int)(&unk_805524B - &unk_8055248) > 6 )
    result = 0;
  return result;
}
// 8049C58: could not find valid save-restore pair for ebp

//----- (08049D4F) --------------------------------------------------------
void sub_8049D4F()
{
  ;
}

//----- (08049D6A) --------------------------------------------------------
void sub_8049D6A()
{
  ;
}

//----- (08049D7A) --------------------------------------------------------
int sub_8049D7A()
{
  int result; // eax

  result = &unk_8055253 - &unk_8055250;
  if ( (unsigned int)(&unk_8055253 - &unk_8055250) > 6 )
    result = 0;
  return result;
}
// 8049D7A: could not find valid save-restore pair for ebp

//----- (08049E04) --------------------------------------------------------
int sub_8049E04()
{
  int result; // eax

  result = sub_8049D7A();
  byte_80555FB = 1;
  return result;
}
// 80555FB: using guessed type char byte_80555FB;

//----- (08049EC6) --------------------------------------------------------
void sub_8049EC6()
{
  ;
}

//----- (08049EE1) --------------------------------------------------------
void sub_8049EE1()
{
  ;
}

//----- (08049EF1) --------------------------------------------------------
int sub_8049EF1()
{
  int result; // eax

  result = &unk_805217F - &unk_805217C;
  if ( (unsigned int)(&unk_805217F - &unk_805217C) > 6 )
    result = 0;
  return result;
}
// 8049EF1: could not find valid save-restore pair for ebp

//----- (08049F4F) --------------------------------------------------------
int sub_8049F4F()
{
  return nullsub_5();
}
// 8049F4F: could not find valid save-restore pair for ebp
// 8049F4E: using guessed type int nullsub_5(void);

//----- (08049FEF) --------------------------------------------------------
void sub_8049FEF()
{
  ;
}

//----- (0804A00A) --------------------------------------------------------
void sub_804A00A()
{
  ;
}

//----- (0804A01A) --------------------------------------------------------
int sub_804A01A()
{
  int result; // eax

  result = &unk_8055253 - &unk_8055250;
  if ( (unsigned int)(&unk_8055253 - &unk_8055250) > 6 )
    result = 0;
  return result;
}
// 804A01A: could not find valid save-restore pair for ebp

//----- (0804A078) --------------------------------------------------------
int sub_804A078()
{
  return nullsub_6();
}
// 804A078: could not find valid save-restore pair for ebp
// 804A077: using guessed type int nullsub_6(void);

//----- (0804A102) --------------------------------------------------------
int __usercall sub_804A102@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  int savedregs; // [esp+18h] [ebp+0h]

  a1(&dword_8051F10);
  dword_8055198 = (int)&loc_804A046;
  sub_80504B4();
  savedregs = 0;
  dword_8055184 = (int)nullsub_6;
  sub_805052E();
  return nullsub_6();
}
// 804A077: using guessed type int nullsub_6(void);
// 80504B4: using guessed type int sub_80504B4(void);
// 805052E: using guessed type int sub_805052E(void);
// 8051F10: using guessed type int dword_8051F10;
// 8055184: using guessed type int dword_8055184;
// 8055198: using guessed type int dword_8055198;

//----- (0804A12E) --------------------------------------------------------
int sub_804A12E()
{
  FILE *v0; // ebx
  char *v6; // [esp-4h] [ebp-1Ch]

  v0 = stdout;
  v6 = gettext("\nWith no FILE, or when FILE is -, read standard input.\n");
  __asm { pushfw }
  if ( sub_804F63A() != -24 )
    sub_804F644();
  __asm { popfw }
  return fputs_unlocked(v6, v0);
}
// 8048F50: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 804F644: using guessed type int sub_804F644(void);

//----- (0804A176) --------------------------------------------------------
int sub_804A176()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nMandatory arguments to long options are mandatory for short options too.\n");
  return fputs_unlocked(v1, v0);
}
// 8048F50: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804A1A1) --------------------------------------------------------
int __usercall sub_804A1A1@<eax>(char _CF@<cf>, bool _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>, char *a7)
{
  int v7; // ebx
  int v8; // eax
  void *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  char *v13; // ebx
  char *v14; // eax
  int v16; // [esp-8h] [ebp-74h]
  int v17; // [esp-4h] [ebp-70h]
  char *s1; // [esp+0h] [ebp-6Ch]
  char *s2; // [esp+4h] [ebp-68h]
  size_t n; // [esp+8h] [ebp-64h]
  const char *v21; // [esp+28h] [ebp-44h]
  const char *v22; // [esp+2Ch] [ebp-40h]
  const char *v23; // [esp+30h] [ebp-3Ch]
  const char *v24; // [esp+34h] [ebp-38h]
  const char *v25; // [esp+38h] [ebp-34h]
  const char *v26; // [esp+3Ch] [ebp-30h]
  const char *v27; // [esp+40h] [ebp-2Ch]
  const char *v28; // [esp+44h] [ebp-28h]
  const char *v29; // [esp+48h] [ebp-24h]
  const char *v30; // [esp+4Ch] [ebp-20h]
  const char *v31; // [esp+50h] [ebp-1Ch]
  const char *v32; // [esp+54h] [ebp-18h]
  int v33; // [esp+58h] [ebp-14h]
  int v34; // [esp+5Ch] [ebp-10h]
  int v35; // [esp+62h] [ebp-Ah]
  int v36; // [esp+68h] [ebp-4h]

  v36 = a5;
  __asm { pushfw }
  v35 = a6;
  if ( a6 >= 10 && ((_BYTE)a6 - 1) * (_BYTE)a6 & 1 )
    abort();
  v7 = v35;
  __asm { popfw }
  *(int *)((char *)&v35 + 2) = v35;
  v21 = "[";
  v22 = "test invocation";
  v23 = "coreutils";
  v24 = "Multi-call invocation";
  v25 = "sha224sum";
  v26 = "sha2 utilities";
  v27 = "sha256sum";
  v28 = "sha2 utilities";
  v29 = "sha384sum";
  v30 = "sha2 utilities";
  v31 = "sha512sum";
  v32 = "sha2 utilities";
  v33 = 0;
  v34 = 0;
  *(&s1 - 19) = a7;
  *(&s1 - 18) = (char *)(&s1 - 16);
  dword_8055184 = (int)&loc_804A266;
  sub_805052E();
  *(&s1 - 18) += 8;
  if ( *(_DWORD *)*(&s1 - 18) )
  {
    s2 = *(char **)*(&s1 - 18);
    v8 = strcmp((const char *)n, s2);
    _ZF = v8 == 0;
    v17 = v8;
    v16 = v7;
    v9 = &loc_804A2A0;
    if ( !_ZF )
      v9 = &loc_804A262;
    dword_8055198 = (int)v9;
    sub_80504B4();
  }
  if ( *((_DWORD *)*(&s1 - 18) + 1) )
    *(&s1 - 19) = (char *)*((_DWORD *)*(&s1 - 18) + 1);
  v10 = gettext("\n%s online help: <%s>\n");
  n = (size_t)"http://www.gnu.org/software/coreutils/";
  s2 = "GNU coreutils";
  printf(v10, "GNU coreutils");
  *(&s1 - 17) = setlocale(5, 0);
  if ( *(&s1 - 17) )
  {
    n = 3;
    s2 = "en_";
    s1 = *(&s1 - 17);
    if ( strncmp(s1, "en_", 3u) )
    {
      v11 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
      s2 = (char *)n;
      printf(v11, n);
    }
  }
  v12 = gettext("Full documentation at: <%s%s>\n");
  s2 = "http://www.gnu.org/software/coreutils/";
  printf(v12, "http://www.gnu.org/software/coreutils/");
  if ( *(&s1 - 19) == (char *)n )
    v13 = " invocation";
  else
    v13 = &locale;
  v14 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  n = (size_t)v13;
  return printf(v14, *(&s1 - 19), v13);
}
// 804A1A1: could not find valid save-restore pair for ebx
// 80504B4: using guessed type int sub_80504B4(void);
// 805052E: using guessed type int sub_805052E(void);
// 8055184: using guessed type int dword_8055184;
// 8055198: using guessed type int dword_8055198;

//----- (0804A38A) --------------------------------------------------------
void __cdecl __noreturn sub_804A38A(int status)
{
  int v1; // ebx
  char *v2; // eax
  int v3; // ebx
  char *v4; // eax
  FILE *v5; // ebx
  char *v6; // eax
  FILE *v7; // ebx
  char *v8; // eax
  FILE *v9; // ebx
  char *v10; // eax
  char *v11; // eax
  int v12; // eax
  char v13; // cf
  bool v14; // zf
  char v15; // sf
  char v16; // of

  if ( status )
  {
    v1 = dword_80556A1;
    v2 = gettext("Try '%s --help' for more information.\n");
    fprintf(stderr, v2, v1);
  }
  else
  {
    v3 = dword_80556A1;
    v4 = gettext("Usage: %s [OPTION]... [FILE]\nBase%d encode or decode FILE, or standard input, to standard output.\n");
    printf(v4, v3, 32);
    sub_804A12E();
    sub_804A176();
    v5 = stdout;
    v6 = gettext(
           "  -d, --decode          decode data\n"
           "  -i, --ignore-garbage  when decoding, ignore non-alphabet characters\n"
           "  -w, --wrap=COLS       wrap encoded lines after COLS character (default 76).\n"
           "                          Use 0 to disable line wrapping\n"
           "\n");
    fputs_unlocked(v6, v5);
    v7 = stdout;
    v8 = gettext("      --help     display this help and exit\n");
    fputs_unlocked(v8, v7);
    v9 = stdout;
    v10 = gettext("      --version  output version information and exit\n");
    fputs_unlocked(v10, v9);
    v11 = gettext(
            "\n"
            "The data are encoded as described for the %s alphabet in RFC 4648.\n"
            "When decoding, the input may contain newlines in addition to the bytes of\n"
            "the formal %s alphabet.  Use --ignore-garbage to attempt to recover\n"
            "from any other non-alphabet bytes in the encoded stream.\n");
    v12 = printf(v11, "base32", "base32");
    sub_804A1A1(v13, v14, v15, v16, v12, (signed int)v9, "base32");
  }
  exit(status);
}
// 8048F50: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 80556A1: using guessed type int dword_80556A1;

//----- (0804A489) --------------------------------------------------------
#error "804A61B: call analysis failed (funcsize=119)"

//----- (0804A678) --------------------------------------------------------
unsigned int __usercall sub_804A678@<eax>(int a1@<ebx>, FILE *a2, FILE *a3, __int64 a4)
{
  int v4; // eax
  bool v5; // zf
  void *v6; // eax
  char *v7; // ebx
  int *v8; // eax
  char *v9; // ebx
  int *v10; // eax
  int v12; // [esp-8h] [ebp-13850h]
  int v13; // [esp-4h] [ebp-1384Ch]
  char *v14; // [esp+0h] [ebp-13848h]
  __int64 v15; // [esp+20h] [ebp-13828h]
  FILE *v16; // [esp+28h] [ebp-13820h]
  FILE *stream; // [esp+2Ch] [ebp-1381Ch]
  int v18; // [esp+30h] [ebp-13818h]
  unsigned int v19; // [esp+34h] [ebp-13814h]
  size_t v20; // [esp+38h] [ebp-13810h]
  char ptr; // [esp+783Ch] [ebp-C00Ch]
  unsigned int v22; // [esp+1383Ch] [ebp-Ch]

  stream = a2;
  v16 = a3;
  v15 = a4;
  v22 = __readgsdword(0x14u);
  v18 = 0;
  do
  {
    v19 = 0;
    do
    {
      v14 = (char *)&v14 + v19 - 79884;
      v20 = fread_unlocked(v14, 1u, 30720 - v19, stream);
      v19 += v20;
      if ( feof_unlocked(stream) )
        break;
      v4 = ferror_unlocked(stream);
      v5 = v4 == 0;
      v13 = v4;
      v12 = a1;
      v6 = &loc_804A76B;
      if ( !v5 )
        v6 = &loc_804A77B;
      dword_8055148 = (int)v6;
      a1 = v12;
      sub_805069D(v14);
    }
    while ( v19 <= 0x77FF );
    if ( v19 )
    {
      sub_804B15A((unsigned __int8 *)&v14 - 79884, v19, &ptr, 8 * ((v19 + 4) / 5));
      sub_804A489(&v14 - 12291, 8 * ((v19 + 4) / 5), v15, SHIDWORD(v15), (int)(&v14 - 19974), v16);
    }
  }
  while ( !feof_unlocked(stream) && !ferror_unlocked(stream) && v19 == 30720 );
  if ( v15 && v18 && fputc_unlocked(10, v16) == -1 )
  {
    v7 = gettext("write error");
    v8 = __errno_location();
    error(1, *v8, v7);
  }
  if ( ferror_unlocked(stream) )
  {
    v9 = gettext("read error");
    v10 = __errno_location();
    error(1, *v10, v9);
  }
  return __readgsdword(0x14u) ^ v22;
}
// 805069D: using guessed type int __stdcall sub_805069D(_DWORD);
// 8055148: using guessed type int dword_8055148;

//----- (0804A925) --------------------------------------------------------
int __usercall __noreturn sub_804A925@<eax>(char *a1@<ebx>, FILE *a2, FILE *a3, char a4)
{
  bool v4; // zf
  void *v5; // eax
  int *v6; // eax
  void *v7; // eax
  int v8; // eax
  size_t v9; // eax
  int *v10; // eax
  char *v11; // eax
  unsigned int v12; // eax
  unsigned int v13; // et1
  int (*v14)(); // eax
  char *v16; // [esp-8h] [ebp-3460h]
  int v17; // [esp-4h] [ebp-345Ch]
  unsigned __int8 v18; // [esp+0h] [ebp-3458h]
  int v19; // [esp+4h] [ebp-3454h]
  int v20; // [esp+8h] [ebp-3450h]
  int v21; // [esp+Ch] [ebp-344Ch]
  int v22; // [esp+10h] [ebp-3448h]
  char v23; // [esp+14h] [ebp-3444h]
  FILE *v24; // [esp+18h] [ebp-3440h]
  FILE *stream; // [esp+1Ch] [ebp-343Ch]
  int v26; // [esp+20h] [ebp-3438h]
  int v27; // [esp+24h] [ebp-3434h]
  int v28; // [esp+28h] [ebp-3430h]
  int v29; // [esp+2Ch] [ebp-342Ch]
  size_t n; // [esp+30h] [ebp-3428h]
  unsigned int v31; // [esp+34h] [ebp-3424h]
  unsigned int j; // [esp+38h] [ebp-3420h]
  size_t i; // [esp+3Ch] [ebp-341Ch]
  int v34; // [esp+40h] [ebp-3418h]
  int v35; // [esp+44h] [ebp-3414h]
  int v36; // [esp+48h] [ebp-3410h]
  int ptr; // [esp+4Ch] [ebp-340Ch]
  int v38; // [esp+50h] [ebp-3408h]
  int v39; // [esp+54h] [ebp-3404h]
  int v40; // [esp+58h] [ebp-3400h]
  int v41; // [esp+5Ch] [ebp-33FCh]
  int v42; // [esp+60h] [ebp-33F8h]
  int v43; // [esp+64h] [ebp-33F4h]
  int v44; // [esp+68h] [ebp-33F0h]
  char v45[8192]; // [esp+144Ch] [ebp-200Ch]
  unsigned int v46; // [esp+344Ch] [ebp-Ch]

  stream = a2;
  v24 = a3;
  v23 = a4;
  v46 = __readgsdword(0x14u);
  sub_804B5F0((_DWORD *)&v18 - 3334);
  do
  {
    v31 = 0;
    do
    {
      n = fread_unlocked(&v45[v31], 1u, 0x2000 - v31, stream);
      if ( v23 )
      {
        for ( i = 0; n && i < n; ++i )
        {
          *(_DWORD *)&v18 = v45[v31 + i];
          if ( !sub_804B5C7(v18) )
          {
            v4 = v45[v31 + i] == 61;
            v17 = (unsigned __int8)v45[v31 + i];
            v16 = a1;
            v5 = &loc_804AA3E;
            if ( !v4 )
              v5 = &loc_804AA47;
            dword_80551AC = (int)v5;
            a1 = v16;
            sub_8050442(
              *(_DWORD *)&v18,
              v19,
              v20,
              v21,
              v22,
              *(_DWORD *)&v23,
              v24,
              stream,
              v26,
              v27,
              v28,
              v29,
              n,
              v31,
              j,
              i,
              v34,
              v35,
              v36,
              ptr,
              v38,
              v39,
              v40,
              v41,
              v42,
              v43,
              v44);
          }
        }
      }
      v31 += n;
      if ( ferror_unlocked(stream) )
      {
        a1 = gettext("read error");
        v6 = __errno_location();
        error(1, *v6, a1);
      }
    }
    while ( v31 <= 0x1FFF && !feof_unlocked(stream) );
    for ( j = 0; ; ++j )
    {
      v12 = feof_unlocked(stream) ? 2 : 1;
      if ( v12 <= j )
        break;
      if ( j == 1 )
      {
        v17 = v34;
        v16 = a1;
        v7 = &loc_804AB71;
        if ( v34 )
          v7 = &loc_804AB76;
        dword_80551C0 = (int)v7;
        a1 = v16;
        sub_80503CA();
        break;
      }
      n = 5120;
      if ( j )
        v8 = 0;
      else
        v8 = v31;
      HIBYTE(v29) = sub_804BCB6((int)a1, &v34, (int)v45, v8, (int)&ptr, (int *)&n);
      v9 = fwrite_unlocked(&ptr, 1u, n, v24);
      if ( v9 < n )
      {
        a1 = gettext("write error");
        v10 = __errno_location();
        error(1, *v10, a1);
      }
      if ( HIBYTE(v29) != 1 )
      {
        v11 = gettext("invalid input");
        error(1, 0, v11);
      }
    }
  }
  while ( !feof_unlocked(stream) );
  v13 = __readgsdword(0x14u);
  v17 = v13 ^ v46;
  v16 = a1;
  v14 = (int (*)())&loc_804ACC7;
  if ( v13 == v46 )
    v14 = sub_804ACCC;
  dword_8055134 = (int)v14;
  return sub_8050724(
           *(_DWORD *)&v18,
           v19,
           v20,
           v21,
           v22,
           *(_DWORD *)&v23,
           v24,
           stream,
           v26,
           v27,
           v28,
           v29,
           n,
           v31,
           j,
           i,
           v34,
           v35,
           v36,
           ptr,
           v38,
           v39,
           v40);
}
// 804ACCC: using guessed type int sub_804ACCC();
// 80503CA: using guessed type int sub_80503CA(void);
// 8050442: using guessed type int __stdcall sub_8050442(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8050724: using guessed type int __stdcall sub_8050724(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8055134: using guessed type int dword_8055134;
// 80551AC: using guessed type int dword_80551AC;
// 80551C0: using guessed type int dword_80551C0;
// 804A925: using guessed type char var_200C[8192];

//----- (0804ACCC) --------------------------------------------------------
#error "804ACD2: positive sp value has been found (funcsize=0)"

//----- (0804ACD5) --------------------------------------------------------
#error "804AF6C: call analysis failed (funcsize=191)"

//----- (0804B148) --------------------------------------------------------
int __cdecl sub_804B148(unsigned __int8 a1)
{
  return a1;
}

//----- (0804B15A) --------------------------------------------------------
#error "804B1F8: call analysis failed (funcsize=102)"

//----- (0804B5C7) --------------------------------------------------------
char __cdecl sub_804B5C7(unsigned __int8 a1)
{
  return (unsigned __int8)~byte_8050F70[(unsigned __int8)sub_804B148(a1)] >> 7;
}

//----- (0804B5F0) --------------------------------------------------------
_DWORD *__cdecl sub_804B5F0(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = 0;
  return result;
}

//----- (0804B5FE) --------------------------------------------------------
const void *__usercall sub_804B5FE@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, _DWORD *a6, int *a7, int a8, _DWORD *a9)
{
  void **v9; // ebp
  const void *result; // eax
  _BYTE *v11; // eax
  int v12; // eax
  _DWORD *v13; // edx
  void *s; // [esp+0h] [ebp-2Ch]
  size_t n; // [esp+8h] [ebp-24h]
  int v16; // [esp+18h] [ebp-14h]
  const void *v17; // [esp+1Ch] [ebp-10h]
  __int16 v18; // [esp+26h] [ebp-6h]
  __int16 *v19; // [esp+28h] [ebp-4h]

  v19 = (__int16 *)a5;
  __asm { pushfw }
  if ( sub_804F63A() != -24 )
    sub_804F644();
  __asm { popfw }
  v19 = &v18;
  v9 = (void **)&v19;
  if ( *a6 == 8 )
    *a6 = 0;
  if ( *a6 || (v17 = (const void *)*a7, a8 - *a7 <= 7) || memchr(v17, 10, 8u) )
  {
    v16 = *a7;
    while ( *(v9 - 4) < v9[4] )
    {
      v11 = *(v9 - 4);
      *(v9 - 4) = v11 + 1;
      *((_BYTE *)v9 - 17) = *v11;
      if ( *((_BYTE *)v9 - 17) != 10 )
      {
        v12 = *(_DWORD *)v9[2];
        v13 = v9[2];
        v9 = &s;
        *v13 = v12 + 1;
        *(_BYTE *)(n + v12 + 4) = *((_BYTE *)&s - 17);
        if ( *(_DWORD *)n == 8 )
          break;
      }
    }
    *(_DWORD *)v9[3] = *(v9 - 4);
    *(_DWORD *)v9[5] = *(_DWORD *)v9[2];
    result = (char *)v9[2] + 4;
  }
  else
  {
    *a7 += 8;
    *a9 = 8;
    result = v17;
  }
  return result;
}
// 804B5FE: could not find valid save-restore pair for ebp
// 804F644: using guessed type int sub_804F644(void);

//----- (0804B705) --------------------------------------------------------
#error "804B76C: call analysis failed (funcsize=416)"

//----- (0804BCB6) --------------------------------------------------------
#error "804BD22: call analysis failed (funcsize=177)"

//----- (0804BFF7) --------------------------------------------------------
#error "804C041: call analysis failed (funcsize=68)"

//----- (0804C0F0) --------------------------------------------------------
int __cdecl sub_804C0F0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // [esp+20h] [ebp-28h]
  int v8; // [esp+24h] [ebp-24h]

  v7 = a4;
  v8 = a5;
  return posix_fadvise64(a1, a2, a3, a4, a5, a6);
}
// 8049070: using guessed type int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804C151) --------------------------------------------------------
void __cdecl sub_804C151(FILE *stream, int a2)
{
  int v2; // eax

  if ( stream )
  {
    v2 = fileno(stream);
    sub_804C0F0(v2, 0, 0, 0, 0, a2);
  }
}

//----- (0804C199) --------------------------------------------------------
#error "804C1FF: call analysis failed (funcsize=65)"

//----- (0804C313) --------------------------------------------------------
int __cdecl sub_804C313(int *a1, unsigned __int8 a2, char a3)
{
  int *v3; // eax
  int v4; // ST10_4

  if ( a1 )
    v3 = a1;
  else
    v3 = &dword_80556A9;
  v4 = ((unsigned int)v3[(a2 >> 5) + 2] >> (a2 & 0x1F)) & 1;
  v3[(a2 >> 5) + 2] ^= (v4 ^ a3 & 1) << (a2 & 0x1F);
  return v4;
}
// 80556A9: using guessed type int dword_80556A9;

//----- (0804C3CD) --------------------------------------------------------
__int16 *__usercall sub_804C3CD@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, __int16 *a5@<eax>, signed int a6@<ebx>, int *a7, int a8, int a9)
{
  signed int *v9; // ebp
  __int16 *result; // eax
  signed int v15; // [esp-16h] [ebp-16h]
  int *v16; // [esp-10h] [ebp-10h]
  __int16 v17; // [esp-6h] [ebp-6h]
  __int16 *v18; // [esp-4h] [ebp-4h]

  v18 = a5;
  __asm { pushfw }
  if ( sub_804F63A() != -24 )
    sub_804F644();
  __asm { popfw }
  v18 = &v17;
  v9 = (signed int *)&v18;
  if ( !a7 )
    a7 = &dword_80556A9;
  *a7 = 10;
  if ( !a8 || (_CF = 0, _OF = 0, _ZF = a9 == 0, _SF = a9 < 0, !a9) )
    abort();
  v16 = a7;
  __asm { pushfw }
  v15 = a6;
  if ( a6 >= 10 )
  {
    v9 = &v15;
    if ( ((_BYTE)a6 - 1) * (_BYTE)a6 & 1 )
      abort();
  }
  __asm { popfw }
  *(_DWORD *)(v9[2] + 40) = v9[3];
  result = v18;
  *((_DWORD *)v18 + 11) = a7;
  return result;
}
// 804C3CD: could not find valid save-restore pair for ebp
// 804F644: using guessed type int sub_804F644(void);
// 80556A9: using guessed type int dword_80556A9;

//----- (0804C460) --------------------------------------------------------
_DWORD *__userpurge sub_804C460@<eax>(_DWORD *a1, int a2)
{
  int v3; // [esp+0h] [ebp-38h]
  int v4; // [esp+4h] [ebp-34h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]

  memset(&v3 - 14, 0, 0x30u);
  if ( a2 == 10 )
    abort();
  *a1 = a2;
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = v6;
  a1[4] = v7;
  a1[5] = v8;
  a1[6] = v9;
  a1[7] = v10;
  a1[8] = v11;
  a1[9] = v12;
  a1[10] = v13;
  a1[11] = v14;
  return a1;
}

//----- (0804C502) --------------------------------------------------------
const char *__cdecl sub_804C502(char *msgid, int a2)
{
  const char *result; // eax
  char *v3; // [esp+18h] [ebp-10h]
  unsigned __int8 *v4; // [esp+1Ch] [ebp-Ch]

  v3 = gettext(msgid);
  if ( v3 != msgid )
    return v3;
  v4 = (unsigned __int8 *)sub_804FD26();
  if ( sub_804F5A7(v4, "UTF-8") )
  {
    if ( sub_804F5A7(v4, "GB18030") )
    {
      if ( a2 == 9 )
        result = (const char *)&unk_80511D5;
      else
        result = "'";
    }
    else if ( *msgid == 96 )
    {
      result = (const char *)&unk_80511CE;
    }
    else
    {
      result = (const char *)&unk_80511D2;
    }
  }
  else
  {
    if ( *msgid == 96 )
    {
      dword_8055120 = (int)&loc_804C570;
      sub_805079E();
    }
    result = (const char *)&unk_80511C2;
  }
  return result;
}
// 805079E: using guessed type int sub_805079E(void);
// 8055120: using guessed type int dword_8055120;

//----- (0804C5B5) --------------------------------------------------------
#error "804CD85: call analysis failed (funcsize=817)"

//----- (0804D52E) --------------------------------------------------------
void *__cdecl sub_804D52E(int a1, int a2, _DWORD *a3, int *a4)
{
  int *v4; // eax
  int *v5; // ST3C_4
  int v6; // ST40_4
  int v7; // ST44_4
  int size; // [esp+48h] [ebp-10h]
  void *v10; // [esp+4Ch] [ebp-Ch]

  if ( a4 )
    v4 = a4;
  else
    v4 = &dword_80556A9;
  v5 = v4;
  v6 = *__errno_location();
  v7 = v5[1] | (a3 == 0);
  size = sub_804C5B5(0, 0, a1, a2, *v5, v7, v5 + 2, v5[10], v5[11]) + 1;
  v10 = sub_804E838(size);
  sub_804C5B5(v10, size, a1, a2, *v5, v7, v5 + 2, v5[10], v5[11]);
  *__errno_location() = v6;
  if ( a3 )
    *a3 = size - 1;
  return v10;
}
// 804C5B5: using guessed type _DWORD __cdecl sub_804C5B5(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80556A9: using guessed type int dword_80556A9;

//----- (0804D6F5) --------------------------------------------------------
#error "804D861: call analysis failed (funcsize=102)"

//----- (0804D866) --------------------------------------------------------
#error "804D970: positive sp value has been found (funcsize=74)"

//----- (0804D973) --------------------------------------------------------
int __usercall sub_804D973@<eax>(signed int a1@<ebx>, int a2, int a3)
{
  int v8; // [esp-4h] [ebp-1Ch]

  v8 = sub_804D6F5(a2, a3, -1, &dword_80556A9);
  __asm { pushfw }
  if ( a1 >= 10 && ((_BYTE)a1 - 1) * (_BYTE)a1 & 1 )
    abort();
  __asm { popfw }
  return v8;
}
// 804D6F5: using guessed type _DWORD __cdecl sub_804D6F5(_DWORD, _DWORD, _DWORD, _DWORD);
// 80556A9: using guessed type int dword_80556A9;

//----- (0804D9C2) --------------------------------------------------------
int __cdecl sub_804D9C2(int a1, int a2, int a3)
{
  return sub_804D6F5(a1, a2, a3, &dword_80556A9);
}
// 804D6F5: using guessed type _DWORD __cdecl sub_804D6F5(_DWORD, _DWORD, _DWORD, _DWORD);
// 80556A9: using guessed type int dword_80556A9;

//----- (0804DA55) --------------------------------------------------------
int __cdecl sub_804DA55(int a1, int a2, int a3)
{
  char v4; // [esp+10h] [ebp-38h]

  sub_804C460(&v4, a2);
  return sub_804D6F5(a1, a3, -1, &v4);
}
// 804D6F5: using guessed type _DWORD __cdecl sub_804D6F5(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804DA93) --------------------------------------------------------
int __usercall sub_804DA93@<eax>(signed int a1@<ebx>, int a2, int a3, int a4, int a5)
{
  char v10; // [esp+10h] [ebp-38h]

  sub_804C460(&v10, a3);
  __asm { pushfw }
  if ( a1 >= 10 && ((_BYTE)a1 - 1) * (_BYTE)a1 & 1 )
    abort();
  __asm { popfw }
  return sub_804D6F5(a2, a4, a5, &v10);
}
// 804D6F5: using guessed type _DWORD __cdecl sub_804D6F5(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804DB60) --------------------------------------------------------
int __cdecl sub_804DB60(int a1, int a2, unsigned __int8 a3)
{
  int v4; // [esp+0h] [ebp-58h]
  unsigned __int8 v5; // [esp+1Ch] [ebp-3Ch]
  int v6; // [esp+20h] [ebp-38h]
  int v7; // [esp+24h] [ebp-34h]
  int v8; // [esp+28h] [ebp-30h]
  int v9; // [esp+2Ch] [ebp-2Ch]
  int v10; // [esp+30h] [ebp-28h]
  int v11; // [esp+34h] [ebp-24h]
  int v12; // [esp+38h] [ebp-20h]
  int v13; // [esp+3Ch] [ebp-1Ch]
  int v14; // [esp+40h] [ebp-18h]
  int v15; // [esp+44h] [ebp-14h]
  int v16; // [esp+48h] [ebp-10h]
  int v17; // [esp+4Ch] [ebp-Ch]

  v5 = a3;
  v6 = dword_80556A9;
  v7 = dword_80556AD;
  v8 = dword_80556B1;
  v9 = dword_80556B5;
  v10 = dword_80556B9;
  v11 = dword_80556BD;
  v12 = dword_80556C1;
  v13 = dword_80556C5;
  v14 = dword_80556C9;
  v15 = dword_80556CD;
  v16 = dword_80556D1;
  v17 = dword_80556D5;
  sub_804C313(&v4 - 14, a3, 1);
  return sub_804D6F5(0, a1, a2, &v6);
}
// 804D6F5: using guessed type _DWORD __cdecl sub_804D6F5(_DWORD, _DWORD, _DWORD, _DWORD);
// 80556A9: using guessed type int dword_80556A9;
// 80556AD: using guessed type int dword_80556AD;
// 80556B1: using guessed type int dword_80556B1;
// 80556B5: using guessed type int dword_80556B5;
// 80556B9: using guessed type int dword_80556B9;
// 80556BD: using guessed type int dword_80556BD;
// 80556C1: using guessed type int dword_80556C1;
// 80556C5: using guessed type int dword_80556C5;
// 80556C9: using guessed type int dword_80556C9;
// 80556CD: using guessed type int dword_80556CD;
// 80556D1: using guessed type int dword_80556D1;
// 80556D5: using guessed type int dword_80556D5;

//----- (0804DC1A) --------------------------------------------------------
int __cdecl sub_804DC1A(int a1, unsigned __int8 a2)
{
  return sub_804DB60(a1, -1, a2);
}

//----- (0804DC53) --------------------------------------------------------
int __cdecl sub_804DC53(int a1)
{
  return sub_804DC1A(a1, 0x3Au);
}

//----- (0804DC90) --------------------------------------------------------
int __usercall sub_804DC90@<eax>(signed int a1@<ebx>, int a2, int a3, int a4)
{
  signed int v9; // [esp-Ah] [ebp-82h]
  int v10; // [esp-4h] [ebp-7Ch]
  int v11; // [esp+0h] [ebp-78h]
  int v12; // [esp+10h] [ebp-68h]
  int v13; // [esp+14h] [ebp-64h]
  int v14; // [esp+18h] [ebp-60h]
  int v15; // [esp+1Ch] [ebp-5Ch]
  int v16; // [esp+20h] [ebp-58h]
  int v17; // [esp+24h] [ebp-54h]
  int v18; // [esp+28h] [ebp-50h]
  int v19; // [esp+2Ch] [ebp-4Ch]
  int v20; // [esp+30h] [ebp-48h]
  int v21; // [esp+34h] [ebp-44h]
  int v22; // [esp+38h] [ebp-40h]
  int v23; // [esp+3Ch] [ebp-3Ch]
  int v24; // [esp+40h] [ebp-38h]
  int v25; // [esp+44h] [ebp-34h]
  int v26; // [esp+48h] [ebp-30h]
  int v27; // [esp+4Ch] [ebp-2Ch]
  int v28; // [esp+50h] [ebp-28h]
  int v29; // [esp+54h] [ebp-24h]
  int v30; // [esp+58h] [ebp-20h]
  int v31; // [esp+5Ch] [ebp-1Ch]
  int v32; // [esp+60h] [ebp-18h]
  int v33; // [esp+64h] [ebp-14h]
  int v34; // [esp+68h] [ebp-10h]
  int v35; // [esp+6Ch] [ebp-Ch]

  sub_804C460(&v12, a3);
  v24 = v12;
  v25 = v13;
  v26 = v14;
  v27 = v15;
  v28 = v16;
  v29 = v17;
  v30 = v18;
  v31 = v19;
  v32 = v20;
  v33 = v21;
  v34 = v22;
  v35 = v23;
  sub_804C313(&v11 - 14, 0x3Au, 1);
  v10 = sub_804D6F5(a2, a4, -1, &v24);
  __asm { pushfw }
  v9 = a1;
  if ( a1 >= 10 && ((_BYTE)a1 - 1) * (_BYTE)a1 & 1 )
    abort();
  __asm { popfw }
  return v10;
}
// 804D6F5: using guessed type _DWORD __cdecl sub_804D6F5(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804DD66) --------------------------------------------------------
int __usercall sub_804DD66@<eax>(signed int a1@<ebx>, int a2, int a3, int a4, int a5)
{
  return sub_804DDA6(a1, a2, a3, a4, a5, -1);
}

//----- (0804DDA6) --------------------------------------------------------
int __usercall sub_804DDA6@<eax>(signed int a1@<ebx>, int a2, int a3, int a4, int a5, int a6)
{
  char v6; // sf
  int v8; // [esp+0h] [ebp-48h]
  int v9; // [esp+10h] [ebp-38h]
  int v10; // [esp+14h] [ebp-34h]
  int v11; // [esp+18h] [ebp-30h]
  int v12; // [esp+1Ch] [ebp-2Ch]
  int v13; // [esp+20h] [ebp-28h]
  int v14; // [esp+24h] [ebp-24h]
  int v15; // [esp+28h] [ebp-20h]
  int v16; // [esp+2Ch] [ebp-1Ch]
  int v17; // [esp+30h] [ebp-18h]
  int v18; // [esp+34h] [ebp-14h]
  int v19; // [esp+38h] [ebp-10h]
  int v20; // [esp+3Ch] [ebp-Ch]

  v9 = dword_80556A9;
  v10 = dword_80556AD;
  v11 = dword_80556B1;
  v12 = dword_80556B5;
  v13 = dword_80556B9;
  v14 = dword_80556BD;
  v15 = dword_80556C1;
  v16 = dword_80556C5;
  v17 = dword_80556C9;
  v18 = dword_80556CD;
  v19 = dword_80556D1;
  v20 = dword_80556D5;
  sub_804C3CD(0, 0, v6, 0, (__int16 *)&v8 - 28, a1, &v8 - 14, a3, a4);
  return sub_804D6F5(a2, a5, a6, &v9);
}
// 804D6F5: using guessed type _DWORD __cdecl sub_804D6F5(_DWORD, _DWORD, _DWORD, _DWORD);
// 80556A9: using guessed type int dword_80556A9;
// 80556AD: using guessed type int dword_80556AD;
// 80556B1: using guessed type int dword_80556B1;
// 80556B5: using guessed type int dword_80556B5;
// 80556B9: using guessed type int dword_80556B9;
// 80556BD: using guessed type int dword_80556BD;
// 80556C1: using guessed type int dword_80556C1;
// 80556C5: using guessed type int dword_80556C5;
// 80556C9: using guessed type int dword_80556C9;
// 80556CD: using guessed type int dword_80556CD;
// 80556D1: using guessed type int dword_80556D1;
// 80556D5: using guessed type int dword_80556D5;

//----- (0804DED0) --------------------------------------------------------
int __cdecl sub_804DED0(int a1, int a2, int a3)
{
  return sub_804D6F5(a1, a2, a3, &unk_805522C);
}
// 804D6F5: using guessed type _DWORD __cdecl sub_804D6F5(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804DF2B) --------------------------------------------------------
int __cdecl sub_804DF2B(int a1, int a2)
{
  return sub_804DED0(a1, a2, -1);
}

//----- (0804DF4D) --------------------------------------------------------
int __cdecl sub_804DF4D(int a1)
{
  return sub_804DF2B(0, a1);
}

//----- (0804DF68) --------------------------------------------------------
#error "804E37C: call analysis failed (funcsize=413)"

//----- (0804E5FB) --------------------------------------------------------
int __cdecl sub_804E5FB(FILE *stream, int a2, int a3, int a4, int a5)
{
  int *v5; // eax
  int v11; // [esp-4h] [ebp-5Ch]
  int i; // [esp+24h] [ebp-34h]
  int v13[12]; // [esp+28h] [ebp-30h]

  for ( i = 0; (unsigned int)i <= 9; ++i )
  {
    v5 = (int *)a5;
    a5 += 4;
    v13[i] = *v5;
    if ( !v13[i] )
      break;
  }
  v11 = sub_804DF68(stream, a2, a3, a4, (int)v13, i);
  __asm { pushfw }
  if ( sub_804F63A() != -24 )
    sub_804F644();
  __asm { popfw }
  return v11;
}
// 804F644: using guessed type int sub_804F644(void);
// 804E5FB: using guessed type int var_30[12];

//----- (0804E68E) --------------------------------------------------------
int sub_804E68E(FILE *stream, int a2, int a3, int a4, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a4);
  return sub_804E5FB(stream, a2, a3, a4, (int)va);
}

//----- (0804E7A1) --------------------------------------------------------
void *__cdecl sub_804E7A1(void *ptr, int a2, int a3)
{
  unsigned int v4; // [esp+1Ch] [ebp-Ch]

  v4 = *(_DWORD *)a2;
  if ( ptr )
  {
    if ( 0x55555554u / a3 <= v4 )
      sub_804E9F2();
    v4 += (v4 >> 1) + 1;
  }
  else
  {
    if ( !v4 )
      v4 = (0x40u / a3 == 0) + 0x40u / a3;
    if ( 0x7FFFFFFFu / a3 < v4 )
      sub_804E9F2();
  }
  *(_DWORD *)a2 = v4;
  return sub_804E875(ptr, a3 * v4);
}

//----- (0804E838) --------------------------------------------------------
void *__cdecl sub_804E838(size_t size)
{
  return sub_804E84B(size);
}

//----- (0804E84B) --------------------------------------------------------
void *__cdecl sub_804E84B(size_t size)
{
  void *v2; // [esp+1Ch] [ebp-Ch]

  v2 = malloc(size);
  if ( !v2 && size )
    sub_804E9F2();
  return v2;
}

//----- (0804E875) --------------------------------------------------------
void *__cdecl sub_804E875(void *ptr, size_t size)
{
  void *ptra; // [esp+20h] [ebp+8h]

  if ( !size && ptr )
  {
    free(ptr);
    dword_8055120 = (int)&locret_804E8D7;
    sub_805079E();
  }
  ptra = realloc(ptr, size);
  if ( !ptra && size )
    sub_804E9F2();
  return ptra;
}
// 805079E: using guessed type int sub_805079E(void);
// 8055120: using guessed type int dword_8055120;

//----- (0804E97F) --------------------------------------------------------
void *__cdecl sub_804E97F(void *src, size_t n)
{
  void *v2; // eax

  v2 = sub_804E84B(n);
  return memcpy(v2, src, n);
}

//----- (0804E9F2) --------------------------------------------------------
void __noreturn sub_804E9F2()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (0804EA2B) --------------------------------------------------------
void sub_804EA2B()
{
  ;
}

//----- (0804EA30) --------------------------------------------------------
void __usercall sub_804EA30(signed int a1@<ebx>)
{
  int v5; // [esp-4h] [ebp-1Ch]

  v5 = sub_804F574();
  __asm { pushfw }
  if ( a1 >= 10 && ((_BYTE)a1 - 1) * (_BYTE)a1 & 1 )
    abort();
  __asm { popfw }
  if ( v5 < 0 )
    sub_804EA2B();
}

//----- (0804EA78) --------------------------------------------------------
#error "804EABD: call analysis failed (funcsize=25)"

//----- (0804EAC2) --------------------------------------------------------
#error "804EC06: positive sp value has been found (funcsize=93)"

//----- (0804EC09) --------------------------------------------------------
int __cdecl sub_804EC09(int a1, int a2, int a3, int a4, int a5, int a6)
{
  return sub_804EA78(a1, 10, a2, a3, a4, a5, a6);
}
// 804EA78: using guessed type _DWORD __cdecl sub_804EA78(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804EC7D) --------------------------------------------------------
signed int __cdecl sub_804EC7D(unsigned int *a1, signed int a2)
{
  signed __int64 v2; // rcx
  unsigned int v3; // edx
  unsigned int v4; // eax
  signed int result; // eax
  unsigned int v10; // [esp-4h] [ebp-2Ch]

  v2 = sub_805003E(0xFFFFFFFFFFFFFFFFLL, a2, a2 >> 31);
  v3 = a1[1];
  v4 = *a1;
  if ( HIDWORD(v2) > v3 )
    goto LABEL_10;
  _CF = HIDWORD(v2) < v3;
  _OF = __OFSUB__(HIDWORD(v2), v3);
  _ZF = HIDWORD(v2) == v3;
  _SF = (signed int)(HIDWORD(v2) - v3) < 0;
  if ( HIDWORD(v2) < v3 )
    goto LABEL_11;
  _CF = (unsigned int)v2 < v4;
  _OF = __OFSUB__((_DWORD)v2, v4);
  _ZF = (_DWORD)v2 == v4;
  _SF = (signed int)(v2 - v4) < 0;
  if ( (unsigned int)v2 >= v4 )
  {
LABEL_10:
    *(_QWORD *)a1 *= a2;
    result = 0;
  }
  else
  {
LABEL_11:
    v10 = *a1;
    __asm { pushfw }
    if ( sub_804F63A() != -24 )
      sub_804F644();
    __asm { popfw }
    *a1 = -1;
    a1[1] = -1;
    result = 1;
  }
  return result;
}
// 804F644: using guessed type int sub_804F644(void);

//----- (0804ED46) --------------------------------------------------------
int __cdecl sub_804ED46(unsigned int *a1, signed int a2, int a3)
{
  signed int v3; // eax
  int v4; // eax
  int v6; // [esp+1Ch] [ebp-Ch]

  v6 = 0;
  dword_8055198 = (int)&loc_804ED7F;
  sub_80504B4();
  do
  {
    v3 = sub_804EC7D(a1, a2);
    v6 |= v3;
    v4 = a3--;
  }
  while ( v4 );
  return v6;
}
// 80504B4: using guessed type int sub_80504B4(void);
// 8055198: using guessed type int dword_8055198;

//----- (0804ED91) --------------------------------------------------------
#error "804EDBE: call analysis failed (funcsize=327)"

//----- (0804F26D) --------------------------------------------------------
int __cdecl sub_804F26D(FILE *stream)
{
  int v2; // eax
  __int64 v3; // rax
  int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]

  v4 = 0;
  if ( fileno(stream) < 0 )
    return fclose(stream);
  if ( !__freading(stream) || (v2 = fileno(stream), LODWORD(v3) = lseek64(v2, 0, 0, 1), v3 != -1) )
  {
    if ( sub_804F369((int)stream, stream) )
      v4 = *__errno_location();
  }
  v5 = fclose(stream);
  if ( v4 )
  {
    *__errno_location() = v4;
    v5 = -1;
  }
  return v5;
}
// 8049050: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804F330) --------------------------------------------------------
int __cdecl sub_804F330(FILE *stream)
{
  int result; // eax

  result = stream->_flags & 0x100;
  if ( result )
    result = sub_804F3C6(stream, 0, 0, 1);
  return result;
}

//----- (0804F369) --------------------------------------------------------
int __usercall sub_804F369@<eax>(int a1@<eax>, FILE *fp)
{
  int result; // eax
  int v7; // [esp-4h] [ebp-1Ch]

  _CF = 0;
  _OF = 0;
  _ZF = fp == 0;
  _SF = (signed int)fp < 0;
  if ( fp && (a1 = __freading(fp), _CF = 0, _OF = 0, _ZF = a1 == 0, _SF = a1 < 0, a1) )
  {
    sub_804F330(fp);
    result = fflush(fp);
  }
  else
  {
    v7 = a1;
    __asm { pushfw }
    if ( sub_804F63A() != -24 )
      sub_804F644();
    __asm { popfw }
    result = fflush(fp);
  }
  return result;
}
// 804F644: using guessed type int sub_804F644(void);

//----- (0804F3C6) --------------------------------------------------------
#error "804F4AA: call analysis failed (funcsize=82)"

//----- (0804F4D5) --------------------------------------------------------
#error "804F4F5: call analysis failed (funcsize=45)"

//----- (0804F560) --------------------------------------------------------
int sub_804F560()
{
  return 0;
}

//----- (0804F56A) --------------------------------------------------------
int sub_804F56A()
{
  return 0;
}

//----- (0804F574) --------------------------------------------------------
int sub_804F574()
{
  int result; // eax
  int v1; // [esp+14h] [ebp-4h]

  v1 = sub_804F56A();
  if ( v1 )
    result = v1;
  else
    result = sub_804F560();
  return result;
}

//----- (0804F5A7) --------------------------------------------------------
#error "804F5CD: call analysis failed (funcsize=51)"

//----- (0804F63A) --------------------------------------------------------
signed int sub_804F63A()
{
  return -24;
}

//----- (0804F645) --------------------------------------------------------
#error "804F6C1: call analysis failed (funcsize=62)"

//----- (0804F6FC) --------------------------------------------------------
int __cdecl sub_804F6FC(int category)
{
  unsigned __int8 v2; // [esp+1Bh] [ebp-Dh]
  const char *s1; // [esp+1Ch] [ebp-Ch]

  v2 = 1;
  s1 = setlocale(category, 0);
  if ( s1 && (!strcmp(s1, "C") || !strcmp(s1, "POSIX")) )
    v2 = 0;
  return v2;
}

//----- (0804F75A) --------------------------------------------------------
#error "804F8ED: call analysis failed (funcsize=294)"

//----- (0804FD1D) --------------------------------------------------------
#error "804FD23: positive sp value has been found (funcsize=0)"

//----- (0804FD26) --------------------------------------------------------
const char *sub_804FD26()
{
  void *v0; // eax
  char *v1; // ST24_4
  const char *s1; // [esp+18h] [ebp-10h]
  char *s2; // [esp+1Ch] [ebp-Ch]

  s1 = nl_langinfo(14);
  if ( !s1 )
    s1 = (const char *)&unk_8051AD7;
  for ( s2 = (char *)sub_804F75A(); *s2; s2 = &v1[strlen(v1) + 1] )
  {
    if ( !strcmp(s1, s2) )
      goto LABEL_9;
    if ( *s2 == 42 )
    {
      v0 = &loc_804FD9B;
      if ( s2[1] )
        v0 = &loc_804FDB3;
      dword_8055184 = (int)v0;
      sub_805052E();
LABEL_9:
      s1 = &s2[strlen(s2) + 1];
      break;
    }
    v1 = &s2[strlen(s2) + 1];
  }
  if ( !*s1 )
    s1 = "ASCII";
  return s1;
}
// 804F75A: using guessed type int sub_804F75A(void);
// 805052E: using guessed type int sub_805052E(void);
// 8055184: using guessed type int dword_8055184;

//----- (08050006) --------------------------------------------------------
int __cdecl sub_8050006(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 65) > 0x19 )
    result = a1;
  else
    result = a1 + 32;
  return result;
}

//----- (0805003E) --------------------------------------------------------
signed __int64 __cdecl sub_805003E(unsigned __int64 a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // esi
  signed __int64 result; // rax
  int v5; // ebp
  int v6; // ebp
  unsigned __int64 v7; // rdi
  unsigned int v8; // eax
  unsigned int v9; // esi
  unsigned int v10; // edi
  unsigned __int64 v11; // rax
  void *v12; // eax
  unsigned int v13; // [esp+0h] [ebp-18h]
  unsigned int v14; // [esp+4h] [ebp-14h]
  unsigned int v15; // [esp+8h] [ebp-10h]

  v14 = a1;
  v13 = a2;
  if ( !a3 )
  {
    if ( a2 > HIDWORD(a1) )
      return (unsigned int)(a1 / a2);
    v3 = a2;
    if ( !a2 )
      v3 = 1 / 0u;
    LODWORD(result) = __PAIR__(HIDWORD(a1) % v3, (unsigned int)a1) / v3;
    HIDWORD(result) = HIDWORD(a1) / v3;
    return result;
  }
  if ( a3 > HIDWORD(a1) )
    return 0LL;
  _BitScanReverse((unsigned int *)&v5, a3);
  v6 = v5 ^ 0x1F;
  if ( !v6 )
  {
    if ( v13 <= v14 || a3 < HIDWORD(a1) )
      return 1LL;
    return 0LL;
  }
  v15 = (a3 << v6) | (v13 >> (32 - v6));
  v13 <<= v6;
  HIDWORD(v7) = HIDWORD(a1) >> (32 - v6);
  LODWORD(v7) = (HIDWORD(a1) << (char)&v13) | (v14 >> (32 - v6));
  v8 = v7 / v15;
  v9 = v7 % v15;
  v10 = v8;
  v11 = v13 * (unsigned __int64)v8;
  v13 = HIDWORD(v11);
  if ( v9 < HIDWORD(v11) )
    return v10 - 1;
  if ( v14 << (char)&v13 < (unsigned int)v11 )
  {
    v12 = &loc_8050178;
    if ( v9 == v13 )
      v12 = &loc_8050192;
    dword_8055148 = (int)v12;
    sub_805069D(v13);
  }
  return v10;
}
// 805069D: using guessed type int __stdcall sub_805069D(_DWORD);
// 8055148: using guessed type int dword_8055148;

//----- (080501EE) --------------------------------------------------------
#error "8050227: positive sp value has been found (funcsize=18)"

//----- (0805023D) --------------------------------------------------------
int __cdecl sub_805023D(int a1)
{
  return __cxa_atexit(a1, 0, dword_80551F0);
}
// 8048EB0: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 80551F0: using guessed type int dword_80551F0;

//----- (080502C9) --------------------------------------------------------
#error "8050302: positive sp value has been found (funcsize=18)"

//----- (080503CA) --------------------------------------------------------
#error "80503D0: positive sp value has been found (funcsize=0)"

//----- (08050442) --------------------------------------------------------
#error "8050448: positive sp value has been found (funcsize=0)"

//----- (080504B4) --------------------------------------------------------
#error "80504BA: positive sp value has been found (funcsize=0)"

//----- (0805052E) --------------------------------------------------------
#error "8050534: positive sp value has been found (funcsize=0)"

//----- (08050580) --------------------------------------------------------
#error "80505B9: positive sp value has been found (funcsize=18)"

//----- (080505C1) --------------------------------------------------------
#error "80505C7: positive sp value has been found (funcsize=0)"

//----- (08050631) --------------------------------------------------------
#error "8050637: positive sp value has been found (funcsize=0)"

//----- (0805069D) --------------------------------------------------------
#error "80506A3: positive sp value has been found (funcsize=0)"

//----- (080506E3) --------------------------------------------------------
#error "805071C: positive sp value has been found (funcsize=18)"

//----- (08050724) --------------------------------------------------------
#error "805072A: positive sp value has been found (funcsize=0)"

//----- (0805079E) --------------------------------------------------------
#error "80507A4: positive sp value has been found (funcsize=0)"

//----- (08050814) --------------------------------------------------------
#error "805081A: positive sp value has been found (funcsize=0)"

//----- (08050830) --------------------------------------------------------
int (**sub_8050830())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_8054ED4;
  v1 = &off_8054ED8 - off_8054ED4;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_8054ED4[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 8054ED4: using guessed type int (*off_8054ED4[2])();
// 8054ED8: using guessed type int (*off_8054ED8)();

//----- (08050894) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 36 decompilation failure(s) on 146 function(s)"
