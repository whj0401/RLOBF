/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8048D10();
// int strcmp(const char *s1, const char *s2);
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void _exit(int status);
// void free(void *ptr);
// void *memcpy(void *dest, const void *src, size_t n);
// int fclose(FILE *stream);
// int __stdcall fseeko64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// int fputc_unlocked(int c, FILE *stream);
// char *textdomain(const char *domainname);
// int __cdecl fopen64(_DWORD, _DWORD); weak
// int ferror_unlocked(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// size_t __ctype_get_mb_cur_max(void);
// size_t __fpending(FILE *fp);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// void error(int status, int errnum, const char *format, ...);
// size_t fread_unlocked(void *ptr, size_t size, size_t n, FILE *stream);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// size_t strlen(const char *s);
// int fprintf(FILE *stream, const char *format, ...);
// void *memset(void *s, int c, size_t n);
// int *__errno_location(void);
// void *memchr(const void *s, int c, size_t n);
// int fileno(FILE *stream);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// char *strrchr(const char *s, int c);
// int __stdcall lseek64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// char *bindtextdomain(const char *domainname, const char *dirname);
// int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// int feof_unlocked(FILE *stream);
// void abort(void);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// int _gmon_start__(void); weak
void sub_8049133();
void sub_8049150();
int sub_8049160();
int sub_80491D0();
int sub_80491F0();
void sub_804924F();
void sub_804926A();
int sub_804927A();
void sub_804935C();
void sub_8049377();
int sub_8049387();
void sub_8049469();
void sub_8049484();
signed int sub_8049494();
signed int sub_804951E();
void sub_8049592();
void sub_80495AD();
int sub_80495BD();
void sub_80496CD();
void sub_80496E8();
int sub_80496F8();
void sub_80497DA();
void sub_80497F5();
int sub_8049805();
int nullsub_3(void); // weak
int sub_8049863();
void sub_8049915();
void sub_8049930();
int sub_8049940();
void sub_8049A34();
void sub_8049A4F();
int sub_8049A5F();
int sub_8049AE9();
void sub_8049B5D();
void sub_8049B78();
int sub_8049B88();
void sub_8049C83();
void sub_8049C9E();
int sub_8049CAE();
// int __usercall sub_8049D15@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
void sub_8049DAC();
void sub_8049DC7();
int sub_8049DD7();
void sub_8049ED5();
void sub_8049EF0();
int sub_8049F00();
int nullsub_5(void); // weak
int sub_8049F5E();
int sub_8049FA3();
void sub_804A017();
void sub_804A032();
int sub_804A042();
void sub_804A124();
void sub_804A13F();
int sub_804A14F();
int nullsub_6(void); // weak
int sub_804A1AD();
void sub_804A25F();
void sub_804A27A();
int sub_804A28A();
void sub_804A388();
void sub_804A3A3();
// int __usercall sub_804A3B3@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>);
// int __usercall sub_804A439@<eax>(int a1@<eax>, int (__cdecl *a2)(void **, int)@<edx>);
// int __usercall sub_804A475@<eax>(int a1@<eax>);
void sub_804A527();
void sub_804A542();
int sub_804A552();
int nullsub_8(void); // weak
int sub_804A5B0();
int sub_804A61E();
int sub_804A649();
// int __usercall sub_804A674@<eax>(int a1@<ebx>, char *s1);
void __cdecl __noreturn sub_804A85B(int status); // idb
size_t __cdecl sub_804A95A(void *ptr, size_t n, int a3, int a4, int a5, FILE *stream);
// unsigned int __usercall sub_804AB2F@<eax>(int a1@<ebx>, FILE *a2, FILE *a3, __int64 a4);
// unsigned int __usercall sub_804ADD8@<eax>(char *a1@<ebx>, FILE *a2, FILE *a3, char a4);
// int __usercall main@<eax>(char *a1@<ebx>, int argc, char **argv);
int __cdecl sub_804B58C(unsigned __int8 a1);
// int __usercall sub_804B59E@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, int a6, int a7, _BYTE *a8, int a9);
// char __usercall sub_804BABC@<al>(signed int a1@<ebx>, unsigned __int8 a2);
_DWORD *__cdecl sub_804BB23(_DWORD *a1);
void *__cdecl sub_804BB31(_DWORD *a1, void **a2, unsigned int a3, _DWORD *a4);
// int __usercall sub_804BC4C@<eax>(signed int a1@<ebx>, unsigned __int8 *a2, unsigned int a3, int *a4);
// bool __usercall sub_804C242@<al>(signed int a1@<ebx>, int *a2, unsigned __int8 *a3, unsigned int a4, int a5, int *a6);
int sub_804C572();
int __cdecl sub_804C656(int a1, int a2, int a3, int a4, int a5, int a6);
void __cdecl sub_804C6B7(FILE *stream, int a2);
char *__cdecl sub_804C6FF(char *s);
_DWORD __cdecl sub_804C8AB(_DWORD, _DWORD, _DWORD); // weak
int *__cdecl sub_804C97A(int *a1, int a2, int a3);
// unsigned int *__userpurge sub_804C9BB@<eax>(unsigned int *a1, unsigned int a2);
const char *__cdecl sub_804CA7C(char *msgid, int a2);
_DWORD __cdecl sub_804CB9C(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
void *__cdecl sub_804DBDD(int a1, int a2, _DWORD *a3, _DWORD *a4);
void *__cdecl sub_804DDEB(signed int a1, int a2, int a3, _DWORD *a4);
void *__cdecl sub_804E069(signed int a1, int a2);
void *__cdecl sub_804E0B5(int a1, signed int a2, int a3, int a4);
void *__cdecl sub_804E14D(signed int a1, unsigned int a2, int a3);
void *__cdecl sub_804E18B(signed int a1, unsigned int a2, int a3, int a4);
void *__cdecl sub_804E261(int a1, int a2, char a3);
void *__cdecl sub_804E31B(int a1, char a2);
void *__cdecl sub_804E354(int a1);
_DWORD __cdecl sub_804E391(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_804E490(int a1, int a2, int a3, int a4);
int __cdecl sub_804E4D0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
void *__cdecl sub_804E60F(signed int a1, int a2, int a3);
void *__cdecl sub_804E66A(signed int a1, int a2);
// void *__usercall sub_804E68C@<eax>(signed int a1@<ebx>, int a2);
int __cdecl sub_804E6CC(FILE *stream, int, int, int, int, int); // idb
int __cdecl sub_804EDAB(FILE *stream, int, int, int, int); // idb
int sub_804EE21(FILE *stream, int a2, int a3, int a4, ...);
void *__cdecl sub_804EF34(void *ptr, int a2, int a3);
// void *__usercall sub_804EFCB@<eax>(signed int a1@<ebx>, size_t size);
void *__cdecl sub_804F01C(size_t size);
void *__cdecl sub_804F05F(void *ptr, size_t size);
void *__cdecl sub_804F150(void *src, size_t n);
void __noreturn sub_804F19E();
void sub_804F1D7();
// void __usercall sub_804F1DC(signed int a1@<ebx>, int a2);
// unsigned __int64 __usercall sub_804F1FF@<edx:eax>(signed int a1@<ebx>, char *nptr, int base, int a4, int a5, int a6, int a7, char *s, int a9, int status);
// unsigned __int64 __usercall sub_804F37B@<edx:eax>(signed int a1@<ebx>, char *nptr, int a3, int a4, int a5, int a6, char *s, int a8, int status);
_DWORD __cdecl sub_804F3EF(_DWORD, _DWORD); // weak
int __cdecl sub_804F4C5(int a1, int a2, int a3);
int __cdecl sub_804F4FB(char *nptr, int a2, int base);
int __cdecl sub_804F9FB(FILE *stream); // idb
// int __usercall sub_804FB0E@<eax>(signed int a1@<ebx>, unsigned int *a2);
// int __usercall sub_804FB60@<eax>(signed int a1@<ebx>, FILE *fp);
// int __usercall sub_804FBA0@<eax>(char _CF@<cf>, bool _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>, unsigned int *a7, int a8, int a9);
size_t __cdecl sub_804FD19(wchar_t *pwc, char *s, size_t n, mbstate_t *p);
int sub_804FDB9();
// int __usercall sub_804FDC3@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>);
// int __usercall sub_804FDF2@<eax>(signed int a1@<ebx>, int a2);
int __cdecl sub_804FE25(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_804FE8A(FILE *fp); // idb
int __cdecl sub_804FF24(int category); // idb
int sub_804FF82(void); // weak
const char *sub_805050D();
signed int sub_805065D();
int sub_8050667(void); // weak
int __cdecl sub_805081F(int a1);
int __cdecl sub_8050857(unsigned __int64 a1, unsigned int a2, unsigned int a3);
int __cdecl sub_8050A3D(int a1);
int __stdcall sub_8050BC1(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int sub_8050C37(void); // weak
int sub_8050CAB(void); // weak
int sub_8050D51(void); // weak
int sub_8050DC7(void); // weak
int __stdcall sub_8050E3D(_DWORD, _DWORD); // weak
int __stdcall sub_8050EAF(_DWORD, _DWORD); // weak
int __stdcall sub_8050F21(_DWORD); // weak
int __stdcall sub_8050F8D(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_8050FFB(_DWORD, _DWORD); // weak
int sub_805106F(void); // weak
int sub_80510E5(void); // weak
int sub_8051151(void); // weak
int __fastcall sub_80511C9(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (**sub_80511E0())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN locret_8049B97; // weak
_UNKNOWN loc_804A721; // weak
_UNKNOWN loc_804A739; // weak
_UNKNOWN loc_804A7E4; // weak
_UNKNOWN loc_804A7FF; // weak
_UNKNOWN loc_804AB82; // weak
_UNKNOWN loc_804AD23; // weak
_UNKNOWN loc_804AEF1; // weak
_UNKNOWN loc_804AEFA; // weak
_UNKNOWN loc_804B10E; // weak
_UNKNOWN loc_804B302; // weak
_UNKNOWN loc_804B30E; // weak
_UNKNOWN loc_804B5CA; // weak
_UNKNOWN loc_804BA16; // weak
_UNKNOWN loc_804BAF6; // weak
_UNKNOWN loc_804BB0E; // weak
_UNKNOWN loc_804BBA4; // weak
_UNKNOWN loc_804BBC2; // weak
_UNKNOWN loc_804BC32; // weak
_UNKNOWN loc_804BCB8; // weak
_UNKNOWN loc_804BCC2; // weak
_UNKNOWN loc_804C294; // weak
_UNKNOWN loc_804C2A7; // weak
_UNKNOWN loc_804C33C; // weak
_UNKNOWN loc_804C341; // weak
_UNKNOWN loc_804C361; // weak
_UNKNOWN loc_804C388; // weak
_UNKNOWN loc_804C76A; // weak
_UNKNOWN loc_804C787; // weak
_UNKNOWN loc_804C78A; // weak
_UNKNOWN loc_804C7F0; // weak
_UNKNOWN loc_804C826; // weak
_UNKNOWN loc_804CAB1; // weak
_UNKNOWN loc_804CACB; // weak
_UNKNOWN loc_804CB15; // weak
_UNKNOWN loc_804CB5C; // weak
_UNKNOWN locret_804CB9A; // weak
_UNKNOWN loc_804DC03; // weak
_UNKNOWN loc_804DC08; // weak
_UNKNOWN loc_804DE32; // weak
_UNKNOWN loc_804DEF1; // weak
_UNKNOWN loc_804F011; // weak
_UNKNOWN loc_804F016; // weak
_UNKNOWN loc_804F04F; // weak
_UNKNOWN loc_804F05A; // weak
_UNKNOWN loc_804F084; // weak
_UNKNOWN loc_804F09C; // weak
_UNKNOWN loc_804F2FA; // weak
_UNKNOWN loc_804F319; // weak
_UNKNOWN loc_804F36F; // weak
_UNKNOWN loc_804F555; // weak
_UNKNOWN loc_804F57C; // weak
_UNKNOWN loc_804F5C0; // weak
_UNKNOWN loc_804F5DF; // weak
_UNKNOWN loc_804F5E9; // weak
_UNKNOWN loc_804FB3B; // weak
_UNKNOWN locret_804FB5E; // weak
_UNKNOWN loc_804FBD5; // weak
_UNKNOWN loc_804FBDA; // weak
_UNKNOWN loc_804FCB9; // weak
_UNKNOWN loc_804FCBE; // weak
_UNKNOWN loc_804FD86; // weak
_UNKNOWN loc_804FDB4; // weak
_UNKNOWN locret_804FDB7; // weak
_UNKNOWN loc_804FEE8; // weak
_UNKNOWN loc_804FF00; // weak
char s = '\0'; // idb
struct option longopts = { "decode", 0, NULL, 100 }; // idb
char byte_8051940[256] =
{
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\x1A',
  '\x1B',
  '\x1C',
  '\x1D',
  '\x1E',
  '\x1F',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\x01',
  '\x02',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\n',
  '\v',
  '\f',
  '\r',
  '\x0E',
  '\x0F',
  '\x10',
  '\x11',
  '\x12',
  '\x13',
  '\x14',
  '\x15',
  '\x16',
  '\x17',
  '\x18',
  '\x19',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF'
}; // idb
_UNKNOWN unk_8051B92; // weak
void *off_8052364[54] =
{
  &loc_804F7EB,
  &loc_804F99D,
  &loc_804F99D,
  &loc_804F824,
  &loc_804F99D,
  &loc_804F858,
  &loc_804F99D,
  &loc_804F99D,
  &loc_804F99D,
  &loc_804F88C,
  &loc_804F99D,
  &loc_804F8C0,
  &loc_804F99D,
  &loc_804F99D,
  &loc_804F8F4,
  &loc_804F99D,
  &loc_804F99D,
  &loc_804F99D,
  &loc_804F928,
  &loc_804F99D,
  &loc_804F99D,
  &loc_804F99D,
  &loc_804F99D,
  &loc_804F95F,
  &loc_804F97E,
  &loc_804F99D,
  &loc_804F99D,
  &loc_804F99D,
  &loc_804F99D,
  &loc_804F99D,
  &loc_804F99D,
  &loc_804F99D,
  &loc_804F7D0,
  &loc_804F818,
  &loc_804F99D,
  &loc_804F99D,
  &loc_804F99D,
  &loc_804F858,
  &loc_804F99D,
  &loc_804F99D,
  &loc_804F99D,
  &loc_804F88C,
  &loc_804F99D,
  &loc_804F8C0,
  &loc_804F99D,
  &loc_804F99D,
  &loc_804F99D,
  &loc_804F99D,
  &loc_804F99D,
  &loc_804F99D,
  &loc_804F928,
  &loc_804F99D,
  &loc_804F99D,
  &loc_804F947
}; // weak
_UNKNOWN unk_80524A7; // weak
_UNKNOWN unk_80531BC; // weak
_UNKNOWN unk_80531BF; // weak
int (*off_8055EC4[2])() = { &sub_80491F0, &sub_80491D0 }; // weak
int (*off_8055EC8)() = &sub_80491D0; // weak
int (*dword_8056008)(void) = NULL; // weak
int dword_805610C = 0; // weak
int dword_8056134 = 0; // weak
int dword_8056148 = 0; // weak
int dword_805615C = 0; // weak
int dword_8056170 = 0; // weak
int dword_8056184 = 0; // weak
int dword_8056198 = 0; // weak
int dword_80561AC = 0; // weak
int dword_80561C0 = 0; // weak
int dword_80561D4 = 0; // weak
int dword_80561E8 = 0; // weak
int dword_80561FC = 0; // weak
int dword_8056210 = 0; // weak
int dword_8056240 = 0; // weak
int off_8056244 = 134551863; // idb
int status = 1; // idb
int dword_805625C = 1; // weak
int dword_8056260 = 256; // weak
void *off_8056264 = &unk_805687D; // weak
int *off_8056268 = &dword_8056260; // weak
_UNKNOWN unk_805627C; // weak
_UNKNOWN unk_8056298; // weak
_UNKNOWN unk_805629B; // weak
_UNKNOWN unk_80562A0; // weak
_UNKNOWN unk_80562A3; // weak
_UNKNOWN unk_80562AC; // weak
_UNKNOWN unk_80562AF; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int program_invocation_name; // weak
int optind; // weak
int stdin; // weak
FILE *stdout; // idb
char *optarg; // idb
char byte_805630C; // weak
char byte_80563F3; // weak
_UNKNOWN unk_80564DE; // weak
char byte_8056574; // weak
char byte_80566A8; // weak
char byte_80567DC; // weak
int dword_805682D; // weak
char byte_8056831; // weak
int dword_8056835; // weak
int dword_805683D; // weak
int dword_8056841; // weak
int dword_8056845; // weak
int dword_8056849; // weak
int dword_805684D; // weak
int dword_8056851; // weak
int dword_8056855; // weak
int dword_8056859; // weak
int dword_805685D; // weak
int dword_8056861; // weak
int dword_8056865; // weak
int dword_8056869; // weak
_UNKNOWN unk_805687D; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (08048CE0) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 80490F0: using guessed type int _gmon_start__(void);

//----- (08048D10) --------------------------------------------------------
int sub_8048D10()
{
  return dword_8056008();
}
// 8056008: using guessed type int (*dword_8056008)(void);

//----- (08049100) --------------------------------------------------------
#error "8049103: positive sp value has been found (funcsize=2)"

//----- (08049133) --------------------------------------------------------
void sub_8049133()
{
  ;
}

//----- (08049150) --------------------------------------------------------
void sub_8049150()
{
  ;
}

//----- (08049160) --------------------------------------------------------
int sub_8049160()
{
  int result; // eax

  result = &unk_80562AF - &unk_80562AC;
  if ( (unsigned int)(&unk_80562AF - &unk_80562AC) > 6 )
    result = 0;
  return result;
}
// 8049160: could not find valid save-restore pair for ebp

//----- (080491D0) --------------------------------------------------------
int sub_80491D0()
{
  int result; // eax

  if ( !byte_805630C )
  {
    result = sub_8049160();
    byte_805630C = 1;
  }
  return result;
}
// 80491D0: could not find valid save-restore pair for ebp
// 805630C: using guessed type char byte_805630C;

//----- (080491F0) --------------------------------------------------------
int sub_80491F0()
{
  return 0;
}
// 80491F0: could not find valid save-restore pair for ebp

//----- (0804924F) --------------------------------------------------------
void sub_804924F()
{
  ;
}

//----- (0804926A) --------------------------------------------------------
void sub_804926A()
{
  ;
}

//----- (0804927A) --------------------------------------------------------
int sub_804927A()
{
  int result; // eax

  result = &unk_805629B - &unk_8056298;
  if ( (unsigned int)(&unk_805629B - &unk_8056298) > 6 )
    result = 0;
  return result;
}
// 804927A: could not find valid save-restore pair for ebp

//----- (0804935C) --------------------------------------------------------
void sub_804935C()
{
  ;
}

//----- (08049377) --------------------------------------------------------
void sub_8049377()
{
  ;
}

//----- (08049387) --------------------------------------------------------
int sub_8049387()
{
  int result; // eax

  result = &unk_805629B - &unk_8056298;
  if ( (unsigned int)(&unk_805629B - &unk_8056298) > 6 )
    result = 0;
  return result;
}
// 8049387: could not find valid save-restore pair for ebp

//----- (08049469) --------------------------------------------------------
void sub_8049469()
{
  ;
}

//----- (08049484) --------------------------------------------------------
void sub_8049484()
{
  ;
}

//----- (08049494) --------------------------------------------------------
signed int sub_8049494()
{
  return 3;
}
// 8049494: could not find valid save-restore pair for ebp

//----- (0804951E) --------------------------------------------------------
signed int sub_804951E()
{
  signed int result; // eax

  result = sub_8049494();
  byte_80563F3 = 1;
  return result;
}
// 80563F3: using guessed type char byte_80563F3;

//----- (08049592) --------------------------------------------------------
void sub_8049592()
{
  ;
}

//----- (080495AD) --------------------------------------------------------
void sub_80495AD()
{
  ;
}

//----- (080495BD) --------------------------------------------------------
int sub_80495BD()
{
  int result; // eax

  result = &unk_805629B - &unk_8056298;
  if ( (unsigned int)(&unk_805629B - &unk_8056298) > 6 )
    result = 0;
  return result;
}
// 80495BD: could not find valid save-restore pair for ebp

//----- (0804966F) --------------------------------------------------------
#error "804968D: call analysis failed (funcsize=33)"

//----- (080496CD) --------------------------------------------------------
void sub_80496CD()
{
  ;
}

//----- (080496E8) --------------------------------------------------------
void sub_80496E8()
{
  ;
}

//----- (080496F8) --------------------------------------------------------
int sub_80496F8()
{
  int result; // eax

  result = &unk_805629B - &unk_8056298;
  if ( (unsigned int)(&unk_805629B - &unk_8056298) > 6 )
    result = 0;
  return result;
}
// 80496F8: could not find valid save-restore pair for ebp

//----- (080497DA) --------------------------------------------------------
void sub_80497DA()
{
  ;
}

//----- (080497F5) --------------------------------------------------------
void sub_80497F5()
{
  ;
}

//----- (08049805) --------------------------------------------------------
int sub_8049805()
{
  int result; // eax

  result = &unk_805629B - &unk_8056298;
  if ( (unsigned int)(&unk_805629B - &unk_8056298) > 6 )
    result = 0;
  return result;
}
// 8049805: could not find valid save-restore pair for ebp

//----- (08049863) --------------------------------------------------------
int sub_8049863()
{
  return nullsub_3();
}
// 8049863: could not find valid save-restore pair for ebp
// 8049862: using guessed type int nullsub_3(void);

//----- (08049915) --------------------------------------------------------
void sub_8049915()
{
  ;
}

//----- (08049930) --------------------------------------------------------
void sub_8049930()
{
  ;
}

//----- (08049940) --------------------------------------------------------
int sub_8049940()
{
  int result; // eax

  result = &unk_80564DE - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_80564DE - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 8049940: could not find valid save-restore pair for ebp
// 80562C0: using guessed type int program_invocation_short_name;

//----- (08049A34) --------------------------------------------------------
void sub_8049A34()
{
  ;
}

//----- (08049A4F) --------------------------------------------------------
void sub_8049A4F()
{
  ;
}

//----- (08049A5F) --------------------------------------------------------
int sub_8049A5F()
{
  int result; // eax

  result = &unk_805629B - &unk_8056298;
  if ( (unsigned int)(&unk_805629B - &unk_8056298) > 6 )
    result = 0;
  return result;
}
// 8049A5F: could not find valid save-restore pair for ebp

//----- (08049AE9) --------------------------------------------------------
int sub_8049AE9()
{
  int result; // eax

  result = sub_8049A5F();
  byte_8056574 = 1;
  return result;
}
// 8056574: using guessed type char byte_8056574;

//----- (08049B5D) --------------------------------------------------------
void sub_8049B5D()
{
  ;
}

//----- (08049B78) --------------------------------------------------------
void sub_8049B78()
{
  ;
}

//----- (08049B88) --------------------------------------------------------
#error "8049BB5: call analysis failed (funcsize=23)"

//----- (08049C83) --------------------------------------------------------
void sub_8049C83()
{
  ;
}

//----- (08049C9E) --------------------------------------------------------
void sub_8049C9E()
{
  ;
}

//----- (08049CAE) --------------------------------------------------------
int sub_8049CAE()
{
  int result; // eax

  result = &unk_805629B - &unk_8056298;
  if ( (unsigned int)(&unk_805629B - &unk_8056298) > 6 )
    result = 0;
  return result;
}
// 8049CAE: could not find valid save-restore pair for ebp

//----- (08049D15) --------------------------------------------------------
int __usercall sub_8049D15@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_8056298, a1);
}

//----- (08049DAC) --------------------------------------------------------
void sub_8049DAC()
{
  ;
}

//----- (08049DC7) --------------------------------------------------------
void sub_8049DC7()
{
  ;
}

//----- (08049DD7) --------------------------------------------------------
int sub_8049DD7()
{
  int result; // eax

  result = &unk_805629B - &unk_8056298;
  if ( (unsigned int)(&unk_805629B - &unk_8056298) > 6 )
    result = 0;
  return result;
}
// 8049DD7: could not find valid save-restore pair for ebp

//----- (08049ED5) --------------------------------------------------------
void sub_8049ED5()
{
  ;
}

//----- (08049EF0) --------------------------------------------------------
void sub_8049EF0()
{
  ;
}

//----- (08049F00) --------------------------------------------------------
int sub_8049F00()
{
  int result; // eax

  result = &unk_80531BF - &unk_80531BC;
  if ( (unsigned int)(&unk_80531BF - &unk_80531BC) > 6 )
    result = 0;
  return result;
}
// 8049F00: could not find valid save-restore pair for ebp

//----- (08049F5E) --------------------------------------------------------
int sub_8049F5E()
{
  return nullsub_5();
}
// 8049F5E: could not find valid save-restore pair for ebp
// 8049F5D: using guessed type int nullsub_5(void);

//----- (08049FA3) --------------------------------------------------------
int sub_8049FA3()
{
  int result; // eax

  result = sub_8049F00();
  byte_80566A8 = 1;
  return result;
}
// 80566A8: using guessed type char byte_80566A8;

//----- (0804A017) --------------------------------------------------------
void sub_804A017()
{
  ;
}

//----- (0804A032) --------------------------------------------------------
void sub_804A032()
{
  ;
}

//----- (0804A042) --------------------------------------------------------
int sub_804A042()
{
  int result; // eax

  result = &unk_805629B - &unk_8056298;
  if ( (unsigned int)(&unk_805629B - &unk_8056298) > 6 )
    result = 0;
  return result;
}
// 804A042: could not find valid save-restore pair for ebp

//----- (0804A124) --------------------------------------------------------
void sub_804A124()
{
  ;
}

//----- (0804A13F) --------------------------------------------------------
void sub_804A13F()
{
  ;
}

//----- (0804A14F) --------------------------------------------------------
int sub_804A14F()
{
  int result; // eax

  result = &unk_805629B - &unk_8056298;
  if ( (unsigned int)(&unk_805629B - &unk_8056298) > 6 )
    result = 0;
  return result;
}
// 804A14F: could not find valid save-restore pair for ebp

//----- (0804A1AD) --------------------------------------------------------
int sub_804A1AD()
{
  return nullsub_6();
}
// 804A1AD: could not find valid save-restore pair for ebp
// 804A1AC: using guessed type int nullsub_6(void);

//----- (0804A25F) --------------------------------------------------------
void sub_804A25F()
{
  ;
}

//----- (0804A27A) --------------------------------------------------------
void sub_804A27A()
{
  ;
}

//----- (0804A28A) --------------------------------------------------------
int sub_804A28A()
{
  int result; // eax

  result = &unk_80562A3 - &unk_80562A0;
  if ( (unsigned int)(&unk_80562A3 - &unk_80562A0) > 6 )
    result = 0;
  return result;
}
// 804A28A: could not find valid save-restore pair for ebp

//----- (0804A388) --------------------------------------------------------
void sub_804A388()
{
  ;
}

//----- (0804A3A3) --------------------------------------------------------
void sub_804A3A3()
{
  ;
}

//----- (0804A3B3) --------------------------------------------------------
int __usercall sub_804A3B3@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>)
{
  int result; // eax
  int v6; // [esp+18h] [ebp-4h]

  v6 = a5;
  __asm { pushfw }
  if ( sub_805065D() != -774 )
    sub_8050667();
  __asm { popfw }
  result = (char *)&off_8052364[45] - (char *)&off_8052364[44];
  if ( (unsigned int)((char *)&off_8052364[45] - (char *)&off_8052364[44]) > 6 )
    result = 0;
  return result;
}
// 8050667: using guessed type int sub_8050667(void);
// 8052364: using guessed type void *off_8052364[54];

//----- (0804A439) --------------------------------------------------------
int __usercall sub_804A439@<eax>(int a1@<eax>, int (__cdecl *a2)(void **, int)@<edx>)
{
  return a2(&off_8052364[44], a1);
}
// 8052364: using guessed type void *off_8052364[54];

//----- (0804A475) --------------------------------------------------------
int __usercall sub_804A475@<eax>(int a1@<eax>)
{
  char v1; // sf
  int result; // eax

  result = sub_804A3B3(0, 0, v1, 0, a1);
  byte_80567DC = 1;
  return result;
}
// 80567DC: using guessed type char byte_80567DC;

//----- (0804A527) --------------------------------------------------------
void sub_804A527()
{
  ;
}

//----- (0804A542) --------------------------------------------------------
void sub_804A542()
{
  ;
}

//----- (0804A552) --------------------------------------------------------
int sub_804A552()
{
  int result; // eax

  result = &unk_80562A3 - &unk_80562A0;
  if ( (unsigned int)(&unk_80562A3 - &unk_80562A0) > 6 )
    result = 0;
  return result;
}
// 804A552: could not find valid save-restore pair for ebp

//----- (0804A5B0) --------------------------------------------------------
int sub_804A5B0()
{
  return nullsub_8();
}
// 804A5B0: could not find valid save-restore pair for ebp
// 804A5AF: using guessed type int nullsub_8(void);

//----- (0804A61E) --------------------------------------------------------
int sub_804A61E()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nWith no FILE, or when FILE is -, read standard input.\n");
  return fputs_unlocked(v1, v0);
}
// 8048F50: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804A649) --------------------------------------------------------
int sub_804A649()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nMandatory arguments to long options are mandatory for short options too.\n");
  return fputs_unlocked(v1, v0);
}
// 8048F50: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804A674) --------------------------------------------------------
int __usercall sub_804A674@<eax>(int a1@<ebx>, char *s1)
{
  void *v2; // eax
  char *v3; // eax
  char *v4; // eax
  int v9; // eax
  void *v10; // eax
  char *v11; // eax
  char *v12; // eax
  char *v13; // ebx
  char *v14; // eax
  int v16; // [esp-8h] [ebp-70h]
  char *v17; // [esp-4h] [ebp-6Ch]
  int v18; // [esp+0h] [ebp-68h]
  char *v19; // [esp+4h] [ebp-64h]
  char *v20; // [esp+8h] [ebp-60h]
  char *v21; // [esp+1Ch] [ebp-4Ch]
  char **i; // [esp+20h] [ebp-48h]
  char *v23; // [esp+24h] [ebp-44h]
  const char *v24; // [esp+28h] [ebp-40h]
  const char *v25; // [esp+2Ch] [ebp-3Ch]
  const char *v26; // [esp+30h] [ebp-38h]
  const char *v27; // [esp+34h] [ebp-34h]
  const char *v28; // [esp+38h] [ebp-30h]
  const char *v29; // [esp+3Ch] [ebp-2Ch]
  const char *v30; // [esp+40h] [ebp-28h]
  const char *v31; // [esp+44h] [ebp-24h]
  const char *v32; // [esp+48h] [ebp-20h]
  const char *v33; // [esp+4Ch] [ebp-1Ch]
  const char *v34; // [esp+50h] [ebp-18h]
  const char *v35; // [esp+54h] [ebp-14h]
  int v36; // [esp+58h] [ebp-10h]
  int v37; // [esp+5Ch] [ebp-Ch]

  v24 = "[";
  v25 = "test invocation";
  v26 = "coreutils";
  v27 = "Multi-call invocation";
  v28 = "sha224sum";
  v29 = "sha2 utilities";
  v30 = "sha256sum";
  v31 = "sha2 utilities";
  v32 = "sha384sum";
  v33 = "sha2 utilities";
  v34 = "sha512sum";
  v35 = "sha2 utilities";
  v36 = 0;
  v37 = 0;
  v21 = s1;
  for ( i = (char **)(&v18 - 16); ; i += 2 )
  {
    _ZF = *i == 0;
    v17 = *i;
    v16 = a1;
    v2 = &loc_804A721;
    if ( _ZF )
      v2 = &loc_804A739;
    dword_8056184 = (int)v2;
    a1 = v16;
    sub_8050F21(v18);
    v19 = *i;
    if ( !strcmp(s1, v19) )
      break;
  }
  if ( i[1] )
    v21 = i[1];
  v3 = gettext("\n%s online help: <%s>\n");
  v20 = "http://www.gnu.org/software/coreutils/";
  v19 = "GNU coreutils";
  printf(v3, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  v4 = setlocale(5, 0);
  v23 = v4;
  _CF = 0;
  _OF = 0;
  _ZF = v4 == 0;
  _SF = (signed int)v4 < 0;
  if ( v4 )
  {
    v17 = v4;
    __asm { pushfw }
    if ( sub_805065D() != -774 )
      sub_8050667();
    __asm { popfw }
    v9 = strncmp(v23, "en_", 3u);
    _ZF = v9 == 0;
    v17 = (char *)v9;
    v16 = a1;
    v10 = &loc_804A7E4;
    if ( _ZF )
      v10 = &loc_804A7FF;
    dword_8056148 = (int)v10;
    sub_805106F();
    v11 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
    v19 = s1;
    printf(v11, s1);
  }
  v12 = gettext("Full documentation at: <%s%s>\n");
  v20 = s1;
  v19 = "http://www.gnu.org/software/coreutils/";
  printf(v12, "http://www.gnu.org/software/coreutils/", s1);
  if ( v21 == s1 )
    v13 = " invocation";
  else
    v13 = &s;
  v14 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  v20 = v13;
  v19 = v21;
  return printf(v14, v21, v13);
}
// 8050667: using guessed type int sub_8050667(void);
// 8050F21: using guessed type int __stdcall sub_8050F21(_DWORD);
// 805106F: using guessed type int sub_805106F(void);
// 8056148: using guessed type int dword_8056148;
// 8056184: using guessed type int dword_8056184;

//----- (0804A85B) --------------------------------------------------------
void __cdecl __noreturn sub_804A85B(int status)
{
  int v1; // ebx
  char *v2; // eax
  int v3; // ebx
  char *v4; // eax
  FILE *v5; // ebx
  char *v6; // eax
  FILE *v7; // ebx
  char *v8; // eax
  FILE *v9; // ebx
  char *v10; // eax
  char *v11; // eax

  if ( status )
  {
    v1 = dword_8056835;
    v2 = gettext("Try '%s --help' for more information.\n");
    fprintf(stderr, v2, v1);
  }
  else
  {
    v3 = dword_8056835;
    v4 = gettext("Usage: %s [OPTION]... [FILE]\nBase%d encode or decode FILE, or standard input, to standard output.\n");
    printf(v4, v3, 32);
    sub_804A61E();
    sub_804A649();
    v5 = stdout;
    v6 = gettext(
           "  -d, --decode          decode data\n"
           "  -i, --ignore-garbage  when decoding, ignore non-alphabet characters\n"
           "  -w, --wrap=COLS       wrap encoded lines after COLS character (default 76).\n"
           "                          Use 0 to disable line wrapping\n"
           "\n");
    fputs_unlocked(v6, v5);
    v7 = stdout;
    v8 = gettext("      --help     display this help and exit\n");
    fputs_unlocked(v8, v7);
    v9 = stdout;
    v10 = gettext("      --version  output version information and exit\n");
    fputs_unlocked(v10, v9);
    v11 = gettext(
            "\n"
            "The data are encoded as described for the %s alphabet in RFC 4648.\n"
            "When decoding, the input may contain newlines in addition to the bytes of\n"
            "the formal %s alphabet.  Use --ignore-garbage to attempt to recover\n"
            "from any other non-alphabet bytes in the encoded stream.\n");
    printf(v11, "base32", "base32");
    sub_804A674((int)v9, "base32");
  }
  exit(status);
}
// 8048F50: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8056835: using guessed type int dword_8056835;

//----- (0804A95A) --------------------------------------------------------
size_t __cdecl sub_804A95A(void *ptr, size_t n, int a3, int a4, int a5, FILE *stream)
{
  size_t result; // eax
  char *v11; // ebx
  int *v12; // eax
  __int64 v13; // rcx
  size_t v14; // eax
  char *v15; // ebx
  int *v16; // eax
  size_t v17; // eax
  char *v18; // ebx
  int *v19; // eax
  size_t v20; // [esp-4h] [ebp-3Ch]
  __int64 v21; // [esp+18h] [ebp-20h]
  size_t v22; // [esp+20h] [ebp-18h]
  size_t v23; // [esp+24h] [ebp-14h]
  __int64 v24; // [esp+28h] [ebp-10h]

  v21 = __PAIR__(a4, a3);
  if ( __PAIR__(a4, a3) )
  {
LABEL_6:
    v22 = 0;
    while ( 1 )
    {
      result = v22;
      if ( v22 >= n )
        break;
      v13 = *(unsigned int *)a5;
      v24 = v21 - v13;
      v14 = v21 - v13;
      if ( (unsigned __int64)(v21 - v13) >> 32 )
        v14 = -1;
      v23 = v14;
      if ( n - v22 <= v14 )
        v14 = n - v22;
      v23 = v14;
      if ( v14 )
      {
        v17 = fwrite_unlocked((char *)ptr + v22, 1u, v23, stdout);
        if ( v17 < v23 )
        {
          v18 = gettext("write error");
          v19 = __errno_location();
          error(1, *v19, v18);
        }
        *(_DWORD *)a5 += v23;
        v22 += v23;
      }
      else
      {
        if ( fputc_unlocked(10, stream) == -1 )
        {
          v15 = gettext("write error");
          v16 = __errno_location();
          error(1, *v16, v15);
        }
        *(_DWORD *)a5 = 0;
      }
    }
    return result;
  }
  v20 = fwrite_unlocked(ptr, 1u, n, stdout);
  __asm { pushfw }
  if ( sub_805065D() != -774 )
    sub_8050667();
  __asm { popfw }
  result = v20;
  if ( v20 < n )
  {
    v11 = gettext("write error");
    v12 = __errno_location();
    error(1, *v12, v11);
    goto LABEL_6;
  }
  return result;
}
// 8050667: using guessed type int sub_8050667(void);

//----- (0804AB2F) --------------------------------------------------------
unsigned int __usercall sub_804AB2F@<eax>(int a1@<ebx>, FILE *a2, FILE *a3, __int64 a4)
{
  char v4; // of
  void *v5; // eax
  char *v6; // ebx
  int *v7; // eax
  char *v8; // ebx
  int *v9; // eax
  int v11; // [esp-8h] [ebp-13850h]
  int v12; // [esp-4h] [ebp-1384Ch]
  int v13; // [esp+0h] [ebp-13848h]
  __int64 v14; // [esp+20h] [ebp-13828h]
  FILE *v15; // [esp+28h] [ebp-13820h]
  FILE *stream; // [esp+2Ch] [ebp-1381Ch]
  int v17; // [esp+30h] [ebp-13818h]
  unsigned int v18; // [esp+34h] [ebp-13814h]
  size_t v19; // [esp+38h] [ebp-13810h]
  char v20[30720]; // [esp+3Ch] [ebp-1380Ch]
  char ptr; // [esp+783Ch] [ebp-C00Ch]
  unsigned int v22; // [esp+1383Ch] [ebp-Ch]

  stream = a2;
  v15 = a3;
  v14 = a4;
  v22 = __readgsdword(0x14u);
  v17 = 0;
  v18 = 0;
  do
  {
    v19 = fread_unlocked(&v20[v18], 1u, 30720 - v18, stream);
    v18 += v19;
  }
  while ( !feof_unlocked(stream) && !ferror_unlocked(stream) && v18 <= 0x77FF );
  if ( v18 )
  {
    sub_804B59E(
      __CFSHL__((v18 + 4) / 5, 3),
      8 * ((v18 + 4) / 5) == 0,
      (8 * ((v18 + 4) / 5) & 0x80000000) != 0,
      v4,
      (int)v20,
      (int)v20,
      v18,
      &ptr,
      8 * ((v18 + 4) / 5));
    sub_804A95A(&v13 - 12291, 8 * ((v18 + 4) / 5), v14, SHIDWORD(v14), (int)(&v13 - 19974), v15);
  }
  if ( !feof_unlocked(stream) && !ferror_unlocked(stream) )
  {
    v12 = 0;
    v11 = a1;
    v5 = &loc_804AD23;
    if ( v18 == 30720 )
      v5 = &loc_804AB82;
    dword_80561D4 = (int)v5;
    sub_8050D51();
  }
  if ( v14 && v17 && fputc_unlocked(10, v15) == -1 )
  {
    v6 = gettext("write error");
    v7 = __errno_location();
    error(1, *v7, v6);
  }
  if ( ferror_unlocked(stream) )
  {
    v8 = gettext("read error");
    v9 = __errno_location();
    error(1, *v9, v8);
  }
  return __readgsdword(0x14u) ^ v22;
}
// 8050D51: using guessed type int sub_8050D51(void);
// 80561D4: using guessed type int dword_80561D4;
// 804AB2F: using guessed type char var_1380C[30720];

//----- (0804ADD8) --------------------------------------------------------
unsigned int __usercall sub_804ADD8@<eax>(char *a1@<ebx>, FILE *a2, FILE *a3, char a4)
{
  bool v4; // zf
  void *v5; // eax
  int v6; // edx
  int v7; // ecx
  int *v8; // eax
  unsigned int v9; // eax
  size_t v10; // eax
  int *v11; // eax
  char *v12; // eax
  unsigned int v13; // eax
  char *v15; // [esp-8h] [ebp-3460h]
  int v16; // [esp-4h] [ebp-345Ch]
  unsigned __int8 v17; // [esp+0h] [ebp-3458h]
  int v18; // [esp+4h] [ebp-3454h]
  int v19; // [esp+8h] [ebp-3450h]
  int v20; // [esp+Ch] [ebp-344Ch]
  int v21; // [esp+10h] [ebp-3448h]
  char v22; // [esp+14h] [ebp-3444h]
  FILE *v23; // [esp+18h] [ebp-3440h]
  FILE *stream; // [esp+1Ch] [ebp-343Ch]
  int v25; // [esp+20h] [ebp-3438h]
  int v26; // [esp+24h] [ebp-3434h]
  int v27; // [esp+28h] [ebp-3430h]
  int v28; // [esp+2Ch] [ebp-342Ch]
  size_t n; // [esp+30h] [ebp-3428h]
  unsigned int v30; // [esp+34h] [ebp-3424h]
  unsigned int v31; // [esp+38h] [ebp-3420h]
  size_t i; // [esp+3Ch] [ebp-341Ch]
  int v33; // [esp+40h] [ebp-3418h]
  int v34; // [esp+44h] [ebp-3414h]
  int v35; // [esp+48h] [ebp-3410h]
  int ptr; // [esp+4Ch] [ebp-340Ch]
  int v37; // [esp+50h] [ebp-3408h]
  int v38; // [esp+54h] [ebp-3404h]
  int v39; // [esp+58h] [ebp-3400h]
  int v40; // [esp+5Ch] [ebp-33FCh]
  int v41; // [esp+60h] [ebp-33F8h]
  int v42; // [esp+64h] [ebp-33F4h]
  int v43; // [esp+68h] [ebp-33F0h]
  int v44; // [esp+6Ch] [ebp-33ECh]
  int v45; // [esp+70h] [ebp-33E8h]
  int v46; // [esp+74h] [ebp-33E4h]
  int v47; // [esp+78h] [ebp-33E0h]
  int v48; // [esp+7Ch] [ebp-33DCh]
  int v49; // [esp+80h] [ebp-33D8h]
  int v50; // [esp+84h] [ebp-33D4h]
  int v51; // [esp+88h] [ebp-33D0h]
  char v52[8192]; // [esp+144Ch] [ebp-200Ch]
  unsigned int v53; // [esp+344Ch] [ebp-Ch]

  stream = a2;
  v23 = a3;
  v22 = a4;
  v53 = __readgsdword(0x14u);
  sub_804BB23((_DWORD *)&v17 - 3334);
  do
  {
    v30 = 0;
    do
    {
      n = fread_unlocked(&v52[v30], 1u, 0x2000 - v30, stream);
      if ( v22 )
      {
        for ( i = 0; n && i < n; ++i )
        {
          *(_DWORD *)&v17 = v52[v30 + i];
          if ( !sub_804BABC((signed int)a1, v17) )
          {
            v4 = v52[v30 + i] == 61;
            v16 = (unsigned __int8)v52[v30 + i];
            v15 = a1;
            v5 = &loc_804AEF1;
            if ( !v4 )
              v5 = &loc_804AEFA;
            dword_80561AC = (int)v5;
            a1 = v15;
            sub_8050E3D(*(_DWORD *)&v17, v18);
          }
        }
      }
      v30 += n;
      if ( ferror_unlocked(stream) )
      {
        a1 = gettext("read error");
        v8 = __errno_location();
        error(1, *v8, a1);
      }
    }
    while ( v30 <= 0x1FFF && !feof_unlocked(stream) );
    dword_805610C = (int)&loc_804B10E;
    sub_80511C9(
      v7,
      v6,
      *(_DWORD *)&v17,
      v18,
      v19,
      v20,
      v21,
      *(_DWORD *)&v22,
      v23,
      stream,
      v25,
      v26,
      v27,
      v28,
      n,
      v30,
      0,
      i,
      v33,
      v34,
      v35,
      ptr,
      v37,
      v38,
      v39,
      v40,
      v41,
      v42,
      v43,
      v44,
      v45,
      v46,
      v47,
      v48,
      v49,
      v50,
      v51);
    do
    {
      if ( v31 == 1 && !v33 )
        break;
      n = 5120;
      if ( v31 )
        v9 = 0;
      else
        v9 = v30;
      HIBYTE(v28) = sub_804C242((signed int)a1, &v33, (unsigned __int8 *)v52, v9, (int)&ptr, (int *)&n);
      v10 = fwrite_unlocked(&ptr, 1u, n, v23);
      if ( v10 < n )
      {
        a1 = gettext("write error");
        v11 = __errno_location();
        error(1, *v11, a1);
      }
      if ( HIBYTE(v28) != 1 )
      {
        v12 = gettext("invalid input");
        error(1, 0, v12);
      }
      ++v31;
      v13 = feof_unlocked(stream) ? 2 : 1;
    }
    while ( v13 > v31 );
  }
  while ( !feof_unlocked(stream) );
  return __readgsdword(0x14u) ^ v53;
}
// 8050E3D: using guessed type int __stdcall sub_8050E3D(_DWORD, _DWORD);
// 80511C9: using guessed type int __fastcall sub_80511C9(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 805610C: using guessed type int dword_805610C;
// 80561AC: using guessed type int dword_80561AC;
// 804ADD8: using guessed type char var_200C[8192];

//----- (0804B168) --------------------------------------------------------
int __usercall main@<eax>(char *a1@<ebx>, int argc, char **argv)
{
  int v3; // eax
  char *v4; // eax
  void *v9; // ebx
  char *v10; // eax
  int v11; // eax
  char *v12; // ebx
  int *v13; // eax
  int v14; // ebx
  int v15; // eax
  void *v17; // [esp-4h] [ebp-48h]
  char *v18; // [esp+0h] [ebp-44h]
  int v19; // [esp+4h] [ebp-40h]
  __int64 v20; // [esp+8h] [ebp-3Ch]
  const char *v21; // [esp+10h] [ebp-34h]
  int v22; // [esp+14h] [ebp-30h]
  char v23; // [esp+2Ah] [ebp-1Ah]
  char v24; // [esp+2Bh] [ebp-19h]
  FILE *v25; // [esp+2Ch] [ebp-18h]
  const char *v26; // [esp+30h] [ebp-14h]
  int v27; // [esp+34h] [ebp-10h]
  __int64 v28; // [esp+38h] [ebp-Ch]

  v23 = 0;
  v24 = 0;
  v28 = 76LL;
  sub_804C6FF(*argv);
  setlocale(6, &s);
  bindtextdomain("coreutils", "/home/hwangdz/coreutils/coreutils-8.28/install_m32/share/locale");
  textdomain("coreutils");
  sub_8050A3D((int)sub_804C572);
  dword_80561E8 = (int)&loc_804B30E;
  sub_8050CAB();
  do
  {
    v3 = v27;
    if ( v27 == 100 )
    {
      v23 = 1;
    }
    else
    {
      if ( v27 <= 100 )
      {
        if ( v27 == -131 )
        {
          v22 = 0;
          v21 = "Simon Josefsson";
          sub_804EE21(stdout, (int)"base32", (int)"GNU coreutils", off_8056244, "Simon Josefsson", 0);
          exit(0);
        }
        if ( v27 == -130 )
          sub_804A85B(0);
        dword_80561D4 = (int)&loc_804B302;
        v3 = sub_8050D51();
      }
      if ( v3 == 105 )
      {
        v24 = 1;
      }
      else
      {
        if ( v3 != 119 )
          sub_804A85B(1);
        v4 = gettext("invalid wrap size");
        v28 = sub_804F37B((signed int)a1, optarg, 0, 0, -1, -1, &s, (int)v4, 0);
      }
    }
    v27 = getopt_long(argc, argv, "diw:", &longopts, 0);
  }
  while ( v27 != -1 );
  if ( argc - optind > 1 )
  {
    v18 = argv[optind];
    v17 = sub_804E68C((signed int)a1, (int)v18);
    __asm { pushfw }
    if ( sub_805065D() != -774 )
      sub_8050667();
    __asm { popfw }
    v9 = v17;
    v10 = gettext("extra operand %s");
    HIDWORD(v20) = v9;
    error(0, 0, v10, v9);
    sub_804A85B(1);
  }
  if ( optind >= argc )
    v26 = "-";
  else
    v26 = argv[optind];
  if ( !strcmp(v26, "-") )
  {
    v19 = 0;
    sub_804F1DC((signed int)a1, 0);
    v25 = (FILE *)stdin;
  }
  else
  {
    v25 = (FILE *)fopen64(v26, "rb");
    if ( !v25 )
    {
      a1 = (char *)sub_804E391(0, 3, v26);
      v11 = *__errno_location();
      HIDWORD(v20) = a1;
      error(1, v11, "%s", a1);
    }
  }
  sub_804C6B7(v25, 2);
  if ( v23 )
    sub_804ADD8(a1, v25, stdout, v24);
  else
    sub_804AB2F((int)a1, v25, stdout, v28);
  if ( sub_804F9FB(v25) == -1 )
  {
    if ( !strcmp(v26, "-") )
    {
      v12 = gettext("closing standard input");
      v13 = __errno_location();
      error(1, *v13, v12);
    }
    v14 = sub_804E391(0, 3, v26);
    v15 = *__errno_location();
    HIDWORD(v20) = v14;
    error(1, v15, "%s", v14);
  }
  return 0;
}
// 8048E40: using guessed type int __cdecl fopen64(_DWORD, _DWORD);
// 804E391: using guessed type _DWORD __cdecl sub_804E391(_DWORD, _DWORD, _DWORD);
// 8050667: using guessed type int sub_8050667(void);
// 8050CAB: using guessed type int sub_8050CAB(void);
// 8050D51: using guessed type int sub_8050D51(void);
// 80561D4: using guessed type int dword_80561D4;
// 80561E8: using guessed type int dword_80561E8;
// 80562E0: using guessed type int optind;
// 8056300: using guessed type int stdin;

//----- (0804B58C) --------------------------------------------------------
int __cdecl sub_804B58C(unsigned __int8 a1)
{
  return a1;
}

//----- (0804B59E) --------------------------------------------------------
#error "804BA11: call analysis failed (funcsize=39)"

//----- (0804BABC) --------------------------------------------------------
char __usercall sub_804BABC@<al>(signed int a1@<ebx>, unsigned __int8 a2)
{
  void *v6; // eax
  int v8; // [esp-6h] [ebp-Eh]
  unsigned __int8 v9; // [esp+6h] [ebp-2h]

  HIWORD(v8) = sub_804B58C(a2);
  __asm { pushfw }
  v6 = &loc_804BAF6;
  if ( a1 < 10 )
    v6 = &loc_804BB0E;
  dword_8056198 = (int)v6;
  sub_8050EAF(a1, v8);
  if ( ((_BYTE)a1 - 1) * (_BYTE)a1 & 1 )
    abort();
  __asm { popfw }
  return (unsigned __int8)~byte_8051940[v9] >> 7;
}
// 804BABC: could not find valid save-restore pair for ebx
// 8050EAF: using guessed type int __stdcall sub_8050EAF(_DWORD, _DWORD);
// 8056198: using guessed type int dword_8056198;

//----- (0804BB23) --------------------------------------------------------
_DWORD *__cdecl sub_804BB23(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = 0;
  return result;
}

//----- (0804BB31) --------------------------------------------------------
void *__cdecl sub_804BB31(_DWORD *a1, void **a2, unsigned int a3, _DWORD *a4)
{
  bool v4; // zf
  void *v5; // eax
  void *result; // eax
  char *v7; // eax
  int v8; // eax
  char v9; // [esp+17h] [ebp-11h]
  char *v10; // [esp+18h] [ebp-10h]
  void *s; // [esp+1Ch] [ebp-Ch]

  if ( *a1 == 8 )
    *a1 = 0;
  if ( *a1 || (s = *a2, (signed int)(a3 - (_DWORD)*a2) <= 7) )
  {
    v10 = (char *)*a2;
    while ( (unsigned int)v10 < a3 )
    {
      v7 = v10++;
      v9 = *v7;
      if ( v9 != 10 )
      {
        v8 = (*a1)++;
        *((_BYTE *)a1 + v8 + 4) = v9;
        if ( *a1 == 8 )
        {
          dword_80561C0 = (int)&loc_804BC32;
          sub_8050DC7();
        }
      }
    }
    *a2 = v10;
    *a4 = *a1;
    result = a1 + 1;
  }
  else
  {
    v4 = memchr(s, 10, 8u) == 0;
    v5 = &loc_804BBA4;
    if ( !v4 )
      v5 = &loc_804BBC2;
    dword_8056134 = (int)v5;
    sub_80510E5();
    *a2 = (char *)*a2 + 8;
    *a4 = 8;
    result = s;
  }
  return result;
}
// 8050DC7: using guessed type int sub_8050DC7(void);
// 80510E5: using guessed type int sub_80510E5(void);
// 8056134: using guessed type int dword_8056134;
// 80561C0: using guessed type int dword_80561C0;

//----- (0804BC4C) --------------------------------------------------------
int __usercall sub_804BC4C@<eax>(signed int a1@<ebx>, unsigned __int8 *a2, unsigned int a3, int *a4)
{
  int v4; // ST18_4
  bool v6; // zf
  void *v7; // eax

  v4 = *a4;
  if ( a3 <= 7 )
    return 0;
  if ( !((unsigned __int8)sub_804BABC(a1, *a2) ^ 1) )
  {
    v6 = sub_804BABC(a1, a2[1]) == 1;
    v7 = &loc_804BCB8;
    if ( v6 )
      v7 = &loc_804BCC2;
    dword_80561FC = (int)v7;
    sub_8050C37();
  }
  return 0;
}
// 8050C37: using guessed type int sub_8050C37(void);
// 80561FC: using guessed type int dword_80561FC;

//----- (0804C242) --------------------------------------------------------
bool __usercall sub_804C242@<al>(signed int a1@<ebx>, int *a2, unsigned __int8 *a3, unsigned int a4, int a5, int *a6)
{
  void *v6; // eax
  void *v7; // eax
  void *v8; // eax
  int v10; // [esp+0h] [ebp-38h]
  int v11; // [esp+4h] [ebp-34h]
  int *v12; // [esp+Ch] [ebp-2Ch]
  int v13; // [esp+14h] [ebp-24h]
  bool v14; // [esp+1Ah] [ebp-1Eh]
  bool v15; // [esp+1Bh] [ebp-1Dh]
  int v16; // [esp+1Ch] [ebp-1Ch]
  int v17; // [esp+20h] [ebp-18h]
  int v18; // [esp+24h] [ebp-14h]
  unsigned __int8 *v19; // [esp+28h] [ebp-10h]
  unsigned __int8 *v20; // [esp+2Ch] [ebp-Ch]

  v16 = *a6;
  v15 = a2 != 0;
  v14 = 0;
  v17 = 0;
  v6 = &loc_804C294;
  if ( a2 == 0 )
    v6 = &loc_804C2A7;
  dword_8056198 = (int)v6;
  sub_8050EAF(v10, v11);
  v17 = *a2;
  v14 = a4 == 0;
  while ( 1 )
  {
    v18 = v16;
    if ( !v17 && v14 != 1 )
    {
      while ( 1 )
      {
        v18 = v16;
        v12 = &v10 - 7;
        if ( (unsigned __int8)sub_804BC4C(a1, a3, a4, &v13) ^ 1 )
          break;
        a3 += 8;
        a4 -= 8;
      }
    }
    if ( !a4 )
      break;
    v8 = &loc_804C361;
    if ( !a4 )
      v8 = &loc_804C388;
    dword_8056184 = (int)v8;
    sub_8050F21(v10);
    if ( *a3 == 10 && v15 )
    {
      ++a3;
      --a4;
    }
    else
    {
      a5 += v16 - v18;
      v16 = v18;
      v20 = &a3[a4];
      if ( v15 )
        v19 = (unsigned __int8 *)sub_804BB31(a2, (void **)&a3, (unsigned int)v20, &a4);
      else
        v19 = a3;
      if ( !a4 || a4 <= 7 && v14 != 1 && v15 )
      {
        a4 = 0;
        goto LABEL_27;
      }
      v12 = &v16;
      if ( (unsigned __int8)sub_804BC4C(a1, v19, a4, &a5) ^ 1 )
        goto LABEL_27;
      a4 = v20 - a3;
    }
  }
  v7 = &loc_804C33C;
  if ( v14 == 1 )
    v7 = &loc_804C341;
  dword_8056148 = (int)v7;
  sub_805106F();
LABEL_27:
  *a6 -= v16;
  return a4 == 0;
}
// 804C242: could not find valid save-restore pair for ebx
// 8050EAF: using guessed type int __stdcall sub_8050EAF(_DWORD, _DWORD);
// 8050F21: using guessed type int __stdcall sub_8050F21(_DWORD);
// 805106F: using guessed type int sub_805106F(void);
// 8056148: using guessed type int dword_8056148;
// 8056184: using guessed type int dword_8056184;
// 8056198: using guessed type int dword_8056198;

//----- (0804C572) --------------------------------------------------------
int sub_804C572()
{
  void *v0; // ebx
  int *v1; // eax
  int *v2; // eax
  int result; // eax
  char *v4; // [esp+2Ch] [ebp-Ch]

  if ( sub_804FE8A(stdout) && (byte_8056831 != 1 || *__errno_location() != 32) )
  {
    v4 = gettext("write error");
    if ( dword_805682D )
    {
      v0 = sub_804E354(dword_805682D);
      v1 = __errno_location();
      error(0, *v1, "%s: %s", v0, v4);
    }
    else
    {
      v2 = __errno_location();
      error(0, *v2, "%s", v4);
    }
    _exit(status);
  }
  result = sub_804FE8A(stderr);
  if ( result )
    _exit(status);
  return result;
}
// 805682D: using guessed type int dword_805682D;
// 8056831: using guessed type char byte_8056831;

//----- (0804C656) --------------------------------------------------------
int __cdecl sub_804C656(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // [esp+20h] [ebp-28h]
  int v8; // [esp+24h] [ebp-24h]
  int v9; // [esp+2Ch] [ebp-1Ch]

  v9 = a3;
  v7 = a4;
  v8 = a5;
  return posix_fadvise64(a1, a2, a3, a4, a5, a6);
}
// 8049070: using guessed type int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804C6B7) --------------------------------------------------------
void __cdecl sub_804C6B7(FILE *stream, int a2)
{
  int v2; // eax

  if ( stream )
  {
    v2 = fileno(stream);
    sub_804C656(v2, 0, 0, 0, 0, a2);
  }
}

//----- (0804C6FF) --------------------------------------------------------
char *__cdecl sub_804C6FF(char *s)
{
  char *v1; // eax
  bool v2; // zf
  void *v3; // eax
  void *v4; // eax
  char *result; // eax
  int v6; // [esp+0h] [ebp-28h]
  int v7; // [esp+4h] [ebp-24h]
  char *v8; // [esp+18h] [ebp-10h]
  char *s1; // [esp+1Ch] [ebp-Ch]
  char *sa; // [esp+30h] [ebp+8h]

  if ( !s )
  {
    fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
    abort();
  }
  v1 = strrchr(s, 47);
  v8 = v1;
  v2 = v1 == 0;
  v3 = &loc_804C76A;
  if ( v2 )
    v3 = &loc_804C787;
  dword_80561C0 = (int)v3;
  sub_8050DC7();
  dword_8056148 = (int)&loc_804C78A;
  sub_805106F();
  s1 = s;
  dword_80561E8 = (int)&loc_804C826;
  sub_8050CAB();
  v2 = strncmp(s1 - 7, "/.libs/", 7u) == 0;
  v4 = &loc_804C7F0;
  if ( !v2 )
    v4 = &loc_804C826;
  dword_80561AC = (int)v4;
  sub_8050E3D(v6, v7);
  sa = s1;
  if ( !strncmp(s1, "lt-", 3u) )
  {
    sa = s1 + 3;
    program_invocation_short_name = (int)(s1 + 3);
  }
  dword_8056835 = (int)sa;
  result = sa;
  program_invocation_name = (int)sa;
  return result;
}
// 804C6FF: could not find valid save-restore pair for ebx
// 8050CAB: using guessed type int sub_8050CAB(void);
// 8050DC7: using guessed type int sub_8050DC7(void);
// 8050E3D: using guessed type int __stdcall sub_8050E3D(_DWORD, _DWORD);
// 805106F: using guessed type int sub_805106F(void);
// 8056148: using guessed type int dword_8056148;
// 80561AC: using guessed type int dword_80561AC;
// 80561C0: using guessed type int dword_80561C0;
// 80561E8: using guessed type int dword_80561E8;
// 80562C0: using guessed type int program_invocation_short_name;
// 80562D0: using guessed type int program_invocation_name;
// 8056835: using guessed type int dword_8056835;

//----- (0804C8AB) --------------------------------------------------------
#error "804C945: call analysis failed (funcsize=57)"

//----- (0804C94A) --------------------------------------------------------
#error "804C94F: positive sp value has been found (funcsize=0)"

//----- (0804C97A) --------------------------------------------------------
int *__cdecl sub_804C97A(int *a1, int a2, int a3)
{
  int *result; // eax

  if ( !a1 )
    a1 = &dword_805683D;
  *a1 = 10;
  if ( !a2 || !a3 )
    abort();
  a1[10] = a2;
  result = a1;
  a1[11] = a3;
  return result;
}
// 805683D: using guessed type int dword_805683D;

//----- (0804C9BB) --------------------------------------------------------
unsigned int *__userpurge sub_804C9BB@<eax>(unsigned int *a1, unsigned int a2)
{
  int v7; // [esp-8h] [ebp-40h]
  int v8; // [esp-4h] [ebp-3Ch]
  unsigned int v9; // [esp+4h] [ebp-34h]
  unsigned int v10; // [esp+8h] [ebp-30h]
  unsigned int v11; // [esp+Ch] [ebp-2Ch]
  unsigned int v12; // [esp+10h] [ebp-28h]
  unsigned int v13; // [esp+14h] [ebp-24h]
  unsigned int v14; // [esp+18h] [ebp-20h]
  unsigned int v15; // [esp+1Ch] [ebp-1Ch]
  unsigned int v16; // [esp+20h] [ebp-18h]
  unsigned int v17; // [esp+24h] [ebp-14h]
  unsigned int v18; // [esp+28h] [ebp-10h]
  unsigned int v19; // [esp+2Ch] [ebp-Ch]

  memset(&v7, 0, 0x30u);
  _CF = a2 < 0xA;
  _OF = __OFSUB__(a2, 10);
  _ZF = a2 == 10;
  _SF = (signed int)(a2 - 10) < 0;
  if ( a2 == 10 )
  {
    v8 = 0;
    __asm { pushfw }
    if ( sub_805065D() != -774 )
      sub_8050667();
    __asm { popfw }
    abort();
  }
  *a1 = a2;
  a1[1] = v9;
  a1[2] = v10;
  a1[3] = v11;
  a1[4] = v12;
  a1[5] = v13;
  a1[6] = v14;
  a1[7] = v15;
  a1[8] = v16;
  a1[9] = v17;
  a1[10] = v18;
  a1[11] = v19;
  return a1;
}
// 8050667: using guessed type int sub_8050667(void);

//----- (0804CA7C) --------------------------------------------------------
#error "804CAC2: call analysis failed (funcsize=82)"

//----- (0804CB9C) --------------------------------------------------------
#error "804D3E7: call analysis failed (funcsize=1102)"

//----- (0804DBDD) --------------------------------------------------------
void *__cdecl sub_804DBDD(int a1, int a2, _DWORD *a3, _DWORD *a4)
{
  void *v4; // eax
  _DWORD *v5; // ST44_4
  int v6; // ST48_4
  int v7; // ST4C_4
  int v9; // [esp+0h] [ebp-58h]
  int v10; // [esp+4h] [ebp-54h]
  int v11; // [esp+8h] [ebp-50h]
  int v12; // [esp+Ch] [ebp-4Ch]
  int v13; // [esp+10h] [ebp-48h]
  int v14; // [esp+14h] [ebp-44h]
  int v15; // [esp+18h] [ebp-40h]
  int v16; // [esp+1Ch] [ebp-3Ch]
  int v17; // [esp+20h] [ebp-38h]
  int v18; // [esp+24h] [ebp-34h]
  int v19; // [esp+28h] [ebp-30h]
  int v20; // [esp+2Ch] [ebp-2Ch]
  int v21; // [esp+30h] [ebp-28h]
  int v22; // [esp+34h] [ebp-24h]
  int v23; // [esp+38h] [ebp-20h]
  int v24; // [esp+3Ch] [ebp-1Ch]
  int v25; // [esp+40h] [ebp-18h]
  int v26; // [esp+44h] [ebp-14h]
  size_t size; // [esp+48h] [ebp-10h]
  int sizea; // [esp+48h] [ebp-10h]
  void *v29; // [esp+4Ch] [ebp-Ch]

  v4 = &loc_804DC03;
  if ( !a4 )
    v4 = &loc_804DC08;
  dword_8056170 = (int)v4;
  sub_8050F8D(v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, size);
  v5 = a4;
  v6 = *__errno_location();
  v7 = a4[1] | (a3 == 0);
  sizea = sub_804CB9C(0, 0, a1, a2, *v5, v7, v5 + 2, a4[10], v5[11]) + 1;
  v29 = sub_804EFCB((signed int)(a4 + 2), sizea);
  sub_804CB9C(v29, sizea, a1, a2, *v5, v7, v5 + 2, v5[10], v5[11]);
  *__errno_location() = v6;
  if ( a3 )
    *a3 = sizea - 1;
  return v29;
}
// 804CB9C: using guessed type _DWORD __cdecl sub_804CB9C(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8050F8D: using guessed type int __stdcall sub_8050F8D(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8056170: using guessed type int dword_8056170;

//----- (0804DDEB) --------------------------------------------------------
void *__cdecl sub_804DDEB(signed int a1, int a2, int a3, _DWORD *a4)
{
  void *v4; // eax
  int *v5; // eax
  void *v6; // edx
  size_t v7; // ST4C_4
  signed int v8; // ebx
  bool v10; // [esp+37h] [ebp-21h]
  int *v11; // [esp+38h] [ebp-20h]
  int *v12; // [esp+38h] [ebp-20h]
  void *ptr; // [esp+3Ch] [ebp-1Ch]
  int v14; // [esp+40h] [ebp-18h]
  int size; // [esp+44h] [ebp-14h]
  int v16; // [esp+48h] [ebp-10h]
  size_t v17; // [esp+4Ch] [ebp-Ch]

  v14 = *__errno_location();
  v11 = off_8056268;
  if ( a1 < 0 )
    abort();
  v4 = &loc_804DE32;
  if ( dword_805625C > a1 )
    v4 = &loc_804DEF1;
  dword_80561C0 = (int)v4;
  sub_8050DC7();
  v10 = v11 == &dword_8056260;
  if ( (unsigned int)a1 > 0xFFFFFFE )
    sub_804F19E();
  if ( v10 )
    v5 = 0;
  else
    v5 = v11;
  v12 = (int *)sub_804F05F(v5, 8 * (a1 + 1));
  off_8056268 = v12;
  if ( v10 )
  {
    v6 = off_8056264;
    *v12 = dword_8056260;
    v12[1] = (int)v6;
  }
  memset(&v12[2 * dword_805625C], 0, 8 * (a1 + 1 - dword_805625C));
  dword_805625C = a1 + 1;
  v7 = v12[2 * a1];
  ptr = (void *)v12[2 * a1 + 1];
  v16 = a4[1] | 1;
  v17 = sub_804CB9C(ptr, v7, a2, a3, *a4, v16, a4 + 2, a4[10], a4[11]);
  if ( v7 <= v17 )
  {
    size = v17 + 1;
    v12[2 * a1] = v17 + 1;
    if ( ptr != &unk_805687D )
      free(ptr);
    v8 = (signed int)&v12[2 * a1];
    ptr = sub_804EFCB(v8, size);
    *(_DWORD *)(v8 + 4) = ptr;
    sub_804CB9C(ptr, size, a2, a3, *a4, v16, a4 + 2, a4[10], a4[11]);
  }
  *__errno_location() = v14;
  return ptr;
}
// 804CB9C: using guessed type _DWORD __cdecl sub_804CB9C(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8050DC7: using guessed type int sub_8050DC7(void);
// 80561C0: using guessed type int dword_80561C0;
// 805625C: using guessed type int dword_805625C;
// 8056260: using guessed type int dword_8056260;
// 8056264: using guessed type void *off_8056264;
// 8056268: using guessed type int *off_8056268;

//----- (0804E069) --------------------------------------------------------
void *__cdecl sub_804E069(signed int a1, int a2)
{
  return sub_804DDEB(a1, a2, -1, &dword_805683D);
}
// 805683D: using guessed type int dword_805683D;

//----- (0804E093) --------------------------------------------------------
#error "804E0A2: call analysis failed (funcsize=11)"

//----- (0804E0B5) --------------------------------------------------------
void *__cdecl sub_804E0B5(int a1, signed int a2, int a3, int a4)
{
  return sub_804DDEB(a2, a3, a4, &dword_805683D);
}
// 805683D: using guessed type int dword_805683D;

//----- (0804E14D) --------------------------------------------------------
void *__cdecl sub_804E14D(signed int a1, unsigned int a2, int a3)
{
  unsigned int v4[14]; // [esp+10h] [ebp-38h]

  sub_804C9BB(v4, a2);
  return sub_804DDEB(a1, a3, -1, v4);
}

//----- (0804E18B) --------------------------------------------------------
void *__cdecl sub_804E18B(signed int a1, unsigned int a2, int a3, int a4)
{
  unsigned int v5[14]; // [esp+10h] [ebp-38h]

  sub_804C9BB(v5, a2);
  return sub_804DDEB(a1, a3, a4, v5);
}

//----- (0804E261) --------------------------------------------------------
void *__cdecl sub_804E261(int a1, int a2, char a3)
{
  int v4; // [esp+0h] [ebp-58h]
  char v5; // [esp+1Ch] [ebp-3Ch]
  int v6; // [esp+20h] [ebp-38h]
  int v7; // [esp+24h] [ebp-34h]
  int v8; // [esp+28h] [ebp-30h]
  int v9; // [esp+2Ch] [ebp-2Ch]
  int v10; // [esp+30h] [ebp-28h]
  int v11; // [esp+34h] [ebp-24h]
  int v12; // [esp+38h] [ebp-20h]
  int v13; // [esp+3Ch] [ebp-1Ch]
  int v14; // [esp+40h] [ebp-18h]
  int v15; // [esp+44h] [ebp-14h]
  int v16; // [esp+48h] [ebp-10h]
  int v17; // [esp+4Ch] [ebp-Ch]

  v5 = a3;
  v6 = dword_805683D;
  v7 = dword_8056841;
  v8 = dword_8056845;
  v9 = dword_8056849;
  v10 = dword_805684D;
  v11 = dword_8056851;
  v12 = dword_8056855;
  v13 = dword_8056859;
  v14 = dword_805685D;
  v15 = dword_8056861;
  v16 = dword_8056865;
  v17 = dword_8056869;
  sub_804C8AB(&v4 - 14, a3, 1);
  return sub_804DDEB(0, a1, a2, &v6);
}
// 804C8AB: using guessed type _DWORD __cdecl sub_804C8AB(_DWORD, _DWORD, _DWORD);
// 805683D: using guessed type int dword_805683D;
// 8056841: using guessed type int dword_8056841;
// 8056845: using guessed type int dword_8056845;
// 8056849: using guessed type int dword_8056849;
// 805684D: using guessed type int dword_805684D;
// 8056851: using guessed type int dword_8056851;
// 8056855: using guessed type int dword_8056855;
// 8056859: using guessed type int dword_8056859;
// 805685D: using guessed type int dword_805685D;
// 8056861: using guessed type int dword_8056861;
// 8056865: using guessed type int dword_8056865;
// 8056869: using guessed type int dword_8056869;

//----- (0804E31B) --------------------------------------------------------
void *__cdecl sub_804E31B(int a1, char a2)
{
  return sub_804E261(a1, -1, a2);
}

//----- (0804E354) --------------------------------------------------------
void *__cdecl sub_804E354(int a1)
{
  return sub_804E31B(a1, 58);
}

//----- (0804E391) --------------------------------------------------------
#error "804E43C: call analysis failed (funcsize=79)"

//----- (0804E490) --------------------------------------------------------
int __cdecl sub_804E490(int a1, int a2, int a3, int a4)
{
  return sub_804E4D0(a1, a2, a3, a4, -1);
}
// 804E4D0: using guessed type int __cdecl sub_804E4D0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804E4D0) --------------------------------------------------------
#error "804E50F: call analysis failed (funcsize=20)"

//----- (0804E514) --------------------------------------------------------
#error "804E595: positive sp value has been found (funcsize=0)"

//----- (0804E60F) --------------------------------------------------------
void *__cdecl sub_804E60F(signed int a1, int a2, int a3)
{
  return sub_804DDEB(a1, a2, a3, &unk_805627C);
}

//----- (0804E66A) --------------------------------------------------------
void *__cdecl sub_804E66A(signed int a1, int a2)
{
  return sub_804E60F(a1, a2, -1);
}

//----- (0804E68C) --------------------------------------------------------
void *__usercall sub_804E68C@<eax>(signed int a1@<ebx>, int a2)
{
  void *v7; // [esp-4h] [ebp-1Ch]

  v7 = sub_804E66A(0, a2);
  __asm { pushfw }
  if ( a1 >= 10 && ((_BYTE)a1 - 1) * (_BYTE)a1 & 1 )
    abort();
  __asm { popfw }
  return v7;
}

//----- (0804E6CC) --------------------------------------------------------
#error "804EBCE: call analysis failed (funcsize=409)"

//----- (0804EDAB) --------------------------------------------------------
int __cdecl sub_804EDAB(FILE *stream, int a2, int a3, int a4, int a5)
{
  int *v5; // eax
  unsigned int i; // [esp+24h] [ebp-34h]
  int v8[12]; // [esp+28h] [ebp-30h]

  for ( i = 0; i <= 9; ++i )
  {
    v5 = (int *)a5;
    a5 += 4;
    v8[i] = *v5;
    if ( !v8[i] )
      break;
  }
  return sub_804E6CC(stream, a2, a3, a4, (int)v8, i);
}
// 804EDAB: using guessed type int var_30[12];

//----- (0804EE21) --------------------------------------------------------
int sub_804EE21(FILE *stream, int a2, int a3, int a4, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a4);
  return sub_804EDAB(stream, a2, a3, a4, (int)va);
}

//----- (0804EF34) --------------------------------------------------------
void *__cdecl sub_804EF34(void *ptr, int a2, int a3)
{
  unsigned int v4; // [esp+1Ch] [ebp-Ch]

  v4 = *(_DWORD *)a2;
  if ( ptr )
  {
    if ( 0x55555554u / a3 <= v4 )
      sub_804F19E();
    v4 += (v4 >> 1) + 1;
  }
  else
  {
    if ( !v4 )
      v4 = (0x40u / a3 == 0) + 0x40u / a3;
    if ( 0x7FFFFFFFu / a3 < v4 )
      sub_804F19E();
  }
  *(_DWORD *)a2 = v4;
  return sub_804F05F(ptr, a3 * v4);
}

//----- (0804EFCB) --------------------------------------------------------
void *__usercall sub_804EFCB@<eax>(signed int a1@<ebx>, size_t size)
{
  void *v6; // eax
  signed int v8; // [esp-Ah] [ebp-22h]
  int v9; // [esp-6h] [ebp-1Eh]
  void *v10; // [esp-4h] [ebp-1Ch]

  v10 = sub_804F01C(size);
  __asm { pushfw }
  v8 = a1;
  if ( a1 >= 10 )
  {
    v6 = &loc_804F011;
    if ( !(((_BYTE)a1 - 1) * (_BYTE)a1 & 1) )
      v6 = &loc_804F016;
    dword_805615C = (int)v6;
    sub_8050FFB(v8, v9);
    abort();
  }
  __asm { popfw }
  return v10;
}
// 8050FFB: using guessed type int __stdcall sub_8050FFB(_DWORD, _DWORD);
// 805615C: using guessed type int dword_805615C;

//----- (0804F01C) --------------------------------------------------------
void *__cdecl sub_804F01C(size_t size)
{
  void *v1; // eax
  bool v2; // zf
  void *v3; // eax
  void *v5; // [esp+1Ch] [ebp-Ch]

  v1 = malloc(size);
  v5 = v1;
  v2 = v1 == 0;
  v3 = &loc_804F04F;
  if ( !v2 )
    v3 = &loc_804F05A;
  dword_80561D4 = (int)v3;
  sub_8050D51();
  if ( size )
    sub_804F19E();
  return v5;
}
// 8050D51: using guessed type int sub_8050D51(void);
// 80561D4: using guessed type int dword_80561D4;

//----- (0804F05F) --------------------------------------------------------
void *__cdecl sub_804F05F(void *ptr, size_t size)
{
  void *v2; // eax
  void *result; // eax
  void *ptra; // [esp+20h] [ebp+8h]

  v2 = &loc_804F084;
  if ( size )
    v2 = &loc_804F09C;
  dword_80561E8 = (int)v2;
  sub_8050CAB();
  if ( ptr )
  {
    free(ptr);
    result = 0;
  }
  else
  {
    ptra = realloc(0, size);
    if ( !ptra )
    {
      if ( size )
        sub_804F19E();
    }
    result = ptra;
  }
  return result;
}
// 8050CAB: using guessed type int sub_8050CAB(void);
// 80561E8: using guessed type int dword_80561E8;

//----- (0804F150) --------------------------------------------------------
void *__cdecl sub_804F150(void *src, size_t n)
{
  void *v2; // eax

  v2 = sub_804F01C(n);
  return memcpy(v2, src, n);
}

//----- (0804F19E) --------------------------------------------------------
void __noreturn sub_804F19E()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (0804F1D7) --------------------------------------------------------
void sub_804F1D7()
{
  ;
}

//----- (0804F1DC) --------------------------------------------------------
void __usercall sub_804F1DC(signed int a1@<ebx>, int a2)
{
  if ( sub_804FDF2(a1, a2) < 0 )
    sub_804F1D7();
}

//----- (0804F1FF) --------------------------------------------------------
unsigned __int64 __usercall sub_804F1FF@<edx:eax>(signed int a1@<ebx>, char *nptr, int base, int a4, int a5, int a6, int a7, char *s, int a9, int status)
{
  void *v10; // eax
  char *v11; // ebx
  int v12; // edx
  signed int v13; // eax
  int v15; // [esp+0h] [ebp-48h]
  int *v16; // [esp+Ch] [ebp-3Ch]
  char *v17; // [esp+10h] [ebp-38h]
  unsigned __int64 v18; // [esp+20h] [ebp-28h]
  unsigned __int64 v19; // [esp+28h] [ebp-20h]
  int v20; // [esp+34h] [ebp-14h]
  unsigned __int64 v21; // [esp+38h] [ebp-10h]

  v19 = __PAIR__(a5, a4);
  v18 = __PAIR__(a7, a6);
  v17 = s;
  v16 = &v15 - 4;
  v20 = sub_804F4FB(nptr, 0, base);
  if ( v20 )
  {
    if ( v20 == 1 )
    {
      *__errno_location() = 75;
      dword_8056134 = (int)&loc_804F2FA;
      sub_80510E5();
    }
    if ( v20 == 3 )
      *__errno_location() = 0;
  }
  else if ( v21 < v19 || v18 < v21 )
  {
    v20 = 1;
    if ( v21 <= 0x3FFFFFFF )
      *__errno_location() = 34;
    else
      *__errno_location() = 75;
  }
  v10 = &loc_804F319;
  if ( !v20 )
    v10 = &loc_804F36F;
  dword_80561E8 = (int)v10;
  sub_8050CAB();
  v11 = (char *)sub_804E68C(a1, (int)nptr);
  if ( *__errno_location() == 22 )
    v12 = 0;
  else
    v12 = *__errno_location();
  if ( status )
    v13 = status;
  else
    v13 = 1;
  v17 = v11;
  v16 = (int *)a9;
  error(v13, v12, "%s: %s", a9, v11);
  return v21;
}
// 8050CAB: using guessed type int sub_8050CAB(void);
// 80510E5: using guessed type int sub_80510E5(void);
// 8056134: using guessed type int dword_8056134;
// 80561E8: using guessed type int dword_80561E8;

//----- (0804F37B) --------------------------------------------------------
unsigned __int64 __usercall sub_804F37B@<edx:eax>(signed int a1@<ebx>, char *nptr, int a3, int a4, int a5, int a6, char *s, int a8, int status)
{
  return sub_804F1FF(a1, nptr, 10, a3, a4, a5, a6, s, a8, status);
}

//----- (0804F3EF) --------------------------------------------------------
#error "804F420: call analysis failed (funcsize=20)"

//----- (0804F425) --------------------------------------------------------
#error "804F4C0: positive sp value has been found (funcsize=47)"

//----- (0804F4C5) --------------------------------------------------------
int __cdecl sub_804F4C5(int a1, int a2, int a3)
{
  int v3; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; ; i |= sub_804F3EF(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}
// 804F3EF: using guessed type _DWORD __cdecl sub_804F3EF(_DWORD, _DWORD);

//----- (0804F4FB) --------------------------------------------------------
int __cdecl sub_804F4FB(char *nptr, int a2, int base)
{
  bool v3; // zf
  void *v4; // eax
  void *v5; // eax
  int v7; // [esp+0h] [ebp-48h]
  int v8; // [esp+4h] [ebp-44h]
  unsigned __int8 v9; // [esp+1Bh] [ebp-2Dh]
  int v10; // [esp+20h] [ebp-28h]
  char *v11; // [esp+24h] [ebp-24h]
  char **endptr; // [esp+34h] [ebp-14h]

  v10 = 0;
  if ( base < 0 || base > 36 )
LABEL_5:
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoumax");
  if ( !a2 )
  {
    dword_8056134 = (int)&loc_804F555;
    sub_80510E5();
    goto LABEL_5;
  }
  endptr = (char **)a2;
  *__errno_location() = 0;
  v11 = nptr;
  v9 = *nptr;
  v3 = ((*__ctype_b_loc())[v9] & 0x2000) == 0;
  v4 = &loc_804F5C0;
  if ( !v3 )
    v4 = &loc_804F57C;
  dword_805615C = (int)v4;
  sub_8050FFB(v7, v8);
  v5 = &loc_804F5DF;
  if ( v9 != 45 )
    v5 = &loc_804F5E9;
  dword_80561C0 = (int)v5;
  sub_8050DC7();
  return 4;
}
// 804F4FB: could not find valid save-restore pair for ebx
// 8050DC7: using guessed type int sub_8050DC7(void);
// 8050FFB: using guessed type int __stdcall sub_8050FFB(_DWORD, _DWORD);
// 80510E5: using guessed type int sub_80510E5(void);
// 8056134: using guessed type int dword_8056134;
// 805615C: using guessed type int dword_805615C;
// 80561C0: using guessed type int dword_80561C0;

//----- (0804F9FB) --------------------------------------------------------
#error "804FA7A: call analysis failed (funcsize=85)"

//----- (0804FB0E) --------------------------------------------------------
int __usercall sub_804FB0E@<eax>(signed int a1@<ebx>, unsigned int *a2)
{
  void *v2; // eax
  char v3; // cf
  bool v4; // zf
  char v5; // sf
  char v6; // of

  v2 = &loc_804FB3B;
  if ( !(*a2 & 0x100) )
    v2 = &locret_804FB5E;
  dword_80561D4 = (int)v2;
  sub_8050D51();
  return sub_804FBA0(v3, v4, v5, v6, (int)a2, a1, a2, 0, 0);
}
// 8050D51: using guessed type int sub_8050D51(void);
// 80561D4: using guessed type int dword_80561D4;

//----- (0804FB60) --------------------------------------------------------
int __usercall sub_804FB60@<eax>(signed int a1@<ebx>, FILE *fp)
{
  if ( !fp || !__freading(fp) )
    return fflush(fp);
  sub_804FB0E(a1, (unsigned int *)fp);
  return fflush(fp);
}

//----- (0804FBA0) --------------------------------------------------------
int __usercall sub_804FBA0@<eax>(char _CF@<cf>, bool _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>, unsigned int *a7, int a8, int a9)
{
  char v9; // al
  int v10; // ebx
  int v11; // eax
  void *v12; // eax
  int v13; // eax
  int v14; // edx
  FILE *v15; // edx
  unsigned int v16; // edx
  signed int v17; // eax
  int result; // eax
  char v23; // al
  int v24; // ebx
  int v25; // eax
  void *v26; // eax
  unsigned int v27; // edx
  FILE *stream; // [esp+0h] [ebp-3Ch]
  int v29; // [esp+4h] [ebp-38h]
  FILE *v30; // [esp+8h] [ebp-34h]
  int v31; // [esp+Ch] [ebp-30h]
  int v32; // [esp+10h] [ebp-2Ch]
  int v33; // [esp+14h] [ebp-28h]
  int v34; // [esp+18h] [ebp-24h]
  int v35; // [esp+1Ch] [ebp-20h]
  int v36; // [esp+20h] [ebp-1Ch]
  int v37; // [esp+24h] [ebp-18h]
  char v38[6]; // [esp+28h] [ebp-14h]
  int v39; // [esp+2Eh] [ebp-Eh]
  int v40; // [esp+32h] [ebp-Ah]
  char v41[6]; // [esp+36h] [ebp-6h]

  *(_DWORD *)&v41[2] = a5;
  __asm { pushfw }
  if ( a6 >= 10 )
  {
    v9 = a6;
    v10 = a6 - 1;
    v11 = (_BYTE)v10 * v9 & 1;
    _ZF = v11 == 0;
    v39 = v11;
    *(_DWORD *)&v38[2] = v10;
    v12 = &loc_804FBD5;
    if ( _ZF )
      v12 = &loc_804FBDA;
    dword_80561AC = (int)v12;
    sub_8050E3D(v40, *(_DWORD *)v41);
    abort();
  }
  __asm { popfw }
  v34 = a8;
  v35 = a9;
  if ( v30->_IO_read_end != v30->_IO_read_ptr || v30->_IO_write_ptr != v30->_IO_write_base || v30->_IO_save_base )
  {
    v31 = v33;
    result = fseeko64(
               *(&stream - 7),
               *(&stream - 8),
               *(&stream - 7),
               v33,
               v32,
               v33,
               v34,
               v35,
               v36,
               v37,
               *(_DWORD *)v38,
               *(_DWORD *)&v38[4],
               *(int *)((char *)&v39 + 2),
               *(int *)((char *)&v40 + 2));
  }
  else
  {
    v13 = fileno(v30);
    v31 = v33;
    v14 = (int)*(&stream - 7);
    v29 = (int)*(&stream - 8);
    *(&stream - 4) = (FILE *)lseek64(
                               v13,
                               v29,
                               v14,
                               v33,
                               v32,
                               v33,
                               v34,
                               v35,
                               v36,
                               v37,
                               *(_DWORD *)v38,
                               *(_DWORD *)&v38[4],
                               *(int *)((char *)&v39 + 2),
                               *(int *)((char *)&v40 + 2));
    *(&stream - 3) = v15;
    v16 = ~(unsigned int)*(&stream - 3);
    v17 = v16 | ~(unsigned int)*(&stream - 4);
    _CF = 0;
    _OF = 0;
    _ZF = v17 == 0;
    _SF = v17 < 0;
    if ( v17 )
    {
      *(int *)((char *)&v40 + 2) = v16 | ~(unsigned int)*(&stream - 4);
      __asm { pushfw }
      v39 = a6;
      if ( a6 >= 10 )
      {
        v23 = a6;
        v24 = a6 - 1;
        v25 = (_BYTE)v24 * v23 & 1;
        _ZF = v25 == 0;
        *(_DWORD *)&v38[2] = v25;
        *(int *)((char *)&v37 + 2) = v24;
        v26 = &loc_804FCB9;
        if ( _ZF )
          v26 = &loc_804FCBE;
        dword_8056184 = (int)v26;
        sub_8050F21(v39);
        abort();
      }
      __asm { popfw }
      *a7 = v30->_flags & 0xFFFFFFEF;
      v27 = *(_DWORD *)&v38[4];
      a7[19] = *(_DWORD *)v38;
      a7[20] = v27;
      result = 0;
    }
    else
    {
      result = -1;
    }
  }
  return result;
}
// 8048DE0: using guessed type int __stdcall fseeko64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8049050: using guessed type int __stdcall lseek64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8050E3D: using guessed type int __stdcall sub_8050E3D(_DWORD, _DWORD);
// 8050F21: using guessed type int __stdcall sub_8050F21(_DWORD);
// 8056184: using guessed type int dword_8056184;
// 80561AC: using guessed type int dword_80561AC;

//----- (0804FD19) --------------------------------------------------------
size_t __cdecl sub_804FD19(wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  bool v4; // zf
  void *v5; // eax
  int v7; // [esp+0h] [ebp-28h]
  int v8; // [esp+4h] [ebp-24h]
  unsigned __int8 v9; // [esp+17h] [ebp-11h]
  char v10; // [esp+18h] [ebp-10h]
  size_t v11; // [esp+1Ch] [ebp-Ch]

  if ( !pwc )
    pwc = (wchar_t *)&v10;
  v11 = mbrtowc(pwc, s, n, p);
  if ( v11 > 0xFFFFFFFD && n )
  {
    v4 = (unsigned __int8)sub_804FF24(0) == 1;
    v5 = &loc_804FD86;
    if ( v4 )
      v5 = &loc_804FDB4;
    dword_805615C = (int)v5;
    sub_8050FFB(v7, v8);
    v9 = *s;
    *pwc = v9;
    dword_80561D4 = (int)&locret_804FDB7;
    sub_8050D51();
  }
  return v11;
}
// 8050D51: using guessed type int sub_8050D51(void);
// 8050FFB: using guessed type int __stdcall sub_8050FFB(_DWORD, _DWORD);
// 805615C: using guessed type int dword_805615C;
// 80561D4: using guessed type int dword_80561D4;

//----- (0804FDB9) --------------------------------------------------------
int sub_804FDB9()
{
  return 0;
}

//----- (0804FDC3) --------------------------------------------------------
int __usercall sub_804FDC3@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed int a6@<ebx>)
{
  int v7; // [esp-4h] [ebp-4h]

  v7 = a5;
  __asm { pushfw }
  if ( a6 >= 10 && ((_BYTE)a6 - 1) * (_BYTE)a6 & 1 )
    abort();
  __asm { popfw }
  return 0;
}

//----- (0804FDF2) --------------------------------------------------------
int __usercall sub_804FDF2@<eax>(signed int a1@<ebx>, int a2)
{
  char v2; // sf
  int result; // eax
  int v4; // [esp+14h] [ebp-4h]

  v4 = sub_804FDC3(0, 0, v2, 0, a2, a1);
  if ( v4 )
    result = v4;
  else
    result = sub_804FDB9();
  return result;
}

//----- (0804FE25) --------------------------------------------------------
int __cdecl sub_804FE25(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // esi
  unsigned __int8 *v3; // ebx
  unsigned __int8 v5; // [esp+1Eh] [ebp-Ah]
  unsigned __int8 v6; // [esp+1Fh] [ebp-9h]

  v2 = a1;
  v3 = a2;
  if ( a1 == a2 )
    return 0;
  do
  {
    v5 = sub_805081F(*v2);
    v6 = sub_805081F(*v3);
    if ( !v5 )
      break;
    ++v2;
    ++v3;
  }
  while ( v5 == v6 );
  return v5 - v6;
}

//----- (0804FE8A) --------------------------------------------------------
int __cdecl sub_804FE8A(FILE *fp)
{
  bool v1; // ST26_1
  void *v2; // eax
  bool v4; // [esp+1Dh] [ebp-Bh]
  bool v5; // [esp+1Fh] [ebp-9h]

  v4 = __fpending(fp) != 0;
  v1 = ferror_unlocked(fp) != 0;
  v5 = sub_804F9FB(fp) != 0;
  v2 = &loc_804FEE8;
  if ( v1 )
    v2 = &loc_804FF00;
  dword_80561D4 = (int)v2;
  sub_8050D51();
  if ( !v5 || !v4 && *__errno_location() == 9 )
    return 0;
  if ( v5 != 1 )
    *__errno_location() = 0;
  return -1;
}
// 8050D51: using guessed type int sub_8050D51(void);
// 80561D4: using guessed type int dword_80561D4;

//----- (0804FF24) --------------------------------------------------------
int __cdecl sub_804FF24(int category)
{
  unsigned __int8 v2; // [esp+1Bh] [ebp-Dh]
  const char *s1; // [esp+1Ch] [ebp-Ch]

  v2 = 1;
  s1 = setlocale(category, 0);
  if ( s1 && (!strcmp(s1, "C") || !strcmp(s1, "POSIX")) )
    v2 = 0;
  return v2;
}

//----- (0804FF82) --------------------------------------------------------
#error "80500E5: call analysis failed (funcsize=117)"

//----- (0805050D) --------------------------------------------------------
const char *sub_805050D()
{
  char *v0; // ST1C_4
  const char *s1; // [esp+18h] [ebp-10h]
  char *s2; // [esp+1Ch] [ebp-Ch]

  s1 = nl_langinfo(14);
  if ( !s1 )
    s1 = (const char *)&unk_80524A7;
  for ( s2 = (char *)sub_804FF82(); *s2; s2 = &v0[strlen(v0) + 1] )
  {
    if ( !strcmp(s1, s2) || *s2 == 42 && !s2[1] )
    {
      s1 = &s2[strlen(s2) + 1];
      break;
    }
    v0 = &s2[strlen(s2) + 1];
  }
  if ( !*s1 )
    s1 = "ASCII";
  return s1;
}
// 804FF82: using guessed type int sub_804FF82(void);

//----- (0805065D) --------------------------------------------------------
signed int sub_805065D()
{
  return -774;
}

//----- (0805081F) --------------------------------------------------------
int __cdecl sub_805081F(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 65) > 0x19 )
    result = a1;
  else
    result = a1 + 32;
  return result;
}

//----- (08050857) --------------------------------------------------------
int __cdecl sub_8050857(unsigned __int64 a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // esi
  int result; // eax
  int v5; // ebp
  int v6; // ebp
  unsigned __int64 v7; // rtt
  unsigned int v8; // esi
  int v9; // edi
  unsigned __int64 v10; // rax
  unsigned int v11; // [esp+0h] [ebp-18h]
  unsigned int v12; // [esp+4h] [ebp-14h]
  unsigned int v13; // [esp+8h] [ebp-10h]

  v12 = a1;
  v11 = a2;
  if ( !a3 )
  {
    if ( a2 > HIDWORD(a1) )
      return a1 / a2;
    v3 = a2;
    if ( !a2 )
      v3 = 1 / 0u;
    return __PAIR__(HIDWORD(a1) % v3, (unsigned int)a1) / v3;
  }
  if ( a3 > HIDWORD(a1) )
    return 0;
  _BitScanReverse((unsigned int *)&v5, a3);
  v6 = v5 ^ 0x1F;
  if ( !v6 )
  {
    if ( v11 <= v12 || a3 < HIDWORD(a1) )
      return 1;
    return 0;
  }
  v13 = (a3 << v6) | (v11 >> (32 - v6));
  v11 <<= (unsigned int)&v11;
  LODWORD(v7) = (HIDWORD(a1) << (char)&v11) | (v12 >> (32 - v6));
  HIDWORD(v7) = HIDWORD(a1) >> (32 - v6);
  v8 = v7 % v13;
  v9 = v7 / v13;
  v10 = v11 * (unsigned __int64)(unsigned int)v9;
  v11 = HIDWORD(v10);
  if ( v8 < HIDWORD(v10) || v12 << (char)&v11 < (unsigned int)v10 && v8 == v11 )
    result = v9 - 1;
  else
    result = v9;
  return result;
}

//----- (080509EE) --------------------------------------------------------
#error "8050A27: positive sp value has been found (funcsize=18)"

//----- (08050A3D) --------------------------------------------------------
int __cdecl sub_8050A3D(int a1)
{
  return __cxa_atexit(a1, 0, dword_8056240);
}
// 8048EB0: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 8056240: using guessed type int dword_8056240;

//----- (08050AB4) --------------------------------------------------------
#error "8050AED: positive sp value has been found (funcsize=18)"

//----- (08050BC1) --------------------------------------------------------
#error "8050BC7: positive sp value has been found (funcsize=0)"

//----- (08050C37) --------------------------------------------------------
#error "8050C3D: positive sp value has been found (funcsize=0)"

//----- (08050CAB) --------------------------------------------------------
#error "8050CB1: positive sp value has been found (funcsize=0)"

//----- (08050D10) --------------------------------------------------------
#error "8050D49: positive sp value has been found (funcsize=18)"

//----- (08050D51) --------------------------------------------------------
#error "8050D57: positive sp value has been found (funcsize=0)"

//----- (08050DC7) --------------------------------------------------------
#error "8050DCD: positive sp value has been found (funcsize=0)"

//----- (08050E3D) --------------------------------------------------------
#error "8050E43: positive sp value has been found (funcsize=0)"

//----- (08050EAF) --------------------------------------------------------
#error "8050EB5: positive sp value has been found (funcsize=0)"

//----- (08050F21) --------------------------------------------------------
#error "8050F27: positive sp value has been found (funcsize=0)"

//----- (08050F8D) --------------------------------------------------------
#error "8050F93: positive sp value has been found (funcsize=0)"

//----- (08050FFB) --------------------------------------------------------
#error "8051001: positive sp value has been found (funcsize=0)"

//----- (0805106F) --------------------------------------------------------
#error "8051075: positive sp value has been found (funcsize=0)"

//----- (080510E5) --------------------------------------------------------
#error "80510EB: positive sp value has been found (funcsize=0)"

//----- (08051151) --------------------------------------------------------
#error "8051157: positive sp value has been found (funcsize=0)"

//----- (080511C9) --------------------------------------------------------
#error "80511CF: positive sp value has been found (funcsize=0)"

//----- (080511E0) --------------------------------------------------------
int (**sub_80511E0())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_8055EC4;
  v1 = &off_8055EC8 - off_8055EC4;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_8055EC4[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 8055EC4: using guessed type int (*off_8055EC4[2])();
// 8055EC8: using guessed type int (*off_8055EC8)();

//----- (08051244) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 34 decompilation failure(s) on 165 function(s)"
