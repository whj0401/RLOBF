/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8048D10();
// int strcmp(const char *s1, const char *s2);
// int open64(void); weak
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void _exit(int status);
// void *memmove(void *dest, const void *src, size_t n);
// void free(void *ptr);
// uintmax_t strtoumax(const char *nptr, char **endptr, int base);
// void *memcpy(void *dest, const void *src, size_t n);
// int mbsinit(const mbstate_t *ps);
// int fclose(FILE *stream);
// int getc_unlocked(FILE *stream);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// int fputc_unlocked(int c, FILE *stream);
// int iswprint(wint_t wc);
// int ferror_unlocked(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// size_t __ctype_get_mb_cur_max(void);
// size_t __fpending(FILE *fp);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// void error(int status, int errnum, const char *format, ...);
// size_t fread_unlocked(void *ptr, size_t size, size_t n, FILE *stream);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// char *strchr(const char *s, int c);
// size_t strlen(const char *s);
// int fprintf(FILE *stream, const char *format, ...);
// void *memset(void *s, int c, size_t n);
// int *__errno_location(void);
// void *memchr(const void *s, int c, size_t n);
// int fileno(FILE *stream);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// char *strrchr(const char *s, int c);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// int feof_unlocked(FILE *stream);
// void abort(void);
// int close(int fd);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// int _gmon_start__(void); weak
void sub_8049133();
void sub_8049150();
int sub_8049160();
int sub_80491D0();
int sub_80491F0();
void sub_804924F();
void sub_804926A();
int sub_804927A();
int sub_8049304();
void sub_8049378();
void sub_8049393();
signed int sub_80493A3();
void sub_8049485();
void sub_80494A0();
int sub_80494B0();
void sub_8049592();
void sub_80495AD();
int sub_80495BD();
void sub_80496B1();
void sub_80496CC();
int sub_80496DC();
void sub_80497BE();
void sub_80497D9();
int sub_80497E9();
void sub_80498CB();
void sub_80498E6();
int sub_80498F6();
int nullsub_3(void); // weak
int sub_8049954();
void sub_80499F4();
void sub_8049A0F();
int sub_8049A1F();
void sub_8049B1D();
void sub_8049B38();
int sub_8049B48();
void sub_8049C2A();
void sub_8049C45();
int sub_8049C55();
int nullsub_4(); // weak
// int __usercall sub_8049CB3@<eax>(int a1@<ecx>, int a2@<ebp>);
int sub_8049D11();
void sub_8049D85();
void sub_8049DA0();
int sub_8049DB0();
void sub_8049EA7();
void sub_8049EC2();
int sub_8049ED2();
void sub_8049FB4();
void sub_8049FCF();
void sub_804A0DA();
void sub_804A0F5();
int sub_804A105();
int sub_804A1A8();
void sub_804A21C();
void sub_804A237();
int sub_804A247();
int nullsub_5(); // weak
// int __usercall sub_804A2A5@<eax>(int a1@<ebp>);
void __spoils<edx,ecx> sub_804A370();
void sub_804A3AA();
signed int sub_804A3BA();
signed int sub_804A444();
void sub_804A4B8();
void sub_804A4D3();
int sub_804A4E3();
int sub_804A593();
int sub_804A5BE();
int __cdecl sub_804A5E9(_DWORD); // weak
int __cdecl sub_804A634(char *s2, size_t n); // idb
void __cdecl __noreturn sub_804A7C6(int status); // idb
_DWORD __cdecl sub_804A8D7(_DWORD, _DWORD, __int64); // weak
int __cdecl sub_804A913(size_t size, size_t n, FILE *stream); // idb
// unsigned int __usercall sub_804AACD@<eax>(int a1@<ebx>, FILE *a2, FILE *a3, __int64 a4);
// int __usercall __noreturn sub_804ADA8@<eax>(char *a1@<ebx>, FILE *a2, FILE *a3, char a4);
int sub_804B136(); // weak
// void __usercall __noreturn main(int a1@<edx>, int a2@<ecx>, int argc, char **argv);
int __cdecl sub_804B5B8(unsigned __int8 a1);
void __cdecl sub_804B5CA(int a1, int a2, _BYTE *a3, int a4);
char __cdecl sub_804BA8E(unsigned __int8 a1);
_DWORD *__cdecl sub_804BAB7(_DWORD *a1);
int __cdecl sub_804BAC5(size_t n); // idb
_DWORD __cdecl sub_804BC00(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_804C22C(size_t n, int, int, int, int); // idb
int sub_804C5B1();
int __cdecl sub_804C6CF(int a1, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_804C730@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, FILE *stream, int a7);
void __fastcall __noreturn sub_804C797(int a1, int a2, int a3);
int __cdecl sub_804C7E6(int c, size_t n); // idb
int __cdecl sub_804C98E(int a1, unsigned __int8 a2, char a3);
void __cdecl __noreturn sub_804CA7C(int *a1, int a2, int a3);
int sub_804CAC2(); // weak
// _DWORD *__userpurge sub_804CAD6@<eax>(_DWORD *a1, int a2);
char *__cdecl sub_804CB78(char *msgid);
_DWORD __cdecl sub_804CC5D(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
void *__cdecl sub_804DBCD(int a1, int a2, _DWORD *a3, int *a4);
_DWORD __cdecl sub_804DDDB();
int __cdecl sub_804E072();
// int __usercall sub_804E09C@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>);
// int __usercall sub_804E131@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, int a6, int a7);
void __cdecl __noreturn sub_804E18E(int a1, int a2);
int __cdecl sub_804E26E(int a1, int a2, unsigned __int8 a3);
int __cdecl sub_804E328(int a1, unsigned __int8 a2);
int __cdecl sub_804E361(int a1);
void __cdecl __noreturn sub_804E464(int a1, int a2, int a3, int a4);
void __cdecl __noreturn sub_804E4A4(int a1, int a2, int a3);
int __cdecl sub_804E5CE();
int __cdecl sub_804E629();
int __cdecl sub_804E64B();
int __cdecl sub_804E666(FILE *stream, int, int, int, int, int); // idb
int __cdecl sub_804ECC0(FILE *stream, int, int, int, int); // idb
int sub_804ED6D(int a1, FILE *stream, int a3, int a4, int a5, ...);
int __cdecl sub_804EE73(void *ptr, int, int); // idb
void *__cdecl sub_804EF42(size_t size);
void *__cdecl sub_804EF55(size_t size);
void *__cdecl sub_804EF9E(void *ptr, size_t size);
signed int sub_804F095();
int sub_804F09F(void); // weak
void *__cdecl sub_804F0A0(void *src, size_t n);
void __noreturn sub_804F0EE();
void sub_804F127();
// int __usercall sub_804F12C@<eax>(signed int a1@<ebx>, int *a2);
// unsigned __int64 __usercall sub_804F174@<edx:eax>(int a1@<edx>, int a2@<ecx>, char *nptr, int base, int a5, int a6, int a7, int a8, char *s, int a10, int status);
unsigned __int64 __cdecl sub_804F2DB(char *nptr, int a2, int a3, int a4, int a5, char *s, int a7, int status);
signed int __cdecl sub_804F34F(int a1, signed int a2);
int __cdecl sub_804F3FB(int a1, signed int a2, int a3);
// int __usercall sub_804F431@<eax>(int a1@<edx>, int a2@<ecx>, char *nptr, int a4, int base, int a6, char *s);
// int __usercall sub_804F8A5@<eax>(signed int a1@<ebx>, FILE *stream);
int __cdecl sub_804F98D(FILE *stream); // idb
int __cdecl sub_804F9DF(FILE *fp); // idb
int __cdecl sub_804FA57(FILE *stream, int, int, int); // idb
int __cdecl sub_804FB7B(wchar_t *pwc, char *s, size_t n, mbstate_t *p); // idb
int sub_804FC25();
int sub_804FC2F();
// int __usercall sub_804FC39@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int *a5@<eax>);
int __cdecl sub_804FC8B(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_804FCF0(FILE *fp); // idb
int __cdecl sub_804FDA3(int category); // idb
void *sub_804FE01();
const char *sub_8050338();
int __cdecl sub_805065B(int a1);
signed __int64 __cdecl sub_8050693(unsigned __int64 a1, unsigned int a2, unsigned int a3);
int __cdecl sub_80508A4(int a1);
int __fastcall sub_8050A4B(_DWORD, _DWORD); // weak
int __stdcall sub_8050AC3(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int sub_8050B65(void); // weak
int sub_8050BD5(void); // weak
int __stdcall sub_8050C64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_8050CDE(_DWORD); // weak
int __stdcall sub_8050D58(_DWORD); // weak
int __stdcall sub_8050DC8(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __fastcall sub_8050E36(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int sub_8050EAE(void); // weak
int __fastcall sub_8050F26(_DWORD, _DWORD); // weak
int sub_8050F92(void); // weak
int sub_8051002(void); // weak
int sub_805107A(void); // weak
int (**sub_8051090())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN locret_804A114; // weak
_UNKNOWN loc_804A8CC; // weak
_UNKNOWN loc_804ABD9; // weak
_UNKNOWN loc_804AC8D; // weak
_UNKNOWN loc_804ACEC; // weak
_UNKNOWN loc_804AD0F; // weak
_UNKNOWN loc_804AD53; // weak
_UNKNOWN loc_804AFD1; // weak
_UNKNOWN loc_804AFE0; // weak
_UNKNOWN loc_804B131; // weak
_UNKNOWN loc_804B6D7; // weak
_UNKNOWN loc_804B6FC; // weak
_UNKNOWN loc_804B790; // weak
_UNKNOWN loc_804B7B5; // weak
_UNKNOWN loc_804B7BA; // weak
_UNKNOWN loc_804B9BE; // weak
_UNKNOWN loc_804C5E2; // weak
_UNKNOWN loc_804C6AB; // weak
_UNKNOWN loc_804C7BC; // weak
_UNKNOWN loc_804C9C7; // weak
_UNKNOWN loc_804CABD; // weak
_UNKNOWN loc_804CBAD; // weak
_UNKNOWN loc_804CBB5; // weak
_UNKNOWN loc_804E1D2; // weak
_UNKNOWN sub_804E1DB; // weak
_UNKNOWN loc_804F1ED; // weak
_UNKNOWN loc_804F24F; // weak
_UNKNOWN loc_804F463; // weak
_UNKNOWN loc_804F46B; // weak
_UNKNOWN loc_804F539; // weak
_UNKNOWN loc_804F573; // weak
_UNKNOWN loc_804F85D; // weak
_UNKNOWN locret_804F8A3; // weak
_UNKNOWN loc_804F9BA; // weak
_UNKNOWN locret_804F9DD; // weak
_UNKNOWN loc_804FA13; // weak
_UNKNOWN loc_804FA3F; // weak
_UNKNOWN loc_804FAC4; // weak
_UNKNOWN loc_804FB59; // weak
_UNKNOWN locret_804FB79; // weak
_UNKNOWN loc_80500C4; // weak
_UNKNOWN loc_80500FA; // weak
_UNKNOWN loc_8050103; // weak
_UNKNOWN loc_8050116; // weak
_UNKNOWN loc_80502A3; // weak
_UNKNOWN loc_80503A0; // weak
_UNKNOWN loc_80503C6; // weak
_UNKNOWN loc_80503DE; // weak
_UNKNOWN loc_805072A; // weak
_UNKNOWN loc_80507CD; // weak
_UNKNOWN loc_80507F9; // weak
char byte_80517F0[256] =
{
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\x1A',
  '\x1B',
  '\x1C',
  '\x1D',
  '\x1E',
  '\x1F',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\x01',
  '\x02',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\n',
  '\v',
  '\f',
  '\r',
  '\x0E',
  '\x0F',
  '\x10',
  '\x11',
  '\x12',
  '\x13',
  '\x14',
  '\x15',
  '\x16',
  '\x17',
  '\x18',
  '\x19',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF'
}; // idb
char byte_80518F0[32] =
{
  'A',
  'B',
  'C',
  'D',
  'E',
  'F',
  'G',
  'H',
  'I',
  'J',
  'K',
  'L',
  'M',
  'N',
  'O',
  'P',
  'Q',
  'R',
  'S',
  'T',
  'U',
  'V',
  'W',
  'X',
  'Y',
  'Z',
  '2',
  '3',
  '4',
  '5',
  '6',
  '7'
}; // idb
_UNKNOWN unk_8052357; // weak
_UNKNOWN unk_80531BC; // weak
_UNKNOWN unk_80531BF; // weak
int (*off_8055EC4[2])() = { &sub_80491F0, &sub_80491D0 }; // weak
int (*off_8055EC8)() = &sub_80491D0; // weak
int (*dword_8056008)(void) = NULL; // weak
int dword_805610C = 0; // weak
int dword_8056120 = 0; // weak
int dword_8056134 = 0; // weak
int dword_8056148 = 0; // weak
int dword_805615C = 0; // weak
int dword_8056170 = 0; // weak
int dword_8056184 = 0; // weak
int dword_8056198 = 0; // weak
int dword_80561AC = 0; // weak
int dword_80561C0 = 0; // weak
int dword_80561D4 = 0; // weak
int dword_80561E8 = 0; // weak
int dword_80561FC = 0; // weak
int dword_8056210 = 0; // weak
int dword_8056240 = 0; // weak
int status = 1; // idb
_UNKNOWN unk_805627C; // weak
_UNKNOWN unk_8056298; // weak
_UNKNOWN unk_805629B; // weak
_UNKNOWN unk_80562A0; // weak
_UNKNOWN unk_80562A3; // weak
_UNKNOWN unk_80562AC; // weak
_UNKNOWN unk_80562AF; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
FILE *stdout; // idb
char byte_805630C; // weak
char byte_8056359; // weak
_UNKNOWN unk_80564DE; // weak
char byte_805660E; // weak
char byte_8056742; // weak
char byte_80567DC; // weak
int dword_805682D; // weak
char byte_8056831; // weak
int dword_8056835; // weak
int dword_805683D[]; // weak
int dword_8056841; // weak
int dword_8056845; // weak
int dword_8056849; // weak
int dword_805684D; // weak
int dword_8056851; // weak
int dword_8056855; // weak
int dword_8056859; // weak
int dword_805685D; // weak
int dword_8056861; // weak
int dword_8056865; // weak
int dword_8056869; // weak
int dword_805697D; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (08048CE0) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 80490F0: using guessed type int _gmon_start__(void);

//----- (08048D10) --------------------------------------------------------
int sub_8048D10()
{
  return dword_8056008();
}
// 8056008: using guessed type int (*dword_8056008)(void);

//----- (08049100) --------------------------------------------------------
#error "8049103: positive sp value has been found (funcsize=2)"

//----- (08049133) --------------------------------------------------------
void sub_8049133()
{
  ;
}

//----- (08049150) --------------------------------------------------------
void sub_8049150()
{
  ;
}

//----- (08049160) --------------------------------------------------------
int sub_8049160()
{
  int result; // eax

  result = &unk_80562AF - &unk_80562AC;
  if ( (unsigned int)(&unk_80562AF - &unk_80562AC) > 6 )
    result = 0;
  return result;
}
// 8049160: could not find valid save-restore pair for ebp

//----- (080491D0) --------------------------------------------------------
int sub_80491D0()
{
  int result; // eax

  if ( !byte_805630C )
  {
    result = sub_8049160();
    byte_805630C = 1;
  }
  return result;
}
// 80491D0: could not find valid save-restore pair for ebp
// 805630C: using guessed type char byte_805630C;

//----- (080491F0) --------------------------------------------------------
int sub_80491F0()
{
  return 0;
}
// 80491F0: could not find valid save-restore pair for ebp

//----- (0804924F) --------------------------------------------------------
void sub_804924F()
{
  ;
}

//----- (0804926A) --------------------------------------------------------
void sub_804926A()
{
  ;
}

//----- (0804927A) --------------------------------------------------------
int sub_804927A()
{
  int result; // eax

  result = &unk_805629B - &unk_8056298;
  if ( (unsigned int)(&unk_805629B - &unk_8056298) > 6 )
    result = 0;
  return result;
}
// 804927A: could not find valid save-restore pair for ebp

//----- (08049304) --------------------------------------------------------
int sub_8049304()
{
  int result; // eax

  result = sub_804927A();
  byte_8056359 = 1;
  return result;
}
// 8056359: using guessed type char byte_8056359;

//----- (08049378) --------------------------------------------------------
void sub_8049378()
{
  ;
}

//----- (08049393) --------------------------------------------------------
void sub_8049393()
{
  ;
}

//----- (080493A3) --------------------------------------------------------
signed int sub_80493A3()
{
  return 3;
}
// 80493A3: could not find valid save-restore pair for ebp

//----- (08049485) --------------------------------------------------------
void sub_8049485()
{
  ;
}

//----- (080494A0) --------------------------------------------------------
void sub_80494A0()
{
  ;
}

//----- (080494B0) --------------------------------------------------------
int sub_80494B0()
{
  int result; // eax

  result = &unk_805629B - &unk_8056298;
  if ( (unsigned int)(&unk_805629B - &unk_8056298) > 6 )
    result = 0;
  return result;
}
// 80494B0: could not find valid save-restore pair for ebp

//----- (08049592) --------------------------------------------------------
void sub_8049592()
{
  ;
}

//----- (080495AD) --------------------------------------------------------
void sub_80495AD()
{
  ;
}

//----- (080495BD) --------------------------------------------------------
int sub_80495BD()
{
  int result; // eax

  result = &unk_805629B - &unk_8056298;
  if ( (unsigned int)(&unk_805629B - &unk_8056298) > 6 )
    result = 0;
  return result;
}
// 80495BD: could not find valid save-restore pair for ebp

//----- (080496B1) --------------------------------------------------------
void sub_80496B1()
{
  ;
}

//----- (080496CC) --------------------------------------------------------
void sub_80496CC()
{
  ;
}

//----- (080496DC) --------------------------------------------------------
int sub_80496DC()
{
  int result; // eax

  result = &unk_805629B - &unk_8056298;
  if ( (unsigned int)(&unk_805629B - &unk_8056298) > 6 )
    result = 0;
  return result;
}
// 80496DC: could not find valid save-restore pair for ebp

//----- (080497BE) --------------------------------------------------------
void sub_80497BE()
{
  ;
}

//----- (080497D9) --------------------------------------------------------
void sub_80497D9()
{
  ;
}

//----- (080497E9) --------------------------------------------------------
int sub_80497E9()
{
  int result; // eax

  result = &unk_805629B - &unk_8056298;
  if ( (unsigned int)(&unk_805629B - &unk_8056298) > 6 )
    result = 0;
  return result;
}
// 80497E9: could not find valid save-restore pair for ebp

//----- (080498CB) --------------------------------------------------------
void sub_80498CB()
{
  ;
}

//----- (080498E6) --------------------------------------------------------
void sub_80498E6()
{
  ;
}

//----- (080498F6) --------------------------------------------------------
int sub_80498F6()
{
  int result; // eax

  result = &unk_80564DE - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_80564DE - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 80498F6: could not find valid save-restore pair for ebp
// 80562C0: using guessed type int program_invocation_short_name;

//----- (08049954) --------------------------------------------------------
int sub_8049954()
{
  return nullsub_3();
}
// 8049954: could not find valid save-restore pair for ebp
// 8049953: using guessed type int nullsub_3(void);

//----- (080499F4) --------------------------------------------------------
void sub_80499F4()
{
  ;
}

//----- (08049A0F) --------------------------------------------------------
void sub_8049A0F()
{
  ;
}

//----- (08049A1F) --------------------------------------------------------
int sub_8049A1F()
{
  int result; // eax

  result = &unk_805629B - &unk_8056298;
  if ( (unsigned int)(&unk_805629B - &unk_8056298) > 6 )
    result = 0;
  return result;
}
// 8049A1F: could not find valid save-restore pair for ebp

//----- (08049B1D) --------------------------------------------------------
void sub_8049B1D()
{
  ;
}

//----- (08049B38) --------------------------------------------------------
void sub_8049B38()
{
  ;
}

//----- (08049B48) --------------------------------------------------------
int sub_8049B48()
{
  int result; // eax

  result = &unk_805629B - &unk_8056298;
  if ( (unsigned int)(&unk_805629B - &unk_8056298) > 6 )
    result = 0;
  return result;
}
// 8049B48: could not find valid save-restore pair for ebp

//----- (08049C2A) --------------------------------------------------------
void sub_8049C2A()
{
  ;
}

//----- (08049C45) --------------------------------------------------------
void sub_8049C45()
{
  ;
}

//----- (08049C55) --------------------------------------------------------
int sub_8049C55()
{
  int result; // eax

  result = &unk_805629B - &unk_8056298;
  if ( (unsigned int)(&unk_805629B - &unk_8056298) > 6 )
    result = 0;
  return result;
}
// 8049C55: could not find valid save-restore pair for ebp

//----- (08049CB3) --------------------------------------------------------
int __usercall sub_8049CB3@<eax>(int a1@<ecx>, int a2@<ebp>)
{
  int v2; // eax
  int (__cdecl *v3)(void *, int); // edx
  int v5; // [esp+18h] [ebp-4h]

  dword_8056148 = (int)nullsub_4;
  v2 = sub_8050F26(a1, 0);
  v5 = a2;
  return v3(&unk_8056298, v2);
}
// 8049CB3: could not find valid save-restore pair for ebp
// 8049CB2: using guessed type int nullsub_4();
// 8050F26: using guessed type int __fastcall sub_8050F26(_DWORD, _DWORD);
// 8056148: using guessed type int dword_8056148;

//----- (08049D11) --------------------------------------------------------
int sub_8049D11()
{
  int result; // eax

  result = sub_8049C55();
  byte_805660E = 1;
  return result;
}
// 805660E: using guessed type char byte_805660E;

//----- (08049D85) --------------------------------------------------------
void sub_8049D85()
{
  ;
}

//----- (08049DA0) --------------------------------------------------------
void sub_8049DA0()
{
  ;
}

//----- (08049DB0) --------------------------------------------------------
int sub_8049DB0()
{
  int result; // eax

  result = &unk_805629B - &unk_8056298;
  if ( (unsigned int)(&unk_805629B - &unk_8056298) > 6 )
    result = 0;
  return result;
}
// 8049DB0: could not find valid save-restore pair for ebp

//----- (08049EA7) --------------------------------------------------------
void sub_8049EA7()
{
  ;
}

//----- (08049EC2) --------------------------------------------------------
void sub_8049EC2()
{
  ;
}

//----- (08049ED2) --------------------------------------------------------
int sub_8049ED2()
{
  int result; // eax

  result = &unk_80531BF - &unk_80531BC;
  if ( (unsigned int)(&unk_80531BF - &unk_80531BC) > 6 )
    result = 0;
  return result;
}
// 8049ED2: could not find valid save-restore pair for ebp

//----- (08049FB4) --------------------------------------------------------
void sub_8049FB4()
{
  ;
}

//----- (08049FCF) --------------------------------------------------------
void sub_8049FCF()
{
  ;
}

//----- (08049FDF) --------------------------------------------------------
#error "804A00C: call analysis failed (funcsize=23)"

//----- (0804A0DA) --------------------------------------------------------
void sub_804A0DA()
{
  ;
}

//----- (0804A0F5) --------------------------------------------------------
void sub_804A0F5()
{
  ;
}

//----- (0804A105) --------------------------------------------------------
int sub_804A105()
{
  int result; // eax
  int (__stdcall *v1)(void *, int, int, int, int, int); // eax
  int v2; // [esp+4h] [ebp-18h]
  int v3; // [esp+8h] [ebp-14h]
  int v4; // [esp+Ch] [ebp-10h]
  int v5; // [esp+10h] [ebp-Ch]
  int v6; // [esp+14h] [ebp-8h]
  int v7; // [esp+18h] [ebp-4h]

  result = &unk_805629B - &unk_8056298;
  if ( (unsigned int)(&unk_805629B - &unk_8056298) > 6 )
  {
    v7 = 0;
    dword_8056134 = (int)&locret_804A114;
    v1 = (int (__stdcall *)(void *, int, int, int, int, int))sub_8050F92();
    result = v1(&unk_8056298, v2, v3, v4, v5, v6);
  }
  return result;
}
// 8050F92: using guessed type int sub_8050F92(void);
// 8056134: using guessed type int dword_8056134;

//----- (0804A1A8) --------------------------------------------------------
int sub_804A1A8()
{
  int result; // eax

  result = sub_804A105();
  byte_8056742 = 1;
  return result;
}
// 8056742: using guessed type char byte_8056742;

//----- (0804A21C) --------------------------------------------------------
void sub_804A21C()
{
  ;
}

//----- (0804A237) --------------------------------------------------------
void sub_804A237()
{
  ;
}

//----- (0804A247) --------------------------------------------------------
int sub_804A247()
{
  int result; // eax

  result = &unk_80562A3 - &unk_80562A0;
  if ( (unsigned int)(&unk_80562A3 - &unk_80562A0) > 6 )
    result = 0;
  return result;
}
// 804A247: could not find valid save-restore pair for ebp

//----- (0804A2A5) --------------------------------------------------------
int __usercall sub_804A2A5@<eax>(int a1@<ebp>)
{
  int v1; // eax
  int (__cdecl *v2)(void *, int); // edx
  int v4; // [esp+18h] [ebp-4h]

  dword_8056120 = (int)nullsub_5;
  v1 = sub_8051002();
  v4 = a1;
  return v2(&unk_80562A0, v1);
}
// 804A2A5: could not find valid save-restore pair for ebp
// 804A2A4: using guessed type int nullsub_5();
// 8051002: using guessed type int sub_8051002(void);
// 8056120: using guessed type int dword_8056120;

//----- (0804A370) --------------------------------------------------------
void __spoils<edx,ecx> sub_804A370()
{
  __asm { pushfw }
  if ( sub_804F095() != 666 )
    sub_804F09F();
  __asm { popfw }
}
// 804F09F: using guessed type int sub_804F09F(void);

//----- (0804A3AA) --------------------------------------------------------
void sub_804A3AA()
{
  ;
}

//----- (0804A3BA) --------------------------------------------------------
signed int sub_804A3BA()
{
  return 4;
}
// 804A3BA: could not find valid save-restore pair for ebp

//----- (0804A444) --------------------------------------------------------
signed int sub_804A444()
{
  signed int result; // eax

  result = sub_804A3BA();
  byte_80567DC = 1;
  return result;
}
// 80567DC: using guessed type char byte_80567DC;

//----- (0804A4B8) --------------------------------------------------------
void sub_804A4B8()
{
  ;
}

//----- (0804A4D3) --------------------------------------------------------
void sub_804A4D3()
{
  ;
}

//----- (0804A4E3) --------------------------------------------------------
int sub_804A4E3()
{
  int result; // eax

  result = &unk_80562A3 - &unk_80562A0;
  if ( (unsigned int)(&unk_80562A3 - &unk_80562A0) > 6 )
    result = 0;
  return result;
}
// 804A4E3: could not find valid save-restore pair for ebp

//----- (0804A593) --------------------------------------------------------
int sub_804A593()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nWith no FILE, or when FILE is -, read standard input.\n");
  return fputs_unlocked(v1, v0);
}
// 8048F50: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804A5BE) --------------------------------------------------------
int sub_804A5BE()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nMandatory arguments to long options are mandatory for short options too.\n");
  return fputs_unlocked(v1, v0);
}
// 8048F50: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804A5E9) --------------------------------------------------------
#error "804A62F: call analysis failed (funcsize=19)"

//----- (0804A634) --------------------------------------------------------
#error "804A7C3: positive sp value has been found (funcsize=96)"

//----- (0804A7C6) --------------------------------------------------------
void __cdecl __noreturn sub_804A7C6(int status)
{
  const char *v1; // ebx
  char *v2; // eax
  const char *v3; // ebx
  char *v4; // eax
  FILE *v5; // ebx
  char *v6; // eax
  FILE *v7; // ebx
  char *v8; // eax
  FILE *v9; // ebx
  char *v10; // eax
  char *v11; // eax
  int v12; // [esp+0h] [ebp-18h]
  const char *v13; // [esp+4h] [ebp-14h]
  const char *v14; // [esp+8h] [ebp-10h]

  if ( status )
  {
    v1 = (const char *)dword_8056835;
    v2 = gettext("Try '%s --help' for more information.\n");
    v14 = v1;
    fprintf(stderr, v2, v1);
    dword_80561AC = (int)&loc_804A8CC;
    sub_8050CDE(v12);
  }
  v3 = (const char *)dword_8056835;
  v4 = gettext("Usage: %s [OPTION]... [FILE]\nBase%d encode or decode FILE, or standard input, to standard output.\n");
  v14 = (const char *)32;
  v13 = v3;
  printf(v4, v3, 32);
  sub_804A593();
  sub_804A5BE();
  v5 = stdout;
  v6 = gettext(
         "  -d, --decode          decode data\n"
         "  -i, --ignore-garbage  when decoding, ignore non-alphabet characters\n"
         "  -w, --wrap=COLS       wrap encoded lines after COLS character (default 76).\n"
         "                          Use 0 to disable line wrapping\n"
         "\n");
  fputs_unlocked(v6, v5);
  v7 = stdout;
  v8 = gettext("      --help     display this help and exit\n");
  fputs_unlocked(v8, v7);
  v9 = stdout;
  v10 = gettext("      --version  output version information and exit\n");
  fputs_unlocked(v10, v9);
  v11 = gettext(
          "\n"
          "The data are encoded as described for the %s alphabet in RFC 4648.\n"
          "When decoding, the input may contain newlines in addition to the bytes of\n"
          "the formal %s alphabet.  Use --ignore-garbage to attempt to recover\n"
          "from any other non-alphabet bytes in the encoded stream.\n");
  v14 = "base32";
  v13 = "base32";
  printf(v11, "base32", "base32");
  sub_804A5E9("base32");
  exit(status);
}
// 8048F50: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 804A5E9: using guessed type int __cdecl sub_804A5E9(_DWORD);
// 8050CDE: using guessed type int __cdecl sub_8050CDE(_DWORD);
// 80561AC: using guessed type int dword_80561AC;
// 8056835: using guessed type int dword_8056835;

//----- (0804A8D7) --------------------------------------------------------
#error "804A90E: call analysis failed (funcsize=21)"

//----- (0804A913) --------------------------------------------------------
#error "804AACA: positive sp value has been found (funcsize=89)"

//----- (0804AACD) --------------------------------------------------------
unsigned int __usercall sub_804AACD@<eax>(int a1@<ebx>, FILE *a2, FILE *a3, __int64 a4)
{
  size_t v4; // eax
  int v5; // eax
  void *v6; // eax
  void *v7; // eax
  int v8; // ebx
  int v9; // edx
  int v10; // ecx
  void *v11; // eax
  char *v12; // ebx
  int *v13; // eax
  char *v14; // ebx
  int *v15; // eax
  int v17; // [esp-8h] [ebp-13850h]
  int v18; // [esp-4h] [ebp-1384Ch]
  int v19; // [esp+0h] [ebp-13848h]
  int v20; // [esp+4h] [ebp-13844h]
  __int64 v21; // [esp+8h] [ebp-13840h]
  int *v22; // [esp+10h] [ebp-13838h]
  FILE *v23; // [esp+14h] [ebp-13834h]
  int v24; // [esp+18h] [ebp-13830h]
  int v25; // [esp+1Ch] [ebp-1382Ch]
  __int64 v26; // [esp+20h] [ebp-13828h]
  FILE *v27; // [esp+28h] [ebp-13820h]
  FILE *stream; // [esp+2Ch] [ebp-1381Ch]
  int v29; // [esp+30h] [ebp-13818h]
  unsigned int v30; // [esp+34h] [ebp-13814h]
  size_t v31; // [esp+38h] [ebp-13810h]
  char v32[30720]; // [esp+3Ch] [ebp-1380Ch]
  unsigned int v33; // [esp+1383Ch] [ebp-Ch]

  stream = a2;
  v27 = a3;
  v26 = a4;
  v33 = __readgsdword(0x14u);
  v29 = 0;
  do
  {
    v30 = 0;
    do
    {
      v4 = fread_unlocked(&v32[v30], 1u, 30720 - v30, stream);
      v31 = v4;
      v30 += v4;
      v5 = feof_unlocked(stream);
      if ( v5 )
        break;
      v5 = ferror_unlocked(stream);
      if ( v5 )
        break;
    }
    while ( v30 <= 0x77FF );
    v18 = v5;
    v17 = a1;
    v6 = &loc_804ABD9;
    if ( !v30 )
      v6 = &loc_804AC8D;
    dword_8056198 = (int)v6;
    a1 = v17;
    sub_8050D58(v19);
    sub_804B5CA((int)(&v19 - 19971), v30, (_BYTE *)&v19 - 49164, 8 * ((v30 + 4) / 5));
    v23 = v27;
    v22 = &v19 - 19974;
    sub_804A8D7(&v19 - 12291, 8 * ((v30 + 4) / 5), v26);
  }
  while ( !feof_unlocked(stream) && !ferror_unlocked(stream) && v30 == 30720 );
  v18 = HIDWORD(v26) | v26;
  v17 = a1;
  v7 = &loc_804ACEC;
  if ( !v26 )
    v7 = &loc_804AD53;
  dword_80561C0 = (int)v7;
  v8 = v17;
  sub_8050C64(v19, v20, v21, HIDWORD(v21), v22, v23, v24, v25, v26, HIDWORD(v26), v27, stream, v29, v30, v31);
  v18 = v29;
  v17 = v8;
  v11 = &loc_804AD0F;
  if ( !v29 )
    v11 = &loc_804AD53;
  dword_8056148 = (int)v11;
  sub_8050F26(v10, v9);
  if ( fputc_unlocked(10, v27) == -1 )
  {
    v12 = gettext("write error");
    v13 = __errno_location();
    error(1, *v13, v12);
  }
  if ( ferror_unlocked(stream) )
  {
    v14 = gettext("read error");
    v15 = __errno_location();
    error(1, *v15, v14);
  }
  return __readgsdword(0x14u) ^ v33;
}
// 804A8D7: using guessed type _DWORD __cdecl sub_804A8D7(_DWORD, _DWORD, __int64);
// 8050C64: using guessed type int __stdcall sub_8050C64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8050D58: using guessed type int __stdcall sub_8050D58(_DWORD);
// 8050F26: using guessed type int __fastcall sub_8050F26(_DWORD, _DWORD);
// 8056148: using guessed type int dword_8056148;
// 8056198: using guessed type int dword_8056198;
// 80561C0: using guessed type int dword_80561C0;
// 804AACD: using guessed type char var_1380C[30720];

//----- (0804ADA8) --------------------------------------------------------
int __usercall __noreturn sub_804ADA8@<eax>(char *a1@<ebx>, FILE *a2, FILE *a3, char a4)
{
  size_t v4; // eax
  int *v5; // eax
  void *v6; // eax
  int v7; // eax
  size_t v8; // eax
  int *v9; // eax
  char *v10; // eax
  unsigned int v11; // eax
  unsigned int v12; // et1
  int (*v13)(); // eax
  char *v15; // [esp-8h] [ebp-3460h]
  int v16; // [esp-4h] [ebp-345Ch]
  unsigned __int8 v17; // [esp+0h] [ebp-3458h]
  int v18; // [esp+4h] [ebp-3454h]
  int v19; // [esp+8h] [ebp-3450h]
  int v20; // [esp+Ch] [ebp-344Ch]
  int v21; // [esp+10h] [ebp-3448h]
  char v22; // [esp+14h] [ebp-3444h]
  FILE *v23; // [esp+18h] [ebp-3440h]
  FILE *stream; // [esp+1Ch] [ebp-343Ch]
  int v25; // [esp+20h] [ebp-3438h]
  int v26; // [esp+24h] [ebp-3434h]
  int v27; // [esp+28h] [ebp-3430h]
  int v28; // [esp+2Ch] [ebp-342Ch]
  size_t n; // [esp+30h] [ebp-3428h]
  int v30; // [esp+34h] [ebp-3424h]
  unsigned int i; // [esp+38h] [ebp-3420h]
  size_t v32; // [esp+3Ch] [ebp-341Ch]
  size_t v33; // [esp+40h] [ebp-3418h]
  char ptr; // [esp+4Ch] [ebp-340Ch]
  char v35[8192]; // [esp+144Ch] [ebp-200Ch]
  unsigned int v36; // [esp+344Ch] [ebp-Ch]

  stream = a2;
  v23 = a3;
  v22 = a4;
  v36 = __readgsdword(0x14u);
  sub_804BAB7((_DWORD *)&v17 - 3334);
  do
  {
    v30 = 0;
    do
    {
      n = fread_unlocked(&v35[v30], 1u, 0x2000 - v30, stream);
      if ( v22 )
      {
        v32 = 0;
        while ( n && v32 < n )
        {
          *(_DWORD *)&v17 = v35[v30 + v32];
          if ( sub_804BA8E(v17) || v35[v30 + v32] == 61 )
          {
            ++v32;
          }
          else
          {
            v4 = n--;
            a1 = (char *)(v32 + v30);
            memmove(&v17 + v32 + v30 - 8204, &v17 + v30 + v32 - 8203, v4 - 1 - v32);
          }
        }
      }
      v30 += n;
      if ( ferror_unlocked(stream) )
      {
        a1 = gettext("read error");
        v5 = __errno_location();
        error(1, *v5, a1);
      }
    }
    while ( (unsigned int)v30 <= 0x1FFF && !feof_unlocked(stream) );
    for ( i = 0; ; ++i )
    {
      v11 = feof_unlocked(stream) ? 2 : 1;
      if ( v11 <= i )
        break;
      v16 = v11;
      v15 = a1;
      v6 = &loc_804AFD1;
      if ( i != 1 )
        v6 = &loc_804AFE0;
      dword_80561C0 = (int)v6;
      a1 = v15;
      sub_8050C64(*(_DWORD *)&v17, v18, v19, v20, v21, *(_DWORD *)&v22, v23, stream, v25, v26, v27, v28, n, v30, i);
      if ( !v33 )
        break;
      n = 5120;
      if ( i )
        v7 = 0;
      else
        v7 = v30;
      HIBYTE(v28) = sub_804C22C((size_t)&v33, (int)v35, v7, (int)&ptr, (int)&n);
      v8 = fwrite_unlocked(&ptr, 1u, n, v23);
      if ( v8 < n )
      {
        a1 = gettext("write error");
        v9 = __errno_location();
        error(1, *v9, a1);
      }
      if ( HIBYTE(v28) != 1 )
      {
        v10 = gettext("invalid input");
        error(1, 0, v10);
      }
    }
  }
  while ( !feof_unlocked(stream) );
  v12 = __readgsdword(0x14u);
  v16 = v12 ^ v36;
  v15 = a1;
  v13 = (int (*)())&loc_804B131;
  if ( v12 == v36 )
    v13 = sub_804B136;
  dword_8056198 = (int)v13;
  return sub_8050D58(*(_DWORD *)&v17);
}
// 804B136: using guessed type int sub_804B136();
// 8050C64: using guessed type int __stdcall sub_8050C64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8050D58: using guessed type int __stdcall sub_8050D58(_DWORD);
// 8056198: using guessed type int dword_8056198;
// 80561C0: using guessed type int dword_80561C0;

//----- (0804B136) --------------------------------------------------------
#error "804B13C: positive sp value has been found (funcsize=0)"

//----- (0804B13F) --------------------------------------------------------
void __usercall __noreturn main(int a1@<edx>, int a2@<ecx>, int argc, char **argv)
{
  sub_804C797(a2, a1, (int)*argv);
}

//----- (0804B5B8) --------------------------------------------------------
int __cdecl sub_804B5B8(unsigned __int8 a1)
{
  return a1;
}

//----- (0804B5CA) --------------------------------------------------------
#error "804B782: call analysis failed (funcsize=163)"

//----- (0804BA8E) --------------------------------------------------------
char __cdecl sub_804BA8E(unsigned __int8 a1)
{
  return (unsigned __int8)~byte_80517F0[(unsigned __int8)sub_804B5B8(a1)] >> 7;
}

//----- (0804BAB7) --------------------------------------------------------
_DWORD *__cdecl sub_804BAB7(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = 0;
  return result;
}

//----- (0804BAC5) --------------------------------------------------------
#error "804BB4E: call analysis failed (funcsize=108)"

//----- (0804BC00) --------------------------------------------------------
#error "804BD07: call analysis failed (funcsize=124)"

//----- (0804C22C) --------------------------------------------------------
#error "804C3D1: call analysis failed (funcsize=203)"

//----- (0804C5B1) --------------------------------------------------------
int sub_804C5B1()
{
  void *v1; // eax
  int v2; // ebx
  int *v3; // eax
  int *v7; // eax
  int result; // eax
  int v9; // [esp+0h] [ebp-38h]
  char *v10; // [esp+2Ch] [ebp-Ch]

  _ZF = sub_804FCF0(stdout) == 0;
  v1 = &loc_804C5E2;
  if ( _ZF )
    v1 = &loc_804C6AB;
  dword_8056198 = (int)v1;
  sub_8050D58(v9);
  if ( byte_8056831 != 1 || *__errno_location() != 32 )
  {
    v10 = gettext("write error");
    if ( dword_805682D )
    {
      v2 = sub_804E361(dword_805682D);
      v3 = __errno_location();
      error(0, *v3, "%s: %s", v2, v10);
      __asm { pushfw }
      if ( v2 >= 10 )
      {
        if ( ((_BYTE)v2 - 1) * (_BYTE)v2 & 1 )
          abort();
      }
      __asm { popfw }
    }
    else
    {
      v7 = __errno_location();
      error(0, *v7, "%s", v10);
    }
    _exit(status);
  }
  result = sub_804FCF0(stderr);
  if ( result )
    _exit(status);
  return result;
}
// 8050D58: using guessed type int __stdcall sub_8050D58(_DWORD);
// 8056198: using guessed type int dword_8056198;
// 805682D: using guessed type int dword_805682D;
// 8056831: using guessed type char byte_8056831;

//----- (0804C6CF) --------------------------------------------------------
int __cdecl sub_804C6CF(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // [esp+18h] [ebp-34h]
  int v8; // [esp+1Ch] [ebp-30h]
  int v9; // [esp+30h] [ebp-1Ch]
  int v10; // [esp+34h] [ebp-18h]
  int v11; // [esp+38h] [ebp-14h]
  int v12; // [esp+3Ch] [ebp-10h]
  int v13; // [esp+40h] [ebp-Ch]
  int v14; // [esp+44h] [ebp-8h]

  return posix_fadvise64(a1, a2, a3, a4, a5, a6, v7, v8, a4, a5, a2, a3, v9, v10, v11, v12, v13, v14);
}
// 8049070: using guessed type int __stdcall posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804C730) --------------------------------------------------------
int __usercall sub_804C730@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, FILE *stream, int a7)
{
  int result; // eax
  int v8; // eax
  __int16 v9; // [esp+26h] [ebp-6h]
  __int16 *v10; // [esp+28h] [ebp-4h]

  v10 = (__int16 *)a5;
  __asm { pushfw }
  if ( sub_804F095() != 666 )
    sub_804F09F();
  __asm { popfw }
  result = (int)v10;
  v10 = &v9;
  if ( stream )
  {
    v8 = fileno(stream);
    result = sub_804C6CF(v8, 0, 0, 0, 0, a7);
  }
  return result;
}
// 804F09F: using guessed type int sub_804F09F(void);

//----- (0804C797) --------------------------------------------------------
void __fastcall __noreturn sub_804C797(int a1, int a2, int a3)
{
  int (__cdecl *v3)(int, size_t); // eax

  v3 = (int (__cdecl *)(int, size_t))&loc_804C7BC;
  if ( a3 )
    v3 = sub_804C7E6;
  dword_8056210 = (int)v3;
  sub_8050A4B(a1, a2);
  fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
  abort();
}
// 8050A4B: using guessed type int __fastcall sub_8050A4B(_DWORD, _DWORD);
// 8056210: using guessed type int dword_8056210;

//----- (0804C7E6) --------------------------------------------------------
#error "804C8D3: positive sp value has been found (funcsize=66)"

//----- (0804C98E) --------------------------------------------------------
int __cdecl sub_804C98E(int a1, unsigned __int8 a2, char a3)
{
  unsigned __int8 v4; // [esp+0h] [ebp-18h]
  unsigned __int8 v5; // [esp+7h] [ebp-11h]
  int *v6; // [esp+8h] [ebp-10h]
  int v7; // [esp+Ch] [ebp-Ch]
  unsigned int v8; // [esp+10h] [ebp-8h]

  v4 = a2;
  v5 = a2;
  if ( a1 )
  {
    dword_80561AC = (int)&loc_804C9C7;
    sub_8050CDE(*(_DWORD *)&v4);
  }
  v6 = &dword_805683D[(v5 >> 5) + 2];
  v7 = v5 & 0x1F;
  v8 = ((unsigned int)*v6 >> v7) & 1;
  *v6 ^= (v8 ^ a3 & 1) << v7;
  return v8;
}
// 8050CDE: using guessed type int __cdecl sub_8050CDE(_DWORD);
// 80561AC: using guessed type int dword_80561AC;
// 805683D: using guessed type int dword_805683D[];

//----- (0804CA7C) --------------------------------------------------------
void __cdecl __noreturn sub_804CA7C(int *a1, int a2, int a3)
{
  int (*v3)(); // eax

  if ( !a1 )
    a1 = dword_805683D;
  *a1 = 10;
  if ( a2 )
  {
    v3 = (int (*)())&loc_804CABD;
    if ( a3 )
      v3 = sub_804CAC2;
    dword_80561D4 = (int)v3;
    sub_8050BD5();
  }
  abort();
}
// 804CAC2: using guessed type int sub_804CAC2();
// 8050BD5: using guessed type int sub_8050BD5(void);
// 80561D4: using guessed type int dword_80561D4;
// 805683D: using guessed type int dword_805683D[];

//----- (0804CAC2) --------------------------------------------------------
#error "804CAD5: positive sp value has been found (funcsize=0)"

//----- (0804CAD6) --------------------------------------------------------
_DWORD *__userpurge sub_804CAD6@<eax>(_DWORD *a1, int a2)
{
  int v3; // [esp+4h] [ebp-34h]
  int v4; // [esp+8h] [ebp-30h]
  int v5; // [esp+Ch] [ebp-2Ch]
  int v6; // [esp+10h] [ebp-28h]
  int v7; // [esp+14h] [ebp-24h]
  int v8; // [esp+18h] [ebp-20h]
  int v9; // [esp+1Ch] [ebp-1Ch]
  int v10; // [esp+20h] [ebp-18h]
  int v11; // [esp+24h] [ebp-14h]
  int v12; // [esp+28h] [ebp-10h]
  int v13; // [esp+2Ch] [ebp-Ch]
  int v14; // [esp+30h] [ebp-8h]

  memset(&v14 - 14, 0, 0x30u);
  if ( a2 == 10 )
    abort();
  *a1 = a2;
  a1[1] = v3;
  a1[2] = v4;
  a1[3] = v5;
  a1[4] = v6;
  a1[5] = v7;
  a1[6] = v8;
  a1[7] = v9;
  a1[8] = v10;
  a1[9] = v11;
  a1[10] = v12;
  a1[11] = v13;
  return a1;
}

//----- (0804CB78) --------------------------------------------------------
char *__cdecl sub_804CB78(char *msgid)
{
  char *v1; // eax
  bool v2; // zf
  void *v3; // eax
  char *v5; // [esp+18h] [ebp-10h]

  v1 = gettext(msgid);
  v5 = v1;
  v2 = v1 == msgid;
  v3 = &loc_804CBAD;
  if ( v2 )
    v3 = &loc_804CBB5;
  dword_8056120 = (int)v3;
  sub_8051002();
  return v5;
}
// 8051002: using guessed type int sub_8051002(void);
// 8056120: using guessed type int dword_8056120;

//----- (0804CC5D) --------------------------------------------------------
#error "804DAA3: call analysis failed (funcsize=1097)"

//----- (0804DBCD) --------------------------------------------------------
void *__cdecl sub_804DBCD(int a1, int a2, _DWORD *a3, int *a4)
{
  int *v4; // eax
  int *v5; // ST3C_4
  int v6; // ST40_4
  int v7; // ST44_4
  int size; // [esp+48h] [ebp-10h]
  void *v10; // [esp+4Ch] [ebp-Ch]

  if ( a4 )
    v4 = a4;
  else
    v4 = dword_805683D;
  v5 = v4;
  v6 = *__errno_location();
  v7 = v5[1] | (a3 == 0);
  size = sub_804CC5D(0, 0, a1, a2, *v5, v7, v5 + 2, v5[10], v5[11]) + 1;
  v10 = sub_804EF42(size);
  sub_804CC5D(v10, size, a1, a2, *v5, v7, v5 + 2, v5[10], v5[11]);
  *__errno_location() = v6;
  if ( a3 )
    *a3 = size - 1;
  return v10;
}
// 804CC5D: using guessed type _DWORD __cdecl sub_804CC5D(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 805683D: using guessed type int dword_805683D[];

//----- (0804DDDB) --------------------------------------------------------
#error "804E04E: call analysis failed (funcsize=182)"

//----- (0804E072) --------------------------------------------------------
int __cdecl sub_804E072()
{
  return sub_804DDDB();
}

//----- (0804E09C) --------------------------------------------------------
int __usercall sub_804E09C@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>)
{
  __int16 v6; // [esp+16h] [ebp-6h]
  __int16 *v7; // [esp+18h] [ebp-4h]

  v7 = (__int16 *)a5;
  __asm { pushfw }
  if ( sub_804F095() != 666 )
    sub_804F09F();
  __asm { popfw }
  v7 = &v6;
  return sub_804DDDB();
}
// 804F09F: using guessed type int sub_804F09F(void);

//----- (0804E131) --------------------------------------------------------
int __usercall sub_804E131@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, int a6, int a7)
{
  int v8; // [esp+10h] [ebp-3Ch]
  __int16 v9; // [esp+46h] [ebp-6h]
  __int16 *v10; // [esp+48h] [ebp-4h]

  v10 = (__int16 *)a5;
  __asm { pushfw }
  if ( sub_804F095() != 666 )
    sub_804F09F();
  __asm { popfw }
  v10 = &v9;
  sub_804CAD6(&v8, a7);
  return sub_804DDDB();
}
// 804F09F: using guessed type int sub_804F09F(void);

//----- (0804E18E) --------------------------------------------------------
void __cdecl __noreturn sub_804E18E(int a1, int a2)
{
  void *v6; // eax
  int v7; // [esp-2h] [ebp-4Ah]
  _DWORD *v8; // [esp+0h] [ebp-48h]
  int v9; // [esp+6h] [ebp-42h]
  int v10; // [esp+Ah] [ebp-3Eh]
  int v11; // [esp+Eh] [ebp-3Ah]
  int v12; // [esp+12h] [ebp-36h]
  int v13; // [esp+16h] [ebp-32h]
  int v14; // [esp+1Ah] [ebp-2Eh]
  int v15; // [esp+1Eh] [ebp-2Ah]
  int v16; // [esp+22h] [ebp-26h]
  int v17; // [esp+26h] [ebp-22h]
  int v18; // [esp+2Ah] [ebp-1Eh]
  int v19; // [esp+2Eh] [ebp-1Ah]
  int v20; // [esp+32h] [ebp-16h]
  int v21; // [esp+36h] [ebp-12h]

  v8 = sub_804CAD6((int *)((char *)&v11 + 2), a2);
  __asm { pushfw }
  _ZF = sub_804F095() == 666;
  v6 = &loc_804E1D2;
  if ( _ZF )
    v6 = &sub_804E1DB;
  dword_80561C0 = (int)v6;
  sub_8050C64(v7, *(_DWORD **)((char *)&v8 + 2), v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21);
  sub_804F09F();
}
// 804F09F: using guessed type int sub_804F09F(void);
// 8050C64: using guessed type int __stdcall sub_8050C64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80561C0: using guessed type int dword_80561C0;

//----- (0804E1DB) --------------------------------------------------------
#error "804E1DD: positive sp value has been found (funcsize=1)"

//----- (0804E26E) --------------------------------------------------------
int __cdecl sub_804E26E(int a1, int a2, unsigned __int8 a3)
{
  int v4; // [esp+0h] [ebp-58h]
  int v5; // [esp+4h] [ebp-54h]
  int v6; // [esp+8h] [ebp-50h]
  int *v7; // [esp+Ch] [ebp-4Ch]
  unsigned __int8 v8; // [esp+1Ch] [ebp-3Ch]
  int v9; // [esp+20h] [ebp-38h]
  int v10; // [esp+24h] [ebp-34h]
  int v11; // [esp+28h] [ebp-30h]
  int v12; // [esp+2Ch] [ebp-2Ch]
  int v13; // [esp+30h] [ebp-28h]
  int v14; // [esp+34h] [ebp-24h]
  int v15; // [esp+38h] [ebp-20h]
  int v16; // [esp+3Ch] [ebp-1Ch]
  int v17; // [esp+40h] [ebp-18h]
  int v18; // [esp+44h] [ebp-14h]
  int v19; // [esp+48h] [ebp-10h]
  int v20; // [esp+4Ch] [ebp-Ch]

  v8 = a3;
  v9 = dword_805683D[0];
  v10 = dword_8056841;
  v11 = dword_8056845;
  v12 = dword_8056849;
  v13 = dword_805684D;
  v14 = dword_8056851;
  v15 = dword_8056855;
  v16 = dword_8056859;
  v17 = dword_805685D;
  v18 = dword_8056861;
  v19 = dword_8056865;
  v20 = dword_8056869;
  sub_804C98E((int)(&v4 - 14), a3, 1);
  v7 = &v9;
  v6 = a2;
  v5 = a1;
  v4 = 0;
  return sub_804DDDB();
}
// 805683D: using guessed type int dword_805683D[];
// 8056841: using guessed type int dword_8056841;
// 8056845: using guessed type int dword_8056845;
// 8056849: using guessed type int dword_8056849;
// 805684D: using guessed type int dword_805684D;
// 8056851: using guessed type int dword_8056851;
// 8056855: using guessed type int dword_8056855;
// 8056859: using guessed type int dword_8056859;
// 805685D: using guessed type int dword_805685D;
// 8056861: using guessed type int dword_8056861;
// 8056865: using guessed type int dword_8056865;
// 8056869: using guessed type int dword_8056869;

//----- (0804E328) --------------------------------------------------------
int __cdecl sub_804E328(int a1, unsigned __int8 a2)
{
  return sub_804E26E(a1, -1, a2);
}

//----- (0804E361) --------------------------------------------------------
int __cdecl sub_804E361(int a1)
{
  return sub_804E328(a1, 0x3Au);
}

//----- (0804E39E) --------------------------------------------------------
#error "804E402: call analysis failed (funcsize=34)"

//----- (0804E407) --------------------------------------------------------
#error "804E463: positive sp value has been found (funcsize=0)"

//----- (0804E464) --------------------------------------------------------
void __cdecl __noreturn sub_804E464(int a1, int a2, int a3, int a4)
{
  sub_804E4A4(a1, a2, a3);
}

//----- (0804E4A4) --------------------------------------------------------
void __cdecl __noreturn sub_804E4A4(int a1, int a2, int a3)
{
  int v3; // [esp+0h] [ebp-38h]
  int v4; // [esp+4h] [ebp-34h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]

  v3 = dword_805683D[0];
  v4 = dword_8056841;
  v5 = dword_8056845;
  v6 = dword_8056849;
  v7 = dword_805684D;
  v8 = dword_8056851;
  v9 = dword_8056855;
  v10 = dword_8056859;
  v11 = dword_805685D;
  v12 = dword_8056861;
  v13 = dword_8056865;
  v14 = dword_8056869;
  sub_804CA7C(&v3, a2, a3);
}
// 805683D: using guessed type int dword_805683D[];
// 8056841: using guessed type int dword_8056841;
// 8056845: using guessed type int dword_8056845;
// 8056849: using guessed type int dword_8056849;
// 805684D: using guessed type int dword_805684D;
// 8056851: using guessed type int dword_8056851;
// 8056855: using guessed type int dword_8056855;
// 8056859: using guessed type int dword_8056859;
// 805685D: using guessed type int dword_805685D;
// 8056861: using guessed type int dword_8056861;
// 8056865: using guessed type int dword_8056865;
// 8056869: using guessed type int dword_8056869;

//----- (0804E5CE) --------------------------------------------------------
int __cdecl sub_804E5CE()
{
  return sub_804DDDB();
}

//----- (0804E629) --------------------------------------------------------
int __cdecl sub_804E629()
{
  return sub_804E5CE();
}

//----- (0804E64B) --------------------------------------------------------
int __cdecl sub_804E64B()
{
  return sub_804E629();
}

//----- (0804E666) --------------------------------------------------------
#error "804EA2D: call analysis failed (funcsize=393)"

//----- (0804ECC0) --------------------------------------------------------
#error "804ECDB: call analysis failed (funcsize=41)"

//----- (0804ED4B) --------------------------------------------------------
#error "804ED68: call analysis failed (funcsize=11)"

//----- (0804ED6D) --------------------------------------------------------
int sub_804ED6D(int a1, FILE *stream, int a3, int a4, int a5, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a5);
  return sub_804ECC0(stream, a3, a4, a5, (int)va);
}

//----- (0804EE73) --------------------------------------------------------
#error "804EEA1: call analysis failed (funcsize=68)"

//----- (0804EF42) --------------------------------------------------------
void *__cdecl sub_804EF42(size_t size)
{
  return sub_804EF55(size);
}

//----- (0804EF55) --------------------------------------------------------
void *__cdecl sub_804EF55(size_t size)
{
  int v6; // [esp-4h] [ebp-2Ch]
  void *v7; // [esp+1Ch] [ebp-Ch]

  v7 = malloc(size);
  if ( !v7 )
  {
    _CF = 0;
    _OF = 0;
    _ZF = size == 0;
    _SF = (size & 0x80000000) != 0;
    if ( size )
    {
      v6 = 0;
      __asm { pushfw }
      if ( sub_804F095() != 666 )
        sub_804F09F();
      __asm { popfw }
      sub_804F0EE();
    }
  }
  return v7;
}
// 804F09F: using guessed type int sub_804F09F(void);

//----- (0804EF9E) --------------------------------------------------------
void *__cdecl sub_804EF9E(void *ptr, size_t size)
{
  void *result; // eax
  void *ptra; // [esp+20h] [ebp+8h]

  if ( size || !ptr )
  {
    ptra = realloc(ptr, size);
    if ( !ptra )
    {
      if ( size )
        sub_804F0EE();
    }
    result = ptra;
  }
  else
  {
    free(ptr);
    result = 0;
  }
  return result;
}

//----- (0804F095) --------------------------------------------------------
signed int sub_804F095()
{
  return 666;
}

//----- (0804F0A0) --------------------------------------------------------
void *__cdecl sub_804F0A0(void *src, size_t n)
{
  void *v2; // eax

  v2 = sub_804EF55(n);
  return memcpy(v2, src, n);
}

//----- (0804F0EE) --------------------------------------------------------
void __noreturn sub_804F0EE()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (0804F127) --------------------------------------------------------
void sub_804F127()
{
  ;
}

//----- (0804F12C) --------------------------------------------------------
int __usercall sub_804F12C@<eax>(signed int a1@<ebx>, int *a2)
{
  int result; // eax

  result = sub_804FC39(0, 0, _SF, 0, a2);
  _CF = 0;
  _OF = 0;
  _ZF = result == 0;
  _SF = result < 0;
  if ( result < 0 )
    sub_804F127();
  __asm { pushfw }
  if ( a1 >= 10 && ((_BYTE)a1 - 1) * (_BYTE)a1 & 1 )
    abort();
  __asm { popfw }
  return result;
}

//----- (0804F174) --------------------------------------------------------
unsigned __int64 __usercall sub_804F174@<edx:eax>(int a1@<edx>, int a2@<ecx>, char *nptr, int base, int a5, int a6, int a7, int a8, char *s, int a10, int status)
{
  int v11; // eax
  bool v12; // zf
  void *v13; // eax
  int v14; // ebx
  int v15; // edx
  signed int v16; // eax
  char *v18; // [esp+0h] [ebp-48h]
  int v19; // [esp+Ch] [ebp-3Ch]
  int v20; // [esp+10h] [ebp-38h]
  unsigned __int64 v21; // [esp+20h] [ebp-28h]
  unsigned __int64 v22; // [esp+28h] [ebp-20h]
  int v23; // [esp+34h] [ebp-14h]
  unsigned __int64 v24; // [esp+38h] [ebp-10h]

  v22 = __PAIR__(a6, a5);
  v21 = __PAIR__(a8, a7);
  v11 = sub_804F431(a1, a2, nptr, 0, base, (int)&v24, s);
  v23 = v11;
  v12 = v11 == 0;
  v13 = &loc_804F1ED;
  if ( !v12 )
    v13 = &loc_804F24F;
  dword_805610C = (int)v13;
  sub_805107A();
  if ( v24 < v22 || v21 < v24 )
  {
    v23 = 1;
    if ( v24 <= 0x3FFFFFFF )
      *__errno_location() = 34;
    else
      *__errno_location() = 75;
  }
  if ( v23 )
  {
    v18 = nptr;
    v14 = sub_804E64B();
    if ( *__errno_location() == 22 )
      v15 = 0;
    else
      v15 = *__errno_location();
    if ( status )
      v16 = status;
    else
      v16 = 1;
    v20 = v14;
    v19 = a10;
    error(v16, v15, "%s: %s", a10, v14);
  }
  return v24;
}
// 805107A: using guessed type int sub_805107A(void);
// 805610C: using guessed type int dword_805610C;

//----- (0804F2DB) --------------------------------------------------------
unsigned __int64 __cdecl sub_804F2DB(char *nptr, int a2, int a3, int a4, int a5, char *s, int a7, int status)
{
  int v8; // ecx

  return sub_804F174(a3, v8, nptr, 10, a2, a3, a4, a5, s, a7, status);
}

//----- (0804F34F) --------------------------------------------------------
signed int __cdecl sub_804F34F(int a1, signed int a2)
{
  signed int result; // eax

  if ( (unsigned __int64)sub_8050693(0xFFFFFFFFFFFFFFFFLL, a2, a2 >> 31) >= *(_QWORD *)a1 )
  {
    *(_QWORD *)a1 *= a2;
    result = 0;
  }
  else
  {
    *(_DWORD *)a1 = -1;
    *(_DWORD *)(a1 + 4) = -1;
    result = 1;
  }
  return result;
}

//----- (0804F3FB) --------------------------------------------------------
int __cdecl sub_804F3FB(int a1, signed int a2, int a3)
{
  int v3; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; ; i |= sub_804F34F(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}

//----- (0804F431) --------------------------------------------------------
int __usercall sub_804F431@<eax>(int a1@<edx>, int a2@<ecx>, char *nptr, int a4, int base, int a6, char *s)
{
  void *v7; // eax
  char **v8; // eax
  int result; // eax
  void *v10; // eax
  int v11; // edx
  int v12; // edx
  int v13; // eax
  int v14; // edx
  int v15; // edx
  int v16; // [esp+0h] [ebp-48h]
  unsigned __int8 i; // [esp+1Bh] [ebp-2Dh]
  char v18; // [esp+1Ch] [ebp-2Ch]
  int v19; // [esp+20h] [ebp-28h]
  char *v20; // [esp+24h] [ebp-24h]
  int v21; // [esp+28h] [ebp-20h]
  int v22; // [esp+2Ch] [ebp-1Ch]
  int v23; // [esp+30h] [ebp-18h]
  char **endptr; // [esp+34h] [ebp-14h]
  uintmax_t v25; // [esp+38h] [ebp-10h]

  v19 = 0;
  if ( base < 0 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoumax");
  v7 = &loc_804F463;
  if ( base > 36 )
    v7 = &loc_804F46B;
  dword_8056210 = (int)v7;
  sub_8050A4B(a2, a1);
  if ( a4 )
    v8 = (char **)a4;
  else
    v8 = (char **)&v18;
  endptr = v8;
  *__errno_location() = 0;
  v20 = nptr;
  for ( i = *nptr; (*__ctype_b_loc())[i] & 0x2000; i = *v20 )
    ++v20;
  if ( i == 45 )
    return 4;
  v25 = strtoumax(nptr, endptr, base);
  if ( *endptr != nptr )
  {
LABEL_20:
    if ( *__errno_location() )
    {
      if ( *__errno_location() != 34 )
        return 4;
      v19 = 1;
    }
    goto LABEL_24;
  }
  v10 = &loc_804F539;
  if ( !s )
    v10 = &loc_804F573;
  dword_805615C = (int)v10;
  sub_8050EAE();
  if ( !**endptr || !strchr(s, **endptr) )
  {
    dword_8056198 = (int)&locret_804F8A3;
    sub_8050D58(v16);
    goto LABEL_20;
  }
  v25 = 1LL;
LABEL_24:
  if ( !s )
  {
    v11 = HIDWORD(v25);
    *(_DWORD *)a6 = v25;
    *(_DWORD *)(a6 + 4) = v11;
    dword_8056198 = (int)&locret_804F8A3;
    sub_8050D58(v16);
  }
  if ( !**endptr )
  {
LABEL_55:
    v15 = HIDWORD(v25);
    *(_DWORD *)a6 = v25;
    *(_DWORD *)(a6 + 4) = v15;
    return v19;
  }
  v21 = 1024;
  v22 = 1;
  if ( !strchr(s, **endptr) )
  {
    v12 = HIDWORD(v25);
    *(_DWORD *)a6 = v25;
    *(_DWORD *)(a6 + 4) = v12;
    return v19 | 2;
  }
  switch ( **endptr )
  {
    case 69:
    case 71:
    case 75:
    case 77:
    case 80:
    case 84:
    case 89:
    case 90:
    case 103:
    case 107:
    case 109:
    case 116:
      if ( strchr(s, 48) )
      {
        v13 = (*endptr)[1];
        switch ( v13 )
        {
          case 68:
            goto LABEL_58;
          case 105:
            if ( (*endptr)[2] == 66 )
              v22 += 2;
            goto LABEL_39;
          case 66:
LABEL_58:
            v21 = 1000;
            ++v22;
            break;
        }
      }
      break;
    default:
      break;
  }
LABEL_39:
  switch ( **endptr )
  {
    case 66:
      v23 = sub_804F34F((int)&v25, 1024);
      goto LABEL_53;
    case 69:
      v23 = sub_804F3FB((int)&v25, v21, 6);
      goto LABEL_53;
    case 71:
    case 103:
      v23 = sub_804F3FB((int)&v25, v21, 3);
      goto LABEL_53;
    case 75:
    case 107:
      v23 = sub_804F3FB((int)&v25, v21, 1);
      goto LABEL_53;
    case 77:
    case 109:
      v23 = sub_804F3FB((int)&v25, v21, 2);
      goto LABEL_53;
    case 80:
      v23 = sub_804F3FB((int)&v25, v21, 5);
      goto LABEL_53;
    case 84:
    case 116:
      v23 = sub_804F3FB((int)&v25, v21, 4);
      goto LABEL_53;
    case 89:
      v23 = sub_804F3FB((int)&v25, v21, 8);
      goto LABEL_53;
    case 90:
      v23 = sub_804F3FB((int)&v25, v21, 7);
      dword_8056120 = (int)&loc_804F85D;
      sub_8051002();
      goto LABEL_52;
    case 98:
      v23 = sub_804F34F((int)&v25, 512);
      goto LABEL_53;
    case 99:
      v23 = 0;
      goto LABEL_53;
    case 119:
      v23 = sub_804F34F((int)&v25, 2);
LABEL_53:
      v19 |= v23;
      *endptr += v22;
      if ( **endptr )
        v19 |= 2u;
      goto LABEL_55;
    default:
LABEL_52:
      v14 = HIDWORD(v25);
      *(_DWORD *)a6 = v25;
      *(_DWORD *)(a6 + 4) = v14;
      result = v19 | 2;
      break;
  }
  return result;
}
// 804F431: could not find valid save-restore pair for ebx
// 8050A4B: using guessed type int __fastcall sub_8050A4B(_DWORD, _DWORD);
// 8050D58: using guessed type int __stdcall sub_8050D58(_DWORD);
// 8050EAE: using guessed type int sub_8050EAE(void);
// 8051002: using guessed type int sub_8051002(void);
// 8056120: using guessed type int dword_8056120;
// 805615C: using guessed type int dword_805615C;
// 8056198: using guessed type int dword_8056198;
// 8056210: using guessed type int dword_8056210;

//----- (0804F8A5) --------------------------------------------------------
int __usercall sub_804F8A5@<eax>(signed int a1@<ebx>, FILE *stream)
{
  int v3; // eax
  int v8; // eax
  int v9; // eax
  int v10; // edx
  int v11; // eax
  int v12; // [esp+14h] [ebp-14h]
  int v13; // [esp+18h] [ebp-10h]

  v12 = 0;
  if ( fileno(stream) < 0 )
    return fclose(stream);
  v3 = __freading(stream);
  _CF = 0;
  _OF = 0;
  _ZF = v3 == 0;
  _SF = v3 < 0;
  if ( !v3
    || (v8 = fileno(stream),
        v9 = lseek64(v8, 0, 0, 1),
        v11 = ~v10 | ~v9,
        _CF = 0,
        _OF = 0,
        _ZF = v11 == 0,
        _SF = v11 < 0,
        v11) )
  {
    __asm { pushfw }
    if ( a1 >= 10 && ((_BYTE)a1 - 1) * (_BYTE)a1 & 1 )
      abort();
    __asm { popfw }
    if ( sub_804F9DF(stream) )
      v12 = *__errno_location();
  }
  v13 = fclose(stream);
  if ( v12 )
  {
    *__errno_location() = v12;
    v13 = -1;
  }
  return v13;
}
// 8049050: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804F98D) --------------------------------------------------------
int __cdecl sub_804F98D(FILE *stream)
{
  void *v1; // eax

  v1 = &loc_804F9BA;
  if ( !(stream->_flags & 0x100) )
    v1 = &locret_804F9DD;
  dword_80561D4 = (int)v1;
  sub_8050BD5();
  return sub_804FA57(stream, 0, 0, 1);
}
// 8050BD5: using guessed type int sub_8050BD5(void);
// 80561D4: using guessed type int dword_80561D4;

//----- (0804F9DF) --------------------------------------------------------
int __cdecl sub_804F9DF(FILE *fp)
{
  int v1; // eax
  void *v3; // eax
  int v8; // [esp-4h] [ebp-1Ch]

  if ( fp )
  {
    v1 = __freading(fp);
    _ZF = v1 == 0;
    v8 = v1;
    v3 = &loc_804FA13;
    if ( !_ZF )
      v3 = &loc_804FA3F;
    dword_80561E8 = (int)v3;
    sub_8050B65();
  }
  v8 = fflush(fp);
  __asm { pushfw }
  if ( sub_804F095() != 666 )
    sub_804F09F();
  __asm { popfw }
  return v8;
}
// 804F09F: using guessed type int sub_804F09F(void);
// 8050B65: using guessed type int sub_8050B65(void);
// 80561E8: using guessed type int dword_80561E8;

//----- (0804FA57) --------------------------------------------------------
int __cdecl sub_804FA57(FILE *stream, int a2, int a3, int a4)
{
  void *v4; // eax
  int v5; // eax
  __off64_t v6; // rax
  int v7; // ecx
  int v8; // edx
  int v10; // [esp+18h] [ebp-20h]
  int v11; // [esp+1Ch] [ebp-1Ch]
  __off64_t v12; // [esp+28h] [ebp-10h]

  v10 = a2;
  v11 = a3;
  if ( stream->_IO_read_end != stream->_IO_read_ptr || stream->_IO_write_ptr != stream->_IO_write_base )
    return fseeko64(stream, v10, v11, a4);
  v4 = &loc_804FAC4;
  if ( stream->_IO_save_base )
    v4 = &loc_804FB59;
  dword_8056120 = (int)v4;
  sub_8051002();
  v5 = fileno(stream);
  LODWORD(v6) = lseek64(v5, v10, v11, a4);
  v12 = v6;
  v8 = ~HIDWORD(v6);
  if ( !(v8 | ~(_DWORD)v6) )
  {
    dword_8056210 = (int)&locret_804FB79;
    sub_8050A4B(v7, v8);
  }
  stream->_flags &= 0xFFFFFFEF;
  stream->_offset = v12;
  return 0;
}
// 8048DE0: using guessed type int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8049050: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8050A4B: using guessed type int __fastcall sub_8050A4B(_DWORD, _DWORD);
// 8051002: using guessed type int sub_8051002(void);
// 8056120: using guessed type int dword_8056120;
// 8056210: using guessed type int dword_8056210;

//----- (0804FB7B) --------------------------------------------------------
#error "804FBF8: call analysis failed (funcsize=44)"

//----- (0804FC25) --------------------------------------------------------
int sub_804FC25()
{
  return 0;
}

//----- (0804FC2F) --------------------------------------------------------
int sub_804FC2F()
{
  return 0;
}

//----- (0804FC39) --------------------------------------------------------
int __usercall sub_804FC39@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int *a5@<eax>)
{
  int result; // eax
  int v6; // [esp+14h] [ebp-8h]
  int *v7; // [esp+18h] [ebp-4h]

  v7 = a5;
  __asm { pushfw }
  if ( sub_804F095() != 666 )
    sub_804F09F();
  __asm { popfw }
  v7 = (int *)((char *)&v6 + 2);
  v6 = sub_804FC2F();
  if ( v6 )
    result = v6;
  else
    result = sub_804FC25();
  return result;
}
// 804F09F: using guessed type int sub_804F09F(void);

//----- (0804FC8B) --------------------------------------------------------
int __cdecl sub_804FC8B(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // esi
  unsigned __int8 *v3; // ebx
  unsigned __int8 v5; // [esp+1Eh] [ebp-Ah]
  unsigned __int8 v6; // [esp+1Fh] [ebp-9h]

  v2 = a1;
  v3 = a2;
  if ( a1 == a2 )
    return 0;
  do
  {
    v5 = sub_805065B(*v2);
    v6 = sub_805065B(*v3);
    if ( !v5 )
      break;
    ++v2;
    ++v3;
  }
  while ( v5 == v6 );
  return v5 - v6;
}

//----- (0804FCF0) --------------------------------------------------------
#error "804FD85: call analysis failed (funcsize=58)"

//----- (0804FDA3) --------------------------------------------------------
int __cdecl sub_804FDA3(int category)
{
  unsigned __int8 v2; // [esp+1Bh] [ebp-Dh]
  const char *s1; // [esp+1Ch] [ebp-Ch]

  v2 = 1;
  s1 = setlocale(category, 0);
  if ( s1 && (!strcmp(s1, "C") || !strcmp(s1, "POSIX")) )
    v2 = 0;
  return v2;
}

//----- (0804FE01) --------------------------------------------------------
void *sub_804FE01()
{
  _BOOL4 v0; // eax
  void *v1; // eax
  int v2; // eax
  bool v3; // zf
  void *v4; // eax
  void *v6; // [esp-14h] [ebp-C8h]
  signed int v7; // [esp-10h] [ebp-C4h]
  int v8; // [esp-Ch] [ebp-C0h]
  int v9; // [esp-8h] [ebp-BCh]
  int v10; // [esp-4h] [ebp-B8h]
  void *ptr; // [esp+0h] [ebp-B4h]
  void *v12; // [esp+4h] [ebp-B0h]
  char *s; // [esp+8h] [ebp-ACh]
  void *v14; // [esp+Ch] [ebp-A8h]
  int v15; // [esp+10h] [ebp-A4h]
  char *v16; // [esp+14h] [ebp-A0h]
  size_t n; // [esp+18h] [ebp-9Ch]
  size_t v18; // [esp+1Ch] [ebp-98h]
  _BOOL4 v19; // [esp+20h] [ebp-94h]
  void *dest; // [esp+24h] [ebp-90h]
  int fd; // [esp+28h] [ebp-8Ch]
  FILE *stream; // [esp+2Ch] [ebp-88h]
  int c; // [esp+30h] [ebp-84h]
  int v24; // [esp+34h] [ebp-80h]
  int v25; // [esp+38h] [ebp-7Ch]
  void *v26; // [esp+3Ch] [ebp-78h]
  int v27; // [esp+40h] [ebp-74h]
  int v28; // [esp+44h] [ebp-70h]
  int v29; // [esp+48h] [ebp-6Ch]
  int v30; // [esp+4Ch] [ebp-68h]
  int v31; // [esp+50h] [ebp-64h]
  int v32; // [esp+54h] [ebp-60h]
  unsigned int v33; // [esp+A8h] [ebp-Ch]

  v33 = __readgsdword(0x14u);
  v12 = (void *)dword_805697D;
  if ( !dword_805697D )
  {
    ptr = 0;
    v16 = "charset.alias";
    s = getenv("CHARSETALIASDIR");
    if ( !s || !*s )
    {
      ptr = 0;
      s = "/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib";
    }
    n = strlen(s);
    v18 = strlen(v16);
    v0 = n && s[n - 1] != 47;
    v19 = v0;
    dest = malloc(n + v0 + v18 + 1);
    if ( dest )
    {
      memcpy(dest, s, n);
      if ( v19 )
        *((_BYTE *)dest + n) = 47;
      memcpy((char *)dest + n + v19, v16, v18 + 1);
    }
    free(ptr);
    if ( dest )
    {
      v7 = 0x20000;
      v6 = dest;
      fd = open64();
      if ( fd >= 0 )
      {
        stream = fdopen(fd, "r");
        if ( stream )
        {
          v14 = 0;
          v15 = 0;
          while ( 1 )
          {
            c = getc_unlocked(stream);
            if ( c == -1 )
            {
              dword_80561C0 = (int)&loc_80502A3;
              sub_8050C64(v6, v7, v8, v9, v10, ptr, v12, s, v14, v15, v16, n, v18, v19, dest);
            }
            if ( c != 10 && c != 32 && c != 9 )
            {
              v1 = &loc_80500C4;
              if ( c != 35 )
                v1 = &loc_8050116;
              dword_80561FC = (int)v1;
              sub_8050AC3(
                v6,
                v7,
                v8,
                v9,
                v10,
                ptr,
                v12,
                s,
                v14,
                v15,
                v16,
                n,
                v18,
                v19,
                dest,
                fd,
                stream,
                c,
                v24,
                v25,
                v26,
                v27,
                v28,
                v29,
                v30,
                v31,
                v32);
              do
              {
                v2 = getc_unlocked(stream);
                c = v2;
                v3 = v2 == -1;
                v4 = &loc_80500FA;
                if ( v3 )
                  v4 = &loc_8050103;
                dword_8056184 = (int)v4;
                sub_8050DC8(v6, v7, v8, v9, v10, ptr, v12, s, v14, v15);
              }
              while ( c != 10 );
            }
          }
        }
        close(fd);
        v12 = &unk_8052357;
      }
      else
      {
        v12 = &unk_8052357;
      }
      free(dest);
    }
    else
    {
      v12 = &unk_8052357;
    }
    dword_805697D = (int)v12;
  }
  return v12;
}
// 8048D30: using guessed type int open64(void);
// 8050AC3: using guessed type int __stdcall sub_8050AC3(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8050B65: using guessed type int sub_8050B65(void);
// 8050C64: using guessed type int __stdcall sub_8050C64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8050DC8: using guessed type int __stdcall sub_8050DC8(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8056184: using guessed type int dword_8056184;
// 80561C0: using guessed type int dword_80561C0;
// 80561E8: using guessed type int dword_80561E8;
// 80561FC: using guessed type int dword_80561FC;
// 805697D: using guessed type int dword_805697D;

//----- (08050338) --------------------------------------------------------
const char *sub_8050338()
{
  int v0; // edx
  int v1; // ecx
  void *v2; // eax
  void *v3; // eax
  int v5; // [esp+0h] [ebp-28h]
  const char *s1; // [esp+18h] [ebp-10h]
  char *s2; // [esp+1Ch] [ebp-Ch]

  s1 = nl_langinfo(14);
  if ( !s1 )
    s1 = (const char *)&unk_8052357;
  s2 = (char *)sub_804FE01();
  if ( *s2 )
  {
    if ( strcmp(s1, s2) )
    {
      v2 = &loc_80503A0;
      if ( *s2 != 42 )
        v2 = &loc_80503DE;
      dword_8056210 = (int)v2;
      sub_8050A4B(v1, v0);
      v3 = &loc_80503C6;
      if ( s2[1] )
        v3 = &loc_80503DE;
      dword_80561AC = (int)v3;
      sub_8050CDE(v5);
    }
    s1 = &s2[strlen(s2) + 1];
  }
  if ( !*s1 )
    s1 = "ASCII";
  return s1;
}
// 8050338: could not find valid save-restore pair for ebx
// 8050A4B: using guessed type int __fastcall sub_8050A4B(_DWORD, _DWORD);
// 8050CDE: using guessed type int __cdecl sub_8050CDE(_DWORD);
// 80561AC: using guessed type int dword_80561AC;
// 8056210: using guessed type int dword_8056210;

//----- (0805065B) --------------------------------------------------------
int __cdecl sub_805065B(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 65) > 0x19 )
    result = a1;
  else
    result = a1 + 32;
  return result;
}

//----- (08050693) --------------------------------------------------------
signed __int64 __cdecl sub_8050693(unsigned __int64 a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // esi
  signed __int64 result; // rax
  int v5; // ebp
  int v6; // ebp
  unsigned __int64 v7; // rtt
  unsigned int v8; // esi
  unsigned int v9; // edi
  unsigned __int64 v10; // rax
  unsigned int *v11; // ecx
  void *v12; // eax
  unsigned int v13; // [esp+0h] [ebp-18h]
  unsigned int v14; // [esp+4h] [ebp-14h]
  unsigned int v15; // [esp+8h] [ebp-10h]

  v14 = a1;
  v13 = a2;
  if ( a3 )
  {
    if ( a3 <= HIDWORD(a1) )
    {
      _BitScanReverse((unsigned int *)&v5, a3);
      v6 = v5 ^ 0x1F;
      if ( v6 )
      {
        v15 = v13 >> (32 - v6);
        v15 |= a3 << v6;
        v13 <<= v6;
        LODWORD(v7) = (HIDWORD(a1) << (char)&v13) | (v14 >> (32 - v6));
        HIDWORD(v7) = HIDWORD(a1) >> (32 - v6);
        v8 = v7 % v15;
        v9 = v7 / v15;
        v10 = v13 * (unsigned __int64)v9;
        v13 = HIDWORD(v10);
        if ( v8 < HIDWORD(v10) )
          return v9 - 1;
        v11 = &v13;
        if ( v14 << (char)&v13 < (unsigned int)v10 )
        {
          v12 = &loc_80507CD;
          if ( v8 == v13 )
            v12 = &loc_80507F9;
          dword_80561E8 = (int)v12;
          sub_8050B65();
        }
        dword_8056148 = (int)&loc_805072A;
        sub_8050F26(v11, 0);
      }
      else if ( v13 > v14 && a3 >= HIDWORD(a1) )
      {
        return 0LL;
      }
      return 1LL;
    }
    return 0LL;
  }
  if ( a2 > HIDWORD(a1) )
    return (unsigned int)(a1 / a2);
  v3 = a2;
  if ( !a2 )
    v3 = 1 / 0u;
  LODWORD(result) = __PAIR__(HIDWORD(a1) % v3, (unsigned int)a1) / v3;
  HIDWORD(result) = HIDWORD(a1) / v3;
  return result;
}
// 8050B65: using guessed type int sub_8050B65(void);
// 8050F26: using guessed type int __fastcall sub_8050F26(_DWORD, _DWORD);
// 8056148: using guessed type int dword_8056148;
// 80561E8: using guessed type int dword_80561E8;

//----- (080508A4) --------------------------------------------------------
int __cdecl sub_80508A4(int a1)
{
  return __cxa_atexit(a1, 0, dword_8056240);
}
// 8048EB0: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 8056240: using guessed type int dword_8056240;

//----- (08050A4B) --------------------------------------------------------
#error "8050A51: positive sp value has been found (funcsize=0)"

//----- (08050AC3) --------------------------------------------------------
#error "8050AC9: positive sp value has been found (funcsize=0)"

//----- (08050B24) --------------------------------------------------------
#error "8050B5D: positive sp value has been found (funcsize=18)"

//----- (08050B65) --------------------------------------------------------
#error "8050B6B: positive sp value has been found (funcsize=0)"

//----- (08050BD5) --------------------------------------------------------
#error "8050BDB: positive sp value has been found (funcsize=0)"

//----- (08050C23) --------------------------------------------------------
#error "8050C5C: positive sp value has been found (funcsize=18)"

//----- (08050C64) --------------------------------------------------------
#error "8050C6A: positive sp value has been found (funcsize=0)"

//----- (08050CDE) --------------------------------------------------------
#error "8050CE4: positive sp value has been found (funcsize=0)"

//----- (08050D58) --------------------------------------------------------
#error "8050D5E: positive sp value has been found (funcsize=0)"

//----- (08050DC8) --------------------------------------------------------
#error "8050DCE: positive sp value has been found (funcsize=0)"

//----- (08050E36) --------------------------------------------------------
#error "8050E3C: positive sp value has been found (funcsize=0)"

//----- (08050EAE) --------------------------------------------------------
#error "8050EB4: positive sp value has been found (funcsize=0)"

//----- (08050F26) --------------------------------------------------------
#error "8050F2C: positive sp value has been found (funcsize=0)"

//----- (08050F92) --------------------------------------------------------
#error "8050F98: positive sp value has been found (funcsize=0)"

//----- (08051002) --------------------------------------------------------
#error "8051008: positive sp value has been found (funcsize=0)"

//----- (0805107A) --------------------------------------------------------
#error "8051080: positive sp value has been found (funcsize=0)"

//----- (08051090) --------------------------------------------------------
int (**sub_8051090())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_8055EC4;
  v1 = &off_8055EC8 - off_8055EC4;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_8055EC4[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 8055EC4: using guessed type int (*off_8055EC4[2])();
// 8055EC8: using guessed type int (*off_8055EC8)();

//----- (080510F4) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 40 decompilation failure(s) on 164 function(s)"
