/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8048D10();
// int strcmp(const char *s1, const char *s2);
// int __cdecl open64(_DWORD, _DWORD); weak
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void _exit(int status);
// void *memmove(void *dest, const void *src, size_t n);
// void free(void *ptr);
// uintmax_t strtoumax(const char *nptr, char **endptr, int base);
// void *memcpy(void *dest, const void *src, size_t n);
// int fclose(FILE *stream);
// int getc_unlocked(FILE *stream);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int fputc_unlocked(int c, FILE *stream);
// char *textdomain(const char *domainname);
// int __cdecl fopen64(_DWORD, _DWORD); weak
// int ferror_unlocked(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// size_t __ctype_get_mb_cur_max(void);
// size_t __fpending(FILE *fp);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// void error(int status, int errnum, const char *format, ...);
// size_t fread_unlocked(void *ptr, size_t size, size_t n, FILE *stream);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __fastcall fputs_unlocked(_DWORD); weak
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// char *strchr(const char *s, int c);
// int fscanf(FILE *stream, const char *format, ...);
// size_t strlen(const char *s);
// int fprintf(FILE *stream, const char *format, ...);
// void *memset(void *s, int c, size_t n);
// int ungetc(int c, FILE *stream);
// int *__errno_location(void);
// void *memchr(const void *s, int c, size_t n);
// int fileno(FILE *stream);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// char *strrchr(const char *s, int c);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// char *bindtextdomain(const char *domainname, const char *dirname);
// int __stdcall posix_fadvise64(_DWORD, _DWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// int feof_unlocked(FILE *stream);
// void abort(void);
// int close(int fd);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// int _gmon_start__(void); weak
void sub_8049133();
void sub_8049150();
int sub_8049160();
int sub_80491D0();
int sub_80491F0();
void sub_804924F();
void sub_804926A();
int sub_804927A();
void sub_8049434();
void sub_804944F();
signed int sub_804945F();
void sub_804958A();
void sub_80495A5();
int sub_80495B5();
void sub_804969D();
void sub_80496B8();
int sub_80496C8();
void sub_80497B0();
void sub_80497CB();
int sub_80497DB();
void sub_80498C3();
void sub_80498DE();
int sub_80498EE();
void sub_8049A0A();
void sub_8049A25();
int sub_8049A35();
// int __usercall sub_8049A8D@<eax>(int a1@<eax>, int (__cdecl *a2)(char *, int)@<edx>);
void sub_8049B25();
void sub_8049B40();
int sub_8049B50();
void sub_8049C38();
void sub_8049CD9();
int sub_8049CE9();
void sub_8049E00();
signed int sub_8049E04();
int __fastcall sub_8049E0E(_DWORD, _DWORD); // weak
void sub_8049E5A();
int sub_8049F36();
void sub_804A01E();
// void __usercall __spoils<edx,ecx> sub_804A039(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>);
// int __usercall sub_804A086@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>);
void sub_804A1A7();
void sub_804A1F6();
// signed int __usercall sub_804A206@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>);
int nullsub_3(void); // weak
int sub_804A2AF();
void sub_804A397();
// int __usercall sub_804A3C6@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>);
unsigned int __fastcall sub_804A54E(int a1, signed __int32 a2);
void sub_804A6B2();
void sub_804A6DD();
signed int sub_804A6E1();
// void __usercall __noreturn sub_804A6EB(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>);
// signed int __usercall sub_804A73F@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>);
int sub_804A89A();
// int __usercall sub_804A90D@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>);
// int __usercall sub_804A9B5@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, char *s1);
int __cdecl sub_804ABF3(int status); // idb
size_t __cdecl sub_804AD4C(void *ptr, size_t n, int a3, int a4, int a5, FILE *stream);
signed __int32 __cdecl sub_804AF2E(FILE *a1, FILE *a2, __int64 a3);
// unsigned int __usercall sub_804B18F@<eax>(signed __int32 a1@<ecx>, char *a2@<ebx>, FILE *a3, FILE *a4, char a5);
// int __usercall main@<eax>(char *a1@<ebx>, int argc, char **argv);
int __cdecl sub_804B9BD(char *a1, int a2);
int __cdecl sub_804BD84(char *a1, int a2, _BYTE *a3, unsigned int a4);
int __cdecl sub_804C304(unsigned __int8 a1);
// signed int __usercall sub_804C425@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>);
// int __usercall sub_804C581@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, _DWORD *a4, char **a5, unsigned int a6, _DWORD *a7);
signed int __cdecl sub_804C6B6(unsigned __int8 *a1, unsigned int a2, int *a3, _DWORD *a4);
// int __usercall sub_804CC1F@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, int *a4, unsigned __int8 *a5, unsigned int a6, char a7, int *a8);
// void __usercall sub_804CD49(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, int a3@<ebp>);
// void __usercall sub_804CD7E(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, int a3@<ebx>, int a4@<ebp>);
// void __usercall sub_804CDF4(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, int a3@<ebp>);
int __cdecl sub_804CEA4(int, int, int); // weak
// void __usercall sub_804CF31(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, int a3@<ebp>);
int __cdecl sub_804D007(int, int, int); // weak
// void __usercall sub_804D072(signed __int32 a1@<ebx>, int a2@<ebp>);
int sub_804D0A2(); // weak
// void __usercall sub_804D265(signed __int32 a1@<edx>, signed __int32 a2@<ebx>);
void __cdecl __noreturn sub_804D3C5(int errnum, char *format, int); // idb
int sub_804D3F8(); // weak
// int __usercall sub_804D43E@<eax>(signed __int32 a1@<ebx>, int a2, int a3);
// void __usercall sub_804D510(signed __int32 a1@<ebx>, FILE *stream);
char *__cdecl sub_804D56B(char *s);
int __cdecl sub_804D6C3(int *a1, unsigned __int8 a2, char a3);
int *__cdecl sub_804D7E6(int *a1, int a2, int a3);
// _DWORD *__userpurge sub_804D842@<eax>(_DWORD *a1, int a2);
// char *__usercall sub_804D8D8@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>, const char *msgid, int a8);
void __cdecl sub_804D9FA(int a1, int a2, int a3, int a4, unsigned int a5, int a6, int a7, int a8, int a9);
// void __usercall sub_804E48A(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, int a3@<ebp>);
// void __usercall sub_804E673(int a1@<ebp>);
void *__cdecl sub_804E7F8(int a1, int a2, _DWORD *a3, int *a4);
// signed int __usercall sub_804EA56@<eax>(signed __int32 a1@<ebx>, int a2, int a3, int a4, unsigned int *a5);
// signed int __usercall sub_804ED14@<eax>(signed __int32 a1@<ebx>, int a2, int a3);
// signed int __usercall sub_804ED3E@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, int a8, int a9, int a10);
// int __usercall sub_804EF6D@<eax>(signed __int32 ecx0@<ecx>, signed __int32 ebx0@<ebx>, int a1, int a2);
// signed int __usercall sub_804EF8F@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, int a3, int a4, int a5);
// signed int __usercall sub_804EFF4@<eax>(signed __int32 a1@<ebx>, int a2, int a3, int a4, int a5);
// signed int __usercall sub_804F0C4@<eax>(signed __int32 a1@<ebx>, int a2, int a3, unsigned __int8 a4);
// signed int __usercall sub_804F256@<eax>(signed __int32 a1@<ebx>, int a2, unsigned __int8 a3);
// signed int __usercall sub_804F29A@<eax>(signed __int32 a1@<ebx>, int a2);
// signed int __usercall sub_804F35A@<eax>(signed __int32 a1@<eax>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, int a4, int a5, int a6);
// signed int __usercall sub_804F556@<eax>(signed __int32 a1@<ebx>, int a2, int a3, int a4, int a5);
// signed int __usercall sub_804F586@<eax>(signed __int32 a1@<ebx>, int a2, int a3, int a4, int a5, int a6);
// signed int __usercall sub_804F79A@<eax>(signed __int32 a1@<ebx>, int a2, int a3, int a4);
// signed int __usercall sub_804F7F9@<eax>(signed __int32 a1@<ebx>, int a2, int a3);
// signed int __usercall sub_804F81B@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, int a8);
// int __usercall sub_804F99D@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>, FILE *stream, int a4, int a5, int a6, int a7, int a8);
// int __usercall sub_80501E7@<eax>(signed __int32 a1@<eax>, signed __int32 a2@<edx>, int a3@<ecx>, signed __int32 a4@<ebx>, FILE *stream, int a6, int a7, int a8, int a9);
// int __usercall sub_80502F9@<eax>(signed __int32 a1@<edx>, int a2@<ecx>, signed __int32 a3@<ebx>, FILE *stream, int a5, int a6, int a7, ...);
// void __usercall sub_8050412(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, int a4, int *a5, unsigned int a6);
// void __usercall sub_80504E2(signed __int32 a1@<ebx>, int a2@<ebp>);
int __cdecl sub_805052E(size_t size); // idb
// void *__usercall sub_8050560@<eax>(signed __int32 a1@<ebx>, size_t size);
// void *__usercall sub_8050655@<eax>(signed __int32 a1@<ebx>, size_t size);
// void *__usercall sub_80506E2@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, void *ptr, size_t size);
// void *__usercall sub_80507E3@<eax>(signed __int32 a1@<ebx>, void *src, size_t n);
// void __usercall __noreturn sub_8050844(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>);
void sub_8050945();
// int __usercall sub_805095A@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, signed __int32 a3, int a4);
// unsigned __int64 __usercall sub_8050AB5@<edx:eax>(signed __int32 a1@<ebx>, char *nptr, int base, int a4, int a5, int a6, int a7, char *s, int a9, int a10);
// unsigned __int64 __usercall sub_8050C48@<edx:eax>(signed __int32 a1@<ebx>, char *nptr, int a3, int a4, int a5, int a6, char *s, int a8, int a9);
signed int __cdecl sub_8050CBC(unsigned int *a1, signed int a2);
// signed int __usercall sub_8050DF3@<eax>(signed __int32 a1@<eax>, signed __int32 a2@<edx>, signed __int32 a3@<ecx>, signed __int32 a4@<ebx>, unsigned int *a5, signed int a6, signed __int32 a7);
// int __usercall sub_8050EED@<eax>(signed __int32 a1@<ebx>, char *nptr, int a3, int base, int a5, char *s);
// int __usercall sub_8051328@<eax>(signed __int32 a1@<ebx>, FILE *stream);
// int __usercall sub_8051419@<eax>(int a1@<edx>, int a2@<ecx>, signed __int32 a3@<ebx>, FILE *stream);
// int __usercall sub_80515B4@<eax>(signed __int32 a1@<ebx>, int a2, FILE *fp);
// int __usercall sub_8051650@<eax>(signed __int32 a1@<ebx>, FILE *stream, int a3, int a4, int a5);
// unsigned __int32 __usercall sub_80517C6@<eax>(int a1@<edx>, int a2@<ecx>, signed __int32 a3@<ebx>, wchar_t *pwc, char *s, size_t n, mbstate_t *p);
int sub_805186D();
// signed int __usercall sub_8051878@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>);
// void __usercall sub_80519C1(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, int a3, int a4);
int sub_8051A8C(); // weak
// int __usercall sub_8051A91@<eax>(signed __int32 a1@<edx>, unsigned __int8 *a2, unsigned __int8 *a3);
// int __usercall sub_8051B5D@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>, FILE *stream);
// int __usercall sub_8051C5A@<eax>(signed __int32 a1@<eax>, signed __int32 a2@<edx>, int category);
// void *__usercall sub_8051CF9@<eax>(signed __int32 a1@<ebx>);
// signed __int32 __usercall sub_80521BF@<eax>(signed __int32 a1@<eax>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>);
// int __usercall sub_8052505@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>, int a3);
signed __int64 __cdecl sub_8052630(unsigned __int64 a1, unsigned int a2, unsigned int a3);
int __cdecl sub_805282E(int a1);
int __fastcall sub_8052A2B(_DWORD, _DWORD); // weak
int __fastcall sub_8052AF1(_DWORD, _DWORD); // weak
int __fastcall sub_8052D8F(_DWORD, _DWORD); // weak
int (**sub_8052F00())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

char byte_804A720[2] = { 'f', '\x90' }; // weak
_UNKNOWN loc_804AB1E; // weak
_UNKNOWN loc_804AF1C; // weak
_UNKNOWN loc_804B4CF; // weak
_UNKNOWN loc_804B747; // weak
_UNKNOWN loc_804B880; // weak
_UNKNOWN loc_804B8C6; // weak
_UNKNOWN loc_804CC7D; // weak
_UNKNOWN loc_804CCD8; // weak
_UNKNOWN loc_804CFDE; // weak
_UNKNOWN loc_804D2FB; // weak
_UNKNOWN loc_804D3EB; // weak
_UNKNOWN loc_804E513; // weak
_UNKNOWN loc_804E693; // weak
_UNKNOWN loc_804EAF7; // weak
_UNKNOWN loc_804F67D; // weak
_UNKNOWN loc_804F6A5; // weak
_UNKNOWN loc_804F6F0; // weak
_UNKNOWN loc_805022E; // weak
_UNKNOWN loc_8050472; // weak
_UNKNOWN loc_8050540; // weak
_UNKNOWN loc_8050C1D; // weak
_UNKNOWN loc_8050E53; // weak
_UNKNOWN loc_8050EBA; // weak
_UNKNOWN loc_8051446; // weak
_UNKNOWN loc_8051454; // weak
_UNKNOWN loc_8051530; // weak
_UNKNOWN loc_8051577; // weak
_UNKNOWN loc_80517EB; // weak
_UNKNOWN loc_80517F1; // weak
_UNKNOWN locret_8051A8F; // weak
_UNKNOWN loc_8051DD8; // weak
_UNKNOWN loc_8051DDF; // weak
_UNKNOWN loc_8052035; // weak
_UNKNOWN loc_805203A; // weak
_UNKNOWN loc_805229A; // weak
_UNKNOWN loc_8052742; // weak
_UNKNOWN loc_805275C; // weak
_UNKNOWN unk_80530EA; // weak
char s = '\0'; // idb
struct option longopts = { "decode", 0, NULL, 100 }; // idb
char aDDecodeDecodeD[131] = "  -d, --decode          decode data\n  -i, --ignore-garbage  when decoding, ignore non-alphabet characters\n  -w, --wrap=COLS       w"; // idb
_UNKNOWN unk_80538B6; // weak
_UNKNOWN unk_80538BA; // weak
_UNKNOWN unk_80538C6; // weak
_UNKNOWN unk_80538CA; // weak
_UNKNOWN unk_80538CD; // weak
_UNKNOWN unk_80538CF; // weak
_DWORD off_80538D4[11] =
{
  134536118,
  134536042,
  134536061,
  134536038,
  134536046,
  134535831,
  134535820,
  134535888,
  134535901,
  134535901,
  134535901
}; // idb
char aWrit[4] = "Writ"; // idb
void *off_8053E5C = &loc_804FACB; // weak
_UNKNOWN unk_80541CF; // weak
_UNKNOWN unk_80551F0; // weak
_UNKNOWN unk_80551F3; // weak
int (*off_8057ED0[2])() = { &sub_80491F0, &sub_80491D0 }; // weak
int (*off_8057ED4)() = &sub_80491D0; // weak
int (*dword_8058008)(void) = NULL; // weak
int dword_8058130 = 0; // weak
int dword_8058134 = 0; // weak
int dword_8058158 = 0; // weak
int dword_8058164 = 0; // weak
int dword_8058170 = 0; // weak
int dword_8058180 = 0; // weak
int dword_8058184 = 0; // weak
int dword_8058194 = 0; // weak
int dword_8058198 = 0; // weak
int (__fastcall *dword_80581A4)(_DWORD, _DWORD) = NULL; // weak
int dword_80581A8 = 0; // weak
int dword_80581B4 = 0; // weak
int dword_80581C8 = 0; // weak
int off_80581CC = 134559295; // idb
int status = 1; // idb
int dword_80581E4 = 1; // weak
int dword_80581E8 = 256; // weak
void *off_80581EC = &unk_8058716; // weak
int *off_80581F0 = &dword_80581E8; // weak
_UNKNOWN unk_8058204; // weak
_UNKNOWN unk_8058220; // weak
_UNKNOWN unk_8058223; // weak
_UNKNOWN unk_8058228; // weak
_UNKNOWN unk_805822B; // weak
_UNKNOWN unk_8058234; // weak
_UNKNOWN unk_8058237; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int program_invocation_name; // weak
int optind; // weak
int stdin; // weak
FILE *stdout; // idb
char *optarg; // idb
char byte_805828C; // weak
_UNKNOWN unk_80584F8; // weak
int dword_80586C6; // weak
char byte_80586CA; // weak
int dword_80586CE; // weak
int dword_80586D6; // weak
int dword_80586DA; // weak
int dword_80586DE; // weak
int dword_80586E2; // weak
int dword_80586E6; // weak
int dword_80586EA; // weak
int dword_80586EE; // weak
int dword_80586F2; // weak
int dword_80586F6; // weak
int dword_80586FA; // weak
int dword_80586FE; // weak
int dword_8058702; // weak
_UNKNOWN unk_8058716; // weak
int dword_8058816; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (08048CE0) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 80490F0: using guessed type int _gmon_start__(void);

//----- (08048D10) --------------------------------------------------------
int sub_8048D10()
{
  return dword_8058008();
}
// 8058008: using guessed type int (*dword_8058008)(void);

//----- (08049100) --------------------------------------------------------
#error "8049103: positive sp value has been found (funcsize=2)"

//----- (08049133) --------------------------------------------------------
void sub_8049133()
{
  ;
}

//----- (08049150) --------------------------------------------------------
void sub_8049150()
{
  ;
}

//----- (08049160) --------------------------------------------------------
int sub_8049160()
{
  int result; // eax

  result = &unk_8058237 - &unk_8058234;
  if ( (unsigned int)(&unk_8058237 - &unk_8058234) > 6 )
    result = 0;
  return result;
}
// 8049160: could not find valid save-restore pair for ebp

//----- (080491D0) --------------------------------------------------------
int sub_80491D0()
{
  int result; // eax

  if ( !byte_805828C )
  {
    result = sub_8049160();
    byte_805828C = 1;
  }
  return result;
}
// 80491D0: could not find valid save-restore pair for ebp
// 805828C: using guessed type char byte_805828C;

//----- (080491F0) --------------------------------------------------------
int sub_80491F0()
{
  return 0;
}
// 80491F0: could not find valid save-restore pair for ebp

//----- (0804924F) --------------------------------------------------------
void sub_804924F()
{
  ;
}

//----- (0804926A) --------------------------------------------------------
void sub_804926A()
{
  ;
}

//----- (0804927A) --------------------------------------------------------
int sub_804927A()
{
  int result; // eax

  result = &unk_805822B - &unk_8058228;
  _CF = (unsigned int)(&unk_805822B - &unk_8058228) < 6;
  _OF = __OFSUB__(&unk_805822B - &unk_8058228, 6);
  _ZF = &unk_805822B - &unk_8058228 == 6;
  _SF = &unk_805822B - &unk_8058228 - 6 < 0;
  if ( (unsigned int)(&unk_805822B - &unk_8058228) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 804927A: could not find valid save-restore pair for ebp

//----- (08049434) --------------------------------------------------------
void sub_8049434()
{
  ;
}

//----- (0804944F) --------------------------------------------------------
void sub_804944F()
{
  ;
}

//----- (0804945F) --------------------------------------------------------
signed int sub_804945F()
{
  return 3;
}
// 804945F: could not find valid save-restore pair for ebp

//----- (0804958A) --------------------------------------------------------
void sub_804958A()
{
  ;
}

//----- (080495A5) --------------------------------------------------------
void sub_80495A5()
{
  ;
}

//----- (080495B5) --------------------------------------------------------
int sub_80495B5()
{
  int result; // eax

  result = &unk_805822B - &unk_8058228;
  _CF = (unsigned int)(&unk_805822B - &unk_8058228) < 6;
  _OF = __OFSUB__(&unk_805822B - &unk_8058228, 6);
  _ZF = &unk_805822B - &unk_8058228 == 6;
  _SF = &unk_805822B - &unk_8058228 - 6 < 0;
  if ( (unsigned int)(&unk_805822B - &unk_8058228) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 80495B5: could not find valid save-restore pair for ebp

//----- (0804969D) --------------------------------------------------------
void sub_804969D()
{
  ;
}

//----- (080496B8) --------------------------------------------------------
void sub_80496B8()
{
  ;
}

//----- (080496C8) --------------------------------------------------------
int sub_80496C8()
{
  int result; // eax

  result = &unk_8058223 - &unk_8058220;
  _CF = (unsigned int)(&unk_8058223 - &unk_8058220) < 6;
  _OF = __OFSUB__(&unk_8058223 - &unk_8058220, 6);
  _ZF = &unk_8058223 - &unk_8058220 == 6;
  _SF = &unk_8058223 - &unk_8058220 - 6 < 0;
  if ( (unsigned int)(&unk_8058223 - &unk_8058220) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 80496C8: could not find valid save-restore pair for ebp

//----- (080497B0) --------------------------------------------------------
void sub_80497B0()
{
  ;
}

//----- (080497CB) --------------------------------------------------------
void sub_80497CB()
{
  ;
}

//----- (080497DB) --------------------------------------------------------
int sub_80497DB()
{
  int result; // eax

  result = &unk_80551F3 - &unk_80551F0;
  _CF = (unsigned int)(&unk_80551F3 - &unk_80551F0) < 6;
  _OF = __OFSUB__(&unk_80551F3 - &unk_80551F0, 6);
  _ZF = &unk_80551F3 - &unk_80551F0 == 6;
  _SF = &unk_80551F3 - &unk_80551F0 - 6 < 0;
  if ( (unsigned int)(&unk_80551F3 - &unk_80551F0) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 80497DB: could not find valid save-restore pair for ebp

//----- (080498C3) --------------------------------------------------------
void sub_80498C3()
{
  ;
}

//----- (080498DE) --------------------------------------------------------
void sub_80498DE()
{
  ;
}

//----- (080498EE) --------------------------------------------------------
int sub_80498EE()
{
  int result; // eax

  result = &unk_805822B - &unk_8058228;
  _CF = (unsigned int)(&unk_805822B - &unk_8058228) < 6;
  _OF = __OFSUB__(&unk_805822B - &unk_8058228, 6);
  _ZF = &unk_805822B - &unk_8058228 == 6;
  _SF = &unk_805822B - &unk_8058228 - 6 < 0;
  if ( (unsigned int)(&unk_805822B - &unk_8058228) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 80498EE: could not find valid save-restore pair for ebp

//----- (08049A0A) --------------------------------------------------------
void sub_8049A0A()
{
  ;
}

//----- (08049A25) --------------------------------------------------------
void sub_8049A25()
{
  ;
}

//----- (08049A35) --------------------------------------------------------
int sub_8049A35()
{
  int result; // eax

  result = "" - "50s";
  _CF = (unsigned int)("" - "50s") < 6;
  _OF = __OFSUB__("" - "50s", 6);
  _ZF = "" - "50s" == 6;
  _SF = "" - "50s" - 6 < 0;
  if ( (unsigned int)("" - "50s") > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 8049A35: could not find valid save-restore pair for ebp

//----- (08049A8D) --------------------------------------------------------
int __usercall sub_8049A8D@<eax>(int a1@<eax>, int (__cdecl *a2)(char *, int)@<edx>)
{
  return a2("50s", a1);
}

//----- (08049B25) --------------------------------------------------------
void sub_8049B25()
{
  ;
}

//----- (08049B40) --------------------------------------------------------
void sub_8049B40()
{
  ;
}

//----- (08049B50) --------------------------------------------------------
int sub_8049B50()
{
  int result; // eax

  result = &unk_805822B - &unk_8058228;
  _CF = (unsigned int)(&unk_805822B - &unk_8058228) < 6;
  _OF = __OFSUB__(&unk_805822B - &unk_8058228, 6);
  _ZF = &unk_805822B - &unk_8058228 == 6;
  _SF = &unk_805822B - &unk_8058228 - 6 < 0;
  if ( (unsigned int)(&unk_805822B - &unk_8058228) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 8049B50: could not find valid save-restore pair for ebp

//----- (08049C38) --------------------------------------------------------
void sub_8049C38()
{
  ;
}

//----- (08049CD9) --------------------------------------------------------
void sub_8049CD9()
{
  ;
}

//----- (08049CE9) --------------------------------------------------------
int sub_8049CE9()
{
  int result; // eax

  result = &unk_80584F8 - (_UNKNOWN *)&program_invocation_short_name;
  _CF = (unsigned int)(&unk_80584F8 - (_UNKNOWN *)&program_invocation_short_name) < 6;
  _OF = __OFSUB__(&unk_80584F8 - (_UNKNOWN *)&program_invocation_short_name, 6);
  _ZF = &unk_80584F8 - (_UNKNOWN *)&program_invocation_short_name == 6;
  _SF = &unk_80584F8 - (_UNKNOWN *)&program_invocation_short_name - 6 < 0;
  if ( (unsigned int)(&unk_80584F8 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 8049CE9: could not find valid save-restore pair for ebp
// 8058240: using guessed type int program_invocation_short_name;

//----- (08049E00) --------------------------------------------------------
void sub_8049E00()
{
  ;
}

//----- (08049E04) --------------------------------------------------------
signed int sub_8049E04()
{
  return 675;
}

//----- (08049E5A) --------------------------------------------------------
void sub_8049E5A()
{
  ;
}

//----- (08049F36) --------------------------------------------------------
int sub_8049F36()
{
  int result; // eax

  result = "rap encoded lines after COLS character (default 76).\n"
           "                          Use 0 to disable line wrapping\n"
           "\n"
         - &aDDecodeDecodeD[128];
  _CF = (unsigned int)("rap encoded lines after COLS character (default 76).\n"
                       "                          Use 0 to disable line wrapping\n"
                       "\n"
                     - &aDDecodeDecodeD[128]) < 6;
  _OF = __OFSUB__(
          "rap encoded lines after COLS character (default 76).\n"
          "                          Use 0 to disable line wrapping\n"
          "\n"
        - &aDDecodeDecodeD[128],
          6);
  _ZF = "rap encoded lines after COLS character (default 76).\n"
        "                          Use 0 to disable line wrapping\n"
        "\n"
      - &aDDecodeDecodeD[128] == 6;
  _SF = "rap encoded lines after COLS character (default 76).\n"
        "                          Use 0 to disable line wrapping\n"
        "\n"
      - &aDDecodeDecodeD[128]
      - 6 < 0;
  if ( (unsigned int)("rap encoded lines after COLS character (default 76).\n"
                      "                          Use 0 to disable line wrapping\n"
                      "\n"
                    - &aDDecodeDecodeD[128]) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 8049F36: could not find valid save-restore pair for ebp

//----- (0804A01E) --------------------------------------------------------
void sub_804A01E()
{
  ;
}

//----- (0804A039) --------------------------------------------------------
void __usercall __spoils<edx,ecx> sub_804A039(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>)
{
  signed __int32 v6; // eax
  signed __int32 v7; // eax
  signed __int32 v8; // edx
  int v9; // ecx
  signed __int32 v10; // eax

  __asm { pushfw }
  v6 = _InterlockedExchange(&dword_8058158, a5);
  _InterlockedExchange(&dword_8058158, a6);
  _InterlockedExchange(&dword_8058158, v6);
  v7 = sub_8049E04();
  if ( v7 != 675 )
  {
    v10 = _InterlockedExchange(&dword_8058158, v7);
    _InterlockedExchange(&dword_8058158, v8);
    sub_8049E0E(v9, _InterlockedExchange(&dword_8058158, v10));
  }
  __asm { popfw }
}
// 8049E0E: using guessed type int __fastcall sub_8049E0E(_DWORD, _DWORD);
// 8058158: using guessed type int dword_8058158;

//----- (0804A086) --------------------------------------------------------
int __usercall sub_804A086@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>)
{
  char v7; // al
  signed __int32 v8; // et0
  int result; // eax
  int v14; // [esp+18h] [ebp-4h]

  v14 = a5;
  __asm { pushfw }
  if ( a7 >= 10 )
  {
    v8 = _InterlockedExchange(&dword_8058158, a7);
    v7 = _InterlockedExchange(&dword_8058158, a6);
    _InterlockedExchange(&dword_8058158, v8);
    if ( ((_BYTE)a7 - 1) * v7 & 1 )
      abort();
  }
  __asm { popfw }
  result = &unk_8058223 - &unk_8058220;
  _CF = (unsigned int)(&unk_8058223 - &unk_8058220) < 6;
  _OF = __OFSUB__(&unk_8058223 - &unk_8058220, 6);
  _ZF = &unk_8058223 - &unk_8058220 == 6;
  _SF = &unk_8058223 - &unk_8058220 - 6 < 0;
  if ( (unsigned int)(&unk_8058223 - &unk_8058220) > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 804A086: could not find valid save-restore pair for ebp
// 8058158: using guessed type int dword_8058158;

//----- (0804A1A7) --------------------------------------------------------
void sub_804A1A7()
{
  ;
}

//----- (0804A1F6) --------------------------------------------------------
void sub_804A1F6()
{
  ;
}

//----- (0804A206) --------------------------------------------------------
signed int __usercall sub_804A206@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>)
{
  signed __int32 v6; // ebx

  __asm { pushfw }
  v6 = _InterlockedExchange(&dword_8058164, a6);
  _InterlockedExchange(&dword_8058164, a5);
  _InterlockedExchange(&dword_8058164, v6);
  return 85;
}
// 8058164: using guessed type int dword_8058164;

//----- (0804A230) --------------------------------------------------------
#error "804A24F: positive sp value has been found (funcsize=8)"

//----- (0804A2AF) --------------------------------------------------------
int sub_804A2AF()
{
  return nullsub_3();
}
// 804A2AF: could not find valid save-restore pair for ebp
// 804A2AE: using guessed type int nullsub_3(void);

//----- (0804A397) --------------------------------------------------------
void sub_804A397()
{
  ;
}

//----- (0804A3C6) --------------------------------------------------------
int __usercall sub_804A3C6@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>)
{
  char v7; // al
  signed __int32 v8; // et0
  char v9; // al
  signed __int32 v10; // et1
  int v12; // [esp-4h] [ebp-4h]

  v12 = a5;
  __asm { pushfw }
  if ( a7 >= 10 )
  {
    v8 = _InterlockedExchange(&dword_8058158, a7);
    v7 = _InterlockedExchange(&dword_8058158, a6);
    a6 = _InterlockedExchange(&dword_8058158, v8);
    if ( ((_BYTE)a7 - 1) * v7 & 1 )
      abort();
  }
  __asm
  {
    popfw
    pushfw
  }
  if ( a7 >= 10 )
  {
    v10 = _InterlockedExchange(&dword_8058164, a7);
    v9 = _InterlockedExchange(&dword_8058164, a6);
    _InterlockedExchange(&dword_8058164, v10);
    if ( ((_BYTE)a7 - 1) * v9 & 1 )
      abort();
  }
  __asm { popfw }
  return v12;
}
// 804A3C6: could not find valid save-restore pair for ebx
// 8058158: using guessed type int dword_8058158;
// 8058164: using guessed type int dword_8058164;

//----- (0804A54E) --------------------------------------------------------
unsigned int __fastcall sub_804A54E(int a1, signed __int32 a2)
{
  signed __int32 v2; // eax
  signed __int32 v3; // et0
  unsigned int result; // eax

  v3 = _InterlockedExchange(&dword_80581B4, 134561944);
  v2 = _InterlockedExchange(&dword_80581B4, a2);
  _InterlockedExchange(&dword_80581B4, v3);
  result = v2 - 134561940;
  _CF = result < 6;
  _OF = __OFSUB__(result, 6);
  _ZF = result == 6;
  _SF = (signed int)(result - 6) < 0;
  if ( result > 6 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 804A54E: could not find valid save-restore pair for ebp
// 80581B4: using guessed type int dword_80581B4;

//----- (0804A6B2) --------------------------------------------------------
void sub_804A6B2()
{
  ;
}

//----- (0804A6DD) --------------------------------------------------------
void sub_804A6DD()
{
  ;
}

//----- (0804A6E1) --------------------------------------------------------
signed int sub_804A6E1()
{
  return -88;
}

//----- (0804A6EB) --------------------------------------------------------
void __usercall __noreturn sub_804A6EB(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>)
{
  char v6; // al
  signed __int32 v7; // et0

  __asm { pushfw }
  if ( a6 >= 10 )
  {
    v7 = _InterlockedExchange(&dword_8058164, a6);
    v6 = _InterlockedExchange(&dword_8058164, a5);
    _InterlockedExchange(&dword_8058164, v7);
    if ( ((_BYTE)a6 - 1) * v6 & 1 )
      abort();
  }
  __asm { popfw }
  __halt();
  JUMPOUT(*(_DWORD *)byte_804A720);
}
// 8058164: using guessed type int dword_8058164;

//----- (0804A73F) --------------------------------------------------------
signed int __usercall sub_804A73F@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>)
{
  signed __int32 v6; // ebx

  __asm { pushfw }
  v6 = _InterlockedExchange(&dword_8058164, a6);
  _InterlockedExchange(&dword_8058164, a5);
  _InterlockedExchange(&dword_8058164, v6);
  return 85;
}
// 8058164: using guessed type int dword_8058164;

//----- (0804A769) --------------------------------------------------------
#error "804A788: positive sp value has been found (funcsize=8)"

//----- (0804A89A) --------------------------------------------------------
int sub_804A89A()
{
  FILE *v0; // ebx
  signed __int32 v1; // ebx
  signed __int32 v2; // ecx
  signed __int32 v3; // ecx
  signed __int32 v4; // ebx
  signed __int32 v5; // et0
  signed __int32 v10; // ecx
  char v11; // al
  signed __int32 v12; // et1
  int v14; // [esp-4h] [ebp-1Ch]

  v0 = stdout;
  gettext("\nWith no FILE, or when FILE is -, read standard input.\n");
  v1 = _InterlockedExchange(&dword_80581B4, (signed __int32)v0);
  v5 = _InterlockedExchange(&dword_80581B4, v2);
  v3 = v1;
  v4 = v5;
  v14 = fputs_unlocked(_InterlockedExchange(&dword_80581B4, v3));
  __asm { pushfw }
  if ( v5 >= 10 )
  {
    v12 = _InterlockedExchange(&dword_8058164, v4);
    v11 = _InterlockedExchange(&dword_8058164, v10);
    _InterlockedExchange(&dword_8058164, v12);
    if ( ((_BYTE)v4 - 1) * v11 & 1 )
      abort();
  }
  __asm { popfw }
  return v14;
}
// 8048F50: using guessed type int __fastcall fputs_unlocked(_DWORD);
// 8058164: using guessed type int dword_8058164;
// 80581B4: using guessed type int dword_80581B4;

//----- (0804A90D) --------------------------------------------------------
int __usercall sub_804A90D@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>)
{
  char v6; // al
  signed __int32 v7; // ebx
  char v8; // t0
  FILE *v9; // ebx
  int v10; // ecx
  signed __int32 v11; // edx
  signed __int32 v12; // ecx
  char v13; // al
  signed __int32 v14; // et1
  int result; // eax
  signed __int32 v16; // ebx
  int v17; // [esp-4h] [ebp-20h]
  FILE *v18; // [esp+4h] [ebp-18h]

  __asm { pushfw }
  if ( a6 >= 10 )
  {
    v6 = a6;
    v7 = _InterlockedExchange(&dword_8058158, a6);
    v8 = _InterlockedExchange(&dword_8058158, a5);
    _InterlockedExchange(&dword_8058158, v7);
    if ( (v8 - 1) * v6 & 1 )
      abort();
  }
  __asm { popfw }
  v9 = stdout;
  v18 = stdout;
  gettext("\nMandatory arguments to long options are mandatory for short options too.\n");
  v17 = fputs_unlocked(v10);
  __asm { pushfw }
  if ( (signed int)v18 >= 10 )
  {
    v14 = _InterlockedExchange(&dword_8058164, (signed __int32)v9);
    v13 = _InterlockedExchange(&dword_8058164, v12);
    _InterlockedExchange(&dword_8058164, v14);
    if ( ((_BYTE)v9 - 1) * v13 & 1 )
      abort();
  }
  __asm { popfw }
  result = v17;
  v16 = _InterlockedExchange(&dword_80581B4, (signed __int32)v18);
  _InterlockedExchange(&dword_80581B4, v11);
  _InterlockedExchange(&dword_80581B4, v16);
  return result;
}
// 804A90D: could not find valid save-restore pair for ebx
// 8048F50: using guessed type int __fastcall fputs_unlocked(_DWORD);
// 8058158: using guessed type int dword_8058158;
// 8058164: using guessed type int dword_8058164;
// 80581B4: using guessed type int dword_80581B4;

//----- (0804A9B5) --------------------------------------------------------
int __usercall sub_804A9B5@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, char *s1)
{
  signed __int32 v4; // ebx
  signed __int32 v5; // edx
  signed __int32 v6; // ebx
  signed __int32 v7; // et0
  char v12; // al
  signed __int32 v13; // ebx
  char v14; // t1
  char *v15; // eax
  char *v16; // eax
  char *v17; // eax
  char *v18; // eax
  signed __int32 v19; // edx
  int v20; // ecx
  signed __int32 v21; // eax
  signed __int32 v22; // ebx
  signed __int32 v23; // ecx
  signed __int32 v25; // [esp-Ah] [ebp-72h]
  char *v26; // [esp+1Ch] [ebp-4Ch]
  const char **i; // [esp+20h] [ebp-48h]
  const char *v28; // [esp+24h] [ebp-44h]
  const char *v29; // [esp+28h] [ebp-40h]
  const char *v30; // [esp+2Ch] [ebp-3Ch]
  const char *v31; // [esp+30h] [ebp-38h]
  const char *v32; // [esp+34h] [ebp-34h]
  const char *v33; // [esp+38h] [ebp-30h]
  const char *v34; // [esp+3Ch] [ebp-2Ch]
  const char *v35; // [esp+40h] [ebp-28h]
  const char *v36; // [esp+44h] [ebp-24h]
  const char *v37; // [esp+48h] [ebp-20h]
  const char *v38; // [esp+4Ch] [ebp-1Ch]
  void *v39; // [esp+50h] [ebp-18h]
  const char *v40; // [esp+54h] [ebp-14h]
  int v41; // [esp+58h] [ebp-10h]
  int v42; // [esp+5Ch] [ebp-Ch]

  v29 = "[";
  v30 = "test invocation";
  v31 = "coreutils";
  v32 = "Multi-call invocation";
  v33 = "sha224sum";
  v34 = "sha2 utilities";
  v35 = "sha256sum";
  v36 = "sha2 utilities";
  v37 = "sha384sum";
  v38 = "sha2 utilities";
  v39 = &unk_80530EA;
  v40 = "sha2 utilities";
  v41 = 0;
  v42 = 0;
  v26 = s1;
  for ( i = &v29; ; i += 2 )
  {
    v4 = _InterlockedExchange(&dword_80581B4, a3);
    v7 = _InterlockedExchange(&dword_80581B4, a1);
    v5 = v4;
    v6 = v7;
    _InterlockedExchange(&dword_80581B4, v5);
    _CF = 0;
    _OF = 0;
    _ZF = *i == 0;
    _SF = (signed int)*i < 0;
    if ( !*i )
      break;
    __asm { pushfw }
    v25 = v6;
    if ( v6 >= 10 )
    {
      v12 = v6;
      v13 = _InterlockedExchange(&dword_8058164, v6);
      v14 = _InterlockedExchange(&dword_8058164, a2);
      _InterlockedExchange(&dword_8058164, v13);
      if ( (v14 - 1) * v12 & 1 )
        abort();
    }
    a3 = v25;
    __asm { popfw }
    if ( !strcmp(s1, *i) )
      break;
  }
  if ( i[1] )
    v26 = (char *)i[1];
  v15 = gettext("\n%s online help: <%s>\n");
  printf(v15, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  v28 = setlocale(5, 0);
  if ( v28 && strncmp(v28, "en_", 3u) )
  {
    v16 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
    printf(v16, s1);
  }
  v18 = gettext("Full documentation at: <%s%s>\n");
  printf(v18, "http://www.gnu.org/software/coreutils/", s1);
  if ( v26 == s1 )
  {
    dword_8058130 = (int)&loc_804AB1E;
    v21 = _InterlockedExchange(&dword_8058134, (signed __int32)v26);
    _InterlockedExchange(&dword_8058134, v19);
    sub_8052D8F(v20, _InterlockedExchange(&dword_8058134, v21));
    v22 = _InterlockedExchange(&dword_8058134, (signed __int32)" invocation");
    _InterlockedExchange(&dword_8058134, v23);
    _InterlockedExchange(&dword_8058134, v22);
  }
  v17 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  return printf(v17, v26, &s);
}
// 8052D8F: using guessed type int __fastcall sub_8052D8F(_DWORD, _DWORD);
// 8058130: using guessed type int dword_8058130;
// 8058134: using guessed type int dword_8058134;
// 8058164: using guessed type int dword_8058164;
// 80581B4: using guessed type int dword_80581B4;

//----- (0804ABF3) --------------------------------------------------------
#error "804AC1D: call analysis failed (funcsize=48)"

//----- (0804AD4C) --------------------------------------------------------
size_t __cdecl sub_804AD4C(void *ptr, size_t n, int a3, int a4, int a5, FILE *stream)
{
  size_t result; // eax
  char *v7; // ebx
  int *v8; // eax
  __int64 v9; // rcx
  size_t v10; // eax
  signed __int32 v11; // edx
  int v12; // ecx
  char *v13; // ebx
  int v14; // eax
  int v15; // ST08_4
  signed __int32 v16; // eax
  signed __int32 v17; // edx
  signed __int32 v18; // eax
  signed __int32 v19; // edx
  signed __int32 v20; // et2
  char *v21; // ebx
  int *v22; // eax
  size_t i; // [esp+20h] [ebp-18h]
  size_t v24; // [esp+24h] [ebp-14h]

  if ( !__PAIR__(a4, a3) )
  {
    result = fwrite_unlocked(ptr, 1u, n, stdout);
    if ( result >= n )
      return result;
    v7 = gettext("write error");
    v8 = __errno_location();
    error(1, *v8, v7);
  }
  for ( i = 0; ; i += v24 )
  {
    result = i;
    if ( i >= n )
      break;
    v9 = *(unsigned int *)a5;
    v10 = a3 - v9;
    if ( (__PAIR__((unsigned int)a4, a3) - v9) >> 32 )
      v10 = -1;
    if ( n - i <= v10 )
      v10 = n - i;
    v24 = v10;
    if ( !v10 )
    {
      if ( fputc_unlocked(10, stream) == -1 )
      {
        v13 = gettext("write error");
        v14 = *__errno_location();
        v15 = v14;
        v16 = _InterlockedExchange(&dword_80581B4, v14);
        _InterlockedExchange(&dword_80581B4, v17);
        _InterlockedExchange(&dword_80581B4, v16);
        error(1, v15, v13);
      }
      *(_DWORD *)a5 = 0;
      dword_8058194 = (int)&loc_804AF1C;
      v18 = _InterlockedExchange(&dword_8058198, a5);
      _InterlockedExchange(&dword_8058198, v11);
      v20 = _InterlockedExchange(&dword_8058198, sub_8052A2B(v12, _InterlockedExchange(&dword_8058198, v18)));
      _InterlockedExchange(&dword_8058198, v19);
      _InterlockedExchange(&dword_8058198, v20);
    }
    if ( fwrite_unlocked((char *)ptr + i, 1u, v24, stdout) < v24 )
    {
      v21 = gettext("write error");
      v22 = __errno_location();
      error(1, *v22, v21);
    }
    *(_DWORD *)a5 += v24;
  }
  return result;
}
// 8052A2B: using guessed type int __fastcall sub_8052A2B(_DWORD, _DWORD);
// 8058194: using guessed type int dword_8058194;
// 8058198: using guessed type int dword_8058198;
// 80581B4: using guessed type int dword_80581B4;

//----- (0804AF2E) --------------------------------------------------------
signed __int32 __cdecl sub_804AF2E(FILE *a1, FILE *a2, __int64 a3)
{
  char *v3; // ebx
  int *v4; // eax
  signed __int32 v5; // ecx
  char *v6; // ebx
  int *v7; // eax
  signed __int32 result; // eax
  signed __int32 v9; // et0
  int v10; // [esp+30h] [ebp-11818h]
  unsigned int v11; // [esp+34h] [ebp-11814h]
  size_t v12; // [esp+38h] [ebp-11810h]
  char v13[30720]; // [esp+3Ch] [ebp-1180Ch]
  char ptr; // [esp+783Ch] [ebp-A00Ch]
  unsigned int v15; // [esp+1183Ch] [ebp-Ch]

  v15 = __readgsdword(0x14u);
  v10 = 0;
  do
  {
    v11 = 0;
    do
    {
      v12 = fread_unlocked(&v13[v11], 1u, 30720 - v11, a1);
      v11 += v12;
    }
    while ( !feof_unlocked(a1) && !ferror_unlocked(a1) && v11 <= 0x77FF );
    if ( v11 )
    {
      sub_804BD84(v13, v11, &ptr, 4 * ((v11 + 2) / 3));
      sub_804AD4C(&ptr, 4 * ((v11 + 2) / 3), a3, SHIDWORD(a3), (int)&v10, a2);
    }
  }
  while ( !feof_unlocked(a1) && !ferror_unlocked(a1) && v11 == 30720 );
  if ( a3 && v10 && fputc_unlocked(10, a2) == -1 )
  {
    v3 = gettext("write error");
    v4 = __errno_location();
    error(1, *v4, v3);
  }
  if ( ferror_unlocked(a1) )
  {
    v6 = gettext("read error");
    v7 = __errno_location();
    error(1, *v7, v6);
  }
  v9 = _InterlockedExchange(&dword_80581B4, __readgsdword(0x14u) ^ v15);
  result = _InterlockedExchange(&dword_80581B4, v5);
  _InterlockedExchange(&dword_80581B4, v9);
  return result;
}
// 80581B4: using guessed type int dword_80581B4;
// 804AF2E: using guessed type char var_1180C[30720];

//----- (0804B18F) --------------------------------------------------------
unsigned int __usercall sub_804B18F@<eax>(signed __int32 a1@<ecx>, char *a2@<ebx>, FILE *a3, FILE *a4, char a5)
{
  int *v5; // eax
  unsigned int v10; // eax
  size_t v11; // eax
  signed __int32 v12; // ecx
  int *v13; // eax
  signed __int32 v14; // et0
  char *v15; // eax
  signed __int32 v16; // edx
  signed __int32 v17; // ecx
  signed __int32 v18; // eax
  signed __int32 v19; // edx
  signed __int32 v20; // et2
  char v22; // [esp+23h] [ebp-1C25h]
  size_t n; // [esp+24h] [ebp-1C24h]
  unsigned int v24; // [esp+28h] [ebp-1C20h]
  unsigned int i; // [esp+2Ch] [ebp-1C1Ch]
  size_t v26; // [esp+30h] [ebp-1C18h]
  int v27; // [esp+34h] [ebp-1C14h]
  char ptr; // [esp+3Ch] [ebp-1C0Ch]
  char v29[4096]; // [esp+C3Ch] [ebp-100Ch]
  unsigned int v30; // [esp+1C3Ch] [ebp-Ch]

  v30 = __readgsdword(0x14u);
  sub_804C425(0, 1, 0, 0, (signed __int32)a4, a1, (signed __int32)a2);
  do
  {
    v24 = 0;
    do
    {
      n = fread_unlocked(&v29[v24], 1u, 4096 - v24, a3);
      if ( a5 )
      {
        v26 = 0;
        while ( n && v26 < n )
        {
          if ( (unsigned __int8)sub_804C304(v29[v24 + v26]) || v29[v24 + v26] == 61 )
          {
            ++v26;
          }
          else
          {
            --n;
            a2 = (char *)(v26 + v24);
            memmove(&v29[v26 + v24], &v29[v24 + 1 + v26], n - v26);
          }
        }
      }
      v24 += n;
      if ( ferror_unlocked(a3) )
      {
        a2 = gettext("read error");
        v5 = __errno_location();
        error(1, *v5, a2);
      }
    }
    while ( v24 <= 0xFFF && !feof_unlocked(a3) );
    for ( i = 0; ; ++i )
    {
      if ( feof_unlocked(a3) )
      {
        dword_8058180 = (int)&loc_804B4CF;
        v18 = _InterlockedExchange(&dword_8058184, 2);
        _InterlockedExchange(&dword_8058184, v16);
        v20 = _InterlockedExchange(&dword_8058184, sub_8052AF1(v17, _InterlockedExchange(&dword_8058184, v18)));
        _InterlockedExchange(&dword_8058184, v19);
        _InterlockedExchange(&dword_8058184, v20);
      }
      if ( i >= 1 || i == 1 && !v27 )
        break;
      n = 3072;
      _CF = 0;
      _OF = 0;
      _ZF = i == 0;
      _SF = (i & 0x80000000) != 0;
      if ( i )
      {
        __asm { pushfw }
        v10 = 0;
        __asm { popfw }
      }
      else
      {
        v10 = v24;
      }
      v22 = sub_804CC1F(
              (signed __int32)&ptr,
              v17,
              (signed __int32)a2,
              &v27,
              (unsigned __int8 *)v29,
              v10,
              (unsigned int)&ptr,
              (int *)&n);
      v11 = fwrite_unlocked(&ptr, 1u, n, a4);
      if ( v11 < n )
      {
        a2 = gettext("write error");
        v14 = _InterlockedExchange(&dword_80581B4, (signed __int32)__errno_location());
        v13 = (int *)_InterlockedExchange(&dword_80581B4, v12);
        _InterlockedExchange(&dword_80581B4, v14);
        error(1, *v13, a2);
      }
      if ( v22 != 1 )
      {
        v15 = gettext("invalid input");
        error(1, 0, v15);
      }
    }
  }
  while ( !feof_unlocked(a3) );
  return __readgsdword(0x14u) ^ v30;
}
// 8052AF1: using guessed type int __fastcall sub_8052AF1(_DWORD, _DWORD);
// 8058180: using guessed type int dword_8058180;
// 8058184: using guessed type int dword_8058184;
// 80581B4: using guessed type int dword_80581B4;
// 804B18F: using guessed type char var_100C[4096];

//----- (0804B50B) --------------------------------------------------------
int __usercall main@<eax>(char *a1@<ebx>, int argc, char **argv)
{
  char *v3; // eax
  int v4; // ecx
  char *v5; // eax
  int v6; // eax
  signed __int32 v7; // ecx
  signed __int32 v8; // ecx
  signed __int32 v9; // ecx
  int *v10; // eax
  signed __int32 v11; // ecx
  signed __int32 v12; // ebx
  signed __int32 v13; // edx
  signed __int32 v14; // edx
  signed __int32 v15; // et0
  int v16; // ecx
  signed __int32 v17; // edx
  signed __int32 v18; // et1
  unsigned int v19; // eax
  int v24; // edx
  int v25; // ecx
  void *v26; // eax
  char *v27; // ebx
  int *v28; // eax
  signed int v29; // ebx
  int *v30; // eax
  int result; // eax
  char v32; // [esp+2Ah] [ebp-1Ah]
  char v33; // [esp+2Bh] [ebp-19h]
  FILE *v34; // [esp+2Ch] [ebp-18h]
  const char *v35; // [esp+30h] [ebp-14h]
  int v36; // [esp+34h] [ebp-10h]
  __int64 v37; // [esp+38h] [ebp-Ch]

  v32 = 0;
  v33 = 0;
  v37 = 76LL;
  sub_804D56B(*argv);
  setlocale(6, &s);
  bindtextdomain("coreutils", "/home/hwangdz/coreutils/coreutils-8.28/install_m32/share/locale");
  textdomain("coreutils");
  sub_805282E((int)sub_804D265);
  while ( 1 )
  {
    v36 = getopt_long(argc, argv, "diw:", &longopts, 0);
    if ( v36 == -1 )
      break;
    if ( v36 == 100 )
    {
      v32 = 1;
    }
    else if ( v36 > 100 )
    {
      if ( v36 == 105 )
      {
        v33 = 1;
      }
      else
      {
        if ( v36 != 119 )
          goto LABEL_16;
        v3 = gettext("invalid wrap size");
        v37 = sub_8050C48((signed __int32)a1, optarg, 0, 0, -1, -1, &s, (int)v3, 0);
      }
    }
    else
    {
      if ( v36 == -131 )
        goto LABEL_14;
      if ( v36 == -130 )
      {
        sub_804ABF3(0);
LABEL_14:
        sub_80502F9(
          off_80581CC,
          v4,
          (signed __int32)a1,
          stdout,
          (int)"base64",
          (int)"GNU coreutils",
          off_80581CC,
          "Simon Josefsson",
          0);
        exit(0);
      }
LABEL_16:
      sub_804ABF3(1);
    }
  }
  if ( argc - optind > 1 )
  {
    a1 = (char *)sub_804F81B(
                   __CFADD__(4 * optind, argv),
                   &argv[optind] == 0,
                   (signed int)&argv[optind] < 0,
                   __OFADD__(4 * optind, argv),
                   (signed __int32)argv[optind],
                   v4,
                   (signed __int32)a1,
                   (int)argv[optind]);
    v5 = gettext("extra operand %s");
    error(0, 0, v5, a1);
    sub_804ABF3(1);
  }
  if ( optind >= argc )
  {
    v35 = "-";
    v6 = strcmp("-", "-");
  }
  else
  {
    v35 = argv[optind];
    v6 = strcmp(v35, "-");
  }
  if ( v6 )
  {
    v34 = (FILE *)fopen64(v35, "rb");
    if ( !v34 )
    {
      a1 = (char *)sub_804F35A((signed __int32)v35, v9, (signed __int32)a1, 0, 3, (int)v35);
      v10 = __errno_location();
      error(1, *v10, "%s", a1);
    }
  }
  else
  {
    sub_805095A(v7, (signed __int32)a1, 0, 0);
    v34 = (FILE *)stdin;
  }
  sub_804D510((signed __int32)a1, v34);
  if ( v32 )
  {
    sub_804B18F(v11, a1, v34, stdout, v33);
    dword_8058194 = (int)&loc_804B880;
    v12 = _InterlockedExchange(&dword_8058198, (signed __int32)a1);
    v15 = _InterlockedExchange(&dword_8058198, v13);
    v14 = v12;
    a1 = (char *)v15;
    v18 = _InterlockedExchange(&dword_8058198, sub_8052A2B(v16, _InterlockedExchange(&dword_8058198, v14)));
    _InterlockedExchange(&dword_8058198, v17);
    _InterlockedExchange(&dword_8058198, v18);
  }
  sub_804AF2E(v34, stdout, v37);
  v19 = sub_8051328((signed __int32)a1, v34);
  _CF = v19 < 0xFFFFFFFF;
  _OF = __OFSUB__(v19, -1);
  _ZF = v19 == -1;
  _SF = (signed int)(v19 + 1) < 0;
  if ( v19 == -1 )
  {
    _ZF = strcmp(v35, "-") == 0;
    v26 = &loc_804B8C6;
    if ( !_ZF )
      v26 = &loc_804B747;
    dword_8058180 = (int)v26;
    sub_8052AF1(v25, v24);
    v27 = gettext("closing standard input");
    v28 = __errno_location();
    error(1, *v28, v27);
    v29 = sub_804F35A((signed __int32)v35, v8, (signed __int32)v27, 0, 3, (int)v35);
    v30 = __errno_location();
    error(1, *v30, "%s", v29);
  }
  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}
// 8048E40: using guessed type int __cdecl fopen64(_DWORD, _DWORD);
// 8052A2B: using guessed type int __fastcall sub_8052A2B(_DWORD, _DWORD);
// 8052AF1: using guessed type int __fastcall sub_8052AF1(_DWORD, _DWORD);
// 8058180: using guessed type int dword_8058180;
// 8058194: using guessed type int dword_8058194;
// 8058198: using guessed type int dword_8058198;
// 8058260: using guessed type int optind;
// 8058280: using guessed type int stdin;

//----- (0804B9BD) --------------------------------------------------------
int __cdecl sub_804B9BD(char *a1, int a2)
{
  int v2; // ST0C_4
  int result; // eax

  if ( a2 )
  {
    v2 = *a1;
    result = (unsigned __int8)a1;
  }
  return result;
}

//----- (0804BD84) --------------------------------------------------------
int __cdecl sub_804BD84(char *a1, int a2, _BYTE *a3, unsigned int a4)
{
  int result; // eax
  int v5; // ST0C_4

  result = a4 & 3;
  if ( !(a4 & 3) )
  {
    result = 3 * (a4 >> 2);
    if ( result == a2 )
      return sub_804B9BD(a1, a2);
  }
  if ( a2 && a4 )
  {
    v5 = *a1;
    result = (unsigned __int8)a1;
  }
  else if ( a4 )
  {
    result = (int)a3;
    *a3 = 0;
  }
  return result;
}

//----- (0804C304) --------------------------------------------------------
int __cdecl sub_804C304(unsigned __int8 a1)
{
  return a1;
}

//----- (0804C425) --------------------------------------------------------
signed int __usercall sub_804C425@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>)
{
  char v11; // al
  signed __int32 v12; // ebx
  signed __int32 v13; // et0
  int v14; // eax
  signed __int32 v15; // ebx

  __asm { pushfw }
  _CF = (unsigned int)a7 < 0xA;
  _OF = __OFSUB__(a7, 10);
  _ZF = a7 == 10;
  _SF = a7 - 10 < 0;
  if ( a7 >= 10 )
  {
    v11 = a7;
    v12 = _InterlockedExchange(&dword_8058170, a7);
    v13 = _InterlockedExchange(&dword_8058170, a6);
    _InterlockedExchange(&dword_8058170, v12);
    a7 = v13 - 1;
    v14 = ((_BYTE)v13 - 1) * v11 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = v14 == 0;
    _SF = v14 < 0;
    if ( v14 )
      abort();
  }
  __asm { pushfw }
  v15 = _InterlockedExchange(&dword_8058164, a7);
  _InterlockedExchange(&dword_8058164, a5);
  _InterlockedExchange(&dword_8058164, v15);
  return 85;
}
// 8058164: using guessed type int dword_8058164;
// 8058170: using guessed type int dword_8058170;

//----- (0804C581) --------------------------------------------------------
int __usercall sub_804C581@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, _DWORD *a4, char **a5, unsigned int a6, _DWORD *a7)
{
  unsigned int *v7; // eax
  signed __int32 v8; // et0
  signed __int32 v9; // ecx
  unsigned int v10; // eax
  char v15; // al
  signed __int32 v16; // ebx
  char v17; // t1
  signed __int32 v18; // et2
  int result; // eax
  char *v20; // eax
  int v21; // eax
  char v22; // [esp+17h] [ebp-11h]
  char *v23; // [esp+18h] [ebp-10h]
  char *s; // [esp+1Ch] [ebp-Ch]

  v8 = _InterlockedExchange(&dword_80581B4, (signed __int32)a4);
  v7 = (unsigned int *)_InterlockedExchange(&dword_80581B4, a2);
  v9 = _InterlockedExchange(&dword_80581B4, v8);
  v10 = *v7;
  _CF = v10 < 4;
  _OF = __OFSUB__(v10, 4);
  _ZF = v10 == 4;
  _SF = (signed int)(v10 - 4) < 0;
  if ( v10 == 4 )
  {
    __asm { pushfw }
    if ( a3 >= 10 )
    {
      v15 = a3;
      v16 = _InterlockedExchange(&dword_8058170, a3);
      v17 = _InterlockedExchange(&dword_8058170, v9);
      _InterlockedExchange(&dword_8058170, v16);
      if ( (v17 - 1) * v15 & 1 )
        abort();
    }
    __asm { popfw }
    *a4 = 0;
    v18 = _InterlockedExchange(&dword_80581B4, (signed __int32)a4);
    _InterlockedExchange(&dword_80581B4, a1);
    _InterlockedExchange(&dword_80581B4, v18);
  }
  if ( *a4 || (s = *a5, (signed int)(a6 - (_DWORD)*a5) <= 3) || memchr(s, 10, 4u) )
  {
    v23 = *a5;
    while ( (unsigned int)v23 < a6 )
    {
      v20 = v23++;
      v22 = *v20;
      if ( *v20 != 10 )
      {
        v21 = (*a4)++;
        *((_BYTE *)a4 + v21 + 4) = v22;
        if ( *a4 == 4 )
          break;
      }
    }
    *a5 = v23;
    *a7 = *a4;
    result = (int)(a4 + 1);
  }
  else
  {
    *a5 += 4;
    *a7 = 4;
    result = (int)s;
  }
  return result;
}
// 8058170: using guessed type int dword_8058170;
// 80581B4: using guessed type int dword_80581B4;

//----- (0804C6B6) --------------------------------------------------------
signed int __cdecl sub_804C6B6(unsigned __int8 *a1, unsigned int a2, int *a3, _DWORD *a4)
{
  signed int result; // eax
  char v9; // al
  char v12; // al
  int v13; // ST0C_4
  unsigned __int8 v22; // al
  char v27; // al
  int v32; // ST0C_4
  char v41; // al
  int v46; // ST0C_4
  int v47; // [esp+10h] [ebp-Ch]

  v47 = *a3;
  _CF = a2 < 1;
  _OF = __OFSUB__(a2, 1);
  _ZF = a2 == 1;
  _SF = (signed int)(a2 - 1) < 0;
  if ( a2 <= 1 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
    return result;
  }
  v9 = sub_804C304(*a1) ^ 1;
  _ZF = v9 == 0;
  _SF = v9 < 0;
  if ( v9 || (v12 = sub_804C304(a1[1]) ^ 1, _ZF = v12 == 0, _SF = v12 < 0, v12) )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
    return result;
  }
  if ( *a4 )
  {
    v13 = (char)*a1;
    return (unsigned __int8)a1;
  }
  _CF = a2 < 2;
  _OF = __OFSUB__(a2, 2);
  _ZF = a2 == 2;
  _SF = (signed int)(a2 - 2) < 0;
  if ( a2 == 2 )
  {
    *a3 = v47;
    __asm { pushfw }
    result = 0;
    __asm { popfw }
    return result;
  }
  if ( a1[2] == 61 )
  {
    _CF = a2 < 4;
    _OF = __OFSUB__(a2, 4);
    _ZF = a2 == 4;
    _SF = (signed int)(a2 - 4) < 0;
    if ( a2 != 4 )
    {
      *a3 = v47;
      __asm { pushfw }
      result = 0;
      __asm { popfw }
      return result;
    }
    v22 = a1[3];
    _CF = v22 < 0x3Du;
    _OF = __OFSUB__(v22, 61);
    _ZF = v22 == 61;
    _SF = (char)(v22 - 61) < 0;
    if ( v22 != 61 )
    {
      *a3 = v47;
      __asm { pushfw }
      result = 0;
      __asm { popfw }
      return result;
    }
  }
  else
  {
    v27 = sub_804C304(a1[2]) ^ 1;
    _CF = 0;
    _OF = 0;
    _ZF = v27 == 0;
    _SF = v27 < 0;
    if ( v27 )
    {
      *a3 = v47;
      __asm { pushfw }
      result = 0;
      __asm { popfw }
      return result;
    }
    if ( *a4 )
    {
      v32 = (char)a1[1];
      return (unsigned __int8)a1;
    }
    _CF = a2 < 3;
    _OF = __OFSUB__(a2, 3);
    _ZF = a2 == 3;
    _SF = (signed int)(a2 - 3) < 0;
    if ( a2 == 3 )
    {
      *a3 = v47;
      __asm { pushfw }
      result = 0;
      __asm { popfw }
      return result;
    }
    if ( a1[3] == 61 )
    {
      _CF = a2 < 4;
      _OF = __OFSUB__(a2, 4);
      _ZF = a2 == 4;
      _SF = (signed int)(a2 - 4) < 0;
      if ( a2 != 4 )
      {
        *a3 = v47;
        __asm { pushfw }
        result = 0;
        __asm { popfw }
        return result;
      }
    }
    else
    {
      v41 = sub_804C304(a1[3]) ^ 1;
      _CF = 0;
      _OF = 0;
      _ZF = v41 == 0;
      _SF = v41 < 0;
      if ( v41 )
      {
        *a3 = v47;
        __asm { pushfw }
        result = 0;
        __asm { popfw }
        return result;
      }
      if ( *a4 )
      {
        v46 = (char)a1[2];
        return (unsigned __int8)a1;
      }
    }
  }
  *a3 = v47;
  return 1;
}

//----- (0804CC1F) --------------------------------------------------------
int __usercall sub_804CC1F@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, int *a4, unsigned __int8 *a5, unsigned int a6, char a7, int *a8)
{
  int v8; // eax
  signed __int32 v13; // ebx
  signed __int32 v14; // edx
  signed __int32 v15; // ebx
  signed __int32 v16; // et0
  signed __int32 v17; // edx
  signed __int32 v18; // ebx
  signed __int32 v19; // edx
  signed __int32 v20; // et1
  signed __int32 v21; // ebx
  signed __int32 v22; // ecx
  signed __int32 v23; // et2
  int v24; // eax
  signed __int32 v25; // ecx
  signed __int32 v26; // ett
  signed __int32 v27; // ebx
  signed __int32 v28; // edx
  signed __int32 v29; // et0
  char v30; // al
  signed __int32 v31; // ebx
  char v32; // t1
  signed __int32 v33; // eax
  signed __int32 v35; // [esp-4h] [ebp-3Ch]
  bool v36; // [esp+1Ah] [ebp-1Eh]
  int v37; // [esp+1Ch] [ebp-1Ch]
  int v38; // [esp+20h] [ebp-18h]
  int v39; // [esp+24h] [ebp-14h]

  v8 = *a8;
  v37 = *a8;
  LOBYTE(v8) = a4 != 0;
  v38 = 0;
  _CF = 0;
  _OF = 0;
  _ZF = a4 == 0;
  _SF = (a4 != 0) < 0;
  dword_80581A4 = (int (__fastcall *)(_DWORD, _DWORD))&loc_804CC7D;
  v13 = _InterlockedExchange(&dword_80581A8, a3);
  v16 = _InterlockedExchange(&dword_80581A8, a1);
  v14 = v13;
  v15 = v16;
  v17 = _InterlockedExchange(&dword_80581A8, v14);
  if ( a4 )
  {
    v38 = *a4;
    v36 = a6 == 0;
    v8 = v37;
    v39 = v37;
    _CF = 0;
    _OF = 0;
    _ZF = v38 == 0;
    _SF = v38 < 0;
    dword_80581A4 = (int (__fastcall *)(_DWORD, _DWORD))sub_804CD7E;
    v18 = _InterlockedExchange(&dword_80581A8, v15);
    v20 = _InterlockedExchange(&dword_80581A8, v17);
    v19 = v18;
    v15 = v20;
    v17 = _InterlockedExchange(&dword_80581A8, v19);
    if ( !v38 )
    {
      v8 = !v36;
      _CF = 0;
      _OF = 0;
      _ZF = v36 == 1;
      _SF = (v8 & 0x80u) != 0;
      dword_80581A4 = (int (__fastcall *)(_DWORD, _DWORD))sub_804CD7E;
      v21 = _InterlockedExchange(&dword_80581A8, v15);
      v23 = _InterlockedExchange(&dword_80581A8, a2);
      v22 = v21;
      v15 = v23;
      a2 = _InterlockedExchange(&dword_80581A8, v22);
      if ( v36 != 1 )
      {
        v39 = v37;
        v24 = sub_804C6B6(a5, a6, (int *)&a7, &v37) ^ 1;
        _CF = 0;
        _OF = 0;
        _ZF = (_BYTE)v24 == 0;
        _SF = (v24 & 0x80u) != 0;
        dword_80581A4 = (int (__fastcall *)(_DWORD, _DWORD))sub_804CD49;
        v26 = _InterlockedExchange(&dword_80581A8, v24);
        v8 = _InterlockedExchange(&dword_80581A8, v25);
        a2 = _InterlockedExchange(&dword_80581A8, v26);
        if ( !_ZF )
        {
          dword_80581A4 = (int (__fastcall *)(_DWORD, _DWORD))sub_804CD7E;
          v27 = _InterlockedExchange(&dword_80581A8, v15);
          v29 = _InterlockedExchange(&dword_80581A8, v17);
          v28 = v27;
          v15 = v29;
          v17 = _InterlockedExchange(&dword_80581A8, v28);
        }
      }
    }
  }
  v35 = v8;
  __asm { pushfw }
  if ( v15 >= 10 )
  {
    v30 = v15;
    v31 = _InterlockedExchange(&dword_8058164, v15);
    v32 = _InterlockedExchange(&dword_8058164, v17);
    v17 = _InterlockedExchange(&dword_8058164, v31);
    if ( (v32 - 1) * v30 & 1 )
      abort();
  }
  __asm { popfw }
  v33 = _InterlockedExchange(&dword_80581A8, v35);
  _InterlockedExchange(&dword_80581A8, a2);
  return dword_80581A4(_InterlockedExchange(&dword_80581A8, v33), v17);
}
// 80581A4: invalid function type has been ignored
// 8058164: using guessed type int dword_8058164;
// 80581A4: using guessed type int (__fastcall *dword_80581A4)(_DWORD, _DWORD);
// 80581A8: using guessed type int dword_80581A8;

//----- (0804CD49) --------------------------------------------------------
void __usercall sub_804CD49(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, int a3@<ebp>)
{
  unsigned int v3; // eax
  signed __int32 v8; // ebx
  signed __int32 v9; // et0

  *(_DWORD *)(a3 + 12) += 4;
  v3 = *(_DWORD *)(a3 + 16);
  _CF = v3 < 4;
  _OF = __OFSUB__(v3, 4);
  v3 -= 4;
  _ZF = v3 == 0;
  _SF = (v3 & 0x80000000) != 0;
  *(_DWORD *)(a3 + 16) = v3;
  dword_80581A4 = (int (__fastcall *)(_DWORD, _DWORD))&loc_804CCD8;
  v8 = _InterlockedExchange(&dword_80581A8, a2);
  v9 = _InterlockedExchange(&dword_80581A8, a1);
  _InterlockedExchange(&dword_80581A8, v8);
  __asm { pushfw }
  JUMPOUT(v9, 10, &loc_804F6A5);
  JUMPOUT(&loc_804F67D);
}
// 80581A4: using guessed type int (__fastcall *dword_80581A4)(_DWORD, _DWORD);
// 80581A8: using guessed type int dword_80581A8;

//----- (0804CD7E) --------------------------------------------------------
void __usercall sub_804CD7E(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, int a3@<ebx>, int a4@<ebp>)
{
  signed __int32 v4; // eax
  signed __int32 v9; // et0
  signed __int32 v10; // edx
  int v11; // eax
  signed __int32 v12; // eax
  signed __int32 v13; // et1
  signed __int32 v14; // et2

  v4 = *(_DWORD *)(a4 + 16);
  _CF = 0;
  _OF = 0;
  _ZF = v4 == 0;
  _SF = v4 < 0;
  dword_80581A4 = (int (__fastcall *)(_DWORD, _DWORD))sub_804CDF4;
  v9 = _InterlockedExchange(&dword_80581A8, v4);
  _InterlockedExchange(&dword_80581A8, a1);
  v10 = _InterlockedExchange(&dword_80581A8, v9);
  if ( !v4 )
  {
    v11 = *(unsigned __int8 *)(a4 - 30) ^ 1;
    _CF = 0;
    _OF = 0;
    _ZF = *(_BYTE *)(a4 - 30) == 1;
    _SF = (v11 & 0x80u) != 0;
    dword_80581A4 = (int (__fastcall *)(_DWORD, _DWORD))sub_804CDF4;
    v13 = _InterlockedExchange(&dword_80581A8, v11);
    v12 = _InterlockedExchange(&dword_80581A8, v10);
    _InterlockedExchange(&dword_80581A8, v13);
    if ( !_ZF )
    {
      dword_80581A4 = (int (__fastcall *)(_DWORD, _DWORD))sub_804D0A2;
      v14 = _InterlockedExchange(&dword_80581A8, v12);
      _InterlockedExchange(&dword_80581A8, a2);
      _InterlockedExchange(&dword_80581A8, v14);
    }
  }
  __asm { pushfw }
  JUMPOUT(a3, 10, &loc_804F6A5);
  JUMPOUT(&loc_804F67D);
}
// 804D0A2: using guessed type int sub_804D0A2();
// 80581A4: using guessed type int (__fastcall *dword_80581A4)(_DWORD, _DWORD);
// 80581A8: using guessed type int dword_80581A8;

//----- (0804CDF4) --------------------------------------------------------
void __usercall sub_804CDF4(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, int a3@<ebp>)
{
  int v3; // eax
  signed __int32 v8; // ebx
  signed __int32 v9; // ecx
  signed __int32 v10; // ebx
  signed __int32 v11; // et0
  signed __int32 v12; // ecx
  signed __int32 v13; // eax
  signed __int32 v14; // eax
  signed __int32 v15; // et1
  signed __int32 v16; // ecx
  signed __int32 v17; // et2
  signed __int32 v18; // ecx
  unsigned int v19; // eax
  signed __int32 v20; // ebx
  signed __int32 v21; // ecx
  signed __int32 v22; // ett

  v3 = *(_DWORD *)(a3 + 16);
  _CF = 0;
  _OF = 0;
  _ZF = v3 == 0;
  _SF = v3 < 0;
  dword_80581A4 = (int (__fastcall *)(_DWORD, _DWORD))sub_804CEA4;
  v8 = _InterlockedExchange(&dword_80581A8, a2);
  v11 = _InterlockedExchange(&dword_80581A8, a1);
  v9 = v8;
  v10 = v11;
  v12 = _InterlockedExchange(&dword_80581A8, v9);
  if ( v3 )
  {
    v13 = **(unsigned __int8 **)(a3 + 12);
    _CF = (unsigned __int8)v13 < 0xAu;
    _OF = __OFSUB__((_BYTE)v13, 10);
    _ZF = (_BYTE)v13 == 10;
    _SF = (char)(v13 - 10) < 0;
    dword_80581A4 = (int (__fastcall *)(_DWORD, _DWORD))sub_804CEA4;
    v15 = _InterlockedExchange(&dword_80581A8, v13);
    v14 = _InterlockedExchange(&dword_80581A8, v12);
    v16 = _InterlockedExchange(&dword_80581A8, v15);
    if ( _ZF )
    {
      _CF = 0;
      _OF = 0;
      _ZF = *(_BYTE *)(a3 - 29) == 0;
      _SF = *(_BYTE *)(a3 - 29) < 0;
      dword_80581A4 = (int (__fastcall *)(_DWORD, _DWORD))sub_804CEA4;
      v17 = _InterlockedExchange(&dword_80581A8, v14);
      _InterlockedExchange(&dword_80581A8, v16);
      v18 = _InterlockedExchange(&dword_80581A8, v17);
      if ( !_ZF )
      {
        ++*(_DWORD *)(a3 + 12);
        v19 = *(_DWORD *)(a3 + 16);
        _CF = v19 < 1;
        _OF = __OFSUB__(v19--, 1);
        _ZF = v19 == 0;
        _SF = (v19 & 0x80000000) != 0;
        *(_DWORD *)(a3 + 16) = v19;
        dword_80581A4 = (int (__fastcall *)(_DWORD, _DWORD))&loc_804CC7D;
        v20 = _InterlockedExchange(&dword_80581A8, v10);
        v22 = _InterlockedExchange(&dword_80581A8, v18);
        v21 = v20;
        v10 = v22;
        _InterlockedExchange(&dword_80581A8, v21);
      }
    }
  }
  __asm { pushfw }
  JUMPOUT(v10, 10, &loc_804F6A5);
  JUMPOUT(&loc_804F67D);
}
// 804CEA4: using guessed type int __cdecl sub_804CEA4(int, int, int);
// 80581A4: using guessed type int (__fastcall *dword_80581A4)(_DWORD, _DWORD);
// 80581A8: using guessed type int dword_80581A8;

//----- (0804CEA4) --------------------------------------------------------
#error "804CF06: call analysis failed (funcsize=40)"

//----- (0804CF31) --------------------------------------------------------
void __usercall sub_804CF31(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, int a3@<ebp>)
{
  int v3; // eax
  signed __int32 v8; // ebx
  signed __int32 v9; // ecx
  signed __int32 v10; // ebx
  signed __int32 v11; // et0
  signed __int32 v12; // ecx
  unsigned __int32 v13; // eax
  signed __int32 v14; // et1
  signed __int32 v15; // ecx
  int v16; // eax
  signed __int32 v17; // ebx
  signed __int32 v18; // ecx
  signed __int32 v19; // et2
  signed __int32 v20; // ecx
  signed __int32 v21; // ebx
  signed __int32 v22; // ecx
  signed __int32 v23; // ett
  signed __int32 v24; // ecx
  signed __int32 v25; // et0

  *(_DWORD *)(a3 - 16) = *(_DWORD *)(a3 + 12);
  v3 = *(_DWORD *)(a3 + 16);
  _CF = 0;
  _OF = 0;
  _ZF = v3 == 0;
  _SF = v3 < 0;
  dword_80581A4 = (int (__fastcall *)(_DWORD, _DWORD))&loc_804CFDE;
  v8 = _InterlockedExchange(&dword_80581A8, a2);
  v11 = _InterlockedExchange(&dword_80581A8, a1);
  v9 = v8;
  v10 = v11;
  v12 = _InterlockedExchange(&dword_80581A8, v9);
  if ( v3 )
  {
    v13 = *(_DWORD *)(a3 + 16);
    _CF = v13 < 3;
    _OF = __OFSUB__(v13, 3);
    _ZF = v13 == 3;
    _SF = (signed int)(v13 - 3) < 0;
    dword_80581A4 = (int (__fastcall *)(_DWORD, _DWORD))sub_804D007;
    v14 = _InterlockedExchange(&dword_80581A8, v13);
    _InterlockedExchange(&dword_80581A8, v12);
    v15 = _InterlockedExchange(&dword_80581A8, v14);
    if ( v13 <= 3 )
    {
      v16 = *(unsigned __int8 *)(a3 - 30) ^ 1;
      _CF = 0;
      _OF = 0;
      _ZF = *(_BYTE *)(a3 - 30) == 1;
      _SF = (v16 & 0x80u) != 0;
      dword_80581A4 = (int (__fastcall *)(_DWORD, _DWORD))sub_804D007;
      v17 = _InterlockedExchange(&dword_80581A8, v10);
      v19 = _InterlockedExchange(&dword_80581A8, v15);
      v18 = v17;
      v10 = v19;
      v20 = _InterlockedExchange(&dword_80581A8, v18);
      if ( !_ZF )
      {
        _CF = 0;
        _OF = 0;
        _ZF = *(_BYTE *)(a3 - 29) == 0;
        _SF = *(_BYTE *)(a3 - 29) < 0;
        dword_80581A4 = (int (__fastcall *)(_DWORD, _DWORD))sub_804D007;
        v21 = _InterlockedExchange(&dword_80581A8, v10);
        v23 = _InterlockedExchange(&dword_80581A8, v20);
        v22 = v21;
        v10 = v23;
        v24 = _InterlockedExchange(&dword_80581A8, v22);
        if ( !_ZF )
        {
          *(_DWORD *)(a3 + 16) = 0;
          dword_80581A4 = (int (__fastcall *)(_DWORD, _DWORD))sub_804D0A2;
          v25 = _InterlockedExchange(&dword_80581A8, v16);
          _InterlockedExchange(&dword_80581A8, v24);
          _InterlockedExchange(&dword_80581A8, v25);
        }
      }
    }
  }
  __asm { pushfw }
  JUMPOUT(v10, 10, &loc_804F6A5);
  JUMPOUT(&loc_804F67D);
}
// 804D007: using guessed type int __cdecl sub_804D007(int, int, int);
// 804D0A2: using guessed type int sub_804D0A2();
// 80581A4: using guessed type int (__fastcall *dword_80581A4)(_DWORD, _DWORD);
// 80581A8: using guessed type int dword_80581A8;

//----- (0804D007) --------------------------------------------------------
#error "804D022: call analysis failed (funcsize=29)"

//----- (0804D072) --------------------------------------------------------
void __usercall sub_804D072(signed __int32 a1@<ebx>, int a2@<ebp>)
{
  unsigned int v2; // edx
  unsigned int v3; // eax
  signed __int32 v8; // edx
  signed __int32 v9; // ebx
  signed __int32 v10; // et0

  v2 = *(_DWORD *)(a2 - 12);
  v3 = *(_DWORD *)(a2 + 12);
  _CF = v2 < v3;
  _OF = __OFSUB__(v2, v3);
  v8 = v2 - v3;
  _ZF = v8 == 0;
  _SF = v8 < 0;
  *(_DWORD *)(a2 + 16) = v8;
  dword_80581A4 = (int (__fastcall *)(_DWORD, _DWORD))&loc_804CC7D;
  v9 = _InterlockedExchange(&dword_80581A8, a1);
  v10 = _InterlockedExchange(&dword_80581A8, v8);
  _InterlockedExchange(&dword_80581A8, v9);
  __asm { pushfw }
  JUMPOUT(v10, 10, &loc_804F6A5);
  JUMPOUT(&loc_804F67D);
}
// 80581A4: using guessed type int (__fastcall *dword_80581A4)(_DWORD, _DWORD);
// 80581A8: using guessed type int dword_80581A8;

//----- (0804D0A2) --------------------------------------------------------
#error "804D0BA: positive sp value has been found (funcsize=0)"

//----- (0804D265) --------------------------------------------------------
void __usercall sub_804D265(signed __int32 a1@<edx>, signed __int32 a2@<ebx>)
{
  int v2; // eax
  signed __int32 v3; // edx
  signed __int32 v8; // ebx
  signed __int32 v9; // ecx
  signed __int32 v10; // ecx
  signed __int32 v11; // ebx
  signed __int32 v12; // et0
  int v13; // eax
  signed __int32 v14; // et1
  unsigned int v15; // eax
  signed __int32 v16; // edx
  signed __int32 v17; // et2
  signed __int32 v18; // ebx
  signed __int32 v19; // edx
  signed __int32 v20; // edx
  signed __int32 v21; // ett
  signed __int32 v22; // edx
  char v23; // al
  signed __int32 v24; // et0
  signed __int32 v25; // ebx
  int *v26; // eax
  signed __int32 v27; // ebx
  signed __int32 v28; // edx
  signed __int32 v29; // edx
  signed __int32 v30; // et1
  char *v31; // [esp+2Ch] [ebp-Ch]

  v2 = sub_8051B5D(a1, a2, stdout);
  _CF = 0;
  _OF = 0;
  _ZF = v2 == 0;
  _SF = v2 < 0;
  dword_80581A4 = (int (__fastcall *)(_DWORD, _DWORD))sub_804D3F8;
  v8 = _InterlockedExchange(&dword_80581A8, a2);
  v12 = _InterlockedExchange(&dword_80581A8, v9);
  v10 = v8;
  v11 = v12;
  _InterlockedExchange(&dword_80581A8, v10);
  if ( v2 )
  {
    v13 = (unsigned __int8)byte_80586CA ^ 1;
    _CF = 0;
    _OF = 0;
    _ZF = byte_80586CA == 1;
    _SF = (v13 & 0x80u) != 0;
    dword_80581A4 = (int (__fastcall *)(_DWORD, _DWORD))&loc_804D2FB;
    v14 = _InterlockedExchange(&dword_80581A8, v13);
    _InterlockedExchange(&dword_80581A8, v3);
    _InterlockedExchange(&dword_80581A8, v14);
    if ( byte_80586CA == 1 )
    {
      v15 = *__errno_location();
      _CF = v15 < 0x20;
      _OF = __OFSUB__(v15, 32);
      _ZF = v15 == 32;
      _SF = (signed int)(v15 - 32) < 0;
      dword_80581A4 = (int (__fastcall *)(_DWORD, _DWORD))sub_804D3F8;
      v17 = _InterlockedExchange(&dword_80581A8, v15);
      _InterlockedExchange(&dword_80581A8, v16);
      _InterlockedExchange(&dword_80581A8, v17);
      if ( v15 != 32 )
      {
        v31 = gettext("write error");
        _CF = 0;
        _OF = 0;
        _ZF = dword_80586C6 == 0;
        _SF = dword_80586C6 < 0;
        dword_80581A4 = (int (__fastcall *)(_DWORD, _DWORD))sub_804D3C5;
        v18 = _InterlockedExchange(&dword_80581A8, v11);
        v21 = _InterlockedExchange(&dword_80581A8, v19);
        v20 = v18;
        v11 = v21;
        v22 = _InterlockedExchange(&dword_80581A8, v20);
        if ( dword_80586C6 )
        {
          __asm { pushfw }
          if ( v11 >= 10 )
          {
            v24 = _InterlockedExchange(&dword_8058158, v11);
            v23 = _InterlockedExchange(&dword_8058158, v22);
            _InterlockedExchange(&dword_8058158, v24);
            if ( ((_BYTE)v11 - 1) * v23 & 1 )
              abort();
          }
          __asm { popfw }
          v25 = sub_804F29A(v11, dword_80586C6);
          v26 = __errno_location();
          error(0, *v26, "%s: %s", v25, v31);
          dword_80581A4 = (int (__fastcall *)(_DWORD, _DWORD))&loc_804D3EB;
          v27 = _InterlockedExchange(&dword_80581A8, v25);
          v30 = _InterlockedExchange(&dword_80581A8, v28);
          v29 = v27;
          v11 = v30;
          _InterlockedExchange(&dword_80581A8, v29);
        }
      }
    }
  }
  __asm { pushfw }
  JUMPOUT(v11, 10, &loc_804F6A5);
  JUMPOUT(&loc_804F67D);
}
// 804D3F8: using guessed type int sub_804D3F8();
// 8058158: using guessed type int dword_8058158;
// 80581A4: using guessed type int (__fastcall *dword_80581A4)(_DWORD, _DWORD);
// 80581A8: using guessed type int dword_80581A8;
// 80586C6: using guessed type int dword_80586C6;
// 80586CA: using guessed type char byte_80586CA;

//----- (0804D3C5) --------------------------------------------------------
#error "804D3E6: call analysis failed (funcsize=11)"

//----- (0804D43E) --------------------------------------------------------
int __usercall sub_804D43E@<eax>(signed __int32 a1@<ebx>, int a2, int a3)
{
  signed __int32 v3; // edx
  signed __int32 v4; // ecx
  char v5; // al
  signed __int32 v6; // et0
  signed __int32 v7; // ebx
  int v8; // eax
  signed __int32 v13; // ebx
  signed __int32 v14; // ecx
  signed __int32 v15; // ebx
  signed __int32 v16; // et1
  int v17; // edx
  signed __int32 v18; // ecx
  signed __int32 v19; // ebx
  int v21; // [esp+6h] [ebp-42h]

  v21 = posix_fadvise64(a2, a3);
  __asm { pushfw }
  if ( a1 >= 10 )
  {
    v6 = _InterlockedExchange(&dword_8058170, a1);
    v5 = _InterlockedExchange(&dword_8058170, v3);
    _InterlockedExchange(&dword_8058170, v6);
    v7 = a1 - 1;
    v8 = (_BYTE)v7 * v5 & 1;
    _CF = 0;
    _OF = 0;
    _ZF = v8 == 0;
    _SF = v8 < 0;
    if ( v8 )
    {
      __asm { pushfw }
      v13 = _InterlockedExchange(&dword_8058158, v7);
      v16 = _InterlockedExchange(&dword_8058158, v4);
      v14 = v13;
      v15 = v16;
      _InterlockedExchange(&dword_8058158, v14);
      if ( sub_8049E04() != 675 )
      {
        v19 = _InterlockedExchange(&dword_8058158, v15);
        _InterlockedExchange(&dword_8058158, v18);
        sub_8049E0E(_InterlockedExchange(&dword_8058158, v19), v17);
      }
      __asm { popfw }
      abort();
    }
  }
  __asm { popfw }
  return v21;
}
// 8049070: using guessed type int __stdcall posix_fadvise64(_DWORD, _DWORD);
// 8049E0E: using guessed type int __fastcall sub_8049E0E(_DWORD, _DWORD);
// 8058158: using guessed type int dword_8058158;
// 8058170: using guessed type int dword_8058170;

//----- (0804D510) --------------------------------------------------------
void __usercall sub_804D510(signed __int32 a1@<ebx>, FILE *stream)
{
  signed __int32 v2; // ecx
  int v3; // eax
  signed __int32 v4; // et0

  if ( stream )
  {
    v4 = _InterlockedExchange(&dword_80581B4, fileno(stream));
    v3 = _InterlockedExchange(&dword_80581B4, v2);
    _InterlockedExchange(&dword_80581B4, v4);
    sub_804D43E(a1, v3, 0);
  }
}
// 80581B4: using guessed type int dword_80581B4;

//----- (0804D56B) --------------------------------------------------------
char *__cdecl sub_804D56B(char *s)
{
  char *v1; // eax
  char *result; // eax
  char *v3; // [esp+18h] [ebp-10h]
  char *s1; // [esp+1Ch] [ebp-Ch]

  if ( !s )
  {
    fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
    abort();
  }
  v3 = strrchr(s, 47);
  if ( v3 )
    v1 = v3 + 1;
  else
    v1 = s;
  s1 = v1;
  if ( v1 - s > 6 && !strncmp(v1 - 7, "/.libs/", 7u) )
  {
    s = s1;
    if ( !strncmp(s1, "lt-", 3u) )
    {
      s = s1 + 3;
      program_invocation_short_name = (int)(s1 + 3);
    }
  }
  dword_80586CE = (int)s;
  result = s;
  program_invocation_name = (int)s;
  return result;
}
// 8058240: using guessed type int program_invocation_short_name;
// 8058250: using guessed type int program_invocation_name;
// 80586CE: using guessed type int dword_80586CE;

//----- (0804D6C3) --------------------------------------------------------
int __cdecl sub_804D6C3(int *a1, unsigned __int8 a2, char a3)
{
  int *v3; // eax
  int v4; // ST10_4

  if ( a1 )
    v3 = a1;
  else
    v3 = &dword_80586D6;
  v4 = ((unsigned int)v3[(a2 >> 5) + 2] >> (a2 & 0x1F)) & 1;
  v3[(a2 >> 5) + 2] ^= (v4 ^ a3 & 1) << (a2 & 0x1F);
  return v4;
}
// 80586D6: using guessed type int dword_80586D6;

//----- (0804D7E6) --------------------------------------------------------
int *__cdecl sub_804D7E6(int *a1, int a2, int a3)
{
  signed __int32 v3; // ecx
  int *result; // eax
  signed __int32 v5; // et0

  if ( !a1 )
    a1 = &dword_80586D6;
  *a1 = 10;
  v5 = _InterlockedExchange(&dword_80581B4, (signed __int32)a1);
  _InterlockedExchange(&dword_80581B4, v3);
  _InterlockedExchange(&dword_80581B4, v5);
  if ( !a2 || !a3 )
    abort();
  a1[10] = a2;
  result = a1;
  a1[11] = a3;
  return result;
}
// 80581B4: using guessed type int dword_80581B4;
// 80586D6: using guessed type int dword_80586D6;

//----- (0804D842) --------------------------------------------------------
_DWORD *__userpurge sub_804D842@<eax>(_DWORD *a1, int a2)
{
  int v3; // [esp+0h] [ebp-38h]
  int v4; // [esp+4h] [ebp-34h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]

  memset(&v3, 0, 0x30u);
  if ( a2 == 10 )
    abort();
  *a1 = a2;
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = v6;
  a1[4] = v7;
  a1[5] = v8;
  a1[6] = v9;
  a1[7] = v10;
  a1[8] = v11;
  a1[9] = v12;
  a1[10] = v13;
  a1[11] = v14;
  return a1;
}

//----- (0804D8D8) --------------------------------------------------------
char *__usercall sub_804D8D8@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<edx>, signed __int32 a6@<ebx>, const char *msgid, int a8)
{
  signed __int32 v8; // ebx
  signed __int32 v9; // edx
  signed __int32 v10; // ebx
  signed __int32 v11; // et0
  signed __int32 v12; // eax
  signed __int32 v13; // edx
  int v14; // ecx
  signed __int32 v15; // eax
  char *result; // eax
  signed __int32 v17; // ecx
  signed __int32 v18; // edx
  signed __int32 v19; // edx
  char v24; // al
  signed __int32 v25; // et2
  unsigned __int8 *v26; // [esp+1Ch] [ebp-10h]

  __asm { pushfw }
  v8 = _InterlockedExchange(&dword_8058158, a6);
  v11 = _InterlockedExchange(&dword_8058158, a5);
  v9 = v8;
  v10 = v11;
  _InterlockedExchange(&dword_8058158, v9);
  v12 = sub_8049E04();
  if ( v12 != 675 )
  {
    v15 = _InterlockedExchange(&dword_8058158, v12);
    _InterlockedExchange(&dword_8058158, v13);
    sub_8049E0E(v14, _InterlockedExchange(&dword_8058158, v15));
  }
  __asm { popfw }
  result = gettext(msgid);
  if ( result == msgid )
  {
    v26 = (unsigned __int8 *)sub_80521BF((signed __int32)result, v17, v10);
    if ( sub_8051A91(v18, v26, "UTF-8") )
    {
      if ( sub_8051A91(v19, v26, "GB18030") )
      {
        if ( a8 == 9 )
          result = (char *)&unk_80538CD;
        else
          result = (char *)&unk_80538CF;
      }
      else if ( *msgid == 96 )
      {
        result = (char *)&unk_80538C6;
      }
      else
      {
        result = (char *)&unk_80538CA;
      }
    }
    else
    {
      _CF = *msgid < 0x60u;
      _OF = __OFSUB__(*msgid, 96);
      _ZF = *msgid == 96;
      _SF = (char)(*msgid - 96) < 0;
      if ( *msgid == 96 )
      {
        __asm { pushfw }
        if ( v10 >= 10 )
        {
          v25 = _InterlockedExchange(&dword_8058158, v10);
          v24 = _InterlockedExchange(&dword_8058158, v19);
          _InterlockedExchange(&dword_8058158, v25);
          if ( ((_BYTE)v10 - 1) * v24 & 1 )
            abort();
        }
        __asm { popfw }
        result = (char *)&unk_80538B6;
      }
      else
      {
        result = (char *)&unk_80538BA;
      }
    }
  }
  return result;
}
// 804D8D8: could not find valid save-restore pair for ebp
// 8049E0E: using guessed type int __fastcall sub_8049E0E(_DWORD, _DWORD);
// 8058158: using guessed type int dword_8058158;

//----- (0804D9FA) --------------------------------------------------------
void __cdecl sub_804D9FA(int a1, int a2, int a3, int a4, unsigned int a5, int a6, int a7, int a8, int a9)
{
  bool v9; // ST53_1

  v9 = __ctype_get_mb_cur_max() == 1;
  if ( a5 <= 0xA )
    JUMPOUT(__CS__, off_80538D4[a5]);
  abort();
}

//----- (0804E48A) --------------------------------------------------------
void __usercall sub_804E48A(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, int a3@<ebp>)
{
  bool v3; // zf
  signed __int32 v4; // ebx

  *(_BYTE *)(a3 - 64) = 1;
  v3 = *(_DWORD *)(a3 + 24) == 2;
  v4 = _InterlockedExchange(&dword_80581B4, a2);
  _InterlockedExchange(&dword_80581B4, a1);
  _InterlockedExchange(&dword_80581B4, v4);
  if ( v3 && *(_BYTE *)(a3 - 70) != 1 )
  {
    if ( *(_DWORD *)(a3 - 52) < *(_DWORD *)(a3 + 12) )
      *(_BYTE *)(*(_DWORD *)(a3 - 76) + *(_DWORD *)(a3 - 52)) = 39;
    if ( ++*(_DWORD *)(a3 - 52) < *(_DWORD *)(a3 + 12) )
      *(_BYTE *)(*(_DWORD *)(a3 - 76) + *(_DWORD *)(a3 - 52)) = 36;
    if ( ++*(_DWORD *)(a3 - 52) < *(_DWORD *)(a3 + 12) )
      *(_BYTE *)(*(_DWORD *)(a3 - 76) + *(_DWORD *)(a3 - 52)) = 39;
    ++*(_DWORD *)(a3 - 52);
    *(_BYTE *)(a3 - 70) = 1;
  }
  if ( *(_DWORD *)(a3 - 52) < *(_DWORD *)(a3 + 12) )
    *(_BYTE *)(*(_DWORD *)(a3 - 76) + *(_DWORD *)(a3 - 52)) = 92;
  ++*(_DWORD *)(a3 - 52);
  JUMPOUT(loc_804E513);
}
// 80581B4: using guessed type int dword_80581B4;

//----- (0804E673) --------------------------------------------------------
void __usercall sub_804E673(int a1@<ebp>)
{
  if ( *(_DWORD *)(a1 - 52) < *(_DWORD *)(a1 + 12) )
    *(_BYTE *)(*(_DWORD *)(a1 - 52) + *(_DWORD *)(a1 - 76)) = **(_BYTE **)(a1 - 44);
  ++*(_DWORD *)(a1 - 52);
  ++*(_DWORD *)(a1 - 44);
  JUMPOUT(loc_804E693);
}

//----- (0804E7F8) --------------------------------------------------------
void *__cdecl sub_804E7F8(int a1, int a2, _DWORD *a3, int *a4)
{
  int *v4; // eax
  int *v5; // ST3C_4
  int v6; // ST40_4
  int v7; // ST44_4
  int v8; // eax
  int size; // [esp+48h] [ebp-10h]
  void *ptr; // [esp+4Ch] [ebp-Ch]

  if ( a4 )
    v4 = a4;
  else
    v4 = &dword_80586D6;
  v5 = v4;
  v6 = *__errno_location();
  v7 = v5[1] | (a3 == 0);
  sub_804D9FA(0, 0, a1, a2, *v5, v7, (int)(v5 + 2), v5[10], v5[11]);
  size = v8 + 1;
  ptr = sub_8050560((signed __int32)(v5 + 2), v8 + 1);
  sub_804D9FA((int)ptr, size, a1, a2, *v5, v7, (int)(v5 + 2), v5[10], v5[11]);
  *__errno_location() = v6;
  if ( a3 )
    *a3 = size - 1;
  return ptr;
}
// 80586D6: using guessed type int dword_80586D6;

//----- (0804EA56) --------------------------------------------------------
signed int __usercall sub_804EA56@<eax>(signed __int32 a1@<ebx>, int a2, int a3, int a4, unsigned int *a5)
{
  signed __int32 v5; // edx
  signed __int32 v6; // ecx
  int v7; // edx
  signed __int32 v8; // ebx
  signed __int32 v9; // et0
  signed __int32 v10; // ebx
  signed __int32 v11; // ecx
  signed __int32 v12; // ecx
  signed __int32 v13; // et1
  void *v14; // edx
  size_t v15; // ST54_4
  size_t v16; // eax
  int *v17; // edx
  signed __int32 v22; // ebx
  signed __int32 v24; // ebx
  bool v25; // [esp+37h] [ebp-21h]
  int *v26; // [esp+38h] [ebp-20h]
  _BYTE *ptr; // [esp+3Ch] [ebp-1Ch]
  int v28; // [esp+40h] [ebp-18h]
  int size; // [esp+44h] [ebp-14h]
  int v30; // [esp+48h] [ebp-10h]

  v28 = *__errno_location();
  v26 = off_80581F0;
  if ( a2 < 0 )
    abort();
  if ( dword_80581E4 <= a2 )
  {
    v25 = off_80581F0 == &dword_80581E8;
    if ( (unsigned int)a2 > 0xFFFFFFE )
      sub_8050844(
        (unsigned int)a2 < 0xFFFFFFE,
        a2 == 268435454,
        a2 - 268435454 < 0,
        __OFSUB__(a2, 268435454),
        a2,
        v5,
        a1);
    v7 = 8 * (a2 + 1);
    if ( v25 )
    {
      dword_8058180 = (int)&loc_804EAF7;
      v8 = _InterlockedExchange(&dword_8058184, a1);
      v9 = _InterlockedExchange(&dword_8058184, v7);
      sub_8052AF1(v6, _InterlockedExchange(&dword_8058184, v8));
      v10 = _InterlockedExchange(&dword_8058184, v9);
      v13 = _InterlockedExchange(&dword_8058184, v11);
      v12 = v10;
      a1 = v13;
      v6 = _InterlockedExchange(&dword_8058184, v12);
    }
    v26 = (int *)sub_80506E2(
                   _InterlockedExchange(&dword_80581B4, _InterlockedExchange(&dword_80581B4, a1)),
                   _InterlockedExchange(&dword_80581B4, v6),
                   v26,
                   v7);
    off_80581F0 = v26;
    if ( v25 )
    {
      v14 = off_80581EC;
      *v26 = dword_80581E8;
      v26[1] = (int)v14;
    }
    memset(&v26[2 * dword_80581E4], 0, 8 * (a2 + 1 - dword_80581E4));
    dword_80581E4 = a2 + 1;
  }
  v15 = v26[2 * a2];
  ptr = (_BYTE *)v26[2 * a2 + 1];
  v30 = a5[1] | 1;
  sub_804D9FA(v26[2 * a2 + 1], v26[2 * a2], a3, a4, *a5, v30, (int)(a5 + 2), a5[10], a5[11]);
  if ( v15 <= v16 )
  {
    v17 = &v26[2 * a2];
    size = v16 + 1;
    *v17 = v16 + 1;
    _CF = ptr < (_BYTE *)&unk_8058716;
    _OF = __OFSUB__(ptr, &unk_8058716);
    _ZF = ptr == (_BYTE *)&unk_8058716;
    _SF = ptr - (_BYTE *)&unk_8058716 < 0;
    if ( ptr != (_BYTE *)&unk_8058716 )
    {
      __asm { pushfw }
      v22 = _InterlockedExchange(&dword_8058164, (signed __int32)(a5 + 2));
      _InterlockedExchange(&dword_8058164, (signed __int32)v17);
      _InterlockedExchange(&dword_8058164, v22);
      return 85;
    }
    v24 = (signed __int32)&v26[2 * a2];
    ptr = sub_8050560(v24, size);
    *(_DWORD *)(v24 + 4) = ptr;
    sub_804D9FA((int)ptr, size, a3, a4, *a5, v30, (int)(a5 + 2), a5[10], a5[11]);
  }
  *__errno_location() = v28;
  return (signed int)ptr;
}
// 8052AF1: using guessed type int __fastcall sub_8052AF1(_DWORD, _DWORD);
// 8058164: using guessed type int dword_8058164;
// 8058180: using guessed type int dword_8058180;
// 8058184: using guessed type int dword_8058184;
// 80581B4: using guessed type int dword_80581B4;
// 80581E4: using guessed type int dword_80581E4;
// 80581E8: using guessed type int dword_80581E8;
// 80581EC: using guessed type void *off_80581EC;
// 80581F0: using guessed type int *off_80581F0;

//----- (0804ED14) --------------------------------------------------------
signed int __usercall sub_804ED14@<eax>(signed __int32 a1@<ebx>, int a2, int a3)
{
  return sub_804EA56(a1, a2, a3, -1, (unsigned int *)&dword_80586D6);
}
// 80586D6: using guessed type int dword_80586D6;

//----- (0804ED3E) --------------------------------------------------------
signed int __usercall sub_804ED3E@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, int a8, int a9, int a10)
{
  signed __int32 v10; // eax
  signed __int32 v11; // edx
  int v12; // ecx
  signed __int32 v13; // ebx

  __asm { pushfw }
  v10 = _InterlockedExchange(&dword_8058158, a5);
  _InterlockedExchange(&dword_8058158, a6);
  _InterlockedExchange(&dword_8058158, v10);
  if ( sub_8049E04() != 675 )
  {
    v13 = _InterlockedExchange(&dword_8058158, a7);
    _InterlockedExchange(&dword_8058158, v11);
    sub_8049E0E(v12, _InterlockedExchange(&dword_8058158, v13));
  }
  __asm { popfw }
  return sub_804EA56(a7, a8, a9, a10, (unsigned int *)&dword_80586D6);
}
// 804ED3E: could not find valid save-restore pair for ebp
// 8049E0E: using guessed type int __fastcall sub_8049E0E(_DWORD, _DWORD);
// 8058158: using guessed type int dword_8058158;
// 80586D6: using guessed type int dword_80586D6;

//----- (0804EF6D) --------------------------------------------------------
int __usercall sub_804EF6D@<eax>(signed __int32 ecx0@<ecx>, signed __int32 ebx0@<ebx>, int a1, int a2)
{
  char v4; // sf

  return sub_804ED3E(0, 0, v4, 0, a1, ecx0, ebx0, 0, a1, a2);
}

//----- (0804EF8F) --------------------------------------------------------
signed int __usercall sub_804EF8F@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, int a3, int a4, int a5)
{
  signed __int32 v5; // eax
  signed __int32 v6; // ebx
  signed __int32 v7; // edx
  signed __int32 v8; // et1
  unsigned int v10[14]; // [esp+10h] [ebp-38h]

  v5 = _InterlockedExchange(&dword_80581B4, (signed __int32)v10);
  _InterlockedExchange(&dword_80581B4, a1);
  _InterlockedExchange(&dword_80581B4, v5);
  sub_804D842(v10, a4);
  v6 = _InterlockedExchange(&dword_80581B4, a2);
  v8 = _InterlockedExchange(&dword_80581B4, v7);
  _InterlockedExchange(&dword_80581B4, v6);
  return sub_804EA56(v8, a3, a5, -1, v10);
}
// 80581B4: using guessed type int dword_80581B4;

//----- (0804EFF4) --------------------------------------------------------
signed int __usercall sub_804EFF4@<eax>(signed __int32 a1@<ebx>, int a2, int a3, int a4, int a5)
{
  unsigned int v6[14]; // [esp+10h] [ebp-38h]

  sub_804D842(v6, a3);
  return sub_804EA56(a1, a2, a4, a5, v6);
}

//----- (0804F0C4) --------------------------------------------------------
signed int __usercall sub_804F0C4@<eax>(signed __int32 a1@<ebx>, int a2, int a3, unsigned __int8 a4)
{
  signed __int32 v4; // ecx
  char v9; // al
  signed __int32 v10; // et0
  int v12; // [esp+20h] [ebp-38h]
  int v13; // [esp+24h] [ebp-34h]
  int v14; // [esp+28h] [ebp-30h]
  int v15; // [esp+2Ch] [ebp-2Ch]
  int v16; // [esp+30h] [ebp-28h]
  int v17; // [esp+34h] [ebp-24h]
  int v18; // [esp+38h] [ebp-20h]
  int v19; // [esp+3Ch] [ebp-1Ch]
  int v20; // [esp+40h] [ebp-18h]
  int v21; // [esp+44h] [ebp-14h]
  int v22; // [esp+48h] [ebp-10h]
  int v23; // [esp+4Ch] [ebp-Ch]

  v12 = dword_80586D6;
  v13 = dword_80586DA;
  v14 = dword_80586DE;
  v15 = dword_80586E2;
  v16 = dword_80586E6;
  v17 = dword_80586EA;
  v18 = dword_80586EE;
  v19 = dword_80586F2;
  v20 = dword_80586F6;
  v21 = dword_80586FA;
  v22 = dword_80586FE;
  v23 = dword_8058702;
  sub_804D6C3(&v12, a4, 1);
  __asm { pushfw }
  if ( a1 >= 10 )
  {
    v10 = _InterlockedExchange(&dword_8058164, a1);
    v9 = _InterlockedExchange(&dword_8058164, v4);
    _InterlockedExchange(&dword_8058164, v10);
    if ( ((_BYTE)a1 - 1) * v9 & 1 )
      abort();
  }
  __asm { popfw }
  return sub_804EA56(a1, 0, a2, a3, (unsigned int *)&v12);
}
// 8058164: using guessed type int dword_8058164;
// 80586D6: using guessed type int dword_80586D6;
// 80586DA: using guessed type int dword_80586DA;
// 80586DE: using guessed type int dword_80586DE;
// 80586E2: using guessed type int dword_80586E2;
// 80586E6: using guessed type int dword_80586E6;
// 80586EA: using guessed type int dword_80586EA;
// 80586EE: using guessed type int dword_80586EE;
// 80586F2: using guessed type int dword_80586F2;
// 80586F6: using guessed type int dword_80586F6;
// 80586FA: using guessed type int dword_80586FA;
// 80586FE: using guessed type int dword_80586FE;
// 8058702: using guessed type int dword_8058702;

//----- (0804F256) --------------------------------------------------------
signed int __usercall sub_804F256@<eax>(signed __int32 a1@<ebx>, int a2, unsigned __int8 a3)
{
  return sub_804F0C4(a1, a2, -1, a3);
}

//----- (0804F29A) --------------------------------------------------------
signed int __usercall sub_804F29A@<eax>(signed __int32 a1@<ebx>, int a2)
{
  return sub_804F256(a1, a2, 0x3Au);
}

//----- (0804F35A) --------------------------------------------------------
signed int __usercall sub_804F35A@<eax>(signed __int32 a1@<eax>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, int a4, int a5, int a6)
{
  signed __int32 v6; // eax
  int v8; // [esp+10h] [ebp-68h]
  int v9; // [esp+14h] [ebp-64h]
  int v10; // [esp+18h] [ebp-60h]
  int v11; // [esp+1Ch] [ebp-5Ch]
  int v12; // [esp+20h] [ebp-58h]
  int v13; // [esp+24h] [ebp-54h]
  int v14; // [esp+28h] [ebp-50h]
  int v15; // [esp+2Ch] [ebp-4Ch]
  int v16; // [esp+30h] [ebp-48h]
  int v17; // [esp+34h] [ebp-44h]
  int v18; // [esp+38h] [ebp-40h]
  int v19; // [esp+3Ch] [ebp-3Ch]
  int v20; // [esp+40h] [ebp-38h]
  int v21; // [esp+44h] [ebp-34h]
  int v22; // [esp+48h] [ebp-30h]
  int v23; // [esp+4Ch] [ebp-2Ch]
  int v24; // [esp+50h] [ebp-28h]
  int v25; // [esp+54h] [ebp-24h]
  int v26; // [esp+58h] [ebp-20h]
  int v27; // [esp+5Ch] [ebp-1Ch]
  int v28; // [esp+60h] [ebp-18h]
  int v29; // [esp+64h] [ebp-14h]
  int v30; // [esp+68h] [ebp-10h]
  int v31; // [esp+6Ch] [ebp-Ch]

  v6 = _InterlockedExchange(&dword_80581B4, a1);
  _InterlockedExchange(&dword_80581B4, a2);
  _InterlockedExchange(&dword_80581B4, v6);
  sub_804D842(&v8, a5);
  v20 = v8;
  v21 = v9;
  v22 = v10;
  v23 = v11;
  v24 = v12;
  v25 = v13;
  v26 = v14;
  v27 = v15;
  v28 = v16;
  v29 = v17;
  v30 = v18;
  v31 = v19;
  sub_804D6C3(&v20, 0x3Au, 1);
  return sub_804EA56(a3, a4, a6, -1, (unsigned int *)&v20);
}
// 80581B4: using guessed type int dword_80581B4;

//----- (0804F556) --------------------------------------------------------
signed int __usercall sub_804F556@<eax>(signed __int32 a1@<ebx>, int a2, int a3, int a4, int a5)
{
  return sub_804F586(a1, a2, a3, a4, a5, -1);
}

//----- (0804F586) --------------------------------------------------------
signed int __usercall sub_804F586@<eax>(signed __int32 a1@<ebx>, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // [esp+10h] [ebp-38h]
  int v8; // [esp+14h] [ebp-34h]
  int v9; // [esp+18h] [ebp-30h]
  int v10; // [esp+1Ch] [ebp-2Ch]
  int v11; // [esp+20h] [ebp-28h]
  int v12; // [esp+24h] [ebp-24h]
  int v13; // [esp+28h] [ebp-20h]
  int v14; // [esp+2Ch] [ebp-1Ch]
  int v15; // [esp+30h] [ebp-18h]
  int v16; // [esp+34h] [ebp-14h]
  int v17; // [esp+38h] [ebp-10h]
  int v18; // [esp+3Ch] [ebp-Ch]

  v7 = dword_80586D6;
  v8 = dword_80586DA;
  v9 = dword_80586DE;
  v10 = dword_80586E2;
  v11 = dword_80586E6;
  v12 = dword_80586EA;
  v13 = dword_80586EE;
  v14 = dword_80586F2;
  v15 = dword_80586F6;
  v16 = dword_80586FA;
  v17 = dword_80586FE;
  v18 = dword_8058702;
  sub_804D7E6(&v7, a3, a4);
  return sub_804EA56(a1, a2, a5, a6, (unsigned int *)&v7);
}
// 80586D6: using guessed type int dword_80586D6;
// 80586DA: using guessed type int dword_80586DA;
// 80586DE: using guessed type int dword_80586DE;
// 80586E2: using guessed type int dword_80586E2;
// 80586E6: using guessed type int dword_80586E6;
// 80586EA: using guessed type int dword_80586EA;
// 80586EE: using guessed type int dword_80586EE;
// 80586F2: using guessed type int dword_80586F2;
// 80586F6: using guessed type int dword_80586F6;
// 80586FA: using guessed type int dword_80586FA;
// 80586FE: using guessed type int dword_80586FE;
// 8058702: using guessed type int dword_8058702;

//----- (0804F79A) --------------------------------------------------------
signed int __usercall sub_804F79A@<eax>(signed __int32 a1@<ebx>, int a2, int a3, int a4)
{
  return sub_804EA56(a1, a2, a3, a4, (unsigned int *)&unk_8058204);
}

//----- (0804F7F9) --------------------------------------------------------
signed int __usercall sub_804F7F9@<eax>(signed __int32 a1@<ebx>, int a2, int a3)
{
  return sub_804F79A(a1, a2, a3, -1);
}

//----- (0804F81B) --------------------------------------------------------
signed int __usercall sub_804F81B@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<eax>, signed __int32 a6@<ecx>, signed __int32 a7@<ebx>, int a8)
{
  signed __int32 v8; // eax
  unsigned int v9; // eax
  signed __int32 v10; // edx
  signed __int32 v11; // ecx
  signed __int32 v16; // ebx
  signed __int32 v17; // et2
  char v19; // al
  signed __int32 v20; // ett

  __asm { pushfw }
  v8 = _InterlockedExchange(&dword_8058170, a5);
  _InterlockedExchange(&dword_8058170, a6);
  _InterlockedExchange(&dword_8058170, v8);
  v9 = sub_804A6E1();
  _CF = v9 < 0xFFFFFFA8;
  _OF = __OFSUB__(v9, -88);
  _ZF = v9 == -88;
  _SF = (signed int)(v9 + 88) < 0;
  if ( v9 != -88 )
    sub_804A6EB(
      v9 < 0xFFFFFFA8,
      v9 == -88,
      (signed int)(v9 + 88) < 0,
      __OFSUB__(v9, -88),
      _InterlockedExchange(&dword_8058170, _InterlockedExchange(&dword_8058170, a7)),
      _InterlockedExchange(&dword_8058170, v10));
  __asm { pushfw }
  if ( a7 >= 10 )
  {
    v20 = _InterlockedExchange(&dword_8058158, a7);
    v19 = _InterlockedExchange(&dword_8058158, v10);
    _InterlockedExchange(&dword_8058158, v20);
    if ( ((_BYTE)a7 - 1) * v19 & 1 )
      abort();
  }
  __asm
  {
    popfw
    popfw
  }
  v16 = _InterlockedExchange(&dword_80581B4, a7);
  v17 = _InterlockedExchange(&dword_80581B4, v11);
  _InterlockedExchange(&dword_80581B4, v16);
  return sub_804F7F9(v17, 0, a8);
}
// 804F81B: could not find valid save-restore pair for ebp
// 8058158: using guessed type int dword_8058158;
// 8058170: using guessed type int dword_8058170;
// 80581B4: using guessed type int dword_80581B4;

//----- (0804F99D) --------------------------------------------------------
int __usercall sub_804F99D@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>, FILE *stream, int a4, int a5, int a6, int a7, int a8)
{
  signed __int32 v8; // ebx
  char *v9; // eax
  int v10; // ecx
  int v11; // edi
  int v12; // ST54_4
  int v13; // ST50_4
  int v14; // ST4C_4
  int v15; // ST48_4
  int v16; // ST44_4
  int v17; // ST40_4
  int v18; // esi
  int v19; // ebx
  char *v20; // eax

  v8 = _InterlockedExchange(&dword_80581B4, a2);
  _InterlockedExchange(&dword_80581B4, a1);
  _InterlockedExchange(&dword_80581B4, v8);
  if ( a4 )
    fprintf(stream, "%s (%s) %s\n", a4, a5, a6);
  else
    fprintf(stream, "%s %s\n", a5, a6);
  v9 = gettext("(C)");
  fprintf(stream, "Copyright %s %d Free Software Foundation, Inc.", v9, 2017);
  gettext(
    "\n"
    "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\n"
    "This is free software: you are free to change and redistribute it.\n"
    "There is NO WARRANTY, to the extent permitted by law.\n"
    "\n");
  fputs_unlocked(v10);
  if ( (unsigned int)a8 <= 9 )
    JUMPOUT(__CS__, *(&off_8053E5C + a8));
  v11 = *(_DWORD *)(a7 + 32);
  v12 = *(_DWORD *)(a7 + 28);
  v13 = *(_DWORD *)(a7 + 24);
  v14 = *(_DWORD *)(a7 + 20);
  v15 = *(_DWORD *)(a7 + 16);
  v16 = *(_DWORD *)(a7 + 12);
  v17 = *(_DWORD *)(a7 + 8);
  v18 = *(_DWORD *)(a7 + 4);
  v19 = *(_DWORD *)a7;
  v20 = gettext(aWrit);
  return fprintf(stream, v20, v19, v18, v17, v16, v15, v14, v13, v12, v11);
}
// 8048F50: using guessed type int __fastcall fputs_unlocked(_DWORD);
// 8053E5C: using guessed type void *;
// 80581B4: using guessed type int dword_80581B4;

//----- (080501E7) --------------------------------------------------------
int __usercall sub_80501E7@<eax>(signed __int32 a1@<eax>, signed __int32 a2@<edx>, int a3@<ecx>, signed __int32 a4@<ebx>, FILE *stream, int a6, int a7, int a8, int a9)
{
  signed __int32 v9; // eax
  signed __int32 v10; // edx
  signed __int32 v11; // ebx
  signed __int32 v12; // ecx
  signed __int32 v13; // ecx
  signed __int32 v14; // ebx
  signed __int32 v15; // et1
  signed __int32 v16; // ebx
  signed __int32 v17; // edx
  int result; // eax
  signed __int32 *v19; // eax
  int v20; // [esp+24h] [ebp-34h]
  int v21[12]; // [esp+28h] [ebp-30h]

  v20 = 0;
  dword_8058130 = (int)&loc_805022E;
  v9 = _InterlockedExchange(&dword_8058134, a1);
  _InterlockedExchange(&dword_8058134, a2);
  sub_8052D8F(a3, _InterlockedExchange(&dword_8058134, v9));
  v11 = _InterlockedExchange(&dword_8058134, a4);
  v15 = _InterlockedExchange(&dword_8058134, v12);
  v13 = v11;
  v14 = v15;
  _InterlockedExchange(&dword_8058134, v13);
  do
  {
    if ( (unsigned int)++v20 > 9 )
      break;
    v19 = (signed __int32 *)a9;
    a9 += 4;
    v10 = *v19;
    v21[v20] = *v19;
  }
  while ( v21[v20] );
  result = sub_804F99D(v10, v14, stream, a6, a7, a8, (int)v21, v20);
  v16 = _InterlockedExchange(&dword_80581B4, v14);
  _InterlockedExchange(&dword_80581B4, v17);
  _InterlockedExchange(&dword_80581B4, v16);
  return result;
}
// 8052D8F: using guessed type int __fastcall sub_8052D8F(_DWORD, _DWORD);
// 8058130: using guessed type int dword_8058130;
// 8058134: using guessed type int dword_8058134;
// 80581B4: using guessed type int dword_80581B4;
// 80501E7: using guessed type int var_30[12];

//----- (080502F9) --------------------------------------------------------
int __usercall sub_80502F9@<eax>(signed __int32 a1@<edx>, int a2@<ecx>, signed __int32 a3@<ebx>, FILE *stream, int a5, int a6, int a7, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a7);
  return sub_80501E7((signed __int32)stream, a1, a2, a3, stream, a5, a6, a7, (int)va);
}

//----- (08050412) --------------------------------------------------------
void __usercall sub_8050412(signed __int32 a1@<edx>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>, int a4, int *a5, unsigned int a6)
{
  signed __int32 v10; // ebx
  signed __int32 v11; // edx
  signed __int32 v12; // ebx
  signed __int32 v13; // et0
  signed __int32 v14; // edx
  signed __int32 v15; // ebx
  signed __int32 v16; // edx
  signed __int32 v17; // et1
  int v18; // eax
  signed __int32 v19; // et2
  int v20; // [esp+1Ch] [ebp-Ch]
  unsigned int v21; // [esp+1Ch] [ebp-Ch]

  v20 = *a5;
  _CF = 0;
  _OF = 0;
  _ZF = a4 == 0;
  _SF = a4 < 0;
  dword_80581A4 = (int (__fastcall *)(_DWORD, _DWORD))sub_80504E2;
  v10 = _InterlockedExchange(&dword_80581A8, a3);
  v13 = _InterlockedExchange(&dword_80581A8, a1);
  v11 = v10;
  v12 = v13;
  v14 = _InterlockedExchange(&dword_80581A8, v11);
  if ( !a4 )
  {
    _CF = 0;
    _OF = 0;
    _ZF = v20 == 0;
    _SF = v20 < 0;
    dword_80581A4 = (int (__fastcall *)(_DWORD, _DWORD))&loc_8050472;
    v15 = _InterlockedExchange(&dword_80581A8, v12);
    v17 = _InterlockedExchange(&dword_80581A8, v14);
    v16 = v15;
    v12 = v17;
    _InterlockedExchange(&dword_80581A8, v16);
    if ( !v20 )
    {
      v21 = (0x40 / a6 == 0) + 0x40 / a6;
      _CF = 0x7FFFFFFF / a6 < v21;
      _OF = __OFSUB__(0x7FFFFFFF / a6, v21);
      _ZF = 0x7FFFFFFF / a6 == v21;
      _SF = (signed int)(0x7FFFFFFF / a6 - v21) < 0;
      dword_80581A4 = (int (__fastcall *)(_DWORD, _DWORD))&loc_8050540;
      v19 = _InterlockedExchange(&dword_80581A8, 0x7FFFFFFF / a6);
      v18 = _InterlockedExchange(&dword_80581A8, a2);
      _InterlockedExchange(&dword_80581A8, v19);
      if ( 0x7FFFFFFF / a6 < v21 )
        sub_8050844(
          0x7FFFFFFF / a6 < v21,
          0x7FFFFFFF / a6 == v21,
          (signed int)(0x7FFFFFFF / a6 - v21) < 0,
          __OFSUB__(0x7FFFFFFF / a6, v21),
          v18,
          0x7FFFFFFF % a6,
          v12);
    }
  }
  __asm { pushfw }
  JUMPOUT(v12, 10, &loc_804F6A5);
  JUMPOUT(&loc_804F67D);
}
// 80581A4: using guessed type int (__fastcall *dword_80581A4)(_DWORD, _DWORD);
// 80581A8: using guessed type int dword_80581A8;

//----- (080504E2) --------------------------------------------------------
void __usercall sub_80504E2(signed __int32 a1@<ebx>, int a2@<ebp>)
{
  unsigned __int32 v2; // eax
  signed __int32 v3; // edx
  signed __int32 v8; // et0
  int v9; // eax
  signed __int32 v10; // et1
  signed __int32 v11; // edx

  v2 = 0x55555554u / *(_DWORD *)(a2 + 16);
  v3 = 0x55555554u % *(_DWORD *)(a2 + 16);
  _CF = v2 < *(_DWORD *)(a2 - 12);
  _OF = __OFSUB__(v2, *(_DWORD *)(a2 - 12));
  _ZF = v2 == *(_DWORD *)(a2 - 12);
  _SF = (signed int)(v2 - *(_DWORD *)(a2 - 12)) < 0;
  v8 = _InterlockedExchange(&dword_80581B4, v2);
  dword_80581A4 = (int (__fastcall *)(_DWORD, _DWORD))sub_805052E;
  v10 = _InterlockedExchange(&dword_80581A8, _InterlockedExchange(&dword_80581B4, v3));
  v9 = _InterlockedExchange(&dword_80581A8, _InterlockedExchange(&dword_80581B4, v8));
  v11 = _InterlockedExchange(&dword_80581A8, v10);
  if ( _CF || _ZF )
    sub_8050844(_CF, _ZF, _SF, _OF, v9, v11, a1);
  __asm { pushfw }
  JUMPOUT(a1, 10, &loc_804F6A5);
  JUMPOUT(&loc_804F67D);
}
// 80581A4: using guessed type int (__fastcall *dword_80581A4)(_DWORD, _DWORD);
// 80581A8: using guessed type int dword_80581A8;
// 80581B4: using guessed type int dword_80581B4;

//----- (0805052E) --------------------------------------------------------
#error "805055F: positive sp value has been found (funcsize=0)"

//----- (08050560) --------------------------------------------------------
void *__usercall sub_8050560@<eax>(signed __int32 a1@<ebx>, size_t size)
{
  signed __int32 v6; // ebx
  signed __int32 v7; // ecx
  signed __int32 v8; // ecx
  signed __int32 v9; // ebx
  signed __int32 v10; // et0
  signed __int32 v11; // edx
  int v12; // ecx
  signed __int32 v14; // ebx
  void *v15; // [esp-4h] [ebp-1Ch]

  v15 = sub_8050655(a1, size);
  __asm { pushfw }
  v6 = _InterlockedExchange(&dword_8058158, a1);
  v10 = _InterlockedExchange(&dword_8058158, v7);
  v8 = v6;
  v9 = v10;
  _InterlockedExchange(&dword_8058158, v8);
  if ( sub_8049E04() != 675 )
  {
    v14 = _InterlockedExchange(&dword_8058158, v9);
    _InterlockedExchange(&dword_8058158, v11);
    sub_8049E0E(v12, _InterlockedExchange(&dword_8058158, v14));
  }
  __asm { popfw }
  return v15;
}
// 8049E0E: using guessed type int __fastcall sub_8049E0E(_DWORD, _DWORD);
// 8058158: using guessed type int dword_8058158;

//----- (08050655) --------------------------------------------------------
void *__usercall sub_8050655@<eax>(signed __int32 a1@<ebx>, size_t size)
{
  signed __int32 v2; // edx
  signed __int32 v3; // ecx
  char v8; // al
  signed __int32 v9; // ebx
  char v10; // t0
  signed __int32 v12; // [esp-Ah] [ebp-32h]
  void *v13; // [esp+1Ch] [ebp-Ch]

  v13 = malloc(size);
  _CF = 0;
  _OF = 0;
  _ZF = v13 == 0;
  _SF = (signed int)v13 < 0;
  if ( !v13 )
  {
    __asm { pushfw }
    v12 = a1;
    if ( a1 >= 10 )
    {
      v8 = a1;
      v9 = _InterlockedExchange(&dword_8058158, a1);
      v10 = _InterlockedExchange(&dword_8058158, v3);
      _InterlockedExchange(&dword_8058158, v9);
      if ( (v10 - 1) * v8 & 1 )
        abort();
    }
    __asm { popfw }
    if ( size )
      sub_8050844(0, size == 0, (size & 0x80000000) != 0, 0, 0, v2, v12);
  }
  return v13;
}
// 8058158: using guessed type int dword_8058158;

//----- (080506E2) --------------------------------------------------------
void *__usercall sub_80506E2@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, void *ptr, size_t size)
{
  signed __int32 v4; // ebx
  signed __int32 v5; // ecx
  signed __int32 v6; // ebx
  signed __int32 v7; // et0
  void *result; // eax
  signed __int32 v13; // edx

  v4 = _InterlockedExchange(&dword_80581B4, a2);
  v7 = _InterlockedExchange(&dword_80581B4, a1);
  v5 = v4;
  v6 = v7;
  _InterlockedExchange(&dword_80581B4, v5);
  if ( size || !ptr )
  {
    result = realloc(ptr, size);
    if ( !result )
    {
      if ( size )
        sub_8050844(0, size == 0, (size & 0x80000000) != 0, 0, 0, v13, v6);
    }
  }
  else
  {
    free(ptr);
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 80581B4: using guessed type int dword_80581B4;

//----- (080507E3) --------------------------------------------------------
void *__usercall sub_80507E3@<eax>(signed __int32 a1@<ebx>, void *src, size_t n)
{
  signed __int32 v3; // edx
  void *v4; // eax
  signed __int32 v5; // et0

  v5 = _InterlockedExchange(&dword_80581B4, (signed __int32)sub_8050655(a1, n));
  v4 = (void *)_InterlockedExchange(&dword_80581B4, v3);
  _InterlockedExchange(&dword_80581B4, v5);
  return memcpy(v4, src, n);
}
// 80581B4: using guessed type int dword_80581B4;

//----- (08050844) --------------------------------------------------------
void __usercall __noreturn sub_8050844(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<eax>, signed __int32 a6@<edx>, signed __int32 a7@<ebx>)
{
  signed __int32 v7; // ebx
  signed __int32 v8; // eax
  signed __int32 v9; // edx
  int v10; // ecx
  signed __int32 v11; // eax
  char *v12; // eax
  int v13; // [esp+18h] [ebp-4h]

  v13 = a5;
  __asm { pushfw }
  v7 = _InterlockedExchange(&dword_8058158, a7);
  _InterlockedExchange(&dword_8058158, a6);
  _InterlockedExchange(&dword_8058158, v7);
  v8 = sub_8049E04();
  if ( v8 != 675 )
  {
    v11 = _InterlockedExchange(&dword_8058158, v8);
    _InterlockedExchange(&dword_8058158, v9);
    sub_8049E0E(v10, _InterlockedExchange(&dword_8058158, v11));
  }
  __asm { popfw }
  v12 = gettext("memory exhausted");
  error(status, 0, "%s", v12);
  abort();
}
// 8049E0E: using guessed type int __fastcall sub_8049E0E(_DWORD, _DWORD);
// 8058158: using guessed type int dword_8058158;

//----- (08050945) --------------------------------------------------------
void sub_8050945()
{
  ;
}

//----- (0805095A) --------------------------------------------------------
int __usercall sub_805095A@<eax>(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, signed __int32 a3, int a4)
{
  signed __int32 v4; // eax
  int v5; // eax
  signed __int32 v6; // ecx
  signed __int32 v11; // ebx
  signed __int32 v12; // ecx
  signed __int32 v13; // et1
  char v14; // al
  signed __int32 v15; // et2
  int v17; // [esp-4h] [ebp-1Ch]

  v4 = _InterlockedExchange(&dword_80581B4, a3);
  _InterlockedExchange(&dword_80581B4, a1);
  sub_80519C1(_InterlockedExchange(&dword_80581B4, v4), a2, a3, a4);
  _CF = 0;
  _OF = 0;
  _ZF = v5 == 0;
  _SF = v5 < 0;
  if ( v5 < 0 )
  {
    v11 = _InterlockedExchange(&dword_80581B4, a2);
    v13 = _InterlockedExchange(&dword_80581B4, v6);
    v12 = v11;
    a2 = v13;
    _InterlockedExchange(&dword_80581B4, v12);
    sub_8050945();
  }
  v17 = v5;
  __asm { pushfw }
  if ( a2 >= 10 )
  {
    v15 = _InterlockedExchange(&dword_8058158, a2);
    v14 = _InterlockedExchange(&dword_8058158, v6);
    _InterlockedExchange(&dword_8058158, v15);
    if ( ((_BYTE)a2 - 1) * v14 & 1 )
      abort();
  }
  __asm { popfw }
  return v17;
}
// 8058158: using guessed type int dword_8058158;
// 80581B4: using guessed type int dword_80581B4;

//----- (08050AB5) --------------------------------------------------------
unsigned __int64 __usercall sub_8050AB5@<edx:eax>(signed __int32 a1@<ebx>, char *nptr, int base, int a4, int a5, int a6, int a7, char *s, int a9, int a10)
{
  signed __int32 v10; // ecx
  signed __int32 v11; // ebx
  signed __int32 *v12; // eax
  signed __int32 v13; // ecx
  signed __int32 v18; // edx
  signed __int32 v19; // eax
  signed __int32 v20; // ebx
  signed __int32 v21; // et1
  signed __int32 v22; // ebx
  signed __int32 v23; // edx
  signed __int32 v24; // edx
  signed __int32 v25; // et2
  int v27; // [esp+34h] [ebp-14h]
  unsigned __int64 v28; // [esp+38h] [ebp-10h]

  v27 = sub_8050EED(a1, nptr, 0, base, (int)&v28, s);
  if ( v27 )
  {
    if ( v27 == 1 )
    {
      *__errno_location() = 75;
    }
    else if ( v27 == 3 )
    {
      *__errno_location() = 0;
    }
  }
  else if ( v28 < __PAIR__((unsigned int)a5, a4) || __PAIR__((unsigned int)a7, a6) < v28 )
  {
    v27 = 1;
    if ( v28 <= 0x3FFFFFFF )
      *__errno_location() = 34;
    else
      *__errno_location() = 75;
  }
  if ( v27 )
  {
    v11 = sub_804F81B(0, v27 == 0, v27 < 0, 0, (signed __int32)nptr, v10, a1, (int)nptr);
    v12 = (signed __int32 *)*__errno_location();
    _CF = (unsigned int)v12 < 0x16;
    _OF = __OFSUB__(v12, 22);
    _ZF = v12 == (signed __int32 *)22;
    _SF = (signed int)v12 - 22 < 0;
    if ( v12 == (signed __int32 *)22 )
    {
      __asm { pushfw }
      v18 = 0;
      __asm { popfw }
    }
    else
    {
      v12 = __errno_location();
      v18 = *v12;
    }
    if ( a10 )
    {
      v19 = _InterlockedExchange(&dword_80581B4, (signed __int32)v12);
      _InterlockedExchange(&dword_80581B4, v13);
      dword_8058194 = (int)&loc_8050C1D;
      v20 = _InterlockedExchange(&dword_8058198, v11);
      v21 = _InterlockedExchange(&dword_8058198, v18);
      sub_8052A2B(_InterlockedExchange(&dword_80581B4, v19), _InterlockedExchange(&dword_8058198, v20));
      v22 = _InterlockedExchange(&dword_8058198, v21);
      v25 = _InterlockedExchange(&dword_8058198, v23);
      v24 = v22;
      v11 = v25;
      v18 = _InterlockedExchange(&dword_8058198, v24);
    }
    error(1, v18, "%s: %s", a9, v11);
  }
  return v28;
}
// 8052A2B: using guessed type int __fastcall sub_8052A2B(_DWORD, _DWORD);
// 8058194: using guessed type int dword_8058194;
// 8058198: using guessed type int dword_8058198;
// 80581B4: using guessed type int dword_80581B4;

//----- (08050C48) --------------------------------------------------------
unsigned __int64 __usercall sub_8050C48@<edx:eax>(signed __int32 a1@<ebx>, char *nptr, int a3, int a4, int a5, int a6, char *s, int a8, int a9)
{
  return sub_8050AB5(a1, nptr, 10, a3, a4, a5, a6, s, a8, a9);
}

//----- (08050CBC) --------------------------------------------------------
signed int __cdecl sub_8050CBC(unsigned int *a1, signed int a2)
{
  signed __int64 v2; // rcx
  unsigned __int32 v3; // edx
  unsigned int v4; // ebx
  signed int result; // eax
  _DWORD *v10; // eax
  signed __int32 v11; // et0

  v2 = sub_8052630(0xFFFFFFFFFFFFFFFFLL, a2, a2 >> 31);
  v3 = a1[1];
  if ( HIDWORD(v2) <= v3 && (HIDWORD(v2) < v3 || (unsigned int)v2 < *a1) )
  {
    v11 = _InterlockedExchange(&dword_80581B4, (signed __int32)a1);
    v10 = (_DWORD *)_InterlockedExchange(&dword_80581B4, v3);
    _InterlockedExchange(&dword_80581B4, v11);
    *v10 = -1;
    v10[1] = -1;
    result = 1;
  }
  else
  {
    v4 = a1[1];
    _CF = *a1 * (unsigned __int64)(unsigned int)a2 >> 32 != 0;
    _OF = *a1 * (unsigned __int64)(unsigned int)a2 >> 32 != 0;
    *(_QWORD *)a1 *= a2;
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 80581B4: using guessed type int dword_80581B4;

//----- (08050DF3) --------------------------------------------------------
signed int __usercall sub_8050DF3@<eax>(signed __int32 a1@<eax>, signed __int32 a2@<edx>, signed __int32 a3@<ecx>, signed __int32 a4@<ebx>, unsigned int *a5, signed int a6, signed __int32 a7)
{
  signed __int32 v7; // eax
  signed __int32 v8; // ebx
  signed __int32 v9; // edx
  signed __int32 v10; // ebx
  signed __int32 v11; // et1
  signed __int32 v12; // ecx
  signed __int32 v13; // eax
  signed __int32 v14; // et2
  signed __int32 v15; // eax
  signed __int32 v16; // edx
  int v17; // edx
  signed __int32 v18; // ecx
  signed __int32 v19; // ebx
  signed int result; // eax
  signed __int32 v21; // ebx
  signed __int32 v22; // ecx
  signed __int32 v23; // ecx
  signed __int32 v24; // ebx
  signed __int32 v25; // et1
  signed __int32 v30; // et2

  dword_80581A4 = (int (__fastcall *)(_DWORD, _DWORD))&loc_8050EBA;
  v7 = _InterlockedExchange(&dword_80581A8, a1);
  _InterlockedExchange(&dword_80581A8, a3);
  dword_8058194 = (int)&loc_804F6F0;
  v8 = _InterlockedExchange(&dword_8058198, a4);
  v11 = _InterlockedExchange(&dword_8058198, a2);
  v9 = v8;
  v10 = v11;
  v14 = _InterlockedExchange(
          &dword_8058198,
          sub_8052A2B(_InterlockedExchange(&dword_80581A8, v7), _InterlockedExchange(&dword_8058198, v9)));
  v13 = _InterlockedExchange(&dword_8058198, v12);
  _InterlockedExchange(&dword_8058198, v14);
  __asm { pushfw }
  v15 = _InterlockedExchange(&dword_8058158, v13);
  _InterlockedExchange(&dword_8058158, v16);
  _InterlockedExchange(&dword_8058158, v15);
  if ( sub_8049E04() != 675 )
  {
    v19 = _InterlockedExchange(&dword_8058158, v10);
    _InterlockedExchange(&dword_8058158, v18);
    sub_8049E0E(_InterlockedExchange(&dword_8058158, v19), v17);
  }
  __asm { popfw }
  result = sub_8050CBC(a5, a6);
  v21 = _InterlockedExchange(&dword_80581B4, v10);
  v25 = _InterlockedExchange(&dword_80581B4, v22);
  v23 = v21;
  v24 = v25;
  _CF = 0;
  _OF = 0;
  _ZF = a7 == 0;
  _SF = a7 < 0;
  dword_80581A4 = (int (__fastcall *)(_DWORD, _DWORD))&loc_8050E53;
  v30 = _InterlockedExchange(&dword_80581A8, a7);
  _InterlockedExchange(&dword_80581A8, _InterlockedExchange(&dword_80581B4, v23));
  _InterlockedExchange(&dword_80581A8, v30);
  if ( a7 )
  {
    __asm { pushfw }
    JUMPOUT(v24, 10, &loc_804F6A5);
    JUMPOUT(&loc_804F67D);
  }
  return result;
}
// 8049E0E: using guessed type int __fastcall sub_8049E0E(_DWORD, _DWORD);
// 8052A2B: using guessed type int __fastcall sub_8052A2B(_DWORD, _DWORD);
// 8058158: using guessed type int dword_8058158;
// 8058194: using guessed type int dword_8058194;
// 8058198: using guessed type int dword_8058198;
// 80581A4: using guessed type int (__fastcall *dword_80581A4)(_DWORD, _DWORD);
// 80581A8: using guessed type int dword_80581A8;
// 80581B4: using guessed type int dword_80581B4;

//----- (08050EED) --------------------------------------------------------
int __usercall sub_8050EED@<eax>(signed __int32 a1@<ebx>, char *nptr, int a3, int base, int a5, char *s)
{
  char **v6; // eax
  int result; // eax
  int v8; // edx
  signed __int32 v9; // edx
  signed __int32 v10; // ecx
  int v11; // edx
  int v12; // eax
  int v13; // edx
  int v14; // edx
  unsigned __int8 i; // [esp+1Bh] [ebp-2Dh]
  char v16; // [esp+1Ch] [ebp-2Ch]
  int v17; // [esp+20h] [ebp-28h]
  char *v18; // [esp+24h] [ebp-24h]
  int v19; // [esp+28h] [ebp-20h]
  int v20; // [esp+2Ch] [ebp-1Ch]
  int v21; // [esp+30h] [ebp-18h]
  char **endptr; // [esp+34h] [ebp-14h]
  uintmax_t v23; // [esp+38h] [ebp-10h]

  v17 = 0;
  if ( base < 0 || base > 36 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoumax");
  if ( a3 )
    v6 = (char **)a3;
  else
    v6 = (char **)&v16;
  endptr = v6;
  *__errno_location() = 0;
  v18 = nptr;
  for ( i = *nptr; (*__ctype_b_loc())[i] & 0x2000; i = *v18 )
    ++v18;
  if ( i == 45 )
    return 4;
  v23 = strtoumax(nptr, endptr, base);
  if ( *endptr == nptr )
  {
    if ( !s || !**endptr || !strchr(s, **endptr) )
      return 4;
    v23 = 1LL;
  }
  else if ( *__errno_location() )
  {
    if ( *__errno_location() != 34 )
      return 4;
    v17 = 1;
  }
  if ( !s )
  {
    v8 = HIDWORD(v23);
    *(_DWORD *)a5 = v23;
    *(_DWORD *)(a5 + 4) = v8;
    return v17;
  }
  if ( !**endptr )
  {
LABEL_53:
    v14 = HIDWORD(v23);
    *(_DWORD *)a5 = v23;
    *(_DWORD *)(a5 + 4) = v14;
    return v17;
  }
  v19 = 1024;
  v20 = 1;
  if ( !strchr(s, **endptr) )
  {
    v11 = HIDWORD(v23);
    *(_DWORD *)a5 = v23;
    *(_DWORD *)(a5 + 4) = v11;
    return v17 | 2;
  }
  switch ( **endptr )
  {
    case 69:
    case 71:
    case 75:
    case 77:
    case 80:
    case 84:
    case 89:
    case 90:
    case 103:
    case 107:
    case 109:
    case 116:
      if ( strchr(s, 48) )
      {
        v12 = (*endptr)[1];
        switch ( v12 )
        {
          case 68:
            goto LABEL_56;
          case 105:
            if ( (*endptr)[2] == 66 )
              v20 += 2;
            goto LABEL_37;
          case 66:
LABEL_56:
            v19 = 1000;
            ++v20;
            break;
        }
      }
      break;
    default:
      break;
  }
LABEL_37:
  switch ( **endptr )
  {
    case 66:
      v21 = sub_8050CBC((unsigned int *)&v23, 1024);
      goto LABEL_51;
    case 69:
      v21 = sub_8050DF3((signed __int32)&v23, v9, v10, a1, (unsigned int *)&v23, v19, 6);
      goto LABEL_51;
    case 71:
    case 103:
      v21 = sub_8050DF3((signed __int32)&v23, v9, v10, a1, (unsigned int *)&v23, v19, 3);
      goto LABEL_51;
    case 75:
    case 107:
      v21 = sub_8050DF3((signed __int32)&v23, v9, v10, a1, (unsigned int *)&v23, v19, 1);
      goto LABEL_51;
    case 77:
    case 109:
      v21 = sub_8050DF3((signed __int32)&v23, v9, v10, a1, (unsigned int *)&v23, v19, 2);
      goto LABEL_51;
    case 80:
      v21 = sub_8050DF3((signed __int32)&v23, v9, v10, a1, (unsigned int *)&v23, v19, 5);
      goto LABEL_51;
    case 84:
    case 116:
      v21 = sub_8050DF3((signed __int32)&v23, v9, v10, a1, (unsigned int *)&v23, v19, 4);
      goto LABEL_51;
    case 89:
      v21 = sub_8050DF3((signed __int32)&v23, v9, v10, a1, (unsigned int *)&v23, v19, 8);
      goto LABEL_51;
    case 90:
      v21 = sub_8050DF3(
              (signed __int32)&v23,
              _InterlockedExchange(&dword_80581B4, _InterlockedExchange(&dword_80581B4, a1)),
              v10,
              _InterlockedExchange(&dword_80581B4, v9),
              (unsigned int *)&v23,
              v19,
              7);
      goto LABEL_51;
    case 98:
      v21 = sub_8050CBC((unsigned int *)&v23, 512);
      goto LABEL_51;
    case 99:
      v21 = 0;
      goto LABEL_51;
    case 119:
      v21 = sub_8050CBC((unsigned int *)&v23, 2);
LABEL_51:
      v17 |= v21;
      *endptr += v20;
      if ( **endptr )
        v17 |= 2u;
      goto LABEL_53;
    default:
      v13 = HIDWORD(v23);
      *(_DWORD *)a5 = v23;
      *(_DWORD *)(a5 + 4) = v13;
      result = v17 | 2;
      break;
  }
  return result;
}
// 80581B4: using guessed type int dword_80581B4;

//----- (08051328) --------------------------------------------------------
int __usercall sub_8051328@<eax>(signed __int32 a1@<ebx>, FILE *stream)
{
  signed __int32 v2; // edx
  int result; // eax
  signed __int32 v4; // et0
  __int64 v5; // rax
  int v6; // eax
  FILE *v7; // [esp+4h] [ebp-24h]
  int v8; // [esp+14h] [ebp-14h]
  int v9; // [esp+18h] [ebp-10h]

  v8 = 0;
  if ( fileno(stream) >= 0 )
  {
    if ( !__freading(stream) || (v6 = fileno(stream), LODWORD(v5) = lseek64(v6, 0, 0, 1), v5 != -1) )
    {
      if ( sub_80515B4(a1, (int)stream, v7) )
        v8 = *__errno_location();
    }
    v9 = fclose(stream);
    if ( v8 )
    {
      *__errno_location() = v8;
      v9 = -1;
    }
    result = v9;
  }
  else
  {
    v4 = _InterlockedExchange(&dword_80581B4, fclose(stream));
    result = _InterlockedExchange(&dword_80581B4, v2);
    _InterlockedExchange(&dword_80581B4, v4);
  }
  return result;
}
// 8049050: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 80581B4: using guessed type int dword_80581B4;

//----- (08051419) --------------------------------------------------------
int __usercall sub_8051419@<eax>(int a1@<edx>, int a2@<ecx>, signed __int32 a3@<ebx>, FILE *stream)
{
  void *v4; // eax
  signed __int32 v5; // edx
  int v6; // ecx
  int v7; // eax
  char v8; // al
  signed __int32 v9; // et0
  signed __int32 v10; // edx
  void *v11; // eax
  signed __int32 v12; // eax
  signed __int32 v13; // ecx
  unsigned __int32 v14; // eax
  signed __int32 v15; // edx
  signed __int32 v20; // eax
  int v22; // [esp-4h] [ebp-1Ch]

  v4 = &loc_8051446;
  if ( !(stream->_flags & 0x100) )
    v4 = &loc_8051577;
  dword_8058130 = (int)v4;
  sub_8052D8F(a2, a1);
  __asm { pushfw }
  if ( a3 >= 10 )
  {
    v9 = _InterlockedExchange(&dword_8058164, a3);
    v8 = _InterlockedExchange(&dword_8058164, v5);
    v10 = _InterlockedExchange(&dword_8058164, v9);
    _ZF = (((_BYTE)a3 - 1) * v8 & 1) == 0;
    v11 = &loc_8051530;
    if ( _ZF )
      v11 = &loc_8051454;
    dword_8058130 = (int)v11;
    sub_8052D8F(v6, v10);
    abort();
  }
  __asm { popfw }
  v7 = sub_8051650(a3, stream, 0, 0, 1);
  v22 = v7;
  __asm { pushfw }
  v12 = _InterlockedExchange(&dword_8058170, v7);
  _InterlockedExchange(&dword_8058170, v13);
  _InterlockedExchange(&dword_8058170, v12);
  v14 = sub_804A6E1();
  _CF = v14 < 0xFFFFFFA8;
  _OF = __OFSUB__(v14, -88);
  _ZF = v14 == -88;
  _SF = (signed int)(v14 + 88) < 0;
  if ( v14 != -88 )
  {
    v20 = _InterlockedExchange(&dword_8058170, v14);
    _InterlockedExchange(&dword_8058170, v15);
    sub_804A6EB(_CF, _ZF, _SF, _OF, _InterlockedExchange(&dword_8058170, v20), a3);
  }
  __asm { popfw }
  return v22;
}
// 8051419: could not find valid save-restore pair for ebx
// 8052D8F: using guessed type int __fastcall sub_8052D8F(_DWORD, _DWORD);
// 8058130: using guessed type int dword_8058130;
// 8058164: using guessed type int dword_8058164;
// 8058170: using guessed type int dword_8058170;

//----- (080515B4) --------------------------------------------------------
int __usercall sub_80515B4@<eax>(signed __int32 a1@<ebx>, int a2, FILE *fp)
{
  int v3; // edx
  int v4; // ecx
  int v9; // eax
  signed __int32 v10; // ecx
  signed __int32 v11; // eax
  unsigned __int32 v12; // eax
  signed __int32 v13; // edx
  bool v14; // cf
  bool v15; // zf
  bool v16; // sf
  char v17; // of
  signed __int32 v18; // eax
  int v20; // [esp+0h] [ebp-1Ch]

  if ( fp && __freading(fp) )
  {
    sub_8051419(v3, v4, a1, fp);
    v9 = fflush(fp);
  }
  else
  {
    v9 = fflush(fp);
  }
  v20 = v9;
  __asm { pushfw }
  v11 = _InterlockedExchange(&dword_8058170, v9);
  _InterlockedExchange(&dword_8058170, v10);
  _InterlockedExchange(&dword_8058170, v11);
  v12 = sub_804A6E1();
  v14 = v12 < 0xFFFFFFA8;
  v17 = __OFSUB__(v12, -88);
  v15 = v12 == -88;
  v16 = (signed int)(v12 + 88) < 0;
  if ( v12 != -88 )
  {
    v18 = _InterlockedExchange(&dword_8058170, v12);
    _InterlockedExchange(&dword_8058170, v13);
    sub_804A6EB(v14, v15, v16, v17, _InterlockedExchange(&dword_8058170, v18), a1);
  }
  __asm { popfw }
  return v20;
}
// 8058170: using guessed type int dword_8058170;

//----- (08051650) --------------------------------------------------------
int __usercall sub_8051650@<eax>(signed __int32 a1@<ebx>, FILE *stream, int a3, int a4, int a5)
{
  char *v5; // edx
  int v6; // eax
  char *v7; // eax
  signed __int32 v8; // ebx
  __off64_t v9; // rax
  int result; // eax

  if ( stream->_IO_read_end != stream->_IO_read_ptr )
    return fseeko64(stream, a3, a4, a5);
  v5 = stream->_IO_write_ptr;
  if ( v5 != stream->_IO_write_base )
    return fseeko64(stream, a3, a4, a5);
  v7 = stream->_IO_save_base;
  v8 = _InterlockedExchange(&dword_80581B4, a1);
  _InterlockedExchange(&dword_80581B4, (signed __int32)v5);
  _InterlockedExchange(&dword_80581B4, v8);
  if ( v7 )
    return fseeko64(stream, a3, a4, a5);
  v6 = fileno(stream);
  LODWORD(v9) = lseek64(v6, a3, a4, a5);
  if ( v9 == -1 )
    return -1;
  _CF = 0;
  _OF = 0;
  _ZF = (stream->_flags & 0xFFFFFFEF) == 0;
  _SF = (stream->_flags & 0xFFFFFFEF & 0x80000000) != 0;
  stream->_flags &= 0xFFFFFFEF;
  stream->_offset = v9;
  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}
// 8048DE0: using guessed type int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8049050: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 80581B4: using guessed type int dword_80581B4;

//----- (080517C6) --------------------------------------------------------
unsigned __int32 __usercall sub_80517C6@<eax>(int a1@<edx>, int a2@<ecx>, signed __int32 a3@<ebx>, wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  void *v7; // eax
  unsigned __int32 v8; // eax
  signed __int32 v9; // edx
  signed __int32 v10; // ecx
  signed __int32 v11; // ebx
  wchar_t v13; // [esp+18h] [ebp-10h]
  unsigned __int32 v14; // [esp+1Ch] [ebp-Ch]

  v7 = &loc_80517EB;
  if ( pwc )
    v7 = &loc_80517F1;
  dword_8058194 = (int)v7;
  sub_8052A2B(a2, a1);
  v8 = mbrtowc(&v13, s, n, p);
  v14 = v8;
  if ( v8 <= 0xFFFFFFFD || !n || !((unsigned __int8)sub_8051C5A(v8, v9, 0) ^ 1) )
    return v14;
  v13 = (unsigned __int8)*s;
  v11 = _InterlockedExchange(&dword_80581B4, a3);
  _InterlockedExchange(&dword_80581B4, v10);
  _InterlockedExchange(&dword_80581B4, v11);
  return 1;
}
// 8052A2B: using guessed type int __fastcall sub_8052A2B(_DWORD, _DWORD);
// 8058194: using guessed type int dword_8058194;
// 80581B4: using guessed type int dword_80581B4;

//----- (0805186D) --------------------------------------------------------
int sub_805186D()
{
  int result; // eax

  __asm { pushfw }
  result = 0;
  __asm { popfw }
  return result;
}

//----- (08051878) --------------------------------------------------------
signed int __usercall sub_8051878@<eax>(char _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, signed __int32 a5@<ecx>, signed __int32 a6@<ebx>)
{
  signed __int32 v6; // ebx
  signed __int32 v7; // eax
  signed __int32 v8; // edx
  signed __int32 v9; // et1

  __asm { pushfw }
  v6 = _InterlockedExchange(&dword_8058170, a6);
  _InterlockedExchange(&dword_8058170, a5);
  _InterlockedExchange(&dword_8058170, v6);
  v7 = sub_804A6E1();
  __asm { pushfw }
  v9 = _InterlockedExchange(&dword_8058164, v7);
  _InterlockedExchange(&dword_8058164, v8);
  _InterlockedExchange(&dword_8058164, v9);
  return 85;
}
// 8058164: using guessed type int dword_8058164;
// 8058170: using guessed type int dword_8058170;

//----- (080519C1) --------------------------------------------------------
void __usercall sub_80519C1(signed __int32 a1@<ecx>, signed __int32 a2@<ebx>, int a3, int a4)
{
  signed __int32 v4; // ebx
  signed __int32 v5; // ecx
  signed __int32 v6; // ebx
  signed __int32 v7; // et0
  signed __int32 v8; // eax
  signed __int32 v13; // ecx
  signed __int32 v14; // et1
  signed __int32 v15; // ecx
  char v16; // al
  signed __int32 v17; // ebx
  char v18; // t2
  signed __int32 v19; // ebx
  signed __int32 v20; // ecx
  signed __int32 v21; // et1
  signed __int32 v22; // [esp-Ah] [ebp-22h]

  v4 = _InterlockedExchange(&dword_80581B4, a2);
  v7 = _InterlockedExchange(&dword_80581B4, a1);
  v5 = v4;
  v6 = v7;
  v8 = sub_8051878(0, 0, _SF, 0, _InterlockedExchange(&dword_80581B4, v5), v7);
  _CF = 0;
  _OF = 0;
  _ZF = v8 == 0;
  _SF = v8 < 0;
  dword_80581A4 = (int (__fastcall *)(_DWORD, _DWORD))sub_8051A8C;
  v14 = _InterlockedExchange(&dword_80581A8, v8);
  _InterlockedExchange(&dword_80581A8, v13);
  _InterlockedExchange(&dword_80581A8, v14);
  if ( !v8 )
  {
    sub_805186D();
    __asm { pushfw }
    v22 = v6;
    if ( v6 >= 10 )
    {
      v16 = v6;
      v17 = _InterlockedExchange(&dword_8058170, v6);
      v18 = _InterlockedExchange(&dword_8058170, v15);
      v15 = _InterlockedExchange(&dword_8058170, v17);
      if ( (v18 - 1) * v16 & 1 )
        abort();
    }
    __asm { popfw }
    dword_80581A4 = (int (__fastcall *)(_DWORD, _DWORD))&locret_8051A8F;
    v19 = _InterlockedExchange(&dword_80581A8, v22);
    v21 = _InterlockedExchange(&dword_80581A8, v15);
    v20 = v19;
    v6 = v21;
    _InterlockedExchange(&dword_80581A8, v20);
  }
  __asm { pushfw }
  JUMPOUT(v6, 10, &loc_804F6A5);
  JUMPOUT(&loc_804F67D);
}
// 8051A8C: using guessed type int sub_8051A8C();
// 8058170: using guessed type int dword_8058170;
// 80581A4: using guessed type int (__fastcall *dword_80581A4)(_DWORD, _DWORD);
// 80581A8: using guessed type int dword_80581A8;
// 80581B4: using guessed type int dword_80581B4;

//----- (08051A8C) --------------------------------------------------------
#error "8051A90: positive sp value has been found (funcsize=0)"

//----- (08051A91) --------------------------------------------------------
int __usercall sub_8051A91@<eax>(signed __int32 a1@<edx>, unsigned __int8 *a2, unsigned __int8 *a3)
{
  unsigned __int8 *v3; // esi
  unsigned __int8 *v4; // ebx
  int result; // eax
  signed __int32 v10; // edx
  unsigned __int8 v11; // al
  char v12; // al
  signed __int32 v13; // et0
  unsigned __int8 v18; // [esp+1Eh] [ebp-Ah]
  unsigned __int8 v19; // [esp+1Fh] [ebp-9h]

  v3 = a2;
  v4 = a3;
  _CF = a2 < a3;
  _OF = __OFSUB__(a2, a3);
  _ZF = a2 == a3;
  _SF = a2 - a3 < 0;
  if ( a2 == a3 )
  {
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  else
  {
    while ( 1 )
    {
      v18 = sub_8052505(a1, (signed __int32)v4, *v3);
      v11 = sub_8052505(v10, (signed __int32)v4, *v4);
      v19 = v11;
      _CF = 0;
      _OF = 0;
      _ZF = v18 == 0;
      _SF = (v18 & 0x80u) != 0;
      if ( !v18 )
        break;
      ++v3;
      ++v4;
      if ( v18 != v11 )
        goto LABEL_12;
    }
    __asm { pushfw }
    if ( (signed int)v4 >= 10 )
    {
      v13 = _InterlockedExchange(&dword_8058164, (signed __int32)v4);
      v12 = _InterlockedExchange(&dword_8058164, a1);
      _InterlockedExchange(&dword_8058164, v13);
      if ( ((_BYTE)v4 - 1) * v12 & 1 )
        abort();
    }
    __asm { popfw }
LABEL_12:
    result = v18 - v19;
  }
  return result;
}
// 8058164: using guessed type int dword_8058164;

//----- (08051B5D) --------------------------------------------------------
int __usercall sub_8051B5D@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>, FILE *stream)
{
  FILE *v3; // eax
  signed __int32 v4; // et0
  signed __int32 v5; // ecx
  char v6; // al
  signed __int32 v7; // et1
  bool v8; // ST2A_1
  signed __int32 v9; // ecx
  unsigned int v14; // eax
  char v19; // al
  signed __int32 v20; // et2
  int result; // eax
  size_t v22; // [esp-4h] [ebp-2Ch]
  bool v23; // [esp+1Fh] [ebp-9h]

  v4 = _InterlockedExchange(&dword_80581B4, (signed __int32)stream);
  v3 = (FILE *)_InterlockedExchange(&dword_80581B4, a1);
  _InterlockedExchange(&dword_80581B4, v4);
  v22 = __fpending(v3);
  __asm { pushfw }
  if ( a2 >= 10 )
  {
    v7 = _InterlockedExchange(&dword_8058158, a2);
    v6 = _InterlockedExchange(&dword_8058158, v5);
    _InterlockedExchange(&dword_8058158, v7);
    if ( ((_BYTE)a2 - 1) * v6 & 1 )
      abort();
  }
  __asm { popfw }
  v8 = ferror_unlocked(stream) != 0;
  v23 = sub_8051328(a2, stream) != 0;
  if ( v8 )
    goto LABEL_17;
  _CF = 0;
  _OF = 0;
  _ZF = v23 == 0;
  _SF = v23 < 0;
  if ( !v23 )
    goto LABEL_18;
  if ( v22 != 0
    || (v14 = *__errno_location(),
        _CF = v14 < 9,
        _OF = __OFSUB__(v14, 9),
        _ZF = v14 == 9,
        _SF = (signed int)(v14 - 9) < 0,
        v14 != 9) )
  {
LABEL_17:
    _CF = 0;
    _OF = 0;
    _ZF = v23 == 1;
    _SF = !v23 < 0;
    if ( v23 != 1 )
    {
      __asm { pushfw }
      if ( a2 >= 10 )
      {
        v20 = _InterlockedExchange(&dword_8058170, a2);
        v19 = _InterlockedExchange(&dword_8058170, v9);
        _InterlockedExchange(&dword_8058170, v20);
        if ( ((_BYTE)a2 - 1) * v19 & 1 )
          abort();
      }
      __asm { popfw }
      *__errno_location() = 0;
    }
    result = -1;
  }
  else
  {
LABEL_18:
    __asm { pushfw }
    result = 0;
    __asm { popfw }
  }
  return result;
}
// 8058158: using guessed type int dword_8058158;
// 8058170: using guessed type int dword_8058170;
// 80581B4: using guessed type int dword_80581B4;

//----- (08051C5A) --------------------------------------------------------
int __usercall sub_8051C5A@<eax>(signed __int32 a1@<eax>, signed __int32 a2@<edx>, int category)
{
  signed __int32 v3; // eax
  signed __int32 v5; // eax
  int v6; // eax
  signed __int32 v7; // ecx
  unsigned __int8 v8; // [esp+1Bh] [ebp-Dh]
  const char *s1; // [esp+1Ch] [ebp-Ch]

  v3 = _InterlockedExchange(&dword_80581B4, a1);
  _InterlockedExchange(&dword_80581B4, a2);
  _InterlockedExchange(&dword_80581B4, v3);
  v8 = 1;
  s1 = setlocale(category, 0);
  if ( s1 )
  {
    v6 = strcmp(s1, "C");
    if ( !v6
      || (v5 = _InterlockedExchange(&dword_80581B4, v6),
          _InterlockedExchange(&dword_80581B4, v7),
          _InterlockedExchange(&dword_80581B4, v5),
          !strcmp(s1, "POSIX")) )
    {
      v8 = 0;
    }
  }
  return v8;
}
// 80581B4: using guessed type int dword_80581B4;

//----- (08051CF9) --------------------------------------------------------
void *__usercall sub_8051CF9@<eax>(signed __int32 a1@<ebx>)
{
  int v1; // ecx
  void *v6; // eax
  signed int v7; // eax
  int v8; // eax
  int v9; // edx
  int v10; // ecx
  void *v11; // eax
  void *v13; // [esp+18h] [ebp-B0h]
  const char *s; // [esp+1Ch] [ebp-ACh]
  signed int n; // [esp+2Ch] [ebp-9Ch]
  size_t v16; // [esp+30h] [ebp-98h]
  signed int v17; // [esp+34h] [ebp-94h]
  char *dest; // [esp+38h] [ebp-90h]
  int fd; // [esp+3Ch] [ebp-8Ch]
  FILE *stream; // [esp+40h] [ebp-88h]
  int c; // [esp+44h] [ebp-84h]
  int ca; // [esp+44h] [ebp-84h]
  char src; // [esp+56h] [ebp-72h]
  char v24; // [esp+89h] [ebp-3Fh]
  unsigned int v25; // [esp+BCh] [ebp-Ch]

  v25 = __readgsdword(0x14u);
  v13 = (void *)dword_8058816;
  if ( !dword_8058816 )
  {
    s = getenv("CHARSETALIASDIR");
    if ( !s || !*s )
      s = "/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib";
    n = strlen(s);
    v16 = strlen("charset.alias");
    _CF = 0;
    _OF = 0;
    _ZF = n == 0;
    _SF = n < 0;
    if ( n )
    {
      v6 = &loc_8051DD8;
      if ( s[n - 1] == 47 )
        v6 = &loc_8051DDF;
      dword_8058130 = (int)v6;
      sub_8052D8F(v1, n - 1);
      v7 = 1;
    }
    else
    {
      __asm { pushfw }
      v7 = 0;
      __asm { popfw }
    }
    v17 = v7;
    dest = (char *)malloc(n + v7 + v16 + 1);
    if ( dest )
    {
      memcpy(dest, s, n);
      if ( v17 )
        dest[n] = 47;
      memcpy(&dest[n + v17], "charset.alias", v16 + 1);
    }
    free(0);
    if ( dest )
    {
      fd = open64(dest, 0x20000);
      if ( fd >= 0 )
      {
        stream = fdopen(fd, "r");
        if ( stream )
        {
          while ( 1 )
          {
            c = getc_unlocked(stream);
            if ( c == -1 )
              break;
            if ( c != 10 && c != 32 && c != 9 )
            {
              if ( c != 35 )
              {
                ungetc(c, stream);
                v8 = fscanf(stream, "%50s %50s", &src, &v24);
                _OF = __OFSUB__(v8, 1);
                _ZF = v8 == 1;
                _SF = v8 - 1 < 0;
                v11 = &loc_8052035;
                if ( !((unsigned __int8)(_SF ^ _OF) | _ZF) )
                  v11 = &loc_805203A;
                dword_8058194 = (int)v11;
                sub_8052A2B(v10, v9);
                break;
              }
              do
                ca = getc_unlocked(stream);
              while ( ca != -1 && ca != 10 );
              if ( ca == -1 )
                break;
            }
          }
          sub_8051328(a1, stream);
          v13 = &unk_80541CF;
        }
        else
        {
          close(fd);
          v13 = &unk_80541CF;
        }
      }
      else
      {
        v13 = &unk_80541CF;
      }
      free(dest);
    }
    else
    {
      v13 = &unk_80541CF;
    }
    dword_8058816 = (int)&unk_80541CF;
  }
  return v13;
}
// 8048D30: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 8052A2B: using guessed type int __fastcall sub_8052A2B(_DWORD, _DWORD);
// 8052D8F: using guessed type int __fastcall sub_8052D8F(_DWORD, _DWORD);
// 8058130: using guessed type int dword_8058130;
// 8058194: using guessed type int dword_8058194;
// 8058816: using guessed type int dword_8058816;

//----- (080521BF) --------------------------------------------------------
signed __int32 __usercall sub_80521BF@<eax>(signed __int32 a1@<eax>, signed __int32 a2@<ecx>, signed __int32 a3@<ebx>)
{
  signed __int32 v3; // eax
  signed __int32 v4; // ebx
  signed __int32 v5; // edx
  signed __int32 v6; // et1
  int v7; // ecx
  signed __int32 v8; // ebx
  signed __int32 v9; // ecx
  signed __int32 v10; // edx
  char *v11; // ST1C_4
  signed __int32 result; // eax
  signed __int32 v13; // ett
  const char *s1; // [esp+18h] [ebp-10h]
  char *s2; // [esp+1Ch] [ebp-Ch]

  v3 = _InterlockedExchange(&dword_80581B4, a1);
  _InterlockedExchange(&dword_80581B4, a2);
  _InterlockedExchange(&dword_80581B4, v3);
  s1 = nl_langinfo(14);
  if ( !s1 )
    s1 = (const char *)&unk_80541CF;
  s2 = (char *)sub_8051CF9(a3);
  dword_8058130 = (int)&loc_805229A;
  v4 = _InterlockedExchange(&dword_8058134, a3);
  v6 = _InterlockedExchange(&dword_8058134, v5);
  sub_8052D8F(v7, _InterlockedExchange(&dword_8058134, v4));
  v8 = _InterlockedExchange(&dword_8058134, v6);
  _InterlockedExchange(&dword_8058134, v9);
  _InterlockedExchange(&dword_8058134, v8);
  while ( strcmp(s1, s2) && (*s2 != 42 || s2[1]) )
  {
    v11 = &s2[strlen(s2) + 1];
    s2 = &v11[strlen(v11) + 1];
    if ( !*s2 )
      goto LABEL_9;
  }
  v10 = strlen(s2) + 1;
  s1 = &s2[v10];
LABEL_9:
  if ( !*s1 )
    s1 = "ASCII";
  v13 = _InterlockedExchange(&dword_80581B4, (signed __int32)s1);
  result = _InterlockedExchange(&dword_80581B4, v10);
  _InterlockedExchange(&dword_80581B4, v13);
  return result;
}
// 8052D8F: using guessed type int __fastcall sub_8052D8F(_DWORD, _DWORD);
// 8058130: using guessed type int dword_8058130;
// 8058134: using guessed type int dword_8058134;
// 80581B4: using guessed type int dword_80581B4;

//----- (08052505) --------------------------------------------------------
int __usercall sub_8052505@<eax>(signed __int32 a1@<edx>, signed __int32 a2@<ebx>, int a3)
{
  signed __int32 v7; // eax
  unsigned __int32 v8; // eax
  signed __int32 v9; // edx
  signed __int32 v10; // eax
  bool v12; // cf
  bool v13; // zf
  bool v14; // sf
  char v15; // of

  _CF = (unsigned int)(a3 - 65) < 0x19;
  _OF = __OFSUB__(a3 - 65, 25);
  _ZF = a3 == 90;
  _SF = a3 - 90 < 0;
  if ( (unsigned int)(a3 - 65) > 0x19 )
    return a3;
  __asm { pushfw }
  v7 = _InterlockedExchange(&dword_8058170, a3 - 65);
  _InterlockedExchange(&dword_8058170, a1);
  _InterlockedExchange(&dword_8058170, v7);
  v8 = sub_804A6E1();
  v12 = v8 < 0xFFFFFFA8;
  v15 = __OFSUB__(v8, -88);
  v13 = v8 == -88;
  v14 = (signed int)(v8 + 88) < 0;
  if ( v8 != -88 )
  {
    v10 = _InterlockedExchange(&dword_8058170, v8);
    _InterlockedExchange(&dword_8058170, v9);
    sub_804A6EB(v12, v13, v14, v15, _InterlockedExchange(&dword_8058170, v10), a2);
  }
  __asm { popfw }
  return a3 + 32;
}
// 8058170: using guessed type int dword_8058170;

//----- (08052630) --------------------------------------------------------
signed __int64 __cdecl sub_8052630(unsigned __int64 a1, unsigned int a2, unsigned int a3)
{
  signed __int64 result; // rax
  int v4; // ebp
  int v5; // ebp
  unsigned int v6; // esi
  int v7; // ST10_4
  unsigned __int64 v8; // rtt
  unsigned int v9; // esi
  unsigned int v10; // edi
  unsigned __int64 v11; // rax
  void *v12; // eax

  if ( !a3 )
  {
    if ( a2 > HIDWORD(a1) )
      return (unsigned int)(a1 / a2);
    v6 = a2;
    if ( !a2 )
      v6 = 1 / 0u;
    LODWORD(result) = __PAIR__(HIDWORD(a1) % v6, (unsigned int)a1) / v6;
    HIDWORD(result) = HIDWORD(a1) / v6;
    return result;
  }
  if ( a3 > HIDWORD(a1) )
    return 0LL;
  _BitScanReverse((unsigned int *)&v4, a3);
  v5 = v4 ^ 0x1F;
  if ( !v5 )
  {
    if ( a2 <= (unsigned int)a1 || a3 < HIDWORD(a1) )
      return 1LL;
    return 0LL;
  }
  v7 = (a3 << v5) | (a2 >> (32 - v5));
  LODWORD(v8) = (HIDWORD(a1) << v5) | ((unsigned int)a1 >> (32 - v5));
  HIDWORD(v8) = HIDWORD(a1) >> (32 - v5);
  v9 = v8 % (unsigned int)v7;
  v10 = v8 / (unsigned int)v7;
  v11 = (a2 << v5) * (unsigned __int64)v10;
  if ( v9 < HIDWORD(v11) )
    return v10 - 1;
  if ( (_DWORD)a1 << v5 < (unsigned int)v11 )
  {
    v12 = &loc_8052742;
    if ( v9 == (a2 << v5) * (unsigned __int64)v10 >> 32 )
      v12 = &loc_805275C;
    dword_8058130 = (int)v12;
    sub_8052D8F(v5, (_DWORD)a1 << v5);
  }
  return v10;
}
// 8052D8F: using guessed type int __fastcall sub_8052D8F(_DWORD, _DWORD);
// 8058130: using guessed type int dword_8058130;

//----- (0805282E) --------------------------------------------------------
int __cdecl sub_805282E(int a1)
{
  return __cxa_atexit(a1, 0, dword_80581C8);
}
// 8048EB0: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 80581C8: using guessed type int dword_80581C8;

//----- (08052A2B) --------------------------------------------------------
#error "8052A31: positive sp value has been found (funcsize=0)"

//----- (08052AF1) --------------------------------------------------------
#error "8052AF7: positive sp value has been found (funcsize=0)"

//----- (08052D8F) --------------------------------------------------------
#error "8052D95: positive sp value has been found (funcsize=0)"

//----- (08052F00) --------------------------------------------------------
int (**sub_8052F00())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_8057ED0;
  v1 = &off_8057ED4 - off_8057ED0;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_8057ED0[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 8057ED0: using guessed type int (*off_8057ED0[2])();
// 8057ED4: using guessed type int (*off_8057ED4)();

//----- (08052F64) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 13 decompilation failure(s) on 148 function(s)"
