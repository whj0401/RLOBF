/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8048E90();
// int strcmp(const char *s1, const char *s2);
// int __cdecl open64(_DWORD, _DWORD); weak
// ssize_t read(int fd, void *buf, size_t nbytes);
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void free(void *ptr);
// void *memcpy(void *dest, const void *src, size_t n);
// int fclose(FILE *stream);
// int getc_unlocked(FILE *stream);
// int __stdcall fseeko64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// int sysconf(int name);
// int ferror_unlocked(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD); weak
// size_t __ctype_get_mb_cur_max(void);
// char *strcpy(char *dest, const char *src);
// size_t __fpending(FILE *fp);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// void error(int status, int errnum, const char *format, ...);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int sysinfo(struct sysinfo *info);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int feof(FILE *stream);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// char *strchr(const char *s, int c);
// int fscanf(FILE *stream, const char *format, ...);
// size_t strlen(const char *s);
// int fprintf(FILE *stream, const char *format, ...);
// void *memset(void *s, int c, size_t n);
// int ungetc(int c, FILE *stream);
// int *__errno_location(void);
// void *memchr(const void *s, int c, size_t n);
// int fileno(FILE *stream);
// int fgetc(FILE *stream);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// char *strrchr(const char *s, int c);
// int __cdecl getdelim(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall lseek64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// void abort(void);
// int __cdecl __xstat64(_DWORD, _DWORD, _DWORD); weak
// int close(int fd);
// const unsigned __int16 **__ctype_b_loc(void);
// int putchar_unlocked(int c);
// int _gmon_start__(void); weak
void sub_8049353();
void sub_8049370();
int sub_8049380();
int sub_80493F0();
int sub_8049410();
void sub_804946F();
void sub_804948A();
signed int sub_804949A();
void sub_804957C();
void sub_8049597();
int sub_80495A7();
int sub_80495ED();
void sub_80496B5();
void sub_80496D0();
int sub_80496E0();
void sub_80497C2();
void sub_80497DD();
int sub_80497ED();
int nullsub_3(void); // weak
int sub_804984B();
void sub_80498FB();
void sub_8049916();
signed int sub_8049926();
void sub_8049A08();
void sub_8049A23();
int sub_8049A33();
// int __usercall sub_8049AE5@<eax>(void (__cdecl *a1)(int *)@<eax>);
void sub_8049B31();
void sub_8049B4C();
int sub_8049B5C();
int __cdecl sub_8049C31(unsigned __int8 a1);
int sub_8049C43();
int __cdecl sub_8049E25(int a1);
void __cdecl __noreturn sub_8049E5D(int status); // idb
// unsigned int __usercall sub_8049F93@<eax>(int a1@<edi>, int a2@<esi>, unsigned __int64 a3, unsigned __int64 a4, unsigned __int64 a5, unsigned __int64 a6, unsigned __int64 a7, char *a8);
// int __usercall sub_804A1B6@<eax>(const unsigned __int16 *a1@<edi>, unsigned int a2@<esi>, int fd, int a4, int a5, int a6, int a7);
// int __usercall sub_804B29C@<eax>(const unsigned __int16 *a1@<edi>, unsigned int a2@<esi>, char *s1, int a4);
_DWORD *__cdecl sub_804B411(unsigned int a1, int a2);
int __cdecl sub_804B5B2(int argc, char **argv); // idb
_DWORD *__cdecl sub_804C121(int a1);
_DWORD *__cdecl sub_804C18B(int a1);
int __cdecl sub_804C1F2(int *a1, signed int *a2);
int __cdecl sub_804C2D8(_DWORD *a1);
int __cdecl sub_804C327(void *ptr); // idb
int __cdecl sub_804C4E6(int a1, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_804C58F@<eax>(int a1@<edi>, int a2@<esi>, unsigned __int64 a3, int a4);
bool __cdecl sub_804C6FD(unsigned __int8 a1);
long double sub_804C744();
long double sub_804C80D();
char *__cdecl sub_804C8E4(char *s);
int __fastcall sub_804CA30(int ecx0, int edx0, int a1, char a2, int a3);
int *__cdecl sub_804CB4F(int *a1, int a2, int a3);
// int *__userpurge sub_804CBB0@<eax>(int *a1, int a2);
int __cdecl sub_804CC66(char *msgid, int); // idb
// unsigned int __usercall sub_804CD21@<eax>(size_t a1@<ebx>, int a2, unsigned int a3, char *a4, size_t a5, signed int a6, int a7, int a8, char *a9, char *a10);
void *__cdecl sub_804DB31(char *a1, size_t a2, _DWORD *a3, int *a4);
void *__cdecl sub_804DD50(signed int a1, char *a2, size_t a3, int a4);
void *__cdecl sub_804DFE4(signed int a1, char *a2);
void *__cdecl sub_804E00E(signed int a1, char *a2, size_t a3);
void *__cdecl sub_804E084(signed int a1, int a2, char *a3);
void *__cdecl sub_804E0C2(signed int a1, int a2, char *a3, size_t a4);
void *__cdecl sub_804E0FF(int a1, char *a2);
// void *__usercall sub_804E15A@<eax>(int a1@<edx>, int a2@<ecx>, char *a3, size_t a4, char a5);
// void *__usercall sub_804E214@<eax>(int a1@<edx>, int a2@<ecx>, char *a3, char a4);
// void *__usercall sub_804E281@<eax>(int a1@<edx>, int a2@<ecx>, char *a3);
void *__cdecl sub_804E2E6(signed int a1, int a2, char *a3);
void *__cdecl sub_804E397(signed int a1, int a2, int a3, char *a4);
void *__cdecl sub_804E3EB(signed int a1, int a2, int a3, char *a4, size_t a5);
void *__cdecl sub_804E515(signed int a1, char *a2, size_t a3);
void *__cdecl sub_804E570(signed int a1, char *a2);
int __cdecl sub_804E5CD(int a1);
int __cdecl sub_804E6B0(_DWORD *a1);
_DWORD *__cdecl sub_804E7E7(_DWORD *a1);
int __cdecl sub_804EA18(FILE *stream, int); // idb
ssize_t __cdecl sub_804ED4F(int fd, void *buf, size_t nbytes);
int __cdecl sub_804EDB1(FILE *stream, int, int, int, int, int); // idb
int __cdecl sub_804F40A(FILE *stream, int, int, int, int); // idb
int sub_804F480(FILE *stream, int a2, int a3, int a4, ...);
int __cdecl sub_804F538(unsigned int a1, unsigned int a2);
int sub_804F577(); // weak
void *__cdecl sub_804F5DF(void *ptr, int a2, int a3);
int __cdecl sub_804F676(size_t size); // idb
int __cdecl sub_804F689(size_t size); // idb
int sub_804F6D2(); // weak
void *__cdecl sub_804F6D7(void *ptr, size_t size);
void *__cdecl sub_804F7AF(void *src, size_t n);
void __noreturn sub_804F7FD();
void sub_804F836();
void sub_804F83B();
int __cdecl sub_804F85E(FILE *stream); // idb
int __cdecl sub_804F93A(FILE *a1);
int __cdecl sub_804F973(FILE *fp); // idb
int __cdecl sub_804F9B3(FILE *stream, int a2, int a3, int a4);
size_t __cdecl sub_804FAC2(wchar_t *pwc, char *s, size_t n, mbstate_t *p);
int __cdecl sub_804FB34(int a1, int a2);
int __cdecl sub_804FB72(int a1, int a2);
int __cdecl sub_804FBBC(char *format, int, int); // idb
int __cdecl sub_804FCE8(char *format, int, int, int, int); // idb
int __cdecl sub_804FD91(int a1, int a2);
_BOOL4 __cdecl sub_804FF8A(int a1, unsigned int a2);
int __cdecl sub_804FFCE(int a1, unsigned int a2);
void __noreturn sub_80500B0();
int sub_80500E9();
int sub_80500F3();
int sub_80500FD();
int __cdecl sub_8050130(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_80501A1(FILE *fp); // idb
int __cdecl sub_8050222(int category); // idb
void *sub_8050280();
const char *sub_8050788();
int __cdecl sub_8050A20(int a1);
// int __usercall sub_8050A5C@<eax>(int a1@<edi>, int a2@<esi>, int a3, int a4, unsigned int a5, int a6);
int __cdecl sub_8050C8B(unsigned __int64 a1, __int64 a2);
int __cdecl sub_8050E7E(int a1);
int __cdecl sub_8050EAD(int a1, int a2);
int __cdecl sub_8050EEC(int a1, int a2);
int sub_805104D(void); // weak
int sub_80510DD(void); // weak
int __stdcall sub_80511B7(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (**sub_80511D0())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_804A37E; // weak
_UNKNOWN loc_804A3B1; // weak
_UNKNOWN loc_804A3F7; // weak
_UNKNOWN loc_804A70F; // weak
_UNKNOWN loc_804A855; // weak
_UNKNOWN loc_804A8BC; // weak
_UNKNOWN loc_804A94F; // weak
_UNKNOWN loc_804A9DB; // weak
_UNKNOWN loc_804AA2A; // weak
_UNKNOWN loc_804AFFC; // weak
_UNKNOWN loc_804B04C; // weak
_UNKNOWN loc_804B060; // weak
_UNKNOWN loc_804B0E4; // weak
_UNKNOWN loc_804B5A9; // weak
_UNKNOWN loc_804CA94; // weak
_UNKNOWN loc_804CA99; // weak
_UNKNOWN loc_804CE02; // weak
_UNKNOWN loc_804CE19; // weak
_UNKNOWN loc_804CF62; // weak
_UNKNOWN loc_804CFC8; // weak
_UNKNOWN loc_804D453; // weak
_UNKNOWN loc_804D45C; // weak
_UNKNOWN loc_804D696; // weak
_UNKNOWN loc_804D71A; // weak
_UNKNOWN loc_804D7A7; // weak
_UNKNOWN loc_804D7AC; // weak
_UNKNOWN loc_804D8FF; // weak
_UNKNOWN loc_804D982; // weak
_UNKNOWN locret_804FAC0; // weak
_UNKNOWN loc_805074F; // weak
_UNKNOWN loc_8050AD5; // weak
_UNKNOWN loc_8050AFC; // weak
_UNKNOWN loc_8050B87; // weak
int dword_8051BC0[8] = { 6656, 4294967279, 4294967294, 2147483646, 0, 0, 0, 0 }; // idb
_UNKNOWN unk_8051D25; // weak
_UNKNOWN unk_8052457; // weak
int dword_8053F0C = 3326152718; // weak
int (*off_8055EEC[2])() = { &sub_8049410, &sub_80493F0 }; // weak
int (*off_8055EF0)() = &sub_80493F0; // weak
int (*dword_8056008)(void) = NULL; // weak
int dword_8056134 = 0; // weak
int dword_8056154 = 0; // weak
int dword_8056168 = 0; // weak
int (__fastcall *dword_8056184)(_DWORD, _DWORD) = NULL; // weak
int dword_805619C = 0; // weak
int status = 1; // idb
int dword_80561B8 = 1; // weak
int dword_80561BC = 256; // weak
void *off_80561C0 = &unk_80565FB; // weak
int *off_80561C4 = &dword_80561BC; // weak
_UNKNOWN unk_80561D8; // weak
_UNKNOWN unk_80561F8; // weak
_UNKNOWN unk_80561FB; // weak
_UNKNOWN unk_80561FC; // weak
_UNKNOWN unk_80561FF; // weak
_UNKNOWN unk_8056200; // weak
_UNKNOWN unk_8056203; // weak
void (__noreturn *off_8056208)() = &sub_80500B0; // weak
_UNKNOWN unk_805620C; // weak
_UNKNOWN unk_805620F; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int program_invocation_name; // weak
FILE *stdout; // idb
int (*obstack_alloc_failed_handler)(void); // weak
char byte_805628C; // weak
char byte_8056366; // weak
__int64 qword_805656B; // weak
__int64 qword_8056573; // weak
__int64 qword_805657B; // weak
__int64 qword_8056583; // weak
__int64 qword_805658B; // weak
char byte_8056593; // weak
char byte_8056594; // weak
char byte_8056595; // weak
char byte_8056596; // weak
char byte_8056597; // weak
int dword_805659B; // weak
char byte_805659F; // weak
int dword_80565A3; // weak
int dword_80565B3; // weak
int dword_80565BB; // weak
int dword_80565BF; // weak
int dword_80565C3; // weak
int dword_80565C7; // weak
int dword_80565CB; // weak
int dword_80565CF; // weak
int dword_80565D3; // weak
int dword_80565D7; // weak
int dword_80565DB; // weak
int dword_80565DF; // weak
int dword_80565E3; // weak
int dword_80565E7; // weak
_UNKNOWN unk_80565FB; // weak
int dword_80566FB; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (08048E64) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 8049310: using guessed type int _gmon_start__(void);

//----- (08048E90) --------------------------------------------------------
int sub_8048E90()
{
  return dword_8056008();
}
// 8056008: using guessed type int (*dword_8056008)(void);

//----- (08049320) --------------------------------------------------------
#error "8049323: positive sp value has been found (funcsize=2)"

//----- (08049353) --------------------------------------------------------
void sub_8049353()
{
  ;
}

//----- (08049370) --------------------------------------------------------
void sub_8049370()
{
  ;
}

//----- (08049380) --------------------------------------------------------
int sub_8049380()
{
  int result; // eax

  result = &unk_805620F - &unk_805620C;
  if ( (unsigned int)(&unk_805620F - &unk_805620C) > 6 )
    result = 0;
  return result;
}
// 8049380: could not find valid save-restore pair for ebp

//----- (080493F0) --------------------------------------------------------
int sub_80493F0()
{
  int result; // eax

  if ( !byte_805628C )
  {
    result = sub_8049380();
    byte_805628C = 1;
  }
  return result;
}
// 80493F0: could not find valid save-restore pair for ebp
// 805628C: using guessed type char byte_805628C;

//----- (08049410) --------------------------------------------------------
int sub_8049410()
{
  return 0;
}
// 8049410: could not find valid save-restore pair for ebp

//----- (0804946F) --------------------------------------------------------
void sub_804946F()
{
  ;
}

//----- (0804948A) --------------------------------------------------------
void sub_804948A()
{
  ;
}

//----- (0804949A) --------------------------------------------------------
signed int sub_804949A()
{
  return 3;
}
// 804949A: could not find valid save-restore pair for ebp

//----- (0804957C) --------------------------------------------------------
void sub_804957C()
{
  ;
}

//----- (08049597) --------------------------------------------------------
void sub_8049597()
{
  ;
}

//----- (080495A7) --------------------------------------------------------
int sub_80495A7()
{
  int result; // eax

  result = &unk_8056203 - &unk_8056200;
  if ( (unsigned int)(&unk_8056203 - &unk_8056200) > 6 )
    result = 0;
  return result;
}
// 80495A7: could not find valid save-restore pair for ebp

//----- (080495ED) --------------------------------------------------------
int sub_80495ED()
{
  int result; // eax

  result = sub_80495A7();
  byte_8056366 = 1;
  return result;
}
// 8056366: using guessed type char byte_8056366;

//----- (080496B5) --------------------------------------------------------
void sub_80496B5()
{
  ;
}

//----- (080496D0) --------------------------------------------------------
void sub_80496D0()
{
  ;
}

//----- (080496E0) --------------------------------------------------------
int sub_80496E0()
{
  int result; // eax

  result = &unk_80561FB - &unk_80561F8;
  if ( (unsigned int)(&unk_80561FB - &unk_80561F8) > 6 )
    result = 0;
  return result;
}
// 80496E0: could not find valid save-restore pair for ebp

//----- (080497C2) --------------------------------------------------------
void sub_80497C2()
{
  ;
}

//----- (080497DD) --------------------------------------------------------
void sub_80497DD()
{
  ;
}

//----- (080497ED) --------------------------------------------------------
int sub_80497ED()
{
  int result; // eax

  result = &unk_80561FB - &unk_80561F8;
  if ( (unsigned int)(&unk_80561FB - &unk_80561F8) > 6 )
    result = 0;
  return result;
}
// 80497ED: could not find valid save-restore pair for ebp

//----- (0804984B) --------------------------------------------------------
int sub_804984B()
{
  return nullsub_3();
}
// 804984B: could not find valid save-restore pair for ebp
// 804984A: using guessed type int nullsub_3(void);

//----- (080498FB) --------------------------------------------------------
void sub_80498FB()
{
  ;
}

//----- (08049916) --------------------------------------------------------
void sub_8049916()
{
  ;
}

//----- (08049926) --------------------------------------------------------
signed int sub_8049926()
{
  return 3;
}
// 8049926: could not find valid save-restore pair for ebp

//----- (08049A08) --------------------------------------------------------
void sub_8049A08()
{
  ;
}

//----- (08049A23) --------------------------------------------------------
void sub_8049A23()
{
  ;
}

//----- (08049A33) --------------------------------------------------------
int sub_8049A33()
{
  int result; // eax

  result = &unk_80561FF - &unk_80561FC;
  if ( (unsigned int)(&unk_80561FF - &unk_80561FC) > 6 )
    result = 0;
  return result;
}
// 8049A33: could not find valid save-restore pair for ebp

//----- (08049AE5) --------------------------------------------------------
int __usercall sub_8049AE5@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  a1(&dword_8053F0C);
  return 0;
}
// 8053F0C: using guessed type int dword_8053F0C;

//----- (08049B31) --------------------------------------------------------
void sub_8049B31()
{
  ;
}

//----- (08049B4C) --------------------------------------------------------
void sub_8049B4C()
{
  ;
}

//----- (08049B5C) --------------------------------------------------------
int sub_8049B5C()
{
  int result; // eax

  result = &unk_80561F8 - (_UNKNOWN *)&off_8056208;
  if ( (unsigned int)(&unk_80561F8 - (_UNKNOWN *)&off_8056208) > 6 )
    result = 0;
  return result;
}
// 8049B5C: could not find valid save-restore pair for ebp
// 8056208: using guessed type void (__noreturn *off_8056208)();

//----- (08049C31) --------------------------------------------------------
int __cdecl sub_8049C31(unsigned __int8 a1)
{
  return a1;
}

//----- (08049C43) --------------------------------------------------------
int sub_8049C43()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nWith no FILE, or when FILE is -, read standard input.\n");
  return fputs_unlocked(v1, v0);
}
// 8049130: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (08049C6E) --------------------------------------------------------
#error "8049C9F: call analysis failed (funcsize=16)"

//----- (08049CA4) --------------------------------------------------------
#error "8049E22: positive sp value has been found (funcsize=0)"

//----- (08049E25) --------------------------------------------------------
int __cdecl sub_8049E25(int a1)
{
  return (*(_DWORD *)(a1 + 16) & 0xF000) == 0x8000 || (*(_DWORD *)(a1 + 16) & 0xF000) == 40960;
}

//----- (08049E5D) --------------------------------------------------------
#error "8049E7F: call analysis failed (funcsize=27)"

//----- (08049F93) --------------------------------------------------------
unsigned int __usercall sub_8049F93@<eax>(int a1@<edi>, int a2@<esi>, unsigned __int64 a3, unsigned __int64 a4, unsigned __int64 a5, unsigned __int64 a6, unsigned __int64 a7, char *a8)
{
  void *v8; // eax
  __int64 v10; // [esp+0h] [ebp-68h]
  int v11; // [esp+8h] [ebp-60h]
  char *s; // [esp+14h] [ebp-54h]
  unsigned __int64 v13; // [esp+18h] [ebp-50h]
  unsigned __int64 v14; // [esp+20h] [ebp-48h]
  unsigned __int64 v15; // [esp+28h] [ebp-40h]
  unsigned __int64 v16; // [esp+30h] [ebp-38h]
  unsigned __int64 v17; // [esp+38h] [ebp-30h]
  char *format; // [esp+40h] [ebp-28h]
  char v19; // [esp+47h] [ebp-21h]
  unsigned int v20; // [esp+5Ch] [ebp-Ch]

  v17 = a3;
  v16 = a4;
  v15 = a5;
  v14 = a6;
  v13 = a7;
  s = a8;
  v20 = __readgsdword(0x14u);
  format = "%*s";
  if ( byte_8056593 )
  {
    v11 = sub_804C58F(a1, a2, v17, (int)&v19);
    HIDWORD(v10) = dword_805659B;
    printf(format, dword_805659B, v11);
    format = " %*s";
  }
  if ( byte_8056594 )
  {
    v11 = sub_804C58F(a1, a2, v16, (int)&v19);
    HIDWORD(v10) = dword_805659B;
    printf(format, dword_805659B, v11);
    format = " %*s";
  }
  if ( byte_8056595 )
  {
    v11 = sub_804C58F(a1, a2, v15, (int)&v19);
    HIDWORD(v10) = dword_805659B;
    printf(format, dword_805659B, v11);
    format = " %*s";
  }
  if ( byte_8056596 )
  {
    v11 = sub_804C58F(a1, a2, v14, (int)&v19);
    HIDWORD(v10) = dword_805659B;
    printf(format, dword_805659B, v11);
    format = " %*s";
  }
  if ( byte_8056597 )
  {
    v11 = sub_804C58F(a1, a2, v13, (int)&v19);
    HIDWORD(v10) = dword_805659B;
    printf(format, dword_805659B, v11);
  }
  if ( s )
  {
    if ( strchr(s, 10) )
      v8 = sub_804E2E6(0, 3, s);
    else
      v8 = s;
    HIDWORD(v10) = v8;
    printf(" %s", v8);
  }
  putchar_unlocked(10);
  return __readgsdword(0x14u) ^ v20;
}
// 8056593: using guessed type char byte_8056593;
// 8056594: using guessed type char byte_8056594;
// 8056595: using guessed type char byte_8056595;
// 8056596: using guessed type char byte_8056596;
// 8056597: using guessed type char byte_8056597;
// 805659B: using guessed type int dword_805659B;

//----- (0804A1B6) --------------------------------------------------------
int __usercall sub_804A1B6@<eax>(const unsigned __int16 *a1@<edi>, unsigned int a2@<esi>, int fd, int a4, int a5, int a6, int a7)
{
  char *v7; // eax
  bool v8; // al
  bool v9; // al
  void *v10; // eax
  void *v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // edx
  __int64 v15; // rax
  __int64 v16; // rax
  int v17; // edx
  void *v18; // ebx
  int v19; // eax
  void *v20; // ebx
  int v21; // eax
  _BYTE *v22; // eax
  void *v23; // eax
  bool v24; // zf
  void *v25; // eax
  void *v26; // eax
  void *v27; // ebx
  int v28; // eax
  size_t v29; // eax
  void *v30; // ebx
  int v31; // eax
  char *v32; // eax
  const unsigned __int16 *v33; // edi
  void *v34; // eax
  int v36; // [esp-38h] [ebp-4108h]
  int v37; // [esp-34h] [ebp-4104h]
  int v38; // [esp-30h] [ebp-4100h]
  void *v39; // [esp-2Ch] [ebp-40FCh]
  int v40; // [esp-28h] [ebp-40F8h]
  int v41; // [esp-24h] [ebp-40F4h]
  int v42; // [esp-20h] [ebp-40F0h]
  int v43; // [esp-1Ch] [ebp-40ECh]
  int v44; // [esp-18h] [ebp-40E8h]
  int v45; // [esp-14h] [ebp-40E4h]
  int v46; // [esp-10h] [ebp-40E0h]
  int v47; // [esp-Ch] [ebp-40DCh]
  int v48; // [esp-8h] [ebp-40D8h]
  int v49; // [esp-4h] [ebp-40D4h]
  int v50; // [esp+0h] [ebp-40D0h]
  int v51; // [esp+4h] [ebp-40CCh]
  __int64 v52; // [esp+8h] [ebp-40C8h]
  int *v53; // [esp+10h] [ebp-40C0h]
  char *v54; // [esp+14h] [ebp-40BCh]
  int v55; // [esp+18h] [ebp-40B8h]
  int v56; // [esp+1Ch] [ebp-40B4h]
  int v57; // [esp+20h] [ebp-40B0h]
  char v58; // [esp+24h] [ebp-40ACh]
  unsigned __int8 v59; // [esp+25h] [ebp-40ABh]
  char v60; // [esp+26h] [ebp-40AAh]
  bool i; // [esp+27h] [ebp-40A9h]
  int v62; // [esp+28h] [ebp-40A8h]
  wint_t wc; // [esp+2Ch] [ebp-40A4h]
  size_t n; // [esp+30h] [ebp-40A0h]
  void *s; // [esp+34h] [ebp-409Ch]
  int v66; // [esp+38h] [ebp-4098h]
  char *v67; // [esp+44h] [ebp-408Ch]
  char *v68; // [esp+48h] [ebp-4088h]
  unsigned int v69; // [esp+4Ch] [ebp-4084h]
  char *v70; // [esp+50h] [ebp-4080h]
  unsigned __int64 v71; // [esp+58h] [ebp-4078h]
  unsigned __int64 v72; // [esp+60h] [ebp-4070h]
  unsigned __int64 v73; // [esp+68h] [ebp-4068h]
  unsigned __int64 v74; // [esp+70h] [ebp-4060h]
  unsigned __int64 v75; // [esp+78h] [ebp-4058h]
  unsigned __int64 v76; // [esp+80h] [ebp-4050h]
  unsigned __int64 v77; // [esp+88h] [ebp-4048h]
  __int64 v78; // [esp+90h] [ebp-4040h]
  unsigned __int64 v79; // [esp+98h] [ebp-4038h]
  mbstate_t ps; // [esp+A0h] [ebp-4030h]
  char dest[16385]; // [esp+B3h] [ebp-401Dh]
  unsigned int v82; // [esp+40B4h] [ebp-1Ch]

  v54 = (char *)a4;
  v53 = (int *)a5;
  v52 = __PAIR__(a7, a6);
  v82 = __readgsdword(0x14u);
  HIBYTE(v57) = 1;
  if ( a4 )
    v7 = v54;
  else
    v7 = gettext("standard input");
  v68 = v7;
  v75 = 0LL;
  v74 = 0LL;
  v73 = 0LL;
  v72 = 0LL;
  v71 = 0LL;
  if ( __ctype_get_mb_cur_max() <= 1 )
  {
    v8 = byte_8056596 || byte_8056595;
    v58 = v8;
    v59 = 0;
  }
  else
  {
    v58 = byte_8056596;
    v59 = byte_8056595;
  }
  v9 = byte_8056594 || byte_8056597;
  HIBYTE(v62) = v9;
  if ( v58 == 1 && !v59 && !byte_8056593 )
  {
    v10 = &loc_804A37E;
    if ( !HIBYTE(v62) )
      v10 = &loc_804A3B1;
    dword_8056154 = (int)v10;
    sub_80510DD();
  }
  sub_804C4E6(fd, 0, 0, 0, 0, 2);
  if ( !v58 || v59 == 1 )
    goto LABEL_106;
  v11 = &loc_804A3F7;
  if ( byte_8056593 == 1 )
    v11 = &loc_804A70F;
  dword_8056134 = (int)v11;
  sub_80511B7(
    v36,
    v37,
    v38,
    v39,
    v40,
    v41,
    v42,
    v43,
    v44,
    v45,
    v46,
    v47,
    v48,
    v49,
    v50,
    v51,
    v52,
    HIDWORD(v52),
    v53,
    v54,
    v55,
    v56,
    v57,
    *(_DWORD *)&v58,
    v62,
    wc,
    n);
  if ( HIBYTE(v62) != 1 )
  {
    v60 = 0;
    if ( *v53 > 0 )
    {
      v12 = sub_8050EEC(fd, (int)(v53 + 1));
      *v53 = v12;
    }
    if ( !*v53 )
    {
      if ( (unsigned __int8)sub_8049E25((int)(v53 + 1)) )
      {
        v13 = v53[12];
        if ( v53[13] >= 0 )
        {
          v14 = v53[13];
          v69 = v53[12];
          if ( v52 < 0 )
          {
            LODWORD(v15) = lseek64(fd, 0, 0, 1, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49);
            v52 = v15;
          }
          if ( v69 % dword_80565A3 )
          {
            if ( v69 < v52 )
              v16 = 0LL;
            else
              v16 = v69 - v52;
            v74 = v16;
            v60 = 1;
          }
          else
          {
            if ( v53[14] <= 0 || (unsigned int)v53[14] > 0x20000000 )
              a2 = 513;
            else
              a2 = v53[14] + 1;
            v78 = v69 - v69 % a2;
            if ( v52 >= 0 && v52 < v78 )
            {
              lseek64(fd, v78, HIDWORD(v78), 1, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49);
              if ( v17 >= 0 )
                v74 = v78 - v52;
            }
          }
        }
      }
    }
    if ( v60 != 1 )
    {
      sub_804C4E6(fd, 0, 0, 0, 0, 2);
      while ( 1 )
      {
        n = sub_804ED4F(fd, dest, 0x4000u);
        if ( !n )
          break;
        if ( n == -1 )
        {
          v18 = sub_804E2E6(0, 3, v68);
          v19 = *__errno_location();
          v39 = v18;
          error(0, v19, "%s", v18);
          HIBYTE(v57) = 0;
          break;
        }
        v74 += n;
      }
    }
  }
  else
  {
LABEL_106:
    if ( v59 != 1 && HIBYTE(v62) != 1 )
    {
      for ( i = 0; ; i = v71 - v79 <= n / 0xF )
      {
        n = sub_804ED4F(fd, dest, 0x4000u);
        if ( !n )
          break;
        if ( n == -1 )
        {
          v20 = sub_804E2E6(0, 3, v68);
          v21 = *__errno_location();
          v39 = v20;
          error(0, v21, "%s");
          HIBYTE(v57) = 0;
          dword_8056168 = (int)&loc_804A94F;
          sub_805104D();
        }
        v74 += n;
        s = dest;
        v70 = &dest[n];
        v79 = v71;
        if ( i == 1 )
        {
          v23 = memchr(s, 10, v70 - (_BYTE *)s);
          s = v23;
          v24 = v23 == 0;
          v25 = &loc_804A8BC;
          if ( !v24 )
            v25 = &loc_804A855;
          dword_8056154 = (int)v25;
          sub_80510DD();
        }
        else
        {
          while ( s != v70 )
          {
            v22 = s;
            s = (char *)s + 1;
            v71 += *v22 == 10;
          }
        }
      }
      dword_8056154 = (int)&loc_804B0E4;
      sub_80510DD();
    }
    if ( __ctype_get_mb_cur_max() <= 1 )
    {
      BYTE2(v62) = 0;
      v77 = 0LL;
      dword_8056134 = (int)&loc_804B060;
      sub_80511B7(
        v36,
        v37,
        v38,
        v39,
        v40,
        v41,
        v42,
        v43,
        v44,
        v45,
        v46,
        v47,
        v48,
        v49,
        v50,
        v51,
        v52,
        HIDWORD(v52),
        v53,
        v54,
        v55,
        v56,
        v57,
        *(_DWORD *)&v58,
        v62,
        wc,
        n);
      while ( 1 )
      {
        v67 = dest;
        if ( n == -1 )
          break;
        v74 += n;
        while ( 2 )
        {
          v32 = v67++;
          switch ( *v32 )
          {
            case 9:
              a2 = HIDWORD(v77);
              v77 = __PAIR__(HIDWORD(v77), (unsigned int)v77 & 0xFFFFFFF8) + 8;
              goto LABEL_89;
            case 10:
              ++v71;
              goto LABEL_84;
            case 11:
              goto LABEL_89;
            case 12:
            case 13:
LABEL_84:
              if ( v77 > v75 )
                v75 = v77;
              v77 = 0LL;
              goto LABEL_89;
            case 32:
              ++v77;
              goto LABEL_89;
            default:
              v33 = *__ctype_b_loc();
              v36 = *(v67 - 1);
              v24 = (v33[(unsigned __int8)sub_8049C31(v36)] & 0x4000) == 0;
              v34 = &loc_804AFFC;
              if ( v24 )
                v34 = &loc_804B04C;
              dword_8056168 = (int)v34;
              sub_805104D();
              ++v77;
              a1 = *__ctype_b_loc();
              v36 = *(v67 - 1);
              if ( a1[(unsigned __int8)sub_8049C31(v36)] & 0x2000 )
              {
LABEL_89:
                v72 += BYTE2(v62);
                BYTE2(v62) = 0;
              }
              else
              {
                BYTE2(v62) = 1;
              }
              if ( --n )
                continue;
              n = sub_804ED4F(fd, dest, 0x4000u);
              if ( !n )
                goto LABEL_96;
              break;
          }
          break;
        }
      }
      v30 = sub_804E2E6(0, 3, v68);
      v31 = *__errno_location();
      v39 = v30;
      error(0, v31, "%s", v30);
      HIBYTE(v57) = 0;
LABEL_96:
      if ( v77 > v75 )
        v75 = v77;
      v72 += BYTE2(v62);
    }
    else
    {
      LOWORD(v62) = 0;
      v76 = 0LL;
      ps.__count = 0;
      ps.__wch = 0;
      v66 = 0;
      v29 = sub_804ED4F(fd, dest, 0x4000u);
      n = v29;
      if ( v29 )
      {
        v26 = &loc_804A9DB;
        if ( n != -1 )
          v26 = &loc_804AA2A;
        dword_8056134 = (int)v26;
        sub_80511B7(
          v36,
          v37,
          v38,
          v39,
          v40,
          v41,
          v42,
          v43,
          v44,
          v45,
          v46,
          v47,
          v48,
          v49,
          v50,
          v51,
          v52,
          HIDWORD(v52),
          v53,
          v54,
          v55,
          v56,
          v57,
          *(_DWORD *)&v58,
          v62,
          wc,
          n);
        v27 = sub_804E2E6(0, 3, v68);
        v28 = *__errno_location();
        v39 = v27;
        error(0, v28, "%s", v27);
        HIBYTE(v57) = 0;
      }
      if ( v76 > v75 )
        v75 = v76;
      v72 += (unsigned __int8)v62;
    }
  }
  if ( v59 < (signed int)(unsigned __int8)byte_8056595 )
    v73 = v74;
  sub_8049F93((int)a1, a2, v71, v72, v73, v74, v75, v54);
  qword_805656B += v71;
  qword_8056573 += v72;
  qword_805657B += v73;
  qword_8056583 += v74;
  if ( v75 > qword_805658B )
    qword_805658B = v75;
  return HIBYTE(v57);
}
// 8049260: using guessed type int __stdcall lseek64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 805104D: using guessed type int sub_805104D(void);
// 80510DD: using guessed type int sub_80510DD(void);
// 80511B7: using guessed type int __stdcall sub_80511B7(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8056134: using guessed type int dword_8056134;
// 8056154: using guessed type int dword_8056154;
// 8056168: using guessed type int dword_8056168;
// 805656B: using guessed type __int64 qword_805656B;
// 8056573: using guessed type __int64 qword_8056573;
// 805657B: using guessed type __int64 qword_805657B;
// 8056583: using guessed type __int64 qword_8056583;
// 805658B: using guessed type __int64 qword_805658B;
// 8056593: using guessed type char byte_8056593;
// 8056594: using guessed type char byte_8056594;
// 8056595: using guessed type char byte_8056595;
// 8056596: using guessed type char byte_8056596;
// 8056597: using guessed type char byte_8056597;
// 80565A3: using guessed type int dword_80565A3;
// 804A1B6: using guessed type char dest[16385];

//----- (0804B29C) --------------------------------------------------------
int __usercall sub_804B29C@<eax>(const unsigned __int16 *a1@<edi>, unsigned int a2@<esi>, char *s1, int a4)
{
  int result; // eax
  void *v5; // ebx
  int *v6; // eax
  void *v7; // ebx
  int *v8; // eax
  unsigned __int8 v9; // [esp+2Bh] [ebp-Dh]
  int fd; // [esp+2Ch] [ebp-Ch]

  if ( s1 && strcmp(s1, "-") )
  {
    fd = open64(s1, 0);
    if ( fd == -1 )
    {
      v5 = sub_804E2E6(0, 3, s1);
      v6 = __errno_location();
      error(0, *v6, "%s", v5);
      result = 0;
    }
    else
    {
      v9 = sub_804A1B6(a1, a2, fd, (int)s1, a4, 0, 0);
      if ( close(fd) )
      {
        v7 = sub_804E2E6(0, 3, s1);
        v8 = __errno_location();
        error(0, *v8, "%s", v7);
        result = 0;
      }
      else
      {
        result = v9;
      }
    }
  }
  else
  {
    byte_805659F = 1;
    sub_804F83B();
    result = sub_804A1B6(a1, a2, 0, (int)s1, a4, -1, -1);
  }
  return result;
}
// 8048EB0: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 805659F: using guessed type char byte_805659F;

//----- (0804B411) --------------------------------------------------------
_DWORD *__cdecl sub_804B411(unsigned int a1, int a2)
{
  unsigned int v2; // eax
  int *v3; // ebx
  int v4; // eax
  int v5; // eax
  _DWORD *v7; // [esp+4h] [ebp-24h]
  unsigned int i; // [esp+18h] [ebp-10h]
  _DWORD *v9; // [esp+1Ch] [ebp-Ch]

  if ( a1 )
    v2 = a1;
  else
    v2 = 1;
  v9 = (_DWORD *)sub_804F538(v2, 0x64u);
  if ( !a1
    || a1 == 1
    && (unsigned __int8)byte_8056596
     + (unsigned __int8)byte_8056595
     + (unsigned __int8)byte_8056594
     + (unsigned __int8)byte_8056593
     + (unsigned __int8)byte_8056597 == 1 )
  {
    *v9 = 1;
    dword_8056154 = (int)&loc_804B5A9;
    sub_80510DD();
  }
  for ( i = 0; i < a1; ++i )
  {
    v3 = &v9[25 * i];
    if ( *(_DWORD *)(4 * i + a2) && strcmp(*(const char **)(4 * i + a2), "-") )
    {
      v5 = *(_DWORD *)(4 * i + a2);
      v7 = &v9[25 * i + 1];
      v4 = sub_8050EAD(v5, (int)v7);
    }
    else
    {
      v7 = &v9[25 * i + 1];
      v4 = sub_8050EEC(0, (int)v7);
    }
    *v3 = v4;
  }
  return v9;
}
// 80510DD: using guessed type int sub_80510DD(void);
// 8056154: using guessed type int dword_8056154;
// 8056593: using guessed type char byte_8056593;
// 8056594: using guessed type char byte_8056594;
// 8056595: using guessed type char byte_8056595;
// 8056596: using guessed type char byte_8056596;
// 8056597: using guessed type char byte_8056597;

//----- (0804B5B2) --------------------------------------------------------
#error "804B5E6: call analysis failed (funcsize=89)"

//----- (0804C121) --------------------------------------------------------
_DWORD *__cdecl sub_804C121(int a1)
{
  _DWORD *v2; // [esp+1Ch] [ebp-Ch]

  v2 = malloc(0x18u);
  if ( !v2 )
    return 0;
  *v2 = 0;
  v2[4] = a1;
  v2[5] = a1;
  return v2;
}

//----- (0804C18B) --------------------------------------------------------
_DWORD *__cdecl sub_804C18B(int a1)
{
  _DWORD *v2; // [esp+1Ch] [ebp-Ch]

  v2 = malloc(0x18u);
  if ( !v2 )
    return 0;
  *v2 = a1;
  v2[2] = 0;
  v2[3] = 0;
  v2[1] = 0;
  v2[4] = 0;
  return v2;
}

//----- (0804C1F2) --------------------------------------------------------
int __cdecl sub_804C1F2(int *a1, signed int *a2)
{
  signed int v2; // eax
  int result; // eax
  int *v4; // eax
  FILE *v5; // [esp+0h] [ebp-28h]
  FILE *v6; // [esp+Ch] [ebp-1Ch]
  int v7; // [esp+1Ch] [ebp-Ch]

  if ( *a1 )
  {
    v6 = (FILE *)*a1;
    v7 = getdelim(a1 + 2, a1 + 3, 0, v6);
    if ( v7 >= 0 )
    {
      *a2 = 1;
      ++a1[1];
      result = a1[2];
    }
    else
    {
      v5 = (FILE *)*a1;
      if ( feof(v5) )
        v2 = 2;
      else
        v2 = 4;
      *a2 = v2;
      result = 0;
    }
  }
  else if ( *(_DWORD *)a1[5] )
  {
    *a2 = 1;
    v4 = (int *)a1[5];
    a1[5] = (int)(v4 + 1);
    result = *v4;
  }
  else
  {
    *a2 = 2;
    result = 0;
  }
  return result;
}
// 8049250: using guessed type int __cdecl getdelim(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804C2D8) --------------------------------------------------------
int __cdecl sub_804C2D8(_DWORD *a1)
{
  int result; // eax

  if ( *a1 )
    result = a1[1];
  else
    result = (a1[5] - a1[4]) >> 2;
  return result;
}

//----- (0804C327) --------------------------------------------------------
#error "804C366: positive sp value has been found (funcsize=15)"

//----- (0804C4E6) --------------------------------------------------------
int __cdecl sub_804C4E6(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // [esp+20h] [ebp-28h]
  int v8; // [esp+24h] [ebp-24h]
  int v9; // [esp+28h] [ebp-20h]
  int v10; // [esp+2Ch] [ebp-1Ch]

  v9 = a2;
  v10 = a3;
  v7 = a4;
  v8 = a5;
  return posix_fadvise64(a1, a2, a3, a4, a5, a6);
}
// 8049280: using guessed type int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804C58F) --------------------------------------------------------
int __usercall sub_804C58F@<eax>(int a1@<edi>, int a2@<esi>, unsigned __int64 a3, int a4)
{
  unsigned __int64 v4; // rax
  unsigned __int64 v6; // [esp+18h] [ebp-20h]
  int v7; // [esp+2Ch] [ebp-Ch]

  v6 = a3;
  v7 = a4 + 20;
  *(_BYTE *)(a4 + 20) = 0;
  do
  {
    *(_BYTE *)--v7 = sub_8050C8B(v6, 10LL) + 48;
    LODWORD(v4) = sub_8050A5C(a1, a2, v6, SHIDWORD(v6), 0xAu, 0);
    v6 = v4;
  }
  while ( v4 );
  return v7;
}

//----- (0804C6FD) --------------------------------------------------------
bool __cdecl sub_804C6FD(unsigned __int8 a1)
{
  return (((unsigned int)dword_8051BC0[a1 >> 5] >> (a1 & 0x1F)) & 1) != 0;
}

//----- (0804C744) --------------------------------------------------------
long double sub_804C744()
{
  double v1; // [esp+18h] [ebp-60h]
  double v2; // [esp+20h] [ebp-58h]
  char v3; // [esp+2Ch] [ebp-4Ch]
  unsigned int v4; // [esp+3Ch] [ebp-3Ch]
  unsigned int v5; // [esp+60h] [ebp-18h]
  unsigned int v6; // [esp+6Ch] [ebp-Ch]

  v6 = __readgsdword(0x14u);
  v1 = (long double)sysconf(85);
  v2 = (long double)sysconf(30);
  if ( v1 >= 0.0 && v2 >= 0.0 )
    return v1 * v2;
  if ( sysinfo((struct sysinfo *)&v3) )
    return 67108864.0;
  return (long double)v4 * (long double)v5;
}

//----- (0804C80D) --------------------------------------------------------
long double sub_804C80D()
{
  double v1; // [esp+18h] [ebp-60h]
  double v2; // [esp+20h] [ebp-58h]
  char v3; // [esp+2Ch] [ebp-4Ch]
  unsigned int v4; // [esp+40h] [ebp-38h]
  unsigned int v5; // [esp+48h] [ebp-30h]
  unsigned int v6; // [esp+60h] [ebp-18h]
  unsigned int v7; // [esp+6Ch] [ebp-Ch]

  v7 = __readgsdword(0x14u);
  v1 = (long double)sysconf(86);
  v2 = (long double)sysconf(30);
  if ( v1 >= 0.0 && v2 >= 0.0 )
    return v1 * v2;
  if ( sysinfo((struct sysinfo *)&v3) )
    return sub_804C744() / 4.0;
  return ((long double)v4 + (long double)v5) * (long double)v6;
}

//----- (0804C8E4) --------------------------------------------------------
char *__cdecl sub_804C8E4(char *s)
{
  char *v1; // eax
  char *result; // eax
  char *v3; // [esp+18h] [ebp-10h]
  char *s1; // [esp+1Ch] [ebp-Ch]

  if ( !s )
  {
    fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
    abort();
  }
  v3 = strrchr(s, 47);
  if ( v3 )
    v1 = v3 + 1;
  else
    v1 = s;
  s1 = v1;
  if ( v1 - s > 6 && !strncmp(v1 - 7, "/.libs/", 7u) )
  {
    s = s1;
    if ( !strncmp(s1, "lt-", 3u) )
    {
      s = s1 + 3;
      program_invocation_short_name = (int)(s1 + 3);
    }
  }
  dword_80565B3 = (int)s;
  result = s;
  program_invocation_name = (int)s;
  return result;
}
// 8056220: using guessed type int program_invocation_short_name;
// 8056230: using guessed type int program_invocation_name;
// 80565B3: using guessed type int dword_80565B3;

//----- (0804CA30) --------------------------------------------------------
int __fastcall sub_804CA30(int ecx0, int edx0, int a1, char a2, int a3)
{
  dword_8056184 = (int (__fastcall *)(_DWORD, _DWORD))&loc_804CA94;
  if ( a1 )
    dword_8056184 = (int (__fastcall *)(_DWORD, _DWORD))&loc_804CA99;
  return dword_8056184(ecx0, edx0);
}
// 8056184: using guessed type int (__fastcall *dword_8056184)(_DWORD, _DWORD);

//----- (0804CB4F) --------------------------------------------------------
int *__cdecl sub_804CB4F(int *a1, int a2, int a3)
{
  int *result; // eax

  if ( !a1 )
    a1 = &dword_80565BB;
  *a1 = 10;
  if ( !a2 || !a3 )
    abort();
  a1[10] = a2;
  result = a1;
  a1[11] = a3;
  return result;
}
// 80565BB: using guessed type int dword_80565BB;

//----- (0804CBB0) --------------------------------------------------------
int *__userpurge sub_804CBB0@<eax>(int *a1, int a2)
{
  int v3; // [esp+0h] [ebp-38h]
  int v4; // [esp+4h] [ebp-34h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]

  memset(&v3 - 14, 0, 0x30u);
  if ( a2 == 10 )
    abort();
  v3 = a2;
  *a1 = a2;
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = v6;
  a1[4] = v7;
  a1[5] = v8;
  a1[6] = v9;
  a1[7] = v10;
  a1[8] = v11;
  a1[9] = v12;
  a1[10] = v13;
  a1[11] = v14;
  return a1;
}

//----- (0804CC66) --------------------------------------------------------
#error "804CD08: call analysis failed (funcsize=54)"

//----- (0804CD21) --------------------------------------------------------
unsigned int __usercall sub_804CD21@<eax>(size_t a1@<ebx>, int a2, unsigned int a3, char *a4, size_t a5, signed int a6, int a7, int a8, char *a9, char *a10)
{
  void *v10; // eax
  void *v11; // eax
  size_t v12; // eax
  int v13; // eax
  bool v14; // al
  size_t v15; // eax
  void *v16; // eax
  void *v17; // eax
  int v18; // eax
  void *v19; // eax
  unsigned int result; // eax
  size_t v21; // [esp-34h] [ebp-90h]
  int v22; // [esp-30h] [ebp-8Ch]
  int v23; // [esp-2Ch] [ebp-88h]
  int v24; // [esp-28h] [ebp-84h]
  size_t v25; // [esp-24h] [ebp-80h]
  int v26; // [esp-20h] [ebp-7Ch]
  int v27; // [esp-1Ch] [ebp-78h]
  int v28; // [esp-18h] [ebp-74h]
  int v29; // [esp-14h] [ebp-70h]
  int v30; // [esp-10h] [ebp-6Ch]
  int v31; // [esp-Ch] [ebp-68h]
  int v32; // [esp-8h] [ebp-64h]
  int v33; // [esp-4h] [ebp-60h]
  char *v34; // [esp+0h] [ebp-5Ch]
  char *v35; // [esp+4h] [ebp-58h]
  int v36; // [esp+8h] [ebp-54h]
  char *v37; // [esp+Ch] [ebp-50h]
  int v38; // [esp+10h] [ebp-4Ch]
  char v39; // [esp+14h] [ebp-48h]
  bool v40; // [esp+15h] [ebp-47h]
  char v41; // [esp+16h] [ebp-46h]
  char v42; // [esp+17h] [ebp-45h]
  char v43; // [esp+18h] [ebp-44h]
  unsigned __int8 v44; // [esp+19h] [ebp-43h]
  unsigned __int8 v45; // [esp+1Ah] [ebp-42h]
  unsigned __int8 v46; // [esp+1Bh] [ebp-41h]
  char v47; // [esp+1Ch] [ebp-40h]
  bool v48; // [esp+1Dh] [ebp-3Fh]
  bool v49; // [esp+1Eh] [ebp-3Eh]
  bool v50; // [esp+1Fh] [ebp-3Dh]
  wint_t wc; // [esp+20h] [ebp-3Ch]
  int v52; // [esp+24h] [ebp-38h]
  unsigned int v53; // [esp+28h] [ebp-34h]
  unsigned int v54; // [esp+2Ch] [ebp-30h]
  char *s; // [esp+30h] [ebp-2Ch]
  size_t n; // [esp+34h] [ebp-28h]
  unsigned int v57; // [esp+38h] [ebp-24h]
  int v58; // [esp+3Ch] [ebp-20h]
  size_t v59; // [esp+40h] [ebp-1Ch]
  unsigned int v60; // [esp+44h] [ebp-18h]
  mbstate_t ps; // [esp+48h] [ebp-14h]
  unsigned int v62; // [esp+50h] [ebp-Ch]

  v38 = a2;
  v37 = a4;
  v36 = a8;
  v35 = a9;
  v34 = a10;
  v62 = __readgsdword(0x14u);
  v53 = 0;
  v54 = 0;
  s = 0;
  n = 0;
  v39 = 0;
  v50 = __ctype_get_mb_cur_max() == 1;
  v40 = (a7 & 2) != 0;
  v41 = 0;
  v42 = 0;
  v43 = 1;
  while ( 1 )
  {
    switch ( a6 )
    {
      case 0:
        v40 = 0;
        break;
      case 1:
        goto LABEL_20;
      case 2:
        goto LABEL_23;
      case 3:
        v39 = 1;
LABEL_20:
        v40 = 1;
        goto LABEL_21;
      case 4:
LABEL_21:
        if ( v40 != 1 )
          v39 = 1;
LABEL_23:
        a6 = 2;
        if ( v40 != 1 )
        {
          if ( v53 < a3 )
            *(_BYTE *)(v38 + v53) = 39;
          ++v53;
        }
        s = "'";
        n = 1;
        break;
      case 5:
        goto LABEL_4;
      case 6:
        a6 = 5;
        v40 = 1;
LABEL_4:
        v22 = !v40;
        v21 = a1;
        v10 = &loc_804CE02;
        if ( v40 == 1 )
          v10 = &loc_804CE19;
        dword_8056168 = (int)v10;
        a1 = v21;
        sub_805104D();
        if ( v53 < a3 )
          *(_BYTE *)(v38 + v53) = 34;
        ++v53;
        v39 = 1;
        s = (char *)&unk_8051D25;
        n = 1;
        break;
      case 7:
        v39 = 1;
        v40 = 0;
        break;
      case 8:
      case 9:
      case 10:
        if ( a6 != 10 )
        {
          v35 = (char *)sub_804CC66("`", a6);
          v34 = (char *)sub_804CC66("'", a6);
        }
        if ( v40 != 1 )
        {
          for ( s = v35; *s; ++s )
          {
            if ( v53 < a3 )
              *(_BYTE *)(v53 + v38) = *s;
            ++v53;
          }
        }
        v39 = 1;
        s = v34;
        n = strlen(v34);
        break;
      default:
        abort();
        return result;
    }
    v52 = 0;
LABEL_197:
    if ( a5 == -1 )
    {
      v18 = (unsigned __int8)v37[v52];
      LOBYTE(v18) = (_BYTE)v18 != 0;
    }
    else
    {
      v18 = v52;
      LOBYTE(v18) = v52 != a5;
    }
    if ( (_BYTE)v18 )
      break;
    if ( !v53 && a6 == 2 && v40 )
      goto LABEL_223;
    if ( a6 != 2 )
      goto LABEL_229;
    v22 = !v40;
    v21 = a1;
    v19 = &loc_804D8FF;
    if ( v40 == 1 )
      v19 = &loc_804D982;
    dword_8056134 = (int)v19;
    a1 = v21;
    sub_80511B7(
      v23,
      v24,
      v25,
      v26,
      v27,
      v28,
      v29,
      v30,
      v31,
      v32,
      v33,
      v34,
      v35,
      v36,
      v37,
      v38,
      *(_DWORD *)&v39,
      *(_DWORD *)&v43,
      *(_DWORD *)&v47,
      wc,
      v52,
      v53,
      v54,
      s,
      n,
      v57,
      v58);
    if ( !v42 )
      goto LABEL_229;
    if ( v43 )
      return sub_804CD21(v38, v54, v37, a5, 5, a7, v36, v35, v34);
    if ( a3 || !v54 )
    {
LABEL_229:
      if ( s && v40 != 1 )
      {
        while ( *s )
        {
          if ( v53 < a3 )
            *(_BYTE *)(v53 + v38) = *s;
          ++v53;
          ++s;
        }
      }
      if ( v53 < a3 )
        *(_BYTE *)(v38 + v53) = 0;
      return v53;
    }
    a3 = v54;
    v53 = 0;
  }
  v46 = 0;
  v47 = 0;
  v48 = 0;
  if ( v39 )
  {
    v22 = v18;
    v21 = a1;
    v11 = &loc_804CF62;
    if ( a6 == 2 )
      v11 = &loc_804CFC8;
    dword_8056134 = (int)v11;
    a1 = v21;
    sub_80511B7(
      v23,
      v24,
      v25,
      v26,
      v27,
      v28,
      v29,
      v30,
      v31,
      v32,
      v33,
      v34,
      v35,
      v36,
      v37,
      v38,
      *(_DWORD *)&v39,
      *(_DWORD *)&v43,
      *(_DWORD *)&v47,
      wc,
      v52,
      v53,
      v54,
      s,
      n,
      v57,
      v58);
    if ( n )
    {
      a1 = v52 + n;
      if ( a5 != -1 || n <= 1 )
      {
        v12 = a5;
      }
      else
      {
        v12 = strlen(v37);
        a5 = v12;
      }
      if ( a1 <= v12 && !memcmp(&v37[v52], s, n) )
      {
        if ( v40 )
          goto LABEL_223;
        v46 = 1;
      }
    }
  }
  v44 = v37[v52];
  switch ( v44 )
  {
    case 0u:
      if ( v39 )
      {
        if ( v40 )
          goto LABEL_223;
        v47 = 1;
        if ( a6 == 2 && v41 != 1 )
        {
          if ( v53 < a3 )
            *(_BYTE *)(v38 + v53) = 39;
          if ( ++v53 < a3 )
            *(_BYTE *)(v38 + v53) = 36;
          if ( ++v53 < a3 )
            *(_BYTE *)(v38 + v53) = 39;
          ++v53;
          v41 = 1;
        }
        if ( v53 < a3 )
          *(_BYTE *)(v38 + v53) = 92;
        ++v53;
        if ( a6 != 2 && v52 + 1 < a5 && v37[v52 + 1] > 47 && v37[v52 + 1] <= 57 )
        {
          if ( v53 < a3 )
            *(_BYTE *)(v38 + v53) = 48;
          if ( ++v53 < a3 )
            *(_BYTE *)(v38 + v53) = 48;
          ++v53;
        }
        v44 = 48;
      }
      else if ( a7 & 1 )
      {
        goto LABEL_196;
      }
      goto LABEL_176;
    case 7u:
      v45 = 97;
      goto LABEL_104;
    case 8u:
      v45 = 98;
      goto LABEL_104;
    case 9u:
      v45 = 116;
      goto LABEL_102;
    case 0xAu:
      v45 = 110;
      goto LABEL_102;
    case 0xBu:
      v45 = 118;
      goto LABEL_104;
    case 0xCu:
      v45 = 102;
      goto LABEL_104;
    case 0xDu:
      v45 = 114;
      goto LABEL_102;
    case 0x20u:
      goto LABEL_112;
    case 0x21u:
    case 0x22u:
    case 0x24u:
    case 0x26u:
    case 0x28u:
    case 0x29u:
    case 0x2Au:
    case 0x3Bu:
    case 0x3Cu:
    case 0x3Du:
    case 0x3Eu:
    case 0x5Bu:
    case 0x5Eu:
    case 0x60u:
    case 0x7Cu:
      goto LABEL_113;
    case 0x23u:
    case 0x7Eu:
      goto LABEL_111;
    case 0x25u:
    case 0x2Bu:
    case 0x2Cu:
    case 0x2Du:
    case 0x2Eu:
    case 0x2Fu:
    case 0x30u:
    case 0x31u:
    case 0x32u:
    case 0x33u:
    case 0x34u:
    case 0x35u:
    case 0x36u:
    case 0x37u:
    case 0x38u:
    case 0x39u:
    case 0x3Au:
    case 0x41u:
    case 0x42u:
    case 0x43u:
    case 0x44u:
    case 0x45u:
    case 0x46u:
    case 0x47u:
    case 0x48u:
    case 0x49u:
    case 0x4Au:
    case 0x4Bu:
    case 0x4Cu:
    case 0x4Du:
    case 0x4Eu:
    case 0x4Fu:
    case 0x50u:
    case 0x51u:
    case 0x52u:
    case 0x53u:
    case 0x54u:
    case 0x55u:
    case 0x56u:
    case 0x57u:
    case 0x58u:
    case 0x59u:
    case 0x5Au:
    case 0x5Du:
    case 0x5Fu:
    case 0x61u:
    case 0x62u:
    case 0x63u:
    case 0x64u:
    case 0x65u:
    case 0x66u:
    case 0x67u:
    case 0x68u:
    case 0x69u:
    case 0x6Au:
    case 0x6Bu:
    case 0x6Cu:
    case 0x6Du:
    case 0x6Eu:
    case 0x6Fu:
    case 0x70u:
    case 0x71u:
    case 0x72u:
    case 0x73u:
    case 0x74u:
    case 0x75u:
    case 0x76u:
    case 0x77u:
    case 0x78u:
    case 0x79u:
    case 0x7Au:
      v48 = 1;
      goto LABEL_176;
    case 0x27u:
      v42 = 1;
      v48 = 1;
      if ( a6 != 2 )
        goto LABEL_176;
      if ( v40 )
        goto LABEL_223;
      if ( a3 && !v54 )
      {
        v54 = a3;
        a3 = 0;
      }
      if ( v53 < a3 )
        *(_BYTE *)(v38 + v53) = 39;
      if ( ++v53 < a3 )
        *(_BYTE *)(v38 + v53) = 92;
      if ( ++v53 < a3 )
        *(_BYTE *)(v38 + v53) = 39;
      ++v53;
      v41 = 0;
      goto LABEL_176;
    case 0x3Fu:
      if ( a6 == 2 )
      {
        if ( v40 )
          goto LABEL_223;
      }
      else if ( a6 == 5 && a7 & 4 && v52 + 2 < a5 && v37[v52 + 1] == 63 )
      {
        switch ( v37[v52 + 2] )
        {
          case 33:
          case 39:
          case 40:
          case 41:
          case 45:
          case 47:
          case 60:
          case 61:
          case 62:
            if ( v40 )
              goto LABEL_223;
            v44 = v37[v52 + 2];
            v52 += 2;
            if ( v53 < a3 )
              *(_BYTE *)(v38 + v53) = 63;
            if ( ++v53 < a3 )
              *(_BYTE *)(v38 + v53) = 34;
            if ( ++v53 < a3 )
              *(_BYTE *)(v38 + v53) = 34;
            if ( ++v53 < a3 )
              *(_BYTE *)(v38 + v53) = 63;
            ++v53;
            break;
          default:
            goto LABEL_176;
        }
      }
      goto LABEL_176;
    case 0x5Cu:
      v45 = v44;
      if ( a6 == 2 )
      {
        if ( v40 )
          goto LABEL_223;
        goto LABEL_185;
      }
      if ( v39 && v40 && n )
        goto LABEL_185;
LABEL_102:
      if ( a6 == 2 && v40 )
        goto LABEL_223;
LABEL_104:
      if ( !v39 )
      {
        dword_8056154 = (int)&loc_804D71A;
        sub_80510DD();
LABEL_107:
        if ( a5 == -1 )
          v14 = v37[1] != 0;
        else
          v14 = a5 != 1;
        if ( !v14 )
        {
LABEL_111:
          if ( !v52 )
          {
LABEL_112:
            v48 = 1;
LABEL_113:
            if ( a6 == 2 && v40 )
              goto LABEL_223;
          }
        }
LABEL_176:
        if ( v39 == 1 && a6 != 2 || v40 == 1 )
        {
          if ( v36 )
          {
            v13 = (*(_DWORD *)(4 * (v44 >> 5) + v36) >> (v44 & 0x1F)) & 1;
            if ( v13 )
              goto LABEL_182;
          }
        }
        v13 = v46 ^ 1;
        if ( v46 == 1 )
          goto LABEL_182;
LABEL_185:
        if ( v41 && v47 != 1 )
        {
          if ( v53 < a3 )
            *(_BYTE *)(v38 + v53) = 39;
          if ( ++v53 < a3 )
            *(_BYTE *)(v38 + v53) = 39;
          ++v53;
          v41 = 0;
        }
        if ( v53 < a3 )
          *(_BYTE *)(v53 + v38) = v44;
        ++v53;
        if ( v48 != 1 )
          v43 = 0;
LABEL_196:
        ++v52;
        goto LABEL_197;
      }
      v13 = v45;
      v44 = v45;
LABEL_182:
      v22 = v13;
      v21 = a1;
      v17 = &loc_804D7A7;
      if ( !v40 )
        v17 = &loc_804D7AC;
      dword_8056154 = (int)v17;
      sub_80510DD();
LABEL_223:
      if ( a6 == 2 && v39 )
        a6 = 4;
      return sub_804CD21(v38, a3, v37, a5, a6, a7 & 0xFFFFFFFD, 0, v35, v34);
    case 0x7Bu:
    case 0x7Du:
      goto LABEL_107;
    default:
      if ( v50 )
      {
        v57 = 1;
        v49 = ((*__ctype_b_loc())[v44] & 0x4000) != 0;
      }
      else
      {
        memset(&ps, 0, 8u);
        v57 = 0;
        v49 = 1;
        if ( a5 == -1 )
          a5 = strlen(v37);
        v25 = a5 - (v57 + v52);
        v15 = sub_804FAC2(&v23 - 15, &v37[v57 + v52], v25, (mbstate_t *)(&v23 - 5));
        v59 = v15;
        if ( v15 )
        {
          v22 = v15;
          v21 = a1;
          v16 = &loc_804D453;
          if ( v59 != -1 )
            v16 = &loc_804D45C;
          dword_8056134 = (int)v16;
          a1 = v21;
          sub_80511B7(
            v23,
            v24,
            v25,
            v26,
            v27,
            v28,
            v29,
            v30,
            v31,
            v32,
            v33,
            v34,
            v35,
            v36,
            v37,
            v38,
            *(_DWORD *)&v39,
            *(_DWORD *)&v43,
            *(_DWORD *)&v47,
            wc,
            v52,
            v53,
            v54,
            s,
            n,
            v57,
            v58);
          v49 = 0;
        }
      }
      v48 = v49;
      if ( v57 <= 1 && (!v39 || v49 == 1) )
        goto LABEL_176;
      v60 = v52 + v57;
      while ( 2 )
      {
        if ( !v39 || v49 == 1 )
          goto LABEL_161;
        if ( v40 )
          goto LABEL_223;
        v47 = 1;
        if ( a6 == 2 && v41 != 1 )
        {
          if ( v53 < a3 )
            *(_BYTE *)(v38 + v53) = 39;
          if ( ++v53 < a3 )
            *(_BYTE *)(v38 + v53) = 36;
          if ( ++v53 < a3 )
            *(_BYTE *)(v38 + v53) = 39;
          ++v53;
          v41 = 1;
        }
        if ( v53 < a3 )
          *(_BYTE *)(v38 + v53) = 92;
        if ( ++v53 < a3 )
          *(_BYTE *)(v53 + v38) = (v44 >> 6) + 48;
        if ( ++v53 < a3 )
          *(_BYTE *)(v53 + v38) = ((v44 >> 3) & 7) + 48;
        ++v53;
        v44 = (v44 & 7) + 48;
        dword_8056154 = (int)&loc_804D696;
        sub_80510DD();
LABEL_161:
        if ( v46 )
        {
          if ( v53 < a3 )
            *(_BYTE *)(v38 + v53) = 92;
          ++v53;
          v46 = 0;
        }
        if ( v52 + 1 < v60 )
        {
          if ( v41 && v47 != 1 )
          {
            if ( v53 < a3 )
              *(_BYTE *)(v38 + v53) = 39;
            if ( ++v53 < a3 )
              *(_BYTE *)(v38 + v53) = 39;
            ++v53;
            v41 = 0;
          }
          if ( v53 < a3 )
            *(_BYTE *)(v53 + v38) = v44;
          ++v53;
          v44 = v37[++v52];
          continue;
        }
        goto LABEL_185;
      }
  }
}
// 805104D: using guessed type int sub_805104D(void);
// 80510DD: using guessed type int sub_80510DD(void);
// 80511B7: using guessed type int __stdcall sub_80511B7(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8056134: using guessed type int dword_8056134;
// 8056154: using guessed type int dword_8056154;
// 8056168: using guessed type int dword_8056168;

//----- (0804DB31) --------------------------------------------------------
void *__cdecl sub_804DB31(char *a1, size_t a2, _DWORD *a3, int *a4)
{
  int *v4; // eax
  int *v5; // ST44_4
  int v6; // ST48_4
  int v7; // ST4C_4
  unsigned int size; // [esp+48h] [ebp-10h]
  void *ptr; // [esp+4Ch] [ebp-Ch]

  if ( a4 )
    v4 = a4;
  else
    v4 = &dword_80565BB;
  v5 = v4;
  v6 = *__errno_location();
  v7 = v5[1] | (a3 == 0);
  size = sub_804CD21((size_t)(v5 + 2), 0, 0, a1, a2, *v5, v7, (int)(v5 + 2), (char *)v5[10], (char *)v5[11]) + 1;
  ptr = (void *)sub_804F676(size);
  sub_804CD21((size_t)(v5 + 2), (int)ptr, size, a1, a2, *v5, v7, (int)(v5 + 2), (char *)v5[10], (char *)v5[11]);
  *__errno_location() = v6;
  if ( a3 )
    *a3 = size - 1;
  return ptr;
}
// 80565BB: using guessed type int dword_80565BB;

//----- (0804DD50) --------------------------------------------------------
void *__cdecl sub_804DD50(signed int a1, char *a2, size_t a3, int a4)
{
  int *v4; // eax
  void *v5; // edx
  unsigned int v6; // ST44_4
  bool v8; // [esp+37h] [ebp-21h]
  int *v9; // [esp+38h] [ebp-20h]
  void *ptr; // [esp+3Ch] [ebp-1Ch]
  int v11; // [esp+40h] [ebp-18h]
  int size; // [esp+44h] [ebp-14h]
  int v13; // [esp+48h] [ebp-10h]
  unsigned int v14; // [esp+4Ch] [ebp-Ch]

  v11 = *__errno_location();
  v9 = off_80561C4;
  if ( a1 < 0 )
    abort();
  if ( dword_80561B8 <= a1 )
  {
    v8 = off_80561C4 == &dword_80561BC;
    if ( (unsigned int)a1 > 0xFFFFFFE )
      sub_804F7FD();
    if ( v8 )
      v4 = 0;
    else
      v4 = off_80561C4;
    v9 = (int *)sub_804F6D7(v4, 8 * (a1 + 1));
    off_80561C4 = v9;
    if ( v8 )
    {
      v5 = off_80561C0;
      *v9 = dword_80561BC;
      v9[1] = (int)v5;
    }
    memset(&v9[2 * dword_80561B8], 0, 8 * (a1 + 1 - dword_80561B8));
    dword_80561B8 = a1 + 1;
  }
  v6 = v9[2 * a1];
  ptr = (void *)v9[2 * a1 + 1];
  v13 = *(_DWORD *)(a4 + 4) | 1;
  v14 = sub_804CD21(a4 + 8, (int)ptr, v6, a2, a3, *(_DWORD *)a4, v13, a4 + 8, *(char **)(a4 + 40), *(char **)(a4 + 44));
  if ( v6 <= v14 )
  {
    size = v14 + 1;
    v9[2 * a1] = v14 + 1;
    if ( ptr != &unk_80565FB )
      free(ptr);
    ptr = (void *)sub_804F676(size);
    v9[2 * a1 + 1] = (int)ptr;
    sub_804CD21(a4 + 8, (int)ptr, size, a2, a3, *(_DWORD *)a4, v13, a4 + 8, *(char **)(a4 + 40), *(char **)(a4 + 44));
  }
  *__errno_location() = v11;
  return ptr;
}
// 80561B8: using guessed type int dword_80561B8;
// 80561BC: using guessed type int dword_80561BC;
// 80561C0: using guessed type void *off_80561C0;
// 80561C4: using guessed type int *off_80561C4;

//----- (0804DFE4) --------------------------------------------------------
void *__cdecl sub_804DFE4(signed int a1, char *a2)
{
  return sub_804DD50(a1, a2, 0xFFFFFFFF, (int)&dword_80565BB);
}
// 80565BB: using guessed type int dword_80565BB;

//----- (0804E00E) --------------------------------------------------------
void *__cdecl sub_804E00E(signed int a1, char *a2, size_t a3)
{
  return sub_804DD50(a1, a2, a3, (int)&dword_80565BB);
}
// 80565BB: using guessed type int dword_80565BB;

//----- (0804E084) --------------------------------------------------------
void *__cdecl sub_804E084(signed int a1, int a2, char *a3)
{
  char v4; // [esp+10h] [ebp-38h]

  sub_804CBB0((int *)&v4, a2);
  return sub_804DD50(a1, a3, 0xFFFFFFFF, (int)&v4);
}

//----- (0804E0C2) --------------------------------------------------------
void *__cdecl sub_804E0C2(signed int a1, int a2, char *a3, size_t a4)
{
  char v5; // [esp+10h] [ebp-38h]

  sub_804CBB0((int *)&v5, a2);
  return sub_804DD50(a1, a3, a4, (int)&v5);
}

//----- (0804E0FF) --------------------------------------------------------
void *__cdecl sub_804E0FF(int a1, char *a2)
{
  return sub_804E084(0, a1, a2);
}

//----- (0804E15A) --------------------------------------------------------
void *__usercall sub_804E15A@<eax>(int a1@<edx>, int a2@<ecx>, char *a3, size_t a4, char a5)
{
  int v6; // [esp+0h] [ebp-58h]
  char v7; // [esp+1Ch] [ebp-3Ch]
  int v8; // [esp+20h] [ebp-38h]
  int v9; // [esp+24h] [ebp-34h]
  int v10; // [esp+28h] [ebp-30h]
  int v11; // [esp+2Ch] [ebp-2Ch]
  int v12; // [esp+30h] [ebp-28h]
  int v13; // [esp+34h] [ebp-24h]
  int v14; // [esp+38h] [ebp-20h]
  int v15; // [esp+3Ch] [ebp-1Ch]
  int v16; // [esp+40h] [ebp-18h]
  int v17; // [esp+44h] [ebp-14h]
  int v18; // [esp+48h] [ebp-10h]
  int v19; // [esp+4Ch] [ebp-Ch]

  v7 = a5;
  v8 = dword_80565BB;
  v9 = dword_80565BF;
  v10 = dword_80565C3;
  v11 = dword_80565C7;
  v12 = dword_80565CB;
  v13 = dword_80565CF;
  v14 = dword_80565D3;
  v15 = dword_80565D7;
  v16 = dword_80565DB;
  v17 = dword_80565DF;
  v18 = dword_80565E3;
  v19 = dword_80565E7;
  sub_804CA30(a2, a1, (int)(&v6 - 14), a5, 1);
  return sub_804DD50(0, a3, a4, (int)&v8);
}
// 80565BB: using guessed type int dword_80565BB;
// 80565BF: using guessed type int dword_80565BF;
// 80565C3: using guessed type int dword_80565C3;
// 80565C7: using guessed type int dword_80565C7;
// 80565CB: using guessed type int dword_80565CB;
// 80565CF: using guessed type int dword_80565CF;
// 80565D3: using guessed type int dword_80565D3;
// 80565D7: using guessed type int dword_80565D7;
// 80565DB: using guessed type int dword_80565DB;
// 80565DF: using guessed type int dword_80565DF;
// 80565E3: using guessed type int dword_80565E3;
// 80565E7: using guessed type int dword_80565E7;

//----- (0804E214) --------------------------------------------------------
void *__usercall sub_804E214@<eax>(int a1@<edx>, int a2@<ecx>, char *a3, char a4)
{
  return sub_804E15A(a1, a2, a3, 0xFFFFFFFF, a4);
}

//----- (0804E281) --------------------------------------------------------
void *__usercall sub_804E281@<eax>(int a1@<edx>, int a2@<ecx>, char *a3)
{
  return sub_804E214(a1, a2, a3, 58);
}

//----- (0804E2E6) --------------------------------------------------------
void *__cdecl sub_804E2E6(signed int a1, int a2, char *a3)
{
  int v3; // edx
  int v4; // ecx
  int v6; // [esp+0h] [ebp-78h]
  int v7; // [esp+10h] [ebp-68h]
  int v8; // [esp+14h] [ebp-64h]
  int v9; // [esp+18h] [ebp-60h]
  int v10; // [esp+1Ch] [ebp-5Ch]
  int v11; // [esp+20h] [ebp-58h]
  int v12; // [esp+24h] [ebp-54h]
  int v13; // [esp+28h] [ebp-50h]
  int v14; // [esp+2Ch] [ebp-4Ch]
  int v15; // [esp+30h] [ebp-48h]
  int v16; // [esp+34h] [ebp-44h]
  int v17; // [esp+38h] [ebp-40h]
  int v18; // [esp+3Ch] [ebp-3Ch]
  int v19; // [esp+40h] [ebp-38h]
  int v20; // [esp+44h] [ebp-34h]
  int v21; // [esp+48h] [ebp-30h]
  int v22; // [esp+4Ch] [ebp-2Ch]
  int v23; // [esp+50h] [ebp-28h]
  int v24; // [esp+54h] [ebp-24h]
  int v25; // [esp+58h] [ebp-20h]
  int v26; // [esp+5Ch] [ebp-1Ch]
  int v27; // [esp+60h] [ebp-18h]
  int v28; // [esp+64h] [ebp-14h]
  int v29; // [esp+68h] [ebp-10h]
  int v30; // [esp+6Ch] [ebp-Ch]

  sub_804CBB0(&v7, a2);
  v19 = v7;
  v20 = v8;
  v21 = v9;
  v22 = v10;
  v23 = v11;
  v24 = v12;
  v25 = v13;
  v26 = v14;
  v27 = v15;
  v28 = v16;
  v29 = v17;
  v30 = v18;
  sub_804CA30(v4, v3, (int)(&v6 - 14), 58, 1);
  return sub_804DD50(a1, a3, 0xFFFFFFFF, (int)&v19);
}

//----- (0804E397) --------------------------------------------------------
void *__cdecl sub_804E397(signed int a1, int a2, int a3, char *a4)
{
  return sub_804E3EB(a1, a2, a3, a4, 0xFFFFFFFF);
}

//----- (0804E3EB) --------------------------------------------------------
void *__cdecl sub_804E3EB(signed int a1, int a2, int a3, char *a4, size_t a5)
{
  int v6; // [esp+0h] [ebp-48h]
  int v7; // [esp+10h] [ebp-38h]
  int v8; // [esp+14h] [ebp-34h]
  int v9; // [esp+18h] [ebp-30h]
  int v10; // [esp+1Ch] [ebp-2Ch]
  int v11; // [esp+20h] [ebp-28h]
  int v12; // [esp+24h] [ebp-24h]
  int v13; // [esp+28h] [ebp-20h]
  int v14; // [esp+2Ch] [ebp-1Ch]
  int v15; // [esp+30h] [ebp-18h]
  int v16; // [esp+34h] [ebp-14h]
  int v17; // [esp+38h] [ebp-10h]
  int v18; // [esp+3Ch] [ebp-Ch]

  v7 = dword_80565BB;
  v8 = dword_80565BF;
  v9 = dword_80565C3;
  v10 = dword_80565C7;
  v11 = dword_80565CB;
  v12 = dword_80565CF;
  v13 = dword_80565D3;
  v14 = dword_80565D7;
  v15 = dword_80565DB;
  v16 = dword_80565DF;
  v17 = dword_80565E3;
  v18 = dword_80565E7;
  sub_804CB4F(&v6 - 14, a2, a3);
  return sub_804DD50(a1, a4, a5, (int)&v7);
}
// 80565BB: using guessed type int dword_80565BB;
// 80565BF: using guessed type int dword_80565BF;
// 80565C3: using guessed type int dword_80565C3;
// 80565C7: using guessed type int dword_80565C7;
// 80565CB: using guessed type int dword_80565CB;
// 80565CF: using guessed type int dword_80565CF;
// 80565D3: using guessed type int dword_80565D3;
// 80565D7: using guessed type int dword_80565D7;
// 80565DB: using guessed type int dword_80565DB;
// 80565DF: using guessed type int dword_80565DF;
// 80565E3: using guessed type int dword_80565E3;
// 80565E7: using guessed type int dword_80565E7;

//----- (0804E515) --------------------------------------------------------
void *__cdecl sub_804E515(signed int a1, char *a2, size_t a3)
{
  return sub_804DD50(a1, a2, a3, (int)&unk_80561D8);
}

//----- (0804E570) --------------------------------------------------------
void *__cdecl sub_804E570(signed int a1, char *a2)
{
  return sub_804E515(a1, a2, 0xFFFFFFFF);
}

//----- (0804E5CD) --------------------------------------------------------
int __cdecl sub_804E5CD(int a1)
{
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  sub_804FCE8((char *)(a1 + 12), 0, 0, (int)malloc, (int)free);
  sub_804FCE8((char *)(a1 + 56), 0, 0, (int)malloc, (int)free);
  return sub_804FCE8((char *)(a1 + 100), 0, 0, (int)malloc, (int)free);
}

//----- (0804E6B0) --------------------------------------------------------
int __cdecl sub_804E6B0(_DWORD *a1)
{
  int v3; // eax
  int v4; // eax

  a1[4];
  sub_804FFCE((int)(a1 + 3), 0);
  v3 = a1[15];
  sub_804FFCE((int)(a1 + 14), 0);
  v4 = a1[26];
  return sub_804FFCE((int)(a1 + 25), 0);
}

//----- (0804E7E7) --------------------------------------------------------
_DWORD *__cdecl sub_804E7E7(_DWORD *a1)
{
  _DWORD *result; // eax
  int src; // [esp+10h] [ebp-38h]
  _DWORD *v3; // [esp+14h] [ebp-34h]
  _DWORD *v4; // [esp+18h] [ebp-30h]
  int v5; // [esp+1Ch] [ebp-2Ch]
  int v6; // [esp+20h] [ebp-28h]
  _DWORD *v7; // [esp+24h] [ebp-24h]
  _DWORD *v8; // [esp+28h] [ebp-20h]
  _DWORD *v9; // [esp+2Ch] [ebp-1Ch]
  _DWORD *v10; // [esp+30h] [ebp-18h]
  _DWORD *v11; // [esp+34h] [ebp-14h]
  size_t n; // [esp+38h] [ebp-10h]
  _DWORD *v13; // [esp+3Ch] [ebp-Ch]

  v3 = a1 + 3;
  src = a1[6] - a1[5] - 1;
  v4 = a1 + 3;
  v5 = a1[5];
  if ( a1[6] == v5 )
    *((_BYTE *)v4 + 40) |= 2u;
  v4[3] = (v4[6] + v4[3]) & ~v4[6];
  if ( v4[3] - v4[1] > (unsigned int)(v4[4] - v4[1]) )
    v4[3] = v4[4];
  v4[2] = v4[3];
  v6 = v5;
  v7 = a1 + 14;
  v8 = a1 + 14;
  if ( (unsigned int)(a1[18] - a1[17]) <= 3 )
    sub_804FD91((int)v7, 4);
  v9 = v7;
  v10 = (_DWORD *)v7[3];
  *v10 = v6;
  v9[3] += 4;
  v11 = a1 + 25;
  n = 4;
  v13 = a1 + 25;
  if ( (unsigned int)(a1[29] - a1[28]) < 4 )
    sub_804FD91((int)v11, n);
  memcpy((void *)v11[3], &src, n);
  v11[3] += n;
  result = a1;
  ++*a1;
  return result;
}

//----- (0804EA18) --------------------------------------------------------
#error "804EA53: call analysis failed (funcsize=59)"

//----- (0804ED4F) --------------------------------------------------------
ssize_t __cdecl sub_804ED4F(int fd, void *buf, size_t nbytes)
{
  ssize_t v4; // [esp+1Ch] [ebp-Ch]

  while ( 1 )
  {
    do
    {
      v4 = read(fd, buf, nbytes);
      if ( v4 >= 0 )
        return v4;
    }
    while ( *__errno_location() == 4 );
    if ( *__errno_location() != 22 || nbytes <= 0x7FFFE000 )
      break;
    nbytes = 2147475456;
  }
  return v4;
}

//----- (0804EDB1) --------------------------------------------------------
int __cdecl sub_804EDB1(FILE *stream, int a2, int a3, int a4, int a5, int a6)
{
  char *v6; // eax
  int v7; // esi
  char *v8; // ebx
  char *v9; // eax
  int result; // eax
  int v11; // edi
  int v12; // esi
  char *v13; // ebx
  char *v14; // eax
  int v15; // edi
  int v16; // esi
  char *v17; // ebx
  char *v18; // eax
  int v19; // edi
  int v20; // esi
  char *v21; // ebx
  int v22; // edi
  int v23; // esi
  char *v24; // ebx
  char *v25; // eax
  int v26; // esi
  int v27; // edi
  char *v28; // ebx
  char *v29; // eax
  int v30; // edi
  int v31; // esi
  char *v32; // ebx
  char *v33; // eax
  char *v34; // ebx
  char *v35; // eax
  int v36; // edi
  int v37; // esi
  char *v38; // ebx
  char *v39; // eax
  int v40; // edi
  int v41; // esi
  char *v42; // ebx
  char *v43; // eax
  char *v44; // [esp+4h] [ebp-64h]
  char *v45; // [esp+8h] [ebp-60h]
  int v46; // [esp+Ch] [ebp-5Ch]
  int v47; // [esp+10h] [ebp-58h]
  int v48; // [esp+14h] [ebp-54h]
  int v49; // [esp+18h] [ebp-50h]
  int v50; // [esp+1Ch] [ebp-4Ch]
  int v51; // [esp+20h] [ebp-48h]
  int v52; // [esp+24h] [ebp-44h]
  int v53; // [esp+28h] [ebp-40h]
  int v54; // [esp+38h] [ebp-30h]
  int v55; // [esp+3Ch] [ebp-2Ch]
  int v56; // [esp+40h] [ebp-28h]
  int v57; // [esp+44h] [ebp-24h]
  int v58; // [esp+48h] [ebp-20h]
  int v59; // [esp+4Ch] [ebp-1Ch]

  if ( a2 )
  {
    v47 = a4;
    fprintf(stream, "%s (%s) %s\n", a2, a3, a4);
  }
  else
  {
    fprintf(stream, "%s %s\n", a3, a4);
  }
  v46 = 2017;
  v45 = gettext("(C)");
  fprintf(stream, "Copyright %s %d Free Software Foundation, Inc.", v45, 2017);
  v6 = gettext(
         "\n"
         "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\n"
         "This is free software: you are free to change and redistribute it.\n"
         "There is NO WARRANTY, to the extent permitted by law.\n"
         "\n");
  fputs_unlocked(v6, stream);
  switch ( a6 )
  {
    case 0:
      abort();
      return result;
    case 1:
      v34 = *(char **)a5;
      v35 = gettext("Written by %s.\n");
      result = fprintf(stream, v35, v34);
      break;
    case 2:
      v7 = *(_DWORD *)(a5 + 4);
      v8 = *(char **)a5;
      v9 = gettext("Written by %s and %s.\n");
      result = fprintf(stream, v9, v8, v7);
      break;
    case 3:
      v11 = *(_DWORD *)(a5 + 8);
      v12 = *(_DWORD *)(a5 + 4);
      v13 = *(char **)a5;
      v14 = gettext("Written by %s, %s, and %s.\n");
      result = fprintf(stream, v14, v13, v12, v11);
      break;
    case 4:
      v59 = *(_DWORD *)(a5 + 12);
      v15 = *(_DWORD *)(a5 + 8);
      v16 = *(_DWORD *)(a5 + 4);
      v17 = *(char **)a5;
      v18 = gettext("Written by %s, %s, %s,\nand %s.\n");
      v48 = v59;
      v47 = v15;
      v46 = v16;
      v45 = v17;
      result = fprintf(stream, v18, v17, v16, v15, v59);
      break;
    case 5:
      v59 = *(_DWORD *)(a5 + 16);
      v58 = *(_DWORD *)(a5 + 12);
      v19 = *(_DWORD *)(a5 + 8);
      v20 = *(_DWORD *)(a5 + 4);
      v21 = *(char **)a5;
      v49 = v59;
      v48 = v58;
      v47 = v19;
      v46 = v20;
      v45 = v21;
      v44 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
      result = fprintf(stream, v44, v21, v20, v19, v58, v59);
      break;
    case 6:
      v59 = *(_DWORD *)(a5 + 20);
      v58 = *(_DWORD *)(a5 + 16);
      v57 = *(_DWORD *)(a5 + 12);
      v22 = *(_DWORD *)(a5 + 8);
      v23 = *(_DWORD *)(a5 + 4);
      v24 = *(char **)a5;
      v25 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
      result = fprintf(stream, v25, v24, v23, v22, v57, v58, v59);
      break;
    case 7:
      v26 = *(_DWORD *)(a5 + 24);
      v59 = *(_DWORD *)(a5 + 20);
      v58 = *(_DWORD *)(a5 + 16);
      v57 = *(_DWORD *)(a5 + 12);
      v56 = *(_DWORD *)(a5 + 8);
      v27 = *(_DWORD *)(a5 + 4);
      v28 = *(char **)a5;
      v29 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
      v51 = v26;
      v50 = v59;
      v49 = v58;
      v48 = v57;
      v47 = v56;
      v46 = v27;
      v45 = v28;
      result = fprintf(stream, v29, v28, v27, v56, v57, v58, v59, v26);
      break;
    case 8:
      v30 = *(_DWORD *)(a5 + 28);
      v59 = *(_DWORD *)(a5 + 24);
      v58 = *(_DWORD *)(a5 + 20);
      v57 = *(_DWORD *)(a5 + 16);
      v56 = *(_DWORD *)(a5 + 12);
      v55 = *(_DWORD *)(a5 + 8);
      v31 = *(_DWORD *)(a5 + 4);
      v32 = *(char **)a5;
      v33 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
      v52 = v30;
      v51 = v59;
      v50 = v58;
      v49 = v57;
      v48 = v56;
      v47 = v55;
      v46 = v31;
      v45 = v32;
      result = fprintf(stream, v33, v32, v31, v55, v56, v57, v58, v59, v30);
      break;
    case 9:
      v36 = *(_DWORD *)(a5 + 32);
      v59 = *(_DWORD *)(a5 + 28);
      v58 = *(_DWORD *)(a5 + 24);
      v57 = *(_DWORD *)(a5 + 20);
      v56 = *(_DWORD *)(a5 + 16);
      v55 = *(_DWORD *)(a5 + 12);
      v54 = *(_DWORD *)(a5 + 8);
      v37 = *(_DWORD *)(a5 + 4);
      v38 = *(char **)a5;
      v39 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
      v53 = v36;
      v52 = v59;
      v51 = v58;
      v50 = v57;
      v49 = v56;
      v48 = v55;
      v47 = v54;
      v46 = v37;
      v45 = v38;
      result = fprintf(stream, v39, v38, v37, v54, v55, v56, v57, v58, v59, v36);
      break;
    default:
      v40 = *(_DWORD *)(a5 + 32);
      v59 = *(_DWORD *)(a5 + 28);
      v58 = *(_DWORD *)(a5 + 24);
      v57 = *(_DWORD *)(a5 + 20);
      v56 = *(_DWORD *)(a5 + 16);
      v55 = *(_DWORD *)(a5 + 12);
      v54 = *(_DWORD *)(a5 + 8);
      v41 = *(_DWORD *)(a5 + 4);
      v42 = *(char **)a5;
      v43 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
      v53 = v40;
      v52 = v59;
      v51 = v58;
      v50 = v57;
      v49 = v56;
      v48 = v55;
      v47 = v54;
      v46 = v41;
      v45 = v42;
      result = fprintf(stream, v43, v42, v41, v54, v55, v56, v57, v58, v59, v40);
      break;
  }
  return result;
}
// 8049130: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804F40A) --------------------------------------------------------
int __cdecl sub_804F40A(FILE *stream, int a2, int a3, int a4, int a5)
{
  int *v5; // eax
  unsigned int i; // [esp+24h] [ebp-34h]
  int v8[12]; // [esp+28h] [ebp-30h]

  for ( i = 0; i <= 9; ++i )
  {
    v5 = (int *)a5;
    a5 += 4;
    v8[i] = *v5;
    if ( !v8[i] )
      break;
  }
  return sub_804EDB1(stream, a2, a3, a4, (int)v8, i);
}
// 804F40A: using guessed type int var_30[12];

//----- (0804F480) --------------------------------------------------------
int sub_804F480(FILE *stream, int a2, int a3, int a4, ...)
{
  va_list va; // [esp+24h] [ebp+18h]

  va_start(va, a4);
  return sub_804F40A(stream, a2, a3, a4, (int)va);
}

//----- (0804F538) --------------------------------------------------------
int __cdecl sub_804F538(unsigned int a1, unsigned int a2)
{
  int v2; // ecx
  _DWORD *savedregs; // [esp+18h] [ebp+0h]

  savedregs = &savedregs;
  dword_8056184 = (int (__fastcall *)(_DWORD, _DWORD))sub_804F577;
  if ( 0x7FFFFFFF / a2 < a1 )
    sub_804F7FD();
  return dword_8056184(v2, 0x7FFFFFFF % a2);
}
// 804F577: using guessed type int sub_804F577();
// 8056184: using guessed type int (__fastcall *dword_8056184)(_DWORD, _DWORD);

//----- (0804F577) --------------------------------------------------------
#error "804F587: positive sp value has been found (funcsize=0)"

//----- (0804F5DF) --------------------------------------------------------
void *__cdecl sub_804F5DF(void *ptr, int a2, int a3)
{
  unsigned int v4; // [esp+1Ch] [ebp-Ch]

  v4 = *(_DWORD *)a2;
  if ( ptr )
  {
    if ( 0x55555554u / a3 <= v4 )
      sub_804F7FD();
    v4 += (v4 >> 1) + 1;
  }
  else
  {
    if ( !v4 )
      v4 = (0x40u / a3 == 0) + 0x40u / a3;
    if ( 0x7FFFFFFFu / a3 < v4 )
      sub_804F7FD();
  }
  *(_DWORD *)a2 = v4;
  return sub_804F6D7(ptr, a3 * v4);
}

//----- (0804F676) --------------------------------------------------------
int __cdecl sub_804F676(size_t size)
{
  return sub_804F689(size);
}

//----- (0804F689) --------------------------------------------------------
int __cdecl sub_804F689(size_t size)
{
  int v1; // edx
  int v2; // ecx
  void *v3; // ST1C_4
  _DWORD *savedregs; // [esp+28h] [ebp+0h]

  savedregs = &savedregs;
  v3 = malloc(size);
  dword_8056184 = (int (__fastcall *)(_DWORD, _DWORD))sub_804F6D2;
  if ( !v3 )
  {
    dword_8056184 = (int (__fastcall *)(_DWORD, _DWORD))sub_804F6D2;
    if ( size )
      sub_804F7FD();
  }
  return dword_8056184(v2, v1);
}
// 804F6D2: using guessed type int sub_804F6D2();
// 8056184: using guessed type int (__fastcall *dword_8056184)(_DWORD, _DWORD);

//----- (0804F6D2) --------------------------------------------------------
#error "804F6D6: positive sp value has been found (funcsize=0)"

//----- (0804F6D7) --------------------------------------------------------
void *__cdecl sub_804F6D7(void *ptr, size_t size)
{
  void *result; // eax
  void *ptra; // [esp+20h] [ebp+8h]

  if ( size || !ptr )
  {
    ptra = realloc(ptr, size);
    if ( !ptra )
    {
      if ( size )
        sub_804F7FD();
    }
    result = ptra;
  }
  else
  {
    free(ptr);
    result = 0;
  }
  return result;
}

//----- (0804F7AF) --------------------------------------------------------
void *__cdecl sub_804F7AF(void *src, size_t n)
{
  void *v2; // eax

  v2 = (void *)sub_804F689(n);
  return memcpy(v2, src, n);
}

//----- (0804F7FD) --------------------------------------------------------
void __noreturn sub_804F7FD()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (0804F836) --------------------------------------------------------
void sub_804F836()
{
  ;
}

//----- (0804F83B) --------------------------------------------------------
void sub_804F83B()
{
  if ( sub_80500FD() < 0 )
    sub_804F836();
}

//----- (0804F85E) --------------------------------------------------------
#error "804F8E4: call analysis failed (funcsize=63)"

//----- (0804F93A) --------------------------------------------------------
int __cdecl sub_804F93A(FILE *a1)
{
  int result; // eax

  result = a1->_flags & 0x100;
  if ( result )
    result = sub_804F9B3(a1, 0, 0, 1);
  return result;
}

//----- (0804F973) --------------------------------------------------------
int __cdecl sub_804F973(FILE *fp)
{
  if ( !fp || !__freading(fp) )
    return fflush(fp);
  sub_804F93A(fp);
  return fflush(fp);
}

//----- (0804F9B3) --------------------------------------------------------
int __cdecl sub_804F9B3(FILE *stream, int a2, int a3, int a4)
{
  int v4; // eax
  __off64_t v5; // rax
  int v7; // [esp+10h] [ebp-2Ch]
  int v8; // [esp+14h] [ebp-28h]
  int v9; // [esp+20h] [ebp-1Ch]
  int v10; // [esp+24h] [ebp-18h]
  int v11; // [esp+28h] [ebp-14h]
  __off64_t v12; // [esp+28h] [ebp-14h]
  int v13; // [esp+2Ch] [ebp-10h]
  int v14; // [esp+30h] [ebp-Ch]
  int v15; // [esp+34h] [ebp-8h]

  if ( stream->_IO_read_end != stream->_IO_read_ptr
    || stream->_IO_write_ptr != stream->_IO_write_base
    || stream->_IO_save_base )
  {
    return fseeko64(stream, a2, a3, a4, v7, v8, a2, a3, v9, v10, v11, v13, v14, v15);
  }
  v4 = fileno(stream);
  LODWORD(v5) = lseek64(v4, a2, a3, a4, v7, v8, a2, a3, v9, v10, v11, v13, v14, v15);
  v12 = v5;
  if ( v5 == -1 )
  {
    dword_8056154 = (int)&locret_804FAC0;
    sub_80510DD();
  }
  stream->_flags &= 0xFFFFFFEF;
  stream->_offset = v12;
  return 0;
}
// 8048F80: using guessed type int __stdcall fseeko64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8049260: using guessed type int __stdcall lseek64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80510DD: using guessed type int sub_80510DD(void);
// 8056154: using guessed type int dword_8056154;

//----- (0804FAC2) --------------------------------------------------------
size_t __cdecl sub_804FAC2(wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  char v5; // [esp+18h] [ebp-10h]
  size_t v6; // [esp+1Ch] [ebp-Ch]

  if ( !pwc )
    pwc = (wchar_t *)&v5;
  v6 = mbrtowc(pwc, s, n, p);
  if ( v6 <= 0xFFFFFFFD || !n || !((unsigned __int8)sub_8050222(0) ^ 1) )
    return v6;
  *pwc = (unsigned __int8)*s;
  return 1;
}

//----- (0804FB34) --------------------------------------------------------
int __cdecl sub_804FB34(int a1, int a2)
{
  int result; // eax

  if ( *(_BYTE *)(a1 + 40) & 1 )
    result = (*(int (__cdecl **)(_DWORD, int))(a1 + 28))(*(_DWORD *)(a1 + 36), a2);
  else
    result = (*(int (__cdecl **)(int))(a1 + 28))(a2);
  return result;
}

//----- (0804FB72) --------------------------------------------------------
int __cdecl sub_804FB72(int a1, int a2)
{
  int result; // eax

  if ( *(_BYTE *)(a1 + 40) & 1 )
    result = (*(int (__cdecl **)(_DWORD, int))(a1 + 32))(*(_DWORD *)(a1 + 36), a2);
  else
    result = (*(int (__cdecl **)(int))(a1 + 32))(a2);
  return result;
}

//----- (0804FBBC) --------------------------------------------------------
#error "804FCDD: call analysis failed (funcsize=71)"

//----- (0804FCE8) --------------------------------------------------------
int __cdecl sub_804FCE8(char *format, int a2, int a3, int a4, int a5)
{
  *((_DWORD *)format + 7) = a4;
  *((_DWORD *)format + 8) = a5;
  format[40] &= 0xFEu;
  return sub_804FBBC(format, a2, a3);
}

//----- (0804FD91) --------------------------------------------------------
int __cdecl sub_804FD91(int a1, int a2)
{
  int result; // eax
  _DWORD *v3; // [esp+14h] [ebp-24h]
  unsigned int v4; // [esp+18h] [ebp-20h]
  int v5; // [esp+1Ch] [ebp-1Ch]
  size_t n; // [esp+20h] [ebp-18h]
  size_t v7; // [esp+24h] [ebp-14h]
  size_t v8; // [esp+28h] [ebp-10h]
  void *dest; // [esp+2Ch] [ebp-Ch]

  v5 = *(_DWORD *)(a1 + 4);
  v3 = 0;
  n = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 8);
  v7 = n + a2;
  v8 = *(_DWORD *)(a1 + 24) + n + a2;
  v4 = (n >> 3) + v8 + 100;
  if ( v4 < v8 )
    v4 = v8;
  if ( *(_DWORD *)a1 > v4 )
    v4 = *(_DWORD *)a1;
  if ( n <= v7 && v7 <= v8 )
    v3 = (_DWORD *)sub_804FB34(a1, v4);
  if ( !v3 )
    obstack_alloc_failed_handler();
  *(_DWORD *)(a1 + 4) = v3;
  v3[1] = v5;
  *(_DWORD *)(a1 + 16) = (char *)v3 + v4;
  *v3 = *(_DWORD *)(a1 + 16);
  dest = (void *)(((unsigned int)v3 + *(_DWORD *)(a1 + 24) + 8) & ~*(_DWORD *)(a1 + 24));
  memcpy(dest, *(const void **)(a1 + 8), n);
  if ( !(*(_BYTE *)(a1 + 40) & 2) && *(_DWORD *)(a1 + 8) == ((*(_DWORD *)(a1 + 24) + v5 + 8) & ~*(_DWORD *)(a1 + 24)) )
  {
    v3[1] = *(_DWORD *)(v5 + 4);
    sub_804FB72(a1, v5);
  }
  *(_DWORD *)(a1 + 8) = dest;
  *(_DWORD *)(a1 + 12) = n + *(_DWORD *)(a1 + 8);
  result = a1;
  *(_BYTE *)(a1 + 40) &= 0xFDu;
  return result;
}
// 8056280: using guessed type int (*obstack_alloc_failed_handler)(void);

//----- (0804FF8A) --------------------------------------------------------
_BOOL4 __cdecl sub_804FF8A(int a1, unsigned int a2)
{
  unsigned int *i; // [esp+8h] [ebp-8h]

  for ( i = *(unsigned int **)(a1 + 4); i && ((unsigned int)i >= a2 || *i < a2); i = (unsigned int *)i[1] )
    ;
  return i != 0;
}

//----- (0804FFCE) --------------------------------------------------------
int __cdecl sub_804FFCE(int a1, unsigned int a2)
{
  int result; // eax
  int *v3; // ST1C_4
  int *v4; // [esp+18h] [ebp-10h]

  result = *(_DWORD *)(a1 + 4);
  v4 = *(int **)(a1 + 4);
  while ( v4 )
  {
    if ( (unsigned int)v4 < a2 )
    {
      result = *v4;
      if ( *v4 >= a2 )
        break;
    }
    v3 = (int *)v4[1];
    sub_804FB72(a1, (int)v4);
    v4 = v3;
    result = a1;
    *(_BYTE *)(a1 + 40) |= 2u;
  }
  if ( v4 )
  {
    *(_DWORD *)(a1 + 12) = a2;
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 16) = *v4;
    result = a1;
    *(_DWORD *)(a1 + 4) = v4;
  }
  else if ( a2 )
  {
    abort();
  }
  return result;
}

//----- (080500B0) --------------------------------------------------------
void __noreturn sub_80500B0()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  fprintf(stderr, "%s\n", v0);
  exit(status);
}

//----- (080500E9) --------------------------------------------------------
int sub_80500E9()
{
  return 0;
}

//----- (080500F3) --------------------------------------------------------
int sub_80500F3()
{
  return 0;
}

//----- (080500FD) --------------------------------------------------------
int sub_80500FD()
{
  int result; // eax
  int v1; // [esp+14h] [ebp-4h]

  v1 = sub_80500F3();
  if ( v1 )
    result = v1;
  else
    result = sub_80500E9();
  return result;
}

//----- (08050130) --------------------------------------------------------
int __cdecl sub_8050130(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // esi
  unsigned __int8 *v3; // ebx
  unsigned __int8 v5; // al
  unsigned __int8 v6; // [esp+1Eh] [ebp-Ah]

  v2 = a1;
  v3 = a2;
  if ( a1 == a2 )
    return 0;
  do
  {
    v6 = sub_8050A20(*v2);
    v5 = sub_8050A20(*v3);
    if ( !v6 )
      break;
    ++v2;
    ++v3;
  }
  while ( v6 == v5 );
  return v6 - v5;
}

//----- (080501A1) --------------------------------------------------------
int __cdecl sub_80501A1(FILE *fp)
{
  bool v1; // ST1E_1
  bool v3; // [esp+1Dh] [ebp-Bh]
  bool v4; // [esp+1Fh] [ebp-9h]

  v3 = __fpending(fp) != 0;
  v1 = ferror_unlocked(fp) != 0;
  v4 = sub_804F85E(fp) != 0;
  if ( !v1 && (!v4 || !v3 && *__errno_location() == 9) )
    return 0;
  if ( v4 != 1 )
    *__errno_location() = 0;
  return -1;
}

//----- (08050222) --------------------------------------------------------
int __cdecl sub_8050222(int category)
{
  unsigned __int8 v2; // [esp+1Bh] [ebp-Dh]
  const char *s1; // [esp+1Ch] [ebp-Ch]

  v2 = 1;
  s1 = setlocale(category, 0);
  if ( s1 && (!strcmp(s1, "C") || !strcmp(s1, "POSIX")) )
    v2 = 0;
  return v2;
}

//----- (08050280) --------------------------------------------------------
void *sub_8050280()
{
  _BOOL4 v0; // eax
  size_t v2; // [esp+0h] [ebp-C8h]
  char *v3; // [esp+8h] [ebp-C0h]
  char *v4; // [esp+Ch] [ebp-BCh]
  void *ptr; // [esp+14h] [ebp-B4h]
  void *v6; // [esp+18h] [ebp-B0h]
  char *s; // [esp+1Ch] [ebp-ACh]
  void *v8; // [esp+20h] [ebp-A8h]
  size_t v9; // [esp+24h] [ebp-A4h]
  char *v10; // [esp+28h] [ebp-A0h]
  size_t n; // [esp+2Ch] [ebp-9Ch]
  size_t v12; // [esp+30h] [ebp-98h]
  _BOOL4 v13; // [esp+34h] [ebp-94h]
  void *dest; // [esp+38h] [ebp-90h]
  int fd; // [esp+3Ch] [ebp-8Ch]
  FILE *stream; // [esp+40h] [ebp-88h]
  int c; // [esp+44h] [ebp-84h]
  size_t v18; // [esp+48h] [ebp-80h]
  size_t v19; // [esp+4Ch] [ebp-7Ch]
  void *v20; // [esp+50h] [ebp-78h]
  char src; // [esp+56h] [ebp-72h]
  char v22; // [esp+89h] [ebp-3Fh]
  unsigned int v23; // [esp+BCh] [ebp-Ch]

  v23 = __readgsdword(0x14u);
  v6 = (void *)dword_80566FB;
  if ( !dword_80566FB )
  {
    ptr = 0;
    v10 = "charset.alias";
    s = getenv("CHARSETALIASDIR");
    if ( !s || !*s )
    {
      ptr = 0;
      s = "/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib";
    }
    n = strlen(s);
    v12 = strlen(v10);
    v0 = n && s[n - 1] != 47;
    v13 = v0;
    v2 = n + v0 + v12 + 1;
    dest = malloc(v2);
    if ( dest )
    {
      memcpy(dest, s, n);
      if ( v13 )
        *((_BYTE *)dest + n) = 47;
      memcpy((char *)dest + n + v13, v10, v12 + 1);
    }
    free(ptr);
    if ( dest )
    {
      fd = open64(dest, 0x20000);
      if ( fd >= 0 )
      {
        stream = fdopen(fd, "r");
        if ( stream )
        {
          v8 = 0;
          v9 = 0;
          while ( 1 )
          {
            c = getc_unlocked(stream);
            if ( c == -1 )
              break;
            if ( c != 10 && c != 32 && c != 9 )
            {
              if ( c == 35 )
              {
                do
                  c = getc_unlocked(stream);
                while ( c != -1 && c != 10 );
                if ( c == -1 )
                  break;
              }
              else
              {
                ungetc(c, stream);
                v4 = &v22;
                v3 = &src;
                if ( fscanf(stream, "%50s %50s", &src, &v22) <= 1 )
                  break;
                v18 = strlen(&src);
                v19 = strlen(&v22);
                v20 = v8;
                if ( v9 )
                {
                  v9 += v19 + v18 + 2;
                  v8 = realloc(v8, v9 + 1);
                }
                else
                {
                  v9 = v18 + v19 + 2;
                  v2 = v18 + v19 + 3;
                  v8 = malloc(v2);
                }
                if ( !v8 )
                {
                  v9 = 0;
                  free(v20);
                  break;
                }
                strcpy((char *)v8 + v9 - v19 - v18 - 2, &src);
                strcpy((char *)v8 + v9 - v19 - 1, (const char *)&v2 - 63);
              }
            }
          }
          sub_804F85E(stream);
          if ( !v9 )
          {
            v6 = &unk_8052457;
            dword_8056168 = (int)&loc_805074F;
            sub_805104D();
          }
          *((_BYTE *)v8 + v9) = 0;
          v6 = v8;
        }
        else
        {
          close(fd);
          v6 = &unk_8052457;
        }
      }
      else
      {
        v6 = &unk_8052457;
      }
      free(dest);
    }
    else
    {
      v6 = &unk_8052457;
    }
    dword_80566FB = (int)v6;
  }
  return v6;
}
// 8048EB0: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 805104D: using guessed type int sub_805104D(void);
// 8056168: using guessed type int dword_8056168;
// 80566FB: using guessed type int dword_80566FB;

//----- (08050788) --------------------------------------------------------
const char *sub_8050788()
{
  char *v0; // ST1C_4
  const char *s1; // [esp+18h] [ebp-10h]
  char *s2; // [esp+1Ch] [ebp-Ch]

  s1 = nl_langinfo(14);
  if ( !s1 )
    s1 = (const char *)&unk_8052457;
  for ( s2 = (char *)sub_8050280(); *s2; s2 = &v0[strlen(v0) + 1] )
  {
    if ( !strcmp(s1, s2) || *s2 == 42 && !s2[1] )
    {
      s1 = &s2[strlen(s2) + 1];
      break;
    }
    v0 = &s2[strlen(s2) + 1];
  }
  if ( !*s1 )
    s1 = "ASCII";
  return s1;
}

//----- (08050A20) --------------------------------------------------------
int __cdecl sub_8050A20(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 65) > 0x19 )
    result = a1;
  else
    result = a1 + 32;
  return result;
}

//----- (08050A5C) --------------------------------------------------------
int __usercall sub_8050A5C@<eax>(int a1@<edi>, int a2@<esi>, int a3, int a4, unsigned int a5, int a6)
{
  int result; // eax
  unsigned int v7; // [esp+0h] [ebp-18h]
  int v8; // [esp+4h] [ebp-14h]
  int v9; // [esp+Ch] [ebp-Ch]
  int v10; // [esp+10h] [ebp-8h]

  v10 = a1;
  v9 = a2;
  v8 = a3;
  v7 = a5;
  dword_8056184 = (int (__fastcall *)(_DWORD, _DWORD))&loc_8050AFC;
  if ( a6
    || (dword_8056184 = (int (__fastcall *)(_DWORD, _DWORD))&loc_8050B87, a5 > (unsigned int)&v7)
    || (dword_8056184 = (int (__fastcall *)(_DWORD, _DWORD))&loc_8050AD5, a5) )
  {
    result = dword_8056184(a5, a4);
  }
  else
  {
    result = __PAIR__((unsigned int)&v7 % (1 / 0u), a3) / (1 / 0u);
  }
  return result;
}
// 8056184: using guessed type int (__fastcall *dword_8056184)(_DWORD, _DWORD);

//----- (08050C8B) --------------------------------------------------------
int __cdecl sub_8050C8B(unsigned __int64 a1, __int64 a2)
{
  int v2; // edx
  int result; // eax
  int v4; // ebp
  int v5; // ebp
  unsigned int v6; // ebp
  unsigned __int64 v7; // rtt
  unsigned __int64 v8; // rax
  unsigned int v9; // edi
  unsigned __int64 v10; // rax
  unsigned int v11; // ecx
  unsigned int v12; // [esp+0h] [ebp-20h]
  unsigned int v13; // [esp+4h] [ebp-1Ch]
  unsigned __int64 v14; // [esp+8h] [ebp-18h]
  unsigned int v15; // [esp+10h] [ebp-10h]

  v13 = HIDWORD(a1);
  v15 = a1;
  v12 = a2;
  v14 = a1;
  if ( HIDWORD(a2) )
  {
    if ( HIDWORD(a2) > HIDWORD(a1) )
    {
      result = a1;
    }
    else
    {
      _BitScanReverse((unsigned int *)&v4, HIDWORD(a2));
      v5 = v4 ^ 0x1F;
      if ( v5 )
      {
        v13 = (HIDWORD(a2) << v5) | (v12 >> (32 - v5));
        LODWORD(v14) = v12 << v5;
        HIDWORD(v8) = HIDWORD(a1) >> (32 - v5);
        LODWORD(v8) = (HIDWORD(a1) << v5) | (v15 >> (32 - v5));
        HIDWORD(v14) = v15 << v5;
        v9 = v8 % v13;
        v10 = (v12 << v5) * (unsigned __int64)(unsigned int)(v8 / v13);
        v12 = HIDWORD(v10);
        v11 = v10;
        if ( v9 < HIDWORD(v10) || HIDWORD(v14) < (unsigned int)v10 && v9 == HIDWORD(v10) )
        {
          HIDWORD(v10) = v12;
          HIDWORD(v10) = (v10 - __PAIR__(v13, (unsigned int)v14)) >> 32;
          v11 = v10 - v14;
        }
        result = ((__PAIR__(v9, HIDWORD(v14)) - __PAIR__(HIDWORD(v10), v11)) >> 32 << (32 - (unsigned __int8)v5)) | ((HIDWORD(v14) - v11) >> (char)&v12);
      }
      else
      {
        if ( v12 <= (unsigned int)v14 || HIDWORD(a2) < HIDWORD(v14) )
          v14 = __PAIR__(v13, (unsigned int)a1) - a2;
        result = v14;
      }
    }
  }
  else
  {
    if ( (unsigned int)a2 <= HIDWORD(a1) )
    {
      v6 = a2;
      if ( !(_DWORD)a2 )
        v6 = 1 / 0u;
      LODWORD(v7) = a1;
      HIDWORD(v7) = v13 % v6;
      v2 = v7 % v6;
    }
    else
    {
      v2 = a1 % (unsigned int)a2;
    }
    result = v2;
  }
  return result;
}

//----- (08050E7E) --------------------------------------------------------
int __cdecl sub_8050E7E(int a1)
{
  return __cxa_atexit(a1, 0, dword_805619C);
}
// 8049070: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 805619C: using guessed type int dword_805619C;

//----- (08050EAD) --------------------------------------------------------
int __cdecl sub_8050EAD(int a1, int a2)
{
  return __xstat64(3, a1, a2);
}
// 80492B0: using guessed type int __cdecl __xstat64(_DWORD, _DWORD, _DWORD);

//----- (08050EEC) --------------------------------------------------------
int __cdecl sub_8050EEC(int a1, int a2)
{
  return __fxstat64(3, a1, a2);
}
// 8049020: using guessed type int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD);

//----- (0805104D) --------------------------------------------------------
#error "8051053: positive sp value has been found (funcsize=0)"

//----- (080510DD) --------------------------------------------------------
#error "80510E3: positive sp value has been found (funcsize=0)"

//----- (080511B7) --------------------------------------------------------
#error "80511BD: positive sp value has been found (funcsize=0)"

//----- (080511D0) --------------------------------------------------------
int (**sub_80511D0())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_8055EEC;
  v1 = &off_8055EF0 - off_8055EEC;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_8055EEC[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 8055EEC: using guessed type int (*off_8055EEC[2])();
// 8055EF0: using guessed type int (*off_8055EF0)();

//----- (08051234) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 15 decompilation failure(s) on 125 function(s)"
