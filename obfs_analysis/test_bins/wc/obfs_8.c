/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8048E90();
// int strcmp(const char *s1, const char *s2);
// ssize_t read(int fd, void *buf, size_t nbytes);
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void _exit(int status);
// void *memmove(void *dest, const void *src, size_t n);
// void free(void *ptr);
// void *memcpy(void *dest, const void *src, size_t n);
// int mbsinit(const mbstate_t *ps);
// int ferror(FILE *stream);
// int fclose(FILE *stream);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// int sysconf(int name);
// char *textdomain(const char *domainname);
// int iswprint(wint_t wc);
// int ferror_unlocked(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD); weak
// size_t __ctype_get_mb_cur_max(void);
// size_t __fpending(FILE *fp);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// void error(int status, int errnum, const char *format, ...);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int sysinfo(struct sysinfo *info);
// int __freading(FILE *fp);
// int iswspace(wint_t wc);
// void exit(int status);
// char *gettext(const char *msgid);
// int feof(FILE *stream);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// char *strchr(const char *s, int c);
// size_t strlen(const char *s);
// int fprintf(FILE *stream, const char *format, ...);
// int getpagesize(void);
// int setvbuf(FILE *stream, char *buf, int modes, size_t n);
// void *memset(void *s, int c, size_t n);
// int *__errno_location(void);
// int fileno(FILE *stream);
// int fgetc(FILE *stream);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// char *strrchr(const char *s, int c);
// int __cdecl getdelim(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// char *bindtextdomain(const char *domainname, const char *dirname);
// int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// void abort(void);
// int __cdecl __xstat64(_DWORD, _DWORD, _DWORD); weak
// int close(int fd);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// int putchar_unlocked(int c);
// int _gmon_start__(void); weak
void sub_8049353();
void sub_8049370();
int sub_8049380();
int sub_80493F0();
int sub_8049410();
void sub_804946F();
void sub_804948A();
signed int sub_804949A();
// int __usercall sub_8049501@<eax>(int a1@<eax>, int (__cdecl *a2)(signed int, int)@<edx>);
void sub_8049598();
void sub_80495B3();
int sub_80495C3();
void sub_80496A5();
void sub_80496C0();
int sub_80496D0();
void sub_80497B2();
void sub_80497CD();
int nullsub_4(void); // weak
int sub_8049854();
void sub_80498F4();
void sub_804990F();
int sub_804991F();
void sub_8049A01();
void sub_8049A1C();
int sub_8049A2C();
void sub_8049B0E();
void sub_8049B29();
int sub_8049B39();
void sub_8049C1B();
void sub_8049C36();
int sub_8049C46();
int __cdecl sub_8049D0F(unsigned __int8 a1);
int sub_8049D21();
// int __usercall sub_8049D4C@<eax>(int a1@<ebx>, char *s1);
void __cdecl sub_8049EFB(int a1);
int sub_8049F5E(); // weak
void __cdecl __noreturn sub_8049F68(int status); // idb
void __cdecl sub_804A07D(signed __int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, char *a6);
int __cdecl sub_804A2FD(int); // weak
int __cdecl sub_804A341(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_804B436(char *s1, int); // idb
_DWORD *__cdecl sub_804B5AF(unsigned int a1, int a2);
signed int __cdecl sub_804B71A(unsigned int a1, _DWORD *a2);
int __cdecl main(int, char **, char **); // idb
void __cdecl __noreturn sub_804B910(char **argv, char *shortopts, struct option *longopts, int *longind, int, int, int, int, int, int, int, int, int, int, int, double, __int64, int, __int16, int, int, char *s1, int, FILE *stream, int, int, int, int, int, char, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int); // idb
int __cdecl sub_804BE8A(int errnum, char *format, char *function, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, char, int, int, char *s1, void *, int, int, int, void *ptr, char *, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, char); // idb
void sub_804C339();
int sub_804C37E(); // weak
_DWORD *__cdecl sub_804C39E(int a1);
_DWORD __cdecl sub_804C405(_DWORD, _DWORD); // weak
int __cdecl sub_804C505(_DWORD *a1);
void __cdecl sub_804C530(void *ptr);
int sub_804C57E();
int __cdecl sub_804C662(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_804C70B(signed __int64 a1, int a2);
bool __cdecl sub_804C879(unsigned __int8 a1);
long double sub_804C8C0();
long double sub_804C97D();
char *__cdecl sub_804CA54(char *s);
int __cdecl sub_804CBA0(int *a1, unsigned __int8 a2, char a3);
void __cdecl __noreturn sub_804CC5A(int *a1, int a2, int a3);
int sub_804CCA0(); // weak
_DWORD __cdecl sub_804CCB4(_DWORD, _DWORD); // weak
int __cdecl sub_804CD6B(char *msgid, int); // idb
_DWORD __cdecl sub_804CE22(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_804CE72(void *s2, size_t n, mbstate_t *p, int, int, int, int, int); // idb
void *__cdecl sub_804DCB3(int a1, int a2, _DWORD *a3, _DWORD *a4);
void *__cdecl sub_804DEAC(signed int a1, int a2, int a3, _DWORD *a4);
void *__cdecl sub_804E115(signed int a1, int a2);
void *__cdecl sub_804E13F(signed int a1, int a2, int a3);
void *__cdecl sub_804E1B5(signed int a1, int a2, int a3);
void *__cdecl sub_804E1F3(signed int a1, int a2, int a3, int a4);
void *__cdecl sub_804E230(int a1, int a2);
void *__cdecl sub_804E28B(int a1, int a2, unsigned __int8 a3);
void *__cdecl sub_804E345(int a1, unsigned __int8 a2);
void *__cdecl sub_804E37E(int a1);
void *__cdecl sub_804E3BB(signed int a1, int a2, int a3);
void __cdecl __noreturn sub_804E46C(int a1, int a2, int a3);
void __cdecl __noreturn sub_804E4AC(int a1, int a2, int a3);
void *__cdecl sub_804E5D6(signed int a1, int a2, int a3);
void *__cdecl sub_804E631(signed int a1, int a2);
int __cdecl sub_804E66E(_DWORD *a1);
int __cdecl sub_804E72D(_DWORD *a1);
int __cdecl sub_804E832(int a1);
bool __cdecl sub_804EA5F(FILE *stream, int a2);
ssize_t __cdecl sub_804ED96(int fd, void *buf, size_t nbytes);
int __cdecl sub_804EE0D(FILE *stream, int, int, int, int, int); // idb
int __cdecl sub_804F47D(FILE *stream, int, int, int, int); // idb
int sub_804F4F3(FILE *stream, int a2, int a3, int a4, ...);
void *__cdecl sub_804F5A3(unsigned int a1, unsigned int a2);
int __cdecl sub_804F606(void *ptr, int, int); // idb
void *__cdecl sub_804F6B6(size_t size);
void *__cdecl sub_804F6C9(size_t size);
void *__cdecl sub_804F6F3(void *ptr, size_t size);
void *__cdecl sub_804F7E4(void *src, size_t n);
void __noreturn sub_804F832();
void sub_804F86B();
void __cdecl sub_804F870(int a1, int a2);
int __cdecl sub_804F893(FILE *stream); // idb
int __cdecl sub_804F956(FILE *stream); // idb
int __cdecl sub_804F98F(FILE *fp); // idb
int __cdecl sub_804F9CF(FILE *stream, int, int, int); // idb
size_t __cdecl sub_804FAC9(wchar_t *pwc, char *s, size_t n, mbstate_t *p);
int __cdecl sub_804FB3B(int a1, int a2);
int __cdecl sub_804FB79(int a1, int a2);
_DWORD __cdecl sub_804FBB7(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_804FCCF(int a1, int a2, int a3, int a4, int a5);
_DWORD __cdecl sub_804FD78(_DWORD, _DWORD); // weak
int __cdecl sub_804FFB0(int a1, unsigned int a2);
void __noreturn sub_8050092();
int sub_80500CB();
int sub_80500D5();
void __cdecl sub_80500DF(int a1, int a2);
int sub_8050130(); // weak
int __cdecl sub_8050135(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_80501AF(FILE *fp); // idb
int __cdecl sub_8050230(int category); // idb
void *sub_805028E();
const char *sub_80507F6();
int __cdecl sub_8050ACB(int a1);
signed __int64 __cdecl sub_8050B07(unsigned __int64 a1, unsigned int a2, unsigned int a3);
int __cdecl sub_8050C5A(unsigned __int64 a1, __int64 a2);
int __cdecl sub_8050E57(int a1);
int __cdecl sub_8050E86(int a1, int a2);
int __cdecl sub_8050EB5(int a1, int a2);
int sub_805101D(void); // weak
int __stdcall sub_8051089(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int sub_80510F5(void); // weak
int __stdcall sub_805116D(_DWORD); // weak
int __stdcall sub_80511E7(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (**sub_8051200())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN locret_8049C55; // weak
_UNKNOWN loc_8049DF9; // weak
_UNKNOWN loc_8049E11; // weak
_UNKNOWN loc_8049F46; // weak
_UNKNOWN loc_8049F63; // weak
_UNKNOWN loc_804A13D; // weak
_UNKNOWN loc_804A193; // weak
_UNKNOWN loc_804A1E9; // weak
_UNKNOWN loc_804A23F; // weak
_UNKNOWN loc_804A28E; // weak
_UNKNOWN loc_804A300; // weak
_UNKNOWN loc_804A310; // weak
_UNKNOWN loc_804B473; // weak
_UNKNOWN loc_804B4BD; // weak
_UNKNOWN locret_804C39C; // weak
_UNKNOWN loc_804CC9B; // weak
_UNKNOWN loc_804DCD9; // weak
_UNKNOWN loc_804DCDE; // weak
_UNKNOWN loc_804E8A5; // weak
_UNKNOWN loc_804E91F; // weak
_UNKNOWN loc_804E98C; // weak
_UNKNOWN loc_804EA13; // weak
_UNKNOWN loc_804EBA6; // weak
_UNKNOWN locret_804EE0B; // weak
_UNKNOWN loc_804EE35; // weak
_UNKNOWN loc_804EE5F; // weak
_UNKNOWN loc_804F40D; // weak
_UNKNOWN locret_8050133; // weak
_UNKNOWN loc_80501A8; // weak
_UNKNOWN loc_805045B; // weak
_UNKNOWN loc_805046A; // weak
_UNKNOWN loc_8050CEA; // weak
char locale = '\0'; // idb
int dword_8051BF8[8] = { 6656, 4294967279, 4294967294, 2147483646, 0, 0, 0, 0 }; // idb
_UNKNOWN unk_805248F; // weak
_UNKNOWN unk_80541B8; // weak
_UNKNOWN unk_80541BB; // weak
int (*off_8055EE8[2])() = { &sub_8049410, &sub_80493F0 }; // weak
int (*off_8055EEC)() = &sub_80493F0; // weak
int (*dword_8056008)(void) = NULL; // weak
int dword_8056134 = 0; // weak
int dword_8056148 = 0; // weak
int dword_805615C = 0; // weak
int dword_8056170 = 0; // weak
int dword_8056184 = 0; // weak
int dword_80561A0 = 0; // weak
int dword_80561B8 = 0; // weak
int status = 1; // idb
int dword_80561D4 = 1; // weak
int dword_80561D8 = 256; // weak
void *off_80561DC = &unk_8056688; // weak
int *off_80561E0 = &dword_80561D8; // weak
_UNKNOWN unk_80561F4; // weak
_UNKNOWN unk_8056214; // weak
_UNKNOWN unk_8056217; // weak
_UNKNOWN unk_8056218; // weak
_UNKNOWN unk_805621B; // weak
void (__noreturn *off_8056224)() = &sub_8050092; // weak
_UNKNOWN unk_8056228; // weak
_UNKNOWN unk_805622B; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int program_invocation_name; // weak
FILE *stdout; // idb
char byte_80562AC; // weak
_UNKNOWN unk_805631D; // weak
char byte_8056620; // weak
char byte_8056621; // weak
char byte_8056622; // weak
char byte_8056623; // weak
char byte_8056624; // weak
int dword_8056628; // weak
char byte_805662C; // weak
int dword_8056638; // weak
char byte_805663C; // weak
int dword_8056640; // weak
int dword_8056648; // weak
int dword_805664C; // weak
int dword_8056650; // weak
int dword_8056654; // weak
int dword_8056658; // weak
int dword_805665C; // weak
int dword_8056660; // weak
int dword_8056664; // weak
int dword_8056668; // weak
int dword_805666C; // weak
int dword_8056670; // weak
int dword_8056674; // weak
_UNKNOWN unk_8056688; // weak
int dword_8056788; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (08048E64) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 8049310: using guessed type int _gmon_start__(void);

//----- (08048E90) --------------------------------------------------------
int sub_8048E90()
{
  return dword_8056008();
}
// 8056008: using guessed type int (*dword_8056008)(void);

//----- (08049320) --------------------------------------------------------
#error "8049323: positive sp value has been found (funcsize=2)"

//----- (08049353) --------------------------------------------------------
void sub_8049353()
{
  ;
}

//----- (08049370) --------------------------------------------------------
void sub_8049370()
{
  ;
}

//----- (08049380) --------------------------------------------------------
int sub_8049380()
{
  int result; // eax

  result = &unk_805622B - &unk_8056228;
  if ( (unsigned int)(&unk_805622B - &unk_8056228) > 6 )
    result = 0;
  return result;
}
// 8049380: could not find valid save-restore pair for ebp

//----- (080493F0) --------------------------------------------------------
int sub_80493F0()
{
  int result; // eax

  if ( !byte_80562AC )
  {
    result = sub_8049380();
    byte_80562AC = 1;
  }
  return result;
}
// 80493F0: could not find valid save-restore pair for ebp
// 80562AC: using guessed type char byte_80562AC;

//----- (08049410) --------------------------------------------------------
int sub_8049410()
{
  return 0;
}
// 8049410: could not find valid save-restore pair for ebp

//----- (0804946F) --------------------------------------------------------
void sub_804946F()
{
  ;
}

//----- (0804948A) --------------------------------------------------------
void sub_804948A()
{
  ;
}

//----- (0804949A) --------------------------------------------------------
signed int sub_804949A()
{
  return 3;
}
// 804949A: could not find valid save-restore pair for ebp

//----- (08049501) --------------------------------------------------------
int __usercall sub_8049501@<eax>(int a1@<eax>, int (__cdecl *a2)(signed int, int)@<edx>)
{
  return a2(134566420, a1);
}

//----- (08049598) --------------------------------------------------------
void sub_8049598()
{
  ;
}

//----- (080495B3) --------------------------------------------------------
void sub_80495B3()
{
  ;
}

//----- (080495C3) --------------------------------------------------------
int sub_80495C3()
{
  int result; // eax

  result = &unk_805631D - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_805631D - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 80495C3: could not find valid save-restore pair for ebp
// 8056240: using guessed type int program_invocation_short_name;

//----- (080496A5) --------------------------------------------------------
void sub_80496A5()
{
  ;
}

//----- (080496C0) --------------------------------------------------------
void sub_80496C0()
{
  ;
}

//----- (080496D0) --------------------------------------------------------
int sub_80496D0()
{
  int result; // eax

  result = &unk_8056217 - &unk_8056214;
  if ( (unsigned int)(&unk_8056217 - &unk_8056214) > 6 )
    result = 0;
  return result;
}
// 80496D0: could not find valid save-restore pair for ebp

//----- (080497B2) --------------------------------------------------------
void sub_80497B2()
{
  ;
}

//----- (080497CD) --------------------------------------------------------
void sub_80497CD()
{
  ;
}

//----- (080497DD) --------------------------------------------------------
#error "804980A: call analysis failed (funcsize=23)"

//----- (08049854) --------------------------------------------------------
int sub_8049854()
{
  return nullsub_4();
}
// 8049854: could not find valid save-restore pair for ebp
// 8049853: using guessed type int nullsub_4(void);

//----- (080498F4) --------------------------------------------------------
void sub_80498F4()
{
  ;
}

//----- (0804990F) --------------------------------------------------------
void sub_804990F()
{
  ;
}

//----- (0804991F) --------------------------------------------------------
int sub_804991F()
{
  int result; // eax

  result = &unk_8056217 - &unk_8056214;
  if ( (unsigned int)(&unk_8056217 - &unk_8056214) > 6 )
    result = 0;
  return result;
}
// 804991F: could not find valid save-restore pair for ebp

//----- (08049A01) --------------------------------------------------------
void sub_8049A01()
{
  ;
}

//----- (08049A1C) --------------------------------------------------------
void sub_8049A1C()
{
  ;
}

//----- (08049A2C) --------------------------------------------------------
int sub_8049A2C()
{
  int result; // eax

  result = &unk_80541BB - &unk_80541B8;
  if ( (unsigned int)(&unk_80541BB - &unk_80541B8) > 6 )
    result = 0;
  return result;
}
// 8049A2C: could not find valid save-restore pair for ebp

//----- (08049B0E) --------------------------------------------------------
void sub_8049B0E()
{
  ;
}

//----- (08049B29) --------------------------------------------------------
void sub_8049B29()
{
  ;
}

//----- (08049B39) --------------------------------------------------------
int sub_8049B39()
{
  int result; // eax

  result = &unk_805621B - &unk_8056218;
  if ( (unsigned int)(&unk_805621B - &unk_8056218) > 6 )
    result = 0;
  return result;
}
// 8049B39: could not find valid save-restore pair for ebp

//----- (08049C1B) --------------------------------------------------------
void sub_8049C1B()
{
  ;
}

//----- (08049C36) --------------------------------------------------------
void sub_8049C36()
{
  ;
}

//----- (08049C46) --------------------------------------------------------
int sub_8049C46()
{
  int result; // eax
  int (__stdcall *v1)(void (__noreturn **)(), int, int, int, int, int); // eax
  int v2; // [esp+4h] [ebp-18h]
  int v3; // [esp+8h] [ebp-14h]
  int v4; // [esp+Ch] [ebp-10h]
  int v5; // [esp+10h] [ebp-Ch]
  int v6; // [esp+14h] [ebp-8h]
  int v7; // [esp+18h] [ebp-4h]

  result = &unk_8056214 - (_UNKNOWN *)&off_8056224;
  if ( (unsigned int)(&unk_8056214 - (_UNKNOWN *)&off_8056224) > 6 )
  {
    v7 = 0;
    dword_8056184 = (int)&locret_8049C55;
    v1 = (int (__stdcall *)(void (__noreturn **)(), int, int, int, int, int))sub_805101D();
    result = v1(&off_8056224, v2, v3, v4, v5, v6);
  }
  return result;
}
// 805101D: using guessed type int sub_805101D(void);
// 8056184: using guessed type int dword_8056184;
// 8056224: using guessed type void (__noreturn *off_8056224)();

//----- (08049D0F) --------------------------------------------------------
int __cdecl sub_8049D0F(unsigned __int8 a1)
{
  return a1;
}

//----- (08049D21) --------------------------------------------------------
int sub_8049D21()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nWith no FILE, or when FILE is -, read standard input.\n");
  return fputs_unlocked(v1, v0);
}
// 8049130: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (08049D4C) --------------------------------------------------------
int __usercall sub_8049D4C@<eax>(int a1@<ebx>, char *s1)
{
  bool v2; // zf
  void *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // ebx
  char *v8; // eax
  int v10; // [esp-8h] [ebp-70h]
  char *v11; // [esp-4h] [ebp-6Ch]
  int v12; // [esp+0h] [ebp-68h]
  char *v13; // [esp+4h] [ebp-64h]
  char *v14; // [esp+8h] [ebp-60h]
  char *v15; // [esp+1Ch] [ebp-4Ch]
  char **i; // [esp+20h] [ebp-48h]
  char *v17; // [esp+24h] [ebp-44h]
  const char *v18; // [esp+28h] [ebp-40h]
  const char *v19; // [esp+2Ch] [ebp-3Ch]
  const char *v20; // [esp+30h] [ebp-38h]
  const char *v21; // [esp+34h] [ebp-34h]
  const char *v22; // [esp+38h] [ebp-30h]
  const char *v23; // [esp+3Ch] [ebp-2Ch]
  const char *v24; // [esp+40h] [ebp-28h]
  const char *v25; // [esp+44h] [ebp-24h]
  const char *v26; // [esp+48h] [ebp-20h]
  const char *v27; // [esp+4Ch] [ebp-1Ch]
  const char *v28; // [esp+50h] [ebp-18h]
  const char *v29; // [esp+54h] [ebp-14h]
  int v30; // [esp+58h] [ebp-10h]
  int v31; // [esp+5Ch] [ebp-Ch]

  v18 = "[";
  v19 = "test invocation";
  v20 = "coreutils";
  v21 = "Multi-call invocation";
  v22 = "sha224sum";
  v23 = "sha2 utilities";
  v24 = "sha256sum";
  v25 = "sha2 utilities";
  v26 = "sha384sum";
  v27 = "sha2 utilities";
  v28 = "sha512sum";
  v29 = "sha2 utilities";
  v30 = 0;
  v31 = 0;
  v15 = s1;
  for ( i = (char **)(&v12 - 16); ; i += 2 )
  {
    v2 = *i == 0;
    v11 = *i;
    v10 = a1;
    v3 = &loc_8049DF9;
    if ( v2 )
      v3 = &loc_8049E11;
    dword_805615C = (int)v3;
    a1 = v10;
    sub_80510F5();
    v13 = *i;
    if ( !strcmp(s1, v13) )
      break;
  }
  if ( i[1] )
    v15 = i[1];
  v4 = gettext("\n%s online help: <%s>\n");
  v14 = "http://www.gnu.org/software/coreutils/";
  v13 = "GNU coreutils";
  printf(v4, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  v17 = setlocale(5, 0);
  if ( v17 && strncmp(v17, "en_", 3u) )
  {
    v5 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
    v13 = s1;
    printf(v5, s1);
  }
  v6 = gettext("Full documentation at: <%s%s>\n");
  v14 = s1;
  v13 = "http://www.gnu.org/software/coreutils/";
  printf(v6, "http://www.gnu.org/software/coreutils/", s1);
  if ( v15 == s1 )
    v7 = " invocation";
  else
    v7 = &locale;
  v8 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  v14 = v7;
  v13 = v15;
  return printf(v8, v15, v7);
}
// 80510F5: using guessed type int sub_80510F5(void);
// 805615C: using guessed type int dword_805615C;

//----- (08049EFB) --------------------------------------------------------
void __cdecl sub_8049EFB(int a1)
{
  int v1; // eax
  int v2; // eax

  v1 = *(_DWORD *)(a1 + 16) & 0xF000;
  dword_80561A0 = (int)&loc_8049F46;
  JUMPOUT(v1, 0x8000, &loc_8050CEA);
  v2 = *(_DWORD *)(a1 + 16) & 0xF000;
  dword_80561A0 = (int)sub_8049F5E;
  JUMPOUT(v2, 40960, &loc_8050CEA);
  dword_80561A0 = (int)&loc_8049F63;
  JUMPOUT(&loc_8050CEA);
}
// 8049F5E: using guessed type int sub_8049F5E();
// 80561A0: using guessed type int dword_80561A0;

//----- (08049F5E) --------------------------------------------------------
#error "8049F67: positive sp value has been found (funcsize=0)"

//----- (08049F68) --------------------------------------------------------
void __cdecl __noreturn sub_8049F68(int status)
{
  int v1; // ebx
  char *v2; // eax
  int v3; // esi
  int v4; // ebx
  char *v5; // eax
  FILE *v6; // ebx
  char *v7; // eax
  FILE *v8; // ebx
  char *v9; // eax
  FILE *v10; // ebx
  char *v11; // eax
  FILE *v12; // ebx
  char *v13; // eax
  FILE *v14; // ebx
  char *v15; // eax

  if ( status )
  {
    v1 = dword_8056640;
    v2 = gettext("Try '%s --help' for more information.\n");
    fprintf(stderr, v2, v1);
  }
  else
  {
    v3 = dword_8056640;
    v4 = dword_8056640;
    v5 = gettext("Usage: %s [OPTION]... [FILE]...\n  or:  %s [OPTION]... --files0-from=F\n");
    printf(v5, v4, v3);
    v6 = stdout;
    v7 = gettext(
           "Print newline, word, and byte counts for each FILE, and a total line if\n"
           "more than one FILE is specified.  A word is a non-zero-length sequence of\n"
           "characters delimited by white space.\n");
    fputs_unlocked(v7, v6);
    sub_8049D21();
    v8 = stdout;
    v9 = gettext(
           "\n"
           "The options below may be used to select which counts are printed, always in\n"
           "the following order: newline, word, character, byte, maximum line length.\n"
           "  -c, --bytes            print the byte counts\n"
           "  -m, --chars            print the character counts\n"
           "  -l, --lines            print the newline counts\n");
    fputs_unlocked(v9, v8);
    v10 = stdout;
    v11 = gettext(
            "      --files0-from=F    read input from the files specified by\n"
            "                           NUL-terminated names in file F;\n"
            "                           If F is - then read names from standard input\n"
            "  -L, --max-line-length  print the maximum display width\n"
            "  -w, --words            print the word counts\n");
    fputs_unlocked(v11, v10);
    v12 = stdout;
    v13 = gettext("      --help     display this help and exit\n");
    fputs_unlocked(v13, v12);
    v14 = stdout;
    v15 = gettext("      --version  output version information and exit\n");
    fputs_unlocked(v15, v14);
    sub_8049D4C((int)v14, "wc");
  }
  exit(status);
}
// 8049130: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8056640: using guessed type int dword_8056640;

//----- (0804A07D) --------------------------------------------------------
void __cdecl sub_804A07D(signed __int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, char *a6)
{
  char *v6; // eax
  int v7; // [esp-10h] [ebp-64h]
  int v8; // [esp-Ch] [ebp-60h]
  char *s; // [esp+0h] [ebp-54h]
  __int64 v10; // [esp+4h] [ebp-50h]
  __int64 v11; // [esp+Ch] [ebp-48h]
  __int64 v12; // [esp+14h] [ebp-40h]
  __int64 v13; // [esp+1Ch] [ebp-38h]
  __int64 v14; // [esp+24h] [ebp-30h]
  char *format; // [esp+2Ch] [ebp-28h]
  char v16; // [esp+33h] [ebp-21h]
  unsigned int v17; // [esp+48h] [ebp-Ch]

  v14 = a1;
  v13 = a2;
  v12 = a3;
  v11 = a4;
  v10 = a5;
  s = a6;
  v17 = __readgsdword(0x14u);
  format = "%*s";
  dword_80561A0 = (int)&loc_804A13D;
  JUMPOUT(byte_8056620, 0, &loc_8050CEA);
  v8 = sub_804C70B(a1, (int)&v16);
  v7 = dword_8056628;
  printf(format, dword_8056628, v8);
  format = " %*s";
  dword_80561A0 = (int)&loc_804A193;
  JUMPOUT(byte_8056621, 0, &loc_8050CEA);
  v8 = sub_804C70B(v13, (int)&v16);
  v7 = dword_8056628;
  printf(format, dword_8056628, v8);
  format = " %*s";
  dword_80561A0 = (int)&loc_804A1E9;
  JUMPOUT(byte_8056622, 0, &loc_8050CEA);
  v8 = sub_804C70B(v12, (int)&v16);
  v7 = dword_8056628;
  printf(format, dword_8056628, v8);
  format = " %*s";
  dword_80561A0 = (int)&loc_804A23F;
  JUMPOUT(byte_8056623, 0, &loc_8050CEA);
  v8 = sub_804C70B(v11, (int)&v16);
  v7 = dword_8056628;
  printf(format, dword_8056628, v8);
  format = " %*s";
  dword_80561A0 = (int)&loc_804A28E;
  JUMPOUT(byte_8056624, 0, &loc_8050CEA);
  v8 = sub_804C70B(v10, (int)&v16);
  v7 = dword_8056628;
  printf(format, dword_8056628, v8);
  dword_80561A0 = (int)&loc_804A310;
  JUMPOUT(s, 0, &loc_8050CEA);
  v6 = strchr(s, 10);
  dword_80561A0 = (int)sub_804A2FD;
  JUMPOUT(v6, 0, &loc_8050CEA);
  sub_804E3BB(0, 3, (int)s);
  dword_80561A0 = (int)&loc_804A300;
  JUMPOUT(&loc_8050CEA);
}
// 804A2FD: using guessed type int __cdecl sub_804A2FD(int);
// 80561A0: using guessed type int dword_80561A0;
// 8056620: using guessed type char byte_8056620;
// 8056621: using guessed type char byte_8056621;
// 8056622: using guessed type char byte_8056622;
// 8056623: using guessed type char byte_8056623;
// 8056624: using guessed type char byte_8056624;
// 8056628: using guessed type int dword_8056628;

//----- (0804A2FD) --------------------------------------------------------
#error "804A30B: call analysis failed (funcsize=13)"

//----- (0804A33F) --------------------------------------------------------
#error "804A340: positive sp value has been found (funcsize=0)"

//----- (0804A341) --------------------------------------------------------
#error "804A360: call analysis failed (funcsize=12)"

//----- (0804A365) --------------------------------------------------------
#error "804B435: positive sp value has been found (funcsize=680)"

//----- (0804B436) --------------------------------------------------------
int __cdecl sub_804B436(char *s1, int a2)
{
  bool v2; // zf
  void *v3; // eax
  int v5; // [esp+0h] [ebp-38h]
  int v6; // [esp+4h] [ebp-34h]
  int v7; // [esp+8h] [ebp-30h]
  int v8; // [esp+Ch] [ebp-2Ch]
  int v9; // [esp+10h] [ebp-28h]
  int v10; // [esp+14h] [ebp-24h]
  int v11; // [esp+18h] [ebp-20h]
  int v12; // [esp+1Ch] [ebp-1Ch]
  int v13; // [esp+20h] [ebp-18h]
  int v14; // [esp+24h] [ebp-14h]
  int v15; // [esp+28h] [ebp-10h]
  int fd; // [esp+2Ch] [ebp-Ch]
  int v17; // [esp+30h] [ebp-8h]
  int v18; // [esp+34h] [ebp-4h]
  int savedregs; // [esp+38h] [ebp+0h]

  if ( s1 )
  {
    v2 = strcmp(s1, "-") == 0;
    v3 = &loc_804B473;
    if ( !v2 )
      v3 = &loc_804B4BD;
    dword_8056170 = (int)v3;
    sub_8051089(v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, fd, v17, v18, savedregs);
  }
  byte_805662C = 1;
  sub_804F870(0, 0);
  return sub_804A341(0, s1, a2, -1, -1);
}
// 804A341: using guessed type int __cdecl sub_804A341(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8051089: using guessed type int __stdcall sub_8051089(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8056170: using guessed type int dword_8056170;
// 805662C: using guessed type char byte_805662C;

//----- (0804B5AF) --------------------------------------------------------
_DWORD *__cdecl sub_804B5AF(unsigned int a1, int a2)
{
  unsigned int v2; // eax
  int v3; // eax
  unsigned int i; // [esp+18h] [ebp-10h]
  _DWORD *v6; // [esp+1Ch] [ebp-Ch]

  if ( a1 )
    v2 = a1;
  else
    v2 = 1;
  v6 = sub_804F5A3(v2, 0x64u);
  if ( a1
    && (a1 != 1
     || (unsigned __int8)byte_8056623
      + (unsigned __int8)byte_8056622
      + (unsigned __int8)byte_8056621
      + (unsigned __int8)byte_8056620
      + (unsigned __int8)byte_8056624 != 1) )
  {
    for ( i = 0; i < a1; ++i )
    {
      if ( *(_DWORD *)(4 * i + a2) && strcmp(*(const char **)(4 * i + a2), "-") )
        v3 = sub_8050E86(*(_DWORD *)(4 * i + a2), (int)&v6[25 * i + 1]);
      else
        v3 = sub_8050EB5(0, (int)&v6[25 * i + 1]);
      v6[25 * i] = v3;
    }
  }
  else
  {
    *v6 = 1;
  }
  return v6;
}
// 8056620: using guessed type char byte_8056620;
// 8056621: using guessed type char byte_8056621;
// 8056622: using guessed type char byte_8056622;
// 8056623: using guessed type char byte_8056623;
// 8056624: using guessed type char byte_8056624;

//----- (0804B71A) --------------------------------------------------------
signed int __cdecl sub_804B71A(unsigned int a1, _DWORD *a2)
{
  signed int v3; // [esp+1Ch] [ebp-1Ch]
  signed int v4; // [esp+20h] [ebp-18h]
  unsigned int i; // [esp+24h] [ebp-14h]
  unsigned __int64 v6; // [esp+28h] [ebp-10h]

  v3 = 1;
  if ( a1 && *a2 <= 0 )
  {
    v4 = 1;
    v6 = 0LL;
    for ( i = 0; i < a1; ++i )
    {
      if ( !a2[25 * i] )
      {
        if ( (a2[25 * i + 5] & 0xF000) == 0x8000 )
          v6 += *(_QWORD *)&a2[25 * i + 12];
        else
          v4 = 7;
      }
    }
    while ( v6 > 9 )
    {
      ++v3;
      v6 = sub_8050B07(v6, 0xAu, 0);
    }
    if ( v3 < v4 )
      v3 = v4;
  }
  return v3;
}

//----- (0804B806) --------------------------------------------------------
#error "804B90B: call analysis failed (funcsize=53)"

//----- (0804B910) --------------------------------------------------------
#error "804BAA6: call analysis failed (funcsize=324)"

//----- (0804BE8A) --------------------------------------------------------
#error "804BE99: call analysis failed (funcsize=264)"

//----- (0804C339) --------------------------------------------------------
void sub_804C339()
{
  void *v0; // ST1C_4

  v0 = malloc(0x18u);
  dword_80561A0 = (int)sub_804C37E;
  JUMPOUT(v0, 0, &loc_8050CEA);
  dword_80561A0 = (int)&locret_804C39C;
  JUMPOUT(&loc_8050CEA);
}
// 804C37E: using guessed type int sub_804C37E();
// 80561A0: using guessed type int dword_80561A0;

//----- (0804C37E) --------------------------------------------------------
#error "804C39D: positive sp value has been found (funcsize=0)"

//----- (0804C39E) --------------------------------------------------------
_DWORD *__cdecl sub_804C39E(int a1)
{
  _DWORD *v2; // [esp+1Ch] [ebp-Ch]

  v2 = malloc(0x18u);
  if ( !v2 )
    return 0;
  *v2 = a1;
  v2[2] = 0;
  v2[3] = 0;
  v2[1] = 0;
  v2[4] = 0;
  return v2;
}

//----- (0804C405) --------------------------------------------------------
#error "804C4A4: call analysis failed (funcsize=62)"

//----- (0804C505) --------------------------------------------------------
int __cdecl sub_804C505(_DWORD *a1)
{
  int result; // eax

  if ( *a1 )
    result = a1[1];
  else
    result = (a1[5] - a1[4]) >> 2;
  return result;
}

//----- (0804C530) --------------------------------------------------------
void __cdecl sub_804C530(void *ptr)
{
  if ( *(_DWORD *)ptr )
    free(*((void **)ptr + 2));
  free(ptr);
}

//----- (0804C57E) --------------------------------------------------------
int sub_804C57E()
{
  void *v0; // ebx
  int *v1; // eax
  int *v2; // eax
  int result; // eax
  char *v4; // [esp+2Ch] [ebp-Ch]

  if ( sub_80501AF(stdout) && (byte_805663C != 1 || *__errno_location() != 32) )
  {
    v4 = gettext("write error");
    if ( dword_8056638 )
    {
      v0 = sub_804E37E(dword_8056638);
      v1 = __errno_location();
      error(0, *v1, "%s: %s", v0, v4);
    }
    else
    {
      v2 = __errno_location();
      error(0, *v2, "%s", v4);
    }
    _exit(status);
  }
  result = sub_80501AF(stderr);
  if ( result )
    _exit(status);
  return result;
}
// 8056638: using guessed type int dword_8056638;
// 805663C: using guessed type char byte_805663C;

//----- (0804C662) --------------------------------------------------------
int __cdecl sub_804C662(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // [esp+20h] [ebp-28h]

  v7 = a4;
  return posix_fadvise64(a1, a2, a3, a4, a5, a6);
}
// 8049280: using guessed type int __cdecl posix_fadvise64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804C70B) --------------------------------------------------------
int __cdecl sub_804C70B(signed __int64 a1, int a2)
{
  signed __int64 v3; // [esp+18h] [ebp-20h]
  int v4; // [esp+2Ch] [ebp-Ch]

  v3 = a1;
  v4 = a2 + 20;
  *(_BYTE *)(a2 + 20) = 0;
  do
  {
    *(_BYTE *)--v4 = sub_8050C5A(v3, 10LL) + 48;
    v3 = sub_8050B07(v3, 0xAu, 0);
  }
  while ( v3 );
  return v4;
}

//----- (0804C879) --------------------------------------------------------
bool __cdecl sub_804C879(unsigned __int8 a1)
{
  return (((unsigned int)dword_8051BF8[a1 >> 5] >> (a1 & 0x1F)) & 1) != 0;
}

//----- (0804C8C0) --------------------------------------------------------
long double sub_804C8C0()
{
  double v1; // [esp+18h] [ebp-60h]
  double v2; // [esp+20h] [ebp-58h]
  char v3; // [esp+2Ch] [ebp-4Ch]
  unsigned int v4; // [esp+3Ch] [ebp-3Ch]
  unsigned int v5; // [esp+60h] [ebp-18h]
  unsigned int v6; // [esp+6Ch] [ebp-Ch]

  v6 = __readgsdword(0x14u);
  v1 = (long double)sysconf(85);
  v2 = (long double)sysconf(30);
  if ( v1 >= 0.0 && v2 >= 0.0 )
    return v1 * v2;
  if ( sysinfo((struct sysinfo *)&v3) )
    return 67108864.0;
  return (long double)v4 * (long double)v5;
}

//----- (0804C97D) --------------------------------------------------------
long double sub_804C97D()
{
  double v1; // [esp+18h] [ebp-60h]
  double v2; // [esp+20h] [ebp-58h]
  char v3; // [esp+2Ch] [ebp-4Ch]
  unsigned int v4; // [esp+40h] [ebp-38h]
  unsigned int v5; // [esp+48h] [ebp-30h]
  unsigned int v6; // [esp+60h] [ebp-18h]
  unsigned int v7; // [esp+6Ch] [ebp-Ch]

  v7 = __readgsdword(0x14u);
  v1 = (long double)sysconf(86);
  v2 = (long double)sysconf(30);
  if ( v1 >= 0.0 && v2 >= 0.0 )
    return v1 * v2;
  if ( sysinfo((struct sysinfo *)&v3) )
    return sub_804C8C0() / 4.0;
  return ((long double)v4 + (long double)v5) * (long double)v6;
}

//----- (0804CA54) --------------------------------------------------------
char *__cdecl sub_804CA54(char *s)
{
  char *v1; // eax
  char *result; // eax
  char *v3; // [esp+18h] [ebp-10h]
  char *s1; // [esp+1Ch] [ebp-Ch]

  if ( !s )
  {
    fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
    abort();
  }
  v3 = strrchr(s, 47);
  if ( v3 )
    v1 = v3 + 1;
  else
    v1 = s;
  s1 = v1;
  if ( v1 - s > 6 && !strncmp(v1 - 7, "/.libs/", 7u) )
  {
    s = s1;
    if ( !strncmp(s1, "lt-", 3u) )
    {
      s = s1 + 3;
      program_invocation_short_name = (int)(s1 + 3);
    }
  }
  dword_8056640 = (int)s;
  result = s;
  program_invocation_name = (int)s;
  return result;
}
// 8056240: using guessed type int program_invocation_short_name;
// 8056250: using guessed type int program_invocation_name;
// 8056640: using guessed type int dword_8056640;

//----- (0804CBA0) --------------------------------------------------------
int __cdecl sub_804CBA0(int *a1, unsigned __int8 a2, char a3)
{
  int *v3; // eax
  int v4; // ST10_4

  if ( a1 )
    v3 = a1;
  else
    v3 = &dword_8056648;
  v4 = ((unsigned int)v3[(a2 >> 5) + 2] >> (a2 & 0x1F)) & 1;
  v3[(a2 >> 5) + 2] ^= (v4 ^ a3 & 1) << (a2 & 0x1F);
  return v4;
}
// 8056648: using guessed type int dword_8056648;

//----- (0804CC5A) --------------------------------------------------------
void __cdecl __noreturn sub_804CC5A(int *a1, int a2, int a3)
{
  int (*v3)(); // eax

  if ( !a1 )
    a1 = &dword_8056648;
  *a1 = 10;
  if ( a2 )
  {
    v3 = (int (*)())&loc_804CC9B;
    if ( a3 )
      v3 = sub_804CCA0;
    dword_805615C = (int)v3;
    sub_80510F5();
  }
  abort();
}
// 804CCA0: using guessed type int sub_804CCA0();
// 80510F5: using guessed type int sub_80510F5(void);
// 805615C: using guessed type int dword_805615C;
// 8056648: using guessed type int dword_8056648;

//----- (0804CCA0) --------------------------------------------------------
#error "804CCB3: positive sp value has been found (funcsize=0)"

//----- (0804CCB4) --------------------------------------------------------
#error "804CD20: call analysis failed (funcsize=36)"

//----- (0804CD25) --------------------------------------------------------
#error "804CD65: positive sp value has been found (funcsize=0)"

//----- (0804CD6B) --------------------------------------------------------
#error "804CDFB: call analysis failed (funcsize=56)"

//----- (0804CE22) --------------------------------------------------------
#error "804CE6D: call analysis failed (funcsize=27)"

//----- (0804CE72) --------------------------------------------------------
#error "804DBC0: positive sp value has been found (funcsize=962)"

//----- (0804DCB3) --------------------------------------------------------
void *__cdecl sub_804DCB3(int a1, int a2, _DWORD *a3, _DWORD *a4)
{
  void *v4; // eax
  int v5; // ST48_4
  int v6; // ST4C_4
  int size; // [esp+48h] [ebp-10h]
  void *v9; // [esp+4Ch] [ebp-Ch]

  v4 = &loc_804DCD9;
  if ( !a4 )
    v4 = &loc_804DCDE;
  dword_805615C = (int)v4;
  sub_80510F5();
  v5 = *__errno_location();
  v6 = a4[1] | (a3 == 0);
  size = sub_804CE22(0, 0, a1, a2, *a4, v6, a4 + 2, a4[10], a4[11]) + 1;
  v9 = sub_804F6B6(size);
  sub_804CE22(v9, size, a1, a2, *a4, v6, a4 + 2, a4[10], a4[11]);
  *__errno_location() = v5;
  if ( a3 )
    *a3 = size - 1;
  return v9;
}
// 804CE22: using guessed type _DWORD __cdecl sub_804CE22(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80510F5: using guessed type int sub_80510F5(void);
// 805615C: using guessed type int dword_805615C;

//----- (0804DEAC) --------------------------------------------------------
void *__cdecl sub_804DEAC(signed int a1, int a2, int a3, _DWORD *a4)
{
  int *v4; // eax
  void *v5; // edx
  size_t v6; // ST44_4
  bool v8; // [esp+37h] [ebp-21h]
  int *v9; // [esp+38h] [ebp-20h]
  void *ptr; // [esp+3Ch] [ebp-1Ch]
  int v11; // [esp+40h] [ebp-18h]
  int size; // [esp+44h] [ebp-14h]
  int v13; // [esp+48h] [ebp-10h]
  size_t v14; // [esp+4Ch] [ebp-Ch]

  v11 = *__errno_location();
  v9 = off_80561E0;
  if ( a1 < 0 )
    abort();
  if ( dword_80561D4 <= a1 )
  {
    v8 = off_80561E0 == &dword_80561D8;
    if ( (unsigned int)a1 > 0xFFFFFFE )
      sub_804F832();
    if ( v8 )
      v4 = 0;
    else
      v4 = off_80561E0;
    v9 = (int *)sub_804F6F3(v4, 8 * (a1 + 1));
    off_80561E0 = v9;
    if ( v8 )
    {
      v5 = off_80561DC;
      *v9 = dword_80561D8;
      v9[1] = (int)v5;
    }
    memset(&v9[2 * dword_80561D4], 0, 8 * (a1 + 1 - dword_80561D4));
    dword_80561D4 = a1 + 1;
  }
  v6 = v9[2 * a1];
  ptr = (void *)v9[2 * a1 + 1];
  v13 = a4[1] | 1;
  v14 = sub_804CE22(ptr, v6, a2, a3, *a4, v13, a4 + 2, a4[10], a4[11]);
  if ( v6 <= v14 )
  {
    size = v14 + 1;
    v9[2 * a1] = v14 + 1;
    if ( ptr != &unk_8056688 )
      free(ptr);
    ptr = sub_804F6B6(size);
    v9[2 * a1 + 1] = (int)ptr;
    sub_804CE22(ptr, size, a2, a3, *a4, v13, a4 + 2, a4[10], a4[11]);
  }
  *__errno_location() = v11;
  return ptr;
}
// 804CE22: using guessed type _DWORD __cdecl sub_804CE22(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80561D4: using guessed type int dword_80561D4;
// 80561D8: using guessed type int dword_80561D8;
// 80561DC: using guessed type void *off_80561DC;
// 80561E0: using guessed type int *off_80561E0;

//----- (0804E115) --------------------------------------------------------
void *__cdecl sub_804E115(signed int a1, int a2)
{
  return sub_804DEAC(a1, a2, -1, &dword_8056648);
}
// 8056648: using guessed type int dword_8056648;

//----- (0804E13F) --------------------------------------------------------
void *__cdecl sub_804E13F(signed int a1, int a2, int a3)
{
  return sub_804DEAC(a1, a2, a3, &dword_8056648);
}
// 8056648: using guessed type int dword_8056648;

//----- (0804E1B5) --------------------------------------------------------
void *__cdecl sub_804E1B5(signed int a1, int a2, int a3)
{
  char v4; // [esp+10h] [ebp-38h]

  sub_804CCB4(&v4, a2);
  return sub_804DEAC(a1, a3, -1, &v4);
}
// 804CCB4: using guessed type _DWORD __cdecl sub_804CCB4(_DWORD, _DWORD);

//----- (0804E1F3) --------------------------------------------------------
void *__cdecl sub_804E1F3(signed int a1, int a2, int a3, int a4)
{
  char v5; // [esp+10h] [ebp-38h]

  sub_804CCB4(&v5, a2);
  return sub_804DEAC(a1, a3, a4, &v5);
}
// 804CCB4: using guessed type _DWORD __cdecl sub_804CCB4(_DWORD, _DWORD);

//----- (0804E230) --------------------------------------------------------
void *__cdecl sub_804E230(int a1, int a2)
{
  return sub_804E1B5(0, a1, a2);
}

//----- (0804E28B) --------------------------------------------------------
void *__cdecl sub_804E28B(int a1, int a2, unsigned __int8 a3)
{
  int v4; // [esp+0h] [ebp-58h]
  unsigned __int8 v5; // [esp+1Ch] [ebp-3Ch]
  int v6; // [esp+20h] [ebp-38h]
  int v7; // [esp+24h] [ebp-34h]
  int v8; // [esp+28h] [ebp-30h]
  int v9; // [esp+2Ch] [ebp-2Ch]
  int v10; // [esp+30h] [ebp-28h]
  int v11; // [esp+34h] [ebp-24h]
  int v12; // [esp+38h] [ebp-20h]
  int v13; // [esp+3Ch] [ebp-1Ch]
  int v14; // [esp+40h] [ebp-18h]
  int v15; // [esp+44h] [ebp-14h]
  int v16; // [esp+48h] [ebp-10h]
  int v17; // [esp+4Ch] [ebp-Ch]

  v5 = a3;
  v6 = dword_8056648;
  v7 = dword_805664C;
  v8 = dword_8056650;
  v9 = dword_8056654;
  v10 = dword_8056658;
  v11 = dword_805665C;
  v12 = dword_8056660;
  v13 = dword_8056664;
  v14 = dword_8056668;
  v15 = dword_805666C;
  v16 = dword_8056670;
  v17 = dword_8056674;
  sub_804CBA0(&v4 - 14, a3, 1);
  return sub_804DEAC(0, a1, a2, &v6);
}
// 8056648: using guessed type int dword_8056648;
// 805664C: using guessed type int dword_805664C;
// 8056650: using guessed type int dword_8056650;
// 8056654: using guessed type int dword_8056654;
// 8056658: using guessed type int dword_8056658;
// 805665C: using guessed type int dword_805665C;
// 8056660: using guessed type int dword_8056660;
// 8056664: using guessed type int dword_8056664;
// 8056668: using guessed type int dword_8056668;
// 805666C: using guessed type int dword_805666C;
// 8056670: using guessed type int dword_8056670;
// 8056674: using guessed type int dword_8056674;

//----- (0804E345) --------------------------------------------------------
void *__cdecl sub_804E345(int a1, unsigned __int8 a2)
{
  return sub_804E28B(a1, -1, a2);
}

//----- (0804E37E) --------------------------------------------------------
void *__cdecl sub_804E37E(int a1)
{
  return sub_804E345(a1, 0x3Au);
}

//----- (0804E3BB) --------------------------------------------------------
void *__cdecl sub_804E3BB(signed int a1, int a2, int a3)
{
  int v4; // [esp-4h] [ebp-7Ch]
  int v5; // [esp+10h] [ebp-68h]
  int v6; // [esp+14h] [ebp-64h]
  int v7; // [esp+18h] [ebp-60h]
  int v8; // [esp+1Ch] [ebp-5Ch]
  int v9; // [esp+20h] [ebp-58h]
  int v10; // [esp+24h] [ebp-54h]
  int v11; // [esp+28h] [ebp-50h]
  int v12; // [esp+2Ch] [ebp-4Ch]
  int v13; // [esp+30h] [ebp-48h]
  int v14; // [esp+34h] [ebp-44h]
  int v15; // [esp+38h] [ebp-40h]
  int v16; // [esp+3Ch] [ebp-3Ch]
  int v17; // [esp+40h] [ebp-38h]
  int v18; // [esp+44h] [ebp-34h]
  int v19; // [esp+48h] [ebp-30h]
  int v20; // [esp+4Ch] [ebp-2Ch]
  int v21; // [esp+50h] [ebp-28h]
  int v22; // [esp+54h] [ebp-24h]
  int v23; // [esp+58h] [ebp-20h]
  int v24; // [esp+5Ch] [ebp-1Ch]
  int v25; // [esp+60h] [ebp-18h]
  int v26; // [esp+64h] [ebp-14h]
  int v27; // [esp+68h] [ebp-10h]
  int v28; // [esp+6Ch] [ebp-Ch]

  sub_804CCB4(&v5, a2);
  v17 = v5;
  v18 = v6;
  v19 = v7;
  v20 = v8;
  v21 = v9;
  v22 = v10;
  v23 = v11;
  v24 = v12;
  v25 = v13;
  v26 = v14;
  v27 = v15;
  v28 = v16;
  sub_804CBA0(&v4 - 14, 0x3Au, 1);
  return sub_804DEAC(a1, a3, -1, &v17);
}
// 804CCB4: using guessed type _DWORD __cdecl sub_804CCB4(_DWORD, _DWORD);

//----- (0804E46C) --------------------------------------------------------
void __cdecl __noreturn sub_804E46C(int a1, int a2, int a3)
{
  sub_804E4AC(a1, a2, a3);
}

//----- (0804E4AC) --------------------------------------------------------
void __cdecl __noreturn sub_804E4AC(int a1, int a2, int a3)
{
  int v3; // [esp+0h] [ebp-48h]
  int v4; // [esp+10h] [ebp-38h]
  int v5; // [esp+14h] [ebp-34h]
  int v6; // [esp+18h] [ebp-30h]
  int v7; // [esp+1Ch] [ebp-2Ch]
  int v8; // [esp+20h] [ebp-28h]
  int v9; // [esp+24h] [ebp-24h]
  int v10; // [esp+28h] [ebp-20h]
  int v11; // [esp+2Ch] [ebp-1Ch]
  int v12; // [esp+30h] [ebp-18h]
  int v13; // [esp+34h] [ebp-14h]
  int v14; // [esp+38h] [ebp-10h]
  int v15; // [esp+3Ch] [ebp-Ch]

  v4 = dword_8056648;
  v5 = dword_805664C;
  v6 = dword_8056650;
  v7 = dword_8056654;
  v8 = dword_8056658;
  v9 = dword_805665C;
  v10 = dword_8056660;
  v11 = dword_8056664;
  v12 = dword_8056668;
  v13 = dword_805666C;
  v14 = dword_8056670;
  v15 = dword_8056674;
  sub_804CC5A(&v3 - 14, a2, a3);
}
// 8056648: using guessed type int dword_8056648;
// 805664C: using guessed type int dword_805664C;
// 8056650: using guessed type int dword_8056650;
// 8056654: using guessed type int dword_8056654;
// 8056658: using guessed type int dword_8056658;
// 805665C: using guessed type int dword_805665C;
// 8056660: using guessed type int dword_8056660;
// 8056664: using guessed type int dword_8056664;
// 8056668: using guessed type int dword_8056668;
// 805666C: using guessed type int dword_805666C;
// 8056670: using guessed type int dword_8056670;
// 8056674: using guessed type int dword_8056674;

//----- (0804E5D6) --------------------------------------------------------
void *__cdecl sub_804E5D6(signed int a1, int a2, int a3)
{
  return sub_804DEAC(a1, a2, a3, &unk_80561F4);
}

//----- (0804E631) --------------------------------------------------------
void *__cdecl sub_804E631(signed int a1, int a2)
{
  return sub_804E5D6(a1, a2, -1);
}

//----- (0804E66E) --------------------------------------------------------
int __cdecl sub_804E66E(_DWORD *a1)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_804FCCF((int)(a1 + 3), 0, 0, (int)malloc, (int)free);
  sub_804FCCF((int)(a1 + 14), 0, 0, (int)malloc, (int)free);
  return sub_804FCCF((int)(a1 + 25), 0, 0, (int)malloc, (int)free);
}

//----- (0804E72D) --------------------------------------------------------
int __cdecl sub_804E72D(_DWORD *a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax

  v1 = a1[4];
  sub_804FFB0((int)(a1 + 3), 0);
  v2 = a1[15];
  sub_804FFB0((int)(a1 + 14), 0);
  v3 = a1[26];
  return sub_804FFB0((int)(a1 + 25), 0);
}

//----- (0804E832) --------------------------------------------------------
int __cdecl sub_804E832(int a1)
{
  int v1; // eax
  int v2; // edx
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int result; // eax
  int src; // [esp+10h] [ebp-38h]
  int v8; // [esp+14h] [ebp-34h]
  int v9; // [esp+18h] [ebp-30h]
  int v10; // [esp+1Ch] [ebp-2Ch]
  int v11; // [esp+20h] [ebp-28h]
  int v12; // [esp+24h] [ebp-24h]
  int v13; // [esp+28h] [ebp-20h]
  int v14; // [esp+2Ch] [ebp-1Ch]
  _DWORD *v15; // [esp+30h] [ebp-18h]
  int v16; // [esp+34h] [ebp-14h]
  size_t n; // [esp+38h] [ebp-10h]
  int v18; // [esp+3Ch] [ebp-Ch]

  v8 = a1 + 12;
  src = *(_DWORD *)(a1 + 24) - *(_DWORD *)(a1 + 20) - 1;
  v9 = a1 + 12;
  v10 = *(_DWORD *)(a1 + 20);
  v1 = *(_DWORD *)(a1 + 24);
  dword_80561A0 = (int)&loc_804E8A5;
  JUMPOUT(v1, v10, &loc_8050CEA);
  *(_BYTE *)(v9 + 40) |= 2u;
  *(_DWORD *)(v9 + 12) = (*(_DWORD *)(v9 + 24) + *(_DWORD *)(v9 + 12)) & ~*(_DWORD *)(v9 + 24);
  v2 = *(_DWORD *)(v9 + 12) - *(_DWORD *)(v9 + 4);
  v3 = *(_DWORD *)(v9 + 16) - *(_DWORD *)(v9 + 4);
  dword_80561A0 = (int)&loc_804E91F;
  JUMPOUT(v2, v3, &loc_8050CEA);
  *(_DWORD *)(v9 + 12) = *(_DWORD *)(v9 + 16);
  *(_DWORD *)(v9 + 8) = *(_DWORD *)(v9 + 12);
  v11 = v10;
  v12 = a1 + 56;
  v13 = a1 + 56;
  v4 = *(_DWORD *)(a1 + 72) - *(_DWORD *)(a1 + 68);
  dword_80561A0 = (int)&loc_804E98C;
  JUMPOUT(v4, 3, &loc_8050CEA);
  sub_804FD78(a1 + 56, 4);
  v14 = a1 + 56;
  v15 = *(_DWORD **)(a1 + 68);
  *v15 = v10;
  *(_DWORD *)(v14 + 12) += 4;
  v16 = a1 + 100;
  n = 4;
  v18 = a1 + 100;
  v5 = *(_DWORD *)(a1 + 116) - *(_DWORD *)(a1 + 112);
  dword_80561A0 = (int)&loc_804EA13;
  JUMPOUT(v5, 4, &loc_8050CEA);
  sub_804FD78(a1 + 100, 4);
  memcpy(*(void **)(a1 + 112), &src, 4u);
  *(_DWORD *)(v16 + 12) += n;
  result = a1;
  ++*(_DWORD *)a1;
  return result;
}
// 804FD78: using guessed type _DWORD __cdecl sub_804FD78(_DWORD, _DWORD);
// 80561A0: using guessed type int dword_80561A0;

//----- (0804EA5F) --------------------------------------------------------
bool __cdecl sub_804EA5F(FILE *stream, int a2)
{
  _BYTE *v2; // eax
  _BYTE *v3; // eax
  int v5; // [esp+14h] [ebp-44h]
  int v6; // [esp+18h] [ebp-40h]
  int v7; // [esp+1Ch] [ebp-3Ch]
  int v8; // [esp+20h] [ebp-38h]
  int v9; // [esp+24h] [ebp-34h]
  int v10; // [esp+28h] [ebp-30h]
  int v11; // [esp+2Ch] [ebp-2Ch]
  int v12; // [esp+30h] [ebp-28h]
  _DWORD *v13; // [esp+34h] [ebp-24h]
  int v14; // [esp+38h] [ebp-20h]
  int v15; // [esp+3Ch] [ebp-1Ch]
  int v16; // [esp+40h] [ebp-18h]
  int v17; // [esp+44h] [ebp-14h]
  int v18; // [esp+48h] [ebp-10h]
  int v19; // [esp+4Ch] [ebp-Ch]

  while ( 1 )
  {
    v5 = fgetc(stream);
    if ( v5 == -1 )
      break;
    v18 = a2 + 12;
    v19 = a2 + 12;
    if ( *(_DWORD *)(a2 + 28) == *(_DWORD *)(a2 + 24) )
      sub_804FD78(v18, 1);
    v3 = *(_BYTE **)(v18 + 12);
    *(_DWORD *)(v18 + 12) = v3 + 1;
    *v3 = v5;
    if ( !v5 )
      sub_804E832(a2);
  }
  v6 = a2 + 12;
  v7 = *(_DWORD *)(a2 + 24) - *(_DWORD *)(a2 + 20);
  if ( v7 )
  {
    v8 = a2 + 12;
    v9 = a2 + 12;
    if ( *(_DWORD *)(a2 + 28) == *(_DWORD *)(a2 + 24) )
      sub_804FD78(v8, 1);
    v2 = *(_BYTE **)(v8 + 12);
    *(_DWORD *)(v8 + 12) = v2 + 1;
    *v2 = 0;
    sub_804E832(a2);
    dword_8056184 = (int)&loc_804EBA6;
    sub_805101D();
  }
  v10 = a2 + 56;
  v11 = a2 + 56;
  if ( (unsigned int)(*(_DWORD *)(a2 + 72) - *(_DWORD *)(v11 + 12)) <= 3 )
    sub_804FD78(v10, 4);
  v12 = v10;
  v13 = *(_DWORD **)(v10 + 12);
  *v13 = 0;
  *(_DWORD *)(v12 + 12) += 4;
  v14 = a2 + 56;
  v15 = *(_DWORD *)(a2 + 64);
  if ( *(_DWORD *)(a2 + 68) == v15 )
    *(_BYTE *)(v14 + 40) |= 2u;
  *(_DWORD *)(v14 + 12) = (*(_DWORD *)(v14 + 24) + *(_DWORD *)(v14 + 12)) & ~*(_DWORD *)(v14 + 24);
  if ( *(_DWORD *)(v14 + 12) - *(_DWORD *)(v14 + 4) > (unsigned int)(*(_DWORD *)(v14 + 16) - *(_DWORD *)(v14 + 4)) )
    *(_DWORD *)(v14 + 12) = *(_DWORD *)(v14 + 16);
  *(_DWORD *)(v14 + 8) = *(_DWORD *)(v14 + 12);
  *(_DWORD *)(a2 + 4) = v15;
  v16 = a2 + 100;
  v17 = *(_DWORD *)(a2 + 108);
  if ( *(_DWORD *)(a2 + 112) == v17 )
    *(_BYTE *)(v16 + 40) |= 2u;
  *(_DWORD *)(v16 + 12) = (*(_DWORD *)(v16 + 24) + *(_DWORD *)(v16 + 12)) & ~*(_DWORD *)(v16 + 24);
  if ( *(_DWORD *)(v16 + 12) - *(_DWORD *)(v16 + 4) > (unsigned int)(*(_DWORD *)(v16 + 16) - *(_DWORD *)(v16 + 4)) )
    *(_DWORD *)(v16 + 12) = *(_DWORD *)(v16 + 16);
  *(_DWORD *)(v16 + 8) = *(_DWORD *)(v16 + 12);
  *(_DWORD *)(a2 + 8) = v17;
  return ferror(stream) == 0;
}
// 804FD78: using guessed type _DWORD __cdecl sub_804FD78(_DWORD, _DWORD);
// 805101D: using guessed type int sub_805101D(void);
// 8056184: using guessed type int dword_8056184;

//----- (0804ED96) --------------------------------------------------------
ssize_t __cdecl sub_804ED96(int fd, void *buf, size_t nbytes)
{
  int v4; // [esp+0h] [ebp-28h]
  ssize_t v5; // [esp+1Ch] [ebp-Ch]

  while ( 1 )
  {
    v5 = read(fd, buf, nbytes);
    if ( v5 >= 0 )
      break;
    if ( *__errno_location() != 4 )
    {
      if ( *__errno_location() != 22 || nbytes <= 0x7FFFE000 )
      {
        dword_8056148 = (int)&locret_804EE0B;
        sub_805116D(v4);
      }
      else
      {
        nbytes = 2147475456;
      }
    }
  }
  return v5;
}
// 805116D: using guessed type int __stdcall sub_805116D(_DWORD);
// 8056148: using guessed type int dword_8056148;

//----- (0804EE0D) --------------------------------------------------------
int __cdecl sub_804EE0D(FILE *stream, int a2, int a3, int a4, int a5, int a6)
{
  void *v6; // eax
  char *v7; // eax
  char *v8; // ebx
  char *v9; // eax
  int result; // eax
  int v11; // esi
  char *v12; // ebx
  char *v13; // eax
  int v14; // edi
  int v15; // esi
  char *v16; // ebx
  char *v17; // eax
  int v18; // edi
  int v19; // esi
  char *v20; // ebx
  char *v21; // eax
  int v22; // edi
  int v23; // esi
  char *v24; // ebx
  char *v25; // eax
  int v26; // edi
  int v27; // esi
  char *v28; // ebx
  char *v29; // eax
  int v30; // esi
  int v31; // edi
  char *v32; // ebx
  char *v33; // eax
  int v34; // edi
  int v35; // esi
  char *v36; // ebx
  char *v37; // eax
  int v38; // edi
  int v39; // esi
  char *v40; // ebx
  int v41; // edi
  int v42; // esi
  char *v43; // ebx
  char *v44; // eax
  int v45; // [esp+0h] [ebp-68h]
  char *v46; // [esp+4h] [ebp-64h]
  char *v47; // [esp+8h] [ebp-60h]
  int v48; // [esp+Ch] [ebp-5Ch]
  int v49; // [esp+10h] [ebp-58h]
  int v50; // [esp+14h] [ebp-54h]
  int v51; // [esp+18h] [ebp-50h]
  int v52; // [esp+1Ch] [ebp-4Ch]
  int v53; // [esp+20h] [ebp-48h]
  int v54; // [esp+24h] [ebp-44h]
  int v55; // [esp+28h] [ebp-40h]
  int v56; // [esp+2Ch] [ebp-3Ch]
  int v57; // [esp+30h] [ebp-38h]
  int v58; // [esp+34h] [ebp-34h]
  int v59; // [esp+38h] [ebp-30h]
  int v60; // [esp+3Ch] [ebp-2Ch]
  int v61; // [esp+40h] [ebp-28h]
  int v62; // [esp+44h] [ebp-24h]
  int v63; // [esp+48h] [ebp-20h]
  int v64; // [esp+4Ch] [ebp-1Ch]

  v6 = &loc_804EE35;
  if ( !a2 )
    v6 = &loc_804EE5F;
  dword_8056184 = (int)v6;
  sub_805101D();
  v49 = a4;
  fprintf(stream, "%s (%s) %s\n", a2, a3, a4);
  v48 = 2017;
  v47 = gettext("(C)");
  fprintf(stream, "Copyright %s %d Free Software Foundation, Inc.", v47, 2017);
  v7 = gettext(
         "\n"
         "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\n"
         "This is free software: you are free to change and redistribute it.\n"
         "There is NO WARRANTY, to the extent permitted by law.\n"
         "\n");
  fputs_unlocked(v7, stream);
  switch ( a6 )
  {
    case 0:
      abort();
      return result;
    case 1:
      v8 = *(char **)a5;
      v9 = gettext("Written by %s.\n");
      return fprintf(stream, v9, v8);
    case 2:
      v11 = *(_DWORD *)(a5 + 4);
      v12 = *(char **)a5;
      v13 = gettext("Written by %s and %s.\n");
      return fprintf(stream, v13, v12, v11);
    case 3:
      v14 = *(_DWORD *)(a5 + 8);
      v15 = *(_DWORD *)(a5 + 4);
      v16 = *(char **)a5;
      v17 = gettext("Written by %s, %s, and %s.\n");
      return fprintf(stream, v17, v16, v15, v14);
    case 4:
      v64 = *(_DWORD *)(a5 + 12);
      v18 = *(_DWORD *)(a5 + 8);
      v19 = *(_DWORD *)(a5 + 4);
      v20 = *(char **)a5;
      v21 = gettext("Written by %s, %s, %s,\nand %s.\n");
      v50 = v64;
      v49 = v18;
      v48 = v19;
      v47 = v20;
      return fprintf(stream, v21, v20, v19, v18, v64);
    case 5:
      v64 = *(_DWORD *)(a5 + 16);
      v63 = *(_DWORD *)(a5 + 12);
      v22 = *(_DWORD *)(a5 + 8);
      v23 = *(_DWORD *)(a5 + 4);
      v24 = *(char **)a5;
      v25 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
      v48 = v23;
      v47 = v24;
      return fprintf(stream, v25, v24, v23, v22, v63, v64);
    case 6:
      v64 = *(_DWORD *)(a5 + 20);
      v63 = *(_DWORD *)(a5 + 16);
      v62 = *(_DWORD *)(a5 + 12);
      v26 = *(_DWORD *)(a5 + 8);
      v27 = *(_DWORD *)(a5 + 4);
      v28 = *(char **)a5;
      v29 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
      return fprintf(stream, v29, v28, v27, v26, v62, v63, v64);
    case 7:
      v30 = *(_DWORD *)(a5 + 24);
      v64 = *(_DWORD *)(a5 + 20);
      v63 = *(_DWORD *)(a5 + 16);
      v62 = *(_DWORD *)(a5 + 12);
      v61 = *(_DWORD *)(a5 + 8);
      v31 = *(_DWORD *)(a5 + 4);
      v32 = *(char **)a5;
      v33 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
      v48 = v31;
      v47 = v32;
      return fprintf(stream, v33, v32, v31, v61, v62, v63, v64, v30);
    case 8:
      v34 = *(_DWORD *)(a5 + 28);
      v64 = *(_DWORD *)(a5 + 24);
      v63 = *(_DWORD *)(a5 + 20);
      v62 = *(_DWORD *)(a5 + 16);
      v61 = *(_DWORD *)(a5 + 12);
      v60 = *(_DWORD *)(a5 + 8);
      v35 = *(_DWORD *)(a5 + 4);
      v36 = *(char **)a5;
      v37 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
      v54 = v34;
      v53 = v64;
      v52 = v63;
      v51 = v62;
      v50 = v61;
      v49 = v60;
      v48 = v35;
      v47 = v36;
      return fprintf(stream, v37, v36, v35, v60, v61, v62, v63, v64, v34);
    case 9:
      v38 = *(_DWORD *)(a5 + 32);
      v64 = *(_DWORD *)(a5 + 28);
      v63 = *(_DWORD *)(a5 + 24);
      v62 = *(_DWORD *)(a5 + 20);
      v61 = *(_DWORD *)(a5 + 16);
      v60 = *(_DWORD *)(a5 + 12);
      v59 = *(_DWORD *)(a5 + 8);
      v39 = *(_DWORD *)(a5 + 4);
      v40 = *(char **)a5;
      v55 = v38;
      v54 = v64;
      v53 = v63;
      v52 = v62;
      v51 = v61;
      v50 = v60;
      v49 = v59;
      v48 = v39;
      v47 = v40;
      v46 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
      fprintf(stream, v46);
      dword_8056170 = (int)&loc_804F40D;
      sub_8051089(v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59);
      break;
    default:
      break;
  }
  v41 = *(_DWORD *)(a5 + 32);
  v64 = *(_DWORD *)(a5 + 28);
  v63 = *(_DWORD *)(a5 + 24);
  v62 = *(_DWORD *)(a5 + 20);
  v61 = *(_DWORD *)(a5 + 16);
  v60 = *(_DWORD *)(a5 + 12);
  v59 = *(_DWORD *)(a5 + 8);
  v42 = *(_DWORD *)(a5 + 4);
  v43 = *(char **)a5;
  v44 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
  v55 = v41;
  v54 = v64;
  v53 = v63;
  v52 = v62;
  v51 = v61;
  v50 = v60;
  v49 = v59;
  v48 = v42;
  v47 = v43;
  return fprintf(stream, v44, v43, v42, v59, v60, v61, v62, v63, v64, v41);
}
// 8049130: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 805101D: using guessed type int sub_805101D(void);
// 8051089: using guessed type int __stdcall sub_8051089(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8056170: using guessed type int dword_8056170;
// 8056184: using guessed type int dword_8056184;

//----- (0804F47D) --------------------------------------------------------
int __cdecl sub_804F47D(FILE *stream, int a2, int a3, int a4, int a5)
{
  int *v5; // eax
  unsigned int i; // [esp+24h] [ebp-34h]
  int v8[12]; // [esp+28h] [ebp-30h]

  for ( i = 0; i <= 9; ++i )
  {
    v5 = (int *)a5;
    a5 += 4;
    v8[i] = *v5;
    if ( !v8[i] )
      break;
  }
  return sub_804EE0D(stream, a2, a3, a4, (int)v8, i);
}
// 804F47D: using guessed type int var_30[12];

//----- (0804F4F3) --------------------------------------------------------
int sub_804F4F3(FILE *stream, int a2, int a3, int a4, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a4);
  return sub_804F47D(stream, a2, a3, a4, (int)va);
}

//----- (0804F5A3) --------------------------------------------------------
void *__cdecl sub_804F5A3(unsigned int a1, unsigned int a2)
{
  if ( 0x7FFFFFFF / a2 < a1 )
    sub_804F832();
  return sub_804F6C9(a2 * a1);
}

//----- (0804F606) --------------------------------------------------------
#error "804F62E: call analysis failed (funcsize=43)"

//----- (0804F6B6) --------------------------------------------------------
void *__cdecl sub_804F6B6(size_t size)
{
  return sub_804F6C9(size);
}

//----- (0804F6C9) --------------------------------------------------------
void *__cdecl sub_804F6C9(size_t size)
{
  void *v2; // [esp+1Ch] [ebp-Ch]

  v2 = malloc(size);
  if ( !v2 && size )
    sub_804F832();
  return v2;
}

//----- (0804F6F3) --------------------------------------------------------
void *__cdecl sub_804F6F3(void *ptr, size_t size)
{
  void *result; // eax
  void *ptra; // [esp+20h] [ebp+8h]

  if ( size || !ptr )
  {
    ptra = realloc(ptr, size);
    if ( !ptra )
    {
      if ( size )
        sub_804F832();
    }
    result = ptra;
  }
  else
  {
    free(ptr);
    result = 0;
  }
  return result;
}

//----- (0804F7E4) --------------------------------------------------------
void *__cdecl sub_804F7E4(void *src, size_t n)
{
  void *v2; // eax

  v2 = sub_804F6C9(n);
  return memcpy(v2, src, n);
}

//----- (0804F832) --------------------------------------------------------
void __noreturn sub_804F832()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (0804F86B) --------------------------------------------------------
void sub_804F86B()
{
  ;
}

//----- (0804F870) --------------------------------------------------------
void __cdecl sub_804F870(int a1, int a2)
{
  int v2; // eax

  sub_80500DF(a1, a2);
  if ( v2 < 0 )
    sub_804F86B();
}

//----- (0804F893) --------------------------------------------------------
int __cdecl sub_804F893(FILE *stream)
{
  int v2; // eax
  __int64 v3; // rax
  int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]

  v4 = 0;
  if ( fileno(stream) < 0 )
    return fclose(stream);
  if ( !__freading(stream) || (v2 = fileno(stream), LODWORD(v3) = lseek64(v2, 0, 0, 1), v3 != -1) )
  {
    if ( sub_804F98F(stream) )
      v4 = *__errno_location();
  }
  v5 = fclose(stream);
  if ( v4 )
  {
    *__errno_location() = v4;
    v5 = -1;
  }
  return v5;
}
// 8049260: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804F956) --------------------------------------------------------
int __cdecl sub_804F956(FILE *stream)
{
  int result; // eax

  result = stream->_flags & 0x100;
  if ( result )
    result = sub_804F9CF(stream, 0, 0, 1);
  return result;
}

//----- (0804F98F) --------------------------------------------------------
int __cdecl sub_804F98F(FILE *fp)
{
  if ( !fp || !__freading(fp) )
    return fflush(fp);
  sub_804F956(fp);
  return fflush(fp);
}

//----- (0804F9CF) --------------------------------------------------------
int __cdecl sub_804F9CF(FILE *stream, int a2, int a3, int a4)
{
  int v4; // eax
  __int64 v5; // rax
  int v7; // edx
  int v8; // [esp+18h] [ebp-20h]
  int v9; // [esp+1Ch] [ebp-1Ch]
  __int64 v10; // [esp+28h] [ebp-10h]

  v8 = a2;
  v9 = a3;
  if ( stream->_IO_read_end != stream->_IO_read_ptr
    || stream->_IO_write_ptr != stream->_IO_write_base
    || stream->_IO_save_base )
  {
    return fseeko64(stream, v8, v9, a4);
  }
  v4 = fileno(stream);
  LODWORD(v5) = lseek64(v4, v8, v9, a4);
  v10 = v5;
  if ( v5 == -1 )
    return -1;
  stream->_flags &= 0xFFFFFFEF;
  v7 = HIDWORD(v10);
  LODWORD(stream->_offset) = v10;
  HIDWORD(stream->_offset) = v7;
  return 0;
}
// 8048F80: using guessed type int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8049260: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804FAC9) --------------------------------------------------------
size_t __cdecl sub_804FAC9(wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  char v5; // [esp+18h] [ebp-10h]
  size_t v6; // [esp+1Ch] [ebp-Ch]

  if ( !pwc )
    pwc = (wchar_t *)&v5;
  v6 = mbrtowc(pwc, s, n, p);
  if ( v6 <= 0xFFFFFFFD || !n || !((unsigned __int8)sub_8050230(0) ^ 1) )
    return v6;
  *pwc = (unsigned __int8)*s;
  return 1;
}

//----- (0804FB3B) --------------------------------------------------------
int __cdecl sub_804FB3B(int a1, int a2)
{
  int result; // eax

  if ( *(_BYTE *)(a1 + 40) & 1 )
    result = (*(int (__cdecl **)(_DWORD, int))(a1 + 28))(*(_DWORD *)(a1 + 36), a2);
  else
    result = (*(int (__cdecl **)(int))(a1 + 28))(a2);
  return result;
}

//----- (0804FB79) --------------------------------------------------------
int __cdecl sub_804FB79(int a1, int a2)
{
  int result; // eax

  if ( *(_BYTE *)(a1 + 40) & 1 )
    result = (*(int (__cdecl **)(_DWORD, int))(a1 + 32))(*(_DWORD *)(a1 + 36), a2);
  else
    result = (*(int (__cdecl **)(int))(a1 + 32))(a2);
  return result;
}

//----- (0804FBB7) --------------------------------------------------------
#error "804FC43: call analysis failed (funcsize=87)"

//----- (0804FCCF) --------------------------------------------------------
int __cdecl sub_804FCCF(int a1, int a2, int a3, int a4, int a5)
{
  *(_DWORD *)(a1 + 28) = a4;
  *(_DWORD *)(a1 + 32) = a5;
  *(_BYTE *)(a1 + 40) &= 0xFEu;
  return sub_804FBB7(a1, a2, a3);
}
// 804FBB7: using guessed type _DWORD __cdecl sub_804FBB7(_DWORD, _DWORD, _DWORD);

//----- (0804FD78) --------------------------------------------------------
#error "804FEC7: call analysis failed (funcsize=123)"

//----- (0804FEF0) --------------------------------------------------------
#error "804FF6B: positive sp value has been found (funcsize=41)"

//----- (0804FFB0) --------------------------------------------------------
int __cdecl sub_804FFB0(int a1, unsigned int a2)
{
  int result; // eax
  int *v3; // ST1C_4
  int *v4; // [esp+18h] [ebp-10h]

  result = *(_DWORD *)(a1 + 4);
  v4 = *(int **)(a1 + 4);
  while ( v4 )
  {
    if ( (unsigned int)v4 < a2 )
    {
      result = *v4;
      if ( *v4 >= a2 )
        break;
    }
    v3 = (int *)v4[1];
    sub_804FB79(a1, (int)v4);
    v4 = v3;
    result = a1;
    *(_BYTE *)(a1 + 40) |= 2u;
  }
  if ( v4 )
  {
    *(_DWORD *)(a1 + 12) = a2;
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 16) = *v4;
    result = a1;
    *(_DWORD *)(a1 + 4) = v4;
  }
  else if ( a2 )
  {
    abort();
  }
  return result;
}

//----- (08050092) --------------------------------------------------------
void __noreturn sub_8050092()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  fprintf(stderr, "%s\n", v0);
  exit(status);
}

//----- (080500CB) --------------------------------------------------------
int sub_80500CB()
{
  return 0;
}

//----- (080500D5) --------------------------------------------------------
int sub_80500D5()
{
  return 0;
}

//----- (080500DF) --------------------------------------------------------
void __cdecl sub_80500DF(int a1, int a2)
{
  int v2; // ST14_4

  v2 = sub_80500D5();
  dword_80561A0 = (int)sub_8050130;
  JUMPOUT(v2, 0, &loc_8050CEA);
  sub_80500CB();
  dword_80561A0 = (int)&locret_8050133;
  JUMPOUT(&loc_8050CEA);
}
// 8050130: using guessed type int sub_8050130();
// 80561A0: using guessed type int dword_80561A0;

//----- (08050130) --------------------------------------------------------
#error "8050134: positive sp value has been found (funcsize=0)"

//----- (08050135) --------------------------------------------------------
int __cdecl sub_8050135(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // esi
  unsigned __int8 *v3; // ebx
  int v5; // [esp+0h] [ebp-28h]
  unsigned __int8 v6; // [esp+1Eh] [ebp-Ah]
  unsigned __int8 v7; // [esp+1Fh] [ebp-9h]

  v2 = a1;
  v3 = a2;
  if ( a1 == a2 )
  {
    dword_8056148 = (int)&loc_80501A8;
    sub_805116D(v5);
  }
  do
  {
    v6 = sub_8050ACB(*v2);
    v7 = sub_8050ACB(*v3);
    if ( !v6 )
      break;
    ++v2;
    ++v3;
  }
  while ( v6 == v7 );
  return v6 - v7;
}
// 805116D: using guessed type int __stdcall sub_805116D(_DWORD);
// 8056148: using guessed type int dword_8056148;

//----- (080501AF) --------------------------------------------------------
int __cdecl sub_80501AF(FILE *fp)
{
  bool v1; // ST1E_1
  bool v3; // [esp+1Dh] [ebp-Bh]
  bool v4; // [esp+1Fh] [ebp-9h]

  v3 = __fpending(fp) != 0;
  v1 = ferror_unlocked(fp) != 0;
  v4 = sub_804F893(fp) != 0;
  if ( !v1 && (!v4 || !v3 && *__errno_location() == 9) )
    return 0;
  if ( v4 != 1 )
    *__errno_location() = 0;
  return -1;
}

//----- (08050230) --------------------------------------------------------
int __cdecl sub_8050230(int category)
{
  unsigned __int8 v2; // [esp+1Bh] [ebp-Dh]
  const char *s1; // [esp+1Ch] [ebp-Ch]

  v2 = 1;
  s1 = setlocale(category, 0);
  if ( s1 && (!strcmp(s1, "C") || !strcmp(s1, "POSIX")) )
    v2 = 0;
  return v2;
}

//----- (0805028E) --------------------------------------------------------
void *sub_805028E()
{
  _BOOL4 v0; // eax
  void *v1; // eax
  int v3; // [esp+0h] [ebp-C8h]
  int v4; // [esp+4h] [ebp-C4h]
  int v5; // [esp+8h] [ebp-C0h]
  int v6; // [esp+Ch] [ebp-BCh]
  int v7; // [esp+10h] [ebp-B8h]
  void *v8; // [esp+18h] [ebp-B0h]
  const char *s; // [esp+1Ch] [ebp-ACh]
  void *v10; // [esp+20h] [ebp-A8h]
  int v11; // [esp+24h] [ebp-A4h]
  size_t n; // [esp+2Ch] [ebp-9Ch]
  size_t v13; // [esp+30h] [ebp-98h]
  _BOOL4 v14; // [esp+34h] [ebp-94h]
  char *dest; // [esp+38h] [ebp-90h]
  int fd; // [esp+3Ch] [ebp-8Ch]
  FILE *stream; // [esp+40h] [ebp-88h]
  int c; // [esp+44h] [ebp-84h]
  int v19; // [esp+48h] [ebp-80h]
  int v20; // [esp+4Ch] [ebp-7Ch]
  void *v21; // [esp+50h] [ebp-78h]
  int v22; // [esp+54h] [ebp-74h]
  int v23; // [esp+58h] [ebp-70h]
  int v24; // [esp+5Ch] [ebp-6Ch]
  int v25; // [esp+60h] [ebp-68h]
  int v26; // [esp+64h] [ebp-64h]
  int v27; // [esp+68h] [ebp-60h]
  int v28; // [esp+6Ch] [ebp-5Ch]
  int v29; // [esp+70h] [ebp-58h]
  int v30; // [esp+74h] [ebp-54h]
  int v31; // [esp+78h] [ebp-50h]
  int v32; // [esp+7Ch] [ebp-4Ch]
  int v33; // [esp+80h] [ebp-48h]
  int v34; // [esp+84h] [ebp-44h]
  int v35; // [esp+88h] [ebp-40h]

  v8 = (void *)dword_8056788;
  if ( !dword_8056788 )
  {
    s = getenv("CHARSETALIASDIR");
    if ( !s || !*s )
      s = "/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib";
    n = strlen(s);
    v13 = strlen("charset.alias");
    v0 = n && s[n - 1] != 47;
    v14 = v0;
    dest = (char *)malloc(n + v0 + v13 + 1);
    if ( dest )
    {
      memcpy(dest, s, n);
      if ( v14 )
        dest[n] = 47;
      memcpy(&dest[n + v14], "charset.alias", v13 + 1);
    }
    free(0);
    v1 = &loc_805045B;
    if ( dest )
      v1 = &loc_805046A;
    dword_8056134 = (int)v1;
    sub_80511E7(
      v3,
      v4,
      v5,
      v6,
      v7,
      0,
      v8,
      s,
      v10,
      v11,
      "charset.alias",
      n,
      v13,
      v14,
      dest,
      fd,
      stream,
      c,
      v19,
      v20,
      v21,
      v22,
      v23,
      v24,
      v25,
      v26,
      v27,
      v28,
      v29,
      v30,
      v31,
      v32,
      v33,
      v34,
      v35);
    v8 = &unk_805248F;
    dword_8056788 = (int)&unk_805248F;
  }
  return v8;
}
// 80511E7: using guessed type int __stdcall sub_80511E7(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8056134: using guessed type int dword_8056134;
// 8056788: using guessed type int dword_8056788;

//----- (080507F6) --------------------------------------------------------
const char *sub_80507F6()
{
  char *v0; // ST1C_4
  const char *s1; // [esp+18h] [ebp-10h]
  char *s2; // [esp+1Ch] [ebp-Ch]

  s1 = nl_langinfo(14);
  if ( !s1 )
    s1 = (const char *)&unk_805248F;
  for ( s2 = (char *)sub_805028E(); *s2; s2 = &v0[strlen(v0) + 1] )
  {
    if ( !strcmp(s1, s2) || *s2 == 42 && !s2[1] )
    {
      s1 = &s2[strlen(s2) + 1];
      break;
    }
    v0 = &s2[strlen(s2) + 1];
  }
  if ( !*s1 )
    s1 = "ASCII";
  return s1;
}

//----- (08050ACB) --------------------------------------------------------
int __cdecl sub_8050ACB(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 65) > 0x19 )
    result = a1;
  else
    result = a1 + 32;
  return result;
}

//----- (08050B07) --------------------------------------------------------
signed __int64 __cdecl sub_8050B07(unsigned __int64 a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // esi
  signed __int64 result; // rax
  int v5; // ebp
  int v6; // ebp
  unsigned int v7; // edi
  unsigned int v8; // edx
  unsigned int v9; // esi
  unsigned int v10; // edi
  unsigned __int64 v11; // rax
  unsigned int v12; // [esp+0h] [ebp-18h]
  unsigned int v13; // [esp+4h] [ebp-14h]
  unsigned int v14; // [esp+8h] [ebp-10h]

  v13 = a1;
  v12 = a2;
  if ( !a3 )
  {
    if ( a2 > HIDWORD(a1) )
      return (unsigned int)(a1 / a2);
    v3 = a2;
    if ( !a2 )
      v3 = 1 / 0u;
    LODWORD(result) = __PAIR__(HIDWORD(a1) % v3, (unsigned int)a1) / v3;
    HIDWORD(result) = HIDWORD(a1) / v3;
    return result;
  }
  if ( a3 > HIDWORD(a1) )
    return 0LL;
  _BitScanReverse((unsigned int *)&v5, a3);
  v6 = v5 ^ 0x1F;
  if ( !v6 )
  {
    if ( v12 <= v13 || a3 < HIDWORD(a1) )
      return 1LL;
    return 0LL;
  }
  v14 = (a3 << v6) | (v12 >> (32 - v6));
  v7 = (HIDWORD(a1) << v6) | (v13 >> (32 - v6));
  v8 = HIDWORD(a1) >> (32 - v6);
  v9 = __PAIR__(v8, v7) % v14;
  v10 = __PAIR__(v8, v7) / v14;
  v11 = (v12 << v6) * (unsigned __int64)v10;
  v12 = HIDWORD(v11);
  if ( v9 < HIDWORD(v11) || v13 << (char)&v12 < (unsigned int)v11 && v9 == v12 )
    result = v10 - 1;
  else
    result = v10;
  return result;
}

//----- (08050C5A) --------------------------------------------------------
int __cdecl sub_8050C5A(unsigned __int64 a1, __int64 a2)
{
  int v2; // edx
  int result; // eax
  int v4; // ebp
  int v5; // ebp
  unsigned int v6; // ebp
  unsigned __int64 v7; // rtt
  unsigned __int64 v8; // rax
  unsigned int v9; // edi
  unsigned __int64 v10; // rax
  unsigned int v11; // ecx
  unsigned int v12; // [esp+0h] [ebp-20h]
  unsigned int v13; // [esp+4h] [ebp-1Ch]
  unsigned __int64 v14; // [esp+8h] [ebp-18h]
  unsigned int v15; // [esp+10h] [ebp-10h]

  v13 = HIDWORD(a1);
  v15 = a1;
  v12 = a2;
  v14 = a1;
  if ( HIDWORD(a2) )
  {
    if ( HIDWORD(a2) > HIDWORD(a1) )
    {
      result = a1;
    }
    else
    {
      _BitScanReverse((unsigned int *)&v4, HIDWORD(a2));
      v5 = v4 ^ 0x1F;
      if ( v5 )
      {
        v13 = (HIDWORD(a2) << v5) | (v12 >> (32 - v5));
        LODWORD(v14) = v12 << v5;
        HIDWORD(v8) = HIDWORD(a1) >> (32 - v5);
        LODWORD(v8) = (HIDWORD(a1) << (char)&v12) | (v15 >> (32 - v5));
        HIDWORD(v14) = v15 << (char)&v12;
        v9 = v8 % v13;
        v10 = (v12 << v5) * (unsigned __int64)(unsigned int)(v8 / v13);
        v12 = HIDWORD(v10);
        v11 = v10;
        if ( v9 < HIDWORD(v10) || HIDWORD(v14) < (unsigned int)v10 && v9 == HIDWORD(v10) )
        {
          HIDWORD(v10) = v12;
          HIDWORD(v10) = (v10 - __PAIR__(v13, (unsigned int)v14)) >> 32;
          v11 = v10 - v14;
        }
        result = ((__PAIR__(v9, HIDWORD(v14)) - __PAIR__(HIDWORD(v10), v11)) >> 32 << (32 - (unsigned __int8)v5)) | ((HIDWORD(v14) - v11) >> (char)&v12);
      }
      else
      {
        if ( v12 <= (unsigned int)v14 || HIDWORD(a2) < HIDWORD(v14) )
          v14 = __PAIR__(v13, (unsigned int)a1) - a2;
        result = v14;
      }
    }
  }
  else
  {
    if ( (unsigned int)a2 <= HIDWORD(a1) )
    {
      v6 = a2;
      if ( !(_DWORD)a2 )
        v6 = 1 / 0u;
      LODWORD(v7) = a1;
      HIDWORD(v7) = v13 % v6;
      v2 = v7 % v6;
    }
    else
    {
      v2 = a1 % (unsigned int)a2;
    }
    result = v2;
  }
  return result;
}

//----- (08050E57) --------------------------------------------------------
int __cdecl sub_8050E57(int a1)
{
  return __cxa_atexit(a1, 0, dword_80561B8);
}
// 8049070: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 80561B8: using guessed type int dword_80561B8;

//----- (08050E86) --------------------------------------------------------
int __cdecl sub_8050E86(int a1, int a2)
{
  return __xstat64(3, a1, a2);
}
// 80492B0: using guessed type int __cdecl __xstat64(_DWORD, _DWORD, _DWORD);

//----- (08050EB5) --------------------------------------------------------
int __cdecl sub_8050EB5(int a1, int a2)
{
  return __fxstat64(3, a1, a2);
}
// 8049020: using guessed type int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD);

//----- (08050F7A) --------------------------------------------------------
#error "8050FB3: positive sp value has been found (funcsize=18)"

//----- (0805101D) --------------------------------------------------------
#error "8051023: positive sp value has been found (funcsize=0)"

//----- (08051089) --------------------------------------------------------
#error "805108F: positive sp value has been found (funcsize=0)"

//----- (080510F5) --------------------------------------------------------
#error "80510FB: positive sp value has been found (funcsize=0)"

//----- (0805116D) --------------------------------------------------------
#error "8051173: positive sp value has been found (funcsize=0)"

//----- (080511E7) --------------------------------------------------------
#error "80511ED: positive sp value has been found (funcsize=0)"

//----- (08051200) --------------------------------------------------------
int (**sub_8051200())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_8055EE8;
  v1 = &off_8055EEC - off_8055EE8;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_8055EE8[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 8055EE8: using guessed type int (*off_8055EE8[2])();
// 8055EEC: using guessed type int (*off_8055EEC)();

//----- (08051264) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 29 decompilation failure(s) on 140 function(s)"
