/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8049480();
// int unsetenv(const char *name);
// int raise(int sig);
// int strcmp(const char *s1, const char *s2);
// int __cdecl open64(_DWORD, _DWORD); weak
// int putc_unlocked(int c, FILE *stream);
// struct passwd *getpwuid(__uid_t uid);
// int printf(const char *format, ...);
// void longjmp(struct __jmp_buf_tag env[1], int val);
// int fflush(FILE *stream);
// void _exit(int status);
// int sigprocmask(int how, const sigset_t *set, sigset_t *oset);
// int dirfd(DIR *dirp);
// int __cdecl wcwidth(_DWORD); weak
// void *memmove(void *dest, const void *src, size_t n);
// int _setjmp(struct __jmp_buf_tag env[1]);
// void free(void *ptr);
// uintmax_t strtoumax(const char *nptr, char **endptr, int base);
// void *memcpy(void *dest, const void *src, size_t n);
// int clock_gettime(clockid_t clock_id, struct timespec *tp);
// int tolower(int c);
// int fclose(FILE *stream);
// int getc_unlocked(FILE *stream);
// __sighandler_t signal(int sig, __sighandler_t handler);
// int memcmp(const void *s1, const void *s2, size_t n);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// time_t mktime(struct tm *tp);
// struct tm *localtime_r(const time_t *timer, struct tm *tp);
// int fflush_unlocked(FILE *stream);
// char *textdomain(const char *domainname);
// ssize_t readlink(const char *path, char *buf, size_t len);
// int fnmatch(const char *pattern, const char *name, int flags);
// int iswprint(wint_t wc);
// int ioctl(int fd, unsigned int request, ...);
// int ferror_unlocked(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD); weak
// void tzset(void);
// size_t __ctype_get_mb_cur_max(void);
// char *strcpy(char *dest, const char *src);
// size_t __fpending(FILE *fp);
// size_t wcstombs(char *s, const wchar_t *pwcs, size_t n);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int gethostname(char *name, size_t len);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// void error(int status, int errnum, const char *format, ...);
// int strcoll(const char *s1, const char *s2);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// time_t timegm(struct tm *tp);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// char *strchr(const char *s, int c);
// char *getcwd(char *buf, size_t size);
// int fscanf(FILE *stream, const char *format, ...);
// size_t strlen(const char *s);
// int setenv(const char *name, const char *value, int replace);
// int fprintf(FILE *stream, const char *format, ...);
// int sigaddset(sigset_t *set, int signo);
// void *memset(void *s, int c, size_t n);
// int ungetc(int c, FILE *stream);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// int *__errno_location(void);
// __pid_t tcgetpgrp(int fd);
// int fileno(FILE *stream);
// int __cdecl stpncpy(_DWORD, _DWORD, _DWORD); weak
// unsigned int gnu_dev_major(unsigned __int64 dev);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// int __cdecl mempcpy(_DWORD, _DWORD, _DWORD); weak
// int sigemptyset(sigset_t *set);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// int toupper(int c);
// char *strrchr(const char *s, int c);
// size_t mbstowcs(wchar_t *pwcs, const char *s, size_t n);
// struct tm *gmtime_r(const time_t *timer, struct tm *tp);
// unsigned int gnu_dev_minor(unsigned __int64 dev);
// int sprintf(char *s, const char *format, ...);
// struct lconv *localeconv(void);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int readdir64(void); weak
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// char *bindtextdomain(const char *domainname, const char *dirname);
// int strncmp(const char *s1, const char *s2, size_t n);
// int isatty(int fd);
// void abort(void);
// int __cdecl __xstat64(_DWORD, _DWORD, _DWORD); weak
// int __cdecl __lxstat64(_DWORD, _DWORD, _DWORD); weak
// int close(int fd);
// int closedir(DIR *dirp);
// size_t strspn(const char *s, const char *accept);
// DIR *opendir(const char *name);
// struct group *getgrgid(__gid_t gid);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// void *calloc(size_t nmemb, size_t size);
// int putchar_unlocked(int c);
// int _gmon_start__(void); weak
void sub_8049BE3();
void sub_8049C00();
int sub_8049C10();
int sub_8049C80();
int sub_8049CA0();
void sub_8049CFF();
void sub_8049D1A();
int sub_8049D2A();
void sub_8049E0C();
void sub_8049E27();
int sub_8049E37();
void sub_8049F19();
void sub_8049F34();
signed int sub_8049F44();
signed int sub_8049FCE();
void sub_804A042();
void sub_804A05D();
int sub_804A06D();
int sub_804A0F7();
void sub_804A17D();
void sub_804A198();
int sub_804A1A8();
void sub_804A29F();
void sub_804A2BA();
int sub_804A2CA();
void sub_804A3C1();
void sub_804A3DC();
int sub_804A3EC();
void sub_804A4EA();
void sub_804A505();
int sub_804A515();
void sub_804A5F7();
void sub_804A612();
int sub_804A622();
int nullsub_3(void); // weak
int sub_804A680();
void sub_804A732();
void sub_804A74D();
int sub_804A75D();
int nullsub_4(void); // weak
int sub_804A7BB();
void sub_804A86D();
void sub_804A888();
int sub_804A898();
// int __usercall sub_804A94A@<eax>(void (__cdecl *a1)(int *)@<eax>);
void sub_804A996();
void sub_804A9B1();
int sub_804A9C1(void); // weak
int __fastcall sub_804AA06(int a1);
int nullsub_5(void); // weak
int sub_804AA38();
int sub_804AA7D();
// int __usercall sub_804AAD7@<eax>(void (__cdecl *a1)(const char *)@<eax>);
void sub_804AB23();
void sub_804AB3E();
int sub_804AB4E();
int sub_804ABD8();
void sub_804AC5E();
void sub_804AC79();
int sub_804AC89();
int sub_804AD13();
int __cdecl sub_804AD67(int a1);
int __cdecl sub_804AD7A(unsigned __int8 a1);
int __cdecl sub_804AD8C(_BYTE *a1);
int sub_804ADF9();
int sub_804AE24();
int __cdecl sub_804AE4F(char *s1); // idb
int __cdecl sub_804B0BA(int a1, int a2);
int __cdecl sub_804B0D9(int a1);
bool __cdecl sub_804B0E1(int a1);
int sub_804B0ED();
int __cdecl sub_804B0F7(int a1, int a2, int a3, int a4);
int __cdecl sub_804B1EA(_DWORD); // weak
int __stdcall sub_804B244(char *file); // idb
_DWORD __cdecl sub_804B2E2(_DWORD, _DWORD); // weak
_DWORD __cdecl sub_804B4E8(_DWORD); // weak
void sub_804B540();
signed int __cdecl sub_804B5E0(int a1);
int __fastcall sub_804B6DC(int a1, int a2);
int sub_804B7B8(); // weak
// int __usercall sub_804B7F2@<eax>(int a1@<ebp>, int a2@<edx>, int a3@<ecx>);
int __cdecl sub_804B80F(size_t maxlen, char *format, int); // idb
int __cdecl sub_804B9BD(size_t maxlen, char *format, int, int, int, int); // idb
int __cdecl sub_804BABC(int); // weak
int __cdecl sub_804BB18(_DWORD *a1, _DWORD *a2);
int sub_804BBF7(); // weak
void __cdecl sub_804BC06(void *ptr);
_BOOL4 __cdecl sub_804BC19(int a1, int a2, int a3, int a4);
void __cdecl sub_804BCE8(void *ptr);
int __fastcall sub_804BD16(int ecx0, int a2, int a1);
int sub_804BE20(); // weak
size_t sub_804BE2A();
size_t __fastcall sub_804BE4A(int a1, int a2);
int __cdecl sub_804BE91(int a1);
int sub_804BEA7();
int sub_804BEC2();
// int __usercall sub_804BFA2@<eax>(int edx0@<edx>, int a2@<ecx>, char a1);
int __fastcall sub_804C190(int a1, int a2);
int __fastcall sub_804C1A4(int a1, int a2);
int __cdecl main(int a1, char **a2);
// int __usercall sub_804C947@<eax>(int a1@<edx>, int a2@<ecx>, char *nptr);
int sub_804C9E0(void); // weak
int __cdecl sub_804CB06(int errnum, char *format, struct option *longopts, int *longind, int, int, int, int); // idb
_DWORD __cdecl sub_804DC44(_DWORD, _DWORD, _DWORD); // weak
_DWORD sub_804E03C(); // weak
int sub_804E0F8(void); // weak
void sub_804E56B();
int __cdecl sub_804E60A(int a1);
int __cdecl sub_804E63D(int, char *format, int); // idb
_DWORD *__cdecl sub_804E693(char *a1, char *s, int a3);
// unsigned int __usercall sub_804E729@<eax>(int a1@<ebx>, char *a2, int a3, unsigned __int8 a4);
_DWORD *__cdecl sub_804EF3E(int a1);
int __cdecl sub_804EF91(int, char *name); // idb
int __cdecl sub_804EFF1(char *name); // idb
__int64 __cdecl sub_804F0CE(__int64 a1);
int sub_804F0F8();
void __cdecl sub_804F110(void **a1);
int __fastcall sub_804F175(int a1, int a2);
_DWORD __cdecl sub_804F252(_DWORD); // weak
int __cdecl sub_804F29D(int a1, int a2, char a3);
int __cdecl sub_804F385(int a1, int a2);
int __cdecl sub_804F439(int a1, int a2);
int __cdecl sub_804F4F7(char *s); // idb
int sub_804F5A8(void); // weak
int __cdecl sub_805060F(int a1);
int __cdecl sub_8050639(char *path, int, int); // idb
void *__cdecl sub_80506A2(int a1, char *s);
int __cdecl sub_8050754(_BYTE *a1);
int __cdecl sub_8050775(char *s, int); // idb
int __cdecl sub_8050929(char *s1, char *s2); // idb
int __cdecl sub_80509E3(int *a1, int *a2, void (*a3)(void));
int __cdecl sub_8050A74(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD));
int __cdecl sub_8050AF0(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD));
_DWORD __cdecl sub_8050B6C(_DWORD, _DWORD); // weak
int __cdecl sub_8050C54(int a1, _DWORD *a2);
int __cdecl sub_8050C92(const char **a1, const char **a2, int (__cdecl *a3)(char *, char *));
int __cdecl sub_8051556(int a1, int a2);
int __cdecl sub_8051578(int a1, int a2);
int __cdecl sub_805159A(int a1, int a2);
int __cdecl sub_80515BC(int a1, int a2);
signed int __cdecl sub_80515DE(int a1, int a2);
signed int __cdecl sub_805164C(int a1, int a2);
int __cdecl sub_80517F6(int a1, _DWORD *a2);
int __cdecl sub_8051818(int a1, _DWORD *a2);
int __cdecl sub_805183A(_DWORD *a1, int a2);
int __cdecl sub_805185C(_DWORD *a1, int a2);
int __cdecl sub_805187E(int a1, _DWORD *a2);
int __cdecl sub_80518EC(int a1, _DWORD *a2);
int __cdecl sub_805195A(_DWORD *a1, int a2);
int __cdecl sub_80519DD(_DWORD *a1, int a2);
int __cdecl sub_8051A4B(const char **a1, const char **a2);
int __cdecl sub_8051A6D(const char **a1, const char **a2);
int __cdecl sub_8051A8F(const char **a1, const char **a2);
int __cdecl sub_8051AB1(const char **a1, const char **a2);
int __cdecl sub_8051AD3(const char **a1, const char **a2);
int __cdecl sub_8051B5A(const char **a1, const char **a2);
int __cdecl sub_8051BC8(const char **a1, const char **a2);
int __cdecl sub_8051C4F(const char **a1, const char **a2);
int __cdecl sub_8051CEF(char **a1, char **a2);
int __cdecl sub_8051D0D(char **a1, char **a2);
int __cdecl sub_8051D27(char **a1, char **a2);
int __cdecl sub_8051D41(char **a1, char **a2);
int __cdecl sub_8051DC0(char **a1, char **a2);
int sub_8051E26();
int sub_8051E7E(void); // weak
int sub_8052000(void); // weak
int __cdecl sub_805211B(int a1, int a2, unsigned __int8 a3, int a4, int a5, int a6);
// int __usercall sub_80521AF@<eax>(int a1@<ebx>);
// int __usercall sub_8052297@<eax>(int a1@<ebx>, char *s, int a3, int a4);
// int __usercall sub_805236B@<eax>(int a1@<ebx>, __uid_t uid, int a3, int a4);
// int __usercall sub_80523BE@<eax>(int a1@<ebx>, __gid_t gid, int a3, int a4);
// size_t __usercall sub_8052411@<eax>(int a1@<ebx>, char *a2, int a3);
// size_t __usercall sub_805248B@<eax>(int a1@<ebx>, __uid_t uid);
int __fastcall sub_80524BF(int a1, int a2);
int __cdecl sub_80524FA(int); // weak
int __fastcall sub_8052516(int a1, int a2, int a3, unsigned int a4);
int __cdecl sub_8052558(int, int); // weak
_DWORD __cdecl sub_80525CC(_DWORD); // weak
int __cdecl sub_8053280(int *a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __cdecl sub_8053380(int, int, int, int); // weak
// int __usercall sub_80534A6@<eax>(int a1@<ebp>, int a2@<edx>, int a3@<ecx>);
int sub_8053561(); // weak
_DWORD __cdecl sub_8053C12(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_8053D34(char *s, int); // idb
// int __usercall sub_8053E2F@<eax>(int a1@<ebx>, int a2, int a3, int a4, int a5, char a6, int a7, char *a8);
_DWORD __cdecl sub_8054304(_DWORD, _DWORD, _DWORD, _DWORD); // weak
size_t __fastcall sub_805448D(int a1, int a2);
int __cdecl sub_80544E9(_DWORD, _DWORD); // weak
int __cdecl sub_805462B(int, char *s, int, int, int, int, int); // idb
_DWORD __cdecl sub_805481E(_DWORD, _DWORD, _DWORD); // weak
bool __cdecl sub_80549C2(unsigned __int8 a1, int a2, int a3);
// bool __usercall sub_8054A3C@<al>(int a1@<edx>, int a2@<ecx>, int a3);
_DWORD __cdecl sub_8054A89(_DWORD, _DWORD); // weak
size_t __cdecl sub_8054EFE(int a1);
// int __usercall sub_8054F5E@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, int a4);
_DWORD sub_80551BE(); // weak
// int __usercall sub_80554C0@<eax>(int a1@<ecx>, int a2@<ebx>, char a3);
unsigned int __cdecl sub_80555A4(unsigned int a1, unsigned int a2);
_DWORD __cdecl sub_8055655(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl sub_80559A2(_DWORD); // weak
void __cdecl __noreturn sub_8055C9A(int status); // idb
// char *__usercall sub_805601F@<eax>(int a1@<edx>, int a2@<ecx>, char *path, int a4);
void __noreturn sub_8056148();
int __cdecl sub_805615C(char *s, int a2);
void __cdecl sub_80562C5(int a1, int a2, int a3);
int __cdecl sub_8056348(int, int, size_t n); // idb
int __cdecl sub_8056488(int, char *s, int, int, size_t n, int); // idb
signed int __cdecl sub_8056594(signed int a1);
_BOOL4 __cdecl sub_80565C4(signed int a1);
_BOOL4 __cdecl sub_8056648(int a1);
int __cdecl sub_8056780(int a1);
int __cdecl sub_80567B6(int, char *s, int); // idb
// int __usercall sub_8056852@<eax>(int a1@<ebx>, int a2, int a3);
int sub_805722F();
_DWORD __cdecl sub_8057328(_DWORD); // weak
void *__cdecl sub_80573C7(void *src);
_BYTE *__cdecl sub_805745E(_BYTE *a1);
size_t __cdecl sub_80574B9(char *s);
int sub_80574F7();
void __cdecl sub_8057501(int a1, char *s, int a3);
_DWORD __cdecl sub_80575BB(_DWORD, _DWORD, _DWORD); // weak
// signed int __usercall sub_8057657@<eax>(int a1@<edx>, int a2@<ecx>, __int16 a3);
// int __usercall sub_805772E@<eax>(int a1@<edx>, int a2@<ecx>, __int16 a3, _BYTE *a4);
int __cdecl sub_8057900(int a1, _BYTE *a2);
void *__cdecl sub_805791D(_BYTE *a1, _BYTE *a2, _DWORD *a3);
// _BYTE *__usercall sub_805794F@<eax>(int a1@<edx>, int a2@<ecx>, _BYTE *a3);
void *__cdecl sub_8057980(_BYTE *a1, _BYTE *a2, _DWORD *a3);
int __cdecl sub_8057B7D(unsigned __int8 a1);
signed int __cdecl sub_8057BCE(int a1, unsigned int a2, int a3, unsigned int a4);
int __cdecl sub_8057E73(char *s1, char *s2); // idb
struct timespec *__cdecl sub_805812A(struct timespec *tp);
int __cdecl sub_8058175(int category); // idb
int __cdecl sub_80581D3(int a1);
int __cdecl sub_80581DE(int a1);
int __cdecl sub_80581E9(int a1);
int __cdecl sub_805843E(_DWORD *a1, int a2);
// bool __usercall sub_80587A6@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3);
// int __usercall sub_8058812@<eax>(int a1@<edx>, int a2@<ecx>, unsigned int a3);
unsigned int __cdecl sub_80588A3(int a1, unsigned int a2);
bool __cdecl sub_80588CE(int a1, int a2);
signed int __cdecl sub_80588DC(int a1);
// unsigned int __usercall sub_8058998@<eax>(signed __int64 a1@<edx:eax>, int a2@<ecx>, unsigned int a3, int a4);
_DWORD __cdecl sub_8058A7E(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
void __cdecl sub_8058CC5(void *a1);
void *__cdecl sub_8058DB1(int a1);
int __cdecl sub_8058DEC(int a1, _DWORD *a2);
_DWORD __cdecl sub_8058E2F(_DWORD, _DWORD, _DWORD, _DWORD); // weak
signed int __cdecl sub_8059017(_DWORD *a1, int a2, char a3);
// signed int __usercall sub_80591B8@<eax>(signed __int64 a1@<edx:eax>, int a2@<ecx>, void **a3, unsigned int a4);
_DWORD __cdecl sub_8059401(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_80596EC(int a1, int a2);
_DWORD __cdecl sub_805972B(_DWORD, _DWORD); // weak
int __cdecl sub_80599B1(_DWORD *a1, unsigned int a2);
int __cdecl sub_8059BBF(int a1, int a2);
void __cdecl sub_8059C6F(void **a1);
// int __usercall sub_8059C95@<eax>(int a1@<edx>, int a2@<ecx>, int a3, long double a4);
// int __usercall sub_8059D5B@<eax>(int _EBP@<ebp>, int a2, int a3);
int __fastcall sub_8059E43(int a1, int a2);
double sub_8059E5D(); // weak
int __cdecl sub_8059EE8(int, size_t n, int, int); // idb
int __cdecl sub_805A051(int, int, char *s, int, int, int, int, int); // idb
__int64 sub_805AF3C();
int __cdecl sub_805AF6A(char *s, int, int); // idb
int __cdecl sub_805B12C(char *s, int, int); // idb
char *__cdecl sub_805B175(__uid_t uid);
int __cdecl sub_805B39D(__gid_t gid); // idb
int __cdecl sub_805B600(__int64 a1, int a2);
int __cdecl sub_805B77A(__int64 a1, int a2);
int __cdecl sub_805B834(wint_t *a1);
int __cdecl sub_805B877(_DWORD *a1, unsigned int a2);
_BYTE *__cdecl sub_805B8E3(_BYTE *a1, unsigned int a2, int a3);
int __cdecl sub_805B914(char *s); // idb
int __cdecl sub_805B98D(char *s, size_t n); // idb
// int __usercall sub_805BE22@<eax>(int a1@<ebx>, char *s, int a3);
// int __usercall sub_805BE4B@<eax>(int a1@<ebx>, char *a2, int a3, char a4);
_DWORD __cdecl sub_805C351(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD sub_805C655(); // weak
int __cdecl sub_805C689(int a1, int a2, int a3, int a4);
int __cdecl sub_805C6BE(int a1, int a2, int a3);
int __cdecl sub_805C6FE(int a1, int a2, int a3);
int __cdecl sub_805C73E(int a1, int a2);
int __cdecl sub_805C7AB(int a1, int a2, int a3, int a4, int a5, int a6);
_DWORD __cdecl sub_805C814(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
char *__cdecl sub_805F82E(char *s);
void *__cdecl sub_805F907(void *src);
int __cdecl sub_805F949(int a1);
int *__cdecl sub_805F975(int *a1, int a2);
_DWORD __cdecl sub_805F98F(_DWORD, _DWORD); // weak
_DWORD __cdecl sub_805FA93(_DWORD, _DWORD, _DWORD); // weak
// _DWORD *__userpurge sub_805FAED@<eax>(_DWORD *a1, int a2);
int __cdecl sub_805FBAF(char *msgid, int); // idb
// unsigned int __usercall sub_805FC89@<eax>(size_t a1@<ebx>, int a2, unsigned int a3, char *a4, size_t a5, signed int a6, int a7, int a8, char *a9, char *a10);
_DWORD __cdecl sub_8060C05(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
void *__cdecl sub_8060D19(char *a1, size_t a2, _DWORD *a3, int *a4);
_DWORD __cdecl sub_8060F19(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_80611FC(int a1, int a2);
int __cdecl sub_8061226(int a1, int a2, int a3);
int __cdecl sub_806129C(int a1, int a2, int a3);
int __cdecl sub_80612DA(int a1, int a2, int a3, int a4);
int __cdecl sub_8061317(int a1, int a2);
int __cdecl sub_8061372(int a1, int a2, char a3);
int __cdecl sub_806144C(int a1, char a2);
int __cdecl sub_8061485(int a1);
_DWORD __cdecl sub_80614C2(_DWORD, _DWORD); // weak
int __cdecl sub_80615FD(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_806177C(int a1, int a2, int a3);
int __cdecl sub_80617E7(int a1, int a2);
int __cdecl sub_8061809(int a1);
_BOOL4 __cdecl sub_8061824(void *src, void *a2);
void sub_8061A24();
signed int sub_8061A71();
signed int sub_8061A89();
// _DWORD *__userpurge sub_8061BC3@<eax>(_DWORD *a1, int a2);
_DWORD __cdecl sub_8061BEE(_DWORD, _DWORD); // weak
// _DWORD *__userpurge sub_8061C2E@<eax>(_DWORD *a1, int a2);
int __cdecl sub_8061CD9(int a1, int a2, int a3, int a4);
int __cdecl sub_8061D6B(FILE *stream, int, int, int, int, int); // idb
int __cdecl sub_80624E2(FILE *stream, int, int, int, int); // idb
int __cdecl sub_8062642(unsigned int a1, unsigned int a2);
int sub_8062681(); // weak
int __cdecl sub_8062692(void *ptr, int, int); // idb
int __cdecl sub_80626C7(void *ptr, int, int); // idb
void *__cdecl sub_8062777(size_t size);
void *__cdecl sub_806278A(size_t size);
int __cdecl sub_80627B4(void *ptr, size_t size); // idb
int __cdecl sub_806281C(void *ptr, int); // idb
void *__cdecl sub_80628A5(void *src, size_t n);
void *__cdecl sub_80628CE(char *s);
void __noreturn sub_80628F3();
int __cdecl sub_80629A9(int errnum, char *format, int, int); // idb
char *sub_8062B65();
int sub_8062B9E();
signed int __cdecl sub_8062C87(unsigned int *a1, unsigned int a2);
int __cdecl sub_8062CDB(unsigned int *a1, unsigned int a2, int a3);
// int __usercall sub_8062D11@<eax>(int a1@<edx>, int a2@<ecx>, char *nptr, int a4, int base, int a6, char *s);
int __fastcall sub_80631C5(int ecx0, int edx0, unsigned int a1, int a2, char a3);
// int __usercall sub_8063281@<eax>(int a1@<ebp>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_806329B@<eax>(int a1@<ebp>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_80632B5@<eax>(int a1@<ebp>, int edx0@<edx>, int ecx0@<ecx>, int a2, int a3, int a4);
int __cdecl sub_8063320(int errnum, char *format, int, int, int); // idb
void __fastcall __noreturn sub_806337B(int ecx0, int edx0, unsigned int a1, int a2, char a3, int a4, int a5);
_DWORD __cdecl sub_80633DE(_DWORD, _DWORD); // weak
// int __usercall sub_80634D4@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5);
// int __usercall sub_806351F@<eax>(int a1@<edx>, int a2@<ecx>, char *nptr, int a4, int base, int a6, char *s);
size_t __cdecl sub_80639A8(wchar_t *pwc, char *s, size_t n, mbstate_t *p);
int __cdecl sub_8063A1A(int a1, int a2);
int __cdecl sub_8063A58(int a1, int a2);
_DWORD __cdecl sub_8063BCF(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl sub_8063CBD(_DWORD, _DWORD); // weak
int __cdecl sub_8064089(int a1, int a2);
_BOOL4 __cdecl sub_80640BD(_DWORD *a1, _DWORD *a2);
char *__cdecl sub_806416F(void *dest, void *src, size_t n);
int __cdecl sub_806419B(char *s); // idb
_DWORD __cdecl sub_806425E(_DWORD, _DWORD); // weak
void *__cdecl sub_8064431(void *ptr);
char *sub_8064464();
int __cdecl sub_8064478(char *value); // idb
signed int __cdecl sub_80644AF(int a1);
signed int __cdecl sub_80644EC(int a1);
int __cdecl sub_80645BB(void *ptr); // idb
int __cdecl sub_806462F(int, time_t *timer, struct tm *tp); // idb
int __cdecl sub_80646D8(int, struct tm *tp); // idb
int __cdecl sub_8064986(int a1, char a2);
// int __usercall sub_8064B01@<eax>(int a1@<edx>, int a2@<ecx>, unsigned __int8 *a3, unsigned __int8 *a4);
int __cdecl sub_8064B94(FILE *fp); // idb
int __cdecl sub_8064C47(void *src); // idb
int sub_8064C78(); // weak
_DWORD __cdecl sub_8064C7D(_DWORD, _DWORD); // weak
void *sub_8064CD8();
_DWORD sub_80651FE(); // weak
int __cdecl sub_80652E3(FILE *stream); // idb
int __cdecl sub_80653BF(_DWORD *a1);
int __cdecl sub_80653F8(FILE *fp); // idb
_DWORD __cdecl sub_806544D(_DWORD, _DWORD); // weak
_DWORD __cdecl sub_8065579(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl sub_8065745(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl sub_80659B1(__int64, _DWORD, _DWORD); // weak
_DWORD __cdecl sub_8065B58(__int64, __int64); // weak
int __cdecl sub_8065DA9(int a1);
int __cdecl sub_8065DD8(int a1, int a2);
int __cdecl sub_8065E07(int a1, int a2);
int __cdecl sub_8065E36(int a1, int a2);
int __stdcall sub_8066034(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __fastcall sub_80660A0(_DWORD, _DWORD); // weak
int __stdcall sub_806610E(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __fastcall sub_806617E(_DWORD, _DWORD); // weak
int __fastcall sub_80661F2(_DWORD, _DWORD, _DWORD);
int __fastcall sub_806627B(_DWORD, _DWORD); // weak
int __stdcall sub_80662EB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_8066357(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_80663C3(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __fastcall sub_8066431(_DWORD, _DWORD, _DWORD, _DWORD);
int (**sub_8066450())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN locret_804ADF7; // weak
_UNKNOWN loc_804B583; // weak
_UNKNOWN loc_804B59B; // weak
_UNKNOWN loc_804B5BC; // weak
_UNKNOWN loc_804B6BF; // weak
_UNKNOWN loc_804B714; // weak
_UNKNOWN loc_804B73D; // weak
_UNKNOWN loc_804BA98; // weak
_UNKNOWN locret_804BABA; // weak
_UNKNOWN loc_804BBDF; // weak
_UNKNOWN loc_804BBFC; // weak
_UNKNOWN loc_804BDAA; // weak
_UNKNOWN loc_804BE08; // weak
_UNKNOWN loc_804BE25; // weak
_UNKNOWN loc_804BFD9; // weak
_UNKNOWN loc_804C07B; // weak
_UNKNOWN loc_804C112; // weak
_UNKNOWN loc_804C2E7; // weak
_UNKNOWN loc_804C2F7; // weak
_UNKNOWN loc_804C338; // weak
_UNKNOWN loc_804C33F; // weak
_UNKNOWN loc_804C419; // weak
_UNKNOWN loc_804C424; // weak
_UNKNOWN loc_804C46A; // weak
_UNKNOWN loc_804C489; // weak
_UNKNOWN loc_804C53C; // weak
_UNKNOWN loc_804C546; // weak
_UNKNOWN loc_804C690; // weak
_UNKNOWN loc_804C6A4; // weak
_UNKNOWN loc_804C9D9; // weak
_UNKNOWN loc_804E032; // weak
_UNKNOWN loc_804E97C; // weak
_UNKNOWN loc_804E9A3; // weak
_UNKNOWN loc_804E9BC; // weak
_UNKNOWN loc_804EAF6; // weak
_UNKNOWN loc_804EB53; // weak
_UNKNOWN loc_804EC19; // weak
_UNKNOWN loc_804EC95; // weak
_UNKNOWN loc_804ECCC; // weak
_UNKNOWN loc_804EDBC; // weak
_UNKNOWN loc_804EF16; // weak
_UNKNOWN loc_804F1BA; // weak
_UNKNOWN loc_804F37E; // weak
_UNKNOWN loc_804F4D8; // weak
_UNKNOWN loc_804F4EC; // weak
_UNKNOWN locret_8050A72; // weak
_UNKNOWN loc_8050CED; // weak
_UNKNOWN locret_80519DB; // weak
_UNKNOWN loc_8051B1F; // weak
_UNKNOWN loc_8051B26; // weak
_UNKNOWN loc_8051C2C; // weak
_UNKNOWN loc_8051C33; // weak
_UNKNOWN loc_8051C9B; // weak
_UNKNOWN loc_8051CA2; // weak
_UNKNOWN loc_8051CC6; // weak
_UNKNOWN loc_8051DA5; // weak
_UNKNOWN loc_8051DAC; // weak
_UNKNOWN loc_8052505; // weak
_UNKNOWN loc_8053320; // weak
_UNKNOWN loc_8053368; // weak
_UNKNOWN loc_8053385; // weak
_UNKNOWN loc_8053F14; // weak
_UNKNOWN loc_8053F36; // weak
_UNKNOWN loc_8053F76; // weak
_UNKNOWN loc_8054045; // weak
_UNKNOWN loc_80544B5; // weak
_UNKNOWN loc_80544C3; // weak
_UNKNOWN loc_8054A1A; // weak
_UNKNOWN loc_8054A33; // weak
_UNKNOWN loc_805500D; // weak
_UNKNOWN loc_80550B8; // weak
_UNKNOWN loc_80550D3; // weak
_UNKNOWN loc_8055FF9; // weak
_UNKNOWN loc_8056000; // weak
_UNKNOWN loc_8056071; // weak
_UNKNOWN loc_805620D; // weak
_UNKNOWN loc_8056215; // weak
_UNKNOWN loc_805639F; // weak
_UNKNOWN loc_80563D7; // weak
_UNKNOWN loc_8056A2B; // weak
_UNKNOWN loc_8056B8E; // weak
_UNKNOWN loc_8056BDC; // weak
_UNKNOWN loc_8056BFF; // weak
_UNKNOWN loc_8056DAA; // weak
_UNKNOWN loc_8056DC6; // weak
_UNKNOWN loc_8056ED1; // weak
_UNKNOWN loc_8056EE2; // weak
_UNKNOWN loc_805716A; // weak
_UNKNOWN loc_8057195; // weak
_UNKNOWN locret_8057209; // weak
_UNKNOWN loc_805727E; // weak
_UNKNOWN loc_8057304; // weak
_UNKNOWN locret_805745C; // weak
_UNKNOWN loc_805772C; // weak
_UNKNOWN loc_80577D9; // weak
_UNKNOWN loc_80578A8; // weak
_UNKNOWN loc_8057954; // weak
_UNKNOWN loc_805797B; // weak
_UNKNOWN loc_8057C26; // weak
_UNKNOWN loc_8057C53; // weak
_UNKNOWN loc_8057C58; // weak
_UNKNOWN loc_8057C7C; // weak
_UNKNOWN loc_8057C94; // weak
_UNKNOWN loc_8057CCD; // weak
_UNKNOWN loc_8057D21; // weak
_UNKNOWN loc_8057D4D; // weak
_UNKNOWN loc_8057E0C; // weak
_UNKNOWN loc_8057E13; // weak
_UNKNOWN locret_8057E71; // weak
_UNKNOWN loc_80587E5; // weak
_UNKNOWN locret_8058A7C; // weak
_UNKNOWN loc_80591F5; // weak
_UNKNOWN loc_8059211; // weak
_UNKNOWN loc_80593E8; // weak
_UNKNOWN loc_80593ED; // weak
_UNKNOWN locret_80593FF; // weak
_UNKNOWN loc_8059CC9; // weak
_UNKNOWN loc_8059DB5; // weak
_UNKNOWN loc_8059DFC; // weak
_UNKNOWN loc_8059E45; // weak
_UNKNOWN loc_8059E62; // weak
_UNKNOWN loc_8059EBD; // weak
_UNKNOWN loc_805AF96; // weak
_UNKNOWN loc_805AFC4; // weak
_UNKNOWN loc_805AFEB; // weak
_UNKNOWN loc_805B0A5; // weak
_UNKNOWN loc_805B0EE; // weak
_UNKNOWN loc_805B111; // weak
_UNKNOWN loc_805B63B; // weak
_UNKNOWN loc_805B6DE; // weak
_UNKNOWN loc_805BED9; // weak
_UNKNOWN loc_805BEF5; // weak
_UNKNOWN loc_805BF98; // weak
_UNKNOWN loc_805BFB9; // weak
_UNKNOWN loc_805C0A6; // weak
_UNKNOWN loc_805C14D; // weak
_UNKNOWN loc_805F971; // weak
_UNKNOWN loc_805FD42; // weak
_UNKNOWN loc_805FD8A; // weak
_UNKNOWN loc_805FDA1; // weak
_UNKNOWN loc_805FF76; // weak
_UNKNOWN loc_805FFAF; // weak
_UNKNOWN loc_805FFF8; // weak
_UNKNOWN loc_8060078; // weak
_UNKNOWN loc_80600D1; // weak
_UNKNOWN loc_806019A; // weak
_UNKNOWN loc_8060228; // weak
_UNKNOWN loc_8060238; // weak
_UNKNOWN loc_806027A; // weak
_UNKNOWN loc_806029D; // weak
_UNKNOWN loc_8060341; // weak
_UNKNOWN loc_806034E; // weak
_UNKNOWN loc_80604BB; // weak
_UNKNOWN loc_80604D6; // weak
_UNKNOWN loc_80604F5; // weak
_UNKNOWN loc_8060525; // weak
_UNKNOWN loc_8060632; // weak
_UNKNOWN loc_806066D; // weak
_UNKNOWN loc_80606A6; // weak
_UNKNOWN loc_8060778; // weak
_UNKNOWN loc_806081D; // weak
_UNKNOWN loc_8060841; // weak
_UNKNOWN loc_8060860; // weak
_UNKNOWN loc_8060884; // weak
_UNKNOWN loc_80608D6; // weak
_UNKNOWN loc_8060985; // weak
_UNKNOWN loc_80609C2; // weak
_UNKNOWN loc_8060A43; // weak
_UNKNOWN loc_8060A48; // weak
_UNKNOWN loc_8060B71; // weak
_UNKNOWN loc_8060BED; // weak
_UNKNOWN loc_8060E6D; // weak
_UNKNOWN loc_8060E78; // weak
_UNKNOWN loc_806250A; // weak
_UNKNOWN locret_8062C85; // weak
_UNKNOWN loc_8062D49; // weak
_UNKNOWN loc_8062D74; // weak
_UNKNOWN loc_8062D96; // weak
_UNKNOWN loc_8062DDA; // weak
_UNKNOWN loc_8062E9A; // weak
_UNKNOWN loc_8062EBC; // weak
_UNKNOWN loc_8062F89; // weak
_UNKNOWN loc_8062F90; // weak
_UNKNOWN loc_8063183; // weak
_UNKNOWN locret_80631C3; // weak
_UNKNOWN loc_8063265; // weak
_UNKNOWN loc_806327C; // weak
_UNKNOWN loc_80632BC; // weak
_UNKNOWN loc_8063332; // weak
_UNKNOWN loc_806350D; // weak
_UNKNOWN loc_8063581; // weak
_UNKNOWN loc_80636A7; // weak
_UNKNOWN loc_80636BD; // weak
_UNKNOWN locret_80639A6; // weak
_UNKNOWN locret_8063AA9; // weak
_UNKNOWN loc_8064579; // weak
_UNKNOWN loc_806457E; // weak
_UNKNOWN locret_806462D; // weak
_UNKNOWN loc_8064742; // weak
_UNKNOWN loc_806476E; // weak
_UNKNOWN loc_80647A0; // weak
_UNKNOWN loc_80647A6; // weak
_UNKNOWN loc_8064B2F; // weak
_UNKNOWN loc_8064B81; // weak
_UNKNOWN loc_8064B8D; // weak
_UNKNOWN loc_8064DAF; // weak
_UNKNOWN loc_8064DCE; // weak
_UNKNOWN loc_806501C; // weak
_UNKNOWN loc_8065021; // weak
_UNKNOWN loc_8065343; // weak
_UNKNOWN loc_806537C; // weak
char locale = '\0'; // idb
_UNKNOWN unk_806795C; // weak
_UNKNOWN unk_8067961; // weak
int sig[12] = { 20, 14, 1, 2, 13, 3, 15, 29, 27, 26, 24, 25 }; // idb
_UNKNOWN unk_806ACE0; // weak
char *off_806ADB4[2] = { "human-readable", "si" }; // weak
int dword_806ADC0[2] = { 176, 144 }; // idb
_UNKNOWN unk_806AE44; // weak
char *off_806B118[10] =
{
  "literal",
  "shell",
  "shell-always",
  "shell-escape",
  "shell-escape-always",
  "c",
  "c-maybe",
  "escape",
  "locale",
  "clocale"
}; // weak
int dword_806B158[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; // idb
_UNKNOWN unk_806B19D; // weak
_UNKNOWN unk_806BA85; // weak
_UNKNOWN unk_806BCF3; // weak
int dword_806CF04 = 89001504; // weak
_UNKNOWN unk_806D3AC; // weak
_UNKNOWN unk_806D3AF; // weak
_UNKNOWN unk_806E3B8; // weak
_UNKNOWN unk_806E3BB; // weak
_UNKNOWN unk_807041C; // weak
_UNKNOWN unk_807041F; // weak
int (*off_8071ED0[2])() = { &sub_8049CA0, &sub_8049C80 }; // weak
int (*off_8071ED4)() = &sub_8049C80; // weak
int (*dword_8072008)(void) = NULL; // weak
int dword_80721DC = 0; // weak
int dword_80721F0 = 0; // weak
int dword_8072204 = 0; // weak
int dword_8072218 = 0; // weak
int dword_807222C = 0; // weak
int dword_8072240 = 0; // weak
int dword_8072254 = 0; // weak
int dword_8072268 = 0; // weak
int dword_807227C = 0; // weak
int dword_8072290 = 0; // weak
int (__fastcall *dword_80722B8)(_DWORD, _DWORD) = NULL; // weak
int dword_80722D0 = 0; // weak
_UNKNOWN unk_80722EC; // weak
int dword_807230C[] = { 2 }; // weak
void *s1 = &unk_806795C; // idb
int dword_8072314 = 1; // weak
void *off_8072318 = &unk_806795F; // weak
_UNKNOWN unk_807231C; // weak
int dword_8072320 = 0; // weak
_UNKNOWN unk_807232C; // weak
char *off_80723CC = "%b %e  %Y"; // idb
char byte_80723D4 = '\x01'; // weak
int dword_80723D8 = 4294967295; // weak
int dword_8072414 = 1; // weak
int status = 1; // idb
_UNKNOWN unk_807244C; // weak
_UNKNOWN unk_807246C; // weak
_UNKNOWN unk_807246F; // weak
_UNKNOWN unk_8072470; // weak
_UNKNOWN unk_8072473; // weak
_UNKNOWN unk_8072474; // weak
_UNKNOWN unk_8072477; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int program_invocation_name; // weak
FILE *stdout; // idb
char byte_80724CC; // weak
char byte_80725B3; // weak
char byte_8072600; // weak
_UNKNOWN unk_80726EB; // weak
char byte_8072868; // weak
char byte_80728B5; // weak
char byte_80728E2; // weak
void *dword_80728F6; // idb
void *dword_80728FA; // idb
int dword_80728FE; // idb
int dword_8072902; // weak
char byte_8072906; // weak
char byte_8072907; // weak
void *dword_807290A; // idb
char byte_8072912; // weak
char *s; // idb
int dword_807291A; // weak
struct timespec tp; // idb
char byte_8072926; // weak
char byte_8072927; // weak
int dword_807292A; // weak
int dword_807292E; // weak
int dword_8072932; // weak
int dword_8072936; // idb
int dword_807293A; // idb
int dword_807293E; // idb
int dword_8072942; // idb
int dword_8072946; // weak
int dword_807294A; // weak
int dword_807294E; // weak
int dword_8072952; // weak
int dword_807295A; // weak
char byte_8072960; // weak
char byte_8072961; // weak
int dword_8072962; // idb
int dword_8072966; // idb
int dword_807296A; // idb
char byte_8072972; // weak
int dword_8072976; // weak
char byte_807297A; // weak
char byte_807297B; // weak
char byte_807297C; // weak
char byte_8072986; // weak
char byte_8072987; // weak
int dword_807298A; // weak
char byte_807298E; // weak
char byte_807298F; // weak
char byte_8072990; // weak
int dword_8072996; // idb
char byte_807299E; // weak
int dword_80729A2; // weak
int dword_80729A6; // weak
int dword_80729AA; // weak
char byte_80729AE; // weak
int dword_80729B2; // weak
int dword_80729B6; // idb
char byte_80729BA; // weak
char byte_80729BB; // weak
sigset_t set; // idb
int dword_8072A56; // weak
int dword_8072A5A; // weak
int dword_8072A5E; // weak
int dword_8072A6A; // weak
_UNKNOWN unk_8072A76; // weak
_UNKNOWN unk_8072AB6; // weak
_UNKNOWN unk_8072AF6; // weak
int dword_8072B02; // weak
char byte_8073836; // weak
struct __jmp_buf_tag env[1]; // idb
__int64 qword_80738F6; // weak
__int64 qword_80738FE; // weak
__int64 qword_8073906; // weak
int dword_8073912; // weak
char byte_8073916; // weak
int dword_807391A; // weak
int dword_807392A; // weak
int dword_8073936; // weak
int dword_807393A; // weak
int dword_807393E; // weak
int dword_8073942; // weak
int dword_8073946; // weak
int dword_807394A; // weak
int dword_807394E; // weak
int dword_8073952; // weak
int dword_8073956; // weak
int dword_807395A; // weak
int dword_807395E; // weak
int dword_8073962; // weak
int dword_8073A76; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (0804945C) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 8049BA0: using guessed type int _gmon_start__(void);

//----- (08049480) --------------------------------------------------------
int sub_8049480()
{
  return dword_8072008();
}
// 8072008: using guessed type int (*dword_8072008)(void);

//----- (08049BB0) --------------------------------------------------------
#error "8049BB3: positive sp value has been found (funcsize=2)"

//----- (08049BE3) --------------------------------------------------------
void sub_8049BE3()
{
  ;
}

//----- (08049C00) --------------------------------------------------------
void sub_8049C00()
{
  ;
}

//----- (08049C10) --------------------------------------------------------
int sub_8049C10()
{
  int result; // eax

  result = 134685827 - (_DWORD)&program_invocation_short_name;
  if ( (unsigned int)(134685827 - (_DWORD)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 8049C10: could not find valid save-restore pair for ebp
// 8072480: using guessed type int program_invocation_short_name;

//----- (08049C80) --------------------------------------------------------
int sub_8049C80()
{
  int result; // eax

  if ( !byte_80724CC )
  {
    result = sub_8049C10();
    byte_80724CC = 1;
  }
  return result;
}
// 8049C80: could not find valid save-restore pair for ebp
// 80724CC: using guessed type char byte_80724CC;

//----- (08049CA0) --------------------------------------------------------
int sub_8049CA0()
{
  return 0;
}
// 8049CA0: could not find valid save-restore pair for ebp

//----- (08049CFF) --------------------------------------------------------
void sub_8049CFF()
{
  ;
}

//----- (08049D1A) --------------------------------------------------------
void sub_8049D1A()
{
  ;
}

//----- (08049D2A) --------------------------------------------------------
int sub_8049D2A()
{
  int result; // eax

  result = &unk_807246F - &unk_807246C;
  if ( (unsigned int)(&unk_807246F - &unk_807246C) > 6 )
    result = 0;
  return result;
}
// 8049D2A: could not find valid save-restore pair for ebp

//----- (08049E0C) --------------------------------------------------------
void sub_8049E0C()
{
  ;
}

//----- (08049E27) --------------------------------------------------------
void sub_8049E27()
{
  ;
}

//----- (08049E37) --------------------------------------------------------
int sub_8049E37()
{
  int result; // eax

  result = &unk_807246F - &unk_807246C;
  if ( (unsigned int)(&unk_807246F - &unk_807246C) > 6 )
    result = 0;
  return result;
}
// 8049E37: could not find valid save-restore pair for ebp

//----- (08049F19) --------------------------------------------------------
void sub_8049F19()
{
  ;
}

//----- (08049F34) --------------------------------------------------------
void sub_8049F34()
{
  ;
}

//----- (08049F44) --------------------------------------------------------
signed int sub_8049F44()
{
  return 3;
}
// 8049F44: could not find valid save-restore pair for ebp

//----- (08049FCE) --------------------------------------------------------
signed int sub_8049FCE()
{
  signed int result; // eax

  result = sub_8049F44();
  byte_80725B3 = 1;
  return result;
}
// 80725B3: using guessed type char byte_80725B3;

//----- (0804A042) --------------------------------------------------------
void sub_804A042()
{
  ;
}

//----- (0804A05D) --------------------------------------------------------
void sub_804A05D()
{
  ;
}

//----- (0804A06D) --------------------------------------------------------
int sub_804A06D()
{
  int result; // eax

  result = &unk_807246F - &unk_807246C;
  if ( (unsigned int)(&unk_807246F - &unk_807246C) > 6 )
    result = 0;
  return result;
}
// 804A06D: could not find valid save-restore pair for ebp

//----- (0804A0F7) --------------------------------------------------------
int sub_804A0F7()
{
  int result; // eax

  result = sub_804A06D();
  byte_8072600 = 1;
  return result;
}
// 8072600: using guessed type char byte_8072600;

//----- (0804A17D) --------------------------------------------------------
void sub_804A17D()
{
  ;
}

//----- (0804A198) --------------------------------------------------------
void sub_804A198()
{
  ;
}

//----- (0804A1A8) --------------------------------------------------------
int sub_804A1A8()
{
  int result; // eax

  result = &unk_807041F - &unk_807041C;
  if ( (unsigned int)(&unk_807041F - &unk_807041C) > 6 )
    result = 0;
  return result;
}
// 804A1A8: could not find valid save-restore pair for ebp

//----- (0804A29F) --------------------------------------------------------
void sub_804A29F()
{
  ;
}

//----- (0804A2BA) --------------------------------------------------------
void sub_804A2BA()
{
  ;
}

//----- (0804A2CA) --------------------------------------------------------
int sub_804A2CA()
{
  int result; // eax

  result = &unk_807246F - &unk_807246C;
  if ( (unsigned int)(&unk_807246F - &unk_807246C) > 6 )
    result = 0;
  return result;
}
// 804A2CA: could not find valid save-restore pair for ebp

//----- (0804A3C1) --------------------------------------------------------
void sub_804A3C1()
{
  ;
}

//----- (0804A3DC) --------------------------------------------------------
void sub_804A3DC()
{
  ;
}

//----- (0804A3EC) --------------------------------------------------------
int sub_804A3EC()
{
  int result; // eax

  result = &unk_807246F - &unk_807246C;
  if ( (unsigned int)(&unk_807246F - &unk_807246C) > 6 )
    result = 0;
  return result;
}
// 804A3EC: could not find valid save-restore pair for ebp

//----- (0804A4EA) --------------------------------------------------------
void sub_804A4EA()
{
  ;
}

//----- (0804A505) --------------------------------------------------------
void sub_804A505()
{
  ;
}

//----- (0804A515) --------------------------------------------------------
int sub_804A515()
{
  int result; // eax

  result = &unk_80726EB - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_80726EB - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 804A515: could not find valid save-restore pair for ebp
// 8072480: using guessed type int program_invocation_short_name;

//----- (0804A5F7) --------------------------------------------------------
void sub_804A5F7()
{
  ;
}

//----- (0804A612) --------------------------------------------------------
void sub_804A612()
{
  ;
}

//----- (0804A622) --------------------------------------------------------
int sub_804A622()
{
  int result; // eax

  result = &unk_807246F - &unk_807246C;
  if ( (unsigned int)(&unk_807246F - &unk_807246C) > 6 )
    result = 0;
  return result;
}
// 804A622: could not find valid save-restore pair for ebp

//----- (0804A680) --------------------------------------------------------
int sub_804A680()
{
  return nullsub_3();
}
// 804A680: could not find valid save-restore pair for ebp
// 804A67F: using guessed type int nullsub_3(void);

//----- (0804A732) --------------------------------------------------------
void sub_804A732()
{
  ;
}

//----- (0804A74D) --------------------------------------------------------
void sub_804A74D()
{
  ;
}

//----- (0804A75D) --------------------------------------------------------
int sub_804A75D()
{
  int result; // eax

  result = &unk_806E3BB - &unk_806E3B8;
  if ( (unsigned int)(&unk_806E3BB - &unk_806E3B8) > 6 )
    result = 0;
  return result;
}
// 804A75D: could not find valid save-restore pair for ebp

//----- (0804A7BB) --------------------------------------------------------
int sub_804A7BB()
{
  return nullsub_4();
}
// 804A7BB: could not find valid save-restore pair for ebp
// 804A7BA: using guessed type int nullsub_4(void);

//----- (0804A86D) --------------------------------------------------------
void sub_804A86D()
{
  ;
}

//----- (0804A888) --------------------------------------------------------
void sub_804A888()
{
  ;
}

//----- (0804A898) --------------------------------------------------------
int sub_804A898()
{
  int result; // eax

  result = &unk_806D3AF - &unk_806D3AC;
  if ( (unsigned int)(&unk_806D3AF - &unk_806D3AC) > 6 )
    result = 0;
  return result;
}
// 804A898: could not find valid save-restore pair for ebp

//----- (0804A94A) --------------------------------------------------------
int __usercall sub_804A94A@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  a1(&dword_806CF04);
  return 0;
}
// 806CF04: using guessed type int dword_806CF04;

//----- (0804A996) --------------------------------------------------------
void sub_804A996()
{
  ;
}

//----- (0804A9B1) --------------------------------------------------------
void sub_804A9B1()
{
  ;
}

//----- (0804A9C1) --------------------------------------------------------
#error "804A9EE: call analysis failed (funcsize=23)"

//----- (0804AA06) --------------------------------------------------------
int __fastcall sub_804AA06(int a1)
{
  dword_8072254 = (int)nullsub_5;
  sub_806617E(a1, 0);
  return nullsub_5();
}
// 804AA37: using guessed type int nullsub_5(void);
// 806617E: using guessed type int __fastcall sub_806617E(_DWORD, _DWORD);
// 8072254: using guessed type int dword_8072254;

//----- (0804AA38) --------------------------------------------------------
int sub_804AA38()
{
  return nullsub_5();
}
// 804AA38: could not find valid save-restore pair for ebp
// 804AA37: using guessed type int nullsub_5(void);

//----- (0804AA7D) --------------------------------------------------------
int sub_804AA7D()
{
  int result; // eax

  result = sub_804A9C1();
  byte_8072868 = 1;
  return result;
}
// 804A9C1: using guessed type int sub_804A9C1(void);
// 8072868: using guessed type char byte_8072868;

//----- (0804AAD7) --------------------------------------------------------
int __usercall sub_804AAD7@<eax>(void (__cdecl *a1)(const char *)@<eax>)
{
  int v1; // ecx

  a1("too large");
  return sub_804AA06(v1);
}

//----- (0804AB23) --------------------------------------------------------
void sub_804AB23()
{
  ;
}

//----- (0804AB3E) --------------------------------------------------------
void sub_804AB3E()
{
  ;
}

//----- (0804AB4E) --------------------------------------------------------
int sub_804AB4E()
{
  int result; // eax

  result = &unk_8072473 - &unk_8072470;
  if ( (unsigned int)(&unk_8072473 - &unk_8072470) > 6 )
    result = 0;
  return result;
}
// 804AB4E: could not find valid save-restore pair for ebp

//----- (0804ABD8) --------------------------------------------------------
int sub_804ABD8()
{
  int result; // eax

  result = sub_804AB4E();
  byte_80728B5 = 1;
  return result;
}
// 80728B5: using guessed type char byte_80728B5;

//----- (0804AC5E) --------------------------------------------------------
void sub_804AC5E()
{
  ;
}

//----- (0804AC79) --------------------------------------------------------
void sub_804AC79()
{
  ;
}

//----- (0804AC89) --------------------------------------------------------
int sub_804AC89()
{
  int result; // eax

  result = &unk_8072477 - &unk_8072474;
  if ( (unsigned int)(&unk_8072477 - &unk_8072474) > 6 )
    result = 0;
  return result;
}
// 804AC89: could not find valid save-restore pair for ebp

//----- (0804AD13) --------------------------------------------------------
int sub_804AD13()
{
  int result; // eax

  result = sub_804AC89();
  byte_80728E2 = 1;
  return result;
}
// 80728E2: using guessed type char byte_80728E2;

//----- (0804AD67) --------------------------------------------------------
int __cdecl sub_804AD67(int a1)
{
  int result; // eax

  if ( a1 != 1 )
  {
    result = a1;
    status = a1;
  }
  return result;
}

//----- (0804AD7A) --------------------------------------------------------
int __cdecl sub_804AD7A(unsigned __int8 a1)
{
  return a1;
}

//----- (0804AD8C) --------------------------------------------------------
int __cdecl sub_804AD8C(_BYTE *a1)
{
  int v1; // ecx
  signed int v2; // eax
  char v3; // ST0F_1

  if ( *a1 == 46 )
  {
    if ( a1[1] == 46 )
      v2 = 2;
    else
      v2 = 1;
    v3 = a1[v2];
    dword_807227C = (int)&locret_804ADF7;
    sub_80660A0(v1, a1);
  }
  return 0;
}
// 80660A0: using guessed type int __fastcall sub_80660A0(_DWORD, _DWORD);
// 807227C: using guessed type int dword_807227C;

//----- (0804ADF9) --------------------------------------------------------
int sub_804ADF9()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nMandatory arguments to long options are mandatory for short options too.\n");
  return fputs_unlocked(v1, v0);
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804AE24) --------------------------------------------------------
int sub_804AE24()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext(
         "\n"
         "The SIZE argument is an integer and optional unit (example: 10K is 10*1024).\n"
         "Units are K,M,G,T,P,E,Z,Y (powers of 1024) or KB,MB,... (powers of 1000).\n");
  return fputs_unlocked(v1, v0);
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804AE4F) --------------------------------------------------------
#error "804AFF0: call analysis failed (funcsize=129)"

//----- (0804B090) --------------------------------------------------------
#error "804B0B7: positive sp value has been found (funcsize=0)"

//----- (0804B0BA) --------------------------------------------------------
int __cdecl sub_804B0BA(int a1, int a2)
{
  return sub_805B600(a1, a2);
}

//----- (0804B0D9) --------------------------------------------------------
int __cdecl sub_804B0D9(int a1)
{
  return a1;
}

//----- (0804B0E1) --------------------------------------------------------
bool __cdecl sub_804B0E1(int a1)
{
  return a1 == 95;
}

//----- (0804B0ED) --------------------------------------------------------
int sub_804B0ED()
{
  return 0;
}

//----- (0804B0F7) --------------------------------------------------------
int __cdecl sub_804B0F7(int a1, int a2, int a3, int a4)
{
  _DWORD *v4; // ST3C_4
  int result; // eax

  if ( (unsigned int)(*((_DWORD *)&unk_8072AF6 + 4) - *((_DWORD *)&unk_8072AF6 + 3)) < 0x10 )
    sub_8063CBD(&unk_8072AF6, 16);
  *((_DWORD *)&unk_8072AF6 + 3) += 16;
  v4 = (_DWORD *)(dword_8072B02 - 16);
  v4[2] = a1;
  v4[3] = a2;
  result = a3;
  *v4 = a3;
  v4[1] = a4;
  return result;
}
// 8063CBD: using guessed type _DWORD __cdecl sub_8063CBD(_DWORD, _DWORD);
// 8072B02: using guessed type int dword_8072B02;

//----- (0804B1EA) --------------------------------------------------------
#error "804B23F: call analysis failed (funcsize=26)"

//----- (0804B244) --------------------------------------------------------
#error "804B2DF: positive sp value has been found (funcsize=39)"

//----- (0804B2E2) --------------------------------------------------------
#error "804B310: call analysis failed (funcsize=17)"

//----- (0804B315) --------------------------------------------------------
#error "804B3CE: call analysis failed (funcsize=57)"

//----- (0804B3D3) --------------------------------------------------------
#error "804B47C: call analysis failed (funcsize=59)"

//----- (0804B49B) --------------------------------------------------------
#error "804B4E7: positive sp value has been found (funcsize=18)"

//----- (0804B4E8) --------------------------------------------------------
#error "804B51E: call analysis failed (funcsize=31)"

//----- (0804B540) --------------------------------------------------------
void sub_804B540()
{
  char v0; // bl
  bool v1; // zf
  int v2; // edx
  int v3; // ecx
  void *v4; // eax
  int v5; // edx
  int v6; // ecx
  int v7; // [esp+0h] [ebp-28h]
  int v8; // [esp+0h] [ebp-28h]
  int v9; // [esp+4h] [ebp-24h]
  signed int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; i <= 255; ++i )
  {
    v0 = *(_BYTE *)(i + 134687542);
    v1 = (unsigned __int8)sub_8056594(i) == 0;
    v4 = &loc_804B583;
    if ( !v1 )
      v4 = &loc_804B59B;
    dword_80721DC = (int)v4;
    sub_8066431(v3, v2, v7, v9);
    if ( i == 126 || i == 45 || i == 46 || i == 95 )
    {
      dword_8072240 = (int)&loc_804B5BC;
      sub_80661F2(v6, v5, v8);
    }
    *(_BYTE *)(i + 134687542) = v0;
  }
}
// 80721DC: using guessed type int dword_80721DC;
// 8072240: using guessed type int dword_8072240;

//----- (0804B5E0) --------------------------------------------------------
signed int __cdecl sub_804B5E0(int a1)
{
  int v2; // eax
  int v3; // [esp+0h] [ebp-48h]
  int v4; // [esp+4h] [ebp-44h]
  int v5; // [esp+8h] [ebp-40h]
  int *v6; // [esp+Ch] [ebp-3Ch]
  int v7; // [esp+10h] [ebp-38h]
  int v8; // [esp+14h] [ebp-34h]
  int v9; // [esp+18h] [ebp-30h]
  int v10; // [esp+1Ch] [ebp-2Ch]
  int v11; // [esp+20h] [ebp-28h]
  int v12; // [esp+24h] [ebp-24h]
  unsigned int v13; // [esp+28h] [ebp-20h]
  unsigned int v14; // [esp+2Ch] [ebp-1Ch]
  int v15; // [esp+30h] [ebp-18h]
  unsigned int v16; // [esp+34h] [ebp-14h]
  char *s; // [esp+38h] [ebp-10h]
  unsigned int v18; // [esp+3Ch] [ebp-Ch]

  v14 = 5;
  do
  {
    dword_8072218 = (int)&loc_804B6BF;
    sub_80662EB(v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, 0, 0, v14, s);
    do
    {
      v13 = v16;
      s = nl_langinfo(v15 + 131086);
      if ( strchr(s, 37) )
        return 0;
      v8 = 0;
      v7 = 0;
      v6 = &v3 - 8;
      v5 = 128;
      v4 = a1 + (v15 << 7);
      v18 = sub_805B914(s);
      if ( v18 > 0x7F )
        return 0;
      v2 = v14;
      if ( v13 >= v14 )
        v2 = v13;
      v14 = v2;
      ++v15;
    }
    while ( v15 <= 11 );
  }
  while ( v16 > v14 );
  return 1;
}
// 80662EB: using guessed type int __stdcall sub_80662EB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8072218: using guessed type int dword_8072218;

//----- (0804B6DC) --------------------------------------------------------
int __fastcall sub_804B6DC(int a1, int a2)
{
  int v2; // ecx
  int v3; // edx
  int v4; // ecx
  int v6; // [esp+48h] [ebp-610h]
  int v7; // [esp+4Ch] [ebp-60Ch]

  dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))&loc_804B73D;
  dword_807227C = (int)&loc_804E032;
  sub_80660A0(a1, a2);
  v6 = sub_804B4E8(off_80723CC);
  dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))&loc_804B714;
  dword_807222C = (int)&loc_804E032;
  sub_806627B(v2, 0);
  dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))sub_804B7B8;
  if ( !v6 )
  {
    dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))sub_804B7B8;
    if ( !v7 )
      dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))&locret_804BABA;
  }
  return dword_80722B8(v4, v3);
}
// 804B4E8: using guessed type _DWORD __cdecl sub_804B4E8(_DWORD);
// 804B7B8: using guessed type int sub_804B7B8();
// 80660A0: using guessed type int __fastcall sub_80660A0(_DWORD, _DWORD);
// 806627B: using guessed type int __fastcall sub_806627B(_DWORD, _DWORD);
// 807222C: using guessed type int dword_807222C;
// 807227C: using guessed type int dword_807227C;
// 80722B8: using guessed type int (__fastcall *dword_80722B8)(_DWORD, _DWORD);

//----- (0804B7B8) --------------------------------------------------------
#error "804B7C1: call analysis failed (funcsize=16)"

//----- (0804B7F2) --------------------------------------------------------
int __usercall sub_804B7F2@<eax>(int a1@<ebp>, int a2@<edx>, int a3@<ecx>)
{
  *(_DWORD *)(a1 - 1576) = 0;
  dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))&loc_804BA98;
  return ((int (__fastcall *)(int, int))loc_804BA98)(a3, a2);
}
// 80722B8: using guessed type int (__fastcall *dword_80722B8)(_DWORD, _DWORD);

//----- (0804B80F) --------------------------------------------------------
#error "804B8DC: call analysis failed (funcsize=51)"

//----- (0804B8FA) --------------------------------------------------------
#error "804B9AA: call analysis failed (funcsize=48)"

//----- (0804B9BD) --------------------------------------------------------
#error "804BA1B: call analysis failed (funcsize=39)"

//----- (0804BA6F) --------------------------------------------------------
#error "804BABB: positive sp value has been found (funcsize=14)"

//----- (0804BABC) --------------------------------------------------------
#error "804BAEB: call analysis failed (funcsize=18)"

//----- (0804BAF0) --------------------------------------------------------
#error "804BB15: positive sp value has been found (funcsize=0)"

//----- (0804BB18) --------------------------------------------------------
#error "804BBDA: call analysis failed (funcsize=67)"

//----- (0804BBF7) --------------------------------------------------------
#error "804BC02: positive sp value has been found (funcsize=0)"

//----- (0804BC06) --------------------------------------------------------
void __cdecl sub_804BC06(void *ptr)
{
  free(ptr);
}

//----- (0804BC19) --------------------------------------------------------
_BOOL4 __cdecl sub_804BC19(int a1, int a2, int a3, int a4)
{
  _DWORD *ptr; // [esp+28h] [ebp-10h]
  int v6; // [esp+2Ch] [ebp-Ch]

  ptr = sub_806278A(0x10u);
  *ptr = a3;
  ptr[1] = a4;
  ptr[2] = a1;
  ptr[3] = a2;
  v6 = sub_80596EC((int)dword_80728F6, (int)ptr);
  if ( !v6 )
    sub_80628F3();
  if ( (_DWORD *)v6 != ptr )
    free(ptr);
  return v6 != (_DWORD)ptr;
}

//----- (0804BCE8) --------------------------------------------------------
void __cdecl sub_804BCE8(void *ptr)
{
  free(*(void **)ptr);
  free(*((void **)ptr + 1));
  free(ptr);
}

//----- (0804BD16) --------------------------------------------------------
int __fastcall sub_804BD16(int ecx0, int a2, int a1)
{
  int v9; // [esp+18h] [ebp-10h]
  char *s1; // [esp+1Ch] [ebp-Ch]

  v9 = dword_807230C[2 * a1];
  s1 = (char *)*(&::s1 + 2 * a1);
  dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))sub_804BE20;
  if ( v9 )
  {
    dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))&loc_804BDAA;
    if ( v9 == 1 )
    {
      a2 = (unsigned __int8)*s1;
      dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))sub_804BE20;
      if ( (_BYTE)a2 != unk_8067961 )
        dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))&loc_804BE08;
    }
  }
  return dword_80722B8(ecx0, a2);
}
// 804BE20: using guessed type int sub_804BE20();
// 80660A0: using guessed type int __fastcall sub_80660A0(_DWORD, _DWORD);
// 807227C: using guessed type int dword_807227C;
// 80722B8: using guessed type int (__fastcall *dword_80722B8)(_DWORD, _DWORD);
// 807230C: using guessed type int dword_807230C[];

//----- (0804BE20) --------------------------------------------------------
#error "804BE29: positive sp value has been found (funcsize=0)"

//----- (0804BE2A) --------------------------------------------------------
size_t sub_804BE2A()
{
  sub_8054EFE((int)dword_807230C);
  return sub_8054EFE((int)&dword_8072314);
}
// 807230C: using guessed type int dword_807230C[];
// 8072314: using guessed type int dword_8072314;

//----- (0804BE4A) --------------------------------------------------------
size_t __fastcall sub_804BE4A(int a1, int a2)
{
  size_t result; // eax

  result = (unsigned __int8)byte_807297A;
  if ( byte_807297A )
  {
    result = sub_804BD16(a1, a2, 4);
    if ( (_BYTE)result )
    {
      sub_8054EFE((int)dword_807230C);
      sub_8054EFE((int)&unk_807232C);
      result = sub_8054EFE((int)&dword_8072314);
    }
  }
  return result;
}
// 807230C: using guessed type int dword_807230C[];
// 8072314: using guessed type int dword_8072314;
// 807297A: using guessed type char byte_807297A;

//----- (0804BE91) --------------------------------------------------------
int __cdecl sub_804BE91(int a1)
{
  int result; // eax

  result = dword_8072A56;
  if ( !dword_8072A56 )
  {
    result = a1;
    dword_8072A56 = a1;
  }
  return result;
}
// 8072A56: using guessed type int dword_8072A56;

//----- (0804BEA7) --------------------------------------------------------
int sub_804BEA7()
{
  int result; // eax

  result = dword_8072A56;
  if ( !dword_8072A56 )
    result = dword_8072A5A++ + 1;
  return result;
}
// 8072A56: using guessed type int dword_8072A56;
// 8072A5A: using guessed type int dword_8072A5A;

//----- (0804BEC2) --------------------------------------------------------
int sub_804BEC2()
{
  int result; // eax
  int sig; // [esp+18h] [ebp-90h]
  sigset_t oset; // [esp+20h] [ebp-88h]

  while ( 1 )
  {
    if ( !dword_8072A56 )
    {
      result = dword_8072A5A;
      if ( !dword_8072A5A )
        break;
    }
    if ( byte_807297C )
      sub_804BE2A();
    fflush_unlocked(stdout);
    sigprocmask(0, &set, &oset);
    sig = dword_8072A56;
    if ( dword_8072A5A )
    {
      --dword_8072A5A;
      raise(19);
    }
    else
    {
      signal(dword_8072A56, 0);
      raise(sig);
    }
    sigprocmask(2, &oset, 0);
  }
  return result;
}
// 807297C: using guessed type char byte_807297C;
// 8072A56: using guessed type int dword_8072A56;
// 8072A5A: using guessed type int dword_8072A5A;

//----- (0804BFA2) --------------------------------------------------------
int __usercall sub_804BFA2@<eax>(int edx0@<edx>, int a2@<ecx>, char a1)
{
  void *v3; // eax
  signed int i; // [esp+10h] [ebp-A8h]
  int v6; // [esp+14h] [ebp-A4h]
  char v7; // [esp+18h] [ebp-A0h]
  int v8; // [esp+98h] [ebp-20h]

  v3 = &loc_804BFD9;
  if ( !a1 )
    v3 = &loc_804C112;
  dword_8072254 = (int)v3;
  sub_806617E(a2, edx0);
  sigemptyset(&set);
  for ( i = 0; i <= 11; ++i )
  {
    sigaction(sig[i], 0, (struct sigaction *)&v6);
    if ( v6 != 1 )
      sigaddset(&set, sig[i]);
  }
  qmemcpy(&v7, &set, 0x80u);
  v8 = 0x10000000;
  dword_807227C = (int)&loc_804C07B;
  return sub_80660A0(0, &v7);
}
// 80660A0: using guessed type int __fastcall sub_80660A0(_DWORD, _DWORD);
// 806617E: using guessed type int __fastcall sub_806617E(_DWORD, _DWORD);
// 8072254: using guessed type int dword_8072254;
// 807227C: using guessed type int dword_807227C;

//----- (0804C190) --------------------------------------------------------
int __fastcall sub_804C190(int a1, int a2)
{
  return sub_804BFA2(a2, a1, 1);
}

//----- (0804C1A4) --------------------------------------------------------
int __fastcall sub_804C1A4(int a1, int a2)
{
  return sub_804BFA2(a2, a1, 0);
}

//----- (0804C1B8) --------------------------------------------------------
int __cdecl main(int a1, char **a2)
{
  int v2; // edx
  int v3; // ecx
  int v4; // edx
  int v5; // ecx
  int v6; // edx
  int v7; // ecx
  bool v8; // zf
  int v9; // edx
  int v10; // ecx
  void *v11; // eax
  void *v12; // eax
  char *v13; // eax
  int v14; // edx
  int v15; // ecx
  void *v16; // eax
  char v17; // al
  void *v18; // eax
  char v19; // al
  int v20; // edx
  int v21; // ecx
  void *v22; // eax
  int v23; // edx
  int v24; // ecx
  int v25; // eax
  char *v26; // eax
  void *v27; // eax
  int v28; // edx
  int v29; // ecx
  const char *v31; // [esp-2Ch] [ebp-58h]
  char **v32; // [esp-28h] [ebp-54h]
  int v33; // [esp-24h] [ebp-50h]
  int v34; // [esp-20h] [ebp-4Ch]
  signed int v35; // [esp-1Ch] [ebp-48h]
  char *v36; // [esp-18h] [ebp-44h]
  int v37; // [esp-14h] [ebp-40h]
  int v38; // [esp-10h] [ebp-3Ch]
  int v39; // [esp-Ch] [ebp-38h]
  int v40; // [esp-8h] [ebp-34h]
  int v41; // [esp-4h] [ebp-30h]
  int v42; // [esp+0h] [ebp-2Ch]
  int sig; // [esp+4h] [ebp-28h]
  int v44; // [esp+8h] [ebp-24h]
  void *v45; // [esp+Ch] [ebp-20h]
  void *ptr; // [esp+10h] [ebp-1Ch]
  char v47; // [esp+14h] [ebp-18h]
  int *v48; // [esp+24h] [ebp-8h]

  v48 = &a1;
  sub_805F82E(*a2);
  setlocale(6, &locale);
  bindtextdomain("coreutils", "/home/hwangdz/coreutils/coreutils-8.28/install_m32/share/locale");
  textdomain("coreutils");
  sub_804AD67(2);
  sub_8065DA9((int)sub_805722F);
  dword_8072A5E = 0;
  byte_80729AE = 1;
  dword_807291A = 0;
  tp.tv_sec = 2147483648;
  tp.tv_nsec = -1;
  v32 = a2;
  v31 = (const char *)a1;
  v42 = sub_804C9E0();
  if ( byte_807297A )
    sub_804E0F8();
  if ( byte_807297A )
  {
    if ( (unsigned __int8)sub_804BD16(v3, v2, 13) || (unsigned __int8)sub_804BD16(v5, v4, 14) && byte_8072912 )
      goto LABEL_89;
    v8 = (unsigned __int8)sub_804BD16(v7, v6, 12) == 0;
    v11 = &loc_804C2E7;
    if ( v8 )
      v11 = &loc_804C2F7;
    dword_807227C = (int)v11;
    sub_80660A0(v10, v9);
    if ( !dword_8072952 )
LABEL_89:
      byte_8072986 = 1;
  }
  if ( dword_807298A == 1 )
  {
    if ( !byte_807298F && dword_8072976 != 3 )
    {
      v12 = &loc_804C338;
      if ( dword_8072952 )
        v12 = &loc_804C33F;
      dword_8072204 = (int)v12;
      sub_8066357(v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, sig, v44, v45);
    }
    dword_807298A = 2;
  }
  if ( byte_807298E )
  {
    dword_80728F6 = (void *)sub_8058A7E(30, 0, sub_804BABC, sub_804BB18, sub_804BC06);
    if ( !dword_80728F6 )
      sub_80628F3();
    sub_8063BCF(&unk_8072AF6, 0, 0, malloc, free);
  }
  v13 = getenv("TZ");
  dword_80729B6 = sub_806419B(v13);
  if ( dword_807295A == 4 || dword_807295A == 2 || !dword_8072952 )
    goto LABEL_90;
  v16 = &loc_804C419;
  if ( byte_8072926 )
    v16 = &loc_804C424;
  dword_807227C = (int)v16;
  sub_80660A0(v15, v14);
  if ( !byte_8072961 )
    v17 = 0;
  else
LABEL_90:
    v17 = 1;
  byte_80729BA = v17 & 1;
  if ( !(v17 & 1 ^ 1) )
    goto LABEL_91;
  v18 = &loc_804C46A;
  if ( byte_807298E )
    v18 = &loc_804C489;
  dword_8072204 = (int)v18;
  sub_8066357(v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, sig, v44, v45);
  if ( byte_807297A || dword_8072976 || byte_8072990 )
    v19 = 1;
  else
LABEL_91:
    v19 = 0;
  byte_80729BB = v19 & 1;
  if ( byte_8072972 )
  {
    sub_8063BCF(&unk_8072A76, 0, 0, malloc, free);
    sub_8063BCF(&unk_8072AB6, 0, 0, malloc, free);
  }
  if ( byte_807297B )
  {
    sub_804B540();
    s = (char *)sub_8062B9E();
    v22 = &loc_804C53C;
    if ( s )
      v22 = &loc_804C546;
    dword_80721DC = (int)v22;
    sub_8066431(v21, v20, v31, v32);
    s = &locale;
  }
  dword_80728FE = 100;
  dword_80728FA = (void *)sub_8062642(0x64u, 0x88u);
  dword_8072902 = 0;
  sub_804F175(v24, v23);
  v44 = a1 - v42;
  if ( a1 - v42 > 0 )
  {
    do
    {
      v25 = v42++;
      v26 = a2[v25];
      v36 = &locale;
      v35 = 1;
      v33 = 0;
      v34 = 0;
      v32 = 0;
      v31 = v26;
      sub_804F5A8();
    }
    while ( v42 < a1 );
  }
  else if ( byte_807298F )
  {
    v36 = &locale;
    v35 = 1;
    v33 = 0;
    v34 = 0;
    v32 = (char **)3;
    v31 = ".";
    sub_804F5A8();
  }
  else
  {
    sub_804E693(".", 0, 1);
  }
  if ( dword_8072902 )
  {
    sub_8051E7E();
    v27 = &loc_804C690;
    if ( byte_807298F == 1 )
      v27 = &loc_804C6A4;
    dword_8072204 = (int)v27;
    sub_8066357(v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, sig, v44, v45);
    sub_8050775(0, 1);
  }
  if ( dword_8072902 )
  {
    sub_8052000();
    if ( dword_807291A )
    {
      putchar_unlocked(10);
      ++dword_8072A6A;
    }
  }
  else if ( v44 <= 1 && dword_807291A && !*(_DWORD *)(dword_807291A + 12) )
  {
    byte_80729AE = 0;
  }
  while ( dword_807291A )
  {
    v45 = (void *)dword_807291A;
    dword_807291A = *(_DWORD *)(dword_807291A + 12);
    if ( !dword_80728F6 || *(_DWORD *)v45 )
    {
      sub_804E729((int)&a1, *(char **)v45, *((_DWORD *)v45 + 1), *((_BYTE *)v45 + 8));
      sub_804BCE8(v45);
      byte_80729AE = 1;
    }
    else
    {
      sub_804B1EA(&v47);
      ptr = (void *)sub_805972B(dword_80728F6, &v47);
      if ( !ptr )
        __assert_fail("found", "src/ls.c", 0x638u, "main");
      sub_804BC06(ptr);
      sub_804BCE8(v45);
    }
  }
  if ( byte_807297A && byte_807297C )
  {
    if ( dword_807230C[0] != 2 || memcmp(s1, &unk_806795C, 2u) || dword_8072314 != 1 || *(_BYTE *)off_8072318 != 109 )
      sub_804BE2A();
    fflush_unlocked(stdout);
    sub_804C1A4(v29, v28);
    for ( sig = dword_8072A5A; sig; --sig )
      raise(19);
    sig = dword_8072A56;
    if ( dword_8072A56 )
      raise(sig);
  }
  if ( byte_8072972 )
  {
    sub_804B2E2("//DIRED//", &unk_8072A76);
    sub_804B2E2("//SUBDIRED//", &unk_8072AB6);
    v32 = (char **)off_806B118[sub_805F949(dword_80729A2)];
    printf("//DIRED-OPTIONS// --quoting-style=%s\n", v32);
  }
  if ( dword_80728F6 )
  {
    if ( sub_80581E9((int)dword_80728F6) )
      __assert_fail("hash_get_n_entries (active_dir_set) == 0", "src/ls.c", 0x66Cu, "main");
    sub_8058CC5(dword_80728F6);
  }
  return dword_8072A5E;
}
// 804B1EA: using guessed type int __cdecl sub_804B1EA(_DWORD);
// 804B2E2: using guessed type _DWORD __cdecl sub_804B2E2(_DWORD, _DWORD);
// 804BABC: using guessed type int __cdecl sub_804BABC(int);
// 804C9E0: using guessed type int sub_804C9E0(void);
// 804E0F8: using guessed type int sub_804E0F8(void);
// 804F5A8: using guessed type int sub_804F5A8(void);
// 8051E7E: using guessed type int sub_8051E7E(void);
// 8052000: using guessed type int sub_8052000(void);
// 8058A7E: using guessed type _DWORD __cdecl sub_8058A7E(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 805972B: using guessed type _DWORD __cdecl sub_805972B(_DWORD, _DWORD);
// 8063BCF: using guessed type _DWORD __cdecl sub_8063BCF(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80660A0: using guessed type int __fastcall sub_80660A0(_DWORD, _DWORD);
// 8066357: using guessed type int __stdcall sub_8066357(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806B118: using guessed type char *off_806B118[10];
// 80721DC: using guessed type int dword_80721DC;
// 8072204: using guessed type int dword_8072204;
// 807227C: using guessed type int dword_807227C;
// 807230C: using guessed type int dword_807230C[];
// 8072314: using guessed type int dword_8072314;
// 8072318: using guessed type void *off_8072318;
// 8072902: using guessed type int dword_8072902;
// 8072912: using guessed type char byte_8072912;
// 807291A: using guessed type int dword_807291A;
// 8072926: using guessed type char byte_8072926;
// 8072952: using guessed type int dword_8072952;
// 807295A: using guessed type int dword_807295A;
// 8072961: using guessed type char byte_8072961;
// 8072972: using guessed type char byte_8072972;
// 8072976: using guessed type int dword_8072976;
// 807297A: using guessed type char byte_807297A;
// 807297B: using guessed type char byte_807297B;
// 807297C: using guessed type char byte_807297C;
// 8072986: using guessed type char byte_8072986;
// 807298A: using guessed type int dword_807298A;
// 807298E: using guessed type char byte_807298E;
// 807298F: using guessed type char byte_807298F;
// 8072990: using guessed type char byte_8072990;
// 80729A2: using guessed type int dword_80729A2;
// 80729AE: using guessed type char byte_80729AE;
// 80729BA: using guessed type char byte_80729BA;
// 80729BB: using guessed type char byte_80729BB;
// 8072A56: using guessed type int dword_8072A56;
// 8072A5A: using guessed type int dword_8072A5A;
// 8072A5E: using guessed type int dword_8072A5E;
// 8072A6A: using guessed type int dword_8072A6A;

//----- (0804C947) --------------------------------------------------------
int __usercall sub_804C947@<eax>(int a1@<edx>, int a2@<ecx>, char *nptr)
{
  int v3; // eax
  int v4; // eax
  int v6; // [esp+0h] [ebp-38h]
  int v7; // [esp+4h] [ebp-34h]
  int v8; // [esp+8h] [ebp-30h]
  int v9; // [esp+Ch] [ebp-2Ch]
  int v10; // [esp+10h] [ebp-28h]
  int v11; // [esp+14h] [ebp-24h]
  int v12; // [esp+18h] [ebp-20h]
  int v13; // [esp+1Ch] [ebp-1Ch]
  int v14; // [esp+28h] [ebp-10h]
  int v15; // [esp+2Ch] [ebp-Ch]

  v3 = sub_806351F(a1, a2, nptr, 0, 0, (int)&v14, &locale);
  if ( v3 )
  {
    if ( v3 == 1 )
    {
      dword_80729B2 = -1;
      return 1;
    }
    dword_80721F0 = (int)&loc_804C9D9;
    sub_80663C3(v6, v7, v8, v9, v10, v11, v12, v13);
  }
  v4 = v14;
  if ( v15 )
    v4 = -1;
  dword_80729B2 = v4;
  return 1;
}
// 80663C3: using guessed type int __stdcall sub_80663C3(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80721F0: using guessed type int dword_80721F0;
// 80729B2: using guessed type int dword_80729B2;

//----- (0804C9E0) --------------------------------------------------------
#error "804CB01: call analysis failed (funcsize=60)"

//----- (0804CB06) --------------------------------------------------------
#error "804DC41: positive sp value has been found (funcsize=921)"

//----- (0804DC44) --------------------------------------------------------
#error "804DCA0: call analysis failed (funcsize=274)"

//----- (0804E005) --------------------------------------------------------
#error "804E031: positive sp value has been found (funcsize=14)"

//----- (0804E03C) --------------------------------------------------------
#error "804E074: call analysis failed (funcsize=53)"

//----- (0804E0F8) --------------------------------------------------------
#error "804E481: call analysis failed (funcsize=281)"

//----- (0804E56B) --------------------------------------------------------
void sub_804E56B()
{
  int v0; // ebx
  char *v1; // eax
  char *s; // [esp+18h] [ebp-10h]
  int v3; // [esp+1Ch] [ebp-Ch]

  s = getenv("QUOTING_STYLE");
  if ( s )
  {
    v3 = sub_805615C(s, (int)off_806B118);
    if ( v3 < 0 )
    {
      v0 = sub_8061809((int)s);
      v1 = gettext("ignoring invalid value of environment variable QUOTING_STYLE: %s");
      error(0, 0, v1, v0);
    }
    else
    {
      sub_805F975(0, dword_806B158[v3]);
    }
  }
}
// 806B118: using guessed type char *off_806B118[10];

//----- (0804E60A) --------------------------------------------------------
int __cdecl sub_804E60A(int a1)
{
  int result; // eax

  result = a1;
  if ( (_BYTE)a1 )
  {
    dword_8072A5E = 2;
  }
  else
  {
    result = dword_8072A5E;
    if ( !dword_8072A5E )
      dword_8072A5E = 1;
  }
  return result;
}
// 8072A5E: using guessed type int dword_8072A5E;

//----- (0804E63D) --------------------------------------------------------
int __cdecl sub_804E63D(int a1, char *format, int a3)
{
  int v3; // ebx
  int *v4; // eax

  v3 = sub_8061317(4, a3);
  v4 = __errno_location();
  error(0, *v4, format, v3);
  return sub_804E60A((unsigned __int8)a1);
}

//----- (0804E693) --------------------------------------------------------
_DWORD *__cdecl sub_804E693(char *a1, char *s, int a3)
{
  void *v3; // eax
  void *v4; // eax
  _DWORD *result; // eax
  _DWORD *v6; // [esp+1Ch] [ebp-Ch]

  v6 = sub_806278A(0x10u);
  if ( s )
    v3 = sub_80628CE(s);
  else
    v3 = 0;
  v6[1] = v3;
  if ( a1 )
    v4 = sub_80628CE(a1);
  else
    v4 = 0;
  *v6 = v4;
  *((_BYTE *)v6 + 8) = a3;
  v6[3] = dword_807291A;
  result = v6;
  dword_807291A = (int)v6;
  return result;
}
// 807291A: using guessed type int dword_807291A;

//----- (0804E729) --------------------------------------------------------
unsigned int __usercall sub_804E729@<eax>(int a1@<ebx>, char *a2, int a3, unsigned __int8 a4)
{
  int v4; // edx
  int v5; // ecx
  char *v6; // eax
  unsigned int v7; // eax
  char *v8; // eax
  int v9; // ebx
  char *v10; // eax
  int v11; // edx
  int v12; // ecx
  void *v13; // eax
  void *v14; // eax
  int v15; // ebx
  char *v16; // eax
  char *v17; // eax
  int v18; // eax
  bool v19; // zf
  void *v20; // eax
  int v21; // ecx
  __int64 v22; // rax
  int v23; // edx
  int v24; // ecx
  char *v25; // eax
  int v26; // edx
  int v27; // ecx
  char *v28; // eax
  void *v29; // eax
  int v31; // [esp-8h] [ebp-350h]
  int v32; // [esp-4h] [ebp-34Ch]
  __int64 v33; // [esp+0h] [ebp-348h]
  char *v34; // [esp+8h] [ebp-340h]
  int v35; // [esp+Ch] [ebp-33Ch]
  int v36; // [esp+10h] [ebp-338h]
  char *v37; // [esp+14h] [ebp-334h]
  int v38; // [esp+18h] [ebp-330h]
  int v39; // [esp+1Ch] [ebp-32Ch]
  int v40; // [esp+20h] [ebp-328h]
  unsigned __int8 v41; // [esp+24h] [ebp-324h]
  char *v42; // [esp+28h] [ebp-320h]
  char *name; // [esp+2Ch] [ebp-31Ch]
  void *ptr; // [esp+30h] [ebp-318h]
  int v45; // [esp+34h] [ebp-314h]
  DIR *dirp; // [esp+38h] [ebp-310h]
  int v47; // [esp+3Ch] [ebp-30Ch]
  int v48; // [esp+40h] [ebp-308h]
  char *s; // [esp+44h] [ebp-304h]
  __int64 v50; // [esp+48h] [ebp-300h]
  int v51; // [esp+50h] [ebp-2F8h]
  int v52; // [esp+54h] [ebp-2F4h]
  int v53; // [esp+A8h] [ebp-2A0h]
  int v54; // [esp+ACh] [ebp-29Ch]
  unsigned int v55; // [esp+33Ch] [ebp-Ch]

  name = a2;
  v42 = (char *)a3;
  v41 = a4;
  v55 = __readgsdword(0x14u);
  v50 = 0LL;
  *__errno_location() = 0;
  dirp = opendir(name);
  if ( !dirp )
  {
    v6 = gettext("cannot open directory %s");
    sub_804E63D(v41, v6, (int)name);
    return __readgsdword(0x14u) ^ v55;
  }
  if ( dword_80728F6 )
  {
    v47 = dirfd(dirp);
    if ( v47 < 0 )
      v7 = (unsigned int)sub_8065DD8((int)name, (int)&v51) >> 31;
    else
      v7 = (unsigned int)sub_8065E07(v47, (int)&v51) >> 31;
    if ( (_BYTE)v7 )
    {
      v8 = gettext("cannot determine device and inode of %s");
      sub_804E63D(v41, v8, (int)name);
      closedir(dirp);
      return __readgsdword(0x14u) ^ v55;
    }
    if ( (unsigned __int8)sub_804BC19(v51, v52, v53, v54) )
    {
      v34 = name;
      v9 = sub_80614C2(0, 3);
      v10 = gettext("%s: not listing already-listed directory");
      v35 = v9;
      error(0, 0, v10, v9);
      closedir(dirp);
      sub_804E60A(1);
      return __readgsdword(0x14u) ^ v55;
    }
    a1 = v54;
    sub_804B0F7(v51, v52, v53, v54);
  }
  sub_804F175(v5, v4);
  if ( !byte_807298E )
  {
    v32 = (unsigned __int8)byte_80729AE;
    v31 = a1;
    v13 = &loc_804E97C;
    if ( !byte_80729AE )
      v13 = &loc_804EAF6;
    dword_8072254 = (int)v13;
    a1 = v31;
    sub_806617E(v12, v11);
  }
  v32 = (unsigned __int8)byte_80723D4 ^ 1;
  v31 = a1;
  v14 = &loc_804E9A3;
  if ( byte_80723D4 == 1 )
    v14 = &loc_804E9BC;
  dword_8072268 = (int)v14;
  v15 = v31;
  sub_806610E(
    v33,
    HIDWORD(v33),
    v34,
    v35,
    v36,
    v37,
    v38,
    v39,
    v40,
    *(_DWORD *)&v41,
    v42,
    name,
    ptr,
    v45,
    dirp,
    v47,
    v48,
    s,
    v50);
  putchar_unlocked(10);
  ++dword_8072A6A;
  byte_80723D4 = 0;
  if ( byte_8072972 )
  {
    fwrite_unlocked("  ", 1u, 2u, stdout);
    dword_8072A6A += 2;
  }
  ptr = 0;
  if ( byte_807297B )
  {
    ptr = (void *)sub_8056852(v31, (int)name, 2);
    if ( !ptr )
    {
      v16 = gettext("error canonicalizing %s");
      sub_804E63D(v41, v16, (int)name);
    }
  }
  if ( v42 )
    v17 = v42;
  else
    v17 = name;
  sub_8053E2F(v31, (int)v17, dword_80729A6, -1, 0, 1, (int)&unk_8072AB6, (char *)ptr);
  free(ptr);
  fwrite_unlocked(":\n", 1u, 2u, stdout);
  dword_8072A6A += 2;
  *__errno_location() = 0;
  LODWORD(v33) = dirp;
  v48 = readdir64();
  if ( v48 )
  {
    v18 = sub_804EFF1((char *)(v48 + 19)) ^ 1;
    v19 = (_BYTE)v18 == 0;
    v32 = v18;
    v31 = v15;
    v20 = &loc_804EB53;
    if ( v19 )
      v20 = &loc_804ECCC;
    dword_8072218 = (int)v20;
    sub_80662EB(v33, HIDWORD(v33), v34, v35, v36, v37, v38, v39, v40, *(_DWORD *)&v41, v42, name, ptr, v45, dirp);
    v45 = 0;
    switch ( *(unsigned __int8 *)(v48 + 18) )
    {
      case 1u:
        v45 = 1;
        dword_80721F0 = (int)&loc_804EC19;
        sub_80663C3(v33, HIDWORD(v33), v34, v35, v36, v37, v38, v39);
        goto LABEL_34;
      case 2u:
        goto LABEL_31;
      case 4u:
        goto LABEL_32;
      case 6u:
        v45 = 4;
        dword_80721F0 = (int)&loc_804EC19;
        sub_80663C3(v33, HIDWORD(v33), v34, v35, v36, v37, v38, v39);
LABEL_31:
        dword_8072268 = (int)&loc_804EC19;
        sub_806610E(
          v33,
          HIDWORD(v33),
          v34,
          v35,
          v36,
          v37,
          v38,
          v39,
          v40,
          *(_DWORD *)&v41,
          v42,
          name,
          ptr,
          2,
          dirp,
          v47,
          v48,
          s,
          v50);
LABEL_32:
        v45 = 3;
        break;
      case 8u:
        v45 = 5;
        break;
      case 0xAu:
LABEL_34:
        v45 = 6;
        break;
      case 0xCu:
        v45 = 7;
        break;
      case 0xEu:
        v45 = 8;
        break;
      default:
        break;
    }
    v37 = name;
    v36 = 0;
    v34 = 0;
    v35 = 0;
    HIDWORD(v33) = v45;
    LODWORD(v33) = v48 + 19;
    LODWORD(v22) = sub_804F5A8();
    v50 += v22;
    v32 = dword_8072952;
    LODWORD(v22) = &loc_804EC95;
    if ( dword_8072952 != 1 )
      LODWORD(v22) = &loc_804ECCC;
    dword_807222C = v22;
    v15 = v31;
    sub_806627B(v21, HIDWORD(v22));
    if ( dword_807295A == -1 && byte_8072961 != 1 && byte_807298E != 1 )
    {
      sub_8051E7E();
      sub_8052000();
      sub_804F175(v24, v23);
    }
  }
  else
  {
    if ( !*__errno_location() )
      goto LABEL_50;
    v25 = gettext("reading directory %s");
    sub_804E63D(v41, v25, (int)name);
    if ( *__errno_location() != 75 )
      goto LABEL_50;
  }
  sub_804BEC2();
  dword_807227C = (int)&loc_804EAF6;
  sub_80660A0(v27, v26);
LABEL_50:
  if ( closedir(dirp) )
  {
    v28 = gettext("closing directory %s");
    sub_804E63D(v41, v28, (int)name);
  }
  sub_8051E7E();
  if ( byte_807298E )
    sub_8050775(name, 0);
  if ( dword_8072952 )
  {
    v32 = (unsigned __int8)byte_8072961;
    v31 = v15;
    v29 = &loc_804EDBC;
    if ( !byte_8072961 )
      v29 = &loc_804EF16;
    dword_8072218 = (int)v29;
    sub_80662EB(v33, HIDWORD(v33), v34, v35, v36, v37, v38, v39, v40, *(_DWORD *)&v41, v42, name, ptr, v45, dirp);
  }
  if ( byte_8072972 )
  {
    fwrite_unlocked("  ", 1u, 2u, stdout);
    dword_8072A6A += 2;
  }
  s = gettext("total");
  fputs_unlocked(s, stdout);
  dword_8072A6A += strlen(s);
  putchar_unlocked(32);
  ++dword_8072A6A;
  s = (char *)sub_805A051(v50, SHIDWORD(v50), (char *)&v33 - 664, dword_8072962, 512, 0, dword_8072966, dword_807296A);
  fputs_unlocked(s, stdout);
  dword_8072A6A += strlen(s);
  putchar_unlocked(10);
  ++dword_8072A6A;
  if ( dword_8072902 )
    sub_8052000();
  return __readgsdword(0x14u) ^ v55;
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8049A80: using guessed type int readdir64(void);
// 804F5A8: using guessed type int sub_804F5A8(void);
// 8051E7E: using guessed type int sub_8051E7E(void);
// 8052000: using guessed type int sub_8052000(void);
// 80614C2: using guessed type _DWORD __cdecl sub_80614C2(_DWORD, _DWORD);
// 80660A0: using guessed type int __fastcall sub_80660A0(_DWORD, _DWORD);
// 806610E: using guessed type int __stdcall sub_806610E(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806617E: using guessed type int __fastcall sub_806617E(_DWORD, _DWORD);
// 806627B: using guessed type int __fastcall sub_806627B(_DWORD, _DWORD);
// 80662EB: using guessed type int __stdcall sub_80662EB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80663C3: using guessed type int __stdcall sub_80663C3(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80721F0: using guessed type int dword_80721F0;
// 8072218: using guessed type int dword_8072218;
// 807222C: using guessed type int dword_807222C;
// 8072254: using guessed type int dword_8072254;
// 8072268: using guessed type int dword_8072268;
// 807227C: using guessed type int dword_807227C;
// 80723D4: using guessed type char byte_80723D4;
// 8072902: using guessed type int dword_8072902;
// 8072952: using guessed type int dword_8072952;
// 807295A: using guessed type int dword_807295A;
// 8072961: using guessed type char byte_8072961;
// 8072972: using guessed type char byte_8072972;
// 807297B: using guessed type char byte_807297B;
// 807298E: using guessed type char byte_807298E;
// 80729A6: using guessed type int dword_80729A6;
// 80729AE: using guessed type char byte_80729AE;
// 8072A6A: using guessed type int dword_8072A6A;

//----- (0804EF3E) --------------------------------------------------------
_DWORD *__cdecl sub_804EF3E(int a1)
{
  _DWORD *v1; // ST1C_4
  _DWORD *result; // eax

  v1 = sub_806278A(8u);
  *v1 = a1;
  v1[1] = dword_8072996;
  result = v1;
  dword_8072996 = (int)v1;
  return result;
}

//----- (0804EF91) --------------------------------------------------------
#error "804EFAB: call analysis failed (funcsize=30)"

//----- (0804EFF1) --------------------------------------------------------
#error "804F038: call analysis failed (funcsize=69)"

//----- (0804F0CE) --------------------------------------------------------
__int64 __cdecl sub_804F0CE(__int64 a1)
{
  return a1;
}

//----- (0804F0F8) --------------------------------------------------------
int sub_804F0F8()
{
  *__errno_location() = 95;
  return 0;
}

//----- (0804F110) --------------------------------------------------------
void __cdecl sub_804F110(void **a1)
{
  void *v1; // ST00_4

  free(*a1);
  free(a1[1]);
  free(a1[2]);
  if ( a1[29] != &unk_80722EC )
  {
    if ( (unsigned __int8)sub_804B0ED() )
    {
      free(a1[29]);
    }
    else
    {
      v1 = a1[29];
      sub_8061A24();
    }
  }
}

//----- (0804F175) --------------------------------------------------------
int __fastcall sub_804F175(int a1, int a2)
{
  int result; // eax
  unsigned int v3; // [esp+18h] [ebp-10h]

  v3 = 0;
  dword_8072254 = (int)&loc_804F1BA;
  sub_806617E(a1, a2);
  do
  {
    sub_804F110(*((void ***)dword_807290A + v3++));
    result = dword_8072902;
  }
  while ( v3 < dword_8072902 );
  dword_8072902 = 0;
  byte_8072906 = 0;
  byte_8072927 = 0;
  dword_807292A = 0;
  dword_807292E = 0;
  dword_8072932 = 0;
  dword_807293A = 0;
  dword_807293E = 0;
  dword_8072942 = 0;
  dword_8072936 = 0;
  dword_8072946 = 0;
  dword_807294A = 0;
  dword_807294E = 0;
  return result;
}
// 806617E: using guessed type int __fastcall sub_806617E(_DWORD, _DWORD);
// 8072254: using guessed type int dword_8072254;
// 8072902: using guessed type int dword_8072902;
// 8072906: using guessed type char byte_8072906;
// 8072927: using guessed type char byte_8072927;
// 807292A: using guessed type int dword_807292A;
// 807292E: using guessed type int dword_807292E;
// 8072932: using guessed type int dword_8072932;
// 8072946: using guessed type int dword_8072946;
// 807294A: using guessed type int dword_807294A;
// 807294E: using guessed type int dword_807294E;

//----- (0804F252) --------------------------------------------------------
#error "804F287: call analysis failed (funcsize=25)"

//----- (0804F29D) --------------------------------------------------------
int __cdecl sub_804F29D(int a1, int a2, char a3)
{
  int v3; // edx
  int v4; // ecx
  signed int v5; // eax
  int *v6; // eax
  int v7; // edx
  int v9; // [esp+0h] [ebp-28h]
  int v10; // [esp+4h] [ebp-24h]
  signed int v11; // [esp+1Ch] [ebp-Ch]

  if ( *(_QWORD *)(a2 + 12) == qword_80738F6 )
  {
    *__errno_location() = 95;
    dword_80721DC = (int)&loc_804F37E;
    sub_8066431(v4, v3, v9, v10);
  }
  if ( a3 )
    v5 = sub_8061A71();
  else
    v5 = sub_8061A89();
  v11 = v5;
  if ( v5 < 0 )
  {
    v6 = __errno_location();
    if ( (unsigned __int8)sub_804F252(*v6) )
    {
      v7 = *(_DWORD *)(a2 + 16);
      LODWORD(qword_80738F6) = *(_DWORD *)(a2 + 12);
      HIDWORD(qword_80738F6) = v7;
    }
  }
  return v11;
}
// 804F252: using guessed type _DWORD __cdecl sub_804F252(_DWORD);
// 80721DC: using guessed type int dword_80721DC;
// 80738F6: using guessed type __int64 qword_80738F6;

//----- (0804F385) --------------------------------------------------------
int __cdecl sub_804F385(int a1, int a2)
{
  int result; // eax
  int *v3; // eax
  int v4; // edx
  int v5; // [esp+1Ch] [ebp-Ch]

  if ( *(_QWORD *)(a2 + 12) == qword_80738FE )
  {
    *__errno_location() = 95;
    result = 0;
  }
  else
  {
    *__errno_location() = 0;
    v5 = sub_80574F7();
    if ( v5 <= 0 )
    {
      v3 = __errno_location();
      if ( (unsigned __int8)sub_804F252(*v3) )
      {
        v4 = *(_DWORD *)(a2 + 16);
        LODWORD(qword_80738FE) = *(_DWORD *)(a2 + 12);
        HIDWORD(qword_80738FE) = v4;
      }
    }
    result = v5;
  }
  return result;
}
// 804F252: using guessed type _DWORD __cdecl sub_804F252(_DWORD);
// 80738F6: using guessed type __int64 qword_80738F6;
// 80738FE: using guessed type __int64 qword_80738FE;

//----- (0804F439) --------------------------------------------------------
int __cdecl sub_804F439(int a1, int a2)
{
  int result; // eax
  int *v3; // eax
  bool v4; // zf
  int v5; // edx
  int v6; // ecx
  void *v7; // eax
  int v8; // edx
  unsigned __int8 v9; // [esp+1Fh] [ebp-9h]

  if ( *(_QWORD *)(a2 + 12) == qword_8073906 )
  {
    *__errno_location() = 95;
    result = 0;
  }
  else
  {
    v9 = sub_804F0F8();
    if ( v9 ^ 1 )
    {
      v3 = __errno_location();
      v4 = (unsigned __int8)sub_804F252(*v3) == 0;
      v7 = &loc_804F4D8;
      if ( v4 )
        v7 = &loc_804F4EC;
      dword_8072254 = (int)v7;
      sub_806617E(v6, v5);
      v8 = *(_DWORD *)(a2 + 16);
      LODWORD(qword_8073906) = *(_DWORD *)(a2 + 12);
      HIDWORD(qword_8073906) = v8;
    }
    result = v9;
  }
  return result;
}
// 804F252: using guessed type _DWORD __cdecl sub_804F252(_DWORD);
// 806617E: using guessed type int __fastcall sub_806617E(_DWORD, _DWORD);
// 8072254: using guessed type int dword_8072254;
// 80738FE: using guessed type __int64 qword_80738FE;
// 8073906: using guessed type __int64 qword_8073906;

//----- (0804F4F7) --------------------------------------------------------
#error "804F57D: call analysis failed (funcsize=48)"

//----- (0804F5A8) --------------------------------------------------------
#error "804F5C8: call analysis failed (funcsize=13)"

//----- (0804F5CD) --------------------------------------------------------
#error "804F875: call analysis failed (funcsize=947)"

//----- (0805060F) --------------------------------------------------------
int __cdecl sub_805060F(int a1)
{
  return *(_DWORD *)(a1 + 108) == 3 || *(_DWORD *)(a1 + 108) == 9;
}

//----- (08050639) --------------------------------------------------------
int __cdecl sub_8050639(char *path, int a2, int a3)
{
  int v3; // ecx
  int result; // eax
  char *v5; // eax

  *(_DWORD *)(a2 + 4) = sub_805601F(*(_DWORD *)(a2 + 60), v3, path, *(_DWORD *)(a2 + 56));
  result = *(_DWORD *)(a2 + 4);
  if ( !result )
  {
    v5 = gettext("cannot read symbolic link %s");
    result = sub_804E63D((unsigned __int8)a3, v5, (int)path);
  }
  return result;
}

//----- (080506A2) --------------------------------------------------------
void *__cdecl sub_80506A2(int a1, char *s)
{
  size_t v3; // eax
  char *v4; // eax
  int v5; // [esp+18h] [ebp-10h]
  void *v6; // [esp+1Ch] [ebp-Ch]

  if ( !s )
    return 0;
  if ( *s == 47 )
    return sub_80628CE(s);
  v5 = sub_8057328(a1);
  if ( !v5 )
    return sub_80628CE(s);
  v3 = strlen(s);
  v6 = sub_806278A(v5 + v3 + 2);
  if ( *(_BYTE *)(v5 - 1 + a1) != 47 )
    ++v5;
  v4 = (char *)stpncpy(v6, a1, v5);
  strcpy(v4, s);
  return v6;
}
// 8049980: using guessed type int __cdecl stpncpy(_DWORD, _DWORD, _DWORD);
// 8057328: using guessed type _DWORD __cdecl sub_8057328(_DWORD);

//----- (08050754) --------------------------------------------------------
int __cdecl sub_8050754(_BYTE *a1)
{
  _BYTE *v1; // ST1C_4

  v1 = sub_805745E(a1);
  return sub_804AD8C(v1);
}

//----- (08050775) --------------------------------------------------------
int __cdecl sub_8050775(char *s, int a2)
{
  char *ptr; // ST28_4
  int v3; // eax
  int v4; // ST2C_4
  int result; // eax
  int v6; // [esp+1Ch] [ebp-1Ch]
  unsigned int v7; // [esp+1Ch] [ebp-1Ch]
  int v8; // [esp+20h] [ebp-18h]
  char **v9; // [esp+24h] [ebp-14h]

  if ( s && dword_80728F6 )
    sub_804E693(0, s, 0);
  v6 = dword_8072902;
  while ( 1 )
  {
    v3 = v6--;
    if ( !v3 )
      break;
    v9 = (char **)*((_DWORD *)dword_807290A + v6);
    if ( (unsigned __int8)sub_805060F((int)v9) && ((s != 0) != 1 || (unsigned __int8)sub_8050754(*v9) ^ 1) )
    {
      if ( s && **v9 != 47 )
      {
        ptr = (char *)sub_805791D(s, *v9, 0);
        sub_804E693(ptr, v9[1], (unsigned __int8)a2);
        free(ptr);
      }
      else
      {
        sub_804E693(*v9, v9[1], (unsigned __int8)a2);
      }
      if ( v9[27] == (char *)9 )
        sub_804F110((void **)v9);
    }
  }
  v7 = 0;
  v8 = 0;
  while ( v7 < dword_8072902 )
  {
    v4 = *((_DWORD *)dword_807290A + v7);
    *((_DWORD *)dword_807290A + v8) = v4;
    v8 += *(_DWORD *)(v4 + 108) != 9;
    ++v7;
  }
  result = v8;
  dword_8072902 = v8;
  return result;
}
// 8072902: using guessed type int dword_8072902;

//----- (08050929) --------------------------------------------------------
int __cdecl sub_8050929(char *s1, char *s2)
{
  int v2; // edi
  int v3; // esi
  char *v4; // ebx
  int *v5; // eax
  int v7; // [esp+2Ch] [ebp-1Ch]

  *__errno_location() = 0;
  v7 = strcoll(s1, s2);
  if ( *__errno_location() )
  {
    v2 = sub_80617E7(1, (int)s2);
    v3 = sub_80617E7(0, (int)s1);
    v4 = gettext("cannot compare file names %s and %s");
    v5 = __errno_location();
    error(0, *v5, v4, v3, v2);
    sub_804E60A(0);
    longjmp(env, 1);
  }
  return v7;
}

//----- (080509E3) --------------------------------------------------------
int __cdecl sub_80509E3(int *a1, int *a2, void (*a3)(void))
{
  int v3; // ST04_4
  int v4; // ST00_4
  int v6; // [esp+0h] [ebp-38h]
  int v7; // [esp+4h] [ebp-34h]
  int v8; // [esp+8h] [ebp-30h]
  int v9; // [esp+Ch] [ebp-2Ch]
  int v10; // [esp+10h] [ebp-28h]
  int v11; // [esp+14h] [ebp-24h]
  int v12; // [esp+18h] [ebp-20h]
  int v13; // [esp+1Ch] [ebp-1Ch]
  int v14; // [esp+20h] [ebp-18h]
  int v15; // [esp+24h] [ebp-14h]
  int v16; // [esp+28h] [ebp-10h]
  int v17; // [esp+2Ch] [ebp-Ch]
  int v18; // [esp+30h] [ebp-8h]

  sub_8061BEE(&v14, a1 + 3);
  sub_8061BEE(&v16, a2 + 3);
  v13 = sub_8061CD9(v16, v17, v14, v15);
  if ( !v13 )
  {
    v3 = *a2;
    v4 = *a1;
    a3();
    dword_8072218 = (int)&locret_8050A72;
    sub_80662EB(v4, v3, v6, v7, v8, v9, v10, v11, v12, 0, v14, v15, v16, v17, v18);
  }
  return v13;
}
// 8061BEE: using guessed type _DWORD __cdecl sub_8061BEE(_DWORD, _DWORD);
// 80662EB: using guessed type int __stdcall sub_80662EB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8072218: using guessed type int dword_8072218;

//----- (08050A74) --------------------------------------------------------
int __cdecl sub_8050A74(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD))
{
  int result; // eax
  int v4; // [esp+1Ch] [ebp-1Ch]
  int v5; // [esp+20h] [ebp-18h]
  int v6; // [esp+24h] [ebp-14h]
  int v7; // [esp+28h] [ebp-10h]
  int v8; // [esp+2Ch] [ebp-Ch]

  sub_8061C2E(&v5, (int)(a1 + 3));
  sub_8061C2E(&v7, (int)(a2 + 3));
  v4 = sub_8061CD9(v7, v8, v5, v6);
  if ( v4 )
    result = v4;
  else
    result = a3(*a1, *a2);
  return result;
}

//----- (08050AF0) --------------------------------------------------------
int __cdecl sub_8050AF0(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD))
{
  int result; // eax
  int v4; // [esp+1Ch] [ebp-1Ch]
  int v5; // [esp+20h] [ebp-18h]
  int v6; // [esp+24h] [ebp-14h]
  int v7; // [esp+28h] [ebp-10h]
  int v8; // [esp+2Ch] [ebp-Ch]

  sub_8061BC3(&v5, (int)(a1 + 3));
  sub_8061BC3(&v7, (int)(a2 + 3));
  v4 = sub_8061CD9(v7, v8, v5, v6);
  if ( v4 )
    result = v4;
  else
    result = a3(*a1, *a2);
  return result;
}

//----- (08050B6C) --------------------------------------------------------
#error "8050BB2: call analysis failed (funcsize=24)"

//----- (08050BB7) --------------------------------------------------------
#error "8050C50: positive sp value has been found (funcsize=53)"

//----- (08050C54) --------------------------------------------------------
int __cdecl sub_8050C54(int a1, _DWORD *a2)
{
  _DWORD *v3; // [esp+8h] [ebp-14h]
  int v4; // [esp+Ch] [ebp-10h]
  int (__stdcall *v5)(_DWORD, _DWORD, _DWORD *, int, _DWORD, int); // [esp+10h] [ebp-Ch]
  int v6; // [esp+14h] [ebp-8h]

  return v5(*v3, *a2, v3, v4, v5, v6);
}

//----- (08050C92) --------------------------------------------------------
int __cdecl sub_8050C92(const char **a1, const char **a2, int (__cdecl *a3)(char *, char *))
{
  int v3; // ecx
  char *v4; // eax
  int result; // eax
  int v6; // [esp+0h] [ebp-28h]
  int v7; // [esp+4h] [ebp-24h]
  char *v8; // [esp+14h] [ebp-14h]
  char *v9; // [esp+18h] [ebp-10h]
  int v10; // [esp+1Ch] [ebp-Ch]

  v8 = strrchr(*a1, 46);
  v9 = strrchr(*a2, 46);
  if ( v9 )
  {
    dword_80721DC = (int)&loc_8050CED;
    sub_8066431(v3, v9, v6, v7);
  }
  if ( v8 )
    v4 = v8;
  else
    v4 = &locale;
  v10 = a3(v4, &locale);
  if ( v10 )
    result = v10;
  else
    result = a3((char *)*a1, (char *)*a2);
  return result;
}
// 80721DC: using guessed type int dword_80721DC;

//----- (08051556) --------------------------------------------------------
int __cdecl sub_8051556(int a1, int a2)
{
  return sub_8050B6C(a1, a2);
}
// 8050B6C: using guessed type _DWORD __cdecl sub_8050B6C(_DWORD, _DWORD);

//----- (08051578) --------------------------------------------------------
int __cdecl sub_8051578(int a1, int a2)
{
  return sub_8050B6C(a1, a2);
}
// 8050B6C: using guessed type _DWORD __cdecl sub_8050B6C(_DWORD, _DWORD);

//----- (0805159A) --------------------------------------------------------
int __cdecl sub_805159A(int a1, int a2)
{
  return sub_8050B6C(a2, a1);
}
// 8050B6C: using guessed type _DWORD __cdecl sub_8050B6C(_DWORD, _DWORD);

//----- (080515BC) --------------------------------------------------------
int __cdecl sub_80515BC(int a1, int a2)
{
  return sub_8050B6C(a2, a1);
}
// 8050B6C: using guessed type _DWORD __cdecl sub_8050B6C(_DWORD, _DWORD);

//----- (080515DE) --------------------------------------------------------
signed int __cdecl sub_80515DE(int a1, int a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_805060F(a1);
  v4 = sub_805060F(a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_8050B6C(a1, a2);
}
// 8050B6C: using guessed type _DWORD __cdecl sub_8050B6C(_DWORD, _DWORD);

//----- (0805164C) --------------------------------------------------------
signed int __cdecl sub_805164C(int a1, int a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_805060F(a1);
  v4 = sub_805060F(a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_8050B6C(a1, a2);
}
// 8050B6C: using guessed type _DWORD __cdecl sub_8050B6C(_DWORD, _DWORD);

//----- (080516BA) --------------------------------------------------------
#error "80516F6: call analysis failed (funcsize=37)"

//----- (0805175A) --------------------------------------------------------
#error "80517A1: call analysis failed (funcsize=48)"

//----- (080517F6) --------------------------------------------------------
int __cdecl sub_80517F6(int a1, _DWORD *a2)
{
  return sub_8050C54(a1, a2);
}

//----- (08051818) --------------------------------------------------------
int __cdecl sub_8051818(int a1, _DWORD *a2)
{
  return sub_8050C54(a1, a2);
}

//----- (0805183A) --------------------------------------------------------
int __cdecl sub_805183A(_DWORD *a1, int a2)
{
  return sub_8050C54(a2, a1);
}

//----- (0805185C) --------------------------------------------------------
int __cdecl sub_805185C(_DWORD *a1, int a2)
{
  return sub_8050C54(a2, a1);
}

//----- (0805187E) --------------------------------------------------------
int __cdecl sub_805187E(int a1, _DWORD *a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_805060F(a1);
  v4 = sub_805060F((int)a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_8050C54(a1, a2);
}

//----- (080518EC) --------------------------------------------------------
int __cdecl sub_80518EC(int a1, _DWORD *a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_805060F(a1);
  v4 = sub_805060F((int)a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_8050C54(a1, a2);
}

//----- (0805195A) --------------------------------------------------------
int __cdecl sub_805195A(_DWORD *a1, int a2)
{
  int v2; // edx
  int v3; // ecx
  int v5; // [esp+0h] [ebp-28h]
  char v6; // [esp+1Eh] [ebp-Ah]
  char v7; // [esp+1Fh] [ebp-9h]

  v6 = sub_805060F((int)a1);
  v7 = sub_805060F(a2);
  if ( v6 && v7 != 1 )
    return -1;
  if ( v6 != 1 )
  {
    if ( v7 )
    {
      dword_8072240 = (int)&locret_80519DB;
      sub_80661F2(v3, v2, v5);
    }
  }
  return sub_8050C54(a2, a1);
}
// 8072240: using guessed type int dword_8072240;

//----- (080519DD) --------------------------------------------------------
int __cdecl sub_80519DD(_DWORD *a1, int a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_805060F((int)a1);
  v4 = sub_805060F(a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_8050C54(a2, a1);
}

//----- (08051A4B) --------------------------------------------------------
int __cdecl sub_8051A4B(const char **a1, const char **a2)
{
  return sub_8050C92(a1, a2, sub_8050929);
}

//----- (08051A6D) --------------------------------------------------------
int __cdecl sub_8051A6D(const char **a1, const char **a2)
{
  return sub_8050C92(a1, a2, (int (__cdecl *)(char *, char *))strcmp);
}

//----- (08051A8F) --------------------------------------------------------
int __cdecl sub_8051A8F(const char **a1, const char **a2)
{
  return sub_8050C92(a2, a1, sub_8050929);
}

//----- (08051AB1) --------------------------------------------------------
int __cdecl sub_8051AB1(const char **a1, const char **a2)
{
  return sub_8050C92(a2, a1, (int (__cdecl *)(char *, char *))strcmp);
}

//----- (08051AD3) --------------------------------------------------------
int __cdecl sub_8051AD3(const char **a1, const char **a2)
{
  char v2; // ST26_1
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  int result; // eax
  int v7; // [esp+0h] [ebp-28h]
  int v8; // [esp+4h] [ebp-24h]
  char v9; // [esp+1Fh] [ebp-9h]

  v2 = sub_805060F((int)a1);
  v9 = sub_805060F((int)a2);
  if ( v2 )
  {
    v5 = &loc_8051B1F;
    if ( v9 == 1 )
      v5 = &loc_8051B26;
    dword_80721DC = (int)v5;
    sub_8066431(v4, v3, v7, v8);
    result = -1;
  }
  else if ( v9 )
  {
    result = 1;
  }
  else
  {
    result = sub_8050C92(a1, a2, sub_8050929);
  }
  return result;
}
// 80721DC: using guessed type int dword_80721DC;

//----- (08051B5A) --------------------------------------------------------
int __cdecl sub_8051B5A(const char **a1, const char **a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_805060F((int)a1);
  v4 = sub_805060F((int)a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_8050C92(a1, a2, (int (__cdecl *)(char *, char *))strcmp);
}

//----- (08051BC8) --------------------------------------------------------
int __cdecl sub_8051BC8(const char **a1, const char **a2)
{
  int v2; // edx
  int v3; // ecx
  void *v5; // eax
  char v6; // [esp+1Eh] [ebp-Ah]
  char v7; // [esp+1Fh] [ebp-9h]

  v6 = sub_805060F((int)a1);
  v7 = sub_805060F((int)a2);
  if ( v6 && v7 != 1 )
    return -1;
  if ( v6 == 1 )
    return sub_8050C92(a2, a1, sub_8050929);
  v5 = &loc_8051C2C;
  if ( !v7 )
    v5 = &loc_8051C33;
  dword_807222C = (int)v5;
  sub_806627B(v3, v2);
  return 1;
}
// 806627B: using guessed type int __fastcall sub_806627B(_DWORD, _DWORD);
// 807222C: using guessed type int dword_807222C;

//----- (08051C4F) --------------------------------------------------------
int __cdecl sub_8051C4F(const char **a1, const char **a2)
{
  char v2; // ST26_1
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  int result; // eax
  int v7; // [esp+0h] [ebp-28h]
  int v8; // [esp+4h] [ebp-24h]
  char v9; // [esp+1Fh] [ebp-9h]

  v2 = sub_805060F((int)a1);
  v9 = sub_805060F((int)a2);
  if ( v2 )
  {
    v5 = &loc_8051C9B;
    if ( v9 == 1 )
      v5 = &loc_8051CA2;
    dword_807227C = (int)v5;
    sub_80660A0(v4, v3);
    result = -1;
  }
  else
  {
    dword_80721DC = (int)&loc_8051CC6;
    sub_8066431(v4, v3, v7, v8);
    if ( v9 )
      result = 1;
    else
      result = sub_8050C92(a2, a1, (int (__cdecl *)(char *, char *))strcmp);
  }
  return result;
}
// 80660A0: using guessed type int __fastcall sub_80660A0(_DWORD, _DWORD);
// 80721DC: using guessed type int dword_80721DC;
// 807227C: using guessed type int dword_807227C;

//----- (08051CEF) --------------------------------------------------------
int __cdecl sub_8051CEF(char **a1, char **a2)
{
  return sub_8057E73(*a1, *a2);
}

//----- (08051D0D) --------------------------------------------------------
int __cdecl sub_8051D0D(char **a1, char **a2)
{
  return sub_8051CEF(a1, a2);
}

//----- (08051D27) --------------------------------------------------------
int __cdecl sub_8051D27(char **a1, char **a2)
{
  return sub_8051CEF(a2, a1);
}

//----- (08051D41) --------------------------------------------------------
int __cdecl sub_8051D41(char **a1, char **a2)
{
  void *v3; // eax
  int v4; // [esp+0h] [ebp-28h]
  int v5; // [esp+4h] [ebp-24h]
  int v6; // [esp+8h] [ebp-20h]
  int v7; // [esp+Ch] [ebp-1Ch]
  int v8; // [esp+10h] [ebp-18h]
  int v9; // [esp+14h] [ebp-14h]
  int v10; // [esp+18h] [ebp-10h]
  int v11; // [esp+1Ch] [ebp-Ch]

  BYTE2(v11) = sub_805060F((int)a1);
  HIBYTE(v11) = sub_805060F((int)a2);
  if ( BYTE2(v11) && HIBYTE(v11) != 1 )
    return -1;
  if ( BYTE2(v11) == 1 )
    return sub_8051CEF(a1, a2);
  v3 = &loc_8051DA5;
  if ( !HIBYTE(v11) )
    v3 = &loc_8051DAC;
  dword_80721F0 = (int)v3;
  sub_80663C3(v4, v5, v6, v7, v8, v9, v10, v11);
  return 1;
}
// 80663C3: using guessed type int __stdcall sub_80663C3(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80721F0: using guessed type int dword_80721F0;

//----- (08051DC0) --------------------------------------------------------
int __cdecl sub_8051DC0(char **a1, char **a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_805060F((int)a1);
  v4 = sub_805060F((int)a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_8051CEF(a2, a1);
}

//----- (08051E26) --------------------------------------------------------
int sub_8051E26()
{
  int result; // eax
  unsigned int i; // [esp+Ch] [ebp-8h]

  for ( i = 0; ; ++i )
  {
    result = dword_8072902;
    if ( i >= dword_8072902 )
      break;
    *((_DWORD *)dword_807290A + i) = (char *)dword_80728FA + 136 * i;
  }
  return result;
}
// 8072902: using guessed type int dword_8072902;

//----- (08051E7E) --------------------------------------------------------
#error "8051F1C: call analysis failed (funcsize=97)"

//----- (08052000) --------------------------------------------------------
#error "80520A5: call analysis failed (funcsize=71)"

//----- (0805211B) --------------------------------------------------------
int __cdecl sub_805211B(int a1, int a2, unsigned __int8 a3, int a4, int a5, int a6)
{
  char *v6; // eax

  if ( byte_8073836 )
    v6 = (char *)(((*(_DWORD *)(a4 + 16) + 12 * a3) << 7) + 134687798);
  else
    v6 = (&off_80723CC)[a3];
  return sub_805C7AB(a1, a2, (int)v6, a4, a5, a6);
}
// 8073836: using guessed type char byte_8073836;

//----- (080521AF) --------------------------------------------------------
int __usercall sub_80521AF@<eax>(int a1@<ebx>)
{
  time_t timer; // [esp+2Ch] [ebp-42Ch]
  int v3; // [esp+30h] [ebp-428h]
  struct tm tp; // [esp+34h] [ebp-424h]
  char v5; // [esp+63h] [ebp-3F5h]
  unsigned int v6; // [esp+44Ch] [ebp-Ch]

  v6 = __readgsdword(0x14u);
  if ( dword_80723D8 < 0 )
  {
    timer = 0;
    if ( sub_806462F(dword_80729B6, &timer, &tp) )
    {
      v3 = sub_805211B((int)&v5, 1001, 0, (int)&tp, dword_80729B6, 0);
      if ( v3 )
        dword_80723D8 = sub_805BE4B(a1, &v5, v3, 0);
    }
    if ( dword_80723D8 < 0 )
      dword_80723D8 = 0;
  }
  return dword_80723D8;
}
// 80723D8: using guessed type int dword_80723D8;

//----- (08052297) --------------------------------------------------------
int __usercall sub_8052297@<eax>(int a1@<ebx>, char *s, int a3, int a4)
{
  int v4; // eax
  int v5; // edx
  int v6; // eax
  int v7; // eax
  int result; // eax
  int v9; // [esp+14h] [ebp-14h]
  int v10; // [esp+18h] [ebp-10h]
  int v11; // [esp+1Ch] [ebp-Ch]

  if ( s )
  {
    v4 = sub_805BE22(a1, s, 0);
    v5 = a4 - v4;
    v11 = a4 - v4;
    v6 = 0;
    if ( v5 >= 0 )
      v6 = v11;
    v10 = v6;
    fputs_unlocked(s, stdout);
    v9 = v10 + strlen(s);
    do
    {
      putchar_unlocked(32);
      v7 = v10--;
    }
    while ( v7 );
  }
  else
  {
    printf("%*lu ", a4, a3);
    v9 = a4;
  }
  result = dword_8072A6A + v9 + 1;
  dword_8072A6A += v9 + 1;
  return result;
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8072A6A: using guessed type int dword_8072A6A;

//----- (0805236B) --------------------------------------------------------
int __usercall sub_805236B@<eax>(int a1@<ebx>, __uid_t uid, int a3, int a4)
{
  char *v4; // eax

  if ( (_BYTE)a4 == 1 )
  {
    if ( byte_8072960 )
      v4 = 0;
    else
      v4 = sub_805B175(uid);
  }
  else
  {
    v4 = "?";
  }
  return sub_8052297(a1, v4, uid, a3);
}
// 8072960: using guessed type char byte_8072960;

//----- (080523BE) --------------------------------------------------------
int __usercall sub_80523BE@<eax>(int a1@<ebx>, __gid_t gid, int a3, int a4)
{
  char *v4; // eax

  if ( (_BYTE)a4 == 1 )
  {
    if ( byte_8072960 )
      v4 = 0;
    else
      v4 = (char *)sub_805B39D(gid);
  }
  else
  {
    v4 = "?";
  }
  return sub_8052297(a1, v4, gid, a3);
}
// 8072960: using guessed type char byte_8072960;

//----- (08052411) --------------------------------------------------------
size_t __usercall sub_8052411@<eax>(int a1@<ebx>, char *a2, int a3)
{
  size_t result; // eax
  int v4; // [esp+1Ch] [ebp-1Ch]
  char s; // [esp+21h] [ebp-17h]
  unsigned int v6; // [esp+2Ch] [ebp-Ch]

  v6 = __readgsdword(0x14u);
  if ( a2 )
  {
    v4 = sub_805BE22(a1, a2, 0);
    result = 0;
    if ( v4 >= 0 )
      result = v4;
  }
  else
  {
    sprintf(&s, "%lu", a3);
    result = strlen(&s);
  }
  return result;
}

//----- (0805248B) --------------------------------------------------------
size_t __usercall sub_805248B@<eax>(int a1@<ebx>, __uid_t uid)
{
  char *v2; // eax

  if ( byte_8072960 )
    v2 = 0;
  else
    v2 = sub_805B175(uid);
  return sub_8052411(a1, v2, uid);
}
// 8072960: using guessed type char byte_8072960;

//----- (080524BF) --------------------------------------------------------
int __fastcall sub_80524BF(int a1, int a2)
{
  dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))sub_80524FA;
  if ( byte_8072960 )
    dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))&loc_8052505;
  return dword_80722B8(a1, a2);
}
// 80524FA: using guessed type int __cdecl sub_80524FA(int);
// 80722B8: using guessed type int (__fastcall *dword_80722B8)(_DWORD, _DWORD);
// 8072960: using guessed type char byte_8072960;

//----- (080524FA) --------------------------------------------------------
#error "8052515: positive sp value has been found (funcsize=0)"

//----- (08052516) --------------------------------------------------------
int __fastcall sub_8052516(int a1, int a2, int a3, unsigned int a4)
{
  dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))sub_8052558;
  if ( a4 <= 0x14 )
    __assert_fail("INT_BUFSIZE_BOUND (uintmax_t) <= buflen", "src/ls.c", 0xFA7u, "format_inode");
  return dword_80722B8(a1, a2);
}
// 8052558: using guessed type int __cdecl sub_8052558(int, int);
// 80722B8: using guessed type int (__fastcall *dword_80722B8)(_DWORD, _DWORD);

//----- (08052558) --------------------------------------------------------
#error "80525AD: call analysis failed (funcsize=31)"

//----- (080525C5) --------------------------------------------------------
#error "80525CB: positive sp value has been found (funcsize=0)"

//----- (080525CC) --------------------------------------------------------
#error "8052E0B: call analysis failed (funcsize=661)"

//----- (08053280) --------------------------------------------------------
int __cdecl sub_8053280(int *a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  void *v8; // eax
  int v9; // edx
  int v10; // ecx
  int v11; // [esp+0h] [ebp-88h]
  int v12; // [esp+4h] [ebp-84h]
  int v13; // [esp+8h] [ebp-80h]
  int v14; // [esp+Ch] [ebp-7Ch]
  int v15; // [esp+10h] [ebp-78h]
  int v16; // [esp+14h] [ebp-74h]
  int v17; // [esp+18h] [ebp-70h]
  int v18; // [esp+30h] [ebp-58h]
  int v19; // [esp+34h] [ebp-54h]
  int v20; // [esp+38h] [ebp-50h]
  int v21; // [esp+3Ch] [ebp-4Ch]
  int v22; // [esp+40h] [ebp-48h]
  int v23; // [esp+44h] [ebp-44h]
  int v24; // [esp+4Ch] [ebp-3Ch]
  int v25; // [esp+50h] [ebp-38h]
  int v26; // [esp+54h] [ebp-34h]
  int v27; // [esp+58h] [ebp-30h]
  int v28; // [esp+60h] [ebp-28h]

  v22 = *a1;
  v28 = sub_805F949(a4);
  dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))sub_8053380;
  v8 = &loc_8053320;
  if ( !byte_807299E )
    v8 = &loc_804E032;
  dword_8072290 = (int)v8;
  sub_8066034(
    v11,
    v12,
    v13,
    v14,
    v15,
    v16,
    v17,
    a7,
    a6,
    a4,
    a3,
    a1,
    v18,
    v19,
    v20,
    v21,
    v22,
    v23,
    0,
    v24,
    v25,
    v26,
    v27);
  dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))&loc_8053368;
  if ( v28 != 1 )
  {
    dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))&loc_8053368;
    if ( v28 != 2 )
    {
      dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))sub_8053380;
      if ( !v28 )
        dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))&loc_8053385;
    }
  }
  return dword_80722B8(v10, v9);
}
// 8053380: using guessed type int __cdecl sub_8053380(int, int, int, int);
// 8066034: using guessed type int __stdcall sub_8066034(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8072290: using guessed type int dword_8072290;
// 80722B8: using guessed type int (__fastcall *dword_80722B8)(_DWORD, _DWORD);
// 807299E: using guessed type char byte_807299E;

//----- (08053380) --------------------------------------------------------
#error "80533B4: call analysis failed (funcsize=77)"

//----- (080534A6) --------------------------------------------------------
int __usercall sub_80534A6@<eax>(int a1@<ebp>, int a2@<edx>, int a3@<ecx>)
{
  *(_BYTE *)(a1 - 78) = 0;
  *(_BYTE *)(a1 - 78) &= 1u;
  dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))sub_8053561;
  return ((int (__fastcall *)(int, int))sub_8053561)(a3, a2);
}
// 8053561: using guessed type int sub_8053561();
// 80722B8: using guessed type int (__fastcall *dword_80722B8)(_DWORD, _DWORD);

//----- (08053C12) --------------------------------------------------------
#error "8053C95: call analysis failed (funcsize=33)"

//----- (08053C9A) --------------------------------------------------------
#error "8053D33: positive sp value has been found (funcsize=37)"

//----- (08053D34) --------------------------------------------------------
#error "8053DC4: call analysis failed (funcsize=63)"

//----- (08053E2F) --------------------------------------------------------
int __usercall sub_8053E2F@<eax>(int a1@<ebx>, int a2, int a3, int a4, int a5, char a6, int a7, char *a8)
{
  void *v8; // eax
  int v9; // ebx
  int v10; // eax
  int v11; // edx
  int v12; // ecx
  void *v13; // eax
  char *v14; // eax
  int v16; // [esp-8h] [ebp-2080h]
  int v17; // [esp-4h] [ebp-207Ch]
  int v18; // [esp+0h] [ebp-2078h]
  void *v19; // [esp+4h] [ebp-2074h]
  char *v20; // [esp+8h] [ebp-2070h]
  void *v21; // [esp+Ch] [ebp-206Ch]
  int v22; // [esp+10h] [ebp-2068h]
  int v23; // [esp+14h] [ebp-2064h]
  int v24; // [esp+18h] [ebp-2060h]
  int v25; // [esp+1Ch] [ebp-205Ch]
  char *s; // [esp+28h] [ebp-2050h]
  int v27; // [esp+2Ch] [ebp-204Ch]
  char v28; // [esp+30h] [ebp-2048h]
  int v29; // [esp+34h] [ebp-2044h]
  int v30; // [esp+38h] [ebp-2040h]
  void *v31; // [esp+3Ch] [ebp-203Ch]
  unsigned __int8 v32; // [esp+42h] [ebp-2036h]
  unsigned __int8 v33; // [esp+43h] [ebp-2035h]
  void *v34; // [esp+44h] [ebp-2034h]
  int v35; // [esp+48h] [ebp-2030h]
  void *ptr; // [esp+4Ch] [ebp-202Ch]
  void *v37; // [esp+50h] [ebp-2028h]
  int v38; // [esp+54h] [ebp-2024h]
  size_t n; // [esp+58h] [ebp-2020h]
  int v40; // [esp+5Ch] [ebp-201Ch]
  int v41; // [esp+60h] [ebp-2018h]
  size_t v42; // [esp+64h] [ebp-2014h]
  int v43; // [esp+68h] [ebp-2010h]
  char v44; // [esp+6Ch] [ebp-200Ch]
  unsigned int v45; // [esp+206Ch] [ebp-Ch]

  v31 = (void *)a2;
  v30 = a3;
  v29 = a5;
  v28 = a6;
  v27 = a7;
  s = a8;
  v45 = __readgsdword(0x14u);
  v34 = &v18 - 2051;
  v35 = sub_8053280(&v18 - 2061, 0x2000, a2, a3, a4, 0, (int)&v18 - 8246);
  v17 = v32;
  v16 = a1;
  v8 = &loc_8053F14;
  if ( !v32 )
    v8 = &loc_8053F36;
  dword_80721F0 = (int)v8;
  v9 = v16;
  v10 = sub_80663C3(v18, v19, v20, v21, v22, v23, v24, v25);
  if ( v28 )
  {
    putchar_unlocked(32);
    v10 = dword_8072A6A++ + 1;
  }
  if ( v29 )
    LOBYTE(v10) = sub_8054A3C(v11, v12, v29);
  v33 = 0;
  v17 = v10;
  v16 = v9;
  v13 = &loc_8053F76;
  if ( !s )
    v13 = &loc_8054045;
  dword_807227C = (int)v13;
  sub_80660A0(v12, v11);
  if ( byte_8072907 && byte_8072906 && v32 != 1 )
  {
    v33 = 1;
    putchar_unlocked(*(char *)v34);
  }
  ptr = (void *)sub_8053D34(::s, 0);
  v37 = (void *)sub_8053D34(s, 1);
  if ( *(_BYTE *)v37 == 47 )
    v14 = &locale;
  else
    v14 = "/";
  v21 = v37;
  v20 = v14;
  v19 = ptr;
  printf("\x1B]8;;file://%s%s%s\a", ptr, v14, v37);
  free(ptr);
  free(v37);
  if ( v27 && byte_8072972 )
  {
    v38 = v27;
    n = 4;
    v40 = v27;
    if ( (unsigned int)(*(_DWORD *)(v27 + 16) - *(_DWORD *)(v27 + 12)) < 4 )
      sub_8063CBD(v38, n);
    memcpy(*(void **)(v38 + 12), &dword_8072A6A, n);
    *(_DWORD *)(v38 + 12) += n;
  }
  fwrite_unlocked((char *)v34 + v33, 1u, v35 - 2 * v33, stdout);
  dword_8072A6A += v35;
  if ( v27 && byte_8072972 )
  {
    v41 = v27;
    v42 = 4;
    v43 = v27;
    if ( (unsigned int)(*(_DWORD *)(v41 + 16) - *(_DWORD *)(v41 + 12)) < 4 )
      sub_8063CBD(v41, v42);
    memcpy(*(void **)(v41 + 12), &dword_8072A6A, v42);
    *(_DWORD *)(v41 + 12) += v42;
  }
  if ( s )
  {
    fwrite_unlocked("\x1B]8;;\a", 1u, 6u, stdout);
    if ( v33 )
      putchar_unlocked(*((char *)v34 + v35 - 1));
  }
  if ( v34 != &v44 && v34 != v31 )
    free(v34);
  return v32 + v35;
}
// 8063CBD: using guessed type _DWORD __cdecl sub_8063CBD(_DWORD, _DWORD);
// 80660A0: using guessed type int __fastcall sub_80660A0(_DWORD, _DWORD);
// 80663C3: using guessed type int __stdcall sub_80663C3(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80721F0: using guessed type int dword_80721F0;
// 807227C: using guessed type int dword_807227C;
// 8072906: using guessed type char byte_8072906;
// 8072907: using guessed type char byte_8072907;
// 8072972: using guessed type char byte_8072972;
// 8072A6A: using guessed type int dword_8072A6A;

//----- (08054304) --------------------------------------------------------
#error "8054467: call analysis failed (funcsize=109)"

//----- (0805448D) --------------------------------------------------------
size_t __fastcall sub_805448D(int a1, int a2)
{
  void *v2; // eax

  v2 = &loc_80544B5;
  if ( !dword_8072320 )
    v2 = &loc_80544C3;
  dword_8072254 = (int)v2;
  sub_806617E(a1, a2);
  return sub_8054EFE((int)&unk_807231C);
}
// 806617E: using guessed type int __fastcall sub_806617E(_DWORD, _DWORD);
// 8072254: using guessed type int dword_8072254;
// 8072320: using guessed type int dword_8072320;

//----- (080544E9) --------------------------------------------------------
#error "805450A: call analysis failed (funcsize=14)"

//----- (0805450F) --------------------------------------------------------
#error "805457F: call analysis failed (funcsize=44)"

//----- (080545BA) --------------------------------------------------------
#error "80545CE: call analysis failed (funcsize=27)"

//----- (0805462B) --------------------------------------------------------
#error "8054696: call analysis failed (funcsize=36)"

//----- (080546D1) --------------------------------------------------------
#error "80546E5: call analysis failed (funcsize=27)"

//----- (08054744) --------------------------------------------------------
#error "8054758: call analysis failed (funcsize=46)"

//----- (08054814) --------------------------------------------------------
#error "805481A: positive sp value has been found (funcsize=0)"

//----- (0805481E) --------------------------------------------------------
#error "805484E: call analysis failed (funcsize=45)"

//----- (080549C2) --------------------------------------------------------
bool __cdecl sub_80549C2(unsigned __int8 a1, int a2, int a3)
{
  char v3; // al
  int v4; // edx
  int v5; // ecx
  bool v6; // zf
  void *v7; // eax
  char v9; // [esp+1Fh] [ebp-9h]

  v3 = sub_805481E(a1, a2, a3);
  v9 = v3;
  v6 = v3 == 0;
  v7 = &loc_8054A1A;
  if ( v6 )
    v7 = &loc_8054A33;
  dword_8072254 = (int)v7;
  sub_806617E(v5, v4);
  putchar_unlocked(v9);
  ++dword_8072A6A;
  return v9 != 0;
}
// 805481E: using guessed type _DWORD __cdecl sub_805481E(_DWORD, _DWORD, _DWORD);
// 806617E: using guessed type int __fastcall sub_806617E(_DWORD, _DWORD);
// 8072254: using guessed type int dword_8072254;
// 8072A6A: using guessed type int dword_8072A6A;

//----- (08054A3C) --------------------------------------------------------
bool __usercall sub_8054A3C@<al>(int a1@<edx>, int a2@<ecx>, int a3)
{
  if ( a3 )
  {
    if ( (unsigned __int8)sub_804BD16(a2, a1, 4) )
      sub_804BE2A();
    sub_8054EFE((int)dword_807230C);
    sub_8054EFE(a3);
    sub_8054EFE((int)&dword_8072314);
  }
  return a3 != 0;
}
// 807230C: using guessed type int dword_807230C[];
// 8072314: using guessed type int dword_8072314;

//----- (08054A89) --------------------------------------------------------
#error "8054BEC: call analysis failed (funcsize=224)"

//----- (08054EFE) --------------------------------------------------------
size_t __cdecl sub_8054EFE(int a1)
{
  int v1; // edx
  int v2; // ecx

  if ( byte_807297C != 1 )
  {
    byte_807297C = 1;
    if ( tcgetpgrp(1) >= 0 )
      sub_804C190(v2, v1);
    sub_805448D(v2, v1);
  }
  return fwrite_unlocked(*(const void **)(a1 + 4), *(_DWORD *)a1, 1u, stdout);
}
// 807297C: using guessed type char byte_807297C;

//----- (08054F5E) --------------------------------------------------------
int __usercall sub_8054F5E@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, int a4)
{
  int v4; // edx
  const char *v5; // eax
  int v6; // eax
  void *v7; // eax
  const char *v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // edx
  int v14; // eax
  int v16; // [esp-8h] [ebp-2E0h]
  int v17; // [esp-4h] [ebp-2DCh]
  const char *v18; // [esp+0h] [ebp-2D8h]
  int v19; // [esp+4h] [ebp-2D4h]
  int v20; // [esp+8h] [ebp-2D0h]
  int v21; // [esp+Ch] [ebp-2CCh]
  int v22; // [esp+10h] [ebp-2C8h]
  int v23; // [esp+14h] [ebp-2C4h]
  int v24; // [esp+18h] [ebp-2C0h]
  int v25; // [esp+1Ch] [ebp-2BCh]
  int v26; // [esp+20h] [ebp-2B8h]
  int v27; // [esp+24h] [ebp-2B4h]
  int v28; // [esp+28h] [ebp-2B0h]
  int *v29; // [esp+2Ch] [ebp-2ACh]
  int v30; // [esp+30h] [ebp-2A8h]
  int v31; // [esp+34h] [ebp-2A4h]
  int v32; // [esp+38h] [ebp-2A0h]
  int v33; // [esp+3Ch] [ebp-29Ch]
  char s; // [esp+40h] [ebp-298h]
  unsigned int v35; // [esp+2CCh] [ebp-Ch]

  v29 = (int *)a4;
  v35 = __readgsdword(0x14u);
  v33 = 0;
  if ( byte_8072987 )
  {
    if ( dword_8072952 == 4 )
    {
      v4 = v29[26];
      v18 = (const char *)v29[25];
      v19 = v4;
      v5 = (const char *)sub_805B77A(*(__int64 *)&v18, (int)&s);
      v6 = strlen(v5) + 1;
    }
    else
    {
      v6 = dword_807292A + 1;
    }
    v33 += v6;
  }
  v17 = (unsigned __int8)byte_8072961;
  v16 = a3;
  v7 = &loc_805500D;
  if ( !byte_8072961 )
    v7 = &loc_80550D3;
  dword_807222C = (int)v7;
  sub_806627B(a2, a1);
  if ( dword_8072952 == 4 )
  {
    if ( *((_BYTE *)v29 + 120) != 1 )
    {
      dword_8072218 = (int)&loc_80550B8;
      sub_80662EB(v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32);
    }
    v8 = (const char *)sub_805A051(
                         v29[17],
                         v29[18],
                         (char *)&v18 - 664,
                         dword_8072962,
                         512,
                         0,
                         dword_8072966,
                         dword_807296A);
    v9 = strlen(v8) + 1;
  }
  else
  {
    v9 = dword_807292E + 1;
  }
  v33 += v9;
  if ( byte_8072926 )
  {
    if ( dword_8072952 == 4 )
    {
      v18 = (const char *)v29[29];
      v10 = strlen(v18) + 1;
    }
    else
    {
      v10 = dword_8072936 + 1;
    }
    v33 += v10;
  }
  v11 = *v29;
  v20 = v29[33];
  v12 = sub_8053C12(v11, dword_80729A2, v20);
  v33 += v12;
  if ( dword_8072976 )
  {
    v13 = v29[7];
    v14 = *((unsigned __int8 *)v29 + 120);
    v20 = v29[27];
    HIBYTE(v32) = sub_805481E(v14, v13, v20);
    v33 += HIBYTE(v32) != 0;
  }
  return v33;
}
// 8053C12: using guessed type _DWORD __cdecl sub_8053C12(_DWORD, _DWORD, _DWORD);
// 805481E: using guessed type _DWORD __cdecl sub_805481E(_DWORD, _DWORD, _DWORD);
// 806627B: using guessed type int __fastcall sub_806627B(_DWORD, _DWORD);
// 80662EB: using guessed type int __stdcall sub_80662EB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8072218: using guessed type int dword_8072218;
// 807222C: using guessed type int dword_807222C;
// 8072926: using guessed type char byte_8072926;
// 807292A: using guessed type int dword_807292A;
// 807292E: using guessed type int dword_807292E;
// 8072952: using guessed type int dword_8072952;
// 8072961: using guessed type char byte_8072961;
// 8072976: using guessed type int dword_8072976;
// 8072987: using guessed type char byte_8072987;
// 80729A2: using guessed type int dword_80729A2;

//----- (080551BE) --------------------------------------------------------
#error "805523F: call analysis failed (funcsize=39)"

//----- (08055244) --------------------------------------------------------
#error "8055340: positive sp value has been found (funcsize=70)"

//----- (08055341) --------------------------------------------------------
#error "80553E2: call analysis failed (funcsize=83)"

//----- (08055470) --------------------------------------------------------
#error "80554BF: positive sp value has been found (funcsize=0)"

//----- (080554C0) --------------------------------------------------------
int __usercall sub_80554C0@<eax>(int a1@<ecx>, int a2@<ebx>, char a3)
{
  int v3; // eax
  char v5; // [esp+1Fh] [ebp-19h]
  unsigned int i; // [esp+20h] [ebp-18h]
  unsigned int v7; // [esp+24h] [ebp-14h]
  int v8; // [esp+28h] [ebp-10h]
  int v9; // [esp+2Ch] [ebp-Ch]

  v7 = 0;
  for ( i = 0; i < dword_8072902; ++i )
  {
    v8 = *((_DWORD *)dword_807290A + i);
    if ( dword_80729B2 )
      v3 = sub_8054F5E(4 * i, a1, a2, v8);
    else
      v3 = 0;
    v9 = v3;
    if ( i )
    {
      if ( dword_80729B2 && (v7 + v3 + 2 >= dword_80729B2 || -3 - v3 < v7) )
      {
        v7 = 0;
        v5 = 10;
      }
      else
      {
        v7 += 2;
        v5 = 32;
      }
      putchar_unlocked(a3);
      putchar_unlocked(v5);
    }
    sub_80544E9(v8, v7);
    v7 += v9;
  }
  return putchar_unlocked(10);
}
// 80544E9: using guessed type int __cdecl sub_80544E9(_DWORD, _DWORD);
// 8072902: using guessed type int dword_8072902;
// 80729B2: using guessed type int dword_80729B2;

//----- (080555A4) --------------------------------------------------------
unsigned int __cdecl sub_80555A4(unsigned int a1, unsigned int a2)
{
  unsigned int result; // eax

  while ( 1 )
  {
    result = a1;
    if ( a1 >= a2 )
      break;
    if ( dword_80729AA && a2 / dword_80729AA > (a1 + 1) / dword_80729AA )
    {
      putchar_unlocked(9);
      a1 += dword_80729AA - a1 % dword_80729AA;
    }
    else
    {
      putchar_unlocked(32);
      ++a1;
    }
  }
  return result;
}
// 80729AA: using guessed type int dword_80729AA;

//----- (08055655) --------------------------------------------------------
#error "80556CA: call analysis failed (funcsize=62)"

//----- (080556FE) --------------------------------------------------------
#error "805590F: call analysis failed (funcsize=96)"

//----- (080559A2) --------------------------------------------------------
#error "80559E3: call analysis failed (funcsize=22)"

//----- (080559E8) --------------------------------------------------------
#error "8055C95: positive sp value has been found (funcsize=124)"

//----- (08055C9A) --------------------------------------------------------
void __cdecl __noreturn sub_8055C9A(int status)
{
  int v1; // ebx
  char *v2; // eax
  int v3; // ebx
  char *v4; // eax
  FILE *v5; // ebx
  char *v6; // eax
  FILE *v7; // ebx
  char *v8; // eax
  FILE *v9; // ebx
  char *v10; // eax
  FILE *v11; // ebx
  char *v12; // eax
  FILE *v13; // ebx
  char *v14; // eax
  FILE *v15; // ebx
  char *v16; // eax
  FILE *v17; // ebx
  char *v18; // eax
  FILE *v19; // ebx
  char *v20; // eax
  FILE *v21; // ebx
  char *v22; // eax
  FILE *v23; // ebx
  char *v24; // eax
  FILE *v25; // ebx
  char *v26; // eax
  FILE *v27; // ebx
  char *v28; // eax
  FILE *v29; // ebx
  char *v30; // eax
  FILE *v31; // ebx
  char *v32; // eax
  FILE *v33; // ebx
  char *v34; // eax
  FILE *v35; // ebx
  char *v36; // eax
  FILE *v37; // ebx
  char *v38; // eax
  FILE *v39; // ebx
  char *v40; // eax
  FILE *v41; // ebx
  char *v42; // eax
  FILE *v43; // ebx
  char *v44; // eax
  FILE *v45; // ebx
  char *v46; // eax
  FILE *v47; // ebx
  char *v48; // eax
  FILE *v49; // ebx
  char *v50; // eax
  FILE *v51; // ebx
  char *v52; // eax
  int v53; // edx
  int v54; // ecx
  void *v55; // eax
  char *v56; // eax
  int v57; // [esp+0h] [ebp-18h]

  if ( status )
  {
    v1 = dword_807392A;
    v2 = gettext("Try '%s --help' for more information.\n");
    fprintf(stderr, v2, v1);
  }
  else
  {
    v3 = dword_807392A;
    v4 = gettext("Usage: %s [OPTION]... [FILE]...\n");
    printf(v4, v3);
    v5 = stdout;
    v6 = gettext(
           "List information about the FILEs (the current directory by default).\n"
           "Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.\n");
    fputs_unlocked(v6, v5);
    sub_804ADF9();
    v7 = stdout;
    v8 = gettext(
           "  -a, --all                  do not ignore entries starting with .\n"
           "  -A, --almost-all           do not list implied . and ..\n"
           "      --author               with -l, print the author of each file\n"
           "  -b, --escape               print C-style escapes for nongraphic characters\n");
    fputs_unlocked(v8, v7);
    v9 = stdout;
    v10 = gettext(
            "      --block-size=SIZE      scale sizes by SIZE before printing them; e.g.,\n"
            "                               '--block-size=M' prints sizes in units of\n"
            "                               1,048,576 bytes; see SIZE format below\n"
            "  -B, --ignore-backups       do not list implied entries ending with ~\n"
            "  -c                         with -lt: sort by, and show, ctime (time of last\n"
            "                               modification of file status information);\n"
            "                               with -l: show ctime and sort by name;\n"
            "                               otherwise: sort by ctime, newest first\n");
    fputs_unlocked(v10, v9);
    v11 = stdout;
    v12 = gettext(
            "  -C                         list entries by columns\n"
            "      --color[=WHEN]         colorize the output; WHEN can be 'always' (default\n"
            "                               if omitted), 'auto', or 'never'; more info below\n"
            "  -d, --directory            list directories themselves, not their contents\n"
            "  -D, --dired                generate output designed for Emacs' dired mode\n");
    fputs_unlocked(v12, v11);
    v13 = stdout;
    v14 = gettext(
            "  -f                         do not sort, enable -aU, disable -ls --color\n"
            "  -F, --classify             append indicator (one of */=>@|) to entries\n"
            "      --file-type            likewise, except do not append '*'\n"
            "      --format=WORD          across -x, commas -m, horizontal -x, long -l,\n"
            "                               single-column -1, verbose -l, vertical -C\n"
            "      --full-time            like -l --time-style=full-iso\n");
    fputs_unlocked(v14, v13);
    v15 = stdout;
    v16 = gettext("  -g                         like -l, but do not list owner\n");
    fputs_unlocked(v16, v15);
    v17 = stdout;
    v18 = gettext(
            "      --group-directories-first\n"
            "                             group directories before files;\n"
            "                               can be augmented with a --sort option, but any\n"
            "                               use of --sort=none (-U) disables grouping\n");
    fputs_unlocked(v18, v17);
    v19 = stdout;
    v20 = gettext(
            "  -G, --no-group             in a long listing, don't print group names\n"
            "  -h, --human-readable       with -l and/or -s, print human readable sizes\n"
            "                               (e.g., 1K 234M 2G)\n"
            "      --si                   likewise, but use powers of 1000 not 1024\n");
    fputs_unlocked(v20, v19);
    v21 = stdout;
    v22 = gettext(
            "  -H, --dereference-command-line\n"
            "                             follow symbolic links listed on the command line\n"
            "      --dereference-command-line-symlink-to-dir\n"
            "                             follow each command line symbolic link\n"
            "                               that points to a directory\n"
            "      --hide=PATTERN         do not list implied entries matching shell PATTERN\n"
            "                               (overridden by -a or -A)\n");
    fputs_unlocked(v22, v21);
    v23 = stdout;
    v24 = gettext(
            "      --hyperlink[=WHEN]     hyperlink file names; WHEN can be 'always'\n"
            "                               (default if omitted), 'auto', or 'never'\n");
    fputs_unlocked(v24, v23);
    v25 = stdout;
    v26 = gettext(
            "      --indicator-style=WORD  append indicator with style WORD to entry names:\n"
            "                               none (default), slash (-p),\n"
            "                               file-type (--file-type), classify (-F)\n"
            "  -i, --inode                print the index number of each file\n"
            "  -I, --ignore=PATTERN       do not list implied entries matching shell PATTERN\n"
            "  -k, --kibibytes            default to 1024-byte blocks for disk usage\n");
    fputs_unlocked(v26, v25);
    v27 = stdout;
    v28 = gettext(
            "  -l                         use a long listing format\n"
            "  -L, --dereference          when showing file information for a symbolic\n"
            "                               link, show information for the file the link\n"
            "                               references rather than for the link itself\n"
            "  -m                         fill width with a comma separated list of entries\n");
    fputs_unlocked(v28, v27);
    v29 = stdout;
    v30 = gettext(
            "  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs\n"
            "  -N, --literal              print entry names without quoting\n"
            "  -o                         like -l, but do not list group information\n"
            "  -p, --indicator-style=slash\n"
            "                             append / indicator to directories\n");
    fputs_unlocked(v30, v29);
    v31 = stdout;
    v32 = gettext(
            "  -q, --hide-control-chars   print ? instead of nongraphic characters\n"
            "      --show-control-chars   show nongraphic characters as-is (the default,\n"
            "                               unless program is 'ls' and output is a terminal)\n"
            "  -Q, --quote-name           enclose entry names in double quotes\n"
            "      --quoting-style=WORD   use quoting style WORD for entry names:\n"
            "                               literal, locale, shell, shell-always,\n"
            "                               shell-escape, shell-escape-always, c, escape\n");
    fputs_unlocked(v32, v31);
    v33 = stdout;
    v34 = gettext(
            "  -r, --reverse              reverse order while sorting\n"
            "  -R, --recursive            list subdirectories recursively\n"
            "  -s, --size                 print the allocated size of each file, in blocks\n");
    fputs_unlocked(v34, v33);
    v35 = stdout;
    v36 = gettext(
            "  -S                         sort by file size, largest first\n"
            "      --sort=WORD            sort by WORD instead of name: none (-U), size (-S),\n"
            "                               time (-t), version (-v), extension (-X)\n"
            "      --time=WORD            with -l, show time as WORD instead of default\n"
            "                               modification time: atime or access or use (-u);\n"
            "                               ctime or status (-c); also use specified time\n"
            "                               as sort key if --sort=time (newest first)\n");
    fputs_unlocked(v36, v35);
    v37 = stdout;
    v38 = gettext(
            "      --time-style=STYLE     with -l, show times using style STYLE:\n"
            "                               full-iso, long-iso, iso, locale, or +FORMAT;\n"
            "                               FORMAT is interpreted like in 'date'; if FORMAT\n"
            "                               is FORMAT1<newline>FORMAT2, then FORMAT1 applies\n"
            "                               to non-recent files and FORMAT2 to recent files;\n"
            "                               if STYLE is prefixed with 'posix-', STYLE\n"
            "                               takes effect only outside the POSIX locale\n");
    fputs_unlocked(v38, v37);
    v39 = stdout;
    v40 = gettext(
            "  -t                         sort by modification time, newest first\n"
            "  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8\n");
    fputs_unlocked(v40, v39);
    v41 = stdout;
    v42 = gettext(
            "  -u                         with -lt: sort by, and show, access time;\n"
            "                               with -l: show access time and sort by name;\n"
            "                               otherwise: sort by access time, newest first\n"
            "  -U                         do not sort; list entries in directory order\n"
            "  -v                         natural sort of (version) numbers within text\n");
    fputs_unlocked(v42, v41);
    v43 = stdout;
    v44 = gettext(
            "  -w, --width=COLS           set output width to COLS.  0 means no limit\n"
            "  -x                         list entries by lines instead of by columns\n"
            "  -X                         sort alphabetically by entry extension\n"
            "  -Z, --context              print any security context of each file\n"
            "  -1                         list one file per line.  Avoid '\\n' with -q or -b\n");
    fputs_unlocked(v44, v43);
    v45 = stdout;
    v46 = gettext("      --help     display this help and exit\n");
    fputs_unlocked(v46, v45);
    v47 = stdout;
    v48 = gettext("      --version  output version information and exit\n");
    fputs_unlocked(v48, v47);
    sub_804AE24();
    v49 = stdout;
    v50 = gettext(
            "\n"
            "Using color to distinguish file types is disabled both by default and\n"
            "with --color=never.  With --color=auto, ls emits color codes only when\n"
            "standard output is connected to a terminal.  The LS_COLORS environment\n"
            "variable can change the settings.  Use the dircolors command to set it.\n");
    fputs_unlocked(v50, v49);
    v51 = stdout;
    v52 = gettext(
            "\n"
            "Exit status:\n"
            " 0  if OK,\n"
            " 1  if minor problems (e.g., cannot access subdirectory),\n"
            " 2  if serious trouble (e.g., cannot access command-line argument).\n");
    fputs_unlocked(v52, v51);
    if ( dword_8072414 == 1 )
    {
      v56 = "ls";
    }
    else
    {
      v55 = &loc_8055FF9;
      if ( dword_8072414 != 2 )
        v55 = &loc_8056000;
      dword_8072240 = (int)v55;
      sub_80661F2(v54, v53, v57);
      v56 = "dir";
    }
    sub_804AE4F(v56);
  }
  exit(status);
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8072240: using guessed type int dword_8072240;
// 8072414: using guessed type int dword_8072414;
// 807392A: using guessed type int dword_807392A;

//----- (0805601F) --------------------------------------------------------
char *__usercall sub_805601F@<eax>(int a1@<edx>, int a2@<ecx>, char *path, int a4)
{
  int v5; // ST2C_4
  int v6; // [esp+0h] [ebp-38h]
  size_t size; // [esp+10h] [ebp-28h]
  char *buf; // [esp+20h] [ebp-18h]
  ssize_t v9; // [esp+28h] [ebp-10h]

  if ( (unsigned int)a4 < 0x401 )
  {
    dword_8072240 = (int)&loc_8056071;
    sub_80661F2(a2, a1, v6);
  }
  for ( size = 1025; ; size = 0x7FFFFFFF )
  {
    while ( 1 )
    {
      buf = (char *)malloc(size);
      if ( !buf )
        return 0;
      v9 = readlink(path, buf, size);
      if ( v9 < 0 && *__errno_location() != 34 )
      {
        v5 = *__errno_location();
        free(buf);
        *__errno_location() = v5;
        return 0;
      }
      if ( v9 < size )
      {
        buf[v9] = 0;
        return buf;
      }
      free(buf);
      if ( size > 0x3FFFFFFF )
        break;
      size *= 2;
    }
    if ( size > 0x7FFFFFFE )
      break;
  }
  *__errno_location() = 12;
  return 0;
}
// 8072240: using guessed type int dword_8072240;

//----- (08056148) --------------------------------------------------------
void __noreturn sub_8056148()
{
  sub_8055C9A(1);
}

//----- (0805615C) --------------------------------------------------------
int __cdecl sub_805615C(char *s, int a2)
{
  bool v2; // zf
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  int i; // [esp+14h] [ebp-14h]
  size_t n; // [esp+1Ch] [ebp-Ch]

  n = strlen(s);
  for ( i = 0; ; ++i )
  {
    if ( !*(_DWORD *)(4 * i + a2) )
      return -1;
    if ( !strncmp(*(const char **)(4 * i + a2), s, n) )
      break;
  }
  v2 = strlen(*(const char **)(4 * i + a2)) == n;
  v5 = &loc_805620D;
  if ( !v2 )
    v5 = &loc_8056215;
  dword_807222C = (int)v5;
  sub_806627B(v4, v3);
  return i;
}
// 806627B: using guessed type int __fastcall sub_806627B(_DWORD, _DWORD);
// 807222C: using guessed type int dword_807222C;

//----- (080562C5) --------------------------------------------------------
void __cdecl sub_80562C5(int a1, int a2, int a3)
{
  char *v3; // eax
  char *format; // ST2C_4
  int v5; // ebx
  int v6; // eax

  if ( a3 == -1 )
    v3 = gettext("invalid argument %s for %s");
  else
    v3 = gettext("ambiguous argument %s for %s");
  format = v3;
  v5 = sub_80617E7(1, a1);
  v6 = sub_806129C(0, 8, a2);
  error(0, 0, format, v6, v5);
}

//----- (08056348) --------------------------------------------------------
int __cdecl sub_8056348(int a1, int a2, size_t n)
{
  FILE *v3; // ebx
  char *v4; // eax
  int v5; // ecx
  void *v6; // eax
  int v8; // [esp+8h] [ebp-20h]
  int i; // [esp+18h] [ebp-10h]
  void *s1; // [esp+1Ch] [ebp-Ch]

  s1 = 0;
  v3 = stderr;
  v4 = gettext("Valid arguments are:");
  fputs_unlocked(v4, v3);
  for ( i = 0; *(_DWORD *)(4 * i + a1); ++i )
  {
    v6 = &loc_805639F;
    if ( !i )
      v6 = &loc_80563D7;
    dword_807222C = (int)v6;
    sub_806627B(v5, 4 * i);
    if ( !memcmp(s1, (const void *)(a2 + i * n), n) )
    {
      v8 = sub_8061809(*(_DWORD *)(4 * i + a1));
      fprintf(stderr, ", %s", v8);
    }
    else
    {
      v8 = sub_8061809(*(_DWORD *)(4 * i + a1));
      fprintf(stderr, "\n  - %s", v8);
      s1 = (void *)(i * n + a2);
    }
  }
  return putc_unlocked(10, stderr);
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 806627B: using guessed type int __fastcall sub_806627B(_DWORD, _DWORD);
// 807222C: using guessed type int dword_807222C;

//----- (08056488) --------------------------------------------------------
int __cdecl sub_8056488(int a1, char *s, int a3, int a4, size_t n, int a6)
{
  int v7; // [esp+8h] [ebp-20h]
  size_t v8; // [esp+Ch] [ebp-1Ch]
  int v9; // [esp+1Ch] [ebp-Ch]

  v8 = n;
  v7 = a4;
  v9 = sub_805615C(s, a3);
  if ( v9 >= 0 )
    return v9;
  sub_80562C5(a1, (int)s, v9);
  sub_8056348(a3, a4, n);
  ((void (*)(void))a6)();
  return -1;
}

//----- (08056594) --------------------------------------------------------
signed int __cdecl sub_8056594(signed int a1)
{
  if ( a1 > 90 )
  {
    if ( (unsigned int)(a1 - 97) <= 0x19 )
      return 1;
  }
  else if ( a1 >= 65 || (unsigned int)(a1 - 48) <= 9 )
  {
    return 1;
  }
  return 0;
}

//----- (080565C4) --------------------------------------------------------
_BOOL4 __cdecl sub_80565C4(signed int a1)
{
  return a1 >= 65 && (a1 <= 90 || (unsigned int)(a1 - 97) <= 0x19);
}

//----- (08056648) --------------------------------------------------------
_BOOL4 __cdecl sub_8056648(int a1)
{
  return (unsigned int)(a1 - 48) <= 9;
}

//----- (08056780) --------------------------------------------------------
int __cdecl sub_8056780(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 65) > 0x19 )
    result = a1;
  else
    result = a1 + 32;
  return result;
}

//----- (080567B6) --------------------------------------------------------
int __cdecl sub_80567B6(int a1, char *s, int a3)
{
  if ( !*(_DWORD *)a1 )
  {
    *(_DWORD *)a1 = sub_8058A7E(7, 0, sub_80599B1, sub_8059BBF, sub_8059C6F);
    if ( !*(_DWORD *)a1 )
      sub_80628F3();
  }
  if ( (unsigned __int8)sub_80575BB(*(_DWORD *)a1, s, a3) )
    return 1;
  sub_8057501(*(_DWORD *)a1, s, a3);
  return 0;
}
// 80575BB: using guessed type _DWORD __cdecl sub_80575BB(_DWORD, _DWORD, _DWORD);
// 8058A7E: using guessed type _DWORD __cdecl sub_8058A7E(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (08056852) --------------------------------------------------------
int __usercall sub_8056852@<eax>(int a1@<ebx>, int a2, int a3)
{
  int v4; // edx
  int v5; // ecx
  int v6; // ecx
  int v7; // edx
  char **v8; // ebp
  int v9; // ecx
  _BYTE *v10; // eax
  bool v11; // zf
  void *v12; // eax
  _BYTE *v13; // eax
  int v14; // edx
  char *v15; // eax
  void *v16; // eax
  int v17; // edx
  char *v18; // eax
  void *v19; // eax
  char *v20; // eax
  _BYTE *v21; // eax
  void *v22; // eax
  int v23; // [esp-8h] [ebp-D4h]
  char *v24; // [esp-4h] [ebp-D0h]
  char *s; // [esp+0h] [ebp-CCh]
  int c; // [esp+4h] [ebp-C8h]
  size_t n; // [esp+8h] [ebp-C4h]
  char v28; // [esp+Ch] [ebp-C0h]
  int v29; // [esp+10h] [ebp-BCh]
  int v30; // [esp+14h] [ebp-B8h]
  int v31; // [esp+18h] [ebp-B4h]
  int v32; // [esp+1Ch] [ebp-B0h]
  int v33; // [esp+20h] [ebp-ACh]
  int v34; // [esp+24h] [ebp-A8h]
  int v35; // [esp+28h] [ebp-A4h]
  int v36; // [esp+2Ch] [ebp-A0h]
  int v37; // [esp+30h] [ebp-9Ch]
  int v38; // [esp+34h] [ebp-98h]
  int v39; // [esp+38h] [ebp-94h]
  int v40; // [esp+3Ch] [ebp-90h]
  int v41; // [esp+40h] [ebp-8Ch]
  unsigned int v42; // [esp+44h] [ebp-88h]
  int v43; // [esp+48h] [ebp-84h]
  int v44; // [esp+4Ch] [ebp-80h]
  int v45; // [esp+50h] [ebp-7Ch]
  int v46; // [esp+54h] [ebp-78h]
  int v47; // [esp+58h] [ebp-74h]

  v34 = 0;
  v38 = 0;
  v31 = 0;
  v42 = a3 & 0xFFFFFFFC;
  *((_BYTE *)&s - 177) = (a3 & 4) != 0;
  *(_DWORD *)&v28 = v28 & 3;
  if ( *(_DWORD *)&v28 & (*(_DWORD *)&v28 - 1) )
  {
    *__errno_location() = 22;
    return 0;
  }
  if ( !n )
  {
    *__errno_location() = 22;
    return 0;
  }
  if ( !*(_BYTE *)n )
  {
    *__errno_location() = 2;
    dword_80721DC = (int)&locret_8057209;
    sub_8066431(v5, v4, s, c);
  }
  *(&s - 35) = 0;
  if ( *(_BYTE *)n == 47 )
  {
    *(&s - 43) = (char *)sub_806278A(0x1000u);
    *(&s - 38) = *(&s - 43) + 4096;
    *(&s - 42) = *(&s - 43);
    if ( *(&s - 35) )
    {
      memcpy(*(&s - 43), *(&s - 35), (size_t)*(&s - 35));
      *(&s - 42) = &(*(&s - 42))[(_DWORD)*(&s - 35)];
    }
    v10 = *(&s - 42);
    *(&s - 42) = v10 + 1;
    *v10 = 47;
    for ( *(&s - 40) = &(*(&s - 35))[n]; ; *(&s - 40) = *(&s - 39) )
    {
LABEL_84:
      if ( !**(&s - 40) )
        goto LABEL_98;
      while ( **(&s - 40) == 47 )
        ++*(&s - 40);
      for ( *(&s - 39) = *(&s - 40); **(&s - 39) && **(&s - 39) != 47; ++*(&s - 39) )
        ;
      if ( *(&s - 39) == *(&s - 40) )
      {
LABEL_98:
        if ( &(*(&s - 43))[(signed int)(*(&s - 35) + 1)] < *(&s - 42) && *(*(&s - 42) - 1) == 47 )
          --*(&s - 42);
        **(&s - 42) = 0;
        v11 = *(&s - 42) + 1 == *(&s - 38);
        v24 = *(&s - 42) + 1;
        v23 = a1;
        v22 = &loc_805716A;
        if ( v11 )
          v22 = &loc_8057195;
        dword_8072290 = (int)v22;
        sub_8066034(
          s,
          c,
          n,
          *(_DWORD *)&v28,
          v29,
          v30,
          v31,
          v32,
          v33,
          v34,
          v35,
          v36,
          v37,
          v38,
          v39,
          v40,
          v41,
          v42,
          v43,
          v44,
          v45,
          v46,
          v47);
        c = *(&s - 42) - *(&s - 43) + 1;
        *(&s - 43) = (char *)sub_80627B4(*(&s - 43), c);
        free(*(&s - 41));
        if ( *(&s - 44) )
          sub_8058CC5(*(&s - 44));
        return (int)*(&s - 43);
      }
      if ( *(&s - 39) - *(&s - 40) != 1 || **(&s - 40) != 46 )
      {
        if ( *(&s - 39) - *(&s - 40) == 2 )
        {
          v11 = **(&s - 40) == 46;
          v24 = (char *)(unsigned __int8)**(&s - 40);
          v23 = a1;
          v12 = &loc_8056B8E;
          if ( !v11 )
            v12 = &loc_8056BFF;
          dword_8072254 = (int)v12;
          a1 = v23;
          sub_806617E(v6, 2);
          if ( (*(&s - 40))[1] == 46 )
          {
            if ( &(*(&s - 43))[(signed int)(*(&s - 35) + 1)] < *(&s - 42) )
            {
              --*(&s - 42);
              dword_8072290 = (int)&loc_8056BDC;
              sub_8066034(
                s,
                c,
                n,
                *(_DWORD *)&v28,
                v29,
                v30,
                v31,
                v32,
                v33,
                v34,
                v35,
                v36,
                v37,
                v38,
                v39,
                v40,
                v41,
                v42,
                v43,
                v44,
                v45,
                v46,
                v47);
              do
                --*(&s - 42);
              while ( *(&s - 42) > *(&s - 43) && *(*(&s - 42) - 1) != 47 );
            }
            continue;
          }
        }
        if ( *(*(&s - 42) - 1) != 47 )
        {
          v13 = *(&s - 42);
          *(&s - 42) = v13 + 1;
          *v13 = 47;
        }
        if ( &(*(&s - 42))[*(&s - 39) - *(&s - 40)] >= *(&s - 38) )
        {
          *(&s - 31) = (char *)(*(&s - 42) - *(&s - 43));
          *(&s - 34) = (char *)(*(&s - 38) - *(&s - 43));
          if ( *(&s - 39) - *(&s - 40) + 1 <= 4096 )
            *(&s - 34) += 4096;
          else
            *(&s - 34) += *(&s - 39) - *(&s - 40) + 1;
          c = (int)*(&s - 34);
          s = *(&s - 43);
          *(&s - 43) = (char *)sub_80627B4(s, c);
          *(&s - 38) = &(*(&s - 34))[(_DWORD)*(&s - 43)];
          *(&s - 42) = &(*(&s - 43))[(_DWORD)*(&s - 31)];
        }
        n = *(&s - 39) - *(&s - 40);
        c = (int)*(&s - 40);
        s = *(&s - 42);
        *(&s - 42) = (char *)memcpy(s, (const void *)c, n);
        v14 = *(&s - 39) - *(&s - 40);
        *(&s - 42) += v14;
        v15 = *(&s - 42);
        *v15 = 0;
        if ( *((_BYTE *)&s - 177) && *(_DWORD *)&v28 == 2 )
        {
          *(&s - 22) = 0;
        }
        else
        {
          v11 = *((_BYTE *)&s - 177) == 0;
          v24 = v15;
          v23 = a1;
          v16 = &loc_8056DAA;
          if ( v11 )
            v16 = &loc_8056DC6;
          dword_8072240 = (int)v16;
          a1 = v23;
          sub_80661F2(v6, v14, s);
          c = (int)(&s - 26);
          s = *(&s - 43);
          if ( sub_8065DD8((int)s, (int)(&s - 26)) != 0 )
          {
            *(&s - 36) = (char *)*__errno_location();
            if ( !*(_DWORD *)&v28 )
              goto LABEL_93;
            if ( *(_DWORD *)&v28 == 1 )
            {
              c = (int)"/";
              s = *(&s - 39);
              if ( (*(&s - 39))[strspn(s, "/")] || *(&s - 36) != (char *)2 )
                goto LABEL_93;
              continue;
            }
            *(&s - 22) = 0;
          }
        }
        if ( ((unsigned int)*(&s - 22) & 0xF000) == 40960 )
        {
          if ( (unsigned __int8)sub_80567B6((int)(&s - 44), (char *)&s - 104, (int)(&s - 26)) )
          {
            if ( *(_DWORD *)&v28 != 2 )
            {
              *(&s - 36) = (char *)40;
LABEL_93:
              free(*(&s - 41));
              free(*(&s - 43));
              if ( *(&s - 44) )
                sub_8058CC5(*(&s - 44));
              *__errno_location() = (int)*(&s - 36);
              return 0;
            }
          }
          else
          {
            v17 = (int)*(&s - 14);
            c = (int)*(&s - 15);
            s = *(&s - 43);
            v18 = sub_805601F(v17, v6, s, c);
            *(&s - 30) = v18;
            if ( *(&s - 30) )
            {
              s = *(&s - 30);
              *(&s - 29) = (char *)strlen(s);
              s = *(&s - 39);
              *(&s - 28) = (char *)strlen(s);
              if ( *(&s - 37) )
              {
                if ( &(*(&s - 28))[(signed int)*(&s - 29) + 1] > *(&s - 37) )
                {
                  *(&s - 37) = &(*(&s - 28))[(_DWORD)*(&s - 29) + 1];
                  c = (int)*(&s - 37);
                  s = *(&s - 41);
                  *(&s - 41) = (char *)sub_80627B4(s, c);
                }
              }
              else
              {
                v20 = &(*(&s - 28))[(_DWORD)*(&s - 29) + 1];
                if ( (unsigned int)v20 < 0x1000 )
                  v20 = (char *)4096;
                *(&s - 37) = v20;
                s = *(&s - 37);
                *(&s - 41) = (char *)sub_806278A((size_t)s);
              }
              memmove(&(*(&s - 29))[(_DWORD)*(&s - 41)], *(&s - 39), (size_t)(*(&s - 28) + 1));
              n = (size_t)*(&s - 29);
              c = (int)*(&s - 30);
              s = *(&s - 41);
              *(&s - 39) = (char *)memcpy(s, (const void *)c, n);
              n = (size_t)*(&s - 39);
              if ( **(&s - 30) == 47 )
              {
                *(&s - 27) = 0;
                if ( *(&s - 27) )
                  memcpy(*(&s - 43), *(&s - 30), (size_t)*(&s - 27));
                *(&s - 42) = &(*(&s - 27))[(_DWORD)*(&s - 43)];
                v21 = *(&s - 42);
                *(&s - 42) = v21 + 1;
                *v21 = 47;
                *(&s - 35) = *(&s - 27);
              }
              else if ( &(*(&s - 43))[(signed int)(*(&s - 35) + 1)] < *(&s - 42) )
              {
                --*(&s - 42);
                while ( *(&s - 42) > *(&s - 43) && *(*(&s - 42) - 1) != 47 )
                  --*(&s - 42);
              }
              free(*(&s - 30));
            }
            else
            {
              v24 = v18;
              v23 = a1;
              v19 = &loc_8056ED1;
              if ( *(_DWORD *)&v28 != 2 )
                v19 = &loc_8056EE2;
              dword_8072268 = (int)v19;
              a1 = v23;
              sub_806610E(
                s,
                c,
                n,
                *(_DWORD *)&v28,
                v29,
                v30,
                v31,
                v32,
                v33,
                v34,
                v35,
                v36,
                v37,
                v38,
                v39,
                v40,
                v41,
                v42,
                v43);
              if ( *__errno_location() == 12 )
              {
                *(&s - 36) = (char *)*__errno_location();
                goto LABEL_93;
              }
            }
          }
        }
        else if ( ((unsigned int)*(&s - 22) & 0xF000) != 0x4000 && **(&s - 39) && *(_DWORD *)&v28 != 2 )
        {
          *(&s - 36) = (char *)20;
          goto LABEL_93;
        }
      }
    }
  }
  *(&s - 43) = sub_8062B65();
  if ( *(&s - 43) )
  {
    c = 0;
    s = *(&s - 43);
    *(&s - 42) = strchr(s, 0);
    if ( *(&s - 42) - *(&s - 43) <= 4095 )
    {
      c = 4096;
      s = *(&s - 43);
      *(&s - 32) = (char *)sub_80627B4(s, 0x1000u);
      v7 = *(&s - 42) - *(&s - 43);
      v8 = &s;
      *(v8 - 42) = &(*(v8 - 32))[v7];
      *(v8 - 43) = *(v8 - 32);
      *(&s - 38) = *(&s - 43) + 4096;
      dword_8072254 = (int)&loc_8056A2B;
      sub_806617E(v9, v7);
    }
    *(&s - 38) = *(&s - 42);
    *(&s - 40) = (char *)n;
    *(&s - 35) = 0;
    goto LABEL_84;
  }
  return 0;
}
// 8056852: could not find valid save-restore pair for ebx
// 8066034: using guessed type int __stdcall sub_8066034(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806610E: using guessed type int __stdcall sub_806610E(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806617E: using guessed type int __fastcall sub_806617E(_DWORD, _DWORD);
// 80721DC: using guessed type int dword_80721DC;
// 8072240: using guessed type int dword_8072240;
// 8072254: using guessed type int dword_8072254;
// 8072268: using guessed type int dword_8072268;
// 8072290: using guessed type int dword_8072290;

//----- (0805722F) --------------------------------------------------------
int sub_805722F()
{
  bool v0; // zf
  int v1; // edx
  int v2; // ecx
  void *v3; // eax
  int v4; // ebx
  int *v5; // eax
  int *v6; // eax
  int result; // eax
  char *v8; // [esp+2Ch] [ebp-Ch]

  if ( sub_8064B94(stdout) )
  {
    if ( byte_8073916 == 1 )
    {
      v0 = *__errno_location() == 32;
      v3 = &loc_805727E;
      if ( v0 )
        v3 = &loc_8057304;
      dword_807222C = (int)v3;
      sub_806627B(v2, v1);
    }
    v8 = gettext("write error");
    if ( dword_8073912 )
    {
      v4 = sub_8061485(dword_8073912);
      v5 = __errno_location();
      error(0, *v5, "%s: %s", v4, v8);
    }
    else
    {
      v6 = __errno_location();
      error(0, *v6, "%s", v8);
    }
    _exit(status);
  }
  result = sub_8064B94(stderr);
  if ( result )
    _exit(status);
  return result;
}
// 806627B: using guessed type int __fastcall sub_806627B(_DWORD, _DWORD);
// 807222C: using guessed type int dword_807222C;
// 8073912: using guessed type int dword_8073912;
// 8073916: using guessed type char byte_8073916;

//----- (08057328) --------------------------------------------------------
#error "8057359: call analysis failed (funcsize=46)"

//----- (080573C7) --------------------------------------------------------
void *__cdecl sub_80573C7(void *src)
{
  size_t v1; // eax
  int v3; // [esp+0h] [ebp-28h]
  int v4; // [esp+4h] [ebp-24h]
  int v5; // [esp+8h] [ebp-20h]
  int v6; // [esp+Ch] [ebp-1Ch]
  int v7; // [esp+10h] [ebp-18h]
  int v8; // [esp+14h] [ebp-14h]
  size_t n; // [esp+18h] [ebp-10h]
  void *dest; // [esp+1Ch] [ebp-Ch]

  n = sub_8057328(src);
  HIBYTE(v8) = n == 0;
  dest = malloc((n == 0) + n + 1);
  if ( !dest )
  {
    dword_80721F0 = (int)&locret_805745C;
    sub_80663C3(v3, v4, v5, v6, v7, v8, n, 0);
  }
  memcpy(dest, src, n);
  if ( HIBYTE(v8) )
  {
    v1 = n++;
    *((_BYTE *)dest + v1) = 46;
  }
  *((_BYTE *)dest + n) = 0;
  return dest;
}
// 8057328: using guessed type _DWORD __cdecl sub_8057328(_DWORD);
// 80663C3: using guessed type int __stdcall sub_80663C3(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80721F0: using guessed type int dword_80721F0;

//----- (0805745E) --------------------------------------------------------
_BYTE *__cdecl sub_805745E(_BYTE *a1)
{
  char v2; // [esp+7h] [ebp-9h]
  _BYTE *v3; // [esp+8h] [ebp-8h]
  _BYTE *i; // [esp+Ch] [ebp-4h]

  v3 = a1;
  v2 = 0;
  while ( *v3 == 47 )
    ++v3;
  for ( i = v3; *i; ++i )
  {
    if ( *i == 47 )
    {
      v2 = 1;
    }
    else if ( v2 )
    {
      v3 = i;
      v2 = 0;
    }
  }
  return v3;
}

//----- (080574B9) --------------------------------------------------------
size_t __cdecl sub_80574B9(char *s)
{
  size_t i; // [esp+18h] [ebp-10h]

  for ( i = strlen(s); i > 1 && s[i - 1] == 47; --i )
    ;
  return i;
}

//----- (080574F7) --------------------------------------------------------
int sub_80574F7()
{
  return 0;
}

//----- (08057501) --------------------------------------------------------
void __cdecl sub_8057501(int a1, char *s, int a3)
{
  void *v3; // edx
  void *v4; // edx
  void **v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]

  if ( a1 )
  {
    v5 = (void **)sub_806278A(0x14u);
    *v5 = sub_80628CE(s);
    v3 = *(void **)(a3 + 92);
    v5[1] = *(void **)(a3 + 88);
    v5[2] = v3;
    v4 = *(void **)(a3 + 4);
    v5[3] = *(void **)a3;
    v5[4] = v4;
    v6 = sub_80596EC(a1, (int)v5);
    if ( !v6 )
      sub_80628F3();
    if ( (void **)v6 != v5 )
      sub_8059C6F(v5);
  }
}

//----- (080575BB) --------------------------------------------------------
#error "805760D: call analysis failed (funcsize=30)"

//----- (08057657) --------------------------------------------------------
signed int __usercall sub_8057657@<eax>(int a1@<edx>, int a2@<ecx>, __int16 a3)
{
  switch ( a3 & 0xF000 )
  {
    case 32768:
      return 45;
    case 16384:
      return 100;
    case 24576:
      return 98;
    case 8192:
      return 99;
    case 40960:
      dword_807227C = (int)&loc_805772C;
      sub_80660A0(a2, a1);
      break;
  }
  if ( (a3 & 0xF000) == 4096 )
    return 112;
  if ( (a3 & 0xF000) == 49152 )
  {
    dword_807227C = (int)&loc_805772C;
    sub_80660A0(a2, a1);
  }
  return 63;
}
// 80660A0: using guessed type int __fastcall sub_80660A0(_DWORD, _DWORD);
// 807227C: using guessed type int dword_807227C;

//----- (0805772E) --------------------------------------------------------
int __usercall sub_805772E@<eax>(int a1@<edx>, int a2@<ecx>, __int16 a3, _BYTE *a4)
{
  int v4; // ecx
  char v5; // al
  char v6; // al
  char *v7; // edx
  char v8; // al
  char v9; // al
  char v10; // al
  char v11; // al
  char v12; // al
  _BYTE *v13; // edx
  char v14; // al
  int result; // eax
  int v16; // [esp+0h] [ebp-4h]

  *a4 = sub_8057657(a1, a2, a3);
  if ( a3 & 0x100 )
    v5 = 114;
  else
    v5 = 45;
  a4[1] = v5;
  if ( a3 & 0x80 )
    v6 = 119;
  else
    v6 = 45;
  a4[2] = v6;
  v7 = a4 + 3;
  if ( a3 & 0x800 )
  {
    if ( a3 & 0x40 )
    {
      dword_8072254 = (int)&loc_80577D9;
      sub_806617E(v4, v7);
    }
    v8 = 83;
  }
  else if ( a3 & 0x40 )
  {
    v8 = 120;
  }
  else
  {
    v8 = 45;
  }
  *v7 = v8;
  if ( a3 & 0x20 )
    v9 = 114;
  else
    v9 = 45;
  a4[4] = v9;
  if ( a3 & 0x10 )
    v10 = 119;
  else
    v10 = 45;
  a4[5] = v10;
  if ( a3 & 0x400 )
  {
    if ( a3 & 8 )
      v11 = 115;
    else
      v11 = 83;
  }
  else if ( a3 & 8 )
  {
    v11 = 120;
  }
  else
  {
    v11 = 45;
  }
  a4[6] = v11;
  if ( a3 & 4 )
    v12 = 114;
  else
    v12 = 45;
  a4[7] = v12;
  v13 = a4 + 8;
  if ( a3 & 2 )
  {
    dword_8072240 = (int)&loc_80578A8;
    sub_80661F2(v4, v13, v16);
  }
  *v13 = 45;
  if ( a3 & 0x200 )
  {
    if ( a3 & 1 )
      v14 = 116;
    else
      v14 = 84;
  }
  else if ( a3 & 1 )
  {
    v14 = 120;
  }
  else
  {
    v14 = 45;
  }
  a4[9] = v14;
  a4[10] = 32;
  result = (int)(a4 + 11);
  a4[11] = 0;
  return result;
}
// 806617E: using guessed type int __fastcall sub_806617E(_DWORD, _DWORD);
// 8072240: using guessed type int dword_8072240;
// 8072254: using guessed type int dword_8072254;

//----- (08057900) --------------------------------------------------------
int __cdecl sub_8057900(int a1, _BYTE *a2)
{
  int v2; // ecx

  return sub_805772E((int)a2, v2, *(_DWORD *)(a1 + 16), a2);
}

//----- (0805791D) --------------------------------------------------------
void *__cdecl sub_805791D(_BYTE *a1, _BYTE *a2, _DWORD *a3)
{
  void *v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_8057980(a1, a2, a3);
  if ( !v4 )
    sub_80628F3();
  return v4;
}

//----- (0805794F) --------------------------------------------------------
_BYTE *__usercall sub_805794F@<eax>(int a1@<edx>, int a2@<ecx>, _BYTE *a3)
{
  void *v3; // eax
  int savedregs; // [esp+0h] [ebp+0h]

  v3 = &loc_805797B;
  if ( *a3 == 47 )
    v3 = &loc_8057954;
  dword_8072240 = (int)v3;
  sub_80661F2(a2, a1, savedregs);
  return a3;
}
// 8072240: using guessed type int dword_8072240;

//----- (08057980) --------------------------------------------------------
void *__cdecl sub_8057980(_BYTE *a1, _BYTE *a2, _DWORD *a3)
{
  int v3; // ecx
  char *v4; // edx
  _BOOL4 v5; // eax
  signed int v7; // eax
  size_t v8; // [esp+0h] [ebp-38h]
  char *v9; // [esp+10h] [ebp-28h]
  size_t v10; // [esp+14h] [ebp-24h]
  char *v11; // [esp+18h] [ebp-20h]
  int v12; // [esp+1Ch] [ebp-1Ch]
  char *s; // [esp+20h] [ebp-18h]
  size_t v14; // [esp+24h] [ebp-14h]
  void *v15; // [esp+28h] [ebp-10h]
  _BYTE *v16; // [esp+2Ch] [ebp-Ch]

  v9 = sub_805745E(a1);
  v10 = sub_80574B9(v9);
  v4 = (char *)(v9 - a1);
  v11 = (char *)(v9 - a1 + v10);
  v5 = 0;
  if ( v10 )
  {
    v4 = (char *)(v10 - 1);
    if ( v9[v10 - 1] != 47 )
      v5 = 1;
  }
  v12 = v5;
  s = sub_805794F((int)v4, v3, a2);
  v14 = strlen(s);
  v8 = (size_t)&v11[v12 + 1 + v14];
  v15 = malloc(v8);
  if ( !v15 )
    return 0;
  v16 = (_BYTE *)mempcpy(v15, a1, v11);
  *v16 = 47;
  v16 += v12;
  if ( a3 )
  {
    if ( *a2 == 47 )
      v7 = -1;
    else
      v7 = 0;
    *a3 = &v16[v7];
  }
  *(_BYTE *)mempcpy(v16, s, v14) = 0;
  return v15;
}
// 80499B0: using guessed type int __cdecl mempcpy(_DWORD, _DWORD, _DWORD);

//----- (08057AA6) --------------------------------------------------------
#error "8057B00: call analysis failed (funcsize=73)"

//----- (08057B7D) --------------------------------------------------------
int __cdecl sub_8057B7D(unsigned __int8 a1)
{
  if ( (unsigned __int8)sub_8056648(a1) )
    return 0;
  if ( (unsigned __int8)sub_80565C4(a1) )
    return a1;
  if ( a1 == 126 )
    return -1;
  return a1 + 256;
}

//----- (08057BCE) --------------------------------------------------------
signed int __cdecl sub_8057BCE(int a1, unsigned int a2, int a3, unsigned int a4)
{
  int v4; // edx
  int v5; // ecx
  void *v6; // eax
  int v7; // edx
  int v8; // ecx
  int v9; // ST08_4
  int v10; // edx
  int v11; // ecx
  void *v12; // eax
  void *v13; // eax
  bool v14; // zf
  int v15; // edx
  int v16; // ecx
  void *v17; // eax
  int v19; // [esp+0h] [ebp-38h]
  int v20; // [esp+0h] [ebp-38h]
  int v21; // [esp+4h] [ebp-34h]
  int v22; // [esp+4h] [ebp-34h]
  int v23; // [esp+8h] [ebp-30h]
  int v24; // [esp+8h] [ebp-30h]
  int v25; // [esp+Ch] [ebp-2Ch]
  int v26; // [esp+Ch] [ebp-2Ch]
  int v27; // [esp+10h] [ebp-28h]
  int v28; // [esp+10h] [ebp-28h]
  int v29; // [esp+14h] [ebp-24h]
  int v30; // [esp+14h] [ebp-24h]
  int v31; // [esp+18h] [ebp-20h]
  int v32; // [esp+18h] [ebp-20h]
  unsigned int v33; // [esp+1Ch] [ebp-1Ch]
  int v34; // [esp+1Ch] [ebp-1Ch]
  unsigned int v35; // [esp+20h] [ebp-18h]
  int v36; // [esp+24h] [ebp-14h]
  int v37; // [esp+28h] [ebp-10h]
  int v38; // [esp+2Ch] [ebp-Ch]
  int v39; // [esp+30h] [ebp-8h]
  int v40; // [esp+34h] [ebp-4h]
  int savedregs; // [esp+38h] [ebp+0h]

  if ( a2 <= 0 && a4 <= 0 )
    return 0;
  dword_8072204 = (int)&loc_8057CCD;
  sub_8066357(v19, v21, v23, v25, v27, v29, v31, 0, 0, 0, v37, v38, v39, v40, savedregs);
  do
  {
    v6 = &loc_8057C26;
    if ( v33 == a2 )
      v6 = &loc_8057C53;
    dword_807222C = (int)v6;
    sub_806627B(v5, v4);
    sub_8057B7D(*(_BYTE *)(a1 + v33));
    dword_80721DC = (int)&loc_8057C58;
    sub_8066431(v8, v7, v9, v22);
    v12 = &loc_8057C7C;
    if ( v35 == a4 )
      v12 = &loc_8057C94;
    dword_807227C = (int)v12;
    sub_80660A0(v11, v10);
    if ( 0 != sub_8057B7D(*(_BYTE *)(a3 + v35)) )
    {
      dword_80721F0 = (int)&locret_8057E71;
      sub_80663C3(v20, v22, v24, v26, v28, v30, v32, v33);
    }
    ++v33;
    ++v35;
  }
  while ( v33 < a2 && (unsigned __int8)sub_8056648(*(char *)(a1 + v33)) ^ 1
       || v35 < a4 && (unsigned __int8)sub_8056648(*(char *)(a3 + v35)) ^ 1 );
  v13 = &loc_8057D4D;
  if ( *(_BYTE *)(a1 + v33) == 48 )
    v13 = &loc_8057D21;
  dword_80721F0 = (int)v13;
  sub_80663C3(v20, v22, v24, v26, v28, v30, v32, v33);
  while ( *(_BYTE *)(a3 + v35) == 48 )
    ++v35;
  while ( (unsigned __int8)sub_8056648(*(char *)(a1 + v34)) && (unsigned __int8)sub_8056648(*(char *)(a3 + v35)) )
  {
    if ( !v36 )
      v36 = *(char *)(a1 + v34) - *(char *)(a3 + v35);
    ++v34;
    ++v35;
  }
  v14 = (unsigned __int8)sub_8056648(*(char *)(a1 + v34)) == 0;
  v17 = &loc_8057E0C;
  if ( v14 )
    v17 = &loc_8057E13;
  dword_807222C = (int)v17;
  sub_806627B(v16, v15);
  return 1;
}
// 8057BCE: could not find valid save-restore pair for ebx
// 80660A0: using guessed type int __fastcall sub_80660A0(_DWORD, _DWORD);
// 806627B: using guessed type int __fastcall sub_806627B(_DWORD, _DWORD);
// 8066357: using guessed type int __stdcall sub_8066357(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80663C3: using guessed type int __stdcall sub_80663C3(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80721DC: using guessed type int dword_80721DC;
// 80721F0: using guessed type int dword_80721F0;
// 8072204: using guessed type int dword_8072204;
// 807222C: using guessed type int dword_807222C;
// 807227C: using guessed type int dword_807227C;

//----- (08057E73) --------------------------------------------------------
#error "8057EBB: call analysis failed (funcsize=48)"

//----- (0805812A) --------------------------------------------------------
struct timespec *__cdecl sub_805812A(struct timespec *tp)
{
  struct timespec *result; // eax
  struct timeval tv; // [esp+18h] [ebp-10h]

  result = (struct timespec *)clock_gettime(0, tp);
  if ( result )
  {
    gettimeofday(&tv, 0);
    tp->tv_sec = tv.tv_sec;
    result = tp;
    tp->tv_nsec = 1000 * tv.tv_usec;
  }
  return result;
}

//----- (08058175) --------------------------------------------------------
int __cdecl sub_8058175(int category)
{
  unsigned __int8 v2; // [esp+1Bh] [ebp-Dh]
  const char *s1; // [esp+1Ch] [ebp-Ch]

  v2 = 1;
  s1 = setlocale(category, 0);
  if ( s1 && (!strcmp(s1, "C") || !strcmp(s1, "POSIX")) )
    v2 = 0;
  return v2;
}

//----- (080581D3) --------------------------------------------------------
int __cdecl sub_80581D3(int a1)
{
  return *(_DWORD *)(a1 + 8);
}

//----- (080581DE) --------------------------------------------------------
int __cdecl sub_80581DE(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (080581E9) --------------------------------------------------------
int __cdecl sub_80581E9(int a1)
{
  return *(_DWORD *)(a1 + 16);
}

//----- (080581F4) --------------------------------------------------------
#error "8058228: call analysis failed (funcsize=50)"

//----- (0805843E) --------------------------------------------------------
int __cdecl sub_805843E(_DWORD *a1, int a2)
{
  int (__cdecl *v2)(int, int); // eax
  int v4; // [esp+4h] [ebp-24h]
  unsigned int v5; // [esp+1Ch] [ebp-Ch]

  v2 = (int (__cdecl *)(int, int))a1[6];
  v4 = a1[2];
  v5 = v2(a2, v4);
  if ( a1[2] <= v5 )
    abort();
  return 8 * v5 + *a1;
}

//----- (0805848E) --------------------------------------------------------
#error "80584C5: call analysis failed (funcsize=53)"

//----- (080587A6) --------------------------------------------------------
bool __usercall sub_80587A6@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3)
{
  int v3; // ST08_4
  unsigned int v5; // [esp+8h] [ebp-8h]
  unsigned int v6; // [esp+Ch] [ebp-4h]

  v5 = 3;
  v6 = 9;
  dword_807222C = (int)&loc_80587E5;
  sub_806627B(a2, a1);
  do
  {
    v3 = v5 + 1;
    v6 += 4 * v3;
    v5 = v3 + 1;
  }
  while ( v6 < a3 && a3 % v5 );
  return a3 % v5 != 0;
}
// 806627B: using guessed type int __fastcall sub_806627B(_DWORD, _DWORD);
// 807222C: using guessed type int dword_807222C;

//----- (08058812) --------------------------------------------------------
int __usercall sub_8058812@<eax>(int a1@<edx>, int a2@<ecx>, unsigned int a3)
{
  int i; // [esp+Ch] [ebp+8h]

  if ( a3 <= 9 )
    a3 = 10;
  for ( i = a3 | 1; i != -1 && !sub_80587A6(a1, a2, i); i += 2 )
    ;
  return i;
}

//----- (080588A3) --------------------------------------------------------
unsigned int __cdecl sub_80588A3(int a1, unsigned int a2)
{
  return sub_8064986(a1, 3) % a2;
}

//----- (080588CE) --------------------------------------------------------
bool __cdecl sub_80588CE(int a1, int a2)
{
  return a1 == a2;
}

//----- (080588DC) --------------------------------------------------------
signed int __cdecl sub_80588DC(int a1)
{
  int v2; // [esp+8h] [ebp-8h]

  v2 = *(_DWORD *)(a1 + 20);
  if ( (_UNKNOWN *)v2 == &unk_806ACE0 )
    return 1;
  if ( *(float *)(v2 + 8) > 0.1
    && 1.0 - 0.1 > *(float *)(v2 + 8)
    && *(float *)(v2 + 12) > 0.1 + 1.0
    && *(float *)v2 >= 0.0
    && *(float *)(v2 + 4) > *(float *)v2 + 0.1
    && *(float *)(v2 + 4) <= 1.0
    && *(float *)(v2 + 8) > *(float *)v2 + 0.1 )
  {
    return 1;
  }
  *(_DWORD *)(a1 + 20) = &unk_806ACE0;
  return 0;
}

//----- (08058998) --------------------------------------------------------
unsigned int __usercall sub_8058998@<eax>(signed __int64 a1@<edx:eax>, int a2@<ecx>, unsigned int a3, int a4)
{
  unsigned int result; // eax
  int v5; // [esp+0h] [ebp-24h]
  __int64 v6; // [esp+4h] [ebp-20h]
  int v7; // [esp+Ch] [ebp-18h]
  int v8; // [esp+10h] [ebp-14h]
  int v9; // [esp+14h] [ebp-10h]
  int v10; // [esp+18h] [ebp-Ch]
  int v11; // [esp+1Ch] [ebp-8h]
  float v12; // [esp+20h] [ebp-4h]
  unsigned int v13; // [esp+2Ch] [ebp+8h]

  if ( *(_BYTE *)(a4 + 16) != 1 )
  {
    v6 = a3;
    v12 = (long double)a3 / *(float *)(a4 + 8);
    if ( v12 >= 4294967300.0 )
    {
      dword_80721F0 = (int)&locret_8058A7C;
      sub_80663C3(v5, v6, HIDWORD(v6), v7, v8, v9, v10, v11);
    }
    a1 = (signed __int64)v12;
    a3 = a1;
  }
  v13 = sub_8058812(SHIDWORD(a1), a2, a3);
  if ( v13 <= 0x1FFFFFFF )
    result = v13;
  else
    result = 0;
  return result;
}
// 80663C3: using guessed type int __stdcall sub_80663C3(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80721F0: using guessed type int dword_80721F0;

//----- (08058A7E) --------------------------------------------------------
#error "8058B8E: call analysis failed (funcsize=86)"

//----- (08058CC5) --------------------------------------------------------
void __cdecl sub_8058CC5(void *a1)
{
  _DWORD *v1; // ST1C_4
  _DWORD *v2; // ST1C_4
  _DWORD *i; // [esp+14h] [ebp-14h]
  _DWORD *j; // [esp+14h] [ebp-14h]
  _DWORD *ptr; // [esp+18h] [ebp-10h]
  _DWORD *ptra; // [esp+18h] [ebp-10h]
  _DWORD *ptrb; // [esp+18h] [ebp-10h]

  if ( *((_DWORD *)a1 + 8) && *((_DWORD *)a1 + 4) )
  {
    for ( i = *(_DWORD **)a1; *((_DWORD *)a1 + 1) > (unsigned int)i; i += 2 )
    {
      if ( *i )
      {
        for ( ptr = i; ptr; ptr = (_DWORD *)ptr[1] )
          (*((void (__cdecl **)(_DWORD))a1 + 8))(*ptr);
      }
    }
  }
  for ( j = *(_DWORD **)a1; *((_DWORD *)a1 + 1) > (unsigned int)j; j += 2 )
  {
    for ( ptra = (_DWORD *)j[1]; ptra; ptra = v1 )
    {
      v1 = (_DWORD *)ptra[1];
      free(ptra);
    }
  }
  for ( ptrb = (_DWORD *)*((_DWORD *)a1 + 9); ptrb; ptrb = v2 )
  {
    v2 = (_DWORD *)ptrb[1];
    free(ptrb);
  }
  free(*(void **)a1);
  free(a1);
}

//----- (08058DB1) --------------------------------------------------------
void *__cdecl sub_8058DB1(int a1)
{
  int v2; // [esp+1Ch] [ebp-Ch]

  if ( !*(_DWORD *)(a1 + 36) )
    return malloc(8u);
  v2 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(v2 + 4);
  return (void *)v2;
}

//----- (08058DEC) --------------------------------------------------------
int __cdecl sub_8058DEC(int a1, _DWORD *a2)
{
  int result; // eax

  *a2 = 0;
  a2[1] = *(_DWORD *)(a1 + 36);
  result = a1;
  *(_DWORD *)(a1 + 36) = a2;
  return result;
}

//----- (08058E2F) --------------------------------------------------------
#error "8058F69: call analysis failed (funcsize=149)"

//----- (08059017) --------------------------------------------------------
signed int __cdecl sub_8059017(_DWORD *a1, int a2, char a3)
{
  int *i; // [esp+18h] [ebp-20h]
  int *j; // [esp+1Ch] [ebp-1Ch]
  int v6; // [esp+20h] [ebp-18h]
  int v7; // [esp+20h] [ebp-18h]
  int *v8; // [esp+24h] [ebp-14h]
  int *v9; // [esp+24h] [ebp-14h]
  int *v10; // [esp+28h] [ebp-10h]
  _DWORD *v11; // [esp+2Ch] [ebp-Ch]

  for ( i = *(int **)a2; *(_DWORD *)(a2 + 4) > (unsigned int)i; i += 2 )
  {
    if ( *i )
    {
      for ( j = (int *)i[1]; j; j = v10 )
      {
        v6 = *j;
        v8 = (int *)sub_805843E(a1, *j);
        v10 = (int *)j[1];
        if ( *v8 )
        {
          j[1] = v8[1];
          v8[1] = (int)j;
        }
        else
        {
          *v8 = v6;
          ++a1[3];
          sub_8058DEC((int)a1, j);
        }
      }
      v7 = *i;
      i[1] = 0;
      if ( !a3 )
      {
        v9 = (int *)sub_805843E(a1, v7);
        if ( *v9 )
        {
          v11 = sub_8058DB1((int)a1);
          if ( !v11 )
            return 0;
          *v11 = v7;
          v11[1] = v9[1];
          v9[1] = (int)v11;
        }
        else
        {
          *v9 = v7;
          ++a1[3];
        }
        *i = 0;
        --*(_DWORD *)(a2 + 12);
      }
    }
  }
  return 1;
}

//----- (080591B8) --------------------------------------------------------
signed int __usercall sub_80591B8@<eax>(signed __int64 a1@<edx:eax>, int a2@<ecx>, void **a3, unsigned int a4)
{
  unsigned int v4; // eax
  int v5; // edx
  int v6; // ecx
  bool v7; // zf
  void *v8; // eax
  int v9; // edx
  int v10; // ecx
  void *v12; // eax
  int v13; // [esp+0h] [ebp-48h]
  int v14; // [esp+0h] [ebp-48h]
  int v15; // [esp+4h] [ebp-44h]
  int v16; // [esp+4h] [ebp-44h]
  int v17; // [esp+8h] [ebp-40h]
  int v18; // [esp+Ch] [ebp-3Ch]
  int nmemb; // [esp+10h] [ebp-38h]
  char *v20; // [esp+18h] [ebp-30h]
  char *v21; // [esp+1Ch] [ebp-2Ch]
  void *v22; // [esp+20h] [ebp-28h]
  void *v23; // [esp+24h] [ebp-24h]
  int v24; // [esp+28h] [ebp-20h]
  void *v25; // [esp+2Ch] [ebp-1Ch]
  void *v26; // [esp+30h] [ebp-18h]
  void *v27; // [esp+34h] [ebp-14h]
  void *v28; // [esp+38h] [ebp-10h]
  void *v29; // [esp+3Ch] [ebp-Ch]

  LODWORD(a1) = a4;
  v4 = sub_8058998(a1, a2, a4, (int)a3[5]);
  nmemb = v4;
  v7 = v4 == 0;
  v8 = &loc_80591F5;
  if ( !v7 )
    v8 = &loc_8059211;
  dword_807222C = (int)v8;
  sub_806627B(v6, v5);
  dword_80721DC = (int)&locret_80593FF;
  sub_8066431(v10, v9, v13, v15);
  if ( a3[2] == (void *)nmemb )
    return 1;
  v20 = (char *)calloc(nmemb, 8u);
  if ( !v20 )
    return 0;
  v22 = (void *)nmemb;
  v21 = &v20[8 * nmemb];
  v23 = 0;
  v24 = 0;
  v25 = a3[5];
  v26 = a3[6];
  v27 = a3[7];
  v28 = a3[8];
  v29 = a3[9];
  if ( !(unsigned __int8)sub_8059017(&v20, (int)a3, 0) )
  {
    a3[9] = v29;
    if ( !((unsigned __int8)sub_8059017(a3, (int)&v20, 1) ^ 1) )
    {
      v7 = (unsigned __int8)sub_8059017(a3, (int)&v20, 0) == 1;
      v12 = &loc_80593E8;
      if ( v7 )
        v12 = &loc_80593ED;
      dword_8072218 = (int)v12;
      sub_80662EB(v14, v16, v17, v18, nmemb, &v20, v20, v21, v22, v23, v24, v25, v26, v27, v28);
    }
    abort();
  }
  free(*a3);
  *a3 = v20;
  a3[1] = v21;
  a3[2] = v22;
  a3[3] = v23;
  a3[9] = v29;
  return 1;
}
// 806627B: using guessed type int __fastcall sub_806627B(_DWORD, _DWORD);
// 80662EB: using guessed type int __stdcall sub_80662EB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80721DC: using guessed type int dword_80721DC;
// 8072218: using guessed type int dword_8072218;
// 807222C: using guessed type int dword_807222C;

//----- (08059401) --------------------------------------------------------
#error "80594DD: call analysis failed (funcsize=115)"

//----- (080596EC) --------------------------------------------------------
int __cdecl sub_80596EC(int a1, int a2)
{
  int v3; // [esp+18h] [ebp-10h]
  int v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_8059401(a1, a2, &v3);
  if ( v4 == -1 )
    return 0;
  if ( v4 )
    return a2;
  return v3;
}
// 8059401: using guessed type _DWORD __cdecl sub_8059401(_DWORD, _DWORD, _DWORD);

//----- (0805972B) --------------------------------------------------------
#error "80597ED: call analysis failed (funcsize=62)"

//----- (080599B1) --------------------------------------------------------
int __cdecl sub_80599B1(_DWORD *a1, unsigned int a2)
{
  unsigned int v2; // eax

  v2 = sub_8064C7D(*a1, a2);
  return sub_8065B58(__PAIR__(a1[2], a1[1] ^ v2), a2);
}
// 8064C7D: using guessed type _DWORD __cdecl sub_8064C7D(_DWORD, _DWORD);
// 8065B58: using guessed type _DWORD __cdecl sub_8065B58(__int64, __int64);

//----- (08059BBF) --------------------------------------------------------
int __cdecl sub_8059BBF(int a1, int a2)
{
  return __PAIR__(*(_DWORD *)(a1 + 4), *(_DWORD *)(a2 + 8)) == __PAIR__(*(_DWORD *)(a2 + 4), *(_DWORD *)(a1 + 8))
      && __PAIR__(*(_DWORD *)(a1 + 12), *(_DWORD *)(a2 + 16)) == __PAIR__(*(_DWORD *)(a2 + 12), *(_DWORD *)(a1 + 16))
      && !strcmp(*(const char **)a1, *(const char **)a2);
}

//----- (08059C6F) --------------------------------------------------------
void __cdecl sub_8059C6F(void **a1)
{
  free(*a1);
  free(a1);
}

//----- (08059C95) --------------------------------------------------------
int __usercall sub_8059C95@<eax>(int a1@<edx>, int a2@<ecx>, int a3, long double a4)
{
  void *v5; // eax
  int v6; // edx
  int v7; // ecx

  dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))&loc_8059EBD;
  v5 = &loc_8059CC9;
  if ( a3 == 1 )
    v5 = &loc_804E032;
  dword_807227C = (int)v5;
  sub_80660A0(a2, a1);
  dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))&loc_8059EBD;
  if ( a4 < 1.8446744073709551615e19 )
  {
    dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))sub_8059D5B;
    if ( a4 < 9.223372036854775808e18 )
      dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))&loc_8059DB5;
  }
  return dword_80722B8(v7, v6);
}
// 80660A0: using guessed type int __fastcall sub_80660A0(_DWORD, _DWORD);
// 807227C: using guessed type int dword_807227C;
// 80722B8: using guessed type int (__fastcall *dword_80722B8)(_DWORD, _DWORD);

//----- (08059D5B) --------------------------------------------------------
int __usercall sub_8059D5B@<eax>(int _EBP@<ebp>, int a2, int a3)
{
  __int16 v4; // cx
  unsigned int v6; // ecx
  unsigned int v7; // edx
  int v8; // edx
  unsigned __int8 v11; // pf
  int _0; // [esp+0h] [ebp+0h]

  __asm
  {
    fld     tbyte ptr [ebp+0Ch]
    fld     ds:tbyte_806AE18
    fsubp   st(1), st
    fnstcw  word ptr [ebp-22h]
  }
  v4 = *(_WORD *)(_EBP - 34);
  _EBP = &_0;
  HIBYTE(v4) = 12;
  *((_WORD *)&_0 - 18) = v4;
  __asm
  {
    fldcw   word ptr [ebp-24h]
    fistp   qword ptr [ebp-10h]
    fldcw   word ptr [ebp-22h]
  }
  v6 = *(&_0 - 3) ^ 0x80000000;
  v7 = *(&_0 - 3) ^ 0x80000000;
  *(&_0 - 4) = *(&_0 - 4);
  *(&_0 - 3) = v7;
  v8 = *(&_0 - 3);
  *(&_0 - 4) = *(&_0 - 4);
  *(&_0 - 3) = v8;
  dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))sub_8059E5D;
  _EBP = &_0;
  if ( !a3 )
  {
    __asm { fild    qword ptr [ebp-10h] }
    v11 = __SETP__(*(&_0 - 3), 0);
    _SF = *(&_0 - 3) < 0;
    dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))&loc_8059DFC;
    _EBP = &_0;
    if ( _SF )
    {
      __asm
      {
        fld     ds:tbyte_806AE28
        faddp   st(1), st
        fld     tbyte ptr [ebp+0Ch]
        fucomip st, st(1)
      }
      dword_80722B8 = sub_8059E43;
      _EBP = &_0;
      if ( !v11 )
      {
        __asm
        {
          fld     tbyte ptr [ebp+0Ch]
          fucomip st, st(1)
          fstp    st
        }
        dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))sub_8059E5D;
        if ( !_ZF )
          dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))&loc_8059E45;
      }
    }
  }
  return dword_80722B8(v6, v8);
}
// 8059D5B: inconsistent fpu stack
// 8059E5D: using guessed type double sub_8059E5D();
// 80722B8: using guessed type int (__fastcall *dword_80722B8)(_DWORD, _DWORD);

//----- (08059E43) --------------------------------------------------------
int __fastcall sub_8059E43(int a1, int a2)
{
  __asm { fstp    st }
  dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))&loc_8059E62;
  return ((int (__fastcall *)(int, int))loc_8059E62)(a1, a2);
}
// 8059E43: inconsistent fpu stack
// 80722B8: using guessed type int (__fastcall *dword_80722B8)(_DWORD, _DWORD);

//----- (08059E5D) --------------------------------------------------------
#error "8059ED5: positive sp value has been found (funcsize=33)"

//----- (08059EE8) --------------------------------------------------------
#error "8059FEA: call analysis failed (funcsize=76)"

//----- (08059FEF) --------------------------------------------------------
#error "805A04E: positive sp value has been found (funcsize=0)"

//----- (0805A051) --------------------------------------------------------
#error "805A651: call analysis failed (funcsize=672)"

//----- (0805AF3C) --------------------------------------------------------
__int64 sub_805AF3C()
{
  __int64 result; // rax

  if ( getenv("POSIXLY_CORRECT") )
    LODWORD(result) = 512;
  else
    LODWORD(result) = 1024;
  HIDWORD(result) = 0;
  return result;
}

//----- (0805AF6A) --------------------------------------------------------
#error "805AFBF: call analysis failed (funcsize=128)"

//----- (0805B12C) --------------------------------------------------------
int __cdecl sub_805B12C(char *s, int a2, int a3)
{
  int v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_805AF6A(s, a3, a2);
  if ( !*(_QWORD *)a3 )
  {
    *(_QWORD *)a3 = sub_805AF3C();
    v4 = 4;
  }
  return v4;
}

//----- (0805B175) --------------------------------------------------------
char *__cdecl sub_805B175(__uid_t uid)
{
  const char *v1; // eax
  char *s; // ST1C_4
  size_t v3; // eax
  char *result; // eax
  char *i; // [esp+10h] [ebp-18h]
  char *v6; // [esp+14h] [ebp-14h]
  struct passwd *v7; // [esp+18h] [ebp-10h]

  v6 = 0;
  for ( i = (char *)dword_807391A; i; i = (char *)*((_DWORD *)i + 1) )
  {
    if ( *(_DWORD *)i == uid )
    {
      v6 = i;
      break;
    }
  }
  if ( !v6 )
  {
    v7 = getpwuid(uid);
    if ( v7 )
      v1 = v7->pw_name;
    else
      v1 = (const char *)&unk_806AE44;
    s = (char *)v1;
    v3 = strlen(v1);
    v6 = (char *)sub_806278A((v3 + 16) & 0xFFFFFFF8);
    *(_DWORD *)v6 = uid;
    strcpy(v6 + 8, s);
    *((_DWORD *)v6 + 1) = dword_807391A;
    dword_807391A = (int)v6;
  }
  if ( v6[8] )
    result = v6 + 8;
  else
    result = 0;
  return result;
}
// 807391A: using guessed type int dword_807391A;

//----- (0805B39D) --------------------------------------------------------
#error "805B406: call analysis failed (funcsize=69)"

//----- (0805B600) --------------------------------------------------------
int __cdecl sub_805B600(__int64 a1, int a2)
{
  int v2; // edx
  bool v3; // zf
  int v4; // edx
  int v5; // ecx
  void *v6; // eax
  __int64 v7; // rax
  __int64 v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+2Ch] [ebp-Ch]

  v9 = a1;
  v10 = a2 + 20;
  *(_BYTE *)(a2 + 20) = 0;
  if ( a1 >= 0 )
  {
    do
    {
      *(_BYTE *)--v10 = sub_8065745(v9, HIDWORD(v9), 10, 0) + 48;
      LODWORD(v7) = sub_8065579(v9, HIDWORD(v9), 10, 0);
      v9 = v7;
    }
    while ( v7 );
  }
  else
  {
    *(_BYTE *)(a2 + 19) = 48 - sub_8065745(a1, HIDWORD(a1), 10, 0);
    v3 = (v2 | sub_8065579(a1, HIDWORD(a1), 10, 0)) == 0;
    v6 = &loc_805B6DE;
    if ( !v3 )
      v6 = &loc_805B63B;
    dword_8072254 = (int)v6;
    sub_806617E(v5, v4);
    v10 = a2 + 18;
    *(_BYTE *)(a2 + 18) = 45;
  }
  return v10;
}
// 8065579: using guessed type _DWORD __cdecl sub_8065579(_DWORD, _DWORD, _DWORD, _DWORD);
// 8065745: using guessed type _DWORD __cdecl sub_8065745(_DWORD, _DWORD, _DWORD, _DWORD);
// 806617E: using guessed type int __fastcall sub_806617E(_DWORD, _DWORD);
// 8072254: using guessed type int dword_8072254;

//----- (0805B77A) --------------------------------------------------------
int __cdecl sub_805B77A(__int64 a1, int a2)
{
  __int64 v2; // rax
  __int64 v4; // [esp+18h] [ebp-20h]
  int v5; // [esp+2Ch] [ebp-Ch]

  v4 = a1;
  v5 = a2 + 20;
  *(_BYTE *)(a2 + 20) = 0;
  do
  {
    *(_BYTE *)--v5 = sub_8065B58(v4, 10LL) + 48;
    LODWORD(v2) = sub_80659B1(v4, 10, 0);
    v4 = v2;
  }
  while ( v2 );
  return v5;
}
// 80659B1: using guessed type _DWORD __cdecl sub_80659B1(__int64, _DWORD, _DWORD);
// 8065B58: using guessed type _DWORD __cdecl sub_8065B58(__int64, __int64);

//----- (0805B834) --------------------------------------------------------
int __cdecl sub_805B834(wint_t *a1)
{
  unsigned __int8 v2; // [esp+1Bh] [ebp-Dh]
  wint_t *i; // [esp+1Ch] [ebp-Ch]

  v2 = 0;
  for ( i = a1; *i; ++i )
  {
    if ( !iswprint(*i) )
    {
      *i = 65533;
      v2 = 1;
    }
  }
  return v2;
}

//----- (0805B877) --------------------------------------------------------
int __cdecl sub_805B877(_DWORD *a1, unsigned int a2)
{
  int v3; // [esp+18h] [ebp-10h]
  int v4; // [esp+1Ch] [ebp-Ch]

  v3 = 0;
  while ( *a1 )
  {
    v4 = wcwidth(*a1);
    if ( v4 == -1 )
    {
      *a1 = 65533;
      v4 = 1;
    }
    if ( v4 + v3 > a2 )
      break;
    v3 += v4;
    ++a1;
  }
  *a1 = 0;
  return v3;
}
// 8049560: using guessed type int __cdecl wcwidth(_DWORD);

//----- (0805B8E3) --------------------------------------------------------
_BYTE *__cdecl sub_805B8E3(_BYTE *a1, unsigned int a2, int a3)
{
  _BYTE *v3; // eax
  int v4; // eax

  while ( 1 )
  {
    v4 = a3--;
    if ( !v4 || (unsigned int)a1 >= a2 )
      break;
    v3 = a1++;
    *v3 = 32;
  }
  *a1 = 0;
  return a1;
}

//----- (0805B914) --------------------------------------------------------
#error "805B988: call analysis failed (funcsize=32)"

//----- (0805B98D) --------------------------------------------------------
#error "805BD0A: positive sp value has been found (funcsize=229)"

//----- (0805BE22) --------------------------------------------------------
int __usercall sub_805BE22@<eax>(int a1@<ebx>, char *s, int a3)
{
  int v3; // eax

  v3 = strlen(s);
  return sub_805BE4B(a1, s, v3, a3);
}

//----- (0805BE4B) --------------------------------------------------------
int __usercall sub_805BE4B@<eax>(int a1@<ebx>, char *a2, int a3, char a4)
{
  signed int v4; // eax
  bool v5; // sf
  unsigned __int8 v6; // of
  void *v7; // eax
  size_t v8; // eax
  bool v9; // zf
  void *v10; // eax
  char *v12; // eax
  int v13; // [esp-8h] [ebp-60h]
  size_t v14; // [esp-4h] [ebp-5Ch]
  int v15; // [esp+0h] [ebp-58h]
  int v16; // [esp+4h] [ebp-54h]
  int v17; // [esp+8h] [ebp-50h]
  int v18; // [esp+Ch] [ebp-4Ch]
  int v19; // [esp+10h] [ebp-48h]
  int v20; // [esp+14h] [ebp-44h]
  int v21; // [esp+18h] [ebp-40h]
  char *v22; // [esp+1Ch] [ebp-3Ch]
  int v23; // [esp+20h] [ebp-38h]
  int v24; // [esp+24h] [ebp-34h]
  int v25; // [esp+28h] [ebp-30h]
  wint_t wc; // [esp+2Ch] [ebp-2Ch]
  char *v27; // [esp+30h] [ebp-28h]
  int v28; // [esp+34h] [ebp-24h]
  size_t v29; // [esp+38h] [ebp-20h]
  unsigned int v30; // [esp+3Ch] [ebp-1Ch]
  char s; // [esp+44h] [ebp-14h]
  unsigned int v32; // [esp+4Ch] [ebp-Ch]

  v22 = a2;
  v32 = __readgsdword(0x14u);
  v27 = a2;
  v30 = (unsigned int)&a2[a3];
  v28 = 0;
  if ( __ctype_get_mb_cur_max() > 1 )
  {
    while ( 1 )
    {
      if ( (unsigned int)v27 >= v30 )
        return v28;
      v4 = *v27;
      if ( v4 > 63 )
        break;
      v6 = __OFSUB__(v4, 37);
      v5 = v4 - 37 < 0;
      v14 = *v27;
      v13 = a1;
      v7 = &loc_805BED9;
      if ( !(v5 ^ v6) )
        v7 = &loc_805BEF5;
      dword_8072218 = (int)v7;
      a1 = v13;
      if ( (unsigned int)(sub_80662EB(v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, wc, v27, v28, v29) - 32) <= 3 )
        goto LABEL_11;
LABEL_12:
      memset(&s, 0, 8u);
      v8 = sub_80639A8(&v15 - 11, v27, v30 - (_DWORD)v27, (mbstate_t *)(&v15 - 5));
      v29 = v8;
      v9 = v8 == -1;
      v14 = v8;
      v13 = a1;
      v10 = &loc_805BF98;
      if ( !v9 )
        v10 = &loc_805BFB9;
      dword_80721F0 = (int)v10;
      a1 = v13;
      sub_80663C3(v15, v16, v17, v18, v19, v20, v21, v22);
      if ( a4 & 1 )
        return -1;
      ++v27;
      ++v28;
    }
    if ( v4 < 65 || v4 > 95 && (unsigned int)(v4 - 97) > 0x1D )
      goto LABEL_12;
LABEL_11:
    dword_8072204 = (int)&loc_805C0A6;
    sub_8066357(v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, wc, v27 + 1, v28 + 1, v29);
    goto LABEL_12;
  }
  dword_8072204 = (int)&loc_805C14D;
  sub_8066357(v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, wc, v27, v28, v29);
  while ( 1 )
  {
    v12 = v27++;
    HIBYTE(v25) = *v12;
    if ( !((*__ctype_b_loc())[HIBYTE(v25)] & 0x4000) )
      break;
    if ( v28 == 0x7FFFFFFF )
      return 0x7FFFFFFF;
    ++v28;
LABEL_28:
    if ( (unsigned int)v27 >= v30 )
      return v28;
  }
  if ( a4 & 2 )
    return -1;
  if ( (*__ctype_b_loc())[HIBYTE(v25)] & 2 )
    goto LABEL_28;
  if ( v28 != 0x7FFFFFFF )
  {
    ++v28;
    goto LABEL_28;
  }
  return 0x7FFFFFFF;
}
// 805BE4B: could not find valid save-restore pair for ebx
// 80662EB: using guessed type int __stdcall sub_80662EB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8066357: using guessed type int __stdcall sub_8066357(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80663C3: using guessed type int __stdcall sub_80663C3(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80721F0: using guessed type int dword_80721F0;
// 8072204: using guessed type int dword_8072204;
// 8072218: using guessed type int dword_8072218;

//----- (0805C176) --------------------------------------------------------
#error "805C32E: call analysis failed (funcsize=129)"

//----- (0805C333) --------------------------------------------------------
#error "805C350: positive sp value has been found (funcsize=0)"

//----- (0805C351) --------------------------------------------------------
#error "805C461: call analysis failed (funcsize=85)"

//----- (0805C655) --------------------------------------------------------
#error "805C684: call analysis failed (funcsize=15)"

//----- (0805C689) --------------------------------------------------------
int __cdecl sub_805C689(int a1, int a2, int a3, int a4)
{
  return sub_805C351(a2, a3, a2 + 4 * a3, a4);
}
// 805C351: using guessed type _DWORD __cdecl sub_805C351(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0805C6BE) --------------------------------------------------------
int __cdecl sub_805C6BE(int a1, int a2, int a3)
{
  int v3; // eax

  while ( 1 )
  {
    v3 = a3--;
    if ( !v3 )
      break;
    *(_BYTE *)(a1 + a3) = tolower(*(unsigned __int8 *)(a2 + a3));
  }
  return a1;
}

//----- (0805C6FE) --------------------------------------------------------
int __cdecl sub_805C6FE(int a1, int a2, int a3)
{
  int v3; // eax

  while ( 1 )
  {
    v3 = a3--;
    if ( !v3 )
      break;
    *(_BYTE *)(a1 + a3) = toupper(*(unsigned __int8 *)(a2 + a3));
  }
  return a1;
}

//----- (0805C73E) --------------------------------------------------------
int __cdecl sub_805C73E(int a1, int a2)
{
  return a1 - (a1 - a2 + 382) % 7 + 3;
}

//----- (0805C7AB) --------------------------------------------------------
int __cdecl sub_805C7AB(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // [esp+0h] [ebp-38h]
  char v8; // [esp+2Fh] [ebp-9h]

  v8 = 0;
  return sub_805C814(a1, a2, a3, a4, 0, (char *)&v7 - 9, a5, a6);
}
// 805C814: using guessed type _DWORD __cdecl sub_805C814(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0805C814) --------------------------------------------------------
#error "805F034: call analysis failed (funcsize=2035)"

//----- (0805F82E) --------------------------------------------------------
char *__cdecl sub_805F82E(char *s)
{
  char *v1; // eax
  char *result; // eax
  char *v3; // [esp+18h] [ebp-10h]
  char *s1; // [esp+1Ch] [ebp-Ch]

  if ( !s )
  {
    fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
    abort();
  }
  v3 = strrchr(s, 47);
  if ( v3 )
    v1 = v3 + 1;
  else
    v1 = s;
  s1 = v1;
  if ( v1 - s > 6 && !strncmp(v1 - 7, "/.libs/", 7u) )
  {
    s = s1;
    if ( !strncmp(s1, "lt-", 3u) )
    {
      s = s1 + 3;
      program_invocation_short_name = (int)(s1 + 3);
    }
  }
  dword_807392A = (int)s;
  result = s;
  program_invocation_name = (int)s;
  return result;
}
// 8072480: using guessed type int program_invocation_short_name;
// 8072490: using guessed type int program_invocation_name;
// 807392A: using guessed type int dword_807392A;

//----- (0805F907) --------------------------------------------------------
void *__cdecl sub_805F907(void *src)
{
  int *v1; // eax
  void *v2; // ST1C_4
  int v4; // [esp+18h] [ebp-10h]

  v4 = *__errno_location();
  if ( src )
    v1 = (int *)src;
  else
    v1 = &dword_8073936;
  v2 = sub_80628A5(v1, 0x30u);
  *__errno_location() = v4;
  return v2;
}
// 8073936: using guessed type int dword_8073936;

//----- (0805F949) --------------------------------------------------------
#error "805F963: call analysis failed (funcsize=15)"

//----- (0805F975) --------------------------------------------------------
int *__cdecl sub_805F975(int *a1, int a2)
{
  int *result; // eax

  if ( a1 )
    result = a1;
  else
    result = &dword_8073936;
  *result = a2;
  return result;
}
// 8073936: using guessed type int dword_8073936;

//----- (0805F98F) --------------------------------------------------------
#error "805F9BA: call analysis failed (funcsize=41)"

//----- (0805FA10) --------------------------------------------------------
#error "805FA66: positive sp value has been found (funcsize=28)"

//----- (0805FA93) --------------------------------------------------------
#error "805FAB3: call analysis failed (funcsize=29)"

//----- (0805FAED) --------------------------------------------------------
_DWORD *__userpurge sub_805FAED@<eax>(_DWORD *a1, int a2)
{
  int v3; // [esp+0h] [ebp-38h]
  int v4; // [esp+4h] [ebp-34h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]

  memset(&v3, 0, 0x30u);
  if ( a2 == 10 )
    abort();
  *a1 = a2;
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = v6;
  a1[4] = v7;
  a1[5] = v8;
  a1[6] = v9;
  a1[7] = v10;
  a1[8] = v11;
  a1[9] = v12;
  a1[10] = v13;
  a1[11] = v14;
  return a1;
}

//----- (0805FBAF) --------------------------------------------------------
#error "805FBDC: call analysis failed (funcsize=64)"

//----- (0805FC89) --------------------------------------------------------
unsigned int __usercall sub_805FC89@<eax>(size_t a1@<ebx>, int a2, unsigned int a3, char *a4, size_t a5, signed int a6, int a7, int a8, char *a9, char *a10)
{
  char *v10; // edx
  int v11; // ecx
  void *v12; // eax
  size_t v13; // eax
  int v14; // edx
  void *v15; // eax
  void *v16; // eax
  void *v17; // eax
  void *v18; // eax
  int v19; // eax
  bool v20; // al
  void *v21; // eax
  const unsigned __int16 *v22; // eax
  size_t v23; // eax
  void *v24; // eax
  size_t v25; // ebx
  void *v26; // eax
  void *v27; // eax
  void *v28; // eax
  void *v29; // eax
  size_t v30; // ebx
  void *v31; // eax
  size_t v32; // ebx
  void *v33; // eax
  void *v34; // eax
  int v35; // eax
  void *v36; // eax
  int v37; // edx
  int v38; // ecx
  unsigned int result; // eax
  size_t v40; // [esp-34h] [ebp-90h]
  int v41; // [esp-30h] [ebp-8Ch]
  int v42; // [esp-2Ch] [ebp-88h]
  int v43; // [esp-28h] [ebp-84h]
  size_t v44; // [esp-24h] [ebp-80h]
  int v45; // [esp-20h] [ebp-7Ch]
  int v46; // [esp-1Ch] [ebp-78h]
  int v47; // [esp-18h] [ebp-74h]
  int v48; // [esp-14h] [ebp-70h]
  int v49; // [esp-10h] [ebp-6Ch]
  int v50; // [esp-Ch] [ebp-68h]
  int v51; // [esp-8h] [ebp-64h]
  int v52; // [esp-4h] [ebp-60h]
  char *v53; // [esp+0h] [ebp-5Ch]
  char *v54; // [esp+4h] [ebp-58h]
  int v55; // [esp+8h] [ebp-54h]
  char *v56; // [esp+Ch] [ebp-50h]
  char *v57; // [esp+10h] [ebp-4Ch]
  unsigned __int8 v58; // [esp+14h] [ebp-48h]
  bool v59; // [esp+15h] [ebp-47h]
  unsigned __int8 v60; // [esp+16h] [ebp-46h]
  char v61; // [esp+17h] [ebp-45h]
  char v62; // [esp+18h] [ebp-44h]
  unsigned __int8 v63; // [esp+19h] [ebp-43h]
  char v64; // [esp+1Ah] [ebp-42h]
  unsigned __int8 v65; // [esp+1Bh] [ebp-41h]
  char v66; // [esp+1Ch] [ebp-40h]
  bool v67; // [esp+1Dh] [ebp-3Fh]
  bool v68; // [esp+1Eh] [ebp-3Eh]
  bool v69; // [esp+1Fh] [ebp-3Dh]
  wint_t wc; // [esp+20h] [ebp-3Ch]
  int v71; // [esp+24h] [ebp-38h]
  unsigned int v72; // [esp+28h] [ebp-34h]
  unsigned int v73; // [esp+2Ch] [ebp-30h]
  char *s; // [esp+30h] [ebp-2Ch]
  size_t n; // [esp+34h] [ebp-28h]
  unsigned int v76; // [esp+38h] [ebp-24h]
  size_t v77; // [esp+40h] [ebp-1Ch]
  unsigned int v78; // [esp+44h] [ebp-18h]
  mbstate_t ps; // [esp+48h] [ebp-14h]
  unsigned int v80; // [esp+50h] [ebp-Ch]
  size_t v81; // [esp+54h] [ebp-8h]

  v81 = a1;
  v57 = (char *)a2;
  v56 = a4;
  v55 = a8;
  v54 = a9;
  v53 = a10;
  v80 = __readgsdword(0x14u);
  v72 = 0;
  v73 = 0;
  s = 0;
  n = 0;
  v58 = 0;
  v69 = __ctype_get_mb_cur_max() == 1;
  v59 = (a7 & 2) != 0;
  v60 = 0;
  v61 = 0;
  v62 = 1;
  switch ( a6 )
  {
    case 0:
      v59 = 0;
      break;
    case 1:
      goto LABEL_19;
    case 2:
      goto LABEL_22;
    case 3:
      v58 = 1;
LABEL_19:
      v59 = 1;
      goto LABEL_20;
    case 4:
LABEL_20:
      if ( v59 != 1 )
        v58 = 1;
LABEL_22:
      a6 = 2;
      if ( v59 != 1 )
      {
        if ( v72 < a3 )
        {
          v10 = v57;
          v57[v72] = 39;
        }
        ++v72;
      }
      s = "'";
      n = 1;
      break;
    case 5:
      goto LABEL_3;
    case 6:
      a6 = 5;
      v59 = 1;
LABEL_3:
      v41 = !v59;
      v40 = a1;
      v12 = &loc_805FD8A;
      if ( v59 == 1 )
        v12 = &loc_805FDA1;
      dword_8072254 = (int)v12;
      a1 = v40;
      sub_806617E(v11, v10);
      if ( v72 < a3 )
      {
        v10 = v57;
        v57[v72] = 34;
      }
      ++v72;
      v58 = 1;
      s = (char *)&unk_806B19D;
      n = 1;
      break;
    case 7:
      v58 = 1;
      v59 = 0;
      break;
    case 8:
    case 9:
    case 10:
      if ( a6 != 10 )
      {
        v54 = (char *)sub_805FBAF("`", a6);
        v53 = (char *)sub_805FBAF("'", a6);
      }
      if ( v59 != 1 )
      {
        for ( s = v54; *s; ++s )
        {
          if ( v72 < a3 )
            v57[v72] = *s;
          ++v72;
        }
      }
      v58 = 1;
      s = v53;
      n = strlen(v53);
      break;
    default:
      abort();
      return result;
  }
  v71 = 0;
  while ( 1 )
  {
    if ( a5 == -1 )
    {
      v10 = v56;
      v35 = (unsigned __int8)v56[v71];
      LOBYTE(v35) = (_BYTE)v35 != 0;
    }
    else
    {
      v35 = v71;
      LOBYTE(v35) = v71 != a5;
    }
    if ( !(_BYTE)v35 )
      break;
    v65 = 0;
    v66 = 0;
    v67 = 0;
    if ( v58 && a6 != 2 && n )
    {
      a1 = v71 + n;
      if ( a5 != -1 || n <= 1 )
      {
        v13 = a5;
      }
      else
      {
        v13 = strlen(v56);
        a5 = v13;
      }
      if ( a1 <= v13 && !memcmp(&v56[v71], s, n) )
      {
        if ( v59 )
          goto LABEL_245;
        v65 = 1;
      }
    }
    v14 = (int)v56;
    v63 = v56[v71];
    switch ( v63 )
    {
      case 0u:
        v41 = v63;
        v40 = a1;
        v15 = &loc_805FF76;
        if ( !v58 )
          v15 = &loc_8060078;
        dword_807227C = (int)v15;
        a1 = v40;
        sub_80660A0(v11, v56);
        if ( v59 )
          goto LABEL_245;
        v66 = 1;
        if ( a6 == 2 )
        {
          v41 = v60 ^ 1;
          v40 = a1;
          v16 = &loc_805FFAF;
          if ( v60 == 1 )
            v16 = &loc_805FFF8;
          dword_8072254 = (int)v16;
          a1 = v40;
          sub_806617E(v11, v14);
          if ( v72 < a3 )
          {
            v14 = (int)v57;
            v57[v72] = 39;
          }
          if ( ++v72 < a3 )
          {
            v14 = (int)v57;
            v57[v72] = 36;
          }
          if ( ++v72 < a3 )
          {
            v14 = (int)v57;
            v57[v72] = 39;
          }
          ++v72;
          v60 = 1;
        }
        if ( v72 < a3 )
        {
          v14 = (int)v57;
          v57[v72] = 92;
        }
        ++v72;
        if ( a6 != 2 && v71 + 1 < a5 )
        {
          v14 = v71 + 1;
          if ( v56[v71 + 1] > 47 )
          {
            v14 = v71 + 1;
            if ( v56[v71 + 1] <= 57 )
            {
              if ( v72 < a3 )
              {
                v14 = (int)v57;
                v57[v72] = 48;
              }
              if ( ++v72 < a3 )
              {
                v14 = (int)v57;
                v57[v72] = 48;
              }
              ++v72;
            }
          }
        }
        v63 = 48;
        goto LABEL_183;
      case 7u:
        v64 = 97;
        goto LABEL_102;
      case 8u:
        v64 = 98;
        goto LABEL_102;
      case 9u:
        v64 = 116;
        goto LABEL_99;
      case 0xAu:
        v64 = 110;
        dword_8072254 = (int)&loc_806027A;
        sub_806617E(v11, v56);
        goto LABEL_92;
      case 0xBu:
        v64 = 118;
        dword_8072254 = (int)&loc_806029D;
        sub_806617E(v11, v56);
        goto LABEL_95;
      case 0xCu:
        v64 = 102;
        goto LABEL_102;
      case 0xDu:
LABEL_92:
        v64 = 114;
LABEL_99:
        if ( a6 == 2 && v59 )
        {
          dword_8072268 = (int)&loc_8060B71;
          sub_806610E(
            v42,
            v43,
            v44,
            v45,
            v46,
            v47,
            v48,
            v49,
            v50,
            v51,
            v52,
            v53,
            v54,
            v55,
            v56,
            v57,
            *(_DWORD *)&v58,
            *(_DWORD *)&v62,
            *(_DWORD *)&v66);
        }
LABEL_102:
        if ( !v58 )
          goto LABEL_183;
        v63 = v64;
        goto LABEL_192;
      case 0x20u:
        goto LABEL_110;
      case 0x21u:
      case 0x22u:
      case 0x24u:
      case 0x26u:
      case 0x28u:
      case 0x29u:
      case 0x2Au:
      case 0x3Bu:
      case 0x3Cu:
      case 0x3Du:
      case 0x3Eu:
      case 0x5Bu:
      case 0x5Eu:
      case 0x60u:
      case 0x7Cu:
        goto LABEL_111;
      case 0x23u:
      case 0x7Eu:
        goto LABEL_109;
      case 0x25u:
      case 0x2Bu:
      case 0x2Cu:
      case 0x2Du:
      case 0x2Eu:
      case 0x2Fu:
      case 0x30u:
      case 0x31u:
      case 0x32u:
      case 0x33u:
      case 0x34u:
      case 0x35u:
      case 0x36u:
      case 0x37u:
      case 0x38u:
      case 0x39u:
      case 0x3Au:
      case 0x41u:
      case 0x42u:
      case 0x43u:
      case 0x44u:
      case 0x45u:
      case 0x46u:
      case 0x47u:
      case 0x48u:
      case 0x49u:
      case 0x4Au:
      case 0x4Bu:
      case 0x4Cu:
      case 0x4Du:
      case 0x4Eu:
      case 0x4Fu:
      case 0x50u:
      case 0x51u:
      case 0x52u:
      case 0x53u:
      case 0x54u:
      case 0x55u:
      case 0x56u:
      case 0x57u:
      case 0x58u:
      case 0x59u:
      case 0x5Au:
      case 0x5Du:
      case 0x5Fu:
      case 0x61u:
      case 0x62u:
      case 0x63u:
      case 0x64u:
      case 0x65u:
      case 0x66u:
      case 0x67u:
      case 0x68u:
      case 0x69u:
      case 0x6Au:
      case 0x6Bu:
      case 0x6Cu:
      case 0x6Du:
      case 0x6Eu:
      case 0x6Fu:
      case 0x70u:
      case 0x71u:
      case 0x72u:
      case 0x73u:
      case 0x74u:
      case 0x75u:
      case 0x76u:
      case 0x77u:
      case 0x78u:
      case 0x79u:
      case 0x7Au:
        v67 = 1;
        goto LABEL_183;
      case 0x27u:
        v61 = 1;
        v67 = 1;
        if ( a6 != 2 )
          goto LABEL_183;
        if ( v59 )
          goto LABEL_245;
        if ( a3 )
        {
          v41 = v63;
          v40 = a1;
          v21 = &loc_8060341;
          if ( v73 )
            v21 = &loc_806034E;
          dword_8072240 = (int)v21;
          a1 = v40;
          sub_80661F2(v11, v56, v42);
          v73 = a3;
          a3 = 0;
        }
        if ( v72 < a3 )
        {
          v14 = (int)v57;
          v57[v72] = 39;
        }
        if ( ++v72 < a3 )
        {
          v14 = (int)v57;
          v57[v72] = 92;
        }
        if ( ++v72 < a3 )
        {
          v14 = (int)v57;
          v57[v72] = 39;
        }
        ++v72;
        v60 = 0;
        goto LABEL_183;
      case 0x3Fu:
        if ( a6 == 2 )
        {
          if ( v59 )
            goto LABEL_245;
        }
        else if ( a6 == 5 )
        {
          v41 = a7 & 4;
          v40 = a1;
          v17 = &loc_80600D1;
          if ( !(a7 & 4) )
            v17 = &loc_806019A;
          dword_8072240 = (int)v17;
          a1 = v40;
          sub_80661F2(v11, v56, v42);
          if ( v71 + 2 < a5 )
          {
            v14 = v71 + 1;
            if ( v56[v71 + 1] == 63 )
            {
              v14 = v71 + 2;
              switch ( v56[v71 + 2] )
              {
                case 33:
                case 39:
                case 40:
                case 41:
                case 45:
                case 47:
                case 60:
                case 61:
                case 62:
                  if ( v59 )
                    goto LABEL_245;
                  v14 = v71 + 2;
                  v63 = v56[v71 + 2];
                  v71 += 2;
                  if ( v72 < a3 )
                  {
                    v14 = (int)v57;
                    v57[v72] = 63;
                  }
                  if ( ++v72 < a3 )
                  {
                    v14 = (int)v57;
                    v57[v72] = 34;
                  }
                  if ( ++v72 < a3 )
                  {
                    v14 = (int)v57;
                    v57[v72] = 34;
                  }
                  if ( ++v72 < a3 )
                  {
                    v14 = (int)v57;
                    v57[v72] = 63;
                  }
                  ++v72;
                  break;
                default:
                  break;
              }
            }
          }
        }
LABEL_183:
        v41 = v58 ^ 1;
        v40 = a1;
        v29 = &loc_8060841;
        if ( v58 != 1 )
          v29 = &loc_8060860;
        dword_8072240 = (int)v29;
        v30 = v40;
        v41 = sub_80661F2(v11, v14, v42);
        v40 = v30;
        v31 = &loc_8060860;
        if ( a6 != 2 )
          v31 = &loc_8060884;
        dword_8072268 = (int)v31;
        v32 = v40;
        sub_806610E(
          v42,
          v43,
          v44,
          v45,
          v46,
          v47,
          v48,
          v49,
          v50,
          v51,
          v52,
          v53,
          v54,
          v55,
          v56,
          v57,
          *(_DWORD *)&v58,
          *(_DWORD *)&v62,
          *(_DWORD *)&v66);
        v41 = !v59;
        v40 = v32;
        v33 = &loc_8060884;
        if ( v59 != 1 )
          v33 = &loc_80608D6;
        dword_8072204 = (int)v33;
        a1 = v40;
        sub_8066357(v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56);
        if ( !v55 || (v11 = v63 & 0x1F, v14 = *(_DWORD *)(4 * (v63 >> 5) + v55) >> v11, !(v14 & 1)) )
        {
          v19 = v65 ^ 1;
          if ( v65 != 1 )
            goto LABEL_205;
        }
LABEL_192:
        if ( v59 )
          goto LABEL_245;
        v66 = 1;
        if ( a6 == 2 && v60 != 1 )
        {
          if ( v72 < a3 )
          {
            v14 = (int)v57;
            v57[v72] = 39;
          }
          if ( ++v72 < a3 )
          {
            v14 = (int)v57;
            v57[v72] = 36;
          }
          if ( ++v72 < a3 )
          {
            v14 = (int)v57;
            v57[v72] = 39;
          }
          ++v72;
          v60 = 1;
        }
        v19 = v72;
        if ( v72 < a3 )
        {
          v14 = (int)v57;
          v19 = (int)&v57[v72];
          v57[v72] = 92;
        }
        ++v72;
        goto LABEL_205;
      case 0x5Cu:
LABEL_95:
        v64 = v63;
        v41 = v63;
        v40 = a1;
        v18 = &loc_8060228;
        if ( a6 != 2 )
          v18 = &loc_8060238;
        dword_8072254 = (int)v18;
        a1 = v40;
        v19 = sub_806617E(v11, v14);
        if ( !v59 )
          goto LABEL_205;
        goto LABEL_245;
      case 0x7Bu:
      case 0x7Du:
        if ( a5 == -1 )
          v20 = v56[1] != 0;
        else
          v20 = a5 != 1;
        if ( v20 )
          goto LABEL_183;
LABEL_109:
        if ( v71 )
          goto LABEL_183;
LABEL_110:
        v67 = 1;
LABEL_111:
        if ( a6 != 2 || !v59 )
          goto LABEL_183;
        goto LABEL_245;
      default:
        if ( v69 )
        {
          v76 = 1;
          v22 = *__ctype_b_loc();
          v14 = 2 * v63;
          v68 = (*(const unsigned __int16 *)((char *)v22 + v14) & 0x4000) != 0;
        }
        else
        {
          memset(&ps, 0, 8u);
          v76 = 0;
          v68 = 1;
          if ( a5 == -1 )
            a5 = strlen(v56);
          v44 = a5 - (v76 + v71);
          v23 = sub_80639A8(&v42 - 15, &v56[v76 + v71], v44, (mbstate_t *)(&v42 - 5));
          v77 = v23;
          if ( v23 )
          {
            v41 = v23;
            v40 = a1;
            v24 = &loc_80604BB;
            if ( v77 != -1 )
              v24 = &loc_80604D6;
            dword_807222C = (int)v24;
            v25 = v40;
            sub_806627B(v11, v14);
            v68 = 0;
            dword_8072268 = (int)&loc_8060632;
            v41 = sub_806610E(
                    v42,
                    v43,
                    v44,
                    v45,
                    v46,
                    v47,
                    v48,
                    v49,
                    v50,
                    v51,
                    v52,
                    v53,
                    v54,
                    v55,
                    v56,
                    v57,
                    *(_DWORD *)&v58,
                    *(_DWORD *)&v62,
                    *(_DWORD *)&v66);
            v40 = v25;
            v26 = &loc_80604F5;
            if ( v77 != -2 )
              v26 = &loc_8060525;
            dword_8072218 = (int)v26;
            a1 = v40;
            sub_80662EB(v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56);
            v68 = 0;
            while ( 1 )
            {
              v14 = v71;
              if ( v71 + v76 >= a5 )
                break;
              v14 = v76 + v71;
              if ( !v56[v76 + v71] )
                break;
              ++v76;
            }
          }
        }
        v67 = v68;
        if ( v76 > 1 )
          goto LABEL_147;
        if ( !v58 )
          goto LABEL_183;
        v41 = !v68;
        v40 = a1;
        v27 = &loc_806066D;
        if ( v68 == 1 )
          v27 = &loc_806081D;
        dword_807227C = (int)v27;
        a1 = v40;
        sub_80660A0(v11, v14);
LABEL_147:
        v14 = v71;
        v78 = v71 + v76;
        while ( 2 )
        {
          if ( v58 )
          {
            v41 = !v68;
            v40 = a1;
            v28 = &loc_80606A6;
            if ( v68 == 1 )
              v28 = &loc_8060778;
            dword_80721DC = (int)v28;
            a1 = v40;
            sub_8066431(v11, v14, v42, v43);
            if ( v59 )
              goto LABEL_245;
            v66 = 1;
            if ( a6 == 2 && v60 != 1 )
            {
              if ( v72 < a3 )
              {
                v14 = (int)v57;
                v57[v72] = 39;
              }
              if ( ++v72 < a3 )
              {
                v14 = (int)v57;
                v57[v72] = 36;
              }
              if ( ++v72 < a3 )
              {
                v14 = (int)v57;
                v57[v72] = 39;
              }
              ++v72;
              v60 = 1;
            }
            if ( v72 < a3 )
            {
              v14 = (int)v57;
              v57[v72] = 92;
            }
            if ( ++v72 < a3 )
            {
              v14 = (int)&v57[v72];
              v57[v72] = (v63 >> 6) + 48;
            }
            if ( ++v72 < a3 )
            {
              v14 = (int)&v57[v72];
              v57[v72] = ((v63 >> 3) & 7) + 48;
            }
            ++v72;
            v63 = (v63 & 7) + 48;
          }
          else if ( v65 )
          {
            if ( v72 < a3 )
            {
              v14 = (int)v57;
              v57[v72] = 92;
            }
            ++v72;
            v65 = 0;
          }
          v19 = v71 + 1;
          if ( v71 + 1 < v78 )
          {
            if ( v60 && v66 != 1 )
            {
              if ( v72 < a3 )
                v57[v72] = 39;
              if ( ++v72 < a3 )
                v57[v72] = 39;
              ++v72;
              v60 = 0;
            }
            if ( v72 < a3 )
              v57[v72] = v63;
            ++v72;
            ++v71;
            v14 = (int)v56;
            v63 = v56[v71];
            continue;
          }
          break;
        }
LABEL_205:
        v41 = v19;
        v40 = a1;
        v34 = &loc_8060985;
        if ( !v60 )
          v34 = &loc_80609C2;
        dword_80721DC = (int)v34;
        a1 = v40;
        sub_8066431(v11, v14, v42, v43);
        if ( v66 != 1 )
        {
          if ( v72 < a3 )
          {
            v10 = v57;
            v57[v72] = 39;
          }
          if ( ++v72 < a3 )
          {
            v10 = v57;
            v57[v72] = 39;
          }
          ++v72;
          v60 = 0;
        }
        if ( v72 < a3 )
        {
          v10 = &v57[v72];
          v57[v72] = v63;
        }
        ++v72;
        if ( v67 != 1 )
          v62 = 0;
        ++v71;
        break;
    }
  }
  if ( v72 || a6 != 2 )
  {
    if ( a6 == 2 && v59 != 1 && v61 )
    {
      if ( v62 )
      {
        sub_805FC89(a1, (int)v57, v73, v56, a5, 5, a7, v55, v54, v53);
        dword_8072240 = (int)&loc_8060BED;
        sub_80661F2(v38, v37, v42);
      }
      if ( !a3 && v73 )
      {
        a3 = v73;
        dword_8072290 = (int)&loc_805FD42;
        sub_8066034(
          v42,
          v43,
          v44,
          v45,
          v46,
          v47,
          v48,
          v49,
          v50,
          v51,
          v52,
          v53,
          v54,
          v55,
          v56,
          v57,
          *(_DWORD *)&v58,
          *(_DWORD *)&v62,
          *(_DWORD *)&v66,
          wc,
          v71,
          0,
          v73);
      }
    }
    if ( s && v59 != 1 )
    {
      while ( *s )
      {
        if ( v72 < a3 )
          v57[v72] = *s;
        ++v72;
        ++s;
      }
    }
    if ( v72 < a3 )
      v57[v72] = 0;
    result = v72;
  }
  else
  {
    v41 = v35;
    v40 = a1;
    v36 = &loc_8060A43;
    if ( !v59 )
      v36 = &loc_8060A48;
    dword_80721DC = (int)v36;
    a1 = v40;
    sub_8066431(v11, v10, v42, v43);
LABEL_245:
    if ( a6 == 2 )
    {
      if ( v58 )
        a6 = 4;
    }
    result = sub_805FC89(a1, (int)v57, a3, v56, a5, a6, a7 & 0xFFFFFFFD, 0, v54, v53);
  }
  return result;
}
// 8066034: using guessed type int __stdcall sub_8066034(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80660A0: using guessed type int __fastcall sub_80660A0(_DWORD, _DWORD);
// 806610E: using guessed type int __stdcall sub_806610E(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806617E: using guessed type int __fastcall sub_806617E(_DWORD, _DWORD);
// 806627B: using guessed type int __fastcall sub_806627B(_DWORD, _DWORD);
// 80662EB: using guessed type int __stdcall sub_80662EB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8066357: using guessed type int __stdcall sub_8066357(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80721DC: using guessed type int dword_80721DC;
// 8072204: using guessed type int dword_8072204;
// 8072218: using guessed type int dword_8072218;
// 807222C: using guessed type int dword_807222C;
// 8072240: using guessed type int dword_8072240;
// 8072254: using guessed type int dword_8072254;
// 8072268: using guessed type int dword_8072268;
// 807227C: using guessed type int dword_807227C;
// 8072290: using guessed type int dword_8072290;

//----- (08060C05) --------------------------------------------------------
#error "8060C6B: call analysis failed (funcsize=35)"

//----- (08060C70) --------------------------------------------------------
#error "8060CDC: positive sp value has been found (funcsize=31)"

//----- (08060D19) --------------------------------------------------------
void *__cdecl sub_8060D19(char *a1, size_t a2, _DWORD *a3, int *a4)
{
  int *v4; // eax
  int *v5; // ST44_4
  int v6; // ST48_4
  int v7; // ST4C_4
  void *v8; // eax
  int v10; // [esp+0h] [ebp-58h]
  int v11; // [esp+4h] [ebp-54h]
  int v12; // [esp+8h] [ebp-50h]
  int v13; // [esp+Ch] [ebp-4Ch]
  int v14; // [esp+10h] [ebp-48h]
  int v15; // [esp+14h] [ebp-44h]
  int v16; // [esp+18h] [ebp-40h]
  int v17; // [esp+1Ch] [ebp-3Ch]
  int v18; // [esp+20h] [ebp-38h]
  int v19; // [esp+24h] [ebp-34h]
  int v20; // [esp+28h] [ebp-30h]
  int v21; // [esp+2Ch] [ebp-2Ch]
  int v22; // [esp+30h] [ebp-28h]
  int v23; // [esp+34h] [ebp-24h]
  int v24; // [esp+38h] [ebp-20h]
  unsigned int size; // [esp+48h] [ebp-10h]
  void *v26; // [esp+4Ch] [ebp-Ch]

  if ( a4 )
    v4 = a4;
  else
    v4 = &dword_8073936;
  v5 = v4;
  v6 = *__errno_location();
  v7 = v5[1] | (a3 == 0);
  size = sub_805FC89((size_t)(v5 + 2), 0, 0, a1, a2, *v5, v7, (int)(v5 + 2), (char *)v5[10], (char *)v5[11]) + 1;
  v26 = sub_8062777(size);
  sub_805FC89((size_t)(v5 + 2), (int)v26, size, a1, a2, *v5, v7, (int)(v5 + 2), (char *)v5[10], (char *)v5[11]);
  *__errno_location() = v6;
  v8 = &loc_8060E6D;
  if ( !a3 )
    v8 = &loc_8060E78;
  dword_8072218 = (int)v8;
  sub_80662EB(v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24);
  *a3 = size - 1;
  return v26;
}
// 80662EB: using guessed type int __stdcall sub_80662EB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8072218: using guessed type int dword_8072218;
// 8073936: using guessed type int dword_8073936;

//----- (08060F19) --------------------------------------------------------
#error "8061169: call analysis failed (funcsize=167)"

//----- (080611FC) --------------------------------------------------------
int __cdecl sub_80611FC(int a1, int a2)
{
  return sub_8060F19(a1, a2, -1, &dword_8073936);
}
// 8060F19: using guessed type _DWORD __cdecl sub_8060F19(_DWORD, _DWORD, _DWORD, _DWORD);
// 8073936: using guessed type int dword_8073936;

//----- (08061226) --------------------------------------------------------
int __cdecl sub_8061226(int a1, int a2, int a3)
{
  return sub_8060F19(a1, a2, a3, &dword_8073936);
}
// 8060F19: using guessed type _DWORD __cdecl sub_8060F19(_DWORD, _DWORD, _DWORD, _DWORD);
// 8073936: using guessed type int dword_8073936;

//----- (0806129C) --------------------------------------------------------
int __cdecl sub_806129C(int a1, int a2, int a3)
{
  char v4; // [esp+10h] [ebp-38h]

  sub_805FAED(&v4, a2);
  return sub_8060F19(a1, a3, -1, &v4);
}
// 8060F19: using guessed type _DWORD __cdecl sub_8060F19(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (080612DA) --------------------------------------------------------
int __cdecl sub_80612DA(int a1, int a2, int a3, int a4)
{
  char v5; // [esp+10h] [ebp-38h]

  sub_805FAED(&v5, a2);
  return sub_8060F19(a1, a3, a4, &v5);
}
// 8060F19: using guessed type _DWORD __cdecl sub_8060F19(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08061317) --------------------------------------------------------
int __cdecl sub_8061317(int a1, int a2)
{
  return sub_806129C(0, a1, a2);
}

//----- (08061372) --------------------------------------------------------
int __cdecl sub_8061372(int a1, int a2, char a3)
{
  int v4; // [esp+0h] [ebp-58h]
  int v5; // [esp+8h] [ebp-50h]
  char v6; // [esp+1Ch] [ebp-3Ch]
  int v7; // [esp+20h] [ebp-38h]
  int v8; // [esp+24h] [ebp-34h]
  int v9; // [esp+28h] [ebp-30h]
  int v10; // [esp+2Ch] [ebp-2Ch]
  int v11; // [esp+30h] [ebp-28h]
  int v12; // [esp+34h] [ebp-24h]
  int v13; // [esp+38h] [ebp-20h]
  int v14; // [esp+3Ch] [ebp-1Ch]
  int v15; // [esp+40h] [ebp-18h]
  int v16; // [esp+44h] [ebp-14h]
  int v17; // [esp+48h] [ebp-10h]
  int v18; // [esp+4Ch] [ebp-Ch]

  v6 = a3;
  v7 = dword_8073936;
  v8 = dword_807393A;
  v9 = dword_807393E;
  v10 = dword_8073942;
  v11 = dword_8073946;
  v12 = dword_807394A;
  v13 = dword_807394E;
  v14 = dword_8073952;
  v15 = dword_8073956;
  v16 = dword_807395A;
  v17 = dword_807395E;
  v18 = dword_8073962;
  v5 = 1;
  sub_805F98F(&v4 - 14, a3);
  return sub_8060F19(0, a1, a2, &v7);
}
// 805F98F: using guessed type _DWORD __cdecl sub_805F98F(_DWORD, _DWORD);
// 8060F19: using guessed type _DWORD __cdecl sub_8060F19(_DWORD, _DWORD, _DWORD, _DWORD);
// 8073936: using guessed type int dword_8073936;
// 807393A: using guessed type int dword_807393A;
// 807393E: using guessed type int dword_807393E;
// 8073942: using guessed type int dword_8073942;
// 8073946: using guessed type int dword_8073946;
// 807394A: using guessed type int dword_807394A;
// 807394E: using guessed type int dword_807394E;
// 8073952: using guessed type int dword_8073952;
// 8073956: using guessed type int dword_8073956;
// 807395A: using guessed type int dword_807395A;
// 807395E: using guessed type int dword_807395E;
// 8073962: using guessed type int dword_8073962;

//----- (0806144C) --------------------------------------------------------
int __cdecl sub_806144C(int a1, char a2)
{
  return sub_8061372(a1, -1, a2);
}

//----- (08061485) --------------------------------------------------------
int __cdecl sub_8061485(int a1)
{
  return sub_806144C(a1, 58);
}

//----- (080614C2) --------------------------------------------------------
#error "806153F: call analysis failed (funcsize=40)"

//----- (08061544) --------------------------------------------------------
#error "8061597: positive sp value has been found (funcsize=0)"

//----- (08061598) --------------------------------------------------------
#error "80615C2: call analysis failed (funcsize=14)"

//----- (080615C7) --------------------------------------------------------
#error "80615FC: positive sp value has been found (funcsize=15)"

//----- (080615FD) --------------------------------------------------------
int __cdecl sub_80615FD(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [esp+0h] [ebp-48h]
  int v7; // [esp+10h] [ebp-38h]
  int v8; // [esp+14h] [ebp-34h]
  int v9; // [esp+18h] [ebp-30h]
  int v10; // [esp+1Ch] [ebp-2Ch]
  int v11; // [esp+20h] [ebp-28h]
  int v12; // [esp+24h] [ebp-24h]
  int v13; // [esp+28h] [ebp-20h]
  int v14; // [esp+2Ch] [ebp-1Ch]
  int v15; // [esp+30h] [ebp-18h]
  int v16; // [esp+34h] [ebp-14h]
  int v17; // [esp+38h] [ebp-10h]
  int v18; // [esp+3Ch] [ebp-Ch]

  v7 = dword_8073936;
  v8 = dword_807393A;
  v9 = dword_807393E;
  v10 = dword_8073942;
  v11 = dword_8073946;
  v12 = dword_807394A;
  v13 = dword_807394E;
  v14 = dword_8073952;
  v15 = dword_8073956;
  v16 = dword_807395A;
  v17 = dword_807395E;
  v18 = dword_8073962;
  sub_805FA93(&v6 - 14, a2, a3);
  return sub_8060F19(a1, a4, a5, &v7);
}
// 805FA93: using guessed type _DWORD __cdecl sub_805FA93(_DWORD, _DWORD, _DWORD);
// 8060F19: using guessed type _DWORD __cdecl sub_8060F19(_DWORD, _DWORD, _DWORD, _DWORD);
// 8073936: using guessed type int dword_8073936;
// 807393A: using guessed type int dword_807393A;
// 807393E: using guessed type int dword_807393E;
// 8073942: using guessed type int dword_8073942;
// 8073946: using guessed type int dword_8073946;
// 807394A: using guessed type int dword_807394A;
// 807394E: using guessed type int dword_807394E;
// 8073952: using guessed type int dword_8073952;
// 8073956: using guessed type int dword_8073956;
// 807395A: using guessed type int dword_807395A;
// 807395E: using guessed type int dword_807395E;
// 8073962: using guessed type int dword_8073962;

//----- (0806177C) --------------------------------------------------------
int __cdecl sub_806177C(int a1, int a2, int a3)
{
  return sub_8060F19(a3, &unk_807244C, a3, &unk_807244C);
}
// 8060F19: using guessed type _DWORD __cdecl sub_8060F19(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (080617E7) --------------------------------------------------------
int __cdecl sub_80617E7(int a1, int a2)
{
  return sub_806177C(a1, a2, -1);
}

//----- (08061809) --------------------------------------------------------
int __cdecl sub_8061809(int a1)
{
  return sub_80617E7(0, a1);
}

//----- (08061824) --------------------------------------------------------
_BOOL4 __cdecl sub_8061824(void *src, void *a2)
{
  size_t v2; // ST20_4
  bool v3; // al
  int *v4; // eax
  int *v5; // eax
  bool v6; // al
  bool v8; // [esp+15h] [ebp-E3h]
  char *s1; // [esp+18h] [ebp-E0h]
  char *s2; // [esp+1Ch] [ebp-DCh]
  size_t n; // [esp+24h] [ebp-D4h]
  void *ptr; // [esp+28h] [ebp-D0h]
  void *v13; // [esp+2Ch] [ebp-CCh]
  __int64 v14; // [esp+30h] [ebp-C8h]
  __int64 v15; // [esp+88h] [ebp-70h]
  __int64 v16; // [esp+90h] [ebp-68h]
  __int64 v17; // [esp+E8h] [ebp-10h]

  s1 = sub_805745E(src);
  s2 = sub_805745E(a2);
  v2 = sub_80574B9(s1);
  n = sub_80574B9(s2);
  v3 = v2 == n && !memcmp(s1, s2, n);
  v8 = 0;
  if ( v3 )
  {
    ptr = (void *)sub_8064C47(src);
    v13 = (void *)sub_8064C47(a2);
    if ( sub_8065DD8((int)ptr, (int)&v14) )
    {
      v4 = __errno_location();
      error(1, *v4, "%s", ptr);
    }
    if ( sub_8065DD8((int)v13, (int)&v16) )
    {
      v5 = __errno_location();
      error(1, *v5, "%s", v13);
    }
    v6 = v15 == v17 && v14 == v16;
    v8 = v6;
    free(ptr);
    free(v13);
  }
  return v8;
}

//----- (08061A24) --------------------------------------------------------
void sub_8061A24()
{
  ;
}

//----- (08061A71) --------------------------------------------------------
signed int sub_8061A71()
{
  *__errno_location() = 95;
  return -1;
}

//----- (08061A89) --------------------------------------------------------
signed int sub_8061A89()
{
  *__errno_location() = 95;
  return -1;
}

//----- (08061BC3) --------------------------------------------------------
_DWORD *__userpurge sub_8061BC3@<eax>(_DWORD *a1, int a2)
{
  int v2; // edx

  v2 = *(_DWORD *)(a2 + 68);
  *a1 = *(_DWORD *)(a2 + 64);
  a1[1] = v2;
  return a1;
}

//----- (08061BEE) --------------------------------------------------------
#error "8061C10: call analysis failed (funcsize=18)"

//----- (08061C23) --------------------------------------------------------
#error "8061C2B: positive sp value has been found (funcsize=0)"

//----- (08061C2E) --------------------------------------------------------
_DWORD *__userpurge sub_8061C2E@<eax>(_DWORD *a1, int a2)
{
  int v2; // edx

  v2 = *(_DWORD *)(a2 + 76);
  *a1 = *(_DWORD *)(a2 + 72);
  a1[1] = v2;
  return a1;
}

//----- (08061CD9) --------------------------------------------------------
int __cdecl sub_8061CD9(int a1, int a2, int a3, int a4)
{
  if ( a1 < a3 )
    return -1;
  if ( a1 > a3 )
    return 1;
  return a2 - a4;
}

//----- (08061D6B) --------------------------------------------------------
#error "80623B0: call analysis failed (funcsize=431)"

//----- (080624E2) --------------------------------------------------------
int __cdecl sub_80624E2(FILE *stream, int a2, int a3, int a4, int a5)
{
  int *v5; // eax
  int v7; // [esp+0h] [ebp-58h]
  int v8; // [esp+4h] [ebp-54h]
  int v9; // [esp+8h] [ebp-50h]
  int v10; // [esp+Ch] [ebp-4Ch]
  int v11; // [esp+10h] [ebp-48h]
  int v12; // [esp+14h] [ebp-44h]
  int v13; // [esp+18h] [ebp-40h]
  int v14; // [esp+1Ch] [ebp-3Ch]
  int v15; // [esp+20h] [ebp-38h]
  int v16; // [esp+24h] [ebp-34h]
  int v17; // [esp+28h] [ebp-30h]
  int v18; // [esp+2Ch] [ebp-2Ch]
  int v19; // [esp+30h] [ebp-28h]
  int v20; // [esp+34h] [ebp-24h]
  int v21; // [esp+38h] [ebp-20h]
  int v22; // [esp+3Ch] [ebp-1Ch]
  int v23; // [esp+40h] [ebp-18h]
  int v24; // [esp+44h] [ebp-14h]
  int v25; // [esp+48h] [ebp-10h]
  int v26; // [esp+4Ch] [ebp-Ch]
  int v27; // [esp+50h] [ebp-8h]
  int v28; // [esp+54h] [ebp-4h]
  int savedregs; // [esp+58h] [ebp+0h]

  dword_8072290 = (int)&loc_806250A;
  sub_8066034(
    v7,
    v8,
    v9,
    v10,
    v11,
    v12,
    v13,
    v14,
    v15,
    0,
    v17,
    v18,
    v19,
    v20,
    v21,
    v22,
    v23,
    v24,
    v25,
    v26,
    v27,
    v28,
    savedregs);
  do
  {
    if ( (unsigned int)++v16 > 9 )
      break;
    v5 = (int *)a5;
    a5 += 4;
    *(&v17 + v16) = *v5;
  }
  while ( *(&v17 + v16) );
  return sub_8061D6B(stream, a2, a3, a4, (int)&v17, v16);
}
// 8066034: using guessed type int __stdcall sub_8066034(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8072290: using guessed type int dword_8072290;

//----- (0806256D) --------------------------------------------------------
#error "80625BA: call analysis failed (funcsize=24)"

//----- (080625BF) --------------------------------------------------------
#error "80625D6: positive sp value has been found (funcsize=0)"

//----- (08062642) --------------------------------------------------------
int __cdecl sub_8062642(unsigned int a1, unsigned int a2)
{
  int v3; // ecx

  dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))sub_8062681;
  if ( 0x7FFFFFFF / a2 < a1 )
    sub_80628F3();
  return dword_80722B8(v3, 0x7FFFFFFF % a2);
}
// 8062681: using guessed type int sub_8062681();
// 80722B8: using guessed type int (__fastcall *dword_80722B8)(_DWORD, _DWORD);

//----- (08062681) --------------------------------------------------------
#error "8062691: positive sp value has been found (funcsize=0)"

//----- (08062692) --------------------------------------------------------
int __cdecl sub_8062692(void *ptr, int a2, int a3)
{
  if ( 0x7FFFFFFFu / a3 < a2 )
    sub_80628F3();
  return sub_80627B4(ptr, a3 * a2);
}

//----- (080626C7) --------------------------------------------------------
#error "80626F5: call analysis failed (funcsize=56)"

//----- (08062777) --------------------------------------------------------
void *__cdecl sub_8062777(size_t size)
{
  return sub_806278A(size);
}

//----- (0806278A) --------------------------------------------------------
void *__cdecl sub_806278A(size_t size)
{
  void *v2; // [esp+1Ch] [ebp-Ch]

  v2 = malloc(size);
  if ( !v2 && size )
    sub_80628F3();
  return v2;
}

//----- (080627B4) --------------------------------------------------------
#error "8062807: call analysis failed (funcsize=34)"

//----- (0806281C) --------------------------------------------------------
int __cdecl sub_806281C(void *ptr, int a2)
{
  return sub_80626C7(ptr, a2, 1);
}

//----- (080628A5) --------------------------------------------------------
void *__cdecl sub_80628A5(void *src, size_t n)
{
  void *v2; // eax

  v2 = sub_806278A(n);
  return memcpy(v2, src, n);
}

//----- (080628CE) --------------------------------------------------------
void *__cdecl sub_80628CE(char *s)
{
  size_t v1; // eax

  v1 = strlen(s);
  return sub_80628A5(s, v1 + 1);
}

//----- (080628F3) --------------------------------------------------------
void __noreturn sub_80628F3()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (0806292C) --------------------------------------------------------
#error "80629A4: call analysis failed (funcsize=35)"

//----- (080629A9) --------------------------------------------------------
#error "8062ADE: positive sp value has been found (funcsize=92)"

//----- (08062B65) --------------------------------------------------------
char *sub_8062B65()
{
  char *v1; // [esp+1Ch] [ebp-Ch]

  v1 = getcwd(0, 0);
  if ( !v1 && *__errno_location() == 12 )
    sub_80628F3();
  return v1;
}

//----- (08062B9E) --------------------------------------------------------
int sub_8062B9E()
{
  int v0; // ecx
  int v2; // [esp+10h] [ebp-18h]
  char *name; // [esp+14h] [ebp-14h]
  size_t len; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]

  name = 0;
  v2 = 34;
  do
  {
    while ( 1 )
    {
      name = (char *)sub_806281C(name, (int)&v2);
      len = v2 - 1;
      name[v2 - 2] = 0;
      *__errno_location() = 0;
      if ( gethostname(name, len) )
        break;
      if ( !name[len - 1] )
      {
        dword_807227C = (int)&locret_8062C85;
        sub_80660A0(v0, len - 1);
        break;
      }
    }
  }
  while ( !*__errno_location() || *__errno_location() == 36 || *__errno_location() == 22 || *__errno_location() == 12 );
  v5 = *__errno_location();
  free(name);
  *__errno_location() = v5;
  return 0;
}
// 80660A0: using guessed type int __fastcall sub_80660A0(_DWORD, _DWORD);
// 807227C: using guessed type int dword_807227C;

//----- (08062C87) --------------------------------------------------------
signed int __cdecl sub_8062C87(unsigned int *a1, unsigned int a2)
{
  signed int result; // eax

  if ( 0xFFFFFFFF / a2 >= *a1 )
  {
    *a1 *= a2;
    result = 0;
  }
  else
  {
    *a1 = -1;
    result = 1;
  }
  return result;
}

//----- (08062CDB) --------------------------------------------------------
int __cdecl sub_8062CDB(unsigned int *a1, unsigned int a2, int a3)
{
  int v3; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; i |= sub_8062C87(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}

//----- (08062D11) --------------------------------------------------------
int __usercall sub_8062D11@<eax>(int a1@<edx>, int a2@<ecx>, char *nptr, int a4, int base, int a6, char *s)
{
  void *v7; // eax
  const unsigned __int16 **v8; // eax
  int v9; // ecx
  int v10; // edx
  bool v11; // zf
  void *v12; // eax
  int result; // eax
  void *v14; // eax
  unsigned int v15; // edx
  int v16; // ecx
  int v17; // edx
  int v18; // ecx
  int v19; // eax
  void *v20; // eax
  int v21; // edx
  int v22; // ecx
  int v23; // [esp+0h] [ebp-48h]
  int v24; // [esp+0h] [ebp-48h]
  int v25; // [esp+4h] [ebp-44h]
  int v26; // [esp+4h] [ebp-44h]
  int v27; // [esp+8h] [ebp-40h]
  int v28; // [esp+8h] [ebp-40h]
  int v29; // [esp+Ch] [ebp-3Ch]
  int v30; // [esp+Ch] [ebp-3Ch]
  int v31; // [esp+10h] [ebp-38h]
  int v32; // [esp+10h] [ebp-38h]
  int v33; // [esp+14h] [ebp-34h]
  int v34; // [esp+14h] [ebp-34h]
  int v35; // [esp+18h] [ebp-30h]
  int v36; // [esp+18h] [ebp-30h]
  int v37; // [esp+1Ch] [ebp-2Ch]
  int v38; // [esp+1Ch] [ebp-2Ch]
  char v39; // [esp+20h] [ebp-28h]
  unsigned int v40; // [esp+24h] [ebp-24h]
  int v41; // [esp+28h] [ebp-20h]
  char *v42; // [esp+2Ch] [ebp-1Ch]
  unsigned int v43; // [esp+30h] [ebp-18h]
  int v44; // [esp+34h] [ebp-14h]
  int v45; // [esp+38h] [ebp-10h]
  char **endptr; // [esp+3Ch] [ebp-Ch]
  int v47; // [esp+40h] [ebp-8h]
  int v48; // [esp+44h] [ebp-4h]
  int savedregs; // [esp+48h] [ebp+0h]

  v41 = 0;
  if ( base < 0 || base > 36 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoul");
  v7 = &loc_8062D49;
  if ( a4 )
    v7 = &loc_8062D74;
  dword_807222C = (int)v7;
  sub_806627B(a2, a1);
  endptr = (char **)&v39;
  *__errno_location() = 0;
  v42 = nptr;
  HIBYTE(v37) = *nptr;
  v8 = __ctype_b_loc();
  v10 = HIBYTE(v37);
  v11 = ((*v8)[v10] & 0x2000) == 0;
  v12 = &loc_8062DDA;
  if ( !v11 )
    v12 = &loc_8062D96;
  dword_8072254 = (int)v12;
  sub_806617E(v9, v10 * 2);
  if ( HIBYTE(v37) == 45 )
    return 4;
  v40 = strtoul(nptr, endptr, base);
  if ( *endptr == nptr )
  {
    if ( !s || !**endptr || !strchr(s, **endptr) )
      return 4;
    v40 = 1;
  }
  else if ( *__errno_location() )
  {
    if ( *__errno_location() != 34 )
      return 4;
    v41 = 1;
  }
  v14 = &loc_8062E9A;
  if ( s )
    v14 = &loc_8062EBC;
  dword_8072218 = (int)v14;
  sub_80662EB(v23, v25, v27, v29, v31, v33, v35, v37, *(_DWORD *)&v39, v40, v41, v42, v43, v44, v45);
  v15 = v40;
  *(_DWORD *)a6 = v40;
  dword_807227C = (int)&locret_80631C3;
  sub_80660A0(v16, v15);
  if ( **endptr )
  {
    v43 = 1024;
    v44 = 1;
    if ( !strchr(s, **endptr) )
    {
      *(_DWORD *)a6 = v40;
      dword_8072268 = (int)&locret_80631C3;
      sub_806610E(
        v24,
        v26,
        v28,
        v30,
        v32,
        v34,
        v36,
        v38,
        *(_DWORD *)&v39,
        v40,
        v41,
        v42,
        v43,
        v44,
        v45,
        endptr,
        v47,
        v48,
        savedregs);
    }
    switch ( **endptr )
    {
      case 69:
      case 71:
      case 75:
      case 77:
      case 80:
      case 84:
      case 89:
      case 90:
      case 103:
      case 107:
      case 109:
      case 116:
        if ( strchr(s, 48) )
        {
          v19 = (*endptr)[1];
          if ( v19 == 68 )
            goto LABEL_52;
          v11 = v19 == 105;
          v20 = &loc_8062F89;
          if ( v11 )
            v20 = &loc_8062F90;
          dword_807227C = (int)v20;
          if ( sub_80660A0(v18, v17) == 66 )
          {
LABEL_52:
            v43 = 1000;
            ++v44;
          }
        }
        break;
      default:
        break;
    }
    switch ( **endptr )
    {
      case 66:
        goto LABEL_35;
      case 69:
        v45 = sub_8062CDB(&v40, v43, 6);
        goto LABEL_47;
      case 71:
      case 103:
        v45 = sub_8062CDB(&v40, v43, 3);
        goto LABEL_47;
      case 75:
      case 107:
        v45 = sub_8062CDB(&v40, v43, 1);
        goto LABEL_47;
      case 77:
      case 109:
        v45 = sub_8062CDB(&v40, v43, 2);
        goto LABEL_47;
      case 80:
        v45 = sub_8062CDB(&v40, v43, 5);
        goto LABEL_47;
      case 84:
      case 116:
        v45 = sub_8062CDB(&v40, v43, 4);
        goto LABEL_47;
      case 89:
        v45 = sub_8062CDB(&v40, v43, 8);
        goto LABEL_47;
      case 90:
        v45 = sub_8062CDB(&v40, v43, 7);
        goto LABEL_47;
      case 98:
        v45 = sub_8062C87(&v40, 0x200u);
        dword_807222C = (int)&loc_8063183;
        sub_806627B(v22, v21);
LABEL_35:
        v45 = sub_8062C87(&v40, 0x400u);
        goto LABEL_47;
      case 99:
        v45 = 0;
        goto LABEL_47;
      case 119:
        v45 = sub_8062C87(&v40, 2u);
LABEL_47:
        v41 |= v45;
        *endptr += v44;
        if ( **endptr )
          v41 |= 2u;
        goto LABEL_49;
      default:
        *(_DWORD *)a6 = v40;
        result = v41 | 2;
        break;
    }
  }
  else
  {
LABEL_49:
    *(_DWORD *)a6 = v40;
    result = v41;
  }
  return result;
}
// 8062D11: could not find valid save-restore pair for ebx
// 80660A0: using guessed type int __fastcall sub_80660A0(_DWORD, _DWORD);
// 806610E: using guessed type int __stdcall sub_806610E(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 806617E: using guessed type int __fastcall sub_806617E(_DWORD, _DWORD);
// 806627B: using guessed type int __fastcall sub_806627B(_DWORD, _DWORD);
// 80662EB: using guessed type int __stdcall sub_80662EB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8072218: using guessed type int dword_8072218;
// 807222C: using guessed type int dword_807222C;
// 8072254: using guessed type int dword_8072254;
// 8072268: using guessed type int dword_8072268;
// 807227C: using guessed type int dword_807227C;

//----- (080631C5) --------------------------------------------------------
int __fastcall sub_80631C5(int ecx0, int edx0, unsigned int a1, int a2, char a3)
{
  int v6; // eax
  int v7; // [esp+0h] [ebp-38h]
  int v8; // [esp+4h] [ebp-34h]
  int v9; // [esp+8h] [ebp-30h]
  int v10; // [esp+Ch] [ebp-2Ch]
  int v11; // [esp+10h] [ebp-28h]
  int v12; // [esp+14h] [ebp-24h]
  int v13; // [esp+18h] [ebp-20h]
  int v14; // [esp+1Ch] [ebp-1Ch]
  int v15; // [esp+20h] [ebp-18h]
  int v16; // [esp+28h] [ebp-10h]
  int v17; // [esp+2Ch] [ebp-Ch]
  int v18; // [esp+30h] [ebp-8h]
  int v19; // [esp+34h] [ebp-4h]
  int savedregs; // [esp+38h] [ebp+0h]

  LOBYTE(v14) = a3;
  dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))&loc_8063265;
  if ( a1 <= 3 )
  {
    dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))sub_806329B;
    if ( a1 < 2 )
    {
      dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))sub_80632B5;
      if ( a1 != 1 )
      {
        dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))&loc_806327C;
        dword_8072204 = (int)&loc_804E032;
        v6 = sub_8066357(v7, v8, v9, v10, v11, v12, v13, v14, v15, "--", v16, v17, v18, v19, savedregs);
        dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))sub_8063281;
        if ( v6 != 4 )
          abort();
      }
    }
  }
  return dword_80722B8(ecx0, edx0);
}
// 8066357: using guessed type int __stdcall sub_8066357(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8072204: using guessed type int dword_8072204;
// 80722B8: using guessed type int (__fastcall *dword_80722B8)(_DWORD, _DWORD);

//----- (08063281) --------------------------------------------------------
int __usercall sub_8063281@<eax>(int a1@<ebp>, int a2@<edx>, int a3@<ecx>)
{
  *(_DWORD *)(a1 - 16) = "invalid %s%s argument '%s'";
  dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))&loc_80632BC;
  return ((int (__fastcall *)(int, int))loc_80632BC)(a3, a2);
}
// 80722B8: using guessed type int (__fastcall *dword_80722B8)(_DWORD, _DWORD);

//----- (0806329B) --------------------------------------------------------
int __usercall sub_806329B@<eax>(int a1@<ebp>, int a2@<edx>, int a3@<ecx>)
{
  *(_DWORD *)(a1 - 16) = "invalid suffix in %s%s argument '%s'";
  dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))&loc_80632BC;
  return ((int (__fastcall *)(int, int))loc_80632BC)(a3, a2);
}
// 80722B8: using guessed type int (__fastcall *dword_80722B8)(_DWORD, _DWORD);

//----- (080632B5) --------------------------------------------------------
int __usercall sub_80632B5@<eax>(int a1@<ebp>, int edx0@<edx>, int ecx0@<ecx>, int a2, int a3, int a4)
{
  bool v7; // sf
  int _0; // [esp+0h] [ebp+0h]

  *(_DWORD *)(a1 - 16) = &unk_806BA85;
  v7 = *(_DWORD *)(a1 + 12) < 0;
  dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))sub_8063320;
  if ( v7 )
  {
    *(&_0 - 5) -= a4;
    *((_BYTE *)&_0 - 22) = *((_BYTE *)&_0 - 28);
    *((_BYTE *)&_0 - 21) = 0;
    *(&_0 - 3) = (int)&_0 - 22;
    dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))&loc_8063332;
  }
  return dword_80722B8(ecx0, edx0);
}
// 80722B8: using guessed type int (__fastcall *dword_80722B8)(_DWORD, _DWORD);

//----- (08063320) --------------------------------------------------------
#error "806337A: positive sp value has been found (funcsize=25)"

//----- (0806337B) --------------------------------------------------------
void __fastcall __noreturn sub_806337B(int ecx0, int edx0, unsigned int a1, int a2, char a3, int a4, int a5)
{
  sub_80631C5(ecx0, a4, a1, a2, a3);
  abort();
}

//----- (080633DE) --------------------------------------------------------
#error "8063462: call analysis failed (funcsize=58)"

//----- (0806349F) --------------------------------------------------------
#error "80634CF: positive sp value has been found (funcsize=15)"

//----- (080634D4) --------------------------------------------------------
int __usercall sub_80634D4@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5)
{
  int v5; // eax
  int v7; // [esp+1Ch] [ebp-Ch]

  v7 = 0;
  dword_807227C = (int)&loc_806350D;
  sub_80660A0(a2, a1);
  do
  {
    v7 |= sub_80633DE(a3, a4);
    v5 = a5--;
  }
  while ( v5 );
  return v7;
}
// 80633DE: using guessed type _DWORD __cdecl sub_80633DE(_DWORD, _DWORD);
// 80660A0: using guessed type int __fastcall sub_80660A0(_DWORD, _DWORD);
// 807227C: using guessed type int dword_807227C;

//----- (0806351F) --------------------------------------------------------
int __usercall sub_806351F@<eax>(int a1@<edx>, int a2@<ecx>, char *nptr, int a4, int base, int a6, char *s)
{
  uintmax_t v8; // rax
  int v9; // ecx
  unsigned __int8 i; // [esp+1Bh] [ebp-2Dh]
  signed int v11; // [esp+20h] [ebp-28h]
  char *v12; // [esp+24h] [ebp-24h]
  signed __int64 v13; // [esp+38h] [ebp-10h]

  v11 = 0;
  if ( base < 0 || base > 36 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoumax");
  if ( !a4 )
  {
    dword_807222C = (int)&loc_8063581;
    sub_806627B(a2, a1);
  }
  *__errno_location() = 0;
  v12 = nptr;
  for ( i = *nptr; (*__ctype_b_loc())[i] & 0x2000; i = *v12 )
    ++v12;
  if ( i == 45 )
    return 4;
  v8 = strtoumax(nptr, (char **)a4, base);
  v13 = v8;
  if ( *(char **)a4 == nptr )
  {
    if ( s && **(_BYTE **)a4 && strchr(s, **(char **)a4) )
    {
      v13 = 1LL;
      goto LABEL_21;
    }
    dword_807227C = (int)&locret_80639A6;
    sub_80660A0(v9, HIDWORD(v8));
  }
  if ( *__errno_location() )
  {
    if ( *__errno_location() != 34 )
      return 4;
    v11 = 1;
  }
LABEL_21:
  LODWORD(v8) = &loc_80636A7;
  if ( s )
    LODWORD(v8) = &loc_80636BD;
  dword_8072254 = v8;
  sub_806617E(v9, HIDWORD(v8));
  *(_QWORD *)a6 = v13;
  return v11;
}
// 80660A0: using guessed type int __fastcall sub_80660A0(_DWORD, _DWORD);
// 806617E: using guessed type int __fastcall sub_806617E(_DWORD, _DWORD);
// 806627B: using guessed type int __fastcall sub_806627B(_DWORD, _DWORD);
// 807222C: using guessed type int dword_807222C;
// 8072254: using guessed type int dword_8072254;
// 807227C: using guessed type int dword_807227C;

//----- (080639A8) --------------------------------------------------------
size_t __cdecl sub_80639A8(wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  char v5; // [esp+18h] [ebp-10h]
  size_t v6; // [esp+1Ch] [ebp-Ch]

  if ( !pwc )
    pwc = (wchar_t *)&v5;
  v6 = mbrtowc(pwc, s, n, p);
  if ( v6 <= 0xFFFFFFFD || !n || !((unsigned __int8)sub_8058175(0) ^ 1) )
    return v6;
  *pwc = (unsigned __int8)*s;
  return 1;
}

//----- (08063A1A) --------------------------------------------------------
int __cdecl sub_8063A1A(int a1, int a2)
{
  int result; // eax

  if ( *(_BYTE *)(a1 + 40) & 1 )
    result = (*(int (__cdecl **)(_DWORD, int))(a1 + 28))(*(_DWORD *)(a1 + 36), a2);
  else
    result = (*(int (__cdecl **)(int))(a1 + 28))(a2);
  return result;
}

//----- (08063A58) --------------------------------------------------------
int __cdecl sub_8063A58(int a1, int a2)
{
  void (*v2)(void); // eax
  int v3; // edx
  int v4; // edx
  int v5; // ecx
  int v7; // [esp+0h] [ebp-18h]
  int v8; // [esp+4h] [ebp-14h]

  if ( *(_BYTE *)(a1 + 40) & 1 )
  {
    v2 = *(void (**)(void))(a1 + 32);
    v3 = *(_DWORD *)(a1 + 36);
    v8 = a2;
    v7 = v3;
    v2();
    dword_8072240 = (int)&locret_8063AA9;
    sub_80661F2(v5, v4, v7);
  }
  return (*(int (__cdecl **)(int))(a1 + 32))(a2);
}
// 8072240: using guessed type int dword_8072240;

//----- (08063AAB) --------------------------------------------------------
#error "8063B06: call analysis failed (funcsize=29)"

//----- (08063B0B) --------------------------------------------------------
#error "8063BCE: positive sp value has been found (funcsize=61)"

//----- (08063BCF) --------------------------------------------------------
#error "8063C15: call analysis failed (funcsize=27)"

//----- (08063C28) --------------------------------------------------------
#error "8063C43: positive sp value has been found (funcsize=0)"

//----- (08063CBD) --------------------------------------------------------
#error "8063E72: call analysis failed (funcsize=158)"

//----- (08064089) --------------------------------------------------------
int __cdecl sub_8064089(int a1, int a2)
{
  return (a1 == 0) ^ (a2 == 0) && a1 >= 0 && a2 >= 0;
}

//----- (080640BD) --------------------------------------------------------
_BOOL4 __cdecl sub_80640BD(_DWORD *a1, _DWORD *a2)
{
  int v2; // ebx

  v2 = a1[5] ^ a2[5] | a1[4] ^ a2[4] | a1[3] ^ a2[3] | a1[2] ^ a2[2] | a1[1] ^ a2[1] | *a2 ^ *a1;
  return (v2 | (unsigned __int8)sub_8064089(a1[8], a2[8])) == 0;
}

//----- (0806416F) --------------------------------------------------------
char *__cdecl sub_806416F(void *dest, void *src, size_t n)
{
  char *result; // eax

  memcpy(dest, src, n);
  result = (char *)dest + n;
  *((_BYTE *)dest + n) = 0;
  return result;
}

//----- (0806419B) --------------------------------------------------------
#error "8064203: call analysis failed (funcsize=60)"

//----- (0806425E) --------------------------------------------------------
#error "8064328: call analysis failed (funcsize=94)"

//----- (08064431) --------------------------------------------------------
void *__cdecl sub_8064431(void *ptr)
{
  void *result; // eax
  void *v2; // ST1C_4

  result = (void *)1;
  if ( ptr != (void *)1 )
  {
    while ( ptr )
    {
      v2 = *(void **)ptr;
      free(ptr);
      result = v2;
      ptr = v2;
    }
  }
  return result;
}

//----- (08064464) --------------------------------------------------------
char *sub_8064464()
{
  return getenv("TZ");
}

//----- (08064478) --------------------------------------------------------
int __cdecl sub_8064478(char *value)
{
  int result; // eax

  if ( value )
    result = setenv("TZ", value, 1);
  else
    result = unsetenv("TZ");
  return result;
}

//----- (080644AF) --------------------------------------------------------
signed int __cdecl sub_80644AF(int a1)
{
  char *v1; // eax

  if ( *(_BYTE *)(a1 + 4) )
    v1 = (char *)(a1 + 5);
  else
    v1 = 0;
  if ( sub_8064478(v1) )
    return 0;
  tzset();
  return 1;
}

//----- (080644EC) --------------------------------------------------------
signed int __cdecl sub_80644EC(int a1)
{
  bool v1; // al
  bool v2; // al
  int v4; // eax
  int v5; // edx
  int v6; // ecx
  bool v7; // zf
  void *v8; // eax
  char *s2; // [esp+14h] [ebp-14h]
  void *ptr; // [esp+18h] [ebp-10h]

  s2 = sub_8064464();
  if ( s2 )
  {
    v1 = *(_BYTE *)(a1 + 4) && !strcmp((const char *)(a1 + 5), s2);
    v2 = v1;
  }
  else
  {
    v2 = *(_BYTE *)(a1 + 4) == 0;
  }
  if ( v2 )
    return 1;
  v4 = sub_806419B(s2);
  ptr = (void *)v4;
  v7 = v4 == 0;
  v8 = &loc_8064579;
  if ( !v7 )
    v8 = &loc_806457E;
  dword_807222C = (int)v8;
  sub_806627B(v6, v5);
  return (signed int)ptr;
}
// 806627B: using guessed type int __fastcall sub_806627B(_DWORD, _DWORD);
// 807222C: using guessed type int dword_807222C;

//----- (080645BB) --------------------------------------------------------
int __cdecl sub_80645BB(void *ptr)
{
  int v2; // [esp+0h] [ebp-28h]
  int v3; // [esp+4h] [ebp-24h]
  int v4; // [esp+8h] [ebp-20h]
  int v5; // [esp+Ch] [ebp-1Ch]
  int v6; // [esp+10h] [ebp-18h]
  int v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+18h] [ebp-10h]
  unsigned __int8 v9; // [esp+1Bh] [ebp-Dh]
  int v10; // [esp+1Ch] [ebp-Ch]
  int v11; // [esp+1Ch] [ebp-Ch]

  if ( ptr == (void *)1 )
  {
    dword_80721F0 = (int)&locret_806462D;
    sub_80663C3(v2, v3, v4, v5, v6, v7, v8, v10);
  }
  v11 = *__errno_location();
  v9 = sub_80644AF((int)ptr);
  if ( v9 ^ 1 )
    v11 = *__errno_location();
  sub_8064431(ptr);
  *__errno_location() = v11;
  return v9;
}
// 80663C3: using guessed type int __stdcall sub_80663C3(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80721F0: using guessed type int dword_80721F0;

//----- (0806462F) --------------------------------------------------------
#error "806465B: call analysis failed (funcsize=53)"

//----- (080646D8) --------------------------------------------------------
int __cdecl sub_80646D8(int a1, struct tm *tp)
{
  int result; // eax
  time_t v3; // eax
  int v4; // edx
  int v5; // ecx
  bool v6; // zf
  void *v7; // eax
  int v8; // edx
  int v9; // ecx
  void *v10; // eax
  time_t timer; // [esp+18h] [ebp-40h]
  void *ptr; // [esp+1Ch] [ebp-3Ch]
  time_t v13; // [esp+20h] [ebp-38h]
  struct tm v14; // [esp+24h] [ebp-34h]

  if ( !a1 )
    return timegm(tp);
  ptr = (void *)sub_80644EC(a1);
  if ( !ptr )
    goto LABEL_16;
  v3 = mktime(tp);
  timer = v3;
  v13 = -1;
  v6 = v3 == -1;
  v7 = &loc_8064742;
  if ( !v6 )
    v7 = &loc_806476E;
  dword_807222C = (int)v7;
  sub_806627B(v5, v4);
  if ( localtime_r(&timer, &v14) && sub_80640BD(tp, &v14) )
  {
    v6 = (unsigned __int8)sub_806425E(a1, tp) == 1;
    v10 = &loc_80647A0;
    if ( v6 )
      v10 = &loc_80647A6;
    dword_807227C = (int)v10;
    sub_80660A0(v9, v8);
    timer = v13;
  }
  if ( (unsigned __int8)sub_80645BB(ptr) )
    result = timer;
  else
LABEL_16:
    result = -1;
  return result;
}
// 80646D8: could not find valid save-restore pair for ebx
// 806425E: using guessed type _DWORD __cdecl sub_806425E(_DWORD, _DWORD);
// 80660A0: using guessed type int __fastcall sub_80660A0(_DWORD, _DWORD);
// 806627B: using guessed type int __fastcall sub_806627B(_DWORD, _DWORD);
// 807222C: using guessed type int dword_807222C;
// 807227C: using guessed type int dword_807227C;

//----- (08064986) --------------------------------------------------------
int __cdecl sub_8064986(int a1, char a2)
{
  return __ROR4__(a1, a2);
}

//----- (08064B01) --------------------------------------------------------
int __usercall sub_8064B01@<eax>(int a1@<edx>, int a2@<ecx>, unsigned __int8 *a3, unsigned __int8 *a4)
{
  int v4; // edx
  int v5; // ecx
  void *v6; // eax
  unsigned __int8 v8; // [esp+1Eh] [ebp-Ah]
  unsigned __int8 v9; // [esp+1Fh] [ebp-9h]

  if ( a3 == a4 )
  {
    dword_807227C = (int)&loc_8064B8D;
    sub_80660A0(a2, a1);
  }
  v8 = sub_8056780(*a3);
  v9 = sub_8056780(*a4);
  if ( v8 )
  {
    v6 = &loc_8064B81;
    if ( v8 == v9 )
      v6 = &loc_8064B2F;
    dword_807227C = (int)v6;
    sub_80660A0(v5, v4);
  }
  return v8 - v9;
}
// 80660A0: using guessed type int __fastcall sub_80660A0(_DWORD, _DWORD);
// 807227C: using guessed type int dword_807227C;

//----- (08064B94) --------------------------------------------------------
#error "8064BF3: call analysis failed (funcsize=57)"

//----- (08064C47) --------------------------------------------------------
int __cdecl sub_8064C47(void *src)
{
  int v2; // edx
  int v3; // ecx
  void *v4; // ST1C_4

  v4 = sub_80573C7(src);
  dword_80722B8 = (int (__fastcall *)(_DWORD, _DWORD))sub_8064C78;
  if ( !v4 )
    sub_80628F3();
  return dword_80722B8(v3, v2);
}
// 8064C78: using guessed type int sub_8064C78();
// 80722B8: using guessed type int (__fastcall *dword_80722B8)(_DWORD, _DWORD);

//----- (08064C78) --------------------------------------------------------
#error "8064C7C: positive sp value has been found (funcsize=0)"

//----- (08064C7D) --------------------------------------------------------
#error "8064C9E: call analysis failed (funcsize=30)"

//----- (08064CD8) --------------------------------------------------------
void *sub_8064CD8()
{
  void *v0; // eax
  int v1; // eax
  bool v2; // zf
  bool v3; // sf
  unsigned __int8 v4; // of
  void *v5; // eax
  int v7; // [esp-14h] [ebp-C8h]
  int v8; // [esp-10h] [ebp-C4h]
  char *v9; // [esp-Ch] [ebp-C0h]
  char *v10; // [esp-8h] [ebp-BCh]
  int v11; // [esp-4h] [ebp-B8h]
  void *ptr; // [esp+0h] [ebp-B4h]
  void *v13; // [esp+4h] [ebp-B0h]
  char *s; // [esp+8h] [ebp-ACh]
  void *v15; // [esp+Ch] [ebp-A8h]
  int v16; // [esp+10h] [ebp-A4h]
  char *v17; // [esp+14h] [ebp-A0h]
  size_t n; // [esp+18h] [ebp-9Ch]
  size_t v19; // [esp+1Ch] [ebp-98h]
  _BOOL4 v20; // [esp+20h] [ebp-94h]
  void *dest; // [esp+24h] [ebp-90h]
  int fd; // [esp+28h] [ebp-8Ch]
  FILE *stream; // [esp+2Ch] [ebp-88h]
  int c; // [esp+30h] [ebp-84h]
  char src; // [esp+42h] [ebp-72h]
  char v26; // [esp+75h] [ebp-3Fh]
  unsigned int v27; // [esp+A8h] [ebp-Ch]

  v27 = __readgsdword(0x14u);
  v13 = (void *)dword_8073A76;
  if ( !dword_8073A76 )
  {
    ptr = 0;
    v17 = "charset.alias";
    s = getenv("CHARSETALIASDIR");
    if ( !s || !*s )
    {
      ptr = 0;
      s = "/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib";
    }
    n = strlen(s);
    v19 = strlen(v17);
    v0 = &loc_8064DAF;
    if ( !n )
      v0 = &loc_8064DCE;
    dword_8072204 = (int)v0;
    sub_8066357(v7, v8, v9, v10, v11, ptr, v13, s, v15, v16, v17, n, v19, v20, dest);
    v20 = s[n - 1] != 47;
    dest = malloc(n + v20 + v19 + 1);
    if ( dest )
    {
      memcpy(dest, s, n);
      if ( v20 )
        *((_BYTE *)dest + n) = 47;
      memcpy((char *)dest + n + v20, v17, v19 + 1);
    }
    free(ptr);
    if ( dest )
    {
      fd = open64(dest, 0x20000);
      if ( fd >= 0 )
      {
        stream = fdopen(fd, "r");
        if ( stream )
        {
          v15 = 0;
          v16 = 0;
          while ( 1 )
          {
            c = getc_unlocked(stream);
            if ( c == -1 )
              break;
            if ( c != 10 && c != 32 && c != 9 )
            {
              if ( c != 35 )
              {
                ungetc(c, stream);
                v10 = &v26;
                v9 = &src;
                v1 = fscanf(stream, "%50s %50s");
                v4 = __OFSUB__(v1, 1);
                v2 = v1 == 1;
                v3 = v1 - 1 < 0;
                v5 = &loc_806501C;
                if ( !((unsigned __int8)(v3 ^ v4) | v2) )
                  v5 = &loc_8065021;
                dword_80721F0 = (int)v5;
                sub_80663C3(v7, v8, v9, v10, v11, ptr, v13, s);
                break;
              }
              do
                c = getc_unlocked(stream);
              while ( c != -1 && c != 10 );
              if ( c == -1 )
                break;
            }
          }
          sub_80652E3(stream);
          if ( v16 )
          {
            *((_BYTE *)v15 + v16) = 0;
            v13 = v15;
          }
          else
          {
            v13 = &unk_806BCF3;
          }
        }
        else
        {
          close(fd);
          v13 = &unk_806BCF3;
        }
      }
      else
      {
        v13 = &unk_806BCF3;
      }
      free(dest);
    }
    else
    {
      v13 = &unk_806BCF3;
    }
    dword_8073A76 = (int)v13;
  }
  return v13;
}
// 80494D0: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 8066357: using guessed type int __stdcall sub_8066357(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80663C3: using guessed type int __stdcall sub_80663C3(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80721F0: using guessed type int dword_80721F0;
// 8072204: using guessed type int dword_8072204;
// 8073A76: using guessed type int dword_8073A76;

//----- (080651FE) --------------------------------------------------------
#error "8065236: call analysis failed (funcsize=71)"

//----- (080652E3) --------------------------------------------------------
int __cdecl sub_80652E3(FILE *stream)
{
  bool v2; // zf
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  int v6; // eax
  __int64 v7; // rax
  int v8; // [esp+0h] [ebp-28h]
  int v9; // [esp+14h] [ebp-14h]
  int v10; // [esp+18h] [ebp-10h]

  v9 = 0;
  if ( fileno(stream) < 0 )
    return fclose(stream);
  v2 = __freading(stream) == 0;
  v5 = &loc_8065343;
  if ( v2 )
    v5 = &loc_806537C;
  dword_8072240 = (int)v5;
  sub_80661F2(v4, v3, v8);
  v6 = fileno(stream);
  LODWORD(v7) = lseek64(v6, 0, 0, 1);
  if ( v7 != -1 && sub_80653F8(stream) )
    v9 = *__errno_location();
  v10 = fclose(stream);
  if ( v9 )
  {
    *__errno_location() = v9;
    v10 = -1;
  }
  return v10;
}
// 8049A70: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8072240: using guessed type int dword_8072240;

//----- (080653BF) --------------------------------------------------------
int __cdecl sub_80653BF(_DWORD *a1)
{
  int result; // eax

  result = *a1 & 0x100;
  if ( result )
    result = sub_806544D(a1, 0);
  return result;
}
// 806544D: using guessed type _DWORD __cdecl sub_806544D(_DWORD, _DWORD);

//----- (080653F8) --------------------------------------------------------
#error "806542C: call analysis failed (funcsize=27)"

//----- (0806544D) --------------------------------------------------------
#error "8065475: call analysis failed (funcsize=15)"

//----- (0806547A) --------------------------------------------------------
#error "8065574: positive sp value has been found (funcsize=62)"

//----- (08065579) --------------------------------------------------------
#error "80655C6: call analysis failed (funcsize=23)"

//----- (080655CB) --------------------------------------------------------
#error "806562A: positive sp value has been found (funcsize=38)"

//----- (08065745) --------------------------------------------------------
#error "8065874: call analysis failed (funcsize=186)"

//----- (080659B1) --------------------------------------------------------
#error "8065B14: call analysis failed (funcsize=142)"

//----- (08065B58) --------------------------------------------------------
#error "8065C9C: call analysis failed (funcsize=119)"

//----- (08065D5A) --------------------------------------------------------
#error "8065D93: positive sp value has been found (funcsize=18)"

//----- (08065DA9) --------------------------------------------------------
int __cdecl sub_8065DA9(int a1)
{
  return __cxa_atexit(a1, 0, dword_80722D0);
}
// 80497B0: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 80722D0: using guessed type int dword_80722D0;

//----- (08065DD8) --------------------------------------------------------
int __cdecl sub_8065DD8(int a1, int a2)
{
  return __xstat64(3, a1, a2);
}
// 8049AE0: using guessed type int __cdecl __xstat64(_DWORD, _DWORD, _DWORD);

//----- (08065E07) --------------------------------------------------------
int __cdecl sub_8065E07(int a1, int a2)
{
  return __fxstat64(3, a1, a2);
}
// 8049730: using guessed type int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD);

//----- (08065E36) --------------------------------------------------------
int __cdecl sub_8065E36(int a1, int a2)
{
  return __lxstat64(3, a1, a2);
}
// 8049AF0: using guessed type int __cdecl __lxstat64(_DWORD, _DWORD, _DWORD);

//----- (08066034) --------------------------------------------------------
#error "806603A: positive sp value has been found (funcsize=0)"

//----- (080660A0) --------------------------------------------------------
#error "80660A6: positive sp value has been found (funcsize=0)"

//----- (0806610E) --------------------------------------------------------
#error "8066114: positive sp value has been found (funcsize=0)"

//----- (0806617E) --------------------------------------------------------
#error "8066184: positive sp value has been found (funcsize=0)"

//----- (080661F2) --------------------------------------------------------
#error "80661F8: positive sp value has been found (funcsize=0)"

//----- (0806623A) --------------------------------------------------------
#error "8066273: positive sp value has been found (funcsize=18)"

//----- (0806627B) --------------------------------------------------------
#error "8066281: positive sp value has been found (funcsize=0)"

//----- (080662EB) --------------------------------------------------------
#error "80662F1: positive sp value has been found (funcsize=0)"

//----- (08066357) --------------------------------------------------------
#error "806635D: positive sp value has been found (funcsize=0)"

//----- (080663C3) --------------------------------------------------------
#error "80663C9: positive sp value has been found (funcsize=0)"

//----- (08066431) --------------------------------------------------------
#error "8066437: positive sp value has been found (funcsize=0)"

//----- (08066450) --------------------------------------------------------
int (**sub_8066450())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_8071ED0;
  v1 = &off_8071ED4 - off_8071ED0;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_8071ED0[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 8071ED0: using guessed type int (*off_8071ED0[2])();
// 8071ED4: using guessed type int (*off_8071ED4)();

//----- (080664B4) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 145 decompilation failure(s) on 440 function(s)"
