/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8049480();
// int unsetenv(const char *name);
// int raise(int sig);
// int strcmp(const char *s1, const char *s2);
// int putc_unlocked(int c, FILE *stream);
// struct passwd *getpwuid(__uid_t uid);
// int printf(const char *format, ...);
// void longjmp(struct __jmp_buf_tag env[1], int val);
// int fflush(FILE *stream);
// void _exit(int status);
// int sigprocmask(int how, const sigset_t *set, sigset_t *oset);
// int dirfd(DIR *dirp);
// int __cdecl wcwidth(_DWORD); weak
// void *memmove(void *dest, const void *src, size_t n);
// void free(void *ptr);
// uintmax_t strtoumax(const char *nptr, char **endptr, int base);
// void *memcpy(void *dest, const void *src, size_t n);
// int mbsinit(const mbstate_t *ps);
// int clock_gettime(clockid_t clock_id, struct timespec *tp);
// int tolower(int c);
// int fclose(FILE *stream);
// int getc_unlocked(FILE *stream);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// __sighandler_t signal(int sig, __sighandler_t handler);
// int memcmp(const void *s1, const void *s2, size_t n);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// char *dcgettext(const char *domainname, const char *msgid, int category);
// time_t mktime(struct tm *tp);
// struct tm *localtime_r(const time_t *timer, struct tm *tp);
// int sigismember(const sigset_t *set, int signo);
// int fflush_unlocked(FILE *stream);
// int iswcntrl(wint_t wc);
// ssize_t readlink(const char *path, char *buf, size_t len);
// int fnmatch(const char *pattern, const char *name, int flags);
// int iswprint(wint_t wc);
// int ioctl(int fd, unsigned int request, ...);
// int ferror_unlocked(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD); weak
// void tzset(void);
// size_t __ctype_get_mb_cur_max(void);
// char *strcpy(char *dest, const char *src);
// size_t __fpending(FILE *fp);
// size_t wcstombs(char *s, const wchar_t *pwcs, size_t n);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int gethostname(char *name, size_t len);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// void error(int status, int errnum, const char *format, ...);
// int strcoll(const char *s1, const char *s2);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// time_t timegm(struct tm *tp);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// char *strchr(const char *s, int c);
// char *getcwd(char *buf, size_t size);
// int fscanf(FILE *stream, const char *format, ...);
// size_t strlen(const char *s);
// int setenv(const char *name, const char *value, int replace);
// int fprintf(FILE *stream, const char *format, ...);
// int sigaddset(sigset_t *set, int signo);
// void *memset(void *s, int c, size_t n);
// int ungetc(int c, FILE *stream);
// int *__errno_location(void);
// __pid_t tcgetpgrp(int fd);
// int fileno(FILE *stream);
// int __cdecl stpncpy(_DWORD, _DWORD, _DWORD); weak
// unsigned int gnu_dev_major(unsigned __int64 dev);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// int __cdecl mempcpy(_DWORD, _DWORD, _DWORD); weak
// int __cdecl wcswidth(_DWORD, _DWORD); weak
// int sigemptyset(sigset_t *set);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// int toupper(int c);
// char *strrchr(const char *s, int c);
// size_t mbstowcs(wchar_t *pwcs, const char *s, size_t n);
// struct tm *gmtime_r(const time_t *timer, struct tm *tp);
// unsigned int gnu_dev_minor(unsigned __int64 dev);
// int sprintf(char *s, const char *format, ...);
// struct lconv *localeconv(void);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int readdir64(void); weak
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// int strncmp(const char *s1, const char *s2, size_t n);
// int isatty(int fd);
// void abort(void);
// int __cdecl __xstat64(_DWORD, _DWORD, _DWORD); weak
// int __cdecl __lxstat64(_DWORD, _DWORD, _DWORD); weak
// int close(int fd);
// int closedir(DIR *dirp);
// size_t strspn(const char *s, const char *accept);
// DIR *opendir(const char *name);
// struct group *getgrgid(__gid_t gid);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// void *calloc(size_t nmemb, size_t size);
// int putchar_unlocked(int c);
// int _gmon_start__(void); weak
void sub_8049BE3();
void sub_8049C00();
int sub_8049C10();
int sub_8049C80();
int sub_8049CA0();
void sub_8049CFF();
void sub_8049D1A();
signed int sub_8049D2A();
void sub_8049E0C();
void sub_8049E27();
int sub_8049E37();
void sub_8049F19();
void sub_8049F34();
signed int sub_8049F44();
void sub_804A026();
void sub_804A041();
int sub_804A051();
void sub_804A133();
void sub_804A14E();
int sub_804A15E();
void sub_804A240();
void sub_804A25B();
int sub_804A26B();
void sub_804A34D();
void sub_804A368();
int sub_804A378();
void sub_804A45A();
void sub_804A475();
int sub_804A485();
void sub_804A579();
void sub_804A594();
int sub_804A5A4();
// int __usercall sub_804A60B@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
void sub_804A6B4();
void sub_804A6CF();
int sub_804A6DF();
int __cdecl sub_804A7B6(int a1);
int __cdecl sub_804A7C9(unsigned __int8 a1);
// _BOOL4 __usercall sub_804A7DB@<eax>(int a1@<edx>, int a2@<ecx>, _BYTE *a3);
int sub_804A87E();
int sub_804A8A9();
// int __usercall sub_804A8D4@<eax>(int a1@<ebx>);
int __cdecl sub_804AAA8(int a1, int a2);
int __cdecl sub_804AAC7(int a1);
bool __cdecl sub_804AACF(int a1);
int sub_804AADB();
int __cdecl sub_804AAE5(int a1, int a2, int a3, int a4);
_DWORD *__stdcall sub_804ABD8(_DWORD *a1);
_BYTE *__cdecl sub_804AE27(_BYTE *a1);
void sub_804AE6A();
signed int __cdecl sub_804AEF1(int a1);
void __fastcall sub_804AFEB(int a1, int a2);
__int64 __cdecl sub_804B27E(int a1, unsigned int a2);
void __cdecl sub_804B38E(void *ptr);
_BOOL4 __cdecl sub_804B3A1(int a1, int a2, int a3, int a4);
void __cdecl sub_804B460(void *ptr);
int __cdecl sub_804B48E(int a1);
size_t sub_804B522();
size_t sub_804B542();
int __cdecl sub_804B589(int a1);
int sub_804B59F();
int sub_804B5BA();
__sighandler_t __cdecl sub_804B6AF(void (*a1)(int));
__sighandler_t sub_804B86B();
__sighandler_t sub_804B87F();
// void __usercall __noreturn main(int a1@<edx>, int a2, char **a3);
int __cdecl sub_804C019(char *nptr); // idb
int __cdecl sub_804C09D(int argc, char **argv); // idb
_DWORD __cdecl sub_804D26F(_DWORD, _DWORD, char); // weak
int sub_804D642();
// int __usercall sub_804D702@<eax>(_DWORD *a1@<ebx>);
void sub_804DB37();
int __cdecl sub_804DBD6(int a1);
int __cdecl sub_804DC09(int, char *format, int); // idb
_DWORD *__cdecl sub_804DC5F(char *a1, char *s, int a3);
// unsigned int __usercall sub_804DCE5@<eax>(int a1@<ebx>, char *a2, int a3, unsigned __int8 a4);
_DWORD *__cdecl sub_804E48C(int a1);
int __cdecl sub_804E4CF(int, char *name); // idb
int __cdecl sub_804E51A(char *a1);
int __cdecl sub_804E5BF(char *name); // idb
int __cdecl sub_804E688(int a1);
int sub_804E6B2();
void __cdecl sub_804E6CA(void **a1);
int sub_804E72F();
_DWORD __cdecl sub_804E807(_DWORD); // weak
signed int __cdecl sub_804E84E(int a1, int a2, char a3);
int __cdecl sub_804E921(int a1, int a2);
int __cdecl sub_804E9C5(int a1, int a2);
_BOOL4 __cdecl sub_804EA7F(char *s);
_DWORD __cdecl sub_804EAF2(_DWORD, _DWORD, __int64, _DWORD, _DWORD); // weak
int __cdecl sub_804FB16(int a1);
int sub_804FB6B(); // weak
int __cdecl sub_804FB75(char *path, int, int); // idb
// void *__usercall sub_804FBDE@<eax>(int a1@<edx>, int a2@<ecx>, int a3, char *s);
// _BOOL4 __usercall sub_804FC90@<eax>(int a1@<edx>, int a2@<ecx>, _BYTE *a3);
int __cdecl sub_804FCB1(char *s, int); // idb
void __cdecl __noreturn sub_804FEC6(char *s1, char *s2); // idb
int sub_804FF8E(); // weak
int __cdecl sub_804FF99(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD));
int __cdecl sub_8050015(_DWORD *a1, _DWORD *a2, void (__cdecl *a3)(_DWORD, _DWORD));
int __cdecl sub_80500A6(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD));
int __cdecl sub_8050122(int *a1, int *a2, int (__fastcall *a3)(_DWORD));
int __cdecl sub_80501B7(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD));
int __cdecl sub_80501E5(const char **a1, const char **a2, int (__cdecl *a3)(char *, char *));
int __cdecl sub_80509A6(int *a1, int *a2);
int __cdecl sub_80509C8(int *a1, int *a2);
int __cdecl sub_80509EA(int *a1, int *a2);
int __cdecl sub_8050A0C(int *a1, int *a2);
int __cdecl sub_8050A2E(int *a1, int *a2);
int __cdecl sub_8050B3C(int *a1, int *a2);
int __cdecl sub_8050C5F(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8050C81(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8050CA3(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8050CC5(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8050CE7(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8050E06(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8050E74(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8050EFB(const char **a1, const char **a2);
int __cdecl sub_8050F1D(const char **a1, const char **a2);
int __cdecl sub_8050F3F(const char **a1, const char **a2);
int __cdecl sub_8050F61(const char **a1, const char **a2);
int __cdecl sub_8050F83(const char **a1, const char **a2);
int __cdecl sub_8050FF1(const char **a1, const char **a2);
int __cdecl sub_805105F(const char **a1, const char **a2);
int __cdecl sub_80510CD(const char **a1, const char **a2);
int __cdecl sub_805113B(char **a1, char **a2);
int __cdecl sub_8051159(char **a1, char **a2);
int __cdecl sub_8051173(char **a1, char **a2);
int __cdecl sub_805118D(char **a1, char **a2);
int sub_805128B();
int sub_80512F3(void); // weak
void sub_8051318();
// int __usercall sub_80514AF@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>);
_DWORD __cdecl sub_80515CA(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
// int __usercall sub_8051677@<eax>(int a1@<ebx>);
// int __usercall sub_805175F@<eax>(int a1@<ebx>, char *s, int a3, int a4);
// int __usercall sub_805181F@<eax>(int a1@<ebx>, __uid_t uid, int a3, int a4);
// int __usercall sub_8051872@<eax>(int a1@<ebx>, __gid_t gid, int a3, int a4);
// size_t __usercall sub_80518C5@<eax>(int a1@<ebx>, char *a2, int a3);
// size_t __usercall sub_805193F@<eax>(int a1@<ebx>, __uid_t uid);
// size_t __usercall sub_8051973@<eax>(int a1@<ebx>, __gid_t gid);
const char *__cdecl sub_80519A7(int a1, unsigned int a2, int a3);
// int __usercall sub_8051A16@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, int a4);
int __cdecl sub_8051AB9(int c, size_t n); // idb
// int __usercall sub_8051B31@<eax>(int a1@<ebp>, int a2);
// int __usercall sub_8051B6B@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebp>, int a4);
int __cdecl sub_8051C04(int); // weak
int __cdecl sub_8051C4D(int); // weak
int __cdecl sub_8051C96(int); // weak
void j__abort(void);
int __cdecl sub_8051CE4(char *format, int, int); // idb
void __cdecl __noreturn sub_8051DBD(int, char *s, int, int, int, int, int); // idb
_DWORD __cdecl sub_8052ABB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_8052AFF(void *src, size_t n, mbstate_t *p, int); // idb
int __cdecl sub_8052FE1(void *a1, int a2, int a3);
char *__cdecl sub_80530D5(char *s, int a2);
int __cdecl sub_80531C9(int a1, int a2, int a3, int a4, char a5, int a6, char *a7);
int __cdecl sub_8053409(int, int, int); // weak
int __cdecl sub_80534E2(void *src, size_t n, FILE *stream); // idb
_DWORD __cdecl sub_80537D8(_DWORD, _DWORD); // weak
size_t sub_8053971();
_DWORD __cdecl sub_80539C9(_DWORD, _DWORD); // weak
_DWORD __cdecl sub_8053C1C(_DWORD, _DWORD, _DWORD); // weak
bool __cdecl sub_8053DA6(unsigned __int8 a1, int a2, int a3);
// bool __usercall sub_8053E07@<al>(int a1@<edx>, int a2@<ecx>, int a3);
_DWORD __cdecl sub_8053E6D(_DWORD, _DWORD); // weak
size_t __cdecl sub_8054285(int a1);
int __cdecl sub_80542E5(char *a1);
unsigned int sub_8054540();
int __cdecl sub_805481B(char a1);
_DWORD __cdecl sub_8054918(_DWORD, _DWORD); // weak
_BYTE *__cdecl sub_80549CE(_BYTE *a1, _BYTE *a2, _BYTE *a3);
int __fastcall sub_8054A62(_DWORD, _DWORD); // weak
unsigned int __cdecl sub_8054CB7(char a1);
void __cdecl __noreturn sub_8054F70(int status); // idb
char *__cdecl sub_80552EE(char *path, int a2);
void __noreturn sub_805541B();
int __cdecl sub_805542F(char *s, int a2);
int __fastcall sub_805559A(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_80555ED(int errnum, char *format, int, int); // idb
int __cdecl sub_8055655(int, int, size_t n); // idb
int __cdecl sub_805577C(int, char *s, int, int, size_t n, int); // idb
signed int __cdecl sub_8055878(signed int a1);
_DWORD __cdecl sub_80558A8(_DWORD); // weak
_BOOL4 __cdecl sub_8055941(int a1);
int __cdecl sub_8055A64(int a1);
int __cdecl sub_8055A9A(int, char *s, int); // idb
int __cdecl sub_8055B36(void *src, int); // idb
int sub_8056511();
// _BYTE *__usercall sub_805660E@<eax>(int a1@<edx>, int a2@<ecx>, _BYTE *a3);
// void *__usercall sub_8056698@<eax>(int a1@<edx>, int a2@<ecx>, void *src);
// _BYTE *__usercall sub_8056733@<eax>(int a1@<edx>, int a2@<ecx>, _BYTE *a3);
size_t __cdecl sub_80567A7(char *s);
int sub_80567E5();
void __cdecl sub_80567EF(int a1, char *s, int a3);
bool __cdecl sub_80568A9(int a1, int a2, int *a3);
signed int __cdecl sub_8056918(__int16 a1);
_DWORD __cdecl sub_80569BF(_DWORD, _DWORD); // weak
int __cdecl sub_8056BBF(int a1, int a2);
// void *__usercall sub_8056BDC@<eax>(int a1@<edx>, int a2@<ecx>, _BYTE *a3, _BYTE *a4, _DWORD *a5);
_BYTE *__cdecl sub_8056C0E(_BYTE *a1);
// void *__usercall sub_8056C26@<eax>(int a1@<edx>, int a2@<ecx>, _BYTE *a3, _BYTE *a4, _DWORD *a5);
_BYTE *__cdecl sub_8056D4C(_BYTE **a1);
int __cdecl sub_8056E23(int a1);
int sub_8056E69(); // weak
// int __usercall sub_8056EA2@<eax>(int a1@<ebp>, int a2);
int sub_8056ED2(); // weak
int __cdecl sub_805710B(char *s1, char *s2); // idb
struct timespec *__cdecl sub_8057353(struct timespec *tp);
int __cdecl sub_80573D3(int category); // idb
int __cdecl sub_8057467(int a1);
int __cdecl sub_8057472(int a1);
int __cdecl sub_805747D(int a1);
unsigned int __cdecl sub_8057488(int a1);
int __cdecl sub_8057661(_DWORD *a1, int a2);
int __cdecl sub_80576B1(int a1, int a2);
bool __cdecl sub_80579AF(unsigned int a1);
// int __usercall sub_8057A06@<eax>(int a1@<edx>, int a2@<ecx>, unsigned int a3);
unsigned int __cdecl sub_8057AAC(int a1, unsigned int a2);
bool __cdecl sub_8057AD7(int a1, int a2);
signed int __cdecl sub_8057AE5(int a1);
_DWORD __cdecl sub_8057BA1(_DWORD, _DWORD); // weak
_DWORD __cdecl sub_8057C77(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
void __cdecl sub_8057ED4(void *a1);
_DWORD __cdecl sub_8057FC0(_DWORD); // weak
int __cdecl sub_8058014(int a1, _DWORD *a2);
int __cdecl sub_8058057(int a1, int a2, _DWORD *a3, char a4);
_DWORD __cdecl sub_805821A(_DWORD, _DWORD, _DWORD); // weak
signed int __cdecl sub_80583D6(int a1, int a2);
int __cdecl sub_80585DD(int a1, int a2, _DWORD *a3);
int __cdecl sub_805890B(int a1, int a2);
__int64 __cdecl sub_8058BE5(int a1, unsigned int a2);
int __cdecl sub_8058D8C(int, int); // weak
void __cdecl sub_8058E7A(void **a1);
long double __cdecl sub_8058EA0(int a1, long double a2);
char *__cdecl sub_8059008(int a1, size_t n, int a3, int a4);
int __cdecl sub_8059137(int, int, char *s, int, int, int, int, int); // idb
__int64 sub_8059FF9();
int __cdecl sub_805A027(char *s, int, int); // idb
int __cdecl sub_805A1CA(char *s, int, int); // idb
char *__cdecl sub_805A213(__uid_t uid);
int __cdecl sub_805A41D(__gid_t gid); // idb
int __cdecl sub_805A634(__int64 a1, int a2);
_DWORD __cdecl sub_805A77E(_DWORD, _DWORD, _DWORD); // weak
// int __usercall sub_805A866@<eax>(int a1@<edx>, int a2@<ecx>, _DWORD *a3);
int __cdecl sub_805A8C2(int *a1, unsigned int a2);
_BYTE *__cdecl sub_805A943(_BYTE *a1, unsigned int a2, int a3);
int __cdecl sub_805A974(char *s, int, int, int, int, int); // idb
// void __usercall __noreturn sub_805AE3D(int a1@<ebx>, char *s, int a3);
// int __usercall __noreturn sub_805AE66@<eax>(int a1@<ebx>, char *a2, int a3, char a4);
int sub_805B146(); // weak
_DWORD __cdecl sub_805B148(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl sub_805B36A(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_805B61E(int a1, int a2, int a3);
int __cdecl sub_805B672(int a1, int a2, int a3);
int __cdecl sub_805B6B2(int a1, int a2, int a3);
int __cdecl sub_805B6F2(int a1, int a2);
int __cdecl sub_805B75F(int a1, int a2, int a3, int a4, int a5, int a6);
_DWORD __cdecl sub_805B7C8(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
void __fastcall __noreturn sub_805E550(int a1, int a2, int a3);
int __cdecl sub_805E59F(int c, size_t n); // idb
void *__cdecl sub_805E642(void *src);
int __cdecl sub_805E684(int *a1);
int *__cdecl sub_805E69B(int *a1, int a2);
int __cdecl sub_805E6B5(int *a1, unsigned __int8 a2, char a3);
int *__cdecl sub_805E77F(int *a1, int a2, int a3);
// _DWORD *__userpurge sub_805E7C0@<eax>(_DWORD *a1, int a2);
const char *__cdecl sub_805E892(char *msgid, int a2);
_DWORD __cdecl sub_805E95A(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_805F79D(int a1, int a2, int a3, int a4, int *a5);
void *__cdecl sub_805FA7F(signed int a1, int a2, int a3, _DWORD *a4);
void *__cdecl sub_805FD41(signed int a1, int a2);
void *__cdecl sub_805FD6B(signed int a1, int a2, int a3);
void *__cdecl sub_805FDE1(signed int a1, int a2, int a3);
void *__cdecl sub_805FE1F(signed int a1, int a2, int a3, int a4);
void *__cdecl sub_805FE5C(int a1, int a2);
void *__cdecl sub_805FEDC(int a1, int a2, unsigned __int8 a3);
void *__cdecl sub_805FFB6(int a1, unsigned __int8 a2);
void *__cdecl sub_805FFEF(int a1);
void *__cdecl sub_806002C(signed int a1, int a2, int a3);
void *__cdecl sub_806014C(signed int a1, int a2, int a3, int a4, int a5);
void *__cdecl sub_8060296(signed int a1, int a2, int a3);
void *__cdecl sub_80602F1(signed int a1, int a2);
void *__cdecl sub_8060313(int a1);
// _BOOL4 __usercall sub_806032E@<eax>(int a1@<edx>, int a2@<ecx>, void *src, void *a4);
void sub_806052E();
signed int sub_806057B();
signed int sub_8060593();
// _DWORD *__userpurge sub_80606CD@<eax>(_DWORD *a1, int a2);
// _DWORD *__userpurge sub_80606F8@<eax>(_DWORD *a1, int a2);
// _DWORD *__userpurge sub_8060733@<eax>(_DWORD *a1, int a2);
_DWORD __cdecl sub_80607EE(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_80608BA(FILE *stream, int, int, int, int, int); // idb
int __cdecl sub_806102D(FILE *stream, int, int, int, int); // idb
int sub_80610A3(FILE *stream, int a2, int a3, int a4, ...);
void *__cdecl sub_8061163(unsigned int a1, unsigned int a2);
void *__cdecl sub_8061191(void *ptr, int a2, int a3);
void *__cdecl sub_80611C6(void *ptr, int a2, int a3);
void *__cdecl sub_806125D(size_t size);
void *__cdecl sub_8061270(size_t size);
void *__cdecl sub_806129A(void *ptr, size_t size);
void *__cdecl sub_80612E9(void *ptr, int a2);
void *__cdecl sub_8061372(void *src, size_t n);
void *__cdecl sub_806139B(char *s);
void __noreturn sub_80613C0();
int sub_80613F9(void); // weak
char *sub_8061600();
int sub_8061639();
signed int __cdecl sub_8061758(unsigned int *a1, unsigned int a2);
int __cdecl sub_80617AC(int a1);
int __cdecl sub_8061805(char *nptr, int, int base, int, char *s); // idb
// void __usercall sub_8061C1B(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, int a6, int a7, int status);
void __fastcall __noreturn sub_8061D06(int a1, int a2, int a3, int a4, char a5, int a6, int a7);
signed int __cdecl sub_8061D69(int a1, int a2);
int __cdecl sub_8061E35(int a1, int a2, int a3);
int __cdecl sub_8061E6B(char *nptr, int, int base, int, char *s); // idb
int __cdecl sub_80622C6(wchar_t *pwc, char *s, size_t n, mbstate_t *p); // idb
int sub_806239C(); // weak
int __cdecl sub_80623A1(int a1, int a2);
int __cdecl sub_80623F4(int a1, int a2);
_DWORD __cdecl sub_8062432(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_806256A(int a1, int a2, int a3, int a4, int a5);
_DWORD __cdecl sub_8062648(_DWORD, _DWORD); // weak
int __cdecl sub_80627A8(void *src, size_t n); // idb
int __cdecl sub_80629FC(int a1, int a2);
_BOOL4 __cdecl sub_8062A30(_DWORD *a1, _DWORD *a2);
char *__cdecl sub_8062AE2(void *dest, void *src, size_t n);
char *__cdecl sub_8062B0E(char *s);
signed int __cdecl sub_8062BB8(int a1, unsigned int a2);
// int __usercall sub_8062D69@<eax>(int a1@<edx>, int a2@<ecx>, void *ptr);
char *sub_8062DB5();
int __cdecl sub_8062DC9(char *value); // idb
signed int __cdecl sub_8062E00(int a1);
_DWORD __cdecl sub_8062E3D(_DWORD); // weak
int __cdecl sub_8062F08(void *ptr); // idb
int __cdecl sub_8062F80(int, time_t *timer, struct tm *tp); // idb
time_t __cdecl sub_806302C(int a1, struct tm *tp);
int __cdecl sub_806329C(int a1, char a2);
int __cdecl sub_8063451(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_80634B6(FILE *fp); // idb
int sub_806359B(); // weak
// void *__usercall sub_80635A2@<eax>(int a1@<edx>, int a2@<ecx>, void *src);
int __cdecl sub_80635C6(_BYTE *a1, unsigned int a2);
int sub_806360C(void); // weak
int sub_8063B32(void); // weak
int __cdecl sub_8063C13(FILE *stream); // idb
int __cdecl sub_8063CD6(FILE *stream); // idb
int __cdecl sub_8063D0F(FILE *fp); // idb
int __cdecl sub_8063D4F(FILE *stream, int, int, int); // idb
signed __int64 __cdecl sub_8063E82(__int64 a1, unsigned int a2, signed int a3);
_DWORD __cdecl sub_8064070(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl sub_80642CB(_DWORD, _DWORD, _DWORD, _DWORD); // weak
__int64 __cdecl sub_806452F(int a1, unsigned int a2, unsigned int a3, int a4);
int __cdecl sub_80647AE(int a1);
int __cdecl sub_80647DD(int a1, int a2);
int __cdecl sub_806480C(int a1, int a2);
int __cdecl sub_806483B(int a1, int a2);
int __fastcall sub_80649F8(_DWORD, _DWORD, _DWORD);
double __fastcall sub_8064A68(_DWORD, _DWORD); // weak
int __stdcall sub_8064ADE(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_8064B50(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __fastcall sub_8064BC6(_DWORD, _DWORD);
int __fastcall sub_8064C3E(_DWORD, _DWORD); // weak
int (**sub_8064C50())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_804A804; // weak
_UNKNOWN loc_804A82A; // weak
_UNKNOWN loc_804A831; // weak
_UNKNOWN loc_804A860; // weak
_UNKNOWN loc_804A866; // weak
_UNKNOWN loc_804A877; // weak
_UNKNOWN loc_804A96B; // weak
_UNKNOWN loc_804A9A9; // weak
_UNKNOWN loc_804AA83; // weak
_UNKNOWN loc_804AEAD; // weak
_UNKNOWN loc_804AEC5; // weak
_UNKNOWN loc_804B03E; // weak
_UNKNOWN loc_804B09B; // weak
_UNKNOWN locret_804B27C; // weak
_UNKNOWN loc_804B5C8; // weak
_UNKNOWN locret_804B6AD; // weak
_UNKNOWN loc_804B860; // weak
_UNKNOWN loc_804C18A; // weak
_UNKNOWN loc_804C357; // weak
_UNKNOWN loc_804CA25; // weak
_UNKNOWN loc_804CAC4; // weak
_UNKNOWN loc_804CADB; // weak
_UNKNOWN loc_804CCEE; // weak
_UNKNOWN loc_804CE1F; // weak
_UNKNOWN loc_804CE4B; // weak
_UNKNOWN loc_804CE54; // weak
_UNKNOWN loc_804CE6D; // weak
_UNKNOWN loc_804CECA; // weak
_UNKNOWN loc_804CF13; // weak
_UNKNOWN loc_804D088; // weak
_UNKNOWN loc_804D0BD; // weak
_UNKNOWN loc_804D680; // weak
_UNKNOWN loc_804D687; // weak
_UNKNOWN loc_804D86F; // weak
_UNKNOWN loc_804D876; // weak
_UNKNOWN loc_804DA1D; // weak
_UNKNOWN loc_804DA6F; // weak
_UNKNOWN loc_804DA92; // weak
_UNKNOWN loc_804E0C5; // weak
_UNKNOWN loc_804E192; // weak
_UNKNOWN loc_804E22E; // weak
_UNKNOWN loc_804E5A7; // weak
_UNKNOWN loc_804E5C4; // weak
_UNKNOWN loc_804E5E2; // weak
_UNKNOWN loc_804E666; // weak
_UNKNOWN loc_804EA78; // weak
_UNKNOWN loc_804FB53; // weak
_UNKNOWN loc_804FB70; // weak
_UNKNOWN loc_804FF13; // weak
_UNKNOWN locret_80500A4; // weak
_UNKNOWN locret_8050BBD; // weak
_UNKNOWN loc_8050EB5; // weak
_UNKNOWN loc_8050EC7; // weak
_UNKNOWN loc_80513A8; // weak
_UNKNOWN loc_80513AD; // weak
_UNKNOWN loc_8051559; // weak
_UNKNOWN loc_8051567; // weak
_UNKNOWN loc_8051A8B; // weak
_UNKNOWN loc_8051AF7; // weak
_UNKNOWN loc_8051BA0; // weak
_UNKNOWN loc_8051BA7; // weak
_UNKNOWN loc_80531B0; // weak
_UNKNOWN loc_80532DB; // weak
_UNKNOWN loc_8053304; // weak
_UNKNOWN loc_805339B; // weak
_UNKNOWN loc_805340E; // weak
_UNKNOWN loc_805344E; // weak
_UNKNOWN locret_80539C7; // weak
_UNKNOWN loc_8053E2C; // weak
_UNKNOWN loc_8053E64; // weak
_UNKNOWN loc_805444F; // weak
_UNKNOWN loc_80545DA; // weak
_UNKNOWN loc_805486E; // weak
_UNKNOWN loc_805487B; // weak
_UNKNOWN loc_8054F15; // weak
_UNKNOWN loc_8055399; // weak
_UNKNOWN loc_80553BF; // weak
_UNKNOWN loc_80554F2; // weak
_UNKNOWN loc_80554FA; // weak
_UNKNOWN loc_805555A; // weak
_UNKNOWN locret_8055598; // weak
_UNKNOWN loc_80555CE; // weak
_UNKNOWN loc_80555F9; // weak
_UNKNOWN loc_8056554; // weak
_UNKNOWN loc_8056564; // weak
_UNKNOWN loc_805663A; // weak
_UNKNOWN loc_8056712; // weak
_UNKNOWN loc_8056723; // weak
_UNKNOWN loc_8056745; // weak
_UNKNOWN loc_805676C; // weak
_UNKNOWN loc_8056D9F; // weak
_UNKNOWN loc_8056E01; // weak
_UNKNOWN locret_8056EDB; // weak
_UNKNOWN loc_80571AF; // weak
_UNKNOWN loc_80571B9; // weak
_UNKNOWN loc_80573A7; // weak
_UNKNOWN locret_80573D1; // weak
_UNKNOWN loc_805745D; // weak
_UNKNOWN loc_8057461; // weak
_UNKNOWN loc_8057A38; // weak
_UNKNOWN loc_80580E3; // weak
_UNKNOWN loc_8058143; // weak
_UNKNOWN loc_8058156; // weak
_UNKNOWN loc_8058213; // weak
_UNKNOWN locret_80585DB; // weak
_UNKNOWN loc_8058631; // weak
_UNKNOWN loc_8058649; // weak
_UNKNOWN locret_805895D; // weak
_UNKNOWN loc_8058F98; // weak
_UNKNOWN loc_805A878; // weak
_UNKNOWN loc_805A8BC; // weak
_UNKNOWN loc_805A92C; // weak
_UNKNOWN loc_805AF18; // weak
_UNKNOWN loc_805AF25; // weak
_UNKNOWN loc_805AF32; // weak
_UNKNOWN loc_805B074; // weak
_UNKNOWN loc_805B141; // weak
_UNKNOWN loc_805E575; // weak
_UNKNOWN locret_805E958; // weak
_UNKNOWN loc_805FAF9; // weak
_UNKNOWN loc_805FB00; // weak
_UNKNOWN loc_8060142; // weak
_UNKNOWN loc_80616EE; // weak
_UNKNOWN loc_8061713; // weak
_UNKNOWN loc_8061751; // weak
_UNKNOWN locret_8061756; // weak
_UNKNOWN loc_80617E1; // weak
_UNKNOWN loc_8061CAD; // weak
_UNKNOWN loc_80622EA; // weak
_UNKNOWN locret_806239F; // weak
_UNKNOWN locret_80623F2; // weak
_UNKNOWN loc_8062D25; // weak
_UNKNOWN loc_8062D3F; // weak
_UNKNOWN loc_8062D7B; // weak
_UNKNOWN locret_8062DB3; // weak
_UNKNOWN loc_8062F5B; // weak
_UNKNOWN loc_8062F65; // weak
_UNKNOWN locret_80630F6; // weak
_UNKNOWN loc_806355B; // weak
_UNKNOWN loc_8063583; // weak
_UNKNOWN locret_80635A0; // weak
_UNKNOWN locret_8063E7C; // weak
_UNKNOWN loc_8063F09; // weak
_UNKNOWN loc_8064599; // weak
_UNKNOWN loc_80645B0; // weak
char locale = '\0'; // idb
char *off_8066010[4] = { "full-iso", "long-iso", "iso", "locale" }; // weak
_UNKNOWN unk_8066024; // weak
char *off_8066054[4] = { "none", "slash", "file-type", "classify" }; // weak
int dword_8066068[4] = { 0, 1, 2, 3 }; // idb
char *off_80660D8 = &unk_8066078; // idb
_UNKNOWN unk_8066141; // weak
struct option longopts = { "all", 0, NULL, 97 }; // idb
char *off_8066678[7] =
{
  "verbose",
  "long",
  "commas",
  "horizontal",
  "across",
  "vertical",
  "single-column"
}; // weak
int dword_8066698[] = { 0 }; // weak
char *off_80666C0[5] = { "none", "time", "size", "extension", "version" }; // weak
int dword_80666D8[5] = { 4294967295, 4, 2, 1, 3 }; // idb
char *off_806670C[5] = { "atime", "access", "use", "ctime", "status" }; // weak
int dword_8066724[5] = { 2, 2, 2, 1, 1 }; // idb
char *off_8066778[4] = { "always", "yes", "force", "never" }; // weak
int dword_80667B8[9] = { 1, 1, 1, 0, 0, 0, 2, 2, 2 }; // idb
int sig[12] = { 20, 14, 1, 2, 13, 3, 15, 29, 27, 26, 24, 25 }; // idb
_UNKNOWN unk_80694C0; // weak
_UNKNOWN unk_8069624; // weak
char *off_80698F8[10] =
{
  "literal",
  "shell",
  "shell-always",
  "shell-escape",
  "shell-escape-always",
  "c",
  "c-maybe",
  "escape",
  "locale",
  "clocale"
}; // weak
int dword_8069938[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; // idb
_UNKNOWN unk_8069966; // weak
_UNKNOWN unk_806996A; // weak
_UNKNOWN unk_806A478; // weak
_UNKNOWN unk_806D3AC; // weak
_UNKNOWN unk_806D3AF; // weak
_UNKNOWN unk_806E3CC; // weak
_UNKNOWN unk_806E3CF; // weak
int (*off_8070EE0[2])() = { &sub_8049CA0, &sub_8049C80 }; // weak
int (*off_8070EE4)() = &sub_8049C80; // weak
int (*dword_8071008)(void) = NULL; // weak
int dword_80711DC = 0; // weak
int dword_80711F0 = 0; // weak
int dword_8071204 = 0; // weak
int dword_8071218 = 0; // weak
int dword_807122C = 0; // weak
int dword_8071240 = 0; // weak
int (__cdecl *dword_8071268)(_DWORD) = NULL; // weak
int dword_8071280 = 0; // weak
_UNKNOWN unk_807129C; // weak
char byte_807129E = '\x01'; // weak
char byte_807129F = '\x01'; // weak
__int64 qword_80712A4 = 1LL; // weak
int dword_80712BC[] = { 2 }; // weak
void *s1 = &unk_806613C; // idb
int dword_80712C4 = 1; // weak
_UNKNOWN unk_80712CC; // weak
int dword_80712D0 = 0; // weak
_UNKNOWN unk_80712D4; // weak
_UNKNOWN unk_80712DC; // weak
int dword_80712F4 = 5; // weak
char *off_80712F8 = "01;36"; // idb
char *off_807137C = "%b %e  %Y"; // idb
char *off_8071380 = "%b %e %H:%M"; // weak
char byte_8071384 = '\x01'; // weak
int dword_8071388 = 4294967295; // weak
int dword_80713C4 = 1; // weak
int off_80713C8 = 134648664; // idb
int off_80713CC = 134566939; // idb
int status = 1; // idb
int dword_80713DC = 1; // weak
int dword_80713E0 = 256; // weak
void *off_80713E4 = &unk_8072802; // weak
int *off_80713E8 = &dword_80713E0; // weak
_UNKNOWN unk_80713FC; // weak
_UNKNOWN unk_807141C; // weak
_UNKNOWN unk_807141F; // weak
_UNKNOWN unk_8071420; // weak
_UNKNOWN unk_8071423; // weak
_UNKNOWN unk_8071424; // weak
_UNKNOWN unk_8071427; // weak
_UNKNOWN unk_8071430; // weak
_UNKNOWN unk_8071433; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int optind; // weak
FILE *stdout; // idb
char *optarg; // idb
char byte_807148C; // weak
_UNKNOWN unk_8071577; // weak
_UNKNOWN unk_80716AB; // weak
void *dword_8071782; // idb
void *dword_8071786; // idb
int dword_807178E; // weak
char byte_8071792; // weak
char byte_8071793; // weak
void *dword_8071796; // idb
int dword_807179A; // weak
char byte_807179E; // weak
char *dword_80717A2; // idb
int dword_80717A6; // weak
char byte_80717B2; // weak
char byte_80717B3; // weak
int dword_80717B6; // weak
int dword_80717BA; // weak
int dword_80717BE; // weak
int dword_80717C2; // weak
int dword_80717C6; // weak
int dword_80717CA; // weak
int dword_80717CE; // weak
int dword_80717D2; // weak
int dword_80717D6; // weak
int dword_80717DA; // weak
int dword_80717DE; // weak
int dword_80717E2; // weak
int dword_80717E6; // weak
char byte_80717EA; // weak
char byte_80717EB; // weak
char byte_80717EC; // weak
char byte_80717ED; // weak
int dword_80717EE; // idb
int qword_80717F2; // idb
int dword_80717FA; // weak
char byte_80717FE; // weak
int dword_8071802; // weak
char byte_8071806; // weak
char byte_8071807; // weak
char byte_8071808; // weak
int dword_807180A; // weak
void *ptr; // idb
char byte_8071813; // weak
int dword_8071816; // weak
char byte_807181A; // weak
char byte_807181B; // weak
char byte_807181C; // weak
int dword_807181E; // weak
int dword_8071822; // idb
int dword_8071826; // idb
char byte_807182A; // weak
int dword_807182E; // weak
int dword_8071832; // weak
int dword_8071836; // weak
char byte_807183A; // weak
int dword_807183E; // weak
int dword_8071842; // idb
sigset_t set; // idb
int dword_80718E2; // weak
int dword_80718E6; // weak
int dword_80718EA; // weak
void *dword_80718EE; // idb
int dword_80718F2; // idb
int dword_80718F6; // weak
_UNKNOWN unk_8071942; // weak
_UNKNOWN unk_8071982; // weak
int dword_807198E; // weak
char byte_80719C2[3328]; // idb
char byte_80726C2; // weak
struct __jmp_buf_tag env[1]; // idb
__int64 qword_8072782; // weak
__int64 qword_807278A; // weak
__int64 qword_8072792; // weak
int dword_807279E; // weak
char byte_80727A2; // weak
int dword_80727A6; // weak
int dword_80727C2; // weak
int dword_80727C6; // weak
int dword_80727CA; // weak
int dword_80727CE; // weak
int dword_80727D2; // weak
int dword_80727D6; // weak
int dword_80727DA; // weak
int dword_80727DE; // weak
int dword_80727E2; // weak
int dword_80727E6; // weak
int dword_80727EA; // weak
int dword_80727EE; // weak
_UNKNOWN unk_8072802; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (0804945C) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 8049BA0: using guessed type int _gmon_start__(void);

//----- (08049480) --------------------------------------------------------
int sub_8049480()
{
  return dword_8071008();
}
// 8071008: using guessed type int (*dword_8071008)(void);

//----- (08049BB0) --------------------------------------------------------
#error "8049BB3: positive sp value has been found (funcsize=2)"

//----- (08049BE3) --------------------------------------------------------
void sub_8049BE3()
{
  ;
}

//----- (08049C00) --------------------------------------------------------
void sub_8049C00()
{
  ;
}

//----- (08049C10) --------------------------------------------------------
int sub_8049C10()
{
  int result; // eax

  result = &unk_8071433 - &unk_8071430;
  if ( (unsigned int)(&unk_8071433 - &unk_8071430) > 6 )
    result = 0;
  return result;
}
// 8049C10: could not find valid save-restore pair for ebp

//----- (08049C80) --------------------------------------------------------
int sub_8049C80()
{
  int result; // eax

  if ( !byte_807148C )
  {
    result = sub_8049C10();
    byte_807148C = 1;
  }
  return result;
}
// 8049C80: could not find valid save-restore pair for ebp
// 807148C: using guessed type char byte_807148C;

//----- (08049CA0) --------------------------------------------------------
int sub_8049CA0()
{
  return 0;
}
// 8049CA0: could not find valid save-restore pair for ebp

//----- (08049CFF) --------------------------------------------------------
void sub_8049CFF()
{
  ;
}

//----- (08049D1A) --------------------------------------------------------
void sub_8049D1A()
{
  ;
}

//----- (08049D2A) --------------------------------------------------------
signed int sub_8049D2A()
{
  return 3;
}
// 8049D2A: could not find valid save-restore pair for ebp

//----- (08049E0C) --------------------------------------------------------
void sub_8049E0C()
{
  ;
}

//----- (08049E27) --------------------------------------------------------
void sub_8049E27()
{
  ;
}

//----- (08049E37) --------------------------------------------------------
int sub_8049E37()
{
  int result; // eax

  result = &unk_807141F - &unk_807141C;
  if ( (unsigned int)(&unk_807141F - &unk_807141C) > 6 )
    result = 0;
  return result;
}
// 8049E37: could not find valid save-restore pair for ebp

//----- (08049F19) --------------------------------------------------------
void sub_8049F19()
{
  ;
}

//----- (08049F34) --------------------------------------------------------
void sub_8049F34()
{
  ;
}

//----- (08049F44) --------------------------------------------------------
signed int sub_8049F44()
{
  return 3;
}
// 8049F44: could not find valid save-restore pair for ebp

//----- (0804A026) --------------------------------------------------------
void sub_804A026()
{
  ;
}

//----- (0804A041) --------------------------------------------------------
void sub_804A041()
{
  ;
}

//----- (0804A051) --------------------------------------------------------
int sub_804A051()
{
  int result; // eax

  result = &unk_8071577 - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_8071577 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 804A051: could not find valid save-restore pair for ebp
// 8071440: using guessed type int program_invocation_short_name;

//----- (0804A133) --------------------------------------------------------
void sub_804A133()
{
  ;
}

//----- (0804A14E) --------------------------------------------------------
void sub_804A14E()
{
  ;
}

//----- (0804A15E) --------------------------------------------------------
int sub_804A15E()
{
  int result; // eax

  result = &unk_806E3CF - &unk_806E3CC;
  if ( (unsigned int)(&unk_806E3CF - &unk_806E3CC) > 6 )
    result = 0;
  return result;
}
// 804A15E: could not find valid save-restore pair for ebp

//----- (0804A240) --------------------------------------------------------
void sub_804A240()
{
  ;
}

//----- (0804A25B) --------------------------------------------------------
void sub_804A25B()
{
  ;
}

//----- (0804A26B) --------------------------------------------------------
int sub_804A26B()
{
  int result; // eax

  result = &unk_807141F - &unk_807141C;
  if ( (unsigned int)(&unk_807141F - &unk_807141C) > 6 )
    result = 0;
  return result;
}
// 804A26B: could not find valid save-restore pair for ebp

//----- (0804A34D) --------------------------------------------------------
void sub_804A34D()
{
  ;
}

//----- (0804A368) --------------------------------------------------------
void sub_804A368()
{
  ;
}

//----- (0804A378) --------------------------------------------------------
int sub_804A378()
{
  int result; // eax

  result = &unk_806D3AF - &unk_806D3AC;
  if ( (unsigned int)(&unk_806D3AF - &unk_806D3AC) > 6 )
    result = 0;
  return result;
}
// 804A378: could not find valid save-restore pair for ebp

//----- (0804A45A) --------------------------------------------------------
void sub_804A45A()
{
  ;
}

//----- (0804A475) --------------------------------------------------------
void sub_804A475()
{
  ;
}

//----- (0804A485) --------------------------------------------------------
int sub_804A485()
{
  int result; // eax

  result = &unk_80716AB - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_80716AB - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 804A485: could not find valid save-restore pair for ebp
// 8071440: using guessed type int program_invocation_short_name;

//----- (0804A579) --------------------------------------------------------
void sub_804A579()
{
  ;
}

//----- (0804A594) --------------------------------------------------------
void sub_804A594()
{
  ;
}

//----- (0804A5A4) --------------------------------------------------------
int sub_804A5A4()
{
  int result; // eax

  result = &unk_8071423 - &unk_8071420;
  if ( (unsigned int)(&unk_8071423 - &unk_8071420) > 6 )
    result = 0;
  return result;
}
// 804A5A4: could not find valid save-restore pair for ebp

//----- (0804A60B) --------------------------------------------------------
int __usercall sub_804A60B@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_8071420, a1);
}

//----- (0804A6B4) --------------------------------------------------------
void sub_804A6B4()
{
  ;
}

//----- (0804A6CF) --------------------------------------------------------
void sub_804A6CF()
{
  ;
}

//----- (0804A6DF) --------------------------------------------------------
int sub_804A6DF()
{
  int result; // eax

  result = &unk_8071427 - &unk_8071424;
  if ( (unsigned int)(&unk_8071427 - &unk_8071424) > 6 )
    result = 0;
  return result;
}
// 804A6DF: could not find valid save-restore pair for ebp

//----- (0804A7B6) --------------------------------------------------------
int __cdecl sub_804A7B6(int a1)
{
  int result; // eax

  if ( a1 != 1 )
  {
    result = a1;
    status = a1;
  }
  return result;
}

//----- (0804A7C9) --------------------------------------------------------
int __cdecl sub_804A7C9(unsigned __int8 a1)
{
  return a1;
}

//----- (0804A7DB) --------------------------------------------------------
_BOOL4 __usercall sub_804A7DB@<eax>(int a1@<edx>, int a2@<ecx>, _BYTE *a3)
{
  void *v3; // eax
  int v4; // edx
  int v5; // ecx
  void *v6; // eax
  int v7; // ecx
  char v8; // al
  bool v9; // zf
  void *v10; // eax
  int v12; // [esp+0h] [ebp-10h]
  char v13; // [esp+Fh] [ebp-1h]

  v3 = &loc_804A804;
  if ( *a3 != 46 )
    v3 = &loc_804A877;
  dword_80711F0 = (int)v3;
  sub_8064BC6(a2, a1);
  v6 = &loc_804A82A;
  if ( a3[1] != 46 )
    v6 = &loc_804A831;
  dword_8071240 = (int)v6;
  sub_80649F8(v5, v4, v12);
  v8 = a3[2];
  v13 = v8;
  v9 = v8 == 0;
  v10 = &loc_804A860;
  if ( v9 )
    v10 = &loc_804A866;
  dword_80711DC = (int)v10;
  sub_8064C3E(v7, a3);
  return v13 == 47;
}
// 804A7DB: could not find valid save-restore pair for ebx
// 8064C3E: using guessed type int __fastcall sub_8064C3E(_DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;
// 80711F0: using guessed type int dword_80711F0;
// 8071240: using guessed type int dword_8071240;

//----- (0804A87E) --------------------------------------------------------
int sub_804A87E()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nMandatory arguments to long options are mandatory for short options too.\n");
  return fputs_unlocked(v1, v0);
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804A8A9) --------------------------------------------------------
int sub_804A8A9()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext(
         "\n"
         "The SIZE argument is an integer and optional unit (example: 10K is 10*1024).\n"
         "Units are K,M,G,T,P,E,Z,Y (powers of 1024) or KB,MB,... (powers of 1000).\n");
  return fputs_unlocked(v1, v0);
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804A8D4) --------------------------------------------------------
int __usercall sub_804A8D4@<eax>(int a1@<ebx>)
{
  int v1; // eax
  bool v2; // zf
  void *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  int v9; // [esp-8h] [ebp-74h]
  int v10; // [esp-4h] [ebp-70h]
  char *s1; // [esp+0h] [ebp-6Ch]
  char *s2; // [esp+4h] [ebp-68h]
  size_t n; // [esp+8h] [ebp-64h]
  int v14; // [esp+Ch] [ebp-60h]
  int v15; // [esp+10h] [ebp-5Ch]
  int v16; // [esp+14h] [ebp-58h]
  int v17; // [esp+18h] [ebp-54h]
  int v18; // [esp+1Ch] [ebp-50h]
  int v19; // [esp+20h] [ebp-4Ch]
  int v20; // [esp+24h] [ebp-48h]
  const char *v21; // [esp+28h] [ebp-44h]
  const char *v22; // [esp+2Ch] [ebp-40h]
  int v23; // [esp+30h] [ebp-3Ch]
  int v24; // [esp+34h] [ebp-38h]
  int v25; // [esp+38h] [ebp-34h]
  int v26; // [esp+3Ch] [ebp-30h]
  int v27; // [esp+40h] [ebp-2Ch]
  int v28; // [esp+44h] [ebp-28h]
  int v29; // [esp+48h] [ebp-24h]
  int v30; // [esp+4Ch] [ebp-20h]
  int v31; // [esp+50h] [ebp-1Ch]
  int v32; // [esp+54h] [ebp-18h]
  int v33; // [esp+58h] [ebp-14h]

  v21 = "[";
  v22 = "test invocation";
  *(&s1 - 14) = "coreutils";
  *(&s1 - 13) = "Multi-call invocation";
  *(&s1 - 12) = "sha224sum";
  *(&s1 - 11) = "sha2 utilities";
  *(&s1 - 10) = "sha256sum";
  *(&s1 - 9) = "sha2 utilities";
  *(&s1 - 8) = "sha384sum";
  *(&s1 - 7) = "sha2 utilities";
  *(&s1 - 6) = "sha512sum";
  *(&s1 - 5) = "sha2 utilities";
  *(&s1 - 4) = 0;
  *(&s1 - 3) = 0;
  *(&s1 - 19) = (char *)n;
  *(&s1 - 18) = (char *)(&s1 - 16);
  if ( *(_DWORD *)*(&s1 - 18) )
  {
    s2 = *(char **)*(&s1 - 18);
    v1 = strcmp((const char *)n, s2);
    v2 = v1 == 0;
    v10 = v1;
    v9 = a1;
    v3 = &loc_804A9A9;
    if ( !v2 )
      v3 = &loc_804A96B;
    dword_8071218 = (int)v3;
    sub_8064ADE(
      s1,
      s2,
      n,
      v14,
      v15,
      v16,
      v17,
      v18,
      v19,
      v20,
      v21,
      v22,
      v23,
      v24,
      v25,
      v26,
      v27,
      v28,
      v29,
      v30,
      v31,
      v32,
      v33);
  }
  if ( *((_DWORD *)*(&s1 - 18) + 1) )
    *(&s1 - 19) = (char *)*((_DWORD *)*(&s1 - 18) + 1);
  v4 = gettext("\n%s online help: <%s>\n");
  n = (size_t)"http://www.gnu.org/software/coreutils/";
  s2 = "GNU coreutils";
  printf(v4, "GNU coreutils");
  *(&s1 - 17) = setlocale(5, 0);
  if ( *(&s1 - 17) )
  {
    n = 3;
    s2 = "en_";
    s1 = *(&s1 - 17);
    if ( strncmp(s1, "en_", 3u) )
    {
      v5 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
      s2 = (char *)n;
      printf(v5, n);
    }
  }
  v6 = gettext("Full documentation at: <%s%s>\n");
  s2 = "http://www.gnu.org/software/coreutils/";
  printf(v6);
  if ( *(&s1 - 19) == (char *)n )
  {
    dword_8071204 = (int)&loc_804AA83;
    sub_8064B50(s1, s2, n, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29);
  }
  v7 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  n = (size_t)&locale;
  return printf(v7, *(&s1 - 19), &locale);
}
// 8064ADE: using guessed type int __stdcall sub_8064ADE(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8064B50: using guessed type int __stdcall sub_8064B50(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8071204: using guessed type int dword_8071204;
// 8071218: using guessed type int dword_8071218;

//----- (0804AAA8) --------------------------------------------------------
int __cdecl sub_804AAA8(int a1, int a2)
{
  return sub_805A634(a1, a2);
}

//----- (0804AAC7) --------------------------------------------------------
int __cdecl sub_804AAC7(int a1)
{
  return a1;
}

//----- (0804AACF) --------------------------------------------------------
bool __cdecl sub_804AACF(int a1)
{
  return a1 == 95;
}

//----- (0804AADB) --------------------------------------------------------
int sub_804AADB()
{
  return 0;
}

//----- (0804AAE5) --------------------------------------------------------
int __cdecl sub_804AAE5(int a1, int a2, int a3, int a4)
{
  _DWORD *v4; // ST3C_4
  int v5; // ecx
  int result; // eax

  if ( (unsigned int)(*((_DWORD *)&unk_8071982 + 4) - *((_DWORD *)&unk_8071982 + 3)) < 0x10 )
    sub_8062648(&unk_8071982, 16);
  *((_DWORD *)&unk_8071982 + 3) += 16;
  v4 = (_DWORD *)(dword_807198E - 16);
  v5 = dword_807198E - 16;
  *(_DWORD *)(v5 + 8) = a1;
  *(_DWORD *)(v5 + 12) = a2;
  result = a3;
  *v4 = a3;
  v4[1] = a4;
  return result;
}
// 8062648: using guessed type _DWORD __cdecl sub_8062648(_DWORD, _DWORD);
// 807198E: using guessed type int dword_807198E;

//----- (0804ABD8) --------------------------------------------------------
_DWORD *__stdcall sub_804ABD8(_DWORD *a1)
{
  _DWORD *v1; // edx

  if ( (unsigned int)(*((_DWORD *)&unk_8071982 + 3) - *((_DWORD *)&unk_8071982 + 2)) < 0x10 )
    __assert_fail("dev_ino_size <= obstack_object_size (&dev_ino_obstack)", "src/ls.c", 0x402u, "dev_ino_pop");
  dword_807198E -= 16;
  v1 = (_DWORD *)dword_807198E;
  *a1 = *(_DWORD *)dword_807198E;
  a1[1] = v1[1];
  a1[2] = v1[2];
  a1[3] = v1[3];
  return a1;
}
// 807198E: using guessed type int dword_807198E;

//----- (0804AC9B) --------------------------------------------------------
#error "804AD64: call analysis failed (funcsize=65)"

//----- (0804AE27) --------------------------------------------------------
_BYTE *__cdecl sub_804AE27(_BYTE *a1)
{
  int v1; // eax

  while ( *a1 )
  {
    if ( *a1 == 37 )
    {
      v1 = (char)a1[1];
      if ( v1 == 37 )
      {
        ++a1;
      }
      else if ( v1 == 98 )
      {
        return a1;
      }
    }
    ++a1;
  }
  return 0;
}

//----- (0804AE6A) --------------------------------------------------------
void sub_804AE6A()
{
  char v0; // bl
  bool v1; // zf
  int v2; // edx
  int v3; // ecx
  void *v4; // eax
  bool v5; // al
  int v6; // [esp+0h] [ebp-28h]
  signed int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; i <= 255; ++i )
  {
    v0 = *(_BYTE *)(i + 134683074);
    v1 = (unsigned __int8)sub_8055878(i) == 0;
    v4 = &loc_804AEAD;
    if ( !v1 )
      v4 = &loc_804AEC5;
    dword_8071240 = (int)v4;
    sub_80649F8(v3, v2, v6);
    v5 = i == 126 || i == 45 || i == 46 || i == 95;
    *(_BYTE *)(i + 134683074) = v0 | v5;
  }
}
// 8071240: using guessed type int dword_8071240;

//----- (0804AEF1) --------------------------------------------------------
signed int __cdecl sub_804AEF1(int a1)
{
  int v2; // eax
  int v3; // [esp+0h] [ebp-48h]
  int v4; // [esp+4h] [ebp-44h]
  int v5; // [esp+28h] [ebp-20h]
  unsigned int v6; // [esp+2Ch] [ebp-1Ch]
  int i; // [esp+30h] [ebp-18h]
  unsigned int v8; // [esp+34h] [ebp-14h]
  char *s; // [esp+38h] [ebp-10h]
  unsigned int v10; // [esp+3Ch] [ebp-Ch]

  v6 = 5;
  do
  {
    v8 = v6;
    v6 = 0;
    for ( i = 0; i <= 11; ++i )
    {
      v5 = v8;
      s = nl_langinfo(i + 131086);
      if ( strchr(s, 37) )
        return 0;
      v4 = a1 + (i << 7);
      v10 = sub_805A974(s, v4, 128, (int)(&v3 - 8), 0, 0);
      if ( v10 > 0x7F )
        return 0;
      v2 = v6;
      if ( v5 >= v6 )
        v2 = v5;
      v6 = v2;
    }
  }
  while ( v8 > v6 );
  return 1;
}

//----- (0804AFEB) --------------------------------------------------------
void __fastcall sub_804AFEB(int a1, int a2)
{
  _BYTE *v2; // eax
  int v3; // ecx
  signed int v4; // edx
  int v5; // edx
  int v6; // ecx
  int v7; // [esp+0h] [ebp-658h]
  signed int v8; // [esp+2Ch] [ebp-62Ch]
  int v9; // [esp+48h] [ebp-610h]
  int v10; // [esp+4Ch] [ebp-60Ch]
  char v11; // [esp+50h] [ebp-608h]

  v8 = 0;
  dword_8071240 = (int)&loc_804B03E;
  sub_80649F8(a1, a2, v7);
  do
  {
    v2 = sub_804AE27((&off_807137C)[v8]);
    v4 = v8;
    *(&v9 + v8++) = (int)v2;
  }
  while ( v8 <= 1 );
  if ( !v9 && !v10 )
  {
    dword_807122C = (int)&locret_804B27C;
    sub_8064A68(v3, v4);
  }
  if ( !((unsigned __int8)sub_804AEF1((int)&v11) ^ 1) )
  {
    dword_807122C = (int)&loc_804B09B;
    sub_8064A68(v6, v5);
    byte_80726C2 = 1;
  }
}
// 8064A68: using guessed type double __fastcall sub_8064A68(_DWORD, _DWORD);
// 807122C: using guessed type int dword_807122C;
// 8071240: using guessed type int dword_8071240;
// 80726C2: using guessed type char byte_80726C2;

//----- (0804B27E) --------------------------------------------------------
__int64 __cdecl sub_804B27E(int a1, unsigned int a2)
{
  return sub_806452F(*(_DWORD *)a1, *(_DWORD *)(a1 + 4), a2, 0);
}

//----- (0804B2D5) --------------------------------------------------------
#error "804B31A: call analysis failed (funcsize=24)"

//----- (0804B31F) --------------------------------------------------------
#error "804B38A: positive sp value has been found (funcsize=35)"

//----- (0804B38E) --------------------------------------------------------
void __cdecl sub_804B38E(void *ptr)
{
  free(ptr);
}

//----- (0804B3A1) --------------------------------------------------------
_BOOL4 __cdecl sub_804B3A1(int a1, int a2, int a3, int a4)
{
  _DWORD *ptr; // [esp+28h] [ebp-10h]
  int v6; // [esp+2Ch] [ebp-Ch]

  ptr = sub_8061270(0x10u);
  *ptr = a3;
  ptr[1] = a4;
  ptr[2] = a1;
  ptr[3] = a2;
  v6 = sub_805890B((int)dword_8071782, (int)ptr);
  if ( !v6 )
    sub_80613C0();
  if ( (_DWORD *)v6 != ptr )
    free(ptr);
  return v6 != (_DWORD)ptr;
}

//----- (0804B460) --------------------------------------------------------
void __cdecl sub_804B460(void *ptr)
{
  free(*(void **)ptr);
  free(*((void **)ptr + 1));
  free(ptr);
}

//----- (0804B48E) --------------------------------------------------------
int __cdecl sub_804B48E(int a1)
{
  int v3; // [esp+0h] [ebp-10h]
  char *s1; // [esp+4h] [ebp-Ch]

  v3 = dword_80712BC[2 * a1];
  s1 = (char *)*(&::s1 + 2 * a1);
  return v3 && (v3 != 1 || *s1 != unk_8066141) && (v3 != 2 || strncmp(s1, "00", 2u));
}
// 80712BC: using guessed type int dword_80712BC[];

//----- (0804B522) --------------------------------------------------------
size_t sub_804B522()
{
  sub_8054285((int)dword_80712BC);
  return sub_8054285((int)&dword_80712C4);
}
// 80712BC: using guessed type int dword_80712BC[];
// 80712C4: using guessed type int dword_80712C4;

//----- (0804B542) --------------------------------------------------------
size_t sub_804B542()
{
  size_t result; // eax

  result = (unsigned __int8)byte_8071806;
  if ( byte_8071806 )
  {
    result = sub_804B48E(4);
    if ( (_BYTE)result )
    {
      sub_8054285((int)dword_80712BC);
      sub_8054285((int)&unk_80712DC);
      result = sub_8054285((int)&dword_80712C4);
    }
  }
  return result;
}
// 80712BC: using guessed type int dword_80712BC[];
// 80712C4: using guessed type int dword_80712C4;
// 8071806: using guessed type char byte_8071806;

//----- (0804B589) --------------------------------------------------------
int __cdecl sub_804B589(int a1)
{
  int result; // eax

  result = dword_80718E2;
  if ( !dword_80718E2 )
  {
    result = a1;
    dword_80718E2 = a1;
  }
  return result;
}
// 80718E2: using guessed type int dword_80718E2;

//----- (0804B59F) --------------------------------------------------------
int sub_804B59F()
{
  int result; // eax

  result = dword_80718E2;
  if ( !dword_80718E2 )
    result = dword_80718E6++ + 1;
  return result;
}
// 80718E2: using guessed type int dword_80718E2;
// 80718E6: using guessed type int dword_80718E6;

//----- (0804B5BA) --------------------------------------------------------
int sub_804B5BA()
{
  void *v0; // eax
  int v2; // [esp+0h] [ebp-A8h]
  int v3; // [esp+4h] [ebp-A4h]
  int v4; // [esp+8h] [ebp-A0h]
  int v5; // [esp+Ch] [ebp-9Ch]
  int v6; // [esp+10h] [ebp-98h]
  int v7; // [esp+14h] [ebp-94h]
  signed int sig; // [esp+18h] [ebp-90h]
  int v9; // [esp+1Ch] [ebp-8Ch]
  sigset_t oset; // [esp+20h] [ebp-88h]

  while ( dword_80718E2 )
  {
    if ( byte_8071808 )
      sub_804B522();
    fflush_unlocked(stdout);
    sigprocmask(0, &set, &oset);
    sig = dword_80718E2;
    v9 = dword_80718E6;
    if ( dword_80718E6 )
    {
      --dword_80718E6;
      sig = 19;
      raise(19);
    }
    else
    {
      signal(dword_80718E2, 0);
      raise(sig);
    }
    sigprocmask(2, &oset, 0);
  }
  v0 = &locret_804B6AD;
  if ( dword_80718E6 )
    v0 = &loc_804B5C8;
  dword_8071218 = (int)v0;
  return sub_8064ADE(
           v2,
           v3,
           v4,
           v5,
           v6,
           v7,
           sig,
           v9,
           oset.__val[0],
           oset.__val[1],
           oset.__val[2],
           oset.__val[3],
           oset.__val[4],
           oset.__val[5],
           oset.__val[6],
           oset.__val[7],
           oset.__val[8],
           oset.__val[9],
           oset.__val[10],
           oset.__val[11],
           oset.__val[12],
           oset.__val[13],
           oset.__val[14]);
}
// 8064ADE: using guessed type int __stdcall sub_8064ADE(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8071218: using guessed type int dword_8071218;
// 8071808: using guessed type char byte_8071808;
// 80718E2: using guessed type int dword_80718E2;
// 80718E6: using guessed type int dword_80718E6;

//----- (0804B6AF) --------------------------------------------------------
__sighandler_t __cdecl sub_804B6AF(void (*a1)(int))
{
  __sighandler_t result; // eax
  char *v2; // edx
  int v3; // ecx
  void *v4; // eax
  int v5; // [esp+4h] [ebp-B4h]
  char v6; // [esp+Ch] [ebp-ACh]
  int i; // [esp+10h] [ebp-A8h]
  void *v8; // [esp+14h] [ebp-A4h]
  char v9; // [esp+18h] [ebp-A0h]
  int v10; // [esp+98h] [ebp-20h]

  result = a1;
  v6 = (char)a1;
  if ( (_BYTE)a1 )
  {
    sigemptyset(&set);
    for ( i = 0; i <= 11; ++i )
    {
      sigaction(sig[i], 0, (struct sigaction *)&v8);
      if ( v8 != (void *)1 )
        sigaddset(&set, sig[i]);
    }
    v2 = &v9;
    qmemcpy(&v9, &set, 0x80u);
    v3 = 0;
    v10 = 0x10000000;
    for ( i = 0; i <= 11; ++i )
    {
      if ( sigismember(&set, sig[i]) )
      {
        if ( sig[i] == 20 )
          v4 = sub_804B59F;
        else
          v4 = sub_804B589;
        v8 = v4;
        sigaction(sig[i], (const struct sigaction *)&v8, 0);
      }
    }
    dword_80711DC = (int)&loc_804B860;
    result = (__sighandler_t)sub_8064C3E(v3, v2);
  }
  for ( i = 0; i <= 11; ++i )
  {
    v5 = sig[i];
    result = (__sighandler_t)sigismember(&set, v5);
    if ( result )
      result = signal(sig[i], 0);
  }
  return result;
}
// 8064C3E: using guessed type int __fastcall sub_8064C3E(_DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;

//----- (0804B86B) --------------------------------------------------------
__sighandler_t sub_804B86B()
{
  return sub_804B6AF((void (*)(int))1);
}

//----- (0804B87F) --------------------------------------------------------
__sighandler_t sub_804B87F()
{
  return sub_804B6AF(0);
}

//----- (0804B893) --------------------------------------------------------
void __usercall __noreturn main(int a1@<edx>, int a2, char **a3)
{
  sub_805E550((int)&a2, a1, (int)*a3);
}

//----- (0804C019) --------------------------------------------------------
int __cdecl sub_804C019(char *nptr)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  int v4; // [esp+28h] [ebp-10h]
  int v5; // [esp+2Ch] [ebp-Ch]

  v1 = sub_8061E6B(nptr, 0, 0, (int)&v4, &locale);
  if ( v1 )
  {
    if ( v1 == 1 )
    {
      dword_807183E = -1;
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    v2 = v4;
    if ( v5 )
      v2 = -1;
    dword_807183E = v2;
    result = 1;
  }
  return result;
}
// 807183E: using guessed type int dword_807183E;

//----- (0804C09D) --------------------------------------------------------
int __cdecl sub_804C09D(int argc, char **argv)
{
  int v2; // edx
  int v3; // ecx
  char *v4; // ebx
  char *v5; // eax
  char *v6; // ebx
  char *v7; // eax
  int v8; // edx
  int v9; // ecx
  signed int v10; // eax
  const char *v11; // ebx
  char *v12; // eax
  char *v13; // eax
  int v14; // edx
  int v15; // ecx
  void *v16; // eax
  char v17; // al
  int v18; // eax
  const char *v19; // eax
  int v20; // edx
  int v21; // ecx
  void *v22; // eax
  void *v23; // eax
  char v24; // al
  int v25; // edx
  int v26; // ecx
  void *v27; // eax
  int result; // eax
  int v29; // edx
  int v30; // ecx
  bool v31; // zf
  void *v32; // eax
  char *v33; // ebx
  char *v34; // eax
  char *v35; // eax
  FILE *v36; // ebx
  char *v37; // eax
  int **v38; // eax
  FILE *v39; // ebx
  char *v40; // eax
  char *v41; // eax
  char *v42; // [esp+0h] [ebp-88h]
  int v43; // [esp+4h] [ebp-84h]
  int *v44; // [esp+8h] [ebp-80h]
  char *v45; // [esp+Ch] [ebp-7Ch]
  const char *v46; // [esp+10h] [ebp-78h]
  const char *v47; // [esp+14h] [ebp-74h]
  char *v48; // [esp+18h] [ebp-70h]
  char *v49; // [esp+1Ch] [ebp-6Ch]
  int v50; // [esp+20h] [ebp-68h]
  int v51; // [esp+24h] [ebp-64h]
  int v52; // [esp+28h] [ebp-60h]
  int v53; // [esp+2Ch] [ebp-5Ch]
  int v54; // [esp+30h] [ebp-58h]
  char *v55; // [esp+34h] [ebp-54h]
  int v56; // [esp+38h] [ebp-50h]
  int v57; // [esp+3Ch] [ebp-4Ch]
  _BYTE *v58; // [esp+40h] [ebp-48h]
  char *s1; // [esp+44h] [ebp-44h]
  char *v60; // [esp+48h] [ebp-40h]
  char **v61; // [esp+4Ch] [ebp-3Ch]
  int i; // [esp+50h] [ebp-38h]
  char *v63; // [esp+54h] [ebp-34h]
  char *nptr; // [esp+58h] [ebp-30h]
  int v65; // [esp+5Ch] [ebp-2Ch]
  char *v66; // [esp+60h] [ebp-28h]
  int v67; // [esp+64h] [ebp-24h]
  char *s; // [esp+68h] [ebp-20h]
  int v69; // [esp+6Ch] [ebp-1Ch]
  _DWORD *v70; // [esp+70h] [ebp-18h]
  int v71; // [esp+74h] [ebp-14h]
  int longind; // [esp+78h] [ebp-10h]

  v55 = 0;
  HIWORD(v54) = 0;
  byte_807182A = 0;
  if ( dword_80713C4 == 2 )
  {
    dword_80717DE = 2;
    sub_805E69B(0, 7);
    dword_8071240 = (int)&loc_804C18A;
    sub_80649F8(v3, v2, v42);
    goto LABEL_6;
  }
  if ( dword_80713C4 == 3 )
  {
LABEL_6:
    dword_80717DE = 0;
    sub_805E69B(0, 7);
    goto LABEL_11;
  }
  if ( dword_80713C4 != 1 )
    abort();
  if ( isatty(1) )
  {
    dword_80717DE = 2;
    sub_805E69B(0, 3);
    byte_807182A = 1;
  }
  else
  {
    dword_80717DE = 1;
    byte_807182A = 0;
  }
LABEL_11:
  dword_80717E2 = 0;
  dword_80717E6 = 0;
  byte_80717EA = 0;
  byte_80717EC = 0;
  byte_80717ED = 0;
  dword_8071802 = 0;
  byte_8071813 = 0;
  dword_8071816 = 1;
  byte_807181A = 0;
  byte_807181B = 0;
  dword_807181E = 0;
  dword_8071822 = 0;
  dword_8071826 = 0;
  byte_80717B2 = 0;
  sub_804DB37();
  dword_807183E = 80;
  v63 = getenv("COLUMNS");
  if ( v63 && *v63 && (unsigned __int8)sub_804C019(v63) ^ 1 )
  {
    v4 = (char *)sub_8060313((int)v63);
    v5 = gettext("ignoring invalid width in environment variable COLUMNS: %s");
    v45 = v4;
    error(0, 0, v5);
  }
  v44 = &longind;
  if ( ioctl(1, 0x5413u) != -1 && HIWORD(longind) )
    dword_807183E = HIWORD(longind);
  nptr = getenv("TABSIZE");
  dword_8071836 = 8;
  if ( nptr )
  {
    if ( sub_8061805(nptr, 0, 0, (int)&longind, 0) )
    {
      v6 = (char *)sub_8060313((int)nptr);
      v7 = gettext("ignoring invalid tab size in environment variable TABSIZE: %s");
      v45 = v6;
      error(0, 0, v7);
    }
    else
    {
      dword_8071836 = longind;
    }
  }
  longind = -1;
  v65 = getopt_long(argc, argv, "abcdfghiklmnopqrstuvw:xABCDFGHI:LNQRST:UXZ1", &longopts, &longind);
  if ( v65 == -1 )
  {
    if ( *(_QWORD *)&qword_80717F2 )
      goto LABEL_127;
  }
  else
  {
    switch ( v65 )
    {
      case 4294967165:
        if ( dword_80713C4 == 1 )
        {
          v19 = "ls";
        }
        else if ( dword_80713C4 == 2 )
        {
          v19 = "dir";
        }
        else
        {
          v19 = "vdir";
        }
        v48 = 0;
        v47 = "David MacKenzie";
        v46 = "Richard M. Stallman";
        sub_80610A3(stdout, (int)v19, (int)"GNU coreutils", off_80713C8, "Richard M. Stallman", "David MacKenzie", 0);
        exit(0);
        return result;
      case 4294967166:
        sub_8054F70(0);
        return result;
      case 49:
        if ( dword_80717DE )
        {
          dword_80717DE = 1;
          dword_8071240 = (int)&loc_804CCEE;
          sub_80649F8(v9, v8, v42);
        }
        break;
      case 65:
        goto LABEL_56;
      case 66:
        sub_804E48C((int)"*~");
        sub_804E48C((int)".*~");
        break;
      case 67:
        dword_80717DE = 2;
        break;
      case 68:
        byte_80717FE = 1;
        break;
      case 70:
        dword_8071802 = 3;
        break;
      case 71:
        byte_807129F = 0;
        break;
      case 72:
        dword_8071816 = 3;
        break;
      case 73:
        sub_804E48C((int)optarg);
        break;
      case 76:
        dword_8071816 = 5;
        break;
      case 78:
        sub_805E69B(0, 0);
        break;
      case 81:
        sub_805E69B(0, 5);
        break;
      case 82:
        byte_807181A = 1;
        dword_80711DC = (int)&loc_804CCEE;
        sub_8064C3E(v9, v8);
        goto LABEL_71;
      case 83:
LABEL_71:
        dword_80717E6 = 2;
        BYTE2(v54) = 1;
        break;
      case 84:
        v13 = gettext("invalid tab size");
        v50 = 2;
        v49 = v13;
        v48 = &locale;
        v46 = (const char *)-1;
        v47 = 0;
        v44 = 0;
        v45 = 0;
        v43 = 0;
        v42 = optarg;
        dword_8071836 = sub_80613F9();
        break;
      case 85:
        dword_80717E6 = -1;
        BYTE2(v54) = 1;
        dword_807122C = (int)&loc_804CCEE;
        sub_8064A68(v9, v8);
        goto LABEL_74;
      case 88:
LABEL_74:
        dword_80717E6 = 1;
        BYTE2(v54) = 1;
        break;
      case 90:
        byte_80717B2 = 1;
        break;
      case 97:
        dword_807181E = 2;
        break;
      case 98:
        sub_805E69B(0, 7);
        break;
      case 99:
        dword_80717E2 = 1;
        break;
      case 100:
        byte_807181B = 1;
        dword_807122C = (int)&loc_804CCEE;
        sub_8064A68(v9, v8);
        goto LABEL_30;
      case 102:
LABEL_30:
        dword_807181E = 2;
        dword_80717E6 = -1;
        BYTE2(v54) = 1;
        if ( !dword_80717DE )
        {
          if ( isatty(1) )
            v10 = 2;
          else
            v10 = 1;
          dword_80717DE = v10;
        }
        byte_80717ED = 0;
        byte_8071806 = 0;
        byte_8071807 = 0;
        break;
      case 103:
        dword_80717DE = 0;
        byte_807129E = 0;
        break;
      case 104:
        dword_80717EE = 176;
        dword_80717FA = 176;
        *(_QWORD *)&qword_80717F2 = 1LL;
        v8 = 0;
        qword_80712A4 = 1LL;
        break;
      case 105:
        byte_8071813 = 1;
        dword_807122C = (int)&loc_804CCEE;
        sub_8064A68(v9, v8);
        goto LABEL_40;
      case 107:
LABEL_40:
        HIBYTE(v54) = 1;
        break;
      case 108:
        dword_80717DE = 0;
        break;
      case 109:
        dword_80717DE = 4;
        break;
      case 110:
        byte_80717EC = 1;
        dword_80717DE = 0;
        break;
      case 111:
        dword_80717DE = 0;
        byte_807129F = 0;
        break;
      case 112:
        dword_8071802 = 1;
        break;
      case 113:
        byte_807182A = 1;
        break;
      case 114:
        byte_80717EA = 1;
        dword_80711DC = (int)&loc_804CCEE;
        sub_8064C3E(v9, v8);
        goto LABEL_48;
      case 115:
LABEL_48:
        byte_80717ED = 1;
        break;
      case 116:
        dword_80717E6 = 4;
        BYTE2(v54) = 1;
        dword_807122C = (int)&loc_804CCEE;
        sub_8064A68(v9, v8);
        goto LABEL_50;
      case 117:
LABEL_50:
        dword_80717E2 = 2;
        break;
      case 118:
        dword_80717E6 = 3;
        BYTE2(v54) = 1;
        break;
      case 119:
        if ( (unsigned __int8)sub_804C019(optarg) ^ 1 )
        {
          v11 = (const char *)sub_8060313((int)optarg);
          v12 = gettext("invalid line width");
          v46 = v11;
          v45 = v12;
          error(2, 0, "%s: %s");
        }
        break;
      case 120:
        dword_80717DE = 3;
        dword_80711DC = (int)&loc_804CCEE;
        sub_8064C3E(v9, v8);
LABEL_56:
        if ( !dword_807181E )
          dword_807181E = 1;
        break;
      case 128:
        byte_80717EB = 1;
        break;
      case 129:
        v71 = sub_805A1CA(optarg, (int)&dword_80717EE, (int)&qword_80717F2);
        if ( v71 )
          sub_8061D06(v9, (int)optarg, v71, longind, 0, (int)&longopts, (int)optarg);
        dword_80717FA = dword_80717EE;
        v8 = *(&qword_80717F2 + 1);
        qword_80712A4 = *(_QWORD *)&qword_80717F2;
        break;
      case 130:
        goto LABEL_85;
      case 131:
        dword_8071816 = 4;
        break;
      case 132:
        dword_8071802 = 2;
        break;
      case 133:
        dword_80717DE = dword_8066698[sub_805577C(
                                        (int)"--format",
                                        optarg,
                                        (int)off_8066678,
                                        (int)dword_8066698,
                                        4u,
                                        off_80713CC)];
        break;
      case 134:
        dword_80717DE = 0;
        v55 = (char *)sub_804AAC7((int)"full-iso");
        dword_80711DC = (int)&loc_804CCEE;
        sub_8064C3E(v15, v14);
LABEL_85:
        if ( optarg )
          v56 = dword_80667B8[sub_805577C((int)"--color", optarg, (int)off_8066778, (int)dword_80667B8, 4u, off_80713CC)];
        else
          v56 = 1;
        if ( v56 == 1 || v56 == 2 && isatty(1) )
        {
          dword_80711DC = (int)&loc_804CA25;
          sub_8064C3E(v9, v8);
        }
        byte_8071806 = 0;
        break;
      case 135:
        byte_807181C = 1;
        break;
      case 136:
        v70 = sub_8061270(8u);
        *v70 = optarg;
        v8 = dword_8071826;
        v70[1] = dword_8071826;
        dword_8071826 = (int)v70;
        break;
      case 137:
        if ( optarg )
          v57 = dword_80667B8[sub_805577C(
                                (int)"--hyperlink",
                                optarg,
                                (int)off_8066778,
                                (int)dword_80667B8,
                                4u,
                                off_80713CC)];
        else
          v57 = 1;
        if ( v57 == 1 )
          goto LABEL_193;
        v16 = &loc_804CAC4;
        if ( v57 != 2 )
          v16 = &loc_804CADB;
        dword_8071204 = (int)v16;
        sub_8064B50(v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, s1, v60);
        if ( isatty(1) )
LABEL_193:
          v17 = 1;
        else
          v17 = 0;
        byte_8071807 = v17 & 1;
        break;
      case 138:
        dword_8071802 = dword_8066068[sub_805577C(
                                        (int)"--indicator-style",
                                        optarg,
                                        (int)off_8066054,
                                        (int)dword_8066068,
                                        4u,
                                        off_80713CC)];
        break;
      case 139:
        v18 = sub_805577C((int)"--quoting-style", optarg, (int)off_80698F8, (int)dword_8069938, 4u, off_80713CC);
        sub_805E69B(0, dword_8069938[v18]);
        break;
      case 140:
        byte_807182A = 0;
        break;
      case 141:
        dword_80717EE = 144;
        dword_80717FA = 144;
        *(_QWORD *)&qword_80717F2 = 1LL;
        v8 = 0;
        qword_80712A4 = 1LL;
        break;
      case 142:
        dword_80717E6 = dword_80666D8[sub_805577C(
                                        (int)"--sort",
                                        optarg,
                                        (int)off_80666C0,
                                        (int)dword_80666D8,
                                        4u,
                                        off_80713CC)];
        BYTE2(v54) = 1;
        break;
      case 143:
        dword_80717E2 = dword_8066724[sub_805577C(
                                        (int)"--time",
                                        optarg,
                                        (int)off_806670C,
                                        (int)dword_8066724,
                                        4u,
                                        off_80713CC)];
        break;
      case 144:
        v55 = optarg;
        break;
      default:
        sub_8054F70(2);
        return result;
    }
    dword_807122C = (int)&loc_804C357;
    sub_8064A68(v9, v8);
  }
  v66 = getenv("LS_BLOCK_SIZE");
  sub_805A1CA(v66, (int)&dword_80717EE, (int)&qword_80717F2);
  if ( v66 || getenv("BLOCK_SIZE") )
  {
    dword_80717FA = dword_80717EE;
    qword_80712A4 = *(_QWORD *)&qword_80717F2;
  }
  if ( HIBYTE(v54) )
  {
    dword_80717EE = 0;
    *(_QWORD *)&qword_80717F2 = 1024LL;
  }
LABEL_127:
  dword_80718F2 = (dword_807183E % 3u != 0) + dword_807183E / 3u;
  v67 = sub_805E684(0);
  v22 = &loc_804CE1F;
  if ( dword_80717DE == 4 )
    v22 = &loc_804CE6D;
  dword_80711DC = (int)v22;
  sub_8064C3E(v21, v20);
  if ( dword_80717DE == 1 )
    goto LABEL_194;
  v23 = &loc_804CE4B;
  if ( dword_807183E )
    v23 = &loc_804CE54;
  dword_8071218 = (int)v23;
  sub_8064ADE(
    v42,
    v43,
    v44,
    v45,
    v46,
    v47,
    v48,
    v49,
    v50,
    v51,
    v52,
    v53,
    v54,
    v55,
    v56,
    v57,
    v58,
    s1,
    v60,
    v61,
    i,
    v63,
    nptr);
  if ( dword_80717DE || v67 != 1 && v67 != 3 && v67 != 6 )
LABEL_194:
    v24 = 0;
  else
    v24 = 1;
  byte_8071793 = v24 & 1;
  dword_807182E = (int)sub_805E642(0);
  if ( v67 == 7 )
    sub_805E6B5((int *)dword_807182E, 0x20u, 1);
  if ( (unsigned int)dword_8071802 > 1 )
  {
    v58 = (_BYTE *)(dword_8071802 - 2 + 134638188);
    v27 = &loc_804CF13;
    if ( *v58 )
      v27 = &loc_804CECA;
    dword_80711F0 = (int)v27;
    sub_8064BC6(v26, v25);
  }
  dword_8071832 = (int)sub_805E642(0);
  sub_805E6B5((int *)dword_8071832, 0x3Au, 1);
  if ( byte_80717FE && (dword_80717DE || byte_8071807) )
    byte_80717FE = 0;
  if ( (dword_80717E2 == 1 || dword_80717E2 == 2) && BYTE2(v54) != 1 && dword_80717DE )
    dword_80717E6 = 4;
  if ( !dword_80717DE )
  {
    s1 = v55;
    if ( !v55 )
    {
      s1 = getenv("TIME_STYLE");
      if ( !s1 )
        s1 = (char *)sub_804AAC7((int)"locale");
    }
    while ( !strncmp(s1, "posix-", 6u) )
    {
      if ( (unsigned __int8)sub_80573D3(2) ^ 1 )
        return optind;
      s1 += 6;
    }
    if ( *s1 == 43 )
    {
      s = s1 + 1;
      v60 = strchr(s1 + 1, 10);
      if ( v60 )
      {
        v31 = strchr(v60 + 1, 10) == 0;
        v32 = &loc_804D088;
        if ( v31 )
          v32 = &loc_804D0BD;
        dword_8071218 = (int)v32;
        sub_8064ADE(
          v42,
          v43,
          v44,
          v45,
          v46,
          v47,
          v48,
          v49,
          v50,
          v51,
          v52,
          v53,
          v54,
          v55,
          v56,
          v57,
          v58,
          s1,
          v60,
          v61,
          i,
          v63,
          nptr);
        v33 = (char *)sub_8060313((int)s);
        v34 = gettext("invalid time style format %s");
        v45 = v33;
        error(2, 0, v34, v33);
        v35 = v60;
        v29 = (int)(v60++ + 1);
        *v35 = 0;
      }
      else
      {
        v60 = s;
      }
      off_807137C = s;
      off_8071380 = v60;
    }
    else
    {
      v45 = (char *)4;
      v44 = (int *)&unk_8066024;
      v69 = sub_805542F(s1, (int)off_8066010);
      if ( v69 < 0 )
      {
        sub_805559A(v30, v29, (int)"time style", (int)s1, v69);
        v36 = stderr;
        v37 = gettext("Valid arguments are:\n");
        fputs_unlocked(v37, v36);
        v61 = off_8066010;
        while ( *v61 )
        {
          v38 = (int **)v61;
          ++v61;
          v44 = *v38;
          fprintf(stderr, "  - [posix-]%s\n", v44);
        }
        v39 = stderr;
        v40 = gettext("  - +FORMAT (e.g., +%H:%M) for a 'date'-style format\n");
        fputs_unlocked(v40, v39);
        sub_8054F70(2);
      }
      if ( v69 == 1 )
      {
        off_8071380 = "%Y-%m-%d %H:%M";
        off_807137C = "%Y-%m-%d %H:%M";
      }
      else if ( v69 > 1 )
      {
        if ( v69 == 2 )
        {
          off_807137C = "%Y-%m-%d ";
          off_8071380 = "%m-%d %H:%M";
        }
        else if ( v69 == 3 && (unsigned __int8)sub_80573D3(2) )
        {
          for ( i = 0; i <= 1; ++i )
          {
            v41 = dcgettext(0, (&off_807137C)[i], 2);
            v29 = i;
            (&off_807137C)[i] = v41;
          }
        }
      }
      else if ( !v69 )
      {
        off_8071380 = "%Y-%m-%d %H:%M:%S.%N %z";
        off_807137C = "%Y-%m-%d %H:%M:%S.%N %z";
      }
    }
    sub_804AFEB(v30, v29);
  }
  return optind;
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 80613F9: using guessed type int sub_80613F9(void);
// 8064A68: using guessed type double __fastcall sub_8064A68(_DWORD, _DWORD);
// 8064ADE: using guessed type int __stdcall sub_8064ADE(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8064B50: using guessed type int __stdcall sub_8064B50(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8064C3E: using guessed type int __fastcall sub_8064C3E(_DWORD, _DWORD);
// 8066010: using guessed type char *off_8066010[4];
// 8066054: using guessed type char *off_8066054[4];
// 8066678: using guessed type char *off_8066678[7];
// 8066698: using guessed type int dword_8066698[];
// 80666C0: using guessed type char *off_80666C0[5];
// 806670C: using guessed type char *off_806670C[5];
// 8066778: using guessed type char *off_8066778[4];
// 80698F8: using guessed type char *off_80698F8[10];
// 80711DC: using guessed type int dword_80711DC;
// 80711F0: using guessed type int dword_80711F0;
// 8071204: using guessed type int dword_8071204;
// 8071218: using guessed type int dword_8071218;
// 807122C: using guessed type int dword_807122C;
// 8071240: using guessed type int dword_8071240;
// 807129E: using guessed type char byte_807129E;
// 807129F: using guessed type char byte_807129F;
// 80712A4: using guessed type __int64 qword_80712A4;
// 8071380: using guessed type char *off_8071380;
// 80713C4: using guessed type int dword_80713C4;
// 8071460: using guessed type int optind;
// 8071793: using guessed type char byte_8071793;
// 80717B2: using guessed type char byte_80717B2;
// 80717DE: using guessed type int dword_80717DE;
// 80717E2: using guessed type int dword_80717E2;
// 80717E6: using guessed type int dword_80717E6;
// 80717EA: using guessed type char byte_80717EA;
// 80717EB: using guessed type char byte_80717EB;
// 80717EC: using guessed type char byte_80717EC;
// 80717ED: using guessed type char byte_80717ED;
// 80717FA: using guessed type int dword_80717FA;
// 80717FE: using guessed type char byte_80717FE;
// 8071802: using guessed type int dword_8071802;
// 8071806: using guessed type char byte_8071806;
// 8071807: using guessed type char byte_8071807;
// 8071813: using guessed type char byte_8071813;
// 8071816: using guessed type int dword_8071816;
// 807181A: using guessed type char byte_807181A;
// 807181B: using guessed type char byte_807181B;
// 807181C: using guessed type char byte_807181C;
// 807181E: using guessed type int dword_807181E;
// 807182A: using guessed type char byte_807182A;
// 807182E: using guessed type int dword_807182E;
// 8071832: using guessed type int dword_8071832;
// 8071836: using guessed type int dword_8071836;
// 807183E: using guessed type int dword_807183E;

//----- (0804D26F) --------------------------------------------------------
#error "804D4FD: call analysis failed (funcsize=281)"

//----- (0804D642) --------------------------------------------------------
int sub_804D642()
{
  int v0; // edx
  int v1; // ecx
  void *v2; // eax
  int v4; // [esp+0h] [ebp-28h]
  char *name; // [esp+1Ch] [ebp-Ch]

  name = getenv("TERM");
  if ( name )
  {
    v2 = &loc_804D680;
    if ( *name )
      v2 = &loc_804D687;
    dword_8071240 = (int)v2;
    sub_80649F8(v1, v0, v4);
  }
  return 0;
}
// 8071240: using guessed type int dword_8071240;

//----- (0804D702) --------------------------------------------------------
int __usercall sub_804D702@<eax>(_DWORD *a1@<ebx>)
{
  int result; // eax
  int v2; // ecx
  int v3; // eax
  int v4; // eax
  int v5; // edx
  int v6; // ecx
  bool v7; // zf
  void *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  signed int v12; // eax
  char *v13; // eax
  char *v14; // eax
  char *v15; // edx
  int v16; // eax
  void *v17; // eax
  signed int v18; // eax
  char *v19; // eax
  _DWORD *v20; // [esp-8h] [ebp-50h]
  int v21; // [esp-4h] [ebp-4Ch]
  int v22; // [esp+0h] [ebp-48h]
  const char *v23; // [esp+4h] [ebp-44h]
  _DWORD *v24; // [esp+Ch] [ebp-3Ch]
  int v25; // [esp+1Ch] [ebp-2Ch]
  char *s; // [esp+20h] [ebp-28h]
  void *v27; // [esp+24h] [ebp-24h]
  int v28; // [esp+28h] [ebp-20h]
  _DWORD *v29; // [esp+2Ch] [ebp-1Ch]
  int v30; // [esp+30h] [ebp-18h]
  _DWORD *v31; // [esp+34h] [ebp-14h]
  void *ptr; // [esp+38h] [ebp-10h]
  char *v33; // [esp+3Ch] [ebp-Ch]

  s = getenv("LS_COLORS");
  if ( !s || !*s )
  {
    v33 = getenv("COLORTERM");
    if ( !v33 || (result = (unsigned __int8)*v33, !(_BYTE)result) )
    {
      result = sub_804D642() ^ 1;
      if ( (_BYTE)result )
        byte_8071806 = 0;
    }
    return result;
  }
  v29 = 0;
  *(_WORD *)((char *)&v25 + 1) = 16191;
  HIBYTE(v25) = 0;
  ::ptr = sub_806139B(s);
  v27 = ::ptr;
  v30 = 1;
  while ( 2 )
  {
    switch ( v30 )
    {
      case 1:
        v3 = *s;
        if ( v3 == 42 )
        {
          v29 = sub_8061270(0x14u);
          v29[4] = dword_807180A;
          dword_807180A = (int)v29;
          ++s;
          v29[1] = v27;
          v24 = v29;
          v4 = sub_804D26F(&v22 - 9, &v22 - 10, 1);
          v7 = (_BYTE)v4 == 0;
          v21 = v4;
          v20 = a1;
          v8 = &loc_804D86F;
          if ( v7 )
            v8 = &loc_804D876;
          dword_80711F0 = (int)v8;
          a1 = v20;
          sub_8064BC6(v6, v5);
          v30 = 4;
          continue;
        }
        if ( v3 == 58 )
        {
          ++s;
          continue;
        }
        if ( *s )
        {
          v9 = s++;
          BYTE1(v25) = *v9;
          v30 = 2;
          continue;
        }
        v30 = 5;
LABEL_43:
        if ( v30 == 6 )
        {
          v19 = gettext("unparsable value for LS_COLORS environment variable");
          error(0, 0, v19);
          free(::ptr);
          v31 = (_DWORD *)dword_807180A;
          while ( v31 )
          {
            ptr = v31;
            v31 = (_DWORD *)v31[4];
            free(ptr);
          }
          byte_8071806 = 0;
        }
        result = dword_80712F4;
        if ( dword_80712F4 == 6 )
        {
          result = strncmp(off_80712F8, "target", 6u);
          if ( !result )
            byte_807179E = 1;
        }
        return result;
      case 2:
        if ( *s )
        {
          v10 = s++;
          BYTE2(v25) = *v10;
          v30 = 3;
          dword_807122C = (int)&loc_804DA92;
          sub_8064A68(v2, s);
        }
        v30 = 6;
        continue;
      case 3:
        v30 = 6;
        v11 = s++;
        if ( *v11 != 61 )
          continue;
        v28 = 0;
        while ( 2 )
        {
          if ( (&off_80660D8)[v28] )
          {
            v23 = (&off_80660D8)[v28];
            if ( strcmp((const char *)&v25 + 1, v23) )
            {
              ++v28;
              continue;
            }
            *(&s1 + 2 * v28) = v27;
            v24 = (_DWORD *)(8 * v28 + 134681276);
            if ( (unsigned __int8)sub_804D26F(&v22 - 9, &v22 - 10, 0) )
              v12 = 1;
            else
              v12 = 6;
            v30 = v12;
          }
          break;
        }
        if ( v30 == 6 )
        {
          a1 = sub_8060313((int)&v25 + 1);
          v13 = gettext("unrecognized prefix: %s");
          v24 = a1;
          error(0, 0, v13, a1);
        }
        continue;
      case 4:
        v14 = s;
        v15 = s++ + 1;
        v16 = (unsigned __int8)*v14;
        v7 = (_BYTE)v16 == 61;
        v21 = v16;
        v20 = a1;
        v17 = &loc_804DA1D;
        if ( !v7 )
          v17 = &loc_804DA6F;
        dword_8071240 = (int)v17;
        a1 = v20;
        sub_80649F8(v2, v15, v22);
        v29[3] = v27;
        v24 = v29 + 2;
        if ( (unsigned __int8)sub_804D26F(&v22 - 9, &v22 - 10, 0) )
          v18 = 1;
        else
          v18 = 6;
        v30 = v18;
        continue;
      case 6:
        goto LABEL_43;
      default:
        abort();
        return result;
    }
  }
}
// 804D26F: using guessed type _DWORD __cdecl sub_804D26F(_DWORD, _DWORD, char);
// 8064A68: using guessed type double __fastcall sub_8064A68(_DWORD, _DWORD);
// 80711F0: using guessed type int dword_80711F0;
// 807122C: using guessed type int dword_807122C;
// 8071240: using guessed type int dword_8071240;
// 80712F4: using guessed type int dword_80712F4;
// 807179E: using guessed type char byte_807179E;
// 8071806: using guessed type char byte_8071806;
// 807180A: using guessed type int dword_807180A;

//----- (0804DB37) --------------------------------------------------------
void sub_804DB37()
{
  void *v0; // ebx
  char *v1; // eax
  char *s; // [esp+18h] [ebp-10h]
  int v3; // [esp+1Ch] [ebp-Ch]

  s = getenv("QUOTING_STYLE");
  if ( s )
  {
    v3 = sub_805542F(s, (int)off_80698F8);
    if ( v3 < 0 )
    {
      v0 = sub_8060313((int)s);
      v1 = gettext("ignoring invalid value of environment variable QUOTING_STYLE: %s");
      error(0, 0, v1, v0);
    }
    else
    {
      sub_805E69B(0, dword_8069938[v3]);
    }
  }
}
// 80698F8: using guessed type char *off_80698F8[10];

//----- (0804DBD6) --------------------------------------------------------
int __cdecl sub_804DBD6(int a1)
{
  int result; // eax

  result = a1;
  if ( (_BYTE)a1 )
  {
    dword_80718EA = 2;
  }
  else
  {
    result = dword_80718EA;
    if ( !dword_80718EA )
      dword_80718EA = 1;
  }
  return result;
}
// 80718EA: using guessed type int dword_80718EA;

//----- (0804DC09) --------------------------------------------------------
int __cdecl sub_804DC09(int a1, char *format, int a3)
{
  void *v3; // ebx
  int *v4; // eax

  v3 = sub_805FE5C(4, a3);
  v4 = __errno_location();
  error(0, *v4, format, v3);
  return sub_804DBD6((unsigned __int8)a1);
}

//----- (0804DC5F) --------------------------------------------------------
_DWORD *__cdecl sub_804DC5F(char *a1, char *s, int a3)
{
  void *v3; // eax
  void *v4; // eax
  _DWORD *result; // eax
  _DWORD *v6; // [esp+1Ch] [ebp-Ch]

  v6 = sub_8061270(0x10u);
  if ( s )
    v3 = sub_806139B(s);
  else
    v3 = 0;
  v6[1] = v3;
  if ( a1 )
    v4 = sub_806139B(a1);
  else
    v4 = 0;
  *v6 = v4;
  *((_BYTE *)v6 + 8) = a3;
  v6[3] = dword_80717A6;
  result = v6;
  dword_80717A6 = (int)v6;
  return result;
}
// 80717A6: using guessed type int dword_80717A6;

//----- (0804DCE5) --------------------------------------------------------
unsigned int __usercall sub_804DCE5@<eax>(int a1@<ebx>, char *a2, int a3, unsigned __int8 a4)
{
  char *v4; // eax
  unsigned int v5; // eax
  char *v6; // eax
  void *v7; // ebx
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  int v11; // eax
  int v12; // edx
  int v13; // ecx
  bool v14; // zf
  void *v15; // eax
  __int64 v16; // rax
  int v17; // edx
  int v18; // ecx
  DIR *v20; // [esp+0h] [ebp-348h]
  int v21; // [esp+4h] [ebp-344h]
  __int64 v22; // [esp+8h] [ebp-340h]
  int v23; // [esp+10h] [ebp-338h]
  int v24; // [esp+14h] [ebp-334h]
  int v25; // [esp+18h] [ebp-330h]
  int v26; // [esp+1Ch] [ebp-32Ch]
  int v27; // [esp+20h] [ebp-328h]
  unsigned __int8 v28; // [esp+24h] [ebp-324h]
  char *v29; // [esp+28h] [ebp-320h]
  char *name; // [esp+2Ch] [ebp-31Ch]
  void *ptr; // [esp+30h] [ebp-318h]
  int v32; // [esp+34h] [ebp-314h]
  DIR *dirp; // [esp+38h] [ebp-310h]
  int v34; // [esp+3Ch] [ebp-30Ch]
  int v35; // [esp+40h] [ebp-308h]
  char *s; // [esp+44h] [ebp-304h]
  __int64 v37; // [esp+48h] [ebp-300h]
  int v38; // [esp+50h] [ebp-2F8h]
  int v39; // [esp+54h] [ebp-2F4h]
  int v40; // [esp+58h] [ebp-2F0h]
  int v41; // [esp+A8h] [ebp-2A0h]
  int v42; // [esp+ACh] [ebp-29Ch]
  unsigned int v43; // [esp+33Ch] [ebp-Ch]

  name = a2;
  v29 = (char *)a3;
  v28 = a4;
  v43 = __readgsdword(0x14u);
  v37 = 0LL;
  *__errno_location() = 0;
  dirp = opendir(name);
  if ( dirp )
  {
    if ( dword_8071782 )
    {
      v34 = dirfd(dirp);
      if ( v34 < 0 )
        v5 = (unsigned int)sub_80647DD((int)name, (int)&v38) >> 31;
      else
        v5 = (unsigned int)sub_806480C(v34, (int)&v38) >> 31;
      if ( (_BYTE)v5 )
      {
        v6 = gettext("cannot determine device and inode of %s");
        sub_804DC09(v28, v6, (int)name);
        closedir(dirp);
        return __readgsdword(0x14u) ^ v43;
      }
      if ( (unsigned __int8)sub_804B3A1(v38, v39, v41, v42) )
      {
        v7 = sub_806002C(0, 3, (int)name);
        v8 = gettext("%s: not listing already-listed directory");
        HIDWORD(v22) = v7;
        error(0, 0, v8, v7);
        closedir(dirp);
        sub_804DBD6(1);
        return __readgsdword(0x14u) ^ v43;
      }
      a1 = v42;
      sub_804AAE5(v38, v39, v41, v42);
    }
    sub_804E72F();
    if ( byte_807181A || byte_807183A )
    {
      if ( byte_8071384 != 1 )
      {
        putchar_unlocked(10);
        ++dword_80718F6;
      }
      byte_8071384 = 0;
      if ( byte_80717FE )
      {
        fwrite_unlocked("  ", 1u, 2u, stdout);
        dword_80718F6 += 2;
      }
      ptr = 0;
      if ( byte_8071807 )
      {
        ptr = (void *)sub_8055B36(name, 2);
        if ( !ptr )
        {
          v9 = gettext("error canonicalizing %s");
          sub_804DC09(v28, v9, (int)name);
        }
      }
      if ( v29 )
        v10 = v29;
      else
        v10 = name;
      sub_80531C9((int)v10, dword_8071832, -1, 0, 1, (int)&unk_8071942, (char *)ptr);
      free(ptr);
      fwrite_unlocked(":\n", 1u, 2u, stdout);
      dword_80718F6 += 2;
    }
    while ( 1 )
    {
      *__errno_location() = 0;
      v20 = dirp;
      v11 = readdir64();
      v35 = v11;
      v14 = v11 == 0;
      v15 = &loc_804E0C5;
      if ( v14 )
        v15 = &loc_804E22E;
      dword_80711DC = (int)v15;
      sub_8064C3E(v13, v12);
      if ( (unsigned __int8)sub_804E51A((char *)(v35 + 19)) ^ 1 )
      {
        v32 = 0;
        switch ( *(unsigned __int8 *)(v35 + 18) )
        {
          case 1u:
            dword_8071218 = (int)&loc_804E192;
            sub_8064ADE(
              v20,
              v21,
              v22,
              HIDWORD(v22),
              v23,
              v24,
              v25,
              v26,
              v27,
              *(_DWORD *)&v28,
              v29,
              name,
              ptr,
              1,
              dirp,
              v34,
              v35,
              s,
              v37,
              HIDWORD(v37),
              v38,
              v39,
              v40);
            goto LABEL_33;
          case 2u:
            v32 = 2;
            break;
          case 4u:
            v32 = 3;
            break;
          case 6u:
            v32 = 4;
            break;
          case 8u:
            goto LABEL_34;
          case 0xAu:
LABEL_33:
            dword_8071204 = (int)&loc_804E192;
            sub_8064B50(
              v20,
              v21,
              v22,
              HIDWORD(v22),
              v23,
              v24,
              v25,
              v26,
              v27,
              *(_DWORD *)&v28,
              v29,
              name,
              ptr,
              6,
              dirp,
              v34,
              v35,
              s,
              v37);
LABEL_34:
            v32 = 5;
            break;
          case 0xCu:
            v32 = 7;
            break;
          case 0xEu:
            v32 = 8;
            break;
          default:
            break;
        }
        LODWORD(v16) = sub_804EAF2(v35 + 19, v32, 0LL, 0, name);
        v37 += v16;
        if ( dword_80717DE == 1 && dword_80717E6 == -1 && byte_80717ED != 1 && byte_807181A != 1 )
        {
          sub_80512F3();
          sub_80514AF(v17, v18, a1);
          sub_804E72F();
        }
      }
      sub_804B5BA();
    }
  }
  v4 = gettext("cannot open directory %s");
  sub_804DC09(v28, v4, (int)name);
  return __readgsdword(0x14u) ^ v43;
}
// 8049A80: using guessed type int readdir64(void);
// 804EAF2: using guessed type _DWORD __cdecl sub_804EAF2(_DWORD, _DWORD, __int64, _DWORD, _DWORD);
// 80512F3: using guessed type int sub_80512F3(void);
// 8064ADE: using guessed type int __stdcall sub_8064ADE(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8064B50: using guessed type int __stdcall sub_8064B50(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8064C3E: using guessed type int __fastcall sub_8064C3E(_DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;
// 8071204: using guessed type int dword_8071204;
// 8071218: using guessed type int dword_8071218;
// 8071384: using guessed type char byte_8071384;
// 80717DE: using guessed type int dword_80717DE;
// 80717E6: using guessed type int dword_80717E6;
// 80717ED: using guessed type char byte_80717ED;
// 80717FE: using guessed type char byte_80717FE;
// 8071807: using guessed type char byte_8071807;
// 807181A: using guessed type char byte_807181A;
// 8071832: using guessed type int dword_8071832;
// 807183A: using guessed type char byte_807183A;
// 80718F6: using guessed type int dword_80718F6;

//----- (0804E48C) --------------------------------------------------------
_DWORD *__cdecl sub_804E48C(int a1)
{
  _DWORD *result; // eax

  result = sub_8061270(8u);
  *result = a1;
  result[1] = dword_8071822;
  dword_8071822 = (int)result;
  return result;
}

//----- (0804E4CF) --------------------------------------------------------
int __cdecl sub_804E4CF(int a1, char *name)
{
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = a1; i; i = *(_DWORD *)(i + 4) )
  {
    if ( !fnmatch(*(const char **)i, name, 4) )
      return 1;
  }
  return 0;
}

//----- (0804E51A) --------------------------------------------------------
#error "804E5A2: call analysis failed (funcsize=46)"

//----- (0804E5BF) --------------------------------------------------------
#error "804E621: call analysis failed (funcsize=51)"

//----- (0804E67E) --------------------------------------------------------
#error "804E687: positive sp value has been found (funcsize=0)"

//----- (0804E688) --------------------------------------------------------
int __cdecl sub_804E688(int a1)
{
  return a1;
}

//----- (0804E6B2) --------------------------------------------------------
int sub_804E6B2()
{
  *__errno_location() = 95;
  return 0;
}

//----- (0804E6CA) --------------------------------------------------------
void __cdecl sub_804E6CA(void **a1)
{
  void *v1; // ST00_4

  free(*a1);
  free(a1[1]);
  free(a1[2]);
  if ( a1[29] != &unk_807129C )
  {
    if ( (unsigned __int8)sub_804AADB() )
    {
      free(a1[29]);
    }
    else
    {
      v1 = a1[29];
      sub_806052E();
    }
  }
}

//----- (0804E72F) --------------------------------------------------------
int sub_804E72F()
{
  int result; // eax
  unsigned int i; // [esp+18h] [ebp-10h]

  for ( i = 0; ; ++i )
  {
    result = dword_807178E;
    if ( i >= dword_807178E )
      break;
    sub_804E6CA(*((void ***)dword_8071796 + i));
  }
  dword_807178E = 0;
  byte_8071792 = 0;
  byte_80717B3 = 0;
  dword_80717B6 = 0;
  dword_80717BA = 0;
  dword_80717BE = 0;
  dword_80717C6 = 0;
  dword_80717CA = 0;
  dword_80717CE = 0;
  dword_80717C2 = 0;
  dword_80717D2 = 0;
  dword_80717D6 = 0;
  dword_80717DA = 0;
  return result;
}
// 807178E: using guessed type int dword_807178E;
// 8071792: using guessed type char byte_8071792;
// 80717B3: using guessed type char byte_80717B3;
// 80717B6: using guessed type int dword_80717B6;
// 80717BA: using guessed type int dword_80717BA;
// 80717BE: using guessed type int dword_80717BE;
// 80717C2: using guessed type int dword_80717C2;
// 80717C6: using guessed type int dword_80717C6;
// 80717CA: using guessed type int dword_80717CA;
// 80717CE: using guessed type int dword_80717CE;
// 80717D2: using guessed type int dword_80717D2;
// 80717D6: using guessed type int dword_80717D6;
// 80717DA: using guessed type int dword_80717DA;

//----- (0804E807) --------------------------------------------------------
#error "804E83B: call analysis failed (funcsize=23)"

//----- (0804E84E) --------------------------------------------------------
signed int __cdecl sub_804E84E(int a1, int a2, char a3)
{
  signed int result; // eax
  signed int v4; // eax
  int *v5; // eax
  int v6; // edx
  signed int v7; // [esp+10h] [ebp-Ch]

  if ( *(_QWORD *)(a2 + 12) == qword_8072782 )
  {
    *__errno_location() = 95;
    result = -1;
  }
  else
  {
    if ( a3 )
      v4 = sub_806057B();
    else
      v4 = sub_8060593();
    v7 = v4;
    if ( v4 < 0 )
    {
      v5 = __errno_location();
      if ( (unsigned __int8)sub_804E807(*v5) )
      {
        v6 = *(_DWORD *)(a2 + 16);
        LODWORD(qword_8072782) = *(_DWORD *)(a2 + 12);
        HIDWORD(qword_8072782) = v6;
      }
    }
    result = v7;
  }
  return result;
}
// 804E807: using guessed type _DWORD __cdecl sub_804E807(_DWORD);
// 8072782: using guessed type __int64 qword_8072782;

//----- (0804E921) --------------------------------------------------------
int __cdecl sub_804E921(int a1, int a2)
{
  int result; // eax
  int *v3; // eax
  int v4; // edx
  int v5; // [esp+1Ch] [ebp-Ch]

  if ( *(_QWORD *)(a2 + 12) == qword_807278A )
  {
    *__errno_location() = 95;
    result = 0;
  }
  else
  {
    *__errno_location() = 0;
    v5 = sub_80567E5();
    if ( v5 <= 0 )
    {
      v3 = __errno_location();
      if ( (unsigned __int8)sub_804E807(*v3) )
      {
        v4 = *(_DWORD *)(a2 + 16);
        LODWORD(qword_807278A) = *(_DWORD *)(a2 + 12);
        HIDWORD(qword_807278A) = v4;
      }
    }
    result = v5;
  }
  return result;
}
// 804E807: using guessed type _DWORD __cdecl sub_804E807(_DWORD);
// 8072782: using guessed type __int64 qword_8072782;
// 807278A: using guessed type __int64 qword_807278A;

//----- (0804E9C5) --------------------------------------------------------
int __cdecl sub_804E9C5(int a1, int a2)
{
  int v2; // edx
  int v3; // ecx
  int *v4; // eax
  int v5; // edx
  unsigned __int8 v7; // [esp+1h] [ebp-9h]

  if ( *(_QWORD *)(a2 + 12) == qword_8072792 )
  {
    *__errno_location() = 95;
    dword_80711F0 = (int)&loc_804EA78;
    sub_8064BC6(v3, v2);
  }
  v7 = sub_804E6B2();
  if ( v7 ^ 1 )
  {
    v4 = __errno_location();
    if ( (unsigned __int8)sub_804E807(*v4) )
    {
      v5 = *(_DWORD *)(a2 + 16);
      LODWORD(qword_8072792) = *(_DWORD *)(a2 + 12);
      HIDWORD(qword_8072792) = v5;
    }
  }
  return v7;
}
// 804E807: using guessed type _DWORD __cdecl sub_804E807(_DWORD);
// 80711F0: using guessed type int dword_80711F0;
// 807278A: using guessed type __int64 qword_807278A;
// 8072792: using guessed type __int64 qword_8072792;

//----- (0804EA7F) --------------------------------------------------------
_BOOL4 __cdecl sub_804EA7F(char *s)
{
  size_t v1; // eax
  bool v2; // al
  int v4; // [esp+0h] [ebp-38h]
  char v5; // [esp+2Ah] [ebp-Eh]
  int v6; // [esp+2Ch] [ebp-Ch]

  v6 = sub_805F79D((int)&v4 - 14, 2, (int)s, -1, (int *)dword_807182E);
  v2 = 1;
  if ( *s == v5 )
  {
    v1 = strlen(s);
    if ( v1 == v6 )
      v2 = 0;
  }
  return v2;
}
// 807182E: using guessed type int dword_807182E;

//----- (0804EAF2) --------------------------------------------------------
#error "804FA36: call analysis failed (funcsize=910)"

//----- (0804FB16) --------------------------------------------------------
int __cdecl sub_804FB16(int a1)
{
  int v1; // eax
  int v2; // eax

  v1 = *(_DWORD *)(a1 + 108);
  dword_8071268 = (int (__cdecl *)(_DWORD))&loc_804FB53;
  if ( v1 != 3 )
  {
    v2 = *(_DWORD *)(a1 + 108);
    dword_8071268 = (int (__cdecl *)(_DWORD))sub_804FB6B;
    if ( v2 == 9 )
      dword_8071268 = (int (__cdecl *)(_DWORD))&loc_804FB70;
  }
  return dword_8071268(a1);
}
// 804FB6B: using guessed type int sub_804FB6B();
// 8071268: using guessed type int (__cdecl *dword_8071268)(_DWORD);

//----- (0804FB6B) --------------------------------------------------------
#error "804FB74: positive sp value has been found (funcsize=0)"

//----- (0804FB75) --------------------------------------------------------
int __cdecl sub_804FB75(char *path, int a2, int a3)
{
  int v3; // edx
  int result; // eax
  char *v5; // eax

  v3 = *(_DWORD *)(a2 + 60);
  *(_DWORD *)(a2 + 4) = sub_80552EE(path, *(_DWORD *)(a2 + 56));
  result = *(_DWORD *)(a2 + 4);
  if ( !result )
  {
    v5 = gettext("cannot read symbolic link %s");
    result = sub_804DC09((unsigned __int8)a3, v5, (int)path);
  }
  return result;
}

//----- (0804FBDE) --------------------------------------------------------
void *__usercall sub_804FBDE@<eax>(int a1@<edx>, int a2@<ecx>, int a3, char *s)
{
  size_t v5; // eax
  char *v6; // eax
  _BYTE *v7; // [esp+18h] [ebp-10h]
  void *v8; // [esp+1Ch] [ebp-Ch]

  if ( !s )
    return 0;
  if ( *s == 47 )
    return sub_806139B(s);
  v7 = sub_805660E(a1, a2, (_BYTE *)a3);
  if ( !v7 )
    return sub_806139B(s);
  v5 = strlen(s);
  v8 = sub_8061270((size_t)&v7[v5 + 2]);
  if ( v7[a3 - 1] != 47 )
    ++v7;
  v6 = (char *)stpncpy(v8, a3, v7);
  strcpy(v6, s);
  return v8;
}
// 8049980: using guessed type int __cdecl stpncpy(_DWORD, _DWORD, _DWORD);

//----- (0804FC90) --------------------------------------------------------
_BOOL4 __usercall sub_804FC90@<eax>(int a1@<edx>, int a2@<ecx>, _BYTE *a3)
{
  _BYTE *v3; // ST1C_4
  int v4; // edx
  int v5; // ecx

  v3 = sub_8056733(a1, a2, a3);
  return sub_804A7DB(v4, v5, v3);
}

//----- (0804FCB1) --------------------------------------------------------
#error "804FD07: call analysis failed (funcsize=152)"

//----- (0804FEC6) --------------------------------------------------------
void __cdecl __noreturn sub_804FEC6(char *s1, char *s2)
{
  bool v2; // zf
  int v3; // edx
  int v4; // ecx
  int (*v5)(); // eax
  void *v6; // edi
  void *v7; // esi
  char *v8; // ebx
  int *v9; // eax

  *__errno_location() = 0;
  strcoll(s1, s2);
  v2 = *__errno_location() == 0;
  v5 = (int (*)())&loc_804FF13;
  if ( v2 )
    v5 = sub_804FF8E;
  dword_80711F0 = (int)v5;
  sub_8064BC6(v4, v3);
  v6 = sub_80602F1(1, (int)s2);
  v7 = sub_80602F1(0, (int)s1);
  v8 = gettext("cannot compare file names %s and %s");
  v9 = __errno_location();
  error(0, *v9, v8, v7, v6);
  sub_804DBD6(0);
  longjmp(env, 1);
}
// 804FF8E: using guessed type int sub_804FF8E();
// 80711F0: using guessed type int dword_80711F0;

//----- (0804FF8E) --------------------------------------------------------
#error "804FF94: positive sp value has been found (funcsize=0)"

//----- (0804FF99) --------------------------------------------------------
int __cdecl sub_804FF99(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD))
{
  int result; // eax
  int v4; // [esp+1Ch] [ebp-1Ch]
  int v5; // [esp+20h] [ebp-18h]
  int v6; // [esp+24h] [ebp-14h]
  int v7; // [esp+28h] [ebp-10h]
  int v8; // [esp+2Ch] [ebp-Ch]

  sub_80606F8(&v5, (int)(a1 + 3));
  sub_80606F8(&v7, (int)(a2 + 3));
  v4 = sub_80607EE(v7, v8, v5, v6);
  if ( v4 )
    result = v4;
  else
    result = a3(*a1, *a2);
  return result;
}
// 80607EE: using guessed type _DWORD __cdecl sub_80607EE(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08050015) --------------------------------------------------------
int __cdecl sub_8050015(_DWORD *a1, _DWORD *a2, void (__cdecl *a3)(_DWORD, _DWORD))
{
  int v3; // edx
  int v4; // ecx
  int v6; // [esp+1Ch] [ebp-1Ch]
  int v7; // [esp+20h] [ebp-18h]
  int v8; // [esp+24h] [ebp-14h]
  int v9; // [esp+28h] [ebp-10h]
  int v10; // [esp+2Ch] [ebp-Ch]

  sub_8060733(&v7, (int)(a1 + 3));
  sub_8060733(&v9, (int)(a2 + 3));
  v6 = sub_80607EE(v9, v10, v7, v8);
  if ( !v6 )
  {
    a3(*a1, *a2);
    dword_807122C = (int)&locret_80500A4;
    sub_8064A68(v4, v3);
  }
  return v6;
}
// 80607EE: using guessed type _DWORD __cdecl sub_80607EE(_DWORD, _DWORD, _DWORD, _DWORD);
// 8064A68: using guessed type double __fastcall sub_8064A68(_DWORD, _DWORD);
// 807122C: using guessed type int dword_807122C;

//----- (080500A6) --------------------------------------------------------
int __cdecl sub_80500A6(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD))
{
  int result; // eax
  int v4; // [esp+1Ch] [ebp-1Ch]
  int v5; // [esp+20h] [ebp-18h]
  int v6; // [esp+24h] [ebp-14h]
  int v7; // [esp+28h] [ebp-10h]
  int v8; // [esp+2Ch] [ebp-Ch]

  sub_80606CD(&v5, (int)(a1 + 3));
  sub_80606CD(&v7, (int)(a2 + 3));
  v4 = sub_80607EE(v7, v8, v5, v6);
  if ( v4 )
    result = v4;
  else
    result = a3(*a1, *a2);
  return result;
}
// 80607EE: using guessed type _DWORD __cdecl sub_80607EE(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08050122) --------------------------------------------------------
int __cdecl sub_8050122(int *a1, int *a2, int (__fastcall *a3)(_DWORD))
{
  __int64 v3; // rcx
  __int64 v4; // rax
  __int64 v5; // rax
  unsigned __int8 v6; // si
  signed int v7; // eax
  int v8; // eax
  int v10; // [esp+0h] [ebp-28h]
  int v11; // [esp+4h] [ebp-24h]
  int v12; // [esp+1Ch] [ebp-Ch]

  LODWORD(v3) = a2[14];
  LODWORD(v4) = a1[14];
  HIDWORD(v3) = a2[15];
  HIDWORD(v4) = a1[15];
  if ( v3 < v4 )
  {
    v7 = -1;
  }
  else
  {
    LODWORD(v3) = a2[14];
    v6 = 1;
    LODWORD(v5) = a1[14];
    HIDWORD(v3) = a2[15];
    HIDWORD(v5) = a1[15];
    if ( v3 <= v5 )
      v6 = 0;
    v7 = v6;
  }
  v12 = v7;
  if ( v7 )
    return v12;
  v8 = *a1;
  v11 = *a2;
  v10 = v8;
  return a3(v3);
}

//----- (080501B7) --------------------------------------------------------
int __cdecl sub_80501B7(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD))
{
  return a3(*a1, *a2);
}

//----- (080501E5) --------------------------------------------------------
int __cdecl sub_80501E5(const char **a1, const char **a2, int (__cdecl *a3)(char *, char *))
{
  char *v3; // edx
  char *v4; // eax
  int result; // eax
  char *v6; // [esp+14h] [ebp-14h]
  char *v7; // [esp+18h] [ebp-10h]
  int v8; // [esp+1Ch] [ebp-Ch]

  v6 = strrchr(*a1, 46);
  v7 = strrchr(*a2, 46);
  if ( v7 )
    v3 = v7;
  else
    v3 = &locale;
  if ( v6 )
    v4 = v6;
  else
    v4 = &locale;
  v8 = a3(v4, v3);
  if ( v8 )
    result = v8;
  else
    result = a3((char *)*a1, (char *)*a2);
  return result;
}

//----- (080509A6) --------------------------------------------------------
int __cdecl sub_80509A6(int *a1, int *a2)
{
  return sub_8050122(a1, a2, (int (__fastcall *)(_DWORD))sub_804FEC6);
}

//----- (080509C8) --------------------------------------------------------
int __cdecl sub_80509C8(int *a1, int *a2)
{
  return sub_8050122(a1, a2, (int (__fastcall *)(_DWORD))strcmp);
}

//----- (080509EA) --------------------------------------------------------
int __cdecl sub_80509EA(int *a1, int *a2)
{
  return sub_8050122(a2, a1, (int (__fastcall *)(_DWORD))sub_804FEC6);
}

//----- (08050A0C) --------------------------------------------------------
int __cdecl sub_8050A0C(int *a1, int *a2)
{
  return sub_8050122(a2, a1, (int (__fastcall *)(_DWORD))strcmp);
}

//----- (08050A2E) --------------------------------------------------------
int __cdecl sub_8050A2E(int *a1, int *a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_804FB16((int)a1);
  v4 = sub_804FB16((int)a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_8050122(a1, a2, (int (__fastcall *)(_DWORD))sub_804FEC6);
}

//----- (08050A9C) --------------------------------------------------------
#error "8050AFC: call analysis failed (funcsize=37)"

//----- (08050B3C) --------------------------------------------------------
int __cdecl sub_8050B3C(int *a1, int *a2)
{
  int v2; // edx
  int v3; // ecx
  int result; // eax
  char v5; // [esp+1Eh] [ebp-Ah]
  char v6; // [esp+1Fh] [ebp-9h]

  v5 = sub_804FB16((int)a1);
  v6 = sub_804FB16((int)a2);
  if ( v5 && v6 != 1 )
  {
    dword_80711F0 = (int)&locret_8050BBD;
    sub_8064BC6(v3, v2);
  }
  if ( v5 != 1 && v6 )
    result = 1;
  else
    result = sub_8050122(a2, a1, (int (__fastcall *)(_DWORD))sub_804FEC6);
  return result;
}
// 80711F0: using guessed type int dword_80711F0;

//----- (08050BBF) --------------------------------------------------------
#error "8050C06: call analysis failed (funcsize=51)"

//----- (08050C5F) --------------------------------------------------------
int __cdecl sub_8050C5F(_DWORD *a1, _DWORD *a2)
{
  return sub_80501B7(a1, a2, (int (__cdecl *)(_DWORD, _DWORD))sub_804FEC6);
}

//----- (08050C81) --------------------------------------------------------
int __cdecl sub_8050C81(_DWORD *a1, _DWORD *a2)
{
  return sub_80501B7(a1, a2, (int (__cdecl *)(_DWORD, _DWORD))strcmp);
}

//----- (08050CA3) --------------------------------------------------------
int __cdecl sub_8050CA3(_DWORD *a1, _DWORD *a2)
{
  return sub_80501B7(a2, a1, (int (__cdecl *)(_DWORD, _DWORD))sub_804FEC6);
}

//----- (08050CC5) --------------------------------------------------------
int __cdecl sub_8050CC5(_DWORD *a1, _DWORD *a2)
{
  return sub_80501B7(a2, a1, (int (__cdecl *)(_DWORD, _DWORD))strcmp);
}

//----- (08050CE7) --------------------------------------------------------
int __cdecl sub_8050CE7(_DWORD *a1, _DWORD *a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_804FB16((int)a1);
  v4 = sub_804FB16((int)a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_80501B7(a1, a2, (int (__cdecl *)(_DWORD, _DWORD))sub_804FEC6);
}

//----- (08050D55) --------------------------------------------------------
#error "8050D9B: call analysis failed (funcsize=53)"

//----- (08050E06) --------------------------------------------------------
int __cdecl sub_8050E06(_DWORD *a1, _DWORD *a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_804FB16((int)a1);
  v4 = sub_804FB16((int)a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_80501B7(a2, a1, (int (__cdecl *)(_DWORD, _DWORD))sub_804FEC6);
}

//----- (08050E74) --------------------------------------------------------
int __cdecl sub_8050E74(_DWORD *a1, _DWORD *a2)
{
  int v2; // edx
  int v3; // ecx
  void *v4; // eax
  char v6; // [esp+1Eh] [ebp-Ah]
  char v7; // [esp+1Fh] [ebp-9h]

  v6 = sub_804FB16((int)a1);
  v7 = sub_804FB16((int)a2);
  v4 = &loc_8050EB5;
  if ( !v6 )
    v4 = &loc_8050EC7;
  dword_80711DC = (int)v4;
  sub_8064C3E(v3, v2);
  if ( v7 != 1 )
    return -1;
  if ( v6 == 1 )
    return sub_80501B7(a2, a1, (int (__cdecl *)(_DWORD, _DWORD))strcmp);
  return 1;
}
// 8064C3E: using guessed type int __fastcall sub_8064C3E(_DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;

//----- (08050EFB) --------------------------------------------------------
int __cdecl sub_8050EFB(const char **a1, const char **a2)
{
  return sub_80501E5(a1, a2, (int (__cdecl *)(char *, char *))sub_804FEC6);
}

//----- (08050F1D) --------------------------------------------------------
int __cdecl sub_8050F1D(const char **a1, const char **a2)
{
  return sub_80501E5(a1, a2, (int (__cdecl *)(char *, char *))strcmp);
}

//----- (08050F3F) --------------------------------------------------------
int __cdecl sub_8050F3F(const char **a1, const char **a2)
{
  return sub_80501E5(a2, a1, (int (__cdecl *)(char *, char *))sub_804FEC6);
}

//----- (08050F61) --------------------------------------------------------
int __cdecl sub_8050F61(const char **a1, const char **a2)
{
  return sub_80501E5(a2, a1, (int (__cdecl *)(char *, char *))strcmp);
}

//----- (08050F83) --------------------------------------------------------
int __cdecl sub_8050F83(const char **a1, const char **a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_804FB16((int)a1);
  v4 = sub_804FB16((int)a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_80501E5(a1, a2, (int (__cdecl *)(char *, char *))sub_804FEC6);
}

//----- (08050FF1) --------------------------------------------------------
int __cdecl sub_8050FF1(const char **a1, const char **a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_804FB16((int)a1);
  v4 = sub_804FB16((int)a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_80501E5(a1, a2, (int (__cdecl *)(char *, char *))strcmp);
}

//----- (0805105F) --------------------------------------------------------
int __cdecl sub_805105F(const char **a1, const char **a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_804FB16((int)a1);
  v4 = sub_804FB16((int)a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_80501E5(a2, a1, (int (__cdecl *)(char *, char *))sub_804FEC6);
}

//----- (080510CD) --------------------------------------------------------
int __cdecl sub_80510CD(const char **a1, const char **a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_804FB16((int)a1);
  v4 = sub_804FB16((int)a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_80501E5(a2, a1, (int (__cdecl *)(char *, char *))strcmp);
}

//----- (0805113B) --------------------------------------------------------
int __cdecl sub_805113B(char **a1, char **a2)
{
  return sub_805710B(*a1, *a2);
}

//----- (08051159) --------------------------------------------------------
int __cdecl sub_8051159(char **a1, char **a2)
{
  return sub_805113B(a1, a2);
}

//----- (08051173) --------------------------------------------------------
int __cdecl sub_8051173(char **a1, char **a2)
{
  return sub_805113B(a2, a1);
}

//----- (0805118D) --------------------------------------------------------
int __cdecl sub_805118D(char **a1, char **a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_804FB16((int)a1);
  v4 = sub_804FB16((int)a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_805113B(a1, a2);
}

//----- (080511F3) --------------------------------------------------------
#error "805123A: call analysis failed (funcsize=50)"

//----- (0805128B) --------------------------------------------------------
int sub_805128B()
{
  int result; // eax
  unsigned int i; // [esp+Ch] [ebp-8h]

  for ( i = 0; ; ++i )
  {
    result = dword_807178E;
    if ( i >= dword_807178E )
      break;
    *((_DWORD *)dword_8071796 + i) = (char *)dword_8071786 + 136 * i;
  }
  return result;
}
// 807178E: using guessed type int dword_807178E;

//----- (080512F3) --------------------------------------------------------
#error "8051305: call analysis failed (funcsize=13)"

//----- (08051318) --------------------------------------------------------
void sub_8051318()
{
  int v0; // edx
  int v1; // ecx
  void *v2; // eax

  if ( dword_807178E + ((unsigned int)dword_807178E >> 1) > dword_807179A )
  {
    free(dword_8071796);
    dword_8071796 = sub_8061163(dword_807178E, 0xCu);
    dword_807179A = 3 * dword_807178E;
  }
  sub_805128B();
  v2 = &loc_80513A8;
  if ( dword_80717E6 != -1 )
    v2 = &loc_80513AD;
  dword_807122C = (int)v2;
  sub_8064A68(v1, v0);
}
// 8051318: could not find valid save-restore pair for ebx
// 8051318: could not find valid save-restore pair for ebp
// 8064A68: using guessed type double __fastcall sub_8064A68(_DWORD, _DWORD);
// 807122C: using guessed type int dword_807122C;
// 807178E: using guessed type int dword_807178E;
// 807179A: using guessed type int dword_807179A;
// 80717E6: using guessed type int dword_80717E6;

//----- (080514AF) --------------------------------------------------------
int __usercall sub_80514AF@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>)
{
  int result; // eax
  void *v4; // eax
  int v5; // ecx
  unsigned int j; // [esp+1Ch] [ebp-Ch]
  unsigned int i; // [esp+1Ch] [ebp-Ch]

  result = dword_80717DE;
  switch ( dword_80717DE )
  {
    case 0:
      for ( i = 0; ; ++i )
      {
        result = dword_807178E;
        if ( i >= dword_807178E )
          break;
        sub_804B542();
        sub_8051A16(4 * i, v5, a3, *((_DWORD *)dword_8071796 + i));
        putchar_unlocked(10);
        ++dword_80718F6;
      }
      break;
    case 1:
      for ( j = 0; ; ++j )
      {
        result = dword_807178E;
        if ( j >= dword_807178E )
          break;
        sub_80539C9(*((_DWORD *)dword_8071796 + j), 0);
        putchar_unlocked(10);
      }
      break;
    case 2:
      if ( dword_807183E )
        result = sub_8054540();
      else
        result = sub_805481B(32);
      break;
    case 3:
      v4 = &loc_8051559;
      if ( dword_807183E )
        v4 = &loc_8051567;
      dword_80711DC = (int)v4;
      sub_8064C3E(a2, a1);
      result = sub_805481B(32);
      break;
    case 4:
      result = sub_805481B(44);
      break;
    default:
      return result;
  }
  return result;
}
// 80539C9: using guessed type _DWORD __cdecl sub_80539C9(_DWORD, _DWORD);
// 8064C3E: using guessed type int __fastcall sub_8064C3E(_DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;
// 807178E: using guessed type int dword_807178E;
// 80717DE: using guessed type int dword_80717DE;
// 807183E: using guessed type int dword_807183E;
// 80718F6: using guessed type int dword_80718F6;

//----- (080515CA) --------------------------------------------------------
#error "80515F5: call analysis failed (funcsize=49)"

//----- (08051677) --------------------------------------------------------
int __usercall sub_8051677@<eax>(int a1@<ebx>)
{
  time_t timer; // [esp+2Ch] [ebp-42Ch]
  int v3; // [esp+30h] [ebp-428h]
  struct tm tp; // [esp+34h] [ebp-424h]
  char v5; // [esp+63h] [ebp-3F5h]
  unsigned int v6; // [esp+44Ch] [ebp-Ch]

  v6 = __readgsdword(0x14u);
  if ( dword_8071388 < 0 )
  {
    timer = 0;
    if ( sub_8062F80(dword_8071842, &timer, &tp) )
    {
      v3 = sub_80515CA(&v5, 1001, 0, &tp, dword_8071842, 0);
      if ( v3 )
        sub_805AE66(a1, &v5, v3, 0);
    }
    if ( dword_8071388 < 0 )
      dword_8071388 = 0;
  }
  return dword_8071388;
}
// 80515CA: using guessed type _DWORD __cdecl sub_80515CA(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8071388: using guessed type int dword_8071388;

//----- (0805175F) --------------------------------------------------------
int __usercall sub_805175F@<eax>(int a1@<ebx>, char *s, int a3, int a4)
{
  int result; // eax

  if ( s )
    sub_805AE3D(a1, s, 0);
  printf("%*lu ", a4, a3);
  result = dword_80718F6 + a4 + 1;
  dword_80718F6 += a4 + 1;
  return result;
}
// 80718F6: using guessed type int dword_80718F6;

//----- (0805181F) --------------------------------------------------------
int __usercall sub_805181F@<eax>(int a1@<ebx>, __uid_t uid, int a3, int a4)
{
  char *v4; // eax

  if ( (_BYTE)a4 == 1 )
  {
    if ( byte_80717EC )
      v4 = 0;
    else
      v4 = sub_805A213(uid);
  }
  else
  {
    v4 = "?";
  }
  return sub_805175F(a1, v4, uid, a3);
}
// 80717EC: using guessed type char byte_80717EC;

//----- (08051872) --------------------------------------------------------
int __usercall sub_8051872@<eax>(int a1@<ebx>, __gid_t gid, int a3, int a4)
{
  char *v4; // eax

  if ( (_BYTE)a4 == 1 )
  {
    if ( byte_80717EC )
      v4 = 0;
    else
      v4 = (char *)sub_805A41D(gid);
  }
  else
  {
    v4 = "?";
  }
  return sub_805175F(a1, v4, gid, a3);
}
// 80717EC: using guessed type char byte_80717EC;

//----- (080518C5) --------------------------------------------------------
size_t __usercall sub_80518C5@<eax>(int a1@<ebx>, char *a2, int a3)
{
  char s; // [esp+21h] [ebp-17h]
  unsigned int v5; // [esp+2Ch] [ebp-Ch]

  v5 = __readgsdword(0x14u);
  if ( a2 )
    sub_805AE3D(a1, a2, 0);
  sprintf(&s, "%lu", a3);
  return strlen(&s);
}

//----- (0805193F) --------------------------------------------------------
size_t __usercall sub_805193F@<eax>(int a1@<ebx>, __uid_t uid)
{
  char *v2; // eax

  if ( byte_80717EC )
    v2 = 0;
  else
    v2 = sub_805A213(uid);
  return sub_80518C5(a1, v2, uid);
}
// 80717EC: using guessed type char byte_80717EC;

//----- (08051973) --------------------------------------------------------
size_t __usercall sub_8051973@<eax>(int a1@<ebx>, __gid_t gid)
{
  char *v2; // eax

  if ( byte_80717EC )
    v2 = 0;
  else
    v2 = (char *)sub_805A41D(gid);
  return sub_80518C5(a1, v2, gid);
}
// 80717EC: using guessed type char byte_80717EC;

//----- (080519A7) --------------------------------------------------------
const char *__cdecl sub_80519A7(int a1, unsigned int a2, int a3)
{
  const char *result; // eax

  if ( a2 <= 0x14 )
    __assert_fail("INT_BUFSIZE_BOUND (uintmax_t) <= buflen", "src/ls.c", 0xFA7u, "format_inode");
  if ( *(_BYTE *)(a3 + 120) && *(_QWORD *)(a3 + 100) )
    result = (const char *)sub_805A77E(*(_DWORD *)(a3 + 100), *(_DWORD *)(a3 + 104), a1);
  else
    result = "?";
  return result;
}
// 805A77E: using guessed type _DWORD __cdecl sub_805A77E(_DWORD, _DWORD, _DWORD);

//----- (08051A16) --------------------------------------------------------
int __usercall sub_8051A16@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, int a4)
{
  bool v4; // zf
  void *v5; // eax
  char v7; // [esp+68h] [ebp-1104h]
  unsigned int v8; // [esp+1150h] [ebp-1Ch]
  int v9; // [esp+1160h] [ebp-Ch]

  v9 = a3;
  v8 = __readgsdword(0x14u);
  v4 = *(_BYTE *)(a4 + 120) == 0;
  dword_8071268 = (int (__cdecl *)(_DWORD))sub_8051AB9;
  v5 = &loc_8051A8B;
  if ( v4 )
    v5 = &loc_8060142;
  dword_807122C = (int)v5;
  sub_8064A68(a2, a1);
  sub_8056BBF(a4 + 12, (int)&v7);
  dword_8071268 = (int (__cdecl *)(_DWORD))&loc_8051AF7;
  return ((int (__cdecl *)(int))loc_8051AF7)(a4);
}
// 8064A68: using guessed type double __fastcall sub_8064A68(_DWORD, _DWORD);
// 807122C: using guessed type int dword_807122C;
// 8071268: using guessed type int (__cdecl *dword_8071268)(_DWORD);

//----- (08051AB9) --------------------------------------------------------
#error "8051AEB: call analysis failed (funcsize=26)"

//----- (08051B31) --------------------------------------------------------
int __usercall sub_8051B31@<eax>(int a1@<ebp>, int a2)
{
  int v2; // eax
  int _0; // [esp+0h] [ebp+0h]

  v2 = *(_DWORD *)(*(_DWORD *)(a1 - 4460) + 124);
  dword_8071268 = (int (__cdecl *)(_DWORD))sub_8051B6B;
  if ( v2 == 1 )
  {
    *((_BYTE *)&_0 - 4346) = 46;
    dword_8071268 = (int (__cdecl *)(_DWORD))&loc_8051BA7;
  }
  return dword_8071268(a2);
}
// 8071268: using guessed type int (__cdecl *dword_8071268)(_DWORD);

//----- (08051B6B) --------------------------------------------------------
int __usercall sub_8051B6B@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebp>, int a4)
{
  int v4; // eax
  bool v5; // zf
  void *v6; // eax
  int v8; // [esp-4h] [ebp-4h]
  int _0; // [esp+0h] [ebp+0h]

  v4 = *(_DWORD *)(*(_DWORD *)(a3 - 4460) + 124);
  v5 = v4 == 2;
  dword_8071268 = (int (__cdecl *)(_DWORD))&loc_8051BA7;
  v8 = v4;
  v6 = &loc_8051BA0;
  if ( !v5 )
    v6 = &loc_8060142;
  dword_807122C = (int)v6;
  sub_8064A68(a2, a1);
  *((_BYTE *)&_0 - 4346) = 43;
  dword_8071268 = sub_8051C04;
  if ( dword_80717E2 != 1 )
  {
    dword_8071268 = sub_8051C4D;
    if ( (unsigned int)dword_80717E2 >= 1 )
    {
      dword_8071268 = sub_8051C96;
      if ( dword_80717E2 != 2 )
        dword_8071268 = (int (__cdecl *)(_DWORD))j__abort;
    }
  }
  return dword_8071268(a4);
}
// 8051C04: using guessed type int __cdecl sub_8051C04(int);
// 8051C4D: using guessed type int __cdecl sub_8051C4D(int);
// 8051C96: using guessed type int __cdecl sub_8051C96(int);
// 8064A68: using guessed type double __fastcall sub_8064A68(_DWORD, _DWORD);
// 807122C: using guessed type int dword_807122C;
// 8071268: using guessed type int (__cdecl *dword_8071268)(_DWORD);
// 80717E2: using guessed type int dword_80717E2;

//----- (08051C04) --------------------------------------------------------
#error "8051C1F: positive sp value has been found (funcsize=6)"

//----- (08051C4D) --------------------------------------------------------
#error "8051C68: positive sp value has been found (funcsize=6)"

//----- (08051C96) --------------------------------------------------------
#error "8051CB1: positive sp value has been found (funcsize=6)"

//----- (08051CE4) --------------------------------------------------------
#error "8051D28: call analysis failed (funcsize=47)"

//----- (08051DBD) --------------------------------------------------------
#error "8051E28: call analysis failed (funcsize=28)"

//----- (08052ABB) --------------------------------------------------------
#error "8052AFA: call analysis failed (funcsize=24)"

//----- (08052AFF) --------------------------------------------------------
#error "8052FDD: positive sp value has been found (funcsize=329)"

//----- (08052FE1) --------------------------------------------------------
int __cdecl sub_8052FE1(void *a1, int a2, int a3)
{
  int v4; // [esp+0h] [ebp-2048h]
  int v5; // [esp+28h] [ebp-2020h]
  void *v6; // [esp+2Ch] [ebp-201Ch]
  unsigned __int8 v7; // [esp+33h] [ebp-2015h]
  void *ptr; // [esp+34h] [ebp-2014h]
  int v9; // [esp+38h] [ebp-2010h]
  char v10; // [esp+3Ch] [ebp-200Ch]
  unsigned int v11; // [esp+203Ch] [ebp-Ch]

  v6 = a1;
  v5 = a2;
  v11 = __readgsdword(0x14u);
  ptr = &v10;
  sub_8052ABB(&v4 - 2053, 0x2000, a1, a2, a3, &v9, &v7);
  if ( ptr != &v10 && ptr != v6 )
    free(ptr);
  return v7 + v9;
}
// 8052ABB: using guessed type _DWORD __cdecl sub_8052ABB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (080530D5) --------------------------------------------------------
char *__cdecl sub_80530D5(char *s, int a2)
{
  size_t v2; // eax
  char *v3; // ecx
  char *v4; // eax
  char *v5; // edx
  char *v6; // eax
  char *v7; // edx
  char *v8; // eax
  unsigned __int8 v9; // al
  int v10; // eax
  int v12; // [esp+0h] [ebp-28h]
  int v13; // [esp+8h] [ebp-20h]
  char v14; // [esp+Ch] [ebp-1Ch]
  char *v15; // [esp+18h] [ebp-10h]
  char *v16; // [esp+1Ch] [ebp-Ch]

  v14 = a2;
  v2 = strlen(s);
  v16 = (char *)sub_8061163(3u, v2 + 1);
  v15 = v16;
  while ( *s )
  {
    if ( v14 && *s == 47 )
    {
      v4 = v15++;
      v5 = v15;
      *v4 = 47;
      ++s;
      dword_80711F0 = (int)&loc_80531B0;
      sub_8064BC6(v3, v5);
    }
    v12 = *s;
    if ( byte_80719C2[(unsigned __int8)sub_804A7C9(v12)] )
    {
      v6 = v15++;
      v7 = s;
      v3 = s++ + 1;
      *v6 = *v7;
    }
    else
    {
      v8 = s++;
      v12 = *v8;
      v9 = sub_804A7C9(v12);
      v13 = v9;
      v10 = sprintf(v15, "%%%02x", v9);
      v15 += v10;
    }
  }
  *v15 = 0;
  return v16;
}
// 80711F0: using guessed type int dword_80711F0;

//----- (080531C9) --------------------------------------------------------
int __cdecl sub_80531C9(int a1, int a2, int a3, int a4, char a5, int a6, char *a7)
{
  int v7; // edx
  int v8; // ecx
  char *v9; // eax
  int v11; // [esp+0h] [ebp-2078h]
  char *s; // [esp+28h] [ebp-2050h]
  int v13; // [esp+2Ch] [ebp-204Ch]
  char v14; // [esp+30h] [ebp-2048h]
  int v15; // [esp+34h] [ebp-2044h]
  int v16; // [esp+38h] [ebp-2040h]
  int v17; // [esp+3Ch] [ebp-203Ch]
  char v18; // [esp+42h] [ebp-2036h]
  char v19; // [esp+43h] [ebp-2035h]
  char *v20; // [esp+44h] [ebp-2034h]
  int v21; // [esp+48h] [ebp-2030h]
  char *v22; // [esp+4Ch] [ebp-202Ch]
  char *v23; // [esp+50h] [ebp-2028h]
  unsigned int v24; // [esp+206Ch] [ebp-Ch]

  v17 = a1;
  v16 = a2;
  v15 = a4;
  v14 = a5;
  v13 = a6;
  s = a7;
  v24 = __readgsdword(0x14u);
  v20 = (char *)(&v11 - 2051);
  v21 = sub_8052ABB(&v11 - 2061, 0x2000, a1, a2, a3, 0, (char *)&v11 - 8246);
  dword_8071268 = (int (__cdecl *)(_DWORD))&loc_80532DB;
  if ( v18 )
  {
    dword_8071268 = (int (__cdecl *)(_DWORD))&loc_80532DB;
    if ( v14 )
    {
      putchar_unlocked(32);
      ++dword_80718F6;
      dword_8071268 = (int (__cdecl *)(_DWORD))&loc_8053304;
      if ( v15 )
      {
        sub_8053E07(v7, v8, v15);
        v19 = 0;
        dword_8071268 = (int (__cdecl *)(_DWORD))&loc_805344E;
        if ( s )
        {
          dword_8071268 = (int (__cdecl *)(_DWORD))&loc_805339B;
          if ( byte_8071793 )
          {
            dword_8071268 = (int (__cdecl *)(_DWORD))&loc_805339B;
            if ( byte_8071792 )
            {
              dword_8071268 = (int (__cdecl *)(_DWORD))&loc_805339B;
              if ( v18 != 1 )
              {
                v19 = 1;
                putchar_unlocked(*v20);
                v22 = sub_80530D5(dword_80717A2, 0);
                v9 = sub_80530D5(s, 1);
                v23 = v9;
                LOBYTE(v9) = *v9;
                dword_8071268 = (int (__cdecl *)(_DWORD))sub_8053409;
                if ( (_BYTE)v9 == 47 )
                  dword_8071268 = (int (__cdecl *)(_DWORD))&loc_805340E;
              }
            }
          }
        }
      }
    }
  }
  return dword_8071268(a1);
}
// 8052ABB: using guessed type _DWORD __cdecl sub_8052ABB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8053409: using guessed type int __cdecl sub_8053409(int, int, int);
// 8071268: using guessed type int (__cdecl *dword_8071268)(_DWORD);
// 8071792: using guessed type char byte_8071792;
// 8071793: using guessed type char byte_8071793;
// 80718F6: using guessed type int dword_80718F6;

//----- (08053409) --------------------------------------------------------
#error "805342D: call analysis failed (funcsize=48)"

//----- (080534E2) --------------------------------------------------------
#error "8053522: call analysis failed (funcsize=159)"

//----- (080537CE) --------------------------------------------------------
#error "80537D4: positive sp value has been found (funcsize=0)"

//----- (080537D8) --------------------------------------------------------
#error "8053875: call analysis failed (funcsize=51)"

//----- (0805387A) --------------------------------------------------------
#error "805396C: positive sp value has been found (funcsize=63)"

//----- (08053971) --------------------------------------------------------
size_t sub_8053971()
{
  int v0; // edx
  int v1; // ecx
  int v2; // ST00_4

  if ( dword_80712D0 )
  {
    sub_8054285((int)&unk_80712CC);
    dword_8071240 = (int)&locret_80539C7;
    sub_80649F8(v1, v0, v2);
  }
  sub_8054285((int)dword_80712BC);
  sub_8054285((int)&unk_80712D4);
  return sub_8054285((int)&dword_80712C4);
}
// 8071240: using guessed type int dword_8071240;
// 80712BC: using guessed type int dword_80712BC[];
// 80712C4: using guessed type int dword_80712C4;
// 80712D0: using guessed type int dword_80712D0;

//----- (080539C9) --------------------------------------------------------
#error "8053BD6: call analysis failed (funcsize=136)"

//----- (08053C1C) --------------------------------------------------------
#error "8053D55: call analysis failed (funcsize=116)"

//----- (08053DA6) --------------------------------------------------------
bool __cdecl sub_8053DA6(unsigned __int8 a1, int a2, int a3)
{
  char v4; // [esp+1Fh] [ebp-9h]

  v4 = sub_8053C1C(a1, a2, a3);
  if ( v4 )
  {
    putchar_unlocked(v4);
    ++dword_80718F6;
  }
  return v4 != 0;
}
// 8053C1C: using guessed type _DWORD __cdecl sub_8053C1C(_DWORD, _DWORD, _DWORD);
// 80718F6: using guessed type int dword_80718F6;

//----- (08053E07) --------------------------------------------------------
bool __usercall sub_8053E07@<al>(int a1@<edx>, int a2@<ecx>, int a3)
{
  void *v3; // eax

  v3 = &loc_8053E2C;
  if ( !a3 )
    v3 = &loc_8053E64;
  dword_807122C = (int)v3;
  sub_8064A68(a2, a1);
  if ( (unsigned __int8)sub_804B48E(4) )
    sub_804B522();
  sub_8054285((int)dword_80712BC);
  sub_8054285(a3);
  sub_8054285((int)&dword_80712C4);
  return a3 != 0;
}
// 8064A68: using guessed type double __fastcall sub_8064A68(_DWORD, _DWORD);
// 807122C: using guessed type int dword_807122C;
// 80712BC: using guessed type int dword_80712BC[];
// 80712C4: using guessed type int dword_80712C4;

//----- (08053E6D) --------------------------------------------------------
#error "8053F52: call analysis failed (funcsize=224)"

//----- (08054285) --------------------------------------------------------
size_t __cdecl sub_8054285(int a1)
{
  if ( byte_8071808 != 1 )
  {
    byte_8071808 = 1;
    if ( tcgetpgrp(1) >= 0 )
      sub_804B86B();
    sub_8053971();
  }
  return fwrite_unlocked(*(const void **)(a1 + 4), *(_DWORD *)a1, 1u, stdout);
}
// 8071808: using guessed type char byte_8071808;

//----- (080542E5) --------------------------------------------------------
int __cdecl sub_80542E5(char *a1)
{
  const char *v1; // eax
  int v2; // eax
  const char *v3; // eax
  int v4; // edx
  int v5; // ecx
  int v6; // eax
  void *v7; // eax
  int result; // eax
  unsigned int v9; // ebx
  char *s; // [esp+0h] [ebp-2DCh]
  char *v11; // [esp+8h] [ebp-2D4h]

  *(&s - 171) = a1;
  *(&s - 3) = (char *)__readgsdword(0x14u);
  *(&s - 167) = 0;
  if ( byte_8071813 )
  {
    if ( dword_80717DE == 4 )
    {
      v1 = (const char *)sub_805A77E(*((_DWORD *)*(&s - 171) + 25), *((_DWORD *)*(&s - 171) + 26), &s - 166);
      v2 = strlen(v1) + 1;
    }
    else
    {
      v2 = dword_80717B6 + 1;
    }
    *(&s - 167) += v2;
  }
  if ( byte_80717ED )
  {
    if ( dword_80717DE == 4 )
    {
      if ( (*(&s - 171))[120] == 1 )
        v3 = (const char *)sub_8059137(
                             *((_DWORD *)*(&s - 171) + 17),
                             *((_DWORD *)*(&s - 171) + 18),
                             (char *)&s - 664,
                             dword_80717EE,
                             512,
                             0,
                             qword_80717F2,
                             *(&qword_80717F2 + 1));
      else
        v3 = "?";
      strlen(v3);
      dword_80711DC = (int)&loc_805444F;
      sub_8064C3E(v5, v4);
    }
    *(&s - 167) += dword_80717BA + 1;
  }
  if ( byte_80717B2 )
  {
    if ( dword_80717DE == 4 )
    {
      s = (char *)*((_DWORD *)*(&s - 171) + 29);
      v6 = strlen(s) + 1;
    }
    else
    {
      v6 = dword_80717C2 + 1;
    }
    *(&s - 167) += v6;
  }
  v7 = *(void **)*(&s - 171);
  v11 = (char *)*((_DWORD *)*(&s - 171) + 33);
  *(&s - 167) += sub_8052FE1(v7, dword_807182E, (int)v11);
  if ( dword_8071802 )
  {
    *((_BYTE *)&s - 669) = sub_8053C1C(
                             (unsigned __int8)(*(&s - 171))[120],
                             *((_DWORD *)*(&s - 171) + 7),
                             *((_DWORD *)*(&s - 171) + 27));
    *(&s - 167) += *((_BYTE *)&s - 669) != 0;
  }
  result = (int)*(&s - 167);
  v9 = __readgsdword(0x14u) ^ (unsigned int)*(&s - 3);
  return result;
}
// 8053C1C: using guessed type _DWORD __cdecl sub_8053C1C(_DWORD, _DWORD, _DWORD);
// 805A77E: using guessed type _DWORD __cdecl sub_805A77E(_DWORD, _DWORD, _DWORD);
// 8064C3E: using guessed type int __fastcall sub_8064C3E(_DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;
// 80717B2: using guessed type char byte_80717B2;
// 80717B6: using guessed type int dword_80717B6;
// 80717BA: using guessed type int dword_80717BA;
// 80717C2: using guessed type int dword_80717C2;
// 80717DE: using guessed type int dword_80717DE;
// 80717ED: using guessed type char byte_80717ED;
// 8071802: using guessed type int dword_8071802;
// 8071813: using guessed type char byte_8071813;
// 807182E: using guessed type int dword_807182E;

//----- (08054540) --------------------------------------------------------
unsigned int sub_8054540()
{
  unsigned int v0; // ST28_4
  char *v1; // ST34_4
  int v2; // edx
  int v3; // ecx
  int v4; // ST00_4
  unsigned int result; // eax
  unsigned int v6; // [esp+18h] [ebp-30h]
  char *v7; // [esp+2Ch] [ebp-1Ch]
  unsigned int v8; // [esp+30h] [ebp-18h]
  int v9; // [esp+38h] [ebp-10h]
  int v10; // [esp+3Ch] [ebp-Ch]

  v0 = sub_8054CB7(1);
  v7 = (char *)dword_80718EE + 12 * v0 - 12;
  v8 = dword_807178E / v0 + (dword_807178E % v0 != 0);
  v6 = 0;
  while ( 1 )
  {
    result = v6;
    if ( v6 >= v8 )
      break;
    v1 = (char *)*((_DWORD *)dword_8071796 + v6);
    v9 = sub_80542E5(v1);
    v10 = **((_DWORD **)v7 + 2);
    sub_80539C9(v1, 0);
    if ( v8 + v6 < dword_807178E )
    {
      sub_8054918(v9, v10);
      dword_8071240 = (int)&loc_80545DA;
      sub_80649F8(v3, v2, v4);
    }
    else
    {
      putchar_unlocked(10);
      ++v6;
    }
  }
  return result;
}
// 80539C9: using guessed type _DWORD __cdecl sub_80539C9(_DWORD, _DWORD);
// 8054918: using guessed type _DWORD __cdecl sub_8054918(_DWORD, _DWORD);
// 8071240: using guessed type int dword_8071240;
// 807178E: using guessed type int dword_807178E;

//----- (080546AE) --------------------------------------------------------
#error "805471D: call analysis failed (funcsize=33)"

//----- (08054722) --------------------------------------------------------
#error "805481A: positive sp value has been found (funcsize=68)"

//----- (0805481B) --------------------------------------------------------
int __cdecl sub_805481B(char a1)
{
  int v1; // ecx
  void *v2; // eax
  char v4; // [esp+1Fh] [ebp-19h]
  unsigned int i; // [esp+20h] [ebp-18h]
  unsigned int v6; // [esp+24h] [ebp-14h]
  char *v7; // [esp+28h] [ebp-10h]
  int v8; // [esp+2Ch] [ebp-Ch]

  v6 = 0;
  for ( i = 0; i < dword_807178E; ++i )
  {
    v7 = (char *)*((_DWORD *)dword_8071796 + i);
    v2 = &loc_805486E;
    if ( !dword_807183E )
      v2 = &loc_805487B;
    dword_80711F0 = (int)v2;
    sub_8064BC6(v1, 4 * i);
    v8 = sub_80542E5(v7);
    if ( i )
    {
      if ( dword_807183E && (v6 + v8 + 2 >= dword_807183E || -3 - v8 < v6) )
      {
        v6 = 0;
        v4 = 10;
      }
      else
      {
        v6 += 2;
        v4 = 32;
      }
      putchar_unlocked(a1);
      putchar_unlocked(v4);
    }
    sub_80539C9(v7, v6);
    v6 += v8;
  }
  return putchar_unlocked(10);
}
// 80539C9: using guessed type _DWORD __cdecl sub_80539C9(_DWORD, _DWORD);
// 80711F0: using guessed type int dword_80711F0;
// 807178E: using guessed type int dword_807178E;
// 807183E: using guessed type int dword_807183E;

//----- (08054918) --------------------------------------------------------
#error "805496E: call analysis failed (funcsize=41)"

//----- (080549CE) --------------------------------------------------------
_BYTE *__cdecl sub_80549CE(_BYTE *a1, _BYTE *a2, _BYTE *a3)
{
  _BYTE *v3; // eax
  _BYTE *v4; // edx
  _BYTE *v5; // eax
  _BYTE *v6; // eax
  _BYTE *v7; // edx
  _BYTE *result; // eax
  _BYTE *v9; // [esp+Ch] [ebp-4h]

  v9 = a2;
  if ( *a2 != 46 || a2[1] )
  {
    while ( *v9 )
    {
      v3 = a1++;
      v4 = v9++;
      *v3 = *v4;
    }
    if ( v9 > a2 && *(v9 - 1) != 47 )
    {
      v5 = a1++;
      *v5 = 47;
    }
  }
  while ( *a3 )
  {
    v6 = a1++;
    v7 = a3++;
    *v6 = *v7;
  }
  result = a1;
  *a1 = 0;
  return result;
}

//----- (08054A62) --------------------------------------------------------
#error "8054BBC: call analysis failed (funcsize=158)"

//----- (08054CB7) --------------------------------------------------------
unsigned int __cdecl sub_8054CB7(char a1)
{
  int v1; // ecx
  int v2; // eax
  unsigned int v3; // eax
  signed int v4; // eax
  int v6; // [esp-Ch] [ebp-48h]
  int v7; // [esp-8h] [ebp-44h]
  int v8; // [esp-4h] [ebp-40h]
  char v9; // [esp+0h] [ebp-3Ch]
  unsigned int v10; // [esp+4h] [ebp-38h]
  unsigned int j; // [esp+8h] [ebp-34h]
  unsigned int i; // [esp+Ch] [ebp-30h]
  unsigned int v13; // [esp+10h] [ebp-2Ch]
  char *v14; // [esp+14h] [ebp-28h]
  int v15; // [esp+18h] [ebp-24h]
  unsigned int v16; // [esp+1Ch] [ebp-20h]
  int v17; // [esp+20h] [ebp-1Ch]
  int v18; // [esp+24h] [ebp-18h]
  int v19; // [esp+28h] [ebp-14h]
  int v20; // [esp+2Ch] [ebp-10h]
  int v21; // [esp+30h] [ebp-Ch]
  int v22; // [esp+34h] [ebp-8h]
  int v23; // [esp+38h] [ebp-4h]
  int savedregs; // [esp+3Ch] [ebp+0h]

  v9 = a1;
  v2 = dword_80718F2;
  if ( dword_807178E <= (unsigned int)dword_80718F2 )
    v2 = dword_807178E;
  v13 = v2;
  sub_8054A62(v1, dword_807178E);
  dword_8071204 = (int)&loc_8054F15;
  sub_8064B50(v6, v7, v8, *(_DWORD *)&v9, 0, j, i, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, savedregs);
  do
  {
    v14 = (char *)*((_DWORD *)dword_8071796 + v10);
    v15 = sub_80542E5(v14);
    for ( i = 0; i < v13; ++i )
    {
      if ( *((_BYTE *)dword_80718EE + 12 * i) )
      {
        v3 = v9 ? v10 / ((dword_807178E + i) / (i + 1)) : v10 % (i + 1);
        v16 = v3;
        v4 = v3 == i ? 0 : 2;
        v17 = v15 + v4;
        if ( *(_DWORD *)(4 * v16 + *((_DWORD *)dword_80718EE + 3 * i + 2)) < (unsigned int)(v15 + v4) )
        {
          *((_DWORD *)dword_80718EE + 3 * i + 1) += v17 - *(_DWORD *)(4 * v16 + *((_DWORD *)dword_80718EE + 3 * i + 2));
          *(_DWORD *)(*((_DWORD *)dword_80718EE + 3 * i + 2) + 4 * v16) = v17;
          *((_BYTE *)dword_80718EE + 12 * i) = *((_DWORD *)dword_80718EE + 3 * i + 1) < (unsigned int)dword_807183E;
        }
      }
    }
    ++v10;
  }
  while ( v10 < dword_807178E );
  for ( j = v13; j > 1 && !*((_BYTE *)dword_80718EE + 12 * j - 12); --j )
    ;
  return j;
}
// 8054A62: using guessed type int __fastcall sub_8054A62(_DWORD, _DWORD);
// 8064B50: using guessed type int __stdcall sub_8064B50(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8071204: using guessed type int dword_8071204;
// 807178E: using guessed type int dword_807178E;
// 807183E: using guessed type int dword_807183E;

//----- (08054F70) --------------------------------------------------------
#error "8054FB3: call analysis failed (funcsize=188)"

//----- (080552EE) --------------------------------------------------------
char *__cdecl sub_80552EE(char *path, int a2)
{
  int v2; // eax
  bool v4; // zf
  int v5; // edx
  int v6; // ecx
  void *v7; // eax
  int v8; // ST34_4
  size_t size; // [esp+10h] [ebp-28h]
  char *buf; // [esp+20h] [ebp-18h]
  ssize_t v11; // [esp+28h] [ebp-10h]

  if ( (unsigned int)a2 >= 0x401 )
    v2 = 1025;
  else
    v2 = a2 + 1;
  size = v2;
  while ( 1 )
  {
    buf = (char *)malloc(size);
    if ( !buf )
      return 0;
    v11 = readlink(path, buf, size);
    if ( v11 < 0 )
      break;
    if ( v11 < size )
    {
      buf[v11] = 0;
      return buf;
    }
    free(buf);
    if ( size > 0x3FFFFFFF )
    {
      if ( size > 0x7FFFFFFE )
      {
        *__errno_location() = 12;
        return 0;
      }
      size = 0x7FFFFFFF;
    }
    else
    {
      size *= 2;
    }
  }
  v4 = *__errno_location() == 34;
  v7 = &loc_8055399;
  if ( v4 )
    v7 = &loc_80553BF;
  dword_807122C = (int)v7;
  sub_8064A68(v6, v5);
  v8 = *__errno_location();
  free(buf);
  *__errno_location() = v8;
  return 0;
}
// 8064A68: using guessed type double __fastcall sub_8064A68(_DWORD, _DWORD);
// 807122C: using guessed type int dword_807122C;

//----- (0805541B) --------------------------------------------------------
void __noreturn sub_805541B()
{
  sub_8054F70(1);
}

//----- (0805542F) --------------------------------------------------------
#error "8055463: call analysis failed (funcsize=74)"

//----- (0805559A) --------------------------------------------------------
int __fastcall sub_805559A(int a1, int a2, int a3, int a4, int a5)
{
  void *v5; // eax
  int v7; // [esp+0h] [ebp-38h]

  dword_8071268 = (int (__cdecl *)(_DWORD))sub_80555ED;
  v5 = &loc_80555CE;
  if ( a5 != -1 )
    v5 = &loc_8060142;
  dword_8071240 = (int)v5;
  sub_80649F8(a1, a2, v7);
  gettext("invalid argument %s for %s");
  dword_8071268 = (int (__cdecl *)(_DWORD))&loc_80555F9;
  return ((int (__cdecl *)(int))loc_80555F9)(a3);
}
// 8071240: using guessed type int dword_8071240;
// 8071268: using guessed type int (__cdecl *dword_8071268)(_DWORD);

//----- (080555ED) --------------------------------------------------------
#error "8055652: positive sp value has been found (funcsize=0)"

//----- (08055655) --------------------------------------------------------
int __cdecl sub_8055655(int a1, int a2, size_t n)
{
  FILE *v3; // ebx
  char *v4; // eax
  const void *v6; // [esp+4h] [ebp-24h]
  void *v7; // [esp+8h] [ebp-20h]
  int i; // [esp+18h] [ebp-10h]
  void *s1; // [esp+1Ch] [ebp-Ch]

  s1 = 0;
  v3 = stderr;
  v4 = gettext("Valid arguments are:");
  fputs_unlocked(v4, v3);
  for ( i = 0; *(_DWORD *)(4 * i + a1); ++i )
  {
    if ( i && (v6 = (const void *)(a2 + i * n), !memcmp(s1, v6, n)) )
    {
      v7 = sub_8060313(*(_DWORD *)(4 * i + a1));
      fprintf(stderr, ", %s", v7);
    }
    else
    {
      v7 = sub_8060313(*(_DWORD *)(4 * i + a1));
      fprintf(stderr, "\n  - %s", v7);
      s1 = (void *)(i * n + a2);
    }
  }
  return putc_unlocked(10, stderr);
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0805577C) --------------------------------------------------------
int __cdecl sub_805577C(int a1, char *s, int a3, int a4, size_t n, int a6)
{
  int v6; // edx
  int v7; // ecx
  int v9; // [esp+8h] [ebp-20h]
  size_t v10; // [esp+Ch] [ebp-1Ch]
  int v11; // [esp+1Ch] [ebp-Ch]

  v10 = n;
  v9 = a4;
  v11 = sub_805542F(s, a3);
  if ( v11 >= 0 )
    return v11;
  sub_805559A(v7, v6, a1, (int)s, v11);
  sub_8055655(a3, a4, n);
  ((void (*)(void))a6)();
  return -1;
}

//----- (08055878) --------------------------------------------------------
signed int __cdecl sub_8055878(signed int a1)
{
  if ( a1 > 90 )
  {
    if ( (unsigned int)(a1 - 97) <= 0x19 )
      return 1;
  }
  else if ( a1 >= 65 || (unsigned int)(a1 - 48) <= 9 )
  {
    return 1;
  }
  return 0;
}

//----- (080558A8) --------------------------------------------------------
#error "80558D3: call analysis failed (funcsize=20)"

//----- (08055941) --------------------------------------------------------
_BOOL4 __cdecl sub_8055941(int a1)
{
  return (unsigned int)(a1 - 48) <= 9;
}

//----- (08055A64) --------------------------------------------------------
int __cdecl sub_8055A64(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 65) > 0x19 )
    result = a1;
  else
    result = a1 + 32;
  return result;
}

//----- (08055A9A) --------------------------------------------------------
int __cdecl sub_8055A9A(int a1, char *s, int a3)
{
  if ( !*(_DWORD *)a1 )
  {
    *(_DWORD *)a1 = sub_8057C77(7, 0, sub_8058BE5, sub_8058D8C, sub_8058E7A);
    if ( !*(_DWORD *)a1 )
      sub_80613C0();
  }
  if ( sub_80568A9(*(_DWORD *)a1, (int)s, (int *)a3) )
    return 1;
  sub_80567EF(*(_DWORD *)a1, s, a3);
  return 0;
}
// 8057C77: using guessed type _DWORD __cdecl sub_8057C77(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8058D8C: using guessed type int __cdecl sub_8058D8C(int, int);

//----- (08055B36) --------------------------------------------------------
#error "8056322: call analysis failed (funcsize=583)"

//----- (08056511) --------------------------------------------------------
int sub_8056511()
{
  int v0; // edx
  int v1; // ecx
  void *v2; // eax
  void *v3; // ebx
  int *v4; // eax
  int *v5; // eax
  int result; // eax
  char *v7; // [esp+2Ch] [ebp-Ch]

  if ( sub_80634B6(stdout) )
  {
    v2 = &loc_8056554;
    if ( byte_80727A2 != 1 )
      v2 = &loc_8056564;
    dword_80711DC = (int)v2;
    sub_8064C3E(v1, v0);
    if ( *__errno_location() != 32 )
    {
      v7 = gettext("write error");
      if ( dword_807279E )
      {
        v3 = sub_805FFEF(dword_807279E);
        v4 = __errno_location();
        error(0, *v4, "%s: %s", v3, v7);
      }
      else
      {
        v5 = __errno_location();
        error(0, *v5, "%s", v7);
      }
      _exit(status);
    }
  }
  result = sub_80634B6(stderr);
  if ( result )
    _exit(status);
  return result;
}
// 8064C3E: using guessed type int __fastcall sub_8064C3E(_DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;
// 807279E: using guessed type int dword_807279E;
// 80727A2: using guessed type char byte_80727A2;

//----- (0805660E) --------------------------------------------------------
_BYTE *__usercall sub_805660E@<eax>(int a1@<edx>, int a2@<ecx>, _BYTE *a3)
{
  int v3; // edx
  int v4; // ecx
  _BYTE *i; // [esp+18h] [ebp-10h]
  _BOOL4 v7; // [esp+1Ch] [ebp-Ch]

  dword_80711F0 = (int)&loc_805663A;
  sub_8064BC6(a2, a1);
  v7 = *a3 == 47;
  for ( i = (_BYTE *)(sub_8056733(v3, v4, a3) - a3); v7 < (unsigned int)i && a3[(_DWORD)(i - 1)] == 47; --i )
    ;
  return i;
}
// 80711F0: using guessed type int dword_80711F0;

//----- (08056698) --------------------------------------------------------
void *__usercall sub_8056698@<eax>(int a1@<edx>, int a2@<ecx>, void *src)
{
  int v4; // edx
  int v5; // ecx
  void *v6; // eax
  int v7; // [esp+0h] [ebp-28h]
  _BYTE *n; // [esp+18h] [ebp-10h]
  void *dest; // [esp+1Ch] [ebp-Ch]

  n = sub_805660E(a1, a2, src);
  dest = malloc((size_t)&n[(n == 0) + 1]);
  if ( !dest )
    return 0;
  memcpy(dest, src, (size_t)n);
  v6 = &loc_8056712;
  if ( n != 0 )
    v6 = &loc_8056723;
  dword_8071240 = (int)v6;
  sub_80649F8(v5, v4, v7);
  n[(_DWORD)dest] = 46;
  n[(_DWORD)dest + 1] = 0;
  return dest;
}
// 8071240: using guessed type int dword_8071240;

//----- (08056733) --------------------------------------------------------
_BYTE *__usercall sub_8056733@<eax>(int a1@<edx>, int a2@<ecx>, _BYTE *a3)
{
  void *v3; // eax
  char v5; // [esp+7h] [ebp-9h]
  _BYTE *v6; // [esp+8h] [ebp-8h]
  _BYTE *i; // [esp+Ch] [ebp-4h]

  v6 = a3;
  v5 = 0;
  v3 = &loc_805676C;
  if ( *a3 == 47 )
    v3 = &loc_8056745;
  dword_80711F0 = (int)v3;
  sub_8064BC6(a2, a1);
  for ( i = a3; *i; ++i )
  {
    if ( *i == 47 )
    {
      v5 = 1;
    }
    else if ( v5 )
    {
      v6 = i;
      v5 = 0;
    }
  }
  return v6;
}
// 80711F0: using guessed type int dword_80711F0;

//----- (080567A7) --------------------------------------------------------
size_t __cdecl sub_80567A7(char *s)
{
  size_t i; // [esp+18h] [ebp-10h]

  for ( i = strlen(s); i > 1 && s[i - 1] == 47; --i )
    ;
  return i;
}

//----- (080567E5) --------------------------------------------------------
int sub_80567E5()
{
  return 0;
}

//----- (080567EF) --------------------------------------------------------
void __cdecl sub_80567EF(int a1, char *s, int a3)
{
  void *v3; // edx
  void *v4; // edx
  void **v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]

  if ( a1 )
  {
    v5 = (void **)sub_8061270(0x14u);
    *v5 = sub_806139B(s);
    v3 = *(void **)(a3 + 92);
    v5[1] = *(void **)(a3 + 88);
    v5[2] = v3;
    v4 = *(void **)(a3 + 4);
    v5[3] = *(void **)a3;
    v5[4] = v4;
    v6 = sub_805890B(a1, (int)v5);
    if ( !v6 )
      sub_80613C0();
    if ( (void **)v6 != v5 )
      sub_8058E7A(v5);
  }
}

//----- (080568A9) --------------------------------------------------------
bool __cdecl sub_80568A9(int a1, int a2, int *a3)
{
  int v4; // edx
  int v5; // edx
  int v6; // [esp+0h] [ebp-38h]
  int v7; // [esp+1Ch] [ebp-1Ch]
  int v8; // [esp+20h] [ebp-18h]
  int v9; // [esp+24h] [ebp-14h]
  int v10; // [esp+28h] [ebp-10h]
  int v11; // [esp+2Ch] [ebp-Ch]

  if ( !a1 )
    return 0;
  v7 = a2;
  v4 = a3[23];
  v8 = a3[22];
  v9 = v4;
  v5 = a3[1];
  v10 = *a3;
  v11 = v5;
  return sub_80576B1(a1, (int)(&v6 - 7)) != 0;
}

//----- (08056918) --------------------------------------------------------
signed int __cdecl sub_8056918(__int16 a1)
{
  switch ( a1 & 0xF000 )
  {
    case 32768:
      return 45;
    case 16384:
      return 100;
    case 24576:
      return 98;
    case 8192:
      return 99;
    case 40960:
      return 108;
    case 4096:
      return 112;
    case 49152:
      return 115;
  }
  return 63;
}

//----- (080569BF) --------------------------------------------------------
#error "80569FA: call analysis failed (funcsize=164)"

//----- (08056BBF) --------------------------------------------------------
int __cdecl sub_8056BBF(int a1, int a2)
{
  return sub_80569BF(*(_DWORD *)(a1 + 16), a2);
}
// 80569BF: using guessed type _DWORD __cdecl sub_80569BF(_DWORD, _DWORD);

//----- (08056BDC) --------------------------------------------------------
void *__usercall sub_8056BDC@<eax>(int a1@<edx>, int a2@<ecx>, _BYTE *a3, _BYTE *a4, _DWORD *a5)
{
  void *v6; // [esp+1Ch] [ebp-Ch]

  v6 = sub_8056C26(a1, a2, a3, a4, a5);
  if ( !v6 )
    sub_80613C0();
  return v6;
}

//----- (08056C0E) --------------------------------------------------------
_BYTE *__cdecl sub_8056C0E(_BYTE *a1)
{
  while ( *a1 == 47 )
    ++a1;
  return a1;
}

//----- (08056C26) --------------------------------------------------------
void *__usercall sub_8056C26@<eax>(int a1@<edx>, int a2@<ecx>, _BYTE *a3, _BYTE *a4, _DWORD *a5)
{
  _BOOL4 v5; // eax
  signed int v7; // eax
  size_t v8; // [esp+0h] [ebp-38h]
  char *v9; // [esp+10h] [ebp-28h]
  size_t v10; // [esp+14h] [ebp-24h]
  char *v11; // [esp+18h] [ebp-20h]
  int v12; // [esp+1Ch] [ebp-1Ch]
  char *s; // [esp+20h] [ebp-18h]
  size_t v14; // [esp+24h] [ebp-14h]
  void *v15; // [esp+28h] [ebp-10h]
  _BYTE *v16; // [esp+2Ch] [ebp-Ch]

  v9 = sub_8056733(a1, a2, a3);
  v10 = sub_80567A7(v9);
  v11 = (char *)(v9 - a3 + v10);
  v5 = v10 && v9[v10 - 1] != 47;
  v12 = v5;
  s = sub_8056C0E(a4);
  v14 = strlen(s);
  v8 = (size_t)&v11[v12 + 1 + v14];
  v15 = malloc(v8);
  if ( !v15 )
    return 0;
  v16 = (_BYTE *)mempcpy(v15, a3, v11);
  *v16 = 47;
  v16 += v12;
  if ( a5 )
  {
    if ( *a4 == 47 )
      v7 = -1;
    else
      v7 = 0;
    *a5 = &v16[v7];
  }
  *(_BYTE *)mempcpy(v16, s, v14) = 0;
  return v15;
}
// 80499B0: using guessed type int __cdecl mempcpy(_DWORD, _DWORD, _DWORD);

//----- (08056D4C) --------------------------------------------------------
_BYTE *__cdecl sub_8056D4C(_BYTE **a1)
{
  bool v1; // zf
  int v2; // edx
  int v3; // ecx
  void *v4; // eax
  int v6; // [esp+0h] [ebp-28h]
  char v7; // [esp+1Bh] [ebp-Dh]
  _BYTE *v8; // [esp+1Ch] [ebp-Ch]

  v8 = 0;
  v7 = 0;
  while ( **a1 )
  {
    if ( v7 )
    {
      v7 = 0;
      v1 = (unsigned __int8)sub_80558A8((char)**a1) == 1;
      v4 = &loc_8056D9F;
      if ( v1 )
        v4 = &loc_8056E01;
      dword_8071240 = (int)v4;
      sub_80649F8(v3, v2, v6);
      if ( **a1 != 126 )
        v8 = 0;
    }
    else if ( **a1 == 46 )
    {
      v7 = 1;
      if ( !v8 )
        v8 = *a1;
    }
    else if ( (unsigned __int8)sub_8055878((char)**a1) ^ 1 && **a1 != 126 )
    {
      v8 = 0;
    }
    ++*a1;
  }
  return v8;
}
// 80558A8: using guessed type _DWORD __cdecl sub_80558A8(_DWORD);
// 8071240: using guessed type int dword_8071240;

//----- (08056E23) --------------------------------------------------------
int __cdecl sub_8056E23(int a1)
{
  bool v1; // al

  v1 = sub_8055941((unsigned __int8)a1);
  dword_8071268 = (int (__cdecl *)(_DWORD))sub_8056E69;
  if ( v1 )
    dword_8071268 = (int (__cdecl *)(_DWORD))&locret_8056EDB;
  return dword_8071268(a1);
}
// 8056E69: using guessed type int sub_8056E69();
// 8071268: using guessed type int (__cdecl *dword_8071268)(_DWORD);

//----- (08056E69) --------------------------------------------------------
#error "8056E70: call analysis failed (funcsize=16)"

//----- (08056EA2) --------------------------------------------------------
int __usercall sub_8056EA2@<eax>(int a1@<ebp>, int a2)
{
  bool v2; // zf

  v2 = *(_BYTE *)(a1 - 12) == 126;
  dword_8071268 = (int (__cdecl *)(_DWORD))sub_8056ED2;
  if ( v2 )
    dword_8071268 = (int (__cdecl *)(_DWORD))&locret_8056EDB;
  return dword_8071268(a2);
}
// 8056ED2: using guessed type int sub_8056ED2();
// 8071268: using guessed type int (__cdecl *dword_8071268)(_DWORD);

//----- (08056ED2) --------------------------------------------------------
#error "8056EDC: positive sp value has been found (funcsize=0)"

//----- (08056EDD) --------------------------------------------------------
#error "8057018: call analysis failed (funcsize=160)"

//----- (0805710B) --------------------------------------------------------
int __cdecl sub_805710B(char *s1, char *s2)
{
  bool v3; // zf
  int v4; // edx
  int v5; // ecx
  void *v6; // eax
  int v7; // [esp+0h] [ebp-38h]

  if ( !strcmp(s1, s2) )
    return 0;
  if ( !*s1 )
    return -1;
  if ( !*s2 )
    return 1;
  if ( !strcmp(".", s1) )
    return -1;
  v3 = strcmp(".", s2) == 0;
  v6 = &loc_80571AF;
  if ( !v3 )
    v6 = &loc_80571B9;
  dword_8071240 = (int)v6;
  sub_80649F8(v5, v4, v7);
  return 1;
}
// 8071240: using guessed type int dword_8071240;

//----- (08057353) --------------------------------------------------------
struct timespec *__cdecl sub_8057353(struct timespec *tp)
{
  int v1; // eax
  int v2; // edx
  int v3; // ecx
  struct timespec *result; // eax
  struct timeval tv; // [esp+18h] [ebp-10h]

  v1 = clock_gettime(0, tp);
  dword_8071268 = (int (__cdecl *)(_DWORD))&loc_80573A7;
  if ( v1 )
    return (struct timespec *)dword_8071268(tp);
  dword_8071268 = (int (__cdecl *)(_DWORD))&locret_80573D1;
  dword_80711DC = (int)&loc_8060142;
  sub_8064C3E(v3, v2);
  gettimeofday(&tv, 0);
  tp->tv_sec = tv.tv_sec;
  result = tp;
  tp->tv_nsec = 1000 * tv.tv_usec;
  return result;
}
// 8064C3E: using guessed type int __fastcall sub_8064C3E(_DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;
// 8071268: using guessed type int (__cdecl *dword_8071268)(_DWORD);

//----- (080573D3) --------------------------------------------------------
int __cdecl sub_80573D3(int category)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  const char *s1; // [esp+1Ch] [ebp-Ch]

  s1 = setlocale(category, 0);
  dword_8071268 = (int (__cdecl *)(_DWORD))&loc_8057461;
  if ( s1
    && (v1 = strcmp(s1, "C"), dword_8071268 = (int (__cdecl *)(_DWORD))&loc_805745D, v1)
    && (v2 = strcmp(s1, "POSIX"), dword_8071268 = (int (__cdecl *)(_DWORD))&loc_8057461, !v2) )
  {
    result = 0;
  }
  else
  {
    result = dword_8071268(category);
  }
  return result;
}
// 8071268: using guessed type int (__cdecl *dword_8071268)(_DWORD);

//----- (08057467) --------------------------------------------------------
int __cdecl sub_8057467(int a1)
{
  return *(_DWORD *)(a1 + 8);
}

//----- (08057472) --------------------------------------------------------
int __cdecl sub_8057472(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (0805747D) --------------------------------------------------------
int __cdecl sub_805747D(int a1)
{
  return *(_DWORD *)(a1 + 16);
}

//----- (08057488) --------------------------------------------------------
unsigned int __cdecl sub_8057488(int a1)
{
  _DWORD *i; // [esp+0h] [ebp-10h]
  unsigned int v3; // [esp+4h] [ebp-Ch]
  _DWORD *v4; // [esp+8h] [ebp-8h]
  unsigned int j; // [esp+Ch] [ebp-4h]

  v3 = 0;
  for ( i = *(_DWORD **)a1; *(_DWORD *)(a1 + 4) > (unsigned int)i; i += 2 )
  {
    if ( *i )
    {
      v4 = i;
      for ( j = 1; ; ++j )
      {
        v4 = (_DWORD *)v4[1];
        if ( !v4 )
          break;
      }
      if ( j > v3 )
        v3 = j;
    }
  }
  return v3;
}

//----- (08057661) --------------------------------------------------------
int __cdecl sub_8057661(_DWORD *a1, int a2)
{
  int (__cdecl *v2)(int, int); // eax
  int v4; // [esp+4h] [ebp-24h]
  unsigned int v5; // [esp+1Ch] [ebp-Ch]

  v2 = (int (__cdecl *)(int, int))a1[6];
  v4 = a1[2];
  v5 = v2(a2, v4);
  if ( a1[2] <= v5 )
    abort();
  return 8 * v5 + *a1;
}

//----- (080576B1) --------------------------------------------------------
int __cdecl sub_80576B1(int a1, int a2)
{
  _DWORD *i; // [esp+18h] [ebp-10h]
  _DWORD *v4; // [esp+1Ch] [ebp-Ch]

  v4 = (_DWORD *)sub_8057661((_DWORD *)a1, a2);
  if ( !*v4 )
    return 0;
  for ( i = v4; i; i = (_DWORD *)i[1] )
  {
    if ( *i == a2 || (*(unsigned __int8 (__cdecl **)(int, _DWORD))(a1 + 28))(a2, *i) )
      return *i;
  }
  return 0;
}

//----- (080579AF) --------------------------------------------------------
bool __cdecl sub_80579AF(unsigned int a1)
{
  int v1; // ST08_4
  unsigned int v3; // [esp+8h] [ebp-8h]
  unsigned int v4; // [esp+Ch] [ebp-4h]

  v3 = 3;
  v4 = 9;
  while ( v4 < a1 && a1 % v3 )
  {
    v1 = v3 + 1;
    v4 += 4 * v1;
    v3 = v1 + 1;
  }
  return a1 % v3 != 0;
}

//----- (08057A06) --------------------------------------------------------
int __usercall sub_8057A06@<eax>(int a1@<edx>, int a2@<ecx>, unsigned int a3)
{
  int v4; // [esp+Ch] [ebp+8h]

  if ( a3 <= 9 )
    a3 = 10;
  v4 = a3 | 1;
  dword_80711DC = (int)&loc_8057A38;
  sub_8064C3E(a2, a1);
  do
    v4 += 2;
  while ( v4 != -1 && !sub_80579AF(v4) );
  return v4;
}
// 8064C3E: using guessed type int __fastcall sub_8064C3E(_DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;

//----- (08057AAC) --------------------------------------------------------
unsigned int __cdecl sub_8057AAC(int a1, unsigned int a2)
{
  return sub_806329C(a1, 3) % a2;
}

//----- (08057AD7) --------------------------------------------------------
bool __cdecl sub_8057AD7(int a1, int a2)
{
  return a1 == a2;
}

//----- (08057AE5) --------------------------------------------------------
signed int __cdecl sub_8057AE5(int a1)
{
  int v2; // [esp+8h] [ebp-8h]

  v2 = *(_DWORD *)(a1 + 20);
  if ( (_UNKNOWN *)v2 == &unk_80694C0 )
    return 1;
  if ( *(float *)(v2 + 8) > 0.1
    && 1.0 - 0.1 > *(float *)(v2 + 8)
    && *(float *)(v2 + 12) > 0.1 + 1.0
    && *(float *)v2 >= 0.0
    && *(float *)(v2 + 4) > *(float *)v2 + 0.1
    && *(float *)(v2 + 4) <= 1.0
    && *(float *)(v2 + 8) > *(float *)v2 + 0.1 )
  {
    return 1;
  }
  *(_DWORD *)(a1 + 20) = &unk_80694C0;
  return 0;
}

//----- (08057BA1) --------------------------------------------------------
#error "8057C35: call analysis failed (funcsize=56)"

//----- (08057C77) --------------------------------------------------------
#error "8057D57: call analysis failed (funcsize=104)"

//----- (08057ED4) --------------------------------------------------------
void __cdecl sub_8057ED4(void *a1)
{
  _DWORD *v1; // ST1C_4
  _DWORD *v2; // ST1C_4
  _DWORD *i; // [esp+14h] [ebp-14h]
  _DWORD *j; // [esp+14h] [ebp-14h]
  _DWORD *ptr; // [esp+18h] [ebp-10h]
  _DWORD *ptra; // [esp+18h] [ebp-10h]
  _DWORD *ptrb; // [esp+18h] [ebp-10h]

  if ( *((_DWORD *)a1 + 8) && *((_DWORD *)a1 + 4) )
  {
    for ( i = *(_DWORD **)a1; *((_DWORD *)a1 + 1) > (unsigned int)i; i += 2 )
    {
      if ( *i )
      {
        for ( ptr = i; ptr; ptr = (_DWORD *)ptr[1] )
          (*((void (__cdecl **)(_DWORD))a1 + 8))(*ptr);
      }
    }
  }
  for ( j = *(_DWORD **)a1; *((_DWORD *)a1 + 1) > (unsigned int)j; j += 2 )
  {
    for ( ptra = (_DWORD *)j[1]; ptra; ptra = v1 )
    {
      v1 = (_DWORD *)ptra[1];
      free(ptra);
    }
  }
  for ( ptrb = (_DWORD *)*((_DWORD *)a1 + 9); ptrb; ptrb = v2 )
  {
    v2 = (_DWORD *)ptrb[1];
    free(ptrb);
  }
  free(*(void **)a1);
  free(a1);
}

//----- (08057FC0) --------------------------------------------------------
#error "8057FE4: call analysis failed (funcsize=26)"

//----- (08058014) --------------------------------------------------------
int __cdecl sub_8058014(int a1, _DWORD *a2)
{
  int result; // eax

  *a2 = 0;
  a2[1] = *(_DWORD *)(a1 + 36);
  result = a1;
  *(_DWORD *)(a1 + 36) = a2;
  return result;
}

//----- (08058057) --------------------------------------------------------
int __cdecl sub_8058057(int a1, int a2, _DWORD *a3, char a4)
{
  int v4; // ecx
  _DWORD *v5; // edx
  int result; // eax
  void *v7; // eax
  _DWORD *v8; // ST34_4
  int v9; // edx
  void *v10; // eax
  _DWORD *v11; // [esp+1Ch] [ebp-1Ch]
  int v12; // [esp+28h] [ebp-10h]

  v11 = (_DWORD *)sub_8057661((_DWORD *)a1, a2);
  v5 = v11;
  *a3 = v11;
  if ( !*v11 )
    return 0;
  if ( *v11 == a2 || (*(unsigned __int8 (__cdecl **)(int, _DWORD))(a1 + 28))(a2, *v11) )
  {
    v12 = *v11;
    v7 = &loc_80580E3;
    if ( !a4 )
      v7 = &loc_8058143;
    dword_80711DC = (int)v7;
    sub_8064C3E(v4, v5);
    if ( v11[1] )
    {
      v8 = (_DWORD *)v11[1];
      v9 = v8[1];
      *v11 = *v8;
      v11[1] = v9;
      sub_8058014(a1, v8);
    }
    else
    {
      *v11 = 0;
    }
    result = v12;
  }
  else
  {
    v10 = &loc_8058213;
    if ( v11[1] )
      v10 = &loc_8058156;
    dword_80711F0 = (int)v10;
    sub_8064BC6(v4, v5);
    result = 0;
  }
  return result;
}
// 8064C3E: using guessed type int __fastcall sub_8064C3E(_DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;
// 80711F0: using guessed type int dword_80711F0;

//----- (0805821A) --------------------------------------------------------
#error "805831C: call analysis failed (funcsize=121)"

//----- (080583D6) --------------------------------------------------------
signed int __cdecl sub_80583D6(int a1, int a2)
{
  signed int result; // eax
  int v3; // [esp+0h] [ebp-48h]
  int v4; // [esp+4h] [ebp-44h]
  int v5; // [esp+8h] [ebp-40h]
  int v6; // [esp+Ch] [ebp-3Ch]
  int nmemb; // [esp+10h] [ebp-38h]
  int v8; // [esp+14h] [ebp-34h]
  char *v9; // [esp+18h] [ebp-30h]
  char *v10; // [esp+1Ch] [ebp-2Ch]
  int v11; // [esp+20h] [ebp-28h]
  int v12; // [esp+24h] [ebp-24h]
  int v13; // [esp+28h] [ebp-20h]
  int v14; // [esp+2Ch] [ebp-1Ch]
  int v15; // [esp+30h] [ebp-18h]
  int v16; // [esp+34h] [ebp-14h]
  int v17; // [esp+38h] [ebp-10h]
  int v18; // [esp+3Ch] [ebp-Ch]
  int v19; // [esp+40h] [ebp-8h]
  int v20; // [esp+44h] [ebp-4h]
  int savedregs; // [esp+48h] [ebp+0h]

  nmemb = sub_8057BA1(a2, *(_DWORD *)(a1 + 20));
  if ( !nmemb )
  {
    dword_8071204 = (int)&locret_80585DB;
    sub_8064B50(v3, v4, v5, v6, 0, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, savedregs);
  }
  if ( *(_DWORD *)(a1 + 8) == nmemb )
    return 1;
  v9 = (char *)calloc(nmemb, 8u);
  if ( !v9 )
    return 0;
  v11 = nmemb;
  v10 = &v9[8 * nmemb];
  v12 = 0;
  v13 = 0;
  v14 = *(_DWORD *)(a1 + 20);
  v15 = *(_DWORD *)(a1 + 24);
  v16 = *(_DWORD *)(a1 + 28);
  v17 = *(_DWORD *)(a1 + 32);
  v18 = *(_DWORD *)(a1 + 36);
  if ( (unsigned __int8)sub_805821A(&v9, a1, 0) )
  {
    free(*(void **)a1);
    *(_DWORD *)a1 = v9;
    *(_DWORD *)(a1 + 4) = v10;
    *(_DWORD *)(a1 + 8) = v11;
    *(_DWORD *)(a1 + 12) = v12;
    *(_DWORD *)(a1 + 36) = v18;
    result = 1;
  }
  else
  {
    *(_DWORD *)(a1 + 36) = v18;
    if ( (unsigned __int8)sub_805821A(a1, &v9, 1) ^ 1 || (unsigned __int8)sub_805821A(a1, &v9, 0) ^ 1 )
      abort();
    free(v9);
    result = 0;
  }
  return result;
}
// 8057BA1: using guessed type _DWORD __cdecl sub_8057BA1(_DWORD, _DWORD);
// 805821A: using guessed type _DWORD __cdecl sub_805821A(_DWORD, _DWORD, _DWORD);
// 8064B50: using guessed type int __stdcall sub_8064B50(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8071204: using guessed type int dword_8071204;

//----- (080585DD) --------------------------------------------------------
int __cdecl sub_80585DD(int a1, int a2, _DWORD *a3)
{
  int v3; // eax
  int v4; // edx
  int v5; // ecx
  bool v6; // zf
  void *v7; // eax
  int v9; // [esp+0h] [ebp-48h]
  int v10; // [esp+2Ch] [ebp-1Ch]
  int v11; // [esp+30h] [ebp-18h]

  if ( !a2 )
    abort();
  v3 = sub_8058057(a1, a2, &v10, 0);
  v11 = v3;
  v6 = v3 == 0;
  v7 = &loc_8058631;
  if ( v6 )
    v7 = &loc_8058649;
  dword_8071240 = (int)v7;
  sub_80649F8(v5, v4, v9);
  if ( a3 )
    *a3 = v11;
  return 0;
}
// 8071240: using guessed type int dword_8071240;

//----- (0805890B) --------------------------------------------------------
int __cdecl sub_805890B(int a1, int a2)
{
  int v2; // edx
  int v3; // ecx
  int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]

  v6 = sub_80585DD(a1, a2, &v5);
  if ( v6 == -1 )
    return 0;
  if ( !v6 )
  {
    dword_80711F0 = (int)&locret_805895D;
    sub_8064BC6(v3, v2);
  }
  return a2;
}
// 80711F0: using guessed type int dword_80711F0;

//----- (0805895F) --------------------------------------------------------
#error "8058AA3: call analysis failed (funcsize=97)"

//----- (08058BE5) --------------------------------------------------------
__int64 __cdecl sub_8058BE5(int a1, unsigned int a2)
{
  int v2; // ST2C_4

  v2 = sub_80635C6(*(_BYTE **)a1, a2);
  return sub_806452F(*(_DWORD *)(a1 + 4) ^ (unsigned int)v2, *(_DWORD *)(a1 + 8), a2, 0);
}

//----- (08058D8C) --------------------------------------------------------
#error "8058E08: call analysis failed (funcsize=53)"

//----- (08058E7A) --------------------------------------------------------
void __cdecl sub_8058E7A(void **a1)
{
  free(*a1);
  free(a1);
}

//----- (08058EA0) --------------------------------------------------------
long double __cdecl sub_8058EA0(int a1, long double a2)
{
  int v2; // ecx
  signed int v3; // eax
  unsigned __int64 v5; // [esp+28h] [ebp-10h]

  if ( a1 != 1 && a2 < 1.8446744073709551615e19 )
  {
    if ( a2 >= 9.223372036854775808e18 )
    {
      v2 = ((unsigned __int64)(signed __int64)(a2 - 9.223372036854775808e18) >> 32) ^ 0x80000000;
      v5 = (signed __int64)(a2 - 9.223372036854775808e18) ^ 0x8000000000000000LL;
    }
    else
    {
      v5 = (signed __int64)a2;
    }
    if ( a1 || a2 == (long double)v5 )
    {
      v3 = 0;
    }
    else
    {
      dword_807122C = (int)&loc_8058F98;
      sub_8064A68(v2, HIDWORD(v5));
      v3 = 1;
    }
    a2 = (long double)(v3 + v5);
  }
  return a2;
}
// 8064A68: using guessed type double __fastcall sub_8064A68(_DWORD, _DWORD);
// 807122C: using guessed type int dword_807122C;

//----- (08059008) --------------------------------------------------------
char *__cdecl sub_8059008(int a1, size_t n, int a3, int a4)
{
  char *i; // ebx
  size_t v5; // eax
  char *v6; // ebx
  unsigned __int8 *v8; // [esp+18h] [ebp-50h]
  unsigned __int8 v9; // [esp+23h] [ebp-45h]
  size_t v10; // [esp+24h] [ebp-44h]
  size_t v11; // [esp+28h] [ebp-40h]
  size_t v12; // [esp+2Ch] [ebp-3Ch]
  char dest[41]; // [esp+33h] [ebp-35h]
  unsigned int v14; // [esp+5Ch] [ebp-Ch]

  v8 = (unsigned __int8 *)a3;
  v14 = __readgsdword(0x14u);
  v10 = -1;
  v12 = strlen((const char *)a4);
  v11 = n;
  memcpy(dest, (const void *)a1, n);
  for ( i = (char *)(a1 + n); ; memcpy(i, (const void *)a4, v12) )
  {
    v9 = *v8;
    if ( *v8 )
    {
      if ( v9 > 0x7Eu )
        v5 = v11;
      else
        v5 = v9;
      v10 = v5;
      ++v8;
    }
    if ( v11 < v10 )
      v10 = v11;
    v6 = &i[-v10];
    v11 -= v10;
    memcpy(v6, &dest[v11], v10);
    if ( !v11 )
      break;
    i = &v6[-v12];
  }
  return v6;
}
// 8059008: using guessed type char dest[41];

//----- (08059137) --------------------------------------------------------
#error "805951F: call analysis failed (funcsize=835)"

//----- (08059FF9) --------------------------------------------------------
__int64 sub_8059FF9()
{
  __int64 result; // rax

  if ( getenv("POSIXLY_CORRECT") )
    LODWORD(result) = 512;
  else
    LODWORD(result) = 1024;
  HIDWORD(result) = 0;
  return result;
}

//----- (0805A027) --------------------------------------------------------
#error "805A091: call analysis failed (funcsize=120)"

//----- (0805A1CA) --------------------------------------------------------
int __cdecl sub_805A1CA(char *s, int a2, int a3)
{
  int v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_805A027(s, a3, a2);
  if ( !*(_QWORD *)a3 )
  {
    *(_QWORD *)a3 = sub_8059FF9();
    v4 = 4;
  }
  return v4;
}

//----- (0805A213) --------------------------------------------------------
char *__cdecl sub_805A213(__uid_t uid)
{
  const char *v1; // eax
  char *s; // ST1C_4
  size_t v3; // eax
  char *result; // eax
  char *i; // [esp+10h] [ebp-18h]
  char *v6; // [esp+14h] [ebp-14h]
  struct passwd *v7; // [esp+18h] [ebp-10h]

  v6 = 0;
  for ( i = (char *)dword_80727A6; i; i = (char *)*((_DWORD *)i + 1) )
  {
    if ( *(_DWORD *)i == uid )
    {
      v6 = i;
      break;
    }
  }
  if ( !v6 )
  {
    v7 = getpwuid(uid);
    if ( v7 )
      v1 = v7->pw_name;
    else
      v1 = (const char *)&unk_8069624;
    s = (char *)v1;
    v3 = strlen(v1);
    v6 = (char *)sub_8061270((v3 + 16) & 0xFFFFFFF8);
    *(_DWORD *)v6 = uid;
    strcpy(v6 + 8, s);
    *((_DWORD *)v6 + 1) = dword_80727A6;
    dword_80727A6 = (int)v6;
  }
  if ( v6[8] )
    result = v6 + 8;
  else
    result = 0;
  return result;
}
// 80727A6: using guessed type int dword_80727A6;

//----- (0805A41D) --------------------------------------------------------
#error "805A487: call analysis failed (funcsize=71)"

//----- (0805A634) --------------------------------------------------------
int __cdecl sub_805A634(__int64 a1, int a2)
{
  __int64 v3; // [esp+18h] [ebp-20h]
  int v4; // [esp+2Ch] [ebp-Ch]

  v3 = a1;
  v4 = a2 + 20;
  *(_BYTE *)(a2 + 20) = 0;
  if ( a1 >= 0 )
  {
    do
    {
      *(_BYTE *)--v4 = sub_8064070(v3, HIDWORD(v3), 10, 0) + 48;
      v3 = sub_8063E82(v3, 0xAu, 0);
    }
    while ( v3 );
  }
  else
  {
    do
    {
      *(_BYTE *)--v4 = 48 - sub_8064070(v3, HIDWORD(v3), 10, 0);
      v3 = sub_8063E82(v3, 0xAu, 0);
    }
    while ( v3 );
    *(_BYTE *)--v4 = 45;
  }
  return v4;
}
// 8064070: using guessed type _DWORD __cdecl sub_8064070(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0805A77E) --------------------------------------------------------
#error "805A7E8: call analysis failed (funcsize=35)"

//----- (0805A7FB) --------------------------------------------------------
#error "805A828: call analysis failed (funcsize=18)"

//----- (0805A83B) --------------------------------------------------------
#error "805A865: positive sp value has been found (funcsize=0)"

//----- (0805A866) --------------------------------------------------------
int __usercall sub_805A866@<eax>(int a1@<edx>, int a2@<ecx>, _DWORD *a3)
{
  void *v3; // eax

  v3 = &loc_805A8BC;
  if ( *a3 )
    v3 = &loc_805A878;
  dword_80711F0 = (int)v3;
  sub_8064BC6(a2, a1);
  return 0;
}
// 80711F0: using guessed type int dword_80711F0;

//----- (0805A8C2) --------------------------------------------------------
#error "805A8E4: call analysis failed (funcsize=39)"

//----- (0805A943) --------------------------------------------------------
_BYTE *__cdecl sub_805A943(_BYTE *a1, unsigned int a2, int a3)
{
  _BYTE *v3; // eax
  int v4; // eax

  while ( 1 )
  {
    v4 = a3--;
    if ( !v4 || (unsigned int)a1 >= a2 )
      break;
    v3 = a1++;
    *v3 = 32;
  }
  *a1 = 0;
  return a1;
}

//----- (0805A974) --------------------------------------------------------
#error "805ACA3: call analysis failed (funcsize=247)"

//----- (0805AE3D) --------------------------------------------------------
void __usercall __noreturn sub_805AE3D(int a1@<ebx>, char *s, int a3)
{
  int v3; // eax

  v3 = strlen(s);
  sub_805AE66(a1, s, v3, a3);
}

//----- (0805AE66) --------------------------------------------------------
int __usercall __noreturn sub_805AE66@<eax>(int a1@<ebx>, char *a2, int a3, char a4)
{
  int v4; // edx
  int v5; // ecx
  signed int v6; // eax
  bool v7; // sf
  unsigned __int8 v8; // of
  void *v9; // eax
  int v10; // eax
  signed int v11; // eax
  char *v12; // eax
  const unsigned __int16 **v13; // eax
  const unsigned __int16 **v14; // eax
  int v15; // ecx
  unsigned int v16; // et1
  int (*v17)(); // eax
  int v19; // [esp-8h] [ebp-60h]
  signed int v20; // [esp-4h] [ebp-5Ch]
  int v21; // [esp+0h] [ebp-58h]
  char *v22; // [esp+1Ch] [ebp-3Ch]
  int v23; // [esp+28h] [ebp-30h]
  wint_t wc; // [esp+2Ch] [ebp-2Ch]
  char *v25; // [esp+30h] [ebp-28h]
  int v26; // [esp+34h] [ebp-24h]
  int v27; // [esp+38h] [ebp-20h]
  char *v28; // [esp+3Ch] [ebp-1Ch]
  int v29; // [esp+40h] [ebp-18h]
  const mbstate_t s; // [esp+44h] [ebp-14h]
  unsigned int v31; // [esp+4Ch] [ebp-Ch]

  v22 = a2;
  v31 = __readgsdword(0x14u);
  v25 = a2;
  v28 = &a2[a3];
  v26 = 0;
  if ( __ctype_get_mb_cur_max() <= 1 )
  {
    while ( 1 )
    {
      do
      {
        while ( 1 )
        {
          if ( v25 >= v28 )
          {
            v11 = v26;
            goto LABEL_46;
          }
          v12 = v25++;
          HIBYTE(v23) = *v12;
          v13 = __ctype_b_loc();
          v4 = 2 * HIBYTE(v23);
          if ( !((*v13)[v4 / 2u] & 0x4000) )
            break;
          if ( v26 == 0x7FFFFFFF )
            goto LABEL_45;
          ++v26;
        }
        if ( a4 & 2 )
        {
          v11 = -1;
          goto LABEL_46;
        }
        v14 = __ctype_b_loc();
        v4 = 2 * HIBYTE(v23);
      }
      while ( (*v14)[v4 / 2u] & 2 );
      if ( v26 == 0x7FFFFFFF )
      {
LABEL_45:
        v11 = 0x7FFFFFFF;
        goto LABEL_46;
      }
      ++v26;
    }
  }
  while ( 1 )
  {
LABEL_32:
    if ( v25 >= v28 )
    {
      v11 = v26;
      goto LABEL_46;
    }
    v6 = *v25;
    if ( v6 <= 63 )
    {
      if ( v6 >= 37 )
        goto LABEL_11;
      if ( (unsigned int)(v6 - 32) > 3 )
        break;
      dword_807122C = (int)&loc_805AF25;
      sub_8064A68(v5, v4);
    }
    v8 = __OFSUB__(v6, 65);
    v7 = v6 - 65 < 0;
    v20 = v6;
    v19 = a1;
    v9 = &loc_805AF18;
    if ( v7 ^ v8 )
      v9 = &loc_805AF32;
    dword_80711F0 = (int)v9;
    a1 = v19;
    v10 = sub_8064BC6(v5, v4);
    if ( v10 > 95 && (unsigned int)(v10 - 97) > 0x1D )
      break;
LABEL_11:
    ++v25;
    ++v26;
  }
  memset((void *)&s, 0, 8u);
  while ( 1 )
  {
    v27 = sub_80622C6(&v21 - 11, v25, v28 - v25, (mbstate_t *)&s);
    if ( v27 == -1 )
      break;
    if ( v27 == -2 )
    {
      if ( !(a4 & 1) )
      {
        v25 = v28;
        ++v26;
        dword_807122C = (int)&loc_805B074;
        sub_8064A68(v5, v4);
      }
      v11 = -1;
      goto LABEL_46;
    }
    if ( !v27 )
      v27 = 1;
    v29 = wcwidth(wc);
    if ( v29 < 0 )
    {
      if ( a4 & 2 )
      {
        v11 = -1;
        goto LABEL_46;
      }
      if ( !iswcntrl(wc) )
      {
        if ( v26 == 0x7FFFFFFF )
          goto LABEL_45;
        ++v26;
      }
    }
    else
    {
      if ( 0x7FFFFFFF - v26 < v29 )
        goto LABEL_45;
      v26 += v29;
    }
    v25 += v27;
    if ( mbsinit(&s) )
      goto LABEL_32;
  }
  if ( !(a4 & 1) )
  {
    ++v25;
    ++v26;
    goto LABEL_32;
  }
  v11 = -1;
LABEL_46:
  v16 = __readgsdword(0x14u);
  v15 = v16 ^ v31;
  v20 = v11;
  v19 = a1;
  v17 = (int (*)())&loc_805B141;
  if ( v16 == v31 )
    v17 = sub_805B146;
  dword_80711DC = (int)v17;
  return sub_8064C3E(v15, v4);
}
// 805AE66: could not find valid save-restore pair for ebx
// 8049560: using guessed type int __cdecl wcwidth(_DWORD);
// 805B146: using guessed type int sub_805B146();
// 8064A68: using guessed type double __fastcall sub_8064A68(_DWORD, _DWORD);
// 8064C3E: using guessed type int __fastcall sub_8064C3E(_DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;
// 80711F0: using guessed type int dword_80711F0;
// 807122C: using guessed type int dword_807122C;

//----- (0805B146) --------------------------------------------------------
#error "805B147: positive sp value has been found (funcsize=0)"

//----- (0805B148) --------------------------------------------------------
#error "805B33C: call analysis failed (funcsize=142)"

//----- (0805B341) --------------------------------------------------------
#error "805B369: positive sp value has been found (funcsize=11)"

//----- (0805B36A) --------------------------------------------------------
#error "805B590: call analysis failed (funcsize=163)"

//----- (0805B61E) --------------------------------------------------------
int __cdecl sub_805B61E(int a1, int a2, int a3)
{
  return sub_805B36A(a1, a2, a1 + 4 * a2, a3);
}
// 805B36A: using guessed type _DWORD __cdecl sub_805B36A(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0805B672) --------------------------------------------------------
int __cdecl sub_805B672(int a1, int a2, int a3)
{
  int v3; // eax

  while ( 1 )
  {
    v3 = a3--;
    if ( !v3 )
      break;
    *(_BYTE *)(a1 + a3) = tolower(*(unsigned __int8 *)(a2 + a3));
  }
  return a1;
}

//----- (0805B6B2) --------------------------------------------------------
int __cdecl sub_805B6B2(int a1, int a2, int a3)
{
  int v3; // eax

  while ( 1 )
  {
    v3 = a3--;
    if ( !v3 )
      break;
    *(_BYTE *)(a1 + a3) = toupper(*(unsigned __int8 *)(a2 + a3));
  }
  return a1;
}

//----- (0805B6F2) --------------------------------------------------------
int __cdecl sub_805B6F2(int a1, int a2)
{
  int v3; // [esp-8h] [ebp-Ch]

  return v3 - (a1 - a2 + 382) % 7 + 3;
}

//----- (0805B75F) --------------------------------------------------------
int __cdecl sub_805B75F(int a1, int a2, int a3, int a4, int a5, int a6)
{
  char v7; // [esp+2Fh] [ebp-Dh]

  v7 = 0;
  return sub_805B7C8(a3, a4, a3, a4, 0, &v7, a5, a6);
}
// 805B7C8: using guessed type _DWORD __cdecl sub_805B7C8(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0805B7C8) --------------------------------------------------------
#error "805B90A: call analysis failed (funcsize=87)"

//----- (0805E550) --------------------------------------------------------
void __fastcall __noreturn sub_805E550(int a1, int a2, int a3)
{
  int (__cdecl *v3)(int, size_t); // eax
  int v4; // [esp+0h] [ebp-28h]

  v3 = (int (__cdecl *)(int, size_t))&loc_805E575;
  if ( a3 )
    v3 = sub_805E59F;
  dword_8071240 = (int)v3;
  sub_80649F8(a1, a2, v4);
  fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
  abort();
}
// 8071240: using guessed type int dword_8071240;

//----- (0805E59F) --------------------------------------------------------
#error "805E641: positive sp value has been found (funcsize=0)"

//----- (0805E642) --------------------------------------------------------
void *__cdecl sub_805E642(void *src)
{
  int *v1; // eax
  void *v2; // ST1C_4
  int v4; // [esp+18h] [ebp-10h]

  v4 = *__errno_location();
  if ( src )
    v1 = (int *)src;
  else
    v1 = &dword_80727C2;
  v2 = sub_8061372(v1, 0x30u);
  *__errno_location() = v4;
  return v2;
}
// 80727C2: using guessed type int dword_80727C2;

//----- (0805E684) --------------------------------------------------------
int __cdecl sub_805E684(int *a1)
{
  int *v1; // eax

  if ( a1 )
    v1 = a1;
  else
    v1 = &dword_80727C2;
  return *v1;
}
// 80727C2: using guessed type int dword_80727C2;

//----- (0805E69B) --------------------------------------------------------
int *__cdecl sub_805E69B(int *a1, int a2)
{
  int *result; // eax

  if ( a1 )
    result = a1;
  else
    result = &dword_80727C2;
  *result = a2;
  return result;
}
// 80727C2: using guessed type int dword_80727C2;

//----- (0805E6B5) --------------------------------------------------------
int __cdecl sub_805E6B5(int *a1, unsigned __int8 a2, char a3)
{
  int *v3; // eax
  int *v4; // ST08_4
  int v5; // ST10_4

  if ( a1 )
    v3 = a1;
  else
    v3 = &dword_80727C2;
  v4 = &v3[(a2 >> 5) + 2];
  v5 = ((unsigned int)*v4 >> (a2 & 0x1F)) & 1;
  *v4 ^= (v5 ^ a3 & 1) << (a2 & 0x1F);
  return v5;
}
// 80727C2: using guessed type int dword_80727C2;

//----- (0805E77F) --------------------------------------------------------
int *__cdecl sub_805E77F(int *a1, int a2, int a3)
{
  int *result; // eax

  if ( !a1 )
    a1 = &dword_80727C2;
  *a1 = 10;
  if ( !a2 || !a3 )
    abort();
  a1[10] = a2;
  result = a1;
  a1[11] = a3;
  return result;
}
// 80727C2: using guessed type int dword_80727C2;

//----- (0805E7C0) --------------------------------------------------------
_DWORD *__userpurge sub_805E7C0@<eax>(_DWORD *a1, int a2)
{
  int v3; // [esp+0h] [ebp-38h]
  int v4; // [esp+4h] [ebp-34h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]

  memset(&v3 - 14, 0, 0x30u);
  if ( a2 == 10 )
    abort();
  *a1 = a2;
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = v6;
  a1[4] = v7;
  a1[5] = v8;
  a1[6] = v9;
  a1[7] = v10;
  a1[8] = v11;
  a1[9] = v12;
  a1[10] = v13;
  a1[11] = v14;
  return a1;
}

//----- (0805E892) --------------------------------------------------------
const char *__cdecl sub_805E892(char *msgid, int a2)
{
  const char *result; // eax
  int v3; // edx
  int v4; // ecx
  char *v5; // [esp+18h] [ebp-10h]
  unsigned __int8 *v6; // [esp+1Ch] [ebp-Ch]

  v5 = gettext(msgid);
  if ( v5 != msgid )
    return v5;
  v6 = (unsigned __int8 *)sub_8063B32();
  if ( sub_8063451(v6, "UTF-8") )
  {
    if ( !sub_8063451(v6, "GB18030") )
    {
      *msgid;
      dword_80711F0 = (int)&locret_805E958;
      sub_8064BC6(v4, v3);
    }
    if ( a2 == 9 )
    {
      dword_80711F0 = (int)&locret_805E958;
      sub_8064BC6(v4, v3);
    }
    result = "'";
  }
  else if ( *msgid == 96 )
  {
    result = (const char *)&unk_8069966;
  }
  else
  {
    result = (const char *)&unk_806996A;
  }
  return result;
}
// 8063B32: using guessed type int sub_8063B32(void);
// 80711F0: using guessed type int dword_80711F0;

//----- (0805E95A) --------------------------------------------------------
#error "805F75B: call analysis failed (funcsize=1081)"

//----- (0805F796) --------------------------------------------------------
#error "805F799: positive sp value has been found (funcsize=0)"

//----- (0805F79D) --------------------------------------------------------
int __cdecl sub_805F79D(int a1, int a2, int a3, int a4, int *a5)
{
  int *v5; // eax
  int *v6; // ST34_4
  int v7; // ST38_4
  int v8; // ST3C_4

  if ( a5 )
    v5 = a5;
  else
    v5 = &dword_80727C2;
  v6 = v5;
  v7 = *__errno_location();
  v8 = sub_805E95A(a1, a2, a3, a4, *v6, v6[1], v6 + 2, v6[10], v6[11]);
  *__errno_location() = v7;
  return v8;
}
// 805E95A: using guessed type _DWORD __cdecl sub_805E95A(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80727C2: using guessed type int dword_80727C2;

//----- (0805F883) --------------------------------------------------------
#error "805F97B: call analysis failed (funcsize=73)"

//----- (0805F980) --------------------------------------------------------
#error "805F9E4: positive sp value has been found (funcsize=29)"

//----- (0805FA7F) --------------------------------------------------------
void *__cdecl sub_805FA7F(signed int a1, int a2, int a3, _DWORD *a4)
{
  int v4; // ecx
  void *v5; // eax
  size_t v6; // edx
  void *v7; // edx
  size_t v8; // ST4C_4
  bool v10; // [esp+37h] [ebp-21h]
  int *v11; // [esp+38h] [ebp-20h]
  void *ptr; // [esp+3Ch] [ebp-1Ch]
  int v13; // [esp+40h] [ebp-18h]
  int size; // [esp+44h] [ebp-14h]
  int v15; // [esp+48h] [ebp-10h]
  size_t v16; // [esp+4Ch] [ebp-Ch]

  v13 = *__errno_location();
  v11 = off_80713E8;
  if ( a1 < 0 )
    abort();
  if ( dword_80713DC <= a1 )
  {
    v10 = off_80713E8 == &dword_80713E0;
    if ( (unsigned int)a1 > 0xFFFFFFE )
      sub_80613C0();
    v5 = &loc_805FAF9;
    if ( !v10 )
      v5 = &loc_805FB00;
    dword_807122C = (int)v5;
    sub_8064A68(v4, 8 * (a1 + 1));
    v11 = (int *)sub_806129A(0, v6);
    off_80713E8 = v11;
    if ( v10 )
    {
      v7 = off_80713E4;
      *v11 = dword_80713E0;
      v11[1] = (int)v7;
    }
    memset(&v11[2 * dword_80713DC], 0, 8 * (a1 + 1 - dword_80713DC));
    dword_80713DC = a1 + 1;
  }
  v8 = v11[2 * a1];
  ptr = (void *)v11[2 * a1 + 1];
  v15 = a4[1] | 1;
  v16 = sub_805E95A(ptr, v11[2 * a1], a2, a3, *a4, v15, a4 + 2, a4[10], a4[11]);
  if ( v8 <= v16 )
  {
    size = v16 + 1;
    v11[2 * a1] = v16 + 1;
    if ( ptr != &unk_8072802 )
      free(ptr);
    ptr = sub_806125D(size);
    v11[2 * a1 + 1] = (int)ptr;
    sub_805E95A(ptr, size, a2, a3, *a4, v15, a4 + 2, a4[10], a4[11]);
  }
  *__errno_location() = v13;
  return ptr;
}
// 805E95A: using guessed type _DWORD __cdecl sub_805E95A(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8064A68: using guessed type double __fastcall sub_8064A68(_DWORD, _DWORD);
// 807122C: using guessed type int dword_807122C;
// 80713DC: using guessed type int dword_80713DC;
// 80713E0: using guessed type int dword_80713E0;
// 80713E4: using guessed type void *off_80713E4;
// 80713E8: using guessed type int *off_80713E8;

//----- (0805FD41) --------------------------------------------------------
void *__cdecl sub_805FD41(signed int a1, int a2)
{
  return sub_805FA7F(a1, a2, -1, &dword_80727C2);
}
// 80727C2: using guessed type int dword_80727C2;

//----- (0805FD6B) --------------------------------------------------------
void *__cdecl sub_805FD6B(signed int a1, int a2, int a3)
{
  return sub_805FA7F(a1, a2, a3, &dword_80727C2);
}
// 80727C2: using guessed type int dword_80727C2;

//----- (0805FDE1) --------------------------------------------------------
void *__cdecl sub_805FDE1(signed int a1, int a2, int a3)
{
  char v4; // [esp+10h] [ebp-38h]

  sub_805E7C0(&v4, a2);
  return sub_805FA7F(a1, a3, -1, &v4);
}

//----- (0805FE1F) --------------------------------------------------------
void *__cdecl sub_805FE1F(signed int a1, int a2, int a3, int a4)
{
  char v5; // [esp+10h] [ebp-38h]

  sub_805E7C0(&v5, a2);
  return sub_805FA7F(a1, a3, a4, &v5);
}

//----- (0805FE5C) --------------------------------------------------------
void *__cdecl sub_805FE5C(int a1, int a2)
{
  return sub_805FDE1(0, a1, a2);
}

//----- (0805FEDC) --------------------------------------------------------
void *__cdecl sub_805FEDC(int a1, int a2, unsigned __int8 a3)
{
  int v4; // [esp+0h] [ebp-58h]
  unsigned __int8 v5; // [esp+1Ch] [ebp-3Ch]
  int v6; // [esp+20h] [ebp-38h]
  int v7; // [esp+24h] [ebp-34h]
  int v8; // [esp+28h] [ebp-30h]
  int v9; // [esp+2Ch] [ebp-2Ch]
  int v10; // [esp+30h] [ebp-28h]
  int v11; // [esp+34h] [ebp-24h]
  int v12; // [esp+38h] [ebp-20h]
  int v13; // [esp+3Ch] [ebp-1Ch]
  int v14; // [esp+40h] [ebp-18h]
  int v15; // [esp+44h] [ebp-14h]
  int v16; // [esp+48h] [ebp-10h]
  int v17; // [esp+4Ch] [ebp-Ch]

  v5 = a3;
  v6 = dword_80727C2;
  v7 = dword_80727C6;
  v8 = dword_80727CA;
  v9 = dword_80727CE;
  v10 = dword_80727D2;
  v11 = dword_80727D6;
  v12 = dword_80727DA;
  v13 = dword_80727DE;
  v14 = dword_80727E2;
  v15 = dword_80727E6;
  v16 = dword_80727EA;
  v17 = dword_80727EE;
  sub_805E6B5(&v4 - 14, a3, 1);
  return sub_805FA7F(0, a1, a2, &v6);
}
// 80727C2: using guessed type int dword_80727C2;
// 80727C6: using guessed type int dword_80727C6;
// 80727CA: using guessed type int dword_80727CA;
// 80727CE: using guessed type int dword_80727CE;
// 80727D2: using guessed type int dword_80727D2;
// 80727D6: using guessed type int dword_80727D6;
// 80727DA: using guessed type int dword_80727DA;
// 80727DE: using guessed type int dword_80727DE;
// 80727E2: using guessed type int dword_80727E2;
// 80727E6: using guessed type int dword_80727E6;
// 80727EA: using guessed type int dword_80727EA;
// 80727EE: using guessed type int dword_80727EE;

//----- (0805FFB6) --------------------------------------------------------
void *__cdecl sub_805FFB6(int a1, unsigned __int8 a2)
{
  return sub_805FEDC(a1, -1, a2);
}

//----- (0805FFEF) --------------------------------------------------------
void *__cdecl sub_805FFEF(int a1)
{
  return sub_805FFB6(a1, 0x3Au);
}

//----- (0806002C) --------------------------------------------------------
void *__cdecl sub_806002C(signed int a1, int a2, int a3)
{
  int v4; // [esp+0h] [ebp-78h]
  int v5; // [esp+10h] [ebp-68h]
  int v6; // [esp+14h] [ebp-64h]
  int v7; // [esp+18h] [ebp-60h]
  int v8; // [esp+1Ch] [ebp-5Ch]
  int v9; // [esp+20h] [ebp-58h]
  int v10; // [esp+24h] [ebp-54h]
  int v11; // [esp+28h] [ebp-50h]
  int v12; // [esp+2Ch] [ebp-4Ch]
  int v13; // [esp+30h] [ebp-48h]
  int v14; // [esp+34h] [ebp-44h]
  int v15; // [esp+38h] [ebp-40h]
  int v16; // [esp+3Ch] [ebp-3Ch]
  int v17; // [esp+40h] [ebp-38h]
  int v18; // [esp+44h] [ebp-34h]
  int v19; // [esp+48h] [ebp-30h]
  int v20; // [esp+4Ch] [ebp-2Ch]
  int v21; // [esp+50h] [ebp-28h]
  int v22; // [esp+54h] [ebp-24h]
  int v23; // [esp+58h] [ebp-20h]
  int v24; // [esp+5Ch] [ebp-1Ch]
  int v25; // [esp+60h] [ebp-18h]
  int v26; // [esp+64h] [ebp-14h]
  int v27; // [esp+68h] [ebp-10h]
  int v28; // [esp+6Ch] [ebp-Ch]

  sub_805E7C0(&v5, a2);
  v17 = v5;
  v18 = v6;
  v19 = v7;
  v20 = v8;
  v21 = v9;
  v22 = v10;
  v23 = v11;
  v24 = v12;
  v25 = v13;
  v26 = v14;
  v27 = v15;
  v28 = v16;
  sub_805E6B5(&v4 - 14, 0x3Au, 1);
  return sub_805FA7F(a1, a3, -1, &v17);
}

//----- (080600ED) --------------------------------------------------------
#error "806011A: call analysis failed (funcsize=15)"

//----- (0806011F) --------------------------------------------------------
#error "8060141: positive sp value has been found (funcsize=0)"

//----- (0806014C) --------------------------------------------------------
void *__cdecl sub_806014C(signed int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [esp+0h] [ebp-48h]
  int v7; // [esp+10h] [ebp-38h]
  int v8; // [esp+14h] [ebp-34h]
  int v9; // [esp+18h] [ebp-30h]
  int v10; // [esp+1Ch] [ebp-2Ch]
  int v11; // [esp+20h] [ebp-28h]
  int v12; // [esp+24h] [ebp-24h]
  int v13; // [esp+28h] [ebp-20h]
  int v14; // [esp+2Ch] [ebp-1Ch]
  int v15; // [esp+30h] [ebp-18h]
  int v16; // [esp+34h] [ebp-14h]
  int v17; // [esp+38h] [ebp-10h]
  int v18; // [esp+3Ch] [ebp-Ch]

  v7 = dword_80727C2;
  v8 = dword_80727C6;
  v9 = dword_80727CA;
  v10 = dword_80727CE;
  v11 = dword_80727D2;
  v12 = dword_80727D6;
  v13 = dword_80727DA;
  v14 = dword_80727DE;
  v15 = dword_80727E2;
  v16 = dword_80727E6;
  v17 = dword_80727EA;
  v18 = dword_80727EE;
  sub_805E77F(&v6 - 14, a2, a3);
  return sub_805FA7F(a1, a4, a5, &v7);
}
// 80727C2: using guessed type int dword_80727C2;
// 80727C6: using guessed type int dword_80727C6;
// 80727CA: using guessed type int dword_80727CA;
// 80727CE: using guessed type int dword_80727CE;
// 80727D2: using guessed type int dword_80727D2;
// 80727D6: using guessed type int dword_80727D6;
// 80727DA: using guessed type int dword_80727DA;
// 80727DE: using guessed type int dword_80727DE;
// 80727E2: using guessed type int dword_80727E2;
// 80727E6: using guessed type int dword_80727E6;
// 80727EA: using guessed type int dword_80727EA;
// 80727EE: using guessed type int dword_80727EE;

//----- (08060296) --------------------------------------------------------
void *__cdecl sub_8060296(signed int a1, int a2, int a3)
{
  return sub_805FA7F(a1, a2, a3, &unk_80713FC);
}

//----- (080602F1) --------------------------------------------------------
void *__cdecl sub_80602F1(signed int a1, int a2)
{
  return sub_8060296(a1, a2, -1);
}

//----- (08060313) --------------------------------------------------------
void *__cdecl sub_8060313(int a1)
{
  return sub_80602F1(0, a1);
}

//----- (0806032E) --------------------------------------------------------
_BOOL4 __usercall sub_806032E@<eax>(int a1@<edx>, int a2@<ecx>, void *src, void *a4)
{
  int v4; // edx
  int v5; // ecx
  size_t v6; // ST20_4
  int v7; // edx
  int v8; // ecx
  bool v9; // al
  int v10; // edx
  int v11; // ecx
  int *v12; // eax
  int *v13; // eax
  bool v14; // al
  bool v16; // [esp+15h] [ebp-E3h]
  char *s1; // [esp+18h] [ebp-E0h]
  char *s2; // [esp+1Ch] [ebp-DCh]
  size_t n; // [esp+24h] [ebp-D4h]
  void *ptr; // [esp+28h] [ebp-D0h]
  void *v21; // [esp+2Ch] [ebp-CCh]
  __int64 v22; // [esp+30h] [ebp-C8h]
  __int64 v23; // [esp+88h] [ebp-70h]
  __int64 v24; // [esp+90h] [ebp-68h]
  __int64 v25; // [esp+E8h] [ebp-10h]

  s1 = sub_8056733(a1, a2, src);
  s2 = sub_8056733(v4, v5, a4);
  v6 = sub_80567A7(s1);
  n = sub_80567A7(s2);
  v9 = v6 == n && !memcmp(s1, s2, n);
  v16 = 0;
  if ( v9 )
  {
    ptr = sub_80635A2(v7, v8, src);
    v21 = sub_80635A2(v10, v11, a4);
    if ( sub_80647DD((int)ptr, (int)&v22) )
    {
      v12 = __errno_location();
      error(1, *v12, "%s", ptr);
    }
    if ( sub_80647DD((int)v21, (int)&v24) )
    {
      v13 = __errno_location();
      error(1, *v13, "%s", v21);
    }
    v14 = v23 == v25 && v22 == v24;
    v16 = v14;
    free(ptr);
    free(v21);
  }
  return v16;
}

//----- (0806052E) --------------------------------------------------------
void sub_806052E()
{
  ;
}

//----- (0806057B) --------------------------------------------------------
signed int sub_806057B()
{
  *__errno_location() = 95;
  return -1;
}

//----- (08060593) --------------------------------------------------------
signed int sub_8060593()
{
  *__errno_location() = 95;
  return -1;
}

//----- (080606CD) --------------------------------------------------------
_DWORD *__userpurge sub_80606CD@<eax>(_DWORD *a1, int a2)
{
  int v2; // edx

  v2 = *(_DWORD *)(a2 + 68);
  *a1 = *(_DWORD *)(a2 + 64);
  a1[1] = v2;
  return a1;
}

//----- (080606F8) --------------------------------------------------------
_DWORD *__userpurge sub_80606F8@<eax>(_DWORD *a1, int a2)
{
  int v2; // edx

  v2 = *(_DWORD *)(a2 + 84);
  *a1 = *(_DWORD *)(a2 + 80);
  a1[1] = v2;
  return a1;
}

//----- (08060733) --------------------------------------------------------
_DWORD *__userpurge sub_8060733@<eax>(_DWORD *a1, int a2)
{
  int v2; // edx

  v2 = *(_DWORD *)(a2 + 76);
  *a1 = *(_DWORD *)(a2 + 72);
  a1[1] = v2;
  return a1;
}

//----- (080607EE) --------------------------------------------------------
#error "8060824: call analysis failed (funcsize=25)"

//----- (080608BA) --------------------------------------------------------
#error "8060C97: call analysis failed (funcsize=470)"

//----- (0806102D) --------------------------------------------------------
int __cdecl sub_806102D(FILE *stream, int a2, int a3, int a4, int a5)
{
  int *v5; // eax
  unsigned int i; // [esp+24h] [ebp-34h]
  int v8[12]; // [esp+28h] [ebp-30h]

  for ( i = 0; i <= 9; ++i )
  {
    v5 = (int *)a5;
    a5 += 4;
    v8[i] = *v5;
    if ( !v8[i] )
      break;
  }
  return sub_80608BA(stream, a2, a3, a4, (int)v8, i);
}
// 806102D: using guessed type int var_30[12];

//----- (080610A3) --------------------------------------------------------
int sub_80610A3(FILE *stream, int a2, int a3, int a4, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a4);
  return sub_806102D(stream, a2, a3, a4, (int)va);
}

//----- (08061163) --------------------------------------------------------
void *__cdecl sub_8061163(unsigned int a1, unsigned int a2)
{
  if ( 0x7FFFFFFF / a2 < a1 )
    sub_80613C0();
  return sub_8061270(a2 * a1);
}

//----- (08061191) --------------------------------------------------------
void *__cdecl sub_8061191(void *ptr, int a2, int a3)
{
  if ( 0x7FFFFFFFu / a3 < a2 )
    sub_80613C0();
  return sub_806129A(ptr, a3 * a2);
}

//----- (080611C6) --------------------------------------------------------
void *__cdecl sub_80611C6(void *ptr, int a2, int a3)
{
  unsigned int v4; // [esp+1Ch] [ebp-Ch]

  v4 = *(_DWORD *)a2;
  if ( ptr )
  {
    if ( 0x55555554u / a3 <= v4 )
      sub_80613C0();
    v4 += (v4 >> 1) + 1;
  }
  else
  {
    if ( !v4 )
      v4 = (0x40u / a3 == 0) + 0x40u / a3;
    if ( 0x7FFFFFFFu / a3 < v4 )
      sub_80613C0();
  }
  *(_DWORD *)a2 = v4;
  return sub_806129A(ptr, a3 * v4);
}

//----- (0806125D) --------------------------------------------------------
void *__cdecl sub_806125D(size_t size)
{
  return sub_8061270(size);
}

//----- (08061270) --------------------------------------------------------
void *__cdecl sub_8061270(size_t size)
{
  void *v2; // [esp+1Ch] [ebp-Ch]

  v2 = malloc(size);
  if ( !v2 && size )
    sub_80613C0();
  return v2;
}

//----- (0806129A) --------------------------------------------------------
void *__cdecl sub_806129A(void *ptr, size_t size)
{
  void *result; // eax
  void *ptra; // [esp+20h] [ebp+8h]

  if ( size || !ptr )
  {
    ptra = realloc(ptr, size);
    if ( !ptra )
    {
      if ( size )
        sub_80613C0();
    }
    result = ptra;
  }
  else
  {
    free(ptr);
    result = 0;
  }
  return result;
}

//----- (080612E9) --------------------------------------------------------
void *__cdecl sub_80612E9(void *ptr, int a2)
{
  return sub_80611C6(ptr, a2, 1);
}

//----- (08061372) --------------------------------------------------------
void *__cdecl sub_8061372(void *src, size_t n)
{
  void *v2; // eax

  v2 = sub_8061270(n);
  return memcpy(v2, src, n);
}

//----- (0806139B) --------------------------------------------------------
void *__cdecl sub_806139B(char *s)
{
  size_t v1; // eax

  v1 = strlen(s);
  return sub_8061372(s, v1 + 1);
}

//----- (080613C0) --------------------------------------------------------
void __noreturn sub_80613C0()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (080613F9) --------------------------------------------------------
#error "8061416: call analysis failed (funcsize=11)"

//----- (0806141B) --------------------------------------------------------
#error "806156B: positive sp value has been found (funcsize=100)"

//----- (08061600) --------------------------------------------------------
char *sub_8061600()
{
  char *v1; // [esp+1Ch] [ebp-Ch]

  v1 = getcwd(0, 0);
  if ( !v1 && *__errno_location() == 12 )
    sub_80613C0();
  return v1;
}

//----- (08061639) --------------------------------------------------------
int sub_8061639()
{
  int v0; // ecx
  bool v1; // zf
  int v2; // edx
  int v3; // ecx
  void *v4; // eax
  int v5; // edx
  int v6; // ecx
  void *v7; // eax
  int v9; // [esp+10h] [ebp-18h]
  char *name; // [esp+14h] [ebp-14h]
  size_t len; // [esp+18h] [ebp-10h]
  int v12; // [esp+1Ch] [ebp-Ch]

  name = 0;
  v9 = 34;
  while ( 1 )
  {
    name = (char *)sub_80612E9(name, (int)&v9);
    len = v9 - 1;
    name[v9 - 2] = 0;
    *__errno_location() = 0;
    if ( gethostname(name, len) )
      goto LABEL_5;
    if ( !name[len - 1] )
    {
      dword_80711DC = (int)&locret_8061756;
      sub_8064C3E(v0, len - 1);
LABEL_5:
      v1 = *__errno_location() == 0;
      v4 = &loc_80616EE;
      if ( v1 )
        v4 = &loc_8061751;
      dword_80711DC = (int)v4;
      sub_8064C3E(v3, v2);
      v1 = *__errno_location() == 36;
      v7 = &loc_8061713;
      if ( v1 )
        v7 = &loc_8061751;
      dword_80711DC = (int)v7;
      sub_8064C3E(v6, v5);
      if ( *__errno_location() != 22 && *__errno_location() != 12 )
        break;
    }
  }
  v12 = *__errno_location();
  free(name);
  *__errno_location() = v12;
  return 0;
}
// 8061639: could not find valid save-restore pair for ebx
// 8064C3E: using guessed type int __fastcall sub_8064C3E(_DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;

//----- (08061758) --------------------------------------------------------
signed int __cdecl sub_8061758(unsigned int *a1, unsigned int a2)
{
  signed int result; // eax

  if ( 0xFFFFFFFF / a2 >= *a1 )
  {
    *a1 *= a2;
    result = 0;
  }
  else
  {
    *a1 = -1;
    result = 1;
  }
  return result;
}

//----- (080617AC) --------------------------------------------------------
int __cdecl sub_80617AC(int a1)
{
  dword_8071268 = (int (__cdecl *)(_DWORD))&loc_80617E1;
  return ((int (__cdecl *)(int))loc_80617E1)(a1);
}
// 8071268: using guessed type int (__cdecl *dword_8071268)(_DWORD);

//----- (080617CC) --------------------------------------------------------
#error "8061804: positive sp value has been found (funcsize=16)"

//----- (08061805) --------------------------------------------------------
#error "8061A1D: call analysis failed (funcsize=293)"

//----- (08061C1B) --------------------------------------------------------
void __usercall sub_8061C1B(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, int a6, int a7, int status)
{
  char *v8; // eax
  const char *v9; // [esp+Ch] [ebp-2Ch]
  char *v10; // [esp+10h] [ebp-28h]
  int v11; // [esp+14h] [ebp-24h]
  char v12; // [esp+1Ch] [ebp-1Ch]
  char v13; // [esp+22h] [ebp-16h]
  char v14; // [esp+23h] [ebp-15h]
  const char *v15; // [esp+24h] [ebp-14h]
  char *msgid; // [esp+28h] [ebp-10h]
  char *v17; // [esp+2Ch] [ebp-Ch]

  v12 = a5;
  v15 = "--";
  if ( (unsigned int)a3 > 3 )
  {
    if ( a3 != 4 )
      goto LABEL_6;
    msgid = "invalid %s%s argument '%s'";
  }
  else if ( (unsigned int)a3 >= 2 )
  {
    msgid = "invalid suffix in %s%s argument '%s'";
  }
  else
  {
    if ( a3 != 1 )
LABEL_6:
      abort();
    msgid = "%s%s argument '%s' too large";
  }
  if ( a4 < 0 )
  {
    v15 -= a4;
    v13 = v12;
    v14 = 0;
    v17 = &v13;
    dword_80711DC = (int)&loc_8061CAD;
    sub_8064C3E(a2, a1);
  }
  v17 = *(char **)(16 * a4 + a6);
  v8 = gettext(msgid);
  v11 = a7;
  v10 = v17;
  v9 = v15;
  error(status, 0, v8, v15, v17, a7);
}
// 8064C3E: using guessed type int __fastcall sub_8064C3E(_DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;

//----- (08061D06) --------------------------------------------------------
void __fastcall __noreturn sub_8061D06(int a1, int a2, int a3, int a4, char a5, int a6, int a7)
{
  sub_8061C1B(a6, a1, a3, a4, a5, a6, a7, status);
  abort();
}

//----- (08061D69) --------------------------------------------------------
signed int __cdecl sub_8061D69(int a1, int a2)
{
  unsigned __int64 v2; // rcx
  int v3; // edx
  signed int result; // eax

  LODWORD(v2) = sub_80642CB(-1, -1, a2, a2 >> 31);
  HIDWORD(v2) = v3;
  if ( v2 >= *(_QWORD *)a1 )
  {
    *(_QWORD *)a1 *= a2;
    result = 0;
  }
  else
  {
    *(_DWORD *)a1 = -1;
    *(_DWORD *)(a1 + 4) = -1;
    result = 1;
  }
  return result;
}
// 80642CB: using guessed type _DWORD __cdecl sub_80642CB(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08061E35) --------------------------------------------------------
int __cdecl sub_8061E35(int a1, int a2, int a3)
{
  int v3; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; ; i |= sub_8061D69(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}

//----- (08061E6B) --------------------------------------------------------
#error "806229D: call analysis failed (funcsize=310)"

//----- (080622C6) --------------------------------------------------------
int __cdecl sub_80622C6(wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  unsigned __int8 v5; // al
  wchar_t v6; // [esp+18h] [ebp-10h]
  size_t v7; // [esp+1Ch] [ebp-Ch]

  dword_8071268 = (int (__cdecl *)(_DWORD))&loc_80622EA;
  if ( !pwc )
  {
    pwc = &v6;
    v7 = mbrtowc(&v6, s, n, p);
    dword_8071268 = (int (__cdecl *)(_DWORD))sub_806239C;
    if ( v7 > 0xFFFFFFFD )
    {
      dword_8071268 = (int (__cdecl *)(_DWORD))sub_806239C;
      if ( n )
      {
        v5 = sub_80573D3(0);
        dword_8071268 = (int (__cdecl *)(_DWORD))sub_806239C;
        if ( v5 ^ 1 )
        {
          v6 = (unsigned __int8)*s;
          dword_8071268 = (int (__cdecl *)(_DWORD))&locret_806239F;
        }
      }
    }
  }
  return dword_8071268(pwc);
}
// 806239C: using guessed type int sub_806239C();
// 8071268: using guessed type int (__cdecl *dword_8071268)(_DWORD);

//----- (0806239C) --------------------------------------------------------
#error "80623A0: positive sp value has been found (funcsize=0)"

//----- (080623A1) --------------------------------------------------------
int __cdecl sub_80623A1(int a1, int a2)
{
  int v2; // edx
  int v3; // ecx

  if ( *(_BYTE *)(a1 + 40) & 1 )
  {
    (*(void (__cdecl **)(_DWORD, int))(a1 + 28))(*(_DWORD *)(a1 + 36), a2);
    dword_80711F0 = (int)&locret_80623F2;
    sub_8064BC6(v3, v2);
  }
  return (*(int (__cdecl **)(int))(a1 + 28))(a2);
}
// 80711F0: using guessed type int dword_80711F0;

//----- (080623F4) --------------------------------------------------------
int __cdecl sub_80623F4(int a1, int a2)
{
  int result; // eax

  if ( *(_BYTE *)(a1 + 40) & 1 )
    result = (*(int (__cdecl **)(_DWORD, int))(a1 + 32))(*(_DWORD *)(a1 + 36), a2);
  else
    result = (*(int (__cdecl **)(int))(a1 + 32))(a2);
  return result;
}

//----- (08062432) --------------------------------------------------------
#error "8062452: call analysis failed (funcsize=93)"

//----- (0806256A) --------------------------------------------------------
int __cdecl sub_806256A(int a1, int a2, int a3, int a4, int a5)
{
  *(_DWORD *)(a1 + 28) = a4;
  *(_DWORD *)(a1 + 32) = a5;
  *(_BYTE *)(a1 + 40) &= 0xFEu;
  return sub_8062432(a1, a2, a3);
}
// 8062432: using guessed type _DWORD __cdecl sub_8062432(_DWORD, _DWORD, _DWORD);

//----- (08062648) --------------------------------------------------------
#error "8062749: call analysis failed (funcsize=87)"

//----- (0806275C) --------------------------------------------------------
#error "80627A3: call analysis failed (funcsize=26)"

//----- (080627A8) --------------------------------------------------------
#error "8062877: positive sp value has been found (funcsize=64)"

//----- (080629FC) --------------------------------------------------------
int __cdecl sub_80629FC(int a1, int a2)
{
  return (a1 == 0) ^ (a2 == 0) && a1 >= 0 && a2 >= 0;
}

//----- (08062A30) --------------------------------------------------------
_BOOL4 __cdecl sub_8062A30(_DWORD *a1, _DWORD *a2)
{
  int v2; // ebx

  v2 = a1[5] ^ a2[5] | a1[4] ^ a2[4] | a1[3] ^ a2[3] | a1[2] ^ a2[2] | a1[1] ^ a2[1] | *a2 ^ *a1;
  return (v2 | (unsigned __int8)sub_80629FC(a1[8], a2[8])) == 0;
}

//----- (08062AE2) --------------------------------------------------------
char *__cdecl sub_8062AE2(void *dest, void *src, size_t n)
{
  char *result; // eax

  memcpy(dest, src, n);
  result = (char *)dest + n;
  *((_BYTE *)dest + n) = 0;
  return result;
}

//----- (08062B0E) --------------------------------------------------------
char *__cdecl sub_8062B0E(char *s)
{
  size_t v1; // eax
  int v2; // eax
  size_t n; // [esp+14h] [ebp-14h]
  char *v5; // [esp+1Ch] [ebp-Ch]

  if ( s )
    v1 = strlen(s) + 1;
  else
    v1 = 0;
  n = v1;
  if ( v1 <= 0x3A )
    v2 = 59;
  else
    v2 = v1 + 1;
  v5 = (char *)malloc((v2 + 12) & 0xFFFFFFF8);
  if ( v5 )
  {
    *(_DWORD *)v5 = 0;
    v5[4] = s != 0;
    v5[5] = 0;
    if ( s )
      sub_8062AE2(v5 + 5, s, n);
  }
  return v5;
}

//----- (08062BB8) --------------------------------------------------------
signed int __cdecl sub_8062BB8(int a1, unsigned int a2)
{
  int i; // eax
  int v4; // edx
  int v5; // ecx
  void *v6; // eax
  char *s1; // [esp+10h] [ebp-18h]
  char *s; // [esp+14h] [ebp-14h]
  size_t n; // [esp+18h] [ebp-10h]
  int v10; // [esp+1Ch] [ebp-Ch]
  int v11; // [esp+30h] [ebp+8h]

  s1 = (char *)&unk_806A478;
  s = *(char **)(a2 + 40);
  if ( !s || a2 <= (unsigned int)s && a2 + 44 > (unsigned int)s )
    return 1;
  if ( *s )
  {
    s1 = (char *)(a1 + 5);
    for ( i = strcmp((const char *)(a1 + 5), s); i; i = strcmp(s1, s) )
    {
      if ( !*s1 && ((char *)(a1 + 5) != s1 || !*(_BYTE *)(a1 + 4)) )
      {
        n = strlen(s) + 1;
        v10 = (int)&s1[-a1 - 5];
        if ( ~v10 < n )
        {
          *__errno_location() = 12;
          return 0;
        }
        if ( v10 + n <= 0x3A )
        {
          sub_8062AE2(s1, s, n);
          break;
        }
        *(_DWORD *)a1 = sub_8062B0E(s);
        v11 = *(_DWORD *)a1;
        if ( !v11 )
          return 0;
        *(_BYTE *)(v11 + 4) = 0;
        s1 = (char *)(v11 + 5);
        break;
      }
      s1 += strlen(s1) + 1;
      v6 = &loc_8062D25;
      if ( *s1 )
        v6 = &loc_8062D3F;
      dword_80711F0 = (int)v6;
      sub_8064BC6(v5, v4);
      if ( *(_DWORD *)a1 )
      {
        a1 = *(_DWORD *)a1;
        s1 = (char *)(a1 + 5);
      }
    }
  }
  *(_DWORD *)(a2 + 40) = s1;
  return 1;
}
// 80711F0: using guessed type int dword_80711F0;

//----- (08062D69) --------------------------------------------------------
int __usercall sub_8062D69@<eax>(int a1@<edx>, int a2@<ecx>, void *ptr)
{
  int result; // eax
  void *v4; // eax
  int v5; // [esp+0h] [ebp-28h]

  result = 1;
  if ( ptr != (void *)1 )
  {
    v4 = &locret_8062DB3;
    if ( ptr )
      v4 = &loc_8062D7B;
    dword_8071240 = (int)v4;
    result = sub_80649F8(a2, a1, v5);
  }
  return result;
}
// 8071240: using guessed type int dword_8071240;

//----- (08062DB5) --------------------------------------------------------
char *sub_8062DB5()
{
  return getenv("TZ");
}

//----- (08062DC9) --------------------------------------------------------
int __cdecl sub_8062DC9(char *value)
{
  int result; // eax

  if ( value )
    result = setenv("TZ", value, 1);
  else
    result = unsetenv("TZ");
  return result;
}

//----- (08062E00) --------------------------------------------------------
signed int __cdecl sub_8062E00(int a1)
{
  char *v1; // eax

  if ( *(_BYTE *)(a1 + 4) )
    v1 = (char *)(a1 + 5);
  else
    v1 = 0;
  if ( sub_8062DC9(v1) )
    return 0;
  tzset();
  return 1;
}

//----- (08062E3D) --------------------------------------------------------
#error "8062E92: call analysis failed (funcsize=65)"

//----- (08062F08) --------------------------------------------------------
int __cdecl sub_8062F08(void *ptr)
{
  int v2; // ST24_4
  unsigned __int8 v3; // al
  int v4; // edx
  int v5; // ecx
  bool v6; // zf
  void *v7; // eax
  int v8; // ST24_4
  int v9; // edx
  int v10; // ecx
  unsigned __int8 v11; // [esp+1Bh] [ebp-Dh]

  if ( ptr == (void *)1 )
    return 1;
  v2 = *__errno_location();
  v3 = sub_8062E00((int)ptr);
  v11 = v3;
  v6 = v3 == 1;
  v7 = &loc_8062F5B;
  if ( v6 )
    v7 = &loc_8062F65;
  dword_80711DC = (int)v7;
  sub_8064C3E(v5, v4);
  v8 = *__errno_location();
  sub_8062D69(v9, v10, ptr);
  *__errno_location() = v8;
  return v11;
}
// 8064C3E: using guessed type int __fastcall sub_8064C3E(_DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;

//----- (08062F80) --------------------------------------------------------
#error "806301C: call analysis failed (funcsize=53)"

//----- (0806302C) --------------------------------------------------------
time_t __cdecl sub_806302C(int a1, struct tm *tp)
{
  int v3; // [esp+0h] [ebp-58h]
  int v4; // [esp+4h] [ebp-54h]
  int v5; // [esp+8h] [ebp-50h]
  int v6; // [esp+Ch] [ebp-4Ch]
  int v7; // [esp+10h] [ebp-48h]
  int v8; // [esp+14h] [ebp-44h]
  time_t timer; // [esp+18h] [ebp-40h]
  void *ptr; // [esp+1Ch] [ebp-3Ch]
  time_t v11; // [esp+20h] [ebp-38h]
  struct tm v12; // [esp+24h] [ebp-34h]
  int v13; // [esp+50h] [ebp-8h]
  int v14; // [esp+54h] [ebp-4h]
  int savedregs; // [esp+58h] [ebp+0h]

  if ( !a1 )
    return timegm(tp);
  ptr = (void *)sub_8062E3D(a1);
  if ( ptr )
  {
    timer = mktime(tp);
    v11 = -1;
    if ( timer != -1 || localtime_r(&timer, &v12) && sub_8062A30(tp, &v12) )
    {
      if ( (unsigned __int8)sub_8062BB8(a1, (unsigned int)tp) ^ 1 )
        timer = v11;
    }
    if ( (unsigned __int8)sub_8062F08(ptr) )
    {
      dword_8071218 = (int)&locret_80630F6;
      sub_8064ADE(
        v3,
        v4,
        v5,
        v6,
        v7,
        v8,
        timer,
        ptr,
        v11,
        v12.tm_sec,
        v12.tm_min,
        v12.tm_hour,
        v12.tm_mday,
        v12.tm_mon,
        v12.tm_year,
        v12.tm_wday,
        v12.tm_yday,
        v12.tm_isdst,
        v12.tm_gmtoff,
        v12.tm_zone,
        v13,
        v14,
        savedregs);
    }
  }
  return -1;
}
// 8062E3D: using guessed type _DWORD __cdecl sub_8062E3D(_DWORD);
// 8064ADE: using guessed type int __stdcall sub_8064ADE(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8071218: using guessed type int dword_8071218;

//----- (0806329C) --------------------------------------------------------
int __cdecl sub_806329C(int a1, char a2)
{
  return __ROR4__(a1, a2);
}

//----- (08063451) --------------------------------------------------------
int __cdecl sub_8063451(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // esi
  unsigned __int8 *v3; // ebx
  unsigned __int8 v5; // [esp+1Eh] [ebp-Ah]
  unsigned __int8 v6; // [esp+1Fh] [ebp-9h]

  v2 = a1;
  v3 = a2;
  if ( a1 == a2 )
    return 0;
  do
  {
    v5 = sub_8055A64(*v2);
    v6 = sub_8055A64(*v3);
    if ( !v5 )
      break;
    ++v2;
    ++v3;
  }
  while ( v5 == v6 );
  return v5 - v6;
}

//----- (080634B6) --------------------------------------------------------
int __cdecl sub_80634B6(FILE *fp)
{
  bool v2; // ST1E_1
  int v3; // eax
  bool v4; // [esp+1Dh] [ebp-Bh]
  bool v5; // [esp+1Fh] [ebp-9h]

  v4 = __fpending(fp) != 0;
  v2 = ferror_unlocked(fp) != 0;
  v5 = sub_8063C13(fp) != 0;
  dword_8071268 = (int (__cdecl *)(_DWORD))&loc_806355B;
  if ( !v2 )
  {
    dword_8071268 = (int (__cdecl *)(_DWORD))sub_806359B;
    if ( v5 )
    {
      dword_8071268 = (int (__cdecl *)(_DWORD))&loc_806355B;
      if ( !v4 )
      {
        v3 = *__errno_location();
        dword_8071268 = (int (__cdecl *)(_DWORD))sub_806359B;
        if ( v3 != 9 )
        {
          dword_8071268 = (int (__cdecl *)(_DWORD))&loc_8063583;
          if ( v5 != 1 )
          {
            *__errno_location() = 0;
            dword_8071268 = (int (__cdecl *)(_DWORD))&locret_80635A0;
          }
        }
      }
    }
  }
  return dword_8071268(fp);
}
// 806359B: using guessed type int sub_806359B();
// 8071268: using guessed type int (__cdecl *dword_8071268)(_DWORD);

//----- (0806359B) --------------------------------------------------------
#error "80635A1: positive sp value has been found (funcsize=0)"

//----- (080635A2) --------------------------------------------------------
void *__usercall sub_80635A2@<eax>(int a1@<edx>, int a2@<ecx>, void *src)
{
  void *v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_8056698(a1, a2, src);
  if ( !v4 )
    sub_80613C0();
  return v4;
}

//----- (080635C6) --------------------------------------------------------
int __cdecl sub_80635C6(_BYTE *a1, unsigned int a2)
{
  _BYTE *i; // [esp+8h] [ebp-8h]
  unsigned int v4; // [esp+Ch] [ebp-4h]

  v4 = 0;
  for ( i = a1; *i; ++i )
    v4 = __ROR4__(v4, 23) + (char)*i;
  return v4 % a2;
}

//----- (0806360C) --------------------------------------------------------
#error "806361B: call analysis failed (funcsize=11)"

//----- (0806362E) --------------------------------------------------------
#error "8063B31: positive sp value has been found (funcsize=278)"

//----- (08063B32) --------------------------------------------------------
#error "8063BF8: call analysis failed (funcsize=32)"

//----- (08063C13) --------------------------------------------------------
int __cdecl sub_8063C13(FILE *stream)
{
  int v2; // eax
  __int64 v3; // rax
  int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]

  v4 = 0;
  if ( fileno(stream) < 0 )
    return fclose(stream);
  if ( !__freading(stream) || (v2 = fileno(stream), LODWORD(v3) = lseek64(v2, 0, 0, 1), v3 != -1) )
  {
    if ( sub_8063D0F(stream) )
      v4 = *__errno_location();
  }
  v5 = fclose(stream);
  if ( v4 )
  {
    *__errno_location() = v4;
    v5 = -1;
  }
  return v5;
}
// 8049A70: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08063CD6) --------------------------------------------------------
int __cdecl sub_8063CD6(FILE *stream)
{
  int result; // eax

  result = stream->_flags & 0x100;
  if ( result )
    result = sub_8063D4F(stream, 0, 0, 1);
  return result;
}

//----- (08063D0F) --------------------------------------------------------
int __cdecl sub_8063D0F(FILE *fp)
{
  if ( !fp || !__freading(fp) )
    return fflush(fp);
  sub_8063CD6(fp);
  return fflush(fp);
}

//----- (08063D4F) --------------------------------------------------------
int __cdecl sub_8063D4F(FILE *stream, int a2, int a3, int a4)
{
  int v4; // eax
  __off64_t v5; // rax
  int v7; // [esp-18h] [ebp-38h]

  if ( stream->_IO_read_end == stream->_IO_read_ptr
    && stream->_IO_write_ptr == stream->_IO_write_base
    && !stream->_IO_save_base )
  {
    v4 = fileno(stream);
    LODWORD(v5) = lseek64(v4, a2, a3, a4);
    if ( v5 == -1 )
      return -1;
    stream->_flags &= 0xFFFFFFEF;
    stream->_offset = v5;
    dword_8071240 = (int)&locret_8063E7C;
    sub_80649F8(stream, HIDWORD(v5), v7);
  }
  return fseeko64(stream, a2, a3, a4);
}
// 8049610: using guessed type int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8049A70: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8071240: using guessed type int dword_8071240;

//----- (08063E82) --------------------------------------------------------
signed __int64 __cdecl sub_8063E82(__int64 a1, unsigned int a2, signed int a3)
{
  int v3; // edx
  unsigned int v4; // ecx
  unsigned int v5; // esi
  unsigned int v6; // edi
  int *v7; // ebp
  unsigned int v8; // eax
  int v9; // ecx
  signed __int64 result; // rax
  unsigned __int64 v11; // rtt
  int v12; // edi
  unsigned int v13; // edx
  unsigned int v14; // esi
  unsigned int v15; // ebp
  unsigned int v16; // esi
  unsigned __int64 v17; // rax
  int v18; // [esp+0h] [ebp-1Ch]
  unsigned int v19; // [esp+4h] [ebp-18h]
  unsigned int v20; // [esp+8h] [ebp-14h]
  unsigned int v21; // [esp+Ch] [ebp-10h]

  v3 = a1;
  v18 = 0;
  v19 = a2;
  v4 = HIDWORD(a1);
  if ( a1 < 0 )
  {
    v3 = -(signed int)a1;
    v5 = v19;
    v6 = a3;
    v4 = (unsigned __int64)-a1 >> 32;
    v18 = -1;
    if ( a3 >= 0 )
      goto LABEL_3;
  }
  else
  {
    v5 = v19;
    v6 = a3;
    if ( a3 >= 0 )
      goto LABEL_3;
  }
  v5 = -v5;
  v18 = ~v18;
  v6 = (unsigned __int64)-(signed __int64)__PAIR__(v6, v5) >> 32;
LABEL_3:
  v7 = (int *)v4;
  v20 = v3;
  v8 = v6;
  v19 = v5;
  if ( v6 )
  {
    if ( v6 > v4 )
      goto LABEL_7;
  }
  else
  {
    if ( v5 > v4 )
    {
      v9 = __PAIR__(v4, v3) / v5;
      goto LABEL_8;
    }
    if ( !v5 )
      v5 = 1 / 0u;
    LODWORD(v11) = v3;
    HIDWORD(v11) = v4 % v5;
    dword_807122C = (int)&loc_8063F09;
    sub_8064A68(v11 / v5, v11 % v5);
    v7 = &v18;
  }
  _BitScanReverse(&v6, v6);
  v12 = v6 ^ 0x1F;
  if ( !v12 )
  {
    if ( v19 <= v20 || v8 < (unsigned int)v7 )
    {
      v9 = 1;
      goto LABEL_8;
    }
LABEL_7:
    v9 = 0;
    goto LABEL_8;
  }
  v21 = (v8 << v12) | (v19 >> (32 - v12));
  v19 <<= v12;
  v13 = (unsigned int)&v18 >> (32 - v12);
  v14 = ((_DWORD)&v18 << v12) | (v20 >> (32 - v12));
  v15 = __PAIR__(v13, v14) % v21;
  v16 = __PAIR__(v13, v14) / v21;
  v17 = v19 * (unsigned __int64)v16;
  v19 = HIDWORD(v17);
  if ( v15 >= HIDWORD(v17) && (v20 << v12 >= (unsigned int)v17 || v15 != v19) )
  {
    dword_80711F0 = (int)&loc_8063F09;
    sub_8064BC6(v16, v20 << v12);
  }
  v9 = v16 - 1;
LABEL_8:
  result = (unsigned int)v9;
  if ( v18 )
    result = -(signed __int64)(unsigned int)v9;
  return result;
}
// 8064A68: using guessed type double __fastcall sub_8064A68(_DWORD, _DWORD);
// 80711F0: using guessed type int dword_80711F0;
// 807122C: using guessed type int dword_807122C;

//----- (08064070) --------------------------------------------------------
#error "80640CF: call analysis failed (funcsize=42)"

//----- (080642CB) --------------------------------------------------------
#error "8064320: call analysis failed (funcsize=60)"

//----- (0806452F) --------------------------------------------------------
__int64 __cdecl sub_806452F(int a1, unsigned int a2, unsigned int a3, int a4)
{
  void *v4; // eax
  unsigned int v5; // ecx
  unsigned int v6; // edx
  unsigned int v8; // ebp
  unsigned __int64 v9; // rtt

  v4 = &loc_8064599;
  if ( a4 )
    v4 = &loc_80645B0;
  dword_80711F0 = (int)v4;
  sub_8064BC6(a1, a4);
  if ( a3 <= a2 )
  {
    v8 = a3;
    if ( !a3 )
      v8 = 1 / 0u;
    LODWORD(v9) = v5;
    HIDWORD(v9) = a2 % v8;
    v6 = v9 % v8;
  }
  else
  {
    v6 = __PAIR__(a2, v5) % a3;
  }
  return v6;
}
// 80711F0: using guessed type int dword_80711F0;

//----- (08064661) --------------------------------------------------------
#error "80646E5: positive sp value has been found (funcsize=46)"

//----- (080647AE) --------------------------------------------------------
int __cdecl sub_80647AE(int a1)
{
  return __cxa_atexit(a1, 0, dword_8071280);
}
// 80497B0: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 8071280: using guessed type int dword_8071280;

//----- (080647DD) --------------------------------------------------------
int __cdecl sub_80647DD(int a1, int a2)
{
  return __xstat64(3, a1, a2);
}
// 8049AE0: using guessed type int __cdecl __xstat64(_DWORD, _DWORD, _DWORD);

//----- (0806480C) --------------------------------------------------------
int __cdecl sub_806480C(int a1, int a2)
{
  return __fxstat64(3, a1, a2);
}
// 8049730: using guessed type int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD);

//----- (0806483B) --------------------------------------------------------
int __cdecl sub_806483B(int a1, int a2)
{
  return __lxstat64(3, a1, a2);
}
// 8049AF0: using guessed type int __cdecl __lxstat64(_DWORD, _DWORD, _DWORD);

//----- (080649F8) --------------------------------------------------------
#error "80649FE: positive sp value has been found (funcsize=0)"

//----- (08064A68) --------------------------------------------------------
#error "8064A6E: positive sp value has been found (funcsize=0)"

//----- (08064ADE) --------------------------------------------------------
#error "8064AE4: positive sp value has been found (funcsize=0)"

//----- (08064B50) --------------------------------------------------------
#error "8064B56: positive sp value has been found (funcsize=0)"

//----- (08064BC6) --------------------------------------------------------
#error "8064BCC: positive sp value has been found (funcsize=0)"

//----- (08064C3E) --------------------------------------------------------
#error "8064C44: positive sp value has been found (funcsize=0)"

//----- (08064C50) --------------------------------------------------------
int (**sub_8064C50())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_8070EE0;
  v1 = &off_8070EE4 - off_8070EE0;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_8070EE0[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 8070EE0: using guessed type int (*off_8070EE0[2])();
// 8070EE4: using guessed type int (*off_8070EE4)();

//----- (08064CB4) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 101 decompilation failure(s) on 394 function(s)"
