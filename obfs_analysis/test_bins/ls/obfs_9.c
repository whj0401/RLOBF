/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8049480();
// int unsetenv(const char *name);
// int raise(int sig);
// int strcmp(const char *s1, const char *s2);
// int putc_unlocked(int c, FILE *stream);
// struct passwd *getpwuid(__uid_t uid);
// int printf(const char *format, ...);
// void longjmp(struct __jmp_buf_tag env[1], int val);
// int fflush(FILE *stream);
// void _exit(int status);
// int sigprocmask(int how, const sigset_t *set, sigset_t *oset);
// int dirfd(DIR *dirp);
// int __cdecl wcwidth(_DWORD); weak
// void *memmove(void *dest, const void *src, size_t n);
// int _setjmp(struct __jmp_buf_tag env[1]);
// void free(void *ptr);
// uintmax_t strtoumax(const char *nptr, char **endptr, int base);
// void *memcpy(void *dest, const void *src, size_t n);
// int mbsinit(const mbstate_t *ps);
// int clock_gettime(clockid_t clock_id, struct timespec *tp);
// int tolower(int c);
// int fclose(FILE *stream);
// __sighandler_t signal(int sig, __sighandler_t handler);
// int memcmp(const void *s1, const void *s2, size_t n);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// time_t mktime(struct tm *tp);
// struct tm *localtime_r(const time_t *timer, struct tm *tp);
// int sigismember(const sigset_t *set, int signo);
// int fflush_unlocked(FILE *stream);
// int iswcntrl(wint_t wc);
// char *textdomain(const char *domainname);
// ssize_t readlink(const char *path, char *buf, size_t len);
// int fnmatch(const char *pattern, const char *name, int flags);
// int iswprint(wint_t wc);
// int ioctl(int fd, unsigned int request, ...);
// int ferror_unlocked(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD); weak
// void tzset(void);
// size_t __ctype_get_mb_cur_max(void);
// char *strcpy(char *dest, const char *src);
// size_t __fpending(FILE *fp);
// size_t wcstombs(char *s, const wchar_t *pwcs, size_t n);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int gethostname(char *name, size_t len);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// void error(int status, int errnum, const char *format, ...);
// int strcoll(const char *s1, const char *s2);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// time_t timegm(struct tm *tp);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// char *strchr(const char *s, int c);
// char *getcwd(char *buf, size_t size);
// size_t strlen(const char *s);
// int setenv(const char *name, const char *value, int replace);
// int fprintf(FILE *stream, const char *format, ...);
// int sigaddset(sigset_t *set, int signo);
// void *memset(void *s, int c, size_t n);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// int *__errno_location(void);
// __pid_t tcgetpgrp(int fd);
// int fileno(FILE *stream);
// int __cdecl stpncpy(_DWORD, _DWORD, _DWORD); weak
// unsigned int gnu_dev_major(unsigned __int64 dev);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// int __cdecl mempcpy(_DWORD, _DWORD, _DWORD); weak
// int wcswidth(void); weak
// int sigemptyset(sigset_t *set);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// int toupper(int c);
// char *strrchr(const char *s, int c);
// size_t mbstowcs(wchar_t *pwcs, const char *s, size_t n);
// struct tm *gmtime_r(const time_t *timer, struct tm *tp);
// unsigned int gnu_dev_minor(unsigned __int64 dev);
// int sprintf(char *s, const char *format, ...);
// struct lconv *localeconv(void);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int readdir64(void); weak
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// char *bindtextdomain(const char *domainname, const char *dirname);
// int strncmp(const char *s1, const char *s2, size_t n);
// int isatty(int fd);
// void abort(void);
// int __cdecl __xstat64(_DWORD, _DWORD, _DWORD); weak
// int __cdecl __lxstat64(_DWORD, _DWORD, _DWORD); weak
// int closedir(DIR *dirp);
// size_t strspn(const char *s, const char *accept);
// DIR *opendir(const char *name);
// struct group *getgrgid(__gid_t gid);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// void *calloc(size_t nmemb, size_t size);
// int putchar_unlocked(int c);
// int _gmon_start__(void); weak
void sub_8049BE3();
void sub_8049C00();
int sub_8049C10();
int sub_8049C80();
int sub_8049CA0();
void sub_8049CFF();
void sub_8049D1A();
signed int sub_8049D2A();
void sub_8049E0C();
void sub_8049E27();
int sub_8049E37();
void sub_8049F19();
void sub_8049F34();
int sub_8049F44();
void sub_804A026();
void sub_804A041();
int sub_804A051();
void sub_804A133();
void sub_804A14E();
int sub_804A15E();
void sub_804A255();
void sub_804A270();
int sub_804A280();
void sub_804A362();
void sub_804A37D();
int sub_804A38D();
void sub_804A46F();
void sub_804A48A();
int sub_804A49A();
void sub_804A57C();
void sub_804A597();
int sub_804A5A7();
void sub_804A6B5();
void sub_804A6D0();
int sub_804A6E0();
int sub_804A793();
// int __usercall sub_804A7D4@<eax>(void (__cdecl *a1)(void **)@<eax>);
void sub_804A820();
void sub_804A83B();
int sub_804A84B();
// int __usercall sub_804A8B2@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
void sub_804A949();
void sub_804A964();
int sub_804A974();
// int __usercall sub_804AA24@<eax>(int a1@<eax>, int edx0@<edx>, int a3@<ecx>, int a2);
int __cdecl sub_804AA60(unsigned __int8 a1);
_DWORD __cdecl sub_804AA72(_DWORD); // weak
int sub_804AAE3();
int sub_804AB0E();
int __cdecl sub_804AB39(char *s1); // idb
int __cdecl sub_804ACEF(int a1, int a2);
int __cdecl sub_804AD0E(int a1);
bool __cdecl sub_804AD16(int a1);
int sub_804AD22();
int __cdecl sub_804AD2C(int a1, int a2, int a3, int a4);
int sub_804AE3F();
int __stdcall sub_804AED2(int); // weak
_DWORD sub_804AF54(); // weak
int __fastcall sub_804B0F0(int a1, int a2);
// int __usercall sub_804B106@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebp>, int a4, int a5);
int sub_804B172(); // weak
void sub_804B19D();
signed int __cdecl sub_804B244(int a1);
char *__fastcall sub_804B32E(int a1, int a2);
int __cdecl sub_804B5C7(int *a1, char *a2);
int __cdecl sub_804B62E(int a1, _QWORD *a2);
void __cdecl sub_804B6FB(void *ptr);
_BOOL4 __cdecl sub_804B70E(int a1, int a2, int a3, int a4);
void __cdecl sub_804B7ED(void *ptr);
_DWORD __cdecl sub_804B81B(_DWORD); // weak
size_t sub_804B8C9();
size_t sub_804B8E9();
int __cdecl sub_804B930(int a1);
int sub_804B946();
int __fastcall sub_804B961(int a1, int a2);
int __cdecl sub_804B97D(sigset_t *set, sigset_t *oset); // idb
__sighandler_t __cdecl sub_804BAC7(void (*a1)(int));
__sighandler_t sub_804BC9F();
__sighandler_t sub_804BCB3();
int __cdecl main(int, char **, char **); // idb
signed int sub_804C470();
// int __usercall sub_804C519@<eax>(const char *a1@<ebx>, int argc, char **argv);
bool __cdecl sub_804D76E(_DWORD *a1, _BYTE **a2, char a3, int *a4);
signed int sub_804DB70();
int sub_804DC17();
void sub_804E000();
int __cdecl sub_804E09F(int a1);
int __cdecl sub_804E0D2(int a1, char *format);
_DWORD *__cdecl sub_804E128(char *a1, char *s, int a3);
// unsigned int __usercall sub_804E1AE@<eax>(int a1@<ebx>, int a2, int a3, char a4);
_DWORD *__cdecl sub_804E974(int a1);
int __cdecl sub_804E9B7(int a1);
_BOOL4 __cdecl sub_804EA1B(char *name);
_DWORD __cdecl sub_804EAAD(_DWORD, _DWORD); // weak
int sub_804EAFC();
void __cdecl sub_804EB14(void **a1);
int __fastcall sub_804EB79(int a1, int a2);
int __cdecl sub_804EC99(int a1);
signed int __cdecl sub_804ECCB(int a1, int a2, char a3);
int __cdecl sub_804EDB8(int a1, int a2);
int __cdecl sub_804EE5C(int a1, int a2);
int __fastcall sub_804EF1A(_DWORD, _DWORD); // weak
_DWORD __cdecl sub_804EFC2(_DWORD, _DWORD, __int64, _DWORD, _DWORD); // weak
int __cdecl sub_804FF8B(int a1);
_DWORD __cdecl sub_804FFB5(_DWORD, _DWORD, _DWORD); // weak
void *__cdecl sub_8050043(int a1, char *s);
int __cdecl sub_80500F5(int a1);
int __cdecl sub_8050116(char *s, int); // idb
int __cdecl sub_8050336(char *s1, char *s2); // idb
int __cdecl sub_80503F0(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD));
int __cdecl sub_805046C(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD));
int __cdecl sub_80504E8(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD));
int __cdecl sub_8050564(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_805061E(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD));
int __cdecl sub_805064C(const char **a1, const char **a2, int (__cdecl *a3)(char *, char *));
int __cdecl sub_8050E71(int a1, int a2);
int __cdecl sub_8050E93(int a1, int a2);
int __cdecl sub_8050EB5(int a1, int a2);
int __cdecl sub_8050ED7(int a1, int a2);
int __cdecl sub_8050EF9(int a1, int a2);
int __cdecl sub_8050FFF(int a1, int a2);
int __cdecl sub_805106D(int a1, int a2);
int __cdecl sub_80510F4(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8051116(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8051138(_DWORD *a1, _DWORD *a2);
int __cdecl sub_805115A(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8051203(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8051271(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80512DF(_DWORD *a1, _DWORD *a2);
int __cdecl sub_805134D(const char **a1, const char **a2);
int __cdecl sub_805136F(const char **a1, const char **a2);
int __cdecl sub_8051391(const char **a1, const char **a2);
int __cdecl sub_80513B3(const char **a1, const char **a2);
int __cdecl sub_80513D5(const char **a1, const char **a2);
int __cdecl sub_805146C(const char **a1, const char **a2);
int __cdecl sub_8051586(const char **a1, const char **a2);
int __cdecl sub_8051609(char **a1, char **a2);
int __cdecl sub_8051627(char **a1, char **a2);
int __cdecl sub_8051641(char **a1, char **a2);
int __cdecl sub_805165B(char **a1, char **a2);
int sub_8051750();
int sub_80517B8();
int sub_805192C();
// int __usercall sub_8051A41@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, unsigned __int8 a5, int a6, int a7, int a8);
// int __usercall sub_8051AD5@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>);
int sub_8051C21(); // weak
// int __usercall sub_8051C23@<eax>(int a1@<ebx>, char *s, int a3, int a4);
// int __usercall sub_8051CE3@<eax>(int a1@<ebx>, __uid_t uid, int a3, int a4);
// int __usercall sub_8051D5F@<eax>(int a1@<ebx>, __gid_t gid, int a3, int a4);
// size_t __usercall sub_8051DB2@<eax>(int a1@<ebx>, char *a2, int a3);
// size_t __usercall sub_8051E2C@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, __uid_t uid);
int __fastcall sub_8051E95(int a1, int a2);
int __cdecl sub_8051ED0(int); // weak
int __fastcall sub_8051EEC(int a1, int a2, int a3, unsigned int a4);
int __cdecl sub_8051F2E(int, int); // weak
_DWORD __cdecl sub_8051FA2(_DWORD); // weak
int __cdecl sub_8052BE3(size_t size, size_t n, FILE *stream); // idb
_DWORD __cdecl sub_8052D95(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_8052DD7(void *src, size_t n, mbstate_t *p, int); // idb
int __cdecl sub_80532F5(void *a1, int a2, int a3);
char *__cdecl sub_80533F9(char *s);
_DWORD __cdecl sub_80534ED(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl sub_8053A85(_DWORD, _DWORD); // weak
size_t sub_8053C57();
int __cdecl sub_8053C9A(int a1, int a2);
_DWORD __cdecl sub_8054054(_DWORD); // weak
_DWORD __cdecl sub_80540CA(_DWORD); // weak
_DWORD __cdecl sub_8054130(_DWORD, _DWORD); // weak
size_t __cdecl sub_80545CB(int a1);
_DWORD __cdecl sub_805462B(_DWORD); // weak
int sub_8054ACB(void); // weak
int __cdecl sub_8054C58(char a1);
_DWORD __cdecl sub_8054D3C(_DWORD, _DWORD); // weak
unsigned int sub_8054E9F();
_DWORD __cdecl sub_80550FF(_DWORD); // weak
void __cdecl __noreturn sub_80553EF(int status); // idb
int __cdecl sub_805575B(char *path, int); // idb
void __noreturn sub_805589D();
int __cdecl sub_80558B1(char *s, int, int, size_t); // idb
void __cdecl sub_8055A08(int a1, int a2, int a3);
int __cdecl sub_8055A8B(int a1);
int __cdecl sub_8055BC7(int, char *s, int, int, size_t n, int); // idb
signed int __cdecl sub_8055CD8(signed int a1);
_DWORD __cdecl sub_8055D08(_DWORD); // weak
_BOOL4 __cdecl sub_8055DD3(int a1);
int __cdecl sub_8055F0A(int a1);
int __cdecl sub_8055F40(int, char *s, int); // idb
char *__cdecl sub_8055FDC(void *src, int a2);
int sub_80569BD();
unsigned int __cdecl sub_8056AA1(_BYTE *a1);
void *__cdecl sub_8056B12(void *src);
_DWORD __cdecl sub_8056BAD(_DWORD); // weak
size_t __cdecl sub_8056C3A(char *s);
int sub_8056C78();
void __cdecl sub_8056C82(int a1, char *s, int a3);
_DWORD __cdecl sub_8056D2C(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl sub_8056DC0(_DWORD); // weak
_DWORD __cdecl sub_8056E80(_DWORD, _DWORD); // weak
int __cdecl sub_8057083(int a1, int a2);
void *__cdecl sub_80570A0(int a1, _BYTE *a2, int *a3);
_BYTE *__cdecl sub_80570D2(_BYTE *a1);
void *__cdecl sub_80570FF(int a1, _BYTE *a2, int *a3);
// _BYTE *__usercall sub_805723D@<eax>(int a1@<edx>, int a2@<ecx>, _BYTE **a3);
int __cdecl sub_805730D(unsigned __int8 a1);
int __cdecl sub_8057590(char *s1, char *s2); // idb
struct timespec *__cdecl sub_805784A(struct timespec *tp);
int __cdecl sub_8057895(int category); // idb
int __cdecl sub_80578F3(int a1);
int __cdecl sub_80578FE(int a1);
int __cdecl sub_8057909(int a1);
unsigned int __cdecl sub_8057914(int a1);
int __cdecl sub_8057AFD(_DWORD, _DWORD); // weak
int __cdecl sub_8057B62(int a1, int a2);
bool __cdecl sub_8057E24(unsigned int a1);
int __cdecl sub_8057E7B(unsigned int a1);
unsigned int __cdecl sub_8057F1C(int a1, unsigned int a2);
bool __cdecl sub_8057F47(int a1, int a2);
signed int __cdecl sub_8057F55(int a1);
unsigned int __cdecl sub_8058011(unsigned int a1, int a2);
_DWORD __cdecl sub_80580BE(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
void __cdecl sub_805838D(void *a1);
void *__cdecl sub_8058479(int a1);
int __cdecl sub_80584B4(int a1, _DWORD *a2);
int __cdecl sub_80584F7(int a1, int a2, _DWORD *a3, char a4);
_DWORD __cdecl sub_8058695(_DWORD, _DWORD, _DWORD); // weak
signed int __cdecl sub_805887E(int a1, unsigned int a2);
_DWORD __cdecl sub_8058AE7(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_8058E55(int a1, int a2);
_DWORD sub_8058E94(); // weak
int __cdecl sub_805915F(int, char *); // idb
int __cdecl sub_8059336(int a1, int a2);
void __cdecl sub_80593F6(void **a1);
int __cdecl sub_805941C(int, _TBYTE); // idb
_DWORD __cdecl sub_8059584(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_80595D9(void *src, size_t n); // idb
int __cdecl sub_80596F1(int, int, char *s, int, int, int, int, int); // idb
__int64 sub_805A64A();
int __cdecl sub_805A678(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_805A69F(int, int base, size_t, char *s); // idb
int __cdecl sub_805A827(int a1, int a2, __int64 *a3);
char *__cdecl sub_805A870(__uid_t uid);
char *__cdecl sub_805AA7C(__gid_t gid);
int __cdecl sub_805ACC8(__int64 a1, int a2);
int __cdecl sub_805AE16(int a1);
int __cdecl sub_805AEF2(wint_t *a1);
int __cdecl sub_805AF35(_DWORD *a1, unsigned int a2);
// _BYTE *__usercall sub_805AFA1@<eax>(int edx0@<edx>, int ecx0@<ecx>, _BYTE *a1, unsigned int a2, int a3);
size_t __cdecl sub_805AFE7(char *s, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_805B4EF@<eax>(int a1@<ebx>, char *s);
// signed int __usercall sub_805B518@<eax>(int a1@<ebx>, void *a2);
void *__cdecl sub_805B86F(int a1, int a2, void *dest, int a4);
int __cdecl sub_805BA55(int, int, void *dest, int); // idb
int __cdecl sub_805BD1D(int a1, int a2, int a3);
int __cdecl sub_805BD61(int a1, int a2, int a3);
int __cdecl sub_805BDA1(int a1, int a2, int a3);
_DWORD __cdecl sub_805BDE1(_DWORD, _DWORD); // weak
int __fastcall sub_805BE83(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int sub_805BEB7();
int __cdecl sub_805BF11(size_t); // idb
char *__cdecl sub_805EFA1(char *s);
int __cdecl sub_805F093(int a1);
int __cdecl sub_805F0D1(size_t n); // idb
int __cdecl sub_805F0F8(int *a1);
int *__cdecl sub_805F10F(int *a1, int a2);
_DWORD __cdecl sub_805F129(_DWORD, _DWORD); // weak
int *__cdecl sub_805F238(int *a1, int a2, int a3);
_DWORD __cdecl sub_805F279(_DWORD, _DWORD); // weak
const char *__cdecl sub_805F350(char *msgid, int a2);
_DWORD __cdecl sub_805F403(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_805F4EE(void *s2, size_t n, mbstate_t *p, int, int, int, int, int); // idb
int __cdecl sub_806020C(int a1, int a2, int a3, int a4, int *a5);
void *__cdecl sub_8060337(int a1, int a2, _DWORD *a3, int *a4);
_DWORD __cdecl sub_806053E(_DWORD); // weak
int __cdecl sub_806087B(int a1);
int __cdecl sub_80608A5(int a1);
int __cdecl sub_806093B(int a1, int a2);
int __cdecl sub_8060979(int a1, int a2);
int __cdecl sub_80609B6(int a1);
_DWORD __cdecl sub_8060A11(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_8060B00(_DWORD, _DWORD); // weak
int sub_8060B22();
int __cdecl sub_8060B5E(int a1);
int __cdecl sub_8060B9B(int a1, int a2, int a3);
int __cdecl sub_8060CAE(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_8060D01(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_8060E4B(int a1);
int __cdecl sub_8060EC6(int a1);
int sub_8060EE8();
_BOOL4 __cdecl sub_8060F03(void *src, void *a2);
void sub_8061103();
signed int sub_8061150();
signed int sub_8061168();
_DWORD __cdecl sub_80612A2(_DWORD, _DWORD); // weak
// _DWORD *__userpurge sub_80612E2@<eax>(_DWORD *a1, int a2);
int __cdecl sub_806130D(_DWORD, _DWORD); // weak
int __cdecl sub_80613ED(int a1, int a2, int a3, int a4);
int __cdecl sub_806148F(FILE *stream, int, int, int, int, int); // idb
int __cdecl sub_8061CE3(FILE *stream, int, int, int, int); // idb
int sub_8061D92(FILE *stream, int a2, int a3, int a4, ...);
void *__cdecl sub_8061E52(unsigned int a1, unsigned int a2);
void *__cdecl sub_8061E80(void *ptr, int a2, int a3);
void *__cdecl sub_8061EB5(void *ptr, int a2, int a3);
void *__cdecl sub_8061F4C(size_t size);
void *__cdecl sub_8061F5F(size_t size);
void *__cdecl sub_8061F89(void *ptr, size_t size);
void *__cdecl sub_8061FD8(void *ptr, int a2);
void *__cdecl sub_8062061(void *src, size_t n);
void *__cdecl sub_806208A(char *s);
void __noreturn sub_80620AF();
int __cdecl sub_80620E8(char *nptr, int base, int, int, int, int, char *s, int, int); // idb
char *sub_8062314();
_DWORD sub_8062376(); // weak
int __cdecl sub_806247A(unsigned int *a1, unsigned int a2);
int __cdecl sub_80624F3(unsigned int *a1, unsigned int a2, int a3);
// int __usercall sub_8062529@<eax>(int a1@<edx>, int a2@<ecx>, char *nptr, int a4, int base, int a6, char *s);
void __cdecl sub_80629A7(int a1, int a2, int a3, int a4, int a5, int status);
void __cdecl __noreturn sub_8062A8D(int a1, int a2, char a3, int a4, int a5);
signed int __cdecl sub_8062AF0(unsigned int *a1, signed int a2);
int __cdecl sub_8062BCC(unsigned int *a1, signed int a2, int a3);
int __cdecl sub_8062C02(char *nptr, int, int base, int, char *s); // idb
size_t __cdecl sub_8063055(wchar_t *pwc, char *s, size_t n, mbstate_t *p);
int __cdecl sub_80630DC(int a1, int a2);
int __cdecl sub_806311A(int a1, int a2);
signed int __cdecl sub_806316D(int a1, signed int a2, signed int a3);
signed int __cdecl sub_80632AC(int a1, signed int a2, signed int a3, int a4, int a5);
_DWORD __cdecl sub_8063395(_DWORD, _DWORD); // weak
int __fastcall sub_80637B2(int a1, int a2, int a3, int a4);
int sub_8063833(); // weak
_DWORD __cdecl sub_806383D(_DWORD, _DWORD); // weak
char *__cdecl sub_8063924(void *dest, void *src, size_t n);
int __cdecl sub_8063950(char *s); // idb
int __cdecl sub_80639A4(void *src, size_t n); // idb
_DWORD __cdecl sub_8063A8B(_DWORD, _DWORD); // weak
void *__cdecl sub_8063C99(void *ptr);
char *sub_8063CF5();
int __cdecl sub_8063D09(char *value); // idb
signed int __cdecl sub_8063D40(int a1);
_DWORD __cdecl sub_8063D7D(_DWORD); // weak
int __cdecl sub_8063E5D(void *ptr); // idb
struct tm *__cdecl sub_8063EBC(int a1, time_t *timer, struct tm *tp);
int __cdecl sub_8063F85(int, struct tm *tp); // idb
int __cdecl sub_8064275(int a1, char a2);
int __cdecl sub_8064465(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_80644CA(FILE *fp); // idb
void *__cdecl sub_806454B(void *src);
int __cdecl sub_806456F(_BYTE *a1, unsigned int a2);
int __cdecl sub_80645B5(size_t n); // idb
char *sub_8064B56();
int __cdecl sub_8064C22(FILE *stream); // idb
int __cdecl sub_8064CE5(FILE *stream); // idb
int __cdecl sub_8064D1E(FILE *fp); // idb
int __cdecl sub_8064D5E(FILE *stream, int, int, int); // idb
// int __usercall sub_8064E7E@<eax>(int a1@<ebp>);
int __cdecl sub_8064EE4(int, int, int); // weak
signed __int64 __cdecl sub_8064F0A(__int64 a1, unsigned int a2, signed int a3);
_DWORD __cdecl sub_80650FA(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl sub_80653AA(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_8065564(int, int, char *, int); // idb
int __cdecl sub_8065813(int a1);
int __cdecl sub_8065842(int a1, int a2);
int __cdecl sub_8065871(int a1, int a2);
int __cdecl sub_80658A0(int a1, int a2);
int __stdcall sub_8065AB5(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_8065B27();
int __stdcall sub_8065B9D(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __fastcall sub_8065C0F(_DWORD, _DWORD, _DWORD);
int __fastcall sub_8065CE1(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
int __stdcall sub_8065D53(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_8065DC3(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (**sub_8065DE0())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN locret_804A6EF; // weak
_UNKNOWN loc_804AA56; // weak
_UNKNOWN loc_804AA5E; // weak
_UNKNOWN loc_804B176; // weak
_UNKNOWN loc_804B17A; // weak
_UNKNOWN loc_804B19B; // weak
_UNKNOWN loc_804B1E3; // weak
_UNKNOWN loc_804B208; // weak
_UNKNOWN loc_804B214; // weak
_UNKNOWN loc_804B3B2; // weak
_UNKNOWN loc_804B3B7; // weak
_UNKNOWN loc_804B582; // weak
_UNKNOWN loc_804B6E5; // weak
_UNKNOWN loc_804B6EC; // weak
_UNKNOWN loc_804BA7A; // weak
_UNKNOWN loc_804BB6C; // weak
_UNKNOWN loc_804BBF7; // weak
_UNKNOWN loc_804C512; // weak
_UNKNOWN loc_804C571; // weak
_UNKNOWN loc_804C59B; // weak
_UNKNOWN loc_804CE99; // weak
_UNKNOWN loc_804CEAF; // weak
_UNKNOWN loc_804CF4A; // weak
_UNKNOWN loc_804D1A4; // weak
_UNKNOWN loc_804D22D; // weak
_UNKNOWN loc_804D2FF; // weak
_UNKNOWN loc_804D318; // weak
_UNKNOWN loc_804D441; // weak
_UNKNOWN loc_804D454; // weak
_UNKNOWN loc_804D495; // weak
_UNKNOWN loc_804D4EE; // weak
_UNKNOWN loc_804D68B; // weak
_UNKNOWN loc_804D6C5; // weak
_UNKNOWN loc_804D6CA; // weak
_UNKNOWN loc_804D70C; // weak
_UNKNOWN loc_804D75B; // weak
_UNKNOWN loc_804D908; // weak
_UNKNOWN loc_804DAA9; // weak
_UNKNOWN loc_804DAF9; // weak
_UNKNOWN loc_804DB25; // weak
_UNKNOWN loc_804E63D; // weak
_UNKNOWN loc_804E6E3; // weak
_UNKNOWN loc_804E710; // weak
_UNKNOWN loc_804E76B; // weak
_UNKNOWN loc_804E76F; // weak
_UNKNOWN loc_804E9C5; // weak
_UNKNOWN loc_804EA14; // weak
_UNKNOWN loc_804EBBA; // weak
_UNKNOWN loc_804EDAE; // weak
_UNKNOWN loc_804EEFB; // weak
_UNKNOWN loc_804EF0F; // weak
_UNKNOWN loc_80510D1; // weak
_UNKNOWN loc_80510D8; // weak
_UNKNOWN loc_8051431; // weak
_UNKNOWN loc_8051438; // weak
_UNKNOWN loc_80514BD; // weak
_UNKNOWN loc_80514CF; // weak
_UNKNOWN locret_8051607; // weak
_UNKNOWN loc_80519B2; // weak
_UNKNOWN loc_80519C0; // weak
_UNKNOWN loc_8051BD4; // weak
_UNKNOWN loc_8051BF9; // weak
_UNKNOWN loc_8051D35; // weak
_UNKNOWN loc_8051D3C; // weak
_UNKNOWN loc_8051E79; // weak
_UNKNOWN loc_8051E84; // weak
_UNKNOWN loc_8051EDB; // weak
_UNKNOWN loc_8053431; // weak
_UNKNOWN loc_80534E2; // weak
_UNKNOWN loc_80559D5; // weak
_UNKNOWN loc_80559D9; // weak
_UNKNOWN loc_8055AC3; // weak
_UNKNOWN loc_8055BAC; // weak
_UNKNOWN locret_8055C5C; // weak
_UNKNOWN loc_805622F; // weak
_UNKNOWN loc_805626C; // weak
_UNKNOWN loc_805633A; // weak
_UNKNOWN loc_8056386; // weak
_UNKNOWN loc_805678C; // weak
_UNKNOWN loc_80567F3; // weak
_UNKNOWN loc_8056882; // weak
_UNKNOWN loc_8056891; // weak
_UNKNOWN loc_8056B8C; // weak
_UNKNOWN loc_8056B9D; // weak
_UNKNOWN loc_80570F0; // weak
_UNKNOWN loc_805720C; // weak
_UNKNOWN loc_80572F8; // weak
_UNKNOWN loc_8057667; // weak
_UNKNOWN loc_8057671; // weak
_UNKNOWN locret_8057848; // weak
_UNKNOWN locret_8058693; // weak
_UNKNOWN loc_805AAF3; // weak
_UNKNOWN loc_805AE67; // weak
_UNKNOWN loc_805AFC7; // weak
_UNKNOWN loc_805B0CA; // weak
_UNKNOWN loc_805B0CF; // weak
_UNKNOWN loc_805B1E5; // weak
_UNKNOWN loc_805B1F6; // weak
_UNKNOWN loc_805B22F; // weak
_UNKNOWN loc_805B289; // weak
_UNKNOWN loc_805B29A; // weak
_UNKNOWN loc_805B5C8; // weak
_UNKNOWN loc_805B5F9; // weak
_UNKNOWN loc_805B726; // weak
_UNKNOWN loc_805B72B; // weak
_UNKNOWN loc_805B76E; // weak
_UNKNOWN loc_805B773; // weak
_UNKNOWN loc_805B79C; // weak
_UNKNOWN loc_805B846; // weak
_UNKNOWN loc_805B85C; // weak
_UNKNOWN loc_805F04B; // weak
_UNKNOWN loc_805F081; // weak
_UNKNOWN loc_805F0D6; // weak
_UNKNOWN loc_805F3BE; // weak
_UNKNOWN loc_8061CF2; // weak
_UNKNOWN loc_8061D32; // weak
_UNKNOWN loc_8062360; // weak
_UNKNOWN loc_8062371; // weak
_UNKNOWN loc_80624F1; // weak
_UNKNOWN loc_806255B; // weak
_UNKNOWN loc_8062563; // weak
_UNKNOWN loc_80625A4; // weak
_UNKNOWN loc_8062643; // weak
_UNKNOWN loc_8062676; // weak
_UNKNOWN loc_80626E3; // weak
_UNKNOWN loc_80627C4; // weak
_UNKNOWN loc_806299A; // weak
_UNKNOWN loc_8062DB5; // weak
_UNKNOWN loc_8062DCE; // weak
_UNKNOWN locret_80630DA; // weak
_UNKNOWN locret_806316B; // weak
_UNKNOWN loc_8063838; // weak
_UNKNOWN loc_8063983; // weak
_UNKNOWN loc_80639A9; // weak
_UNKNOWN loc_8063CD2; // weak
_UNKNOWN locret_8063CF3; // weak
_UNKNOWN loc_8063F26; // weak
_UNKNOWN loc_8063F43; // weak
_UNKNOWN locret_8063F83; // weak
_UNKNOWN loc_8063FDE; // weak
_UNKNOWN loc_806402A; // weak
_UNKNOWN loc_806405F; // weak
_UNKNOWN loc_8064073; // weak
_UNKNOWN loc_8064B8A; // weak
_UNKNOWN loc_8064B91; // weak
_UNKNOWN locret_8064F04; // weak
_UNKNOWN loc_8064FDA; // weak
_UNKNOWN loc_8064FE5; // weak
char locale = '\0'; // idb
char *off_80671B0[4] = { "full-iso", "long-iso", "iso", "locale" }; // weak
_UNKNOWN unk_80671C4; // weak
char *off_80671F4[4] = { "none", "slash", "file-type", "classify" }; // weak
int dword_8067208[4] = { 0, 1, 2, 3 }; // idb
char *off_8067278 = &unk_8067218; // idb
struct option longopts = { "all", 0, NULL, 97 }; // idb
char *off_8067818[7] =
{
  "verbose",
  "long",
  "commas",
  "horizontal",
  "across",
  "vertical",
  "single-column"
}; // weak
int dword_8067838[] = { 0 }; // weak
char *off_8067860[5] = { "none", "time", "size", "extension", "version" }; // weak
int dword_8067878[5] = { 4294967295, 4, 2, 1, 3 }; // idb
char *off_80678AC[5] = { "atime", "access", "use", "ctime", "status" }; // weak
int dword_80678C4[5] = { 2, 2, 2, 1, 1 }; // idb
char *off_8067918[4] = { "always", "yes", "force", "never" }; // weak
int dword_8067958[9] = { 1, 1, 1, 0, 0, 0, 2, 2, 2 }; // idb
int (__cdecl *off_8068678[28])(int, int) =
{
  &sub_80510F4,
  &sub_805117C,
  &sub_8051138,
  &sub_8051271,
  &sub_8051116,
  &sub_8051203,
  &sub_805115A,
  &sub_80512DF,
  &sub_805134D,
  &sub_80513D5,
  &sub_8051391,
  &sub_8051503,
  &sub_805136F,
  &sub_805146C,
  &sub_80513B3,
  &sub_8051586,
  &sub_8050E71,
  &sub_8050EF9,
  &sub_8050EB5,
  &sub_8050FFF,
  &sub_8050E93,
  &sub_8050F67,
  &sub_8050ED7,
  &sub_805106D,
  &sub_8051627,
  &sub_805165B,
  &sub_8051641,
  &sub_80516C1
}; // weak
int sig[12] = { 20, 14, 1, 2, 13, 3, 15, 29, 27, 26, 24, 25 }; // idb
_UNKNOWN unk_806A660; // weak
_UNKNOWN unk_806A7C4; // weak
char *off_806AA98[10] =
{
  "literal",
  "shell",
  "shell-always",
  "shell-escape",
  "shell-escape-always",
  "c",
  "c-maybe",
  "escape",
  "locale",
  "clocale"
}; // weak
int dword_806AAD8[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; // idb
_UNKNOWN unk_806AB0A; // weak
_UNKNOWN unk_806AB16; // weak
_UNKNOWN unk_806AB1A; // weak
_UNKNOWN unk_806AB1D; // weak
void *off_806B45C[48] =
{
  &loc_8062DEA,
  &loc_8062E42,
  &loc_8062DEA,
  &loc_8062E42,
  &loc_8062E42,
  &loc_8062E42,
  &loc_8062DEA,
  &loc_8062E42,
  &loc_8062DEA,
  &loc_8062E42,
  &loc_8062E42,
  &loc_8062DEA,
  &loc_8062E42,
  &loc_8062E42,
  &loc_8062E42,
  &loc_8062DEA,
  &loc_8062E42,
  &loc_8062E42,
  &loc_8062E42,
  &loc_8062E42,
  &loc_8062DEA,
  &loc_8062DEA,
  &loc_8062E42,
  &loc_8062E42,
  &loc_8062E42,
  &loc_8062E42,
  &loc_8062E42,
  &loc_8062E42,
  &loc_8062E42,
  &loc_8062E42,
  &loc_8062E42,
  &loc_8062E42,
  &loc_8062E42,
  &loc_8062E42,
  &loc_8062DEA,
  &loc_8062E42,
  &loc_8062E42,
  &loc_8062E42,
  &loc_8062DEA,
  &loc_8062E42,
  &loc_8062DEA,
  &loc_8062E42,
  &loc_8062E42,
  &loc_8062E42,
  &loc_8062E42,
  &loc_8062E42,
  &loc_8062E42,
  &loc_8062DEA
}; // weak
_UNKNOWN unk_806B673; // weak
_UNKNOWN unk_806D3AC; // weak
_UNKNOWN unk_806D3AF; // weak
_UNKNOWN unk_806E3CC; // weak
_UNKNOWN unk_806E3CF; // weak
_UNKNOWN unk_806F408; // weak
_UNKNOWN unk_806F40B; // weak
int (*off_8071ED8[2])() = { &sub_8049CA0, &sub_8049C80 }; // weak
int (*off_8071EDC)() = &sub_8049C80; // weak
int (*dword_8072008)(void) = NULL; // weak
int dword_80721DC = 0; // weak
int dword_80721F0 = 0; // weak
int dword_8072204 = 0; // weak
int dword_8072224 = 0; // weak
int dword_8072238 = 0; // weak
int dword_807224C = 0; // weak
int dword_8072260 = 0; // weak
int (__fastcall *dword_8072288)(_DWORD, _DWORD) = NULL; // weak
int dword_80722A0 = 0; // weak
_UNKNOWN unk_80722BC; // weak
char byte_80722BE = '\x01'; // weak
char byte_80722BF = '\x01'; // weak
int qword_80722C4 = 1; // idb
int dword_80722DC = 2; // weak
void *s1 = &unk_80672DC; // idb
int dword_80722E4 = 1; // weak
_UNKNOWN unk_80722EC; // weak
int dword_80722F0 = 0; // weak
_UNKNOWN unk_80722F4; // weak
_UNKNOWN unk_80722FC; // weak
int dword_8072314 = 5; // weak
char *off_8072318 = "01;36"; // idb
char *off_807239C = "%b %e  %Y"; // idb
char *off_80723A0 = "%b %e %H:%M"; // weak
char byte_80723A4 = '\x01'; // weak
int dword_80723A8 = 4294967295; // weak
int dword_80723E4 = 1; // weak
int off_80723E8 = 134653176; // idb
int off_80723EC = 134568093; // idb
int status = 1; // idb
_UNKNOWN unk_807243C; // weak
_UNKNOWN unk_807243F; // weak
_UNKNOWN unk_8072440; // weak
_UNKNOWN unk_8072443; // weak
_UNKNOWN unk_8072444; // weak
_UNKNOWN unk_8072447; // weak
_UNKNOWN unk_8072450; // weak
_UNKNOWN unk_8072453; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int program_invocation_name; // weak
int optind; // weak
FILE *stdout; // idb
int (*obstack_alloc_failed_handler)(void); // weak
char *optarg; // idb
char byte_80724AC; // weak
_UNKNOWN unk_8072631; // weak
_UNKNOWN unk_8072765; // weak
char byte_80727AE; // weak
void *dword_807283C; // idb
void *dword_8072840; // idb
int dword_8072848; // weak
char byte_807284D; // weak
void *dword_8072850; // idb
int dword_8072854; // weak
char byte_8072858; // weak
int dword_8072860; // weak
char byte_807286C; // weak
int dword_8072870; // weak
int dword_8072874; // weak
int dword_807287C; // idb
int dword_8072898; // weak
int dword_807289C; // weak
int dword_80728A0; // weak
char byte_80728A4; // weak
char byte_80728A5; // weak
char byte_80728A6; // weak
char byte_80728A7; // weak
int dword_80728A8; // idb
int qword_80728AC; // idb
int dword_80728B4; // idb
char byte_80728B8; // weak
int dword_80728BC; // weak
char byte_80728C0; // weak
char byte_80728C1; // weak
char byte_80728C2; // weak
int dword_80728C4; // weak
void *ptr; // idb
char byte_80728CD; // weak
int dword_80728D0; // weak
char byte_80728D4; // weak
char byte_80728D5; // weak
char byte_80728D6; // weak
int dword_80728D8; // weak
int dword_80728DC; // idb
int dword_80728E0; // idb
char byte_80728E4; // weak
int dword_80728E8; // weak
int dword_80728EC; // weak
int dword_80728F0; // weak
char byte_80728F4; // weak
int dword_80728F8; // weak
int dword_80728FC; // idb
sigset_t set; // idb
int dword_807299C; // weak
int dword_80729A0; // weak
int dword_80729A4; // weak
void *dword_80729A8; // idb
int dword_80729AC; // idb
int dword_80729B0; // weak
_UNKNOWN unk_80729FC; // weak
_UNKNOWN unk_8072A3C; // weak
int dword_8072A48; // weak
char byte_807377C; // weak
struct __jmp_buf_tag env[1]; // idb
__int64 qword_807383C; // weak
__int64 qword_8073844; // weak
__int64 qword_807384C; // weak
int dword_8073854; // weak
int dword_8073858; // weak
char byte_807385C; // weak
int dword_8073860; // weak
int dword_8073868; // weak
int dword_8073870; // weak
int dword_807387C; // weak
int dword_8073880; // weak
int dword_8073884; // weak
int dword_8073888; // weak
int dword_807388C; // weak
int dword_8073890; // weak
int dword_8073894; // weak
int dword_8073898; // weak
int dword_807389C; // weak
int dword_80738A0; // weak
int dword_80738A4; // weak
int dword_80738A8; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (0804945C) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 8049BA0: using guessed type int _gmon_start__(void);

//----- (08049480) --------------------------------------------------------
int sub_8049480()
{
  return dword_8072008();
}
// 8072008: using guessed type int (*dword_8072008)(void);

//----- (08049BB0) --------------------------------------------------------
#error "8049BB3: positive sp value has been found (funcsize=2)"

//----- (08049BE3) --------------------------------------------------------
void sub_8049BE3()
{
  ;
}

//----- (08049C00) --------------------------------------------------------
void sub_8049C00()
{
  ;
}

//----- (08049C10) --------------------------------------------------------
int sub_8049C10()
{
  int result; // eax

  result = &unk_8072453 - &unk_8072450;
  if ( (unsigned int)(&unk_8072453 - &unk_8072450) > 6 )
    result = 0;
  return result;
}
// 8049C10: could not find valid save-restore pair for ebp

//----- (08049C80) --------------------------------------------------------
int sub_8049C80()
{
  int result; // eax

  if ( !byte_80724AC )
  {
    result = sub_8049C10();
    byte_80724AC = 1;
  }
  return result;
}
// 8049C80: could not find valid save-restore pair for ebp
// 80724AC: using guessed type char byte_80724AC;

//----- (08049CA0) --------------------------------------------------------
int sub_8049CA0()
{
  return 0;
}
// 8049CA0: could not find valid save-restore pair for ebp

//----- (08049CFF) --------------------------------------------------------
void sub_8049CFF()
{
  ;
}

//----- (08049D1A) --------------------------------------------------------
void sub_8049D1A()
{
  ;
}

//----- (08049D2A) --------------------------------------------------------
signed int sub_8049D2A()
{
  return 3;
}
// 8049D2A: could not find valid save-restore pair for ebp

//----- (08049E0C) --------------------------------------------------------
void sub_8049E0C()
{
  ;
}

//----- (08049E27) --------------------------------------------------------
void sub_8049E27()
{
  ;
}

//----- (08049E37) --------------------------------------------------------
int sub_8049E37()
{
  int result; // eax

  result = &unk_807243F - &unk_807243C;
  if ( (unsigned int)(&unk_807243F - &unk_807243C) > 6 )
    result = 0;
  return result;
}
// 8049E37: could not find valid save-restore pair for ebp

//----- (08049F19) --------------------------------------------------------
void sub_8049F19()
{
  ;
}

//----- (08049F34) --------------------------------------------------------
void sub_8049F34()
{
  ;
}

//----- (08049F44) --------------------------------------------------------
int sub_8049F44()
{
  int result; // eax

  result = &unk_807243F - &unk_807243C;
  if ( (unsigned int)(&unk_807243F - &unk_807243C) > 6 )
    result = 0;
  return result;
}
// 8049F44: could not find valid save-restore pair for ebp

//----- (0804A026) --------------------------------------------------------
void sub_804A026()
{
  ;
}

//----- (0804A041) --------------------------------------------------------
void sub_804A041()
{
  ;
}

//----- (0804A051) --------------------------------------------------------
int sub_804A051()
{
  int result; // eax

  result = &unk_806F40B - &unk_806F408;
  if ( (unsigned int)(&unk_806F40B - &unk_806F408) > 6 )
    result = 0;
  return result;
}
// 804A051: could not find valid save-restore pair for ebp

//----- (0804A133) --------------------------------------------------------
void sub_804A133()
{
  ;
}

//----- (0804A14E) --------------------------------------------------------
void sub_804A14E()
{
  ;
}

//----- (0804A15E) --------------------------------------------------------
int sub_804A15E()
{
  int result; // eax

  result = &unk_807243F - &unk_807243C;
  if ( (unsigned int)(&unk_807243F - &unk_807243C) > 6 )
    result = 0;
  return result;
}
// 804A15E: could not find valid save-restore pair for ebp

//----- (0804A255) --------------------------------------------------------
void sub_804A255()
{
  ;
}

//----- (0804A270) --------------------------------------------------------
void sub_804A270()
{
  ;
}

//----- (0804A280) --------------------------------------------------------
int sub_804A280()
{
  int result; // eax

  result = &unk_8072631 - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_8072631 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 804A280: could not find valid save-restore pair for ebp
// 8072460: using guessed type int program_invocation_short_name;

//----- (0804A362) --------------------------------------------------------
void sub_804A362()
{
  ;
}

//----- (0804A37D) --------------------------------------------------------
void sub_804A37D()
{
  ;
}

//----- (0804A38D) --------------------------------------------------------
int sub_804A38D()
{
  int result; // eax

  result = &unk_806E3CF - &unk_806E3CC;
  if ( (unsigned int)(&unk_806E3CF - &unk_806E3CC) > 6 )
    result = 0;
  return result;
}
// 804A38D: could not find valid save-restore pair for ebp

//----- (0804A46F) --------------------------------------------------------
void sub_804A46F()
{
  ;
}

//----- (0804A48A) --------------------------------------------------------
void sub_804A48A()
{
  ;
}

//----- (0804A49A) --------------------------------------------------------
int sub_804A49A()
{
  int result; // eax

  result = &unk_807243F - &unk_807243C;
  if ( (unsigned int)(&unk_807243F - &unk_807243C) > 6 )
    result = 0;
  return result;
}
// 804A49A: could not find valid save-restore pair for ebp

//----- (0804A57C) --------------------------------------------------------
void sub_804A57C()
{
  ;
}

//----- (0804A597) --------------------------------------------------------
void sub_804A597()
{
  ;
}

//----- (0804A5A7) --------------------------------------------------------
int sub_804A5A7()
{
  int result; // eax

  result = &unk_806D3AF - &unk_806D3AC;
  if ( (unsigned int)(&unk_806D3AF - &unk_806D3AC) > 6 )
    result = 0;
  return result;
}
// 804A5A7: could not find valid save-restore pair for ebp

//----- (0804A6B5) --------------------------------------------------------
void sub_804A6B5()
{
  ;
}

//----- (0804A6D0) --------------------------------------------------------
void sub_804A6D0()
{
  ;
}

//----- (0804A6E0) --------------------------------------------------------
int sub_804A6E0()
{
  int result; // eax
  int (__stdcall *v1)(int *, int, int, int, int, int); // eax
  int v2; // [esp+4h] [ebp-18h]
  int v3; // [esp+8h] [ebp-14h]
  int v4; // [esp+Ch] [ebp-10h]
  int v5; // [esp+10h] [ebp-Ch]
  int v6; // [esp+14h] [ebp-8h]
  int *v7; // [esp+18h] [ebp-4h]

  result = &unk_8072765 - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_8072765 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
  {
    dword_807224C = (int)&locret_804A6EF;
    v1 = (int (__stdcall *)(int *, int, int, int, int, int))sub_8065B27();
    v7 = &v6;
    result = v1(&program_invocation_short_name, v2, v3, v4, v5, v6);
  }
  return result;
}
// 804A6E0: could not find valid save-restore pair for ebp
// 807224C: using guessed type int dword_807224C;
// 8072460: using guessed type int program_invocation_short_name;

//----- (0804A793) --------------------------------------------------------
int sub_804A793()
{
  int result; // eax

  result = sub_804A6E0();
  byte_80727AE = 1;
  return result;
}
// 80727AE: using guessed type char byte_80727AE;

//----- (0804A7D4) --------------------------------------------------------
int __usercall sub_804A7D4@<eax>(void (__cdecl *a1)(void **)@<eax>)
{
  a1(&off_806B45C[13]);
  return 0;
}
// 806B45C: using guessed type void *off_806B45C[48];

//----- (0804A820) --------------------------------------------------------
void sub_804A820()
{
  ;
}

//----- (0804A83B) --------------------------------------------------------
void sub_804A83B()
{
  ;
}

//----- (0804A84B) --------------------------------------------------------
int sub_804A84B()
{
  int result; // eax

  result = &unk_8072443 - &unk_8072440;
  if ( (unsigned int)(&unk_8072443 - &unk_8072440) > 6 )
    result = 0;
  return result;
}
// 804A84B: could not find valid save-restore pair for ebp

//----- (0804A8B2) --------------------------------------------------------
int __usercall sub_804A8B2@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_8072440, a1);
}

//----- (0804A949) --------------------------------------------------------
void sub_804A949()
{
  ;
}

//----- (0804A964) --------------------------------------------------------
void sub_804A964()
{
  ;
}

//----- (0804A974) --------------------------------------------------------
int sub_804A974()
{
  int result; // eax

  result = &unk_8072447 - &unk_8072444;
  if ( (unsigned int)(&unk_8072447 - &unk_8072444) > 6 )
    result = 0;
  return result;
}
// 804A974: could not find valid save-restore pair for ebp

//----- (0804AA24) --------------------------------------------------------
int __usercall sub_804AA24@<eax>(int a1@<eax>, int edx0@<edx>, int a3@<ecx>, int a2)
{
  void *v4; // eax
  int result; // eax
  int savedregs; // [esp+0h] [ebp+0h]

  v4 = &loc_804AA56;
  if ( a2 == 1 )
    v4 = &loc_804AA5E;
  dword_8072224 = (int)v4;
  sub_8065C0F(a3, edx0, savedregs);
  result = a2;
  status = a2;
  return result;
}
// 8072224: using guessed type int dword_8072224;

//----- (0804AA60) --------------------------------------------------------
int __cdecl sub_804AA60(unsigned __int8 a1)
{
  return a1;
}

//----- (0804AA72) --------------------------------------------------------
#error "804AA96: call analysis failed (funcsize=38)"

//----- (0804AAE3) --------------------------------------------------------
int sub_804AAE3()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nMandatory arguments to long options are mandatory for short options too.\n");
  return fputs_unlocked(v1, v0);
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804AB0E) --------------------------------------------------------
int sub_804AB0E()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext(
         "\n"
         "The SIZE argument is an integer and optional unit (example: 10K is 10*1024).\n"
         "Units are K,M,G,T,P,E,Z,Y (powers of 1024) or KB,MB,... (powers of 1000).\n");
  return fputs_unlocked(v1, v0);
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804AB39) --------------------------------------------------------
int __cdecl sub_804AB39(char *s1)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // ebx
  char *v5; // eax
  int v7; // [esp+0h] [ebp-68h]
  char *v8; // [esp+4h] [ebp-64h]
  char *v9; // [esp+8h] [ebp-60h]
  char *v10; // [esp+1Ch] [ebp-4Ch]
  char **i; // [esp+20h] [ebp-48h]
  char *v12; // [esp+24h] [ebp-44h]
  const char *v13; // [esp+28h] [ebp-40h]
  const char *v14; // [esp+2Ch] [ebp-3Ch]
  const char *v15; // [esp+30h] [ebp-38h]
  const char *v16; // [esp+34h] [ebp-34h]
  const char *v17; // [esp+38h] [ebp-30h]
  const char *v18; // [esp+3Ch] [ebp-2Ch]
  const char *v19; // [esp+40h] [ebp-28h]
  const char *v20; // [esp+44h] [ebp-24h]
  const char *v21; // [esp+48h] [ebp-20h]
  const char *v22; // [esp+4Ch] [ebp-1Ch]
  const char *v23; // [esp+50h] [ebp-18h]
  const char *v24; // [esp+54h] [ebp-14h]
  int v25; // [esp+58h] [ebp-10h]
  int v26; // [esp+5Ch] [ebp-Ch]

  v13 = "[";
  v14 = "test invocation";
  v15 = "coreutils";
  v16 = "Multi-call invocation";
  v17 = "sha224sum";
  v18 = "sha2 utilities";
  v19 = "sha256sum";
  v20 = "sha2 utilities";
  v21 = "sha384sum";
  v22 = "sha2 utilities";
  v23 = "sha512sum";
  v24 = "sha2 utilities";
  v25 = 0;
  v26 = 0;
  v10 = s1;
  for ( i = (char **)(&v7 - 16); *i; i += 2 )
  {
    v8 = *i;
    if ( !strcmp(s1, v8) )
      break;
  }
  if ( i[1] )
    v10 = i[1];
  v1 = gettext("\n%s online help: <%s>\n");
  v9 = "http://www.gnu.org/software/coreutils/";
  v8 = "GNU coreutils";
  printf(v1, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  v12 = setlocale(5, 0);
  if ( v12 && strncmp(v12, "en_", 3u) )
  {
    v2 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
    v8 = s1;
    printf(v2, s1);
  }
  v3 = gettext("Full documentation at: <%s%s>\n");
  v9 = s1;
  v8 = "http://www.gnu.org/software/coreutils/";
  printf(v3, "http://www.gnu.org/software/coreutils/", s1);
  if ( v10 == s1 )
    v4 = " invocation";
  else
    v4 = &locale;
  v5 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  v9 = v4;
  v8 = v10;
  return printf(v5, v10, v4);
}

//----- (0804ACEF) --------------------------------------------------------
int __cdecl sub_804ACEF(int a1, int a2)
{
  return sub_805ACC8(a1, a2);
}

//----- (0804AD0E) --------------------------------------------------------
int __cdecl sub_804AD0E(int a1)
{
  return a1;
}

//----- (0804AD16) --------------------------------------------------------
bool __cdecl sub_804AD16(int a1)
{
  return a1 == 95;
}

//----- (0804AD22) --------------------------------------------------------
int sub_804AD22()
{
  return 0;
}

//----- (0804AD2C) --------------------------------------------------------
int __cdecl sub_804AD2C(int a1, int a2, int a3, int a4)
{
  _DWORD *v4; // ecx
  int result; // eax

  if ( (unsigned int)(*((_DWORD *)&unk_8072A3C + 4) - *((_DWORD *)&unk_8072A3C + 3)) < 0x10 )
    sub_8063395(&unk_8072A3C, 16);
  *((_DWORD *)&unk_8072A3C + 3) += 16;
  v4 = (_DWORD *)(dword_8072A48 - 16);
  v4[2] = a1;
  v4[3] = a2;
  result = a3;
  *v4 = a3;
  v4[1] = a4;
  return result;
}
// 8063395: using guessed type _DWORD __cdecl sub_8063395(_DWORD, _DWORD);
// 8072A48: using guessed type int dword_8072A48;

//----- (0804AE3F) --------------------------------------------------------
int sub_804AE3F()
{
  unsigned int v0; // ecx
  int v2; // [esp+10h] [ebp-18h]
  void *v3; // [esp+14h] [ebp-14h]

  v2 = 16;
  v3 = &unk_8072A3C;
  v0 = *((_DWORD *)&unk_8072A3C + 3) - *((_DWORD *)&unk_8072A3C + 2);
  dword_8072288 = (int (__fastcall *)(_DWORD, _DWORD))sub_804AED2;
  if ( v0 < 0x10 )
    __assert_fail("dev_ino_size <= obstack_object_size (&dev_ino_obstack)", "src/ls.c", 0x402u, "dev_ino_pop");
  return dword_8072288(v0, 16);
}
// 804AED2: using guessed type int __stdcall sub_804AED2(int);
// 8072288: using guessed type int (__fastcall *dword_8072288)(_DWORD, _DWORD);

//----- (0804AED2) --------------------------------------------------------
#error "804AF51: positive sp value has been found (funcsize=33)"

//----- (0804AF54) --------------------------------------------------------
#error "804AF84: call analysis failed (funcsize=15)"

//----- (0804AF89) --------------------------------------------------------
#error "804B0EF: positive sp value has been found (funcsize=106)"

//----- (0804B0F0) --------------------------------------------------------
int __fastcall sub_804B0F0(int a1, int a2)
{
  dword_8072288 = (int (__fastcall *)(_DWORD, _DWORD))&loc_804B17A;
  return ((int (__fastcall *)(int, int))loc_804B17A)(a1, a2);
}
// 8072288: using guessed type int (__fastcall *dword_8072288)(_DWORD, _DWORD);

//----- (0804B106) --------------------------------------------------------
int __usercall sub_804B106@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebp>, int a4, int a5)
{
  char v5; // al
  int v6; // eax

  v5 = **(_BYTE **)(a3 + 8);
  dword_8072288 = (int (__fastcall *)(_DWORD, _DWORD))&loc_804B176;
  if ( v5 == 37 )
  {
    v6 = *(char *)(a5 + 1);
    dword_8072288 = (int (__fastcall *)(_DWORD, _DWORD))sub_804B172;
    if ( v6 != 37 )
    {
      dword_8072288 = (int (__fastcall *)(_DWORD, _DWORD))&loc_804B176;
      if ( v6 == 98 )
        dword_8072288 = (int (__fastcall *)(_DWORD, _DWORD))&loc_804B19B;
    }
  }
  return dword_8072288(a2, a1);
}
// 804B172: using guessed type int sub_804B172();
// 8072288: using guessed type int (__fastcall *dword_8072288)(_DWORD, _DWORD);

//----- (0804B172) --------------------------------------------------------
#error "804B19C: positive sp value has been found (funcsize=11)"

//----- (0804B19D) --------------------------------------------------------
void sub_804B19D()
{
  char v0; // bl
  bool v1; // zf
  int v2; // edx
  int v3; // ecx
  void *v4; // eax
  int v5; // edx
  int v6; // ecx
  void *v7; // eax
  char v8; // al
  int v9; // [esp+0h] [ebp-28h]
  int v10; // [esp+0h] [ebp-28h]
  signed int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; i <= 255; ++i )
  {
    v0 = *(_BYTE *)(i + 134687356);
    v1 = (unsigned __int8)sub_8055CD8(i) == 0;
    v4 = &loc_804B1E3;
    if ( !v1 )
      v4 = &loc_804B214;
    dword_8072224 = (int)v4;
    sub_8065C0F(v3, v2, v9);
    if ( i == 126 )
      goto LABEL_15;
    v7 = &loc_804B208;
    if ( i == 45 )
      v7 = &loc_804B214;
    dword_8072224 = (int)v7;
    sub_8065C0F(v6, v5, v10);
    if ( i != 46 && i != 95 )
      v8 = 0;
    else
LABEL_15:
      v8 = 1;
    *(_BYTE *)(i + 134687356) = v0 | v8;
  }
}
// 8072224: using guessed type int dword_8072224;

//----- (0804B244) --------------------------------------------------------
signed int __cdecl sub_804B244(int a1)
{
  int v2; // eax
  int v3; // [esp+28h] [ebp-20h]
  unsigned int v4; // [esp+2Ch] [ebp-1Ch]
  int i; // [esp+30h] [ebp-18h]
  unsigned int v6; // [esp+34h] [ebp-14h]
  char *s; // [esp+38h] [ebp-10h]
  size_t v8; // [esp+3Ch] [ebp-Ch]

  v4 = 5;
  do
  {
    v6 = v4;
    v4 = 0;
    for ( i = 0; i <= 11; ++i )
    {
      v3 = v6;
      s = nl_langinfo(i + 131086);
      if ( strchr(s, 37) )
        return 0;
      v8 = sub_805AFE7(s, a1 + (i << 7), 128, (int)&v3, 0, 0);
      if ( v8 > 0x7F )
        return 0;
      v2 = v4;
      if ( v3 >= v4 )
        v2 = v3;
      v4 = v2;
    }
  }
  while ( v6 > v4 );
  return 1;
}

//----- (0804B32E) --------------------------------------------------------
char *__fastcall sub_804B32E(int a1, int a2)
{
  int v2; // eax
  void *v3; // eax
  char *result; // eax
  int v5; // [esp-4h] [ebp-65Ch]
  int v6[3]; // [esp+0h] [ebp-658h]
  char *v7; // [esp+Ch] [ebp-64Ch]
  char *v8; // [esp+10h] [ebp-648h]
  int *v9; // [esp+14h] [ebp-644h]
  int v10; // [esp+18h] [ebp-640h]
  int i; // [esp+2Ch] [ebp-62Ch]
  int j; // [esp+30h] [ebp-628h]
  int k; // [esp+34h] [ebp-624h]
  char *v14; // [esp+38h] [ebp-620h]
  char *v15; // [esp+3Ch] [ebp-61Ch]
  char *s; // [esp+40h] [ebp-618h]
  char *v17; // [esp+44h] [ebp-614h]
  int v18; // [esp+48h] [ebp-610h]
  int v19; // [esp+4Ch] [ebp-60Ch]
  char v20; // [esp+50h] [ebp-608h]

  for ( i = 0; i <= 1; ++i )
  {
    v6[0] = (int)(&off_807239C)[i];
    v2 = sub_804B0F0(a1, a2);
    a2 = i;
    *(&v18 + i) = v2;
  }
  if ( v18 )
  {
    result = (char *)(sub_804B244((int)&v20) ^ 1);
    if ( !(_BYTE)result )
    {
      for ( j = 0; j <= 1; ++j )
      {
        result = (&off_807239C)[j];
        v15 = (&off_807239C)[j];
        for ( k = 0; k <= 11; ++k )
        {
          s = (char *)(((k + 12 * j) << 7) + 134687612);
          if ( !*(&v18 + j) )
          {
            v7 = v15;
            v14 = (char *)snprintf(s, 0x80u, "%s", v15);
            dword_807224C = (int)&loc_804B582;
            sub_8065B27();
          }
          result = (char *)(*(&v18 + j) - (_DWORD)v15);
          if ( (signed int)result > 128 )
            return result;
          v17 = (char *)(*(&v18 + j) - (_DWORD)v15);
          v10 = *(&v18 + j) + 2;
          v9 = &v6[32 * k - 386];
          v8 = v15;
          v7 = v17;
          result = (char *)snprintf(s, 0x80u, "%.*s%s%s", v17, v15, v9, v10);
          v14 = result;
          if ( (signed int)result < 0 || (signed int)v14 > 127 )
            return result;
        }
      }
      byte_807377C = 1;
    }
  }
  else
  {
    v5 = v19;
    v3 = &loc_804B3B2;
    if ( v19 )
      v3 = &loc_804B3B7;
    dword_807224C = (int)v3;
    result = (char *)sub_8065B27();
  }
  return result;
}
// 807224C: using guessed type int dword_807224C;
// 807377C: using guessed type char byte_807377C;
// 804B32E: using guessed type int anonymous_0[3];

//----- (0804B5C7) --------------------------------------------------------
int __cdecl sub_804B5C7(int *a1, char *a2)
{
  return sub_8065564(*a1, a1[1], a2, 0);
}

//----- (0804B62E) --------------------------------------------------------
#error "804B6E0: call analysis failed (funcsize=65)"

//----- (0804B6FB) --------------------------------------------------------
void __cdecl sub_804B6FB(void *ptr)
{
  free(ptr);
}

//----- (0804B70E) --------------------------------------------------------
_BOOL4 __cdecl sub_804B70E(int a1, int a2, int a3, int a4)
{
  _DWORD *ptr; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]

  ptr = sub_8061F5F(0x10u);
  *ptr = a3;
  ptr[1] = a4;
  ptr[2] = a1;
  ptr[3] = a2;
  v6 = sub_8058E55((int)dword_807283C, (int)ptr);
  if ( !v6 )
    sub_80620AF();
  if ( (_DWORD *)v6 != ptr )
    free(ptr);
  return v6 != (_DWORD)ptr;
}

//----- (0804B7ED) --------------------------------------------------------
void __cdecl sub_804B7ED(void *ptr)
{
  free(*(void **)ptr);
  free(*((void **)ptr + 1));
  free(ptr);
}

//----- (0804B81B) --------------------------------------------------------
#error "804B854: call analysis failed (funcsize=18)"

//----- (0804B859) --------------------------------------------------------
#error "804B8C8: positive sp value has been found (funcsize=0)"

//----- (0804B8C9) --------------------------------------------------------
size_t sub_804B8C9()
{
  sub_80545CB((int)&dword_80722DC);
  return sub_80545CB((int)&dword_80722E4);
}
// 80722DC: using guessed type int dword_80722DC;
// 80722E4: using guessed type int dword_80722E4;

//----- (0804B8E9) --------------------------------------------------------
size_t sub_804B8E9()
{
  size_t result; // eax

  result = (unsigned __int8)byte_80728C0;
  if ( byte_80728C0 )
  {
    result = sub_804B81B(4);
    if ( (_BYTE)result )
    {
      sub_80545CB((int)&dword_80722DC);
      sub_80545CB((int)&unk_80722FC);
      result = sub_80545CB((int)&dword_80722E4);
    }
  }
  return result;
}
// 804B81B: using guessed type _DWORD __cdecl sub_804B81B(_DWORD);
// 80722DC: using guessed type int dword_80722DC;
// 80722E4: using guessed type int dword_80722E4;
// 80728C0: using guessed type char byte_80728C0;

//----- (0804B930) --------------------------------------------------------
int __cdecl sub_804B930(int a1)
{
  int result; // eax

  result = dword_807299C;
  if ( !dword_807299C )
  {
    result = a1;
    dword_807299C = a1;
  }
  return result;
}
// 807299C: using guessed type int dword_807299C;

//----- (0804B946) --------------------------------------------------------
int sub_804B946()
{
  int result; // eax

  result = dword_807299C;
  if ( !dword_807299C )
    result = dword_80729A0++ + 1;
  return result;
}
// 807299C: using guessed type int dword_807299C;
// 80729A0: using guessed type int dword_80729A0;

//----- (0804B961) --------------------------------------------------------
int __fastcall sub_804B961(int a1, int a2)
{
  dword_8072288 = (int (__fastcall *)(_DWORD, _DWORD))&loc_804BA7A;
  return ((int (__fastcall *)(int, int))loc_804BA7A)(a1, a2);
}
// 8072288: using guessed type int (__fastcall *dword_8072288)(_DWORD, _DWORD);

//----- (0804B97D) --------------------------------------------------------
#error "804BAC6: positive sp value has been found (funcsize=70)"

//----- (0804BAC7) --------------------------------------------------------
__sighandler_t __cdecl sub_804BAC7(void (*a1)(int))
{
  __sighandler_t result; // eax
  int v2; // edx
  int v3; // ecx
  int v4; // ST00_4
  int v5; // [esp+0h] [ebp-B8h]
  int v6; // [esp+4h] [ebp-B4h]
  int v7; // [esp+8h] [ebp-B0h]
  int v8; // [esp+Ch] [ebp-ACh]
  signed int v9; // [esp+10h] [ebp-A8h]
  signed int i; // [esp+10h] [ebp-A8h]
  signed int j; // [esp+10h] [ebp-A8h]
  int (__cdecl *v12)(int); // [esp+14h] [ebp-A4h]
  char v13; // [esp+18h] [ebp-A0h]
  int v14; // [esp+1Ch] [ebp-9Ch]
  int v15; // [esp+20h] [ebp-98h]
  int v16; // [esp+24h] [ebp-94h]
  int v17; // [esp+28h] [ebp-90h]
  int v18; // [esp+2Ch] [ebp-8Ch]
  int v19; // [esp+30h] [ebp-88h]
  int v20; // [esp+34h] [ebp-84h]
  int v21; // [esp+38h] [ebp-80h]
  int v22; // [esp+3Ch] [ebp-7Ch]
  int v23; // [esp+40h] [ebp-78h]
  int v24; // [esp+44h] [ebp-74h]
  int v25; // [esp+48h] [ebp-70h]
  int v26; // [esp+4Ch] [ebp-6Ch]
  int v27; // [esp+50h] [ebp-68h]
  int v28; // [esp+54h] [ebp-64h]
  int v29; // [esp+58h] [ebp-60h]
  int v30; // [esp+98h] [ebp-20h]

  result = a1;
  LOBYTE(v8) = (_BYTE)a1;
  if ( (_BYTE)a1 )
  {
    sigemptyset(&set);
    v9 = 0;
    dword_8072224 = (int)&loc_804BB6C;
    sub_8065C0F(v3, v2, v4);
    do
    {
      sigaction(sig[v9], 0, (struct sigaction *)&v12);
      if ( v12 != (int (__cdecl *)(int))1 )
        sigaddset(&set, sig[v9]);
      ++v9;
    }
    while ( v9 <= 11 );
    result = (__sighandler_t)32;
    qmemcpy(&v13, &set, 0x80u);
    v30 = 0x10000000;
    for ( i = 0; i <= 11; ++i )
    {
      result = (__sighandler_t)sigismember(&set, sig[i]);
      if ( result )
      {
        if ( sig[i] == 20 )
        {
          dword_8072260 = (int)&loc_804BBF7;
          sub_8065AB5(
            v5,
            v6,
            v7,
            v8,
            i,
            v12,
            *(_DWORD *)&v13,
            v14,
            v15,
            v16,
            v17,
            v18,
            v19,
            v20,
            v21,
            v22,
            v23,
            v24,
            v25,
            v26,
            v27,
            v28,
            v29);
        }
        v12 = sub_804B930;
        result = (__sighandler_t)sigaction(sig[i], (const struct sigaction *)&v12, 0);
      }
    }
  }
  else
  {
    for ( j = 0; j <= 11; ++j )
    {
      result = (__sighandler_t)sigismember(&set, sig[j]);
      if ( result )
        result = signal(sig[j], 0);
    }
  }
  return result;
}
// 8065AB5: using guessed type int __stdcall sub_8065AB5(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8072224: using guessed type int dword_8072224;
// 8072260: using guessed type int dword_8072260;

//----- (0804BC9F) --------------------------------------------------------
__sighandler_t sub_804BC9F()
{
  return sub_804BAC7((void (*)(int))1);
}

//----- (0804BCB3) --------------------------------------------------------
__sighandler_t sub_804BCB3()
{
  return sub_804BAC7(0);
}

//----- (0804BCC7) --------------------------------------------------------
#error "804BE71: call analysis failed (funcsize=420)"

//----- (0804C470) --------------------------------------------------------
#error "804C4D7: call analysis failed (funcsize=41)"

//----- (0804C519) --------------------------------------------------------
int __usercall sub_804C519@<eax>(const char *a1@<ebx>, int argc, char **argv)
{
  void *v3; // eax
  char *v4; // eax
  int v5; // edx
  int v6; // ecx
  char *v7; // eax
  int v8; // edx
  int v9; // ecx
  signed int v10; // eax
  char *v11; // eax
  char *v12; // eax
  char *v13; // eax
  void *v14; // eax
  bool v15; // al
  char v16; // al
  int v17; // eax
  const char *v18; // eax
  void *v19; // eax
  char v20; // al
  int v21; // edx
  void *v22; // eax
  int v23; // eax
  bool v24; // zf
  void *v25; // eax
  const char *v26; // ebx
  int v27; // edx
  int v28; // ecx
  int v29; // ebx
  char *v30; // eax
  char *v31; // eax
  FILE *v32; // ebx
  char *v33; // eax
  int **v34; // eax
  FILE *v35; // ebx
  char *v36; // eax
  int v37; // eax
  void *v38; // eax
  int v39; // edx
  int v40; // ecx
  void *v41; // eax
  int result; // eax
  const char *v43; // [esp-8h] [ebp-90h]
  int v44; // [esp-4h] [ebp-8Ch]
  char *v45; // [esp+0h] [ebp-88h]
  int v46; // [esp+4h] [ebp-84h]
  int *v47; // [esp+8h] [ebp-80h]
  void *v48; // [esp+Ch] [ebp-7Ch]
  const char *v49; // [esp+10h] [ebp-78h]
  const char *v50; // [esp+14h] [ebp-74h]
  int v51; // [esp+18h] [ebp-70h]
  int v52; // [esp+1Ch] [ebp-6Ch]
  int v53; // [esp+20h] [ebp-68h]
  int v54; // [esp+24h] [ebp-64h]
  int v55; // [esp+28h] [ebp-60h]
  int v56; // [esp+2Ch] [ebp-5Ch]
  int v57; // [esp+30h] [ebp-58h]
  char *v58; // [esp+34h] [ebp-54h]
  char *v59; // [esp+38h] [ebp-50h]
  int v60; // [esp+3Ch] [ebp-4Ch]
  _BYTE *i; // [esp+40h] [ebp-48h]
  char *s1; // [esp+44h] [ebp-44h]
  char *v63; // [esp+48h] [ebp-40h]
  char **v64; // [esp+4Ch] [ebp-3Ch]
  int v65; // [esp+50h] [ebp-38h]
  char *v66; // [esp+54h] [ebp-34h]
  char *nptr; // [esp+58h] [ebp-30h]
  int v68; // [esp+5Ch] [ebp-2Ch]
  char *v69; // [esp+60h] [ebp-28h]
  int v70; // [esp+64h] [ebp-24h]
  char *s; // [esp+68h] [ebp-20h]
  int v72; // [esp+6Ch] [ebp-1Ch]
  _DWORD *v73; // [esp+70h] [ebp-18h]
  int v74; // [esp+74h] [ebp-14h]
  int longind; // [esp+78h] [ebp-10h]

  v58 = 0;
  HIWORD(v57) = 0;
  byte_80728E4 = 0;
  if ( dword_80723E4 == 2 )
  {
    dword_8072898 = 2;
    sub_805F10F(0, 7);
  }
  else
  {
    v44 = dword_80723E4;
    v43 = a1;
    v3 = &loc_804C571;
    if ( dword_80723E4 == 3 )
      v3 = &loc_804C59B;
    dword_80721F0 = (int)v3;
    a1 = v43;
    if ( sub_8065D53(v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55) != 1 )
      abort();
    if ( isatty(1) )
    {
      dword_8072898 = 2;
      sub_805F10F(0, 3);
      byte_80728E4 = 1;
    }
    else
    {
      dword_8072898 = 1;
      byte_80728E4 = 0;
    }
  }
  dword_807289C = 0;
  dword_80728A0 = 0;
  byte_80728A4 = 0;
  byte_80728A6 = 0;
  byte_80728A7 = 0;
  dword_80728BC = 0;
  byte_80728CD = 0;
  dword_80728D0 = 1;
  byte_80728D4 = 0;
  byte_80728D5 = 0;
  dword_80728D8 = 0;
  dword_80728DC = 0;
  dword_80728E0 = 0;
  byte_807286C = 0;
  sub_804E000();
  dword_80728F8 = 80;
  v66 = getenv("COLUMNS");
  if ( v66 )
  {
    if ( *v66 )
    {
      v45 = v66;
      if ( (unsigned __int8)sub_804C470() ^ 1 )
      {
        v45 = v66;
        a1 = (const char *)sub_8060EE8();
        v4 = gettext("ignoring invalid width in environment variable COLUMNS: %s");
        v48 = (void *)a1;
        error(0, 0, v4);
      }
    }
  }
  v47 = &longind;
  if ( ioctl(1, 0x5413u) != -1 && HIWORD(longind) )
    dword_80728F8 = HIWORD(longind);
  nptr = getenv("TABSIZE");
  dword_80728F0 = 8;
  if ( nptr )
  {
    if ( sub_8062529(v5, v6, nptr, 0, 0, (int)&longind, 0) )
    {
      v45 = nptr;
      a1 = (const char *)sub_8060EE8();
      v7 = gettext("ignoring invalid tab size in environment variable TABSIZE: %s");
      v48 = (void *)a1;
      error(0, 0, v7);
    }
    else
    {
      dword_80728F0 = longind;
    }
  }
  while ( 1 )
  {
    longind = -1;
    v68 = getopt_long(argc, argv, "abcdfghiklmnopqrstuvw:xABCDFGHI:LNQRST:UXZ1", &longopts, &longind);
    if ( v68 == -1 )
      break;
LABEL_25:
    switch ( v68 )
    {
      case 4294967165:
        if ( dword_80723E4 == 1 )
        {
          v18 = "ls";
        }
        else if ( dword_80723E4 == 2 )
        {
          v18 = "dir";
        }
        else
        {
          v18 = "vdir";
        }
        v51 = 0;
        v50 = "David MacKenzie";
        v49 = "Richard M. Stallman";
        sub_8061D92(stdout, (int)v18, (int)"GNU coreutils", off_80723E8, "Richard M. Stallman", "David MacKenzie", 0);
        exit(0);
        return result;
      case 4294967166:
        sub_80553EF(0);
        return result;
      case 49:
        goto LABEL_75;
      case 65:
        if ( !dword_80728D8 )
          dword_80728D8 = 1;
        continue;
      case 66:
        sub_804E974((int)"*~");
        sub_804E974((int)".*~");
        continue;
      case 67:
        dword_8072898 = 2;
        continue;
      case 68:
        byte_80728B8 = 1;
        continue;
      case 70:
        dword_80728BC = 3;
        dword_8072204 = (int)&loc_804D1A4;
        sub_8065CE1(v9, v8, v45, v46, v47);
        goto LABEL_63;
      case 71:
LABEL_63:
        byte_80722BF = 0;
        dword_80721F0 = (int)&loc_804D1A4;
        sub_8065D53(v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55);
        goto LABEL_64;
      case 72:
LABEL_64:
        dword_80728D0 = 3;
        continue;
      case 73:
        goto LABEL_66;
      case 76:
        dword_80728D0 = 5;
        continue;
      case 78:
        sub_805F10F(0, 0);
        continue;
      case 81:
        sub_805F10F(0, 5);
        continue;
      case 82:
        byte_80728D4 = 1;
        continue;
      case 83:
        dword_80728A0 = 2;
        BYTE2(v57) = 1;
        continue;
      case 84:
        v12 = gettext("invalid tab size");
        dword_80728F0 = sub_80620E8(optarg, 0, 0, 0, -1, 0, &locale, (int)v12, 2);
        continue;
      case 85:
        dword_80728A0 = -1;
        BYTE2(v57) = 1;
        dword_8072204 = (int)&loc_804D1A4;
        sub_8065CE1(v9, v8, v45, v46, v47);
        goto LABEL_74;
      case 88:
LABEL_74:
        dword_80728A0 = 1;
        BYTE2(v57) = 1;
        dword_8072224 = (int)&loc_804D1A4;
        sub_8065C0F(v9, v8, v45);
LABEL_75:
        if ( dword_8072898 )
          dword_8072898 = 1;
        continue;
      case 90:
        byte_807286C = 1;
        continue;
      case 97:
        dword_80728D8 = 2;
        continue;
      case 98:
        sub_805F10F(0, 7);
        continue;
      case 99:
        dword_807289C = 1;
        continue;
      case 100:
        byte_80728D5 = 1;
        continue;
      case 102:
        dword_80728D8 = 2;
        dword_80728A0 = -1;
        BYTE2(v57) = 1;
        if ( !dword_8072898 )
        {
          if ( isatty(1) )
            v10 = 2;
          else
            v10 = 1;
          dword_8072898 = v10;
        }
        byte_80728A7 = 0;
        byte_80728C0 = 0;
        byte_80728C1 = 0;
        continue;
      case 103:
        dword_8072898 = 0;
        byte_80722BE = 0;
        continue;
      case 104:
        dword_80728A8 = 176;
        dword_80728B4 = 176;
        *(_QWORD *)&qword_80728AC = 1LL;
        *(_QWORD *)&qword_80722C4 = 1LL;
        continue;
      case 105:
        byte_80728CD = 1;
        continue;
      case 107:
        HIBYTE(v57) = 1;
        continue;
      case 108:
        dword_8072898 = 0;
        continue;
      case 109:
        dword_8072898 = 4;
        dword_80721F0 = (int)&loc_804D1A4;
        sub_8065D53(v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55);
        goto LABEL_43;
      case 110:
LABEL_43:
        byte_80728A6 = 1;
        dword_8072898 = 0;
        continue;
      case 111:
        dword_8072898 = 0;
        byte_80722BF = 0;
        continue;
      case 112:
        dword_80728BC = 1;
        continue;
      case 113:
        byte_80728E4 = 1;
        continue;
      case 114:
        byte_80728A4 = 1;
        dword_80721DC = (int)&loc_804D1A4;
        sub_8065DC3(v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59);
        goto LABEL_48;
      case 115:
LABEL_48:
        byte_80728A7 = 1;
        continue;
      case 116:
        dword_80728A0 = 4;
        BYTE2(v57) = 1;
        continue;
      case 117:
        dword_807289C = 2;
        continue;
      case 118:
        dword_80728A0 = 3;
        BYTE2(v57) = 1;
        continue;
      case 119:
        v45 = optarg;
        if ( (unsigned __int8)sub_804C470() ^ 1 )
        {
          v45 = optarg;
          a1 = (const char *)sub_8060EE8();
          v11 = gettext("invalid line width");
          v49 = a1;
          v48 = v11;
          error(2, 0, "%s: %s");
        }
        continue;
      case 120:
        dword_8072898 = 3;
        continue;
      case 128:
        byte_80728A5 = 1;
        dword_80721F0 = (int)&loc_804D1A4;
        sub_8065D53(v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55);
        goto LABEL_79;
      case 129:
        v74 = sub_805A827((int)optarg, (int)&dword_80728A8, (__int64 *)&qword_80728AC);
        if ( v74 )
          sub_8062A8D(v74, longind, 0, (int)&longopts, (int)optarg);
        dword_80728B4 = dword_80728A8;
        *(_QWORD *)&qword_80722C4 = *(_QWORD *)&qword_80728AC;
        continue;
      case 130:
        v13 = optarg;
        if ( optarg )
        {
          v13 = (char *)dword_8067958[sub_8055BC7(
                                        (int)"--color",
                                        optarg,
                                        (int)off_8067918,
                                        (int)dword_8067958,
                                        4u,
                                        off_80723EC)];
          v59 = v13;
        }
        else
        {
          v59 = (char *)1;
        }
        v44 = (int)v13;
        v43 = a1;
        v14 = &loc_804CE99;
        if ( v59 == (char *)1 )
          v14 = &loc_804CEAF;
        dword_80721DC = (int)v14;
        a1 = v43;
        sub_8065DC3(v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59);
        v15 = v59 == (char *)2 && isatty(1);
        byte_80728C0 = v15;
        if ( v15 )
          dword_80728F0 = 0;
        continue;
      case 131:
        dword_80728D0 = 4;
        dword_807224C = (int)&loc_804D1A4;
        sub_8065B27();
LABEL_66:
        sub_804E974((int)optarg);
        continue;
      case 132:
        dword_80728BC = 2;
        continue;
      case 133:
        dword_8072898 = dword_8067838[sub_8055BC7(
                                        (int)"--format",
                                        optarg,
                                        (int)off_8067818,
                                        (int)dword_8067838,
                                        4u,
                                        off_80723EC)];
        dword_80721DC = (int)&loc_804D1A4;
        sub_8065DC3(v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59);
        goto LABEL_84;
      case 134:
LABEL_84:
        dword_8072898 = 0;
        v58 = (char *)sub_804AD0E((int)"full-iso");
        continue;
      case 135:
        byte_80728D6 = 1;
        continue;
      case 136:
LABEL_79:
        v73 = sub_8061F5F(8u);
        *v73 = optarg;
        v73[1] = dword_80728E0;
        dword_80728E0 = (int)v73;
        continue;
      case 137:
        if ( optarg )
        {
          v60 = dword_8067958[sub_8055BC7(
                                (int)"--hyperlink",
                                optarg,
                                (int)off_8067918,
                                (int)dword_8067958,
                                4u,
                                off_80723EC)];
          dword_80721F0 = (int)&loc_804CF4A;
          sub_8065D53(v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55);
        }
        v60 = 1;
        v16 = 1;
        byte_80728C1 = v16 & 1;
        dword_80721DC = (int)&loc_804D1A4;
        sub_8065DC3(v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59);
        goto LABEL_105;
      case 138:
LABEL_105:
        dword_80728BC = dword_8067208[sub_8055BC7(
                                        (int)"--indicator-style",
                                        optarg,
                                        (int)off_80671F4,
                                        (int)dword_8067208,
                                        4u,
                                        off_80723EC)];
        continue;
      case 139:
        v17 = sub_8055BC7((int)"--quoting-style", optarg, (int)off_806AA98, (int)dword_806AAD8, 4u, off_80723EC);
        sub_805F10F(0, dword_806AAD8[v17]);
        dword_8072260 = (int)&loc_804D1A4;
        sub_8065AB5(
          v45,
          v46,
          v47,
          v48,
          v49,
          v50,
          v51,
          v52,
          v53,
          v54,
          v55,
          v56,
          v57,
          v58,
          v59,
          v60,
          i,
          s1,
          v63,
          v64,
          v65,
          v66,
          nptr);
        goto LABEL_107;
      case 140:
        byte_80728E4 = 0;
        break;
      case 141:
        dword_80728A8 = 144;
        dword_80728B4 = 144;
        *(_QWORD *)&qword_80728AC = 1LL;
        *(_QWORD *)&qword_80722C4 = 1LL;
        break;
      case 142:
        dword_80728A0 = dword_8067878[sub_8055BC7(
                                        (int)"--sort",
                                        optarg,
                                        (int)off_8067860,
                                        (int)dword_8067878,
                                        4u,
                                        off_80723EC)];
        BYTE2(v57) = 1;
        break;
      case 143:
        dword_807289C = dword_80678C4[sub_8055BC7(
                                        (int)"--time",
                                        optarg,
                                        (int)off_80678AC,
                                        (int)dword_80678C4,
                                        4u,
                                        off_80723EC)];
        break;
      case 144:
LABEL_107:
        v58 = optarg;
        break;
      default:
        sub_80553EF(2);
        return result;
    }
  }
  if ( *(_QWORD *)&qword_80728AC )
  {
    dword_80721F0 = (int)&loc_804D22D;
    sub_8065D53(v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55);
    goto LABEL_25;
  }
  v69 = getenv("LS_BLOCK_SIZE");
  sub_805A827((int)v69, (int)&dword_80728A8, (__int64 *)&qword_80728AC);
  if ( v69 || getenv("BLOCK_SIZE") )
  {
    dword_80728B4 = dword_80728A8;
    *(_QWORD *)&qword_80722C4 = *(_QWORD *)&qword_80728AC;
  }
  if ( HIBYTE(v57) )
  {
    dword_80728A8 = 0;
    *(_QWORD *)&qword_80728AC = 1024LL;
  }
  dword_80729AC = (dword_80728F8 % 3u != 0) + dword_80728F8 / 3u;
  v70 = sub_805F0F8(0);
  if ( dword_8072898 == 4 || dword_8072898 == 1 )
    goto LABEL_190;
  if ( !dword_80728F8 )
  {
    v44 = dword_8072898;
    v43 = a1;
    v19 = &loc_804D2FF;
    if ( dword_8072898 )
      v19 = &loc_804D318;
    dword_80721DC = (int)v19;
    a1 = v43;
    sub_8065DC3(v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59);
  }
  if ( v70 != 1 && v70 != 3 && v70 != 6 )
LABEL_190:
    v20 = 0;
  else
    v20 = 1;
  byte_807284D = v20 & 1;
  dword_80728E8 = sub_805F093(0);
  if ( v70 == 7 )
  {
    v47 = (int *)1;
    sub_805F129(dword_80728E8, 32);
  }
  if ( (unsigned int)dword_80728BC > 1 )
  {
    for ( i = (_BYTE *)(dword_80728BC - 2 + 134642700); *i; ++i )
    {
      v21 = (char)*i;
      v47 = (int *)1;
      sub_805F129(dword_80728E8, v21);
    }
  }
  dword_80728EC = sub_805F093(0);
  v47 = (int *)1;
  sub_805F129(dword_80728EC, 58);
  if ( byte_80728B8 && (dword_8072898 || byte_80728C1) )
    byte_80728B8 = 0;
  if ( dword_807289C == 1 || dword_807289C == 2 )
  {
    v44 = BYTE2(v57) ^ 1;
    v43 = a1;
    v22 = &loc_804D441;
    if ( BYTE2(v57) == 1 )
      v22 = &loc_804D454;
    dword_8072238 = (int)v22;
    a1 = v43;
    sub_8065B9D(
      v45,
      v46,
      v47,
      v48,
      v49,
      v50,
      v51,
      v52,
      v53,
      v54,
      v55,
      v56,
      v57,
      v58,
      v59,
      v60,
      i,
      s1,
      v63,
      v64,
      v65,
      v66,
      nptr,
      v68,
      v69,
      v70,
      s);
    if ( dword_8072898 )
      dword_80728A0 = 4;
  }
  if ( !dword_8072898 )
  {
    s1 = v58;
    if ( !v58 )
    {
      s1 = getenv("TIME_STYLE");
      if ( !s1 )
        s1 = (char *)sub_804AD0E((int)"locale");
    }
    v23 = strncmp(s1, "posix-", 6u);
    v24 = v23 == 0;
    v44 = v23;
    v43 = a1;
    v25 = &loc_804D4EE;
    if ( v24 )
      v25 = &loc_804D495;
    dword_80721DC = (int)v25;
    v26 = v43;
    sub_8065DC3(v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59);
    if ( *s1 == 43 )
    {
      s = s1 + 1;
      v63 = strchr(s1 + 1, 10);
      if ( v63 )
      {
        if ( strchr(v63 + 1, 10) )
        {
          v45 = s;
          v29 = sub_8060EE8();
          v30 = gettext("invalid time style format %s");
          v48 = (void *)v29;
          error(2, 0, v30, v29);
        }
        v31 = v63;
        v27 = (int)(v63++ + 1);
        *v31 = 0;
      }
      else
      {
        v63 = s;
      }
      off_807239C = s;
      off_80723A0 = v63;
    }
    else
    {
      v72 = sub_80558B1(s1, (int)off_80671B0, (int)&unk_80671C4, 4u);
      if ( v72 < 0 )
      {
        sub_8055A08((int)"time style", (int)s1, v72);
        v32 = stderr;
        v33 = gettext("Valid arguments are:\n");
        fputs_unlocked(v33, v32);
        v64 = off_80671B0;
        while ( *v64 )
        {
          v34 = (int **)v64;
          ++v64;
          v47 = *v34;
          fprintf(stderr, "  - [posix-]%s\n", v47);
        }
        v35 = stderr;
        v36 = gettext("  - +FORMAT (e.g., +%H:%M) for a 'date'-style format\n");
        fputs_unlocked(v36, v35);
        sub_80553EF(2);
      }
      v37 = v72;
      if ( v72 == 1 )
      {
        off_80723A0 = "%Y-%m-%d %H:%M";
        off_807239C = "%Y-%m-%d %H:%M";
      }
      else
      {
        if ( v72 <= 1 )
        {
          v44 = v72;
          v43 = v26;
          v38 = &loc_804D68B;
          if ( !v72 )
            v38 = &loc_804D6CA;
          dword_8072260 = (int)v38;
          v26 = v43;
          sub_8065AB5(
            v45,
            v46,
            v47,
            v48,
            v49,
            v50,
            v51,
            v52,
            v53,
            v54,
            v55,
            v56,
            v57,
            v58,
            v59,
            v60,
            i,
            s1,
            v63,
            v64,
            v65,
            v66,
            nptr);
          dword_8072224 = (int)&loc_804D75B;
          v37 = sub_8065C0F(v40, v39, v45);
        }
        if ( v37 == 2 )
        {
          off_807239C = "%Y-%m-%d ";
          off_80723A0 = "%m-%d %H:%M";
        }
        else
        {
          v24 = v37 == 3;
          v44 = v37;
          v43 = v26;
          v41 = &loc_804D6C5;
          if ( v24 )
            v41 = &loc_804D70C;
          dword_8072260 = (int)v41;
          sub_8065AB5(
            v45,
            v46,
            v47,
            v48,
            v49,
            v50,
            v51,
            v52,
            v53,
            v54,
            v55,
            v56,
            v57,
            v58,
            v59,
            v60,
            i,
            s1,
            v63,
            v64,
            v65,
            v66,
            nptr);
        }
      }
    }
    sub_804B32E(v28, v27);
  }
  return optind;
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 805F129: using guessed type _DWORD __cdecl sub_805F129(_DWORD, _DWORD);
// 8065AB5: using guessed type int __stdcall sub_8065AB5(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8065B9D: using guessed type int __stdcall sub_8065B9D(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8065D53: using guessed type int __stdcall sub_8065D53(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8065DC3: using guessed type int __stdcall sub_8065DC3(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80671B0: using guessed type char *off_80671B0[4];
// 80671F4: using guessed type char *off_80671F4[4];
// 8067818: using guessed type char *off_8067818[7];
// 8067838: using guessed type int dword_8067838[];
// 8067860: using guessed type char *off_8067860[5];
// 80678AC: using guessed type char *off_80678AC[5];
// 8067918: using guessed type char *off_8067918[4];
// 806AA98: using guessed type char *off_806AA98[10];
// 80721DC: using guessed type int dword_80721DC;
// 80721F0: using guessed type int dword_80721F0;
// 8072204: using guessed type int dword_8072204;
// 8072224: using guessed type int dword_8072224;
// 8072238: using guessed type int dword_8072238;
// 807224C: using guessed type int dword_807224C;
// 8072260: using guessed type int dword_8072260;
// 80722BE: using guessed type char byte_80722BE;
// 80722BF: using guessed type char byte_80722BF;
// 80723A0: using guessed type char *off_80723A0;
// 80723E4: using guessed type int dword_80723E4;
// 8072480: using guessed type int optind;
// 807284D: using guessed type char byte_807284D;
// 807286C: using guessed type char byte_807286C;
// 8072898: using guessed type int dword_8072898;
// 807289C: using guessed type int dword_807289C;
// 80728A0: using guessed type int dword_80728A0;
// 80728A4: using guessed type char byte_80728A4;
// 80728A5: using guessed type char byte_80728A5;
// 80728A6: using guessed type char byte_80728A6;
// 80728A7: using guessed type char byte_80728A7;
// 80728B8: using guessed type char byte_80728B8;
// 80728BC: using guessed type int dword_80728BC;
// 80728C0: using guessed type char byte_80728C0;
// 80728C1: using guessed type char byte_80728C1;
// 80728CD: using guessed type char byte_80728CD;
// 80728D0: using guessed type int dword_80728D0;
// 80728D4: using guessed type char byte_80728D4;
// 80728D5: using guessed type char byte_80728D5;
// 80728D6: using guessed type char byte_80728D6;
// 80728D8: using guessed type int dword_80728D8;
// 80728E4: using guessed type char byte_80728E4;
// 80728E8: using guessed type int dword_80728E8;
// 80728EC: using guessed type int dword_80728EC;
// 80728F0: using guessed type int dword_80728F0;
// 80728F8: using guessed type int dword_80728F8;

//----- (0804D76E) --------------------------------------------------------
bool __cdecl sub_804D76E(_DWORD *a1, _BYTE **a2, char a3, int *a4)
{
  signed int v4; // eax
  _BYTE *v5; // eax
  _BYTE *v6; // edx
  _BYTE *v7; // eax
  _BYTE *v8; // eax
  _BYTE *v9; // eax
  _BYTE *v10; // eax
  _BYTE *v11; // eax
  _BYTE *v12; // eax
  _BYTE *v13; // eax
  void *v14; // eax
  _BYTE *v15; // eax
  _BYTE *v16; // ST30_4
  _BYTE *v17; // edx
  int v18; // ST28_4
  _BYTE *v19; // eax
  bool result; // al
  int v21; // [esp+0h] [ebp-38h]
  int v22; // [esp+4h] [ebp-34h]
  int v23; // [esp+8h] [ebp-30h]
  _DWORD v24[4]; // [esp+Ch] [ebp-2Ch]
  int v25; // [esp+10h] [ebp-28h]
  int v26; // [esp+14h] [ebp-24h]
  int v27; // [esp+18h] [ebp-20h]
  int v28; // [esp+1Ch] [ebp-1Ch]
  int v29; // [esp+20h] [ebp-18h]
  unsigned int v30; // [esp+24h] [ebp-14h]
  _BYTE *v31; // [esp+28h] [ebp-10h]
  _BYTE *v32; // [esp+2Ch] [ebp-Ch]
  int v33; // [esp+30h] [ebp-8h]
  int v34; // [esp+34h] [ebp-4h]
  int savedregs; // [esp+38h] [ebp+0h]

  LOBYTE(v24[0]) = a3;
  v31 = *a2;
  v32 = (_BYTE *)*a1;
  v29 = 0;
  HIBYTE(v28) = 0;
  v30 = 0;
LABEL_55:
  while ( v30 <= 4 )
  {
    switch ( v30 )
    {
      case 0u:
        v4 = (char)*v31;
        if ( v4 == 61 )
        {
          if ( LOBYTE(v24[0]) )
          {
            v30 = 5;
            goto LABEL_17;
          }
        }
        else if ( v4 > 61 )
        {
          if ( v4 == 92 )
          {
            v30 = 1;
            ++v31;
            goto LABEL_17;
          }
          if ( v4 == 94 )
          {
            v30 = 4;
            ++v31;
            goto LABEL_17;
          }
        }
        else if ( !*v31 || v4 == 58 )
        {
          v30 = 5;
          goto LABEL_17;
        }
        v5 = v32++;
        v6 = v31++;
        *v5 = *v6;
        ++v29;
LABEL_17:
        dword_807224C = (int)&loc_804DB25;
        sub_8065B27();
LABEL_18:
        switch ( *v31 )
        {
          case 0:
            v30 = 6;
            break;
          case 48:
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
            v30 = 2;
            HIBYTE(v28) = *v31 - 48;
            break;
          case 63:
            HIBYTE(v28) = 127;
            break;
          case 88:
          case 120:
            v30 = 3;
            HIBYTE(v28) = 0;
            break;
          case 95:
            HIBYTE(v28) = 32;
            break;
          case 97:
            HIBYTE(v28) = 7;
            break;
          case 98:
            HIBYTE(v28) = 8;
            break;
          case 101:
            HIBYTE(v28) = 27;
            break;
          case 102:
            HIBYTE(v28) = 12;
            break;
          case 110:
            HIBYTE(v28) = 10;
            break;
          case 114:
            HIBYTE(v28) = 13;
            dword_80721DC = (int)&loc_804D908;
            sub_8065DC3(v21, v22, v23, v24[0], v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, savedregs);
            goto LABEL_27;
          case 116:
LABEL_27:
            HIBYTE(v28) = 9;
            break;
          case 118:
            HIBYTE(v28) = 11;
            break;
          default:
            HIBYTE(v28) = *v31;
            break;
        }
        if ( v30 == 1 )
        {
          v7 = v32++;
          *v7 = HIBYTE(v28);
          ++v29;
          v30 = 0;
        }
        ++v31;
        break;
      case 1u:
        goto LABEL_18;
      case 2u:
        if ( *v31 > 47 && *v31 <= 55 )
        {
          v9 = v31++;
          HIBYTE(v28) = 8 * HIBYTE(v28) + *v9 - 48;
        }
        else
        {
          v8 = v32++;
          *v8 = HIBYTE(v28);
          ++v29;
          v30 = 0;
        }
        goto LABEL_55;
      case 3u:
        switch ( *v31 )
        {
          case 48:
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            v10 = v31++;
            HIBYTE(v28) = 16 * HIBYTE(v28) + *v10 - 48;
            break;
          case 65:
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
            v12 = v31++;
            HIBYTE(v28) = 16 * HIBYTE(v28) + *v12 - 55;
            break;
          case 97:
          case 98:
          case 99:
          case 100:
          case 101:
          case 102:
            v11 = v31++;
            HIBYTE(v28) = 16 * HIBYTE(v28) + *v11 - 87;
            break;
          default:
            v13 = v32++;
            *v13 = HIBYTE(v28);
            ++v29;
            v30 = 0;
            break;
        }
        goto LABEL_55;
      case 4u:
        v30 = 0;
        if ( *v31 <= 63 )
        {
          if ( *v31 == 63 )
          {
            v19 = v32++;
            *v19 = 127;
            ++v29;
          }
          else
          {
            v30 = 6;
          }
        }
        else
        {
          v14 = &loc_804DAA9;
          if ( *v31 == 127 )
            v14 = &loc_804DAF9;
          dword_80721F0 = (int)v14;
          sub_8065D53(v21, v22, v23, v24[0], v25, v26, v27, v28, v29, 0, v31);
          v15 = v32++;
          v17 = v16;
          v31 = v16 + 1;
          *v15 = *v17 & 0x1F;
          v29 = v18 + 1;
        }
        goto LABEL_55;
      default:
        abort();
        return result;
    }
  }
  *a1 = v32;
  *a2 = v31;
  *a4 = v29;
  return v30 != 6;
}
// 8065D53: using guessed type int __stdcall sub_8065D53(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8065DC3: using guessed type int __stdcall sub_8065DC3(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80721DC: using guessed type int dword_80721DC;
// 80721F0: using guessed type int dword_80721F0;
// 807224C: using guessed type int dword_807224C;

//----- (0804DB70) --------------------------------------------------------
signed int sub_804DB70()
{
  char *s1; // [esp+18h] [ebp-10h]
  char *name; // [esp+1Ch] [ebp-Ch]

  name = getenv("TERM");
  if ( !name || !*name )
    return 0;
  for ( s1 = "# Configuration file for dircolors, a utility to help you set the";
        (unsigned int)(s1 - "# Configuration file for dircolors, a utility to help you set the") <= 0x104C;
        s1 += strlen(s1) + 1 )
  {
    if ( !strncmp(s1, "TERM ", 5u) && !fnmatch(s1 + 5, name, 0) )
      return 1;
  }
  return 0;
}

//----- (0804DC17) --------------------------------------------------------
int sub_804DC17()
{
  int result; // eax
  int v1; // eax
  signed int v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  signed int v6; // eax
  int v7; // ebx
  char *v8; // eax
  char *v9; // eax
  signed int v10; // eax
  char *v11; // eax
  char *v12; // [esp+0h] [ebp-48h]
  const char *v13; // [esp+4h] [ebp-44h]
  int v14; // [esp+Ch] [ebp-3Ch]
  char s1[2]; // [esp+1Dh] [ebp-2Bh]
  char *s; // [esp+20h] [ebp-28h]
  void *v17; // [esp+24h] [ebp-24h]
  int v18; // [esp+28h] [ebp-20h]
  int *v19; // [esp+2Ch] [ebp-1Ch]
  int v20; // [esp+30h] [ebp-18h]
  _DWORD *v21; // [esp+34h] [ebp-14h]
  void *ptr; // [esp+38h] [ebp-10h]
  char *v23; // [esp+3Ch] [ebp-Ch]

  s = getenv("LS_COLORS");
  if ( !s || !*s )
  {
    v23 = getenv("COLORTERM");
    if ( !v23 || (result = (unsigned __int8)*v23, !(_BYTE)result) )
    {
      result = sub_804DB70() ^ 1;
      if ( (_BYTE)result )
        byte_80728C0 = 0;
    }
    return result;
  }
  v19 = 0;
  strcpy(s1, "??");
  ::ptr = sub_806208A(s);
  v17 = ::ptr;
  v20 = 1;
  while ( 2 )
  {
    switch ( v20 )
    {
      case 1:
        v1 = *s;
        if ( v1 == 42 )
        {
          v19 = (int *)sub_8061F5F(0x14u);
          v19[4] = dword_80728C4;
          dword_80728C4 = (int)v19;
          ++s;
          v19[1] = (int)v17;
          if ( sub_804D76E(&v12 - 9, &v12 - 10, 1, v19) )
            v2 = 4;
          else
            v2 = 6;
          v20 = v2;
          continue;
        }
        if ( v1 == 58 )
        {
          ++s;
          continue;
        }
        if ( *s )
        {
          v3 = s++;
          s1[0] = *v3;
          v20 = 2;
          continue;
        }
        v20 = 5;
LABEL_44:
        if ( v20 == 6 )
        {
          v11 = gettext("unparsable value for LS_COLORS environment variable");
          error(0, 0, v11);
          free(::ptr);
          v21 = (_DWORD *)dword_80728C4;
          while ( v21 )
          {
            ptr = v21;
            v21 = (_DWORD *)v21[4];
            free(ptr);
          }
          byte_80728C0 = 0;
        }
        result = dword_8072314;
        if ( dword_8072314 == 6 )
        {
          result = strncmp(off_8072318, "target", 6u);
          if ( !result )
            byte_8072858 = 1;
        }
        return result;
      case 2:
        if ( *s )
        {
          v4 = s++;
          s1[1] = *v4;
          v20 = 3;
        }
        else
        {
          v20 = 6;
        }
        continue;
      case 3:
        v20 = 6;
        v5 = s++;
        if ( *v5 != 61 )
          continue;
        v18 = 0;
        while ( 2 )
        {
          if ( (&off_8067278)[v18] )
          {
            v13 = (&off_8067278)[v18];
            if ( strcmp(s1, v13) )
            {
              ++v18;
              continue;
            }
            *(&::s1 + 2 * v18) = v17;
            if ( sub_804D76E(&v12 - 9, &v12 - 10, 0, (int *)(8 * v18 + 134685404)) )
              v6 = 1;
            else
              v6 = 6;
            v20 = v6;
          }
          break;
        }
        if ( v20 == 6 )
        {
          v12 = s1;
          v7 = sub_8060EE8();
          v8 = gettext("unrecognized prefix: %s");
          v14 = v7;
          error(0, 0, v8, v7);
        }
        continue;
      case 4:
        v9 = s++;
        if ( *v9 == 61 )
        {
          v19[3] = (int)v17;
          if ( sub_804D76E(&v12 - 9, &v12 - 10, 0, v19 + 2) )
            v10 = 1;
          else
            v10 = 6;
          v20 = v10;
        }
        else
        {
          v20 = 6;
        }
        continue;
      case 6:
        goto LABEL_44;
      default:
        abort();
        return result;
    }
  }
}
// 8072314: using guessed type int dword_8072314;
// 8072858: using guessed type char byte_8072858;
// 80728C0: using guessed type char byte_80728C0;
// 80728C4: using guessed type int dword_80728C4;

//----- (0804E000) --------------------------------------------------------
void sub_804E000()
{
  int v0; // ebx
  char *v1; // eax
  char *s; // [esp+18h] [ebp-10h]
  int v3; // [esp+1Ch] [ebp-Ch]

  s = getenv("QUOTING_STYLE");
  if ( s )
  {
    v3 = sub_80558B1(s, (int)off_806AA98, (int)dword_806AAD8, 4u);
    if ( v3 < 0 )
    {
      v0 = sub_8060EE8();
      v1 = gettext("ignoring invalid value of environment variable QUOTING_STYLE: %s");
      error(0, 0, v1, v0);
    }
    else
    {
      sub_805F10F(0, dword_806AAD8[v3]);
    }
  }
}
// 806AA98: using guessed type char *off_806AA98[10];

//----- (0804E09F) --------------------------------------------------------
int __cdecl sub_804E09F(int a1)
{
  int result; // eax

  result = a1;
  if ( (_BYTE)a1 )
  {
    dword_80729A4 = 2;
  }
  else
  {
    result = dword_80729A4;
    if ( !dword_80729A4 )
      dword_80729A4 = 1;
  }
  return result;
}
// 80729A4: using guessed type int dword_80729A4;

//----- (0804E0D2) --------------------------------------------------------
int __cdecl sub_804E0D2(int a1, char *format)
{
  int v2; // ebx
  int *v3; // eax

  v2 = sub_80609B6(4);
  v3 = __errno_location();
  error(0, *v3, format, v2);
  return sub_804E09F((unsigned __int8)a1);
}

//----- (0804E128) --------------------------------------------------------
_DWORD *__cdecl sub_804E128(char *a1, char *s, int a3)
{
  void *v3; // eax
  void *v4; // eax
  _DWORD *result; // eax
  _DWORD *v6; // [esp+1Ch] [ebp-Ch]

  v6 = sub_8061F5F(0x10u);
  if ( s )
    v3 = sub_806208A(s);
  else
    v3 = 0;
  v6[1] = v3;
  if ( a1 )
    v4 = sub_806208A(a1);
  else
    v4 = 0;
  *v6 = v4;
  *((_BYTE *)v6 + 8) = a3;
  v6[3] = dword_8072860;
  result = v6;
  dword_8072860 = (int)v6;
  return result;
}
// 8072860: using guessed type int dword_8072860;

//----- (0804E1AE) --------------------------------------------------------
unsigned int __usercall sub_804E1AE@<eax>(int a1@<ebx>, int a2, int a3, char a4)
{
  char **v4; // ebp
  int v5; // edx
  int v6; // ecx
  char *v7; // eax
  int v8; // edx
  unsigned int v9; // eax
  char *v10; // eax
  int v11; // edx
  int v12; // ebx
  int v13; // eax
  int v14; // edx
  int v15; // ebx
  char *v16; // eax
  char *v17; // eax
  int v18; // edx
  int v19; // eax
  __int64 v20; // rax
  int v21; // ecx
  int v22; // edx
  void *v23; // eax
  int v24; // edx
  int v25; // ecx
  char *v26; // eax
  int v27; // edx
  int v28; // eax
  bool v29; // zf
  void *v30; // eax
  char *v31; // eax
  int v32; // edx
  int v33; // edx
  int v35; // [esp-8h] [ebp-354h]
  int v36; // [esp-4h] [ebp-350h]
  char *name; // [esp+0h] [ebp-34Ch]
  __int64 errnum; // [esp+4h] [ebp-348h]
  int v39; // [esp+Ch] [ebp-340h]
  int v40; // [esp+10h] [ebp-33Ch]
  int v41; // [esp+14h] [ebp-338h]
  __int64 v42; // [esp+18h] [ebp-334h]
  int v43; // [esp+20h] [ebp-32Ch]
  char v44; // [esp+24h] [ebp-328h]
  int v45; // [esp+28h] [ebp-324h]
  int v46; // [esp+2Ch] [ebp-320h]
  int v47; // [esp+30h] [ebp-31Ch]
  int v48; // [esp+34h] [ebp-318h]
  int v49; // [esp+38h] [ebp-314h]
  int v50; // [esp+3Ch] [ebp-310h]
  int v51; // [esp+40h] [ebp-30Ch]
  int v52; // [esp+44h] [ebp-308h]
  int v53; // [esp+48h] [ebp-304h]
  int v54; // [esp+4Ch] [ebp-300h]
  int v55; // [esp+50h] [ebp-2FCh]
  int v56; // [esp+54h] [ebp-2F8h]
  int v57; // [esp+58h] [ebp-2F4h]

  v46 = a2;
  v45 = a3;
  v44 = a4;
  v4 = &name;
  *(&name - 3) = (char *)__readgsdword(0x14u);
  *(&name - 192) = 0;
  *(&name - 191) = 0;
  *__errno_location() = 0;
  name = *(&name - 199);
  *(&name - 196) = (char *)opendir(name);
  if ( *(&name - 196) )
  {
    if ( dword_807283C )
    {
      name = *(&name - 196);
      *(&name - 195) = (char *)dirfd((DIR *)name);
      if ( (signed int)*(&name - 195) < 0 )
      {
        LODWORD(errnum) = &name - 190;
        name = *(&name - 199);
        v9 = (unsigned int)sub_8065842((int)name, (int)(&name - 190)) >> 31;
      }
      else
      {
        LODWORD(errnum) = &name - 190;
        name = *(&name - 195);
        v9 = (unsigned int)sub_8065871((int)name, (int)(&name - 190)) >> 31;
      }
      if ( (_BYTE)v9 )
      {
        v10 = gettext("cannot determine device and inode of %s");
        v11 = *((unsigned __int8 *)&name - 804);
        HIDWORD(errnum) = *(&name - 199);
        sub_804E0D2(v11, v10);
        closedir((DIR *)*(&name - 196));
        return __readgsdword(0x14u) ^ (unsigned int)*(v4 - 3);
      }
      v12 = (int)*(&name - 167);
      v13 = (int)*(&name - 190);
      v14 = (int)*(&name - 189);
      HIDWORD(errnum) = *(&name - 168);
      if ( (unsigned __int8)sub_804B70E(v13, v14, SHIDWORD(errnum), v12) )
      {
        HIDWORD(errnum) = *(&name - 199);
        v15 = sub_8060B9B(0, 3, SHIDWORD(errnum));
        v16 = gettext("%s: not listing already-listed directory");
        v39 = v15;
        error(0, 0, v16, v15);
        closedir((DIR *)*(&name - 196));
        sub_804E09F(1);
        return __readgsdword(0x14u) ^ (unsigned int)*(v4 - 3);
      }
      a1 = (int)*(&name - 167);
      sub_804AD2C((int)*(&name - 190), (int)*(&name - 189), (int)*(&name - 168), a1);
    }
    sub_804EB79(v6, v5);
    if ( byte_80728D4 || byte_80728F4 )
    {
      if ( byte_80723A4 != 1 )
      {
        putchar_unlocked(10);
        ++dword_80729B0;
      }
      byte_80723A4 = 0;
      if ( byte_80728B8 )
      {
        fwrite_unlocked("  ", 1u, 2u, stdout);
        dword_80729B0 += 2;
      }
      *(&name - 198) = 0;
      if ( byte_80728C1 )
      {
        LODWORD(errnum) = 2;
        name = *(&name - 199);
        *(&name - 198) = sub_8055FDC(name, 2);
        if ( !*(&name - 198) )
        {
          v17 = gettext("error canonicalizing %s");
          v18 = *((unsigned __int8 *)&name - 804);
          HIDWORD(errnum) = *(&name - 199);
          sub_804E0D2(v18, v17);
        }
      }
      if ( *(&name - 200) )
        v19 = (int)*(&name - 200);
      else
        v19 = (int)*(&name - 199);
      sub_80534ED(v19, dword_80728EC, -1, 0, 1, &unk_80729FC, *(&name - 198));
      free(*(&name - 198));
      fwrite_unlocked(":\n", 1u, 2u, stdout);
      dword_80729B0 += 2;
    }
    while ( 1 )
    {
      *__errno_location() = 0;
      name = *(v4 - 196);
      *(v4 - 194) = (char *)readdir64();
      if ( !*(v4 - 194) )
        break;
      name = *(v4 - 194) + 19;
      if ( (unsigned __int8)sub_804EA1B(name) ^ 1 )
      {
        *(v4 - 197) = 0;
        switch ( (*(v4 - 194))[18] )
        {
          case 1:
            *(v4 - 197) = (char *)1;
            break;
          case 2:
            goto LABEL_29;
          case 4:
            *(v4 - 197) = (char *)3;
            break;
          case 6:
            *(v4 - 197) = (char *)4;
            dword_8072260 = (int)&loc_804E63D;
            sub_8065AB5(
              name,
              errnum,
              HIDWORD(errnum),
              v39,
              v40,
              v41,
              v42,
              HIDWORD(v42),
              v43,
              *(_DWORD *)&v44,
              v45,
              v46,
              v47,
              v48,
              v49,
              v50,
              v51,
              v52,
              v53,
              v54,
              v55,
              v56,
              v57);
            v4 = &name;
LABEL_29:
            *(v4 - 197) = (char *)2;
            break;
          case 8:
            *(v4 - 197) = (char *)5;
            break;
          case 0xA:
            *(v4 - 197) = (char *)6;
            break;
          case 0xC:
            *(v4 - 197) = (char *)7;
            break;
          case 0xE:
            *(v4 - 197) = (char *)8;
            break;
          default:
            break;
        }
        v22 = (int)(*(v4 - 194) + 19);
        v4 = &name;
        v41 = (int)*(&name - 199);
        v40 = 0;
        *(__int64 *)((char *)&errnum + 4) = 0LL;
        errnum = (unsigned int)*(&name - 197);
        LODWORD(v20) = sub_804EFC2(v22, errnum, HIDWORD(errnum), 0, v41);
        *((_QWORD *)&name - 96) += v20;
        if ( dword_8072898 == 1 )
        {
          v36 = dword_80728A0;
          v35 = a1;
          v23 = &loc_804E6E3;
          v4 = (char **)&v35;
          if ( dword_80728A0 != -1 )
            v23 = &loc_804E710;
          dword_8072260 = (int)v23;
          a1 = v35;
          sub_8065AB5(
            name,
            errnum,
            HIDWORD(errnum),
            v39,
            v40,
            v41,
            v42,
            HIDWORD(v42),
            v43,
            *(_DWORD *)&v44,
            v45,
            v46,
            v47,
            v48,
            v49,
            v50,
            v51,
            v52,
            v53,
            v54,
            v55,
            v56,
            v57);
          if ( byte_80728A7 != 1 && byte_80728D4 != 1 )
          {
            sub_80517B8();
            sub_805192C();
            sub_804EB79(v25, v24);
          }
        }
      }
      sub_804B961(v21, SHIDWORD(v20));
    }
    if ( *__errno_location() )
    {
      v26 = gettext("reading directory %s");
      v27 = *((unsigned __int8 *)v4 - 804);
      HIDWORD(errnum) = *(v4 - 199);
      sub_804E0D2(v27, v26);
      v28 = *__errno_location();
      v29 = v28 == 75;
      v36 = v28;
      v35 = a1;
      v30 = &loc_804E76B;
      if ( v29 )
        v30 = &loc_804E76F;
      dword_80721F0 = (int)v30;
      sub_8065D53(name, errnum, HIDWORD(errnum), v39, v40, v41, v42, HIDWORD(v42), v43, *(_DWORD *)&v44, v45);
    }
    name = *(v4 - 196);
    if ( closedir((DIR *)name) )
    {
      v31 = gettext("closing directory %s");
      v32 = *((unsigned __int8 *)v4 - 804);
      HIDWORD(errnum) = *(v4 - 199);
      sub_804E0D2(v32, v31);
    }
    sub_80517B8();
    if ( byte_80728D4 )
    {
      LODWORD(errnum) = 0;
      sub_8050116(*(v4 - 199), 0);
    }
    if ( !dword_8072898 || byte_80728A7 )
    {
      if ( byte_80728B8 )
      {
        fwrite_unlocked("  ", 1u, 2u, stdout);
        dword_80729B0 += 2;
      }
      *(v4 - 193) = gettext("total");
      LODWORD(errnum) = stdout;
      fputs_unlocked(*(v4 - 193), stdout);
      dword_80729B0 += strlen(*(v4 - 193));
      putchar_unlocked(32);
      ++dword_80729B0;
      v42 = *(_QWORD *)&qword_80728AC;
      v40 = 512;
      v41 = 0;
      v39 = dword_80728A8;
      v4 = &name;
      HIDWORD(errnum) = &name - 166;
      v33 = (int)*(&name - 191);
      name = *(&name - 192);
      *(&name - 193) = (char *)sub_80596F1(
                                 (int)name,
                                 v33,
                                 (char *)&name - 664,
                                 dword_80728A8,
                                 512,
                                 0,
                                 qword_80728AC,
                                 *(&qword_80728AC + 1));
      LODWORD(errnum) = stdout;
      fputs_unlocked(*(&name - 193), stdout);
      dword_80729B0 += strlen(*(&name - 193));
      putchar_unlocked(10);
      ++dword_80729B0;
    }
    if ( dword_8072848 )
      sub_805192C();
  }
  else
  {
    v7 = gettext("cannot open directory %s");
    v8 = *((unsigned __int8 *)&name - 804);
    HIDWORD(errnum) = *(&name - 199);
    sub_804E0D2(v8, v7);
  }
  return __readgsdword(0x14u) ^ (unsigned int)*(v4 - 3);
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8049A80: using guessed type int readdir64(void);
// 804EFC2: using guessed type _DWORD __cdecl sub_804EFC2(_DWORD, _DWORD, __int64, _DWORD, _DWORD);
// 80534ED: using guessed type _DWORD __cdecl sub_80534ED(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8065AB5: using guessed type int __stdcall sub_8065AB5(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8065D53: using guessed type int __stdcall sub_8065D53(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80721F0: using guessed type int dword_80721F0;
// 8072260: using guessed type int dword_8072260;
// 80723A4: using guessed type char byte_80723A4;
// 8072848: using guessed type int dword_8072848;
// 8072898: using guessed type int dword_8072898;
// 80728A0: using guessed type int dword_80728A0;
// 80728A7: using guessed type char byte_80728A7;
// 80728B8: using guessed type char byte_80728B8;
// 80728C1: using guessed type char byte_80728C1;
// 80728D4: using guessed type char byte_80728D4;
// 80728EC: using guessed type int dword_80728EC;
// 80728F4: using guessed type char byte_80728F4;
// 80729B0: using guessed type int dword_80729B0;

//----- (0804E974) --------------------------------------------------------
_DWORD *__cdecl sub_804E974(int a1)
{
  _DWORD *result; // eax

  result = sub_8061F5F(8u);
  *result = a1;
  result[1] = dword_80728DC;
  dword_80728DC = (int)result;
  return result;
}

//----- (0804E9B7) --------------------------------------------------------
int __cdecl sub_804E9B7(int a1)
{
  void *v1; // eax

  v1 = &loc_804EA14;
  if ( a1 )
    v1 = &loc_804E9C5;
  dword_807224C = (int)v1;
  sub_8065B27();
  return 0;
}
// 807224C: using guessed type int dword_807224C;

//----- (0804EA1B) --------------------------------------------------------
_BOOL4 __cdecl sub_804EA1B(char *name)
{
  signed int v1; // eax
  bool v2; // al

  v2 = dword_80728D8 != 2 && *name == 46 && (!dword_80728D8 || (name[1] != 46 ? (v1 = 1) : (v1 = 2), !name[v1]))
    || !dword_80728D8 && (unsigned __int8)sub_804E9B7(dword_80728E0)
    || (unsigned __int8)sub_804E9B7(dword_80728DC);
  return v2;
}
// 80728D8: using guessed type int dword_80728D8;

//----- (0804EAAD) --------------------------------------------------------
#error "804EAF1: call analysis failed (funcsize=22)"

//----- (0804EAF6) --------------------------------------------------------
#error "804EAFB: positive sp value has been found (funcsize=0)"

//----- (0804EAFC) --------------------------------------------------------
int sub_804EAFC()
{
  *__errno_location() = 95;
  return 0;
}

//----- (0804EB14) --------------------------------------------------------
void __cdecl sub_804EB14(void **a1)
{
  void *v1; // ST00_4

  free(*a1);
  free(a1[1]);
  free(a1[2]);
  if ( a1[29] != &unk_80722BC )
  {
    if ( (unsigned __int8)sub_804AD22() )
    {
      free(a1[29]);
    }
    else
    {
      v1 = a1[29];
      sub_8061103();
    }
  }
}

//----- (0804EB79) --------------------------------------------------------
int __fastcall sub_804EB79(int a1, int a2)
{
  dword_8072288 = (int (__fastcall *)(_DWORD, _DWORD))&loc_804EBBA;
  return ((int (__fastcall *)(int, int))loc_804EBBA)(a1, a2);
}
// 8072288: using guessed type int (__fastcall *dword_8072288)(_DWORD, _DWORD);

//----- (0804EB99) --------------------------------------------------------
#error "804EBB1: call analysis failed (funcsize=47)"

//----- (0804EC89) --------------------------------------------------------
#error "804EC98: positive sp value has been found (funcsize=0)"

//----- (0804EC99) --------------------------------------------------------
int __cdecl sub_804EC99(int a1)
{
  return a1 == 22 || a1 == 38 || sub_804AD16(a1);
}

//----- (0804ECCB) --------------------------------------------------------
signed int __cdecl sub_804ECCB(int a1, int a2, char a3)
{
  signed int result; // eax
  signed int v4; // eax
  int *v5; // eax
  int v6; // edx
  signed int v7; // [esp+1Ch] [ebp-Ch]

  if ( *(_QWORD *)(a2 + 12) == qword_807383C )
  {
    *__errno_location() = 95;
    result = -1;
  }
  else
  {
    if ( a3 )
      v4 = sub_8061150();
    else
      v4 = sub_8061168();
    v7 = v4;
    if ( v4 < 0 )
    {
      v5 = __errno_location();
      if ( (unsigned __int8)sub_804EC99(*v5) )
      {
        v6 = *(_DWORD *)(a2 + 16);
        LODWORD(qword_807383C) = *(_DWORD *)(a2 + 12);
        HIDWORD(qword_807383C) = v6;
      }
    }
    result = v7;
  }
  return result;
}
// 807383C: using guessed type __int64 qword_807383C;

//----- (0804EDB8) --------------------------------------------------------
int __cdecl sub_804EDB8(int a1, int a2)
{
  int result; // eax
  int *v3; // eax
  int v4; // edx
  int v5; // [esp+1Ch] [ebp-Ch]

  if ( *(_QWORD *)(a2 + 12) == qword_8073844 )
  {
    *__errno_location() = 95;
    result = 0;
  }
  else
  {
    *__errno_location() = 0;
    v5 = sub_8056C78();
    if ( v5 <= 0 )
    {
      v3 = __errno_location();
      if ( (unsigned __int8)sub_804EC99(*v3) )
      {
        v4 = *(_DWORD *)(a2 + 16);
        LODWORD(qword_8073844) = *(_DWORD *)(a2 + 12);
        HIDWORD(qword_8073844) = v4;
      }
    }
    result = v5;
  }
  return result;
}
// 807383C: using guessed type __int64 qword_807383C;
// 8073844: using guessed type __int64 qword_8073844;

//----- (0804EE5C) --------------------------------------------------------
int __cdecl sub_804EE5C(int a1, int a2)
{
  int result; // eax
  int *v3; // eax
  bool v4; // zf
  void *v5; // eax
  int v6; // edx
  int v7; // [esp+0h] [ebp-28h]
  int v8; // [esp+4h] [ebp-24h]
  int v9; // [esp+8h] [ebp-20h]
  int v10; // [esp+Ch] [ebp-1Ch]
  int v11; // [esp+10h] [ebp-18h]
  int v12; // [esp+14h] [ebp-14h]
  int v13; // [esp+18h] [ebp-10h]
  int v14; // [esp+1Ch] [ebp-Ch]
  int v15; // [esp+20h] [ebp-8h]
  int v16; // [esp+24h] [ebp-4h]
  int savedregs; // [esp+28h] [ebp+0h]

  if ( *(_QWORD *)(a2 + 12) == qword_807384C )
  {
    *__errno_location() = 95;
    result = 0;
  }
  else
  {
    HIBYTE(v14) = sub_804EAFC();
    if ( HIBYTE(v14) ^ 1 )
    {
      v3 = __errno_location();
      v4 = (unsigned __int8)sub_804EC99(*v3) == 0;
      v5 = &loc_804EEFB;
      if ( v4 )
        v5 = &loc_804EF0F;
      dword_80721F0 = (int)v5;
      sub_8065D53(v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, savedregs);
      v6 = *(_DWORD *)(a2 + 16);
      LODWORD(qword_807384C) = *(_DWORD *)(a2 + 12);
      HIDWORD(qword_807384C) = v6;
    }
    result = HIBYTE(v14);
  }
  return result;
}
// 8065D53: using guessed type int __stdcall sub_8065D53(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80721F0: using guessed type int dword_80721F0;
// 8073844: using guessed type __int64 qword_8073844;
// 807384C: using guessed type __int64 qword_807384C;

//----- (0804EF1A) --------------------------------------------------------
#error "804EF65: call analysis failed (funcsize=21)"

//----- (0804EF6A) --------------------------------------------------------
#error "804EFC1: positive sp value has been found (funcsize=0)"

//----- (0804EFC2) --------------------------------------------------------
#error "804F3CD: call analysis failed (funcsize=893)"

//----- (0804FF8B) --------------------------------------------------------
int __cdecl sub_804FF8B(int a1)
{
  return *(_DWORD *)(a1 + 108) == 3 || *(_DWORD *)(a1 + 108) == 9;
}

//----- (0804FFB5) --------------------------------------------------------
#error "804FFF0: call analysis failed (funcsize=19)"

//----- (0804FFF5) --------------------------------------------------------
#error "8050042: positive sp value has been found (funcsize=0)"

//----- (08050043) --------------------------------------------------------
void *__cdecl sub_8050043(int a1, char *s)
{
  size_t v3; // eax
  char *v4; // eax
  unsigned int v5; // [esp+18h] [ebp-10h]
  void *v6; // [esp+1Ch] [ebp-Ch]

  if ( !s )
    return 0;
  if ( *s == 47 )
    return sub_806208A(s);
  v5 = sub_8056AA1((_BYTE *)a1);
  if ( !v5 )
    return sub_806208A(s);
  v3 = strlen(s);
  v6 = sub_8061F5F(v5 + v3 + 2);
  if ( *(_BYTE *)(v5 - 1 + a1) != 47 )
    ++v5;
  v4 = (char *)stpncpy(v6, a1, v5);
  strcpy(v4, s);
  return v6;
}
// 8049980: using guessed type int __cdecl stpncpy(_DWORD, _DWORD, _DWORD);

//----- (080500F5) --------------------------------------------------------
int __cdecl sub_80500F5(int a1)
{
  int v1; // ST1C_4

  v1 = sub_8056BAD(a1);
  return sub_804AA72(v1);
}
// 804AA72: using guessed type _DWORD __cdecl sub_804AA72(_DWORD);
// 8056BAD: using guessed type _DWORD __cdecl sub_8056BAD(_DWORD);

//----- (08050116) --------------------------------------------------------
#error "80502A3: call analysis failed (funcsize=108)"

//----- (08050336) --------------------------------------------------------
int __cdecl sub_8050336(char *s1, char *s2)
{
  int v2; // edi
  int v3; // esi
  char *v4; // ebx
  int *v5; // eax
  int v7; // [esp+2Ch] [ebp-1Ch]

  *__errno_location() = 0;
  v7 = strcoll(s1, s2);
  if ( *__errno_location() )
  {
    v2 = sub_8060EC6(1);
    v3 = sub_8060EC6(0);
    v4 = gettext("cannot compare file names %s and %s");
    v5 = __errno_location();
    error(0, *v5, v4, v3, v2);
    sub_804E09F(0);
    longjmp(env, 1);
  }
  return v7;
}

//----- (080503F0) --------------------------------------------------------
int __cdecl sub_80503F0(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD))
{
  int result; // eax
  int v4; // [esp+1Ch] [ebp-1Ch]
  int v5; // [esp+20h] [ebp-18h]
  int v6; // [esp+24h] [ebp-14h]
  int v7; // [esp+28h] [ebp-10h]
  int v8; // [esp+2Ch] [ebp-Ch]

  sub_80612E2(&v5, (int)(a1 + 3));
  sub_80612E2(&v7, (int)(a2 + 3));
  v4 = sub_80613ED(v7, v8, v5, v6);
  if ( v4 )
    result = v4;
  else
    result = a3(*a1, *a2);
  return result;
}

//----- (0805046C) --------------------------------------------------------
int __cdecl sub_805046C(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD))
{
  int result; // eax
  int v4; // [esp+1Ch] [ebp-1Ch]
  int v5; // [esp+20h] [ebp-18h]
  int v6; // [esp+24h] [ebp-14h]
  int v7; // [esp+28h] [ebp-10h]
  int v8; // [esp+2Ch] [ebp-Ch]

  sub_806130D(&v5, a1 + 3);
  sub_806130D(&v7, a2 + 3);
  v4 = sub_80613ED(v7, v8, v5, v6);
  if ( v4 )
    result = v4;
  else
    result = a3(*a1, *a2);
  return result;
}
// 806130D: using guessed type int __cdecl sub_806130D(_DWORD, _DWORD);

//----- (080504E8) --------------------------------------------------------
int __cdecl sub_80504E8(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD))
{
  int result; // eax
  int v4; // [esp+1Ch] [ebp-1Ch]
  int v5; // [esp+20h] [ebp-18h]
  int v6; // [esp+24h] [ebp-14h]
  int v7; // [esp+28h] [ebp-10h]
  int v8; // [esp+2Ch] [ebp-Ch]

  sub_80612A2(&v5, a1 + 3);
  sub_80612A2(&v7, a2 + 3);
  v4 = sub_80613ED(v7, v8, v5, v6);
  if ( v4 )
    result = v4;
  else
    result = a3(*a1, *a2);
  return result;
}
// 80612A2: using guessed type _DWORD __cdecl sub_80612A2(_DWORD, _DWORD);

//----- (08050564) --------------------------------------------------------
#error "8050593: call analysis failed (funcsize=21)"

//----- (080505A6) --------------------------------------------------------
#error "805061A: positive sp value has been found (funcsize=0)"

//----- (0805061E) --------------------------------------------------------
int __cdecl sub_805061E(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD))
{
  return a3(*a1, *a2);
}

//----- (0805064C) --------------------------------------------------------
int __cdecl sub_805064C(const char **a1, const char **a2, int (__cdecl *a3)(char *, char *))
{
  char *v3; // edx
  char *v4; // eax
  int result; // eax
  char *v6; // [esp+14h] [ebp-14h]
  char *v7; // [esp+18h] [ebp-10h]
  int v8; // [esp+1Ch] [ebp-Ch]

  v6 = strrchr(*a1, 46);
  v7 = strrchr(*a2, 46);
  if ( v7 )
    v3 = v7;
  else
    v3 = &locale;
  if ( v6 )
    v4 = v6;
  else
    v4 = &locale;
  v8 = a3(v4, v3);
  if ( v8 )
    result = v8;
  else
    result = a3((char *)*a1, (char *)*a2);
  return result;
}

//----- (08050E71) --------------------------------------------------------
int __cdecl sub_8050E71(int a1, int a2)
{
  return sub_8050564(a1, a2, sub_8050336);
}
// 8050564: using guessed type int __cdecl sub_8050564(_DWORD, _DWORD, _DWORD);

//----- (08050E93) --------------------------------------------------------
int __cdecl sub_8050E93(int a1, int a2)
{
  return sub_8050564(a1, a2, strcmp);
}
// 8050564: using guessed type int __cdecl sub_8050564(_DWORD, _DWORD, _DWORD);

//----- (08050EB5) --------------------------------------------------------
int __cdecl sub_8050EB5(int a1, int a2)
{
  return sub_8050564(a2, a1, sub_8050336);
}
// 8050564: using guessed type int __cdecl sub_8050564(_DWORD, _DWORD, _DWORD);

//----- (08050ED7) --------------------------------------------------------
int __cdecl sub_8050ED7(int a1, int a2)
{
  return sub_8050564(a2, a1, strcmp);
}
// 8050564: using guessed type int __cdecl sub_8050564(_DWORD, _DWORD, _DWORD);

//----- (08050EF9) --------------------------------------------------------
int __cdecl sub_8050EF9(int a1, int a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_804FF8B(a1);
  v4 = sub_804FF8B(a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_8050564(a1, a2, sub_8050336);
}
// 8050564: using guessed type int __cdecl sub_8050564(_DWORD, _DWORD, _DWORD);

//----- (08050F67) --------------------------------------------------------
#error "8050FDA: call analysis failed (funcsize=45)"

//----- (08050FFF) --------------------------------------------------------
int __cdecl sub_8050FFF(int a1, int a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_804FF8B(a1);
  v4 = sub_804FF8B(a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_8050564(a2, a1, sub_8050336);
}
// 8050564: using guessed type int __cdecl sub_8050564(_DWORD, _DWORD, _DWORD);

//----- (0805106D) --------------------------------------------------------
int __cdecl sub_805106D(int a1, int a2)
{
  int v2; // edx
  int v3; // ecx
  void *v5; // eax
  int v6; // [esp+0h] [ebp-28h]
  char v7; // [esp+1Eh] [ebp-Ah]
  char v8; // [esp+1Fh] [ebp-9h]

  v7 = sub_804FF8B(a1);
  v8 = sub_804FF8B(a2);
  if ( v7 && v8 != 1 )
    return -1;
  if ( v7 == 1 )
    return sub_8050564(a2, a1, strcmp);
  v5 = &loc_80510D1;
  if ( !v8 )
    v5 = &loc_80510D8;
  dword_8072224 = (int)v5;
  sub_8065C0F(v3, v2, v6);
  return 1;
}
// 8050564: using guessed type int __cdecl sub_8050564(_DWORD, _DWORD, _DWORD);
// 8072224: using guessed type int dword_8072224;

//----- (080510F4) --------------------------------------------------------
int __cdecl sub_80510F4(_DWORD *a1, _DWORD *a2)
{
  return sub_805061E(a1, a2, (int (__cdecl *)(_DWORD, _DWORD))sub_8050336);
}

//----- (08051116) --------------------------------------------------------
int __cdecl sub_8051116(_DWORD *a1, _DWORD *a2)
{
  return sub_805061E(a1, a2, (int (__cdecl *)(_DWORD, _DWORD))strcmp);
}

//----- (08051138) --------------------------------------------------------
int __cdecl sub_8051138(_DWORD *a1, _DWORD *a2)
{
  return sub_805061E(a2, a1, (int (__cdecl *)(_DWORD, _DWORD))sub_8050336);
}

//----- (0805115A) --------------------------------------------------------
int __cdecl sub_805115A(_DWORD *a1, _DWORD *a2)
{
  return sub_805061E(a2, a1, (int (__cdecl *)(_DWORD, _DWORD))strcmp);
}

//----- (0805117C) --------------------------------------------------------
#error "80511DB: call analysis failed (funcsize=43)"

//----- (08051203) --------------------------------------------------------
int __cdecl sub_8051203(_DWORD *a1, _DWORD *a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_804FF8B((int)a1);
  v4 = sub_804FF8B((int)a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_805061E(a1, a2, (int (__cdecl *)(_DWORD, _DWORD))strcmp);
}

//----- (08051271) --------------------------------------------------------
int __cdecl sub_8051271(_DWORD *a1, _DWORD *a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_804FF8B((int)a1);
  v4 = sub_804FF8B((int)a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_805061E(a2, a1, (int (__cdecl *)(_DWORD, _DWORD))sub_8050336);
}

//----- (080512DF) --------------------------------------------------------
int __cdecl sub_80512DF(_DWORD *a1, _DWORD *a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_804FF8B((int)a1);
  v4 = sub_804FF8B((int)a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_805061E(a2, a1, (int (__cdecl *)(_DWORD, _DWORD))strcmp);
}

//----- (0805134D) --------------------------------------------------------
int __cdecl sub_805134D(const char **a1, const char **a2)
{
  return sub_805064C(a1, a2, sub_8050336);
}

//----- (0805136F) --------------------------------------------------------
int __cdecl sub_805136F(const char **a1, const char **a2)
{
  return sub_805064C(a1, a2, (int (__cdecl *)(char *, char *))strcmp);
}

//----- (08051391) --------------------------------------------------------
int __cdecl sub_8051391(const char **a1, const char **a2)
{
  return sub_805064C(a2, a1, sub_8050336);
}

//----- (080513B3) --------------------------------------------------------
int __cdecl sub_80513B3(const char **a1, const char **a2)
{
  return sub_805064C(a2, a1, (int (__cdecl *)(char *, char *))strcmp);
}

//----- (080513D5) --------------------------------------------------------
int __cdecl sub_80513D5(const char **a1, const char **a2)
{
  char v2; // ST26_1
  void *v3; // eax
  int result; // eax
  char v5; // [esp+1Fh] [ebp-9h]

  v2 = sub_804FF8B((int)a1);
  v5 = sub_804FF8B((int)a2);
  if ( v2 )
  {
    v3 = &loc_8051431;
    if ( v5 == 1 )
      v3 = &loc_8051438;
    dword_807224C = (int)v3;
    sub_8065B27();
    result = -1;
  }
  else if ( v5 )
  {
    result = 1;
  }
  else
  {
    result = sub_805064C(a1, a2, sub_8050336);
  }
  return result;
}
// 807224C: using guessed type int dword_807224C;

//----- (0805146C) --------------------------------------------------------
int __cdecl sub_805146C(const char **a1, const char **a2)
{
  void *v2; // eax
  char v4; // [esp+1Eh] [ebp-Ah]
  char v5; // [esp+1Fh] [ebp-9h]

  v4 = sub_804FF8B((int)a1);
  v5 = sub_804FF8B((int)a2);
  v2 = &loc_80514BD;
  if ( !v4 )
    v2 = &loc_80514CF;
  dword_807224C = (int)v2;
  sub_8065B27();
  if ( v5 != 1 )
    return -1;
  if ( v4 == 1 )
    return sub_805064C(a1, a2, (int (__cdecl *)(char *, char *))strcmp);
  return 1;
}
// 807224C: using guessed type int dword_807224C;

//----- (08051503) --------------------------------------------------------
#error "8051561: call analysis failed (funcsize=40)"

//----- (08051586) --------------------------------------------------------
int __cdecl sub_8051586(const char **a1, const char **a2)
{
  int v3; // [esp+0h] [ebp-28h]
  int v4; // [esp+4h] [ebp-24h]
  int v5; // [esp+8h] [ebp-20h]
  int v6; // [esp+Ch] [ebp-1Ch]
  int v7; // [esp+10h] [ebp-18h]
  int v8; // [esp+14h] [ebp-14h]
  int v9; // [esp+18h] [ebp-10h]
  int v10; // [esp+1Ch] [ebp-Ch]
  int v11; // [esp+20h] [ebp-8h]
  int v12; // [esp+24h] [ebp-4h]
  int savedregs; // [esp+28h] [ebp+0h]

  BYTE2(v10) = sub_804FF8B((int)a1);
  HIBYTE(v10) = sub_804FF8B((int)a2);
  if ( BYTE2(v10) && HIBYTE(v10) != 1 )
    return -1;
  if ( BYTE2(v10) != 1 )
  {
    if ( HIBYTE(v10) )
    {
      dword_80721F0 = (int)&locret_8051607;
      sub_8065D53(v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, savedregs);
    }
  }
  return sub_805064C(a2, a1, (int (__cdecl *)(char *, char *))strcmp);
}
// 8065D53: using guessed type int __stdcall sub_8065D53(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80721F0: using guessed type int dword_80721F0;

//----- (08051609) --------------------------------------------------------
int __cdecl sub_8051609(char **a1, char **a2)
{
  return sub_8057590(*a1, *a2);
}

//----- (08051627) --------------------------------------------------------
int __cdecl sub_8051627(char **a1, char **a2)
{
  return sub_8051609(a1, a2);
}

//----- (08051641) --------------------------------------------------------
int __cdecl sub_8051641(char **a1, char **a2)
{
  return sub_8051609(a2, a1);
}

//----- (0805165B) --------------------------------------------------------
int __cdecl sub_805165B(char **a1, char **a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_804FF8B((int)a1);
  v4 = sub_804FF8B((int)a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_8051609(a1, a2);
}

//----- (080516C1) --------------------------------------------------------
#error "8051718: call analysis failed (funcsize=45)"

//----- (08051750) --------------------------------------------------------
int sub_8051750()
{
  int result; // eax
  unsigned int i; // [esp+Ch] [ebp-8h]

  for ( i = 0; ; ++i )
  {
    result = dword_8072848;
    if ( i >= dword_8072848 )
      break;
    *((_DWORD *)dword_8072850 + i) = (char *)dword_8072840 + 136 * i;
  }
  return result;
}
// 8072848: using guessed type int dword_8072848;

//----- (080517B8) --------------------------------------------------------
int sub_80517B8()
{
  int result; // eax
  int v1; // eax
  unsigned __int8 v2; // [esp+1h] [ebp-9h]

  if ( dword_8072848 + ((unsigned int)dword_8072848 >> 1) > dword_8072854 )
  {
    free(dword_8072850);
    dword_8072850 = sub_8061E52(dword_8072848, 0xCu);
    dword_8072854 = 3 * dword_8072848;
  }
  sub_8051750();
  result = dword_80728A0;
  if ( dword_80728A0 != -1 )
  {
    if ( _setjmp(env) )
    {
      v2 = 1;
      if ( dword_80728A0 == 3 )
        __assert_fail("sort_type != sort_version", "src/ls.c", 0xEE5u, "sort_files");
      sub_8051750();
    }
    else
    {
      v2 = 0;
    }
    if ( dword_80728A0 == 4 )
      v1 = dword_807289C;
    else
      v1 = 0;
    result = sub_805BD1D(
               (int)dword_8072850,
               dword_8072848,
               (int)off_8068678[2 * (2 * (2 * (v1 + dword_80728A0) + v2) + (unsigned __int8)byte_80728A4)
                              + (unsigned __int8)byte_80728D6]);
  }
  return result;
}
// 8068678: using guessed type int (__cdecl *off_8068678[28])(int, int);
// 8072848: using guessed type int dword_8072848;
// 8072854: using guessed type int dword_8072854;
// 807289C: using guessed type int dword_807289C;
// 80728A0: using guessed type int dword_80728A0;
// 80728A4: using guessed type char byte_80728A4;
// 80728D6: using guessed type char byte_80728D6;

//----- (0805192C) --------------------------------------------------------
int sub_805192C()
{
  int result; // eax
  void *v1; // eax
  int v2; // [esp+0h] [ebp-28h]
  int v3; // [esp+4h] [ebp-24h]
  int v4; // [esp+8h] [ebp-20h]
  int v5; // [esp+Ch] [ebp-1Ch]
  int v6; // [esp+10h] [ebp-18h]
  int v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+18h] [ebp-10h]
  int v9; // [esp+1Ch] [ebp-Ch]
  unsigned int j; // [esp+1Ch] [ebp-Ch]
  unsigned int i; // [esp+1Ch] [ebp-Ch]
  int v12; // [esp+20h] [ebp-8h]
  int v13; // [esp+24h] [ebp-4h]
  int savedregs; // [esp+28h] [ebp+0h]

  result = dword_8072898;
  switch ( dword_8072898 )
  {
    case 0:
      for ( i = 0; ; ++i )
      {
        result = dword_8072848;
        if ( i >= dword_8072848 )
          break;
        sub_804B8E9();
        sub_8051FA2(*((_DWORD *)dword_8072850 + i));
        putchar_unlocked(10);
        ++dword_80729B0;
      }
      break;
    case 1:
      for ( j = 0; ; ++j )
      {
        result = dword_8072848;
        if ( j >= dword_8072848 )
          break;
        sub_8053C9A(*((_DWORD *)dword_8072850 + j), 0);
        putchar_unlocked(10);
      }
      break;
    case 2:
      v1 = &loc_80519B2;
      if ( dword_80728F8 )
        v1 = &loc_80519C0;
      dword_80721F0 = (int)v1;
      sub_8065D53(v2, v3, v4, v5, v6, v7, v8, v9, v12, v13, savedregs);
      result = sub_8054C58(32);
      break;
    case 3:
      if ( dword_80728F8 )
        result = sub_8054ACB();
      else
        result = sub_8054C58(32);
      break;
    case 4:
      result = sub_8054C58(44);
      break;
    default:
      return result;
  }
  return result;
}
// 8051FA2: using guessed type _DWORD __cdecl sub_8051FA2(_DWORD);
// 8054ACB: using guessed type int sub_8054ACB(void);
// 8065D53: using guessed type int __stdcall sub_8065D53(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80721F0: using guessed type int dword_80721F0;
// 8072848: using guessed type int dword_8072848;
// 8072898: using guessed type int dword_8072898;
// 80728F8: using guessed type int dword_80728F8;
// 80729B0: using guessed type int dword_80729B0;

//----- (08051A41) --------------------------------------------------------
int __usercall sub_8051A41@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, unsigned __int8 a5, int a6, int a7, int a8)
{
  char *v8; // eax
  unsigned __int8 v10; // [esp+1Ch] [ebp-1Ch]

  v10 = a5;
  if ( byte_807377C )
  {
    a1 = v10;
    a2 = *(_DWORD *)(a6 + 16);
    v8 = (char *)(((a2 + 12 * v10) << 7) + 134687612);
  }
  else
  {
    v8 = (&off_807239C)[v10];
  }
  return sub_805BE83(a2, a1, a3, a4, v8, a6, a7, a8);
}
// 805BE83: using guessed type int __fastcall sub_805BE83(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 807377C: using guessed type char byte_807377C;

//----- (08051AD5) --------------------------------------------------------
int __usercall sub_8051AD5@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>)
{
  struct tm *v4; // eax
  time_t timer; // [esp+2Ch] [ebp-42Ch]
  int v6; // [esp+30h] [ebp-428h]
  struct tm tp; // [esp+34h] [ebp-424h]
  char v8; // [esp+63h] [ebp-3F5h]
  unsigned int v9; // [esp+44Ch] [ebp-Ch]

  v9 = __readgsdword(0x14u);
  dword_8072288 = (int (__fastcall *)(_DWORD, _DWORD))&loc_8051BF9;
  if ( dword_80723A8 < 0 )
  {
    timer = 0;
    v4 = sub_8063EBC(dword_80728FC, &timer, &tp);
    dword_8072288 = (int (__fastcall *)(_DWORD, _DWORD))&loc_8051BD4;
    if ( v4 )
    {
      v6 = sub_8051A41(a1, a2, (int)&v8, 1001, 0, (int)&tp, dword_80728FC, 0);
      dword_8072288 = (int (__fastcall *)(_DWORD, _DWORD))&loc_8051BD4;
      if ( v6 )
      {
        dword_80723A8 = sub_805B518(a3, &v8);
        dword_8072288 = (int (__fastcall *)(_DWORD, _DWORD))&loc_8051BF9;
        if ( dword_80723A8 < 0 )
        {
          dword_80723A8 = 0;
          a2 = __readgsdword(0x14u) ^ v9;
          dword_8072288 = (int (__fastcall *)(_DWORD, _DWORD))sub_8051C21;
        }
      }
    }
  }
  return dword_8072288(a2, a1);
}
// 8051C21: using guessed type int sub_8051C21();
// 8072288: using guessed type int (__fastcall *dword_8072288)(_DWORD, _DWORD);
// 80723A8: using guessed type int dword_80723A8;

//----- (08051C21) --------------------------------------------------------
#error "8051C22: positive sp value has been found (funcsize=0)"

//----- (08051C23) --------------------------------------------------------
int __usercall sub_8051C23@<eax>(int a1@<ebx>, char *s, int a3, int a4)
{
  int v4; // eax
  int v5; // eax
  int result; // eax
  int v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+18h] [ebp-10h]
  int v9; // [esp+1Ch] [ebp-Ch]

  if ( s )
  {
    v9 = a4 - sub_805B4EF(a1, s);
    v4 = 0;
    if ( v9 >= 0 )
      v4 = v9;
    v8 = v4;
    fputs_unlocked(s, stdout);
    v7 = v8 + strlen(s);
    do
    {
      putchar_unlocked(32);
      v5 = v8--;
    }
    while ( v5 );
  }
  else
  {
    printf("%*lu ", a4, a3);
    v7 = a4;
  }
  result = dword_80729B0 + v7 + 1;
  dword_80729B0 += v7 + 1;
  return result;
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 80729B0: using guessed type int dword_80729B0;

//----- (08051CE3) --------------------------------------------------------
int __usercall sub_8051CE3@<eax>(int a1@<ebx>, __uid_t uid, int a3, int a4)
{
  char *v4; // eax
  void *v5; // eax

  if ( (_BYTE)a4 == 1 )
  {
    v5 = &loc_8051D35;
    if ( !byte_80728A6 )
      v5 = &loc_8051D3C;
    dword_807224C = (int)v5;
    sub_8065B27();
    v4 = 0;
  }
  else
  {
    v4 = "?";
  }
  return sub_8051C23(a1, v4, uid, a3);
}
// 807224C: using guessed type int dword_807224C;
// 80728A6: using guessed type char byte_80728A6;

//----- (08051D5F) --------------------------------------------------------
int __usercall sub_8051D5F@<eax>(int a1@<ebx>, __gid_t gid, int a3, int a4)
{
  char *v4; // eax

  if ( (_BYTE)a4 == 1 )
  {
    if ( byte_80728A6 )
      v4 = 0;
    else
      v4 = sub_805AA7C(gid);
  }
  else
  {
    v4 = "?";
  }
  return sub_8051C23(a1, v4, gid, a3);
}
// 80728A6: using guessed type char byte_80728A6;

//----- (08051DB2) --------------------------------------------------------
size_t __usercall sub_8051DB2@<eax>(int a1@<ebx>, char *a2, int a3)
{
  size_t result; // eax
  int v4; // [esp+1Ch] [ebp-1Ch]
  char s; // [esp+21h] [ebp-17h]
  unsigned int v6; // [esp+2Ch] [ebp-Ch]

  v6 = __readgsdword(0x14u);
  if ( a2 )
  {
    v4 = sub_805B4EF(a1, a2);
    result = 0;
    if ( v4 >= 0 )
      result = v4;
  }
  else
  {
    sprintf(&s, "%lu", a3);
    result = strlen(&s);
  }
  return result;
}

//----- (08051E2C) --------------------------------------------------------
size_t __usercall sub_8051E2C@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, __uid_t uid)
{
  char *v4; // eax
  int v6; // [esp+0h] [ebp-18h]
  int v7; // [esp+4h] [ebp-14h]
  int v8; // [esp+8h] [ebp-10h]

  dword_8072288 = (int (__fastcall *)(_DWORD, _DWORD))&loc_8051E79;
  if ( !byte_80728A6 )
    return dword_8072288(a2, a1);
  dword_8072288 = (int (__fastcall *)(_DWORD, _DWORD))&loc_8051E84;
  dword_8072204 = (int)&loc_804EDAE;
  sub_8065CE1(a2, a1, v6, v7, v8);
  v4 = sub_805A870(uid);
  return sub_8051DB2(a3, v4, uid);
}
// 8072204: using guessed type int dword_8072204;
// 8072288: using guessed type int (__fastcall *dword_8072288)(_DWORD, _DWORD);
// 80728A6: using guessed type char byte_80728A6;

//----- (08051E95) --------------------------------------------------------
int __fastcall sub_8051E95(int a1, int a2)
{
  dword_8072288 = (int (__fastcall *)(_DWORD, _DWORD))sub_8051ED0;
  if ( byte_80728A6 )
    dword_8072288 = (int (__fastcall *)(_DWORD, _DWORD))&loc_8051EDB;
  return dword_8072288(a1, a2);
}
// 8051ED0: using guessed type int __cdecl sub_8051ED0(int);
// 8072288: using guessed type int (__fastcall *dword_8072288)(_DWORD, _DWORD);
// 80728A6: using guessed type char byte_80728A6;

//----- (08051ED0) --------------------------------------------------------
#error "8051EEB: positive sp value has been found (funcsize=0)"

//----- (08051EEC) --------------------------------------------------------
int __fastcall sub_8051EEC(int a1, int a2, int a3, unsigned int a4)
{
  dword_8072288 = (int (__fastcall *)(_DWORD, _DWORD))sub_8051F2E;
  if ( a4 <= 0x14 )
    __assert_fail("INT_BUFSIZE_BOUND (uintmax_t) <= buflen", "src/ls.c", 0xFA7u, "format_inode");
  return dword_8072288(a1, a2);
}
// 8051F2E: using guessed type int __cdecl sub_8051F2E(int, int);
// 8072288: using guessed type int (__fastcall *dword_8072288)(_DWORD, _DWORD);

//----- (08051F2E) --------------------------------------------------------
#error "8051F83: call analysis failed (funcsize=31)"

//----- (08051F9B) --------------------------------------------------------
#error "8051FA1: positive sp value has been found (funcsize=0)"

//----- (08051FA2) --------------------------------------------------------
#error "8052BDE: call analysis failed (funcsize=615)"

//----- (08052BE3) --------------------------------------------------------
#error "8052C24: call analysis failed (funcsize=69)"

//----- (08052D95) --------------------------------------------------------
#error "8052DD2: call analysis failed (funcsize=21)"

//----- (08052DD7) --------------------------------------------------------
#error "80532F1: positive sp value has been found (funcsize=376)"

//----- (080532F5) --------------------------------------------------------
int __cdecl sub_80532F5(void *a1, int a2, int a3)
{
  int v4; // [esp+0h] [ebp-2048h]
  int v5; // [esp+Ch] [ebp-203Ch]
  int v6; // [esp+10h] [ebp-2038h]
  int *v7; // [esp+14h] [ebp-2034h]
  int *v8; // [esp+18h] [ebp-2030h]
  int v9; // [esp+28h] [ebp-2020h]
  void *v10; // [esp+2Ch] [ebp-201Ch]
  unsigned __int8 v11; // [esp+33h] [ebp-2015h]
  void *ptr; // [esp+34h] [ebp-2014h]
  int v13; // [esp+38h] [ebp-2010h]
  char v14; // [esp+3Ch] [ebp-200Ch]
  unsigned int v15; // [esp+203Ch] [ebp-Ch]

  v10 = a1;
  v9 = a2;
  v15 = __readgsdword(0x14u);
  ptr = &v4 - 2051;
  v8 = (int *)((char *)&v4 - 8213);
  v7 = &v4 - 2052;
  v6 = a3;
  v5 = a2;
  sub_8052D95(&v4 - 2053, 0x2000, a1);
  if ( ptr != &v14 && ptr != v10 )
    free(ptr);
  return v11 + v13;
}
// 8052D95: using guessed type _DWORD __cdecl sub_8052D95(_DWORD, _DWORD, _DWORD);

//----- (080533F9) --------------------------------------------------------
char *__cdecl sub_80533F9(char *s)
{
  size_t v1; // eax
  char *v2; // eax
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  int v7; // [esp+0h] [ebp-28h]
  int v8; // [esp+4h] [ebp-24h]
  int v9; // [esp+8h] [ebp-20h]
  char *v10; // [esp+18h] [ebp-10h]
  char *v11; // [esp+1Ch] [ebp-Ch]

  v1 = strlen(s);
  v2 = (char *)sub_8061E52(3u, v1 + 1);
  v11 = v2;
  v10 = v2;
  v5 = &loc_80534E2;
  if ( *s )
    v5 = &loc_8053431;
  dword_8072204 = (int)v5;
  sub_8065CE1(v4, v3, v7, v8, v9);
  *v10 = 0;
  return v11;
}
// 8072204: using guessed type int dword_8072204;

//----- (080534ED) --------------------------------------------------------
#error "805382A: call analysis failed (funcsize=181)"

//----- (0805382F) --------------------------------------------------------
#error "8053888: call analysis failed (funcsize=103)"

//----- (08053A7B) --------------------------------------------------------
#error "8053A81: positive sp value has been found (funcsize=0)"

//----- (08053A85) --------------------------------------------------------
#error "8053B39: call analysis failed (funcsize=61)"

//----- (08053B4C) --------------------------------------------------------
#error "8053C52: positive sp value has been found (funcsize=67)"

//----- (08053C57) --------------------------------------------------------
size_t sub_8053C57()
{
  if ( dword_80722F0 )
    return sub_80545CB((int)&unk_80722EC);
  sub_80545CB((int)&dword_80722DC);
  sub_80545CB((int)&unk_80722F4);
  return sub_80545CB((int)&dword_80722E4);
}
// 80722DC: using guessed type int dword_80722DC;
// 80722E4: using guessed type int dword_80722E4;
// 80722F0: using guessed type int dword_80722F0;

//----- (08053C9A) --------------------------------------------------------
int __cdecl sub_8053C9A(int a1, int a2)
{
  int v2; // edx
  int v3; // ecx
  int v4; // edx
  int v5; // eax
  const char *v6; // eax
  int v7; // edx
  int v8; // eax
  int v9; // edx
  int v10; // eax
  unsigned __int8 v11; // al
  int v13; // [esp+0h] [ebp-2D8h]
  int v14; // [esp+4h] [ebp-2D4h]
  const char *v15; // [esp+8h] [ebp-2D0h]
  int v16; // [esp+Ch] [ebp-2CCh]
  int v17; // [esp+2Ch] [ebp-2ACh]
  int v18; // [esp+3Ch] [ebp-29Ch]
  char s; // [esp+40h] [ebp-298h]
  unsigned int v20; // [esp+2CCh] [ebp-Ch]

  v17 = a1;
  v20 = __readgsdword(0x14u);
  sub_804B8E9();
  if ( byte_80728CD )
  {
    v15 = (const char *)v17;
    v4 = sub_8051EEC(v3, v2, (int)&s, 0x28Cu);
    if ( dword_8072898 == 4 )
      v5 = 0;
    else
      v5 = dword_8072870;
    v15 = (const char *)v4;
    v14 = v5;
    printf("%*s ", v5, v4);
  }
  if ( byte_80728A7 )
  {
    if ( *(_BYTE *)(v17 + 120) == 1 )
      v6 = (const char *)sub_80596F1(
                           *(_DWORD *)(v17 + 68),
                           *(_DWORD *)(v17 + 72),
                           (char *)&v13 - 664,
                           dword_80728A8,
                           512,
                           0,
                           qword_80728AC,
                           *(&qword_80728AC + 1));
    else
      v6 = "?";
    if ( dword_8072898 == 4 )
      v7 = 0;
    else
      v7 = dword_8072874;
    v15 = v6;
    v14 = v7;
    printf("%*s ", v7, v6);
  }
  if ( byte_807286C )
  {
    if ( dword_8072898 == 4 )
      v8 = 0;
    else
      v8 = dword_807287C;
    v15 = *(const char **)(v17 + 116);
    v14 = v8;
    printf("%*s ", v8, v15);
  }
  v16 = a2;
  v15 = 0;
  v18 = sub_8053A85(v17, 0);
  if ( dword_80728BC )
  {
    v9 = *(_DWORD *)(v17 + 28);
    v10 = *(unsigned __int8 *)(v17 + 120);
    v15 = *(const char **)(v17 + 108);
    v14 = v9;
    v11 = sub_8054054(v10);
    v18 += v11;
  }
  return v18;
}
// 8053A85: using guessed type _DWORD __cdecl sub_8053A85(_DWORD, _DWORD);
// 8054054: using guessed type _DWORD __cdecl sub_8054054(_DWORD);
// 807286C: using guessed type char byte_807286C;
// 8072870: using guessed type int dword_8072870;
// 8072874: using guessed type int dword_8072874;
// 8072898: using guessed type int dword_8072898;
// 80728A7: using guessed type char byte_80728A7;
// 80728BC: using guessed type int dword_80728BC;
// 80728CD: using guessed type char byte_80728CD;

//----- (08053EB3) --------------------------------------------------------
#error "8053F28: call analysis failed (funcsize=112)"

//----- (08054054) --------------------------------------------------------
#error "805407C: call analysis failed (funcsize=15)"

//----- (08054081) --------------------------------------------------------
#error "80540C9: positive sp value has been found (funcsize=0)"

//----- (080540CA) --------------------------------------------------------
#error "80540FA: call analysis failed (funcsize=29)"

//----- (08054130) --------------------------------------------------------
#error "805453A: call analysis failed (funcsize=160)"

//----- (080545CB) --------------------------------------------------------
size_t __cdecl sub_80545CB(int a1)
{
  if ( byte_80728C2 != 1 )
  {
    byte_80728C2 = 1;
    if ( tcgetpgrp(1) >= 0 )
      sub_804BC9F();
    sub_8053C57();
  }
  return fwrite_unlocked(*(const void **)(a1 + 4), *(_DWORD *)a1, 1u, stdout);
}
// 80728C2: using guessed type char byte_80728C2;

//----- (0805462B) --------------------------------------------------------
#error "8054759: call analysis failed (funcsize=142)"

//----- (0805490B) --------------------------------------------------------
#error "8054911: positive sp value has been found (funcsize=0)"

//----- (08054915) --------------------------------------------------------
#error "80549A5: call analysis failed (funcsize=44)"

//----- (080549B8) --------------------------------------------------------
#error "8054ACA: positive sp value has been found (funcsize=36)"

//----- (08054ACB) --------------------------------------------------------
#error "8054BCF: call analysis failed (funcsize=78)"

//----- (08054C58) --------------------------------------------------------
int __cdecl sub_8054C58(char a1)
{
  int v1; // eax
  char v3; // [esp+1Fh] [ebp-19h]
  unsigned int i; // [esp+20h] [ebp-18h]
  unsigned int v5; // [esp+24h] [ebp-14h]
  int v6; // [esp+28h] [ebp-10h]
  int v7; // [esp+2Ch] [ebp-Ch]

  v5 = 0;
  for ( i = 0; i < dword_8072848; ++i )
  {
    v6 = *((_DWORD *)dword_8072850 + i);
    if ( dword_80728F8 )
      v1 = sub_805462B(v6);
    else
      v1 = 0;
    v7 = v1;
    if ( i )
    {
      if ( dword_80728F8 && (v5 + v1 + 2 >= dword_80728F8 || -3 - v1 < v5) )
      {
        v5 = 0;
        v3 = 10;
      }
      else
      {
        v5 += 2;
        v3 = 32;
      }
      putchar_unlocked(a1);
      putchar_unlocked(v3);
    }
    sub_8053C9A(v6, v5);
    v5 += v7;
  }
  return putchar_unlocked(10);
}
// 805462B: using guessed type _DWORD __cdecl sub_805462B(_DWORD);
// 8072848: using guessed type int dword_8072848;
// 80728F8: using guessed type int dword_80728F8;

//----- (08054D3C) --------------------------------------------------------
#error "8054D87: call analysis failed (funcsize=39)"

//----- (08054DF2) --------------------------------------------------------
#error "8054E29: call analysis failed (funcsize=65)"

//----- (08054E9F) --------------------------------------------------------
unsigned int sub_8054E9F()
{
  unsigned int v0; // eax
  unsigned int result; // eax
  unsigned int i; // [esp+10h] [ebp-28h]
  unsigned int j; // [esp+10h] [ebp-28h]
  unsigned int v4; // [esp+14h] [ebp-24h]
  char *v5; // [esp+18h] [ebp-20h]
  unsigned int k; // [esp+1Ch] [ebp-1Ch]
  unsigned int v7; // [esp+20h] [ebp-18h]
  unsigned int v8; // [esp+28h] [ebp-10h]
  unsigned int v9; // [esp+2Ch] [ebp-Ch]

  v0 = dword_80729AC;
  if ( dword_8072848 <= (unsigned int)dword_80729AC )
    v0 = dword_8072848;
  v7 = v0;
  if ( dword_8073854 < v0 )
  {
    if ( (unsigned int)dword_80729AC >> 1 <= v0 )
    {
      dword_80729A8 = sub_8061E80(dword_80729A8, dword_80729AC, 12);
      v4 = dword_80729AC;
    }
    else
    {
      dword_80729A8 = sub_8061E80(dword_80729A8, v0, 24);
      v4 = 2 * v7;
    }
    v8 = dword_8073854 + v4 + 1;
    v9 = (v4 - dword_8073854) * v8;
    if ( v8 < v4 || v9 / (v4 - dword_8073854) != v8 )
      sub_80620AF();
    v5 = (char *)sub_8061E52(v9 >> 1, 4u);
    for ( i = dword_8073854; i < v4; ++i )
    {
      *((_DWORD *)dword_80729A8 + 3 * i + 2) = v5;
      v5 += 4 * (i + 1);
    }
    dword_8073854 = v4;
  }
  for ( j = 0; ; ++j )
  {
    result = j;
    if ( j >= v7 )
      break;
    *((_BYTE *)dword_80729A8 + 12 * j) = 1;
    *((_DWORD *)dword_80729A8 + 3 * j + 1) = 3 * (j + 1);
    for ( k = 0; k <= j; ++k )
      *(_DWORD *)(4 * k + *((_DWORD *)dword_80729A8 + 3 * j + 2)) = 3;
  }
  return result;
}
// 8072848: using guessed type int dword_8072848;
// 8073854: using guessed type int dword_8073854;

//----- (080550FF) --------------------------------------------------------
#error "805520A: call analysis failed (funcsize=222)"

//----- (080553EF) --------------------------------------------------------
void __cdecl __noreturn sub_80553EF(int status)
{
  int v1; // ebx
  char *v2; // eax
  int v3; // ebx
  char *v4; // eax
  FILE *v5; // ebx
  char *v6; // eax
  FILE *v7; // ebx
  char *v8; // eax
  FILE *v9; // ebx
  char *v10; // eax
  FILE *v11; // ebx
  char *v12; // eax
  FILE *v13; // ebx
  char *v14; // eax
  FILE *v15; // ebx
  char *v16; // eax
  FILE *v17; // ebx
  char *v18; // eax
  FILE *v19; // ebx
  char *v20; // eax
  FILE *v21; // ebx
  char *v22; // eax
  FILE *v23; // ebx
  char *v24; // eax
  FILE *v25; // ebx
  char *v26; // eax
  FILE *v27; // ebx
  char *v28; // eax
  FILE *v29; // ebx
  char *v30; // eax
  FILE *v31; // ebx
  char *v32; // eax
  FILE *v33; // ebx
  char *v34; // eax
  FILE *v35; // ebx
  char *v36; // eax
  FILE *v37; // ebx
  char *v38; // eax
  FILE *v39; // ebx
  char *v40; // eax
  FILE *v41; // ebx
  char *v42; // eax
  FILE *v43; // ebx
  char *v44; // eax
  FILE *v45; // ebx
  char *v46; // eax
  FILE *v47; // ebx
  char *v48; // eax
  FILE *v49; // ebx
  char *v50; // eax
  FILE *v51; // ebx
  char *v52; // eax
  char *v53; // eax

  if ( status )
  {
    v1 = dword_8073870;
    v2 = gettext("Try '%s --help' for more information.\n");
    fprintf(stderr, v2, v1);
  }
  else
  {
    v3 = dword_8073870;
    v4 = gettext("Usage: %s [OPTION]... [FILE]...\n");
    printf(v4, v3);
    v5 = stdout;
    v6 = gettext(
           "List information about the FILEs (the current directory by default).\n"
           "Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.\n");
    fputs_unlocked(v6, v5);
    sub_804AAE3();
    v7 = stdout;
    v8 = gettext(
           "  -a, --all                  do not ignore entries starting with .\n"
           "  -A, --almost-all           do not list implied . and ..\n"
           "      --author               with -l, print the author of each file\n"
           "  -b, --escape               print C-style escapes for nongraphic characters\n");
    fputs_unlocked(v8, v7);
    v9 = stdout;
    v10 = gettext(
            "      --block-size=SIZE      scale sizes by SIZE before printing them; e.g.,\n"
            "                               '--block-size=M' prints sizes in units of\n"
            "                               1,048,576 bytes; see SIZE format below\n"
            "  -B, --ignore-backups       do not list implied entries ending with ~\n"
            "  -c                         with -lt: sort by, and show, ctime (time of last\n"
            "                               modification of file status information);\n"
            "                               with -l: show ctime and sort by name;\n"
            "                               otherwise: sort by ctime, newest first\n");
    fputs_unlocked(v10, v9);
    v11 = stdout;
    v12 = gettext(
            "  -C                         list entries by columns\n"
            "      --color[=WHEN]         colorize the output; WHEN can be 'always' (default\n"
            "                               if omitted), 'auto', or 'never'; more info below\n"
            "  -d, --directory            list directories themselves, not their contents\n"
            "  -D, --dired                generate output designed for Emacs' dired mode\n");
    fputs_unlocked(v12, v11);
    v13 = stdout;
    v14 = gettext(
            "  -f                         do not sort, enable -aU, disable -ls --color\n"
            "  -F, --classify             append indicator (one of */=>@|) to entries\n"
            "      --file-type            likewise, except do not append '*'\n"
            "      --format=WORD          across -x, commas -m, horizontal -x, long -l,\n"
            "                               single-column -1, verbose -l, vertical -C\n"
            "      --full-time            like -l --time-style=full-iso\n");
    fputs_unlocked(v14, v13);
    v15 = stdout;
    v16 = gettext("  -g                         like -l, but do not list owner\n");
    fputs_unlocked(v16, v15);
    v17 = stdout;
    v18 = gettext(
            "      --group-directories-first\n"
            "                             group directories before files;\n"
            "                               can be augmented with a --sort option, but any\n"
            "                               use of --sort=none (-U) disables grouping\n");
    fputs_unlocked(v18, v17);
    v19 = stdout;
    v20 = gettext(
            "  -G, --no-group             in a long listing, don't print group names\n"
            "  -h, --human-readable       with -l and/or -s, print human readable sizes\n"
            "                               (e.g., 1K 234M 2G)\n"
            "      --si                   likewise, but use powers of 1000 not 1024\n");
    fputs_unlocked(v20, v19);
    v21 = stdout;
    v22 = gettext(
            "  -H, --dereference-command-line\n"
            "                             follow symbolic links listed on the command line\n"
            "      --dereference-command-line-symlink-to-dir\n"
            "                             follow each command line symbolic link\n"
            "                               that points to a directory\n"
            "      --hide=PATTERN         do not list implied entries matching shell PATTERN\n"
            "                               (overridden by -a or -A)\n");
    fputs_unlocked(v22, v21);
    v23 = stdout;
    v24 = gettext(
            "      --hyperlink[=WHEN]     hyperlink file names; WHEN can be 'always'\n"
            "                               (default if omitted), 'auto', or 'never'\n");
    fputs_unlocked(v24, v23);
    v25 = stdout;
    v26 = gettext(
            "      --indicator-style=WORD  append indicator with style WORD to entry names:\n"
            "                               none (default), slash (-p),\n"
            "                               file-type (--file-type), classify (-F)\n"
            "  -i, --inode                print the index number of each file\n"
            "  -I, --ignore=PATTERN       do not list implied entries matching shell PATTERN\n"
            "  -k, --kibibytes            default to 1024-byte blocks for disk usage\n");
    fputs_unlocked(v26, v25);
    v27 = stdout;
    v28 = gettext(
            "  -l                         use a long listing format\n"
            "  -L, --dereference          when showing file information for a symbolic\n"
            "                               link, show information for the file the link\n"
            "                               references rather than for the link itself\n"
            "  -m                         fill width with a comma separated list of entries\n");
    fputs_unlocked(v28, v27);
    v29 = stdout;
    v30 = gettext(
            "  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs\n"
            "  -N, --literal              print entry names without quoting\n"
            "  -o                         like -l, but do not list group information\n"
            "  -p, --indicator-style=slash\n"
            "                             append / indicator to directories\n");
    fputs_unlocked(v30, v29);
    v31 = stdout;
    v32 = gettext(
            "  -q, --hide-control-chars   print ? instead of nongraphic characters\n"
            "      --show-control-chars   show nongraphic characters as-is (the default,\n"
            "                               unless program is 'ls' and output is a terminal)\n"
            "  -Q, --quote-name           enclose entry names in double quotes\n"
            "      --quoting-style=WORD   use quoting style WORD for entry names:\n"
            "                               literal, locale, shell, shell-always,\n"
            "                               shell-escape, shell-escape-always, c, escape\n");
    fputs_unlocked(v32, v31);
    v33 = stdout;
    v34 = gettext(
            "  -r, --reverse              reverse order while sorting\n"
            "  -R, --recursive            list subdirectories recursively\n"
            "  -s, --size                 print the allocated size of each file, in blocks\n");
    fputs_unlocked(v34, v33);
    v35 = stdout;
    v36 = gettext(
            "  -S                         sort by file size, largest first\n"
            "      --sort=WORD            sort by WORD instead of name: none (-U), size (-S),\n"
            "                               time (-t), version (-v), extension (-X)\n"
            "      --time=WORD            with -l, show time as WORD instead of default\n"
            "                               modification time: atime or access or use (-u);\n"
            "                               ctime or status (-c); also use specified time\n"
            "                               as sort key if --sort=time (newest first)\n");
    fputs_unlocked(v36, v35);
    v37 = stdout;
    v38 = gettext(
            "      --time-style=STYLE     with -l, show times using style STYLE:\n"
            "                               full-iso, long-iso, iso, locale, or +FORMAT;\n"
            "                               FORMAT is interpreted like in 'date'; if FORMAT\n"
            "                               is FORMAT1<newline>FORMAT2, then FORMAT1 applies\n"
            "                               to non-recent files and FORMAT2 to recent files;\n"
            "                               if STYLE is prefixed with 'posix-', STYLE\n"
            "                               takes effect only outside the POSIX locale\n");
    fputs_unlocked(v38, v37);
    v39 = stdout;
    v40 = gettext(
            "  -t                         sort by modification time, newest first\n"
            "  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8\n");
    fputs_unlocked(v40, v39);
    v41 = stdout;
    v42 = gettext(
            "  -u                         with -lt: sort by, and show, access time;\n"
            "                               with -l: show access time and sort by name;\n"
            "                               otherwise: sort by access time, newest first\n"
            "  -U                         do not sort; list entries in directory order\n"
            "  -v                         natural sort of (version) numbers within text\n");
    fputs_unlocked(v42, v41);
    v43 = stdout;
    v44 = gettext(
            "  -w, --width=COLS           set output width to COLS.  0 means no limit\n"
            "  -x                         list entries by lines instead of by columns\n"
            "  -X                         sort alphabetically by entry extension\n"
            "  -Z, --context              print any security context of each file\n"
            "  -1                         list one file per line.  Avoid '\\n' with -q or -b\n");
    fputs_unlocked(v44, v43);
    v45 = stdout;
    v46 = gettext("      --help     display this help and exit\n");
    fputs_unlocked(v46, v45);
    v47 = stdout;
    v48 = gettext("      --version  output version information and exit\n");
    fputs_unlocked(v48, v47);
    sub_804AB0E();
    v49 = stdout;
    v50 = gettext(
            "\n"
            "Using color to distinguish file types is disabled both by default and\n"
            "with --color=never.  With --color=auto, ls emits color codes only when\n"
            "standard output is connected to a terminal.  The LS_COLORS environment\n"
            "variable can change the settings.  Use the dircolors command to set it.\n");
    fputs_unlocked(v50, v49);
    v51 = stdout;
    v52 = gettext(
            "\n"
            "Exit status:\n"
            " 0  if OK,\n"
            " 1  if minor problems (e.g., cannot access subdirectory),\n"
            " 2  if serious trouble (e.g., cannot access command-line argument).\n");
    fputs_unlocked(v52, v51);
    if ( dword_80723E4 == 1 )
    {
      v53 = "ls";
    }
    else if ( dword_80723E4 == 2 )
    {
      v53 = "dir";
    }
    else
    {
      v53 = "vdir";
    }
    sub_804AB39(v53);
  }
  exit(status);
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 80723E4: using guessed type int dword_80723E4;
// 8073870: using guessed type int dword_8073870;

//----- (0805575B) --------------------------------------------------------
#error "805587B: call analysis failed (funcsize=96)"

//----- (0805589D) --------------------------------------------------------
void __noreturn sub_805589D()
{
  sub_80553EF(1);
}

//----- (080558B1) --------------------------------------------------------
int __cdecl sub_80558B1(char *s, int a2, int a3, size_t a4)
{
  int result; // eax
  bool v5; // zf
  void *v6; // eax
  char v7; // [esp+13h] [ebp-15h]
  signed int i; // [esp+14h] [ebp-14h]
  signed int v9; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]

  v9 = -1;
  v7 = 0;
  n = strlen(s);
  for ( i = 0; *(_DWORD *)(4 * i + a2); ++i )
  {
    if ( !strncmp(*(const char **)(4 * i + a2), s, n) )
    {
      if ( strlen(*(const char **)(4 * i + a2)) == n )
        return i;
      if ( v9 == -1 )
      {
        v9 = i;
      }
      else
      {
        if ( a3 )
        {
          v5 = memcmp((const void *)(a3 + a4 * v9), (const void *)(i * a4 + a3), a4) == 0;
          v6 = &loc_80559D5;
          if ( v5 )
            v6 = &loc_80559D9;
          dword_807224C = (int)v6;
          sub_8065B27();
        }
        v7 = 1;
      }
    }
  }
  if ( v7 )
    result = -2;
  else
    result = v9;
  return result;
}
// 807224C: using guessed type int dword_807224C;

//----- (08055A08) --------------------------------------------------------
void __cdecl sub_8055A08(int a1, int a2, int a3)
{
  char *v3; // eax
  char *format; // ST2C_4
  int v5; // ebx
  int v6; // eax

  if ( a3 == -1 )
    v3 = gettext("invalid argument %s for %s");
  else
    v3 = gettext("ambiguous argument %s for %s");
  format = v3;
  v5 = sub_8060EC6(1);
  v6 = sub_806093B(0, 8);
  error(0, 0, format, v6, v5);
}

//----- (08055A8B) --------------------------------------------------------
int __cdecl sub_8055A8B(int a1)
{
  FILE *v1; // ebx
  char *v2; // eax
  int v3; // ecx
  void *v4; // eax
  int v6; // [esp+0h] [ebp-28h]
  int v7; // [esp+4h] [ebp-24h]
  int v8; // [esp+8h] [ebp-20h]

  v1 = stderr;
  v2 = gettext("Valid arguments are:");
  fputs_unlocked(v2, v1);
  v4 = &loc_8055BAC;
  if ( *(_DWORD *)a1 )
    v4 = &loc_8055AC3;
  dword_8072204 = (int)v4;
  sub_8065CE1(v3, 0, v6, v7, v8);
  return putc_unlocked(10, stderr);
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8072204: using guessed type int dword_8072204;

//----- (08055BC7) --------------------------------------------------------
int __cdecl sub_8055BC7(int a1, char *s, int a3, int a4, size_t n, int a6)
{
  int v7; // [esp+4h] [ebp-24h]
  size_t v8; // [esp+8h] [ebp-20h]
  int v9; // [esp+1Ch] [ebp-Ch]

  v9 = sub_80558B1(s, a3, a4, n);
  if ( v9 >= 0 )
  {
    dword_807224C = (int)&locret_8055C5C;
    sub_8065B27();
  }
  sub_8055A08(a1, (int)s, v9);
  v8 = n;
  v7 = a4;
  sub_8055A8B(a3);
  ((void (*)(void))a6)();
  return -1;
}
// 807224C: using guessed type int dword_807224C;

//----- (08055CD8) --------------------------------------------------------
signed int __cdecl sub_8055CD8(signed int a1)
{
  if ( a1 > 90 )
  {
    if ( (unsigned int)(a1 - 97) <= 0x19 )
      return 1;
  }
  else if ( a1 >= 65 || (unsigned int)(a1 - 48) <= 9 )
  {
    return 1;
  }
  return 0;
}

//----- (08055D08) --------------------------------------------------------
#error "8055D2C: call analysis failed (funcsize=23)"

//----- (08055DD3) --------------------------------------------------------
_BOOL4 __cdecl sub_8055DD3(int a1)
{
  return (unsigned int)(a1 - 48) <= 9;
}

//----- (08055F0A) --------------------------------------------------------
int __cdecl sub_8055F0A(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 65) > 0x19 )
    result = a1;
  else
    result = a1 + 32;
  return result;
}

//----- (08055F40) --------------------------------------------------------
int __cdecl sub_8055F40(int a1, char *s, int a3)
{
  if ( !*(_DWORD *)a1 )
  {
    *(_DWORD *)a1 = sub_80580BE(7, 0, sub_805915F, sub_8059336, sub_80593F6);
    if ( !*(_DWORD *)a1 )
      sub_80620AF();
  }
  if ( (unsigned __int8)sub_8056D2C(*(_DWORD *)a1, s, a3) )
    return 1;
  sub_8056C82(*(_DWORD *)a1, s, a3);
  return 0;
}
// 8056D2C: using guessed type _DWORD __cdecl sub_8056D2C(_DWORD, _DWORD, _DWORD);
// 80580BE: using guessed type _DWORD __cdecl sub_80580BE(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (08055FDC) --------------------------------------------------------
char *__cdecl sub_8055FDC(void *src, int a2)
{
  _BYTE *v3; // eax
  void *v4; // eax
  void *v5; // eax
  _BYTE *v6; // eax
  char *v7; // eax
  int v8; // ecx
  int v9; // edx
  bool v10; // al
  size_t v11; // eax
  size_t v12; // eax
  char *v13; // eax
  void *v14; // eax
  void *v15; // eax
  int v16; // [esp+0h] [ebp-C8h]
  int v17; // [esp+4h] [ebp-C4h]
  int v18; // [esp+8h] [ebp-C0h]
  int v19; // [esp+Ch] [ebp-BCh]
  int v20; // [esp+10h] [ebp-B8h]
  int v21; // [esp+14h] [ebp-B4h]
  void *v22; // [esp+18h] [ebp-B0h]
  char *s; // [esp+1Ch] [ebp-ACh]
  void *dest; // [esp+20h] [ebp-A8h]
  void *ptr; // [esp+24h] [ebp-A4h]
  void *i; // [esp+28h] [ebp-A0h]
  char *j; // [esp+2Ch] [ebp-9Ch]
  char *v28; // [esp+30h] [ebp-98h]
  size_t size; // [esp+34h] [ebp-94h]
  int v30; // [esp+38h] [ebp-90h]
  size_t n; // [esp+3Ch] [ebp-8Ch]
  size_t v32; // [esp+40h] [ebp-88h]
  unsigned int v33; // [esp+44h] [ebp-84h]
  char *v34; // [esp+48h] [ebp-80h]
  int v35; // [esp+4Ch] [ebp-7Ch]
  char *v36; // [esp+50h] [ebp-78h]
  size_t v37; // [esp+54h] [ebp-74h]
  size_t v38; // [esp+58h] [ebp-70h]
  size_t v39; // [esp+5Ch] [ebp-6Ch]
  int v40; // [esp+60h] [ebp-68h]
  int v41; // [esp+70h] [ebp-58h]
  int v42; // [esp+8Ch] [ebp-3Ch]
  int v43; // [esp+D4h] [ebp+Ch]

  ptr = 0;
  size = 0;
  v22 = 0;
  v33 = a2 & 0xFFFFFFFC;
  HIBYTE(v21) = (a2 & 4) != 0;
  v43 = a2 & 3;
  if ( v43 & (v43 - 1) )
  {
    *__errno_location() = 22;
    return 0;
  }
  if ( !src )
  {
    *__errno_location() = 22;
    return 0;
  }
  if ( !*(_BYTE *)src )
  {
    *__errno_location() = 2;
    return 0;
  }
  n = 0;
  if ( *(_BYTE *)src != 47 )
  {
    s = sub_8062314();
    if ( s )
    {
      dest = strchr(s, 0);
      if ( (_BYTE *)dest - s > 4095 )
      {
        v28 = (char *)dest;
      }
      else
      {
        v34 = (char *)sub_8061F89(s, 0x1000u);
        dest = &v34[(_BYTE *)dest - s];
        s = v34;
        v28 = v34 + 4096;
      }
      i = src;
      n = 0;
      goto LABEL_79;
    }
    return 0;
  }
  s = (char *)sub_8061F5F(0x1000u);
  v28 = s + 4096;
  dest = s;
  if ( n )
  {
    memcpy(s, src, n);
    dest = (char *)dest + n;
  }
  v3 = dest;
  dest = (char *)dest + 1;
  *v3 = 47;
  for ( i = (char *)src + n; ; i = j )
  {
LABEL_79:
    if ( !*(_BYTE *)i )
      goto LABEL_93;
    v4 = &loc_805626C;
    if ( *(_BYTE *)i == 47 )
      v4 = &loc_805622F;
    dword_8072260 = (int)v4;
    sub_8065AB5(
      v16,
      v17,
      v18,
      v19,
      v20,
      v21,
      v22,
      s,
      dest,
      ptr,
      i,
      j,
      v28,
      size,
      v30,
      n,
      v32,
      v33,
      v34,
      v35,
      v36,
      v37,
      v38);
    for ( j = (char *)i; *j && *j != 47; ++j )
      ;
    if ( j == i )
    {
LABEL_93:
      if ( &s[n + 1] < dest && *((char *)dest - 1) == 47 )
        dest = (char *)dest - 1;
      *(_BYTE *)dest = 0;
      if ( (char *)dest + 1 != v28 )
        s = (char *)sub_8061F89(s, (_BYTE *)dest - s + 1);
      free(ptr);
      if ( v22 )
        sub_805838D(v22);
      return s;
    }
    if ( j - (_BYTE *)i == 1 && *(_BYTE *)i == 46 )
      continue;
    if ( j - (_BYTE *)i == 2 && *(_BYTE *)i == 46 )
    {
      v5 = &loc_805633A;
      if ( *((_BYTE *)i + 1) != 46 )
        v5 = &loc_8056386;
      dword_8072260 = (int)v5;
      sub_8065AB5(
        v16,
        v17,
        v18,
        v19,
        v20,
        v21,
        v22,
        s,
        dest,
        ptr,
        i,
        j,
        v28,
        size,
        v30,
        n,
        v32,
        v33,
        v34,
        v35,
        v36,
        v37,
        v38);
      if ( &s[n + 1] < dest )
      {
        for ( dest = (char *)dest - 1; dest > s && *((char *)dest - 1) != 47; dest = (char *)dest - 1 )
          ;
      }
      continue;
    }
    if ( *((char *)dest - 1) != 47 )
    {
      v6 = dest;
      dest = (char *)dest + 1;
      *v6 = 47;
    }
    if ( (char *)dest + j - (_BYTE *)i >= v28 )
    {
      v35 = (_BYTE *)dest - s;
      v32 = v28 - s;
      if ( j - (_BYTE *)i + 1 <= 4096 )
        v32 += 4096;
      else
        v32 += j - (_BYTE *)i + 1;
      s = (char *)sub_8061F89(s, v32);
      v28 = &s[v32];
      dest = &s[v35];
    }
    v7 = (char *)memcpy(dest, i, j - (_BYTE *)i);
    v9 = j - (_BYTE *)i;
    dest = &v7[j - (_BYTE *)i];
    *(_BYTE *)dest = 0;
    if ( HIBYTE(v21) && v43 == 2 )
    {
      v41 = 0;
    }
    else
    {
      if ( HIBYTE(v21) )
        v10 = sub_8065842((int)s, (int)&v40) != 0;
      else
        v10 = sub_80658A0((int)s, (int)&v40) != 0;
      if ( v10 )
      {
        v30 = *__errno_location();
        if ( !v43 )
          goto LABEL_88;
        if ( v43 == 1 )
        {
          v11 = strspn(j, "/");
          if ( j[v11] || v30 != 2 )
            goto LABEL_88;
          continue;
        }
        v41 = 0;
      }
    }
    if ( (v41 & 0xF000) != 40960 )
      break;
    if ( (unsigned __int8)sub_8055F40((int)&v22, (char *)src, (int)&v40) )
    {
      if ( v43 != 2 )
      {
        v30 = 40;
        goto LABEL_88;
      }
    }
    else
    {
      v36 = (char *)sub_805575B(s, v42);
      if ( v36 )
      {
        v37 = strlen(v36);
        v38 = strlen(j);
        if ( size )
        {
          if ( v37 + v38 + 1 > size )
          {
            size = v37 + v38 + 1;
            ptr = sub_8061F89(ptr, size);
          }
        }
        else
        {
          v12 = v37 + v38 + 1;
          if ( v12 < 0x1000 )
            v12 = 4096;
          size = v12;
          ptr = sub_8061F5F(v12);
        }
        memmove((char *)ptr + v37, j, v38 + 1);
        v13 = (char *)memcpy(ptr, v36, v37);
        j = v13;
        src = v13;
        v14 = &loc_805678C;
        if ( *v36 != 47 )
          v14 = &loc_80567F3;
        dword_807224C = (int)v14;
        sub_8065B27();
        v39 = 0;
        dest = s + 1;
        *s = 47;
        n = v39;
        free(v36);
      }
      else if ( v43 != 2 || *__errno_location() == 12 )
      {
        v30 = *__errno_location();
        goto LABEL_88;
      }
    }
LABEL_78:
    ;
  }
  if ( (v41 & 0xF000) == 0x4000 || !*j )
    goto LABEL_78;
  v15 = &loc_8056882;
  if ( v43 == 2 )
    v15 = &loc_8056891;
  dword_8072204 = (int)v15;
  sub_8065CE1(v8, v9, v16, v17, v18);
  v30 = 20;
LABEL_88:
  free(ptr);
  free(s);
  if ( v22 )
    sub_805838D(v22);
  *__errno_location() = v30;
  return 0;
}
// 8055FDC: could not find valid save-restore pair for ebx
// 8065AB5: using guessed type int __stdcall sub_8065AB5(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8072204: using guessed type int dword_8072204;
// 807224C: using guessed type int dword_807224C;
// 8072260: using guessed type int dword_8072260;

//----- (080569BD) --------------------------------------------------------
int sub_80569BD()
{
  int v0; // ebx
  int *v1; // eax
  int *v2; // eax
  int result; // eax
  char *v4; // [esp+2Ch] [ebp-Ch]

  if ( sub_80644CA(stdout) && (byte_807385C != 1 || *__errno_location() != 32) )
  {
    v4 = gettext("write error");
    if ( dword_8073858 )
    {
      v0 = sub_8060B5E(dword_8073858);
      v1 = __errno_location();
      error(0, *v1, "%s: %s", v0, v4);
    }
    else
    {
      v2 = __errno_location();
      error(0, *v2, "%s", v4);
    }
    _exit(status);
  }
  result = sub_80644CA(stderr);
  if ( result )
    _exit(status);
  return result;
}
// 8073858: using guessed type int dword_8073858;
// 807385C: using guessed type char byte_807385C;

//----- (08056AA1) --------------------------------------------------------
unsigned int __cdecl sub_8056AA1(_BYTE *a1)
{
  unsigned int i; // [esp+18h] [ebp-10h]
  _BOOL4 v3; // [esp+1Ch] [ebp-Ch]

  v3 = *a1 == 47;
  for ( i = sub_8056BAD(a1) - (_DWORD)a1; v3 < i && a1[i - 1] == 47; --i )
    ;
  return i;
}
// 8056BAD: using guessed type _DWORD __cdecl sub_8056BAD(_DWORD);

//----- (08056B12) --------------------------------------------------------
void *__cdecl sub_8056B12(void *src)
{
  void *v2; // eax
  unsigned int n; // [esp+18h] [ebp-10h]
  void *dest; // [esp+1Ch] [ebp-Ch]

  n = sub_8056AA1(src);
  dest = malloc((n == 0) + n + 1);
  if ( !dest )
    return 0;
  memcpy(dest, src, n);
  v2 = &loc_8056B8C;
  if ( n != 0 )
    v2 = &loc_8056B9D;
  dword_807224C = (int)v2;
  sub_8065B27();
  *((_BYTE *)dest + n) = 46;
  *((_BYTE *)dest + n + 1) = 0;
  return dest;
}
// 807224C: using guessed type int dword_807224C;

//----- (08056BAD) --------------------------------------------------------
#error "8056C30: call analysis failed (funcsize=30)"

//----- (08056C3A) --------------------------------------------------------
size_t __cdecl sub_8056C3A(char *s)
{
  size_t i; // [esp+18h] [ebp-10h]

  for ( i = strlen(s); i > 1 && s[i - 1] == 47; --i )
    ;
  return i;
}

//----- (08056C78) --------------------------------------------------------
int sub_8056C78()
{
  return 0;
}

//----- (08056C82) --------------------------------------------------------
void __cdecl sub_8056C82(int a1, char *s, int a3)
{
  void *v3; // edx
  void *v4; // edx
  void **v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]

  if ( a1 )
  {
    v5 = (void **)sub_8061F5F(0x14u);
    *v5 = sub_806208A(s);
    v3 = *(void **)(a3 + 92);
    v5[1] = *(void **)(a3 + 88);
    v5[2] = v3;
    v4 = *(void **)(a3 + 4);
    v5[3] = *(void **)a3;
    v5[4] = v4;
    v6 = sub_8058E55(a1, (int)v5);
    if ( !v6 )
      sub_80620AF();
    if ( (void **)v6 != v5 )
      sub_80593F6(v5);
  }
}

//----- (08056D2C) --------------------------------------------------------
#error "8056D61: call analysis failed (funcsize=21)"

//----- (08056DC0) --------------------------------------------------------
#error "8056DFF: call analysis failed (funcsize=24)"

//----- (08056E80) --------------------------------------------------------
#error "8056EFC: call analysis failed (funcsize=160)"

//----- (08057083) --------------------------------------------------------
int __cdecl sub_8057083(int a1, int a2)
{
  return sub_8056E80(*(_DWORD *)(a1 + 16), a2);
}
// 8056E80: using guessed type _DWORD __cdecl sub_8056E80(_DWORD, _DWORD);

//----- (080570A0) --------------------------------------------------------
void *__cdecl sub_80570A0(int a1, _BYTE *a2, int *a3)
{
  void *v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_80570FF(a1, a2, a3);
  if ( !v4 )
    sub_80620AF();
  return v4;
}

//----- (080570D2) --------------------------------------------------------
_BYTE *__cdecl sub_80570D2(_BYTE *a1)
{
  dword_807224C = (int)&loc_80570F0;
  sub_8065B27();
  do
    ++a1;
  while ( *a1 == 47 );
  return a1;
}
// 807224C: using guessed type int dword_807224C;

//----- (080570FF) --------------------------------------------------------
void *__cdecl sub_80570FF(int a1, _BYTE *a2, int *a3)
{
  _BOOL4 v3; // eax
  _BYTE *v5; // eax
  int v6; // edx
  int v7; // ecx
  int v8; // [esp+0h] [ebp-38h]
  char *v9; // [esp+10h] [ebp-28h]
  size_t v10; // [esp+14h] [ebp-24h]
  int v11; // [esp+18h] [ebp-20h]
  _BOOL4 v12; // [esp+1Ch] [ebp-1Ch]
  char *s; // [esp+20h] [ebp-18h]
  size_t v14; // [esp+24h] [ebp-14h]
  void *v15; // [esp+28h] [ebp-10h]
  int v16; // [esp+2Ch] [ebp-Ch]

  v9 = (char *)sub_8056BAD(a1);
  v10 = sub_8056C3A(v9);
  v11 = (int)&v9[v10 - a1];
  v3 = v10 && v9[v10 - 1] != 47;
  v12 = v3;
  s = sub_80570D2(a2);
  v14 = strlen(s);
  v15 = malloc(v12 + v11 + v14 + 1);
  if ( !v15 )
    return 0;
  v5 = (_BYTE *)mempcpy(v15, a1, v11);
  *v5 = 47;
  v16 = (int)&v5[v12];
  if ( a3 )
  {
    if ( *a2 == 47 )
    {
      dword_8072224 = (int)&loc_805720C;
      sub_8065C0F(v7, v6, v8);
    }
    *a3 = v16;
  }
  *(_BYTE *)mempcpy(v16, s, v14) = 0;
  return v15;
}
// 80499B0: using guessed type int __cdecl mempcpy(_DWORD, _DWORD, _DWORD);
// 8056BAD: using guessed type _DWORD __cdecl sub_8056BAD(_DWORD);
// 8072224: using guessed type int dword_8072224;

//----- (0805723D) --------------------------------------------------------
_BYTE *__usercall sub_805723D@<eax>(int a1@<edx>, int a2@<ecx>, _BYTE **a3)
{
  int v4; // [esp+0h] [ebp-28h]
  char v5; // [esp+1Bh] [ebp-Dh]
  _BYTE *v6; // [esp+1Ch] [ebp-Ch]

  v6 = 0;
  v5 = 0;
  dword_8072224 = (int)&loc_80572F8;
  sub_8065C0F(a2, a1, v4);
  do
  {
    if ( v5 )
    {
      v5 = 0;
      if ( (unsigned __int8)sub_8055D08((char)**a3) ^ 1 && **a3 != 126 )
        v6 = 0;
    }
    else if ( **a3 == 46 )
    {
      v5 = 1;
      if ( !v6 )
        v6 = *a3;
    }
    else if ( (unsigned __int8)sub_8055CD8((char)**a3) ^ 1 && **a3 != 126 )
    {
      v6 = 0;
    }
    ++*a3;
  }
  while ( **a3 );
  return v6;
}
// 8055D08: using guessed type _DWORD __cdecl sub_8055D08(_DWORD);
// 8072224: using guessed type int dword_8072224;

//----- (0805730D) --------------------------------------------------------
int __cdecl sub_805730D(unsigned __int8 a1)
{
  if ( (unsigned __int8)sub_8055DD3(a1) )
    return 0;
  if ( (unsigned __int8)sub_8055D08(a1) )
    return a1;
  if ( a1 == 126 )
    return -1;
  return a1 + 256;
}
// 8055D08: using guessed type _DWORD __cdecl sub_8055D08(_DWORD);

//----- (0805735E) --------------------------------------------------------
#error "8057524: call analysis failed (funcsize=176)"

//----- (08057590) --------------------------------------------------------
int __cdecl sub_8057590(char *s1, char *s2)
{
  int v3; // edx
  int v4; // ecx
  bool v5; // zf
  void *v6; // eax
  int v7; // [esp+0h] [ebp-38h]
  int v8; // [esp+0h] [ebp-38h]
  int v9; // [esp+4h] [ebp-34h]
  int v10; // [esp+4h] [ebp-34h]
  int v11; // [esp+8h] [ebp-30h]
  int v12; // [esp+Ch] [ebp-2Ch]
  int v13; // [esp+10h] [ebp-28h]
  int v14; // [esp+14h] [ebp-24h]
  size_t n; // [esp+18h] [ebp-20h]
  int v16; // [esp+1Ch] [ebp-1Ch]
  int v17; // [esp+20h] [ebp-18h]
  int v18; // [esp+24h] [ebp-14h]
  int v19; // [esp+28h] [ebp-10h]

  v17 = strcmp(s1, s2);
  if ( !v17 )
    return 0;
  if ( !*s1 )
    return -1;
  if ( !*s2 )
    return 1;
  if ( !strcmp(".", s1) )
    return -1;
  if ( !strcmp(".", s2) )
  {
    dword_8072204 = (int)&locret_8057848;
    sub_8065CE1(v4, v3, v7, v9, v11);
  }
  v5 = strcmp("..", s1) == 0;
  v6 = &loc_8057667;
  if ( !v5 )
    v6 = &loc_8057671;
  dword_80721F0 = (int)v6;
  sub_8065D53(v8, v10, v11, v12, v13, v14, n, v16, v17, v18, v19);
  return -1;
}
// 8065D53: using guessed type int __stdcall sub_8065D53(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80721F0: using guessed type int dword_80721F0;
// 8072204: using guessed type int dword_8072204;

//----- (0805784A) --------------------------------------------------------
struct timespec *__cdecl sub_805784A(struct timespec *tp)
{
  struct timespec *result; // eax
  struct timeval tv; // [esp+18h] [ebp-10h]

  result = (struct timespec *)clock_gettime(0, tp);
  if ( result )
  {
    gettimeofday(&tv, 0);
    tp->tv_sec = tv.tv_sec;
    result = tp;
    tp->tv_nsec = 1000 * tv.tv_usec;
  }
  return result;
}

//----- (08057895) --------------------------------------------------------
int __cdecl sub_8057895(int category)
{
  unsigned __int8 v2; // [esp+1Bh] [ebp-Dh]
  const char *s1; // [esp+1Ch] [ebp-Ch]

  v2 = 1;
  s1 = setlocale(category, 0);
  if ( s1 && (!strcmp(s1, "C") || !strcmp(s1, "POSIX")) )
    v2 = 0;
  return v2;
}

//----- (080578F3) --------------------------------------------------------
int __cdecl sub_80578F3(int a1)
{
  return *(_DWORD *)(a1 + 8);
}

//----- (080578FE) --------------------------------------------------------
int __cdecl sub_80578FE(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (08057909) --------------------------------------------------------
int __cdecl sub_8057909(int a1)
{
  return *(_DWORD *)(a1 + 16);
}

//----- (08057914) --------------------------------------------------------
unsigned int __cdecl sub_8057914(int a1)
{
  _DWORD *i; // [esp+0h] [ebp-10h]
  unsigned int v3; // [esp+4h] [ebp-Ch]
  _DWORD *v4; // [esp+8h] [ebp-8h]
  unsigned int j; // [esp+Ch] [ebp-4h]

  v3 = 0;
  for ( i = *(_DWORD **)a1; *(_DWORD *)(a1 + 4) > (unsigned int)i; i += 2 )
  {
    if ( *i )
    {
      v4 = i;
      for ( j = 1; ; ++j )
      {
        v4 = (_DWORD *)v4[1];
        if ( !v4 )
          break;
      }
      if ( j > v3 )
        v3 = j;
    }
  }
  return v3;
}

//----- (08057AFD) --------------------------------------------------------
#error "8057B1F: call analysis failed (funcsize=13)"

//----- (08057B24) --------------------------------------------------------
#error "8057B61: positive sp value has been found (funcsize=0)"

//----- (08057B62) --------------------------------------------------------
int __cdecl sub_8057B62(int a1, int a2)
{
  _DWORD *i; // [esp+18h] [ebp-10h]
  _DWORD *v4; // [esp+1Ch] [ebp-Ch]

  v4 = (_DWORD *)sub_8057AFD(a1, a2);
  if ( !*v4 )
    return 0;
  for ( i = v4; i; i = (_DWORD *)i[1] )
  {
    if ( *i == a2 || (*(unsigned __int8 (__cdecl **)(int, _DWORD))(a1 + 28))(a2, *i) )
      return *i;
  }
  return 0;
}
// 8057AFD: using guessed type int __cdecl sub_8057AFD(_DWORD, _DWORD);

//----- (08057E24) --------------------------------------------------------
bool __cdecl sub_8057E24(unsigned int a1)
{
  int v1; // ST08_4
  unsigned int v3; // [esp+8h] [ebp-8h]
  unsigned int v4; // [esp+Ch] [ebp-4h]

  v3 = 3;
  v4 = 9;
  while ( v4 < a1 && a1 % v3 )
  {
    v1 = v3 + 1;
    v4 += 4 * v1;
    v3 = v1 + 1;
  }
  return a1 % v3 != 0;
}

//----- (08057E7B) --------------------------------------------------------
int __cdecl sub_8057E7B(unsigned int a1)
{
  int i; // [esp+Ch] [ebp+8h]

  if ( a1 <= 9 )
    a1 = 10;
  for ( i = a1 | 1; i != -1 && !sub_8057E24(i); i += 2 )
    ;
  return i;
}

//----- (08057F1C) --------------------------------------------------------
unsigned int __cdecl sub_8057F1C(int a1, unsigned int a2)
{
  return sub_8064275(a1, 3) % a2;
}

//----- (08057F47) --------------------------------------------------------
bool __cdecl sub_8057F47(int a1, int a2)
{
  return a1 == a2;
}

//----- (08057F55) --------------------------------------------------------
signed int __cdecl sub_8057F55(int a1)
{
  int v2; // [esp+8h] [ebp-8h]

  v2 = *(_DWORD *)(a1 + 20);
  if ( (_UNKNOWN *)v2 == &unk_806A660 )
    return 1;
  if ( *(float *)(v2 + 8) > 0.1
    && 1.0 - 0.1 > *(float *)(v2 + 8)
    && *(float *)(v2 + 12) > 0.1 + 1.0
    && *(float *)v2 >= 0.0
    && *(float *)(v2 + 4) > *(float *)v2 + 0.1
    && *(float *)(v2 + 4) <= 1.0
    && *(float *)(v2 + 8) > *(float *)v2 + 0.1 )
  {
    return 1;
  }
  *(_DWORD *)(a1 + 20) = &unk_806A660;
  return 0;
}

//----- (08058011) --------------------------------------------------------
unsigned int __cdecl sub_8058011(unsigned int a1, int a2)
{
  unsigned int result; // eax
  float v3; // [esp+20h] [ebp-4h]
  unsigned int v4; // [esp+2Ch] [ebp+8h]

  if ( *(_BYTE *)(a2 + 16) != 1 )
  {
    v3 = (long double)a1 / *(float *)(a2 + 8);
    if ( v3 >= 4294967300.0 )
      return 0;
    a1 = (signed __int64)v3;
  }
  v4 = sub_8057E7B(a1);
  if ( v4 <= 0x1FFFFFFF )
    result = v4;
  else
    result = 0;
  return result;
}

//----- (080580BE) --------------------------------------------------------
#error "8058106: call analysis failed (funcsize=109)"

//----- (0805838D) --------------------------------------------------------
void __cdecl sub_805838D(void *a1)
{
  _DWORD *v1; // ST1C_4
  _DWORD *v2; // ST1C_4
  _DWORD *i; // [esp+14h] [ebp-14h]
  _DWORD *j; // [esp+14h] [ebp-14h]
  _DWORD *ptr; // [esp+18h] [ebp-10h]
  _DWORD *ptra; // [esp+18h] [ebp-10h]
  _DWORD *ptrb; // [esp+18h] [ebp-10h]

  if ( *((_DWORD *)a1 + 8) && *((_DWORD *)a1 + 4) )
  {
    for ( i = *(_DWORD **)a1; *((_DWORD *)a1 + 1) > (unsigned int)i; i += 2 )
    {
      if ( *i )
      {
        for ( ptr = i; ptr; ptr = (_DWORD *)ptr[1] )
          (*((void (__cdecl **)(_DWORD))a1 + 8))(*ptr);
      }
    }
  }
  for ( j = *(_DWORD **)a1; *((_DWORD *)a1 + 1) > (unsigned int)j; j += 2 )
  {
    for ( ptra = (_DWORD *)j[1]; ptra; ptra = v1 )
    {
      v1 = (_DWORD *)ptra[1];
      free(ptra);
    }
  }
  for ( ptrb = (_DWORD *)*((_DWORD *)a1 + 9); ptrb; ptrb = v2 )
  {
    v2 = (_DWORD *)ptrb[1];
    free(ptrb);
  }
  free(*(void **)a1);
  free(a1);
}

//----- (08058479) --------------------------------------------------------
void *__cdecl sub_8058479(int a1)
{
  int v2; // [esp+1Ch] [ebp-Ch]

  if ( !*(_DWORD *)(a1 + 36) )
    return malloc(8u);
  v2 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(v2 + 4);
  return (void *)v2;
}

//----- (080584B4) --------------------------------------------------------
int __cdecl sub_80584B4(int a1, _DWORD *a2)
{
  int result; // eax

  *a2 = 0;
  a2[1] = *(_DWORD *)(a1 + 36);
  result = a1;
  *(_DWORD *)(a1 + 36) = a2;
  return result;
}

//----- (080584F7) --------------------------------------------------------
int __cdecl sub_80584F7(int a1, int a2, _DWORD *a3, char a4)
{
  unsigned __int8 (*v5)(void); // eax
  _DWORD *v6; // ecx
  int v7; // edx
  unsigned __int8 (__cdecl *v8)(int, int); // eax
  int v9; // [esp+0h] [ebp-38h]
  int v10; // [esp+4h] [ebp-34h]
  int v11; // [esp+8h] [ebp-30h]
  char v12; // [esp+Ch] [ebp-2Ch]
  int v13; // [esp+10h] [ebp-28h]
  int v14; // [esp+14h] [ebp-24h]
  _DWORD *i; // [esp+18h] [ebp-20h]
  _DWORD *v16; // [esp+1Ch] [ebp-1Ch]
  int v17; // [esp+20h] [ebp-18h]
  _DWORD *v18; // [esp+24h] [ebp-14h]
  int v19; // [esp+28h] [ebp-10h]
  _DWORD *v20; // [esp+2Ch] [ebp-Ch]

  v12 = a4;
  v16 = (_DWORD *)sub_8057AFD(a1, a2);
  *a3 = v16;
  if ( !*v16 )
    return 0;
  if ( *v16 == a2 || (v5 = *(unsigned __int8 (**)(void))(a1 + 28), v10 = *v16, v9 = a2, v5()) )
  {
    v19 = *v16;
    if ( v12 )
    {
      if ( v16[1] )
      {
        v20 = (_DWORD *)v16[1];
        v6 = v16;
        v7 = v20[1];
        *v16 = *v20;
        v6[1] = v7;
        sub_80584B4(a1, v20);
      }
      else
      {
        *v16 = 0;
      }
    }
    dword_80721F0 = (int)&locret_8058693;
    sub_8065D53(v9, v10, v11, *(_DWORD *)&v12, v13, v14, i, v16, v17, v18, v19);
  }
  for ( i = v16; ; i = (_DWORD *)i[1] )
  {
    if ( !i[1] )
      return 0;
    if ( *(_DWORD *)i[1] == a2 )
      break;
    v8 = *(unsigned __int8 (__cdecl **)(int, int))(a1 + 28);
    v10 = *(_DWORD *)i[1];
    if ( v8(a2, v10) )
      break;
  }
  v17 = *(_DWORD *)i[1];
  if ( v12 )
  {
    v18 = (_DWORD *)i[1];
    i[1] = v18[1];
    sub_80584B4(a1, v18);
  }
  return v17;
}
// 8057AFD: using guessed type int __cdecl sub_8057AFD(_DWORD, _DWORD);
// 8065D53: using guessed type int __stdcall sub_8065D53(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80721F0: using guessed type int dword_80721F0;

//----- (08058695) --------------------------------------------------------
#error "805872B: call analysis failed (funcsize=141)"

//----- (0805887E) --------------------------------------------------------
signed int __cdecl sub_805887E(int a1, unsigned int a2)
{
  signed int result; // eax
  unsigned int nmemb; // [esp+10h] [ebp-38h]
  char *v4; // [esp+18h] [ebp-30h]
  char *v5; // [esp+1Ch] [ebp-2Ch]
  unsigned int v6; // [esp+20h] [ebp-28h]
  int v7; // [esp+24h] [ebp-24h]
  int v8; // [esp+28h] [ebp-20h]
  int v9; // [esp+2Ch] [ebp-1Ch]
  int v10; // [esp+30h] [ebp-18h]
  int v11; // [esp+34h] [ebp-14h]
  int v12; // [esp+38h] [ebp-10h]
  int v13; // [esp+3Ch] [ebp-Ch]

  nmemb = sub_8058011(a2, *(_DWORD *)(a1 + 20));
  if ( !nmemb )
    return 0;
  if ( *(_DWORD *)(a1 + 8) == nmemb )
    return 1;
  v4 = (char *)calloc(nmemb, 8u);
  if ( !v4 )
    return 0;
  v6 = nmemb;
  v5 = &v4[8 * nmemb];
  v7 = 0;
  v8 = 0;
  v9 = *(_DWORD *)(a1 + 20);
  v10 = *(_DWORD *)(a1 + 24);
  v11 = *(_DWORD *)(a1 + 28);
  v12 = *(_DWORD *)(a1 + 32);
  v13 = *(_DWORD *)(a1 + 36);
  if ( (unsigned __int8)sub_8058695(&v4, a1, 0) )
  {
    free(*(void **)a1);
    *(_DWORD *)a1 = v4;
    *(_DWORD *)(a1 + 4) = v5;
    *(_DWORD *)(a1 + 8) = v6;
    *(_DWORD *)(a1 + 12) = v7;
    *(_DWORD *)(a1 + 36) = v13;
    result = 1;
  }
  else
  {
    *(_DWORD *)(a1 + 36) = v13;
    if ( (unsigned __int8)sub_8058695(a1, &v4, 1) ^ 1 || (unsigned __int8)sub_8058695(a1, &v4, 0) ^ 1 )
      abort();
    free(v4);
    result = 0;
  }
  return result;
}
// 8058695: using guessed type _DWORD __cdecl sub_8058695(_DWORD, _DWORD, _DWORD);

//----- (08058AE7) --------------------------------------------------------
#error "8058DA6: call analysis failed (funcsize=203)"

//----- (08058E55) --------------------------------------------------------
int __cdecl sub_8058E55(int a1, int a2)
{
  int v3; // [esp+18h] [ebp-10h]
  int v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_8058AE7(a1, a2, &v3);
  if ( v4 == -1 )
    return 0;
  if ( v4 )
    return a2;
  return v3;
}
// 8058AE7: using guessed type _DWORD __cdecl sub_8058AE7(_DWORD, _DWORD, _DWORD);

//----- (08058E94) --------------------------------------------------------
#error "8058EC5: call analysis failed (funcsize=16)"

//----- (08058ECA) --------------------------------------------------------
#error "805915A: positive sp value has been found (funcsize=78)"

//----- (0805915F) --------------------------------------------------------
int __cdecl sub_805915F(int a1, char *a2)
{
  int v2; // ebx

  v2 = *(_DWORD *)(a1 + 4) ^ sub_806456F(*(_BYTE **)a1, (unsigned int)a2);
  return sub_8065564(v2, *(_DWORD *)(a1 + 8), a2, 0);
}

//----- (08059336) --------------------------------------------------------
int __cdecl sub_8059336(int a1, int a2)
{
  return __PAIR__(*(_DWORD *)(a1 + 4), *(_DWORD *)(a2 + 8)) == __PAIR__(*(_DWORD *)(a2 + 4), *(_DWORD *)(a1 + 8))
      && __PAIR__(*(_DWORD *)(a1 + 12), *(_DWORD *)(a2 + 16)) == __PAIR__(*(_DWORD *)(a2 + 12), *(_DWORD *)(a1 + 16))
      && !strcmp(*(const char **)a1, *(const char **)a2);
}

//----- (080593F6) --------------------------------------------------------
void __cdecl sub_80593F6(void **a1)
{
  free(*a1);
  free(a1);
}

//----- (0805941C) --------------------------------------------------------
#error "805953E: call analysis failed (funcsize=107)"

//----- (08059584) --------------------------------------------------------
#error "80595D4: call analysis failed (funcsize=26)"

//----- (080595D9) --------------------------------------------------------
#error "80596EE: positive sp value has been found (funcsize=72)"

//----- (080596F1) --------------------------------------------------------
#error "8059F03: call analysis failed (funcsize=873)"

//----- (0805A64A) --------------------------------------------------------
__int64 sub_805A64A()
{
  __int64 result; // rax

  if ( getenv("POSIXLY_CORRECT") )
    LODWORD(result) = 512;
  else
    LODWORD(result) = 1024;
  HIDWORD(result) = 0;
  return result;
}

//----- (0805A678) --------------------------------------------------------
#error "805A69A: call analysis failed (funcsize=13)"

//----- (0805A69F) --------------------------------------------------------
#error "805A826: positive sp value has been found (funcsize=110)"

//----- (0805A827) --------------------------------------------------------
int __cdecl sub_805A827(int a1, int a2, __int64 *a3)
{
  int v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_805A678(a1, a3, a2);
  if ( !*a3 )
  {
    *a3 = sub_805A64A();
    v4 = 4;
  }
  return v4;
}
// 805A678: using guessed type int __cdecl sub_805A678(_DWORD, _DWORD, _DWORD);

//----- (0805A870) --------------------------------------------------------
char *__cdecl sub_805A870(__uid_t uid)
{
  const char *v1; // eax
  char *s; // ST1C_4
  size_t v3; // eax
  char *result; // eax
  char *i; // [esp+10h] [ebp-18h]
  char *v6; // [esp+14h] [ebp-14h]
  struct passwd *v7; // [esp+18h] [ebp-10h]

  v6 = 0;
  for ( i = (char *)dword_8073860; i; i = (char *)*((_DWORD *)i + 1) )
  {
    if ( *(_DWORD *)i == uid )
    {
      v6 = i;
      break;
    }
  }
  if ( !v6 )
  {
    v7 = getpwuid(uid);
    if ( v7 )
      v1 = v7->pw_name;
    else
      v1 = (const char *)&unk_806A7C4;
    s = (char *)v1;
    v3 = strlen(v1);
    v6 = (char *)sub_8061F5F((v3 + 16) & 0xFFFFFFF8);
    *(_DWORD *)v6 = uid;
    strcpy(v6 + 8, s);
    *((_DWORD *)v6 + 1) = dword_8073860;
    dword_8073860 = (int)v6;
  }
  if ( v6[8] )
    result = v6 + 8;
  else
    result = 0;
  return result;
}
// 8073860: using guessed type int dword_8073860;

//----- (0805AA7C) --------------------------------------------------------
char *__cdecl sub_805AA7C(__gid_t gid)
{
  char *v1; // eax
  size_t v2; // eax
  char *result; // eax
  int v4; // [esp+0h] [ebp-28h]
  int v5; // [esp+4h] [ebp-24h]
  int v6; // [esp+8h] [ebp-20h]
  int v7; // [esp+Ch] [ebp-1Ch]
  char *i; // [esp+10h] [ebp-18h]
  char *v9; // [esp+14h] [ebp-14h]
  struct group *v10; // [esp+18h] [ebp-10h]
  char *s; // [esp+1Ch] [ebp-Ch]
  int v12; // [esp+20h] [ebp-8h]
  int v13; // [esp+24h] [ebp-4h]
  int savedregs; // [esp+28h] [ebp+0h]

  v9 = 0;
  for ( i = (char *)dword_8073868; i; i = (char *)*((_DWORD *)i + 1) )
  {
    if ( *(_DWORD *)i == gid )
    {
      v9 = i;
      break;
    }
  }
  if ( !v9 )
  {
    v10 = getgrgid(gid);
    if ( v10 )
    {
      v1 = v10->gr_name;
      dword_80721F0 = (int)&loc_805AAF3;
      sub_8065D53(v4, v5, v6, v7, i, 0, v10, s, v12, v13, savedregs);
    }
    v2 = strlen((const char *)&unk_806A7C4);
    v9 = (char *)sub_8061F5F((v2 + 16) & 0xFFFFFFF8);
    *(_DWORD *)v9 = gid;
    strcpy(v9 + 8, (const char *)&unk_806A7C4);
    *((_DWORD *)v9 + 1) = dword_8073868;
    dword_8073868 = (int)v9;
  }
  if ( v9[8] )
    result = v9 + 8;
  else
    result = 0;
  return result;
}
// 8065D53: using guessed type int __stdcall sub_8065D53(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80721F0: using guessed type int dword_80721F0;
// 8073868: using guessed type int dword_8073868;

//----- (0805ACC8) --------------------------------------------------------
int __cdecl sub_805ACC8(__int64 a1, int a2)
{
  __int64 v3; // [esp+18h] [ebp-20h]
  int v4; // [esp+2Ch] [ebp-Ch]

  v3 = a1;
  v4 = a2 + 20;
  *(_BYTE *)(a2 + 20) = 0;
  if ( a1 >= 0 )
  {
    do
    {
      *(_BYTE *)--v4 = sub_80650FA(v3, HIDWORD(v3), 10, 0) + 48;
      v3 = sub_8064F0A(v3, 0xAu, 0);
    }
    while ( v3 );
  }
  else
  {
    do
    {
      *(_BYTE *)--v4 = 48 - sub_80650FA(v3, HIDWORD(v3), 10, 0);
      v3 = sub_8064F0A(v3, 0xAu, 0);
    }
    while ( v3 );
    *(_BYTE *)--v4 = 45;
  }
  return v4;
}
// 80650FA: using guessed type _DWORD __cdecl sub_80650FA(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0805AE16) --------------------------------------------------------
int __cdecl sub_805AE16(int a1)
{
  int v1; // ecx
  int v2; // edx
  int v3; // edx
  int v4; // eax
  int result; // eax
  int v6; // [esp+0h] [ebp-3Ch]
  int v7; // [esp+Ch] [ebp-30h]
  int v8; // [esp+10h] [ebp-2Ch]
  int v9; // [esp+18h] [ebp-24h]

  v9 = a1;
  *(&v6 - 7) = v7;
  *(&v6 - 3) = v8 + 20;
  *(_BYTE *)(*(&v6 - 3))-- = 0;
  *(_BYTE *)*(&v6 - 3) = sub_8065564(*(&v6 - 8), *(&v6 - 7), (char *)0xA, 0) + 48;
  *(&v6 - 8) = sub_80653AA(*(&v6 - 8), *(&v6 - 7), 10, 0);
  *(&v6 - 7) = v2;
  v3 = *(&v6 - 7);
  v4 = v3 | *(&v6 - 8);
  dword_8072288 = (int (__fastcall *)(_DWORD, _DWORD))&loc_805AE67;
  if ( v4 )
    result = dword_8072288(v1, v3);
  else
    result = *(&v6 - 3);
  return result;
}
// 80653AA: using guessed type _DWORD __cdecl sub_80653AA(_DWORD, _DWORD, _DWORD, _DWORD);
// 8072288: using guessed type int (__fastcall *dword_8072288)(_DWORD, _DWORD);

//----- (0805AEF2) --------------------------------------------------------
int __cdecl sub_805AEF2(wint_t *a1)
{
  unsigned __int8 v2; // [esp+1Bh] [ebp-Dh]
  wint_t *i; // [esp+1Ch] [ebp-Ch]

  v2 = 0;
  for ( i = a1; *i; ++i )
  {
    if ( !iswprint(*i) )
    {
      *i = 65533;
      v2 = 1;
    }
  }
  return v2;
}

//----- (0805AF35) --------------------------------------------------------
int __cdecl sub_805AF35(_DWORD *a1, unsigned int a2)
{
  int v3; // [esp+18h] [ebp-10h]
  int v4; // [esp+1Ch] [ebp-Ch]

  v3 = 0;
  while ( *a1 )
  {
    v4 = wcwidth(*a1);
    if ( v4 == -1 )
    {
      *a1 = 65533;
      v4 = 1;
    }
    if ( v4 + v3 > a2 )
      break;
    v3 += v4;
    ++a1;
  }
  *a1 = 0;
  return v3;
}
// 8049560: using guessed type int __cdecl wcwidth(_DWORD);

//----- (0805AFA1) --------------------------------------------------------
_BYTE *__usercall sub_805AFA1@<eax>(int edx0@<edx>, int ecx0@<ecx>, _BYTE *a1, unsigned int a2, int a3)
{
  _BYTE *v5; // eax
  int v6; // eax
  int savedregs; // [esp+0h] [ebp+0h]

  dword_8072224 = (int)&loc_805AFC7;
  sub_8065C0F(ecx0, edx0, savedregs);
  do
  {
    v5 = a1++;
    *v5 = 32;
    v6 = a3--;
  }
  while ( v6 && (unsigned int)a1 < a2 );
  *a1 = 0;
  return a1;
}
// 8072224: using guessed type int dword_8072224;

//----- (0805AFE7) --------------------------------------------------------
size_t __cdecl sub_805AFE7(char *s, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // ecx
  int v7; // edx
  int v8; // ecx
  void *v9; // eax
  void *v10; // eax
  int v11; // edx
  int v12; // ecx
  bool v13; // zf
  void *v14; // eax
  void *v15; // eax
  _BYTE *v16; // eax
  unsigned int v17; // eax
  int v18; // edx
  int v19; // ecx
  wchar_t *v21; // [esp+0h] [ebp-58h]
  size_t v22; // [esp+4h] [ebp-54h]
  int v23; // [esp+8h] [ebp-50h]
  int v24; // [esp+Ch] [ebp-4Ch]
  int v25; // [esp+10h] [ebp-48h]
  int v26; // [esp+14h] [ebp-44h]
  int v27; // [esp+18h] [ebp-40h]
  size_t v28; // [esp+1Ch] [ebp-3Ch]
  size_t size; // [esp+20h] [ebp-38h]
  void *ptr; // [esp+24h] [ebp-34h]
  wchar_t *pwcs; // [esp+28h] [ebp-30h]
  char *v32; // [esp+2Ch] [ebp-2Ch]
  size_t v33; // [esp+30h] [ebp-28h]
  size_t v34; // [esp+34h] [ebp-24h]
  unsigned int v35; // [esp+38h] [ebp-20h]
  int v36; // [esp+3Ch] [ebp-1Ch]
  int v37; // [esp+40h] [ebp-18h]
  size_t n; // [esp+44h] [ebp-14h]
  unsigned int v39; // [esp+48h] [ebp-10h]
  unsigned int v40; // [esp+4Ch] [ebp-Ch]
  int v41; // [esp+64h] [ebp+Ch]
  _BYTE *v42; // [esp+64h] [ebp+Ch]

  v28 = -1;
  size = strlen(s) + 1;
  ptr = 0;
  pwcs = 0;
  v32 = s;
  v33 = size - 1;
  v34 = size - 1;
  v35 = 0;
  HIWORD(v27) = 0;
  if ( !(a6 & 2) && __ctype_get_mb_cur_max() > 1 )
  {
    n = mbstowcs(0, s, 0);
    if ( n == -1 )
    {
      v9 = &loc_805B0CA;
      if ( !(a6 & 1) )
        v9 = &loc_805B0CF;
      dword_8072204 = (int)v9;
      sub_8065CE1(v8, v7, v21, v22, v23);
LABEL_21:
      if ( *(_DWORD *)a4 < v33 )
      {
        v33 = *(_DWORD *)a4;
        v34 = v33;
      }
      if ( *(_DWORD *)a4 > v33 )
        v35 = *(_DWORD *)a4 - v33;
      *(_DWORD *)a4 = v33;
      if ( a5 )
      {
        v15 = &loc_805B289;
        if ( a5 == 1 )
          v15 = &loc_805B29A;
        dword_80721F0 = (int)v15;
        sub_8065D53(v21, v22, v23, v24, v25, v26, v27, v28, size, ptr, pwcs);
        v36 = (v35 >> 1) + (v35 & 1);
        v37 = v35 >> 1;
      }
      else
      {
        v36 = 0;
        v37 = v35;
      }
      if ( a6 & 4 )
        v36 = 0;
      if ( a6 & 8 )
        v37 = 0;
      if ( a3 )
      {
        v39 = a3 - 1 + a2;
        v16 = sub_805AFA1(a3 - 1, v6, (_BYTE *)a2, v39, v36);
        v41 = (int)v16;
        v40 = v39 - (_DWORD)v16;
        v17 = v34;
        if ( v40 <= v34 )
          v17 = v40;
        v42 = (_BYTE *)mempcpy(v41, v32, v17);
        sub_805AFA1(v18, v19, v42, v39, v37);
      }
      v28 = v37 + v36 + v34;
      goto LABEL_39;
    }
    pwcs = (wchar_t *)malloc(4 * ++n);
    if ( !pwcs )
    {
      if ( a6 & 1 )
      {
        dword_80721F0 = (int)&loc_805B22F;
        sub_8065D53(v21, v22, v23, v24, v25, v26, v27, v28, size, ptr, pwcs);
      }
      goto LABEL_39;
    }
    if ( mbstowcs(pwcs, s, n) )
    {
      pwcs[n + 0x3FFFFFFF] = 0;
      HIBYTE(v27) = 1;
      BYTE2(v27) = sub_805AEF2((wint_t *)pwcs);
      v22 = n;
      v21 = pwcs;
      v33 = wcswidth();
    }
  }
  if ( !HIBYTE(v27) || !BYTE2(v27) && *(_DWORD *)a4 >= v33 )
    goto LABEL_21;
  if ( BYTE2(v27) )
    size = wcstombs(0, pwcs, 0) + 1;
  v10 = malloc(size);
  ptr = v10;
  v13 = v10 == 0;
  v14 = &loc_805B1E5;
  if ( !v13 )
    v14 = &loc_805B1F6;
  dword_8072204 = (int)v14;
  sub_8065CE1(v12, v11, v21, v22, v23);
  if ( a6 & 1 )
    goto LABEL_21;
LABEL_39:
  free(pwcs);
  free(ptr);
  return v28;
}
// 805AFE7: could not find valid save-restore pair for ebx
// 80499B0: using guessed type int __cdecl mempcpy(_DWORD, _DWORD, _DWORD);
// 80499C0: using guessed type int wcswidth(void);
// 8065D53: using guessed type int __stdcall sub_8065D53(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80721F0: using guessed type int dword_80721F0;
// 8072204: using guessed type int dword_8072204;

//----- (0805B4EF) --------------------------------------------------------
int __usercall sub_805B4EF@<eax>(int a1@<ebx>, char *s)
{
  strlen(s);
  return sub_805B518(a1, s);
}

//----- (0805B518) --------------------------------------------------------
signed int __usercall sub_805B518@<eax>(int a1@<ebx>, void *a2)
{
  void **v2; // ebp
  int v3; // eax
  bool v4; // sf
  unsigned __int8 v5; // of
  void *v6; // eax
  size_t v7; // eax
  int v8; // edx
  int v9; // ecx
  signed int result; // eax
  int v11; // edx
  int v12; // ecx
  int v13; // eax
  void *v14; // eax
  int v15; // edx
  int v16; // ecx
  bool v17; // zf
  void *v18; // eax
  _BYTE *v19; // eax
  unsigned int v20; // ecx
  int v21; // [esp-8h] [ebp-64h]
  int v22; // [esp-4h] [ebp-60h]
  void *s; // [esp+0h] [ebp-5Ch]
  int c; // [esp+4h] [ebp-58h]
  size_t n; // [esp+8h] [ebp-54h]
  mbstate_t *p; // [esp+Ch] [ebp-50h]
  int v27; // [esp+10h] [ebp-4Ch]
  int v28; // [esp+14h] [ebp-48h]
  int v29; // [esp+18h] [ebp-44h]
  void *v30; // [esp+1Ch] [ebp-40h]
  int v31; // [esp+20h] [ebp-3Ch]
  int v32; // [esp+24h] [ebp-38h]
  int v33; // [esp+28h] [ebp-34h]
  int v34; // [esp+2Ch] [ebp-30h]
  int v35; // [esp+30h] [ebp-2Ch]
  int v36; // [esp+34h] [ebp-28h]
  int v37; // [esp+38h] [ebp-24h]
  int v38; // [esp+3Ch] [ebp-20h]
  int v39; // [esp+40h] [ebp-1Ch]
  int v40; // [esp+44h] [ebp-18h]
  int v41; // [esp+48h] [ebp-14h]
  unsigned int v42; // [esp+4Ch] [ebp-10h]
  int v43; // [esp+50h] [ebp-Ch]
  int v44; // [esp+54h] [ebp-8h]
  int v45; // [esp+58h] [ebp-4h]

  v30 = a2;
  v42 = __readgsdword(0x14u);
  v2 = &s;
  *(&s - 10) = a2;
  *(&s - 7) = (char *)p + (_DWORD)*(&s - 10);
  *(&s - 9) = 0;
  if ( __ctype_get_mb_cur_max() <= 1 )
  {
    do
    {
      while ( 1 )
      {
        if ( *(&s - 10) >= *(&s - 7) )
        {
          result = (signed int)*(&s - 9);
          goto LABEL_48;
        }
        v19 = *(&s - 10);
        *(&s - 10) = v19 + 1;
        *((_BYTE *)&s - 45) = *v19;
        if ( !((*__ctype_b_loc())[*((unsigned __int8 *)&s - 45)] & 0x4000) )
          break;
        if ( *(&s - 9) == (void *)0x7FFFFFFF )
          goto LABEL_47;
        *(&s - 9) = (char *)*(&s - 9) + 1;
      }
      if ( v27 & 2 )
        goto LABEL_44;
    }
    while ( (*__ctype_b_loc())[*((unsigned __int8 *)&s - 45)] & 2 );
    if ( *(&s - 9) == (void *)0x7FFFFFFF )
    {
LABEL_47:
      result = 0x7FFFFFFF;
      goto LABEL_48;
    }
    *(&s - 9) = (char *)*(&s - 9) + 1;
    dword_80721F0 = (int)&loc_805B846;
    sub_8065D53(s, c, n, p, v27, v28, v29, v30, v31, v32, v33);
    v2 = &s;
LABEL_44:
    result = -1;
    goto LABEL_48;
  }
  dword_8072260 = (int)&loc_805B79C;
  sub_8065AB5(s, c, n, p, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45);
  v2 = &s;
  while ( 1 )
  {
    v3 = *(char *)*(&s - 10);
    if ( v3 <= 63 )
      break;
LABEL_8:
    if ( v3 < 65 || v3 > 95 && (unsigned int)(v3 - 97) > 0x1D )
      goto LABEL_12;
    *(&s - 10) = (char *)*(&s - 10) + 1;
    *(&s - 9) = (char *)*(&s - 9) + 1;
LABEL_34:
    if ( *(&s - 10) >= *(&s - 7) )
    {
      result = (signed int)*(&s - 9);
      goto LABEL_48;
    }
  }
  v5 = __OFSUB__(v3, 37);
  v4 = v3 - 37 < 0;
  v22 = *(char *)*(&s - 10);
  v21 = a1;
  v6 = &loc_805B5C8;
  if ( !(v4 ^ v5) )
    v6 = &loc_805B5F9;
  dword_80721DC = (int)v6;
  a1 = v21;
  if ( (unsigned int)(sub_8065DC3(s, c, n, p, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37) - 32) <= 3 )
  {
    dword_8072260 = (int)&loc_805B5F9;
    v3 = sub_8065AB5(
           s,
           c,
           n,
           p,
           v27,
           v28,
           v29,
           v30,
           v31,
           v32,
           v33,
           v34,
           v35,
           v36,
           v37,
           v38,
           v39,
           v40,
           v41,
           v42,
           v43,
           v44,
           v45);
    v2 = &s;
    goto LABEL_8;
  }
LABEL_12:
  memset(&s - 5, 0, 8u);
  while ( 1 )
  {
    v7 = (_BYTE *)*(&s - 7) - (_BYTE *)*(&s - 10);
    p = (mbstate_t *)(&s - 5);
    n = v7;
    v2 = &s;
    c = (int)*(&s - 10);
    *(&s - 8) = (void *)sub_8063055((wchar_t *)&s - 11, (char *)c, v7, (mbstate_t *)(&s - 5));
    if ( *(&s - 8) == (void *)-1 )
    {
      if ( !(v27 & 1) )
      {
        *(&s - 10) = (char *)*(&s - 10) + 1;
        *(&s - 9) = (char *)*(&s - 9) + 1;
        dword_8072204 = (int)&loc_805B79C;
        sub_8065CE1(v9, v8, s, c, n);
      }
      dword_80721F0 = (int)&loc_805B85C;
      sub_8065D53(s, c, n, p, v27, v28, v29, v30, v31, v32, v33);
      v2 = &s;
    }
    if ( *(&s - 8) == (void *)-2 )
      break;
    if ( !*(&s - 8) )
      *(&s - 8) = (void *)1;
    s = *(&s - 11);
    *(&s - 6) = (void *)wcwidth(s);
    if ( (signed int)*(&s - 6) >= 0 )
    {
      v13 = 0x7FFFFFFF - (_DWORD)*(&s - 9);
      v5 = __OFSUB__(v13, *(&s - 6));
      v4 = v13 - (signed int)*(&s - 6) < 0;
      v22 = 0x7FFFFFFF - (_DWORD)*(&s - 9);
      v21 = a1;
      v14 = &loc_805B726;
      if ( !(v4 ^ v5) )
        v14 = &loc_805B72B;
      dword_8072224 = (int)v14;
      v2 = (void **)&v21;
      sub_8065C0F(v12, v11, s);
      goto LABEL_47;
    }
    if ( v27 & 2 )
    {
      result = -1;
      goto LABEL_48;
    }
    s = *(&s - 11);
    if ( !iswcntrl((wint_t)s) )
    {
      v17 = *(&s - 9) == (void *)0x7FFFFFFF;
      v22 = 0;
      v21 = a1;
      v18 = &loc_805B76E;
      if ( !v17 )
        v18 = &loc_805B773;
      dword_8072224 = (int)v18;
      sub_8065C0F(v16, v15, s);
      goto LABEL_47;
    }
    *(&s - 10) = (char *)*(&s - 10) + (_DWORD)*(&s - 8);
    if ( mbsinit((const mbstate_t *)(&s - 5)) )
      goto LABEL_34;
  }
  if ( !(v27 & 1) )
  {
    *(&s - 10) = *(&s - 7);
    *(&s - 9) = (char *)*(&s - 9) + 1;
    goto LABEL_34;
  }
  result = -1;
LABEL_48:
  v20 = __readgsdword(0x14u) ^ (unsigned int)*(v2 - 3);
  return result;
}
// 805B518: could not find valid save-restore pair for ebx
// 8049560: using guessed type int __cdecl wcwidth(_DWORD);
// 8065AB5: using guessed type int __stdcall sub_8065AB5(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8065D53: using guessed type int __stdcall sub_8065D53(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8065DC3: using guessed type int __stdcall sub_8065DC3(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80721DC: using guessed type int dword_80721DC;
// 80721F0: using guessed type int dword_80721F0;
// 8072204: using guessed type int dword_8072204;
// 8072224: using guessed type int dword_8072224;
// 8072260: using guessed type int dword_8072260;

//----- (0805B86F) --------------------------------------------------------
void *__cdecl sub_805B86F(int a1, int a2, void *dest, int a4)
{
  _DWORD *v4; // eax
  _DWORD *v5; // eax
  unsigned int v7; // [esp+10h] [ebp-28h]
  unsigned int v8; // [esp+14h] [ebp-24h]
  unsigned int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]

  v12 = (unsigned int)a2 >> 1;
  v13 = a2 - ((unsigned int)a2 >> 1);
  v7 = 0;
  v8 = (unsigned int)a2 >> 1;
  v9 = (unsigned int)a2 >> 1;
  v14 = a2;
  sub_805BA55(a1 + 4 * ((unsigned int)a2 >> 1), v13, dest, a4);
  sub_805BA55(a1, (unsigned int)a2 >> 1, dest, a4);
  v10 = *(_DWORD *)a1;
  v11 = *(_DWORD *)(4 * ((unsigned int)a2 >> 1) + a1);
  while ( 1 )
  {
    while ( ((int (__cdecl *)(int, int))a4)(v10, v11) > 0 )
    {
      v5 = dest;
      dest = (char *)dest + 4;
      *v5 = v11;
      if ( ++v9 == v14 )
        return memcpy(dest, (const void *)(4 * v7 + a1), 4 * (v8 - v7));
      v11 = *(_DWORD *)(4 * v9 + a1);
    }
    v4 = dest;
    dest = (char *)dest + 4;
    *v4 = v10;
    if ( ++v7 == v8 )
      break;
    v10 = *(_DWORD *)(4 * v7 + a1);
  }
  v7 = v9;
  v8 = v14;
  return memcpy(dest, (const void *)(4 * v7 + a1), 4 * (v8 - v7));
}

//----- (0805BA55) --------------------------------------------------------
#error "805BC9E: call analysis failed (funcsize=179)"

//----- (0805BD1D) --------------------------------------------------------
int __cdecl sub_805BD1D(int a1, int a2, int a3)
{
  return sub_805BA55(a1, a2, (void *)(a1 + 4 * a2), a3);
}

//----- (0805BD61) --------------------------------------------------------
int __cdecl sub_805BD61(int a1, int a2, int a3)
{
  int v3; // eax

  while ( 1 )
  {
    v3 = a3--;
    if ( !v3 )
      break;
    *(_BYTE *)(a1 + a3) = tolower(*(unsigned __int8 *)(a2 + a3));
  }
  return a1;
}

//----- (0805BDA1) --------------------------------------------------------
int __cdecl sub_805BDA1(int a1, int a2, int a3)
{
  int v3; // eax

  while ( 1 )
  {
    v3 = a3--;
    if ( !v3 )
      break;
    *(_BYTE *)(a1 + a3) = toupper(*(unsigned __int8 *)(a2 + a3));
  }
  return a1;
}

//----- (0805BDE1) --------------------------------------------------------
#error "805BE70: call analysis failed (funcsize=44)"

//----- (0805BE75) --------------------------------------------------------
#error "805BE82: positive sp value has been found (funcsize=0)"

//----- (0805BE83) --------------------------------------------------------
#error "805BEA4: call analysis failed (funcsize=15)"

//----- (0805BEB7) --------------------------------------------------------
int sub_805BEB7()
{
  char v1; // [esp+2Fh] [ebp-9h]

  v1 = 0;
  return sub_805BF11(0);
}

//----- (0805BF11) --------------------------------------------------------
#error "805E4C2: call analysis failed (funcsize=2097)"

//----- (0805EFA1) --------------------------------------------------------
char *__cdecl sub_805EFA1(char *s)
{
  char *v1; // eax
  bool v2; // zf
  void *v3; // eax
  char *result; // eax
  int v5; // [esp+0h] [ebp-28h]
  int v6; // [esp+4h] [ebp-24h]
  int v7; // [esp+8h] [ebp-20h]
  int v8; // [esp+Ch] [ebp-1Ch]
  int v9; // [esp+10h] [ebp-18h]
  int v10; // [esp+14h] [ebp-14h]
  char *v11; // [esp+18h] [ebp-10h]
  char *s1; // [esp+1Ch] [ebp-Ch]
  char *s1a; // [esp+1Ch] [ebp-Ch]
  int v14; // [esp+20h] [ebp-8h]
  int v15; // [esp+24h] [ebp-4h]
  int savedregs; // [esp+28h] [ebp+0h]

  if ( !s )
  {
    fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
    abort();
  }
  v11 = strrchr(s, 47);
  if ( v11 )
    v1 = v11 + 1;
  else
    v1 = s;
  s1 = v1;
  if ( v1 - s > 6 )
  {
    v2 = strncmp(v1 - 7, "/.libs/", 7u) == 0;
    v3 = &loc_805F04B;
    if ( !v2 )
      v3 = &loc_805F081;
    dword_80721F0 = (int)v3;
    sub_8065D53(v5, v6, v7, v8, v9, v10, v11, s1, v14, v15, savedregs);
    s = s1a;
    if ( !strncmp(s1a, "lt-", 3u) )
    {
      s = s1a + 3;
      program_invocation_short_name = (int)(s1a + 3);
    }
  }
  dword_8073870 = (int)s;
  result = s;
  program_invocation_name = (int)s;
  return result;
}
// 8065D53: using guessed type int __stdcall sub_8065D53(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80721F0: using guessed type int dword_80721F0;
// 8072460: using guessed type int program_invocation_short_name;
// 8072470: using guessed type int program_invocation_name;
// 8073870: using guessed type int dword_8073870;

//----- (0805F093) --------------------------------------------------------
int __cdecl sub_805F093(int a1)
{
  int v2; // edx
  int v3; // ecx
  int v4; // ST18_4

  v4 = *__errno_location();
  dword_8072288 = (int (__fastcall *)(_DWORD, _DWORD))sub_805F0D1;
  if ( a1 )
    dword_8072288 = (int (__fastcall *)(_DWORD, _DWORD))&loc_805F0D6;
  return dword_8072288(v3, v2);
}
// 8072288: using guessed type int (__fastcall *dword_8072288)(_DWORD, _DWORD);

//----- (0805F0D1) --------------------------------------------------------
#error "805F0F7: positive sp value has been found (funcsize=0)"

//----- (0805F0F8) --------------------------------------------------------
int __cdecl sub_805F0F8(int *a1)
{
  int *v1; // eax

  if ( a1 )
    v1 = a1;
  else
    v1 = &dword_807387C;
  return *v1;
}
// 807387C: using guessed type int dword_807387C;

//----- (0805F10F) --------------------------------------------------------
int *__cdecl sub_805F10F(int *a1, int a2)
{
  int *result; // eax

  if ( a1 )
    result = a1;
  else
    result = &dword_807387C;
  *result = a2;
  return result;
}
// 807387C: using guessed type int dword_807387C;

//----- (0805F129) --------------------------------------------------------
#error "805F1BE: call analysis failed (funcsize=50)"

//----- (0805F1D1) --------------------------------------------------------
#error "805F20B: positive sp value has been found (funcsize=20)"

//----- (0805F238) --------------------------------------------------------
int *__cdecl sub_805F238(int *a1, int a2, int a3)
{
  int *result; // eax

  if ( !a1 )
    a1 = &dword_807387C;
  *a1 = 10;
  if ( !a2 || !a3 )
    abort();
  a1[10] = a2;
  result = a1;
  a1[11] = a3;
  return result;
}
// 807387C: using guessed type int dword_807387C;

//----- (0805F279) --------------------------------------------------------
#error "805F2FE: call analysis failed (funcsize=42)"

//----- (0805F303) --------------------------------------------------------
#error "805F34A: positive sp value has been found (funcsize=22)"

//----- (0805F350) --------------------------------------------------------
#error "805F3B0: call analysis failed (funcsize=54)"

//----- (0805F403) --------------------------------------------------------
#error "805F4E9: call analysis failed (funcsize=59)"

//----- (0805F4EE) --------------------------------------------------------
#error "8060208: positive sp value has been found (funcsize=1000)"

//----- (0806020C) --------------------------------------------------------
int __cdecl sub_806020C(int a1, int a2, int a3, int a4, int *a5)
{
  int *v5; // eax
  int *v6; // ST34_4
  int v7; // ST38_4
  int v8; // ST3C_4

  if ( a5 )
    v5 = a5;
  else
    v5 = &dword_807387C;
  v6 = v5;
  v7 = *__errno_location();
  v8 = sub_805F403(a1, a2, a3, a4, *v6, v6[1], v6 + 2, v6[10], v6[11]);
  *__errno_location() = v7;
  return v8;
}
// 805F403: using guessed type _DWORD __cdecl sub_805F403(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 807387C: using guessed type int dword_807387C;

//----- (08060337) --------------------------------------------------------
void *__cdecl sub_8060337(int a1, int a2, _DWORD *a3, int *a4)
{
  int *v4; // eax
  int *v5; // ST3C_4
  int v6; // ST40_4
  int v7; // ST44_4
  int size; // [esp+48h] [ebp-10h]
  void *v10; // [esp+4Ch] [ebp-Ch]

  if ( a4 )
    v4 = a4;
  else
    v4 = &dword_807387C;
  v5 = v4;
  v6 = *__errno_location();
  v7 = v5[1] | (a3 == 0);
  size = sub_805F403(0, 0, a1, a2, *v5, v7, v5 + 2, v5[10], v5[11]) + 1;
  v10 = sub_8061F4C(size);
  sub_805F403(v10, size, a1, a2, *v5, v7, v5 + 2, v5[10], v5[11]);
  *__errno_location() = v6;
  if ( a3 )
    *a3 = size - 1;
  return v10;
}
// 805F403: using guessed type _DWORD __cdecl sub_805F403(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 807387C: using guessed type int dword_807387C;

//----- (0806053E) --------------------------------------------------------
#error "8060673: call analysis failed (funcsize=82)"

//----- (08060678) --------------------------------------------------------
#error "8060878: positive sp value has been found (funcsize=78)"

//----- (0806087B) --------------------------------------------------------
int __cdecl sub_806087B(int a1)
{
  return sub_806053E(a1);
}
// 806053E: using guessed type _DWORD __cdecl sub_806053E(_DWORD);

//----- (080608A5) --------------------------------------------------------
int __cdecl sub_80608A5(int a1)
{
  return sub_806053E(a1);
}
// 806053E: using guessed type _DWORD __cdecl sub_806053E(_DWORD);

//----- (0806093B) --------------------------------------------------------
int __cdecl sub_806093B(int a1, int a2)
{
  char v3; // [esp+10h] [ebp-38h]

  sub_805F279(&v3, a2);
  return sub_806053E(a1);
}
// 805F279: using guessed type _DWORD __cdecl sub_805F279(_DWORD, _DWORD);
// 806053E: using guessed type _DWORD __cdecl sub_806053E(_DWORD);

//----- (08060979) --------------------------------------------------------
int __cdecl sub_8060979(int a1, int a2)
{
  char v3; // [esp+10h] [ebp-38h]

  sub_805F279(&v3, a2);
  return sub_806053E(a1);
}
// 805F279: using guessed type _DWORD __cdecl sub_805F279(_DWORD, _DWORD);
// 806053E: using guessed type _DWORD __cdecl sub_806053E(_DWORD);

//----- (080609B6) --------------------------------------------------------
int __cdecl sub_80609B6(int a1)
{
  return sub_806093B(0, a1);
}

//----- (08060A11) --------------------------------------------------------
#error "8060AAF: call analysis failed (funcsize=46)"

//----- (08060AC2) --------------------------------------------------------
#error "8060AFF: positive sp value has been found (funcsize=0)"

//----- (08060B00) --------------------------------------------------------
#error "8060B1D: call analysis failed (funcsize=11)"

//----- (08060B22) --------------------------------------------------------
int sub_8060B22()
{
  int v1; // [esp+0h] [ebp-18h]
  char v2; // [esp+Ch] [ebp-Ch]

  *((_BYTE *)&v1 - 12) = v2;
  return sub_8060A11(*((char *)&v1 - 12), -1, *((char *)&v1 - 12));
}
// 8060B22: could not find valid save-restore pair for ebp
// 8060A11: using guessed type _DWORD __cdecl sub_8060A11(_DWORD, _DWORD, _DWORD);

//----- (08060B5E) --------------------------------------------------------
int __cdecl sub_8060B5E(int a1)
{
  return sub_8060B00(a1, 58);
}
// 8060B00: using guessed type int __cdecl sub_8060B00(_DWORD, _DWORD);

//----- (08060B9B) --------------------------------------------------------
int __cdecl sub_8060B9B(int a1, int a2, int a3)
{
  int v4; // [esp-4h] [ebp-7Ch]
  int v5; // [esp+0h] [ebp-78h]
  int v6; // [esp+4h] [ebp-74h]
  int *v7; // [esp+8h] [ebp-70h]
  int v8; // [esp+10h] [ebp-68h]
  int v9; // [esp+14h] [ebp-64h]
  int v10; // [esp+18h] [ebp-60h]
  int v11; // [esp+1Ch] [ebp-5Ch]
  int v12; // [esp+20h] [ebp-58h]
  int v13; // [esp+24h] [ebp-54h]
  int v14; // [esp+28h] [ebp-50h]
  int v15; // [esp+2Ch] [ebp-4Ch]
  int v16; // [esp+30h] [ebp-48h]
  int v17; // [esp+34h] [ebp-44h]
  int v18; // [esp+38h] [ebp-40h]
  int v19; // [esp+3Ch] [ebp-3Ch]
  int v20; // [esp+40h] [ebp-38h]
  int v21; // [esp+44h] [ebp-34h]
  int v22; // [esp+48h] [ebp-30h]
  int v23; // [esp+4Ch] [ebp-2Ch]
  int v24; // [esp+50h] [ebp-28h]
  int v25; // [esp+54h] [ebp-24h]
  int v26; // [esp+58h] [ebp-20h]
  int v27; // [esp+5Ch] [ebp-1Ch]
  int v28; // [esp+60h] [ebp-18h]
  int v29; // [esp+64h] [ebp-14h]
  int v30; // [esp+68h] [ebp-10h]
  int v31; // [esp+6Ch] [ebp-Ch]

  sub_805F279(&v8, a2);
  v20 = v8;
  v21 = v9;
  v22 = v10;
  v23 = v11;
  v24 = v12;
  v25 = v13;
  v26 = v14;
  v27 = v15;
  v28 = v16;
  v29 = v17;
  v30 = v18;
  v31 = v19;
  v6 = 1;
  sub_805F129(&v4 - 14, 58);
  v7 = &v20;
  v6 = -1;
  v5 = a3;
  return sub_806053E(a1);
}
// 805F129: using guessed type _DWORD __cdecl sub_805F129(_DWORD, _DWORD);
// 805F279: using guessed type _DWORD __cdecl sub_805F279(_DWORD, _DWORD);
// 806053E: using guessed type _DWORD __cdecl sub_806053E(_DWORD);

//----- (08060C8C) --------------------------------------------------------
#error "8060C9B: call analysis failed (funcsize=11)"

//----- (08060CAE) --------------------------------------------------------
int __cdecl sub_8060CAE(int a1, int a2, int a3, int a4, int a5)
{
  return sub_8060D01(a4, a3, a4, a5, -1);
}

//----- (08060D01) --------------------------------------------------------
int __cdecl sub_8060D01(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [esp+0h] [ebp-48h]
  int v7; // [esp+4h] [ebp-44h]
  int v8; // [esp+8h] [ebp-40h]
  int *v9; // [esp+Ch] [ebp-3Ch]
  int v10; // [esp+10h] [ebp-38h]
  int v11; // [esp+14h] [ebp-34h]
  int v12; // [esp+18h] [ebp-30h]
  int v13; // [esp+1Ch] [ebp-2Ch]
  int v14; // [esp+20h] [ebp-28h]
  int v15; // [esp+24h] [ebp-24h]
  int v16; // [esp+28h] [ebp-20h]
  int v17; // [esp+2Ch] [ebp-1Ch]
  int v18; // [esp+30h] [ebp-18h]
  int v19; // [esp+34h] [ebp-14h]
  int v20; // [esp+38h] [ebp-10h]
  int v21; // [esp+3Ch] [ebp-Ch]

  v10 = dword_807387C;
  v11 = dword_8073880;
  v12 = dword_8073884;
  v13 = dword_8073888;
  v14 = dword_807388C;
  v15 = dword_8073890;
  v16 = dword_8073894;
  v17 = dword_8073898;
  v18 = dword_807389C;
  v19 = dword_80738A0;
  v20 = dword_80738A4;
  v21 = dword_80738A8;
  sub_805F238(&v6 - 14, a2, a3);
  v9 = &v10;
  v8 = a5;
  v7 = a4;
  return sub_806053E(a1);
}
// 806053E: using guessed type _DWORD __cdecl sub_806053E(_DWORD);
// 807387C: using guessed type int dword_807387C;
// 8073880: using guessed type int dword_8073880;
// 8073884: using guessed type int dword_8073884;
// 8073888: using guessed type int dword_8073888;
// 807388C: using guessed type int dword_807388C;
// 8073890: using guessed type int dword_8073890;
// 8073894: using guessed type int dword_8073894;
// 8073898: using guessed type int dword_8073898;
// 807389C: using guessed type int dword_807389C;
// 80738A0: using guessed type int dword_80738A0;
// 80738A4: using guessed type int dword_80738A4;
// 80738A8: using guessed type int dword_80738A8;

//----- (08060E4B) --------------------------------------------------------
int __cdecl sub_8060E4B(int a1)
{
  return sub_806053E(a1);
}
// 806053E: using guessed type _DWORD __cdecl sub_806053E(_DWORD);

//----- (08060EC6) --------------------------------------------------------
int __cdecl sub_8060EC6(int a1)
{
  return sub_8060E4B(a1);
}

//----- (08060EE8) --------------------------------------------------------
int sub_8060EE8()
{
  return sub_8060EC6(0);
}

//----- (08060F03) --------------------------------------------------------
_BOOL4 __cdecl sub_8060F03(void *src, void *a2)
{
  size_t v2; // ST20_4
  bool v3; // al
  int *v4; // eax
  int *v5; // eax
  bool v6; // al
  bool v8; // [esp+15h] [ebp-E3h]
  char *s1; // [esp+18h] [ebp-E0h]
  char *s2; // [esp+1Ch] [ebp-DCh]
  size_t n; // [esp+24h] [ebp-D4h]
  void *ptr; // [esp+28h] [ebp-D0h]
  void *v13; // [esp+2Ch] [ebp-CCh]
  __int64 v14; // [esp+30h] [ebp-C8h]
  __int64 v15; // [esp+88h] [ebp-70h]
  __int64 v16; // [esp+90h] [ebp-68h]
  __int64 v17; // [esp+E8h] [ebp-10h]

  s1 = (char *)sub_8056BAD(src);
  s2 = (char *)sub_8056BAD(a2);
  v2 = sub_8056C3A(s1);
  n = sub_8056C3A(s2);
  v3 = v2 == n && !memcmp(s1, s2, n);
  v8 = 0;
  if ( v3 )
  {
    ptr = sub_806454B(src);
    v13 = sub_806454B(a2);
    if ( sub_8065842((int)ptr, (int)&v14) )
    {
      v4 = __errno_location();
      error(1, *v4, "%s", ptr);
    }
    if ( sub_8065842((int)v13, (int)&v16) )
    {
      v5 = __errno_location();
      error(1, *v5, "%s", v13);
    }
    v6 = v15 == v17 && v14 == v16;
    v8 = v6;
    free(ptr);
    free(v13);
  }
  return v8;
}
// 8056BAD: using guessed type _DWORD __cdecl sub_8056BAD(_DWORD);

//----- (08061103) --------------------------------------------------------
void sub_8061103()
{
  ;
}

//----- (08061150) --------------------------------------------------------
signed int sub_8061150()
{
  *__errno_location() = 95;
  return -1;
}

//----- (08061168) --------------------------------------------------------
signed int sub_8061168()
{
  *__errno_location() = 95;
  return -1;
}

//----- (080612A2) --------------------------------------------------------
#error "80612B9: call analysis failed (funcsize=14)"

//----- (080612CC) --------------------------------------------------------
#error "80612DF: positive sp value has been found (funcsize=0)"

//----- (080612E2) --------------------------------------------------------
_DWORD *__userpurge sub_80612E2@<eax>(_DWORD *a1, int a2)
{
  int v2; // edx

  v2 = *(_DWORD *)(a2 + 84);
  *a1 = *(_DWORD *)(a2 + 80);
  a1[1] = v2;
  return a1;
}

//----- (0806130D) --------------------------------------------------------
#error "8061345: call analysis failed (funcsize=18)"

//----- (0806134A) --------------------------------------------------------
#error "806135A: positive sp value has been found (funcsize=0)"

//----- (080613ED) --------------------------------------------------------
int __cdecl sub_80613ED(int a1, int a2, int a3, int a4)
{
  if ( a1 < a3 )
    return -1;
  if ( a1 > a3 )
    return 1;
  return a2 - a4;
}

//----- (0806148F) --------------------------------------------------------
#error "80619B1: call analysis failed (funcsize=485)"

//----- (08061CE3) --------------------------------------------------------
int __cdecl sub_8061CE3(FILE *stream, int a2, int a3, int a4, int a5)
{
  bool v5; // zf
  void *v6; // eax
  int v8; // [esp-4h] [ebp-5Ch]
  int v9; // [esp+0h] [ebp-58h]
  int v10; // [esp+4h] [ebp-54h]
  int v11; // [esp+8h] [ebp-50h]
  int v12; // [esp+Ch] [ebp-4Ch]
  int v13; // [esp+10h] [ebp-48h]
  int v14; // [esp+14h] [ebp-44h]
  int v15; // [esp+18h] [ebp-40h]
  int v16; // [esp+1Ch] [ebp-3Ch]
  int v17; // [esp+20h] [ebp-38h]
  int v18; // [esp+24h] [ebp-34h]
  int v19; // [esp+28h] [ebp-30h]
  int v20; // [esp+2Ch] [ebp-2Ch]
  int v21; // [esp+30h] [ebp-28h]
  int v22; // [esp+34h] [ebp-24h]
  int v23; // [esp+38h] [ebp-20h]

  v18 = 0;
  *(&v19 + v18) = *(_DWORD *)a5;
  v5 = *(&v19 + v18) == 0;
  v8 = *(&v19 + v18);
  v6 = &loc_8061D32;
  if ( !v5 )
    v6 = &loc_8061CF2;
  dword_80721DC = (int)v6;
  sub_8065DC3(v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23);
  return sub_806148F(stream, a2, a3, a4, (int)(&v9 - 12), v18);
}
// 8065DC3: using guessed type int __stdcall sub_8065DC3(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80721DC: using guessed type int dword_80721DC;

//----- (08061D92) --------------------------------------------------------
int sub_8061D92(FILE *stream, int a2, int a3, int a4, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a4);
  return sub_8061CE3(stream, a2, a3, a4, (int)va);
}

//----- (08061E52) --------------------------------------------------------
void *__cdecl sub_8061E52(unsigned int a1, unsigned int a2)
{
  if ( 0x7FFFFFFF / a2 < a1 )
    sub_80620AF();
  return sub_8061F5F(a2 * a1);
}

//----- (08061E80) --------------------------------------------------------
void *__cdecl sub_8061E80(void *ptr, int a2, int a3)
{
  if ( 0x7FFFFFFFu / a3 < a2 )
    sub_80620AF();
  return sub_8061F89(ptr, a3 * a2);
}

//----- (08061EB5) --------------------------------------------------------
void *__cdecl sub_8061EB5(void *ptr, int a2, int a3)
{
  unsigned int v4; // [esp+1Ch] [ebp-Ch]

  v4 = *(_DWORD *)a2;
  if ( ptr )
  {
    if ( 0x55555554u / a3 <= v4 )
      sub_80620AF();
    v4 += (v4 >> 1) + 1;
  }
  else
  {
    if ( !v4 )
      v4 = (0x40u / a3 == 0) + 0x40u / a3;
    if ( 0x7FFFFFFFu / a3 < v4 )
      sub_80620AF();
  }
  *(_DWORD *)a2 = v4;
  return sub_8061F89(ptr, a3 * v4);
}

//----- (08061F4C) --------------------------------------------------------
void *__cdecl sub_8061F4C(size_t size)
{
  return sub_8061F5F(size);
}

//----- (08061F5F) --------------------------------------------------------
void *__cdecl sub_8061F5F(size_t size)
{
  void *v2; // [esp+1Ch] [ebp-Ch]

  v2 = malloc(size);
  if ( !v2 && size )
    sub_80620AF();
  return v2;
}

//----- (08061F89) --------------------------------------------------------
void *__cdecl sub_8061F89(void *ptr, size_t size)
{
  void *result; // eax
  void *ptra; // [esp+20h] [ebp+8h]

  if ( size || !ptr )
  {
    ptra = realloc(ptr, size);
    if ( !ptra )
    {
      if ( size )
        sub_80620AF();
    }
    result = ptra;
  }
  else
  {
    free(ptr);
    result = 0;
  }
  return result;
}

//----- (08061FD8) --------------------------------------------------------
void *__cdecl sub_8061FD8(void *ptr, int a2)
{
  return sub_8061EB5(ptr, a2, 1);
}

//----- (08062061) --------------------------------------------------------
void *__cdecl sub_8062061(void *src, size_t n)
{
  void *v2; // eax

  v2 = sub_8061F5F(n);
  return memcpy(v2, src, n);
}

//----- (0806208A) --------------------------------------------------------
void *__cdecl sub_806208A(char *s)
{
  size_t v1; // eax

  v1 = strlen(s);
  return sub_8062061(s, v1 + 1);
}

//----- (080620AF) --------------------------------------------------------
void __noreturn sub_80620AF()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (080620E8) --------------------------------------------------------
#error "8062247: call analysis failed (funcsize=116)"

//----- (08062314) --------------------------------------------------------
char *sub_8062314()
{
  char *v0; // eax
  bool v1; // zf
  void *v2; // eax
  char *v4; // [esp+1Ch] [ebp-Ch]

  v0 = getcwd(0, 0);
  v4 = v0;
  v1 = v0 == 0;
  v2 = &loc_8062360;
  if ( !v1 )
    v2 = &loc_8062371;
  dword_807224C = (int)v2;
  sub_8065B27();
  if ( *__errno_location() == 12 )
    sub_80620AF();
  return v4;
}
// 807224C: using guessed type int dword_807224C;

//----- (08062376) --------------------------------------------------------
#error "806243C: call analysis failed (funcsize=78)"

//----- (0806247A) --------------------------------------------------------
int __cdecl sub_806247A(unsigned int *a1, unsigned int a2)
{
  if ( 0xFFFFFFFF / a2 < *a1 )
  {
    *a1 = -1;
    dword_807224C = (int)&loc_80624F1;
    sub_8065B27();
  }
  *a1 *= a2;
  return 0;
}
// 807224C: using guessed type int dword_807224C;

//----- (080624F3) --------------------------------------------------------
int __cdecl sub_80624F3(unsigned int *a1, unsigned int a2, int a3)
{
  int v3; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; i |= sub_806247A(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}

//----- (08062529) --------------------------------------------------------
int __usercall sub_8062529@<eax>(int a1@<edx>, int a2@<ecx>, char *nptr, int a4, int base, int a6, char *s)
{
  void *v7; // eax
  int result; // eax
  int v9; // edx
  int v10; // ecx
  void *v11; // eax
  void *v12; // eax
  int v13; // edx
  int v14; // ecx
  int v15; // eax
  int v16; // [esp+0h] [ebp-48h]
  int v17; // [esp+0h] [ebp-48h]
  int v18; // [esp+0h] [ebp-48h]
  int v19; // [esp+0h] [ebp-48h]
  int v20; // [esp+4h] [ebp-44h]
  int v21; // [esp+4h] [ebp-44h]
  int v22; // [esp+4h] [ebp-44h]
  int v23; // [esp+4h] [ebp-44h]
  int v24; // [esp+8h] [ebp-40h]
  int v25; // [esp+8h] [ebp-40h]
  int v26; // [esp+8h] [ebp-40h]
  int v27; // [esp+8h] [ebp-40h]
  int v28; // [esp+Ch] [ebp-3Ch]
  int v29; // [esp+Ch] [ebp-3Ch]
  int v30; // [esp+10h] [ebp-38h]
  int v31; // [esp+10h] [ebp-38h]
  int v32; // [esp+14h] [ebp-34h]
  int v33; // [esp+14h] [ebp-34h]
  int v34; // [esp+18h] [ebp-30h]
  int v35; // [esp+18h] [ebp-30h]
  int v36; // [esp+1Ch] [ebp-2Ch]
  int v37; // [esp+1Ch] [ebp-2Ch]
  int v38; // [esp+20h] [ebp-28h]
  int v39; // [esp+20h] [ebp-28h]
  unsigned int v40; // [esp+24h] [ebp-24h]
  int v41; // [esp+28h] [ebp-20h]
  char *v42; // [esp+2Ch] [ebp-1Ch]
  unsigned int v43; // [esp+30h] [ebp-18h]
  int v44; // [esp+34h] [ebp-14h]
  int v45; // [esp+38h] [ebp-10h]
  char **endptr; // [esp+3Ch] [ebp-Ch]

  v41 = 0;
  if ( base < 0 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoul");
  v7 = &loc_806255B;
  if ( base > 36 )
    v7 = &loc_8062563;
  dword_8072204 = (int)v7;
  sub_8065CE1(a2, a1, v16, v20, v24);
  if ( !a4 )
  {
    dword_80721DC = (int)&loc_80625A4;
    sub_8065DC3(v17, v21, v25, v28, v30, v32, v34, v36, v38, v40, v41, v42, v43, v44, v45);
  }
  endptr = (char **)a4;
  *__errno_location() = 0;
  v42 = nptr;
  HIBYTE(v36) = *nptr;
  while ( (*__ctype_b_loc())[HIBYTE(v36)] & 0x2000 )
    HIBYTE(v36) = *++v42;
  if ( HIBYTE(v36) == 45 )
    return 4;
  v40 = strtoul(nptr, endptr, base);
  if ( *endptr == nptr )
  {
    v11 = &loc_8062643;
    if ( !s )
      v11 = &loc_8062676;
    dword_8072204 = (int)v11;
    sub_8065CE1(v10, v9, v18, v22, v26);
    if ( !**endptr || !strchr(s, **endptr) )
      return 4;
    v40 = 1;
  }
  else if ( *__errno_location() )
  {
    if ( *__errno_location() != 34 )
      return 4;
    v41 = 1;
  }
  if ( !s )
  {
    *(_DWORD *)a6 = v40;
    return v41;
  }
  v12 = &loc_80626E3;
  if ( !**endptr )
    v12 = &loc_806299A;
  dword_80721DC = (int)v12;
  sub_8065DC3(v18, v22, v26, v28, v30, v32, v34, v36, v38, v40, v41, v42, v43, v44, v45);
  v43 = 1024;
  v44 = 1;
  if ( !strchr(s, **endptr) )
  {
    *(_DWORD *)a6 = v40;
    return v41 | 2;
  }
  switch ( **endptr )
  {
    case 69:
    case 71:
    case 75:
    case 77:
    case 80:
    case 84:
    case 89:
    case 90:
    case 103:
    case 107:
    case 109:
    case 116:
      if ( !strchr(s, 48) )
        goto LABEL_39;
      v15 = (*endptr)[1];
      switch ( v15 )
      {
        case 68:
          goto LABEL_38;
        case 105:
          if ( (*endptr)[2] == 66 )
          {
            v44 += 2;
            dword_80721F0 = (int)&loc_80627C4;
            sub_8065D53(v19, v23, v27, v29, v31, v33, v35, v37, v39, v40, v41);
          }
          dword_8072204 = (int)&loc_80627C4;
          sub_8065CE1(v14, v13, v19, v23, v27);
          goto LABEL_38;
        case 66:
LABEL_38:
          v43 = 1000;
          ++v44;
          break;
      }
LABEL_39:
      switch ( **endptr )
      {
        case 66:
          v45 = sub_806247A(&v40, 0x400u);
          goto LABEL_53;
        case 69:
          v45 = sub_80624F3(&v40, v43, 6);
          goto LABEL_53;
        case 71:
        case 103:
          v45 = sub_80624F3(&v40, v43, 3);
          goto LABEL_53;
        case 75:
        case 107:
          v45 = sub_80624F3(&v40, v43, 1);
          goto LABEL_53;
        case 77:
        case 109:
          v45 = sub_80624F3(&v40, v43, 2);
          goto LABEL_53;
        case 80:
          v45 = sub_80624F3(&v40, v43, 5);
          goto LABEL_53;
        case 84:
        case 116:
          v45 = sub_80624F3(&v40, v43, 4);
          goto LABEL_53;
        case 89:
          v45 = sub_80624F3(&v40, v43, 8);
          goto LABEL_53;
        case 90:
          v45 = sub_80624F3(&v40, v43, 7);
          goto LABEL_53;
        case 98:
          v45 = sub_806247A(&v40, 0x200u);
          goto LABEL_53;
        case 99:
          v45 = 0;
          goto LABEL_53;
        case 119:
          v45 = sub_806247A(&v40, 2u);
LABEL_53:
          v41 |= v45;
          *endptr += v44;
          if ( **endptr )
            v41 |= 2u;
          *(_DWORD *)a6 = v40;
          result = v41;
          break;
        default:
          *(_DWORD *)a6 = v40;
          result = v41 | 2;
          break;
      }
      return result;
    default:
      goto LABEL_39;
  }
}
// 8062529: could not find valid save-restore pair for ebx
// 8065D53: using guessed type int __stdcall sub_8065D53(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8065DC3: using guessed type int __stdcall sub_8065DC3(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80721DC: using guessed type int dword_80721DC;
// 80721F0: using guessed type int dword_80721F0;
// 8072204: using guessed type int dword_8072204;

//----- (080629A7) --------------------------------------------------------
void __cdecl sub_80629A7(int a1, int a2, int a3, int a4, int a5, int status)
{
  char *v6; // eax
  const char *v7; // [esp+Ch] [ebp-2Ch]
  char *v8; // [esp+10h] [ebp-28h]
  int v9; // [esp+14h] [ebp-24h]
  char v10; // [esp+1Ch] [ebp-1Ch]
  char v11; // [esp+22h] [ebp-16h]
  char v12; // [esp+23h] [ebp-15h]
  const char *v13; // [esp+24h] [ebp-14h]
  char *msgid; // [esp+28h] [ebp-10h]
  char *v15; // [esp+2Ch] [ebp-Ch]

  v10 = a3;
  v13 = "--";
  if ( (unsigned int)a1 > 3 )
  {
    if ( a1 != 4 )
      goto LABEL_6;
    msgid = "invalid %s%s argument '%s'";
  }
  else if ( (unsigned int)a1 >= 2 )
  {
    msgid = "invalid suffix in %s%s argument '%s'";
  }
  else
  {
    if ( a1 != 1 )
LABEL_6:
      abort();
    msgid = "%s%s argument '%s' too large";
  }
  if ( a2 >= 0 )
  {
    v15 = *(char **)(16 * a2 + a4);
  }
  else
  {
    v13 -= a2;
    v11 = v10;
    v12 = 0;
    v15 = &v11;
  }
  v6 = gettext(msgid);
  v9 = a5;
  v8 = v15;
  v7 = v13;
  error(status, 0, v6, v13, v15, a5);
}

//----- (08062A8D) --------------------------------------------------------
void __cdecl __noreturn sub_8062A8D(int a1, int a2, char a3, int a4, int a5)
{
  sub_80629A7(a1, a2, a3, a4, a5, status);
  abort();
}

//----- (08062AF0) --------------------------------------------------------
signed int __cdecl sub_8062AF0(unsigned int *a1, signed int a2)
{
  unsigned __int64 v2; // rcx
  int v3; // edx
  signed int result; // eax
  int v5; // esi
  unsigned __int64 v6; // rax

  LODWORD(v2) = sub_80653AA(-1, -1, a2, a2 >> 31);
  HIDWORD(v2) = v3;
  if ( v2 >= *(_QWORD *)a1 )
  {
    v5 = a2 * a1[1] + *a1 * (a2 >> 31);
    v6 = *a1 * (unsigned __int64)(unsigned int)a2;
    *a1 = v6;
    a1[1] = v5 + HIDWORD(v6);
    result = 0;
  }
  else
  {
    *a1 = -1;
    a1[1] = -1;
    result = 1;
  }
  return result;
}
// 80653AA: using guessed type _DWORD __cdecl sub_80653AA(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08062BCC) --------------------------------------------------------
int __cdecl sub_8062BCC(unsigned int *a1, signed int a2, int a3)
{
  int v3; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; ; i |= sub_8062AF0(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}

//----- (08062C02) --------------------------------------------------------
int __cdecl sub_8062C02(char *nptr, int a2, int base, int a4, char *s)
{
  char **v5; // eax
  int result; // eax
  int v7; // edx
  bool v8; // zf
  int v9; // edx
  int v10; // ecx
  void *v11; // eax
  int v12; // edx
  int v13; // edx
  int v14; // [esp+0h] [ebp-48h]
  int v15; // [esp+4h] [ebp-44h]
  int v16; // [esp+8h] [ebp-40h]
  unsigned __int8 i; // [esp+1Bh] [ebp-2Dh]
  char v18; // [esp+1Ch] [ebp-2Ch]
  int v19; // [esp+20h] [ebp-28h]
  char *v20; // [esp+24h] [ebp-24h]
  int v21; // [esp+28h] [ebp-20h]
  int v22; // [esp+2Ch] [ebp-1Ch]
  char **endptr; // [esp+34h] [ebp-14h]
  uintmax_t v24; // [esp+38h] [ebp-10h]

  v19 = 0;
  if ( base < 0 || base > 36 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoumax");
  if ( a2 )
    v5 = (char **)a2;
  else
    v5 = (char **)&v18;
  endptr = v5;
  *__errno_location() = 0;
  v20 = nptr;
  for ( i = *nptr; (*__ctype_b_loc())[i] & 0x2000; i = *v20 )
    ++v20;
  if ( i == 45 )
    return 4;
  v24 = strtoumax(nptr, endptr, base);
  if ( *endptr == nptr )
  {
    if ( !s || !**endptr || !strchr(s, **endptr) )
      return 4;
    v24 = 1LL;
  }
  else if ( *__errno_location() )
  {
    if ( *__errno_location() != 34 )
      return 4;
    v19 = 1;
  }
  if ( s )
  {
    if ( **endptr )
    {
      v21 = 1024;
      v22 = 1;
      v8 = strchr(s, **endptr) == 0;
      v11 = &loc_8062DB5;
      if ( !v8 )
        v11 = &loc_8062DCE;
      dword_8072204 = (int)v11;
      sub_8065CE1(v10, v9, v14, v15, v16);
      v12 = HIDWORD(v24);
      *(_DWORD *)a4 = v24;
      *(_DWORD *)(a4 + 4) = v12;
      result = v19 | 2;
    }
    else
    {
      v13 = HIDWORD(v24);
      *(_DWORD *)a4 = v24;
      *(_DWORD *)(a4 + 4) = v13;
      result = v19;
    }
  }
  else
  {
    v7 = HIDWORD(v24);
    *(_DWORD *)a4 = v24;
    *(_DWORD *)(a4 + 4) = v7;
    result = v19;
  }
  return result;
}
// 8072204: using guessed type int dword_8072204;

//----- (08063055) --------------------------------------------------------
size_t __cdecl sub_8063055(wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  int v4; // ecx
  wchar_t v5; // edx
  int v7; // [esp+0h] [ebp-28h]
  int v8; // [esp+4h] [ebp-24h]
  int v9; // [esp+8h] [ebp-20h]
  char v10; // [esp+18h] [ebp-10h]
  size_t v11; // [esp+1Ch] [ebp-Ch]

  if ( !pwc )
    pwc = (wchar_t *)&v10;
  v11 = mbrtowc(pwc, s, n, p);
  if ( v11 > 0xFFFFFFFD && n && (unsigned __int8)sub_8057895(0) ^ 1 )
  {
    v5 = (unsigned __int8)*s;
    *pwc = v5;
    dword_8072204 = (int)&locret_80630DA;
    sub_8065CE1(v4, v5, v7, v8, v9);
  }
  return v11;
}
// 8072204: using guessed type int dword_8072204;

//----- (080630DC) --------------------------------------------------------
int __cdecl sub_80630DC(int a1, int a2)
{
  int result; // eax

  if ( *(_BYTE *)(a1 + 40) & 1 )
    result = (*(int (__cdecl **)(_DWORD, int))(a1 + 28))(*(_DWORD *)(a1 + 36), a2);
  else
    result = (*(int (__cdecl **)(int))(a1 + 28))(a2);
  return result;
}

//----- (0806311A) --------------------------------------------------------
int __cdecl sub_806311A(int a1, int a2)
{
  if ( *(_BYTE *)(a1 + 40) & 1 )
  {
    (*(void (__cdecl **)(_DWORD, int))(a1 + 32))(*(_DWORD *)(a1 + 36), a2);
    dword_807224C = (int)&locret_806316B;
    sub_8065B27();
  }
  return (*(int (__cdecl **)(int))(a1 + 32))(a2);
}
// 807224C: using guessed type int dword_807224C;

//----- (0806316D) --------------------------------------------------------
signed int __cdecl sub_806316D(int a1, signed int a2, signed int a3)
{
  int v4; // [esp+4h] [ebp-24h]
  int v5; // [esp+18h] [ebp-10h]
  _DWORD *v6; // [esp+1Ch] [ebp-Ch]

  if ( !a3 )
    a3 = 8;
  if ( !a2 )
  {
    v5 = 32;
    a2 = 4064;
  }
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 24) = a3 - 1;
  v4 = *(_DWORD *)a1;
  *(_DWORD *)(a1 + 4) = sub_80630DC(a1, v4);
  v6 = *(_DWORD **)(a1 + 4);
  if ( !v6 )
    obstack_alloc_failed_handler();
  *(_DWORD *)(a1 + 8) = ((unsigned int)&v6[a3 / 4u + 1] + 3) & -a3;
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 8);
  *v6 = (char *)v6 + *(_DWORD *)a1;
  *(_DWORD *)(a1 + 16) = *v6;
  v6[1] = 0;
  *(_BYTE *)(a1 + 40) &= 0xFDu;
  *(_BYTE *)(a1 + 40) &= 0xFBu;
  return 1;
}
// 80724A0: using guessed type int (*obstack_alloc_failed_handler)(void);

//----- (080632AC) --------------------------------------------------------
signed int __cdecl sub_80632AC(int a1, signed int a2, signed int a3, int a4, int a5)
{
  *(_DWORD *)(a1 + 28) = a4;
  *(_DWORD *)(a1 + 32) = a5;
  *(_BYTE *)(a1 + 40) &= 0xFEu;
  return sub_806316D(a1, a2, a3);
}

//----- (08063395) --------------------------------------------------------
#error "8063516: call analysis failed (funcsize=119)"

//----- (0806351B) --------------------------------------------------------
#error "8063522: call analysis failed (funcsize=55)"

//----- (080635D4) --------------------------------------------------------
#error "8063604: positive sp value has been found (funcsize=15)"

//----- (080637B2) --------------------------------------------------------
int __fastcall sub_80637B2(int a1, int a2, int a3, int a4)
{
  dword_8072288 = (int (__fastcall *)(_DWORD, _DWORD))sub_8063833;
  if ( (a3 == 0) ^ (a4 == 0) )
  {
    dword_8072288 = (int (__fastcall *)(_DWORD, _DWORD))sub_8063833;
    if ( a3 >= 0 )
    {
      dword_8072288 = (int (__fastcall *)(_DWORD, _DWORD))sub_8063833;
      if ( a4 >= 0 )
        dword_8072288 = (int (__fastcall *)(_DWORD, _DWORD))&loc_8063838;
    }
  }
  return dword_8072288(a1, a3 == 0);
}
// 8063833: using guessed type int sub_8063833();
// 8072288: using guessed type int (__fastcall *dword_8072288)(_DWORD, _DWORD);

//----- (08063833) --------------------------------------------------------
#error "806383C: positive sp value has been found (funcsize=0)"

//----- (0806383D) --------------------------------------------------------
#error "8063890: call analysis failed (funcsize=32)"

//----- (080638A3) --------------------------------------------------------
#error "8063921: positive sp value has been found (funcsize=43)"

//----- (08063924) --------------------------------------------------------
char *__cdecl sub_8063924(void *dest, void *src, size_t n)
{
  char *result; // eax

  memcpy(dest, src, n);
  result = (char *)dest + n;
  *((_BYTE *)dest + n) = 0;
  return result;
}

//----- (08063950) --------------------------------------------------------
int __cdecl sub_8063950(char *s)
{
  int v1; // edx
  int v2; // ecx
  void *v4; // eax
  int v5; // [esp+0h] [ebp-28h]
  int v6; // [esp+4h] [ebp-24h]
  int v7; // [esp+8h] [ebp-20h]
  int v8; // [esp+Ch] [ebp-1Ch]
  int v9; // [esp+10h] [ebp-18h]
  int v10; // [esp+14h] [ebp-14h]
  int v11; // [esp+18h] [ebp-10h]
  int v12; // [esp+1Ch] [ebp-Ch]
  int v13; // [esp+20h] [ebp-8h]
  int v14; // [esp+24h] [ebp-4h]
  int savedregs; // [esp+28h] [ebp+0h]

  dword_8072288 = (int (__fastcall *)(_DWORD, _DWORD))sub_80639A4;
  v4 = &loc_8063983;
  if ( !s )
    v4 = &loc_804EDAE;
  dword_80721F0 = (int)v4;
  sub_8065D53(v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, savedregs);
  strlen(s);
  dword_8072288 = (int (__fastcall *)(_DWORD, _DWORD))&loc_80639A9;
  return ((int (__fastcall *)(int, int))loc_80639A9)(v2, v1);
}
// 8065D53: using guessed type int __stdcall sub_8065D53(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80721F0: using guessed type int dword_80721F0;
// 8072288: using guessed type int (__fastcall *dword_8072288)(_DWORD, _DWORD);

//----- (080639A4) --------------------------------------------------------
#error "8063A8A: positive sp value has been found (funcsize=58)"

//----- (08063A8B) --------------------------------------------------------
#error "8063AF0: call analysis failed (funcsize=150)"

//----- (08063C99) --------------------------------------------------------
void *__cdecl sub_8063C99(void *ptr)
{
  void *v1; // eax
  void *result; // eax
  void *v3; // ST24_4

  v1 = &loc_8063CD2;
  if ( ptr == (void *)1 )
    v1 = &locret_8063CF3;
  dword_807224C = (int)v1;
  result = (void *)sub_8065B27();
  while ( ptr )
  {
    v3 = *(void **)ptr;
    free(ptr);
    result = v3;
    ptr = v3;
  }
  return result;
}
// 807224C: using guessed type int dword_807224C;

//----- (08063CF5) --------------------------------------------------------
char *sub_8063CF5()
{
  return getenv("TZ");
}

//----- (08063D09) --------------------------------------------------------
int __cdecl sub_8063D09(char *value)
{
  int result; // eax

  if ( value )
    result = setenv("TZ", value, 1);
  else
    result = unsetenv("TZ");
  return result;
}

//----- (08063D40) --------------------------------------------------------
signed int __cdecl sub_8063D40(int a1)
{
  char *v1; // eax

  if ( *(_BYTE *)(a1 + 4) )
    v1 = (char *)(a1 + 5);
  else
    v1 = 0;
  if ( sub_8063D09(v1) )
    return 0;
  tzset();
  return 1;
}

//----- (08063D7D) --------------------------------------------------------
#error "8063DC8: call analysis failed (funcsize=70)"

//----- (08063E5D) --------------------------------------------------------
int __cdecl sub_8063E5D(void *ptr)
{
  unsigned __int8 v2; // [esp+1Bh] [ebp-Dh]
  int v3; // [esp+1Ch] [ebp-Ch]

  if ( ptr == (void *)1 )
    return 1;
  v3 = *__errno_location();
  v2 = sub_8063D40((int)ptr);
  if ( v2 ^ 1 )
    v3 = *__errno_location();
  sub_8063C99(ptr);
  *__errno_location() = v3;
  return v2;
}

//----- (08063EBC) --------------------------------------------------------
struct tm *__cdecl sub_8063EBC(int a1, time_t *timer, struct tm *tp)
{
  bool v4; // zf
  int v5; // edx
  int v6; // ecx
  void *v7; // eax
  int v8; // edx
  int v9; // ecx
  int v10; // [esp+0h] [ebp-28h]
  int v11; // [esp+0h] [ebp-28h]
  int v12; // [esp+4h] [ebp-24h]
  int v13; // [esp+4h] [ebp-24h]
  int v14; // [esp+8h] [ebp-20h]
  int v15; // [esp+8h] [ebp-20h]
  bool v16; // [esp+1Bh] [ebp-Dh]
  void *ptr; // [esp+1Ch] [ebp-Ch]

  if ( !a1 )
    return gmtime_r(timer, tp);
  ptr = (void *)sub_8063D7D(a1);
  if ( ptr )
  {
    v4 = localtime_r(timer, tp) == 0;
    v7 = &loc_8063F26;
    if ( v4 )
      v7 = &loc_8063F43;
    dword_8072204 = (int)v7;
    sub_8065CE1(v6, v5, v10, v12, v14);
    v16 = (unsigned __int8)sub_8063A8B(a1, tp) != 0;
    if ( (unsigned __int8)sub_8063E5D(ptr) )
    {
      if ( v16 )
      {
        dword_8072204 = (int)&locret_8063F83;
        sub_8065CE1(v9, v8, v11, v13, v15);
      }
    }
  }
  return 0;
}
// 8063A8B: using guessed type _DWORD __cdecl sub_8063A8B(_DWORD, _DWORD);
// 8063D7D: using guessed type _DWORD __cdecl sub_8063D7D(_DWORD);
// 8072204: using guessed type int dword_8072204;

//----- (08063F85) --------------------------------------------------------
int __cdecl sub_8063F85(int a1, struct tm *tp)
{
  int result; // eax
  void *v3; // eax
  bool v4; // zf
  void *v5; // eax
  int v6; // edx
  int v7; // ecx
  void *v8; // eax
  int v9; // [esp+0h] [ebp-58h]
  int v10; // [esp+0h] [ebp-58h]
  int v11; // [esp+4h] [ebp-54h]
  int v12; // [esp+4h] [ebp-54h]
  int v13; // [esp+8h] [ebp-50h]
  int v14; // [esp+8h] [ebp-50h]
  int v15; // [esp+Ch] [ebp-4Ch]
  int v16; // [esp+10h] [ebp-48h]
  int v17; // [esp+14h] [ebp-44h]
  time_t timer; // [esp+18h] [ebp-40h]
  void *ptr; // [esp+1Ch] [ebp-3Ch]
  time_t v20; // [esp+20h] [ebp-38h]
  struct tm v21; // [esp+24h] [ebp-34h]
  int v22; // [esp+50h] [ebp-8h]
  int v23; // [esp+54h] [ebp-4h]
  int savedregs; // [esp+58h] [ebp+0h]

  if ( !a1 )
    return timegm(tp);
  v3 = (void *)sub_8063D7D(a1);
  ptr = v3;
  v4 = v3 == 0;
  v5 = &loc_8063FDE;
  if ( v4 )
    v5 = &loc_8064073;
  dword_8072260 = (int)v5;
  sub_8065AB5(
    v9,
    v11,
    v13,
    v15,
    v16,
    v17,
    timer,
    ptr,
    v20,
    v21.tm_sec,
    v21.tm_min,
    v21.tm_hour,
    v21.tm_mday,
    v21.tm_mon,
    v21.tm_year,
    v21.tm_wday,
    v21.tm_yday,
    v21.tm_isdst,
    v21.tm_gmtoff,
    v21.tm_zone,
    v22,
    v23,
    savedregs);
  timer = mktime(tp);
  v20 = -1;
  if ( timer != -1 )
    goto LABEL_16;
  v4 = localtime_r(&timer, &v21) == 0;
  v8 = &loc_806402A;
  if ( v4 )
    v8 = &loc_806405F;
  dword_8072204 = (int)v8;
  sub_8065CE1(v7, v6, v10, v12, v14);
  if ( sub_806383D(tp, &v21) )
  {
LABEL_16:
    if ( (unsigned __int8)sub_8063A8B(a1, tp) ^ 1 )
      timer = v20;
  }
  if ( (unsigned __int8)sub_8063E5D(ptr) )
    result = timer;
  else
    result = -1;
  return result;
}
// 8063F85: could not find valid save-restore pair for ebx
// 806383D: using guessed type _DWORD __cdecl sub_806383D(_DWORD, _DWORD);
// 8063A8B: using guessed type _DWORD __cdecl sub_8063A8B(_DWORD, _DWORD);
// 8063D7D: using guessed type _DWORD __cdecl sub_8063D7D(_DWORD);
// 8065AB5: using guessed type int __stdcall sub_8065AB5(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8072204: using guessed type int dword_8072204;
// 8072260: using guessed type int dword_8072260;

//----- (08064275) --------------------------------------------------------
int __cdecl sub_8064275(int a1, char a2)
{
  return __ROR4__(a1, a2);
}

//----- (08064465) --------------------------------------------------------
int __cdecl sub_8064465(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // esi
  unsigned __int8 *v3; // ebx
  unsigned __int8 v5; // [esp+1Eh] [ebp-Ah]
  unsigned __int8 v6; // [esp+1Fh] [ebp-9h]

  v2 = a1;
  v3 = a2;
  if ( a1 == a2 )
    return 0;
  do
  {
    v5 = sub_8055F0A(*v2);
    v6 = sub_8055F0A(*v3);
    if ( !v5 )
      break;
    ++v2;
    ++v3;
  }
  while ( v5 == v6 );
  return v5 - v6;
}

//----- (080644CA) --------------------------------------------------------
int __cdecl sub_80644CA(FILE *fp)
{
  bool v1; // ST1E_1
  bool v3; // [esp+1Dh] [ebp-Bh]
  bool v4; // [esp+1Fh] [ebp-9h]

  v3 = __fpending(fp) != 0;
  v1 = ferror_unlocked(fp) != 0;
  v4 = sub_8064C22(fp) != 0;
  if ( !v1 && (!v4 || !v3 && *__errno_location() == 9) )
    return 0;
  if ( v4 != 1 )
    *__errno_location() = 0;
  return -1;
}

//----- (0806454B) --------------------------------------------------------
void *__cdecl sub_806454B(void *src)
{
  void *v2; // [esp+1Ch] [ebp-Ch]

  v2 = sub_8056B12(src);
  if ( !v2 )
    sub_80620AF();
  return v2;
}

//----- (0806456F) --------------------------------------------------------
int __cdecl sub_806456F(_BYTE *a1, unsigned int a2)
{
  _BYTE *i; // [esp+8h] [ebp-8h]
  unsigned int v4; // [esp+Ch] [ebp-4h]

  v4 = 0;
  for ( i = a1; *i; ++i )
    v4 = __ROR4__(v4, 23) + (char)*i;
  return v4 % a2;
}

//----- (080645B5) --------------------------------------------------------
#error "8064723: call analysis failed (funcsize=114)"

//----- (08064B56) --------------------------------------------------------
char *sub_8064B56()
{
  bool v0; // zf
  int v1; // edx
  int v2; // ecx
  void *v3; // eax
  size_t v4; // ST08_4
  char *v5; // ST24_4
  int v7; // [esp+0h] [ebp-28h]
  int v8; // [esp+4h] [ebp-24h]
  int v9; // [esp+8h] [ebp-20h]
  char *s1; // [esp+18h] [ebp-10h]
  char *s2; // [esp+1Ch] [ebp-Ch]

  v0 = nl_langinfo(14) == 0;
  v3 = &loc_8064B8A;
  if ( !v0 )
    v3 = &loc_8064B91;
  dword_8072204 = (int)v3;
  sub_8065CE1(v2, v1, v7, v8, v9);
  s1 = (char *)&unk_806B673;
  for ( s2 = (char *)sub_80645B5(v4); *s2; s2 = &v5[strlen(v5) + 1] )
  {
    if ( !strcmp((const char *)&unk_806B673, s2) || *s2 == 42 && !s2[1] )
    {
      s1 = &s2[strlen(s2) + 1];
      break;
    }
    v5 = &s2[strlen(s2) + 1];
  }
  if ( !*s1 )
    s1 = "ASCII";
  return s1;
}
// 8072204: using guessed type int dword_8072204;

//----- (08064C22) --------------------------------------------------------
int __cdecl sub_8064C22(FILE *stream)
{
  int v2; // eax
  __int64 v3; // rax
  int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]

  v4 = 0;
  if ( fileno(stream) < 0 )
    return fclose(stream);
  if ( !__freading(stream) || (v2 = fileno(stream), LODWORD(v3) = lseek64(v2, 0, 0, 1), v3 != -1) )
  {
    if ( sub_8064D1E(stream) )
      v4 = *__errno_location();
  }
  v5 = fclose(stream);
  if ( v4 )
  {
    *__errno_location() = v4;
    v5 = -1;
  }
  return v5;
}
// 8049A70: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08064CE5) --------------------------------------------------------
int __cdecl sub_8064CE5(FILE *stream)
{
  int result; // eax

  result = stream->_flags & 0x100;
  if ( result )
    result = sub_8064D5E(stream, 0, 0, 1);
  return result;
}

//----- (08064D1E) --------------------------------------------------------
int __cdecl sub_8064D1E(FILE *fp)
{
  if ( !fp || !__freading(fp) )
    return fflush(fp);
  sub_8064CE5(fp);
  return fflush(fp);
}

//----- (08064D5E) --------------------------------------------------------
int __cdecl sub_8064D5E(FILE *stream, int a2, int a3, int a4)
{
  int v5; // ecx
  char *v6; // edx
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  int v10; // eax
  int v11; // edx
  int v12; // [esp+18h] [ebp-20h]
  int v13; // [esp+1Ch] [ebp-1Ch]
  int v14; // [esp+28h] [ebp-10h]
  int v15; // [esp+2Ch] [ebp-Ch]

  v12 = a2;
  v13 = a3;
  v6 = stream->_IO_read_end;
  v7 = stream->_IO_read_ptr;
  dword_8072288 = (int (__fastcall *)(_DWORD, _DWORD))sub_8064EE4;
  if ( v6 == v7 )
  {
    v6 = stream->_IO_write_ptr;
    v8 = stream->_IO_write_base;
    dword_8072288 = (int (__fastcall *)(_DWORD, _DWORD))sub_8064EE4;
    if ( v6 == v8 )
    {
      v9 = stream->_IO_save_base;
      dword_8072288 = (int (__fastcall *)(_DWORD, _DWORD))sub_8064EE4;
      if ( !v9 )
      {
        v10 = fileno(stream);
        v14 = lseek64(v10, v12, v13, a4);
        v15 = v11;
        v6 = (char *)~v11;
        dword_8072288 = (int (__fastcall *)(_DWORD, _DWORD))sub_8064E7E;
        if ( !((unsigned int)v6 | ~v14) )
          dword_8072288 = (int (__fastcall *)(_DWORD, _DWORD))&locret_8064F04;
      }
    }
  }
  return dword_8072288(v5, v6);
}
// 8049A70: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8064EE4: using guessed type int __cdecl sub_8064EE4(int, int, int);
// 8072288: using guessed type int (__fastcall *dword_8072288)(_DWORD, _DWORD);

//----- (08064E7E) --------------------------------------------------------
int __usercall sub_8064E7E@<eax>(int a1@<ebp>)
{
  int v2; // ecx
  int v3; // [esp-10h] [ebp-10h]
  int v4; // [esp-Ch] [ebp-Ch]

  **(_DWORD **)(a1 + 8) &= 0xFFFFFFEF;
  v2 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(v2 + 76) = v3;
  *(_DWORD *)(v2 + 80) = v4;
  dword_8072288 = (int (__fastcall *)(_DWORD, _DWORD))&locret_8064F04;
  return ((int (__fastcall *)(int))locret_8064F04)(v2);
}
// 8072288: using guessed type int (__fastcall *dword_8072288)(_DWORD, _DWORD);

//----- (08064EE4) --------------------------------------------------------
#error "8064F05: positive sp value has been found (funcsize=0)"

//----- (08064F0A) --------------------------------------------------------
signed __int64 __cdecl sub_8064F0A(__int64 a1, unsigned int a2, signed int a3)
{
  int v3; // edx
  unsigned int v4; // ecx
  unsigned int v5; // esi
  unsigned int v6; // edi
  unsigned int v7; // ebp
  unsigned int v8; // eax
  int v9; // ecx
  unsigned int v10; // edx
  int v11; // ebp
  int v12; // ecx
  signed __int64 result; // rax
  void *v14; // eax
  unsigned int v15; // esi
  int v16; // edx
  unsigned int v17; // ecx
  int v18; // edi
  unsigned int v19; // edx
  unsigned int v20; // esi
  unsigned int v21; // ebp
  int v22; // esi
  unsigned __int64 v23; // rax
  int v24; // [esp+0h] [ebp-1Ch]
  unsigned int v25; // [esp+4h] [ebp-18h]
  unsigned int v26; // [esp+8h] [ebp-14h]
  unsigned int v27; // [esp+Ch] [ebp-10h]

  v3 = a1;
  v24 = 0;
  v25 = a2;
  v4 = HIDWORD(a1);
  if ( a1 < 0 )
  {
    v3 = -(signed int)a1;
    v5 = v25;
    v6 = a3;
    v4 = (unsigned __int64)-a1 >> 32;
    v24 = -1;
    if ( a3 >= 0 )
      goto LABEL_3;
  }
  else
  {
    v5 = v25;
    v6 = a3;
    if ( a3 >= 0 )
      goto LABEL_3;
  }
  v5 = -v5;
  v24 = ~v24;
  v6 = (unsigned __int64)-(signed __int64)__PAIR__(v6, v5) >> 32;
LABEL_3:
  v7 = v4;
  v26 = v3;
  v8 = v6;
  v9 = v3;
  v25 = v5;
  if ( v6 )
  {
    if ( v6 <= v7 )
    {
      _BitScanReverse(&v6, v6);
      v18 = v6 ^ 0x1F;
      if ( v18 )
      {
        v27 = v25 >> (32 - v18);
        v27 |= v8 << v18;
        v25 <<= v18;
        v19 = (unsigned int)&v24 >> (32 - v18);
        v20 = (unsigned int)&v24 | (v26 >> (32 - v18));
        v21 = __PAIR__(v19, v20) % v27;
        v22 = __PAIR__(v19, v20) / v27;
        v23 = v25 * (unsigned __int64)(unsigned int)v22;
        v25 = HIDWORD(v23);
        if ( v21 < HIDWORD(v23) || v26 << v18 < (unsigned int)v23 && v21 == v25 )
        {
          v12 = v22 - 1;
          v11 = 0;
        }
        else
        {
          v12 = v22;
          v11 = 0;
        }
        goto LABEL_8;
      }
      if ( v25 <= v26 || v8 < v7 )
      {
        v11 = 0;
        v12 = 1;
        goto LABEL_8;
      }
    }
    v11 = 0;
    v12 = 0;
    goto LABEL_8;
  }
  if ( v5 <= v7 )
  {
    v14 = &loc_8064FDA;
    if ( v5 )
      v14 = &loc_8064FE5;
    dword_807224C = (int)v14;
    sub_8065B27();
    v15 = 1 / v5;
    v16 = v7 % v15;
    v11 = v7 / v15;
    v12 = __PAIR__((unsigned int)v16, v17) / v15;
  }
  else
  {
    v10 = v7;
    v11 = 0;
    v12 = __PAIR__(v10, v9) / v5;
  }
LABEL_8:
  result = __PAIR__(v11, v12);
  if ( v24 )
    result = -__PAIR__(v11, v12);
  return result;
}
// 807224C: using guessed type int dword_807224C;

//----- (080650FA) --------------------------------------------------------
#error "8065287: call analysis failed (funcsize=127)"

//----- (080653AA) --------------------------------------------------------
#error "80654CA: call analysis failed (funcsize=118)"

//----- (08065564) --------------------------------------------------------
#error "806565F: call analysis failed (funcsize=141)"

//----- (08065813) --------------------------------------------------------
int __cdecl sub_8065813(int a1)
{
  return __cxa_atexit(a1, 0, dword_80722A0);
}
// 80497B0: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 80722A0: using guessed type int dword_80722A0;

//----- (08065842) --------------------------------------------------------
int __cdecl sub_8065842(int a1, int a2)
{
  return __xstat64(3, a1, a2);
}
// 8049AE0: using guessed type int __cdecl __xstat64(_DWORD, _DWORD, _DWORD);

//----- (08065871) --------------------------------------------------------
int __cdecl sub_8065871(int a1, int a2)
{
  return __fxstat64(3, a1, a2);
}
// 8049730: using guessed type int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD);

//----- (080658A0) --------------------------------------------------------
int __cdecl sub_80658A0(int a1, int a2)
{
  return __lxstat64(3, a1, a2);
}
// 8049AF0: using guessed type int __cdecl __lxstat64(_DWORD, _DWORD, _DWORD);

//----- (08065AB5) --------------------------------------------------------
#error "8065ABB: positive sp value has been found (funcsize=0)"

//----- (08065B27) --------------------------------------------------------
#error "8065B2D: positive sp value has been found (funcsize=0)"

//----- (08065B9D) --------------------------------------------------------
#error "8065BA3: positive sp value has been found (funcsize=0)"

//----- (08065C0F) --------------------------------------------------------
#error "8065C15: positive sp value has been found (funcsize=0)"

//----- (08065CE1) --------------------------------------------------------
#error "8065CE7: positive sp value has been found (funcsize=0)"

//----- (08065D53) --------------------------------------------------------
#error "8065D59: positive sp value has been found (funcsize=0)"

//----- (08065DC3) --------------------------------------------------------
#error "8065DC9: positive sp value has been found (funcsize=0)"

//----- (08065DE0) --------------------------------------------------------
int (**sub_8065DE0())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_8071ED8;
  v1 = &off_8071EDC - off_8071ED8;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_8071ED8[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 8071ED8: using guessed type int (*off_8071ED8[2])();
// 8071EDC: using guessed type int (*off_8071EDC)();

//----- (08065E44) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 121 decompilation failure(s) on 410 function(s)"
