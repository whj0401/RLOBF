/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8049480();
// int unsetenv(const char *name);
// int raise(int sig);
// int strcmp(const char *s1, const char *s2);
// int __cdecl open64(_DWORD, _DWORD); weak
// int putc_unlocked(int c, FILE *stream);
// struct passwd *getpwuid(__uid_t uid);
// int printf(const char *format, ...);
// void longjmp(struct __jmp_buf_tag env[1], int val);
// int fflush(FILE *stream);
// int sigprocmask(int how, const sigset_t *set, sigset_t *oset);
// int dirfd(DIR *dirp);
// int wcwidth(void); weak
// void *memmove(void *dest, const void *src, size_t n);
// int _setjmp(struct __jmp_buf_tag env[1]);
// void free(void *ptr);
// uintmax_t strtoumax(const char *nptr, char **endptr, int base);
// void *memcpy(void *dest, const void *src, size_t n);
// int mbsinit(const mbstate_t *ps);
// int clock_gettime(clockid_t clock_id, struct timespec *tp);
// int fclose(FILE *stream);
// int getc_unlocked(FILE *stream);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// __sighandler_t signal(int sig, __sighandler_t handler);
// int memcmp(const void *s1, const void *s2, size_t n);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// char *dcgettext(const char *domainname, const char *msgid, int category);
// time_t mktime(struct tm *tp);
// struct tm *localtime_r(const time_t *timer, struct tm *tp);
// int sigismember(const sigset_t *set, int signo);
// int fflush_unlocked(FILE *stream);
// char *textdomain(const char *domainname);
// ssize_t readlink(const char *path, char *buf, size_t len);
// int fnmatch(const char *pattern, const char *name, int flags);
// int iswprint(wint_t wc);
// int ioctl(int fd, unsigned int request, ...);
// int ferror_unlocked(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD); weak
// void tzset(void);
// size_t __ctype_get_mb_cur_max(void);
// char *strcpy(char *dest, const char *src);
// size_t __fpending(FILE *fp);
// size_t wcstombs(char *s, const wchar_t *pwcs, size_t n);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int gethostname(char *name, size_t len);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// void error(int status, int errnum, const char *format, ...);
// int strcoll(const char *s1, const char *s2);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// time_t timegm(struct tm *tp);
// int __freading(FILE *fp);
// void exit(int status);
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// size_t strftime(char *s, size_t maxsize, const char *format, const struct tm *tp);
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// char *strchr(const char *s, int c);
// char *getcwd(char *buf, size_t size);
// size_t strlen(const char *s);
// int setenv(const char *name, const char *value, int replace);
// int fprintf(FILE *stream, const char *format, ...);
// int sigaddset(sigset_t *set, int signo);
// void *memset(void *s, int c, size_t n);
// int *__errno_location(void);
// __pid_t tcgetpgrp(int fd);
// int fileno(FILE *stream);
// int __cdecl stpncpy(_DWORD, _DWORD, _DWORD); weak
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// int __cdecl mempcpy(_DWORD, _DWORD, _DWORD); weak
// int __cdecl wcswidth(_DWORD, _DWORD); weak
// int sigemptyset(sigset_t *set);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// int toupper(int c);
// char *strrchr(const char *s, int c);
// size_t mbstowcs(wchar_t *pwcs, const char *s, size_t n);
// struct tm *gmtime_r(const time_t *timer, struct tm *tp);
// int sprintf(char *s, const char *format, ...);
// struct lconv *localeconv(void);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int readdir64(void); weak
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// char *bindtextdomain(const char *domainname, const char *dirname);
// int strncmp(const char *s1, const char *s2, size_t n);
// int isatty(int fd);
// void abort(void);
// int __cdecl __xstat64(_DWORD, _DWORD, _DWORD); weak
// int __cdecl __lxstat64(_DWORD, _DWORD, _DWORD); weak
// int close(int fd);
// int closedir(DIR *dirp);
// DIR *opendir(const char *name);
// struct group *getgrgid(__gid_t gid);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// void *calloc(size_t nmemb, size_t size);
// int putchar_unlocked(int c);
// int _gmon_start__(void); weak
void sub_8049BE3();
void sub_8049C00();
int sub_8049C10();
int sub_8049C80();
int sub_8049CA0();
void sub_8049CFF();
void sub_8049D1A();
signed int sub_8049D2A();
void sub_8049E0C();
void sub_8049E27();
signed int sub_8049E37();
void sub_8049F39();
void sub_8049F54();
int sub_8049F64();
void sub_804A046();
void sub_804A061();
int sub_804A071();
void sub_804A183();
void sub_804A19E();
int sub_804A1AE();
void sub_804A2AC();
void sub_804A2C7();
int sub_804A2D7();
int sub_804A381();
void sub_804A3EF();
void sub_804A40A();
int sub_804A41A();
void sub_804A4FC();
void sub_804A517();
int sub_804A527();
void sub_804A621();
void sub_804A63C();
int sub_804A64C();
int nullsub_3(void); // weak
int sub_804A6AA();
int __cdecl sub_804A728(int a1);
int __cdecl sub_804A73B(unsigned __int8 a1);
int __cdecl sub_804A74D(_BYTE *a1);
int sub_804A7AD();
int sub_804A7D8();
int __cdecl sub_804A803(char *s1); // idb
int __cdecl sub_804A999(int a1, int a2);
int __cdecl sub_804A9B8(int a1);
bool __cdecl sub_804A9C0(int a1);
int sub_804A9CC();
int __cdecl sub_804A9D6(int a1, int a2, int a3, int a4);
_DWORD *__stdcall sub_804AAC5(_DWORD *a1);
unsigned int __cdecl sub_804AB78(int a1, int a2);
_DWORD __cdecl sub_804ACD3(_DWORD); // weak
void sub_804AD5F();
signed int __cdecl sub_804ADE1(int a1);
int sub_804AECB(void); // weak
int __cdecl sub_804B117(unsigned __int64 *a1, unsigned int a2);
int __cdecl sub_804B15E(_QWORD *a1, _QWORD *a2);
void __cdecl sub_804B1E2(void *ptr);
void __cdecl __noreturn sub_804B1F5(int a1, int a2, int a3, int a4);
void __cdecl sub_804B2BD(void *ptr);
int __cdecl sub_804B2EB(int a1);
size_t sub_804B377();
size_t sub_804B397();
int __cdecl sub_804B3DE(int a1);
int sub_804B3F4();
int sub_804B40F();
__sighandler_t __cdecl sub_804B501(void (*a1)(int));
__sighandler_t sub_804B6A8();
__sighandler_t sub_804B6BC();
void __cdecl main(int a1, char **a2);
void __fastcall sub_804BA76(int a1, int a2);
int __cdecl sub_804BB42(int, int, int, int, int); // weak
int __cdecl sub_804BCD0(char *, int); // idb
// void __usercall sub_804BE3F(int a1@<ebp>);
int __cdecl sub_804BECF(char *file, unsigned int line, char *function); // idb
int sub_804BFFB(); // weak
signed int __cdecl sub_804C25A(char *nptr);
int __cdecl sub_804C2EA(int argc, char **argv); // idb
_DWORD __cdecl sub_804D495(_DWORD, _DWORD, _DWORD, _DWORD); // weak
signed int sub_804D878();
// int __usercall sub_804D92A@<eax>(int a1@<ebx>);
void sub_804DD19();
int __cdecl sub_804DDB8(int a1);
int __cdecl sub_804DDFF(int a1, char *format);
_DWORD *__cdecl sub_804DE5D(char *s, char *a2, int a3);
// unsigned int __usercall sub_804DF0C@<eax>(const unsigned __int16 *a1@<ebx>, char *a2, char *a3, unsigned __int8 a4);
_DWORD *__cdecl sub_804E6DA(int a1);
// int __usercall sub_804E71D@<eax>(int a1@<edx>, int a2@<ecx>, int a3, char *name);
int __cdecl sub_804E77D(char *name); // idb
int __cdecl sub_804E844(int a1);
int sub_804E86E();
void __cdecl sub_804E886(void **a1);
int sub_804E8F7();
int __cdecl sub_804E9E9(int a1);
int __cdecl sub_804EB72(int a1, int a2);
int __cdecl sub_804EC1E(int a1, int a2);
int __cdecl sub_804ECB3(const char *s);
void __cdecl sub_804ED26(int a1, int a2, __int64 a3, char a4, int a5);
int __cdecl sub_804EDF6(int c, size_t n, int, int, int, int, int, char); // idb
// void __usercall sub_804F537(int a1@<ebp>);
// void __usercall sub_804F572(int a1@<ebp>);
int __cdecl sub_804F5C1(char *format, int); // idb
int __cdecl sub_8050428(int a1);
void *__cdecl sub_80504CB(int a1, char *s);
int __cdecl sub_8050595(int a1);
int __cdecl sub_80505B6(char *, int); // idb
void __cdecl __noreturn sub_805079A(char *s1, char *s2); // idb
int sub_8050868(); // weak
int __cdecl sub_805091B(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD));
int __cdecl sub_80509A7(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD));
int __cdecl sub_8050A23(int *a1, int a2, int (__fastcall *a3)(_DWORD));
_DWORD __cdecl sub_8050AC4(_DWORD, _DWORD); // weak
int __cdecl sub_8050B2F(const char **a1, const char **a2, int (*a3)(void));
int __cdecl sub_80512E8(int *a1, int a2);
int __cdecl sub_805130A(int *a1, int a2);
int __cdecl sub_805132C(int a1, int *a2);
int __cdecl sub_805134E(int a1, int *a2);
int __cdecl sub_8051370(int *a1, int a2);
int __cdecl sub_80513F9(int *a1, int a2);
int __cdecl sub_8051467(int a1, int *a2);
int __cdecl sub_80514EE(int a1, int *a2);
int __cdecl sub_805155C(int a1, int a2);
int __cdecl sub_805157E(int a1, int a2);
int __cdecl sub_80515A0(int a1, int a2);
int __cdecl sub_80515C2(int a1, int a2);
signed int __cdecl sub_80515E4(int a1, int a2);
signed int __cdecl sub_805178A(int a1, int a2);
int __cdecl sub_80517F8(const char **a1, const char **a2);
int __cdecl sub_805181A(const char **a1, const char **a2);
int __cdecl sub_805183C(const char **a1, const char **a2);
int __cdecl sub_805185E(const char **a1, const char **a2);
int __cdecl sub_8051880(const char **a1, const char **a2);
int __cdecl sub_8051907(const char **a1, const char **a2);
int __cdecl sub_8051A11(const char **a1, const char **a2);
void __cdecl sub_8051A7F(char **a1, char **a2);
void __cdecl sub_8051A9D(char **a1, char **a2);
void __cdecl sub_8051AB7(char **a1, char **a2);
void __cdecl sub_8051AD1(char **a1, char **a2);
int sub_8051BB6(void); // weak
void sub_8051C4B();
int sub_8051DAB(void); // weak
int __cdecl sub_8051EF8(int a1, int a2, unsigned __int8 a3, int a4, int a5, int a6);
int sub_8051F8C();
int __cdecl sub_8052074(char *s, int, int); // idb
int __cdecl sub_8052159(__uid_t uid, int, int); // idb
int __cdecl sub_80521AC(__gid_t gid, int, int); // idb
size_t __cdecl sub_8052235(char *a1, int a2);
size_t __cdecl sub_80522AF(__uid_t uid);
// size_t __usercall sub_80522EF@<eax>(int a1@<edx>, int a2@<ecx>, __gid_t gid);
// const char *__usercall sub_8052340@<eax>(int a1@<edx>, int a2@<ecx>, int a3, unsigned int a4, int a5);
_DWORD __cdecl sub_80523D4(_DWORD); // weak
int __cdecl sub_8052B90(char *format, size_t n, FILE *stream, int, int); // idb
// unsigned int __usercall sub_8052FBC@<eax>(const unsigned __int16 *a1@<ebx>, void **a2, unsigned int a3, char *a4, int *a5, int a6, unsigned int *a7, _BYTE *a8);
// int __usercall sub_80534EC@<eax>(const unsigned __int16 *a1@<ebx>, char *a2, int *a3, int a4);
char *__cdecl sub_8053643(char *s, int a2);
// unsigned int __usercall sub_8053732@<eax>(const unsigned __int16 *a1@<ebx>, char *a2, int *a3, int a4, int a5, char a6, int a7, char *a8);
unsigned int __cdecl sub_8053C24(int a1, unsigned __int8 a2, const unsigned __int16 *a3, unsigned int a4);
size_t sub_8053DAD();
unsigned int __cdecl sub_8053DFC(int a1, unsigned int a2);
_DWORD __cdecl sub_805403F(_DWORD, _DWORD, _DWORD); // weak
bool __cdecl sub_805419B(unsigned __int8 a1, int a2, int a3);
bool __cdecl sub_8054208(int a1);
_DWORD __cdecl sub_8054255(_DWORD, _DWORD); // weak
size_t __cdecl sub_80546A8(int a1);
void __cdecl sub_8054708(int a1);
// void __usercall sub_80547BA(int a1@<ebp>);
int __cdecl sub_805483C(int, int, int, int, int, int, int); // weak
int sub_80548BA(); // weak
unsigned int sub_8054A0C();
int sub_8054B54();
int __cdecl sub_8054CC9(char a1);
unsigned int __cdecl sub_8054DBE(unsigned int a1, unsigned int a2);
_BYTE *__cdecl sub_8054E5C(_BYTE *a1, _BYTE *a2, _BYTE *a3);
unsigned int sub_8054EF8();
unsigned int __cdecl sub_8055108(char a1);
void __cdecl __noreturn sub_805538B(int status); // idb
void sub_80556F7();
// void __usercall sub_805574E(int a1@<ebp>);
int sub_8055787(); // weak
int __cdecl sub_80557CB(char *buf, size_t len); // idb
void __noreturn sub_805597D();
int __cdecl sub_8055991(char *s, int, int, size_t); // idb
void __cdecl sub_8055B34(int a1, int a2, int a3);
int __cdecl sub_8055BD3(int, int, size_t n); // idb
int __cdecl sub_8055CFA(int, char *s, int, int, size_t n, int); // idb
signed int __cdecl sub_8055DF6(signed int a1);
_DWORD __cdecl sub_8055E26(_DWORD); // weak
_BOOL4 __cdecl sub_8055EF1(int a1);
int __cdecl sub_8056028(int a1);
// signed int __usercall sub_805605E@<eax>(int a1@<edx>, int a2@<ecx>, int *a3, int a4, int *a5);
char *__cdecl sub_8056113(void *src, int a2);
_DWORD __cdecl sub_8056B96(_DWORD); // weak
void *__cdecl sub_8056C1C(void *src);
_DWORD __cdecl sub_8056C9E(_DWORD); // weak
size_t __cdecl sub_8056D0E(char *s);
int sub_8056D65();
void __cdecl sub_8056D6F(int a1);
void __cdecl __noreturn sub_8056DA0(int); // weak
bool __cdecl sub_8056E69(int a1, int a2, int *a3);
_DWORD __cdecl sub_8056ED4(_DWORD); // weak
_DWORD __cdecl sub_8056FC8(_DWORD, _DWORD); // weak
int __cdecl sub_80571A8(int a1, int a2);
void __cdecl sub_80571C5(int a1, _BYTE *a2, _DWORD *a3);
int sub_8057204(); // weak
_BYTE *__cdecl sub_8057209(_BYTE *a1);
void *__cdecl sub_8057231(int a1, _BYTE *a2, _DWORD *a3);
// _BYTE *__usercall sub_8057357@<eax>(int a1@<edx>, int a2@<ecx>, int *a3);
int __cdecl sub_805743A(unsigned __int8 a1);
int __cdecl sub_805748B(int a1, unsigned int a2, int a3, unsigned int a4);
void __cdecl sub_80576BB(char *s1, char *s2);
// void __usercall sub_8057706(int a1@<ebp>);
// void __usercall sub_805773A(int a1@<ebp>);
int __cdecl sub_805776E(char *s2); // idb
int __cdecl sub_80577AF(char *s2); // idb
int __cdecl sub_80577F0(char *s2); // idb
int __cdecl sub_8057831(char *s2); // idb
// void __usercall sub_80578D7(int a1@<ebp>, int a2, int a3, char *a4);
int sub_8057927(); // weak
// void __usercall sub_80579D2(int a1@<ebp>);
int __cdecl sub_8057A0F(char *s2, size_t n, int); // idb
struct timespec *__cdecl sub_8057B1B(struct timespec *tp);
int __cdecl sub_8057B66(int category); // idb
int __cdecl sub_8057BC4(int a1);
int __cdecl sub_8057BCF(int a1);
int __cdecl sub_8057BDA(int a1);
unsigned int __cdecl sub_8057BE5(int a1);
int __cdecl sub_8057DAE(_DWORD *a1, int a2);
int __cdecl sub_8057DFE(int a1, int a2);
bool __cdecl sub_80580A5(unsigned int a1);
int __cdecl sub_8058118(unsigned int a1);
unsigned int __cdecl sub_8058199(int a1, unsigned int a2);
signed int __cdecl sub_80581DE(int a1);
unsigned int __cdecl sub_80582AE(unsigned int a1, int a2);
int __cdecl sub_805835B(unsigned int a1, void *a2, int a3);
void __cdecl sub_80585C6(void *a1);
void *__cdecl sub_80586E0(int a1);
int __cdecl sub_805872B(int a1, _DWORD *a2);
int __cdecl sub_805875E(int a1, int a2, int **a3, char a4);
int __cdecl sub_8058918(int a1, int *a2, char a3);
void __cdecl __noreturn sub_8058DD0(_DWORD, _DWORD); // weak
void __cdecl __noreturn sub_80590B0(int a1, int a2);
int __cdecl sub_8059129(int a1, int a2);
int __cdecl sub_805918C(int); // weak
int __cdecl sub_805939B(int a1, unsigned int a2);
int __cdecl sub_8059541(int a1, int a2);
void __cdecl sub_80595E1(void **a1);
long double __cdecl sub_8059607(int a1, long double a2);
int __cdecl sub_805975F(int, size_t, int, int); // idb
_DWORD __cdecl sub_80598C8(_DWORD); // weak
int __cdecl sub_80598FE(_TBYTE); // idb
signed __int64 sub_805A6DC();
int __cdecl sub_805A71A(char *s, int, int); // idb
int __cdecl sub_805A879(char *s, int, int); // idb
char *__cdecl sub_805A8C2(__uid_t uid);
char *__cdecl sub_805AB03(__gid_t gid);
int __cdecl sub_805AD11(__int64 a1, int a2);
int __cdecl sub_805AE4B(unsigned __int64 a1, int a2);
int __cdecl sub_805AF01(wint_t *a1);
void sub_805AF54();
// void __usercall sub_805AF7B(int a1@<ebp>, int a2, _DWORD *a3, unsigned int a4);
int sub_805AFE5(); // weak
void sub_805B018();
int __cdecl sub_805B08E(char *s, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_805B512(char *s);
_DWORD __cdecl sub_805B53B(_DWORD); // weak
int __cdecl sub_805B568(int c, size_t n); // idb
void *__cdecl sub_805B825(int a1, int a2, void *dest, int a4);
void __cdecl sub_805B9BB(int a1, int a2, void *dest, int a4);
void __cdecl sub_805BC23(int a1, int a2, int a3);
void sub_805BC67();
int __cdecl sub_805BCEA(int a1, int a2, int a3);
int __cdecl sub_805BD2A(int a1, int a2);
int __cdecl sub_805BD87(int a1, int a2, int a3, int a4, int a5, int a6);
_DWORD __cdecl sub_805BE20(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_805E990(char *s); // idb
void *__cdecl sub_805EA82(void *src);
int __cdecl sub_805EAD4(int *a1);
int *__cdecl sub_805EAF7(int *a1, int a2);
int __cdecl sub_805EB11(int *a1, unsigned __int8 a2, char a3);
_DWORD __cdecl sub_805EBDF(_DWORD, _DWORD, _DWORD); // weak
// _DWORD *__userpurge sub_805EC59@<eax>(_DWORD *a1, int a2);
char *__cdecl sub_805ED23(char *msgid, int a2);
_DWORD __cdecl sub_805EDDF(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_805EE6F(void *s2, size_t n, mbstate_t *p, int, int, int, int, int); // idb
int __cdecl sub_805FB88(int a1, int a2, int a3, int a4, int *a5);
void *__cdecl sub_805FC73(int a1, int a2, _DWORD *a3, int *a4);
void __cdecl sub_805FE5E(int a1);
// void __usercall sub_805FE94(int a1@<ebp>, int a2, int a3);
// void __usercall sub_805FEDE(int a1@<ebp>);
void __cdecl sub_8060166(int a1);
void __cdecl sub_8060223(int a1, int a2);
void __cdecl sub_8060261(int a1, int a2);
void __cdecl sub_806029E(int a1);
void __cdecl sub_8060311(int a1, int a2, unsigned __int8 a3);
_DWORD __cdecl sub_80603CB(_DWORD, _DWORD); // weak
int __cdecl sub_8060419(int a1);
void __cdecl sub_806047E(int a1, int a2, int a3);
void __cdecl sub_806052F(int a1, int a2, int a3, int a4);
void __cdecl sub_8060587(int a1, int a2, int a3, int a4, int a5);
void __cdecl sub_80606B1(int a1);
void __cdecl sub_8060718(int a1);
void sub_806073A();
_BOOL4 __cdecl sub_8060755(void *src, void *a2);
void sub_806096A();
signed int sub_80609BF();
signed int sub_80609D7();
// _DWORD *__userpurge sub_8060B11@<eax>(_DWORD *a1, int a2);
// _DWORD *__userpurge sub_8060B3C@<eax>(_DWORD *a1, int a2);
// _DWORD *__userpurge sub_8060B67@<eax>(_DWORD *a1, int a2);
void __cdecl sub_8060C02(int a1, int a2, int a3, int a4);
void sub_8060C5A();
int sub_8060C77(); // weak
int __cdecl sub_8060D32(FILE *stream, int, int, int, int, int); // idb
int __cdecl sub_806138C(FILE *stream, int, int, int, int); // idb
int sub_8061416(FILE *stream, int a2, int a3, int a4, ...);
void *__cdecl sub_80614C6(unsigned int a1, unsigned int a2);
void *__cdecl sub_80614F4(void *ptr, int a2, int a3);
void *__cdecl sub_8061529(void *ptr, int a2, int a3);
void *__cdecl sub_80615C0(size_t size);
void *__cdecl sub_80615D3(size_t size);
void *__cdecl sub_8061609(void *ptr, size_t size);
void *__cdecl sub_806167D(void *ptr, int a2);
void *__cdecl sub_806171A(void *src, size_t n);
void *__cdecl sub_8061743(char *s);
void __noreturn sub_8061768();
unsigned __int64 __cdecl sub_80617A1(int nptr, int base, int a3, int a4, int a5, int a6, int s, int a8, int status);
char *sub_806196B();
char *sub_80619B4();
signed int __cdecl sub_8061A88(unsigned int *a1, unsigned int a2);
int __cdecl sub_8061AFC(int a1, int a2, int a3);
int __cdecl sub_8061B42(char *nptr, int, int base, int, char *s); // idb
int __cdecl sub_8061F9C(int, int, int, int, int, int status); // idb
void __cdecl __noreturn sub_8062090(int a1, int a2, char a3, int a4, int a5);
signed int __cdecl sub_80620E3(int a1, int a2);
_DWORD __cdecl sub_806219F(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_80621FE(char *nptr, int, int base, int, char *s); // idb
size_t __cdecl sub_8062663(wchar_t *pwc, char *s, size_t n, mbstate_t *p);
int __cdecl sub_80626FD(int a1, int a2);
int __cdecl sub_8062747(int a1, int a2);
signed int __cdecl sub_80627AA(int a1, signed int a2, signed int a3);
signed int __cdecl sub_80628A9(int a1, signed int a2, signed int a3, int a4, int a5);
int __cdecl sub_8062976(int a1, int a2);
int __cdecl sub_8062CB0(int a1, int a2);
_BOOL4 __cdecl sub_8062CE4(_DWORD *a1, _DWORD *a2);
char *__cdecl sub_8062D92(void *dest, void *src, size_t n);
char *__cdecl sub_8062DBE(char *s);
signed int __cdecl sub_8062E68(int a1, unsigned int a2);
void *__cdecl sub_8062FFD(void *ptr);
char *sub_8063030();
int __cdecl sub_8063044(char *value); // idb
signed int __cdecl sub_806307B(int a1);
_DWORD __cdecl sub_80630C4(_DWORD); // weak
int __cdecl sub_80631A8(void *ptr); // idb
struct tm *__cdecl sub_8063207(int a1, time_t *timer, struct tm *tp);
void __cdecl sub_80632BF(int a1, struct tm *tp);
int __cdecl sub_80632FB(struct tm *tp); // idb
int __cdecl sub_80635DC(int a1, char a2);
int __cdecl sub_8063707(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_806376C(FILE *fp); // idb
void *__cdecl sub_8063806(void *src);
int __cdecl sub_8063836(_BYTE *a1, unsigned int a2);
void *sub_8063888();
const char *sub_8063DC6();
int __cdecl sub_8063E79(FILE *stream); // idb
int __cdecl sub_8063F81(FILE *stream); // idb
int __cdecl sub_8063FBA(FILE *fp); // idb
int __cdecl sub_8064013(FILE *stream, int, int, int); // idb
signed __int64 __cdecl sub_8064121(__int64 a1, unsigned int a2, signed int a3);
_DWORD __cdecl sub_80642B8(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl sub_806456E(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_80647BA(unsigned __int64 a1, __int64 a2);
int __cdecl sub_80649F2(int a1);
int __cdecl sub_8064A21(int a1, int a2);
int __cdecl sub_8064A50(int a1, int a2);
int __cdecl sub_8064A8F(int a1, int a2);
int __stdcall sub_8064C1B(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_8064C87(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __fastcall sub_8064CF3(_DWORD, _DWORD); // weak
int __stdcall sub_8064D6B(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
double __fastcall sub_8064E3D(_DWORD, _DWORD); // weak
int (**sub_8064E50())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_804B4E5; // weak
_UNKNOWN loc_804B7B2; // weak
_UNKNOWN loc_804B88D; // weak
_UNKNOWN loc_804B894; // weak
_UNKNOWN loc_804B91C; // weak
_UNKNOWN loc_804B921; // weak
_UNKNOWN loc_804BAB8; // weak
_UNKNOWN loc_804BB47; // weak
_UNKNOWN loc_804BEBC; // weak
_UNKNOWN loc_804C81F; // weak
_UNKNOWN loc_804C85E; // weak
_UNKNOWN loc_804CF37; // weak
_UNKNOWN loc_804D166; // weak
_UNKNOWN loc_804D189; // weak
_UNKNOWN loc_804D1A7; // weak
_UNKNOWN loc_804D1E8; // weak
_UNKNOWN loc_804D241; // weak
_UNKNOWN loc_804D482; // weak
_UNKNOWN loc_804DA16; // weak
_UNKNOWN loc_804DAA4; // weak
_UNKNOWN loc_804DEAA; // weak
_UNKNOWN loc_804DECA; // weak
_UNKNOWN loc_804E254; // weak
_UNKNOWN loc_804E25C; // weak
_UNKNOWN loc_804E429; // weak
_UNKNOWN loc_804E459; // weak
_UNKNOWN loc_804E4B7; // weak
_UNKNOWN loc_804E4E5; // weak
_UNKNOWN loc_804E4EF; // weak
_UNKNOWN loc_804E770; // weak
_UNKNOWN loc_804E816; // weak
_UNKNOWN loc_804E833; // weak
_UNKNOWN loc_804F588; // weak
_UNKNOWN loc_804F5E9; // weak
_UNKNOWN loc_80505EB; // weak
_UNKNOWN loc_805060F; // weak
_UNKNOWN loc_8050702; // weak
_UNKNOWN loc_80507E7; // weak
_UNKNOWN loc_80507FF; // weak
_UNKNOWN loc_8050BB3; // weak
_UNKNOWN loc_8050BCB; // weak
_UNKNOWN loc_80514A8; // weak
_UNKNOWN loc_80514BA; // weak
_UNKNOWN loc_80518E4; // weak
_UNKNOWN loc_80518EB; // weak
_UNKNOWN locret_8051988; // weak
_UNKNOWN loc_8052144; // weak
_UNKNOWN loc_805231E; // weak
_UNKNOWN loc_8052394; // weak
_UNKNOWN loc_80523C1; // weak
_UNKNOWN loc_805304A; // weak
_UNKNOWN loc_8053050; // weak
_UNKNOWN loc_8053115; // weak
_UNKNOWN loc_8053125; // weak
_UNKNOWN loc_8053203; // weak
_UNKNOWN loc_8053212; // weak
_UNKNOWN loc_805346D; // weak
_UNKNOWN loc_80534C1; // weak
_UNKNOWN loc_80534C9; // weak
_UNKNOWN loc_80539F9; // weak
_UNKNOWN loc_8053A94; // weak
_UNKNOWN loc_8053B3B; // weak
_UNKNOWN loc_8053B49; // weak
_UNKNOWN loc_8053B93; // weak
_UNKNOWN loc_8053BB2; // weak
_UNKNOWN loc_8053BDB; // weak
_UNKNOWN loc_8053BF7; // weak
_UNKNOWN loc_8053D8F; // weak
_UNKNOWN loc_8053DA2; // weak
_UNKNOWN loc_8053E88; // weak
_UNKNOWN loc_8053F50; // weak
_UNKNOWN loc_80547C2; // weak
_UNKNOWN loc_805489C; // weak
_UNKNOWN loc_8055751; // weak
_UNKNOWN loc_805578A; // weak
_UNKNOWN loc_8056086; // weak
_UNKNOWN loc_80560CB; // weak
_UNKNOWN loc_80561B4; // weak
_UNKNOWN loc_805635C; // weak
_UNKNOWN loc_8056993; // weak
_UNKNOWN loc_8056D2B; // weak
_UNKNOWN loc_8056D60; // weak
_UNKNOWN locret_8056E67; // weak
_UNKNOWN loc_80573D5; // weak
_UNKNOWN loc_80573E1; // weak
_UNKNOWN loc_80574AD; // weak
_UNKNOWN loc_805755A; // weak
_UNKNOWN loc_8057A12; // weak
_UNKNOWN locret_8057B19; // weak
_UNKNOWN loc_8058380; // weak
_UNKNOWN loc_8058387; // weak
_UNKNOWN loc_8058446; // weak
_UNKNOWN loc_8058448; // weak
_UNKNOWN loc_805860C; // weak
_UNKNOWN loc_8058633; // weak
_UNKNOWN loc_80586C0; // weak
_UNKNOWN loc_8058854; // weak
_UNKNOWN loc_8058911; // weak
_UNKNOWN loc_8058B9B; // weak
_UNKNOWN loc_8058DC6; // weak
_UNKNOWN loc_8059182; // weak
_UNKNOWN loc_80596EF; // weak
_UNKNOWN loc_805AFB3; // weak
_UNKNOWN loc_805AFEF; // weak
_UNKNOWN loc_805B00A; // weak
_UNKNOWN loc_805B03A; // weak
_UNKNOWN loc_805B2CC; // weak
_UNKNOWN loc_805B2DD; // weak
_UNKNOWN loc_805BB62; // weak
_UNKNOWN loc_805BB67; // weak
_UNKNOWN loc_805BCA2; // weak
_UNKNOWN locret_805EDAA; // weak
_UNKNOWN sub_805FF1B; // weak
_UNKNOWN loc_805FF1E; // weak
_UNKNOWN loc_805FFBE; // weak
_UNKNOWN loc_806082D; // weak
_UNKNOWN loc_8060941; // weak
_UNKNOWN loc_806162E; // weak
_UNKNOWN loc_806164C; // weak
_UNKNOWN locret_80627A8; // weak
_UNKNOWN loc_80632AB; // weak
_UNKNOWN loc_80632B8; // weak
_UNKNOWN locret_8063437; // weak
_UNKNOWN loc_80637CA; // weak
_UNKNOWN loc_80637E2; // weak
_UNKNOWN loc_8063B13; // weak
_UNKNOWN loc_8063B18; // weak
_UNKNOWN loc_8063F31; // weak
_UNKNOWN loc_8063F3B; // weak
_UNKNOWN loc_8063FEE; // weak
_UNKNOWN loc_8063FFB; // weak
_UNKNOWN loc_8064805; // weak
char locale = '\0'; // idb
char *off_8066208[4] = { "full-iso", "long-iso", "iso", "locale" }; // weak
_UNKNOWN unk_806621C; // weak
char *off_806624C[4] = { "none", "slash", "file-type", "classify" }; // weak
int dword_8066260[4] = { 0, 1, 2, 3 }; // idb
char *off_80662D0 = &unk_8066270; // idb
_UNKNOWN unk_8066339; // weak
struct option longopts = { "all", 0, NULL, 97 }; // idb
char *off_8066870[7] =
{
  "verbose",
  "long",
  "commas",
  "horizontal",
  "across",
  "vertical",
  "single-column"
}; // weak
int dword_8066890[] = { 0 }; // weak
char *off_80668B8[5] = { "none", "time", "size", "extension", "version" }; // weak
int dword_80668D0[5] = { 4294967295, 4, 2, 1, 3 }; // idb
char *off_8066904[5] = { "atime", "access", "use", "ctime", "status" }; // weak
int dword_806691C[5] = { 2, 2, 2, 1, 1 }; // idb
char *off_8066970[4] = { "always", "yes", "force", "never" }; // weak
int dword_80669B0[9] = { 1, 1, 1, 0, 0, 0, 2, 2, 2 }; // idb
int (__cdecl *off_80676D0[28])(int, int) =
{
  &sub_805155C,
  &sub_80515E4,
  &sub_80515A0,
  &sub_80516EE,
  &sub_805157E,
  &sub_8051652,
  &sub_80515C2,
  &sub_805178A,
  &sub_80517F8,
  &sub_8051880,
  &sub_805183C,
  &sub_805198A,
  &sub_805181A,
  &sub_8051907,
  &sub_805185E,
  &sub_8051A11,
  &sub_80512E8,
  &sub_8051370,
  &sub_805132C,
  &sub_8051467,
  &sub_805130A,
  &sub_80513F9,
  &sub_805134E,
  &sub_80514EE,
  &sub_8051A9D,
  &sub_8051AD1,
  &sub_8051AB7,
  &sub_8051B37
}; // weak
int sig[12] = { 20, 14, 1, 2, 13, 3, 15, 29, 27, 26, 24, 25 }; // idb
_UNKNOWN unk_80696B8; // weak
char *off_806978C[2] = { "human-readable", "si" }; // weak
int dword_8069798[2] = { 176, 144 }; // idb
_UNKNOWN unk_806981C; // weak
char *off_8069AF0[10] =
{
  "literal",
  "shell",
  "shell-always",
  "shell-escape",
  "shell-escape-always",
  "c",
  "c-maybe",
  "escape",
  "locale",
  "clocale"
}; // weak
int dword_8069B30[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; // idb
_UNKNOWN unk_8069B5E; // weak
_UNKNOWN unk_8069B62; // weak
_UNKNOWN unk_8069B6E; // weak
_UNKNOWN unk_8069B72; // weak
_UNKNOWN unk_806A670; // weak
_UNKNOWN unk_806A6CB; // weak
_UNKNOWN unk_806B390; // weak
_UNKNOWN unk_806B393; // weak
_UNKNOWN unk_806B394; // weak
_UNKNOWN unk_806B397; // weak
int (*off_8070EE4[2])() = { &sub_8049CA0, &sub_8049C80 }; // weak
int (*off_8070EE8)() = &sub_8049C80; // weak
int (*dword_8071008)(void) = NULL; // weak
int dword_80711DC = 0; // weak
int dword_80711FC = 0; // weak
int dword_8071210 = 0; // weak
int dword_8071224 = 0; // weak
int dword_8071238 = 0; // weak
int (*dword_8071254)(void) = NULL; // weak
int dword_807126C = 0; // weak
_UNKNOWN unk_8071288; // weak
char byte_807128A = '\x01'; // weak
char byte_807128B = '\x01'; // weak
__int64 qword_8071290 = 1LL; // weak
int dword_80712A8[] = { 2 }; // weak
void *off_80712AC = &unk_8066334; // idb
int dword_80712B0 = 1; // weak
_UNKNOWN unk_80712B8; // weak
int dword_80712BC = 0; // weak
_UNKNOWN unk_80712C0; // weak
_UNKNOWN unk_80712C8; // weak
int dword_80712E0 = 5; // weak
char *s1 = "01;36"; // idb
_UNKNOWN unk_8071360; // weak
char *off_8071368 = "%b %e  %Y"; // idb
char *off_807136C = "%b %e %H:%M"; // weak
char byte_8071370 = '\x01'; // weak
int dword_8071374 = 4294967295; // weak
int dword_80713B0 = 1; // weak
int off_80713B4 = 134649168; // idb
int off_80713B8 = 134568317; // idb
int status = 1; // idb
int dword_80713C8 = 1; // weak
int dword_80713CC = 256; // weak
_UNKNOWN unk_8071408; // weak
_UNKNOWN unk_807140B; // weak
_UNKNOWN unk_807141C; // weak
_UNKNOWN unk_807141F; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int optind; // weak
FILE *stdout; // idb
int (*obstack_alloc_failed_handler)(void); // weak
char *optarg; // idb
char byte_807146C; // weak
_UNKNOWN unk_80715A4; // weak
char byte_807163A; // weak
_UNKNOWN unk_807163E; // weak
int dword_8071715; // weak
int dword_8071721; // weak
char byte_8071725; // weak
char byte_8071726; // weak
void *dword_8071729; // idb
int dword_807172D; // weak
char byte_8071731; // weak
char *dword_8071735; // idb
int dword_8071739; // weak
struct timespec tp; // idb
char byte_8071745; // weak
char byte_8071746; // weak
int dword_8071749; // weak
int dword_807174D; // weak
int dword_8071751; // weak
int dword_8071755; // idb
int dword_8071759; // idb
int dword_807175D; // idb
int dword_8071761; // idb
int dword_8071765; // weak
int dword_8071769; // weak
int dword_807176D; // weak
int dword_8071771; // weak
int dword_8071775; // weak
int dword_8071779; // weak
char byte_807177D; // weak
char byte_807177E; // weak
char byte_807177F; // weak
char byte_8071780; // weak
int dword_8071781; // weak
__int64 qword_8071785; // weak
int dword_807178D; // weak
char byte_8071791; // weak
int dword_8071795; // weak
char byte_8071799; // weak
char byte_807179A; // weak
char byte_807179B; // weak
int dword_807179D; // weak
void *ptr; // idb
char byte_80717A5; // weak
char byte_80717A6; // weak
int dword_80717A9; // weak
char byte_80717AD; // weak
char byte_80717AE; // weak
char byte_80717AF; // weak
int dword_80717B1; // weak
int dword_80717B5; // idb
int dword_80717B9; // idb
char byte_80717BD; // weak
int dword_80717C1; // weak
int dword_80717C5; // weak
int dword_80717C9; // weak
char byte_80717CD; // weak
int dword_80717D1; // weak
int dword_80717D5; // idb
char byte_80717D9; // weak
sigset_t set; // idb
int dword_8071875; // weak
int dword_8071879; // weak
int dword_807187D; // weak
void *dword_8071881; // idb
int dword_8071885; // idb
int dword_8071889; // weak
_UNKNOWN unk_80718D5; // weak
_UNKNOWN unk_8071915; // weak
int dword_8071921; // weak
char byte_8071955[3328]; // idb
char byte_8072655; // weak
struct __jmp_buf_tag env[1]; // idb
__int64 qword_807271D; // weak
__int64 qword_8072725; // weak
int dword_807272D; // weak
int dword_8072739; // weak
int dword_8072741; // weak
int dword_8072749; // weak
int dword_8072755; // weak
int dword_8072759; // weak
int dword_807275D; // weak
int dword_8072761; // weak
int dword_8072765; // weak
int dword_8072769; // weak
int dword_807276D; // weak
int dword_8072771; // weak
int dword_8072775; // weak
int dword_8072779; // weak
int dword_807277D; // weak
int dword_8072781; // weak
int dword_8072895; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (0804945C) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 8049BA0: using guessed type int _gmon_start__(void);

//----- (08049480) --------------------------------------------------------
int sub_8049480()
{
  return dword_8071008();
}
// 8071008: using guessed type int (*dword_8071008)(void);

//----- (08049BB0) --------------------------------------------------------
#error "8049BB3: positive sp value has been found (funcsize=2)"

//----- (08049BE3) --------------------------------------------------------
void sub_8049BE3()
{
  ;
}

//----- (08049C00) --------------------------------------------------------
void sub_8049C00()
{
  ;
}

//----- (08049C10) --------------------------------------------------------
int sub_8049C10()
{
  int result; // eax

  result = &unk_807141F - &unk_807141C;
  if ( (unsigned int)(&unk_807141F - &unk_807141C) > 6 )
    result = 0;
  return result;
}
// 8049C10: could not find valid save-restore pair for ebp

//----- (08049C80) --------------------------------------------------------
int sub_8049C80()
{
  int result; // eax

  if ( !byte_807146C )
  {
    result = sub_8049C10();
    byte_807146C = 1;
  }
  return result;
}
// 8049C80: could not find valid save-restore pair for ebp
// 807146C: using guessed type char byte_807146C;

//----- (08049CA0) --------------------------------------------------------
int sub_8049CA0()
{
  return 0;
}
// 8049CA0: could not find valid save-restore pair for ebp

//----- (08049CFF) --------------------------------------------------------
void sub_8049CFF()
{
  ;
}

//----- (08049D1A) --------------------------------------------------------
void sub_8049D1A()
{
  ;
}

//----- (08049D2A) --------------------------------------------------------
signed int sub_8049D2A()
{
  return 3;
}
// 8049D2A: could not find valid save-restore pair for ebp

//----- (08049E0C) --------------------------------------------------------
void sub_8049E0C()
{
  ;
}

//----- (08049E27) --------------------------------------------------------
void sub_8049E27()
{
  ;
}

//----- (08049E37) --------------------------------------------------------
signed int sub_8049E37()
{
  return 3;
}
// 8049E37: could not find valid save-restore pair for ebp

//----- (08049F39) --------------------------------------------------------
void sub_8049F39()
{
  ;
}

//----- (08049F54) --------------------------------------------------------
void sub_8049F54()
{
  ;
}

//----- (08049F64) --------------------------------------------------------
int sub_8049F64()
{
  int result; // eax

  result = &unk_807140B - &unk_8071408;
  if ( (unsigned int)(&unk_807140B - &unk_8071408) > 6 )
    result = 0;
  return result;
}
// 8049F64: could not find valid save-restore pair for ebp

//----- (0804A046) --------------------------------------------------------
void sub_804A046()
{
  ;
}

//----- (0804A061) --------------------------------------------------------
void sub_804A061()
{
  ;
}

//----- (0804A071) --------------------------------------------------------
int sub_804A071()
{
  int result; // eax

  result = &unk_807140B - &unk_8071408;
  if ( (unsigned int)(&unk_807140B - &unk_8071408) > 6 )
    result = 0;
  return result;
}
// 804A071: could not find valid save-restore pair for ebp

//----- (0804A183) --------------------------------------------------------
void sub_804A183()
{
  ;
}

//----- (0804A19E) --------------------------------------------------------
void sub_804A19E()
{
  ;
}

//----- (0804A1AE) --------------------------------------------------------
int sub_804A1AE()
{
  int result; // eax

  result = &unk_80715A4 - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_80715A4 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 804A1AE: could not find valid save-restore pair for ebp
// 8071420: using guessed type int program_invocation_short_name;

//----- (0804A2AC) --------------------------------------------------------
void sub_804A2AC()
{
  ;
}

//----- (0804A2C7) --------------------------------------------------------
void sub_804A2C7()
{
  ;
}

//----- (0804A2D7) --------------------------------------------------------
int sub_804A2D7()
{
  int result; // eax

  result = &unk_807140B - &unk_8071408;
  if ( (unsigned int)(&unk_807140B - &unk_8071408) > 6 )
    result = 0;
  return result;
}
// 804A2D7: could not find valid save-restore pair for ebp

//----- (0804A381) --------------------------------------------------------
int sub_804A381()
{
  int result; // eax

  result = sub_804A2D7();
  byte_807163A = 1;
  return result;
}
// 807163A: using guessed type char byte_807163A;

//----- (0804A3EF) --------------------------------------------------------
void sub_804A3EF()
{
  ;
}

//----- (0804A40A) --------------------------------------------------------
void sub_804A40A()
{
  ;
}

//----- (0804A41A) --------------------------------------------------------
int sub_804A41A()
{
  int result; // eax

  result = &unk_807163E - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_807163E - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 804A41A: could not find valid save-restore pair for ebp
// 8071420: using guessed type int program_invocation_short_name;

//----- (0804A4FC) --------------------------------------------------------
void sub_804A4FC()
{
  ;
}

//----- (0804A517) --------------------------------------------------------
void sub_804A517()
{
  ;
}

//----- (0804A527) --------------------------------------------------------
int sub_804A527()
{
  int result; // eax

  result = &unk_806B393 - &unk_806B390;
  if ( (unsigned int)(&unk_806B393 - &unk_806B390) > 6 )
    result = 0;
  return result;
}
// 804A527: could not find valid save-restore pair for ebp

//----- (0804A621) --------------------------------------------------------
void sub_804A621()
{
  ;
}

//----- (0804A63C) --------------------------------------------------------
void sub_804A63C()
{
  ;
}

//----- (0804A64C) --------------------------------------------------------
int sub_804A64C()
{
  int result; // eax

  result = &unk_806B397 - &unk_806B394;
  if ( (unsigned int)(&unk_806B397 - &unk_806B394) > 6 )
    result = 0;
  return result;
}
// 804A64C: could not find valid save-restore pair for ebp

//----- (0804A6AA) --------------------------------------------------------
int sub_804A6AA()
{
  return nullsub_3();
}
// 804A6AA: could not find valid save-restore pair for ebp
// 804A6A9: using guessed type int nullsub_3(void);

//----- (0804A728) --------------------------------------------------------
int __cdecl sub_804A728(int a1)
{
  int result; // eax

  if ( a1 != 1 )
  {
    result = a1;
    status = a1;
  }
  return result;
}

//----- (0804A73B) --------------------------------------------------------
int __cdecl sub_804A73B(unsigned __int8 a1)
{
  return a1;
}

//----- (0804A74D) --------------------------------------------------------
int __cdecl sub_804A74D(_BYTE *a1)
{
  signed int v3; // eax
  char v4; // [esp+Fh] [ebp-1h]

  if ( *a1 != 46 )
    return 0;
  if ( a1[1] == 46 )
    v3 = 2;
  else
    v3 = 1;
  v4 = a1[v3];
  return !v4 || v4 == 47;
}

//----- (0804A7AD) --------------------------------------------------------
int sub_804A7AD()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nMandatory arguments to long options are mandatory for short options too.\n");
  return fputs_unlocked(v1, v0);
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804A7D8) --------------------------------------------------------
int sub_804A7D8()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext(
         "\n"
         "The SIZE argument is an integer and optional unit (example: 10K is 10*1024).\n"
         "Units are K,M,G,T,P,E,Z,Y (powers of 1024) or KB,MB,... (powers of 1000).\n");
  return fputs_unlocked(v1, v0);
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804A803) --------------------------------------------------------
int __cdecl sub_804A803(char *s1)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // ebx
  char *v5; // eax
  int v7; // [esp+0h] [ebp-68h]
  char *v8; // [esp+4h] [ebp-64h]
  char *v9; // [esp+8h] [ebp-60h]
  char *v10; // [esp+1Ch] [ebp-4Ch]
  char **i; // [esp+20h] [ebp-48h]
  char *v12; // [esp+24h] [ebp-44h]
  const char *v13; // [esp+28h] [ebp-40h]
  const char *v14; // [esp+2Ch] [ebp-3Ch]
  const char *v15; // [esp+30h] [ebp-38h]
  const char *v16; // [esp+34h] [ebp-34h]
  const char *v17; // [esp+38h] [ebp-30h]
  const char *v18; // [esp+3Ch] [ebp-2Ch]
  const char *v19; // [esp+40h] [ebp-28h]
  const char *v20; // [esp+44h] [ebp-24h]
  const char *v21; // [esp+48h] [ebp-20h]
  const char *v22; // [esp+4Ch] [ebp-1Ch]
  const char *v23; // [esp+50h] [ebp-18h]
  const char *v24; // [esp+54h] [ebp-14h]
  int v25; // [esp+58h] [ebp-10h]
  int v26; // [esp+5Ch] [ebp-Ch]

  v13 = "[";
  v14 = "test invocation";
  v15 = "coreutils";
  v16 = "Multi-call invocation";
  v17 = "sha224sum";
  v18 = "sha2 utilities";
  v19 = "sha256sum";
  v20 = "sha2 utilities";
  v21 = "sha384sum";
  v22 = "sha2 utilities";
  v23 = "sha512sum";
  v24 = "sha2 utilities";
  v25 = 0;
  v26 = 0;
  v10 = s1;
  for ( i = (char **)(&v7 - 16); *i; i += 2 )
  {
    v8 = *i;
    if ( !strcmp(s1, v8) )
      break;
  }
  if ( i[1] )
    v10 = i[1];
  v1 = gettext("\n%s online help: <%s>\n");
  v9 = "http://www.gnu.org/software/coreutils/";
  v8 = "GNU coreutils";
  printf(v1, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  v12 = setlocale(5, 0);
  if ( v12 && strncmp(v12, "en_", 3u) )
  {
    v2 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
    v8 = s1;
    printf(v2, s1);
  }
  v3 = gettext("Full documentation at: <%s%s>\n");
  v9 = s1;
  v8 = "http://www.gnu.org/software/coreutils/";
  printf(v3, "http://www.gnu.org/software/coreutils/", s1);
  if ( v10 == s1 )
    v4 = " invocation";
  else
    v4 = &locale;
  v5 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  v9 = v4;
  v8 = v10;
  return printf(v5, v10, v4);
}

//----- (0804A999) --------------------------------------------------------
int __cdecl sub_804A999(int a1, int a2)
{
  return sub_805AD11(a1, a2);
}

//----- (0804A9B8) --------------------------------------------------------
int __cdecl sub_804A9B8(int a1)
{
  return a1;
}

//----- (0804A9C0) --------------------------------------------------------
bool __cdecl sub_804A9C0(int a1)
{
  return a1 == 95;
}

//----- (0804A9CC) --------------------------------------------------------
int sub_804A9CC()
{
  return 0;
}

//----- (0804A9D6) --------------------------------------------------------
int __cdecl sub_804A9D6(int a1, int a2, int a3, int a4)
{
  _DWORD *v4; // ST3C_4
  int result; // eax

  if ( (unsigned int)(*((_DWORD *)&unk_8071915 + 4) - *((_DWORD *)&unk_8071915 + 3)) < 0x10 )
    sub_8062976((int)&unk_8071915, 16);
  *((_DWORD *)&unk_8071915 + 3) += 16;
  v4 = (_DWORD *)(dword_8071921 - 16);
  v4[2] = a1;
  v4[3] = a2;
  result = a3;
  *v4 = a3;
  v4[1] = a4;
  return result;
}
// 8071921: using guessed type int dword_8071921;

//----- (0804AAC5) --------------------------------------------------------
_DWORD *__stdcall sub_804AAC5(_DWORD *a1)
{
  _DWORD *v1; // edx

  if ( (unsigned int)(*((_DWORD *)&unk_8071915 + 3) - *((_DWORD *)&unk_8071915 + 2)) < 0x10 )
    __assert_fail("dev_ino_size <= obstack_object_size (&dev_ino_obstack)", "src/ls.c", 0x402u, "dev_ino_pop");
  dword_8071921 -= 16;
  v1 = (_DWORD *)dword_8071921;
  *a1 = *(_DWORD *)dword_8071921;
  a1[1] = v1[1];
  a1[2] = v1[2];
  a1[3] = v1[3];
  return a1;
}
// 8071921: using guessed type int dword_8071921;

//----- (0804AB78) --------------------------------------------------------
unsigned int __cdecl sub_804AB78(int a1, int a2)
{
  unsigned int result; // eax
  int v3; // [esp+4h] [ebp-34h]
  unsigned int i; // [esp+18h] [ebp-20h]
  int v5; // [esp+1Ch] [ebp-1Ch]
  unsigned int v6; // [esp+20h] [ebp-18h]
  int v7; // [esp+24h] [ebp-14h]
  int v8; // [esp+28h] [ebp-10h]
  int v9; // [esp+2Ch] [ebp-Ch]

  v5 = a2;
  result = (unsigned int)(*(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 8)) >> 2;
  v6 = (unsigned int)(*(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 8)) >> 2;
  if ( result )
  {
    v7 = a2;
    v8 = *(_DWORD *)(a2 + 8);
    if ( *(_DWORD *)(a2 + 12) == v8 )
      *(_BYTE *)(v7 + 40) |= 2u;
    *(_DWORD *)(v7 + 12) = (*(_DWORD *)(v7 + 24) + *(_DWORD *)(v7 + 12)) & ~*(_DWORD *)(v7 + 24);
    if ( *(_DWORD *)(v7 + 12) - *(_DWORD *)(v7 + 4) > (unsigned int)(*(_DWORD *)(v7 + 16) - *(_DWORD *)(v7 + 4)) )
      *(_DWORD *)(v7 + 12) = *(_DWORD *)(v7 + 16);
    *(_DWORD *)(v7 + 8) = *(_DWORD *)(v7 + 12);
    v9 = v8;
    fputs_unlocked(a1, stdout);
    for ( i = 0; i < v6; ++i )
    {
      v3 = *(_DWORD *)(4 * i + v9);
      printf(" %lu", v3);
    }
    result = putchar_unlocked(10);
  }
  return result;
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804ACD3) --------------------------------------------------------
#error "804AD51: call analysis failed (funcsize=37)"

//----- (0804AD5F) --------------------------------------------------------
void sub_804AD5F()
{
  char v0; // bl
  bool v1; // al
  signed int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; i <= 255; ++i )
  {
    v0 = *(_BYTE *)(i + 134682965);
    v1 = (unsigned __int8)sub_8055DF6(i) || i == 126 || i == 45 || i == 46 || i == 95;
    *(_BYTE *)(i + 134682965) = v0 | v1;
  }
}

//----- (0804ADE1) --------------------------------------------------------
signed int __cdecl sub_804ADE1(int a1)
{
  int v2; // eax
  int v3; // [esp+28h] [ebp-20h]
  unsigned int v4; // [esp+2Ch] [ebp-1Ch]
  int i; // [esp+30h] [ebp-18h]
  unsigned int v6; // [esp+34h] [ebp-14h]
  char *s; // [esp+38h] [ebp-10h]
  unsigned int v8; // [esp+3Ch] [ebp-Ch]

  v4 = 5;
  do
  {
    v6 = v4;
    v4 = 0;
    for ( i = 0; i <= 11; ++i )
    {
      v3 = v6;
      s = nl_langinfo(i + 131086);
      if ( strchr(s, 37) )
        return 0;
      v8 = sub_805B08E(s, a1 + (i << 7), 128, (int)&v3, 0, 0);
      if ( v8 > 0x7F )
        return 0;
      v2 = v4;
      if ( v3 >= v4 )
        v2 = v3;
      v4 = v2;
    }
  }
  while ( v6 > v4 );
  return 1;
}

//----- (0804AECB) --------------------------------------------------------
#error "804AFB5: call analysis failed (funcsize=64)"

//----- (0804B117) --------------------------------------------------------
int __cdecl sub_804B117(unsigned __int64 *a1, unsigned int a2)
{
  return sub_80647BA(*a1, a2);
}

//----- (0804B15E) --------------------------------------------------------
int __cdecl sub_804B15E(_QWORD *a1, _QWORD *a2)
{
  return *a1 == *a2 && a2[1] == a1[1];
}

//----- (0804B1E2) --------------------------------------------------------
void __cdecl sub_804B1E2(void *ptr)
{
  free(ptr);
}

//----- (0804B1F5) --------------------------------------------------------
void __cdecl __noreturn sub_804B1F5(int a1, int a2, int a3, int a4)
{
  _DWORD *v4; // [esp+28h] [ebp-10h]

  v4 = sub_80615D3(0x10u);
  *v4 = a3;
  v4[1] = a4;
  v4[2] = a1;
  v4[3] = a2;
  sub_80590B0(dword_8071715, (int)v4);
}
// 8071715: using guessed type int dword_8071715;

//----- (0804B2BD) --------------------------------------------------------
void __cdecl sub_804B2BD(void *ptr)
{
  free(*(void **)ptr);
  free(*((void **)ptr + 1));
  free(ptr);
}

//----- (0804B2EB) --------------------------------------------------------
int __cdecl sub_804B2EB(int a1)
{
  int v3; // [esp+18h] [ebp-10h]
  char *s1; // [esp+1Ch] [ebp-Ch]

  v3 = dword_80712A8[2 * a1];
  s1 = (char *)*(&off_80712AC + 2 * a1);
  return v3 && (v3 != 1 || *s1 != unk_8066339) && (v3 != 2 || strncmp(s1, "00", 2u));
}
// 80712A8: using guessed type int dword_80712A8[];
// 80712AC: using guessed type void *off_80712AC;

//----- (0804B377) --------------------------------------------------------
size_t sub_804B377()
{
  sub_80546A8((int)dword_80712A8);
  return sub_80546A8((int)&dword_80712B0);
}
// 80712A8: using guessed type int dword_80712A8[];
// 80712B0: using guessed type int dword_80712B0;

//----- (0804B397) --------------------------------------------------------
size_t sub_804B397()
{
  size_t result; // eax

  result = (unsigned __int8)byte_8071799;
  if ( byte_8071799 )
  {
    result = sub_804B2EB(4);
    if ( (_BYTE)result )
    {
      sub_80546A8((int)dword_80712A8);
      sub_80546A8((int)&unk_80712C8);
      result = sub_80546A8((int)&dword_80712B0);
    }
  }
  return result;
}
// 80712A8: using guessed type int dword_80712A8[];
// 80712B0: using guessed type int dword_80712B0;
// 8071799: using guessed type char byte_8071799;

//----- (0804B3DE) --------------------------------------------------------
int __cdecl sub_804B3DE(int a1)
{
  int result; // eax

  result = dword_8071875;
  if ( !dword_8071875 )
  {
    result = a1;
    dword_8071875 = a1;
  }
  return result;
}
// 8071875: using guessed type int dword_8071875;

//----- (0804B3F4) --------------------------------------------------------
int sub_804B3F4()
{
  int result; // eax

  result = dword_8071875;
  if ( !dword_8071875 )
    result = dword_8071879++ + 1;
  return result;
}
// 8071875: using guessed type int dword_8071875;
// 8071879: using guessed type int dword_8071879;

//----- (0804B40F) --------------------------------------------------------
int sub_804B40F()
{
  int result; // eax
  int v1; // [esp+0h] [ebp-A8h]
  int v2; // [esp+4h] [ebp-A4h]
  int v3; // [esp+8h] [ebp-A0h]
  int v4; // [esp+Ch] [ebp-9Ch]
  int v5; // [esp+10h] [ebp-98h]
  int v6; // [esp+14h] [ebp-94h]
  int sig; // [esp+18h] [ebp-90h]
  int siga; // [esp+18h] [ebp-90h]
  int v9; // [esp+1Ch] [ebp-8Ch]
  sigset_t oset; // [esp+20h] [ebp-88h]

  dword_8071238 = (int)&loc_804B4E5;
  sub_8064C1B(
    v1,
    v2,
    v3,
    v4,
    v5,
    v6,
    sig,
    v9,
    oset.__val[0],
    oset.__val[1],
    oset.__val[2],
    oset.__val[3],
    oset.__val[4],
    oset.__val[5],
    oset.__val[6],
    oset.__val[7],
    oset.__val[8],
    oset.__val[9],
    oset.__val[10],
    oset.__val[11],
    oset.__val[12],
    oset.__val[13],
    oset.__val[14],
    oset.__val[15],
    oset.__val[16],
    oset.__val[17],
    oset.__val[18],
    oset.__val[19],
    oset.__val[20],
    oset.__val[21],
    oset.__val[22],
    oset.__val[23],
    oset.__val[24],
    oset.__val[25],
    oset.__val[26]);
  while ( 1 )
  {
    if ( byte_807179B )
      sub_804B377();
    fflush_unlocked(stdout);
    sigprocmask(0, &set, &oset);
    siga = dword_8071875;
    if ( dword_8071879 )
    {
      --dword_8071879;
      raise(19);
    }
    else
    {
      signal(dword_8071875, 0);
      raise(siga);
    }
    sigprocmask(2, &oset, 0);
    if ( !dword_8071875 )
    {
      result = dword_8071879;
      if ( !dword_8071879 )
        break;
    }
  }
  return result;
}
// 8064C1B: using guessed type int __stdcall sub_8064C1B(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8071238: using guessed type int dword_8071238;
// 807179B: using guessed type char byte_807179B;
// 8071875: using guessed type int dword_8071875;
// 8071879: using guessed type int dword_8071879;

//----- (0804B501) --------------------------------------------------------
__sighandler_t __cdecl sub_804B501(void (*a1)(int))
{
  __sighandler_t result; // eax
  void *v2; // eax
  signed int i; // [esp+10h] [ebp-A8h]
  signed int j; // [esp+10h] [ebp-A8h]
  signed int k; // [esp+10h] [ebp-A8h]
  void *v6; // [esp+14h] [ebp-A4h]
  char v7; // [esp+18h] [ebp-A0h]
  int v8; // [esp+98h] [ebp-20h]

  result = a1;
  if ( (_BYTE)a1 )
  {
    sigemptyset(&set);
    for ( i = 0; i <= 11; ++i )
    {
      sigaction(sig[i], 0, (struct sigaction *)&v6);
      if ( v6 != (void *)1 )
        sigaddset(&set, sig[i]);
    }
    result = (__sighandler_t)32;
    qmemcpy(&v7, &set, 0x80u);
    v8 = 0x10000000;
    for ( j = 0; j <= 11; ++j )
    {
      result = (__sighandler_t)sigismember(&set, sig[j]);
      if ( result )
      {
        if ( sig[j] == 20 )
          v2 = sub_804B3F4;
        else
          v2 = sub_804B3DE;
        v6 = v2;
        result = (__sighandler_t)sigaction(sig[j], (const struct sigaction *)&v6, 0);
      }
    }
  }
  else
  {
    for ( k = 0; k <= 11; ++k )
    {
      result = (__sighandler_t)sigismember(&set, sig[k]);
      if ( result )
        result = signal(sig[k], 0);
    }
  }
  return result;
}

//----- (0804B6A8) --------------------------------------------------------
__sighandler_t sub_804B6A8()
{
  return sub_804B501((void (*)(int))1);
}

//----- (0804B6BC) --------------------------------------------------------
__sighandler_t sub_804B6BC()
{
  return sub_804B501(0);
}

//----- (0804B6D0) --------------------------------------------------------
void __cdecl main(int a1, char **a2)
{
  char v2; // al

  sub_805E990(*a2);
  setlocale(6, &locale);
  bindtextdomain("coreutils", "/home/hwangdz/coreutils/coreutils-8.28/install_m32/share/locale");
  textdomain("coreutils");
  sub_804A728(2);
  sub_80649F2((int)&loc_80561B4);
  dword_807187D = 0;
  byte_80717CD = 1;
  dword_8071739 = 0;
  tp.tv_sec = 2147483648;
  tp.tv_nsec = -1;
  sub_804C2EA(a1, a2);
  dword_8071254 = (int (*)(void))&loc_804B7B2;
  JUMPOUT(byte_8071799, 0, &loc_8058DC6);
  sub_804D92A((int)&a1);
  dword_8071254 = (int (*)(void))&loc_804B894;
  JUMPOUT(byte_8071799, 0, &loc_8058DC6);
  v2 = sub_804B2EB(13);
  dword_8071254 = (int (*)(void))&loc_804B88D;
  JUMPOUT(v2, 0, &loc_8058DC6);
  JUMPOUT(sub_804B2EB(14), 0, &loc_8058DC6);
  dword_8071254 = (int (*)(void))&loc_804B88D;
  JUMPOUT(byte_8071731, 0, &loc_8058DC6);
  JUMPOUT(sub_804B2EB(12), 0, &loc_8058DC6);
  JUMPOUT(dword_8071771, 0, &loc_8058DC6);
  byte_80717A5 = 1;
  JUMPOUT(dword_80717A9, 1, &loc_8058DC6);
  JUMPOUT(byte_80717AE, 0, &loc_8058DC6);
  JUMPOUT(dword_8071795, 3, &loc_8058DC6);
  dword_8071254 = (int (*)(void))&loc_804B91C;
  JUMPOUT(dword_8071771, 0, &loc_8058DC6);
  dword_8071254 = (int (*)(void))&loc_804B921;
  JUMPOUT(&loc_8058DC6);
}
// 8071254: using guessed type int (*dword_8071254)(void);
// 8071731: using guessed type char byte_8071731;
// 8071739: using guessed type int dword_8071739;
// 8071771: using guessed type int dword_8071771;
// 8071795: using guessed type int dword_8071795;
// 8071799: using guessed type char byte_8071799;
// 80717A5: using guessed type char byte_80717A5;
// 80717A9: using guessed type int dword_80717A9;
// 80717AE: using guessed type char byte_80717AE;
// 80717CD: using guessed type char byte_80717CD;
// 807187D: using guessed type int dword_807187D;

//----- (0804BA76) --------------------------------------------------------
void __fastcall sub_804BA76(int a1, int a2)
{
  byte_80717D9 = 0;
  dword_8071254 = (int (*)(void))sub_804BB42;
  dword_80711DC = (int)&loc_804BAB8;
  sub_8064E3D(a1, a2);
  JUMPOUT(byte_80717AD, 0, &loc_8058DC6);
  JUMPOUT(byte_8071799, 0, &loc_8058DC6);
  JUMPOUT(dword_8071795, 0, &loc_8058DC6);
  dword_8071254 = (int (*)(void))sub_804BB42;
  JUMPOUT(byte_80717AF, 0, &loc_8058DC6);
  dword_8071254 = (int (*)(void))&loc_804BB47;
  JUMPOUT(&loc_8058DC6);
}
// 804BB42: using guessed type int __cdecl sub_804BB42(int, int, int, int, int);
// 8064E3D: using guessed type double __fastcall sub_8064E3D(_DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;
// 8071254: using guessed type int (*dword_8071254)(void);
// 8071795: using guessed type int dword_8071795;
// 8071799: using guessed type char byte_8071799;
// 80717AD: using guessed type char byte_80717AD;
// 80717AF: using guessed type char byte_80717AF;
// 80717D9: using guessed type char byte_80717D9;

//----- (0804BB42) --------------------------------------------------------
#error "804BB93: call analysis failed (funcsize=72)"

//----- (0804BCD0) --------------------------------------------------------
#error "804BCE7: call analysis failed (funcsize=8)"

//----- (0804BCFF) --------------------------------------------------------
#error "804BD51: call analysis failed (funcsize=70)"

//----- (0804BE3F) --------------------------------------------------------
#error "804BEB3: call analysis failed (funcsize=32)"

//----- (0804BECF) --------------------------------------------------------
#error "804BF35: positive sp value has been found (funcsize=24)"

//----- (0804BF8B) --------------------------------------------------------
#error "804BF91: call analysis failed (funcsize=10)"

//----- (0804C25A) --------------------------------------------------------
signed int __cdecl sub_804C25A(char *nptr)
{
  int v1; // eax
  int v2; // eax
  signed int result; // eax
  int v4; // [esp+28h] [ebp-10h]
  int v5; // [esp+2Ch] [ebp-Ch]

  v1 = sub_80621FE(nptr, 0, 0, (int)&v4, &locale);
  if ( v1 )
  {
    if ( v1 == 1 )
    {
      dword_80717D1 = -1;
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    v2 = v4;
    if ( v5 )
      v2 = -1;
    dword_80717D1 = v2;
    result = 1;
  }
  return result;
}
// 80717D1: using guessed type int dword_80717D1;

//----- (0804C2EA) --------------------------------------------------------
int __cdecl sub_804C2EA(int argc, char **argv)
{
  int v2; // eax
  int v3; // ebx
  char *v4; // eax
  int v5; // eax
  int v6; // ebx
  char *v7; // eax
  int v8; // edx
  int v9; // ecx
  signed int v10; // eax
  bool v11; // zf
  int v12; // edx
  int v13; // ecx
  void *v14; // eax
  const char *v15; // eax
  const char *v16; // ebx
  char *v17; // eax
  char *v18; // eax
  int v19; // edx
  int v20; // ecx
  bool v21; // al
  bool v22; // al
  int v23; // edx
  int v24; // ecx
  int v25; // eax
  const char *v26; // eax
  bool v27; // al
  void *v28; // eax
  void *v29; // eax
  void *v30; // eax
  int v31; // eax
  int v32; // ebx
  char *v33; // eax
  char *v34; // eax
  FILE *v35; // ebx
  char *v36; // eax
  int **v37; // eax
  FILE *v38; // ebx
  char *v39; // eax
  char *v40; // eax
  int result; // eax
  char *v42; // [esp+0h] [ebp-88h]
  int v43; // [esp+4h] [ebp-84h]
  int *v44; // [esp+8h] [ebp-80h]
  char *v45; // [esp+Ch] [ebp-7Ch]
  const char *v46; // [esp+10h] [ebp-78h]
  const char *v47; // [esp+14h] [ebp-74h]
  int v48; // [esp+18h] [ebp-70h]
  int v49; // [esp+1Ch] [ebp-6Ch]
  int v50; // [esp+20h] [ebp-68h]
  int v51; // [esp+24h] [ebp-64h]
  int v52; // [esp+28h] [ebp-60h]
  int v53; // [esp+2Ch] [ebp-5Ch]
  int v54; // [esp+30h] [ebp-58h]
  char *v55; // [esp+34h] [ebp-54h]
  int v56; // [esp+38h] [ebp-50h]
  int v57; // [esp+3Ch] [ebp-4Ch]
  unsigned __int8 *i; // [esp+40h] [ebp-48h]
  char *s1; // [esp+44h] [ebp-44h]
  char *v60; // [esp+48h] [ebp-40h]
  char **v61; // [esp+4Ch] [ebp-3Ch]
  int j; // [esp+50h] [ebp-38h]
  char *v63; // [esp+54h] [ebp-34h]
  char *nptr; // [esp+58h] [ebp-30h]
  int v65; // [esp+5Ch] [ebp-2Ch]
  char *v66; // [esp+60h] [ebp-28h]
  int v67; // [esp+64h] [ebp-24h]
  char *s; // [esp+68h] [ebp-20h]
  int v69; // [esp+6Ch] [ebp-1Ch]
  _DWORD *v70; // [esp+70h] [ebp-18h]
  int v71; // [esp+74h] [ebp-14h]
  int longind; // [esp+78h] [ebp-10h]
  int v73; // [esp+7Ch] [ebp-Ch]
  int v74; // [esp+80h] [ebp-8h]
  int v75; // [esp+84h] [ebp-4h]
  int savedregs; // [esp+88h] [ebp+0h]

  v55 = 0;
  HIWORD(v54) = 0;
  byte_80717BD = 0;
  if ( dword_80713B0 == 2 )
  {
    dword_8071771 = 2;
    sub_805EAF7(0, 7);
  }
  else if ( dword_80713B0 == 3 )
  {
    dword_8071771 = 0;
    sub_805EAF7(0, 7);
  }
  else
  {
    if ( dword_80713B0 != 1 )
      abort();
    if ( isatty(1) )
    {
      dword_8071771 = 2;
      sub_805EAF7(0, 3);
      byte_80717BD = 1;
    }
    else
    {
      dword_8071771 = 1;
      byte_80717BD = 0;
    }
  }
  dword_8071775 = 0;
  dword_8071779 = 0;
  byte_807177D = 0;
  byte_807177F = 0;
  byte_8071780 = 0;
  dword_8071795 = 0;
  byte_80717A6 = 0;
  dword_80717A9 = 1;
  byte_80717AD = 0;
  byte_80717AE = 0;
  dword_80717B1 = 0;
  dword_80717B5 = 0;
  dword_80717B9 = 0;
  byte_8071745 = 0;
  sub_804DD19();
  dword_80717D1 = 80;
  v63 = getenv("COLUMNS");
  if ( v63 && *v63 && (unsigned __int8)sub_804C25A(v63) ^ 1 )
  {
    v42 = v63;
    sub_806073A();
    v3 = v2;
    v4 = gettext("ignoring invalid width in environment variable COLUMNS: %s");
    v45 = (char *)v3;
    error(0, 0, v4);
  }
  v44 = &longind;
  if ( ioctl(1, 0x5413u) != -1 && HIWORD(longind) )
    dword_80717D1 = HIWORD(longind);
  nptr = getenv("TABSIZE");
  dword_80717C9 = 8;
  if ( nptr )
  {
    if ( sub_8061B42(nptr, 0, 0, (int)&longind, 0) )
    {
      v42 = nptr;
      sub_806073A();
      v6 = v5;
      v7 = gettext("ignoring invalid tab size in environment variable TABSIZE: %s");
      v45 = (char *)v6;
      error(0, 0, v7);
    }
    else
    {
      dword_80717C9 = longind;
    }
  }
  while ( 1 )
  {
    longind = -1;
    v65 = getopt_long(argc, argv, "abcdfghiklmnopqrstuvw:xABCDFGHI:LNQRST:UXZ1", &longopts, &longind);
    if ( v65 == -1 )
      break;
    switch ( v65 )
    {
      case 4294967165:
        if ( dword_80713B0 == 1 )
        {
          v26 = "ls";
        }
        else if ( dword_80713B0 == 2 )
        {
          v26 = "dir";
        }
        else
        {
          v26 = "vdir";
        }
        v48 = 0;
        v47 = "David MacKenzie";
        v46 = "Richard M. Stallman";
        sub_8061416(stdout, (int)v26, (int)"GNU coreutils", off_80713B4, "Richard M. Stallman", "David MacKenzie", 0);
        exit(0);
        return result;
      case 4294967166:
        sub_805538B(0);
        return result;
      case 49:
        goto LABEL_75;
      case 65:
        if ( !dword_80717B1 )
        {
          dword_80717B1 = 1;
          dword_80711FC = (int)&loc_804CF37;
          sub_8064D6B(v42, v43, v44, v45, v46, v47, v48);
        }
        continue;
      case 66:
        sub_804E6DA((int)"*~");
        sub_804E6DA((int)".*~");
        continue;
      case 67:
        dword_8071771 = 2;
        continue;
      case 68:
        byte_8071791 = 1;
        continue;
      case 70:
        dword_8071795 = 3;
        continue;
      case 71:
        byte_807128B = 0;
        dword_8071210 = (int)&loc_804CF37;
        sub_8064CF3(v9, v8);
        goto LABEL_64;
      case 72:
LABEL_64:
        dword_80717A9 = 3;
        continue;
      case 73:
        goto LABEL_66;
      case 76:
        dword_80717A9 = 5;
        continue;
      case 78:
        sub_805EAF7(0, 0);
        continue;
      case 81:
        sub_805EAF7(0, 5);
        continue;
      case 82:
        byte_80717AD = 1;
        continue;
      case 83:
        dword_8071779 = 2;
        BYTE2(v54) = 1;
        continue;
      case 84:
        v18 = gettext("invalid tab size");
        dword_80717C9 = sub_80617A1((int)optarg, 0, 0, 0, -1, 0, (int)&locale, (int)v18, 2);
        continue;
      case 85:
        dword_8071779 = -1;
        BYTE2(v54) = 1;
        continue;
      case 88:
        dword_8071779 = 1;
        BYTE2(v54) = 1;
        dword_8071224 = (int)&loc_804CF37;
        sub_8064C87(
          v42,
          v43,
          v44,
          v45,
          v46,
          v47,
          v48,
          v49,
          v50,
          v51,
          v52,
          v53,
          v54,
          v55,
          v56,
          v57,
          i,
          s1,
          v60,
          v61,
          j,
          v63,
          nptr);
LABEL_75:
        if ( dword_8071771 )
          dword_8071771 = 1;
        continue;
      case 90:
        byte_8071745 = 1;
        continue;
      case 97:
        dword_80717B1 = 2;
        continue;
      case 98:
        sub_805EAF7(0, 7);
        continue;
      case 99:
        dword_8071775 = 1;
        continue;
      case 100:
        byte_80717AE = 1;
        continue;
      case 102:
        dword_80717B1 = 2;
        dword_8071779 = -1;
        BYTE2(v54) = 1;
        if ( !dword_8071771 )
        {
          if ( isatty(1) )
            v10 = 2;
          else
            v10 = 1;
          dword_8071771 = v10;
        }
        byte_8071780 = 0;
        byte_8071799 = 0;
        byte_807179A = 0;
        continue;
      case 103:
        dword_8071771 = 0;
        byte_807128A = 0;
        continue;
      case 104:
        dword_8071781 = 176;
        dword_807178D = 176;
        qword_8071785 = 1LL;
        qword_8071290 = 1LL;
        continue;
      case 105:
        byte_80717A6 = 1;
        continue;
      case 107:
        HIBYTE(v54) = 1;
        continue;
      case 108:
        dword_8071771 = 0;
        continue;
      case 109:
        dword_8071771 = 4;
        continue;
      case 110:
        byte_807177F = 1;
        dword_8071771 = 0;
        continue;
      case 111:
        dword_8071771 = 0;
        byte_807128B = 0;
        continue;
      case 112:
        dword_8071795 = 1;
        continue;
      case 113:
        byte_80717BD = 1;
        continue;
      case 114:
        byte_807177D = 1;
        dword_80711DC = (int)&loc_804CF37;
        sub_8064E3D(v9, v8);
        goto LABEL_48;
      case 115:
LABEL_48:
        byte_8071780 = 1;
        continue;
      case 116:
        dword_8071779 = 4;
        BYTE2(v54) = 1;
        continue;
      case 117:
        dword_8071775 = 2;
        dword_80711FC = (int)&loc_804CF37;
        sub_8064D6B(v42, v43, v44, v45, v46, v47, v48);
        goto LABEL_51;
      case 118:
LABEL_51:
        dword_8071779 = 3;
        BYTE2(v54) = 1;
        dword_80711DC = (int)&loc_804CF37;
        sub_8064E3D(v9, v8);
        goto LABEL_52;
      case 119:
LABEL_52:
        v11 = (unsigned __int8)sub_804C25A(optarg) == 1;
        v14 = &loc_804C81F;
        if ( v11 )
          v14 = &loc_804C85E;
        dword_80711DC = (int)v14;
        sub_8064E3D(v13, v12);
        v42 = optarg;
        sub_806073A();
        v16 = v15;
        v17 = gettext("invalid line width");
        v46 = v16;
        v45 = v17;
        error(2, 0, "%s: %s");
        continue;
      case 120:
        dword_8071771 = 3;
        continue;
      case 128:
        byte_807177E = 1;
        continue;
      case 129:
        v71 = sub_805A879(optarg, (int)&dword_8071781, (int)&qword_8071785);
        if ( v71 )
          sub_8062090(v71, longind, 0, (int)&longopts, (int)optarg);
        dword_807178D = dword_8071781;
        qword_8071290 = qword_8071785;
        continue;
      case 130:
        if ( optarg )
          v56 = dword_80669B0[sub_8055CFA((int)"--color", optarg, (int)off_8066970, (int)dword_80669B0, 4u, off_80713B8)];
        else
          v56 = 1;
        v21 = v56 == 1 || v56 == 2 && isatty(1);
        byte_8071799 = v21;
        if ( v21 )
        {
          dword_80717C9 = 0;
        }
        else
        {
          dword_8071238 = (int)&loc_804CF37;
          sub_8064C1B(
            v42,
            v43,
            v44,
            v45,
            v46,
            v47,
            v48,
            v49,
            v50,
            v51,
            v52,
            v53,
            v54,
            v55,
            v56,
            v57,
            i,
            s1,
            v60,
            v61,
            j,
            v63,
            nptr,
            v65,
            v66,
            v67,
            s,
            v69,
            v70,
            v71,
            longind,
            v73,
            v74,
            v75,
            savedregs);
LABEL_96:
          if ( optarg )
            v57 = dword_80669B0[sub_8055CFA(
                                  (int)"--hyperlink",
                                  optarg,
                                  (int)off_8066970,
                                  (int)dword_80669B0,
                                  4u,
                                  off_80713B8)];
          else
            v57 = 1;
          v22 = v57 == 1 || v57 == 2 && isatty(1);
          byte_807179A = v22;
        }
        continue;
      case 131:
        dword_80717A9 = 4;
        dword_80711FC = (int)&loc_804CF37;
        sub_8064D6B(v42, v43, v44, v45, v46, v47, v48);
LABEL_66:
        sub_804E6DA((int)optarg);
        continue;
      case 132:
        dword_8071795 = 2;
        continue;
      case 133:
        dword_8071771 = dword_8066890[sub_8055CFA(
                                        (int)"--format",
                                        optarg,
                                        (int)off_8066870,
                                        (int)dword_8066890,
                                        4u,
                                        off_80713B8)];
        continue;
      case 134:
        dword_8071771 = 0;
        v55 = (char *)sub_804A9B8((int)"full-iso");
        continue;
      case 135:
        goto LABEL_81;
      case 136:
        v70 = sub_80615D3(8u);
        *v70 = optarg;
        v70[1] = dword_80717B9;
        dword_80717B9 = (int)v70;
        dword_80711FC = (int)&loc_804CF37;
        sub_8064D6B(v42, v43, v44, v45, v46, v47, v48);
        goto LABEL_80;
      case 137:
        goto LABEL_96;
      case 138:
        dword_8071795 = dword_8066260[sub_8055CFA(
                                        (int)"--indicator-style",
                                        optarg,
                                        (int)off_806624C,
                                        (int)dword_8066260,
                                        4u,
                                        off_80713B8)];
        dword_80711DC = (int)&loc_804CF37;
        sub_8064E3D(v24, v23);
        goto LABEL_106;
      case 139:
LABEL_106:
        v25 = sub_8055CFA((int)"--quoting-style", optarg, (int)off_8069AF0, (int)dword_8069B30, 4u, off_80713B8);
        sub_805EAF7(0, dword_8069B30[v25]);
        continue;
      case 140:
        byte_80717BD = 0;
        continue;
      case 141:
        dword_8071781 = 144;
        dword_807178D = 144;
        qword_8071785 = 1LL;
        qword_8071290 = 1LL;
        continue;
      case 142:
LABEL_80:
        dword_8071779 = dword_80668D0[sub_8055CFA(
                                        (int)"--sort",
                                        optarg,
                                        (int)off_80668B8,
                                        (int)dword_80668D0,
                                        4u,
                                        off_80713B8)];
        BYTE2(v54) = 1;
        dword_8071210 = (int)&loc_804CF37;
        sub_8064CF3(v20, v19);
LABEL_81:
        byte_80717AF = 1;
        dword_80711DC = (int)&loc_804CF37;
        sub_8064E3D(v9, v8);
        goto LABEL_82;
      case 143:
LABEL_82:
        dword_8071775 = dword_806691C[sub_8055CFA(
                                        (int)"--time",
                                        optarg,
                                        (int)off_8066904,
                                        (int)dword_806691C,
                                        4u,
                                        off_80713B8)];
        break;
      case 144:
        v55 = optarg;
        break;
      default:
        sub_805538B(2);
        return result;
    }
  }
  if ( !qword_8071785 )
  {
    v66 = getenv("LS_BLOCK_SIZE");
    sub_805A879(v66, (int)&dword_8071781, (int)&qword_8071785);
    if ( v66 || getenv("BLOCK_SIZE") )
    {
      dword_807178D = dword_8071781;
      qword_8071290 = qword_8071785;
    }
    if ( HIBYTE(v54) )
    {
      dword_8071781 = 0;
      qword_8071785 = 1024LL;
    }
  }
  dword_8071885 = (dword_80717D1 % 3u != 0) + dword_80717D1 / 3u;
  v67 = sub_805EAD4(0);
  v27 = dword_8071771 != 4
     && dword_8071771 != 1
     && (dword_80717D1 || !dword_8071771)
     && (v67 == 1 || v67 == 3 || v67 == 6);
  byte_8071726 = v27;
  dword_80717C1 = (int)sub_805EA82(0);
  if ( v67 == 7 )
    sub_805EB11((int *)dword_80717C1, 0x20u, 1);
  if ( (unsigned int)dword_8071795 > 1 )
  {
    for ( i = (unsigned __int8 *)(dword_8071795 - 2 + 134638692); *i; ++i )
      sub_805EB11((int *)dword_80717C1, *i, 1);
  }
  dword_80717C5 = (int)sub_805EA82(0);
  sub_805EB11((int *)dword_80717C5, 0x3Au, 1);
  if ( byte_8071791 && (dword_8071771 || byte_807179A) )
    byte_8071791 = 0;
  v28 = &loc_804D166;
  if ( dword_8071775 == 1 )
    v28 = &loc_804D189;
  dword_8071238 = (int)v28;
  sub_8064C1B(
    v42,
    v43,
    v44,
    v45,
    v46,
    v47,
    v48,
    v49,
    v50,
    v51,
    v52,
    v53,
    v54,
    v55,
    v56,
    v57,
    i,
    s1,
    v60,
    v61,
    j,
    v63,
    nptr,
    v65,
    v66,
    v67,
    s,
    v69,
    v70,
    v71,
    longind,
    v73,
    v74,
    v75,
    savedregs);
  v29 = &loc_804D189;
  if ( dword_8071775 != 2 )
    v29 = &loc_804D1A7;
  dword_8071224 = (int)v29;
  sub_8064C87(
    v42,
    v43,
    v44,
    v45,
    v46,
    v47,
    v48,
    v49,
    v50,
    v51,
    v52,
    v53,
    v54,
    v55,
    v56,
    v57,
    i,
    s1,
    v60,
    v61,
    j,
    v63,
    nptr);
  if ( BYTE2(v54) != 1 && dword_8071771 )
    dword_8071779 = 4;
  if ( !dword_8071771 )
  {
    s1 = v55;
    if ( !v55 )
    {
      s1 = getenv("TIME_STYLE");
      if ( !s1 )
        s1 = (char *)sub_804A9B8((int)"locale");
    }
    v11 = strncmp(s1, "posix-", 6u) == 0;
    v30 = &loc_804D241;
    if ( v11 )
      v30 = &loc_804D1E8;
    dword_8071224 = (int)v30;
    sub_8064C87(
      v42,
      v43,
      v44,
      v45,
      v46,
      v47,
      v48,
      v49,
      v50,
      v51,
      v52,
      v53,
      v54,
      v55,
      v56,
      v57,
      i,
      s1,
      v60,
      v61,
      j,
      v63,
      nptr);
    if ( *s1 == 43 )
    {
      s = s1 + 1;
      v60 = strchr(s1 + 1, 10);
      if ( v60 )
      {
        if ( strchr(v60 + 1, 10) )
        {
          v42 = s;
          sub_806073A();
          v32 = v31;
          v33 = gettext("invalid time style format %s");
          v45 = (char *)v32;
          error(2, 0, v33, v32);
        }
        v34 = v60++;
        *v34 = 0;
      }
      else
      {
        v60 = s;
      }
      off_8071368 = s;
      off_807136C = v60;
      goto LABEL_188;
    }
    v69 = sub_8055991(s1, (int)off_8066208, (int)&unk_806621C, 4u);
    if ( v69 < 0 )
    {
      sub_8055B34((int)"time style", (int)s1, v69);
      v35 = stderr;
      v36 = gettext("Valid arguments are:\n");
      fputs_unlocked(v36, v35);
      v61 = off_8066208;
      while ( *v61 )
      {
        v37 = (int **)v61;
        ++v61;
        v44 = *v37;
        fprintf(stderr, "  - [posix-]%s\n", v44);
      }
      v38 = stderr;
      v39 = gettext("  - +FORMAT (e.g., +%H:%M) for a 'date'-style format\n");
      fputs_unlocked(v39, v38);
      sub_805538B(2);
    }
    if ( v69 != 1 )
    {
      if ( v69 <= 1 )
      {
        if ( !v69 )
        {
          off_807136C = "%Y-%m-%d %H:%M:%S.%N %z";
          off_8071368 = "%Y-%m-%d %H:%M:%S.%N %z";
        }
        goto LABEL_188;
      }
      if ( v69 == 2 )
      {
        off_8071368 = "%Y-%m-%d ";
        off_807136C = "%m-%d %H:%M";
        dword_8071238 = (int)&loc_804D482;
        sub_8064C1B(
          v42,
          v43,
          v44,
          v45,
          v46,
          v47,
          v48,
          v49,
          v50,
          v51,
          v52,
          v53,
          v54,
          v55,
          v56,
          v57,
          i,
          s1,
          v60,
          v61,
          j,
          v63,
          nptr,
          v65,
          v66,
          v67,
          s,
          2,
          v70,
          v71,
          longind,
          v73,
          v74,
          v75,
          savedregs);
      }
      else if ( v69 != 3 )
      {
        goto LABEL_188;
      }
      if ( (unsigned __int8)sub_8057B66(2) )
      {
        for ( j = 0; j <= 1; ++j )
        {
          v40 = dcgettext(0, (&off_8071368)[j], 2);
          (&off_8071368)[j] = v40;
        }
      }
      goto LABEL_188;
    }
    off_807136C = "%Y-%m-%d %H:%M";
    off_8071368 = "%Y-%m-%d %H:%M";
LABEL_188:
    sub_804AECB();
  }
  return optind;
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 804AECB: using guessed type int sub_804AECB(void);
// 8064C1B: using guessed type int __stdcall sub_8064C1B(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8064C87: using guessed type int __stdcall sub_8064C87(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8064CF3: using guessed type int __fastcall sub_8064CF3(_DWORD, _DWORD);
// 8064D6B: using guessed type int __stdcall sub_8064D6B(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8064E3D: using guessed type double __fastcall sub_8064E3D(_DWORD, _DWORD);
// 8066208: using guessed type char *off_8066208[4];
// 806624C: using guessed type char *off_806624C[4];
// 8066870: using guessed type char *off_8066870[7];
// 8066890: using guessed type int dword_8066890[];
// 80668B8: using guessed type char *off_80668B8[5];
// 8066904: using guessed type char *off_8066904[5];
// 8066970: using guessed type char *off_8066970[4];
// 8069AF0: using guessed type char *off_8069AF0[10];
// 80711DC: using guessed type int dword_80711DC;
// 80711FC: using guessed type int dword_80711FC;
// 8071210: using guessed type int dword_8071210;
// 8071224: using guessed type int dword_8071224;
// 8071238: using guessed type int dword_8071238;
// 807128A: using guessed type char byte_807128A;
// 807128B: using guessed type char byte_807128B;
// 8071290: using guessed type __int64 qword_8071290;
// 807136C: using guessed type char *off_807136C;
// 80713B0: using guessed type int dword_80713B0;
// 8071440: using guessed type int optind;
// 8071726: using guessed type char byte_8071726;
// 8071745: using guessed type char byte_8071745;
// 8071771: using guessed type int dword_8071771;
// 8071775: using guessed type int dword_8071775;
// 8071779: using guessed type int dword_8071779;
// 807177D: using guessed type char byte_807177D;
// 807177E: using guessed type char byte_807177E;
// 807177F: using guessed type char byte_807177F;
// 8071780: using guessed type char byte_8071780;
// 8071781: using guessed type int dword_8071781;
// 8071785: using guessed type __int64 qword_8071785;
// 807178D: using guessed type int dword_807178D;
// 8071791: using guessed type char byte_8071791;
// 8071795: using guessed type int dword_8071795;
// 8071799: using guessed type char byte_8071799;
// 807179A: using guessed type char byte_807179A;
// 80717A6: using guessed type char byte_80717A6;
// 80717A9: using guessed type int dword_80717A9;
// 80717AD: using guessed type char byte_80717AD;
// 80717AE: using guessed type char byte_80717AE;
// 80717AF: using guessed type char byte_80717AF;
// 80717B1: using guessed type int dword_80717B1;
// 80717BD: using guessed type char byte_80717BD;
// 80717C1: using guessed type int dword_80717C1;
// 80717C5: using guessed type int dword_80717C5;
// 80717C9: using guessed type int dword_80717C9;
// 80717D1: using guessed type int dword_80717D1;

//----- (0804D495) --------------------------------------------------------
#error "804D5DD: call analysis failed (funcsize=280)"

//----- (0804D878) --------------------------------------------------------
signed int sub_804D878()
{
  char *s1; // [esp+18h] [ebp-10h]
  char *name; // [esp+1Ch] [ebp-Ch]

  name = getenv("TERM");
  if ( !name || !*name )
    return 0;
  for ( s1 = "# Configuration file for dircolors, a utility to help you set the";
        (unsigned int)(s1 - "# Configuration file for dircolors, a utility to help you set the") <= 0x104C;
        s1 += strlen(s1) + 1 )
  {
    if ( !strncmp(s1, "TERM ", 5u) && !fnmatch(s1 + 5, name, 0) )
      return 1;
  }
  return 0;
}

//----- (0804D92A) --------------------------------------------------------
int __usercall sub_804D92A@<eax>(int a1@<ebx>)
{
  int result; // eax
  char *v2; // edx
  int v3; // ecx
  int v4; // eax
  bool v5; // zf
  void *v6; // eax
  signed int v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  signed int v11; // eax
  int v12; // eax
  char *v13; // eax
  char *v14; // eax
  signed int v15; // eax
  char *v16; // eax
  int v17; // [esp-8h] [ebp-50h]
  int v18; // [esp-4h] [ebp-4Ch]
  char *v19; // [esp+0h] [ebp-48h]
  const char *v20; // [esp+4h] [ebp-44h]
  int v21; // [esp+Ch] [ebp-3Ch]
  char s1[2]; // [esp+1Dh] [ebp-2Bh]
  char *s; // [esp+20h] [ebp-28h]
  void *v24; // [esp+24h] [ebp-24h]
  int v25; // [esp+28h] [ebp-20h]
  _DWORD *v26; // [esp+2Ch] [ebp-1Ch]
  int v27; // [esp+30h] [ebp-18h]
  _DWORD *v28; // [esp+34h] [ebp-14h]
  void *ptr; // [esp+38h] [ebp-10h]
  char *v30; // [esp+3Ch] [ebp-Ch]

  s = getenv("LS_COLORS");
  if ( s && *s )
  {
    v26 = 0;
    strcpy(s1, "??");
    ::ptr = sub_8061743(s);
    v24 = ::ptr;
    v27 = 1;
    while ( 1 )
    {
      switch ( v27 )
      {
        case 1:
          v4 = *s;
          if ( v4 == 42 )
          {
            v26 = sub_80615D3(0x14u);
            v26[4] = dword_807179D;
            dword_807179D = (int)v26;
            ++s;
            v26[1] = v24;
            if ( (unsigned __int8)sub_804D495(&v19 - 9, &v19 - 10, 1, v26) )
              v7 = 4;
            else
              v7 = 6;
            v27 = v7;
          }
          else if ( v4 == 58 )
          {
            ++s;
          }
          else
          {
            v5 = v4 == 0;
            v18 = *s;
            v17 = a1;
            v6 = &loc_804DA16;
            if ( v5 )
              v6 = &loc_804DAA4;
            dword_80711DC = (int)v6;
            a1 = v17;
            sub_8064E3D(v3, v2);
            v8 = s;
            v2 = s++ + 1;
            s1[0] = *v8;
            v27 = 2;
          }
          continue;
        case 2:
          if ( *s )
          {
            v9 = s;
            v2 = s++ + 1;
            s1[1] = *v9;
            v27 = 3;
          }
          else
          {
            v27 = 6;
          }
          continue;
        case 3:
          v27 = 6;
          v10 = s;
          v2 = s++ + 1;
          if ( *v10 != 61 )
            continue;
          v25 = 0;
          break;
        case 4:
          v14 = s;
          v2 = s++ + 1;
          if ( *v14 == 61 )
          {
            v26[3] = v24;
            if ( (unsigned __int8)sub_804D495(&v19 - 9, &v19 - 10, 0, v26 + 2) )
              v15 = 1;
            else
              v15 = 6;
            v27 = v15;
          }
          else
          {
            v27 = 6;
          }
          continue;
        case 6:
          if ( v27 == 6 )
          {
            v16 = gettext("unparsable value for LS_COLORS environment variable");
            error(0, 0, v16);
            free(::ptr);
            v28 = (_DWORD *)dword_807179D;
            while ( v28 )
            {
              ptr = v28;
              v28 = (_DWORD *)v28[4];
              free(ptr);
            }
            byte_8071799 = 0;
          }
          result = dword_80712E0;
          if ( dword_80712E0 == 6 )
          {
            result = strncmp(::s1, "target", 6u);
            if ( !result )
              byte_8071731 = 1;
          }
          return result;
        default:
          abort();
          return result;
      }
      while ( 1 )
      {
        if ( !(&off_80662D0)[v25] )
          goto LABEL_33;
        v20 = (&off_80662D0)[v25];
        if ( !strcmp(s1, v20) )
          break;
        ++v25;
      }
      *(&off_80712AC + 2 * v25) = v24;
      v21 = 8 * v25 + 134681256;
      if ( (unsigned __int8)sub_804D495(&v24, &s, 0, v21) )
        v11 = 1;
      else
        v11 = 6;
      v27 = v11;
LABEL_33:
      if ( v27 == 6 )
      {
        v19 = s1;
        sub_806073A();
        a1 = v12;
        v13 = gettext("unrecognized prefix: %s");
        v21 = a1;
        error(0, 0, v13, a1);
      }
    }
  }
  v30 = getenv("COLORTERM");
  if ( !v30 || (result = (unsigned __int8)*v30, !(_BYTE)result) )
  {
    result = sub_804D878() ^ 1;
    if ( (_BYTE)result )
      byte_8071799 = 0;
  }
  return result;
}
// 804D495: using guessed type _DWORD __cdecl sub_804D495(_DWORD, _DWORD, _DWORD, _DWORD);
// 8064E3D: using guessed type double __fastcall sub_8064E3D(_DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;
// 80712E0: using guessed type int dword_80712E0;
// 8071731: using guessed type char byte_8071731;
// 8071799: using guessed type char byte_8071799;
// 807179D: using guessed type int dword_807179D;

//----- (0804DD19) --------------------------------------------------------
void sub_804DD19()
{
  int v0; // eax
  int v1; // ebx
  char *v2; // eax
  char *s; // [esp+18h] [ebp-10h]
  int v4; // [esp+1Ch] [ebp-Ch]

  s = getenv("QUOTING_STYLE");
  if ( s )
  {
    v4 = sub_8055991(s, (int)off_8069AF0, (int)dword_8069B30, 4u);
    if ( v4 < 0 )
    {
      sub_806073A();
      v1 = v0;
      v2 = gettext("ignoring invalid value of environment variable QUOTING_STYLE: %s");
      error(0, 0, v2, v1);
    }
    else
    {
      sub_805EAF7(0, dword_8069B30[v4]);
    }
  }
}
// 8069AF0: using guessed type char *off_8069AF0[10];

//----- (0804DDB8) --------------------------------------------------------
int __cdecl sub_804DDB8(int a1)
{
  int result; // eax

  result = a1;
  if ( (_BYTE)a1 )
  {
    dword_807187D = 2;
  }
  else
  {
    result = dword_807187D;
    if ( !dword_807187D )
      dword_807187D = 1;
  }
  return result;
}
// 807187D: using guessed type int dword_807187D;

//----- (0804DDFF) --------------------------------------------------------
int __cdecl sub_804DDFF(int a1, char *format)
{
  int v2; // eax
  int v3; // ebx
  int *v4; // eax

  sub_806029E(4);
  v3 = v2;
  v4 = __errno_location();
  error(0, *v4, format, v3);
  return sub_804DDB8((unsigned __int8)a1);
}

//----- (0804DE5D) --------------------------------------------------------
#error "804DE92: call analysis failed (funcsize=49)"

//----- (0804DF0C) --------------------------------------------------------
unsigned int __usercall sub_804DF0C@<eax>(const unsigned __int16 *a1@<ebx>, char *a2, char *a3, unsigned __int8 a4)
{
  char *v4; // eax
  unsigned int v5; // eax
  char *v6; // eax
  int v7; // ecx
  char *v8; // eax
  void *v9; // eax
  int *v10; // edx
  __int64 v11; // rax
  int v12; // ecx
  char *v13; // eax
  bool v14; // zf
  void *v15; // eax
  int v16; // edx
  int v17; // ecx
  DIR *v19; // [esp+0h] [ebp-348h]
  int v20; // [esp+4h] [ebp-344h]
  __int64 v21; // [esp+8h] [ebp-340h]
  int v22; // [esp+10h] [ebp-338h]
  int v23; // [esp+14h] [ebp-334h]
  int v24; // [esp+18h] [ebp-330h]
  int v25; // [esp+1Ch] [ebp-32Ch]
  int v26; // [esp+20h] [ebp-328h]
  unsigned __int8 v27; // [esp+24h] [ebp-324h]
  char *v28; // [esp+28h] [ebp-320h]
  char *name; // [esp+2Ch] [ebp-31Ch]
  void *ptr; // [esp+30h] [ebp-318h]
  int v31; // [esp+34h] [ebp-314h]
  DIR *dirp; // [esp+38h] [ebp-310h]
  int v33; // [esp+3Ch] [ebp-30Ch]
  int v34; // [esp+40h] [ebp-308h]
  char *s; // [esp+44h] [ebp-304h]
  __int64 v36; // [esp+48h] [ebp-300h]
  int v37; // [esp+50h] [ebp-2F8h]
  int v38; // [esp+54h] [ebp-2F4h]
  int v39; // [esp+58h] [ebp-2F0h]
  int v40; // [esp+5Ch] [ebp-2ECh]
  int v41; // [esp+60h] [ebp-2E8h]
  int v42; // [esp+64h] [ebp-2E4h]
  int v43; // [esp+68h] [ebp-2E0h]
  int v44; // [esp+6Ch] [ebp-2DCh]
  int v45; // [esp+70h] [ebp-2D8h]
  int v46; // [esp+74h] [ebp-2D4h]
  int v47; // [esp+78h] [ebp-2D0h]
  int v48; // [esp+7Ch] [ebp-2CCh]
  int v49; // [esp+80h] [ebp-2C8h]
  int v50; // [esp+84h] [ebp-2C4h]
  int v51; // [esp+88h] [ebp-2C0h]
  __int64 v52; // [esp+A8h] [ebp-2A0h]
  unsigned int v53; // [esp+33Ch] [ebp-Ch]

  name = a2;
  v28 = a3;
  v27 = a4;
  v53 = __readgsdword(0x14u);
  v36 = 0LL;
  *__errno_location() = 0;
  dirp = opendir(name);
  if ( dirp )
  {
    if ( !dword_8071715 )
    {
      sub_804E8F7();
      if ( byte_80717AD || byte_80717CD )
      {
        if ( byte_8071370 != 1 )
        {
          putchar_unlocked(10);
          ++dword_8071889;
        }
        byte_8071370 = 0;
        if ( byte_8071791 )
        {
          fwrite_unlocked("  ", 1u, 2u, stdout);
          dword_8071889 += 2;
        }
        ptr = 0;
        if ( byte_807179A )
        {
          ptr = sub_8056113(name, 2);
          if ( !ptr )
          {
            v8 = gettext("error canonicalizing %s");
            LODWORD(v21) = name;
            sub_804DDFF(v27, v8);
          }
        }
        v9 = &loc_804E254;
        if ( !v28 )
          v9 = &loc_804E25C;
        dword_8071210 = (int)v9;
        sub_8064CF3(v7, dword_80717C5);
        sub_8053732(a1, v28, v10, -1, 0, 1, (int)&unk_80718D5, (char *)ptr);
        free(ptr);
        fwrite_unlocked(":\n", 1u, 2u, stdout);
        dword_8071889 += 2;
      }
      while ( 1 )
      {
        *__errno_location() = 0;
        v19 = dirp;
        v34 = readdir64();
        if ( v34 )
        {
          if ( (unsigned __int8)sub_804E77D((char *)(v34 + 19)) ^ 1 )
          {
            v31 = 0;
            switch ( *(unsigned __int8 *)(v34 + 18) )
            {
              case 1u:
                v31 = 1;
                break;
              case 2u:
                v31 = 2;
                break;
              case 4u:
                v31 = 3;
                break;
              case 6u:
                v31 = 4;
                break;
              case 8u:
                v31 = 5;
                break;
              case 0xAu:
                v31 = 6;
                break;
              case 0xCu:
                v31 = 7;
                break;
              case 0xEu:
                v31 = 8;
                break;
              default:
                break;
            }
            sub_804ED26(v34 + 19, v31, 0LL, 0, (int)name);
            v36 += v11;
            if ( dword_8071771 == 1 )
            {
              LODWORD(v11) = &loc_804E429;
              if ( dword_8071779 != -1 )
                LODWORD(v11) = &loc_804E459;
              dword_8071210 = v11;
              sub_8064CF3(v12, HIDWORD(v11));
              if ( byte_8071780 != 1 && byte_80717AD != 1 )
              {
                sub_8051C4B();
                sub_8051DAB();
                sub_804E8F7();
              }
            }
          }
        }
        else
        {
          if ( *__errno_location() )
          {
            v13 = gettext("reading directory %s");
            LODWORD(v21) = name;
            sub_804DDFF(v27, v13);
            v14 = *__errno_location() == 75;
            v15 = &loc_804E4B7;
            if ( v14 )
              v15 = &loc_804E4E5;
            dword_80711FC = (int)v15;
            sub_8064D6B(v19, v20, v21, HIDWORD(v21), v22, v23, v24);
            dword_80711DC = (int)&loc_804E4EF;
            sub_8064E3D(v17, v16);
          }
          dword_8071238 = (int)&loc_804E4EF;
          sub_8064C1B(
            v19,
            v20,
            v21,
            HIDWORD(v21),
            v22,
            v23,
            v24,
            v25,
            v26,
            *(_DWORD *)&v27,
            v28,
            name,
            ptr,
            v31,
            dirp,
            v33,
            v34,
            s,
            v36,
            HIDWORD(v36),
            v37,
            v38,
            v39,
            v40,
            v41,
            v42,
            v43,
            v44,
            v45,
            v46,
            v47,
            v48,
            v49,
            v50,
            v51);
        }
        sub_804B40F();
      }
    }
    v33 = dirfd(dirp);
    if ( v33 < 0 )
      v5 = (unsigned int)sub_8064A21((int)name, (int)&v37) >> 31;
    else
      v5 = (unsigned int)sub_8064A50(v33, (int)&v37) >> 31;
    if ( !(_BYTE)v5 )
      sub_804B1F5(v37, v38, v52, SHIDWORD(v52));
    v6 = gettext("cannot determine device and inode of %s");
    LODWORD(v21) = name;
    sub_804DDFF(v27, v6);
    closedir(dirp);
  }
  else
  {
    v4 = gettext("cannot open directory %s");
    LODWORD(v21) = name;
    sub_804DDFF(v27, v4);
  }
  return __readgsdword(0x14u) ^ v53;
}
// 8049A80: using guessed type int readdir64(void);
// 8051DAB: using guessed type int sub_8051DAB(void);
// 8064C1B: using guessed type int __stdcall sub_8064C1B(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8064CF3: using guessed type int __fastcall sub_8064CF3(_DWORD, _DWORD);
// 8064D6B: using guessed type int __stdcall sub_8064D6B(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8064E3D: using guessed type double __fastcall sub_8064E3D(_DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;
// 80711FC: using guessed type int dword_80711FC;
// 8071210: using guessed type int dword_8071210;
// 8071238: using guessed type int dword_8071238;
// 8071370: using guessed type char byte_8071370;
// 8071440: using guessed type int optind;
// 8071715: using guessed type int dword_8071715;
// 8071771: using guessed type int dword_8071771;
// 8071779: using guessed type int dword_8071779;
// 8071780: using guessed type char byte_8071780;
// 8071791: using guessed type char byte_8071791;
// 807179A: using guessed type char byte_807179A;
// 80717AD: using guessed type char byte_80717AD;
// 80717C5: using guessed type int dword_80717C5;
// 80717CD: using guessed type char byte_80717CD;
// 8071889: using guessed type int dword_8071889;

//----- (0804E6DA) --------------------------------------------------------
_DWORD *__cdecl sub_804E6DA(int a1)
{
  _DWORD *result; // eax

  result = sub_80615D3(8u);
  *result = a1;
  result[1] = dword_80717B5;
  dword_80717B5 = (int)result;
  return result;
}

//----- (0804E71D) --------------------------------------------------------
int __usercall sub_804E71D@<eax>(int a1@<edx>, int a2@<ecx>, int a3, char *name)
{
  int v5; // [esp+1Ch] [ebp-Ch]

  v5 = a3;
  dword_8071210 = (int)&loc_804E770;
  sub_8064CF3(a2, a1);
  do
  {
    if ( !fnmatch(*(const char **)v5, name, 4) )
      return 1;
    v5 = *(_DWORD *)(v5 + 4);
  }
  while ( v5 );
  return 0;
}
// 8064CF3: using guessed type int __fastcall sub_8064CF3(_DWORD, _DWORD);
// 8071210: using guessed type int dword_8071210;

//----- (0804E77D) --------------------------------------------------------
int __cdecl sub_804E77D(char *name)
{
  int v1; // ecx
  signed int v2; // eax
  char v3; // al
  bool v4; // zf
  int v5; // edx
  int v6; // ecx
  void *v7; // eax
  char v8; // al

  if ( dword_80717B1 != 2 && *name == 46 )
  {
    if ( !dword_80717B1 )
      goto LABEL_19;
    v2 = name[1] == 46 ? 2 : 1;
    if ( !name[v2] )
      goto LABEL_19;
  }
  if ( !dword_80717B1 )
  {
    v4 = (unsigned __int8)sub_804E71D((int)name, v1, dword_80717B9, name) == 0;
    v7 = &loc_804E816;
    if ( !v4 )
      v7 = &loc_804E833;
    dword_80711DC = (int)v7;
    sub_8064E3D(v6, v5);
  }
  v3 = sub_804E71D((int)name, v1, dword_80717B5, name);
  if ( !v3 )
    v8 = 0;
  else
LABEL_19:
    v8 = 1;
  return v8 & 1;
}
// 8064E3D: using guessed type double __fastcall sub_8064E3D(_DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;
// 80717B1: using guessed type int dword_80717B1;

//----- (0804E844) --------------------------------------------------------
int __cdecl sub_804E844(int a1)
{
  return a1;
}

//----- (0804E86E) --------------------------------------------------------
int sub_804E86E()
{
  *__errno_location() = 95;
  return 0;
}

//----- (0804E886) --------------------------------------------------------
void __cdecl sub_804E886(void **a1)
{
  void *v1; // ST00_4

  free(*a1);
  free(a1[1]);
  free(a1[2]);
  if ( a1[29] != &unk_8071288 )
  {
    if ( (unsigned __int8)sub_804A9CC() )
    {
      free(a1[29]);
    }
    else
    {
      v1 = a1[29];
      sub_806096A();
    }
  }
}

//----- (0804E8F7) --------------------------------------------------------
int sub_804E8F7()
{
  int result; // eax
  unsigned int i; // [esp+18h] [ebp-10h]

  for ( i = 0; ; ++i )
  {
    result = dword_8071721;
    if ( i >= dword_8071721 )
      break;
    sub_804E886(*((void ***)dword_8071729 + i));
  }
  dword_8071721 = 0;
  byte_8071725 = 0;
  byte_8071746 = 0;
  dword_8071749 = 0;
  dword_807174D = 0;
  dword_8071751 = 0;
  dword_8071759 = 0;
  dword_807175D = 0;
  dword_8071761 = 0;
  dword_8071755 = 0;
  dword_8071765 = 0;
  dword_8071769 = 0;
  dword_807176D = 0;
  return result;
}
// 8071721: using guessed type int dword_8071721;
// 8071725: using guessed type char byte_8071725;
// 8071746: using guessed type char byte_8071746;
// 8071749: using guessed type int dword_8071749;
// 807174D: using guessed type int dword_807174D;
// 8071751: using guessed type int dword_8071751;
// 8071765: using guessed type int dword_8071765;
// 8071769: using guessed type int dword_8071769;
// 807176D: using guessed type int dword_807176D;

//----- (0804E9E9) --------------------------------------------------------
int __cdecl sub_804E9E9(int a1)
{
  return a1 == 22 || a1 == 38 || sub_804A9C0(a1);
}

//----- (0804EA27) --------------------------------------------------------
#error "804EAA3: call analysis failed (funcsize=52)"

//----- (0804EAF3) --------------------------------------------------------
#error "804EB6E: positive sp value has been found (funcsize=0)"

//----- (0804EB72) --------------------------------------------------------
int __cdecl sub_804EB72(int a1, int a2)
{
  int *v2; // eax
  int result; // eax
  int v4; // [esp+1Ch] [ebp-10h]

  if ( *(_QWORD *)(a2 + 12) == qword_807271D )
  {
    *__errno_location() = 95;
    result = 0;
  }
  else
  {
    *__errno_location() = 0;
    v4 = sub_8056D65();
    if ( v4 <= 0 )
    {
      v2 = __errno_location();
      if ( (unsigned __int8)sub_804E9E9(*v2) )
        qword_807271D = *(_QWORD *)(a2 + 12);
    }
    result = v4;
  }
  return result;
}
// 8072715: using guessed type __int64 qword_8072715;
// 807271D: using guessed type __int64 qword_807271D;

//----- (0804EC1E) --------------------------------------------------------
int __cdecl sub_804EC1E(int a1, int a2)
{
  int result; // eax
  int *v3; // eax
  int v4; // edx
  unsigned __int8 v5; // [esp+1Fh] [ebp-9h]

  if ( *(_QWORD *)(a2 + 12) == qword_8072725 )
  {
    *__errno_location() = 95;
    result = 0;
  }
  else
  {
    v5 = sub_804E86E();
    if ( v5 ^ 1 )
    {
      v3 = __errno_location();
      if ( (unsigned __int8)sub_804E9E9(*v3) )
      {
        v4 = *(_DWORD *)(a2 + 16);
        LODWORD(qword_8072725) = *(_DWORD *)(a2 + 12);
        HIDWORD(qword_8072725) = v4;
      }
    }
    result = v5;
  }
  return result;
}
// 807271D: using guessed type __int64 qword_807271D;
// 8072725: using guessed type __int64 qword_8072725;

//----- (0804ECB3) --------------------------------------------------------
int __cdecl sub_804ECB3(const char *s)
{
  size_t v1; // eax
  bool v2; // al
  __int16 v4; // [esp+2Ah] [ebp-12h]
  int v5; // [esp+2Ch] [ebp-10h]

  v5 = sub_805FB88((int)&v4, 2, (int)s, -1, (int *)dword_80717C1);
  v2 = 1;
  if ( *s == (_BYTE)v4 )
  {
    v1 = strlen(s);
    if ( v1 == v5 )
      v2 = 0;
  }
  return v2;
}
// 80717C1: using guessed type int dword_80717C1;

//----- (0804ED26) --------------------------------------------------------
void __cdecl sub_804ED26(int a1, int a2, __int64 a3, char a4, int a5)
{
  JUMPOUT(a4, 1, &loc_8058DC6);
  dword_8071254 = (int (*)(void))sub_804EDF6;
  JUMPOUT(a3, 0LL, &loc_8058DC6);
  __assert_fail("! command_line_arg || inode == NOT_AN_INODE_NUMBER", "src/ls.c", 0xC28u, "gobble_file");
}
// 8071254: using guessed type int (*dword_8071254)(void);

//----- (0804EDF6) --------------------------------------------------------
#error "804EE31: call analysis failed (funcsize=382)"

//----- (0804F4C5) --------------------------------------------------------
#error "804F4F6: call analysis failed (funcsize=23)"

//----- (0804F537) --------------------------------------------------------
void __usercall sub_804F537(int a1@<ebp>)
{
  bool v1; // sf
  int v2; // eax

  v1 = *(_DWORD *)(a1 - 872) < 0;
  dword_8071254 = (int (*)(void))sub_804F572;
  JUMPOUT(!v1, &loc_8058DC6);
  v2 = *__errno_location();
  dword_8071254 = (int (*)(void))&loc_804F588;
  JUMPOUT(&loc_8058DC6);
}
// 8071254: using guessed type int (*dword_8071254)(void);

//----- (0804F572) --------------------------------------------------------
void __usercall sub_804F572(int a1@<ebp>)
{
  bool v1; // zf

  *(_BYTE *)(a1 - 877) = (*(_DWORD *)(*(_DWORD *)(a1 - 868) + 28) & 0xF000) != 0x4000;
  v1 = *(_BYTE *)(a1 - 877) == 1;
  dword_8071254 = (int (*)(void))sub_804F5C1;
  JUMPOUT(v1, &loc_8058DC6);
  dword_8071254 = (int (*)(void))&loc_804F5E9;
  JUMPOUT(&loc_8058DC6);
}
// 8071254: using guessed type int (*dword_8071254)(void);

//----- (0804F5C1) --------------------------------------------------------
#error "804F5D7: call analysis failed (funcsize=32)"

//----- (0804F665) --------------------------------------------------------
#error "804F66E: call analysis failed (funcsize=18)"

//----- (08050428) --------------------------------------------------------
int __cdecl sub_8050428(int a1)
{
  return *(_DWORD *)(a1 + 108) == 3 || *(_DWORD *)(a1 + 108) == 9;
}

//----- (08050462) --------------------------------------------------------
#error "80504C4: call analysis failed (funcsize=31)"

//----- (080504CB) --------------------------------------------------------
void *__cdecl sub_80504CB(int a1, char *s)
{
  size_t v3; // eax
  void *v4; // eax
  char *v5; // eax
  int v6; // [esp+18h] [ebp-10h]
  void *v7; // [esp+1Ch] [ebp-Ch]

  if ( !s )
    return 0;
  if ( *s == 47 )
    return sub_8061743(s);
  v6 = sub_8056B96(a1);
  if ( !v6 )
    return sub_8061743(s);
  v3 = strlen(s);
  v4 = sub_80615D3(v6 + v3 + 2);
  v7 = v4;
  if ( *(_BYTE *)(v6 - 1 + a1) != 47 )
    ++v6;
  v5 = (char *)stpncpy(v4, a1, v6);
  strcpy(v5, s);
  return v7;
}
// 8049980: using guessed type int __cdecl stpncpy(_DWORD, _DWORD, _DWORD);
// 8056B96: using guessed type _DWORD __cdecl sub_8056B96(_DWORD);

//----- (08050595) --------------------------------------------------------
int __cdecl sub_8050595(int a1)
{
  _BYTE *v1; // ST1C_4

  v1 = (_BYTE *)sub_8056C9E(a1);
  return sub_804A74D(v1);
}
// 8056C9E: using guessed type _DWORD __cdecl sub_8056C9E(_DWORD);

//----- (080505B6) --------------------------------------------------------
#error "80505E6: call analysis failed (funcsize=141)"

//----- (0805079A) --------------------------------------------------------
void __cdecl __noreturn sub_805079A(char *s1, char *s2)
{
  int v2; // eax
  int v3; // edi
  bool v4; // zf
  int v5; // edx
  int v6; // ecx
  int (*v7)(); // eax
  int v8; // eax
  int v9; // esi
  char *v10; // ebx
  int *v11; // eax

  *__errno_location() = 0;
  strcoll(s1, s2);
  v4 = *__errno_location() == 0;
  v7 = (int (*)())&loc_80507E7;
  if ( v4 )
    v7 = sub_8050868;
  dword_8071210 = (int)v7;
  sub_8064CF3(v6, v5);
  sub_8060718(1);
  v3 = v2;
  sub_8060718(0);
  v9 = v8;
  v10 = gettext("cannot compare file names %s and %s");
  v11 = __errno_location();
  error(0, *v11, v10, v9, v3);
  sub_804DDB8(0);
  longjmp(env, 1);
}
// 8050868: using guessed type int sub_8050868();
// 8064CF3: using guessed type int __fastcall sub_8064CF3(_DWORD, _DWORD);
// 8071210: using guessed type int dword_8071210;

//----- (08050868) --------------------------------------------------------
#error "805086E: positive sp value has been found (funcsize=0)"

//----- (08050873) --------------------------------------------------------
#error "805091A: positive sp value has been found (funcsize=43)"

//----- (0805091B) --------------------------------------------------------
int __cdecl sub_805091B(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD))
{
  int result; // eax
  int v4; // [esp+20h] [ebp-18h]
  int v5; // [esp+24h] [ebp-14h]
  int v6; // [esp+28h] [ebp-10h]
  int v7; // [esp+2Ch] [ebp-Ch]

  sub_8060B67(&v4, (int)(a1 + 3));
  sub_8060B67(&v6, (int)(a2 + 3));
  sub_8060C02(v6, v7, v4, v5);
  if ( !result )
    result = a3(*a1, *a2);
  return result;
}

//----- (080509A7) --------------------------------------------------------
int __cdecl sub_80509A7(_DWORD *a1, _DWORD *a2, int (__cdecl *a3)(_DWORD, _DWORD))
{
  int result; // eax
  int v4; // [esp+20h] [ebp-18h]
  int v5; // [esp+24h] [ebp-14h]
  int v6; // [esp+28h] [ebp-10h]
  int v7; // [esp+2Ch] [ebp-Ch]

  sub_8060B11(&v4, (int)(a1 + 3));
  sub_8060B11(&v6, (int)(a2 + 3));
  sub_8060C02(v6, v7, v4, v5);
  if ( !result )
    result = a3(*a1, *a2);
  return result;
}

//----- (08050A23) --------------------------------------------------------
int __cdecl sub_8050A23(int *a1, int a2, int (__fastcall *a3)(_DWORD))
{
  __int64 v3; // rcx
  int v4; // edx
  __int64 v5; // rax
  unsigned __int8 v6; // si
  signed int v7; // eax
  int v8; // eax
  int v10; // [esp+0h] [ebp-28h]
  int v11; // [esp+4h] [ebp-24h]
  int v12; // [esp+1Ch] [ebp-Ch]

  v3 = *(_QWORD *)(a2 + 56);
  v4 = a1[15];
  if ( SHIDWORD(v3) < v4 || SHIDWORD(v3) <= v4 && (unsigned int)v3 < a1[14] )
  {
    v7 = -1;
  }
  else
  {
    LODWORD(v3) = *(_DWORD *)(a2 + 56);
    v6 = 1;
    LODWORD(v5) = a1[14];
    HIDWORD(v3) = *(_DWORD *)(a2 + 60);
    HIDWORD(v5) = a1[15];
    if ( v3 <= v5 )
      v6 = 0;
    v7 = v6;
  }
  v12 = v7;
  if ( v7 )
    return v12;
  v8 = *a1;
  v11 = *(_DWORD *)a2;
  v10 = v8;
  return a3(v3);
}

//----- (08050AC4) --------------------------------------------------------
#error "8050ADB: call analysis failed (funcsize=14)"

//----- (08050B2F) --------------------------------------------------------
int __cdecl sub_8050B2F(const char **a1, const char **a2, int (*a3)(void))
{
  char *v3; // edx
  char *v4; // eax
  bool v5; // zf
  void *v6; // eax
  char *v8; // [esp+0h] [ebp-28h]
  char *v9; // [esp+4h] [ebp-24h]
  int v10; // [esp+8h] [ebp-20h]
  int v11; // [esp+Ch] [ebp-1Ch]
  int v12; // [esp+10h] [ebp-18h]
  char *v13; // [esp+14h] [ebp-14h]
  char *v14; // [esp+18h] [ebp-10h]

  v13 = strrchr(*a1, 46);
  v14 = strrchr(*a2, 46);
  if ( v14 )
    v3 = v14;
  else
    v3 = &locale;
  if ( v13 )
    v4 = v13;
  else
    v4 = &locale;
  v9 = v3;
  v8 = v4;
  v5 = a3() == 0;
  v6 = &loc_8050BB3;
  if ( !v5 )
    v6 = &loc_8050BCB;
  dword_80711FC = (int)v6;
  sub_8064D6B(v8, v9, v10, v11, v12, v13, v14);
  return ((int (__cdecl *)(const char *, const char *))a3)(*a1, *a2);
}
// 8064D6B: using guessed type int __stdcall sub_8064D6B(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80711FC: using guessed type int dword_80711FC;

//----- (080512E8) --------------------------------------------------------
int __cdecl sub_80512E8(int *a1, int a2)
{
  return sub_8050A23(a1, a2, (int (__fastcall *)(_DWORD))sub_805079A);
}

//----- (0805130A) --------------------------------------------------------
int __cdecl sub_805130A(int *a1, int a2)
{
  return sub_8050A23(a1, a2, (int (__fastcall *)(_DWORD))strcmp);
}

//----- (0805132C) --------------------------------------------------------
int __cdecl sub_805132C(int a1, int *a2)
{
  return sub_8050A23(a2, a1, (int (__fastcall *)(_DWORD))sub_805079A);
}

//----- (0805134E) --------------------------------------------------------
int __cdecl sub_805134E(int a1, int *a2)
{
  return sub_8050A23(a2, a1, (int (__fastcall *)(_DWORD))strcmp);
}

//----- (08051370) --------------------------------------------------------
int __cdecl sub_8051370(int *a1, int a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_8050428((int)a1);
  v4 = sub_8050428(a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_8050A23(a1, a2, (int (__fastcall *)(_DWORD))sub_805079A);
}

//----- (080513F9) --------------------------------------------------------
int __cdecl sub_80513F9(int *a1, int a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_8050428((int)a1);
  v4 = sub_8050428(a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_8050A23(a1, a2, (int (__fastcall *)(_DWORD))strcmp);
}

//----- (08051467) --------------------------------------------------------
int __cdecl sub_8051467(int a1, int *a2)
{
  int v2; // edx
  int v3; // ecx
  void *v4; // eax
  char v6; // [esp+1Eh] [ebp-Ah]
  char v7; // [esp+1Fh] [ebp-9h]

  v6 = sub_8050428(a1);
  v7 = sub_8050428((int)a2);
  v4 = &loc_80514A8;
  if ( !v6 )
    v4 = &loc_80514BA;
  dword_80711DC = (int)v4;
  sub_8064E3D(v3, v2);
  if ( v7 != 1 )
    return -1;
  if ( v6 == 1 )
    return sub_8050A23(a2, a1, (int (__fastcall *)(_DWORD))sub_805079A);
  return 1;
}
// 8064E3D: using guessed type double __fastcall sub_8064E3D(_DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;

//----- (080514EE) --------------------------------------------------------
int __cdecl sub_80514EE(int a1, int *a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_8050428(a1);
  v4 = sub_8050428((int)a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_8050A23(a2, a1, (int (__fastcall *)(_DWORD))strcmp);
}

//----- (0805155C) --------------------------------------------------------
int __cdecl sub_805155C(int a1, int a2)
{
  return sub_8050AC4(a1, a2);
}
// 8050AC4: using guessed type _DWORD __cdecl sub_8050AC4(_DWORD, _DWORD);

//----- (0805157E) --------------------------------------------------------
int __cdecl sub_805157E(int a1, int a2)
{
  return sub_8050AC4(a1, a2);
}
// 8050AC4: using guessed type _DWORD __cdecl sub_8050AC4(_DWORD, _DWORD);

//----- (080515A0) --------------------------------------------------------
int __cdecl sub_80515A0(int a1, int a2)
{
  return sub_8050AC4(a2, a1);
}
// 8050AC4: using guessed type _DWORD __cdecl sub_8050AC4(_DWORD, _DWORD);

//----- (080515C2) --------------------------------------------------------
int __cdecl sub_80515C2(int a1, int a2)
{
  return sub_8050AC4(a2, a1);
}
// 8050AC4: using guessed type _DWORD __cdecl sub_8050AC4(_DWORD, _DWORD);

//----- (080515E4) --------------------------------------------------------
signed int __cdecl sub_80515E4(int a1, int a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_8050428(a1);
  v4 = sub_8050428(a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_8050AC4(a1, a2);
}
// 8050AC4: using guessed type _DWORD __cdecl sub_8050AC4(_DWORD, _DWORD);

//----- (08051652) --------------------------------------------------------
#error "80516C6: call analysis failed (funcsize=48)"

//----- (080516EE) --------------------------------------------------------
#error "8051765: call analysis failed (funcsize=48)"

//----- (0805178A) --------------------------------------------------------
signed int __cdecl sub_805178A(int a1, int a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_8050428(a1);
  v4 = sub_8050428(a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_8050AC4(a2, a1);
}
// 8050AC4: using guessed type _DWORD __cdecl sub_8050AC4(_DWORD, _DWORD);

//----- (080517F8) --------------------------------------------------------
int __cdecl sub_80517F8(const char **a1, const char **a2)
{
  return sub_8050B2F(a1, a2, (int (*)(void))sub_805079A);
}

//----- (0805181A) --------------------------------------------------------
int __cdecl sub_805181A(const char **a1, const char **a2)
{
  return sub_8050B2F(a1, a2, (int (*)(void))strcmp);
}

//----- (0805183C) --------------------------------------------------------
int __cdecl sub_805183C(const char **a1, const char **a2)
{
  return sub_8050B2F(a2, a1, (int (*)(void))sub_805079A);
}

//----- (0805185E) --------------------------------------------------------
int __cdecl sub_805185E(const char **a1, const char **a2)
{
  return sub_8050B2F(a2, a1, (int (*)(void))strcmp);
}

//----- (08051880) --------------------------------------------------------
int __cdecl sub_8051880(const char **a1, const char **a2)
{
  void *v3; // eax
  int v4; // [esp+0h] [ebp-28h]
  int v5; // [esp+4h] [ebp-24h]
  int v6; // [esp+8h] [ebp-20h]
  int v7; // [esp+Ch] [ebp-1Ch]
  int v8; // [esp+10h] [ebp-18h]
  int v9; // [esp+14h] [ebp-14h]
  int v10; // [esp+18h] [ebp-10h]
  char v11; // [esp+1Eh] [ebp-Ah]
  char v12; // [esp+1Fh] [ebp-9h]

  v11 = sub_8050428((int)a1);
  v12 = sub_8050428((int)a2);
  if ( v11 && v12 != 1 )
    return -1;
  if ( v11 == 1 )
    return sub_8050B2F(a1, a2, (int (*)(void))sub_805079A);
  v3 = &loc_80518E4;
  if ( !v12 )
    v3 = &loc_80518EB;
  dword_80711FC = (int)v3;
  sub_8064D6B(v4, v5, v6, v7, v8, v9, v10);
  return 1;
}
// 8064D6B: using guessed type int __stdcall sub_8064D6B(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80711FC: using guessed type int dword_80711FC;

//----- (08051907) --------------------------------------------------------
int __cdecl sub_8051907(const char **a1, const char **a2)
{
  int v2; // edx
  int v3; // ecx
  int result; // eax
  char v5; // [esp+1Eh] [ebp-Ah]
  char v6; // [esp+1Fh] [ebp-9h]

  v5 = sub_8050428((int)a1);
  v6 = sub_8050428((int)a2);
  if ( v5 && v6 != 1 )
  {
    dword_80711DC = (int)&locret_8051988;
    sub_8064E3D(v3, v2);
  }
  if ( v5 != 1 && v6 )
    result = 1;
  else
    result = sub_8050B2F(a1, a2, (int (*)(void))strcmp);
  return result;
}
// 8064E3D: using guessed type double __fastcall sub_8064E3D(_DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;

//----- (0805198A) --------------------------------------------------------
#error "80519C6: call analysis failed (funcsize=43)"

//----- (08051A11) --------------------------------------------------------
int __cdecl sub_8051A11(const char **a1, const char **a2)
{
  char v3; // [esp+1Eh] [ebp-Ah]
  char v4; // [esp+1Fh] [ebp-9h]

  v3 = sub_8050428((int)a1);
  v4 = sub_8050428((int)a2);
  if ( v3 && v4 != 1 )
    return -1;
  if ( v3 != 1 && v4 )
    return 1;
  return sub_8050B2F(a2, a1, (int (*)(void))strcmp);
}

//----- (08051A7F) --------------------------------------------------------
void __cdecl sub_8051A7F(char **a1, char **a2)
{
  sub_80576BB(*a1, *a2);
}

//----- (08051A9D) --------------------------------------------------------
void __cdecl sub_8051A9D(char **a1, char **a2)
{
  sub_8051A7F(a1, a2);
}

//----- (08051AB7) --------------------------------------------------------
void __cdecl sub_8051AB7(char **a1, char **a2)
{
  sub_8051A7F(a2, a1);
}

//----- (08051AD1) --------------------------------------------------------
void __cdecl sub_8051AD1(char **a1, char **a2)
{
  char v2; // [esp+1Eh] [ebp-Ah]
  char v3; // [esp+1Fh] [ebp-9h]

  v2 = sub_8050428((int)a1);
  v3 = sub_8050428((int)a2);
  if ( (!v2 || v3 == 1) && (v2 == 1 || !v3) )
    sub_8051A7F(a1, a2);
}

//----- (08051B37) --------------------------------------------------------
#error "8051B7E: call analysis failed (funcsize=42)"

//----- (08051BB6) --------------------------------------------------------
#error "8051BD2: call analysis failed (funcsize=36)"

//----- (08051C4B) --------------------------------------------------------
void sub_8051C4B()
{
  int v0; // eax
  unsigned __int8 v1; // [esp+1Fh] [ebp-9h]

  if ( dword_8071721 + ((unsigned int)dword_8071721 >> 1) > dword_807172D )
  {
    free(dword_8071729);
    dword_8071729 = sub_80614C6(dword_8071721, 0xCu);
    dword_807172D = 3 * dword_8071721;
  }
  sub_8051BB6();
  if ( dword_8071779 != -1 )
  {
    if ( _setjmp(env) )
    {
      v1 = 1;
      if ( dword_8071779 == 3 )
        __assert_fail("sort_type != sort_version", "src/ls.c", 0xEE5u, "sort_files");
      sub_8051BB6();
    }
    else
    {
      v1 = 0;
    }
    if ( dword_8071779 == 4 )
      v0 = dword_8071775;
    else
      v0 = 0;
    sub_805BC23(
      (int)dword_8071729,
      dword_8071721,
      (int)off_80676D0[2 * (2 * (2 * (v0 + dword_8071779) + v1) + (unsigned __int8)byte_807177D)
                     + (unsigned __int8)byte_80717AF]);
  }
}
// 8051BB6: using guessed type int sub_8051BB6(void);
// 80676D0: using guessed type int (__cdecl *off_80676D0[28])(int, int);
// 8071721: using guessed type int dword_8071721;
// 807172D: using guessed type int dword_807172D;
// 8071775: using guessed type int dword_8071775;
// 8071779: using guessed type int dword_8071779;
// 807177D: using guessed type char byte_807177D;
// 80717AF: using guessed type char byte_80717AF;

//----- (08051DAB) --------------------------------------------------------
#error "8051EA1: call analysis failed (funcsize=84)"

//----- (08051EF8) --------------------------------------------------------
int __cdecl sub_8051EF8(int a1, int a2, unsigned __int8 a3, int a4, int a5, int a6)
{
  char *v6; // eax

  if ( byte_8072655 )
    v6 = (char *)(((*(_DWORD *)(a4 + 16) + 12 * a3) << 7) + 134683221);
  else
    v6 = (&off_8071368)[a3];
  return sub_805BD87(a1, a2, (int)v6, a4, a5, a6);
}
// 8072655: using guessed type char byte_8072655;

//----- (08051F8C) --------------------------------------------------------
int sub_8051F8C()
{
  time_t timer; // [esp+2Ch] [ebp-42Ch]
  int v2; // [esp+30h] [ebp-428h]
  struct tm tp; // [esp+34h] [ebp-424h]
  char v4; // [esp+63h] [ebp-3F5h]
  unsigned int v5; // [esp+44Ch] [ebp-Ch]

  v5 = __readgsdword(0x14u);
  if ( dword_8071374 < 0 )
  {
    timer = 0;
    if ( sub_8063207(dword_80717D5, &timer, &tp) )
    {
      v2 = sub_8051EF8((int)&v4, 1001, 0, (int)&tp, dword_80717D5, 0);
      if ( v2 )
        dword_8071374 = sub_805B53B(&v4);
    }
    if ( dword_8071374 < 0 )
      dword_8071374 = 0;
  }
  return dword_8071374;
}
// 805B53B: using guessed type _DWORD __cdecl sub_805B53B(_DWORD);
// 8071374: using guessed type int dword_8071374;

//----- (08052074) --------------------------------------------------------
int __cdecl sub_8052074(char *s, int a2, int a3)
{
  int v3; // eax
  int v4; // ecx
  int v5; // eax
  int v6; // edx
  int result; // eax
  int v8; // [esp+4h] [ebp-24h]
  int v9; // [esp+8h] [ebp-20h]
  size_t v10; // [esp+14h] [ebp-14h]
  int v11; // [esp+18h] [ebp-10h]
  int v12; // [esp+1Ch] [ebp-Ch]

  if ( s )
  {
    v8 = 0;
    v12 = a3 - sub_805B512(s);
    v3 = 0;
    if ( v12 >= 0 )
      v3 = v12;
    v11 = v3;
    fputs_unlocked(s, stdout);
    v10 = v11 + strlen(s);
    do
    {
      putchar_unlocked(32);
      v5 = v11;
      v6 = v11-- - 1;
    }
    while ( v5 );
    dword_80711DC = (int)&loc_8052144;
    sub_8064E3D(v4, v6);
  }
  v9 = a2;
  v8 = a3;
  printf("%*lu ", a3, a2);
  result = dword_8071889 + a3 + 1;
  dword_8071889 += a3 + 1;
  return result;
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8064E3D: using guessed type double __fastcall sub_8064E3D(_DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;
// 8071889: using guessed type int dword_8071889;

//----- (08052159) --------------------------------------------------------
int __cdecl sub_8052159(__uid_t uid, int a2, int a3)
{
  char *v3; // eax

  if ( (_BYTE)a3 == 1 )
  {
    if ( byte_807177F )
      v3 = 0;
    else
      v3 = sub_805A8C2(uid);
  }
  else
  {
    v3 = "?";
  }
  return sub_8052074(v3, uid, a2);
}
// 807177F: using guessed type char byte_807177F;

//----- (080521AC) --------------------------------------------------------
#error "80521D6: call analysis failed (funcsize=40)"

//----- (08052235) --------------------------------------------------------
size_t __cdecl sub_8052235(char *a1, int a2)
{
  size_t result; // eax
  int v3; // [esp+1Ch] [ebp-1Ch]
  char s; // [esp+21h] [ebp-17h]
  unsigned int v5; // [esp+2Ch] [ebp-Ch]

  v5 = __readgsdword(0x14u);
  if ( a1 )
  {
    v3 = sub_805B512(a1);
    result = 0;
    if ( v3 >= 0 )
      result = v3;
  }
  else
  {
    sprintf(&s, "%lu", a2);
    result = strlen(&s);
  }
  return result;
}

//----- (080522AF) --------------------------------------------------------
size_t __cdecl sub_80522AF(__uid_t uid)
{
  char *v1; // eax

  if ( byte_807177F )
    v1 = 0;
  else
    v1 = sub_805A8C2(uid);
  return sub_8052235(v1, uid);
}
// 807177F: using guessed type char byte_807177F;

//----- (080522EF) --------------------------------------------------------
size_t __usercall sub_80522EF@<eax>(int a1@<edx>, int a2@<ecx>, __gid_t gid)
{
  char *v4; // eax

  if ( byte_807177F )
  {
    dword_80711DC = (int)&loc_805231E;
    sub_8064E3D(a2, a1);
  }
  v4 = sub_805AB03(gid);
  return sub_8052235(v4, gid);
}
// 8064E3D: using guessed type double __fastcall sub_8064E3D(_DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;
// 807177F: using guessed type char byte_807177F;

//----- (08052340) --------------------------------------------------------
const char *__usercall sub_8052340@<eax>(int a1@<edx>, int a2@<ecx>, int a3, unsigned int a4, int a5)
{
  void *v5; // eax
  const char *result; // eax

  if ( a4 <= 0x14 )
    __assert_fail("INT_BUFSIZE_BOUND (uintmax_t) <= buflen", "src/ls.c", 0xFA7u, "format_inode");
  v5 = &loc_8052394;
  if ( !*(_BYTE *)(a5 + 120) )
    v5 = &loc_80523C1;
  dword_80711DC = (int)v5;
  sub_8064E3D(a2, a1);
  if ( *(_QWORD *)(a5 + 100) )
    result = (const char *)sub_805AE4B(*(_QWORD *)(a5 + 100), a3);
  else
    result = "?";
  return result;
}
// 8064E3D: using guessed type double __fastcall sub_8064E3D(_DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;

//----- (080523D4) --------------------------------------------------------
#error "8052B8B: call analysis failed (funcsize=373)"

//----- (08052B90) --------------------------------------------------------
#error "8052BFC: call analysis failed (funcsize=180)"

//----- (08052FBC) --------------------------------------------------------
unsigned int __usercall sub_8052FBC@<eax>(const unsigned __int16 *a1@<ebx>, void **a2, unsigned int a3, char *a4, int *a5, int a6, unsigned int *a7, _BYTE *a8)
{
  void *v8; // eax
  char v9; // al
  char v10; // dl
  void *v11; // eax
  char *v12; // ecx
  int v13; // edx
  int v14; // eax
  bool v15; // zf
  bool v16; // sf
  unsigned __int8 v17; // of
  void *v18; // eax
  signed int v19; // eax
  char *v20; // eax
  char *v21; // edx
  char *v22; // eax
  char *v23; // edx
  char *v24; // eax
  char *v25; // eax
  char *v26; // eax
  void *v27; // edx
  bool v28; // al
  int v29; // eax
  void *v30; // eax
  const unsigned __int16 *v32; // [esp-8h] [ebp-90h]
  int v33; // [esp-4h] [ebp-8Ch]
  wchar_t v34; // [esp+0h] [ebp-88h]
  unsigned int v35; // [esp+4h] [ebp-84h]
  int v36; // [esp+8h] [ebp-80h]
  int v37; // [esp+Ch] [ebp-7Ch]
  int v38; // [esp+10h] [ebp-78h]
  int v39; // [esp+14h] [ebp-74h]
  int v40; // [esp+18h] [ebp-70h]
  _BYTE *v41; // [esp+1Ch] [ebp-6Ch]
  unsigned int *v42; // [esp+20h] [ebp-68h]
  int *v43; // [esp+24h] [ebp-64h]
  char *s; // [esp+28h] [ebp-60h]
  void **v45; // [esp+2Ch] [ebp-5Ch]
  int v46; // [esp+30h] [ebp-58h]
  int v47; // [esp+34h] [ebp-54h]
  int v48; // [esp+38h] [ebp-50h]
  wchar_t pwc; // [esp+3Ch] [ebp-4Ch]
  void *dest; // [esp+40h] [ebp-48h]
  unsigned int v51; // [esp+44h] [ebp-44h]
  unsigned int v52; // [esp+48h] [ebp-40h]
  char *v53; // [esp+4Ch] [ebp-3Ch]
  char *v54; // [esp+50h] [ebp-38h]
  size_t v55; // [esp+54h] [ebp-34h]
  unsigned __int8 *v56; // [esp+58h] [ebp-30h]
  unsigned __int8 *v57; // [esp+5Ch] [ebp-2Ch]
  int v58; // [esp+60h] [ebp-28h]
  char *v59; // [esp+64h] [ebp-24h]
  int v60; // [esp+68h] [ebp-20h]
  unsigned __int8 *v61; // [esp+6Ch] [ebp-1Ch]
  unsigned __int8 *v62; // [esp+70h] [ebp-18h]
  mbstate_t ps; // [esp+74h] [ebp-14h]
  unsigned int v64; // [esp+7Ch] [ebp-Ch]
  int v65; // [esp+80h] [ebp-8h]
  int v66; // [esp+84h] [ebp-4h]
  int savedregs; // [esp+88h] [ebp+0h]

  v45 = a2;
  s = a4;
  v43 = a5;
  v42 = a7;
  v41 = a8;
  v64 = __readgsdword(0x14u);
  dest = *a2;
  v52 = 0;
  v58 = sub_805EAD4(a5);
  if ( !byte_80717BD )
    goto LABEL_66;
  if ( v58 == 1 )
    goto LABEL_67;
  v33 = (unsigned __int8)byte_80717BD;
  v32 = a1;
  v8 = &loc_805304A;
  if ( v58 == 2 )
    v8 = &loc_8053050;
  dword_8071238 = (int)v8;
  a1 = v32;
  sub_8064C1B(
    v34,
    v35,
    v36,
    v37,
    v38,
    v39,
    v40,
    v41,
    v42,
    v43,
    s,
    v45,
    v46,
    v47,
    v48,
    pwc,
    dest,
    v51,
    v52,
    v53,
    v54,
    v55,
    v56,
    v57,
    v58,
    v59,
    v60,
    v61,
    v62,
    ps.__count,
    ps.__wch,
    v64,
    v65,
    v66,
    savedregs);
  if ( v58 )
LABEL_66:
    v9 = 0;
  else
LABEL_67:
    v9 = 1;
  HIBYTE(v48) = v9 & 1;
  if ( a6 )
  {
    v52 = sub_805FB88((int)dest, a3, (int)s, -1, v43);
    if ( a3 <= v52 )
    {
      dest = sub_80615D3(v52 + 1);
      sub_805FB88((int)dest, v52 + 1, (int)s, -1, v43);
    }
    v10 = *s;
    v33 = *(unsigned __int8 *)dest;
    v32 = a1;
    v11 = &loc_8053115;
    if ( v10 != *(_BYTE *)dest )
      v11 = &loc_8053125;
    dword_8071238 = (int)v11;
    a1 = v32;
    sub_8064C1B(
      v34,
      v35,
      v36,
      v37,
      v38,
      v39,
      v40,
      v41,
      v42,
      v43,
      s,
      v45,
      v46,
      v47,
      v48,
      pwc,
      dest,
      v51,
      v52,
      v53,
      v54,
      v55,
      v56,
      v57,
      v58,
      v59,
      v60,
      v61,
      v62,
      ps.__count,
      ps.__wch,
      v64,
      v65,
      v66,
      savedregs);
    BYTE2(v48) = strlen(s) != v52;
  }
  else if ( HIBYTE(v48) )
  {
    v52 = strlen(s);
    if ( a3 <= v52 )
      dest = sub_80615D3(v52 + 1);
    memcpy(dest, s, v52 + 1);
    BYTE2(v48) = 0;
  }
  else
  {
    v52 = strlen(s);
    dest = s;
    BYTE2(v48) = 0;
  }
  if ( !HIBYTE(v48) )
    goto LABEL_48;
  if ( __ctype_get_mb_cur_max() <= 1 )
  {
    v56 = (unsigned __int8 *)dest;
    v27 = dest;
    v61 = (unsigned __int8 *)dest + v52;
    while ( v56 < v61 )
    {
      a1 = *__ctype_b_loc();
      if ( !(a1[(unsigned __int8)sub_804A73B(*v56)] & 0x4000) )
        *v56 = 63;
      ++v56;
    }
    v51 = v52;
    dword_80711DC = (int)&loc_805346D;
    sub_8064E3D(v12, v27);
LABEL_48:
    if ( v42 )
    {
      if ( __ctype_get_mb_cur_max() <= 1 )
      {
        v57 = (unsigned __int8 *)dest;
        v62 = (unsigned __int8 *)dest + v52;
        v51 = 0;
        while ( v57 < v62 )
        {
          a1 = *__ctype_b_loc();
          if ( a1[(unsigned __int8)sub_804A73B(*v57)] & 0x4000 )
            ++v51;
          ++v57;
        }
      }
      else
      {
        v36 = 0;
        v35 = v52;
        v51 = sub_805B53B(dest);
      }
    }
    goto LABEL_56;
  }
  v53 = (char *)dest;
  v13 = (int)dest;
  v59 = (char *)dest + v52;
  v54 = (char *)dest;
  v51 = 0;
LABEL_40:
  while ( v53 < v59 )
  {
    v14 = *v53;
    v17 = __OFSUB__(v14, 63);
    v15 = v14 == 63;
    v16 = v14 - 63 < 0;
    v33 = *v53;
    v32 = a1;
    v18 = &loc_8053203;
    if ( !((unsigned __int8)(v16 ^ v17) | v15) )
      v18 = &loc_8053212;
    dword_80711DC = (int)v18;
    a1 = v32;
    sub_8064E3D(v12, v13);
    if ( v19 < 37 && (unsigned int)(v19 - 32) > 3 )
    {
      ps.__count = 0;
      ps.__wch = 0;
      while ( 1 )
      {
        v55 = sub_8062663(&v34 - 19, v53, v59 - v53, &ps);
        if ( v55 == -1 )
        {
          ++v53;
          v25 = v54;
          v13 = (int)(v54++ + 1);
          *v25 = 63;
          ++v51;
          goto LABEL_40;
        }
        if ( v55 == -2 )
          break;
        if ( !v55 )
          v55 = 1;
        v34 = pwc;
        v60 = wcwidth();
        if ( v60 < 0 )
        {
          v53 += v55;
          v26 = v54++;
          *v26 = 63;
          ++v51;
        }
        else
        {
          while ( v55 )
          {
            v22 = v54++;
            v23 = v53++;
            *v22 = *v23;
            --v55;
          }
          v51 += v60;
        }
        if ( mbsinit(&ps) )
          goto LABEL_40;
      }
      v53 = v59;
      v24 = v54;
      v13 = (int)(v54++ + 1);
      *v24 = 63;
      ++v51;
    }
    else
    {
      v20 = v54++;
      v21 = v53;
      v12 = v53++ + 1;
      v13 = (unsigned __int8)*v21;
      *v20 = v13;
      ++v51;
    }
  }
  v52 = v54 - (_BYTE *)dest;
LABEL_56:
  v28 = byte_8071726 && byte_8071725 && BYTE2(v48) != 1;
  v29 = v28;
  *v41 = v29;
  v33 = v29;
  v32 = a1;
  v30 = &loc_80534C1;
  if ( !v42 )
    v30 = &loc_80534C9;
  dword_80711FC = (int)v30;
  sub_8064D6B(v34, v35, v36, v37, v38, v39, v40);
  *v42 = v51;
  *v45 = dest;
  return v52;
}
// 8049560: using guessed type int wcwidth(void);
// 805B53B: using guessed type _DWORD __cdecl sub_805B53B(_DWORD);
// 8064C1B: using guessed type int __stdcall sub_8064C1B(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8064D6B: using guessed type int __stdcall sub_8064D6B(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8064E3D: using guessed type double __fastcall sub_8064E3D(_DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;
// 80711FC: using guessed type int dword_80711FC;
// 8071238: using guessed type int dword_8071238;
// 8071725: using guessed type char byte_8071725;
// 8071726: using guessed type char byte_8071726;
// 80717BD: using guessed type char byte_80717BD;

//----- (080534EC) --------------------------------------------------------
int __usercall sub_80534EC@<eax>(const unsigned __int16 *a1@<ebx>, char *a2, int *a3, int a4)
{
  int v5; // [esp+0h] [ebp-2048h]
  int *v6; // [esp+28h] [ebp-2020h]
  char *v7; // [esp+2Ch] [ebp-201Ch]
  unsigned __int8 v8; // [esp+33h] [ebp-2015h]
  void *ptr; // [esp+34h] [ebp-2014h]
  int v10; // [esp+38h] [ebp-2010h]
  char v11; // [esp+3Ch] [ebp-200Ch]
  unsigned int v12; // [esp+203Ch] [ebp-Ch]

  v7 = a2;
  v6 = a3;
  v12 = __readgsdword(0x14u);
  ptr = &v5 - 2051;
  sub_8052FBC(a1, (void **)&v5 - 2053, 0x2000u, a2, a3, a4, (unsigned int *)&v5 - 2052, (_BYTE *)&v5 - 8213);
  if ( ptr != &v11 && ptr != v7 )
    free(ptr);
  return v8 + v10;
}

//----- (08053643) --------------------------------------------------------
char *__cdecl sub_8053643(char *s, int a2)
{
  size_t v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // edx
  unsigned __int8 *v6; // eax
  unsigned __int8 v7; // al
  char *v9; // [esp+18h] [ebp-10h]
  char *v10; // [esp+1Ch] [ebp-Ch]

  v2 = strlen(s);
  v10 = (char *)sub_80614C6(3u, v2 + 1);
  v9 = v10;
  while ( *s )
  {
    if ( (_BYTE)a2 && *s == 47 )
    {
      v3 = v9++;
      *v3 = 47;
      ++s;
    }
    else if ( byte_8071955[(unsigned __int8)sub_804A73B(*s)] )
    {
      v4 = v9++;
      v5 = s++;
      *v4 = *v5;
    }
    else
    {
      v6 = (unsigned __int8 *)s++;
      v7 = sub_804A73B(*v6);
      v9 += sprintf(v9, "%%%02x", v7);
    }
  }
  *v9 = 0;
  return v10;
}

//----- (08053732) --------------------------------------------------------
unsigned int __usercall sub_8053732@<eax>(const unsigned __int16 *a1@<ebx>, char *a2, int *a3, int a4, int a5, char a6, int a7, char *a8)
{
  char *v8; // eax
  void *v9; // eax
  const unsigned __int16 *v10; // ebx
  void *v11; // eax
  int v12; // edx
  int v13; // ecx
  void *v14; // eax
  void *v15; // eax
  const unsigned __int16 *v17; // [esp-8h] [ebp-2080h]
  size_t v18; // [esp-4h] [ebp-207Ch]
  int v19; // [esp+0h] [ebp-2078h]
  void *v20; // [esp+4h] [ebp-2074h]
  char *v21; // [esp+8h] [ebp-2070h]
  void *v22; // [esp+Ch] [ebp-206Ch]
  int v23; // [esp+10h] [ebp-2068h]
  int v24; // [esp+14h] [ebp-2064h]
  int v25; // [esp+18h] [ebp-2060h]
  char *s; // [esp+28h] [ebp-2050h]
  int v27; // [esp+2Ch] [ebp-204Ch]
  char v28; // [esp+30h] [ebp-2048h]
  int v29; // [esp+34h] [ebp-2044h]
  int *v30; // [esp+38h] [ebp-2040h]
  char *v31; // [esp+3Ch] [ebp-203Ch]
  unsigned __int8 v32; // [esp+42h] [ebp-2036h]
  unsigned __int8 v33; // [esp+43h] [ebp-2035h]
  void *v34; // [esp+44h] [ebp-2034h]
  unsigned int v35; // [esp+48h] [ebp-2030h]
  void *ptr; // [esp+4Ch] [ebp-202Ch]
  void *v37; // [esp+50h] [ebp-2028h]
  int v38; // [esp+54h] [ebp-2024h]
  size_t n; // [esp+58h] [ebp-2020h]
  int v40; // [esp+5Ch] [ebp-201Ch]
  int v41; // [esp+60h] [ebp-2018h]
  size_t v42; // [esp+64h] [ebp-2014h]
  int v43; // [esp+68h] [ebp-2010h]
  char v44; // [esp+6Ch] [ebp-200Ch]
  unsigned int v45; // [esp+206Ch] [ebp-Ch]

  v31 = a2;
  v30 = a3;
  v29 = a5;
  v28 = a6;
  v27 = a7;
  s = a8;
  v45 = __readgsdword(0x14u);
  v34 = &v19 - 2051;
  v35 = sub_8052FBC(a1, (void **)&v19 - 2061, 0x2000u, a2, a3, a4, 0, (_BYTE *)&v19 - 8246);
  if ( v32 && v28 )
  {
    putchar_unlocked(32);
    ++dword_8071889;
  }
  if ( v29 )
    sub_8054208(v29);
  v33 = 0;
  if ( s )
  {
    if ( byte_8071726 && byte_8071725 && v32 != 1 )
    {
      v33 = 1;
      putchar_unlocked(*(char *)v34);
    }
    ptr = sub_8053643(dword_8071735, 0);
    v37 = sub_8053643(s, 1);
    if ( *(_BYTE *)v37 == 47 )
      v8 = &locale;
    else
      v8 = "/";
    v22 = v37;
    v21 = v8;
    v20 = ptr;
    printf("\x1B]8;;file://%s%s%s\a");
    free(ptr);
    free(v37);
  }
  if ( v27 )
  {
    v18 = (unsigned __int8)byte_8071791;
    v17 = a1;
    v9 = &loc_8053B49;
    if ( !byte_8071791 )
      v9 = &loc_80539F9;
    dword_80711FC = (int)v9;
    sub_8064D6B(v19, v20, v21, v22, v23, v24, v25);
    v38 = v27;
    n = 4;
    v40 = v27;
    if ( (unsigned int)(*(_DWORD *)(v38 + 16) - *(_DWORD *)(v38 + 12)) < 4 )
      sub_8062976(v38, n);
    memcpy(*(void **)(v38 + 12), &dword_8071889, n);
    *(_DWORD *)(v38 + 12) += n;
  }
  v10 = (const unsigned __int16 *)v34;
  fwrite_unlocked((char *)v34 + v33, 1u, v35 - 2 * v33, stdout);
  dword_8071889 += v35;
  if ( v27 )
  {
    v18 = (unsigned __int8)byte_8071791;
    v17 = v10;
    v11 = &loc_8053A94;
    if ( !byte_8071791 )
      v11 = &loc_8053B3B;
    dword_80711FC = (int)v11;
    v10 = v17;
    sub_8064D6B(v19, v20, v21, v22, v23, v24, v25);
    v41 = v27;
    v42 = 4;
    v43 = v27;
    if ( (unsigned int)(*(_DWORD *)(v27 + 16) - *(_DWORD *)(v27 + 12)) < 4 )
      sub_8062976(v41, v42);
    memcpy(*(void **)(v41 + 12), &dword_8071889, v42);
    *(_DWORD *)(v41 + 12) += v42;
  }
  if ( s )
  {
    v18 = fwrite_unlocked("\x1B]8;;\a", 1u, 6u, stdout);
    v17 = v10;
    v14 = &loc_8053B93;
    if ( !v33 )
      v14 = &loc_8053BB2;
    dword_8071210 = (int)v14;
    v10 = v17;
    sub_8064CF3(v13, v12);
    putchar_unlocked(*((char *)v34 + v35 - 1));
  }
  v18 = (size_t)&v44;
  v17 = v10;
  v15 = &loc_8053BDB;
  if ( v34 == &v44 )
    v15 = &loc_8053BF7;
  dword_80711FC = (int)v15;
  sub_8064D6B(v19, v20, v21, v22, v23, v24, v25);
  if ( v34 != v31 )
    free(v34);
  return v32 + v35;
}
// 8064CF3: using guessed type int __fastcall sub_8064CF3(_DWORD, _DWORD);
// 8064D6B: using guessed type int __stdcall sub_8064D6B(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80711FC: using guessed type int dword_80711FC;
// 8071210: using guessed type int dword_8071210;
// 8071725: using guessed type char byte_8071725;
// 8071726: using guessed type char byte_8071726;
// 8071791: using guessed type char byte_8071791;
// 8071889: using guessed type int dword_8071889;

//----- (08053C24) --------------------------------------------------------
unsigned int __cdecl sub_8053C24(int a1, unsigned __int8 a2, const unsigned __int16 *a3, unsigned int a4)
{
  char *v4; // eax
  int v5; // eax
  bool v6; // al
  bool v7; // ST2B_1
  void *v8; // eax
  char *v10; // [esp+24h] [ebp-24h]
  int v11; // [esp+28h] [ebp-20h]
  unsigned int v12; // [esp+2Ch] [ebp-1Ch]

  if ( a2 )
    v4 = *(char **)(a1 + 4);
  else
    v4 = *(char **)a1;
  v10 = v4;
  if ( byte_8071799 )
    v5 = sub_8054255(a1, a2);
  else
    v5 = 0;
  v11 = v5;
  v6 = byte_8071799 && (v5 || (unsigned __int8)sub_804B2EB(4));
  v7 = v6;
  v12 = sub_8053732(a3, v10, (int *)dword_80717C1, *(_DWORD *)(a1 + 132), v11, a2 == 0, (int)a3, *(char **)(a1 + 8));
  sub_804B40F();
  if ( v7 )
  {
    sub_8053DAD();
    if ( dword_80717D1 )
    {
      v8 = &loc_8053D8F;
      if ( a4 / dword_80717D1 == (a4 + v12 - 1) / dword_80717D1 )
        v8 = &loc_8053DA2;
      dword_80711DC = (int)v8;
      sub_8064E3D(a4 / dword_80717D1, (a4 + v12 - 1) % dword_80717D1);
      sub_80546A8((int)&unk_8071360);
    }
  }
  return v12;
}
// 8054255: using guessed type _DWORD __cdecl sub_8054255(_DWORD, _DWORD);
// 8064E3D: using guessed type double __fastcall sub_8064E3D(_DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;
// 8071799: using guessed type char byte_8071799;
// 80717C1: using guessed type int dword_80717C1;
// 80717D1: using guessed type int dword_80717D1;

//----- (08053DAD) --------------------------------------------------------
size_t sub_8053DAD()
{
  if ( dword_80712BC )
    return sub_80546A8((int)&unk_80712B8);
  sub_80546A8((int)dword_80712A8);
  sub_80546A8((int)&unk_80712C0);
  return sub_80546A8((int)&dword_80712B0);
}
// 80712A8: using guessed type int dword_80712A8[];
// 80712B0: using guessed type int dword_80712B0;
// 80712BC: using guessed type int dword_80712BC;

//----- (08053DFC) --------------------------------------------------------
unsigned int __cdecl sub_8053DFC(int a1, unsigned int a2)
{
  int v2; // edx
  int v3; // ecx
  const char *v4; // edx
  const char *v5; // eax
  int v6; // edx
  int v7; // eax
  int v8; // eax
  int v9; // edx
  unsigned __int8 v10; // al
  bool v11; // al
  int v13; // [esp-2Ch] [ebp-2D8h]
  int v14; // [esp-28h] [ebp-2D4h]
  const char *v15; // [esp-24h] [ebp-2D0h]
  int v16; // [esp-20h] [ebp-2CCh]
  signed int v17; // [esp-1Ch] [ebp-2C8h]
  int v18; // [esp-18h] [ebp-2C4h]
  int v19; // [esp-14h] [ebp-2C0h]
  int v20; // [esp-10h] [ebp-2BCh]
  int v21; // [esp-Ch] [ebp-2B8h]
  int v22; // [esp-8h] [ebp-2B4h]
  int v23; // [esp-4h] [ebp-2B0h]
  int v24; // [esp+0h] [ebp-2ACh]
  int v25; // [esp+4h] [ebp-2A8h]
  int v26; // [esp+8h] [ebp-2A4h]
  int v27; // [esp+Ch] [ebp-2A0h]
  unsigned int v28; // [esp+10h] [ebp-29Ch]
  char v29; // [esp+14h] [ebp-298h]
  int v30; // [esp+18h] [ebp-294h]
  int v31; // [esp+1Ch] [ebp-290h]
  int v32; // [esp+20h] [ebp-28Ch]
  int v33; // [esp+24h] [ebp-288h]
  int v34; // [esp+28h] [ebp-284h]
  int v35; // [esp+2Ch] [ebp-280h]
  int v36; // [esp+30h] [ebp-27Ch]
  int v37; // [esp+34h] [ebp-278h]
  int v38; // [esp+38h] [ebp-274h]
  int v39; // [esp+3Ch] [ebp-270h]
  int v40; // [esp+40h] [ebp-26Ch]
  int v41; // [esp+44h] [ebp-268h]
  int v42; // [esp+48h] [ebp-264h]
  int v43; // [esp+4Ch] [ebp-260h]
  int v44; // [esp+50h] [ebp-25Ch]
  int v45; // [esp+54h] [ebp-258h]
  int v46; // [esp+58h] [ebp-254h]
  int v47; // [esp+5Ch] [ebp-250h]
  unsigned int v48; // [esp+2A0h] [ebp-Ch]

  v24 = a1;
  v48 = __readgsdword(0x14u);
  sub_804B397();
  if ( byte_80717A6 )
  {
    v4 = sub_8052340(v2, v3, (int)&v29, 0x28Cu, v24);
    if ( dword_8071771 != 4 )
    {
      dword_80711FC = (int)&loc_8053E88;
      sub_8064D6B(v13, v14, v15, v16, v17, v18, v19);
    }
    v15 = v4;
    v14 = 0;
    printf("%*s ");
  }
  if ( byte_8071780 )
  {
    if ( *(_BYTE *)(v24 + 120) == 1 )
    {
      v6 = *(_DWORD *)(v24 + 72);
      v7 = *(_DWORD *)(v24 + 68);
      *(_QWORD *)&v19 = qword_8071785;
      v17 = 512;
      v18 = 0;
      v16 = dword_8071781;
      v15 = (const char *)(&v13 - 166);
      v14 = v6;
      v5 = (const char *)sub_80598C8(v7);
    }
    else
    {
      v5 = "?";
    }
    if ( dword_8071771 != 4 )
    {
      dword_8071238 = (int)&loc_8053F50;
      v5 = (const char *)sub_8064C1B(
                           v13,
                           v14,
                           v15,
                           v16,
                           v17,
                           v18,
                           v19,
                           v20,
                           v21,
                           v22,
                           v23,
                           v24,
                           v25,
                           v26,
                           v27,
                           v28,
                           *(_DWORD *)&v29,
                           v30,
                           v31,
                           v32,
                           v33,
                           v34,
                           v35,
                           v36,
                           v37,
                           v38,
                           v39,
                           v40,
                           v41,
                           v42,
                           v43,
                           v44,
                           v45,
                           v46,
                           v47);
    }
    v15 = v5;
    v14 = 0;
    printf("%*s ", 0, v5);
  }
  if ( byte_8071745 )
  {
    if ( dword_8071771 == 4 )
      v8 = 0;
    else
      v8 = dword_8071755;
    v15 = *(const char **)(v24 + 116);
    v14 = v8;
    printf("%*s ", v8, v15);
  }
  v28 = sub_8053C24(v24, 0, 0, a2);
  if ( dword_8071795 )
  {
    v9 = *(_DWORD *)(v24 + 28);
    v10 = *(_BYTE *)(v24 + 120);
    v15 = *(const char **)(v24 + 108);
    v11 = sub_805419B(v10, v9, (int)v15);
    v28 += v11;
  }
  return v28;
}
// 80598C8: using guessed type _DWORD __cdecl sub_80598C8(_DWORD);
// 8064C1B: using guessed type int __stdcall sub_8064C1B(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8064D6B: using guessed type int __stdcall sub_8064D6B(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80711FC: using guessed type int dword_80711FC;
// 8071238: using guessed type int dword_8071238;
// 8071745: using guessed type char byte_8071745;
// 8071749: using guessed type int dword_8071749;
// 807174D: using guessed type int dword_807174D;
// 8071771: using guessed type int dword_8071771;
// 8071780: using guessed type char byte_8071780;
// 8071781: using guessed type int dword_8071781;
// 8071785: using guessed type __int64 qword_8071785;
// 8071795: using guessed type int dword_8071795;
// 80717A6: using guessed type char byte_80717A6;

//----- (0805403F) --------------------------------------------------------
#error "8054177: call analysis failed (funcsize=103)"

//----- (0805419B) --------------------------------------------------------
bool __cdecl sub_805419B(unsigned __int8 a1, int a2, int a3)
{
  char v3; // al
  char v5; // [esp+1Fh] [ebp-9h]

  v3 = sub_805403F(a1, a2, a3);
  v5 = v3;
  if ( v3 )
  {
    putchar_unlocked(v3);
    ++dword_8071889;
  }
  return v5 != 0;
}
// 805403F: using guessed type _DWORD __cdecl sub_805403F(_DWORD, _DWORD, _DWORD);
// 8071889: using guessed type int dword_8071889;

//----- (08054208) --------------------------------------------------------
bool __cdecl sub_8054208(int a1)
{
  if ( a1 )
  {
    if ( (unsigned __int8)sub_804B2EB(4) )
      sub_804B377();
    sub_80546A8((int)dword_80712A8);
    sub_80546A8(a1);
    sub_80546A8((int)&dword_80712B0);
  }
  return a1 != 0;
}
// 80712A8: using guessed type int dword_80712A8[];
// 80712B0: using guessed type int dword_80712B0;

//----- (08054255) --------------------------------------------------------
#error "80545B6: call analysis failed (funcsize=294)"

//----- (080546A8) --------------------------------------------------------
size_t __cdecl sub_80546A8(int a1)
{
  if ( byte_807179B != 1 )
  {
    byte_807179B = 1;
    if ( tcgetpgrp(1) >= 0 )
      sub_804B6A8();
    sub_8053DAD();
  }
  return fwrite_unlocked(*(const void **)(a1 + 4), *(_DWORD *)a1, 1u, stdout);
}
// 807179B: using guessed type char byte_807179B;

//----- (08054708) --------------------------------------------------------
void __cdecl sub_8054708(int a1)
{
  const char *v1; // eax
  char v2; // [esp+40h] [ebp-298h]
  unsigned int v3; // [esp+2CCh] [ebp-Ch]

  v3 = __readgsdword(0x14u);
  JUMPOUT(byte_80717A6, 0, &loc_8058DC6);
  dword_8071254 = (int (*)(void))sub_80547BA;
  JUMPOUT(dword_8071771, 4, &loc_8058DC6);
  v1 = (const char *)sub_805AE4B(*(_QWORD *)(a1 + 100), (int)&v2);
  strlen(v1);
  dword_8071254 = (int (*)(void))&loc_80547C2;
  JUMPOUT(&loc_8058DC6);
}
// 8071254: using guessed type int (*dword_8071254)(void);
// 8071771: using guessed type int dword_8071771;
// 80717A6: using guessed type char byte_80717A6;

//----- (080547BA) --------------------------------------------------------
void __usercall sub_80547BA(int a1@<ebp>)
{
  bool v1; // zf
  int _0; // [esp+0h] [ebp+0h]

  *(_DWORD *)(a1 - 668) += dword_8071749 + 1;
  JUMPOUT(byte_8071780, 0, &loc_8058DC6);
  dword_8071254 = (int (*)(void))sub_80548BA;
  JUMPOUT(dword_8071771, 4, &loc_8058DC6);
  v1 = *(_BYTE *)(*(&_0 - 171) + 120) == 1;
  dword_8071254 = (int (*)(void))sub_805483C;
  JUMPOUT(v1, &loc_8058DC6);
  dword_8071254 = (int (*)(void))&loc_805489C;
  JUMPOUT(&loc_8058DC6);
}
// 805483C: using guessed type int __cdecl sub_805483C(int, int, int, int, int, int, int);
// 80548BA: using guessed type int sub_80548BA();
// 8071254: using guessed type int (*dword_8071254)(void);
// 8071749: using guessed type int dword_8071749;
// 8071771: using guessed type int dword_8071771;
// 8071780: using guessed type char byte_8071780;

//----- (0805483C) --------------------------------------------------------
#error "8054897: call analysis failed (funcsize=26)"

//----- (08054A0C) --------------------------------------------------------
unsigned int sub_8054A0C()
{
  unsigned int v0; // ST28_4
  int v1; // ST34_4
  int v2; // eax
  int v3; // eax
  unsigned int result; // eax
  unsigned int i; // [esp+18h] [ebp-30h]
  int v6; // [esp+1Ch] [ebp-2Ch]
  unsigned int v7; // [esp+20h] [ebp-28h]
  unsigned int j; // [esp+24h] [ebp-24h]
  char *v9; // [esp+2Ch] [ebp-1Ch]
  unsigned int v10; // [esp+30h] [ebp-18h]
  int v11; // [esp+38h] [ebp-10h]
  int v12; // [esp+3Ch] [ebp-Ch]

  v0 = sub_8055108(1);
  v9 = (char *)dword_8071881 + 12 * v0 - 12;
  v10 = dword_8071721 / v0 + (dword_8071721 % v0 != 0);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v10 )
      break;
    v6 = 0;
    v7 = i;
    for ( j = 0; ; j += v12 )
    {
      v1 = *((_DWORD *)dword_8071729 + v7);
      sub_8054708(v1);
      v11 = v2;
      v3 = v6++;
      v12 = *(_DWORD *)(*((_DWORD *)v9 + 2) + 4 * v3);
      sub_8053DFC(v1, j);
      v7 += v10;
      if ( v7 >= dword_8071721 )
        break;
      sub_8054DBE(j + v11, v12 + j);
    }
    putchar_unlocked(10);
  }
  return result;
}
// 8071721: using guessed type int dword_8071721;

//----- (08054B54) --------------------------------------------------------
int sub_8054B54()
{
  int v0; // ST28_4
  int v1; // eax
  int v2; // eax
  int v3; // ST28_4
  unsigned int i; // [esp+10h] [ebp-28h]
  unsigned int v6; // [esp+14h] [ebp-24h]
  int v7; // [esp+18h] [ebp-20h]
  int v8; // [esp+1Ch] [ebp-1Ch]
  unsigned int v9; // [esp+20h] [ebp-18h]
  char *v10; // [esp+24h] [ebp-14h]

  v6 = 0;
  v9 = sub_8055108(0);
  v10 = (char *)dword_8071881 + 12 * v9 - 12;
  v0 = *(_DWORD *)dword_8071729;
  sub_8054708(*(_DWORD *)dword_8071729);
  v7 = v1;
  v8 = **((_DWORD **)v10 + 2);
  sub_8053DFC(v0, 0);
  for ( i = 1; i < dword_8071721; ++i )
  {
    if ( i % v9 )
    {
      sub_8054DBE(v6 + v7, v8 + v6);
      v6 += v8;
    }
    else
    {
      putchar_unlocked(10);
      v6 = 0;
    }
    v3 = *((_DWORD *)dword_8071729 + i);
    sub_8053DFC(v3, v6);
    sub_8054708(v3);
    v7 = v2;
    v8 = *(_DWORD *)(4 * (i % v9) + *((_DWORD *)v10 + 2));
  }
  return putchar_unlocked(10);
}
// 8071721: using guessed type int dword_8071721;

//----- (08054CC9) --------------------------------------------------------
int __cdecl sub_8054CC9(char a1)
{
  int v1; // eax
  char v3; // [esp+1Fh] [ebp-19h]
  unsigned int i; // [esp+20h] [ebp-18h]
  unsigned int v5; // [esp+24h] [ebp-14h]
  int v6; // [esp+28h] [ebp-10h]
  int v7; // [esp+2Ch] [ebp-Ch]

  v5 = 0;
  for ( i = 0; i < dword_8071721; ++i )
  {
    v6 = *((_DWORD *)dword_8071729 + i);
    if ( dword_80717D1 )
      sub_8054708(v6);
    else
      v1 = 0;
    v7 = v1;
    if ( i )
    {
      if ( dword_80717D1 && (v5 + v1 + 2 >= dword_80717D1 || -3 - v1 < v5) )
      {
        v5 = 0;
        v3 = 10;
      }
      else
      {
        v5 += 2;
        v3 = 32;
      }
      putchar_unlocked(a1);
      putchar_unlocked(v3);
    }
    sub_8053DFC(v6, v5);
    v5 += v7;
  }
  return putchar_unlocked(10);
}
// 8071721: using guessed type int dword_8071721;
// 80717D1: using guessed type int dword_80717D1;

//----- (08054DBE) --------------------------------------------------------
unsigned int __cdecl sub_8054DBE(unsigned int a1, unsigned int a2)
{
  unsigned int result; // eax

  while ( 1 )
  {
    result = a1;
    if ( a1 >= a2 )
      break;
    if ( dword_80717C9 && a2 / dword_80717C9 > (a1 + 1) / dword_80717C9 )
    {
      putchar_unlocked(9);
      a1 += dword_80717C9 - a1 % dword_80717C9;
    }
    else
    {
      putchar_unlocked(32);
      ++a1;
    }
  }
  return result;
}
// 80717C9: using guessed type int dword_80717C9;

//----- (08054E5C) --------------------------------------------------------
_BYTE *__cdecl sub_8054E5C(_BYTE *a1, _BYTE *a2, _BYTE *a3)
{
  _BYTE *v3; // eax
  _BYTE *v4; // edx
  _BYTE *result; // eax
  _BYTE *v6; // eax
  _BYTE *v7; // eax
  _BYTE *v8; // edx
  _BYTE *v9; // [esp+Ch] [ebp-4h]

  v9 = a2;
  if ( *a2 != 46 || a2[1] )
  {
    while ( *v9 )
    {
      v3 = a1++;
      v4 = v9++;
      *v3 = *v4;
    }
    if ( v9 > a2 && *(v9 - 1) != 47 )
    {
      v6 = a1++;
      *v6 = 47;
    }
  }
  while ( *a3 )
  {
    v7 = a1++;
    v8 = a3++;
    *v7 = *v8;
  }
  result = a1;
  *a1 = 0;
  return result;
}

//----- (08054EF8) --------------------------------------------------------
unsigned int sub_8054EF8()
{
  unsigned int v0; // eax
  unsigned int result; // eax
  unsigned int i; // [esp+10h] [ebp-28h]
  unsigned int j; // [esp+10h] [ebp-28h]
  unsigned int v4; // [esp+14h] [ebp-24h]
  char *v5; // [esp+18h] [ebp-20h]
  unsigned int k; // [esp+1Ch] [ebp-1Ch]
  unsigned int v7; // [esp+20h] [ebp-18h]
  unsigned int v8; // [esp+28h] [ebp-10h]
  unsigned int v9; // [esp+2Ch] [ebp-Ch]

  v0 = dword_8071885;
  if ( dword_8071721 <= (unsigned int)dword_8071885 )
    v0 = dword_8071721;
  v7 = v0;
  if ( dword_807272D < v0 )
  {
    if ( (unsigned int)dword_8071885 >> 1 <= v0 )
    {
      dword_8071881 = sub_80614F4(dword_8071881, dword_8071885, 12);
      v4 = dword_8071885;
    }
    else
    {
      dword_8071881 = sub_80614F4(dword_8071881, v0, 24);
      v4 = 2 * v7;
    }
    v8 = dword_807272D + v4 + 1;
    v9 = (v4 - dword_807272D) * v8;
    if ( v8 < v4 || v9 / (v4 - dword_807272D) != v8 )
      sub_8061768();
    v5 = (char *)sub_80614C6(v9 >> 1, 4u);
    for ( i = dword_807272D; i < v4; ++i )
    {
      *((_DWORD *)dword_8071881 + 3 * i + 2) = v5;
      v5 += 4 * (i + 1);
    }
    dword_807272D = v4;
  }
  for ( j = 0; ; ++j )
  {
    result = j;
    if ( j >= v7 )
      break;
    *((_BYTE *)dword_8071881 + 12 * j) = 1;
    *((_DWORD *)dword_8071881 + 3 * j + 1) = 3 * (j + 1);
    for ( k = 0; k <= j; ++k )
      *(_DWORD *)(4 * k + *((_DWORD *)dword_8071881 + 3 * j + 2)) = 3;
  }
  return result;
}
// 8071721: using guessed type int dword_8071721;
// 807272D: using guessed type int dword_807272D;

//----- (08055108) --------------------------------------------------------
unsigned int __cdecl sub_8055108(char a1)
{
  int v1; // eax
  int v2; // eax
  unsigned int v3; // eax
  signed int v4; // eax
  unsigned int i; // [esp+10h] [ebp-38h]
  unsigned int k; // [esp+14h] [ebp-34h]
  unsigned int j; // [esp+18h] [ebp-30h]
  unsigned int v9; // [esp+1Ch] [ebp-2Ch]
  int v10; // [esp+24h] [ebp-24h]
  unsigned int v11; // [esp+28h] [ebp-20h]
  int v12; // [esp+2Ch] [ebp-1Ch]

  v1 = dword_8071885;
  if ( dword_8071721 <= (unsigned int)dword_8071885 )
    v1 = dword_8071721;
  v9 = v1;
  sub_8054EF8();
  for ( i = 0; i < dword_8071721; ++i )
  {
    sub_8054708(*((_DWORD *)dword_8071729 + i));
    v10 = v2;
    for ( j = 0; j < v9; ++j )
    {
      if ( *((_BYTE *)dword_8071881 + 12 * j) )
      {
        v3 = a1 ? i / ((dword_8071721 + j) / (j + 1)) : i % (j + 1);
        v11 = v3;
        v4 = v3 == j ? 0 : 2;
        v12 = v10 + v4;
        if ( *(_DWORD *)(4 * v11 + *((_DWORD *)dword_8071881 + 3 * j + 2)) < (unsigned int)(v10 + v4) )
        {
          *((_DWORD *)dword_8071881 + 3 * j + 1) += v12 - *(_DWORD *)(4 * v11 + *((_DWORD *)dword_8071881 + 3 * j + 2));
          *(_DWORD *)(*((_DWORD *)dword_8071881 + 3 * j + 2) + 4 * v11) = v12;
          *((_BYTE *)dword_8071881 + 12 * j) = *((_DWORD *)dword_8071881 + 3 * j + 1) < (unsigned int)dword_80717D1;
        }
      }
    }
  }
  for ( k = v9; k > 1 && !*((_BYTE *)dword_8071881 + 12 * k - 12); --k )
    ;
  return k;
}
// 8071721: using guessed type int dword_8071721;
// 80717D1: using guessed type int dword_80717D1;

//----- (0805538B) --------------------------------------------------------
void __cdecl __noreturn sub_805538B(int status)
{
  int v1; // ebx
  char *v2; // eax
  int v3; // ebx
  char *v4; // eax
  FILE *v5; // ebx
  char *v6; // eax
  FILE *v7; // ebx
  char *v8; // eax
  FILE *v9; // ebx
  char *v10; // eax
  FILE *v11; // ebx
  char *v12; // eax
  FILE *v13; // ebx
  char *v14; // eax
  FILE *v15; // ebx
  char *v16; // eax
  FILE *v17; // ebx
  char *v18; // eax
  FILE *v19; // ebx
  char *v20; // eax
  FILE *v21; // ebx
  char *v22; // eax
  FILE *v23; // ebx
  char *v24; // eax
  FILE *v25; // ebx
  char *v26; // eax
  FILE *v27; // ebx
  char *v28; // eax
  FILE *v29; // ebx
  char *v30; // eax
  FILE *v31; // ebx
  char *v32; // eax
  FILE *v33; // ebx
  char *v34; // eax
  FILE *v35; // ebx
  char *v36; // eax
  FILE *v37; // ebx
  char *v38; // eax
  FILE *v39; // ebx
  char *v40; // eax
  FILE *v41; // ebx
  char *v42; // eax
  FILE *v43; // ebx
  char *v44; // eax
  FILE *v45; // ebx
  char *v46; // eax
  FILE *v47; // ebx
  char *v48; // eax
  FILE *v49; // ebx
  char *v50; // eax
  FILE *v51; // ebx
  char *v52; // eax
  char *v53; // eax

  if ( status )
  {
    v1 = dword_8072749;
    v2 = gettext("Try '%s --help' for more information.\n");
    fprintf(stderr, v2, v1);
  }
  else
  {
    v3 = dword_8072749;
    v4 = gettext("Usage: %s [OPTION]... [FILE]...\n");
    printf(v4, v3);
    v5 = stdout;
    v6 = gettext(
           "List information about the FILEs (the current directory by default).\n"
           "Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.\n");
    fputs_unlocked(v6, v5);
    sub_804A7AD();
    v7 = stdout;
    v8 = gettext(
           "  -a, --all                  do not ignore entries starting with .\n"
           "  -A, --almost-all           do not list implied . and ..\n"
           "      --author               with -l, print the author of each file\n"
           "  -b, --escape               print C-style escapes for nongraphic characters\n");
    fputs_unlocked(v8, v7);
    v9 = stdout;
    v10 = gettext(
            "      --block-size=SIZE      scale sizes by SIZE before printing them; e.g.,\n"
            "                               '--block-size=M' prints sizes in units of\n"
            "                               1,048,576 bytes; see SIZE format below\n"
            "  -B, --ignore-backups       do not list implied entries ending with ~\n"
            "  -c                         with -lt: sort by, and show, ctime (time of last\n"
            "                               modification of file status information);\n"
            "                               with -l: show ctime and sort by name;\n"
            "                               otherwise: sort by ctime, newest first\n");
    fputs_unlocked(v10, v9);
    v11 = stdout;
    v12 = gettext(
            "  -C                         list entries by columns\n"
            "      --color[=WHEN]         colorize the output; WHEN can be 'always' (default\n"
            "                               if omitted), 'auto', or 'never'; more info below\n"
            "  -d, --directory            list directories themselves, not their contents\n"
            "  -D, --dired                generate output designed for Emacs' dired mode\n");
    fputs_unlocked(v12, v11);
    v13 = stdout;
    v14 = gettext(
            "  -f                         do not sort, enable -aU, disable -ls --color\n"
            "  -F, --classify             append indicator (one of */=>@|) to entries\n"
            "      --file-type            likewise, except do not append '*'\n"
            "      --format=WORD          across -x, commas -m, horizontal -x, long -l,\n"
            "                               single-column -1, verbose -l, vertical -C\n"
            "      --full-time            like -l --time-style=full-iso\n");
    fputs_unlocked(v14, v13);
    v15 = stdout;
    v16 = gettext("  -g                         like -l, but do not list owner\n");
    fputs_unlocked(v16, v15);
    v17 = stdout;
    v18 = gettext(
            "      --group-directories-first\n"
            "                             group directories before files;\n"
            "                               can be augmented with a --sort option, but any\n"
            "                               use of --sort=none (-U) disables grouping\n");
    fputs_unlocked(v18, v17);
    v19 = stdout;
    v20 = gettext(
            "  -G, --no-group             in a long listing, don't print group names\n"
            "  -h, --human-readable       with -l and/or -s, print human readable sizes\n"
            "                               (e.g., 1K 234M 2G)\n"
            "      --si                   likewise, but use powers of 1000 not 1024\n");
    fputs_unlocked(v20, v19);
    v21 = stdout;
    v22 = gettext(
            "  -H, --dereference-command-line\n"
            "                             follow symbolic links listed on the command line\n"
            "      --dereference-command-line-symlink-to-dir\n"
            "                             follow each command line symbolic link\n"
            "                               that points to a directory\n"
            "      --hide=PATTERN         do not list implied entries matching shell PATTERN\n"
            "                               (overridden by -a or -A)\n");
    fputs_unlocked(v22, v21);
    v23 = stdout;
    v24 = gettext(
            "      --hyperlink[=WHEN]     hyperlink file names; WHEN can be 'always'\n"
            "                               (default if omitted), 'auto', or 'never'\n");
    fputs_unlocked(v24, v23);
    v25 = stdout;
    v26 = gettext(
            "      --indicator-style=WORD  append indicator with style WORD to entry names:\n"
            "                               none (default), slash (-p),\n"
            "                               file-type (--file-type), classify (-F)\n"
            "  -i, --inode                print the index number of each file\n"
            "  -I, --ignore=PATTERN       do not list implied entries matching shell PATTERN\n"
            "  -k, --kibibytes            default to 1024-byte blocks for disk usage\n");
    fputs_unlocked(v26, v25);
    v27 = stdout;
    v28 = gettext(
            "  -l                         use a long listing format\n"
            "  -L, --dereference          when showing file information for a symbolic\n"
            "                               link, show information for the file the link\n"
            "                               references rather than for the link itself\n"
            "  -m                         fill width with a comma separated list of entries\n");
    fputs_unlocked(v28, v27);
    v29 = stdout;
    v30 = gettext(
            "  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs\n"
            "  -N, --literal              print entry names without quoting\n"
            "  -o                         like -l, but do not list group information\n"
            "  -p, --indicator-style=slash\n"
            "                             append / indicator to directories\n");
    fputs_unlocked(v30, v29);
    v31 = stdout;
    v32 = gettext(
            "  -q, --hide-control-chars   print ? instead of nongraphic characters\n"
            "      --show-control-chars   show nongraphic characters as-is (the default,\n"
            "                               unless program is 'ls' and output is a terminal)\n"
            "  -Q, --quote-name           enclose entry names in double quotes\n"
            "      --quoting-style=WORD   use quoting style WORD for entry names:\n"
            "                               literal, locale, shell, shell-always,\n"
            "                               shell-escape, shell-escape-always, c, escape\n");
    fputs_unlocked(v32, v31);
    v33 = stdout;
    v34 = gettext(
            "  -r, --reverse              reverse order while sorting\n"
            "  -R, --recursive            list subdirectories recursively\n"
            "  -s, --size                 print the allocated size of each file, in blocks\n");
    fputs_unlocked(v34, v33);
    v35 = stdout;
    v36 = gettext(
            "  -S                         sort by file size, largest first\n"
            "      --sort=WORD            sort by WORD instead of name: none (-U), size (-S),\n"
            "                               time (-t), version (-v), extension (-X)\n"
            "      --time=WORD            with -l, show time as WORD instead of default\n"
            "                               modification time: atime or access or use (-u);\n"
            "                               ctime or status (-c); also use specified time\n"
            "                               as sort key if --sort=time (newest first)\n");
    fputs_unlocked(v36, v35);
    v37 = stdout;
    v38 = gettext(
            "      --time-style=STYLE     with -l, show times using style STYLE:\n"
            "                               full-iso, long-iso, iso, locale, or +FORMAT;\n"
            "                               FORMAT is interpreted like in 'date'; if FORMAT\n"
            "                               is FORMAT1<newline>FORMAT2, then FORMAT1 applies\n"
            "                               to non-recent files and FORMAT2 to recent files;\n"
            "                               if STYLE is prefixed with 'posix-', STYLE\n"
            "                               takes effect only outside the POSIX locale\n");
    fputs_unlocked(v38, v37);
    v39 = stdout;
    v40 = gettext(
            "  -t                         sort by modification time, newest first\n"
            "  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8\n");
    fputs_unlocked(v40, v39);
    v41 = stdout;
    v42 = gettext(
            "  -u                         with -lt: sort by, and show, access time;\n"
            "                               with -l: show access time and sort by name;\n"
            "                               otherwise: sort by access time, newest first\n"
            "  -U                         do not sort; list entries in directory order\n"
            "  -v                         natural sort of (version) numbers within text\n");
    fputs_unlocked(v42, v41);
    v43 = stdout;
    v44 = gettext(
            "  -w, --width=COLS           set output width to COLS.  0 means no limit\n"
            "  -x                         list entries by lines instead of by columns\n"
            "  -X                         sort alphabetically by entry extension\n"
            "  -Z, --context              print any security context of each file\n"
            "  -1                         list one file per line.  Avoid '\\n' with -q or -b\n");
    fputs_unlocked(v44, v43);
    v45 = stdout;
    v46 = gettext("      --help     display this help and exit\n");
    fputs_unlocked(v46, v45);
    v47 = stdout;
    v48 = gettext("      --version  output version information and exit\n");
    fputs_unlocked(v48, v47);
    sub_804A7D8();
    v49 = stdout;
    v50 = gettext(
            "\n"
            "Using color to distinguish file types is disabled both by default and\n"
            "with --color=never.  With --color=auto, ls emits color codes only when\n"
            "standard output is connected to a terminal.  The LS_COLORS environment\n"
            "variable can change the settings.  Use the dircolors command to set it.\n");
    fputs_unlocked(v50, v49);
    v51 = stdout;
    v52 = gettext(
            "\n"
            "Exit status:\n"
            " 0  if OK,\n"
            " 1  if minor problems (e.g., cannot access subdirectory),\n"
            " 2  if serious trouble (e.g., cannot access command-line argument).\n");
    fputs_unlocked(v52, v51);
    if ( dword_80713B0 == 1 )
    {
      v53 = "ls";
    }
    else if ( dword_80713B0 == 2 )
    {
      v53 = "dir";
    }
    else
    {
      v53 = "vdir";
    }
    sub_804A803(v53);
  }
  exit(status);
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 80713B0: using guessed type int dword_80713B0;
// 8072749: using guessed type int dword_8072749;

//----- (080556F7) --------------------------------------------------------
void sub_80556F7()
{
  dword_8071254 = (int (*)(void))sub_805574E;
  JUMPOUT(0, &loc_8058DC6);
  dword_8071254 = (int (*)(void))&loc_8055751;
  JUMPOUT(&loc_8058DC6);
}
// 8071254: using guessed type int (*dword_8071254)(void);

//----- (0805574E) --------------------------------------------------------
void __usercall sub_805574E(int a1@<ebp>)
{
  bool v1; // cf

  *(_DWORD *)(a1 - 28) = *(_DWORD *)(a1 - 32);
  v1 = *(_DWORD *)(a1 + 12) < *(_DWORD *)(a1 - 28);
  dword_8071254 = (int (*)(void))sub_8055787;
  JUMPOUT(!v1, &loc_8058DC6);
  dword_8071254 = (int (*)(void))&loc_805578A;
  JUMPOUT(&loc_8058DC6);
}
// 8055787: using guessed type int sub_8055787();
// 8071254: using guessed type int (*dword_8071254)(void);

//----- (08055787) --------------------------------------------------------
#error "8055793: call analysis failed (funcsize=16)"

//----- (080557CB) --------------------------------------------------------
#error "80557DF: call analysis failed (funcsize=45)"

//----- (0805597D) --------------------------------------------------------
void __noreturn sub_805597D()
{
  sub_805538B(1);
}

//----- (08055991) --------------------------------------------------------
#error "8055A3F: call analysis failed (funcsize=111)"

//----- (08055B34) --------------------------------------------------------
void __cdecl sub_8055B34(int a1, int a2, int a3)
{
  char *v3; // eax
  int v4; // eax
  int v5; // ebx
  char *format; // ST2C_4
  int v7; // eax

  if ( a3 == -1 )
    v3 = gettext("invalid argument %s for %s");
  else
    v3 = gettext("ambiguous argument %s for %s");
  format = v3;
  sub_8060718(1);
  v5 = v4;
  sub_8060223(0, 8);
  error(0, 0, format, v7, v5);
}

//----- (08055BD3) --------------------------------------------------------
int __cdecl sub_8055BD3(int a1, int a2, size_t n)
{
  FILE *v3; // ebx
  char *v4; // eax
  int v5; // eax
  int v6; // eax
  int v8; // [esp+0h] [ebp-28h]
  const void *v9; // [esp+4h] [ebp-24h]
  int v10; // [esp+8h] [ebp-20h]
  int i; // [esp+18h] [ebp-10h]
  void *s1; // [esp+1Ch] [ebp-Ch]

  s1 = 0;
  v3 = stderr;
  v4 = gettext("Valid arguments are:");
  fputs_unlocked(v4, v3);
  for ( i = 0; *(_DWORD *)(4 * i + a1); ++i )
  {
    if ( i && (v9 = (const void *)(a2 + i * n), !memcmp(s1, v9, n)) )
    {
      v8 = *(_DWORD *)(4 * i + a1);
      sub_806073A();
      v10 = v6;
      fprintf(stderr, ", %s", v6);
    }
    else
    {
      v8 = *(_DWORD *)(4 * i + a1);
      sub_806073A();
      v10 = v5;
      fprintf(stderr, "\n  - %s", v5);
      s1 = (void *)(i * n + a2);
    }
  }
  return putc_unlocked(10, stderr);
}
// 8049860: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (08055CFA) --------------------------------------------------------
int __cdecl sub_8055CFA(int a1, char *s, int a3, int a4, size_t n, int a6)
{
  int v7; // [esp+0h] [ebp-Ch]

  v7 = sub_8055991(s, a3, a4, n);
  if ( v7 >= 0 )
    return v7;
  sub_8055B34(a1, (int)s, v7);
  sub_8055BD3(a3, a4, n);
  ((void (*)(void))a6)();
  return -1;
}

//----- (08055DF6) --------------------------------------------------------
signed int __cdecl sub_8055DF6(signed int a1)
{
  if ( a1 > 90 )
  {
    if ( (unsigned int)(a1 - 97) <= 0x19 )
      return 1;
  }
  else if ( a1 >= 65 || (unsigned int)(a1 - 48) <= 9 )
  {
    return 1;
  }
  return 0;
}

//----- (08055E26) --------------------------------------------------------
#error "8055E45: call analysis failed (funcsize=23)"

//----- (08055EF1) --------------------------------------------------------
_BOOL4 __cdecl sub_8055EF1(int a1)
{
  return (unsigned int)(a1 - 48) <= 9;
}

//----- (08056028) --------------------------------------------------------
int __cdecl sub_8056028(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 65) > 0x19 )
    result = a1;
  else
    result = a1 + 32;
  return result;
}

//----- (0805605E) --------------------------------------------------------
signed int __usercall sub_805605E@<eax>(int a1@<edx>, int a2@<ecx>, int *a3, int a4, int *a5)
{
  void *v5; // eax

  v5 = &loc_8056086;
  if ( *a3 )
    v5 = &loc_80560CB;
  dword_80711DC = (int)v5;
  sub_8064E3D(a2, a1);
  *a3 = sub_805835B(7u, 0, (int)sub_805939B);
  if ( !*a3 )
    sub_8061768();
  if ( sub_8056E69(*a3, a4, a5) )
    return 1;
  sub_8056D6F(*a3);
  return 0;
}
// 8064E3D: using guessed type double __fastcall sub_8064E3D(_DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;

//----- (08056113) --------------------------------------------------------
char *__cdecl sub_8056113(void *src, int a2)
{
  char *result; // eax
  int v3; // ecx
  void *v4; // edx
  char *v5; // ST50_4
  char *v7; // eax
  void *v8; // eax
  _BYTE v9[5]; // [esp+1h] [ebp-B1h]
  char *s; // [esp+6h] [ebp-ACh]
  char *dest; // [esp+Ah] [ebp-A8h]
  char *desta; // [esp+Ah] [ebp-A8h]
  _BYTE *v13; // [esp+12h] [ebp-A0h]
  int v14; // [esp+1Ah] [ebp-98h]

  v9[4] = 0;
  *(_DWORD *)v9 = (a2 & 4) != 0;
  if ( a2 & 3 & ((a2 & 3) - 1) )
  {
    *__errno_location() = 22;
    return 0;
  }
  if ( !src )
  {
    *__errno_location() = 22;
    return 0;
  }
  if ( *(_BYTE *)src )
  {
    if ( *(_BYTE *)src == 47 )
    {
      s = (char *)sub_80615D3(0x1000u);
      v14 = (int)(s + 4096);
      desta = s;
      v7 = desta;
      dest = desta + 1;
      *v7 = 47;
      v4 = src;
      v13 = src;
    }
    else
    {
      s = sub_806196B();
      if ( !s )
        return 0;
      dest = strchr(s, 0);
      v4 = (void *)(dest - s);
      if ( dest - s > 4095 )
      {
        v14 = (int)dest;
      }
      else
      {
        v5 = (char *)sub_8061609(s, 0x1000u);
        v4 = (void *)(dest - s);
        dest = &v5[dest - s];
        s = v5;
        v14 = (int)(v5 + 4096);
      }
      v13 = src;
    }
    v8 = &loc_8056993;
    if ( *v13 )
      v8 = &loc_805635C;
    dword_8071210 = (int)v8;
    sub_8064CF3(v3, v4);
    if ( s + 1 < dest && *(dest - 1) == 47 )
      --dest;
    *dest = 0;
    if ( dest + 1 != (char *)v14 )
      s = (char *)sub_8061609(s, dest - s + 1);
    free(0);
    if ( *(_DWORD *)&v9[1] )
      sub_80585C6(*(void **)&v9[1]);
    result = s;
  }
  else
  {
    *__errno_location() = 2;
    result = 0;
  }
  return result;
}
// 8064CF3: using guessed type int __fastcall sub_8064CF3(_DWORD, _DWORD);
// 8071210: using guessed type int dword_8071210;

//----- (08056B96) --------------------------------------------------------
#error "8056BCD: call analysis failed (funcsize=45)"

//----- (08056C1C) --------------------------------------------------------
void *__cdecl sub_8056C1C(void *src)
{
  size_t v2; // eax
  size_t n; // [esp+18h] [ebp-10h]
  void *dest; // [esp+1Ch] [ebp-Ch]

  n = sub_8056B96(src);
  dest = malloc((n == 0) + n + 1);
  if ( !dest )
    return 0;
  memcpy(dest, src, n);
  if ( n == 0 )
  {
    v2 = n++;
    *((_BYTE *)dest + v2) = 46;
  }
  *((_BYTE *)dest + n) = 0;
  return dest;
}
// 8056B96: using guessed type _DWORD __cdecl sub_8056B96(_DWORD);

//----- (08056C9E) --------------------------------------------------------
#error "8056CBC: call analysis failed (funcsize=39)"

//----- (08056D0E) --------------------------------------------------------
size_t __cdecl sub_8056D0E(char *s)
{
  void *v1; // eax
  int v3; // [esp+0h] [ebp-28h]
  int v4; // [esp+4h] [ebp-24h]
  int v5; // [esp+8h] [ebp-20h]
  int v6; // [esp+Ch] [ebp-1Ch]
  int v7; // [esp+10h] [ebp-18h]
  int v8; // [esp+14h] [ebp-14h]
  size_t v9; // [esp+18h] [ebp-10h]

  v9 = strlen(s);
  if ( v9 > 1 )
  {
    v1 = &loc_8056D60;
    if ( s[v9 - 1] == 47 )
      v1 = &loc_8056D2B;
    dword_80711FC = (int)v1;
    sub_8064D6B(v3, v4, v5, v6, v7, v8, v9);
  }
  return v9;
}
// 8064D6B: using guessed type int __stdcall sub_8064D6B(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80711FC: using guessed type int dword_80711FC;

//----- (08056D65) --------------------------------------------------------
int sub_8056D65()
{
  return 0;
}

//----- (08056D6F) --------------------------------------------------------
void __cdecl sub_8056D6F(int a1)
{
  dword_8071254 = (int (*)(void))sub_8056DA0;
  JUMPOUT(a1, 0, &loc_8058DC6);
  dword_8071254 = (int (*)(void))&locret_8056E67;
  JUMPOUT(&loc_8058DC6);
}
// 8056DA0: using guessed type void __cdecl __noreturn sub_8056DA0(int);
// 8071254: using guessed type int (*dword_8071254)(void);

//----- (08056DA0) --------------------------------------------------------
#error "8056DA7: call analysis failed (funcsize=31)"

//----- (08056E69) --------------------------------------------------------
bool __cdecl sub_8056E69(int a1, int a2, int *a3)
{
  int v4; // edx
  int v5; // edx
  int v6; // [esp+0h] [ebp-38h]
  int v7; // [esp+1Ch] [ebp-1Ch]
  int v8; // [esp+20h] [ebp-18h]
  int v9; // [esp+24h] [ebp-14h]
  int v10; // [esp+28h] [ebp-10h]
  int v11; // [esp+2Ch] [ebp-Ch]

  if ( !a1 )
    return 0;
  v7 = a2;
  v4 = a3[23];
  v8 = a3[22];
  v9 = v4;
  v5 = a3[1];
  v10 = *a3;
  v11 = v5;
  return sub_8057DFE(a1, (int)(&v6 - 7)) != 0;
}

//----- (08056ED4) --------------------------------------------------------
#error "8056F3D: call analysis failed (funcsize=59)"

//----- (08056FC8) --------------------------------------------------------
#error "8057061: call analysis failed (funcsize=150)"

//----- (080571A8) --------------------------------------------------------
int __cdecl sub_80571A8(int a1, int a2)
{
  return sub_8056FC8(*(_DWORD *)(a1 + 16), a2);
}
// 8056FC8: using guessed type _DWORD __cdecl sub_8056FC8(_DWORD, _DWORD);

//----- (080571C5) --------------------------------------------------------
void __cdecl sub_80571C5(int a1, _BYTE *a2, _DWORD *a3)
{
  void *v3; // ST1C_4

  v3 = sub_8057231(a1, a2, a3);
  dword_8071254 = (int (*)(void))sub_8057204;
  JUMPOUT(v3, 0, &loc_8058DC6);
  sub_8061768();
}
// 8057204: using guessed type int sub_8057204();
// 8071254: using guessed type int (*dword_8071254)(void);

//----- (08057204) --------------------------------------------------------
#error "8057208: positive sp value has been found (funcsize=0)"

//----- (08057209) --------------------------------------------------------
_BYTE *__cdecl sub_8057209(_BYTE *a1)
{
  while ( *a1 == 47 )
    ++a1;
  return a1;
}

//----- (08057231) --------------------------------------------------------
void *__cdecl sub_8057231(int a1, _BYTE *a2, _DWORD *a3)
{
  _BOOL4 v3; // eax
  signed int v5; // eax
  size_t v6; // [esp+0h] [ebp-38h]
  char *v7; // [esp+10h] [ebp-28h]
  size_t v8; // [esp+14h] [ebp-24h]
  char *v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  char *s; // [esp+20h] [ebp-18h]
  size_t v12; // [esp+24h] [ebp-14h]
  void *v13; // [esp+28h] [ebp-10h]
  _BYTE *v14; // [esp+2Ch] [ebp-Ch]

  v7 = (char *)sub_8056C9E(a1);
  v8 = sub_8056D0E(v7);
  v9 = &v7[v8 - a1];
  v3 = v8 && v7[v8 - 1] != 47;
  v10 = v3;
  s = sub_8057209(a2);
  v12 = strlen(s);
  v6 = (size_t)&v9[v10 + 1 + v12];
  v13 = malloc(v6);
  if ( !v13 )
    return 0;
  v14 = (_BYTE *)mempcpy(v13, a1, v9);
  *v14 = 47;
  v14 += v10;
  if ( a3 )
  {
    if ( *a2 == 47 )
      v5 = -1;
    else
      v5 = 0;
    *a3 = &v14[v5];
  }
  *(_BYTE *)mempcpy(v14, s, v12) = 0;
  return v13;
}
// 80499B0: using guessed type int __cdecl mempcpy(_DWORD, _DWORD, _DWORD);
// 8056C9E: using guessed type _DWORD __cdecl sub_8056C9E(_DWORD);

//----- (08057357) --------------------------------------------------------
_BYTE *__usercall sub_8057357@<eax>(int a1@<edx>, int a2@<ecx>, int *a3)
{
  void *v3; // eax
  unsigned __int8 v4; // al
  char v6; // [esp+1Bh] [ebp-Dh]
  _BYTE *v7; // [esp+1Ch] [ebp-Ch]

  v7 = 0;
  v6 = 0;
  while ( *(_BYTE *)*a3 )
  {
    if ( v6 )
    {
      v6 = 0;
      if ( (unsigned __int8)sub_8055E26(*(char *)*a3) ^ 1 && *(_BYTE *)*a3 != 126 )
        v7 = 0;
    }
    else if ( *(_BYTE *)*a3 == 46 )
    {
      v6 = 1;
      v3 = &loc_80573D5;
      if ( v7 )
        v3 = &loc_80573E1;
      dword_8071210 = (int)v3;
      sub_8064CF3(a2, a1);
      v7 = (_BYTE *)*a3;
    }
    else
    {
      v4 = sub_8055DF6(*(char *)*a3);
      if ( v4 ^ 1 && *(_BYTE *)*a3 != 126 )
        v7 = 0;
    }
    a1 = *a3 + 1;
    *a3 = a1;
  }
  return v7;
}
// 8055E26: using guessed type _DWORD __cdecl sub_8055E26(_DWORD);
// 8064CF3: using guessed type int __fastcall sub_8064CF3(_DWORD, _DWORD);
// 8071210: using guessed type int dword_8071210;

//----- (0805743A) --------------------------------------------------------
int __cdecl sub_805743A(unsigned __int8 a1)
{
  if ( (unsigned __int8)sub_8055EF1(a1) )
    return 0;
  if ( (unsigned __int8)sub_8055E26(a1) )
    return a1;
  if ( a1 == 126 )
    return -1;
  return a1 + 256;
}
// 8055E26: using guessed type _DWORD __cdecl sub_8055E26(_DWORD);

//----- (0805748B) --------------------------------------------------------
int __cdecl sub_805748B(int a1, unsigned int a2, int a3, unsigned int a4)
{
  int v4; // eax
  int v5; // eax
  bool v7; // zf
  int v8; // edx
  int v9; // ecx
  void *v10; // eax
  bool v11; // al
  unsigned int v12; // [esp+1Ch] [ebp-1Ch]
  unsigned int v13; // [esp+20h] [ebp-18h]
  int v14; // [esp+24h] [ebp-14h]
  int v15; // [esp+28h] [ebp-10h]

  v12 = 0;
  v13 = 0;
  do
  {
    if ( v12 >= a2 && v13 >= a4 )
      return 0;
    v14 = 0;
    while ( 1 )
    {
      if ( v12 < a2 )
      {
        v7 = (unsigned __int8)sub_8055EF1(*(char *)(a1 + v12)) == 1;
        v10 = &loc_805755A;
        if ( !v7 )
          v10 = &loc_80574AD;
        dword_8071210 = (int)v10;
        sub_8064CF3(v9, v8);
      }
      if ( v13 >= a4 || !((unsigned __int8)sub_8055EF1(*(char *)(a3 + v13)) ^ 1) )
        break;
      if ( v12 == a2 )
        v4 = 0;
      else
        v4 = sub_805743A(*(_BYTE *)(a1 + v12));
      v15 = v4;
      if ( v13 == a4 )
        v5 = 0;
      else
        v5 = sub_805743A(*(_BYTE *)(a3 + v13));
      if ( v15 != v5 )
        return v15 - v5;
      ++v12;
      ++v13;
    }
    while ( *(_BYTE *)(a1 + v12) == 48 )
      ++v12;
    while ( *(_BYTE *)(a3 + v13) == 48 )
      ++v13;
    while ( 1 )
    {
      v11 = sub_8055EF1(*(char *)(a1 + v12));
      if ( !v11 || !(unsigned __int8)sub_8055EF1(*(char *)(a3 + v13)) )
        break;
      if ( !v14 )
        v14 = *(char *)(a1 + v12) - *(char *)(a3 + v13);
      ++v12;
      ++v13;
    }
    if ( (unsigned __int8)sub_8055EF1(*(char *)(a1 + v12)) )
      return 1;
    if ( (unsigned __int8)sub_8055EF1(*(char *)(a3 + v13)) )
      return -1;
  }
  while ( !v14 );
  return v14;
}
// 8064CF3: using guessed type int __fastcall sub_8064CF3(_DWORD, _DWORD);
// 8071210: using guessed type int dword_8071210;

//----- (080576BB) --------------------------------------------------------
void __cdecl sub_80576BB(char *s1, char *s2)
{
  int v2; // ST20_4

  v2 = strcmp(s1, s2);
  dword_8071254 = (int (*)(void))sub_8057706;
  JUMPOUT(v2, 0, &loc_8058DC6);
  dword_8071254 = (int (*)(void))&locret_8057B19;
  JUMPOUT(&loc_8058DC6);
}
// 8071254: using guessed type int (*dword_8071254)(void);

//----- (08057706) --------------------------------------------------------
void __usercall sub_8057706(int a1@<ebp>)
{
  char v1; // al

  v1 = **(_BYTE **)(a1 + 8);
  dword_8071254 = (int (*)(void))sub_805773A;
  JUMPOUT(v1, 0, &loc_8058DC6);
  dword_8071254 = (int (*)(void))&locret_8057B19;
  JUMPOUT(&loc_8058DC6);
}
// 8071254: using guessed type int (*dword_8071254)(void);

//----- (0805773A) --------------------------------------------------------
void __usercall sub_805773A(int a1@<ebp>)
{
  char v1; // al

  v1 = **(_BYTE **)(a1 + 12);
  dword_8071254 = (int (*)(void))sub_805776E;
  JUMPOUT(v1, 0, &loc_8058DC6);
  dword_8071254 = (int (*)(void))&locret_8057B19;
  JUMPOUT(&loc_8058DC6);
}
// 8071254: using guessed type int (*dword_8071254)(void);

//----- (0805776E) --------------------------------------------------------
#error "805777C: call analysis failed (funcsize=14)"

//----- (080577AF) --------------------------------------------------------
#error "80577BD: call analysis failed (funcsize=14)"

//----- (080577F0) --------------------------------------------------------
#error "80577FE: call analysis failed (funcsize=14)"

//----- (08057831) --------------------------------------------------------
#error "805783F: call analysis failed (funcsize=14)"

//----- (08057872) --------------------------------------------------------
#error "80578BA: call analysis failed (funcsize=27)"

//----- (080578D7) --------------------------------------------------------
void __usercall sub_80578D7(int a1@<ebp>, int a2, int a3, char *a4)
{
  char v4; // al
  char v5; // al

  v4 = **(_BYTE **)(a1 + 8);
  dword_8071254 = (int (*)(void))sub_8057927;
  JUMPOUT(v4, 46, &loc_8058DC6);
  v5 = *a4;
  dword_8071254 = (int (*)(void))sub_8057927;
  JUMPOUT(v5, 46, &loc_8058DC6);
  dword_8071254 = (int (*)(void))&locret_8057B19;
  JUMPOUT(&loc_8058DC6);
}
// 8057927: using guessed type int sub_8057927();
// 8071254: using guessed type int (*dword_8071254)(void);

//----- (08057927) --------------------------------------------------------
#error "8057979: call analysis failed (funcsize=46)"

//----- (080579D2) --------------------------------------------------------
void __usercall sub_80579D2(int a1@<ebp>)
{
  bool v1; // zf
  int v2; // eax
  int _0; // [esp+0h] [ebp+0h]

  *(_DWORD *)(a1 - 32) = *(_DWORD *)(a1 - 40) - *(_DWORD *)(a1 + 8);
  v1 = *(_DWORD *)(a1 - 16) == 0;
  dword_8071254 = (int (*)(void))sub_8057A0F;
  JUMPOUT(v1, &loc_8058DC6);
  v2 = *(&_0 - 4);
  dword_8071254 = (int (*)(void))&loc_8057A12;
  JUMPOUT(&loc_8058DC6);
}
// 8071254: using guessed type int (*dword_8071254)(void);

//----- (08057A0F) --------------------------------------------------------
#error "8057A7C: call analysis failed (funcsize=69)"

//----- (08057B16) --------------------------------------------------------
#error "8057B1A: positive sp value has been found (funcsize=0)"

//----- (08057B1B) --------------------------------------------------------
struct timespec *__cdecl sub_8057B1B(struct timespec *tp)
{
  struct timespec *result; // eax
  struct timeval tv; // [esp+18h] [ebp-10h]

  result = (struct timespec *)clock_gettime(0, tp);
  if ( result )
  {
    gettimeofday(&tv, 0);
    tp->tv_sec = tv.tv_sec;
    result = tp;
    tp->tv_nsec = 1000 * tv.tv_usec;
  }
  return result;
}

//----- (08057B66) --------------------------------------------------------
int __cdecl sub_8057B66(int category)
{
  unsigned __int8 v2; // [esp+1Bh] [ebp-Dh]
  const char *s1; // [esp+1Ch] [ebp-Ch]

  v2 = 1;
  s1 = setlocale(category, 0);
  if ( s1 && (!strcmp(s1, "C") || !strcmp(s1, "POSIX")) )
    v2 = 0;
  return v2;
}

//----- (08057BC4) --------------------------------------------------------
int __cdecl sub_8057BC4(int a1)
{
  return *(_DWORD *)(a1 + 8);
}

//----- (08057BCF) --------------------------------------------------------
int __cdecl sub_8057BCF(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (08057BDA) --------------------------------------------------------
int __cdecl sub_8057BDA(int a1)
{
  return *(_DWORD *)(a1 + 16);
}

//----- (08057BE5) --------------------------------------------------------
unsigned int __cdecl sub_8057BE5(int a1)
{
  _DWORD *i; // [esp+0h] [ebp-10h]
  unsigned int v3; // [esp+4h] [ebp-Ch]
  _DWORD *v4; // [esp+8h] [ebp-8h]
  unsigned int j; // [esp+Ch] [ebp-4h]

  v3 = 0;
  for ( i = *(_DWORD **)a1; *(_DWORD *)(a1 + 4) > (unsigned int)i; i += 2 )
  {
    if ( *i )
    {
      v4 = i;
      for ( j = 1; ; ++j )
      {
        v4 = (_DWORD *)v4[1];
        if ( !v4 )
          break;
      }
      if ( j > v3 )
        v3 = j;
    }
  }
  return v3;
}

//----- (08057DAE) --------------------------------------------------------
int __cdecl sub_8057DAE(_DWORD *a1, int a2)
{
  int (__cdecl *v2)(int, int); // eax
  int v4; // [esp+4h] [ebp-24h]
  unsigned int v5; // [esp+1Ch] [ebp-Ch]

  v2 = (int (__cdecl *)(int, int))a1[6];
  v4 = a1[2];
  v5 = v2(a2, v4);
  if ( a1[2] <= v5 )
    abort();
  return 8 * v5 + *a1;
}

//----- (08057DFE) --------------------------------------------------------
int __cdecl sub_8057DFE(int a1, int a2)
{
  _DWORD *i; // [esp+18h] [ebp-10h]
  _DWORD *v4; // [esp+1Ch] [ebp-Ch]

  v4 = (_DWORD *)sub_8057DAE((_DWORD *)a1, a2);
  if ( !*v4 )
    return 0;
  for ( i = v4; i; i = (_DWORD *)i[1] )
  {
    if ( *i == a2 || (*(unsigned __int8 (__cdecl **)(int, _DWORD))(a1 + 28))(a2, *i) )
      return *i;
  }
  return 0;
}

//----- (080580A5) --------------------------------------------------------
bool __cdecl sub_80580A5(unsigned int a1)
{
  int v1; // ST08_4
  unsigned int v3; // [esp+8h] [ebp-8h]
  unsigned int v4; // [esp+Ch] [ebp-4h]

  v3 = 3;
  v4 = 9;
  while ( v4 < a1 && a1 % v3 )
  {
    v1 = v3 + 1;
    v4 += 4 * v1;
    v3 = v1 + 1;
  }
  return a1 % v3 != 0;
}

//----- (08058118) --------------------------------------------------------
int __cdecl sub_8058118(unsigned int a1)
{
  int i; // [esp+Ch] [ebp+8h]

  if ( a1 <= 9 )
    a1 = 10;
  for ( i = a1 | 1; i != -1 && !sub_80580A5(i); i += 2 )
    ;
  return i;
}

//----- (08058199) --------------------------------------------------------
unsigned int __cdecl sub_8058199(int a1, unsigned int a2)
{
  return sub_80635DC(a1, 3) % a2;
}

//----- (080581DE) --------------------------------------------------------
signed int __cdecl sub_80581DE(int a1)
{
  int v2; // [esp+8h] [ebp-8h]

  v2 = *(_DWORD *)(a1 + 20);
  if ( (_UNKNOWN *)v2 == &unk_80696B8 )
    return 1;
  if ( *(float *)(v2 + 8) > 0.1
    && 1.0 - 0.1 > *(float *)(v2 + 8)
    && *(float *)(v2 + 12) > 0.1 + 1.0
    && *(float *)v2 >= 0.0
    && *(float *)(v2 + 4) > *(float *)v2 + 0.1
    && *(float *)(v2 + 4) <= 1.0
    && *(float *)(v2 + 8) > *(float *)v2 + 0.1 )
  {
    return 1;
  }
  *(_DWORD *)(a1 + 20) = &unk_80696B8;
  return 0;
}

//----- (080582AE) --------------------------------------------------------
unsigned int __cdecl sub_80582AE(unsigned int a1, int a2)
{
  unsigned int result; // eax
  float v3; // [esp+20h] [ebp-4h]
  unsigned int v4; // [esp+2Ch] [ebp+8h]

  if ( *(_BYTE *)(a2 + 16) != 1 )
  {
    v3 = (long double)a1 / *(float *)(a2 + 8);
    if ( v3 >= 4294967300.0 )
      return 0;
    a1 = (signed __int64)v3;
  }
  v4 = sub_8058118(a1);
  if ( v4 <= 0x1FFFFFFF )
    result = v4;
  else
    result = 0;
  return result;
}

//----- (0805835B) --------------------------------------------------------
#error "805837B: call analysis failed (funcsize=76)"

//----- (080585C6) --------------------------------------------------------
#error "805869D: call analysis failed (funcsize=97)"

//----- (080586E0) --------------------------------------------------------
void *__cdecl sub_80586E0(int a1)
{
  int v2; // [esp+1Ch] [ebp-Ch]

  if ( !*(_DWORD *)(a1 + 36) )
    return malloc(8u);
  v2 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(v2 + 4);
  return (void *)v2;
}

//----- (0805872B) --------------------------------------------------------
int __cdecl sub_805872B(int a1, _DWORD *a2)
{
  int result; // eax

  *a2 = 0;
  a2[1] = *(_DWORD *)(a1 + 36);
  result = a1;
  *(_DWORD *)(a1 + 36) = a2;
  return result;
}

//----- (0805875E) --------------------------------------------------------
int __cdecl sub_805875E(int a1, int a2, int **a3, char a4)
{
  int result; // eax
  int v5; // edx
  int v6; // ecx
  int *v7; // ST34_4
  int v8; // edx
  void *v9; // eax
  int *v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+28h] [ebp-10h]

  v10 = (int *)sub_8057DAE((_DWORD *)a1, a2);
  *a3 = v10;
  if ( !*v10 )
    return 0;
  if ( *v10 == a2 || (*(unsigned __int8 (__cdecl **)(int, int))(a1 + 28))(a2, *v10) )
  {
    v11 = *v10;
    if ( a4 )
    {
      if ( v10[1] )
      {
        v7 = (int *)v10[1];
        v8 = v7[1];
        *v10 = *v7;
        v10[1] = v8;
        sub_805872B(a1, v7);
      }
      else
      {
        *v10 = 0;
      }
    }
    result = v11;
  }
  else
  {
    v9 = &loc_8058911;
    if ( v10[1] )
      v9 = &loc_8058854;
    dword_8071210 = (int)v9;
    sub_8064CF3(v6, v5);
    result = 0;
  }
  return result;
}
// 8064CF3: using guessed type int __fastcall sub_8064CF3(_DWORD, _DWORD);
// 8071210: using guessed type int dword_8071210;

//----- (08058918) --------------------------------------------------------
int __cdecl sub_8058918(int a1, int *a2, char a3)
{
  char v4; // [esp+Ch] [ebp-2Ch]
  int v5; // [esp+18h] [ebp-20h]

  v4 = a3;
  v5 = *a2;
  dword_8071254 = (int (*)(void))&loc_8058B9B;
  return ((int (*)(void))loc_8058B9B)();
}
// 8071254: invalid function type has been ignored
// 8071254: using guessed type int (*dword_8071254)(void);

//----- (08058DD0) --------------------------------------------------------
#error "8058DF0: call analysis failed (funcsize=14)"

//----- (08058DFA) --------------------------------------------------------
#error "80590AF: positive sp value has been found (funcsize=119)"

//----- (080590B0) --------------------------------------------------------
void __cdecl __noreturn sub_80590B0(int a1, int a2)
{
  sub_8058DD0(a1, a2);
}
// 8058DD0: using guessed type void __cdecl __noreturn sub_8058DD0(_DWORD, _DWORD);

//----- (08059129) --------------------------------------------------------
int __cdecl sub_8059129(int a1, int a2)
{
  int v2; // eax
  bool v3; // zf
  int (__cdecl *v4)(int); // eax
  int v6; // [esp-4h] [ebp-4Ch]
  int v7; // [esp+0h] [ebp-48h]
  int v8; // [esp+4h] [ebp-44h]
  int v9; // [esp+8h] [ebp-40h]
  int v10; // [esp+Ch] [ebp-3Ch]
  int v11; // [esp+10h] [ebp-38h]
  int v12; // [esp+14h] [ebp-34h]
  int v13; // [esp+18h] [ebp-30h]
  int v14; // [esp+30h] [ebp-18h]

  v2 = sub_805875E(a1, a2, (int **)&v7 - 8, 1);
  v14 = v2;
  v3 = v2 == 0;
  v6 = v2;
  v4 = (int (__cdecl *)(int))&loc_8059182;
  if ( !v3 )
    v4 = sub_805918C;
  dword_80711FC = (int)v4;
  sub_8064D6B(v7, v8, v9, v10, v11, v12, v13);
  return 0;
}
// 805918C: using guessed type int __cdecl sub_805918C(int);
// 8064D6B: using guessed type int __stdcall sub_8064D6B(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80711FC: using guessed type int dword_80711FC;

//----- (0805918C) --------------------------------------------------------
#error "8059209: call analysis failed (funcsize=140)"

//----- (0805939B) --------------------------------------------------------
int __cdecl sub_805939B(int a1, unsigned int a2)
{
  int v3; // eax

  v3 = sub_8063836(*(_BYTE **)a1, a2);
  return sub_80647BA(__PAIR__(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 4) ^ (unsigned int)v3), a2);
}

//----- (08059541) --------------------------------------------------------
int __cdecl sub_8059541(int a1, int a2)
{
  int v2; // ebx

  v2 = *(_DWORD *)(a1 + 8);
  return *(_QWORD *)(a1 + 4) == *(_QWORD *)(a2 + 4)
      && __PAIR__(*(_DWORD *)(a1 + 12), *(_DWORD *)(a2 + 16)) == __PAIR__(*(_DWORD *)(a2 + 12), *(_DWORD *)(a1 + 16))
      && !strcmp(*(const char **)a1, *(const char **)a2);
}

//----- (080595E1) --------------------------------------------------------
void __cdecl sub_80595E1(void **a1)
{
  free(*a1);
  free(a1);
}

//----- (08059607) --------------------------------------------------------
long double __cdecl sub_8059607(int a1, long double a2)
{
  int v2; // ecx
  signed int v3; // eax
  unsigned __int64 v5; // [esp+28h] [ebp-10h]

  if ( a1 != 1 && a2 < 1.8446744073709551615e19 )
  {
    if ( a2 >= 9.223372036854775808e18 )
    {
      v2 = ((unsigned __int64)(signed __int64)(a2 - 9.223372036854775808e18) >> 32) ^ 0x80000000;
      v5 = (signed __int64)(a2 - 9.223372036854775808e18) ^ 0x8000000000000000LL;
    }
    else
    {
      v5 = (signed __int64)a2;
    }
    if ( a1 || a2 == (long double)v5 )
    {
      v3 = 0;
    }
    else
    {
      dword_80711DC = (int)&loc_80596EF;
      sub_8064E3D(v2, HIDWORD(v5));
      v3 = 1;
    }
    a2 = (long double)(v3 + v5);
  }
  return a2;
}
// 8064E3D: using guessed type double __fastcall sub_8064E3D(_DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;

//----- (0805975F) --------------------------------------------------------
#error "8059805: call analysis failed (funcsize=96)"

//----- (080598C8) --------------------------------------------------------
#error "80598F9: call analysis failed (funcsize=18)"

//----- (080598FE) --------------------------------------------------------
#error "805A4D3: positive sp value has been found (funcsize=709)"

//----- (0805A6DC) --------------------------------------------------------
signed __int64 sub_805A6DC()
{
  signed __int64 result; // rax

  if ( getenv("POSIXLY_CORRECT") )
    result = 512LL;
  else
    result = 1024LL;
  return result;
}

//----- (0805A71A) --------------------------------------------------------
int __cdecl sub_805A71A(char *s, int a2, int a3)
{
  int v4; // [esp+20h] [ebp-18h]
  int v5; // [esp+24h] [ebp-14h]
  int v6; // [esp+28h] [ebp-10h]
  int v7; // [esp+2Ch] [ebp-Ch]

  v5 = 0;
  if ( s || (s = getenv("BLOCK_SIZE")) != 0 || (s = getenv("BLOCKSIZE")) != 0 )
  {
    if ( *s == 39 )
    {
      v5 |= 4u;
      ++s;
    }
    v6 = sub_8055991(s, (int)off_806978C, (int)dword_8069798, 4u);
    if ( v6 < 0 )
    {
      v7 = sub_80621FE(s, (int)&v4, 0, a2, "eEgGkKmMpPtTyYzZ0");
      if ( v7 )
      {
        *(_DWORD *)a3 = 0;
        return v7;
      }
      while ( *s <= 47 || *s > 57 )
      {
        if ( s == (char *)v4 )
        {
          v5 |= 0x80u;
          if ( *(_BYTE *)(v4 - 1) == 66 )
            v5 |= 0x100u;
          if ( *(_BYTE *)(v4 - 1) != 66 || *(_BYTE *)(v4 - 2) == 105 )
            v5 |= 0x20u;
          break;
        }
        ++s;
      }
    }
    else
    {
      v5 |= dword_8069798[v6];
      *(_DWORD *)a2 = 1;
      *(_DWORD *)(a2 + 4) = 0;
    }
  }
  else
  {
    *(_QWORD *)a2 = sub_805A6DC();
  }
  *(_DWORD *)a3 = v5;
  return 0;
}
// 806978C: using guessed type char *off_806978C[2];

//----- (0805A879) --------------------------------------------------------
int __cdecl sub_805A879(char *s, int a2, int a3)
{
  int v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_805A71A(s, a3, a2);
  if ( !*(_QWORD *)a3 )
  {
    *(_QWORD *)a3 = sub_805A6DC();
    v4 = 4;
  }
  return v4;
}

//----- (0805A8C2) --------------------------------------------------------
char *__cdecl sub_805A8C2(__uid_t uid)
{
  const char *v1; // eax
  char *s; // ST24_4
  size_t v3; // eax
  char *result; // eax
  char *i; // [esp+10h] [ebp-18h]
  char *v6; // [esp+14h] [ebp-14h]
  struct passwd *v7; // [esp+18h] [ebp-10h]

  v6 = 0;
  for ( i = (char *)dword_8072739; i; i = (char *)*((_DWORD *)i + 1) )
  {
    if ( *(_DWORD *)i == uid )
    {
      v6 = i;
      break;
    }
  }
  if ( !v6 )
  {
    v7 = getpwuid(uid);
    if ( v7 )
      v1 = v7->pw_name;
    else
      v1 = (const char *)&unk_806981C;
    s = (char *)v1;
    v3 = strlen(v1);
    v6 = (char *)sub_80615D3((v3 + 16) & 0xFFFFFFF8);
    *(_DWORD *)v6 = uid;
    strcpy(v6 + 8, s);
    *((_DWORD *)v6 + 1) = dword_8072739;
    dword_8072739 = (int)v6;
  }
  if ( v6[8] )
    result = v6 + 8;
  else
    result = 0;
  return result;
}
// 8072739: using guessed type int dword_8072739;

//----- (0805AB03) --------------------------------------------------------
char *__cdecl sub_805AB03(__gid_t gid)
{
  const char *v1; // eax
  char *s; // ST1C_4
  size_t v3; // eax
  char *result; // eax
  char *i; // [esp+10h] [ebp-18h]
  char *v6; // [esp+14h] [ebp-14h]
  struct group *v7; // [esp+18h] [ebp-10h]

  v6 = 0;
  for ( i = (char *)dword_8072741; i; i = (char *)*((_DWORD *)i + 1) )
  {
    if ( *(_DWORD *)i == gid )
    {
      v6 = i;
      break;
    }
  }
  if ( !v6 )
  {
    v7 = getgrgid(gid);
    if ( v7 )
      v1 = v7->gr_name;
    else
      v1 = (const char *)&unk_806981C;
    s = (char *)v1;
    v3 = strlen(v1);
    v6 = (char *)sub_80615D3((v3 + 16) & 0xFFFFFFF8);
    *(_DWORD *)v6 = gid;
    strcpy(v6 + 8, s);
    *((_DWORD *)v6 + 1) = dword_8072741;
    dword_8072741 = (int)v6;
  }
  if ( v6[8] )
    result = v6 + 8;
  else
    result = 0;
  return result;
}
// 8072741: using guessed type int dword_8072741;

//----- (0805AD11) --------------------------------------------------------
int __cdecl sub_805AD11(__int64 a1, int a2)
{
  __int64 v3; // [esp+18h] [ebp-20h]
  int v4; // [esp+2Ch] [ebp-Ch]

  v3 = a1;
  v4 = a2 + 20;
  *(_BYTE *)(a2 + 20) = 0;
  if ( a1 >= 0 )
  {
    do
    {
      *(_BYTE *)--v4 = sub_80642B8(v3, HIDWORD(v3), 10, 0) + 48;
      v3 = sub_8064121(v3, 0xAu, 0);
    }
    while ( v3 );
  }
  else
  {
    do
    {
      *(_BYTE *)--v4 = 48 - sub_80642B8(v3, HIDWORD(v3), 10, 0);
      v3 = sub_8064121(v3, 0xAu, 0);
    }
    while ( v3 );
    *(_BYTE *)--v4 = 45;
  }
  return v4;
}
// 80642B8: using guessed type _DWORD __cdecl sub_80642B8(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0805AE4B) --------------------------------------------------------
int __cdecl sub_805AE4B(unsigned __int64 a1, int a2)
{
  unsigned __int64 v2; // rax
  unsigned __int64 v4; // [esp+18h] [ebp-20h]
  int v5; // [esp+2Ch] [ebp-Ch]

  v4 = a1;
  v5 = a2 + 20;
  *(_BYTE *)(a2 + 20) = 0;
  do
  {
    *(_BYTE *)--v5 = sub_80647BA(v4, 10LL) + 48;
    LODWORD(v2) = sub_806456E(v4, HIDWORD(v4), 10, 0);
    v4 = v2;
  }
  while ( v2 );
  return v5;
}
// 806456E: using guessed type _DWORD __cdecl sub_806456E(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0805AF01) --------------------------------------------------------
int __cdecl sub_805AF01(wint_t *a1)
{
  unsigned __int8 v2; // [esp+1Bh] [ebp-Dh]
  wint_t *i; // [esp+1Ch] [ebp-Ch]

  v2 = 0;
  for ( i = a1; *i; ++i )
  {
    if ( !iswprint(*i) )
    {
      *i = 65533;
      v2 = 1;
    }
  }
  return v2;
}

//----- (0805AF54) --------------------------------------------------------
void sub_805AF54()
{
  dword_8071254 = (int (*)(void))&loc_805AFEF;
  JUMPOUT(&loc_8058DC6);
}
// 8071254: using guessed type int (*dword_8071254)(void);

//----- (0805AF7B) --------------------------------------------------------
void __usercall sub_805AF7B(int a1@<ebp>, int a2, _DWORD *a3, unsigned int a4)
{
  bool v4; // zf
  unsigned int v5; // eax
  int retaddr; // [esp+0h] [ebp+0h]

  retaddr = **(_DWORD **)(a1 + 8);
  *(_DWORD *)(a1 - 12) = wcwidth();
  v4 = *(_DWORD *)(a1 - 12) == -1;
  dword_8071254 = (int (*)(void))&loc_805AFB3;
  JUMPOUT(!v4, &loc_8058DC6);
  *a3 = 65533;
  *(&retaddr - 3) = 1;
  v5 = *(&retaddr - 3) + *(&retaddr - 4);
  dword_8071254 = (int (*)(void))sub_805AFE5;
  JUMPOUT(v5 <= a4, &loc_8058DC6);
  dword_8071254 = (int (*)(void))&loc_805B00A;
  JUMPOUT(&loc_8058DC6);
}
// 8049560: using guessed type int wcwidth(void);
// 805AFE5: using guessed type int sub_805AFE5();
// 8071254: using guessed type int (*dword_8071254)(void);

//----- (0805AFE5) --------------------------------------------------------
#error "805B017: positive sp value has been found (funcsize=0)"

//----- (0805B018) --------------------------------------------------------
void sub_805B018()
{
  dword_8071254 = (int (*)(void))&loc_805B03A;
  JUMPOUT(&loc_8058DC6);
}
// 8071254: using guessed type int (*dword_8071254)(void);

//----- (0805B02E) --------------------------------------------------------
#error "805B065: positive sp value has been found (funcsize=17)"

//----- (0805B08E) --------------------------------------------------------
int __cdecl sub_805B08E(char *s, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // ecx
  unsigned int v7; // ST0C_4
  unsigned int v8; // eax
  void *v9; // eax
  int v10; // ST50_4
  int v11; // eax
  size_t v12; // eax
  char v14; // [esp+1Ah] [ebp-3Eh]
  char v15; // [esp+1Bh] [ebp-3Dh]
  int v16; // [esp+1Ch] [ebp-3Ch]
  size_t size; // [esp+20h] [ebp-38h]
  char *v18; // [esp+24h] [ebp-34h]
  wchar_t *pwcs; // [esp+28h] [ebp-30h]
  char *v20; // [esp+2Ch] [ebp-2Ch]
  unsigned int v21; // [esp+30h] [ebp-28h]
  size_t v22; // [esp+34h] [ebp-24h]
  unsigned int v23; // [esp+38h] [ebp-20h]
  size_t v24; // [esp+3Ch] [ebp-1Ch]
  unsigned int v25; // [esp+40h] [ebp-18h]
  size_t n; // [esp+44h] [ebp-14h]
  int na; // [esp+44h] [ebp-14h]
  unsigned int v28; // [esp+4Ch] [ebp-Ch]
  int v29; // [esp+64h] [ebp+Ch]

  v16 = -1;
  size = strlen(s) + 1;
  v18 = 0;
  pwcs = 0;
  v20 = s;
  v21 = size - 1;
  v22 = size - 1;
  v23 = 0;
  v14 = 0;
  v15 = 0;
  if ( !(a6 & 2) && __ctype_get_mb_cur_max() > 1 )
  {
    n = mbstowcs(0, s, 0);
    if ( n == -1 )
    {
      if ( !(a6 & 1) )
        goto LABEL_38;
      goto LABEL_20;
    }
    na = n + 1;
    pwcs = (wchar_t *)malloc(4 * na);
    if ( !pwcs )
    {
      if ( !(a6 & 1) )
        goto LABEL_38;
      goto LABEL_20;
    }
    if ( mbstowcs(pwcs, s, na) )
    {
      pwcs[na + 0x3FFFFFFF] = 0;
      v15 = 1;
      v14 = sub_805AF01((wint_t *)pwcs);
      v21 = wcswidth(pwcs, na);
    }
  }
  if ( v15 && (v14 || *(_DWORD *)a4 < v21) )
  {
    if ( v14 )
      size = wcstombs(0, pwcs, 0) + 1;
    v18 = (char *)malloc(size);
    if ( v18 )
    {
      v20 = v18;
      v7 = *(_DWORD *)a4;
      sub_805AF54();
      v21 = v8;
      v22 = wcstombs(v18, pwcs, size);
    }
    else if ( !(a6 & 1) )
    {
      goto LABEL_38;
    }
  }
LABEL_20:
  if ( *(_DWORD *)a4 < v21 )
  {
    v21 = *(_DWORD *)a4;
    v22 = *(_DWORD *)a4;
  }
  if ( *(_DWORD *)a4 > v21 )
    v23 = *(_DWORD *)a4 - v21;
  *(_DWORD *)a4 = v21;
  if ( a5 )
  {
    v9 = &loc_805B2CC;
    if ( a5 == 1 )
      v9 = &loc_805B2DD;
    dword_8071210 = (int)v9;
    sub_8064CF3(v6, v21);
    v24 = (v23 >> 1) + (v23 & 1);
    v25 = v23 >> 1;
  }
  else
  {
    v24 = 0;
    v25 = v23;
  }
  if ( a6 & 4 )
    v24 = 0;
  if ( a6 & 8 )
    v25 = 0;
  if ( a3 )
  {
    v10 = a3 - 1 + a2;
    sub_805B018();
    v29 = v11;
    v28 = v10 - v11;
    v12 = v22;
    if ( v28 <= v22 )
      v12 = v28;
    mempcpy(v29, v20, v12);
    sub_805B018();
  }
  v16 = v25 + v24 + v22;
LABEL_38:
  free(pwcs);
  free(v18);
  return v16;
}
// 80499B0: using guessed type int __cdecl mempcpy(_DWORD, _DWORD, _DWORD);
// 80499C0: using guessed type int __cdecl wcswidth(_DWORD, _DWORD);
// 8064CF3: using guessed type int __fastcall sub_8064CF3(_DWORD, _DWORD);
// 8071210: using guessed type int dword_8071210;

//----- (0805B512) --------------------------------------------------------
int __cdecl sub_805B512(char *s)
{
  strlen(s);
  return sub_805B53B(s);
}
// 805B53B: using guessed type _DWORD __cdecl sub_805B53B(_DWORD);

//----- (0805B53B) --------------------------------------------------------
#error "805B563: call analysis failed (funcsize=15)"

//----- (0805B568) --------------------------------------------------------
#error "805B824: positive sp value has been found (funcsize=116)"

//----- (0805B825) --------------------------------------------------------
void *__cdecl sub_805B825(int a1, int a2, void *dest, int a4)
{
  _DWORD *v4; // eax
  _DWORD *v5; // eax
  unsigned int v7; // [esp+10h] [ebp-28h]
  unsigned int v8; // [esp+14h] [ebp-24h]
  unsigned int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]

  v12 = (unsigned int)a2 >> 1;
  v13 = a2 - ((unsigned int)a2 >> 1);
  v7 = 0;
  v8 = (unsigned int)a2 >> 1;
  v9 = (unsigned int)a2 >> 1;
  v14 = a2;
  sub_805B9BB(a1 + 4 * ((unsigned int)a2 >> 1), a2 - ((unsigned int)a2 >> 1), dest, a4);
  sub_805B9BB(a1, (unsigned int)a2 >> 1, dest, a4);
  v10 = *(_DWORD *)a1;
  v11 = *(_DWORD *)(4 * ((unsigned int)a2 >> 1) + a1);
  while ( 1 )
  {
    while ( ((int (__cdecl *)(int, int))a4)(v10, v11) > 0 )
    {
      v5 = dest;
      dest = (char *)dest + 4;
      *v5 = v11;
      if ( ++v9 == v14 )
        return memcpy(dest, (const void *)(4 * v7 + a1), 4 * (v8 - v7));
      v11 = *(_DWORD *)(4 * v9 + a1);
    }
    v4 = dest;
    dest = (char *)dest + 4;
    *v4 = v10;
    if ( ++v7 == v8 )
      break;
    v10 = *(_DWORD *)(4 * v7 + a1);
  }
  v7 = v9;
  v8 = v14;
  return memcpy(dest, (const void *)(4 * v7 + a1), 4 * (v8 - v7));
}

//----- (0805B9BB) --------------------------------------------------------
void __cdecl sub_805B9BB(int a1, int a2, void *dest, int a4)
{
  int v4; // ecx
  int v5; // eax
  _DWORD *v6; // edx
  void *v7; // eax
  int v8; // eax
  int v9; // [esp+14h] [ebp-34h]
  int v10; // [esp+18h] [ebp-30h]
  unsigned int v11; // [esp+1Ch] [ebp-2Ch]
  int v12; // [esp+20h] [ebp-28h]
  int v13; // [esp+24h] [ebp-24h]
  int v14; // [esp+28h] [ebp-20h]
  int v15; // [esp+2Ch] [ebp-1Ch]
  int v16; // [esp+30h] [ebp-18h]
  int v17; // [esp+34h] [ebp-14h]
  unsigned int v18; // [esp+38h] [ebp-10h]
  int v19; // [esp+3Ch] [ebp-Ch]

  if ( (unsigned int)a2 > 2 )
  {
    v16 = (unsigned int)a2 >> 1;
    v17 = a2 - ((unsigned int)a2 >> 1);
    v10 = 0;
    v18 = (unsigned int)a2 >> 1;
    v11 = (unsigned int)a2 >> 1;
    v19 = a2;
    sub_805B9BB(a1 + 4 * ((unsigned int)a2 >> 1), v17, dest, a4);
    if ( (unsigned int)a2 >> 1 > 1 )
      sub_805B825(a1, v16, dest, a4);
    else
      *(_DWORD *)dest = *(_DWORD *)a1;
    v13 = *((_DWORD *)dest + v10);
    v12 = *(_DWORD *)(4 * v11 + a1);
    v9 = 0;
    while ( ((int (__cdecl *)(int, int))a4)(v13, v12) > 0 )
    {
      v8 = v9++;
      *(_DWORD *)(a1 + 4 * v8) = v12;
      if ( ++v11 == v19 )
      {
        memcpy((void *)(4 * v9 + a1), (char *)dest + 4 * v10, 4 * (v18 - v10));
        return;
      }
      v12 = *(_DWORD *)(4 * v11 + a1);
    }
    v5 = v9++;
    v6 = (_DWORD *)(a1 + 4 * v5);
    *v6 = v13;
    ++v10;
    v7 = &loc_805BB62;
    if ( v10 != v18 )
      v7 = &loc_805BB67;
    dword_8071210 = (int)v7;
    sub_8064CF3(v4, v6);
  }
  else if ( a2 == 2 )
  {
    v14 = *(_DWORD *)a1;
    v15 = *(_DWORD *)(a1 + 4);
    if ( ((int (__cdecl *)(int, int))a4)(v14, v15) > 0 )
    {
      *(_DWORD *)a1 = v15;
      *(_DWORD *)(a1 + 4) = v14;
    }
  }
}
// 8064CF3: using guessed type int __fastcall sub_8064CF3(_DWORD, _DWORD);
// 8071210: using guessed type int dword_8071210;

//----- (0805BC23) --------------------------------------------------------
void __cdecl sub_805BC23(int a1, int a2, int a3)
{
  sub_805B9BB(a1, a2, (void *)(a1 + 4 * a2), a3);
}

//----- (0805BC67) --------------------------------------------------------
void sub_805BC67()
{
  dword_8071254 = (int (*)(void))&loc_805BCA2;
  JUMPOUT(&loc_8058DC6);
}
// 8071254: using guessed type int (*dword_8071254)(void);

//----- (0805BC81) --------------------------------------------------------
#error "805BCE7: positive sp value has been found (funcsize=0)"

//----- (0805BCEA) --------------------------------------------------------
int __cdecl sub_805BCEA(int a1, int a2, int a3)
{
  int v3; // eax

  while ( 1 )
  {
    v3 = a3--;
    if ( !v3 )
      break;
    *(_BYTE *)(a1 + a3) = toupper(*(unsigned __int8 *)(a2 + a3));
  }
  return a1;
}

//----- (0805BD2A) --------------------------------------------------------
int __cdecl sub_805BD2A(int a1, int a2)
{
  return a1 - (a1 - a2 + 382) % 7 + 3;
}

//----- (0805BD87) --------------------------------------------------------
int __cdecl sub_805BD87(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // [esp+0h] [ebp-38h]
  char v8; // [esp+2Fh] [ebp-9h]

  v8 = 0;
  return sub_805BE20(a1, a2, a3, a4, 0, (char *)&v7 - 9, a5, a6);
}
// 805BE20: using guessed type _DWORD __cdecl sub_805BE20(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0805BE20) --------------------------------------------------------
#error "805C16F: call analysis failed (funcsize=1908)"

//----- (0805E985) --------------------------------------------------------
#error "805E98B: positive sp value has been found (funcsize=0)"

//----- (0805E990) --------------------------------------------------------
#error "805EA5A: call analysis failed (funcsize=66)"

//----- (0805EA82) --------------------------------------------------------
void *__cdecl sub_805EA82(void *src)
{
  int *v1; // eax
  void *v3; // ST1C_4
  int v4; // [esp+18h] [ebp-10h]

  v4 = *__errno_location();
  if ( src )
    v1 = (int *)src;
  else
    v1 = &dword_8072755;
  v3 = sub_806171A(v1, 0x30u);
  *__errno_location() = v4;
  return v3;
}
// 8072755: using guessed type int dword_8072755;

//----- (0805EAD4) --------------------------------------------------------
int __cdecl sub_805EAD4(int *a1)
{
  int *v1; // eax

  if ( a1 )
    v1 = a1;
  else
    v1 = &dword_8072755;
  return *v1;
}
// 8072755: using guessed type int dword_8072755;

//----- (0805EAF7) --------------------------------------------------------
int *__cdecl sub_805EAF7(int *a1, int a2)
{
  int *result; // eax

  if ( a1 )
    result = a1;
  else
    result = &dword_8072755;
  *result = a2;
  return result;
}
// 8072755: using guessed type int dword_8072755;

//----- (0805EB11) --------------------------------------------------------
int __cdecl sub_805EB11(int *a1, unsigned __int8 a2, char a3)
{
  int *v3; // eax
  int *v4; // ST08_4
  unsigned int v5; // edx

  if ( a1 )
    v3 = a1;
  else
    v3 = &dword_8072755;
  v4 = &v3[(a2 >> 5) + 2];
  v5 = *v4;
  *v4 ^= (((unsigned int)*v4 >> (a2 & 0x1F)) & 1 ^ a3 & 1) << (a2 & 0x1F);
  return (v5 >> (a2 & 0x1F)) & 1;
}
// 8072755: using guessed type int dword_8072755;

//----- (0805EBDF) --------------------------------------------------------
#error "805EBFF: call analysis failed (funcsize=30)"

//----- (0805EC59) --------------------------------------------------------
_DWORD *__userpurge sub_805EC59@<eax>(_DWORD *a1, int a2)
{
  int v3; // [esp+0h] [ebp-38h]
  int v4; // [esp+4h] [ebp-34h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]

  memset(&v3, 0, 0x30u);
  if ( a2 == 10 )
    abort();
  *a1 = a2;
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = v6;
  a1[4] = v7;
  a1[5] = v8;
  a1[6] = v9;
  a1[7] = v10;
  a1[8] = v11;
  a1[9] = v12;
  a1[10] = v13;
  a1[11] = v14;
  return a1;
}

//----- (0805ED23) --------------------------------------------------------
char *__cdecl sub_805ED23(char *msgid, int a2)
{
  char *result; // eax
  int v3; // [esp+0h] [ebp-28h]
  int v4; // [esp+4h] [ebp-24h]
  int v5; // [esp+8h] [ebp-20h]
  int v6; // [esp+Ch] [ebp-1Ch]
  int v7; // [esp+10h] [ebp-18h]
  int v8; // [esp+14h] [ebp-14h]
  char *v9; // [esp+18h] [ebp-10h]
  unsigned __int8 *v10; // [esp+1Ch] [ebp-Ch]

  v9 = gettext(msgid);
  if ( v9 != msgid )
    return v9;
  v10 = (unsigned __int8 *)sub_8063DC6();
  if ( sub_8063707(v10, "UTF-8") )
  {
    if ( sub_8063707(v10, "GB18030") )
    {
      if ( a2 == 9 )
      {
        dword_80711FC = (int)&locret_805EDAA;
        sub_8064D6B(v3, v4, v5, v6, v7, v8, v9);
      }
      result = "'";
    }
    else if ( *msgid == 96 )
    {
      result = (char *)&unk_8069B6E;
    }
    else
    {
      result = (char *)&unk_8069B72;
    }
  }
  else if ( *msgid == 96 )
  {
    result = (char *)&unk_8069B5E;
  }
  else
  {
    result = (char *)&unk_8069B62;
  }
  return result;
}
// 8064D6B: using guessed type int __stdcall sub_8064D6B(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80711FC: using guessed type int dword_80711FC;

//----- (0805EDDF) --------------------------------------------------------
#error "805EE6A: call analysis failed (funcsize=40)"

//----- (0805EE6F) --------------------------------------------------------
#error "805FB84: positive sp value has been found (funcsize=983)"

//----- (0805FB88) --------------------------------------------------------
int __cdecl sub_805FB88(int a1, int a2, int a3, int a4, int *a5)
{
  int *v5; // eax
  int *v6; // ST34_4
  int v7; // ST38_4
  int v8; // ST3C_4

  if ( a5 )
    v5 = a5;
  else
    v5 = &dword_8072755;
  v6 = v5;
  v7 = *__errno_location();
  v8 = sub_805EDDF(a1, a2, a3, a4, *v6, v6[1], v6 + 2, v6[10], v6[11]);
  *__errno_location() = v7;
  return v8;
}
// 805EDDF: using guessed type _DWORD __cdecl sub_805EDDF(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8072755: using guessed type int dword_8072755;

//----- (0805FC73) --------------------------------------------------------
void *__cdecl sub_805FC73(int a1, int a2, _DWORD *a3, int *a4)
{
  int *v4; // eax
  int *v5; // ST3C_4
  int v6; // ST40_4
  int v7; // ST44_4
  int size; // [esp+48h] [ebp-10h]
  void *ptr; // [esp+4Ch] [ebp-Ch]

  if ( a4 )
    v4 = a4;
  else
    v4 = &dword_8072755;
  v5 = v4;
  v6 = *__errno_location();
  v7 = v5[1] | (a3 == 0);
  size = sub_805EDDF(0, 0, a1, a2, *v5, v7, v5 + 2, v5[10], v5[11]) + 1;
  ptr = sub_80615C0(size);
  sub_805EDDF(ptr, size, a1, a2, *v5, v7, v5 + 2, v5[10], v5[11]);
  *__errno_location() = v6;
  if ( a3 )
    *a3 = size - 1;
  return ptr;
}
// 805EDDF: using guessed type _DWORD __cdecl sub_805EDDF(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8072755: using guessed type int dword_8072755;

//----- (0805FE5E) --------------------------------------------------------
void __cdecl sub_805FE5E(int a1)
{
  int v1; // ST40_4

  v1 = *__errno_location();
  dword_8071254 = (int (*)(void))sub_805FE94;
  JUMPOUT(a1 >= 0, &loc_8058DC6);
  abort();
}
// 8071254: using guessed type int (*dword_8071254)(void);

//----- (0805FE94) --------------------------------------------------------
void __usercall sub_805FE94(int a1@<ebp>, int a2, int a3)
{
  bool v3; // zf
  bool v4; // sf
  unsigned __int8 v5; // of
  int _0; // [esp+0h] [ebp+0h]

  v5 = __OFSUB__(dword_80713C8, *(_DWORD *)(a1 + 8));
  v3 = dword_80713C8 == *(_DWORD *)(a1 + 8);
  v4 = dword_80713C8 - *(_DWORD *)(a1 + 8) < 0;
  dword_8071254 = (int (*)(void))&loc_805FFBE;
  JUMPOUT(!((unsigned __int8)(v4 ^ v5) | v3), &loc_8058DC6);
  *((_BYTE *)&_0 - 33) = *(&_0 - 8) == (_DWORD)&dword_80713CC;
  dword_8071254 = (int (*)(void))sub_805FEDE;
  JUMPOUT(a3, 268435454, &loc_8058DC6);
  sub_8061768();
}
// 8071254: using guessed type int (*dword_8071254)(void);
// 80713C8: using guessed type int dword_80713C8;
// 80713CC: using guessed type int dword_80713CC;

//----- (0805FEDE) --------------------------------------------------------
void __usercall sub_805FEDE(int a1@<ebp>)
{
  int v1; // edx
  bool v2; // zf

  v1 = 8 * (*(_DWORD *)(a1 + 8) + 1);
  v2 = *(_BYTE *)(a1 - 33) == 0;
  dword_8071254 = (int (*)(void))&sub_805FF1B;
  JUMPOUT(v2, &loc_8058DC6);
  dword_8071254 = (int (*)(void))&loc_805FF1E;
  JUMPOUT(&loc_8058DC6);
}
// 8071254: using guessed type int (*dword_8071254)(void);

//----- (0805FF1B) --------------------------------------------------------
#error "8060163: positive sp value has been found (funcsize=151)"

//----- (08060166) --------------------------------------------------------
void __cdecl sub_8060166(int a1)
{
  sub_805FE5E(a1);
}

//----- (08060190) --------------------------------------------------------
#error "80601BD: call analysis failed (funcsize=15)"

//----- (080601C2) --------------------------------------------------------
#error "8060220: positive sp value has been found (funcsize=10)"

//----- (08060223) --------------------------------------------------------
void __cdecl sub_8060223(int a1, int a2)
{
  char v2; // [esp+10h] [ebp-38h]

  sub_805EC59(&v2, a2);
  sub_805FE5E(a1);
}

//----- (08060261) --------------------------------------------------------
void __cdecl sub_8060261(int a1, int a2)
{
  char v2; // [esp+10h] [ebp-38h]

  sub_805EC59(&v2, a2);
  sub_805FE5E(a1);
}

//----- (0806029E) --------------------------------------------------------
void __cdecl sub_806029E(int a1)
{
  sub_8060223(0, a1);
}

//----- (08060311) --------------------------------------------------------
void __cdecl sub_8060311(int a1, int a2, unsigned __int8 a3)
{
  int v3; // [esp+0h] [ebp-58h]
  int v4; // [esp+4h] [ebp-54h]
  int v5; // [esp+8h] [ebp-50h]
  int *v6; // [esp+Ch] [ebp-4Ch]
  unsigned __int8 v7; // [esp+1Ch] [ebp-3Ch]
  int v8; // [esp+20h] [ebp-38h]
  int v9; // [esp+24h] [ebp-34h]
  int v10; // [esp+28h] [ebp-30h]
  int v11; // [esp+2Ch] [ebp-2Ch]
  int v12; // [esp+30h] [ebp-28h]
  int v13; // [esp+34h] [ebp-24h]
  int v14; // [esp+38h] [ebp-20h]
  int v15; // [esp+3Ch] [ebp-1Ch]
  int v16; // [esp+40h] [ebp-18h]
  int v17; // [esp+44h] [ebp-14h]
  int v18; // [esp+48h] [ebp-10h]
  int v19; // [esp+4Ch] [ebp-Ch]

  v7 = a3;
  v8 = dword_8072755;
  v9 = dword_8072759;
  v10 = dword_807275D;
  v11 = dword_8072761;
  v12 = dword_8072765;
  v13 = dword_8072769;
  v14 = dword_807276D;
  v15 = dword_8072771;
  v16 = dword_8072775;
  v17 = dword_8072779;
  v18 = dword_807277D;
  v19 = dword_8072781;
  sub_805EB11(&v3 - 14, a3, 1);
  v6 = &v8;
  v5 = a2;
  v4 = a1;
  sub_805FE5E(0);
}
// 8072755: using guessed type int dword_8072755;
// 8072759: using guessed type int dword_8072759;
// 807275D: using guessed type int dword_807275D;
// 8072761: using guessed type int dword_8072761;
// 8072765: using guessed type int dword_8072765;
// 8072769: using guessed type int dword_8072769;
// 807276D: using guessed type int dword_807276D;
// 8072771: using guessed type int dword_8072771;
// 8072775: using guessed type int dword_8072775;
// 8072779: using guessed type int dword_8072779;
// 807277D: using guessed type int dword_807277D;
// 8072781: using guessed type int dword_8072781;

//----- (080603CB) --------------------------------------------------------
#error "80603FB: call analysis failed (funcsize=17)"

//----- (08060400) --------------------------------------------------------
#error "8060418: positive sp value has been found (funcsize=0)"

//----- (08060419) --------------------------------------------------------
int __cdecl sub_8060419(int a1)
{
  return sub_80603CB(a1, 58);
}
// 80603CB: using guessed type _DWORD __cdecl sub_80603CB(_DWORD, _DWORD);

//----- (0806047E) --------------------------------------------------------
void __cdecl sub_806047E(int a1, int a2, int a3)
{
  int v3; // [esp+0h] [ebp-78h]
  int v4; // [esp+4h] [ebp-74h]
  int v5; // [esp+8h] [ebp-70h]
  int *v6; // [esp+Ch] [ebp-6Ch]
  int v7; // [esp+10h] [ebp-68h]
  int v8; // [esp+14h] [ebp-64h]
  int v9; // [esp+18h] [ebp-60h]
  int v10; // [esp+1Ch] [ebp-5Ch]
  int v11; // [esp+20h] [ebp-58h]
  int v12; // [esp+24h] [ebp-54h]
  int v13; // [esp+28h] [ebp-50h]
  int v14; // [esp+2Ch] [ebp-4Ch]
  int v15; // [esp+30h] [ebp-48h]
  int v16; // [esp+34h] [ebp-44h]
  int v17; // [esp+38h] [ebp-40h]
  int v18; // [esp+3Ch] [ebp-3Ch]
  int v19; // [esp+40h] [ebp-38h]
  int v20; // [esp+44h] [ebp-34h]
  int v21; // [esp+48h] [ebp-30h]
  int v22; // [esp+4Ch] [ebp-2Ch]
  int v23; // [esp+50h] [ebp-28h]
  int v24; // [esp+54h] [ebp-24h]
  int v25; // [esp+58h] [ebp-20h]
  int v26; // [esp+5Ch] [ebp-1Ch]
  int v27; // [esp+60h] [ebp-18h]
  int v28; // [esp+64h] [ebp-14h]
  int v29; // [esp+68h] [ebp-10h]
  int v30; // [esp+6Ch] [ebp-Ch]

  sub_805EC59(&v7, a2);
  v19 = v7;
  v20 = v8;
  v21 = v9;
  v22 = v10;
  v23 = v11;
  v24 = v12;
  v25 = v13;
  v26 = v14;
  v27 = v15;
  v28 = v16;
  v29 = v17;
  v30 = v18;
  sub_805EB11(&v3 - 14, 0x3Au, 1);
  v6 = &v19;
  v5 = -1;
  v4 = a3;
  sub_805FE5E(a1);
}

//----- (0806052F) --------------------------------------------------------
void __cdecl sub_806052F(int a1, int a2, int a3, int a4)
{
  sub_8060587(a1, a2, a3, a4, -1);
}

//----- (08060587) --------------------------------------------------------
void __cdecl sub_8060587(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // [esp+0h] [ebp-48h]
  int v6; // [esp+4h] [ebp-44h]
  int v7; // [esp+8h] [ebp-40h]
  int *v8; // [esp+Ch] [ebp-3Ch]
  int v9; // [esp+10h] [ebp-38h]
  int v10; // [esp+14h] [ebp-34h]
  int v11; // [esp+18h] [ebp-30h]
  int v12; // [esp+1Ch] [ebp-2Ch]
  int v13; // [esp+20h] [ebp-28h]
  int v14; // [esp+24h] [ebp-24h]
  int v15; // [esp+28h] [ebp-20h]
  int v16; // [esp+2Ch] [ebp-1Ch]
  int v17; // [esp+30h] [ebp-18h]
  int v18; // [esp+34h] [ebp-14h]
  int v19; // [esp+38h] [ebp-10h]
  int v20; // [esp+3Ch] [ebp-Ch]

  v9 = dword_8072755;
  v10 = dword_8072759;
  v11 = dword_807275D;
  v12 = dword_8072761;
  v13 = dword_8072765;
  v14 = dword_8072769;
  v15 = dword_807276D;
  v16 = dword_8072771;
  v17 = dword_8072775;
  v18 = dword_8072779;
  v19 = dword_807277D;
  v20 = dword_8072781;
  sub_805EBDF(&v5 - 14, a2, a3);
  v8 = &v9;
  v7 = a5;
  v6 = a4;
  sub_805FE5E(a1);
}
// 805EBDF: using guessed type _DWORD __cdecl sub_805EBDF(_DWORD, _DWORD, _DWORD);
// 8072755: using guessed type int dword_8072755;
// 8072759: using guessed type int dword_8072759;
// 807275D: using guessed type int dword_807275D;
// 8072761: using guessed type int dword_8072761;
// 8072765: using guessed type int dword_8072765;
// 8072769: using guessed type int dword_8072769;
// 807276D: using guessed type int dword_807276D;
// 8072771: using guessed type int dword_8072771;
// 8072775: using guessed type int dword_8072775;
// 8072779: using guessed type int dword_8072779;
// 807277D: using guessed type int dword_807277D;
// 8072781: using guessed type int dword_8072781;

//----- (080606B1) --------------------------------------------------------
void __cdecl sub_80606B1(int a1)
{
  sub_805FE5E(a1);
}

//----- (08060718) --------------------------------------------------------
void __cdecl sub_8060718(int a1)
{
  sub_80606B1(a1);
}

//----- (0806073A) --------------------------------------------------------
void sub_806073A()
{
  sub_8060718(0);
}

//----- (08060755) --------------------------------------------------------
_BOOL4 __cdecl sub_8060755(void *src, void *a2)
{
  size_t v2; // ST28_4
  bool v3; // al
  bool v4; // al
  bool v5; // zf
  void *v6; // eax
  int *v7; // eax
  int *v8; // eax
  bool v9; // al
  bool v10; // ST1D_1
  int v12; // [esp+0h] [ebp-F8h]
  int v13; // [esp+4h] [ebp-F4h]
  int v14; // [esp+8h] [ebp-F0h]
  int v15; // [esp+Ch] [ebp-ECh]
  int v16; // [esp+10h] [ebp-E8h]
  int v17; // [esp+14h] [ebp-E4h]
  char *s1; // [esp+18h] [ebp-E0h]
  char *s2; // [esp+1Ch] [ebp-DCh]
  size_t n; // [esp+24h] [ebp-D4h]
  void *ptr; // [esp+28h] [ebp-D0h]
  void *v22; // [esp+2Ch] [ebp-CCh]
  __int64 v23; // [esp+30h] [ebp-C8h]
  __int64 v24; // [esp+88h] [ebp-70h]
  __int64 v25; // [esp+90h] [ebp-68h]
  __int64 v26; // [esp+E8h] [ebp-10h]

  s1 = (char *)sub_8056C9E(src);
  s2 = (char *)sub_8056C9E(a2);
  v2 = sub_8056D0E(s1);
  n = sub_8056D0E(s2);
  v3 = v2 == n && !memcmp(s1, s2, n);
  BYTE2(v17) = v3;
  v4 = v3;
  HIBYTE(v17) = v4;
  BYTE1(v17) = 0;
  v5 = v4 == 0;
  v6 = &loc_806082D;
  if ( v5 )
    v6 = &loc_8060941;
  dword_80711FC = (int)v6;
  sub_8064D6B(v12, v13, v14, v15, v16, v17, s1);
  ptr = sub_8063806(src);
  v22 = sub_8063806(a2);
  if ( sub_8064A21((int)ptr, (int)&v23) )
  {
    v7 = __errno_location();
    error(1, *v7, "%s", ptr);
  }
  if ( sub_8064A21((int)v22, (int)&v25) )
  {
    v8 = __errno_location();
    error(1, *v8, "%s", v22);
  }
  v9 = v24 == v26 && v23 == v25;
  v10 = v9;
  free(ptr);
  free(v22);
  return v10;
}
// 8056C9E: using guessed type _DWORD __cdecl sub_8056C9E(_DWORD);
// 8064D6B: using guessed type int __stdcall sub_8064D6B(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80711FC: using guessed type int dword_80711FC;

//----- (0806096A) --------------------------------------------------------
void sub_806096A()
{
  ;
}

//----- (080609BF) --------------------------------------------------------
signed int sub_80609BF()
{
  *__errno_location() = 95;
  return -1;
}

//----- (080609D7) --------------------------------------------------------
signed int sub_80609D7()
{
  *__errno_location() = 95;
  return -1;
}

//----- (08060B11) --------------------------------------------------------
_DWORD *__userpurge sub_8060B11@<eax>(_DWORD *a1, int a2)
{
  int v2; // edx

  v2 = *(_DWORD *)(a2 + 68);
  *a1 = *(_DWORD *)(a2 + 64);
  a1[1] = v2;
  return a1;
}

//----- (08060B3C) --------------------------------------------------------
_DWORD *__userpurge sub_8060B3C@<eax>(_DWORD *a1, int a2)
{
  int v2; // edx

  v2 = *(_DWORD *)(a2 + 84);
  *a1 = *(_DWORD *)(a2 + 80);
  a1[1] = v2;
  return a1;
}

//----- (08060B67) --------------------------------------------------------
_DWORD *__userpurge sub_8060B67@<eax>(_DWORD *a1, int a2)
{
  int v2; // edx

  v2 = *(_DWORD *)(a2 + 76);
  *a1 = *(_DWORD *)(a2 + 72);
  a1[1] = v2;
  return a1;
}

//----- (08060C02) --------------------------------------------------------
void __cdecl sub_8060C02(int a1, int a2, int a3, int a4)
{
  JUMPOUT(a1, a3, &loc_8058DC6);
  dword_8071254 = (int (*)(void))sub_8060C5A;
  JUMPOUT(a1, a3, &loc_8058DC6);
  dword_8071254 = (int (*)(void))sub_8060C77;
  JUMPOUT(&loc_8058DC6);
}
// 8060C77: using guessed type int sub_8060C77();
// 8071254: using guessed type int (*dword_8071254)(void);

//----- (08060C5A) --------------------------------------------------------
void sub_8060C5A()
{
  dword_8071254 = (int (*)(void))sub_8060C77;
  JUMPOUT(&loc_8058DC6);
}
// 8060C77: using guessed type int sub_8060C77();
// 8071254: using guessed type int (*dword_8071254)(void);

//----- (08060D32) --------------------------------------------------------
#error "80610D0: call analysis failed (funcsize=383)"

//----- (0806138C) --------------------------------------------------------
int __cdecl sub_806138C(FILE *stream, int a2, int a3, int a4, int a5)
{
  int *v5; // eax
  unsigned int i; // [esp+24h] [ebp-34h]
  int v8[12]; // [esp+28h] [ebp-30h]

  for ( i = 0; i <= 9; ++i )
  {
    v5 = (int *)a5;
    a5 += 4;
    v8[i] = *v5;
    if ( !v8[i] )
      break;
  }
  return sub_8060D32(stream, a2, a3, a4, (int)v8, i);
}
// 806138C: using guessed type int var_30[12];

//----- (08061416) --------------------------------------------------------
int sub_8061416(FILE *stream, int a2, int a3, int a4, ...)
{
  va_list va; // [esp+24h] [ebp+18h]

  va_start(va, a4);
  return sub_806138C(stream, a2, a3, a4, (int)va);
}

//----- (080614C6) --------------------------------------------------------
void *__cdecl sub_80614C6(unsigned int a1, unsigned int a2)
{
  if ( 0x7FFFFFFF / a2 < a1 )
    sub_8061768();
  return sub_80615D3(a2 * a1);
}

//----- (080614F4) --------------------------------------------------------
void *__cdecl sub_80614F4(void *ptr, int a2, int a3)
{
  if ( 0x7FFFFFFFu / a3 < a2 )
    sub_8061768();
  return sub_8061609(ptr, a3 * a2);
}

//----- (08061529) --------------------------------------------------------
void *__cdecl sub_8061529(void *ptr, int a2, int a3)
{
  unsigned int v4; // [esp+1Ch] [ebp-Ch]

  v4 = *(_DWORD *)a2;
  if ( ptr )
  {
    if ( 0x55555554u / a3 <= v4 )
      sub_8061768();
    v4 += (v4 >> 1) + 1;
  }
  else
  {
    if ( !v4 )
      v4 = (0x40u / a3 == 0) + 0x40u / a3;
    if ( 0x7FFFFFFFu / a3 < v4 )
      sub_8061768();
  }
  *(_DWORD *)a2 = v4;
  return sub_8061609(ptr, a3 * v4);
}

//----- (080615C0) --------------------------------------------------------
void *__cdecl sub_80615C0(size_t size)
{
  return sub_80615D3(size);
}

//----- (080615D3) --------------------------------------------------------
void *__cdecl sub_80615D3(size_t size)
{
  void *v2; // [esp+1Ch] [ebp-Ch]

  v2 = malloc(size);
  if ( !v2 && size )
    sub_8061768();
  return v2;
}

//----- (08061609) --------------------------------------------------------
void *__cdecl sub_8061609(void *ptr, size_t size)
{
  void *v2; // eax
  void *result; // eax
  int v4; // [esp+0h] [ebp-18h]
  int v5; // [esp+4h] [ebp-14h]
  int v6; // [esp+8h] [ebp-10h]
  int v7; // [esp+Ch] [ebp-Ch]
  int v8; // [esp+10h] [ebp-8h]
  int v9; // [esp+14h] [ebp-4h]
  int savedregs; // [esp+18h] [ebp+0h]

  v2 = &loc_806162E;
  if ( size )
    v2 = &loc_806164C;
  dword_80711FC = (int)v2;
  sub_8064D6B(v4, v5, v6, v7, v8, v9, savedregs);
  if ( ptr )
  {
    free(ptr);
    result = 0;
  }
  else
  {
    result = realloc(0, size);
    if ( !result )
    {
      if ( size )
        sub_8061768();
    }
  }
  return result;
}
// 8064D6B: using guessed type int __stdcall sub_8064D6B(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80711FC: using guessed type int dword_80711FC;

//----- (0806167D) --------------------------------------------------------
void *__cdecl sub_806167D(void *ptr, int a2)
{
  return sub_8061529(ptr, a2, 1);
}

//----- (0806171A) --------------------------------------------------------
void *__cdecl sub_806171A(void *src, size_t n)
{
  void *v2; // eax

  v2 = sub_80615D3(n);
  return memcpy(v2, src, n);
}

//----- (08061743) --------------------------------------------------------
void *__cdecl sub_8061743(char *s)
{
  size_t v1; // eax

  v1 = strlen(s);
  return sub_806171A(s, v1 + 1);
}

//----- (08061768) --------------------------------------------------------
void __noreturn sub_8061768()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (080617A1) --------------------------------------------------------
unsigned __int64 __cdecl sub_80617A1(int nptr, int base, int a3, int a4, int a5, int a6, int s, int a8, int status)
{
  int v9; // eax
  int v10; // ebx
  int v11; // edx
  signed int v12; // eax
  int v14; // [esp+0h] [ebp-48h]
  int v15; // [esp+Ch] [ebp-3Ch]
  int v16; // [esp+10h] [ebp-38h]
  unsigned __int64 v17; // [esp+20h] [ebp-28h]
  unsigned __int64 v18; // [esp+28h] [ebp-20h]
  int v19; // [esp+34h] [ebp-14h]
  unsigned __int64 v20; // [esp+38h] [ebp-10h]

  v18 = __PAIR__(a4, a3);
  v17 = __PAIR__(a6, a5);
  v19 = sub_80621FE((char *)nptr, 0, base, (int)(&v14 - 4), (char *)s);
  if ( v19 )
  {
    if ( v19 == 1 )
    {
      *__errno_location() = 75;
    }
    else if ( v19 == 3 )
    {
      *__errno_location() = 0;
    }
  }
  else if ( v20 < v18 || v17 < v20 )
  {
    v19 = 1;
    if ( v20 <= 0x3FFFFFFF )
      *__errno_location() = 34;
    else
      *__errno_location() = 75;
  }
  if ( v19 )
  {
    v14 = nptr;
    sub_806073A();
    v10 = v9;
    if ( *__errno_location() == 22 )
      v11 = 0;
    else
      v11 = *__errno_location();
    if ( status )
      v12 = status;
    else
      v12 = 1;
    v16 = v10;
    v15 = a8;
    error(v12, v11, "%s: %s", a8, v10);
  }
  return v20;
}

//----- (0806196B) --------------------------------------------------------
char *sub_806196B()
{
  char *v1; // [esp+1Ch] [ebp-Ch]

  v1 = getcwd(0, 0);
  if ( !v1 && *__errno_location() == 12 )
    sub_8061768();
  return v1;
}

//----- (080619B4) --------------------------------------------------------
char *sub_80619B4()
{
  int v1; // [esp+10h] [ebp-18h]
  char *name; // [esp+14h] [ebp-14h]
  size_t len; // [esp+18h] [ebp-10h]
  int v4; // [esp+1Ch] [ebp-Ch]

  name = 0;
  v1 = 34;
  do
  {
    while ( 1 )
    {
      name = (char *)sub_806167D(name, (int)&v1);
      len = v1 - 1;
      name[v1 - 2] = 0;
      *__errno_location() = 0;
      if ( gethostname(name, len) )
        break;
      if ( !name[len - 1] )
        return name;
    }
  }
  while ( !*__errno_location() || *__errno_location() == 36 || *__errno_location() == 22 || *__errno_location() == 12 );
  v4 = *__errno_location();
  free(name);
  *__errno_location() = v4;
  return 0;
}

//----- (08061A88) --------------------------------------------------------
signed int __cdecl sub_8061A88(unsigned int *a1, unsigned int a2)
{
  signed int result; // eax

  if ( 0xFFFFFFFF / a2 >= *a1 )
  {
    *a1 *= a2;
    result = 0;
  }
  else
  {
    *a1 = -1;
    result = 1;
  }
  return result;
}

//----- (08061AFC) --------------------------------------------------------
int __cdecl sub_8061AFC(int a1, int a2, int a3)
{
  int v4; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; i |= sub_8061A88((unsigned int *)a1, a2) )
  {
    v4 = a3--;
    if ( !v4 )
      break;
  }
  return i;
}

//----- (08061B42) --------------------------------------------------------
#error "8061CA3: call analysis failed (funcsize=312)"

//----- (08061F9C) --------------------------------------------------------
#error "8061FCF: call analysis failed (funcsize=70)"

//----- (08062090) --------------------------------------------------------
void __cdecl __noreturn sub_8062090(int a1, int a2, char a3, int a4, int a5)
{
  sub_8061F9C(a1, a2, a3, a4, a5, status);
  abort();
}

//----- (080620E3) --------------------------------------------------------
signed int __cdecl sub_80620E3(int a1, int a2)
{
  unsigned __int64 v2; // rcx
  int v3; // edx
  signed int result; // eax

  LODWORD(v2) = sub_806456E(-1, -1, a2, a2 >> 31);
  HIDWORD(v2) = v3;
  if ( v2 >= *(_QWORD *)a1 )
  {
    *(_QWORD *)a1 *= a2;
    result = 0;
  }
  else
  {
    *(_DWORD *)a1 = -1;
    *(_DWORD *)(a1 + 4) = -1;
    result = 1;
  }
  return result;
}
// 806456E: using guessed type _DWORD __cdecl sub_806456E(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0806219F) --------------------------------------------------------
#error "80621BA: call analysis failed (funcsize=26)"

//----- (080621FE) --------------------------------------------------------
#error "80622E2: call analysis failed (funcsize=302)"

//----- (08062663) --------------------------------------------------------
size_t __cdecl sub_8062663(wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  size_t v5; // eax
  char v6; // [esp+18h] [ebp-10h]
  size_t v7; // [esp+1Ch] [ebp-Ch]

  if ( !pwc )
    pwc = (wchar_t *)&v6;
  v5 = mbrtowc(pwc, s, n, p);
  v7 = v5;
  if ( v5 <= 0xFFFFFFFD || !n || !((unsigned __int8)sub_8057B66(0) ^ 1) )
    return v7;
  *pwc = (unsigned __int8)*s;
  return 1;
}

//----- (080626FD) --------------------------------------------------------
int __cdecl sub_80626FD(int a1, int a2)
{
  int result; // eax

  if ( *(_BYTE *)(a1 + 40) & 1 )
    result = (*(int (__cdecl **)(_DWORD, int))(a1 + 28))(*(_DWORD *)(a1 + 36), a2);
  else
    result = (*(int (__cdecl **)(int))(a1 + 28))(a2);
  return result;
}

//----- (08062747) --------------------------------------------------------
int __cdecl sub_8062747(int a1, int a2)
{
  void (*v2)(void); // eax
  int v4; // [esp+0h] [ebp-18h]
  int v5; // [esp+8h] [ebp-10h]
  int v6; // [esp+Ch] [ebp-Ch]
  int v7; // [esp+10h] [ebp-8h]
  int v8; // [esp+14h] [ebp-4h]
  int savedregs; // [esp+18h] [ebp+0h]

  if ( *(_BYTE *)(a1 + 40) & 1 )
  {
    v2 = *(void (**)(void))(a1 + 32);
    v4 = *(_DWORD *)(a1 + 36);
    v2();
    dword_80711FC = (int)&locret_80627A8;
    sub_8064D6B(v4, a2, v5, v6, v7, v8, savedregs);
  }
  return (*(int (__cdecl **)(int))(a1 + 32))(a2);
}
// 8064D6B: using guessed type int __stdcall sub_8064D6B(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80711FC: using guessed type int dword_80711FC;

//----- (080627AA) --------------------------------------------------------
signed int __cdecl sub_80627AA(int a1, signed int a2, signed int a3)
{
  int v4; // [esp+4h] [ebp-24h]
  int v5; // [esp+18h] [ebp-10h]
  _DWORD *v6; // [esp+1Ch] [ebp-Ch]

  if ( !a3 )
    a3 = 8;
  if ( !a2 )
  {
    v5 = 32;
    a2 = 4064;
  }
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 24) = a3 - 1;
  v4 = *(_DWORD *)a1;
  *(_DWORD *)(a1 + 4) = sub_80626FD(a1, v4);
  v6 = *(_DWORD **)(a1 + 4);
  if ( !v6 )
    obstack_alloc_failed_handler();
  *(_DWORD *)(a1 + 8) = ((unsigned int)&v6[a3 / 4u + 1] + 3) & -a3;
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 8);
  *v6 = (char *)v6 + *(_DWORD *)a1;
  *(_DWORD *)(a1 + 16) = *v6;
  v6[1] = 0;
  *(_BYTE *)(a1 + 40) &= 0xFDu;
  *(_BYTE *)(a1 + 40) &= 0xFBu;
  return 1;
}
// 8071460: using guessed type int (*obstack_alloc_failed_handler)(void);

//----- (080628A9) --------------------------------------------------------
signed int __cdecl sub_80628A9(int a1, signed int a2, signed int a3, int a4, int a5)
{
  *(_DWORD *)(a1 + 28) = a4;
  *(_DWORD *)(a1 + 32) = a5;
  *(_BYTE *)(a1 + 40) &= 0xFEu;
  return sub_80627AA(a1, a2, a3);
}

//----- (08062976) --------------------------------------------------------
int __cdecl sub_8062976(int a1, int a2)
{
  int result; // eax
  _DWORD *v3; // [esp+14h] [ebp-24h]
  unsigned int v4; // [esp+18h] [ebp-20h]
  int v5; // [esp+1Ch] [ebp-1Ch]
  size_t n; // [esp+20h] [ebp-18h]
  size_t v7; // [esp+24h] [ebp-14h]
  size_t v8; // [esp+28h] [ebp-10h]
  void *dest; // [esp+2Ch] [ebp-Ch]

  v5 = *(_DWORD *)(a1 + 4);
  v3 = 0;
  n = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 8);
  v7 = n + a2;
  v8 = *(_DWORD *)(a1 + 24) + n + a2;
  v4 = (n >> 3) + v8 + 100;
  if ( v4 < v8 )
    v4 = v8;
  if ( *(_DWORD *)a1 > v4 )
    v4 = *(_DWORD *)a1;
  if ( n <= v7 && v7 <= v8 )
    v3 = (_DWORD *)sub_80626FD(a1, v4);
  if ( !v3 )
    obstack_alloc_failed_handler();
  *(_DWORD *)(a1 + 4) = v3;
  v3[1] = v5;
  *(_DWORD *)(a1 + 16) = (char *)v3 + v4;
  *v3 = *(_DWORD *)(a1 + 16);
  dest = (void *)(((unsigned int)v3 + *(_DWORD *)(a1 + 24) + 8) & ~*(_DWORD *)(a1 + 24));
  memcpy(dest, *(const void **)(a1 + 8), n);
  if ( !(*(_BYTE *)(a1 + 40) & 2) && *(_DWORD *)(a1 + 8) == ((*(_DWORD *)(a1 + 24) + v5 + 8) & ~*(_DWORD *)(a1 + 24)) )
  {
    v3[1] = *(_DWORD *)(v5 + 4);
    sub_8062747(a1, v5);
  }
  *(_DWORD *)(a1 + 8) = dest;
  *(_DWORD *)(a1 + 12) = n + *(_DWORD *)(a1 + 8);
  result = a1;
  *(_BYTE *)(a1 + 40) &= 0xFDu;
  return result;
}
// 8071460: using guessed type int (*obstack_alloc_failed_handler)(void);

//----- (08062CB0) --------------------------------------------------------
int __cdecl sub_8062CB0(int a1, int a2)
{
  return (a1 == 0) ^ (a2 == 0) && a1 >= 0 && a2 >= 0;
}

//----- (08062CE4) --------------------------------------------------------
_BOOL4 __cdecl sub_8062CE4(_DWORD *a1, _DWORD *a2)
{
  int v2; // ebx

  v2 = a1[5] ^ a2[5] | a1[4] ^ a2[4] | a1[3] ^ a2[3] | a1[2] ^ a2[2] | a1[1] ^ a2[1] | *a2 ^ *a1;
  return (v2 | (unsigned __int8)sub_8062CB0(a1[8], a2[8])) == 0;
}

//----- (08062D92) --------------------------------------------------------
char *__cdecl sub_8062D92(void *dest, void *src, size_t n)
{
  char *result; // eax

  memcpy(dest, src, n);
  result = (char *)dest + n;
  *((_BYTE *)dest + n) = 0;
  return result;
}

//----- (08062DBE) --------------------------------------------------------
char *__cdecl sub_8062DBE(char *s)
{
  size_t v1; // eax
  int v2; // eax
  size_t n; // [esp+14h] [ebp-14h]
  char *v5; // [esp+1Ch] [ebp-Ch]

  if ( s )
    v1 = strlen(s) + 1;
  else
    v1 = 0;
  n = v1;
  if ( v1 <= 0x3A )
    v2 = 59;
  else
    v2 = v1 + 1;
  v5 = (char *)malloc((v2 + 12) & 0xFFFFFFF8);
  if ( v5 )
  {
    *(_DWORD *)v5 = 0;
    v5[4] = s != 0;
    v5[5] = 0;
    if ( s )
      sub_8062D92(v5 + 5, s, n);
  }
  return v5;
}

//----- (08062E68) --------------------------------------------------------
signed int __cdecl sub_8062E68(int a1, unsigned int a2)
{
  int i; // eax
  char *s1; // [esp+10h] [ebp-18h]
  char *s; // [esp+14h] [ebp-14h]
  size_t n; // [esp+18h] [ebp-10h]
  int v7; // [esp+30h] [ebp+8h]

  s1 = (char *)&unk_806A670;
  s = *(char **)(a2 + 40);
  if ( !s || a2 <= (unsigned int)s && a2 + 44 > (unsigned int)s )
    return 1;
  if ( *s )
  {
    s1 = (char *)(a1 + 5);
    for ( i = strcmp((const char *)(a1 + 5), s); i; i = strcmp(s1, s) )
    {
      if ( !*s1 && ((char *)(a1 + 5) != s1 || !*(_BYTE *)(a1 + 4)) )
      {
        n = strlen(s) + 1;
        if ( ~(unsigned int)&s1[-a1 - 5] < n )
        {
          *__errno_location() = 12;
          return 0;
        }
        if ( (unsigned int)&s1[n - 5 - a1] <= 0x3A )
        {
          sub_8062D92(s1, s, n);
          break;
        }
        *(_DWORD *)a1 = sub_8062DBE(s);
        v7 = *(_DWORD *)a1;
        if ( !v7 )
          return 0;
        *(_BYTE *)(v7 + 4) = 0;
        s1 = (char *)(v7 + 5);
        break;
      }
      s1 += strlen(s1) + 1;
      if ( !*s1 )
      {
        if ( *(_DWORD *)a1 )
        {
          a1 = *(_DWORD *)a1;
          s1 = (char *)(a1 + 5);
        }
      }
    }
  }
  *(_DWORD *)(a2 + 40) = s1;
  return 1;
}

//----- (08062FFD) --------------------------------------------------------
void *__cdecl sub_8062FFD(void *ptr)
{
  void *result; // eax
  void *v2; // ST1C_4

  result = (void *)1;
  if ( ptr != (void *)1 )
  {
    while ( ptr )
    {
      v2 = *(void **)ptr;
      free(ptr);
      result = v2;
      ptr = v2;
    }
  }
  return result;
}

//----- (08063030) --------------------------------------------------------
char *sub_8063030()
{
  return getenv("TZ");
}

//----- (08063044) --------------------------------------------------------
int __cdecl sub_8063044(char *value)
{
  int result; // eax

  if ( value )
    result = setenv("TZ", value, 1);
  else
    result = unsetenv("TZ");
  return result;
}

//----- (0806307B) --------------------------------------------------------
signed int __cdecl sub_806307B(int a1)
{
  char *v1; // eax

  if ( *(_BYTE *)(a1 + 4) )
    v1 = (char *)(a1 + 5);
  else
    v1 = 0;
  if ( sub_8063044(v1) )
    return 0;
  tzset();
  return 1;
}

//----- (080630C4) --------------------------------------------------------
#error "8063146: call analysis failed (funcsize=47)"

//----- (080631A8) --------------------------------------------------------
int __cdecl sub_80631A8(void *ptr)
{
  unsigned __int8 v2; // [esp+1Bh] [ebp-Dh]
  int v3; // [esp+1Ch] [ebp-Ch]

  if ( ptr == (void *)1 )
    return 1;
  v3 = *__errno_location();
  v2 = sub_806307B((int)ptr);
  if ( v2 ^ 1 )
    v3 = *__errno_location();
  sub_8062FFD(ptr);
  *__errno_location() = v3;
  return v2;
}

//----- (08063207) --------------------------------------------------------
struct tm *__cdecl sub_8063207(int a1, time_t *timer, struct tm *tp)
{
  struct tm *result; // eax
  char v4; // al
  bool v5; // al
  bool v6; // zf
  int v7; // edx
  int v8; // ecx
  void *v9; // eax
  bool v10; // [esp+1Bh] [ebp-Dh]
  void *ptr; // [esp+1Ch] [ebp-Ch]

  if ( !a1 )
    return gmtime_r(timer, tp);
  ptr = (void *)sub_80630C4(a1);
  if ( !ptr )
    goto LABEL_17;
  v5 = 0;
  if ( localtime_r(timer, tp) )
  {
    v4 = sub_8062E68(a1, (unsigned int)tp);
    if ( v4 )
      v5 = 1;
  }
  v10 = v5;
  v6 = (unsigned __int8)sub_80631A8(ptr) == 0;
  v9 = &loc_80632AB;
  if ( v6 )
    v9 = &loc_80632B8;
  dword_80711DC = (int)v9;
  sub_8064E3D(v8, v7);
  if ( v10 )
    result = tp;
  else
LABEL_17:
    result = 0;
  return result;
}
// 80630C4: using guessed type _DWORD __cdecl sub_80630C4(_DWORD);
// 8064E3D: using guessed type double __fastcall sub_8064E3D(_DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;

//----- (080632BF) --------------------------------------------------------
void __cdecl sub_80632BF(int a1, struct tm *tp)
{
  dword_8071254 = (int (*)(void))sub_80632FB;
  JUMPOUT(a1, 0, &loc_8058DC6);
  timegm(tp);
  dword_8071254 = (int (*)(void))&locret_8063437;
  JUMPOUT(&loc_8058DC6);
}
// 8071254: using guessed type int (*dword_8071254)(void);

//----- (080632FB) --------------------------------------------------------
#error "8063301: call analysis failed (funcsize=82)"

//----- (08063432) --------------------------------------------------------
#error "8063438: positive sp value has been found (funcsize=0)"

//----- (080635DC) --------------------------------------------------------
int __cdecl sub_80635DC(int a1, char a2)
{
  return __ROR4__(a1, a2);
}

//----- (08063707) --------------------------------------------------------
int __cdecl sub_8063707(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // esi
  unsigned __int8 *v3; // ebx
  unsigned __int8 v5; // [esp+1Eh] [ebp-Ah]
  unsigned __int8 v6; // [esp+1Fh] [ebp-9h]

  v2 = a1;
  v3 = a2;
  if ( a1 == a2 )
    return 0;
  do
  {
    v5 = sub_8056028(*v2);
    v6 = sub_8056028(*v3);
    if ( !v5 )
      break;
    ++v2;
    ++v3;
  }
  while ( v5 == v6 );
  return v5 - v6;
}

//----- (0806376C) --------------------------------------------------------
#error "80637C5: call analysis failed (funcsize=50)"

//----- (08063806) --------------------------------------------------------
void *__cdecl sub_8063806(void *src)
{
  void *v2; // [esp+1Ch] [ebp-Ch]

  v2 = sub_8056C1C(src);
  if ( !v2 )
    sub_8061768();
  return v2;
}

//----- (08063836) --------------------------------------------------------
int __cdecl sub_8063836(_BYTE *a1, unsigned int a2)
{
  _BYTE *i; // [esp+8h] [ebp-8h]
  unsigned int v4; // [esp+Ch] [ebp-4h]

  v4 = 0;
  for ( i = a1; *i; ++i )
    v4 = __ROR4__(v4, 23) + (char)*i;
  return v4 % a2;
}

//----- (08063888) --------------------------------------------------------
void *sub_8063888()
{
  _BOOL4 v0; // eax
  bool v1; // zf
  void *v2; // eax
  int v4; // [esp-14h] [ebp-C8h]
  int v5; // [esp-10h] [ebp-C4h]
  int v6; // [esp-Ch] [ebp-C0h]
  int v7; // [esp-8h] [ebp-BCh]
  int v8; // [esp-4h] [ebp-B8h]
  void *v9; // [esp+4h] [ebp-B0h]
  const char *s; // [esp+8h] [ebp-ACh]
  size_t n; // [esp+18h] [ebp-9Ch]
  size_t v12; // [esp+1Ch] [ebp-98h]
  _BOOL4 v13; // [esp+20h] [ebp-94h]
  char *dest; // [esp+24h] [ebp-90h]
  int fd; // [esp+28h] [ebp-8Ch]
  FILE *stream; // [esp+2Ch] [ebp-88h]

  v9 = (void *)dword_8072895;
  if ( !dword_8072895 )
  {
    s = getenv("CHARSETALIASDIR");
    if ( !s || !*s )
      s = "/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib";
    n = strlen(s);
    v12 = strlen("charset.alias");
    v0 = n && s[n - 1] != 47;
    v13 = v0;
    dest = (char *)malloc(n + v0 + v12 + 1);
    if ( dest )
    {
      memcpy(dest, s, n);
      if ( v13 )
        dest[n] = 47;
      memcpy(&dest[n + v13], "charset.alias", v12 + 1);
    }
    free(0);
    if ( dest )
    {
      fd = open64(dest, 0x20000);
      if ( fd >= 0 )
      {
        stream = fdopen(fd, "r");
        if ( stream )
        {
          v1 = getc_unlocked(stream) == -1;
          v2 = &loc_8063B13;
          if ( !v1 )
            v2 = &loc_8063B18;
          dword_80711FC = (int)v2;
          sub_8064D6B(v4, v5, v6, v7, v8, 0, v9);
          sub_8063E79(stream);
          v9 = &unk_806A6CB;
        }
        else
        {
          close(fd);
          v9 = &unk_806A6CB;
        }
      }
      else
      {
        v9 = &unk_806A6CB;
      }
      free(dest);
    }
    else
    {
      v9 = &unk_806A6CB;
    }
    dword_8072895 = (int)&unk_806A6CB;
  }
  return v9;
}
// 80494D0: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 8064D6B: using guessed type int __stdcall sub_8064D6B(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80711FC: using guessed type int dword_80711FC;
// 8072895: using guessed type int dword_8072895;

//----- (08063DC6) --------------------------------------------------------
const char *sub_8063DC6()
{
  char *v0; // ST1C_4
  const char *s1; // [esp+18h] [ebp-10h]
  char *s2; // [esp+1Ch] [ebp-Ch]

  s1 = nl_langinfo(14);
  if ( !s1 )
    s1 = (const char *)&unk_806A6CB;
  for ( s2 = (char *)sub_8063888(); *s2; s2 = &v0[strlen(v0) + 1] )
  {
    if ( !strcmp(s1, s2) || *s2 == 42 && !s2[1] )
    {
      s1 = &s2[strlen(s2) + 1];
      break;
    }
    v0 = &s2[strlen(s2) + 1];
  }
  if ( !*s1 )
    s1 = "ASCII";
  return s1;
}

//----- (08063E79) --------------------------------------------------------
#error "8063F69: call analysis failed (funcsize=67)"

//----- (08063F81) --------------------------------------------------------
int __cdecl sub_8063F81(FILE *stream)
{
  int result; // eax

  result = stream->_flags & 0x100;
  if ( result )
    result = sub_8064013(stream, 0, 0, 1);
  return result;
}

//----- (08063FBA) --------------------------------------------------------
int __cdecl sub_8063FBA(FILE *fp)
{
  bool v1; // zf
  int v2; // edx
  int v3; // ecx
  void *v4; // eax

  if ( fp )
  {
    v1 = __freading(fp) == 0;
    v4 = &loc_8063FEE;
    if ( !v1 )
      v4 = &loc_8063FFB;
    dword_8071210 = (int)v4;
    sub_8064CF3(v3, v2);
  }
  return fflush(fp);
}
// 8064CF3: using guessed type int __fastcall sub_8064CF3(_DWORD, _DWORD);
// 8071210: using guessed type int dword_8071210;

//----- (08064013) --------------------------------------------------------
int __cdecl sub_8064013(FILE *stream, int a2, int a3, int a4)
{
  int v4; // eax
  __int64 v5; // rax
  int v6; // edx
  int v8; // [esp+18h] [ebp-20h]
  int v9; // [esp+1Ch] [ebp-1Ch]
  __int64 v10; // [esp+28h] [ebp-10h]

  v8 = a2;
  v9 = a3;
  if ( stream->_IO_read_end != stream->_IO_read_ptr
    || stream->_IO_write_ptr != stream->_IO_write_base
    || stream->_IO_save_base )
  {
    return fseeko64(stream, v8, v9, a4);
  }
  v4 = fileno(stream);
  LODWORD(v5) = lseek64(v4, v8, v9, a4);
  v10 = v5;
  if ( v5 == -1 )
    return -1;
  stream->_flags &= 0xFFFFFFEF;
  v6 = HIDWORD(v10);
  LODWORD(stream->_offset) = v10;
  HIDWORD(stream->_offset) = v6;
  return 0;
}
// 8049610: using guessed type int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8049A70: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08064121) --------------------------------------------------------
signed __int64 __cdecl sub_8064121(__int64 a1, unsigned int a2, signed int a3)
{
  int v3; // edx
  unsigned int v4; // ecx
  unsigned int v5; // esi
  unsigned int v6; // edi
  unsigned int v7; // ebp
  unsigned int v8; // eax
  int v9; // ecx
  unsigned int v10; // edx
  int v11; // ebp
  int v12; // ecx
  signed __int64 result; // rax
  int v14; // edx
  int v15; // edi
  unsigned __int64 v16; // rtt
  unsigned int v17; // ebp
  int v18; // esi
  unsigned __int64 v19; // rax
  int v20; // [esp+0h] [ebp-1Ch]
  unsigned int v21; // [esp+4h] [ebp-18h]
  unsigned int v22; // [esp+8h] [ebp-14h]
  unsigned int v23; // [esp+Ch] [ebp-10h]

  v3 = a1;
  v20 = 0;
  v21 = a2;
  v4 = HIDWORD(a1);
  if ( a1 < 0 )
  {
    v3 = -(signed int)a1;
    v5 = v21;
    v6 = a3;
    v4 = (unsigned __int64)-a1 >> 32;
    v20 = -1;
    if ( a3 >= 0 )
      goto LABEL_3;
  }
  else
  {
    v5 = v21;
    v6 = a3;
    if ( a3 >= 0 )
      goto LABEL_3;
  }
  v5 = -v5;
  v20 = ~v20;
  v6 = (unsigned __int64)-(signed __int64)__PAIR__(v6, v5) >> 32;
LABEL_3:
  v7 = v4;
  v22 = v3;
  v8 = v6;
  v9 = v3;
  v21 = v5;
  if ( v6 )
  {
    if ( v6 <= v7 )
    {
      _BitScanReverse(&v6, v6);
      v15 = v6 ^ 0x1F;
      if ( v15 )
      {
        v23 = v21 >> (32 - v15);
        v23 |= v8 << v15;
        v21 <<= v15;
        LODWORD(v16) = ((_DWORD)&v20 << v15) | (v22 >> (32 - v15));
        HIDWORD(v16) = (unsigned int)&v20 >> (32 - v15);
        v17 = v16 % v23;
        v18 = v16 / v23;
        v19 = v21 * (unsigned __int64)(unsigned int)v18;
        v21 = HIDWORD(v19);
        if ( v17 < HIDWORD(v19) || v22 << v15 < (unsigned int)v19 && v17 == v21 )
        {
          v12 = v18 - 1;
          v11 = 0;
        }
        else
        {
          v12 = v18;
          v11 = 0;
        }
        goto LABEL_8;
      }
      if ( v21 <= v22 || v8 < v7 )
      {
        v11 = 0;
        v12 = 1;
        goto LABEL_8;
      }
    }
    v11 = 0;
    v12 = 0;
    goto LABEL_8;
  }
  if ( v5 <= v7 )
  {
    if ( !v5 )
      v5 = 1 / 0u;
    v14 = v7 % v5;
    v11 = v7 / v5;
    v12 = __PAIR__((unsigned int)v14, v9) / v5;
  }
  else
  {
    v10 = v7;
    v11 = 0;
    v12 = __PAIR__(v10, v9) / v5;
  }
LABEL_8:
  result = __PAIR__(v11, v12);
  if ( v20 )
    result = -__PAIR__(v11, v12);
  return result;
}

//----- (080642B8) --------------------------------------------------------
#error "80643EE: call analysis failed (funcsize=175)"

//----- (0806456E) --------------------------------------------------------
#error "80645A7: call analysis failed (funcsize=23)"

//----- (080645BA) --------------------------------------------------------
#error "8064622: positive sp value has been found (funcsize=31)"

//----- (080647BA) --------------------------------------------------------
int __cdecl sub_80647BA(unsigned __int64 a1, __int64 a2)
{
  int v2; // ecx
  int result; // eax
  int v4; // ebp
  int v5; // ebp
  unsigned int v6; // ebp
  unsigned __int64 v7; // rtt
  unsigned __int64 v8; // rax
  unsigned int v9; // edi
  unsigned __int64 v10; // rax
  unsigned int v11; // ecx
  unsigned int v12; // [esp+0h] [ebp-20h]
  unsigned int v13; // [esp+4h] [ebp-1Ch]
  unsigned __int64 v14; // [esp+8h] [ebp-18h]
  unsigned int v15; // [esp+10h] [ebp-10h]

  v13 = HIDWORD(a1);
  v2 = a1;
  v15 = a1;
  v12 = a2;
  v14 = a1;
  if ( !HIDWORD(a2) )
  {
    if ( (unsigned int)a2 > HIDWORD(a1) )
      return a1 % (unsigned int)a2;
    v6 = a2;
    if ( !(_DWORD)a2 )
      v6 = 1 / 0u;
    LODWORD(v7) = a1;
    HIDWORD(v7) = v13 % v6;
    dword_80711DC = (int)&loc_8064805;
    sub_8064E3D(a1, v7 % v6);
    return v2;
  }
  if ( HIDWORD(a2) > HIDWORD(a1) )
    return v2;
  _BitScanReverse((unsigned int *)&v4, HIDWORD(a2));
  v5 = v4 ^ 0x1F;
  if ( v5 )
  {
    v13 = (HIDWORD(a2) << v5) | (v12 >> (32 - (_DWORD)&v12));
    LODWORD(v14) = v12 << (char)&v12;
    HIDWORD(v8) = HIDWORD(a1) >> (32 - (_DWORD)&v12);
    LODWORD(v8) = (HIDWORD(a1) << (char)&v12) | (v15 >> (32 - (_DWORD)&v12));
    HIDWORD(v14) = v15 << (char)&v12;
    v9 = v8 % v13;
    v10 = (v12 << (char)&v12) * (unsigned __int64)(unsigned int)(v8 / v13);
    v12 = HIDWORD(v10);
    v11 = v10;
    if ( v9 < HIDWORD(v10) || HIDWORD(v14) < (unsigned int)v10 && v9 == HIDWORD(v10) )
    {
      HIDWORD(v10) = v12;
      HIDWORD(v10) = (v10 - __PAIR__(v13, (unsigned int)v14)) >> 32;
      v11 = v10 - v14;
    }
    result = ((__PAIR__(v9, HIDWORD(v14)) - __PAIR__(HIDWORD(v10), v11)) >> 32 << (32 - (signed int)&v12)) | ((HIDWORD(v14) - v11) >> (char)&v12);
  }
  else
  {
    if ( v12 <= (unsigned int)v14 || HIDWORD(a2) < HIDWORD(v14) )
      v14 = __PAIR__(v13, (unsigned int)a1) - a2;
    result = v14;
  }
  return result;
}
// 8064E3D: using guessed type double __fastcall sub_8064E3D(_DWORD, _DWORD);
// 80711DC: using guessed type int dword_80711DC;

//----- (080649BC) --------------------------------------------------------
#error "80649DC: positive sp value has been found (funcsize=10)"

//----- (080649F2) --------------------------------------------------------
int __cdecl sub_80649F2(int a1)
{
  return __cxa_atexit(a1, 0, dword_807126C);
}
// 80497B0: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 807126C: using guessed type int dword_807126C;

//----- (08064A21) --------------------------------------------------------
int __cdecl sub_8064A21(int a1, int a2)
{
  return __xstat64(3, a1, a2);
}
// 8049AE0: using guessed type int __cdecl __xstat64(_DWORD, _DWORD, _DWORD);

//----- (08064A50) --------------------------------------------------------
int __cdecl sub_8064A50(int a1, int a2)
{
  return __fxstat64(3, a1, a2);
}
// 8049730: using guessed type int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD);

//----- (08064A8F) --------------------------------------------------------
int __cdecl sub_8064A8F(int a1, int a2)
{
  return __lxstat64(3, a1, a2);
}
// 8049AF0: using guessed type int __cdecl __lxstat64(_DWORD, _DWORD, _DWORD);

//----- (08064B77) --------------------------------------------------------
#error "8064B97: positive sp value has been found (funcsize=10)"

//----- (08064C1B) --------------------------------------------------------
#error "8064C21: positive sp value has been found (funcsize=0)"

//----- (08064C87) --------------------------------------------------------
#error "8064C8D: positive sp value has been found (funcsize=0)"

//----- (08064CF3) --------------------------------------------------------
#error "8064CF9: positive sp value has been found (funcsize=0)"

//----- (08064D6B) --------------------------------------------------------
#error "8064D71: positive sp value has been found (funcsize=0)"

//----- (08064E3D) --------------------------------------------------------
#error "8064E43: positive sp value has been found (funcsize=0)"

//----- (08064E50) --------------------------------------------------------
int (**sub_8064E50())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_8070EE4;
  v1 = &off_8070EE8 - off_8070EE4;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_8070EE4[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 8070EE4: using guessed type int (*off_8070EE4[2])();
// 8070EE8: using guessed type int (*off_8070EE8)();

//----- (08064EB4) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 96 decompilation failure(s) on 404 function(s)"
