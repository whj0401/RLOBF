/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8048FC0();
// int __cdecl freopen64(_DWORD, _DWORD, _DWORD); weak
// int dup2(int fd, int fd2);
// int strcmp(const char *s1, const char *s2);
// int __cdecl open64(_DWORD, _DWORD); weak
// int putc_unlocked(int c, FILE *stream);
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void _exit(int status);
// void *memmove(void *dest, const void *src, size_t n);
// void free(void *ptr);
// char *strdup(const char *s);
// void *memcpy(void *dest, const void *src, size_t n);
// int mbsinit(const mbstate_t *ps);
// int ferror(FILE *stream);
// int fclose(FILE *stream);
// intmax_t strtoimax(const char *nptr, char **endptr, int base);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// char *textdomain(const char *domainname);
// int iswprint(wint_t wc);
// int __cdecl fopen64(_DWORD, _DWORD); weak
// int ferror_unlocked(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD); weak
// size_t __ctype_get_mb_cur_max(void);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// size_t __fpending(FILE *fp);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// void error(int status, int errnum, const char *format, ...);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int re_match(struct re_pattern_buffer *buffer, const char *string, int length, int start, struct re_registers *regs);
// int __freading(FILE *fp);
// int iswspace(wint_t wc);
// void exit(int status);
// int __cdecl ftello64(_DWORD); weak
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// char *strchr(const char *s, int c);
// size_t strlen(const char *s);
// size_t iconv(iconv_t cd, char **inbuf, size_t *inbytesleft, char **outbuf, size_t *outbytesleft);
// int iconv_close(iconv_t cd);
// int fprintf(FILE *stream, const char *format, ...);
// int re_search(struct re_pattern_buffer *buffer, const char *string, int length, int start, int range, struct re_registers *regs);
// int re_compile_fastmap(struct re_pattern_buffer *buffer);
// void *memset(void *s, int c, size_t n);
// int iswalnum(wint_t wc);
// int *__errno_location(void);
// void *memchr(const void *s, int c, size_t n);
// int fileno(FILE *stream);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// int strnlen(void); weak
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// int toupper(int c);
// char *strrchr(const char *s, int c);
// int sprintf(char *s, const char *format, ...);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// const char *re_compile_pattern(const char *pattern, size_t length, struct re_pattern_buffer *buffer);
// char *bindtextdomain(const char *domainname, const char *dirname);
// int strncmp(const char *s1, const char *s2, size_t n);
// void abort(void);
// iconv_t iconv_open(const char *tocode, const char *fromcode);
// int close(int fd);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// int putchar_unlocked(int c);
// int _gmon_start__(void); weak
void sub_8049533();
void sub_8049550();
int sub_8049560();
int sub_80495D0();
int sub_80495F0();
void sub_804964F();
void sub_804966A();
signed int sub_804967A();
void sub_804975C();
void sub_8049777();
int sub_8049787();
void sub_8049869();
void sub_8049884();
int sub_8049894();
void sub_804998B();
void sub_80499A6();
signed int sub_80499B6();
void sub_8049A98();
void sub_8049AB3();
int sub_8049AC3();
void sub_8049BBA();
void sub_8049BD5();
int sub_8049BE5();
void sub_8049CD9();
void sub_8049CF4();
int sub_8049D04();
void sub_8049DE6();
void sub_8049E01();
int sub_8049E11();
void sub_8049EF3();
void sub_8049F0E();
int sub_8049F1E();
int __cdecl sub_8049FE0(unsigned __int8 a1);
int sub_8049FF2();
int sub_804A01D();
int __cdecl sub_804A048(_DWORD); // weak
int __cdecl sub_804A0CD(char *s2, size_t n); // idb
_BYTE *__cdecl sub_804A21C(char *a1);
_BYTE *__cdecl sub_804A24C(char *s);
int __cdecl sub_804A5FD(int a1);
char sub_804A6E8();
int __cdecl sub_804A840(char *s1, int); // idb
int sub_804A925(const void *, const void *); // idb
int compar(const void *, const void *); // idb
int __cdecl sub_804AAEE(void *, int); // idb
void sub_804ABC5();
void __cdecl sub_804ABFE(char *s1);
int __cdecl sub_804AC91(char *s1, int); // idb
int __cdecl sub_804B547(int a1);
_DWORD __cdecl sub_804B56D(_DWORD, _DWORD); // weak
_DWORD sub_804BA48(); // weak
_DWORD __cdecl sub_804BE2D(_DWORD); // weak
int sub_804CAB4();
int sub_804CCD7();
int sub_804CF5C(void); // weak
size_t sub_804D3BA();
void __cdecl __noreturn sub_804D474(int status); // idb
int __cdecl main(int, char **, char **); // idb
void __noreturn sub_804DFF1();
int __cdecl sub_804E005(char *s, int, int, size_t); // idb
void __cdecl sub_804E15E(int a1, int a2, int a3);
int __cdecl sub_804E1F6(int, int, size_t n); // idb
_DWORD sub_804E31D(); // weak
signed int __cdecl sub_804E33F(int a1, int a2, int a3, int a4, int a5, size_t a6);
void __noreturn sub_804E462();
int sub_804E57A(); // weak
signed int __cdecl sub_804E59E(int a1);
FILE *__cdecl sub_804E5ED(int a1, int a2, FILE *stream);
char *__cdecl sub_804E747(char *s);
// int __usercall sub_804E820@<eax>(int a1@<ebx>, _BYTE *a2, int a3);
int __cdecl sub_804EDF1(char *msgid, char *); // idb
int __cdecl sub_804F13A(int *a1, unsigned __int8 a2, char a3);
int *__cdecl sub_804F214(int *a1, int a2, int a3);
// _DWORD *__userpurge sub_804F255@<eax>(_DWORD *a1, int a2);
char *__cdecl sub_804F317(char *msgid);
_DWORD __cdecl sub_804F3E7(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
void *__cdecl sub_8050666(signed int a1, int a2, int a3, _DWORD *a4);
void *__cdecl sub_8050946(signed int a1, int a2);
void *__cdecl sub_8050970(signed int a1, int a2, int a3);
void *__cdecl sub_80509F6(signed int a1, int a2, int a3);
void *__cdecl sub_8050A34(signed int a1, int a2, int a3, int a4);
void *__cdecl sub_8050ACC(int a1, int a2, unsigned __int8 a3);
void *__cdecl sub_8050B96(int a1, unsigned __int8 a2);
void *__cdecl sub_8050BCF(int a1);
void *__cdecl sub_8050C0C(signed int a1, int a2, int a3);
void *__cdecl sub_8050CCD(int a1, int a2, int a3, int a4);
void *__cdecl sub_8050D1D(signed int a1, int a2, int a3, int a4, int a5);
void *__cdecl sub_8050E7C(signed int a1, int a2, int a3);
void *__cdecl sub_8050ED7(signed int a1, int a2);
void *__cdecl sub_8050EF9(int a1);
void *__cdecl sub_8050F14(FILE *stream, int a2);
void *__cdecl sub_80511F3(int a1, int a2, int a3);
void *__cdecl sub_805127A(int a1, int a2);
_DWORD __cdecl sub_80512BE(_DWORD); // weak
int __cdecl sub_80512F9(int c, size_t n); // idb
int __cdecl sub_805166A(FILE *stream, int, int, int, int, int); // idb
_DWORD __cdecl sub_8051E75(_DWORD, _DWORD, _DWORD, _DWORD, char); // weak
void *__cdecl sub_8051F4A(unsigned int a1, unsigned int a2);
void *__cdecl sub_8051FAD(void *ptr, int a2, int a3);
void *__cdecl sub_8052044(size_t size);
void *__cdecl sub_8052057(size_t size);
void *__cdecl sub_8052081(void *ptr, size_t size);
void *__cdecl sub_8052159(void *src, size_t n);
void __noreturn sub_80521A7();
int __cdecl sub_8052298(char *s, char *fromcode, char *tocode); // idb
signed int __cdecl sub_80522D6(unsigned int *a1, signed int a2);
int __cdecl sub_80523F0(unsigned int *a1, signed int a2, int a3);
int __cdecl sub_8052426(char *nptr, int, int base, int, char *s); // idb
int __cdecl sub_805285B(FILE *stream); // idb
int __cdecl sub_805291E(FILE *stream); // idb
int __cdecl sub_8052957(FILE *fp); // idb
int __cdecl sub_8052997(FILE *stream, int, int, int); // idb
size_t __cdecl sub_8052ADF(wchar_t *pwc, char *s, size_t n, mbstate_t *p);
int __cdecl sub_8052B6A(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_8052BE8(FILE *fp); // idb
int __cdecl sub_8052C82(int category); // idb
void *sub_8052CF9();
const char *sub_8053247();
int __cdecl sub_80532FA(int a1);
_DWORD __cdecl sub_805368B(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int sub_8053925(void); // weak
int __cdecl sub_805394B(size_t); // idb
// _BYTE *__usercall sub_805418D@<eax>(int a1@<ebx>, _BYTE *a2, _BYTE *a3);
int __cdecl sub_8054A3A(int a1);
signed int __cdecl sub_8054D2F(char *a1, size_t a2, void *a3, void **a4, size_t *a5);
int __cdecl sub_8055174(char *s, iconv_t cd); // idb
int __cdecl sub_8055512(char *s, char *fromcode, char *tocode); // idb
size_t __cdecl sub_805560C(void *s, size_t n);
int __cdecl sub_8055895(int a1);
unsigned int __cdecl sub_80558CB(unsigned int a1);
_DWORD __cdecl sub_8055980(_DWORD); // weak
int __cdecl sub_8055A8D(int a1, int a2);
bool __cdecl sub_8055B1D(unsigned __int8 a1);
_DWORD __cdecl sub_8055B74(_DWORD); // weak
signed __int64 __cdecl sub_8055C65(__int64 a1, unsigned int a2, signed int a3);
int __cdecl sub_8055EB4(int a1);
int __cdecl sub_8055EE3(int a1, int a2);
int __stdcall sub_8056042(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __fastcall sub_80560B4(_DWORD, _DWORD); // weak
int __stdcall sub_8056120(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __fastcall sub_8056198(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_8056206(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_8056278(_DWORD); // weak
int (**sub_8056290())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_804A277; // weak
_UNKNOWN loc_804A5EE; // weak
_UNKNOWN loc_804AA66; // weak
_UNKNOWN loc_804CB0A; // weak
_UNKNOWN loc_804CB21; // weak
_UNKNOWN loc_804CE37; // weak
_UNKNOWN loc_804CE68; // weak
_UNKNOWN loc_804D460; // weak
_UNKNOWN loc_804E19A; // weak
_UNKNOWN loc_804E493; // weak
_UNKNOWN loc_804E4C6; // weak
_UNKNOWN loc_804E4F7; // weak
_UNKNOWN loc_804E547; // weak
_UNKNOWN loc_804E56D; // weak
_UNKNOWN loc_804EB84; // weak
_UNKNOWN loc_804EB99; // weak
_UNKNOWN loc_804EC87; // weak
_UNKNOWN loc_804EC8E; // weak
_UNKNOWN loc_804ED29; // weak
_UNKNOWN loc_804F373; // weak
_UNKNOWN loc_804F38B; // weak
_UNKNOWN loc_80506E6; // weak
_UNKNOWN loc_805071C; // weak
_UNKNOWN loc_805072F; // weak
_UNKNOWN loc_8050896; // weak
_UNKNOWN loc_80508A1; // weak
_UNKNOWN loc_80510A2; // weak
_UNKNOWN loc_8051128; // weak
_UNKNOWN loc_8052A5C; // weak
_UNKNOWN loc_8052A63; // weak
_UNKNOWN loc_8052B39; // weak
_UNKNOWN loc_8052B65; // weak
_UNKNOWN loc_8052BC4; // weak
_UNKNOWN loc_8052BC6; // weak
_UNKNOWN loc_8052C46; // weak
_UNKNOWN loc_8052C5E; // weak
_UNKNOWN loc_8052CD8; // weak
_UNKNOWN loc_8052CEF; // weak
_UNKNOWN loc_8052E00; // weak
_UNKNOWN loc_8052E7E; // weak
_UNKNOWN loc_8052E8F; // weak
_UNKNOWN loc_8052F7E; // weak
_UNKNOWN loc_8052F9B; // weak
_UNKNOWN loc_805320E; // weak
_UNKNOWN loc_8053325; // weak
_UNKNOWN loc_805332A; // weak
_UNKNOWN loc_8054451; // weak
_UNKNOWN loc_805449F; // weak
_UNKNOWN loc_80544BC; // weak
_UNKNOWN loc_8054500; // weak
_UNKNOWN loc_8054513; // weak
_UNKNOWN loc_80547CE; // weak
_UNKNOWN loc_80548E9; // weak
_UNKNOWN loc_80548F3; // weak
_UNKNOWN loc_8054A20; // weak
_UNKNOWN loc_8054A65; // weak
_UNKNOWN loc_8054A6A; // weak
_UNKNOWN loc_80550D7; // weak
_UNKNOWN loc_80550D9; // weak
_UNKNOWN unk_805735E; // weak
_UNKNOWN unk_8057362; // weak
_UNKNOWN unk_80576A4; // weak
_UNKNOWN unk_8057C6F; // weak
int dword_8057E30[8] = { 6656, 4294967279, 4294967294, 2147483646, 0, 0, 0, 0 }; // idb
_UNKNOWN unk_80581F0; // weak
_UNKNOWN unk_80581F3; // weak
_UNKNOWN unk_80591FC; // weak
_UNKNOWN unk_80591FF; // weak
int (*off_805BEE4[2])() = { &sub_80495F0, &sub_80495D0 }; // weak
int (*off_805BEE8)() = &sub_80495D0; // weak
int (*dword_805C008)(void) = NULL; // weak
int dword_805C160 = 0; // weak
int dword_805C174 = 0; // weak
int dword_805C19C = 0; // weak
int dword_805C1B0 = 0; // weak
int dword_805C1C4 = 0; // weak
int dword_805C1F4 = 0; // weak
char byte_805C1F8 = '\x01'; // weak
char *s = "/"; // idb
char *off_805C208[2] = { "xx", "8.28" }; // weak
int status = 1; // idb
int dword_805C230 = 1; // weak
int dword_805C234 = 256; // weak
void *off_805C238 = &unk_805CC55; // weak
int *off_805C23C = &dword_805C234; // weak
_UNKNOWN unk_805C250; // weak
_UNKNOWN unk_805C26C; // weak
_UNKNOWN unk_805C26F; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int program_invocation_name; // weak
FILE *stdin; // idb
FILE *stdout; // idb
char byte_805C2CC; // weak
char byte_805C595; // weak
char byte_805C596; // weak
int dword_805C599; // weak
char byte_805C59D; // weak
char *s1; // idb
int dword_805C5B5; // weak
int dword_805C6F5; // weak
struct re_pattern_buffer buffer; // idb
char byte_805C835[256]; // idb
char byte_805C955[9]; // idb
char byte_805C95E; // weak
char byte_805C95F; // weak
char byte_805C975; // weak
void *ptr; // idb
size_t nmemb; // idb
int dword_805CBC5; // weak
int dword_805CBC9; // weak
char byte_805CBCD; // weak
char *string; // idb
int dword_805CBD5; // weak
char byte_805CBD9; // weak
int dword_805CBDD; // weak
int dword_805CBE1; // weak
char byte_805CBE5; // weak
char *dword_805CBE9; // idb
int dword_805CBED; // weak
char byte_805CBF1; // weak
int dword_805CBF5; // weak
int dword_805CBF9; // weak
int dword_805CBFD; // weak
char byte_805CC01; // weak
int dword_805CC05; // weak
int dword_805CC15; // weak
int dword_805CC19; // weak
int dword_805CC1D; // weak
int dword_805CC21; // weak
int dword_805CC25; // weak
int dword_805CC29; // weak
int dword_805CC2D; // weak
int dword_805CC31; // weak
int dword_805CC35; // weak
int dword_805CC39; // weak
int dword_805CC3D; // weak
int dword_805CC41; // weak
_UNKNOWN unk_805CC55; // weak
int dword_805CD55; // weak
int dword_805CD75[263]; // idb
// extern _UNKNOWN __gmon_start__; weak


//----- (08048F98) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 80494F0: using guessed type int _gmon_start__(void);

//----- (08048FC0) --------------------------------------------------------
int sub_8048FC0()
{
  return dword_805C008();
}
// 805C008: using guessed type int (*dword_805C008)(void);

//----- (08049500) --------------------------------------------------------
#error "8049503: positive sp value has been found (funcsize=2)"

//----- (08049533) --------------------------------------------------------
void sub_8049533()
{
  ;
}

//----- (08049550) --------------------------------------------------------
void sub_8049550()
{
  ;
}

//----- (08049560) --------------------------------------------------------
int sub_8049560()
{
  int result; // eax

  result = 134595203 - (_DWORD)&program_invocation_short_name;
  if ( (unsigned int)(134595203 - (_DWORD)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 8049560: could not find valid save-restore pair for ebp
// 805C280: using guessed type int program_invocation_short_name;

//----- (080495D0) --------------------------------------------------------
int sub_80495D0()
{
  int result; // eax

  if ( !byte_805C2CC )
  {
    result = sub_8049560();
    byte_805C2CC = 1;
  }
  return result;
}
// 80495D0: could not find valid save-restore pair for ebp
// 805C2CC: using guessed type char byte_805C2CC;

//----- (080495F0) --------------------------------------------------------
int sub_80495F0()
{
  return 0;
}
// 80495F0: could not find valid save-restore pair for ebp

//----- (0804964F) --------------------------------------------------------
void sub_804964F()
{
  ;
}

//----- (0804966A) --------------------------------------------------------
void sub_804966A()
{
  ;
}

//----- (0804967A) --------------------------------------------------------
signed int sub_804967A()
{
  return 3;
}
// 804967A: could not find valid save-restore pair for ebp

//----- (0804975C) --------------------------------------------------------
void sub_804975C()
{
  ;
}

//----- (08049777) --------------------------------------------------------
void sub_8049777()
{
  ;
}

//----- (08049787) --------------------------------------------------------
int sub_8049787()
{
  int result; // eax

  result = &unk_805C26F - &unk_805C26C;
  if ( (unsigned int)(&unk_805C26F - &unk_805C26C) > 6 )
    result = 0;
  return result;
}
// 8049787: could not find valid save-restore pair for ebp

//----- (08049869) --------------------------------------------------------
void sub_8049869()
{
  ;
}

//----- (08049884) --------------------------------------------------------
void sub_8049884()
{
  ;
}

//----- (08049894) --------------------------------------------------------
int sub_8049894()
{
  int result; // eax

  result = &unk_805C26F - &unk_805C26C;
  if ( (unsigned int)(&unk_805C26F - &unk_805C26C) > 6 )
    result = 0;
  return result;
}
// 8049894: could not find valid save-restore pair for ebp

//----- (0804998B) --------------------------------------------------------
void sub_804998B()
{
  ;
}

//----- (080499A6) --------------------------------------------------------
void sub_80499A6()
{
  ;
}

//----- (080499B6) --------------------------------------------------------
signed int sub_80499B6()
{
  return 3;
}
// 80499B6: could not find valid save-restore pair for ebp

//----- (08049A98) --------------------------------------------------------
void sub_8049A98()
{
  ;
}

//----- (08049AB3) --------------------------------------------------------
void sub_8049AB3()
{
  ;
}

//----- (08049AC3) --------------------------------------------------------
int sub_8049AC3()
{
  int result; // eax

  result = &unk_805C26F - &unk_805C26C;
  if ( (unsigned int)(&unk_805C26F - &unk_805C26C) > 6 )
    result = 0;
  return result;
}
// 8049AC3: could not find valid save-restore pair for ebp

//----- (08049BBA) --------------------------------------------------------
void sub_8049BBA()
{
  ;
}

//----- (08049BD5) --------------------------------------------------------
void sub_8049BD5()
{
  ;
}

//----- (08049BE5) --------------------------------------------------------
int sub_8049BE5()
{
  int result; // eax

  result = &unk_805C26F - &unk_805C26C;
  if ( (unsigned int)(&unk_805C26F - &unk_805C26C) > 6 )
    result = 0;
  return result;
}
// 8049BE5: could not find valid save-restore pair for ebp

//----- (08049CD9) --------------------------------------------------------
void sub_8049CD9()
{
  ;
}

//----- (08049CF4) --------------------------------------------------------
void sub_8049CF4()
{
  ;
}

//----- (08049D04) --------------------------------------------------------
int sub_8049D04()
{
  int result; // eax

  result = &unk_80591FF - &unk_80591FC;
  if ( (unsigned int)(&unk_80591FF - &unk_80591FC) > 6 )
    result = 0;
  return result;
}
// 8049D04: could not find valid save-restore pair for ebp

//----- (08049DE6) --------------------------------------------------------
void sub_8049DE6()
{
  ;
}

//----- (08049E01) --------------------------------------------------------
void sub_8049E01()
{
  ;
}

//----- (08049E11) --------------------------------------------------------
int sub_8049E11()
{
  int result; // eax

  result = &unk_80581F3 - &unk_80581F0;
  if ( (unsigned int)(&unk_80581F3 - &unk_80581F0) > 6 )
    result = 0;
  return result;
}
// 8049E11: could not find valid save-restore pair for ebp

//----- (08049EF3) --------------------------------------------------------
void sub_8049EF3()
{
  ;
}

//----- (08049F0E) --------------------------------------------------------
void sub_8049F0E()
{
  ;
}

//----- (08049F1E) --------------------------------------------------------
int sub_8049F1E()
{
  int result; // eax

  result = &unk_80581F3 - &unk_80581F0;
  if ( (unsigned int)(&unk_80581F3 - &unk_80581F0) > 6 )
    result = 0;
  return result;
}
// 8049F1E: could not find valid save-restore pair for ebp

//----- (08049FE0) --------------------------------------------------------
int __cdecl sub_8049FE0(unsigned __int8 a1)
{
  return a1;
}

//----- (08049FF2) --------------------------------------------------------
int sub_8049FF2()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nWith no FILE, or when FILE is -, read standard input.\n");
  return fputs_unlocked(v1, v0);
}
// 80492B0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804A01D) --------------------------------------------------------
int sub_804A01D()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nMandatory arguments to long options are mandatory for short options too.\n");
  return fputs_unlocked(v1, v0);
}
// 80492B0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804A048) --------------------------------------------------------
#error "804A0C8: call analysis failed (funcsize=28)"

//----- (0804A0CD) --------------------------------------------------------
#error "804A219: positive sp value has been found (funcsize=84)"

//----- (0804A21C) --------------------------------------------------------
_BYTE *__cdecl sub_804A21C(char *a1)
{
  char *v1; // ebx
  int *v2; // eax

  v1 = gettext("error in regular expression matcher");
  v2 = __errno_location();
  error(1, *v2, v1);
  return sub_804A24C(a1);
}

//----- (0804A24C) --------------------------------------------------------
#error "804A5E9: call analysis failed (funcsize=33)"

//----- (0804A5FD) --------------------------------------------------------
int __cdecl sub_804A5FD(int a1)
{
  unsigned __int8 *v1; // eax
  size_t v2; // eax
  void *v3; // ebx
  char *v4; // eax
  const char *v6; // [esp+Ch] [ebp-2Ch]
  void *v7; // [esp+10h] [ebp-28h]
  struct re_pattern_buffer *buffer; // [esp+24h] [ebp-14h]
  char *s; // [esp+28h] [ebp-10h]
  const char *v10; // [esp+2Ch] [ebp-Ch]

  buffer = (struct re_pattern_buffer *)(a1 + 4);
  s = *(char **)a1;
  buffer->buffer = 0;
  buffer->allocated = 0;
  buffer->fastmap = (char *)(a1 + 36);
  if ( byte_805C59D )
    v1 = (unsigned __int8 *)byte_805C835;
  else
    v1 = 0;
  buffer->translate = v1;
  v2 = strlen(s);
  v10 = re_compile_pattern(s, v2, buffer);
  if ( v10 )
  {
    v3 = sub_8050EF9((int)s);
    v4 = gettext("%s (for regexp %s)");
    v7 = v3;
    v6 = v10;
    error(1, 0, v4, v10, v3);
  }
  return re_compile_fastmap(buffer);
}
// 805C59D: using guessed type char byte_805C59D;

//----- (0804A6E8) --------------------------------------------------------
char sub_804A6E8()
{
  char result; // al
  int v1; // eax
  bool v2; // zf
  signed int c; // [esp+1Ch] [ebp-Ch]
  int ca; // [esp+1Ch] [ebp-Ch]

  if ( byte_805C59D )
  {
    for ( c = 0; c <= 255; ++c )
      *(_BYTE *)(c + 134596661) = toupper(c);
  }
  if ( dword_805C5B5 )
  {
    if ( !*(_BYTE *)dword_805C5B5 )
      dword_805C5B5 = 0;
  }
  else if ( byte_805C1F8 && byte_805C596 != 1 )
  {
    dword_805C5B5 = (int)"[.?!][]\"')}]*\\($\\|\t\\|  \\)[ \t\n]*";
  }
  else
  {
    dword_805C5B5 = (int)"\n";
  }
  if ( dword_805C5B5 )
    sub_804A5FD((int)&dword_805C5B5);
  if ( dword_805C6F5 )
    return sub_804A5FD((int)&dword_805C6F5);
  result = (char)s1;
  if ( !s1 )
  {
    result = byte_805C1F8;
    if ( byte_805C1F8 )
    {
      for ( ca = 0; ca <= 255; ++ca )
      {
        v1 = (*__ctype_b_loc())[ca] & 0x400;
        v2 = v1 == 0;
        result = v1 != 0;
        *(_BYTE *)(ca + 134596949) = !v2;
      }
    }
    else
    {
      result = (unsigned int)memset(byte_805C955, 1, 0x100u);
      byte_805C975 = 0;
      byte_805C95E = 0;
      byte_805C95F = 0;
    }
  }
  return result;
}
// 805C1F8: using guessed type char byte_805C1F8;
// 805C596: using guessed type char byte_805C596;
// 805C59D: using guessed type char byte_805C59D;
// 805C5B5: using guessed type int dword_805C5B5;
// 805C6F5: using guessed type int dword_805C6F5;
// 805C95E: using guessed type char byte_805C95E;
// 805C95F: using guessed type char byte_805C95F;
// 805C975: using guessed type char byte_805C975;

//----- (0804A840) --------------------------------------------------------
int __cdecl sub_804A840(char *s1, int a2)
{
  bool v2; // al
  void *v3; // eax
  char *v4; // eax
  void *v5; // ebx
  int *v6; // eax
  int result; // eax
  bool v8; // [esp+1Bh] [ebp-Dh]
  int v9; // [esp+1Ch] [ebp-Ch]

  v2 = !s1 || !*s1 || !strcmp(s1, "-");
  v8 = v2;
  if ( v2 )
    v3 = sub_8050F14(stdin, (int)&v9);
  else
    v3 = sub_805127A((int)s1, (int)&v9);
  *(_DWORD *)a2 = v3;
  if ( !*(_DWORD *)a2 )
  {
    if ( v8 )
      v4 = "-";
    else
      v4 = s1;
    v5 = sub_8050C0C(0, 3, (int)v4);
    v6 = __errno_location();
    error(1, *v6, "%s", v5);
  }
  result = a2;
  *(_DWORD *)(a2 + 4) = v9 + *(_DWORD *)a2;
  return result;
}

//----- (0804A925) --------------------------------------------------------
#error "804AA11: call analysis failed (funcsize=114)"

//----- (0804AA9F) --------------------------------------------------------
int __cdecl compar(const void *a1, const void *a2)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = sub_804A925(a1, a2);
  if ( v3 )
    return v3;
  if ( *(_DWORD *)a1 < *(_DWORD *)a2 )
    return -1;
  return *(_DWORD *)a1 > *(_DWORD *)a2;
}

//----- (0804AAEE) --------------------------------------------------------
#error "804ABB9: call analysis failed (funcsize=23)"

//----- (0804ABC5) --------------------------------------------------------
void sub_804ABC5()
{
  if ( nmemb )
    qsort(ptr, nmemb, 0x1Cu, compar);
}

//----- (0804ABFE) --------------------------------------------------------
void __cdecl sub_804ABFE(char *s1)
{
  unsigned __int8 *i; // [esp+14h] [ebp-14h]
  void *ptr; // [esp+18h] [ebp-10h]
  unsigned int v3; // [esp+1Ch] [ebp-Ch]

  sub_804A840(s1, (int)&ptr);
  memset(byte_805C955, 1, 0x100u);
  for ( i = (unsigned __int8 *)ptr; v3 > (unsigned int)i; ++i )
    byte_805C955[(unsigned __int8)sub_8049FE0(*i)] = 0;
  if ( byte_805C1F8 != 1 )
  {
    byte_805C975 = 0;
    byte_805C95E = 0;
    byte_805C95F = 0;
  }
  free(ptr);
}
// 805C1F8: using guessed type char byte_805C1F8;
// 805C95E: using guessed type char byte_805C95E;
// 805C95F: using guessed type char byte_805C95F;
// 805C975: using guessed type char byte_805C975;

//----- (0804AC91) --------------------------------------------------------
#error "804AD62: call analysis failed (funcsize=85)"

//----- (0804AE0F) --------------------------------------------------------
#error "804B140: call analysis failed (funcsize=255)"

//----- (0804B547) --------------------------------------------------------
int __cdecl sub_804B547(int a1)
{
  int result; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  result = a1;
  for ( i = a1; i > 0; --i )
    result = putchar_unlocked(32);
  return result;
}

//----- (0804B56D) --------------------------------------------------------
#error "804BA1C: call analysis failed (funcsize=294)"

//----- (0804BA48) --------------------------------------------------------
#error "804BB6A: call analysis failed (funcsize=204)"

//----- (0804BE2D) --------------------------------------------------------
#error "804BF01: call analysis failed (funcsize=726)"

//----- (0804CAB4) --------------------------------------------------------
#error "804CB05: call analysis failed (funcsize=116)"

//----- (0804CCD7) --------------------------------------------------------
int sub_804CCD7()
{
  signed int v0; // eax
  bool v1; // zf
  int v2; // edx
  int v3; // ecx
  void *v4; // eax
  char *v6; // [esp+0h] [ebp-48h]
  unsigned __int8 *string; // [esp+28h] [ebp-20h]
  int v8; // [esp+2Ch] [ebp-1Ch]
  int v9; // [esp+30h] [ebp-18h]
  int v10; // [esp+3Ch] [ebp-Ch]

  printf("\\%s ", off_805C208[0]);
  putchar_unlocked(123);
  sub_804B56D(dword_805CBC5, dword_805CBC9);
  fwrite_unlocked("}{", 1u, 2u, stdout);
  sub_804B56D(::string, dword_805CBD5);
  fwrite_unlocked("}{", 1u, 2u, stdout);
  v9 = dword_805CBDD;
  v10 = dword_805CBE1;
  string = (unsigned __int8 *)dword_805CBDD;
  if ( dword_805C6F5 )
  {
    v8 = re_match(&buffer, (const char *)dword_805CBDD, dword_805CBE1 - dword_805CBDD, 0, 0);
    if ( v8 == -2 )
      sub_804A21C(v6);
    if ( v8 == -1 )
      v0 = 1;
    else
      v0 = v8;
    string += v0;
  }
  else
  {
    v1 = byte_805C955[(unsigned __int8)sub_8049FE0(*(_BYTE *)dword_805CBDD)] == 0;
    v4 = &loc_804CE37;
    if ( v1 )
      v4 = &loc_804CE68;
    dword_805C1B0 = (int)v4;
    sub_80560B4(v3, v2);
    while ( dword_805CBE1 > (unsigned int)string && byte_805C955[(unsigned __int8)sub_8049FE0(*string)] )
      ++string;
  }
  sub_804B56D(v9, string);
  fwrite_unlocked("}{", 1u, 2u, stdout);
  sub_804B56D(string, v10);
  fwrite_unlocked("}{", 1u, 2u, stdout);
  sub_804B56D(dword_805CBE9, dword_805CBED);
  putchar_unlocked(125);
  if ( byte_805C595 || byte_805C596 )
  {
    putchar_unlocked(123);
    sub_804B56D(dword_805CBF5, dword_805CBF9);
    putchar_unlocked(125);
  }
  return putchar_unlocked(10);
}
// 804B56D: using guessed type _DWORD __cdecl sub_804B56D(_DWORD, _DWORD);
// 80560B4: using guessed type int __fastcall sub_80560B4(_DWORD, _DWORD);
// 805C1B0: using guessed type int dword_805C1B0;
// 805C208: using guessed type char *off_805C208[2];
// 805C595: using guessed type char byte_805C595;
// 805C596: using guessed type char byte_805C596;
// 805C6F5: using guessed type int dword_805C6F5;
// 805CBC5: using guessed type int dword_805CBC5;
// 805CBC9: using guessed type int dword_805CBC9;
// 805CBD5: using guessed type int dword_805CBD5;
// 805CBDD: using guessed type int dword_805CBDD;
// 805CBE1: using guessed type int dword_805CBE1;
// 805CBED: using guessed type int dword_805CBED;
// 805CBF5: using guessed type int dword_805CBF5;
// 805CBF9: using guessed type int dword_805CBF9;

//----- (0804CF5C) --------------------------------------------------------
#error "804CF93: call analysis failed (funcsize=266)"

//----- (0804D3BA) --------------------------------------------------------
size_t sub_804D3BA()
{
  size_t result; // eax
  int v1; // [esp+0h] [ebp-28h]
  int i; // [esp+18h] [ebp-10h]
  char *v3; // [esp+1Ch] [ebp-Ch]

  dword_805CBC5 = 0;
  dword_805CBC9 = 0;
  byte_805CBCD = 0;
  dword_805CBE9 = 0;
  dword_805CBED = 0;
  byte_805CBF1 = 0;
  v3 = (char *)ptr;
  for ( i = 0; ; ++i )
  {
    result = nmemb;
    if ( (signed int)nmemb <= i )
      break;
    sub_804BE2D(v3);
    if ( dword_805C599 == 2 )
    {
      sub_804CAB4();
      dword_805C160 = (int)&loc_804D460;
      sub_8056278(v1);
LABEL_8:
      sub_804CCD7();
      goto LABEL_9;
    }
    if ( (unsigned int)dword_805C599 < 2 )
    {
      sub_804CF5C();
      goto LABEL_9;
    }
    if ( dword_805C599 == 3 )
      goto LABEL_8;
LABEL_9:
    v3 += 28;
  }
  return result;
}
// 804BE2D: using guessed type _DWORD __cdecl sub_804BE2D(_DWORD);
// 804CF5C: using guessed type int sub_804CF5C(void);
// 8056278: using guessed type int __stdcall sub_8056278(_DWORD);
// 805C160: using guessed type int dword_805C160;
// 805C599: using guessed type int dword_805C599;
// 805CBC5: using guessed type int dword_805CBC5;
// 805CBC9: using guessed type int dword_805CBC9;
// 805CBCD: using guessed type char byte_805CBCD;
// 805CBED: using guessed type int dword_805CBED;
// 805CBF1: using guessed type char byte_805CBF1;

//----- (0804D474) --------------------------------------------------------
void __cdecl __noreturn sub_804D474(int status)
{
  int v1; // ebx
  char *v2; // eax
  int v3; // esi
  int v4; // ebx
  char *v5; // eax
  FILE *v6; // ebx
  char *v7; // eax
  FILE *v8; // ebx
  char *v9; // eax
  FILE *v10; // ebx
  char *v11; // eax
  FILE *v12; // ebx
  char *v13; // eax
  FILE *v14; // ebx
  char *v15; // eax
  FILE *v16; // ebx
  char *v17; // eax
  FILE *v18; // ebx
  char *v19; // eax
  FILE *v20; // ebx
  char *v21; // eax

  if ( status )
  {
    v1 = dword_805CC05;
    v2 = gettext("Try '%s --help' for more information.\n");
    fprintf(stderr, v2, v1);
  }
  else
  {
    v3 = dword_805CC05;
    v4 = dword_805CC05;
    v5 = gettext("Usage: %s [OPTION]... [INPUT]...   (without -G)\n  or:  %s -G [OPTION]... [INPUT [OUTPUT]]\n");
    printf(v5, v4, v3);
    v6 = stdout;
    v7 = gettext("Output a permuted index, including context, of the words in the input files.\n");
    fputs_unlocked(v7, v6);
    sub_8049FF2();
    sub_804A01D();
    v8 = stdout;
    v9 = gettext(
           "  -A, --auto-reference           output automatically generated references\n"
           "  -G, --traditional              behave more like System V 'ptx'\n");
    fputs_unlocked(v9, v8);
    v10 = stdout;
    v11 = gettext(
            "  -F, --flag-truncation=STRING   use STRING for flagging line truncations.\n"
            "                                 The default is '/'\n");
    fputs_unlocked(v11, v10);
    v12 = stdout;
    v13 = gettext(
            "  -M, --macro-name=STRING        macro name to use instead of 'xx'\n"
            "  -O, --format=roff              generate output as roff directives\n"
            "  -R, --right-side-refs          put references at right, not counted in -w\n"
            "  -S, --sentence-regexp=REGEXP   for end of lines or end of sentences\n"
            "  -T, --format=tex               generate output as TeX directives\n");
    fputs_unlocked(v13, v12);
    v14 = stdout;
    v15 = gettext(
            "  -W, --word-regexp=REGEXP       use REGEXP to match each keyword\n"
            "  -b, --break-file=FILE          word break characters in this FILE\n"
            "  -f, --ignore-case              fold lower case to upper case for sorting\n"
            "  -g, --gap-size=NUMBER          gap size in columns between output fields\n"
            "  -i, --ignore-file=FILE         read ignore word list from FILE\n"
            "  -o, --only-file=FILE           read only word list from this FILE\n");
    fputs_unlocked(v15, v14);
    v16 = stdout;
    v17 = gettext(
            "  -r, --references               first field of each line is a reference\n"
            "  -t, --typeset-mode               - not implemented -\n"
            "  -w, --width=NUMBER             output width in columns, reference excluded\n");
    fputs_unlocked(v17, v16);
    v18 = stdout;
    v19 = gettext("      --help     display this help and exit\n");
    fputs_unlocked(v19, v18);
    v20 = stdout;
    v21 = gettext("      --version  output version information and exit\n");
    fputs_unlocked(v21, v20);
    sub_804A048("ptx");
  }
  exit(status);
}
// 80492B0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 804A048: using guessed type int __cdecl sub_804A048(_DWORD);
// 805CC05: using guessed type int dword_805CC05;

//----- (0804D5E8) --------------------------------------------------------
#error "804D799: call analysis failed (funcsize=544)"

//----- (0804DFF1) --------------------------------------------------------
void __noreturn sub_804DFF1()
{
  sub_804D474(1);
}

//----- (0804E005) --------------------------------------------------------
#error "804E14D: call analysis failed (funcsize=40)"

//----- (0804E15E) --------------------------------------------------------
#error "804E185: call analysis failed (funcsize=38)"

//----- (0804E1F6) --------------------------------------------------------
int __cdecl sub_804E1F6(int a1, int a2, size_t n)
{
  FILE *v3; // ebx
  char *v4; // eax
  const void *v6; // [esp+4h] [ebp-24h]
  void *v7; // [esp+8h] [ebp-20h]
  int i; // [esp+18h] [ebp-10h]
  void *s1; // [esp+1Ch] [ebp-Ch]

  s1 = 0;
  v3 = stderr;
  v4 = gettext("Valid arguments are:");
  fputs_unlocked(v4, v3);
  for ( i = 0; *(_DWORD *)(4 * i + a1); ++i )
  {
    if ( i && (v6 = (const void *)(a2 + i * n), !memcmp(s1, v6, n)) )
    {
      v7 = sub_8050EF9(*(_DWORD *)(4 * i + a1));
      fprintf(stderr, ", %s", v7);
    }
    else
    {
      v7 = sub_8050EF9(*(_DWORD *)(4 * i + a1));
      fprintf(stderr, "\n  - %s", v7);
      s1 = (void *)(i * n + a2);
    }
  }
  return putc_unlocked(10, stderr);
}
// 80492B0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804E31D) --------------------------------------------------------
#error "804E33A: call analysis failed (funcsize=11)"

//----- (0804E33F) --------------------------------------------------------
signed int __cdecl sub_804E33F(int a1, int a2, int a3, int a4, int a5, size_t a6)
{
  char *s; // [esp+0h] [ebp-28h]
  size_t v8; // [esp+Ch] [ebp-1Ch]
  int v9; // [esp+10h] [ebp-18h]
  int v10; // [esp+14h] [ebp-14h]
  size_t n; // [esp+18h] [ebp-10h]
  void (*v12)(void); // [esp+1Ch] [ebp-Ch]

  v8 = a6;
  *(&s - 3) = (char *)sub_804E005((char *)v8, v9, v10, v8);
  if ( (signed int)*(&s - 3) >= 0 )
    return (signed int)*(&s - 3);
  sub_804E15E((int)*(&s - 3), v8, (int)*(&s - 3));
  sub_804E1F6(v9, v10, n);
  v12();
  return -1;
}
// 804E33F: could not find valid save-restore pair for ebp

//----- (0804E462) --------------------------------------------------------
#error "804E48E: call analysis failed (funcsize=77)"

//----- (0804E57A) --------------------------------------------------------
#error "804E59B: positive sp value has been found (funcsize=0)"

//----- (0804E59E) --------------------------------------------------------
signed int __cdecl sub_804E59E(int a1)
{
  int fd; // [esp+1Ch] [ebp-Ch]

  fd = open64("/dev/null", 0);
  if ( fd == a1 )
    return 1;
  if ( fd >= 0 )
  {
    close(fd);
    *__errno_location() = 9;
  }
  return 0;
}
// 8049000: using guessed type int __cdecl open64(_DWORD, _DWORD);

//----- (0804E5ED) --------------------------------------------------------
FILE *__cdecl sub_804E5ED(int a1, int a2, FILE *stream)
{
  int v3; // eax
  char v5; // [esp+19h] [ebp-Fh]
  char v6; // [esp+1Ah] [ebp-Eh]
  char v7; // [esp+1Bh] [ebp-Dh]
  int v8; // [esp+1Ch] [ebp-Ch]
  FILE *streama; // [esp+38h] [ebp+10h]

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v3 = fileno(stream);
  if ( v3 != 1 )
  {
    if ( v3 != 2 )
    {
      if ( !v3 )
        goto LABEL_10;
      if ( dup2(2, 2) != 2 )
        v7 = 1;
    }
    if ( dup2(1, 1) != 1 )
      v6 = 1;
  }
  if ( dup2(0, 0) )
    v5 = 1;
LABEL_10:
  if ( v5 && (unsigned __int8)sub_804E59E(0) ^ 1 )
  {
    streama = 0;
  }
  else if ( v6 && (unsigned __int8)sub_804E59E(1) ^ 1 )
  {
    streama = 0;
  }
  else if ( v7 && (unsigned __int8)sub_804E59E(2) ^ 1 )
  {
    streama = 0;
  }
  else
  {
    streama = (FILE *)freopen64(a1, a2, stream);
  }
  v8 = *__errno_location();
  if ( v7 )
    close(2);
  if ( v6 )
    close(1);
  if ( v5 )
    close(0);
  if ( !streama )
    *__errno_location() = v8;
  return streama;
}
// 8048FD0: using guessed type int __cdecl freopen64(_DWORD, _DWORD, _DWORD);

//----- (0804E747) --------------------------------------------------------
char *__cdecl sub_804E747(char *s)
{
  char *v1; // eax
  char *result; // eax
  char *v3; // [esp+18h] [ebp-10h]
  char *s1; // [esp+1Ch] [ebp-Ch]

  if ( !s )
  {
    fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
    abort();
  }
  v3 = strrchr(s, 47);
  if ( v3 )
    v1 = v3 + 1;
  else
    v1 = s;
  s1 = v1;
  if ( v1 - s > 6 && !strncmp(v1 - 7, "/.libs/", 7u) )
  {
    s = s1;
    if ( !strncmp(s1, "lt-", 3u) )
    {
      s = s1 + 3;
      program_invocation_short_name = (int)(s1 + 3);
    }
  }
  dword_805CC05 = (int)s;
  result = s;
  program_invocation_name = (int)s;
  return result;
}
// 805C280: using guessed type int program_invocation_short_name;
// 805C290: using guessed type int program_invocation_name;
// 805CC05: using guessed type int dword_805CC05;

//----- (0804E820) --------------------------------------------------------
int __usercall sub_804E820@<eax>(int a1@<ebx>, _BYTE *a2, int a3)
{
  _BOOL4 v3; // eax
  _BOOL4 v4; // eax
  _BOOL4 v5; // eax
  _BOOL4 v6; // eax
  void *v7; // eax
  _BOOL4 v8; // eax
  bool v9; // zf
  void *v10; // eax
  int v12; // [esp+0h] [ebp-B8h]
  int v13; // [esp+0h] [ebp-B8h]
  int v14; // [esp+0h] [ebp-B8h]
  int v15; // [esp+4h] [ebp-B4h]
  int v16; // [esp+4h] [ebp-B4h]
  int v17; // [esp+8h] [ebp-B0h]
  int v18; // [esp+8h] [ebp-B0h]
  int v19; // [esp+Ch] [ebp-ACh]
  int v20; // [esp+10h] [ebp-A8h]
  int v21; // [esp+14h] [ebp-A4h]
  int v22; // [esp+18h] [ebp-A0h]
  _BYTE *v23; // [esp+1Ch] [ebp-9Ch]
  int v24; // [esp+20h] [ebp-98h]
  int v25; // [esp+24h] [ebp-94h]
  int v26; // [esp+28h] [ebp-90h]
  int v27; // [esp+2Ch] [ebp-8Ch]
  char *s; // [esp+30h] [ebp-88h]
  _BYTE *v29; // [esp+34h] [ebp-84h]
  _BYTE *v30; // [esp+38h] [ebp-80h]
  char v31; // [esp+3Ch] [ebp-7Ch]
  int v32; // [esp+40h] [ebp-78h]
  int v33; // [esp+44h] [ebp-74h]
  char v34; // [esp+48h] [ebp-70h]
  unsigned int v35; // [esp+4Ch] [ebp-6Ch]
  int v36; // [esp+50h] [ebp-68h]
  int v37; // [esp+54h] [ebp-64h]
  wint_t v38; // [esp+58h] [ebp-60h]
  char *v39; // [esp+5Ch] [ebp-5Ch]
  int v40; // [esp+60h] [ebp-58h]
  int v41; // [esp+64h] [ebp-54h]
  int v42; // [esp+68h] [ebp-50h]
  int v43; // [esp+6Ch] [ebp-4Ch]
  int v44; // [esp+70h] [ebp-48h]
  unsigned int v45; // [esp+74h] [ebp-44h]
  int v46; // [esp+78h] [ebp-40h]
  int v47; // [esp+7Ch] [ebp-3Ch]
  wint_t wc; // [esp+80h] [ebp-38h]
  char *v49; // [esp+84h] [ebp-34h]
  int v50; // [esp+88h] [ebp-30h]
  int v51; // [esp+8Ch] [ebp-2Ch]
  int v52; // [esp+90h] [ebp-28h]
  int v53; // [esp+94h] [ebp-24h]
  int v54; // [esp+98h] [ebp-20h]
  unsigned int v55; // [esp+ACh] [ebp-Ch]

  v23 = a2;
  v22 = a3;
  v55 = __readgsdword(0x14u);
  s = (char *)sub_80512BE(a3);
  HIBYTE(v26) = 0;
  while ( *v23 )
  {
    v29 = sub_805418D(a1, v23, s);
    if ( !v29 )
      break;
    if ( __ctype_get_mb_cur_max() > 1 )
    {
      v35 = (unsigned int)v23;
      v31 = 0;
      memset(&v32, 0, 8u);
      v34 = 0;
      LOBYTE(v27) = 1;
      if ( v35 < (unsigned int)v29 )
      {
        do
        {
          sub_8054A3A((int)&v31);
          v3 = (_BYTE)v37 != 1 || v38;
          if ( !v3 )
            abort();
          v45 = v35;
          v46 = v36;
          v47 = v37;
          wc = v38;
          v49 = v39;
          v50 = v40;
          v51 = v41;
          v52 = v42;
          v53 = v43;
          v54 = v44;
          v35 += v36;
          v34 = 0;
        }
        while ( v35 < (unsigned int)v29 );
        if ( (_BYTE)v47 && iswalnum(wc) )
          LOBYTE(v27) = 0;
      }
      v35 = (unsigned int)v29;
      v31 = 0;
      memset(&v32, 0, 8u);
      v34 = 0;
      v49 = s;
      LOBYTE(v45) = 0;
      memset(&v46, 0, 8u);
      for ( LOBYTE(wc) = 0; ; LOBYTE(wc) = 0 )
      {
        sub_8054A3A((int)&v45);
        v5 = (_BYTE)v51 != 1 || v52;
        if ( !v5 )
          break;
        sub_8054A3A((int)&v31);
        v4 = (_BYTE)v37 != 1 || v38;
        if ( !v4 )
          abort();
        v35 += v36;
        v34 = 0;
        v49 += v50;
      }
      BYTE1(v27) = 1;
      sub_8054A3A((int)&v31);
      v6 = (_BYTE)v37 != 1 || v38;
      if ( v6 )
      {
        v45 = v35;
        v46 = v36;
        v47 = v37;
        wc = v38;
        v49 = v39;
        v50 = v40;
        v51 = v41;
        v52 = v42;
        v53 = v43;
        v54 = v44;
        if ( (_BYTE)v37 )
        {
          if ( iswalnum(wc) )
            BYTE1(v27) = 0;
        }
      }
      v7 = &loc_804EB84;
      if ( !(_BYTE)v27 )
        v7 = &loc_804EB99;
      dword_805C1C4 = (int)v7;
      sub_8056042(
        v13,
        v16,
        v18,
        v19,
        v20,
        v21,
        v22,
        v23,
        v24,
        v25,
        v26,
        v27,
        s,
        v29,
        v30,
        *(_DWORD *)&v31,
        v32,
        v33,
        *(_DWORD *)&v34,
        v35,
        v36,
        v37,
        v38,
        v39,
        v40,
        v41,
        v42);
      if ( BYTE1(v27) )
      {
        HIBYTE(v26) = 1;
        break;
      }
      v35 = (unsigned int)v29;
      v31 = 0;
      memset(&v32, 0, 8u);
      v34 = 0;
      sub_8054A3A((int)&v31);
      v8 = (_BYTE)v37 != 1 || v38;
      if ( !v8 )
        break;
      v23 = &v29[v36];
      dword_805C160 = (int)&loc_804ED29;
      sub_8056278(v14);
    }
    BYTE2(v27) = 1;
    if ( v23 < v29 )
    {
      v9 = ((*__ctype_b_loc())[(unsigned __int8)*(v29 - 1)] & 8) == 0;
      v10 = &loc_804EC87;
      if ( v9 )
        v10 = &loc_804EC8E;
      dword_805C174 = (int)v10;
      sub_8056206(
        v12,
        v15,
        v17,
        v19,
        v20,
        v21,
        v22,
        v23,
        v24,
        v25,
        v26,
        v27,
        s,
        v29,
        v30,
        *(_DWORD *)&v31,
        v32,
        v33,
        *(_DWORD *)&v34,
        v35,
        v36,
        v37,
        v38,
        v39,
        v40,
        v41,
        v42);
      BYTE2(v27) = 0;
    }
    v30 = &v29[strlen(s)];
    HIBYTE(v27) = 1;
    if ( *v30 && (*__ctype_b_loc())[(unsigned __int8)*v30] & 8 )
      HIBYTE(v27) = 0;
    if ( BYTE2(v27) && HIBYTE(v27) )
    {
      HIBYTE(v26) = 1;
      break;
    }
    if ( !*v29 )
      break;
    v23 = v29 + 1;
  }
  free(s);
  return HIBYTE(v26);
}
// 80512BE: using guessed type _DWORD __cdecl sub_80512BE(_DWORD);
// 8056042: using guessed type int __stdcall sub_8056042(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8056206: using guessed type int __stdcall sub_8056206(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8056278: using guessed type int __stdcall sub_8056278(_DWORD);
// 805C160: using guessed type int dword_805C160;
// 805C174: using guessed type int dword_805C174;
// 805C1C4: using guessed type int dword_805C1C4;

//----- (0804EDF1) --------------------------------------------------------
#error "804EFFE: call analysis failed (funcsize=204)"

//----- (0804F13A) --------------------------------------------------------
int __cdecl sub_804F13A(int *a1, unsigned __int8 a2, char a3)
{
  int *v3; // eax
  int *v4; // ST08_4
  int v5; // ST10_4

  if ( a1 )
    v3 = a1;
  else
    v3 = &dword_805CC15;
  v4 = &v3[(a2 >> 5) + 2];
  v5 = ((unsigned int)*v4 >> (a2 & 0x1F)) & 1;
  *v4 ^= (v5 ^ a3 & 1) << (a2 & 0x1F);
  return v5;
}
// 805CC15: using guessed type int dword_805CC15;

//----- (0804F214) --------------------------------------------------------
int *__cdecl sub_804F214(int *a1, int a2, int a3)
{
  int *result; // eax

  if ( !a1 )
    a1 = &dword_805CC15;
  *a1 = 10;
  if ( !a2 || !a3 )
    abort();
  a1[10] = a2;
  result = a1;
  a1[11] = a3;
  return result;
}
// 805CC15: using guessed type int dword_805CC15;

//----- (0804F255) --------------------------------------------------------
_DWORD *__userpurge sub_804F255@<eax>(_DWORD *a1, int a2)
{
  int v3; // [esp+0h] [ebp-38h]
  int v4; // [esp+4h] [ebp-34h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]

  memset(&v3, 0, 0x30u);
  if ( a2 == 10 )
    abort();
  *a1 = a2;
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = v6;
  a1[4] = v7;
  a1[5] = v8;
  a1[6] = v9;
  a1[7] = v10;
  a1[8] = v11;
  a1[9] = v12;
  a1[10] = v13;
  a1[11] = v14;
  return a1;
}

//----- (0804F317) --------------------------------------------------------
char *__cdecl sub_804F317(char *msgid)
{
  char *result; // eax
  unsigned __int8 *v2; // eax
  bool v3; // zf
  void *v4; // eax
  int v5; // [esp+0h] [ebp-28h]
  char *v6; // [esp+18h] [ebp-10h]

  v6 = gettext(msgid);
  if ( v6 != msgid )
    return v6;
  v2 = (unsigned __int8 *)sub_8053247();
  v3 = sub_8052B6A(v2, "UTF-8") == 0;
  v4 = &loc_804F373;
  if ( !v3 )
    v4 = &loc_804F38B;
  dword_805C160 = (int)v4;
  sub_8056278(v5);
  if ( *msgid == 96 )
    result = (char *)&unk_805735E;
  else
    result = (char *)&unk_8057362;
  return result;
}
// 8056278: using guessed type int __stdcall sub_8056278(_DWORD);
// 805C160: using guessed type int dword_805C160;

//----- (0804F3E7) --------------------------------------------------------
#error "804FC66: call analysis failed (funcsize=1125)"

//----- (08050445) --------------------------------------------------------
#error "805048F: call analysis failed (funcsize=26)"

//----- (08050494) --------------------------------------------------------
#error "80504FD: call analysis failed (funcsize=37)"

//----- (08050510) --------------------------------------------------------
#error "80505CB: positive sp value has been found (funcsize=51)"

//----- (08050666) --------------------------------------------------------
#error "8050891: call analysis failed (funcsize=200)"

//----- (08050946) --------------------------------------------------------
void *__cdecl sub_8050946(signed int a1, int a2)
{
  return sub_8050666(a1, a2, -1, &dword_805CC15);
}
// 805CC15: using guessed type int dword_805CC15;

//----- (08050970) --------------------------------------------------------
void *__cdecl sub_8050970(signed int a1, int a2, int a3)
{
  return sub_8050666(a1, a2, a3, &dword_805CC15);
}
// 805CC15: using guessed type int dword_805CC15;

//----- (080509F6) --------------------------------------------------------
void *__cdecl sub_80509F6(signed int a1, int a2, int a3)
{
  char v4; // [esp+10h] [ebp-38h]

  sub_804F255(&v4, a2);
  return sub_8050666(a1, a3, -1, &v4);
}

//----- (08050A34) --------------------------------------------------------
void *__cdecl sub_8050A34(signed int a1, int a2, int a3, int a4)
{
  char v5; // [esp+10h] [ebp-38h]

  sub_804F255(&v5, a2);
  return sub_8050666(a1, a3, a4, &v5);
}

//----- (08050ACC) --------------------------------------------------------
void *__cdecl sub_8050ACC(int a1, int a2, unsigned __int8 a3)
{
  int v4; // [esp+0h] [ebp-58h]
  unsigned __int8 v5; // [esp+1Ch] [ebp-3Ch]
  int v6; // [esp+20h] [ebp-38h]
  int v7; // [esp+24h] [ebp-34h]
  int v8; // [esp+28h] [ebp-30h]
  int v9; // [esp+2Ch] [ebp-2Ch]
  int v10; // [esp+30h] [ebp-28h]
  int v11; // [esp+34h] [ebp-24h]
  int v12; // [esp+38h] [ebp-20h]
  int v13; // [esp+3Ch] [ebp-1Ch]
  int v14; // [esp+40h] [ebp-18h]
  int v15; // [esp+44h] [ebp-14h]
  int v16; // [esp+48h] [ebp-10h]
  int v17; // [esp+4Ch] [ebp-Ch]

  v5 = a3;
  v6 = dword_805CC15;
  v7 = dword_805CC19;
  v8 = dword_805CC1D;
  v9 = dword_805CC21;
  v10 = dword_805CC25;
  v11 = dword_805CC29;
  v12 = dword_805CC2D;
  v13 = dword_805CC31;
  v14 = dword_805CC35;
  v15 = dword_805CC39;
  v16 = dword_805CC3D;
  v17 = dword_805CC41;
  sub_804F13A(&v4 - 14, a3, 1);
  return sub_8050666(0, a1, a2, &v6);
}
// 805CC15: using guessed type int dword_805CC15;
// 805CC19: using guessed type int dword_805CC19;
// 805CC1D: using guessed type int dword_805CC1D;
// 805CC21: using guessed type int dword_805CC21;
// 805CC25: using guessed type int dword_805CC25;
// 805CC29: using guessed type int dword_805CC29;
// 805CC2D: using guessed type int dword_805CC2D;
// 805CC31: using guessed type int dword_805CC31;
// 805CC35: using guessed type int dword_805CC35;
// 805CC39: using guessed type int dword_805CC39;
// 805CC3D: using guessed type int dword_805CC3D;
// 805CC41: using guessed type int dword_805CC41;

//----- (08050B96) --------------------------------------------------------
void *__cdecl sub_8050B96(int a1, unsigned __int8 a2)
{
  return sub_8050ACC(a1, -1, a2);
}

//----- (08050BCF) --------------------------------------------------------
void *__cdecl sub_8050BCF(int a1)
{
  return sub_8050B96(a1, 0x3Au);
}

//----- (08050C0C) --------------------------------------------------------
void *__cdecl sub_8050C0C(signed int a1, int a2, int a3)
{
  int v4; // [esp+0h] [ebp-78h]
  int v5; // [esp+10h] [ebp-68h]
  int v6; // [esp+14h] [ebp-64h]
  int v7; // [esp+18h] [ebp-60h]
  int v8; // [esp+1Ch] [ebp-5Ch]
  int v9; // [esp+20h] [ebp-58h]
  int v10; // [esp+24h] [ebp-54h]
  int v11; // [esp+28h] [ebp-50h]
  int v12; // [esp+2Ch] [ebp-4Ch]
  int v13; // [esp+30h] [ebp-48h]
  int v14; // [esp+34h] [ebp-44h]
  int v15; // [esp+38h] [ebp-40h]
  int v16; // [esp+3Ch] [ebp-3Ch]
  int v17; // [esp+40h] [ebp-38h]
  int v18; // [esp+44h] [ebp-34h]
  int v19; // [esp+48h] [ebp-30h]
  int v20; // [esp+4Ch] [ebp-2Ch]
  int v21; // [esp+50h] [ebp-28h]
  int v22; // [esp+54h] [ebp-24h]
  int v23; // [esp+58h] [ebp-20h]
  int v24; // [esp+5Ch] [ebp-1Ch]
  int v25; // [esp+60h] [ebp-18h]
  int v26; // [esp+64h] [ebp-14h]
  int v27; // [esp+68h] [ebp-10h]
  int v28; // [esp+6Ch] [ebp-Ch]

  sub_804F255(&v5, a2);
  v17 = v5;
  v18 = v6;
  v19 = v7;
  v20 = v8;
  v21 = v9;
  v22 = v10;
  v23 = v11;
  v24 = v12;
  v25 = v13;
  v26 = v14;
  v27 = v15;
  v28 = v16;
  sub_804F13A(&v4 - 14, 0x3Au, 1);
  return sub_8050666(a1, a3, -1, &v17);
}

//----- (08050CCD) --------------------------------------------------------
void *__cdecl sub_8050CCD(int a1, int a2, int a3, int a4)
{
  return sub_8050D1D(-1, a4, -1, a4, -1);
}

//----- (08050D1D) --------------------------------------------------------
void *__cdecl sub_8050D1D(signed int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [esp+0h] [ebp-48h]
  int v7; // [esp+10h] [ebp-38h]
  int v8; // [esp+14h] [ebp-34h]
  int v9; // [esp+18h] [ebp-30h]
  int v10; // [esp+1Ch] [ebp-2Ch]
  int v11; // [esp+20h] [ebp-28h]
  int v12; // [esp+24h] [ebp-24h]
  int v13; // [esp+28h] [ebp-20h]
  int v14; // [esp+2Ch] [ebp-1Ch]
  int v15; // [esp+30h] [ebp-18h]
  int v16; // [esp+34h] [ebp-14h]
  int v17; // [esp+38h] [ebp-10h]
  int v18; // [esp+3Ch] [ebp-Ch]

  v7 = dword_805CC15;
  v8 = dword_805CC19;
  v9 = dword_805CC1D;
  v10 = dword_805CC21;
  v11 = dword_805CC25;
  v12 = dword_805CC29;
  v13 = dword_805CC2D;
  v14 = dword_805CC31;
  v15 = dword_805CC35;
  v16 = dword_805CC39;
  v17 = dword_805CC3D;
  v18 = dword_805CC41;
  sub_804F214(&v6 - 14, a2, a3);
  return sub_8050666(a1, a4, a5, &v7);
}
// 805CC15: using guessed type int dword_805CC15;
// 805CC19: using guessed type int dword_805CC19;
// 805CC1D: using guessed type int dword_805CC1D;
// 805CC21: using guessed type int dword_805CC21;
// 805CC25: using guessed type int dword_805CC25;
// 805CC29: using guessed type int dword_805CC29;
// 805CC2D: using guessed type int dword_805CC2D;
// 805CC31: using guessed type int dword_805CC31;
// 805CC35: using guessed type int dword_805CC35;
// 805CC39: using guessed type int dword_805CC39;
// 805CC3D: using guessed type int dword_805CC3D;
// 805CC41: using guessed type int dword_805CC41;

//----- (08050E7C) --------------------------------------------------------
void *__cdecl sub_8050E7C(signed int a1, int a2, int a3)
{
  return sub_8050666(a1, a2, a3, &unk_805C250);
}

//----- (08050ED7) --------------------------------------------------------
void *__cdecl sub_8050ED7(signed int a1, int a2)
{
  return sub_8050E7C(a1, a2, -1);
}

//----- (08050EF9) --------------------------------------------------------
void *__cdecl sub_8050EF9(int a1)
{
  return sub_8050ED7(0, a1);
}

//----- (08050F14) --------------------------------------------------------
void *__cdecl sub_8050F14(FILE *stream, int a2)
{
  int v2; // eax
  __int64 v3; // rax
  void *result; // eax
  size_t v5; // eax
  bool v6; // zf
  void *v7; // eax
  int v8; // [esp+0h] [ebp-A8h]
  int v9; // [esp+4h] [ebp-A4h]
  int v10; // [esp+8h] [ebp-A0h]
  int v11; // [esp+Ch] [ebp-9Ch]
  void *ptr; // [esp+10h] [ebp-98h]
  void *ptra; // [esp+10h] [ebp-98h]
  size_t size; // [esp+14h] [ebp-94h]
  size_t sizea; // [esp+14h] [ebp-94h]
  size_t v16; // [esp+18h] [ebp-90h]
  unsigned int v17; // [esp+18h] [ebp-90h]
  int v18; // [esp+1Ch] [ebp-8Ch]
  int v19; // [esp+1Ch] [ebp-8Ch]
  size_t v20; // [esp+24h] [ebp-84h]
  int v21; // [esp+28h] [ebp-80h]
  void *v22; // [esp+28h] [ebp-80h]
  int v23; // [esp+2Ch] [ebp-7Ch]
  __int64 v24; // [esp+30h] [ebp-78h]
  __int64 v25; // [esp+38h] [ebp-70h]
  char v26; // [esp+40h] [ebp-68h]
  int v27; // [esp+44h] [ebp-64h]
  int v28; // [esp+48h] [ebp-60h]
  int v29; // [esp+4Ch] [ebp-5Ch]
  int v30; // [esp+50h] [ebp-58h]
  int v31; // [esp+54h] [ebp-54h]
  int v32; // [esp+58h] [ebp-50h]
  int v33; // [esp+5Ch] [ebp-4Ch]
  int v34; // [esp+60h] [ebp-48h]
  int v35; // [esp+64h] [ebp-44h]
  int v36; // [esp+68h] [ebp-40h]
  __int64 v37; // [esp+6Ch] [ebp-3Ch]

  size = 0x2000;
  v2 = fileno(stream);
  if ( sub_8055EE3(v2, (int)&v26) >= 0 && (v30 & 0xF000) == 0x8000 )
  {
    LODWORD(v3) = ftello64(stream);
    v24 = v3;
    if ( v3 >= 0 && v37 > v3 )
    {
      v25 = v37 - v3;
      if ( v37 - v3 > 4294967294LL )
      {
        *__errno_location() = 12;
        return 0;
      }
      size = v25 + 1;
    }
  }
  ptr = malloc(size);
  if ( !ptr )
    return 0;
  v5 = fread(ptr, 1u, size, stream);
  v20 = v5;
  v16 = v5;
  v6 = v5 == size;
  v7 = &loc_80510A2;
  if ( v6 )
    v7 = &loc_8051128;
  dword_805C1C4 = (int)v7;
  sub_8056042(
    v8,
    v9,
    v10,
    v11,
    ptr,
    size,
    v16,
    v18,
    size,
    v20,
    v21,
    v23,
    v24,
    HIDWORD(v24),
    v25,
    HIDWORD(v25),
    *(_DWORD *)&v26,
    v27,
    v28,
    v29,
    v30,
    v31,
    v32,
    v33,
    v34,
    v35,
    v36);
  v19 = *__errno_location();
  if ( ferror(stream) )
  {
    free(ptra);
    *__errno_location() = v19;
    result = 0;
  }
  else
  {
    if ( sizea - 1 > v17 )
    {
      v22 = realloc(ptra, v17 + 1);
      if ( v22 )
        ptra = v22;
    }
    *((_BYTE *)ptra + v17) = 0;
    *(_DWORD *)a2 = v17;
    result = ptra;
  }
  return result;
}
// 8049280: using guessed type int __cdecl ftello64(_DWORD);
// 8056042: using guessed type int __stdcall sub_8056042(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 805C1C4: using guessed type int dword_805C1C4;

//----- (080511F3) --------------------------------------------------------
void *__cdecl sub_80511F3(int a1, int a2, int a3)
{
  int v4; // [esp+14h] [ebp-14h]
  FILE *stream; // [esp+18h] [ebp-10h]
  void *ptr; // [esp+1Ch] [ebp-Ch]

  stream = (FILE *)fopen64(a1, a3);
  if ( !stream )
    return 0;
  ptr = sub_8050F14(stream, a2);
  v4 = *__errno_location();
  if ( !sub_805285B(stream) )
    return ptr;
  if ( ptr )
  {
    v4 = *__errno_location();
    free(ptr);
  }
  *__errno_location() = v4;
  return 0;
}
// 8049160: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (0805127A) --------------------------------------------------------
void *__cdecl sub_805127A(int a1, int a2)
{
  return sub_80511F3(a1, a2, (int)&unk_80576A4);
}

//----- (080512BE) --------------------------------------------------------
#error "80512F4: call analysis failed (funcsize=18)"

//----- (080512F9) --------------------------------------------------------
#error "8051667: positive sp value has been found (funcsize=262)"

//----- (0805166A) --------------------------------------------------------
#error "8051C0C: call analysis failed (funcsize=383)"

//----- (08051DEA) --------------------------------------------------------
#error "8051E54: call analysis failed (funcsize=35)"

//----- (08051E59) --------------------------------------------------------
#error "8051E74: positive sp value has been found (funcsize=0)"

//----- (08051E75) --------------------------------------------------------
#error "8051ECC: call analysis failed (funcsize=27)"

//----- (08051ED1) --------------------------------------------------------
#error "8051EDE: positive sp value has been found (funcsize=0)"

//----- (08051F4A) --------------------------------------------------------
void *__cdecl sub_8051F4A(unsigned int a1, unsigned int a2)
{
  if ( 0x7FFFFFFF / a2 < a1 )
    sub_80521A7();
  return sub_8052057(a2 * a1);
}

//----- (08051FAD) --------------------------------------------------------
void *__cdecl sub_8051FAD(void *ptr, int a2, int a3)
{
  unsigned int v4; // [esp+1Ch] [ebp-Ch]

  v4 = *(_DWORD *)a2;
  if ( ptr )
  {
    if ( 0x55555554u / a3 <= v4 )
      sub_80521A7();
    v4 += (v4 >> 1) + 1;
  }
  else
  {
    if ( !v4 )
      v4 = (0x40u / a3 == 0) + 0x40u / a3;
    if ( 0x7FFFFFFFu / a3 < v4 )
      sub_80521A7();
  }
  *(_DWORD *)a2 = v4;
  return sub_8052081(ptr, a3 * v4);
}

//----- (08052044) --------------------------------------------------------
void *__cdecl sub_8052044(size_t size)
{
  return sub_8052057(size);
}

//----- (08052057) --------------------------------------------------------
void *__cdecl sub_8052057(size_t size)
{
  void *v2; // [esp+1Ch] [ebp-Ch]

  v2 = malloc(size);
  if ( !v2 && size )
    sub_80521A7();
  return v2;
}

//----- (08052081) --------------------------------------------------------
void *__cdecl sub_8052081(void *ptr, size_t size)
{
  void *result; // eax
  void *ptra; // [esp+20h] [ebp+8h]

  if ( size || !ptr )
  {
    ptra = realloc(ptr, size);
    if ( !ptra )
    {
      if ( size )
        sub_80521A7();
    }
    result = ptra;
  }
  else
  {
    free(ptr);
    result = 0;
  }
  return result;
}

//----- (08052159) --------------------------------------------------------
void *__cdecl sub_8052159(void *src, size_t n)
{
  void *v2; // eax

  v2 = sub_8052057(n);
  return memcpy(v2, src, n);
}

//----- (080521A7) --------------------------------------------------------
void __noreturn sub_80521A7()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (08052298) --------------------------------------------------------
int __cdecl sub_8052298(char *s, char *fromcode, char *tocode)
{
  int v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_8055512(s, fromcode, tocode);
  if ( !v4 && *__errno_location() == 12 )
    sub_80521A7();
  return v4;
}

//----- (080522D6) --------------------------------------------------------
signed int __cdecl sub_80522D6(unsigned int *a1, signed int a2)
{
  unsigned int v2; // ebx
  unsigned int v3; // esi
  signed int result; // eax

  v2 = *a1;
  v3 = a1[1];
  if ( (signed __int64)__PAIR__(v3, v2) >= sub_8055C65(0x8000000000000000LL, a2, a2 >> 31) )
  {
    if ( sub_8055C65(0x7FFFFFFFFFFFFFFFLL, a2, a2 >> 31) >= *(_QWORD *)a1 )
    {
      *(_QWORD *)a1 *= a2;
      result = 0;
    }
    else
    {
      *a1 = -1;
      a1[1] = 0x7FFFFFFF;
      result = 1;
    }
  }
  else
  {
    *a1 = 0;
    a1[1] = 2147483648;
    result = 1;
  }
  return result;
}

//----- (080523F0) --------------------------------------------------------
int __cdecl sub_80523F0(unsigned int *a1, signed int a2, int a3)
{
  int v3; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; ; i |= sub_80522D6(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}

//----- (08052426) --------------------------------------------------------
#error "805247C: call analysis failed (funcsize=299)"

//----- (0805285B) --------------------------------------------------------
int __cdecl sub_805285B(FILE *stream)
{
  int v2; // eax
  __int64 v3; // rax
  int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]

  v4 = 0;
  if ( fileno(stream) < 0 )
    return fclose(stream);
  if ( !__freading(stream) || (v2 = fileno(stream), LODWORD(v3) = lseek64(v2, 0, 0, 1), v3 != -1) )
  {
    if ( sub_8052957(stream) )
      v4 = *__errno_location();
  }
  v5 = fclose(stream);
  if ( v4 )
  {
    *__errno_location() = v4;
    v5 = -1;
  }
  return v5;
}
// 8049430: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0805291E) --------------------------------------------------------
int __cdecl sub_805291E(FILE *stream)
{
  int result; // eax

  result = stream->_flags & 0x100;
  if ( result )
    result = sub_8052997(stream, 0, 0, 1);
  return result;
}

//----- (08052957) --------------------------------------------------------
int __cdecl sub_8052957(FILE *fp)
{
  if ( !fp || !__freading(fp) )
    return fflush(fp);
  sub_805291E(fp);
  return fflush(fp);
}

//----- (08052997) --------------------------------------------------------
#error "8052A57: call analysis failed (funcsize=72)"

//----- (08052ADF) --------------------------------------------------------
#error "8052B34: call analysis failed (funcsize=45)"

//----- (08052B6A) --------------------------------------------------------
#error "8052BBF: call analysis failed (funcsize=41)"

//----- (08052BE8) --------------------------------------------------------
#error "8052C41: call analysis failed (funcsize=50)"

//----- (08052C82) --------------------------------------------------------
#error "8052CD3: call analysis failed (funcsize=35)"

//----- (08052CF9) --------------------------------------------------------
#error "8052F79: call analysis failed (funcsize=158)"

//----- (08053247) --------------------------------------------------------
const char *sub_8053247()
{
  char *v0; // ST1C_4
  const char *s1; // [esp+18h] [ebp-10h]
  char *s2; // [esp+1Ch] [ebp-Ch]

  s1 = nl_langinfo(14);
  if ( !s1 )
    s1 = (const char *)&unk_8057C6F;
  for ( s2 = (char *)sub_8052CF9(); *s2; s2 = &v0[strlen(v0) + 1] )
  {
    if ( !strcmp(s1, s2) || *s2 == 42 && !s2[1] )
    {
      s1 = &s2[strlen(s2) + 1];
      break;
    }
    v0 = &s2[strlen(s2) + 1];
  }
  if ( !*s1 )
    s1 = "ASCII";
  return s1;
}

//----- (080532FA) --------------------------------------------------------
#error "8053320: call analysis failed (funcsize=21)"

//----- (0805368B) --------------------------------------------------------
#error "805379C: call analysis failed (funcsize=163)"

//----- (08053925) --------------------------------------------------------
#error "8053946: call analysis failed (funcsize=14)"

//----- (0805394B) --------------------------------------------------------
#error "8053AE7: call analysis failed (funcsize=107)"

//----- (0805418D) --------------------------------------------------------
_BYTE *__usercall sub_805418D@<eax>(int a1@<ebx>, _BYTE *a2, _BYTE *a3)
{
  _BOOL4 v3; // eax
  _BOOL4 v4; // eax
  _BYTE *result; // eax
  _BOOL4 v6; // eax
  int v7; // eax
  int v8; // edx
  int v9; // ecx
  bool v10; // zf
  void *v11; // eax
  void *v12; // eax
  char v13; // al
  char v14; // al
  _BOOL4 v15; // eax
  _BOOL4 v16; // eax
  _BOOL4 v17; // eax
  bool v18; // al
  bool v19; // al
  _BYTE *v20; // eax
  void *v21; // eax
  size_t v22; // eax
  int v23; // [esp-20h] [ebp-180h]
  int v24; // [esp-1Ch] [ebp-17Ch]
  _BYTE *v25; // [esp-18h] [ebp-178h]
  _BYTE *v26; // [esp-14h] [ebp-174h]
  int *v27; // [esp-10h] [ebp-170h]
  int v28; // [esp-Ch] [ebp-16Ch]
  int v29; // [esp-8h] [ebp-168h]
  int v30; // [esp-4h] [ebp-164h]
  _BYTE *v31; // [esp+0h] [ebp-160h]
  _BYTE *v32; // [esp+4h] [ebp-15Ch]
  int v33; // [esp+8h] [ebp-158h]
  int v34; // [esp+Ch] [ebp-154h]
  int v35; // [esp+10h] [ebp-150h]
  unsigned int v36; // [esp+14h] [ebp-14Ch]
  unsigned int v37; // [esp+18h] [ebp-148h]
  unsigned int v38; // [esp+1Ch] [ebp-144h]
  unsigned int j; // [esp+20h] [ebp-140h]
  unsigned int v40; // [esp+24h] [ebp-13Ch]
  unsigned int v41; // [esp+28h] [ebp-138h]
  unsigned int v42; // [esp+2Ch] [ebp-134h]
  _BYTE *v43; // [esp+30h] [ebp-130h]
  _BYTE *v44; // [esp+34h] [ebp-12Ch]
  _BYTE *i; // [esp+38h] [ebp-128h]
  char v46; // [esp+3Ch] [ebp-124h]
  int v47; // [esp+40h] [ebp-120h]
  int v48; // [esp+44h] [ebp-11Ch]
  char v49; // [esp+48h] [ebp-118h]
  void *s2; // [esp+4Ch] [ebp-114h]
  int v51; // [esp+50h] [ebp-110h]
  unsigned __int8 v52; // [esp+54h] [ebp-10Ch]
  int v53; // [esp+58h] [ebp-108h]
  int v54; // [esp+5Ch] [ebp-104h]
  int v55; // [esp+60h] [ebp-100h]
  int v56; // [esp+64h] [ebp-FCh]
  int v57; // [esp+68h] [ebp-F8h]
  int v58; // [esp+6Ch] [ebp-F4h]
  int v59; // [esp+70h] [ebp-F0h]
  char v60; // [esp+74h] [ebp-ECh]
  int v61; // [esp+78h] [ebp-E8h]
  int v62; // [esp+7Ch] [ebp-E4h]
  char v63; // [esp+80h] [ebp-E0h]
  _BYTE *v64; // [esp+84h] [ebp-DCh]
  int v65; // [esp+88h] [ebp-D8h]
  char v66; // [esp+8Ch] [ebp-D4h]
  int v67; // [esp+90h] [ebp-D0h]
  int v68; // [esp+94h] [ebp-CCh]
  int v69; // [esp+98h] [ebp-C8h]
  int v70; // [esp+9Ch] [ebp-C4h]
  int v71; // [esp+A0h] [ebp-C0h]
  int v72; // [esp+A4h] [ebp-BCh]
  int v73; // [esp+A8h] [ebp-B8h]
  int v74; // [esp+ACh] [ebp-B4h]
  int v75; // [esp+B0h] [ebp-B0h]
  int v76; // [esp+B4h] [ebp-ACh]
  int v77; // [esp+B8h] [ebp-A8h]
  void *s1; // [esp+BCh] [ebp-A4h]
  size_t n; // [esp+C0h] [ebp-A0h]
  int v80; // [esp+C4h] [ebp-9Ch]
  int v81; // [esp+C8h] [ebp-98h]
  int v82; // [esp+CCh] [ebp-94h]
  int v83; // [esp+D0h] [ebp-90h]
  int v84; // [esp+D4h] [ebp-8Ch]
  int v85; // [esp+D8h] [ebp-88h]
  int v86; // [esp+DCh] [ebp-84h]
  int v87; // [esp+E0h] [ebp-80h]
  int v88; // [esp+E4h] [ebp-7Ch]
  int v89; // [esp+E8h] [ebp-78h]
  int v90; // [esp+ECh] [ebp-74h]
  int v91; // [esp+F0h] [ebp-70h]
  void *v92; // [esp+F4h] [ebp-6Ch]
  size_t v93; // [esp+F8h] [ebp-68h]
  int v94; // [esp+FCh] [ebp-64h]
  int v95; // [esp+100h] [ebp-60h]
  int v96; // [esp+104h] [ebp-5Ch]
  int v97; // [esp+108h] [ebp-58h]
  int v98; // [esp+10Ch] [ebp-54h]
  int v99; // [esp+110h] [ebp-50h]
  int v100; // [esp+114h] [ebp-4Ch]
  int v101; // [esp+118h] [ebp-48h]
  char v102; // [esp+11Ch] [ebp-44h]
  char k; // [esp+128h] [ebp-38h]
  void *v104; // [esp+12Ch] [ebp-34h]
  int v105; // [esp+130h] [ebp-30h]
  char v106; // [esp+134h] [ebp-2Ch]
  int v107; // [esp+138h] [ebp-28h]
  unsigned int v108; // [esp+154h] [ebp-Ch]

  v32 = a2;
  v31 = a3;
  v108 = __readgsdword(0x14u);
  if ( __ctype_get_mb_cur_max() <= 1 )
  {
    if ( *v31 )
    {
      LOBYTE(v34) = 1;
      v40 = 0;
      v41 = 0;
      v42 = 0;
      v43 = v31;
      v20 = v31++;
      BYTE2(v34) = *v20;
      while ( 1 )
      {
        if ( !*v32 )
          return 0;
        if ( (_BYTE)v34 && v40 > 9 && 5 * v40 <= v41 )
        {
          if ( v43 )
          {
            v26 = (_BYTE *)(v41 - v42);
            v25 = v43;
            v43 += strnlen();
            v10 = *v43 == 0;
            v24 = (unsigned __int8)*v43;
            v23 = a1;
            v21 = &loc_80548E9;
            if ( !v10 )
              v21 = &loc_80548F3;
            dword_805C19C = (int)v21;
            a1 = v23;
            sub_8056120(
              v25,
              v26,
              v27,
              v28,
              v29,
              v30,
              v31,
              v32,
              v33,
              v34,
              v35,
              v36,
              v37,
              v38,
              j,
              v40,
              v41,
              v42,
              v43,
              v44,
              i,
              *(_DWORD *)&v46,
              v47,
              v48,
              *(_DWORD *)&v49,
              s2,
              v51,
              *(_DWORD *)&v52,
              v53,
              v54,
              v55,
              v56,
              v57,
              v58,
              v59,
              *(_DWORD *)&v60,
              v61,
              v62,
              *(_DWORD *)&v63,
              v64,
              v65,
              *(_DWORD *)&v66,
              v67,
              v68,
              v69,
              v70,
              v71,
              v72,
              v73,
              v74,
              v75,
              v76);
            v43 = 0;
            v42 = v41;
          }
          if ( !v43 )
          {
            v22 = strlen(v31 - 1);
            HIBYTE(v34) = sub_805368B(v32, v31 - 1, v22, &v35);
            if ( HIBYTE(v34) )
              return (_BYTE *)v35;
            LOBYTE(v34) = 0;
          }
        }
        ++v40;
        ++v41;
        if ( *v32 == BYTE2(v34) )
          break;
LABEL_95:
        ++v32;
      }
      v44 = v32 + 1;
      for ( i = v31; ; ++i )
      {
        if ( !*i )
        {
          dword_805C160 = (int)&loc_8054A20;
          sub_8056278(v25);
        }
        if ( !*v44 )
          break;
        ++v41;
        if ( *v44 != *i )
          goto LABEL_95;
        ++v44;
      }
      result = 0;
    }
    else
    {
      result = v32;
    }
  }
  else
  {
    s2 = v31;
    v46 = 0;
    memset(&v47, 0, 8u);
    v49 = 0;
    sub_8054A3A((int)&v46);
    v3 = v52 != 1 || v53;
    if ( v3 )
    {
      HIBYTE(v33) = 1;
      v36 = 0;
      v37 = 0;
      v38 = 0;
      v64 = v31;
      v60 = 0;
      memset(&v25 - 58, 0, 8u);
      v63 = 0;
      s1 = v32;
      LOBYTE(v74) = 0;
      memset(&v75, 0, 8u);
      for ( LOBYTE(v77) = 0; ; LOBYTE(v77) = 0 )
      {
        sub_8054A3A((int)&v74);
        v4 = (_BYTE)v80 != 1 || v81;
        if ( !v4 )
          return 0;
        if ( HIBYTE(v33) && v36 > 9 && 5 * v36 <= v37 )
        {
          for ( j = v37 - v38; j; --j )
          {
            sub_8054A3A((int)&v60);
            v6 = v66 != 1 || v67;
            if ( !v6 )
              break;
            v64 += v65;
            v63 = 0;
          }
          v38 = v37;
          sub_8054A3A((int)&v60);
          if ( v66 != 1 || v67 )
          {
            dword_805C160 = (int)&loc_8054451;
            sub_8056278(v25);
          }
          v27 = &v35;
          v26 = v31;
          v25 = v32;
          v7 = sub_8053925();
          BYTE1(v34) = v7;
          v10 = (_BYTE)v7 == 0;
          v24 = v7;
          v23 = a1;
          v11 = &loc_805449F;
          if ( v10 )
            v11 = &loc_80544BC;
          dword_805C1B0 = (int)v11;
          a1 = v23;
          sub_80560B4(v9, v8);
          dword_805C19C = (int)&loc_8054A20;
          sub_8056120(
            v25,
            v26,
            v27,
            v28,
            v29,
            v30,
            v31,
            v32,
            v33,
            v34,
            v35,
            v36,
            v37,
            v38,
            j,
            v40,
            v41,
            v42,
            v43,
            v44,
            i,
            *(_DWORD *)&v46,
            v47,
            v48,
            *(_DWORD *)&v49,
            s2,
            v51,
            *(_DWORD *)&v52,
            v53,
            v54,
            v55,
            v56,
            v57,
            v58,
            v59,
            *(_DWORD *)&v60,
            v61,
            v62,
            *(_DWORD *)&v63,
            v64,
            v65,
            *(_DWORD *)&v66,
            v67,
            v68,
            v69,
            v70,
            v71,
            v72,
            v73,
            v74,
            v75,
            v76);
          HIBYTE(v33) = 0;
        }
        ++v36;
        ++v37;
        if ( (_BYTE)v80 )
        {
          v24 = v52;
          v23 = a1;
          v12 = &loc_8054500;
          if ( !v52 )
            v12 = &loc_8054513;
          dword_805C174 = (int)v12;
          a1 = v23;
          sub_8056206(
            v25,
            v26,
            v27,
            v28,
            v29,
            v30,
            v31,
            v32,
            v33,
            v34,
            v35,
            v36,
            v37,
            v38,
            j,
            v40,
            v41,
            v42,
            v43,
            v44,
            i,
            *(_DWORD *)&v46,
            v47,
            v48,
            *(_DWORD *)&v49,
            s2,
            v51);
          v13 = v81 == v53;
        }
        else
        {
          v14 = n == v51 && !memcmp(s1, s2, n) ? 1 : 0;
          v13 = v14 & 1;
        }
        if ( v13 )
          break;
LABEL_70:
        s1 = (char *)s1 + n;
      }
      v88 = v74;
      v89 = v75;
      v90 = v76;
      v91 = v77;
      v93 = n;
      v94 = v80;
      v95 = v81;
      v96 = v82;
      v97 = v83;
      v98 = v84;
      v99 = v85;
      v100 = v86;
      v101 = v87;
      v92 = (char *)s1 + n;
      LOBYTE(v91) = 0;
      v104 = v31;
      v102 = 0;
      memset(&v25 - 16, 0, 8u);
      k = 0;
      sub_8054A3A((int)&v102);
      v15 = v106 != 1 || v107;
      if ( !v15 )
        abort();
      v104 = (char *)v104 + v105;
      for ( k = 0; ; k = 0 )
      {
        sub_8054A3A((int)&v102);
        v16 = v106 != 1 || v107;
        if ( !v16 )
        {
          dword_805C19C = (int)&loc_80547CE;
          sub_8056120(
            v25,
            v26,
            v27,
            v28,
            v29,
            v30,
            v31,
            v32,
            v33,
            v34,
            v35,
            v36,
            v37,
            v38,
            j,
            v40,
            v41,
            v42,
            v43,
            v44,
            i,
            *(_DWORD *)&v46,
            v47,
            v48,
            *(_DWORD *)&v49,
            s2,
            v51,
            *(_DWORD *)&v52,
            v53,
            v54,
            v55,
            v56,
            v57,
            v58,
            v59,
            *(_DWORD *)&v60,
            v61,
            v62,
            *(_DWORD *)&v63,
            v64,
            v65,
            *(_DWORD *)&v66,
            v67,
            v68,
            v69,
            v70,
            v71,
            v72,
            v73,
            v74,
            v75,
            v76);
        }
        sub_8054A3A((int)&v88);
        v17 = (_BYTE)v94 != 1 || v95;
        if ( !v17 )
          break;
        ++v37;
        if ( (_BYTE)v94 && v106 )
        {
          v18 = v95 != v107;
        }
        else
        {
          v19 = v93 != v105 || memcmp(v92, v104, v93);
          v18 = v19;
        }
        if ( v18 )
          goto LABEL_70;
        v92 = (char *)v92 + v93;
        LOBYTE(v91) = 0;
        v104 = (char *)v104 + v105;
      }
      result = 0;
    }
    else
    {
      result = v32;
    }
  }
  return result;
}
// 80493D0: using guessed type int strnlen(void);
// 805368B: using guessed type _DWORD __cdecl sub_805368B(_DWORD, _DWORD, _DWORD, _DWORD);
// 8053925: using guessed type int sub_8053925(void);
// 80560B4: using guessed type int __fastcall sub_80560B4(_DWORD, _DWORD);
// 8056120: using guessed type int __stdcall sub_8056120(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8056206: using guessed type int __stdcall sub_8056206(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8056278: using guessed type int __stdcall sub_8056278(_DWORD);
// 805C160: using guessed type int dword_805C160;
// 805C174: using guessed type int dword_805C174;
// 805C19C: using guessed type int dword_805C19C;
// 805C1B0: using guessed type int dword_805C1B0;

//----- (08054A3A) --------------------------------------------------------
#error "8054A60: call analysis failed (funcsize=21)"

//----- (08054D2F) --------------------------------------------------------
signed int __cdecl sub_8054D2F(char *a1, size_t a2, void *a3, void **a4, size_t *a5)
{
  size_t v6; // eax
  bool v7; // zf
  void *v8; // eax
  size_t v9; // [esp-24h] [ebp-107Ch]
  int v10; // [esp-20h] [ebp-1078h]
  int v11; // [esp-1Ch] [ebp-1074h]
  int v12; // [esp-18h] [ebp-1070h]
  int v13; // [esp-14h] [ebp-106Ch]
  int v14; // [esp-10h] [ebp-1068h]
  int v15; // [esp-Ch] [ebp-1064h]
  int v16; // [esp-8h] [ebp-1060h]
  int v17; // [esp-4h] [ebp-105Ch]
  size_t *v18; // [esp+0h] [ebp-1058h]
  void **v19; // [esp+4h] [ebp-1054h]
  iconv_t cd; // [esp+8h] [ebp-1050h]
  char *v21; // [esp+Ch] [ebp-104Ch]
  int v22; // [esp+10h] [ebp-1048h]
  int v23; // [esp+14h] [ebp-1044h]
  int v24; // [esp+18h] [ebp-1040h]
  char *inbuf; // [esp+1Ch] [ebp-103Ch]
  size_t inbytesleft; // [esp+20h] [ebp-1038h]
  char *outbuf; // [esp+24h] [ebp-1034h]
  size_t outbytesleft; // [esp+28h] [ebp-1030h]
  void *ptr; // [esp+2Ch] [ebp-102Ch]
  size_t v30; // [esp+30h] [ebp-1028h]
  size_t v31; // [esp+34h] [ebp-1024h]
  size_t v32; // [esp+38h] [ebp-1020h]
  size_t size; // [esp+3Ch] [ebp-101Ch]
  size_t v34; // [esp+40h] [ebp-1018h]
  size_t v35; // [esp+44h] [ebp-1014h]
  int v36; // [esp+48h] [ebp-1010h]
  char v37; // [esp+4Ch] [ebp-100Ch]
  unsigned int v38; // [esp+104Ch] [ebp-Ch]

  v21 = a1;
  cd = a3;
  v19 = a4;
  v18 = a5;
  v38 = __readgsdword(0x14u);
  iconv(a3, 0, 0, 0, 0);
  v30 = 0;
  inbuf = a1;
  inbytesleft = a2;
  while ( inbytesleft )
  {
    outbuf = &v37;
    outbytesleft = 4096;
    v31 = iconv(cd, (char **)&v10 - 1039, (size_t *)&v10 - 1038, (char **)&v10 - 1037, (size_t *)&v10 - 1036);
    if ( v31 == -1 && *__errno_location() != 7 )
    {
      if ( *__errno_location() != 22 )
        return -1;
      break;
    }
    v30 += outbuf - &v37;
  }
  outbuf = &v37;
  outbytesleft = 4096;
  v32 = iconv(cd, 0, 0, &outbuf, &outbytesleft);
  if ( v32 == -1 )
    return -1;
  v30 += outbuf - &v37;
  size = v30;
  if ( !v30 )
  {
    *v18 = 0;
    return 0;
  }
  if ( *v19 && *v18 >= size )
  {
    ptr = *v19;
  }
  else
  {
    ptr = malloc(size);
    if ( !ptr )
    {
      *__errno_location() = 12;
      return -1;
    }
  }
  iconv(cd, 0, 0, 0, 0);
  inbuf = v21;
  inbytesleft = a2;
  outbuf = (char *)ptr;
  outbytesleft = size;
  while ( inbytesleft )
  {
    v34 = iconv(cd, (char **)&v10 - 1039, &inbytesleft, &outbuf, &outbytesleft);
    if ( v34 == -1 )
    {
      if ( *__errno_location() != 22 )
        goto LABEL_25;
      break;
    }
  }
  v6 = iconv(cd, 0, 0, &outbuf, &outbytesleft);
  v35 = v6;
  v7 = v6 == -1;
  v9 = v6;
  v8 = &loc_80550D7;
  if ( !v7 )
    v8 = &loc_80550D9;
  dword_805C174 = (int)v8;
  sub_8056206(
    v10,
    v11,
    v12,
    v13,
    v14,
    v15,
    v16,
    v17,
    v18,
    v19,
    cd,
    v21,
    v22,
    v23,
    v24,
    inbuf,
    inbytesleft,
    outbuf,
    outbytesleft,
    ptr,
    v30,
    v31,
    v32,
    size,
    v34,
    v35,
    v36);
LABEL_25:
  if ( *v19 != ptr )
  {
    v36 = *__errno_location();
    free(ptr);
    *__errno_location() = v36;
  }
  return -1;
}
// 8056206: using guessed type int __stdcall sub_8056206(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 805C174: using guessed type int dword_805C174;

//----- (08055174) --------------------------------------------------------
#error "80553F7: call analysis failed (funcsize=241)"

//----- (08055512) --------------------------------------------------------
#error "805558D: call analysis failed (funcsize=76)"

//----- (0805560C) --------------------------------------------------------
size_t __cdecl sub_805560C(void *s, size_t n)
{
  size_t result; // eax
  _BYTE *v3; // [esp+1Ch] [ebp-Ch]

  v3 = memchr(s, 0, n);
  if ( v3 )
    result = v3 - (_BYTE *)s + 1;
  else
    result = n;
  return result;
}

//----- (08055895) --------------------------------------------------------
int __cdecl sub_8055895(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 65) > 0x19 )
    result = a1;
  else
    result = a1 + 32;
  return result;
}

//----- (080558CB) --------------------------------------------------------
unsigned int __cdecl sub_80558CB(unsigned int a1)
{
  _DWORD *v1; // ST18_4
  unsigned int v2; // ST14_4
  _DWORD *v4; // [esp+14h] [ebp-14h]

  if ( a1 + 8 < a1 )
    return 0;
  v4 = malloc(a1 + 8);
  if ( !v4 )
    return 0;
  v1 = v4;
  v2 = (unsigned int)(v4 + 2);
  v1[1] = 336984906;
  *v1 = dword_805CD75[v2 % 0x101];
  dword_805CD75[v2 % 0x101] = v2;
  return v2;
}

//----- (08055980) --------------------------------------------------------
#error "8055A34: call analysis failed (funcsize=69)"

//----- (08055A8D) --------------------------------------------------------
int __cdecl sub_8055A8D(int a1, int a2)
{
  int result; // eax

  if ( *(_DWORD *)a2 == a2 + 16 )
  {
    memcpy((void *)(a1 + 16), (const void *)(a2 + 16), *(_DWORD *)(a2 + 4));
    *(_DWORD *)a1 = a1 + 16;
  }
  else
  {
    *(_DWORD *)a1 = *(_DWORD *)a2;
  }
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  *(_BYTE *)(a1 + 8) = *(_BYTE *)(a2 + 8);
  result = *(unsigned __int8 *)(a1 + 8);
  if ( (_BYTE)result )
  {
    result = a1;
    *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
  }
  return result;
}

//----- (08055B1D) --------------------------------------------------------
bool __cdecl sub_8055B1D(unsigned __int8 a1)
{
  return (((unsigned int)dword_8057E30[a1 >> 5] >> (a1 & 0x1F)) & 1) != 0;
}

//----- (08055B74) --------------------------------------------------------
#error "8055BDA: call analysis failed (funcsize=65)"

//----- (08055C65) --------------------------------------------------------
signed __int64 __cdecl sub_8055C65(__int64 a1, unsigned int a2, signed int a3)
{
  int v3; // edx
  unsigned int v4; // ecx
  unsigned int v5; // esi
  unsigned int v6; // edi
  unsigned int v7; // ebp
  unsigned int v8; // eax
  int v9; // ecx
  unsigned int v10; // edx
  int v11; // ebp
  int v12; // ecx
  signed __int64 result; // rax
  int v14; // edx
  int v15; // edi
  unsigned __int64 v16; // rtt
  int v17; // esi
  unsigned __int64 v18; // rax
  int v19; // [esp+0h] [ebp-1Ch]
  unsigned int v20; // [esp+4h] [ebp-18h]
  unsigned int v21; // [esp+8h] [ebp-14h]
  unsigned int v22; // [esp+Ch] [ebp-10h]

  v3 = a1;
  v19 = 0;
  v20 = a2;
  v4 = HIDWORD(a1);
  if ( a1 < 0 )
  {
    v3 = -(signed int)a1;
    v5 = v20;
    v6 = a3;
    v4 = (unsigned __int64)-a1 >> 32;
    v19 = -1;
    if ( a3 >= 0 )
      goto LABEL_3;
  }
  else
  {
    v5 = v20;
    v6 = a3;
    if ( a3 >= 0 )
      goto LABEL_3;
  }
  v5 = -v5;
  v19 = ~v19;
  v6 = (unsigned __int64)-(signed __int64)__PAIR__(v6, v5) >> 32;
LABEL_3:
  v7 = v4;
  v21 = v3;
  v8 = v6;
  v9 = v3;
  v20 = v5;
  if ( v6 )
  {
    if ( v6 <= v7 )
    {
      _BitScanReverse(&v6, v6);
      v15 = v6 ^ 0x1F;
      if ( v15 )
      {
        v22 = v20 >> (32 - v15);
        v22 |= v8 << v15;
        v20 <<= v15;
        LODWORD(v16) = ((_DWORD)&v19 << v15) | (v21 >> (32 - v15));
        HIDWORD(v16) = (unsigned int)&v19 >> (32 - v15);
        v17 = v16 / v22;
        v18 = v20 * (unsigned __int64)(unsigned int)v17;
        v20 = HIDWORD(v18);
        if ( v16 % v22 < HIDWORD(v18) || v21 << v15 < (unsigned int)v18 && &v19 == (int *)v20 )
        {
          v12 = v17 - 1;
          v11 = 0;
        }
        else
        {
          v12 = v17;
          v11 = 0;
        }
        goto LABEL_8;
      }
      if ( v20 <= v21 || v8 < v7 )
      {
        v11 = 0;
        v12 = 1;
        goto LABEL_8;
      }
    }
    v11 = 0;
    v12 = 0;
    goto LABEL_8;
  }
  if ( v5 <= v7 )
  {
    if ( !v5 )
      v5 = 1 / 0u;
    v14 = v7 % v5;
    v11 = v7 / v5;
    v12 = __PAIR__((unsigned int)v14, v9) / v5;
  }
  else
  {
    v10 = v7;
    v11 = 0;
    v12 = __PAIR__(v10, v9) / v5;
  }
LABEL_8:
  result = __PAIR__(v11, v12);
  if ( v19 )
    result = -__PAIR__(v11, v12);
  return result;
}

//----- (08055E65) --------------------------------------------------------
#error "8055E9E: positive sp value has been found (funcsize=18)"

//----- (08055EB4) --------------------------------------------------------
int __cdecl sub_8055EB4(int a1)
{
  return __cxa_atexit(a1, 0, dword_805C1F4);
}
// 80491F0: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 805C1F4: using guessed type int dword_805C1F4;

//----- (08055EE3) --------------------------------------------------------
int __cdecl sub_8055EE3(int a1, int a2)
{
  return __fxstat64(3, a1, a2);
}
// 8049190: using guessed type int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD);

//----- (08056042) --------------------------------------------------------
#error "8056048: positive sp value has been found (funcsize=0)"

//----- (080560B4) --------------------------------------------------------
#error "80560BA: positive sp value has been found (funcsize=0)"

//----- (08056120) --------------------------------------------------------
#error "8056126: positive sp value has been found (funcsize=0)"

//----- (08056198) --------------------------------------------------------
#error "805619E: positive sp value has been found (funcsize=0)"

//----- (08056206) --------------------------------------------------------
#error "805620C: positive sp value has been found (funcsize=0)"

//----- (08056278) --------------------------------------------------------
#error "805627E: positive sp value has been found (funcsize=0)"

//----- (08056290) --------------------------------------------------------
int (**sub_8056290())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_805BEE4;
  v1 = &off_805BEE8 - off_805BEE4;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_805BEE4[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 805BEE4: using guessed type int (*off_805BEE4[2])();
// 805BEE8: using guessed type int (*off_805BEE8)();

//----- (080562F4) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 55 decompilation failure(s) on 156 function(s)"
