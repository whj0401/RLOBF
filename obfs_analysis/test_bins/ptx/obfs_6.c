/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8048FC0();
// int __cdecl freopen64(_DWORD, _DWORD, _DWORD); weak
// int dup2(int fd, int fd2);
// int strcmp(const char *s1, const char *s2);
// int __cdecl open64(_DWORD, _DWORD); weak
// int putc_unlocked(int c, FILE *stream);
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void _exit(int status);
// void *memmove(void *dest, const void *src, size_t n);
// void free(void *ptr);
// char *strdup(const char *s);
// void *memcpy(void *dest, const void *src, size_t n);
// int mbsinit(const mbstate_t *ps);
// int ferror(FILE *stream);
// int fclose(FILE *stream);
// int getc_unlocked(FILE *stream);
// intmax_t strtoimax(const char *nptr, char **endptr, int base);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// int __cdecl fopen64(_DWORD, _DWORD); weak
// int ferror_unlocked(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD); weak
// size_t __ctype_get_mb_cur_max(void);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// size_t __fpending(FILE *fp);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// void error(int status, int errnum, const char *format, ...);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int re_match(struct re_pattern_buffer *buffer, const char *string, int length, int start, struct re_registers *regs);
// int __freading(FILE *fp);
// int iswspace(wint_t wc);
// void exit(int status);
// int __cdecl ftello64(_DWORD); weak
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// char *strchr(const char *s, int c);
// size_t strlen(const char *s);
// size_t iconv(iconv_t cd, char **inbuf, size_t *inbytesleft, char **outbuf, size_t *outbytesleft);
// int iconv_close(iconv_t cd);
// int fprintf(FILE *stream, const char *format, ...);
// int re_search(struct re_pattern_buffer *buffer, const char *string, int length, int start, int range, struct re_registers *regs);
// int re_compile_fastmap(struct re_pattern_buffer *buffer);
// void *memset(void *s, int c, size_t n);
// int iswalnum(wint_t wc);
// int *__errno_location(void);
// void *memchr(const void *s, int c, size_t n);
// int fileno(FILE *stream);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// int __cdecl strnlen(_DWORD, _DWORD); weak
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// int toupper(int c);
// char *strrchr(const char *s, int c);
// int sprintf(char *s, const char *format, ...);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// const char *re_compile_pattern(const char *pattern, size_t length, struct re_pattern_buffer *buffer);
// int strncmp(const char *s1, const char *s2, size_t n);
// void abort(void);
// iconv_t iconv_open(const char *tocode, const char *fromcode);
// int close(int fd);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// int putchar_unlocked(int c);
// int _gmon_start__(void); weak
void sub_8049533();
void sub_8049550();
int sub_8049560();
int sub_80495D0();
int sub_80495F0();
void sub_804964F();
void sub_804966A();
signed int sub_804967A();
// int __usercall sub_804972C@<eax>(void (__cdecl *a1)(signed int)@<eax>);
void sub_8049778();
void sub_8049793();
int sub_80497A3();
void sub_8049885();
void sub_80498A0();
int sub_80498B0();
void sub_8049992();
void sub_80499AD();
signed int sub_80499BD();
void sub_8049A9F();
void sub_8049ABA();
int sub_8049ACA();
void sub_8049BAC();
void sub_8049BC7();
int sub_8049BD7();
void sub_8049CB9();
void sub_8049CD4();
int sub_8049CE4();
void sub_8049DC6();
void sub_8049DE1();
int sub_8049DF1();
void sub_8049EFE();
void sub_8049F19();
int sub_8049F29();
void sub_804A00B();
void sub_804A026();
int sub_804A036();
int __cdecl sub_804A0E6(unsigned __int8 a1);
int sub_804A0F8();
int sub_804A123();
int __cdecl sub_804A14E(const char *s1);
char *__cdecl sub_804A2F4(char *a1);
char *__cdecl sub_804A324(char *s);
int __cdecl sub_804A6D6(int a1);
char *sub_804A7C1();
int __cdecl sub_804A974(char *s1, int); // idb
int sub_804AA59(const void *, const void *); // idb
int compar(const void *, const void *); // idb
int __cdecl sub_804AC39(void *, int); // idb
void sub_804ACE3();
void __cdecl sub_804AD1C(char *s1);
int __cdecl sub_804ADAF(char *s1, int); // idb
int __cdecl sub_804B6EE(int a1);
// unsigned int __usercall sub_804B714@<eax>(int a1@<edx>, int a2@<ecx>, char *a3, unsigned int a4);
_DWORD __cdecl sub_804BF5E(_DWORD); // weak
int __cdecl sub_804C024(char *string, int length, int start, struct re_registers *regs); // idb
int __cdecl sub_804C5B2(char *string, int length, int start, struct re_registers *regs); // idb
int sub_804CBE9();
int sub_804CE0C();
int sub_804D08D(void); // weak
size_t sub_804D588();
void __cdecl __noreturn sub_804D652(int status); // idb
// void __usercall __noreturn main(int a1@<edx>, int a2@<ecx>, int argc, char **argv);
void __noreturn sub_804E1CC();
int __cdecl sub_804E1E0(char *s, int, int, size_t); // idb
void __cdecl sub_804E30B(int a1, int a2, int a3);
int __cdecl sub_804E38E(int, int, size_t n); // idb
int __cdecl sub_804E531(int, size_t n); // idb
int sub_804E63A();
signed int __cdecl sub_804E733(int a1);
int __cdecl sub_804E782(int, int, FILE *stream); // idb
void __fastcall __noreturn sub_804E940(int a1, int a2, int a3);
int __cdecl sub_804E98F(int c, size_t n); // idb
int __cdecl sub_804EA4B(_BYTE *a1, char *a2);
char *__cdecl sub_804F042(char *msgid, char *a2);
int __cdecl sub_804F3C0(int *a1, unsigned __int8 a2, char a3);
int *__cdecl sub_804F49A(int *a1, int a2, int a3);
int __cdecl sub_804F4DB(_DWORD, _DWORD); // weak
const char *__cdecl sub_804F5C2(char *msgid, int a2);
// int __usercall sub_804F65D@<eax>(char *a1@<ebx>, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, char *a10);
void *__cdecl sub_8050805(signed int a1, int a2, int a3, int a4);
void *__cdecl sub_8050AD8(signed int a1, int a2);
void *__cdecl sub_8050B02(signed int a1, int a2, int a3);
void *__cdecl sub_8050B78(signed int a1, int a2, int a3);
void *__cdecl sub_8050BB6(signed int a1, int a2, int a3, int a4);
_DWORD __cdecl sub_8050C4E(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_8050D3D(int a1, char a2);
int __cdecl sub_8050D76(int a1);
_DWORD __cdecl sub_8050DB3(_DWORD, _DWORD); // weak
void *__cdecl sub_8050E89(signed int a1, int a2, int a3, int a4);
void *__cdecl sub_8050EC9(signed int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_805101D(char *s, iconv_t cd); // idb
void *__cdecl sub_8051407(signed int a1, int a2);
void *__cdecl sub_8051429(int a1);
char *__cdecl sub_8051444(FILE *stream, int a2);
char *__cdecl sub_8051713(int a1, int a2, int a3);
char *__cdecl sub_805179A(int a1, int a2);
char *__cdecl sub_80517DE(char *a1, int a2);
int __cdecl sub_8051B61(FILE *stream, int, int, int, int, int); // idb
int __cdecl sub_805228B(FILE *stream, int, int, int, int); // idb
int sub_8052316(FILE *stream, int a2, int a3, int a4, ...);
void *__cdecl sub_80523D6(unsigned int a1, unsigned int a2);
int __cdecl sub_8052439(void *ptr, int, int); // idb
void *__cdecl sub_80524E9(size_t size);
void *__cdecl sub_80524FC(size_t size);
void *__cdecl sub_805253F(void *ptr, size_t size);
void *__cdecl sub_8052617(void *src, size_t n);
void __noreturn sub_8052665();
char *__cdecl sub_8052741(char *s, char *fromcode, char *tocode);
signed int __cdecl sub_805277F(unsigned int *a1, int a2);
int __cdecl sub_8052899(unsigned int *a1, int a2, int a3);
// int __usercall sub_80528CF@<eax>(int a1@<edx>, int a2@<ecx>, char *nptr, int a4, int base, int a6, char *s);
int __cdecl sub_8052CF6(FILE *stream); // idb
int __cdecl sub_8052DD2(FILE *stream); // idb
int __cdecl sub_8052E0B(FILE *fp); // idb
int __cdecl sub_8052E4B(FILE *stream, int, int, int); // idb
size_t __cdecl sub_8052F6A(wchar_t *pwc, char *s, size_t n, mbstate_t *p);
int __cdecl sub_8052FDC(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_8053056(FILE *fp); // idb
int __cdecl sub_80530D7(int category); // idb
void *sub_8053135();
char *sub_8053699();
int __cdecl sub_805377A(int a1);
_DWORD __cdecl sub_8053AE2(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl sub_8053D4A(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl sub_8054553(_DWORD, _DWORD); // weak
int __cdecl sub_8054DE8(int a1);
int __cdecl sub_80550FC(size_t *); // idb
void *__cdecl sub_8055533(signed int a1, int a2, int a3);
char *__cdecl sub_8055593(char *s, char *fromcode, char *tocode);
size_t __cdecl sub_8055678(void *s, size_t n);
int __cdecl sub_80558BA(int a1);
_DWORD __cdecl sub_80558F0(_DWORD); // weak
_DWORD __cdecl sub_8055A0D(_DWORD); // weak
int __cdecl sub_8055B2F(int a1, int a2);
bool __cdecl sub_8055BD8(unsigned __int8 a1);
size_t __cdecl sub_8055C2F(const char *a1);
_DWORD __cdecl sub_8055CF2(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_8055F4D(int a1);
int __cdecl sub_8055F7C(int a1, int a2);
int __fastcall sub_805612D(_DWORD, _DWORD, _DWORD);
int __fastcall sub_80561A1(_DWORD, _DWORD); // weak
int __fastcall sub_8056234(_DWORD, _DWORD);
int __stdcall sub_80562A4(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int sub_805631A(void); // weak
int sub_8056386(void); // weak
int (**sub_80563A0())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN locret_8049E00; // weak
_UNKNOWN loc_804A3DA; // weak
_UNKNOWN loc_804A3F1; // weak
_UNKNOWN loc_804A6A0; // weak
_UNKNOWN loc_804A7EB; // weak
_UNKNOWN loc_804A817; // weak
_UNKNOWN loc_804A85C; // weak
_UNKNOWN loc_804A876; // weak
_UNKNOWN loc_804A8D0; // weak
_UNKNOWN loc_804B783; // weak
_UNKNOWN loc_804BA7D; // weak
_UNKNOWN loc_804BA82; // weak
_UNKNOWN loc_804BB6D; // weak
_UNKNOWN loc_804BB84; // weak
_UNKNOWN loc_804CD66; // weak
_UNKNOWN loc_804CD7D; // weak
_UNKNOWN loc_804CF9D; // weak
_UNKNOWN loc_804D63E; // weak
_UNKNOWN loc_804E702; // weak
_UNKNOWN loc_804E965; // weak
_UNKNOWN loc_804EB7E; // weak
_UNKNOWN loc_804EB83; // weak
_UNKNOWN loc_804ECD1; // weak
_UNKNOWN loc_804ECD6; // weak
_UNKNOWN loc_804F0AB; // weak
_UNKNOWN loc_804F188; // weak
_UNKNOWN loc_804F1C2; // weak
_UNKNOWN loc_804F22A; // weak
_UNKNOWN loc_804F249; // weak
_UNKNOWN loc_804F25F; // weak
_UNKNOWN loc_804F289; // weak
_UNKNOWN loc_804F7E6; // weak
_UNKNOWN loc_804F818; // weak
_UNKNOWN loc_804F861; // weak
_UNKNOWN loc_804F865; // weak
_UNKNOWN loc_804F8BE; // weak
_UNKNOWN loc_804F8F5; // weak
_UNKNOWN loc_804F961; // weak
_UNKNOWN loc_804FB4A; // weak
_UNKNOWN loc_804FB4F; // weak
_UNKNOWN loc_804FC20; // weak
_UNKNOWN loc_804FC30; // weak
_UNKNOWN loc_804FCFD; // weak
_UNKNOWN loc_804FD02; // weak
_UNKNOWN loc_804FE7D; // weak
_UNKNOWN loc_804FE82; // weak
_UNKNOWN loc_804FF90; // weak
_UNKNOWN loc_804FFAF; // weak
_UNKNOWN loc_804FFDD; // weak
_UNKNOWN loc_804FFE2; // weak
_UNKNOWN loc_80500C2; // weak
_UNKNOWN loc_8050179; // weak
_UNKNOWN loc_80503DE; // weak
_UNKNOWN loc_80503F0; // weak
_UNKNOWN loc_8050438; // weak
_UNKNOWN loc_805045A; // weak
_UNKNOWN loc_805084C; // weak
_UNKNOWN loc_805089A; // weak
_UNKNOWN loc_8050930; // weak
_UNKNOWN loc_80514F9; // weak
_UNKNOWN loc_80514FF; // weak
_UNKNOWN loc_80516F1; // weak
_UNKNOWN loc_8051948; // weak
_UNKNOWN loc_80519AD; // weak
_UNKNOWN loc_80519AF; // weak
_UNKNOWN loc_8051A44; // weak
_UNKNOWN loc_8051B47; // weak
_UNKNOWN loc_80522B3; // weak
_UNKNOWN loc_805252F; // weak
_UNKNOWN loc_805253A; // weak
_UNKNOWN loc_8052901; // weak
_UNKNOWN loc_8052920; // weak
_UNKNOWN loc_8052922; // weak
_UNKNOWN loc_805294B; // weak
_UNKNOWN loc_80529A4; // weak
_UNKNOWN loc_80529DE; // weak
_UNKNOWN loc_8052C9E; // weak
_UNKNOWN loc_8052D56; // weak
_UNKNOWN loc_8052D8F; // weak
_UNKNOWN locret_8052F68; // weak
_UNKNOWN loc_8053043; // weak
_UNKNOWN loc_8053266; // weak
_UNKNOWN loc_80532E7; // weak
_UNKNOWN loc_80533FB; // weak
_UNKNOWN loc_8053443; // weak
_UNKNOWN loc_8053448; // weak
_UNKNOWN loc_805344D; // weak
_UNKNOWN loc_80536CD; // weak
_UNKNOWN loc_80536D4; // weak
_UNKNOWN loc_805375A; // weak
_UNKNOWN loc_80539B3; // weak
_UNKNOWN loc_8054FB7; // weak
_UNKNOWN loc_8054FDB; // weak
_UNKNOWN loc_805500D; // weak
_UNKNOWN loc_8055013; // weak
_UNKNOWN loc_8055BCA; // weak
_UNKNOWN locret_8055BD6; // weak
char locale = '\0'; // idb
char byte_8057128[256] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'A',
  'B',
  'C',
  'D',
  'E',
  'F',
  'G',
  'H',
  'I',
  'J',
  'K',
  'L',
  'M',
  'N',
  'O',
  'P',
  'Q',
  'R',
  'S',
  'T',
  'U',
  'V',
  'W',
  'X',
  'Y',
  'Z',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'a',
  'b',
  'c',
  'd',
  'e',
  'f',
  'g',
  'h',
  'i',
  'j',
  'k',
  'l',
  'm',
  'n',
  'o',
  'p',
  'q',
  'r',
  's',
  't',
  'u',
  'v',
  'w',
  'x',
  'y',
  'z',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'A',
  'A',
  'A',
  'A',
  'A',
  'A',
  'A',
  'C',
  'E',
  'E',
  'E',
  'E',
  'I',
  'I',
  'I',
  'I',
  '\0',
  'N',
  'O',
  'O',
  'O',
  'O',
  'O',
  '\0',
  'O',
  'U',
  'U',
  'U',
  'U',
  'Y',
  '\0',
  '\0',
  'a',
  'a',
  'a',
  'a',
  'a',
  'a',
  'a',
  'c',
  'e',
  'e',
  'e',
  'e',
  'i',
  'i',
  'i',
  'i',
  '\0',
  'n',
  'o',
  'o',
  'o',
  'o',
  'o',
  '\0',
  'o',
  'u',
  'u',
  'u',
  'u',
  'y',
  '\0',
  'y'
}; // idb
char byte_8057228[256] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x04',
  '\0',
  '\x03',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x06',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x03',
  '\x02',
  '\x04',
  '\x06',
  '\x05',
  '\b',
  '\x01',
  '\a',
  '\x03',
  '\x02',
  '\x04',
  '\x05',
  '\x03',
  '\x02',
  '\x04',
  '\x05',
  '\0',
  '\x06',
  '\x03',
  '\x02',
  '\x04',
  '\x06',
  '\x05',
  '\0',
  '\t',
  '\x03',
  '\x02',
  '\x04',
  '\x05',
  '\x02',
  '\0',
  '\0',
  '\x03',
  '\x02',
  '\x04',
  '\x06',
  '\x05',
  '\b',
  '\x01',
  '\a',
  '\x03',
  '\x02',
  '\x04',
  '\x05',
  '\x03',
  '\x02',
  '\x04',
  '\x05',
  '\0',
  '\x06',
  '\x03',
  '\x02',
  '\x04',
  '\x06',
  '\x05',
  '\0',
  '\t',
  '\x03',
  '\x02',
  '\x04',
  '\x05',
  '\x02',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_8057476; // weak
_UNKNOWN unk_805747A; // weak
_UNKNOWN unk_8057486; // weak
_UNKNOWN unk_805748A; // weak
_UNKNOWN unk_805748D; // weak
_UNKNOWN unk_80577BC; // weak
_UNKNOWN unk_8057D87; // weak
int dword_8057F48[8] = { 6656, 4294967279, 4294967294, 2147483646, 0, 0, 0, 0 }; // idb
_UNKNOWN unk_80581F0; // weak
_UNKNOWN unk_80581F3; // weak
_UNKNOWN unk_80591FC; // weak
_UNKNOWN unk_80591FF; // weak
int (*off_805BEE0[2])() = { &sub_80495F0, &sub_80495D0 }; // weak
int (*off_805BEE4)() = &sub_80495D0; // weak
int (*dword_805C008)(void) = NULL; // weak
int dword_805C160 = 0; // weak
int dword_805C174 = 0; // weak
int dword_805C188 = 0; // weak
int dword_805C19C = 0; // weak
int dword_805C1B0 = 0; // weak
int dword_805C1C4 = 0; // weak
int dword_805C200 = 0; // weak
char byte_805C204 = '\x01'; // weak
char *s = "/"; // idb
char *off_805C214[2] = { "xx", "8.28" }; // weak
int status = 1; // idb
int dword_805C23C = 1; // weak
int dword_805C240 = 256; // weak
void *off_805C244 = &unk_805CCC2; // weak
int *off_805C248 = &dword_805C240; // weak
_UNKNOWN unk_805C25C; // weak
_UNKNOWN unk_805C278; // weak
_UNKNOWN unk_805C27B; // weak
_UNKNOWN unk_805C280; // weak
_UNKNOWN unk_805C283; // weak
_UNKNOWN unk_805C28C; // weak
_UNKNOWN unk_805C28F; // weak
FILE *stderr; // idb
FILE *stdin; // idb
FILE *stdout; // idb
char byte_805C2EC; // weak
char byte_805C602; // weak
char byte_805C603; // weak
int dword_805C606; // weak
char byte_805C60A; // weak
char *s1; // idb
int dword_805C622; // weak
int dword_805C762; // weak
struct re_pattern_buffer stru_805C766; // idb
char byte_805C8A2; // weak
char byte_805C9C2[9]; // idb
char byte_805C9CB; // weak
char byte_805C9CC; // weak
char byte_805C9E2; // weak
void *ptr; // idb
size_t nmemb; // idb
char byte_805CB22[12]; // idb
int dword_805CC32; // weak
int dword_805CC36; // weak
char byte_805CC3A; // weak
char *string; // idb
int dword_805CC42; // weak
char byte_805CC46; // weak
int dword_805CC4A; // weak
int dword_805CC4E; // weak
char byte_805CC52; // weak
char *dword_805CC56; // idb
int dword_805CC5A; // weak
char byte_805CC5E; // weak
int dword_805CC62; // weak
int dword_805CC66; // weak
int dword_805CC6A; // weak
char byte_805CC6E; // weak
int dword_805CC72; // weak
int dword_805CC82; // weak
int dword_805CC86; // weak
int dword_805CC8A; // weak
int dword_805CC8E; // weak
int dword_805CC92; // weak
int dword_805CC96; // weak
int dword_805CC9A; // weak
int dword_805CC9E; // weak
int dword_805CCA2; // weak
int dword_805CCA6; // weak
int dword_805CCAA; // weak
int dword_805CCAE; // weak
_UNKNOWN unk_805CCC2; // weak
int dword_805CDC2; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (08048F98) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 80494F0: using guessed type int _gmon_start__(void);

//----- (08048FC0) --------------------------------------------------------
int sub_8048FC0()
{
  return dword_805C008();
}
// 805C008: using guessed type int (*dword_805C008)(void);

//----- (08049500) --------------------------------------------------------
#error "8049503: positive sp value has been found (funcsize=2)"

//----- (08049533) --------------------------------------------------------
void sub_8049533()
{
  ;
}

//----- (08049550) --------------------------------------------------------
void sub_8049550()
{
  ;
}

//----- (08049560) --------------------------------------------------------
int sub_8049560()
{
  int result; // eax

  result = &unk_805C28F - &unk_805C28C;
  if ( (unsigned int)(&unk_805C28F - &unk_805C28C) > 6 )
    result = 0;
  return result;
}
// 8049560: could not find valid save-restore pair for ebp

//----- (080495D0) --------------------------------------------------------
int sub_80495D0()
{
  int result; // eax

  if ( !byte_805C2EC )
  {
    result = sub_8049560();
    byte_805C2EC = 1;
  }
  return result;
}
// 80495D0: could not find valid save-restore pair for ebp
// 805C2EC: using guessed type char byte_805C2EC;

//----- (080495F0) --------------------------------------------------------
int sub_80495F0()
{
  return 0;
}
// 80495F0: could not find valid save-restore pair for ebp

//----- (0804964F) --------------------------------------------------------
void sub_804964F()
{
  ;
}

//----- (0804966A) --------------------------------------------------------
void sub_804966A()
{
  ;
}

//----- (0804967A) --------------------------------------------------------
signed int sub_804967A()
{
  return 3;
}
// 804967A: could not find valid save-restore pair for ebp

//----- (0804972C) --------------------------------------------------------
int __usercall sub_804972C@<eax>(void (__cdecl *a1)(signed int)@<eax>)
{
  a1(134590188);
  return 0;
}

//----- (08049778) --------------------------------------------------------
void sub_8049778()
{
  ;
}

//----- (08049793) --------------------------------------------------------
void sub_8049793()
{
  ;
}

//----- (080497A3) --------------------------------------------------------
int sub_80497A3()
{
  int result; // eax

  result = &unk_805C27B - &unk_805C278;
  if ( (unsigned int)(&unk_805C27B - &unk_805C278) > 6 )
    result = 0;
  return result;
}
// 80497A3: could not find valid save-restore pair for ebp

//----- (08049885) --------------------------------------------------------
void sub_8049885()
{
  ;
}

//----- (080498A0) --------------------------------------------------------
void sub_80498A0()
{
  ;
}

//----- (080498B0) --------------------------------------------------------
int sub_80498B0()
{
  int result; // eax

  result = &unk_805C27B - &unk_805C278;
  if ( (unsigned int)(&unk_805C27B - &unk_805C278) > 6 )
    result = 0;
  return result;
}
// 80498B0: could not find valid save-restore pair for ebp

//----- (08049992) --------------------------------------------------------
void sub_8049992()
{
  ;
}

//----- (080499AD) --------------------------------------------------------
void sub_80499AD()
{
  ;
}

//----- (080499BD) --------------------------------------------------------
signed int sub_80499BD()
{
  return 3;
}
// 80499BD: could not find valid save-restore pair for ebp

//----- (08049A9F) --------------------------------------------------------
void sub_8049A9F()
{
  ;
}

//----- (08049ABA) --------------------------------------------------------
void sub_8049ABA()
{
  ;
}

//----- (08049ACA) --------------------------------------------------------
int sub_8049ACA()
{
  int result; // eax

  result = &unk_805C27B - &unk_805C278;
  if ( (unsigned int)(&unk_805C27B - &unk_805C278) > 6 )
    result = 0;
  return result;
}
// 8049ACA: could not find valid save-restore pair for ebp

//----- (08049BAC) --------------------------------------------------------
void sub_8049BAC()
{
  ;
}

//----- (08049BC7) --------------------------------------------------------
void sub_8049BC7()
{
  ;
}

//----- (08049BD7) --------------------------------------------------------
int sub_8049BD7()
{
  int result; // eax

  result = &unk_805C27B - &unk_805C278;
  if ( (unsigned int)(&unk_805C27B - &unk_805C278) > 6 )
    result = 0;
  return result;
}
// 8049BD7: could not find valid save-restore pair for ebp

//----- (08049CB9) --------------------------------------------------------
void sub_8049CB9()
{
  ;
}

//----- (08049CD4) --------------------------------------------------------
void sub_8049CD4()
{
  ;
}

//----- (08049CE4) --------------------------------------------------------
int sub_8049CE4()
{
  int result; // eax

  result = &unk_805C283 - &unk_805C280;
  if ( (unsigned int)(&unk_805C283 - &unk_805C280) > 6 )
    result = 0;
  return result;
}
// 8049CE4: could not find valid save-restore pair for ebp

//----- (08049DC6) --------------------------------------------------------
void sub_8049DC6()
{
  ;
}

//----- (08049DE1) --------------------------------------------------------
void sub_8049DE1()
{
  ;
}

//----- (08049DF1) --------------------------------------------------------
int sub_8049DF1()
{
  int result; // eax
  int (__stdcall *v1)(void *, int, int, int, int, int); // eax
  int v2; // [esp+4h] [ebp-18h]
  int v3; // [esp+8h] [ebp-14h]
  int v4; // [esp+Ch] [ebp-10h]
  int v5; // [esp+10h] [ebp-Ch]
  int v6; // [esp+14h] [ebp-8h]
  int v7; // [esp+18h] [ebp-4h]

  result = &unk_80591FF - &unk_80591FC;
  if ( (unsigned int)(&unk_80591FF - &unk_80591FC) > 6 )
  {
    v7 = 0;
    dword_805C174 = (int)&locret_8049E00;
    v1 = (int (__stdcall *)(void *, int, int, int, int, int))sub_805631A();
    result = v1(&unk_80591FC, v2, v3, v4, v5, v6);
  }
  return result;
}
// 805631A: using guessed type int sub_805631A(void);
// 805C174: using guessed type int dword_805C174;

//----- (08049EFE) --------------------------------------------------------
void sub_8049EFE()
{
  ;
}

//----- (08049F19) --------------------------------------------------------
void sub_8049F19()
{
  ;
}

//----- (08049F29) --------------------------------------------------------
int sub_8049F29()
{
  int result; // eax

  result = &unk_80581F3 - &unk_80581F0;
  if ( (unsigned int)(&unk_80581F3 - &unk_80581F0) > 6 )
    result = 0;
  return result;
}
// 8049F29: could not find valid save-restore pair for ebp

//----- (0804A00B) --------------------------------------------------------
void sub_804A00B()
{
  ;
}

//----- (0804A026) --------------------------------------------------------
void sub_804A026()
{
  ;
}

//----- (0804A036) --------------------------------------------------------
int sub_804A036()
{
  int result; // eax

  result = &unk_80581F3 - &unk_80581F0;
  if ( (unsigned int)(&unk_80581F3 - &unk_80581F0) > 6 )
    result = 0;
  return result;
}
// 804A036: could not find valid save-restore pair for ebp

//----- (0804A0E6) --------------------------------------------------------
int __cdecl sub_804A0E6(unsigned __int8 a1)
{
  return a1;
}

//----- (0804A0F8) --------------------------------------------------------
int sub_804A0F8()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nWith no FILE, or when FILE is -, read standard input.\n");
  return fputs_unlocked(v1, v0);
}
// 80492B0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804A123) --------------------------------------------------------
int sub_804A123()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nMandatory arguments to long options are mandatory for short options too.\n");
  return fputs_unlocked(v1, v0);
}
// 80492B0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804A14E) --------------------------------------------------------
int __cdecl sub_804A14E(const char *s1)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // ebx
  char *v5; // eax
  const char *v7; // [esp+1Ch] [ebp-50h]
  const char **i; // [esp+20h] [ebp-4Ch]
  char *v9; // [esp+24h] [ebp-48h]
  const char *v10; // [esp+28h] [ebp-44h]
  const char *v11; // [esp+2Ch] [ebp-40h]
  const char *v12; // [esp+30h] [ebp-3Ch]
  const char *v13; // [esp+34h] [ebp-38h]
  const char *v14; // [esp+38h] [ebp-34h]
  const char *v15; // [esp+3Ch] [ebp-30h]
  const char *v16; // [esp+40h] [ebp-2Ch]
  const char *v17; // [esp+44h] [ebp-28h]
  const char *v18; // [esp+48h] [ebp-24h]
  const char *v19; // [esp+4Ch] [ebp-20h]
  const char *v20; // [esp+50h] [ebp-1Ch]
  const char *v21; // [esp+54h] [ebp-18h]
  int v22; // [esp+58h] [ebp-14h]
  int v23; // [esp+5Ch] [ebp-10h]

  v10 = "[";
  v11 = "test invocation";
  v12 = "coreutils";
  v13 = "Multi-call invocation";
  v14 = "sha224sum";
  v15 = "sha2 utilities";
  v16 = "sha256sum";
  v17 = "sha2 utilities";
  v18 = "sha384sum";
  v19 = "sha2 utilities";
  v20 = "sha512sum";
  v21 = "sha2 utilities";
  v22 = 0;
  v23 = 0;
  v7 = s1;
  for ( i = &v10; *i && strcmp(s1, *i); i += 2 )
    ;
  if ( i[1] )
    v7 = i[1];
  v1 = gettext("\n%s online help: <%s>\n");
  printf(v1, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  v9 = setlocale(5, 0);
  if ( v9 && strncmp(v9, "en_", 3u) )
  {
    v2 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
    printf(v2, s1);
  }
  v3 = gettext("Full documentation at: <%s%s>\n");
  printf(v3, "http://www.gnu.org/software/coreutils/", s1);
  if ( v7 == s1 )
    v4 = " invocation";
  else
    v4 = &locale;
  v5 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  return printf(v5, v7, v4);
}

//----- (0804A2F4) --------------------------------------------------------
char *__cdecl sub_804A2F4(char *a1)
{
  char *v1; // ebx
  int *v2; // eax

  v1 = gettext("error in regular expression matcher");
  v2 = __errno_location();
  error(1, *v2, v1);
  return sub_804A324(a1);
}

//----- (0804A324) --------------------------------------------------------
#error "804A3D5: call analysis failed (funcsize=179)"

//----- (0804A6D6) --------------------------------------------------------
int __cdecl sub_804A6D6(int a1)
{
  char *v1; // eax
  size_t v2; // eax
  void *v3; // ebx
  char *v4; // eax
  char *s; // [esp+0h] [ebp-3Ch]
  size_t length; // [esp+4h] [ebp-38h]
  struct re_pattern_buffer *buffer; // [esp+8h] [ebp-34h]
  int v9; // [esp+Ch] [ebp-30h]
  void *v10; // [esp+10h] [ebp-2Ch]

  *(&s - 5) = (char *)(a1 + 4);
  *(&s - 4) = (char *)buffer->buffer;
  *(_DWORD *)*(&s - 5) = 0;
  *((_DWORD *)*(&s - 5) + 1) = 0;
  *((_DWORD *)*(&s - 5) + 4) = (char *)buffer + 36;
  if ( byte_805C60A )
    v1 = &byte_805C8A2;
  else
    v1 = 0;
  *((_DWORD *)*(&s - 5) + 5) = v1;
  s = *(&s - 4);
  v2 = strlen(s);
  buffer = (struct re_pattern_buffer *)*(&s - 5);
  length = v2;
  s = *(&s - 4);
  *(&s - 3) = (char *)re_compile_pattern(s, v2, buffer);
  if ( *(&s - 3) )
  {
    s = *(&s - 4);
    v3 = sub_8051429((int)s);
    v4 = gettext("%s (for regexp %s)");
    v10 = v3;
    v9 = (int)*(&s - 3);
    error(1, 0, v4, v9, v3);
  }
  return re_compile_fastmap((struct re_pattern_buffer *)*(&s - 5));
}
// 805C60A: using guessed type char byte_805C60A;
// 805C8A2: using guessed type char byte_805C8A2;

//----- (0804A7C1) --------------------------------------------------------
#error "804A93A: call analysis failed (funcsize=91)"

//----- (0804A974) --------------------------------------------------------
int __cdecl sub_804A974(char *s1, int a2)
{
  bool v2; // al
  char *v3; // eax
  int v4; // ebx
  int *v5; // eax
  int result; // eax
  int v7; // [esp+1Ch] [ebp-Ch]

  v2 = !s1 || !*s1 || !strcmp(s1, "-");
  if ( v2 )
    v3 = sub_8051444(stdin, (int)&v7);
  else
    v3 = sub_805179A((int)s1, (int)&v7);
  *(_DWORD *)a2 = v3;
  if ( !*(_DWORD *)a2 )
  {
    v4 = sub_8050DB3(0, 3);
    v5 = __errno_location();
    error(1, *v5, "%s", v4);
  }
  result = a2;
  *(_DWORD *)(a2 + 4) = v7 + *(_DWORD *)a2;
  return result;
}
// 8050DB3: using guessed type _DWORD __cdecl sub_8050DB3(_DWORD, _DWORD);

//----- (0804AA59) --------------------------------------------------------
#error "804AB2B: call analysis failed (funcsize=86)"

//----- (0804ABD5) --------------------------------------------------------
#error "804AC24: call analysis failed (funcsize=35)"

//----- (0804AC39) --------------------------------------------------------
int __cdecl sub_804AC39(void *a1, int a2)
{
  int v3; // [esp+8h] [ebp-10h]
  int v4; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  v3 = 0;
  v4 = *(_DWORD *)(a2 + 8) - 1;
  while ( v3 <= v4 )
  {
    v5 = (v3 + v4) / 2;
    v6 = sub_804AA59(a1, (const void *)(8 * v5 + *(_DWORD *)a2));
    if ( v6 >= 0 )
    {
      if ( v6 <= 0 )
        return 1;
      v3 = v5 + 1;
    }
    else
    {
      v4 = v5 - 1;
    }
  }
  return 0;
}

//----- (0804ACE3) --------------------------------------------------------
void sub_804ACE3()
{
  if ( nmemb )
    qsort(ptr, nmemb, 0x1Cu, compar);
}

//----- (0804AD1C) --------------------------------------------------------
void __cdecl sub_804AD1C(char *s1)
{
  unsigned __int8 *i; // [esp+14h] [ebp-14h]
  void *ptr; // [esp+18h] [ebp-10h]
  unsigned int v3; // [esp+1Ch] [ebp-Ch]

  sub_804A974(s1, (int)&ptr);
  memset(byte_805C9C2, 1, 0x100u);
  for ( i = (unsigned __int8 *)ptr; v3 > (unsigned int)i; ++i )
    byte_805C9C2[(unsigned __int8)sub_804A0E6(*i)] = 0;
  if ( byte_805C204 != 1 )
  {
    byte_805C9E2 = 0;
    byte_805C9CB = 0;
    byte_805C9CC = 0;
  }
  free(ptr);
}
// 805C204: using guessed type char byte_805C204;
// 805C9CB: using guessed type char byte_805C9CB;
// 805C9CC: using guessed type char byte_805C9CC;
// 805C9E2: using guessed type char byte_805C9E2;

//----- (0804ADAF) --------------------------------------------------------
#error "804AEA8: call analysis failed (funcsize=97)"

//----- (0804AF08) --------------------------------------------------------
#error "804B1B9: call analysis failed (funcsize=237)"

//----- (0804B6EE) --------------------------------------------------------
int __cdecl sub_804B6EE(int a1)
{
  int result; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  result = a1;
  for ( i = a1; i > 0; --i )
    result = putchar_unlocked(32);
  return result;
}

//----- (0804B714) --------------------------------------------------------
unsigned int __usercall sub_804B714@<eax>(int a1@<edx>, int a2@<ecx>, char *a3, unsigned int a4)
{
  int v4; // edx
  int v5; // ecx
  int v6; // eax
  bool v7; // zf
  void *v8; // eax
  int v9; // edx
  int v10; // ecx
  char *v11; // eax
  char *v12; // eax
  char *v13; // eax
  char *v14; // eax
  char *v15; // eax
  int v16; // edx
  int v17; // ecx
  unsigned int result; // eax
  int v19; // [esp+0h] [ebp-28h]
  char *v20; // [esp+4h] [ebp-24h]
  int v21; // [esp+8h] [ebp-20h]
  unsigned __int8 v22; // [esp+13h] [ebp-15h]
  char *v23; // [esp+14h] [ebp-14h]
  int v24; // [esp+18h] [ebp-10h]
  int v25; // [esp+1Ch] [ebp-Ch]

  v23 = a3;
  dword_805C1B0 = (int)&loc_804BB84;
  sub_80561A1(a2, a1);
  do
  {
    v22 = *v23;
    if ( !byte_805CB22[v22] )
    {
      putchar_unlocked(*v23);
      goto LABEL_69;
    }
    v6 = byte_8057228[v22];
    v24 = v6;
    v7 = v6 == 0;
    v8 = &loc_804B783;
    if ( v7 )
      v8 = &loc_804BA82;
    dword_805C19C = (int)v8;
    sub_8056234(v5, v4);
    if ( dword_805C606 == 3 )
    {
      v25 = byte_8057128[v22];
      switch ( v24 )
      {
        case 1:
          if ( v25 == 79 )
          {
            fwrite_unlocked("\\OE{}", 1u, 5u, stdout);
          }
          else if ( v25 > 79 )
          {
            if ( v25 == 97 )
            {
              fwrite_unlocked("\\ae{}", 1u, 5u, stdout);
            }
            else
            {
              if ( v25 != 111 )
              {
LABEL_17:
                putchar_unlocked(32);
                goto LABEL_69;
              }
              fwrite_unlocked("\\oe{}", 1u, 5u, stdout);
            }
          }
          else
          {
            if ( v25 != 65 )
              goto LABEL_17;
            fwrite_unlocked("\\AE{}", 1u, 5u, stdout);
          }
          dword_805C1B0 = (int)&loc_804BA7D;
          sub_80561A1(v10, v9);
          goto LABEL_19;
        case 2:
LABEL_19:
          if ( v25 == 105 )
            v11 = "\\";
          else
            v11 = &locale;
          v21 = v25;
          v20 = v11;
          printf("\\'%s%c", v11, v25);
          goto LABEL_69;
        case 3:
          if ( v25 == 105 )
            v12 = "\\";
          else
            v12 = &locale;
          v21 = v25;
          v20 = v12;
          printf("\\'%s%c", v12, v25);
          goto LABEL_69;
        case 4:
          if ( v25 == 105 )
            v13 = "\\";
          else
            v13 = &locale;
          v21 = v25;
          v20 = v13;
          printf("\\^%s%c", v13, v25);
          goto LABEL_69;
        case 5:
          if ( v25 == 105 )
            v14 = "\\";
          else
            v14 = &locale;
          v21 = v25;
          v20 = v14;
          printf("\\\"%s%c", v14, v25);
          goto LABEL_69;
        case 6:
          if ( v25 == 105 )
            v15 = "\\";
          else
            v15 = &locale;
          v21 = v25;
          v20 = v15;
          printf("\\~%s%c", v15, v25);
          goto LABEL_69;
        case 7:
          v20 = (char *)v25;
          printf("\\c{%c}", v25);
          goto LABEL_69;
        case 8:
          if ( v25 == 65 )
          {
            fwrite_unlocked("\\AA{}", 1u, 5u, stdout);
          }
          else if ( v25 == 97 )
          {
            fwrite_unlocked("\\aa{}", 1u, 5u, stdout);
          }
          else
          {
            putchar_unlocked(32);
          }
          goto LABEL_69;
        case 9:
          if ( v25 == 79 )
          {
            fwrite_unlocked("\\O{}", 1u, 4u, stdout);
          }
          else if ( v25 == 111 )
          {
            fwrite_unlocked("\\o{}", 1u, 4u, stdout);
          }
          else
          {
            putchar_unlocked(32);
          }
          goto LABEL_69;
        default:
          goto LABEL_69;
      }
    }
    if ( v22 == 92 )
      goto LABEL_65;
    if ( (signed int)v22 > 92 )
    {
      if ( v22 == 123 || v22 == 125 )
      {
        v20 = (char *)v22;
        printf("$\\%c$", v22);
        dword_805C174 = (int)&loc_804BB6D;
        sub_805631A();
LABEL_65:
        fwrite_unlocked("\\backslash{}", 1u, 0xCu, stdout);
        dword_805C1C4 = (int)&loc_804BB6D;
        sub_805612D(v17, v16, v19);
LABEL_66:
        putchar_unlocked(32);
        goto LABEL_69;
      }
      if ( v22 != 95 )
        goto LABEL_66;
    }
    else
    {
      if ( v22 == 34 )
      {
        putchar_unlocked(34);
        putchar_unlocked(34);
        goto LABEL_69;
      }
      if ( (signed int)v22 < 34 || (signed int)v22 > 38 )
        goto LABEL_66;
    }
    putchar_unlocked(92);
    putchar_unlocked(v22);
LABEL_69:
    ++v23;
    result = a4;
  }
  while ( a4 > (unsigned int)v23 );
  return result;
}
// 80561A1: using guessed type int __fastcall sub_80561A1(_DWORD, _DWORD);
// 805631A: using guessed type int sub_805631A(void);
// 805C174: using guessed type int dword_805C174;
// 805C19C: using guessed type int dword_805C19C;
// 805C1B0: using guessed type int dword_805C1B0;
// 805C1C4: using guessed type int dword_805C1C4;
// 805C606: using guessed type int dword_805C606;

//----- (0804BB92) --------------------------------------------------------
#error "804BE88: call analysis failed (funcsize=236)"

//----- (0804BF5E) --------------------------------------------------------
#error "804BFC2: call analysis failed (funcsize=35)"

//----- (0804BFD5) --------------------------------------------------------
#error "804C01F: call analysis failed (funcsize=25)"

//----- (0804C024) --------------------------------------------------------
#error "804C0B9: call analysis failed (funcsize=389)"

//----- (0804C5B2) --------------------------------------------------------
#error "804CBE6: positive sp value has been found (funcsize=383)"

//----- (0804CBE9) --------------------------------------------------------
int sub_804CBE9()
{
  int v0; // ecx
  int v1; // ecx
  int v2; // ecx
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  int v6; // ecx
  int v7; // ecx

  printf(".%s \"", off_805C214[0]);
  sub_804B714(dword_805CC36, v0, (char *)dword_805CC32, dword_805CC36);
  if ( byte_805CC3A )
    fputs_unlocked(s, stdout);
  putchar_unlocked(34);
  fwrite_unlocked(" \"", 1u, 2u, stdout);
  if ( byte_805CC46 )
    fputs_unlocked(s, stdout);
  sub_804B714(dword_805CC42, v1, string, dword_805CC42);
  putchar_unlocked(34);
  fwrite_unlocked(" \"", 1u, 2u, stdout);
  sub_804B714(dword_805CC4E, v2, (char *)dword_805CC4A, dword_805CC4E);
  if ( byte_805CC52 )
    fputs_unlocked(s, stdout);
  putchar_unlocked(34);
  fwrite_unlocked(" \"", 1u, 2u, stdout);
  v5 = &loc_804CD66;
  if ( !byte_805CC5E )
    v5 = &loc_804CD7D;
  dword_805C19C = (int)v5;
  sub_8056234(v4, v3);
  fputs_unlocked(s, stdout);
  sub_804B714(dword_805CC5A, v6, dword_805CC56, dword_805CC5A);
  putchar_unlocked(34);
  if ( byte_805C602 || byte_805C603 )
  {
    fwrite_unlocked(" \"", 1u, 2u, stdout);
    sub_804B714(dword_805CC66, v7, (char *)dword_805CC62, dword_805CC66);
    putchar_unlocked(34);
  }
  return putchar_unlocked(10);
}
// 80492B0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 805C19C: using guessed type int dword_805C19C;
// 805C214: using guessed type char *off_805C214[2];
// 805C602: using guessed type char byte_805C602;
// 805C603: using guessed type char byte_805C603;
// 805CC32: using guessed type int dword_805CC32;
// 805CC36: using guessed type int dword_805CC36;
// 805CC3A: using guessed type char byte_805CC3A;
// 805CC42: using guessed type int dword_805CC42;
// 805CC46: using guessed type char byte_805CC46;
// 805CC4A: using guessed type int dword_805CC4A;
// 805CC4E: using guessed type int dword_805CC4E;
// 805CC52: using guessed type char byte_805CC52;
// 805CC5A: using guessed type int dword_805CC5A;
// 805CC5E: using guessed type char byte_805CC5E;
// 805CC62: using guessed type int dword_805CC62;
// 805CC66: using guessed type int dword_805CC66;

//----- (0804CE0C) --------------------------------------------------------
int sub_804CE0C()
{
  int v0; // ecx
  int v1; // ecx
  int v2; // edx
  int v3; // ecx
  signed int v4; // eax
  int v5; // ecx
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  char *v10; // [esp+0h] [ebp-48h]
  unsigned __int8 *string; // [esp+28h] [ebp-20h]
  int v12; // [esp+2Ch] [ebp-1Ch]
  char *v13; // [esp+30h] [ebp-18h]
  int v14; // [esp+3Ch] [ebp-Ch]

  printf("\\%s ", off_805C214[0]);
  putchar_unlocked(123);
  sub_804B714(dword_805CC36, v0, (char *)dword_805CC32, dword_805CC36);
  fwrite_unlocked("}{", 1u, 2u, stdout);
  sub_804B714(dword_805CC42, v1, ::string, dword_805CC42);
  fwrite_unlocked("}{", 1u, 2u, stdout);
  v13 = (char *)dword_805CC4A;
  v14 = dword_805CC4E;
  string = (unsigned __int8 *)dword_805CC4A;
  if ( dword_805C762 )
  {
    v12 = re_match(&stru_805C766, (const char *)dword_805CC4A, dword_805CC4E - dword_805CC4A, 0, 0);
    if ( v12 == -2 )
      sub_804A2F4(v10);
    if ( v12 == -1 )
      v4 = 1;
    else
      v4 = v12;
    string += v4;
    dword_805C1B0 = (int)&loc_804CF9D;
    sub_80561A1(v3, v2);
  }
  if ( byte_805C9C2[(unsigned __int8)sub_804A0E6(*string)] )
  {
    while ( dword_805CC4E > (unsigned int)string && byte_805C9C2[(unsigned __int8)sub_804A0E6(*string)] )
      ++string;
  }
  else
  {
    ++string;
  }
  sub_804B714((int)string, v5, v13, (unsigned int)string);
  fwrite_unlocked("}{", 1u, 2u, stdout);
  sub_804B714(v14, v6, (char *)string, v14);
  fwrite_unlocked("}{", 1u, 2u, stdout);
  sub_804B714(dword_805CC5A, v7, dword_805CC56, dword_805CC5A);
  putchar_unlocked(125);
  if ( byte_805C602 || byte_805C603 )
  {
    putchar_unlocked(123);
    sub_804B714(dword_805CC66, v8, (char *)dword_805CC62, dword_805CC66);
    putchar_unlocked(125);
  }
  return putchar_unlocked(10);
}
// 80561A1: using guessed type int __fastcall sub_80561A1(_DWORD, _DWORD);
// 805C1B0: using guessed type int dword_805C1B0;
// 805C214: using guessed type char *off_805C214[2];
// 805C602: using guessed type char byte_805C602;
// 805C603: using guessed type char byte_805C603;
// 805C762: using guessed type int dword_805C762;
// 805CC32: using guessed type int dword_805CC32;
// 805CC36: using guessed type int dword_805CC36;
// 805CC42: using guessed type int dword_805CC42;
// 805CC4A: using guessed type int dword_805CC4A;
// 805CC4E: using guessed type int dword_805CC4E;
// 805CC5A: using guessed type int dword_805CC5A;
// 805CC62: using guessed type int dword_805CC62;
// 805CC66: using guessed type int dword_805CC66;

//----- (0804D08D) --------------------------------------------------------
#error "804D171: call analysis failed (funcsize=153)"

//----- (0804D2FF) --------------------------------------------------------
#error "804D587: positive sp value has been found (funcsize=141)"

//----- (0804D588) --------------------------------------------------------
size_t sub_804D588()
{
  int v0; // edx
  int v1; // ecx
  size_t result; // eax
  int v3; // [esp+0h] [ebp-28h]
  int i; // [esp+18h] [ebp-10h]
  char *v5; // [esp+1Ch] [ebp-Ch]

  dword_805CC32 = 0;
  dword_805CC36 = 0;
  byte_805CC3A = 0;
  dword_805CC56 = 0;
  dword_805CC5A = 0;
  byte_805CC5E = 0;
  v5 = (char *)ptr;
  for ( i = 0; ; ++i )
  {
    result = nmemb;
    if ( (signed int)nmemb <= i )
      break;
    sub_804BF5E(v5);
    if ( dword_805C606 == 2 )
      goto LABEL_7;
    if ( (unsigned int)dword_805C606 < 2 )
    {
      sub_804D08D();
      dword_805C1C4 = (int)&loc_804D63E;
      sub_805612D(v1, v0, v3);
LABEL_7:
      sub_804CBE9();
      goto LABEL_9;
    }
    if ( dword_805C606 == 3 )
      sub_804CE0C();
LABEL_9:
    v5 += 28;
  }
  return result;
}
// 804BF5E: using guessed type _DWORD __cdecl sub_804BF5E(_DWORD);
// 804D08D: using guessed type int sub_804D08D(void);
// 805C1C4: using guessed type int dword_805C1C4;
// 805C606: using guessed type int dword_805C606;
// 805CC32: using guessed type int dword_805CC32;
// 805CC36: using guessed type int dword_805CC36;
// 805CC3A: using guessed type char byte_805CC3A;
// 805CC5A: using guessed type int dword_805CC5A;
// 805CC5E: using guessed type char byte_805CC5E;

//----- (0804D652) --------------------------------------------------------
void __cdecl __noreturn sub_804D652(int status)
{
  int v1; // ebx
  char *v2; // eax
  int v3; // esi
  int v4; // ebx
  char *v5; // eax
  FILE *v6; // ebx
  char *v7; // eax
  FILE *v8; // ebx
  char *v9; // eax
  FILE *v10; // ebx
  char *v11; // eax
  FILE *v12; // ebx
  char *v13; // eax
  FILE *v14; // ebx
  char *v15; // eax
  FILE *v16; // ebx
  char *v17; // eax
  FILE *v18; // ebx
  char *v19; // eax
  FILE *v20; // ebx
  char *v21; // eax

  if ( status )
  {
    v1 = dword_805CC72;
    v2 = gettext("Try '%s --help' for more information.\n");
    fprintf(stderr, v2, v1);
  }
  else
  {
    v3 = dword_805CC72;
    v4 = dword_805CC72;
    v5 = gettext("Usage: %s [OPTION]... [INPUT]...   (without -G)\n  or:  %s -G [OPTION]... [INPUT [OUTPUT]]\n");
    printf(v5, v4, v3);
    v6 = stdout;
    v7 = gettext("Output a permuted index, including context, of the words in the input files.\n");
    fputs_unlocked(v7, v6);
    sub_804A0F8();
    sub_804A123();
    v8 = stdout;
    v9 = gettext(
           "  -A, --auto-reference           output automatically generated references\n"
           "  -G, --traditional              behave more like System V 'ptx'\n");
    fputs_unlocked(v9, v8);
    v10 = stdout;
    v11 = gettext(
            "  -F, --flag-truncation=STRING   use STRING for flagging line truncations.\n"
            "                                 The default is '/'\n");
    fputs_unlocked(v11, v10);
    v12 = stdout;
    v13 = gettext(
            "  -M, --macro-name=STRING        macro name to use instead of 'xx'\n"
            "  -O, --format=roff              generate output as roff directives\n"
            "  -R, --right-side-refs          put references at right, not counted in -w\n"
            "  -S, --sentence-regexp=REGEXP   for end of lines or end of sentences\n"
            "  -T, --format=tex               generate output as TeX directives\n");
    fputs_unlocked(v13, v12);
    v14 = stdout;
    v15 = gettext(
            "  -W, --word-regexp=REGEXP       use REGEXP to match each keyword\n"
            "  -b, --break-file=FILE          word break characters in this FILE\n"
            "  -f, --ignore-case              fold lower case to upper case for sorting\n"
            "  -g, --gap-size=NUMBER          gap size in columns between output fields\n"
            "  -i, --ignore-file=FILE         read ignore word list from FILE\n"
            "  -o, --only-file=FILE           read only word list from this FILE\n");
    fputs_unlocked(v15, v14);
    v16 = stdout;
    v17 = gettext(
            "  -r, --references               first field of each line is a reference\n"
            "  -t, --typeset-mode               - not implemented -\n"
            "  -w, --width=NUMBER             output width in columns, reference excluded\n");
    fputs_unlocked(v17, v16);
    v18 = stdout;
    v19 = gettext("      --help     display this help and exit\n");
    fputs_unlocked(v19, v18);
    v20 = stdout;
    v21 = gettext("      --version  output version information and exit\n");
    fputs_unlocked(v21, v20);
    sub_804A14E("ptx");
  }
  exit(status);
}
// 80492B0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 805CC72: using guessed type int dword_805CC72;

//----- (0804D7C6) --------------------------------------------------------
void __usercall __noreturn main(int a1@<edx>, int a2@<ecx>, int argc, char **argv)
{
  sub_804E940(a2, a1, (int)*argv);
}

//----- (0804E1CC) --------------------------------------------------------
void __noreturn sub_804E1CC()
{
  sub_804D652(1);
}

//----- (0804E1E0) --------------------------------------------------------
int __cdecl sub_804E1E0(char *s, int a2, int a3, size_t a4)
{
  int result; // eax
  char v5; // [esp+13h] [ebp-15h]
  signed int i; // [esp+14h] [ebp-14h]
  signed int v7; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]

  v7 = -1;
  v5 = 0;
  n = strlen(s);
  for ( i = 0; *(_DWORD *)(4 * i + a2); ++i )
  {
    if ( !strncmp(*(const char **)(4 * i + a2), s, n) )
    {
      if ( strlen(*(const char **)(4 * i + a2)) == n )
        return i;
      if ( v7 == -1 )
      {
        v7 = i;
      }
      else if ( !a3 || memcmp((const void *)(a3 + a4 * v7), (const void *)(i * a4 + a3), a4) )
      {
        v5 = 1;
      }
    }
  }
  if ( v5 )
    result = -2;
  else
    result = v7;
  return result;
}

//----- (0804E30B) --------------------------------------------------------
void __cdecl sub_804E30B(int a1, int a2, int a3)
{
  char *v3; // eax
  char *format; // ST2C_4
  void *v5; // ebx
  void *v6; // eax

  if ( a3 == -1 )
    v3 = gettext("invalid argument %s for %s");
  else
    v3 = gettext("ambiguous argument %s for %s");
  format = v3;
  v5 = sub_8051407(1, a1);
  v6 = sub_8050B78(0, 8, a2);
  error(0, 0, format, v6, v5);
}

//----- (0804E38E) --------------------------------------------------------
#error "804E481: call analysis failed (funcsize=96)"

//----- (0804E4F5) --------------------------------------------------------
#error "804E51E: call analysis failed (funcsize=19)"

//----- (0804E531) --------------------------------------------------------
#error "804E59B: positive sp value has been found (funcsize=31)"

//----- (0804E63A) --------------------------------------------------------
int sub_804E63A()
{
  char *v0; // ebx
  int v1; // eax
  int v2; // eax
  int result; // eax
  char *v4; // [esp+Ch] [ebp-2Ch]
  char *v5; // [esp+10h] [ebp-28h]
  char *v6; // [esp+2Ch] [ebp-Ch]

  if ( sub_8053056(stdout) && (byte_805CC6E != 1 || *__errno_location() != 32) )
  {
    v6 = gettext("write error");
    if ( dword_805CC6A )
    {
      v0 = (char *)sub_8050D76(dword_805CC6A);
      v1 = *__errno_location();
      v5 = v6;
      v4 = v0;
      error(0, v1, "%s: %s", v0, v6);
      dword_805C160 = (int)&loc_804E702;
      sub_8056386();
    }
    v2 = *__errno_location();
    v4 = v6;
    error(0, v2, "%s", v6);
    _exit(status);
  }
  result = sub_8053056(stderr);
  if ( result )
    _exit(status);
  return result;
}
// 8056386: using guessed type int sub_8056386(void);
// 805C160: using guessed type int dword_805C160;
// 805CC6A: using guessed type int dword_805CC6A;
// 805CC6E: using guessed type char byte_805CC6E;

//----- (0804E733) --------------------------------------------------------
signed int __cdecl sub_804E733(int a1)
{
  int fd; // [esp+1Ch] [ebp-Ch]

  fd = open64("/dev/null", 0);
  if ( fd == a1 )
    return 1;
  if ( fd >= 0 )
  {
    close(fd);
    *__errno_location() = 9;
  }
  return 0;
}
// 8049000: using guessed type int __cdecl open64(_DWORD, _DWORD);

//----- (0804E782) --------------------------------------------------------
#error "804E8F6: call analysis failed (funcsize=124)"

//----- (0804E940) --------------------------------------------------------
void __fastcall __noreturn sub_804E940(int a1, int a2, int a3)
{
  int (__cdecl *v3)(int, size_t); // eax

  v3 = (int (__cdecl *)(int, size_t))&loc_804E965;
  if ( a3 )
    v3 = sub_804E98F;
  dword_805C19C = (int)v3;
  sub_8056234(a1, a2);
  fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
  abort();
}
// 805C19C: using guessed type int dword_805C19C;

//----- (0804E98F) --------------------------------------------------------
#error "804EA4A: positive sp value has been found (funcsize=52)"

//----- (0804EA4B) --------------------------------------------------------
int __cdecl sub_804EA4B(_BYTE *a1, char *a2)
{
  _BOOL4 v2; // eax
  bool v3; // zf
  void *v4; // eax
  int v5; // edx
  int v6; // ecx
  _BOOL4 v7; // eax
  void *v8; // eax
  _BOOL4 v9; // eax
  _BOOL4 v10; // eax
  _BOOL4 v11; // eax
  size_t v12; // eax
  int v14; // [esp+0h] [ebp-B8h]
  char *v15; // [esp+18h] [ebp-A0h]
  _BYTE *v16; // [esp+1Ch] [ebp-9Ch]
  unsigned __int8 v17; // [esp+2Bh] [ebp-8Dh]
  char v18; // [esp+2Ch] [ebp-8Ch]
  char v19; // [esp+2Dh] [ebp-8Bh]
  char v20; // [esp+2Eh] [ebp-8Ah]
  char v21; // [esp+2Fh] [ebp-89h]
  char *s; // [esp+30h] [ebp-88h]
  _BYTE *v23; // [esp+34h] [ebp-84h]
  unsigned __int8 *v24; // [esp+38h] [ebp-80h]
  char v25; // [esp+3Ch] [ebp-7Ch]
  int v26; // [esp+40h] [ebp-78h]
  char v27; // [esp+48h] [ebp-70h]
  _BYTE *v28; // [esp+4Ch] [ebp-6Ch]
  int v29; // [esp+50h] [ebp-68h]
  int v30; // [esp+54h] [ebp-64h]
  wint_t v31; // [esp+58h] [ebp-60h]
  char *v32; // [esp+5Ch] [ebp-5Ch]
  int v33; // [esp+60h] [ebp-58h]
  int v34; // [esp+64h] [ebp-54h]
  int v35; // [esp+68h] [ebp-50h]
  int v36; // [esp+6Ch] [ebp-4Ch]
  int v37; // [esp+70h] [ebp-48h]
  _BYTE *v38; // [esp+74h] [ebp-44h]
  int v39; // [esp+78h] [ebp-40h]
  int v40; // [esp+7Ch] [ebp-3Ch]
  wint_t wc; // [esp+80h] [ebp-38h]
  char *v42; // [esp+84h] [ebp-34h]
  int v43; // [esp+88h] [ebp-30h]
  int v44; // [esp+8Ch] [ebp-2Ch]
  int v45; // [esp+90h] [ebp-28h]
  int v46; // [esp+94h] [ebp-24h]
  int v47; // [esp+98h] [ebp-20h]
  unsigned int v48; // [esp+ACh] [ebp-Ch]

  v16 = a1;
  v15 = a2;
  v48 = __readgsdword(0x14u);
  s = sub_80517DE(a2, 2);
  v17 = 0;
  while ( *v16 )
  {
    v23 = (_BYTE *)sub_8054553(v16, s);
    if ( !v23 )
      break;
    if ( __ctype_get_mb_cur_max() <= 1 )
    {
      v20 = 1;
      if ( v16 < v23 && (*__ctype_b_loc())[(unsigned __int8)*(v23 - 1)] & 8 )
        v20 = 0;
      v12 = strlen(s);
      v24 = &v23[v12];
      v21 = 1;
      if ( v23[v12] && (*__ctype_b_loc())[*v24] & 8 )
        v21 = 0;
      if ( v20 && v21 )
      {
        v17 = 1;
        break;
      }
      if ( !*v23 )
        break;
      v16 = v23 + 1;
    }
    else
    {
      v28 = v16;
      v25 = 0;
      memset(&v26, 0, 8u);
      v27 = 0;
      v18 = 1;
      if ( v28 < v23 )
      {
        sub_8054DE8((int)&v25);
        v2 = (_BYTE)v30 != 1 || v31;
        v3 = v2 == 0;
        v4 = &loc_804EB7E;
        if ( !v3 )
          v4 = &loc_804EB83;
        dword_805C174 = (int)v4;
        sub_805631A();
        abort();
      }
      v28 = v23;
      v25 = 0;
      memset(&v26, 0, 8u);
      v27 = 0;
      v42 = s;
      LOBYTE(v38) = 0;
      memset(&v39, 0, 8u);
      LOBYTE(wc) = 0;
      sub_8054DE8((int)&v38);
      v9 = (_BYTE)v44 != 1 || v45;
      if ( v9 )
      {
        sub_8054DE8((int)&v25);
        v7 = (_BYTE)v30 != 1 || v31;
        v3 = v7 == 0;
        v8 = &loc_804ECD1;
        if ( !v3 )
          v8 = &loc_804ECD6;
        dword_805C1C4 = (int)v8;
        sub_805612D(v6, v5, v14);
        abort();
      }
      v19 = 1;
      sub_8054DE8((int)&v25);
      v10 = (_BYTE)v30 != 1 || v31;
      if ( v10 )
      {
        v38 = v28;
        v39 = v29;
        v40 = v30;
        wc = v31;
        v42 = v32;
        v43 = v33;
        v44 = v34;
        v45 = v35;
        v46 = v36;
        v47 = v37;
        if ( (_BYTE)v30 )
        {
          if ( iswalnum(wc) )
            v19 = 0;
        }
      }
      if ( v18 && v19 )
      {
        v17 = 1;
        break;
      }
      v28 = v23;
      v25 = 0;
      memset(&v26, 0, 8u);
      v27 = 0;
      sub_8054DE8((int)&v25);
      v11 = (_BYTE)v30 != 1 || v31;
      if ( !v11 )
        break;
      v16 = &v23[v29];
    }
  }
  free(s);
  return v17;
}
// 8054553: using guessed type _DWORD __cdecl sub_8054553(_DWORD, _DWORD);
// 805631A: using guessed type int sub_805631A(void);
// 805C174: using guessed type int dword_805C174;
// 805C1C4: using guessed type int dword_805C1C4;

//----- (0804F042) --------------------------------------------------------
char *__cdecl sub_804F042(char *msgid, char *a2)
{
  bool v2; // zf
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  int v6; // edx
  int v7; // ecx
  char *v8; // eax
  int v9; // edx
  int v10; // ecx
  void *v11; // eax
  void *v12; // eax
  char *result; // eax
  size_t v14; // ebx
  size_t v15; // [esp+0h] [ebp-48h]
  char *v16; // [esp+8h] [ebp-40h]
  char *v17; // [esp+Ch] [ebp-3Ch]
  void *ptr; // [esp+14h] [ebp-34h]
  void *v19; // [esp+18h] [ebp-30h]
  char *v20; // [esp+1Ch] [ebp-2Ch]
  char *v21; // [esp+20h] [ebp-28h]
  char *s1; // [esp+24h] [ebp-24h]
  char *s; // [esp+28h] [ebp-20h]
  size_t n; // [esp+2Ch] [ebp-1Ch]
  void *dest; // [esp+30h] [ebp-18h]
  char *v26; // [esp+34h] [ebp-14h]
  char *v27; // [esp+38h] [ebp-10h]
  char *v28; // [esp+3Ch] [ebp-Ch]

  s1 = gettext(msgid);
  s = sub_8053699();
  ptr = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v2 = sub_8052FDC((unsigned __int8 *)s, "UTF-8") == 0;
  v5 = &loc_804F0AB;
  if ( v2 )
    v5 = &loc_804F188;
  dword_805C1B0 = (int)v5;
  sub_80561A1(v4, v3);
  ptr = sub_8052741(a2, "UTF-8", s);
  v20 = (char *)ptr;
  n = strlen(s);
  dest = sub_80524FC(n + 11);
  memcpy(dest, s, n);
  memcpy((char *)dest + n, "//TRANSLIT", 0xBu);
  v26 = sub_8052741(a2, "UTF-8", (char *)dest);
  free(dest);
  if ( v26 )
  {
    if ( strchr(v26, 63) )
    {
      free(v26);
    }
    else
    {
      v19 = v26;
      v21 = v26;
    }
  }
  if ( v20 )
  {
    v8 = v20;
  }
  else
  {
    if ( v21 )
    {
      dword_805C1B0 = (int)&loc_804F1C2;
      sub_80561A1(v7, v6);
    }
    v8 = msgid;
  }
  v27 = v8;
  if ( !strcmp(s1, msgid) )
  {
    if ( ptr && ptr != v27 )
      free(ptr);
    if ( v19 && v19 != v27 )
      free(v19);
    result = v27;
  }
  else
  {
    if ( (unsigned __int8)sub_804EA4B(s1, msgid) )
      goto LABEL_40;
    if ( v20 )
    {
      v2 = (unsigned __int8)sub_804EA4B(s1, v20) == 0;
      v11 = &loc_804F22A;
      if ( !v2 )
        v11 = &loc_804F25F;
      dword_805C1C4 = (int)v11;
      sub_805612D(v10, v9, v15);
    }
    v12 = &loc_804F249;
    if ( !v21 )
      v12 = &loc_804F289;
    dword_805C160 = (int)v12;
    sub_8056386();
    if ( (unsigned __int8)sub_804EA4B(s1, v21) )
    {
LABEL_40:
      if ( ptr )
        free(ptr);
      if ( v19 )
        free(v19);
      result = s1;
    }
    else
    {
      v14 = strlen(s1);
      v15 = v14 + strlen(v27) + 4;
      v28 = (char *)sub_80524FC(v15);
      v17 = v27;
      v16 = s1;
      sprintf(v28, "%s (%s)", s1, v27);
      if ( ptr )
        free(ptr);
      if ( v19 )
        free(v19);
      result = v28;
    }
  }
  return result;
}
// 80561A1: using guessed type int __fastcall sub_80561A1(_DWORD, _DWORD);
// 8056386: using guessed type int sub_8056386(void);
// 805C160: using guessed type int dword_805C160;
// 805C1B0: using guessed type int dword_805C1B0;
// 805C1C4: using guessed type int dword_805C1C4;

//----- (0804F3C0) --------------------------------------------------------
int __cdecl sub_804F3C0(int *a1, unsigned __int8 a2, char a3)
{
  int *v3; // eax
  int v4; // eax
  int v5; // ST10_4

  if ( a1 )
    v3 = a1;
  else
    v3 = &dword_805CC82;
  v4 = (int)&v3[a2 >> 5];
  v5 = (*(_DWORD *)(v4 + 8) >> (a2 & 0x1F)) & 1;
  *(_DWORD *)(v4 + 8) ^= (v5 ^ a3 & 1) << (a2 & 0x1F);
  return v5;
}
// 805CC82: using guessed type int dword_805CC82;

//----- (0804F49A) --------------------------------------------------------
int *__cdecl sub_804F49A(int *a1, int a2, int a3)
{
  int *result; // eax

  if ( !a1 )
    a1 = &dword_805CC82;
  *a1 = 10;
  if ( !a2 || !a3 )
    abort();
  a1[10] = a2;
  result = a1;
  a1[11] = a3;
  return result;
}
// 805CC82: using guessed type int dword_805CC82;

//----- (0804F4DB) --------------------------------------------------------
#error "804F582: call analysis failed (funcsize=51)"

//----- (0804F587) --------------------------------------------------------
#error "804F5AF: positive sp value has been found (funcsize=0)"

//----- (0804F5C2) --------------------------------------------------------
const char *__cdecl sub_804F5C2(char *msgid, int a2)
{
  const char *result; // eax
  char *v3; // [esp+18h] [ebp-10h]
  unsigned __int8 *v4; // [esp+1Ch] [ebp-Ch]

  v3 = gettext(msgid);
  if ( v3 != msgid )
    return v3;
  v4 = (unsigned __int8 *)sub_8053699();
  if ( sub_8052FDC(v4, "UTF-8") )
  {
    if ( sub_8052FDC(v4, "GB18030") )
    {
      if ( a2 == 9 )
        result = (const char *)&unk_805748D;
      else
        result = "'";
    }
    else if ( *msgid == 96 )
    {
      result = (const char *)&unk_8057486;
    }
    else
    {
      result = (const char *)&unk_805748A;
    }
  }
  else if ( *msgid == 96 )
  {
    result = (const char *)&unk_8057476;
  }
  else
  {
    result = (const char *)&unk_805747A;
  }
  return result;
}

//----- (0804F65D) --------------------------------------------------------
int __usercall sub_804F65D@<eax>(char *a1@<ebx>, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, char *a10)
{
  int v10; // edx
  int v11; // ecx
  bool v12; // zf
  void *v13; // eax
  void *v14; // eax
  void *v15; // eax
  size_t v16; // eax
  char *v17; // edx
  int v18; // eax
  void *v19; // eax
  int v20; // eax
  void *v21; // eax
  bool v22; // al
  void *v23; // eax
  const unsigned __int16 *v24; // eax
  char *v25; // eax
  void *v26; // eax
  char *v27; // eax
  void *v28; // eax
  void *v29; // eax
  int v30; // edx
  int v31; // eax
  int result; // eax
  void *v33; // eax
  mbstate_t *v34; // edx
  unsigned int v35; // esi
  char *v36; // [esp-8h] [ebp-94h]
  int v37; // [esp-4h] [ebp-90h]
  char *s; // [esp+0h] [ebp-8Ch]
  void *s2; // [esp+4h] [ebp-88h]
  size_t n; // [esp+8h] [ebp-84h]
  mbstate_t *p; // [esp+Ch] [ebp-80h]
  int v42; // [esp+10h] [ebp-7Ch]
  unsigned int v43; // [esp+14h] [ebp-78h]
  int v44; // [esp+18h] [ebp-74h]
  unsigned int v45; // [esp+1Ch] [ebp-70h]
  char *v46; // [esp+20h] [ebp-6Ch]
  int v47; // [esp+24h] [ebp-68h]
  int v48; // [esp+28h] [ebp-64h]
  int v49; // [esp+2Ch] [ebp-60h]
  int v50; // [esp+30h] [ebp-5Ch]
  int v51; // [esp+34h] [ebp-58h]
  int v52; // [esp+38h] [ebp-54h]
  int v53; // [esp+3Ch] [ebp-50h]
  int v54; // [esp+40h] [ebp-4Ch]
  int v55; // [esp+44h] [ebp-48h]
  int v56; // [esp+48h] [ebp-44h]
  int v57; // [esp+4Ch] [ebp-40h]
  int v58; // [esp+50h] [ebp-3Ch]
  int v59; // [esp+54h] [ebp-38h]
  int v60; // [esp+58h] [ebp-34h]
  int v61; // [esp+5Ch] [ebp-30h]
  int v62; // [esp+60h] [ebp-2Ch]
  int v63; // [esp+64h] [ebp-28h]
  int v64; // [esp+68h] [ebp-24h]
  int v65; // [esp+6Ch] [ebp-20h]
  int v66; // [esp+70h] [ebp-1Ch]
  int v67; // [esp+74h] [ebp-18h]
  int v68; // [esp+78h] [ebp-14h]
  int v69; // [esp+7Ch] [ebp-10h]
  char *v70; // [esp+80h] [ebp-Ch]

  v70 = a1;
  v53 = a2;
  v52 = a4;
  v51 = a8;
  v50 = a9;
  *(&s - 23) = a10;
  *(&s - 3) = (char *)__readgsdword(0x14u);
  *(&s - 13) = 0;
  *(&s - 12) = 0;
  *(&s - 11) = 0;
  *(&s - 10) = 0;
  *((_BYTE *)&s - 72) = 0;
  *((_BYTE *)&s - 61) = __ctype_get_mb_cur_max() == 1;
  *((_BYTE *)&s - 71) = (v45 & 2) != 0;
  *((_BYTE *)&s - 70) = 0;
  *((_BYTE *)&s - 69) = 0;
  *((_BYTE *)&s - 68) = 1;
  while ( 1 )
  {
    switch ( v44 )
    {
      case 0:
        goto LABEL_30;
      case 1:
        goto LABEL_21;
      case 2:
        goto LABEL_25;
      case 3:
        *((_BYTE *)&s - 72) = 1;
LABEL_21:
        *((_BYTE *)&s - 71) = 1;
        goto LABEL_22;
      case 4:
LABEL_22:
        v12 = *((_BYTE *)&s - 71) == 1;
        v37 = *((unsigned __int8 *)&s - 71) ^ 1;
        v36 = a1;
        v14 = &loc_804F861;
        if ( v12 )
          v14 = &loc_804F865;
        dword_805C19C = (int)v14;
        a1 = v36;
        sub_8056234(v11, v10);
        *((_BYTE *)&s - 72) = 1;
LABEL_25:
        v44 = 2;
        if ( *((_BYTE *)&s - 71) != 1 )
        {
          if ( *(&s - 13) < (char *)p )
          {
            v10 = (int)*(&s - 19);
            (*(&s - 13))[v10] = 39;
          }
          ++*(&s - 13);
        }
        *(&s - 11) = "'";
        *(&s - 10) = (char *)1;
        dword_805C1C4 = (int)&loc_804F8BE;
        sub_805612D(v11, v10, s);
LABEL_30:
        *((_BYTE *)&s - 71) = 0;
        break;
      case 5:
        goto LABEL_4;
      case 6:
        v44 = 5;
        *((_BYTE *)&s - 71) = 1;
LABEL_4:
        if ( *((_BYTE *)&s - 71) != 1 )
        {
          if ( *(&s - 13) < (char *)p )
          {
            v10 = (int)*(&s - 19);
            (*(&s - 13))[v10] = 34;
          }
          ++*(&s - 13);
        }
        *((_BYTE *)&s - 72) = 1;
        *(&s - 11) = (char *)&unk_805748D;
        *(&s - 10) = (char *)1;
        break;
      case 7:
        *((_BYTE *)&s - 72) = 1;
        *((_BYTE *)&s - 71) = 0;
        break;
      case 8:
      case 9:
      case 10:
        if ( v44 != 10 )
        {
          *(&s - 22) = (char *)sub_804F5C2("`", v44);
          *(&s - 23) = (char *)sub_804F5C2("'", v44);
        }
        v12 = *((_BYTE *)&s - 71) == 1;
        v37 = *((unsigned __int8 *)&s - 71) ^ 1;
        v36 = a1;
        v13 = &loc_804F7E6;
        if ( v12 )
          v13 = &loc_804F818;
        dword_805C188 = (int)v13;
        a1 = v36;
        sub_80562A4(
          s,
          s2,
          n,
          p,
          v42,
          v43,
          v44,
          v45,
          v46,
          v47,
          v48,
          v49,
          v50,
          v51,
          v52,
          v53,
          v54,
          v55,
          v56,
          v57,
          v58,
          v59,
          v60,
          v61,
          v62,
          v63,
          v64,
          v65,
          v66,
          v67,
          v68,
          v69);
        for ( *(&s - 11) = *(&s - 22); **(&s - 11); ++*(&s - 11) )
        {
          if ( *(&s - 13) < (char *)p )
            (*(&s - 19))[(_DWORD)*(&s - 13)] = **(&s - 11);
          ++*(&s - 13);
        }
        *((_BYTE *)&s - 72) = 1;
        *(&s - 11) = *(&s - 23);
        s = *(&s - 11);
        *(&s - 10) = (char *)strlen(s);
        break;
      default:
        abort();
        return result;
    }
    *(&s - 14) = 0;
LABEL_179:
    if ( v43 == -1 )
    {
      v10 = (int)*(&s - 20);
      v31 = (unsigned __int8)(*(&s - 14))[v10];
      LOBYTE(v31) = (_BYTE)v31 != 0;
    }
    else
    {
      v31 = (int)*(&s - 14);
      LOBYTE(v31) = v31 != v43;
    }
    if ( (_BYTE)v31 )
      break;
    if ( !*(&s - 13) && v44 == 2 && *((_BYTE *)&s - 71) )
      goto LABEL_204;
    if ( v44 != 2 || *((_BYTE *)&s - 71) == 1 || !*((_BYTE *)&s - 69) )
      goto LABEL_211;
    if ( *((_BYTE *)&s - 68) )
    {
      v46 = *(&s - 23);
      v45 = (unsigned int)*(&s - 22);
      v44 = (int)*(&s - 21);
      v43 = v45;
      v42 = 5;
      p = (mbstate_t *)v45;
      n = (size_t)*(&s - 20);
      s2 = *(&s - 12);
      s = *(&s - 19);
      result = sub_804F65D(a1, (int)s, (int)s2, n, v45, 5, v45, v44, v45, v46);
      goto LABEL_208;
    }
    if ( p )
    {
LABEL_211:
      if ( *(&s - 11) && *((_BYTE *)&s - 71) != 1 )
      {
        dword_805C1B0 = (int)&loc_8050438;
        sub_80561A1(v11, v10);
        do
        {
          if ( *(&s - 13) < (char *)p )
            (*(&s - 19))[(_DWORD)*(&s - 13)] = **(&s - 11);
          ++*(&s - 13);
          ++*(&s - 11);
        }
        while ( **(&s - 11) );
      }
      if ( *(&s - 13) < (char *)p )
        (*(&s - 13))[(_DWORD)*(&s - 19)] = 0;
      result = (int)*(&s - 13);
      goto LABEL_208;
    }
    v12 = *(&s - 12) == 0;
    v37 = *((unsigned __int8 *)&s - 71) ^ 1;
    v36 = a1;
    v33 = &loc_80503DE;
    if ( v12 )
      v33 = &loc_80503F0;
    dword_805C19C = (int)v33;
    a1 = v36;
    sub_8056234(v11, v10);
    p = (mbstate_t *)*(&s - 12);
    *(&s - 13) = 0;
  }
  *((_BYTE *)&s - 65) = 0;
  *((_BYTE *)&s - 64) = 0;
  *((_BYTE *)&s - 63) = 0;
  v12 = *((_BYTE *)&s - 72) == 0;
  v37 = v31;
  v36 = a1;
  v15 = &loc_804F8F5;
  if ( v12 )
    v15 = &loc_804F961;
  dword_805C188 = (int)v15;
  a1 = v36;
  sub_80562A4(
    s,
    s2,
    n,
    p,
    v42,
    v43,
    v44,
    v45,
    v46,
    v47,
    v48,
    v49,
    v50,
    v51,
    v52,
    v53,
    v54,
    v55,
    v56,
    v57,
    v58,
    v59,
    v60,
    v61,
    v62,
    v63,
    v64,
    v65,
    v66,
    v67,
    v68,
    v69);
  if ( v44 != 2 && *(&s - 10) )
  {
    a1 = &(*(&s - 10))[(_DWORD)*(&s - 14)];
    if ( v43 != -1 || (unsigned int)*(&s - 10) <= 1 )
    {
      v16 = v43;
    }
    else
    {
      s = *(&s - 20);
      v16 = strlen(s);
      v43 = v16;
    }
    if ( (unsigned int)a1 <= v16 )
    {
      v17 = &(*(&s - 20))[(_DWORD)*(&s - 14)];
      n = (size_t)*(&s - 10);
      s2 = *(&s - 11);
      if ( !memcmp(v17, s2, n) )
      {
        if ( *((_BYTE *)&s - 71) )
          goto LABEL_204;
        *((_BYTE *)&s - 65) = 1;
      }
    }
  }
  v10 = (int)*(&s - 20);
  *((_BYTE *)&s - 67) = (*(&s - 14))[v10];
  v18 = *((unsigned __int8 *)&s - 67);
  switch ( v18 )
  {
    case 0:
      if ( *((_BYTE *)&s - 72) )
      {
        if ( *((_BYTE *)&s - 71) )
          goto LABEL_204;
        *((_BYTE *)&s - 64) = 1;
        if ( v44 == 2 && *((_BYTE *)&s - 70) != 1 )
        {
          if ( *(&s - 13) < (char *)p )
          {
            v10 = (int)*(&s - 19);
            (*(&s - 13))[v10] = 39;
          }
          if ( ++*(&s - 13) < (char *)p )
          {
            v10 = (int)*(&s - 19);
            (*(&s - 13))[v10] = 36;
          }
          if ( ++*(&s - 13) < (char *)p )
          {
            v10 = (int)*(&s - 19);
            (*(&s - 13))[v10] = 39;
          }
          ++*(&s - 13);
          *((_BYTE *)&s - 70) = 1;
        }
        if ( *(&s - 13) < (char *)p )
        {
          v10 = (int)*(&s - 19);
          (*(&s - 13))[v10] = 92;
        }
        ++*(&s - 13);
        if ( v44 != 2 && (unsigned int)(*(&s - 14) + 1) < v43 )
        {
          v10 = (int)(*(&s - 14) + 1);
          if ( (*(&s - 20))[v10] > 47 )
          {
            v10 = (int)(*(&s - 14) + 1);
            if ( (*(&s - 20))[v10] <= 57 )
            {
              if ( *(&s - 13) < (char *)p )
              {
                v10 = (int)*(&s - 19);
                (*(&s - 13))[v10] = 48;
              }
              if ( ++*(&s - 13) < (char *)p )
              {
                v10 = (int)*(&s - 19);
                (*(&s - 13))[v10] = 48;
              }
              ++*(&s - 13);
            }
          }
        }
        *((_BYTE *)&s - 67) = 48;
      }
      else if ( v45 & 1 )
      {
        goto LABEL_178;
      }
      dword_805C1C4 = (int)&loc_8050179;
      sub_805612D(v11, v10, s);
LABEL_71:
      if ( v44 == 2 )
      {
        if ( *((_BYTE *)&s - 71) )
        {
          dword_805C1B0 = (int)&loc_805045A;
          sub_80561A1(v11, v10);
        }
      }
      else if ( v44 == 5 )
      {
        if ( v45 & 4 )
        {
          if ( (unsigned int)(*(&s - 14) + 2) < v43 )
          {
            v10 = (int)(*(&s - 14) + 1);
            if ( (*(&s - 20))[v10] == 63 )
            {
              v10 = (int)(*(&s - 14) + 2);
              switch ( (*(&s - 20))[v10] )
              {
                case 33:
                case 39:
                case 40:
                case 41:
                case 45:
                case 47:
                case 60:
                case 61:
                case 62:
                  v12 = *((_BYTE *)&s - 71) == 0;
                  v37 = (*(&s - 20))[v10];
                  v36 = a1;
                  v19 = &loc_804FB4A;
                  if ( v12 )
                    v19 = &loc_804FB4F;
                  dword_805C1B0 = (int)v19;
                  a1 = v36;
                  sub_80561A1(v11, v10);
                  goto LABEL_204;
                default:
                  goto LABEL_148;
              }
            }
          }
        }
      }
      goto LABEL_148;
    case 7:
      *((_BYTE *)&s - 66) = 97;
      goto LABEL_99;
    case 8:
      *((_BYTE *)&s - 66) = 98;
      goto LABEL_99;
    case 9:
      *((_BYTE *)&s - 66) = 116;
      goto LABEL_96;
    case 10:
      *((_BYTE *)&s - 66) = 110;
      goto LABEL_96;
    case 11:
      *((_BYTE *)&s - 66) = 118;
      goto LABEL_99;
    case 12:
      *((_BYTE *)&s - 66) = 102;
      goto LABEL_99;
    case 13:
      *((_BYTE *)&s - 66) = 114;
LABEL_96:
      if ( v44 == 2 && *((_BYTE *)&s - 71) )
      {
        dword_805C174 = (int)&loc_805045A;
        sub_805631A();
      }
LABEL_99:
      if ( !*((_BYTE *)&s - 72) )
        goto LABEL_148;
      *((_BYTE *)&s - 67) = *((_BYTE *)&s - 66);
      goto LABEL_154;
    case 32:
      goto LABEL_107;
    case 33:
    case 34:
    case 36:
    case 38:
    case 40:
    case 41:
    case 42:
    case 59:
    case 60:
    case 61:
    case 62:
    case 91:
    case 94:
    case 96:
    case 124:
      goto LABEL_108;
    case 35:
    case 126:
      goto LABEL_106;
    case 37:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
    case 77:
    case 78:
    case 79:
    case 80:
    case 81:
    case 82:
    case 83:
    case 84:
    case 85:
    case 86:
    case 87:
    case 88:
    case 89:
    case 90:
    case 93:
    case 95:
    case 97:
    case 98:
    case 99:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 106:
    case 107:
    case 108:
    case 109:
    case 110:
    case 111:
    case 112:
    case 113:
    case 114:
    case 115:
    case 116:
    case 117:
    case 118:
    case 119:
    case 120:
    case 121:
    case 122:
      *((_BYTE *)&s - 63) = 1;
      goto LABEL_148;
    case 39:
      *((_BYTE *)&s - 69) = 1;
      *((_BYTE *)&s - 63) = 1;
      if ( v44 != 2 )
        goto LABEL_148;
      v12 = *((_BYTE *)&s - 71) == 0;
      v37 = v18;
      v36 = a1;
      v23 = &loc_804FCFD;
      if ( v12 )
        v23 = &loc_804FD02;
      dword_805C1B0 = (int)v23;
      a1 = v36;
      sub_80561A1(v11, v10);
      goto LABEL_204;
    case 63:
      goto LABEL_71;
    case 92:
      v20 = *((unsigned __int8 *)&s - 67);
      *((_BYTE *)&s - 66) = v20;
      v37 = v20;
      v36 = a1;
      v21 = &loc_804FC20;
      if ( v44 != 2 )
        v21 = &loc_804FC30;
      dword_805C1C4 = (int)v21;
      a1 = v36;
      sub_805612D(v11, v10, s);
      if ( !*((_BYTE *)&s - 71) )
        goto LABEL_167;
      goto LABEL_204;
    case 123:
    case 125:
      if ( v43 == -1 )
        v22 = (*(&s - 20))[1] != 0;
      else
        v22 = v43 != 1;
      if ( v22 )
        goto LABEL_148;
LABEL_106:
      if ( *(&s - 14) )
        goto LABEL_148;
LABEL_107:
      *((_BYTE *)&s - 63) = 1;
LABEL_108:
      if ( v44 != 2 || !*((_BYTE *)&s - 71) )
        goto LABEL_148;
      goto LABEL_204;
    default:
      if ( *((_BYTE *)&s - 61) )
      {
        *(&s - 9) = (char *)1;
        v24 = *__ctype_b_loc();
        v10 = 2 * *((unsigned __int8 *)&s - 67);
        *((_BYTE *)&s - 62) = (*(const unsigned __int16 *)((char *)v24 + v10) & 0x4000) != 0;
      }
      else
      {
        memset(&s - 5, 0, 8u);
        *(&s - 9) = 0;
        *((_BYTE *)&s - 62) = 1;
        if ( v43 == -1 )
        {
          s = *(&s - 20);
          v43 = strlen(s);
        }
        v25 = (char *)sub_8052F6A(
                        (wchar_t *)&s - 15,
                        &(*(&s - 20))[(unsigned int)&(*(&s - 14))[(_DWORD)*(&s - 9)]],
                        v43 - (unsigned int)&(*(&s - 14))[(_DWORD)*(&s - 9)],
                        (mbstate_t *)(&s - 5));
        *(&s - 7) = v25;
        v12 = *(&s - 7) == 0;
        v37 = (int)v25;
        v36 = a1;
        v26 = &loc_804FE7D;
        if ( !v12 )
          v26 = &loc_804FE82;
        dword_805C174 = (int)v26;
        a1 = v36;
        sub_805631A();
      }
      *((_BYTE *)&s - 63) = *((_BYTE *)&s - 62);
      if ( (unsigned int)*(&s - 9) <= 1 && (!*((_BYTE *)&s - 72) || *((_BYTE *)&s - 62) == 1) )
        goto LABEL_148;
      v27 = &(*(&s - 9))[(_DWORD)*(&s - 14)];
      *(&s - 6) = v27;
      v12 = *((_BYTE *)&s - 72) == 0;
      v37 = (int)v27;
      v36 = a1;
      v28 = &loc_804FFAF;
      if ( v12 )
        v28 = &loc_80500C2;
      dword_805C188 = (int)v28;
      a1 = v36;
      sub_80562A4(
        s,
        s2,
        n,
        p,
        v42,
        v43,
        v44,
        v45,
        v46,
        v47,
        v48,
        v49,
        v50,
        v51,
        v52,
        v53,
        v54,
        v55,
        v56,
        v57,
        v58,
        v59,
        v60,
        v61,
        v62,
        v63,
        v64,
        v65,
        v66,
        v67,
        v68,
        v69);
      if ( *((_BYTE *)&s - 62) == 1 )
      {
        if ( *((_BYTE *)&s - 65) )
        {
          if ( *(&s - 13) < (char *)p )
          {
            v10 = (int)*(&s - 19);
            (*(&s - 13))[v10] = 92;
          }
          ++*(&s - 13);
          *((_BYTE *)&s - 65) = 0;
        }
        if ( *(&s - 14) + 1 < *(&s - 6) )
        {
          if ( *((_BYTE *)&s - 70) && *((_BYTE *)&s - 64) != 1 )
          {
            if ( *(&s - 13) < (char *)p )
              (*(&s - 13))[(_DWORD)*(&s - 19)] = 39;
            if ( ++*(&s - 13) < (char *)p )
              (*(&s - 13))[(_DWORD)*(&s - 19)] = 39;
            ++*(&s - 13);
            *((_BYTE *)&s - 70) = 0;
          }
          if ( *(&s - 13) < (char *)p )
            (*(&s - 19))[(_DWORD)*(&s - 13)] = *((_BYTE *)&s - 67);
          ++*(&s - 13);
          ++*(&s - 14);
          v30 = (int)*(&s - 20);
          *((_BYTE *)&s - 67) = (*(&s - 14))[v30];
          dword_805C1B0 = (int)&loc_804FF90;
          sub_80561A1(v11, v30);
LABEL_148:
          if ( (*((_BYTE *)&s - 72) == 1 && v44 != 2 || *((_BYTE *)&s - 71) == 1)
            && *(&s - 21)
            && (v11 = *((_BYTE *)&s - 67) & 0x1F,
                v10 = *(_DWORD *)&(*(&s - 21))[4 * (unsigned __int8)(*((_BYTE *)&s - 67) >> 5)] >> v11,
                v10 & 1)
            || *((_BYTE *)&s - 65) == 1 )
          {
LABEL_154:
            if ( *((_BYTE *)&s - 71) )
              goto LABEL_204;
            *((_BYTE *)&s - 64) = 1;
            if ( v44 == 2 && *((_BYTE *)&s - 70) != 1 )
            {
              if ( *(&s - 13) < (char *)p )
              {
                v10 = (int)*(&s - 19);
                (*(&s - 13))[v10] = 39;
              }
              if ( ++*(&s - 13) < (char *)p )
              {
                v10 = (int)*(&s - 19);
                (*(&s - 13))[v10] = 36;
              }
              if ( ++*(&s - 13) < (char *)p )
              {
                v10 = (int)*(&s - 19);
                (*(&s - 13))[v10] = 39;
              }
              ++*(&s - 13);
              *((_BYTE *)&s - 70) = 1;
            }
            if ( *(&s - 13) < (char *)p )
            {
              v10 = (int)*(&s - 19);
              (*(&s - 13))[v10] = 92;
            }
            ++*(&s - 13);
          }
        }
LABEL_167:
        if ( *((_BYTE *)&s - 70) && *((_BYTE *)&s - 64) != 1 )
        {
          if ( *(&s - 13) < (char *)p )
          {
            v10 = (int)*(&s - 19);
            (*(&s - 13))[v10] = 39;
          }
          if ( ++*(&s - 13) < (char *)p )
          {
            v10 = (int)*(&s - 19);
            (*(&s - 13))[v10] = 39;
          }
          ++*(&s - 13);
          *((_BYTE *)&s - 70) = 0;
        }
        if ( *(&s - 13) < (char *)p )
        {
          v10 = (int)&(*(&s - 19))[(_DWORD)*(&s - 13)];
          *(_BYTE *)v10 = *((_BYTE *)&s - 67);
        }
        ++*(&s - 13);
        if ( *((_BYTE *)&s - 63) != 1 )
          *((_BYTE *)&s - 68) = 0;
LABEL_178:
        ++*(&s - 14);
        goto LABEL_179;
      }
      v12 = *((_BYTE *)&s - 71) == 0;
      v37 = *((unsigned __int8 *)&s - 62) ^ 1;
      v36 = a1;
      v29 = &loc_804FFDD;
      if ( v12 )
        v29 = &loc_804FFE2;
      dword_805C1C4 = (int)v29;
      a1 = v36;
      sub_805612D(v11, v10, s);
LABEL_204:
      if ( v44 == 2 && *((_BYTE *)&s - 72) )
        v44 = 4;
      v34 = (mbstate_t *)(v45 & 0xFFFFFFFD);
      v46 = *(&s - 23);
      v45 = (unsigned int)*(&s - 22);
      v44 = 0;
      v43 = (unsigned int)v34;
      v42 = 0;
      p = v34;
      n = (size_t)*(&s - 20);
      s2 = v34;
      s = *(&s - 19);
      result = sub_804F65D(a1, (int)s, v43, n, v43, 0, v43, 0, v45, v46);
LABEL_208:
      v35 = __readgsdword(0x14u) ^ (unsigned int)*(&s - 3);
      return result;
  }
}
// 80561A1: using guessed type int __fastcall sub_80561A1(_DWORD, _DWORD);
// 80562A4: using guessed type int __stdcall sub_80562A4(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 805631A: using guessed type int sub_805631A(void);
// 805C174: using guessed type int dword_805C174;
// 805C188: using guessed type int dword_805C188;
// 805C19C: using guessed type int dword_805C19C;
// 805C1B0: using guessed type int dword_805C1B0;
// 805C1C4: using guessed type int dword_805C1C4;

//----- (080505F9) --------------------------------------------------------
#error "8050712: call analysis failed (funcsize=83)"

//----- (08050725) --------------------------------------------------------
#error "805076A: positive sp value has been found (funcsize=0)"

//----- (08050805) --------------------------------------------------------
void *__cdecl sub_8050805(signed int a1, int a2, int a3, int a4)
{
  int v4; // edx
  int v5; // ecx
  void *v6; // eax
  int v7; // ecx
  size_t v8; // edx
  void *v9; // edx
  unsigned int v10; // ST4C_4
  bool v12; // [esp+37h] [ebp-21h]
  int *v13; // [esp+38h] [ebp-20h]
  int *v14; // [esp+38h] [ebp-20h]
  void *ptr; // [esp+3Ch] [ebp-1Ch]
  int v16; // [esp+40h] [ebp-18h]
  int size; // [esp+44h] [ebp-14h]
  int v18; // [esp+48h] [ebp-10h]
  unsigned int v19; // [esp+4Ch] [ebp-Ch]

  v16 = *__errno_location();
  v13 = off_805C248;
  if ( a1 < 0 )
    abort();
  v6 = &loc_805084C;
  if ( dword_805C23C > a1 )
    v6 = &loc_8050930;
  dword_805C19C = (int)v6;
  sub_8056234(v5, v4);
  v12 = v13 == &dword_805C240;
  if ( (unsigned int)a1 > 0xFFFFFFE )
    sub_8052665();
  v8 = 8 * (a1 + 1);
  if ( v12 )
  {
    dword_805C1B0 = (int)&loc_805089A;
    sub_80561A1(v7, v8);
  }
  v14 = (int *)sub_805253F(v13, v8);
  off_805C248 = v14;
  if ( v12 )
  {
    v9 = off_805C244;
    *v14 = dword_805C240;
    v14[1] = (int)v9;
  }
  memset(&v14[2 * dword_805C23C], 0, 8 * (a1 + 1 - dword_805C23C));
  dword_805C23C = a1 + 1;
  v10 = v14[2 * a1];
  ptr = (void *)v14[2 * a1 + 1];
  v18 = *(_DWORD *)(a4 + 4) | 1;
  v19 = sub_804F65D(
          (char *)(a4 + 8),
          (int)ptr,
          v10,
          a2,
          a3,
          *(_DWORD *)a4,
          v18,
          a4 + 8,
          *(_DWORD *)(a4 + 40),
          *(char **)(a4 + 44));
  if ( v10 <= v19 )
  {
    size = v19 + 1;
    v14[2 * a1] = v19 + 1;
    if ( ptr != &unk_805CCC2 )
      free(ptr);
    ptr = sub_80524E9(size);
    v14[2 * a1 + 1] = (int)ptr;
    sub_804F65D(
      (char *)(a4 + 8),
      (int)ptr,
      size,
      a2,
      a3,
      *(_DWORD *)a4,
      v18,
      a4 + 8,
      *(_DWORD *)(a4 + 40),
      *(char **)(a4 + 44));
  }
  *__errno_location() = v16;
  return ptr;
}
// 80561A1: using guessed type int __fastcall sub_80561A1(_DWORD, _DWORD);
// 805C19C: using guessed type int dword_805C19C;
// 805C1B0: using guessed type int dword_805C1B0;
// 805C23C: using guessed type int dword_805C23C;
// 805C240: using guessed type int dword_805C240;
// 805C244: using guessed type void *off_805C244;
// 805C248: using guessed type int *off_805C248;

//----- (08050AD8) --------------------------------------------------------
void *__cdecl sub_8050AD8(signed int a1, int a2)
{
  return sub_8050805(a1, a2, -1, (int)&dword_805CC82);
}
// 805CC82: using guessed type int dword_805CC82;

//----- (08050B02) --------------------------------------------------------
void *__cdecl sub_8050B02(signed int a1, int a2, int a3)
{
  return sub_8050805(a1, a2, a3, (int)&dword_805CC82);
}
// 805CC82: using guessed type int dword_805CC82;

//----- (08050B78) --------------------------------------------------------
void *__cdecl sub_8050B78(signed int a1, int a2, int a3)
{
  char v4; // [esp+10h] [ebp-38h]

  sub_804F4DB(&v4, a2);
  return sub_8050805(a1, a3, -1, (int)&v4);
}
// 804F4DB: using guessed type int __cdecl sub_804F4DB(_DWORD, _DWORD);

//----- (08050BB6) --------------------------------------------------------
void *__cdecl sub_8050BB6(signed int a1, int a2, int a3, int a4)
{
  char v5; // [esp+10h] [ebp-38h]

  sub_804F4DB(&v5, a2);
  return sub_8050805(a1, a3, a4, (int)&v5);
}
// 804F4DB: using guessed type int __cdecl sub_804F4DB(_DWORD, _DWORD);

//----- (08050C4E) --------------------------------------------------------
#error "8050CF6: call analysis failed (funcsize=45)"

//----- (08050CFB) --------------------------------------------------------
#error "8050D3C: positive sp value has been found (funcsize=0)"

//----- (08050D3D) --------------------------------------------------------
int __cdecl sub_8050D3D(int a1, char a2)
{
  return sub_8050C4E(a1, -1, a2);
}
// 8050C4E: using guessed type _DWORD __cdecl sub_8050C4E(_DWORD, _DWORD, _DWORD);

//----- (08050D76) --------------------------------------------------------
int __cdecl sub_8050D76(int a1)
{
  return sub_8050D3D(a1, 58);
}

//----- (08050DB3) --------------------------------------------------------
#error "8050E4A: call analysis failed (funcsize=47)"

//----- (08050E4F) --------------------------------------------------------
#error "8050E88: positive sp value has been found (funcsize=0)"

//----- (08050E89) --------------------------------------------------------
void *__cdecl sub_8050E89(signed int a1, int a2, int a3, int a4)
{
  return sub_8050EC9(a1, a2, a3, a4, -1);
}

//----- (08050EC9) --------------------------------------------------------
void *__cdecl sub_8050EC9(signed int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [esp+0h] [ebp-48h]
  int v7; // [esp+10h] [ebp-38h]
  int v8; // [esp+14h] [ebp-34h]
  int v9; // [esp+18h] [ebp-30h]
  int v10; // [esp+1Ch] [ebp-2Ch]
  int v11; // [esp+20h] [ebp-28h]
  int v12; // [esp+24h] [ebp-24h]
  int v13; // [esp+28h] [ebp-20h]
  int v14; // [esp+2Ch] [ebp-1Ch]
  int v15; // [esp+30h] [ebp-18h]
  int v16; // [esp+34h] [ebp-14h]
  int v17; // [esp+38h] [ebp-10h]
  int v18; // [esp+3Ch] [ebp-Ch]

  v7 = dword_805CC82;
  v8 = dword_805CC86;
  v9 = dword_805CC8A;
  v10 = dword_805CC8E;
  v11 = dword_805CC92;
  v12 = dword_805CC96;
  v13 = dword_805CC9A;
  v14 = dword_805CC9E;
  v15 = dword_805CCA2;
  v16 = dword_805CCA6;
  v17 = dword_805CCAA;
  v18 = dword_805CCAE;
  sub_804F49A(&v6 - 14, a2, a3);
  return sub_8050805(a1, a4, a5, (int)&v7);
}
// 805CC82: using guessed type int dword_805CC82;
// 805CC86: using guessed type int dword_805CC86;
// 805CC8A: using guessed type int dword_805CC8A;
// 805CC8E: using guessed type int dword_805CC8E;
// 805CC92: using guessed type int dword_805CC92;
// 805CC96: using guessed type int dword_805CC96;
// 805CC9A: using guessed type int dword_805CC9A;
// 805CC9E: using guessed type int dword_805CC9E;
// 805CCA2: using guessed type int dword_805CCA2;
// 805CCA6: using guessed type int dword_805CCA6;
// 805CCAA: using guessed type int dword_805CCAA;
// 805CCAE: using guessed type int dword_805CCAE;

//----- (0805101D) --------------------------------------------------------
#error "805125B: call analysis failed (funcsize=178)"

//----- (08051407) --------------------------------------------------------
void *__cdecl sub_8051407(signed int a1, int a2)
{
  return sub_8055533(a1, a2, -1);
}

//----- (08051429) --------------------------------------------------------
void *__cdecl sub_8051429(int a1)
{
  return sub_8051407(0, a1);
}

//----- (08051444) --------------------------------------------------------
char *__cdecl sub_8051444(FILE *stream, int a2)
{
  int v2; // eax
  __int64 v3; // rax
  int v4; // ecx
  __int64 v5; // rax
  size_t n; // ST28_4
  size_t v8; // ST2C_4
  int v9; // ST24_4
  int v10; // edx
  int v11; // ecx
  int v12; // [esp+0h] [ebp-A8h]
  int v13; // [esp+0h] [ebp-A8h]
  char *ptr; // [esp+10h] [ebp-98h]
  unsigned int size; // [esp+14h] [ebp-94h]
  unsigned int v16; // [esp+18h] [ebp-90h]
  signed int v17; // [esp+1Ch] [ebp-8Ch]
  char *v18; // [esp+28h] [ebp-80h]
  char *v19; // [esp+2Ch] [ebp-7Ch]
  __int64 v20; // [esp+30h] [ebp-78h]
  __int64 v21; // [esp+38h] [ebp-70h]
  char v22; // [esp+40h] [ebp-68h]
  int v23; // [esp+50h] [ebp-58h]
  __int64 v24; // [esp+6Ch] [ebp-3Ch]

  size = 0x2000;
  v2 = fileno(stream);
  if ( sub_8055F7C(v2, (int)&v22) >= 0 && (v23 & 0xF000) == 0x8000 )
  {
    LODWORD(v3) = ftello64(stream);
    v20 = v3;
    if ( v3 >= 0 && v24 > v3 )
    {
      v5 = v24 - v3;
      v21 = v24 - v20;
      if ( (((unsigned __int64)(v24 - v20) >> 32) & 0x80000000) == 0LL )
      {
        LODWORD(v5) = &loc_80514F9;
        if ( SHIDWORD(v21) > 0 )
          LODWORD(v5) = &loc_80514FF;
        dword_805C1C4 = v5;
        sub_805612D(v4, HIDWORD(v5), v12);
        if ( (unsigned int)v21 > 0xFFFFFFFE )
        {
          *__errno_location() = 12;
          return 0;
        }
      }
      size = v21 + 1;
    }
  }
  ptr = (char *)malloc(size);
  if ( !ptr )
    return 0;
  v16 = 0;
  while ( 1 )
  {
    n = size - v16;
    v8 = fread(&ptr[v16], 1u, size - v16, stream);
    v16 += v8;
    if ( v8 != n )
      break;
    if ( size == -1 )
    {
      v17 = 12;
LABEL_29:
      free(ptr);
      *__errno_location() = v17;
      return 0;
    }
    if ( ~(size >> 1) <= size )
      size = -1;
    else
      size += size >> 1;
    v19 = (char *)realloc(ptr, size);
    if ( !v19 )
    {
      v17 = *__errno_location();
      goto LABEL_29;
    }
    ptr = v19;
  }
  v9 = *__errno_location();
  if ( ferror(stream) )
  {
    dword_805C1C4 = (int)&loc_80516F1;
    sub_805612D(v11, v10, v13);
  }
  if ( size - 1 > v16 )
  {
    v18 = (char *)realloc(ptr, v16 + 1);
    if ( v18 )
      ptr = v18;
  }
  ptr[v16] = 0;
  *(_DWORD *)a2 = v16;
  return ptr;
}
// 8049280: using guessed type int __cdecl ftello64(_DWORD);
// 805C1C4: using guessed type int dword_805C1C4;

//----- (08051713) --------------------------------------------------------
char *__cdecl sub_8051713(int a1, int a2, int a3)
{
  int v4; // [esp+14h] [ebp-14h]
  FILE *stream; // [esp+18h] [ebp-10h]
  char *ptr; // [esp+1Ch] [ebp-Ch]

  stream = (FILE *)fopen64(a1, a3);
  if ( !stream )
    return 0;
  ptr = sub_8051444(stream, a2);
  v4 = *__errno_location();
  if ( !sub_8052CF6(stream) )
    return ptr;
  if ( ptr )
  {
    v4 = *__errno_location();
    free(ptr);
  }
  *__errno_location() = v4;
  return 0;
}
// 8049160: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (0805179A) --------------------------------------------------------
char *__cdecl sub_805179A(int a1, int a2)
{
  return sub_8051713(a1, a2, (int)&unk_80577BC);
}

//----- (080517DE) --------------------------------------------------------
char *__cdecl sub_80517DE(char *a1, int a2)
{
  char *v2; // ebx
  size_t v3; // eax
  char *v4; // ebx
  bool v5; // zf
  int v6; // edx
  int v7; // ecx
  void *v8; // eax
  void *v9; // eax
  size_t v10; // eax
  size_t v11; // edx
  char *s; // [esp+Ch] [ebp-5Ch]
  int v14; // [esp+10h] [ebp-58h]
  char *v15; // [esp+14h] [ebp-54h]
  char *i; // [esp+18h] [ebp-50h]
  char *v17; // [esp+1Ch] [ebp-4Ch]
  size_t v18; // [esp+20h] [ebp-48h]
  char v19; // [esp+24h] [ebp-44h]
  int v20; // [esp+28h] [ebp-40h]
  char j; // [esp+30h] [ebp-38h]
  char *v22; // [esp+34h] [ebp-34h]
  int v23; // [esp+38h] [ebp-30h]
  char v24; // [esp+3Ch] [ebp-2Ch]
  wint_t wc; // [esp+40h] [ebp-28h]
  unsigned int v26; // [esp+5Ch] [ebp-Ch]

  s = a1;
  v26 = __readgsdword(0x14u);
  v17 = strdup(a1);
  if ( !v17 )
    sub_8052665();
  if ( __ctype_get_mb_cur_max() <= 1 )
  {
    if ( a2 )
    {
      for ( i = v17; *i && (*__ctype_b_loc())[(unsigned __int8)*i] & 0x2000; ++i )
        ;
      v10 = strlen(i);
      memmove(v17, i, v10 + 1);
    }
    if ( a2 != 1 )
    {
      v11 = strlen(v17) - 1;
      for ( i = &v17[v11]; i >= v17 && (*__ctype_b_loc())[(unsigned __int8)*i] & 0x2000; --i )
        *i = 0;
    }
  }
  else
  {
    if ( a2 )
    {
      v22 = v17;
      v2 = v17;
      v18 = (size_t)&v2[strlen(v17)];
      v19 = 0;
      memset(&v20, 0, 8u);
      for ( j = 0; (unsigned int)v22 < v18; j = 0 )
      {
        sub_805377A((int)&v18);
        if ( !v24 || !iswspace(wc) )
          break;
        v22 += v23;
      }
      v3 = strlen(v22);
      memmove(v17, v22, v3 + 1);
    }
    if ( a2 != 1 )
    {
      v14 = 0;
      v22 = v17;
      v4 = v17;
      v18 = (size_t)&v4[strlen(v17)];
      v19 = 0;
      memset(&v20, 0, 8u);
      j = 0;
      while ( (unsigned int)v22 < v18 )
      {
        sub_805377A((int)&v18);
        v9 = &loc_8051A44;
        if ( v14 )
          v9 = &loc_8051948;
        dword_805C174 = (int)v9;
        sub_805631A();
        if ( !v24 || !iswspace(wc) )
        {
          if ( v14 || v24 == 1 && iswspace(wc) )
          {
            if ( v14 == 1 )
            {
              if ( v24 == 1 )
              {
                v5 = iswspace(wc) == 0;
                v8 = &loc_80519AD;
                if ( !v5 )
                  v8 = &loc_80519AF;
                dword_805C19C = (int)v8;
                sub_8056234(v7, v6);
              }
            }
            else if ( v14 == 1 && v24 && iswspace(wc) )
            {
              v14 = 2;
              v15 = v22;
            }
            else if ( v14 != 2 || !v24 || !iswspace(wc) )
            {
              v14 = 1;
            }
          }
          else
          {
            v14 = 1;
          }
        }
        v22 += v23;
        j = 0;
      }
      if ( v14 == 2 )
      {
        *v15 = 0;
        dword_805C160 = (int)&loc_8051B47;
        sub_8056386();
      }
    }
  }
  return v17;
}
// 805631A: using guessed type int sub_805631A(void);
// 8056386: using guessed type int sub_8056386(void);
// 805C160: using guessed type int dword_805C160;
// 805C174: using guessed type int dword_805C174;
// 805C19C: using guessed type int dword_805C19C;

//----- (08051B61) --------------------------------------------------------
int __cdecl sub_8051B61(FILE *stream, int a2, int a3, int a4, int a5, int a6)
{
  char *v6; // eax
  char *v7; // ebx
  char *v8; // eax
  int result; // eax
  int v10; // esi
  char *v11; // ebx
  char *v12; // eax
  int v13; // edi
  int v14; // esi
  char *v15; // ebx
  char *v16; // eax
  int v17; // edi
  int v18; // esi
  char *v19; // ebx
  char *v20; // eax
  int v21; // edi
  int v22; // esi
  char *v23; // ebx
  char *v24; // eax
  int v25; // edi
  int v26; // esi
  char *v27; // ebx
  int v28; // esi
  int v29; // edi
  char *v30; // ebx
  char *v31; // eax
  int v32; // edi
  int v33; // esi
  char *v34; // ebx
  char *v35; // eax
  int v36; // edi
  int v37; // esi
  char *v38; // ebx
  char *v39; // eax
  int v40; // edi
  int v41; // esi
  char *v42; // ebx
  char *v43; // [esp+4h] [ebp-64h]
  char *v44; // [esp+8h] [ebp-60h]
  int v45; // [esp+Ch] [ebp-5Ch]
  int v46; // [esp+10h] [ebp-58h]
  int v47; // [esp+14h] [ebp-54h]
  int v48; // [esp+18h] [ebp-50h]
  int v49; // [esp+1Ch] [ebp-4Ch]
  int v50; // [esp+20h] [ebp-48h]
  int v51; // [esp+24h] [ebp-44h]
  int v52; // [esp+28h] [ebp-40h]
  int v53; // [esp+38h] [ebp-30h]
  int v54; // [esp+3Ch] [ebp-2Ch]
  int v55; // [esp+40h] [ebp-28h]
  int v56; // [esp+44h] [ebp-24h]
  int v57; // [esp+48h] [ebp-20h]
  int v58; // [esp+4Ch] [ebp-1Ch]

  if ( a2 )
  {
    v46 = a4;
    fprintf(stream, "%s (%s) %s\n", a2, a3, a4);
  }
  else
  {
    fprintf(stream, "%s %s\n", a3, a4);
  }
  v45 = 2017;
  v44 = gettext("(C)");
  fprintf(stream, "Copyright %s %d Free Software Foundation, Inc.", v44, 2017);
  v6 = gettext(
         "\n"
         "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\n"
         "This is free software: you are free to change and redistribute it.\n"
         "There is NO WARRANTY, to the extent permitted by law.\n"
         "\n");
  fputs_unlocked(v6, stream);
  switch ( a6 )
  {
    case 0:
      abort();
      return result;
    case 1:
      v7 = *(char **)a5;
      v8 = gettext("Written by %s.\n");
      result = fprintf(stream, v8, v7);
      break;
    case 2:
      v10 = *(_DWORD *)(a5 + 4);
      v11 = *(char **)a5;
      v12 = gettext("Written by %s and %s.\n");
      result = fprintf(stream, v12, v11, v10);
      break;
    case 3:
      v13 = *(_DWORD *)(a5 + 8);
      v14 = *(_DWORD *)(a5 + 4);
      v15 = *(char **)a5;
      v16 = gettext("Written by %s, %s, and %s.\n");
      result = fprintf(stream, v16, v15, v14, v13);
      break;
    case 4:
      v58 = *(_DWORD *)(a5 + 12);
      v17 = *(_DWORD *)(a5 + 8);
      v18 = *(_DWORD *)(a5 + 4);
      v19 = *(char **)a5;
      v20 = gettext("Written by %s, %s, %s,\nand %s.\n");
      v47 = v58;
      v46 = v17;
      v45 = v18;
      v44 = v19;
      result = fprintf(stream, v20, v19, v18, v17, v58);
      break;
    case 5:
      v58 = *(_DWORD *)(a5 + 16);
      v57 = *(_DWORD *)(a5 + 12);
      v21 = *(_DWORD *)(a5 + 8);
      v22 = *(_DWORD *)(a5 + 4);
      v23 = *(char **)a5;
      v24 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
      v46 = v21;
      v45 = v22;
      v44 = v23;
      result = fprintf(stream, v24, v23, v22, v21, v57, v58);
      break;
    case 6:
      v58 = *(_DWORD *)(a5 + 20);
      v57 = *(_DWORD *)(a5 + 16);
      v56 = *(_DWORD *)(a5 + 12);
      v25 = *(_DWORD *)(a5 + 8);
      v26 = *(_DWORD *)(a5 + 4);
      v27 = *(char **)a5;
      v49 = v58;
      v48 = v57;
      v47 = v56;
      v46 = v25;
      v45 = v26;
      v44 = v27;
      v43 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
      result = fprintf(stream, v43, v27, v26, v25, v56, v57, v58);
      break;
    case 7:
      v28 = *(_DWORD *)(a5 + 24);
      v58 = *(_DWORD *)(a5 + 20);
      v57 = *(_DWORD *)(a5 + 16);
      v56 = *(_DWORD *)(a5 + 12);
      v55 = *(_DWORD *)(a5 + 8);
      v29 = *(_DWORD *)(a5 + 4);
      v30 = *(char **)a5;
      v31 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
      v45 = v29;
      v44 = v30;
      result = fprintf(stream, v31, v30, v29, v55, v56, v57, v58, v28);
      break;
    case 8:
      v32 = *(_DWORD *)(a5 + 28);
      v58 = *(_DWORD *)(a5 + 24);
      v57 = *(_DWORD *)(a5 + 20);
      v56 = *(_DWORD *)(a5 + 16);
      v55 = *(_DWORD *)(a5 + 12);
      v54 = *(_DWORD *)(a5 + 8);
      v33 = *(_DWORD *)(a5 + 4);
      v34 = *(char **)a5;
      v35 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
      v51 = v32;
      v50 = v58;
      v49 = v57;
      v48 = v56;
      v47 = v55;
      v46 = v54;
      v45 = v33;
      v44 = v34;
      result = fprintf(stream, v35, v34, v33, v54, v55, v56, v57, v58, v32);
      break;
    case 9:
      v36 = *(_DWORD *)(a5 + 32);
      v58 = *(_DWORD *)(a5 + 28);
      v57 = *(_DWORD *)(a5 + 24);
      v56 = *(_DWORD *)(a5 + 20);
      v55 = *(_DWORD *)(a5 + 16);
      v54 = *(_DWORD *)(a5 + 12);
      v53 = *(_DWORD *)(a5 + 8);
      v37 = *(_DWORD *)(a5 + 4);
      v38 = *(char **)a5;
      v39 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
      v52 = v36;
      v51 = v58;
      v50 = v57;
      v49 = v56;
      v48 = v55;
      v44 = v38;
      result = fprintf(stream, v39, v38, v37, v53, v54, v55, v56, v57, v58, v36);
      break;
    default:
      v40 = *(_DWORD *)(a5 + 32);
      v58 = *(_DWORD *)(a5 + 28);
      v57 = *(_DWORD *)(a5 + 24);
      v56 = *(_DWORD *)(a5 + 20);
      v55 = *(_DWORD *)(a5 + 16);
      v54 = *(_DWORD *)(a5 + 12);
      v53 = *(_DWORD *)(a5 + 8);
      v41 = *(_DWORD *)(a5 + 4);
      v42 = *(char **)a5;
      v52 = v40;
      v51 = v58;
      v50 = v57;
      v49 = v56;
      v48 = v55;
      v47 = v54;
      v46 = v53;
      v45 = v41;
      v44 = v42;
      v43 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
      result = fprintf(stream, v43, v42, v41, v53, v54, v55, v56, v57, v58, v40);
      break;
  }
  return result;
}
// 80492B0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0805228B) --------------------------------------------------------
int __cdecl sub_805228B(FILE *stream, int a2, int a3, int a4, int a5)
{
  int *v5; // eax
  int v7; // [esp+24h] [ebp-34h]
  int v8[12]; // [esp+28h] [ebp-30h]

  v7 = 0;
  dword_805C174 = (int)&loc_80522B3;
  sub_805631A();
  do
  {
    if ( (unsigned int)++v7 > 9 )
      break;
    v5 = (int *)a5;
    a5 += 4;
    v8[v7] = *v5;
  }
  while ( v8[v7] );
  return sub_8051B61(stream, a2, a3, a4, (int)v8, v7);
}
// 805631A: using guessed type int sub_805631A(void);
// 805C174: using guessed type int dword_805C174;
// 805228B: using guessed type int var_30[12];

//----- (08052316) --------------------------------------------------------
int sub_8052316(FILE *stream, int a2, int a3, int a4, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a4);
  return sub_805228B(stream, a2, a3, a4, (int)va);
}

//----- (080523D6) --------------------------------------------------------
void *__cdecl sub_80523D6(unsigned int a1, unsigned int a2)
{
  if ( 0x7FFFFFFF / a2 < a1 )
    sub_8052665();
  return sub_80524FC(a2 * a1);
}

//----- (08052439) --------------------------------------------------------
#error "8052461: call analysis failed (funcsize=43)"

//----- (080524E9) --------------------------------------------------------
void *__cdecl sub_80524E9(size_t size)
{
  return sub_80524FC(size);
}

//----- (080524FC) --------------------------------------------------------
void *__cdecl sub_80524FC(size_t size)
{
  void *v1; // eax
  bool v2; // zf
  void *v3; // eax
  void *v5; // [esp+1Ch] [ebp-Ch]

  v1 = malloc(size);
  v5 = v1;
  v2 = v1 == 0;
  v3 = &loc_805252F;
  if ( !v2 )
    v3 = &loc_805253A;
  dword_805C174 = (int)v3;
  sub_805631A();
  if ( size )
    sub_8052665();
  return v5;
}
// 805631A: using guessed type int sub_805631A(void);
// 805C174: using guessed type int dword_805C174;

//----- (0805253F) --------------------------------------------------------
void *__cdecl sub_805253F(void *ptr, size_t size)
{
  void *result; // eax
  void *ptra; // [esp+20h] [ebp+8h]

  if ( size || !ptr )
  {
    ptra = realloc(ptr, size);
    if ( !ptra )
    {
      if ( size )
        sub_8052665();
    }
    result = ptra;
  }
  else
  {
    free(ptr);
    result = 0;
  }
  return result;
}

//----- (08052617) --------------------------------------------------------
void *__cdecl sub_8052617(void *src, size_t n)
{
  void *v2; // eax

  v2 = sub_80524FC(n);
  return memcpy(v2, src, n);
}

//----- (08052665) --------------------------------------------------------
void __noreturn sub_8052665()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (08052741) --------------------------------------------------------
char *__cdecl sub_8052741(char *s, char *fromcode, char *tocode)
{
  char *v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_8055593(s, fromcode, tocode);
  if ( !v4 && *__errno_location() == 12 )
    sub_8052665();
  return v4;
}

//----- (0805277F) --------------------------------------------------------
signed int __cdecl sub_805277F(unsigned int *a1, int a2)
{
  unsigned int v2; // ebx
  unsigned int v3; // esi
  signed __int64 v4; // rax
  signed int result; // eax
  __int64 v6; // rcx
  int v7; // edx
  int v8; // esi
  unsigned __int64 v9; // rax
  __int64 v10; // [esp+8h] [ebp-24h]
  __int64 v11; // [esp+8h] [ebp-24h]

  v2 = *a1;
  v3 = a1[1];
  v10 = a2;
  LODWORD(v4) = sub_8055CF2(0, 2147483648, a2);
  if ( (signed __int64)__PAIR__(v3, v2) >= v4 )
  {
    v11 = SHIDWORD(v10);
    LODWORD(v6) = sub_8055CF2(-1, 0x7FFFFFFF, v11);
    HIDWORD(v6) = v7;
    if ( v6 >= *(_QWORD *)v11 )
    {
      v8 = HIDWORD(v11) * *(_DWORD *)(v11 + 4) + *(_DWORD *)v11 * (SHIDWORD(v11) >> 31);
      v9 = *(unsigned int *)v11 * (unsigned __int64)HIDWORD(v11);
      *(_DWORD *)v11 = v9;
      *(_DWORD *)(v11 + 4) = v8 + HIDWORD(v9);
      result = 0;
    }
    else
    {
      *(_DWORD *)v11 = -1;
      *(_DWORD *)(v11 + 4) = 0x7FFFFFFF;
      result = 1;
    }
  }
  else
  {
    *(_DWORD *)v10 = 0;
    *(_DWORD *)(v10 + 4) = 2147483648;
    result = 1;
  }
  return result;
}
// 8055CF2: using guessed type _DWORD __cdecl sub_8055CF2(_DWORD, _DWORD, _DWORD);

//----- (08052899) --------------------------------------------------------
int __cdecl sub_8052899(unsigned int *a1, int a2, int a3)
{
  int v3; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; ; i |= sub_805277F(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}

//----- (080528CF) --------------------------------------------------------
int __usercall sub_80528CF@<eax>(int a1@<edx>, int a2@<ecx>, char *nptr, int a4, int base, int a6, char *s)
{
  void *v7; // eax
  int v8; // edx
  int v9; // ecx
  void *v10; // eax
  void *v11; // eax
  int result; // eax
  int v13; // edx
  int v14; // edx
  int v15; // ecx
  int v16; // edx
  int v17; // eax
  int v18; // edx
  int v19; // edx
  int v20; // [esp+0h] [ebp-38h]
  char v21; // [esp+10h] [ebp-28h]
  int v22; // [esp+14h] [ebp-24h]
  int v23; // [esp+18h] [ebp-20h]
  int v24; // [esp+1Ch] [ebp-1Ch]
  int v25; // [esp+20h] [ebp-18h]
  char **endptr; // [esp+24h] [ebp-14h]
  intmax_t v27; // [esp+28h] [ebp-10h]

  v22 = 0;
  if ( base < 0 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoimax");
  v7 = &loc_8052901;
  if ( base > 36 )
    v7 = &loc_8052922;
  dword_805C19C = (int)v7;
  sub_8056234(a2, a1);
  v10 = &loc_8052920;
  if ( a4 )
    v10 = &loc_805294B;
  dword_805C1C4 = (int)v10;
  sub_805612D(v9, v8, v20);
  endptr = (char **)&v21;
  *__errno_location() = 0;
  v27 = strtoimax(nptr, endptr, base);
  if ( *endptr == nptr )
  {
    v11 = &loc_80529A4;
    if ( !s )
      v11 = &loc_80529DE;
    dword_805C174 = (int)v11;
    sub_805631A();
    if ( !**endptr || !strchr(s, **endptr) )
      return 4;
    v27 = 1LL;
  }
  else if ( *__errno_location() )
  {
    if ( *__errno_location() != 34 )
      return 4;
    v22 = 1;
  }
  if ( !s )
  {
    v13 = HIDWORD(v27);
    *(_DWORD *)a6 = v27;
    *(_DWORD *)(a6 + 4) = v13;
    return v22;
  }
  if ( !**endptr )
  {
LABEL_50:
    v19 = HIDWORD(v27);
    *(_DWORD *)a6 = v27;
    *(_DWORD *)(a6 + 4) = v19;
    return v22;
  }
  v23 = 1024;
  v24 = 1;
  if ( !strchr(s, **endptr) )
  {
    v16 = HIDWORD(v27);
    *(_DWORD *)a6 = v27;
    *(_DWORD *)(a6 + 4) = v16;
    return v22 | 2;
  }
  switch ( **endptr )
  {
    case 69:
    case 71:
    case 75:
    case 77:
    case 80:
    case 84:
    case 89:
    case 90:
    case 103:
    case 107:
    case 109:
    case 116:
      if ( strchr(s, 48) )
      {
        v17 = (*endptr)[1];
        switch ( v17 )
        {
          case 68:
            goto LABEL_53;
          case 105:
            if ( (*endptr)[2] == 66 )
              v24 += 2;
            goto LABEL_34;
          case 66:
LABEL_53:
            v23 = 1000;
            ++v24;
            break;
        }
      }
      break;
    default:
      break;
  }
LABEL_34:
  switch ( **endptr )
  {
    case 66:
      v25 = sub_805277F((unsigned int *)&v27, 1024);
      goto LABEL_48;
    case 69:
      goto LABEL_38;
    case 71:
    case 103:
      v25 = sub_8052899((unsigned int *)&v27, v23, 3);
      goto LABEL_48;
    case 75:
    case 107:
      v25 = sub_8052899((unsigned int *)&v27, v23, 1);
      goto LABEL_48;
    case 77:
    case 109:
      v25 = sub_8052899((unsigned int *)&v27, v23, 2);
      goto LABEL_48;
    case 80:
      v25 = sub_8052899((unsigned int *)&v27, v23, 5);
      goto LABEL_48;
    case 84:
    case 116:
      v25 = sub_8052899((unsigned int *)&v27, v23, 4);
      goto LABEL_48;
    case 89:
      v25 = sub_8052899((unsigned int *)&v27, v23, 8);
      goto LABEL_48;
    case 90:
      v25 = sub_8052899((unsigned int *)&v27, v23, 7);
      goto LABEL_48;
    case 98:
      v25 = sub_805277F((unsigned int *)&v27, 512);
      goto LABEL_48;
    case 99:
      v25 = 0;
      dword_805C1B0 = (int)&loc_8052C9E;
      sub_80561A1(v15, v14);
LABEL_38:
      v25 = sub_8052899((unsigned int *)&v27, v23, 6);
      goto LABEL_48;
    case 119:
      v25 = sub_805277F((unsigned int *)&v27, 2);
LABEL_48:
      v22 |= v25;
      *endptr += v24;
      if ( **endptr )
        v22 |= 2u;
      goto LABEL_50;
    default:
      v18 = HIDWORD(v27);
      *(_DWORD *)a6 = v27;
      *(_DWORD *)(a6 + 4) = v18;
      result = v22 | 2;
      break;
  }
  return result;
}
// 80528CF: could not find valid save-restore pair for ebx
// 80561A1: using guessed type int __fastcall sub_80561A1(_DWORD, _DWORD);
// 805631A: using guessed type int sub_805631A(void);
// 805C174: using guessed type int dword_805C174;
// 805C19C: using guessed type int dword_805C19C;
// 805C1B0: using guessed type int dword_805C1B0;
// 805C1C4: using guessed type int dword_805C1C4;

//----- (08052CF6) --------------------------------------------------------
#error "8052D51: call analysis failed (funcsize=63)"

//----- (08052DD2) --------------------------------------------------------
int __cdecl sub_8052DD2(FILE *stream)
{
  int result; // eax

  result = stream->_flags & 0x100;
  if ( result )
    result = sub_8052E4B(stream, 0, 0, 1);
  return result;
}

//----- (08052E0B) --------------------------------------------------------
int __cdecl sub_8052E0B(FILE *fp)
{
  if ( !fp || !__freading(fp) )
    return fflush(fp);
  sub_8052DD2(fp);
  return fflush(fp);
}

//----- (08052E4B) --------------------------------------------------------
int __cdecl sub_8052E4B(FILE *stream, int a2, int a3, int a4)
{
  int v4; // eax
  __off64_t v5; // rax
  int v7; // [esp+0h] [ebp-38h]

  if ( stream->_IO_read_end == stream->_IO_read_ptr
    && stream->_IO_write_ptr == stream->_IO_write_base
    && !stream->_IO_save_base )
  {
    v4 = fileno(stream);
    LODWORD(v5) = lseek64(v4, a2, a3, a4);
    if ( v5 == -1 )
      return -1;
    stream->_flags &= 0xFFFFFFEF;
    stream->_offset = v5;
    dword_805C1C4 = (int)&locret_8052F68;
    sub_805612D(stream, HIDWORD(v5), v7);
  }
  return fseeko64(stream, a2, a3, a4);
}
// 80490F0: using guessed type int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8049430: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 805C1C4: using guessed type int dword_805C1C4;

//----- (08052F6A) --------------------------------------------------------
size_t __cdecl sub_8052F6A(wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  char v5; // [esp+18h] [ebp-10h]
  size_t v6; // [esp+1Ch] [ebp-Ch]

  if ( !pwc )
    pwc = (wchar_t *)&v5;
  v6 = mbrtowc(pwc, s, n, p);
  if ( v6 <= 0xFFFFFFFD || !n || !((unsigned __int8)sub_80530D7(0) ^ 1) )
    return v6;
  *pwc = (unsigned __int8)*s;
  return 1;
}

//----- (08052FDC) --------------------------------------------------------
#error "805302B: call analysis failed (funcsize=43)"

//----- (08053056) --------------------------------------------------------
int __cdecl sub_8053056(FILE *fp)
{
  bool v1; // ST1E_1
  bool v3; // [esp+1Dh] [ebp-Bh]
  bool v4; // [esp+1Fh] [ebp-9h]

  v3 = __fpending(fp) != 0;
  v1 = ferror_unlocked(fp) != 0;
  v4 = sub_8052CF6(fp) != 0;
  if ( !v1 && (!v4 || !v3 && *__errno_location() == 9) )
    return 0;
  if ( v4 != 1 )
    *__errno_location() = 0;
  return -1;
}

//----- (080530D7) --------------------------------------------------------
int __cdecl sub_80530D7(int category)
{
  unsigned __int8 v2; // [esp+1Bh] [ebp-Dh]
  const char *s1; // [esp+1Ch] [ebp-Ch]

  v2 = 1;
  s1 = setlocale(category, 0);
  if ( s1 && (!strcmp(s1, "C") || !strcmp(s1, "POSIX")) )
    v2 = 0;
  return v2;
}

//----- (08053135) --------------------------------------------------------
void *sub_8053135()
{
  _BOOL4 v0; // eax
  void *v1; // eax
  int v2; // edx
  int v3; // ecx
  bool v4; // zf
  void *v5; // eax
  void *v6; // eax
  int v7; // edx
  int v8; // ecx
  void *v9; // eax
  void *ptr; // [esp+14h] [ebp-B4h]
  void *v12; // [esp+18h] [ebp-B0h]
  char *s; // [esp+1Ch] [ebp-ACh]
  void *v14; // [esp+20h] [ebp-A8h]
  int v15; // [esp+24h] [ebp-A4h]
  char *v16; // [esp+28h] [ebp-A0h]
  size_t n; // [esp+2Ch] [ebp-9Ch]
  size_t v18; // [esp+30h] [ebp-98h]
  _BOOL4 v19; // [esp+34h] [ebp-94h]
  void *dest; // [esp+38h] [ebp-90h]
  int fd; // [esp+3Ch] [ebp-8Ch]
  FILE *stream; // [esp+40h] [ebp-88h]
  int c; // [esp+44h] [ebp-84h]
  unsigned int v24; // [esp+BCh] [ebp-Ch]

  v24 = __readgsdword(0x14u);
  v12 = (void *)dword_805CDC2;
  if ( !dword_805CDC2 )
  {
    ptr = 0;
    v16 = "charset.alias";
    s = getenv("CHARSETALIASDIR");
    if ( !s || !*s )
    {
      ptr = 0;
      s = "/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib";
    }
    n = strlen(s);
    v18 = strlen(v16);
    v0 = n && s[n - 1] != 47;
    v19 = v0;
    v1 = malloc(n + v0 + v18 + 1);
    dest = v1;
    v4 = v1 == 0;
    v5 = &loc_8053266;
    if ( v4 )
      v5 = &loc_80532E7;
    dword_805C1B0 = (int)v5;
    sub_80561A1(v3, v2);
    memcpy(dest, s, n);
    if ( v19 )
      *((_BYTE *)dest + n) = 47;
    memcpy((char *)dest + n + v19, v16, v18 + 1);
    free(ptr);
    if ( dest )
    {
      fd = open64(dest, 0x20000);
      if ( fd >= 0 )
      {
        stream = fdopen(fd, "r");
        if ( stream )
        {
          v14 = 0;
          v15 = 0;
          while ( 1 )
          {
            c = getc_unlocked(stream);
            if ( c == -1 )
              break;
            if ( c != 10 && c != 32 && c != 9 )
            {
              v6 = &loc_80533FB;
              if ( c != 35 )
                v6 = &loc_805344D;
              dword_805C160 = (int)v6;
              sub_8056386();
              do
                c = getc_unlocked(stream);
              while ( c != -1 && c != 10 );
              v9 = &loc_8053443;
              if ( c != -1 )
                v9 = &loc_8053448;
              dword_805C1B0 = (int)v9;
              sub_80561A1(v8, v7);
              break;
            }
          }
          sub_8052CF6(stream);
          if ( v15 )
          {
            *((_BYTE *)v14 + v15) = 0;
            v12 = v14;
          }
          else
          {
            v12 = &unk_8057D87;
          }
        }
        else
        {
          close(fd);
          v12 = &unk_8057D87;
        }
      }
      else
      {
        v12 = &unk_8057D87;
      }
      free(dest);
    }
    else
    {
      v12 = &unk_8057D87;
    }
    dword_805CDC2 = (int)v12;
  }
  return v12;
}
// 8049000: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 80561A1: using guessed type int __fastcall sub_80561A1(_DWORD, _DWORD);
// 8056386: using guessed type int sub_8056386(void);
// 805C160: using guessed type int dword_805C160;
// 805C1B0: using guessed type int dword_805C1B0;
// 805CDC2: using guessed type int dword_805CDC2;

//----- (08053699) --------------------------------------------------------
char *sub_8053699()
{
  bool v0; // zf
  void *v1; // eax
  int v2; // edx
  int v3; // ecx
  char *v4; // ST24_4
  int v6; // [esp+0h] [ebp-28h]
  char *s1; // [esp+18h] [ebp-10h]
  char *s2; // [esp+1Ch] [ebp-Ch]

  v0 = nl_langinfo(14) == 0;
  v1 = &loc_80536CD;
  if ( !v0 )
    v1 = &loc_80536D4;
  dword_805C160 = (int)v1;
  sub_8056386();
  s1 = (char *)&unk_8057D87;
  s2 = (char *)sub_8053135();
  dword_805C1C4 = (int)&loc_805375A;
  sub_805612D(v3, v2, v6);
  while ( strcmp((const char *)&unk_8057D87, s2) && (*s2 != 42 || s2[1]) )
  {
    v4 = &s2[strlen(s2) + 1];
    s2 = &v4[strlen(v4) + 1];
    if ( !*s2 )
      goto LABEL_9;
  }
  s1 = &s2[strlen(s2) + 1];
LABEL_9:
  if ( !*s1 )
    s1 = "ASCII";
  return s1;
}
// 8056386: using guessed type int sub_8056386(void);
// 805C160: using guessed type int dword_805C160;
// 805C1C4: using guessed type int dword_805C1C4;

//----- (0805377A) --------------------------------------------------------
int __cdecl sub_805377A(int a1)
{
  int result; // eax

  result = *(unsigned __int8 *)(a1 + 16);
  if ( !(_BYTE)result )
  {
    if ( !*(_BYTE *)(a1 + 4) )
    {
      if ( sub_8055BD8(**(_BYTE **)(a1 + 20)) )
      {
        *(_DWORD *)(a1 + 24) = 1;
        *(_DWORD *)(a1 + 32) = **(char **)(a1 + 20);
        *(_BYTE *)(a1 + 28) = 1;
LABEL_19:
        result = a1;
        *(_BYTE *)(a1 + 16) = 1;
        return result;
      }
      if ( !mbsinit((const mbstate_t *)(a1 + 8)) )
        __assert_fail("mbsinit (&iter->state)", "lib/mbiter.h", 0x8Eu, "mbiter_multi_next");
      *(_BYTE *)(a1 + 4) = 1;
    }
    *(_DWORD *)(a1 + 24) = sub_8052F6A(
                             (wchar_t *)(a1 + 32),
                             *(char **)(a1 + 20),
                             *(_DWORD *)a1 - *(_DWORD *)(a1 + 20),
                             (mbstate_t *)(a1 + 8));
    if ( *(_DWORD *)(a1 + 24) == -1 )
    {
      *(_DWORD *)(a1 + 24) = 1;
      *(_BYTE *)(a1 + 28) = 0;
      dword_805C160 = (int)&loc_80539B3;
      sub_8056386();
    }
    if ( *(_DWORD *)(a1 + 24) == -2 )
    {
      *(_DWORD *)(a1 + 24) = *(_DWORD *)a1 - *(_DWORD *)(a1 + 20);
      *(_BYTE *)(a1 + 28) = 0;
    }
    else
    {
      if ( !*(_DWORD *)(a1 + 24) )
      {
        *(_DWORD *)(a1 + 24) = 1;
        if ( **(_BYTE **)(a1 + 20) )
          __assert_fail("*iter->cur.ptr == '\\0'", "lib/mbiter.h", 0xA9u, "mbiter_multi_next");
        if ( *(_DWORD *)(a1 + 32) )
          __assert_fail("iter->cur.wc == 0", "lib/mbiter.h", 0xAAu, "mbiter_multi_next");
      }
      *(_BYTE *)(a1 + 28) = 1;
      if ( mbsinit((const mbstate_t *)(a1 + 8)) )
        *(_BYTE *)(a1 + 4) = 0;
    }
    goto LABEL_19;
  }
  return result;
}
// 8056386: using guessed type int sub_8056386(void);
// 805C160: using guessed type int dword_805C160;

//----- (08053AE2) --------------------------------------------------------
#error "8053C48: call analysis failed (funcsize=163)"

//----- (08053D4A) --------------------------------------------------------
#error "8054150: call analysis failed (funcsize=352)"

//----- (08054553) --------------------------------------------------------
#error "805494C: call analysis failed (funcsize=365)"

//----- (08054DE8) --------------------------------------------------------
int __cdecl sub_8054DE8(int a1)
{
  int result; // eax
  size_t v2; // eax
  size_t v3; // eax
  size_t v4; // eax
  int v5; // ecx
  int v6; // edx
  void *v7; // eax
  bool v8; // zf
  void *v9; // eax
  const char *v10; // [esp+0h] [ebp-18h]

  result = *(unsigned __int8 *)(a1 + 12);
  if ( !(_BYTE)result )
  {
    if ( !*(_BYTE *)a1 )
    {
      if ( sub_8055BD8(**(_BYTE **)(a1 + 16)) )
      {
        *(_DWORD *)(a1 + 20) = 1;
        *(_DWORD *)(a1 + 28) = **(char **)(a1 + 16);
        *(_BYTE *)(a1 + 24) = 1;
LABEL_22:
        result = a1;
        *(_BYTE *)(a1 + 12) = 1;
        return result;
      }
      if ( !mbsinit((const mbstate_t *)(a1 + 4)) )
        __assert_fail("mbsinit (&iter->state)", "lib/mbuiter.h", 0x96u, "mbuiter_multi_next");
      *(_BYTE *)a1 = 1;
    }
    v2 = __ctype_get_mb_cur_max();
    v3 = sub_8055678(*(void **)(a1 + 16), v2);
    v4 = sub_8052F6A((wchar_t *)(a1 + 28), *(char **)(a1 + 16), v3, (mbstate_t *)(a1 + 4));
    v6 = a1;
    *(_DWORD *)(a1 + 20) = v4;
    if ( *(_DWORD *)(a1 + 20) == -1 )
    {
      *(_DWORD *)(a1 + 20) = 1;
      *(_BYTE *)(a1 + 24) = 0;
      dword_805C160 = (int)&loc_8055013;
      sub_8056386();
    }
    if ( *(_DWORD *)(a1 + 20) == -2 )
    {
      v10 = *(const char **)(a1 + 16);
      *(_DWORD *)(a1 + 20) = strlen(v10);
      *(_BYTE *)(a1 + 24) = 0;
    }
    else
    {
      if ( !*(_DWORD *)(a1 + 20) )
      {
        *(_DWORD *)(a1 + 20) = 1;
        if ( **(_BYTE **)(a1 + 16) )
          __assert_fail("*iter->cur.ptr == '\\0'", "lib/mbuiter.h", 0xB2u, "mbuiter_multi_next");
        v7 = &loc_8054FB7;
        if ( !*(_DWORD *)(a1 + 28) )
          v7 = &loc_8054FDB;
        dword_805C1C4 = (int)v7;
        sub_805612D(v5, v6, v10);
        __assert_fail("iter->cur.wc == 0", "lib/mbuiter.h", 0xB3u, "mbuiter_multi_next");
      }
      *(_BYTE *)(a1 + 24) = 1;
      v8 = mbsinit((const mbstate_t *)(a1 + 4)) == 0;
      v9 = &loc_805500D;
      if ( v8 )
        v9 = &loc_8055013;
      dword_805C174 = (int)v9;
      sub_805631A();
      *(_BYTE *)a1 = 0;
    }
    goto LABEL_22;
  }
  return result;
}
// 805631A: using guessed type int sub_805631A(void);
// 8056386: using guessed type int sub_8056386(void);
// 805C160: using guessed type int dword_805C160;
// 805C174: using guessed type int dword_805C174;
// 805C1C4: using guessed type int dword_805C1C4;

//----- (080550D8) --------------------------------------------------------
#error "80550F7: call analysis failed (funcsize=12)"

//----- (080550FC) --------------------------------------------------------
#error "80553FF: call analysis failed (funcsize=198)"

//----- (08055533) --------------------------------------------------------
void *__cdecl sub_8055533(signed int a1, int a2, int a3)
{
  return sub_8050805(a1, a2, a3, (int)&unk_805C25C);
}

//----- (08055593) --------------------------------------------------------
char *__cdecl sub_8055593(char *s, char *fromcode, char *tocode)
{
  char *result; // eax
  int v4; // ST24_4
  int v5; // ST28_4
  iconv_t cd; // [esp+1Ch] [ebp-1Ch]
  void *ptr; // [esp+20h] [ebp-18h]
  char *v8; // [esp+2Ch] [ebp-Ch]

  if ( *s && sub_8052FDC((unsigned __int8 *)fromcode, (unsigned __int8 *)tocode) )
  {
    cd = iconv_open(tocode, fromcode);
    if ( cd == (iconv_t)-1 )
      return 0;
    ptr = (void *)sub_805101D(s, cd);
    if ( ptr )
    {
      if ( iconv_close(cd) < 0 )
      {
        v5 = *__errno_location();
        free(ptr);
        *__errno_location() = v5;
        return 0;
      }
    }
    else
    {
      v4 = *__errno_location();
      iconv_close(cd);
      *__errno_location() = v4;
    }
    result = (char *)ptr;
  }
  else
  {
    v8 = strdup(s);
    if ( !v8 )
      *__errno_location() = 12;
    result = v8;
  }
  return result;
}

//----- (08055678) --------------------------------------------------------
size_t __cdecl sub_8055678(void *s, size_t n)
{
  size_t result; // eax
  _BYTE *v3; // [esp+1Ch] [ebp-Ch]

  v3 = memchr(s, 0, n);
  if ( v3 )
    result = v3 - (_BYTE *)s + 1;
  else
    result = n;
  return result;
}

//----- (080558BA) --------------------------------------------------------
int __cdecl sub_80558BA(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 65) > 0x19 )
    result = a1;
  else
    result = a1 + 32;
  return result;
}

//----- (080558F0) --------------------------------------------------------
#error "8055977: call analysis failed (funcsize=46)"

//----- (08055A0D) --------------------------------------------------------
#error "8055A4F: call analysis failed (funcsize=23)"

//----- (08055B2F) --------------------------------------------------------
int __cdecl sub_8055B2F(int a1, int a2)
{
  void *v2; // eax
  int result; // eax

  if ( *(_DWORD *)a2 == a2 + 16 )
  {
    memcpy((void *)(a1 + 16), (const void *)(a2 + 16), *(_DWORD *)(a2 + 4));
    *(_DWORD *)a1 = a1 + 16;
  }
  else
  {
    *(_DWORD *)a1 = *(_DWORD *)a2;
  }
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  *(_BYTE *)(a1 + 8) = *(_BYTE *)(a2 + 8);
  v2 = &loc_8055BCA;
  if ( !*(_BYTE *)(a1 + 8) )
    v2 = &locret_8055BD6;
  dword_805C174 = (int)v2;
  sub_805631A();
  result = a1;
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
  return result;
}
// 805631A: using guessed type int sub_805631A(void);
// 805C174: using guessed type int dword_805C174;

//----- (08055BD8) --------------------------------------------------------
bool __cdecl sub_8055BD8(unsigned __int8 a1)
{
  return (((unsigned int)dword_8057F48[a1 >> 5] >> (a1 & 0x1F)) & 1) != 0;
}

//----- (08055C2F) --------------------------------------------------------
size_t __cdecl sub_8055C2F(const char *a1)
{
  _BOOL4 v1; // eax
  int v3; // [esp+10h] [ebp-48h]
  char v4; // [esp+14h] [ebp-44h]
  int v5; // [esp+18h] [ebp-40h]
  char i; // [esp+20h] [ebp-38h]
  const char *v7; // [esp+24h] [ebp-34h]
  int v8; // [esp+28h] [ebp-30h]
  char v9; // [esp+2Ch] [ebp-2Ch]
  int v10; // [esp+30h] [ebp-28h]
  unsigned int v11; // [esp+4Ch] [ebp-Ch]

  v11 = __readgsdword(0x14u);
  if ( __ctype_get_mb_cur_max() <= 1 )
    return strlen(a1);
  v3 = 0;
  v7 = a1;
  v4 = 0;
  memset(&v5, 0, 8u);
  for ( i = 0; ; i = 0 )
  {
    sub_8054DE8((int)&v4);
    v1 = v9 != 1 || v10;
    if ( !v1 )
      break;
    ++v3;
    v7 += v8;
  }
  return v3;
}

//----- (08055CF2) --------------------------------------------------------
#error "8055D27: call analysis failed (funcsize=18)"

//----- (08055D2C) --------------------------------------------------------
#error "8055D93: positive sp value has been found (funcsize=40)"

//----- (08055F4D) --------------------------------------------------------
int __cdecl sub_8055F4D(int a1)
{
  return __cxa_atexit(a1, 0, dword_805C200);
}
// 80491F0: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 805C200: using guessed type int dword_805C200;

//----- (08055F7C) --------------------------------------------------------
int __cdecl sub_8055F7C(int a1, int a2)
{
  return __fxstat64(3, a1, a2);
}
// 8049190: using guessed type int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD);

//----- (0805612D) --------------------------------------------------------
#error "8056133: positive sp value has been found (funcsize=0)"

//----- (080561A1) --------------------------------------------------------
#error "80561A7: positive sp value has been found (funcsize=0)"

//----- (080561F3) --------------------------------------------------------
#error "805622C: positive sp value has been found (funcsize=18)"

//----- (08056234) --------------------------------------------------------
#error "805623A: positive sp value has been found (funcsize=0)"

//----- (080562A4) --------------------------------------------------------
#error "80562AA: positive sp value has been found (funcsize=0)"

//----- (0805631A) --------------------------------------------------------
#error "8056320: positive sp value has been found (funcsize=0)"

//----- (08056386) --------------------------------------------------------
#error "805638C: positive sp value has been found (funcsize=0)"

//----- (080563A0) --------------------------------------------------------
int (**sub_80563A0())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_805BEE0;
  v1 = &off_805BEE4 - off_805BEE0;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_805BEE0[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 805BEE0: using guessed type int (*off_805BEE0[2])();
// 805BEE4: using guessed type int (*off_805BEE4)();

//----- (08056404) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 47 decompilation failure(s) on 163 function(s)"
