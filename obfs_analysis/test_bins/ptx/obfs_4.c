/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8048FC0();
// int dup2(int fd, int fd2);
// int strcmp(const char *s1, const char *s2);
// int __cdecl open64(_DWORD, _DWORD); weak
// int putc_unlocked(int c, FILE *stream);
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void _exit(int status);
// void *memmove(void *dest, const void *src, size_t n);
// void free(void *ptr);
// char *strdup(const char *s);
// void *memcpy(void *dest, const void *src, size_t n);
// int mbsinit(const mbstate_t *ps);
// int ferror(FILE *stream);
// int fclose(FILE *stream);
// int getc_unlocked(FILE *stream);
// intmax_t strtoimax(const char *nptr, char **endptr, int base);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// char *textdomain(const char *domainname);
// int __cdecl fopen64(_DWORD, _DWORD); weak
// int ferror_unlocked(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD); weak
// size_t __ctype_get_mb_cur_max(void);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// size_t __fpending(FILE *fp);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// void error(int status, int errnum, const char *format, ...);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int re_match(struct re_pattern_buffer *buffer, const char *string, int length, int start, struct re_registers *regs);
// int __freading(FILE *fp);
// int iswspace(wint_t wc);
// void exit(int status);
// int __cdecl ftello64(_DWORD); weak
// char *gettext(const char *msgid);
// FILE *fdopen(int fd, const char *modes);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// char *strchr(const char *s, int c);
// int fscanf(FILE *stream, const char *format, ...);
// size_t strlen(const char *s);
// size_t iconv(iconv_t cd, char **inbuf, size_t *inbytesleft, char **outbuf, size_t *outbytesleft);
// int iconv_close(iconv_t cd);
// int fprintf(FILE *stream, const char *format, ...);
// int re_search(struct re_pattern_buffer *buffer, const char *string, int length, int start, int range, struct re_registers *regs);
// int re_compile_fastmap(struct re_pattern_buffer *buffer);
// void *memset(void *s, int c, size_t n);
// int ungetc(int c, FILE *stream);
// int iswalnum(wint_t wc);
// int *__errno_location(void);
// void *memchr(const void *s, int c, size_t n);
// int fileno(FILE *stream);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// int __cdecl strnlen(_DWORD, _DWORD); weak
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// int toupper(int c);
// char *strrchr(const char *s, int c);
// int sprintf(char *s, const char *format, ...);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// const char *re_compile_pattern(const char *pattern, size_t length, struct re_pattern_buffer *buffer);
// char *bindtextdomain(const char *domainname, const char *dirname);
// int strncmp(const char *s1, const char *s2, size_t n);
// void abort(void);
// iconv_t iconv_open(const char *tocode, const char *fromcode);
// int close(int fd);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// int putchar_unlocked(int c);
// int _gmon_start__(void); weak
void sub_8049533();
void sub_8049550();
int sub_8049560();
int sub_80495D0();
int sub_80495F0();
void sub_804964F();
void sub_804966A();
signed int sub_804967A();
void sub_804975C();
void sub_8049777();
int sub_8049787();
void sub_8049869();
void sub_8049884();
int sub_8049894();
void sub_8049976();
void sub_8049991();
int sub_80499A1();
void sub_8049A95();
void sub_8049AB0();
void sub_8049BCD();
void sub_8049BE8();
int sub_8049BF8();
void sub_8049CDA();
void sub_8049CF5();
int sub_8049D05();
int sub_8049D8F();
// int __usercall sub_8049DD0@<eax>(void (__cdecl *a1)(int *)@<eax>);
void sub_8049E2E();
void sub_8049E49();
int sub_8049E59();
void sub_8049F57();
void sub_8049F72();
int sub_8049F82();
int nullsub_3(void); // weak
int sub_8049FE0();
void sub_804A092();
void sub_804A0AD();
int __fastcall sub_804A0BD(int a1, int a2);
int __fastcall sub_804A160(int a1, int a2);
void sub_804A1E6();
void sub_804A201();
// int __usercall sub_804A291@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>);
void sub_804A341();
void sub_804A35C();
int sub_804A36C();
_DWORD nullsub_5(); // weak
// int __usercall sub_804A3D3@<eax>(int a1@<eax>, int (__cdecl *a2)(void **, int)@<edx>);
void sub_804A483();
void sub_804A49E();
int sub_804A4AE();
int __cdecl sub_804A55E(unsigned __int8 a1);
int sub_804A570();
int sub_804A59B();
int sub_804A5C6();
char *__cdecl sub_804A791(char *a1);
char *__cdecl sub_804A7C1(char *s);
int __cdecl sub_804AB82(int a1);
char *sub_804AC86();
int __cdecl sub_804AE20(char *s1, int); // idb
int sub_804AF1A(const void *, const void *); // idb
int compar(const void *, const void *); // idb
int __cdecl sub_804B10E(void *, int); // idb
void sub_804B1E2();
void __cdecl sub_804B21B(char *s1);
void __cdecl sub_804B2AE(char *s1, int a2);
_DWORD __cdecl sub_804B40B(_DWORD); // weak
int __cdecl sub_804BC0F(int a1);
_DWORD __cdecl sub_804BC35(_DWORD, _DWORD); // weak
unsigned int sub_804C0E8();
int sub_804D1BD();
int sub_804DB2B(void); // weak
void __cdecl __noreturn sub_804DC6A(int status); // idb
int __cdecl main(int argc, char **argv);
void __noreturn sub_804E7F5();
int __cdecl sub_804E809(char *s, int, int, size_t); // idb
// void __usercall sub_804E997(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5);
int __cdecl sub_804EA33(int, int, size_t n); // idb
int __cdecl sub_804EB6C(int, char *s, int, int, size_t n, int); // idb
int sub_804EC9C();
signed int __cdecl sub_804ED80(int a1);
int __cdecl sub_804EDCF(int, int, FILE *stream); // idb
int __cdecl sub_804EFD4(char *s); // idb
// int __usercall sub_804F0DB@<eax>(int a1@<ebx>, unsigned __int8 *a2, int a3);
int __cdecl sub_804F79E(char *msgid, char *); // idb
_DWORD __cdecl sub_804FB20(_DWORD, _DWORD); // weak
int *__cdecl sub_804FC0F(int *a1, int a2, int a3);
_DWORD __cdecl sub_804FC50(_DWORD, _DWORD); // weak
char *__cdecl sub_804FD27(char *msgid, int a2);
_DWORD __cdecl sub_804FE0F(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl sub_8051090(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_805138C(int a1, int a2);
int __cdecl sub_8051441(int a1, int a2, int a3);
int __cdecl sub_805147F(int a1, int a2, int a3, int a4);
int __cdecl sub_8051517(int a1, int a2, char a3);
int __cdecl sub_80515F1(int a1, char a2);
int __cdecl sub_805162A(int a1);
int __cdecl sub_8051667(int a1, int a2, int a3);
int __cdecl sub_8051728(int a1, int a2, int a3, int a4);
int __cdecl sub_8051778(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_80518B2(int a1, int a2, int a3);
int __cdecl sub_805190D(int a1, int a2);
int __cdecl sub_805192F(int a1);
int __cdecl sub_805194A(FILE *stream);
void *__cdecl sub_8051C47(int a1, int a2, int a3);
void *__cdecl sub_8051CCE(int a1, int a2);
_DWORD __cdecl sub_8051D12(_DWORD, _DWORD); // weak
int __cdecl sub_8052080(FILE *stream, int, int, int, int, int); // idb
int __cdecl sub_8052834(FILE *stream, int, int, int, int); // idb
int sub_80528BA(FILE *stream, int a2, int a3, int a4, ...);
void *__cdecl sub_805297A(unsigned int a1, unsigned int a2);
void *__cdecl sub_80529DD(void *ptr, int a2, int a3);
void *__cdecl sub_8052A8D(size_t size);
void *__cdecl sub_8052AA0(size_t size);
void *__cdecl sub_8052ACA(void *ptr, size_t size);
void *__cdecl sub_8052BD4(void *src, size_t n);
void __noreturn sub_8052C22();
int __cdecl sub_8052CFE(char *s, char *fromcode, char *tocode); // idb
_DWORD __cdecl sub_8052D55(_DWORD, _DWORD); // weak
int __cdecl sub_8052E88(int a1, int a2, int a3);
int __cdecl sub_8052EBE(char *nptr, int, int base, int, char *s); // idb
int __cdecl sub_805330B(FILE *stream); // idb
int __cdecl sub_805342B(FILE *stream); // idb
int __cdecl sub_8053464(FILE *fp); // idb
int __cdecl sub_80534BD(FILE *stream, int, int, int); // idb
size_t __cdecl sub_80535EC(wchar_t *pwc, char *s, size_t n, mbstate_t *p);
int __cdecl sub_805365E(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_80536D8(FILE *fp); // idb
int __cdecl sub_8053759(int category); // idb
int sub_80537D0(void); // weak
const char *sub_8053D4F();
int __cdecl sub_8053E02(int a1);
// signed int __usercall sub_8054181@<eax>(unsigned int a1@<edx>, int a2@<ecx>, _BYTE *a3, int a4, unsigned int a5, _DWORD *a6);
// unsigned __int8 *__usercall sub_8054C36@<eax>(int a1@<ebx>, unsigned __int8 *a2, _BYTE *a3);
_DWORD __cdecl sub_8055570(_DWORD); // weak
int __cdecl sub_8055CD8(char *s, iconv_t cd); // idb
int __cdecl sub_805603E(char *s, char *fromcode, char *tocode); // idb
int __cdecl sub_805614E(void *s, size_t n); // idb
int __cdecl sub_8056450(int a1);
_DWORD __cdecl sub_8056486(_DWORD); // weak
_DWORD __cdecl sub_8056554(_DWORD); // weak
int __cdecl sub_8056661(int a1, int a2);
bool __cdecl sub_805671A(unsigned __int8 a1);
size_t __cdecl sub_8056781(const char *a1);
_DWORD __cdecl sub_8056844(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_8056A9F(int a1);
int __cdecl sub_8056ACE(int a1, int a2);
int sub_8056C61(void); // weak
int __fastcall sub_8056CD9(_DWORD, _DWORD);
int __stdcall sub_8056D4D(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_8056DBD(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_8056E4A(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __fastcall sub_8056EB8(_DWORD, _DWORD); // weak
int __stdcall sub_8056F2E(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_8056FC1(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __fastcall sub_8057037(_DWORD, _DWORD, _DWORD);
int sub_80570A9(void); // weak
int (**sub_80570C0())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN locret_804A0CC; // weak
_UNKNOWN loc_804A686; // weak
_UNKNOWN loc_804A840; // weak
_UNKNOWN loc_804A866; // weak
_UNKNOWN loc_804A86B; // weak
_UNKNOWN loc_804A8D0; // weak
_UNKNOWN loc_804A8E7; // weak
_UNKNOWN loc_804A9F5; // weak
_UNKNOWN loc_804AB4C; // weak
_UNKNOWN loc_804AC39; // weak
_UNKNOWN loc_804AC75; // weak
_UNKNOWN loc_804ACB0; // weak
_UNKNOWN loc_804ACDC; // weak
_UNKNOWN loc_804AD7C; // weak
_UNKNOWN loc_804AE6F; // weak
_UNKNOWN loc_804B2F6; // weak
_UNKNOWN loc_804B325; // weak
_UNKNOWN loc_804C1E9; // weak
_UNKNOWN loc_804C1F1; // weak
_UNKNOWN loc_804C249; // weak
_UNKNOWN loc_804C26D; // weak
_UNKNOWN loc_804C295; // weak
_UNKNOWN loc_804C327; // weak
_UNKNOWN loc_804C33B; // weak
_UNKNOWN loc_804C3CF; // weak
_UNKNOWN loc_804C498; // weak
_UNKNOWN loc_804D33A; // weak
_UNKNOWN loc_804D351; // weak
_UNKNOWN loc_804DE7E; // weak
_UNKNOWN loc_804DECA; // weak
_UNKNOWN loc_804DF39; // weak
_UNKNOWN loc_804DFA2; // weak
_UNKNOWN loc_804E19E; // weak
_UNKNOWN loc_804E277; // weak
_UNKNOWN loc_804E2D7; // weak
_UNKNOWN loc_804E7CD; // weak
_UNKNOWN loc_804E9BD; // weak
_UNKNOWN loc_804E9CB; // weak
_UNKNOWN loc_804EB38; // weak
_UNKNOWN loc_804F1F6; // weak
_UNKNOWN loc_804F2F7; // weak
_UNKNOWN loc_804F396; // weak
_UNKNOWN loc_804F39D; // weak
_UNKNOWN loc_804F3F5; // weak
_UNKNOWN loc_804F415; // weak
_UNKNOWN loc_804F41C; // weak
_UNKNOWN loc_804F43E; // weak
_UNKNOWN loc_804F4E3; // weak
_UNKNOWN loc_804F501; // weak
_UNKNOWN loc_804F55F; // weak
_UNKNOWN loc_804F566; // weak
_UNKNOWN loc_804F58F; // weak
_UNKNOWN loc_804F594; // weak
_UNKNOWN loc_804F691; // weak
_UNKNOWN loc_804F6A3; // weak
_UNKNOWN loc_804F6D2; // weak
_UNKNOWN loc_804FDBF; // weak
_UNKNOWN loc_804FDC6; // weak
_UNKNOWN loc_804FDEC; // weak
_UNKNOWN loc_804FE08; // weak
_UNKNOWN locret_804FE0D; // weak
_UNKNOWN loc_8051AF8; // weak
_UNKNOWN loc_8051AFD; // weak
_UNKNOWN loc_8051B9D; // weak
_UNKNOWN loc_8051BA9; // weak
_UNKNOWN loc_8052A10; // weak
_UNKNOWN loc_8052A2D; // weak
_UNKNOWN loc_8052B22; // weak
_UNKNOWN loc_8052B2D; // weak
_UNKNOWN loc_8052FDB; // weak
_UNKNOWN loc_8052FFA; // weak
_UNKNOWN loc_8053010; // weak
_UNKNOWN locret_8053309; // weak
_UNKNOWN loc_80533B6; // weak
_UNKNOWN loc_80533DE; // weak
_UNKNOWN loc_80533E8; // weak
_UNKNOWN loc_8053415; // weak
_UNKNOWN loc_8053426; // weak
_UNKNOWN locret_8053429; // weak
_UNKNOWN loc_8053498; // weak
_UNKNOWN loc_80534A5; // weak
_UNKNOWN loc_80536C5; // weak
_UNKNOWN loc_80537C6; // weak
_UNKNOWN loc_80537CA; // weak
_UNKNOWN loc_8053E2D; // weak
_UNKNOWN loc_8053E32; // weak
_UNKNOWN loc_80542F2; // weak
_UNKNOWN loc_80543B5; // weak
_UNKNOWN loc_8054DF0; // weak
_UNKNOWN loc_8054DFA; // weak
_UNKNOWN loc_8054E23; // weak
_UNKNOWN loc_8054E2D; // weak
_UNKNOWN loc_80553A2; // weak
_UNKNOWN loc_805541F; // weak
_UNKNOWN loc_8055429; // weak
_UNKNOWN loc_8055499; // weak
_UNKNOWN loc_8055544; // weak
_UNKNOWN loc_8056190; // weak
_UNKNOWN loc_805619F; // weak
_UNKNOWN loc_805670C; // weak
_UNKNOWN locret_8056718; // weak
char locale = '\0'; // idb
struct option longopts = { "auto-reference", 0, NULL, 65 }; // idb
char *off_8057CFC[2] = { "roff", "tex" }; // weak
int dword_8057D08[2] = { 2, 3 }; // idb
char aFran[4] = "Fran"; // idb
char byte_8057F60[256] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x04',
  '\0',
  '\x03',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x06',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x03',
  '\x02',
  '\x04',
  '\x06',
  '\x05',
  '\b',
  '\x01',
  '\a',
  '\x03',
  '\x02',
  '\x04',
  '\x05',
  '\x03',
  '\x02',
  '\x04',
  '\x05',
  '\0',
  '\x06',
  '\x03',
  '\x02',
  '\x04',
  '\x06',
  '\x05',
  '\0',
  '\t',
  '\x03',
  '\x02',
  '\x04',
  '\x05',
  '\x02',
  '\0',
  '\0',
  '\x03',
  '\x02',
  '\x04',
  '\x06',
  '\x05',
  '\b',
  '\x01',
  '\a',
  '\x03',
  '\x02',
  '\x04',
  '\x05',
  '\x03',
  '\x02',
  '\x04',
  '\x05',
  '\0',
  '\x06',
  '\x03',
  '\x02',
  '\x04',
  '\x06',
  '\x05',
  '\0',
  '\t',
  '\x03',
  '\x02',
  '\x04',
  '\x05',
  '\x02',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_80581AE; // weak
_UNKNOWN unk_80581B2; // weak
_UNKNOWN unk_80581BE; // weak
_UNKNOWN unk_80584F4; // weak
void *off_805897C[54] =
{
  &loc_805312D,
  &loc_805329D,
  &loc_805329D,
  &loc_8053154,
  &loc_805329D,
  &loc_8053176,
  &loc_805329D,
  &loc_805329D,
  &loc_805329D,
  &loc_8053198,
  &loc_805329D,
  &loc_80531BA,
  &loc_805329D,
  &loc_805329D,
  &loc_80531DC,
  &loc_805329D,
  &loc_805329D,
  &loc_805329D,
  &loc_8053210,
  &loc_805329D,
  &loc_805329D,
  &loc_805329D,
  &loc_805329D,
  &loc_805324A,
  &loc_805327E,
  &loc_805329D,
  &loc_805329D,
  &loc_805329D,
  &loc_805329D,
  &loc_805329D,
  &loc_805329D,
  &loc_805329D,
  &loc_8053112,
  &loc_8053148,
  &loc_805329D,
  &loc_805329D,
  &loc_805329D,
  &loc_8053176,
  &loc_805329D,
  &loc_805329D,
  &loc_805329D,
  &loc_8053198,
  &loc_805329D,
  &loc_80531BA,
  &loc_805329D,
  &loc_805329D,
  &loc_805329D,
  &loc_805329D,
  &loc_805329D,
  &loc_805329D,
  &loc_8053210,
  &loc_805329D,
  &loc_805329D,
  &loc_8053232
}; // weak
_UNKNOWN unk_8058ABF; // weak
int dword_8058C80[8] = { 6656, 4294967279, 4294967294, 2147483646, 0, 0, 0, 0 }; // idb
_UNKNOWN unk_80591FC; // weak
_UNKNOWN unk_805A230; // weak
_UNKNOWN unk_805A233; // weak
int dword_805AEF8 = 239141509; // weak
int (*off_805CED4[2])() = { &sub_80495F0, &sub_80495D0 }; // weak
int (*off_805CED8)() = &sub_80495D0; // weak
int (*dword_805D008)(void) = NULL; // weak
int dword_805D160 = 0; // weak
int dword_805D174 = 0; // weak
int dword_805D188 = 0; // weak
int dword_805D19C = 0; // weak
int dword_805D1B0 = 0; // weak
int dword_805D1C4 = 0; // weak
int dword_805D1D8 = 0; // weak
int dword_805D1EC = 0; // weak
int dword_805D200 = 0; // weak
int dword_805D214 = 0; // weak
int dword_805D244 = 0; // weak
char byte_805D248 = '\x01'; // weak
int dword_805D24C = 72; // weak
int dword_805D250 = 3; // weak
char *s = "/"; // idb
char *off_805D258[2] = { "xx", "8.28" }; // weak
int off_805D25C = 134577615; // idb
int off_805D260 = 134539253; // idb
int status = 1; // idb
_UNKNOWN unk_805D2A0; // weak
_UNKNOWN unk_805D2BC; // weak
_UNKNOWN unk_805D2BF; // weak
_UNKNOWN unk_805D2D0; // weak
_UNKNOWN unk_805D2D3; // weak
int program_invocation_short_name; // weak
FILE *stderr; // idb
int optind; // weak
FILE *stdout; // idb
char *optarg; // idb
char byte_805D32C; // weak
_UNKNOWN unk_805D417; // weak
char byte_805D547; // weak
char byte_805D62E; // weak
char byte_805D729; // weak
char byte_805D72A; // weak
char byte_805D72B; // weak
int dword_805D72D; // weak
char byte_805D731; // weak
char *s1; // idb
char *dword_805D739; // idb
char *dword_805D73D; // idb
int dword_805D749; // weak
int dword_805D889; // weak
char byte_805D9C9; // weak
char byte_805DAE9[9]; // idb
char byte_805DAF2; // weak
char byte_805DAF3; // weak
char byte_805DB09; // weak
int dword_805DBE9; // weak
int dword_805DBED; // weak
_UNKNOWN unk_805DBF1; // weak
int dword_805DBF9; // weak
_UNKNOWN unk_805DBFD; // weak
int dword_805DC05; // weak
int dword_805DC09; // weak
__int64 qword_805DC11; // weak
int dword_805DC19; // weak
int dword_805DC1D; // weak
int dword_805DC21; // weak
void *ptr; // idb
size_t nmemb; // idb
char byte_805DC49[12]; // idb
char byte_805DC55; // weak
char byte_805DC6B; // weak
int dword_805DD49; // weak
int dword_805DD4D; // weak
int dword_805DD51; // weak
int dword_805DD55; // weak
int dword_805DD59; // weak
int dword_805DD5D; // weak
char byte_805DD61; // weak
char *string; // idb
int dword_805DD69; // weak
char byte_805DD6D; // weak
int dword_805DD71; // weak
int dword_805DD75; // weak
char byte_805DD79; // weak
char *dword_805DD7D; // idb
int dword_805DD81; // weak
char byte_805DD85; // weak
int dword_805DD89; // weak
int dword_805DD8D; // weak
int dword_805DD91; // weak
char byte_805DD95; // weak
int dword_805DD99; // weak
int dword_805DDA9; // weak
int dword_805DDAD; // weak
int dword_805DDB1; // weak
int dword_805DDB5; // weak
int dword_805DDB9; // weak
int dword_805DDBD; // weak
int dword_805DDC1; // weak
int dword_805DDC5; // weak
int dword_805DDC9; // weak
int dword_805DDCD; // weak
int dword_805DDD1; // weak
int dword_805DDD5; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (08048F98) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 80494F0: using guessed type int _gmon_start__(void);

//----- (08048FC0) --------------------------------------------------------
int sub_8048FC0()
{
  return dword_805D008();
}
// 805D008: using guessed type int (*dword_805D008)(void);

//----- (08049500) --------------------------------------------------------
#error "8049503: positive sp value has been found (funcsize=2)"

//----- (08049533) --------------------------------------------------------
void sub_8049533()
{
  ;
}

//----- (08049550) --------------------------------------------------------
void sub_8049550()
{
  ;
}

//----- (08049560) --------------------------------------------------------
int sub_8049560()
{
  int result; // eax

  result = &unk_805D2D3 - &unk_805D2D0;
  if ( (unsigned int)(&unk_805D2D3 - &unk_805D2D0) > 6 )
    result = 0;
  return result;
}
// 8049560: could not find valid save-restore pair for ebp

//----- (080495D0) --------------------------------------------------------
int sub_80495D0()
{
  int result; // eax

  if ( !byte_805D32C )
  {
    result = sub_8049560();
    byte_805D32C = 1;
  }
  return result;
}
// 80495D0: could not find valid save-restore pair for ebp
// 805D32C: using guessed type char byte_805D32C;

//----- (080495F0) --------------------------------------------------------
int sub_80495F0()
{
  return 0;
}
// 80495F0: could not find valid save-restore pair for ebp

//----- (0804964F) --------------------------------------------------------
void sub_804964F()
{
  ;
}

//----- (0804966A) --------------------------------------------------------
void sub_804966A()
{
  ;
}

//----- (0804967A) --------------------------------------------------------
signed int sub_804967A()
{
  return 3;
}
// 804967A: could not find valid save-restore pair for ebp

//----- (0804975C) --------------------------------------------------------
void sub_804975C()
{
  ;
}

//----- (08049777) --------------------------------------------------------
void sub_8049777()
{
  ;
}

//----- (08049787) --------------------------------------------------------
int sub_8049787()
{
  int result; // eax

  result = &unk_805D2BF - &unk_805D2BC;
  if ( (unsigned int)(&unk_805D2BF - &unk_805D2BC) > 6 )
    result = 0;
  return result;
}
// 8049787: could not find valid save-restore pair for ebp

//----- (08049869) --------------------------------------------------------
void sub_8049869()
{
  ;
}

//----- (08049884) --------------------------------------------------------
void sub_8049884()
{
  ;
}

//----- (08049894) --------------------------------------------------------
int sub_8049894()
{
  int result; // eax

  result = &unk_805D2BF - &unk_805D2BC;
  if ( (unsigned int)(&unk_805D2BF - &unk_805D2BC) > 6 )
    result = 0;
  return result;
}
// 8049894: could not find valid save-restore pair for ebp

//----- (08049976) --------------------------------------------------------
void sub_8049976()
{
  ;
}

//----- (08049991) --------------------------------------------------------
void sub_8049991()
{
  ;
}

//----- (080499A1) --------------------------------------------------------
int sub_80499A1()
{
  int result; // eax

  result = &unk_805D417 - (_UNKNOWN *)&program_invocation_short_name;
  if ( (unsigned int)(&unk_805D417 - (_UNKNOWN *)&program_invocation_short_name) > 6 )
    result = 0;
  return result;
}
// 80499A1: could not find valid save-restore pair for ebp
// 805D2E0: using guessed type int program_invocation_short_name;

//----- (08049A95) --------------------------------------------------------
void sub_8049A95()
{
  ;
}

//----- (08049AB0) --------------------------------------------------------
void sub_8049AB0()
{
  ;
}

//----- (08049AC0) --------------------------------------------------------
#error "8049AED: call analysis failed (funcsize=23)"

//----- (08049BCD) --------------------------------------------------------
void sub_8049BCD()
{
  ;
}

//----- (08049BE8) --------------------------------------------------------
void sub_8049BE8()
{
  ;
}

//----- (08049BF8) --------------------------------------------------------
int sub_8049BF8()
{
  int result; // eax

  result = &unk_805D2BF - &unk_805D2BC;
  if ( (unsigned int)(&unk_805D2BF - &unk_805D2BC) > 6 )
    result = 0;
  return result;
}
// 8049BF8: could not find valid save-restore pair for ebp

//----- (08049CDA) --------------------------------------------------------
void sub_8049CDA()
{
  ;
}

//----- (08049CF5) --------------------------------------------------------
void sub_8049CF5()
{
  ;
}

//----- (08049D05) --------------------------------------------------------
int sub_8049D05()
{
  int result; // eax

  result = &unk_805D2BF - &unk_805D2BC;
  if ( (unsigned int)(&unk_805D2BF - &unk_805D2BC) > 6 )
    result = 0;
  return result;
}
// 8049D05: could not find valid save-restore pair for ebp

//----- (08049D8F) --------------------------------------------------------
int sub_8049D8F()
{
  int result; // eax

  result = sub_8049D05();
  byte_805D547 = 1;
  return result;
}
// 805D547: using guessed type char byte_805D547;

//----- (08049DD0) --------------------------------------------------------
int __usercall sub_8049DD0@<eax>(void (__cdecl *a1)(int *)@<eax>)
{
  a1(&dword_805AEF8);
  return 0;
}
// 805AEF8: using guessed type int dword_805AEF8;

//----- (08049E2E) --------------------------------------------------------
void sub_8049E2E()
{
  ;
}

//----- (08049E49) --------------------------------------------------------
void sub_8049E49()
{
  ;
}

//----- (08049E59) --------------------------------------------------------
int sub_8049E59()
{
  int result; // eax

  result = &unk_805A233 - &unk_805A230;
  if ( (unsigned int)(&unk_805A233 - &unk_805A230) > 6 )
    result = 0;
  return result;
}
// 8049E59: could not find valid save-restore pair for ebp

//----- (08049F57) --------------------------------------------------------
void sub_8049F57()
{
  ;
}

//----- (08049F72) --------------------------------------------------------
void sub_8049F72()
{
  ;
}

//----- (08049F82) --------------------------------------------------------
int sub_8049F82()
{
  int result; // eax

  result = &unk_805D2BF - &unk_805D2BC;
  if ( (unsigned int)(&unk_805D2BF - &unk_805D2BC) > 6 )
    result = 0;
  return result;
}
// 8049F82: could not find valid save-restore pair for ebp

//----- (08049FE0) --------------------------------------------------------
int sub_8049FE0()
{
  return nullsub_3();
}
// 8049FE0: could not find valid save-restore pair for ebp
// 8049FDF: using guessed type int nullsub_3(void);

//----- (0804A092) --------------------------------------------------------
void sub_804A092()
{
  ;
}

//----- (0804A0AD) --------------------------------------------------------
void sub_804A0AD()
{
  ;
}

//----- (0804A0BD) --------------------------------------------------------
int __fastcall sub_804A0BD(int a1, int a2)
{
  int result; // eax
  int (__stdcall *v3)(void *, int, int, int, int, int); // eax
  int v4; // [esp+4h] [ebp-18h]
  int v5; // [esp+8h] [ebp-14h]
  int v6; // [esp+Ch] [ebp-10h]
  int v7; // [esp+10h] [ebp-Ch]
  int v8; // [esp+14h] [ebp-8h]
  int v9; // [esp+18h] [ebp-4h]

  result = &unk_805D2BF - &unk_805D2BC;
  if ( (unsigned int)(&unk_805D2BF - &unk_805D2BC) > 6 )
  {
    v9 = 0;
    dword_805D200 = (int)&locret_804A0CC;
    v3 = (int (__stdcall *)(void *, int, int, int, int, int))sub_8056CD9(a1, a2);
    result = v3(&unk_805D2BC, v4, v5, v6, v7, v8);
  }
  return result;
}
// 805D200: using guessed type int dword_805D200;

//----- (0804A160) --------------------------------------------------------
int __fastcall sub_804A160(int a1, int a2)
{
  int result; // eax

  result = sub_804A0BD(a1, a2);
  byte_805D62E = 1;
  return result;
}
// 805D62E: using guessed type char byte_805D62E;

//----- (0804A1E6) --------------------------------------------------------
void sub_804A1E6()
{
  ;
}

//----- (0804A201) --------------------------------------------------------
void sub_804A201()
{
  ;
}

//----- (0804A211) --------------------------------------------------------
#error "804A23E: call analysis failed (funcsize=23)"

//----- (0804A291) --------------------------------------------------------
int __usercall sub_804A291@<eax>(int a1@<eax>, int (__cdecl *a2)(void *, int)@<edx>)
{
  return a2(&unk_80591FC, a1);
}

//----- (0804A341) --------------------------------------------------------
void sub_804A341()
{
  ;
}

//----- (0804A35C) --------------------------------------------------------
void sub_804A35C()
{
  ;
}

//----- (0804A36C) --------------------------------------------------------
int sub_804A36C()
{
  int result; // eax

  result = (char *)&off_805897C[10] - (char *)&off_805897C[9];
  if ( (unsigned int)((char *)&off_805897C[10] - (char *)&off_805897C[9]) > 6 )
    result = 0;
  return result;
}
// 804A36C: could not find valid save-restore pair for ebp
// 805897C: using guessed type void *off_805897C[54];

//----- (0804A3D3) --------------------------------------------------------
int __usercall sub_804A3D3@<eax>(int a1@<eax>, int (__cdecl *a2)(void **, int)@<edx>)
{
  return a2(&off_805897C[9], a1);
}
// 805897C: using guessed type void *off_805897C[54];

//----- (0804A437) --------------------------------------------------------
#error "804A3CE: call analysis failed (funcsize=26)"

//----- (0804A483) --------------------------------------------------------
void sub_804A483()
{
  ;
}

//----- (0804A49E) --------------------------------------------------------
void sub_804A49E()
{
  ;
}

//----- (0804A4AE) --------------------------------------------------------
int sub_804A4AE()
{
  int result; // eax

  result = (char *)&off_805897C[10] - (char *)&off_805897C[9];
  if ( (unsigned int)((char *)&off_805897C[10] - (char *)&off_805897C[9]) > 6 )
    result = 0;
  return result;
}
// 804A4AE: could not find valid save-restore pair for ebp
// 805897C: using guessed type void *off_805897C[54];

//----- (0804A55E) --------------------------------------------------------
int __cdecl sub_804A55E(unsigned __int8 a1)
{
  return a1;
}

//----- (0804A570) --------------------------------------------------------
int sub_804A570()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nWith no FILE, or when FILE is -, read standard input.\n");
  return fputs_unlocked(v1, v0);
}
// 80492B0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804A59B) --------------------------------------------------------
int sub_804A59B()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nMandatory arguments to long options are mandatory for short options too.\n");
  return fputs_unlocked(v1, v0);
}
// 80492B0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804A5C6) --------------------------------------------------------
int sub_804A5C6()
{
  char *v0; // eax
  char *v1; // eax
  char *v2; // eax
  char *v3; // ebx
  char *v4; // eax
  char *s1; // [esp+0h] [ebp-6Ch]
  char *s2; // [esp+4h] [ebp-68h]
  size_t n; // [esp+8h] [ebp-64h]
  int v9; // [esp+Ch] [ebp-60h]
  int v10; // [esp+10h] [ebp-5Ch]
  int v11; // [esp+14h] [ebp-58h]
  int v12; // [esp+18h] [ebp-54h]
  const char *v13; // [esp+28h] [ebp-44h]
  const char *v14; // [esp+2Ch] [ebp-40h]
  const char *v15; // [esp+30h] [ebp-3Ch]
  const char *v16; // [esp+34h] [ebp-38h]
  const char *v17; // [esp+38h] [ebp-34h]
  const char *v18; // [esp+3Ch] [ebp-30h]

  v13 = "[";
  v14 = "test invocation";
  v15 = "coreutils";
  v16 = "Multi-call invocation";
  v17 = "sha224sum";
  v18 = "sha2 utilities";
  *(&s1 - 10) = "sha256sum";
  *(&s1 - 9) = "sha2 utilities";
  *(&s1 - 8) = "sha384sum";
  *(&s1 - 7) = "sha2 utilities";
  *(&s1 - 6) = "sha512sum";
  *(&s1 - 5) = "sha2 utilities";
  *(&s1 - 4) = 0;
  *(&s1 - 3) = 0;
  *(&s1 - 19) = (char *)n;
  *(&s1 - 18) = (char *)(&s1 - 16);
  dword_805D1D8 = (int)&loc_804A686;
  sub_8056DBD(s1, s2, n, v9, v10, v11, v12);
  do
  {
    *(&s1 - 18) += 8;
    if ( !*(_DWORD *)*(&s1 - 18) )
      break;
    s2 = *(char **)*(&s1 - 18);
  }
  while ( strcmp((const char *)n, s2) );
  if ( *((_DWORD *)*(&s1 - 18) + 1) )
    *(&s1 - 19) = (char *)*((_DWORD *)*(&s1 - 18) + 1);
  v0 = gettext("\n%s online help: <%s>\n");
  n = (size_t)"http://www.gnu.org/software/coreutils/";
  s2 = "GNU coreutils";
  printf(v0, "GNU coreutils");
  *(&s1 - 17) = setlocale(5, 0);
  if ( *(&s1 - 17) )
  {
    n = 3;
    s2 = "en_";
    s1 = *(&s1 - 17);
    if ( strncmp(s1, "en_", 3u) )
    {
      v1 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
      s2 = (char *)n;
      printf(v1, n);
    }
  }
  v2 = gettext("Full documentation at: <%s%s>\n");
  s2 = "http://www.gnu.org/software/coreutils/";
  printf(v2, "http://www.gnu.org/software/coreutils/");
  if ( *(&s1 - 19) == (char *)n )
    v3 = " invocation";
  else
    v3 = &locale;
  v4 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  n = (size_t)v3;
  return printf(v4, *(&s1 - 19), v3);
}
// 8056DBD: using guessed type int __stdcall sub_8056DBD(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 805D1D8: using guessed type int dword_805D1D8;

//----- (0804A791) --------------------------------------------------------
char *__cdecl sub_804A791(char *a1)
{
  char *v1; // ebx
  int *v2; // eax

  v1 = gettext("error in regular expression matcher");
  v2 = __errno_location();
  error(1, *v2, v1);
  return sub_804A7C1(a1);
}

//----- (0804A7C1) --------------------------------------------------------
#error "804AAB6: call analysis failed (funcsize=142)"

//----- (0804AB82) --------------------------------------------------------
int __cdecl sub_804AB82(int a1)
{
  unsigned __int8 *v1; // eax
  size_t v2; // eax
  const char *v3; // eax
  bool v4; // zf
  void *v5; // eax
  int v6; // ebx
  char *v7; // eax
  const char *v9; // [esp+Ch] [ebp-2Ch]
  int v10; // [esp+10h] [ebp-28h]
  struct re_pattern_buffer *buffer; // [esp+24h] [ebp-14h]
  char *s; // [esp+28h] [ebp-10h]
  const char *v13; // [esp+2Ch] [ebp-Ch]

  buffer = (struct re_pattern_buffer *)(a1 + 4);
  s = *(char **)a1;
  *(_DWORD *)(a1 + 4) = 0;
  buffer->allocated = 0;
  buffer->fastmap = (char *)(a1 + 36);
  if ( byte_805D731 )
    v1 = (unsigned __int8 *)&byte_805D9C9;
  else
    v1 = 0;
  buffer->translate = v1;
  v2 = strlen(s);
  v3 = re_compile_pattern(s, v2, buffer);
  v13 = v3;
  v4 = v3 == 0;
  v5 = &loc_804AC39;
  if ( v4 )
    v5 = &loc_804AC75;
  dword_805D160 = (int)v5;
  sub_80570A9();
  v6 = sub_805192F((int)s);
  v7 = gettext("%s (for regexp %s)");
  v10 = v6;
  v9 = v13;
  error(1, 0, v7, v13, v6);
  return re_compile_fastmap(buffer);
}
// 80570A9: using guessed type int sub_80570A9(void);
// 805D160: using guessed type int dword_805D160;
// 805D731: using guessed type char byte_805D731;
// 805D9C9: using guessed type char byte_805D9C9;

//----- (0804AC86) --------------------------------------------------------
char *sub_804AC86()
{
  void *v0; // eax
  char *result; // eax
  int v2; // [esp+0h] [ebp-28h]
  int v3; // [esp+4h] [ebp-24h]
  int v4; // [esp+8h] [ebp-20h]
  int v5; // [esp+Ch] [ebp-1Ch]
  int v6; // [esp+10h] [ebp-18h]
  int v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+18h] [ebp-10h]
  signed int c; // [esp+1Ch] [ebp-Ch]

  v0 = &loc_804ACB0;
  if ( !byte_805D731 )
    v0 = &loc_804ACDC;
  dword_805D1D8 = (int)v0;
  sub_8056DBD(v2, v3, v4, v5, v6, v7, v8);
  for ( c = 0; c <= 255; ++c )
    *(_BYTE *)(c + 134601161) = toupper(c);
  if ( dword_805D749 )
  {
    if ( !*(_BYTE *)dword_805D749 )
      dword_805D749 = 0;
  }
  else if ( byte_805D248 && byte_805D72A != 1 )
  {
    dword_805D749 = (int)"[.?!][]\"')}]*\\($\\|\t\\|  \\)[ \t\n]*";
  }
  else
  {
    dword_805D749 = (int)"\n";
  }
  if ( dword_805D749 )
    sub_804AB82((int)&dword_805D749);
  if ( dword_805D889 )
    return (char *)sub_804AB82((int)&dword_805D889);
  result = s1;
  if ( !s1 )
  {
    if ( byte_805D248 )
    {
      dword_805D160 = (int)&loc_804AD7C;
      result = (char *)sub_80570A9();
    }
    else
    {
      result = (char *)memset(byte_805DAE9, 1, 0x100u);
      byte_805DB09 = 0;
      byte_805DAF2 = 0;
      byte_805DAF3 = 0;
    }
  }
  return result;
}
// 804AC86: could not find valid save-restore pair for ebx
// 8056DBD: using guessed type int __stdcall sub_8056DBD(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80570A9: using guessed type int sub_80570A9(void);
// 805D160: using guessed type int dword_805D160;
// 805D1D8: using guessed type int dword_805D1D8;
// 805D248: using guessed type char byte_805D248;
// 805D72A: using guessed type char byte_805D72A;
// 805D731: using guessed type char byte_805D731;
// 805D749: using guessed type int dword_805D749;
// 805D889: using guessed type int dword_805D889;
// 805DAF2: using guessed type char byte_805DAF2;
// 805DAF3: using guessed type char byte_805DAF3;
// 805DB09: using guessed type char byte_805DB09;

//----- (0804AE20) --------------------------------------------------------
int __cdecl sub_804AE20(char *s1, int a2)
{
  char *v2; // eax
  int v3; // ebx
  int v4; // eax
  int result; // eax
  int v6; // [esp+Ch] [ebp-1Ch]
  char v7; // [esp+1Bh] [ebp-Dh]
  int v8; // [esp+1Ch] [ebp-Ch]

  if ( !s1 || !*s1 || !strcmp(s1, "-") )
  {
    dword_805D214 = (int)&loc_804AE6F;
    sub_8056C61();
  }
  v7 = 0;
  *(_DWORD *)a2 = sub_8051CCE((int)s1, (int)&v8);
  if ( !*(_DWORD *)a2 )
  {
    if ( v7 )
      v2 = "-";
    else
      v2 = s1;
    v3 = sub_8051667(0, 3, (int)v2);
    v4 = *__errno_location();
    v6 = v3;
    error(1, v4, "%s", v3);
  }
  result = a2;
  *(_DWORD *)(a2 + 4) = v8 + *(_DWORD *)a2;
  return result;
}
// 8056C61: using guessed type int sub_8056C61(void);
// 805D214: using guessed type int dword_805D214;

//----- (0804AF1A) --------------------------------------------------------
#error "804AF43: call analysis failed (funcsize=21)"

//----- (0804AF56) --------------------------------------------------------
#error "804B0BC: positive sp value has been found (funcsize=76)"

//----- (0804B0BF) --------------------------------------------------------
int __cdecl compar(const void *a1, const void *a2)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = sub_804AF1A(a1, a2);
  if ( v3 )
    return v3;
  if ( *(_DWORD *)a1 < *(_DWORD *)a2 )
    return -1;
  return *(_DWORD *)a1 > *(_DWORD *)a2;
}

//----- (0804B10E) --------------------------------------------------------
#error "804B135: call analysis failed (funcsize=66)"

//----- (0804B1E2) --------------------------------------------------------
void sub_804B1E2()
{
  if ( nmemb )
    qsort(ptr, nmemb, 0x1Cu, compar);
}

//----- (0804B21B) --------------------------------------------------------
void __cdecl sub_804B21B(char *s1)
{
  unsigned __int8 *i; // [esp+14h] [ebp-14h]
  void *ptr; // [esp+18h] [ebp-10h]
  unsigned int v3; // [esp+1Ch] [ebp-Ch]

  sub_804AE20(s1, (int)&ptr);
  memset(byte_805DAE9, 1, 0x100u);
  for ( i = (unsigned __int8 *)ptr; v3 > (unsigned int)i; ++i )
    byte_805DAE9[(unsigned __int8)sub_804A55E(*i)] = 0;
  if ( byte_805D248 != 1 )
  {
    byte_805DB09 = 0;
    byte_805DAF2 = 0;
    byte_805DAF3 = 0;
  }
  free(ptr);
}
// 805D248: using guessed type char byte_805D248;
// 805DAF2: using guessed type char byte_805DAF2;
// 805DAF3: using guessed type char byte_805DAF3;
// 805DB09: using guessed type char byte_805DB09;

//----- (0804B2AE) --------------------------------------------------------
void __cdecl sub_804B2AE(char *s1, int a2)
{
  int v2; // edx
  int v3; // ecx
  void *v4; // eax
  int v6; // [esp+0h] [ebp-28h]
  _BYTE *v7; // [esp+10h] [ebp-18h]
  int v8; // [esp+18h] [ebp-10h]
  unsigned int v9; // [esp+1Ch] [ebp-Ch]

  sub_804AE20(s1, (int)&v8);
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  v7 = (_BYTE *)v8;
  while ( v9 > (unsigned int)v7 )
  {
    if ( v9 > (unsigned int)v7 )
    {
      v4 = &loc_804B325;
      if ( *v7 != 10 )
        v4 = &loc_804B2F6;
      dword_805D174 = (int)v4;
      sub_8057037(v3, v2, v6);
    }
    if ( v9 > (unsigned int)v7 )
      ++v7;
  }
  qsort(*(void **)a2, *(_DWORD *)(a2 + 8), 8u, sub_804AF1A);
}
// 805D174: using guessed type int dword_805D174;

//----- (0804B40B) --------------------------------------------------------
#error "804BB85: call analysis failed (funcsize=501)"

//----- (0804BC0F) --------------------------------------------------------
int __cdecl sub_804BC0F(int a1)
{
  int result; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  result = a1;
  for ( i = a1; i > 0; --i )
    result = putchar_unlocked(32);
  return result;
}

//----- (0804BC35) --------------------------------------------------------
#error "804BFC9: call analysis failed (funcsize=261)"

//----- (0804C0E8) --------------------------------------------------------
unsigned int sub_804C0E8()
{
  int v0; // ecx
  int v1; // edx
  size_t v2; // eax
  void *v3; // eax
  void *v4; // eax
  int v5; // edx
  int v6; // ecx
  void *v7; // eax
  void *v8; // eax
  int v9; // edx
  int v10; // ecx
  const char *v12; // [esp+0h] [ebp-58h]
  int v13; // [esp+4h] [ebp-54h]
  __int64 v14; // [esp+8h] [ebp-50h]
  int v15; // [esp+10h] [ebp-48h]
  int v16; // [esp+14h] [ebp-44h]
  int i; // [esp+18h] [ebp-40h]
  int v18; // [esp+1Ch] [ebp-3Ch]
  int j; // [esp+20h] [ebp-38h]
  const char *v20; // [esp+24h] [ebp-34h]
  __int64 v21; // [esp+28h] [ebp-30h]
  int v22; // [esp+30h] [ebp-28h]
  int v23; // [esp+34h] [ebp-24h]
  int v24; // [esp+38h] [ebp-20h]
  unsigned int v25; // [esp+4Ch] [ebp-Ch]

  v25 = __readgsdword(0x14u);
  if ( byte_805D729 )
  {
    dword_805DBED = 0;
    for ( i = 0; i < dword_805DC09; ++i )
    {
      v21 = *(_QWORD *)(8 * i + dword_805DC1D) + 1LL;
      if ( i > 0 )
        v21 -= *(_QWORD *)(8 * (i + 0x1FFFFFFF) + dword_805DC1D);
      v14 = v21;
      v18 = sprintf((char *)&v23 + 3, "%lld");
      v1 = 4 * i;
      if ( *(_DWORD *)(4 * i + dword_805DC19) )
      {
        v12 = *(const char **)(4 * i + dword_805DC19);
        v2 = strlen(v12);
        v1 = v18;
        v18 += v2;
      }
      v3 = &loc_804C1E9;
      if ( v18 <= dword_805DBED )
        v3 = &loc_804C1F1;
      dword_805D200 = (int)v3;
      sub_8056CD9(v0, v1);
      dword_805DBED = v18;
    }
    dword_805DD89 = (int)sub_8052AA0(++dword_805DBED + 1);
  }
  v4 = &loc_804C249;
  if ( byte_805D729 )
    v4 = &loc_804C26D;
  dword_805D160 = (int)v4;
  sub_80570A9();
  v7 = &loc_804C26D;
  if ( !byte_805D72A )
    v7 = &loc_804C295;
  dword_805D174 = (int)v7;
  sub_8057037(v6, v5, v12);
  if ( byte_805D72B != 1 )
    dword_805D24C -= dword_805DBED + dword_805D250;
  if ( dword_805D24C < 0 )
    dword_805D24C = 0;
  dword_805DD49 = dword_805D24C / 2;
  dword_805DD4D = dword_805D24C / 2 - dword_805D250;
  dword_805DD51 = dword_805D24C / 2;
  if ( s )
  {
    v8 = &loc_804C327;
    if ( !*s )
      v8 = &loc_804C33B;
    dword_805D160 = (int)v8;
    sub_80570A9();
    dword_805DD55 = strlen(s);
  }
  else
  {
    s = 0;
  }
  if ( byte_805D248 )
  {
    dword_805DD4D += -2 * dword_805DD55;
    if ( dword_805DD4D < 0 )
      dword_805DD4D = 0;
    dword_805DD51 += -2 * dword_805DD55;
  }
  else
  {
    dword_805DD51 += ~(2 * dword_805DD55);
  }
  dword_805D19C = (int)&loc_804C3CF;
  sub_8056F2E(v12, v13, v14, HIDWORD(v14), v15, v16, i, v18, 0, v20, v21, HIDWORD(v21), v22, v23, v24);
  byte_805DC55 = 1;
  if ( dword_805D72D == 2 )
  {
    byte_805DC6B = 1;
  }
  else if ( (unsigned int)dword_805D72D >= 2 && dword_805D72D == 3 )
  {
    v20 = "$%&#_{}\\";
    dword_805D200 = (int)&loc_804C498;
    sub_8056CD9(v10, v9);
    do
    {
      v12 = (const char *)*v20;
      byte_805DC49[(unsigned __int8)sub_804A55E((unsigned __int8)v12)] = 1;
      ++v20;
    }
    while ( *v20 );
    for ( j = 128; j <= 255; ++j )
      *(_BYTE *)(j + 134601801) = byte_8057F60[(unsigned __int8)j] != 0;
  }
  return __readgsdword(0x14u) ^ v25;
}
// 804C0E8: could not find valid save-restore pair for ebx
// 8056F2E: using guessed type int __stdcall sub_8056F2E(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80570A9: using guessed type int sub_80570A9(void);
// 805D160: using guessed type int dword_805D160;
// 805D174: using guessed type int dword_805D174;
// 805D19C: using guessed type int dword_805D19C;
// 805D200: using guessed type int dword_805D200;
// 805D248: using guessed type char byte_805D248;
// 805D24C: using guessed type int dword_805D24C;
// 805D250: using guessed type int dword_805D250;
// 805D729: using guessed type char byte_805D729;
// 805D72A: using guessed type char byte_805D72A;
// 805D72B: using guessed type char byte_805D72B;
// 805D72D: using guessed type int dword_805D72D;
// 805DBED: using guessed type int dword_805DBED;
// 805DC09: using guessed type int dword_805DC09;
// 805DC19: using guessed type int dword_805DC19;
// 805DC1D: using guessed type int dword_805DC1D;
// 805DC55: using guessed type char byte_805DC55;
// 805DC6B: using guessed type char byte_805DC6B;
// 805DD49: using guessed type int dword_805DD49;
// 805DD4D: using guessed type int dword_805DD4D;
// 805DD51: using guessed type int dword_805DD51;
// 805DD55: using guessed type int dword_805DD55;
// 805DD89: using guessed type int dword_805DD89;

//----- (0804C4EA) --------------------------------------------------------
#error "804CC00: call analysis failed (funcsize=853)"

//----- (0804D1BD) --------------------------------------------------------
int sub_804D1BD()
{
  int v0; // edx
  int v1; // ecx
  void *v2; // eax
  int v4; // [esp+0h] [ebp-18h]

  printf(".%s \"", off_805D258[0]);
  sub_804BC35(dword_805DD59, dword_805DD5D);
  if ( byte_805DD61 )
    fputs_unlocked(s, stdout);
  putchar_unlocked(34);
  fwrite_unlocked(" \"", 1u, 2u, stdout);
  if ( byte_805DD6D )
    fputs_unlocked(s, stdout);
  sub_804BC35(string, dword_805DD69);
  putchar_unlocked(34);
  fwrite_unlocked(" \"", 1u, 2u, stdout);
  sub_804BC35(dword_805DD71, dword_805DD75);
  if ( byte_805DD79 )
    fputs_unlocked(s, stdout);
  putchar_unlocked(34);
  fwrite_unlocked(" \"", 1u, 2u, stdout);
  v2 = &loc_804D33A;
  if ( !byte_805DD85 )
    v2 = &loc_804D351;
  dword_805D174 = (int)v2;
  sub_8057037(v1, v0, v4);
  fputs_unlocked(s, stdout);
  sub_804BC35(dword_805DD7D, dword_805DD81);
  putchar_unlocked(34);
  if ( byte_805D729 || byte_805D72A )
  {
    fwrite_unlocked(" \"", 1u, 2u, stdout);
    sub_804BC35(dword_805DD89, dword_805DD8D);
    putchar_unlocked(34);
  }
  return putchar_unlocked(10);
}
// 80492B0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 804BC35: using guessed type _DWORD __cdecl sub_804BC35(_DWORD, _DWORD);
// 805D174: using guessed type int dword_805D174;
// 805D258: using guessed type char *off_805D258[2];
// 805D729: using guessed type char byte_805D729;
// 805D72A: using guessed type char byte_805D72A;
// 805DD59: using guessed type int dword_805DD59;
// 805DD5D: using guessed type int dword_805DD5D;
// 805DD61: using guessed type char byte_805DD61;
// 805DD69: using guessed type int dword_805DD69;
// 805DD6D: using guessed type char byte_805DD6D;
// 805DD71: using guessed type int dword_805DD71;
// 805DD75: using guessed type int dword_805DD75;
// 805DD79: using guessed type char byte_805DD79;
// 805DD81: using guessed type int dword_805DD81;
// 805DD85: using guessed type char byte_805DD85;
// 805DD89: using guessed type int dword_805DD89;
// 805DD8D: using guessed type int dword_805DD8D;

//----- (0804D3E0) --------------------------------------------------------
#error "804D521: call analysis failed (funcsize=176)"

//----- (0804D6D1) --------------------------------------------------------
#error "804DADE: call analysis failed (funcsize=246)"

//----- (0804DB2B) --------------------------------------------------------
#error "804DB7E: call analysis failed (funcsize=21)"

//----- (0804DB91) --------------------------------------------------------
#error "804DC69: positive sp value has been found (funcsize=55)"

//----- (0804DC6A) --------------------------------------------------------
void __cdecl __noreturn sub_804DC6A(int status)
{
  int v1; // ebx
  char *v2; // eax
  int v3; // esi
  int v4; // ebx
  char *v5; // eax
  FILE *v6; // ebx
  char *v7; // eax
  FILE *v8; // ebx
  char *v9; // eax
  FILE *v10; // ebx
  char *v11; // eax
  FILE *v12; // ebx
  char *v13; // eax
  FILE *v14; // ebx
  char *v15; // eax
  FILE *v16; // ebx
  char *v17; // eax
  FILE *v18; // ebx
  char *v19; // eax
  FILE *v20; // ebx
  char *v21; // eax

  if ( status )
  {
    v1 = dword_805DD99;
    v2 = gettext("Try '%s --help' for more information.\n");
    fprintf(stderr, v2, v1);
  }
  else
  {
    v3 = dword_805DD99;
    v4 = dword_805DD99;
    v5 = gettext("Usage: %s [OPTION]... [INPUT]...   (without -G)\n  or:  %s -G [OPTION]... [INPUT [OUTPUT]]\n");
    printf(v5, v4, v3);
    v6 = stdout;
    v7 = gettext("Output a permuted index, including context, of the words in the input files.\n");
    fputs_unlocked(v7, v6);
    sub_804A570();
    sub_804A59B();
    v8 = stdout;
    v9 = gettext(
           "  -A, --auto-reference           output automatically generated references\n"
           "  -G, --traditional              behave more like System V 'ptx'\n");
    fputs_unlocked(v9, v8);
    v10 = stdout;
    v11 = gettext(
            "  -F, --flag-truncation=STRING   use STRING for flagging line truncations.\n"
            "                                 The default is '/'\n");
    fputs_unlocked(v11, v10);
    v12 = stdout;
    v13 = gettext(
            "  -M, --macro-name=STRING        macro name to use instead of 'xx'\n"
            "  -O, --format=roff              generate output as roff directives\n"
            "  -R, --right-side-refs          put references at right, not counted in -w\n"
            "  -S, --sentence-regexp=REGEXP   for end of lines or end of sentences\n"
            "  -T, --format=tex               generate output as TeX directives\n");
    fputs_unlocked(v13, v12);
    v14 = stdout;
    v15 = gettext(
            "  -W, --word-regexp=REGEXP       use REGEXP to match each keyword\n"
            "  -b, --break-file=FILE          word break characters in this FILE\n"
            "  -f, --ignore-case              fold lower case to upper case for sorting\n"
            "  -g, --gap-size=NUMBER          gap size in columns between output fields\n"
            "  -i, --ignore-file=FILE         read ignore word list from FILE\n"
            "  -o, --only-file=FILE           read only word list from this FILE\n");
    fputs_unlocked(v15, v14);
    v16 = stdout;
    v17 = gettext(
            "  -r, --references               first field of each line is a reference\n"
            "  -t, --typeset-mode               - not implemented -\n"
            "  -w, --width=NUMBER             output width in columns, reference excluded\n");
    fputs_unlocked(v17, v16);
    v18 = stdout;
    v19 = gettext("      --help     display this help and exit\n");
    fputs_unlocked(v19, v18);
    v20 = stdout;
    v21 = gettext("      --version  output version information and exit\n");
    fputs_unlocked(v21, v20);
    sub_804A5C6();
  }
  exit(status);
}
// 80492B0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 805DD99: using guessed type int dword_805DD99;

//----- (0804DDDE) --------------------------------------------------------
int __cdecl main(int argc, char **argv)
{
  void *v2; // eax
  int v3; // eax
  void *v4; // eax
  int v5; // eax
  void *v6; // eax
  int v7; // ebx
  char *v8; // eax
  int v9; // edx
  int v10; // ecx
  int v11; // ecx
  int v12; // ebx
  char *v13; // eax
  int v14; // eax
  int v15; // ebx
  int v16; // eax
  int v17; // ebx
  char *v18; // eax
  signed int v19; // eax
  char *v21; // [esp+0h] [ebp-44h]
  int v22; // [esp+4h] [ebp-40h]
  char *v23; // [esp+8h] [ebp-3Ch]
  int v24; // [esp+Ch] [ebp-38h]
  int v25; // [esp+10h] [ebp-34h]
  int v26; // [esp+14h] [ebp-30h]
  int v27; // [esp+18h] [ebp-2Ch]
  int v28; // [esp+1Ch] [ebp-28h]
  int v29; // [esp+20h] [ebp-24h]
  int v30; // [esp+24h] [ebp-20h]
  int v31; // [esp+28h] [ebp-1Ch]
  int i; // [esp+2Ch] [ebp-18h]
  int v33; // [esp+30h] [ebp-14h]
  int v34; // [esp+34h] [ebp-10h]
  __int64 v35; // [esp+38h] [ebp-Ch]

  sub_804EFD4(*argv);
  setlocale(6, &locale);
  bindtextdomain("coreutils", "/home/hwangdz/coreutils/coreutils-8.28/install_m32/share/locale");
  textdomain("coreutils");
  sub_8056A9F((int)sub_804EC9C);
  while ( 1 )
  {
    v33 = getopt_long(argc, argv, "AF:GM:ORS:TW:b:i:fg:o:trw:", &longopts, 0);
    if ( v33 == -1 )
      break;
    if ( v33 == 83 )
    {
      dword_805D749 = (int)sub_804A7C1(optarg);
    }
    else if ( v33 > 83 )
    {
      if ( v33 == 103 )
      {
        if ( sub_8052EBE(optarg, 0, 0, (int)&v35, 0)
          || v35 < 0
          || SHIDWORD(v35) <= 0 && !(_DWORD)v35
          || v35 > 0x7FFFFFFF )
        {
          v7 = sub_805192F((int)optarg);
          v8 = gettext("invalid gap width: %s");
          v24 = v7;
          error(1, 0, v8);
        }
        dword_805D250 = v35;
        dword_805D1C4 = (int)&loc_804E2D7;
        sub_8056E4A(v21, v22, v23, v24, v25, v26, v27);
LABEL_49:
        dword_805D73D = optarg;
        dword_805D200 = (int)&loc_804E2D7;
        sub_8056CD9(v10, v9);
        goto LABEL_50;
      }
      if ( v33 > 103 )
      {
        if ( v33 == 114 )
        {
          byte_805D72A = 1;
        }
        else if ( v33 > 114 )
        {
          if ( v33 != 116 )
          {
            if ( v33 != 119 )
              goto LABEL_39;
            if ( sub_8052EBE(optarg, 0, 0, (int)&v35, 0)
              || v35 < 0
              || SHIDWORD(v35) <= 0 && !(_DWORD)v35
              || v35 > 0x7FFFFFFF )
            {
              v12 = sub_805192F((int)optarg);
              v13 = gettext("invalid line width: %s");
              v24 = v12;
              error(1, 0, v13);
            }
            dword_805D24C = v35;
            dword_805D200 = (int)&loc_804E2D7;
            sub_8056CD9(v11, HIDWORD(v35));
LABEL_59:
            byte_805D729 = 1;
          }
        }
        else
        {
          if ( v33 == 105 )
            goto LABEL_49;
          if ( v33 != 111 )
            goto LABEL_39;
LABEL_50:
          dword_805D739 = optarg;
        }
      }
      else if ( v33 == 87 )
      {
        dword_805D889 = (int)sub_804A7C1(optarg);
        if ( !*(_BYTE *)dword_805D889 )
          dword_805D889 = 0;
      }
      else if ( v33 > 87 )
      {
        v6 = &loc_804DF39;
        if ( v33 == 98 )
          v6 = &loc_804DFA2;
        dword_805D200 = (int)v6;
        if ( sub_8056CD9(v10, v9) != 102 )
          goto LABEL_39;
LABEL_41:
        byte_805D731 = 1;
      }
      else
      {
        if ( v33 != 84 )
          goto LABEL_39;
        dword_805D72D = 3;
      }
    }
    else if ( v33 == 70 )
    {
      s = sub_804A7C1(optarg);
    }
    else if ( v33 > 70 )
    {
      v4 = &loc_804DECA;
      if ( v33 == 77 )
        v4 = &loc_804E19E;
      dword_805D214 = (int)v4;
      v5 = sub_8056C61();
      if ( v5 <= 77 )
      {
        if ( v5 != 71 )
          goto LABEL_39;
        byte_805D248 = 0;
        dword_805D214 = (int)&loc_804E2D7;
        sub_8056C61();
        s1 = optarg;
        dword_805D19C = (int)&loc_804E2D7;
        sub_8056F2E(v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, i, v33, v34, v35);
        goto LABEL_41;
      }
      if ( v5 == 79 )
      {
        dword_805D72D = 2;
        dword_805D160 = (int)&loc_804E2D7;
        sub_80570A9();
      }
      else if ( v5 != 82 )
      {
        goto LABEL_39;
      }
      byte_805D72B = 1;
    }
    else
    {
      v2 = &loc_804DE7E;
      if ( v33 == -130 )
        v2 = &loc_804E277;
      dword_805D200 = (int)v2;
      v3 = sub_8056CD9(v10, v9);
      if ( v3 <= -130 )
      {
        if ( v3 == -131 )
        {
          v14 = sub_804F79E("F. Pinard", aFran);
          v26 = 0;
          v25 = v14;
          sub_80528BA(stdout, (int)"ptx", (int)"GNU coreutils", off_805D25C, v14, 0);
          exit(0);
        }
LABEL_39:
        sub_804DC6A(1);
      }
      if ( v3 != 10 )
      {
        if ( v3 != 65 )
          goto LABEL_39;
        goto LABEL_59;
      }
      dword_805D72D = dword_8057D08[sub_804EB6C(
                                      (int)"--format",
                                      optarg,
                                      (int)off_8057CFC,
                                      (int)dword_8057D08,
                                      4u,
                                      off_805D260)];
    }
  }
  if ( optind == argc )
  {
    dword_805DC19 = (int)sub_8052AA0(4u);
    dword_805DC1D = (int)sub_8052AA0(8u);
    dword_805DC21 = (int)sub_8052AA0(8u);
    dword_805DC09 = 1;
    *(_DWORD *)dword_805DC19 = 0;
  }
  else if ( byte_805D248 )
  {
    dword_805DC09 = argc - optind;
    dword_805DC19 = (int)sub_805297A(argc - optind, 4u);
    dword_805DC1D = (int)sub_805297A(dword_805DC09, 8u);
    dword_805DC21 = (int)sub_805297A(dword_805DC09, 8u);
    for ( i = 0; i < dword_805DC09; ++i )
    {
      if ( *argv[optind] && strcmp(argv[optind], "-") )
        *(_DWORD *)(dword_805DC19 + 4 * i) = argv[optind];
      else
        *(_DWORD *)(4 * i + dword_805DC19) = 0;
      ++optind;
    }
  }
  else
  {
    dword_805DC09 = 1;
    dword_805DC19 = (int)sub_8052AA0(4u);
    dword_805DC1D = (int)sub_8052AA0(8u);
    dword_805DC21 = (int)sub_8052AA0(8u);
    if ( *argv[optind] && strcmp(argv[optind], "-") )
      *(_DWORD *)dword_805DC19 = argv[optind];
    else
      *(_DWORD *)dword_805DC19 = 0;
    if ( ++optind < argc )
    {
      if ( !sub_804EDCF((int)argv[optind], (int)"w", stdout) )
      {
        v23 = argv[optind];
        v15 = sub_8051667(0, 3, (int)v23);
        v16 = *__errno_location();
        v24 = v15;
        error(1, v16, "%s", v15);
      }
      ++optind;
    }
    if ( optind < argc )
    {
      v21 = argv[optind];
      v17 = sub_805192F((int)v21);
      v18 = gettext("extra operand %s");
      v24 = v17;
      error(0, 0, v18, v17);
      sub_804DC6A(1);
    }
  }
  if ( !dword_805D72D )
  {
    if ( byte_805D248 )
      v19 = 1;
    else
      v19 = 2;
    dword_805D72D = v19;
  }
  sub_804AC86();
  if ( s1 )
    sub_804B21B(s1);
  if ( dword_805D73D )
  {
    sub_804B2AE(dword_805D73D, (int)&unk_805DBF1);
    if ( !dword_805DBF9 )
      dword_805D73D = 0;
  }
  if ( dword_805D739 )
  {
    sub_804B2AE(dword_805D739, (int)&unk_805DBFD);
    if ( !dword_805DC05 )
      dword_805D739 = 0;
  }
  nmemb = 0;
  qword_805DC11 = 0LL;
  dword_805DBE9 = 0;
  dword_805DBED = 0;
  i = 0;
  dword_805D214 = (int)&loc_804E7CD;
  sub_8056C61();
  do
  {
    v34 = 8 * i + dword_805DC21;
    sub_804AE20(*(char **)(4 * i + dword_805DC19), v34);
    sub_804B40B(i);
    *(_QWORD *)(dword_805DC1D + 8 * i++) = ++qword_805DC11;
  }
  while ( i < dword_805DC09 );
  sub_804B1E2();
  sub_804C0E8();
  sub_804DB2B();
  return 0;
}
// 804B40B: using guessed type _DWORD __cdecl sub_804B40B(_DWORD);
// 804DB2B: using guessed type int sub_804DB2B(void);
// 8056C61: using guessed type int sub_8056C61(void);
// 8056E4A: using guessed type int __stdcall sub_8056E4A(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8056F2E: using guessed type int __stdcall sub_8056F2E(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80570A9: using guessed type int sub_80570A9(void);
// 8057CFC: using guessed type char *off_8057CFC[2];
// 805D160: using guessed type int dword_805D160;
// 805D19C: using guessed type int dword_805D19C;
// 805D1C4: using guessed type int dword_805D1C4;
// 805D200: using guessed type int dword_805D200;
// 805D214: using guessed type int dword_805D214;
// 805D248: using guessed type char byte_805D248;
// 805D24C: using guessed type int dword_805D24C;
// 805D250: using guessed type int dword_805D250;
// 805D300: using guessed type int optind;
// 805D729: using guessed type char byte_805D729;
// 805D72A: using guessed type char byte_805D72A;
// 805D72B: using guessed type char byte_805D72B;
// 805D72D: using guessed type int dword_805D72D;
// 805D731: using guessed type char byte_805D731;
// 805D749: using guessed type int dword_805D749;
// 805D889: using guessed type int dword_805D889;
// 805DBE9: using guessed type int dword_805DBE9;
// 805DBED: using guessed type int dword_805DBED;
// 805DBF9: using guessed type int dword_805DBF9;
// 805DC05: using guessed type int dword_805DC05;
// 805DC09: using guessed type int dword_805DC09;
// 805DC11: using guessed type __int64 qword_805DC11;
// 805DC19: using guessed type int dword_805DC19;
// 805DC1D: using guessed type int dword_805DC1D;
// 805DC21: using guessed type int dword_805DC21;

//----- (0804E7F5) --------------------------------------------------------
void __noreturn sub_804E7F5()
{
  sub_804DC6A(1);
}

//----- (0804E809) --------------------------------------------------------
#error "804E883: call analysis failed (funcsize=115)"

//----- (0804E997) --------------------------------------------------------
void __usercall sub_804E997(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5)
{
  void *v5; // eax
  const char *format; // ST34_4
  int v7; // ebx
  int v8; // eax

  v5 = &loc_804E9BD;
  if ( a5 != -1 )
    v5 = &loc_804E9CB;
  dword_805D200 = (int)v5;
  sub_8056CD9(a2, a1);
  format = gettext("invalid argument %s for %s");
  v7 = sub_805190D(1, a3);
  v8 = sub_8051441(0, 8, a4);
  error(0, 0, format, v8, v7);
}
// 805D200: using guessed type int dword_805D200;

//----- (0804EA33) --------------------------------------------------------
int __cdecl sub_804EA33(int a1, int a2, size_t n)
{
  FILE *v3; // ebx
  char *v4; // eax
  const void *v6; // [esp+4h] [ebp-24h]
  int v7; // [esp+8h] [ebp-20h]
  int v8; // [esp+18h] [ebp-10h]
  void *s1; // [esp+1Ch] [ebp-Ch]

  s1 = 0;
  v3 = stderr;
  v4 = gettext("Valid arguments are:");
  fputs_unlocked(v4, v3);
  v8 = 0;
  dword_805D214 = (int)&loc_804EB38;
  sub_8056C61();
  do
  {
    if ( v8 && (v6 = (const void *)(a2 + v8 * n), !memcmp(s1, v6, n)) )
    {
      v7 = sub_805192F(*(_DWORD *)(4 * v8 + a1));
      fprintf(stderr, ", %s", v7);
    }
    else
    {
      v7 = sub_805192F(*(_DWORD *)(4 * v8 + a1));
      fprintf(stderr, "\n  - %s", v7);
      s1 = (void *)(v8 * n + a2);
    }
    ++v8;
  }
  while ( *(_DWORD *)(4 * v8 + a1) );
  return putc_unlocked(10, stderr);
}
// 80492B0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8056C61: using guessed type int sub_8056C61(void);
// 805D214: using guessed type int dword_805D214;

//----- (0804EB6C) --------------------------------------------------------
int __cdecl sub_804EB6C(int a1, char *s, int a3, int a4, size_t n, int a6)
{
  int v6; // edx
  int v7; // ecx
  int v9; // [esp+1Ch] [ebp-Ch]

  v9 = sub_804E809(s, a3, a4, n);
  if ( v9 >= 0 )
    return v9;
  sub_804E997(v6, v7, a1, (int)s, v9);
  sub_804EA33(a3, a4, n);
  ((void (*)(void))a6)();
  return -1;
}

//----- (0804EC9C) --------------------------------------------------------
int sub_804EC9C()
{
  int v0; // ebx
  int *v1; // eax
  int *v2; // eax
  int result; // eax
  char *v4; // [esp+2Ch] [ebp-Ch]

  if ( sub_80536D8(stdout) && (byte_805DD95 != 1 || *__errno_location() != 32) )
  {
    v4 = gettext("write error");
    if ( dword_805DD91 )
    {
      v0 = sub_805162A(dword_805DD91);
      v1 = __errno_location();
      error(0, *v1, "%s: %s", v0, v4);
    }
    else
    {
      v2 = __errno_location();
      error(0, *v2, "%s", v4);
    }
    _exit(status);
  }
  result = sub_80536D8(stderr);
  if ( result )
    _exit(status);
  return result;
}
// 805DD91: using guessed type int dword_805DD91;
// 805DD95: using guessed type char byte_805DD95;

//----- (0804ED80) --------------------------------------------------------
signed int __cdecl sub_804ED80(int a1)
{
  int fd; // [esp+1Ch] [ebp-Ch]

  fd = open64("/dev/null", 0);
  if ( fd == a1 )
    return 1;
  if ( fd >= 0 )
  {
    close(fd);
    *__errno_location() = 9;
  }
  return 0;
}
// 8049000: using guessed type int __cdecl open64(_DWORD, _DWORD);

//----- (0804EDCF) --------------------------------------------------------
#error "804EE92: call analysis failed (funcsize=145)"

//----- (0804EFD4) --------------------------------------------------------
#error "804F03A: call analysis failed (funcsize=71)"

//----- (0804F0DB) --------------------------------------------------------
int __usercall sub_804F0DB@<eax>(int a1@<ebx>, unsigned __int8 *a2, int a3)
{
  int v3; // edx
  int v4; // ecx
  void *v5; // eax
  int v6; // edx
  int v7; // ecx
  void *v8; // eax
  int v9; // edx
  int v10; // ecx
  void *v11; // eax
  int v12; // edx
  int v13; // ecx
  void *v14; // eax
  void *v15; // eax
  void *v16; // eax
  size_t v17; // eax
  void *v18; // eax
  int v20; // [esp+0h] [ebp-B8h]
  int v21; // [esp+4h] [ebp-B4h]
  int v22; // [esp+8h] [ebp-B0h]
  int v23; // [esp+Ch] [ebp-ACh]
  int v24; // [esp+10h] [ebp-A8h]
  int v25; // [esp+14h] [ebp-A4h]
  int v26; // [esp+18h] [ebp-A0h]
  unsigned __int8 *v27; // [esp+1Ch] [ebp-9Ch]
  unsigned __int8 v28; // [esp+2Bh] [ebp-8Dh]
  char v29; // [esp+2Ch] [ebp-8Ch]
  char v30; // [esp+2Dh] [ebp-8Bh]
  char v31; // [esp+2Eh] [ebp-8Ah]
  char v32; // [esp+2Fh] [ebp-89h]
  char *s; // [esp+30h] [ebp-88h]
  unsigned __int8 *v34; // [esp+34h] [ebp-84h]
  unsigned __int8 *v35; // [esp+38h] [ebp-80h]
  char v36; // [esp+3Ch] [ebp-7Ch]
  int v37; // [esp+40h] [ebp-78h]
  char v38; // [esp+48h] [ebp-70h]
  unsigned __int8 *v39; // [esp+4Ch] [ebp-6Ch]
  int v40; // [esp+50h] [ebp-68h]
  int v41; // [esp+54h] [ebp-64h]
  wint_t v42; // [esp+58h] [ebp-60h]
  char *v43; // [esp+5Ch] [ebp-5Ch]
  int v44; // [esp+60h] [ebp-58h]
  int v45; // [esp+64h] [ebp-54h]
  int v46; // [esp+68h] [ebp-50h]
  int v47; // [esp+6Ch] [ebp-4Ch]
  int v48; // [esp+70h] [ebp-48h]
  unsigned __int8 *v49; // [esp+74h] [ebp-44h]
  int v50; // [esp+78h] [ebp-40h]
  int v51; // [esp+7Ch] [ebp-3Ch]
  wint_t wc; // [esp+80h] [ebp-38h]
  char *v53; // [esp+84h] [ebp-34h]
  int v54; // [esp+88h] [ebp-30h]
  int v55; // [esp+8Ch] [ebp-2Ch]
  int v56; // [esp+90h] [ebp-28h]
  int v57; // [esp+94h] [ebp-24h]
  int v58; // [esp+98h] [ebp-20h]
  unsigned int v59; // [esp+ACh] [ebp-Ch]

  v27 = a2;
  v26 = a3;
  v59 = __readgsdword(0x14u);
  s = (char *)sub_8051D12(a3, 2);
  v28 = 0;
  while ( *v27 )
  {
    v34 = sub_8054C36(a1, v27, s);
    if ( !v34 )
      break;
    if ( __ctype_get_mb_cur_max() > 1 )
    {
      v39 = v27;
      v36 = 0;
      memset(&v37, 0, 8u);
      v38 = 0;
      v29 = 1;
      if ( v39 < v34 )
      {
        sub_8055570(&v36);
        if ( (_BYTE)v41 != 1 || v42 )
        {
          dword_805D200 = (int)&loc_804F1F6;
          sub_8056CD9(v4, v3);
        }
        abort();
      }
      v39 = v34;
      v36 = 0;
      memset(&v37, 0, 8u);
      v38 = 0;
      v53 = s;
      LOBYTE(v49) = 0;
      memset(&v50, 0, 8u);
      LOBYTE(wc) = 0;
      sub_8055570(&v49);
      if ( (_BYTE)v55 == 1 )
      {
        v5 = &loc_804F396;
        if ( !v56 )
          v5 = &loc_804F39D;
        dword_805D1D8 = (int)v5;
        sub_8056DBD(v20, v21, v22, v23, v24, v25, v26);
      }
      dword_805D214 = (int)&loc_804F2F7;
      sub_8056C61();
      v30 = 1;
      sub_8055570(&v36);
      v8 = &loc_804F3F5;
      if ( (_BYTE)v41 != 1 )
        v8 = &loc_804F415;
      dword_805D174 = (int)v8;
      sub_8057037(v7, v6, v20);
      v11 = &loc_804F415;
      if ( !v42 )
        v11 = &loc_804F41C;
      dword_805D1B0 = (int)v11;
      sub_8056EB8(v10, v9);
      dword_805D214 = (int)&loc_804F43E;
      sub_8056C61();
      v49 = v39;
      v50 = v40;
      v51 = v41;
      wc = v42;
      v53 = v43;
      v54 = v44;
      v55 = v45;
      v56 = v46;
      v57 = v47;
      v58 = v48;
      if ( (_BYTE)v41 && iswalnum(wc) )
        v30 = 0;
      if ( v29 )
      {
        v14 = &loc_804F4E3;
        if ( !v30 )
          v14 = &loc_804F501;
        dword_805D200 = (int)v14;
        sub_8056CD9(v13, v12);
        v28 = 1;
        dword_805D1C4 = (int)&loc_804F6D2;
        sub_8056E4A(v20, v21, v22, v23, v24, v25, v26);
      }
      v39 = v34;
      v36 = 0;
      memset(&v37, 0, 8u);
      v38 = 0;
      sub_8055570(&v36);
      v15 = &loc_804F55F;
      if ( (_BYTE)v41 != 1 )
        v15 = &loc_804F566;
      dword_805D1C4 = (int)v15;
      sub_8056E4A(v20, v21, v22, v23, v24, v25, v26);
      v16 = &loc_804F58F;
      if ( v42 )
        v16 = &loc_804F594;
      dword_805D214 = (int)v16;
      sub_8056C61();
      break;
    }
    v31 = 1;
    if ( v27 < v34 && (*__ctype_b_loc())[*(v34 - 1)] & 8 )
      v31 = 0;
    v17 = strlen(s);
    v35 = &v34[v17];
    v32 = 1;
    if ( v34[v17] && (*__ctype_b_loc())[*v35] & 8 )
      v32 = 0;
    v18 = &loc_804F691;
    if ( !v31 )
      v18 = &loc_804F6A3;
    dword_805D160 = (int)v18;
    sub_80570A9();
    if ( v32 )
    {
      v28 = 1;
      break;
    }
    if ( !*v34 )
      break;
    v27 = v34 + 1;
  }
  free(s);
  return v28;
}
// 8051D12: using guessed type _DWORD __cdecl sub_8051D12(_DWORD, _DWORD);
// 8055570: using guessed type _DWORD __cdecl sub_8055570(_DWORD);
// 8056C61: using guessed type int sub_8056C61(void);
// 8056DBD: using guessed type int __stdcall sub_8056DBD(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8056E4A: using guessed type int __stdcall sub_8056E4A(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8056EB8: using guessed type int __fastcall sub_8056EB8(_DWORD, _DWORD);
// 80570A9: using guessed type int sub_80570A9(void);
// 805D160: using guessed type int dword_805D160;
// 805D174: using guessed type int dword_805D174;
// 805D1B0: using guessed type int dword_805D1B0;
// 805D1C4: using guessed type int dword_805D1C4;
// 805D1D8: using guessed type int dword_805D1D8;
// 805D200: using guessed type int dword_805D200;
// 805D214: using guessed type int dword_805D214;

//----- (0804F79E) --------------------------------------------------------
#error "804F95A: call analysis failed (funcsize=210)"

//----- (0804FB20) --------------------------------------------------------
#error "804FB92: call analysis failed (funcsize=37)"

//----- (0804FB97) --------------------------------------------------------
#error "804FBE2: positive sp value has been found (funcsize=27)"

//----- (0804FC0F) --------------------------------------------------------
int *__cdecl sub_804FC0F(int *a1, int a2, int a3)
{
  int *result; // eax

  if ( !a1 )
    a1 = &dword_805DDA9;
  *a1 = 10;
  if ( !a2 || !a3 )
    abort();
  a1[10] = a2;
  result = a1;
  a1[11] = a3;
  return result;
}
// 805DDA9: using guessed type int dword_805DDA9;

//----- (0804FC50) --------------------------------------------------------
#error "804FCD6: call analysis failed (funcsize=40)"

//----- (0804FCDB) --------------------------------------------------------
#error "804FD21: positive sp value has been found (funcsize=0)"

//----- (0804FD27) --------------------------------------------------------
char *__cdecl sub_804FD27(char *msgid, int a2)
{
  char *result; // eax
  void *v3; // eax
  void *v4; // eax
  int v5; // [esp+0h] [ebp-28h]
  int v6; // [esp+4h] [ebp-24h]
  int v7; // [esp+8h] [ebp-20h]
  int v8; // [esp+Ch] [ebp-1Ch]
  int v9; // [esp+10h] [ebp-18h]
  int v10; // [esp+14h] [ebp-14h]
  char *v11; // [esp+18h] [ebp-10h]
  unsigned __int8 *v12; // [esp+1Ch] [ebp-Ch]

  v11 = gettext(msgid);
  if ( v11 != msgid )
    return v11;
  v12 = (unsigned __int8 *)sub_8053D4F();
  if ( sub_805365E(v12, "UTF-8") )
  {
    if ( sub_805365E(v12, "GB18030") )
    {
      v4 = &loc_804FDEC;
      if ( a2 != 9 )
        v4 = &loc_804FE08;
      dword_805D1C4 = (int)v4;
      sub_8056E4A(v5, v6, v7, v8, v9, v10, v11);
      dword_805D160 = (int)&locret_804FE0D;
      sub_80570A9();
      result = "'";
    }
    else
    {
      v3 = &loc_804FDBF;
      if ( *msgid != 96 )
        v3 = &loc_804FDC6;
      dword_805D160 = (int)v3;
      sub_80570A9();
      result = (char *)&unk_80581BE;
    }
  }
  else if ( *msgid == 96 )
  {
    result = (char *)&unk_80581AE;
  }
  else
  {
    result = (char *)&unk_80581B2;
  }
  return result;
}
// 8056E4A: using guessed type int __stdcall sub_8056E4A(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80570A9: using guessed type int sub_80570A9(void);
// 805D160: using guessed type int dword_805D160;
// 805D1C4: using guessed type int dword_805D1C4;

//----- (0804FE0F) --------------------------------------------------------
#error "804FFBA: call analysis failed (funcsize=924)"

//----- (08050E84) --------------------------------------------------------
#error "8050F04: call analysis failed (funcsize=42)"

//----- (08050F09) --------------------------------------------------------
#error "8050FF5: positive sp value has been found (funcsize=63)"

//----- (08051090) --------------------------------------------------------
#error "8051335: call analysis failed (funcsize=192)"

//----- (0805138C) --------------------------------------------------------
int __cdecl sub_805138C(int a1, int a2)
{
  return sub_8051090(a1, a2, -1, &dword_805DDA9);
}
// 8051090: using guessed type _DWORD __cdecl sub_8051090(_DWORD, _DWORD, _DWORD, _DWORD);
// 805DDA9: using guessed type int dword_805DDA9;

//----- (080513B6) --------------------------------------------------------
#error "80513E0: call analysis failed (funcsize=14)"

//----- (080513E5) --------------------------------------------------------
#error "8051403: positive sp value has been found (funcsize=0)"

//----- (08051441) --------------------------------------------------------
int __cdecl sub_8051441(int a1, int a2, int a3)
{
  char v4; // [esp+10h] [ebp-38h]

  sub_804FC50(&v4, a2);
  return sub_8051090(a1, a3, -1, &v4);
}
// 804FC50: using guessed type _DWORD __cdecl sub_804FC50(_DWORD, _DWORD);
// 8051090: using guessed type _DWORD __cdecl sub_8051090(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0805147F) --------------------------------------------------------
int __cdecl sub_805147F(int a1, int a2, int a3, int a4)
{
  char v5; // [esp+10h] [ebp-38h]

  sub_804FC50(&v5, a2);
  return sub_8051090(a1, a3, a4, &v5);
}
// 804FC50: using guessed type _DWORD __cdecl sub_804FC50(_DWORD, _DWORD);
// 8051090: using guessed type _DWORD __cdecl sub_8051090(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08051517) --------------------------------------------------------
int __cdecl sub_8051517(int a1, int a2, char a3)
{
  int v4; // [esp+0h] [ebp-58h]
  int v5; // [esp+8h] [ebp-50h]
  char v6; // [esp+1Ch] [ebp-3Ch]
  int v7; // [esp+20h] [ebp-38h]
  int v8; // [esp+24h] [ebp-34h]
  int v9; // [esp+28h] [ebp-30h]
  int v10; // [esp+2Ch] [ebp-2Ch]
  int v11; // [esp+30h] [ebp-28h]
  int v12; // [esp+34h] [ebp-24h]
  int v13; // [esp+38h] [ebp-20h]
  int v14; // [esp+3Ch] [ebp-1Ch]
  int v15; // [esp+40h] [ebp-18h]
  int v16; // [esp+44h] [ebp-14h]
  int v17; // [esp+48h] [ebp-10h]
  int v18; // [esp+4Ch] [ebp-Ch]

  v6 = a3;
  v7 = dword_805DDA9;
  v8 = dword_805DDAD;
  v9 = dword_805DDB1;
  v10 = dword_805DDB5;
  v11 = dword_805DDB9;
  v12 = dword_805DDBD;
  v13 = dword_805DDC1;
  v14 = dword_805DDC5;
  v15 = dword_805DDC9;
  v16 = dword_805DDCD;
  v17 = dword_805DDD1;
  v18 = dword_805DDD5;
  v5 = 1;
  sub_804FB20(&v4 - 14, a3);
  return sub_8051090(0, a1, a2, &v7);
}
// 804FB20: using guessed type _DWORD __cdecl sub_804FB20(_DWORD, _DWORD);
// 8051090: using guessed type _DWORD __cdecl sub_8051090(_DWORD, _DWORD, _DWORD, _DWORD);
// 805DDA9: using guessed type int dword_805DDA9;
// 805DDAD: using guessed type int dword_805DDAD;
// 805DDB1: using guessed type int dword_805DDB1;
// 805DDB5: using guessed type int dword_805DDB5;
// 805DDB9: using guessed type int dword_805DDB9;
// 805DDBD: using guessed type int dword_805DDBD;
// 805DDC1: using guessed type int dword_805DDC1;
// 805DDC5: using guessed type int dword_805DDC5;
// 805DDC9: using guessed type int dword_805DDC9;
// 805DDCD: using guessed type int dword_805DDCD;
// 805DDD1: using guessed type int dword_805DDD1;
// 805DDD5: using guessed type int dword_805DDD5;

//----- (080515F1) --------------------------------------------------------
int __cdecl sub_80515F1(int a1, char a2)
{
  return sub_8051517(a1, -1, a2);
}

//----- (0805162A) --------------------------------------------------------
int __cdecl sub_805162A(int a1)
{
  return sub_80515F1(a1, 58);
}

//----- (08051667) --------------------------------------------------------
int __cdecl sub_8051667(int a1, int a2, int a3)
{
  int v4; // [esp-4h] [ebp-7Ch]
  int v5; // [esp+4h] [ebp-74h]
  int v6; // [esp+10h] [ebp-68h]
  int v7; // [esp+14h] [ebp-64h]
  int v8; // [esp+18h] [ebp-60h]
  int v9; // [esp+1Ch] [ebp-5Ch]
  int v10; // [esp+20h] [ebp-58h]
  int v11; // [esp+24h] [ebp-54h]
  int v12; // [esp+28h] [ebp-50h]
  int v13; // [esp+2Ch] [ebp-4Ch]
  int v14; // [esp+30h] [ebp-48h]
  int v15; // [esp+34h] [ebp-44h]
  int v16; // [esp+38h] [ebp-40h]
  int v17; // [esp+3Ch] [ebp-3Ch]
  int v18; // [esp+40h] [ebp-38h]
  int v19; // [esp+44h] [ebp-34h]
  int v20; // [esp+48h] [ebp-30h]
  int v21; // [esp+4Ch] [ebp-2Ch]
  int v22; // [esp+50h] [ebp-28h]
  int v23; // [esp+54h] [ebp-24h]
  int v24; // [esp+58h] [ebp-20h]
  int v25; // [esp+5Ch] [ebp-1Ch]
  int v26; // [esp+60h] [ebp-18h]
  int v27; // [esp+64h] [ebp-14h]
  int v28; // [esp+68h] [ebp-10h]
  int v29; // [esp+6Ch] [ebp-Ch]

  sub_804FC50(&v6, a2);
  v18 = v6;
  v19 = v7;
  v20 = v8;
  v21 = v9;
  v22 = v10;
  v23 = v11;
  v24 = v12;
  v25 = v13;
  v26 = v14;
  v27 = v15;
  v28 = v16;
  v29 = v17;
  v5 = 1;
  sub_804FB20(&v4 - 14, 58);
  return sub_8051090(a1, a3, -1, &v18);
}
// 804FB20: using guessed type _DWORD __cdecl sub_804FB20(_DWORD, _DWORD);
// 804FC50: using guessed type _DWORD __cdecl sub_804FC50(_DWORD, _DWORD);
// 8051090: using guessed type _DWORD __cdecl sub_8051090(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08051728) --------------------------------------------------------
int __cdecl sub_8051728(int a1, int a2, int a3, int a4)
{
  return sub_8051778(a1, a2, a3, a4, -1);
}

//----- (08051778) --------------------------------------------------------
int __cdecl sub_8051778(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [esp+0h] [ebp-48h]
  int v7; // [esp+10h] [ebp-38h]
  int v8; // [esp+14h] [ebp-34h]
  int v9; // [esp+18h] [ebp-30h]
  int v10; // [esp+1Ch] [ebp-2Ch]
  int v11; // [esp+20h] [ebp-28h]
  int v12; // [esp+24h] [ebp-24h]
  int v13; // [esp+28h] [ebp-20h]
  int v14; // [esp+2Ch] [ebp-1Ch]
  int v15; // [esp+30h] [ebp-18h]
  int v16; // [esp+34h] [ebp-14h]
  int v17; // [esp+38h] [ebp-10h]
  int v18; // [esp+3Ch] [ebp-Ch]

  v7 = dword_805DDA9;
  v8 = dword_805DDAD;
  v9 = dword_805DDB1;
  v10 = dword_805DDB5;
  v11 = dword_805DDB9;
  v12 = dword_805DDBD;
  v13 = dword_805DDC1;
  v14 = dword_805DDC5;
  v15 = dword_805DDC9;
  v16 = dword_805DDCD;
  v17 = dword_805DDD1;
  v18 = dword_805DDD5;
  sub_804FC0F(&v6 - 14, a2, a3);
  return sub_8051090(a1, a4, a5, &v7);
}
// 8051090: using guessed type _DWORD __cdecl sub_8051090(_DWORD, _DWORD, _DWORD, _DWORD);
// 805DDA9: using guessed type int dword_805DDA9;
// 805DDAD: using guessed type int dword_805DDAD;
// 805DDB1: using guessed type int dword_805DDB1;
// 805DDB5: using guessed type int dword_805DDB5;
// 805DDB9: using guessed type int dword_805DDB9;
// 805DDBD: using guessed type int dword_805DDBD;
// 805DDC1: using guessed type int dword_805DDC1;
// 805DDC5: using guessed type int dword_805DDC5;
// 805DDC9: using guessed type int dword_805DDC9;
// 805DDCD: using guessed type int dword_805DDCD;
// 805DDD1: using guessed type int dword_805DDD1;
// 805DDD5: using guessed type int dword_805DDD5;

//----- (080518B2) --------------------------------------------------------
int __cdecl sub_80518B2(int a1, int a2, int a3)
{
  return sub_8051090(a1, a2, a3, &unk_805D2A0);
}
// 8051090: using guessed type _DWORD __cdecl sub_8051090(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0805190D) --------------------------------------------------------
int __cdecl sub_805190D(int a1, int a2)
{
  return sub_80518B2(a1, a2, -1);
}

//----- (0805192F) --------------------------------------------------------
int __cdecl sub_805192F(int a1)
{
  return sub_805190D(0, a1);
}

//----- (0805194A) --------------------------------------------------------
int __cdecl sub_805194A(FILE *stream)
{
  int v1; // eax
  __int64 v2; // rax
  bool v4; // zf
  void *v5; // eax
  void *v6; // eax
  int v7; // [esp+0h] [ebp-A8h]
  int v8; // [esp+0h] [ebp-A8h]
  int v9; // [esp+4h] [ebp-A4h]
  int v10; // [esp+8h] [ebp-A0h]
  int v11; // [esp+Ch] [ebp-9Ch]
  void *ptr; // [esp+10h] [ebp-98h]
  void *ptra; // [esp+10h] [ebp-98h]
  size_t size; // [esp+14h] [ebp-94h]
  int v15; // [esp+1Ch] [ebp-8Ch]
  int v16; // [esp+1Ch] [ebp-8Ch]
  size_t v17; // [esp+24h] [ebp-84h]
  int v18; // [esp+28h] [ebp-80h]
  int v19; // [esp+2Ch] [ebp-7Ch]
  __int64 v20; // [esp+30h] [ebp-78h]
  __int64 v21; // [esp+38h] [ebp-70h]
  char v22; // [esp+40h] [ebp-68h]
  int v23; // [esp+44h] [ebp-64h]
  int v24; // [esp+48h] [ebp-60h]
  int v25; // [esp+4Ch] [ebp-5Ch]
  int v26; // [esp+50h] [ebp-58h]
  int v27; // [esp+54h] [ebp-54h]
  int v28; // [esp+58h] [ebp-50h]
  __int64 v29; // [esp+6Ch] [ebp-3Ch]

  size = 0x2000;
  v1 = fileno(stream);
  if ( sub_8056ACE(v1, (int)&v22) >= 0 && (v26 & 0xF000) == 0x8000 )
  {
    LODWORD(v2) = ftello64(stream);
    v20 = v2;
    if ( v2 >= 0 && v29 > v2 )
    {
      v21 = v29 - v2;
      if ( v29 - v2 > 4294967294LL )
      {
        *__errno_location() = 12;
        return 0;
      }
      size = v21 + 1;
    }
  }
  ptr = malloc(size);
  if ( !ptr )
    return 0;
  v17 = fread(ptr, 1u, size, stream);
  if ( v17 == size )
  {
    v6 = &loc_8051B9D;
    if ( size != -1 )
      v6 = &loc_8051BA9;
    dword_805D1D8 = (int)v6;
    sub_8056DBD(v7, v9, v10, v11, ptr, size, v17);
    v16 = 12;
  }
  else
  {
    v15 = *__errno_location();
    v4 = ferror(stream) == 0;
    v5 = &loc_8051AF8;
    if ( v4 )
      v5 = &loc_8051AFD;
    dword_805D1EC = (int)v5;
    sub_8056D4D(
      v8,
      v9,
      v10,
      v11,
      ptr,
      size,
      v17,
      v15,
      size,
      v17,
      v18,
      v19,
      v20,
      HIDWORD(v20),
      v21,
      HIDWORD(v21),
      *(_DWORD *)&v22,
      v23,
      v24,
      v25,
      v26,
      v27,
      v28);
  }
  free(ptra);
  *__errno_location() = v16;
  return 0;
}
// 8049280: using guessed type int __cdecl ftello64(_DWORD);
// 8056D4D: using guessed type int __stdcall sub_8056D4D(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8056DBD: using guessed type int __stdcall sub_8056DBD(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 805D1D8: using guessed type int dword_805D1D8;
// 805D1EC: using guessed type int dword_805D1EC;

//----- (08051C47) --------------------------------------------------------
void *__cdecl sub_8051C47(int a1, int a2, int a3)
{
  int v4; // [esp+14h] [ebp-14h]
  FILE *stream; // [esp+18h] [ebp-10h]
  void *ptr; // [esp+1Ch] [ebp-Ch]

  stream = (FILE *)fopen64(a1, a3);
  if ( !stream )
    return 0;
  ptr = (void *)sub_805194A(stream);
  v4 = *__errno_location();
  if ( !sub_805330B(stream) )
    return ptr;
  if ( ptr )
  {
    v4 = *__errno_location();
    free(ptr);
  }
  *__errno_location() = v4;
  return 0;
}
// 8049160: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (08051CCE) --------------------------------------------------------
void *__cdecl sub_8051CCE(int a1, int a2)
{
  return sub_8051C47(a1, a2, (int)&unk_80584F4);
}

//----- (08051D12) --------------------------------------------------------
#error "8051E01: call analysis failed (funcsize=260)"

//----- (08052080) --------------------------------------------------------
#error "8052502: call analysis failed (funcsize=374)"

//----- (08052834) --------------------------------------------------------
int __cdecl sub_8052834(FILE *stream, int a2, int a3, int a4, int a5)
{
  int *v5; // eax
  unsigned int i; // [esp+24h] [ebp-34h]
  int v8[12]; // [esp+28h] [ebp-30h]

  for ( i = 0; i <= 9; ++i )
  {
    v5 = (int *)a5;
    a5 += 4;
    v8[i] = *v5;
    if ( !v8[i] )
      break;
  }
  return sub_8052080(stream, a2, a3, a4, (int)v8, i);
}
// 8052834: using guessed type int var_30[12];

//----- (080528BA) --------------------------------------------------------
int sub_80528BA(FILE *stream, int a2, int a3, int a4, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a4);
  return sub_8052834(stream, a2, a3, a4, (int)va);
}

//----- (0805297A) --------------------------------------------------------
void *__cdecl sub_805297A(unsigned int a1, unsigned int a2)
{
  if ( 0x7FFFFFFF / a2 < a1 )
    sub_8052C22();
  return sub_8052AA0(a2 * a1);
}

//----- (080529DD) --------------------------------------------------------
void *__cdecl sub_80529DD(void *ptr, int a2, int a3)
{
  void *v3; // eax
  unsigned int v5; // [esp+1Ch] [ebp-Ch]
  unsigned int v6; // [esp+1Ch] [ebp-Ch]

  v5 = *(_DWORD *)a2;
  if ( ptr )
  {
    if ( 0x55555554u / a3 <= v5 )
      sub_8052C22();
    v6 = (v5 >> 1) + v5 + 1;
  }
  else
  {
    v3 = &loc_8052A10;
    if ( v5 )
      v3 = &loc_8052A2D;
    dword_805D214 = (int)v3;
    sub_8056C61();
    v6 = (0x40u / a3 == 0) + 0x40u / a3;
    if ( 0x7FFFFFFFu / a3 < v6 )
      sub_8052C22();
  }
  *(_DWORD *)a2 = v6;
  return sub_8052ACA(ptr, a3 * v6);
}
// 8056C61: using guessed type int sub_8056C61(void);
// 805D214: using guessed type int dword_805D214;

//----- (08052A8D) --------------------------------------------------------
void *__cdecl sub_8052A8D(size_t size)
{
  return sub_8052AA0(size);
}

//----- (08052AA0) --------------------------------------------------------
void *__cdecl sub_8052AA0(size_t size)
{
  void *v2; // [esp+1Ch] [ebp-Ch]

  v2 = malloc(size);
  if ( !v2 && size )
    sub_8052C22();
  return v2;
}

//----- (08052ACA) --------------------------------------------------------
void *__cdecl sub_8052ACA(void *ptr, size_t size)
{
  void *result; // eax
  void *v3; // eax
  bool v4; // zf
  void *v5; // eax
  void *ptra; // [esp+20h] [ebp+8h]

  if ( size || !ptr )
  {
    v3 = realloc(ptr, size);
    ptra = v3;
    v4 = v3 == 0;
    v5 = &loc_8052B22;
    if ( !v4 )
      v5 = &loc_8052B2D;
    dword_805D160 = (int)v5;
    sub_80570A9();
    if ( size )
      sub_8052C22();
    result = ptra;
  }
  else
  {
    free(ptr);
    result = 0;
  }
  return result;
}
// 80570A9: using guessed type int sub_80570A9(void);
// 805D160: using guessed type int dword_805D160;

//----- (08052BD4) --------------------------------------------------------
void *__cdecl sub_8052BD4(void *src, size_t n)
{
  void *v2; // eax

  v2 = sub_8052AA0(n);
  return memcpy(v2, src, n);
}

//----- (08052C22) --------------------------------------------------------
void __noreturn sub_8052C22()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (08052CFE) --------------------------------------------------------
#error "8052D46: call analysis failed (funcsize=29)"

//----- (08052D55) --------------------------------------------------------
#error "8052E14: call analysis failed (funcsize=93)"

//----- (08052E88) --------------------------------------------------------
int __cdecl sub_8052E88(int a1, int a2, int a3)
{
  int v3; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; ; i |= sub_8052D55(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}
// 8052D55: using guessed type _DWORD __cdecl sub_8052D55(_DWORD, _DWORD);

//----- (08052EBE) --------------------------------------------------------
int __cdecl sub_8052EBE(char *nptr, int a2, int base, int a4, char *s)
{
  char **v5; // eax
  int v6; // edx
  int v7; // ecx
  int result; // eax
  int v9; // edx
  int v10; // ecx
  void *v11; // eax
  int v12; // edx
  int v13; // [esp+0h] [ebp-38h]
  int v14; // [esp+0h] [ebp-38h]
  int v15; // [esp+4h] [ebp-34h]
  int v16; // [esp+8h] [ebp-30h]
  int v17; // [esp+Ch] [ebp-2Ch]
  char v18; // [esp+10h] [ebp-28h]
  int v19; // [esp+14h] [ebp-24h]
  int v20; // [esp+18h] [ebp-20h]
  char **endptr; // [esp+24h] [ebp-14h]
  intmax_t v22; // [esp+28h] [ebp-10h]

  v19 = 0;
  if ( base < 0 || base > 36 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoimax");
  if ( a2 )
    v5 = (char **)a2;
  else
    v5 = (char **)&v18;
  endptr = v5;
  *__errno_location() = 0;
  v22 = strtoimax(nptr, endptr, base);
  if ( *endptr == nptr )
  {
    if ( s && **endptr )
    {
      if ( strchr(s, **endptr) )
      {
        v22 = 1LL;
        dword_805D174 = (int)&loc_8052FDB;
        sub_8057037(v7, v6, v14);
      }
    }
    result = 4;
  }
  else
  {
    if ( *__errno_location() )
    {
      if ( *__errno_location() != 34 )
      {
        dword_805D200 = (int)&locret_8053309;
        sub_8056CD9(v10, v9);
      }
      v19 = 1;
    }
    v11 = &loc_8052FFA;
    if ( s )
      v11 = &loc_8053010;
    dword_805D1C4 = (int)v11;
    sub_8056E4A(v13, v15, v16, v17, *(_DWORD *)&v18, v19, v20);
    v12 = HIDWORD(v22);
    *(_DWORD *)a4 = v22;
    *(_DWORD *)(a4 + 4) = v12;
    result = v19;
  }
  return result;
}
// 8056E4A: using guessed type int __stdcall sub_8056E4A(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 805D174: using guessed type int dword_805D174;
// 805D1C4: using guessed type int dword_805D1C4;
// 805D200: using guessed type int dword_805D200;

//----- (0805330B) --------------------------------------------------------
int __cdecl sub_805330B(FILE *stream)
{
  int v1; // eax
  __int64 v2; // rax
  bool v3; // zf
  void *v4; // eax
  int v5; // edx
  int v6; // ecx
  void *v7; // eax
  void *v8; // eax
  int v10; // [esp+0h] [ebp-28h]
  int v11; // [esp+4h] [ebp-24h]
  int v12; // [esp+8h] [ebp-20h]
  int v13; // [esp+Ch] [ebp-1Ch]
  int v14; // [esp+10h] [ebp-18h]
  int v15; // [esp+14h] [ebp-14h]
  int v16; // [esp+18h] [ebp-10h]
  int v17; // [esp+1Ch] [ebp-Ch]

  v15 = 0;
  v16 = 0;
  v17 = fileno(stream);
  if ( v17 < 0 )
  {
    fclose(stream);
    dword_805D214 = (int)&locret_8053429;
    sub_8056C61();
  }
  if ( __freading(stream) )
  {
    v1 = fileno(stream);
    LODWORD(v2) = lseek64(v1, 0, 0, 1);
    v3 = v2 == -1;
    v4 = &loc_80533B6;
    if ( v3 )
      v4 = &loc_80533E8;
    dword_805D214 = (int)v4;
    sub_8056C61();
  }
  v3 = sub_8053464(stream) == 0;
  v7 = &loc_80533DE;
  if ( v3 )
    v7 = &loc_80533E8;
  dword_805D174 = (int)v7;
  sub_8057037(v6, v5, v10);
  v15 = *__errno_location();
  v16 = fclose(stream);
  v8 = &loc_8053415;
  if ( !v15 )
    v8 = &loc_8053426;
  dword_805D1C4 = (int)v8;
  sub_8056E4A(v10, v11, v12, v13, v14, v15, v16);
  *__errno_location() = v15;
  return -1;
}
// 805330B: could not find valid save-restore pair for ebx
// 8049430: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8056C61: using guessed type int sub_8056C61(void);
// 8056E4A: using guessed type int __stdcall sub_8056E4A(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 805D174: using guessed type int dword_805D174;
// 805D1C4: using guessed type int dword_805D1C4;
// 805D214: using guessed type int dword_805D214;

//----- (0805342B) --------------------------------------------------------
int __cdecl sub_805342B(FILE *stream)
{
  int result; // eax

  result = stream->_flags & 0x100;
  if ( result )
    result = sub_80534BD(stream, 0, 0, 1);
  return result;
}

//----- (08053464) --------------------------------------------------------
#error "8053493: call analysis failed (funcsize=24)"

//----- (080534BD) --------------------------------------------------------
#error "80535AE: call analysis failed (funcsize=84)"

//----- (080535EC) --------------------------------------------------------
size_t __cdecl sub_80535EC(wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  char v5; // [esp+18h] [ebp-10h]
  size_t v6; // [esp+1Ch] [ebp-Ch]

  if ( !pwc )
    pwc = (wchar_t *)&v5;
  v6 = mbrtowc(pwc, s, n, p);
  if ( v6 <= 0xFFFFFFFD || !n || !((unsigned __int8)sub_8053759(0) ^ 1) )
    return v6;
  *pwc = (unsigned __int8)*s;
  return 1;
}

//----- (0805365E) --------------------------------------------------------
int __cdecl sub_805365E(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // esi
  unsigned __int8 *v3; // ebx
  int v5; // edx
  int v6; // ecx
  int v7; // [esp+0h] [ebp-28h]
  unsigned __int8 v8; // [esp+1Eh] [ebp-Ah]
  unsigned __int8 v9; // [esp+1Fh] [ebp-9h]

  v2 = a1;
  v3 = a2;
  if ( a1 == a2 )
    return 0;
  do
  {
    v8 = sub_8056450(*v2);
    v9 = sub_8056450(*v3);
    if ( !v8 )
    {
      dword_805D174 = (int)&loc_80536C5;
      sub_8057037(v6, v5, v7);
    }
    ++v2;
    ++v3;
  }
  while ( v8 == v9 );
  return v8 - v9;
}
// 805D174: using guessed type int dword_805D174;

//----- (080536D8) --------------------------------------------------------
int __cdecl sub_80536D8(FILE *fp)
{
  bool v1; // ST1E_1
  bool v3; // [esp+1Dh] [ebp-Bh]
  bool v4; // [esp+1Fh] [ebp-9h]

  v3 = __fpending(fp) != 0;
  v1 = ferror_unlocked(fp) != 0;
  v4 = sub_805330B(fp) != 0;
  if ( !v1 && (!v4 || !v3 && *__errno_location() == 9) )
    return 0;
  if ( v4 != 1 )
    *__errno_location() = 0;
  return -1;
}

//----- (08053759) --------------------------------------------------------
int __cdecl sub_8053759(int category)
{
  bool v1; // zf
  void *v2; // eax
  int v4; // [esp+0h] [ebp-28h]
  int v5; // [esp+4h] [ebp-24h]
  int v6; // [esp+8h] [ebp-20h]
  int v7; // [esp+Ch] [ebp-1Ch]
  int v8; // [esp+10h] [ebp-18h]
  int v9; // [esp+14h] [ebp-14h]
  int v10; // [esp+18h] [ebp-10h]
  const char *s1; // [esp+1Ch] [ebp-Ch]

  HIBYTE(v10) = 1;
  s1 = setlocale(category, 0);
  if ( s1 )
  {
    if ( strcmp(s1, "C") )
    {
      v1 = strcmp(s1, "POSIX") == 0;
      v2 = &loc_80537C6;
      if ( !v1 )
        v2 = &loc_80537CA;
      dword_805D1C4 = (int)v2;
      sub_8056E4A(v4, v5, v6, v7, v8, v9, v10);
    }
    HIBYTE(v10) = 0;
  }
  return HIBYTE(v10);
}
// 8056E4A: using guessed type int __stdcall sub_8056E4A(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 805D1C4: using guessed type int dword_805D1C4;

//----- (080537D0) --------------------------------------------------------
#error "8053BF3: call analysis failed (funcsize=276)"

//----- (08053D4F) --------------------------------------------------------
const char *sub_8053D4F()
{
  char *v0; // ST1C_4
  const char *s1; // [esp+18h] [ebp-10h]
  char *s2; // [esp+1Ch] [ebp-Ch]

  s1 = nl_langinfo(14);
  if ( !s1 )
    s1 = (const char *)&unk_8058ABF;
  for ( s2 = (char *)sub_80537D0(); *s2; s2 = &v0[strlen(v0) + 1] )
  {
    if ( !strcmp(s1, s2) || *s2 == 42 && !s2[1] )
    {
      s1 = &s2[strlen(s2) + 1];
      break;
    }
    v0 = &s2[strlen(s2) + 1];
  }
  if ( !*s1 )
    s1 = "ASCII";
  return s1;
}
// 80537D0: using guessed type int sub_80537D0(void);

//----- (08053E02) --------------------------------------------------------
int __cdecl sub_8053E02(int a1)
{
  void *v1; // eax

  v1 = &loc_8053E2D;
  if ( !*(_BYTE *)(a1 + 16) )
    v1 = &loc_8053E32;
  dword_805D160 = (int)v1;
  return sub_80570A9();
}
// 80570A9: using guessed type int sub_80570A9(void);
// 805D160: using guessed type int dword_805D160;

//----- (08054181) --------------------------------------------------------
signed int __usercall sub_8054181@<eax>(unsigned int a1@<edx>, int a2@<ecx>, _BYTE *a3, int a4, unsigned int a5, _DWORD *a6)
{
  void *v6; // esp
  unsigned int v7; // eax
  int v9; // [esp+0h] [ebp-38h]
  int v10; // [esp+4h] [ebp-34h]
  int v11; // [esp+8h] [ebp-30h]
  int v12; // [esp+Ch] [ebp-2Ch]
  int v13; // [esp+10h] [ebp-28h]
  unsigned int i; // [esp+14h] [ebp-24h]
  int v15; // [esp+18h] [ebp-20h]
  int v16; // [esp+1Ch] [ebp-1Ch]
  _BYTE *v17; // [esp+20h] [ebp-18h]
  _BYTE *v18; // [esp+24h] [ebp-14h]
  unsigned int v19; // [esp+28h] [ebp-10h]
  unsigned int v20; // [esp+2Ch] [ebp-Ch]
  int v21; // [esp+30h] [ebp-8h]
  int v22; // [esp+34h] [ebp-4h]
  int savedregs; // [esp+38h] [ebp+0h]

  v19 = a5;
  if ( a5 > 0x1FFFFFFF )
  {
    v7 = 0;
  }
  else if ( 4 * v19 > 0xFB7 )
  {
    v7 = sub_8056486(4 * v19);
  }
  else
  {
    a1 = (4 * (v19 + 2) + 30) % 0x10;
    v6 = alloca(16 * ((4 * (v19 + 2) + 30) / 0x10));
    v7 = 16 * (((unsigned int)&v13 + 3) >> 4) + 8;
  }
  v20 = v7;
  if ( !v7 )
  {
    dword_805D174 = (int)&loc_80543B5;
    sub_8057037(a2, a1, v9);
  }
  *(_DWORD *)(v20 + 4) = 1;
  v15 = 0;
  for ( i = 2; i < v19; ++i )
  {
    HIBYTE(v13) = *(_BYTE *)(i - 1 + a4);
    while ( *(_BYTE *)(a4 + v15) != HIBYTE(v13) )
    {
      if ( !v15 )
      {
        *(_DWORD *)(v20 + 4 * i) = i;
        dword_805D19C = (int)&loc_80542F2;
        sub_8056F2E(v9, v10, v11, v12, v13, i, v15, v16, v17, v18, v19, v20, v21, v22, savedregs);
      }
      v15 -= *(_DWORD *)(4 * v15 + v20);
    }
    *(_DWORD *)(4 * i + v20) = i - ++v15;
  }
  *a6 = 0;
  v16 = 0;
  v17 = a3;
  v18 = a3;
  while ( *v18 )
  {
    if ( *(_BYTE *)(a4 + v16) == *v18 )
    {
      ++v16;
      ++v18;
      if ( v16 == v19 )
      {
        *a6 = v17;
        break;
      }
    }
    else if ( v16 )
    {
      v17 += *(_DWORD *)(4 * v16 + v20);
      v16 -= *(_DWORD *)(4 * v16 + v20);
    }
    else
    {
      ++v17;
      ++v18;
    }
  }
  sub_8056554(v20);
  return 1;
}
// 8056486: using guessed type _DWORD __cdecl sub_8056486(_DWORD);
// 8056554: using guessed type _DWORD __cdecl sub_8056554(_DWORD);
// 8056F2E: using guessed type int __stdcall sub_8056F2E(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 805D174: using guessed type int dword_805D174;
// 805D19C: using guessed type int dword_805D19C;

//----- (080543BA) --------------------------------------------------------
#error "8054588: call analysis failed (funcsize=496)"

//----- (08054C36) --------------------------------------------------------
unsigned __int8 *__usercall sub_8054C36@<eax>(int a1@<ebx>, unsigned __int8 *a2, _BYTE *a3)
{
  _BOOL4 v3; // eax
  int v4; // edx
  int v5; // ecx
  void *v6; // eax
  int v7; // ebx
  void *v8; // eax
  unsigned __int8 *result; // eax
  _BYTE *v10; // eax
  void *v11; // eax
  int v12; // eax
  bool v13; // zf
  void *v14; // eax
  unsigned int v15; // eax
  int v16; // [esp-8h] [ebp-180h]
  int v17; // [esp-4h] [ebp-17Ch]
  int v18; // [esp+0h] [ebp-178h]
  int v19; // [esp+4h] [ebp-174h]
  int v20; // [esp+8h] [ebp-170h]
  int v21; // [esp+Ch] [ebp-16Ch]
  int v22; // [esp+10h] [ebp-168h]
  int v23; // [esp+14h] [ebp-164h]
  _BYTE *v24; // [esp+18h] [ebp-160h]
  unsigned __int8 *v25; // [esp+1Ch] [ebp-15Ch]
  int v26; // [esp+20h] [ebp-158h]
  int v27; // [esp+24h] [ebp-154h]
  int v28; // [esp+28h] [ebp-150h]
  int v29; // [esp+2Ch] [ebp-14Ch]
  int v30; // [esp+30h] [ebp-148h]
  int v31; // [esp+34h] [ebp-144h]
  int v32; // [esp+38h] [ebp-140h]
  unsigned int v33; // [esp+3Ch] [ebp-13Ch]
  unsigned int v34; // [esp+40h] [ebp-138h]
  unsigned int v35; // [esp+44h] [ebp-134h]
  _BYTE *v36; // [esp+48h] [ebp-130h]
  _BYTE *v37; // [esp+4Ch] [ebp-12Ch]
  _BYTE *i; // [esp+50h] [ebp-128h]
  char v39; // [esp+54h] [ebp-124h]
  int v40; // [esp+58h] [ebp-120h]
  char v41; // [esp+60h] [ebp-118h]
  void *s2; // [esp+64h] [ebp-114h]
  char v43; // [esp+6Ch] [ebp-10Ch]
  int v44; // [esp+70h] [ebp-108h]
  char v45; // [esp+8Ch] [ebp-ECh]
  char v46; // [esp+98h] [ebp-E0h]
  _BYTE *v47; // [esp+9Ch] [ebp-DCh]
  int v48; // [esp+C4h] [ebp-B4h]
  int v49; // [esp+C8h] [ebp-B0h]
  int v50; // [esp+D0h] [ebp-A8h]
  void *s1; // [esp+D4h] [ebp-A4h]
  int v52; // [esp+DCh] [ebp-9Ch]
  int v53; // [esp+E0h] [ebp-98h]
  unsigned int v54; // [esp+16Ch] [ebp-Ch]

  v25 = a2;
  v24 = a3;
  v54 = __readgsdword(0x14u);
  if ( __ctype_get_mb_cur_max() <= 1 )
  {
    if ( *v24 )
    {
      LOBYTE(v27) = 1;
      v33 = 0;
      v34 = 0;
      v35 = 0;
      v36 = v24;
      v10 = v24++;
      BYTE2(v27) = *v10;
      while ( 1 )
      {
        if ( !*v25 )
          return 0;
        v17 = *v25;
        v16 = a1;
        v11 = &loc_80553A2;
        if ( !(_BYTE)v27 )
          v11 = &loc_8055499;
        dword_805D1D8 = (int)v11;
        a1 = v16;
        sub_8056DBD(v18, v19, v20, v21, v22, v23, v24);
        if ( v33 > 9 && 5 * v33 <= v34 )
        {
          if ( v36 )
          {
            v12 = strnlen(v36, v34 - v35);
            v36 += v12;
            v13 = *v36 == 0;
            v17 = (unsigned __int8)*v36;
            v14 = &loc_805541F;
            if ( !v13 )
              v14 = &loc_8055429;
            dword_805D160 = (int)v14;
            a1 = v16;
            sub_80570A9();
            v36 = 0;
            v35 = v34;
          }
          if ( !v36 )
          {
            v15 = strlen(v24 - 1);
            HIBYTE(v27) = sub_8054181((unsigned int)&v28, (int)(v24 - 1), v25, (int)(v24 - 1), v15, &v28);
            if ( HIBYTE(v27) )
              return (unsigned __int8 *)v28;
            LOBYTE(v27) = 0;
          }
        }
        ++v33;
        ++v34;
        if ( *v25 == BYTE2(v27) )
          break;
        ++v25;
      }
      v37 = v25 + 1;
      for ( i = v24; ; ++i )
      {
        if ( !*i )
          return v25;
        if ( !*v37 )
          break;
        ++v34;
        if ( *v37 != *i )
        {
          dword_805D214 = (int)&loc_8055544;
          sub_8056C61();
        }
        ++v37;
      }
      result = 0;
    }
    else
    {
      result = v25;
    }
  }
  else
  {
    s2 = v24;
    v39 = 0;
    memset(&v40, 0, 8u);
    v41 = 0;
    sub_8055570(&v39);
    v3 = v43 != 1 || v44;
    if ( v3 )
    {
      HIBYTE(v26) = 1;
      v29 = 0;
      v30 = 0;
      v31 = 0;
      v47 = v24;
      v45 = 0;
      memset(&v18 - 58, 0, 8u);
      v46 = 0;
      s1 = v25;
      LOBYTE(v48) = 0;
      memset(&v49, 0, 8u);
      LOBYTE(v50) = 0;
      sub_8055570(&v48);
      v17 = (unsigned __int8)v52 ^ 1;
      v16 = a1;
      v6 = &loc_8054DF0;
      if ( (_BYTE)v52 != 1 )
        v6 = &loc_8054DFA;
      dword_805D200 = (int)v6;
      v7 = v16;
      sub_8056CD9(v5, v4);
      v17 = v53 != 0;
      v16 = v7;
      v8 = &loc_8054E23;
      if ( v53 )
        v8 = &loc_8054E2D;
      dword_805D19C = (int)v8;
      sub_8056F2E(v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32);
      result = 0;
    }
    else
    {
      result = v25;
    }
  }
  return result;
}
// 80493D0: using guessed type int __cdecl strnlen(_DWORD, _DWORD);
// 8055570: using guessed type _DWORD __cdecl sub_8055570(_DWORD);
// 8056C61: using guessed type int sub_8056C61(void);
// 8056DBD: using guessed type int __stdcall sub_8056DBD(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8056F2E: using guessed type int __stdcall sub_8056F2E(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80570A9: using guessed type int sub_80570A9(void);
// 805D160: using guessed type int dword_805D160;
// 805D19C: using guessed type int dword_805D19C;
// 805D1D8: using guessed type int dword_805D1D8;
// 805D200: using guessed type int dword_805D200;
// 805D214: using guessed type int dword_805D214;

//----- (08055570) --------------------------------------------------------
#error "8055590: call analysis failed (funcsize=149)"

//----- (0805585E) --------------------------------------------------------
#error "8055942: call analysis failed (funcsize=211)"

//----- (08055CD8) --------------------------------------------------------
#error "8055F9D: call analysis failed (funcsize=232)"

//----- (0805603E) --------------------------------------------------------
#error "80560AD: call analysis failed (funcsize=84)"

//----- (0805614E) --------------------------------------------------------
int __cdecl sub_805614E(void *s, size_t n)
{
  _BYTE *v2; // eax
  int v3; // edx
  int v4; // ecx
  bool v5; // zf
  void *v6; // eax
  _BYTE *v8; // [esp+1Ch] [ebp-Ch]

  v2 = memchr(s, 0, n);
  v8 = v2;
  v5 = v2 == 0;
  v6 = &loc_8056190;
  if ( v5 )
    v6 = &loc_805619F;
  dword_805D200 = (int)v6;
  sub_8056CD9(v4, v3);
  return v8 - (_BYTE *)s + 1;
}
// 805D200: using guessed type int dword_805D200;

//----- (08056450) --------------------------------------------------------
int __cdecl sub_8056450(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 65) > 0x19 )
    result = a1;
  else
    result = a1 + 32;
  return result;
}

//----- (08056486) --------------------------------------------------------
#error "80564F1: call analysis failed (funcsize=36)"

//----- (08056554) --------------------------------------------------------
#error "805659C: call analysis failed (funcsize=30)"

//----- (08056661) --------------------------------------------------------
int __cdecl sub_8056661(int a1, int a2)
{
  void *v2; // eax
  int result; // eax

  if ( *(_DWORD *)a2 == a2 + 16 )
  {
    memcpy((void *)(a1 + 16), (const void *)(a2 + 16), *(_DWORD *)(a2 + 4));
    *(_DWORD *)a1 = a1 + 16;
  }
  else
  {
    *(_DWORD *)a1 = *(_DWORD *)a2;
  }
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  *(_BYTE *)(a1 + 8) = *(_BYTE *)(a2 + 8);
  v2 = &loc_805670C;
  if ( !*(_BYTE *)(a1 + 8) )
    v2 = &locret_8056718;
  dword_805D214 = (int)v2;
  sub_8056C61();
  result = a1;
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
  return result;
}
// 8056C61: using guessed type int sub_8056C61(void);
// 805D214: using guessed type int dword_805D214;

//----- (0805671A) --------------------------------------------------------
bool __cdecl sub_805671A(unsigned __int8 a1)
{
  return (((unsigned int)dword_8058C80[a1 >> 5] >> (a1 & 0x1F)) & 1) != 0;
}

//----- (08056781) --------------------------------------------------------
size_t __cdecl sub_8056781(const char *a1)
{
  _BOOL4 v1; // eax
  int v3; // [esp+10h] [ebp-48h]
  char v4; // [esp+14h] [ebp-44h]
  int v5; // [esp+18h] [ebp-40h]
  char i; // [esp+20h] [ebp-38h]
  const char *v7; // [esp+24h] [ebp-34h]
  int v8; // [esp+28h] [ebp-30h]
  char v9; // [esp+2Ch] [ebp-2Ch]
  int v10; // [esp+30h] [ebp-28h]
  unsigned int v11; // [esp+4Ch] [ebp-Ch]

  v11 = __readgsdword(0x14u);
  if ( __ctype_get_mb_cur_max() <= 1 )
    return strlen(a1);
  v3 = 0;
  v7 = a1;
  v4 = 0;
  memset(&v5, 0, 8u);
  for ( i = 0; ; i = 0 )
  {
    sub_8055570(&v4);
    v1 = v9 != 1 || v10;
    if ( !v1 )
      break;
    ++v3;
    v7 += v8;
  }
  return v3;
}
// 8055570: using guessed type _DWORD __cdecl sub_8055570(_DWORD);

//----- (08056844) --------------------------------------------------------
#error "8056902: call analysis failed (funcsize=146)"

//----- (08056A9F) --------------------------------------------------------
int __cdecl sub_8056A9F(int a1)
{
  return __cxa_atexit(a1, 0, dword_805D244);
}
// 80491F0: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 805D244: using guessed type int dword_805D244;

//----- (08056ACE) --------------------------------------------------------
int __cdecl sub_8056ACE(int a1, int a2)
{
  return __fxstat64(3, a1, a2);
}
// 8049190: using guessed type int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD);

//----- (08056B9D) --------------------------------------------------------
#error "8056BD6: positive sp value has been found (funcsize=18)"

//----- (08056C20) --------------------------------------------------------
#error "8056C59: positive sp value has been found (funcsize=18)"

//----- (08056C61) --------------------------------------------------------
#error "8056C67: positive sp value has been found (funcsize=0)"

//----- (08056CD9) --------------------------------------------------------
#error "8056CDF: positive sp value has been found (funcsize=0)"

//----- (08056D4D) --------------------------------------------------------
#error "8056D53: positive sp value has been found (funcsize=0)"

//----- (08056DBD) --------------------------------------------------------
#error "8056DC3: positive sp value has been found (funcsize=0)"

//----- (08056E09) --------------------------------------------------------
#error "8056E42: positive sp value has been found (funcsize=18)"

//----- (08056E4A) --------------------------------------------------------
#error "8056E50: positive sp value has been found (funcsize=0)"

//----- (08056EB8) --------------------------------------------------------
#error "8056EBE: positive sp value has been found (funcsize=0)"

//----- (08056F2E) --------------------------------------------------------
#error "8056F34: positive sp value has been found (funcsize=0)"

//----- (08056FC1) --------------------------------------------------------
#error "8056FC7: positive sp value has been found (funcsize=0)"

//----- (08057037) --------------------------------------------------------
#error "805703D: positive sp value has been found (funcsize=0)"

//----- (080570A9) --------------------------------------------------------
#error "80570AF: positive sp value has been found (funcsize=0)"

//----- (080570C0) --------------------------------------------------------
int (**sub_80570C0())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_805CED4;
  v1 = &off_805CED8 - off_805CED4;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_805CED4[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 805CED4: using guessed type int (*off_805CED4[2])();
// 805CED8: using guessed type int (*off_805CED8)();

//----- (08057124) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 57 decompilation failure(s) on 178 function(s)"
